{
  "module_name": "ptp_ocp.c",
  "hash_id": "adc628f6b9b9993d10f85a3046fb6d51b754ec26095f860aa8e6abd91fc3b150",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_ocp.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/serial_8250.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/i2c-xiic.h>\n#include <linux/platform_data/i2c-ocores.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/xilinx_spi.h>\n#include <linux/spi/altera.h>\n#include <net/devlink.h>\n#include <linux/i2c.h>\n#include <linux/mtd/mtd.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/crc16.h>\n\n#define PCI_VENDOR_ID_FACEBOOK\t\t\t0x1d9b\n#define PCI_DEVICE_ID_FACEBOOK_TIMECARD\t\t0x0400\n\n#define PCI_VENDOR_ID_CELESTICA\t\t\t0x18d4\n#define PCI_DEVICE_ID_CELESTICA_TIMECARD\t0x1008\n\n#define PCI_VENDOR_ID_OROLIA\t\t\t0x1ad7\n#define PCI_DEVICE_ID_OROLIA_ARTCARD\t\t0xa000\n\nstatic struct class timecard_class = {\n\t.name\t\t= \"timecard\",\n};\n\nstruct ocp_reg {\n\tu32\tctrl;\n\tu32\tstatus;\n\tu32\tselect;\n\tu32\tversion;\n\tu32\ttime_ns;\n\tu32\ttime_sec;\n\tu32\t__pad0[2];\n\tu32\tadjust_ns;\n\tu32\tadjust_sec;\n\tu32\t__pad1[2];\n\tu32\toffset_ns;\n\tu32\toffset_window_ns;\n\tu32\t__pad2[2];\n\tu32\tdrift_ns;\n\tu32\tdrift_window_ns;\n\tu32\t__pad3[6];\n\tu32\tservo_offset_p;\n\tu32\tservo_offset_i;\n\tu32\tservo_drift_p;\n\tu32\tservo_drift_i;\n\tu32\tstatus_offset;\n\tu32\tstatus_drift;\n};\n\n#define OCP_CTRL_ENABLE\t\tBIT(0)\n#define OCP_CTRL_ADJUST_TIME\tBIT(1)\n#define OCP_CTRL_ADJUST_OFFSET\tBIT(2)\n#define OCP_CTRL_ADJUST_DRIFT\tBIT(3)\n#define OCP_CTRL_ADJUST_SERVO\tBIT(8)\n#define OCP_CTRL_READ_TIME_REQ\tBIT(30)\n#define OCP_CTRL_READ_TIME_DONE\tBIT(31)\n\n#define OCP_STATUS_IN_SYNC\tBIT(0)\n#define OCP_STATUS_IN_HOLDOVER\tBIT(1)\n\n#define OCP_SELECT_CLK_NONE\t0\n#define OCP_SELECT_CLK_REG\t0xfe\n\nstruct tod_reg {\n\tu32\tctrl;\n\tu32\tstatus;\n\tu32\tuart_polarity;\n\tu32\tversion;\n\tu32\tadj_sec;\n\tu32\t__pad0[3];\n\tu32\tuart_baud;\n\tu32\t__pad1[3];\n\tu32\tutc_status;\n\tu32\tleap;\n};\n\n#define TOD_CTRL_PROTOCOL\tBIT(28)\n#define TOD_CTRL_DISABLE_FMT_A\tBIT(17)\n#define TOD_CTRL_DISABLE_FMT_B\tBIT(16)\n#define TOD_CTRL_ENABLE\t\tBIT(0)\n#define TOD_CTRL_GNSS_MASK\tGENMASK(3, 0)\n#define TOD_CTRL_GNSS_SHIFT\t24\n\n#define TOD_STATUS_UTC_MASK\t\tGENMASK(7, 0)\n#define TOD_STATUS_UTC_VALID\t\tBIT(8)\n#define TOD_STATUS_LEAP_ANNOUNCE\tBIT(12)\n#define TOD_STATUS_LEAP_VALID\t\tBIT(16)\n\nstruct ts_reg {\n\tu32\tenable;\n\tu32\terror;\n\tu32\tpolarity;\n\tu32\tversion;\n\tu32\t__pad0[4];\n\tu32\tcable_delay;\n\tu32\t__pad1[3];\n\tu32\tintr;\n\tu32\tintr_mask;\n\tu32\tevent_count;\n\tu32\t__pad2[1];\n\tu32\tts_count;\n\tu32\ttime_ns;\n\tu32\ttime_sec;\n\tu32\tdata_width;\n\tu32\tdata;\n};\n\nstruct pps_reg {\n\tu32\tctrl;\n\tu32\tstatus;\n\tu32\t__pad0[6];\n\tu32\tcable_delay;\n};\n\n#define PPS_STATUS_FILTER_ERR\tBIT(0)\n#define PPS_STATUS_SUPERV_ERR\tBIT(1)\n\nstruct img_reg {\n\tu32\tversion;\n};\n\nstruct gpio_reg {\n\tu32\tgpio1;\n\tu32\t__pad0;\n\tu32\tgpio2;\n\tu32\t__pad1;\n};\n\nstruct irig_master_reg {\n\tu32\tctrl;\n\tu32\tstatus;\n\tu32\t__pad0;\n\tu32\tversion;\n\tu32\tadj_sec;\n\tu32\tmode_ctrl;\n};\n\n#define IRIG_M_CTRL_ENABLE\tBIT(0)\n\nstruct irig_slave_reg {\n\tu32\tctrl;\n\tu32\tstatus;\n\tu32\t__pad0;\n\tu32\tversion;\n\tu32\tadj_sec;\n\tu32\tmode_ctrl;\n};\n\n#define IRIG_S_CTRL_ENABLE\tBIT(0)\n\nstruct dcf_master_reg {\n\tu32\tctrl;\n\tu32\tstatus;\n\tu32\t__pad0;\n\tu32\tversion;\n\tu32\tadj_sec;\n};\n\n#define DCF_M_CTRL_ENABLE\tBIT(0)\n\nstruct dcf_slave_reg {\n\tu32\tctrl;\n\tu32\tstatus;\n\tu32\t__pad0;\n\tu32\tversion;\n\tu32\tadj_sec;\n};\n\n#define DCF_S_CTRL_ENABLE\tBIT(0)\n\nstruct signal_reg {\n\tu32\tenable;\n\tu32\tstatus;\n\tu32\tpolarity;\n\tu32\tversion;\n\tu32\t__pad0[4];\n\tu32\tcable_delay;\n\tu32\t__pad1[3];\n\tu32\tintr;\n\tu32\tintr_mask;\n\tu32\t__pad2[2];\n\tu32\tstart_ns;\n\tu32\tstart_sec;\n\tu32\tpulse_ns;\n\tu32\tpulse_sec;\n\tu32\tperiod_ns;\n\tu32\tperiod_sec;\n\tu32\trepeat_count;\n};\n\nstruct frequency_reg {\n\tu32\tctrl;\n\tu32\tstatus;\n};\n\nstruct board_config_reg {\n\tu32 mro50_serial_activate;\n};\n\n#define FREQ_STATUS_VALID\tBIT(31)\n#define FREQ_STATUS_ERROR\tBIT(30)\n#define FREQ_STATUS_OVERRUN\tBIT(29)\n#define FREQ_STATUS_MASK\tGENMASK(23, 0)\n\nstruct ptp_ocp_flash_info {\n\tconst char *name;\n\tint pci_offset;\n\tint data_size;\n\tvoid *data;\n};\n\nstruct ptp_ocp_firmware_header {\n\tchar magic[4];\n\t__be16 pci_vendor_id;\n\t__be16 pci_device_id;\n\t__be32 image_size;\n\t__be16 hw_revision;\n\t__be16 crc;\n};\n\n#define OCP_FIRMWARE_MAGIC_HEADER \"OCPC\"\n\nstruct ptp_ocp_i2c_info {\n\tconst char *name;\n\tunsigned long fixed_rate;\n\tsize_t data_size;\n\tvoid *data;\n};\n\nstruct ptp_ocp_ext_info {\n\tint index;\n\tirqreturn_t (*irq_fcn)(int irq, void *priv);\n\tint (*enable)(void *priv, u32 req, bool enable);\n};\n\nstruct ptp_ocp_ext_src {\n\tvoid __iomem\t\t*mem;\n\tstruct ptp_ocp\t\t*bp;\n\tstruct ptp_ocp_ext_info\t*info;\n\tint\t\t\tirq_vec;\n};\n\nenum ptp_ocp_sma_mode {\n\tSMA_MODE_IN,\n\tSMA_MODE_OUT,\n};\n\nstruct ptp_ocp_sma_connector {\n\tenum\tptp_ocp_sma_mode mode;\n\tbool\tfixed_fcn;\n\tbool\tfixed_dir;\n\tbool\tdisabled;\n\tu8\tdefault_fcn;\n};\n\nstruct ocp_attr_group {\n\tu64 cap;\n\tconst struct attribute_group *group;\n};\n\n#define OCP_CAP_BASIC\tBIT(0)\n#define OCP_CAP_SIGNAL\tBIT(1)\n#define OCP_CAP_FREQ\tBIT(2)\n\nstruct ptp_ocp_signal {\n\tktime_t\t\tperiod;\n\tktime_t\t\tpulse;\n\tktime_t\t\tphase;\n\tktime_t\t\tstart;\n\tint\t\tduty;\n\tbool\t\tpolarity;\n\tbool\t\trunning;\n};\n\nstruct ptp_ocp_serial_port {\n\tint line;\n\tint baud;\n};\n\n#define OCP_BOARD_ID_LEN\t\t13\n#define OCP_SERIAL_LEN\t\t\t6\n\nstruct ptp_ocp {\n\tstruct pci_dev\t\t*pdev;\n\tstruct device\t\tdev;\n\tspinlock_t\t\tlock;\n\tstruct ocp_reg __iomem\t*reg;\n\tstruct tod_reg __iomem\t*tod;\n\tstruct pps_reg __iomem\t*pps_to_ext;\n\tstruct pps_reg __iomem\t*pps_to_clk;\n\tstruct board_config_reg __iomem\t*board_config;\n\tstruct gpio_reg __iomem\t*pps_select;\n\tstruct gpio_reg __iomem\t*sma_map1;\n\tstruct gpio_reg __iomem\t*sma_map2;\n\tstruct irig_master_reg\t__iomem *irig_out;\n\tstruct irig_slave_reg\t__iomem *irig_in;\n\tstruct dcf_master_reg\t__iomem *dcf_out;\n\tstruct dcf_slave_reg\t__iomem *dcf_in;\n\tstruct tod_reg\t\t__iomem *nmea_out;\n\tstruct frequency_reg\t__iomem *freq_in[4];\n\tstruct ptp_ocp_ext_src\t*signal_out[4];\n\tstruct ptp_ocp_ext_src\t*pps;\n\tstruct ptp_ocp_ext_src\t*ts0;\n\tstruct ptp_ocp_ext_src\t*ts1;\n\tstruct ptp_ocp_ext_src\t*ts2;\n\tstruct ptp_ocp_ext_src\t*ts3;\n\tstruct ptp_ocp_ext_src\t*ts4;\n\tstruct ocp_art_gpio_reg __iomem *art_sma;\n\tstruct img_reg __iomem\t*image;\n\tstruct ptp_clock\t*ptp;\n\tstruct ptp_clock_info\tptp_info;\n\tstruct platform_device\t*i2c_ctrl;\n\tstruct platform_device\t*spi_flash;\n\tstruct clk_hw\t\t*i2c_clk;\n\tstruct timer_list\twatchdog;\n\tconst struct attribute_group **attr_group;\n\tconst struct ptp_ocp_eeprom_map *eeprom_map;\n\tstruct dentry\t\t*debug_root;\n\ttime64_t\t\tgnss_lost;\n\tint\t\t\tid;\n\tint\t\t\tn_irqs;\n\tstruct ptp_ocp_serial_port\tgnss_port;\n\tstruct ptp_ocp_serial_port\tgnss2_port;\n\tstruct ptp_ocp_serial_port\tmac_port;    \n\tstruct ptp_ocp_serial_port\tnmea_port;\n\tbool\t\t\tfw_loader;\n\tu8\t\t\tfw_tag;\n\tu16\t\t\tfw_version;\n\tu8\t\t\tboard_id[OCP_BOARD_ID_LEN];\n\tu8\t\t\tserial[OCP_SERIAL_LEN];\n\tbool\t\t\thas_eeprom_data;\n\tu32\t\t\tpps_req_map;\n\tint\t\t\tflash_start;\n\tu32\t\t\tutc_tai_offset;\n\tu32\t\t\tts_window_adjust;\n\tu64\t\t\tfw_cap;\n\tstruct ptp_ocp_signal\tsignal[4];\n\tstruct ptp_ocp_sma_connector sma[4];\n\tconst struct ocp_sma_op *sma_op;\n};\n\n#define OCP_REQ_TIMESTAMP\tBIT(0)\n#define OCP_REQ_PPS\t\tBIT(1)\n\nstruct ocp_resource {\n\tunsigned long offset;\n\tint size;\n\tint irq_vec;\n\tint (*setup)(struct ptp_ocp *bp, struct ocp_resource *r);\n\tvoid *extra;\n\tunsigned long bp_offset;\n\tconst char * const name;\n};\n\nstatic int ptp_ocp_register_mem(struct ptp_ocp *bp, struct ocp_resource *r);\nstatic int ptp_ocp_register_i2c(struct ptp_ocp *bp, struct ocp_resource *r);\nstatic int ptp_ocp_register_spi(struct ptp_ocp *bp, struct ocp_resource *r);\nstatic int ptp_ocp_register_serial(struct ptp_ocp *bp, struct ocp_resource *r);\nstatic int ptp_ocp_register_ext(struct ptp_ocp *bp, struct ocp_resource *r);\nstatic int ptp_ocp_fb_board_init(struct ptp_ocp *bp, struct ocp_resource *r);\nstatic irqreturn_t ptp_ocp_ts_irq(int irq, void *priv);\nstatic irqreturn_t ptp_ocp_signal_irq(int irq, void *priv);\nstatic int ptp_ocp_ts_enable(void *priv, u32 req, bool enable);\nstatic int ptp_ocp_signal_from_perout(struct ptp_ocp *bp, int gen,\n\t\t\t\t      struct ptp_perout_request *req);\nstatic int ptp_ocp_signal_enable(void *priv, u32 req, bool enable);\nstatic int ptp_ocp_sma_store(struct ptp_ocp *bp, const char *buf, int sma_nr);\n\nstatic int ptp_ocp_art_board_init(struct ptp_ocp *bp, struct ocp_resource *r);\n\nstatic const struct ocp_attr_group fb_timecard_groups[];\n\nstatic const struct ocp_attr_group art_timecard_groups[];\n\nstruct ptp_ocp_eeprom_map {\n\tu16\toff;\n\tu16\tlen;\n\tu32\tbp_offset;\n\tconst void * const tag;\n};\n\n#define EEPROM_ENTRY(addr, member)\t\t\t\t\\\n\t.off = addr,\t\t\t\t\t\t\\\n\t.len = sizeof_field(struct ptp_ocp, member),\t\t\\\n\t.bp_offset = offsetof(struct ptp_ocp, member)\n\n#define BP_MAP_ENTRY_ADDR(bp, map) ({\t\t\t\t\\\n\t(void *)((uintptr_t)(bp) + (map)->bp_offset);\t\t\\\n})\n\nstatic struct ptp_ocp_eeprom_map fb_eeprom_map[] = {\n\t{ EEPROM_ENTRY(0x43, board_id) },\n\t{ EEPROM_ENTRY(0x00, serial), .tag = \"mac\" },\n\t{ }\n};\n\nstatic struct ptp_ocp_eeprom_map art_eeprom_map[] = {\n\t{ EEPROM_ENTRY(0x200 + 0x43, board_id) },\n\t{ EEPROM_ENTRY(0x200 + 0x63, serial) },\n\t{ }\n};\n\n#define bp_assign_entry(bp, res, val) ({\t\t\t\t\\\n\tuintptr_t addr = (uintptr_t)(bp) + (res)->bp_offset;\t\t\\\n\t*(typeof(val) *)addr = val;\t\t\t\t\t\\\n})\n\n#define OCP_RES_LOCATION(member) \\\n\t.name = #member, .bp_offset = offsetof(struct ptp_ocp, member)\n\n#define OCP_MEM_RESOURCE(member) \\\n\tOCP_RES_LOCATION(member), .setup = ptp_ocp_register_mem\n\n#define OCP_SERIAL_RESOURCE(member) \\\n\tOCP_RES_LOCATION(member), .setup = ptp_ocp_register_serial\n\n#define OCP_I2C_RESOURCE(member) \\\n\tOCP_RES_LOCATION(member), .setup = ptp_ocp_register_i2c\n\n#define OCP_SPI_RESOURCE(member) \\\n\tOCP_RES_LOCATION(member), .setup = ptp_ocp_register_spi\n\n#define OCP_EXT_RESOURCE(member) \\\n\tOCP_RES_LOCATION(member), .setup = ptp_ocp_register_ext\n\n \n\nstatic struct ocp_resource ocp_fb_resource[] = {\n\t{\n\t\tOCP_MEM_RESOURCE(reg),\n\t\t.offset = 0x01000000, .size = 0x10000,\n\t},\n\t{\n\t\tOCP_EXT_RESOURCE(ts0),\n\t\t.offset = 0x01010000, .size = 0x10000, .irq_vec = 1,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 0,\n\t\t\t.irq_fcn = ptp_ocp_ts_irq,\n\t\t\t.enable = ptp_ocp_ts_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_EXT_RESOURCE(ts1),\n\t\t.offset = 0x01020000, .size = 0x10000, .irq_vec = 2,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 1,\n\t\t\t.irq_fcn = ptp_ocp_ts_irq,\n\t\t\t.enable = ptp_ocp_ts_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_EXT_RESOURCE(ts2),\n\t\t.offset = 0x01060000, .size = 0x10000, .irq_vec = 6,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 2,\n\t\t\t.irq_fcn = ptp_ocp_ts_irq,\n\t\t\t.enable = ptp_ocp_ts_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_EXT_RESOURCE(ts3),\n\t\t.offset = 0x01110000, .size = 0x10000, .irq_vec = 15,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 3,\n\t\t\t.irq_fcn = ptp_ocp_ts_irq,\n\t\t\t.enable = ptp_ocp_ts_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_EXT_RESOURCE(ts4),\n\t\t.offset = 0x01120000, .size = 0x10000, .irq_vec = 16,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 4,\n\t\t\t.irq_fcn = ptp_ocp_ts_irq,\n\t\t\t.enable = ptp_ocp_ts_enable,\n\t\t},\n\t},\n\t \n\t{\n\t\tOCP_EXT_RESOURCE(pps),\n\t\t.offset = 0x010C0000, .size = 0x10000, .irq_vec = 0,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 5,\n\t\t\t.irq_fcn = ptp_ocp_ts_irq,\n\t\t\t.enable = ptp_ocp_ts_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_EXT_RESOURCE(signal_out[0]),\n\t\t.offset = 0x010D0000, .size = 0x10000, .irq_vec = 11,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 1,\n\t\t\t.irq_fcn = ptp_ocp_signal_irq,\n\t\t\t.enable = ptp_ocp_signal_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_EXT_RESOURCE(signal_out[1]),\n\t\t.offset = 0x010E0000, .size = 0x10000, .irq_vec = 12,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 2,\n\t\t\t.irq_fcn = ptp_ocp_signal_irq,\n\t\t\t.enable = ptp_ocp_signal_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_EXT_RESOURCE(signal_out[2]),\n\t\t.offset = 0x010F0000, .size = 0x10000, .irq_vec = 13,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 3,\n\t\t\t.irq_fcn = ptp_ocp_signal_irq,\n\t\t\t.enable = ptp_ocp_signal_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_EXT_RESOURCE(signal_out[3]),\n\t\t.offset = 0x01100000, .size = 0x10000, .irq_vec = 14,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 4,\n\t\t\t.irq_fcn = ptp_ocp_signal_irq,\n\t\t\t.enable = ptp_ocp_signal_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(pps_to_ext),\n\t\t.offset = 0x01030000, .size = 0x10000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(pps_to_clk),\n\t\t.offset = 0x01040000, .size = 0x10000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(tod),\n\t\t.offset = 0x01050000, .size = 0x10000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(irig_in),\n\t\t.offset = 0x01070000, .size = 0x10000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(irig_out),\n\t\t.offset = 0x01080000, .size = 0x10000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(dcf_in),\n\t\t.offset = 0x01090000, .size = 0x10000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(dcf_out),\n\t\t.offset = 0x010A0000, .size = 0x10000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(nmea_out),\n\t\t.offset = 0x010B0000, .size = 0x10000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(image),\n\t\t.offset = 0x00020000, .size = 0x1000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(pps_select),\n\t\t.offset = 0x00130000, .size = 0x1000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(sma_map1),\n\t\t.offset = 0x00140000, .size = 0x1000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(sma_map2),\n\t\t.offset = 0x00220000, .size = 0x1000,\n\t},\n\t{\n\t\tOCP_I2C_RESOURCE(i2c_ctrl),\n\t\t.offset = 0x00150000, .size = 0x10000, .irq_vec = 7,\n\t\t.extra = &(struct ptp_ocp_i2c_info) {\n\t\t\t.name = \"xiic-i2c\",\n\t\t\t.fixed_rate = 50000000,\n\t\t\t.data_size = sizeof(struct xiic_i2c_platform_data),\n\t\t\t.data = &(struct xiic_i2c_platform_data) {\n\t\t\t\t.num_devices = 2,\n\t\t\t\t.devices = (struct i2c_board_info[]) {\n\t\t\t\t\t{ I2C_BOARD_INFO(\"24c02\", 0x50) },\n\t\t\t\t\t{ I2C_BOARD_INFO(\"24mac402\", 0x58),\n\t\t\t\t\t  .platform_data = \"mac\" },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tOCP_SERIAL_RESOURCE(gnss_port),\n\t\t.offset = 0x00160000 + 0x1000, .irq_vec = 3,\n\t\t.extra = &(struct ptp_ocp_serial_port) {\n\t\t\t.baud = 115200,\n\t\t},\n\t},\n\t{\n\t\tOCP_SERIAL_RESOURCE(gnss2_port),\n\t\t.offset = 0x00170000 + 0x1000, .irq_vec = 4,\n\t\t.extra = &(struct ptp_ocp_serial_port) {\n\t\t\t.baud = 115200,\n\t\t},\n\t},\n\t{\n\t\tOCP_SERIAL_RESOURCE(mac_port),\n\t\t.offset = 0x00180000 + 0x1000, .irq_vec = 5,\n\t\t.extra = &(struct ptp_ocp_serial_port) {\n\t\t\t.baud = 57600,\n\t\t},\n\t},\n\t{\n\t\tOCP_SERIAL_RESOURCE(nmea_port),\n\t\t.offset = 0x00190000 + 0x1000, .irq_vec = 10,\n\t},\n\t{\n\t\tOCP_SPI_RESOURCE(spi_flash),\n\t\t.offset = 0x00310000, .size = 0x10000, .irq_vec = 9,\n\t\t.extra = &(struct ptp_ocp_flash_info) {\n\t\t\t.name = \"xilinx_spi\", .pci_offset = 0,\n\t\t\t.data_size = sizeof(struct xspi_platform_data),\n\t\t\t.data = &(struct xspi_platform_data) {\n\t\t\t\t.num_chipselect = 1,\n\t\t\t\t.bits_per_word = 8,\n\t\t\t\t.num_devices = 1,\n\t\t\t\t.force_irq = true,\n\t\t\t\t.devices = &(struct spi_board_info) {\n\t\t\t\t\t.modalias = \"spi-nor\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(freq_in[0]),\n\t\t.offset = 0x01200000, .size = 0x10000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(freq_in[1]),\n\t\t.offset = 0x01210000, .size = 0x10000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(freq_in[2]),\n\t\t.offset = 0x01220000, .size = 0x10000,\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(freq_in[3]),\n\t\t.offset = 0x01230000, .size = 0x10000,\n\t},\n\t{\n\t\t.setup = ptp_ocp_fb_board_init,\n\t},\n\t{ }\n};\n\n#define OCP_ART_CONFIG_SIZE\t\t144\n#define OCP_ART_TEMP_TABLE_SIZE\t\t368\n\nstruct ocp_art_gpio_reg {\n\tstruct {\n\t\tu32\tgpio;\n\t\tu32\t__pad[3];\n\t} map[4];\n};\n\nstatic struct ocp_resource ocp_art_resource[] = {\n\t{\n\t\tOCP_MEM_RESOURCE(reg),\n\t\t.offset = 0x01000000, .size = 0x10000,\n\t},\n\t{\n\t\tOCP_SERIAL_RESOURCE(gnss_port),\n\t\t.offset = 0x00160000 + 0x1000, .irq_vec = 3,\n\t\t.extra = &(struct ptp_ocp_serial_port) {\n\t\t\t.baud = 115200,\n\t\t},\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(art_sma),\n\t\t.offset = 0x003C0000, .size = 0x1000,\n\t},\n\t \n\t{\n\t\tOCP_EXT_RESOURCE(ts0),\n\t\t.offset = 0x360000, .size = 0x20, .irq_vec = 12,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 0,\n\t\t\t.irq_fcn = ptp_ocp_ts_irq,\n\t\t\t.enable = ptp_ocp_ts_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_EXT_RESOURCE(ts1),\n\t\t.offset = 0x380000, .size = 0x20, .irq_vec = 8,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 1,\n\t\t\t.irq_fcn = ptp_ocp_ts_irq,\n\t\t\t.enable = ptp_ocp_ts_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_EXT_RESOURCE(ts2),\n\t\t.offset = 0x390000, .size = 0x20, .irq_vec = 10,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 2,\n\t\t\t.irq_fcn = ptp_ocp_ts_irq,\n\t\t\t.enable = ptp_ocp_ts_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_EXT_RESOURCE(ts3),\n\t\t.offset = 0x3A0000, .size = 0x20, .irq_vec = 14,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 3,\n\t\t\t.irq_fcn = ptp_ocp_ts_irq,\n\t\t\t.enable = ptp_ocp_ts_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_EXT_RESOURCE(ts4),\n\t\t.offset = 0x3B0000, .size = 0x20, .irq_vec = 15,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 4,\n\t\t\t.irq_fcn = ptp_ocp_ts_irq,\n\t\t\t.enable = ptp_ocp_ts_enable,\n\t\t},\n\t},\n\t \n\t{\n\t\tOCP_EXT_RESOURCE(pps),\n\t\t.offset = 0x00330000, .size = 0x20, .irq_vec = 11,\n\t\t.extra = &(struct ptp_ocp_ext_info) {\n\t\t\t.index = 5,\n\t\t\t.irq_fcn = ptp_ocp_ts_irq,\n\t\t\t.enable = ptp_ocp_ts_enable,\n\t\t},\n\t},\n\t{\n\t\tOCP_SPI_RESOURCE(spi_flash),\n\t\t.offset = 0x00310000, .size = 0x10000, .irq_vec = 9,\n\t\t.extra = &(struct ptp_ocp_flash_info) {\n\t\t\t.name = \"spi_altera\", .pci_offset = 0,\n\t\t\t.data_size = sizeof(struct altera_spi_platform_data),\n\t\t\t.data = &(struct altera_spi_platform_data) {\n\t\t\t\t.num_chipselect = 1,\n\t\t\t\t.num_devices = 1,\n\t\t\t\t.devices = &(struct spi_board_info) {\n\t\t\t\t\t.modalias = \"spi-nor\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tOCP_I2C_RESOURCE(i2c_ctrl),\n\t\t.offset = 0x350000, .size = 0x100, .irq_vec = 4,\n\t\t.extra = &(struct ptp_ocp_i2c_info) {\n\t\t\t.name = \"ocores-i2c\",\n\t\t\t.fixed_rate = 400000,\n\t\t\t.data_size = sizeof(struct ocores_i2c_platform_data),\n\t\t\t.data = &(struct ocores_i2c_platform_data) {\n\t\t\t\t.clock_khz = 125000,\n\t\t\t\t.bus_khz = 400,\n\t\t\t\t.num_devices = 1,\n\t\t\t\t.devices = &(struct i2c_board_info) {\n\t\t\t\t\tI2C_BOARD_INFO(\"24c08\", 0x50),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tOCP_SERIAL_RESOURCE(mac_port),\n\t\t.offset = 0x00190000, .irq_vec = 7,\n\t\t.extra = &(struct ptp_ocp_serial_port) {\n\t\t\t.baud = 9600,\n\t\t},\n\t},\n\t{\n\t\tOCP_MEM_RESOURCE(board_config),\n\t\t.offset = 0x210000, .size = 0x1000,\n\t},\n\t{\n\t\t.setup = ptp_ocp_art_board_init,\n\t},\n\t{ }\n};\n\nstatic const struct pci_device_id ptp_ocp_pcidev_id[] = {\n\t{ PCI_DEVICE_DATA(FACEBOOK, TIMECARD, &ocp_fb_resource) },\n\t{ PCI_DEVICE_DATA(CELESTICA, TIMECARD, &ocp_fb_resource) },\n\t{ PCI_DEVICE_DATA(OROLIA, ARTCARD, &ocp_art_resource) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, ptp_ocp_pcidev_id);\n\nstatic DEFINE_MUTEX(ptp_ocp_lock);\nstatic DEFINE_IDR(ptp_ocp_idr);\n\nstruct ocp_selector {\n\tconst char *name;\n\tint value;\n};\n\nstatic const struct ocp_selector ptp_ocp_clock[] = {\n\t{ .name = \"NONE\",\t.value = 0 },\n\t{ .name = \"TOD\",\t.value = 1 },\n\t{ .name = \"IRIG\",\t.value = 2 },\n\t{ .name = \"PPS\",\t.value = 3 },\n\t{ .name = \"PTP\",\t.value = 4 },\n\t{ .name = \"RTC\",\t.value = 5 },\n\t{ .name = \"DCF\",\t.value = 6 },\n\t{ .name = \"REGS\",\t.value = 0xfe },\n\t{ .name = \"EXT\",\t.value = 0xff },\n\t{ }\n};\n\n#define SMA_DISABLE\t\tBIT(16)\n#define SMA_ENABLE\t\tBIT(15)\n#define SMA_SELECT_MASK\t\tGENMASK(14, 0)\n\nstatic const struct ocp_selector ptp_ocp_sma_in[] = {\n\t{ .name = \"10Mhz\",\t.value = 0x0000 },\n\t{ .name = \"PPS1\",\t.value = 0x0001 },\n\t{ .name = \"PPS2\",\t.value = 0x0002 },\n\t{ .name = \"TS1\",\t.value = 0x0004 },\n\t{ .name = \"TS2\",\t.value = 0x0008 },\n\t{ .name = \"IRIG\",\t.value = 0x0010 },\n\t{ .name = \"DCF\",\t.value = 0x0020 },\n\t{ .name = \"TS3\",\t.value = 0x0040 },\n\t{ .name = \"TS4\",\t.value = 0x0080 },\n\t{ .name = \"FREQ1\",\t.value = 0x0100 },\n\t{ .name = \"FREQ2\",\t.value = 0x0200 },\n\t{ .name = \"FREQ3\",\t.value = 0x0400 },\n\t{ .name = \"FREQ4\",\t.value = 0x0800 },\n\t{ .name = \"None\",\t.value = SMA_DISABLE },\n\t{ }\n};\n\nstatic const struct ocp_selector ptp_ocp_sma_out[] = {\n\t{ .name = \"10Mhz\",\t.value = 0x0000 },\n\t{ .name = \"PHC\",\t.value = 0x0001 },\n\t{ .name = \"MAC\",\t.value = 0x0002 },\n\t{ .name = \"GNSS1\",\t.value = 0x0004 },\n\t{ .name = \"GNSS2\",\t.value = 0x0008 },\n\t{ .name = \"IRIG\",\t.value = 0x0010 },\n\t{ .name = \"DCF\",\t.value = 0x0020 },\n\t{ .name = \"GEN1\",\t.value = 0x0040 },\n\t{ .name = \"GEN2\",\t.value = 0x0080 },\n\t{ .name = \"GEN3\",\t.value = 0x0100 },\n\t{ .name = \"GEN4\",\t.value = 0x0200 },\n\t{ .name = \"GND\",\t.value = 0x2000 },\n\t{ .name = \"VCC\",\t.value = 0x4000 },\n\t{ }\n};\n\nstatic const struct ocp_selector ptp_ocp_art_sma_in[] = {\n\t{ .name = \"PPS1\",\t.value = 0x0001 },\n\t{ .name = \"10Mhz\",\t.value = 0x0008 },\n\t{ }\n};\n\nstatic const struct ocp_selector ptp_ocp_art_sma_out[] = {\n\t{ .name = \"PHC\",\t.value = 0x0002 },\n\t{ .name = \"GNSS\",\t.value = 0x0004 },\n\t{ .name = \"10Mhz\",\t.value = 0x0010 },\n\t{ }\n};\n\nstruct ocp_sma_op {\n\tconst struct ocp_selector *tbl[2];\n\tvoid (*init)(struct ptp_ocp *bp);\n\tu32 (*get)(struct ptp_ocp *bp, int sma_nr);\n\tint (*set_inputs)(struct ptp_ocp *bp, int sma_nr, u32 val);\n\tint (*set_output)(struct ptp_ocp *bp, int sma_nr, u32 val);\n};\n\nstatic void\nptp_ocp_sma_init(struct ptp_ocp *bp)\n{\n\treturn bp->sma_op->init(bp);\n}\n\nstatic u32\nptp_ocp_sma_get(struct ptp_ocp *bp, int sma_nr)\n{\n\treturn bp->sma_op->get(bp, sma_nr);\n}\n\nstatic int\nptp_ocp_sma_set_inputs(struct ptp_ocp *bp, int sma_nr, u32 val)\n{\n\treturn bp->sma_op->set_inputs(bp, sma_nr, val);\n}\n\nstatic int\nptp_ocp_sma_set_output(struct ptp_ocp *bp, int sma_nr, u32 val)\n{\n\treturn bp->sma_op->set_output(bp, sma_nr, val);\n}\n\nstatic const char *\nptp_ocp_select_name_from_val(const struct ocp_selector *tbl, int val)\n{\n\tint i;\n\n\tfor (i = 0; tbl[i].name; i++)\n\t\tif (tbl[i].value == val)\n\t\t\treturn tbl[i].name;\n\treturn NULL;\n}\n\nstatic int\nptp_ocp_select_val_from_name(const struct ocp_selector *tbl, const char *name)\n{\n\tconst char *select;\n\tint i;\n\n\tfor (i = 0; tbl[i].name; i++) {\n\t\tselect = tbl[i].name;\n\t\tif (!strncasecmp(name, select, strlen(select)))\n\t\t\treturn tbl[i].value;\n\t}\n\treturn -EINVAL;\n}\n\nstatic ssize_t\nptp_ocp_select_table_show(const struct ocp_selector *tbl, char *buf)\n{\n\tssize_t count;\n\tint i;\n\n\tcount = 0;\n\tfor (i = 0; tbl[i].name; i++)\n\t\tcount += sysfs_emit_at(buf, count, \"%s \", tbl[i].name);\n\tif (count)\n\t\tcount--;\n\tcount += sysfs_emit_at(buf, count, \"\\n\");\n\treturn count;\n}\n\nstatic int\n__ptp_ocp_gettime_locked(struct ptp_ocp *bp, struct timespec64 *ts,\n\t\t\t struct ptp_system_timestamp *sts)\n{\n\tu32 ctrl, time_sec, time_ns;\n\tint i;\n\n\tptp_read_system_prets(sts);\n\n\tctrl = OCP_CTRL_READ_TIME_REQ | OCP_CTRL_ENABLE;\n\tiowrite32(ctrl, &bp->reg->ctrl);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tctrl = ioread32(&bp->reg->ctrl);\n\t\tif (ctrl & OCP_CTRL_READ_TIME_DONE)\n\t\t\tbreak;\n\t}\n\tptp_read_system_postts(sts);\n\n\tif (sts && bp->ts_window_adjust) {\n\t\ts64 ns = timespec64_to_ns(&sts->post_ts);\n\n\t\tsts->post_ts = ns_to_timespec64(ns - bp->ts_window_adjust);\n\t}\n\n\ttime_ns = ioread32(&bp->reg->time_ns);\n\ttime_sec = ioread32(&bp->reg->time_sec);\n\n\tts->tv_sec = time_sec;\n\tts->tv_nsec = time_ns;\n\n\treturn ctrl & OCP_CTRL_READ_TIME_DONE ? 0 : -ETIMEDOUT;\n}\n\nstatic int\nptp_ocp_gettimex(struct ptp_clock_info *ptp_info, struct timespec64 *ts,\n\t\t struct ptp_system_timestamp *sts)\n{\n\tstruct ptp_ocp *bp = container_of(ptp_info, struct ptp_ocp, ptp_info);\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\terr = __ptp_ocp_gettime_locked(bp, ts, sts);\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\treturn err;\n}\n\nstatic void\n__ptp_ocp_settime_locked(struct ptp_ocp *bp, const struct timespec64 *ts)\n{\n\tu32 ctrl, time_sec, time_ns;\n\tu32 select;\n\n\ttime_ns = ts->tv_nsec;\n\ttime_sec = ts->tv_sec;\n\n\tselect = ioread32(&bp->reg->select);\n\tiowrite32(OCP_SELECT_CLK_REG, &bp->reg->select);\n\n\tiowrite32(time_ns, &bp->reg->adjust_ns);\n\tiowrite32(time_sec, &bp->reg->adjust_sec);\n\n\tctrl = OCP_CTRL_ADJUST_TIME | OCP_CTRL_ENABLE;\n\tiowrite32(ctrl, &bp->reg->ctrl);\n\n\t \n\tiowrite32(select >> 16, &bp->reg->select);\n}\n\nstatic int\nptp_ocp_settime(struct ptp_clock_info *ptp_info, const struct timespec64 *ts)\n{\n\tstruct ptp_ocp *bp = container_of(ptp_info, struct ptp_ocp, ptp_info);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\t__ptp_ocp_settime_locked(bp, ts);\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\treturn 0;\n}\n\nstatic void\n__ptp_ocp_adjtime_locked(struct ptp_ocp *bp, u32 adj_val)\n{\n\tu32 select, ctrl;\n\n\tselect = ioread32(&bp->reg->select);\n\tiowrite32(OCP_SELECT_CLK_REG, &bp->reg->select);\n\n\tiowrite32(adj_val, &bp->reg->offset_ns);\n\tiowrite32(NSEC_PER_SEC, &bp->reg->offset_window_ns);\n\n\tctrl = OCP_CTRL_ADJUST_OFFSET | OCP_CTRL_ENABLE;\n\tiowrite32(ctrl, &bp->reg->ctrl);\n\n\t \n\tiowrite32(select >> 16, &bp->reg->select);\n}\n\nstatic void\nptp_ocp_adjtime_coarse(struct ptp_ocp *bp, s64 delta_ns)\n{\n\tstruct timespec64 ts;\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\terr = __ptp_ocp_gettime_locked(bp, &ts, NULL);\n\tif (likely(!err)) {\n\t\tset_normalized_timespec64(&ts, ts.tv_sec,\n\t\t\t\t\t  ts.tv_nsec + delta_ns);\n\t\t__ptp_ocp_settime_locked(bp, &ts);\n\t}\n\tspin_unlock_irqrestore(&bp->lock, flags);\n}\n\nstatic int\nptp_ocp_adjtime(struct ptp_clock_info *ptp_info, s64 delta_ns)\n{\n\tstruct ptp_ocp *bp = container_of(ptp_info, struct ptp_ocp, ptp_info);\n\tunsigned long flags;\n\tu32 adj_ns, sign;\n\n\tif (delta_ns > NSEC_PER_SEC || -delta_ns > NSEC_PER_SEC) {\n\t\tptp_ocp_adjtime_coarse(bp, delta_ns);\n\t\treturn 0;\n\t}\n\n\tsign = delta_ns < 0 ? BIT(31) : 0;\n\tadj_ns = sign ? -delta_ns : delta_ns;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\t__ptp_ocp_adjtime_locked(bp, sign | adj_ns);\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\treturn 0;\n}\n\nstatic int\nptp_ocp_null_adjfine(struct ptp_clock_info *ptp_info, long scaled_ppm)\n{\n\tif (scaled_ppm == 0)\n\t\treturn 0;\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic s32\nptp_ocp_null_getmaxphase(struct ptp_clock_info *ptp_info)\n{\n\treturn 0;\n}\n\nstatic int\nptp_ocp_null_adjphase(struct ptp_clock_info *ptp_info, s32 phase_ns)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nptp_ocp_enable(struct ptp_clock_info *ptp_info, struct ptp_clock_request *rq,\n\t       int on)\n{\n\tstruct ptp_ocp *bp = container_of(ptp_info, struct ptp_ocp, ptp_info);\n\tstruct ptp_ocp_ext_src *ext = NULL;\n\tu32 req;\n\tint err;\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\treq = OCP_REQ_TIMESTAMP;\n\t\tswitch (rq->extts.index) {\n\t\tcase 0:\n\t\t\text = bp->ts0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\text = bp->ts1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\text = bp->ts2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\text = bp->ts3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\text = bp->ts4;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\text = bp->pps;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PTP_CLK_REQ_PPS:\n\t\treq = OCP_REQ_PPS;\n\t\text = bp->pps;\n\t\tbreak;\n\tcase PTP_CLK_REQ_PEROUT:\n\t\tswitch (rq->perout.index) {\n\t\tcase 0:\n\t\t\t \n\t\t\tif (on && (rq->perout.period.sec != 1 ||\n\t\t\t\t   rq->perout.period.nsec != 0))\n\t\t\t\treturn -EINVAL;\n\t\t\treturn 0;\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\t\treq = rq->perout.index - 1;\n\t\t\text = bp->signal_out[req];\n\t\t\terr = ptp_ocp_signal_from_perout(bp, req, &rq->perout);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = -ENXIO;\n\tif (ext)\n\t\terr = ext->info->enable(ext, req, on);\n\n\treturn err;\n}\n\nstatic int\nptp_ocp_verify(struct ptp_clock_info *ptp_info, unsigned pin,\n\t       enum ptp_pin_function func, unsigned chan)\n{\n\tstruct ptp_ocp *bp = container_of(ptp_info, struct ptp_ocp, ptp_info);\n\tchar buf[16];\n\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\t\tsnprintf(buf, sizeof(buf), \"IN: None\");\n\t\tbreak;\n\tcase PTP_PF_EXTTS:\n\t\t \n\t\treturn 0;\n\tcase PTP_PF_PEROUT:\n\t\t \n\t\tif (chan)\n\t\t\tsnprintf(buf, sizeof(buf), \"OUT: GEN%d\", chan);\n\t\telse\n\t\t\tsnprintf(buf, sizeof(buf), \"OUT: PHC\");\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ptp_ocp_sma_store(bp, buf, pin + 1);\n}\n\nstatic const struct ptp_clock_info ptp_ocp_clock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= KBUILD_MODNAME,\n\t.max_adj\t= 100000000,\n\t.gettimex64\t= ptp_ocp_gettimex,\n\t.settime64\t= ptp_ocp_settime,\n\t.adjtime\t= ptp_ocp_adjtime,\n\t.adjfine\t= ptp_ocp_null_adjfine,\n\t.adjphase\t= ptp_ocp_null_adjphase,\n\t.getmaxphase\t= ptp_ocp_null_getmaxphase,\n\t.enable\t\t= ptp_ocp_enable,\n\t.verify\t\t= ptp_ocp_verify,\n\t.pps\t\t= true,\n\t.n_ext_ts\t= 6,\n\t.n_per_out\t= 5,\n};\n\nstatic void\n__ptp_ocp_clear_drift_locked(struct ptp_ocp *bp)\n{\n\tu32 ctrl, select;\n\n\tselect = ioread32(&bp->reg->select);\n\tiowrite32(OCP_SELECT_CLK_REG, &bp->reg->select);\n\n\tiowrite32(0, &bp->reg->drift_ns);\n\n\tctrl = OCP_CTRL_ADJUST_DRIFT | OCP_CTRL_ENABLE;\n\tiowrite32(ctrl, &bp->reg->ctrl);\n\n\t \n\tiowrite32(select >> 16, &bp->reg->select);\n}\n\nstatic void\nptp_ocp_utc_distribute(struct ptp_ocp *bp, u32 val)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\n\tbp->utc_tai_offset = val;\n\n\tif (bp->irig_out)\n\t\tiowrite32(val, &bp->irig_out->adj_sec);\n\tif (bp->dcf_out)\n\t\tiowrite32(val, &bp->dcf_out->adj_sec);\n\tif (bp->nmea_out)\n\t\tiowrite32(val, &bp->nmea_out->adj_sec);\n\n\tspin_unlock_irqrestore(&bp->lock, flags);\n}\n\nstatic void\nptp_ocp_watchdog(struct timer_list *t)\n{\n\tstruct ptp_ocp *bp = from_timer(bp, t, watchdog);\n\tunsigned long flags;\n\tu32 status, utc_offset;\n\n\tstatus = ioread32(&bp->pps_to_clk->status);\n\n\tif (status & PPS_STATUS_SUPERV_ERR) {\n\t\tiowrite32(status, &bp->pps_to_clk->status);\n\t\tif (!bp->gnss_lost) {\n\t\t\tspin_lock_irqsave(&bp->lock, flags);\n\t\t\t__ptp_ocp_clear_drift_locked(bp);\n\t\t\tspin_unlock_irqrestore(&bp->lock, flags);\n\t\t\tbp->gnss_lost = ktime_get_real_seconds();\n\t\t}\n\n\t} else if (bp->gnss_lost) {\n\t\tbp->gnss_lost = 0;\n\t}\n\n\t \n\tif (bp->tod) {\n\t\tstatus = ioread32(&bp->tod->utc_status);\n\t\tutc_offset = status & TOD_STATUS_UTC_MASK;\n\t\tif (status & TOD_STATUS_UTC_VALID &&\n\t\t    utc_offset != bp->utc_tai_offset)\n\t\t\tptp_ocp_utc_distribute(bp, utc_offset);\n\t}\n\n\tmod_timer(&bp->watchdog, jiffies + HZ);\n}\n\nstatic void\nptp_ocp_estimate_pci_timing(struct ptp_ocp *bp)\n{\n\tktime_t start, end;\n\tktime_t delay;\n\tu32 ctrl;\n\n\tctrl = ioread32(&bp->reg->ctrl);\n\tctrl = OCP_CTRL_READ_TIME_REQ | OCP_CTRL_ENABLE;\n\n\tiowrite32(ctrl, &bp->reg->ctrl);\n\n\tstart = ktime_get_ns();\n\n\tctrl = ioread32(&bp->reg->ctrl);\n\n\tend = ktime_get_ns();\n\n\tdelay = end - start;\n\tbp->ts_window_adjust = (delay >> 5) * 3;\n}\n\nstatic int\nptp_ocp_init_clock(struct ptp_ocp *bp)\n{\n\tstruct timespec64 ts;\n\tbool sync;\n\tu32 ctrl;\n\n\tctrl = OCP_CTRL_ENABLE;\n\tiowrite32(ctrl, &bp->reg->ctrl);\n\n\t \n\t \n\tiowrite32(0x2000, &bp->reg->servo_offset_p);\n\tiowrite32(0x1000, &bp->reg->servo_offset_i);\n\tiowrite32(0,\t  &bp->reg->servo_drift_p);\n\tiowrite32(0,\t  &bp->reg->servo_drift_i);\n\n\t \n\tctrl |= OCP_CTRL_ADJUST_SERVO;\n\tiowrite32(ctrl, &bp->reg->ctrl);\n\n\tif ((ioread32(&bp->reg->ctrl) & OCP_CTRL_ENABLE) == 0) {\n\t\tdev_err(&bp->pdev->dev, \"clock not enabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tptp_ocp_estimate_pci_timing(bp);\n\n\tsync = ioread32(&bp->reg->status) & OCP_STATUS_IN_SYNC;\n\tif (!sync) {\n\t\tktime_get_clocktai_ts64(&ts);\n\t\tptp_ocp_settime(&bp->ptp_info, &ts);\n\t}\n\n\t \n\tif (bp->pps_to_clk) {\n\t\ttimer_setup(&bp->watchdog, ptp_ocp_watchdog, 0);\n\t\tmod_timer(&bp->watchdog, jiffies + HZ);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nptp_ocp_tod_init(struct ptp_ocp *bp)\n{\n\tu32 ctrl, reg;\n\n\tctrl = ioread32(&bp->tod->ctrl);\n\tctrl |= TOD_CTRL_PROTOCOL | TOD_CTRL_ENABLE;\n\tctrl &= ~(TOD_CTRL_DISABLE_FMT_A | TOD_CTRL_DISABLE_FMT_B);\n\tiowrite32(ctrl, &bp->tod->ctrl);\n\n\treg = ioread32(&bp->tod->utc_status);\n\tif (reg & TOD_STATUS_UTC_VALID)\n\t\tptp_ocp_utc_distribute(bp, reg & TOD_STATUS_UTC_MASK);\n}\n\nstatic const char *\nptp_ocp_tod_proto_name(const int idx)\n{\n\tstatic const char * const proto_name[] = {\n\t\t\"NMEA\", \"NMEA_ZDA\", \"NMEA_RMC\", \"NMEA_none\",\n\t\t\"UBX\", \"UBX_UTC\", \"UBX_LS\", \"UBX_none\"\n\t};\n\treturn proto_name[idx];\n}\n\nstatic const char *\nptp_ocp_tod_gnss_name(int idx)\n{\n\tstatic const char * const gnss_name[] = {\n\t\t\"ALL\", \"COMBINED\", \"GPS\", \"GLONASS\", \"GALILEO\", \"BEIDOU\",\n\t\t\"Unknown\"\n\t};\n\tif (idx >= ARRAY_SIZE(gnss_name))\n\t\tidx = ARRAY_SIZE(gnss_name) - 1;\n\treturn gnss_name[idx];\n}\n\nstruct ptp_ocp_nvmem_match_info {\n\tstruct ptp_ocp *bp;\n\tconst void * const tag;\n};\n\nstatic int\nptp_ocp_nvmem_match(struct device *dev, const void *data)\n{\n\tconst struct ptp_ocp_nvmem_match_info *info = data;\n\n\tdev = dev->parent;\n\tif (!i2c_verify_client(dev) || info->tag != dev->platform_data)\n\t\treturn 0;\n\n\twhile ((dev = dev->parent))\n\t\tif (dev->driver && !strcmp(dev->driver->name, KBUILD_MODNAME))\n\t\t\treturn info->bp == dev_get_drvdata(dev);\n\treturn 0;\n}\n\nstatic inline struct nvmem_device *\nptp_ocp_nvmem_device_get(struct ptp_ocp *bp, const void * const tag)\n{\n\tstruct ptp_ocp_nvmem_match_info info = { .bp = bp, .tag = tag };\n\n\treturn nvmem_device_find(&info, ptp_ocp_nvmem_match);\n}\n\nstatic inline void\nptp_ocp_nvmem_device_put(struct nvmem_device **nvmemp)\n{\n\tif (!IS_ERR_OR_NULL(*nvmemp))\n\t\tnvmem_device_put(*nvmemp);\n\t*nvmemp = NULL;\n}\n\nstatic void\nptp_ocp_read_eeprom(struct ptp_ocp *bp)\n{\n\tconst struct ptp_ocp_eeprom_map *map;\n\tstruct nvmem_device *nvmem;\n\tconst void *tag;\n\tint ret;\n\n\tif (!bp->i2c_ctrl)\n\t\treturn;\n\n\ttag = NULL;\n\tnvmem = NULL;\n\n\tfor (map = bp->eeprom_map; map->len; map++) {\n\t\tif (map->tag != tag) {\n\t\t\ttag = map->tag;\n\t\t\tptp_ocp_nvmem_device_put(&nvmem);\n\t\t}\n\t\tif (!nvmem) {\n\t\t\tnvmem = ptp_ocp_nvmem_device_get(bp, tag);\n\t\t\tif (IS_ERR(nvmem)) {\n\t\t\t\tret = PTR_ERR(nvmem);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tret = nvmem_device_read(nvmem, map->off, map->len,\n\t\t\t\t\tBP_MAP_ENTRY_ADDR(bp, map));\n\t\tif (ret != map->len)\n\t\t\tgoto fail;\n\t}\n\n\tbp->has_eeprom_data = true;\n\nout:\n\tptp_ocp_nvmem_device_put(&nvmem);\n\treturn;\n\nfail:\n\tdev_err(&bp->pdev->dev, \"could not read eeprom: %d\\n\", ret);\n\tgoto out;\n}\n\nstatic struct device *\nptp_ocp_find_flash(struct ptp_ocp *bp)\n{\n\tstruct device *dev, *last;\n\n\tlast = NULL;\n\tdev = &bp->spi_flash->dev;\n\n\twhile ((dev = device_find_any_child(dev))) {\n\t\tif (!strcmp(\"mtd\", dev_bus_name(dev)))\n\t\t\tbreak;\n\t\tput_device(last);\n\t\tlast = dev;\n\t}\n\tput_device(last);\n\n\treturn dev;\n}\n\nstatic int\nptp_ocp_devlink_fw_image(struct devlink *devlink, const struct firmware *fw,\n\t\t\t const u8 **data, size_t *size)\n{\n\tstruct ptp_ocp *bp = devlink_priv(devlink);\n\tconst struct ptp_ocp_firmware_header *hdr;\n\tsize_t offset, length;\n\tu16 crc;\n\n\thdr = (const struct ptp_ocp_firmware_header *)fw->data;\n\tif (memcmp(hdr->magic, OCP_FIRMWARE_MAGIC_HEADER, 4)) {\n\t\tdevlink_flash_update_status_notify(devlink,\n\t\t\t\"No firmware header found, cancel firmware upgrade\",\n\t\t\tNULL, 0, 0);\n\t\treturn -EINVAL;\n\t}\n\n\tif (be16_to_cpu(hdr->pci_vendor_id) != bp->pdev->vendor ||\n\t    be16_to_cpu(hdr->pci_device_id) != bp->pdev->device) {\n\t\tdevlink_flash_update_status_notify(devlink,\n\t\t\t\"Firmware image compatibility check failed\",\n\t\t\tNULL, 0, 0);\n\t\treturn -EINVAL;\n\t}\n\n\toffset = sizeof(*hdr);\n\tlength = be32_to_cpu(hdr->image_size);\n\tif (length != (fw->size - offset)) {\n\t\tdevlink_flash_update_status_notify(devlink,\n\t\t\t\"Firmware image size check failed\",\n\t\t\tNULL, 0, 0);\n\t\treturn -EINVAL;\n\t}\n\n\tcrc = crc16(0xffff, &fw->data[offset], length);\n\tif (be16_to_cpu(hdr->crc) != crc) {\n\t\tdevlink_flash_update_status_notify(devlink,\n\t\t\t\"Firmware image CRC check failed\",\n\t\t\tNULL, 0, 0);\n\t\treturn -EINVAL;\n\t}\n\n\t*data = &fw->data[offset];\n\t*size = length;\n\n\treturn 0;\n}\n\nstatic int\nptp_ocp_devlink_flash(struct devlink *devlink, struct device *dev,\n\t\t      const struct firmware *fw)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\tstruct ptp_ocp *bp = devlink_priv(devlink);\n\tsize_t off, len, size, resid, wrote;\n\tstruct erase_info erase;\n\tsize_t base, blksz;\n\tconst u8 *data;\n\tint err;\n\n\terr = ptp_ocp_devlink_fw_image(devlink, fw, &data, &size);\n\tif (err)\n\t\tgoto out;\n\n\toff = 0;\n\tbase = bp->flash_start;\n\tblksz = 4096;\n\tresid = size;\n\n\twhile (resid) {\n\t\tdevlink_flash_update_status_notify(devlink, \"Flashing\",\n\t\t\t\t\t\t   NULL, off, size);\n\n\t\tlen = min_t(size_t, resid, blksz);\n\t\terase.addr = base + off;\n\t\terase.len = blksz;\n\n\t\terr = mtd_erase(mtd, &erase);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = mtd_write(mtd, base + off, len, &wrote, data + off);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff += blksz;\n\t\tresid -= len;\n\t}\nout:\n\treturn err;\n}\n\nstatic int\nptp_ocp_devlink_flash_update(struct devlink *devlink,\n\t\t\t     struct devlink_flash_update_params *params,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ptp_ocp *bp = devlink_priv(devlink);\n\tstruct device *dev;\n\tconst char *msg;\n\tint err;\n\n\tdev = ptp_ocp_find_flash(bp);\n\tif (!dev) {\n\t\tdev_err(&bp->pdev->dev, \"Can't find Flash SPI adapter\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdevlink_flash_update_status_notify(devlink, \"Preparing to flash\",\n\t\t\t\t\t   NULL, 0, 0);\n\n\terr = ptp_ocp_devlink_flash(devlink, dev, params->fw);\n\n\tmsg = err ? \"Flash error\" : \"Flash complete\";\n\tdevlink_flash_update_status_notify(devlink, msg, NULL, 0, 0);\n\n\tput_device(dev);\n\treturn err;\n}\n\nstatic int\nptp_ocp_devlink_info_get(struct devlink *devlink, struct devlink_info_req *req,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct ptp_ocp *bp = devlink_priv(devlink);\n\tconst char *fw_image;\n\tchar buf[32];\n\tint err;\n\n\tfw_image = bp->fw_loader ? \"loader\" : \"fw\";\n\tsprintf(buf, \"%d.%d\", bp->fw_tag, bp->fw_version);\n\terr = devlink_info_version_running_put(req, fw_image, buf);\n\tif (err)\n\t\treturn err;\n\n\tif (!bp->has_eeprom_data) {\n\t\tptp_ocp_read_eeprom(bp);\n\t\tif (!bp->has_eeprom_data)\n\t\t\treturn 0;\n\t}\n\n\tsprintf(buf, \"%pM\", bp->serial);\n\terr = devlink_info_serial_number_put(req, buf);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_info_version_fixed_put(req,\n\t\t\tDEVLINK_INFO_VERSION_GENERIC_BOARD_ID,\n\t\t\tbp->board_id);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const struct devlink_ops ptp_ocp_devlink_ops = {\n\t.flash_update = ptp_ocp_devlink_flash_update,\n\t.info_get = ptp_ocp_devlink_info_get,\n};\n\nstatic void __iomem *\n__ptp_ocp_get_mem(struct ptp_ocp *bp, resource_size_t start, int size)\n{\n\tstruct resource res = DEFINE_RES_MEM_NAMED(start, size, \"ptp_ocp\");\n\n\treturn devm_ioremap_resource(&bp->pdev->dev, &res);\n}\n\nstatic void __iomem *\nptp_ocp_get_mem(struct ptp_ocp *bp, struct ocp_resource *r)\n{\n\tresource_size_t start;\n\n\tstart = pci_resource_start(bp->pdev, 0) + r->offset;\n\treturn __ptp_ocp_get_mem(bp, start, r->size);\n}\n\nstatic void\nptp_ocp_set_irq_resource(struct resource *res, int irq)\n{\n\tstruct resource r = DEFINE_RES_IRQ(irq);\n\t*res = r;\n}\n\nstatic void\nptp_ocp_set_mem_resource(struct resource *res, resource_size_t start, int size)\n{\n\tstruct resource r = DEFINE_RES_MEM(start, size);\n\t*res = r;\n}\n\nstatic int\nptp_ocp_register_spi(struct ptp_ocp *bp, struct ocp_resource *r)\n{\n\tstruct ptp_ocp_flash_info *info;\n\tstruct pci_dev *pdev = bp->pdev;\n\tstruct platform_device *p;\n\tstruct resource res[2];\n\tresource_size_t start;\n\tint id;\n\n\tstart = pci_resource_start(pdev, 0) + r->offset;\n\tptp_ocp_set_mem_resource(&res[0], start, r->size);\n\tptp_ocp_set_irq_resource(&res[1], pci_irq_vector(pdev, r->irq_vec));\n\n\tinfo = r->extra;\n\tid = pci_dev_id(pdev) << 1;\n\tid += info->pci_offset;\n\n\tp = platform_device_register_resndata(&pdev->dev, info->name, id,\n\t\t\t\t\t      res, 2, info->data,\n\t\t\t\t\t      info->data_size);\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tbp_assign_entry(bp, r, p);\n\n\treturn 0;\n}\n\nstatic struct platform_device *\nptp_ocp_i2c_bus(struct pci_dev *pdev, struct ocp_resource *r, int id)\n{\n\tstruct ptp_ocp_i2c_info *info;\n\tstruct resource res[2];\n\tresource_size_t start;\n\n\tinfo = r->extra;\n\tstart = pci_resource_start(pdev, 0) + r->offset;\n\tptp_ocp_set_mem_resource(&res[0], start, r->size);\n\tptp_ocp_set_irq_resource(&res[1], pci_irq_vector(pdev, r->irq_vec));\n\n\treturn platform_device_register_resndata(&pdev->dev, info->name,\n\t\t\t\t\t\t id, res, 2,\n\t\t\t\t\t\t info->data, info->data_size);\n}\n\nstatic int\nptp_ocp_register_i2c(struct ptp_ocp *bp, struct ocp_resource *r)\n{\n\tstruct pci_dev *pdev = bp->pdev;\n\tstruct ptp_ocp_i2c_info *info;\n\tstruct platform_device *p;\n\tstruct clk_hw *clk;\n\tchar buf[32];\n\tint id;\n\n\tinfo = r->extra;\n\tid = pci_dev_id(bp->pdev);\n\n\tsprintf(buf, \"AXI.%d\", id);\n\tclk = clk_hw_register_fixed_rate(&pdev->dev, buf, NULL, 0,\n\t\t\t\t\t info->fixed_rate);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\tbp->i2c_clk = clk;\n\n\tsprintf(buf, \"%s.%d\", info->name, id);\n\tdevm_clk_hw_register_clkdev(&pdev->dev, clk, NULL, buf);\n\tp = ptp_ocp_i2c_bus(bp->pdev, r, id);\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tbp_assign_entry(bp, r, p);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t\nptp_ocp_signal_irq(int irq, void *priv)\n{\n\tstruct ptp_ocp_ext_src *ext = priv;\n\tstruct signal_reg __iomem *reg = ext->mem;\n\tstruct ptp_ocp *bp = ext->bp;\n\tu32 enable, status;\n\tint gen;\n\n\tgen = ext->info->index - 1;\n\n\tenable = ioread32(&reg->enable);\n\tstatus = ioread32(&reg->status);\n\n\t \n\tif (status || !enable) {\n\t\tiowrite32(0, &reg->intr_mask);\n\t\tiowrite32(0, &reg->enable);\n\t\tbp->signal[gen].running = false;\n\t}\n\n\tiowrite32(0, &reg->intr);\t \n\n\treturn IRQ_HANDLED;\n}\n\nstatic int\nptp_ocp_signal_set(struct ptp_ocp *bp, int gen, struct ptp_ocp_signal *s)\n{\n\tstruct ptp_system_timestamp sts;\n\tstruct timespec64 ts;\n\tktime_t start_ns;\n\tint err;\n\n\tif (!s->period)\n\t\treturn 0;\n\n\tif (!s->pulse)\n\t\ts->pulse = ktime_divns(s->period * s->duty, 100);\n\n\terr = ptp_ocp_gettimex(&bp->ptp_info, &ts, &sts);\n\tif (err)\n\t\treturn err;\n\n\tstart_ns = ktime_set(ts.tv_sec, ts.tv_nsec) + NSEC_PER_MSEC;\n\tif (!s->start) {\n\t\t \n\t\ts->start = DIV64_U64_ROUND_UP(start_ns, s->period);\n\t\ts->start = ktime_add(s->start, s->phase);\n\t}\n\n\tif (s->duty < 1 || s->duty > 99)\n\t\treturn -EINVAL;\n\n\tif (s->pulse < 1 || s->pulse > s->period)\n\t\treturn -EINVAL;\n\n\tif (s->start < start_ns)\n\t\treturn -EINVAL;\n\n\tbp->signal[gen] = *s;\n\n\treturn 0;\n}\n\nstatic int\nptp_ocp_signal_from_perout(struct ptp_ocp *bp, int gen,\n\t\t\t   struct ptp_perout_request *req)\n{\n\tstruct ptp_ocp_signal s = { };\n\n\ts.polarity = bp->signal[gen].polarity;\n\ts.period = ktime_set(req->period.sec, req->period.nsec);\n\tif (!s.period)\n\t\treturn 0;\n\n\tif (req->flags & PTP_PEROUT_DUTY_CYCLE) {\n\t\ts.pulse = ktime_set(req->on.sec, req->on.nsec);\n\t\ts.duty = ktime_divns(s.pulse * 100, s.period);\n\t}\n\n\tif (req->flags & PTP_PEROUT_PHASE)\n\t\ts.phase = ktime_set(req->phase.sec, req->phase.nsec);\n\telse\n\t\ts.start = ktime_set(req->start.sec, req->start.nsec);\n\n\treturn ptp_ocp_signal_set(bp, gen, &s);\n}\n\nstatic int\nptp_ocp_signal_enable(void *priv, u32 req, bool enable)\n{\n\tstruct ptp_ocp_ext_src *ext = priv;\n\tstruct signal_reg __iomem *reg = ext->mem;\n\tstruct ptp_ocp *bp = ext->bp;\n\tstruct timespec64 ts;\n\tint gen;\n\n\tgen = ext->info->index - 1;\n\n\tiowrite32(0, &reg->intr_mask);\n\tiowrite32(0, &reg->enable);\n\tbp->signal[gen].running = false;\n\tif (!enable)\n\t\treturn 0;\n\n\tts = ktime_to_timespec64(bp->signal[gen].start);\n\tiowrite32(ts.tv_sec, &reg->start_sec);\n\tiowrite32(ts.tv_nsec, &reg->start_ns);\n\n\tts = ktime_to_timespec64(bp->signal[gen].period);\n\tiowrite32(ts.tv_sec, &reg->period_sec);\n\tiowrite32(ts.tv_nsec, &reg->period_ns);\n\n\tts = ktime_to_timespec64(bp->signal[gen].pulse);\n\tiowrite32(ts.tv_sec, &reg->pulse_sec);\n\tiowrite32(ts.tv_nsec, &reg->pulse_ns);\n\n\tiowrite32(bp->signal[gen].polarity, &reg->polarity);\n\tiowrite32(0, &reg->repeat_count);\n\n\tiowrite32(0, &reg->intr);\t\t \n\tiowrite32(1, &reg->intr_mask);\t\t \n\tiowrite32(3, &reg->enable);\t\t \n\n\tbp->signal[gen].running = true;\n\n\treturn 0;\n}\n\nstatic irqreturn_t\nptp_ocp_ts_irq(int irq, void *priv)\n{\n\tstruct ptp_ocp_ext_src *ext = priv;\n\tstruct ts_reg __iomem *reg = ext->mem;\n\tstruct ptp_clock_event ev;\n\tu32 sec, nsec;\n\n\tif (ext == ext->bp->pps) {\n\t\tif (ext->bp->pps_req_map & OCP_REQ_PPS) {\n\t\t\tev.type = PTP_CLOCK_PPS;\n\t\t\tptp_clock_event(ext->bp->ptp, &ev);\n\t\t}\n\n\t\tif ((ext->bp->pps_req_map & ~OCP_REQ_PPS) == 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tsec = ioread32(&reg->time_sec);\n\tnsec = ioread32(&reg->time_ns);\n\n\tev.type = PTP_CLOCK_EXTTS;\n\tev.index = ext->info->index;\n\tev.timestamp = sec * NSEC_PER_SEC + nsec;\n\n\tptp_clock_event(ext->bp->ptp, &ev);\n\nout:\n\tiowrite32(1, &reg->intr);\t \n\n\treturn IRQ_HANDLED;\n}\n\nstatic int\nptp_ocp_ts_enable(void *priv, u32 req, bool enable)\n{\n\tstruct ptp_ocp_ext_src *ext = priv;\n\tstruct ts_reg __iomem *reg = ext->mem;\n\tstruct ptp_ocp *bp = ext->bp;\n\n\tif (ext == bp->pps) {\n\t\tu32 old_map = bp->pps_req_map;\n\n\t\tif (enable)\n\t\t\tbp->pps_req_map |= req;\n\t\telse\n\t\t\tbp->pps_req_map &= ~req;\n\n\t\t \n\t\tif ((!!old_map ^ !!bp->pps_req_map) == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (enable) {\n\t\tiowrite32(1, &reg->enable);\n\t\tiowrite32(1, &reg->intr_mask);\n\t\tiowrite32(1, &reg->intr);\n\t} else {\n\t\tiowrite32(0, &reg->intr_mask);\n\t\tiowrite32(0, &reg->enable);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nptp_ocp_unregister_ext(struct ptp_ocp_ext_src *ext)\n{\n\text->info->enable(ext, ~0, false);\n\tpci_free_irq(ext->bp->pdev, ext->irq_vec, ext);\n\tkfree(ext);\n}\n\nstatic int\nptp_ocp_register_ext(struct ptp_ocp *bp, struct ocp_resource *r)\n{\n\tstruct pci_dev *pdev = bp->pdev;\n\tstruct ptp_ocp_ext_src *ext;\n\tint err;\n\n\text = kzalloc(sizeof(*ext), GFP_KERNEL);\n\tif (!ext)\n\t\treturn -ENOMEM;\n\n\text->mem = ptp_ocp_get_mem(bp, r);\n\tif (IS_ERR(ext->mem)) {\n\t\terr = PTR_ERR(ext->mem);\n\t\tgoto out;\n\t}\n\n\text->bp = bp;\n\text->info = r->extra;\n\text->irq_vec = r->irq_vec;\n\n\terr = pci_request_irq(pdev, r->irq_vec, ext->info->irq_fcn, NULL,\n\t\t\t      ext, \"ocp%d.%s\", bp->id, r->name);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Could not get irq %d\\n\", r->irq_vec);\n\t\tgoto out;\n\t}\n\n\tbp_assign_entry(bp, r, ext);\n\n\treturn 0;\n\nout:\n\tkfree(ext);\n\treturn err;\n}\n\nstatic int\nptp_ocp_serial_line(struct ptp_ocp *bp, struct ocp_resource *r)\n{\n\tstruct pci_dev *pdev = bp->pdev;\n\tstruct uart_8250_port uart;\n\n\t \n\tmemset(&uart, 0, sizeof(uart));\n\tuart.port.dev = &pdev->dev;\n\tuart.port.iotype = UPIO_MEM;\n\tuart.port.regshift = 2;\n\tuart.port.mapbase = pci_resource_start(pdev, 0) + r->offset;\n\tuart.port.irq = pci_irq_vector(pdev, r->irq_vec);\n\tuart.port.uartclk = 50000000;\n\tuart.port.flags = UPF_FIXED_TYPE | UPF_IOREMAP | UPF_NO_THRE_TEST;\n\tuart.port.type = PORT_16550A;\n\n\treturn serial8250_register_8250_port(&uart);\n}\n\nstatic int\nptp_ocp_register_serial(struct ptp_ocp *bp, struct ocp_resource *r)\n{\n\tstruct ptp_ocp_serial_port *p = (struct ptp_ocp_serial_port *)r->extra;\n\tstruct ptp_ocp_serial_port port = {};\n\n\tport.line = ptp_ocp_serial_line(bp, r);\n\tif (port.line < 0)\n\t\treturn port.line;\n\n\tif (p)\n\t\tport.baud = p->baud;\n\n\tbp_assign_entry(bp, r, port);\n\n\treturn 0;\n}\n\nstatic int\nptp_ocp_register_mem(struct ptp_ocp *bp, struct ocp_resource *r)\n{\n\tvoid __iomem *mem;\n\n\tmem = ptp_ocp_get_mem(bp, r);\n\tif (IS_ERR(mem))\n\t\treturn PTR_ERR(mem);\n\n\tbp_assign_entry(bp, r, mem);\n\n\treturn 0;\n}\n\nstatic void\nptp_ocp_nmea_out_init(struct ptp_ocp *bp)\n{\n\tif (!bp->nmea_out)\n\t\treturn;\n\n\tiowrite32(0, &bp->nmea_out->ctrl);\t\t \n\tiowrite32(7, &bp->nmea_out->uart_baud);\t\t \n\tiowrite32(1, &bp->nmea_out->ctrl);\t\t \n}\n\nstatic void\n_ptp_ocp_signal_init(struct ptp_ocp_signal *s, struct signal_reg __iomem *reg)\n{\n\tu32 val;\n\n\tiowrite32(0, &reg->enable);\t\t \n\n\tval = ioread32(&reg->polarity);\n\ts->polarity = val ? true : false;\n\ts->duty = 50;\n}\n\nstatic void\nptp_ocp_signal_init(struct ptp_ocp *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (bp->signal_out[i])\n\t\t\t_ptp_ocp_signal_init(&bp->signal[i],\n\t\t\t\t\t     bp->signal_out[i]->mem);\n}\n\nstatic void\nptp_ocp_attr_group_del(struct ptp_ocp *bp)\n{\n\tsysfs_remove_groups(&bp->dev.kobj, bp->attr_group);\n\tkfree(bp->attr_group);\n}\n\nstatic int\nptp_ocp_attr_group_add(struct ptp_ocp *bp,\n\t\t       const struct ocp_attr_group *attr_tbl)\n{\n\tint count, i;\n\tint err;\n\n\tcount = 0;\n\tfor (i = 0; attr_tbl[i].cap; i++)\n\t\tif (attr_tbl[i].cap & bp->fw_cap)\n\t\t\tcount++;\n\n\tbp->attr_group = kcalloc(count + 1, sizeof(struct attribute_group *),\n\t\t\t\t GFP_KERNEL);\n\tif (!bp->attr_group)\n\t\treturn -ENOMEM;\n\n\tcount = 0;\n\tfor (i = 0; attr_tbl[i].cap; i++)\n\t\tif (attr_tbl[i].cap & bp->fw_cap)\n\t\t\tbp->attr_group[count++] = attr_tbl[i].group;\n\n\terr = sysfs_create_groups(&bp->dev.kobj, bp->attr_group);\n\tif (err)\n\t\tbp->attr_group[0] = NULL;\n\n\treturn err;\n}\n\nstatic void\nptp_ocp_enable_fpga(u32 __iomem *reg, u32 bit, bool enable)\n{\n\tu32 ctrl;\n\tbool on;\n\n\tctrl = ioread32(reg);\n\ton = ctrl & bit;\n\tif (on ^ enable) {\n\t\tctrl &= ~bit;\n\t\tctrl |= enable ? bit : 0;\n\t\tiowrite32(ctrl, reg);\n\t}\n}\n\nstatic void\nptp_ocp_irig_out(struct ptp_ocp *bp, bool enable)\n{\n\treturn ptp_ocp_enable_fpga(&bp->irig_out->ctrl,\n\t\t\t\t   IRIG_M_CTRL_ENABLE, enable);\n}\n\nstatic void\nptp_ocp_irig_in(struct ptp_ocp *bp, bool enable)\n{\n\treturn ptp_ocp_enable_fpga(&bp->irig_in->ctrl,\n\t\t\t\t   IRIG_S_CTRL_ENABLE, enable);\n}\n\nstatic void\nptp_ocp_dcf_out(struct ptp_ocp *bp, bool enable)\n{\n\treturn ptp_ocp_enable_fpga(&bp->dcf_out->ctrl,\n\t\t\t\t   DCF_M_CTRL_ENABLE, enable);\n}\n\nstatic void\nptp_ocp_dcf_in(struct ptp_ocp *bp, bool enable)\n{\n\treturn ptp_ocp_enable_fpga(&bp->dcf_in->ctrl,\n\t\t\t\t   DCF_S_CTRL_ENABLE, enable);\n}\n\nstatic void\n__handle_signal_outputs(struct ptp_ocp *bp, u32 val)\n{\n\tptp_ocp_irig_out(bp, val & 0x00100010);\n\tptp_ocp_dcf_out(bp, val & 0x00200020);\n}\n\nstatic void\n__handle_signal_inputs(struct ptp_ocp *bp, u32 val)\n{\n\tptp_ocp_irig_in(bp, val & 0x00100010);\n\tptp_ocp_dcf_in(bp, val & 0x00200020);\n}\n\nstatic u32\nptp_ocp_sma_fb_get(struct ptp_ocp *bp, int sma_nr)\n{\n\tu32 __iomem *gpio;\n\tu32 shift;\n\n\tif (bp->sma[sma_nr - 1].fixed_fcn)\n\t\treturn (sma_nr - 1) & 1;\n\n\tif (bp->sma[sma_nr - 1].mode == SMA_MODE_IN)\n\t\tgpio = sma_nr > 2 ? &bp->sma_map2->gpio1 : &bp->sma_map1->gpio1;\n\telse\n\t\tgpio = sma_nr > 2 ? &bp->sma_map1->gpio2 : &bp->sma_map2->gpio2;\n\tshift = sma_nr & 1 ? 0 : 16;\n\n\treturn (ioread32(gpio) >> shift) & 0xffff;\n}\n\nstatic int\nptp_ocp_sma_fb_set_output(struct ptp_ocp *bp, int sma_nr, u32 val)\n{\n\tu32 reg, mask, shift;\n\tunsigned long flags;\n\tu32 __iomem *gpio;\n\n\tgpio = sma_nr > 2 ? &bp->sma_map1->gpio2 : &bp->sma_map2->gpio2;\n\tshift = sma_nr & 1 ? 0 : 16;\n\n\tmask = 0xffff << (16 - shift);\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\n\treg = ioread32(gpio);\n\treg = (reg & mask) | (val << shift);\n\n\t__handle_signal_outputs(bp, reg);\n\n\tiowrite32(reg, gpio);\n\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\treturn 0;\n}\n\nstatic int\nptp_ocp_sma_fb_set_inputs(struct ptp_ocp *bp, int sma_nr, u32 val)\n{\n\tu32 reg, mask, shift;\n\tunsigned long flags;\n\tu32 __iomem *gpio;\n\n\tgpio = sma_nr > 2 ? &bp->sma_map2->gpio1 : &bp->sma_map1->gpio1;\n\tshift = sma_nr & 1 ? 0 : 16;\n\n\tmask = 0xffff << (16 - shift);\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\n\treg = ioread32(gpio);\n\treg = (reg & mask) | (val << shift);\n\n\t__handle_signal_inputs(bp, reg);\n\n\tiowrite32(reg, gpio);\n\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\treturn 0;\n}\n\nstatic void\nptp_ocp_sma_fb_init(struct ptp_ocp *bp)\n{\n\tu32 reg;\n\tint i;\n\n\t \n\tbp->sma[0].mode = SMA_MODE_IN;\n\tbp->sma[1].mode = SMA_MODE_IN;\n\tbp->sma[2].mode = SMA_MODE_OUT;\n\tbp->sma[3].mode = SMA_MODE_OUT;\n\tfor (i = 0; i < 4; i++)\n\t\tbp->sma[i].default_fcn = i & 1;\n\n\t \n\tif (!bp->sma_map1) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbp->sma[i].fixed_fcn = true;\n\t\t\tbp->sma[i].fixed_dir = true;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\treg = ioread32(&bp->sma_map2->gpio2);\n\tif (reg == 0xffffffff) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tbp->sma[i].fixed_dir = true;\n\t} else {\n\t\treg = ioread32(&bp->sma_map1->gpio1);\n\t\tbp->sma[0].mode = reg & BIT(15) ? SMA_MODE_IN : SMA_MODE_OUT;\n\t\tbp->sma[1].mode = reg & BIT(31) ? SMA_MODE_IN : SMA_MODE_OUT;\n\n\t\treg = ioread32(&bp->sma_map1->gpio2);\n\t\tbp->sma[2].mode = reg & BIT(15) ? SMA_MODE_OUT : SMA_MODE_IN;\n\t\tbp->sma[3].mode = reg & BIT(31) ? SMA_MODE_OUT : SMA_MODE_IN;\n\t}\n}\n\nstatic const struct ocp_sma_op ocp_fb_sma_op = {\n\t.tbl\t\t= { ptp_ocp_sma_in, ptp_ocp_sma_out },\n\t.init\t\t= ptp_ocp_sma_fb_init,\n\t.get\t\t= ptp_ocp_sma_fb_get,\n\t.set_inputs\t= ptp_ocp_sma_fb_set_inputs,\n\t.set_output\t= ptp_ocp_sma_fb_set_output,\n};\n\nstatic int\nptp_ocp_fb_set_pins(struct ptp_ocp *bp)\n{\n\tstruct ptp_pin_desc *config;\n\tint i;\n\n\tconfig = kcalloc(4, sizeof(*config), GFP_KERNEL);\n\tif (!config)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tsprintf(config[i].name, \"sma%d\", i + 1);\n\t\tconfig[i].index = i;\n\t}\n\n\tbp->ptp_info.n_pins = 4;\n\tbp->ptp_info.pin_config = config;\n\n\treturn 0;\n}\n\nstatic void\nptp_ocp_fb_set_version(struct ptp_ocp *bp)\n{\n\tu64 cap = OCP_CAP_BASIC;\n\tu32 version;\n\n\tversion = ioread32(&bp->image->version);\n\n\t \n\tif ((version & 0xffff) == 0) {\n\t\tversion = version >> 16;\n\t\tbp->fw_loader = true;\n\t}\n\n\tbp->fw_tag = version >> 15;\n\tbp->fw_version = version & 0x7fff;\n\n\tif (bp->fw_tag) {\n\t\t \n\t\tif (version >= 5)\n\t\t\tcap |= OCP_CAP_SIGNAL | OCP_CAP_FREQ;\n\t} else {\n\t\t \n\t\tif (version >= 19)\n\t\t\tcap |= OCP_CAP_SIGNAL;\n\t\tif (version >= 20)\n\t\t\tcap |= OCP_CAP_FREQ;\n\t}\n\n\tbp->fw_cap = cap;\n}\n\n \nstatic int\nptp_ocp_fb_board_init(struct ptp_ocp *bp, struct ocp_resource *r)\n{\n\tint err;\n\n\tbp->flash_start = 1024 * 4096;\n\tbp->eeprom_map = fb_eeprom_map;\n\tbp->fw_version = ioread32(&bp->image->version);\n\tbp->sma_op = &ocp_fb_sma_op;\n\n\tptp_ocp_fb_set_version(bp);\n\n\tptp_ocp_tod_init(bp);\n\tptp_ocp_nmea_out_init(bp);\n\tptp_ocp_sma_init(bp);\n\tptp_ocp_signal_init(bp);\n\n\terr = ptp_ocp_attr_group_add(bp, fb_timecard_groups);\n\tif (err)\n\t\treturn err;\n\n\terr = ptp_ocp_fb_set_pins(bp);\n\tif (err)\n\t\treturn err;\n\n\treturn ptp_ocp_init_clock(bp);\n}\n\nstatic bool\nptp_ocp_allow_irq(struct ptp_ocp *bp, struct ocp_resource *r)\n{\n\tbool allow = !r->irq_vec || r->irq_vec < bp->n_irqs;\n\n\tif (!allow)\n\t\tdev_err(&bp->pdev->dev, \"irq %d out of range, skipping %s\\n\",\n\t\t\tr->irq_vec, r->name);\n\treturn allow;\n}\n\nstatic int\nptp_ocp_register_resources(struct ptp_ocp *bp, kernel_ulong_t driver_data)\n{\n\tstruct ocp_resource *r, *table;\n\tint err = 0;\n\n\ttable = (struct ocp_resource *)driver_data;\n\tfor (r = table; r->setup; r++) {\n\t\tif (!ptp_ocp_allow_irq(bp, r))\n\t\t\tcontinue;\n\t\terr = r->setup(bp, r);\n\t\tif (err) {\n\t\t\tdev_err(&bp->pdev->dev,\n\t\t\t\t\"Could not register %s: err %d\\n\",\n\t\t\t\tr->name, err);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic void\nptp_ocp_art_sma_init(struct ptp_ocp *bp)\n{\n\tu32 reg;\n\tint i;\n\n\t \n\tbp->sma[0].mode = SMA_MODE_IN;\n\tbp->sma[1].mode = SMA_MODE_IN;\n\tbp->sma[2].mode = SMA_MODE_OUT;\n\tbp->sma[3].mode = SMA_MODE_OUT;\n\n\tbp->sma[0].default_fcn = 0x08;\t \n\tbp->sma[1].default_fcn = 0x01;\t \n\tbp->sma[2].default_fcn = 0x10;\t \n\tbp->sma[3].default_fcn = 0x02;\t \n\n\t \n\tif (!bp->art_sma) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbp->sma[i].fixed_fcn = true;\n\t\t\tbp->sma[i].fixed_dir = true;\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\treg = ioread32(&bp->art_sma->map[i].gpio);\n\n\t\tswitch (reg & 0xff) {\n\t\tcase 0:\n\t\t\tbp->sma[i].fixed_fcn = true;\n\t\t\tbp->sma[i].fixed_dir = true;\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 8:\n\t\t\tbp->sma[i].mode = SMA_MODE_IN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbp->sma[i].mode = SMA_MODE_OUT;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic u32\nptp_ocp_art_sma_get(struct ptp_ocp *bp, int sma_nr)\n{\n\tif (bp->sma[sma_nr - 1].fixed_fcn)\n\t\treturn bp->sma[sma_nr - 1].default_fcn;\n\n\treturn ioread32(&bp->art_sma->map[sma_nr - 1].gpio) & 0xff;\n}\n\n \nstatic int\nptp_ocp_art_sma_set(struct ptp_ocp *bp, int sma_nr, u32 val)\n{\n\tunsigned long flags;\n\tu32 __iomem *gpio;\n\tint err = 0;\n\tu32 reg;\n\n\tval &= SMA_SELECT_MASK;\n\tif (hweight32(val) > 1)\n\t\treturn -EINVAL;\n\n\tgpio = &bp->art_sma->map[sma_nr - 1].gpio;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\treg = ioread32(gpio);\n\tif (((reg >> 16) & val) == 0) {\n\t\terr = -EOPNOTSUPP;\n\t} else {\n\t\treg = (reg & 0xff00) | (val & 0xff);\n\t\tiowrite32(reg, gpio);\n\t}\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\treturn err;\n}\n\nstatic const struct ocp_sma_op ocp_art_sma_op = {\n\t.tbl\t\t= { ptp_ocp_art_sma_in, ptp_ocp_art_sma_out },\n\t.init\t\t= ptp_ocp_art_sma_init,\n\t.get\t\t= ptp_ocp_art_sma_get,\n\t.set_inputs\t= ptp_ocp_art_sma_set,\n\t.set_output\t= ptp_ocp_art_sma_set,\n};\n\n \nstatic int\nptp_ocp_art_board_init(struct ptp_ocp *bp, struct ocp_resource *r)\n{\n\tint err;\n\n\tbp->flash_start = 0x1000000;\n\tbp->eeprom_map = art_eeprom_map;\n\tbp->fw_cap = OCP_CAP_BASIC;\n\tbp->fw_version = ioread32(&bp->reg->version);\n\tbp->fw_tag = 2;\n\tbp->sma_op = &ocp_art_sma_op;\n\n\t \n\tiowrite32(1, &bp->board_config->mro50_serial_activate);\n\n\tptp_ocp_sma_init(bp);\n\n\terr = ptp_ocp_attr_group_add(bp, art_timecard_groups);\n\tif (err)\n\t\treturn err;\n\n\treturn ptp_ocp_init_clock(bp);\n}\n\nstatic ssize_t\nptp_ocp_show_output(const struct ocp_selector *tbl, u32 val, char *buf,\n\t\t    int def_val)\n{\n\tconst char *name;\n\tssize_t count;\n\n\tcount = sysfs_emit(buf, \"OUT: \");\n\tname = ptp_ocp_select_name_from_val(tbl, val);\n\tif (!name)\n\t\tname = ptp_ocp_select_name_from_val(tbl, def_val);\n\tcount += sysfs_emit_at(buf, count, \"%s\\n\", name);\n\treturn count;\n}\n\nstatic ssize_t\nptp_ocp_show_inputs(const struct ocp_selector *tbl, u32 val, char *buf,\n\t\t    int def_val)\n{\n\tconst char *name;\n\tssize_t count;\n\tint i;\n\n\tcount = sysfs_emit(buf, \"IN: \");\n\tfor (i = 0; tbl[i].name; i++) {\n\t\tif (val & tbl[i].value) {\n\t\t\tname = tbl[i].name;\n\t\t\tcount += sysfs_emit_at(buf, count, \"%s \", name);\n\t\t}\n\t}\n\tif (!val && def_val >= 0) {\n\t\tname = ptp_ocp_select_name_from_val(tbl, def_val);\n\t\tcount += sysfs_emit_at(buf, count, \"%s \", name);\n\t}\n\tif (count)\n\t\tcount--;\n\tcount += sysfs_emit_at(buf, count, \"\\n\");\n\treturn count;\n}\n\nstatic int\nsma_parse_inputs(const struct ocp_selector * const tbl[], const char *buf,\n\t\t enum ptp_ocp_sma_mode *mode)\n{\n\tint idx, count, dir;\n\tchar **argv;\n\tint ret;\n\n\targv = argv_split(GFP_KERNEL, buf, &count);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tret = -EINVAL;\n\tif (!count)\n\t\tgoto out;\n\n\tidx = 0;\n\tdir = *mode == SMA_MODE_IN ? 0 : 1;\n\tif (!strcasecmp(\"IN:\", argv[0])) {\n\t\tdir = 0;\n\t\tidx++;\n\t}\n\tif (!strcasecmp(\"OUT:\", argv[0])) {\n\t\tdir = 1;\n\t\tidx++;\n\t}\n\t*mode = dir == 0 ? SMA_MODE_IN : SMA_MODE_OUT;\n\n\tret = 0;\n\tfor (; idx < count; idx++)\n\t\tret |= ptp_ocp_select_val_from_name(tbl[dir], argv[idx]);\n\tif (ret < 0)\n\t\tret = -EINVAL;\n\nout:\n\targv_free(argv);\n\treturn ret;\n}\n\nstatic ssize_t\nptp_ocp_sma_show(struct ptp_ocp *bp, int sma_nr, char *buf,\n\t\t int default_in_val, int default_out_val)\n{\n\tstruct ptp_ocp_sma_connector *sma = &bp->sma[sma_nr - 1];\n\tconst struct ocp_selector * const *tbl;\n\tu32 val;\n\n\ttbl = bp->sma_op->tbl;\n\tval = ptp_ocp_sma_get(bp, sma_nr) & SMA_SELECT_MASK;\n\n\tif (sma->mode == SMA_MODE_IN) {\n\t\tif (sma->disabled)\n\t\t\tval = SMA_DISABLE;\n\t\treturn ptp_ocp_show_inputs(tbl[0], val, buf, default_in_val);\n\t}\n\n\treturn ptp_ocp_show_output(tbl[1], val, buf, default_out_val);\n}\n\nstatic ssize_t\nsma1_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\n\treturn ptp_ocp_sma_show(bp, 1, buf, 0, 1);\n}\n\nstatic ssize_t\nsma2_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\n\treturn ptp_ocp_sma_show(bp, 2, buf, -1, 1);\n}\n\nstatic ssize_t\nsma3_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\n\treturn ptp_ocp_sma_show(bp, 3, buf, -1, 0);\n}\n\nstatic ssize_t\nsma4_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\n\treturn ptp_ocp_sma_show(bp, 4, buf, -1, 1);\n}\n\nstatic int\nptp_ocp_sma_store(struct ptp_ocp *bp, const char *buf, int sma_nr)\n{\n\tstruct ptp_ocp_sma_connector *sma = &bp->sma[sma_nr - 1];\n\tenum ptp_ocp_sma_mode mode;\n\tint val;\n\n\tmode = sma->mode;\n\tval = sma_parse_inputs(bp->sma_op->tbl, buf, &mode);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (sma->fixed_dir && (mode != sma->mode || val & SMA_DISABLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (sma->fixed_fcn) {\n\t\tif (val != sma->default_fcn)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn 0;\n\t}\n\n\tsma->disabled = !!(val & SMA_DISABLE);\n\n\tif (mode != sma->mode) {\n\t\tif (mode == SMA_MODE_IN)\n\t\t\tptp_ocp_sma_set_output(bp, sma_nr, 0);\n\t\telse\n\t\t\tptp_ocp_sma_set_inputs(bp, sma_nr, 0);\n\t\tsma->mode = mode;\n\t}\n\n\tif (!sma->fixed_dir)\n\t\tval |= SMA_ENABLE;\t\t \n\n\tif (sma->disabled)\n\t\tval = 0;\n\n\tif (mode == SMA_MODE_IN)\n\t\tval = ptp_ocp_sma_set_inputs(bp, sma_nr, val);\n\telse\n\t\tval = ptp_ocp_sma_set_output(bp, sma_nr, val);\n\n\treturn val;\n}\n\nstatic ssize_t\nsma1_store(struct device *dev, struct device_attribute *attr,\n\t   const char *buf, size_t count)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint err;\n\n\terr = ptp_ocp_sma_store(bp, buf, 1);\n\treturn err ? err : count;\n}\n\nstatic ssize_t\nsma2_store(struct device *dev, struct device_attribute *attr,\n\t   const char *buf, size_t count)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint err;\n\n\terr = ptp_ocp_sma_store(bp, buf, 2);\n\treturn err ? err : count;\n}\n\nstatic ssize_t\nsma3_store(struct device *dev, struct device_attribute *attr,\n\t   const char *buf, size_t count)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint err;\n\n\terr = ptp_ocp_sma_store(bp, buf, 3);\n\treturn err ? err : count;\n}\n\nstatic ssize_t\nsma4_store(struct device *dev, struct device_attribute *attr,\n\t   const char *buf, size_t count)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint err;\n\n\terr = ptp_ocp_sma_store(bp, buf, 4);\n\treturn err ? err : count;\n}\nstatic DEVICE_ATTR_RW(sma1);\nstatic DEVICE_ATTR_RW(sma2);\nstatic DEVICE_ATTR_RW(sma3);\nstatic DEVICE_ATTR_RW(sma4);\n\nstatic ssize_t\navailable_sma_inputs_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\n\treturn ptp_ocp_select_table_show(bp->sma_op->tbl[0], buf);\n}\nstatic DEVICE_ATTR_RO(available_sma_inputs);\n\nstatic ssize_t\navailable_sma_outputs_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\n\treturn ptp_ocp_select_table_show(bp->sma_op->tbl[1], buf);\n}\nstatic DEVICE_ATTR_RO(available_sma_outputs);\n\n#define EXT_ATTR_RO(_group, _name, _val)\t\t\t\t\\\n\tstruct dev_ext_attribute dev_attr_##_group##_val##_##_name =\t\\\n\t\t{ __ATTR_RO(_name), (void *)_val }\n#define EXT_ATTR_RW(_group, _name, _val)\t\t\t\t\\\n\tstruct dev_ext_attribute dev_attr_##_group##_val##_##_name =\t\\\n\t\t{ __ATTR_RW(_name), (void *)_val }\n#define to_ext_attr(x) container_of(x, struct dev_ext_attribute, attr)\n\n \nstatic ssize_t\nsignal_store(struct device *dev, struct device_attribute *attr,\n\t     const char *buf, size_t count)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tstruct ptp_ocp_signal s = { };\n\tint gen = (uintptr_t)ea->var;\n\tint argc, err;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, buf, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\terr = -EINVAL;\n\ts.duty = bp->signal[gen].duty;\n\ts.phase = bp->signal[gen].phase;\n\ts.period = bp->signal[gen].period;\n\ts.polarity = bp->signal[gen].polarity;\n\n\tswitch (argc) {\n\tcase 4:\n\t\targc--;\n\t\terr = kstrtobool(argv[argc], &s.polarity);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tfallthrough;\n\tcase 3:\n\t\targc--;\n\t\terr = kstrtou64(argv[argc], 0, &s.phase);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tfallthrough;\n\tcase 2:\n\t\targc--;\n\t\terr = kstrtoint(argv[argc], 0, &s.duty);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tfallthrough;\n\tcase 1:\n\t\targc--;\n\t\terr = kstrtou64(argv[argc], 0, &s.period);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terr = ptp_ocp_signal_set(bp, gen, &s);\n\tif (err)\n\t\tgoto out;\n\n\terr = ptp_ocp_signal_enable(bp->signal_out[gen], gen, s.period != 0);\n\nout:\n\targv_free(argv);\n\treturn err ? err : count;\n}\n\nstatic ssize_t\nsignal_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tstruct ptp_ocp_signal *signal;\n\tstruct timespec64 ts;\n\tssize_t count;\n\tint i;\n\n\ti = (uintptr_t)ea->var;\n\tsignal = &bp->signal[i];\n\n\tcount = sysfs_emit(buf, \"%llu %d %llu %d\", signal->period,\n\t\t\t   signal->duty, signal->phase, signal->polarity);\n\n\tts = ktime_to_timespec64(signal->start);\n\tcount += sysfs_emit_at(buf, count, \" %ptT TAI\\n\", &ts);\n\n\treturn count;\n}\nstatic EXT_ATTR_RW(signal, signal, 0);\nstatic EXT_ATTR_RW(signal, signal, 1);\nstatic EXT_ATTR_RW(signal, signal, 2);\nstatic EXT_ATTR_RW(signal, signal, 3);\n\nstatic ssize_t\nduty_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint i = (uintptr_t)ea->var;\n\n\treturn sysfs_emit(buf, \"%d\\n\", bp->signal[i].duty);\n}\nstatic EXT_ATTR_RO(signal, duty, 0);\nstatic EXT_ATTR_RO(signal, duty, 1);\nstatic EXT_ATTR_RO(signal, duty, 2);\nstatic EXT_ATTR_RO(signal, duty, 3);\n\nstatic ssize_t\nperiod_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint i = (uintptr_t)ea->var;\n\n\treturn sysfs_emit(buf, \"%llu\\n\", bp->signal[i].period);\n}\nstatic EXT_ATTR_RO(signal, period, 0);\nstatic EXT_ATTR_RO(signal, period, 1);\nstatic EXT_ATTR_RO(signal, period, 2);\nstatic EXT_ATTR_RO(signal, period, 3);\n\nstatic ssize_t\nphase_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint i = (uintptr_t)ea->var;\n\n\treturn sysfs_emit(buf, \"%llu\\n\", bp->signal[i].phase);\n}\nstatic EXT_ATTR_RO(signal, phase, 0);\nstatic EXT_ATTR_RO(signal, phase, 1);\nstatic EXT_ATTR_RO(signal, phase, 2);\nstatic EXT_ATTR_RO(signal, phase, 3);\n\nstatic ssize_t\npolarity_show(struct device *dev, struct device_attribute *attr,\n\t      char *buf)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint i = (uintptr_t)ea->var;\n\n\treturn sysfs_emit(buf, \"%d\\n\", bp->signal[i].polarity);\n}\nstatic EXT_ATTR_RO(signal, polarity, 0);\nstatic EXT_ATTR_RO(signal, polarity, 1);\nstatic EXT_ATTR_RO(signal, polarity, 2);\nstatic EXT_ATTR_RO(signal, polarity, 3);\n\nstatic ssize_t\nrunning_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint i = (uintptr_t)ea->var;\n\n\treturn sysfs_emit(buf, \"%d\\n\", bp->signal[i].running);\n}\nstatic EXT_ATTR_RO(signal, running, 0);\nstatic EXT_ATTR_RO(signal, running, 1);\nstatic EXT_ATTR_RO(signal, running, 2);\nstatic EXT_ATTR_RO(signal, running, 3);\n\nstatic ssize_t\nstart_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint i = (uintptr_t)ea->var;\n\tstruct timespec64 ts;\n\n\tts = ktime_to_timespec64(bp->signal[i].start);\n\treturn sysfs_emit(buf, \"%llu.%lu\\n\", ts.tv_sec, ts.tv_nsec);\n}\nstatic EXT_ATTR_RO(signal, start, 0);\nstatic EXT_ATTR_RO(signal, start, 1);\nstatic EXT_ATTR_RO(signal, start, 2);\nstatic EXT_ATTR_RO(signal, start, 3);\n\nstatic ssize_t\nseconds_store(struct device *dev, struct device_attribute *attr,\n\t      const char *buf, size_t count)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint idx = (uintptr_t)ea->var;\n\tu32 val;\n\tint err;\n\n\terr = kstrtou32(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\tif (val > 0xff)\n\t\treturn -EINVAL;\n\n\tif (val)\n\t\tval = (val << 8) | 0x1;\n\n\tiowrite32(val, &bp->freq_in[idx]->ctrl);\n\n\treturn count;\n}\n\nstatic ssize_t\nseconds_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint idx = (uintptr_t)ea->var;\n\tu32 val;\n\n\tval = ioread32(&bp->freq_in[idx]->ctrl);\n\tif (val & 1)\n\t\tval = (val >> 8) & 0xff;\n\telse\n\t\tval = 0;\n\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\nstatic EXT_ATTR_RW(freq, seconds, 0);\nstatic EXT_ATTR_RW(freq, seconds, 1);\nstatic EXT_ATTR_RW(freq, seconds, 2);\nstatic EXT_ATTR_RW(freq, seconds, 3);\n\nstatic ssize_t\nfrequency_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint idx = (uintptr_t)ea->var;\n\tu32 val;\n\n\tval = ioread32(&bp->freq_in[idx]->status);\n\tif (val & FREQ_STATUS_ERROR)\n\t\treturn sysfs_emit(buf, \"error\\n\");\n\tif (val & FREQ_STATUS_OVERRUN)\n\t\treturn sysfs_emit(buf, \"overrun\\n\");\n\tif (val & FREQ_STATUS_VALID)\n\t\treturn sysfs_emit(buf, \"%lu\\n\", val & FREQ_STATUS_MASK);\n\treturn 0;\n}\nstatic EXT_ATTR_RO(freq, frequency, 0);\nstatic EXT_ATTR_RO(freq, frequency, 1);\nstatic EXT_ATTR_RO(freq, frequency, 2);\nstatic EXT_ATTR_RO(freq, frequency, 3);\n\nstatic ssize_t\nserialnum_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\n\tif (!bp->has_eeprom_data)\n\t\tptp_ocp_read_eeprom(bp);\n\n\treturn sysfs_emit(buf, \"%pM\\n\", bp->serial);\n}\nstatic DEVICE_ATTR_RO(serialnum);\n\nstatic ssize_t\ngnss_sync_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tssize_t ret;\n\n\tif (bp->gnss_lost)\n\t\tret = sysfs_emit(buf, \"LOST @ %ptT\\n\", &bp->gnss_lost);\n\telse\n\t\tret = sysfs_emit(buf, \"SYNC\\n\");\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(gnss_sync);\n\nstatic ssize_t\nutc_tai_offset_show(struct device *dev,\n\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", bp->utc_tai_offset);\n}\n\nstatic ssize_t\nutc_tai_offset_store(struct device *dev,\n\t\t     struct device_attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint err;\n\tu32 val;\n\n\terr = kstrtou32(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\n\tptp_ocp_utc_distribute(bp, val);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(utc_tai_offset);\n\nstatic ssize_t\nts_window_adjust_show(struct device *dev,\n\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", bp->ts_window_adjust);\n}\n\nstatic ssize_t\nts_window_adjust_store(struct device *dev,\n\t\t       struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tint err;\n\tu32 val;\n\n\terr = kstrtou32(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\n\tbp->ts_window_adjust = val;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(ts_window_adjust);\n\nstatic ssize_t\nirig_b_mode_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tu32 val;\n\n\tval = ioread32(&bp->irig_out->ctrl);\n\tval = (val >> 16) & 0x07;\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t\nirig_b_mode_store(struct device *dev,\n\t\t  struct device_attribute *attr,\n\t\t  const char *buf, size_t count)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tint err;\n\tu32 reg;\n\tu8 val;\n\n\terr = kstrtou8(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\tif (val > 7)\n\t\treturn -EINVAL;\n\n\treg = ((val & 0x7) << 16);\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\tiowrite32(0, &bp->irig_out->ctrl);\t\t \n\tiowrite32(reg, &bp->irig_out->ctrl);\t\t \n\tiowrite32(reg | IRIG_M_CTRL_ENABLE, &bp->irig_out->ctrl);\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(irig_b_mode);\n\nstatic ssize_t\nclock_source_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tconst char *p;\n\tu32 select;\n\n\tselect = ioread32(&bp->reg->select);\n\tp = ptp_ocp_select_name_from_val(ptp_ocp_clock, select >> 16);\n\n\treturn sysfs_emit(buf, \"%s\\n\", p);\n}\n\nstatic ssize_t\nclock_source_store(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tint val;\n\n\tval = ptp_ocp_select_val_from_name(ptp_ocp_clock, buf);\n\tif (val < 0)\n\t\treturn val;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\tiowrite32(val, &bp->reg->select);\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(clock_source);\n\nstatic ssize_t\navailable_clock_sources_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\treturn ptp_ocp_select_table_show(ptp_ocp_clock, buf);\n}\nstatic DEVICE_ATTR_RO(available_clock_sources);\n\nstatic ssize_t\nclock_status_drift_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tu32 val;\n\tint res;\n\n\tval = ioread32(&bp->reg->status_drift);\n\tres = (val & ~INT_MAX) ? -1 : 1;\n\tres *= (val & INT_MAX);\n\treturn sysfs_emit(buf, \"%d\\n\", res);\n}\nstatic DEVICE_ATTR_RO(clock_status_drift);\n\nstatic ssize_t\nclock_status_offset_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tu32 val;\n\tint res;\n\n\tval = ioread32(&bp->reg->status_offset);\n\tres = (val & ~INT_MAX) ? -1 : 1;\n\tres *= (val & INT_MAX);\n\treturn sysfs_emit(buf, \"%d\\n\", res);\n}\nstatic DEVICE_ATTR_RO(clock_status_offset);\n\nstatic ssize_t\ntod_correction_show(struct device *dev,\n\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tu32 val;\n\tint res;\n\n\tval = ioread32(&bp->tod->adj_sec);\n\tres = (val & ~INT_MAX) ? -1 : 1;\n\tres *= (val & INT_MAX);\n\treturn sysfs_emit(buf, \"%d\\n\", res);\n}\n\nstatic ssize_t\ntod_correction_store(struct device *dev, struct device_attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tint err, res;\n\tu32 val = 0;\n\n\terr = kstrtos32(buf, 0, &res);\n\tif (err)\n\t\treturn err;\n\tif (res < 0) {\n\t\tres *= -1;\n\t\tval |= BIT(31);\n\t}\n\tval |= res;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\tiowrite32(val, &bp->tod->adj_sec);\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(tod_correction);\n\n#define _DEVICE_SIGNAL_GROUP_ATTRS(_nr)\t\t\t\t\t\\\n\tstatic struct attribute *fb_timecard_signal##_nr##_attrs[] = {\t\\\n\t\t&dev_attr_signal##_nr##_signal.attr.attr,\t\t\\\n\t\t&dev_attr_signal##_nr##_duty.attr.attr,\t\t\t\\\n\t\t&dev_attr_signal##_nr##_phase.attr.attr,\t\t\\\n\t\t&dev_attr_signal##_nr##_period.attr.attr,\t\t\\\n\t\t&dev_attr_signal##_nr##_polarity.attr.attr,\t\t\\\n\t\t&dev_attr_signal##_nr##_running.attr.attr,\t\t\\\n\t\t&dev_attr_signal##_nr##_start.attr.attr,\t\t\\\n\t\tNULL,\t\t\t\t\t\t\t\\\n\t}\n\n#define DEVICE_SIGNAL_GROUP(_name, _nr)\t\t\t\t\t\\\n\t_DEVICE_SIGNAL_GROUP_ATTRS(_nr);\t\t\t\t\\\n\tstatic const struct attribute_group\t\t\t\t\\\n\t\t\tfb_timecard_signal##_nr##_group = {\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\t\\\n\t\t.attrs = fb_timecard_signal##_nr##_attrs,\t\t\\\n}\n\nDEVICE_SIGNAL_GROUP(gen1, 0);\nDEVICE_SIGNAL_GROUP(gen2, 1);\nDEVICE_SIGNAL_GROUP(gen3, 2);\nDEVICE_SIGNAL_GROUP(gen4, 3);\n\n#define _DEVICE_FREQ_GROUP_ATTRS(_nr)\t\t\t\t\t\\\n\tstatic struct attribute *fb_timecard_freq##_nr##_attrs[] = {\t\\\n\t\t&dev_attr_freq##_nr##_seconds.attr.attr,\t\t\\\n\t\t&dev_attr_freq##_nr##_frequency.attr.attr,\t\t\\\n\t\tNULL,\t\t\t\t\t\t\t\\\n\t}\n\n#define DEVICE_FREQ_GROUP(_name, _nr)\t\t\t\t\t\\\n\t_DEVICE_FREQ_GROUP_ATTRS(_nr);\t\t\t\t\t\\\n\tstatic const struct attribute_group\t\t\t\t\\\n\t\t\tfb_timecard_freq##_nr##_group = {\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\t\\\n\t\t.attrs = fb_timecard_freq##_nr##_attrs,\t\t\t\\\n}\n\nDEVICE_FREQ_GROUP(freq1, 0);\nDEVICE_FREQ_GROUP(freq2, 1);\nDEVICE_FREQ_GROUP(freq3, 2);\nDEVICE_FREQ_GROUP(freq4, 3);\n\nstatic ssize_t\ndisciplining_config_read(struct file *filp, struct kobject *kobj,\n\t\t\t struct bin_attribute *bin_attr, char *buf,\n\t\t\t loff_t off, size_t count)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(kobj_to_dev(kobj));\n\tsize_t size = OCP_ART_CONFIG_SIZE;\n\tstruct nvmem_device *nvmem;\n\tssize_t err;\n\n\tnvmem = ptp_ocp_nvmem_device_get(bp, NULL);\n\tif (IS_ERR(nvmem))\n\t\treturn PTR_ERR(nvmem);\n\n\tif (off > size) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (off + count > size)\n\t\tcount = size - off;\n\n\t\n\terr = nvmem_device_read(nvmem, off, count, buf);\n\tif (err != count) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\tptp_ocp_nvmem_device_put(&nvmem);\n\n\treturn err;\n}\n\nstatic ssize_t\ndisciplining_config_write(struct file *filp, struct kobject *kobj,\n\t\t\t  struct bin_attribute *bin_attr, char *buf,\n\t\t\t  loff_t off, size_t count)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(kobj_to_dev(kobj));\n\tstruct nvmem_device *nvmem;\n\tssize_t err;\n\n\t \n\tif (off || count != OCP_ART_CONFIG_SIZE)\n\t\treturn -EFAULT;\n\n\tnvmem = ptp_ocp_nvmem_device_get(bp, NULL);\n\tif (IS_ERR(nvmem))\n\t\treturn PTR_ERR(nvmem);\n\n\terr = nvmem_device_write(nvmem, 0x00, count, buf);\n\tif (err != count)\n\t\terr = -EFAULT;\n\n\tptp_ocp_nvmem_device_put(&nvmem);\n\n\treturn err;\n}\nstatic BIN_ATTR_RW(disciplining_config, OCP_ART_CONFIG_SIZE);\n\nstatic ssize_t\ntemperature_table_read(struct file *filp, struct kobject *kobj,\n\t\t       struct bin_attribute *bin_attr, char *buf,\n\t\t       loff_t off, size_t count)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(kobj_to_dev(kobj));\n\tsize_t size = OCP_ART_TEMP_TABLE_SIZE;\n\tstruct nvmem_device *nvmem;\n\tssize_t err;\n\n\tnvmem = ptp_ocp_nvmem_device_get(bp, NULL);\n\tif (IS_ERR(nvmem))\n\t\treturn PTR_ERR(nvmem);\n\n\tif (off > size) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (off + count > size)\n\t\tcount = size - off;\n\n\t\n\terr = nvmem_device_read(nvmem, 0x90 + off, count, buf);\n\tif (err != count) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\tptp_ocp_nvmem_device_put(&nvmem);\n\n\treturn err;\n}\n\nstatic ssize_t\ntemperature_table_write(struct file *filp, struct kobject *kobj,\n\t\t\tstruct bin_attribute *bin_attr, char *buf,\n\t\t\tloff_t off, size_t count)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(kobj_to_dev(kobj));\n\tstruct nvmem_device *nvmem;\n\tssize_t err;\n\n\t \n\tif (off || count != OCP_ART_TEMP_TABLE_SIZE)\n\t\treturn -EFAULT;\n\n\tnvmem = ptp_ocp_nvmem_device_get(bp, NULL);\n\tif (IS_ERR(nvmem))\n\t\treturn PTR_ERR(nvmem);\n\n\terr = nvmem_device_write(nvmem, 0x90, count, buf);\n\tif (err != count)\n\t\terr = -EFAULT;\n\n\tptp_ocp_nvmem_device_put(&nvmem);\n\n\treturn err;\n}\nstatic BIN_ATTR_RW(temperature_table, OCP_ART_TEMP_TABLE_SIZE);\n\nstatic struct attribute *fb_timecard_attrs[] = {\n\t&dev_attr_serialnum.attr,\n\t&dev_attr_gnss_sync.attr,\n\t&dev_attr_clock_source.attr,\n\t&dev_attr_available_clock_sources.attr,\n\t&dev_attr_sma1.attr,\n\t&dev_attr_sma2.attr,\n\t&dev_attr_sma3.attr,\n\t&dev_attr_sma4.attr,\n\t&dev_attr_available_sma_inputs.attr,\n\t&dev_attr_available_sma_outputs.attr,\n\t&dev_attr_clock_status_drift.attr,\n\t&dev_attr_clock_status_offset.attr,\n\t&dev_attr_irig_b_mode.attr,\n\t&dev_attr_utc_tai_offset.attr,\n\t&dev_attr_ts_window_adjust.attr,\n\t&dev_attr_tod_correction.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group fb_timecard_group = {\n\t.attrs = fb_timecard_attrs,\n};\n\nstatic const struct ocp_attr_group fb_timecard_groups[] = {\n\t{ .cap = OCP_CAP_BASIC,\t    .group = &fb_timecard_group },\n\t{ .cap = OCP_CAP_SIGNAL,    .group = &fb_timecard_signal0_group },\n\t{ .cap = OCP_CAP_SIGNAL,    .group = &fb_timecard_signal1_group },\n\t{ .cap = OCP_CAP_SIGNAL,    .group = &fb_timecard_signal2_group },\n\t{ .cap = OCP_CAP_SIGNAL,    .group = &fb_timecard_signal3_group },\n\t{ .cap = OCP_CAP_FREQ,\t    .group = &fb_timecard_freq0_group },\n\t{ .cap = OCP_CAP_FREQ,\t    .group = &fb_timecard_freq1_group },\n\t{ .cap = OCP_CAP_FREQ,\t    .group = &fb_timecard_freq2_group },\n\t{ .cap = OCP_CAP_FREQ,\t    .group = &fb_timecard_freq3_group },\n\t{ },\n};\n\nstatic struct attribute *art_timecard_attrs[] = {\n\t&dev_attr_serialnum.attr,\n\t&dev_attr_clock_source.attr,\n\t&dev_attr_available_clock_sources.attr,\n\t&dev_attr_utc_tai_offset.attr,\n\t&dev_attr_ts_window_adjust.attr,\n\t&dev_attr_sma1.attr,\n\t&dev_attr_sma2.attr,\n\t&dev_attr_sma3.attr,\n\t&dev_attr_sma4.attr,\n\t&dev_attr_available_sma_inputs.attr,\n\t&dev_attr_available_sma_outputs.attr,\n\tNULL,\n};\n\nstatic struct bin_attribute *bin_art_timecard_attrs[] = {\n\t&bin_attr_disciplining_config,\n\t&bin_attr_temperature_table,\n\tNULL,\n};\n\nstatic const struct attribute_group art_timecard_group = {\n\t.attrs = art_timecard_attrs,\n\t.bin_attrs = bin_art_timecard_attrs,\n};\n\nstatic const struct ocp_attr_group art_timecard_groups[] = {\n\t{ .cap = OCP_CAP_BASIC,\t    .group = &art_timecard_group },\n\t{ },\n};\n\nstatic void\ngpio_input_map(char *buf, struct ptp_ocp *bp, u16 map[][2], u16 bit,\n\t       const char *def)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (bp->sma[i].mode != SMA_MODE_IN)\n\t\t\tcontinue;\n\t\tif (map[i][0] & (1 << bit)) {\n\t\t\tsprintf(buf, \"sma%d\", i + 1);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!def)\n\t\tdef = \"----\";\n\tstrcpy(buf, def);\n}\n\nstatic void\ngpio_output_map(char *buf, struct ptp_ocp *bp, u16 map[][2], u16 bit)\n{\n\tchar *ans = buf;\n\tint i;\n\n\tstrcpy(ans, \"----\");\n\tfor (i = 0; i < 4; i++) {\n\t\tif (bp->sma[i].mode != SMA_MODE_OUT)\n\t\t\tcontinue;\n\t\tif (map[i][1] & (1 << bit))\n\t\t\tans += sprintf(ans, \"sma%d \", i + 1);\n\t}\n}\n\nstatic void\n_signal_summary_show(struct seq_file *s, struct ptp_ocp *bp, int nr)\n{\n\tstruct signal_reg __iomem *reg = bp->signal_out[nr]->mem;\n\tstruct ptp_ocp_signal *signal = &bp->signal[nr];\n\tchar label[8];\n\tbool on;\n\tu32 val;\n\n\tif (!signal)\n\t\treturn;\n\n\ton = signal->running;\n\tsprintf(label, \"GEN%d\", nr + 1);\n\tseq_printf(s, \"%7s: %s, period:%llu duty:%d%% phase:%llu pol:%d\",\n\t\t   label, on ? \" ON\" : \"OFF\",\n\t\t   signal->period, signal->duty, signal->phase,\n\t\t   signal->polarity);\n\n\tval = ioread32(&reg->enable);\n\tseq_printf(s, \" [%x\", val);\n\tval = ioread32(&reg->status);\n\tseq_printf(s, \" %x]\", val);\n\n\tseq_printf(s, \" start:%llu\\n\", signal->start);\n}\n\nstatic void\n_frequency_summary_show(struct seq_file *s, int nr,\n\t\t\tstruct frequency_reg __iomem *reg)\n{\n\tchar label[8];\n\tbool on;\n\tu32 val;\n\n\tif (!reg)\n\t\treturn;\n\n\tsprintf(label, \"FREQ%d\", nr + 1);\n\tval = ioread32(&reg->ctrl);\n\ton = val & 1;\n\tval = (val >> 8) & 0xff;\n\tseq_printf(s, \"%7s: %s, sec:%u\",\n\t\t   label,\n\t\t   on ? \" ON\" : \"OFF\",\n\t\t   val);\n\n\tval = ioread32(&reg->status);\n\tif (val & FREQ_STATUS_ERROR)\n\t\tseq_printf(s, \", error\");\n\tif (val & FREQ_STATUS_OVERRUN)\n\t\tseq_printf(s, \", overrun\");\n\tif (val & FREQ_STATUS_VALID)\n\t\tseq_printf(s, \", freq %lu Hz\", val & FREQ_STATUS_MASK);\n\tseq_printf(s, \"  reg:%x\\n\", val);\n}\n\nstatic int\nptp_ocp_summary_show(struct seq_file *s, void *data)\n{\n\tstruct device *dev = s->private;\n\tstruct ptp_system_timestamp sts;\n\tstruct ts_reg __iomem *ts_reg;\n\tchar *buf, *src, *mac_src;\n\tstruct timespec64 ts;\n\tstruct ptp_ocp *bp;\n\tu16 sma_val[4][2];\n\tu32 ctrl, val;\n\tbool on, map;\n\tint i;\n\n\tbuf = (char *)__get_free_page(GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbp = dev_get_drvdata(dev);\n\n\tseq_printf(s, \"%7s: /dev/ptp%d\\n\", \"PTP\", ptp_clock_index(bp->ptp));\n\tif (bp->gnss_port.line != -1)\n\t\tseq_printf(s, \"%7s: /dev/ttyS%d\\n\", \"GNSS1\",\n\t\t\t   bp->gnss_port.line);\n\tif (bp->gnss2_port.line != -1)\n\t\tseq_printf(s, \"%7s: /dev/ttyS%d\\n\", \"GNSS2\",\n\t\t\t   bp->gnss2_port.line);\n\tif (bp->mac_port.line != -1)\n\t\tseq_printf(s, \"%7s: /dev/ttyS%d\\n\", \"MAC\", bp->mac_port.line);\n\tif (bp->nmea_port.line != -1)\n\t\tseq_printf(s, \"%7s: /dev/ttyS%d\\n\", \"NMEA\", bp->nmea_port.line);\n\n\tmemset(sma_val, 0xff, sizeof(sma_val));\n\tif (bp->sma_map1) {\n\t\tu32 reg;\n\n\t\treg = ioread32(&bp->sma_map1->gpio1);\n\t\tsma_val[0][0] = reg & 0xffff;\n\t\tsma_val[1][0] = reg >> 16;\n\n\t\treg = ioread32(&bp->sma_map1->gpio2);\n\t\tsma_val[2][1] = reg & 0xffff;\n\t\tsma_val[3][1] = reg >> 16;\n\n\t\treg = ioread32(&bp->sma_map2->gpio1);\n\t\tsma_val[2][0] = reg & 0xffff;\n\t\tsma_val[3][0] = reg >> 16;\n\n\t\treg = ioread32(&bp->sma_map2->gpio2);\n\t\tsma_val[0][1] = reg & 0xffff;\n\t\tsma_val[1][1] = reg >> 16;\n\t}\n\n\tsma1_show(dev, NULL, buf);\n\tseq_printf(s, \"   sma1: %04x,%04x %s\",\n\t\t   sma_val[0][0], sma_val[0][1], buf);\n\n\tsma2_show(dev, NULL, buf);\n\tseq_printf(s, \"   sma2: %04x,%04x %s\",\n\t\t   sma_val[1][0], sma_val[1][1], buf);\n\n\tsma3_show(dev, NULL, buf);\n\tseq_printf(s, \"   sma3: %04x,%04x %s\",\n\t\t   sma_val[2][0], sma_val[2][1], buf);\n\n\tsma4_show(dev, NULL, buf);\n\tseq_printf(s, \"   sma4: %04x,%04x %s\",\n\t\t   sma_val[3][0], sma_val[3][1], buf);\n\n\tif (bp->ts0) {\n\t\tts_reg = bp->ts0->mem;\n\t\ton = ioread32(&ts_reg->enable);\n\t\tsrc = \"GNSS1\";\n\t\tseq_printf(s, \"%7s: %s, src: %s\\n\", \"TS0\",\n\t\t\t   on ? \" ON\" : \"OFF\", src);\n\t}\n\n\tif (bp->ts1) {\n\t\tts_reg = bp->ts1->mem;\n\t\ton = ioread32(&ts_reg->enable);\n\t\tgpio_input_map(buf, bp, sma_val, 2, NULL);\n\t\tseq_printf(s, \"%7s: %s, src: %s\\n\", \"TS1\",\n\t\t\t   on ? \" ON\" : \"OFF\", buf);\n\t}\n\n\tif (bp->ts2) {\n\t\tts_reg = bp->ts2->mem;\n\t\ton = ioread32(&ts_reg->enable);\n\t\tgpio_input_map(buf, bp, sma_val, 3, NULL);\n\t\tseq_printf(s, \"%7s: %s, src: %s\\n\", \"TS2\",\n\t\t\t   on ? \" ON\" : \"OFF\", buf);\n\t}\n\n\tif (bp->ts3) {\n\t\tts_reg = bp->ts3->mem;\n\t\ton = ioread32(&ts_reg->enable);\n\t\tgpio_input_map(buf, bp, sma_val, 6, NULL);\n\t\tseq_printf(s, \"%7s: %s, src: %s\\n\", \"TS3\",\n\t\t\t   on ? \" ON\" : \"OFF\", buf);\n\t}\n\n\tif (bp->ts4) {\n\t\tts_reg = bp->ts4->mem;\n\t\ton = ioread32(&ts_reg->enable);\n\t\tgpio_input_map(buf, bp, sma_val, 7, NULL);\n\t\tseq_printf(s, \"%7s: %s, src: %s\\n\", \"TS4\",\n\t\t\t   on ? \" ON\" : \"OFF\", buf);\n\t}\n\n\tif (bp->pps) {\n\t\tts_reg = bp->pps->mem;\n\t\tsrc = \"PHC\";\n\t\ton = ioread32(&ts_reg->enable);\n\t\tmap = !!(bp->pps_req_map & OCP_REQ_TIMESTAMP);\n\t\tseq_printf(s, \"%7s: %s, src: %s\\n\", \"TS5\",\n\t\t\t   on && map ? \" ON\" : \"OFF\", src);\n\n\t\tmap = !!(bp->pps_req_map & OCP_REQ_PPS);\n\t\tseq_printf(s, \"%7s: %s, src: %s\\n\", \"PPS\",\n\t\t\t   on && map ? \" ON\" : \"OFF\", src);\n\t}\n\n\tif (bp->fw_cap & OCP_CAP_SIGNAL)\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t_signal_summary_show(s, bp, i);\n\n\tif (bp->fw_cap & OCP_CAP_FREQ)\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t_frequency_summary_show(s, i, bp->freq_in[i]);\n\n\tif (bp->irig_out) {\n\t\tctrl = ioread32(&bp->irig_out->ctrl);\n\t\ton = ctrl & IRIG_M_CTRL_ENABLE;\n\t\tval = ioread32(&bp->irig_out->status);\n\t\tgpio_output_map(buf, bp, sma_val, 4);\n\t\tseq_printf(s, \"%7s: %s, error: %d, mode %d, out: %s\\n\", \"IRIG\",\n\t\t\t   on ? \" ON\" : \"OFF\", val, (ctrl >> 16), buf);\n\t}\n\n\tif (bp->irig_in) {\n\t\ton = ioread32(&bp->irig_in->ctrl) & IRIG_S_CTRL_ENABLE;\n\t\tval = ioread32(&bp->irig_in->status);\n\t\tgpio_input_map(buf, bp, sma_val, 4, NULL);\n\t\tseq_printf(s, \"%7s: %s, error: %d, src: %s\\n\", \"IRIG in\",\n\t\t\t   on ? \" ON\" : \"OFF\", val, buf);\n\t}\n\n\tif (bp->dcf_out) {\n\t\ton = ioread32(&bp->dcf_out->ctrl) & DCF_M_CTRL_ENABLE;\n\t\tval = ioread32(&bp->dcf_out->status);\n\t\tgpio_output_map(buf, bp, sma_val, 5);\n\t\tseq_printf(s, \"%7s: %s, error: %d, out: %s\\n\", \"DCF\",\n\t\t\t   on ? \" ON\" : \"OFF\", val, buf);\n\t}\n\n\tif (bp->dcf_in) {\n\t\ton = ioread32(&bp->dcf_in->ctrl) & DCF_S_CTRL_ENABLE;\n\t\tval = ioread32(&bp->dcf_in->status);\n\t\tgpio_input_map(buf, bp, sma_val, 5, NULL);\n\t\tseq_printf(s, \"%7s: %s, error: %d, src: %s\\n\", \"DCF in\",\n\t\t\t   on ? \" ON\" : \"OFF\", val, buf);\n\t}\n\n\tif (bp->nmea_out) {\n\t\ton = ioread32(&bp->nmea_out->ctrl) & 1;\n\t\tval = ioread32(&bp->nmea_out->status);\n\t\tseq_printf(s, \"%7s: %s, error: %d\\n\", \"NMEA\",\n\t\t\t   on ? \" ON\" : \"OFF\", val);\n\t}\n\n\t \n\tif (bp->pps_select) {\n\t\tval = ioread32(&bp->pps_select->gpio1);\n\t\tsrc = &buf[80];\n\t\tmac_src = \"GNSS1\";\n\t\tif (val & 0x01) {\n\t\t\tgpio_input_map(src, bp, sma_val, 0, NULL);\n\t\t\tmac_src = src;\n\t\t} else if (val & 0x02) {\n\t\t\tsrc = \"MAC\";\n\t\t} else if (val & 0x04) {\n\t\t\tsrc = \"GNSS1\";\n\t\t} else {\n\t\t\tsrc = \"----\";\n\t\t\tmac_src = src;\n\t\t}\n\t} else {\n\t\tsrc = \"?\";\n\t\tmac_src = src;\n\t}\n\tseq_printf(s, \"MAC PPS1 src: %s\\n\", mac_src);\n\n\tgpio_input_map(buf, bp, sma_val, 1, \"GNSS2\");\n\tseq_printf(s, \"MAC PPS2 src: %s\\n\", buf);\n\n\t \n\tval = ioread32(&bp->reg->select);\n\tswitch (val >> 16) {\n\tcase 0:\n\t\tsprintf(buf, \"----\");\n\t\tbreak;\n\tcase 2:\n\t\tsprintf(buf, \"IRIG\");\n\t\tbreak;\n\tcase 3:\n\t\tsprintf(buf, \"%s via PPS1\", src);\n\t\tbreak;\n\tcase 6:\n\t\tsprintf(buf, \"DCF\");\n\t\tbreak;\n\tdefault:\n\t\tstrcpy(buf, \"unknown\");\n\t\tbreak;\n\t}\n\tval = ioread32(&bp->reg->status);\n\tseq_printf(s, \"%7s: %s, state: %s\\n\", \"PHC src\", buf,\n\t\t   val & OCP_STATUS_IN_SYNC ? \"sync\" : \"unsynced\");\n\n\tif (!ptp_ocp_gettimex(&bp->ptp_info, &ts, &sts)) {\n\t\tstruct timespec64 sys_ts;\n\t\ts64 pre_ns, post_ns, ns;\n\n\t\tpre_ns = timespec64_to_ns(&sts.pre_ts);\n\t\tpost_ns = timespec64_to_ns(&sts.post_ts);\n\t\tns = (pre_ns + post_ns) / 2;\n\t\tns += (s64)bp->utc_tai_offset * NSEC_PER_SEC;\n\t\tsys_ts = ns_to_timespec64(ns);\n\n\t\tseq_printf(s, \"%7s: %lld.%ld == %ptT TAI\\n\", \"PHC\",\n\t\t\t   ts.tv_sec, ts.tv_nsec, &ts);\n\t\tseq_printf(s, \"%7s: %lld.%ld == %ptT UTC offset %d\\n\", \"SYS\",\n\t\t\t   sys_ts.tv_sec, sys_ts.tv_nsec, &sys_ts,\n\t\t\t   bp->utc_tai_offset);\n\t\tseq_printf(s, \"%7s: PHC:SYS offset: %lld  window: %lld\\n\", \"\",\n\t\t\t   timespec64_to_ns(&ts) - ns,\n\t\t\t   post_ns - pre_ns);\n\t}\n\n\tfree_page((unsigned long)buf);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ptp_ocp_summary);\n\nstatic int\nptp_ocp_tod_status_show(struct seq_file *s, void *data)\n{\n\tstruct device *dev = s->private;\n\tstruct ptp_ocp *bp;\n\tu32 val;\n\tint idx;\n\n\tbp = dev_get_drvdata(dev);\n\n\tval = ioread32(&bp->tod->ctrl);\n\tif (!(val & TOD_CTRL_ENABLE)) {\n\t\tseq_printf(s, \"TOD Slave disabled\\n\");\n\t\treturn 0;\n\t}\n\tseq_printf(s, \"TOD Slave enabled, Control Register 0x%08X\\n\", val);\n\n\tidx = val & TOD_CTRL_PROTOCOL ? 4 : 0;\n\tidx += (val >> 16) & 3;\n\tseq_printf(s, \"Protocol %s\\n\", ptp_ocp_tod_proto_name(idx));\n\n\tidx = (val >> TOD_CTRL_GNSS_SHIFT) & TOD_CTRL_GNSS_MASK;\n\tseq_printf(s, \"GNSS %s\\n\", ptp_ocp_tod_gnss_name(idx));\n\n\tval = ioread32(&bp->tod->version);\n\tseq_printf(s, \"TOD Version %d.%d.%d\\n\",\n\t\tval >> 24, (val >> 16) & 0xff, val & 0xffff);\n\n\tval = ioread32(&bp->tod->status);\n\tseq_printf(s, \"Status register: 0x%08X\\n\", val);\n\n\tval = ioread32(&bp->tod->adj_sec);\n\tidx = (val & ~INT_MAX) ? -1 : 1;\n\tidx *= (val & INT_MAX);\n\tseq_printf(s, \"Correction seconds: %d\\n\", idx);\n\n\tval = ioread32(&bp->tod->utc_status);\n\tseq_printf(s, \"UTC status register: 0x%08X\\n\", val);\n\tseq_printf(s, \"UTC offset: %ld  valid:%d\\n\",\n\t\tval & TOD_STATUS_UTC_MASK, val & TOD_STATUS_UTC_VALID ? 1 : 0);\n\tseq_printf(s, \"Leap second info valid:%d, Leap second announce %d\\n\",\n\t\tval & TOD_STATUS_LEAP_VALID ? 1 : 0,\n\t\tval & TOD_STATUS_LEAP_ANNOUNCE ? 1 : 0);\n\n\tval = ioread32(&bp->tod->leap);\n\tseq_printf(s, \"Time to next leap second (in sec): %d\\n\", (s32) val);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ptp_ocp_tod_status);\n\nstatic struct dentry *ptp_ocp_debugfs_root;\n\nstatic void\nptp_ocp_debugfs_add_device(struct ptp_ocp *bp)\n{\n\tstruct dentry *d;\n\n\td = debugfs_create_dir(dev_name(&bp->dev), ptp_ocp_debugfs_root);\n\tbp->debug_root = d;\n\tdebugfs_create_file(\"summary\", 0444, bp->debug_root,\n\t\t\t    &bp->dev, &ptp_ocp_summary_fops);\n\tif (bp->tod)\n\t\tdebugfs_create_file(\"tod_status\", 0444, bp->debug_root,\n\t\t\t\t    &bp->dev, &ptp_ocp_tod_status_fops);\n}\n\nstatic void\nptp_ocp_debugfs_remove_device(struct ptp_ocp *bp)\n{\n\tdebugfs_remove_recursive(bp->debug_root);\n}\n\nstatic void\nptp_ocp_debugfs_init(void)\n{\n\tptp_ocp_debugfs_root = debugfs_create_dir(\"timecard\", NULL);\n}\n\nstatic void\nptp_ocp_debugfs_fini(void)\n{\n\tdebugfs_remove_recursive(ptp_ocp_debugfs_root);\n}\n\nstatic void\nptp_ocp_dev_release(struct device *dev)\n{\n\tstruct ptp_ocp *bp = dev_get_drvdata(dev);\n\n\tmutex_lock(&ptp_ocp_lock);\n\tidr_remove(&ptp_ocp_idr, bp->id);\n\tmutex_unlock(&ptp_ocp_lock);\n}\n\nstatic int\nptp_ocp_device_init(struct ptp_ocp *bp, struct pci_dev *pdev)\n{\n\tint err;\n\n\tmutex_lock(&ptp_ocp_lock);\n\terr = idr_alloc(&ptp_ocp_idr, bp, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&ptp_ocp_lock);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"idr_alloc failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\tbp->id = err;\n\n\tbp->ptp_info = ptp_ocp_clock_info;\n\tspin_lock_init(&bp->lock);\n\tbp->gnss_port.line = -1;\n\tbp->gnss2_port.line = -1;\n\tbp->mac_port.line = -1;\n\tbp->nmea_port.line = -1;\n\tbp->pdev = pdev;\n\n\tdevice_initialize(&bp->dev);\n\tdev_set_name(&bp->dev, \"ocp%d\", bp->id);\n\tbp->dev.class = &timecard_class;\n\tbp->dev.parent = &pdev->dev;\n\tbp->dev.release = ptp_ocp_dev_release;\n\tdev_set_drvdata(&bp->dev, bp);\n\n\terr = device_add(&bp->dev);\n\tif (err) {\n\t\tdev_err(&bp->dev, \"device add failed: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tpci_set_drvdata(pdev, bp);\n\n\treturn 0;\n\nout:\n\tput_device(&bp->dev);\n\treturn err;\n}\n\nstatic void\nptp_ocp_symlink(struct ptp_ocp *bp, struct device *child, const char *link)\n{\n\tstruct device *dev = &bp->dev;\n\n\tif (sysfs_create_link(&dev->kobj, &child->kobj, link))\n\t\tdev_err(dev, \"%s symlink failed\\n\", link);\n}\n\nstatic void\nptp_ocp_link_child(struct ptp_ocp *bp, const char *name, const char *link)\n{\n\tstruct device *dev, *child;\n\n\tdev = &bp->pdev->dev;\n\n\tchild = device_find_child_by_name(dev, name);\n\tif (!child) {\n\t\tdev_err(dev, \"Could not find device %s\\n\", name);\n\t\treturn;\n\t}\n\n\tptp_ocp_symlink(bp, child, link);\n\tput_device(child);\n}\n\nstatic int\nptp_ocp_complete(struct ptp_ocp *bp)\n{\n\tstruct pps_device *pps;\n\tchar buf[32];\n\n\tif (bp->gnss_port.line != -1) {\n\t\tsprintf(buf, \"ttyS%d\", bp->gnss_port.line);\n\t\tptp_ocp_link_child(bp, buf, \"ttyGNSS\");\n\t}\n\tif (bp->gnss2_port.line != -1) {\n\t\tsprintf(buf, \"ttyS%d\", bp->gnss2_port.line);\n\t\tptp_ocp_link_child(bp, buf, \"ttyGNSS2\");\n\t}\n\tif (bp->mac_port.line != -1) {\n\t\tsprintf(buf, \"ttyS%d\", bp->mac_port.line);\n\t\tptp_ocp_link_child(bp, buf, \"ttyMAC\");\n\t}\n\tif (bp->nmea_port.line != -1) {\n\t\tsprintf(buf, \"ttyS%d\", bp->nmea_port.line);\n\t\tptp_ocp_link_child(bp, buf, \"ttyNMEA\");\n\t}\n\tsprintf(buf, \"ptp%d\", ptp_clock_index(bp->ptp));\n\tptp_ocp_link_child(bp, buf, \"ptp\");\n\n\tpps = pps_lookup_dev(bp->ptp);\n\tif (pps)\n\t\tptp_ocp_symlink(bp, pps->dev, \"pps\");\n\n\tptp_ocp_debugfs_add_device(bp);\n\n\treturn 0;\n}\n\nstatic void\nptp_ocp_phc_info(struct ptp_ocp *bp)\n{\n\tstruct timespec64 ts;\n\tu32 version, select;\n\tbool sync;\n\n\tversion = ioread32(&bp->reg->version);\n\tselect = ioread32(&bp->reg->select);\n\tdev_info(&bp->pdev->dev, \"Version %d.%d.%d, clock %s, device ptp%d\\n\",\n\t\t version >> 24, (version >> 16) & 0xff, version & 0xffff,\n\t\t ptp_ocp_select_name_from_val(ptp_ocp_clock, select >> 16),\n\t\t ptp_clock_index(bp->ptp));\n\n\tsync = ioread32(&bp->reg->status) & OCP_STATUS_IN_SYNC;\n\tif (!ptp_ocp_gettimex(&bp->ptp_info, &ts, NULL))\n\t\tdev_info(&bp->pdev->dev, \"Time: %lld.%ld, %s\\n\",\n\t\t\t ts.tv_sec, ts.tv_nsec,\n\t\t\t sync ? \"in-sync\" : \"UNSYNCED\");\n}\n\nstatic void\nptp_ocp_serial_info(struct device *dev, const char *name, int port, int baud)\n{\n\tif (port != -1)\n\t\tdev_info(dev, \"%5s: /dev/ttyS%-2d @ %6d\\n\", name, port, baud);\n}\n\nstatic void\nptp_ocp_info(struct ptp_ocp *bp)\n{\n\tstatic int nmea_baud[] = {\n\t\t1200, 2400, 4800, 9600, 19200, 38400,\n\t\t57600, 115200, 230400, 460800, 921600,\n\t\t1000000, 2000000\n\t};\n\tstruct device *dev = &bp->pdev->dev;\n\tu32 reg;\n\n\tptp_ocp_phc_info(bp);\n\n\tptp_ocp_serial_info(dev, \"GNSS\", bp->gnss_port.line,\n\t\t\t    bp->gnss_port.baud);\n\tptp_ocp_serial_info(dev, \"GNSS2\", bp->gnss2_port.line,\n\t\t\t    bp->gnss2_port.baud);\n\tptp_ocp_serial_info(dev, \"MAC\", bp->mac_port.line, bp->mac_port.baud);\n\tif (bp->nmea_out && bp->nmea_port.line != -1) {\n\t\tbp->nmea_port.baud = -1;\n\n\t\treg = ioread32(&bp->nmea_out->uart_baud);\n\t\tif (reg < ARRAY_SIZE(nmea_baud))\n\t\t\tbp->nmea_port.baud = nmea_baud[reg];\n\n\t\tptp_ocp_serial_info(dev, \"NMEA\", bp->nmea_port.line,\n\t\t\t\t    bp->nmea_port.baud);\n\t}\n}\n\nstatic void\nptp_ocp_detach_sysfs(struct ptp_ocp *bp)\n{\n\tstruct device *dev = &bp->dev;\n\n\tsysfs_remove_link(&dev->kobj, \"ttyGNSS\");\n\tsysfs_remove_link(&dev->kobj, \"ttyGNSS2\");\n\tsysfs_remove_link(&dev->kobj, \"ttyMAC\");\n\tsysfs_remove_link(&dev->kobj, \"ptp\");\n\tsysfs_remove_link(&dev->kobj, \"pps\");\n}\n\nstatic void\nptp_ocp_detach(struct ptp_ocp *bp)\n{\n\tint i;\n\n\tptp_ocp_debugfs_remove_device(bp);\n\tptp_ocp_detach_sysfs(bp);\n\tptp_ocp_attr_group_del(bp);\n\tif (timer_pending(&bp->watchdog))\n\t\tdel_timer_sync(&bp->watchdog);\n\tif (bp->ts0)\n\t\tptp_ocp_unregister_ext(bp->ts0);\n\tif (bp->ts1)\n\t\tptp_ocp_unregister_ext(bp->ts1);\n\tif (bp->ts2)\n\t\tptp_ocp_unregister_ext(bp->ts2);\n\tif (bp->ts3)\n\t\tptp_ocp_unregister_ext(bp->ts3);\n\tif (bp->ts4)\n\t\tptp_ocp_unregister_ext(bp->ts4);\n\tif (bp->pps)\n\t\tptp_ocp_unregister_ext(bp->pps);\n\tfor (i = 0; i < 4; i++)\n\t\tif (bp->signal_out[i])\n\t\t\tptp_ocp_unregister_ext(bp->signal_out[i]);\n\tif (bp->gnss_port.line != -1)\n\t\tserial8250_unregister_port(bp->gnss_port.line);\n\tif (bp->gnss2_port.line != -1)\n\t\tserial8250_unregister_port(bp->gnss2_port.line);\n\tif (bp->mac_port.line != -1)\n\t\tserial8250_unregister_port(bp->mac_port.line);\n\tif (bp->nmea_port.line != -1)\n\t\tserial8250_unregister_port(bp->nmea_port.line);\n\tplatform_device_unregister(bp->spi_flash);\n\tplatform_device_unregister(bp->i2c_ctrl);\n\tif (bp->i2c_clk)\n\t\tclk_hw_unregister_fixed_rate(bp->i2c_clk);\n\tif (bp->n_irqs)\n\t\tpci_free_irq_vectors(bp->pdev);\n\tif (bp->ptp)\n\t\tptp_clock_unregister(bp->ptp);\n\tkfree(bp->ptp_info.pin_config);\n\tdevice_unregister(&bp->dev);\n}\n\nstatic int\nptp_ocp_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct devlink *devlink;\n\tstruct ptp_ocp *bp;\n\tint err;\n\n\tdevlink = devlink_alloc(&ptp_ocp_devlink_ops, sizeof(*bp), &pdev->dev);\n\tif (!devlink) {\n\t\tdev_err(&pdev->dev, \"devlink_alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"pci_enable_device\\n\");\n\t\tgoto out_free;\n\t}\n\n\tbp = devlink_priv(devlink);\n\terr = ptp_ocp_device_init(bp, pdev);\n\tif (err)\n\t\tgoto out_disable;\n\n\t \n\terr = pci_alloc_irq_vectors(pdev, 1, 17, PCI_IRQ_MSI | PCI_IRQ_MSIX);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"alloc_irq_vectors err: %d\\n\", err);\n\t\tgoto out;\n\t}\n\tbp->n_irqs = err;\n\tpci_set_master(pdev);\n\n\terr = ptp_ocp_register_resources(bp, id->driver_data);\n\tif (err)\n\t\tgoto out;\n\n\tbp->ptp = ptp_clock_register(&bp->ptp_info, &pdev->dev);\n\tif (IS_ERR(bp->ptp)) {\n\t\terr = PTR_ERR(bp->ptp);\n\t\tdev_err(&pdev->dev, \"ptp_clock_register: %d\\n\", err);\n\t\tbp->ptp = NULL;\n\t\tgoto out;\n\t}\n\n\terr = ptp_ocp_complete(bp);\n\tif (err)\n\t\tgoto out;\n\n\tptp_ocp_info(bp);\n\tdevlink_register(devlink);\n\treturn 0;\n\nout:\n\tptp_ocp_detach(bp);\nout_disable:\n\tpci_disable_device(pdev);\nout_free:\n\tdevlink_free(devlink);\n\treturn err;\n}\n\nstatic void\nptp_ocp_remove(struct pci_dev *pdev)\n{\n\tstruct ptp_ocp *bp = pci_get_drvdata(pdev);\n\tstruct devlink *devlink = priv_to_devlink(bp);\n\n\tdevlink_unregister(devlink);\n\tptp_ocp_detach(bp);\n\tpci_disable_device(pdev);\n\n\tdevlink_free(devlink);\n}\n\nstatic struct pci_driver ptp_ocp_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= ptp_ocp_pcidev_id,\n\t.probe\t\t= ptp_ocp_probe,\n\t.remove\t\t= ptp_ocp_remove,\n};\n\nstatic int\nptp_ocp_i2c_notifier_call(struct notifier_block *nb,\n\t\t\t  unsigned long action, void *data)\n{\n\tstruct device *dev, *child = data;\n\tstruct ptp_ocp *bp;\n\tbool add;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\tadd = action == BUS_NOTIFY_ADD_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (!i2c_verify_adapter(child))\n\t\treturn 0;\n\n\tdev = child;\n\twhile ((dev = dev->parent))\n\t\tif (dev->driver && !strcmp(dev->driver->name, KBUILD_MODNAME))\n\t\t\tgoto found;\n\treturn 0;\n\nfound:\n\tbp = dev_get_drvdata(dev);\n\tif (add)\n\t\tptp_ocp_symlink(bp, child, \"i2c\");\n\telse\n\t\tsysfs_remove_link(&bp->dev.kobj, \"i2c\");\n\n\treturn 0;\n}\n\nstatic struct notifier_block ptp_ocp_i2c_notifier = {\n\t.notifier_call = ptp_ocp_i2c_notifier_call,\n};\n\nstatic int __init\nptp_ocp_init(void)\n{\n\tconst char *what;\n\tint err;\n\n\tptp_ocp_debugfs_init();\n\n\twhat = \"timecard class\";\n\terr = class_register(&timecard_class);\n\tif (err)\n\t\tgoto out;\n\n\twhat = \"i2c notifier\";\n\terr = bus_register_notifier(&i2c_bus_type, &ptp_ocp_i2c_notifier);\n\tif (err)\n\t\tgoto out_notifier;\n\n\twhat = \"ptp_ocp driver\";\n\terr = pci_register_driver(&ptp_ocp_driver);\n\tif (err)\n\t\tgoto out_register;\n\n\treturn 0;\n\nout_register:\n\tbus_unregister_notifier(&i2c_bus_type, &ptp_ocp_i2c_notifier);\nout_notifier:\n\tclass_unregister(&timecard_class);\nout:\n\tptp_ocp_debugfs_fini();\n\tpr_err(KBUILD_MODNAME \": failed to register %s: %d\\n\", what, err);\n\treturn err;\n}\n\nstatic void __exit\nptp_ocp_fini(void)\n{\n\tbus_unregister_notifier(&i2c_bus_type, &ptp_ocp_i2c_notifier);\n\tpci_unregister_driver(&ptp_ocp_driver);\n\tclass_unregister(&timecard_class);\n\tptp_ocp_debugfs_fini();\n}\n\nmodule_init(ptp_ocp_init);\nmodule_exit(ptp_ocp_fini);\n\nMODULE_DESCRIPTION(\"OpenCompute TimeCard driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}