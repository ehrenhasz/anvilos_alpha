{
  "module_name": "ptp_dfl_tod.c",
  "hash_id": "ae1e62b49b73b6055375575cd48b38342be55cd0406d3e5f4fb0486a0dfc60c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_dfl_tod.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/dfl.h>\n#include <linux/gcd.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/spinlock.h>\n#include <linux/units.h>\n\n#define FME_FEATURE_ID_TOD\t\t0x22\n\n \n#define TOD_CLK_FREQ\t\t\t0x038\n\n \n#define TOD_SECONDSH\t\t\t0x100\n#define TOD_SECONDSL\t\t\t0x104\n#define TOD_NANOSEC\t\t\t0x108\n#define TOD_PERIOD\t\t\t0x110\n#define TOD_ADJUST_PERIOD\t\t0x114\n#define TOD_ADJUST_COUNT\t\t0x118\n#define TOD_DRIFT_ADJUST\t\t0x11c\n#define TOD_DRIFT_ADJUST_RATE\t\t0x120\n#define PERIOD_FRAC_OFFSET\t\t16\n#define SECONDS_MSB\t\t\tGENMASK_ULL(47, 32)\n#define SECONDS_LSB\t\t\tGENMASK_ULL(31, 0)\n#define TOD_SECONDSH_SEC_MSB\t\tGENMASK_ULL(15, 0)\n\n#define CAL_SECONDS(m, l)\t\t((FIELD_GET(TOD_SECONDSH_SEC_MSB, (m)) << 32) | (l))\n\n#define TOD_PERIOD_MASK\t\tGENMASK_ULL(19, 0)\n#define TOD_PERIOD_MAX\t\t\tFIELD_MAX(TOD_PERIOD_MASK)\n#define TOD_PERIOD_MIN\t\t\t0\n#define TOD_DRIFT_ADJUST_MASK\t\tGENMASK_ULL(15, 0)\n#define TOD_DRIFT_ADJUST_FNS_MAX\tFIELD_MAX(TOD_DRIFT_ADJUST_MASK)\n#define TOD_DRIFT_ADJUST_RATE_MAX\tTOD_DRIFT_ADJUST_FNS_MAX\n#define TOD_ADJUST_COUNT_MASK\t\tGENMASK_ULL(19, 0)\n#define TOD_ADJUST_COUNT_MAX\t\tFIELD_MAX(TOD_ADJUST_COUNT_MASK)\n#define TOD_ADJUST_INTERVAL_US\t\t10\n#define TOD_ADJUST_MS\t\t\t\\\n\t\t(((TOD_PERIOD_MAX >> 16) + 1) * (TOD_ADJUST_COUNT_MAX + 1))\n#define TOD_ADJUST_MS_MAX\t\t(TOD_ADJUST_MS / MICRO)\n#define TOD_ADJUST_MAX_US\t\t(TOD_ADJUST_MS_MAX * USEC_PER_MSEC)\n#define TOD_MAX_ADJ\t\t\t(500 * MEGA)\n\nstruct dfl_tod {\n\tstruct ptp_clock_info ptp_clock_ops;\n\tstruct device *dev;\n\tstruct ptp_clock *ptp_clock;\n\n\t \n\tvoid __iomem *tod_ctrl;\n\n\t \n\tspinlock_t tod_lock;\n};\n\n \nstatic int fine_adjust_tod_clock(struct dfl_tod *dt, u32 adjust_period,\n\t\t\t\t u32 adjust_count)\n{\n\tvoid __iomem *base = dt->tod_ctrl;\n\tu32 val;\n\n\twritel(adjust_period, base + TOD_ADJUST_PERIOD);\n\twritel(adjust_count, base + TOD_ADJUST_COUNT);\n\n\t \n\treturn readl_poll_timeout_atomic(base + TOD_ADJUST_COUNT, val, !val, TOD_ADJUST_INTERVAL_US,\n\t\t\t\t  TOD_ADJUST_MAX_US);\n}\n\n \nstatic int coarse_adjust_tod_clock(struct dfl_tod *dt, s64 delta)\n{\n\tu32 seconds_msb, seconds_lsb, nanosec;\n\tvoid __iomem *base = dt->tod_ctrl;\n\tu64 seconds, now;\n\n\tif (delta == 0)\n\t\treturn 0;\n\n\tnanosec = readl(base + TOD_NANOSEC);\n\tseconds_lsb = readl(base + TOD_SECONDSL);\n\tseconds_msb = readl(base + TOD_SECONDSH);\n\n\t \n\tseconds = CAL_SECONDS(seconds_msb, seconds_lsb);\n\tnow = seconds * NSEC_PER_SEC + nanosec + delta;\n\n\tseconds = div_u64_rem(now, NSEC_PER_SEC, &nanosec);\n\tseconds_msb = FIELD_GET(SECONDS_MSB, seconds);\n\tseconds_lsb = FIELD_GET(SECONDS_LSB, seconds);\n\n\twritel(seconds_msb, base + TOD_SECONDSH);\n\twritel(seconds_lsb, base + TOD_SECONDSL);\n\twritel(nanosec, base + TOD_NANOSEC);\n\n\treturn 0;\n}\n\nstatic int dfl_tod_adjust_fine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct dfl_tod *dt = container_of(ptp, struct dfl_tod, ptp_clock_ops);\n\tu32 tod_period, tod_rem, tod_drift_adjust_fns, tod_drift_adjust_rate;\n\tvoid __iomem *base = dt->tod_ctrl;\n\tunsigned long flags, rate;\n\tu64 ppb;\n\n\t \n\trate = readl(base + TOD_CLK_FREQ);\n\n\t \n\tppb = scaled_ppm_to_ppb(scaled_ppm) + GIGA;\n\n\ttod_period = div_u64_rem(ppb << PERIOD_FRAC_OFFSET, rate, &tod_rem);\n\tif (tod_period > TOD_PERIOD_MAX)\n\t\treturn -ERANGE;\n\n\t \n\ttod_drift_adjust_fns = tod_rem / gcd(tod_rem, rate);\n\ttod_drift_adjust_rate = rate / gcd(tod_rem, rate);\n\n\twhile ((tod_drift_adjust_fns > TOD_DRIFT_ADJUST_FNS_MAX) ||\n\t       (tod_drift_adjust_rate > TOD_DRIFT_ADJUST_RATE_MAX)) {\n\t\ttod_drift_adjust_fns >>= 1;\n\t\ttod_drift_adjust_rate >>= 1;\n\t}\n\n\tif (tod_drift_adjust_fns == 0)\n\t\ttod_drift_adjust_rate = 0;\n\n\tspin_lock_irqsave(&dt->tod_lock, flags);\n\twritel(tod_period, base + TOD_PERIOD);\n\twritel(0, base + TOD_ADJUST_PERIOD);\n\twritel(0, base + TOD_ADJUST_COUNT);\n\twritel(tod_drift_adjust_fns, base + TOD_DRIFT_ADJUST);\n\twritel(tod_drift_adjust_rate, base + TOD_DRIFT_ADJUST_RATE);\n\tspin_unlock_irqrestore(&dt->tod_lock, flags);\n\n\treturn 0;\n}\n\nstatic int dfl_tod_adjust_time(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct dfl_tod *dt = container_of(ptp, struct dfl_tod, ptp_clock_ops);\n\tu32 period, diff, rem, rem_period, adj_period;\n\tvoid __iomem *base = dt->tod_ctrl;\n\tunsigned long flags;\n\tbool neg_adj;\n\tu64 count;\n\tint ret;\n\n\tneg_adj = delta < 0;\n\tif (neg_adj)\n\t\tdelta = -delta;\n\n\tspin_lock_irqsave(&dt->tod_lock, flags);\n\n\t \n\tperiod = readl(base + TOD_PERIOD);\n\n\tif (neg_adj) {\n\t\tdiff = (period - TOD_PERIOD_MIN) >> PERIOD_FRAC_OFFSET;\n\t\tadj_period = period - (diff << PERIOD_FRAC_OFFSET);\n\t\tcount = div_u64_rem(delta, diff, &rem);\n\t\trem_period = period - (rem << PERIOD_FRAC_OFFSET);\n\t} else {\n\t\tdiff = (TOD_PERIOD_MAX - period) >> PERIOD_FRAC_OFFSET;\n\t\tadj_period = period + (diff << PERIOD_FRAC_OFFSET);\n\t\tcount = div_u64_rem(delta, diff, &rem);\n\t\trem_period = period + (rem << PERIOD_FRAC_OFFSET);\n\t}\n\n\tret = 0;\n\n\tif (count > TOD_ADJUST_COUNT_MAX) {\n\t\tret = coarse_adjust_tod_clock(dt, delta);\n\t} else {\n\t\t \n\t\tif (count)\n\t\t\tret = fine_adjust_tod_clock(dt, adj_period, count);\n\n\t\t \n\t\tif (rem)\n\t\t\tret = fine_adjust_tod_clock(dt, rem_period, 1);\n\t}\n\n\tspin_unlock_irqrestore(&dt->tod_lock, flags);\n\n\treturn ret;\n}\n\nstatic int dfl_tod_get_timex(struct ptp_clock_info *ptp, struct timespec64 *ts,\n\t\t\t     struct ptp_system_timestamp *sts)\n{\n\tstruct dfl_tod *dt = container_of(ptp, struct dfl_tod, ptp_clock_ops);\n\tu32 seconds_msb, seconds_lsb, nanosec;\n\tvoid __iomem *base = dt->tod_ctrl;\n\tunsigned long flags;\n\tu64 seconds;\n\n\tspin_lock_irqsave(&dt->tod_lock, flags);\n\tptp_read_system_prets(sts);\n\tnanosec = readl(base + TOD_NANOSEC);\n\tseconds_lsb = readl(base + TOD_SECONDSL);\n\tseconds_msb = readl(base + TOD_SECONDSH);\n\tptp_read_system_postts(sts);\n\tspin_unlock_irqrestore(&dt->tod_lock, flags);\n\n\tseconds = CAL_SECONDS(seconds_msb, seconds_lsb);\n\n\tts->tv_nsec = nanosec;\n\tts->tv_sec = seconds;\n\n\treturn 0;\n}\n\nstatic int dfl_tod_set_time(struct ptp_clock_info *ptp,\n\t\t\t    const struct timespec64 *ts)\n{\n\tstruct dfl_tod *dt = container_of(ptp, struct dfl_tod, ptp_clock_ops);\n\tu32 seconds_msb = FIELD_GET(SECONDS_MSB, ts->tv_sec);\n\tu32 seconds_lsb = FIELD_GET(SECONDS_LSB, ts->tv_sec);\n\tu32 nanosec = FIELD_GET(SECONDS_LSB, ts->tv_nsec);\n\tvoid __iomem *base = dt->tod_ctrl;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dt->tod_lock, flags);\n\twritel(seconds_msb, base + TOD_SECONDSH);\n\twritel(seconds_lsb, base + TOD_SECONDSL);\n\twritel(nanosec, base + TOD_NANOSEC);\n\tspin_unlock_irqrestore(&dt->tod_lock, flags);\n\n\treturn 0;\n}\n\nstatic struct ptp_clock_info dfl_tod_clock_ops = {\n\t.owner = THIS_MODULE,\n\t.name = \"dfl_tod\",\n\t.max_adj = TOD_MAX_ADJ,\n\t.adjfine = dfl_tod_adjust_fine,\n\t.adjtime = dfl_tod_adjust_time,\n\t.gettimex64 = dfl_tod_get_timex,\n\t.settime64 = dfl_tod_set_time,\n};\n\nstatic int dfl_tod_probe(struct dfl_device *ddev)\n{\n\tstruct device *dev = &ddev->dev;\n\tstruct dfl_tod *dt;\n\n\tdt = devm_kzalloc(dev, sizeof(*dt), GFP_KERNEL);\n\tif (!dt)\n\t\treturn -ENOMEM;\n\n\tdt->tod_ctrl = devm_ioremap_resource(dev, &ddev->mmio_res);\n\tif (IS_ERR(dt->tod_ctrl))\n\t\treturn PTR_ERR(dt->tod_ctrl);\n\n\tdt->dev = dev;\n\tspin_lock_init(&dt->tod_lock);\n\tdev_set_drvdata(dev, dt);\n\n\tdt->ptp_clock_ops = dfl_tod_clock_ops;\n\n\tdt->ptp_clock = ptp_clock_register(&dt->ptp_clock_ops, dev);\n\tif (IS_ERR(dt->ptp_clock))\n\t\treturn dev_err_probe(dt->dev, PTR_ERR(dt->ptp_clock),\n\t\t\t\t     \"Unable to register PTP clock\\n\");\n\n\treturn 0;\n}\n\nstatic void dfl_tod_remove(struct dfl_device *ddev)\n{\n\tstruct dfl_tod *dt = dev_get_drvdata(&ddev->dev);\n\n\tptp_clock_unregister(dt->ptp_clock);\n}\n\nstatic const struct dfl_device_id dfl_tod_ids[] = {\n\t{ FME_ID, FME_FEATURE_ID_TOD },\n\t{ }\n};\nMODULE_DEVICE_TABLE(dfl, dfl_tod_ids);\n\nstatic struct dfl_driver dfl_tod_driver = {\n\t.drv = {\n\t\t.name = \"dfl-tod\",\n\t},\n\t.id_table = dfl_tod_ids,\n\t.probe = dfl_tod_probe,\n\t.remove = dfl_tod_remove,\n};\nmodule_dfl_driver(dfl_tod_driver);\n\nMODULE_DESCRIPTION(\"FPGA DFL ToD driver\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}