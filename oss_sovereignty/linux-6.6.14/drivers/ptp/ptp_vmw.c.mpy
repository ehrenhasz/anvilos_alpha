{
  "module_name": "ptp_vmw.c",
  "hash_id": "26952a6b6e79933cdc8ed437a3feb7b6663df417cf06b20fa5c430e909146252",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_vmw.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/ptp_clock_kernel.h>\n#include <asm/hypervisor.h>\n#include <asm/vmware.h>\n\n#define VMWARE_MAGIC 0x564D5868\n#define VMWARE_CMD_PCLK(nr) ((nr << 16) | 97)\n#define VMWARE_CMD_PCLK_GETTIME VMWARE_CMD_PCLK(0)\n\nstatic struct acpi_device *ptp_vmw_acpi_device;\nstatic struct ptp_clock *ptp_vmw_clock;\n\n\nstatic int ptp_vmw_pclk_read(u64 *ns)\n{\n\tu32 ret, nsec_hi, nsec_lo, unused1, unused2, unused3;\n\n\tasm volatile (VMWARE_HYPERCALL :\n\t\t\"=a\"(ret), \"=b\"(nsec_hi), \"=c\"(nsec_lo), \"=d\"(unused1),\n\t\t\"=S\"(unused2), \"=D\"(unused3) :\n\t\t\"a\"(VMWARE_MAGIC), \"b\"(0),\n\t\t\"c\"(VMWARE_CMD_PCLK_GETTIME), \"d\"(0) :\n\t\t\"memory\");\n\n\tif (ret == 0)\n\t\t*ns = ((u64)nsec_hi << 32) | nsec_lo;\n\treturn ret;\n}\n\n \n\nstatic int ptp_vmw_adjtime(struct ptp_clock_info *info, s64 delta)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ptp_vmw_adjfine(struct ptp_clock_info *info, long delta)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ptp_vmw_gettime(struct ptp_clock_info *info, struct timespec64 *ts)\n{\n\tu64 ns;\n\n\tif (ptp_vmw_pclk_read(&ns) != 0)\n\t\treturn -EIO;\n\t*ts = ns_to_timespec64(ns);\n\treturn 0;\n}\n\nstatic int ptp_vmw_settime(struct ptp_clock_info *info,\n\t\t\t  const struct timespec64 *ts)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ptp_vmw_enable(struct ptp_clock_info *info,\n\t\t\t struct ptp_clock_request *request, int on)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic struct ptp_clock_info ptp_vmw_clock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ptp_vmw\",\n\t.max_adj\t= 0,\n\t.adjtime\t= ptp_vmw_adjtime,\n\t.adjfine\t= ptp_vmw_adjfine,\n\t.gettime64\t= ptp_vmw_gettime,\n\t.settime64\t= ptp_vmw_settime,\n\t.enable\t\t= ptp_vmw_enable,\n};\n\n \n\nstatic int ptp_vmw_acpi_add(struct acpi_device *device)\n{\n\tptp_vmw_clock = ptp_clock_register(&ptp_vmw_clock_info, NULL);\n\tif (IS_ERR(ptp_vmw_clock)) {\n\t\tpr_err(\"failed to register ptp clock\\n\");\n\t\treturn PTR_ERR(ptp_vmw_clock);\n\t}\n\n\tptp_vmw_acpi_device = device;\n\treturn 0;\n}\n\nstatic void ptp_vmw_acpi_remove(struct acpi_device *device)\n{\n\tptp_clock_unregister(ptp_vmw_clock);\n}\n\nstatic const struct acpi_device_id ptp_vmw_acpi_device_ids[] = {\n\t{ \"VMW0005\", 0 },\n\t{ \"\", 0 },\n};\n\nMODULE_DEVICE_TABLE(acpi, ptp_vmw_acpi_device_ids);\n\nstatic struct acpi_driver ptp_vmw_acpi_driver = {\n\t.name = \"ptp_vmw\",\n\t.ids = ptp_vmw_acpi_device_ids,\n\t.ops = {\n\t\t.add = ptp_vmw_acpi_add,\n\t\t.remove\t= ptp_vmw_acpi_remove\n\t},\n\t.owner\t= THIS_MODULE\n};\n\nstatic int __init ptp_vmw_init(void)\n{\n\tif (x86_hyper_type != X86_HYPER_VMWARE)\n\t\treturn -1;\n\treturn acpi_bus_register_driver(&ptp_vmw_acpi_driver);\n}\n\nstatic void __exit ptp_vmw_exit(void)\n{\n\tacpi_bus_unregister_driver(&ptp_vmw_acpi_driver);\n}\n\nmodule_init(ptp_vmw_init);\nmodule_exit(ptp_vmw_exit);\n\nMODULE_DESCRIPTION(\"VMware virtual PTP clock driver\");\nMODULE_AUTHOR(\"VMware, Inc.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}