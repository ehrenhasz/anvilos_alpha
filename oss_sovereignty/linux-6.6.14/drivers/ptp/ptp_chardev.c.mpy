{
  "module_name": "ptp_chardev.c",
  "hash_id": "64aed01e9da52b6171fba5a0725da651a69ee17feec6d84c3997ea815b4f1a03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_chardev.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/posix-clock.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/timekeeping.h>\n\n#include <linux/nospec.h>\n\n#include \"ptp_private.h\"\n\nstatic int ptp_disable_pinfunc(struct ptp_clock_info *ops,\n\t\t\t       enum ptp_pin_function func, unsigned int chan)\n{\n\tstruct ptp_clock_request rq;\n\tint err = 0;\n\n\tmemset(&rq, 0, sizeof(rq));\n\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\t\tbreak;\n\tcase PTP_PF_EXTTS:\n\t\trq.type = PTP_CLK_REQ_EXTTS;\n\t\trq.extts.index = chan;\n\t\terr = ops->enable(ops, &rq, 0);\n\t\tbreak;\n\tcase PTP_PF_PEROUT:\n\t\trq.type = PTP_CLK_REQ_PEROUT;\n\t\trq.perout.index = chan;\n\t\terr = ops->enable(ops, &rq, 0);\n\t\tbreak;\n\tcase PTP_PF_PHYSYNC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn err;\n}\n\nint ptp_set_pinfunc(struct ptp_clock *ptp, unsigned int pin,\n\t\t    enum ptp_pin_function func, unsigned int chan)\n{\n\tstruct ptp_clock_info *info = ptp->info;\n\tstruct ptp_pin_desc *pin1 = NULL, *pin2 = &info->pin_config[pin];\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < info->n_pins; i++) {\n\t\tif (info->pin_config[i].func == func &&\n\t\t    info->pin_config[i].chan == chan) {\n\t\t\tpin1 = &info->pin_config[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pin1 && i == pin)\n\t\treturn 0;\n\n\t \n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\t\tbreak;\n\tcase PTP_PF_EXTTS:\n\t\tif (chan >= info->n_ext_ts)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PTP_PF_PEROUT:\n\t\tif (chan >= info->n_per_out)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PTP_PF_PHYSYNC:\n\t\tif (chan != 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->verify(info, pin, func, chan)) {\n\t\tpr_err(\"driver cannot use function %u on pin %u\\n\", func, chan);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (pin1) {\n\t\tptp_disable_pinfunc(info, func, chan);\n\t\tpin1->func = PTP_PF_NONE;\n\t\tpin1->chan = 0;\n\t}\n\tptp_disable_pinfunc(info, pin2->func, pin2->chan);\n\tpin2->func = func;\n\tpin2->chan = chan;\n\n\treturn 0;\n}\n\nint ptp_open(struct posix_clock *pc, fmode_t fmode)\n{\n\treturn 0;\n}\n\nlong ptp_ioctl(struct posix_clock *pc, unsigned int cmd, unsigned long arg)\n{\n\tstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\n\tstruct ptp_sys_offset_extended *extoff = NULL;\n\tstruct ptp_sys_offset_precise precise_offset;\n\tstruct system_device_crosststamp xtstamp;\n\tstruct ptp_clock_info *ops = ptp->info;\n\tstruct ptp_sys_offset *sysoff = NULL;\n\tstruct ptp_system_timestamp sts;\n\tstruct ptp_clock_request req;\n\tstruct ptp_clock_caps caps;\n\tstruct ptp_clock_time *pct;\n\tunsigned int i, pin_index;\n\tstruct ptp_pin_desc pd;\n\tstruct timespec64 ts;\n\tint enable, err = 0;\n\n\tswitch (cmd) {\n\n\tcase PTP_CLOCK_GETCAPS:\n\tcase PTP_CLOCK_GETCAPS2:\n\t\tmemset(&caps, 0, sizeof(caps));\n\n\t\tcaps.max_adj = ptp->info->max_adj;\n\t\tcaps.n_alarm = ptp->info->n_alarm;\n\t\tcaps.n_ext_ts = ptp->info->n_ext_ts;\n\t\tcaps.n_per_out = ptp->info->n_per_out;\n\t\tcaps.pps = ptp->info->pps;\n\t\tcaps.n_pins = ptp->info->n_pins;\n\t\tcaps.cross_timestamping = ptp->info->getcrosststamp != NULL;\n\t\tcaps.adjust_phase = ptp->info->adjphase != NULL &&\n\t\t\t\t    ptp->info->getmaxphase != NULL;\n\t\tif (caps.adjust_phase)\n\t\t\tcaps.max_phase_adj = ptp->info->getmaxphase(ptp->info);\n\t\tif (copy_to_user((void __user *)arg, &caps, sizeof(caps)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase PTP_EXTTS_REQUEST:\n\tcase PTP_EXTTS_REQUEST2:\n\t\tmemset(&req, 0, sizeof(req));\n\n\t\tif (copy_from_user(&req.extts, (void __user *)arg,\n\t\t\t\t   sizeof(req.extts))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (cmd == PTP_EXTTS_REQUEST2) {\n\t\t\t \n\t\t\treq.extts.flags |= PTP_STRICT_FLAGS;\n\t\t\t \n\t\t\tif ((req.extts.flags & ~PTP_EXTTS_VALID_FLAGS) ||\n\t\t\t    req.extts.rsv[0] || req.extts.rsv[1]) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif ((req.extts.flags & PTP_ENABLE_FEATURE) &&\n\t\t\t    (req.extts.flags & PTP_EXTTS_EDGES) == 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (cmd == PTP_EXTTS_REQUEST) {\n\t\t\treq.extts.flags &= PTP_EXTTS_V1_VALID_FLAGS;\n\t\t\treq.extts.rsv[0] = 0;\n\t\t\treq.extts.rsv[1] = 0;\n\t\t}\n\t\tif (req.extts.index >= ops->n_ext_ts) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\treq.type = PTP_CLK_REQ_EXTTS;\n\t\tenable = req.extts.flags & PTP_ENABLE_FEATURE ? 1 : 0;\n\t\tif (mutex_lock_interruptible(&ptp->pincfg_mux))\n\t\t\treturn -ERESTARTSYS;\n\t\terr = ops->enable(ops, &req, enable);\n\t\tmutex_unlock(&ptp->pincfg_mux);\n\t\tbreak;\n\n\tcase PTP_PEROUT_REQUEST:\n\tcase PTP_PEROUT_REQUEST2:\n\t\tmemset(&req, 0, sizeof(req));\n\n\t\tif (copy_from_user(&req.perout, (void __user *)arg,\n\t\t\t\t   sizeof(req.perout))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (cmd == PTP_PEROUT_REQUEST2) {\n\t\t\tstruct ptp_perout_request *perout = &req.perout;\n\n\t\t\tif (perout->flags & ~PTP_PEROUT_VALID_FLAGS) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (!(perout->flags & PTP_PEROUT_DUTY_CYCLE) &&\n\t\t\t    (perout->rsv[0] || perout->rsv[1] ||\n\t\t\t     perout->rsv[2] || perout->rsv[3])) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (perout->flags & PTP_PEROUT_DUTY_CYCLE) {\n\t\t\t\t \n\t\t\t\tif (perout->on.sec > perout->period.sec ||\n\t\t\t\t    (perout->on.sec == perout->period.sec &&\n\t\t\t\t     perout->on.nsec > perout->period.nsec)) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (perout->flags & PTP_PEROUT_PHASE) {\n\t\t\t\t \n\t\t\t\tif (perout->phase.sec > perout->period.sec ||\n\t\t\t\t    (perout->phase.sec == perout->period.sec &&\n\t\t\t\t     perout->phase.nsec >= perout->period.nsec)) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (cmd == PTP_PEROUT_REQUEST) {\n\t\t\treq.perout.flags &= PTP_PEROUT_V1_VALID_FLAGS;\n\t\t\treq.perout.rsv[0] = 0;\n\t\t\treq.perout.rsv[1] = 0;\n\t\t\treq.perout.rsv[2] = 0;\n\t\t\treq.perout.rsv[3] = 0;\n\t\t}\n\t\tif (req.perout.index >= ops->n_per_out) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\treq.type = PTP_CLK_REQ_PEROUT;\n\t\tenable = req.perout.period.sec || req.perout.period.nsec;\n\t\tif (mutex_lock_interruptible(&ptp->pincfg_mux))\n\t\t\treturn -ERESTARTSYS;\n\t\terr = ops->enable(ops, &req, enable);\n\t\tmutex_unlock(&ptp->pincfg_mux);\n\t\tbreak;\n\n\tcase PTP_ENABLE_PPS:\n\tcase PTP_ENABLE_PPS2:\n\t\tmemset(&req, 0, sizeof(req));\n\n\t\tif (!capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t\treq.type = PTP_CLK_REQ_PPS;\n\t\tenable = arg ? 1 : 0;\n\t\tif (mutex_lock_interruptible(&ptp->pincfg_mux))\n\t\t\treturn -ERESTARTSYS;\n\t\terr = ops->enable(ops, &req, enable);\n\t\tmutex_unlock(&ptp->pincfg_mux);\n\t\tbreak;\n\n\tcase PTP_SYS_OFFSET_PRECISE:\n\tcase PTP_SYS_OFFSET_PRECISE2:\n\t\tif (!ptp->info->getcrosststamp) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\terr = ptp->info->getcrosststamp(ptp->info, &xtstamp);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tmemset(&precise_offset, 0, sizeof(precise_offset));\n\t\tts = ktime_to_timespec64(xtstamp.device);\n\t\tprecise_offset.device.sec = ts.tv_sec;\n\t\tprecise_offset.device.nsec = ts.tv_nsec;\n\t\tts = ktime_to_timespec64(xtstamp.sys_realtime);\n\t\tprecise_offset.sys_realtime.sec = ts.tv_sec;\n\t\tprecise_offset.sys_realtime.nsec = ts.tv_nsec;\n\t\tts = ktime_to_timespec64(xtstamp.sys_monoraw);\n\t\tprecise_offset.sys_monoraw.sec = ts.tv_sec;\n\t\tprecise_offset.sys_monoraw.nsec = ts.tv_nsec;\n\t\tif (copy_to_user((void __user *)arg, &precise_offset,\n\t\t\t\t sizeof(precise_offset)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase PTP_SYS_OFFSET_EXTENDED:\n\tcase PTP_SYS_OFFSET_EXTENDED2:\n\t\tif (!ptp->info->gettimex64) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\textoff = memdup_user((void __user *)arg, sizeof(*extoff));\n\t\tif (IS_ERR(extoff)) {\n\t\t\terr = PTR_ERR(extoff);\n\t\t\textoff = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (extoff->n_samples > PTP_MAX_SAMPLES\n\t\t    || extoff->rsv[0] || extoff->rsv[1] || extoff->rsv[2]) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < extoff->n_samples; i++) {\n\t\t\terr = ptp->info->gettimex64(ptp->info, &ts, &sts);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\textoff->ts[i][0].sec = sts.pre_ts.tv_sec;\n\t\t\textoff->ts[i][0].nsec = sts.pre_ts.tv_nsec;\n\t\t\textoff->ts[i][1].sec = ts.tv_sec;\n\t\t\textoff->ts[i][1].nsec = ts.tv_nsec;\n\t\t\textoff->ts[i][2].sec = sts.post_ts.tv_sec;\n\t\t\textoff->ts[i][2].nsec = sts.post_ts.tv_nsec;\n\t\t}\n\t\tif (copy_to_user((void __user *)arg, extoff, sizeof(*extoff)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase PTP_SYS_OFFSET:\n\tcase PTP_SYS_OFFSET2:\n\t\tsysoff = memdup_user((void __user *)arg, sizeof(*sysoff));\n\t\tif (IS_ERR(sysoff)) {\n\t\t\terr = PTR_ERR(sysoff);\n\t\t\tsysoff = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (sysoff->n_samples > PTP_MAX_SAMPLES) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tpct = &sysoff->ts[0];\n\t\tfor (i = 0; i < sysoff->n_samples; i++) {\n\t\t\tktime_get_real_ts64(&ts);\n\t\t\tpct->sec = ts.tv_sec;\n\t\t\tpct->nsec = ts.tv_nsec;\n\t\t\tpct++;\n\t\t\tif (ops->gettimex64)\n\t\t\t\terr = ops->gettimex64(ops, &ts, NULL);\n\t\t\telse\n\t\t\t\terr = ops->gettime64(ops, &ts);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tpct->sec = ts.tv_sec;\n\t\t\tpct->nsec = ts.tv_nsec;\n\t\t\tpct++;\n\t\t}\n\t\tktime_get_real_ts64(&ts);\n\t\tpct->sec = ts.tv_sec;\n\t\tpct->nsec = ts.tv_nsec;\n\t\tif (copy_to_user((void __user *)arg, sysoff, sizeof(*sysoff)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase PTP_PIN_GETFUNC:\n\tcase PTP_PIN_GETFUNC2:\n\t\tif (copy_from_user(&pd, (void __user *)arg, sizeof(pd))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif ((pd.rsv[0] || pd.rsv[1] || pd.rsv[2]\n\t\t\t\t|| pd.rsv[3] || pd.rsv[4])\n\t\t\t&& cmd == PTP_PIN_GETFUNC2) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t} else if (cmd == PTP_PIN_GETFUNC) {\n\t\t\tpd.rsv[0] = 0;\n\t\t\tpd.rsv[1] = 0;\n\t\t\tpd.rsv[2] = 0;\n\t\t\tpd.rsv[3] = 0;\n\t\t\tpd.rsv[4] = 0;\n\t\t}\n\t\tpin_index = pd.index;\n\t\tif (pin_index >= ops->n_pins) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tpin_index = array_index_nospec(pin_index, ops->n_pins);\n\t\tif (mutex_lock_interruptible(&ptp->pincfg_mux))\n\t\t\treturn -ERESTARTSYS;\n\t\tpd = ops->pin_config[pin_index];\n\t\tmutex_unlock(&ptp->pincfg_mux);\n\t\tif (!err && copy_to_user((void __user *)arg, &pd, sizeof(pd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase PTP_PIN_SETFUNC:\n\tcase PTP_PIN_SETFUNC2:\n\t\tif (copy_from_user(&pd, (void __user *)arg, sizeof(pd))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif ((pd.rsv[0] || pd.rsv[1] || pd.rsv[2]\n\t\t\t\t|| pd.rsv[3] || pd.rsv[4])\n\t\t\t&& cmd == PTP_PIN_SETFUNC2) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t} else if (cmd == PTP_PIN_SETFUNC) {\n\t\t\tpd.rsv[0] = 0;\n\t\t\tpd.rsv[1] = 0;\n\t\t\tpd.rsv[2] = 0;\n\t\t\tpd.rsv[3] = 0;\n\t\t\tpd.rsv[4] = 0;\n\t\t}\n\t\tpin_index = pd.index;\n\t\tif (pin_index >= ops->n_pins) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tpin_index = array_index_nospec(pin_index, ops->n_pins);\n\t\tif (mutex_lock_interruptible(&ptp->pincfg_mux))\n\t\t\treturn -ERESTARTSYS;\n\t\terr = ptp_set_pinfunc(ptp, pin_index, pd.func, pd.chan);\n\t\tmutex_unlock(&ptp->pincfg_mux);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOTTY;\n\t\tbreak;\n\t}\n\nout:\n\tkfree(extoff);\n\tkfree(sysoff);\n\treturn err;\n}\n\n__poll_t ptp_poll(struct posix_clock *pc, struct file *fp, poll_table *wait)\n{\n\tstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\n\n\tpoll_wait(fp, &ptp->tsev_wq, wait);\n\n\treturn queue_cnt(&ptp->tsevq) ? EPOLLIN : 0;\n}\n\n#define EXTTS_BUFSIZE (PTP_BUF_TIMESTAMPS * sizeof(struct ptp_extts_event))\n\nssize_t ptp_read(struct posix_clock *pc,\n\t\t uint rdflags, char __user *buf, size_t cnt)\n{\n\tstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\n\tstruct timestamp_event_queue *queue = &ptp->tsevq;\n\tstruct ptp_extts_event *event;\n\tunsigned long flags;\n\tsize_t qcnt, i;\n\tint result;\n\n\tif (cnt % sizeof(struct ptp_extts_event) != 0)\n\t\treturn -EINVAL;\n\n\tif (cnt > EXTTS_BUFSIZE)\n\t\tcnt = EXTTS_BUFSIZE;\n\n\tcnt = cnt / sizeof(struct ptp_extts_event);\n\n\tif (mutex_lock_interruptible(&ptp->tsevq_mux))\n\t\treturn -ERESTARTSYS;\n\n\tif (wait_event_interruptible(ptp->tsev_wq,\n\t\t\t\t     ptp->defunct || queue_cnt(queue))) {\n\t\tmutex_unlock(&ptp->tsevq_mux);\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tif (ptp->defunct) {\n\t\tmutex_unlock(&ptp->tsevq_mux);\n\t\treturn -ENODEV;\n\t}\n\n\tevent = kmalloc(EXTTS_BUFSIZE, GFP_KERNEL);\n\tif (!event) {\n\t\tmutex_unlock(&ptp->tsevq_mux);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&queue->lock, flags);\n\n\tqcnt = queue_cnt(queue);\n\n\tif (cnt > qcnt)\n\t\tcnt = qcnt;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tevent[i] = queue->buf[queue->head];\n\t\t \n\t\tWRITE_ONCE(queue->head, (queue->head + 1) % PTP_MAX_TIMESTAMPS);\n\t}\n\n\tspin_unlock_irqrestore(&queue->lock, flags);\n\n\tcnt = cnt * sizeof(struct ptp_extts_event);\n\n\tmutex_unlock(&ptp->tsevq_mux);\n\n\tresult = cnt;\n\tif (copy_to_user(buf, event, cnt))\n\t\tresult = -EFAULT;\n\n\tkfree(event);\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}