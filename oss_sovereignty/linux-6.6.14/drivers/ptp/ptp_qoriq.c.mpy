{
  "module_name": "ptp_qoriq.c",
  "hash_id": "2d264b4776eab432b65ff8605792cab66eeb073eeb5506c4793c51f9a685e2a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_qoriq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/hrtimer.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/timex.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n\n#include <linux/fsl/ptp_qoriq.h>\n\n \n\n \nstatic u64 tmr_cnt_read(struct ptp_qoriq *ptp_qoriq)\n{\n\tstruct ptp_qoriq_registers *regs = &ptp_qoriq->regs;\n\tu64 ns;\n\tu32 lo, hi;\n\n\tlo = ptp_qoriq->read(&regs->ctrl_regs->tmr_cnt_l);\n\thi = ptp_qoriq->read(&regs->ctrl_regs->tmr_cnt_h);\n\tns = ((u64) hi) << 32;\n\tns |= lo;\n\treturn ns;\n}\n\n \nstatic void tmr_cnt_write(struct ptp_qoriq *ptp_qoriq, u64 ns)\n{\n\tstruct ptp_qoriq_registers *regs = &ptp_qoriq->regs;\n\tu32 hi = ns >> 32;\n\tu32 lo = ns & 0xffffffff;\n\n\tptp_qoriq->write(&regs->ctrl_regs->tmr_cnt_l, lo);\n\tptp_qoriq->write(&regs->ctrl_regs->tmr_cnt_h, hi);\n}\n\nstatic u64 tmr_offset_read(struct ptp_qoriq *ptp_qoriq)\n{\n\tstruct ptp_qoriq_registers *regs = &ptp_qoriq->regs;\n\tu32 lo, hi;\n\tu64 ns;\n\n\tlo = ptp_qoriq->read(&regs->ctrl_regs->tmroff_l);\n\thi = ptp_qoriq->read(&regs->ctrl_regs->tmroff_h);\n\tns = ((u64) hi) << 32;\n\tns |= lo;\n\treturn ns;\n}\n\nstatic void tmr_offset_write(struct ptp_qoriq *ptp_qoriq, u64 delta_ns)\n{\n\tstruct ptp_qoriq_registers *regs = &ptp_qoriq->regs;\n\tu32 lo = delta_ns & 0xffffffff;\n\tu32 hi = delta_ns >> 32;\n\n\tptp_qoriq->write(&regs->ctrl_regs->tmroff_l, lo);\n\tptp_qoriq->write(&regs->ctrl_regs->tmroff_h, hi);\n}\n\n \nstatic void set_alarm(struct ptp_qoriq *ptp_qoriq)\n{\n\tstruct ptp_qoriq_registers *regs = &ptp_qoriq->regs;\n\tu64 ns;\n\tu32 lo, hi;\n\n\tns = tmr_cnt_read(ptp_qoriq) + tmr_offset_read(ptp_qoriq)\n\t\t\t\t     + 1500000000ULL;\n\n\tns = div_u64(ns, 1000000000UL) * 1000000000ULL;\n\tns -= ptp_qoriq->tclk_period;\n\thi = ns >> 32;\n\tlo = ns & 0xffffffff;\n\tptp_qoriq->write(&regs->alarm_regs->tmr_alarm1_l, lo);\n\tptp_qoriq->write(&regs->alarm_regs->tmr_alarm1_h, hi);\n}\n\n \nstatic void set_fipers(struct ptp_qoriq *ptp_qoriq)\n{\n\tstruct ptp_qoriq_registers *regs = &ptp_qoriq->regs;\n\n\tset_alarm(ptp_qoriq);\n\tptp_qoriq->write(&regs->fiper_regs->tmr_fiper1, ptp_qoriq->tmr_fiper1);\n\tptp_qoriq->write(&regs->fiper_regs->tmr_fiper2, ptp_qoriq->tmr_fiper2);\n\n\tif (ptp_qoriq->fiper3_support)\n\t\tptp_qoriq->write(&regs->fiper_regs->tmr_fiper3,\n\t\t\t\t ptp_qoriq->tmr_fiper3);\n}\n\nint extts_clean_up(struct ptp_qoriq *ptp_qoriq, int index, bool update_event)\n{\n\tstruct ptp_qoriq_registers *regs = &ptp_qoriq->regs;\n\tstruct ptp_clock_event event;\n\tvoid __iomem *reg_etts_l;\n\tvoid __iomem *reg_etts_h;\n\tu32 valid, lo, hi;\n\n\tswitch (index) {\n\tcase 0:\n\t\tvalid = ETS1_VLD;\n\t\treg_etts_l = &regs->etts_regs->tmr_etts1_l;\n\t\treg_etts_h = &regs->etts_regs->tmr_etts1_h;\n\t\tbreak;\n\tcase 1:\n\t\tvalid = ETS2_VLD;\n\t\treg_etts_l = &regs->etts_regs->tmr_etts2_l;\n\t\treg_etts_h = &regs->etts_regs->tmr_etts2_h;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tevent.type = PTP_CLOCK_EXTTS;\n\tevent.index = index;\n\n\tif (ptp_qoriq->extts_fifo_support)\n\t\tif (!(ptp_qoriq->read(&regs->ctrl_regs->tmr_stat) & valid))\n\t\t\treturn 0;\n\n\tdo {\n\t\tlo = ptp_qoriq->read(reg_etts_l);\n\t\thi = ptp_qoriq->read(reg_etts_h);\n\n\t\tif (update_event) {\n\t\t\tevent.timestamp = ((u64) hi) << 32;\n\t\t\tevent.timestamp |= lo;\n\t\t\tptp_clock_event(ptp_qoriq->clock, &event);\n\t\t}\n\n\t\tif (!ptp_qoriq->extts_fifo_support)\n\t\t\tbreak;\n\t} while (ptp_qoriq->read(&regs->ctrl_regs->tmr_stat) & valid);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(extts_clean_up);\n\n \n\nirqreturn_t ptp_qoriq_isr(int irq, void *priv)\n{\n\tstruct ptp_qoriq *ptp_qoriq = priv;\n\tstruct ptp_qoriq_registers *regs = &ptp_qoriq->regs;\n\tstruct ptp_clock_event event;\n\tu32 ack = 0, mask, val, irqs;\n\n\tspin_lock(&ptp_qoriq->lock);\n\n\tval = ptp_qoriq->read(&regs->ctrl_regs->tmr_tevent);\n\tmask = ptp_qoriq->read(&regs->ctrl_regs->tmr_temask);\n\n\tspin_unlock(&ptp_qoriq->lock);\n\n\tirqs = val & mask;\n\n\tif (irqs & ETS1) {\n\t\tack |= ETS1;\n\t\textts_clean_up(ptp_qoriq, 0, true);\n\t}\n\n\tif (irqs & ETS2) {\n\t\tack |= ETS2;\n\t\textts_clean_up(ptp_qoriq, 1, true);\n\t}\n\n\tif (irqs & PP1) {\n\t\tack |= PP1;\n\t\tevent.type = PTP_CLOCK_PPS;\n\t\tptp_clock_event(ptp_qoriq->clock, &event);\n\t}\n\n\tif (ack) {\n\t\tptp_qoriq->write(&regs->ctrl_regs->tmr_tevent, ack);\n\t\treturn IRQ_HANDLED;\n\t} else\n\t\treturn IRQ_NONE;\n}\nEXPORT_SYMBOL_GPL(ptp_qoriq_isr);\n\n \n\nint ptp_qoriq_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tu64 adj, diff;\n\tu32 tmr_add;\n\tint neg_adj = 0;\n\tstruct ptp_qoriq *ptp_qoriq = container_of(ptp, struct ptp_qoriq, caps);\n\tstruct ptp_qoriq_registers *regs = &ptp_qoriq->regs;\n\n\tif (scaled_ppm < 0) {\n\t\tneg_adj = 1;\n\t\tscaled_ppm = -scaled_ppm;\n\t}\n\ttmr_add = ptp_qoriq->tmr_add;\n\tadj = tmr_add;\n\n\t \n\tdiff = mul_u64_u64_div_u64(adj, scaled_ppm, 32768000000);\n\tdiff = DIV64_U64_ROUND_UP(diff, 2);\n\n\ttmr_add = neg_adj ? tmr_add - diff : tmr_add + diff;\n\tptp_qoriq->write(&regs->ctrl_regs->tmr_add, tmr_add);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ptp_qoriq_adjfine);\n\nint ptp_qoriq_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct ptp_qoriq *ptp_qoriq = container_of(ptp, struct ptp_qoriq, caps);\n\ts64 now, curr_delta;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ptp_qoriq->lock, flags);\n\n\t \n\tif (ptp_qoriq->etsec) {\n\t\tnow = tmr_cnt_read(ptp_qoriq);\n\t\tnow += delta;\n\t\ttmr_cnt_write(ptp_qoriq, now);\n\t} else {\n\t\tcurr_delta = tmr_offset_read(ptp_qoriq);\n\t\tcurr_delta += delta;\n\t\ttmr_offset_write(ptp_qoriq, curr_delta);\n\t}\n\tset_fipers(ptp_qoriq);\n\n\tspin_unlock_irqrestore(&ptp_qoriq->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ptp_qoriq_adjtime);\n\nint ptp_qoriq_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tu64 ns;\n\tunsigned long flags;\n\tstruct ptp_qoriq *ptp_qoriq = container_of(ptp, struct ptp_qoriq, caps);\n\n\tspin_lock_irqsave(&ptp_qoriq->lock, flags);\n\n\tns = tmr_cnt_read(ptp_qoriq) + tmr_offset_read(ptp_qoriq);\n\n\tspin_unlock_irqrestore(&ptp_qoriq->lock, flags);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ptp_qoriq_gettime);\n\nint ptp_qoriq_settime(struct ptp_clock_info *ptp,\n\t\t      const struct timespec64 *ts)\n{\n\tu64 ns;\n\tunsigned long flags;\n\tstruct ptp_qoriq *ptp_qoriq = container_of(ptp, struct ptp_qoriq, caps);\n\n\tns = timespec64_to_ns(ts);\n\n\tspin_lock_irqsave(&ptp_qoriq->lock, flags);\n\n\ttmr_offset_write(ptp_qoriq, 0);\n\ttmr_cnt_write(ptp_qoriq, ns);\n\tset_fipers(ptp_qoriq);\n\n\tspin_unlock_irqrestore(&ptp_qoriq->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ptp_qoriq_settime);\n\nint ptp_qoriq_enable(struct ptp_clock_info *ptp,\n\t\t     struct ptp_clock_request *rq, int on)\n{\n\tstruct ptp_qoriq *ptp_qoriq = container_of(ptp, struct ptp_qoriq, caps);\n\tstruct ptp_qoriq_registers *regs = &ptp_qoriq->regs;\n\tunsigned long flags;\n\tu32 bit, mask = 0;\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\tswitch (rq->extts.index) {\n\t\tcase 0:\n\t\t\tbit = ETS1EN;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbit = ETS2EN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (on)\n\t\t\textts_clean_up(ptp_qoriq, rq->extts.index, false);\n\n\t\tbreak;\n\tcase PTP_CLK_REQ_PPS:\n\t\tbit = PP1EN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tspin_lock_irqsave(&ptp_qoriq->lock, flags);\n\n\tmask = ptp_qoriq->read(&regs->ctrl_regs->tmr_temask);\n\tif (on) {\n\t\tmask |= bit;\n\t\tptp_qoriq->write(&regs->ctrl_regs->tmr_tevent, bit);\n\t} else {\n\t\tmask &= ~bit;\n\t}\n\n\tptp_qoriq->write(&regs->ctrl_regs->tmr_temask, mask);\n\n\tspin_unlock_irqrestore(&ptp_qoriq->lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ptp_qoriq_enable);\n\nstatic const struct ptp_clock_info ptp_qoriq_caps = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"qoriq ptp clock\",\n\t.max_adj\t= 512000,\n\t.n_alarm\t= 0,\n\t.n_ext_ts\t= N_EXT_TS,\n\t.n_per_out\t= 0,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 1,\n\t.adjfine\t= ptp_qoriq_adjfine,\n\t.adjtime\t= ptp_qoriq_adjtime,\n\t.gettime64\t= ptp_qoriq_gettime,\n\t.settime64\t= ptp_qoriq_settime,\n\t.enable\t\t= ptp_qoriq_enable,\n};\n\n \nstatic u32 ptp_qoriq_nominal_freq(u32 clk_src)\n{\n\tu32 remainder = 0;\n\n\tclk_src /= 1000000;\n\tremainder = clk_src % 100;\n\tif (remainder) {\n\t\tclk_src -= remainder;\n\t\tclk_src += 100;\n\t}\n\n\tdo {\n\t\tclk_src -= 100;\n\n\t} while (1000 % clk_src);\n\n\treturn clk_src * 1000000;\n}\n\n \nstatic int ptp_qoriq_auto_config(struct ptp_qoriq *ptp_qoriq,\n\t\t\t\t struct device_node *node)\n{\n\tstruct clk *clk;\n\tu64 freq_comp;\n\tu64 max_adj;\n\tu32 nominal_freq;\n\tu32 remainder = 0;\n\tu32 clk_src = 0;\n\n\tptp_qoriq->cksel = DEFAULT_CKSEL;\n\n\tclk = of_clk_get(node, 0);\n\tif (!IS_ERR(clk)) {\n\t\tclk_src = clk_get_rate(clk);\n\t\tclk_put(clk);\n\t}\n\n\tif (clk_src <= 100000000UL) {\n\t\tpr_err(\"error reference clock value, or lower than 100MHz\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnominal_freq = ptp_qoriq_nominal_freq(clk_src);\n\tif (!nominal_freq)\n\t\treturn -EINVAL;\n\n\tptp_qoriq->tclk_period = 1000000000UL / nominal_freq;\n\tptp_qoriq->tmr_prsc = DEFAULT_TMR_PRSC;\n\n\t \n\tfreq_comp = ((u64)1 << 32) * nominal_freq;\n\tfreq_comp = div_u64_rem(freq_comp, clk_src, &remainder);\n\tif (remainder)\n\t\tfreq_comp++;\n\n\tptp_qoriq->tmr_add = freq_comp;\n\tptp_qoriq->tmr_fiper1 = DEFAULT_FIPER1_PERIOD - ptp_qoriq->tclk_period;\n\tptp_qoriq->tmr_fiper2 = DEFAULT_FIPER2_PERIOD - ptp_qoriq->tclk_period;\n\tptp_qoriq->tmr_fiper3 = DEFAULT_FIPER3_PERIOD - ptp_qoriq->tclk_period;\n\n\t \n\tmax_adj = 1000000000ULL * (clk_src - nominal_freq);\n\tmax_adj = div_u64(max_adj, nominal_freq) - 1;\n\tptp_qoriq->caps.max_adj = max_adj;\n\n\treturn 0;\n}\n\nint ptp_qoriq_init(struct ptp_qoriq *ptp_qoriq, void __iomem *base,\n\t\t   const struct ptp_clock_info *caps)\n{\n\tstruct device_node *node = ptp_qoriq->dev->of_node;\n\tstruct ptp_qoriq_registers *regs;\n\tstruct timespec64 now;\n\tunsigned long flags;\n\tu32 tmr_ctrl;\n\n\tif (!node)\n\t\treturn -ENODEV;\n\n\tptp_qoriq->base = base;\n\tptp_qoriq->caps = *caps;\n\n\tif (of_property_read_u32(node, \"fsl,cksel\", &ptp_qoriq->cksel))\n\t\tptp_qoriq->cksel = DEFAULT_CKSEL;\n\n\tif (of_property_read_bool(node, \"fsl,extts-fifo\"))\n\t\tptp_qoriq->extts_fifo_support = true;\n\telse\n\t\tptp_qoriq->extts_fifo_support = false;\n\n\tif (of_device_is_compatible(node, \"fsl,dpaa2-ptp\") ||\n\t    of_device_is_compatible(node, \"fsl,enetc-ptp\"))\n\t\tptp_qoriq->fiper3_support = true;\n\n\tif (of_property_read_u32(node,\n\t\t\t\t \"fsl,tclk-period\", &ptp_qoriq->tclk_period) ||\n\t    of_property_read_u32(node,\n\t\t\t\t \"fsl,tmr-prsc\", &ptp_qoriq->tmr_prsc) ||\n\t    of_property_read_u32(node,\n\t\t\t\t \"fsl,tmr-add\", &ptp_qoriq->tmr_add) ||\n\t    of_property_read_u32(node,\n\t\t\t\t \"fsl,tmr-fiper1\", &ptp_qoriq->tmr_fiper1) ||\n\t    of_property_read_u32(node,\n\t\t\t\t \"fsl,tmr-fiper2\", &ptp_qoriq->tmr_fiper2) ||\n\t    of_property_read_u32(node,\n\t\t\t\t \"fsl,max-adj\", &ptp_qoriq->caps.max_adj) ||\n\t    (ptp_qoriq->fiper3_support &&\n\t     of_property_read_u32(node, \"fsl,tmr-fiper3\",\n\t\t\t\t  &ptp_qoriq->tmr_fiper3))) {\n\t\tpr_warn(\"device tree node missing required elements, try automatic configuration\\n\");\n\n\t\tif (ptp_qoriq_auto_config(ptp_qoriq, node))\n\t\t\treturn -ENODEV;\n\t}\n\n\tif (of_property_read_bool(node, \"little-endian\")) {\n\t\tptp_qoriq->read = qoriq_read_le;\n\t\tptp_qoriq->write = qoriq_write_le;\n\t} else {\n\t\tptp_qoriq->read = qoriq_read_be;\n\t\tptp_qoriq->write = qoriq_write_be;\n\t}\n\n\t \n\tif (of_device_is_compatible(node, \"fsl,etsec-ptp\")) {\n\t\tptp_qoriq->etsec = true;\n\t\tptp_qoriq->regs.ctrl_regs = base + ETSEC_CTRL_REGS_OFFSET;\n\t\tptp_qoriq->regs.alarm_regs = base + ETSEC_ALARM_REGS_OFFSET;\n\t\tptp_qoriq->regs.fiper_regs = base + ETSEC_FIPER_REGS_OFFSET;\n\t\tptp_qoriq->regs.etts_regs = base + ETSEC_ETTS_REGS_OFFSET;\n\t} else {\n\t\tptp_qoriq->regs.ctrl_regs = base + CTRL_REGS_OFFSET;\n\t\tptp_qoriq->regs.alarm_regs = base + ALARM_REGS_OFFSET;\n\t\tptp_qoriq->regs.fiper_regs = base + FIPER_REGS_OFFSET;\n\t\tptp_qoriq->regs.etts_regs = base + ETTS_REGS_OFFSET;\n\t}\n\n\tspin_lock_init(&ptp_qoriq->lock);\n\n\tktime_get_real_ts64(&now);\n\tptp_qoriq_settime(&ptp_qoriq->caps, &now);\n\n\ttmr_ctrl =\n\t  (ptp_qoriq->tclk_period & TCLK_PERIOD_MASK) << TCLK_PERIOD_SHIFT |\n\t  (ptp_qoriq->cksel & CKSEL_MASK) << CKSEL_SHIFT;\n\n\tspin_lock_irqsave(&ptp_qoriq->lock, flags);\n\n\tregs = &ptp_qoriq->regs;\n\tptp_qoriq->write(&regs->ctrl_regs->tmr_ctrl, tmr_ctrl);\n\tptp_qoriq->write(&regs->ctrl_regs->tmr_add, ptp_qoriq->tmr_add);\n\tptp_qoriq->write(&regs->ctrl_regs->tmr_prsc, ptp_qoriq->tmr_prsc);\n\tptp_qoriq->write(&regs->fiper_regs->tmr_fiper1, ptp_qoriq->tmr_fiper1);\n\tptp_qoriq->write(&regs->fiper_regs->tmr_fiper2, ptp_qoriq->tmr_fiper2);\n\n\tif (ptp_qoriq->fiper3_support)\n\t\tptp_qoriq->write(&regs->fiper_regs->tmr_fiper3,\n\t\t\t\t ptp_qoriq->tmr_fiper3);\n\n\tset_alarm(ptp_qoriq);\n\tptp_qoriq->write(&regs->ctrl_regs->tmr_ctrl,\n\t\t\t tmr_ctrl|FIPERST|RTPE|TE|FRD);\n\n\tspin_unlock_irqrestore(&ptp_qoriq->lock, flags);\n\n\tptp_qoriq->clock = ptp_clock_register(&ptp_qoriq->caps, ptp_qoriq->dev);\n\tif (IS_ERR(ptp_qoriq->clock))\n\t\treturn PTR_ERR(ptp_qoriq->clock);\n\n\tptp_qoriq->phc_index = ptp_clock_index(ptp_qoriq->clock);\n\tptp_qoriq_create_debugfs(ptp_qoriq);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ptp_qoriq_init);\n\nvoid ptp_qoriq_free(struct ptp_qoriq *ptp_qoriq)\n{\n\tstruct ptp_qoriq_registers *regs = &ptp_qoriq->regs;\n\n\tptp_qoriq->write(&regs->ctrl_regs->tmr_temask, 0);\n\tptp_qoriq->write(&regs->ctrl_regs->tmr_ctrl,   0);\n\n\tptp_qoriq_remove_debugfs(ptp_qoriq);\n\tptp_clock_unregister(ptp_qoriq->clock);\n\tiounmap(ptp_qoriq->base);\n\tfree_irq(ptp_qoriq->irq, ptp_qoriq);\n}\nEXPORT_SYMBOL_GPL(ptp_qoriq_free);\n\nstatic int ptp_qoriq_probe(struct platform_device *dev)\n{\n\tstruct ptp_qoriq *ptp_qoriq;\n\tint err = -ENOMEM;\n\tvoid __iomem *base;\n\n\tptp_qoriq = kzalloc(sizeof(*ptp_qoriq), GFP_KERNEL);\n\tif (!ptp_qoriq)\n\t\tgoto no_memory;\n\n\tptp_qoriq->dev = &dev->dev;\n\n\terr = -ENODEV;\n\n\tptp_qoriq->irq = platform_get_irq(dev, 0);\n\tif (ptp_qoriq->irq < 0) {\n\t\tpr_err(\"irq not in device tree\\n\");\n\t\tgoto no_node;\n\t}\n\tif (request_irq(ptp_qoriq->irq, ptp_qoriq_isr, IRQF_SHARED,\n\t\t\tDRIVER, ptp_qoriq)) {\n\t\tpr_err(\"request_irq failed\\n\");\n\t\tgoto no_node;\n\t}\n\n\tptp_qoriq->rsrc = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (!ptp_qoriq->rsrc) {\n\t\tpr_err(\"no resource\\n\");\n\t\tgoto no_resource;\n\t}\n\tif (request_resource(&iomem_resource, ptp_qoriq->rsrc)) {\n\t\tpr_err(\"resource busy\\n\");\n\t\tgoto no_resource;\n\t}\n\n\tbase = ioremap(ptp_qoriq->rsrc->start,\n\t\t       resource_size(ptp_qoriq->rsrc));\n\tif (!base) {\n\t\tpr_err(\"ioremap ptp registers failed\\n\");\n\t\tgoto no_ioremap;\n\t}\n\n\terr = ptp_qoriq_init(ptp_qoriq, base, &ptp_qoriq_caps);\n\tif (err)\n\t\tgoto no_clock;\n\n\tplatform_set_drvdata(dev, ptp_qoriq);\n\treturn 0;\n\nno_clock:\n\tiounmap(base);\nno_ioremap:\n\trelease_resource(ptp_qoriq->rsrc);\nno_resource:\n\tfree_irq(ptp_qoriq->irq, ptp_qoriq);\nno_node:\n\tkfree(ptp_qoriq);\nno_memory:\n\treturn err;\n}\n\nstatic int ptp_qoriq_remove(struct platform_device *dev)\n{\n\tstruct ptp_qoriq *ptp_qoriq = platform_get_drvdata(dev);\n\n\tptp_qoriq_free(ptp_qoriq);\n\trelease_resource(ptp_qoriq->rsrc);\n\tkfree(ptp_qoriq);\n\treturn 0;\n}\n\nstatic const struct of_device_id match_table[] = {\n\t{ .compatible = \"fsl,etsec-ptp\" },\n\t{ .compatible = \"fsl,fman-ptp-timer\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, match_table);\n\nstatic struct platform_driver ptp_qoriq_driver = {\n\t.driver = {\n\t\t.name\t\t= \"ptp_qoriq\",\n\t\t.of_match_table\t= match_table,\n\t},\n\t.probe       = ptp_qoriq_probe,\n\t.remove      = ptp_qoriq_remove,\n};\n\nmodule_platform_driver(ptp_qoriq_driver);\n\nMODULE_AUTHOR(\"Richard Cochran <richardcochran@gmail.com>\");\nMODULE_DESCRIPTION(\"PTP clock for Freescale QorIQ 1588 timer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}