{
  "module_name": "ptp_pch.c",
  "hash_id": "b2437226d7e273634e5cb50f839b5ea20542ac8612eb5ecf9dd9e0bf2ab682e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_pch.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/io-64-nonatomic-hi-lo.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/ptp_pch.h>\n#include <linux/slab.h>\n\n#define STATION_ADDR_LEN\t20\n#define PCI_DEVICE_ID_PCH_1588\t0x8819\n#define IO_MEM_BAR 1\n\n#define DEFAULT_ADDEND 0xA0000000\n#define TICKS_NS_SHIFT  5\n#define N_EXT_TS\t2\n\nenum pch_status {\n\tPCH_SUCCESS,\n\tPCH_INVALIDPARAM,\n\tPCH_NOTIMESTAMP,\n\tPCH_INTERRUPTMODEINUSE,\n\tPCH_FAILED,\n\tPCH_UNSUPPORTED,\n};\n\n \nstruct pch_ts_regs {\n\tu32 control;\n\tu32 event;\n\tu32 addend;\n\tu32 accum;\n\tu32 test;\n\tu32 ts_compare;\n\tu32 rsystime_lo;\n\tu32 rsystime_hi;\n\tu32 systime_lo;\n\tu32 systime_hi;\n\tu32 trgt_lo;\n\tu32 trgt_hi;\n\tu32 asms_lo;\n\tu32 asms_hi;\n\tu32 amms_lo;\n\tu32 amms_hi;\n\tu32 ch_control;\n\tu32 ch_event;\n\tu32 tx_snap_lo;\n\tu32 tx_snap_hi;\n\tu32 rx_snap_lo;\n\tu32 rx_snap_hi;\n\tu32 src_uuid_lo;\n\tu32 src_uuid_hi;\n\tu32 can_status;\n\tu32 can_snap_lo;\n\tu32 can_snap_hi;\n\tu32 ts_sel;\n\tu32 ts_st[6];\n\tu32 reserve1[14];\n\tu32 stl_max_set_en;\n\tu32 stl_max_set;\n\tu32 reserve2[13];\n\tu32 srst;\n};\n\n#define PCH_TSC_RESET\t\t(1 << 0)\n#define PCH_TSC_TTM_MASK\t(1 << 1)\n#define PCH_TSC_ASMS_MASK\t(1 << 2)\n#define PCH_TSC_AMMS_MASK\t(1 << 3)\n#define PCH_TSC_PPSM_MASK\t(1 << 4)\n#define PCH_TSE_TTIPEND\t\t(1 << 1)\n#define PCH_TSE_SNS\t\t(1 << 2)\n#define PCH_TSE_SNM\t\t(1 << 3)\n#define PCH_TSE_PPS\t\t(1 << 4)\n#define PCH_CC_MM\t\t(1 << 0)\n#define PCH_CC_TA\t\t(1 << 1)\n\n#define PCH_CC_MODE_SHIFT\t16\n#define PCH_CC_MODE_MASK\t0x001F0000\n#define PCH_CC_VERSION\t\t(1 << 31)\n#define PCH_CE_TXS\t\t(1 << 0)\n#define PCH_CE_RXS\t\t(1 << 1)\n#define PCH_CE_OVR\t\t(1 << 0)\n#define PCH_CE_VAL\t\t(1 << 1)\n#define PCH_ECS_ETH\t\t(1 << 0)\n\n#define PCH_ECS_CAN\t\t(1 << 1)\n\n#define PCH_IEEE1588_ETH\t(1 << 0)\n#define PCH_IEEE1588_CAN\t(1 << 1)\n\n \nstruct pch_dev {\n\tstruct pch_ts_regs __iomem *regs;\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info caps;\n\tint exts0_enabled;\n\tint exts1_enabled;\n\n\tu32 irq;\n\tstruct pci_dev *pdev;\n\tspinlock_t register_lock;\n};\n\n \nstruct pch_params {\n\tu8 station[STATION_ADDR_LEN];\n};\n\n \nstatic struct pch_params pch_param = {\n\t\"00:00:00:00:00:00\"\n};\n\n \nstatic inline void pch_eth_enable_set(struct pch_dev *chip)\n{\n\tu32 val;\n\t \n\tval = ioread32(&chip->regs->ts_sel) | (PCH_ECS_ETH);\n\tiowrite32(val, (&chip->regs->ts_sel));\n}\n\nstatic u64 pch_systime_read(struct pch_ts_regs __iomem *regs)\n{\n\tu64 ns;\n\n\tns = ioread64_lo_hi(&regs->systime_lo);\n\n\treturn ns << TICKS_NS_SHIFT;\n}\n\nstatic void pch_systime_write(struct pch_ts_regs __iomem *regs, u64 ns)\n{\n\tiowrite64_lo_hi(ns >> TICKS_NS_SHIFT, &regs->systime_lo);\n}\n\nstatic inline void pch_block_reset(struct pch_dev *chip)\n{\n\tu32 val;\n\t \n\tval = ioread32(&chip->regs->control) | PCH_TSC_RESET;\n\tiowrite32(val, (&chip->regs->control));\n\tval = val & ~PCH_TSC_RESET;\n\tiowrite32(val, (&chip->regs->control));\n}\n\nvoid pch_ch_control_write(struct pci_dev *pdev, u32 val)\n{\n\tstruct pch_dev *chip = pci_get_drvdata(pdev);\n\n\tiowrite32(val, (&chip->regs->ch_control));\n}\nEXPORT_SYMBOL(pch_ch_control_write);\n\nu32 pch_ch_event_read(struct pci_dev *pdev)\n{\n\tstruct pch_dev *chip = pci_get_drvdata(pdev);\n\tu32 val;\n\n\tval = ioread32(&chip->regs->ch_event);\n\n\treturn val;\n}\nEXPORT_SYMBOL(pch_ch_event_read);\n\nvoid pch_ch_event_write(struct pci_dev *pdev, u32 val)\n{\n\tstruct pch_dev *chip = pci_get_drvdata(pdev);\n\n\tiowrite32(val, (&chip->regs->ch_event));\n}\nEXPORT_SYMBOL(pch_ch_event_write);\n\nu32 pch_src_uuid_lo_read(struct pci_dev *pdev)\n{\n\tstruct pch_dev *chip = pci_get_drvdata(pdev);\n\tu32 val;\n\n\tval = ioread32(&chip->regs->src_uuid_lo);\n\n\treturn val;\n}\nEXPORT_SYMBOL(pch_src_uuid_lo_read);\n\nu32 pch_src_uuid_hi_read(struct pci_dev *pdev)\n{\n\tstruct pch_dev *chip = pci_get_drvdata(pdev);\n\tu32 val;\n\n\tval = ioread32(&chip->regs->src_uuid_hi);\n\n\treturn val;\n}\nEXPORT_SYMBOL(pch_src_uuid_hi_read);\n\nu64 pch_rx_snap_read(struct pci_dev *pdev)\n{\n\tstruct pch_dev *chip = pci_get_drvdata(pdev);\n\tu64 ns;\n\n\tns = ioread64_lo_hi(&chip->regs->rx_snap_lo);\n\n\treturn ns << TICKS_NS_SHIFT;\n}\nEXPORT_SYMBOL(pch_rx_snap_read);\n\nu64 pch_tx_snap_read(struct pci_dev *pdev)\n{\n\tstruct pch_dev *chip = pci_get_drvdata(pdev);\n\tu64 ns;\n\n\tns = ioread64_lo_hi(&chip->regs->tx_snap_lo);\n\n\treturn ns << TICKS_NS_SHIFT;\n}\nEXPORT_SYMBOL(pch_tx_snap_read);\n\n \nstatic void pch_set_system_time_count(struct pch_dev *chip)\n{\n\tiowrite32(0x01, &chip->regs->stl_max_set_en);\n\tiowrite32(0xFFFFFFFF, &chip->regs->stl_max_set);\n\tiowrite32(0x00, &chip->regs->stl_max_set_en);\n}\n\nstatic void pch_reset(struct pch_dev *chip)\n{\n\t \n\tpch_block_reset(chip);\n\n\t \n\tpch_set_system_time_count(chip);\n}\n\n \nint pch_set_station_address(u8 *addr, struct pci_dev *pdev)\n{\n\tstruct pch_dev *chip = pci_get_drvdata(pdev);\n\tbool valid;\n\tu64 mac;\n\n\t \n\tif ((chip->regs == NULL) || addr == (u8 *)NULL) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"invalid params returning PCH_INVALIDPARAM\\n\");\n\t\treturn PCH_INVALIDPARAM;\n\t}\n\n\tvalid = mac_pton(addr, (u8 *)&mac);\n\tif (!valid) {\n\t\tdev_err(&pdev->dev, \"invalid params returning PCH_INVALIDPARAM\\n\");\n\t\treturn PCH_INVALIDPARAM;\n\t}\n\n\tdev_dbg(&pdev->dev, \"invoking pch_station_set\\n\");\n\tiowrite64_lo_hi(mac, &chip->regs->ts_st);\n\treturn 0;\n}\nEXPORT_SYMBOL(pch_set_station_address);\n\n \nstatic irqreturn_t isr(int irq, void *priv)\n{\n\tstruct pch_dev *pch_dev = priv;\n\tstruct pch_ts_regs __iomem *regs = pch_dev->regs;\n\tstruct ptp_clock_event event;\n\tu32 ack = 0, val;\n\n\tval = ioread32(&regs->event);\n\n\tif (val & PCH_TSE_SNS) {\n\t\tack |= PCH_TSE_SNS;\n\t\tif (pch_dev->exts0_enabled) {\n\t\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\t\tevent.index = 0;\n\t\t\tevent.timestamp = ioread64_hi_lo(&regs->asms_hi);\n\t\t\tevent.timestamp <<= TICKS_NS_SHIFT;\n\t\t\tptp_clock_event(pch_dev->ptp_clock, &event);\n\t\t}\n\t}\n\n\tif (val & PCH_TSE_SNM) {\n\t\tack |= PCH_TSE_SNM;\n\t\tif (pch_dev->exts1_enabled) {\n\t\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\t\tevent.index = 1;\n\t\t\tevent.timestamp = ioread64_hi_lo(&regs->asms_hi);\n\t\t\tevent.timestamp <<= TICKS_NS_SHIFT;\n\t\t\tptp_clock_event(pch_dev->ptp_clock, &event);\n\t\t}\n\t}\n\n\tif (val & PCH_TSE_TTIPEND)\n\t\tack |= PCH_TSE_TTIPEND;  \n\n\tif (ack) {\n\t\tiowrite32(ack, &regs->event);\n\t\treturn IRQ_HANDLED;\n\t} else\n\t\treturn IRQ_NONE;\n}\n\n \n\nstatic int ptp_pch_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tu32 addend;\n\tstruct pch_dev *pch_dev = container_of(ptp, struct pch_dev, caps);\n\tstruct pch_ts_regs __iomem *regs = pch_dev->regs;\n\n\taddend = adjust_by_scaled_ppm(DEFAULT_ADDEND, scaled_ppm);\n\n\tiowrite32(addend, &regs->addend);\n\n\treturn 0;\n}\n\nstatic int ptp_pch_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\ts64 now;\n\tunsigned long flags;\n\tstruct pch_dev *pch_dev = container_of(ptp, struct pch_dev, caps);\n\tstruct pch_ts_regs __iomem *regs = pch_dev->regs;\n\n\tspin_lock_irqsave(&pch_dev->register_lock, flags);\n\tnow = pch_systime_read(regs);\n\tnow += delta;\n\tpch_systime_write(regs, now);\n\tspin_unlock_irqrestore(&pch_dev->register_lock, flags);\n\n\treturn 0;\n}\n\nstatic int ptp_pch_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tu64 ns;\n\tunsigned long flags;\n\tstruct pch_dev *pch_dev = container_of(ptp, struct pch_dev, caps);\n\tstruct pch_ts_regs __iomem *regs = pch_dev->regs;\n\n\tspin_lock_irqsave(&pch_dev->register_lock, flags);\n\tns = pch_systime_read(regs);\n\tspin_unlock_irqrestore(&pch_dev->register_lock, flags);\n\n\t*ts = ns_to_timespec64(ns);\n\treturn 0;\n}\n\nstatic int ptp_pch_settime(struct ptp_clock_info *ptp,\n\t\t\t   const struct timespec64 *ts)\n{\n\tu64 ns;\n\tunsigned long flags;\n\tstruct pch_dev *pch_dev = container_of(ptp, struct pch_dev, caps);\n\tstruct pch_ts_regs __iomem *regs = pch_dev->regs;\n\n\tns = timespec64_to_ns(ts);\n\n\tspin_lock_irqsave(&pch_dev->register_lock, flags);\n\tpch_systime_write(regs, ns);\n\tspin_unlock_irqrestore(&pch_dev->register_lock, flags);\n\n\treturn 0;\n}\n\nstatic int ptp_pch_enable(struct ptp_clock_info *ptp,\n\t\t\t  struct ptp_clock_request *rq, int on)\n{\n\tstruct pch_dev *pch_dev = container_of(ptp, struct pch_dev, caps);\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\tswitch (rq->extts.index) {\n\t\tcase 0:\n\t\t\tpch_dev->exts0_enabled = on ? 1 : 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpch_dev->exts1_enabled = on ? 1 : 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct ptp_clock_info ptp_pch_caps = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"PCH timer\",\n\t.max_adj\t= 50000000,\n\t.n_ext_ts\t= N_EXT_TS,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 0,\n\t.adjfine\t= ptp_pch_adjfine,\n\t.adjtime\t= ptp_pch_adjtime,\n\t.gettime64\t= ptp_pch_gettime,\n\t.settime64\t= ptp_pch_settime,\n\t.enable\t\t= ptp_pch_enable,\n};\n\nstatic void pch_remove(struct pci_dev *pdev)\n{\n\tstruct pch_dev *chip = pci_get_drvdata(pdev);\n\n\tfree_irq(pdev->irq, chip);\n\tptp_clock_unregister(chip->ptp_clock);\n}\n\nstatic s32\npch_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\ts32 ret;\n\tunsigned long flags;\n\tstruct pch_dev *chip;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tret = pcim_enable_device(pdev);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"could not enable the pci device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pcim_iomap_regions(pdev, BIT(IO_MEM_BAR), \"1588_regs\");\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not locate IO memory address\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tchip->regs = pcim_iomap_table(pdev)[IO_MEM_BAR];\n\tchip->caps = ptp_pch_caps;\n\tchip->ptp_clock = ptp_clock_register(&chip->caps, &pdev->dev);\n\tif (IS_ERR(chip->ptp_clock))\n\t\treturn PTR_ERR(chip->ptp_clock);\n\n\tspin_lock_init(&chip->register_lock);\n\n\tret = request_irq(pdev->irq, &isr, IRQF_SHARED, KBUILD_MODNAME, chip);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"failed to get irq %d\\n\", pdev->irq);\n\t\tgoto err_req_irq;\n\t}\n\n\t \n\tchip->irq = pdev->irq;\n\tchip->pdev = pdev;\n\tpci_set_drvdata(pdev, chip);\n\n\tspin_lock_irqsave(&chip->register_lock, flags);\n\t \n\tpch_reset(chip);\n\n\tiowrite32(DEFAULT_ADDEND, &chip->regs->addend);\n\tiowrite64_lo_hi(1, &chip->regs->trgt_lo);\n\tiowrite32(PCH_TSE_TTIPEND, &chip->regs->event);\n\n\tpch_eth_enable_set(chip);\n\n\tif (strcmp(pch_param.station, \"00:00:00:00:00:00\") != 0) {\n\t\tif (pch_set_station_address(pch_param.station, pdev) != 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\"Invalid station address parameter\\n\"\n\t\t\t\"Module loaded but station address not set correctly\\n\"\n\t\t\t);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&chip->register_lock, flags);\n\treturn 0;\n\nerr_req_irq:\n\tptp_clock_unregister(chip->ptp_clock);\n\n\tdev_err(&pdev->dev, \"probe failed(ret=0x%x)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct pci_device_id pch_ieee1588_pcidev_id[] = {\n\t{\n\t  .vendor = PCI_VENDOR_ID_INTEL,\n\t  .device = PCI_DEVICE_ID_PCH_1588\n\t },\n\t{0}\n};\nMODULE_DEVICE_TABLE(pci, pch_ieee1588_pcidev_id);\n\nstatic struct pci_driver pch_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = pch_ieee1588_pcidev_id,\n\t.probe = pch_probe,\n\t.remove = pch_remove,\n};\nmodule_pci_driver(pch_driver);\n\nmodule_param_string(station,\n\t\t    pch_param.station, sizeof(pch_param.station), 0444);\nMODULE_PARM_DESC(station,\n\t \"IEEE 1588 station address to use - colon separated hex values\");\n\nMODULE_AUTHOR(\"LAPIS SEMICONDUCTOR, <tshimizu818@gmail.com>\");\nMODULE_DESCRIPTION(\"PTP clock using the EG20T timer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}