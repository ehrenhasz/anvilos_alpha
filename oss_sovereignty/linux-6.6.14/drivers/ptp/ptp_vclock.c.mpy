{
  "module_name": "ptp_vclock.c",
  "hash_id": "6b43cf4970a30a7dc3ba70cb341e3fb3f097d982c35ed04816f83bb2f52496d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_vclock.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/hashtable.h>\n#include \"ptp_private.h\"\n\n#define PTP_VCLOCK_CC_SHIFT\t\t31\n#define PTP_VCLOCK_CC_MULT\t\t(1 << PTP_VCLOCK_CC_SHIFT)\n#define PTP_VCLOCK_FADJ_SHIFT\t\t9\n#define PTP_VCLOCK_FADJ_DENOMINATOR\t15625ULL\n#define PTP_VCLOCK_REFRESH_INTERVAL\t(HZ * 2)\n\n \nstatic DEFINE_SPINLOCK(vclock_hash_lock);\n\nstatic DEFINE_READ_MOSTLY_HASHTABLE(vclock_hash, 8);\n\nstatic void ptp_vclock_hash_add(struct ptp_vclock *vclock)\n{\n\tspin_lock(&vclock_hash_lock);\n\n\thlist_add_head_rcu(&vclock->vclock_hash_node,\n\t\t\t   &vclock_hash[vclock->clock->index % HASH_SIZE(vclock_hash)]);\n\n\tspin_unlock(&vclock_hash_lock);\n}\n\nstatic void ptp_vclock_hash_del(struct ptp_vclock *vclock)\n{\n\tspin_lock(&vclock_hash_lock);\n\n\thlist_del_init_rcu(&vclock->vclock_hash_node);\n\n\tspin_unlock(&vclock_hash_lock);\n\n\tsynchronize_rcu();\n}\n\nstatic int ptp_vclock_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct ptp_vclock *vclock = info_to_vclock(ptp);\n\ts64 adj;\n\n\tadj = (s64)scaled_ppm << PTP_VCLOCK_FADJ_SHIFT;\n\tadj = div_s64(adj, PTP_VCLOCK_FADJ_DENOMINATOR);\n\n\tif (mutex_lock_interruptible(&vclock->lock))\n\t\treturn -EINTR;\n\ttimecounter_read(&vclock->tc);\n\tvclock->cc.mult = PTP_VCLOCK_CC_MULT + adj;\n\tmutex_unlock(&vclock->lock);\n\n\treturn 0;\n}\n\nstatic int ptp_vclock_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct ptp_vclock *vclock = info_to_vclock(ptp);\n\n\tif (mutex_lock_interruptible(&vclock->lock))\n\t\treturn -EINTR;\n\ttimecounter_adjtime(&vclock->tc, delta);\n\tmutex_unlock(&vclock->lock);\n\n\treturn 0;\n}\n\nstatic int ptp_vclock_gettime(struct ptp_clock_info *ptp,\n\t\t\t      struct timespec64 *ts)\n{\n\tstruct ptp_vclock *vclock = info_to_vclock(ptp);\n\tu64 ns;\n\n\tif (mutex_lock_interruptible(&vclock->lock))\n\t\treturn -EINTR;\n\tns = timecounter_read(&vclock->tc);\n\tmutex_unlock(&vclock->lock);\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nstatic int ptp_vclock_gettimex(struct ptp_clock_info *ptp,\n\t\t\t       struct timespec64 *ts,\n\t\t\t       struct ptp_system_timestamp *sts)\n{\n\tstruct ptp_vclock *vclock = info_to_vclock(ptp);\n\tstruct ptp_clock *pptp = vclock->pclock;\n\tstruct timespec64 pts;\n\tint err;\n\tu64 ns;\n\n\terr = pptp->info->getcyclesx64(pptp->info, &pts, sts);\n\tif (err)\n\t\treturn err;\n\n\tif (mutex_lock_interruptible(&vclock->lock))\n\t\treturn -EINTR;\n\tns = timecounter_cyc2time(&vclock->tc, timespec64_to_ns(&pts));\n\tmutex_unlock(&vclock->lock);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nstatic int ptp_vclock_settime(struct ptp_clock_info *ptp,\n\t\t\t      const struct timespec64 *ts)\n{\n\tstruct ptp_vclock *vclock = info_to_vclock(ptp);\n\tu64 ns = timespec64_to_ns(ts);\n\n\tif (mutex_lock_interruptible(&vclock->lock))\n\t\treturn -EINTR;\n\ttimecounter_init(&vclock->tc, &vclock->cc, ns);\n\tmutex_unlock(&vclock->lock);\n\n\treturn 0;\n}\n\nstatic int ptp_vclock_getcrosststamp(struct ptp_clock_info *ptp,\n\t\t\t\t     struct system_device_crosststamp *xtstamp)\n{\n\tstruct ptp_vclock *vclock = info_to_vclock(ptp);\n\tstruct ptp_clock *pptp = vclock->pclock;\n\tint err;\n\tu64 ns;\n\n\terr = pptp->info->getcrosscycles(pptp->info, xtstamp);\n\tif (err)\n\t\treturn err;\n\n\tif (mutex_lock_interruptible(&vclock->lock))\n\t\treturn -EINTR;\n\tns = timecounter_cyc2time(&vclock->tc, ktime_to_ns(xtstamp->device));\n\tmutex_unlock(&vclock->lock);\n\n\txtstamp->device = ns_to_ktime(ns);\n\n\treturn 0;\n}\n\nstatic long ptp_vclock_refresh(struct ptp_clock_info *ptp)\n{\n\tstruct ptp_vclock *vclock = info_to_vclock(ptp);\n\tstruct timespec64 ts;\n\n\tptp_vclock_gettime(&vclock->info, &ts);\n\n\treturn PTP_VCLOCK_REFRESH_INTERVAL;\n}\n\nstatic const struct ptp_clock_info ptp_vclock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ptp virtual clock\",\n\t.max_adj\t= 500000000,\n\t.adjfine\t= ptp_vclock_adjfine,\n\t.adjtime\t= ptp_vclock_adjtime,\n\t.settime64\t= ptp_vclock_settime,\n\t.do_aux_work\t= ptp_vclock_refresh,\n};\n\nstatic u64 ptp_vclock_read(const struct cyclecounter *cc)\n{\n\tstruct ptp_vclock *vclock = cc_to_vclock(cc);\n\tstruct ptp_clock *ptp = vclock->pclock;\n\tstruct timespec64 ts = {};\n\n\tptp->info->getcycles64(ptp->info, &ts);\n\n\treturn timespec64_to_ns(&ts);\n}\n\nstatic const struct cyclecounter ptp_vclock_cc = {\n\t.read\t= ptp_vclock_read,\n\t.mask\t= CYCLECOUNTER_MASK(32),\n\t.mult\t= PTP_VCLOCK_CC_MULT,\n\t.shift\t= PTP_VCLOCK_CC_SHIFT,\n};\n\nstruct ptp_vclock *ptp_vclock_register(struct ptp_clock *pclock)\n{\n\tstruct ptp_vclock *vclock;\n\n\tvclock = kzalloc(sizeof(*vclock), GFP_KERNEL);\n\tif (!vclock)\n\t\treturn NULL;\n\n\tvclock->pclock = pclock;\n\tvclock->info = ptp_vclock_info;\n\tif (pclock->info->getcyclesx64)\n\t\tvclock->info.gettimex64 = ptp_vclock_gettimex;\n\telse\n\t\tvclock->info.gettime64 = ptp_vclock_gettime;\n\tif (pclock->info->getcrosscycles)\n\t\tvclock->info.getcrosststamp = ptp_vclock_getcrosststamp;\n\tvclock->cc = ptp_vclock_cc;\n\n\tsnprintf(vclock->info.name, PTP_CLOCK_NAME_LEN, \"ptp%d_virt\",\n\t\t pclock->index);\n\n\tINIT_HLIST_NODE(&vclock->vclock_hash_node);\n\n\tmutex_init(&vclock->lock);\n\n\tvclock->clock = ptp_clock_register(&vclock->info, &pclock->dev);\n\tif (IS_ERR_OR_NULL(vclock->clock)) {\n\t\tkfree(vclock);\n\t\treturn NULL;\n\t}\n\n\ttimecounter_init(&vclock->tc, &vclock->cc, 0);\n\tptp_schedule_worker(vclock->clock, PTP_VCLOCK_REFRESH_INTERVAL);\n\n\tptp_vclock_hash_add(vclock);\n\n\treturn vclock;\n}\n\nvoid ptp_vclock_unregister(struct ptp_vclock *vclock)\n{\n\tptp_vclock_hash_del(vclock);\n\n\tptp_clock_unregister(vclock->clock);\n\tkfree(vclock);\n}\n\n#if IS_BUILTIN(CONFIG_PTP_1588_CLOCK)\nint ptp_get_vclocks_index(int pclock_index, int **vclock_index)\n{\n\tchar name[PTP_CLOCK_NAME_LEN] = \"\";\n\tstruct ptp_clock *ptp;\n\tstruct device *dev;\n\tint num = 0;\n\n\tif (pclock_index < 0)\n\t\treturn num;\n\n\tsnprintf(name, PTP_CLOCK_NAME_LEN, \"ptp%d\", pclock_index);\n\tdev = class_find_device_by_name(ptp_class, name);\n\tif (!dev)\n\t\treturn num;\n\n\tptp = dev_get_drvdata(dev);\n\n\tif (mutex_lock_interruptible(&ptp->n_vclocks_mux)) {\n\t\tput_device(dev);\n\t\treturn num;\n\t}\n\n\t*vclock_index = kzalloc(sizeof(int) * ptp->n_vclocks, GFP_KERNEL);\n\tif (!(*vclock_index))\n\t\tgoto out;\n\n\tmemcpy(*vclock_index, ptp->vclock_index, sizeof(int) * ptp->n_vclocks);\n\tnum = ptp->n_vclocks;\nout:\n\tmutex_unlock(&ptp->n_vclocks_mux);\n\tput_device(dev);\n\treturn num;\n}\nEXPORT_SYMBOL(ptp_get_vclocks_index);\n\nktime_t ptp_convert_timestamp(const ktime_t *hwtstamp, int vclock_index)\n{\n\tunsigned int hash = vclock_index % HASH_SIZE(vclock_hash);\n\tstruct ptp_vclock *vclock;\n\tu64 ns;\n\tu64 vclock_ns = 0;\n\n\tns = ktime_to_ns(*hwtstamp);\n\n\trcu_read_lock();\n\n\thlist_for_each_entry_rcu(vclock, &vclock_hash[hash], vclock_hash_node) {\n\t\tif (vclock->clock->index != vclock_index)\n\t\t\tcontinue;\n\n\t\tif (mutex_lock_interruptible(&vclock->lock))\n\t\t\tbreak;\n\t\tvclock_ns = timecounter_cyc2time(&vclock->tc, ns);\n\t\tmutex_unlock(&vclock->lock);\n\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\n\treturn ns_to_ktime(vclock_ns);\n}\nEXPORT_SYMBOL(ptp_convert_timestamp);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}