{
  "module_name": "ptp_clockmatrix.h",
  "hash_id": "5f56adaf08c49e1426bdbc58ed47d93be1a84acbba7130d78d5aa678a83064fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_clockmatrix.h",
  "human_readable_source": " \n \n#ifndef PTP_IDTCLOCKMATRIX_H\n#define PTP_IDTCLOCKMATRIX_H\n\n#include <linux/ktime.h>\n#include <linux/mfd/idt8a340_reg.h>\n#include <linux/ptp_clock.h>\n#include <linux/regmap.h>\n\n#define FW_FILENAME\t\"idtcm.bin\"\n#define MAX_TOD\t\t(4)\n#define MAX_PLL\t\t(8)\n#define MAX_REF_CLK\t(16)\n\n#define MAX_ABS_WRITE_PHASE_NANOSECONDS (107374182L)\n\n#define TOD_MASK_ADDR\t\t(0xFFA5)\n#define DEFAULT_TOD_MASK\t(0x04)\n\n#define SET_U16_LSB(orig, val8) (orig = (0xff00 & (orig)) | (val8))\n#define SET_U16_MSB(orig, val8) (orig = (0x00ff & (orig)) | (val8 << 8))\n\n#define TOD0_PTP_PLL_ADDR\t\t(0xFFA8)\n#define TOD1_PTP_PLL_ADDR\t\t(0xFFA9)\n#define TOD2_PTP_PLL_ADDR\t\t(0xFFAA)\n#define TOD3_PTP_PLL_ADDR\t\t(0xFFAB)\n\n#define TOD0_OUT_ALIGN_MASK_ADDR\t(0xFFB0)\n#define TOD1_OUT_ALIGN_MASK_ADDR\t(0xFFB2)\n#define TOD2_OUT_ALIGN_MASK_ADDR\t(0xFFB4)\n#define TOD3_OUT_ALIGN_MASK_ADDR\t(0xFFB6)\n\n#define DEFAULT_OUTPUT_MASK_PLL0\t(0x003)\n#define DEFAULT_OUTPUT_MASK_PLL1\t(0x00c)\n#define DEFAULT_OUTPUT_MASK_PLL2\t(0x030)\n#define DEFAULT_OUTPUT_MASK_PLL3\t(0x0c0)\n\n#define DEFAULT_TOD0_PTP_PLL\t\t(0)\n#define DEFAULT_TOD1_PTP_PLL\t\t(1)\n#define DEFAULT_TOD2_PTP_PLL\t\t(2)\n#define DEFAULT_TOD3_PTP_PLL\t\t(3)\n\n#define PHASE_PULL_IN_THRESHOLD_NS_DEPRECATED\t(150000)\n#define PHASE_PULL_IN_THRESHOLD_NS\t\t(15000)\n#define TOD_WRITE_OVERHEAD_COUNT_MAX\t\t(2)\n#define TOD_BYTE_COUNT\t\t\t\t(11)\n\n#define LOCK_TIMEOUT_MS\t\t\t(2000)\n#define LOCK_POLL_INTERVAL_MS\t\t(10)\n\n#define IDTCM_MAX_WRITE_COUNT\t\t(512)\n\n#define PHASE_PULL_IN_MAX_PPB\t\t(144000)\n#define PHASE_PULL_IN_MIN_THRESHOLD_NS\t(2)\n\n \n#define IDTCM_FW_REG(FW, VER, REG)\t(((FW) < (VER)) ? (REG) : (REG##_##VER))\nenum fw_version {\n\tV_DEFAULT = 0,\n\tV487 = 1,\n\tV520 = 2,\n};\n\n \nenum ptp_pll_mode {\n\tPTP_PLL_MODE_MIN = 0,\n\tPTP_PLL_MODE_WRITE_FREQUENCY = PTP_PLL_MODE_MIN,\n\tPTP_PLL_MODE_WRITE_PHASE,\n\tPTP_PLL_MODE_UNSUPPORTED,\n\tPTP_PLL_MODE_MAX = PTP_PLL_MODE_UNSUPPORTED,\n};\n\nstruct idtcm;\n\nstruct idtcm_channel {\n\tstruct ptp_clock_info\tcaps;\n\tstruct ptp_clock\t*ptp_clock;\n\tstruct idtcm\t\t*idtcm;\n\tu16\t\t\tdpll_phase;\n\tu16\t\t\tdpll_freq;\n\tu16\t\t\tdpll_n;\n\tu16\t\t\tdpll_ctrl_n;\n\tu16\t\t\tdpll_phase_pull_in;\n\tu16\t\t\ttod_read_primary;\n\tu16\t\t\ttod_read_secondary;\n\tu16\t\t\ttod_write;\n\tu16\t\t\ttod_n;\n\tu16\t\t\thw_dpll_n;\n\tu8\t\t\tsync_src;\n\tenum ptp_pll_mode\tmode;\n\tint\t\t\t(*configure_write_frequency)(struct idtcm_channel *channel);\n\tint\t\t\t(*configure_write_phase)(struct idtcm_channel *channel);\n\tint\t\t\t(*do_phase_pull_in)(struct idtcm_channel *channel,\n\t\t\t\t\t\t    s32 offset_ns, u32 max_ffo_ppb);\n\ts32\t\t\tcurrent_freq_scaled_ppm;\n\tbool\t\t\tphase_pull_in;\n\tu32\t\t\tdco_delay;\n\t \n\tu8\t\t\trefn;\n\tu8\t\t\tpll;\n\tu8\t\t\ttod;\n\tu16\t\t\toutput_mask;\n};\n\nstruct idtcm {\n\tstruct idtcm_channel\tchannel[MAX_TOD];\n\tstruct device\t\t*dev;\n\tu8\t\t\ttod_mask;\n\tchar\t\t\tversion[16];\n\tenum fw_version\t\tfw_ver;\n\t \n\tu8\t\t\textts_mask;\n\tbool\t\t\textts_single_shot;\n\tstruct delayed_work\textts_work;\n\t \n\tstruct idtcm_channel\t*event_channel[MAX_TOD];\n\t \n\tstruct mutex\t\t*lock;\n\tstruct device\t\t*mfd;\n\tstruct regmap\t\t*regmap;\n\t \n\tu8\t\t\tcalculate_overhead_flag;\n\ts64\t\t\ttod_write_overhead_ns;\n\tktime_t\t\t\tstart_time;\n};\n\nstruct idtcm_fwrc {\n\tu8 hiaddr;\n\tu8 loaddr;\n\tu8 value;\n\tu8 reserved;\n} __packed;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}