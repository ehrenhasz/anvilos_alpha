{
  "module_name": "ptp_dte.c",
  "hash_id": "687fe870f512ec17b8b8b90556b4c29a4105cd44b78e8c5a4820a5ffacf23e1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_dte.c",
  "human_readable_source": "\n\n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/types.h>\n\n#define DTE_NCO_LOW_TIME_REG\t0x00\n#define DTE_NCO_TIME_REG\t0x04\n#define DTE_NCO_OVERFLOW_REG\t0x08\n#define DTE_NCO_INC_REG\t\t0x0c\n\n#define DTE_NCO_SUM2_MASK\t0xffffffff\n#define DTE_NCO_SUM2_SHIFT\t4ULL\n\n#define DTE_NCO_SUM3_MASK\t0xff\n#define DTE_NCO_SUM3_SHIFT\t36ULL\n#define DTE_NCO_SUM3_WR_SHIFT\t8\n\n#define DTE_NCO_TS_WRAP_MASK\t0xfff\n#define DTE_NCO_TS_WRAP_LSHIFT\t32\n\n#define DTE_NCO_INC_DEFAULT\t0x80000000\n#define DTE_NUM_REGS_TO_RESTORE\t4\n\n \n#define DTE_WRAP_AROUND_NSEC_SHIFT 44\n\n \n#define DTE_NCO_MAX_NS\t0xFFFFFFFFFFFLL\n\n \n#define DTE_PPB_ADJ(ppb) (u32)(div64_u64((((u64)abs(ppb) * BIT(28)) +\\\n\t\t\t\t      62500000ULL), 125000000ULL))\n\n \nstruct ptp_dte {\n\tvoid __iomem *regs;\n\tstruct ptp_clock *ptp_clk;\n\tstruct ptp_clock_info caps;\n\tstruct device *dev;\n\tu32 ts_ovf_last;\n\tu32 ts_wrap_cnt;\n\tspinlock_t lock;\n\tu32 reg_val[DTE_NUM_REGS_TO_RESTORE];\n};\n\nstatic void dte_write_nco(void __iomem *regs, s64 ns)\n{\n\tu32 sum2, sum3;\n\n\tsum2 = (u32)((ns >> DTE_NCO_SUM2_SHIFT) & DTE_NCO_SUM2_MASK);\n\t \n\tif (sum2 != DTE_NCO_SUM2_MASK)\n\t\tsum2++;\n\n\t \n\tsum3 = (u32)(((ns >> DTE_NCO_SUM3_SHIFT) & DTE_NCO_SUM3_MASK) <<\n\t\t     DTE_NCO_SUM3_WR_SHIFT);\n\n\twritel(0, (regs + DTE_NCO_LOW_TIME_REG));\n\twritel(sum2, (regs + DTE_NCO_TIME_REG));\n\twritel(sum3, (regs + DTE_NCO_OVERFLOW_REG));\n}\n\nstatic s64 dte_read_nco(void __iomem *regs)\n{\n\tu32 sum2, sum3;\n\ts64 ns;\n\n\t \n\tsum3 = readl(regs + DTE_NCO_OVERFLOW_REG) & DTE_NCO_SUM3_MASK;\n\tsum2 = readl(regs + DTE_NCO_TIME_REG);\n\tns = ((s64)sum3 << DTE_NCO_SUM3_SHIFT) |\n\t\t ((s64)sum2 << DTE_NCO_SUM2_SHIFT);\n\n\treturn ns;\n}\n\nstatic void dte_write_nco_delta(struct ptp_dte *ptp_dte, s64 delta)\n{\n\ts64 ns;\n\n\tns = dte_read_nco(ptp_dte->regs);\n\n\t \n\tif ((delta < 0) && (abs(delta) > ns)) {\n\t\tif (ptp_dte->ts_wrap_cnt) {\n\t\t\tns += DTE_NCO_MAX_NS + delta;\n\t\t\tptp_dte->ts_wrap_cnt--;\n\t\t} else {\n\t\t\tns = 0;\n\t\t}\n\t} else {\n\t\tns += delta;\n\t\tif (ns > DTE_NCO_MAX_NS) {\n\t\t\tptp_dte->ts_wrap_cnt++;\n\t\t\tns -= DTE_NCO_MAX_NS;\n\t\t}\n\t}\n\n\tdte_write_nco(ptp_dte->regs, ns);\n\n\tptp_dte->ts_ovf_last = (ns >> DTE_NCO_TS_WRAP_LSHIFT) &\n\t\t\tDTE_NCO_TS_WRAP_MASK;\n}\n\nstatic s64 dte_read_nco_with_ovf(struct ptp_dte *ptp_dte)\n{\n\tu32 ts_ovf;\n\ts64 ns = 0;\n\n\tns = dte_read_nco(ptp_dte->regs);\n\n\t \n\tts_ovf = (ns >> DTE_NCO_TS_WRAP_LSHIFT) & DTE_NCO_TS_WRAP_MASK;\n\n\t \n\tif (ts_ovf < ptp_dte->ts_ovf_last)\n\t\tptp_dte->ts_wrap_cnt++;\n\n\tptp_dte->ts_ovf_last = ts_ovf;\n\n\t \n\tns += (s64)(BIT_ULL(DTE_WRAP_AROUND_NSEC_SHIFT) * ptp_dte->ts_wrap_cnt);\n\n\treturn ns;\n}\n\nstatic int ptp_dte_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\ts32 ppb = scaled_ppm_to_ppb(scaled_ppm);\n\tu32 nco_incr;\n\tunsigned long flags;\n\tstruct ptp_dte *ptp_dte = container_of(ptp, struct ptp_dte, caps);\n\n\tif (abs(ppb) > ptp_dte->caps.max_adj) {\n\t\tdev_err(ptp_dte->dev, \"ppb adj too big\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ppb < 0)\n\t\tnco_incr = DTE_NCO_INC_DEFAULT - DTE_PPB_ADJ(ppb);\n\telse\n\t\tnco_incr = DTE_NCO_INC_DEFAULT + DTE_PPB_ADJ(ppb);\n\n\tspin_lock_irqsave(&ptp_dte->lock, flags);\n\twritel(nco_incr, ptp_dte->regs + DTE_NCO_INC_REG);\n\tspin_unlock_irqrestore(&ptp_dte->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ptp_dte_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tunsigned long flags;\n\tstruct ptp_dte *ptp_dte = container_of(ptp, struct ptp_dte, caps);\n\n\tspin_lock_irqsave(&ptp_dte->lock, flags);\n\tdte_write_nco_delta(ptp_dte, delta);\n\tspin_unlock_irqrestore(&ptp_dte->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ptp_dte_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tunsigned long flags;\n\tstruct ptp_dte *ptp_dte = container_of(ptp, struct ptp_dte, caps);\n\n\tspin_lock_irqsave(&ptp_dte->lock, flags);\n\t*ts = ns_to_timespec64(dte_read_nco_with_ovf(ptp_dte));\n\tspin_unlock_irqrestore(&ptp_dte->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ptp_dte_settime(struct ptp_clock_info *ptp,\n\t\t\t     const struct timespec64 *ts)\n{\n\tunsigned long flags;\n\tstruct ptp_dte *ptp_dte = container_of(ptp, struct ptp_dte, caps);\n\n\tspin_lock_irqsave(&ptp_dte->lock, flags);\n\n\t \n\twritel(0, ptp_dte->regs + DTE_NCO_INC_REG);\n\n\tdte_write_nco(ptp_dte->regs, timespec64_to_ns(ts));\n\n\t \n\tptp_dte->ts_ovf_last = 0;\n\tptp_dte->ts_wrap_cnt = 0;\n\n\t \n\twritel(DTE_NCO_INC_DEFAULT, ptp_dte->regs + DTE_NCO_INC_REG);\n\n\tspin_unlock_irqrestore(&ptp_dte->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ptp_dte_enable(struct ptp_clock_info *ptp,\n\t\t\t    struct ptp_clock_request *rq, int on)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct ptp_clock_info ptp_dte_caps = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"DTE PTP timer\",\n\t.max_adj\t= 50000000,\n\t.n_ext_ts\t= 0,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 0,\n\t.adjfine\t= ptp_dte_adjfine,\n\t.adjtime\t= ptp_dte_adjtime,\n\t.gettime64\t= ptp_dte_gettime,\n\t.settime64\t= ptp_dte_settime,\n\t.enable\t\t= ptp_dte_enable,\n};\n\nstatic int ptp_dte_probe(struct platform_device *pdev)\n{\n\tstruct ptp_dte *ptp_dte;\n\tstruct device *dev = &pdev->dev;\n\n\tptp_dte = devm_kzalloc(dev, sizeof(struct ptp_dte), GFP_KERNEL);\n\tif (!ptp_dte)\n\t\treturn -ENOMEM;\n\n\tptp_dte->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ptp_dte->regs))\n\t\treturn PTR_ERR(ptp_dte->regs);\n\n\tspin_lock_init(&ptp_dte->lock);\n\n\tptp_dte->dev = dev;\n\tptp_dte->caps = ptp_dte_caps;\n\tptp_dte->ptp_clk = ptp_clock_register(&ptp_dte->caps, &pdev->dev);\n\tif (IS_ERR(ptp_dte->ptp_clk)) {\n\t\tdev_err(dev,\n\t\t\t\"%s: Failed to register ptp clock\\n\", __func__);\n\t\treturn PTR_ERR(ptp_dte->ptp_clk);\n\t}\n\n\tplatform_set_drvdata(pdev, ptp_dte);\n\n\tdev_info(dev, \"ptp clk probe done\\n\");\n\n\treturn 0;\n}\n\nstatic int ptp_dte_remove(struct platform_device *pdev)\n{\n\tstruct ptp_dte *ptp_dte = platform_get_drvdata(pdev);\n\tu8 i;\n\n\tptp_clock_unregister(ptp_dte->ptp_clk);\n\n\tfor (i = 0; i < DTE_NUM_REGS_TO_RESTORE; i++)\n\t\twritel(0, ptp_dte->regs + (i * sizeof(u32)));\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ptp_dte_suspend(struct device *dev)\n{\n\tstruct ptp_dte *ptp_dte = dev_get_drvdata(dev);\n\tu8 i;\n\n\tfor (i = 0; i < DTE_NUM_REGS_TO_RESTORE; i++) {\n\t\tptp_dte->reg_val[i] =\n\t\t\treadl(ptp_dte->regs + (i * sizeof(u32)));\n\t}\n\n\t \n\twritel(0, ptp_dte->regs + DTE_NCO_INC_REG);\n\n\treturn 0;\n}\n\nstatic int ptp_dte_resume(struct device *dev)\n{\n\tstruct ptp_dte *ptp_dte = dev_get_drvdata(dev);\n\tu8 i;\n\n\tfor (i = 0; i < DTE_NUM_REGS_TO_RESTORE; i++) {\n\t\tif ((i * sizeof(u32)) != DTE_NCO_OVERFLOW_REG)\n\t\t\twritel(ptp_dte->reg_val[i],\n\t\t\t\t(ptp_dte->regs + (i * sizeof(u32))));\n\t\telse\n\t\t\twritel(((ptp_dte->reg_val[i] &\n\t\t\t\tDTE_NCO_SUM3_MASK) << DTE_NCO_SUM3_WR_SHIFT),\n\t\t\t\t(ptp_dte->regs + (i * sizeof(u32))));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ptp_dte_pm_ops = {\n\t.suspend = ptp_dte_suspend,\n\t.resume = ptp_dte_resume\n};\n\n#define PTP_DTE_PM_OPS\t(&ptp_dte_pm_ops)\n#else\n#define PTP_DTE_PM_OPS\tNULL\n#endif\n\nstatic const struct of_device_id ptp_dte_of_match[] = {\n\t{ .compatible = \"brcm,ptp-dte\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ptp_dte_of_match);\n\nstatic struct platform_driver ptp_dte_driver = {\n\t.driver = {\n\t\t.name = \"ptp-dte\",\n\t\t.pm = PTP_DTE_PM_OPS,\n\t\t.of_match_table = ptp_dte_of_match,\n\t},\n\t.probe    = ptp_dte_probe,\n\t.remove   = ptp_dte_remove,\n};\nmodule_platform_driver(ptp_dte_driver);\n\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_DESCRIPTION(\"Broadcom DTE PTP Clock driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}