{
  "module_name": "ptp_clock.c",
  "hash_id": "3a0f8edba487020fec38f454a397db7b846d49c2722d601d5a342997f71dce97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_clock.c",
  "human_readable_source": "\n \n#include <linux/idr.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/posix-clock.h>\n#include <linux/pps_kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/sched/types.h>\n\n#include \"ptp_private.h\"\n\n#define PTP_MAX_ALARMS 4\n#define PTP_PPS_DEFAULTS (PPS_CAPTUREASSERT | PPS_OFFSETASSERT)\n#define PTP_PPS_EVENT PPS_CAPTUREASSERT\n#define PTP_PPS_MODE (PTP_PPS_DEFAULTS | PPS_CANWAIT | PPS_TSFMT_TSPEC)\n\nstruct class *ptp_class;\n\n \n\nstatic dev_t ptp_devt;\n\nstatic DEFINE_IDA(ptp_clocks_map);\n\n \n\nstatic inline int queue_free(struct timestamp_event_queue *q)\n{\n\treturn PTP_MAX_TIMESTAMPS - queue_cnt(q) - 1;\n}\n\nstatic void enqueue_external_timestamp(struct timestamp_event_queue *queue,\n\t\t\t\t       struct ptp_clock_event *src)\n{\n\tstruct ptp_extts_event *dst;\n\tunsigned long flags;\n\ts64 seconds;\n\tu32 remainder;\n\n\tseconds = div_u64_rem(src->timestamp, 1000000000, &remainder);\n\n\tspin_lock_irqsave(&queue->lock, flags);\n\n\tdst = &queue->buf[queue->tail];\n\tdst->index = src->index;\n\tdst->t.sec = seconds;\n\tdst->t.nsec = remainder;\n\n\t \n\tif (!queue_free(queue))\n\t\tWRITE_ONCE(queue->head, (queue->head + 1) % PTP_MAX_TIMESTAMPS);\n\n\tWRITE_ONCE(queue->tail, (queue->tail + 1) % PTP_MAX_TIMESTAMPS);\n\n\tspin_unlock_irqrestore(&queue->lock, flags);\n}\n\n \n\nstatic int ptp_clock_getres(struct posix_clock *pc, struct timespec64 *tp)\n{\n\ttp->tv_sec = 0;\n\ttp->tv_nsec = 1;\n\treturn 0;\n}\n\nstatic int ptp_clock_settime(struct posix_clock *pc, const struct timespec64 *tp)\n{\n\tstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\n\n\tif (ptp_clock_freerun(ptp)) {\n\t\tpr_err(\"ptp: physical clock is free running\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn  ptp->info->settime64(ptp->info, tp);\n}\n\nstatic int ptp_clock_gettime(struct posix_clock *pc, struct timespec64 *tp)\n{\n\tstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\n\tint err;\n\n\tif (ptp->info->gettimex64)\n\t\terr = ptp->info->gettimex64(ptp->info, tp, NULL);\n\telse\n\t\terr = ptp->info->gettime64(ptp->info, tp);\n\treturn err;\n}\n\nstatic int ptp_clock_adjtime(struct posix_clock *pc, struct __kernel_timex *tx)\n{\n\tstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\n\tstruct ptp_clock_info *ops;\n\tint err = -EOPNOTSUPP;\n\n\tif (ptp_clock_freerun(ptp)) {\n\t\tpr_err(\"ptp: physical clock is free running\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tops = ptp->info;\n\n\tif (tx->modes & ADJ_SETOFFSET) {\n\t\tstruct timespec64 ts;\n\t\tktime_t kt;\n\t\ts64 delta;\n\n\t\tts.tv_sec  = tx->time.tv_sec;\n\t\tts.tv_nsec = tx->time.tv_usec;\n\n\t\tif (!(tx->modes & ADJ_NANO))\n\t\t\tts.tv_nsec *= 1000;\n\n\t\tif ((unsigned long) ts.tv_nsec >= NSEC_PER_SEC)\n\t\t\treturn -EINVAL;\n\n\t\tkt = timespec64_to_ktime(ts);\n\t\tdelta = ktime_to_ns(kt);\n\t\terr = ops->adjtime(ops, delta);\n\t} else if (tx->modes & ADJ_FREQUENCY) {\n\t\tlong ppb = scaled_ppm_to_ppb(tx->freq);\n\t\tif (ppb > ops->max_adj || ppb < -ops->max_adj)\n\t\t\treturn -ERANGE;\n\t\terr = ops->adjfine(ops, tx->freq);\n\t\tptp->dialed_frequency = tx->freq;\n\t} else if (tx->modes & ADJ_OFFSET) {\n\t\tif (ops->adjphase) {\n\t\t\ts32 max_phase_adj = ops->getmaxphase(ops);\n\t\t\ts32 offset = tx->offset;\n\n\t\t\tif (!(tx->modes & ADJ_NANO))\n\t\t\t\toffset *= NSEC_PER_USEC;\n\n\t\t\tif (offset > max_phase_adj || offset < -max_phase_adj)\n\t\t\t\treturn -ERANGE;\n\n\t\t\terr = ops->adjphase(ops, offset);\n\t\t}\n\t} else if (tx->modes == 0) {\n\t\ttx->freq = ptp->dialed_frequency;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}\n\nstatic struct posix_clock_operations ptp_clock_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.clock_adjtime\t= ptp_clock_adjtime,\n\t.clock_gettime\t= ptp_clock_gettime,\n\t.clock_getres\t= ptp_clock_getres,\n\t.clock_settime\t= ptp_clock_settime,\n\t.ioctl\t\t= ptp_ioctl,\n\t.open\t\t= ptp_open,\n\t.poll\t\t= ptp_poll,\n\t.read\t\t= ptp_read,\n};\n\nstatic void ptp_clock_release(struct device *dev)\n{\n\tstruct ptp_clock *ptp = container_of(dev, struct ptp_clock, dev);\n\n\tptp_cleanup_pin_groups(ptp);\n\tkfree(ptp->vclock_index);\n\tmutex_destroy(&ptp->tsevq_mux);\n\tmutex_destroy(&ptp->pincfg_mux);\n\tmutex_destroy(&ptp->n_vclocks_mux);\n\tida_free(&ptp_clocks_map, ptp->index);\n\tkfree(ptp);\n}\n\nstatic int ptp_getcycles64(struct ptp_clock_info *info, struct timespec64 *ts)\n{\n\tif (info->getcyclesx64)\n\t\treturn info->getcyclesx64(info, ts, NULL);\n\telse\n\t\treturn info->gettime64(info, ts);\n}\n\nstatic void ptp_aux_kworker(struct kthread_work *work)\n{\n\tstruct ptp_clock *ptp = container_of(work, struct ptp_clock,\n\t\t\t\t\t     aux_work.work);\n\tstruct ptp_clock_info *info = ptp->info;\n\tlong delay;\n\n\tdelay = info->do_aux_work(info);\n\n\tif (delay >= 0)\n\t\tkthread_queue_delayed_work(ptp->kworker, &ptp->aux_work, delay);\n}\n\n \n\nstruct ptp_clock *ptp_clock_register(struct ptp_clock_info *info,\n\t\t\t\t     struct device *parent)\n{\n\tstruct ptp_clock *ptp;\n\tint err = 0, index, major = MAJOR(ptp_devt);\n\tsize_t size;\n\n\tif (info->n_alarm > PTP_MAX_ALARMS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\terr = -ENOMEM;\n\tptp = kzalloc(sizeof(struct ptp_clock), GFP_KERNEL);\n\tif (ptp == NULL)\n\t\tgoto no_memory;\n\n\tindex = ida_alloc_max(&ptp_clocks_map, MINORMASK, GFP_KERNEL);\n\tif (index < 0) {\n\t\terr = index;\n\t\tgoto no_slot;\n\t}\n\n\tptp->clock.ops = ptp_clock_ops;\n\tptp->info = info;\n\tptp->devid = MKDEV(major, index);\n\tptp->index = index;\n\tspin_lock_init(&ptp->tsevq.lock);\n\tmutex_init(&ptp->tsevq_mux);\n\tmutex_init(&ptp->pincfg_mux);\n\tmutex_init(&ptp->n_vclocks_mux);\n\tinit_waitqueue_head(&ptp->tsev_wq);\n\n\tif (ptp->info->getcycles64 || ptp->info->getcyclesx64) {\n\t\tptp->has_cycles = true;\n\t\tif (!ptp->info->getcycles64 && ptp->info->getcyclesx64)\n\t\t\tptp->info->getcycles64 = ptp_getcycles64;\n\t} else {\n\t\t \n\t\tptp->info->getcycles64 = ptp_getcycles64;\n\n\t\tif (ptp->info->gettimex64)\n\t\t\tptp->info->getcyclesx64 = ptp->info->gettimex64;\n\n\t\tif (ptp->info->getcrosststamp)\n\t\t\tptp->info->getcrosscycles = ptp->info->getcrosststamp;\n\t}\n\n\tif (ptp->info->do_aux_work) {\n\t\tkthread_init_delayed_work(&ptp->aux_work, ptp_aux_kworker);\n\t\tptp->kworker = kthread_create_worker(0, \"ptp%d\", ptp->index);\n\t\tif (IS_ERR(ptp->kworker)) {\n\t\t\terr = PTR_ERR(ptp->kworker);\n\t\t\tpr_err(\"failed to create ptp aux_worker %d\\n\", err);\n\t\t\tgoto kworker_err;\n\t\t}\n\t}\n\n\t \n\tif (parent && parent->class && parent->class->name &&\n\t    strcmp(parent->class->name, \"ptp\") == 0)\n\t\tptp->is_virtual_clock = true;\n\n\tif (!ptp->is_virtual_clock) {\n\t\tptp->max_vclocks = PTP_DEFAULT_MAX_VCLOCKS;\n\n\t\tsize = sizeof(int) * ptp->max_vclocks;\n\t\tptp->vclock_index = kzalloc(size, GFP_KERNEL);\n\t\tif (!ptp->vclock_index) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto no_mem_for_vclocks;\n\t\t}\n\t}\n\n\terr = ptp_populate_pin_groups(ptp);\n\tif (err)\n\t\tgoto no_pin_groups;\n\n\t \n\tif (info->pps) {\n\t\tstruct pps_source_info pps;\n\t\tmemset(&pps, 0, sizeof(pps));\n\t\tsnprintf(pps.name, PPS_MAX_NAME_LEN, \"ptp%d\", index);\n\t\tpps.mode = PTP_PPS_MODE;\n\t\tpps.owner = info->owner;\n\t\tptp->pps_source = pps_register_source(&pps, PTP_PPS_DEFAULTS);\n\t\tif (IS_ERR(ptp->pps_source)) {\n\t\t\terr = PTR_ERR(ptp->pps_source);\n\t\t\tpr_err(\"failed to register pps source\\n\");\n\t\t\tgoto no_pps;\n\t\t}\n\t\tptp->pps_source->lookup_cookie = ptp;\n\t}\n\n\t \n\tdevice_initialize(&ptp->dev);\n\tptp->dev.devt = ptp->devid;\n\tptp->dev.class = ptp_class;\n\tptp->dev.parent = parent;\n\tptp->dev.groups = ptp->pin_attr_groups;\n\tptp->dev.release = ptp_clock_release;\n\tdev_set_drvdata(&ptp->dev, ptp);\n\tdev_set_name(&ptp->dev, \"ptp%d\", ptp->index);\n\n\t \n\terr = posix_clock_register(&ptp->clock, &ptp->dev);\n\tif (err) {\n\t\tif (ptp->pps_source)\n\t\t\tpps_unregister_source(ptp->pps_source);\n\n\t\tif (ptp->kworker)\n\t\t\tkthread_destroy_worker(ptp->kworker);\n\n\t\tput_device(&ptp->dev);\n\n\t\tpr_err(\"failed to create posix clock\\n\");\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn ptp;\n\nno_pps:\n\tptp_cleanup_pin_groups(ptp);\nno_pin_groups:\n\tkfree(ptp->vclock_index);\nno_mem_for_vclocks:\n\tif (ptp->kworker)\n\t\tkthread_destroy_worker(ptp->kworker);\nkworker_err:\n\tmutex_destroy(&ptp->tsevq_mux);\n\tmutex_destroy(&ptp->pincfg_mux);\n\tmutex_destroy(&ptp->n_vclocks_mux);\n\tida_free(&ptp_clocks_map, index);\nno_slot:\n\tkfree(ptp);\nno_memory:\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(ptp_clock_register);\n\nstatic int unregister_vclock(struct device *dev, void *data)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\n\tptp_vclock_unregister(info_to_vclock(ptp->info));\n\treturn 0;\n}\n\nint ptp_clock_unregister(struct ptp_clock *ptp)\n{\n\tif (ptp_vclock_in_use(ptp)) {\n\t\tdevice_for_each_child(&ptp->dev, NULL, unregister_vclock);\n\t}\n\n\tptp->defunct = 1;\n\twake_up_interruptible(&ptp->tsev_wq);\n\n\tif (ptp->kworker) {\n\t\tkthread_cancel_delayed_work_sync(&ptp->aux_work);\n\t\tkthread_destroy_worker(ptp->kworker);\n\t}\n\n\t \n\tif (ptp->pps_source)\n\t\tpps_unregister_source(ptp->pps_source);\n\n\tposix_clock_unregister(&ptp->clock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ptp_clock_unregister);\n\nvoid ptp_clock_event(struct ptp_clock *ptp, struct ptp_clock_event *event)\n{\n\tstruct pps_event_time evt;\n\n\tswitch (event->type) {\n\n\tcase PTP_CLOCK_ALARM:\n\t\tbreak;\n\n\tcase PTP_CLOCK_EXTTS:\n\t\tenqueue_external_timestamp(&ptp->tsevq, event);\n\t\twake_up_interruptible(&ptp->tsev_wq);\n\t\tbreak;\n\n\tcase PTP_CLOCK_PPS:\n\t\tpps_get_ts(&evt);\n\t\tpps_event(ptp->pps_source, &evt, PTP_PPS_EVENT, NULL);\n\t\tbreak;\n\n\tcase PTP_CLOCK_PPSUSR:\n\t\tpps_event(ptp->pps_source, &event->pps_times,\n\t\t\t  PTP_PPS_EVENT, NULL);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(ptp_clock_event);\n\nint ptp_clock_index(struct ptp_clock *ptp)\n{\n\treturn ptp->index;\n}\nEXPORT_SYMBOL(ptp_clock_index);\n\nint ptp_find_pin(struct ptp_clock *ptp,\n\t\t enum ptp_pin_function func, unsigned int chan)\n{\n\tstruct ptp_pin_desc *pin = NULL;\n\tint i;\n\n\tfor (i = 0; i < ptp->info->n_pins; i++) {\n\t\tif (ptp->info->pin_config[i].func == func &&\n\t\t    ptp->info->pin_config[i].chan == chan) {\n\t\t\tpin = &ptp->info->pin_config[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pin ? i : -1;\n}\nEXPORT_SYMBOL(ptp_find_pin);\n\nint ptp_find_pin_unlocked(struct ptp_clock *ptp,\n\t\t\t  enum ptp_pin_function func, unsigned int chan)\n{\n\tint result;\n\n\tmutex_lock(&ptp->pincfg_mux);\n\n\tresult = ptp_find_pin(ptp, func, chan);\n\n\tmutex_unlock(&ptp->pincfg_mux);\n\n\treturn result;\n}\nEXPORT_SYMBOL(ptp_find_pin_unlocked);\n\nint ptp_schedule_worker(struct ptp_clock *ptp, unsigned long delay)\n{\n\treturn kthread_mod_delayed_work(ptp->kworker, &ptp->aux_work, delay);\n}\nEXPORT_SYMBOL(ptp_schedule_worker);\n\nvoid ptp_cancel_worker_sync(struct ptp_clock *ptp)\n{\n\tkthread_cancel_delayed_work_sync(&ptp->aux_work);\n}\nEXPORT_SYMBOL(ptp_cancel_worker_sync);\n\n \n\nstatic void __exit ptp_exit(void)\n{\n\tclass_destroy(ptp_class);\n\tunregister_chrdev_region(ptp_devt, MINORMASK + 1);\n\tida_destroy(&ptp_clocks_map);\n}\n\nstatic int __init ptp_init(void)\n{\n\tint err;\n\n\tptp_class = class_create(\"ptp\");\n\tif (IS_ERR(ptp_class)) {\n\t\tpr_err(\"ptp: failed to allocate class\\n\");\n\t\treturn PTR_ERR(ptp_class);\n\t}\n\n\terr = alloc_chrdev_region(&ptp_devt, 0, MINORMASK + 1, \"ptp\");\n\tif (err < 0) {\n\t\tpr_err(\"ptp: failed to allocate device region\\n\");\n\t\tgoto no_region;\n\t}\n\n\tptp_class->dev_groups = ptp_groups;\n\tpr_info(\"PTP clock support registered\\n\");\n\treturn 0;\n\nno_region:\n\tclass_destroy(ptp_class);\n\treturn err;\n}\n\nsubsys_initcall(ptp_init);\nmodule_exit(ptp_exit);\n\nMODULE_AUTHOR(\"Richard Cochran <richardcochran@gmail.com>\");\nMODULE_DESCRIPTION(\"PTP clocks support\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}