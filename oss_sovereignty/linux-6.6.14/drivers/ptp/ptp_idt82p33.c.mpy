{
  "module_name": "ptp_idt82p33.c",
  "hash_id": "0ab3be0d2c79b8acefd58bd2e92889cd8b555677ae69633d280471a63af8ea8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_idt82p33.c",
  "human_readable_source": "\n\n\n\n\n#define pr_fmt(fmt) \"IDT_82p33xxx: \" fmt\n\n#include <linux/firmware.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/timekeeping.h>\n#include <linux/bitops.h>\n#include <linux/of.h>\n#include <linux/mfd/rsmu.h>\n#include <linux/mfd/idt82p33_reg.h>\n\n#include \"ptp_private.h\"\n#include \"ptp_idt82p33.h\"\n\nMODULE_DESCRIPTION(\"Driver for IDT 82p33xxx clock devices\");\nMODULE_AUTHOR(\"IDT support-1588 <IDT-support-1588@lm.renesas.com>\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FW_FILENAME);\n\n#define EXTTS_PERIOD_MS (95)\n\n \nstatic u32 phase_snap_threshold = SNAP_THRESHOLD_NS;\nmodule_param(phase_snap_threshold, uint, 0);\nMODULE_PARM_DESC(phase_snap_threshold,\n\"threshold (10000ns by default) below which adjtime would use double dco\");\n\nstatic char *firmware;\nmodule_param(firmware, charp, 0);\n\nstatic struct ptp_pin_desc pin_config[MAX_PHC_PLL][MAX_TRIG_CLK];\n\nstatic inline int idt82p33_read(struct idt82p33 *idt82p33, u16 regaddr,\n\t\t\t\tu8 *buf, u16 count)\n{\n\treturn regmap_bulk_read(idt82p33->regmap, regaddr, buf, count);\n}\n\nstatic inline int idt82p33_write(struct idt82p33 *idt82p33, u16 regaddr,\n\t\t\t\t u8 *buf, u16 count)\n{\n\treturn regmap_bulk_write(idt82p33->regmap, regaddr, buf, count);\n}\n\nstatic void idt82p33_byte_array_to_timespec(struct timespec64 *ts,\n\t\t\t\t\t    u8 buf[TOD_BYTE_COUNT])\n{\n\ttime64_t sec;\n\ts32 nsec;\n\tu8 i;\n\n\tnsec = buf[3];\n\tfor (i = 0; i < 3; i++) {\n\t\tnsec <<= 8;\n\t\tnsec |= buf[2 - i];\n\t}\n\n\tsec = buf[9];\n\tfor (i = 0; i < 5; i++) {\n\t\tsec <<= 8;\n\t\tsec |= buf[8 - i];\n\t}\n\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}\n\nstatic void idt82p33_timespec_to_byte_array(struct timespec64 const *ts,\n\t\t\t\t\t    u8 buf[TOD_BYTE_COUNT])\n{\n\ttime64_t sec;\n\ts32 nsec;\n\tu8 i;\n\n\tnsec = ts->tv_nsec;\n\tsec = ts->tv_sec;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tbuf[i] = nsec & 0xff;\n\t\tnsec >>= 8;\n\t}\n\n\tfor (i = 4; i < TOD_BYTE_COUNT; i++) {\n\t\tbuf[i] = sec & 0xff;\n\t\tsec >>= 8;\n\t}\n}\n\nstatic int idt82p33_dpll_set_mode(struct idt82p33_channel *channel,\n\t\t\t\t  enum pll_mode mode)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tu8 dpll_mode;\n\tint err;\n\n\tif (channel->pll_mode == mode)\n\t\treturn 0;\n\n\terr = idt82p33_read(idt82p33, channel->dpll_mode_cnfg,\n\t\t\t    &dpll_mode, sizeof(dpll_mode));\n\tif (err)\n\t\treturn err;\n\n\tdpll_mode &= ~(PLL_MODE_MASK << PLL_MODE_SHIFT);\n\n\tdpll_mode |= (mode << PLL_MODE_SHIFT);\n\n\terr = idt82p33_write(idt82p33, channel->dpll_mode_cnfg,\n\t\t\t     &dpll_mode, sizeof(dpll_mode));\n\tif (err)\n\t\treturn err;\n\n\tchannel->pll_mode = mode;\n\n\treturn 0;\n}\n\nstatic int idt82p33_set_tod_trigger(struct idt82p33_channel *channel,\n\t\t\t\t    u8 trigger, bool write)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tint err;\n\tu8 cfg;\n\n\tif (trigger > WR_TRIG_SEL_MAX)\n\t\treturn -EINVAL;\n\n\terr = idt82p33_read(idt82p33, channel->dpll_tod_trigger,\n\t\t\t    &cfg, sizeof(cfg));\n\n\tif (err)\n\t\treturn err;\n\n\tif (write == true)\n\t\ttrigger = (trigger << WRITE_TRIGGER_SHIFT) |\n\t\t\t  (cfg & READ_TRIGGER_MASK);\n\telse\n\t\ttrigger = (trigger << READ_TRIGGER_SHIFT) |\n\t\t\t  (cfg & WRITE_TRIGGER_MASK);\n\n\treturn idt82p33_write(idt82p33, channel->dpll_tod_trigger,\n\t\t\t      &trigger, sizeof(trigger));\n}\n\nstatic int idt82p33_get_extts(struct idt82p33_channel *channel,\n\t\t\t      struct timespec64 *ts)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tu8 buf[TOD_BYTE_COUNT];\n\tint err;\n\n\terr = idt82p33_read(idt82p33, channel->dpll_tod_sts, buf, sizeof(buf));\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (memcmp(buf, channel->extts_tod_sts, TOD_BYTE_COUNT) == 0)\n\t\treturn -EAGAIN;\n\n\tmemcpy(channel->extts_tod_sts, buf, TOD_BYTE_COUNT);\n\n\tidt82p33_byte_array_to_timespec(ts, buf);\n\n\tif (channel->discard_next_extts) {\n\t\tchannel->discard_next_extts = false;\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic int map_ref_to_tod_trig_sel(int ref, u8 *trigger)\n{\n\tint err = 0;\n\n\tswitch (ref) {\n\tcase 0:\n\t\t*trigger = HW_TOD_TRIG_SEL_IN12;\n\t\tbreak;\n\tcase 1:\n\t\t*trigger = HW_TOD_TRIG_SEL_IN13;\n\t\tbreak;\n\tcase 2:\n\t\t*trigger = HW_TOD_TRIG_SEL_IN14;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic bool is_one_shot(u8 mask)\n{\n\t \n\tif ((mask == 1) || (mask == 2))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nstatic int arm_tod_read_with_trigger(struct idt82p33_channel *channel, u8 trigger)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tu8 buf[TOD_BYTE_COUNT];\n\tint err;\n\n\t \n\terr = idt82p33_read(idt82p33, channel->dpll_tod_sts, buf, sizeof(buf));\n\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(channel->extts_tod_sts, buf, TOD_BYTE_COUNT);\n\n\terr = idt82p33_set_tod_trigger(channel, trigger, false);\n\n\tif (err)\n\t\tdev_err(idt82p33->dev, \"%s: err = %d\", __func__, err);\n\n\treturn err;\n}\n\nstatic int idt82p33_extts_enable(struct idt82p33_channel *channel,\n\t\t\t\t struct ptp_clock_request *rq, int on)\n{\n\tu8 index = rq->extts.index;\n\tstruct idt82p33 *idt82p33;\n\tu8 mask = 1 << index;\n\tint err = 0;\n\tu8 old_mask;\n\tu8 trigger;\n\tint ref;\n\n\tidt82p33  = channel->idt82p33;\n\told_mask = idt82p33->extts_mask;\n\n\t \n\tif (rq->extts.flags & ~(PTP_ENABLE_FEATURE |\n\t\t\t\tPTP_RISING_EDGE |\n\t\t\t\tPTP_FALLING_EDGE |\n\t\t\t\tPTP_STRICT_FLAGS))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((rq->extts.flags & PTP_ENABLE_FEATURE) &&\n\t    (rq->extts.flags & PTP_FALLING_EDGE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (index >= MAX_PHC_PLL)\n\t\treturn -EINVAL;\n\n\tif (on) {\n\t\t \n\t\tif (idt82p33->extts_mask & mask)\n\t\t\treturn 0;\n\n\t\t \n\t\tref = ptp_find_pin(channel->ptp_clock, PTP_PF_EXTTS, channel->plln);\n\n\t\tif (ref < 0) {\n\t\t\tdev_err(idt82p33->dev, \"%s: No valid pin found for Pll%d!\\n\",\n\t\t\t\t__func__, channel->plln);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\terr = map_ref_to_tod_trig_sel(ref, &trigger);\n\n\t\tif (err) {\n\t\t\tdev_err(idt82p33->dev,\n\t\t\t\t\"%s: Unsupported ref %d!\\n\", __func__, ref);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = arm_tod_read_with_trigger(&idt82p33->channel[index], trigger);\n\n\t\tif (err == 0) {\n\t\t\tidt82p33->extts_mask |= mask;\n\t\t\tidt82p33->channel[index].tod_trigger = trigger;\n\t\t\tidt82p33->event_channel[index] = channel;\n\t\t\tidt82p33->extts_single_shot = is_one_shot(idt82p33->extts_mask);\n\n\t\t\tif (old_mask)\n\t\t\t\treturn 0;\n\n\t\t\tschedule_delayed_work(&idt82p33->extts_work,\n\t\t\t\t\t      msecs_to_jiffies(EXTTS_PERIOD_MS));\n\t\t}\n\t} else {\n\t\tidt82p33->extts_mask &= ~mask;\n\t\tidt82p33->extts_single_shot = is_one_shot(idt82p33->extts_mask);\n\n\t\tif (idt82p33->extts_mask == 0)\n\t\t\tcancel_delayed_work(&idt82p33->extts_work);\n\t}\n\n\treturn err;\n}\n\nstatic int idt82p33_extts_check_channel(struct idt82p33 *idt82p33, u8 todn)\n{\n\tstruct idt82p33_channel *event_channel;\n\tstruct ptp_clock_event event;\n\tstruct timespec64 ts;\n\tint err;\n\n\terr = idt82p33_get_extts(&idt82p33->channel[todn], &ts);\n\tif (err == 0) {\n\t\tevent_channel = idt82p33->event_channel[todn];\n\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\tevent.index = todn;\n\t\tevent.timestamp = timespec64_to_ns(&ts);\n\t\tptp_clock_event(event_channel->ptp_clock,\n\t\t\t\t&event);\n\t}\n\treturn err;\n}\n\nstatic u8 idt82p33_extts_enable_mask(struct idt82p33_channel *channel,\n\t\t\t\t     u8 extts_mask, bool enable)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tu8 trigger = channel->tod_trigger;\n\tu8 mask;\n\tint err;\n\tint i;\n\n\tif (extts_mask == 0)\n\t\treturn 0;\n\n\tif (enable == false)\n\t\tcancel_delayed_work_sync(&idt82p33->extts_work);\n\n\tfor (i = 0; i < MAX_PHC_PLL; i++) {\n\t\tmask = 1 << i;\n\n\t\tif ((extts_mask & mask) == 0)\n\t\t\tcontinue;\n\n\t\tif (enable) {\n\t\t\terr = arm_tod_read_with_trigger(&idt82p33->channel[i], trigger);\n\t\t\tif (err)\n\t\t\t\tdev_err(idt82p33->dev,\n\t\t\t\t\t\"%s: Arm ToD read trigger failed, err = %d\",\n\t\t\t\t\t__func__, err);\n\t\t} else {\n\t\t\terr = idt82p33_extts_check_channel(idt82p33, i);\n\t\t\tif (err == 0 && idt82p33->extts_single_shot)\n\t\t\t\t \n\t\t\t\textts_mask &= ~mask;\n\t\t}\n\t}\n\n\tif (enable)\n\t\tschedule_delayed_work(&idt82p33->extts_work,\n\t\t\t\t      msecs_to_jiffies(EXTTS_PERIOD_MS));\n\n\treturn extts_mask;\n}\n\nstatic int _idt82p33_gettime(struct idt82p33_channel *channel,\n\t\t\t     struct timespec64 *ts)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tu8 old_mask = idt82p33->extts_mask;\n\tu8 buf[TOD_BYTE_COUNT];\n\tu8 new_mask = 0;\n\tint err;\n\n\t \n\tif (old_mask)\n\t\tnew_mask = idt82p33_extts_enable_mask(channel, old_mask, false);\n\n\terr = idt82p33_set_tod_trigger(channel, HW_TOD_RD_TRIG_SEL_LSB_TOD_STS,\n\t\t\t\t       false);\n\tif (err)\n\t\treturn err;\n\n\tchannel->discard_next_extts = true;\n\n\tif (idt82p33->calculate_overhead_flag)\n\t\tidt82p33->start_time = ktime_get_raw();\n\n\terr = idt82p33_read(idt82p33, channel->dpll_tod_sts, buf, sizeof(buf));\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (new_mask)\n\t\tidt82p33_extts_enable_mask(channel, new_mask, true);\n\n\tidt82p33_byte_array_to_timespec(ts, buf);\n\n\treturn 0;\n}\n\n \n\nstatic int _idt82p33_settime(struct idt82p33_channel *channel,\n\t\t\t     struct timespec64 const *ts)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tstruct timespec64 local_ts = *ts;\n\tchar buf[TOD_BYTE_COUNT];\n\ts64 dynamic_overhead_ns;\n\tint err;\n\tu8 i;\n\n\terr = idt82p33_set_tod_trigger(channel, HW_TOD_WR_TRIG_SEL_MSB_TOD_CNFG,\n\t\t\t\t       true);\n\tif (err)\n\t\treturn err;\n\n\tchannel->discard_next_extts = true;\n\n\tif (idt82p33->calculate_overhead_flag) {\n\t\tdynamic_overhead_ns = ktime_to_ns(ktime_get_raw())\n\t\t\t\t\t- ktime_to_ns(idt82p33->start_time);\n\n\t\ttimespec64_add_ns(&local_ts, dynamic_overhead_ns);\n\n\t\tidt82p33->calculate_overhead_flag = 0;\n\t}\n\n\tidt82p33_timespec_to_byte_array(&local_ts, buf);\n\n\t \n\tfor (i = 0; i < TOD_BYTE_COUNT; i++) {\n\t\terr = idt82p33_write(idt82p33, channel->dpll_tod_cnfg + i,\n\t\t\t\t     &buf[i], sizeof(buf[i]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int _idt82p33_adjtime_immediate(struct idt82p33_channel *channel,\n\t\t\t\t       s64 delta_ns)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tstruct timespec64 ts;\n\ts64 now_ns;\n\tint err;\n\n\tidt82p33->calculate_overhead_flag = 1;\n\n\terr = _idt82p33_gettime(channel, &ts);\n\n\tif (err)\n\t\treturn err;\n\n\tnow_ns = timespec64_to_ns(&ts);\n\tnow_ns += delta_ns + idt82p33->tod_write_overhead_ns;\n\n\tts = ns_to_timespec64(now_ns);\n\n\terr = _idt82p33_settime(channel, &ts);\n\n\treturn err;\n}\n\nstatic int _idt82p33_adjtime_internal_triggered(struct idt82p33_channel *channel,\n\t\t\t\t\t\ts64 delta_ns)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tchar buf[TOD_BYTE_COUNT];\n\tstruct timespec64 ts;\n\tconst u8 delay_ns = 32;\n\ts32 remainder;\n\ts64 ns;\n\tint err;\n\n\terr = _idt82p33_gettime(channel, &ts);\n\n\tif (err)\n\t\treturn err;\n\n\tif (ts.tv_nsec > (NSEC_PER_SEC - 5 * NSEC_PER_MSEC)) {\n\t\t \n\t\tmdelay(6);\n\t\tns = (ts.tv_sec + 2) * NSEC_PER_SEC + delta_ns + delay_ns;\n\t} else\n\t\tns = (ts.tv_sec + 1) * NSEC_PER_SEC + delta_ns + delay_ns;\n\n\tts = ns_to_timespec64(ns);\n\tidt82p33_timespec_to_byte_array(&ts, buf);\n\n\t \n\terr = idt82p33_write(idt82p33, channel->dpll_tod_cnfg, buf, sizeof(buf));\n\tif (err)\n\t\treturn err;\n\n\t \n\t(void)div_s64_rem(delta_ns, NSEC_PER_SEC, &remainder);\n\tif (remainder != 0)\n\t\tschedule_delayed_work(&channel->adjtime_work, HZ);\n\n\treturn idt82p33_set_tod_trigger(channel, HW_TOD_TRIG_SEL_TOD_PPS, true);\n}\n\nstatic void idt82p33_adjtime_workaround(struct work_struct *work)\n{\n\tstruct idt82p33_channel *channel = container_of(work,\n\t\t\t\t\t\t\tstruct idt82p33_channel,\n\t\t\t\t\t\t\tadjtime_work.work);\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\n\tmutex_lock(idt82p33->lock);\n\t \n\t_idt82p33_adjtime_internal_triggered(channel, 0);\n\tmutex_unlock(idt82p33->lock);\n}\n\nstatic int _idt82p33_adjfine(struct idt82p33_channel *channel, long scaled_ppm)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tunsigned char buf[5] = {0};\n\tint err, i;\n\ts64 fcw;\n\n\t \n\n\tfcw = scaled_ppm * 762939453125ULL;\n\tfcw = div_s64(fcw, 8430756LL);\n\n\tfor (i = 0; i < 5; i++) {\n\t\tbuf[i] = fcw & 0xff;\n\t\tfcw >>= 8;\n\t}\n\n\terr = idt82p33_dpll_set_mode(channel, PLL_MODE_DCO);\n\n\tif (err)\n\t\treturn err;\n\n\terr = idt82p33_write(idt82p33, channel->dpll_freq_cnfg,\n\t\t\t     buf, sizeof(buf));\n\n\treturn err;\n}\n\n \nstatic s32 idt82p33_ddco_scaled_ppm(long current_ppm, s32 ddco_ppb)\n{\n\ts64 scaled_ppm = div_s64(((s64)ddco_ppb << 13), 125);\n\ts64 max_scaled_ppm = div_s64(((s64)DCO_MAX_PPB << 13), 125);\n\n\tcurrent_ppm += scaled_ppm;\n\n\tif (current_ppm > max_scaled_ppm)\n\t\tcurrent_ppm = max_scaled_ppm;\n\telse if (current_ppm < -max_scaled_ppm)\n\t\tcurrent_ppm = -max_scaled_ppm;\n\n\treturn (s32)current_ppm;\n}\n\nstatic int idt82p33_stop_ddco(struct idt82p33_channel *channel)\n{\n\tint err;\n\n\terr = _idt82p33_adjfine(channel, channel->current_freq);\n\tif (err)\n\t\treturn err;\n\n\tchannel->ddco = false;\n\n\treturn 0;\n}\n\nstatic int idt82p33_start_ddco(struct idt82p33_channel *channel, s32 delta_ns)\n{\n\ts32 current_ppm = channel->current_freq;\n\tu32 duration_ms = MSEC_PER_SEC;\n\ts32 ppb;\n\tint err;\n\n\t \n\tif (abs(delta_ns) < DDCO_THRESHOLD_NS)\n\t\treturn 0;\n\n\t \n\tppb = delta_ns;\n\twhile (abs(ppb) > DCO_MAX_PPB) {\n\t\tduration_ms *= 2;\n\t\tppb /= 2;\n\t}\n\n\terr = _idt82p33_adjfine(channel,\n\t\t\t\tidt82p33_ddco_scaled_ppm(current_ppm, ppb));\n\tif (err)\n\t\treturn err;\n\n\t \n\tptp_schedule_worker(channel->ptp_clock,\n\t\t\t    msecs_to_jiffies(duration_ms) - 1);\n\tchannel->ddco = true;\n\n\treturn 0;\n}\n\nstatic int idt82p33_measure_one_byte_write_overhead(\n\t\tstruct idt82p33_channel *channel, s64 *overhead_ns)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tktime_t start, stop;\n\tu8 trigger = 0;\n\ts64 total_ns;\n\tint err;\n\tu8 i;\n\n\ttotal_ns = 0;\n\t*overhead_ns = 0;\n\n\tfor (i = 0; i < MAX_MEASURMENT_COUNT; i++) {\n\n\t\tstart = ktime_get_raw();\n\n\t\terr = idt82p33_write(idt82p33, channel->dpll_tod_trigger,\n\t\t\t\t     &trigger, sizeof(trigger));\n\n\t\tstop = ktime_get_raw();\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttotal_ns += ktime_to_ns(stop) - ktime_to_ns(start);\n\t}\n\n\t*overhead_ns = div_s64(total_ns, MAX_MEASURMENT_COUNT);\n\n\treturn err;\n}\n\nstatic int idt82p33_measure_one_byte_read_overhead(\n\t\tstruct idt82p33_channel *channel, s64 *overhead_ns)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tktime_t start, stop;\n\tu8 trigger = 0;\n\ts64 total_ns;\n\tint err;\n\tu8 i;\n\n\ttotal_ns = 0;\n\t*overhead_ns = 0;\n\n\tfor (i = 0; i < MAX_MEASURMENT_COUNT; i++) {\n\n\t\tstart = ktime_get_raw();\n\n\t\terr = idt82p33_read(idt82p33, channel->dpll_tod_trigger,\n\t\t\t\t    &trigger, sizeof(trigger));\n\n\t\tstop = ktime_get_raw();\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttotal_ns += ktime_to_ns(stop) - ktime_to_ns(start);\n\t}\n\n\t*overhead_ns = div_s64(total_ns, MAX_MEASURMENT_COUNT);\n\n\treturn err;\n}\n\nstatic int idt82p33_measure_tod_write_9_byte_overhead(\n\t\tstruct idt82p33_channel *channel)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tu8 buf[TOD_BYTE_COUNT];\n\tktime_t start, stop;\n\ts64 total_ns;\n\tint err = 0;\n\tu8 i, j;\n\n\ttotal_ns = 0;\n\tidt82p33->tod_write_overhead_ns = 0;\n\n\tfor (i = 0; i < MAX_MEASURMENT_COUNT; i++) {\n\n\t\tstart = ktime_get_raw();\n\n\t\t \n\t\tfor (j = 0; j < (TOD_BYTE_COUNT - 1); j++) {\n\t\t\terr = idt82p33_write(idt82p33,\n\t\t\t\t\t     channel->dpll_tod_cnfg + i,\n\t\t\t\t\t     &buf[i], sizeof(buf[i]));\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tstop = ktime_get_raw();\n\n\t\ttotal_ns += ktime_to_ns(stop) - ktime_to_ns(start);\n\t}\n\n\tidt82p33->tod_write_overhead_ns = div_s64(total_ns,\n\t\t\t\t\t\t  MAX_MEASURMENT_COUNT);\n\n\treturn err;\n}\n\nstatic int idt82p33_measure_settime_gettime_gap_overhead(\n\t\tstruct idt82p33_channel *channel, s64 *overhead_ns)\n{\n\tstruct timespec64 ts1 = {0, 0};\n\tstruct timespec64 ts2;\n\tint err;\n\n\t*overhead_ns = 0;\n\n\terr = _idt82p33_settime(channel, &ts1);\n\n\tif (err)\n\t\treturn err;\n\n\terr = _idt82p33_gettime(channel, &ts2);\n\n\tif (!err)\n\t\t*overhead_ns = timespec64_to_ns(&ts2) - timespec64_to_ns(&ts1);\n\n\treturn err;\n}\n\nstatic int idt82p33_measure_tod_write_overhead(struct idt82p33_channel *channel)\n{\n\ts64 trailing_overhead_ns, one_byte_write_ns, gap_ns, one_byte_read_ns;\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tint err;\n\n\tidt82p33->tod_write_overhead_ns = 0;\n\n\terr = idt82p33_measure_settime_gettime_gap_overhead(channel, &gap_ns);\n\n\tif (err) {\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Failed in %s with err %d!\\n\", __func__, err);\n\t\treturn err;\n\t}\n\n\terr = idt82p33_measure_one_byte_write_overhead(channel,\n\t\t\t\t\t\t       &one_byte_write_ns);\n\n\tif (err)\n\t\treturn err;\n\n\terr = idt82p33_measure_one_byte_read_overhead(channel,\n\t\t\t\t\t\t      &one_byte_read_ns);\n\n\tif (err)\n\t\treturn err;\n\n\terr = idt82p33_measure_tod_write_9_byte_overhead(channel);\n\n\tif (err)\n\t\treturn err;\n\n\ttrailing_overhead_ns = gap_ns - 2 * one_byte_write_ns\n\t\t\t       - one_byte_read_ns;\n\n\tidt82p33->tod_write_overhead_ns -= trailing_overhead_ns;\n\n\treturn err;\n}\n\nstatic int idt82p33_check_and_set_masks(struct idt82p33 *idt82p33,\n\t\t\t\t\tu8 page,\n\t\t\t\t\tu8 offset,\n\t\t\t\t\tu8 val)\n{\n\tint err = 0;\n\n\tif (page == PLLMASK_ADDR_HI && offset == PLLMASK_ADDR_LO) {\n\t\tif ((val & 0xfc) || !(val & 0x3)) {\n\t\t\tdev_err(idt82p33->dev,\n\t\t\t\t\"Invalid PLL mask 0x%x\\n\", val);\n\t\t\terr = -EINVAL;\n\t\t} else {\n\t\t\tidt82p33->pll_mask = val;\n\t\t}\n\t} else if (page == PLL0_OUTMASK_ADDR_HI &&\n\t\toffset == PLL0_OUTMASK_ADDR_LO) {\n\t\tidt82p33->channel[0].output_mask = val;\n\t} else if (page == PLL1_OUTMASK_ADDR_HI &&\n\t\toffset == PLL1_OUTMASK_ADDR_LO) {\n\t\tidt82p33->channel[1].output_mask = val;\n\t}\n\n\treturn err;\n}\n\nstatic void idt82p33_display_masks(struct idt82p33 *idt82p33)\n{\n\tu8 mask, i;\n\n\tdev_info(idt82p33->dev,\n\t\t \"pllmask = 0x%02x\\n\", idt82p33->pll_mask);\n\n\tfor (i = 0; i < MAX_PHC_PLL; i++) {\n\t\tmask = 1 << i;\n\n\t\tif (mask & idt82p33->pll_mask)\n\t\t\tdev_info(idt82p33->dev,\n\t\t\t\t \"PLL%d output_mask = 0x%04x\\n\",\n\t\t\t\t i, idt82p33->channel[i].output_mask);\n\t}\n}\n\nstatic int idt82p33_sync_tod(struct idt82p33_channel *channel, bool enable)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tu8 sync_cnfg;\n\tint err;\n\n\terr = idt82p33_read(idt82p33, channel->dpll_sync_cnfg,\n\t\t\t    &sync_cnfg, sizeof(sync_cnfg));\n\tif (err)\n\t\treturn err;\n\n\tsync_cnfg &= ~SYNC_TOD;\n\tif (enable)\n\t\tsync_cnfg |= SYNC_TOD;\n\n\treturn idt82p33_write(idt82p33, channel->dpll_sync_cnfg,\n\t\t\t      &sync_cnfg, sizeof(sync_cnfg));\n}\n\nstatic long idt82p33_work_handler(struct ptp_clock_info *ptp)\n{\n\tstruct idt82p33_channel *channel =\n\t\t\tcontainer_of(ptp, struct idt82p33_channel, caps);\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\n\tmutex_lock(idt82p33->lock);\n\t(void)idt82p33_stop_ddco(channel);\n\tmutex_unlock(idt82p33->lock);\n\n\t \n\treturn -1;\n}\n\nstatic int idt82p33_output_enable(struct idt82p33_channel *channel,\n\t\t\t\t  bool enable, unsigned int outn)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tint err;\n\tu8 val;\n\n\terr = idt82p33_read(idt82p33, OUT_MUX_CNFG(outn), &val, sizeof(val));\n\tif (err)\n\t\treturn err;\n\tif (enable)\n\t\tval &= ~SQUELCH_ENABLE;\n\telse\n\t\tval |= SQUELCH_ENABLE;\n\n\treturn idt82p33_write(idt82p33, OUT_MUX_CNFG(outn), &val, sizeof(val));\n}\n\nstatic int idt82p33_perout_enable(struct idt82p33_channel *channel,\n\t\t\t\t  bool enable,\n\t\t\t\t  struct ptp_perout_request *perout)\n{\n\t \n\treturn idt82p33_output_enable(channel, enable, perout->index);\n}\n\nstatic int idt82p33_enable_tod(struct idt82p33_channel *channel)\n{\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tstruct timespec64 ts = {0, 0};\n\tint err;\n\n\terr = idt82p33_measure_tod_write_overhead(channel);\n\n\tif (err) {\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Failed in %s with err %d!\\n\", __func__, err);\n\t\treturn err;\n\t}\n\n\terr = _idt82p33_settime(channel, &ts);\n\n\tif (err)\n\t\treturn err;\n\n\treturn idt82p33_sync_tod(channel, true);\n}\n\nstatic void idt82p33_ptp_clock_unregister_all(struct idt82p33 *idt82p33)\n{\n\tstruct idt82p33_channel *channel;\n\tu8 i;\n\n\tfor (i = 0; i < MAX_PHC_PLL; i++) {\n\t\tchannel = &idt82p33->channel[i];\n\t\tcancel_delayed_work_sync(&channel->adjtime_work);\n\t\tif (channel->ptp_clock)\n\t\t\tptp_clock_unregister(channel->ptp_clock);\n\t}\n}\n\n\n\nstatic int idt82p33_enable(struct ptp_clock_info *ptp,\n\t\t\t   struct ptp_clock_request *rq, int on)\n{\n\tstruct idt82p33_channel *channel =\n\t\t\tcontainer_of(ptp, struct idt82p33_channel, caps);\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tint err = -EOPNOTSUPP;\n\n\tmutex_lock(idt82p33->lock);\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_PEROUT:\n\t\tif (!on)\n\t\t\terr = idt82p33_perout_enable(channel, false,\n\t\t\t\t\t\t     &rq->perout);\n\t\t \n\t\telse if (rq->perout.start.nsec || rq->perout.period.sec != 1 ||\n\t\t\t rq->perout.period.nsec)\n\t\t\terr = -ERANGE;\n\t\telse\n\t\t\terr = idt82p33_perout_enable(channel, true,\n\t\t\t\t\t\t     &rq->perout);\n\t\tbreak;\n\tcase PTP_CLK_REQ_EXTTS:\n\t\terr = idt82p33_extts_enable(channel, rq, on);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(idt82p33->lock);\n\n\tif (err)\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Failed in %s with err %d!\\n\", __func__, err);\n\treturn err;\n}\n\nstatic s32 idt82p33_getmaxphase(__always_unused struct ptp_clock_info *ptp)\n{\n\treturn WRITE_PHASE_OFFSET_LIMIT;\n}\n\nstatic int idt82p33_adjwritephase(struct ptp_clock_info *ptp, s32 offset_ns)\n{\n\tstruct idt82p33_channel *channel =\n\t\tcontainer_of(ptp, struct idt82p33_channel, caps);\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\ts64 offset_regval;\n\tu8 val[4] = {0};\n\tint err;\n\n\t \n\toffset_regval = div_s64((s64)(-offset_ns) * 1000000000ll,\n\t\t\t\tIDT_T0DPLL_PHASE_RESOL);\n\n\tval[0] = offset_regval & 0xFF;\n\tval[1] = (offset_regval >> 8) & 0xFF;\n\tval[2] = (offset_regval >> 16) & 0xFF;\n\tval[3] = (offset_regval >> 24) & 0x1F;\n\tval[3] |= PH_OFFSET_EN;\n\n\tmutex_lock(idt82p33->lock);\n\n\terr = idt82p33_dpll_set_mode(channel, PLL_MODE_WPH);\n\tif (err) {\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Failed in %s with err %d!\\n\", __func__, err);\n\t\tgoto out;\n\t}\n\n\terr = idt82p33_write(idt82p33, channel->dpll_phase_cnfg, val,\n\t\t\t     sizeof(val));\n\nout:\n\tmutex_unlock(idt82p33->lock);\n\treturn err;\n}\n\nstatic int idt82p33_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct idt82p33_channel *channel =\n\t\t\tcontainer_of(ptp, struct idt82p33_channel, caps);\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tint err;\n\n\tif (channel->ddco == true)\n\t\treturn 0;\n\n\tif (scaled_ppm == channel->current_freq)\n\t\treturn 0;\n\n\tmutex_lock(idt82p33->lock);\n\terr = _idt82p33_adjfine(channel, scaled_ppm);\n\n\tif (err == 0)\n\t\tchannel->current_freq = scaled_ppm;\n\tmutex_unlock(idt82p33->lock);\n\n\tif (err)\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Failed in %s with err %d!\\n\", __func__, err);\n\treturn err;\n}\n\nstatic int idt82p33_adjtime(struct ptp_clock_info *ptp, s64 delta_ns)\n{\n\tstruct idt82p33_channel *channel =\n\t\t\tcontainer_of(ptp, struct idt82p33_channel, caps);\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tint err;\n\n\tif (channel->ddco == true)\n\t\treturn -EBUSY;\n\n\tmutex_lock(idt82p33->lock);\n\n\tif (abs(delta_ns) < phase_snap_threshold) {\n\t\terr = idt82p33_start_ddco(channel, delta_ns);\n\t\tmutex_unlock(idt82p33->lock);\n\t\treturn err;\n\t}\n\n\t \n\terr = _idt82p33_adjtime_internal_triggered(channel, delta_ns);\n\tif (err && delta_ns > IMMEDIATE_SNAP_THRESHOLD_NS)\n\t\terr = _idt82p33_adjtime_immediate(channel, delta_ns);\n\n\tmutex_unlock(idt82p33->lock);\n\n\tif (err)\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Failed in %s with err %d!\\n\", __func__, err);\n\treturn err;\n}\n\nstatic int idt82p33_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct idt82p33_channel *channel =\n\t\t\tcontainer_of(ptp, struct idt82p33_channel, caps);\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tint err;\n\n\tmutex_lock(idt82p33->lock);\n\terr = _idt82p33_gettime(channel, ts);\n\tmutex_unlock(idt82p33->lock);\n\n\tif (err)\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Failed in %s with err %d!\\n\", __func__, err);\n\treturn err;\n}\n\nstatic int idt82p33_settime(struct ptp_clock_info *ptp,\n\t\t\t    const struct timespec64 *ts)\n{\n\tstruct idt82p33_channel *channel =\n\t\t\tcontainer_of(ptp, struct idt82p33_channel, caps);\n\tstruct idt82p33 *idt82p33 = channel->idt82p33;\n\tint err;\n\n\tmutex_lock(idt82p33->lock);\n\terr = _idt82p33_settime(channel, ts);\n\tmutex_unlock(idt82p33->lock);\n\n\tif (err)\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Failed in %s with err %d!\\n\", __func__, err);\n\treturn err;\n}\n\nstatic int idt82p33_channel_init(struct idt82p33 *idt82p33, u32 index)\n{\n\tstruct idt82p33_channel *channel = &idt82p33->channel[index];\n\n\tswitch (index) {\n\tcase 0:\n\t\tchannel->dpll_tod_cnfg = DPLL1_TOD_CNFG;\n\t\tchannel->dpll_tod_trigger = DPLL1_TOD_TRIGGER;\n\t\tchannel->dpll_tod_sts = DPLL1_TOD_STS;\n\t\tchannel->dpll_mode_cnfg = DPLL1_OPERATING_MODE_CNFG;\n\t\tchannel->dpll_freq_cnfg = DPLL1_HOLDOVER_FREQ_CNFG;\n\t\tchannel->dpll_phase_cnfg = DPLL1_PHASE_OFFSET_CNFG;\n\t\tchannel->dpll_sync_cnfg = DPLL1_SYNC_EDGE_CNFG;\n\t\tchannel->dpll_input_mode_cnfg = DPLL1_INPUT_MODE_CNFG;\n\t\tbreak;\n\tcase 1:\n\t\tchannel->dpll_tod_cnfg = DPLL2_TOD_CNFG;\n\t\tchannel->dpll_tod_trigger = DPLL2_TOD_TRIGGER;\n\t\tchannel->dpll_tod_sts = DPLL2_TOD_STS;\n\t\tchannel->dpll_mode_cnfg = DPLL2_OPERATING_MODE_CNFG;\n\t\tchannel->dpll_freq_cnfg = DPLL2_HOLDOVER_FREQ_CNFG;\n\t\tchannel->dpll_phase_cnfg = DPLL2_PHASE_OFFSET_CNFG;\n\t\tchannel->dpll_sync_cnfg = DPLL2_SYNC_EDGE_CNFG;\n\t\tchannel->dpll_input_mode_cnfg = DPLL2_INPUT_MODE_CNFG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tchannel->plln = index;\n\tchannel->current_freq = 0;\n\tchannel->idt82p33 = idt82p33;\n\tINIT_DELAYED_WORK(&channel->adjtime_work, idt82p33_adjtime_workaround);\n\n\treturn 0;\n}\n\nstatic int idt82p33_verify_pin(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t       enum ptp_pin_function func, unsigned int chan)\n{\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_EXTTS:\n\t\tbreak;\n\tcase PTP_PF_PEROUT:\n\tcase PTP_PF_PHYSYNC:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void idt82p33_caps_init(u32 index, struct ptp_clock_info *caps,\n\t\t\t       struct ptp_pin_desc *pin_cfg, u8 max_pins)\n{\n\tstruct ptp_pin_desc *ppd;\n\tint i;\n\n\tcaps->owner = THIS_MODULE;\n\tcaps->max_adj = DCO_MAX_PPB;\n\tcaps->n_per_out = MAX_PER_OUT;\n\tcaps->n_ext_ts = MAX_PHC_PLL,\n\tcaps->n_pins = max_pins,\n\tcaps->adjphase = idt82p33_adjwritephase,\n\tcaps->getmaxphase = idt82p33_getmaxphase,\n\tcaps->adjfine = idt82p33_adjfine;\n\tcaps->adjtime = idt82p33_adjtime;\n\tcaps->gettime64 = idt82p33_gettime;\n\tcaps->settime64 = idt82p33_settime;\n\tcaps->enable = idt82p33_enable;\n\tcaps->verify = idt82p33_verify_pin;\n\tcaps->do_aux_work = idt82p33_work_handler;\n\n\tsnprintf(caps->name, sizeof(caps->name), \"IDT 82P33 PLL%u\", index);\n\n\tcaps->pin_config = pin_cfg;\n\n\tfor (i = 0; i < max_pins; ++i) {\n\t\tppd = &pin_cfg[i];\n\n\t\tppd->index = i;\n\t\tppd->func = PTP_PF_NONE;\n\t\tppd->chan = index;\n\t\tsnprintf(ppd->name, sizeof(ppd->name), \"in%d\", 12 + i);\n\t}\n}\n\nstatic int idt82p33_enable_channel(struct idt82p33 *idt82p33, u32 index)\n{\n\tstruct idt82p33_channel *channel;\n\tint err;\n\n\tif (!(index < MAX_PHC_PLL))\n\t\treturn -EINVAL;\n\n\tchannel = &idt82p33->channel[index];\n\n\terr = idt82p33_channel_init(idt82p33, index);\n\tif (err) {\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Channel_init failed in %s with err %d!\\n\",\n\t\t\t__func__, err);\n\t\treturn err;\n\t}\n\n\tidt82p33_caps_init(index, &channel->caps,\n\t\t\t   pin_config[index], MAX_TRIG_CLK);\n\n\tchannel->ptp_clock = ptp_clock_register(&channel->caps, NULL);\n\n\tif (IS_ERR(channel->ptp_clock)) {\n\t\terr = PTR_ERR(channel->ptp_clock);\n\t\tchannel->ptp_clock = NULL;\n\t\treturn err;\n\t}\n\n\tif (!channel->ptp_clock)\n\t\treturn -ENOTSUPP;\n\n\terr = idt82p33_dpll_set_mode(channel, PLL_MODE_DCO);\n\tif (err) {\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Dpll_set_mode failed in %s with err %d!\\n\",\n\t\t\t__func__, err);\n\t\treturn err;\n\t}\n\n\terr = idt82p33_enable_tod(channel);\n\tif (err) {\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Enable_tod failed in %s with err %d!\\n\",\n\t\t\t__func__, err);\n\t\treturn err;\n\t}\n\n\tdev_info(idt82p33->dev, \"PLL%d registered as ptp%d\\n\",\n\t\t index, channel->ptp_clock->index);\n\n\treturn 0;\n}\n\nstatic int idt82p33_reset(struct idt82p33 *idt82p33, bool cold)\n{\n\tint err;\n\tu8 cfg = SOFT_RESET_EN;\n\n\tif (cold == true)\n\t\tgoto cold_reset;\n\n\terr = idt82p33_read(idt82p33, REG_SOFT_RESET, &cfg, sizeof(cfg));\n\tif (err) {\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Soft reset failed with err %d!\\n\", err);\n\t\treturn err;\n\t}\n\n\tcfg |= SOFT_RESET_EN;\n\ncold_reset:\n\terr = idt82p33_write(idt82p33, REG_SOFT_RESET, &cfg, sizeof(cfg));\n\tif (err)\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Cold reset failed with err %d!\\n\", err);\n\treturn err;\n}\n\nstatic int idt82p33_load_firmware(struct idt82p33 *idt82p33)\n{\n\tchar fname[128] = FW_FILENAME;\n\tconst struct firmware *fw;\n\tstruct idt82p33_fwrc *rec;\n\tu8 loaddr, page, val;\n\tint err;\n\ts32 len;\n\n\tif (firmware)  \n\t\tsnprintf(fname, sizeof(fname), \"%s\", firmware);\n\n\tdev_info(idt82p33->dev, \"requesting firmware '%s'\\n\", fname);\n\n\terr = request_firmware(&fw, fname, idt82p33->dev);\n\n\tif (err) {\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"Failed in %s with err %d!\\n\", __func__, err);\n\t\treturn err;\n\t}\n\n\tdev_dbg(idt82p33->dev, \"firmware size %zu bytes\\n\", fw->size);\n\n\trec = (struct idt82p33_fwrc *) fw->data;\n\n\tfor (len = fw->size; len > 0; len -= sizeof(*rec)) {\n\n\t\tif (rec->reserved) {\n\t\t\tdev_err(idt82p33->dev,\n\t\t\t\t\"bad firmware, reserved field non-zero\\n\");\n\t\t\terr = -EINVAL;\n\t\t} else {\n\t\t\tval = rec->value;\n\t\t\tloaddr = rec->loaddr;\n\t\t\tpage = rec->hiaddr;\n\n\t\t\trec++;\n\n\t\t\terr = idt82p33_check_and_set_masks(idt82p33, page,\n\t\t\t\t\t\t\t   loaddr, val);\n\t\t}\n\n\t\tif (err == 0) {\n\t\t\t \n\t\t\tif (loaddr > 0x7b)\n\t\t\t\tcontinue;\n\n\t\t\terr = idt82p33_write(idt82p33, REG_ADDR(page, loaddr),\n\t\t\t\t\t     &val, sizeof(val));\n\t\t}\n\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tidt82p33_display_masks(idt82p33);\nout:\n\trelease_firmware(fw);\n\treturn err;\n}\n\nstatic void idt82p33_extts_check(struct work_struct *work)\n{\n\tstruct idt82p33 *idt82p33 = container_of(work, struct idt82p33,\n\t\t\t\t\t\t extts_work.work);\n\tstruct idt82p33_channel *channel;\n\tint err;\n\tu8 mask;\n\tint i;\n\n\tif (idt82p33->extts_mask == 0)\n\t\treturn;\n\n\tmutex_lock(idt82p33->lock);\n\n\tfor (i = 0; i < MAX_PHC_PLL; i++) {\n\t\tmask = 1 << i;\n\n\t\tif ((idt82p33->extts_mask & mask) == 0)\n\t\t\tcontinue;\n\n\t\terr = idt82p33_extts_check_channel(idt82p33, i);\n\n\t\tif (err == 0) {\n\t\t\t \n\t\t\tif (idt82p33->extts_single_shot) {\n\t\t\t\tidt82p33->extts_mask &= ~mask;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tchannel = &idt82p33->channel[i];\n\t\t\t\tarm_tod_read_with_trigger(channel, channel->tod_trigger);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (idt82p33->extts_mask)\n\t\tschedule_delayed_work(&idt82p33->extts_work,\n\t\t\t\t      msecs_to_jiffies(EXTTS_PERIOD_MS));\n\n\tmutex_unlock(idt82p33->lock);\n}\n\nstatic int idt82p33_probe(struct platform_device *pdev)\n{\n\tstruct rsmu_ddata *ddata = dev_get_drvdata(pdev->dev.parent);\n\tstruct idt82p33 *idt82p33;\n\tint err;\n\tu8 i;\n\n\tidt82p33 = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(struct idt82p33), GFP_KERNEL);\n\tif (!idt82p33)\n\t\treturn -ENOMEM;\n\n\tidt82p33->dev = &pdev->dev;\n\tidt82p33->mfd = pdev->dev.parent;\n\tidt82p33->lock = &ddata->lock;\n\tidt82p33->regmap = ddata->regmap;\n\tidt82p33->tod_write_overhead_ns = 0;\n\tidt82p33->calculate_overhead_flag = 0;\n\tidt82p33->pll_mask = DEFAULT_PLL_MASK;\n\tidt82p33->channel[0].output_mask = DEFAULT_OUTPUT_MASK_PLL0;\n\tidt82p33->channel[1].output_mask = DEFAULT_OUTPUT_MASK_PLL1;\n\tidt82p33->extts_mask = 0;\n\tINIT_DELAYED_WORK(&idt82p33->extts_work, idt82p33_extts_check);\n\n\tmutex_lock(idt82p33->lock);\n\n\t \n\tidt82p33_reset(idt82p33, true);\n\n\terr = idt82p33_load_firmware(idt82p33);\n\tif (err)\n\t\tdev_warn(idt82p33->dev,\n\t\t\t \"loading firmware failed with %d\\n\", err);\n\n\t \n\tidt82p33_reset(idt82p33, false);\n\n\tif (idt82p33->pll_mask) {\n\t\tfor (i = 0; i < MAX_PHC_PLL; i++) {\n\t\t\tif (idt82p33->pll_mask & (1 << i))\n\t\t\t\terr = idt82p33_enable_channel(idt82p33, i);\n\t\t\telse\n\t\t\t\terr = idt82p33_channel_init(idt82p33, i);\n\t\t\tif (err) {\n\t\t\t\tdev_err(idt82p33->dev,\n\t\t\t\t\t\"Failed in %s with err %d!\\n\",\n\t\t\t\t\t__func__, err);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev_err(idt82p33->dev,\n\t\t\t\"no PLLs flagged as PHCs, nothing to do\\n\");\n\t\terr = -ENODEV;\n\t}\n\n\tmutex_unlock(idt82p33->lock);\n\n\tif (err) {\n\t\tidt82p33_ptp_clock_unregister_all(idt82p33);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, idt82p33);\n\n\treturn 0;\n}\n\nstatic int idt82p33_remove(struct platform_device *pdev)\n{\n\tstruct idt82p33 *idt82p33 = platform_get_drvdata(pdev);\n\n\tcancel_delayed_work_sync(&idt82p33->extts_work);\n\n\tidt82p33_ptp_clock_unregister_all(idt82p33);\n\n\treturn 0;\n}\n\nstatic struct platform_driver idt82p33_driver = {\n\t.driver = {\n\t\t.name = \"82p33x1x-phc\",\n\t},\n\t.probe = idt82p33_probe,\n\t.remove\t= idt82p33_remove,\n};\n\nmodule_platform_driver(idt82p33_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}