{
  "module_name": "ptp_ines.c",
  "hash_id": "7beb50b4a460654c31d4ac7f0cc0698c4044f8083faa2377c8b07018aa7dc46b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_ines.c",
  "human_readable_source": "\n\n\n\n\n#define pr_fmt(fmt) \"InES_PTP: \" fmt\n\n#include <linux/ethtool.h>\n#include <linux/export.h>\n#include <linux/if_vlan.h>\n#include <linux/mii_timestamper.h>\n#include <linux/module.h>\n#include <linux/net_tstamp.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/ptp_classify.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/stddef.h>\n\nMODULE_DESCRIPTION(\"Driver for the ZHAW InES PTP time stamping IP core\");\nMODULE_AUTHOR(\"Richard Cochran <richardcochran@gmail.com>\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define MCAST_MAC_SELECT_SHIFT\t2\n#define MCAST_MAC_SELECT_MASK\t0x3\n#define IO_RESET\t\tBIT(1)\n#define PTP_RESET\t\tBIT(0)\n\n \n#define IF_MAJOR_VER_SHIFT\t12\n#define IF_MAJOR_VER_MASK\t0xf\n#define IF_MINOR_VER_SHIFT\t8\n#define IF_MINOR_VER_MASK\t0xf\n#define FPGA_MAJOR_VER_SHIFT\t4\n#define FPGA_MAJOR_VER_MASK\t0xf\n#define FPGA_MINOR_VER_SHIFT\t0\n#define FPGA_MINOR_VER_MASK\t0xf\n\n \n#define RX_INTR_STATUS_3\tBIT(5)\n#define RX_INTR_STATUS_2\tBIT(4)\n#define RX_INTR_STATUS_1\tBIT(3)\n#define TX_INTR_STATUS_3\tBIT(2)\n#define TX_INTR_STATUS_2\tBIT(1)\n#define TX_INTR_STATUS_1\tBIT(0)\n\n \n#define RX_INTR_MASK_3\t\tBIT(5)\n#define RX_INTR_MASK_2\t\tBIT(4)\n#define RX_INTR_MASK_1\t\tBIT(3)\n#define TX_INTR_MASK_3\t\tBIT(2)\n#define TX_INTR_MASK_2\t\tBIT(1)\n#define TX_INTR_MASK_1\t\tBIT(0)\n\n \n#define RX_FIFO_NE_3\t\tBIT(5)\n#define RX_FIFO_NE_2\t\tBIT(4)\n#define RX_FIFO_NE_1\t\tBIT(3)\n#define TX_FIFO_NE_3\t\tBIT(2)\n#define TX_FIFO_NE_2\t\tBIT(1)\n#define TX_FIFO_NE_1\t\tBIT(0)\n\n \n#define CM_ONE_STEP\t\tBIT(6)\n#define PHY_SPEED_SHIFT\t\t4\n#define PHY_SPEED_MASK\t\t0x3\n#define P2P_DELAY_WR_POS_SHIFT\t2\n#define P2P_DELAY_WR_POS_MASK\t0x3\n#define PTP_MODE_SHIFT\t\t0\n#define PTP_MODE_MASK\t\t0x3\n\n \n#define TS_ENABLE\t\tBIT(15)\n#define DATA_READ_POS_SHIFT\t8\n#define DATA_READ_POS_MASK\t0x1f\n#define DISCARDED_EVENTS_SHIFT\t4\n#define DISCARDED_EVENTS_MASK\t0xf\n\n#define INES_N_PORTS\t\t3\n#define INES_REGISTER_SIZE\t0x80\n#define INES_PORT_OFFSET\t0x20\n#define INES_PORT_SIZE\t\t0x20\n#define INES_FIFO_DEPTH\t\t90\n#define INES_MAX_EVENTS\t\t100\n\n#define BC_PTP_V1\t\t0\n#define BC_PTP_V2\t\t1\n#define TC_E2E_PTP_V2\t\t2\n#define TC_P2P_PTP_V2\t\t3\n\n#define PHY_SPEED_10\t\t0\n#define PHY_SPEED_100\t\t1\n#define PHY_SPEED_1000\t\t2\n\n#define PORT_CONF \\\n\t((PHY_SPEED_1000 << PHY_SPEED_SHIFT) | (BC_PTP_V2 << PTP_MODE_SHIFT))\n\n#define ines_read32(s, r)\t__raw_readl((void __iomem *)&s->regs->r)\n#define ines_write32(s, v, r)\t__raw_writel(v, (void __iomem *)&s->regs->r)\n\n#define MESSAGE_TYPE_SYNC\t\t1\n#define MESSAGE_TYPE_P_DELAY_REQ\t2\n#define MESSAGE_TYPE_P_DELAY_RESP\t3\n#define MESSAGE_TYPE_DELAY_REQ\t\t4\n\nstatic LIST_HEAD(ines_clocks);\nstatic DEFINE_MUTEX(ines_clocks_lock);\n\nstruct ines_global_regs {\n\tu32 id;\n\tu32 test;\n\tu32 global;\n\tu32 version;\n\tu32 test2;\n\tu32 int_stat;\n\tu32 int_msk;\n\tu32 buf_stat;\n};\n\nstruct ines_port_registers {\n\tu32 port_conf;\n\tu32 p_delay;\n\tu32 ts_stat_tx;\n\tu32 ts_stat_rx;\n\tu32 ts_tx;\n\tu32 ts_rx;\n};\n\nstruct ines_timestamp {\n\tstruct list_head list;\n\tunsigned long\ttmo;\n\tu16\t\ttag;\n\tu64\t\tsec;\n\tu64\t\tnsec;\n\tu64\t\tclkid;\n\tu16\t\tportnum;\n\tu16\t\tseqid;\n};\n\nstruct ines_port {\n\tstruct ines_port_registers\t*regs;\n\tstruct mii_timestamper\t\tmii_ts;\n\tstruct ines_clock\t\t*clock;\n\tbool\t\t\t\trxts_enabled;\n\tbool\t\t\t\ttxts_enabled;\n\tunsigned int\t\t\tindex;\n\tstruct delayed_work\t\tts_work;\n\t \n\tspinlock_t\t\t\tlock;\n\tstruct sk_buff\t\t\t*tx_skb;\n\tstruct list_head\t\tevents;\n\tstruct list_head\t\tpool;\n\tstruct ines_timestamp\t\tpool_data[INES_MAX_EVENTS];\n};\n\nstruct ines_clock {\n\tstruct ines_port\t\tport[INES_N_PORTS];\n\tstruct ines_global_regs __iomem\t*regs;\n\tvoid __iomem\t\t\t*base;\n\tstruct device_node\t\t*node;\n\tstruct device\t\t\t*dev;\n\tstruct list_head\t\tlist;\n};\n\nstatic bool ines_match(struct sk_buff *skb, unsigned int ptp_class,\n\t\t       struct ines_timestamp *ts, struct device *dev);\nstatic int ines_rxfifo_read(struct ines_port *port);\nstatic u64 ines_rxts64(struct ines_port *port, unsigned int words);\nstatic bool ines_timestamp_expired(struct ines_timestamp *ts);\nstatic u64 ines_txts64(struct ines_port *port, unsigned int words);\nstatic void ines_txtstamp_work(struct work_struct *work);\nstatic bool is_sync_pdelay_resp(struct sk_buff *skb, int type);\nstatic u8 tag_to_msgtype(u8 tag);\n\nstatic void ines_clock_cleanup(struct ines_clock *clock)\n{\n\tstruct ines_port *port;\n\tint i;\n\n\tfor (i = 0; i < INES_N_PORTS; i++) {\n\t\tport = &clock->port[i];\n\t\tcancel_delayed_work_sync(&port->ts_work);\n\t}\n}\n\nstatic int ines_clock_init(struct ines_clock *clock, struct device *device,\n\t\t\t   void __iomem *addr)\n{\n\tstruct device_node *node = device->of_node;\n\tunsigned long port_addr;\n\tstruct ines_port *port;\n\tint i, j;\n\n\tINIT_LIST_HEAD(&clock->list);\n\tclock->node = node;\n\tclock->dev  = device;\n\tclock->base = addr;\n\tclock->regs = clock->base;\n\n\tfor (i = 0; i < INES_N_PORTS; i++) {\n\t\tport = &clock->port[i];\n\t\tport_addr = (unsigned long) clock->base +\n\t\t\tINES_PORT_OFFSET + i * INES_PORT_SIZE;\n\t\tport->regs = (struct ines_port_registers *) port_addr;\n\t\tport->clock = clock;\n\t\tport->index = i;\n\t\tINIT_DELAYED_WORK(&port->ts_work, ines_txtstamp_work);\n\t\tspin_lock_init(&port->lock);\n\t\tINIT_LIST_HEAD(&port->events);\n\t\tINIT_LIST_HEAD(&port->pool);\n\t\tfor (j = 0; j < INES_MAX_EVENTS; j++)\n\t\t\tlist_add(&port->pool_data[j].list, &port->pool);\n\t}\n\n\tines_write32(clock, 0xBEEF, test);\n\tines_write32(clock, 0xBEEF, test2);\n\n\tdev_dbg(device, \"ID      0x%x\\n\", ines_read32(clock, id));\n\tdev_dbg(device, \"TEST    0x%x\\n\", ines_read32(clock, test));\n\tdev_dbg(device, \"VERSION 0x%x\\n\", ines_read32(clock, version));\n\tdev_dbg(device, \"TEST2   0x%x\\n\", ines_read32(clock, test2));\n\n\tfor (i = 0; i < INES_N_PORTS; i++) {\n\t\tport = &clock->port[i];\n\t\tines_write32(port, PORT_CONF, port_conf);\n\t}\n\n\treturn 0;\n}\n\nstatic struct ines_port *ines_find_port(struct device_node *node, u32 index)\n{\n\tstruct ines_port *port = NULL;\n\tstruct ines_clock *clock;\n\tstruct list_head *this;\n\n\tmutex_lock(&ines_clocks_lock);\n\tlist_for_each(this, &ines_clocks) {\n\t\tclock = list_entry(this, struct ines_clock, list);\n\t\tif (clock->node == node) {\n\t\t\tport = &clock->port[index];\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ines_clocks_lock);\n\treturn port;\n}\n\nstatic u64 ines_find_rxts(struct ines_port *port, struct sk_buff *skb, int type)\n{\n\tstruct list_head *this, *next;\n\tstruct ines_timestamp *ts;\n\tunsigned long flags;\n\tu64 ns = 0;\n\n\tif (type == PTP_CLASS_NONE)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tines_rxfifo_read(port);\n\tlist_for_each_safe(this, next, &port->events) {\n\t\tts = list_entry(this, struct ines_timestamp, list);\n\t\tif (ines_timestamp_expired(ts)) {\n\t\t\tlist_del_init(&ts->list);\n\t\t\tlist_add(&ts->list, &port->pool);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ines_match(skb, type, ts, port->clock->dev)) {\n\t\t\tns = ts->sec * 1000000000ULL + ts->nsec;\n\t\t\tlist_del_init(&ts->list);\n\t\t\tlist_add(&ts->list, &port->pool);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn ns;\n}\n\nstatic u64 ines_find_txts(struct ines_port *port, struct sk_buff *skb)\n{\n\tunsigned int class = ptp_classify_raw(skb), i;\n\tu32 data_rd_pos, buf_stat, mask, ts_stat_tx;\n\tstruct ines_timestamp ts;\n\tunsigned long flags;\n\tu64 ns = 0;\n\n\tmask = TX_FIFO_NE_1 << port->index;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tfor (i = 0; i < INES_FIFO_DEPTH; i++) {\n\n\t\tbuf_stat = ines_read32(port->clock, buf_stat);\n\t\tif (!(buf_stat & mask)) {\n\t\t\tdev_dbg(port->clock->dev,\n\t\t\t\t  \"Tx timestamp FIFO unexpectedly empty\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tts_stat_tx = ines_read32(port, ts_stat_tx);\n\t\tdata_rd_pos = (ts_stat_tx >> DATA_READ_POS_SHIFT) &\n\t\t\tDATA_READ_POS_MASK;\n\t\tif (data_rd_pos) {\n\t\t\tdev_err(port->clock->dev,\n\t\t\t\t\"unexpected Tx read pos %u\\n\", data_rd_pos);\n\t\t\tbreak;\n\t\t}\n\n\t\tts.tag     = ines_read32(port, ts_tx);\n\t\tts.sec     = ines_txts64(port, 3);\n\t\tts.nsec    = ines_txts64(port, 2);\n\t\tts.clkid   = ines_txts64(port, 4);\n\t\tts.portnum = ines_read32(port, ts_tx);\n\t\tts.seqid   = ines_read32(port, ts_tx);\n\n\t\tif (ines_match(skb, class, &ts, port->clock->dev)) {\n\t\t\tns = ts.sec * 1000000000ULL + ts.nsec;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\treturn ns;\n}\n\nstatic int ines_hwtstamp(struct mii_timestamper *mii_ts, struct ifreq *ifr)\n{\n\tstruct ines_port *port = container_of(mii_ts, struct ines_port, mii_ts);\n\tu32 cm_one_step = 0, port_conf, ts_stat_rx, ts_stat_tx;\n\tstruct hwtstamp_config cfg;\n\tunsigned long flags;\n\n\tif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\tswitch (cfg.tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\tts_stat_tx = 0;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tts_stat_tx = TS_ENABLE;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ONESTEP_P2P:\n\t\tts_stat_tx = TS_ENABLE;\n\t\tcm_one_step = CM_ONE_STEP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (cfg.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tts_stat_rx = 0;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_ALL:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\treturn -ERANGE;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tts_stat_rx = TS_ENABLE;\n\t\tcfg.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tport_conf = ines_read32(port, port_conf);\n\tport_conf &= ~CM_ONE_STEP;\n\tport_conf |= cm_one_step;\n\n\tines_write32(port, port_conf, port_conf);\n\tines_write32(port, ts_stat_rx, ts_stat_rx);\n\tines_write32(port, ts_stat_tx, ts_stat_tx);\n\n\tport->rxts_enabled = ts_stat_rx == TS_ENABLE;\n\tport->txts_enabled = ts_stat_tx == TS_ENABLE;\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\n}\n\nstatic void ines_link_state(struct mii_timestamper *mii_ts,\n\t\t\t    struct phy_device *phydev)\n{\n\tstruct ines_port *port = container_of(mii_ts, struct ines_port, mii_ts);\n\tu32 port_conf, speed_conf;\n\tunsigned long flags;\n\n\tswitch (phydev->speed) {\n\tcase SPEED_10:\n\t\tspeed_conf = PHY_SPEED_10 << PHY_SPEED_SHIFT;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tspeed_conf = PHY_SPEED_100 << PHY_SPEED_SHIFT;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tspeed_conf = PHY_SPEED_1000 << PHY_SPEED_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(port->clock->dev, \"bad speed: %d\\n\", phydev->speed);\n\t\treturn;\n\t}\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tport_conf = ines_read32(port, port_conf);\n\tport_conf &= ~(0x3 << PHY_SPEED_SHIFT);\n\tport_conf |= speed_conf;\n\n\tines_write32(port, port_conf, port_conf);\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic bool ines_match(struct sk_buff *skb, unsigned int ptp_class,\n\t\t       struct ines_timestamp *ts, struct device *dev)\n{\n\tstruct ptp_header *hdr;\n\tu16 portn, seqid;\n\tu8 msgtype;\n\tu64 clkid;\n\n\tif (unlikely(ptp_class & PTP_CLASS_V1))\n\t\treturn false;\n\n\thdr = ptp_parse_header(skb, ptp_class);\n\tif (!hdr)\n\t\treturn false;\n\n\tmsgtype = ptp_get_msgtype(hdr, ptp_class);\n\tclkid = be64_to_cpup((__be64 *)&hdr->source_port_identity.clock_identity.id[0]);\n\tportn = be16_to_cpu(hdr->source_port_identity.port_number);\n\tseqid = be16_to_cpu(hdr->sequence_id);\n\n\tif (tag_to_msgtype(ts->tag & 0x7) != msgtype) {\n\t\tdev_dbg(dev, \"msgtype mismatch ts %hhu != skb %hhu\\n\",\n\t\t\ttag_to_msgtype(ts->tag & 0x7), msgtype);\n\t\treturn false;\n\t}\n\tif (ts->clkid != clkid) {\n\t\tdev_dbg(dev, \"clkid mismatch ts %llx != skb %llx\\n\",\n\t\t\tts->clkid, clkid);\n\t\treturn false;\n\t}\n\tif (ts->portnum != portn) {\n\t\tdev_dbg(dev, \"portn mismatch ts %hu != skb %hu\\n\",\n\t\t\tts->portnum, portn);\n\t\treturn false;\n\t}\n\tif (ts->seqid != seqid) {\n\t\tdev_dbg(dev, \"seqid mismatch ts %hu != skb %hu\\n\",\n\t\t\tts->seqid, seqid);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool ines_rxtstamp(struct mii_timestamper *mii_ts,\n\t\t\t  struct sk_buff *skb, int type)\n{\n\tstruct ines_port *port = container_of(mii_ts, struct ines_port, mii_ts);\n\tstruct skb_shared_hwtstamps *ssh;\n\tu64 ns;\n\n\tif (!port->rxts_enabled)\n\t\treturn false;\n\n\tns = ines_find_rxts(port, skb, type);\n\tif (!ns)\n\t\treturn false;\n\n\tssh = skb_hwtstamps(skb);\n\tssh->hwtstamp = ns_to_ktime(ns);\n\tnetif_rx(skb);\n\n\treturn true;\n}\n\nstatic int ines_rxfifo_read(struct ines_port *port)\n{\n\tu32 data_rd_pos, buf_stat, mask, ts_stat_rx;\n\tstruct ines_timestamp *ts;\n\tunsigned int i;\n\n\tmask = RX_FIFO_NE_1 << port->index;\n\n\tfor (i = 0; i < INES_FIFO_DEPTH; i++) {\n\t\tif (list_empty(&port->pool)) {\n\t\t\tdev_err(port->clock->dev, \"event pool is empty\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tbuf_stat = ines_read32(port->clock, buf_stat);\n\t\tif (!(buf_stat & mask))\n\t\t\tbreak;\n\n\t\tts_stat_rx = ines_read32(port, ts_stat_rx);\n\t\tdata_rd_pos = (ts_stat_rx >> DATA_READ_POS_SHIFT) &\n\t\t\tDATA_READ_POS_MASK;\n\t\tif (data_rd_pos) {\n\t\t\tdev_err(port->clock->dev, \"unexpected Rx read pos %u\\n\",\n\t\t\t\tdata_rd_pos);\n\t\t\tbreak;\n\t\t}\n\n\t\tts = list_first_entry(&port->pool, struct ines_timestamp, list);\n\t\tts->tmo     = jiffies + HZ;\n\t\tts->tag     = ines_read32(port, ts_rx);\n\t\tts->sec     = ines_rxts64(port, 3);\n\t\tts->nsec    = ines_rxts64(port, 2);\n\t\tts->clkid   = ines_rxts64(port, 4);\n\t\tts->portnum = ines_read32(port, ts_rx);\n\t\tts->seqid   = ines_read32(port, ts_rx);\n\n\t\tlist_del_init(&ts->list);\n\t\tlist_add_tail(&ts->list, &port->events);\n\t}\n\n\treturn 0;\n}\n\nstatic u64 ines_rxts64(struct ines_port *port, unsigned int words)\n{\n\tunsigned int i;\n\tu64 result;\n\tu16 word;\n\n\tword = ines_read32(port, ts_rx);\n\tresult = word;\n\twords--;\n\tfor (i = 0; i < words; i++) {\n\t\tword = ines_read32(port, ts_rx);\n\t\tresult <<= 16;\n\t\tresult |= word;\n\t}\n\treturn result;\n}\n\nstatic bool ines_timestamp_expired(struct ines_timestamp *ts)\n{\n\treturn time_after(jiffies, ts->tmo);\n}\n\nstatic int ines_ts_info(struct mii_timestamper *mii_ts,\n\t\t\tstruct ethtool_ts_info *info)\n{\n\tinfo->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tinfo->phc_index = -1;\n\n\tinfo->tx_types =\n\t\t(1 << HWTSTAMP_TX_OFF) |\n\t\t(1 << HWTSTAMP_TX_ON) |\n\t\t(1 << HWTSTAMP_TX_ONESTEP_P2P);\n\n\tinfo->rx_filters =\n\t\t(1 << HWTSTAMP_FILTER_NONE) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_EVENT);\n\n\treturn 0;\n}\n\nstatic u64 ines_txts64(struct ines_port *port, unsigned int words)\n{\n\tunsigned int i;\n\tu64 result;\n\tu16 word;\n\n\tword = ines_read32(port, ts_tx);\n\tresult = word;\n\twords--;\n\tfor (i = 0; i < words; i++) {\n\t\tword = ines_read32(port, ts_tx);\n\t\tresult <<= 16;\n\t\tresult |= word;\n\t}\n\treturn result;\n}\n\nstatic bool ines_txts_onestep(struct ines_port *port, struct sk_buff *skb, int type)\n{\n\tunsigned long flags;\n\tu32 port_conf;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tport_conf = ines_read32(port, port_conf);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (port_conf & CM_ONE_STEP)\n\t\treturn is_sync_pdelay_resp(skb, type);\n\n\treturn false;\n}\n\nstatic void ines_txtstamp(struct mii_timestamper *mii_ts,\n\t\t\t  struct sk_buff *skb, int type)\n{\n\tstruct ines_port *port = container_of(mii_ts, struct ines_port, mii_ts);\n\tstruct sk_buff *old_skb = NULL;\n\tunsigned long flags;\n\n\tif (!port->txts_enabled || ines_txts_onestep(port, skb, type)) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (port->tx_skb)\n\t\told_skb = port->tx_skb;\n\n\tport->tx_skb = skb;\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tkfree_skb(old_skb);\n\n\tschedule_delayed_work(&port->ts_work, 1);\n}\n\nstatic void ines_txtstamp_work(struct work_struct *work)\n{\n\tstruct ines_port *port =\n\t\tcontainer_of(work, struct ines_port, ts_work.work);\n\tstruct skb_shared_hwtstamps ssh;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tu64 ns;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tskb = port->tx_skb;\n\tport->tx_skb = NULL;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tns = ines_find_txts(port, skb);\n\tif (!ns) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tssh.hwtstamp = ns_to_ktime(ns);\n\tskb_complete_tx_timestamp(skb, &ssh);\n}\n\nstatic bool is_sync_pdelay_resp(struct sk_buff *skb, int type)\n{\n\tstruct ptp_header *hdr;\n\tu8 msgtype;\n\n\thdr = ptp_parse_header(skb, type);\n\tif (!hdr)\n\t\treturn false;\n\n\tmsgtype = ptp_get_msgtype(hdr, type);\n\n\tswitch (msgtype) {\n\tcase PTP_MSGTYPE_SYNC:\n\tcase PTP_MSGTYPE_PDELAY_RESP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic u8 tag_to_msgtype(u8 tag)\n{\n\tswitch (tag) {\n\tcase MESSAGE_TYPE_SYNC:\n\t\treturn PTP_MSGTYPE_SYNC;\n\tcase MESSAGE_TYPE_P_DELAY_REQ:\n\t\treturn PTP_MSGTYPE_PDELAY_REQ;\n\tcase MESSAGE_TYPE_P_DELAY_RESP:\n\t\treturn PTP_MSGTYPE_PDELAY_RESP;\n\tcase MESSAGE_TYPE_DELAY_REQ:\n\t\treturn PTP_MSGTYPE_DELAY_REQ;\n\t}\n\treturn 0xf;\n}\n\nstatic struct mii_timestamper *ines_ptp_probe_channel(struct device *device,\n\t\t\t\t\t\t      unsigned int index)\n{\n\tstruct device_node *node = device->of_node;\n\tstruct ines_port *port;\n\n\tif (index > INES_N_PORTS - 1) {\n\t\tdev_err(device, \"bad port index %u\\n\", index);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tport = ines_find_port(node, index);\n\tif (!port) {\n\t\tdev_err(device, \"missing port index %u\\n\", index);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\tport->mii_ts.rxtstamp = ines_rxtstamp;\n\tport->mii_ts.txtstamp = ines_txtstamp;\n\tport->mii_ts.hwtstamp = ines_hwtstamp;\n\tport->mii_ts.link_state = ines_link_state;\n\tport->mii_ts.ts_info = ines_ts_info;\n\n\treturn &port->mii_ts;\n}\n\nstatic void ines_ptp_release_channel(struct device *device,\n\t\t\t\t     struct mii_timestamper *mii_ts)\n{\n}\n\nstatic struct mii_timestamping_ctrl ines_ctrl = {\n\t.probe_channel = ines_ptp_probe_channel,\n\t.release_channel = ines_ptp_release_channel,\n};\n\nstatic int ines_ptp_ctrl_probe(struct platform_device *pld)\n{\n\tstruct ines_clock *clock;\n\tvoid __iomem *addr;\n\tint err = 0;\n\n\taddr = devm_platform_ioremap_resource(pld, 0);\n\tif (IS_ERR(addr)) {\n\t\terr = PTR_ERR(addr);\n\t\tgoto out;\n\t}\n\tclock = kzalloc(sizeof(*clock), GFP_KERNEL);\n\tif (!clock) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (ines_clock_init(clock, &pld->dev, addr)) {\n\t\tkfree(clock);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\terr = register_mii_tstamp_controller(&pld->dev, &ines_ctrl);\n\tif (err) {\n\t\tkfree(clock);\n\t\tgoto out;\n\t}\n\tmutex_lock(&ines_clocks_lock);\n\tlist_add_tail(&ines_clocks, &clock->list);\n\tmutex_unlock(&ines_clocks_lock);\n\n\tdev_set_drvdata(&pld->dev, clock);\nout:\n\treturn err;\n}\n\nstatic int ines_ptp_ctrl_remove(struct platform_device *pld)\n{\n\tstruct ines_clock *clock = dev_get_drvdata(&pld->dev);\n\n\tunregister_mii_tstamp_controller(&pld->dev);\n\tmutex_lock(&ines_clocks_lock);\n\tlist_del(&clock->list);\n\tmutex_unlock(&ines_clocks_lock);\n\tines_clock_cleanup(clock);\n\tkfree(clock);\n\treturn 0;\n}\n\nstatic const struct of_device_id ines_ptp_ctrl_of_match[] = {\n\t{ .compatible = \"ines,ptp-ctrl\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, ines_ptp_ctrl_of_match);\n\nstatic struct platform_driver ines_ptp_ctrl_driver = {\n\t.probe  = ines_ptp_ctrl_probe,\n\t.remove = ines_ptp_ctrl_remove,\n\t.driver = {\n\t\t.name = \"ines_ptp_ctrl\",\n\t\t.of_match_table = ines_ptp_ctrl_of_match,\n\t},\n};\nmodule_platform_driver(ines_ptp_ctrl_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}