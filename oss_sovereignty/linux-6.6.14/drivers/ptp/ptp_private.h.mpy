{
  "module_name": "ptp_private.h",
  "hash_id": "dad9a463c399e174ffd8ab7b37300fad01118b5eada62c38b0a1dd43530875b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ptp/ptp_private.h",
  "human_readable_source": " \n \n#ifndef _PTP_PRIVATE_H_\n#define _PTP_PRIVATE_H_\n\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/posix-clock.h>\n#include <linux/ptp_clock.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/time.h>\n\n#define PTP_MAX_TIMESTAMPS 128\n#define PTP_BUF_TIMESTAMPS 30\n#define PTP_DEFAULT_MAX_VCLOCKS 20\n\nstruct timestamp_event_queue {\n\tstruct ptp_extts_event buf[PTP_MAX_TIMESTAMPS];\n\tint head;\n\tint tail;\n\tspinlock_t lock;\n};\n\nstruct ptp_clock {\n\tstruct posix_clock clock;\n\tstruct device dev;\n\tstruct ptp_clock_info *info;\n\tdev_t devid;\n\tint index;  \n\tstruct pps_device *pps_source;\n\tlong dialed_frequency;  \n\tstruct timestamp_event_queue tsevq;  \n\tstruct mutex tsevq_mux;  \n\tstruct mutex pincfg_mux;  \n\twait_queue_head_t tsev_wq;\n\tint defunct;  \n\tstruct device_attribute *pin_dev_attr;\n\tstruct attribute **pin_attr;\n\tstruct attribute_group pin_attr_group;\n\t \n\tconst struct attribute_group *pin_attr_groups[2];\n\tstruct kthread_worker *kworker;\n\tstruct kthread_delayed_work aux_work;\n\tunsigned int max_vclocks;\n\tunsigned int n_vclocks;\n\tint *vclock_index;\n\tstruct mutex n_vclocks_mux;  \n\tbool is_virtual_clock;\n\tbool has_cycles;\n};\n\n#define info_to_vclock(d) container_of((d), struct ptp_vclock, info)\n#define cc_to_vclock(d) container_of((d), struct ptp_vclock, cc)\n#define dw_to_vclock(d) container_of((d), struct ptp_vclock, refresh_work)\n\nstruct ptp_vclock {\n\tstruct ptp_clock *pclock;\n\tstruct ptp_clock_info info;\n\tstruct ptp_clock *clock;\n\tstruct hlist_node vclock_hash_node;\n\tstruct cyclecounter cc;\n\tstruct timecounter tc;\n\tstruct mutex lock;\t \n};\n\n \nstatic inline int queue_cnt(const struct timestamp_event_queue *q)\n{\n\t \n\tint cnt = READ_ONCE(q->tail) - READ_ONCE(q->head);\n\treturn cnt < 0 ? PTP_MAX_TIMESTAMPS + cnt : cnt;\n}\n\n \nstatic inline bool ptp_vclock_in_use(struct ptp_clock *ptp)\n{\n\tbool in_use = false;\n\n\tif (mutex_lock_interruptible(&ptp->n_vclocks_mux))\n\t\treturn true;\n\n\tif (!ptp->is_virtual_clock && ptp->n_vclocks)\n\t\tin_use = true;\n\n\tmutex_unlock(&ptp->n_vclocks_mux);\n\n\treturn in_use;\n}\n\n \nstatic inline bool ptp_clock_freerun(struct ptp_clock *ptp)\n{\n\tif (ptp->has_cycles)\n\t\treturn false;\n\n\treturn ptp_vclock_in_use(ptp);\n}\n\nextern struct class *ptp_class;\n\n \n\n \nint ptp_set_pinfunc(struct ptp_clock *ptp, unsigned int pin,\n\t\t    enum ptp_pin_function func, unsigned int chan);\n\nlong ptp_ioctl(struct posix_clock *pc,\n\t       unsigned int cmd, unsigned long arg);\n\nint ptp_open(struct posix_clock *pc, fmode_t fmode);\n\nssize_t ptp_read(struct posix_clock *pc,\n\t\t uint flags, char __user *buf, size_t cnt);\n\n__poll_t ptp_poll(struct posix_clock *pc,\n\t      struct file *fp, poll_table *wait);\n\n \n\nextern const struct attribute_group *ptp_groups[];\n\nint ptp_populate_pin_groups(struct ptp_clock *ptp);\nvoid ptp_cleanup_pin_groups(struct ptp_clock *ptp);\n\nstruct ptp_vclock *ptp_vclock_register(struct ptp_clock *pclock);\nvoid ptp_vclock_unregister(struct ptp_vclock *vclock);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}