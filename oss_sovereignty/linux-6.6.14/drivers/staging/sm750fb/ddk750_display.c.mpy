{
  "module_name": "ddk750_display.c",
  "hash_id": "936f963e3306cc5c0a1f84ca51c3e41fdb5cac213d1551a6768838cf26ee264d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/sm750fb/ddk750_display.c",
  "human_readable_source": "\n#include \"ddk750_reg.h\"\n#include \"ddk750_chip.h\"\n#include \"ddk750_display.h\"\n#include \"ddk750_power.h\"\n#include \"ddk750_dvi.h\"\n\nstatic void set_display_control(int ctrl, int disp_state)\n{\n\t \n\tunsigned long reg, val, reserved;\n\tint cnt = 0;\n\n\tif (!ctrl) {\n\t\treg = PANEL_DISPLAY_CTRL;\n\t\treserved = PANEL_DISPLAY_CTRL_RESERVED_MASK;\n\t} else {\n\t\treg = CRT_DISPLAY_CTRL;\n\t\treserved = CRT_DISPLAY_CTRL_RESERVED_MASK;\n\t}\n\n\tval = peek32(reg);\n\tif (disp_state) {\n\t\t \n\t\tval |= DISPLAY_CTRL_TIMING;\n\t\tpoke32(reg, val);\n\n\t\tval |= DISPLAY_CTRL_PLANE;\n\n\t\t \n\t\tdo {\n\t\t\tcnt++;\n\t\t\tpoke32(reg, val);\n\t\t} while ((peek32(reg) & ~reserved) != (val & ~reserved));\n\t\tpr_debug(\"Set Plane enbit:after tried %d times\\n\", cnt);\n\t} else {\n\t\t \n\t\tval &= ~DISPLAY_CTRL_PLANE;\n\t\tpoke32(reg, val);\n\n\t\tval &= ~DISPLAY_CTRL_TIMING;\n\t\tpoke32(reg, val);\n\t}\n}\n\nstatic void primary_wait_vertical_sync(int delay)\n{\n\tunsigned int status;\n\n\t \n\tif (!(peek32(PANEL_PLL_CTRL) & PLL_CTRL_POWER) ||\n\t    !(peek32(PANEL_DISPLAY_CTRL) & DISPLAY_CTRL_TIMING))\n\t\treturn;\n\n\twhile (delay-- > 0) {\n\t\t \n\t\tdo {\n\t\t\tstatus = peek32(SYSTEM_CTRL);\n\t\t} while (status & SYSTEM_CTRL_PANEL_VSYNC_ACTIVE);\n\n\t\t \n\t\tdo {\n\t\t\tstatus = peek32(SYSTEM_CTRL);\n\t\t} while (!(status & SYSTEM_CTRL_PANEL_VSYNC_ACTIVE));\n\t}\n}\n\nstatic void sw_panel_power_sequence(int disp, int delay)\n{\n\tunsigned int reg;\n\n\t \n\treg = peek32(PANEL_DISPLAY_CTRL);\n\treg |= (disp ? PANEL_DISPLAY_CTRL_FPEN : 0);\n\tpoke32(PANEL_DISPLAY_CTRL, reg);\n\tprimary_wait_vertical_sync(delay);\n\n\treg = peek32(PANEL_DISPLAY_CTRL);\n\treg |= (disp ? PANEL_DISPLAY_CTRL_DATA : 0);\n\tpoke32(PANEL_DISPLAY_CTRL, reg);\n\tprimary_wait_vertical_sync(delay);\n\n\treg = peek32(PANEL_DISPLAY_CTRL);\n\treg |= (disp ? PANEL_DISPLAY_CTRL_VBIASEN : 0);\n\tpoke32(PANEL_DISPLAY_CTRL, reg);\n\tprimary_wait_vertical_sync(delay);\n\n\treg = peek32(PANEL_DISPLAY_CTRL);\n\treg |= (disp ? PANEL_DISPLAY_CTRL_FPEN : 0);\n\tpoke32(PANEL_DISPLAY_CTRL, reg);\n\tprimary_wait_vertical_sync(delay);\n}\n\nvoid ddk750_set_logical_disp_out(enum disp_output output)\n{\n\tunsigned int reg;\n\n\tif (output & PNL_2_USAGE) {\n\t\t \n\t\treg = peek32(PANEL_DISPLAY_CTRL);\n\t\treg &= ~PANEL_DISPLAY_CTRL_SELECT_MASK;\n\t\treg |= (((output & PNL_2_MASK) >> PNL_2_OFFSET) <<\n\t\t\tPANEL_DISPLAY_CTRL_SELECT_SHIFT);\n\t\tpoke32(PANEL_DISPLAY_CTRL, reg);\n\t}\n\n\tif (output & CRT_2_USAGE) {\n\t\t \n\t\treg = peek32(CRT_DISPLAY_CTRL);\n\t\treg &= ~CRT_DISPLAY_CTRL_SELECT_MASK;\n\t\treg |= (((output & CRT_2_MASK) >> CRT_2_OFFSET) <<\n\t\t\tCRT_DISPLAY_CTRL_SELECT_SHIFT);\n\t\t \n\t\treg &= ~CRT_DISPLAY_CTRL_BLANK;\n\t\tpoke32(CRT_DISPLAY_CTRL, reg);\n\t}\n\n\tif (output & PRI_TP_USAGE) {\n\t\t \n\t\tset_display_control(0, (output & PRI_TP_MASK) >> PRI_TP_OFFSET);\n\t}\n\n\tif (output & SEC_TP_USAGE) {\n\t\t \n\t\tset_display_control(1, (output & SEC_TP_MASK) >> SEC_TP_OFFSET);\n\t}\n\n\tif (output & PNL_SEQ_USAGE) {\n\t\t \n\t\tsw_panel_power_sequence((output & PNL_SEQ_MASK) >>\n\t\t\t\t\tPNL_SEQ_OFFSET, 4);\n\t}\n\n\tif (output & DAC_USAGE)\n\t\tset_DAC((output & DAC_MASK) >> DAC_OFFSET);\n\n\tif (output & DPMS_USAGE)\n\t\tddk750_set_dpms((output & DPMS_MASK) >> DPMS_OFFSET);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}