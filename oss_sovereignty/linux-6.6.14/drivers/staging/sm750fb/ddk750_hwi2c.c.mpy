{
  "module_name": "ddk750_hwi2c.c",
  "hash_id": "c4239174785ef099175de90981696bf235bb60bf43d568b1bffe70a022076e4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/sm750fb/ddk750_hwi2c.c",
  "human_readable_source": "\n#define USE_HW_I2C\n#ifdef USE_HW_I2C\n#include \"ddk750_chip.h\"\n#include \"ddk750_reg.h\"\n#include \"ddk750_hwi2c.h\"\n#include \"ddk750_power.h\"\n\n#define MAX_HWI2C_FIFO                  16\n#define HWI2C_WAIT_TIMEOUT              0xF0000\n\nint sm750_hw_i2c_init(unsigned char bus_speed_mode)\n{\n\tunsigned int value;\n\n\t \n\tvalue = peek32(GPIO_MUX);\n\n\tvalue |= (GPIO_MUX_30 | GPIO_MUX_31);\n\tpoke32(GPIO_MUX, value);\n\n\t \n\tsm750_enable_i2c(1);\n\n\t \n\tvalue = peek32(I2C_CTRL) & ~(I2C_CTRL_MODE | I2C_CTRL_EN);\n\tif (bus_speed_mode)\n\t\tvalue |= I2C_CTRL_MODE;\n\tvalue |= I2C_CTRL_EN;\n\tpoke32(I2C_CTRL, value);\n\n\treturn 0;\n}\n\nvoid sm750_hw_i2c_close(void)\n{\n\tunsigned int value;\n\n\t \n\tvalue = peek32(I2C_CTRL) & ~I2C_CTRL_EN;\n\tpoke32(I2C_CTRL, value);\n\n\t \n\tsm750_enable_i2c(0);\n\n\t \n\tvalue = peek32(GPIO_MUX);\n\tvalue &= ~GPIO_MUX_30;\n\tvalue &= ~GPIO_MUX_31;\n\tpoke32(GPIO_MUX, value);\n}\n\nstatic long hw_i2c_wait_tx_done(void)\n{\n\tunsigned int timeout;\n\n\t \n\ttimeout = HWI2C_WAIT_TIMEOUT;\n\twhile (!(peek32(I2C_STATUS) & I2C_STATUS_TX) && (timeout != 0))\n\t\ttimeout--;\n\n\tif (timeout == 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic unsigned int hw_i2c_write_data(unsigned char addr,\n\t\t\t\t      unsigned int length,\n\t\t\t\t      unsigned char *buf)\n{\n\tunsigned char count, i;\n\tunsigned int total_bytes = 0;\n\n\t \n\tpoke32(I2C_SLAVE_ADDRESS, addr & ~0x01);\n\n\t \n\tdo {\n\t\t \n\t\tpoke32(I2C_RESET, 0);\n\n\t\t \n\t\tif (length < MAX_HWI2C_FIFO)\n\t\t\tcount = length - 1;\n\t\telse\n\t\t\tcount = MAX_HWI2C_FIFO - 1;\n\t\tpoke32(I2C_BYTE_COUNT, count);\n\n\t\t \n\t\tfor (i = 0; i <= count; i++)\n\t\t\tpoke32(I2C_DATA0 + i, *buf++);\n\n\t\t \n\t\tpoke32(I2C_CTRL, peek32(I2C_CTRL) | I2C_CTRL_CTRL);\n\n\t\t \n\t\tif (hw_i2c_wait_tx_done() != 0)\n\t\t\tbreak;\n\n\t\t \n\t\tlength -= (count + 1);\n\n\t\t \n\t\ttotal_bytes += (count + 1);\n\n\t} while (length > 0);\n\n\treturn total_bytes;\n}\n\n \nstatic unsigned int hw_i2c_read_data(unsigned char addr,\n\t\t\t\t     unsigned int length,\n\t\t\t\t     unsigned char *buf)\n{\n\tunsigned char count, i;\n\tunsigned int total_bytes = 0;\n\n\t \n\tpoke32(I2C_SLAVE_ADDRESS, addr | 0x01);\n\n\t \n\tdo {\n\t\t \n\t\tpoke32(I2C_RESET, 0);\n\n\t\t \n\t\tif (length <= MAX_HWI2C_FIFO)\n\t\t\tcount = length - 1;\n\t\telse\n\t\t\tcount = MAX_HWI2C_FIFO - 1;\n\t\tpoke32(I2C_BYTE_COUNT, count);\n\n\t\t \n\t\tpoke32(I2C_CTRL, peek32(I2C_CTRL) | I2C_CTRL_CTRL);\n\n\t\t \n\t\tif (hw_i2c_wait_tx_done() != 0)\n\t\t\tbreak;\n\n\t\t \n\t\tfor (i = 0; i <= count; i++)\n\t\t\t*buf++ = peek32(I2C_DATA0 + i);\n\n\t\t \n\t\tlength -= (count + 1);\n\n\t\t \n\t\ttotal_bytes += (count + 1);\n\n\t} while (length > 0);\n\n\treturn total_bytes;\n}\n\n \nunsigned char sm750_hw_i2c_read_reg(unsigned char addr, unsigned char reg)\n{\n\tunsigned char value = 0xFF;\n\n\tif (hw_i2c_write_data(addr, 1, &reg) == 1)\n\t\thw_i2c_read_data(addr, 1, &value);\n\n\treturn value;\n}\n\n \nint sm750_hw_i2c_write_reg(unsigned char addr,\n\t\t\t   unsigned char reg,\n\t\t\t   unsigned char data)\n{\n\tunsigned char value[2];\n\n\tvalue[0] = reg;\n\tvalue[1] = data;\n\tif (hw_i2c_write_data(addr, 2, value) == 2)\n\t\treturn 0;\n\n\treturn -1;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}