{
  "module_name": "sm750_hw.c",
  "hash_id": "3be3dc322ca66396858b29f673c1ed650583a183f6e0f605fd143e513195bc6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/sm750fb/sm750_hw.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/console.h>\n#ifdef CONFIG_MTRR\n#include <asm/mtrr.h>\n#endif\n#include <linux/platform_device.h>\n#include <linux/sizes.h>\n\n#include \"sm750.h\"\n#include \"ddk750.h\"\n#include \"sm750_accel.h\"\n\nvoid __iomem *mmio750;\n\nint hw_sm750_map(struct sm750_dev *sm750_dev, struct pci_dev *pdev)\n{\n\tint ret;\n\n\tret = 0;\n\n\tsm750_dev->vidreg_start = pci_resource_start(pdev, 1);\n\tsm750_dev->vidreg_size = SZ_2M;\n\n\tpr_info(\"mmio phyAddr = %lx\\n\", sm750_dev->vidreg_start);\n\n\t \n\tret = pci_request_region(pdev, 1, \"sm750fb\");\n\tif (ret) {\n\t\tpr_err(\"Can not request PCI regions.\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tsm750_dev->pvReg =\n\t\tioremap(sm750_dev->vidreg_start, sm750_dev->vidreg_size);\n\tif (!sm750_dev->pvReg) {\n\t\tpr_err(\"mmio failed\\n\");\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t} else {\n\t\tpr_info(\"mmio virtual addr = %p\\n\", sm750_dev->pvReg);\n\t}\n\n\tsm750_dev->accel.dprBase = sm750_dev->pvReg + DE_BASE_ADDR_TYPE1;\n\tsm750_dev->accel.dpPortBase = sm750_dev->pvReg + DE_PORT_ADDR_TYPE1;\n\n\tmmio750 = sm750_dev->pvReg;\n\tsm750_set_chip_type(sm750_dev->devid, sm750_dev->revid);\n\n\tsm750_dev->vidmem_start = pci_resource_start(pdev, 0);\n\t \n\tsm750_dev->vidmem_size = ddk750_get_vm_size();\n\tpr_info(\"video memory phyAddr = %lx, size = %u bytes\\n\",\n\t\tsm750_dev->vidmem_start, sm750_dev->vidmem_size);\n\n\t \n\tsm750_dev->pvMem =\n\t\tioremap_wc(sm750_dev->vidmem_start, sm750_dev->vidmem_size);\n\tif (!sm750_dev->pvMem) {\n\t\tiounmap(sm750_dev->pvReg);\n\t\tpr_err(\"Map video memory failed\\n\");\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t} else {\n\t\tpr_info(\"video memory vaddr = %p\\n\", sm750_dev->pvMem);\n\t}\nexit:\n\treturn ret;\n}\n\nint hw_sm750_inithw(struct sm750_dev *sm750_dev, struct pci_dev *pdev)\n{\n\tstruct init_status *parm;\n\n\tparm = &sm750_dev->initParm;\n\tif (parm->chip_clk == 0)\n\t\tparm->chip_clk = (sm750_get_chip_type() == SM750LE) ?\n\t\t\t\t\t       DEFAULT_SM750LE_CHIP_CLOCK :\n\t\t\t\t\t       DEFAULT_SM750_CHIP_CLOCK;\n\n\tif (parm->mem_clk == 0)\n\t\tparm->mem_clk = parm->chip_clk;\n\tif (parm->master_clk == 0)\n\t\tparm->master_clk = parm->chip_clk / 3;\n\n\tddk750_init_hw((struct initchip_param *)&sm750_dev->initParm);\n\t \n\tif (sm750_dev->devid == 0x718) {\n\t\tpoke32(SYSTEM_CTRL,\n\t\t       peek32(SYSTEM_CTRL) | SYSTEM_CTRL_PCI_BURST);\n\t}\n\n\tif (sm750_get_chip_type() != SM750LE) {\n\t\tunsigned int val;\n\t\t \n\t\tif (sm750_dev->nocrt) {\n\t\t\tpoke32(MISC_CTRL,\n\t\t\t       peek32(MISC_CTRL) | MISC_CTRL_DAC_POWER_OFF);\n\t\t\t \n\t\t\tval = peek32(SYSTEM_CTRL) & ~SYSTEM_CTRL_DPMS_MASK;\n\t\t\tval |= SYSTEM_CTRL_DPMS_VPHN;\n\t\t\tpoke32(SYSTEM_CTRL, val);\n\t\t} else {\n\t\t\tpoke32(MISC_CTRL,\n\t\t\t       peek32(MISC_CTRL) & ~MISC_CTRL_DAC_POWER_OFF);\n\t\t\t \n\t\t\tval = peek32(SYSTEM_CTRL) & ~SYSTEM_CTRL_DPMS_MASK;\n\t\t\tval |= SYSTEM_CTRL_DPMS_VPHP;\n\t\t\tpoke32(SYSTEM_CTRL, val);\n\t\t}\n\n\t\tval = peek32(PANEL_DISPLAY_CTRL) &\n\t\t      ~(PANEL_DISPLAY_CTRL_DUAL_DISPLAY |\n\t\t\tPANEL_DISPLAY_CTRL_DOUBLE_PIXEL);\n\t\tswitch (sm750_dev->pnltype) {\n\t\tcase sm750_24TFT:\n\t\t\tbreak;\n\t\tcase sm750_doubleTFT:\n\t\t\tval |= PANEL_DISPLAY_CTRL_DOUBLE_PIXEL;\n\t\t\tbreak;\n\t\tcase sm750_dualTFT:\n\t\t\tval |= PANEL_DISPLAY_CTRL_DUAL_DISPLAY;\n\t\t\tbreak;\n\t\t}\n\t\tpoke32(PANEL_DISPLAY_CTRL, val);\n\t} else {\n\t\t \n\t\tsm750_sw_i2c_init(0, 1);\n\n\t\t \n\t\tif (sm750_sw_i2c_read_reg(0xec, 0x4a) == 0x95) {\n\t\t\t \n\t\t\tpr_info(\"yes,CH7301 DVI chip found\\n\");\n\t\t\tsm750_sw_i2c_write_reg(0xec, 0x1d, 0x16);\n\t\t\tsm750_sw_i2c_write_reg(0xec, 0x21, 0x9);\n\t\t\tsm750_sw_i2c_write_reg(0xec, 0x49, 0xC0);\n\t\t\tpr_info(\"okay,CH7301 DVI chip setup done\\n\");\n\t\t}\n\t}\n\n\t \n\tif (!sm750_dev->accel_off)\n\t\thw_sm750_initAccel(sm750_dev);\n\n\treturn 0;\n}\n\nint hw_sm750_output_setMode(struct lynxfb_output *output,\n\t\t\t    struct fb_var_screeninfo *var,\n\t\t\t    struct fb_fix_screeninfo *fix)\n{\n\tint ret;\n\tenum disp_output disp_set;\n\tint channel;\n\n\tret = 0;\n\tdisp_set = 0;\n\tchannel = *output->channel;\n\n\tif (sm750_get_chip_type() != SM750LE) {\n\t\tif (channel == sm750_primary) {\n\t\t\tpr_info(\"primary channel\\n\");\n\t\t\tif (output->paths & sm750_panel)\n\t\t\t\tdisp_set |= do_LCD1_PRI;\n\t\t\tif (output->paths & sm750_crt)\n\t\t\t\tdisp_set |= do_CRT_PRI;\n\n\t\t} else {\n\t\t\tpr_info(\"secondary channel\\n\");\n\t\t\tif (output->paths & sm750_panel)\n\t\t\t\tdisp_set |= do_LCD1_SEC;\n\t\t\tif (output->paths & sm750_crt)\n\t\t\t\tdisp_set |= do_CRT_SEC;\n\t\t}\n\t\tddk750_set_logical_disp_out(disp_set);\n\t} else {\n\t\t \n\t\tu32 reg;\n\n\t\treg = peek32(DISPLAY_CONTROL_750LE);\n\t\treg |= 0xf;\n\t\tpoke32(DISPLAY_CONTROL_750LE, reg);\n\t}\n\n\tpr_info(\"ddk setlogicdispout done\\n\");\n\treturn ret;\n}\n\nint hw_sm750_crtc_checkMode(struct lynxfb_crtc *crtc,\n\t\t\t    struct fb_var_screeninfo *var)\n{\n\tstruct sm750_dev *sm750_dev;\n\tstruct lynxfb_par *par = container_of(crtc, struct lynxfb_par, crtc);\n\n\tsm750_dev = par->dev;\n\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\tcase 16:\n\t\tbreak;\n\tcase 32:\n\t\tif (sm750_dev->revid == SM750LE_REVISION_ID) {\n\t\t\tpr_debug(\"750le do not support 32bpp\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint hw_sm750_crtc_setMode(struct lynxfb_crtc *crtc,\n\t\t\t  struct fb_var_screeninfo *var,\n\t\t\t  struct fb_fix_screeninfo *fix)\n{\n\tint ret, fmt;\n\tu32 reg;\n\tstruct mode_parameter modparm;\n\tenum clock_type clock;\n\tstruct sm750_dev *sm750_dev;\n\tstruct lynxfb_par *par;\n\n\tret = 0;\n\tpar = container_of(crtc, struct lynxfb_par, crtc);\n\tsm750_dev = par->dev;\n\n\tif (!sm750_dev->accel_off) {\n\t\t \n\t\tswitch (var->bits_per_pixel) {\n\t\tcase 8:\n\t\t\tfmt = 0;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tfmt = 1;\n\t\t\tbreak;\n\t\tcase 32:\n\t\tdefault:\n\t\t\tfmt = 2;\n\t\t\tbreak;\n\t\t}\n\t\tsm750_hw_set2dformat(&sm750_dev->accel, fmt);\n\t}\n\n\t \n\tmodparm.pixel_clock = ps_to_hz(var->pixclock);\n\tmodparm.vertical_sync_polarity =\n\t\t(var->sync & FB_SYNC_HOR_HIGH_ACT) ? POS : NEG;\n\tmodparm.horizontal_sync_polarity =\n\t\t(var->sync & FB_SYNC_VERT_HIGH_ACT) ? POS : NEG;\n\tmodparm.clock_phase_polarity =\n\t\t(var->sync & FB_SYNC_COMP_HIGH_ACT) ? POS : NEG;\n\tmodparm.horizontal_display_end = var->xres;\n\tmodparm.horizontal_sync_width = var->hsync_len;\n\tmodparm.horizontal_sync_start = var->xres + var->right_margin;\n\tmodparm.horizontal_total = var->xres + var->left_margin +\n\t\t\t\t   var->right_margin + var->hsync_len;\n\tmodparm.vertical_display_end = var->yres;\n\tmodparm.vertical_sync_height = var->vsync_len;\n\tmodparm.vertical_sync_start = var->yres + var->lower_margin;\n\tmodparm.vertical_total = var->yres + var->upper_margin +\n\t\t\t\t var->lower_margin + var->vsync_len;\n\n\t \n\tif (crtc->channel != sm750_secondary)\n\t\tclock = PRIMARY_PLL;\n\telse\n\t\tclock = SECONDARY_PLL;\n\n\tpr_debug(\"Request pixel clock = %lu\\n\", modparm.pixel_clock);\n\tret = ddk750_setModeTiming(&modparm, clock);\n\tif (ret) {\n\t\tpr_err(\"Set mode timing failed\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (crtc->channel != sm750_secondary) {\n\t\t \n\t\tpoke32(PANEL_FB_ADDRESS,\n\t\t       crtc->o_screen & PANEL_FB_ADDRESS_ADDRESS_MASK);\n\n\t\treg = var->xres * (var->bits_per_pixel >> 3);\n\t\t \n\t\treg = ALIGN(reg, crtc->line_pad);\n\t\treg = (reg << PANEL_FB_WIDTH_WIDTH_SHIFT) &\n\t\t      PANEL_FB_WIDTH_WIDTH_MASK;\n\t\treg |= (fix->line_length & PANEL_FB_WIDTH_OFFSET_MASK);\n\t\tpoke32(PANEL_FB_WIDTH, reg);\n\n\t\treg = ((var->xres - 1) << PANEL_WINDOW_WIDTH_WIDTH_SHIFT) &\n\t\t      PANEL_WINDOW_WIDTH_WIDTH_MASK;\n\t\treg |= (var->xoffset & PANEL_WINDOW_WIDTH_X_MASK);\n\t\tpoke32(PANEL_WINDOW_WIDTH, reg);\n\n\t\treg = (var->yres_virtual - 1)\n\t\t      << PANEL_WINDOW_HEIGHT_HEIGHT_SHIFT;\n\t\treg &= PANEL_WINDOW_HEIGHT_HEIGHT_MASK;\n\t\treg |= (var->yoffset & PANEL_WINDOW_HEIGHT_Y_MASK);\n\t\tpoke32(PANEL_WINDOW_HEIGHT, reg);\n\n\t\tpoke32(PANEL_PLANE_TL, 0);\n\n\t\treg = ((var->yres - 1) << PANEL_PLANE_BR_BOTTOM_SHIFT) &\n\t\t      PANEL_PLANE_BR_BOTTOM_MASK;\n\t\treg |= ((var->xres - 1) & PANEL_PLANE_BR_RIGHT_MASK);\n\t\tpoke32(PANEL_PLANE_BR, reg);\n\n\t\t \n\t\treg = peek32(PANEL_DISPLAY_CTRL);\n\t\tpoke32(PANEL_DISPLAY_CTRL, reg | (var->bits_per_pixel >> 4));\n\t} else {\n\t\t \n\t\tpoke32(CRT_FB_ADDRESS, crtc->o_screen);\n\t\treg = var->xres * (var->bits_per_pixel >> 3);\n\t\t \n\t\treg = ALIGN(reg, crtc->line_pad) << CRT_FB_WIDTH_WIDTH_SHIFT;\n\t\treg &= CRT_FB_WIDTH_WIDTH_MASK;\n\t\treg |= (fix->line_length & CRT_FB_WIDTH_OFFSET_MASK);\n\t\tpoke32(CRT_FB_WIDTH, reg);\n\n\t\t \n\t\treg = peek32(CRT_DISPLAY_CTRL);\n\t\treg |= ((var->bits_per_pixel >> 4) &\n\t\t\tCRT_DISPLAY_CTRL_FORMAT_MASK);\n\t\tpoke32(CRT_DISPLAY_CTRL, reg);\n\t}\n\nexit:\n\treturn ret;\n}\n\nint hw_sm750_setColReg(struct lynxfb_crtc *crtc, ushort index, ushort red,\n\t\t       ushort green, ushort blue)\n{\n\tstatic unsigned int add[] = { PANEL_PALETTE_RAM, CRT_PALETTE_RAM };\n\n\tpoke32(add[crtc->channel] + index * 4,\n\t       (red << 16) | (green << 8) | blue);\n\treturn 0;\n}\n\nint hw_sm750le_setBLANK(struct lynxfb_output *output, int blank)\n{\n\tint dpms, crtdb;\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:\n\t\tdpms = CRT_DISPLAY_CTRL_DPMS_0;\n\t\tcrtdb = 0;\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\tdpms = CRT_DISPLAY_CTRL_DPMS_0;\n\t\tcrtdb = CRT_DISPLAY_CTRL_BLANK;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tdpms = CRT_DISPLAY_CTRL_DPMS_2;\n\t\tcrtdb = CRT_DISPLAY_CTRL_BLANK;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tdpms = CRT_DISPLAY_CTRL_DPMS_1;\n\t\tcrtdb = CRT_DISPLAY_CTRL_BLANK;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tdpms = CRT_DISPLAY_CTRL_DPMS_3;\n\t\tcrtdb = CRT_DISPLAY_CTRL_BLANK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (output->paths & sm750_crt) {\n\t\tunsigned int val;\n\n\t\tval = peek32(CRT_DISPLAY_CTRL) & ~CRT_DISPLAY_CTRL_DPMS_MASK;\n\t\tpoke32(CRT_DISPLAY_CTRL, val | dpms);\n\n\t\tval = peek32(CRT_DISPLAY_CTRL) & ~CRT_DISPLAY_CTRL_BLANK;\n\t\tpoke32(CRT_DISPLAY_CTRL, val | crtdb);\n\t}\n\treturn 0;\n}\n\nint hw_sm750_setBLANK(struct lynxfb_output *output, int blank)\n{\n\tunsigned int dpms, pps, crtdb;\n\n\tdpms = 0;\n\tpps = 0;\n\tcrtdb = 0;\n\n\tswitch (blank) {\n\tcase FB_BLANK_UNBLANK:\n\t\tpr_debug(\"flag = FB_BLANK_UNBLANK\\n\");\n\t\tdpms = SYSTEM_CTRL_DPMS_VPHP;\n\t\tpps = PANEL_DISPLAY_CTRL_DATA;\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\t\tpr_debug(\"flag = FB_BLANK_NORMAL\\n\");\n\t\tdpms = SYSTEM_CTRL_DPMS_VPHP;\n\t\tcrtdb = CRT_DISPLAY_CTRL_BLANK;\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\tdpms = SYSTEM_CTRL_DPMS_VNHP;\n\t\tcrtdb = CRT_DISPLAY_CTRL_BLANK;\n\t\tbreak;\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\tdpms = SYSTEM_CTRL_DPMS_VPHN;\n\t\tcrtdb = CRT_DISPLAY_CTRL_BLANK;\n\t\tbreak;\n\tcase FB_BLANK_POWERDOWN:\n\t\tdpms = SYSTEM_CTRL_DPMS_VNHN;\n\t\tcrtdb = CRT_DISPLAY_CTRL_BLANK;\n\t\tbreak;\n\t}\n\n\tif (output->paths & sm750_crt) {\n\t\tunsigned int val = peek32(SYSTEM_CTRL) & ~SYSTEM_CTRL_DPMS_MASK;\n\n\t\tpoke32(SYSTEM_CTRL, val | dpms);\n\n\t\tval = peek32(CRT_DISPLAY_CTRL) & ~CRT_DISPLAY_CTRL_BLANK;\n\t\tpoke32(CRT_DISPLAY_CTRL, val | crtdb);\n\t}\n\n\tif (output->paths & sm750_panel) {\n\t\tunsigned int val = peek32(PANEL_DISPLAY_CTRL);\n\n\t\tval &= ~PANEL_DISPLAY_CTRL_DATA;\n\t\tval |= pps;\n\t\tpoke32(PANEL_DISPLAY_CTRL, val);\n\t}\n\n\treturn 0;\n}\n\nvoid hw_sm750_initAccel(struct sm750_dev *sm750_dev)\n{\n\tu32 reg;\n\n\tsm750_enable_2d_engine(1);\n\n\tif (sm750_get_chip_type() == SM750LE) {\n\t\treg = peek32(DE_STATE1);\n\t\treg |= DE_STATE1_DE_ABORT;\n\t\tpoke32(DE_STATE1, reg);\n\n\t\treg = peek32(DE_STATE1);\n\t\treg &= ~DE_STATE1_DE_ABORT;\n\t\tpoke32(DE_STATE1, reg);\n\n\t} else {\n\t\t \n\t\treg = peek32(SYSTEM_CTRL);\n\t\treg |= SYSTEM_CTRL_DE_ABORT;\n\t\tpoke32(SYSTEM_CTRL, reg);\n\n\t\treg = peek32(SYSTEM_CTRL);\n\t\treg &= ~SYSTEM_CTRL_DE_ABORT;\n\t\tpoke32(SYSTEM_CTRL, reg);\n\t}\n\n\t \n\tsm750_dev->accel.de_init(&sm750_dev->accel);\n}\n\nint hw_sm750le_deWait(void)\n{\n\tint i = 0x10000000;\n\tunsigned int mask = DE_STATE2_DE_STATUS_BUSY | DE_STATE2_DE_FIFO_EMPTY |\n\t\t\t    DE_STATE2_DE_MEM_FIFO_EMPTY;\n\n\twhile (i--) {\n\t\tunsigned int val = peek32(DE_STATE2);\n\n\t\tif ((val & mask) ==\n\t\t    (DE_STATE2_DE_FIFO_EMPTY | DE_STATE2_DE_MEM_FIFO_EMPTY))\n\t\t\treturn 0;\n\t}\n\t \n\treturn -1;\n}\n\nint hw_sm750_deWait(void)\n{\n\tint i = 0x10000000;\n\tunsigned int mask = SYSTEM_CTRL_DE_STATUS_BUSY |\n\t\t\t    SYSTEM_CTRL_DE_FIFO_EMPTY |\n\t\t\t    SYSTEM_CTRL_DE_MEM_FIFO_EMPTY;\n\n\twhile (i--) {\n\t\tunsigned int val = peek32(SYSTEM_CTRL);\n\n\t\tif ((val & mask) ==\n\t\t    (SYSTEM_CTRL_DE_FIFO_EMPTY | SYSTEM_CTRL_DE_MEM_FIFO_EMPTY))\n\t\t\treturn 0;\n\t}\n\t \n\treturn -1;\n}\n\nint hw_sm750_pan_display(struct lynxfb_crtc *crtc,\n\t\t\t const struct fb_var_screeninfo *var,\n\t\t\t const struct fb_info *info)\n{\n\tu32 total;\n\t \n\tif ((var->xoffset + var->xres > var->xres_virtual) ||\n\t    (var->yoffset + var->yres > var->yres_virtual)) {\n\t\treturn -EINVAL;\n\t}\n\n\ttotal = var->yoffset * info->fix.line_length +\n\t\t((var->xoffset * var->bits_per_pixel) >> 3);\n\ttotal += crtc->o_screen;\n\tif (crtc->channel == sm750_primary) {\n\t\tpoke32(PANEL_FB_ADDRESS,\n\t\t       peek32(PANEL_FB_ADDRESS) |\n\t\t\t       (total & PANEL_FB_ADDRESS_ADDRESS_MASK));\n\t} else {\n\t\tpoke32(CRT_FB_ADDRESS,\n\t\t       peek32(CRT_FB_ADDRESS) |\n\t\t\t       (total & CRT_FB_ADDRESS_ADDRESS_MASK));\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}