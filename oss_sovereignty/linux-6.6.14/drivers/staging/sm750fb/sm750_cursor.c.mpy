{
  "module_name": "sm750_cursor.c",
  "hash_id": "b238151b6ce8b939e57622ca79e68b784304b00bb6a916c4205ac5a5cc46262b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/sm750fb/sm750_cursor.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/console.h>\n#include <linux/platform_device.h>\n\n#include \"sm750.h\"\n#include \"sm750_cursor.h\"\n\n#define poke32(addr, data) \\\nwritel((data), cursor->mmio + (addr))\n\n \n#define HWC_ADDRESS                         0x0\n#define HWC_ADDRESS_ENABLE                  BIT(31)\n#define HWC_ADDRESS_EXT                     BIT(27)\n#define HWC_ADDRESS_CS                      BIT(26)\n#define HWC_ADDRESS_ADDRESS_MASK            0x3ffffff\n\n#define HWC_LOCATION                        0x4\n#define HWC_LOCATION_TOP                    BIT(27)\n#define HWC_LOCATION_Y_SHIFT                16\n#define HWC_LOCATION_Y_MASK                 (0x7ff << 16)\n#define HWC_LOCATION_LEFT                   BIT(11)\n#define HWC_LOCATION_X_MASK                 0x7ff\n\n#define HWC_COLOR_12                        0x8\n#define HWC_COLOR_12_2_RGB565_SHIFT         16\n#define HWC_COLOR_12_2_RGB565_MASK          (0xffff << 16)\n#define HWC_COLOR_12_1_RGB565_MASK          0xffff\n\n#define HWC_COLOR_3                         0xC\n#define HWC_COLOR_3_RGB565_MASK             0xffff\n\n \nvoid sm750_hw_cursor_enable(struct lynx_cursor *cursor)\n{\n\tu32 reg;\n\n\treg = (cursor->offset & HWC_ADDRESS_ADDRESS_MASK) | HWC_ADDRESS_ENABLE;\n\tpoke32(HWC_ADDRESS, reg);\n}\n\nvoid sm750_hw_cursor_disable(struct lynx_cursor *cursor)\n{\n\tpoke32(HWC_ADDRESS, 0);\n}\n\nvoid sm750_hw_cursor_setSize(struct lynx_cursor *cursor, int w, int h)\n{\n\tcursor->w = w;\n\tcursor->h = h;\n}\n\nvoid sm750_hw_cursor_setPos(struct lynx_cursor *cursor, int x, int y)\n{\n\tu32 reg;\n\n\treg = ((y << HWC_LOCATION_Y_SHIFT) & HWC_LOCATION_Y_MASK) |\n\t       (x & HWC_LOCATION_X_MASK);\n\tpoke32(HWC_LOCATION, reg);\n}\n\nvoid sm750_hw_cursor_setColor(struct lynx_cursor *cursor, u32 fg, u32 bg)\n{\n\tu32 reg = (fg << HWC_COLOR_12_2_RGB565_SHIFT) &\n\t\tHWC_COLOR_12_2_RGB565_MASK;\n\n\tpoke32(HWC_COLOR_12, reg | (bg & HWC_COLOR_12_1_RGB565_MASK));\n\tpoke32(HWC_COLOR_3, 0xffe0);\n}\n\nvoid sm750_hw_cursor_setData(struct lynx_cursor *cursor, u16 rop,\n\t\t\t     const u8 *pcol, const u8 *pmsk)\n{\n\tint i, j, count, pitch, offset;\n\tu8 color, mask, opr;\n\tu16 data;\n\tvoid __iomem *pbuffer, *pstart;\n\n\t \n\tpitch = cursor->w >> 3;\n\n\t \n\tcount = pitch * cursor->h;\n\n\t \n\toffset = cursor->max_w * 2 / 8;\n\n\tdata = 0;\n\tpstart = cursor->vstart;\n\tpbuffer = pstart;\n\n\tfor (i = 0; i < count; i++) {\n\t\tcolor = *pcol++;\n\t\tmask = *pmsk++;\n\t\tdata = 0;\n\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif (mask & (0x80 >> j)) {\n\t\t\t\tif (rop == ROP_XOR)\n\t\t\t\t\topr = mask ^ color;\n\t\t\t\telse\n\t\t\t\t\topr = mask & color;\n\n\t\t\t\t \n\t\t\t\tdata |= ((opr & (0x80 >> j)) ? 2 : 1) << (j * 2);\n\t\t\t}\n\t\t}\n\t\tiowrite16(data, pbuffer);\n\n\t\t \n\t\tif ((i + 1) % pitch == 0) {\n\t\t\t \n\t\t\tpstart += offset;\n\t\t\tpbuffer = pstart;\n\t\t} else {\n\t\t\tpbuffer += sizeof(u16);\n\t\t}\n\t}\n}\n\nvoid sm750_hw_cursor_setData2(struct lynx_cursor *cursor, u16 rop,\n\t\t\t      const u8 *pcol, const u8 *pmsk)\n{\n\tint i, j, count, pitch, offset;\n\tu8 color, mask;\n\tu16 data;\n\tvoid __iomem *pbuffer, *pstart;\n\n\t \n\tpitch = cursor->w >> 3;\n\n\t \n\tcount = pitch * cursor->h;\n\n\t \n\toffset = cursor->max_w * 2 / 8;\n\n\tdata = 0;\n\tpstart = cursor->vstart;\n\tpbuffer = pstart;\n\n\tfor (i = 0; i < count; i++) {\n\t\tcolor = *pcol++;\n\t\tmask = *pmsk++;\n\t\tdata = 0;\n\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif (mask & (1 << j))\n\t\t\t\tdata |= ((color & (1 << j)) ? 1 : 2) << (j * 2);\n\t\t}\n\t\tiowrite16(data, pbuffer);\n\n\t\t \n\t\tif (!(i & (pitch - 1))) {\n\t\t\t \n\t\t\tpstart += offset;\n\t\t\tpbuffer = pstart;\n\t\t} else {\n\t\t\tpbuffer += sizeof(u16);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}