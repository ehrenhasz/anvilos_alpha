{
  "module_name": "ddk750_chip.c",
  "hash_id": "02cf9b60412d4587e2922fdd17a5c1a73e2ec889a24007709d584b66d2db91ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/sm750fb/ddk750_chip.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/sizes.h>\n\n#include \"ddk750_reg.h\"\n#include \"ddk750_chip.h\"\n#include \"ddk750_power.h\"\n\n#define MHz(x) ((x) * 1000000)\n\nstatic enum logical_chip_type chip;\n\nenum logical_chip_type sm750_get_chip_type(void)\n{\n\treturn chip;\n}\n\nvoid sm750_set_chip_type(unsigned short dev_id, u8 rev_id)\n{\n\tif (dev_id == 0x718) {\n\t\tchip = SM718;\n\t} else if (dev_id == 0x750) {\n\t\tchip = SM750;\n\t\t \n\t\tif (rev_id == SM750LE_REVISION_ID) {\n\t\t\tchip = SM750LE;\n\t\t\tpr_info(\"found sm750le\\n\");\n\t\t}\n\t} else {\n\t\tchip = SM_UNKNOWN;\n\t}\n}\n\nstatic unsigned int get_mxclk_freq(void)\n{\n\tunsigned int pll_reg;\n\tunsigned int M, N, OD, POD;\n\n\tif (sm750_get_chip_type() == SM750LE)\n\t\treturn MHz(130);\n\n\tpll_reg = peek32(MXCLK_PLL_CTRL);\n\tM = (pll_reg & PLL_CTRL_M_MASK) >> PLL_CTRL_M_SHIFT;\n\tN = (pll_reg & PLL_CTRL_N_MASK) >> PLL_CTRL_N_SHIFT;\n\tOD = (pll_reg & PLL_CTRL_OD_MASK) >> PLL_CTRL_OD_SHIFT;\n\tPOD = (pll_reg & PLL_CTRL_POD_MASK) >> PLL_CTRL_POD_SHIFT;\n\n\treturn DEFAULT_INPUT_CLOCK * M / N / BIT(OD) / BIT(POD);\n}\n\n \nstatic void set_chip_clock(unsigned int frequency)\n{\n\tstruct pll_value pll;\n\n\t \n\tif (sm750_get_chip_type() == SM750LE)\n\t\treturn;\n\n\tif (frequency) {\n\t\t \n\t\tpll.input_freq = DEFAULT_INPUT_CLOCK;  \n\t\tpll.clock_type = MXCLK_PLL;\n\n\t\t \n\t\tsm750_calc_pll_value(frequency, &pll);\n\n\t\t \n\t\tpoke32(MXCLK_PLL_CTRL, sm750_format_pll_reg(&pll));\n\t}\n}\n\nstatic void set_memory_clock(unsigned int frequency)\n{\n\tunsigned int reg, divisor;\n\n\t \n\tif (sm750_get_chip_type() == SM750LE)\n\t\treturn;\n\n\tif (frequency) {\n\t\t \n\t\tif (frequency > MHz(336))\n\t\t\tfrequency = MHz(336);\n\n\t\t \n\t\tdivisor = DIV_ROUND_CLOSEST(get_mxclk_freq(), frequency);\n\n\t\t \n\t\treg = peek32(CURRENT_GATE) & ~CURRENT_GATE_M2XCLK_MASK;\n\t\tswitch (divisor) {\n\t\tdefault:\n\t\tcase 1:\n\t\t\treg |= CURRENT_GATE_M2XCLK_DIV_1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\treg |= CURRENT_GATE_M2XCLK_DIV_2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\treg |= CURRENT_GATE_M2XCLK_DIV_3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\treg |= CURRENT_GATE_M2XCLK_DIV_4;\n\t\t\tbreak;\n\t\t}\n\n\t\tsm750_set_current_gate(reg);\n\t}\n}\n\n \nstatic void set_master_clock(unsigned int frequency)\n{\n\tunsigned int reg, divisor;\n\n\t \n\tif (sm750_get_chip_type() == SM750LE)\n\t\treturn;\n\n\tif (frequency) {\n\t\t \n\t\tif (frequency > MHz(190))\n\t\t\tfrequency = MHz(190);\n\n\t\t \n\t\tdivisor = DIV_ROUND_CLOSEST(get_mxclk_freq(), frequency);\n\n\t\t \n\t\treg = peek32(CURRENT_GATE) & ~CURRENT_GATE_MCLK_MASK;\n\t\tswitch (divisor) {\n\t\tdefault:\n\t\tcase 3:\n\t\t\treg |= CURRENT_GATE_MCLK_DIV_3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\treg |= CURRENT_GATE_MCLK_DIV_4;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\treg |= CURRENT_GATE_MCLK_DIV_6;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\treg |= CURRENT_GATE_MCLK_DIV_8;\n\t\t\tbreak;\n\t\t}\n\n\t\tsm750_set_current_gate(reg);\n\t}\n}\n\nunsigned int ddk750_get_vm_size(void)\n{\n\tunsigned int reg;\n\tunsigned int data;\n\n\t \n\tif (sm750_get_chip_type() == SM750LE)\n\t\treturn SZ_64M;\n\n\t \n\treg = peek32(MODE0_GATE);\n\treg |= MODE0_GATE_GPIO;\n\tpoke32(MODE0_GATE, reg);\n\n\t \n\treg = peek32(MISC_CTRL) & MISC_CTRL_LOCALMEM_SIZE_MASK;\n\tswitch (reg) {\n\tcase MISC_CTRL_LOCALMEM_SIZE_8M:\n\t\tdata = SZ_8M;  break;  \n\tcase MISC_CTRL_LOCALMEM_SIZE_16M:\n\t\tdata = SZ_16M; break;  \n\tcase MISC_CTRL_LOCALMEM_SIZE_32M:\n\t\tdata = SZ_32M; break;  \n\tcase MISC_CTRL_LOCALMEM_SIZE_64M:\n\t\tdata = SZ_64M; break;  \n\tdefault:\n\t\tdata = 0;\n\t\tbreak;\n\t}\n\treturn data;\n}\n\nint ddk750_init_hw(struct initchip_param *p_init_param)\n{\n\tunsigned int reg;\n\n\tif (p_init_param->power_mode != 0)\n\t\tp_init_param->power_mode = 0;\n\tsm750_set_power_mode(p_init_param->power_mode);\n\n\t \n\treg = peek32(CURRENT_GATE);\n\treg |= (CURRENT_GATE_DISPLAY | CURRENT_GATE_LOCALMEM);\n\tsm750_set_current_gate(reg);\n\n\tif (sm750_get_chip_type() != SM750LE) {\n\t\t \n\t\treg = peek32(VGA_CONFIGURATION);\n\t\treg |= (VGA_CONFIGURATION_PLL | VGA_CONFIGURATION_MODE);\n\t\tpoke32(VGA_CONFIGURATION, reg);\n\t} else {\n#if defined(__i386__) || defined(__x86_64__)\n\t\t \n\t\toutb_p(0x88, 0x3d4);\n\t\toutb_p(0x06, 0x3d5);\n#endif\n\t}\n\n\t \n\tset_chip_clock(MHz((unsigned int)p_init_param->chip_clock));\n\n\t \n\tset_memory_clock(MHz(p_init_param->mem_clock));\n\n\t \n\tset_master_clock(MHz(p_init_param->master_clock));\n\n\t \n\tif (p_init_param->reset_memory == 1) {\n\t\treg = peek32(MISC_CTRL);\n\t\treg &= ~MISC_CTRL_LOCALMEM_RESET;\n\t\tpoke32(MISC_CTRL, reg);\n\n\t\treg |= MISC_CTRL_LOCALMEM_RESET;\n\t\tpoke32(MISC_CTRL, reg);\n\t}\n\n\tif (p_init_param->set_all_eng_off == 1) {\n\t\tsm750_enable_2d_engine(0);\n\n\t\t \n\t\treg = peek32(VIDEO_DISPLAY_CTRL);\n\t\treg &= ~DISPLAY_CTRL_PLANE;\n\t\tpoke32(VIDEO_DISPLAY_CTRL, reg);\n\n\t\t \n\t\treg = peek32(VIDEO_ALPHA_DISPLAY_CTRL);\n\t\treg &= ~DISPLAY_CTRL_PLANE;\n\t\tpoke32(VIDEO_ALPHA_DISPLAY_CTRL, reg);\n\n\t\t \n\t\treg = peek32(ALPHA_DISPLAY_CTRL);\n\t\treg &= ~DISPLAY_CTRL_PLANE;\n\t\tpoke32(ALPHA_DISPLAY_CTRL, reg);\n\n\t\t \n\t\treg = peek32(DMA_ABORT_INTERRUPT);\n\t\treg |= DMA_ABORT_INTERRUPT_ABORT_1;\n\t\tpoke32(DMA_ABORT_INTERRUPT, reg);\n\n\t\t \n\t\tsm750_enable_dma(0);\n\t}\n\n\t \n\n\treturn 0;\n}\n\n \nunsigned int sm750_calc_pll_value(unsigned int request_orig,\n\t\t\t\t  struct pll_value *pll)\n{\n\t \n\tint N, M, X, d;\n\tint mini_diff;\n\tunsigned int RN, quo, rem, fl_quo;\n\tunsigned int input, request;\n\tunsigned int tmp_clock, ret;\n\tconst int max_OD = 3;\n\tint max_d = 6;\n\n\tif (sm750_get_chip_type() == SM750LE) {\n\t\t \n\t\treturn request_orig;\n\t}\n\n\tret = 0;\n\tmini_diff = ~0;\n\trequest = request_orig / 1000;\n\tinput = pll->input_freq / 1000;\n\n\t \n\tif (pll->clock_type == MXCLK_PLL)\n\t\tmax_d = 3;\n\n\tfor (N = 15; N > 1; N--) {\n\t\t \n\t\tRN = N * request;\n\t\tquo = RN / input;\n\t\trem = RN % input; \n\t\tfl_quo = rem * 10000 / input;\n\n\t\tfor (d = max_d; d >= 0; d--) {\n\t\t\tX = BIT(d);\n\t\t\tM = quo * X;\n\t\t\tM += fl_quo * X / 10000;\n\t\t\t \n\t\t\tM += (fl_quo * X % 10000) > 5000 ? 1 : 0;\n\t\t\tif (M < 256 && M > 0) {\n\t\t\t\tunsigned int diff;\n\n\t\t\t\ttmp_clock = pll->input_freq * M / N / X;\n\t\t\t\tdiff = abs(tmp_clock - request_orig);\n\t\t\t\tif (diff < mini_diff) {\n\t\t\t\t\tpll->M = M;\n\t\t\t\t\tpll->N = N;\n\t\t\t\t\tpll->POD = 0;\n\t\t\t\t\tif (d > max_OD)\n\t\t\t\t\t\tpll->POD = d - max_OD;\n\t\t\t\t\tpll->OD = d - pll->POD;\n\t\t\t\t\tmini_diff = diff;\n\t\t\t\t\tret = tmp_clock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nunsigned int sm750_format_pll_reg(struct pll_value *p_PLL)\n{\n#ifndef VALIDATION_CHIP\n\tunsigned int POD = p_PLL->POD;\n#endif\n\tunsigned int OD = p_PLL->OD;\n\tunsigned int M = p_PLL->M;\n\tunsigned int N = p_PLL->N;\n\n\t \n\treturn PLL_CTRL_POWER |\n#ifndef VALIDATION_CHIP\n\t\t((POD << PLL_CTRL_POD_SHIFT) & PLL_CTRL_POD_MASK) |\n#endif\n\t\t((OD << PLL_CTRL_OD_SHIFT) & PLL_CTRL_OD_MASK) |\n\t\t((N << PLL_CTRL_N_SHIFT) & PLL_CTRL_N_MASK) |\n\t\t((M << PLL_CTRL_M_SHIFT) & PLL_CTRL_M_MASK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}