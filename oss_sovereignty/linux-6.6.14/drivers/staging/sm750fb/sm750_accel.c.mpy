{
  "module_name": "sm750_accel.c",
  "hash_id": "18a727baf391c0c4664c2a36abb7eb15fb30a211e02865aebf88337e9e269ced",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/sm750fb/sm750_accel.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/console.h>\n#include <linux/platform_device.h>\n\n#include \"sm750.h\"\n#include \"sm750_accel.h\"\nstatic inline void write_dpr(struct lynx_accel *accel, int offset, u32 regValue)\n{\n\twritel(regValue, accel->dprBase + offset);\n}\n\nstatic inline u32 read_dpr(struct lynx_accel *accel, int offset)\n{\n\treturn readl(accel->dprBase + offset);\n}\n\nstatic inline void write_dpPort(struct lynx_accel *accel, u32 data)\n{\n\twritel(data, accel->dpPortBase);\n}\n\nvoid sm750_hw_de_init(struct lynx_accel *accel)\n{\n\t \n\tu32 reg, clr;\n\n\twrite_dpr(accel, DE_MASKS, 0xFFFFFFFF);\n\n\t \n\treg =  0x3;\n\n\tclr = DE_STRETCH_FORMAT_PATTERN_XY |\n\t      DE_STRETCH_FORMAT_PATTERN_Y_MASK |\n\t      DE_STRETCH_FORMAT_PATTERN_X_MASK |\n\t      DE_STRETCH_FORMAT_ADDRESSING_MASK |\n\t      DE_STRETCH_FORMAT_SOURCE_HEIGHT_MASK;\n\n\t \n\twrite_dpr(accel, DE_STRETCH_FORMAT,\n\t\t  (read_dpr(accel, DE_STRETCH_FORMAT) & ~clr) | reg);\n\n\t \n\twrite_dpr(accel, DE_CLIP_TL, 0);  \n\twrite_dpr(accel, DE_CLIP_BR, 0);  \n\n\twrite_dpr(accel, DE_COLOR_COMPARE_MASK, 0);  \n\twrite_dpr(accel, DE_COLOR_COMPARE, 0);\n\n\tclr = DE_CONTROL_TRANSPARENCY | DE_CONTROL_TRANSPARENCY_MATCH |\n\t\tDE_CONTROL_TRANSPARENCY_SELECT;\n\n\t \n\twrite_dpr(accel, DE_CONTROL, read_dpr(accel, DE_CONTROL) & ~clr);\n}\n\n \n\nvoid sm750_hw_set2dformat(struct lynx_accel *accel, int fmt)\n{\n\tu32 reg;\n\n\t \n\treg = read_dpr(accel, DE_STRETCH_FORMAT);\n\treg &= ~DE_STRETCH_FORMAT_PIXEL_FORMAT_MASK;\n\treg |= ((fmt << DE_STRETCH_FORMAT_PIXEL_FORMAT_SHIFT) &\n\t\tDE_STRETCH_FORMAT_PIXEL_FORMAT_MASK);\n\twrite_dpr(accel, DE_STRETCH_FORMAT, reg);\n}\n\nint sm750_hw_fillrect(struct lynx_accel *accel,\n\t\t      u32 base, u32 pitch, u32 Bpp,\n\t\t      u32 x, u32 y, u32 width, u32 height,\n\t\t      u32 color, u32 rop)\n{\n\tu32 deCtrl;\n\n\tif (accel->de_wait() != 0) {\n\t\t \n\t\tpr_debug(\"De engine always busy\\n\");\n\t\treturn -1;\n\t}\n\n\twrite_dpr(accel, DE_WINDOW_DESTINATION_BASE, base);  \n\twrite_dpr(accel, DE_PITCH,\n\t\t  ((pitch / Bpp << DE_PITCH_DESTINATION_SHIFT) &\n\t\t   DE_PITCH_DESTINATION_MASK) |\n\t\t  (pitch / Bpp & DE_PITCH_SOURCE_MASK));  \n\n\twrite_dpr(accel, DE_WINDOW_WIDTH,\n\t\t  ((pitch / Bpp << DE_WINDOW_WIDTH_DST_SHIFT) &\n\t\t   DE_WINDOW_WIDTH_DST_MASK) |\n\t\t   (pitch / Bpp & DE_WINDOW_WIDTH_SRC_MASK));  \n\n\twrite_dpr(accel, DE_FOREGROUND, color);  \n\n\twrite_dpr(accel, DE_DESTINATION,\n\t\t  ((x << DE_DESTINATION_X_SHIFT) & DE_DESTINATION_X_MASK) |\n\t\t  (y & DE_DESTINATION_Y_MASK));  \n\n\twrite_dpr(accel, DE_DIMENSION,\n\t\t  ((width << DE_DIMENSION_X_SHIFT) & DE_DIMENSION_X_MASK) |\n\t\t  (height & DE_DIMENSION_Y_ET_MASK));  \n\n\tdeCtrl = DE_CONTROL_STATUS | DE_CONTROL_LAST_PIXEL |\n\t\tDE_CONTROL_COMMAND_RECTANGLE_FILL | DE_CONTROL_ROP_SELECT |\n\t\t(rop & DE_CONTROL_ROP_MASK);  \n\n\twrite_dpr(accel, DE_CONTROL, deCtrl);\n\treturn 0;\n}\n\n \nint sm750_hw_copyarea(struct lynx_accel *accel,\n\t\t      unsigned int sBase, unsigned int sPitch,\n\t\t      unsigned int sx, unsigned int sy,\n\t\t      unsigned int dBase, unsigned int dPitch,\n\t\t      unsigned int Bpp, unsigned int dx, unsigned int dy,\n\t\t      unsigned int width, unsigned int height,\n\t\t      unsigned int rop2)\n{\n\tunsigned int nDirection, de_ctrl;\n\n\tnDirection = LEFT_TO_RIGHT;\n\t \n\tde_ctrl = 0;\n\n\t \n\tif (sBase == dBase && sPitch == dPitch) {\n\t\t \n\t\tif (sy < dy) {\n\t\t\t \n\n\t\t\tnDirection = BOTTOM_TO_TOP;\n\t\t} else if (sy > dy) {\n\t\t\t \n\n\t\t\tnDirection = TOP_TO_BOTTOM;\n\t\t} else {\n\t\t\t \n\n\t\t\tif (sx <= dx) {\n\t\t\t\t \n\n\t\t\t\tnDirection = RIGHT_TO_LEFT;\n\t\t\t} else {\n\t\t\t \n\n\t\t\t\t \n\n\t\t\t\tnDirection = LEFT_TO_RIGHT;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((nDirection == BOTTOM_TO_TOP) || (nDirection == RIGHT_TO_LEFT)) {\n\t\tsx += width - 1;\n\t\tsy += height - 1;\n\t\tdx += width - 1;\n\t\tdy += height - 1;\n\t}\n\n\t \n\n\t \n\twrite_dpr(accel, DE_WINDOW_SOURCE_BASE, sBase);  \n\n\t \n\twrite_dpr(accel, DE_WINDOW_DESTINATION_BASE, dBase);  \n\n\t \n\twrite_dpr(accel, DE_PITCH,\n\t\t  ((dPitch / Bpp << DE_PITCH_DESTINATION_SHIFT) &\n\t\t   DE_PITCH_DESTINATION_MASK) |\n\t\t  (sPitch / Bpp & DE_PITCH_SOURCE_MASK));  \n\n\t \n\twrite_dpr(accel, DE_WINDOW_WIDTH,\n\t\t  ((dPitch / Bpp << DE_WINDOW_WIDTH_DST_SHIFT) &\n\t\t   DE_WINDOW_WIDTH_DST_MASK) |\n\t\t  (sPitch / Bpp & DE_WINDOW_WIDTH_SRC_MASK));  \n\n\tif (accel->de_wait() != 0)\n\t\treturn -1;\n\n\twrite_dpr(accel, DE_SOURCE,\n\t\t  ((sx << DE_SOURCE_X_K1_SHIFT) & DE_SOURCE_X_K1_MASK) |\n\t\t  (sy & DE_SOURCE_Y_K2_MASK));  \n\twrite_dpr(accel, DE_DESTINATION,\n\t\t  ((dx << DE_DESTINATION_X_SHIFT) & DE_DESTINATION_X_MASK) |\n\t\t  (dy & DE_DESTINATION_Y_MASK));  \n\twrite_dpr(accel, DE_DIMENSION,\n\t\t  ((width << DE_DIMENSION_X_SHIFT) & DE_DIMENSION_X_MASK) |\n\t\t  (height & DE_DIMENSION_Y_ET_MASK));  \n\n\tde_ctrl = (rop2 & DE_CONTROL_ROP_MASK) | DE_CONTROL_ROP_SELECT |\n\t\t((nDirection == RIGHT_TO_LEFT) ? DE_CONTROL_DIRECTION : 0) |\n\t\tDE_CONTROL_COMMAND_BITBLT | DE_CONTROL_STATUS;\n\twrite_dpr(accel, DE_CONTROL, de_ctrl);  \n\n\treturn 0;\n}\n\nstatic unsigned int deGetTransparency(struct lynx_accel *accel)\n{\n\tunsigned int de_ctrl;\n\n\tde_ctrl = read_dpr(accel, DE_CONTROL);\n\n\tde_ctrl &= (DE_CONTROL_TRANSPARENCY_MATCH |\n\t\t    DE_CONTROL_TRANSPARENCY_SELECT | DE_CONTROL_TRANSPARENCY);\n\n\treturn de_ctrl;\n}\n\n \nint sm750_hw_imageblit(struct lynx_accel *accel, const char *pSrcbuf,\n\t\t       u32 srcDelta, u32 startBit, u32 dBase, u32 dPitch,\n\t\t       u32 bytePerPixel, u32 dx, u32 dy, u32 width,\n\t\t       u32 height, u32 fColor, u32 bColor, u32 rop2)\n{\n\tunsigned int ulBytesPerScan;\n\tunsigned int ul4BytesPerScan;\n\tunsigned int ulBytesRemain;\n\tunsigned int de_ctrl = 0;\n\tunsigned char ajRemain[4];\n\tint i, j;\n\n\tstartBit &= 7;  \n\tulBytesPerScan = (width + startBit + 7) / 8;\n\tul4BytesPerScan = ulBytesPerScan & ~3;\n\tulBytesRemain = ulBytesPerScan & 3;\n\n\tif (accel->de_wait() != 0)\n\t\treturn -1;\n\n\t \n\twrite_dpr(accel, DE_WINDOW_SOURCE_BASE, 0);\n\n\t \n\twrite_dpr(accel, DE_WINDOW_DESTINATION_BASE, dBase);\n\n\t \n\twrite_dpr(accel, DE_PITCH,\n\t\t  ((dPitch / bytePerPixel << DE_PITCH_DESTINATION_SHIFT) &\n\t\t   DE_PITCH_DESTINATION_MASK) |\n\t\t  (dPitch / bytePerPixel & DE_PITCH_SOURCE_MASK));  \n\n\t \n\twrite_dpr(accel, DE_WINDOW_WIDTH,\n\t\t  ((dPitch / bytePerPixel << DE_WINDOW_WIDTH_DST_SHIFT) &\n\t\t   DE_WINDOW_WIDTH_DST_MASK) |\n\t\t  (dPitch / bytePerPixel & DE_WINDOW_WIDTH_SRC_MASK));\n\n\t  \n\twrite_dpr(accel, DE_SOURCE,\n\t\t  (startBit << DE_SOURCE_X_K1_SHIFT) &\n\t\t  DE_SOURCE_X_K1_MONO_MASK);  \n\n\twrite_dpr(accel, DE_DESTINATION,\n\t\t  ((dx << DE_DESTINATION_X_SHIFT) & DE_DESTINATION_X_MASK) |\n\t\t  (dy & DE_DESTINATION_Y_MASK));  \n\n\twrite_dpr(accel, DE_DIMENSION,\n\t\t  ((width << DE_DIMENSION_X_SHIFT) & DE_DIMENSION_X_MASK) |\n\t\t  (height & DE_DIMENSION_Y_ET_MASK));  \n\n\twrite_dpr(accel, DE_FOREGROUND, fColor);\n\twrite_dpr(accel, DE_BACKGROUND, bColor);\n\n\tde_ctrl = (rop2 & DE_CONTROL_ROP_MASK) |\n\t\tDE_CONTROL_ROP_SELECT | DE_CONTROL_COMMAND_HOST_WRITE |\n\t\tDE_CONTROL_HOST | DE_CONTROL_STATUS;\n\n\twrite_dpr(accel, DE_CONTROL, de_ctrl | deGetTransparency(accel));\n\n\t \n\tfor (i = 0; i < height; i++) {\n\t\t \n\t\tfor (j = 0; j < (ul4BytesPerScan / 4); j++)\n\t\t\twrite_dpPort(accel, *(unsigned int *)(pSrcbuf + (j * 4)));\n\n\t\tif (ulBytesRemain) {\n\t\t\tmemcpy(ajRemain, pSrcbuf + ul4BytesPerScan,\n\t\t\t       ulBytesRemain);\n\t\t\twrite_dpPort(accel, *(unsigned int *)ajRemain);\n\t\t}\n\n\t\tpSrcbuf += srcDelta;\n\t}\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}