{
  "module_name": "ddk750_sii164.c",
  "hash_id": "8becf18773c780092732a505de6ae77e80603005b85f83bf89fab0f25ff05323",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/sm750fb/ddk750_sii164.c",
  "human_readable_source": "\n#define USE_DVICHIP\n#ifdef USE_DVICHIP\n\n#include \"ddk750_sii164.h\"\n#include \"ddk750_hwi2c.h\"\n\n \n#define SII164_I2C_ADDRESS                  0x70\n\n \n#define USE_HW_I2C\n\n#ifdef USE_HW_I2C\n    #define i2cWriteReg sm750_hw_i2c_write_reg\n    #define i2cReadReg  sm750_hw_i2c_read_reg\n#else\n    #define i2cWriteReg sm750_sw_i2c_write_reg\n    #define i2cReadReg  sm750_sw_i2c_read_reg\n#endif\n\n \n#define SII164_VENDOR_ID                    0x0001\n#define SII164_DEVICE_ID                    0x0006\n\n#ifdef SII164_FULL_FUNCTIONS\n \nstatic char *gDviCtrlChipName = \"Silicon Image SiI 164\";\n#endif\n\n \nunsigned short sii164_get_vendor_id(void)\n{\n\tunsigned short vendorID;\n\n\tvendorID = ((unsigned short)i2cReadReg(SII164_I2C_ADDRESS,\n\t\t\t\t\t       SII164_VENDOR_ID_HIGH) << 8) |\n\t\t   (unsigned short)i2cReadReg(SII164_I2C_ADDRESS,\n\t\t\t\t\t      SII164_VENDOR_ID_LOW);\n\n\treturn vendorID;\n}\n\n \nunsigned short sii164GetDeviceID(void)\n{\n\tunsigned short deviceID;\n\n\tdeviceID = ((unsigned short)i2cReadReg(SII164_I2C_ADDRESS,\n\t\t\t\t\t       SII164_DEVICE_ID_HIGH) << 8) |\n\t\t   (unsigned short)i2cReadReg(SII164_I2C_ADDRESS,\n\t\t\t\t\t      SII164_DEVICE_ID_LOW);\n\n\treturn deviceID;\n}\n\n \n\n \nlong sii164_init_chip(unsigned char edge_select,\n\t\t      unsigned char bus_select,\n\t\t      unsigned char dual_edge_clk_select,\n\t\t      unsigned char hsync_enable,\n\t\t      unsigned char vsync_enable,\n\t\t      unsigned char deskew_enable,\n\t\t      unsigned char deskew_setting,\n\t\t      unsigned char continuous_sync_enable,\n\t\t      unsigned char pll_filter_enable,\n\t\t      unsigned char pll_filter_value)\n{\n\tunsigned char config;\n\n\t \n#ifdef USE_HW_I2C\n\t \n\tsm750_hw_i2c_init(1);\n#else\n\tsm750_sw_i2c_init(DEFAULT_I2C_SCL, DEFAULT_I2C_SDA);\n#endif\n\n\t \n\tif ((sii164_get_vendor_id() == SII164_VENDOR_ID) &&\n\t    (sii164GetDeviceID() == SII164_DEVICE_ID)) {\n\t\t \n\n\t\t \n\t\tif (edge_select == 0)\n\t\t\tconfig = SII164_CONFIGURATION_LATCH_FALLING;\n\t\telse\n\t\t\tconfig = SII164_CONFIGURATION_LATCH_RISING;\n\n\t\t \n\t\tif (bus_select == 0)\n\t\t\tconfig |= SII164_CONFIGURATION_BUS_12BITS;\n\t\telse\n\t\t\tconfig |= SII164_CONFIGURATION_BUS_24BITS;\n\n\t\t \n\t\tif (dual_edge_clk_select == 0)\n\t\t\tconfig |= SII164_CONFIGURATION_CLOCK_SINGLE;\n\t\telse\n\t\t\tconfig |= SII164_CONFIGURATION_CLOCK_DUAL;\n\n\t\t \n\t\tif (hsync_enable == 0)\n\t\t\tconfig |= SII164_CONFIGURATION_HSYNC_FORCE_LOW;\n\t\telse\n\t\t\tconfig |= SII164_CONFIGURATION_HSYNC_AS_IS;\n\n\t\t \n\t\tif (vsync_enable == 0)\n\t\t\tconfig |= SII164_CONFIGURATION_VSYNC_FORCE_LOW;\n\t\telse\n\t\t\tconfig |= SII164_CONFIGURATION_VSYNC_AS_IS;\n\n\t\ti2cWriteReg(SII164_I2C_ADDRESS, SII164_CONFIGURATION, config);\n\n\t\t \n\t\tif (deskew_enable == 0)\n\t\t\tconfig = SII164_DESKEW_DISABLE;\n\t\telse\n\t\t\tconfig = SII164_DESKEW_ENABLE;\n\n\t\tswitch (deskew_setting) {\n\t\tcase 0:\n\t\t\tconfig |= SII164_DESKEW_1_STEP;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tconfig |= SII164_DESKEW_2_STEP;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tconfig |= SII164_DESKEW_3_STEP;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tconfig |= SII164_DESKEW_4_STEP;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tconfig |= SII164_DESKEW_5_STEP;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tconfig |= SII164_DESKEW_6_STEP;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tconfig |= SII164_DESKEW_7_STEP;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tconfig |= SII164_DESKEW_8_STEP;\n\t\t\tbreak;\n\t\t}\n\t\ti2cWriteReg(SII164_I2C_ADDRESS, SII164_DESKEW, config);\n\n\t\t \n\t\tif (continuous_sync_enable == 0)\n\t\t\tconfig = SII164_PLL_FILTER_SYNC_CONTINUOUS_DISABLE;\n\t\telse\n\t\t\tconfig = SII164_PLL_FILTER_SYNC_CONTINUOUS_ENABLE;\n\n\t\t \n\t\tif (pll_filter_enable == 0)\n\t\t\tconfig |= SII164_PLL_FILTER_DISABLE;\n\t\telse\n\t\t\tconfig |= SII164_PLL_FILTER_ENABLE;\n\n\t\t \n\t\tconfig |= ((pll_filter_value & 0x07) << 1);\n\n\t\ti2cWriteReg(SII164_I2C_ADDRESS, SII164_PLL, config);\n\n\t\t \n\t\tconfig = i2cReadReg(SII164_I2C_ADDRESS, SII164_CONFIGURATION);\n\t\tconfig |= SII164_CONFIGURATION_POWER_NORMAL;\n\t\ti2cWriteReg(SII164_I2C_ADDRESS, SII164_CONFIGURATION, config);\n\n\t\treturn 0;\n\t}\n\n\t \n\treturn -1;\n}\n\n \n\n#ifdef SII164_FULL_FUNCTIONS\n\n \nvoid sii164ResetChip(void)\n{\n\t \n\tsii164SetPower(0);\n\tsii164SetPower(1);\n}\n\n \nchar *sii164GetChipString(void)\n{\n\treturn gDviCtrlChipName;\n}\n\n \nvoid sii164SetPower(unsigned char powerUp)\n{\n\tunsigned char config;\n\n\tconfig = i2cReadReg(SII164_I2C_ADDRESS, SII164_CONFIGURATION);\n\tif (powerUp == 1) {\n\t\t \n\t\tconfig &= ~SII164_CONFIGURATION_POWER_MASK;\n\t\tconfig |= SII164_CONFIGURATION_POWER_NORMAL;\n\t\ti2cWriteReg(SII164_I2C_ADDRESS, SII164_CONFIGURATION, config);\n\t} else {\n\t\t \n\t\tconfig &= ~SII164_CONFIGURATION_POWER_MASK;\n\t\tconfig |= SII164_CONFIGURATION_POWER_DOWN;\n\t\ti2cWriteReg(SII164_I2C_ADDRESS, SII164_CONFIGURATION, config);\n\t}\n}\n\n \nstatic\nvoid sii164SelectHotPlugDetectionMode(enum sii164_hot_plug_mode hotPlugMode)\n{\n\tunsigned char detectReg;\n\n\tdetectReg = i2cReadReg(SII164_I2C_ADDRESS, SII164_DETECT) &\n\t\t    ~SII164_DETECT_MONITOR_SENSE_OUTPUT_FLAG;\n\tswitch (hotPlugMode) {\n\tcase SII164_HOTPLUG_DISABLE:\n\t\tdetectReg |= SII164_DETECT_MONITOR_SENSE_OUTPUT_HIGH;\n\t\tbreak;\n\tcase SII164_HOTPLUG_USE_MDI:\n\t\tdetectReg &= ~SII164_DETECT_INTERRUPT_MASK;\n\t\tdetectReg |= SII164_DETECT_INTERRUPT_BY_HTPLG_PIN;\n\t\tdetectReg |= SII164_DETECT_MONITOR_SENSE_OUTPUT_MDI;\n\t\tbreak;\n\tcase SII164_HOTPLUG_USE_RSEN:\n\t\tdetectReg |= SII164_DETECT_MONITOR_SENSE_OUTPUT_RSEN;\n\t\tbreak;\n\tcase SII164_HOTPLUG_USE_HTPLG:\n\t\tdetectReg |= SII164_DETECT_MONITOR_SENSE_OUTPUT_HTPLG;\n\t\tbreak;\n\t}\n\n\ti2cWriteReg(SII164_I2C_ADDRESS, SII164_DETECT, detectReg);\n}\n\n \nvoid sii164EnableHotPlugDetection(unsigned char enableHotPlug)\n{\n\tunsigned char detectReg;\n\n\tdetectReg = i2cReadReg(SII164_I2C_ADDRESS, SII164_DETECT);\n\n\t \n\tif (enableHotPlug != 0)\n\t\tsii164SelectHotPlugDetectionMode(SII164_HOTPLUG_USE_MDI);\n\telse\n\t\tsii164SelectHotPlugDetectionMode(SII164_HOTPLUG_DISABLE);\n}\n\n \nunsigned char sii164IsConnected(void)\n{\n\tunsigned char hotPlugValue;\n\n\thotPlugValue = i2cReadReg(SII164_I2C_ADDRESS, SII164_DETECT) &\n\t\t       SII164_DETECT_HOT_PLUG_STATUS_MASK;\n\tif (hotPlugValue == SII164_DETECT_HOT_PLUG_STATUS_ON)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nunsigned char sii164CheckInterrupt(void)\n{\n\tunsigned char detectReg;\n\n\tdetectReg = i2cReadReg(SII164_I2C_ADDRESS, SII164_DETECT) &\n\t\t    SII164_DETECT_MONITOR_STATE_MASK;\n\tif (detectReg == SII164_DETECT_MONITOR_STATE_CHANGE)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nvoid sii164ClearInterrupt(void)\n{\n\tunsigned char detectReg;\n\n\t \n\tdetectReg = i2cReadReg(SII164_I2C_ADDRESS, SII164_DETECT);\n\ti2cWriteReg(SII164_I2C_ADDRESS, SII164_DETECT,\n\t\t    detectReg | SII164_DETECT_MONITOR_STATE_CLEAR);\n}\n\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}