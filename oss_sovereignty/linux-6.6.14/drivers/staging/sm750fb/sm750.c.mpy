{
  "module_name": "sm750.c",
  "hash_id": "78a03fd4ce5afc1583abd8728449f34577e47eade4d1c85476e7df2e2a6f73c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/sm750fb/sm750.c",
  "human_readable_source": "\n#include <linux/aperture.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fb.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/mm_types.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/console.h>\n\n#include \"sm750.h\"\n#include \"sm750_accel.h\"\n#include \"sm750_cursor.h\"\n\n \n\n \nstatic int g_hwcursor = 1;\nstatic int g_noaccel;\nstatic int g_nomtrr;\nstatic const char *g_fbmode[] = {NULL, NULL};\nstatic const char *g_def_fbmode = \"1024x768-32@60\";\nstatic char *g_settings;\nstatic int g_dualview;\nstatic char *g_option;\n\nstatic const struct fb_videomode lynx750_ext[] = {\n\t \n\t{NULL,  60, 1024, 600, 20423, 144,  40, 18, 1, 104, 3,\n\t FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t FB_VMODE_NONINTERLACED},\n\n\t \n\t{NULL,  70, 1024, 600, 17211, 152,  48, 21, 1, 104, 3,\n\t FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t FB_VMODE_NONINTERLACED},\n\n\t \n\t{NULL,  75, 1024, 600, 15822, 160,  56, 23, 1, 104, 3,\n\t FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t FB_VMODE_NONINTERLACED},\n\n\t \n\t{NULL,  85, 1024, 600, 13730, 168,  56, 26, 1, 112, 3,\n\t FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t FB_VMODE_NONINTERLACED},\n\n\t \n\t{NULL, 60,  720,  480,  37427, 88,   16, 13, 1,   72,  3,\n\t FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t FB_VMODE_NONINTERLACED},\n\n\t \n\t{NULL, 60,  1280,  720,  13426, 162, 86, 22, 1,  136, 3,\n\t FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t FB_VMODE_NONINTERLACED},\n\n\t \n\t{NULL, 60, 1280, 768, 12579, 192, 64, 20, 3, 128, 7,\n\t FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t FB_VMODE_NONINTERLACED},\n\n\t \n\t{NULL,  60, 1360, 768, 11804, 208,  64, 23, 1, 144, 3,\n\t FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t FB_VMODE_NONINTERLACED},\n\n\t \n\t{NULL, 60,  1368,  768,  11647, 216, 72, 23, 1,  144, 3,\n\t FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t FB_VMODE_NONINTERLACED},\n\n\t \n\t{NULL, 60, 1440, 900, 9392, 232, 80, 28, 1, 152, 3,\n\t FB_SYNC_VERT_HIGH_ACT,\n\t FB_VMODE_NONINTERLACED},\n\n\t \n\t{NULL, 60, 1440, 960, 8733, 240, 88, 30, 1, 152, 3,\n\t FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,\n\t FB_VMODE_NONINTERLACED},\n\n\t \n\t{NULL, 60, 1920, 1080, 6734, 148, 88, 41, 1, 44, 3,\n\t FB_SYNC_VERT_HIGH_ACT,\n\t FB_VMODE_NONINTERLACED},\n};\n\n \nstatic int lynxfb_ops_cursor(struct fb_info *info, struct fb_cursor *fbcursor)\n{\n\tstruct lynxfb_par *par;\n\tstruct lynxfb_crtc *crtc;\n\tstruct lynx_cursor *cursor;\n\n\tpar = info->par;\n\tcrtc = &par->crtc;\n\tcursor = &crtc->cursor;\n\n\tif (fbcursor->image.width > cursor->max_w ||\n\t    fbcursor->image.height > cursor->max_h ||\n\t    fbcursor->image.depth > 1) {\n\t\treturn -ENXIO;\n\t}\n\n\tsm750_hw_cursor_disable(cursor);\n\tif (fbcursor->set & FB_CUR_SETSIZE)\n\t\tsm750_hw_cursor_setSize(cursor,\n\t\t\t\t\tfbcursor->image.width,\n\t\t\t\t\tfbcursor->image.height);\n\n\tif (fbcursor->set & FB_CUR_SETPOS)\n\t\tsm750_hw_cursor_setPos(cursor,\n\t\t\t\t       fbcursor->image.dx - info->var.xoffset,\n\t\t\t\t       fbcursor->image.dy - info->var.yoffset);\n\n\tif (fbcursor->set & FB_CUR_SETCMAP) {\n\t\t \n\t\tu16 fg, bg;\n\n\t\tfg = ((info->cmap.red[fbcursor->image.fg_color] & 0xf800)) |\n\t\t     ((info->cmap.green[fbcursor->image.fg_color] & 0xfc00) >> 5) |\n\t\t     ((info->cmap.blue[fbcursor->image.fg_color] & 0xf800) >> 11);\n\n\t\tbg = ((info->cmap.red[fbcursor->image.bg_color] & 0xf800)) |\n\t\t     ((info->cmap.green[fbcursor->image.bg_color] & 0xfc00) >> 5) |\n\t\t     ((info->cmap.blue[fbcursor->image.bg_color] & 0xf800) >> 11);\n\n\t\tsm750_hw_cursor_setColor(cursor, fg, bg);\n\t}\n\n\tif (fbcursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {\n\t\tsm750_hw_cursor_setData(cursor,\n\t\t\t\t\tfbcursor->rop,\n\t\t\t\t\tfbcursor->image.data,\n\t\t\t\t\tfbcursor->mask);\n\t}\n\n\tif (fbcursor->enable)\n\t\tsm750_hw_cursor_enable(cursor);\n\n\treturn 0;\n}\n\nstatic void lynxfb_ops_fillrect(struct fb_info *info,\n\t\t\t\tconst struct fb_fillrect *region)\n{\n\tstruct lynxfb_par *par;\n\tstruct sm750_dev *sm750_dev;\n\tunsigned int base, pitch, Bpp, rop;\n\tu32 color;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn;\n\n\tpar = info->par;\n\tsm750_dev = par->dev;\n\n\t \n\tbase = par->crtc.o_screen;\n\tpitch = info->fix.line_length;\n\tBpp = info->var.bits_per_pixel >> 3;\n\n\tcolor = (Bpp == 1) ? region->color :\n\t\t((u32 *)info->pseudo_palette)[region->color];\n\trop = (region->rop != ROP_COPY) ? HW_ROP2_XOR : HW_ROP2_COPY;\n\n\t \n\tspin_lock(&sm750_dev->slock);\n\n\tsm750_dev->accel.de_fillrect(&sm750_dev->accel,\n\t\t\t\t     base, pitch, Bpp,\n\t\t\t\t     region->dx, region->dy,\n\t\t\t\t     region->width, region->height,\n\t\t\t\t     color, rop);\n\tspin_unlock(&sm750_dev->slock);\n}\n\nstatic void lynxfb_ops_copyarea(struct fb_info *info,\n\t\t\t\tconst struct fb_copyarea *region)\n{\n\tstruct lynxfb_par *par;\n\tstruct sm750_dev *sm750_dev;\n\tunsigned int base, pitch, Bpp;\n\n\tpar = info->par;\n\tsm750_dev = par->dev;\n\n\t \n\tbase = par->crtc.o_screen;\n\tpitch = info->fix.line_length;\n\tBpp = info->var.bits_per_pixel >> 3;\n\n\t \n\tspin_lock(&sm750_dev->slock);\n\n\tsm750_dev->accel.de_copyarea(&sm750_dev->accel,\n\t\t\t\t     base, pitch, region->sx, region->sy,\n\t\t\t\t     base, pitch, Bpp, region->dx, region->dy,\n\t\t\t\t     region->width, region->height,\n\t\t\t\t     HW_ROP2_COPY);\n\tspin_unlock(&sm750_dev->slock);\n}\n\nstatic void lynxfb_ops_imageblit(struct fb_info *info,\n\t\t\t\t const struct fb_image *image)\n{\n\tunsigned int base, pitch, Bpp;\n\tunsigned int fgcol, bgcol;\n\tstruct lynxfb_par *par;\n\tstruct sm750_dev *sm750_dev;\n\n\tpar = info->par;\n\tsm750_dev = par->dev;\n\t \n\tbase = par->crtc.o_screen;\n\tpitch = info->fix.line_length;\n\tBpp = info->var.bits_per_pixel >> 3;\n\n\t \n\tif (image->depth != 1) {\n\t\tcfb_imageblit(info, image);\n\t\treturn;\n\t}\n\n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\n\t    info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\n\t\tfgcol = ((u32 *)info->pseudo_palette)[image->fg_color];\n\t\tbgcol = ((u32 *)info->pseudo_palette)[image->bg_color];\n\t} else {\n\t\tfgcol = image->fg_color;\n\t\tbgcol = image->bg_color;\n\t}\n\n\t \n\tspin_lock(&sm750_dev->slock);\n\n\tsm750_dev->accel.de_imageblit(&sm750_dev->accel,\n\t\t\t\t      image->data, image->width >> 3, 0,\n\t\t\t\t      base, pitch, Bpp,\n\t\t\t\t      image->dx, image->dy,\n\t\t\t\t      image->width, image->height,\n\t\t\t\t      fgcol, bgcol, HW_ROP2_COPY);\n\tspin_unlock(&sm750_dev->slock);\n}\n\nstatic int lynxfb_ops_pan_display(struct fb_var_screeninfo *var,\n\t\t\t\t  struct fb_info *info)\n{\n\tstruct lynxfb_par *par;\n\tstruct lynxfb_crtc *crtc;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tpar = info->par;\n\tcrtc = &par->crtc;\n\treturn hw_sm750_pan_display(crtc, var, info);\n}\n\nstatic inline void lynxfb_set_visual_mode(struct fb_info *info)\n{\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\tbreak;\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic inline int lynxfb_set_color_offsets(struct fb_info *info)\n{\n\tlynxfb_set_visual_mode(info);\n\n\tswitch (info->var.bits_per_pixel) {\n\tcase 8:\n\t\tinfo->var.red.offset = 0;\n\t\tinfo->var.red.length = 8;\n\t\tinfo->var.green.offset = 0;\n\t\tinfo->var.green.length = 8;\n\t\tinfo->var.blue.offset = 0;\n\t\tinfo->var.blue.length = 8;\n\t\tinfo->var.transp.length = 0;\n\t\tinfo->var.transp.offset = 0;\n\t\tbreak;\n\tcase 16:\n\t\tinfo->var.red.offset = 11;\n\t\tinfo->var.red.length = 5;\n\t\tinfo->var.green.offset = 5;\n\t\tinfo->var.green.length = 6;\n\t\tinfo->var.blue.offset = 0;\n\t\tinfo->var.blue.length = 5;\n\t\tinfo->var.transp.length = 0;\n\t\tinfo->var.transp.offset = 0;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tinfo->var.red.offset = 16;\n\t\tinfo->var.red.length = 8;\n\t\tinfo->var.green.offset = 8;\n\t\tinfo->var.green.length = 8;\n\t\tinfo->var.blue.offset = 0;\n\t\tinfo->var.blue.length = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int lynxfb_ops_set_par(struct fb_info *info)\n{\n\tstruct lynxfb_par *par;\n\tstruct lynxfb_crtc *crtc;\n\tstruct lynxfb_output *output;\n\tstruct fb_var_screeninfo *var;\n\tstruct fb_fix_screeninfo *fix;\n\tint ret;\n\tunsigned int line_length;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tret = 0;\n\tpar = info->par;\n\tcrtc = &par->crtc;\n\toutput = &par->output;\n\tvar = &info->var;\n\tfix = &info->fix;\n\n\t \n\tline_length = var->xres_virtual * var->bits_per_pixel / 8;\n\tline_length = ALIGN(line_length, crtc->line_pad);\n\tfix->line_length = line_length;\n\tpr_info(\"fix->line_length = %d\\n\", fix->line_length);\n\n\t \n\n\tret = lynxfb_set_color_offsets(info);\n\n\tvar->height = -1;\n\tvar->width = -1;\n\tvar->accel_flags = 0; \n\n\tif (ret) {\n\t\tpr_err(\"bpp %d not supported\\n\", var->bits_per_pixel);\n\t\treturn ret;\n\t}\n\tret = hw_sm750_crtc_setMode(crtc, var, fix);\n\tif (!ret)\n\t\tret = hw_sm750_output_setMode(output, var, fix);\n\treturn ret;\n}\n\nstatic inline unsigned int chan_to_field(unsigned int chan,\n\t\t\t\t\t struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\nstatic int __maybe_unused lynxfb_suspend(struct device *dev)\n{\n\tstruct fb_info *info;\n\tstruct sm750_dev *sm750_dev;\n\n\tsm750_dev = dev_get_drvdata(dev);\n\n\tconsole_lock();\n\tinfo = sm750_dev->fbinfo[0];\n\tif (info)\n\t\t \n\t\tfb_set_suspend(info, 1);\n\tinfo = sm750_dev->fbinfo[1];\n\tif (info)\n\t\t \n\t\tfb_set_suspend(info, 1);\n\n\tconsole_unlock();\n\treturn 0;\n}\n\nstatic int __maybe_unused lynxfb_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct fb_info *info;\n\tstruct sm750_dev *sm750_dev;\n\n\tstruct lynxfb_par *par;\n\tstruct lynxfb_crtc *crtc;\n\tstruct lynx_cursor *cursor;\n\n\tsm750_dev = pci_get_drvdata(pdev);\n\n\tconsole_lock();\n\n\thw_sm750_inithw(sm750_dev, pdev);\n\n\tinfo = sm750_dev->fbinfo[0];\n\n\tif (info) {\n\t\tpar = info->par;\n\t\tcrtc = &par->crtc;\n\t\tcursor = &crtc->cursor;\n\t\tmemset_io(cursor->vstart, 0x0, cursor->size);\n\t\tmemset_io(crtc->v_screen, 0x0, crtc->vidmem_size);\n\t\tlynxfb_ops_set_par(info);\n\t\tfb_set_suspend(info, 0);\n\t}\n\n\tinfo = sm750_dev->fbinfo[1];\n\n\tif (info) {\n\t\tpar = info->par;\n\t\tcrtc = &par->crtc;\n\t\tcursor = &crtc->cursor;\n\t\tmemset_io(cursor->vstart, 0x0, cursor->size);\n\t\tmemset_io(crtc->v_screen, 0x0, crtc->vidmem_size);\n\t\tlynxfb_ops_set_par(info);\n\t\tfb_set_suspend(info, 0);\n\t}\n\n\tpdev->dev.power.power_state.event = PM_EVENT_RESUME;\n\n\tconsole_unlock();\n\treturn 0;\n}\n\nstatic int lynxfb_ops_check_var(struct fb_var_screeninfo *var,\n\t\t\t\tstruct fb_info *info)\n{\n\tint ret;\n\tstruct lynxfb_par *par;\n\tstruct lynxfb_crtc *crtc;\n\tresource_size_t request;\n\n\tret = 0;\n\tpar = info->par;\n\tcrtc = &par->crtc;\n\n\tpr_debug(\"check var:%dx%d-%d\\n\",\n\t\t var->xres,\n\t\t var->yres,\n\t\t var->bits_per_pixel);\n\n\tret = lynxfb_set_color_offsets(info);\n\n\tif (ret) {\n\t\tpr_err(\"bpp %d not supported\\n\", var->bits_per_pixel);\n\t\treturn ret;\n\t}\n\n\tvar->height = -1;\n\tvar->width = -1;\n\tvar->accel_flags = 0; \n\n\t \n\trequest = var->xres_virtual * (var->bits_per_pixel >> 3);\n\t \n\n\trequest = ALIGN(request, crtc->line_pad);\n\trequest = request * var->yres_virtual;\n\tif (crtc->vidmem_size < request) {\n\t\tpr_err(\"not enough video memory for mode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn hw_sm750_crtc_checkMode(crtc, var);\n}\n\nstatic int lynxfb_ops_setcolreg(unsigned int regno,\n\t\t\t\tunsigned int red,\n\t\t\t\tunsigned int green,\n\t\t\t\tunsigned int blue,\n\t\t\t\tunsigned int transp,\n\t\t\t\tstruct fb_info *info)\n{\n\tstruct lynxfb_par *par;\n\tstruct lynxfb_crtc *crtc;\n\tstruct fb_var_screeninfo *var;\n\tint ret;\n\n\tpar = info->par;\n\tcrtc = &par->crtc;\n\tvar = &info->var;\n\tret = 0;\n\n\tif (regno > 256) {\n\t\tpr_err(\"regno = %d\\n\", regno);\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->var.grayscale)\n\t\tred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\n\n\tif (var->bits_per_pixel == 8 &&\n\t    info->fix.visual == FB_VISUAL_PSEUDOCOLOR) {\n\t\tred >>= 8;\n\t\tgreen >>= 8;\n\t\tblue >>= 8;\n\t\tret = hw_sm750_setColReg(crtc, regno, red, green, blue);\n\t\tgoto exit;\n\t}\n\n\tif (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 256) {\n\t\tu32 val;\n\n\t\tif (var->bits_per_pixel == 16 ||\n\t\t    var->bits_per_pixel == 32 ||\n\t\t    var->bits_per_pixel == 24) {\n\t\t\tval = chan_to_field(red, &var->red);\n\t\t\tval |= chan_to_field(green, &var->green);\n\t\t\tval |= chan_to_field(blue, &var->blue);\n\t\t\tpar->pseudo_palette[regno] = val;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tret = -EINVAL;\n\nexit:\n\treturn ret;\n}\n\nstatic int lynxfb_ops_blank(int blank, struct fb_info *info)\n{\n\tstruct lynxfb_par *par;\n\tstruct lynxfb_output *output;\n\n\tpr_debug(\"blank = %d.\\n\", blank);\n\tpar = info->par;\n\toutput = &par->output;\n\treturn output->proc_setBLANK(output, blank);\n}\n\nstatic int sm750fb_set_drv(struct lynxfb_par *par)\n{\n\tint ret;\n\tstruct sm750_dev *sm750_dev;\n\tstruct lynxfb_output *output;\n\tstruct lynxfb_crtc *crtc;\n\n\tret = 0;\n\n\tsm750_dev = par->dev;\n\toutput = &par->output;\n\tcrtc = &par->crtc;\n\n\tcrtc->vidmem_size = sm750_dev->vidmem_size;\n\tif (sm750_dev->fb_count > 1)\n\t\tcrtc->vidmem_size >>= 1;\n\n\t \n\tsm750_dev->hwCursor = g_hwcursor;\n\n\tcrtc->line_pad = 16;\n\tcrtc->xpanstep = 8;\n\tcrtc->ypanstep = 1;\n\tcrtc->ywrapstep = 0;\n\n\toutput->proc_setBLANK = (sm750_dev->revid == SM750LE_REVISION_ID) ?\n\t\t\t\t hw_sm750le_setBLANK : hw_sm750_setBLANK;\n\t \n\tsm750_dev->accel.de_wait = (sm750_dev->revid == SM750LE_REVISION_ID) ?\n\t\t\t\t    hw_sm750le_deWait : hw_sm750_deWait;\n\tswitch (sm750_dev->dataflow) {\n\tcase sm750_simul_pri:\n\t\toutput->paths = sm750_pnc;\n\t\tcrtc->channel = sm750_primary;\n\t\tcrtc->o_screen = 0;\n\t\tcrtc->v_screen = sm750_dev->pvMem;\n\t\tpr_info(\"use simul primary mode\\n\");\n\t\tbreak;\n\tcase sm750_simul_sec:\n\t\toutput->paths = sm750_pnc;\n\t\tcrtc->channel = sm750_secondary;\n\t\tcrtc->o_screen = 0;\n\t\tcrtc->v_screen = sm750_dev->pvMem;\n\t\tbreak;\n\tcase sm750_dual_normal:\n\t\tif (par->index == 0) {\n\t\t\toutput->paths = sm750_panel;\n\t\t\tcrtc->channel = sm750_primary;\n\t\t\tcrtc->o_screen = 0;\n\t\t\tcrtc->v_screen = sm750_dev->pvMem;\n\t\t} else {\n\t\t\toutput->paths = sm750_crt;\n\t\t\tcrtc->channel = sm750_secondary;\n\t\t\t \n\t\t\tcrtc->o_screen = sm750_dev->vidmem_size >> 1;\n\t\t\tcrtc->v_screen = sm750_dev->pvMem + crtc->o_screen;\n\t\t}\n\t\tbreak;\n\tcase sm750_dual_swap:\n\t\tif (par->index == 0) {\n\t\t\toutput->paths = sm750_panel;\n\t\t\tcrtc->channel = sm750_secondary;\n\t\t\tcrtc->o_screen = 0;\n\t\t\tcrtc->v_screen = sm750_dev->pvMem;\n\t\t} else {\n\t\t\toutput->paths = sm750_crt;\n\t\t\tcrtc->channel = sm750_primary;\n\t\t\t \n\t\t\tcrtc->o_screen = sm750_dev->vidmem_size >> 1;\n\t\t\tcrtc->v_screen = sm750_dev->pvMem + crtc->o_screen;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic struct fb_ops lynxfb_ops = {\n\t.owner = THIS_MODULE,\n\t.fb_check_var =  lynxfb_ops_check_var,\n\t.fb_set_par = lynxfb_ops_set_par,\n\t.fb_setcolreg = lynxfb_ops_setcolreg,\n\t.fb_blank = lynxfb_ops_blank,\n\t.fb_fillrect = cfb_fillrect,\n\t.fb_imageblit = cfb_imageblit,\n\t.fb_copyarea = cfb_copyarea,\n\t \n\t.fb_cursor = lynxfb_ops_cursor,\n};\n\nstatic int lynxfb_set_fbinfo(struct fb_info *info, int index)\n{\n\tint i;\n\tstruct lynxfb_par *par;\n\tstruct sm750_dev *sm750_dev;\n\tstruct lynxfb_crtc *crtc;\n\tstruct lynxfb_output *output;\n\tstruct fb_var_screeninfo *var;\n\tstruct fb_fix_screeninfo *fix;\n\n\tconst struct fb_videomode *pdb[] = {\n\t\tlynx750_ext, NULL, vesa_modes,\n\t};\n\tint cdb[] = {ARRAY_SIZE(lynx750_ext), 0, VESA_MODEDB_SIZE};\n\tstatic const char * const mdb_desc[] = {\n\t\t\"driver prepared modes\",\n\t\t\"kernel prepared default modedb\",\n\t\t\"kernel HELPERS prepared vesa_modes\",\n\t};\n\n\tstatic const char *fixId[2] = {\n\t\t\"sm750_fb1\", \"sm750_fb2\",\n\t};\n\n\tint ret, line_length;\n\n\tret = 0;\n\tpar = (struct lynxfb_par *)info->par;\n\tsm750_dev = par->dev;\n\tcrtc = &par->crtc;\n\toutput = &par->output;\n\tvar = &info->var;\n\tfix = &info->fix;\n\n\t \n\tpar->index = index;\n\toutput->channel = &crtc->channel;\n\tsm750fb_set_drv(par);\n\tlynxfb_ops.fb_pan_display = lynxfb_ops_pan_display;\n\n\t \n\tcrtc->cursor.offset = crtc->o_screen + crtc->vidmem_size - 1024;\n\tcrtc->cursor.mmio = sm750_dev->pvReg +\n\t\t0x800f0 + (int)crtc->channel * 0x140;\n\n\tpr_info(\"crtc->cursor.mmio = %p\\n\", crtc->cursor.mmio);\n\tcrtc->cursor.max_h = 64;\n\tcrtc->cursor.max_w = 64;\n\tcrtc->cursor.size = crtc->cursor.max_h * crtc->cursor.max_w * 2 / 8;\n\tcrtc->cursor.vstart = sm750_dev->pvMem + crtc->cursor.offset;\n\n\tmemset_io(crtc->cursor.vstart, 0, crtc->cursor.size);\n\tif (!g_hwcursor) {\n\t\tlynxfb_ops.fb_cursor = NULL;\n\t\tsm750_hw_cursor_disable(&crtc->cursor);\n\t}\n\n\t \n\tif (!sm750_dev->accel_off) {\n\t\t \n\t\tlynxfb_ops.fb_fillrect = lynxfb_ops_fillrect;\n\t\tlynxfb_ops.fb_copyarea = lynxfb_ops_copyarea;\n\t\tlynxfb_ops.fb_imageblit = lynxfb_ops_imageblit;\n\t}\n\tinfo->fbops = &lynxfb_ops;\n\n\tif (!g_fbmode[index]) {\n\t\tg_fbmode[index] = g_def_fbmode;\n\t\tif (index)\n\t\t\tg_fbmode[index] = g_fbmode[0];\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = fb_find_mode(var, info, g_fbmode[index],\n\t\t\t\t   pdb[i], cdb[i], NULL, 8);\n\n\t\tif (ret == 1) {\n\t\t\tpr_info(\"success! use specified mode:%s in %s\\n\",\n\t\t\t\tg_fbmode[index],\n\t\t\t\tmdb_desc[i]);\n\t\t\tbreak;\n\t\t} else if (ret == 2) {\n\t\t\tpr_warn(\"use specified mode:%s in %s,with an ignored refresh rate\\n\",\n\t\t\t\tg_fbmode[index],\n\t\t\t\tmdb_desc[i]);\n\t\t\tbreak;\n\t\t} else if (ret == 3) {\n\t\t\tpr_warn(\"wanna use default mode\\n\");\n\t\t\t \n\t\t} else if (ret == 4) {\n\t\t\tpr_warn(\"fall back to any valid mode\\n\");\n\t\t} else {\n\t\t\tpr_warn(\"ret = %d,fb_find_mode failed,with %s\\n\",\n\t\t\t\tret,\n\t\t\t\tmdb_desc[i]);\n\t\t}\n\t}\n\n\t \n\n\tpr_info(\"Member of info->var is :\\n\"\n\t\t\"xres=%d\\n\"\n\t\t\"yres=%d\\n\"\n\t\t\"xres_virtual=%d\\n\"\n\t\t\"yres_virtual=%d\\n\"\n\t\t\"xoffset=%d\\n\"\n\t\t\"yoffset=%d\\n\"\n\t\t\"bits_per_pixel=%d\\n\"\n\t\t\" ...\\n\",\n\t\tvar->xres,\n\t\tvar->yres,\n\t\tvar->xres_virtual,\n\t\tvar->yres_virtual,\n\t\tvar->xoffset,\n\t\tvar->yoffset,\n\t\tvar->bits_per_pixel);\n\n\t \n\tpar->info = info;\n\n\t \n\tline_length = ALIGN((var->xres_virtual * var->bits_per_pixel / 8),\n\t\t\t    crtc->line_pad);\n\n\tinfo->pseudo_palette = &par->pseudo_palette[0];\n\tinfo->screen_base = crtc->v_screen;\n\tpr_debug(\"screen_base vaddr = %p\\n\", info->screen_base);\n\tinfo->screen_size = line_length * var->yres_virtual;\n\n\t \n\tfix->type = FB_TYPE_PACKED_PIXELS;\n\tfix->type_aux = 0;\n\tfix->xpanstep = crtc->xpanstep;\n\tfix->ypanstep = crtc->ypanstep;\n\tfix->ywrapstep = crtc->ywrapstep;\n\tfix->accel = FB_ACCEL_SMI;\n\n\tstrscpy(fix->id, fixId[index], sizeof(fix->id));\n\n\tfix->smem_start = crtc->o_screen + sm750_dev->vidmem_start;\n\tpr_info(\"fix->smem_start = %lx\\n\", fix->smem_start);\n\t \n\tfix->smem_len = crtc->vidmem_size;\n\tpr_info(\"fix->smem_len = %x\\n\", fix->smem_len);\n\tinfo->screen_size = fix->smem_len;\n\tfix->line_length = line_length;\n\tfix->mmio_start = sm750_dev->vidreg_start;\n\tpr_info(\"fix->mmio_start = %lx\\n\", fix->mmio_start);\n\tfix->mmio_len = sm750_dev->vidreg_size;\n\tpr_info(\"fix->mmio_len = %x\\n\", fix->mmio_len);\n\n\tlynxfb_set_visual_mode(info);\n\n\t \n\tvar->activate = FB_ACTIVATE_NOW;\n\tvar->accel_flags = 0;\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\n\tpr_debug(\"#1 show info->cmap :\\nstart=%d,len=%d,red=%p,green=%p,blue=%p,transp=%p\\n\",\n\t\t info->cmap.start, info->cmap.len,\n\t\t info->cmap.red, info->cmap.green, info->cmap.blue,\n\t\t info->cmap.transp);\n\n\tret = fb_alloc_cmap(&info->cmap, 256, 0);\n\tif (ret < 0) {\n\t\tpr_err(\"Could not allocate memory for cmap.\\n\");\n\t\tgoto exit;\n\t}\n\n\tpr_debug(\"#2 show info->cmap :\\nstart=%d,len=%d,red=%p,green=%p,blue=%p,transp=%p\\n\",\n\t\t info->cmap.start, info->cmap.len,\n\t\t info->cmap.red, info->cmap.green, info->cmap.blue,\n\t\t info->cmap.transp);\n\nexit:\n\tlynxfb_ops_check_var(var, info);\n\treturn ret;\n}\n\n \nstatic void sm750fb_setup(struct sm750_dev *sm750_dev, char *src)\n{\n\tchar *opt;\n\tint swap;\n\n\tswap = 0;\n\n\tsm750_dev->initParm.chip_clk = 0;\n\tsm750_dev->initParm.mem_clk = 0;\n\tsm750_dev->initParm.master_clk = 0;\n\tsm750_dev->initParm.powerMode = 0;\n\tsm750_dev->initParm.setAllEngOff = 0;\n\tsm750_dev->initParm.resetMemory = 1;\n\n\t \n\tg_hwcursor = 3;\n\n\tif (!src || !*src) {\n\t\tdev_warn(&sm750_dev->pdev->dev, \"no specific g_option.\\n\");\n\t\tgoto NO_PARAM;\n\t}\n\n\twhile ((opt = strsep(&src, \":\")) != NULL && *opt != 0) {\n\t\tdev_info(&sm750_dev->pdev->dev, \"opt=%s\\n\", opt);\n\t\tdev_info(&sm750_dev->pdev->dev, \"src=%s\\n\", src);\n\n\t\tif (!strncmp(opt, \"swap\", strlen(\"swap\"))) {\n\t\t\tswap = 1;\n\t\t} else if (!strncmp(opt, \"nocrt\", strlen(\"nocrt\"))) {\n\t\t\tsm750_dev->nocrt = 1;\n\t\t} else if (!strncmp(opt, \"36bit\", strlen(\"36bit\"))) {\n\t\t\tsm750_dev->pnltype = sm750_doubleTFT;\n\t\t} else if (!strncmp(opt, \"18bit\", strlen(\"18bit\"))) {\n\t\t\tsm750_dev->pnltype = sm750_dualTFT;\n\t\t} else if (!strncmp(opt, \"24bit\", strlen(\"24bit\"))) {\n\t\t\tsm750_dev->pnltype = sm750_24TFT;\n\t\t} else if (!strncmp(opt, \"nohwc0\", strlen(\"nohwc0\"))) {\n\t\t\tg_hwcursor &= ~0x1;\n\t\t} else if (!strncmp(opt, \"nohwc1\", strlen(\"nohwc1\"))) {\n\t\t\tg_hwcursor &= ~0x2;\n\t\t} else if (!strncmp(opt, \"nohwc\", strlen(\"nohwc\"))) {\n\t\t\tg_hwcursor = 0;\n\t\t} else {\n\t\t\tif (!g_fbmode[0]) {\n\t\t\t\tg_fbmode[0] = opt;\n\t\t\t\tdev_info(&sm750_dev->pdev->dev,\n\t\t\t\t\t \"find fbmode0 : %s\\n\", g_fbmode[0]);\n\t\t\t} else if (!g_fbmode[1]) {\n\t\t\t\tg_fbmode[1] = opt;\n\t\t\t\tdev_info(&sm750_dev->pdev->dev,\n\t\t\t\t\t \"find fbmode1 : %s\\n\", g_fbmode[1]);\n\t\t\t} else {\n\t\t\t\tdev_warn(&sm750_dev->pdev->dev, \"How many view you wann set?\\n\");\n\t\t\t}\n\t\t}\n\t}\n\nNO_PARAM:\n\tif (sm750_dev->revid != SM750LE_REVISION_ID) {\n\t\tif (sm750_dev->fb_count > 1) {\n\t\t\tif (swap)\n\t\t\t\tsm750_dev->dataflow = sm750_dual_swap;\n\t\t\telse\n\t\t\t\tsm750_dev->dataflow = sm750_dual_normal;\n\t\t} else {\n\t\t\tif (swap)\n\t\t\t\tsm750_dev->dataflow = sm750_simul_sec;\n\t\t\telse\n\t\t\t\tsm750_dev->dataflow = sm750_simul_pri;\n\t\t}\n\t} else {\n\t\t \n\t\tsm750_dev->dataflow = sm750_simul_sec;\n\t\t \n\t\tsm750_dev->nocrt = 0;\n\t}\n}\n\nstatic void sm750fb_framebuffer_release(struct sm750_dev *sm750_dev)\n{\n\tstruct fb_info *fb_info;\n\n\twhile (sm750_dev->fb_count) {\n\t\tfb_info = sm750_dev->fbinfo[sm750_dev->fb_count - 1];\n\t\tunregister_framebuffer(fb_info);\n\t\tframebuffer_release(fb_info);\n\t\tsm750_dev->fb_count--;\n\t}\n}\n\nstatic int sm750fb_framebuffer_alloc(struct sm750_dev *sm750_dev, int fbidx)\n{\n\tstruct fb_info *fb_info;\n\tstruct lynxfb_par *par;\n\tint err;\n\n\tfb_info = framebuffer_alloc(sizeof(struct lynxfb_par),\n\t\t\t\t    &sm750_dev->pdev->dev);\n\tif (!fb_info)\n\t\treturn -ENOMEM;\n\n\tsm750_dev->fbinfo[fbidx] = fb_info;\n\tpar = fb_info->par;\n\tpar->dev = sm750_dev;\n\n\terr = lynxfb_set_fbinfo(fb_info, fbidx);\n\tif (err)\n\t\tgoto release_fb;\n\n\terr = register_framebuffer(fb_info);\n\tif (err < 0)\n\t\tgoto release_fb;\n\n\tsm750_dev->fb_count++;\n\n\treturn 0;\n\nrelease_fb:\n\tframebuffer_release(fb_info);\n\treturn err;\n}\n\nstatic int lynxfb_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct sm750_dev *sm750_dev = NULL;\n\tint max_fb;\n\tint fbidx;\n\tint err;\n\n\terr = aperture_remove_conflicting_pci_devices(pdev, \"sm750_fb1\");\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = pcim_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tsm750_dev = devm_kzalloc(&pdev->dev, sizeof(*sm750_dev), GFP_KERNEL);\n\tif (!sm750_dev)\n\t\treturn err;\n\n\tsm750_dev->fbinfo[0] = NULL;\n\tsm750_dev->fbinfo[1] = NULL;\n\tsm750_dev->devid = pdev->device;\n\tsm750_dev->revid = pdev->revision;\n\tsm750_dev->pdev = pdev;\n\tsm750_dev->mtrr_off = g_nomtrr;\n\tsm750_dev->mtrr.vram = 0;\n\tsm750_dev->accel_off = g_noaccel;\n\tspin_lock_init(&sm750_dev->slock);\n\n\tif (!sm750_dev->accel_off) {\n\t\t \n\t\tsm750_dev->accel.de_init = sm750_hw_de_init;\n\t\tsm750_dev->accel.de_fillrect = sm750_hw_fillrect;\n\t\tsm750_dev->accel.de_copyarea = sm750_hw_copyarea;\n\t\tsm750_dev->accel.de_imageblit = sm750_hw_imageblit;\n\t}\n\n\t \n\tsm750fb_setup(sm750_dev, g_settings);\n\n\t \n\terr = hw_sm750_map(sm750_dev, pdev);\n\tif (err)\n\t\treturn err;\n\n\tif (!sm750_dev->mtrr_off)\n\t\tsm750_dev->mtrr.vram = arch_phys_wc_add(sm750_dev->vidmem_start,\n\t\t\t\t\t\t\tsm750_dev->vidmem_size);\n\n\tmemset_io(sm750_dev->pvMem, 0, sm750_dev->vidmem_size);\n\n\tpci_set_drvdata(pdev, sm750_dev);\n\n\t \n\thw_sm750_inithw(sm750_dev, pdev);\n\n\t \n\tmax_fb = g_dualview ? 2 : 1;\n\tfor (fbidx = 0; fbidx < max_fb; fbidx++) {\n\t\terr = sm750fb_framebuffer_alloc(sm750_dev, fbidx);\n\t\tif (err)\n\t\t\tgoto release_fb;\n\t}\n\n\treturn 0;\n\nrelease_fb:\n\tsm750fb_framebuffer_release(sm750_dev);\n\treturn err;\n}\n\nstatic void lynxfb_pci_remove(struct pci_dev *pdev)\n{\n\tstruct sm750_dev *sm750_dev;\n\n\tsm750_dev = pci_get_drvdata(pdev);\n\n\tsm750fb_framebuffer_release(sm750_dev);\n\tarch_phys_wc_del(sm750_dev->mtrr.vram);\n\n\tiounmap(sm750_dev->pvReg);\n\tiounmap(sm750_dev->pvMem);\n\tkfree(g_settings);\n}\n\nstatic int __init lynxfb_setup(char *options)\n{\n\tint len;\n\tchar *opt, *tmp;\n\n\tif (!options || !*options) {\n\t\tpr_warn(\"no options.\\n\");\n\t\treturn 0;\n\t}\n\n\tpr_info(\"options:%s\\n\", options);\n\n\tlen = strlen(options) + 1;\n\tg_settings = kzalloc(len, GFP_KERNEL);\n\tif (!g_settings)\n\t\treturn -ENOMEM;\n\n\ttmp = g_settings;\n\n\t \n\twhile ((opt = strsep(&options, \":\")) != NULL) {\n\t\t \n\t\tif (!strncmp(opt, \"noaccel\", strlen(\"noaccel\"))) {\n\t\t\tg_noaccel = 1;\n\t\t} else if (!strncmp(opt, \"nomtrr\", strlen(\"nomtrr\"))) {\n\t\t\tg_nomtrr = 1;\n\t\t} else if (!strncmp(opt, \"dual\", strlen(\"dual\"))) {\n\t\t\tg_dualview = 1;\n\t\t} else {\n\t\t\tstrcat(tmp, opt);\n\t\t\ttmp += strlen(opt);\n\t\t\tif (options)\n\t\t\t\t*tmp++ = ':';\n\t\t\telse\n\t\t\t\t*tmp++ = 0;\n\t\t}\n\t}\n\n\t \n\tpr_info(\"parameter left for chip specific analysis:%s\\n\", g_settings);\n\treturn 0;\n}\n\nstatic const struct pci_device_id smi_pci_table[] = {\n\t{ PCI_DEVICE(0x126f, 0x0750), },\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, smi_pci_table);\n\nstatic SIMPLE_DEV_PM_OPS(lynxfb_pm_ops, lynxfb_suspend, lynxfb_resume);\n\nstatic struct pci_driver lynxfb_driver = {\n\t.name =\t\t\"sm750fb\",\n\t.id_table =\tsmi_pci_table,\n\t.probe =\tlynxfb_pci_probe,\n\t.remove =\tlynxfb_pci_remove,\n\t.driver.pm =\t&lynxfb_pm_ops,\n};\n\nstatic int __init lynxfb_init(void)\n{\n\tchar *option;\n\n\tif (fb_modesetting_disabled(\"sm750fb\"))\n\t\treturn -ENODEV;\n\n#ifdef MODULE\n\toption = g_option;\n#else\n\tif (fb_get_options(\"sm750fb\", &option))\n\t\treturn -ENODEV;\n#endif\n\n\tlynxfb_setup(option);\n\treturn pci_register_driver(&lynxfb_driver);\n}\nmodule_init(lynxfb_init);\n\nstatic void __exit lynxfb_exit(void)\n{\n\tpci_unregister_driver(&lynxfb_driver);\n}\nmodule_exit(lynxfb_exit);\n\nmodule_param(g_option, charp, 0444);\n\nMODULE_PARM_DESC(g_option,\n\t\t \"\\n\\t\\tCommon options:\\n\"\n\t\t \"\\t\\tnoaccel:disable 2d capabilities\\n\"\n\t\t \"\\t\\tnomtrr:disable MTRR attribute for video memory\\n\"\n\t\t \"\\t\\tdualview:dual frame buffer feature enabled\\n\"\n\t\t \"\\t\\tnohwc:disable hardware cursor\\n\"\n\t\t \"\\t\\tUsual example:\\n\"\n\t\t \"\\t\\tinsmod ./sm750fb.ko g_option=\\\"noaccel,nohwc,1280x1024-8@60\\\"\\n\"\n\t\t );\n\nMODULE_AUTHOR(\"monk liu <monk.liu@siliconmotion.com>\");\nMODULE_AUTHOR(\"Sudip Mukherjee <sudip@vectorindia.org>\");\nMODULE_DESCRIPTION(\"Frame buffer driver for SM750 chipset\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}