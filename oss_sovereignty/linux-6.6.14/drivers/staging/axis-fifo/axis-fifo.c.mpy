{
  "module_name": "axis-fifo.c",
  "hash_id": "b16c5b2a7bca1f4a665886f3cc7302799db0668088475623f1969750f837a62d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/axis-fifo/axis-fifo.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/wait.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/param.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <linux/jiffies.h>\n#include <linux/miscdevice.h>\n\n \n\n#define DRIVER_NAME \"axis_fifo\"\n\n#define READ_BUF_SIZE 128U  \n#define WRITE_BUF_SIZE 128U  \n\n \n\n#define XLLF_ISR_OFFSET  0x00000000   \n#define XLLF_IER_OFFSET  0x00000004   \n\n#define XLLF_TDFR_OFFSET 0x00000008   \n#define XLLF_TDFV_OFFSET 0x0000000c   \n#define XLLF_TDFD_OFFSET 0x00000010   \n#define XLLF_TLR_OFFSET  0x00000014   \n\n#define XLLF_RDFR_OFFSET 0x00000018   \n#define XLLF_RDFO_OFFSET 0x0000001c   \n#define XLLF_RDFD_OFFSET 0x00000020   \n#define XLLF_RLR_OFFSET  0x00000024   \n#define XLLF_SRR_OFFSET  0x00000028   \n#define XLLF_TDR_OFFSET  0x0000002C   \n#define XLLF_RDR_OFFSET  0x00000030   \n\n \n\n#define XLLF_RDFR_RESET_MASK        0x000000a5  \n#define XLLF_TDFR_RESET_MASK        0x000000a5  \n#define XLLF_SRR_RESET_MASK         0x000000a5  \n\n \n\n#define XLLF_INT_RPURE_MASK       0x80000000  \n#define XLLF_INT_RPORE_MASK       0x40000000  \n#define XLLF_INT_RPUE_MASK        0x20000000  \n#define XLLF_INT_TPOE_MASK        0x10000000  \n#define XLLF_INT_TC_MASK          0x08000000  \n#define XLLF_INT_RC_MASK          0x04000000  \n#define XLLF_INT_TSE_MASK         0x02000000  \n#define XLLF_INT_TRC_MASK         0x01000000  \n#define XLLF_INT_RRC_MASK         0x00800000  \n#define XLLF_INT_TFPF_MASK        0x00400000  \n#define XLLF_INT_TFPE_MASK        0x00200000  \n#define XLLF_INT_RFPF_MASK        0x00100000  \n#define XLLF_INT_RFPE_MASK        0x00080000  \n#define XLLF_INT_ALL_MASK         0xfff80000  \n#define XLLF_INT_ERROR_MASK       0xf2000000  \n#define XLLF_INT_RXERROR_MASK     0xe0000000  \n#define XLLF_INT_TXERROR_MASK     0x12000000  \n\n \nstatic long read_timeout = 1000;  \nstatic long write_timeout = 1000;  \n\n \n\nmodule_param(read_timeout, long, 0444);\nMODULE_PARM_DESC(read_timeout, \"ms to wait before blocking read() timing out; set to -1 for no timeout\");\nmodule_param(write_timeout, long, 0444);\nMODULE_PARM_DESC(write_timeout, \"ms to wait before blocking write() timing out; set to -1 for no timeout\");\n\n \n\nstruct axis_fifo {\n\tint irq;  \n\tvoid __iomem *base_addr;  \n\n\tunsigned int rx_fifo_depth;  \n\tunsigned int tx_fifo_depth;  \n\tint has_rx_fifo;  \n\tint has_tx_fifo;  \n\n\twait_queue_head_t read_queue;  \n\tstruct mutex read_lock;  \n\twait_queue_head_t write_queue;  \n\tstruct mutex write_lock;  \n\tunsigned int write_flags;  \n\tunsigned int read_flags;  \n\n\tstruct device *dt_device;  \n\tstruct miscdevice miscdev;\n};\n\n \n\nstatic ssize_t sysfs_write(struct device *dev, const char *buf,\n\t\t\t   size_t count, unsigned int addr_offset)\n{\n\tstruct axis_fifo *fifo = dev_get_drvdata(dev);\n\tunsigned long tmp;\n\tint rc;\n\n\trc = kstrtoul(buf, 0, &tmp);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tiowrite32(tmp, fifo->base_addr + addr_offset);\n\n\treturn count;\n}\n\nstatic ssize_t sysfs_read(struct device *dev, char *buf,\n\t\t\t  unsigned int addr_offset)\n{\n\tstruct axis_fifo *fifo = dev_get_drvdata(dev);\n\tunsigned int read_val;\n\tunsigned int len;\n\tchar tmp[32];\n\n\tread_val = ioread32(fifo->base_addr + addr_offset);\n\tlen =  snprintf(tmp, sizeof(tmp), \"0x%x\\n\", read_val);\n\tmemcpy(buf, tmp, len);\n\n\treturn len;\n}\n\nstatic ssize_t isr_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\treturn sysfs_write(dev, buf, count, XLLF_ISR_OFFSET);\n}\n\nstatic ssize_t isr_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sysfs_read(dev, buf, XLLF_ISR_OFFSET);\n}\n\nstatic DEVICE_ATTR_RW(isr);\n\nstatic ssize_t ier_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\treturn sysfs_write(dev, buf, count, XLLF_IER_OFFSET);\n}\n\nstatic ssize_t ier_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sysfs_read(dev, buf, XLLF_IER_OFFSET);\n}\n\nstatic DEVICE_ATTR_RW(ier);\n\nstatic ssize_t tdfr_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\treturn sysfs_write(dev, buf, count, XLLF_TDFR_OFFSET);\n}\n\nstatic DEVICE_ATTR_WO(tdfr);\n\nstatic ssize_t tdfv_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_read(dev, buf, XLLF_TDFV_OFFSET);\n}\n\nstatic DEVICE_ATTR_RO(tdfv);\n\nstatic ssize_t tdfd_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\treturn sysfs_write(dev, buf, count, XLLF_TDFD_OFFSET);\n}\n\nstatic DEVICE_ATTR_WO(tdfd);\n\nstatic ssize_t tlr_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\treturn sysfs_write(dev, buf, count, XLLF_TLR_OFFSET);\n}\n\nstatic DEVICE_ATTR_WO(tlr);\n\nstatic ssize_t rdfr_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\treturn sysfs_write(dev, buf, count, XLLF_RDFR_OFFSET);\n}\n\nstatic DEVICE_ATTR_WO(rdfr);\n\nstatic ssize_t rdfo_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_read(dev, buf, XLLF_RDFO_OFFSET);\n}\n\nstatic DEVICE_ATTR_RO(rdfo);\n\nstatic ssize_t rdfd_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_read(dev, buf, XLLF_RDFD_OFFSET);\n}\n\nstatic DEVICE_ATTR_RO(rdfd);\n\nstatic ssize_t rlr_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sysfs_read(dev, buf, XLLF_RLR_OFFSET);\n}\n\nstatic DEVICE_ATTR_RO(rlr);\n\nstatic ssize_t srr_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\treturn sysfs_write(dev, buf, count, XLLF_SRR_OFFSET);\n}\n\nstatic DEVICE_ATTR_WO(srr);\n\nstatic ssize_t tdr_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\treturn sysfs_write(dev, buf, count, XLLF_TDR_OFFSET);\n}\n\nstatic DEVICE_ATTR_WO(tdr);\n\nstatic ssize_t rdr_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sysfs_read(dev, buf, XLLF_RDR_OFFSET);\n}\n\nstatic DEVICE_ATTR_RO(rdr);\n\nstatic struct attribute *axis_fifo_attrs[] = {\n\t&dev_attr_isr.attr,\n\t&dev_attr_ier.attr,\n\t&dev_attr_tdfr.attr,\n\t&dev_attr_tdfv.attr,\n\t&dev_attr_tdfd.attr,\n\t&dev_attr_tlr.attr,\n\t&dev_attr_rdfr.attr,\n\t&dev_attr_rdfo.attr,\n\t&dev_attr_rdfd.attr,\n\t&dev_attr_rlr.attr,\n\t&dev_attr_srr.attr,\n\t&dev_attr_tdr.attr,\n\t&dev_attr_rdr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group axis_fifo_attrs_group = {\n\t.name = \"ip_registers\",\n\t.attrs = axis_fifo_attrs,\n};\n\nstatic const struct attribute_group *axis_fifo_attrs_groups[] = {\n\t&axis_fifo_attrs_group,\n\tNULL,\n};\n\n \n\nstatic void reset_ip_core(struct axis_fifo *fifo)\n{\n\tiowrite32(XLLF_SRR_RESET_MASK, fifo->base_addr + XLLF_SRR_OFFSET);\n\tiowrite32(XLLF_TDFR_RESET_MASK, fifo->base_addr + XLLF_TDFR_OFFSET);\n\tiowrite32(XLLF_RDFR_RESET_MASK, fifo->base_addr + XLLF_RDFR_OFFSET);\n\tiowrite32(XLLF_INT_TC_MASK | XLLF_INT_RC_MASK | XLLF_INT_RPURE_MASK |\n\t\t  XLLF_INT_RPORE_MASK | XLLF_INT_RPUE_MASK |\n\t\t  XLLF_INT_TPOE_MASK | XLLF_INT_TSE_MASK,\n\t\t  fifo->base_addr + XLLF_IER_OFFSET);\n\tiowrite32(XLLF_INT_ALL_MASK, fifo->base_addr + XLLF_ISR_OFFSET);\n}\n\n \nstatic ssize_t axis_fifo_read(struct file *f, char __user *buf,\n\t\t\t      size_t len, loff_t *off)\n{\n\tstruct axis_fifo *fifo = (struct axis_fifo *)f->private_data;\n\tsize_t bytes_available;\n\tunsigned int words_available;\n\tunsigned int copied;\n\tunsigned int copy;\n\tunsigned int i;\n\tint ret;\n\tu32 tmp_buf[READ_BUF_SIZE];\n\n\tif (fifo->read_flags & O_NONBLOCK) {\n\t\t \n\t\tif (!mutex_trylock(&fifo->read_lock))\n\t\t\treturn -EAGAIN;\n\n\t\tif (!ioread32(fifo->base_addr + XLLF_RDFO_OFFSET)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto end_unlock;\n\t\t}\n\t} else {\n\t\t \n\t\tmutex_lock(&fifo->read_lock);\n\t\tret = wait_event_interruptible_timeout(fifo->read_queue,\n\t\t\tioread32(fifo->base_addr + XLLF_RDFO_OFFSET),\n\t\t\tread_timeout);\n\n\t\tif (ret <= 0) {\n\t\t\tif (ret == 0) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t} else if (ret != -ERESTARTSYS) {\n\t\t\t\tdev_err(fifo->dt_device, \"wait_event_interruptible_timeout() error in read (ret=%i)\\n\",\n\t\t\t\t\tret);\n\t\t\t}\n\n\t\t\tgoto end_unlock;\n\t\t}\n\t}\n\n\tbytes_available = ioread32(fifo->base_addr + XLLF_RLR_OFFSET);\n\tif (!bytes_available) {\n\t\tdev_err(fifo->dt_device, \"received a packet of length 0 - fifo core will be reset\\n\");\n\t\treset_ip_core(fifo);\n\t\tret = -EIO;\n\t\tgoto end_unlock;\n\t}\n\n\tif (bytes_available > len) {\n\t\tdev_err(fifo->dt_device, \"user read buffer too small (available bytes=%zu user buffer bytes=%zu) - fifo core will be reset\\n\",\n\t\t\tbytes_available, len);\n\t\treset_ip_core(fifo);\n\t\tret = -EINVAL;\n\t\tgoto end_unlock;\n\t}\n\n\tif (bytes_available % sizeof(u32)) {\n\t\t \n\t\tdev_err(fifo->dt_device, \"received a packet that isn't word-aligned - fifo core will be reset\\n\");\n\t\treset_ip_core(fifo);\n\t\tret = -EIO;\n\t\tgoto end_unlock;\n\t}\n\n\twords_available = bytes_available / sizeof(u32);\n\n\t \n\tcopied = 0;\n\twhile (words_available > 0) {\n\t\tcopy = min(words_available, READ_BUF_SIZE);\n\n\t\tfor (i = 0; i < copy; i++) {\n\t\t\ttmp_buf[i] = ioread32(fifo->base_addr +\n\t\t\t\t\t      XLLF_RDFD_OFFSET);\n\t\t}\n\n\t\tif (copy_to_user(buf + copied * sizeof(u32), tmp_buf,\n\t\t\t\t copy * sizeof(u32))) {\n\t\t\treset_ip_core(fifo);\n\t\t\tret = -EFAULT;\n\t\t\tgoto end_unlock;\n\t\t}\n\n\t\tcopied += copy;\n\t\twords_available -= copy;\n\t}\n\n\tret = bytes_available;\n\nend_unlock:\n\tmutex_unlock(&fifo->read_lock);\n\n\treturn ret;\n}\n\n \nstatic ssize_t axis_fifo_write(struct file *f, const char __user *buf,\n\t\t\t       size_t len, loff_t *off)\n{\n\tstruct axis_fifo *fifo = (struct axis_fifo *)f->private_data;\n\tunsigned int words_to_write;\n\tunsigned int copied;\n\tunsigned int copy;\n\tunsigned int i;\n\tint ret;\n\tu32 tmp_buf[WRITE_BUF_SIZE];\n\n\tif (len % sizeof(u32)) {\n\t\tdev_err(fifo->dt_device,\n\t\t\t\"tried to send a packet that isn't word-aligned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twords_to_write = len / sizeof(u32);\n\n\tif (!words_to_write) {\n\t\tdev_err(fifo->dt_device,\n\t\t\t\"tried to send a packet of length 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (words_to_write > fifo->tx_fifo_depth) {\n\t\tdev_err(fifo->dt_device, \"tried to write more words [%u] than slots in the fifo buffer [%u]\\n\",\n\t\t\twords_to_write, fifo->tx_fifo_depth);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fifo->write_flags & O_NONBLOCK) {\n\t\t \n\t\tif (!mutex_trylock(&fifo->write_lock))\n\t\t\treturn -EAGAIN;\n\n\t\tif (words_to_write > ioread32(fifo->base_addr +\n\t\t\t\t\t      XLLF_TDFV_OFFSET)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto end_unlock;\n\t\t}\n\t} else {\n\t\t \n\n\t\t \n\t\tmutex_lock(&fifo->write_lock);\n\t\tret = wait_event_interruptible_timeout(fifo->write_queue,\n\t\t\tioread32(fifo->base_addr + XLLF_TDFV_OFFSET)\n\t\t\t\t >= words_to_write,\n\t\t\twrite_timeout);\n\n\t\tif (ret <= 0) {\n\t\t\tif (ret == 0) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t} else if (ret != -ERESTARTSYS) {\n\t\t\t\tdev_err(fifo->dt_device, \"wait_event_interruptible_timeout() error in write (ret=%i)\\n\",\n\t\t\t\t\tret);\n\t\t\t}\n\n\t\t\tgoto end_unlock;\n\t\t}\n\t}\n\n\t \n\tcopied = 0;\n\twhile (words_to_write > 0) {\n\t\tcopy = min(words_to_write, WRITE_BUF_SIZE);\n\n\t\tif (copy_from_user(tmp_buf, buf + copied * sizeof(u32),\n\t\t\t\t   copy * sizeof(u32))) {\n\t\t\treset_ip_core(fifo);\n\t\t\tret = -EFAULT;\n\t\t\tgoto end_unlock;\n\t\t}\n\n\t\tfor (i = 0; i < copy; i++)\n\t\t\tiowrite32(tmp_buf[i], fifo->base_addr +\n\t\t\t\t  XLLF_TDFD_OFFSET);\n\n\t\tcopied += copy;\n\t\twords_to_write -= copy;\n\t}\n\n\tret = copied * sizeof(u32);\n\n\t \n\tiowrite32(ret, fifo->base_addr + XLLF_TLR_OFFSET);\n\nend_unlock:\n\tmutex_unlock(&fifo->write_lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t axis_fifo_irq(int irq, void *dw)\n{\n\tstruct axis_fifo *fifo = (struct axis_fifo *)dw;\n\tunsigned int pending_interrupts;\n\n\tdo {\n\t\tpending_interrupts = ioread32(fifo->base_addr +\n\t\t\t\t\t      XLLF_IER_OFFSET) &\n\t\t\t\t\t      ioread32(fifo->base_addr\n\t\t\t\t\t      + XLLF_ISR_OFFSET);\n\t\tif (pending_interrupts & XLLF_INT_RC_MASK) {\n\t\t\t \n\n\t\t\t \n\t\t\twake_up(&fifo->read_queue);\n\n\t\t\t \n\t\t\tiowrite32(XLLF_INT_RC_MASK & XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t} else if (pending_interrupts & XLLF_INT_TC_MASK) {\n\t\t\t \n\n\t\t\t \n\t\t\twake_up(&fifo->write_queue);\n\n\t\t\tiowrite32(XLLF_INT_TC_MASK & XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t} else if (pending_interrupts & XLLF_INT_TFPF_MASK) {\n\t\t\t \n\n\t\t\tiowrite32(XLLF_INT_TFPF_MASK & XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t} else if (pending_interrupts & XLLF_INT_TFPE_MASK) {\n\t\t\t \n\n\t\t\tiowrite32(XLLF_INT_TFPE_MASK & XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t} else if (pending_interrupts & XLLF_INT_RFPF_MASK) {\n\t\t\t \n\n\t\t\tiowrite32(XLLF_INT_RFPF_MASK & XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t} else if (pending_interrupts & XLLF_INT_RFPE_MASK) {\n\t\t\t \n\n\t\t\tiowrite32(XLLF_INT_RFPE_MASK & XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t} else if (pending_interrupts & XLLF_INT_TRC_MASK) {\n\t\t\t \n\n\t\t\tiowrite32(XLLF_INT_TRC_MASK & XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t} else if (pending_interrupts & XLLF_INT_RRC_MASK) {\n\t\t\t \n\n\t\t\tiowrite32(XLLF_INT_RRC_MASK & XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t} else if (pending_interrupts & XLLF_INT_RPURE_MASK) {\n\t\t\t \n\t\t\tdev_err(fifo->dt_device,\n\t\t\t\t\"receive under-read interrupt\\n\");\n\n\t\t\tiowrite32(XLLF_INT_RPURE_MASK & XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t} else if (pending_interrupts & XLLF_INT_RPORE_MASK) {\n\t\t\t \n\t\t\tdev_err(fifo->dt_device,\n\t\t\t\t\"receive over-read interrupt\\n\");\n\n\t\t\tiowrite32(XLLF_INT_RPORE_MASK & XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t} else if (pending_interrupts & XLLF_INT_RPUE_MASK) {\n\t\t\t \n\t\t\tdev_err(fifo->dt_device,\n\t\t\t\t\"receive underrun error interrupt\\n\");\n\n\t\t\tiowrite32(XLLF_INT_RPUE_MASK & XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t} else if (pending_interrupts & XLLF_INT_TPOE_MASK) {\n\t\t\t \n\t\t\tdev_err(fifo->dt_device,\n\t\t\t\t\"transmit overrun error interrupt\\n\");\n\n\t\t\tiowrite32(XLLF_INT_TPOE_MASK & XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t} else if (pending_interrupts & XLLF_INT_TSE_MASK) {\n\t\t\t \n\t\t\tdev_err(fifo->dt_device,\n\t\t\t\t\"transmit length mismatch error interrupt\\n\");\n\n\t\t\tiowrite32(XLLF_INT_TSE_MASK & XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t} else if (pending_interrupts) {\n\t\t\t \n\t\t\tdev_err(fifo->dt_device,\n\t\t\t\t\"unknown interrupt(s) 0x%x\\n\",\n\t\t\t\tpending_interrupts);\n\n\t\t\tiowrite32(XLLF_INT_ALL_MASK,\n\t\t\t\t  fifo->base_addr + XLLF_ISR_OFFSET);\n\t\t}\n\t} while (pending_interrupts);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int axis_fifo_open(struct inode *inod, struct file *f)\n{\n\tstruct axis_fifo *fifo = container_of(f->private_data,\n\t\t\t\t\t      struct axis_fifo, miscdev);\n\tf->private_data = fifo;\n\n\tif (((f->f_flags & O_ACCMODE) == O_WRONLY) ||\n\t    ((f->f_flags & O_ACCMODE) == O_RDWR)) {\n\t\tif (fifo->has_tx_fifo) {\n\t\t\tfifo->write_flags = f->f_flags;\n\t\t} else {\n\t\t\tdev_err(fifo->dt_device, \"tried to open device for write but the transmit fifo is disabled\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\tif (((f->f_flags & O_ACCMODE) == O_RDONLY) ||\n\t    ((f->f_flags & O_ACCMODE) == O_RDWR)) {\n\t\tif (fifo->has_rx_fifo) {\n\t\t\tfifo->read_flags = f->f_flags;\n\t\t} else {\n\t\t\tdev_err(fifo->dt_device, \"tried to open device for read but the receive fifo is disabled\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int axis_fifo_close(struct inode *inod, struct file *f)\n{\n\tf->private_data = NULL;\n\n\treturn 0;\n}\n\nstatic const struct file_operations fops = {\n\t.owner = THIS_MODULE,\n\t.open = axis_fifo_open,\n\t.release = axis_fifo_close,\n\t.read = axis_fifo_read,\n\t.write = axis_fifo_write\n};\n\n \nstatic int get_dts_property(struct axis_fifo *fifo,\n\t\t\t    char *name, unsigned int *var)\n{\n\tint rc;\n\n\trc = of_property_read_u32(fifo->dt_device->of_node, name, var);\n\tif (rc) {\n\t\tdev_err(fifo->dt_device, \"couldn't read IP dts property '%s'\",\n\t\t\tname);\n\t\treturn rc;\n\t}\n\tdev_dbg(fifo->dt_device, \"dts property '%s' = %u\\n\",\n\t\tname, *var);\n\n\treturn 0;\n}\n\nstatic int axis_fifo_parse_dt(struct axis_fifo *fifo)\n{\n\tint ret;\n\tunsigned int value;\n\n\tret = get_dts_property(fifo, \"xlnx,axi-str-rxd-tdata-width\", &value);\n\tif (ret) {\n\t\tdev_err(fifo->dt_device, \"missing xlnx,axi-str-rxd-tdata-width property\\n\");\n\t\tgoto end;\n\t} else if (value != 32) {\n\t\tdev_err(fifo->dt_device, \"xlnx,axi-str-rxd-tdata-width only supports 32 bits\\n\");\n\t\tret = -EIO;\n\t\tgoto end;\n\t}\n\n\tret = get_dts_property(fifo, \"xlnx,axi-str-txd-tdata-width\", &value);\n\tif (ret) {\n\t\tdev_err(fifo->dt_device, \"missing xlnx,axi-str-txd-tdata-width property\\n\");\n\t\tgoto end;\n\t} else if (value != 32) {\n\t\tdev_err(fifo->dt_device, \"xlnx,axi-str-txd-tdata-width only supports 32 bits\\n\");\n\t\tret = -EIO;\n\t\tgoto end;\n\t}\n\n\tret = get_dts_property(fifo, \"xlnx,rx-fifo-depth\",\n\t\t\t       &fifo->rx_fifo_depth);\n\tif (ret) {\n\t\tdev_err(fifo->dt_device, \"missing xlnx,rx-fifo-depth property\\n\");\n\t\tret = -EIO;\n\t\tgoto end;\n\t}\n\n\tret = get_dts_property(fifo, \"xlnx,tx-fifo-depth\",\n\t\t\t       &fifo->tx_fifo_depth);\n\tif (ret) {\n\t\tdev_err(fifo->dt_device, \"missing xlnx,tx-fifo-depth property\\n\");\n\t\tret = -EIO;\n\t\tgoto end;\n\t}\n\n\t \n\tfifo->tx_fifo_depth -= 4;\n\n\tret = get_dts_property(fifo, \"xlnx,use-rx-data\", &fifo->has_rx_fifo);\n\tif (ret) {\n\t\tdev_err(fifo->dt_device, \"missing xlnx,use-rx-data property\\n\");\n\t\tret = -EIO;\n\t\tgoto end;\n\t}\n\n\tret = get_dts_property(fifo, \"xlnx,use-tx-data\", &fifo->has_tx_fifo);\n\tif (ret) {\n\t\tdev_err(fifo->dt_device, \"missing xlnx,use-tx-data property\\n\");\n\t\tret = -EIO;\n\t\tgoto end;\n\t}\n\nend:\n\treturn ret;\n}\n\nstatic int axis_fifo_probe(struct platform_device *pdev)\n{\n\tstruct resource *r_mem;  \n\tstruct device *dev = &pdev->dev;  \n\tstruct axis_fifo *fifo = NULL;\n\tchar *device_name;\n\tint rc = 0;  \n\n\t \n\n\tdevice_name = devm_kzalloc(dev, 32, GFP_KERNEL);\n\tif (!device_name)\n\t\treturn -ENOMEM;\n\n\t \n\tfifo = devm_kzalloc(dev, sizeof(*fifo), GFP_KERNEL);\n\tif (!fifo)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, fifo);\n\tfifo->dt_device = dev;\n\n\tinit_waitqueue_head(&fifo->read_queue);\n\tinit_waitqueue_head(&fifo->write_queue);\n\n\tmutex_init(&fifo->read_lock);\n\tmutex_init(&fifo->write_lock);\n\n\t \n\n\t \n\tfifo->base_addr = devm_platform_get_and_ioremap_resource(pdev, 0, &r_mem);\n\tif (IS_ERR(fifo->base_addr)) {\n\t\trc = PTR_ERR(fifo->base_addr);\n\t\tgoto err_initial;\n\t}\n\n\tdev_dbg(fifo->dt_device, \"remapped memory to 0x%p\\n\", fifo->base_addr);\n\n\t \n\tsnprintf(device_name, 32, \"%s_%pa\", DRIVER_NAME, &r_mem->start);\n\tdev_dbg(fifo->dt_device, \"device name [%s]\\n\", device_name);\n\n\t \n\n\trc = axis_fifo_parse_dt(fifo);\n\tif (rc)\n\t\tgoto err_initial;\n\n\treset_ip_core(fifo);\n\n\t \n\n\t \n\trc = platform_get_irq(pdev, 0);\n\tif (rc < 0)\n\t\tgoto err_initial;\n\n\t \n\tfifo->irq = rc;\n\trc = devm_request_irq(fifo->dt_device, fifo->irq, &axis_fifo_irq, 0,\n\t\t\t      DRIVER_NAME, fifo);\n\tif (rc) {\n\t\tdev_err(fifo->dt_device, \"couldn't allocate interrupt %i\\n\",\n\t\t\tfifo->irq);\n\t\tgoto err_initial;\n\t}\n\n\t \n\n\t \n\tfifo->miscdev.fops = &fops;\n\tfifo->miscdev.minor = MISC_DYNAMIC_MINOR;\n\tfifo->miscdev.name = device_name;\n\tfifo->miscdev.groups = axis_fifo_attrs_groups;\n\tfifo->miscdev.parent = dev;\n\trc = misc_register(&fifo->miscdev);\n\tif (rc < 0)\n\t\tgoto err_initial;\n\n\treturn 0;\n\nerr_initial:\n\tdev_set_drvdata(dev, NULL);\n\treturn rc;\n}\n\nstatic void axis_fifo_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct axis_fifo *fifo = dev_get_drvdata(dev);\n\n\tmisc_deregister(&fifo->miscdev);\n\tdev_set_drvdata(dev, NULL);\n}\n\nstatic const struct of_device_id axis_fifo_of_match[] = {\n\t{ .compatible = \"xlnx,axi-fifo-mm-s-4.1\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, axis_fifo_of_match);\n\nstatic struct platform_driver axis_fifo_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table\t= axis_fifo_of_match,\n\t},\n\t.probe\t\t= axis_fifo_probe,\n\t.remove_new\t= axis_fifo_remove,\n};\n\nstatic int __init axis_fifo_init(void)\n{\n\tif (read_timeout >= 0)\n\t\tread_timeout = msecs_to_jiffies(read_timeout);\n\telse\n\t\tread_timeout = MAX_SCHEDULE_TIMEOUT;\n\n\tif (write_timeout >= 0)\n\t\twrite_timeout = msecs_to_jiffies(write_timeout);\n\telse\n\t\twrite_timeout = MAX_SCHEDULE_TIMEOUT;\n\n\tpr_info(\"axis-fifo driver loaded with parameters read_timeout = %li, write_timeout = %li\\n\",\n\t\tread_timeout, write_timeout);\n\treturn platform_driver_register(&axis_fifo_driver);\n}\n\nmodule_init(axis_fifo_init);\n\nstatic void __exit axis_fifo_exit(void)\n{\n\tplatform_driver_unregister(&axis_fifo_driver);\n}\n\nmodule_exit(axis_fifo_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jacob Feder <jacobsfeder@gmail.com>\");\nMODULE_DESCRIPTION(\"Xilinx AXI-Stream FIFO v4.1 IP core driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}