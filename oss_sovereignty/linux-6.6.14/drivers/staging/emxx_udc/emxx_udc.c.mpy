{
  "module_name": "emxx_udc.c",
  "hash_id": "9e2752b10b26eaf80b8fd5a3e631dc7ef55bba8604b174b236193504a6654672",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/emxx_udc/emxx_udc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/clk.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/dma-mapping.h>\n#include <linux/workqueue.h>\n#include <linux/device.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n\n#include <linux/irq.h>\n#include <linux/gpio/consumer.h>\n\n#include \"emxx_udc.h\"\n\n#define\tDRIVER_DESC\t\"EMXX UDC driver\"\n#define\tDMA_ADDR_INVALID\t(~(dma_addr_t)0)\n\nstatic struct gpio_desc *vbus_gpio;\nstatic int vbus_irq;\n\nstatic const char\tdriver_name[] = \"emxx_udc\";\n\n \n \nstatic void _nbu2ss_ep_dma_abort(struct nbu2ss_udc *, struct nbu2ss_ep *);\nstatic void _nbu2ss_ep0_enable(struct nbu2ss_udc *);\n \nstatic void _nbu2ss_ep_done(struct nbu2ss_ep *, struct nbu2ss_req *, int);\nstatic void _nbu2ss_set_test_mode(struct nbu2ss_udc *, u32 mode);\nstatic void _nbu2ss_endpoint_toggle_reset(struct nbu2ss_udc *udc, u8 ep_adrs);\n\nstatic int _nbu2ss_pullup(struct nbu2ss_udc *, int);\nstatic void _nbu2ss_fifo_flush(struct nbu2ss_udc *, struct nbu2ss_ep *);\n\n \n \n#define\t_nbu2ss_zero_len_pkt(udc, epnum)\t\\\n\t_nbu2ss_ep_in_end(udc, epnum, 0, 0)\n\n \n \nstatic struct nbu2ss_udc udc_controller;\n\n \n \nstatic inline u32 _nbu2ss_readl(void __iomem *address)\n{\n\treturn __raw_readl(address);\n}\n\n \n \nstatic inline void _nbu2ss_writel(void __iomem *address, u32 udata)\n{\n\t__raw_writel(udata, address);\n}\n\n \n \nstatic inline void _nbu2ss_bitset(void __iomem *address, u32 udata)\n{\n\tu32\treg_dt = __raw_readl(address) | (udata);\n\n\t__raw_writel(reg_dt, address);\n}\n\n \n \nstatic inline void _nbu2ss_bitclr(void __iomem *address, u32 udata)\n{\n\tu32\treg_dt = __raw_readl(address) & ~(udata);\n\n\t__raw_writel(reg_dt, address);\n}\n\n#ifdef UDC_DEBUG_DUMP\n \nstatic void _nbu2ss_dump_register(struct nbu2ss_udc *udc)\n{\n\tint\t\ti;\n\tu32 reg_data;\n\n\tpr_info(\"=== %s()\\n\", __func__);\n\n\tif (!udc) {\n\t\tpr_err(\"%s udc == NULL\\n\", __func__);\n\t\treturn;\n\t}\n\n\tspin_unlock(&udc->lock);\n\n\tdev_dbg(&udc->dev, \"\\n-USB REG-\\n\");\n\tfor (i = 0x0 ; i < USB_BASE_SIZE ; i += 16) {\n\t\treg_data = _nbu2ss_readl(IO_ADDRESS(USB_BASE_ADDRESS + i));\n\t\tdev_dbg(&udc->dev, \"USB%04x =%08x\", i, (int)reg_data);\n\n\t\treg_data = _nbu2ss_readl(IO_ADDRESS(USB_BASE_ADDRESS + i + 4));\n\t\tdev_dbg(&udc->dev, \" %08x\", (int)reg_data);\n\n\t\treg_data = _nbu2ss_readl(IO_ADDRESS(USB_BASE_ADDRESS + i + 8));\n\t\tdev_dbg(&udc->dev, \" %08x\", (int)reg_data);\n\n\t\treg_data = _nbu2ss_readl(IO_ADDRESS(USB_BASE_ADDRESS + i + 12));\n\t\tdev_dbg(&udc->dev, \" %08x\\n\", (int)reg_data);\n\t}\n\n\tspin_lock(&udc->lock);\n}\n#endif  \n\n \n \nstatic void _nbu2ss_ep0_complete(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tu8\t\trecipient;\n\tu16\t\tselector;\n\tu16\t\twIndex;\n\tu32\t\ttest_mode;\n\tstruct usb_ctrlrequest\t*p_ctrl;\n\tstruct nbu2ss_udc *udc;\n\n\tif (!_ep || !_req)\n\t\treturn;\n\n\tudc = (struct nbu2ss_udc *)_req->context;\n\tp_ctrl = &udc->ctrl;\n\tif ((p_ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tif (p_ctrl->bRequest == USB_REQ_SET_FEATURE) {\n\t\t\t \n\t\t\t \n\t\t\trecipient = (u8)(p_ctrl->bRequestType & USB_RECIP_MASK);\n\t\t\tselector  = le16_to_cpu(p_ctrl->wValue);\n\t\t\tif ((recipient == USB_RECIP_DEVICE) &&\n\t\t\t    (selector == USB_DEVICE_TEST_MODE)) {\n\t\t\t\twIndex = le16_to_cpu(p_ctrl->wIndex);\n\t\t\t\ttest_mode = (u32)(wIndex >> 8);\n\t\t\t\t_nbu2ss_set_test_mode(udc, test_mode);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \n \nstatic void _nbu2ss_create_ep0_packet(struct nbu2ss_udc *udc,\n\t\t\t\t      void *p_buf, unsigned int length)\n{\n\tudc->ep0_req.req.buf\t\t= p_buf;\n\tudc->ep0_req.req.length\t\t= length;\n\tudc->ep0_req.req.dma\t\t= 0;\n\tudc->ep0_req.req.zero\t\t= true;\n\tudc->ep0_req.req.complete\t= _nbu2ss_ep0_complete;\n\tudc->ep0_req.req.status\t\t= -EINPROGRESS;\n\tudc->ep0_req.req.context\t= udc;\n\tudc->ep0_req.req.actual\t\t= 0;\n}\n\n \n \nstatic u32 _nbu2ss_get_begin_ram_address(struct nbu2ss_udc *udc)\n{\n\tu32\t\tnum, buf_type;\n\tu32\t\tdata, last_ram_adr, use_ram_size;\n\n\tstruct ep_regs __iomem *p_ep_regs;\n\n\tlast_ram_adr = (D_RAM_SIZE_CTRL / sizeof(u32)) * 2;\n\tuse_ram_size = 0;\n\n\tfor (num = 0; num < NUM_ENDPOINTS - 1; num++) {\n\t\tp_ep_regs = &udc->p_regs->EP_REGS[num];\n\t\tdata = _nbu2ss_readl(&p_ep_regs->EP_PCKT_ADRS);\n\t\tbuf_type = _nbu2ss_readl(&p_ep_regs->EP_CONTROL) & EPN_BUF_TYPE;\n\t\tif (buf_type == 0) {\n\t\t\t \n\t\t\tuse_ram_size += (data & EPN_MPKT) / sizeof(u32);\n\t\t} else {\n\t\t\t \n\t\t\tuse_ram_size += ((data & EPN_MPKT) / sizeof(u32)) * 2;\n\t\t}\n\n\t\tif ((data >> 16) > last_ram_adr)\n\t\t\tlast_ram_adr = data >> 16;\n\t}\n\n\treturn last_ram_adr + use_ram_size;\n}\n\n \n \nstatic int _nbu2ss_ep_init(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep)\n{\n\tu32\t\tnum;\n\tu32\t\tdata;\n\tu32\t\tbegin_adrs;\n\n\tif (ep->epnum == 0)\n\t\treturn\t-EINVAL;\n\n\tnum = ep->epnum - 1;\n\n\t \n\t \n\tbegin_adrs = _nbu2ss_get_begin_ram_address(udc);\n\tdata = (begin_adrs << 16) | ep->ep.maxpacket;\n\t_nbu2ss_writel(&udc->p_regs->EP_REGS[num].EP_PCKT_ADRS, data);\n\n\t \n\t \n\tdata = 1 << (ep->epnum + 8);\n\t_nbu2ss_bitset(&udc->p_regs->USB_INT_ENA, data);\n\n\t \n\t \n\t \n\tswitch (ep->ep_type) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tdata = EPN_BULK;\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tdata = EPN_BUF_SINGLE | EPN_INTERRUPT;\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tdata = EPN_ISO;\n\t\tbreak;\n\n\tdefault:\n\t\tdata = 0;\n\t\tbreak;\n\t}\n\n\t_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\n\t_nbu2ss_endpoint_toggle_reset(udc, (ep->epnum | ep->direct));\n\n\tif (ep->direct == USB_DIR_OUT) {\n\t\t \n\t\t \n\t\tdata = EPN_EN | EPN_BCLR | EPN_DIR0;\n\t\t_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\n\n\t\tdata = EPN_ONAK | EPN_OSTL_EN | EPN_OSTL;\n\t\t_nbu2ss_bitclr(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\n\n\t\tdata = EPN_OUT_EN | EPN_OUT_END_EN;\n\t\t_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_INT_ENA, data);\n\t} else {\n\t\t \n\t\t \n\t\tdata = EPN_EN | EPN_BCLR | EPN_AUTO;\n\t\t_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\n\n\t\tdata = EPN_ISTL;\n\t\t_nbu2ss_bitclr(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\n\n\t\tdata = EPN_IN_EN | EPN_IN_END_EN;\n\t\t_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_INT_ENA, data);\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic int _nbu2ss_epn_exit(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep)\n{\n\tu32\t\tnum;\n\tu32\t\tdata;\n\n\tif ((ep->epnum == 0) || (udc->vbus_active == 0))\n\t\treturn\t-EINVAL;\n\n\tnum = ep->epnum - 1;\n\n\t \n\t \n\t_nbu2ss_writel(&udc->p_regs->EP_REGS[num].EP_PCKT_ADRS, 0);\n\n\t \n\t \n\tdata = 1 << (ep->epnum + 8);\n\t_nbu2ss_bitclr(&udc->p_regs->USB_INT_ENA, data);\n\n\tif (ep->direct == USB_DIR_OUT) {\n\t\t \n\t\t \n\t\tdata = EPN_ONAK | EPN_BCLR;\n\t\t_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\n\n\t\tdata = EPN_EN | EPN_DIR0;\n\t\t_nbu2ss_bitclr(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\n\n\t\tdata = EPN_OUT_EN | EPN_OUT_END_EN;\n\t\t_nbu2ss_bitclr(&udc->p_regs->EP_REGS[num].EP_INT_ENA, data);\n\t} else {\n\t\t \n\t\t \n\t\tdata = EPN_BCLR;\n\t\t_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\n\n\t\tdata = EPN_EN | EPN_AUTO;\n\t\t_nbu2ss_bitclr(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\n\n\t\tdata = EPN_IN_EN | EPN_IN_END_EN;\n\t\t_nbu2ss_bitclr(&udc->p_regs->EP_REGS[num].EP_INT_ENA, data);\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic void _nbu2ss_ep_dma_init(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep)\n{\n\tu32\t\tnum;\n\tu32\t\tdata;\n\n\tdata = _nbu2ss_readl(&udc->p_regs->USBSSCONF);\n\tif (((ep->epnum == 0) || (data & (1 << ep->epnum)) == 0))\n\t\treturn;\t\t \n\n\tnum = ep->epnum - 1;\n\n\tif (ep->direct == USB_DIR_OUT) {\n\t\t \n\t\t \n\t\tdata = ep->ep.maxpacket;\n\t\t_nbu2ss_writel(&udc->p_regs->EP_DCR[num].EP_DCR2, data);\n\n\t\t \n\t\t \n\t\tdata = DCR1_EPN_DIR0;\n\t\t_nbu2ss_bitset(&udc->p_regs->EP_DCR[num].EP_DCR1, data);\n\n\t\t \n\t\t \n\t\tdata = EPN_STOP_MODE | EPN_STOP_SET  | EPN_DMAMODE0;\n\t\t_nbu2ss_writel(&udc->p_regs->EP_REGS[num].EP_DMA_CTRL, data);\n\t} else {\n\t\t \n\t\t \n\t\t_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, EPN_AUTO);\n\n\t\t \n\t\t \n\t\tdata = EPN_BURST_SET | EPN_DMAMODE0;\n\t\t_nbu2ss_writel(&udc->p_regs->EP_REGS[num].EP_DMA_CTRL, data);\n\t}\n}\n\n \n \nstatic void _nbu2ss_ep_dma_exit(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep)\n{\n\tu32\t\tnum;\n\tu32\t\tdata;\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\tif (udc->vbus_active == 0)\n\t\treturn;\t\t \n\n\tdata = _nbu2ss_readl(&preg->USBSSCONF);\n\tif ((ep->epnum == 0) || ((data & (1 << ep->epnum)) == 0))\n\t\treturn;\t\t \n\n\tnum = ep->epnum - 1;\n\n\t_nbu2ss_ep_dma_abort(udc, ep);\n\n\tif (ep->direct == USB_DIR_OUT) {\n\t\t \n\t\t \n\t\t_nbu2ss_writel(&preg->EP_DCR[num].EP_DCR2, 0);\n\t\t_nbu2ss_bitclr(&preg->EP_DCR[num].EP_DCR1, DCR1_EPN_DIR0);\n\t\t_nbu2ss_writel(&preg->EP_REGS[num].EP_DMA_CTRL, 0);\n\t} else {\n\t\t \n\t\t \n\t\t_nbu2ss_bitclr(&preg->EP_REGS[num].EP_CONTROL, EPN_AUTO);\n\t\t_nbu2ss_writel(&preg->EP_REGS[num].EP_DMA_CTRL, 0);\n\t}\n}\n\n \n \nstatic void _nbu2ss_ep_dma_abort(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep)\n{\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\t_nbu2ss_bitclr(&preg->EP_DCR[ep->epnum - 1].EP_DCR1, DCR1_EPN_REQEN);\n\tmdelay(DMA_DISABLE_TIME);\t \n\t_nbu2ss_bitclr(&preg->EP_REGS[ep->epnum - 1].EP_DMA_CTRL, EPN_DMA_EN);\n}\n\n \n \nstatic void _nbu2ss_ep_in_end(struct nbu2ss_udc *udc,\n\t\t\t      u32 epnum, u32 data32, u32 length)\n{\n\tu32\t\tdata;\n\tu32\t\tnum;\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\tif (length >= sizeof(u32))\n\t\treturn;\n\n\tif (epnum == 0) {\n\t\t_nbu2ss_bitclr(&preg->EP0_CONTROL, EP0_AUTO);\n\n\t\t \n\t\tif (length)\n\t\t\t_nbu2ss_writel(&preg->EP0_WRITE, data32);\n\n\t\tdata = ((length << 5) & EP0_DW) | EP0_DEND;\n\t\t_nbu2ss_writel(&preg->EP0_CONTROL, data);\n\n\t\t_nbu2ss_bitset(&preg->EP0_CONTROL, EP0_AUTO);\n\t} else {\n\t\tnum = epnum - 1;\n\n\t\t_nbu2ss_bitclr(&preg->EP_REGS[num].EP_CONTROL, EPN_AUTO);\n\n\t\t \n\t\tif (length)\n\t\t\t_nbu2ss_writel(&preg->EP_REGS[num].EP_WRITE, data32);\n\n\t\tdata = (((length) << 5) & EPN_DW) | EPN_DEND;\n\t\t_nbu2ss_bitset(&preg->EP_REGS[num].EP_CONTROL, data);\n\n\t\t_nbu2ss_bitset(&preg->EP_REGS[num].EP_CONTROL, EPN_AUTO);\n\t}\n}\n\n#ifdef USE_DMA\n \nstatic void _nbu2ss_dma_map_single(struct nbu2ss_udc *udc,\n\t\t\t\t   struct nbu2ss_ep *ep,\n\t\t\t\t   struct nbu2ss_req *req, u8 direct)\n{\n\tif (req->req.dma == DMA_ADDR_INVALID) {\n\t\tif (req->unaligned) {\n\t\t\treq->req.dma = ep->phys_buf;\n\t\t} else {\n\t\t\treq->req.dma = dma_map_single(udc->gadget.dev.parent,\n\t\t\t\t\t\t      req->req.buf,\n\t\t\t\t\t\t      req->req.length,\n\t\t\t\t\t\t      (direct == USB_DIR_IN)\n\t\t\t\t\t\t      ? DMA_TO_DEVICE\n\t\t\t\t\t\t      : DMA_FROM_DEVICE);\n\t\t}\n\t\treq->mapped = 1;\n\t} else {\n\t\tif (!req->unaligned)\n\t\t\tdma_sync_single_for_device(udc->gadget.dev.parent,\n\t\t\t\t\t\t   req->req.dma,\n\t\t\t\t\t\t   req->req.length,\n\t\t\t\t\t\t   (direct == USB_DIR_IN)\n\t\t\t\t\t\t   ? DMA_TO_DEVICE\n\t\t\t\t\t\t   : DMA_FROM_DEVICE);\n\n\t\treq->mapped = 0;\n\t}\n}\n\n \nstatic void _nbu2ss_dma_unmap_single(struct nbu2ss_udc *udc,\n\t\t\t\t     struct nbu2ss_ep *ep,\n\t\t\t\t     struct nbu2ss_req *req, u8 direct)\n{\n\tu8\t\tdata[4];\n\tu8\t\t*p;\n\tu32\t\tcount = 0;\n\n\tif (direct == USB_DIR_OUT) {\n\t\tcount = req->req.actual % 4;\n\t\tif (count) {\n\t\t\tp = req->req.buf;\n\t\t\tp += (req->req.actual - count);\n\t\t\tmemcpy(data, p, count);\n\t\t}\n\t}\n\n\tif (req->mapped) {\n\t\tif (req->unaligned) {\n\t\t\tif (direct == USB_DIR_OUT)\n\t\t\t\tmemcpy(req->req.buf, ep->virt_buf,\n\t\t\t\t       req->req.actual & 0xfffffffc);\n\t\t} else {\n\t\t\tdma_unmap_single(udc->gadget.dev.parent,\n\t\t\t\t\t req->req.dma, req->req.length,\n\t\t\t\t(direct == USB_DIR_IN)\n\t\t\t\t? DMA_TO_DEVICE\n\t\t\t\t: DMA_FROM_DEVICE);\n\t\t}\n\t\treq->req.dma = DMA_ADDR_INVALID;\n\t\treq->mapped = 0;\n\t} else {\n\t\tif (!req->unaligned)\n\t\t\tdma_sync_single_for_cpu(udc->gadget.dev.parent,\n\t\t\t\t\t\treq->req.dma, req->req.length,\n\t\t\t\t(direct == USB_DIR_IN)\n\t\t\t\t? DMA_TO_DEVICE\n\t\t\t\t: DMA_FROM_DEVICE);\n\t}\n\n\tif (count) {\n\t\tp = req->req.buf;\n\t\tp += (req->req.actual - count);\n\t\tmemcpy(p, data, count);\n\t}\n}\n#endif\n\n \n \nstatic int ep0_out_pio(struct nbu2ss_udc *udc, u8 *buf, u32 length)\n{\n\tu32\t\ti;\n\tu32 numreads = length / sizeof(u32);\n\tunion usb_reg_access *buf32 = (union usb_reg_access *)buf;\n\n\tif (!numreads)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < numreads; i++) {\n\t\tbuf32->dw = _nbu2ss_readl(&udc->p_regs->EP0_READ);\n\t\tbuf32++;\n\t}\n\n\treturn  numreads * sizeof(u32);\n}\n\n \n \nstatic int ep0_out_overbytes(struct nbu2ss_udc *udc, u8 *p_buf, u32 length)\n{\n\tu32\t\ti;\n\tu32\t\ti_read_size = 0;\n\tunion usb_reg_access  temp_32;\n\tunion usb_reg_access  *p_buf_32 = (union usb_reg_access *)p_buf;\n\n\tif ((length > 0) && (length < sizeof(u32))) {\n\t\ttemp_32.dw = _nbu2ss_readl(&udc->p_regs->EP0_READ);\n\t\tfor (i = 0 ; i < length ; i++)\n\t\t\tp_buf_32->byte.DATA[i] = temp_32.byte.DATA[i];\n\t\ti_read_size += length;\n\t}\n\n\treturn i_read_size;\n}\n\n \n \nstatic int EP0_in_PIO(struct nbu2ss_udc *udc, u8 *p_buf, u32 length)\n{\n\tu32\t\ti;\n\tu32\t\ti_max_length   = EP0_PACKETSIZE;\n\tu32\t\ti_word_length  = 0;\n\tu32\t\ti_write_length = 0;\n\tunion usb_reg_access  *p_buf_32 = (union usb_reg_access *)p_buf;\n\n\t \n\t \n\tif (i_max_length < length)\n\t\ti_word_length = i_max_length / sizeof(u32);\n\telse\n\t\ti_word_length = length / sizeof(u32);\n\n\t \n\t \n\tfor (i = 0; i < i_word_length; i++) {\n\t\t_nbu2ss_writel(&udc->p_regs->EP0_WRITE, p_buf_32->dw);\n\t\tp_buf_32++;\n\t\ti_write_length += sizeof(u32);\n\t}\n\n\treturn i_write_length;\n}\n\n \n \nstatic int ep0_in_overbytes(struct nbu2ss_udc *udc,\n\t\t\t    u8 *p_buf,\n\t\t\t    u32 i_remain_size)\n{\n\tu32\t\ti;\n\tunion usb_reg_access  temp_32;\n\tunion usb_reg_access  *p_buf_32 = (union usb_reg_access *)p_buf;\n\n\tif ((i_remain_size > 0) && (i_remain_size < sizeof(u32))) {\n\t\tfor (i = 0 ; i < i_remain_size ; i++)\n\t\t\ttemp_32.byte.DATA[i] = p_buf_32->byte.DATA[i];\n\t\t_nbu2ss_ep_in_end(udc, 0, temp_32.dw, i_remain_size);\n\n\t\treturn i_remain_size;\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic int EP0_send_NULL(struct nbu2ss_udc *udc, bool pid_flag)\n{\n\tu32\t\tdata;\n\n\tdata = _nbu2ss_readl(&udc->p_regs->EP0_CONTROL);\n\tdata &= ~(u32)EP0_INAK;\n\n\tif (pid_flag)\n\t\tdata |= (EP0_INAK_EN | EP0_PIDCLR | EP0_DEND);\n\telse\n\t\tdata |= (EP0_INAK_EN | EP0_DEND);\n\n\t_nbu2ss_writel(&udc->p_regs->EP0_CONTROL, data);\n\n\treturn 0;\n}\n\n \n \nstatic int EP0_receive_NULL(struct nbu2ss_udc *udc, bool pid_flag)\n{\n\tu32\t\tdata;\n\n\tdata = _nbu2ss_readl(&udc->p_regs->EP0_CONTROL);\n\tdata &= ~(u32)EP0_ONAK;\n\n\tif (pid_flag)\n\t\tdata |= EP0_PIDCLR;\n\n\t_nbu2ss_writel(&udc->p_regs->EP0_CONTROL, data);\n\n\treturn 0;\n}\n\n \nstatic int _nbu2ss_ep0_in_transfer(struct nbu2ss_udc *udc,\n\t\t\t\t   struct nbu2ss_req *req)\n{\n\tu8\t\t*p_buffer;\t\t\t \n\tu32\t\tdata;\n\tu32\t\ti_remain_size = 0;\n\tint\t\tresult = 0;\n\n\t \n\t \n\tif (req->req.actual == req->req.length) {\n\t\tif ((req->req.actual % EP0_PACKETSIZE) == 0) {\n\t\t\tif (req->zero) {\n\t\t\t\treq->zero = false;\n\t\t\t\tEP0_send_NULL(udc, false);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\t\t \n\t}\n\n\t \n\t \n\tdata = _nbu2ss_readl(&udc->p_regs->EP0_CONTROL);\n\tdata |= EP0_INAK_EN;\n\tdata &= ~(u32)EP0_INAK;\n\t_nbu2ss_writel(&udc->p_regs->EP0_CONTROL, data);\n\n\ti_remain_size = req->req.length - req->req.actual;\n\tp_buffer = (u8 *)req->req.buf;\n\tp_buffer += req->req.actual;\n\n\t \n\t \n\tresult = EP0_in_PIO(udc, p_buffer, i_remain_size);\n\n\treq->div_len = result;\n\ti_remain_size -= result;\n\n\tif (i_remain_size == 0) {\n\t\tEP0_send_NULL(udc, false);\n\t\treturn result;\n\t}\n\n\tif ((i_remain_size < sizeof(u32)) && (result != EP0_PACKETSIZE)) {\n\t\tp_buffer += result;\n\t\tresult += ep0_in_overbytes(udc, p_buffer, i_remain_size);\n\t\treq->div_len = result;\n\t}\n\n\treturn result;\n}\n\n \nstatic int _nbu2ss_ep0_out_transfer(struct nbu2ss_udc *udc,\n\t\t\t\t    struct nbu2ss_req *req)\n{\n\tu8\t\t*p_buffer;\n\tu32\t\ti_remain_size;\n\tu32\t\ti_recv_length;\n\tint\t\tresult = 0;\n\tint\t\tf_rcv_zero;\n\n\t \n\t \n\ti_recv_length = _nbu2ss_readl(&udc->p_regs->EP0_LENGTH) & EP0_LDATA;\n\tif (i_recv_length != 0) {\n\t\tf_rcv_zero = 0;\n\n\t\ti_remain_size = req->req.length - req->req.actual;\n\t\tp_buffer = (u8 *)req->req.buf;\n\t\tp_buffer += req->req.actual;\n\n\t\tresult = ep0_out_pio(udc, p_buffer\n\t\t\t\t\t, min(i_remain_size, i_recv_length));\n\t\tif (result < 0)\n\t\t\treturn result;\n\n\t\treq->req.actual += result;\n\t\ti_recv_length -= result;\n\n\t\tif ((i_recv_length > 0) && (i_recv_length < sizeof(u32))) {\n\t\t\tp_buffer += result;\n\t\t\ti_remain_size -= result;\n\n\t\t\tresult = ep0_out_overbytes(udc, p_buffer\n\t\t\t\t\t, min(i_remain_size, i_recv_length));\n\t\t\treq->req.actual += result;\n\t\t}\n\t} else {\n\t\tf_rcv_zero = 1;\n\t}\n\n\t \n\t \n\tif (req->req.actual == req->req.length) {\n\t\tif ((req->req.actual % EP0_PACKETSIZE) == 0) {\n\t\t\tif (req->zero) {\n\t\t\t\treq->zero = false;\n\t\t\t\tEP0_receive_NULL(udc, false);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\t\t \n\t}\n\n\tif ((req->req.actual % EP0_PACKETSIZE) != 0)\n\t\treturn 0;\t\t \n\n\tif (req->req.actual > req->req.length) {\n\t\tdev_err(udc->dev, \" *** Overrun Error\\n\");\n\t\treturn -EOVERFLOW;\n\t}\n\n\tif (f_rcv_zero != 0) {\n\t\ti_remain_size = _nbu2ss_readl(&udc->p_regs->EP0_CONTROL);\n\t\tif (i_remain_size & EP0_ONAK) {\n\t\t\t \n\t\t\t \n\t\t\t_nbu2ss_bitclr(&udc->p_regs->EP0_CONTROL, EP0_ONAK);\n\t\t}\n\t\tresult = 1;\n\t}\n\n\treturn result;\n}\n\n \nstatic int _nbu2ss_out_dma(struct nbu2ss_udc *udc, struct nbu2ss_req *req,\n\t\t\t   u32 num, u32 length)\n{\n\tdma_addr_t\tp_buffer;\n\tu32\t\tmpkt;\n\tu32\t\tlmpkt;\n\tu32\t\tdmacnt;\n\tu32\t\tburst = 1;\n\tu32\t\tdata;\n\tint\t\tresult;\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\tif (req->dma_flag)\n\t\treturn 1;\t\t \n\n\treq->dma_flag = true;\n\tp_buffer = req->req.dma;\n\tp_buffer += req->req.actual;\n\n\t \n\t_nbu2ss_writel(&preg->EP_DCR[num].EP_TADR, (u32)p_buffer);\n\n\t \n\tmpkt = _nbu2ss_readl(&preg->EP_REGS[num].EP_PCKT_ADRS) & EPN_MPKT;\n\tdmacnt = length / mpkt;\n\tlmpkt = (length % mpkt) & ~(u32)0x03;\n\n\tif (dmacnt > DMA_MAX_COUNT) {\n\t\tdmacnt = DMA_MAX_COUNT;\n\t\tlmpkt = 0;\n\t} else if (lmpkt != 0) {\n\t\tif (dmacnt == 0)\n\t\t\tburst = 0;\t \n\t\tdmacnt++;\n\t}\n\n\tdata = mpkt | (lmpkt << 16);\n\t_nbu2ss_writel(&preg->EP_DCR[num].EP_DCR2, data);\n\n\tdata = ((dmacnt & 0xff) << 16) | DCR1_EPN_DIR0 | DCR1_EPN_REQEN;\n\t_nbu2ss_writel(&preg->EP_DCR[num].EP_DCR1, data);\n\n\tif (burst == 0) {\n\t\t_nbu2ss_writel(&preg->EP_REGS[num].EP_LEN_DCNT, 0);\n\t\t_nbu2ss_bitclr(&preg->EP_REGS[num].EP_DMA_CTRL, EPN_BURST_SET);\n\t} else {\n\t\t_nbu2ss_writel(&preg->EP_REGS[num].EP_LEN_DCNT\n\t\t\t\t, (dmacnt << 16));\n\t\t_nbu2ss_bitset(&preg->EP_REGS[num].EP_DMA_CTRL, EPN_BURST_SET);\n\t}\n\t_nbu2ss_bitset(&preg->EP_REGS[num].EP_DMA_CTRL, EPN_DMA_EN);\n\n\tresult = length & ~(u32)0x03;\n\treq->div_len = result;\n\n\treturn result;\n}\n\n \nstatic int _nbu2ss_epn_out_pio(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep,\n\t\t\t       struct nbu2ss_req *req, u32 length)\n{\n\tu8\t\t*p_buffer;\n\tu32\t\ti;\n\tu32\t\tdata;\n\tu32\t\ti_word_length;\n\tunion usb_reg_access\ttemp_32;\n\tunion usb_reg_access\t*p_buf_32;\n\tint\t\tresult = 0;\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\tif (req->dma_flag)\n\t\treturn 1;\t\t \n\n\tif (length == 0)\n\t\treturn 0;\n\n\tp_buffer = (u8 *)req->req.buf;\n\tp_buf_32 = (union usb_reg_access *)(p_buffer + req->req.actual);\n\n\ti_word_length = length / sizeof(u32);\n\tif (i_word_length > 0) {\n\t\t \n\t\t \n\t\tfor (i = 0; i < i_word_length; i++) {\n\t\t\tp_buf_32->dw =\n\t\t\t_nbu2ss_readl(&preg->EP_REGS[ep->epnum - 1].EP_READ);\n\t\t\tp_buf_32++;\n\t\t}\n\t\tresult = i_word_length * sizeof(u32);\n\t}\n\n\tdata = length - result;\n\tif (data > 0) {\n\t\t \n\t\t \n\t\ttemp_32.dw =\n\t\t\t_nbu2ss_readl(&preg->EP_REGS[ep->epnum - 1].EP_READ);\n\t\tfor (i = 0 ; i < data ; i++)\n\t\t\tp_buf_32->byte.DATA[i] = temp_32.byte.DATA[i];\n\t\tresult += data;\n\t}\n\n\treq->req.actual += result;\n\n\tif ((req->req.actual == req->req.length) ||\n\t    ((req->req.actual % ep->ep.maxpacket) != 0)) {\n\t\tresult = 0;\n\t}\n\n\treturn result;\n}\n\n \nstatic int _nbu2ss_epn_out_data(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep,\n\t\t\t\tstruct nbu2ss_req *req, u32 data_size)\n{\n\tu32\t\tnum;\n\tu32\t\ti_buf_size;\n\tint\t\tnret = 1;\n\n\tif (ep->epnum == 0)\n\t\treturn -EINVAL;\n\n\tnum = ep->epnum - 1;\n\n\ti_buf_size = min((req->req.length - req->req.actual), data_size);\n\n\tif ((ep->ep_type != USB_ENDPOINT_XFER_INT) && (req->req.dma != 0) &&\n\t    (i_buf_size  >= sizeof(u32))) {\n\t\tnret = _nbu2ss_out_dma(udc, req, num, i_buf_size);\n\t} else {\n\t\ti_buf_size = min_t(u32, i_buf_size, ep->ep.maxpacket);\n\t\tnret = _nbu2ss_epn_out_pio(udc, ep, req, i_buf_size);\n\t}\n\n\treturn nret;\n}\n\n \nstatic int _nbu2ss_epn_out_transfer(struct nbu2ss_udc *udc,\n\t\t\t\t    struct nbu2ss_ep *ep,\n\t\t\t\t    struct nbu2ss_req *req)\n{\n\tu32\t\tnum;\n\tu32\t\ti_recv_length;\n\tint\t\tresult = 1;\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\tif (ep->epnum == 0)\n\t\treturn -EINVAL;\n\n\tnum = ep->epnum - 1;\n\n\t \n\t \n\ti_recv_length =\n\t\t_nbu2ss_readl(&preg->EP_REGS[num].EP_LEN_DCNT) & EPN_LDATA;\n\n\tif (i_recv_length != 0) {\n\t\tresult = _nbu2ss_epn_out_data(udc, ep, req, i_recv_length);\n\t\tif (i_recv_length < ep->ep.maxpacket) {\n\t\t\tif (i_recv_length == result) {\n\t\t\t\treq->req.actual += result;\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((req->req.actual == req->req.length) ||\n\t\t    ((req->req.actual % ep->ep.maxpacket) != 0)) {\n\t\t\tresult = 0;\n\t\t}\n\t}\n\n\tif (result == 0) {\n\t\tif ((req->req.actual % ep->ep.maxpacket) == 0) {\n\t\t\tif (req->zero) {\n\t\t\t\treq->zero = false;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (req->req.actual > req->req.length) {\n\t\tdev_err(udc->dev, \" Overrun Error\\n\");\n\t\tdev_err(udc->dev, \" actual = %d, length = %d\\n\",\n\t\t\treq->req.actual, req->req.length);\n\t\tresult = -EOVERFLOW;\n\t}\n\n\treturn result;\n}\n\n \nstatic int _nbu2ss_in_dma(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep,\n\t\t\t  struct nbu2ss_req *req, u32 num, u32 length)\n{\n\tdma_addr_t\tp_buffer;\n\tu32\t\tmpkt;\t\t \n\tu32\t\tlmpkt;\t\t \n\tu32\t\tdmacnt;\t\t \n\tu32\t\ti_write_length;\n\tu32\t\tdata;\n\tint\t\tresult = -EINVAL;\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\tif (req->dma_flag)\n\t\treturn 1;\t\t \n\n#ifdef USE_DMA\n\tif (req->req.actual == 0)\n\t\t_nbu2ss_dma_map_single(udc, ep, req, USB_DIR_IN);\n#endif\n\treq->dma_flag = true;\n\n\t \n\tmpkt = _nbu2ss_readl(&preg->EP_REGS[num].EP_PCKT_ADRS) & EPN_MPKT;\n\n\ti_write_length = min(DMA_MAX_COUNT * mpkt, length);\n\n\t \n\t \n\tif (mpkt < i_write_length) {\n\t\tdmacnt = i_write_length / mpkt;\n\t\tlmpkt  = (i_write_length % mpkt) & ~(u32)0x3;\n\t\tif (lmpkt != 0)\n\t\t\tdmacnt++;\n\t\telse\n\t\t\tlmpkt = mpkt & ~(u32)0x3;\n\n\t} else {\n\t\tdmacnt = 1;\n\t\tlmpkt  = i_write_length & ~(u32)0x3;\n\t}\n\n\t \n\tdata = mpkt | (lmpkt << 16);\n\t_nbu2ss_writel(&preg->EP_DCR[num].EP_DCR2, data);\n\n\t \n\tp_buffer = req->req.dma;\n\tp_buffer += req->req.actual;\n\t_nbu2ss_writel(&preg->EP_DCR[num].EP_TADR, (u32)p_buffer);\n\n\t \n\tdata = ((dmacnt & 0xff) << 16) | DCR1_EPN_REQEN;\n\t_nbu2ss_writel(&preg->EP_DCR[num].EP_DCR1, data);\n\n\t \n\tdata = dmacnt << 16;\n\t_nbu2ss_writel(&preg->EP_REGS[num].EP_LEN_DCNT, data);\n\n\t \n\t_nbu2ss_bitset(&preg->EP_REGS[num].EP_DMA_CTRL, EPN_DMA_EN);\n\n\tresult = i_write_length & ~(u32)0x3;\n\treq->div_len = result;\n\n\treturn result;\n}\n\n \nstatic int _nbu2ss_epn_in_pio(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep,\n\t\t\t      struct nbu2ss_req *req, u32 length)\n{\n\tu8\t\t*p_buffer;\n\tu32\t\ti;\n\tu32\t\tdata;\n\tu32\t\ti_word_length;\n\tunion usb_reg_access\ttemp_32;\n\tunion usb_reg_access\t*p_buf_32 = NULL;\n\tint\t\tresult = 0;\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\tif (req->dma_flag)\n\t\treturn 1;\t\t \n\n\tif (length > 0) {\n\t\tp_buffer = (u8 *)req->req.buf;\n\t\tp_buf_32 = (union usb_reg_access *)(p_buffer + req->req.actual);\n\n\t\ti_word_length = length / sizeof(u32);\n\t\tif (i_word_length > 0) {\n\t\t\tfor (i = 0; i < i_word_length; i++) {\n\t\t\t\t_nbu2ss_writel(&preg->EP_REGS[ep->epnum - 1].EP_WRITE,\n\t\t\t\t\t       p_buf_32->dw);\n\n\t\t\t\tp_buf_32++;\n\t\t\t}\n\t\t\tresult = i_word_length * sizeof(u32);\n\t\t}\n\t}\n\n\tif (result != ep->ep.maxpacket) {\n\t\tdata = length - result;\n\t\ttemp_32.dw = 0;\n\t\tfor (i = 0 ; i < data ; i++)\n\t\t\ttemp_32.byte.DATA[i] = p_buf_32->byte.DATA[i];\n\n\t\t_nbu2ss_ep_in_end(udc, ep->epnum, temp_32.dw, data);\n\t\tresult += data;\n\t}\n\n\treq->div_len = result;\n\n\treturn result;\n}\n\n \nstatic int _nbu2ss_epn_in_data(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep,\n\t\t\t       struct nbu2ss_req *req, u32 data_size)\n{\n\tu32\t\tnum;\n\tint\t\tnret = 1;\n\n\tif (ep->epnum == 0)\n\t\treturn -EINVAL;\n\n\tnum = ep->epnum - 1;\n\n\tif ((ep->ep_type != USB_ENDPOINT_XFER_INT) && (req->req.dma != 0) &&\n\t    (data_size >= sizeof(u32))) {\n\t\tnret = _nbu2ss_in_dma(udc, ep, req, num, data_size);\n\t} else {\n\t\tdata_size = min_t(u32, data_size, ep->ep.maxpacket);\n\t\tnret = _nbu2ss_epn_in_pio(udc, ep, req, data_size);\n\t}\n\n\treturn nret;\n}\n\n \nstatic int _nbu2ss_epn_in_transfer(struct nbu2ss_udc *udc,\n\t\t\t\t   struct nbu2ss_ep *ep, struct nbu2ss_req *req)\n{\n\tu32\t\tnum;\n\tu32\t\ti_buf_size;\n\tint\t\tresult = 0;\n\tu32\t\tstatus;\n\n\tif (ep->epnum == 0)\n\t\treturn -EINVAL;\n\n\tnum = ep->epnum - 1;\n\n\tstatus = _nbu2ss_readl(&udc->p_regs->EP_REGS[num].EP_STATUS);\n\n\t \n\t \n\tif (req->req.actual == 0) {\n\t\tif ((status & EPN_IN_EMPTY) == 0)\n\t\t\treturn 1;\t \n\n\t} else {\n\t\tif ((status & EPN_IN_FULL) != 0)\n\t\t\treturn 1;\t \n\t}\n\n\t \n\t \n\ti_buf_size = req->req.length - req->req.actual;\n\tif (i_buf_size > 0)\n\t\tresult = _nbu2ss_epn_in_data(udc, ep, req, i_buf_size);\n\telse if (req->req.length == 0)\n\t\t_nbu2ss_zero_len_pkt(udc, ep->epnum);\n\n\treturn result;\n}\n\n \nstatic int _nbu2ss_start_transfer(struct nbu2ss_udc *udc,\n\t\t\t\t  struct nbu2ss_ep *ep,\n\t\t\t\t  struct nbu2ss_req *req,\n\t\t\t\t  bool\tbflag)\n{\n\tint\t\tnret = -EINVAL;\n\n\treq->dma_flag = false;\n\treq->div_len = 0;\n\n\tif (req->req.length == 0) {\n\t\treq->zero = false;\n\t} else {\n\t\tif ((req->req.length % ep->ep.maxpacket) == 0)\n\t\t\treq->zero = req->req.zero;\n\t\telse\n\t\t\treq->zero = false;\n\t}\n\n\tif (ep->epnum == 0) {\n\t\t \n\t\tswitch (udc->ep0state) {\n\t\tcase EP0_IN_DATA_PHASE:\n\t\t\tnret = _nbu2ss_ep0_in_transfer(udc, req);\n\t\t\tbreak;\n\n\t\tcase EP0_OUT_DATA_PHASE:\n\t\t\tnret = _nbu2ss_ep0_out_transfer(udc, req);\n\t\t\tbreak;\n\n\t\tcase EP0_IN_STATUS_PHASE:\n\t\t\tnret = EP0_send_NULL(udc, true);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t} else {\n\t\t \n\t\tif (ep->direct == USB_DIR_OUT) {\n\t\t\t \n\t\t\tif (!bflag)\n\t\t\t\tnret = _nbu2ss_epn_out_transfer(udc, ep, req);\n\t\t} else {\n\t\t\t \n\t\t\tnret = _nbu2ss_epn_in_transfer(udc, ep, req);\n\t\t}\n\t}\n\n\treturn nret;\n}\n\n \nstatic void _nbu2ss_restert_transfer(struct nbu2ss_ep *ep)\n{\n\tu32\t\tlength;\n\tbool\tbflag = false;\n\tstruct nbu2ss_req *req;\n\n\treq = list_first_entry_or_null(&ep->queue, struct nbu2ss_req, queue);\n\tif (!req)\n\t\treturn;\n\n\tif (ep->epnum > 0) {\n\t\tlength = _nbu2ss_readl(&ep->udc->p_regs->EP_REGS[ep->epnum - 1].EP_LEN_DCNT);\n\n\t\tlength &= EPN_LDATA;\n\t\tif (length < ep->ep.maxpacket)\n\t\t\tbflag = true;\n\t}\n\n\t_nbu2ss_start_transfer(ep->udc, ep, req, bflag);\n}\n\n \n \nstatic void _nbu2ss_endpoint_toggle_reset(struct nbu2ss_udc *udc, u8 ep_adrs)\n{\n\tu8\t\tnum;\n\tu32\t\tdata;\n\n\tif ((ep_adrs == 0) || (ep_adrs == 0x80))\n\t\treturn;\n\n\tnum = (ep_adrs & 0x7F) - 1;\n\n\tif (ep_adrs & USB_DIR_IN)\n\t\tdata = EPN_IPIDCLR;\n\telse\n\t\tdata = EPN_BCLR | EPN_OPIDCLR;\n\n\t_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\n}\n\n \n \nstatic void _nbu2ss_set_endpoint_stall(struct nbu2ss_udc *udc,\n\t\t\t\t       u8 ep_adrs, bool bstall)\n{\n\tu8\t\tnum, epnum;\n\tu32\t\tdata;\n\tstruct nbu2ss_ep *ep;\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\tif ((ep_adrs == 0) || (ep_adrs == 0x80)) {\n\t\tif (bstall) {\n\t\t\t \n\t\t\t_nbu2ss_bitset(&preg->EP0_CONTROL, EP0_STL);\n\t\t} else {\n\t\t\t \n\t\t\t_nbu2ss_bitclr(&preg->EP0_CONTROL, EP0_STL);\n\t\t}\n\t} else {\n\t\tepnum = ep_adrs & USB_ENDPOINT_NUMBER_MASK;\n\t\tnum = epnum - 1;\n\t\tep = &udc->ep[epnum];\n\n\t\tif (bstall) {\n\t\t\t \n\t\t\tep->halted = true;\n\n\t\t\tif (ep_adrs & USB_DIR_IN)\n\t\t\t\tdata = EPN_BCLR | EPN_ISTL;\n\t\t\telse\n\t\t\t\tdata = EPN_OSTL_EN | EPN_OSTL;\n\n\t\t\t_nbu2ss_bitset(&preg->EP_REGS[num].EP_CONTROL, data);\n\t\t} else {\n\t\t\tif (ep_adrs & USB_DIR_IN) {\n\t\t\t\t_nbu2ss_bitclr(&preg->EP_REGS[num].EP_CONTROL\n\t\t\t\t\t\t, EPN_ISTL);\n\t\t\t} else {\n\t\t\t\tdata =\n\t\t\t\t_nbu2ss_readl(&preg->EP_REGS[num].EP_CONTROL);\n\n\t\t\t\tdata &= ~EPN_OSTL;\n\t\t\t\tdata |= EPN_OSTL_EN;\n\n\t\t\t\t_nbu2ss_writel(&preg->EP_REGS[num].EP_CONTROL\n\t\t\t\t\t\t, data);\n\t\t\t}\n\n\t\t\t \n\t\t\tep->stalled = false;\n\t\t\tif (ep->halted) {\n\t\t\t\tep->halted = false;\n\t\t\t\t_nbu2ss_restert_transfer(ep);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void _nbu2ss_set_test_mode(struct nbu2ss_udc *udc, u32 mode)\n{\n\tu32\t\tdata;\n\n\tif (mode > MAX_TEST_MODE_NUM)\n\t\treturn;\n\n\tdev_info(udc->dev, \"SET FEATURE : test mode = %d\\n\", mode);\n\n\tdata = _nbu2ss_readl(&udc->p_regs->USB_CONTROL);\n\tdata &= ~TEST_FORCE_ENABLE;\n\tdata |= mode << TEST_MODE_SHIFT;\n\n\t_nbu2ss_writel(&udc->p_regs->USB_CONTROL, data);\n\t_nbu2ss_bitset(&udc->p_regs->TEST_CONTROL, CS_TESTMODEEN);\n}\n\n \nstatic int _nbu2ss_set_feature_device(struct nbu2ss_udc *udc,\n\t\t\t\t      u16 selector, u16 wIndex)\n{\n\tint\tresult = -EOPNOTSUPP;\n\n\tswitch (selector) {\n\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\tif (wIndex == 0x0000) {\n\t\t\tudc->remote_wakeup = U2F_ENABLE;\n\t\t\tresult = 0;\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_TEST_MODE:\n\t\twIndex >>= 8;\n\t\tif (wIndex <= MAX_TEST_MODE_NUM)\n\t\t\tresult = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\n \nstatic int _nbu2ss_get_ep_stall(struct nbu2ss_udc *udc, u8 ep_adrs)\n{\n\tu8\t\tepnum;\n\tu32\t\tdata = 0, bit_data;\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\tepnum = ep_adrs & ~USB_ENDPOINT_DIR_MASK;\n\tif (epnum == 0) {\n\t\tdata = _nbu2ss_readl(&preg->EP0_CONTROL);\n\t\tbit_data = EP0_STL;\n\n\t} else {\n\t\tdata = _nbu2ss_readl(&preg->EP_REGS[epnum - 1].EP_CONTROL);\n\t\tif ((data & EPN_EN) == 0)\n\t\t\treturn -1;\n\n\t\tif (ep_adrs & USB_ENDPOINT_DIR_MASK)\n\t\t\tbit_data = EPN_ISTL;\n\t\telse\n\t\t\tbit_data = EPN_OSTL;\n\t}\n\n\tif ((data & bit_data) == 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic inline int _nbu2ss_req_feature(struct nbu2ss_udc *udc, bool bset)\n{\n\tu8\trecipient = (u8)(udc->ctrl.bRequestType & USB_RECIP_MASK);\n\tu8\tdirection = (u8)(udc->ctrl.bRequestType & USB_DIR_IN);\n\tu16\tselector  = le16_to_cpu(udc->ctrl.wValue);\n\tu16\twIndex    = le16_to_cpu(udc->ctrl.wIndex);\n\tu8\tep_adrs;\n\tint\tresult = -EOPNOTSUPP;\n\n\tif ((udc->ctrl.wLength != 0x0000) ||\n\t    (direction != USB_DIR_OUT)) {\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (recipient) {\n\tcase USB_RECIP_DEVICE:\n\t\tif (bset)\n\t\t\tresult =\n\t\t\t_nbu2ss_set_feature_device(udc, selector, wIndex);\n\t\tbreak;\n\n\tcase USB_RECIP_ENDPOINT:\n\t\tif (0x0000 == (wIndex & 0xFF70)) {\n\t\t\tif (selector == USB_ENDPOINT_HALT) {\n\t\t\t\tep_adrs = wIndex & 0xFF;\n\t\t\t\tif (!bset) {\n\t\t\t\t\t_nbu2ss_endpoint_toggle_reset(udc,\n\t\t\t\t\t\t\t\t      ep_adrs);\n\t\t\t\t}\n\n\t\t\t\t_nbu2ss_set_endpoint_stall(udc, ep_adrs, bset);\n\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (result >= 0)\n\t\t_nbu2ss_create_ep0_packet(udc, udc->ep0_buf, 0);\n\n\treturn result;\n}\n\n \nstatic inline enum usb_device_speed _nbu2ss_get_speed(struct nbu2ss_udc *udc)\n{\n\tu32\t\tdata;\n\tenum usb_device_speed speed = USB_SPEED_FULL;\n\n\tdata = _nbu2ss_readl(&udc->p_regs->USB_STATUS);\n\tif (data & HIGH_SPEED)\n\t\tspeed = USB_SPEED_HIGH;\n\n\treturn speed;\n}\n\n \nstatic void _nbu2ss_epn_set_stall(struct nbu2ss_udc *udc,\n\t\t\t\t  struct nbu2ss_ep *ep)\n{\n\tu8\tep_adrs;\n\tu32\tregdata;\n\tint\tlimit_cnt = 0;\n\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\tif (ep->direct == USB_DIR_IN) {\n\t\tfor (limit_cnt = 0\n\t\t\t; limit_cnt < IN_DATA_EMPTY_COUNT\n\t\t\t; limit_cnt++) {\n\t\t\tregdata = _nbu2ss_readl(&preg->EP_REGS[ep->epnum - 1].EP_STATUS);\n\n\t\t\tif ((regdata & EPN_IN_DATA) == 0)\n\t\t\t\tbreak;\n\n\t\t\tmdelay(1);\n\t\t}\n\t}\n\n\tep_adrs = ep->epnum | ep->direct;\n\t_nbu2ss_set_endpoint_stall(udc, ep_adrs, 1);\n}\n\n \nstatic int std_req_get_status(struct nbu2ss_udc *udc)\n{\n\tu32\tlength;\n\tu16\tstatus_data = 0;\n\tu8\trecipient = (u8)(udc->ctrl.bRequestType & USB_RECIP_MASK);\n\tu8\tdirection = (u8)(udc->ctrl.bRequestType & USB_DIR_IN);\n\tu8\tep_adrs;\n\tint\tresult = -EINVAL;\n\n\tif ((udc->ctrl.wValue != 0x0000) || (direction != USB_DIR_IN))\n\t\treturn result;\n\n\tlength =\n\t\tmin_t(u16, le16_to_cpu(udc->ctrl.wLength), sizeof(status_data));\n\tswitch (recipient) {\n\tcase USB_RECIP_DEVICE:\n\t\tif (udc->ctrl.wIndex == 0x0000) {\n\t\t\tif (udc->gadget.is_selfpowered)\n\t\t\t\tstatus_data |= BIT(USB_DEVICE_SELF_POWERED);\n\n\t\t\tif (udc->remote_wakeup)\n\t\t\t\tstatus_data |= BIT(USB_DEVICE_REMOTE_WAKEUP);\n\n\t\t\tresult = 0;\n\t\t}\n\t\tbreak;\n\n\tcase USB_RECIP_ENDPOINT:\n\t\tif (0x0000 == (le16_to_cpu(udc->ctrl.wIndex) & 0xFF70)) {\n\t\t\tep_adrs = (u8)(le16_to_cpu(udc->ctrl.wIndex) & 0xFF);\n\t\t\tresult = _nbu2ss_get_ep_stall(udc, ep_adrs);\n\n\t\t\tif (result > 0)\n\t\t\t\tstatus_data |= BIT(USB_ENDPOINT_HALT);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (result >= 0) {\n\t\tmemcpy(udc->ep0_buf, &status_data, length);\n\t\t_nbu2ss_create_ep0_packet(udc, udc->ep0_buf, length);\n\t\t_nbu2ss_ep0_in_transfer(udc, &udc->ep0_req);\n\n\t} else {\n\t\tdev_err(udc->dev, \" Error GET_STATUS\\n\");\n\t}\n\n\treturn result;\n}\n\n \nstatic int std_req_clear_feature(struct nbu2ss_udc *udc)\n{\n\treturn _nbu2ss_req_feature(udc, false);\n}\n\n \nstatic int std_req_set_feature(struct nbu2ss_udc *udc)\n{\n\treturn _nbu2ss_req_feature(udc, true);\n}\n\n \nstatic int std_req_set_address(struct nbu2ss_udc *udc)\n{\n\tint\t\tresult = 0;\n\tu32\t\twValue = le16_to_cpu(udc->ctrl.wValue);\n\n\tif ((udc->ctrl.bRequestType != 0x00)\t||\n\t    (udc->ctrl.wIndex != 0x0000)\t||\n\t\t(udc->ctrl.wLength != 0x0000)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (wValue != (wValue & 0x007F))\n\t\treturn -EINVAL;\n\n\twValue <<= USB_ADRS_SHIFT;\n\n\t_nbu2ss_writel(&udc->p_regs->USB_ADDRESS, wValue);\n\t_nbu2ss_create_ep0_packet(udc, udc->ep0_buf, 0);\n\n\treturn result;\n}\n\n \nstatic int std_req_set_configuration(struct nbu2ss_udc *udc)\n{\n\tu32 config_value = (u32)(le16_to_cpu(udc->ctrl.wValue) & 0x00ff);\n\n\tif ((udc->ctrl.wIndex != 0x0000)\t||\n\t    (udc->ctrl.wLength != 0x0000)\t||\n\t\t(udc->ctrl.bRequestType != 0x00)) {\n\t\treturn -EINVAL;\n\t}\n\n\tudc->curr_config = config_value;\n\n\tif (config_value > 0) {\n\t\t_nbu2ss_bitset(&udc->p_regs->USB_CONTROL, CONF);\n\t\tudc->devstate = USB_STATE_CONFIGURED;\n\n\t} else {\n\t\t_nbu2ss_bitclr(&udc->p_regs->USB_CONTROL, CONF);\n\t\tudc->devstate = USB_STATE_ADDRESS;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline void _nbu2ss_read_request_data(struct nbu2ss_udc *udc, u32 *pdata)\n{\n\t*pdata = _nbu2ss_readl(&udc->p_regs->SETUP_DATA0);\n\tpdata++;\n\t*pdata = _nbu2ss_readl(&udc->p_regs->SETUP_DATA1);\n}\n\n \nstatic inline int _nbu2ss_decode_request(struct nbu2ss_udc *udc)\n{\n\tbool\t\t\tbcall_back = true;\n\tint\t\t\tnret = -EINVAL;\n\tstruct usb_ctrlrequest\t*p_ctrl;\n\n\tp_ctrl = &udc->ctrl;\n\t_nbu2ss_read_request_data(udc, (u32 *)p_ctrl);\n\n\t \n\tif (p_ctrl->wLength == 0) {\n\t\tudc->ep0state = EP0_IN_STATUS_PHASE;\n\n\t} else {\n\t\tif (p_ctrl->bRequestType & USB_DIR_IN)\n\t\t\tudc->ep0state = EP0_IN_DATA_PHASE;\n\t\telse\n\t\t\tudc->ep0state = EP0_OUT_DATA_PHASE;\n\t}\n\n\tif ((p_ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tswitch (p_ctrl->bRequest) {\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\tnret = std_req_get_status(udc);\n\t\t\tbcall_back = false;\n\t\t\tbreak;\n\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tnret = std_req_clear_feature(udc);\n\t\t\tbcall_back = false;\n\t\t\tbreak;\n\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tnret = std_req_set_feature(udc);\n\t\t\tbcall_back = false;\n\t\t\tbreak;\n\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\tnret = std_req_set_address(udc);\n\t\t\tbcall_back = false;\n\t\t\tbreak;\n\n\t\tcase USB_REQ_SET_CONFIGURATION:\n\t\t\tnret = std_req_set_configuration(udc);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!bcall_back) {\n\t\tif (udc->ep0state == EP0_IN_STATUS_PHASE) {\n\t\t\tif (nret >= 0) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tnret = EP0_send_NULL(udc, true);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tspin_unlock(&udc->lock);\n\t\tnret = udc->driver->setup(&udc->gadget, &udc->ctrl);\n\t\tspin_lock(&udc->lock);\n\t}\n\n\tif (nret < 0)\n\t\tudc->ep0state = EP0_IDLE;\n\n\treturn nret;\n}\n\n \nstatic inline int _nbu2ss_ep0_in_data_stage(struct nbu2ss_udc *udc)\n{\n\tint\t\t\tnret;\n\tstruct nbu2ss_req\t*req;\n\tstruct nbu2ss_ep\t*ep = &udc->ep[0];\n\n\treq = list_first_entry_or_null(&ep->queue, struct nbu2ss_req, queue);\n\tif (!req)\n\t\treq = &udc->ep0_req;\n\n\treq->req.actual += req->div_len;\n\treq->div_len = 0;\n\n\tnret = _nbu2ss_ep0_in_transfer(udc, req);\n\tif (nret == 0) {\n\t\tudc->ep0state = EP0_OUT_STATUS_PAHSE;\n\t\tEP0_receive_NULL(udc, true);\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int _nbu2ss_ep0_out_data_stage(struct nbu2ss_udc *udc)\n{\n\tint\t\t\tnret;\n\tstruct nbu2ss_req\t*req;\n\tstruct nbu2ss_ep\t*ep = &udc->ep[0];\n\n\treq = list_first_entry_or_null(&ep->queue, struct nbu2ss_req, queue);\n\tif (!req)\n\t\treq = &udc->ep0_req;\n\n\tnret = _nbu2ss_ep0_out_transfer(udc, req);\n\tif (nret == 0) {\n\t\tudc->ep0state = EP0_IN_STATUS_PHASE;\n\t\tEP0_send_NULL(udc, true);\n\n\t} else if (nret < 0) {\n\t\t_nbu2ss_bitset(&udc->p_regs->EP0_CONTROL, EP0_BCLR);\n\t\treq->req.status = nret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int _nbu2ss_ep0_status_stage(struct nbu2ss_udc *udc)\n{\n\tstruct nbu2ss_req\t*req;\n\tstruct nbu2ss_ep\t*ep = &udc->ep[0];\n\n\treq = list_first_entry_or_null(&ep->queue, struct nbu2ss_req, queue);\n\tif (!req) {\n\t\treq = &udc->ep0_req;\n\t\tif (req->req.complete)\n\t\t\treq->req.complete(&ep->ep, &req->req);\n\n\t} else {\n\t\tif (req->req.complete)\n\t\t\t_nbu2ss_ep_done(ep, req, 0);\n\t}\n\n\tudc->ep0state = EP0_IDLE;\n\n\treturn 0;\n}\n\n \nstatic inline void _nbu2ss_ep0_int(struct nbu2ss_udc *udc)\n{\n\tint\t\ti;\n\tu32\t\tstatus;\n\tu32\t\tintr;\n\tint\t\tnret = -1;\n\n\tstatus = _nbu2ss_readl(&udc->p_regs->EP0_STATUS);\n\tintr = status & EP0_STATUS_RW_BIT;\n\t_nbu2ss_writel(&udc->p_regs->EP0_STATUS, ~intr);\n\n\tstatus &= (SETUP_INT | EP0_IN_INT | EP0_OUT_INT\n\t\t\t| STG_END_INT | EP0_OUT_NULL_INT);\n\n\tif (status == 0) {\n\t\tdev_info(udc->dev, \"%s Not Decode Interrupt\\n\", __func__);\n\t\tdev_info(udc->dev, \"EP0_STATUS = 0x%08x\\n\", intr);\n\t\treturn;\n\t}\n\n\tif (udc->gadget.speed == USB_SPEED_UNKNOWN)\n\t\tudc->gadget.speed = _nbu2ss_get_speed(udc);\n\n\tfor (i = 0; i < EP0_END_XFER; i++) {\n\t\tswitch (udc->ep0state) {\n\t\tcase EP0_IDLE:\n\t\t\tif (status & SETUP_INT) {\n\t\t\t\tstatus = 0;\n\t\t\t\tnret = _nbu2ss_decode_request(udc);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EP0_IN_DATA_PHASE:\n\t\t\tif (status & EP0_IN_INT) {\n\t\t\t\tstatus &= ~EP0_IN_INT;\n\t\t\t\tnret = _nbu2ss_ep0_in_data_stage(udc);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EP0_OUT_DATA_PHASE:\n\t\t\tif (status & EP0_OUT_INT) {\n\t\t\t\tstatus &= ~EP0_OUT_INT;\n\t\t\t\tnret = _nbu2ss_ep0_out_data_stage(udc);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EP0_IN_STATUS_PHASE:\n\t\t\tif ((status & STG_END_INT) || (status & SETUP_INT)) {\n\t\t\t\tstatus &= ~(STG_END_INT | EP0_IN_INT);\n\t\t\t\tnret = _nbu2ss_ep0_status_stage(udc);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EP0_OUT_STATUS_PAHSE:\n\t\t\tif ((status & STG_END_INT) || (status & SETUP_INT) ||\n\t\t\t    (status & EP0_OUT_NULL_INT)) {\n\t\t\t\tstatus &= ~(STG_END_INT\n\t\t\t\t\t\t| EP0_OUT_INT\n\t\t\t\t\t\t| EP0_OUT_NULL_INT);\n\n\t\t\t\tnret = _nbu2ss_ep0_status_stage(udc);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (status == 0)\n\t\t\tbreak;\n\t}\n\n\tif (nret < 0) {\n\t\t \n\t\t_nbu2ss_set_endpoint_stall(udc, 0, true);\n\t}\n}\n\n \nstatic void _nbu2ss_ep_done(struct nbu2ss_ep *ep,\n\t\t\t    struct nbu2ss_req *req,\n\t\t\t    int status)\n{\n\tstruct nbu2ss_udc *udc = ep->udc;\n\n\tlist_del_init(&req->queue);\n\n\tif (status == -ECONNRESET)\n\t\t_nbu2ss_fifo_flush(udc, ep);\n\n\tif (likely(req->req.status == -EINPROGRESS))\n\t\treq->req.status = status;\n\n\tif (ep->stalled) {\n\t\t_nbu2ss_epn_set_stall(udc, ep);\n\t} else {\n\t\tif (!list_empty(&ep->queue))\n\t\t\t_nbu2ss_restert_transfer(ep);\n\t}\n\n#ifdef USE_DMA\n\tif ((ep->direct == USB_DIR_OUT) && (ep->epnum > 0) &&\n\t    (req->req.dma != 0))\n\t\t_nbu2ss_dma_unmap_single(udc, ep, req, USB_DIR_OUT);\n#endif\n\n\tspin_unlock(&udc->lock);\n\treq->req.complete(&ep->ep, &req->req);\n\tspin_lock(&udc->lock);\n}\n\n \nstatic inline void _nbu2ss_epn_in_int(struct nbu2ss_udc *udc,\n\t\t\t\t      struct nbu2ss_ep *ep,\n\t\t\t\t      struct nbu2ss_req *req)\n{\n\tint\tresult = 0;\n\tu32\tstatus;\n\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\tif (req->dma_flag)\n\t\treturn;\t\t \n\n\treq->req.actual += req->div_len;\n\treq->div_len = 0;\n\n\tif (req->req.actual != req->req.length) {\n\t\t \n\t\t \n\t\tresult = _nbu2ss_epn_in_transfer(udc, ep, req);\n\n\t} else {\n\t\tif (req->zero && ((req->req.actual % ep->ep.maxpacket) == 0)) {\n\t\t\tstatus =\n\t\t\t_nbu2ss_readl(&preg->EP_REGS[ep->epnum - 1].EP_STATUS);\n\n\t\t\tif ((status & EPN_IN_FULL) == 0) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\treq->zero = false;\n\t\t\t\t_nbu2ss_zero_len_pkt(udc, ep->epnum);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (result <= 0) {\n\t\t \n\t\t \n\t\t_nbu2ss_ep_done(ep, req, result);\n\t}\n}\n\n \nstatic inline void _nbu2ss_epn_out_int(struct nbu2ss_udc *udc,\n\t\t\t\t       struct nbu2ss_ep *ep,\n\t\t\t\t       struct nbu2ss_req *req)\n{\n\tint\tresult;\n\n\tresult = _nbu2ss_epn_out_transfer(udc, ep, req);\n\tif (result <= 0)\n\t\t_nbu2ss_ep_done(ep, req, result);\n}\n\n \nstatic inline void _nbu2ss_epn_in_dma_int(struct nbu2ss_udc *udc,\n\t\t\t\t\t  struct nbu2ss_ep *ep,\n\t\t\t\t\t  struct nbu2ss_req *req)\n{\n\tu32\t\tmpkt;\n\tu32\t\tsize;\n\tstruct usb_request *preq;\n\n\tpreq = &req->req;\n\n\tif (!req->dma_flag)\n\t\treturn;\n\n\tpreq->actual += req->div_len;\n\treq->div_len = 0;\n\treq->dma_flag = false;\n\n#ifdef USE_DMA\n\t_nbu2ss_dma_unmap_single(udc, ep, req, USB_DIR_IN);\n#endif\n\n\tif (preq->actual != preq->length) {\n\t\t_nbu2ss_epn_in_transfer(udc, ep, req);\n\t} else {\n\t\tmpkt = ep->ep.maxpacket;\n\t\tsize = preq->actual % mpkt;\n\t\tif (size > 0) {\n\t\t\tif (((preq->actual & 0x03) == 0) && (size < mpkt))\n\t\t\t\t_nbu2ss_ep_in_end(udc, ep->epnum, 0, 0);\n\t\t} else {\n\t\t\t_nbu2ss_epn_in_int(udc, ep, req);\n\t\t}\n\t}\n}\n\n \nstatic inline void _nbu2ss_epn_out_dma_int(struct nbu2ss_udc *udc,\n\t\t\t\t\t   struct nbu2ss_ep *ep,\n\t\t\t\t\t   struct nbu2ss_req *req)\n{\n\tint\t\ti;\n\tu32\t\tnum;\n\tu32\t\tdmacnt, ep_dmacnt;\n\tu32\t\tmpkt;\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\tnum = ep->epnum - 1;\n\n\tif (req->req.actual == req->req.length) {\n\t\tif ((req->req.length % ep->ep.maxpacket) && !req->zero) {\n\t\t\treq->div_len = 0;\n\t\t\treq->dma_flag = false;\n\t\t\t_nbu2ss_ep_done(ep, req, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tep_dmacnt = _nbu2ss_readl(&preg->EP_REGS[num].EP_LEN_DCNT)\n\t\t & EPN_DMACNT;\n\tep_dmacnt >>= 16;\n\n\tfor (i = 0; i < EPC_PLL_LOCK_COUNT; i++) {\n\t\tdmacnt = _nbu2ss_readl(&preg->EP_DCR[num].EP_DCR1)\n\t\t\t & DCR1_EPN_DMACNT;\n\t\tdmacnt >>= 16;\n\t\tif (ep_dmacnt == dmacnt)\n\t\t\tbreak;\n\t}\n\n\t_nbu2ss_bitclr(&preg->EP_DCR[num].EP_DCR1, DCR1_EPN_REQEN);\n\n\tif (dmacnt != 0) {\n\t\tmpkt = ep->ep.maxpacket;\n\t\tif ((req->div_len % mpkt) == 0)\n\t\t\treq->div_len -= mpkt * dmacnt;\n\t}\n\n\tif ((req->req.actual % ep->ep.maxpacket) > 0) {\n\t\tif (req->req.actual == req->div_len) {\n\t\t\treq->div_len = 0;\n\t\t\treq->dma_flag = false;\n\t\t\t_nbu2ss_ep_done(ep, req, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\treq->req.actual += req->div_len;\n\treq->div_len = 0;\n\treq->dma_flag = false;\n\n\t_nbu2ss_epn_out_int(udc, ep, req);\n}\n\n \nstatic inline void _nbu2ss_epn_int(struct nbu2ss_udc *udc, u32 epnum)\n{\n\tu32\tnum;\n\tu32\tstatus;\n\n\tstruct nbu2ss_req\t*req;\n\tstruct nbu2ss_ep\t*ep = &udc->ep[epnum];\n\n\tnum = epnum - 1;\n\n\t \n\tstatus = _nbu2ss_readl(&udc->p_regs->EP_REGS[num].EP_STATUS);\n\n\t \n\t_nbu2ss_writel(&udc->p_regs->EP_REGS[num].EP_STATUS, ~status);\n\n\treq = list_first_entry_or_null(&ep->queue, struct nbu2ss_req, queue);\n\tif (!req) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (status & EPN_OUT_END_INT) {\n\t\tstatus &= ~EPN_OUT_INT;\n\t\t_nbu2ss_epn_out_dma_int(udc, ep, req);\n\t}\n\n\tif (status & EPN_OUT_INT)\n\t\t_nbu2ss_epn_out_int(udc, ep, req);\n\n\tif (status & EPN_IN_END_INT) {\n\t\tstatus &= ~EPN_IN_INT;\n\t\t_nbu2ss_epn_in_dma_int(udc, ep, req);\n\t}\n\n\tif (status & EPN_IN_INT)\n\t\t_nbu2ss_epn_in_int(udc, ep, req);\n}\n\n \nstatic inline void _nbu2ss_ep_int(struct nbu2ss_udc *udc, u32 epnum)\n{\n\tif (epnum == 0)\n\t\t_nbu2ss_ep0_int(udc);\n\telse\n\t\t_nbu2ss_epn_int(udc, epnum);\n}\n\n \nstatic void _nbu2ss_ep0_enable(struct nbu2ss_udc *udc)\n{\n\t_nbu2ss_bitset(&udc->p_regs->EP0_CONTROL, (EP0_AUTO | EP0_BCLR));\n\t_nbu2ss_writel(&udc->p_regs->EP0_INT_ENA, EP0_INT_EN_BIT);\n}\n\n \nstatic int _nbu2ss_nuke(struct nbu2ss_udc *udc,\n\t\t\tstruct nbu2ss_ep *ep,\n\t\t\tint status)\n{\n\tstruct nbu2ss_req *req, *n;\n\n\t \n\t_nbu2ss_epn_exit(udc, ep);\n\n\t \n\t_nbu2ss_ep_dma_exit(udc, ep);\n\n\tif (list_empty(&ep->queue))\n\t\treturn 0;\n\n\t \n\tlist_for_each_entry_safe(req, n, &ep->queue, queue) {\n\t\t_nbu2ss_ep_done(ep, req, status);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void _nbu2ss_quiesce(struct nbu2ss_udc *udc)\n{\n\tstruct nbu2ss_ep\t*ep;\n\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\n\t_nbu2ss_nuke(udc, &udc->ep[0], -ESHUTDOWN);\n\n\t \n\tlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {\n\t\t_nbu2ss_nuke(udc, ep, -ESHUTDOWN);\n\t}\n}\n\n \nstatic int _nbu2ss_pullup(struct nbu2ss_udc *udc, int is_on)\n{\n\tu32\treg_dt;\n\n\tif (udc->vbus_active == 0)\n\t\treturn -ESHUTDOWN;\n\n\tif (is_on) {\n\t\t \n\t\tif (udc->driver) {\n\t\t\treg_dt = (_nbu2ss_readl(&udc->p_regs->USB_CONTROL)\n\t\t\t\t| PUE2) & ~(u32)CONNECTB;\n\n\t\t\t_nbu2ss_writel(&udc->p_regs->USB_CONTROL, reg_dt);\n\t\t}\n\n\t} else {\n\t\t \n\t\treg_dt = (_nbu2ss_readl(&udc->p_regs->USB_CONTROL) | CONNECTB)\n\t\t\t& ~(u32)PUE2;\n\n\t\t_nbu2ss_writel(&udc->p_regs->USB_CONTROL, reg_dt);\n\t\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void _nbu2ss_fifo_flush(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep)\n{\n\tstruct fc_regs __iomem *p = udc->p_regs;\n\n\tif (udc->vbus_active == 0)\n\t\treturn;\n\n\tif (ep->epnum == 0) {\n\t\t \n\t\t_nbu2ss_bitset(&p->EP0_CONTROL, EP0_BCLR);\n\n\t} else {\n\t\t \n\t\t_nbu2ss_ep_dma_abort(udc, ep);\n\t\t_nbu2ss_bitset(&p->EP_REGS[ep->epnum - 1].EP_CONTROL, EPN_BCLR);\n\t}\n}\n\n \nstatic int _nbu2ss_enable_controller(struct nbu2ss_udc *udc)\n{\n\tint\twaitcnt = 0;\n\n\tif (udc->udc_enabled)\n\t\treturn 0;\n\n\t \n\t_nbu2ss_bitset(&udc->p_regs->EPCTR, (DIRPD | EPC_RST));\n\tudelay(EPC_RST_DISABLE_TIME);\t \n\n\t_nbu2ss_bitclr(&udc->p_regs->EPCTR, DIRPD);\n\tmdelay(EPC_DIRPD_DISABLE_TIME);\t \n\n\t_nbu2ss_bitclr(&udc->p_regs->EPCTR, EPC_RST);\n\n\t_nbu2ss_writel(&udc->p_regs->AHBSCTR, WAIT_MODE);\n\n\t_nbu2ss_writel(&udc->p_regs->AHBMCTR,\n\t\t       HBUSREQ_MODE | HTRANS_MODE | WBURST_TYPE);\n\n\twhile (!(_nbu2ss_readl(&udc->p_regs->EPCTR) & PLL_LOCK)) {\n\t\twaitcnt++;\n\t\tudelay(1);\t \n\t\tif (waitcnt == EPC_PLL_LOCK_COUNT) {\n\t\t\tdev_err(udc->dev, \"*** Reset Cancel failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t_nbu2ss_bitset(&udc->p_regs->UTMI_CHARACTER_1, USB_SQUSET);\n\n\t_nbu2ss_bitset(&udc->p_regs->USB_CONTROL, (INT_SEL | SOF_RCV));\n\n\t \n\t_nbu2ss_ep0_enable(udc);\n\n\t \n\t_nbu2ss_bitset(&udc->p_regs->USB_INT_ENA, USB_INT_EN_BIT);\n\n\tudc->udc_enabled = true;\n\n\treturn 0;\n}\n\n \nstatic void _nbu2ss_reset_controller(struct nbu2ss_udc *udc)\n{\n\t_nbu2ss_bitset(&udc->p_regs->EPCTR, EPC_RST);\n\t_nbu2ss_bitclr(&udc->p_regs->EPCTR, EPC_RST);\n}\n\n \nstatic void _nbu2ss_disable_controller(struct nbu2ss_udc *udc)\n{\n\tif (udc->udc_enabled) {\n\t\tudc->udc_enabled = false;\n\t\t_nbu2ss_reset_controller(udc);\n\t\t_nbu2ss_bitset(&udc->p_regs->EPCTR, (DIRPD | EPC_RST));\n\t}\n}\n\n \nstatic inline void _nbu2ss_check_vbus(struct nbu2ss_udc *udc)\n{\n\tint\tnret;\n\tu32\treg_dt;\n\n\t \n\tmdelay(VBUS_CHATTERING_MDELAY);\t\t \n\n\t \n\treg_dt = gpiod_get_value(vbus_gpio);\n\tif (reg_dt == 0) {\n\t\tudc->linux_suspended = 0;\n\n\t\t_nbu2ss_reset_controller(udc);\n\t\tdev_info(udc->dev, \" ----- VBUS OFF\\n\");\n\n\t\tif (udc->vbus_active == 1) {\n\t\t\t \n\t\t\tudc->vbus_active = 0;\n\t\t\tif (udc->usb_suspended) {\n\t\t\t\tudc->usb_suspended = 0;\n\t\t\t\t \n\t\t\t}\n\t\t\tudc->devstate = USB_STATE_NOTATTACHED;\n\n\t\t\t_nbu2ss_quiesce(udc);\n\t\t\tif (udc->driver) {\n\t\t\t\tspin_unlock(&udc->lock);\n\t\t\t\tudc->driver->disconnect(&udc->gadget);\n\t\t\t\tspin_lock(&udc->lock);\n\t\t\t}\n\n\t\t\t_nbu2ss_disable_controller(udc);\n\t\t}\n\t} else {\n\t\tmdelay(5);\t\t \n\t\treg_dt = gpiod_get_value(vbus_gpio);\n\t\tif (reg_dt == 0)\n\t\t\treturn;\n\n\t\tdev_info(udc->dev, \" ----- VBUS ON\\n\");\n\n\t\tif (udc->linux_suspended)\n\t\t\treturn;\n\n\t\tif (udc->vbus_active == 0) {\n\t\t\t \n\t\t\tudc->vbus_active = 1;\n\t\t\tudc->devstate = USB_STATE_POWERED;\n\n\t\t\tnret = _nbu2ss_enable_controller(udc);\n\t\t\tif (nret < 0) {\n\t\t\t\t_nbu2ss_disable_controller(udc);\n\t\t\t\tudc->vbus_active = 0;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_nbu2ss_pullup(udc, 1);\n\n#ifdef UDC_DEBUG_DUMP\n\t\t\t_nbu2ss_dump_register(udc);\n#endif  \n\n\t\t} else {\n\t\t\tif (udc->devstate == USB_STATE_POWERED)\n\t\t\t\t_nbu2ss_pullup(udc, 1);\n\t\t}\n\t}\n}\n\n \nstatic inline void _nbu2ss_int_bus_reset(struct nbu2ss_udc *udc)\n{\n\tudc->devstate\t\t= USB_STATE_DEFAULT;\n\tudc->remote_wakeup\t= 0;\n\n\t_nbu2ss_quiesce(udc);\n\n\tudc->ep0state = EP0_IDLE;\n}\n\n \nstatic inline void _nbu2ss_int_usb_resume(struct nbu2ss_udc *udc)\n{\n\tif (udc->usb_suspended == 1) {\n\t\tudc->usb_suspended = 0;\n\t\tif (udc->driver && udc->driver->resume) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->resume(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n}\n\n \nstatic inline void _nbu2ss_int_usb_suspend(struct nbu2ss_udc *udc)\n{\n\tu32\treg_dt;\n\n\tif (udc->usb_suspended == 0) {\n\t\treg_dt = gpiod_get_value(vbus_gpio);\n\n\t\tif (reg_dt == 0)\n\t\t\treturn;\n\n\t\tudc->usb_suspended = 1;\n\t\tif (udc->driver && udc->driver->suspend) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->suspend(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\n\t\t_nbu2ss_bitset(&udc->p_regs->USB_CONTROL, SUSPEND);\n\t}\n}\n\n \n \nstatic irqreturn_t _nbu2ss_vbus_irq(int irq, void *_udc)\n{\n\tstruct nbu2ss_udc\t*udc = (struct nbu2ss_udc *)_udc;\n\n\tspin_lock(&udc->lock);\n\t_nbu2ss_check_vbus(udc);\n\tspin_unlock(&udc->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \n \nstatic irqreturn_t _nbu2ss_udc_irq(int irq, void *_udc)\n{\n\tu8\tsuspend_flag = 0;\n\tu32\tstatus;\n\tu32\tepnum, int_bit;\n\n\tstruct nbu2ss_udc\t*udc = (struct nbu2ss_udc *)_udc;\n\tstruct fc_regs __iomem *preg = udc->p_regs;\n\n\tif (gpiod_get_value(vbus_gpio) == 0) {\n\t\t_nbu2ss_writel(&preg->USB_INT_STA, ~USB_INT_STA_RW);\n\t\t_nbu2ss_writel(&preg->USB_INT_ENA, 0);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_lock(&udc->lock);\n\n\tfor (;;) {\n\t\tif (gpiod_get_value(vbus_gpio) == 0) {\n\t\t\t_nbu2ss_writel(&preg->USB_INT_STA, ~USB_INT_STA_RW);\n\t\t\t_nbu2ss_writel(&preg->USB_INT_ENA, 0);\n\t\t\tstatus = 0;\n\t\t} else {\n\t\t\tstatus = _nbu2ss_readl(&preg->USB_INT_STA);\n\t\t}\n\n\t\tif (status == 0)\n\t\t\tbreak;\n\n\t\t_nbu2ss_writel(&preg->USB_INT_STA, ~(status & USB_INT_STA_RW));\n\n\t\tif (status & USB_RST_INT) {\n\t\t\t \n\t\t\t_nbu2ss_int_bus_reset(udc);\n\t\t}\n\n\t\tif (status & RSUM_INT) {\n\t\t\t \n\t\t\t_nbu2ss_int_usb_resume(udc);\n\t\t}\n\n\t\tif (status & SPND_INT) {\n\t\t\t \n\t\t\tsuspend_flag = 1;\n\t\t}\n\n\t\tif (status & EPN_INT) {\n\t\t\t \n\t\t\tint_bit = status >> 8;\n\n\t\t\tfor (epnum = 0; epnum < NUM_ENDPOINTS; epnum++) {\n\t\t\t\tif (0x01 & int_bit)\n\t\t\t\t\t_nbu2ss_ep_int(udc, epnum);\n\n\t\t\t\tint_bit >>= 1;\n\n\t\t\t\tif (int_bit == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (suspend_flag)\n\t\t_nbu2ss_int_usb_suspend(udc);\n\n\tspin_unlock(&udc->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \n \nstatic int nbu2ss_ep_enable(struct usb_ep *_ep,\n\t\t\t    const struct usb_endpoint_descriptor *desc)\n{\n\tu8\t\tep_type;\n\tunsigned long\tflags;\n\n\tstruct nbu2ss_ep\t*ep;\n\tstruct nbu2ss_udc\t*udc;\n\n\tif (!_ep || !desc) {\n\t\tpr_err(\" *** %s, bad param\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep = container_of(_ep, struct nbu2ss_ep, ep);\n\tif (!ep->udc) {\n\t\tpr_err(\" *** %s, ep == NULL !!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep_type = usb_endpoint_type(desc);\n\tif ((ep_type == USB_ENDPOINT_XFER_CONTROL) ||\n\t    (ep_type == USB_ENDPOINT_XFER_ISOC)) {\n\t\tpr_err(\" *** %s, bat bmAttributes\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tudc = ep->udc;\n\tif (udc->vbus_active == 0)\n\t\treturn -ESHUTDOWN;\n\n\tif ((!udc->driver) || (udc->gadget.speed == USB_SPEED_UNKNOWN)) {\n\t\tdev_err(ep->udc->dev, \" *** %s, udc !!\\n\", __func__);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tep->desc = desc;\n\tep->epnum = usb_endpoint_num(desc);\n\tep->direct = desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK;\n\tep->ep_type = ep_type;\n\tep->wedged = 0;\n\tep->halted = false;\n\tep->stalled = false;\n\n\tep->ep.maxpacket = le16_to_cpu(desc->wMaxPacketSize);\n\n\t \n\t_nbu2ss_ep_dma_init(udc, ep);\n\n\t \n\t_nbu2ss_ep_init(udc, ep);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int nbu2ss_ep_disable(struct usb_ep *_ep)\n{\n\tstruct nbu2ss_ep\t*ep;\n\tstruct nbu2ss_udc\t*udc;\n\tunsigned long\t\tflags;\n\n\tif (!_ep) {\n\t\tpr_err(\" *** %s, bad param\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep = container_of(_ep, struct nbu2ss_ep, ep);\n\tif (!ep->udc) {\n\t\tpr_err(\"udc: *** %s, ep == NULL !!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tudc = ep->udc;\n\tif (udc->vbus_active == 0)\n\t\treturn -ESHUTDOWN;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\t_nbu2ss_nuke(udc, ep, -EINPROGRESS);\t\t \n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic struct usb_request *nbu2ss_ep_alloc_request(struct usb_ep *ep,\n\t\t\t\t\t\t   gfp_t gfp_flags)\n{\n\tstruct nbu2ss_req *req;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n#ifdef USE_DMA\n\treq->req.dma = DMA_ADDR_INVALID;\n#endif\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\n \nstatic void nbu2ss_ep_free_request(struct usb_ep *_ep,\n\t\t\t\t   struct usb_request *_req)\n{\n\tstruct nbu2ss_req *req;\n\n\tif (_req) {\n\t\treq = container_of(_req, struct nbu2ss_req, req);\n\n\t\tkfree(req);\n\t}\n}\n\n \nstatic int nbu2ss_ep_queue(struct usb_ep *_ep,\n\t\t\t   struct usb_request *_req, gfp_t gfp_flags)\n{\n\tstruct nbu2ss_req\t*req;\n\tstruct nbu2ss_ep\t*ep;\n\tstruct nbu2ss_udc\t*udc;\n\tunsigned long\t\tflags;\n\tbool\t\t\tbflag;\n\tint\t\t\tresult = -EINVAL;\n\n\t \n\tif (!_ep || !_req) {\n\t\tif (!_ep)\n\t\t\tpr_err(\"udc: %s --- _ep == NULL\\n\", __func__);\n\n\t\tif (!_req)\n\t\t\tpr_err(\"udc: %s --- _req == NULL\\n\", __func__);\n\n\t\treturn -EINVAL;\n\t}\n\n\treq = container_of(_req, struct nbu2ss_req, req);\n\tif (unlikely(!_req->complete ||\n\t\t     !_req->buf ||\n\t\t     !list_empty(&req->queue))) {\n\t\tif (!_req->complete)\n\t\t\tpr_err(\"udc: %s --- !_req->complete\\n\", __func__);\n\n\t\tif (!_req->buf)\n\t\t\tpr_err(\"udc:%s --- !_req->buf\\n\", __func__);\n\n\t\tif (!list_empty(&req->queue))\n\t\t\tpr_err(\"%s --- !list_empty(&req->queue)\\n\", __func__);\n\n\t\treturn -EINVAL;\n\t}\n\n\tep = container_of(_ep, struct nbu2ss_ep, ep);\n\tudc = ep->udc;\n\n\tif (udc->vbus_active == 0) {\n\t\tdev_info(udc->dev, \"Can't ep_queue (VBUS OFF)\\n\");\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tif (unlikely(!udc->driver)) {\n\t\tdev_err(udc->dev, \"%s, bogus device state %p\\n\", __func__,\n\t\t\tudc->driver);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n#ifdef USE_DMA\n\tif ((uintptr_t)req->req.buf & 0x3)\n\t\treq->unaligned = true;\n\telse\n\t\treq->unaligned = false;\n\n\tif (req->unaligned) {\n\t\tif (!ep->virt_buf) {\n\t\t\tep->virt_buf = dma_alloc_coherent(udc->dev, PAGE_SIZE,\n\t\t\t\t\t\t\t  &ep->phys_buf,\n\t\t\t\t\t\t\t  GFP_ATOMIC | GFP_DMA);\n\t\t\tif (!ep->virt_buf) {\n\t\t\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tif (ep->epnum > 0)  {\n\t\t\tif (ep->direct == USB_DIR_IN)\n\t\t\t\tmemcpy(ep->virt_buf, req->req.buf,\n\t\t\t\t       req->req.length);\n\t\t}\n\t}\n\n\tif ((ep->epnum > 0) && (ep->direct == USB_DIR_OUT) &&\n\t    (req->req.dma != 0))\n\t\t_nbu2ss_dma_map_single(udc, ep, req, USB_DIR_OUT);\n#endif\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\tbflag = list_empty(&ep->queue);\n\tlist_add_tail(&req->queue, &ep->queue);\n\n\tif (bflag && !ep->stalled) {\n\t\tresult = _nbu2ss_start_transfer(udc, ep, req, false);\n\t\tif (result < 0) {\n\t\t\tdev_err(udc->dev, \" *** %s, result = %d\\n\", __func__,\n\t\t\t\tresult);\n\t\t\tlist_del(&req->queue);\n\t\t} else if ((ep->epnum > 0) && (ep->direct == USB_DIR_OUT)) {\n#ifdef USE_DMA\n\t\t\tif (req->req.length < 4 &&\n\t\t\t    req->req.length == req->req.actual)\n#else\n\t\t\tif (req->req.length == req->req.actual)\n#endif\n\t\t\t\t_nbu2ss_ep_done(ep, req, result);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int nbu2ss_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct nbu2ss_req\t*req;\n\tstruct nbu2ss_ep\t*ep;\n\tstruct nbu2ss_udc\t*udc;\n\tunsigned long flags;\n\n\t \n\tif (!_ep || !_req) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tep = container_of(_ep, struct nbu2ss_ep, ep);\n\n\tudc = ep->udc;\n\tif (!udc)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\tif (&req->req == _req) {\n\t\t\t_nbu2ss_ep_done(ep, req, -ECONNRESET);\n\t\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tpr_debug(\"%s no queue(EINVAL)\\n\", __func__);\n\n\treturn -EINVAL;\n}\n\n \nstatic int nbu2ss_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tu8\t\tep_adrs;\n\tunsigned long\tflags;\n\n\tstruct nbu2ss_ep\t*ep;\n\tstruct nbu2ss_udc\t*udc;\n\n\tif (!_ep) {\n\t\tpr_err(\"%s, bad param\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep = container_of(_ep, struct nbu2ss_ep, ep);\n\n\tudc = ep->udc;\n\tif (!udc) {\n\t\tdev_err(ep->udc->dev, \" *** %s, bad udc\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tep_adrs = ep->epnum | ep->direct;\n\tif (value == 0) {\n\t\t_nbu2ss_set_endpoint_stall(udc, ep_adrs, value);\n\t\tep->stalled = false;\n\t} else {\n\t\tif (list_empty(&ep->queue))\n\t\t\t_nbu2ss_epn_set_stall(udc, ep);\n\t\telse\n\t\t\tep->stalled = true;\n\t}\n\n\tif (value == 0)\n\t\tep->wedged = 0;\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int nbu2ss_ep_set_wedge(struct usb_ep *_ep)\n{\n\treturn nbu2ss_ep_set_halt(_ep, 1);\n}\n\n \nstatic int nbu2ss_ep_fifo_status(struct usb_ep *_ep)\n{\n\tu32\t\tdata;\n\tstruct nbu2ss_ep\t*ep;\n\tstruct nbu2ss_udc\t*udc;\n\tunsigned long\t\tflags;\n\tstruct fc_regs\t__iomem *preg;\n\n\tif (!_ep) {\n\t\tpr_err(\"%s, bad param\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep = container_of(_ep, struct nbu2ss_ep, ep);\n\n\tudc = ep->udc;\n\tif (!udc) {\n\t\tdev_err(ep->udc->dev, \"%s, bad udc\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tpreg = udc->p_regs;\n\n\tdata = gpiod_get_value(vbus_gpio);\n\tif (data == 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (ep->epnum == 0) {\n\t\tdata = _nbu2ss_readl(&preg->EP0_LENGTH) & EP0_LDATA;\n\n\t} else {\n\t\tdata = _nbu2ss_readl(&preg->EP_REGS[ep->epnum - 1].EP_LEN_DCNT)\n\t\t\t& EPN_LDATA;\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void  nbu2ss_ep_fifo_flush(struct usb_ep *_ep)\n{\n\tu32\t\t\tdata;\n\tstruct nbu2ss_ep\t*ep;\n\tstruct nbu2ss_udc\t*udc;\n\tunsigned long\t\tflags;\n\n\tif (!_ep) {\n\t\tpr_err(\"udc: %s, bad param\\n\", __func__);\n\t\treturn;\n\t}\n\n\tep = container_of(_ep, struct nbu2ss_ep, ep);\n\n\tudc = ep->udc;\n\tif (!udc) {\n\t\tdev_err(ep->udc->dev, \"%s, bad udc\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdata = gpiod_get_value(vbus_gpio);\n\tif (data == 0)\n\t\treturn;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\t_nbu2ss_fifo_flush(udc, ep);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n}\n\n \nstatic const struct usb_ep_ops nbu2ss_ep_ops = {\n\t.enable\t\t= nbu2ss_ep_enable,\n\t.disable\t= nbu2ss_ep_disable,\n\n\t.alloc_request\t= nbu2ss_ep_alloc_request,\n\t.free_request\t= nbu2ss_ep_free_request,\n\n\t.queue\t\t= nbu2ss_ep_queue,\n\t.dequeue\t= nbu2ss_ep_dequeue,\n\n\t.set_halt\t= nbu2ss_ep_set_halt,\n\t.set_wedge\t= nbu2ss_ep_set_wedge,\n\n\t.fifo_status\t= nbu2ss_ep_fifo_status,\n\t.fifo_flush\t= nbu2ss_ep_fifo_flush,\n};\n\n \n \n\n \nstatic int nbu2ss_gad_get_frame(struct usb_gadget *pgadget)\n{\n\tu32\t\t\tdata;\n\tstruct nbu2ss_udc\t*udc;\n\n\tif (!pgadget) {\n\t\tpr_err(\"udc: %s, bad param\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tudc = container_of(pgadget, struct nbu2ss_udc, gadget);\n\tdata = gpiod_get_value(vbus_gpio);\n\tif (data == 0)\n\t\treturn -EINVAL;\n\n\treturn _nbu2ss_readl(&udc->p_regs->USB_ADDRESS) & FRAME;\n}\n\n \nstatic int nbu2ss_gad_wakeup(struct usb_gadget *pgadget)\n{\n\tint\ti;\n\tu32\tdata;\n\n\tstruct nbu2ss_udc\t*udc;\n\n\tif (!pgadget) {\n\t\tpr_err(\"%s, bad param\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tudc = container_of(pgadget, struct nbu2ss_udc, gadget);\n\n\tdata = gpiod_get_value(vbus_gpio);\n\tif (data == 0) {\n\t\tdev_warn(&pgadget->dev, \"VBUS LEVEL = %d\\n\", data);\n\t\treturn -EINVAL;\n\t}\n\n\t_nbu2ss_bitset(&udc->p_regs->EPCTR, PLL_RESUME);\n\n\tfor (i = 0; i < EPC_PLL_LOCK_COUNT; i++) {\n\t\tdata = _nbu2ss_readl(&udc->p_regs->EPCTR);\n\n\t\tif (data & PLL_LOCK)\n\t\t\tbreak;\n\t}\n\n\t_nbu2ss_bitclr(&udc->p_regs->EPCTR, PLL_RESUME);\n\n\treturn 0;\n}\n\n \nstatic int nbu2ss_gad_set_selfpowered(struct usb_gadget *pgadget,\n\t\t\t\t      int is_selfpowered)\n{\n\tstruct nbu2ss_udc       *udc;\n\tunsigned long\t\tflags;\n\n\tif (!pgadget) {\n\t\tpr_err(\"%s, bad param\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tudc = container_of(pgadget, struct nbu2ss_udc, gadget);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tpgadget->is_selfpowered = (is_selfpowered != 0);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int nbu2ss_gad_vbus_session(struct usb_gadget *pgadget, int is_active)\n{\n\treturn 0;\n}\n\n \nstatic int nbu2ss_gad_vbus_draw(struct usb_gadget *pgadget, unsigned int mA)\n{\n\tstruct nbu2ss_udc\t*udc;\n\tunsigned long\t\tflags;\n\n\tif (!pgadget) {\n\t\tpr_err(\"%s, bad param\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tudc = container_of(pgadget, struct nbu2ss_udc, gadget);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc->mA = mA;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int nbu2ss_gad_pullup(struct usb_gadget *pgadget, int is_on)\n{\n\tstruct nbu2ss_udc\t*udc;\n\tunsigned long\t\tflags;\n\n\tif (!pgadget) {\n\t\tpr_err(\"%s, bad param\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tudc = container_of(pgadget, struct nbu2ss_udc, gadget);\n\n\tif (!udc->driver) {\n\t\tpr_warn(\"%s, Not Regist Driver\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (udc->vbus_active == 0)\n\t\treturn -ESHUTDOWN;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\t_nbu2ss_pullup(udc, is_on);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int nbu2ss_gad_ioctl(struct usb_gadget *pgadget,\n\t\t\t    unsigned int code, unsigned long param)\n{\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops nbu2ss_gadget_ops = {\n\t.get_frame\t\t= nbu2ss_gad_get_frame,\n\t.wakeup\t\t\t= nbu2ss_gad_wakeup,\n\t.set_selfpowered\t= nbu2ss_gad_set_selfpowered,\n\t.vbus_session\t\t= nbu2ss_gad_vbus_session,\n\t.vbus_draw\t\t= nbu2ss_gad_vbus_draw,\n\t.pullup\t\t\t= nbu2ss_gad_pullup,\n\t.ioctl\t\t\t= nbu2ss_gad_ioctl,\n};\n\nstatic const struct {\n\tconst char *name;\n\tconst struct usb_ep_caps caps;\n} ep_info[NUM_ENDPOINTS] = {\n#define EP_INFO(_name, _caps) \\\n\t{ \\\n\t\t.name = _name, \\\n\t\t.caps = _caps, \\\n\t}\n\n\tEP_INFO(\"ep0\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_CONTROL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep1-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep2-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep3in-int\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_INT, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep4-iso\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep5-iso\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep6-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep7-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep8in-int\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_INT, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep9-iso\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"epa-iso\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"epb-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"epc-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"epdin-int\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_INT, USB_EP_CAPS_DIR_IN)),\n\n#undef EP_INFO\n};\n\n \nstatic void nbu2ss_drv_ep_init(struct nbu2ss_udc *udc)\n{\n\tint\ti;\n\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\tudc->gadget.ep0 = &udc->ep[0].ep;\n\n\tfor (i = 0; i < NUM_ENDPOINTS; i++) {\n\t\tstruct nbu2ss_ep *ep = &udc->ep[i];\n\n\t\tep->udc = udc;\n\t\tep->desc = NULL;\n\n\t\tep->ep.driver_data = NULL;\n\t\tep->ep.name = ep_info[i].name;\n\t\tep->ep.caps = ep_info[i].caps;\n\t\tep->ep.ops = &nbu2ss_ep_ops;\n\n\t\tusb_ep_set_maxpacket_limit(&ep->ep,\n\t\t\t\t\t   i == 0 ? EP0_PACKETSIZE\n\t\t\t\t\t   : EP_PACKETSIZE);\n\n\t\tlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\n\t\tINIT_LIST_HEAD(&ep->queue);\n\t}\n\n\tlist_del_init(&udc->ep[0].ep.ep_list);\n}\n\n \n \nstatic int nbu2ss_drv_contest_init(struct platform_device *pdev,\n\t\t\t\t   struct nbu2ss_udc *udc)\n{\n\tspin_lock_init(&udc->lock);\n\tudc->dev = &pdev->dev;\n\n\tudc->gadget.is_selfpowered = 1;\n\tudc->devstate = USB_STATE_NOTATTACHED;\n\tudc->pdev = pdev;\n\tudc->mA = 0;\n\n\tudc->pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\n\n\t \n\tnbu2ss_drv_ep_init(udc);\n\n\t \n\tudc->gadget.ops = &nbu2ss_gadget_ops;\n\tudc->gadget.ep0 = &udc->ep[0].ep;\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->gadget.name = driver_name;\n\t \n\n\tdevice_initialize(&udc->gadget.dev);\n\n\tdev_set_name(&udc->gadget.dev, \"gadget\");\n\tudc->gadget.dev.parent = &pdev->dev;\n\tudc->gadget.dev.dma_mask = pdev->dev.dma_mask;\n\n\treturn 0;\n}\n\n \nstatic int nbu2ss_drv_probe(struct platform_device *pdev)\n{\n\tint status;\n\tstruct nbu2ss_udc *udc;\n\tint irq;\n\tvoid __iomem *mmio_base;\n\n\tudc = &udc_controller;\n\tmemset(udc, 0, sizeof(struct nbu2ss_udc));\n\n\tplatform_set_drvdata(pdev, udc);\n\n\t \n\tmmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mmio_base))\n\t\treturn PTR_ERR(mmio_base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tstatus = devm_request_irq(&pdev->dev, irq, _nbu2ss_udc_irq,\n\t\t\t\t  0, driver_name, udc);\n\n\t \n\tudc->p_regs = (struct fc_regs __iomem *)mmio_base;\n\n\t \n\tif (status != 0) {\n\t\tdev_err(udc->dev, \"request_irq(USB_UDC_IRQ_1) failed\\n\");\n\t\treturn status;\n\t}\n\n\t \n\tstatus = nbu2ss_drv_contest_init(pdev, udc);\n\tif (status < 0) {\n\t\t \n\t\treturn status;\n\t}\n\n\t \n\tvbus_irq = gpiod_to_irq(vbus_gpio);\n\tirq_set_irq_type(vbus_irq, IRQ_TYPE_EDGE_BOTH);\n\tstatus = request_irq(vbus_irq,\n\t\t\t     _nbu2ss_vbus_irq, IRQF_SHARED, driver_name, udc);\n\n\tif (status != 0) {\n\t\tdev_err(udc->dev, \"request_irq(vbus_irq) failed\\n\");\n\t\treturn status;\n\t}\n\n\treturn status;\n}\n\n \nstatic void nbu2ss_drv_shutdown(struct platform_device *pdev)\n{\n\tstruct nbu2ss_udc\t*udc;\n\n\tudc = platform_get_drvdata(pdev);\n\tif (!udc)\n\t\treturn;\n\n\t_nbu2ss_disable_controller(udc);\n}\n\n \nstatic void nbu2ss_drv_remove(struct platform_device *pdev)\n{\n\tstruct nbu2ss_udc\t*udc;\n\tstruct nbu2ss_ep\t*ep;\n\tint\ti;\n\n\tudc = &udc_controller;\n\n\tfor (i = 0; i < NUM_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\t\tif (ep->virt_buf)\n\t\t\tdma_free_coherent(udc->dev, PAGE_SIZE, (void *)ep->virt_buf,\n\t\t\t\t\t  ep->phys_buf);\n\t}\n\n\t \n\tfree_irq(vbus_irq, udc);\n}\n\n \nstatic int nbu2ss_drv_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct nbu2ss_udc\t*udc;\n\n\tudc = platform_get_drvdata(pdev);\n\tif (!udc)\n\t\treturn 0;\n\n\tif (udc->vbus_active) {\n\t\tudc->vbus_active = 0;\n\t\tudc->devstate = USB_STATE_NOTATTACHED;\n\t\tudc->linux_suspended = 1;\n\n\t\tif (udc->usb_suspended) {\n\t\t\tudc->usb_suspended = 0;\n\t\t\t_nbu2ss_reset_controller(udc);\n\t\t}\n\n\t\t_nbu2ss_quiesce(udc);\n\t}\n\t_nbu2ss_disable_controller(udc);\n\n\treturn 0;\n}\n\n \nstatic int nbu2ss_drv_resume(struct platform_device *pdev)\n{\n\tu32\tdata;\n\tstruct nbu2ss_udc\t*udc;\n\n\tudc = platform_get_drvdata(pdev);\n\tif (!udc)\n\t\treturn 0;\n\n\tdata = gpiod_get_value(vbus_gpio);\n\tif (data) {\n\t\tudc->vbus_active = 1;\n\t\tudc->devstate = USB_STATE_POWERED;\n\t\t_nbu2ss_enable_controller(udc);\n\t\t_nbu2ss_pullup(udc, 1);\n\t}\n\n\tudc->linux_suspended = 0;\n\n\treturn 0;\n}\n\nstatic struct platform_driver udc_driver = {\n\t.probe\t\t= nbu2ss_drv_probe,\n\t.shutdown\t= nbu2ss_drv_shutdown,\n\t.remove_new\t= nbu2ss_drv_remove,\n\t.suspend\t= nbu2ss_drv_suspend,\n\t.resume\t\t= nbu2ss_drv_resume,\n\t.driver\t\t= {\n\t\t.name\t= driver_name,\n\t},\n};\n\nmodule_platform_driver(udc_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Renesas Electronics Corporation\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}