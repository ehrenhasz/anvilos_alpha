{
  "module_name": "rtsx_transport.c",
  "hash_id": "84b460a8e0d0a4b24adbdbcafbddd53a4013509e8b9f82e8f265d74e0ae8a541",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rts5208/rtsx_transport.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n\n#include \"rtsx.h\"\n\n \n\n \n\nunsigned int rtsx_stor_access_xfer_buf(unsigned char *buffer,\n\t\t\t\t       unsigned int buflen,\n\t\t\t\t       struct scsi_cmnd *srb,\n\t\t\t\t       unsigned int *index,\n\t\t\t\t       unsigned int *offset,\n\t\t\t\t       enum xfer_buf_dir dir)\n{\n\tunsigned int cnt;\n\n\t \n\tif (scsi_sg_count(srb) == 0) {\n\t\tunsigned char *sgbuffer;\n\n\t\tif (*offset >= scsi_bufflen(srb))\n\t\t\treturn 0;\n\t\tcnt = min(buflen, scsi_bufflen(srb) - *offset);\n\n\t\tsgbuffer = (unsigned char *)scsi_sglist(srb) + *offset;\n\n\t\tif (dir == TO_XFER_BUF)\n\t\t\tmemcpy(sgbuffer, buffer, cnt);\n\t\telse\n\t\t\tmemcpy(buffer, sgbuffer, cnt);\n\t\t*offset += cnt;\n\n\t \n\t} else {\n\t\tstruct scatterlist *sg =\n\t\t\t\t(struct scatterlist *)scsi_sglist(srb)\n\t\t\t\t+ *index;\n\n\t\t \n\t\tcnt = 0;\n\t\twhile (cnt < buflen && *index < scsi_sg_count(srb)) {\n\t\t\tstruct page *page = sg_page(sg) +\n\t\t\t\t\t((sg->offset + *offset) >> PAGE_SHIFT);\n\t\t\tunsigned int poff = (sg->offset + *offset) &\n\t\t\t\t\t    (PAGE_SIZE - 1);\n\t\t\tunsigned int sglen = sg->length - *offset;\n\n\t\t\tif (sglen > buflen - cnt) {\n\t\t\t\t \n\t\t\t\tsglen = buflen - cnt;\n\t\t\t\t*offset += sglen;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t*offset = 0;\n\t\t\t\t++*index;\n\t\t\t\t++sg;\n\t\t\t}\n\n\t\t\twhile (sglen > 0) {\n\t\t\t\tunsigned int plen = min(sglen, (unsigned int)\n\t\t\t\t\t\tPAGE_SIZE - poff);\n\n\t\t\t\tif (dir == TO_XFER_BUF)\n\t\t\t\t\tmemcpy_to_page(page, poff, buffer + cnt, plen);\n\t\t\t\telse\n\t\t\t\t\tmemcpy_from_page(buffer + cnt, page, poff, plen);\n\n\t\t\t\t \n\t\t\t\tpoff = 0;\n\t\t\t\t++page;\n\t\t\t\tcnt += plen;\n\t\t\t\tsglen -= plen;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\treturn cnt;\n}\n\n \nvoid rtsx_stor_set_xfer_buf(unsigned char *buffer,\n\t\t\t    unsigned int buflen, struct scsi_cmnd *srb)\n{\n\tunsigned int index = 0, offset = 0;\n\n\trtsx_stor_access_xfer_buf(buffer, buflen, srb, &index, &offset,\n\t\t\t\t  TO_XFER_BUF);\n\tif (buflen < scsi_bufflen(srb))\n\t\tscsi_set_resid(srb, scsi_bufflen(srb) - buflen);\n}\n\nvoid rtsx_stor_get_xfer_buf(unsigned char *buffer,\n\t\t\t    unsigned int buflen, struct scsi_cmnd *srb)\n{\n\tunsigned int index = 0, offset = 0;\n\n\trtsx_stor_access_xfer_buf(buffer, buflen, srb, &index, &offset,\n\t\t\t\t  FROM_XFER_BUF);\n\tif (buflen < scsi_bufflen(srb))\n\t\tscsi_set_resid(srb, scsi_bufflen(srb) - buflen);\n}\n\n \n\n \nvoid rtsx_invoke_transport(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint result;\n\n\tresult = rtsx_scsi_handler(srb, chip);\n\n\t \n\tif (rtsx_chk_stat(chip, RTSX_STAT_ABORT)) {\n\t\tdev_dbg(rtsx_dev(chip), \"-- command was aborted\\n\");\n\t\tsrb->result = DID_ABORT << 16;\n\t\tgoto handle_errors;\n\t}\n\n\t \n\tif (result == TRANSPORT_ERROR) {\n\t\tdev_dbg(rtsx_dev(chip), \"-- transport indicates error, resetting\\n\");\n\t\tsrb->result = DID_ERROR << 16;\n\t\tgoto handle_errors;\n\t}\n\n\tsrb->result = SAM_STAT_GOOD;\n\n\t \n\tif (result == TRANSPORT_FAILED) {\n\t\t \n\t\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\t\tmemcpy(srb->sense_buffer,\n\t\t       (unsigned char *)&chip->sense_buffer[SCSI_LUN(srb)],\n\t\t       sizeof(struct sense_data_t));\n\t}\n\n\treturn;\n\nhandle_errors:\n\treturn;\n}\n\nvoid rtsx_add_cmd(struct rtsx_chip *chip,\n\t\t  u8 cmd_type, u16 reg_addr, u8 mask, u8 data)\n{\n\t__le32 *cb = (__le32 *)(chip->host_cmds_ptr);\n\tu32 val = 0;\n\n\tval |= (u32)(cmd_type & 0x03) << 30;\n\tval |= (u32)(reg_addr & 0x3FFF) << 16;\n\tval |= (u32)mask << 8;\n\tval |= (u32)data;\n\n\tspin_lock_irq(&chip->rtsx->reg_lock);\n\tif (chip->ci < (HOST_CMDS_BUF_LEN / 4))\n\t\tcb[(chip->ci)++] = cpu_to_le32(val);\n\n\tspin_unlock_irq(&chip->rtsx->reg_lock);\n}\n\nvoid rtsx_send_cmd_no_wait(struct rtsx_chip *chip)\n{\n\tu32 val = BIT(31);\n\n\trtsx_writel(chip, RTSX_HCBAR, chip->host_cmds_addr);\n\n\tval |= (u32)(chip->ci * 4) & 0x00FFFFFF;\n\t \n\tval |= 0x40000000;\n\trtsx_writel(chip, RTSX_HCBCTLR, val);\n}\n\nint rtsx_send_cmd(struct rtsx_chip *chip, u8 card, int timeout)\n{\n\tstruct rtsx_dev *rtsx = chip->rtsx;\n\tstruct completion trans_done;\n\tu32 val = BIT(31);\n\tlong timeleft;\n\tint err = 0;\n\n\tif (card == SD_CARD)\n\t\trtsx->check_card_cd = SD_EXIST;\n\telse if (card == MS_CARD)\n\t\trtsx->check_card_cd = MS_EXIST;\n\telse if (card == XD_CARD)\n\t\trtsx->check_card_cd = XD_EXIST;\n\telse\n\t\trtsx->check_card_cd = 0;\n\n\tspin_lock_irq(&rtsx->reg_lock);\n\n\t \n\trtsx->done = &trans_done;\n\trtsx->trans_result = TRANS_NOT_READY;\n\tinit_completion(&trans_done);\n\trtsx->trans_state = STATE_TRANS_CMD;\n\n\trtsx_writel(chip, RTSX_HCBAR, chip->host_cmds_addr);\n\n\tval |= (u32)(chip->ci * 4) & 0x00FFFFFF;\n\t \n\tval |= 0x40000000;\n\trtsx_writel(chip, RTSX_HCBCTLR, val);\n\n\tspin_unlock_irq(&rtsx->reg_lock);\n\n\t \n\ttimeleft = wait_for_completion_interruptible_timeout(&trans_done,\n\t\t\t\t\t\t\t     msecs_to_jiffies(timeout));\n\tif (timeleft <= 0) {\n\t\tdev_dbg(rtsx_dev(chip), \"chip->int_reg = 0x%x\\n\",\n\t\t\tchip->int_reg);\n\t\terr = -ETIMEDOUT;\n\t\tgoto finish_send_cmd;\n\t}\n\n\tspin_lock_irq(&rtsx->reg_lock);\n\tif (rtsx->trans_result == TRANS_RESULT_FAIL)\n\t\terr = -EIO;\n\telse if (rtsx->trans_result == TRANS_RESULT_OK)\n\t\terr = 0;\n\n\tspin_unlock_irq(&rtsx->reg_lock);\n\nfinish_send_cmd:\n\trtsx->done = NULL;\n\trtsx->trans_state = STATE_TRANS_NONE;\n\n\tif (err < 0)\n\t\trtsx_stop_cmd(chip, card);\n\n\treturn err;\n}\n\nstatic inline void rtsx_add_sg_tbl(struct rtsx_chip *chip,\n\t\t\t\t   u32 addr, u32 len, u8 option)\n{\n\t__le64 *sgb = (__le64 *)(chip->host_sg_tbl_ptr);\n\tu64 val = 0;\n\tu32 temp_len = 0;\n\tu8  temp_opt = 0;\n\n\tdo {\n\t\tif (len > 0x80000) {\n\t\t\ttemp_len = 0x80000;\n\t\t\ttemp_opt = option & (~RTSX_SG_END);\n\t\t} else {\n\t\t\ttemp_len = len;\n\t\t\ttemp_opt = option;\n\t\t}\n\t\tval = ((u64)addr << 32) | ((u64)temp_len << 12) | temp_opt;\n\n\t\tif (chip->sgi < (HOST_SG_TBL_BUF_LEN / 8))\n\t\t\tsgb[(chip->sgi)++] = cpu_to_le64(val);\n\n\t\tlen -= temp_len;\n\t\taddr += temp_len;\n\t} while (len);\n}\n\nstatic int rtsx_transfer_sglist_adma_partial(struct rtsx_chip *chip, u8 card,\n\t\t\t\t\t     struct scatterlist *sg, int num_sg,\n\t\t\t\t\t     unsigned int *index,\n\t\t\t\t\t     unsigned int *offset, int size,\n\t\t\t\t\t     enum dma_data_direction dma_dir,\n\t\t\t\t\t     int timeout)\n{\n\tstruct rtsx_dev *rtsx = chip->rtsx;\n\tstruct completion trans_done;\n\tu8 dir;\n\tint sg_cnt, i, resid;\n\tint err = 0;\n\tlong timeleft;\n\tstruct scatterlist *sg_ptr;\n\tu32 val = TRIG_DMA;\n\n\tif (!sg || num_sg <= 0 || !offset || !index)\n\t\treturn -EIO;\n\n\tif (dma_dir == DMA_TO_DEVICE)\n\t\tdir = HOST_TO_DEVICE;\n\telse if (dma_dir == DMA_FROM_DEVICE)\n\t\tdir = DEVICE_TO_HOST;\n\telse\n\t\treturn -ENXIO;\n\n\tif (card == SD_CARD)\n\t\trtsx->check_card_cd = SD_EXIST;\n\telse if (card == MS_CARD)\n\t\trtsx->check_card_cd = MS_EXIST;\n\telse if (card == XD_CARD)\n\t\trtsx->check_card_cd = XD_EXIST;\n\telse\n\t\trtsx->check_card_cd = 0;\n\n\tspin_lock_irq(&rtsx->reg_lock);\n\n\t \n\trtsx->done = &trans_done;\n\n\trtsx->trans_state = STATE_TRANS_SG;\n\trtsx->trans_result = TRANS_NOT_READY;\n\n\tspin_unlock_irq(&rtsx->reg_lock);\n\n\tsg_cnt = dma_map_sg(&rtsx->pci->dev, sg, num_sg, dma_dir);\n\n\tresid = size;\n\tsg_ptr = sg;\n\tchip->sgi = 0;\n\t \n\tfor (i = 0; i < *index; i++)\n\t\tsg_ptr = sg_next(sg_ptr);\n\tfor (i = *index; i < sg_cnt; i++) {\n\t\tdma_addr_t addr;\n\t\tunsigned int len;\n\t\tu8 option;\n\n\t\taddr = sg_dma_address(sg_ptr);\n\t\tlen = sg_dma_len(sg_ptr);\n\n\t\tdev_dbg(rtsx_dev(chip), \"DMA addr: 0x%x, Len: 0x%x\\n\",\n\t\t\t(unsigned int)addr, len);\n\t\tdev_dbg(rtsx_dev(chip), \"*index = %d, *offset = %d\\n\",\n\t\t\t*index, *offset);\n\n\t\taddr += *offset;\n\n\t\tif ((len - *offset) > resid) {\n\t\t\t*offset += resid;\n\t\t\tlen = resid;\n\t\t\tresid = 0;\n\t\t} else {\n\t\t\tresid -= (len - *offset);\n\t\t\tlen -= *offset;\n\t\t\t*offset = 0;\n\t\t\t*index = *index + 1;\n\t\t}\n\t\toption = RTSX_SG_VALID | RTSX_SG_TRANS_DATA;\n\t\tif ((i == sg_cnt - 1) || !resid)\n\t\t\toption |= RTSX_SG_END;\n\n\t\trtsx_add_sg_tbl(chip, (u32)addr, (u32)len, option);\n\n\t\tif (!resid)\n\t\t\tbreak;\n\n\t\tsg_ptr = sg_next(sg_ptr);\n\t}\n\n\tdev_dbg(rtsx_dev(chip), \"SG table count = %d\\n\", chip->sgi);\n\n\tval |= (u32)(dir & 0x01) << 29;\n\tval |= ADMA_MODE;\n\n\tspin_lock_irq(&rtsx->reg_lock);\n\n\tinit_completion(&trans_done);\n\n\trtsx_writel(chip, RTSX_HDBAR, chip->host_sg_tbl_addr);\n\trtsx_writel(chip, RTSX_HDBCTLR, val);\n\n\tspin_unlock_irq(&rtsx->reg_lock);\n\n\ttimeleft = wait_for_completion_interruptible_timeout(&trans_done,\n\t\t\t\t\t\t\t     msecs_to_jiffies(timeout));\n\tif (timeleft <= 0) {\n\t\tdev_dbg(rtsx_dev(chip), \"Timeout (%s %d)\\n\",\n\t\t\t__func__, __LINE__);\n\t\tdev_dbg(rtsx_dev(chip), \"chip->int_reg = 0x%x\\n\",\n\t\t\tchip->int_reg);\n\t\terr = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&rtsx->reg_lock);\n\tif (rtsx->trans_result == TRANS_RESULT_FAIL) {\n\t\terr = -EIO;\n\t\tspin_unlock_irq(&rtsx->reg_lock);\n\t\tgoto out;\n\t}\n\tspin_unlock_irq(&rtsx->reg_lock);\n\n\t \n\tspin_lock_irq(&rtsx->reg_lock);\n\tif (rtsx->trans_result == TRANS_NOT_READY) {\n\t\tinit_completion(&trans_done);\n\t\tspin_unlock_irq(&rtsx->reg_lock);\n\t\ttimeleft = wait_for_completion_interruptible_timeout(&trans_done,\n\t\t\t\t\t\t\t\t     msecs_to_jiffies(timeout));\n\t\tif (timeleft <= 0) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"Timeout (%s %d)\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tdev_dbg(rtsx_dev(chip), \"chip->int_reg = 0x%x\\n\",\n\t\t\t\tchip->int_reg);\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tspin_unlock_irq(&rtsx->reg_lock);\n\t}\n\n\tspin_lock_irq(&rtsx->reg_lock);\n\tif (rtsx->trans_result == TRANS_RESULT_FAIL)\n\t\terr = -EIO;\n\telse if (rtsx->trans_result == TRANS_RESULT_OK)\n\t\terr = 0;\n\n\tspin_unlock_irq(&rtsx->reg_lock);\n\nout:\n\trtsx->done = NULL;\n\trtsx->trans_state = STATE_TRANS_NONE;\n\tdma_unmap_sg(&rtsx->pci->dev, sg, num_sg, dma_dir);\n\n\tif (err < 0)\n\t\trtsx_stop_cmd(chip, card);\n\n\treturn err;\n}\n\nstatic int rtsx_transfer_sglist_adma(struct rtsx_chip *chip, u8 card,\n\t\t\t\t     struct scatterlist *sg, int num_sg,\n\t\t\t\t     enum dma_data_direction dma_dir,\n\t\t\t\t     int timeout)\n{\n\tstruct rtsx_dev *rtsx = chip->rtsx;\n\tstruct completion trans_done;\n\tu8 dir;\n\tint buf_cnt, i;\n\tint err = 0;\n\tlong timeleft;\n\tstruct scatterlist *sg_ptr;\n\n\tif (!sg || num_sg <= 0)\n\t\treturn -EIO;\n\n\tif (dma_dir == DMA_TO_DEVICE)\n\t\tdir = HOST_TO_DEVICE;\n\telse if (dma_dir == DMA_FROM_DEVICE)\n\t\tdir = DEVICE_TO_HOST;\n\telse\n\t\treturn -ENXIO;\n\n\tif (card == SD_CARD)\n\t\trtsx->check_card_cd = SD_EXIST;\n\telse if (card == MS_CARD)\n\t\trtsx->check_card_cd = MS_EXIST;\n\telse if (card == XD_CARD)\n\t\trtsx->check_card_cd = XD_EXIST;\n\telse\n\t\trtsx->check_card_cd = 0;\n\n\tspin_lock_irq(&rtsx->reg_lock);\n\n\t \n\trtsx->done = &trans_done;\n\n\trtsx->trans_state = STATE_TRANS_SG;\n\trtsx->trans_result = TRANS_NOT_READY;\n\n\tspin_unlock_irq(&rtsx->reg_lock);\n\n\tbuf_cnt = dma_map_sg(&rtsx->pci->dev, sg, num_sg, dma_dir);\n\n\tsg_ptr = sg;\n\n\tfor (i = 0; i <= buf_cnt / (HOST_SG_TBL_BUF_LEN / 8); i++) {\n\t\tu32 val = TRIG_DMA;\n\t\tint sg_cnt, j;\n\n\t\tif (i == buf_cnt / (HOST_SG_TBL_BUF_LEN / 8))\n\t\t\tsg_cnt = buf_cnt % (HOST_SG_TBL_BUF_LEN / 8);\n\t\telse\n\t\t\tsg_cnt = HOST_SG_TBL_BUF_LEN / 8;\n\n\t\tchip->sgi = 0;\n\t\tfor (j = 0; j < sg_cnt; j++) {\n\t\t\tdma_addr_t addr = sg_dma_address(sg_ptr);\n\t\t\tunsigned int len = sg_dma_len(sg_ptr);\n\t\t\tu8 option;\n\n\t\t\tdev_dbg(rtsx_dev(chip), \"DMA addr: 0x%x, Len: 0x%x\\n\",\n\t\t\t\t(unsigned int)addr, len);\n\n\t\t\toption = RTSX_SG_VALID | RTSX_SG_TRANS_DATA;\n\t\t\tif (j == (sg_cnt - 1))\n\t\t\t\toption |= RTSX_SG_END;\n\n\t\t\trtsx_add_sg_tbl(chip, (u32)addr, (u32)len, option);\n\n\t\t\tsg_ptr = sg_next(sg_ptr);\n\t\t}\n\n\t\tdev_dbg(rtsx_dev(chip), \"SG table count = %d\\n\", chip->sgi);\n\n\t\tval |= (u32)(dir & 0x01) << 29;\n\t\tval |= ADMA_MODE;\n\n\t\tspin_lock_irq(&rtsx->reg_lock);\n\n\t\tinit_completion(&trans_done);\n\n\t\trtsx_writel(chip, RTSX_HDBAR, chip->host_sg_tbl_addr);\n\t\trtsx_writel(chip, RTSX_HDBCTLR, val);\n\n\t\tspin_unlock_irq(&rtsx->reg_lock);\n\n\t\ttimeleft = wait_for_completion_interruptible_timeout(&trans_done,\n\t\t\t\t\t\t\t\t     msecs_to_jiffies(timeout));\n\t\tif (timeleft <= 0) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"Timeout (%s %d)\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tdev_dbg(rtsx_dev(chip), \"chip->int_reg = 0x%x\\n\",\n\t\t\t\tchip->int_reg);\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock_irq(&rtsx->reg_lock);\n\t\tif (rtsx->trans_result == TRANS_RESULT_FAIL) {\n\t\t\terr = -EIO;\n\t\t\tspin_unlock_irq(&rtsx->reg_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock_irq(&rtsx->reg_lock);\n\n\t\tsg_ptr += sg_cnt;\n\t}\n\n\t \n\tspin_lock_irq(&rtsx->reg_lock);\n\tif (rtsx->trans_result == TRANS_NOT_READY) {\n\t\tinit_completion(&trans_done);\n\t\tspin_unlock_irq(&rtsx->reg_lock);\n\t\ttimeleft = wait_for_completion_interruptible_timeout(&trans_done,\n\t\t\t\t\t\t\t\t     msecs_to_jiffies(timeout));\n\t\tif (timeleft <= 0) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"Timeout (%s %d)\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tdev_dbg(rtsx_dev(chip), \"chip->int_reg = 0x%x\\n\",\n\t\t\t\tchip->int_reg);\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tspin_unlock_irq(&rtsx->reg_lock);\n\t}\n\n\tspin_lock_irq(&rtsx->reg_lock);\n\tif (rtsx->trans_result == TRANS_RESULT_FAIL)\n\t\terr = -EIO;\n\telse if (rtsx->trans_result == TRANS_RESULT_OK)\n\t\terr = 0;\n\n\tspin_unlock_irq(&rtsx->reg_lock);\n\nout:\n\trtsx->done = NULL;\n\trtsx->trans_state = STATE_TRANS_NONE;\n\tdma_unmap_sg(&rtsx->pci->dev, sg, num_sg, dma_dir);\n\n\tif (err < 0)\n\t\trtsx_stop_cmd(chip, card);\n\n\treturn err;\n}\n\nstatic int rtsx_transfer_buf(struct rtsx_chip *chip, u8 card, void *buf,\n\t\t\t     size_t len, enum dma_data_direction dma_dir,\n\t\t\t     int timeout)\n{\n\tstruct rtsx_dev *rtsx = chip->rtsx;\n\tstruct completion trans_done;\n\tdma_addr_t addr;\n\tu8 dir;\n\tint err = 0;\n\tu32 val = BIT(31);\n\tlong timeleft;\n\n\tif (!buf || len <= 0)\n\t\treturn -EIO;\n\n\tif (dma_dir == DMA_TO_DEVICE)\n\t\tdir = HOST_TO_DEVICE;\n\telse if (dma_dir == DMA_FROM_DEVICE)\n\t\tdir = DEVICE_TO_HOST;\n\telse\n\t\treturn -ENXIO;\n\n\taddr = dma_map_single(&rtsx->pci->dev, buf, len, dma_dir);\n\tif (dma_mapping_error(&rtsx->pci->dev, addr))\n\t\treturn -ENOMEM;\n\n\tif (card == SD_CARD)\n\t\trtsx->check_card_cd = SD_EXIST;\n\telse if (card == MS_CARD)\n\t\trtsx->check_card_cd = MS_EXIST;\n\telse if (card == XD_CARD)\n\t\trtsx->check_card_cd = XD_EXIST;\n\telse\n\t\trtsx->check_card_cd = 0;\n\n\tval |= (u32)(dir & 0x01) << 29;\n\tval |= (u32)(len & 0x00FFFFFF);\n\n\tspin_lock_irq(&rtsx->reg_lock);\n\n\t \n\trtsx->done = &trans_done;\n\n\tinit_completion(&trans_done);\n\n\trtsx->trans_state = STATE_TRANS_BUF;\n\trtsx->trans_result = TRANS_NOT_READY;\n\n\trtsx_writel(chip, RTSX_HDBAR, addr);\n\trtsx_writel(chip, RTSX_HDBCTLR, val);\n\n\tspin_unlock_irq(&rtsx->reg_lock);\n\n\t \n\ttimeleft = wait_for_completion_interruptible_timeout(&trans_done,\n\t\t\t\t\t\t\t     msecs_to_jiffies(timeout));\n\tif (timeleft <= 0) {\n\t\tdev_dbg(rtsx_dev(chip), \"Timeout (%s %d)\\n\",\n\t\t\t__func__, __LINE__);\n\t\tdev_dbg(rtsx_dev(chip), \"chip->int_reg = 0x%x\\n\",\n\t\t\tchip->int_reg);\n\t\terr = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&rtsx->reg_lock);\n\tif (rtsx->trans_result == TRANS_RESULT_FAIL)\n\t\terr = -EIO;\n\telse if (rtsx->trans_result == TRANS_RESULT_OK)\n\t\terr = 0;\n\n\tspin_unlock_irq(&rtsx->reg_lock);\n\nout:\n\trtsx->done = NULL;\n\trtsx->trans_state = STATE_TRANS_NONE;\n\tdma_unmap_single(&rtsx->pci->dev, addr, len, dma_dir);\n\n\tif (err < 0)\n\t\trtsx_stop_cmd(chip, card);\n\n\treturn err;\n}\n\nint rtsx_transfer_data_partial(struct rtsx_chip *chip, u8 card,\n\t\t\t       void *buf, size_t len, int use_sg,\n\t\t\t       unsigned int *index, unsigned int *offset,\n\t\t\t       enum dma_data_direction dma_dir, int timeout)\n{\n\tint err = 0;\n\n\t \n\tif (rtsx_chk_stat(chip, RTSX_STAT_ABORT))\n\t\treturn -EIO;\n\n\tif (use_sg) {\n\t\tstruct scatterlist *sg = buf;\n\n\t\terr = rtsx_transfer_sglist_adma_partial(chip, card, sg, use_sg,\n\t\t\t\t\t\t\tindex, offset, (int)len,\n\t\t\t\t\t\t\tdma_dir, timeout);\n\t} else {\n\t\terr = rtsx_transfer_buf(chip, card,\n\t\t\t\t\tbuf, len, dma_dir, timeout);\n\t}\n\tif (err < 0) {\n\t\tif (RTSX_TST_DELINK(chip)) {\n\t\t\tRTSX_CLR_DELINK(chip);\n\t\t\tchip->need_reinit = SD_CARD | MS_CARD | XD_CARD;\n\t\t\trtsx_reinit_cards(chip, 1);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint rtsx_transfer_data(struct rtsx_chip *chip, u8 card, void *buf, size_t len,\n\t\t       int use_sg, enum dma_data_direction dma_dir, int timeout)\n{\n\tint err = 0;\n\n\tdev_dbg(rtsx_dev(chip), \"use_sg = %d\\n\", use_sg);\n\n\t \n\tif (rtsx_chk_stat(chip, RTSX_STAT_ABORT))\n\t\treturn -EIO;\n\n\tif (use_sg) {\n\t\terr = rtsx_transfer_sglist_adma(chip, card, buf,\n\t\t\t\t\t\tuse_sg, dma_dir, timeout);\n\t} else {\n\t\terr = rtsx_transfer_buf(chip, card, buf, len, dma_dir, timeout);\n\t}\n\n\tif (err < 0) {\n\t\tif (RTSX_TST_DELINK(chip)) {\n\t\t\tRTSX_CLR_DELINK(chip);\n\t\t\tchip->need_reinit = SD_CARD | MS_CARD | XD_CARD;\n\t\t\trtsx_reinit_cards(chip, 1);\n\t\t}\n\t}\n\n\treturn err;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}