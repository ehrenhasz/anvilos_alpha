{
  "module_name": "xd.c",
  "hash_id": "26b7a7ed4e8e0d84317c53cc608cc8f7ea48ec9c37072ce192cf979da1354965",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rts5208/xd.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n\n#include \"rtsx.h\"\n#include \"rtsx_transport.h\"\n#include \"rtsx_scsi.h\"\n#include \"rtsx_card.h\"\n#include \"xd.h\"\n\nstatic int xd_build_l2p_tbl(struct rtsx_chip *chip, int zone_no);\nstatic int xd_init_page(struct rtsx_chip *chip, u32 phy_blk, u16 logoff,\n\t\t\tu8 start_page, u8 end_page);\n\nstatic inline void xd_set_err_code(struct rtsx_chip *chip, u8 err_code)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\n\txd_card->err_code = err_code;\n}\n\nstatic int xd_set_init_para(struct rtsx_chip *chip)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tint retval;\n\n\tif (chip->asic_code)\n\t\txd_card->xd_clock = 47;\n\telse\n\t\txd_card->xd_clock = CLK_50;\n\n\tretval = switch_clock(chip, xd_card->xd_clock);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int xd_switch_clock(struct rtsx_chip *chip)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tint retval;\n\n\tretval = select_card(chip, XD_CARD);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = switch_clock(chip, xd_card->xd_clock);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int xd_read_id(struct rtsx_chip *chip, u8 id_cmd, u8 *id_buf, u8 buf_len)\n{\n\tint retval, i;\n\tu8 *ptr;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_DAT, 0xFF, id_cmd);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\n\t\t     XD_TRANSFER_START | XD_READ_ID);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER, XD_TRANSFER_END,\n\t\t     XD_TRANSFER_END);\n\n\tfor (i = 0; i < 4; i++)\n\t\trtsx_add_cmd(chip, READ_REG_CMD, (u16)(XD_ADDRESS1 + i), 0, 0);\n\n\tretval = rtsx_send_cmd(chip, XD_CARD, 20);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\tptr = rtsx_get_cmd_data(chip) + 1;\n\tif (id_buf && buf_len) {\n\t\tif (buf_len > 4)\n\t\t\tbuf_len = 4;\n\t\tmemcpy(id_buf, ptr, buf_len);\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic void xd_assign_phy_addr(struct rtsx_chip *chip, u32 addr, u8 mode)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\n\tswitch (mode) {\n\tcase XD_RW_ADDR:\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS0, 0xFF, 0);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS1, 0xFF, (u8)addr);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS2,\n\t\t\t     0xFF, (u8)(addr >> 8));\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS3,\n\t\t\t     0xFF, (u8)(addr >> 16));\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_CFG, 0xFF,\n\t\t\t     xd_card->addr_cycle |\n\t\t\t     XD_CALC_ECC |\n\t\t\t     XD_BA_NO_TRANSFORM);\n\t\tbreak;\n\n\tcase XD_ERASE_ADDR:\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS0, 0xFF, (u8)addr);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS1,\n\t\t\t     0xFF, (u8)(addr >> 8));\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS2,\n\t\t\t     0xFF, (u8)(addr >> 16));\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_CFG, 0xFF,\n\t\t\t     (xd_card->addr_cycle - 1) | XD_CALC_ECC |\n\t\t\tXD_BA_NO_TRANSFORM);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int xd_read_redundant(struct rtsx_chip *chip, u32 page_addr,\n\t\t\t     u8 *buf, int buf_len)\n{\n\tint retval, i;\n\n\trtsx_init_cmd(chip);\n\n\txd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER,\n\t\t     0xFF, XD_TRANSFER_START | XD_READ_REDUNDANT);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\n\t\t     XD_TRANSFER_END, XD_TRANSFER_END);\n\n\tfor (i = 0; i < 6; i++)\n\t\trtsx_add_cmd(chip, READ_REG_CMD, (u16)(XD_PAGE_STATUS + i),\n\t\t\t     0, 0);\n\tfor (i = 0; i < 4; i++)\n\t\trtsx_add_cmd(chip, READ_REG_CMD, (u16)(XD_RESERVED0 + i),\n\t\t\t     0, 0);\n\trtsx_add_cmd(chip, READ_REG_CMD, XD_PARITY, 0, 0);\n\n\tretval = rtsx_send_cmd(chip, XD_CARD, 500);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\tif (buf && buf_len) {\n\t\tu8 *ptr = rtsx_get_cmd_data(chip) + 1;\n\n\t\tif (buf_len > 11)\n\t\t\tbuf_len = 11;\n\t\tmemcpy(buf, ptr, buf_len);\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int xd_read_data_from_ppb(struct rtsx_chip *chip, int offset,\n\t\t\t\t u8 *buf, int buf_len)\n{\n\tint retval, i;\n\n\tif (!buf || buf_len < 0)\n\t\treturn STATUS_FAIL;\n\n\trtsx_init_cmd(chip);\n\n\tfor (i = 0; i < buf_len; i++)\n\t\trtsx_add_cmd(chip, READ_REG_CMD, PPBUF_BASE2 + offset + i,\n\t\t\t     0, 0);\n\n\tretval = rtsx_send_cmd(chip, 0, 250);\n\tif (retval < 0) {\n\t\trtsx_clear_xd_error(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tmemcpy(buf, rtsx_get_cmd_data(chip), buf_len);\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int xd_read_cis(struct rtsx_chip *chip, u32 page_addr, u8 *buf,\n\t\t       int buf_len)\n{\n\tint retval;\n\tu8 reg;\n\n\tif (!buf || buf_len < 10)\n\t\treturn STATUS_FAIL;\n\n\trtsx_init_cmd(chip);\n\n\txd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t     0x01, PINGPONG_BUFFER);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, 1);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_CHK_DATA_STATUS,\n\t\t     XD_AUTO_CHK_DATA_STATUS, XD_AUTO_CHK_DATA_STATUS);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\n\t\t     XD_TRANSFER_START | XD_READ_PAGES);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER, XD_TRANSFER_END,\n\t\t     XD_TRANSFER_END);\n\n\tretval = rtsx_send_cmd(chip, XD_CARD, 250);\n\tif (retval == -ETIMEDOUT) {\n\t\trtsx_clear_xd_error(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = rtsx_read_register(chip, XD_PAGE_STATUS, &reg);\n\tif (retval)\n\t\treturn retval;\n\tif (reg != XD_GPG) {\n\t\trtsx_clear_xd_error(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = rtsx_read_register(chip, XD_CTL, &reg);\n\tif (retval)\n\t\treturn retval;\n\tif (!(reg & XD_ECC1_ERROR) || !(reg & XD_ECC1_UNCORRECTABLE)) {\n\t\tretval = xd_read_data_from_ppb(chip, 0, buf, buf_len);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t\tif (reg & XD_ECC1_ERROR) {\n\t\t\tu8 ecc_bit, ecc_byte;\n\n\t\t\tretval = rtsx_read_register(chip, XD_ECC_BIT1,\n\t\t\t\t\t\t    &ecc_bit);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t\tretval = rtsx_read_register(chip, XD_ECC_BYTE1,\n\t\t\t\t\t\t    &ecc_byte);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\n\t\t\tdev_dbg(rtsx_dev(chip), \"ECC_BIT1 = 0x%x, ECC_BYTE1 = 0x%x\\n\",\n\t\t\t\tecc_bit, ecc_byte);\n\t\t\tif (ecc_byte < buf_len) {\n\t\t\t\tdev_dbg(rtsx_dev(chip), \"Before correct: 0x%x\\n\",\n\t\t\t\t\tbuf[ecc_byte]);\n\t\t\t\tbuf[ecc_byte] ^= (1 << ecc_bit);\n\t\t\t\tdev_dbg(rtsx_dev(chip), \"After correct: 0x%x\\n\",\n\t\t\t\t\tbuf[ecc_byte]);\n\t\t\t}\n\t\t}\n\t} else if (!(reg & XD_ECC2_ERROR) || !(reg & XD_ECC2_UNCORRECTABLE)) {\n\t\trtsx_clear_xd_error(chip);\n\n\t\tretval = xd_read_data_from_ppb(chip, 256, buf, buf_len);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t\tif (reg & XD_ECC2_ERROR) {\n\t\t\tu8 ecc_bit, ecc_byte;\n\n\t\t\tretval = rtsx_read_register(chip, XD_ECC_BIT2,\n\t\t\t\t\t\t    &ecc_bit);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t\tretval = rtsx_read_register(chip, XD_ECC_BYTE2,\n\t\t\t\t\t\t    &ecc_byte);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\n\t\t\tdev_dbg(rtsx_dev(chip), \"ECC_BIT2 = 0x%x, ECC_BYTE2 = 0x%x\\n\",\n\t\t\t\tecc_bit, ecc_byte);\n\t\t\tif (ecc_byte < buf_len) {\n\t\t\t\tdev_dbg(rtsx_dev(chip), \"Before correct: 0x%x\\n\",\n\t\t\t\t\tbuf[ecc_byte]);\n\t\t\t\tbuf[ecc_byte] ^= (1 << ecc_bit);\n\t\t\t\tdev_dbg(rtsx_dev(chip), \"After correct: 0x%x\\n\",\n\t\t\t\t\tbuf[ecc_byte]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\trtsx_clear_xd_error(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic void xd_fill_pull_ctl_disable(struct rtsx_chip *chip)\n{\n\tif (CHECK_PID(chip, 0x5208)) {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF,\n\t\t\t     XD_D3_PD | XD_D2_PD | XD_D1_PD | XD_D0_PD);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF,\n\t\t\t     XD_D7_PD | XD_D6_PD | XD_D5_PD | XD_D4_PD);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF,\n\t\t\t     XD_WP_PD | XD_CE_PD | XD_CLE_PD | XD_CD_PU);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF,\n\t\t\t     XD_RDY_PD | XD_WE_PD | XD_RE_PD | XD_ALE_PD);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF,\n\t\t\t     MS_INS_PU | SD_WP_PD | SD_CD_PU | SD_CMD_PD);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF,\n\t\t\t     MS_D5_PD | MS_D4_PD);\n\t} else if (CHECK_PID(chip, 0x5288)) {\n\t\tif (CHECK_BARO_PKG(chip, QFN)) {\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1,\n\t\t\t\t     0xFF, 0x55);\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2,\n\t\t\t\t     0xFF, 0x55);\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3,\n\t\t\t\t     0xFF, 0x4B);\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4,\n\t\t\t\t     0xFF, 0x69);\n\t\t}\n\t}\n}\n\nstatic void xd_fill_pull_ctl_stage1_barossa(struct rtsx_chip *chip)\n{\n\tif (CHECK_BARO_PKG(chip, QFN)) {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x55);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x4B);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\n\t}\n}\n\nstatic void xd_fill_pull_ctl_enable(struct rtsx_chip *chip)\n{\n\tif (CHECK_PID(chip, 0x5208)) {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF,\n\t\t\t     XD_D3_PD | XD_D2_PD | XD_D1_PD | XD_D0_PD);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF,\n\t\t\t     XD_D7_PD | XD_D6_PD | XD_D5_PD | XD_D4_PD);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF,\n\t\t\t     XD_WP_PD | XD_CE_PU | XD_CLE_PD | XD_CD_PU);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF,\n\t\t\t     XD_RDY_PU | XD_WE_PU | XD_RE_PU | XD_ALE_PD);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF,\n\t\t\t     MS_INS_PU | SD_WP_PD | SD_CD_PU | SD_CMD_PD);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF,\n\t\t\t     MS_D5_PD | MS_D4_PD);\n\t} else if (CHECK_PID(chip, 0x5288)) {\n\t\tif (CHECK_BARO_PKG(chip, QFN)) {\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1,\n\t\t\t\t     0xFF, 0x55);\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2,\n\t\t\t\t     0xFF, 0x55);\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3,\n\t\t\t\t     0xFF, 0x53);\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4,\n\t\t\t\t     0xFF, 0xA9);\n\t\t}\n\t}\n}\n\nstatic int xd_pull_ctl_disable(struct rtsx_chip *chip)\n{\n\tint retval;\n\n\tif (CHECK_PID(chip, 0x5208)) {\n\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL1, 0xFF,\n\t\t\t\t\t     XD_D3_PD |\n\t\t\t\t\t     XD_D2_PD |\n\t\t\t\t\t     XD_D1_PD |\n\t\t\t\t\t     XD_D0_PD);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL2, 0xFF,\n\t\t\t\t\t     XD_D7_PD |\n\t\t\t\t\t     XD_D6_PD |\n\t\t\t\t\t     XD_D5_PD |\n\t\t\t\t\t     XD_D4_PD);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL3, 0xFF,\n\t\t\t\t\t     XD_WP_PD |\n\t\t\t\t\t     XD_CE_PD |\n\t\t\t\t\t     XD_CLE_PD |\n\t\t\t\t\t     XD_CD_PU);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL4, 0xFF,\n\t\t\t\t\t     XD_RDY_PD |\n\t\t\t\t\t     XD_WE_PD |\n\t\t\t\t\t     XD_RE_PD |\n\t\t\t\t\t     XD_ALE_PD);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL5, 0xFF,\n\t\t\t\t\t     MS_INS_PU |\n\t\t\t\t\t     SD_WP_PD |\n\t\t\t\t\t     SD_CD_PU |\n\t\t\t\t\t     SD_CMD_PD);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL6, 0xFF,\n\t\t\t\t\t     MS_D5_PD | MS_D4_PD);\n\t\tif (retval)\n\t\t\treturn retval;\n\t} else if (CHECK_PID(chip, 0x5288)) {\n\t\tif (CHECK_BARO_PKG(chip, QFN)) {\n\t\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL1,\n\t\t\t\t\t\t     0xFF, 0x55);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL2,\n\t\t\t\t\t\t     0xFF, 0x55);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL3,\n\t\t\t\t\t\t     0xFF, 0x4B);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL4,\n\t\t\t\t\t\t     0xFF, 0x69);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int reset_xd(struct rtsx_chip *chip)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tint retval, i, j;\n\tu8 *ptr, id_buf[4], redunt[11];\n\n\tretval = select_card(chip, XD_CARD);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_CHK_DATA_STATUS, 0xFF,\n\t\t     XD_PGSTS_NOT_FF);\n\tif (chip->asic_code) {\n\t\tif (!CHECK_PID(chip, 0x5288))\n\t\t\txd_fill_pull_ctl_disable(chip);\n\t\telse\n\t\t\txd_fill_pull_ctl_stage1_barossa(chip);\n\t} else {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, FPGA_PULL_CTL, 0xFF,\n\t\t\t     (FPGA_XD_PULL_CTL_EN1 & FPGA_XD_PULL_CTL_EN3) |\n\t\t\t     0x20);\n\t}\n\n\tif (!chip->ft2_fast_mode)\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_INIT,\n\t\t\t     XD_NO_AUTO_PWR_OFF, 0);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_OE, XD_OUTPUT_EN, 0);\n\n\tretval = rtsx_send_cmd(chip, XD_CARD, 100);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\tif (!chip->ft2_fast_mode) {\n\t\tretval = card_power_off(chip, XD_CARD);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\twait_timeout(250);\n\n\t\trtsx_init_cmd(chip);\n\n\t\tif (chip->asic_code) {\n\t\t\txd_fill_pull_ctl_enable(chip);\n\t\t} else {\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, FPGA_PULL_CTL, 0xFF,\n\t\t\t\t     (FPGA_XD_PULL_CTL_EN1 &\n\t\t\t\t      FPGA_XD_PULL_CTL_EN2) |\n\t\t\t\t     0x20);\n\t\t}\n\n\t\tretval = rtsx_send_cmd(chip, XD_CARD, 100);\n\t\tif (retval < 0)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = card_power_on(chip, XD_CARD);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n#ifdef SUPPORT_OCP\n\t\twait_timeout(50);\n\t\tif (chip->ocp_stat & (SD_OC_NOW | SD_OC_EVER)) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"Over current, OCPSTAT is 0x%x\\n\",\n\t\t\t\tchip->ocp_stat);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n#endif\n\t}\n\n\trtsx_init_cmd(chip);\n\n\tif (chip->ft2_fast_mode) {\n\t\tif (chip->asic_code) {\n\t\t\txd_fill_pull_ctl_enable(chip);\n\t\t} else {\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, FPGA_PULL_CTL, 0xFF,\n\t\t\t\t     (FPGA_XD_PULL_CTL_EN1 &\n\t\t\t\t      FPGA_XD_PULL_CTL_EN2) |\n\t\t\t\t     0x20);\n\t\t}\n\t}\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_OE, XD_OUTPUT_EN, XD_OUTPUT_EN);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_CTL, XD_CE_DISEN, XD_CE_DISEN);\n\n\tretval = rtsx_send_cmd(chip, XD_CARD, 100);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\tif (!chip->ft2_fast_mode)\n\t\twait_timeout(200);\n\n\tretval = xd_set_init_para(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\trtsx_init_cmd(chip);\n\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_DTCTL, 0xFF,\n\t\t\t     XD_TIME_SETUP_STEP * 3 +\n\t\t\t     XD_TIME_RW_STEP * (2 + i) + XD_TIME_RWN_STEP * i);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_CATCTL, 0xFF,\n\t\t\t     XD_TIME_SETUP_STEP * 3 +\n\t\t\t     XD_TIME_RW_STEP * (4 + i) +\n\t\t\t     XD_TIME_RWN_STEP * (3 + i));\n\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\n\t\t\t     XD_TRANSFER_START | XD_RESET);\n\t\trtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\n\t\t\t     XD_TRANSFER_END, XD_TRANSFER_END);\n\n\t\trtsx_add_cmd(chip, READ_REG_CMD, XD_DAT, 0, 0);\n\t\trtsx_add_cmd(chip, READ_REG_CMD, XD_CTL, 0, 0);\n\n\t\tretval = rtsx_send_cmd(chip, XD_CARD, 100);\n\t\tif (retval < 0)\n\t\t\treturn STATUS_FAIL;\n\n\t\tptr = rtsx_get_cmd_data(chip) + 1;\n\n\t\tdev_dbg(rtsx_dev(chip), \"XD_DAT: 0x%x, XD_CTL: 0x%x\\n\",\n\t\t\tptr[0], ptr[1]);\n\n\t\tif (((ptr[0] & READY_FLAG) != READY_STATE) ||\n\t\t    !(ptr[1] & XD_RDY))\n\t\t\tcontinue;\n\n\t\tretval = xd_read_id(chip, READ_ID, id_buf, 4);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tdev_dbg(rtsx_dev(chip), \"READ_ID: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\tid_buf[0], id_buf[1], id_buf[2], id_buf[3]);\n\n\t\txd_card->device_code = id_buf[1];\n\n\t\t \n\t\tswitch (xd_card->device_code) {\n\t\tcase XD_4M_X8_512_1:\n\t\tcase XD_4M_X8_512_2:\n\t\t\txd_card->block_shift = 4;\n\t\t\txd_card->page_off = 0x0F;\n\t\t\txd_card->addr_cycle = 3;\n\t\t\txd_card->zone_cnt = 1;\n\t\t\txd_card->capacity = 8000;\n\t\t\tXD_SET_4MB(xd_card);\n\t\t\tbreak;\n\t\tcase XD_8M_X8_512:\n\t\t\txd_card->block_shift = 4;\n\t\t\txd_card->page_off = 0x0F;\n\t\t\txd_card->addr_cycle = 3;\n\t\t\txd_card->zone_cnt = 1;\n\t\t\txd_card->capacity = 16000;\n\t\t\tbreak;\n\t\tcase XD_16M_X8_512:\n\t\t\tXD_PAGE_512(xd_card);\n\t\t\txd_card->addr_cycle = 3;\n\t\t\txd_card->zone_cnt = 1;\n\t\t\txd_card->capacity = 32000;\n\t\t\tbreak;\n\t\tcase XD_32M_X8_512:\n\t\t\tXD_PAGE_512(xd_card);\n\t\t\txd_card->addr_cycle = 3;\n\t\t\txd_card->zone_cnt = 2;\n\t\t\txd_card->capacity = 64000;\n\t\t\tbreak;\n\t\tcase XD_64M_X8_512:\n\t\t\tXD_PAGE_512(xd_card);\n\t\t\txd_card->addr_cycle = 4;\n\t\t\txd_card->zone_cnt = 4;\n\t\t\txd_card->capacity = 128000;\n\t\t\tbreak;\n\t\tcase XD_128M_X8_512:\n\t\t\tXD_PAGE_512(xd_card);\n\t\t\txd_card->addr_cycle = 4;\n\t\t\txd_card->zone_cnt = 8;\n\t\t\txd_card->capacity = 256000;\n\t\t\tbreak;\n\t\tcase XD_256M_X8_512:\n\t\t\tXD_PAGE_512(xd_card);\n\t\t\txd_card->addr_cycle = 4;\n\t\t\txd_card->zone_cnt = 16;\n\t\t\txd_card->capacity = 512000;\n\t\t\tbreak;\n\t\tcase XD_512M_X8:\n\t\t\tXD_PAGE_512(xd_card);\n\t\t\txd_card->addr_cycle = 4;\n\t\t\txd_card->zone_cnt = 32;\n\t\t\txd_card->capacity = 1024000;\n\t\t\tbreak;\n\t\tcase XD_1G_X8_512:\n\t\t\tXD_PAGE_512(xd_card);\n\t\t\txd_card->addr_cycle = 4;\n\t\t\txd_card->zone_cnt = 64;\n\t\t\txd_card->capacity = 2048000;\n\t\t\tbreak;\n\t\tcase XD_2G_X8_512:\n\t\t\tXD_PAGE_512(xd_card);\n\t\t\txd_card->addr_cycle = 4;\n\t\t\txd_card->zone_cnt = 128;\n\t\t\txd_card->capacity = 4096000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < 10; j++) {\n\t\t\tretval = xd_read_id(chip, READ_ID, id_buf, 4);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\n\t\t\tif (id_buf[1] != xd_card->device_code)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j == 10)\n\t\t\tbreak;\n\t}\n\n\tif (i == 4) {\n\t\txd_card->block_shift = 0;\n\t\txd_card->page_off = 0;\n\t\txd_card->addr_cycle = 0;\n\t\txd_card->capacity = 0;\n\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = xd_read_id(chip, READ_XD_ID, id_buf, 4);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\tdev_dbg(rtsx_dev(chip), \"READ_XD_ID: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\tid_buf[0], id_buf[1], id_buf[2], id_buf[3]);\n\tif (id_buf[2] != XD_ID_CODE)\n\t\treturn STATUS_FAIL;\n\n\t \n\tfor (i = 0; i < 24; i++) {\n\t\tu32 page_addr;\n\n\t\tif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tpage_addr = (u32)i << xd_card->block_shift;\n\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tretval = xd_read_redundant(chip, page_addr, redunt, 11);\n\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == 3)\n\t\t\tcontinue;\n\n\t\tif (redunt[BLOCK_STATUS] != XD_GBLK)\n\t\t\tcontinue;\n\n\t\tj = 0;\n\t\tif (redunt[PAGE_STATUS] != XD_GPG) {\n\t\t\tfor (j = 1; j <= 8; j++) {\n\t\t\t\tretval = xd_read_redundant(chip, page_addr + j,\n\t\t\t\t\t\t\t   redunt, 11);\n\t\t\t\tif (retval == STATUS_SUCCESS) {\n\t\t\t\t\tif (redunt[PAGE_STATUS] == XD_GPG)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (j == 9)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (redunt[BLOCK_STATUS] == XD_GBLK &&\n\t\t    (redunt[PARITY] & XD_BA1_ALL0)) {\n\t\t\tu8 buf[10];\n\n\t\t\tpage_addr += j;\n\n\t\t\tretval = xd_read_cis(chip, page_addr, buf, 10);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\n\t\t\tif (buf[0] == 0x01 && buf[1] == 0x03 &&\n\t\t\t    buf[2] == 0xD9 &&\n\t\t\t    buf[3] == 0x01 && buf[4] == 0xFF &&\n\t\t\t    buf[5] == 0x18 && buf[6] == 0x02 &&\n\t\t\t    buf[7] == 0xDF && buf[8] == 0x01 &&\n\t\t\t    buf[9] == 0x20) {\n\t\t\t\txd_card->cis_block = (u16)i;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tdev_dbg(rtsx_dev(chip), \"CIS block: 0x%x\\n\", xd_card->cis_block);\n\tif (xd_card->cis_block == 0xFFFF)\n\t\treturn STATUS_FAIL;\n\n\tchip->capacity[chip->card2lun[XD_CARD]] = xd_card->capacity;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int xd_check_data_blank(u8 *redunt)\n{\n\tint i;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (redunt[PAGE_STATUS + i] != 0xFF)\n\t\t\treturn 0;\n\t}\n\n\tif ((redunt[PARITY] & (XD_ECC1_ALL1 | XD_ECC2_ALL1))\n\t\t!= (XD_ECC1_ALL1 | XD_ECC2_ALL1))\n\t\treturn 0;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (redunt[RESERVED0 + i] != 0xFF)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic u16 xd_load_log_block_addr(u8 *redunt)\n{\n\tu16 addr = 0xFFFF;\n\n\tif (redunt[PARITY] & XD_BA1_BA2_EQL)\n\t\taddr = ((u16)redunt[BLOCK_ADDR1_H] << 8) |\n\t\t\tredunt[BLOCK_ADDR1_L];\n\telse if (redunt[PARITY] & XD_BA1_VALID)\n\t\taddr = ((u16)redunt[BLOCK_ADDR1_H] << 8) |\n\t\t\tredunt[BLOCK_ADDR1_L];\n\telse if (redunt[PARITY] & XD_BA2_VALID)\n\t\taddr = ((u16)redunt[BLOCK_ADDR2_H] << 8) |\n\t\t\tredunt[BLOCK_ADDR2_L];\n\n\treturn addr;\n}\n\nstatic int xd_init_l2p_tbl(struct rtsx_chip *chip)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tint size, i;\n\n\tdev_dbg(rtsx_dev(chip), \"%s: zone_cnt = %d\\n\", __func__,\n\t\txd_card->zone_cnt);\n\n\tif (xd_card->zone_cnt < 1)\n\t\treturn STATUS_FAIL;\n\n\tsize = xd_card->zone_cnt * sizeof(struct zone_entry);\n\tdev_dbg(rtsx_dev(chip), \"Buffer size for l2p table is %d\\n\", size);\n\n\txd_card->zone = vmalloc(size);\n\tif (!xd_card->zone)\n\t\treturn STATUS_ERROR;\n\n\tfor (i = 0; i < xd_card->zone_cnt; i++) {\n\t\txd_card->zone[i].build_flag = 0;\n\t\txd_card->zone[i].l2p_table = NULL;\n\t\txd_card->zone[i].free_table = NULL;\n\t\txd_card->zone[i].get_index = 0;\n\t\txd_card->zone[i].set_index = 0;\n\t\txd_card->zone[i].unused_blk_cnt = 0;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic inline void free_zone(struct zone_entry *zone)\n{\n\tif (!zone)\n\t\treturn;\n\n\tzone->build_flag = 0;\n\tzone->set_index = 0;\n\tzone->get_index = 0;\n\tzone->unused_blk_cnt = 0;\n\tvfree(zone->l2p_table);\n\tzone->l2p_table = NULL;\n\tvfree(zone->free_table);\n\tzone->free_table = NULL;\n}\n\nstatic void xd_set_unused_block(struct rtsx_chip *chip, u32 phy_blk)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tstruct zone_entry *zone;\n\tint zone_no;\n\n\tzone_no = (int)phy_blk >> 10;\n\tif (zone_no >= xd_card->zone_cnt) {\n\t\tdev_dbg(rtsx_dev(chip), \"Set unused block to invalid zone (zone_no = %d, zone_cnt = %d)\\n\",\n\t\t\tzone_no, xd_card->zone_cnt);\n\t\treturn;\n\t}\n\tzone = &xd_card->zone[zone_no];\n\n\tif (!zone->free_table) {\n\t\tif (xd_build_l2p_tbl(chip, zone_no) != STATUS_SUCCESS)\n\t\t\treturn;\n\t}\n\n\tif (zone->set_index >= XD_FREE_TABLE_CNT ||\n\t    zone->set_index < 0) {\n\t\tfree_zone(zone);\n\t\tdev_dbg(rtsx_dev(chip), \"Set unused block fail, invalid set_index\\n\");\n\t\treturn;\n\t}\n\n\tdev_dbg(rtsx_dev(chip), \"Set unused block to index %d\\n\",\n\t\tzone->set_index);\n\n\tzone->free_table[zone->set_index++] = (u16)(phy_blk & 0x3ff);\n\tif (zone->set_index >= XD_FREE_TABLE_CNT)\n\t\tzone->set_index = 0;\n\tzone->unused_blk_cnt++;\n}\n\nstatic u32 xd_get_unused_block(struct rtsx_chip *chip, int zone_no)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tstruct zone_entry *zone;\n\tu32 phy_blk;\n\n\tif (zone_no >= xd_card->zone_cnt) {\n\t\tdev_dbg(rtsx_dev(chip), \"Get unused block from invalid zone (zone_no = %d, zone_cnt = %d)\\n\",\n\t\t\tzone_no, xd_card->zone_cnt);\n\t\treturn BLK_NOT_FOUND;\n\t}\n\tzone = &xd_card->zone[zone_no];\n\n\tif (zone->unused_blk_cnt == 0 ||\n\t    zone->set_index == zone->get_index) {\n\t\tfree_zone(zone);\n\t\tdev_dbg(rtsx_dev(chip), \"Get unused block fail, no unused block available\\n\");\n\t\treturn BLK_NOT_FOUND;\n\t}\n\tif (zone->get_index >= XD_FREE_TABLE_CNT || zone->get_index < 0) {\n\t\tfree_zone(zone);\n\t\tdev_dbg(rtsx_dev(chip), \"Get unused block fail, invalid get_index\\n\");\n\t\treturn BLK_NOT_FOUND;\n\t}\n\n\tdev_dbg(rtsx_dev(chip), \"Get unused block from index %d\\n\",\n\t\tzone->get_index);\n\n\tphy_blk = zone->free_table[zone->get_index];\n\tzone->free_table[zone->get_index++] = 0xFFFF;\n\tif (zone->get_index >= XD_FREE_TABLE_CNT)\n\t\tzone->get_index = 0;\n\tzone->unused_blk_cnt--;\n\n\tphy_blk += ((u32)(zone_no) << 10);\n\treturn phy_blk;\n}\n\nstatic void xd_set_l2p_tbl(struct rtsx_chip *chip,\n\t\t\t   int zone_no, u16 log_off, u16 phy_off)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tstruct zone_entry *zone;\n\n\tzone = &xd_card->zone[zone_no];\n\tzone->l2p_table[log_off] = phy_off;\n}\n\nstatic u32 xd_get_l2p_tbl(struct rtsx_chip *chip, int zone_no, u16 log_off)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tstruct zone_entry *zone;\n\tint retval;\n\n\tzone = &xd_card->zone[zone_no];\n\tif (zone->l2p_table[log_off] == 0xFFFF) {\n\t\tu32 phy_blk = 0;\n\t\tint i;\n\n#ifdef XD_DELAY_WRITE\n\t\tretval = xd_delay_write(chip);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"In %s, delay write fail!\\n\",\n\t\t\t\t__func__);\n\t\t\treturn BLK_NOT_FOUND;\n\t\t}\n#endif\n\n\t\tif (zone->unused_blk_cnt <= 0) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"No unused block!\\n\");\n\t\t\treturn BLK_NOT_FOUND;\n\t\t}\n\n\t\tfor (i = 0; i < zone->unused_blk_cnt; i++) {\n\t\t\tphy_blk = xd_get_unused_block(chip, zone_no);\n\t\t\tif (phy_blk == BLK_NOT_FOUND) {\n\t\t\t\tdev_dbg(rtsx_dev(chip), \"No unused block available!\\n\");\n\t\t\t\treturn BLK_NOT_FOUND;\n\t\t\t}\n\n\t\t\tretval = xd_init_page(chip, phy_blk, log_off,\n\t\t\t\t\t      0, xd_card->page_off + 1);\n\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= zone->unused_blk_cnt) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"No good unused block available!\\n\");\n\t\t\treturn BLK_NOT_FOUND;\n\t\t}\n\n\t\txd_set_l2p_tbl(chip, zone_no, log_off, (u16)(phy_blk & 0x3FF));\n\t\treturn phy_blk;\n\t}\n\n\treturn (u32)zone->l2p_table[log_off] + ((u32)(zone_no) << 10);\n}\n\nint reset_xd_card(struct rtsx_chip *chip)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tint retval;\n\n\tmemset(xd_card, 0, sizeof(struct xd_info));\n\n\txd_card->block_shift = 0;\n\txd_card->page_off = 0;\n\txd_card->addr_cycle = 0;\n\txd_card->capacity = 0;\n\txd_card->zone_cnt = 0;\n\txd_card->cis_block = 0xFFFF;\n\txd_card->delay_write.delay_write_flag = 0;\n\n\tretval = enable_card_clock(chip, XD_CARD);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = reset_xd(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = xd_init_l2p_tbl(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int xd_mark_bad_block(struct rtsx_chip *chip, u32 phy_blk)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tint retval;\n\tu32 page_addr;\n\tu8 reg = 0;\n\n\tdev_dbg(rtsx_dev(chip), \"mark block 0x%x as bad block\\n\", phy_blk);\n\n\tif (phy_blk == BLK_NOT_FOUND)\n\t\treturn STATUS_FAIL;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_STATUS, 0xFF, XD_GPG);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_STATUS, 0xFF, XD_LATER_BBLK);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_H, 0xFF, 0xFF);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_L, 0xFF, 0xFF);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR2_H, 0xFF, 0xFF);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR2_L, 0xFF, 0xFF);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_RESERVED0, 0xFF, 0xFF);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_RESERVED1, 0xFF, 0xFF);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_RESERVED2, 0xFF, 0xFF);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_RESERVED3, 0xFF, 0xFF);\n\n\tpage_addr = phy_blk << xd_card->block_shift;\n\n\txd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF,\n\t\t     xd_card->page_off + 1);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\n\t\t     XD_TRANSFER_START | XD_WRITE_REDUNDANT);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\n\t\t     XD_TRANSFER_END, XD_TRANSFER_END);\n\n\tretval = rtsx_send_cmd(chip, XD_CARD, 500);\n\tif (retval < 0) {\n\t\trtsx_clear_xd_error(chip);\n\t\trtsx_read_register(chip, XD_DAT, &reg);\n\t\tif (reg & PROGRAM_ERROR)\n\t\t\txd_set_err_code(chip, XD_PRG_ERROR);\n\t\telse\n\t\t\txd_set_err_code(chip, XD_TO_ERROR);\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int xd_init_page(struct rtsx_chip *chip, u32 phy_blk,\n\t\t\tu16 logoff, u8 start_page, u8 end_page)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tint retval;\n\tu32 page_addr;\n\tu8 reg = 0;\n\n\tdev_dbg(rtsx_dev(chip), \"Init block 0x%x\\n\", phy_blk);\n\n\tif (start_page > end_page)\n\t\treturn STATUS_FAIL;\n\tif (phy_blk == BLK_NOT_FOUND)\n\t\treturn STATUS_FAIL;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_STATUS, 0xFF, 0xFF);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_STATUS, 0xFF, 0xFF);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_H,\n\t\t     0xFF, (u8)(logoff >> 8));\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_L, 0xFF, (u8)logoff);\n\n\tpage_addr = (phy_blk << xd_card->block_shift) + start_page;\n\n\txd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_CFG,\n\t\t     XD_BA_TRANSFORM, XD_BA_TRANSFORM);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT,\n\t\t     0xFF, (end_page - start_page));\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER,\n\t\t     0xFF, XD_TRANSFER_START | XD_WRITE_REDUNDANT);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\n\t\t     XD_TRANSFER_END, XD_TRANSFER_END);\n\n\tretval = rtsx_send_cmd(chip, XD_CARD, 500);\n\tif (retval < 0) {\n\t\trtsx_clear_xd_error(chip);\n\t\trtsx_read_register(chip, XD_DAT, &reg);\n\t\tif (reg & PROGRAM_ERROR) {\n\t\t\txd_mark_bad_block(chip, phy_blk);\n\t\t\txd_set_err_code(chip, XD_PRG_ERROR);\n\t\t} else {\n\t\t\txd_set_err_code(chip, XD_TO_ERROR);\n\t\t}\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int xd_copy_page(struct rtsx_chip *chip, u32 old_blk, u32 new_blk,\n\t\t\tu8 start_page, u8 end_page)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tu32 old_page, new_page;\n\tu8 i, reg = 0;\n\tint retval;\n\n\tdev_dbg(rtsx_dev(chip), \"Copy page from block 0x%x to block 0x%x\\n\",\n\t\told_blk, new_blk);\n\n\tif (start_page > end_page)\n\t\treturn STATUS_FAIL;\n\n\tif (old_blk == BLK_NOT_FOUND || new_blk == BLK_NOT_FOUND)\n\t\treturn STATUS_FAIL;\n\n\told_page = (old_blk << xd_card->block_shift) + start_page;\n\tnew_page = (new_blk << xd_card->block_shift) + start_page;\n\n\tXD_CLR_BAD_NEWBLK(xd_card);\n\n\tretval = rtsx_write_register(chip, CARD_DATA_SOURCE, 0x01,\n\t\t\t\t     PINGPONG_BUFFER);\n\tif (retval)\n\t\treturn retval;\n\n\tfor (i = start_page; i < end_page; i++) {\n\t\tif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\n\t\t\trtsx_clear_xd_error(chip);\n\t\t\txd_set_err_code(chip, XD_NO_CARD);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\trtsx_init_cmd(chip);\n\n\t\txd_assign_phy_addr(chip, old_page, XD_RW_ADDR);\n\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, 1);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_CHK_DATA_STATUS,\n\t\t\t     XD_AUTO_CHK_DATA_STATUS, 0);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\n\t\t\t     XD_TRANSFER_START | XD_READ_PAGES);\n\t\trtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\n\t\t\t     XD_TRANSFER_END, XD_TRANSFER_END);\n\n\t\tretval = rtsx_send_cmd(chip, XD_CARD, 500);\n\t\tif (retval < 0) {\n\t\t\trtsx_clear_xd_error(chip);\n\t\t\treg = 0;\n\t\t\trtsx_read_register(chip, XD_CTL, &reg);\n\t\t\tif (reg & (XD_ECC1_ERROR | XD_ECC2_ERROR)) {\n\t\t\t\tmdelay(100);\n\n\t\t\t\tif (detect_card_cd(chip,\n\t\t\t\t\t\t   XD_CARD) != STATUS_SUCCESS) {\n\t\t\t\t\txd_set_err_code(chip, XD_NO_CARD);\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t\t}\n\n\t\t\t\tif (((reg & XD_ECC1_ERROR) &&\n\t\t\t\t     (reg & XD_ECC1_UNCORRECTABLE)) ||\n\t\t\t\t    ((reg & XD_ECC2_ERROR) &&\n\t\t\t\t     (reg & XD_ECC2_UNCORRECTABLE))) {\n\t\t\t\t\trtsx_write_register(chip,\n\t\t\t\t\t\t\t    XD_PAGE_STATUS,\n\t\t\t\t\t\t\t    0xFF,\n\t\t\t\t\t\t\t    XD_BPG);\n\t\t\t\t\trtsx_write_register(chip,\n\t\t\t\t\t\t\t    XD_BLOCK_STATUS,\n\t\t\t\t\t\t\t    0xFF,\n\t\t\t\t\t\t\t    XD_GBLK);\n\t\t\t\t\tXD_SET_BAD_OLDBLK(xd_card);\n\t\t\t\t\tdev_dbg(rtsx_dev(chip), \"old block 0x%x ecc error\\n\",\n\t\t\t\t\t\told_blk);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txd_set_err_code(chip, XD_TO_ERROR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t}\n\n\t\tif (XD_CHK_BAD_OLDBLK(xd_card))\n\t\t\trtsx_clear_xd_error(chip);\n\n\t\trtsx_init_cmd(chip);\n\n\t\txd_assign_phy_addr(chip, new_page, XD_RW_ADDR);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, 1);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\n\t\t\t     XD_TRANSFER_START | XD_WRITE_PAGES);\n\t\trtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\n\t\t\t     XD_TRANSFER_END, XD_TRANSFER_END);\n\n\t\tretval = rtsx_send_cmd(chip, XD_CARD, 300);\n\t\tif (retval < 0) {\n\t\t\trtsx_clear_xd_error(chip);\n\t\t\treg = 0;\n\t\t\trtsx_read_register(chip, XD_DAT, &reg);\n\t\t\tif (reg & PROGRAM_ERROR) {\n\t\t\t\txd_mark_bad_block(chip, new_blk);\n\t\t\t\txd_set_err_code(chip, XD_PRG_ERROR);\n\t\t\t\tXD_SET_BAD_NEWBLK(xd_card);\n\t\t\t} else {\n\t\t\t\txd_set_err_code(chip, XD_TO_ERROR);\n\t\t\t}\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\told_page++;\n\t\tnew_page++;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int xd_reset_cmd(struct rtsx_chip *chip)\n{\n\tint retval;\n\tu8 *ptr;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER,\n\t\t     0xFF, XD_TRANSFER_START | XD_RESET);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\n\t\t     XD_TRANSFER_END, XD_TRANSFER_END);\n\trtsx_add_cmd(chip, READ_REG_CMD, XD_DAT, 0, 0);\n\trtsx_add_cmd(chip, READ_REG_CMD, XD_CTL, 0, 0);\n\n\tretval = rtsx_send_cmd(chip, XD_CARD, 100);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\tptr = rtsx_get_cmd_data(chip) + 1;\n\tif (((ptr[0] & READY_FLAG) == READY_STATE) && (ptr[1] & XD_RDY))\n\t\treturn STATUS_SUCCESS;\n\n\treturn STATUS_FAIL;\n}\n\nstatic int xd_erase_block(struct rtsx_chip *chip, u32 phy_blk)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tu32 page_addr;\n\tu8 reg = 0, *ptr;\n\tint i, retval;\n\n\tif (phy_blk == BLK_NOT_FOUND)\n\t\treturn STATUS_FAIL;\n\n\tpage_addr = phy_blk << xd_card->block_shift;\n\n\tfor (i = 0; i < 3; i++) {\n\t\trtsx_init_cmd(chip);\n\n\t\txd_assign_phy_addr(chip, page_addr, XD_ERASE_ADDR);\n\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\n\t\t\t     XD_TRANSFER_START | XD_ERASE);\n\t\trtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\n\t\t\t     XD_TRANSFER_END, XD_TRANSFER_END);\n\t\trtsx_add_cmd(chip, READ_REG_CMD, XD_DAT, 0, 0);\n\n\t\tretval = rtsx_send_cmd(chip, XD_CARD, 250);\n\t\tif (retval < 0) {\n\t\t\trtsx_clear_xd_error(chip);\n\t\t\trtsx_read_register(chip, XD_DAT, &reg);\n\t\t\tif (reg & PROGRAM_ERROR) {\n\t\t\t\txd_mark_bad_block(chip, phy_blk);\n\t\t\t\txd_set_err_code(chip, XD_PRG_ERROR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t\txd_set_err_code(chip, XD_ERASE_FAIL);\n\t\t\tretval = xd_reset_cmd(chip);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tptr = rtsx_get_cmd_data(chip) + 1;\n\t\tif (*ptr & PROGRAM_ERROR) {\n\t\t\txd_mark_bad_block(chip, phy_blk);\n\t\t\txd_set_err_code(chip, XD_PRG_ERROR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\treturn STATUS_SUCCESS;\n\t}\n\n\txd_mark_bad_block(chip, phy_blk);\n\txd_set_err_code(chip, XD_ERASE_FAIL);\n\treturn STATUS_FAIL;\n}\n\nstatic int xd_build_l2p_tbl(struct rtsx_chip *chip, int zone_no)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tstruct zone_entry *zone;\n\tint retval;\n\tu32 start, end, i;\n\tu16 max_logoff, cur_fst_page_logoff;\n\tu16 cur_lst_page_logoff, ent_lst_page_logoff;\n\tu8 redunt[11];\n\n\tdev_dbg(rtsx_dev(chip), \"%s: %d\\n\", __func__, zone_no);\n\n\tif (!xd_card->zone) {\n\t\tretval = xd_init_l2p_tbl(chip);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn retval;\n\t}\n\n\tif (xd_card->zone[zone_no].build_flag) {\n\t\tdev_dbg(rtsx_dev(chip), \"l2p table of zone %d has been built\\n\",\n\t\t\tzone_no);\n\t\treturn STATUS_SUCCESS;\n\t}\n\n\tzone = &xd_card->zone[zone_no];\n\n\tif (!zone->l2p_table) {\n\t\tzone->l2p_table = vmalloc(2000);\n\t\tif (!zone->l2p_table)\n\t\t\tgoto build_fail;\n\t}\n\tmemset((u8 *)(zone->l2p_table), 0xff, 2000);\n\n\tif (!zone->free_table) {\n\t\tzone->free_table = vmalloc(XD_FREE_TABLE_CNT * 2);\n\t\tif (!zone->free_table)\n\t\t\tgoto build_fail;\n\t}\n\tmemset((u8 *)(zone->free_table), 0xff, XD_FREE_TABLE_CNT * 2);\n\n\tif (zone_no == 0) {\n\t\tif (xd_card->cis_block == 0xFFFF)\n\t\t\tstart = 0;\n\t\telse\n\t\t\tstart = xd_card->cis_block + 1;\n\t\tif (XD_CHK_4MB(xd_card)) {\n\t\t\tend = 0x200;\n\t\t\tmax_logoff = 499;\n\t\t} else {\n\t\t\tend = 0x400;\n\t\t\tmax_logoff = 999;\n\t\t}\n\t} else {\n\t\tstart = (u32)(zone_no) << 10;\n\t\tend = (u32)(zone_no + 1) << 10;\n\t\tmax_logoff = 999;\n\t}\n\n\tdev_dbg(rtsx_dev(chip), \"start block 0x%x, end block 0x%x\\n\",\n\t\tstart, end);\n\n\tzone->set_index = 0;\n\tzone->get_index = 0;\n\tzone->unused_blk_cnt = 0;\n\n\tfor (i = start; i < end; i++) {\n\t\tu32 page_addr = i << xd_card->block_shift;\n\t\tu32 phy_block;\n\n\t\tretval = xd_read_redundant(chip, page_addr, redunt, 11);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\tcontinue;\n\n\t\tif (redunt[BLOCK_STATUS] != 0xFF) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"bad block\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (xd_check_data_blank(redunt)) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"blank block\\n\");\n\t\t\txd_set_unused_block(chip, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur_fst_page_logoff = xd_load_log_block_addr(redunt);\n\t\tif (cur_fst_page_logoff == 0xFFFF ||\n\t\t    cur_fst_page_logoff > max_logoff) {\n\t\t\tretval = xd_erase_block(chip, i);\n\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\txd_set_unused_block(chip, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (zone_no == 0 && cur_fst_page_logoff == 0 &&\n\t\t    redunt[PAGE_STATUS] != XD_GPG)\n\t\t\tXD_SET_MBR_FAIL(xd_card);\n\n\t\tif (zone->l2p_table[cur_fst_page_logoff] == 0xFFFF) {\n\t\t\tzone->l2p_table[cur_fst_page_logoff] = (u16)(i & 0x3FF);\n\t\t\tcontinue;\n\t\t}\n\n\t\tphy_block = zone->l2p_table[cur_fst_page_logoff] +\n\t\t\t((u32)((zone_no) << 10));\n\n\t\tpage_addr = ((i + 1) << xd_card->block_shift) - 1;\n\n\t\tretval = xd_read_redundant(chip, page_addr, redunt, 11);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\tcontinue;\n\n\t\tcur_lst_page_logoff = xd_load_log_block_addr(redunt);\n\t\tif (cur_lst_page_logoff == cur_fst_page_logoff) {\n\t\t\tint m;\n\n\t\t\tpage_addr = ((phy_block + 1) <<\n\t\t\t\txd_card->block_shift) - 1;\n\n\t\t\tfor (m = 0; m < 3; m++) {\n\t\t\t\tretval = xd_read_redundant(chip, page_addr,\n\t\t\t\t\t\t\t   redunt, 11);\n\t\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (m == 3) {\n\t\t\t\tzone->l2p_table[cur_fst_page_logoff] =\n\t\t\t\t\t(u16)(i & 0x3FF);\n\t\t\t\tretval = xd_erase_block(chip, phy_block);\n\t\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\t\txd_set_unused_block(chip, phy_block);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tent_lst_page_logoff = xd_load_log_block_addr(redunt);\n\t\t\tif (ent_lst_page_logoff != cur_fst_page_logoff) {\n\t\t\t\tzone->l2p_table[cur_fst_page_logoff] =\n\t\t\t\t\t(u16)(i & 0x3FF);\n\t\t\t\tretval = xd_erase_block(chip, phy_block);\n\t\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\t\txd_set_unused_block(chip, phy_block);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tretval = xd_erase_block(chip, i);\n\t\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\t\txd_set_unused_block(chip, i);\n\t\t\t}\n\t\t} else {\n\t\t\tretval = xd_erase_block(chip, i);\n\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\txd_set_unused_block(chip, i);\n\t\t}\n\t}\n\n\tif (XD_CHK_4MB(xd_card))\n\t\tend = 500;\n\telse\n\t\tend = 1000;\n\n\ti = 0;\n\tfor (start = 0; start < end; start++) {\n\t\tif (zone->l2p_table[start] == 0xFFFF)\n\t\t\ti++;\n\t}\n\n\tdev_dbg(rtsx_dev(chip), \"Block count %d, invalid L2P entry %d\\n\",\n\t\tend, i);\n\tdev_dbg(rtsx_dev(chip), \"Total unused block: %d\\n\",\n\t\tzone->unused_blk_cnt);\n\n\tif ((zone->unused_blk_cnt - i) < 1)\n\t\tchip->card_wp |= XD_CARD;\n\n\tzone->build_flag = 1;\n\n\treturn STATUS_SUCCESS;\n\nbuild_fail:\n\tvfree(zone->l2p_table);\n\tzone->l2p_table = NULL;\n\tvfree(zone->free_table);\n\tzone->free_table = NULL;\n\n\treturn STATUS_FAIL;\n}\n\nstatic int xd_send_cmd(struct rtsx_chip *chip, u8 cmd)\n{\n\tint retval;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_DAT, 0xFF, cmd);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\n\t\t     XD_TRANSFER_START | XD_SET_CMD);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\n\t\t     XD_TRANSFER_END, XD_TRANSFER_END);\n\n\tretval = rtsx_send_cmd(chip, XD_CARD, 200);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int xd_read_multiple_pages(struct rtsx_chip *chip, u32 phy_blk,\n\t\t\t\t  u32 log_blk, u8 start_page, u8 end_page,\n\t\t\t\t  u8 *buf, unsigned int *index,\n\t\t\t\t  unsigned int *offset)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tu32 page_addr, new_blk;\n\tu16 log_off;\n\tu8 reg_val, page_cnt;\n\tint zone_no, retval, i;\n\n\tif (start_page > end_page)\n\t\tgoto status_fail;\n\n\tpage_cnt = end_page - start_page;\n\tzone_no = (int)(log_blk / 1000);\n\tlog_off = (u16)(log_blk % 1000);\n\n\tif ((phy_blk & 0x3FF) == 0x3FF) {\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tpage_addr = ((u32)i) << xd_card->block_shift;\n\n\t\t\tretval = xd_read_redundant(chip, page_addr, NULL, 0);\n\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\tbreak;\n\n\t\t\tif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\n\t\t\t\txd_set_err_code(chip, XD_NO_CARD);\n\t\t\t\tgoto status_fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tpage_addr = (phy_blk << xd_card->block_shift) + start_page;\n\n\trtsx_init_cmd(chip);\n\n\txd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_CFG, XD_PPB_TO_SIE, XD_PPB_TO_SIE);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01, RING_BUFFER);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, page_cnt);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_CHK_DATA_STATUS,\n\t\t     XD_AUTO_CHK_DATA_STATUS, XD_AUTO_CHK_DATA_STATUS);\n\n\ttrans_dma_enable(chip->srb->sc_data_direction, chip,\n\t\t\t page_cnt * 512, DMA_512);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\n\t\t     XD_TRANSFER_START | XD_READ_PAGES);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\n\t\t     XD_TRANSFER_END | XD_PPB_EMPTY,\n\t\t     XD_TRANSFER_END | XD_PPB_EMPTY);\n\n\trtsx_send_cmd_no_wait(chip);\n\n\tretval = rtsx_transfer_data_partial(chip, XD_CARD, buf, page_cnt * 512,\n\t\t\t\t\t    scsi_sg_count(chip->srb),\n\t\t\t\t\t    index, offset, DMA_FROM_DEVICE,\n\t\t\t\t\t    chip->xd_timeout);\n\tif (retval < 0) {\n\t\trtsx_clear_xd_error(chip);\n\n\t\tif (retval == -ETIMEDOUT) {\n\t\t\txd_set_err_code(chip, XD_TO_ERROR);\n\t\t\tgoto status_fail;\n\t\t} else {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn STATUS_SUCCESS;\n\nfail:\n\tretval = rtsx_read_register(chip, XD_PAGE_STATUS, &reg_val);\n\tif (retval)\n\t\treturn retval;\n\n\tif (reg_val !=  XD_GPG)\n\t\txd_set_err_code(chip, XD_PRG_ERROR);\n\n\tretval = rtsx_read_register(chip, XD_CTL, &reg_val);\n\tif (retval)\n\t\treturn retval;\n\n\tif (((reg_val & (XD_ECC1_ERROR | XD_ECC1_UNCORRECTABLE)) ==\n\t\t\t\t(XD_ECC1_ERROR | XD_ECC1_UNCORRECTABLE)) ||\n\t\t((reg_val & (XD_ECC2_ERROR | XD_ECC2_UNCORRECTABLE)) ==\n\t\t\t(XD_ECC2_ERROR | XD_ECC2_UNCORRECTABLE))) {\n\t\twait_timeout(100);\n\n\t\tif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\n\t\t\txd_set_err_code(chip, XD_NO_CARD);\n\t\t\tgoto status_fail;\n\t\t}\n\n\t\txd_set_err_code(chip, XD_ECC_ERROR);\n\n\t\tnew_blk = xd_get_unused_block(chip, zone_no);\n\t\tif (new_blk == NO_NEW_BLK) {\n\t\t\tXD_CLR_BAD_OLDBLK(xd_card);\n\t\t\tgoto status_fail;\n\t\t}\n\n\t\tretval = xd_copy_page(chip, phy_blk, new_blk, 0,\n\t\t\t\t      xd_card->page_off + 1);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tif (!XD_CHK_BAD_NEWBLK(xd_card)) {\n\t\t\t\tretval = xd_erase_block(chip, new_blk);\n\t\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\t\txd_set_unused_block(chip, new_blk);\n\t\t\t} else {\n\t\t\t\tXD_CLR_BAD_NEWBLK(xd_card);\n\t\t\t}\n\t\t\tXD_CLR_BAD_OLDBLK(xd_card);\n\t\t\tgoto status_fail;\n\t\t}\n\t\txd_set_l2p_tbl(chip, zone_no, log_off, (u16)(new_blk & 0x3FF));\n\t\txd_erase_block(chip, phy_blk);\n\t\txd_mark_bad_block(chip, phy_blk);\n\t\tXD_CLR_BAD_OLDBLK(xd_card);\n\t}\n\nstatus_fail:\n\treturn STATUS_FAIL;\n}\n\nstatic int xd_finish_write(struct rtsx_chip *chip,\n\t\t\t   u32 old_blk, u32 new_blk, u32 log_blk, u8 page_off)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tint retval, zone_no;\n\tu16 log_off;\n\n\tdev_dbg(rtsx_dev(chip), \"old_blk = 0x%x, \", old_blk);\n\tdev_dbg(rtsx_dev(chip),\t\"new_blk = 0x%x, \", new_blk);\n\tdev_dbg(rtsx_dev(chip), \"log_blk = 0x%x\\n\", log_blk);\n\n\tif (page_off > xd_card->page_off)\n\t\treturn STATUS_FAIL;\n\n\tzone_no = (int)(log_blk / 1000);\n\tlog_off = (u16)(log_blk % 1000);\n\n\tif (old_blk == BLK_NOT_FOUND) {\n\t\tretval = xd_init_page(chip, new_blk, log_off,\n\t\t\t\t      page_off, xd_card->page_off + 1);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tretval = xd_erase_block(chip, new_blk);\n\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\txd_set_unused_block(chip, new_blk);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t} else {\n\t\tretval = xd_copy_page(chip, old_blk, new_blk,\n\t\t\t\t      page_off, xd_card->page_off + 1);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tif (!XD_CHK_BAD_NEWBLK(xd_card)) {\n\t\t\t\tretval = xd_erase_block(chip, new_blk);\n\t\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\t\txd_set_unused_block(chip, new_blk);\n\t\t\t}\n\t\t\tXD_CLR_BAD_NEWBLK(xd_card);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tretval = xd_erase_block(chip, old_blk);\n\t\tif (retval == STATUS_SUCCESS) {\n\t\t\tif (XD_CHK_BAD_OLDBLK(xd_card)) {\n\t\t\t\txd_mark_bad_block(chip, old_blk);\n\t\t\t\tXD_CLR_BAD_OLDBLK(xd_card);\n\t\t\t} else {\n\t\t\t\txd_set_unused_block(chip, old_blk);\n\t\t\t}\n\t\t} else {\n\t\t\txd_set_err_code(chip, XD_NO_ERROR);\n\t\t\tXD_CLR_BAD_OLDBLK(xd_card);\n\t\t}\n\t}\n\n\txd_set_l2p_tbl(chip, zone_no, log_off, (u16)(new_blk & 0x3FF));\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int xd_prepare_write(struct rtsx_chip *chip,\n\t\t\t    u32 old_blk, u32 new_blk, u32 log_blk, u8 page_off)\n{\n\tint retval;\n\n\tdev_dbg(rtsx_dev(chip), \"%s, old_blk = 0x%x, new_blk = 0x%x, log_blk = 0x%x, page_off = %d\\n\",\n\t\t__func__, old_blk, new_blk, log_blk, (int)page_off);\n\n\tif (page_off) {\n\t\tretval = xd_copy_page(chip, old_blk, new_blk, 0, page_off);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int xd_write_multiple_pages(struct rtsx_chip *chip, u32 old_blk,\n\t\t\t\t   u32 new_blk, u32 log_blk, u8 start_page,\n\t\t\t\t   u8 end_page, u8 *buf, unsigned int *index,\n\t\t\t\t   unsigned int *offset)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tu32 page_addr;\n\tint zone_no, retval;\n\tu16 log_off;\n\tu8 page_cnt, reg_val;\n\n\tdev_dbg(rtsx_dev(chip), \"%s, old_blk = 0x%x, new_blk = 0x%x, log_blk = 0x%x\\n\",\n\t\t__func__, old_blk, new_blk, log_blk);\n\n\tif (start_page > end_page)\n\t\tgoto status_fail;\n\n\tpage_cnt = end_page - start_page;\n\tzone_no = (int)(log_blk / 1000);\n\tlog_off = (u16)(log_blk % 1000);\n\n\tpage_addr = (new_blk << xd_card->block_shift) + start_page;\n\n\tretval = xd_send_cmd(chip, READ1_1);\n\tif (retval != STATUS_SUCCESS)\n\t\tgoto status_fail;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_H,\n\t\t     0xFF, (u8)(log_off >> 8));\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_L, 0xFF, (u8)log_off);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_STATUS, 0xFF, XD_GBLK);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_STATUS, 0xFF, XD_GPG);\n\n\txd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_CFG, XD_BA_TRANSFORM,\n\t\t     XD_BA_TRANSFORM);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, page_cnt);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01, RING_BUFFER);\n\n\ttrans_dma_enable(chip->srb->sc_data_direction, chip,\n\t\t\t page_cnt * 512, DMA_512);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER,\n\t\t     0xFF, XD_TRANSFER_START | XD_WRITE_PAGES);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\n\t\t     XD_TRANSFER_END, XD_TRANSFER_END);\n\n\trtsx_send_cmd_no_wait(chip);\n\n\tretval = rtsx_transfer_data_partial(chip, XD_CARD, buf, page_cnt * 512,\n\t\t\t\t\t    scsi_sg_count(chip->srb),\n\t\t\t\t\t    index, offset, DMA_TO_DEVICE, chip->xd_timeout);\n\tif (retval < 0) {\n\t\trtsx_clear_xd_error(chip);\n\n\t\tif (retval == -ETIMEDOUT) {\n\t\t\txd_set_err_code(chip, XD_TO_ERROR);\n\t\t\tgoto status_fail;\n\t\t} else {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (end_page == (xd_card->page_off + 1)) {\n\t\txd_card->delay_write.delay_write_flag = 0;\n\n\t\tif (old_blk != BLK_NOT_FOUND) {\n\t\t\tretval = xd_erase_block(chip, old_blk);\n\t\t\tif (retval == STATUS_SUCCESS) {\n\t\t\t\tif (XD_CHK_BAD_OLDBLK(xd_card)) {\n\t\t\t\t\txd_mark_bad_block(chip, old_blk);\n\t\t\t\t\tXD_CLR_BAD_OLDBLK(xd_card);\n\t\t\t\t} else {\n\t\t\t\t\txd_set_unused_block(chip, old_blk);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txd_set_err_code(chip, XD_NO_ERROR);\n\t\t\t\tXD_CLR_BAD_OLDBLK(xd_card);\n\t\t\t}\n\t\t}\n\t\txd_set_l2p_tbl(chip, zone_no, log_off, (u16)(new_blk & 0x3FF));\n\t}\n\n\treturn STATUS_SUCCESS;\n\nfail:\n\tretval = rtsx_read_register(chip, XD_DAT, &reg_val);\n\tif (retval)\n\t\treturn retval;\n\tif (reg_val & PROGRAM_ERROR) {\n\t\txd_set_err_code(chip, XD_PRG_ERROR);\n\t\txd_mark_bad_block(chip, new_blk);\n\t}\n\nstatus_fail:\n\treturn STATUS_FAIL;\n}\n\n#ifdef XD_DELAY_WRITE\nint xd_delay_write(struct rtsx_chip *chip)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tstruct xd_delay_write_tag *delay_write = &xd_card->delay_write;\n\tint retval;\n\n\tif (delay_write->delay_write_flag) {\n\t\tretval = xd_switch_clock(chip);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tdelay_write->delay_write_flag = 0;\n\t\tretval = xd_finish_write(chip,\n\t\t\t\t\t delay_write->old_phyblock,\n\t\t\t\t\t delay_write->new_phyblock,\n\t\t\t\t\t delay_write->logblock,\n\t\t\t\t\t delay_write->pageoff);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n#endif\n\nint xd_rw(struct scsi_cmnd *srb, struct rtsx_chip *chip,\n\t  u32 start_sector, u16 sector_cnt)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tunsigned int lun = SCSI_LUN(srb);\n#ifdef XD_DELAY_WRITE\n\tstruct xd_delay_write_tag *delay_write = &xd_card->delay_write;\n#endif\n\tint retval, zone_no;\n\tunsigned int index = 0, offset = 0;\n\tu32 log_blk, old_blk = 0, new_blk = 0;\n\tu16 log_off, total_sec_cnt = sector_cnt;\n\tu8 start_page, end_page = 0, page_cnt;\n\tu8 *ptr;\n\n\txd_set_err_code(chip, XD_NO_ERROR);\n\n\txd_card->cleanup_counter = 0;\n\n\tdev_dbg(rtsx_dev(chip), \"%s: scsi_sg_count = %d\\n\", __func__,\n\t\tscsi_sg_count(srb));\n\n\tptr = (u8 *)scsi_sglist(srb);\n\n\tretval = xd_switch_clock(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\n\t\tchip->card_fail |= XD_CARD;\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tlog_blk = start_sector >> xd_card->block_shift;\n\tstart_page = (u8)start_sector & xd_card->page_off;\n\tzone_no = (int)(log_blk / 1000);\n\tlog_off = (u16)(log_blk % 1000);\n\n\tif (xd_card->zone[zone_no].build_flag == 0) {\n\t\tretval = xd_build_l2p_tbl(chip, zone_no);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tchip->card_fail |= XD_CARD;\n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\tif (srb->sc_data_direction == DMA_TO_DEVICE) {\n#ifdef XD_DELAY_WRITE\n\t\tif (delay_write->delay_write_flag &&\n\t\t    delay_write->logblock == log_blk &&\n\t\t    start_page > delay_write->pageoff) {\n\t\t\tdelay_write->delay_write_flag = 0;\n\t\t\tif (delay_write->old_phyblock != BLK_NOT_FOUND) {\n\t\t\t\tretval = xd_copy_page(chip,\n\t\t\t\t\t\t      delay_write->old_phyblock,\n\t\t\t\t\t\t      delay_write->new_phyblock,\n\t\t\t\t\t\t      delay_write->pageoff,\n\t\t\t\t\t\t      start_page);\n\t\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t\t}\n\t\t\t}\n\t\t\told_blk = delay_write->old_phyblock;\n\t\t\tnew_blk = delay_write->new_phyblock;\n\t\t} else if (delay_write->delay_write_flag &&\n\t\t\t\t(delay_write->logblock == log_blk) &&\n\t\t\t\t(start_page == delay_write->pageoff)) {\n\t\t\tdelay_write->delay_write_flag = 0;\n\t\t\told_blk = delay_write->old_phyblock;\n\t\t\tnew_blk = delay_write->new_phyblock;\n\t\t} else {\n\t\t\tretval = xd_delay_write(chip);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n#endif\n\t\t\told_blk = xd_get_l2p_tbl(chip, zone_no, log_off);\n\t\t\tnew_blk  = xd_get_unused_block(chip, zone_no);\n\t\t\tif (old_blk == BLK_NOT_FOUND ||\n\t\t\t    new_blk == BLK_NOT_FOUND) {\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\tretval = xd_prepare_write(chip, old_blk, new_blk,\n\t\t\t\t\t\t  log_blk, start_page);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tif (detect_card_cd(chip, XD_CARD) !=\n\t\t\t\t\tSTATUS_SUCCESS) {\n\t\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t\t       SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t\t}\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n#ifdef XD_DELAY_WRITE\n\t\t}\n#endif\n\t} else {\n#ifdef XD_DELAY_WRITE\n\t\tretval = xd_delay_write(chip);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n#endif\n\n\t\told_blk = xd_get_l2p_tbl(chip, zone_no, log_off);\n\t\tif (old_blk == BLK_NOT_FOUND) {\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\tdev_dbg(rtsx_dev(chip), \"old_blk = 0x%x\\n\", old_blk);\n\n\twhile (total_sec_cnt) {\n\t\tif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\n\t\t\tchip->card_fail |= XD_CARD;\n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tif ((start_page + total_sec_cnt) > (xd_card->page_off + 1))\n\t\t\tend_page = xd_card->page_off + 1;\n\t\telse\n\t\t\tend_page = start_page + (u8)total_sec_cnt;\n\n\t\tpage_cnt = end_page - start_page;\n\t\tif (srb->sc_data_direction == DMA_FROM_DEVICE) {\n\t\t\tretval = xd_read_multiple_pages(chip, old_blk, log_blk,\n\t\t\t\t\t\t\tstart_page, end_page,\n\t\t\t\t\t\t\tptr, &index, &offset);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t} else {\n\t\t\tretval = xd_write_multiple_pages(chip, old_blk,\n\t\t\t\t\t\t\t new_blk, log_blk,\n\t\t\t\t\t\t\t start_page, end_page,\n\t\t\t\t\t\t\t ptr, &index, &offset);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t}\n\n\t\ttotal_sec_cnt -= page_cnt;\n\t\tif (scsi_sg_count(srb) == 0)\n\t\t\tptr += page_cnt * 512;\n\n\t\tif (total_sec_cnt == 0)\n\t\t\tbreak;\n\n\t\tlog_blk++;\n\t\tzone_no = (int)(log_blk / 1000);\n\t\tlog_off = (u16)(log_blk % 1000);\n\n\t\tif (xd_card->zone[zone_no].build_flag == 0) {\n\t\t\tretval = xd_build_l2p_tbl(chip, zone_no);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tchip->card_fail |= XD_CARD;\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t}\n\n\t\told_blk = xd_get_l2p_tbl(chip, zone_no, log_off);\n\t\tif (old_blk == BLK_NOT_FOUND) {\n\t\t\tif (srb->sc_data_direction == DMA_FROM_DEVICE)\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\t\telse\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tif (srb->sc_data_direction == DMA_TO_DEVICE) {\n\t\t\tnew_blk = xd_get_unused_block(chip, zone_no);\n\t\t\tif (new_blk == BLK_NOT_FOUND) {\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t}\n\n\t\tstart_page = 0;\n\t}\n\n\tif (srb->sc_data_direction == DMA_TO_DEVICE &&\n\t    (end_page != (xd_card->page_off + 1))) {\n#ifdef XD_DELAY_WRITE\n\t\tdelay_write->delay_write_flag = 1;\n\t\tdelay_write->old_phyblock = old_blk;\n\t\tdelay_write->new_phyblock = new_blk;\n\t\tdelay_write->logblock = log_blk;\n\t\tdelay_write->pageoff = end_page;\n#else\n\t\tif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\n\t\t\tchip->card_fail |= XD_CARD;\n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tretval = xd_finish_write(chip, old_blk, new_blk,\n\t\t\t\t\t log_blk, end_page);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n#endif\n\t}\n\n\tscsi_set_resid(srb, 0);\n\n\treturn STATUS_SUCCESS;\n}\n\nvoid xd_free_l2p_tbl(struct rtsx_chip *chip)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tint i = 0;\n\n\tif (xd_card->zone) {\n\t\tfor (i = 0; i < xd_card->zone_cnt; i++) {\n\t\t\tvfree(xd_card->zone[i].l2p_table);\n\t\t\txd_card->zone[i].l2p_table = NULL;\n\t\t\tvfree(xd_card->zone[i].free_table);\n\t\t\txd_card->zone[i].free_table = NULL;\n\t\t}\n\t\tvfree(xd_card->zone);\n\t\txd_card->zone = NULL;\n\t}\n}\n\nvoid xd_cleanup_work(struct rtsx_chip *chip)\n{\n#ifdef XD_DELAY_WRITE\n\tstruct xd_info *xd_card = &chip->xd_card;\n\n\tif (xd_card->delay_write.delay_write_flag) {\n\t\tdev_dbg(rtsx_dev(chip), \"xD: delay write\\n\");\n\t\txd_delay_write(chip);\n\t\txd_card->cleanup_counter = 0;\n\t}\n#endif\n}\n\nint xd_power_off_card3v3(struct rtsx_chip *chip)\n{\n\tint retval;\n\n\tretval = disable_card_clock(chip, XD_CARD);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = rtsx_write_register(chip, CARD_OE, XD_OUTPUT_EN, 0);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!chip->ft2_fast_mode) {\n\t\tretval = card_power_off(chip, XD_CARD);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\twait_timeout(50);\n\t}\n\n\tif (chip->asic_code) {\n\t\tretval = xd_pull_ctl_disable(chip);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t} else {\n\t\tretval = rtsx_write_register(chip, FPGA_PULL_CTL, 0xFF, 0xDF);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nint release_xd_card(struct rtsx_chip *chip)\n{\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tint retval;\n\n\tchip->card_ready &= ~XD_CARD;\n\tchip->card_fail &= ~XD_CARD;\n\tchip->card_wp &= ~XD_CARD;\n\n\txd_card->delay_write.delay_write_flag = 0;\n\n\txd_free_l2p_tbl(chip);\n\n\tretval = xd_power_off_card3v3(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}