{
  "module_name": "rtsx_chip.c",
  "hash_id": "67b50080d89a4d1126fd3aac9b523d4e943c6a6987378e2df1d94f5ebd4af16b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rts5208/rtsx_chip.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n\n#include \"rtsx.h\"\n#include \"sd.h\"\n#include \"xd.h\"\n#include \"ms.h\"\n\nstatic void rtsx_calibration(struct rtsx_chip *chip)\n{\n\trtsx_write_phy_register(chip, 0x1B, 0x135E);\n\twait_timeout(10);\n\trtsx_write_phy_register(chip, 0x00, 0x0280);\n\trtsx_write_phy_register(chip, 0x01, 0x7112);\n\trtsx_write_phy_register(chip, 0x01, 0x7110);\n\trtsx_write_phy_register(chip, 0x01, 0x7112);\n\trtsx_write_phy_register(chip, 0x01, 0x7113);\n\trtsx_write_phy_register(chip, 0x00, 0x0288);\n}\n\nvoid rtsx_enable_card_int(struct rtsx_chip *chip)\n{\n\tu32 reg = rtsx_readl(chip, RTSX_BIER);\n\tint i;\n\n\tfor (i = 0; i <= chip->max_lun; i++) {\n\t\tif (chip->lun2card[i] & XD_CARD)\n\t\t\treg |= XD_INT_EN;\n\t\tif (chip->lun2card[i] & SD_CARD)\n\t\t\treg |= SD_INT_EN;\n\t\tif (chip->lun2card[i] & MS_CARD)\n\t\t\treg |= MS_INT_EN;\n\t}\n\tif (chip->hw_bypass_sd)\n\t\treg &= ~((u32)SD_INT_EN);\n\n\trtsx_writel(chip, RTSX_BIER, reg);\n}\n\nvoid rtsx_enable_bus_int(struct rtsx_chip *chip)\n{\n\tu32 reg = 0;\n#ifndef DISABLE_CARD_INT\n\tint i;\n#endif\n\n\treg = TRANS_OK_INT_EN | TRANS_FAIL_INT_EN;\n\n#ifndef DISABLE_CARD_INT\n\tfor (i = 0; i <= chip->max_lun; i++) {\n\t\tdev_dbg(rtsx_dev(chip), \"lun2card[%d] = 0x%02x\\n\",\n\t\t\ti, chip->lun2card[i]);\n\n\t\tif (chip->lun2card[i] & XD_CARD)\n\t\t\treg |= XD_INT_EN;\n\t\tif (chip->lun2card[i] & SD_CARD)\n\t\t\treg |= SD_INT_EN;\n\t\tif (chip->lun2card[i] & MS_CARD)\n\t\t\treg |= MS_INT_EN;\n\t}\n\tif (chip->hw_bypass_sd)\n\t\treg &= ~((u32)SD_INT_EN);\n#endif\n\n\tif (chip->ic_version >= IC_VER_C)\n\t\treg |= DELINK_INT_EN;\n#ifdef SUPPORT_OCP\n\treg |= OC_INT_EN;\n#endif\n\tif (!chip->adma_mode)\n\t\treg |= DATA_DONE_INT_EN;\n\n\t \n\trtsx_writel(chip, RTSX_BIER, reg);\n\n\tdev_dbg(rtsx_dev(chip), \"RTSX_BIER: 0x%08x\\n\", reg);\n}\n\nvoid rtsx_disable_bus_int(struct rtsx_chip *chip)\n{\n\trtsx_writel(chip, RTSX_BIER, 0);\n}\n\nstatic int rtsx_pre_handle_sdio_old(struct rtsx_chip *chip)\n{\n\tint retval;\n\n\tif (chip->ignore_sd && CHK_SDIO_EXIST(chip)) {\n\t\tif (chip->asic_code) {\n\t\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL5,\n\t\t\t\t\t\t     0xFF,\n\t\t\t\t\t\t     MS_INS_PU | SD_WP_PU |\n\t\t\t\t\t\t     SD_CD_PU | SD_CMD_PU);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\tretval = rtsx_write_register(chip, FPGA_PULL_CTL,\n\t\t\t\t\t\t     0xFF,\n\t\t\t\t\t\t     FPGA_SD_PULL_CTL_EN);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tretval = rtsx_write_register(chip, CARD_SHARE_MODE, 0xFF,\n\t\t\t\t\t     CARD_SHARE_48_SD);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\t \n\t\tretval = rtsx_write_register(chip, 0xFF2C, 0x01, 0x01);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tretval = rtsx_write_register(chip, SDIO_CTRL, 0xFF,\n\t\t\t\t\t     SDIO_BUS_CTRL | SDIO_CD_CTRL);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tchip->sd_int = 1;\n\t\tchip->sd_io = 1;\n\t} else {\n\t\tchip->need_reset |= SD_CARD;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\n#ifdef HW_AUTO_SWITCH_SD_BUS\nstatic int rtsx_pre_handle_sdio_new(struct rtsx_chip *chip)\n{\n\tu8 tmp;\n\tbool sw_bypass_sd = false;\n\tint retval;\n\n\tif (chip->driver_first_load) {\n\t\tif (CHECK_PID(chip, 0x5288)) {\n\t\t\tretval = rtsx_read_register(chip, 0xFE5A, &tmp);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t\tif (tmp & 0x08)\n\t\t\t\tsw_bypass_sd = true;\n\t\t} else if (CHECK_PID(chip, 0x5208)) {\n\t\t\tretval = rtsx_read_register(chip, 0xFE70, &tmp);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t\tif (tmp & 0x80)\n\t\t\t\tsw_bypass_sd = true;\n\t\t}\n\t} else {\n\t\tif (chip->sdio_in_charge)\n\t\t\tsw_bypass_sd = true;\n\t}\n\tdev_dbg(rtsx_dev(chip), \"chip->sdio_in_charge = %d\\n\",\n\t\tchip->sdio_in_charge);\n\tdev_dbg(rtsx_dev(chip), \"chip->driver_first_load = %d\\n\",\n\t\tchip->driver_first_load);\n\tdev_dbg(rtsx_dev(chip), \"sw_bypass_sd = %d\\n\",\n\t\tsw_bypass_sd);\n\n\tif (sw_bypass_sd) {\n\t\tu8 cd_toggle_mask = 0;\n\n\t\tretval = rtsx_read_register(chip, TLPTISTAT, &tmp);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tcd_toggle_mask = 0x08;\n\n\t\tif (tmp & cd_toggle_mask) {\n\t\t\t \n\t\t\tif (CHECK_PID(chip, 0x5288)) {\n\t\t\t\tretval = rtsx_write_register(chip, 0xFE5A,\n\t\t\t\t\t\t\t     0x08, 0x00);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t} else if (CHECK_PID(chip, 0x5208)) {\n\t\t\t\tretval = rtsx_write_register(chip, 0xFE70,\n\t\t\t\t\t\t\t     0x80, 0x00);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t}\n\n\t\t\tretval = rtsx_write_register(chip, TLPTISTAT, 0xFF,\n\t\t\t\t\t\t     tmp);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\n\t\t\tchip->need_reset |= SD_CARD;\n\t\t} else {\n\t\t\tdev_dbg(rtsx_dev(chip), \"Chip inserted with SDIO!\\n\");\n\n\t\t\tif (chip->asic_code) {\n\t\t\t\tretval = sd_pull_ctl_enable(chip);\n\t\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t} else {\n\t\t\t\tretval = rtsx_write_register\n\t\t\t\t\t\t(chip, FPGA_PULL_CTL,\n\t\t\t\t\t\t FPGA_SD_PULL_CTL_BIT | 0x20,\n\t\t\t\t\t\t 0);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t}\n\t\t\tretval = card_share_mode(chip, SD_CARD);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\n\t\t\t \n\t\t\tif (CHECK_PID(chip, 0x5288)) {\n\t\t\t\tretval = rtsx_write_register(chip, 0xFE5A,\n\t\t\t\t\t\t\t     0x08, 0x08);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t} else if (CHECK_PID(chip, 0x5208)) {\n\t\t\t\tretval = rtsx_write_register(chip, 0xFE70,\n\t\t\t\t\t\t\t     0x80, 0x80);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t}\n\n\t\t\tchip->chip_insert_with_sdio = 1;\n\t\t\tchip->sd_io = 1;\n\t\t}\n\t} else {\n\t\tretval = rtsx_write_register(chip, TLPTISTAT, 0x08, 0x08);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tchip->need_reset |= SD_CARD;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n#endif\n\nstatic int rtsx_reset_aspm(struct rtsx_chip *chip)\n{\n\tint ret;\n\n\tif (chip->dynamic_aspm) {\n\t\tif (!CHK_SDIO_EXIST(chip) || !CHECK_PID(chip, 0x5288))\n\t\t\treturn STATUS_SUCCESS;\n\n\t\tret = rtsx_write_cfg_dw(chip, 2, 0xC0, 0xFF,\n\t\t\t\t\tchip->aspm_l0s_l1_en);\n\t\tif (ret != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\treturn STATUS_SUCCESS;\n\t}\n\n\tif (CHECK_PID(chip, 0x5208)) {\n\t\tret = rtsx_write_register(chip, ASPM_FORCE_CTL, 0xFF, 0x3F);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tret = rtsx_write_config_byte(chip, LCTLR, chip->aspm_l0s_l1_en);\n\tif (ret != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tchip->aspm_level[0] = chip->aspm_l0s_l1_en;\n\tif (CHK_SDIO_EXIST(chip)) {\n\t\tchip->aspm_level[1] = chip->aspm_l0s_l1_en;\n\t\tret = rtsx_write_cfg_dw(chip, CHECK_PID(chip, 0x5288) ? 2 : 1,\n\t\t\t\t\t0xC0, 0xFF, chip->aspm_l0s_l1_en);\n\t\tif (ret != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\tchip->aspm_enabled = 1;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int rtsx_enable_pcie_intr(struct rtsx_chip *chip)\n{\n\tint ret;\n\n\tif (!chip->asic_code || !CHECK_PID(chip, 0x5208)) {\n\t\trtsx_enable_bus_int(chip);\n\t\treturn STATUS_SUCCESS;\n\t}\n\n\tif (chip->phy_debug_mode) {\n\t\tret = rtsx_write_register(chip, CDRESUMECTL, 0x77, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\trtsx_disable_bus_int(chip);\n\t} else {\n\t\trtsx_enable_bus_int(chip);\n\t}\n\n\tif (chip->ic_version >= IC_VER_D) {\n\t\tu16 reg;\n\n\t\tret = rtsx_read_phy_register(chip, 0x00, &reg);\n\t\tif (ret != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\treg &= 0xFE7F;\n\t\treg |= 0x80;\n\t\tret = rtsx_write_phy_register(chip, 0x00, reg);\n\t\tif (ret != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tret = rtsx_read_phy_register(chip, 0x1C, &reg);\n\t\tif (ret != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\treg &= 0xFFF7;\n\t\tret = rtsx_write_phy_register(chip, 0x1C, reg);\n\t\tif (ret != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\tif (chip->driver_first_load && chip->ic_version < IC_VER_C)\n\t\trtsx_calibration(chip);\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_reset_chip(struct rtsx_chip *chip)\n{\n\tint retval;\n\n\trtsx_writel(chip, RTSX_HCBAR, chip->host_cmds_addr);\n\n\trtsx_disable_aspm(chip);\n\n\tretval = rtsx_write_register(chip, HOST_SLEEP_STATE, 0x03, 0x00);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tretval = rtsx_write_register(chip, CARD_CLK_EN, 0x1E, 0);\n\tif (retval)\n\t\treturn retval;\n\n#ifdef SUPPORT_OCP\n\t \n\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\n\t\tretval = rtsx_write_register(chip, FPDCTL, OC_POWER_DOWN, 0);\n\t\tif (retval)\n\t\t\treturn retval;\n\t} else {\n\t\tretval = rtsx_write_register(chip, FPDCTL, OC_POWER_DOWN,\n\t\t\t\t\t     MS_OC_POWER_DOWN);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tretval = rtsx_write_register(chip, OCPPARA1, OCP_TIME_MASK,\n\t\t\t\t     OCP_TIME_800);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, OCPPARA2, OCP_THD_MASK,\n\t\t\t\t     OCP_THD_244_946);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, OCPCTL, 0xFF,\n\t\t\t\t     CARD_OC_INT_EN | CARD_DETECT_EN);\n\tif (retval)\n\t\treturn retval;\n#else\n\t \n\tretval = rtsx_write_register(chip, FPDCTL, OC_POWER_DOWN,\n\t\t\t\t     OC_POWER_DOWN);\n\tif (retval)\n\t\treturn retval;\n#endif\n\n\tif (!CHECK_PID(chip, 0x5288)) {\n\t\tretval = rtsx_write_register(chip, CARD_GPIO_DIR, 0xFF, 0x03);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t \n\tretval = rtsx_write_register(chip, CARD_GPIO, 0xFF, 0x03);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tretval = rtsx_write_register(chip, CHANGE_LINK_STATE, 0x0A, 0);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tretval = rtsx_write_register(chip, CARD_DRIVE_SEL, 0xFF,\n\t\t\t\t     chip->card_drive_sel);\n\tif (retval)\n\t\treturn retval;\n\n#ifdef LED_AUTO_BLINK\n\tretval = rtsx_write_register(chip, CARD_AUTO_BLINK, 0xFF,\n\t\t\t\t     LED_BLINK_SPEED | BLINK_EN | LED_GPIO0);\n\tif (retval)\n\t\treturn retval;\n#endif\n\n\tif (chip->asic_code) {\n\t\t \n\t\tretval = rtsx_write_register(chip, SSC_CTL1, 0xFF,\n\t\t\t\t\t     SSC_8X_EN | SSC_SEL_4M);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = rtsx_write_register(chip, SSC_CTL2, 0xFF, 0x12);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t \n\tretval = rtsx_write_register(chip, CHANGE_LINK_STATE, 0x16, 0x10);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tif (chip->aspm_l0s_l1_en) {\n\t\tretval = rtsx_reset_aspm(chip);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t} else {\n\t\tif (chip->asic_code && CHECK_PID(chip, 0x5208)) {\n\t\t\tretval = rtsx_write_phy_register(chip, 0x07, 0x0129);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\t\t}\n\t\tretval = rtsx_write_config_byte(chip, LCTLR,\n\t\t\t\t\t\tchip->aspm_l0s_l1_en);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = rtsx_write_config_byte(chip, 0x81, 1);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (CHK_SDIO_EXIST(chip)) {\n\t\tretval = rtsx_write_cfg_dw(chip,\n\t\t\t\t\t   CHECK_PID(chip, 0x5288) ? 2 : 1,\n\t\t\t\t\t   0xC0, 0xFF00, 0x0100);\n\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\tif (CHECK_PID(chip, 0x5288) && !CHK_SDIO_EXIST(chip)) {\n\t\tretval = rtsx_write_cfg_dw(chip, 2, 0xC0, 0xFFFF, 0x0103);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = rtsx_write_cfg_dw(chip, 2, 0x84, 0xFF, 0x03);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = rtsx_write_register(chip, IRQSTAT0, LINK_RDY_INT,\n\t\t\t\t     LINK_RDY_INT);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = rtsx_write_register(chip, PERST_GLITCH_WIDTH, 0xFF, 0x80);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = rtsx_enable_pcie_intr(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tchip->need_reset = 0;\n\n\tchip->int_reg = rtsx_readl(chip, RTSX_BIPR);\n\n\tif (chip->hw_bypass_sd)\n\t\tgoto nextcard;\n\tdev_dbg(rtsx_dev(chip), \"In %s, chip->int_reg = 0x%x\\n\", __func__,\n\t\tchip->int_reg);\n\tif (chip->int_reg & SD_EXIST) {\n#ifdef HW_AUTO_SWITCH_SD_BUS\n\t\tif (CHECK_PID(chip, 0x5208) && chip->ic_version < IC_VER_C)\n\t\t\tretval = rtsx_pre_handle_sdio_old(chip);\n\t\telse\n\t\t\tretval = rtsx_pre_handle_sdio_new(chip);\n\n\t\tdev_dbg(rtsx_dev(chip), \"chip->need_reset = 0x%x (%s)\\n\",\n\t\t\t(unsigned int)(chip->need_reset), __func__);\n#else   \n\t\tretval = rtsx_pre_handle_sdio_old(chip);\n#endif   \n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t} else {\n\t\tchip->sd_io = 0;\n\t\tretval = rtsx_write_register(chip, SDIO_CTRL,\n\t\t\t\t\t     SDIO_BUS_CTRL | SDIO_CD_CTRL, 0);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\nnextcard:\n\tif (chip->int_reg & XD_EXIST)\n\t\tchip->need_reset |= XD_CARD;\n\tif (chip->int_reg & MS_EXIST)\n\t\tchip->need_reset |= MS_CARD;\n\tif (chip->int_reg & CARD_EXIST) {\n\t\tretval = rtsx_write_register(chip, SSC_CTL1, SSC_RSTB,\n\t\t\t\t\t     SSC_RSTB);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tdev_dbg(rtsx_dev(chip), \"In %s, chip->need_reset = 0x%x\\n\", __func__,\n\t\t(unsigned int)(chip->need_reset));\n\n\tretval = rtsx_write_register(chip, RCCTL, 0x01, 0x00);\n\tif (retval)\n\t\treturn retval;\n\n\tif (CHECK_PID(chip, 0x5208) || CHECK_PID(chip, 0x5288)) {\n\t\t \n\t\tretval = rtsx_write_register(chip, MAIN_PWR_OFF_CTL, 0x03,\n\t\t\t\t\t     0x03);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tif (chip->remote_wakeup_en && !chip->auto_delink_en) {\n\t\tretval = rtsx_write_register(chip, WAKE_SEL_CTL, 0x07, 0x07);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tif (chip->aux_pwr_exist) {\n\t\t\tretval = rtsx_write_register(chip, PME_FORCE_CTL,\n\t\t\t\t\t\t     0xFF, 0x33);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t} else {\n\t\tretval = rtsx_write_register(chip, WAKE_SEL_CTL, 0x07, 0x04);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = rtsx_write_register(chip, PME_FORCE_CTL, 0xFF, 0x30);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tif (CHECK_PID(chip, 0x5208) && chip->ic_version >= IC_VER_D) {\n\t\tretval = rtsx_write_register(chip, PETXCFG, 0x1C, 0x14);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tif (chip->asic_code && CHECK_PID(chip, 0x5208)) {\n\t\tretval = rtsx_clr_phy_reg_bit(chip, 0x1C, 2);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\tif (chip->ft2_fast_mode) {\n\t\tretval = rtsx_write_register(chip, CARD_PWR_CTL, 0xFF,\n\t\t\t\t\t     MS_PARTIAL_POWER_ON |\n\t\t\t\t\t     SD_PARTIAL_POWER_ON);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tudelay(chip->pmos_pwr_on_interval);\n\t\tretval = rtsx_write_register(chip, CARD_PWR_CTL, 0xFF,\n\t\t\t\t\t     MS_POWER_ON | SD_POWER_ON);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\twait_timeout(200);\n\t}\n\n\t \n\trtsx_reset_detected_cards(chip, 0);\n\n\tchip->driver_first_load = 0;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic inline int valid_sd_speed_prior(u32 sd_speed_prior)\n{\n\tbool valid_para = true;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tu8 tmp = (u8)(sd_speed_prior >> (i * 8));\n\n\t\tif (tmp < 0x01 || tmp > 0x04) {\n\t\t\tvalid_para = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn valid_para;\n}\n\nstatic inline int valid_sd_current_prior(u32 sd_current_prior)\n{\n\tbool valid_para = true;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tu8 tmp = (u8)(sd_current_prior >> (i * 8));\n\n\t\tif (tmp > 0x03) {\n\t\t\tvalid_para = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn valid_para;\n}\n\nstatic int rts5208_init(struct rtsx_chip *chip)\n{\n\tint retval;\n\tu16 reg = 0;\n\tu8 val = 0;\n\n\tretval = rtsx_write_register(chip, CLK_SEL, 0x03, 0x03);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_read_register(chip, CLK_SEL, &val);\n\tif (retval)\n\t\treturn retval;\n\tchip->asic_code = val == 0 ? 1 : 0;\n\n\tif (chip->asic_code) {\n\t\tretval = rtsx_read_phy_register(chip, 0x1C, &reg);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tdev_dbg(rtsx_dev(chip), \"Value of phy register 0x1C is 0x%x\\n\",\n\t\t\treg);\n\t\tchip->ic_version = (reg >> 4) & 0x07;\n\t\tchip->phy_debug_mode = reg & PHY_DEBUG_MODE ? 1 : 0;\n\n\t} else {\n\t\tretval = rtsx_read_register(chip, 0xFE80, &val);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tchip->ic_version = val;\n\t\tchip->phy_debug_mode = 0;\n\t}\n\n\tretval = rtsx_read_register(chip, PDINFO, &val);\n\tif (retval)\n\t\treturn retval;\n\tdev_dbg(rtsx_dev(chip), \"PDINFO: 0x%x\\n\", val);\n\tchip->aux_pwr_exist = val & AUX_PWR_DETECTED ? 1 : 0;\n\n\tretval = rtsx_read_register(chip, 0xFE50, &val);\n\tif (retval)\n\t\treturn retval;\n\tchip->hw_bypass_sd = val & 0x01 ? 1 : 0;\n\n\trtsx_read_config_byte(chip, 0x0E, &val);\n\tif (val & 0x80)\n\t\tSET_SDIO_EXIST(chip);\n\telse\n\t\tCLR_SDIO_EXIST(chip);\n\n\tif (chip->use_hw_setting) {\n\t\tretval = rtsx_read_register(chip, CHANGE_LINK_STATE, &val);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tchip->auto_delink_en = val & 0x80 ? 1 : 0;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int rts5288_init(struct rtsx_chip *chip)\n{\n\tint retval;\n\tu8 val = 0, max_func;\n\tu32 lval = 0;\n\n\tretval = rtsx_write_register(chip, CLK_SEL, 0x03, 0x03);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_read_register(chip, CLK_SEL, &val);\n\tif (retval)\n\t\treturn retval;\n\tchip->asic_code = val == 0 ? 1 : 0;\n\n\tchip->ic_version = 0;\n\tchip->phy_debug_mode = 0;\n\n\tretval = rtsx_read_register(chip, PDINFO, &val);\n\tif (retval)\n\t\treturn retval;\n\tdev_dbg(rtsx_dev(chip), \"PDINFO: 0x%x\\n\", val);\n\tchip->aux_pwr_exist = val & AUX_PWR_DETECTED ? 1 : 0;\n\n\tretval = rtsx_read_register(chip, CARD_SHARE_MODE, &val);\n\tif (retval)\n\t\treturn retval;\n\tdev_dbg(rtsx_dev(chip), \"CARD_SHARE_MODE: 0x%x\\n\", val);\n\tchip->baro_pkg = val & 0x04 ? QFN : LQFP;\n\n\tretval = rtsx_read_register(chip, 0xFE5A, &val);\n\tif (retval)\n\t\treturn retval;\n\tchip->hw_bypass_sd = val & 0x10 ? 1 : 0;\n\n\tretval = rtsx_read_cfg_dw(chip, 0, 0x718, &lval);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tmax_func = (u8)((lval >> 29) & 0x07);\n\tdev_dbg(rtsx_dev(chip), \"Max function number: %d\\n\", max_func);\n\tif (max_func == 0x02)\n\t\tSET_SDIO_EXIST(chip);\n\telse\n\t\tCLR_SDIO_EXIST(chip);\n\n\tif (chip->use_hw_setting) {\n\t\tretval = rtsx_read_register(chip, CHANGE_LINK_STATE, &val);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tchip->auto_delink_en = val & 0x80 ? 1 : 0;\n\n\t\tif (CHECK_BARO_PKG(chip, LQFP))\n\t\t\tchip->lun_mode = SD_MS_1LUN;\n\t\telse\n\t\t\tchip->lun_mode = DEFAULT_SINGLE;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_init_chip(struct rtsx_chip *chip)\n{\n\tstruct sd_info *sd_card = &chip->sd_card;\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\tunsigned int i;\n\n\tdev_dbg(rtsx_dev(chip), \"Vendor ID: 0x%04x, Product ID: 0x%04x\\n\",\n\t\tchip->vendor_id, chip->product_id);\n\n\tchip->ic_version = 0;\n\n\tmemset(xd_card, 0, sizeof(struct xd_info));\n\tmemset(sd_card, 0, sizeof(struct sd_info));\n\tmemset(ms_card, 0, sizeof(struct ms_info));\n\n\tchip->xd_reset_counter = 0;\n\tchip->sd_reset_counter = 0;\n\tchip->ms_reset_counter = 0;\n\n\tchip->xd_show_cnt = MAX_SHOW_CNT;\n\tchip->sd_show_cnt = MAX_SHOW_CNT;\n\tchip->ms_show_cnt = MAX_SHOW_CNT;\n\n\tchip->sd_io = 0;\n\tchip->auto_delink_cnt = 0;\n\tchip->auto_delink_allowed = 1;\n\trtsx_set_stat(chip, RTSX_STAT_INIT);\n\n\tchip->aspm_enabled = 0;\n\tchip->chip_insert_with_sdio = 0;\n\tchip->sdio_aspm = 0;\n\tchip->sdio_idle = 0;\n\tchip->sdio_counter = 0;\n\tchip->cur_card = 0;\n\tchip->phy_debug_mode = 0;\n\tchip->sdio_func_exist = 0;\n\tmemset(chip->sdio_raw_data, 0, 12);\n\n\tfor (i = 0; i < MAX_ALLOWED_LUN_CNT; i++) {\n\t\tset_sense_type(chip, i, SENSE_TYPE_NO_SENSE);\n\t\tchip->rw_fail_cnt[i] = 0;\n\t}\n\n\tif (!valid_sd_speed_prior(chip->sd_speed_prior))\n\t\tchip->sd_speed_prior = 0x01040203;\n\n\tdev_dbg(rtsx_dev(chip), \"sd_speed_prior = 0x%08x\\n\",\n\t\tchip->sd_speed_prior);\n\n\tif (!valid_sd_current_prior(chip->sd_current_prior))\n\t\tchip->sd_current_prior = 0x00010203;\n\n\tdev_dbg(rtsx_dev(chip), \"sd_current_prior = 0x%08x\\n\",\n\t\tchip->sd_current_prior);\n\n\tif (chip->sd_ddr_tx_phase > 31 || chip->sd_ddr_tx_phase < 0)\n\t\tchip->sd_ddr_tx_phase = 0;\n\n\tif (chip->mmc_ddr_tx_phase > 31 || chip->mmc_ddr_tx_phase < 0)\n\t\tchip->mmc_ddr_tx_phase = 0;\n\n\tretval = rtsx_write_register(chip, FPDCTL, SSC_POWER_DOWN, 0);\n\tif (retval)\n\t\treturn retval;\n\twait_timeout(200);\n\tretval = rtsx_write_register(chip, CLK_DIV, 0x07, 0x07);\n\tif (retval)\n\t\treturn retval;\n\tdev_dbg(rtsx_dev(chip), \"chip->use_hw_setting = %d\\n\",\n\t\tchip->use_hw_setting);\n\n\tif (CHECK_PID(chip, 0x5208)) {\n\t\tretval = rts5208_init(chip);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t} else if (CHECK_PID(chip, 0x5288)) {\n\t\tretval = rts5288_init(chip);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\tif (chip->ss_en == 2)\n\t\tchip->ss_en = 0;\n\n\tdev_dbg(rtsx_dev(chip), \"chip->asic_code = %d\\n\", chip->asic_code);\n\tdev_dbg(rtsx_dev(chip), \"chip->ic_version = 0x%x\\n\", chip->ic_version);\n\tdev_dbg(rtsx_dev(chip), \"chip->phy_debug_mode = %d\\n\",\n\t\tchip->phy_debug_mode);\n\tdev_dbg(rtsx_dev(chip), \"chip->aux_pwr_exist = %d\\n\",\n\t\tchip->aux_pwr_exist);\n\tdev_dbg(rtsx_dev(chip), \"chip->sdio_func_exist = %d\\n\",\n\t\tchip->sdio_func_exist);\n\tdev_dbg(rtsx_dev(chip), \"chip->hw_bypass_sd = %d\\n\",\n\t\tchip->hw_bypass_sd);\n\tdev_dbg(rtsx_dev(chip), \"chip->aspm_l0s_l1_en = %d\\n\",\n\t\tchip->aspm_l0s_l1_en);\n\tdev_dbg(rtsx_dev(chip), \"chip->lun_mode = %d\\n\", chip->lun_mode);\n\tdev_dbg(rtsx_dev(chip), \"chip->auto_delink_en = %d\\n\",\n\t\tchip->auto_delink_en);\n\tdev_dbg(rtsx_dev(chip), \"chip->ss_en = %d\\n\", chip->ss_en);\n\tdev_dbg(rtsx_dev(chip), \"chip->baro_pkg = %d\\n\", chip->baro_pkg);\n\n\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\n\t\tchip->card2lun[SD_CARD] = 0;\n\t\tchip->card2lun[MS_CARD] = 1;\n\t\tchip->card2lun[XD_CARD] = 0xFF;\n\t\tchip->lun2card[0] = SD_CARD;\n\t\tchip->lun2card[1] = MS_CARD;\n\t\tchip->max_lun = 1;\n\t\tSET_SDIO_IGNORED(chip);\n\t} else if (CHECK_LUN_MODE(chip, SD_MS_1LUN)) {\n\t\tchip->card2lun[SD_CARD] = 0;\n\t\tchip->card2lun[MS_CARD] = 0;\n\t\tchip->card2lun[XD_CARD] = 0xFF;\n\t\tchip->lun2card[0] = SD_CARD | MS_CARD;\n\t\tchip->max_lun = 0;\n\t} else {\n\t\tchip->card2lun[XD_CARD] = 0;\n\t\tchip->card2lun[SD_CARD] = 0;\n\t\tchip->card2lun[MS_CARD] = 0;\n\t\tchip->lun2card[0] = XD_CARD | SD_CARD | MS_CARD;\n\t\tchip->max_lun = 0;\n\t}\n\n\tretval = rtsx_reset_chip(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nvoid rtsx_release_chip(struct rtsx_chip *chip)\n{\n\txd_free_l2p_tbl(chip);\n\tms_free_l2p_tbl(chip);\n\tchip->card_exist = 0;\n\tchip->card_ready = 0;\n}\n\n#if !defined(LED_AUTO_BLINK) && defined(REGULAR_BLINK)\nstatic inline void rtsx_blink_led(struct rtsx_chip *chip)\n{\n\tif (chip->card_exist && chip->blink_led) {\n\t\tif (chip->led_toggle_counter < LED_TOGGLE_INTERVAL) {\n\t\t\tchip->led_toggle_counter++;\n\t\t} else {\n\t\t\tchip->led_toggle_counter = 0;\n\t\t\ttoggle_gpio(chip, LED_GPIO);\n\t\t}\n\t}\n}\n#endif\n\nstatic void rtsx_monitor_aspm_config(struct rtsx_chip *chip)\n{\n\tbool reg_changed, maybe_support_aspm;\n\tu32 tmp = 0;\n\tu8 reg0 = 0, reg1 = 0;\n\n\tmaybe_support_aspm = false;\n\treg_changed = false;\n\trtsx_read_config_byte(chip, LCTLR, &reg0);\n\tif (chip->aspm_level[0] != reg0) {\n\t\treg_changed = true;\n\t\tchip->aspm_level[0] = reg0;\n\t}\n\tif (CHK_SDIO_EXIST(chip) && !CHK_SDIO_IGNORED(chip)) {\n\t\trtsx_read_cfg_dw(chip, 1, 0xC0, &tmp);\n\t\treg1 = (u8)tmp;\n\t\tif (chip->aspm_level[1] != reg1) {\n\t\t\treg_changed = true;\n\t\t\tchip->aspm_level[1] = reg1;\n\t\t}\n\n\t\tif ((reg0 & 0x03) && (reg1 & 0x03))\n\t\t\tmaybe_support_aspm = true;\n\n\t} else {\n\t\tif (reg0 & 0x03)\n\t\t\tmaybe_support_aspm = true;\n\t}\n\n\tif (reg_changed) {\n\t\tif (maybe_support_aspm)\n\t\t\tchip->aspm_l0s_l1_en = 0x03;\n\n\t\tdev_dbg(rtsx_dev(chip),\n\t\t\t\"aspm_level[0] = 0x%02x, aspm_level[1] = 0x%02x\\n\",\n\t\t\tchip->aspm_level[0], chip->aspm_level[1]);\n\n\t\tif (chip->aspm_l0s_l1_en) {\n\t\t\tchip->aspm_enabled = 1;\n\t\t} else {\n\t\t\tchip->aspm_enabled = 0;\n\t\t\tchip->sdio_aspm = 0;\n\t\t}\n\t\trtsx_write_register(chip, ASPM_FORCE_CTL, 0xFF,\n\t\t\t\t    0x30 | chip->aspm_level[0] |\n\t\t\t\t    (chip->aspm_level[1] << 2));\n\t}\n}\n\nstatic void rtsx_manage_ocp(struct rtsx_chip *chip)\n{\n#ifdef SUPPORT_OCP\n\tif (!chip->ocp_int)\n\t\treturn;\n\n\trtsx_read_register(chip, OCPSTAT, &chip->ocp_stat);\n\n\tif (chip->card_exist & SD_CARD)\n\t\tsd_power_off_card3v3(chip);\n\telse if (chip->card_exist & MS_CARD)\n\t\tms_power_off_card3v3(chip);\n\telse if (chip->card_exist & XD_CARD)\n\t\txd_power_off_card3v3(chip);\n\n\tchip->ocp_int = 0;\n#endif\n}\n\nstatic void rtsx_manage_sd_lock(struct rtsx_chip *chip)\n{\n#ifdef SUPPORT_SD_LOCK\n\tstruct sd_info *sd_card = &chip->sd_card;\n\tu8 val;\n\n\tif (!sd_card->sd_erase_status)\n\t\treturn;\n\n\tif (chip->card_exist & SD_CARD) {\n\t\trtsx_read_register(chip, 0xFD30, &val);\n\t\tif (val & 0x02) {\n\t\t\tsd_card->sd_erase_status = SD_NOT_ERASE;\n\t\t\tsd_card->sd_lock_notify = 1;\n\t\t\tchip->need_reinit |= SD_CARD;\n\t\t}\n\t} else {\n\t\tsd_card->sd_erase_status = SD_NOT_ERASE;\n\t}\n#endif\n}\n\nstatic bool rtsx_is_ss_allowed(struct rtsx_chip *chip)\n{\n\tu32 val;\n\n\tif (!chip->ss_en || CHECK_PID(chip, 0x5288))\n\t\treturn false;\n\n\tif (CHK_SDIO_EXIST(chip) && !CHK_SDIO_IGNORED(chip)) {\n\t\trtsx_read_cfg_dw(chip, 1, 0x04, &val);\n\t\tif (val & 0x07)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void rtsx_manage_ss(struct rtsx_chip *chip)\n{\n\tif (!rtsx_is_ss_allowed(chip) || chip->sd_io)\n\t\treturn;\n\n\tif (rtsx_get_stat(chip) != RTSX_STAT_IDLE) {\n\t\tchip->ss_counter = 0;\n\t\treturn;\n\t}\n\n\tif (chip->ss_counter < (chip->ss_idle_period / POLLING_INTERVAL))\n\t\tchip->ss_counter++;\n\telse\n\t\trtsx_exclusive_enter_ss(chip);\n}\n\nstatic void rtsx_manage_aspm(struct rtsx_chip *chip)\n{\n\tu8 data;\n\n\tif (!CHECK_PID(chip, 0x5208))\n\t\treturn;\n\n\trtsx_monitor_aspm_config(chip);\n\n#ifdef SUPPORT_SDIO_ASPM\n\tif (!CHK_SDIO_EXIST(chip) || CHK_SDIO_IGNORED(chip) ||\n\t    !chip->aspm_l0s_l1_en || !chip->dynamic_aspm)\n\t\treturn;\n\n\tif (chip->sd_io) {\n\t\tdynamic_configure_sdio_aspm(chip);\n\t\treturn;\n\t}\n\n\tif (chip->sdio_aspm)\n\t\treturn;\n\n\tdev_dbg(rtsx_dev(chip), \"SDIO enter ASPM!\\n\");\n\tdata = 0x30 | (chip->aspm_level[1] << 2);\n\trtsx_write_register(chip, ASPM_FORCE_CTL, 0xFC, data);\n\tchip->sdio_aspm = 1;\n#endif\n}\n\nstatic void rtsx_manage_idle(struct rtsx_chip *chip)\n{\n\tif (chip->idle_counter < IDLE_MAX_COUNT) {\n\t\tchip->idle_counter++;\n\t\treturn;\n\t}\n\n\tif (rtsx_get_stat(chip) == RTSX_STAT_IDLE)\n\t\treturn;\n\n\tdev_dbg(rtsx_dev(chip), \"Idle state!\\n\");\n\trtsx_set_stat(chip, RTSX_STAT_IDLE);\n\n#if !defined(LED_AUTO_BLINK) && defined(REGULAR_BLINK)\n\tchip->led_toggle_counter = 0;\n#endif\n\trtsx_force_power_on(chip, SSC_PDCTL);\n\n\tturn_off_led(chip, LED_GPIO);\n\n\tif (chip->auto_power_down && !chip->card_ready && !chip->sd_io)\n\t\trtsx_force_power_down(chip, SSC_PDCTL | OC_PDCTL);\n}\n\nstatic void rtsx_manage_2lun_mode(struct rtsx_chip *chip)\n{\n#ifdef SUPPORT_OCP\n\tu8 sd_oc, ms_oc;\n\n\tsd_oc = chip->ocp_stat & (SD_OC_NOW | SD_OC_EVER);\n\tms_oc = chip->ocp_stat & (MS_OC_NOW | MS_OC_EVER);\n\n\tif (sd_oc || ms_oc)\n\t\tdev_dbg(rtsx_dev(chip), \"Over current, OCPSTAT is 0x%x\\n\",\n\t\t\tchip->ocp_stat);\n\n\tif (sd_oc && (chip->card_exist & SD_CARD)) {\n\t\trtsx_write_register(chip, CARD_OE, SD_OUTPUT_EN, 0);\n\t\tcard_power_off(chip, SD_CARD);\n\t\tchip->card_fail |= SD_CARD;\n\t}\n\n\tif (ms_oc && (chip->card_exist & MS_CARD)) {\n\t\trtsx_write_register(chip, CARD_OE, MS_OUTPUT_EN, 0);\n\t\tcard_power_off(chip, MS_CARD);\n\t\tchip->card_fail |= MS_CARD;\n\t}\n#endif\n}\n\nstatic void rtsx_manage_1lun_mode(struct rtsx_chip *chip)\n{\n#ifdef SUPPORT_OCP\n\tif (!(chip->ocp_stat & (SD_OC_NOW | SD_OC_EVER)))\n\t\treturn;\n\n\tdev_dbg(rtsx_dev(chip), \"Over current, OCPSTAT is 0x%x\\n\",\n\t\tchip->ocp_stat);\n\n\tif (chip->card_exist & SD_CARD) {\n\t\trtsx_write_register(chip, CARD_OE, SD_OUTPUT_EN, 0);\n\t\tchip->card_fail |= SD_CARD;\n\t} else if (chip->card_exist & MS_CARD) {\n\t\trtsx_write_register(chip, CARD_OE, MS_OUTPUT_EN, 0);\n\t\tchip->card_fail |= MS_CARD;\n\t} else if (chip->card_exist & XD_CARD) {\n\t\trtsx_write_register(chip, CARD_OE, XD_OUTPUT_EN, 0);\n\t\tchip->card_fail |= XD_CARD;\n\t}\n\tcard_power_off(chip, SD_CARD);\n#endif\n}\n\nstatic void rtsx_delink_stage1(struct rtsx_chip *chip, int enter_L1,\n\t\t\t       int stage3_cnt)\n{\n\tu8 val;\n\n\trtsx_set_stat(chip, RTSX_STAT_DELINK);\n\n\tif (chip->asic_code && CHECK_PID(chip, 0x5208))\n\t\trtsx_set_phy_reg_bit(chip, 0x1C, 2);\n\n\tif (chip->card_exist)\n\t\tdev_dbg(rtsx_dev(chip), \"False card inserted, do force delink\\n\");\n\telse\n\t\tdev_dbg(rtsx_dev(chip), \"No card inserted, do delink\\n\");\n\n\tif (enter_L1)\n\t\trtsx_write_register(chip, HOST_SLEEP_STATE, 0x03, 1);\n\n\tif (chip->card_exist)\n\t\tval = 0x02;\n\telse\n\t\tval = 0x0A;\n\n\trtsx_write_register(chip, CHANGE_LINK_STATE, val, val);\n\n\tif (enter_L1)\n\t\trtsx_enter_L1(chip);\n\n\tif (chip->card_exist)\n\t\tchip->auto_delink_cnt = stage3_cnt + 1;\n}\n\nstatic void rtsx_delink_stage(struct rtsx_chip *chip)\n{\n\tint delink_stage1_cnt, delink_stage2_cnt, delink_stage3_cnt;\n\tint enter_L1;\n\n\tif (!chip->auto_delink_en || !chip->auto_delink_allowed ||\n\t    chip->card_ready || chip->card_ejected || chip->sd_io) {\n\t\tchip->auto_delink_cnt = 0;\n\t\treturn;\n\t}\n\n\tenter_L1 = chip->auto_delink_in_L1 &&\n\t\t(chip->aspm_l0s_l1_en || chip->ss_en);\n\n\tdelink_stage1_cnt = chip->delink_stage1_step;\n\tdelink_stage2_cnt = delink_stage1_cnt + chip->delink_stage2_step;\n\tdelink_stage3_cnt = delink_stage2_cnt + chip->delink_stage3_step;\n\n\tif (chip->auto_delink_cnt > delink_stage3_cnt)\n\t\treturn;\n\n\tif (chip->auto_delink_cnt == delink_stage1_cnt)\n\t\trtsx_delink_stage1(chip, enter_L1, delink_stage3_cnt);\n\n\tif (chip->auto_delink_cnt == delink_stage2_cnt) {\n\t\tdev_dbg(rtsx_dev(chip), \"Try to do force delink\\n\");\n\n\t\tif (enter_L1)\n\t\t\trtsx_exit_L1(chip);\n\n\t\tif (chip->asic_code && CHECK_PID(chip, 0x5208))\n\t\t\trtsx_set_phy_reg_bit(chip, 0x1C, 2);\n\n\t\trtsx_write_register(chip, CHANGE_LINK_STATE, 0x0A, 0x0A);\n\t}\n\n\tchip->auto_delink_cnt++;\n}\n\nvoid rtsx_polling_func(struct rtsx_chip *chip)\n{\n\tif (rtsx_chk_stat(chip, RTSX_STAT_SUSPEND))\n\t\treturn;\n\n\tif (rtsx_chk_stat(chip, RTSX_STAT_DELINK))\n\t\tgoto delink_stage;\n\n\tif (chip->polling_config) {\n\t\tu8 val;\n\n\t\trtsx_read_config_byte(chip, 0, &val);\n\t}\n\n\tif (rtsx_chk_stat(chip, RTSX_STAT_SS))\n\t\treturn;\n\n\trtsx_manage_ocp(chip);\n\n\trtsx_manage_sd_lock(chip);\n\n\trtsx_init_cards(chip);\n\n\trtsx_manage_ss(chip);\n\n\trtsx_manage_aspm(chip);\n\n\trtsx_manage_idle(chip);\n\n\tswitch (rtsx_get_stat(chip)) {\n\tcase RTSX_STAT_RUN:\n#if !defined(LED_AUTO_BLINK) && defined(REGULAR_BLINK)\n\t\trtsx_blink_led(chip);\n#endif\n\t\tdo_remaining_work(chip);\n\t\tbreak;\n\n\tcase RTSX_STAT_IDLE:\n\t\tif (chip->sd_io && !chip->sd_int)\n\t\t\ttry_to_switch_sdio_ctrl(chip);\n\n\t\trtsx_enable_aspm(chip);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN))\n\t\trtsx_manage_2lun_mode(chip);\n\telse\n\t\trtsx_manage_1lun_mode(chip);\n\ndelink_stage:\n\trtsx_delink_stage(chip);\n}\n\n \nvoid rtsx_stop_cmd(struct rtsx_chip *chip, int card)\n{\n\tint i;\n\n\tfor (i = 0; i <= 8; i++) {\n\t\tint addr = RTSX_HCBAR + i * 4;\n\t\tu32 reg;\n\n\t\treg = rtsx_readl(chip, addr);\n\t\tdev_dbg(rtsx_dev(chip), \"BAR (0x%02x): 0x%08x\\n\", addr, reg);\n\t}\n\trtsx_writel(chip, RTSX_HCBCTLR, STOP_CMD);\n\trtsx_writel(chip, RTSX_HDBCTLR, STOP_DMA);\n\n\tfor (i = 0; i < 16; i++) {\n\t\tu16 addr = 0xFE20 + (u16)i;\n\t\tu8 val;\n\n\t\trtsx_read_register(chip, addr, &val);\n\t\tdev_dbg(rtsx_dev(chip), \"0x%04X: 0x%02x\\n\", addr, val);\n\t}\n\n\trtsx_write_register(chip, DMACTL, 0x80, 0x80);\n\trtsx_write_register(chip, RBCTL, 0x80, 0x80);\n}\n\n#define MAX_RW_REG_CNT\t\t1024\n\nint rtsx_write_register(struct rtsx_chip *chip, u16 addr, u8 mask, u8 data)\n{\n\tint i;\n\tu32 val = 3 << 30;\n\n\tval |= (u32)(addr & 0x3FFF) << 16;\n\tval |= (u32)mask << 8;\n\tval |= (u32)data;\n\n\trtsx_writel(chip, RTSX_HAIMR, val);\n\n\tfor (i = 0; i < MAX_RW_REG_CNT; i++) {\n\t\tval = rtsx_readl(chip, RTSX_HAIMR);\n\t\tif ((val & BIT(31)) == 0) {\n\t\t\tif (data != (u8)val)\n\t\t\t\treturn STATUS_FAIL;\n\n\t\t\treturn STATUS_SUCCESS;\n\t\t}\n\t}\n\n\treturn STATUS_TIMEDOUT;\n}\n\nint rtsx_read_register(struct rtsx_chip *chip, u16 addr, u8 *data)\n{\n\tu32 val = 2 << 30;\n\tint i;\n\n\tif (data)\n\t\t*data = 0;\n\n\tval |= (u32)(addr & 0x3FFF) << 16;\n\n\trtsx_writel(chip, RTSX_HAIMR, val);\n\n\tfor (i = 0; i < MAX_RW_REG_CNT; i++) {\n\t\tval = rtsx_readl(chip, RTSX_HAIMR);\n\t\tif ((val & BIT(31)) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (i >= MAX_RW_REG_CNT)\n\t\treturn STATUS_TIMEDOUT;\n\n\tif (data)\n\t\t*data = (u8)(val & 0xFF);\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_write_cfg_dw(struct rtsx_chip *chip, u8 func_no, u16 addr, u32 mask,\n\t\t      u32 val)\n{\n\tint retval;\n\tu8 mode = 0, tmp;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (mask & 0xFF) {\n\t\t\tretval = rtsx_write_register(chip, CFGDATA0 + i,\n\t\t\t\t\t\t     0xFF,\n\t\t\t\t\t\t     (u8)(val & mask & 0xFF));\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t\tmode |= (1 << i);\n\t\t}\n\t\tmask >>= 8;\n\t\tval >>= 8;\n\t}\n\n\tif (mode) {\n\t\tretval = rtsx_write_register(chip, CFGADDR0, 0xFF, (u8)addr);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = rtsx_write_register(chip, CFGADDR1, 0xFF,\n\t\t\t\t\t     (u8)(addr >> 8));\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tretval = rtsx_write_register(chip, CFGRWCTL, 0xFF,\n\t\t\t\t\t     0x80 | mode |\n\t\t\t\t\t     ((func_no & 0x03) << 4));\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tfor (i = 0; i < MAX_RW_REG_CNT; i++) {\n\t\t\tretval = rtsx_read_register(chip, CFGRWCTL, &tmp);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t\tif ((tmp & 0x80) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_read_cfg_dw(struct rtsx_chip *chip, u8 func_no, u16 addr, u32 *val)\n{\n\tint retval;\n\tint i;\n\tu8 tmp;\n\tu32 data = 0;\n\n\tretval = rtsx_write_register(chip, CFGADDR0, 0xFF, (u8)addr);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, CFGADDR1, 0xFF, (u8)(addr >> 8));\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, CFGRWCTL, 0xFF,\n\t\t\t\t     0x80 | ((func_no & 0x03) << 4));\n\tif (retval)\n\t\treturn retval;\n\n\tfor (i = 0; i < MAX_RW_REG_CNT; i++) {\n\t\tretval = rtsx_read_register(chip, CFGRWCTL, &tmp);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tif ((tmp & 0x80) == 0)\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tretval = rtsx_read_register(chip, CFGDATA0 + i, &tmp);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tdata |= (u32)tmp << (i * 8);\n\t}\n\n\tif (val)\n\t\t*val = data;\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_write_cfg_seq(struct rtsx_chip *chip, u8 func, u16 addr, u8 *buf,\n\t\t       int len)\n{\n\tu32 *data, *mask;\n\tu16 offset = addr % 4;\n\tu16 aligned_addr = addr - offset;\n\tint dw_len, i, j;\n\tint retval;\n\tsize_t size;\n\n\tif (!buf)\n\t\treturn STATUS_NOMEM;\n\n\tif ((len + offset) % 4)\n\t\tdw_len = (len + offset) / 4 + 1;\n\telse\n\t\tdw_len = (len + offset) / 4;\n\n\tdev_dbg(rtsx_dev(chip), \"dw_len = %d\\n\", dw_len);\n\n\tsize = array_size(dw_len, 4);\n\tdata = vzalloc(size);\n\tif (!data)\n\t\treturn STATUS_NOMEM;\n\n\tmask = vzalloc(size);\n\tif (!mask) {\n\t\tvfree(data);\n\t\treturn STATUS_NOMEM;\n\t}\n\n\tj = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tmask[j] |= 0xFF << (offset * 8);\n\t\tdata[j] |= buf[i] << (offset * 8);\n\t\tif (++offset == 4) {\n\t\t\tj++;\n\t\t\toffset = 0;\n\t\t}\n\t}\n\n\tprint_hex_dump_bytes(KBUILD_MODNAME \": \", DUMP_PREFIX_NONE, mask, size);\n\tprint_hex_dump_bytes(KBUILD_MODNAME \": \", DUMP_PREFIX_NONE, data, size);\n\n\tfor (i = 0; i < dw_len; i++) {\n\t\tretval = rtsx_write_cfg_dw(chip, func, aligned_addr + i * 4,\n\t\t\t\t\t   mask[i], data[i]);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(data);\n\t\t\tvfree(mask);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\tvfree(data);\n\tvfree(mask);\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_read_cfg_seq(struct rtsx_chip *chip, u8 func, u16 addr, u8 *buf,\n\t\t      int len)\n{\n\tu32 *data;\n\tu16 offset = addr % 4;\n\tu16 aligned_addr = addr - offset;\n\tint dw_len, i, j;\n\tint retval;\n\n\tif ((len + offset) % 4)\n\t\tdw_len = (len + offset) / 4 + 1;\n\telse\n\t\tdw_len = (len + offset) / 4;\n\n\tdev_dbg(rtsx_dev(chip), \"dw_len = %d\\n\", dw_len);\n\n\tdata = vmalloc(array_size(dw_len, 4));\n\tif (!data)\n\t\treturn STATUS_NOMEM;\n\n\tfor (i = 0; i < dw_len; i++) {\n\t\tretval = rtsx_read_cfg_dw(chip, func, aligned_addr + i * 4,\n\t\t\t\t\t  data + i);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(data);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\tif (buf) {\n\t\tj = 0;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tbuf[i] = (u8)(data[j] >> (offset * 8));\n\t\t\tif (++offset == 4) {\n\t\t\t\tj++;\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvfree(data);\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_write_phy_register(struct rtsx_chip *chip, u8 addr, u16 val)\n{\n\tint retval;\n\tbool finished = false;\n\tint i;\n\tu8 tmp;\n\n\tretval = rtsx_write_register(chip, PHYDATA0, 0xFF, (u8)val);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, PHYDATA1, 0xFF, (u8)(val >> 8));\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, PHYADDR, 0xFF, addr);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, PHYRWCTL, 0xFF, 0x81);\n\tif (retval)\n\t\treturn retval;\n\n\tfor (i = 0; i < 100000; i++) {\n\t\tretval = rtsx_read_register(chip, PHYRWCTL, &tmp);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tif (!(tmp & 0x80)) {\n\t\t\tfinished = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!finished)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_read_phy_register(struct rtsx_chip *chip, u8 addr, u16 *val)\n{\n\tint retval;\n\tbool finished = false;\n\tint i;\n\tu16 data = 0;\n\tu8 tmp;\n\n\tretval = rtsx_write_register(chip, PHYADDR, 0xFF, addr);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, PHYRWCTL, 0xFF, 0x80);\n\tif (retval)\n\t\treturn retval;\n\n\tfor (i = 0; i < 100000; i++) {\n\t\tretval = rtsx_read_register(chip, PHYRWCTL, &tmp);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tif (!(tmp & 0x80)) {\n\t\t\tfinished = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!finished)\n\t\treturn STATUS_FAIL;\n\n\tretval = rtsx_read_register(chip, PHYDATA0, &tmp);\n\tif (retval)\n\t\treturn retval;\n\tdata = tmp;\n\tretval = rtsx_read_register(chip, PHYDATA1, &tmp);\n\tif (retval)\n\t\treturn retval;\n\tdata |= (u16)tmp << 8;\n\n\tif (val)\n\t\t*val = data;\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_read_efuse(struct rtsx_chip *chip, u8 addr, u8 *val)\n{\n\tint retval;\n\tint i;\n\tu8 data = 0;\n\n\tretval = rtsx_write_register(chip, EFUSE_CTRL, 0xFF, 0x80 | addr);\n\tif (retval)\n\t\treturn retval;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tretval = rtsx_read_register(chip, EFUSE_CTRL, &data);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tif (!(data & 0x80))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (data & 0x80)\n\t\treturn STATUS_TIMEDOUT;\n\n\tretval = rtsx_read_register(chip, EFUSE_DATA, &data);\n\tif (retval)\n\t\treturn retval;\n\tif (val)\n\t\t*val = data;\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_write_efuse(struct rtsx_chip *chip, u8 addr, u8 val)\n{\n\tint retval;\n\tint i, j;\n\tu8 data = 0, tmp = 0xFF;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (val & (u8)(1 << i))\n\t\t\tcontinue;\n\n\t\ttmp &= (~(u8)(1 << i));\n\t\tdev_dbg(rtsx_dev(chip), \"Write 0x%x to 0x%x\\n\", tmp, addr);\n\n\t\tretval = rtsx_write_register(chip, EFUSE_DATA, 0xFF, tmp);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = rtsx_write_register(chip, EFUSE_CTRL, 0xFF,\n\t\t\t\t\t     0xA0 | addr);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tfor (j = 0; j < 100; j++) {\n\t\t\tretval = rtsx_read_register(chip, EFUSE_CTRL, &data);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t\tif (!(data & 0x80))\n\t\t\t\tbreak;\n\t\t\twait_timeout(3);\n\t\t}\n\n\t\tif (data & 0x80)\n\t\t\treturn STATUS_TIMEDOUT;\n\n\t\twait_timeout(5);\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_clr_phy_reg_bit(struct rtsx_chip *chip, u8 reg, u8 bit)\n{\n\tint retval;\n\tu16 value;\n\n\tretval = rtsx_read_phy_register(chip, reg, &value);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (value & (1 << bit)) {\n\t\tvalue &= ~(1 << bit);\n\t\tretval = rtsx_write_phy_register(chip, reg, value);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_set_phy_reg_bit(struct rtsx_chip *chip, u8 reg, u8 bit)\n{\n\tint retval;\n\tu16 value;\n\n\tretval = rtsx_read_phy_register(chip, reg, &value);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif ((value & (1 << bit)) == 0) {\n\t\tvalue |= (1 << bit);\n\t\tretval = rtsx_write_phy_register(chip, reg, value);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic void rtsx_handle_pm_dstate(struct rtsx_chip *chip, u8 dstate)\n{\n\tu32 ultmp;\n\n\tdev_dbg(rtsx_dev(chip), \"%04x set pm_dstate to %d\\n\",\n\t\tchip->product_id, dstate);\n\n\tif (CHK_SDIO_EXIST(chip)) {\n\t\tu8 func_no;\n\n\t\tif (CHECK_PID(chip, 0x5288))\n\t\t\tfunc_no = 2;\n\t\telse\n\t\t\tfunc_no = 1;\n\n\t\trtsx_read_cfg_dw(chip, func_no, 0x84, &ultmp);\n\t\tdev_dbg(rtsx_dev(chip), \"pm_dstate of function %d: 0x%x\\n\",\n\t\t\t(int)func_no, ultmp);\n\t\trtsx_write_cfg_dw(chip, func_no, 0x84, 0xFF, dstate);\n\t}\n\n\trtsx_write_config_byte(chip, 0x44, dstate);\n\trtsx_write_config_byte(chip, 0x45, 0);\n}\n\nvoid rtsx_enter_L1(struct rtsx_chip *chip)\n{\n\trtsx_handle_pm_dstate(chip, 2);\n}\n\nvoid rtsx_exit_L1(struct rtsx_chip *chip)\n{\n\trtsx_write_config_byte(chip, 0x44, 0);\n\trtsx_write_config_byte(chip, 0x45, 0);\n}\n\nvoid rtsx_enter_ss(struct rtsx_chip *chip)\n{\n\tdev_dbg(rtsx_dev(chip), \"Enter Selective Suspend State!\\n\");\n\n\trtsx_write_register(chip, IRQSTAT0, LINK_RDY_INT, LINK_RDY_INT);\n\n\tif (chip->power_down_in_ss) {\n\t\trtsx_power_off_card(chip);\n\t\trtsx_force_power_down(chip, SSC_PDCTL | OC_PDCTL);\n\t}\n\n\tif (CHK_SDIO_EXIST(chip))\n\t\trtsx_write_cfg_dw(chip, CHECK_PID(chip, 0x5288) ? 2 : 1,\n\t\t\t\t  0xC0, 0xFF00, 0x0100);\n\n\tif (chip->auto_delink_en) {\n\t\trtsx_write_register(chip, HOST_SLEEP_STATE, 0x01, 0x01);\n\t} else {\n\t\tif (!chip->phy_debug_mode) {\n\t\t\tu32 tmp;\n\n\t\t\ttmp = rtsx_readl(chip, RTSX_BIER);\n\t\t\ttmp |= CARD_INT;\n\t\t\trtsx_writel(chip, RTSX_BIER, tmp);\n\t\t}\n\n\t\trtsx_write_register(chip, CHANGE_LINK_STATE, 0x02, 0);\n\t}\n\n\trtsx_enter_L1(chip);\n\n\tRTSX_CLR_DELINK(chip);\n\trtsx_set_stat(chip, RTSX_STAT_SS);\n}\n\nvoid rtsx_exit_ss(struct rtsx_chip *chip)\n{\n\tdev_dbg(rtsx_dev(chip), \"Exit Selective Suspend State!\\n\");\n\n\trtsx_exit_L1(chip);\n\n\tif (chip->power_down_in_ss) {\n\t\trtsx_force_power_on(chip, SSC_PDCTL | OC_PDCTL);\n\t\tudelay(1000);\n\t}\n\n\tif (RTSX_TST_DELINK(chip)) {\n\t\tchip->need_reinit = SD_CARD | MS_CARD | XD_CARD;\n\t\trtsx_reinit_cards(chip, 1);\n\t\tRTSX_CLR_DELINK(chip);\n\t} else if (chip->power_down_in_ss) {\n\t\tchip->need_reinit = SD_CARD | MS_CARD | XD_CARD;\n\t\trtsx_reinit_cards(chip, 0);\n\t}\n}\n\nint rtsx_pre_handle_interrupt(struct rtsx_chip *chip)\n{\n\tu32 status, int_enable;\n\tbool exit_ss = false;\n#ifdef SUPPORT_OCP\n\tu32 ocp_int = 0;\n\n\tocp_int = OC_INT;\n#endif\n\n\tif (chip->ss_en) {\n\t\tchip->ss_counter = 0;\n\t\tif (rtsx_get_stat(chip) == RTSX_STAT_SS) {\n\t\t\texit_ss = true;\n\t\t\trtsx_exit_L1(chip);\n\t\t\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\t\t}\n\t}\n\n\tint_enable = rtsx_readl(chip, RTSX_BIER);\n\tchip->int_reg = rtsx_readl(chip, RTSX_BIPR);\n\n\tif (((chip->int_reg & int_enable) == 0) ||\n\t    chip->int_reg == 0xFFFFFFFF)\n\t\treturn STATUS_FAIL;\n\n\tstatus = chip->int_reg &= (int_enable | 0x7FFFFF);\n\n\tif (status & CARD_INT) {\n\t\tchip->auto_delink_cnt = 0;\n\n\t\tif (status & SD_INT) {\n\t\t\tif (status & SD_EXIST) {\n\t\t\t\tset_bit(SD_NR, &chip->need_reset);\n\t\t\t} else {\n\t\t\t\tset_bit(SD_NR, &chip->need_release);\n\t\t\t\tchip->sd_reset_counter = 0;\n\t\t\t\tchip->sd_show_cnt = 0;\n\t\t\t\tclear_bit(SD_NR, &chip->need_reset);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (exit_ss && (status & SD_EXIST))\n\t\t\t\tset_bit(SD_NR, &chip->need_reinit);\n\t\t}\n\t\tif (!CHECK_PID(chip, 0x5288) || CHECK_BARO_PKG(chip, QFN)) {\n\t\t\tif (status & XD_INT) {\n\t\t\t\tif (status & XD_EXIST) {\n\t\t\t\t\tset_bit(XD_NR, &chip->need_reset);\n\t\t\t\t} else {\n\t\t\t\t\tset_bit(XD_NR, &chip->need_release);\n\t\t\t\t\tchip->xd_reset_counter = 0;\n\t\t\t\t\tchip->xd_show_cnt = 0;\n\t\t\t\t\tclear_bit(XD_NR, &chip->need_reset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (exit_ss && (status & XD_EXIST))\n\t\t\t\t\tset_bit(XD_NR, &chip->need_reinit);\n\t\t\t}\n\t\t}\n\t\tif (status & MS_INT) {\n\t\t\tif (status & MS_EXIST) {\n\t\t\t\tset_bit(MS_NR, &chip->need_reset);\n\t\t\t} else {\n\t\t\t\tset_bit(MS_NR, &chip->need_release);\n\t\t\t\tchip->ms_reset_counter = 0;\n\t\t\t\tchip->ms_show_cnt = 0;\n\t\t\t\tclear_bit(MS_NR, &chip->need_reset);\n\t\t\t}\n\t\t} else {\n\t\t\tif (exit_ss && (status & MS_EXIST))\n\t\t\t\tset_bit(MS_NR, &chip->need_reinit);\n\t\t}\n\t}\n\n#ifdef SUPPORT_OCP\n\tchip->ocp_int = ocp_int & status;\n#endif\n\n\tif (chip->sd_io && (chip->int_reg & DATA_DONE_INT))\n\t\tchip->int_reg &= ~(u32)DATA_DONE_INT;\n\n\treturn STATUS_SUCCESS;\n}\n\nvoid rtsx_do_before_power_down(struct rtsx_chip *chip, int pm_stat)\n{\n\tint retval;\n\n\tdev_dbg(rtsx_dev(chip), \"%s, pm_stat = %d\\n\", __func__, pm_stat);\n\n\trtsx_set_stat(chip, RTSX_STAT_SUSPEND);\n\n\tretval = rtsx_force_power_on(chip, SSC_PDCTL);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn;\n\n\trtsx_release_cards(chip);\n\trtsx_disable_bus_int(chip);\n\tturn_off_led(chip, LED_GPIO);\n\n#ifdef HW_AUTO_SWITCH_SD_BUS\n\tif (chip->sd_io) {\n\t\tchip->sdio_in_charge = 1;\n\t\tif (CHECK_PID(chip, 0x5208)) {\n\t\t\trtsx_write_register(chip, TLPTISTAT, 0x08, 0x08);\n\t\t\t \n\t\t\trtsx_write_register(chip, 0xFE70, 0x80, 0x80);\n\t\t} else if (CHECK_PID(chip, 0x5288)) {\n\t\t\trtsx_write_register(chip, TLPTISTAT, 0x08, 0x08);\n\t\t\t \n\t\t\trtsx_write_register(chip, 0xFE5A, 0x08, 0x08);\n\t\t}\n\t}\n#endif\n\n\tif (CHECK_PID(chip, 0x5208) && chip->ic_version >= IC_VER_D) {\n\t\t \n\t\trtsx_write_register(chip, PETXCFG, 0x08, 0x08);\n\t}\n\n\tif (pm_stat == PM_S1) {\n\t\tdev_dbg(rtsx_dev(chip), \"Host enter S1\\n\");\n\t\trtsx_write_register(chip, HOST_SLEEP_STATE, 0x03,\n\t\t\t\t    HOST_ENTER_S1);\n\t} else if (pm_stat == PM_S3) {\n\t\tif (chip->s3_pwr_off_delay > 0)\n\t\t\twait_timeout(chip->s3_pwr_off_delay);\n\n\t\tdev_dbg(rtsx_dev(chip), \"Host enter S3\\n\");\n\t\trtsx_write_register(chip, HOST_SLEEP_STATE, 0x03,\n\t\t\t\t    HOST_ENTER_S3);\n\t}\n\n\tif (chip->do_delink_before_power_down && chip->auto_delink_en)\n\t\trtsx_write_register(chip, CHANGE_LINK_STATE, 0x02, 2);\n\n\trtsx_force_power_down(chip, SSC_PDCTL | OC_PDCTL);\n\n\tchip->cur_clk = 0;\n\tchip->cur_card = 0;\n\tchip->card_exist = 0;\n}\n\nvoid rtsx_enable_aspm(struct rtsx_chip *chip)\n{\n\tif (chip->aspm_l0s_l1_en && chip->dynamic_aspm && !chip->aspm_enabled) {\n\t\tdev_dbg(rtsx_dev(chip), \"Try to enable ASPM\\n\");\n\t\tchip->aspm_enabled = 1;\n\n\t\tif (chip->asic_code && CHECK_PID(chip, 0x5208))\n\t\t\trtsx_write_phy_register(chip, 0x07, 0);\n\t\tif (CHECK_PID(chip, 0x5208)) {\n\t\t\trtsx_write_register(chip, ASPM_FORCE_CTL, 0xF3,\n\t\t\t\t\t    0x30 | chip->aspm_level[0]);\n\t\t} else {\n\t\t\trtsx_write_config_byte(chip, LCTLR,\n\t\t\t\t\t       chip->aspm_l0s_l1_en);\n\t\t}\n\n\t\tif (CHK_SDIO_EXIST(chip)) {\n\t\t\tu16 val = chip->aspm_l0s_l1_en | 0x0100;\n\n\t\t\trtsx_write_cfg_dw(chip, CHECK_PID(chip, 0x5288) ? 2 : 1,\n\t\t\t\t\t  0xC0, 0xFFF, val);\n\t\t}\n\t}\n}\n\nvoid rtsx_disable_aspm(struct rtsx_chip *chip)\n{\n\tif (CHECK_PID(chip, 0x5208))\n\t\trtsx_monitor_aspm_config(chip);\n\n\tif (chip->aspm_l0s_l1_en && chip->dynamic_aspm && chip->aspm_enabled) {\n\t\tdev_dbg(rtsx_dev(chip), \"Try to disable ASPM\\n\");\n\t\tchip->aspm_enabled = 0;\n\n\t\tif (chip->asic_code && CHECK_PID(chip, 0x5208))\n\t\t\trtsx_write_phy_register(chip, 0x07, 0x0129);\n\t\tif (CHECK_PID(chip, 0x5208))\n\t\t\trtsx_write_register(chip, ASPM_FORCE_CTL,\n\t\t\t\t\t    0xF3, 0x30);\n\t\telse\n\t\t\trtsx_write_config_byte(chip, LCTLR, 0x00);\n\n\t\twait_timeout(1);\n\t}\n}\n\nint rtsx_read_ppbuf(struct rtsx_chip *chip, u8 *buf, int buf_len)\n{\n\tint retval;\n\tint i, j;\n\tu16 reg_addr;\n\tu8 *ptr;\n\n\tif (!buf)\n\t\treturn STATUS_ERROR;\n\n\tptr = buf;\n\treg_addr = PPBUF_BASE2;\n\tfor (i = 0; i < buf_len / 256; i++) {\n\t\trtsx_init_cmd(chip);\n\n\t\tfor (j = 0; j < 256; j++)\n\t\t\trtsx_add_cmd(chip, READ_REG_CMD, reg_addr++, 0, 0);\n\n\t\tretval = rtsx_send_cmd(chip, 0, 250);\n\t\tif (retval < 0)\n\t\t\treturn STATUS_FAIL;\n\n\t\tmemcpy(ptr, rtsx_get_cmd_data(chip), 256);\n\t\tptr += 256;\n\t}\n\n\tif (buf_len % 256) {\n\t\trtsx_init_cmd(chip);\n\n\t\tfor (j = 0; j < buf_len % 256; j++)\n\t\t\trtsx_add_cmd(chip, READ_REG_CMD, reg_addr++, 0, 0);\n\n\t\tretval = rtsx_send_cmd(chip, 0, 250);\n\t\tif (retval < 0)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\tmemcpy(ptr, rtsx_get_cmd_data(chip), buf_len % 256);\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_write_ppbuf(struct rtsx_chip *chip, u8 *buf, int buf_len)\n{\n\tint retval;\n\tint i, j;\n\tu16 reg_addr;\n\tu8 *ptr;\n\n\tif (!buf)\n\t\treturn STATUS_ERROR;\n\n\tptr = buf;\n\treg_addr = PPBUF_BASE2;\n\tfor (i = 0; i < buf_len / 256; i++) {\n\t\trtsx_init_cmd(chip);\n\n\t\tfor (j = 0; j < 256; j++) {\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, reg_addr++, 0xFF,\n\t\t\t\t     *ptr);\n\t\t\tptr++;\n\t\t}\n\n\t\tretval = rtsx_send_cmd(chip, 0, 250);\n\t\tif (retval < 0)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\tif (buf_len % 256) {\n\t\trtsx_init_cmd(chip);\n\n\t\tfor (j = 0; j < buf_len % 256; j++) {\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, reg_addr++, 0xFF,\n\t\t\t\t     *ptr);\n\t\t\tptr++;\n\t\t}\n\n\t\tretval = rtsx_send_cmd(chip, 0, 250);\n\t\tif (retval < 0)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_check_chip_exist(struct rtsx_chip *chip)\n{\n\tif (rtsx_readl(chip, 0) == 0xFFFFFFFF)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_force_power_on(struct rtsx_chip *chip, u8 ctl)\n{\n\tint retval;\n\tu8 mask = 0;\n\n\tif (ctl & SSC_PDCTL)\n\t\tmask |= SSC_POWER_DOWN;\n\n#ifdef SUPPORT_OCP\n\tif (ctl & OC_PDCTL) {\n\t\tmask |= SD_OC_POWER_DOWN;\n\t\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN))\n\t\t\tmask |= MS_OC_POWER_DOWN;\n\t}\n#endif\n\n\tif (mask) {\n\t\tretval = rtsx_write_register(chip, FPDCTL, mask, 0);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tif (CHECK_PID(chip, 0x5288))\n\t\t\twait_timeout(200);\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nint rtsx_force_power_down(struct rtsx_chip *chip, u8 ctl)\n{\n\tint retval;\n\tu8 mask = 0, val = 0;\n\n\tif (ctl & SSC_PDCTL)\n\t\tmask |= SSC_POWER_DOWN;\n\n#ifdef SUPPORT_OCP\n\tif (ctl & OC_PDCTL) {\n\t\tmask |= SD_OC_POWER_DOWN;\n\t\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN))\n\t\t\tmask |= MS_OC_POWER_DOWN;\n\t}\n#endif\n\n\tif (mask) {\n\t\tval = mask;\n\t\tretval = rtsx_write_register(chip, FPDCTL, mask, val);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}