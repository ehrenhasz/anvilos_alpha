{
  "module_name": "rtsx_card.c",
  "hash_id": "dc17c37213aefeb022304090eceea332cff217d3324261a45fbca51a2fff4d27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rts5208/rtsx_card.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n\n#include \"rtsx.h\"\n#include \"sd.h\"\n#include \"xd.h\"\n#include \"ms.h\"\n\nvoid do_remaining_work(struct rtsx_chip *chip)\n{\n\tstruct sd_info *sd_card = &chip->sd_card;\n#ifdef XD_DELAY_WRITE\n\tstruct xd_info *xd_card = &chip->xd_card;\n#endif\n\tstruct ms_info *ms_card = &chip->ms_card;\n\n\tif (chip->card_ready & SD_CARD) {\n\t\tif (sd_card->seq_mode) {\n\t\t\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\t\t\tsd_card->cleanup_counter++;\n\t\t} else {\n\t\t\tsd_card->cleanup_counter = 0;\n\t\t}\n\t}\n\n#ifdef XD_DELAY_WRITE\n\tif (chip->card_ready & XD_CARD) {\n\t\tif (xd_card->delay_write.delay_write_flag) {\n\t\t\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\t\t\txd_card->cleanup_counter++;\n\t\t} else {\n\t\t\txd_card->cleanup_counter = 0;\n\t\t}\n\t}\n#endif\n\n\tif (chip->card_ready & MS_CARD) {\n\t\tif (CHK_MSPRO(ms_card)) {\n\t\t\tif (ms_card->seq_mode) {\n\t\t\t\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\t\t\t\tms_card->cleanup_counter++;\n\t\t\t} else {\n\t\t\t\tms_card->cleanup_counter = 0;\n\t\t\t}\n\t\t} else {\n#ifdef MS_DELAY_WRITE\n\t\t\tif (ms_card->delay_write.delay_write_flag) {\n\t\t\t\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\t\t\t\tms_card->cleanup_counter++;\n\t\t\t} else {\n\t\t\t\tms_card->cleanup_counter = 0;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\tif (sd_card->cleanup_counter > POLLING_WAIT_CNT)\n\t\tsd_cleanup_work(chip);\n\n\tif (xd_card->cleanup_counter > POLLING_WAIT_CNT)\n\t\txd_cleanup_work(chip);\n\n\tif (ms_card->cleanup_counter > POLLING_WAIT_CNT)\n\t\tms_cleanup_work(chip);\n}\n\nvoid try_to_switch_sdio_ctrl(struct rtsx_chip *chip)\n{\n\tu8 reg1 = 0, reg2 = 0;\n\n\trtsx_read_register(chip, 0xFF34, &reg1);\n\trtsx_read_register(chip, 0xFF38, &reg2);\n\tdev_dbg(rtsx_dev(chip), \"reg 0xFF34: 0x%x, reg 0xFF38: 0x%x\\n\",\n\t\treg1, reg2);\n\tif ((reg1 & 0xC0) && (reg2 & 0xC0)) {\n\t\tchip->sd_int = 1;\n\t\trtsx_write_register(chip, SDIO_CTRL, 0xFF,\n\t\t\t\t    SDIO_BUS_CTRL | SDIO_CD_CTRL);\n\t\trtsx_write_register(chip, PWR_GATE_CTRL,\n\t\t\t\t    LDO3318_PWR_MASK, LDO_ON);\n\t}\n}\n\n#ifdef SUPPORT_SDIO_ASPM\nvoid dynamic_configure_sdio_aspm(struct rtsx_chip *chip)\n{\n\tu8 buf[12], reg;\n\tint i;\n\n\tfor (i = 0; i < 12; i++)\n\t\trtsx_read_register(chip, 0xFF08 + i, &buf[i]);\n\trtsx_read_register(chip, 0xFF25, &reg);\n\tif ((memcmp(buf, chip->sdio_raw_data, 12) != 0) || (reg & 0x03)) {\n\t\tchip->sdio_counter = 0;\n\t\tchip->sdio_idle = 0;\n\t} else {\n\t\tif (!chip->sdio_idle) {\n\t\t\tchip->sdio_counter++;\n\t\t\tif (chip->sdio_counter >= SDIO_IDLE_COUNT) {\n\t\t\t\tchip->sdio_counter = 0;\n\t\t\t\tchip->sdio_idle = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemcpy(chip->sdio_raw_data, buf, 12);\n\n\tif (chip->sdio_idle) {\n\t\tif (!chip->sdio_aspm) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"SDIO enter ASPM!\\n\");\n\t\t\trtsx_write_register(chip, ASPM_FORCE_CTL, 0xFC,\n\t\t\t\t\t    0x30 | (chip->aspm_level[1] << 2));\n\t\t\tchip->sdio_aspm = 1;\n\t\t}\n\t} else {\n\t\tif (chip->sdio_aspm) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"SDIO exit ASPM!\\n\");\n\t\t\trtsx_write_register(chip, ASPM_FORCE_CTL, 0xFC, 0x30);\n\t\t\tchip->sdio_aspm = 0;\n\t\t}\n\t}\n}\n#endif\n\nvoid do_reset_sd_card(struct rtsx_chip *chip)\n{\n\tint retval;\n\n\tdev_dbg(rtsx_dev(chip), \"%s: %d, card2lun = 0x%x\\n\", __func__,\n\t\tchip->sd_reset_counter, chip->card2lun[SD_CARD]);\n\n\tif (chip->card2lun[SD_CARD] >= MAX_ALLOWED_LUN_CNT) {\n\t\tclear_bit(SD_NR, &chip->need_reset);\n\t\tchip->sd_reset_counter = 0;\n\t\tchip->sd_show_cnt = 0;\n\t\treturn;\n\t}\n\n\tchip->rw_fail_cnt[chip->card2lun[SD_CARD]] = 0;\n\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\trtsx_write_register(chip, SDIO_CTRL, 0xFF, 0);\n\n\tretval = reset_sd_card(chip);\n\tif (chip->need_release & SD_CARD)\n\t\treturn;\n\tif (retval == STATUS_SUCCESS) {\n\t\tclear_bit(SD_NR, &chip->need_reset);\n\t\tchip->sd_reset_counter = 0;\n\t\tchip->sd_show_cnt = 0;\n\t\tchip->card_ready |= SD_CARD;\n\t\tchip->card_fail &= ~SD_CARD;\n\t\tchip->rw_card[chip->card2lun[SD_CARD]] = sd_rw;\n\t} else {\n\t\tif (chip->sd_io || chip->sd_reset_counter >= MAX_RESET_CNT) {\n\t\t\tclear_bit(SD_NR, &chip->need_reset);\n\t\t\tchip->sd_reset_counter = 0;\n\t\t\tchip->sd_show_cnt = 0;\n\t\t} else {\n\t\t\tchip->sd_reset_counter++;\n\t\t}\n\t\tchip->card_ready &= ~SD_CARD;\n\t\tchip->card_fail |= SD_CARD;\n\t\tchip->capacity[chip->card2lun[SD_CARD]] = 0;\n\t\tchip->rw_card[chip->card2lun[SD_CARD]] = NULL;\n\n\t\trtsx_write_register(chip, CARD_OE, SD_OUTPUT_EN, 0);\n\t\tif (!chip->ft2_fast_mode)\n\t\t\tcard_power_off(chip, SD_CARD);\n\t\tif (chip->sd_io) {\n\t\t\tchip->sd_int = 0;\n\t\t\ttry_to_switch_sdio_ctrl(chip);\n\t\t} else {\n\t\t\tdisable_card_clock(chip, SD_CARD);\n\t\t}\n\t}\n}\n\nvoid do_reset_xd_card(struct rtsx_chip *chip)\n{\n\tint retval;\n\n\tdev_dbg(rtsx_dev(chip), \"%s: %d, card2lun = 0x%x\\n\", __func__,\n\t\tchip->xd_reset_counter, chip->card2lun[XD_CARD]);\n\n\tif (chip->card2lun[XD_CARD] >= MAX_ALLOWED_LUN_CNT) {\n\t\tclear_bit(XD_NR, &chip->need_reset);\n\t\tchip->xd_reset_counter = 0;\n\t\tchip->xd_show_cnt = 0;\n\t\treturn;\n\t}\n\n\tchip->rw_fail_cnt[chip->card2lun[XD_CARD]] = 0;\n\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\trtsx_write_register(chip, SDIO_CTRL, 0xFF, 0);\n\n\tretval = reset_xd_card(chip);\n\tif (chip->need_release & XD_CARD)\n\t\treturn;\n\tif (retval == STATUS_SUCCESS) {\n\t\tclear_bit(XD_NR, &chip->need_reset);\n\t\tchip->xd_reset_counter = 0;\n\t\tchip->card_ready |= XD_CARD;\n\t\tchip->card_fail &= ~XD_CARD;\n\t\tchip->rw_card[chip->card2lun[XD_CARD]] = xd_rw;\n\t} else {\n\t\tif (chip->xd_reset_counter >= MAX_RESET_CNT) {\n\t\t\tclear_bit(XD_NR, &chip->need_reset);\n\t\t\tchip->xd_reset_counter = 0;\n\t\t\tchip->xd_show_cnt = 0;\n\t\t} else {\n\t\t\tchip->xd_reset_counter++;\n\t\t}\n\t\tchip->card_ready &= ~XD_CARD;\n\t\tchip->card_fail |= XD_CARD;\n\t\tchip->capacity[chip->card2lun[XD_CARD]] = 0;\n\t\tchip->rw_card[chip->card2lun[XD_CARD]] = NULL;\n\n\t\trtsx_write_register(chip, CARD_OE, XD_OUTPUT_EN, 0);\n\t\tif (!chip->ft2_fast_mode)\n\t\t\tcard_power_off(chip, XD_CARD);\n\t\tdisable_card_clock(chip, XD_CARD);\n\t}\n}\n\nvoid do_reset_ms_card(struct rtsx_chip *chip)\n{\n\tint retval;\n\n\tdev_dbg(rtsx_dev(chip), \"%s: %d, card2lun = 0x%x\\n\", __func__,\n\t\tchip->ms_reset_counter, chip->card2lun[MS_CARD]);\n\n\tif (chip->card2lun[MS_CARD] >= MAX_ALLOWED_LUN_CNT) {\n\t\tclear_bit(MS_NR, &chip->need_reset);\n\t\tchip->ms_reset_counter = 0;\n\t\tchip->ms_show_cnt = 0;\n\t\treturn;\n\t}\n\n\tchip->rw_fail_cnt[chip->card2lun[MS_CARD]] = 0;\n\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\trtsx_write_register(chip, SDIO_CTRL, 0xFF, 0);\n\n\tretval = reset_ms_card(chip);\n\tif (chip->need_release & MS_CARD)\n\t\treturn;\n\tif (retval == STATUS_SUCCESS) {\n\t\tclear_bit(MS_NR, &chip->need_reset);\n\t\tchip->ms_reset_counter = 0;\n\t\tchip->card_ready |= MS_CARD;\n\t\tchip->card_fail &= ~MS_CARD;\n\t\tchip->rw_card[chip->card2lun[MS_CARD]] = ms_rw;\n\t} else {\n\t\tif (chip->ms_reset_counter >= MAX_RESET_CNT) {\n\t\t\tclear_bit(MS_NR, &chip->need_reset);\n\t\t\tchip->ms_reset_counter = 0;\n\t\t\tchip->ms_show_cnt = 0;\n\t\t} else {\n\t\t\tchip->ms_reset_counter++;\n\t\t}\n\t\tchip->card_ready &= ~MS_CARD;\n\t\tchip->card_fail |= MS_CARD;\n\t\tchip->capacity[chip->card2lun[MS_CARD]] = 0;\n\t\tchip->rw_card[chip->card2lun[MS_CARD]] = NULL;\n\n\t\trtsx_write_register(chip, CARD_OE, MS_OUTPUT_EN, 0);\n\t\tif (!chip->ft2_fast_mode)\n\t\t\tcard_power_off(chip, MS_CARD);\n\t\tdisable_card_clock(chip, MS_CARD);\n\t}\n}\n\nstatic void release_sdio(struct rtsx_chip *chip)\n{\n\tif (chip->sd_io) {\n\t\trtsx_write_register(chip, CARD_STOP, SD_STOP | SD_CLR_ERR,\n\t\t\t\t    SD_STOP | SD_CLR_ERR);\n\n\t\tif (chip->chip_insert_with_sdio) {\n\t\t\tchip->chip_insert_with_sdio = 0;\n\n\t\t\tif (CHECK_PID(chip, 0x5288))\n\t\t\t\trtsx_write_register(chip, 0xFE5A, 0x08, 0x00);\n\t\t\telse\n\t\t\t\trtsx_write_register(chip, 0xFE70, 0x80, 0x00);\n\t\t}\n\n\t\trtsx_write_register(chip, SDIO_CTRL, SDIO_CD_CTRL, 0);\n\t\tchip->sd_io = 0;\n\t}\n}\n\nvoid rtsx_power_off_card(struct rtsx_chip *chip)\n{\n\tif ((chip->card_ready & SD_CARD) || chip->sd_io) {\n\t\tsd_cleanup_work(chip);\n\t\tsd_power_off_card3v3(chip);\n\t}\n\n\tif (chip->card_ready & XD_CARD) {\n\t\txd_cleanup_work(chip);\n\t\txd_power_off_card3v3(chip);\n\t}\n\n\tif (chip->card_ready & MS_CARD) {\n\t\tms_cleanup_work(chip);\n\t\tms_power_off_card3v3(chip);\n\t}\n}\n\nvoid rtsx_release_cards(struct rtsx_chip *chip)\n{\n\tchip->int_reg = rtsx_readl(chip, RTSX_BIPR);\n\n\tif ((chip->card_ready & SD_CARD) || chip->sd_io) {\n\t\tif (chip->int_reg & SD_EXIST)\n\t\t\tsd_cleanup_work(chip);\n\t\trelease_sd_card(chip);\n\t}\n\n\tif (chip->card_ready & XD_CARD) {\n\t\tif (chip->int_reg & XD_EXIST)\n\t\t\txd_cleanup_work(chip);\n\t\trelease_xd_card(chip);\n\t}\n\n\tif (chip->card_ready & MS_CARD) {\n\t\tif (chip->int_reg & MS_EXIST)\n\t\t\tms_cleanup_work(chip);\n\t\trelease_ms_card(chip);\n\t}\n}\n\nvoid rtsx_reset_cards(struct rtsx_chip *chip)\n{\n\tif (!chip->need_reset)\n\t\treturn;\n\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\trtsx_force_power_on(chip, SSC_PDCTL | OC_PDCTL);\n\n\trtsx_disable_aspm(chip);\n\n\tif ((chip->need_reset & SD_CARD) && chip->chip_insert_with_sdio)\n\t\tclear_bit(SD_NR, &chip->need_reset);\n\n\tif (chip->need_reset & XD_CARD) {\n\t\tchip->card_exist |= XD_CARD;\n\n\t\tif (chip->xd_show_cnt >= MAX_SHOW_CNT)\n\t\t\tdo_reset_xd_card(chip);\n\t\telse\n\t\t\tchip->xd_show_cnt++;\n\t}\n\tif (CHECK_PID(chip, 0x5288) && CHECK_BARO_PKG(chip, QFN)) {\n\t\tif (chip->card_exist & XD_CARD) {\n\t\t\tclear_bit(SD_NR, &chip->need_reset);\n\t\t\tclear_bit(MS_NR, &chip->need_reset);\n\t\t}\n\t}\n\tif (chip->need_reset & SD_CARD) {\n\t\tchip->card_exist |= SD_CARD;\n\n\t\tif (chip->sd_show_cnt >= MAX_SHOW_CNT) {\n\t\t\trtsx_write_register(chip, RBCTL, RB_FLUSH, RB_FLUSH);\n\t\t\tdo_reset_sd_card(chip);\n\t\t} else {\n\t\t\tchip->sd_show_cnt++;\n\t\t}\n\t}\n\tif (chip->need_reset & MS_CARD) {\n\t\tchip->card_exist |= MS_CARD;\n\n\t\tif (chip->ms_show_cnt >= MAX_SHOW_CNT)\n\t\t\tdo_reset_ms_card(chip);\n\t\telse\n\t\t\tchip->ms_show_cnt++;\n\t}\n}\n\nvoid rtsx_reinit_cards(struct rtsx_chip *chip, int reset_chip)\n{\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\trtsx_force_power_on(chip, SSC_PDCTL | OC_PDCTL);\n\n\tif (reset_chip)\n\t\trtsx_reset_chip(chip);\n\n\tchip->int_reg = rtsx_readl(chip, RTSX_BIPR);\n\n\tif ((chip->int_reg & SD_EXIST) && (chip->need_reinit & SD_CARD)) {\n\t\trelease_sdio(chip);\n\t\trelease_sd_card(chip);\n\n\t\twait_timeout(100);\n\n\t\tchip->card_exist |= SD_CARD;\n\t\tdo_reset_sd_card(chip);\n\t}\n\n\tif ((chip->int_reg & XD_EXIST) && (chip->need_reinit & XD_CARD)) {\n\t\trelease_xd_card(chip);\n\n\t\twait_timeout(100);\n\n\t\tchip->card_exist |= XD_CARD;\n\t\tdo_reset_xd_card(chip);\n\t}\n\n\tif ((chip->int_reg & MS_EXIST) && (chip->need_reinit & MS_CARD)) {\n\t\trelease_ms_card(chip);\n\n\t\twait_timeout(100);\n\n\t\tchip->card_exist |= MS_CARD;\n\t\tdo_reset_ms_card(chip);\n\t}\n\n\tchip->need_reinit = 0;\n}\n\n#ifdef DISABLE_CARD_INT\nvoid card_cd_debounce(struct rtsx_chip *chip, unsigned long *need_reset,\n\t\t      unsigned long *need_release)\n{\n\tu8 release_map = 0, reset_map = 0;\n\n\tchip->int_reg = rtsx_readl(chip, RTSX_BIPR);\n\n\tif (chip->card_exist) {\n\t\tif (chip->card_exist & XD_CARD) {\n\t\t\tif (!(chip->int_reg & XD_EXIST))\n\t\t\t\trelease_map |= XD_CARD;\n\t\t} else if (chip->card_exist & SD_CARD) {\n\t\t\tif (!(chip->int_reg & SD_EXIST))\n\t\t\t\trelease_map |= SD_CARD;\n\t\t} else if (chip->card_exist & MS_CARD) {\n\t\t\tif (!(chip->int_reg & MS_EXIST))\n\t\t\t\trelease_map |= MS_CARD;\n\t\t}\n\t} else {\n\t\tif (chip->int_reg & XD_EXIST)\n\t\t\treset_map |= XD_CARD;\n\t\telse if (chip->int_reg & SD_EXIST)\n\t\t\treset_map |= SD_CARD;\n\t\telse if (chip->int_reg & MS_EXIST)\n\t\t\treset_map |= MS_CARD;\n\t}\n\n\tif (reset_map) {\n\t\tint xd_cnt = 0, sd_cnt = 0, ms_cnt = 0;\n\t\tint i;\n\n\t\tfor (i = 0; i < (DEBOUNCE_CNT); i++) {\n\t\t\tchip->int_reg = rtsx_readl(chip, RTSX_BIPR);\n\n\t\t\tif (chip->int_reg & XD_EXIST)\n\t\t\t\txd_cnt++;\n\t\t\telse\n\t\t\t\txd_cnt = 0;\n\n\t\t\tif (chip->int_reg & SD_EXIST)\n\t\t\t\tsd_cnt++;\n\t\t\telse\n\t\t\t\tsd_cnt = 0;\n\n\t\t\tif (chip->int_reg & MS_EXIST)\n\t\t\t\tms_cnt++;\n\t\t\telse\n\t\t\t\tms_cnt = 0;\n\n\t\t\twait_timeout(30);\n\t\t}\n\n\t\treset_map = 0;\n\t\tif (!(chip->card_exist & XD_CARD) &&\n\t\t    (xd_cnt > (DEBOUNCE_CNT - 1)))\n\t\t\treset_map |= XD_CARD;\n\t\tif (!(chip->card_exist & SD_CARD) &&\n\t\t    (sd_cnt > (DEBOUNCE_CNT - 1)))\n\t\t\treset_map |= SD_CARD;\n\t\tif (!(chip->card_exist & MS_CARD) &&\n\t\t    (ms_cnt > (DEBOUNCE_CNT - 1)))\n\t\t\treset_map |= MS_CARD;\n\t}\n\n\tif (CHECK_PID(chip, 0x5288) && CHECK_BARO_PKG(chip, QFN))\n\t\trtsx_write_register(chip, HOST_SLEEP_STATE, 0xC0, 0x00);\n\n\tif (need_reset)\n\t\t*need_reset = reset_map;\n\tif (need_release)\n\t\t*need_release = release_map;\n}\n#endif\n\nvoid rtsx_init_cards(struct rtsx_chip *chip)\n{\n\tif (RTSX_TST_DELINK(chip) && (rtsx_get_stat(chip) != RTSX_STAT_SS)) {\n\t\tdev_dbg(rtsx_dev(chip), \"Reset chip in polling thread!\\n\");\n\t\trtsx_reset_chip(chip);\n\t\tRTSX_CLR_DELINK(chip);\n\t}\n\n#ifdef DISABLE_CARD_INT\n\tcard_cd_debounce(chip, &chip->need_reset, &chip->need_release);\n#endif\n\n\tif (chip->need_release) {\n\t\tif (CHECK_PID(chip, 0x5288) && CHECK_BARO_PKG(chip, QFN)) {\n\t\t\tif (chip->int_reg & XD_EXIST) {\n\t\t\t\tclear_bit(SD_NR, &chip->need_release);\n\t\t\t\tclear_bit(MS_NR, &chip->need_release);\n\t\t\t}\n\t\t}\n\n\t\tif (!(chip->card_exist & SD_CARD) && !chip->sd_io)\n\t\t\tclear_bit(SD_NR, &chip->need_release);\n\t\tif (!(chip->card_exist & XD_CARD))\n\t\t\tclear_bit(XD_NR, &chip->need_release);\n\t\tif (!(chip->card_exist & MS_CARD))\n\t\t\tclear_bit(MS_NR, &chip->need_release);\n\n\t\tdev_dbg(rtsx_dev(chip), \"chip->need_release = 0x%x\\n\",\n\t\t\t(unsigned int)(chip->need_release));\n\n#ifdef SUPPORT_OCP\n\t\tif (chip->need_release) {\n\t\t\tif (chip->ocp_stat & (CARD_OC_NOW | CARD_OC_EVER))\n\t\t\t\trtsx_write_register(chip, OCPCLR,\n\t\t\t\t\t\t    CARD_OC_INT_CLR |\n\t\t\t\t\t\t    CARD_OC_CLR,\n\t\t\t\t\t\t    CARD_OC_INT_CLR |\n\t\t\t\t\t\t    CARD_OC_CLR);\n\t\t\tchip->ocp_stat = 0;\n\t\t}\n#endif\n\t\tif (chip->need_release) {\n\t\t\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\t\t\trtsx_force_power_on(chip, SSC_PDCTL | OC_PDCTL);\n\t\t}\n\n\t\tif (chip->need_release & SD_CARD) {\n\t\t\tclear_bit(SD_NR, &chip->need_release);\n\t\t\tchip->card_exist &= ~SD_CARD;\n\t\t\tchip->card_ejected &= ~SD_CARD;\n\t\t\tchip->card_fail &= ~SD_CARD;\n\t\t\tCLR_BIT(chip->lun_mc, chip->card2lun[SD_CARD]);\n\t\t\tchip->rw_fail_cnt[chip->card2lun[SD_CARD]] = 0;\n\t\t\trtsx_write_register(chip, RBCTL, RB_FLUSH, RB_FLUSH);\n\n\t\t\trelease_sdio(chip);\n\t\t\trelease_sd_card(chip);\n\t\t}\n\n\t\tif (chip->need_release & XD_CARD) {\n\t\t\tclear_bit(XD_NR, &chip->need_release);\n\t\t\tchip->card_exist &= ~XD_CARD;\n\t\t\tchip->card_ejected &= ~XD_CARD;\n\t\t\tchip->card_fail &= ~XD_CARD;\n\t\t\tCLR_BIT(chip->lun_mc, chip->card2lun[XD_CARD]);\n\t\t\tchip->rw_fail_cnt[chip->card2lun[XD_CARD]] = 0;\n\n\t\t\trelease_xd_card(chip);\n\n\t\t\tif (CHECK_PID(chip, 0x5288) &&\n\t\t\t    CHECK_BARO_PKG(chip, QFN))\n\t\t\t\trtsx_write_register(chip, HOST_SLEEP_STATE,\n\t\t\t\t\t\t    0xC0, 0xC0);\n\t\t}\n\n\t\tif (chip->need_release & MS_CARD) {\n\t\t\tclear_bit(MS_NR, &chip->need_release);\n\t\t\tchip->card_exist &= ~MS_CARD;\n\t\t\tchip->card_ejected &= ~MS_CARD;\n\t\t\tchip->card_fail &= ~MS_CARD;\n\t\t\tCLR_BIT(chip->lun_mc, chip->card2lun[MS_CARD]);\n\t\t\tchip->rw_fail_cnt[chip->card2lun[MS_CARD]] = 0;\n\n\t\t\trelease_ms_card(chip);\n\t\t}\n\n\t\tdev_dbg(rtsx_dev(chip), \"chip->card_exist = 0x%x\\n\",\n\t\t\tchip->card_exist);\n\n\t\tif (!chip->card_exist)\n\t\t\tturn_off_led(chip, LED_GPIO);\n\t}\n\n\tif (chip->need_reset) {\n\t\tdev_dbg(rtsx_dev(chip), \"chip->need_reset = 0x%x\\n\",\n\t\t\t(unsigned int)(chip->need_reset));\n\n\t\trtsx_reset_cards(chip);\n\t}\n\n\tif (chip->need_reinit) {\n\t\tdev_dbg(rtsx_dev(chip), \"chip->need_reinit = 0x%x\\n\",\n\t\t\t(unsigned int)(chip->need_reinit));\n\n\t\trtsx_reinit_cards(chip, 0);\n\t}\n}\n\nint switch_ssc_clock(struct rtsx_chip *chip, int clk)\n{\n\tint retval;\n\tu8 n = (u8)(clk - 2), min_n, max_n;\n\tu8 mcu_cnt, div, max_div, ssc_depth, ssc_depth_mask;\n\tint sd_vpclk_phase_reset = 0;\n\n\tif (chip->cur_clk == clk)\n\t\treturn STATUS_SUCCESS;\n\n\tmin_n = 60;\n\tmax_n = 120;\n\tmax_div = CLK_DIV_4;\n\n\tdev_dbg(rtsx_dev(chip), \"Switch SSC clock to %dMHz (cur_clk = %d)\\n\",\n\t\tclk, chip->cur_clk);\n\n\tif (clk <= 2 || n > max_n)\n\t\treturn STATUS_FAIL;\n\n\tmcu_cnt = (u8)(125 / clk + 3);\n\tif (mcu_cnt > 7)\n\t\tmcu_cnt = 7;\n\n\tdiv = CLK_DIV_1;\n\twhile ((n < min_n) && (div < max_div)) {\n\t\tn = (n + 2) * 2 - 2;\n\t\tdiv++;\n\t}\n\tdev_dbg(rtsx_dev(chip), \"n = %d, div = %d\\n\", n, div);\n\n\tif (chip->ssc_en) {\n\t\tssc_depth = 0x01;\n\t\tn -= 2;\n\t} else {\n\t\tssc_depth = 0;\n\t}\n\n\tssc_depth_mask = 0x03;\n\n\tdev_dbg(rtsx_dev(chip), \"ssc_depth = %d\\n\", ssc_depth);\n\n\trtsx_init_cmd(chip);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CLK_CTL, CLK_LOW_FREQ, CLK_LOW_FREQ);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CLK_DIV, 0xFF, (div << 4) | mcu_cnt);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SSC_CTL1, SSC_RSTB, 0);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SSC_CTL2, ssc_depth_mask, ssc_depth);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SSC_DIV_N_0, 0xFF, n);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SSC_CTL1, SSC_RSTB, SSC_RSTB);\n\tif (sd_vpclk_phase_reset) {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SD_VPCLK0_CTL,\n\t\t\t     PHASE_NOT_RESET, 0);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SD_VPCLK0_CTL,\n\t\t\t     PHASE_NOT_RESET, PHASE_NOT_RESET);\n\t}\n\n\tretval = rtsx_send_cmd(chip, 0, WAIT_TIME);\n\tif (retval < 0)\n\t\treturn STATUS_ERROR;\n\n\tudelay(10);\n\tretval = rtsx_write_register(chip, CLK_CTL, CLK_LOW_FREQ, 0);\n\tif (retval)\n\t\treturn retval;\n\n\tchip->cur_clk = clk;\n\n\treturn STATUS_SUCCESS;\n}\n\nint switch_normal_clock(struct rtsx_chip *chip, int clk)\n{\n\tint retval;\n\tu8 sel, div, mcu_cnt;\n\tint sd_vpclk_phase_reset = 0;\n\n\tif (chip->cur_clk == clk)\n\t\treturn STATUS_SUCCESS;\n\n\tswitch (clk) {\n\tcase CLK_20:\n\t\tdev_dbg(rtsx_dev(chip), \"Switch clock to 20MHz\\n\");\n\t\tsel = SSC_80;\n\t\tdiv = CLK_DIV_4;\n\t\tmcu_cnt = 7;\n\t\tbreak;\n\n\tcase CLK_30:\n\t\tdev_dbg(rtsx_dev(chip), \"Switch clock to 30MHz\\n\");\n\t\tsel = SSC_120;\n\t\tdiv = CLK_DIV_4;\n\t\tmcu_cnt = 7;\n\t\tbreak;\n\n\tcase CLK_40:\n\t\tdev_dbg(rtsx_dev(chip), \"Switch clock to 40MHz\\n\");\n\t\tsel = SSC_80;\n\t\tdiv = CLK_DIV_2;\n\t\tmcu_cnt = 7;\n\t\tbreak;\n\n\tcase CLK_50:\n\t\tdev_dbg(rtsx_dev(chip), \"Switch clock to 50MHz\\n\");\n\t\tsel = SSC_100;\n\t\tdiv = CLK_DIV_2;\n\t\tmcu_cnt = 6;\n\t\tbreak;\n\n\tcase CLK_60:\n\t\tdev_dbg(rtsx_dev(chip), \"Switch clock to 60MHz\\n\");\n\t\tsel = SSC_120;\n\t\tdiv = CLK_DIV_2;\n\t\tmcu_cnt = 6;\n\t\tbreak;\n\n\tcase CLK_80:\n\t\tdev_dbg(rtsx_dev(chip), \"Switch clock to 80MHz\\n\");\n\t\tsel = SSC_80;\n\t\tdiv = CLK_DIV_1;\n\t\tmcu_cnt = 5;\n\t\tbreak;\n\n\tcase CLK_100:\n\t\tdev_dbg(rtsx_dev(chip), \"Switch clock to 100MHz\\n\");\n\t\tsel = SSC_100;\n\t\tdiv = CLK_DIV_1;\n\t\tmcu_cnt = 5;\n\t\tbreak;\n\n\tcase CLK_120:\n\t\tdev_dbg(rtsx_dev(chip), \"Switch clock to 120MHz\\n\");\n\t\tsel = SSC_120;\n\t\tdiv = CLK_DIV_1;\n\t\tmcu_cnt = 5;\n\t\tbreak;\n\n\tcase CLK_150:\n\t\tdev_dbg(rtsx_dev(chip), \"Switch clock to 150MHz\\n\");\n\t\tsel = SSC_150;\n\t\tdiv = CLK_DIV_1;\n\t\tmcu_cnt = 4;\n\t\tbreak;\n\n\tcase CLK_200:\n\t\tdev_dbg(rtsx_dev(chip), \"Switch clock to 200MHz\\n\");\n\t\tsel = SSC_200;\n\t\tdiv = CLK_DIV_1;\n\t\tmcu_cnt = 4;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(rtsx_dev(chip), \"Try to switch to an illegal clock (%d)\\n\",\n\t\t\tclk);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = rtsx_write_register(chip, CLK_CTL, 0xFF, CLK_LOW_FREQ);\n\tif (retval)\n\t\treturn retval;\n\tif (sd_vpclk_phase_reset) {\n\t\tretval = rtsx_write_register(chip, SD_VPCLK0_CTL,\n\t\t\t\t\t     PHASE_NOT_RESET, 0);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = rtsx_write_register(chip, SD_VPCLK1_CTL,\n\t\t\t\t\t     PHASE_NOT_RESET, 0);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\tretval = rtsx_write_register(chip, CLK_DIV, 0xFF,\n\t\t\t\t     (div << 4) | mcu_cnt);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, CLK_SEL, 0xFF, sel);\n\tif (retval)\n\t\treturn retval;\n\n\tif (sd_vpclk_phase_reset) {\n\t\tudelay(200);\n\t\tretval = rtsx_write_register(chip, SD_VPCLK0_CTL,\n\t\t\t\t\t     PHASE_NOT_RESET, PHASE_NOT_RESET);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = rtsx_write_register(chip, SD_VPCLK1_CTL,\n\t\t\t\t\t     PHASE_NOT_RESET, PHASE_NOT_RESET);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tudelay(200);\n\t}\n\tretval = rtsx_write_register(chip, CLK_CTL, 0xFF, 0);\n\tif (retval)\n\t\treturn retval;\n\n\tchip->cur_clk = clk;\n\n\treturn STATUS_SUCCESS;\n}\n\nvoid trans_dma_enable(enum dma_data_direction dir, struct rtsx_chip *chip,\n\t\t      u32 byte_cnt, u8 pack_size)\n{\n\tif (pack_size > DMA_1024)\n\t\tpack_size = DMA_512;\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, IRQSTAT0, DMA_DONE_INT, DMA_DONE_INT);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, DMATC3, 0xFF, (u8)(byte_cnt >> 24));\n\trtsx_add_cmd(chip, WRITE_REG_CMD, DMATC2, 0xFF, (u8)(byte_cnt >> 16));\n\trtsx_add_cmd(chip, WRITE_REG_CMD, DMATC1, 0xFF, (u8)(byte_cnt >> 8));\n\trtsx_add_cmd(chip, WRITE_REG_CMD, DMATC0, 0xFF, (u8)byte_cnt);\n\n\tif (dir == DMA_FROM_DEVICE) {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, DMACTL,\n\t\t\t     0x03 | DMA_PACK_SIZE_MASK,\n\t\t\t     DMA_DIR_FROM_CARD | DMA_EN | pack_size);\n\t} else {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, DMACTL,\n\t\t\t     0x03 | DMA_PACK_SIZE_MASK,\n\t\t\t     DMA_DIR_TO_CARD | DMA_EN | pack_size);\n\t}\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01, RING_BUFFER);\n}\n\nint enable_card_clock(struct rtsx_chip *chip, u8 card)\n{\n\tint retval;\n\tu8 clk_en = 0;\n\n\tif (card & XD_CARD)\n\t\tclk_en |= XD_CLK_EN;\n\tif (card & SD_CARD)\n\t\tclk_en |= SD_CLK_EN;\n\tif (card & MS_CARD)\n\t\tclk_en |= MS_CLK_EN;\n\n\tretval = rtsx_write_register(chip, CARD_CLK_EN, clk_en, clk_en);\n\tif (retval)\n\t\treturn retval;\n\n\treturn STATUS_SUCCESS;\n}\n\nint disable_card_clock(struct rtsx_chip *chip, u8 card)\n{\n\tint retval;\n\tu8 clk_en = 0;\n\n\tif (card & XD_CARD)\n\t\tclk_en |= XD_CLK_EN;\n\tif (card & SD_CARD)\n\t\tclk_en |= SD_CLK_EN;\n\tif (card & MS_CARD)\n\t\tclk_en |= MS_CLK_EN;\n\n\tretval = rtsx_write_register(chip, CARD_CLK_EN, clk_en, 0);\n\tif (retval)\n\t\treturn retval;\n\n\treturn STATUS_SUCCESS;\n}\n\nint card_power_on(struct rtsx_chip *chip, u8 card)\n{\n\tint retval;\n\tu8 mask, val1, val2;\n\n\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN) && card == MS_CARD) {\n\t\tmask = MS_POWER_MASK;\n\t\tval1 = MS_PARTIAL_POWER_ON;\n\t\tval2 = MS_POWER_ON;\n\t} else {\n\t\tmask = SD_POWER_MASK;\n\t\tval1 = SD_PARTIAL_POWER_ON;\n\t\tval2 = SD_POWER_ON;\n\t}\n\n\trtsx_init_cmd(chip);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PWR_CTL, mask, val1);\n\n\tretval = rtsx_send_cmd(chip, 0, 100);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tudelay(chip->pmos_pwr_on_interval);\n\n\trtsx_init_cmd(chip);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PWR_CTL, mask, val2);\n\n\tretval = rtsx_send_cmd(chip, 0, 100);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nint card_power_off(struct rtsx_chip *chip, u8 card)\n{\n\tint retval;\n\tu8 mask, val;\n\n\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN) && card == MS_CARD) {\n\t\tmask = MS_POWER_MASK;\n\t\tval = MS_POWER_OFF;\n\t} else {\n\t\tmask = SD_POWER_MASK;\n\t\tval = SD_POWER_OFF;\n\t}\n\n\tretval = rtsx_write_register(chip, CARD_PWR_CTL, mask, val);\n\tif (retval)\n\t\treturn retval;\n\n\treturn STATUS_SUCCESS;\n}\n\nint card_rw(struct scsi_cmnd *srb, struct rtsx_chip *chip,\n\t    u32 sec_addr, u16 sec_cnt)\n{\n\tint retval;\n\tunsigned int lun = SCSI_LUN(srb);\n\tint i;\n\n\tif (!chip->rw_card[lun])\n\t\treturn STATUS_FAIL;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tchip->rw_need_retry = 0;\n\n\t\tretval = chip->rw_card[lun](srb, chip, sec_addr, sec_cnt);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tif (rtsx_check_chip_exist(chip) != STATUS_SUCCESS) {\n\t\t\t\trtsx_release_chip(chip);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t\tif (detect_card_cd(chip, chip->cur_card) !=\n\t\t\t\t\t\t\tSTATUS_SUCCESS) {\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\tif (!chip->rw_need_retry) {\n\t\t\t\tdev_dbg(rtsx_dev(chip), \"RW fail, but no need to retry\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tchip->rw_need_retry = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(rtsx_dev(chip), \"Retry RW, (i = %d)\\n\", i);\n\t}\n\n\treturn retval;\n}\n\nint card_share_mode(struct rtsx_chip *chip, int card)\n{\n\tint retval;\n\tu8 mask, value;\n\n\tif (CHECK_PID(chip, 0x5208)) {\n\t\tmask = CARD_SHARE_MASK;\n\t\tif (card == SD_CARD)\n\t\t\tvalue = CARD_SHARE_48_SD;\n\t\telse if (card == MS_CARD)\n\t\t\tvalue = CARD_SHARE_48_MS;\n\t\telse if (card == XD_CARD)\n\t\t\tvalue = CARD_SHARE_48_XD;\n\t\telse\n\t\t\treturn STATUS_FAIL;\n\n\t} else if (CHECK_PID(chip, 0x5288)) {\n\t\tmask = 0x03;\n\t\tif (card == SD_CARD)\n\t\t\tvalue = CARD_SHARE_BAROSSA_SD;\n\t\telse if (card == MS_CARD)\n\t\t\tvalue = CARD_SHARE_BAROSSA_MS;\n\t\telse if (card == XD_CARD)\n\t\t\tvalue = CARD_SHARE_BAROSSA_XD;\n\t\telse\n\t\t\treturn STATUS_FAIL;\n\n\t} else {\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = rtsx_write_register(chip, CARD_SHARE_MODE, mask, value);\n\tif (retval)\n\t\treturn retval;\n\n\treturn STATUS_SUCCESS;\n}\n\nint select_card(struct rtsx_chip *chip, int card)\n{\n\tint retval;\n\n\tif (chip->cur_card != card) {\n\t\tu8 mod;\n\n\t\tif (card == SD_CARD)\n\t\t\tmod = SD_MOD_SEL;\n\t\telse if (card == MS_CARD)\n\t\t\tmod = MS_MOD_SEL;\n\t\telse if (card == XD_CARD)\n\t\t\tmod = XD_MOD_SEL;\n\t\telse if (card == SPI_CARD)\n\t\t\tmod = SPI_MOD_SEL;\n\t\telse\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = rtsx_write_register(chip, CARD_SELECT, 0x07, mod);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tchip->cur_card = card;\n\n\t\tretval =  card_share_mode(chip, card);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nvoid toggle_gpio(struct rtsx_chip *chip, u8 gpio)\n{\n\tu8 temp_reg;\n\n\trtsx_read_register(chip, CARD_GPIO, &temp_reg);\n\ttemp_reg ^= (0x01 << gpio);\n\trtsx_write_register(chip, CARD_GPIO, 0xFF, temp_reg);\n}\n\nvoid turn_on_led(struct rtsx_chip *chip, u8 gpio)\n{\n\tif (CHECK_PID(chip, 0x5288))\n\t\trtsx_write_register(chip, CARD_GPIO, (u8)(1 << gpio),\n\t\t\t\t    (u8)(1 << gpio));\n\telse\n\t\trtsx_write_register(chip, CARD_GPIO, (u8)(1 << gpio), 0);\n}\n\nvoid turn_off_led(struct rtsx_chip *chip, u8 gpio)\n{\n\tif (CHECK_PID(chip, 0x5288))\n\t\trtsx_write_register(chip, CARD_GPIO, (u8)(1 << gpio), 0);\n\telse\n\t\trtsx_write_register(chip, CARD_GPIO, (u8)(1 << gpio),\n\t\t\t\t    (u8)(1 << gpio));\n}\n\nint detect_card_cd(struct rtsx_chip *chip, int card)\n{\n\tu32 card_cd, status;\n\n\tif (card == SD_CARD) {\n\t\tcard_cd = SD_EXIST;\n\t} else if (card == MS_CARD) {\n\t\tcard_cd = MS_EXIST;\n\t} else if (card == XD_CARD) {\n\t\tcard_cd = XD_EXIST;\n\t} else {\n\t\tdev_dbg(rtsx_dev(chip), \"Wrong card type: 0x%x\\n\", card);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tstatus = rtsx_readl(chip, RTSX_BIPR);\n\tif (!(status & card_cd))\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nint check_card_exist(struct rtsx_chip *chip, unsigned int lun)\n{\n\tif (chip->card_exist & chip->lun2card[lun])\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint check_card_ready(struct rtsx_chip *chip, unsigned int lun)\n{\n\tif (chip->card_ready & chip->lun2card[lun])\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint check_card_wp(struct rtsx_chip *chip, unsigned int lun)\n{\n\tif (chip->card_wp & chip->lun2card[lun])\n\t\treturn 1;\n\n\treturn 0;\n}\n\nu8 get_lun_card(struct rtsx_chip *chip, unsigned int lun)\n{\n\tif ((chip->card_ready & chip->lun2card[lun]) == XD_CARD)\n\t\treturn (u8)XD_CARD;\n\telse if ((chip->card_ready & chip->lun2card[lun]) == SD_CARD)\n\t\treturn (u8)SD_CARD;\n\telse if ((chip->card_ready & chip->lun2card[lun]) == MS_CARD)\n\t\treturn (u8)MS_CARD;\n\n\treturn 0;\n}\n\nvoid eject_card(struct rtsx_chip *chip, unsigned int lun)\n{\n\tdo_remaining_work(chip);\n\n\tif ((chip->card_ready & chip->lun2card[lun]) == SD_CARD) {\n\t\trelease_sd_card(chip);\n\t\tchip->card_ejected |= SD_CARD;\n\t\tchip->card_ready &= ~SD_CARD;\n\t\tchip->capacity[lun] = 0;\n\t} else if ((chip->card_ready & chip->lun2card[lun]) == XD_CARD) {\n\t\trelease_xd_card(chip);\n\t\tchip->card_ejected |= XD_CARD;\n\t\tchip->card_ready &= ~XD_CARD;\n\t\tchip->capacity[lun] = 0;\n\t} else if ((chip->card_ready & chip->lun2card[lun]) == MS_CARD) {\n\t\trelease_ms_card(chip);\n\t\tchip->card_ejected |= MS_CARD;\n\t\tchip->card_ready &= ~MS_CARD;\n\t\tchip->capacity[lun] = 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}