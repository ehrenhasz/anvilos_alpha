{
  "module_name": "spi.c",
  "hash_id": "e7e833e8556a548408e0ed931bef00c36194a237113e3945a7dc95003f1ee5fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rts5208/spi.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n\n#include \"rtsx.h\"\n#include \"spi.h\"\n\nstatic inline void spi_set_err_code(struct rtsx_chip *chip, u8 err_code)\n{\n\tstruct spi_info *spi = &chip->spi;\n\n\tspi->err_code = err_code;\n}\n\nstatic int spi_init(struct rtsx_chip *chip)\n{\n\tint retval;\n\n\tretval = rtsx_write_register(chip, SPI_CONTROL, 0xFF,\n\t\t\t\t     CS_POLARITY_LOW | DTO_MSB_FIRST\n\t\t\t\t     | SPI_MASTER | SPI_MODE0 | SPI_AUTO);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, SPI_TCTL, EDO_TIMING_MASK,\n\t\t\t\t     SAMPLE_DELAY_HALF);\n\tif (retval)\n\t\treturn retval;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int spi_set_init_para(struct rtsx_chip *chip)\n{\n\tstruct spi_info *spi = &chip->spi;\n\tint retval;\n\n\tretval = rtsx_write_register(chip, SPI_CLK_DIVIDER1, 0xFF,\n\t\t\t\t     (u8)(spi->clk_div >> 8));\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, SPI_CLK_DIVIDER0, 0xFF,\n\t\t\t\t     (u8)(spi->clk_div));\n\tif (retval)\n\t\treturn retval;\n\n\tretval = switch_clock(chip, spi->spi_clock);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = select_card(chip, SPI_CARD);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = rtsx_write_register(chip, CARD_CLK_EN, SPI_CLK_EN,\n\t\t\t\t     SPI_CLK_EN);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, CARD_OE, SPI_OUTPUT_EN,\n\t\t\t\t     SPI_OUTPUT_EN);\n\tif (retval)\n\t\treturn retval;\n\n\twait_timeout(10);\n\n\tretval = spi_init(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int sf_polling_status(struct rtsx_chip *chip, int msec)\n{\n\tint retval;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_COMMAND, 0xFF, SPI_RDSR);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t     SPI_TRANSFER0_START | SPI_POLLING_MODE0);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, SPI_TRANSFER0, SPI_TRANSFER0_END,\n\t\t     SPI_TRANSFER0_END);\n\n\tretval = rtsx_send_cmd(chip, 0, msec);\n\tif (retval < 0) {\n\t\trtsx_clear_spi_error(chip);\n\t\tspi_set_err_code(chip, SPI_BUSY_ERR);\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int sf_enable_write(struct rtsx_chip *chip, u8 ins)\n{\n\tstruct spi_info *spi = &chip->spi;\n\tint retval;\n\n\tif (!spi->write_en)\n\t\treturn STATUS_SUCCESS;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_COMMAND, 0xFF, ins);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_CA_NUMBER, 0xFF,\n\t\t     SPI_COMMAND_BIT_8 | SPI_ADDRESS_BIT_24);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t     SPI_TRANSFER0_START | SPI_C_MODE0);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, SPI_TRANSFER0, SPI_TRANSFER0_END,\n\t\t     SPI_TRANSFER0_END);\n\n\tretval = rtsx_send_cmd(chip, 0, 100);\n\tif (retval < 0) {\n\t\trtsx_clear_spi_error(chip);\n\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int sf_disable_write(struct rtsx_chip *chip, u8 ins)\n{\n\tstruct spi_info *spi = &chip->spi;\n\tint retval;\n\n\tif (!spi->write_en)\n\t\treturn STATUS_SUCCESS;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_COMMAND, 0xFF, ins);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_CA_NUMBER, 0xFF,\n\t\t     SPI_COMMAND_BIT_8 | SPI_ADDRESS_BIT_24);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t     SPI_TRANSFER0_START | SPI_C_MODE0);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, SPI_TRANSFER0, SPI_TRANSFER0_END,\n\t\t     SPI_TRANSFER0_END);\n\n\tretval = rtsx_send_cmd(chip, 0, 100);\n\tif (retval < 0) {\n\t\trtsx_clear_spi_error(chip);\n\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic void sf_program(struct rtsx_chip *chip, u8 ins, u8 addr_mode, u32 addr,\n\t\t       u16 len)\n{\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_COMMAND, 0xFF, ins);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_CA_NUMBER, 0xFF,\n\t\t     SPI_COMMAND_BIT_8 | SPI_ADDRESS_BIT_24);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_LENGTH0, 0xFF, (u8)len);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_LENGTH1, 0xFF, (u8)(len >> 8));\n\tif (addr_mode) {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR0, 0xFF, (u8)addr);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR1, 0xFF,\n\t\t\t     (u8)(addr >> 8));\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR2, 0xFF,\n\t\t\t     (u8)(addr >> 16));\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t\t     SPI_TRANSFER0_START | SPI_CADO_MODE0);\n\t} else {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t\t     SPI_TRANSFER0_START | SPI_CDO_MODE0);\n\t}\n\trtsx_add_cmd(chip, CHECK_REG_CMD, SPI_TRANSFER0, SPI_TRANSFER0_END,\n\t\t     SPI_TRANSFER0_END);\n}\n\nstatic int sf_erase(struct rtsx_chip *chip, u8 ins, u8 addr_mode, u32 addr)\n{\n\tint retval;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_COMMAND, 0xFF, ins);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_CA_NUMBER, 0xFF,\n\t\t     SPI_COMMAND_BIT_8 | SPI_ADDRESS_BIT_24);\n\tif (addr_mode) {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR0, 0xFF, (u8)addr);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR1, 0xFF,\n\t\t\t     (u8)(addr >> 8));\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR2, 0xFF,\n\t\t\t     (u8)(addr >> 16));\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t\t     SPI_TRANSFER0_START | SPI_CA_MODE0);\n\t} else {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t\t     SPI_TRANSFER0_START | SPI_C_MODE0);\n\t}\n\trtsx_add_cmd(chip, CHECK_REG_CMD, SPI_TRANSFER0, SPI_TRANSFER0_END,\n\t\t     SPI_TRANSFER0_END);\n\n\tretval = rtsx_send_cmd(chip, 0, 100);\n\tif (retval < 0) {\n\t\trtsx_clear_spi_error(chip);\n\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int spi_init_eeprom(struct rtsx_chip *chip)\n{\n\tint retval;\n\tint clk;\n\n\tif (chip->asic_code)\n\t\tclk = 30;\n\telse\n\t\tclk = CLK_30;\n\n\tretval = rtsx_write_register(chip, SPI_CLK_DIVIDER1, 0xFF, 0x00);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, SPI_CLK_DIVIDER0, 0xFF, 0x27);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = switch_clock(chip, clk);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = select_card(chip, SPI_CARD);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = rtsx_write_register(chip, CARD_CLK_EN, SPI_CLK_EN,\n\t\t\t\t     SPI_CLK_EN);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, CARD_OE, SPI_OUTPUT_EN,\n\t\t\t\t     SPI_OUTPUT_EN);\n\tif (retval)\n\t\treturn retval;\n\n\twait_timeout(10);\n\n\tretval = rtsx_write_register(chip, SPI_CONTROL, 0xFF,\n\t\t\t\t     CS_POLARITY_HIGH | SPI_EEPROM_AUTO);\n\tif (retval)\n\t\treturn retval;\n\tretval = rtsx_write_register(chip, SPI_TCTL, EDO_TIMING_MASK,\n\t\t\t\t     SAMPLE_DELAY_HALF);\n\tif (retval)\n\t\treturn retval;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int spi_eeprom_program_enable(struct rtsx_chip *chip)\n{\n\tint retval;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_CA_NUMBER, 0xFF, 0x86);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_COMMAND, 0xFF, 0x13);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t     SPI_TRANSFER0_START | SPI_CA_MODE0);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, SPI_TRANSFER0, SPI_TRANSFER0_END,\n\t\t     SPI_TRANSFER0_END);\n\n\tretval = rtsx_send_cmd(chip, 0, 100);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nint spi_erase_eeprom_chip(struct rtsx_chip *chip)\n{\n\tint retval;\n\n\tretval = spi_init_eeprom(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = spi_eeprom_program_enable(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_GPIO_DIR, 0x01, 0);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01, RING_BUFFER);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_COMMAND, 0xFF, 0x12);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_CA_NUMBER, 0xFF, 0x84);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t     SPI_TRANSFER0_START | SPI_CA_MODE0);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, SPI_TRANSFER0, SPI_TRANSFER0_END,\n\t\t     SPI_TRANSFER0_END);\n\n\tretval = rtsx_send_cmd(chip, 0, 100);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\tretval = rtsx_write_register(chip, CARD_GPIO_DIR, 0x01, 0x01);\n\tif (retval)\n\t\treturn retval;\n\n\treturn STATUS_SUCCESS;\n}\n\nint spi_erase_eeprom_byte(struct rtsx_chip *chip, u16 addr)\n{\n\tint retval;\n\n\tretval = spi_init_eeprom(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = spi_eeprom_program_enable(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_GPIO_DIR, 0x01, 0);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01, RING_BUFFER);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_COMMAND, 0xFF, 0x07);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR0, 0xFF, (u8)addr);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR1, 0xFF, (u8)(addr >> 8));\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_CA_NUMBER, 0xFF, 0x46);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t     SPI_TRANSFER0_START | SPI_CA_MODE0);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, SPI_TRANSFER0, SPI_TRANSFER0_END,\n\t\t     SPI_TRANSFER0_END);\n\n\tretval = rtsx_send_cmd(chip, 0, 100);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\tretval = rtsx_write_register(chip, CARD_GPIO_DIR, 0x01, 0x01);\n\tif (retval)\n\t\treturn retval;\n\n\treturn STATUS_SUCCESS;\n}\n\nint spi_read_eeprom(struct rtsx_chip *chip, u16 addr, u8 *val)\n{\n\tint retval;\n\tu8 data;\n\n\tretval = spi_init_eeprom(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_GPIO_DIR, 0x01, 0);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01, RING_BUFFER);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_COMMAND, 0xFF, 0x06);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR0, 0xFF, (u8)addr);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR1, 0xFF, (u8)(addr >> 8));\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_CA_NUMBER, 0xFF, 0x46);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_LENGTH0, 0xFF, 1);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t     SPI_TRANSFER0_START | SPI_CADI_MODE0);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, SPI_TRANSFER0, SPI_TRANSFER0_END,\n\t\t     SPI_TRANSFER0_END);\n\n\tretval = rtsx_send_cmd(chip, 0, 100);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\twait_timeout(5);\n\tretval = rtsx_read_register(chip, SPI_DATA, &data);\n\tif (retval)\n\t\treturn retval;\n\n\tif (val)\n\t\t*val = data;\n\n\tretval = rtsx_write_register(chip, CARD_GPIO_DIR, 0x01, 0x01);\n\tif (retval)\n\t\treturn retval;\n\n\treturn STATUS_SUCCESS;\n}\n\nint spi_write_eeprom(struct rtsx_chip *chip, u16 addr, u8 val)\n{\n\tint retval;\n\n\tretval = spi_init_eeprom(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = spi_eeprom_program_enable(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_GPIO_DIR, 0x01, 0);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01, RING_BUFFER);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_COMMAND, 0xFF, 0x05);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR0, 0xFF, val);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR1, 0xFF, (u8)addr);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR2, 0xFF, (u8)(addr >> 8));\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_CA_NUMBER, 0xFF, 0x4E);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t     SPI_TRANSFER0_START | SPI_CA_MODE0);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, SPI_TRANSFER0, SPI_TRANSFER0_END,\n\t\t     SPI_TRANSFER0_END);\n\n\tretval = rtsx_send_cmd(chip, 0, 100);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\tretval = rtsx_write_register(chip, CARD_GPIO_DIR, 0x01, 0x01);\n\tif (retval)\n\t\treturn retval;\n\n\treturn STATUS_SUCCESS;\n}\n\nint spi_get_status(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct spi_info *spi = &chip->spi;\n\n\tdev_dbg(rtsx_dev(chip), \"%s: err_code = 0x%x\\n\", __func__,\n\t\tspi->err_code);\n\trtsx_stor_set_xfer_buf(&spi->err_code,\n\t\t\t       min_t(int, scsi_bufflen(srb), 1), srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - 1);\n\n\treturn STATUS_SUCCESS;\n}\n\nint spi_set_parameter(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct spi_info *spi = &chip->spi;\n\n\tspi_set_err_code(chip, SPI_NO_ERR);\n\n\tif (chip->asic_code)\n\t\tspi->spi_clock = ((u16)(srb->cmnd[8]) << 8) | srb->cmnd[9];\n\telse\n\t\tspi->spi_clock = srb->cmnd[3];\n\n\tspi->clk_div = ((u16)(srb->cmnd[4]) << 8) | srb->cmnd[5];\n\tspi->write_en = srb->cmnd[6];\n\n\tdev_dbg(rtsx_dev(chip), \"spi_clock = %d, clk_div = %d, write_en = %d\\n\",\n\t\tspi->spi_clock, spi->clk_div, spi->write_en);\n\n\treturn STATUS_SUCCESS;\n}\n\nint spi_read_flash_id(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval;\n\tu16 len;\n\tu8 *buf;\n\n\tspi_set_err_code(chip, SPI_NO_ERR);\n\n\tlen = ((u16)(srb->cmnd[7]) << 8) | srb->cmnd[8];\n\tif (len > 512) {\n\t\tspi_set_err_code(chip, SPI_INVALID_COMMAND);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = spi_set_init_para(chip);\n\tif (retval != STATUS_SUCCESS) {\n\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\treturn STATUS_FAIL;\n\t}\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01,\n\t\t     PINGPONG_BUFFER);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_COMMAND, 0xFF, srb->cmnd[3]);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR2, 0xFF, srb->cmnd[4]);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR1, 0xFF, srb->cmnd[5]);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR0, 0xFF, srb->cmnd[6]);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_CA_NUMBER, 0xFF,\n\t\t     SPI_COMMAND_BIT_8 | SPI_ADDRESS_BIT_24);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_LENGTH1, 0xFF, srb->cmnd[7]);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_LENGTH0, 0xFF, srb->cmnd[8]);\n\n\tif (len == 0) {\n\t\tif (srb->cmnd[9]) {\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0,\n\t\t\t\t     0xFF, SPI_TRANSFER0_START | SPI_CA_MODE0);\n\t\t} else {\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0,\n\t\t\t\t     0xFF, SPI_TRANSFER0_START | SPI_C_MODE0);\n\t\t}\n\t} else {\n\t\tif (srb->cmnd[9]) {\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t\t\t     SPI_TRANSFER0_START | SPI_CADI_MODE0);\n\t\t} else {\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t\t\t     SPI_TRANSFER0_START | SPI_CDI_MODE0);\n\t\t}\n\t}\n\n\trtsx_add_cmd(chip, CHECK_REG_CMD, SPI_TRANSFER0, SPI_TRANSFER0_END,\n\t\t     SPI_TRANSFER0_END);\n\n\tretval = rtsx_send_cmd(chip, 0, 100);\n\tif (retval < 0) {\n\t\trtsx_clear_spi_error(chip);\n\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tif (len) {\n\t\tbuf = kmalloc(len, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn STATUS_ERROR;\n\n\t\tretval = rtsx_read_ppbuf(chip, buf, len);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tspi_set_err_code(chip, SPI_READ_ERR);\n\t\t\tkfree(buf);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\trtsx_stor_set_xfer_buf(buf, scsi_bufflen(srb), srb);\n\t\tscsi_set_resid(srb, 0);\n\n\t\tkfree(buf);\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nint spi_read_flash(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval;\n\tunsigned int index = 0, offset = 0;\n\tu8 ins, slow_read;\n\tu32 addr;\n\tu16 len;\n\tu8 *buf;\n\n\tspi_set_err_code(chip, SPI_NO_ERR);\n\n\tins = srb->cmnd[3];\n\taddr = ((u32)(srb->cmnd[4]) << 16) | ((u32)(srb->cmnd[5])\n\t\t\t\t\t<< 8) | srb->cmnd[6];\n\tlen = ((u16)(srb->cmnd[7]) << 8) | srb->cmnd[8];\n\tslow_read = srb->cmnd[9];\n\n\tretval = spi_set_init_para(chip);\n\tif (retval != STATUS_SUCCESS) {\n\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tbuf = kmalloc(SF_PAGE_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn STATUS_ERROR;\n\n\twhile (len) {\n\t\tu16 pagelen = SF_PAGE_LEN - (u8)addr;\n\n\t\tif (pagelen > len)\n\t\t\tpagelen = len;\n\n\t\trtsx_init_cmd(chip);\n\n\t\ttrans_dma_enable(DMA_FROM_DEVICE, chip, 256, DMA_256);\n\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_COMMAND, 0xFF, ins);\n\n\t\tif (slow_read) {\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR0, 0xFF,\n\t\t\t\t     (u8)addr);\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR1, 0xFF,\n\t\t\t\t     (u8)(addr >> 8));\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR2, 0xFF,\n\t\t\t\t     (u8)(addr >> 16));\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_CA_NUMBER, 0xFF,\n\t\t\t\t     SPI_COMMAND_BIT_8 | SPI_ADDRESS_BIT_24);\n\t\t} else {\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR1, 0xFF,\n\t\t\t\t     (u8)addr);\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR2, 0xFF,\n\t\t\t\t     (u8)(addr >> 8));\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_ADDR3, 0xFF,\n\t\t\t\t     (u8)(addr >> 16));\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_CA_NUMBER, 0xFF,\n\t\t\t\t     SPI_COMMAND_BIT_8 | SPI_ADDRESS_BIT_32);\n\t\t}\n\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_LENGTH1, 0xFF,\n\t\t\t     (u8)(pagelen >> 8));\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_LENGTH0, 0xFF,\n\t\t\t     (u8)pagelen);\n\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t\t     SPI_TRANSFER0_START | SPI_CADI_MODE0);\n\t\trtsx_add_cmd(chip, CHECK_REG_CMD, SPI_TRANSFER0,\n\t\t\t     SPI_TRANSFER0_END, SPI_TRANSFER0_END);\n\n\t\trtsx_send_cmd_no_wait(chip);\n\n\t\tretval = rtsx_transfer_data(chip, 0, buf, pagelen, 0,\n\t\t\t\t\t    DMA_FROM_DEVICE, 10000);\n\t\tif (retval < 0) {\n\t\t\tkfree(buf);\n\t\t\trtsx_clear_spi_error(chip);\n\t\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\trtsx_stor_access_xfer_buf(buf, pagelen, srb, &index, &offset,\n\t\t\t\t\t  TO_XFER_BUF);\n\n\t\taddr += pagelen;\n\t\tlen -= pagelen;\n\t}\n\n\tscsi_set_resid(srb, 0);\n\tkfree(buf);\n\n\treturn STATUS_SUCCESS;\n}\n\nint spi_write_flash(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval;\n\tu8 ins, program_mode;\n\tu32 addr;\n\tu16 len;\n\tu8 *buf;\n\tunsigned int index = 0, offset = 0;\n\n\tspi_set_err_code(chip, SPI_NO_ERR);\n\n\tins = srb->cmnd[3];\n\taddr = ((u32)(srb->cmnd[4]) << 16) | ((u32)(srb->cmnd[5])\n\t\t\t\t\t<< 8) | srb->cmnd[6];\n\tlen = ((u16)(srb->cmnd[7]) << 8) | srb->cmnd[8];\n\tprogram_mode = srb->cmnd[9];\n\n\tretval = spi_set_init_para(chip);\n\tif (retval != STATUS_SUCCESS) {\n\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tif (program_mode == BYTE_PROGRAM) {\n\t\tbuf = kmalloc(4, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn STATUS_ERROR;\n\n\t\twhile (len) {\n\t\t\tretval = sf_enable_write(chip, SPI_WREN);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\trtsx_stor_access_xfer_buf(buf, 1, srb, &index, &offset,\n\t\t\t\t\t\t  FROM_XFER_BUF);\n\n\t\t\trtsx_init_cmd(chip);\n\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t\t     0x01, PINGPONG_BUFFER);\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, PPBUF_BASE2, 0xFF,\n\t\t\t\t     buf[0]);\n\t\t\tsf_program(chip, ins, 1, addr, 1);\n\n\t\t\tretval = rtsx_send_cmd(chip, 0, 100);\n\t\t\tif (retval < 0) {\n\t\t\t\tkfree(buf);\n\t\t\t\trtsx_clear_spi_error(chip);\n\t\t\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\tretval = sf_polling_status(chip, 100);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\taddr++;\n\t\t\tlen--;\n\t\t}\n\n\t\tkfree(buf);\n\n\t} else if (program_mode == AAI_PROGRAM) {\n\t\tint first_byte = 1;\n\n\t\tretval = sf_enable_write(chip, SPI_WREN);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tbuf = kmalloc(4, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn STATUS_ERROR;\n\n\t\twhile (len) {\n\t\t\trtsx_stor_access_xfer_buf(buf, 1, srb, &index, &offset,\n\t\t\t\t\t\t  FROM_XFER_BUF);\n\n\t\t\trtsx_init_cmd(chip);\n\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t\t     0x01, PINGPONG_BUFFER);\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD, PPBUF_BASE2, 0xFF,\n\t\t\t\t     buf[0]);\n\t\t\tif (first_byte) {\n\t\t\t\tsf_program(chip, ins, 1, addr, 1);\n\t\t\t\tfirst_byte = 0;\n\t\t\t} else {\n\t\t\t\tsf_program(chip, ins, 0, 0, 1);\n\t\t\t}\n\n\t\t\tretval = rtsx_send_cmd(chip, 0, 100);\n\t\t\tif (retval < 0) {\n\t\t\t\tkfree(buf);\n\t\t\t\trtsx_clear_spi_error(chip);\n\t\t\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\tretval = sf_polling_status(chip, 100);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\tlen--;\n\t\t}\n\n\t\tkfree(buf);\n\n\t\tretval = sf_disable_write(chip, SPI_WRDI);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = sf_polling_status(chip, 100);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t} else if (program_mode == PAGE_PROGRAM) {\n\t\tbuf = kmalloc(SF_PAGE_LEN, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn STATUS_NOMEM;\n\n\t\twhile (len) {\n\t\t\tu16 pagelen = SF_PAGE_LEN - (u8)addr;\n\n\t\t\tif (pagelen > len)\n\t\t\t\tpagelen = len;\n\n\t\t\tretval = sf_enable_write(chip, SPI_WREN);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\trtsx_init_cmd(chip);\n\n\t\t\ttrans_dma_enable(DMA_TO_DEVICE, chip, 256, DMA_256);\n\t\t\tsf_program(chip, ins, 1, addr, pagelen);\n\n\t\t\trtsx_send_cmd_no_wait(chip);\n\n\t\t\trtsx_stor_access_xfer_buf(buf, pagelen, srb, &index,\n\t\t\t\t\t\t  &offset, FROM_XFER_BUF);\n\n\t\t\tretval = rtsx_transfer_data(chip, 0, buf, pagelen, 0,\n\t\t\t\t\t\t    DMA_TO_DEVICE, 100);\n\t\t\tif (retval < 0) {\n\t\t\t\tkfree(buf);\n\t\t\t\trtsx_clear_spi_error(chip);\n\t\t\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\tretval = sf_polling_status(chip, 100);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\taddr += pagelen;\n\t\t\tlen -= pagelen;\n\t\t}\n\n\t\tkfree(buf);\n\t} else {\n\t\tspi_set_err_code(chip, SPI_INVALID_COMMAND);\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nint spi_erase_flash(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval;\n\tu8 ins, erase_mode;\n\tu32 addr;\n\n\tspi_set_err_code(chip, SPI_NO_ERR);\n\n\tins = srb->cmnd[3];\n\taddr = ((u32)(srb->cmnd[4]) << 16) | ((u32)(srb->cmnd[5])\n\t\t\t\t\t<< 8) | srb->cmnd[6];\n\terase_mode = srb->cmnd[9];\n\n\tretval = spi_set_init_para(chip);\n\tif (retval != STATUS_SUCCESS) {\n\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tif (erase_mode == PAGE_ERASE) {\n\t\tretval = sf_enable_write(chip, SPI_WREN);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = sf_erase(chip, ins, 1, addr);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t} else if (erase_mode == CHIP_ERASE) {\n\t\tretval = sf_enable_write(chip, SPI_WREN);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = sf_erase(chip, ins, 0, 0);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t} else {\n\t\tspi_set_err_code(chip, SPI_INVALID_COMMAND);\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nint spi_write_flash_status(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval;\n\tu8 ins, status, ewsr;\n\n\tins = srb->cmnd[3];\n\tstatus = srb->cmnd[4];\n\tewsr = srb->cmnd[5];\n\n\tretval = spi_set_init_para(chip);\n\tif (retval != STATUS_SUCCESS) {\n\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = sf_enable_write(chip, ewsr);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01,\n\t\t     PINGPONG_BUFFER);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_COMMAND, 0xFF, ins);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_CA_NUMBER, 0xFF,\n\t\t     SPI_COMMAND_BIT_8 | SPI_ADDRESS_BIT_24);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_LENGTH1, 0xFF, 0);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_LENGTH0, 0xFF, 1);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, PPBUF_BASE2, 0xFF, status);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, SPI_TRANSFER0, 0xFF,\n\t\t     SPI_TRANSFER0_START | SPI_CDO_MODE0);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, SPI_TRANSFER0, SPI_TRANSFER0_END,\n\t\t     SPI_TRANSFER0_END);\n\n\tretval = rtsx_send_cmd(chip, 0, 100);\n\tif (retval != STATUS_SUCCESS) {\n\t\trtsx_clear_spi_error(chip);\n\t\tspi_set_err_code(chip, SPI_HW_ERR);\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}