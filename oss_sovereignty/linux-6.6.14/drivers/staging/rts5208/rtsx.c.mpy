{
  "module_name": "rtsx.c",
  "hash_id": "7c19f9b0a28c01275e4beffaeeb05609967690f5b276bd7d51a9cdd79f725a0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rts5208/rtsx.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n\n#include \"rtsx.h\"\n#include \"ms.h\"\n#include \"sd.h\"\n#include \"xd.h\"\n\nMODULE_DESCRIPTION(\"Realtek PCI-Express card reader rts5208/rts5288 driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int delay_use = 1;\nmodule_param(delay_use, uint, 0644);\nMODULE_PARM_DESC(delay_use, \"seconds to delay before using a new device\");\n\nstatic int ss_en;\nmodule_param(ss_en, int, 0644);\nMODULE_PARM_DESC(ss_en, \"enable selective suspend\");\n\nstatic int ss_interval = 50;\nmodule_param(ss_interval, int, 0644);\nMODULE_PARM_DESC(ss_interval, \"Interval to enter ss state in seconds\");\n\nstatic int auto_delink_en;\nmodule_param(auto_delink_en, int, 0644);\nMODULE_PARM_DESC(auto_delink_en, \"enable auto delink\");\n\nstatic unsigned char aspm_l0s_l1_en;\nmodule_param(aspm_l0s_l1_en, byte, 0644);\nMODULE_PARM_DESC(aspm_l0s_l1_en, \"enable device aspm\");\n\nstatic int msi_en;\nmodule_param(msi_en, int, 0644);\nMODULE_PARM_DESC(msi_en, \"enable msi\");\n\nstatic irqreturn_t rtsx_interrupt(int irq, void *dev_id);\n\n \n\nstatic const char *host_info(struct Scsi_Host *host)\n{\n\treturn \"SCSI emulation for PCI-Express Mass Storage devices\";\n}\n\nstatic int slave_alloc(struct scsi_device *sdev)\n{\n\t \n\tsdev->inquiry_len = 36;\n\treturn 0;\n}\n\nstatic int slave_configure(struct scsi_device *sdev)\n{\n\t \n\tblk_queue_dma_alignment(sdev->request_queue, (512 - 1));\n\n\t \n\tif (sdev->scsi_level < SCSI_2) {\n\t\tsdev->scsi_level = SCSI_2;\n\t\tsdev->sdev_target->scsi_level = SCSI_2;\n\t}\n\n\treturn 0;\n}\n\n \n\n \n#undef SPRINTF\n#define SPRINTF(args...) \\\n\tdo { \\\n\t\tif (pos < buffer + length) \\\n\t\t\tpos += sprintf(pos, ## args); \\\n\t} while (0)\n\n \n \nstatic int queuecommand_lck(struct scsi_cmnd *srb)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tstruct rtsx_dev *dev = host_to_rtsx(srb->device->host);\n\tstruct rtsx_chip *chip = dev->chip;\n\n\t \n\tif (chip->srb) {\n\t\tdev_err(&dev->pci->dev, \"Error: chip->srb = %p\\n\",\n\t\t\tchip->srb);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\t \n\tif (rtsx_chk_stat(chip, RTSX_STAT_DISCONNECT)) {\n\t\tdev_info(&dev->pci->dev, \"Fail command during disconnect\\n\");\n\t\tsrb->result = DID_NO_CONNECT << 16;\n\t\tdone(srb);\n\t\treturn 0;\n\t}\n\n\t \n\tchip->srb = srb;\n\tcomplete(&dev->cmnd_ready);\n\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(queuecommand)\n\n \n\n \nstatic int command_abort(struct scsi_cmnd *srb)\n{\n\tstruct Scsi_Host *host = srb->device->host;\n\tstruct rtsx_dev *dev = host_to_rtsx(host);\n\tstruct rtsx_chip *chip = dev->chip;\n\n\tscsi_lock(host);\n\n\t \n\tif (chip->srb != srb) {\n\t\tscsi_unlock(host);\n\t\tdev_info(&dev->pci->dev, \"-- nothing to abort\\n\");\n\t\treturn FAILED;\n\t}\n\n\trtsx_set_stat(chip, RTSX_STAT_ABORT);\n\n\tscsi_unlock(host);\n\n\t \n\twait_for_completion(&dev->notify);\n\n\treturn SUCCESS;\n}\n\n \nstatic int device_reset(struct scsi_cmnd *srb)\n{\n\treturn SUCCESS;\n}\n\n \n\nstatic const struct scsi_host_template rtsx_host_template = {\n\t \n\t.name =\t\t\t\tCR_DRIVER_NAME,\n\t.proc_name =\t\t\tCR_DRIVER_NAME,\n\t.info =\t\t\t\thost_info,\n\n\t \n\t.queuecommand =\t\t\tqueuecommand,\n\n\t \n\t.eh_abort_handler =\t\tcommand_abort,\n\t.eh_device_reset_handler =\tdevice_reset,\n\n\t \n\t.can_queue =\t\t\t1,\n\n\t \n\t.this_id =\t\t\t-1,\n\n\t.slave_alloc =\t\t\tslave_alloc,\n\t.slave_configure =\t\tslave_configure,\n\n\t \n\t.sg_tablesize =\t\t\tSG_ALL,\n\n\t \n\t.max_sectors =                  240,\n\n\t \n\t.emulated =\t\t\t1,\n\n\t \n\t.skip_settle_delay =\t\t1,\n\n\t \n\t.module =\t\t\tTHIS_MODULE\n};\n\nstatic int rtsx_acquire_irq(struct rtsx_dev *dev)\n{\n\tstruct rtsx_chip *chip = dev->chip;\n\n\tdev_info(&dev->pci->dev, \"%s: chip->msi_en = %d, pci->irq = %d\\n\",\n\t\t __func__, chip->msi_en, dev->pci->irq);\n\n\tif (request_irq(dev->pci->irq, rtsx_interrupt,\n\t\t\tchip->msi_en ? 0 : IRQF_SHARED,\n\t\t\tCR_DRIVER_NAME, dev)) {\n\t\tdev_err(&dev->pci->dev,\n\t\t\t\"rtsx: unable to grab IRQ %d, disabling device\\n\",\n\t\t\tdev->pci->irq);\n\t\treturn -1;\n\t}\n\n\tdev->irq = dev->pci->irq;\n\tpci_intx(dev->pci, !chip->msi_en);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused rtsx_suspend(struct device *dev_d)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev_d);\n\tstruct rtsx_dev *dev = pci_get_drvdata(pci);\n\tstruct rtsx_chip *chip;\n\n\tif (!dev)\n\t\treturn 0;\n\n\t \n\tmutex_lock(&dev->dev_mutex);\n\n\tchip = dev->chip;\n\n\trtsx_do_before_power_down(chip, PM_S3);\n\n\tif (dev->irq >= 0) {\n\t\tfree_irq(dev->irq, (void *)dev);\n\t\tdev->irq = -1;\n\t}\n\n\tif (chip->msi_en)\n\t\tpci_free_irq_vectors(pci);\n\n\tdevice_wakeup_enable(dev_d);\n\n\t \n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rtsx_resume(struct device *dev_d)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev_d);\n\tstruct rtsx_dev *dev = pci_get_drvdata(pci);\n\tstruct rtsx_chip *chip;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tchip = dev->chip;\n\n\t \n\tmutex_lock(&dev->dev_mutex);\n\n\tpci_set_master(pci);\n\n\tif (chip->msi_en) {\n\t\tif (pci_alloc_irq_vectors(pci, 1, 1, PCI_IRQ_MSI) < 0)\n\t\t\tchip->msi_en = 0;\n\t}\n\n\tif (rtsx_acquire_irq(dev) < 0) {\n\t\t \n\t\tmutex_unlock(&dev->dev_mutex);\n\t\treturn -EIO;\n\t}\n\n\trtsx_write_register(chip, HOST_SLEEP_STATE, 0x03, 0x00);\n\trtsx_init_chip(chip);\n\n\t \n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn 0;\n}\n\nstatic void rtsx_shutdown(struct pci_dev *pci)\n{\n\tstruct rtsx_dev *dev = pci_get_drvdata(pci);\n\tstruct rtsx_chip *chip;\n\n\tif (!dev)\n\t\treturn;\n\n\tchip = dev->chip;\n\n\trtsx_do_before_power_down(chip, PM_S1);\n\n\tif (dev->irq >= 0) {\n\t\tfree_irq(dev->irq, (void *)dev);\n\t\tdev->irq = -1;\n\t}\n\n\tif (chip->msi_en)\n\t\tpci_free_irq_vectors(pci);\n\n\tpci_disable_device(pci);\n}\n\nstatic int rtsx_control_thread(void *__dev)\n{\n\tstruct rtsx_dev *dev = __dev;\n\tstruct rtsx_chip *chip = dev->chip;\n\tstruct Scsi_Host *host = rtsx_to_host(dev);\n\n\tfor (;;) {\n\t\tif (wait_for_completion_interruptible(&dev->cmnd_ready))\n\t\t\tbreak;\n\n\t\t \n\t\tmutex_lock(&dev->dev_mutex);\n\n\t\t \n\t\tif (rtsx_chk_stat(chip, RTSX_STAT_DISCONNECT)) {\n\t\t\tdev_info(&dev->pci->dev, \"-- rtsx-control exiting\\n\");\n\t\t\tmutex_unlock(&dev->dev_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tscsi_lock(host);\n\n\t\t \n\t\tif (rtsx_chk_stat(chip, RTSX_STAT_ABORT)) {\n\t\t\tchip->srb->result = DID_ABORT << 16;\n\t\t\tgoto skip_for_abort;\n\t\t}\n\n\t\tscsi_unlock(host);\n\n\t\t \n\t\tif (chip->srb->sc_data_direction == DMA_BIDIRECTIONAL) {\n\t\t\tdev_err(&dev->pci->dev, \"UNKNOWN data direction\\n\");\n\t\t\tchip->srb->result = DID_ERROR << 16;\n\t\t} else if (chip->srb->device->id) {\n\t\t\t \n\t\t\tdev_err(&dev->pci->dev, \"Bad target number (%d:%d)\\n\",\n\t\t\t\tchip->srb->device->id,\n\t\t\t\t(u8)chip->srb->device->lun);\n\t\t\tchip->srb->result = DID_BAD_TARGET << 16;\n\t\t} else if (chip->srb->device->lun > chip->max_lun) {\n\t\t\tdev_err(&dev->pci->dev, \"Bad LUN (%d:%d)\\n\",\n\t\t\t\tchip->srb->device->id,\n\t\t\t\t(u8)chip->srb->device->lun);\n\t\t\tchip->srb->result = DID_BAD_TARGET << 16;\n\t\t} else {\n\t\t\t \n\t\t\tscsi_show_command(chip);\n\t\t\trtsx_invoke_transport(chip->srb, chip);\n\t\t}\n\n\t\t \n\t\tscsi_lock(host);\n\n\t\t \n\t\tif (!chip->srb)\n\t\t\t;\t\t \n\n\t\t \n\t\telse if (chip->srb->result != DID_ABORT << 16) {\n\t\t\tscsi_done(chip->srb);\n\t\t} else {\nskip_for_abort:\n\t\t\tdev_err(&dev->pci->dev, \"scsi command aborted\\n\");\n\t\t}\n\n\t\tif (rtsx_chk_stat(chip, RTSX_STAT_ABORT)) {\n\t\t\tcomplete(&dev->notify);\n\n\t\t\trtsx_set_stat(chip, RTSX_STAT_IDLE);\n\t\t}\n\n\t\t \n\t\tchip->srb = NULL;\n\t\tscsi_unlock(host);\n\n\t\t \n\t\tmutex_unlock(&dev->dev_mutex);\n\t}  \n\n\t \n\tkthread_complete_and_exit(&dev->control_exit, 0);\n}\n\nstatic int rtsx_polling_thread(void *__dev)\n{\n\tstruct rtsx_dev *dev = __dev;\n\tstruct rtsx_chip *chip = dev->chip;\n\tstruct sd_info *sd_card = &chip->sd_card;\n\tstruct xd_info *xd_card = &chip->xd_card;\n\tstruct ms_info *ms_card = &chip->ms_card;\n\n\tsd_card->cleanup_counter = 0;\n\txd_card->cleanup_counter = 0;\n\tms_card->cleanup_counter = 0;\n\n\t \n\twait_timeout((delay_use + 5) * 1000);\n\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(msecs_to_jiffies(POLLING_INTERVAL));\n\n\t\t \n\t\tmutex_lock(&dev->dev_mutex);\n\n\t\t \n\t\tif (rtsx_chk_stat(chip, RTSX_STAT_DISCONNECT)) {\n\t\t\tdev_info(&dev->pci->dev, \"-- rtsx-polling exiting\\n\");\n\t\t\tmutex_unlock(&dev->dev_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_unlock(&dev->dev_mutex);\n\n\t\tmspro_polling_format_status(chip);\n\n\t\t \n\t\tmutex_lock(&dev->dev_mutex);\n\n\t\trtsx_polling_func(chip);\n\n\t\t \n\t\tmutex_unlock(&dev->dev_mutex);\n\t}\n\n\tkthread_complete_and_exit(&dev->polling_exit, 0);\n}\n\n \nstatic irqreturn_t rtsx_interrupt(int irq, void *dev_id)\n{\n\tstruct rtsx_dev *dev = dev_id;\n\tstruct rtsx_chip *chip;\n\tint retval;\n\tu32 status;\n\n\tif (dev)\n\t\tchip = dev->chip;\n\telse\n\t\treturn IRQ_NONE;\n\n\tif (!chip)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&dev->reg_lock);\n\n\tretval = rtsx_pre_handle_interrupt(chip);\n\tif (retval == STATUS_FAIL) {\n\t\tspin_unlock(&dev->reg_lock);\n\t\tif (chip->int_reg == 0xFFFFFFFF)\n\t\t\treturn IRQ_HANDLED;\n\t\treturn IRQ_NONE;\n\t}\n\n\tstatus = chip->int_reg;\n\n\tif (dev->check_card_cd) {\n\t\tif (!(dev->check_card_cd & status)) {\n\t\t\t \n\t\t\tdev->trans_result = TRANS_RESULT_FAIL;\n\t\t\tif (dev->done)\n\t\t\t\tcomplete(dev->done);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (status & (NEED_COMPLETE_INT | DELINK_INT)) {\n\t\tif (status & (TRANS_FAIL_INT | DELINK_INT)) {\n\t\t\tif (status & DELINK_INT)\n\t\t\t\tRTSX_SET_DELINK(chip);\n\t\t\tdev->trans_result = TRANS_RESULT_FAIL;\n\t\t\tif (dev->done)\n\t\t\t\tcomplete(dev->done);\n\t\t} else if (status & TRANS_OK_INT) {\n\t\t\tdev->trans_result = TRANS_RESULT_OK;\n\t\t\tif (dev->done)\n\t\t\t\tcomplete(dev->done);\n\t\t} else if (status & DATA_DONE_INT) {\n\t\t\tdev->trans_result = TRANS_NOT_READY;\n\t\t\tif (dev->done && dev->trans_state == STATE_TRANS_SG)\n\t\t\t\tcomplete(dev->done);\n\t\t}\n\t}\n\nexit:\n\tspin_unlock(&dev->reg_lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void rtsx_release_resources(struct rtsx_dev *dev)\n{\n\tdev_info(&dev->pci->dev, \"-- %s\\n\", __func__);\n\n\t \n\tdev_info(&dev->pci->dev, \"-- sending exit command to thread\\n\");\n\tcomplete(&dev->cmnd_ready);\n\tif (dev->ctl_thread)\n\t\twait_for_completion(&dev->control_exit);\n\tif (dev->polling_thread)\n\t\twait_for_completion(&dev->polling_exit);\n\n\twait_timeout(200);\n\n\tif (dev->rtsx_resv_buf) {\n\t\tdev->chip->host_cmds_ptr = NULL;\n\t\tdev->chip->host_sg_tbl_ptr = NULL;\n\t}\n\n\tif (dev->irq > 0)\n\t\tfree_irq(dev->irq, (void *)dev);\n\tif (dev->chip->msi_en)\n\t\tpci_free_irq_vectors(dev->pci);\n\tif (dev->remap_addr)\n\t\tiounmap(dev->remap_addr);\n\n\trtsx_release_chip(dev->chip);\n\tkfree(dev->chip);\n}\n\n \nstatic void quiesce_and_remove_host(struct rtsx_dev *dev)\n{\n\tstruct Scsi_Host *host = rtsx_to_host(dev);\n\tstruct rtsx_chip *chip = dev->chip;\n\n\t \n\tmutex_lock(&dev->dev_mutex);\n\tscsi_lock(host);\n\trtsx_set_stat(chip, RTSX_STAT_DISCONNECT);\n\tscsi_unlock(host);\n\tmutex_unlock(&dev->dev_mutex);\n\twake_up(&dev->delay_wait);\n\twait_for_completion(&dev->scanning_done);\n\n\t \n\twait_timeout(100);\n\n\t \n\tmutex_lock(&dev->dev_mutex);\n\tif (chip->srb) {\n\t\tchip->srb->result = DID_NO_CONNECT << 16;\n\t\tscsi_lock(host);\n\t\tscsi_done(dev->chip->srb);\n\t\tchip->srb = NULL;\n\t\tscsi_unlock(host);\n\t}\n\tmutex_unlock(&dev->dev_mutex);\n\n\t \n\tscsi_remove_host(host);\n}\n\n \nstatic void release_everything(struct rtsx_dev *dev)\n{\n\trtsx_release_resources(dev);\n\n\t \n\tscsi_host_put(rtsx_to_host(dev));\n}\n\n \nstatic int rtsx_scan_thread(void *__dev)\n{\n\tstruct rtsx_dev *dev = __dev;\n\tstruct rtsx_chip *chip = dev->chip;\n\n\t \n\tif (delay_use > 0) {\n\t\tdev_info(&dev->pci->dev,\n\t\t\t \"%s: waiting for device to settle before scanning\\n\",\n\t\t\t CR_DRIVER_NAME);\n\t\twait_event_interruptible_timeout\n\t\t\t(dev->delay_wait,\n\t\t\t rtsx_chk_stat(chip, RTSX_STAT_DISCONNECT),\n\t\t\t delay_use * HZ);\n\t}\n\n\t \n\tif (!rtsx_chk_stat(chip, RTSX_STAT_DISCONNECT)) {\n\t\tscsi_scan_host(rtsx_to_host(dev));\n\t\tdev_info(&dev->pci->dev, \"%s: device scan complete\\n\",\n\t\t\t CR_DRIVER_NAME);\n\n\t\t \n\t}\n\n\tkthread_complete_and_exit(&dev->scanning_done, 0);\n}\n\nstatic void rtsx_init_options(struct rtsx_chip *chip)\n{\n\tchip->vendor_id = chip->rtsx->pci->vendor;\n\tchip->product_id = chip->rtsx->pci->device;\n\tchip->adma_mode = 1;\n\tchip->lun_mc = 0;\n\tchip->driver_first_load = 1;\n#ifdef HW_AUTO_SWITCH_SD_BUS\n\tchip->sdio_in_charge = 0;\n#endif\n\n\tchip->mspro_formatter_enable = 1;\n\tchip->ignore_sd = 0;\n\tchip->use_hw_setting = 0;\n\tchip->lun_mode = DEFAULT_SINGLE;\n\tchip->auto_delink_en = auto_delink_en;\n\tchip->ss_en = ss_en;\n\tchip->ss_idle_period = ss_interval * 1000;\n\tchip->remote_wakeup_en = 0;\n\tchip->aspm_l0s_l1_en = aspm_l0s_l1_en;\n\tchip->dynamic_aspm = 1;\n\tchip->fpga_sd_sdr104_clk = CLK_200;\n\tchip->fpga_sd_ddr50_clk = CLK_100;\n\tchip->fpga_sd_sdr50_clk = CLK_100;\n\tchip->fpga_sd_hs_clk = CLK_100;\n\tchip->fpga_mmc_52m_clk = CLK_80;\n\tchip->fpga_ms_hg_clk = CLK_80;\n\tchip->fpga_ms_4bit_clk = CLK_80;\n\tchip->fpga_ms_1bit_clk = CLK_40;\n\tchip->asic_sd_sdr104_clk = 203;\n\tchip->asic_sd_sdr50_clk = 98;\n\tchip->asic_sd_ddr50_clk = 98;\n\tchip->asic_sd_hs_clk = 98;\n\tchip->asic_mmc_52m_clk = 98;\n\tchip->asic_ms_hg_clk = 117;\n\tchip->asic_ms_4bit_clk = 78;\n\tchip->asic_ms_1bit_clk = 39;\n\tchip->ssc_depth_sd_sdr104 = SSC_DEPTH_2M;\n\tchip->ssc_depth_sd_sdr50 = SSC_DEPTH_2M;\n\tchip->ssc_depth_sd_ddr50 = SSC_DEPTH_1M;\n\tchip->ssc_depth_sd_hs = SSC_DEPTH_1M;\n\tchip->ssc_depth_mmc_52m = SSC_DEPTH_1M;\n\tchip->ssc_depth_ms_hg = SSC_DEPTH_1M;\n\tchip->ssc_depth_ms_4bit = SSC_DEPTH_512K;\n\tchip->ssc_depth_low_speed = SSC_DEPTH_512K;\n\tchip->ssc_en = 1;\n\tchip->sd_speed_prior = 0x01040203;\n\tchip->sd_current_prior = 0x00010203;\n\tchip->sd_ctl = SD_PUSH_POINT_AUTO |\n\t\t       SD_SAMPLE_POINT_AUTO |\n\t\t       SUPPORT_MMC_DDR_MODE;\n\tchip->sd_ddr_tx_phase = 0;\n\tchip->mmc_ddr_tx_phase = 1;\n\tchip->sd_default_tx_phase = 15;\n\tchip->sd_default_rx_phase = 15;\n\tchip->pmos_pwr_on_interval = 200;\n\tchip->sd_voltage_switch_delay = 1000;\n\tchip->ms_power_class_en = 3;\n\n\tchip->sd_400mA_ocp_thd = 1;\n\tchip->sd_800mA_ocp_thd = 5;\n\tchip->ms_ocp_thd = 2;\n\n\tchip->card_drive_sel = 0x55;\n\tchip->sd30_drive_sel_1v8 = 0x03;\n\tchip->sd30_drive_sel_3v3 = 0x01;\n\n\tchip->do_delink_before_power_down = 1;\n\tchip->auto_power_down = 1;\n\tchip->polling_config = 0;\n\n\tchip->force_clkreq_0 = 1;\n\tchip->ft2_fast_mode = 0;\n\n\tchip->sdio_retry_cnt = 1;\n\n\tchip->xd_timeout = 2000;\n\tchip->sd_timeout = 10000;\n\tchip->ms_timeout = 2000;\n\tchip->mspro_timeout = 15000;\n\n\tchip->power_down_in_ss = 1;\n\n\tchip->sdr104_en = 1;\n\tchip->sdr50_en = 1;\n\tchip->ddr50_en = 1;\n\n\tchip->delink_stage1_step = 100;\n\tchip->delink_stage2_step = 40;\n\tchip->delink_stage3_step = 20;\n\n\tchip->auto_delink_in_L1 = 1;\n\tchip->blink_led = 1;\n\tchip->msi_en = msi_en;\n\tchip->hp_watch_bios_hotplug = 0;\n\tchip->max_payload = 0;\n\tchip->phy_voltage = 0;\n\n\tchip->support_ms_8bit = 1;\n\tchip->s3_pwr_off_delay = 1000;\n}\n\nstatic int rtsx_probe(struct pci_dev *pci,\n\t\t      const struct pci_device_id *pci_id)\n{\n\tstruct Scsi_Host *host;\n\tstruct rtsx_dev *dev;\n\tint err = 0;\n\tstruct task_struct *th;\n\n\tdev_dbg(&pci->dev, \"Realtek PCI-E card reader detected\\n\");\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0) {\n\t\tdev_err(&pci->dev, \"PCI enable device failed!\\n\");\n\t\treturn err;\n\t}\n\n\terr = pci_request_regions(pci, CR_DRIVER_NAME);\n\tif (err < 0) {\n\t\tdev_err(&pci->dev, \"PCI request regions for %s failed!\\n\",\n\t\t\tCR_DRIVER_NAME);\n\t\treturn err;\n\t}\n\n\t \n\thost = scsi_host_alloc(&rtsx_host_template, sizeof(*dev));\n\tif (!host) {\n\t\tdev_err(&pci->dev, \"Unable to allocate the scsi host\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto scsi_host_alloc_fail;\n\t}\n\n\tdev = host_to_rtsx(host);\n\tmemset(dev, 0, sizeof(struct rtsx_dev));\n\n\tdev->chip = kzalloc(sizeof(*dev->chip), GFP_KERNEL);\n\tif (!dev->chip) {\n\t\terr = -ENOMEM;\n\t\tgoto chip_alloc_fail;\n\t}\n\n\tspin_lock_init(&dev->reg_lock);\n\tmutex_init(&dev->dev_mutex);\n\tinit_completion(&dev->cmnd_ready);\n\tinit_completion(&dev->control_exit);\n\tinit_completion(&dev->polling_exit);\n\tinit_completion(&dev->notify);\n\tinit_completion(&dev->scanning_done);\n\tinit_waitqueue_head(&dev->delay_wait);\n\n\tdev->pci = pci;\n\tdev->irq = -1;\n\n\tdev_info(&pci->dev, \"Resource length: 0x%x\\n\",\n\t\t (unsigned int)pci_resource_len(pci, 0));\n\tdev->addr = pci_resource_start(pci, 0);\n\tdev->remap_addr = ioremap(dev->addr, pci_resource_len(pci, 0));\n\tif (!dev->remap_addr) {\n\t\tdev_err(&pci->dev, \"ioremap error\\n\");\n\t\terr = -ENXIO;\n\t\tgoto ioremap_fail;\n\t}\n\n\t \n\tdev_info(&pci->dev, \"Original address: 0x%lx, remapped address: 0x%lx\\n\",\n\t\t (unsigned long)(dev->addr), (unsigned long)(dev->remap_addr));\n\n\tdev->rtsx_resv_buf = dmam_alloc_coherent(&pci->dev, RTSX_RESV_BUF_LEN,\n\t\t\t\t\t\t &dev->rtsx_resv_buf_addr,\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!dev->rtsx_resv_buf) {\n\t\tdev_err(&pci->dev, \"alloc dma buffer fail\\n\");\n\t\terr = -ENXIO;\n\t\tgoto dma_alloc_fail;\n\t}\n\tdev->chip->host_cmds_ptr = dev->rtsx_resv_buf;\n\tdev->chip->host_cmds_addr = dev->rtsx_resv_buf_addr;\n\tdev->chip->host_sg_tbl_ptr = dev->rtsx_resv_buf + HOST_CMDS_BUF_LEN;\n\tdev->chip->host_sg_tbl_addr = dev->rtsx_resv_buf_addr +\n\t\t\t\t      HOST_CMDS_BUF_LEN;\n\n\tdev->chip->rtsx = dev;\n\n\trtsx_init_options(dev->chip);\n\n\tdev_info(&pci->dev, \"pci->irq = %d\\n\", pci->irq);\n\n\tif (dev->chip->msi_en) {\n\t\tif (pci_alloc_irq_vectors(pci, 1, 1, PCI_IRQ_MSI) < 0)\n\t\t\tdev->chip->msi_en = 0;\n\t}\n\n\tif (rtsx_acquire_irq(dev) < 0) {\n\t\terr = -EBUSY;\n\t\tgoto irq_acquire_fail;\n\t}\n\n\tpci_set_master(pci);\n\tsynchronize_irq(dev->irq);\n\n\trtsx_init_chip(dev->chip);\n\n\t \n\thost->max_id = 1;\n\thost->max_lun = dev->chip->max_lun;\n\n\t \n\tth = kthread_run(rtsx_control_thread, dev, CR_DRIVER_NAME);\n\tif (IS_ERR(th)) {\n\t\tdev_err(&pci->dev, \"Unable to start control thread\\n\");\n\t\terr = PTR_ERR(th);\n\t\tgoto control_thread_fail;\n\t}\n\tdev->ctl_thread = th;\n\n\terr = scsi_add_host(host, &pci->dev);\n\tif (err) {\n\t\tdev_err(&pci->dev, \"Unable to add the scsi host\\n\");\n\t\tgoto scsi_add_host_fail;\n\t}\n\n\t \n\tth = kthread_run(rtsx_scan_thread, dev, \"rtsx-scan\");\n\tif (IS_ERR(th)) {\n\t\tdev_err(&pci->dev, \"Unable to start the device-scanning thread\\n\");\n\t\tcomplete(&dev->scanning_done);\n\t\terr = PTR_ERR(th);\n\t\tgoto scan_thread_fail;\n\t}\n\n\t \n\tth = kthread_run(rtsx_polling_thread, dev, \"rtsx-polling\");\n\tif (IS_ERR(th)) {\n\t\tdev_err(&pci->dev, \"Unable to start the device-polling thread\\n\");\n\t\terr = PTR_ERR(th);\n\t\tgoto scan_thread_fail;\n\t}\n\tdev->polling_thread = th;\n\n\tpci_set_drvdata(pci, dev);\n\n\treturn 0;\n\n\t \nscan_thread_fail:\n\tquiesce_and_remove_host(dev);\nscsi_add_host_fail:\n\tcomplete(&dev->cmnd_ready);\n\twait_for_completion(&dev->control_exit);\ncontrol_thread_fail:\n\tfree_irq(dev->irq, (void *)dev);\n\trtsx_release_chip(dev->chip);\nirq_acquire_fail:\n\tdev->chip->host_cmds_ptr = NULL;\n\tdev->chip->host_sg_tbl_ptr = NULL;\n\tif (dev->chip->msi_en)\n\t\tpci_free_irq_vectors(dev->pci);\ndma_alloc_fail:\n\tiounmap(dev->remap_addr);\nioremap_fail:\n\tkfree(dev->chip);\nchip_alloc_fail:\n\tdev_err(&pci->dev, \"%s failed\\n\", __func__);\n\tscsi_host_put(host);\nscsi_host_alloc_fail:\n\tpci_release_regions(pci);\n\treturn err;\n}\n\nstatic void rtsx_remove(struct pci_dev *pci)\n{\n\tstruct rtsx_dev *dev = pci_get_drvdata(pci);\n\n\tquiesce_and_remove_host(dev);\n\trelease_everything(dev);\n\tpci_release_regions(pci);\n}\n\n \nstatic const struct pci_device_id rtsx_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x5208),\n\t\tPCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x5288),\n\t\tPCI_CLASS_OTHERS << 16, 0xFF0000 },\n\t{ 0, },\n};\n\nMODULE_DEVICE_TABLE(pci, rtsx_ids);\n\nstatic SIMPLE_DEV_PM_OPS(rtsx_pm_ops, rtsx_suspend, rtsx_resume);\n\n \nstatic struct pci_driver rtsx_driver = {\n\t.name = CR_DRIVER_NAME,\n\t.id_table = rtsx_ids,\n\t.probe = rtsx_probe,\n\t.remove = rtsx_remove,\n\t.driver.pm = &rtsx_pm_ops,\n\t.shutdown = rtsx_shutdown,\n};\n\nmodule_pci_driver(rtsx_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}