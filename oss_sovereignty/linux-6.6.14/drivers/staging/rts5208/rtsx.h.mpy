{
  "module_name": "rtsx.h",
  "hash_id": "2ad2fbd454b05694df863a1254a5aada13893175eb603d72d8db25fdf4d5d865",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rts5208/rtsx.h",
  "human_readable_source": " \n \n\n#ifndef __REALTEK_RTSX_H\n#define __REALTEK_RTSX_H\n\n#include <linux/io.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/cdrom.h>\n#include <linux/workqueue.h>\n#include <linux/timer.h>\n#include <linux/time64.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_devinfo.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n\n#define CR_DRIVER_NAME\t\t\"rts5208\"\n\n \n#define rtsx_writel(chip, reg, value) \\\n\tiowrite32(value, (chip)->rtsx->remap_addr + reg)\n#define rtsx_readl(chip, reg) \\\n\tioread32((chip)->rtsx->remap_addr + reg)\n#define rtsx_writew(chip, reg, value) \\\n\tiowrite16(value, (chip)->rtsx->remap_addr + reg)\n#define rtsx_readw(chip, reg) \\\n\tioread16((chip)->rtsx->remap_addr + reg)\n#define rtsx_writeb(chip, reg, value) \\\n\tiowrite8(value, (chip)->rtsx->remap_addr + reg)\n#define rtsx_readb(chip, reg) \\\n\tioread8((chip)->rtsx->remap_addr + reg)\n\n#define rtsx_read_config_byte(chip, where, val) \\\n\tpci_read_config_byte((chip)->rtsx->pci, where, val)\n\n#define rtsx_write_config_byte(chip, where, val) \\\n\tpci_write_config_byte((chip)->rtsx->pci, where, val)\n\n#define wait_timeout_x(task_state, msecs)\t\\\ndo {\t\t\t\t\t\t\\\n\tset_current_state((task_state));\t\\\n\tschedule_timeout((msecs) * HZ / 1000);\t\\\n} while (0)\n#define wait_timeout(msecs)\twait_timeout_x(TASK_INTERRUPTIBLE, (msecs))\n\n#define STATE_TRANS_NONE\t0\n#define STATE_TRANS_CMD\t\t1\n#define STATE_TRANS_BUF\t\t2\n#define STATE_TRANS_SG\t\t3\n\n#define TRANS_NOT_READY\t\t0\n#define TRANS_RESULT_OK\t\t1\n#define TRANS_RESULT_FAIL\t2\n\n#define SCSI_LUN(srb)\t\t((srb)->device->lun)\n\nstruct rtsx_chip;\n\nstruct rtsx_dev {\n\tstruct pci_dev *pci;\n\n\t \n\tunsigned long\t\taddr;\n\tvoid __iomem\t\t*remap_addr;\n\tint irq;\n\n\t \n\tspinlock_t\t\treg_lock;\n\n\tstruct task_struct\t*ctl_thread;\t  \n\tstruct task_struct\t*polling_thread;  \n\n\t \n\tstruct completion\tcmnd_ready;\t  \n\tstruct completion\tcontrol_exit;\t  \n\tstruct completion\tpolling_exit;\t  \n\tstruct completion\tnotify;\t\t  \n\tstruct completion\tscanning_done;\t  \n\n\twait_queue_head_t\tdelay_wait;\t  \n\tstruct mutex\t\tdev_mutex;\n\n\t \n\tvoid\t\t\t*rtsx_resv_buf;\n\tdma_addr_t\t\trtsx_resv_buf_addr;\n\n\tchar\t\t\ttrans_result;\n\tchar\t\t\ttrans_state;\n\n\tstruct completion\t*done;\n\t \n\tu32\t\t\tcheck_card_cd;\n\n\tstruct rtsx_chip\t*chip;\n};\n\n \nstatic inline struct Scsi_Host *rtsx_to_host(struct rtsx_dev *dev)\n{\n\treturn container_of((void *)dev, struct Scsi_Host, hostdata);\n}\n\nstatic inline struct rtsx_dev *host_to_rtsx(struct Scsi_Host *host)\n{\n\treturn (struct rtsx_dev *)host->hostdata;\n}\n\n \n#define scsi_unlock(host)\tspin_unlock_irq(host->host_lock)\n#define scsi_lock(host)\t\tspin_lock_irq(host->host_lock)\n\n#define lock_state(chip)\tspin_lock_irq(&((chip)->rtsx->reg_lock))\n#define unlock_state(chip)\tspin_unlock_irq(&((chip)->rtsx->reg_lock))\n\n \nenum xfer_buf_dir\t{TO_XFER_BUF, FROM_XFER_BUF};\n\n#include \"rtsx_chip.h\"\n#include \"rtsx_transport.h\"\n#include \"rtsx_scsi.h\"\n#include \"rtsx_card.h\"\n#include \"rtsx_sys.h\"\n#include \"general.h\"\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}