{
  "module_name": "rtsx_chip.h",
  "hash_id": "6d6191009256c91f24642bcc5f9f3861f1d93d81842a69ccb4d984b410fe0801",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rts5208/rtsx_chip.h",
  "human_readable_source": " \n \n\n#ifndef __REALTEK_RTSX_CHIP_H\n#define __REALTEK_RTSX_CHIP_H\n\n#include \"rtsx.h\"\n\n#define SUPPORT_CPRM\n#define SUPPORT_OCP\n#define SUPPORT_SDIO_ASPM\n#define SUPPORT_MAGIC_GATE\n#define SUPPORT_MSXC\n#define SUPPORT_SD_LOCK\n \n#define HW_AUTO_SWITCH_SD_BUS\n \n#define HW_INT_WRITE_CLR\n \n \n\n#ifdef SUPPORT_MAGIC_GATE\n\t \n\t#define MG_SET_ICV_SLOW\n\t \n\t#define MS_SAMPLE_INT_ERR\n\t \n\t#define READ_BYTES_WAIT_INT\n#endif\n\n#ifdef SUPPORT_MSXC\n#define XC_POWERCLASS\n#define SUPPORT_PCGL_1P18\n#endif\n\n#ifndef LED_AUTO_BLINK\n#define REGULAR_BLINK\n#endif\n\n#define LED_BLINK_SPEED\t\t5\n#define LED_TOGGLE_INTERVAL\t6\n#define\tGPIO_TOGGLE_THRESHOLD   1024\n#define LED_GPIO\t\t0\n\n#define POLLING_INTERVAL\t30\n\n#define TRACE_ITEM_CNT\t\t64\n\n#ifndef STATUS_SUCCESS\n#define STATUS_SUCCESS\t\t0\n#endif\n#ifndef STATUS_FAIL\n#define STATUS_FAIL\t\t1\n#endif\n#ifndef STATUS_TIMEDOUT\n#define STATUS_TIMEDOUT\t\t2\n#endif\n#ifndef STATUS_NOMEM\n#define STATUS_NOMEM\t\t3\n#endif\n#ifndef STATUS_READ_FAIL\n#define STATUS_READ_FAIL\t4\n#endif\n#ifndef STATUS_WRITE_FAIL\n#define STATUS_WRITE_FAIL\t5\n#endif\n#ifndef STATUS_ERROR\n#define STATUS_ERROR\t\t10\n#endif\n\n#define PM_S1\t\t\t1\n#define PM_S3\t\t\t3\n\n \n\n#define TRANSPORT_GOOD\t\t0    \n#define TRANSPORT_FAILED\t1    \n#define TRANSPORT_NO_SENSE\t2   \n#define TRANSPORT_ERROR\t\t3    \n\n \n#define STOP_MEDIUM\t\t\t0x00     \n#define MAKE_MEDIUM_READY\t\t0x01     \n#define UNLOAD_MEDIUM\t\t\t0x02     \n#define LOAD_MEDIUM\t\t\t0x03     \n\n \n#define QULIFIRE                0x00\n#define AENC_FNC                0x00\n#define TRML_IOP                0x00\n#define REL_ADR                 0x00\n#define WBUS_32                 0x00\n#define WBUS_16                 0x00\n#define SYNC                    0x00\n#define LINKED                  0x00\n#define CMD_QUE                 0x00\n#define SFT_RE                  0x00\n\n#define VEN_ID_LEN              8                \n#define PRDCT_ID_LEN            16               \n#define PRDCT_REV_LEN           4                \n\n \n \n#define RTSX_FLIDX_TRANS_ACTIVE\t\t18\n \n#define RTSX_FLIDX_ABORTING\t\t20\n \n#define RTSX_FLIDX_DISCONNECTING\t21\n\n#define ABORTING_OR_DISCONNECTING\t((1UL << US_FLIDX_ABORTING) | \\\n\t\t\t\t\t (1UL << US_FLIDX_DISCONNECTING))\n\n \n#define RTSX_FLIDX_RESETTING\t\t22\n \n#define RTSX_FLIDX_TIMED_OUT\t\t23\n#define DRCT_ACCESS_DEV         0x00     \n#define RMB_DISC                0x80     \n#define ANSI_SCSI2              0x02     \n\n#define SCSI                    0x00     \n\n#define\tWRITE_PROTECTED_MEDIA 0x07\n\n \n#define ILI                     0x20     \n\n#define NO_SENSE                0x00     \n#define RECOVER_ERR             0x01     \n#define NOT_READY               0x02     \n#define MEDIA_ERR               0x03     \n#define HARDWARE_ERR            0x04     \n#define ILGAL_REQ               0x05     \n#define UNIT_ATTENTION          0x06     \n#define DAT_PRTCT               0x07     \n#define BLNC_CHK                0x08     \n\t\t\t\t\t \n#define CPY_ABRT                0x0a     \n#define ABRT_CMD                0x0b     \n#define EQUAL                   0x0c     \n#define VLM_OVRFLW              0x0d     \n#define MISCMP                  0x0e     \n\n#define READ_ERR                -1\n#define WRITE_ERR               -2\n\n#define\tFIRST_RESET\t\t0x01\n#define\tUSED_EXIST\t\t0x02\n\n \n \n#define SENSE_VALID             0x80     \n#define SENSE_INVALID           0x00     \n\n \n#define CUR_ERR                 0x70     \n#define DEF_ERR                 0x71     \n\n \n#define SNSKEYINFO_LEN          3        \n\n#define SKSV                    0x80\n#define CDB_ILLEGAL             0x40\n#define DAT_ILLEGAL             0x00\n#define BPV                     0x08\n#define BIT_ILLEGAL0            0        \n#define BIT_ILLEGAL1            1        \n#define BIT_ILLEGAL2            2        \n#define BIT_ILLEGAL3            3        \n#define BIT_ILLEGAL4            4        \n#define BIT_ILLEGAL5            5        \n#define BIT_ILLEGAL6            6        \n#define BIT_ILLEGAL7            7        \n\n \n#define ASC_NO_INFO             0x00\n#define ASC_MISCMP              0x1d\n#define ASC_INVLD_CDB           0x24\n#define ASC_INVLD_PARA          0x26\n#define ASC_LU_NOT_READY\t0x04\n#define ASC_WRITE_ERR           0x0c\n#define ASC_READ_ERR            0x11\n#define ASC_LOAD_EJCT_ERR       0x53\n#define\tASC_MEDIA_NOT_PRESENT\t0x3A\n#define\tASC_MEDIA_CHANGED\t0x28\n#define\tASC_MEDIA_IN_PROCESS\t0x04\n#define\tASC_WRITE_PROTECT\t0x27\n#define ASC_LUN_NOT_SUPPORTED\t0x25\n\n \n#define ASCQ_NO_INFO            0x00\n#define\tASCQ_MEDIA_IN_PROCESS\t0x01\n#define ASCQ_MISCMP             0x00\n#define ASCQ_INVLD_CDB          0x00\n#define ASCQ_INVLD_PARA         0x02\n#define ASCQ_LU_NOT_READY\t0x02\n#define ASCQ_WRITE_ERR          0x02\n#define ASCQ_READ_ERR           0x00\n#define ASCQ_LOAD_EJCT_ERR      0x00\n#define\tASCQ_WRITE_PROTECT\t0x00\n\nstruct sense_data_t {\n\tunsigned char   err_code;\t \n\t \n\t \n\t \n\t \n\t \n\t \n\tunsigned char   seg_no;\t\t \n\tunsigned char   sense_key;\t \n\t \n\tunsigned char   info[4];\t \n\tunsigned char   ad_sense_len;\t \n\tunsigned char   cmd_info[4];\t \n\tunsigned char   asc;\t\t \n\tunsigned char   ascq;\t\t \n\tunsigned char   rfu;\t\t \n\tunsigned char   sns_key_info[3]; \n};\n\n \n#define RTSX_HCBAR\t\t0x00\n#define RTSX_HCBCTLR\t\t0x04\n#define RTSX_HDBAR\t\t0x08\n#define RTSX_HDBCTLR\t\t0x0C\n#define RTSX_HAIMR\t\t0x10\n#define RTSX_BIPR\t\t0x14\n#define RTSX_BIER\t\t0x18\n\n \n#define STOP_CMD\t\t(0x01 << 28)\n\n \n#define SDMA_MODE\t\t0x00\n#define ADMA_MODE\t\t(0x02 << 26)\n#define STOP_DMA\t\t(0x01 << 28)\n#define TRIG_DMA\t\t(0x01 << 31)\n\n \n#define CMD_DONE_INT\t\tBIT(31)\n#define DATA_DONE_INT\t\tBIT(30)\n#define TRANS_OK_INT\t\tBIT(29)\n#define TRANS_FAIL_INT\t\tBIT(28)\n#define XD_INT\t\t\tBIT(27)\n#define MS_INT\t\t\tBIT(26)\n#define SD_INT\t\t\tBIT(25)\n#define GPIO0_INT\t\tBIT(24)\n#define OC_INT\t\t\tBIT(23)\n#define SD_WRITE_PROTECT\tBIT(19)\n#define XD_EXIST\t\tBIT(18)\n#define MS_EXIST\t\tBIT(17)\n#define SD_EXIST\t\tBIT(16)\n#define DELINK_INT\t\tGPIO0_INT\n#define MS_OC_INT\t\tBIT(23)\n#define SD_OC_INT\t\tBIT(22)\n\n#define CARD_INT\t\t(XD_INT | MS_INT | SD_INT)\n#define NEED_COMPLETE_INT\t(DATA_DONE_INT | TRANS_OK_INT | TRANS_FAIL_INT)\n#define RTSX_INT\t\t(CMD_DONE_INT | NEED_COMPLETE_INT | CARD_INT | \\\n\t\t\t\t GPIO0_INT | OC_INT)\n\n#define CARD_EXIST\t\t(XD_EXIST | MS_EXIST | SD_EXIST)\n\n \n#define CMD_DONE_INT_EN\t\tBIT(31)\n#define DATA_DONE_INT_EN\tBIT(30)\n#define TRANS_OK_INT_EN\t\tBIT(29)\n#define TRANS_FAIL_INT_EN\tBIT(28)\n#define XD_INT_EN\t\tBIT(27)\n#define MS_INT_EN\t\tBIT(26)\n#define SD_INT_EN\t\tBIT(25)\n#define GPIO0_INT_EN\t\tBIT(24)\n#define OC_INT_EN\t\tBIT(23)\n#define DELINK_INT_EN\t\tGPIO0_INT_EN\n#define MS_OC_INT_EN\t\tBIT(23)\n#define SD_OC_INT_EN\t\tBIT(22)\n\n#define READ_REG_CMD\t\t0\n#define WRITE_REG_CMD\t\t1\n#define CHECK_REG_CMD\t\t2\n\n#define HOST_TO_DEVICE\t\t0\n#define DEVICE_TO_HOST\t\t1\n\n#define RTSX_RESV_BUF_LEN\t4096\n#define HOST_CMDS_BUF_LEN\t1024\n#define HOST_SG_TBL_BUF_LEN\t(RTSX_RESV_BUF_LEN - HOST_CMDS_BUF_LEN)\n\n#define SD_NR\t\t2\n#define MS_NR\t\t3\n#define XD_NR\t\t4\n#define SPI_NR\t\t7\n#define SD_CARD\t\tBIT(SD_NR)\n#define MS_CARD\t\tBIT(MS_NR)\n#define XD_CARD\t\tBIT(XD_NR)\n#define SPI_CARD\tBIT(SPI_NR)\n\n#define MAX_ALLOWED_LUN_CNT\t8\n\n#define XD_FREE_TABLE_CNT\t1200\n#define MS_FREE_TABLE_CNT\t512\n\n \n#define SET_BIT(data, idx)\t((data) |= 1 << (idx))\n#define CLR_BIT(data, idx)\t((data) &= ~(1 << (idx)))\n#define CHK_BIT(data, idx)\t((data) & (1 << (idx)))\n\n \n#define RTSX_SG_INT\t\t0x04\n#define RTSX_SG_END\t\t0x02\n#define RTSX_SG_VALID\t\t0x01\n\n#define RTSX_SG_NO_OP\t\t0x00\n#define RTSX_SG_TRANS_DATA\t(0x02 << 4)\n#define RTSX_SG_LINK_DESC\t(0x03 << 4)\n\nstruct rtsx_chip;\n\ntypedef int (*card_rw_func)(struct scsi_cmnd *srb, struct rtsx_chip *chip,\n\t\t\tu32 sec_addr, u16 sec_cnt);\n\n \nenum card_clock\t{CLK_20 = 1, CLK_30, CLK_40, CLK_50, CLK_60,\n\t\t CLK_80, CLK_100, CLK_120, CLK_150, CLK_200};\n\nenum RTSX_STAT\t{RTSX_STAT_INIT, RTSX_STAT_IDLE, RTSX_STAT_RUN, RTSX_STAT_SS,\n\t\t RTSX_STAT_DELINK, RTSX_STAT_SUSPEND,\n\t\t RTSX_STAT_ABORT, RTSX_STAT_DISCONNECT};\nenum IC_VER\t{IC_VER_AB, IC_VER_C = 2, IC_VER_D = 3};\n\n#define MAX_RESET_CNT\t\t3\n\n \n#define MAX_DEFECTIVE_BLOCK     10\n\nstruct zone_entry {\n\tu16 *l2p_table;\n\tu16 *free_table;\n\tu16 defect_list[MAX_DEFECTIVE_BLOCK];   \n\tint set_index;\n\tint get_index;\n\tint unused_blk_cnt;\n\tint disable_count;\n\t \n\tint build_flag;\n};\n\n#define TYPE_SD\t\t\t0x0000\n#define TYPE_MMC\t\t0x0001\n\n \n#define SD_HS\t\t\t0x0100\n#define SD_SDR50\t\t0x0200\n#define SD_DDR50\t\t0x0400\n#define SD_SDR104\t\t0x0800\n#define SD_HCXC\t\t\t0x1000\n\n \n#define MMC_26M\t\t\t0x0100\n#define MMC_52M\t\t\t0x0200\n#define MMC_4BIT\t\t0x0400\n#define MMC_8BIT\t\t0x0800\n#define MMC_SECTOR_MODE\t\t0x1000\n#define MMC_DDR52\t\t0x2000\n\n \n#define CHK_SD(sd_card)\t\t\t(((sd_card)->sd_type & 0xFF) == TYPE_SD)\n#define CHK_SD_HS(sd_card)\t\t(CHK_SD(sd_card) && \\\n\t\t\t\t\t ((sd_card)->sd_type & SD_HS))\n#define CHK_SD_SDR50(sd_card)\t\t(CHK_SD(sd_card) && \\\n\t\t\t\t\t ((sd_card)->sd_type & SD_SDR50))\n#define CHK_SD_DDR50(sd_card)\t\t(CHK_SD(sd_card) && \\\n\t\t\t\t\t ((sd_card)->sd_type & SD_DDR50))\n#define CHK_SD_SDR104(sd_card)\t\t(CHK_SD(sd_card) && \\\n\t\t\t\t\t ((sd_card)->sd_type & SD_SDR104))\n#define CHK_SD_HCXC(sd_card)\t\t(CHK_SD(sd_card) && \\\n\t\t\t\t\t ((sd_card)->sd_type & SD_HCXC))\n#define CHK_SD_HC(sd_card)\t\t(CHK_SD_HCXC(sd_card) && \\\n\t\t\t\t\t ((sd_card)->capacity <= 0x4000000))\n#define CHK_SD_XC(sd_card)\t\t(CHK_SD_HCXC(sd_card) && \\\n\t\t\t\t\t ((sd_card)->capacity > 0x4000000))\n#define CHK_SD30_SPEED(sd_card)\t\t(CHK_SD_SDR50(sd_card) || \\\n\t\t\t\t\t CHK_SD_DDR50(sd_card) || \\\n\t\t\t\t\t CHK_SD_SDR104(sd_card))\n\n#define SET_SD(sd_card)\t\t\t((sd_card)->sd_type = TYPE_SD)\n#define SET_SD_HS(sd_card)\t\t((sd_card)->sd_type |= SD_HS)\n#define SET_SD_SDR50(sd_card)\t\t((sd_card)->sd_type |= SD_SDR50)\n#define SET_SD_DDR50(sd_card)\t\t((sd_card)->sd_type |= SD_DDR50)\n#define SET_SD_SDR104(sd_card)\t\t((sd_card)->sd_type |= SD_SDR104)\n#define SET_SD_HCXC(sd_card)\t\t((sd_card)->sd_type |= SD_HCXC)\n\n#define CLR_SD_HS(sd_card)\t\t((sd_card)->sd_type &= ~SD_HS)\n#define CLR_SD_SDR50(sd_card)\t\t((sd_card)->sd_type &= ~SD_SDR50)\n#define CLR_SD_DDR50(sd_card)\t\t((sd_card)->sd_type &= ~SD_DDR50)\n#define CLR_SD_SDR104(sd_card)\t\t((sd_card)->sd_type &= ~SD_SDR104)\n#define CLR_SD_HCXC(sd_card)\t\t((sd_card)->sd_type &= ~SD_HCXC)\n\n \n#define CHK_MMC(sd_card)\t\t(((sd_card)->sd_type & 0xFF) == \\\n\t\t\t\t\t TYPE_MMC)\n#define CHK_MMC_26M(sd_card)\t\t(CHK_MMC(sd_card) && \\\n\t\t\t\t\t ((sd_card)->sd_type & MMC_26M))\n#define CHK_MMC_52M(sd_card)\t\t(CHK_MMC(sd_card) && \\\n\t\t\t\t\t ((sd_card)->sd_type & MMC_52M))\n#define CHK_MMC_4BIT(sd_card)\t\t(CHK_MMC(sd_card) && \\\n\t\t\t\t\t ((sd_card)->sd_type & MMC_4BIT))\n#define CHK_MMC_8BIT(sd_card)\t\t(CHK_MMC(sd_card) && \\\n\t\t\t\t\t ((sd_card)->sd_type & MMC_8BIT))\n#define CHK_MMC_SECTOR_MODE(sd_card)\t(CHK_MMC(sd_card) && \\\n\t\t\t\t\t ((sd_card)->sd_type & MMC_SECTOR_MODE))\n#define CHK_MMC_DDR52(sd_card)\t\t(CHK_MMC(sd_card) && \\\n\t\t\t\t\t ((sd_card)->sd_type & MMC_DDR52))\n\n#define SET_MMC(sd_card)\t\t((sd_card)->sd_type = TYPE_MMC)\n#define SET_MMC_26M(sd_card)\t\t((sd_card)->sd_type |= MMC_26M)\n#define SET_MMC_52M(sd_card)\t\t((sd_card)->sd_type |= MMC_52M)\n#define SET_MMC_4BIT(sd_card)\t\t((sd_card)->sd_type |= MMC_4BIT)\n#define SET_MMC_8BIT(sd_card)\t\t((sd_card)->sd_type |= MMC_8BIT)\n#define SET_MMC_SECTOR_MODE(sd_card)\t((sd_card)->sd_type |= MMC_SECTOR_MODE)\n#define SET_MMC_DDR52(sd_card)\t\t((sd_card)->sd_type |= MMC_DDR52)\n\n#define CLR_MMC_26M(sd_card)\t\t((sd_card)->sd_type &= ~MMC_26M)\n#define CLR_MMC_52M(sd_card)\t\t((sd_card)->sd_type &= ~MMC_52M)\n#define CLR_MMC_4BIT(sd_card)\t\t((sd_card)->sd_type &= ~MMC_4BIT)\n#define CLR_MMC_8BIT(sd_card)\t\t((sd_card)->sd_type &= ~MMC_8BIT)\n#define CLR_MMC_SECTOR_MODE(sd_card)\t((sd_card)->sd_type &= ~MMC_SECTOR_MODE)\n#define CLR_MMC_DDR52(sd_card)\t\t((sd_card)->sd_type &= ~MMC_DDR52)\n\n#define CHK_MMC_HS(sd_card)\t\t(CHK_MMC_52M(sd_card) && \\\n\t\t\t\t\t CHK_MMC_26M(sd_card))\n#define CLR_MMC_HS(sd_card)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tCLR_MMC_DDR52(sd_card);\t\t\t\\\n\tCLR_MMC_52M(sd_card);\t\t\t\\\n\tCLR_MMC_26M(sd_card);\t\t\t\\\n} while (0)\n\n#define SD_SUPPORT_CLASS_TEN\t\t0x01\n#define SD_SUPPORT_1V8\t\t\t0x02\n\n#define SD_SET_CLASS_TEN(sd_card)\t((sd_card)->sd_setting |= \\\n\t\t\t\t\t SD_SUPPORT_CLASS_TEN)\n#define SD_CHK_CLASS_TEN(sd_card)\t((sd_card)->sd_setting & \\\n\t\t\t\t\t SD_SUPPORT_CLASS_TEN)\n#define SD_CLR_CLASS_TEN(sd_card)\t((sd_card)->sd_setting &= \\\n\t\t\t\t\t ~SD_SUPPORT_CLASS_TEN)\n#define SD_SET_1V8(sd_card)\t\t((sd_card)->sd_setting |= \\\n\t\t\t\t\t SD_SUPPORT_1V8)\n#define SD_CHK_1V8(sd_card)\t\t((sd_card)->sd_setting & \\\n\t\t\t\t\t SD_SUPPORT_1V8)\n#define SD_CLR_1V8(sd_card)\t\t((sd_card)->sd_setting &= \\\n\t\t\t\t\t ~SD_SUPPORT_1V8)\n\nstruct sd_info {\n\tu16 sd_type;\n\tu8 err_code;\n\tu8 sd_data_buf_ready;\n\tu32 sd_addr;\n\tu32 capacity;\n\n\tu8 raw_csd[16];\n\tu8 raw_scr[8];\n\n\t \n\tint seq_mode;\n\tenum dma_data_direction pre_dir;\n\tu32 pre_sec_addr;\n\tu16 pre_sec_cnt;\n\n\tint cleanup_counter;\n\n\tint sd_clock;\n\n\tint mmc_dont_switch_bus;\n\n#ifdef SUPPORT_CPRM\n\tint sd_pass_thru_en;\n\tint pre_cmd_err;\n\tu8 last_rsp_type;\n\tu8 rsp[17];\n#endif\n\n\tu8 func_group1_mask;\n\tu8 func_group2_mask;\n\tu8 func_group3_mask;\n\tu8 func_group4_mask;\n\n\tu8 sd_switch_fail;\n\tu8 sd_read_phase;\n\n#ifdef SUPPORT_SD_LOCK\n\tu8 sd_lock_status;\n\tu8 sd_erase_status;\n\tu8 sd_lock_notify;\n#endif\n\tint need_retune;\n};\n\nstruct xd_delay_write_tag {\n\tu32 old_phyblock;\n\tu32 new_phyblock;\n\tu32 logblock;\n\tu8 pageoff;\n\tu8 delay_write_flag;\n};\n\nstruct xd_info {\n\tu8 maker_code;\n\tu8 device_code;\n\tu8 block_shift;\n\tu8 page_off;\n\tu8 addr_cycle;\n\tu16 cis_block;\n\tu8 multi_flag;\n\tu8 err_code;\n\tu32 capacity;\n\n\tstruct zone_entry *zone;\n\tint zone_cnt;\n\n\tstruct xd_delay_write_tag delay_write;\n\tint cleanup_counter;\n\n\tint xd_clock;\n};\n\n#define MODE_512_SEQ\t\t0x01\n#define MODE_2K_SEQ\t\t0x02\n\n#define TYPE_MS\t\t\t0x0000\n#define TYPE_MSPRO\t\t0x0001\n\n#define MS_4BIT\t\t\t0x0100\n#define MS_8BIT\t\t\t0x0200\n#define MS_HG\t\t\t0x0400\n#define MS_XC\t\t\t0x0800\n\n#define HG8BIT\t\t\t(MS_HG | MS_8BIT)\n\n#define CHK_MSPRO(ms_card)\t(((ms_card)->ms_type & 0xFF) == TYPE_MSPRO)\n#define CHK_HG8BIT(ms_card)\t(CHK_MSPRO(ms_card) && \\\n\t\t\t\t (((ms_card)->ms_type & HG8BIT) == HG8BIT))\n#define CHK_MSXC(ms_card)\t(CHK_MSPRO(ms_card) && \\\n\t\t\t\t ((ms_card)->ms_type & MS_XC))\n#define CHK_MSHG(ms_card)\t(CHK_MSPRO(ms_card) && \\\n\t\t\t\t ((ms_card)->ms_type & MS_HG))\n\n#define CHK_MS8BIT(ms_card)\t(((ms_card)->ms_type & MS_8BIT))\n#define CHK_MS4BIT(ms_card)\t(((ms_card)->ms_type & MS_4BIT))\n\nstruct ms_delay_write_tag {\n\tu16 old_phyblock;\n\tu16 new_phyblock;\n\tu16 logblock;\n\tu8 pageoff;\n\tu8 delay_write_flag;\n};\n\nstruct ms_info {\n\tu16 ms_type;\n\tu8 block_shift;\n\tu8 page_off;\n\tu16 total_block;\n\tu16 boot_block;\n\tu32 capacity;\n\n\tu8 check_ms_flow;\n\tu8 switch_8bit_fail;\n\tu8 err_code;\n\n\tstruct zone_entry *segment;\n\tint segment_cnt;\n\n\tint pro_under_formatting;\n\tint format_status;\n\tu16 progress;\n\tu8 raw_sys_info[96];\n#ifdef SUPPORT_PCGL_1P18\n\tu8 raw_model_name[48];\n#endif\n\n\tu8 multi_flag;\n\n\t \n\tu8 seq_mode;\n\tenum dma_data_direction pre_dir;\n\tu32 pre_sec_addr;\n\tu16 pre_sec_cnt;\n\tu32 total_sec_cnt;\n\n\tstruct ms_delay_write_tag delay_write;\n\n\tint cleanup_counter;\n\n\tint ms_clock;\n\n#ifdef SUPPORT_MAGIC_GATE\n\tu8 magic_gate_id[16];\n\tu8 mg_entry_num;\n\tint mg_auth;     \n#endif\n};\n\nstruct spi_info {\n\tu8 use_clk;\n\tu8 write_en;\n\tu16 clk_div;\n\tu8 err_code;\n\n\tint spi_clock;\n};\n\n \n \n \n \n#define DEFAULT_SINGLE\t\t0\n \n#define SD_MS_2LUN\t\t1\n \n#define SD_MS_1LUN\t\t2\n\n#define LAST_LUN_MODE\t\t2\n\n \n#define QFN\t\t0\n#define LQFP\t\t1\n\n \n \n \n \n#define SD_PUSH_POINT_CTL_MASK\t\t0x03\n#define SD_PUSH_POINT_DELAY\t\t0x01\n#define SD_PUSH_POINT_AUTO\t\t0x02\n \n#define SD_SAMPLE_POINT_CTL_MASK\t0x0C\n#define SD_SAMPLE_POINT_DELAY\t\t0x04\n#define SD_SAMPLE_POINT_AUTO\t\t0x08\n \n#define SD_DDR_TX_PHASE_SET_BY_USER\t0x10\n \n#define MMC_DDR_TX_PHASE_SET_BY_USER\t0x20\n \n#define SUPPORT_MMC_DDR_MODE\t\t0x40\n \n#define RESET_MMC_FIRST\t\t\t0x80\n\n#define SEQ_START_CRITERIA\t\t0x20\n\n \n#define POWER_CLASS_2_EN\t\t0x02\n#define POWER_CLASS_1_EN\t\t0x01\n\n#define MAX_SHOW_CNT\t\t\t10\n#define MAX_RESET_CNT\t\t\t3\n\n#define SDIO_EXIST\t\t\t0x01\n#define SDIO_IGNORED\t\t\t0x02\n\n#define CHK_SDIO_EXIST(chip)\t\t((chip)->sdio_func_exist & SDIO_EXIST)\n#define SET_SDIO_EXIST(chip)\t\t((chip)->sdio_func_exist |= SDIO_EXIST)\n#define CLR_SDIO_EXIST(chip)\t\t((chip)->sdio_func_exist &= ~SDIO_EXIST)\n\n#define CHK_SDIO_IGNORED(chip)\t\t((chip)->sdio_func_exist & SDIO_IGNORED)\n#define SET_SDIO_IGNORED(chip)\t\t((chip)->sdio_func_exist |= \\\n\t\t\t\t\t SDIO_IGNORED)\n#define CLR_SDIO_IGNORED(chip)\t\t((chip)->sdio_func_exist &= \\\n\t\t\t\t\t ~SDIO_IGNORED)\n\nstruct rtsx_chip {\n\tstruct rtsx_dev\t*rtsx;\n\n\tu32\t\tint_reg;  \n\tchar\t\tmax_lun;\n\tvoid\t\t*context;\n\n\tvoid\t\t*host_cmds_ptr;\t \n\tdma_addr_t\thost_cmds_addr;\n\tint\t\tci;\t\t\t \n\n\tvoid\t\t*host_sg_tbl_ptr;\t \n\tdma_addr_t\thost_sg_tbl_addr;\n\tint\t\tsgi;\t\t\t \n\n\tstruct scsi_cmnd\t*srb;\t\t\t \n\tstruct sense_data_t\tsense_buffer[MAX_ALLOWED_LUN_CNT];\n\n\tint\t\t\tcur_clk;\t\t \n\n\t \n\tint\t\t\tcur_card;\n\n\tunsigned long\tneed_release;\t\t \n\tunsigned long\tneed_reset;\t\t \n\t \n\tunsigned long\t\tneed_reinit;\n\n\tint\t\t\trw_need_retry;\n\n#ifdef SUPPORT_OCP\n\tu32\t\t\tocp_int;\n\tu8\t\t\tocp_stat;\n#endif\n\n\tu8\tcard_exist;\t \n\tu8\tcard_ready;\t \n\tu8\tcard_fail;\t \n\tu8\tcard_ejected;\t \n\tu8\tcard_wp;\t \n\n\tu8\tlun_mc;\t\t \n\n#ifndef LED_AUTO_BLINK\n\tint\t\t\tled_toggle_counter;\n#endif\n\n\tint\t\t\tsd_reset_counter;\n\tint\t\t\txd_reset_counter;\n\tint\t\t\tms_reset_counter;\n\n\t \n\tu8\t\t\tcard_bus_width[MAX_ALLOWED_LUN_CNT];\n\t \n\tu32\t\t\tcapacity[MAX_ALLOWED_LUN_CNT];\n\t \n\tcard_rw_func\t\trw_card[MAX_ALLOWED_LUN_CNT];\n\t \n\tu32\t\t\trw_cap[MAX_ALLOWED_LUN_CNT];\n\t \n\tu8\t\t\tcard2lun[32];\n\t \n\tu8\t\t\tlun2card[MAX_ALLOWED_LUN_CNT];\n\n\tint\t\t\trw_fail_cnt[MAX_ALLOWED_LUN_CNT];\n\n\tint\t\t\tsd_show_cnt;\n\tint\t\t\txd_show_cnt;\n\tint\t\t\tms_show_cnt;\n\n\t \n\tstruct sd_info\t\tsd_card;\n\tstruct xd_info\t\txd_card;\n\tstruct ms_info\t\tms_card;\n\n\tstruct spi_info\t\tspi;\n\n\tint\t\t\tauto_delink_cnt;\n\tint\t\t\tauto_delink_allowed;\n\n\tint\t\t\taspm_enabled;\n\n\tint\t\t\tsdio_aspm;\n\tint\t\t\tsdio_idle;\n\tint\t\t\tsdio_counter;\n\tu8\t\t\tsdio_raw_data[12];\n\n\tu8\t\t\tsd_io;\n\tu8\t\t\tsd_int;\n\n\tu8\t\t\trtsx_flag;\n\n\tint\t\t\tss_counter;\n\tint\t\t\tidle_counter;\n\tenum RTSX_STAT\t\trtsx_stat;\n\n\tu16\t\t\tvendor_id;\n\tu16\t\t\tproduct_id;\n\tu8\t\t\tic_version;\n\n\tint\t\t\tdriver_first_load;\n\n#ifdef HW_AUTO_SWITCH_SD_BUS\n\tint\t\t\tsdio_in_charge;\n#endif\n\n\tu8\t\t\taspm_level[2];\n\n\tint\t\t\tchip_insert_with_sdio;\n\n\t \n\n\tint adma_mode;\n\n\tint auto_delink_en;\n\tint ss_en;\n\tu8 lun_mode;\n\tu8 aspm_l0s_l1_en;\n\n\tint power_down_in_ss;\n\n\tint sdr104_en;\n\tint ddr50_en;\n\tint sdr50_en;\n\n\tint baro_pkg;\n\n\tint asic_code;\n\tint phy_debug_mode;\n\tint hw_bypass_sd;\n\tint sdio_func_exist;\n\tint aux_pwr_exist;\n\tu8 ms_power_class_en;\n\n\tint mspro_formatter_enable;\n\n\tint remote_wakeup_en;\n\n\tint ignore_sd;\n\tint use_hw_setting;\n\n\tint ss_idle_period;\n\n\tint dynamic_aspm;\n\n\tint fpga_sd_sdr104_clk;\n\tint fpga_sd_ddr50_clk;\n\tint fpga_sd_sdr50_clk;\n\tint fpga_sd_hs_clk;\n\tint fpga_mmc_52m_clk;\n\tint fpga_ms_hg_clk;\n\tint fpga_ms_4bit_clk;\n\tint fpga_ms_1bit_clk;\n\n\tint asic_sd_sdr104_clk;\n\tint asic_sd_ddr50_clk;\n\tint asic_sd_sdr50_clk;\n\tint asic_sd_hs_clk;\n\tint asic_mmc_52m_clk;\n\tint asic_ms_hg_clk;\n\tint asic_ms_4bit_clk;\n\tint asic_ms_1bit_clk;\n\n\tu8 ssc_depth_sd_sdr104;\n\tu8 ssc_depth_sd_ddr50;\n\tu8 ssc_depth_sd_sdr50;\n\tu8 ssc_depth_sd_hs;\n\tu8 ssc_depth_mmc_52m;\n\tu8 ssc_depth_ms_hg;\n\tu8 ssc_depth_ms_4bit;\n\tu8 ssc_depth_low_speed;\n\n\tu8 card_drive_sel;\n\tu8 sd30_drive_sel_1v8;\n\tu8 sd30_drive_sel_3v3;\n\n\tu8 sd_400mA_ocp_thd;\n\tu8 sd_800mA_ocp_thd;\n\tu8 ms_ocp_thd;\n\n\tint ssc_en;\n\tint msi_en;\n\n\tint xd_timeout;\n\tint sd_timeout;\n\tint ms_timeout;\n\tint mspro_timeout;\n\n\tint auto_power_down;\n\n\tint sd_ddr_tx_phase;\n\tint mmc_ddr_tx_phase;\n\tint sd_default_tx_phase;\n\tint sd_default_rx_phase;\n\n\tint pmos_pwr_on_interval;\n\tint sd_voltage_switch_delay;\n\tint s3_pwr_off_delay;\n\n\tint force_clkreq_0;\n\tint ft2_fast_mode;\n\n\tint do_delink_before_power_down;\n\tint polling_config;\n\tint sdio_retry_cnt;\n\n\tint delink_stage1_step;\n\tint delink_stage2_step;\n\tint delink_stage3_step;\n\n\tint auto_delink_in_L1;\n\tint hp_watch_bios_hotplug;\n\tint support_ms_8bit;\n\n\tu8 blink_led;\n\tu8 phy_voltage;\n\tu8 max_payload;\n\n\tu32 sd_speed_prior;\n\tu32 sd_current_prior;\n\tu32 sd_ctl;\n};\n\nstatic inline struct device *rtsx_dev(const struct rtsx_chip *chip)\n{\n\treturn &chip->rtsx->pci->dev;\n}\n\n#define rtsx_set_stat(chip, stat)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((stat) != RTSX_STAT_IDLE) {\t\t\t\t\\\n\t\t(chip)->idle_counter = 0;\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t(chip)->rtsx_stat = (enum RTSX_STAT)(stat);\t\t\\\n} while (0)\n#define rtsx_get_stat(chip)\t\t((chip)->rtsx_stat)\n#define rtsx_chk_stat(chip, stat)\t((chip)->rtsx_stat == (stat))\n\n#define RTSX_SET_DELINK(chip)\t((chip)->rtsx_flag |= 0x01)\n#define RTSX_CLR_DELINK(chip)\t((chip)->rtsx_flag &= 0xFE)\n#define RTSX_TST_DELINK(chip)\t((chip)->rtsx_flag & 0x01)\n\n#define CHECK_PID(chip, pid)\t\t((chip)->product_id == (pid))\n#define CHECK_BARO_PKG(chip, pkg)\t((chip)->baro_pkg == (pkg))\n#define CHECK_LUN_MODE(chip, mode)\t((chip)->lun_mode == (mode))\n\n \n#define SSC_PDCTL\t\t0x01\n#define OC_PDCTL\t\t0x02\n\nint rtsx_force_power_on(struct rtsx_chip *chip, u8 ctl);\nint rtsx_force_power_down(struct rtsx_chip *chip, u8 ctl);\n\nvoid rtsx_enable_card_int(struct rtsx_chip *chip);\nvoid rtsx_enable_bus_int(struct rtsx_chip *chip);\nvoid rtsx_disable_bus_int(struct rtsx_chip *chip);\nint rtsx_reset_chip(struct rtsx_chip *chip);\nint rtsx_init_chip(struct rtsx_chip *chip);\nvoid rtsx_release_chip(struct rtsx_chip *chip);\nvoid rtsx_polling_func(struct rtsx_chip *chip);\nvoid rtsx_stop_cmd(struct rtsx_chip *chip, int card);\nint rtsx_write_register(struct rtsx_chip *chip, u16 addr, u8 mask, u8 data);\nint rtsx_read_register(struct rtsx_chip *chip, u16 addr, u8 *data);\nint rtsx_write_cfg_dw(struct rtsx_chip *chip,\n\t\t      u8 func_no, u16 addr, u32 mask, u32 val);\nint rtsx_read_cfg_dw(struct rtsx_chip *chip, u8 func_no, u16 addr, u32 *val);\nint rtsx_write_cfg_seq(struct rtsx_chip *chip,\n\t\t       u8 func, u16 addr, u8 *buf, int len);\nint rtsx_read_cfg_seq(struct rtsx_chip *chip,\n\t\t      u8 func, u16 addr, u8 *buf, int len);\nint rtsx_write_phy_register(struct rtsx_chip *chip, u8 addr, u16 val);\nint rtsx_read_phy_register(struct rtsx_chip *chip, u8 addr, u16 *val);\nint rtsx_read_efuse(struct rtsx_chip *chip, u8 addr, u8 *val);\nint rtsx_write_efuse(struct rtsx_chip *chip, u8 addr, u8 val);\nint rtsx_clr_phy_reg_bit(struct rtsx_chip *chip, u8 reg, u8 bit);\nint rtsx_set_phy_reg_bit(struct rtsx_chip *chip, u8 reg, u8 bit);\nvoid rtsx_enter_ss(struct rtsx_chip *chip);\nvoid rtsx_exit_ss(struct rtsx_chip *chip);\nint rtsx_pre_handle_interrupt(struct rtsx_chip *chip);\nvoid rtsx_enter_L1(struct rtsx_chip *chip);\nvoid rtsx_exit_L1(struct rtsx_chip *chip);\nvoid rtsx_do_before_power_down(struct rtsx_chip *chip, int pm_stat);\nvoid rtsx_enable_aspm(struct rtsx_chip *chip);\nvoid rtsx_disable_aspm(struct rtsx_chip *chip);\nint rtsx_read_ppbuf(struct rtsx_chip *chip, u8 *buf, int buf_len);\nint rtsx_write_ppbuf(struct rtsx_chip *chip, u8 *buf, int buf_len);\nint rtsx_check_chip_exist(struct rtsx_chip *chip);\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}