{
  "module_name": "ms.c",
  "hash_id": "072daabe84e36fea673c96b66e91e181054596e5a1bef52b0af75f326e9832b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rts5208/ms.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n\n#include \"rtsx.h\"\n#include \"ms.h\"\n\nstatic inline void ms_set_err_code(struct rtsx_chip *chip, u8 err_code)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\n\tms_card->err_code = err_code;\n}\n\nstatic inline int ms_check_err_code(struct rtsx_chip *chip, u8 err_code)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\n\treturn (ms_card->err_code == err_code);\n}\n\nstatic int ms_parse_err_code(struct rtsx_chip *chip)\n{\n\treturn STATUS_FAIL;\n}\n\nstatic int ms_transfer_tpc(struct rtsx_chip *chip, u8 trans_mode,\n\t\t\t   u8 tpc, u8 cnt, u8 cfg)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\tu8 *ptr;\n\n\tdev_dbg(rtsx_dev(chip), \"%s: tpc = 0x%x\\n\", __func__, tpc);\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_BYTE_CNT, 0xFF, cnt);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t     0x01, PINGPONG_BUFFER);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TRANSFER,\n\t\t     0xFF, MS_TRANSFER_START | trans_mode);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, MS_TRANSFER,\n\t\t     MS_TRANSFER_END, MS_TRANSFER_END);\n\n\trtsx_add_cmd(chip, READ_REG_CMD, MS_TRANS_CFG, 0, 0);\n\n\tretval = rtsx_send_cmd(chip, MS_CARD, 5000);\n\tif (retval < 0) {\n\t\trtsx_clear_ms_error(chip);\n\t\tms_set_err_code(chip, MS_TO_ERROR);\n\t\treturn ms_parse_err_code(chip);\n\t}\n\n\tptr = rtsx_get_cmd_data(chip) + 1;\n\n\tif (!(tpc & 0x08)) {\t\t \n\t\tif (*ptr & MS_CRC16_ERR) {\n\t\t\tms_set_err_code(chip, MS_CRC16_ERROR);\n\t\t\treturn ms_parse_err_code(chip);\n\t\t}\n\t} else {\t\t\t \n\t\tif (CHK_MSPRO(ms_card) && !(*ptr & 0x80)) {\n\t\t\tif (*ptr & (MS_INT_ERR | MS_INT_CMDNK)) {\n\t\t\t\tms_set_err_code(chip, MS_CMD_NK);\n\t\t\t\treturn ms_parse_err_code(chip);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*ptr & MS_RDY_TIMEOUT) {\n\t\trtsx_clear_ms_error(chip);\n\t\tms_set_err_code(chip, MS_TO_ERROR);\n\t\treturn ms_parse_err_code(chip);\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_transfer_data(struct rtsx_chip *chip, u8 trans_mode,\n\t\t\t    u8 tpc, u16 sec_cnt, u8 cfg, bool mode_2k,\n\t\t\t    int use_sg, void *buf, int buf_len)\n{\n\tint retval;\n\tu8 val, err_code = 0;\n\tenum dma_data_direction dir;\n\n\tif (!buf || !buf_len)\n\t\treturn STATUS_FAIL;\n\n\tif (trans_mode == MS_TM_AUTO_READ) {\n\t\tdir = DMA_FROM_DEVICE;\n\t\terr_code = MS_FLASH_READ_ERROR;\n\t} else if (trans_mode == MS_TM_AUTO_WRITE) {\n\t\tdir = DMA_TO_DEVICE;\n\t\terr_code = MS_FLASH_WRITE_ERROR;\n\t} else {\n\t\treturn STATUS_FAIL;\n\t}\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\n\trtsx_add_cmd(chip, WRITE_REG_CMD,\n\t\t     MS_SECTOR_CNT_H, 0xFF, (u8)(sec_cnt >> 8));\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_SECTOR_CNT_L, 0xFF, (u8)sec_cnt);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\n\n\tif (mode_2k) {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD,\n\t\t\t     MS_CFG, MS_2K_SECTOR_MODE, MS_2K_SECTOR_MODE);\n\t} else {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_CFG, MS_2K_SECTOR_MODE, 0);\n\t}\n\n\ttrans_dma_enable(dir, chip, sec_cnt * 512, DMA_512);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD,\n\t\t     MS_TRANSFER, 0xFF, MS_TRANSFER_START | trans_mode);\n\trtsx_add_cmd(chip, CHECK_REG_CMD,\n\t\t     MS_TRANSFER, MS_TRANSFER_END, MS_TRANSFER_END);\n\n\trtsx_send_cmd_no_wait(chip);\n\n\tretval = rtsx_transfer_data(chip, MS_CARD, buf, buf_len,\n\t\t\t\t    use_sg, dir, chip->mspro_timeout);\n\tif (retval < 0) {\n\t\tms_set_err_code(chip, err_code);\n\t\tif (retval == -ETIMEDOUT)\n\t\t\tretval = STATUS_TIMEDOUT;\n\t\telse\n\t\t\tretval = STATUS_FAIL;\n\n\t\treturn retval;\n\t}\n\n\tretval = rtsx_read_register(chip, MS_TRANS_CFG, &val);\n\tif (retval)\n\t\treturn retval;\n\n\tif (val & (MS_INT_CMDNK | MS_INT_ERR | MS_CRC16_ERR | MS_RDY_TIMEOUT))\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_write_bytes(struct rtsx_chip *chip,\n\t\t\t  u8 tpc, u8 cnt, u8 cfg, u8 *data, int data_len)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, i;\n\n\tif (!data || data_len < cnt)\n\t\treturn STATUS_ERROR;\n\n\trtsx_init_cmd(chip);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD,\n\t\t\t     PPBUF_BASE2 + i, 0xFF, data[i]);\n\t}\n\tif (cnt % 2)\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, PPBUF_BASE2 + i, 0xFF, 0xFF);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_BYTE_CNT, 0xFF, cnt);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t     0x01, PINGPONG_BUFFER);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD,\n\t\t     MS_TRANSFER, 0xFF, MS_TRANSFER_START | MS_TM_WRITE_BYTES);\n\trtsx_add_cmd(chip, CHECK_REG_CMD,\n\t\t     MS_TRANSFER, MS_TRANSFER_END, MS_TRANSFER_END);\n\n\tretval = rtsx_send_cmd(chip, MS_CARD, 5000);\n\tif (retval < 0) {\n\t\tu8 val = 0;\n\n\t\trtsx_read_register(chip, MS_TRANS_CFG, &val);\n\t\tdev_dbg(rtsx_dev(chip), \"MS_TRANS_CFG: 0x%02x\\n\", val);\n\n\t\trtsx_clear_ms_error(chip);\n\n\t\tif (!(tpc & 0x08)) {\n\t\t\tif (val & MS_CRC16_ERR) {\n\t\t\t\tms_set_err_code(chip, MS_CRC16_ERROR);\n\t\t\t\treturn ms_parse_err_code(chip);\n\t\t\t}\n\t\t} else {\n\t\t\tif (CHK_MSPRO(ms_card) && !(val & 0x80)) {\n\t\t\t\tif (val & (MS_INT_ERR | MS_INT_CMDNK)) {\n\t\t\t\t\tms_set_err_code(chip, MS_CMD_NK);\n\t\t\t\t\treturn ms_parse_err_code(chip);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (val & MS_RDY_TIMEOUT) {\n\t\t\tms_set_err_code(chip, MS_TO_ERROR);\n\t\t\treturn ms_parse_err_code(chip);\n\t\t}\n\n\t\tms_set_err_code(chip, MS_TO_ERROR);\n\t\treturn ms_parse_err_code(chip);\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_read_bytes(struct rtsx_chip *chip,\n\t\t\t u8 tpc, u8 cnt, u8 cfg, u8 *data, int data_len)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, i;\n\tu8 *ptr;\n\n\tif (!data)\n\t\treturn STATUS_ERROR;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_BYTE_CNT, 0xFF, cnt);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\n\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t     0x01, PINGPONG_BUFFER);\n\n\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TRANSFER, 0xFF,\n\t\t     MS_TRANSFER_START | MS_TM_READ_BYTES);\n\trtsx_add_cmd(chip, CHECK_REG_CMD, MS_TRANSFER,\n\t\t     MS_TRANSFER_END, MS_TRANSFER_END);\n\n\tfor (i = 0; i < data_len - 1; i++)\n\t\trtsx_add_cmd(chip, READ_REG_CMD, PPBUF_BASE2 + i, 0, 0);\n\n\tif (data_len % 2)\n\t\trtsx_add_cmd(chip, READ_REG_CMD, PPBUF_BASE2 + data_len, 0, 0);\n\telse\n\t\trtsx_add_cmd(chip, READ_REG_CMD, PPBUF_BASE2 + data_len - 1,\n\t\t\t     0, 0);\n\n\tretval = rtsx_send_cmd(chip, MS_CARD, 5000);\n\tif (retval < 0) {\n\t\tu8 val = 0;\n\n\t\trtsx_read_register(chip, MS_TRANS_CFG, &val);\n\t\trtsx_clear_ms_error(chip);\n\n\t\tif (!(tpc & 0x08)) {\n\t\t\tif (val & MS_CRC16_ERR) {\n\t\t\t\tms_set_err_code(chip, MS_CRC16_ERROR);\n\t\t\t\treturn ms_parse_err_code(chip);\n\t\t\t}\n\t\t} else {\n\t\t\tif (CHK_MSPRO(ms_card) && !(val & 0x80)) {\n\t\t\t\tif (val & (MS_INT_ERR | MS_INT_CMDNK)) {\n\t\t\t\t\tms_set_err_code(chip, MS_CMD_NK);\n\t\t\t\t\treturn ms_parse_err_code(chip);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (val & MS_RDY_TIMEOUT) {\n\t\t\tms_set_err_code(chip, MS_TO_ERROR);\n\t\t\treturn ms_parse_err_code(chip);\n\t\t}\n\n\t\tms_set_err_code(chip, MS_TO_ERROR);\n\t\treturn ms_parse_err_code(chip);\n\t}\n\n\tptr = rtsx_get_cmd_data(chip) + 1;\n\n\tfor (i = 0; i < data_len; i++)\n\t\tdata[i] = ptr[i];\n\n\tif (tpc == PRO_READ_SHORT_DATA && data_len == 8) {\n\t\tdev_dbg(rtsx_dev(chip), \"Read format progress:\\n\");\n\t\tprint_hex_dump_bytes(KBUILD_MODNAME \": \", DUMP_PREFIX_NONE, ptr,\n\t\t\t\t     cnt);\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_set_rw_reg_addr(struct rtsx_chip *chip, u8 read_start,\n\t\t\t      u8 read_cnt, u8 write_start, u8 write_cnt)\n{\n\tint retval, i;\n\tu8 data[4];\n\n\tdata[0] = read_start;\n\tdata[1] = read_cnt;\n\tdata[2] = write_start;\n\tdata[3] = write_cnt;\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_write_bytes(chip, SET_RW_REG_ADRS, 4,\n\t\t\t\t\tNO_WAIT_INT, data, 4);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\treturn STATUS_SUCCESS;\n\t\trtsx_clear_ms_error(chip);\n\t}\n\n\treturn STATUS_FAIL;\n}\n\nstatic int ms_send_cmd(struct rtsx_chip *chip, u8 cmd, u8 cfg)\n{\n\tu8 data[2];\n\n\tdata[0] = cmd;\n\tdata[1] = 0;\n\n\treturn ms_write_bytes(chip, PRO_SET_CMD, 1, cfg, data, 1);\n}\n\nstatic int ms_set_init_para(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\n\tif (CHK_HG8BIT(ms_card)) {\n\t\tif (chip->asic_code)\n\t\t\tms_card->ms_clock = chip->asic_ms_hg_clk;\n\t\telse\n\t\t\tms_card->ms_clock = chip->fpga_ms_hg_clk;\n\n\t} else if (CHK_MSPRO(ms_card) || CHK_MS4BIT(ms_card)) {\n\t\tif (chip->asic_code)\n\t\t\tms_card->ms_clock = chip->asic_ms_4bit_clk;\n\t\telse\n\t\t\tms_card->ms_clock = chip->fpga_ms_4bit_clk;\n\n\t} else {\n\t\tif (chip->asic_code)\n\t\t\tms_card->ms_clock = chip->asic_ms_1bit_clk;\n\t\telse\n\t\t\tms_card->ms_clock = chip->fpga_ms_1bit_clk;\n\t}\n\n\tretval = switch_clock(chip, ms_card->ms_clock);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = select_card(chip, MS_CARD);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_switch_clock(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\n\tretval = select_card(chip, MS_CARD);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = switch_clock(chip, ms_card->ms_clock);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_pull_ctl_disable(struct rtsx_chip *chip)\n{\n\tint retval;\n\n\tif (CHECK_PID(chip, 0x5208)) {\n\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL1, 0xFF,\n\t\t\t\t\t     MS_D1_PD | MS_D2_PD | MS_CLK_PD |\n\t\t\t\t\t     MS_D6_PD);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL2, 0xFF,\n\t\t\t\t\t     MS_D3_PD | MS_D0_PD | MS_BS_PD |\n\t\t\t\t\t     XD_D4_PD);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL3, 0xFF,\n\t\t\t\t\t     MS_D7_PD | XD_CE_PD | XD_CLE_PD |\n\t\t\t\t\t     XD_CD_PU);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL4, 0xFF,\n\t\t\t\t\t     XD_RDY_PD | SD_D3_PD | SD_D2_PD |\n\t\t\t\t\t     XD_ALE_PD);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL5, 0xFF,\n\t\t\t\t\t     MS_INS_PU | SD_WP_PD | SD_CD_PU |\n\t\t\t\t\t     SD_CMD_PD);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL6, 0xFF,\n\t\t\t\t\t     MS_D5_PD | MS_D4_PD);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t} else if (CHECK_PID(chip, 0x5288)) {\n\t\tif (CHECK_BARO_PKG(chip, QFN)) {\n\t\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL1,\n\t\t\t\t\t\t     0xFF, 0x55);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\n\t\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL2,\n\t\t\t\t\t\t     0xFF, 0x55);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\n\t\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL3,\n\t\t\t\t\t\t     0xFF, 0x4B);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\n\t\t\tretval = rtsx_write_register(chip, CARD_PULL_CTL4,\n\t\t\t\t\t\t     0xFF, 0x69);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_pull_ctl_enable(struct rtsx_chip *chip)\n{\n\tint retval;\n\n\trtsx_init_cmd(chip);\n\n\tif (CHECK_PID(chip, 0x5208)) {\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF,\n\t\t\t     MS_D1_PD | MS_D2_PD | MS_CLK_NP | MS_D6_PD);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF,\n\t\t\t     MS_D3_PD | MS_D0_PD | MS_BS_NP | XD_D4_PD);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF,\n\t\t\t     MS_D7_PD | XD_CE_PD | XD_CLE_PD | XD_CD_PU);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF,\n\t\t\t     XD_RDY_PD | SD_D3_PD | SD_D2_PD | XD_ALE_PD);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF,\n\t\t\t     MS_INS_PU | SD_WP_PD | SD_CD_PU | SD_CMD_PD);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF,\n\t\t\t     MS_D5_PD | MS_D4_PD);\n\t} else if (CHECK_PID(chip, 0x5288)) {\n\t\tif (CHECK_BARO_PKG(chip, QFN)) {\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD,\n\t\t\t\t     CARD_PULL_CTL1, 0xFF, 0x55);\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD,\n\t\t\t\t     CARD_PULL_CTL2, 0xFF, 0x45);\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD,\n\t\t\t\t     CARD_PULL_CTL3, 0xFF, 0x4B);\n\t\t\trtsx_add_cmd(chip, WRITE_REG_CMD,\n\t\t\t\t     CARD_PULL_CTL4, 0xFF, 0x29);\n\t\t}\n\t}\n\n\tretval = rtsx_send_cmd(chip, MS_CARD, 100);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_prepare_reset(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\tu8 oc_mask = 0;\n\n\tms_card->ms_type = 0;\n\tms_card->check_ms_flow = 0;\n\tms_card->switch_8bit_fail = 0;\n\tms_card->delay_write.delay_write_flag = 0;\n\n\tms_card->pro_under_formatting = 0;\n\n\tretval = ms_power_off_card3v3(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (!chip->ft2_fast_mode)\n\t\twait_timeout(250);\n\n\tretval = enable_card_clock(chip, MS_CARD);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (chip->asic_code) {\n\t\tretval = ms_pull_ctl_enable(chip);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t} else {\n\t\tretval = rtsx_write_register(chip, FPGA_PULL_CTL,\n\t\t\t\t\t     FPGA_MS_PULL_CTL_BIT | 0x20, 0);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tif (!chip->ft2_fast_mode) {\n\t\tretval = card_power_on(chip, MS_CARD);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\twait_timeout(150);\n\n#ifdef SUPPORT_OCP\n\t\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN))\n\t\t\toc_mask = MS_OC_NOW | MS_OC_EVER;\n\t\telse\n\t\t\toc_mask = SD_OC_NOW | SD_OC_EVER;\n\n\t\tif (chip->ocp_stat & oc_mask) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"Over current, OCPSTAT is 0x%x\\n\",\n\t\t\t\tchip->ocp_stat);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n#endif\n\t}\n\n\tretval = rtsx_write_register(chip, CARD_OE, MS_OUTPUT_EN,\n\t\t\t\t     MS_OUTPUT_EN);\n\tif (retval)\n\t\treturn retval;\n\n\tif (chip->asic_code) {\n\t\tretval = rtsx_write_register(chip, MS_CFG, 0xFF,\n\t\t\t\t\t     SAMPLE_TIME_RISING |\n\t\t\t\t\t     PUSH_TIME_DEFAULT |\n\t\t\t\t\t     NO_EXTEND_TOGGLE |\n\t\t\t\t\t     MS_BUS_WIDTH_1);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t} else {\n\t\tretval = rtsx_write_register(chip, MS_CFG, 0xFF,\n\t\t\t\t\t     SAMPLE_TIME_FALLING |\n\t\t\t\t\t     PUSH_TIME_DEFAULT |\n\t\t\t\t\t     NO_EXTEND_TOGGLE |\n\t\t\t\t\t     MS_BUS_WIDTH_1);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\tretval = rtsx_write_register(chip, MS_TRANS_CFG, 0xFF,\n\t\t\t\t     NO_WAIT_INT | NO_AUTO_READ_INT_REG);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = rtsx_write_register(chip, CARD_STOP, MS_STOP | MS_CLR_ERR,\n\t\t\t\t     MS_STOP | MS_CLR_ERR);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = ms_set_init_para(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_identify_media_type(struct rtsx_chip *chip, int switch_8bit_bus)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, i;\n\tu8 val;\n\n\tretval = ms_set_rw_reg_addr(chip, PRO_STATUS_REG, 6, SYSTEM_PARAM, 1);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_transfer_tpc(chip, MS_TM_READ_BYTES, READ_REG,\n\t\t\t\t\t 6, NO_WAIT_INT);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (i == MS_MAX_RETRY_COUNT)\n\t\treturn STATUS_FAIL;\n\n\tretval = rtsx_read_register(chip, PPBUF_BASE2 + 2, &val);\n\tif (retval)\n\t\treturn retval;\n\n\tdev_dbg(rtsx_dev(chip), \"Type register: 0x%x\\n\", val);\n\tif (val != 0x01) {\n\t\tif (val != 0x02)\n\t\t\tms_card->check_ms_flow = 1;\n\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = rtsx_read_register(chip, PPBUF_BASE2 + 4, &val);\n\tif (retval)\n\t\treturn retval;\n\n\tdev_dbg(rtsx_dev(chip), \"Category register: 0x%x\\n\", val);\n\tif (val != 0) {\n\t\tms_card->check_ms_flow = 1;\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = rtsx_read_register(chip, PPBUF_BASE2 + 5, &val);\n\tif (retval)\n\t\treturn retval;\n\n\tdev_dbg(rtsx_dev(chip), \"Class register: 0x%x\\n\", val);\n\tif (val == 0) {\n\t\tretval = rtsx_read_register(chip, PPBUF_BASE2, &val);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tif (val & WRT_PRTCT)\n\t\t\tchip->card_wp |= MS_CARD;\n\t\telse\n\t\t\tchip->card_wp &= ~MS_CARD;\n\n\t} else if ((val == 0x01) || (val == 0x02) || (val == 0x03)) {\n\t\tchip->card_wp |= MS_CARD;\n\t} else {\n\t\tms_card->check_ms_flow = 1;\n\t\treturn STATUS_FAIL;\n\t}\n\n\tms_card->ms_type |= TYPE_MSPRO;\n\n\tretval = rtsx_read_register(chip, PPBUF_BASE2 + 3, &val);\n\tif (retval)\n\t\treturn retval;\n\n\tdev_dbg(rtsx_dev(chip), \"IF Mode register: 0x%x\\n\", val);\n\tif (val == 0) {\n\t\tms_card->ms_type &= 0x0F;\n\t} else if (val == 7) {\n\t\tif (switch_8bit_bus)\n\t\t\tms_card->ms_type |= MS_HG;\n\t\telse\n\t\t\tms_card->ms_type &= 0x0F;\n\n\t} else {\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_confirm_cpu_startup(struct rtsx_chip *chip)\n{\n\tint retval, i, k;\n\tu8 val;\n\n\t \n\tk = 0;\n\tdo {\n\t\tif (detect_card_cd(chip, MS_CARD) != STATUS_SUCCESS) {\n\t\t\tms_set_err_code(chip, MS_NO_CARD);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\t\tretval = ms_read_bytes(chip, GET_INT, 1,\n\t\t\t\t\t       NO_WAIT_INT, &val, 1);\n\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == MS_MAX_RETRY_COUNT)\n\t\t\treturn STATUS_FAIL;\n\n\t\tif (k > 100)\n\t\t\treturn STATUS_FAIL;\n\n\t\tk++;\n\t\twait_timeout(100);\n\t} while (!(val & INT_REG_CED));\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_read_bytes(chip, GET_INT, 1, NO_WAIT_INT, &val, 1);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (i == MS_MAX_RETRY_COUNT)\n\t\treturn STATUS_FAIL;\n\n\tif (val & INT_REG_ERR) {\n\t\tif (val & INT_REG_CMDNK)\n\t\t\tchip->card_wp |= (MS_CARD);\n\t\telse\n\t\t\treturn STATUS_FAIL;\n\t}\n\t \n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_switch_parallel_bus(struct rtsx_chip *chip)\n{\n\tint retval, i;\n\tu8 data[2];\n\n\tdata[0] = PARALLEL_4BIT_IF;\n\tdata[1] = 0;\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_write_bytes(chip, WRITE_REG, 1, NO_WAIT_INT,\n\t\t\t\t\tdata, 2);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_switch_8bit_bus(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, i;\n\tu8 data[2];\n\n\tdata[0] = PARALLEL_8BIT_IF;\n\tdata[1] = 0;\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_write_bytes(chip, WRITE_REG, 1,\n\t\t\t\t\tNO_WAIT_INT, data, 2);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = rtsx_write_register(chip, MS_CFG, 0x98,\n\t\t\t\t     MS_BUS_WIDTH_8 | SAMPLE_TIME_FALLING);\n\tif (retval)\n\t\treturn retval;\n\n\tms_card->ms_type |= MS_8BIT;\n\tretval = ms_set_init_para(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_transfer_tpc(chip, MS_TM_READ_BYTES, GET_INT,\n\t\t\t\t\t 1, NO_WAIT_INT);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_pro_reset_flow(struct rtsx_chip *chip, int switch_8bit_bus)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tretval = ms_prepare_reset(chip);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = ms_identify_media_type(chip, switch_8bit_bus);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = ms_confirm_cpu_startup(chip);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = ms_switch_parallel_bus(chip);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tif (detect_card_cd(chip, MS_CARD) != STATUS_SUCCESS) {\n\t\t\t\tms_set_err_code(chip, MS_NO_CARD);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\t \n\tretval = rtsx_write_register(chip, MS_CFG, 0x18, MS_BUS_WIDTH_4);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = rtsx_write_register(chip, MS_CFG, PUSH_TIME_ODD,\n\t\t\t\t     PUSH_TIME_ODD);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = ms_set_init_para(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\t \n\tif (CHK_MSHG(ms_card) && chip->support_ms_8bit && switch_8bit_bus) {\n\t\tretval = ms_switch_8bit_bus(chip);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tms_card->switch_8bit_fail = 1;\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\n#ifdef XC_POWERCLASS\nstatic int msxc_change_power(struct rtsx_chip *chip, u8 mode)\n{\n\tint retval;\n\tu8 buf[6];\n\n\tms_cleanup_work(chip);\n\n\tretval = ms_set_rw_reg_addr(chip, 0, 0, PRO_DATA_COUNT1, 6);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tbuf[0] = 0;\n\tbuf[1] = mode;\n\tbuf[2] = 0;\n\tbuf[3] = 0;\n\tbuf[4] = 0;\n\tbuf[5] = 0;\n\n\tretval = ms_write_bytes(chip, PRO_WRITE_REG, 6, NO_WAIT_INT, buf, 6);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = ms_send_cmd(chip, XC_CHG_POWER, WAIT_INT);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = rtsx_read_register(chip, MS_TRANS_CFG, buf);\n\tif (retval)\n\t\treturn retval;\n\n\tif (buf[0] & (MS_INT_CMDNK | MS_INT_ERR))\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n#endif\n\nstatic int ms_read_attribute_info(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, i;\n\tu8 val, *buf, class_code, device_type, sub_class, data[16];\n\tu16 total_blk = 0, blk_size = 0;\n#ifdef SUPPORT_MSXC\n\tu32 xc_total_blk = 0, xc_blk_size = 0;\n#endif\n\tu32 sys_info_addr = 0, sys_info_size;\n#ifdef SUPPORT_PCGL_1P18\n\tu32 model_name_addr = 0, model_name_size;\n\tint found_sys_info = 0, found_model_name = 0;\n#endif\n\n\tretval = ms_set_rw_reg_addr(chip, PRO_INT_REG, 2, PRO_SYSTEM_PARAM, 7);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (CHK_MS8BIT(ms_card))\n\t\tdata[0] = PARALLEL_8BIT_IF;\n\telse\n\t\tdata[0] = PARALLEL_4BIT_IF;\n\n\tdata[1] = 0;\n\n\tdata[2] = 0x40;\n\tdata[3] = 0;\n\tdata[4] = 0;\n\tdata[5] = 0;\n\tdata[6] = 0;\n\tdata[7] = 0;\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_write_bytes(chip, PRO_WRITE_REG, 7, NO_WAIT_INT,\n\t\t\t\t\tdata, 8);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tbuf = kmalloc(64 * 512, GFP_KERNEL);\n\tif (!buf)\n\t\treturn STATUS_ERROR;\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_send_cmd(chip, PRO_READ_ATRB, WAIT_INT);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\tcontinue;\n\n\t\tretval = rtsx_read_register(chip, MS_TRANS_CFG, &val);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tkfree(buf);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t\tif (!(val & MS_INT_BREQ)) {\n\t\t\tkfree(buf);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t\tretval = ms_transfer_data(chip, MS_TM_AUTO_READ,\n\t\t\t\t\t  PRO_READ_LONG_DATA, 0x40, WAIT_INT,\n\t\t\t\t\t  0, 0, buf, 64 * 512);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\n\t\trtsx_clear_ms_error(chip);\n\t}\n\tif (retval != STATUS_SUCCESS) {\n\t\tkfree(buf);\n\t\treturn STATUS_FAIL;\n\t}\n\n\ti = 0;\n\tdo {\n\t\tretval = rtsx_read_register(chip, MS_TRANS_CFG, &val);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tkfree(buf);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tif ((val & MS_INT_CED) || !(val & MS_INT_BREQ))\n\t\t\tbreak;\n\n\t\tretval = ms_transfer_tpc(chip, MS_TM_NORMAL_READ,\n\t\t\t\t\t PRO_READ_LONG_DATA, 0, WAIT_INT);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tkfree(buf);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\ti++;\n\t} while (i < 1024);\n\n\tif (buf[0] != 0xa5 && buf[1] != 0xc3) {\n\t\t \n\t\tkfree(buf);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tif (buf[4] < 1 || buf[4] > 12) {\n\t\tkfree(buf);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tfor (i = 0; i < buf[4]; i++) {\n\t\tint cur_addr_off = 16 + i * 12;\n\n#ifdef SUPPORT_MSXC\n\t\tif (buf[cur_addr_off + 8] == 0x10 ||\n\t\t    buf[cur_addr_off + 8] == 0x13) {\n#else\n\t\tif (buf[cur_addr_off + 8] == 0x10) {\n#endif\n\t\t\tsys_info_addr = ((u32)buf[cur_addr_off + 0] << 24) |\n\t\t\t\t((u32)buf[cur_addr_off + 1] << 16) |\n\t\t\t\t((u32)buf[cur_addr_off + 2] << 8) |\n\t\t\t\tbuf[cur_addr_off + 3];\n\t\t\tsys_info_size = ((u32)buf[cur_addr_off + 4] << 24) |\n\t\t\t\t((u32)buf[cur_addr_off + 5] << 16) |\n\t\t\t\t((u32)buf[cur_addr_off + 6] << 8) |\n\t\t\t\tbuf[cur_addr_off + 7];\n\t\t\tdev_dbg(rtsx_dev(chip), \"sys_info_addr = 0x%x, sys_info_size = 0x%x\\n\",\n\t\t\t\tsys_info_addr, sys_info_size);\n\t\t\tif (sys_info_size != 96)  {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t\tif (sys_info_addr < 0x1A0) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t\tif ((sys_info_size + sys_info_addr) > 0x8000) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n#ifdef SUPPORT_MSXC\n\t\t\tif (buf[cur_addr_off + 8] == 0x13)\n\t\t\t\tms_card->ms_type |= MS_XC;\n#endif\n#ifdef SUPPORT_PCGL_1P18\n\t\t\tfound_sys_info = 1;\n#else\n\t\t\tbreak;\n#endif\n\t\t}\n#ifdef SUPPORT_PCGL_1P18\n\t\tif (buf[cur_addr_off + 8] == 0x15) {\n\t\t\tmodel_name_addr = ((u32)buf[cur_addr_off + 0] << 24) |\n\t\t\t\t((u32)buf[cur_addr_off + 1] << 16) |\n\t\t\t\t((u32)buf[cur_addr_off + 2] << 8) |\n\t\t\t\tbuf[cur_addr_off + 3];\n\t\t\tmodel_name_size = ((u32)buf[cur_addr_off + 4] << 24) |\n\t\t\t\t((u32)buf[cur_addr_off + 5] << 16) |\n\t\t\t\t((u32)buf[cur_addr_off + 6] << 8) |\n\t\t\t\tbuf[cur_addr_off + 7];\n\t\t\tdev_dbg(rtsx_dev(chip), \"model_name_addr = 0x%x, model_name_size = 0x%x\\n\",\n\t\t\t\tmodel_name_addr, model_name_size);\n\t\t\tif (model_name_size != 48)  {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t\tif (model_name_addr < 0x1A0) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t\tif ((model_name_size + model_name_addr) > 0x8000) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\tfound_model_name = 1;\n\t\t}\n\n\t\tif (found_sys_info && found_model_name)\n\t\t\tbreak;\n#endif\n\t}\n\n\tif (i == buf[4]) {\n\t\tkfree(buf);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tclass_code =  buf[sys_info_addr + 0];\n\tdevice_type = buf[sys_info_addr + 56];\n\tsub_class = buf[sys_info_addr + 46];\n#ifdef SUPPORT_MSXC\n\tif (CHK_MSXC(ms_card)) {\n\t\txc_total_blk = ((u32)buf[sys_info_addr + 6] << 24) |\n\t\t\t\t((u32)buf[sys_info_addr + 7] << 16) |\n\t\t\t\t((u32)buf[sys_info_addr + 8] << 8) |\n\t\t\t\tbuf[sys_info_addr + 9];\n\t\txc_blk_size = ((u32)buf[sys_info_addr + 32] << 24) |\n\t\t\t\t((u32)buf[sys_info_addr + 33] << 16) |\n\t\t\t\t((u32)buf[sys_info_addr + 34] << 8) |\n\t\t\t\tbuf[sys_info_addr + 35];\n\t\tdev_dbg(rtsx_dev(chip), \"xc_total_blk = 0x%x, xc_blk_size = 0x%x\\n\",\n\t\t\txc_total_blk, xc_blk_size);\n\t} else {\n\t\ttotal_blk = ((u16)buf[sys_info_addr + 6] << 8) |\n\t\t\tbuf[sys_info_addr + 7];\n\t\tblk_size = ((u16)buf[sys_info_addr + 2] << 8) |\n\t\t\tbuf[sys_info_addr + 3];\n\t\tdev_dbg(rtsx_dev(chip), \"total_blk = 0x%x, blk_size = 0x%x\\n\",\n\t\t\ttotal_blk, blk_size);\n\t}\n#else\n\ttotal_blk = ((u16)buf[sys_info_addr + 6] << 8) | buf[sys_info_addr + 7];\n\tblk_size = ((u16)buf[sys_info_addr + 2] << 8) | buf[sys_info_addr + 3];\n\tdev_dbg(rtsx_dev(chip), \"total_blk = 0x%x, blk_size = 0x%x\\n\",\n\t\ttotal_blk, blk_size);\n#endif\n\n\tdev_dbg(rtsx_dev(chip), \"class_code = 0x%x, device_type = 0x%x, sub_class = 0x%x\\n\",\n\t\tclass_code, device_type, sub_class);\n\n\tmemcpy(ms_card->raw_sys_info, buf + sys_info_addr, 96);\n#ifdef SUPPORT_PCGL_1P18\n\tmemcpy(ms_card->raw_model_name, buf + model_name_addr, 48);\n#endif\n\n\tkfree(buf);\n\n#ifdef SUPPORT_MSXC\n\tif (CHK_MSXC(ms_card)) {\n\t\tif (class_code != 0x03)\n\t\t\treturn STATUS_FAIL;\n\t} else {\n\t\tif (class_code != 0x02)\n\t\t\treturn STATUS_FAIL;\n\t}\n#else\n\tif (class_code != 0x02)\n\t\treturn STATUS_FAIL;\n#endif\n\n\tif (device_type != 0x00) {\n\t\tif (device_type == 0x01 || device_type == 0x02 ||\n\t\t    device_type == 0x03) {\n\t\t\tchip->card_wp |= MS_CARD;\n\t\t} else {\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\tif (sub_class & 0xC0)\n\t\treturn STATUS_FAIL;\n\n\tdev_dbg(rtsx_dev(chip), \"class_code: 0x%x, device_type: 0x%x, sub_class: 0x%x\\n\",\n\t\tclass_code, device_type, sub_class);\n\n#ifdef SUPPORT_MSXC\n\tif (CHK_MSXC(ms_card)) {\n\t\tchip->capacity[chip->card2lun[MS_CARD]] =\n\t\t\tms_card->capacity = xc_total_blk * xc_blk_size;\n\t} else {\n\t\tchip->capacity[chip->card2lun[MS_CARD]] =\n\t\t\tms_card->capacity = total_blk * blk_size;\n\t}\n#else\n\tms_card->capacity = total_blk * blk_size;\n\tchip->capacity[chip->card2lun[MS_CARD]] = ms_card->capacity;\n#endif\n\n\treturn STATUS_SUCCESS;\n}\n\n#ifdef SUPPORT_MAGIC_GATE\nstatic int mg_set_tpc_para_sub(struct rtsx_chip *chip,\n\t\t\t       int type, u8 mg_entry_num);\n#endif\n\nstatic int reset_ms_pro(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n#ifdef XC_POWERCLASS\n\tu8 change_power_class;\n\n\tif (chip->ms_power_class_en & 0x02)\n\t\tchange_power_class = 2;\n\telse if (chip->ms_power_class_en & 0x01)\n\t\tchange_power_class = 1;\n\telse\n\t\tchange_power_class = 0;\n#endif\n\n#ifdef XC_POWERCLASS\nretry:\n#endif\n\tretval = ms_pro_reset_flow(chip, 1);\n\tif (retval != STATUS_SUCCESS) {\n\t\tif (ms_card->switch_8bit_fail) {\n\t\t\tretval = ms_pro_reset_flow(chip, 0);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\t\t} else {\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\tretval = ms_read_attribute_info(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n#ifdef XC_POWERCLASS\n\tif (CHK_HG8BIT(ms_card))\n\t\tchange_power_class = 0;\n\n\tif (change_power_class && CHK_MSXC(ms_card)) {\n\t\tu8 power_class_en = chip->ms_power_class_en;\n\n\t\tdev_dbg(rtsx_dev(chip), \"power_class_en = 0x%x\\n\",\n\t\t\tpower_class_en);\n\t\tdev_dbg(rtsx_dev(chip), \"change_power_class = %d\\n\",\n\t\t\tchange_power_class);\n\n\t\tif (change_power_class)\n\t\t\tpower_class_en &= (1 << (change_power_class - 1));\n\t\telse\n\t\t\tpower_class_en = 0;\n\n\t\tif (power_class_en) {\n\t\t\tu8 power_class_mode =\n\t\t\t\t(ms_card->raw_sys_info[46] & 0x18) >> 3;\n\t\t\tdev_dbg(rtsx_dev(chip), \"power_class_mode = 0x%x\",\n\t\t\t\tpower_class_mode);\n\t\t\tif (change_power_class > power_class_mode)\n\t\t\t\tchange_power_class = power_class_mode;\n\t\t\tif (change_power_class) {\n\t\t\t\tretval = msxc_change_power(chip,\n\t\t\t\t\t\t\t   change_power_class);\n\t\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\t\tchange_power_class--;\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n#ifdef SUPPORT_MAGIC_GATE\n\tretval = mg_set_tpc_para_sub(chip, 0, 0);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n#endif\n\n\tif (CHK_HG8BIT(ms_card))\n\t\tchip->card_bus_width[chip->card2lun[MS_CARD]] = 8;\n\telse\n\t\tchip->card_bus_width[chip->card2lun[MS_CARD]] = 4;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_read_status_reg(struct rtsx_chip *chip)\n{\n\tint retval;\n\tu8 val[2];\n\n\tretval = ms_set_rw_reg_addr(chip, STATUS_REG0, 2, 0, 0);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = ms_read_bytes(chip, READ_REG, 2, NO_WAIT_INT, val, 2);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (val[1] & (STS_UCDT | STS_UCEX | STS_UCFG)) {\n\t\tms_set_err_code(chip, MS_FLASH_READ_ERROR);\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_read_extra_data(struct rtsx_chip *chip,\n\t\t\t      u16 block_addr, u8 page_num, u8 *buf, int buf_len)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, i;\n\tu8 val, data[10];\n\n\tretval = ms_set_rw_reg_addr(chip, OVERWRITE_FLAG, MS_EXTRA_SIZE,\n\t\t\t\t    SYSTEM_PARAM, 6);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (CHK_MS4BIT(ms_card)) {\n\t\t \n\t\tdata[0] = 0x88;\n\t} else {\n\t\t \n\t\tdata[0] = 0x80;\n\t}\n\tdata[1] = 0;\n\tdata[2] = (u8)(block_addr >> 8);\n\tdata[3] = (u8)block_addr;\n\tdata[4] = 0x40;\n\tdata[5] = page_num;\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_write_bytes(chip, WRITE_REG, 6, NO_WAIT_INT,\n\t\t\t\t\tdata, 6);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (i == MS_MAX_RETRY_COUNT)\n\t\treturn STATUS_FAIL;\n\n\tms_set_err_code(chip, MS_NO_ERROR);\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_send_cmd(chip, BLOCK_READ, WAIT_INT);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (i == MS_MAX_RETRY_COUNT)\n\t\treturn STATUS_FAIL;\n\n\tms_set_err_code(chip, MS_NO_ERROR);\n\tretval = ms_read_bytes(chip, GET_INT, 1, NO_WAIT_INT, &val, 1);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (val & INT_REG_CMDNK) {\n\t\tms_set_err_code(chip, MS_CMD_NK);\n\t\treturn STATUS_FAIL;\n\t}\n\tif (val & INT_REG_CED) {\n\t\tif (val & INT_REG_ERR) {\n\t\t\tretval = ms_read_status_reg(chip);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\n\t\t\tretval = ms_set_rw_reg_addr(chip, OVERWRITE_FLAG,\n\t\t\t\t\t\t    MS_EXTRA_SIZE, SYSTEM_PARAM,\n\t\t\t\t\t\t    6);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\tretval = ms_read_bytes(chip, READ_REG, MS_EXTRA_SIZE, NO_WAIT_INT,\n\t\t\t       data, MS_EXTRA_SIZE);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (buf && buf_len) {\n\t\tif (buf_len > MS_EXTRA_SIZE)\n\t\t\tbuf_len = MS_EXTRA_SIZE;\n\t\tmemcpy(buf, data, buf_len);\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_write_extra_data(struct rtsx_chip *chip, u16 block_addr,\n\t\t\t       u8 page_num, u8 *buf, int buf_len)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, i;\n\tu8 val, data[16];\n\n\tif (!buf || buf_len < MS_EXTRA_SIZE)\n\t\treturn STATUS_FAIL;\n\n\tretval = ms_set_rw_reg_addr(chip, OVERWRITE_FLAG, MS_EXTRA_SIZE,\n\t\t\t\t    SYSTEM_PARAM, 6 + MS_EXTRA_SIZE);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (CHK_MS4BIT(ms_card))\n\t\tdata[0] = 0x88;\n\telse\n\t\tdata[0] = 0x80;\n\n\tdata[1] = 0;\n\tdata[2] = (u8)(block_addr >> 8);\n\tdata[3] = (u8)block_addr;\n\tdata[4] = 0x40;\n\tdata[5] = page_num;\n\n\tfor (i = 6; i < MS_EXTRA_SIZE + 6; i++)\n\t\tdata[i] = buf[i - 6];\n\n\tretval = ms_write_bytes(chip, WRITE_REG, (6 + MS_EXTRA_SIZE),\n\t\t\t\tNO_WAIT_INT, data, 16);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = ms_send_cmd(chip, BLOCK_WRITE, WAIT_INT);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tms_set_err_code(chip, MS_NO_ERROR);\n\tretval = ms_read_bytes(chip, GET_INT, 1, NO_WAIT_INT, &val, 1);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (val & INT_REG_CMDNK) {\n\t\tms_set_err_code(chip, MS_CMD_NK);\n\t\treturn STATUS_FAIL;\n\t}\n\tif (val & INT_REG_CED) {\n\t\tif (val & INT_REG_ERR) {\n\t\t\tms_set_err_code(chip, MS_FLASH_WRITE_ERROR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_read_page(struct rtsx_chip *chip, u16 block_addr, u8 page_num)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\tu8 val, data[6];\n\n\tretval = ms_set_rw_reg_addr(chip, OVERWRITE_FLAG, MS_EXTRA_SIZE,\n\t\t\t\t    SYSTEM_PARAM, 6);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (CHK_MS4BIT(ms_card))\n\t\tdata[0] = 0x88;\n\telse\n\t\tdata[0] = 0x80;\n\n\tdata[1] = 0;\n\tdata[2] = (u8)(block_addr >> 8);\n\tdata[3] = (u8)block_addr;\n\tdata[4] = 0x20;\n\tdata[5] = page_num;\n\n\tretval = ms_write_bytes(chip, WRITE_REG, 6, NO_WAIT_INT, data, 6);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = ms_send_cmd(chip, BLOCK_READ, WAIT_INT);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tms_set_err_code(chip, MS_NO_ERROR);\n\tretval = ms_read_bytes(chip, GET_INT, 1, NO_WAIT_INT, &val, 1);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (val & INT_REG_CMDNK) {\n\t\tms_set_err_code(chip, MS_CMD_NK);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tif (val & INT_REG_CED) {\n\t\tif (val & INT_REG_ERR) {\n\t\t\tif (!(val & INT_REG_BREQ)) {\n\t\t\t\tms_set_err_code(chip,  MS_FLASH_READ_ERROR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t\tretval = ms_read_status_reg(chip);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\tms_set_err_code(chip,  MS_FLASH_WRITE_ERROR);\n\n\t\t} else {\n\t\t\tif (!(val & INT_REG_BREQ)) {\n\t\t\t\tms_set_err_code(chip, MS_BREQ_ERROR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t}\n\t}\n\n\tretval = ms_transfer_tpc(chip, MS_TM_NORMAL_READ, READ_PAGE_DATA,\n\t\t\t\t 0, NO_WAIT_INT);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (ms_check_err_code(chip, MS_FLASH_WRITE_ERROR))\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_set_bad_block(struct rtsx_chip *chip, u16 phy_blk)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\tu8 val, data[8], extra[MS_EXTRA_SIZE];\n\n\tretval = ms_read_extra_data(chip, phy_blk, 0, extra, MS_EXTRA_SIZE);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = ms_set_rw_reg_addr(chip, OVERWRITE_FLAG, MS_EXTRA_SIZE,\n\t\t\t\t    SYSTEM_PARAM, 7);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tms_set_err_code(chip, MS_NO_ERROR);\n\n\tif (CHK_MS4BIT(ms_card))\n\t\tdata[0] = 0x88;\n\telse\n\t\tdata[0] = 0x80;\n\n\tdata[1] = 0;\n\tdata[2] = (u8)(phy_blk >> 8);\n\tdata[3] = (u8)phy_blk;\n\tdata[4] = 0x80;\n\tdata[5] = 0;\n\tdata[6] = extra[0] & 0x7F;\n\tdata[7] = 0xFF;\n\n\tretval = ms_write_bytes(chip, WRITE_REG, 7, NO_WAIT_INT, data, 7);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = ms_send_cmd(chip, BLOCK_WRITE, WAIT_INT);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tms_set_err_code(chip, MS_NO_ERROR);\n\tretval = ms_read_bytes(chip, GET_INT, 1, NO_WAIT_INT, &val, 1);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (val & INT_REG_CMDNK) {\n\t\tms_set_err_code(chip, MS_CMD_NK);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tif (val & INT_REG_CED) {\n\t\tif (val & INT_REG_ERR) {\n\t\t\tms_set_err_code(chip, MS_FLASH_WRITE_ERROR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_erase_block(struct rtsx_chip *chip, u16 phy_blk)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, i = 0;\n\tu8 val, data[6];\n\n\tretval = ms_set_rw_reg_addr(chip, OVERWRITE_FLAG, MS_EXTRA_SIZE,\n\t\t\t\t    SYSTEM_PARAM, 6);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tms_set_err_code(chip, MS_NO_ERROR);\n\n\tif (CHK_MS4BIT(ms_card))\n\t\tdata[0] = 0x88;\n\telse\n\t\tdata[0] = 0x80;\n\n\tdata[1] = 0;\n\tdata[2] = (u8)(phy_blk >> 8);\n\tdata[3] = (u8)phy_blk;\n\tdata[4] = 0;\n\tdata[5] = 0;\n\n\tretval = ms_write_bytes(chip, WRITE_REG, 6, NO_WAIT_INT, data, 6);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\nERASE_RTY:\n\tretval = ms_send_cmd(chip, BLOCK_ERASE, WAIT_INT);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tms_set_err_code(chip, MS_NO_ERROR);\n\tretval = ms_read_bytes(chip, GET_INT, 1, NO_WAIT_INT, &val, 1);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (val & INT_REG_CMDNK) {\n\t\tif (i < 3) {\n\t\t\ti++;\n\t\t\tgoto ERASE_RTY;\n\t\t}\n\n\t\tms_set_err_code(chip, MS_CMD_NK);\n\t\tms_set_bad_block(chip, phy_blk);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tif (val & INT_REG_CED) {\n\t\tif (val & INT_REG_ERR) {\n\t\t\tms_set_err_code(chip, MS_FLASH_WRITE_ERROR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic void ms_set_page_status(u16 log_blk, u8 type, u8 *extra, int extra_len)\n{\n\tif (!extra || extra_len < MS_EXTRA_SIZE)\n\t\treturn;\n\n\tmemset(extra, 0xFF, MS_EXTRA_SIZE);\n\n\tif (type == set_PS_NG) {\n\t\t \n\t\textra[0] = 0xB8;\n\t} else {\n\t\t \n\t\textra[0] = 0x98;\n\t}\n\n\textra[2] = (u8)(log_blk >> 8);\n\textra[3] = (u8)log_blk;\n}\n\nstatic int ms_init_page(struct rtsx_chip *chip, u16 phy_blk, u16 log_blk,\n\t\t\tu8 start_page, u8 end_page)\n{\n\tint retval;\n\tu8 extra[MS_EXTRA_SIZE], i;\n\n\tmemset(extra, 0xff, MS_EXTRA_SIZE);\n\n\textra[0] = 0xf8;\t \n\textra[1] = 0xff;\n\textra[2] = (u8)(log_blk >> 8);\n\textra[3] = (u8)log_blk;\n\n\tfor (i = start_page; i < end_page; i++) {\n\t\tif (detect_card_cd(chip, MS_CARD) != STATUS_SUCCESS) {\n\t\t\tms_set_err_code(chip, MS_NO_CARD);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tretval = ms_write_extra_data(chip, phy_blk, i,\n\t\t\t\t\t     extra, MS_EXTRA_SIZE);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_copy_page(struct rtsx_chip *chip, u16 old_blk, u16 new_blk,\n\t\t\tu16 log_blk, u8 start_page, u8 end_page)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tbool uncorrect_flag = false;\n\tint retval, rty_cnt;\n\tu8 extra[MS_EXTRA_SIZE], val, i, j, data[16];\n\n\tdev_dbg(rtsx_dev(chip), \"Copy page from 0x%x to 0x%x, logical block is 0x%x\\n\",\n\t\told_blk, new_blk, log_blk);\n\tdev_dbg(rtsx_dev(chip), \"start_page = %d, end_page = %d\\n\",\n\t\tstart_page, end_page);\n\n\tretval = ms_read_extra_data(chip, new_blk, 0, extra, MS_EXTRA_SIZE);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = ms_read_status_reg(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = rtsx_read_register(chip, PPBUF_BASE2, &val);\n\tif (retval)\n\t\treturn retval;\n\n\tif (val & BUF_FULL) {\n\t\tretval = ms_send_cmd(chip, CLEAR_BUF, WAIT_INT);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = ms_read_bytes(chip, GET_INT, 1, NO_WAIT_INT, &val, 1);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tif (!(val & INT_REG_CED)) {\n\t\t\tms_set_err_code(chip, MS_FLASH_WRITE_ERROR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\tfor (i = start_page; i < end_page; i++) {\n\t\tif (detect_card_cd(chip, MS_CARD) != STATUS_SUCCESS) {\n\t\t\tms_set_err_code(chip, MS_NO_CARD);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tretval = ms_read_extra_data(chip, old_blk, i, extra,\n\t\t\t\t\t    MS_EXTRA_SIZE);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = ms_set_rw_reg_addr(chip, OVERWRITE_FLAG,\n\t\t\t\t\t    MS_EXTRA_SIZE, SYSTEM_PARAM, 6);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tms_set_err_code(chip, MS_NO_ERROR);\n\n\t\tif (CHK_MS4BIT(ms_card))\n\t\t\tdata[0] = 0x88;\n\t\telse\n\t\t\tdata[0] = 0x80;\n\n\t\tdata[1] = 0;\n\t\tdata[2] = (u8)(old_blk >> 8);\n\t\tdata[3] = (u8)old_blk;\n\t\tdata[4] = 0x20;\n\t\tdata[5] = i;\n\n\t\tretval = ms_write_bytes(chip, WRITE_REG, 6, NO_WAIT_INT,\n\t\t\t\t\tdata, 6);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = ms_send_cmd(chip, BLOCK_READ, WAIT_INT);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tms_set_err_code(chip, MS_NO_ERROR);\n\t\tretval = ms_read_bytes(chip, GET_INT, 1, NO_WAIT_INT, &val, 1);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tif (val & INT_REG_CMDNK) {\n\t\t\tms_set_err_code(chip, MS_CMD_NK);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tif (val & INT_REG_CED) {\n\t\t\tif (val & INT_REG_ERR) {\n\t\t\t\tretval = ms_read_status_reg(chip);\n\t\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\t\tuncorrect_flag = true;\n\t\t\t\t\tdev_dbg(rtsx_dev(chip), \"Uncorrectable error\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tuncorrect_flag = false;\n\t\t\t\t}\n\n\t\t\t\tretval = ms_transfer_tpc(chip,\n\t\t\t\t\t\t\t MS_TM_NORMAL_READ,\n\t\t\t\t\t\t\t READ_PAGE_DATA,\n\t\t\t\t\t\t\t 0, NO_WAIT_INT);\n\t\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\t\treturn STATUS_FAIL;\n\n\t\t\t\tif (uncorrect_flag) {\n\t\t\t\t\tms_set_page_status(log_blk, set_PS_NG,\n\t\t\t\t\t\t\t   extra,\n\t\t\t\t\t\t\t   MS_EXTRA_SIZE);\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t\textra[0] &= 0xEF;\n\n\t\t\t\t\tms_write_extra_data(chip, old_blk, i,\n\t\t\t\t\t\t\t    extra,\n\t\t\t\t\t\t\t    MS_EXTRA_SIZE);\n\t\t\t\t\tdev_dbg(rtsx_dev(chip), \"page %d : extra[0] = 0x%x\\n\",\n\t\t\t\t\t\ti, extra[0]);\n\t\t\t\t\tMS_SET_BAD_BLOCK_FLG(ms_card);\n\n\t\t\t\t\tms_set_page_status(log_blk,\n\t\t\t\t\t\t\t   set_PS_error, extra,\n\t\t\t\t\t\t\t   MS_EXTRA_SIZE);\n\t\t\t\t\tms_write_extra_data(chip, new_blk, i,\n\t\t\t\t\t\t\t    extra,\n\t\t\t\t\t\t\t    MS_EXTRA_SIZE);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (rty_cnt = 0; rty_cnt < MS_MAX_RETRY_COUNT;\n\t\t\t\t     rty_cnt++) {\n\t\t\t\t\tretval = ms_transfer_tpc(chip,\n\t\t\t\t\t\t\t\t MS_TM_NORMAL_WRITE,\n\t\t\t\t\t\t\t\t WRITE_PAGE_DATA,\n\t\t\t\t\t\t\t\t 0, NO_WAIT_INT);\n\t\t\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (rty_cnt == MS_MAX_RETRY_COUNT)\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\tif (!(val & INT_REG_BREQ)) {\n\t\t\t\tms_set_err_code(chip, MS_BREQ_ERROR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t}\n\n\t\tretval = ms_set_rw_reg_addr(chip, OVERWRITE_FLAG, MS_EXTRA_SIZE,\n\t\t\t\t\t    SYSTEM_PARAM, (6 + MS_EXTRA_SIZE));\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tms_set_err_code(chip, MS_NO_ERROR);\n\n\t\tif (CHK_MS4BIT(ms_card))\n\t\t\tdata[0] = 0x88;\n\t\telse\n\t\t\tdata[0] = 0x80;\n\n\t\tdata[1] = 0;\n\t\tdata[2] = (u8)(new_blk >> 8);\n\t\tdata[3] = (u8)new_blk;\n\t\tdata[4] = 0x20;\n\t\tdata[5] = i;\n\n\t\tif ((extra[0] & 0x60) != 0x60)\n\t\t\tdata[6] = extra[0];\n\t\telse\n\t\t\tdata[6] = 0xF8;\n\n\t\tdata[6 + 1] = 0xFF;\n\t\tdata[6 + 2] = (u8)(log_blk >> 8);\n\t\tdata[6 + 3] = (u8)log_blk;\n\n\t\tfor (j = 4; j <= MS_EXTRA_SIZE; j++)\n\t\t\tdata[6 + j] = 0xFF;\n\n\t\tretval = ms_write_bytes(chip, WRITE_REG, (6 + MS_EXTRA_SIZE),\n\t\t\t\t\tNO_WAIT_INT, data, 16);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = ms_send_cmd(chip, BLOCK_WRITE, WAIT_INT);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tms_set_err_code(chip, MS_NO_ERROR);\n\t\tretval = ms_read_bytes(chip, GET_INT, 1, NO_WAIT_INT, &val, 1);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tif (val & INT_REG_CMDNK) {\n\t\t\tms_set_err_code(chip, MS_CMD_NK);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tif (val & INT_REG_CED) {\n\t\t\tif (val & INT_REG_ERR) {\n\t\t\t\tms_set_err_code(chip, MS_FLASH_WRITE_ERROR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tretval = ms_set_rw_reg_addr(chip, OVERWRITE_FLAG,\n\t\t\t\t\t\t    MS_EXTRA_SIZE, SYSTEM_PARAM,\n\t\t\t\t\t\t    7);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\n\t\t\tms_set_err_code(chip, MS_NO_ERROR);\n\n\t\t\tif (CHK_MS4BIT(ms_card))\n\t\t\t\tdata[0] = 0x88;\n\t\t\telse\n\t\t\t\tdata[0] = 0x80;\n\n\t\t\tdata[1] = 0;\n\t\t\tdata[2] = (u8)(old_blk >> 8);\n\t\t\tdata[3] = (u8)old_blk;\n\t\t\tdata[4] = 0x80;\n\t\t\tdata[5] = 0;\n\t\t\tdata[6] = 0xEF;\n\t\t\tdata[7] = 0xFF;\n\n\t\t\tretval = ms_write_bytes(chip, WRITE_REG, 7,\n\t\t\t\t\t\tNO_WAIT_INT, data, 8);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\n\t\t\tretval = ms_send_cmd(chip, BLOCK_WRITE, WAIT_INT);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\n\t\t\tms_set_err_code(chip, MS_NO_ERROR);\n\t\t\tretval = ms_read_bytes(chip, GET_INT, 1,\n\t\t\t\t\t       NO_WAIT_INT, &val, 1);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\n\t\t\tif (val & INT_REG_CMDNK) {\n\t\t\t\tms_set_err_code(chip, MS_CMD_NK);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\tif (val & INT_REG_CED) {\n\t\t\t\tif (val & INT_REG_ERR) {\n\t\t\t\t\tms_set_err_code(chip,\n\t\t\t\t\t\t\tMS_FLASH_WRITE_ERROR);\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int reset_ms(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\tu16 i, reg_addr, block_size;\n\tu8 val, extra[MS_EXTRA_SIZE], j, *ptr;\n#ifndef SUPPORT_MAGIC_GATE\n\tu16 eblock_cnt;\n#endif\n\n\tretval = ms_prepare_reset(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tms_card->ms_type |= TYPE_MS;\n\n\tretval = ms_send_cmd(chip, MS_RESET, NO_WAIT_INT);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = ms_read_status_reg(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = rtsx_read_register(chip, PPBUF_BASE2, &val);\n\tif (retval)\n\t\treturn retval;\n\n\tif (val & WRT_PRTCT)\n\t\tchip->card_wp |= MS_CARD;\n\telse\n\t\tchip->card_wp &= ~MS_CARD;\n\n\ti = 0;\n\nRE_SEARCH:\n\t \n\twhile (i < (MAX_DEFECTIVE_BLOCK + 2)) {\n\t\tif (detect_card_cd(chip, MS_CARD) != STATUS_SUCCESS) {\n\t\t\tms_set_err_code(chip, MS_NO_CARD);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tretval = ms_read_extra_data(chip, i, 0, extra, MS_EXTRA_SIZE);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (extra[0] & BLOCK_OK) {\n\t\t\tif (!(extra[1] & NOT_BOOT_BLOCK)) {\n\t\t\t\tms_card->boot_block = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\n\tif (i == (MAX_DEFECTIVE_BLOCK + 2)) {\n\t\tdev_dbg(rtsx_dev(chip), \"No boot block found!\");\n\t\treturn STATUS_FAIL;\n\t}\n\n\tfor (j = 0; j < 3; j++) {\n\t\tretval = ms_read_page(chip, ms_card->boot_block, j);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tif (ms_check_err_code(chip, MS_FLASH_WRITE_ERROR)) {\n\t\t\t\ti = ms_card->boot_block + 1;\n\t\t\t\tms_set_err_code(chip, MS_NO_ERROR);\n\t\t\t\tgoto RE_SEARCH;\n\t\t\t}\n\t\t}\n\t}\n\n\tretval = ms_read_page(chip, ms_card->boot_block, 0);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\t \n\trtsx_init_cmd(chip);\n\n\tfor (i = 0; i < 96; i++)\n\t\trtsx_add_cmd(chip, READ_REG_CMD, PPBUF_BASE2 + 0x1A0 + i, 0, 0);\n\n\tretval = rtsx_send_cmd(chip, MS_CARD, 100);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\tptr = rtsx_get_cmd_data(chip);\n\tmemcpy(ms_card->raw_sys_info, ptr, 96);\n\n\t \n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, READ_REG_CMD, HEADER_ID0, 0, 0);\n\trtsx_add_cmd(chip, READ_REG_CMD, HEADER_ID1, 0, 0);\n\n\tfor (reg_addr = DISABLED_BLOCK0; reg_addr <= DISABLED_BLOCK3;\n\t     reg_addr++)\n\t\trtsx_add_cmd(chip, READ_REG_CMD, reg_addr, 0, 0);\n\n\tfor (reg_addr = BLOCK_SIZE_0; reg_addr <= PAGE_SIZE_1; reg_addr++)\n\t\trtsx_add_cmd(chip, READ_REG_CMD, reg_addr, 0, 0);\n\n\trtsx_add_cmd(chip, READ_REG_CMD, MS_device_type, 0, 0);\n\trtsx_add_cmd(chip, READ_REG_CMD, MS_4bit_support, 0, 0);\n\n\tretval = rtsx_send_cmd(chip, MS_CARD, 100);\n\tif (retval < 0)\n\t\treturn STATUS_FAIL;\n\n\tptr = rtsx_get_cmd_data(chip);\n\n\tdev_dbg(rtsx_dev(chip), \"Boot block data:\\n\");\n\tdev_dbg(rtsx_dev(chip), \"%*ph\\n\", 16, ptr);\n\n\t \n\tif (ptr[0] != 0x00 || ptr[1] != 0x01) {\n\t\ti = ms_card->boot_block + 1;\n\t\tgoto RE_SEARCH;\n\t}\n\n\t \n\tif (ptr[12] != 0x02 || ptr[13] != 0x00) {\n\t\ti = ms_card->boot_block + 1;\n\t\tgoto RE_SEARCH;\n\t}\n\n\tif (ptr[14] == 1 || ptr[14] == 3)\n\t\tchip->card_wp |= MS_CARD;\n\n\t \n\tblock_size = ((u16)ptr[6] << 8) | ptr[7];\n\tif (block_size == 0x0010) {\n\t\t \n\t\tms_card->block_shift = 5;\n\t\tms_card->page_off = 0x1F;\n\t} else if (block_size == 0x0008) {\n\t\t \n\t\tms_card->block_shift = 4;\n\t\tms_card->page_off = 0x0F;\n\t}\n\n\t \n\tms_card->total_block = ((u16)ptr[8] << 8) | ptr[9];\n\n#ifdef SUPPORT_MAGIC_GATE\n\tj = ptr[10];\n\n\tif (ms_card->block_shift == 4)  {  \n\t\tif (j < 2)  {  \n\t\t\tms_card->capacity = 0x1EE0;\n\t\t} else {  \n\t\t\tms_card->capacity = 0x3DE0;\n\t\t}\n\t} else  {  \n\t\tif (j < 5)  {  \n\t\t\tms_card->capacity = 0x7BC0;\n\t\t} else if (j < 0xA) {  \n\t\t\tms_card->capacity = 0xF7C0;\n\t\t} else if (j < 0x11) {  \n\t\t\tms_card->capacity = 0x1EF80;\n\t\t} else {  \n\t\t\tms_card->capacity = 0x3DF00;\n\t\t}\n\t}\n#else\n\t \n\teblock_cnt = ((u16)ptr[10] << 8) | ptr[11];\n\n\tms_card->capacity = ((u32)eblock_cnt - 2) << ms_card->block_shift;\n#endif\n\n\tchip->capacity[chip->card2lun[MS_CARD]] = ms_card->capacity;\n\n\t \n\tif (ptr[15]) {\n\t\tretval = ms_set_rw_reg_addr(chip, 0, 0, SYSTEM_PARAM, 1);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = rtsx_write_register(chip, PPBUF_BASE2, 0xFF, 0x88);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tretval = rtsx_write_register(chip, PPBUF_BASE2 + 1, 0xFF, 0);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tretval = ms_transfer_tpc(chip, MS_TM_WRITE_BYTES, WRITE_REG, 1,\n\t\t\t\t\t NO_WAIT_INT);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = rtsx_write_register(chip, MS_CFG,\n\t\t\t\t\t     0x58 | MS_NO_CHECK_INT,\n\t\t\t\t\t     MS_BUS_WIDTH_4 |\n\t\t\t\t\t     PUSH_TIME_ODD |\n\t\t\t\t\t     MS_NO_CHECK_INT);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tms_card->ms_type |= MS_4BIT;\n\t}\n\n\tif (CHK_MS4BIT(ms_card))\n\t\tchip->card_bus_width[chip->card2lun[MS_CARD]] = 4;\n\telse\n\t\tchip->card_bus_width[chip->card2lun[MS_CARD]] = 1;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_init_l2p_tbl(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint size, i, seg_no, retval;\n\tu16 defect_block, reg_addr;\n\tu8 val1, val2;\n\n\tms_card->segment_cnt = ms_card->total_block >> 9;\n\tdev_dbg(rtsx_dev(chip), \"ms_card->segment_cnt = %d\\n\",\n\t\tms_card->segment_cnt);\n\n\tsize = ms_card->segment_cnt * sizeof(struct zone_entry);\n\tms_card->segment = vzalloc(size);\n\tif (!ms_card->segment)\n\t\treturn STATUS_FAIL;\n\n\tretval = ms_read_page(chip, ms_card->boot_block, 1);\n\tif (retval != STATUS_SUCCESS)\n\t\tgoto INIT_FAIL;\n\n\treg_addr = PPBUF_BASE2;\n\tfor (i = 0; i < (((ms_card->total_block >> 9) * 10) + 1); i++) {\n\t\tint block_no;\n\n\t\tretval = rtsx_read_register(chip, reg_addr++, &val1);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\tgoto INIT_FAIL;\n\n\t\tretval = rtsx_read_register(chip, reg_addr++, &val2);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\tgoto INIT_FAIL;\n\n\t\tdefect_block = ((u16)val1 << 8) | val2;\n\t\tif (defect_block == 0xFFFF)\n\t\t\tbreak;\n\n\t\tseg_no = defect_block / 512;\n\n\t\tblock_no = ms_card->segment[seg_no].disable_count++;\n\t\tms_card->segment[seg_no].defect_list[block_no] = defect_block;\n\t}\n\n\tfor (i = 0; i < ms_card->segment_cnt; i++) {\n\t\tms_card->segment[i].build_flag = 0;\n\t\tms_card->segment[i].l2p_table = NULL;\n\t\tms_card->segment[i].free_table = NULL;\n\t\tms_card->segment[i].get_index = 0;\n\t\tms_card->segment[i].set_index = 0;\n\t\tms_card->segment[i].unused_blk_cnt = 0;\n\n\t\tdev_dbg(rtsx_dev(chip), \"defective block count of segment %d is %d\\n\",\n\t\t\ti, ms_card->segment[i].disable_count);\n\t}\n\n\treturn STATUS_SUCCESS;\n\nINIT_FAIL:\n\tvfree(ms_card->segment);\n\tms_card->segment = NULL;\n\n\treturn STATUS_FAIL;\n}\n\nstatic u16 ms_get_l2p_tbl(struct rtsx_chip *chip, int seg_no, u16 log_off)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tstruct zone_entry *segment;\n\n\tif (!ms_card->segment)\n\t\treturn 0xFFFF;\n\n\tsegment = &ms_card->segment[seg_no];\n\n\tif (segment->l2p_table)\n\t\treturn segment->l2p_table[log_off];\n\n\treturn 0xFFFF;\n}\n\nstatic void ms_set_l2p_tbl(struct rtsx_chip *chip,\n\t\t\t   int seg_no, u16 log_off, u16 phy_blk)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tstruct zone_entry *segment;\n\n\tif (!ms_card->segment)\n\t\treturn;\n\n\tsegment = &ms_card->segment[seg_no];\n\tif (segment->l2p_table)\n\t\tsegment->l2p_table[log_off] = phy_blk;\n}\n\nstatic void ms_set_unused_block(struct rtsx_chip *chip, u16 phy_blk)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tstruct zone_entry *segment;\n\tint seg_no;\n\n\tseg_no = (int)phy_blk >> 9;\n\tsegment = &ms_card->segment[seg_no];\n\n\tsegment->free_table[segment->set_index++] = phy_blk;\n\tif (segment->set_index >= MS_FREE_TABLE_CNT)\n\t\tsegment->set_index = 0;\n\n\tsegment->unused_blk_cnt++;\n}\n\nstatic u16 ms_get_unused_block(struct rtsx_chip *chip, int seg_no)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tstruct zone_entry *segment;\n\tu16 phy_blk;\n\n\tsegment = &ms_card->segment[seg_no];\n\n\tif (segment->unused_blk_cnt <= 0)\n\t\treturn 0xFFFF;\n\n\tphy_blk = segment->free_table[segment->get_index];\n\tsegment->free_table[segment->get_index++] = 0xFFFF;\n\tif (segment->get_index >= MS_FREE_TABLE_CNT)\n\t\tsegment->get_index = 0;\n\n\tsegment->unused_blk_cnt--;\n\n\treturn phy_blk;\n}\n\nstatic const unsigned short ms_start_idx[] = {0, 494, 990, 1486, 1982, 2478,\n\t\t\t\t\t      2974, 3470, 3966, 4462, 4958,\n\t\t\t\t\t      5454, 5950, 6446, 6942, 7438,\n\t\t\t\t\t      7934};\n\nstatic int ms_arbitrate_l2p(struct rtsx_chip *chip, u16 phy_blk,\n\t\t\t    u16 log_off, u8 us1, u8 us2)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tstruct zone_entry *segment;\n\tint seg_no;\n\tu16 tmp_blk;\n\n\tseg_no = (int)phy_blk >> 9;\n\tsegment = &ms_card->segment[seg_no];\n\ttmp_blk = segment->l2p_table[log_off];\n\n\tif (us1 != us2) {\n\t\tif (us1 == 0) {\n\t\t\tif (!(chip->card_wp & MS_CARD))\n\t\t\t\tms_erase_block(chip, tmp_blk);\n\n\t\t\tms_set_unused_block(chip, tmp_blk);\n\t\t\tsegment->l2p_table[log_off] = phy_blk;\n\t\t} else {\n\t\t\tif (!(chip->card_wp & MS_CARD))\n\t\t\t\tms_erase_block(chip, phy_blk);\n\n\t\t\tms_set_unused_block(chip, phy_blk);\n\t\t}\n\t} else {\n\t\tif (phy_blk < tmp_blk) {\n\t\t\tif (!(chip->card_wp & MS_CARD))\n\t\t\t\tms_erase_block(chip, phy_blk);\n\n\t\t\tms_set_unused_block(chip, phy_blk);\n\t\t} else {\n\t\t\tif (!(chip->card_wp & MS_CARD))\n\t\t\t\tms_erase_block(chip, tmp_blk);\n\n\t\t\tms_set_unused_block(chip, tmp_blk);\n\t\t\tsegment->l2p_table[log_off] = phy_blk;\n\t\t}\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_build_l2p_tbl(struct rtsx_chip *chip, int seg_no)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tstruct zone_entry *segment;\n\tbool defect_flag;\n\tint retval, table_size, disable_cnt, i;\n\tu16 start, end, phy_blk, log_blk, tmp_blk, idx;\n\tu8 extra[MS_EXTRA_SIZE], us1, us2;\n\n\tdev_dbg(rtsx_dev(chip), \"%s: %d\\n\", __func__, seg_no);\n\n\tif (!ms_card->segment) {\n\t\tretval = ms_init_l2p_tbl(chip);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn retval;\n\t}\n\n\tif (ms_card->segment[seg_no].build_flag) {\n\t\tdev_dbg(rtsx_dev(chip), \"l2p table of segment %d has been built\\n\",\n\t\t\tseg_no);\n\t\treturn STATUS_SUCCESS;\n\t}\n\n\tif (seg_no == 0)\n\t\ttable_size = 494;\n\telse\n\t\ttable_size = 496;\n\n\tsegment = &ms_card->segment[seg_no];\n\n\tif (!segment->l2p_table) {\n\t\tsegment->l2p_table = vmalloc(array_size(table_size, 2));\n\t\tif (!segment->l2p_table)\n\t\t\tgoto BUILD_FAIL;\n\t}\n\tmemset((u8 *)(segment->l2p_table), 0xff, array_size(table_size, 2));\n\n\tif (!segment->free_table) {\n\t\tsegment->free_table = vmalloc(array_size(MS_FREE_TABLE_CNT, 2));\n\t\tif (!segment->free_table)\n\t\t\tgoto BUILD_FAIL;\n\t}\n\tmemset((u8 *)(segment->free_table), 0xff, array_size(MS_FREE_TABLE_CNT, 2));\n\n\tstart = (u16)seg_no << 9;\n\tend = (u16)(seg_no + 1) << 9;\n\n\tdisable_cnt = segment->disable_count;\n\n\tsegment->get_index = 0;\n\tsegment->set_index = 0;\n\tsegment->unused_blk_cnt = 0;\n\n\tfor (phy_blk = start; phy_blk < end; phy_blk++) {\n\t\tif (disable_cnt) {\n\t\t\tdefect_flag = false;\n\t\t\tfor (i = 0; i < segment->disable_count; i++) {\n\t\t\t\tif (phy_blk == segment->defect_list[i]) {\n\t\t\t\t\tdefect_flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (defect_flag) {\n\t\t\t\tdisable_cnt--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tretval = ms_read_extra_data(chip, phy_blk, 0,\n\t\t\t\t\t    extra, MS_EXTRA_SIZE);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"read extra data fail\\n\");\n\t\t\tms_set_bad_block(chip, phy_blk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (seg_no == ms_card->segment_cnt - 1) {\n\t\t\tif (!(extra[1] & NOT_TRANSLATION_TABLE)) {\n\t\t\t\tif (!(chip->card_wp & MS_CARD)) {\n\t\t\t\t\tretval = ms_erase_block(chip, phy_blk);\n\t\t\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\textra[2] = 0xff;\n\t\t\t\t\textra[3] = 0xff;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!(extra[0] & BLOCK_OK))\n\t\t\tcontinue;\n\t\tif (!(extra[1] & NOT_BOOT_BLOCK))\n\t\t\tcontinue;\n\t\tif ((extra[0] & PAGE_OK) != PAGE_OK)\n\t\t\tcontinue;\n\n\t\tlog_blk = ((u16)extra[2] << 8) | extra[3];\n\n\t\tif (log_blk == 0xFFFF) {\n\t\t\tif (!(chip->card_wp & MS_CARD)) {\n\t\t\t\tretval = ms_erase_block(chip, phy_blk);\n\t\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tms_set_unused_block(chip, phy_blk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (log_blk < ms_start_idx[seg_no] ||\n\t\t    log_blk >= ms_start_idx[seg_no + 1]) {\n\t\t\tif (!(chip->card_wp & MS_CARD)) {\n\t\t\t\tretval = ms_erase_block(chip, phy_blk);\n\t\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tms_set_unused_block(chip, phy_blk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tidx = log_blk - ms_start_idx[seg_no];\n\n\t\tif (segment->l2p_table[idx] == 0xFFFF) {\n\t\t\tsegment->l2p_table[idx] = phy_blk;\n\t\t\tcontinue;\n\t\t}\n\n\t\tus1 = extra[0] & 0x10;\n\t\ttmp_blk = segment->l2p_table[idx];\n\t\tretval = ms_read_extra_data(chip, tmp_blk, 0,\n\t\t\t\t\t    extra, MS_EXTRA_SIZE);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\tcontinue;\n\t\tus2 = extra[0] & 0x10;\n\n\t\t(void)ms_arbitrate_l2p(chip, phy_blk,\n\t\t\t\tlog_blk - ms_start_idx[seg_no], us1, us2);\n\t}\n\n\tsegment->build_flag = 1;\n\n\tdev_dbg(rtsx_dev(chip), \"unused block count: %d\\n\",\n\t\tsegment->unused_blk_cnt);\n\n\t \n\tif (seg_no == ms_card->segment_cnt - 1) {\n\t\tif (segment->unused_blk_cnt < 2)\n\t\t\tchip->card_wp |= MS_CARD;\n\t} else {\n\t\tif (segment->unused_blk_cnt < 1)\n\t\t\tchip->card_wp |= MS_CARD;\n\t}\n\n\tif (chip->card_wp & MS_CARD)\n\t\treturn STATUS_SUCCESS;\n\n\tfor (log_blk = ms_start_idx[seg_no];\n\t     log_blk < ms_start_idx[seg_no + 1]; log_blk++) {\n\t\tidx = log_blk - ms_start_idx[seg_no];\n\t\tif (segment->l2p_table[idx] == 0xFFFF) {\n\t\t\tphy_blk = ms_get_unused_block(chip, seg_no);\n\t\t\tif (phy_blk == 0xFFFF) {\n\t\t\t\tchip->card_wp |= MS_CARD;\n\t\t\t\treturn STATUS_SUCCESS;\n\t\t\t}\n\t\t\tretval = ms_init_page(chip, phy_blk, log_blk, 0, 1);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\tgoto BUILD_FAIL;\n\n\t\t\tsegment->l2p_table[idx] = phy_blk;\n\t\t\tif (seg_no == ms_card->segment_cnt - 1) {\n\t\t\t\tif (segment->unused_blk_cnt < 2) {\n\t\t\t\t\tchip->card_wp |= MS_CARD;\n\t\t\t\t\treturn STATUS_SUCCESS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (segment->unused_blk_cnt < 1) {\n\t\t\t\t\tchip->card_wp |= MS_CARD;\n\t\t\t\t\treturn STATUS_SUCCESS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (seg_no == 0) {\n\t\tfor (log_blk = 0; log_blk < 494; log_blk++) {\n\t\t\ttmp_blk = segment->l2p_table[log_blk];\n\t\t\tif (tmp_blk < ms_card->boot_block) {\n\t\t\t\tdev_dbg(rtsx_dev(chip), \"Boot block is not the first normal block.\\n\");\n\n\t\t\t\tif (chip->card_wp & MS_CARD)\n\t\t\t\t\tbreak;\n\n\t\t\t\tphy_blk = ms_get_unused_block(chip, 0);\n\t\t\t\tretval = ms_copy_page(chip, tmp_blk, phy_blk,\n\t\t\t\t\t\t      log_blk, 0,\n\t\t\t\t\t\t      ms_card->page_off + 1);\n\t\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\t\treturn STATUS_FAIL;\n\n\t\t\t\tsegment->l2p_table[log_blk] = phy_blk;\n\n\t\t\t\tretval = ms_set_bad_block(chip, tmp_blk);\n\t\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn STATUS_SUCCESS;\n\nBUILD_FAIL:\n\tsegment->build_flag = 0;\n\tvfree(segment->l2p_table);\n\tsegment->l2p_table = NULL;\n\tvfree(segment->free_table);\n\tsegment->free_table = NULL;\n\n\treturn STATUS_FAIL;\n}\n\nint reset_ms_card(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint seg_no = ms_card->total_block / 512 - 1;\n\tint retval;\n\n\tmemset(ms_card, 0, sizeof(struct ms_info));\n\n\tretval = enable_card_clock(chip, MS_CARD);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = select_card(chip, MS_CARD);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tms_card->ms_type = 0;\n\n\tretval = reset_ms_pro(chip);\n\tif (retval != STATUS_SUCCESS) {\n\t\tif (ms_card->check_ms_flow) {\n\t\t\tretval = reset_ms(chip);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\t\t} else {\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\tretval = ms_set_init_para(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (!CHK_MSPRO(ms_card)) {\n\t\t \n\t\tretval = ms_build_l2p_tbl(chip, seg_no);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\tdev_dbg(rtsx_dev(chip), \"ms_card->ms_type = 0x%x\\n\", ms_card->ms_type);\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int mspro_set_rw_cmd(struct rtsx_chip *chip,\n\t\t\t    u32 start_sec, u16 sec_cnt, u8 cmd)\n{\n\tint retval, i;\n\tu8 data[8];\n\n\tdata[0] = cmd;\n\tdata[1] = (u8)(sec_cnt >> 8);\n\tdata[2] = (u8)sec_cnt;\n\tdata[3] = (u8)(start_sec >> 24);\n\tdata[4] = (u8)(start_sec >> 16);\n\tdata[5] = (u8)(start_sec >> 8);\n\tdata[6] = (u8)start_sec;\n\tdata[7] = 0;\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_write_bytes(chip, PRO_EX_SET_CMD, 7,\n\t\t\t\t\tWAIT_INT, data, 8);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (i == MS_MAX_RETRY_COUNT)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nvoid mspro_stop_seq_mode(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\n\tif (ms_card->seq_mode) {\n\t\tretval = ms_switch_clock(chip);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn;\n\n\t\tms_card->seq_mode = 0;\n\t\tms_card->total_sec_cnt = 0;\n\t\tms_send_cmd(chip, PRO_STOP, WAIT_INT);\n\n\t\trtsx_write_register(chip, RBCTL, RB_FLUSH, RB_FLUSH);\n\t}\n}\n\nstatic inline int ms_auto_tune_clock(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\n\tif (chip->asic_code) {\n\t\tif (ms_card->ms_clock > 30)\n\t\t\tms_card->ms_clock -= 20;\n\t} else {\n\t\tif (ms_card->ms_clock == CLK_80)\n\t\t\tms_card->ms_clock = CLK_60;\n\t\telse if (ms_card->ms_clock == CLK_60)\n\t\t\tms_card->ms_clock = CLK_40;\n\t}\n\n\tretval = ms_switch_clock(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int mspro_rw_multi_sector(struct scsi_cmnd *srb,\n\t\t\t\t struct rtsx_chip *chip, u32 start_sector,\n\t\t\t\t u16 sector_cnt)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tbool mode_2k = false;\n\tint retval;\n\tu16 count;\n\tu8 val, trans_mode, rw_tpc, rw_cmd;\n\n\tms_set_err_code(chip, MS_NO_ERROR);\n\n\tms_card->cleanup_counter = 0;\n\n\tif (CHK_MSHG(ms_card)) {\n\t\tif ((start_sector % 4) || (sector_cnt % 4)) {\n\t\t\tif (srb->sc_data_direction == DMA_FROM_DEVICE) {\n\t\t\t\trw_tpc = PRO_READ_LONG_DATA;\n\t\t\t\trw_cmd = PRO_READ_DATA;\n\t\t\t} else {\n\t\t\t\trw_tpc = PRO_WRITE_LONG_DATA;\n\t\t\t\trw_cmd = PRO_WRITE_DATA;\n\t\t\t}\n\t\t} else {\n\t\t\tif (srb->sc_data_direction == DMA_FROM_DEVICE) {\n\t\t\t\trw_tpc = PRO_READ_QUAD_DATA;\n\t\t\t\trw_cmd = PRO_READ_2K_DATA;\n\t\t\t} else {\n\t\t\t\trw_tpc = PRO_WRITE_QUAD_DATA;\n\t\t\t\trw_cmd = PRO_WRITE_2K_DATA;\n\t\t\t}\n\t\t\tmode_2k = true;\n\t\t}\n\t} else {\n\t\tif (srb->sc_data_direction == DMA_FROM_DEVICE) {\n\t\t\trw_tpc = PRO_READ_LONG_DATA;\n\t\t\trw_cmd = PRO_READ_DATA;\n\t\t} else {\n\t\t\trw_tpc = PRO_WRITE_LONG_DATA;\n\t\t\trw_cmd = PRO_WRITE_DATA;\n\t\t}\n\t}\n\n\tretval = ms_switch_clock(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (srb->sc_data_direction == DMA_FROM_DEVICE)\n\t\ttrans_mode = MS_TM_AUTO_READ;\n\telse\n\t\ttrans_mode = MS_TM_AUTO_WRITE;\n\n\tretval = rtsx_read_register(chip, MS_TRANS_CFG, &val);\n\tif (retval)\n\t\treturn retval;\n\n\tif (ms_card->seq_mode) {\n\t\tif (ms_card->pre_dir != srb->sc_data_direction ||\n\t\t    ((ms_card->pre_sec_addr + ms_card->pre_sec_cnt) !=\n\t\t     start_sector) ||\n\t\t    (mode_2k && (ms_card->seq_mode & MODE_512_SEQ)) ||\n\t\t    (!mode_2k && (ms_card->seq_mode & MODE_2K_SEQ)) ||\n\t\t    !(val & MS_INT_BREQ) ||\n\t\t    ((ms_card->total_sec_cnt + sector_cnt) > 0xFE00)) {\n\t\t\tms_card->seq_mode = 0;\n\t\t\tms_card->total_sec_cnt = 0;\n\t\t\tif (val & MS_INT_BREQ) {\n\t\t\t\tretval = ms_send_cmd(chip, PRO_STOP, WAIT_INT);\n\t\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\t\treturn STATUS_FAIL;\n\n\t\t\t\trtsx_write_register(chip, RBCTL, RB_FLUSH,\n\t\t\t\t\t\t    RB_FLUSH);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ms_card->seq_mode) {\n\t\tms_card->total_sec_cnt = 0;\n\t\tif (sector_cnt >= SEQ_START_CRITERIA) {\n\t\t\tif ((ms_card->capacity - start_sector) > 0xFE00)\n\t\t\t\tcount = 0xFE00;\n\t\t\telse\n\t\t\t\tcount = (u16)(ms_card->capacity - start_sector);\n\n\t\t\tif (count > sector_cnt) {\n\t\t\t\tif (mode_2k)\n\t\t\t\t\tms_card->seq_mode = MODE_2K_SEQ;\n\t\t\t\telse\n\t\t\t\t\tms_card->seq_mode = MODE_512_SEQ;\n\t\t\t}\n\t\t} else {\n\t\t\tcount = sector_cnt;\n\t\t}\n\t\tretval = mspro_set_rw_cmd(chip, start_sector, count, rw_cmd);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tms_card->seq_mode = 0;\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\tretval = ms_transfer_data(chip, trans_mode, rw_tpc, sector_cnt,\n\t\t\t\t  WAIT_INT, mode_2k, scsi_sg_count(srb),\n\t\t\t\t  scsi_sglist(srb), scsi_bufflen(srb));\n\tif (retval != STATUS_SUCCESS) {\n\t\tms_card->seq_mode = 0;\n\t\trtsx_read_register(chip, MS_TRANS_CFG, &val);\n\t\trtsx_clear_ms_error(chip);\n\n\t\tif (detect_card_cd(chip, MS_CARD) != STATUS_SUCCESS) {\n\t\t\tchip->rw_need_retry = 0;\n\t\t\tdev_dbg(rtsx_dev(chip), \"No card exist, exit %s\\n\",\n\t\t\t\t__func__);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tif (val & MS_INT_BREQ)\n\t\t\tms_send_cmd(chip, PRO_STOP, WAIT_INT);\n\n\t\tif (val & (MS_CRC16_ERR | MS_RDY_TIMEOUT)) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"MSPro CRC error, tune clock!\\n\");\n\t\t\tchip->rw_need_retry = 1;\n\t\t\tms_auto_tune_clock(chip);\n\t\t}\n\n\t\treturn retval;\n\t}\n\n\tif (ms_card->seq_mode) {\n\t\tms_card->pre_sec_addr = start_sector;\n\t\tms_card->pre_sec_cnt = sector_cnt;\n\t\tms_card->pre_dir = srb->sc_data_direction;\n\t\tms_card->total_sec_cnt += sector_cnt;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int mspro_read_format_progress(struct rtsx_chip *chip,\n\t\t\t\t      const int short_data_len)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, i;\n\tu32 total_progress, cur_progress;\n\tu8 cnt, tmp;\n\tu8 data[8];\n\n\tdev_dbg(rtsx_dev(chip), \"%s, short_data_len = %d\\n\", __func__,\n\t\tshort_data_len);\n\n\tretval = ms_switch_clock(chip);\n\tif (retval != STATUS_SUCCESS) {\n\t\tms_card->format_status = FORMAT_FAIL;\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = rtsx_read_register(chip, MS_TRANS_CFG, &tmp);\n\tif (retval != STATUS_SUCCESS) {\n\t\tms_card->format_status = FORMAT_FAIL;\n\t\treturn STATUS_FAIL;\n\t}\n\n\tif (!(tmp & MS_INT_BREQ)) {\n\t\tif ((tmp & (MS_INT_CED | MS_INT_BREQ | MS_INT_CMDNK |\n\t\t\t    MS_INT_ERR)) == MS_INT_CED) {\n\t\t\tms_card->format_status = FORMAT_SUCCESS;\n\t\t\treturn STATUS_SUCCESS;\n\t\t}\n\t\tms_card->format_status = FORMAT_FAIL;\n\t\treturn STATUS_FAIL;\n\t}\n\n\tif (short_data_len >= 256)\n\t\tcnt = 0;\n\telse\n\t\tcnt = (u8)short_data_len;\n\n\tretval = rtsx_write_register(chip, MS_CFG, MS_NO_CHECK_INT,\n\t\t\t\t     MS_NO_CHECK_INT);\n\tif (retval != STATUS_SUCCESS) {\n\t\tms_card->format_status = FORMAT_FAIL;\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = ms_read_bytes(chip, PRO_READ_SHORT_DATA, cnt, WAIT_INT,\n\t\t\t       data, 8);\n\tif (retval != STATUS_SUCCESS) {\n\t\tms_card->format_status = FORMAT_FAIL;\n\t\treturn STATUS_FAIL;\n\t}\n\n\ttotal_progress = (data[0] << 24) | (data[1] << 16) |\n\t\t(data[2] << 8) | data[3];\n\tcur_progress = (data[4] << 24) | (data[5] << 16) |\n\t\t(data[6] << 8) | data[7];\n\n\tdev_dbg(rtsx_dev(chip), \"total_progress = %d, cur_progress = %d\\n\",\n\t\ttotal_progress, cur_progress);\n\n\tif (total_progress == 0) {\n\t\tms_card->progress = 0;\n\t} else {\n\t\tu64 ulltmp = (u64)cur_progress * (u64)65535;\n\n\t\tdo_div(ulltmp, total_progress);\n\t\tms_card->progress = (u16)ulltmp;\n\t}\n\tdev_dbg(rtsx_dev(chip), \"progress = %d\\n\", ms_card->progress);\n\n\tfor (i = 0; i < 5000; i++) {\n\t\tretval = rtsx_read_register(chip, MS_TRANS_CFG, &tmp);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tms_card->format_status = FORMAT_FAIL;\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t\tif (tmp & (MS_INT_CED | MS_INT_CMDNK |\n\t\t\t\tMS_INT_BREQ | MS_INT_ERR))\n\t\t\tbreak;\n\n\t\twait_timeout(1);\n\t}\n\n\tretval = rtsx_write_register(chip, MS_CFG, MS_NO_CHECK_INT, 0);\n\tif (retval != STATUS_SUCCESS) {\n\t\tms_card->format_status = FORMAT_FAIL;\n\t\treturn STATUS_FAIL;\n\t}\n\n\tif (i == 5000) {\n\t\tms_card->format_status = FORMAT_FAIL;\n\t\treturn STATUS_FAIL;\n\t}\n\n\tif (tmp & (MS_INT_CMDNK | MS_INT_ERR)) {\n\t\tms_card->format_status = FORMAT_FAIL;\n\t\treturn STATUS_FAIL;\n\t}\n\n\tif (tmp & MS_INT_CED) {\n\t\tms_card->format_status = FORMAT_SUCCESS;\n\t\tms_card->pro_under_formatting = 0;\n\t} else if (tmp & MS_INT_BREQ) {\n\t\tms_card->format_status = FORMAT_IN_PROGRESS;\n\t} else {\n\t\tms_card->format_status = FORMAT_FAIL;\n\t\tms_card->pro_under_formatting = 0;\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nvoid mspro_polling_format_status(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint i;\n\n\tif (ms_card->pro_under_formatting &&\n\t    (rtsx_get_stat(chip) != RTSX_STAT_SS)) {\n\t\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\t\tfor (i = 0; i < 65535; i++) {\n\t\t\tmspro_read_format_progress(chip, MS_SHORT_DATA_LEN);\n\t\t\tif (ms_card->format_status != FORMAT_IN_PROGRESS)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint mspro_format(struct scsi_cmnd *srb, struct rtsx_chip *chip,\n\t\t int short_data_len, bool quick_format)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, i;\n\tu8 buf[8], tmp;\n\tu16 para;\n\n\tretval = ms_switch_clock(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = ms_set_rw_reg_addr(chip, 0x00, 0x00, PRO_TPC_PARM, 0x01);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tmemset(buf, 0, 2);\n\tswitch (short_data_len) {\n\tcase 32:\n\t\tbuf[0] = 0;\n\t\tbreak;\n\tcase 64:\n\t\tbuf[0] = 1;\n\t\tbreak;\n\tcase 128:\n\t\tbuf[0] = 2;\n\t\tbreak;\n\tcase 256:\n\tdefault:\n\t\tbuf[0] = 3;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_write_bytes(chip, PRO_WRITE_REG, 1,\n\t\t\t\t\tNO_WAIT_INT, buf, 2);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (i == MS_MAX_RETRY_COUNT)\n\t\treturn STATUS_FAIL;\n\n\tif (quick_format)\n\t\tpara = 0x0000;\n\telse\n\t\tpara = 0x0001;\n\n\tretval = mspro_set_rw_cmd(chip, 0, para, PRO_FORMAT);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = rtsx_read_register(chip, MS_TRANS_CFG, &tmp);\n\tif (retval)\n\t\treturn retval;\n\n\tif (tmp & (MS_INT_CMDNK | MS_INT_ERR))\n\t\treturn STATUS_FAIL;\n\n\tif ((tmp & (MS_INT_BREQ | MS_INT_CED)) == MS_INT_BREQ) {\n\t\tms_card->pro_under_formatting = 1;\n\t\tms_card->progress = 0;\n\t\tms_card->format_status = FORMAT_IN_PROGRESS;\n\t\treturn STATUS_SUCCESS;\n\t}\n\n\tif (tmp & MS_INT_CED) {\n\t\tms_card->pro_under_formatting = 0;\n\t\tms_card->progress = 0;\n\t\tms_card->format_status = FORMAT_SUCCESS;\n\t\tset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_NO_SENSE);\n\t\treturn STATUS_SUCCESS;\n\t}\n\n\treturn STATUS_FAIL;\n}\n\nstatic int ms_read_multiple_pages(struct rtsx_chip *chip, u16 phy_blk,\n\t\t\t\t  u16 log_blk, u8 start_page, u8 end_page,\n\t\t\t\t  u8 *buf, unsigned int *index,\n\t\t\t\t  unsigned int *offset)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, i;\n\tu8 extra[MS_EXTRA_SIZE], page_addr, val, trans_cfg, data[6];\n\tu8 *ptr;\n\n\tretval = ms_read_extra_data(chip, phy_blk, start_page,\n\t\t\t\t    extra, MS_EXTRA_SIZE);\n\tif (retval == STATUS_SUCCESS) {\n\t\tif ((extra[1] & 0x30) != 0x30) {\n\t\t\tms_set_err_code(chip, MS_FLASH_READ_ERROR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\tretval = ms_set_rw_reg_addr(chip, OVERWRITE_FLAG, MS_EXTRA_SIZE,\n\t\t\t\t    SYSTEM_PARAM, 6);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (CHK_MS4BIT(ms_card))\n\t\tdata[0] = 0x88;\n\telse\n\t\tdata[0] = 0x80;\n\n\tdata[1] = 0;\n\tdata[2] = (u8)(phy_blk >> 8);\n\tdata[3] = (u8)phy_blk;\n\tdata[4] = 0;\n\tdata[5] = start_page;\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_write_bytes(chip, WRITE_REG, 6, NO_WAIT_INT,\n\t\t\t\t\tdata, 6);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (i == MS_MAX_RETRY_COUNT)\n\t\treturn STATUS_FAIL;\n\n\tms_set_err_code(chip, MS_NO_ERROR);\n\n\tretval = ms_send_cmd(chip, BLOCK_READ, WAIT_INT);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tptr = buf;\n\n\tfor (page_addr = start_page; page_addr < end_page; page_addr++) {\n\t\tms_set_err_code(chip, MS_NO_ERROR);\n\n\t\tif (detect_card_cd(chip, MS_CARD) != STATUS_SUCCESS) {\n\t\t\tms_set_err_code(chip, MS_NO_CARD);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tretval = ms_read_bytes(chip, GET_INT, 1, NO_WAIT_INT, &val, 1);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tif (val & INT_REG_CMDNK) {\n\t\t\tms_set_err_code(chip, MS_CMD_NK);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t\tif (val & INT_REG_ERR) {\n\t\t\tif (val & INT_REG_BREQ) {\n\t\t\t\tretval = ms_read_status_reg(chip);\n\t\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\t\tif (!(chip->card_wp & MS_CARD)) {\n\t\t\t\t\t\treset_ms(chip);\n\t\t\t\t\t\tms_set_page_status\n\t\t\t\t\t\t\t(log_blk, set_PS_NG,\n\t\t\t\t\t\t\t extra,\n\t\t\t\t\t\t\t MS_EXTRA_SIZE);\n\t\t\t\t\t\tms_write_extra_data\n\t\t\t\t\t\t\t(chip, phy_blk,\n\t\t\t\t\t\t\t page_addr, extra,\n\t\t\t\t\t\t\t MS_EXTRA_SIZE);\n\t\t\t\t\t}\n\t\t\t\t\tms_set_err_code(chip,\n\t\t\t\t\t\t\tMS_FLASH_READ_ERROR);\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tms_set_err_code(chip, MS_FLASH_READ_ERROR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(val & INT_REG_BREQ)) {\n\t\t\t\tms_set_err_code(chip, MS_BREQ_ERROR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t}\n\n\t\tif (page_addr == (end_page - 1)) {\n\t\t\tif (!(val & INT_REG_CED)) {\n\t\t\t\tretval = ms_send_cmd(chip, BLOCK_END, WAIT_INT);\n\t\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\tretval = ms_read_bytes(chip, GET_INT, 1, NO_WAIT_INT,\n\t\t\t\t\t       &val, 1);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn STATUS_FAIL;\n\n\t\t\tif (!(val & INT_REG_CED)) {\n\t\t\t\tms_set_err_code(chip, MS_FLASH_READ_ERROR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\ttrans_cfg = NO_WAIT_INT;\n\t\t} else {\n\t\t\ttrans_cfg = WAIT_INT;\n\t\t}\n\n\t\trtsx_init_cmd(chip);\n\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TPC, 0xFF, READ_PAGE_DATA);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TRANS_CFG,\n\t\t\t     0xFF, trans_cfg);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t     0x01, RING_BUFFER);\n\n\t\ttrans_dma_enable(DMA_FROM_DEVICE, chip, 512, DMA_512);\n\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TRANSFER, 0xFF,\n\t\t\t     MS_TRANSFER_START |  MS_TM_NORMAL_READ);\n\t\trtsx_add_cmd(chip, CHECK_REG_CMD, MS_TRANSFER,\n\t\t\t     MS_TRANSFER_END, MS_TRANSFER_END);\n\n\t\trtsx_send_cmd_no_wait(chip);\n\n\t\tretval = rtsx_transfer_data_partial(chip, MS_CARD, ptr, 512,\n\t\t\t\t\t\t    scsi_sg_count(chip->srb),\n\t\t\t\t\t\t    index, offset,\n\t\t\t\t\t\t    DMA_FROM_DEVICE,\n\t\t\t\t\t\t    chip->ms_timeout);\n\t\tif (retval < 0) {\n\t\t\tif (retval == -ETIMEDOUT) {\n\t\t\t\tms_set_err_code(chip, MS_TO_ERROR);\n\t\t\t\trtsx_clear_ms_error(chip);\n\t\t\t\treturn STATUS_TIMEDOUT;\n\t\t\t}\n\n\t\t\tretval = rtsx_read_register(chip, MS_TRANS_CFG, &val);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tms_set_err_code(chip, MS_TO_ERROR);\n\t\t\t\trtsx_clear_ms_error(chip);\n\t\t\t\treturn STATUS_TIMEDOUT;\n\t\t\t}\n\t\t\tif (val & (MS_CRC16_ERR | MS_RDY_TIMEOUT)) {\n\t\t\t\tms_set_err_code(chip, MS_CRC16_ERROR);\n\t\t\t\trtsx_clear_ms_error(chip);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t}\n\n\t\tif (scsi_sg_count(chip->srb) == 0)\n\t\t\tptr += 512;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_write_multiple_pages(struct rtsx_chip *chip, u16 old_blk,\n\t\t\t\t   u16 new_blk, u16 log_blk, u8 start_page,\n\t\t\t\tu8 end_page, u8 *buf, unsigned int *index,\n\t\t\t\tunsigned int *offset)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, i;\n\tu8 page_addr, val, data[16];\n\tu8 *ptr;\n\n\tif (!start_page) {\n\t\tretval = ms_set_rw_reg_addr(chip, OVERWRITE_FLAG, MS_EXTRA_SIZE,\n\t\t\t\t\t    SYSTEM_PARAM, 7);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tif (CHK_MS4BIT(ms_card))\n\t\t\tdata[0] = 0x88;\n\t\telse\n\t\t\tdata[0] = 0x80;\n\n\t\tdata[1] = 0;\n\t\tdata[2] = (u8)(old_blk >> 8);\n\t\tdata[3] = (u8)old_blk;\n\t\tdata[4] = 0x80;\n\t\tdata[5] = 0;\n\t\tdata[6] = 0xEF;\n\t\tdata[7] = 0xFF;\n\n\t\tretval = ms_write_bytes(chip, WRITE_REG, 7, NO_WAIT_INT,\n\t\t\t\t\tdata, 8);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tretval = ms_send_cmd(chip, BLOCK_WRITE, WAIT_INT);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tms_set_err_code(chip, MS_NO_ERROR);\n\t\tretval = ms_transfer_tpc(chip, MS_TM_READ_BYTES, GET_INT, 1,\n\t\t\t\t\t NO_WAIT_INT);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = ms_set_rw_reg_addr(chip, OVERWRITE_FLAG, MS_EXTRA_SIZE,\n\t\t\t\t    SYSTEM_PARAM, (6 + MS_EXTRA_SIZE));\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tms_set_err_code(chip, MS_NO_ERROR);\n\n\tif (CHK_MS4BIT(ms_card))\n\t\tdata[0] = 0x88;\n\telse\n\t\tdata[0] = 0x80;\n\n\tdata[1] = 0;\n\tdata[2] = (u8)(new_blk >> 8);\n\tdata[3] = (u8)new_blk;\n\tif ((end_page - start_page) == 1)\n\t\tdata[4] = 0x20;\n\telse\n\t\tdata[4] = 0;\n\n\tdata[5] = start_page;\n\tdata[6] = 0xF8;\n\tdata[7] = 0xFF;\n\tdata[8] = (u8)(log_blk >> 8);\n\tdata[9] = (u8)log_blk;\n\n\tfor (i = 0x0A; i < 0x10; i++)\n\t\tdata[i] = 0xFF;\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_write_bytes(chip, WRITE_REG, 6 + MS_EXTRA_SIZE,\n\t\t\t\t\tNO_WAIT_INT, data, 16);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (i == MS_MAX_RETRY_COUNT)\n\t\treturn STATUS_FAIL;\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_send_cmd(chip, BLOCK_WRITE, WAIT_INT);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (i == MS_MAX_RETRY_COUNT)\n\t\treturn STATUS_FAIL;\n\n\tretval = ms_read_bytes(chip, GET_INT, 1, NO_WAIT_INT, &val, 1);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tptr = buf;\n\tfor (page_addr = start_page; page_addr < end_page; page_addr++) {\n\t\tms_set_err_code(chip, MS_NO_ERROR);\n\n\t\tif (detect_card_cd(chip, MS_CARD) != STATUS_SUCCESS) {\n\t\t\tms_set_err_code(chip, MS_NO_CARD);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tif (val & INT_REG_CMDNK) {\n\t\t\tms_set_err_code(chip, MS_CMD_NK);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t\tif (val & INT_REG_ERR) {\n\t\t\tms_set_err_code(chip, MS_FLASH_WRITE_ERROR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t\tif (!(val & INT_REG_BREQ)) {\n\t\t\tms_set_err_code(chip, MS_BREQ_ERROR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tudelay(30);\n\n\t\trtsx_init_cmd(chip);\n\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TPC,\n\t\t\t     0xFF, WRITE_PAGE_DATA);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TRANS_CFG,\n\t\t\t     0xFF, WAIT_INT);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t     0x01, RING_BUFFER);\n\n\t\ttrans_dma_enable(DMA_TO_DEVICE, chip, 512, DMA_512);\n\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TRANSFER, 0xFF,\n\t\t\t     MS_TRANSFER_START |  MS_TM_NORMAL_WRITE);\n\t\trtsx_add_cmd(chip, CHECK_REG_CMD, MS_TRANSFER,\n\t\t\t     MS_TRANSFER_END, MS_TRANSFER_END);\n\n\t\trtsx_send_cmd_no_wait(chip);\n\n\t\tretval = rtsx_transfer_data_partial(chip, MS_CARD, ptr,\t512,\n\t\t\t\t\t\t    scsi_sg_count(chip->srb),\n\t\t\t\t\t\t    index, offset,\n\t\t\t\t\t\t    DMA_TO_DEVICE,\n\t\t\t\t\t\t    chip->ms_timeout);\n\t\tif (retval < 0) {\n\t\t\tms_set_err_code(chip, MS_TO_ERROR);\n\t\t\trtsx_clear_ms_error(chip);\n\n\t\t\tif (retval == -ETIMEDOUT)\n\t\t\t\treturn STATUS_TIMEDOUT;\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tretval = ms_read_bytes(chip, GET_INT, 1, NO_WAIT_INT, &val, 1);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tif ((end_page - start_page) == 1) {\n\t\t\tif (!(val & INT_REG_CED)) {\n\t\t\t\tms_set_err_code(chip, MS_FLASH_WRITE_ERROR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (page_addr == (end_page - 1)) {\n\t\t\t\tif (!(val & INT_REG_CED)) {\n\t\t\t\t\tretval = ms_send_cmd(chip, BLOCK_END,\n\t\t\t\t\t\t\t     WAIT_INT);\n\t\t\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t\t}\n\n\t\t\t\tretval = ms_read_bytes(chip, GET_INT, 1,\n\t\t\t\t\t\t       NO_WAIT_INT, &val, 1);\n\t\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\tif (page_addr == (end_page - 1) ||\n\t\t\t    page_addr == ms_card->page_off) {\n\t\t\t\tif (!(val & INT_REG_CED)) {\n\t\t\t\t\tms_set_err_code(chip,\n\t\t\t\t\t\t\tMS_FLASH_WRITE_ERROR);\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (scsi_sg_count(chip->srb) == 0)\n\t\t\tptr += 512;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_finish_write(struct rtsx_chip *chip, u16 old_blk, u16 new_blk,\n\t\t\t   u16 log_blk, u8 page_off)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval, seg_no;\n\n\tretval = ms_copy_page(chip, old_blk, new_blk, log_blk,\n\t\t\t      page_off, ms_card->page_off + 1);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tseg_no = old_blk >> 9;\n\n\tif (MS_TST_BAD_BLOCK_FLG(ms_card)) {\n\t\tMS_CLR_BAD_BLOCK_FLG(ms_card);\n\t\tms_set_bad_block(chip, old_blk);\n\t} else {\n\t\tretval = ms_erase_block(chip, old_blk);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tms_set_unused_block(chip, old_blk);\n\t}\n\n\tms_set_l2p_tbl(chip, seg_no, log_blk - ms_start_idx[seg_no], new_blk);\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int ms_prepare_write(struct rtsx_chip *chip, u16 old_blk, u16 new_blk,\n\t\t\t    u16 log_blk, u8 start_page)\n{\n\tint retval;\n\n\tif (start_page) {\n\t\tretval = ms_copy_page(chip, old_blk, new_blk, log_blk,\n\t\t\t\t      0, start_page);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\n#ifdef MS_DELAY_WRITE\nint ms_delay_write(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tstruct ms_delay_write_tag *delay_write = &ms_card->delay_write;\n\tint retval;\n\n\tif (delay_write->delay_write_flag) {\n\t\tretval = ms_set_init_para(chip);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\n\t\tdelay_write->delay_write_flag = 0;\n\t\tretval = ms_finish_write(chip,\n\t\t\t\t\t delay_write->old_phyblock,\n\t\t\t\t\tdelay_write->new_phyblock,\n\t\t\t\t\tdelay_write->logblock,\n\t\t\t\t\tdelay_write->pageoff);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n#endif\n\nstatic inline void ms_rw_fail(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tif (srb->sc_data_direction == DMA_FROM_DEVICE)\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\telse\n\t\tset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_MEDIA_WRITE_ERR);\n}\n\nstatic int ms_rw_multi_sector(struct scsi_cmnd *srb, struct rtsx_chip *chip,\n\t\t\t      u32 start_sector, u16 sector_cnt)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tunsigned int lun = SCSI_LUN(srb);\n\tint retval, seg_no;\n\tunsigned int index = 0, offset = 0;\n\tu16 old_blk = 0, new_blk = 0, log_blk, total_sec_cnt = sector_cnt;\n\tu8 start_page, end_page = 0, page_cnt;\n\tu8 *ptr;\n#ifdef MS_DELAY_WRITE\n\tstruct ms_delay_write_tag *delay_write = &ms_card->delay_write;\n#endif\n\n\tms_set_err_code(chip, MS_NO_ERROR);\n\n\tms_card->cleanup_counter = 0;\n\n\tptr = (u8 *)scsi_sglist(srb);\n\n\tretval = ms_switch_clock(chip);\n\tif (retval != STATUS_SUCCESS) {\n\t\tms_rw_fail(srb, chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tlog_blk = (u16)(start_sector >> ms_card->block_shift);\n\tstart_page = (u8)(start_sector & ms_card->page_off);\n\n\tfor (seg_no = 0; seg_no < ARRAY_SIZE(ms_start_idx) - 1; seg_no++) {\n\t\tif (log_blk < ms_start_idx[seg_no + 1])\n\t\t\tbreak;\n\t}\n\n\tif (ms_card->segment[seg_no].build_flag == 0) {\n\t\tretval = ms_build_l2p_tbl(chip, seg_no);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tchip->card_fail |= MS_CARD;\n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\tif (srb->sc_data_direction == DMA_TO_DEVICE) {\n#ifdef MS_DELAY_WRITE\n\t\tif (delay_write->delay_write_flag &&\n\t\t    delay_write->logblock == log_blk &&\n\t\t    start_page > delay_write->pageoff) {\n\t\t\tdelay_write->delay_write_flag = 0;\n\t\t\tretval = ms_copy_page(chip,\n\t\t\t\t\t      delay_write->old_phyblock,\n\t\t\t\t\t      delay_write->new_phyblock,\n\t\t\t\t\t      log_blk,\n\t\t\t\t\t      delay_write->pageoff, start_page);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t\told_blk = delay_write->old_phyblock;\n\t\t\tnew_blk = delay_write->new_phyblock;\n\t\t} else if (delay_write->delay_write_flag &&\n\t\t\t\t(delay_write->logblock == log_blk) &&\n\t\t\t\t(start_page == delay_write->pageoff)) {\n\t\t\tdelay_write->delay_write_flag = 0;\n\t\t\told_blk = delay_write->old_phyblock;\n\t\t\tnew_blk = delay_write->new_phyblock;\n\t\t} else {\n\t\t\tretval = ms_delay_write(chip);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n#endif\n\t\t\told_blk = ms_get_l2p_tbl\n\t\t\t\t\t(chip, seg_no,\n\t\t\t\t\t log_blk - ms_start_idx[seg_no]);\n\t\t\tnew_blk  = ms_get_unused_block(chip, seg_no);\n\t\t\tif (old_blk == 0xFFFF || new_blk == 0xFFFF) {\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\n\t\t\tretval = ms_prepare_write(chip, old_blk, new_blk,\n\t\t\t\t\t\t  log_blk, start_page);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tif (detect_card_cd(chip, MS_CARD) !=\n\t\t\t\t    STATUS_SUCCESS) {\n\t\t\t\t\tset_sense_type\n\t\t\t\t\t\t(chip, lun,\n\t\t\t\t\t\tSENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t\t}\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n#ifdef MS_DELAY_WRITE\n\t\t}\n#endif\n\t} else {\n#ifdef MS_DELAY_WRITE\n\t\tretval = ms_delay_write(chip);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tif (detect_card_cd(chip, MS_CARD) != STATUS_SUCCESS) {\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n#endif\n\t\told_blk = ms_get_l2p_tbl(chip, seg_no,\n\t\t\t\t\t log_blk - ms_start_idx[seg_no]);\n\t\tif (old_blk == 0xFFFF) {\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\t}\n\n\tdev_dbg(rtsx_dev(chip), \"seg_no = %d, old_blk = 0x%x, new_blk = 0x%x\\n\",\n\t\tseg_no, old_blk, new_blk);\n\n\twhile (total_sec_cnt) {\n\t\tif ((start_page + total_sec_cnt) > (ms_card->page_off + 1))\n\t\t\tend_page = ms_card->page_off + 1;\n\t\telse\n\t\t\tend_page = start_page + (u8)total_sec_cnt;\n\n\t\tpage_cnt = end_page - start_page;\n\n\t\tdev_dbg(rtsx_dev(chip), \"start_page = %d, end_page = %d, page_cnt = %d\\n\",\n\t\t\tstart_page, end_page, page_cnt);\n\n\t\tif (srb->sc_data_direction == DMA_FROM_DEVICE) {\n\t\t\tretval = ms_read_multiple_pages(chip,\n\t\t\t\t\t\t\told_blk, log_blk,\n\t\t\t\t\t\t\tstart_page, end_page,\n\t\t\t\t\t\t\tptr, &index, &offset);\n\t\t} else {\n\t\t\tretval = ms_write_multiple_pages(chip, old_blk, new_blk,\n\t\t\t\t\t\t\t log_blk, start_page,\n\t\t\t\t\t\t\t end_page, ptr, &index,\n\t\t\t\t\t\t\t &offset);\n\t\t}\n\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\ttoggle_gpio(chip, 1);\n\t\t\tif (detect_card_cd(chip, MS_CARD) != STATUS_SUCCESS) {\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t\tms_rw_fail(srb, chip);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tif (srb->sc_data_direction == DMA_TO_DEVICE) {\n\t\t\tif (end_page == (ms_card->page_off + 1)) {\n\t\t\t\tretval = ms_erase_block(chip, old_blk);\n\t\t\t\tif (retval == STATUS_SUCCESS)\n\t\t\t\t\tms_set_unused_block(chip, old_blk);\n\n\t\t\t\tms_set_l2p_tbl(chip, seg_no,\n\t\t\t\t\t       log_blk - ms_start_idx[seg_no],\n\t\t\t\t\t       new_blk);\n\t\t\t}\n\t\t}\n\n\t\ttotal_sec_cnt -= page_cnt;\n\t\tif (scsi_sg_count(srb) == 0)\n\t\t\tptr += page_cnt * 512;\n\n\t\tif (total_sec_cnt == 0)\n\t\t\tbreak;\n\n\t\tlog_blk++;\n\n\t\tfor (seg_no = 0; seg_no < ARRAY_SIZE(ms_start_idx) - 1;\n\t\t\t\tseg_no++) {\n\t\t\tif (log_blk < ms_start_idx[seg_no + 1])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (ms_card->segment[seg_no].build_flag == 0) {\n\t\t\tretval = ms_build_l2p_tbl(chip, seg_no);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tchip->card_fail |= MS_CARD;\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t}\n\n\t\told_blk = ms_get_l2p_tbl(chip, seg_no,\n\t\t\t\t\t log_blk - ms_start_idx[seg_no]);\n\t\tif (old_blk == 0xFFFF) {\n\t\t\tms_rw_fail(srb, chip);\n\t\t\treturn STATUS_FAIL;\n\t\t}\n\n\t\tif (srb->sc_data_direction == DMA_TO_DEVICE) {\n\t\t\tnew_blk = ms_get_unused_block(chip, seg_no);\n\t\t\tif (new_blk == 0xFFFF) {\n\t\t\t\tms_rw_fail(srb, chip);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n\t\t}\n\n\t\tdev_dbg(rtsx_dev(chip), \"seg_no = %d, old_blk = 0x%x, new_blk = 0x%x\\n\",\n\t\t\tseg_no, old_blk, new_blk);\n\n\t\tstart_page = 0;\n\t}\n\n\tif (srb->sc_data_direction == DMA_TO_DEVICE) {\n\t\tif (end_page < (ms_card->page_off + 1)) {\n#ifdef MS_DELAY_WRITE\n\t\t\tdelay_write->delay_write_flag = 1;\n\t\t\tdelay_write->old_phyblock = old_blk;\n\t\t\tdelay_write->new_phyblock = new_blk;\n\t\t\tdelay_write->logblock = log_blk;\n\t\t\tdelay_write->pageoff = end_page;\n#else\n\t\t\tretval = ms_finish_write(chip, old_blk, new_blk,\n\t\t\t\t\t\t log_blk, end_page);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tif (detect_card_cd(chip, MS_CARD) !=\n\t\t\t\t    STATUS_SUCCESS) {\n\t\t\t\t\tset_sense_type\n\t\t\t\t\t\t(chip, lun,\n\t\t\t\t\t\tSENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\t\t\treturn STATUS_FAIL;\n\t\t\t\t}\n\n\t\t\t\tms_rw_fail(srb, chip);\n\t\t\t\treturn STATUS_FAIL;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\tscsi_set_resid(srb, 0);\n\n\treturn STATUS_SUCCESS;\n}\n\nint ms_rw(struct scsi_cmnd *srb, struct rtsx_chip *chip,\n\t  u32 start_sector, u16 sector_cnt)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\n\tif (CHK_MSPRO(ms_card))\n\t\tretval = mspro_rw_multi_sector(srb, chip, start_sector,\n\t\t\t\t\t       sector_cnt);\n\telse\n\t\tretval = ms_rw_multi_sector(srb, chip, start_sector,\n\t\t\t\t\t    sector_cnt);\n\n\treturn retval;\n}\n\nvoid ms_free_l2p_tbl(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint i = 0;\n\n\tif (ms_card->segment) {\n\t\tfor (i = 0; i < ms_card->segment_cnt; i++) {\n\t\t\tvfree(ms_card->segment[i].l2p_table);\n\t\t\tms_card->segment[i].l2p_table = NULL;\n\t\t\tvfree(ms_card->segment[i].free_table);\n\t\t\tms_card->segment[i].free_table = NULL;\n\t\t}\n\t\tvfree(ms_card->segment);\n\t\tms_card->segment = NULL;\n\t}\n}\n\n#ifdef SUPPORT_MAGIC_GATE\n\n#ifdef READ_BYTES_WAIT_INT\nstatic int ms_poll_int(struct rtsx_chip *chip)\n{\n\tint retval;\n\tu8 val;\n\n\trtsx_init_cmd(chip);\n\n\trtsx_add_cmd(chip, CHECK_REG_CMD, MS_TRANS_CFG, MS_INT_CED, MS_INT_CED);\n\n\tretval = rtsx_send_cmd(chip, MS_CARD, 5000);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tval = *rtsx_get_cmd_data(chip);\n\tif (val & MS_INT_ERR)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n#endif\n\n#ifdef MS_SAMPLE_INT_ERR\nstatic int check_ms_err(struct rtsx_chip *chip)\n{\n\tint retval;\n\tu8 val;\n\n\tretval = rtsx_read_register(chip, MS_TRANSFER, &val);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn 1;\n\tif (val & MS_TRANSFER_ERR)\n\t\treturn 1;\n\n\tretval = rtsx_read_register(chip, MS_TRANS_CFG, &val);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn 1;\n\n\tif (val & (MS_INT_ERR | MS_INT_CMDNK))\n\t\treturn 1;\n\n\treturn 0;\n}\n#else\nstatic int check_ms_err(struct rtsx_chip *chip)\n{\n\tint retval;\n\tu8 val;\n\n\tretval = rtsx_read_register(chip, MS_TRANSFER, &val);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn 1;\n\tif (val & MS_TRANSFER_ERR)\n\t\treturn 1;\n\n\treturn 0;\n}\n#endif\n\nstatic int mg_send_ex_cmd(struct rtsx_chip *chip, u8 cmd, u8 entry_num)\n{\n\tint retval, i;\n\tu8 data[8];\n\n\tdata[0] = cmd;\n\tdata[1] = 0;\n\tdata[2] = 0;\n\tdata[3] = 0;\n\tdata[4] = 0;\n\tdata[5] = 0;\n\tdata[6] = entry_num;\n\tdata[7] = 0;\n\n\tfor (i = 0; i < MS_MAX_RETRY_COUNT; i++) {\n\t\tretval = ms_write_bytes(chip, PRO_EX_SET_CMD, 7, WAIT_INT,\n\t\t\t\t\tdata, 8);\n\t\tif (retval == STATUS_SUCCESS)\n\t\t\tbreak;\n\t}\n\tif (i == MS_MAX_RETRY_COUNT)\n\t\treturn STATUS_FAIL;\n\n\tif (check_ms_err(chip)) {\n\t\trtsx_clear_ms_error(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nstatic int mg_set_tpc_para_sub(struct rtsx_chip *chip, int type,\n\t\t\t       u8 mg_entry_num)\n{\n\tint retval;\n\tu8 buf[6];\n\n\tif (type == 0)\n\t\tretval = ms_set_rw_reg_addr(chip, 0, 0, PRO_TPC_PARM, 1);\n\telse\n\t\tretval = ms_set_rw_reg_addr(chip, 0, 0, PRO_DATA_COUNT1, 6);\n\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tbuf[0] = 0;\n\tbuf[1] = 0;\n\tif (type == 1) {\n\t\tbuf[2] = 0;\n\t\tbuf[3] = 0;\n\t\tbuf[4] = 0;\n\t\tbuf[5] = mg_entry_num;\n\t}\n\tretval = ms_write_bytes(chip, PRO_WRITE_REG, (type == 0) ? 1 : 6,\n\t\t\t\tNO_WAIT_INT, buf, 6);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n\nint mg_set_leaf_id(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval;\n\tint i;\n\tunsigned int lun = SCSI_LUN(srb);\n\tu8 buf1[32], buf2[12];\n\n\tif (scsi_bufflen(srb) < 12) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tms_cleanup_work(chip);\n\n\tretval = ms_switch_clock(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = mg_send_ex_cmd(chip, MG_SET_LID, 0);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_KEY_FAIL_NOT_ESTAB);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tmemset(buf1, 0, 32);\n\trtsx_stor_get_xfer_buf(buf2, min_t(int, 12, scsi_bufflen(srb)), srb);\n\tfor (i = 0; i < 8; i++)\n\t\tbuf1[8 + i] = buf2[4 + i];\n\n\tretval = ms_write_bytes(chip, PRO_WRITE_SHORT_DATA, 32, WAIT_INT,\n\t\t\t\tbuf1, 32);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_KEY_FAIL_NOT_ESTAB);\n\t\treturn STATUS_FAIL;\n\t}\n\tif (check_ms_err(chip)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_KEY_FAIL_NOT_ESTAB);\n\t\trtsx_clear_ms_error(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nint mg_get_local_EKB(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval;\n\tint bufflen;\n\tunsigned int lun = SCSI_LUN(srb);\n\tu8 *buf = NULL;\n\n\tms_cleanup_work(chip);\n\n\tretval = ms_switch_clock(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tbuf = kmalloc(1540, GFP_KERNEL);\n\tif (!buf)\n\t\treturn STATUS_ERROR;\n\n\tbuf[0] = 0x04;\n\tbuf[1] = 0x1A;\n\tbuf[2] = 0x00;\n\tbuf[3] = 0x00;\n\n\tretval = mg_send_ex_cmd(chip, MG_GET_LEKB, 0);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_KEY_FAIL_NOT_AUTHEN);\n\t\tgoto free_buffer;\n\t}\n\n\tretval = ms_transfer_data(chip, MS_TM_AUTO_READ, PRO_READ_LONG_DATA,\n\t\t\t\t  3, WAIT_INT, 0, 0, buf + 4, 1536);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_KEY_FAIL_NOT_AUTHEN);\n\t\trtsx_clear_ms_error(chip);\n\t\tgoto free_buffer;\n\t}\n\tif (check_ms_err(chip)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_KEY_FAIL_NOT_AUTHEN);\n\t\trtsx_clear_ms_error(chip);\n\t\tretval = STATUS_FAIL;\n\t\tgoto free_buffer;\n\t}\n\n\tbufflen = min_t(int, 1052, scsi_bufflen(srb));\n\trtsx_stor_set_xfer_buf(buf, bufflen, srb);\n\nfree_buffer:\n\tkfree(buf);\n\treturn retval;\n}\n\nint mg_chg(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\tint bufflen;\n\tint i;\n\tunsigned int lun = SCSI_LUN(srb);\n\tu8 buf[32];\n\n\tms_cleanup_work(chip);\n\n\tretval = ms_switch_clock(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = mg_send_ex_cmd(chip, MG_GET_ID, 0);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_INCOMPATIBLE_MEDIUM);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = ms_read_bytes(chip, PRO_READ_SHORT_DATA, 32, WAIT_INT,\n\t\t\t       buf, 32);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_INCOMPATIBLE_MEDIUM);\n\t\treturn STATUS_FAIL;\n\t}\n\tif (check_ms_err(chip)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_INCOMPATIBLE_MEDIUM);\n\t\trtsx_clear_ms_error(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tmemcpy(ms_card->magic_gate_id, buf, 16);\n\n#ifdef READ_BYTES_WAIT_INT\n\tretval = ms_poll_int(chip);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_INCOMPATIBLE_MEDIUM);\n\t\treturn STATUS_FAIL;\n\t}\n#endif\n\n\tretval = mg_send_ex_cmd(chip, MG_SET_RD, 0);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_INCOMPATIBLE_MEDIUM);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tbufflen = min_t(int, 12, scsi_bufflen(srb));\n\trtsx_stor_get_xfer_buf(buf, bufflen, srb);\n\n\tfor (i = 0; i < 8; i++)\n\t\tbuf[i] = buf[4 + i];\n\n\tfor (i = 0; i < 24; i++)\n\t\tbuf[8 + i] = 0;\n\n\tretval = ms_write_bytes(chip, PRO_WRITE_SHORT_DATA,\n\t\t\t\t32, WAIT_INT, buf, 32);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_INCOMPATIBLE_MEDIUM);\n\t\treturn STATUS_FAIL;\n\t}\n\tif (check_ms_err(chip)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_INCOMPATIBLE_MEDIUM);\n\t\trtsx_clear_ms_error(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tms_card->mg_auth = 0;\n\n\treturn STATUS_SUCCESS;\n}\n\nint mg_get_rsp_chg(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\tint bufflen;\n\tunsigned int lun = SCSI_LUN(srb);\n\tu8 buf1[32], buf2[36];\n\n\tms_cleanup_work(chip);\n\n\tretval = ms_switch_clock(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = mg_send_ex_cmd(chip, MG_MAKE_RMS, 0);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_KEY_FAIL_NOT_AUTHEN);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tretval = ms_read_bytes(chip, PRO_READ_SHORT_DATA, 32, WAIT_INT,\n\t\t\t       buf1, 32);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_KEY_FAIL_NOT_AUTHEN);\n\t\treturn STATUS_FAIL;\n\t}\n\tif (check_ms_err(chip)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_KEY_FAIL_NOT_AUTHEN);\n\t\trtsx_clear_ms_error(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tbuf2[0] = 0x00;\n\tbuf2[1] = 0x22;\n\tbuf2[2] = 0x00;\n\tbuf2[3] = 0x00;\n\n\tmemcpy(buf2 + 4, ms_card->magic_gate_id, 16);\n\tmemcpy(buf2 + 20, buf1, 16);\n\n\tbufflen = min_t(int, 36, scsi_bufflen(srb));\n\trtsx_stor_set_xfer_buf(buf2, bufflen, srb);\n\n#ifdef READ_BYTES_WAIT_INT\n\tretval = ms_poll_int(chip);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_KEY_FAIL_NOT_AUTHEN);\n\t\treturn STATUS_FAIL;\n\t}\n#endif\n\n\treturn STATUS_SUCCESS;\n}\n\nint mg_rsp(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\tint i;\n\tint bufflen;\n\tunsigned int lun = SCSI_LUN(srb);\n\tu8 buf[32];\n\n\tms_cleanup_work(chip);\n\n\tretval = ms_switch_clock(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tretval = mg_send_ex_cmd(chip, MG_MAKE_KSE, 0);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_KEY_FAIL_NOT_AUTHEN);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tbufflen = min_t(int, 12, scsi_bufflen(srb));\n\trtsx_stor_get_xfer_buf(buf, bufflen, srb);\n\n\tfor (i = 0; i < 8; i++)\n\t\tbuf[i] = buf[4 + i];\n\n\tfor (i = 0; i < 24; i++)\n\t\tbuf[8 + i] = 0;\n\n\tretval = ms_write_bytes(chip, PRO_WRITE_SHORT_DATA, 32, WAIT_INT,\n\t\t\t\tbuf, 32);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_KEY_FAIL_NOT_AUTHEN);\n\t\treturn STATUS_FAIL;\n\t}\n\tif (check_ms_err(chip)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_KEY_FAIL_NOT_AUTHEN);\n\t\trtsx_clear_ms_error(chip);\n\t\treturn STATUS_FAIL;\n\t}\n\n\tms_card->mg_auth = 1;\n\n\treturn STATUS_SUCCESS;\n}\n\nint mg_get_ICV(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\tint bufflen;\n\tunsigned int lun = SCSI_LUN(srb);\n\tu8 *buf = NULL;\n\n\tms_cleanup_work(chip);\n\n\tretval = ms_switch_clock(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tbuf = kmalloc(1028, GFP_KERNEL);\n\tif (!buf)\n\t\treturn STATUS_ERROR;\n\n\tbuf[0] = 0x04;\n\tbuf[1] = 0x02;\n\tbuf[2] = 0x00;\n\tbuf[3] = 0x00;\n\n\tretval = mg_send_ex_cmd(chip, MG_GET_IBD, ms_card->mg_entry_num);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\tgoto free_buffer;\n\t}\n\n\tretval = ms_transfer_data(chip, MS_TM_AUTO_READ, PRO_READ_LONG_DATA,\n\t\t\t\t  2, WAIT_INT, 0, 0, buf + 4, 1024);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\trtsx_clear_ms_error(chip);\n\t\tgoto free_buffer;\n\t}\n\tif (check_ms_err(chip)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\trtsx_clear_ms_error(chip);\n\t\tretval = STATUS_FAIL;\n\t\tgoto free_buffer;\n\t}\n\n\tbufflen = min_t(int, 1028, scsi_bufflen(srb));\n\trtsx_stor_set_xfer_buf(buf, bufflen, srb);\n\nfree_buffer:\n\tkfree(buf);\n\treturn retval;\n}\n\nint mg_set_ICV(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\tint bufflen;\n#ifdef MG_SET_ICV_SLOW\n\tint i;\n#endif\n\tunsigned int lun = SCSI_LUN(srb);\n\tu8 *buf = NULL;\n\n\tms_cleanup_work(chip);\n\n\tretval = ms_switch_clock(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tbuf = kmalloc(1028, GFP_KERNEL);\n\tif (!buf)\n\t\treturn STATUS_ERROR;\n\n\tbufflen = min_t(int, 1028, scsi_bufflen(srb));\n\trtsx_stor_get_xfer_buf(buf, bufflen, srb);\n\n\tretval = mg_send_ex_cmd(chip, MG_SET_IBD, ms_card->mg_entry_num);\n\tif (retval != STATUS_SUCCESS) {\n\t\tif (ms_card->mg_auth == 0) {\n\t\t\tif ((buf[5] & 0xC0) != 0)\n\t\t\t\tset_sense_type\n\t\t\t\t\t(chip, lun,\n\t\t\t\t\tSENSE_TYPE_MG_KEY_FAIL_NOT_ESTAB);\n\t\t\telse\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MG_WRITE_ERR);\n\t\t} else {\n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_WRITE_ERR);\n\t\t}\n\t\tgoto set_ICV_finish;\n\t}\n\n#ifdef MG_SET_ICV_SLOW\n\tfor (i = 0; i < 2; i++) {\n\t\tudelay(50);\n\n\t\trtsx_init_cmd(chip);\n\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TPC,\n\t\t\t     0xFF, PRO_WRITE_LONG_DATA);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, WAIT_INT);\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t     0x01, RING_BUFFER);\n\n\t\ttrans_dma_enable(DMA_TO_DEVICE, chip, 512, DMA_512);\n\n\t\trtsx_add_cmd(chip, WRITE_REG_CMD, MS_TRANSFER, 0xFF,\n\t\t\t     MS_TRANSFER_START |  MS_TM_NORMAL_WRITE);\n\t\trtsx_add_cmd(chip, CHECK_REG_CMD, MS_TRANSFER,\n\t\t\t     MS_TRANSFER_END, MS_TRANSFER_END);\n\n\t\trtsx_send_cmd_no_wait(chip);\n\n\t\tretval = rtsx_transfer_data(chip, MS_CARD, buf + 4 + i * 512,\n\t\t\t\t\t    512, 0, DMA_TO_DEVICE, 3000);\n\t\tif (retval < 0 || check_ms_err(chip)) {\n\t\t\trtsx_clear_ms_error(chip);\n\t\t\tif (ms_card->mg_auth == 0) {\n\t\t\t\tif ((buf[5] & 0xC0) != 0)\n\t\t\t\t\tset_sense_type\n\t\t\t\t\t    (chip, lun,\n\t\t\t\t\t     SENSE_TYPE_MG_KEY_FAIL_NOT_ESTAB);\n\t\t\t\telse\n\t\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t\t       SENSE_TYPE_MG_WRITE_ERR);\n\t\t\t} else {\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MG_WRITE_ERR);\n\t\t\t}\n\t\t\tretval = STATUS_FAIL;\n\t\t\tgoto set_ICV_finish;\n\t\t}\n\t}\n#else\n\tretval = ms_transfer_data(chip, MS_TM_AUTO_WRITE, PRO_WRITE_LONG_DATA,\n\t\t\t\t  2, WAIT_INT, 0, 0, buf + 4, 1024);\n\tif (retval != STATUS_SUCCESS || check_ms_err(chip)) {\n\t\trtsx_clear_ms_error(chip);\n\t\tif (ms_card->mg_auth == 0) {\n\t\t\tif ((buf[5] & 0xC0) != 0)\n\t\t\t\tset_sense_type\n\t\t\t\t    (chip, lun,\n\t\t\t\t     SENSE_TYPE_MG_KEY_FAIL_NOT_ESTAB);\n\t\t\telse\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MG_WRITE_ERR);\n\t\t} else {\n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_WRITE_ERR);\n\t\t}\n\t\tgoto set_ICV_finish;\n\t}\n#endif\n\nset_ICV_finish:\n\tkfree(buf);\n\treturn retval;\n}\n\n#endif  \n\nvoid ms_cleanup_work(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\n\tif (CHK_MSPRO(ms_card)) {\n\t\tif (ms_card->seq_mode) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"MS Pro: stop transmission\\n\");\n\t\t\tmspro_stop_seq_mode(chip);\n\t\t\tms_card->cleanup_counter = 0;\n\t\t}\n\t\tif (CHK_MSHG(ms_card)) {\n\t\t\trtsx_write_register(chip, MS_CFG,\n\t\t\t\t\t    MS_2K_SECTOR_MODE, 0x00);\n\t\t}\n\t}\n#ifdef MS_DELAY_WRITE\n\telse if ((!CHK_MSPRO(ms_card)) &&\n\t\t ms_card->delay_write.delay_write_flag) {\n\t\tdev_dbg(rtsx_dev(chip), \"MS: delay write\\n\");\n\t\tms_delay_write(chip);\n\t\tms_card->cleanup_counter = 0;\n\t}\n#endif\n}\n\nint ms_power_off_card3v3(struct rtsx_chip *chip)\n{\n\tint retval;\n\n\tretval = disable_card_clock(chip, MS_CARD);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\tif (chip->asic_code) {\n\t\tretval = ms_pull_ctl_disable(chip);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t} else {\n\t\tretval = rtsx_write_register(chip, FPGA_PULL_CTL,\n\t\t\t\t\t     FPGA_MS_PULL_CTL_BIT | 0x20,\n\t\t\t\t\t     FPGA_MS_PULL_CTL_BIT);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\tretval = rtsx_write_register(chip, CARD_OE, MS_OUTPUT_EN, 0);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!chip->ft2_fast_mode) {\n\t\tretval = card_power_off(chip, MS_CARD);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn STATUS_FAIL;\n\t}\n\n\treturn STATUS_SUCCESS;\n}\n\nint release_ms_card(struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint retval;\n\n#ifdef MS_DELAY_WRITE\n\tms_card->delay_write.delay_write_flag = 0;\n#endif\n\tms_card->pro_under_formatting = 0;\n\n\tchip->card_ready &= ~MS_CARD;\n\tchip->card_fail &= ~MS_CARD;\n\tchip->card_wp &= ~MS_CARD;\n\n\tms_free_l2p_tbl(chip);\n\n\tmemset(ms_card->raw_sys_info, 0, 96);\n#ifdef SUPPORT_PCGL_1P18\n\tmemset(ms_card->raw_model_name, 0, 48);\n#endif\n\n\tretval = ms_power_off_card3v3(chip);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn STATUS_FAIL;\n\n\treturn STATUS_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}