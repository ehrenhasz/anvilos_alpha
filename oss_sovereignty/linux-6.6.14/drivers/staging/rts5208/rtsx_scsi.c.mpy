{
  "module_name": "rtsx_scsi.c",
  "hash_id": "1ec8ea8efd97471307549ba8ee6201bd98c74599c5554f5e4c87341c899e33c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rts5208/rtsx_scsi.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n\n#include \"rtsx.h\"\n#include \"sd.h\"\n#include \"ms.h\"\n#include \"spi.h\"\n\nvoid scsi_show_command(struct rtsx_chip *chip)\n{\n\tstruct scsi_cmnd *srb = chip->srb;\n\tchar *what = NULL;\n\tbool unknown_cmd = false;\n\tint len;\n\n\tswitch (srb->cmnd[0]) {\n\tcase TEST_UNIT_READY:\n\t\twhat = \"TEST_UNIT_READY\";\n\t\tbreak;\n\tcase REZERO_UNIT:\n\t\twhat = \"REZERO_UNIT\";\n\t\tbreak;\n\tcase REQUEST_SENSE:\n\t\twhat = \"REQUEST_SENSE\";\n\t\tbreak;\n\tcase FORMAT_UNIT:\n\t\twhat = \"FORMAT_UNIT\";\n\t\tbreak;\n\tcase READ_BLOCK_LIMITS:\n\t\twhat = \"READ_BLOCK_LIMITS\";\n\t\tbreak;\n\tcase REASSIGN_BLOCKS:\n\t\twhat = \"REASSIGN_BLOCKS\";\n\t\tbreak;\n\tcase READ_6:\n\t\twhat = \"READ_6\";\n\t\tbreak;\n\tcase WRITE_6:\n\t\twhat = \"WRITE_6\";\n\t\tbreak;\n\tcase SEEK_6:\n\t\twhat = \"SEEK_6\";\n\t\tbreak;\n\tcase READ_REVERSE:\n\t\twhat = \"READ_REVERSE\";\n\t\tbreak;\n\tcase WRITE_FILEMARKS:\n\t\twhat = \"WRITE_FILEMARKS\";\n\t\tbreak;\n\tcase SPACE:\n\t\twhat = \"SPACE\";\n\t\tbreak;\n\tcase INQUIRY:\n\t\twhat = \"INQUIRY\";\n\t\tbreak;\n\tcase RECOVER_BUFFERED_DATA:\n\t\twhat = \"RECOVER_BUFFERED_DATA\";\n\t\tbreak;\n\tcase MODE_SELECT:\n\t\twhat = \"MODE_SELECT\";\n\t\tbreak;\n\tcase RESERVE:\n\t\twhat = \"RESERVE\";\n\t\tbreak;\n\tcase RELEASE:\n\t\twhat = \"RELEASE\";\n\t\tbreak;\n\tcase COPY:\n\t\twhat = \"COPY\";\n\t\tbreak;\n\tcase ERASE:\n\t\twhat = \"ERASE\";\n\t\tbreak;\n\tcase MODE_SENSE:\n\t\twhat = \"MODE_SENSE\";\n\t\tbreak;\n\tcase START_STOP:\n\t\twhat = \"START_STOP\";\n\t\tbreak;\n\tcase RECEIVE_DIAGNOSTIC:\n\t\twhat = \"RECEIVE_DIAGNOSTIC\";\n\t\tbreak;\n\tcase SEND_DIAGNOSTIC:\n\t\twhat = \"SEND_DIAGNOSTIC\";\n\t\tbreak;\n\tcase ALLOW_MEDIUM_REMOVAL:\n\t\twhat = \"ALLOW_MEDIUM_REMOVAL\";\n\t\tbreak;\n\tcase SET_WINDOW:\n\t\twhat = \"SET_WINDOW\";\n\t\tbreak;\n\tcase READ_CAPACITY:\n\t\twhat = \"READ_CAPACITY\";\n\t\tbreak;\n\tcase READ_10:\n\t\twhat = \"READ_10\";\n\t\tbreak;\n\tcase WRITE_10:\n\t\twhat = \"WRITE_10\";\n\t\tbreak;\n\tcase SEEK_10:\n\t\twhat = \"SEEK_10\";\n\t\tbreak;\n\tcase WRITE_VERIFY:\n\t\twhat = \"WRITE_VERIFY\";\n\t\tbreak;\n\tcase VERIFY:\n\t\twhat = \"VERIFY\";\n\t\tbreak;\n\tcase SEARCH_HIGH:\n\t\twhat = \"SEARCH_HIGH\";\n\t\tbreak;\n\tcase SEARCH_EQUAL:\n\t\twhat = \"SEARCH_EQUAL\";\n\t\tbreak;\n\tcase SEARCH_LOW:\n\t\twhat = \"SEARCH_LOW\";\n\t\tbreak;\n\tcase SET_LIMITS:\n\t\twhat = \"SET_LIMITS\";\n\t\tbreak;\n\tcase READ_POSITION:\n\t\twhat = \"READ_POSITION\";\n\t\tbreak;\n\tcase SYNCHRONIZE_CACHE:\n\t\twhat = \"SYNCHRONIZE_CACHE\";\n\t\tbreak;\n\tcase LOCK_UNLOCK_CACHE:\n\t\twhat = \"LOCK_UNLOCK_CACHE\";\n\t\tbreak;\n\tcase READ_DEFECT_DATA:\n\t\twhat = \"READ_DEFECT_DATA\";\n\t\tbreak;\n\tcase MEDIUM_SCAN:\n\t\twhat = \"MEDIUM_SCAN\";\n\t\tbreak;\n\tcase COMPARE:\n\t\twhat = \"COMPARE\";\n\t\tbreak;\n\tcase COPY_VERIFY:\n\t\twhat = \"COPY_VERIFY\";\n\t\tbreak;\n\tcase WRITE_BUFFER:\n\t\twhat = \"WRITE_BUFFER\";\n\t\tbreak;\n\tcase READ_BUFFER:\n\t\twhat = \"READ_BUFFER\";\n\t\tbreak;\n\tcase UPDATE_BLOCK:\n\t\twhat = \"UPDATE_BLOCK\";\n\t\tbreak;\n\tcase READ_LONG:\n\t\twhat = \"READ_LONG\";\n\t\tbreak;\n\tcase WRITE_LONG:\n\t\twhat = \"WRITE_LONG\";\n\t\tbreak;\n\tcase CHANGE_DEFINITION:\n\t\twhat = \"CHANGE_DEFINITION\";\n\t\tbreak;\n\tcase WRITE_SAME:\n\t\twhat = \"WRITE_SAME\";\n\t\tbreak;\n\tcase GPCMD_READ_SUBCHANNEL:\n\t\twhat = \"READ SUBCHANNEL\";\n\t\tbreak;\n\tcase READ_TOC:\n\t\twhat = \"READ_TOC\";\n\t\tbreak;\n\tcase GPCMD_READ_HEADER:\n\t\twhat = \"READ HEADER\";\n\t\tbreak;\n\tcase GPCMD_PLAY_AUDIO_10:\n\t\twhat = \"PLAY AUDIO (10)\";\n\t\tbreak;\n\tcase GPCMD_PLAY_AUDIO_MSF:\n\t\twhat = \"PLAY AUDIO MSF\";\n\t\tbreak;\n\tcase GPCMD_GET_EVENT_STATUS_NOTIFICATION:\n\t\twhat = \"GET EVENT/STATUS NOTIFICATION\";\n\t\tbreak;\n\tcase GPCMD_PAUSE_RESUME:\n\t\twhat = \"PAUSE/RESUME\";\n\t\tbreak;\n\tcase LOG_SELECT:\n\t\twhat = \"LOG_SELECT\";\n\t\tbreak;\n\tcase LOG_SENSE:\n\t\twhat = \"LOG_SENSE\";\n\t\tbreak;\n\tcase GPCMD_STOP_PLAY_SCAN:\n\t\twhat = \"STOP PLAY/SCAN\";\n\t\tbreak;\n\tcase GPCMD_READ_DISC_INFO:\n\t\twhat = \"READ DISC INFORMATION\";\n\t\tbreak;\n\tcase GPCMD_READ_TRACK_RZONE_INFO:\n\t\twhat = \"READ TRACK INFORMATION\";\n\t\tbreak;\n\tcase GPCMD_RESERVE_RZONE_TRACK:\n\t\twhat = \"RESERVE TRACK\";\n\t\tbreak;\n\tcase GPCMD_SEND_OPC:\n\t\twhat = \"SEND OPC\";\n\t\tbreak;\n\tcase MODE_SELECT_10:\n\t\twhat = \"MODE_SELECT_10\";\n\t\tbreak;\n\tcase GPCMD_REPAIR_RZONE_TRACK:\n\t\twhat = \"REPAIR TRACK\";\n\t\tbreak;\n\tcase 0x59:\n\t\twhat = \"READ MASTER CUE\";\n\t\tbreak;\n\tcase MODE_SENSE_10:\n\t\twhat = \"MODE_SENSE_10\";\n\t\tbreak;\n\tcase GPCMD_CLOSE_TRACK:\n\t\twhat = \"CLOSE TRACK/SESSION\";\n\t\tbreak;\n\tcase 0x5C:\n\t\twhat = \"READ BUFFER CAPACITY\";\n\t\tbreak;\n\tcase 0x5D:\n\t\twhat = \"SEND CUE SHEET\";\n\t\tbreak;\n\tcase GPCMD_BLANK:\n\t\twhat = \"BLANK\";\n\t\tbreak;\n\tcase REPORT_LUNS:\n\t\twhat = \"REPORT LUNS\";\n\t\tbreak;\n\tcase MOVE_MEDIUM:\n\t\twhat = \"MOVE_MEDIUM or PLAY AUDIO (12)\";\n\t\tbreak;\n\tcase READ_12:\n\t\twhat = \"READ_12\";\n\t\tbreak;\n\tcase WRITE_12:\n\t\twhat = \"WRITE_12\";\n\t\tbreak;\n\tcase WRITE_VERIFY_12:\n\t\twhat = \"WRITE_VERIFY_12\";\n\t\tbreak;\n\tcase SEARCH_HIGH_12:\n\t\twhat = \"SEARCH_HIGH_12\";\n\t\tbreak;\n\tcase SEARCH_EQUAL_12:\n\t\twhat = \"SEARCH_EQUAL_12\";\n\t\tbreak;\n\tcase SEARCH_LOW_12:\n\t\twhat = \"SEARCH_LOW_12\";\n\t\tbreak;\n\tcase SEND_VOLUME_TAG:\n\t\twhat = \"SEND_VOLUME_TAG\";\n\t\tbreak;\n\tcase READ_ELEMENT_STATUS:\n\t\twhat = \"READ_ELEMENT_STATUS\";\n\t\tbreak;\n\tcase GPCMD_READ_CD_MSF:\n\t\twhat = \"READ CD MSF\";\n\t\tbreak;\n\tcase GPCMD_SCAN:\n\t\twhat = \"SCAN\";\n\t\tbreak;\n\tcase GPCMD_SET_SPEED:\n\t\twhat = \"SET CD SPEED\";\n\t\tbreak;\n\tcase GPCMD_MECHANISM_STATUS:\n\t\twhat = \"MECHANISM STATUS\";\n\t\tbreak;\n\tcase GPCMD_READ_CD:\n\t\twhat = \"READ CD\";\n\t\tbreak;\n\tcase 0xE1:\n\t\twhat = \"WRITE CONTINUE\";\n\t\tbreak;\n\tcase WRITE_LONG_2:\n\t\twhat = \"WRITE_LONG_2\";\n\t\tbreak;\n\tcase VENDOR_CMND:\n\t\twhat = \"Realtek's vendor command\";\n\t\tbreak;\n\tdefault:\n\t\twhat = \"(unknown command)\";\n\t\tunknown_cmd = true;\n\t\tbreak;\n\t}\n\n\tif (srb->cmnd[0] != TEST_UNIT_READY)\n\t\tdev_dbg(rtsx_dev(chip), \"Command %s (%d bytes)\\n\",\n\t\t\twhat, srb->cmd_len);\n\n\tif (unknown_cmd) {\n\t\tlen = min_t(unsigned short, srb->cmd_len, 16);\n\t\tdev_dbg(rtsx_dev(chip), \"%*ph\\n\", len, srb->cmnd);\n\t}\n}\n\nvoid set_sense_type(struct rtsx_chip *chip, unsigned int lun, int sense_type)\n{\n\tswitch (sense_type) {\n\tcase SENSE_TYPE_MEDIA_CHANGE:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x06, 0, 0x28, 0, 0, 0);\n\t\tbreak;\n\n\tcase SENSE_TYPE_MEDIA_NOT_PRESENT:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x02, 0, 0x3A, 0, 0, 0);\n\t\tbreak;\n\n\tcase SENSE_TYPE_MEDIA_LBA_OVER_RANGE:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x05, 0, 0x21, 0, 0, 0);\n\t\tbreak;\n\n\tcase SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x05, 0, 0x25, 0, 0, 0);\n\t\tbreak;\n\n\tcase SENSE_TYPE_MEDIA_WRITE_PROTECT:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x07, 0, 0x27, 0, 0, 0);\n\t\tbreak;\n\n\tcase SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x03, 0, 0x11, 0, 0, 0);\n\t\tbreak;\n\n\tcase SENSE_TYPE_MEDIA_WRITE_ERR:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x03, 0, 0x0C, 0x02, 0, 0);\n\t\tbreak;\n\n\tcase SENSE_TYPE_MEDIA_INVALID_CMD_FIELD:\n\t\tset_sense_data(chip, lun, CUR_ERR, ILGAL_REQ, 0,\n\t\t\t       ASC_INVLD_CDB, ASCQ_INVLD_CDB, CDB_ILLEGAL, 1);\n\t\tbreak;\n\n\tcase SENSE_TYPE_FORMAT_IN_PROGRESS:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x02, 0, 0x04, 0x04, 0, 0);\n\t\tbreak;\n\n\tcase SENSE_TYPE_FORMAT_CMD_FAILED:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x03, 0, 0x31, 0x01, 0, 0);\n\t\tbreak;\n\n#ifdef SUPPORT_MAGIC_GATE\n\tcase SENSE_TYPE_MG_KEY_FAIL_NOT_ESTAB:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x05, 0, 0x6F, 0x02, 0, 0);\n\t\tbreak;\n\n\tcase SENSE_TYPE_MG_KEY_FAIL_NOT_AUTHEN:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x05, 0, 0x6F, 0x00, 0, 0);\n\t\tbreak;\n\n\tcase SENSE_TYPE_MG_INCOMPATIBLE_MEDIUM:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x02, 0, 0x30, 0x00, 0, 0);\n\t\tbreak;\n\n\tcase SENSE_TYPE_MG_WRITE_ERR:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x03, 0, 0x0C, 0x00, 0, 0);\n\t\tbreak;\n#endif\n\n#ifdef SUPPORT_SD_LOCK\n\tcase SENSE_TYPE_MEDIA_READ_FORBIDDEN:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0x07, 0, 0x11, 0x13, 0, 0);\n\t\tbreak;\n#endif\n\n\tcase SENSE_TYPE_NO_SENSE:\n\tdefault:\n\t\tset_sense_data(chip, lun, CUR_ERR, 0, 0, 0, 0, 0, 0);\n\t\tbreak;\n\t}\n}\n\nvoid set_sense_data(struct rtsx_chip *chip, unsigned int lun, u8 err_code,\n\t\t    u8 sense_key, u32 info, u8 asc, u8 ascq, u8 sns_key_info0,\n\t\tu16 sns_key_info1)\n{\n\tstruct sense_data_t *sense = &chip->sense_buffer[lun];\n\n\tsense->err_code = err_code;\n\tsense->sense_key = sense_key;\n\tsense->info[0] = (u8)(info >> 24);\n\tsense->info[1] = (u8)(info >> 16);\n\tsense->info[2] = (u8)(info >> 8);\n\tsense->info[3] = (u8)info;\n\n\tsense->ad_sense_len = sizeof(struct sense_data_t) - 8;\n\tsense->asc = asc;\n\tsense->ascq = ascq;\n\tif (sns_key_info0 != 0) {\n\t\tsense->sns_key_info[0] = SKSV | sns_key_info0;\n\t\tsense->sns_key_info[1] = (sns_key_info1 & 0xf0) >> 4;\n\t\tsense->sns_key_info[2] = sns_key_info1 & 0x0f;\n\t}\n}\n\nstatic int test_unit_ready(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned int lun = SCSI_LUN(srb);\n\n\tif (!check_card_ready(chip, lun)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (!(CHK_BIT(chip->lun_mc, lun))) {\n\t\tSET_BIT(chip->lun_mc, lun);\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_CHANGE);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n#ifdef SUPPORT_SD_LOCK\n\tif (get_lun_card(chip, SCSI_LUN(srb)) == SD_CARD) {\n\t\tstruct sd_info *sd_card = &chip->sd_card;\n\n\t\tif (sd_card->sd_lock_notify) {\n\t\t\tsd_card->sd_lock_notify = 0;\n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_CHANGE);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t} else if (sd_card->sd_lock_status & SD_LOCKED) {\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_READ_FORBIDDEN);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t}\n#endif\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic unsigned char formatter_inquiry_str[20] = {\n\t'M', 'E', 'M', 'O', 'R', 'Y', 'S', 'T', 'I', 'C', 'K',\n#ifdef SUPPORT_MAGIC_GATE\n\t'-', 'M', 'G',  \n#else\n\t0x20, 0x20, 0x20,   \n#endif\n\n#ifdef SUPPORT_MAGIC_GATE\n\t0x0B,   \n#else\n\t0x09,   \n#endif\n\t0x00,   \n\t0x00,   \n\t0x20, 0x20, 0x20,  \n};\n\nstatic int inquiry(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned int lun = SCSI_LUN(srb);\n\tchar *inquiry_default = (char *)\"Generic-xD/SD/M.S.      1.00 \";\n\tchar *inquiry_sdms =    (char *)\"Generic-SD/MemoryStick  1.00 \";\n\tchar *inquiry_sd =      (char *)\"Generic-SD/MMC          1.00 \";\n\tchar *inquiry_ms =      (char *)\"Generic-MemoryStick     1.00 \";\n\tchar *inquiry_string;\n\tunsigned char sendbytes;\n\tunsigned char *buf;\n\tu8 card = get_lun_card(chip, lun);\n\tbool pro_formatter_flag = false;\n\tunsigned char inquiry_buf[] = {\n\t\tQULIFIRE | DRCT_ACCESS_DEV,\n\t\tRMB_DISC | 0x0D,\n\t\t0x00,\n\t\t0x01,\n\t\t0x1f,\n\t\t0x02,\n\t\t0,\n\t\tREL_ADR | WBUS_32 | WBUS_16 | SYNC | LINKED | CMD_QUE | SFT_RE,\n\t};\n\n\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\n\t\tif (chip->lun2card[lun] == SD_CARD)\n\t\t\tinquiry_string = inquiry_sd;\n\t\telse\n\t\t\tinquiry_string = inquiry_ms;\n\n\t} else if (CHECK_LUN_MODE(chip, SD_MS_1LUN)) {\n\t\tinquiry_string = inquiry_sdms;\n\t} else {\n\t\tinquiry_string = inquiry_default;\n\t}\n\n\tbuf = vmalloc(scsi_bufflen(srb));\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n#ifdef SUPPORT_MAGIC_GATE\n\tif (chip->mspro_formatter_enable &&\n\t    (chip->lun2card[lun] & MS_CARD))\n#else\n\tif (chip->mspro_formatter_enable)\n#endif\n\t\tif (!card || card == MS_CARD)\n\t\t\tpro_formatter_flag = true;\n\n\tif (pro_formatter_flag) {\n\t\tif (scsi_bufflen(srb) < 56)\n\t\t\tsendbytes = (unsigned char)(scsi_bufflen(srb));\n\t\telse\n\t\t\tsendbytes = 56;\n\n\t} else {\n\t\tif (scsi_bufflen(srb) < 36)\n\t\t\tsendbytes = (unsigned char)(scsi_bufflen(srb));\n\t\telse\n\t\t\tsendbytes = 36;\n\t}\n\n\tif (sendbytes > 8) {\n\t\tmemcpy(buf, inquiry_buf, 8);\n\t\tstrncpy(buf + 8, inquiry_string, sendbytes - 8);\n\t\tif (pro_formatter_flag) {\n\t\t\t \n\t\t\tbuf[4] = 0x33;\n\t\t}\n\t} else {\n\t\tmemcpy(buf, inquiry_buf, sendbytes);\n\t}\n\n\tif (pro_formatter_flag) {\n\t\tif (sendbytes > 36)\n\t\t\tmemcpy(buf + 36, formatter_inquiry_str, sendbytes - 36);\n\t}\n\n\tscsi_set_resid(srb, 0);\n\n\trtsx_stor_set_xfer_buf(buf, scsi_bufflen(srb), srb);\n\tvfree(buf);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int start_stop_unit(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned int lun = SCSI_LUN(srb);\n\n\tscsi_set_resid(srb, scsi_bufflen(srb));\n\n\tif (srb->cmnd[1] == 1)\n\t\treturn TRANSPORT_GOOD;\n\n\tswitch (srb->cmnd[0x4]) {\n\tcase STOP_MEDIUM:\n\t\t \n\t\treturn TRANSPORT_GOOD;\n\n\tcase UNLOAD_MEDIUM:\n\t\t \n\t\tif (check_card_ready(chip, lun))\n\t\t\teject_card(chip, lun);\n\t\treturn TRANSPORT_GOOD;\n\n\tcase MAKE_MEDIUM_READY:\n\tcase LOAD_MEDIUM:\n\t\tif (check_card_ready(chip, lun))\n\t\t\treturn TRANSPORT_GOOD;\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\treturn TRANSPORT_FAILED;\n\n\t\tbreak;\n\t}\n\n\treturn TRANSPORT_ERROR;\n}\n\nstatic int allow_medium_removal(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint prevent;\n\n\tprevent = srb->cmnd[4] & 0x1;\n\n\tscsi_set_resid(srb, 0);\n\n\tif (prevent) {\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int request_sense(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct sense_data_t *sense;\n\tunsigned int lun = SCSI_LUN(srb);\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tunsigned char *tmp, *buf;\n\n\tsense = &chip->sense_buffer[lun];\n\n\tif ((get_lun_card(chip, lun) == MS_CARD) &&\n\t    ms_card->pro_under_formatting) {\n\t\tif (ms_card->format_status == FORMAT_SUCCESS) {\n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_NO_SENSE);\n\t\t\tms_card->pro_under_formatting = 0;\n\t\t\tms_card->progress = 0;\n\t\t} else if (ms_card->format_status == FORMAT_IN_PROGRESS) {\n\t\t\t \n\t\t\tset_sense_data(chip, lun, CUR_ERR, 0x02, 0, 0x04, 0x04,\n\t\t\t\t       0, (u16)(ms_card->progress));\n\t\t} else {\n\t\t\t \n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_FORMAT_CMD_FAILED);\n\t\t\tms_card->pro_under_formatting = 0;\n\t\t\tms_card->progress = 0;\n\t\t}\n\n\t\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\t}\n\n\tbuf = vmalloc(scsi_bufflen(srb));\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\ttmp = (unsigned char *)sense;\n\tmemcpy(buf, tmp, scsi_bufflen(srb));\n\n\trtsx_stor_set_xfer_buf(buf, scsi_bufflen(srb), srb);\n\tvfree(buf);\n\n\tscsi_set_resid(srb, 0);\n\t \n\tset_sense_type(chip, lun, SENSE_TYPE_NO_SENSE);\n\treturn TRANSPORT_GOOD;\n}\n\nstatic void ms_mode_sense(struct rtsx_chip *chip, u8 cmd,\n\t\t\t  int lun, u8 *buf, int buf_len)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint sys_info_offset;\n\tint data_size = buf_len;\n\tbool support_format = false;\n\tint i = 0;\n\n\tif (cmd == MODE_SENSE) {\n\t\tsys_info_offset = 8;\n\t\tif (data_size > 0x68)\n\t\t\tdata_size = 0x68;\n\n\t\tbuf[i++] = 0x67;   \n\t} else {\n\t\tsys_info_offset = 12;\n\t\tif (data_size > 0x6C)\n\t\t\tdata_size = 0x6C;\n\n\t\tbuf[i++] = 0x00;   \n\t\tbuf[i++] = 0x6A;   \n\t}\n\n\t \n\tif (check_card_ready(chip, lun)) {\n\t\tif (CHK_MSXC(ms_card)) {\n\t\t\tsupport_format = true;\n\t\t\tbuf[i++] = 0x40;\n\t\t} else if (CHK_MSPRO(ms_card)) {\n\t\t\tsupport_format = true;\n\t\t\tbuf[i++] = 0x20;\n\t\t} else {\n\t\t\tbuf[i++] = 0x10;\n\t\t}\n\n\t\t \n\t\tif (check_card_wp(chip, lun))\n\t\t\tbuf[i++] = 0x80;\n\t\telse\n\t\t\tbuf[i++] = 0x00;\n\n\t} else {\n\t\tbuf[i++] = 0x00;\t \n\t\tbuf[i++] = 0x00;\t \n\t}\n\n\tbuf[i++] = 0x00;\t\t \n\n\tif (cmd == MODE_SENSE_10) {\n\t\tbuf[i++] = 0x00;   \n\t\tbuf[i++] = 0x00;   \n\t\tbuf[i++] = 0x00;   \n\n\t\t \n\t\tif (data_size >= 9)\n\t\t\tbuf[i++] = 0x20;\t\t \n\t\tif (data_size >= 10)\n\t\t\tbuf[i++] = 0x62;\t\t \n\t\tif (data_size >= 11)\n\t\t\tbuf[i++] = 0x00;\t\t \n\t\tif (data_size >= 12) {\n\t\t\tif (support_format)\n\t\t\t\tbuf[i++] = 0xC0;\t \n\t\t\telse\n\t\t\t\tbuf[i++] = 0x00;\n\t\t}\n\t} else {\n\t\t \n\t\tif (data_size >= 5)\n\t\t\tbuf[i++] = 0x20;\t\t \n\t\tif (data_size >= 6)\n\t\t\tbuf[i++] = 0x62;\t\t \n\t\tif (data_size >= 7)\n\t\t\tbuf[i++] = 0x00;\t\t \n\t\tif (data_size >= 8) {\n\t\t\tif (support_format)\n\t\t\t\tbuf[i++] = 0xC0;\t \n\t\t\telse\n\t\t\t\tbuf[i++] = 0x00;\n\t\t}\n\t}\n\n\tif (data_size > sys_info_offset) {\n\t\t \n\t\tint len = data_size - sys_info_offset;\n\n\t\tlen = (len < 96) ? len : 96;\n\n\t\tmemcpy(buf + sys_info_offset, ms_card->raw_sys_info, len);\n\t}\n}\n\nstatic int mode_sense(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned int lun = SCSI_LUN(srb);\n\tunsigned int data_size;\n\tint status;\n\tbool pro_formatter_flag;\n\tunsigned char page_code, *buf;\n\tu8 card = get_lun_card(chip, lun);\n\n#ifndef SUPPORT_MAGIC_GATE\n\tif (!check_card_ready(chip, lun)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\tscsi_set_resid(srb, scsi_bufflen(srb));\n\t\treturn TRANSPORT_FAILED;\n\t}\n#endif\n\n\tpro_formatter_flag = false;\n\tdata_size = 8;\n#ifdef SUPPORT_MAGIC_GATE\n\tif ((chip->lun2card[lun] & MS_CARD)) {\n\t\tif (!card || card == MS_CARD) {\n\t\t\tdata_size = 108;\n\t\t\tif (chip->mspro_formatter_enable)\n\t\t\t\tpro_formatter_flag = true;\n\t\t}\n\t}\n#else\n\tif (card == MS_CARD) {\n\t\tif (chip->mspro_formatter_enable) {\n\t\t\tpro_formatter_flag = true;\n\t\t\tdata_size = 108;\n\t\t}\n\t}\n#endif\n\n\tbuf = kmalloc(data_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\tpage_code = srb->cmnd[2] & 0x3f;\n\n\tif (page_code == 0x3F || page_code == 0x1C ||\n\t    page_code == 0x00 ||\n\t\t(pro_formatter_flag && page_code == 0x20)) {\n\t\tif (srb->cmnd[0] == MODE_SENSE) {\n\t\t\tif (page_code == 0x3F || page_code == 0x20) {\n\t\t\t\tms_mode_sense(chip, srb->cmnd[0],\n\t\t\t\t\t      lun, buf, data_size);\n\t\t\t} else {\n\t\t\t\tdata_size = 4;\n\t\t\t\tbuf[0] = 0x03;\n\t\t\t\tbuf[1] = 0x00;\n\t\t\t\tif (check_card_wp(chip, lun))\n\t\t\t\t\tbuf[2] = 0x80;\n\t\t\t\telse\n\t\t\t\t\tbuf[2] = 0x00;\n\n\t\t\t\tbuf[3] = 0x00;\n\t\t\t}\n\t\t} else {\n\t\t\tif (page_code == 0x3F || page_code == 0x20) {\n\t\t\t\tms_mode_sense(chip, srb->cmnd[0],\n\t\t\t\t\t      lun, buf, data_size);\n\t\t\t} else {\n\t\t\t\tdata_size = 8;\n\t\t\t\tbuf[0] = 0x00;\n\t\t\t\tbuf[1] = 0x06;\n\t\t\t\tbuf[2] = 0x00;\n\t\t\t\tif (check_card_wp(chip, lun))\n\t\t\t\t\tbuf[3] = 0x80;\n\t\t\t\telse\n\t\t\t\t\tbuf[3] = 0x00;\n\t\t\t\tbuf[4] = 0x00;\n\t\t\t\tbuf[5] = 0x00;\n\t\t\t\tbuf[6] = 0x00;\n\t\t\t\tbuf[7] = 0x00;\n\t\t\t}\n\t\t}\n\t\tstatus = TRANSPORT_GOOD;\n\t} else {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\tscsi_set_resid(srb, scsi_bufflen(srb));\n\t\tstatus = TRANSPORT_FAILED;\n\t}\n\n\tif (status == TRANSPORT_GOOD) {\n\t\tunsigned int len = min_t(unsigned int, scsi_bufflen(srb),\n\t\t\t\t\tdata_size);\n\t\trtsx_stor_set_xfer_buf(buf, len, srb);\n\t\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\t}\n\tkfree(buf);\n\n\treturn status;\n}\n\nstatic int read_write(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n#ifdef SUPPORT_SD_LOCK\n\tstruct sd_info *sd_card = &chip->sd_card;\n#endif\n\tunsigned int lun = SCSI_LUN(srb);\n\tint retval;\n\tu32 start_sec;\n\tu16 sec_cnt;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\tif (!check_card_ready(chip, lun) || (get_card_size(chip, lun) == 0)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (!(CHK_BIT(chip->lun_mc, lun))) {\n\t\tSET_BIT(chip->lun_mc, lun);\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_CHANGE);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n#ifdef SUPPORT_SD_LOCK\n\tif (sd_card->sd_erase_status) {\n\t\t \n\t\tdev_dbg(rtsx_dev(chip), \"SD card being erased!\\n\");\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_READ_FORBIDDEN);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (get_lun_card(chip, lun) == SD_CARD) {\n\t\tif (sd_card->sd_lock_status & SD_LOCKED) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"SD card locked!\\n\");\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_READ_FORBIDDEN);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t}\n#endif\n\n\tif (srb->cmnd[0] == READ_10 || srb->cmnd[0] == WRITE_10) {\n\t\tstart_sec = ((u32)srb->cmnd[2] << 24) |\n\t\t\t((u32)srb->cmnd[3] << 16) |\n\t\t\t((u32)srb->cmnd[4] << 8) | ((u32)srb->cmnd[5]);\n\t\tsec_cnt = ((u16)(srb->cmnd[7]) << 8) | srb->cmnd[8];\n\t} else if ((srb->cmnd[0] == READ_6) || (srb->cmnd[0] == WRITE_6)) {\n\t\tstart_sec = ((u32)(srb->cmnd[1] & 0x1F) << 16) |\n\t\t\t((u32)srb->cmnd[2] << 8) | ((u32)srb->cmnd[3]);\n\t\tsec_cnt = srb->cmnd[4];\n\t\tif (sec_cnt == 0)\n\t\t\tsec_cnt = 256;\n\t} else if ((srb->cmnd[0] == VENDOR_CMND) &&\n\t\t(srb->cmnd[1] == SCSI_APP_CMD) &&\n\t\t((srb->cmnd[2] == PP_READ10) || (srb->cmnd[2] == PP_WRITE10))) {\n\t\tstart_sec = ((u32)srb->cmnd[4] << 24) |\n\t\t\t((u32)srb->cmnd[5] << 16) |\n\t\t\t((u32)srb->cmnd[6] << 8) | ((u32)srb->cmnd[7]);\n\t\tsec_cnt = ((u16)(srb->cmnd[9]) << 8) | srb->cmnd[10];\n\t} else {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\t \n\tif (start_sec > get_card_size(chip, lun) ||\n\t    ((start_sec + sec_cnt) > get_card_size(chip, lun))) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LBA_OVER_RANGE);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (sec_cnt == 0) {\n\t\tscsi_set_resid(srb, 0);\n\t\treturn TRANSPORT_GOOD;\n\t}\n\n\tif (chip->rw_fail_cnt[lun] == 3) {\n\t\tdev_dbg(rtsx_dev(chip), \"read/write fail three times in succession\\n\");\n\t\tif (srb->sc_data_direction == DMA_FROM_DEVICE)\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\telse\n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_WRITE_ERR);\n\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (srb->sc_data_direction == DMA_TO_DEVICE) {\n\t\tif (check_card_wp(chip, lun)) {\n\t\t\tdev_dbg(rtsx_dev(chip), \"Write protected card!\\n\");\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_PROTECT);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t}\n\n\tretval = card_rw(srb, chip, start_sec, sec_cnt);\n\tif (retval != STATUS_SUCCESS) {\n\t\tif (chip->need_release & chip->lun2card[lun]) {\n\t\t\tchip->rw_fail_cnt[lun] = 0;\n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t} else {\n\t\t\tchip->rw_fail_cnt[lun]++;\n\t\t\tif (srb->sc_data_direction == DMA_FROM_DEVICE)\n\t\t\t\tset_sense_type\n\t\t\t\t\t(chip, lun,\n\t\t\t\t\t SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\t\telse\n\t\t\t\tset_sense_type(chip, lun,\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t}\n\t\tretval = TRANSPORT_FAILED;\n\t\tgoto exit;\n\t} else {\n\t\tchip->rw_fail_cnt[lun] = 0;\n\t\tretval = TRANSPORT_GOOD;\n\t}\n\n\tscsi_set_resid(srb, 0);\n\nexit:\n\treturn retval;\n}\n\nstatic int read_format_capacity(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned char *buf;\n\tunsigned int lun = SCSI_LUN(srb);\n\tunsigned int buf_len;\n\tu8 card = get_lun_card(chip, lun);\n\tu32 card_size;\n\tint desc_cnt;\n\tint i = 0;\n\n\tif (!check_card_ready(chip, lun)) {\n\t\tif (!chip->mspro_formatter_enable) {\n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t}\n\n\tbuf_len = (scsi_bufflen(srb) > 12) ? 0x14 : 12;\n\n\tbuf = kmalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\tbuf[i++] = 0;\n\tbuf[i++] = 0;\n\tbuf[i++] = 0;\n\n\t \n\tif (buf_len > 12 && chip->mspro_formatter_enable &&\n\t    (chip->lun2card[lun] & MS_CARD) &&\n\t    (!card || card == MS_CARD)) {\n\t\tbuf[i++] = 0x10;\n\t\tdesc_cnt = 2;\n\t} else {\n\t\tbuf[i++] = 0x08;\n\t\tdesc_cnt = 1;\n\t}\n\n\twhile (desc_cnt) {\n\t\tif (check_card_ready(chip, lun)) {\n\t\t\tcard_size = get_card_size(chip, lun);\n\t\t\tbuf[i++] = (unsigned char)(card_size >> 24);\n\t\t\tbuf[i++] = (unsigned char)(card_size >> 16);\n\t\t\tbuf[i++] = (unsigned char)(card_size >> 8);\n\t\t\tbuf[i++] = (unsigned char)card_size;\n\n\t\t\tif (desc_cnt == 2)\n\t\t\t\tbuf[i++] = 2;\n\t\t\telse\n\t\t\t\tbuf[i++] = 0;\n\t\t} else {\n\t\t\tbuf[i++] = 0xFF;\n\t\t\tbuf[i++] = 0xFF;\n\t\t\tbuf[i++] = 0xFF;\n\t\t\tbuf[i++] = 0xFF;\n\n\t\t\tif (desc_cnt == 2)\n\t\t\t\tbuf[i++] = 3;\n\t\t\telse\n\t\t\t\tbuf[i++] = 0;\n\t\t}\n\n\t\tbuf[i++] = 0x00;\n\t\tbuf[i++] = 0x02;\n\t\tbuf[i++] = 0x00;\n\n\t\tdesc_cnt--;\n\t}\n\n\tbuf_len = min_t(unsigned int, scsi_bufflen(srb), buf_len);\n\trtsx_stor_set_xfer_buf(buf, buf_len, srb);\n\tkfree(buf);\n\n\tscsi_set_resid(srb, scsi_bufflen(srb) - buf_len);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int read_capacity(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned char *buf;\n\tunsigned int lun = SCSI_LUN(srb);\n\tu32 card_size;\n\n\tif (!check_card_ready(chip, lun)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (!(CHK_BIT(chip->lun_mc, lun))) {\n\t\tSET_BIT(chip->lun_mc, lun);\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_CHANGE);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tbuf = kmalloc(8, GFP_KERNEL);\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\tcard_size = get_card_size(chip, lun);\n\tbuf[0] = (unsigned char)((card_size - 1) >> 24);\n\tbuf[1] = (unsigned char)((card_size - 1) >> 16);\n\tbuf[2] = (unsigned char)((card_size - 1) >> 8);\n\tbuf[3] = (unsigned char)(card_size - 1);\n\n\tbuf[4] = 0x00;\n\tbuf[5] = 0x00;\n\tbuf[6] = 0x02;\n\tbuf[7] = 0x00;\n\n\trtsx_stor_set_xfer_buf(buf, scsi_bufflen(srb), srb);\n\tkfree(buf);\n\n\tscsi_set_resid(srb, 0);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int read_eeprom(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned short len, i;\n\tint retval;\n\tu8 *buf;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\tlen = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\n\n\tbuf = vmalloc(len);\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\tretval = rtsx_force_power_on(chip, SSC_PDCTL);\n\tif (retval != STATUS_SUCCESS) {\n\t\tvfree(buf);\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tretval = spi_read_eeprom(chip, i, buf + i);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(buf);\n\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t}\n\n\tlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb), len);\n\trtsx_stor_set_xfer_buf(buf, len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\tvfree(buf);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int write_eeprom(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned short len, i;\n\tint retval;\n\tu8 *buf;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\tlen = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\n\n\tretval = rtsx_force_power_on(chip, SSC_PDCTL);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (len == 511) {\n\t\tretval = spi_erase_eeprom_chip(chip);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t} else {\n\t\tlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb),\n\t\t\t\t\tlen);\n\t\tbuf = vmalloc(len);\n\t\tif (!buf)\n\t\t\treturn TRANSPORT_ERROR;\n\n\t\trtsx_stor_get_xfer_buf(buf, len, srb);\n\t\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tretval = spi_write_eeprom(chip, i, buf[i]);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tvfree(buf);\n\t\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\t\treturn TRANSPORT_FAILED;\n\t\t\t}\n\t\t}\n\n\t\tvfree(buf);\n\t}\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int read_mem(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned short addr, len, i;\n\tint retval;\n\tu8 *buf;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\taddr = ((u16)srb->cmnd[2] << 8) | srb->cmnd[3];\n\tlen = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\n\n\tif (addr < 0xFC00) {\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tbuf = vmalloc(len);\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\tretval = rtsx_force_power_on(chip, SSC_PDCTL);\n\tif (retval != STATUS_SUCCESS) {\n\t\tvfree(buf);\n\t\tset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tretval = rtsx_read_register(chip, addr + i, buf + i);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(buf);\n\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t}\n\n\tlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb), len);\n\trtsx_stor_set_xfer_buf(buf, len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\tvfree(buf);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int write_mem(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned short addr, len, i;\n\tint retval;\n\tu8 *buf;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\taddr = ((u16)srb->cmnd[2] << 8) | srb->cmnd[3];\n\tlen = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\n\n\tif (addr < 0xFC00) {\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb), len);\n\tbuf = vmalloc(len);\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\trtsx_stor_get_xfer_buf(buf, len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\tretval = rtsx_force_power_on(chip, SSC_PDCTL);\n\tif (retval != STATUS_SUCCESS) {\n\t\tvfree(buf);\n\t\tset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tretval = rtsx_write_register(chip, addr + i, 0xFF, buf[i]);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(buf);\n\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t}\n\n\tvfree(buf);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int get_sd_csd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct sd_info *sd_card = &chip->sd_card;\n\tunsigned int lun = SCSI_LUN(srb);\n\n\tif (!check_card_ready(chip, lun)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (get_lun_card(chip, lun) != SD_CARD) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tscsi_set_resid(srb, 0);\n\trtsx_stor_set_xfer_buf(sd_card->raw_csd, scsi_bufflen(srb), srb);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int toggle_gpio_cmd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tu8 gpio = srb->cmnd[2];\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\tif (gpio > 3)\n\t\tgpio = 1;\n\ttoggle_gpio(chip, gpio);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int read_host_reg(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tu8 addr, buf[4];\n\tu32 val;\n\tunsigned int len;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\taddr = srb->cmnd[4];\n\n\tval = rtsx_readl(chip, addr);\n\tdev_dbg(rtsx_dev(chip), \"Host register (0x%x): 0x%x\\n\", addr, val);\n\n\tbuf[0] = (u8)(val >> 24);\n\tbuf[1] = (u8)(val >> 16);\n\tbuf[2] = (u8)(val >> 8);\n\tbuf[3] = (u8)val;\n\n\tlen = min_t(unsigned int, scsi_bufflen(srb), 4);\n\trtsx_stor_set_xfer_buf(buf, len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int write_host_reg(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tu8 addr, buf[4];\n\tu32 val;\n\tunsigned int len;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\taddr = srb->cmnd[4];\n\n\tlen = min_t(unsigned int, scsi_bufflen(srb), 4);\n\trtsx_stor_get_xfer_buf(buf, len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\tval = ((u32)buf[0] << 24) | ((u32)buf[1] << 16) | ((u32)buf[2]\n\t\t\t\t\t\t\t<< 8) | buf[3];\n\n\trtsx_writel(chip, addr, val);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int set_variable(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned int lun = SCSI_LUN(srb);\n\n\tif (srb->cmnd[3] == 1) {\n\t\t \n\t\tstruct xd_info *xd_card = &chip->xd_card;\n\t\tstruct sd_info *sd_card = &chip->sd_card;\n\t\tstruct ms_info *ms_card = &chip->ms_card;\n\n\t\tswitch (srb->cmnd[4]) {\n\t\tcase XD_CARD:\n\t\t\txd_card->xd_clock = srb->cmnd[5];\n\t\t\tbreak;\n\n\t\tcase SD_CARD:\n\t\t\tsd_card->sd_clock = srb->cmnd[5];\n\t\t\tbreak;\n\n\t\tcase MS_CARD:\n\t\t\tms_card->ms_clock = srb->cmnd[5];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t} else if (srb->cmnd[3] == 2) {\n\t\tif (srb->cmnd[4]) {\n\t\t\tchip->blink_led = 1;\n\t\t} else {\n\t\t\tint retval;\n\n\t\t\tchip->blink_led = 0;\n\n\t\t\trtsx_disable_aspm(chip);\n\n\t\t\tif (chip->ss_en &&\n\t\t\t    (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\t\t\trtsx_exit_ss(chip);\n\t\t\t\twait_timeout(100);\n\t\t\t}\n\t\t\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\t\t\tretval = rtsx_force_power_on(chip, SSC_PDCTL);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\t\treturn TRANSPORT_FAILED;\n\t\t\t}\n\n\t\t\tturn_off_led(chip, LED_GPIO);\n\t\t}\n\t} else {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int get_variable(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned int lun = SCSI_LUN(srb);\n\n\tif (srb->cmnd[3] == 1) {\n\t\tstruct xd_info *xd_card = &chip->xd_card;\n\t\tstruct sd_info *sd_card = &chip->sd_card;\n\t\tstruct ms_info *ms_card = &chip->ms_card;\n\t\tu8 tmp;\n\n\t\tswitch (srb->cmnd[4]) {\n\t\tcase XD_CARD:\n\t\t\ttmp = (u8)(xd_card->xd_clock);\n\t\t\tbreak;\n\n\t\tcase SD_CARD:\n\t\t\ttmp = (u8)(sd_card->sd_clock);\n\t\t\tbreak;\n\n\t\tcase MS_CARD:\n\t\t\ttmp = (u8)(ms_card->ms_clock);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\n\t\trtsx_stor_set_xfer_buf(&tmp, 1, srb);\n\t} else if (srb->cmnd[3] == 2) {\n\t\tu8 tmp = chip->blink_led;\n\n\t\trtsx_stor_set_xfer_buf(&tmp, 1, srb);\n\t} else {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int dma_access_ring_buffer(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval;\n\tunsigned int lun = SCSI_LUN(srb);\n\tu16 len;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\tlen = ((u16)(srb->cmnd[4]) << 8) | srb->cmnd[5];\n\tlen = min_t(u16, len, scsi_bufflen(srb));\n\n\tif (srb->sc_data_direction == DMA_FROM_DEVICE)\n\t\tdev_dbg(rtsx_dev(chip), \"Read from device\\n\");\n\telse\n\t\tdev_dbg(rtsx_dev(chip), \"Write to device\\n\");\n\n\tretval = rtsx_transfer_data(chip, 0, scsi_sglist(srb), len,\n\t\t\t\t    scsi_sg_count(srb), srb->sc_data_direction,\n\t\t\t\t    1000);\n\tif (retval < 0) {\n\t\tif (srb->sc_data_direction == DMA_FROM_DEVICE)\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\telse\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\n\t\treturn TRANSPORT_FAILED;\n\t}\n\tscsi_set_resid(srb, 0);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int get_dev_status(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct sd_info *sd_card = &chip->sd_card;\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tint buf_len;\n\tunsigned int lun = SCSI_LUN(srb);\n\tu8 card = get_lun_card(chip, lun);\n\tu8 status[32];\n#ifdef SUPPORT_OCP\n\tu8 oc_now_mask = 0, oc_ever_mask = 0;\n#endif\n\n\tmemset(status, 0, 32);\n\n\tstatus[0] = (u8)(chip->product_id);\n\tstatus[1] = chip->ic_version;\n\n\tif (chip->auto_delink_en)\n\t\tstatus[2] = 0x10;\n\telse\n\t\tstatus[2] = 0x00;\n\n\tstatus[3] = 20;\n\tstatus[4] = 10;\n\tstatus[5] = 05;\n\tstatus[6] = 21;\n\n\tif (chip->card_wp)\n\t\tstatus[7] = 0x20;\n\telse\n\t\tstatus[7] = 0x00;\n\n#ifdef SUPPORT_OCP\n\tstatus[8] = 0;\n\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN) &&\n\t    chip->lun2card[lun] == MS_CARD) {\n\t\toc_now_mask = MS_OC_NOW;\n\t\toc_ever_mask = MS_OC_EVER;\n\t} else {\n\t\toc_now_mask = SD_OC_NOW;\n\t\toc_ever_mask = SD_OC_EVER;\n\t}\n\n\tif (chip->ocp_stat & oc_now_mask)\n\t\tstatus[8] |= 0x02;\n\n\tif (chip->ocp_stat & oc_ever_mask)\n\t\tstatus[8] |= 0x01;\n#endif\n\n\tif (card == SD_CARD) {\n\t\tif (CHK_SD(sd_card)) {\n\t\t\tif (CHK_SD_HCXC(sd_card)) {\n\t\t\t\tif (sd_card->capacity > 0x4000000)\n\t\t\t\t\tstatus[0x0E] = 0x02;\n\t\t\t\telse\n\t\t\t\t\tstatus[0x0E] = 0x01;\n\t\t\t} else {\n\t\t\t\tstatus[0x0E] = 0x00;\n\t\t\t}\n\n\t\t\tif (CHK_SD_SDR104(sd_card))\n\t\t\t\tstatus[0x0F] = 0x03;\n\t\t\telse if (CHK_SD_DDR50(sd_card))\n\t\t\t\tstatus[0x0F] = 0x04;\n\t\t\telse if (CHK_SD_SDR50(sd_card))\n\t\t\t\tstatus[0x0F] = 0x02;\n\t\t\telse if (CHK_SD_HS(sd_card))\n\t\t\t\tstatus[0x0F] = 0x01;\n\t\t\telse\n\t\t\t\tstatus[0x0F] = 0x00;\n\t\t} else {\n\t\t\tif (CHK_MMC_SECTOR_MODE(sd_card))\n\t\t\t\tstatus[0x0E] = 0x01;\n\t\t\telse\n\t\t\t\tstatus[0x0E] = 0x00;\n\n\t\t\tif (CHK_MMC_DDR52(sd_card))\n\t\t\t\tstatus[0x0F] = 0x03;\n\t\t\telse if (CHK_MMC_52M(sd_card))\n\t\t\t\tstatus[0x0F] = 0x02;\n\t\t\telse if (CHK_MMC_26M(sd_card))\n\t\t\t\tstatus[0x0F] = 0x01;\n\t\t\telse\n\t\t\t\tstatus[0x0F] = 0x00;\n\t\t}\n\t} else if (card == MS_CARD) {\n\t\tif (CHK_MSPRO(ms_card)) {\n\t\t\tif (CHK_MSXC(ms_card))\n\t\t\t\tstatus[0x0E] = 0x01;\n\t\t\telse\n\t\t\t\tstatus[0x0E] = 0x00;\n\n\t\t\tif (CHK_HG8BIT(ms_card))\n\t\t\t\tstatus[0x0F] = 0x01;\n\t\t\telse\n\t\t\t\tstatus[0x0F] = 0x00;\n\t\t}\n\t}\n\n#ifdef SUPPORT_SD_LOCK\n\tif (card == SD_CARD) {\n\t\tstatus[0x17] = 0x80;\n\t\tif (sd_card->sd_erase_status)\n\t\t\tstatus[0x17] |= 0x01;\n\t\tif (sd_card->sd_lock_status & SD_LOCKED) {\n\t\t\tstatus[0x17] |= 0x02;\n\t\t\tstatus[0x07] |= 0x40;\n\t\t}\n\t\tif (sd_card->sd_lock_status & SD_PWD_EXIST)\n\t\t\tstatus[0x17] |= 0x04;\n\t} else {\n\t\tstatus[0x17] = 0x00;\n\t}\n\n\tdev_dbg(rtsx_dev(chip), \"status[0x17] = 0x%x\\n\", status[0x17]);\n#endif\n\n\tstatus[0x18] = 0x8A;\n\tstatus[0x1A] = 0x28;\n#ifdef SUPPORT_SD_LOCK\n\tstatus[0x1F] = 0x01;\n#endif\n\n\tbuf_len = min_t(unsigned int, scsi_bufflen(srb), sizeof(status));\n\trtsx_stor_set_xfer_buf(status, buf_len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - buf_len);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int set_chip_mode(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint phy_debug_mode;\n\tint retval;\n\tu16 reg;\n\n\tif (!CHECK_PID(chip, 0x5208)) {\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tphy_debug_mode = (int)(srb->cmnd[3]);\n\n\tif (phy_debug_mode) {\n\t\tchip->phy_debug_mode = 1;\n\t\tretval = rtsx_write_register(chip, CDRESUMECTL, 0x77, 0);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn TRANSPORT_FAILED;\n\n\t\trtsx_disable_bus_int(chip);\n\n\t\tretval = rtsx_read_phy_register(chip, 0x1C, &reg);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn TRANSPORT_FAILED;\n\n\t\treg |= 0x0001;\n\t\tretval = rtsx_write_phy_register(chip, 0x1C, reg);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn TRANSPORT_FAILED;\n\t} else {\n\t\tchip->phy_debug_mode = 0;\n\t\tretval = rtsx_write_register(chip, CDRESUMECTL, 0x77, 0x77);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn TRANSPORT_FAILED;\n\n\t\trtsx_enable_bus_int(chip);\n\n\t\tretval = rtsx_read_phy_register(chip, 0x1C, &reg);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn TRANSPORT_FAILED;\n\n\t\treg &= 0xFFFE;\n\t\tretval = rtsx_write_phy_register(chip, 0x1C, reg);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn TRANSPORT_FAILED;\n\t}\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int rw_mem_cmd_buf(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval =  STATUS_SUCCESS;\n\tunsigned int lun = SCSI_LUN(srb);\n\tu8 cmd_type, mask, value, idx;\n\tu16 addr;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\tswitch (srb->cmnd[3]) {\n\tcase INIT_BATCHCMD:\n\t\trtsx_init_cmd(chip);\n\t\tbreak;\n\n\tcase ADD_BATCHCMD:\n\t\tcmd_type = srb->cmnd[4];\n\t\tif (cmd_type > 2) {\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t\taddr = (srb->cmnd[5] << 8) | srb->cmnd[6];\n\t\tmask = srb->cmnd[7];\n\t\tvalue = srb->cmnd[8];\n\t\trtsx_add_cmd(chip, cmd_type, addr, mask, value);\n\t\tbreak;\n\n\tcase SEND_BATCHCMD:\n\t\tretval = rtsx_send_cmd(chip, 0, 1000);\n\t\tbreak;\n\n\tcase GET_BATCHRSP:\n\t\tidx = srb->cmnd[4];\n\t\tvalue = *(rtsx_get_cmd_data(chip) + idx);\n\t\tif (scsi_bufflen(srb) < 1) {\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t\trtsx_stor_set_xfer_buf(&value, 1, srb);\n\t\tscsi_set_resid(srb, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int suit_cmd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tswitch (srb->cmnd[3]) {\n\tcase INIT_BATCHCMD:\n\tcase ADD_BATCHCMD:\n\tcase SEND_BATCHCMD:\n\tcase GET_BATCHRSP:\n\t\treturn rw_mem_cmd_buf(srb, chip);\n\tdefault:\n\t\treturn TRANSPORT_ERROR;\n\t}\n}\n\nstatic int read_phy_register(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned short addr, len, i;\n\tint retval;\n\tu8 *buf;\n\tu16 val;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\taddr = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\n\tlen = ((u16)srb->cmnd[6] << 8) | srb->cmnd[7];\n\n\tif (len % 2)\n\t\tlen -= len % 2;\n\n\tif (len) {\n\t\tbuf = vmalloc(len);\n\t\tif (!buf)\n\t\t\treturn TRANSPORT_ERROR;\n\n\t\tretval = rtsx_force_power_on(chip, SSC_PDCTL);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(buf);\n\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\n\t\tfor (i = 0; i < len / 2; i++) {\n\t\t\tretval = rtsx_read_phy_register(chip, addr + i, &val);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tvfree(buf);\n\t\t\t\tset_sense_type\n\t\t\t\t\t(chip, SCSI_LUN(srb),\n\t\t\t\t\t SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\t\t\treturn TRANSPORT_FAILED;\n\t\t\t}\n\n\t\t\tbuf[2 * i] = (u8)(val >> 8);\n\t\t\tbuf[2 * i + 1] = (u8)val;\n\t\t}\n\n\t\tlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb),\n\t\t\t\t\tlen);\n\t\trtsx_stor_set_xfer_buf(buf, len, srb);\n\t\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\t\tvfree(buf);\n\t}\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int write_phy_register(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned short addr, len, i;\n\tint retval;\n\tu8 *buf;\n\tu16 val;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\taddr = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\n\tlen = ((u16)srb->cmnd[6] << 8) | srb->cmnd[7];\n\n\tif (len % 2)\n\t\tlen -= len % 2;\n\n\tif (len) {\n\t\tlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb),\n\t\t\t\t\tlen);\n\n\t\tbuf = vmalloc(len);\n\t\tif (!buf)\n\t\t\treturn TRANSPORT_ERROR;\n\n\t\trtsx_stor_get_xfer_buf(buf, len, srb);\n\t\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\t\tretval = rtsx_force_power_on(chip, SSC_PDCTL);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(buf);\n\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\n\t\tfor (i = 0; i < len / 2; i++) {\n\t\t\tval = ((u16)buf[2 * i] << 8) | buf[2 * i + 1];\n\t\t\tretval = rtsx_write_phy_register(chip, addr + i, val);\n\t\t\tif (retval != STATUS_SUCCESS) {\n\t\t\t\tvfree(buf);\n\t\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\t\treturn TRANSPORT_FAILED;\n\t\t\t}\n\t\t}\n\n\t\tvfree(buf);\n\t}\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int erase_eeprom2(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned short addr;\n\tint retval;\n\tu8 mode;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\tretval = rtsx_force_power_on(chip, SSC_PDCTL);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tmode = srb->cmnd[3];\n\taddr = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\n\n\tif (mode == 0) {\n\t\tretval = spi_erase_eeprom_chip(chip);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t} else if (mode == 1) {\n\t\tretval = spi_erase_eeprom_byte(chip, addr);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t} else {\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int read_eeprom2(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned short addr, len, i;\n\tint retval;\n\tu8 *buf;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\taddr = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\n\tlen = ((u16)srb->cmnd[6] << 8) | srb->cmnd[7];\n\n\tbuf = vmalloc(len);\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\tretval = rtsx_force_power_on(chip, SSC_PDCTL);\n\tif (retval != STATUS_SUCCESS) {\n\t\tvfree(buf);\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tretval = spi_read_eeprom(chip, addr + i, buf + i);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(buf);\n\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t}\n\n\tlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb), len);\n\trtsx_stor_set_xfer_buf(buf, len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\tvfree(buf);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int write_eeprom2(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned short addr, len, i;\n\tint retval;\n\tu8 *buf;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\taddr = ((u16)srb->cmnd[4] << 8) | srb->cmnd[5];\n\tlen = ((u16)srb->cmnd[6] << 8) | srb->cmnd[7];\n\n\tlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb), len);\n\tbuf = vmalloc(len);\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\trtsx_stor_get_xfer_buf(buf, len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\tretval = rtsx_force_power_on(chip, SSC_PDCTL);\n\tif (retval != STATUS_SUCCESS) {\n\t\tvfree(buf);\n\t\tset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tretval = spi_write_eeprom(chip, addr + i, buf[i]);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(buf);\n\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t}\n\n\tvfree(buf);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int read_efuse(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval;\n\tu8 addr, len, i;\n\tu8 *buf;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\taddr = srb->cmnd[4];\n\tlen = srb->cmnd[5];\n\n\tbuf = vmalloc(len);\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\tretval = rtsx_force_power_on(chip, SSC_PDCTL);\n\tif (retval != STATUS_SUCCESS) {\n\t\tvfree(buf);\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tretval = rtsx_read_efuse(chip, addr + i, buf + i);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(buf);\n\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t}\n\n\tlen = (u8)min_t(unsigned int, scsi_bufflen(srb), len);\n\trtsx_stor_set_xfer_buf(buf, len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\tvfree(buf);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int write_efuse(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval, result = TRANSPORT_GOOD;\n\tu16 val;\n\tu8 addr, len, i;\n\tu8 *buf;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\taddr = srb->cmnd[4];\n\tlen = srb->cmnd[5];\n\n\tlen = (u8)min_t(unsigned int, scsi_bufflen(srb), len);\n\tbuf = vmalloc(len);\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\trtsx_stor_get_xfer_buf(buf, len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\tretval = rtsx_force_power_on(chip, SSC_PDCTL);\n\tif (retval != STATUS_SUCCESS) {\n\t\tvfree(buf);\n\t\treturn TRANSPORT_ERROR;\n\t}\n\n\tif (chip->asic_code) {\n\t\tretval = rtsx_read_phy_register(chip, 0x08, &val);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(buf);\n\t\t\treturn TRANSPORT_ERROR;\n\t\t}\n\n\t\tretval = rtsx_write_register(chip, PWR_GATE_CTRL,\n\t\t\t\t\t     LDO3318_PWR_MASK, LDO_OFF);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(buf);\n\t\t\treturn TRANSPORT_ERROR;\n\t\t}\n\n\t\twait_timeout(600);\n\n\t\tretval = rtsx_write_phy_register(chip, 0x08,\n\t\t\t\t\t\t 0x4C00 | chip->phy_voltage);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(buf);\n\t\t\treturn TRANSPORT_ERROR;\n\t\t}\n\n\t\tretval = rtsx_write_register(chip, PWR_GATE_CTRL,\n\t\t\t\t\t     LDO3318_PWR_MASK, LDO_ON);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tvfree(buf);\n\t\t\treturn TRANSPORT_ERROR;\n\t\t}\n\n\t\twait_timeout(600);\n\t}\n\n\tretval = card_power_on(chip, SPI_CARD);\n\tif (retval != STATUS_SUCCESS) {\n\t\tvfree(buf);\n\t\treturn TRANSPORT_ERROR;\n\t}\n\n\twait_timeout(50);\n\n\tfor (i = 0; i < len; i++) {\n\t\tretval = rtsx_write_efuse(chip, addr + i, buf[i]);\n\t\tif (retval != STATUS_SUCCESS) {\n\t\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t\t       SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\t\tresult = TRANSPORT_FAILED;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\tvfree(buf);\n\n\tretval = card_power_off(chip, SPI_CARD);\n\tif (retval != STATUS_SUCCESS)\n\t\treturn TRANSPORT_ERROR;\n\n\tif (chip->asic_code) {\n\t\tretval = rtsx_write_register(chip, PWR_GATE_CTRL,\n\t\t\t\t\t     LDO3318_PWR_MASK, LDO_OFF);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn TRANSPORT_ERROR;\n\n\t\twait_timeout(600);\n\n\t\tretval = rtsx_write_phy_register(chip, 0x08, val);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn TRANSPORT_ERROR;\n\n\t\tretval = rtsx_write_register(chip, PWR_GATE_CTRL,\n\t\t\t\t\t     LDO3318_PWR_MASK, LDO_ON);\n\t\tif (retval != STATUS_SUCCESS)\n\t\t\treturn TRANSPORT_ERROR;\n\t}\n\n\treturn result;\n}\n\nstatic int read_cfg_byte(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval;\n\tbool func_max;\n\tu8 func;\n\tu16 addr, len;\n\tu8 *buf;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\tfunc = srb->cmnd[3];\n\taddr = ((u16)(srb->cmnd[4]) << 8) | srb->cmnd[5];\n\tlen = ((u16)(srb->cmnd[6]) << 8) | srb->cmnd[7];\n\n\tdev_dbg(rtsx_dev(chip), \"%s: func = %d, addr = 0x%x, len = %d\\n\",\n\t\t__func__, func, addr, len);\n\n\tif (CHK_SDIO_EXIST(chip) && !CHK_SDIO_IGNORED(chip))\n\t\tfunc_max = true;\n\telse\n\t\tfunc_max = false;\n\n\tif (func > func_max) {\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tbuf = vmalloc(len);\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\tretval = rtsx_read_cfg_seq(chip, func, addr, buf, len);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\tvfree(buf);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tlen = (u16)min_t(unsigned int, scsi_bufflen(srb), len);\n\trtsx_stor_set_xfer_buf(buf, len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\tvfree(buf);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int write_cfg_byte(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval;\n\tbool func_max;\n\tu8 func;\n\tu16 addr, len;\n\tu8 *buf;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\tfunc = srb->cmnd[3];\n\taddr = ((u16)(srb->cmnd[4]) << 8) | srb->cmnd[5];\n\tlen = ((u16)(srb->cmnd[6]) << 8) | srb->cmnd[7];\n\n\tdev_dbg(rtsx_dev(chip), \"%s: func = %d, addr = 0x%x\\n\",\n\t\t__func__, func, addr);\n\n\tif (CHK_SDIO_EXIST(chip) && !CHK_SDIO_IGNORED(chip))\n\t\tfunc_max = true;\n\telse\n\t\tfunc_max = false;\n\n\tif (func > func_max) {\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tlen = (unsigned short)min_t(unsigned int, scsi_bufflen(srb), len);\n\tbuf = vmalloc(len);\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\trtsx_stor_get_xfer_buf(buf, len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - len);\n\n\tretval = rtsx_write_cfg_seq(chip, func, addr, buf, len);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, SCSI_LUN(srb), SENSE_TYPE_MEDIA_WRITE_ERR);\n\t\tvfree(buf);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tvfree(buf);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int app_cmd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint result;\n\n\tswitch (srb->cmnd[2]) {\n\tcase PP_READ10:\n\tcase PP_WRITE10:\n\t\tresult = read_write(srb, chip);\n\t\tbreak;\n\n\tcase READ_HOST_REG:\n\t\tresult = read_host_reg(srb, chip);\n\t\tbreak;\n\n\tcase WRITE_HOST_REG:\n\t\tresult = write_host_reg(srb, chip);\n\t\tbreak;\n\n\tcase GET_VAR:\n\t\tresult = get_variable(srb, chip);\n\t\tbreak;\n\n\tcase SET_VAR:\n\t\tresult = set_variable(srb, chip);\n\t\tbreak;\n\n\tcase DMA_READ:\n\tcase DMA_WRITE:\n\t\tresult = dma_access_ring_buffer(srb, chip);\n\t\tbreak;\n\n\tcase READ_PHY:\n\t\tresult = read_phy_register(srb, chip);\n\t\tbreak;\n\n\tcase WRITE_PHY:\n\t\tresult = write_phy_register(srb, chip);\n\t\tbreak;\n\n\tcase ERASE_EEPROM2:\n\t\tresult = erase_eeprom2(srb, chip);\n\t\tbreak;\n\n\tcase READ_EEPROM2:\n\t\tresult = read_eeprom2(srb, chip);\n\t\tbreak;\n\n\tcase WRITE_EEPROM2:\n\t\tresult = write_eeprom2(srb, chip);\n\t\tbreak;\n\n\tcase READ_EFUSE:\n\t\tresult = read_efuse(srb, chip);\n\t\tbreak;\n\n\tcase WRITE_EFUSE:\n\t\tresult = write_efuse(srb, chip);\n\t\tbreak;\n\n\tcase READ_CFG:\n\t\tresult = read_cfg_byte(srb, chip);\n\t\tbreak;\n\n\tcase WRITE_CFG:\n\t\tresult = write_cfg_byte(srb, chip);\n\t\tbreak;\n\n\tcase SET_CHIP_MODE:\n\t\tresult = set_chip_mode(srb, chip);\n\t\tbreak;\n\n\tcase SUIT_CMD:\n\t\tresult = suit_cmd(srb, chip);\n\t\tbreak;\n\n\tcase GET_DEV_STATUS:\n\t\tresult = get_dev_status(srb, chip);\n\t\tbreak;\n\n\tdefault:\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\treturn result;\n}\n\nstatic int read_status(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tu8 rtsx_status[16];\n\tint buf_len;\n\tunsigned int lun = SCSI_LUN(srb);\n\n\trtsx_status[0] = (u8)(chip->vendor_id >> 8);\n\trtsx_status[1] = (u8)(chip->vendor_id);\n\n\trtsx_status[2] = (u8)(chip->product_id >> 8);\n\trtsx_status[3] = (u8)(chip->product_id);\n\n\trtsx_status[4] = (u8)lun;\n\n\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\n\t\tif (chip->lun2card[lun] == SD_CARD)\n\t\t\trtsx_status[5] = 2;\n\t\telse\n\t\t\trtsx_status[5] = 3;\n\t} else {\n\t\tif (chip->card_exist) {\n\t\t\tif (chip->card_exist & XD_CARD)\n\t\t\t\trtsx_status[5] = 4;\n\t\t\telse if (chip->card_exist & SD_CARD)\n\t\t\t\trtsx_status[5] = 2;\n\t\t\telse if (chip->card_exist & MS_CARD)\n\t\t\t\trtsx_status[5] = 3;\n\t\t\telse\n\t\t\t\trtsx_status[5] = 7;\n\t\t} else {\n\t\t\trtsx_status[5] = 7;\n\t\t}\n\t}\n\n\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN))\n\t\trtsx_status[6] = 2;\n\telse\n\t\trtsx_status[6] = 1;\n\n\trtsx_status[7] = (u8)(chip->product_id);\n\trtsx_status[8] = chip->ic_version;\n\n\tif (check_card_exist(chip, lun))\n\t\trtsx_status[9] = 1;\n\telse\n\t\trtsx_status[9] = 0;\n\n\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN))\n\t\trtsx_status[10] = 0;\n\telse\n\t\trtsx_status[10] = 1;\n\n\tif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\n\t\tif (chip->lun2card[lun] == SD_CARD)\n\t\t\trtsx_status[11] = SD_CARD;\n\t\telse\n\t\t\trtsx_status[11] = MS_CARD;\n\t} else {\n\t\trtsx_status[11] = XD_CARD | SD_CARD | MS_CARD;\n\t}\n\n\tif (check_card_ready(chip, lun))\n\t\trtsx_status[12] = 1;\n\telse\n\t\trtsx_status[12] = 0;\n\n\tif (get_lun_card(chip, lun) == XD_CARD) {\n\t\trtsx_status[13] = 0x40;\n\t} else if (get_lun_card(chip, lun) == SD_CARD) {\n\t\tstruct sd_info *sd_card = &chip->sd_card;\n\n\t\trtsx_status[13] = 0x20;\n\t\tif (CHK_SD(sd_card)) {\n\t\t\tif (CHK_SD_HCXC(sd_card))\n\t\t\t\trtsx_status[13] |= 0x04;\n\t\t\tif (CHK_SD_HS(sd_card))\n\t\t\t\trtsx_status[13] |= 0x02;\n\t\t} else {\n\t\t\trtsx_status[13] |= 0x08;\n\t\t\tif (CHK_MMC_52M(sd_card))\n\t\t\t\trtsx_status[13] |= 0x02;\n\t\t\tif (CHK_MMC_SECTOR_MODE(sd_card))\n\t\t\t\trtsx_status[13] |= 0x04;\n\t\t}\n\t} else if (get_lun_card(chip, lun) == MS_CARD) {\n\t\tstruct ms_info *ms_card = &chip->ms_card;\n\n\t\tif (CHK_MSPRO(ms_card)) {\n\t\t\trtsx_status[13] = 0x38;\n\t\t\tif (CHK_HG8BIT(ms_card))\n\t\t\t\trtsx_status[13] |= 0x04;\n#ifdef SUPPORT_MSXC\n\t\t\tif (CHK_MSXC(ms_card))\n\t\t\t\trtsx_status[13] |= 0x01;\n#endif\n\t\t} else {\n\t\t\trtsx_status[13] = 0x30;\n\t\t}\n\t} else {\n\t\tif (CHECK_LUN_MODE(chip, DEFAULT_SINGLE)) {\n#ifdef SUPPORT_SDIO\n\t\t\tif (chip->sd_io && chip->sd_int)\n\t\t\t\trtsx_status[13] = 0x60;\n\t\t\telse\n\t\t\t\trtsx_status[13] = 0x70;\n#else\n\t\t\trtsx_status[13] = 0x70;\n#endif\n\t\t} else {\n\t\t\tif (chip->lun2card[lun] == SD_CARD)\n\t\t\t\trtsx_status[13] = 0x20;\n\t\t\telse\n\t\t\t\trtsx_status[13] = 0x30;\n\t\t}\n\t}\n\n\trtsx_status[14] = 0x78;\n\tif (CHK_SDIO_EXIST(chip) && !CHK_SDIO_IGNORED(chip))\n\t\trtsx_status[15] = 0x83;\n\telse\n\t\trtsx_status[15] = 0x82;\n\n\tbuf_len = min_t(unsigned int, scsi_bufflen(srb), sizeof(rtsx_status));\n\trtsx_stor_set_xfer_buf(rtsx_status, buf_len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - buf_len);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int get_card_bus_width(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned int lun = SCSI_LUN(srb);\n\tu8 card, bus_width;\n\n\tif (!check_card_ready(chip, lun)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tcard = get_lun_card(chip, lun);\n\tif (card == SD_CARD || card == MS_CARD) {\n\t\tbus_width = chip->card_bus_width[lun];\n\t} else {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tscsi_set_resid(srb, 0);\n\trtsx_stor_set_xfer_buf(&bus_width, scsi_bufflen(srb), srb);\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int spi_vendor_cmd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint result;\n\tunsigned int lun = SCSI_LUN(srb);\n\tu8 gpio_dir;\n\n\tif (CHECK_PID(chip, 0x5208) || CHECK_PID(chip, 0x5288)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\trtsx_force_power_on(chip, SSC_PDCTL);\n\n\trtsx_read_register(chip, CARD_GPIO_DIR, &gpio_dir);\n\trtsx_write_register(chip, CARD_GPIO_DIR, 0x07, gpio_dir & 0x06);\n\n\tswitch (srb->cmnd[2]) {\n\tcase SCSI_SPI_GETSTATUS:\n\t\tresult = spi_get_status(srb, chip);\n\t\tbreak;\n\n\tcase SCSI_SPI_SETPARAMETER:\n\t\tresult = spi_set_parameter(srb, chip);\n\t\tbreak;\n\n\tcase SCSI_SPI_READFALSHID:\n\t\tresult = spi_read_flash_id(srb, chip);\n\t\tbreak;\n\n\tcase SCSI_SPI_READFLASH:\n\t\tresult = spi_read_flash(srb, chip);\n\t\tbreak;\n\n\tcase SCSI_SPI_WRITEFLASH:\n\t\tresult = spi_write_flash(srb, chip);\n\t\tbreak;\n\n\tcase SCSI_SPI_WRITEFLASHSTATUS:\n\t\tresult = spi_write_flash_status(srb, chip);\n\t\tbreak;\n\n\tcase SCSI_SPI_ERASEFLASH:\n\t\tresult = spi_erase_flash(srb, chip);\n\t\tbreak;\n\n\tdefault:\n\t\trtsx_write_register(chip, CARD_GPIO_DIR, 0x07, gpio_dir);\n\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\trtsx_write_register(chip, CARD_GPIO_DIR, 0x07, gpio_dir);\n\n\tif (result != STATUS_SUCCESS)\n\t\treturn TRANSPORT_FAILED;\n\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int vendor_cmnd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint result;\n\n\tswitch (srb->cmnd[1]) {\n\tcase READ_STATUS:\n\t\tresult = read_status(srb, chip);\n\t\tbreak;\n\n\tcase READ_MEM:\n\t\tresult = read_mem(srb, chip);\n\t\tbreak;\n\n\tcase WRITE_MEM:\n\t\tresult = write_mem(srb, chip);\n\t\tbreak;\n\n\tcase READ_EEPROM:\n\t\tresult = read_eeprom(srb, chip);\n\t\tbreak;\n\n\tcase WRITE_EEPROM:\n\t\tresult = write_eeprom(srb, chip);\n\t\tbreak;\n\n\tcase TOGGLE_GPIO:\n\t\tresult = toggle_gpio_cmd(srb, chip);\n\t\tbreak;\n\n\tcase GET_SD_CSD:\n\t\tresult = get_sd_csd(srb, chip);\n\t\tbreak;\n\n\tcase GET_BUS_WIDTH:\n\t\tresult = get_card_bus_width(srb, chip);\n\t\tbreak;\n\n\tcase SCSI_APP_CMD:\n\t\tresult = app_cmd(srb, chip);\n\t\tbreak;\n\n\tcase SPI_VENDOR_COMMAND:\n\t\tresult = spi_vendor_cmd(srb, chip);\n\t\tbreak;\n\n\tdefault:\n\t\tset_sense_type(chip, SCSI_LUN(srb),\n\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\treturn result;\n}\n\n#if !defined(LED_AUTO_BLINK) && !defined(REGULAR_BLINK)\nvoid led_shine(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned int lun = SCSI_LUN(srb);\n\tu16 sec_cnt;\n\n\tif (srb->cmnd[0] == READ_10 || srb->cmnd[0] == WRITE_10) {\n\t\tsec_cnt = ((u16)(srb->cmnd[7]) << 8) | srb->cmnd[8];\n\t} else if ((srb->cmnd[0] == READ_6) || (srb->cmnd[0] == WRITE_6)) {\n\t\tsec_cnt = srb->cmnd[4];\n\t\tif (sec_cnt == 0)\n\t\t\tsec_cnt = 256;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (chip->rw_cap[lun] >= GPIO_TOGGLE_THRESHOLD) {\n\t\ttoggle_gpio(chip, LED_GPIO);\n\t\tchip->rw_cap[lun] = 0;\n\t} else {\n\t\tchip->rw_cap[lun] += sec_cnt;\n\t}\n}\n#endif\n\nstatic int ms_format_cmnd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tunsigned int lun = SCSI_LUN(srb);\n\tbool quick_format;\n\tint retval;\n\n\tif (get_lun_card(chip, lun) != MS_CARD) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (srb->cmnd[3] != 0x4D || srb->cmnd[4] != 0x47 ||\n\t    srb->cmnd[5] != 0x66 || srb->cmnd[6] != 0x6D ||\n\t\tsrb->cmnd[7] != 0x74) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\n\t\tif (!check_card_ready(chip, lun) ||\n\t\t    (get_card_size(chip, lun) == 0)) {\n\t\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\tif (srb->cmnd[8] & 0x01)\n\t\tquick_format = false;\n\telse\n\t\tquick_format = true;\n\n\tif (!(chip->card_ready & MS_CARD)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (chip->card_wp & MS_CARD) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_WRITE_PROTECT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (!CHK_MSPRO(ms_card)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tretval = mspro_format(srb, chip, MS_SHORT_DATA_LEN, quick_format);\n\tif (retval != STATUS_SUCCESS) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_FORMAT_CMD_FAILED);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tscsi_set_resid(srb, 0);\n\treturn TRANSPORT_GOOD;\n}\n\n#ifdef SUPPORT_PCGL_1P18\nstatic int get_ms_information(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tunsigned int lun = SCSI_LUN(srb);\n\tu8 dev_info_id, data_len;\n\tu8 *buf;\n\tunsigned int buf_len;\n\tint i;\n\n\tif (!check_card_ready(chip, lun)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\tif (get_lun_card(chip, lun) != MS_CARD) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (srb->cmnd[2] != 0xB0 || srb->cmnd[4] != 0x4D ||\n\t    srb->cmnd[5] != 0x53 || srb->cmnd[6] != 0x49 ||\n\t    srb->cmnd[7] != 0x44) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tdev_info_id = srb->cmnd[3];\n\tif ((CHK_MSXC(ms_card) && dev_info_id == 0x10) ||\n\t    (!CHK_MSXC(ms_card) && dev_info_id == 0x13) ||\n\t    !CHK_MSPRO(ms_card)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (dev_info_id == 0x15) {\n\t\tbuf_len = 0x3C;\n\t\tdata_len = 0x3A;\n\t} else {\n\t\tbuf_len = 0x6C;\n\t\tdata_len = 0x6A;\n\t}\n\n\tbuf = kmalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn TRANSPORT_ERROR;\n\n\ti = 0;\n\t \n\tbuf[i++] = 0x00;\t\t \n\tbuf[i++] = data_len;\t\t \n\t \n\tif (CHK_MSXC(ms_card))\n\t\tbuf[i++] = 0x03;\n\telse\n\t\tbuf[i++] = 0x02;\n\n\t \n\tbuf[i++] = 0x01;\n\t \n\tbuf[i++] = 0x00;\n\tbuf[i++] = 0x00;\n\tbuf[i++] = 0x00;\n\t \n\tbuf[i++] = 0x01;\n\n\t \n\n\t \n\tbuf[i++] = dev_info_id;\n\t \n\tif (dev_info_id == 0x15)\n\t\tdata_len = 0x31;\n\telse\n\t\tdata_len = 0x61;\n\n\tbuf[i++] = 0x00;\t\t \n\tbuf[i++] = data_len;\t\t \n\t \n\tbuf[i++] = 0x80;\n\tif (dev_info_id == 0x10 || dev_info_id == 0x13) {\n\t\t \n\t\tmemcpy(buf + i, ms_card->raw_sys_info, 96);\n\t} else {\n\t\t \n\t\tmemcpy(buf + i, ms_card->raw_model_name, 48);\n\t}\n\n\trtsx_stor_set_xfer_buf(buf, buf_len, srb);\n\tscsi_set_resid(srb, scsi_bufflen(srb) - buf_len);\n\n\tkfree(buf);\n\treturn STATUS_SUCCESS;\n}\n#endif\n\nstatic int ms_sp_cmnd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tint retval = TRANSPORT_ERROR;\n\n\tif (srb->cmnd[2] == MS_FORMAT)\n\t\tretval = ms_format_cmnd(srb, chip);\n#ifdef SUPPORT_PCGL_1P18\n\telse if (srb->cmnd[2] == GET_MS_INFORMATION)\n\t\tretval = get_ms_information(srb, chip);\n#endif\n\n\treturn retval;\n}\n\n#ifdef SUPPORT_CPRM\nstatic int sd_extension_cmnd(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tunsigned int lun = SCSI_LUN(srb);\n\tint result;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\tsd_cleanup_work(chip);\n\n\tif (!check_card_ready(chip, lun)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\tif (get_lun_card(chip, lun) != SD_CARD) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tswitch (srb->cmnd[0]) {\n\tcase SD_PASS_THRU_MODE:\n\t\tresult = sd_pass_thru_mode(srb, chip);\n\t\tbreak;\n\n\tcase SD_EXECUTE_NO_DATA:\n\t\tresult = sd_execute_no_data(srb, chip);\n\t\tbreak;\n\n\tcase SD_EXECUTE_READ:\n\t\tresult = sd_execute_read_data(srb, chip);\n\t\tbreak;\n\n\tcase SD_EXECUTE_WRITE:\n\t\tresult = sd_execute_write_data(srb, chip);\n\t\tbreak;\n\n\tcase SD_GET_RSP:\n\t\tresult = sd_get_cmd_rsp(srb, chip);\n\t\tbreak;\n\n\tcase SD_HW_RST:\n\t\tresult = sd_hw_rst(srb, chip);\n\t\tbreak;\n\n\tdefault:\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\treturn result;\n}\n#endif\n\n#ifdef SUPPORT_MAGIC_GATE\nstatic int mg_report_key(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tunsigned int lun = SCSI_LUN(srb);\n\tint retval;\n\tu8 key_format;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\tms_cleanup_work(chip);\n\n\tif (!check_card_ready(chip, lun)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\tif (get_lun_card(chip, lun) != MS_CARD) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (srb->cmnd[7] != KC_MG_R_PRO) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (!CHK_MSPRO(ms_card)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_INCOMPATIBLE_MEDIUM);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tkey_format = srb->cmnd[10] & 0x3F;\n\tdev_dbg(rtsx_dev(chip), \"key_format = 0x%x\\n\", key_format);\n\n\tswitch (key_format) {\n\tcase KF_GET_LOC_EKB:\n\t\tif ((scsi_bufflen(srb) == 0x41C) &&\n\t\t    srb->cmnd[8] == 0x04 &&\n\t\t    srb->cmnd[9] == 0x1C) {\n\t\t\tretval = mg_get_local_EKB(srb, chip);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn TRANSPORT_FAILED;\n\n\t\t} else {\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t\tbreak;\n\n\tcase KF_RSP_CHG:\n\t\tif ((scsi_bufflen(srb) == 0x24) &&\n\t\t    srb->cmnd[8] == 0x00 &&\n\t\t    srb->cmnd[9] == 0x24) {\n\t\t\tretval = mg_get_rsp_chg(srb, chip);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn TRANSPORT_FAILED;\n\n\t\t} else {\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t\tbreak;\n\n\tcase KF_GET_ICV:\n\t\tms_card->mg_entry_num = srb->cmnd[5];\n\t\tif ((scsi_bufflen(srb) == 0x404) &&\n\t\t    srb->cmnd[8] == 0x04 &&\n\t\t    srb->cmnd[9] == 0x04 &&\n\t\t    srb->cmnd[2] == 0x00 &&\n\t\t    srb->cmnd[3] == 0x00 &&\n\t\t    srb->cmnd[4] == 0x00 &&\n\t\t    srb->cmnd[5] < 32) {\n\t\t\tretval = mg_get_ICV(srb, chip);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn TRANSPORT_FAILED;\n\n\t\t} else {\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tscsi_set_resid(srb, 0);\n\treturn TRANSPORT_GOOD;\n}\n\nstatic int mg_send_key(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tunsigned int lun = SCSI_LUN(srb);\n\tint retval;\n\tu8 key_format;\n\n\trtsx_disable_aspm(chip);\n\n\tif (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {\n\t\trtsx_exit_ss(chip);\n\t\twait_timeout(100);\n\t}\n\trtsx_set_stat(chip, RTSX_STAT_RUN);\n\n\tms_cleanup_work(chip);\n\n\tif (!check_card_ready(chip, lun)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\tif (check_card_wp(chip, lun)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_WRITE_PROTECT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\tif (get_lun_card(chip, lun) != MS_CARD) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_LUN_NOT_SUPPORT);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (srb->cmnd[7] != KC_MG_R_PRO) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tif (!CHK_MSPRO(ms_card)) {\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MG_INCOMPATIBLE_MEDIUM);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tkey_format = srb->cmnd[10] & 0x3F;\n\tdev_dbg(rtsx_dev(chip), \"key_format = 0x%x\\n\", key_format);\n\n\tswitch (key_format) {\n\tcase KF_SET_LEAF_ID:\n\t\tif ((scsi_bufflen(srb) == 0x0C) &&\n\t\t    srb->cmnd[8] == 0x00 &&\n\t\t    srb->cmnd[9] == 0x0C) {\n\t\t\tretval = mg_set_leaf_id(srb, chip);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn TRANSPORT_FAILED;\n\n\t\t} else {\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t\tbreak;\n\n\tcase KF_CHG_HOST:\n\t\tif ((scsi_bufflen(srb) == 0x0C) &&\n\t\t    srb->cmnd[8] == 0x00 &&\n\t\t    srb->cmnd[9] == 0x0C) {\n\t\t\tretval = mg_chg(srb, chip);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn TRANSPORT_FAILED;\n\n\t\t} else {\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t\tbreak;\n\n\tcase KF_RSP_HOST:\n\t\tif ((scsi_bufflen(srb) == 0x0C) &&\n\t\t    srb->cmnd[8] == 0x00 &&\n\t\t    srb->cmnd[9] == 0x0C) {\n\t\t\tretval = mg_rsp(srb, chip);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn TRANSPORT_FAILED;\n\n\t\t} else {\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t\tbreak;\n\n\tcase KF_SET_ICV:\n\t\tms_card->mg_entry_num = srb->cmnd[5];\n\t\tif ((scsi_bufflen(srb) == 0x404) &&\n\t\t    srb->cmnd[8] == 0x04 &&\n\t\t    srb->cmnd[9] == 0x04 &&\n\t\t    srb->cmnd[2] == 0x00 &&\n\t\t    srb->cmnd[3] == 0x00 &&\n\t\t    srb->cmnd[4] == 0x00 &&\n\t\t    srb->cmnd[5] < 32) {\n\t\t\tretval = mg_set_ICV(srb, chip);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\treturn TRANSPORT_FAILED;\n\n\t\t} else {\n\t\t\tset_sense_type(chip, lun,\n\t\t\t\t       SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\treturn TRANSPORT_FAILED;\n\t}\n\n\tscsi_set_resid(srb, 0);\n\treturn TRANSPORT_GOOD;\n}\n#endif\n\nint rtsx_scsi_handler(struct scsi_cmnd *srb, struct rtsx_chip *chip)\n{\n#ifdef SUPPORT_SD_LOCK\n\tstruct sd_info *sd_card = &chip->sd_card;\n#endif\n\tstruct ms_info *ms_card = &chip->ms_card;\n\tunsigned int lun = SCSI_LUN(srb);\n\tint result;\n\n#ifdef SUPPORT_SD_LOCK\n\tif (sd_card->sd_erase_status) {\n\t\t \n\t\tif (!(srb->cmnd[0] == VENDOR_CMND &&\n\t\t      srb->cmnd[1] == SCSI_APP_CMD &&\n\t\t      srb->cmnd[2] == GET_DEV_STATUS) &&\n\t\t\tsrb->cmnd[0] != REQUEST_SENSE) {\n\t\t\t \n\t\t\tset_sense_data(chip, lun, CUR_ERR,\n\t\t\t\t       0x02, 0, 0x04, 0x04, 0, 0);\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t}\n#endif\n\n\tif ((get_lun_card(chip, lun) == MS_CARD) &&\n\t    ms_card->format_status == FORMAT_IN_PROGRESS) {\n\t\tif (srb->cmnd[0] != REQUEST_SENSE &&\n\t\t    srb->cmnd[0] != INQUIRY) {\n\t\t\t \n\t\t\tset_sense_data(chip, lun, CUR_ERR, 0x02, 0, 0x04, 0x04,\n\t\t\t\t       0, (u16)(ms_card->progress));\n\t\t\treturn TRANSPORT_FAILED;\n\t\t}\n\t}\n\n\tswitch (srb->cmnd[0]) {\n\tcase READ_10:\n\tcase WRITE_10:\n\tcase READ_6:\n\tcase WRITE_6:\n\t\tresult = read_write(srb, chip);\n#if !defined(LED_AUTO_BLINK) && !defined(REGULAR_BLINK)\n\t\tled_shine(srb, chip);\n#endif\n\t\tbreak;\n\n\tcase TEST_UNIT_READY:\n\t\tresult = test_unit_ready(srb, chip);\n\t\tbreak;\n\n\tcase INQUIRY:\n\t\tresult = inquiry(srb, chip);\n\t\tbreak;\n\n\tcase READ_CAPACITY:\n\t\tresult = read_capacity(srb, chip);\n\t\tbreak;\n\n\tcase START_STOP:\n\t\tresult = start_stop_unit(srb, chip);\n\t\tbreak;\n\n\tcase ALLOW_MEDIUM_REMOVAL:\n\t\tresult = allow_medium_removal(srb, chip);\n\t\tbreak;\n\n\tcase REQUEST_SENSE:\n\t\tresult = request_sense(srb, chip);\n\t\tbreak;\n\n\tcase MODE_SENSE:\n\tcase MODE_SENSE_10:\n\t\tresult = mode_sense(srb, chip);\n\t\tbreak;\n\n\tcase 0x23:\n\t\tresult = read_format_capacity(srb, chip);\n\t\tbreak;\n\n\tcase VENDOR_CMND:\n\t\tresult = vendor_cmnd(srb, chip);\n\t\tbreak;\n\n\tcase MS_SP_CMND:\n\t\tresult = ms_sp_cmnd(srb, chip);\n\t\tbreak;\n\n#ifdef SUPPORT_CPRM\n\tcase SD_PASS_THRU_MODE:\n\tcase SD_EXECUTE_NO_DATA:\n\tcase SD_EXECUTE_READ:\n\tcase SD_EXECUTE_WRITE:\n\tcase SD_GET_RSP:\n\tcase SD_HW_RST:\n\t\tresult = sd_extension_cmnd(srb, chip);\n\t\tbreak;\n#endif\n\n#ifdef SUPPORT_MAGIC_GATE\n\tcase CMD_MSPRO_MG_RKEY:\n\t\tresult = mg_report_key(srb, chip);\n\t\tbreak;\n\n\tcase CMD_MSPRO_MG_SKEY:\n\t\tresult = mg_send_key(srb, chip);\n\t\tbreak;\n#endif\n\n\tcase FORMAT_UNIT:\n\tcase MODE_SELECT:\n\tcase VERIFY:\n\t\tresult = TRANSPORT_GOOD;\n\t\tbreak;\n\n\tdefault:\n\t\tset_sense_type(chip, lun, SENSE_TYPE_MEDIA_INVALID_CMD_FIELD);\n\t\tresult = TRANSPORT_FAILED;\n\t}\n\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}