{
  "module_name": "olpc_dcon.c",
  "hash_id": "a11b9819a14e0b8bd6499c1df3f2953203fe89f3db690e8f32b8792eae7b2fc9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/olpc_dcon/olpc_dcon.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/fb.h>\n#include <linux/console.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/backlight.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/ctype.h>\n#include <linux/panic_notifier.h>\n#include <linux/reboot.h>\n#include <linux/olpc-ec.h>\n#include <asm/tsc.h>\n#include <asm/olpc.h>\n\n#include \"olpc_dcon.h\"\n\n \n\nstatic ushort resumeline = 898;\nmodule_param(resumeline, ushort, 0444);\n\nstatic struct dcon_platform_data *pdata;\n\n \n\n \nstatic struct platform_device *dcon_device;\n\nstatic unsigned short normal_i2c[] = { 0x0d, I2C_CLIENT_END };\n\nstatic s32 dcon_write(struct dcon_priv *dcon, u8 reg, u16 val)\n{\n\treturn i2c_smbus_write_word_data(dcon->client, reg, val);\n}\n\nstatic s32 dcon_read(struct dcon_priv *dcon, u8 reg)\n{\n\treturn i2c_smbus_read_word_data(dcon->client, reg);\n}\n\n \n\nstatic int dcon_hw_init(struct dcon_priv *dcon, int is_init)\n{\n\tu16 ver;\n\tint rc = 0;\n\n\tver = dcon_read(dcon, DCON_REG_ID);\n\tif ((ver >> 8) != 0xDC) {\n\t\tpr_err(\"DCON ID not 0xDCxx: 0x%04x instead.\\n\", ver);\n\t\trc = -ENXIO;\n\t\tgoto err;\n\t}\n\n\tif (is_init) {\n\t\tpr_info(\"Discovered DCON version %x\\n\", ver & 0xFF);\n\t\trc = pdata->init(dcon);\n\t\tif (rc != 0) {\n\t\t\tpr_err(\"Unable to init.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (ver < 0xdc02) {\n\t\tdev_err(&dcon->client->dev,\n\t\t\t\"DCON v1 is unsupported, giving up..\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tdcon_write(dcon, 0x3a, 0xc040);\n\tdcon_write(dcon, DCON_REG_MEM_OPT_A, 0x0000);   \n\tdcon_write(dcon, DCON_REG_MEM_OPT_A,\n\t\t   MEM_DLL_CLOCK_DELAY | MEM_POWER_DOWN);\n\tdcon_write(dcon, DCON_REG_MEM_OPT_B, MEM_SOFT_RESET);\n\n\t \n\tif (is_init) {\n\t\tdcon->disp_mode = MODE_PASSTHRU | MODE_BL_ENABLE |\n\t\t\t\tMODE_CSWIZZLE | MODE_COL_AA;\n\t}\n\tdcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);\n\n\t \n\tdcon_write(dcon, DCON_REG_SCAN_INT, resumeline);\n\nerr:\n\treturn rc;\n}\n\n \nstatic int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)\n{\n\tunsigned long timeout;\n\tu8 pm;\n\tint x;\n\npower_up:\n\tif (is_powered_down) {\n\t\tpm = 1;\n\t\tx = olpc_ec_cmd(EC_DCON_POWER_MODE, &pm, 1, NULL, 0);\n\t\tif (x) {\n\t\t\tpr_warn(\"unable to force dcon to power up: %d!\\n\", x);\n\t\t\treturn x;\n\t\t}\n\t\tusleep_range(10000, 11000);   \n\t}\n\n\tpdata->bus_stabilize_wiggle();\n\n\tfor (x = -1, timeout = 50; timeout && x < 0; timeout--) {\n\t\tusleep_range(1000, 1100);\n\t\tx = dcon_read(dcon, DCON_REG_ID);\n\t}\n\tif (x < 0) {\n\t\tpr_err(\"unable to stabilize dcon's smbus, reasserting power and praying.\\n\");\n\t\tBUG_ON(olpc_board_at_least(olpc_board(0xc2)));\n\t\tpm = 0;\n\t\tolpc_ec_cmd(EC_DCON_POWER_MODE, &pm, 1, NULL, 0);\n\t\tmsleep(100);\n\t\tis_powered_down = 1;\n\t\tgoto power_up;\t \n\t}\n\n\tif (is_powered_down)\n\t\treturn dcon_hw_init(dcon, 0);\n\treturn 0;\n}\n\nstatic void dcon_set_backlight(struct dcon_priv *dcon, u8 level)\n{\n\tdcon->bl_val = level;\n\tdcon_write(dcon, DCON_REG_BRIGHT, dcon->bl_val);\n\n\t \n\tif (dcon->bl_val == 0) {\n\t\tdcon->disp_mode &= ~MODE_BL_ENABLE;\n\t\tdcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);\n\t} else if (!(dcon->disp_mode & MODE_BL_ENABLE)) {\n\t\tdcon->disp_mode |= MODE_BL_ENABLE;\n\t\tdcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);\n\t}\n}\n\n \nstatic int dcon_set_mono_mode(struct dcon_priv *dcon, bool enable_mono)\n{\n\tif (dcon->mono == enable_mono)\n\t\treturn 0;\n\n\tdcon->mono = enable_mono;\n\n\tif (enable_mono) {\n\t\tdcon->disp_mode &= ~(MODE_CSWIZZLE | MODE_COL_AA);\n\t\tdcon->disp_mode |= MODE_MONO_LUMA;\n\t} else {\n\t\tdcon->disp_mode &= ~(MODE_MONO_LUMA);\n\t\tdcon->disp_mode |= MODE_CSWIZZLE | MODE_COL_AA;\n\t}\n\n\tdcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);\n\treturn 0;\n}\n\n \n\nstatic void dcon_sleep(struct dcon_priv *dcon, bool sleep)\n{\n\tint x;\n\n\t \n\n\tif (dcon->asleep == sleep)\n\t\treturn;\n\n\tif (!olpc_board_at_least(olpc_board(0xc2)))\n\t\treturn;\n\n\tif (sleep) {\n\t\tu8 pm = 0;\n\n\t\tx = olpc_ec_cmd(EC_DCON_POWER_MODE, &pm, 1, NULL, 0);\n\t\tif (x)\n\t\t\tpr_warn(\"unable to force dcon to power down: %d!\\n\", x);\n\t\telse\n\t\t\tdcon->asleep = sleep;\n\t} else {\n\t\t \n\t\tif (dcon->bl_val != 0)\n\t\t\tdcon->disp_mode |= MODE_BL_ENABLE;\n\t\tx = dcon_bus_stabilize(dcon, 1);\n\t\tif (x)\n\t\t\tpr_warn(\"unable to reinit dcon hardware: %d!\\n\", x);\n\t\telse\n\t\t\tdcon->asleep = sleep;\n\n\t\t \n\t\tdcon_set_backlight(dcon, dcon->bl_val);\n\t}\n\n\t \n}\n\n \nstatic void dcon_load_holdoff(struct dcon_priv *dcon)\n{\n\tktime_t delta_t, now;\n\n\twhile (1) {\n\t\tnow = ktime_get();\n\t\tdelta_t = ktime_sub(now, dcon->load_time);\n\t\tif (ktime_to_ns(delta_t) > NSEC_PER_MSEC * 20)\n\t\t\tbreak;\n\t\tmdelay(4);\n\t}\n}\n\nstatic bool dcon_blank_fb(struct dcon_priv *dcon, bool blank)\n{\n\tint err;\n\n\tconsole_lock();\n\tlock_fb_info(dcon->fbinfo);\n\n\tdcon->ignore_fb_events = true;\n\terr = fb_blank(dcon->fbinfo,\n\t\t       blank ? FB_BLANK_POWERDOWN : FB_BLANK_UNBLANK);\n\tdcon->ignore_fb_events = false;\n\tunlock_fb_info(dcon->fbinfo);\n\tconsole_unlock();\n\n\tif (err) {\n\t\tdev_err(&dcon->client->dev, \"couldn't %sblank framebuffer\\n\",\n\t\t\tblank ? \"\" : \"un\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic void dcon_source_switch(struct work_struct *work)\n{\n\tstruct dcon_priv *dcon = container_of(work, struct dcon_priv,\n\t\t\tswitch_source);\n\tint source = dcon->pending_src;\n\n\tif (dcon->curr_src == source)\n\t\treturn;\n\n\tdcon_load_holdoff(dcon);\n\n\tdcon->switched = false;\n\n\tswitch (source) {\n\tcase DCON_SOURCE_CPU:\n\t\tpr_info(\"%s to CPU\\n\", __func__);\n\t\t \n\t\tif (dcon_write(dcon, DCON_REG_MODE,\n\t\t\t       dcon->disp_mode | MODE_SCAN_INT))\n\t\t\tpr_err(\"couldn't enable scanline interrupt!\\n\");\n\t\telse\n\t\t\t \n\t\t\twait_event_timeout(dcon->waitq, dcon->switched, HZ);\n\n\t\tif (!dcon->switched)\n\t\t\tpr_err(\"Timeout entering CPU mode; expect a screen glitch.\\n\");\n\n\t\t \n\t\tif (dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode))\n\t\t\tpr_err(\"couldn't disable scanline interrupt!\\n\");\n\n\t\t \n\t\tif (!dcon_blank_fb(dcon, false)) {\n\t\t\tpr_err(\"Failed to enter CPU mode\\n\");\n\t\t\tdcon->pending_src = DCON_SOURCE_DCON;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tpdata->set_dconload(1);\n\t\tdcon->load_time = ktime_get();\n\n\t\tpr_info(\"The CPU has control\\n\");\n\t\tbreak;\n\tcase DCON_SOURCE_DCON:\n\t{\n\t\tktime_t delta_t;\n\n\t\tpr_info(\"%s to DCON\\n\", __func__);\n\n\t\t \n\t\tpdata->set_dconload(0);\n\t\tdcon->load_time = ktime_get();\n\n\t\twait_event_timeout(dcon->waitq, dcon->switched, HZ / 2);\n\n\t\tif (!dcon->switched) {\n\t\t\tpr_err(\"Timeout entering DCON mode; expect a screen glitch.\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tdelta_t = ktime_sub(dcon->irq_time, dcon->load_time);\n\t\t\tif (dcon->switched && ktime_to_ns(delta_t)\n\t\t\t    < NSEC_PER_MSEC * 20) {\n\t\t\t\tpr_err(\"missed loading, retrying\\n\");\n\t\t\t\tpdata->set_dconload(1);\n\t\t\t\tmdelay(41);\n\t\t\t\tpdata->set_dconload(0);\n\t\t\t\tdcon->load_time = ktime_get();\n\t\t\t\tmdelay(41);\n\t\t\t}\n\t\t}\n\n\t\tdcon_blank_fb(dcon, true);\n\t\tpr_info(\"The DCON has control\\n\");\n\t\tbreak;\n\t}\n\tdefault:\n\t\tBUG();\n\t}\n\n\tdcon->curr_src = source;\n}\n\nstatic void dcon_set_source(struct dcon_priv *dcon, int arg)\n{\n\tif (dcon->pending_src == arg)\n\t\treturn;\n\n\tdcon->pending_src = arg;\n\n\tif (dcon->curr_src != arg)\n\t\tschedule_work(&dcon->switch_source);\n}\n\nstatic void dcon_set_source_sync(struct dcon_priv *dcon, int arg)\n{\n\tdcon_set_source(dcon, arg);\n\tflush_work(&dcon->switch_source);\n}\n\nstatic ssize_t dcon_mode_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct dcon_priv *dcon = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%4.4X\\n\", dcon->disp_mode);\n}\n\nstatic ssize_t dcon_sleep_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct dcon_priv *dcon = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", dcon->asleep);\n}\n\nstatic ssize_t dcon_freeze_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct dcon_priv *dcon = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", dcon->curr_src == DCON_SOURCE_DCON ? 1 : 0);\n}\n\nstatic ssize_t dcon_mono_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct dcon_priv *dcon = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", dcon->mono);\n}\n\nstatic ssize_t dcon_resumeline_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", resumeline);\n}\n\nstatic ssize_t dcon_mono_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tunsigned long enable_mono;\n\tint rc;\n\n\trc = kstrtoul(buf, 10, &enable_mono);\n\tif (rc)\n\t\treturn rc;\n\n\tdcon_set_mono_mode(dev_get_drvdata(dev), enable_mono ? true : false);\n\n\treturn count;\n}\n\nstatic ssize_t dcon_freeze_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct dcon_priv *dcon = dev_get_drvdata(dev);\n\tunsigned long output;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &output);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (output) {\n\tcase 0:\n\t\tdcon_set_source(dcon, DCON_SOURCE_CPU);\n\t\tbreak;\n\tcase 1:\n\t\tdcon_set_source_sync(dcon, DCON_SOURCE_DCON);\n\t\tbreak;\n\tcase 2:   \n\t\tdcon_set_source(dcon, DCON_SOURCE_DCON);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t dcon_resumeline_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tunsigned short rl;\n\tint rc;\n\n\trc = kstrtou16(buf, 10, &rl);\n\tif (rc)\n\t\treturn rc;\n\n\tresumeline = rl;\n\tdcon_write(dev_get_drvdata(dev), DCON_REG_SCAN_INT, resumeline);\n\n\treturn count;\n}\n\nstatic ssize_t dcon_sleep_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tunsigned long output;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &output);\n\tif (ret)\n\t\treturn ret;\n\n\tdcon_sleep(dev_get_drvdata(dev), output ? true : false);\n\treturn count;\n}\n\nstatic struct device_attribute dcon_device_files[] = {\n\t__ATTR(mode, 0444, dcon_mode_show, NULL),\n\t__ATTR(sleep, 0644, dcon_sleep_show, dcon_sleep_store),\n\t__ATTR(freeze, 0644, dcon_freeze_show, dcon_freeze_store),\n\t__ATTR(monochrome, 0644, dcon_mono_show, dcon_mono_store),\n\t__ATTR(resumeline, 0644, dcon_resumeline_show, dcon_resumeline_store),\n};\n\nstatic int dcon_bl_update(struct backlight_device *dev)\n{\n\tstruct dcon_priv *dcon = bl_get_data(dev);\n\tu8 level = backlight_get_brightness(dev) & 0x0F;\n\n\tif (level != dcon->bl_val)\n\t\tdcon_set_backlight(dcon, level);\n\n\t \n\tif (!dcon->ignore_fb_events)\n\t\tdcon_sleep(dcon, !!(dev->props.state & BL_CORE_FBBLANK));\n\n\treturn 0;\n}\n\nstatic int dcon_bl_get(struct backlight_device *dev)\n{\n\tstruct dcon_priv *dcon = bl_get_data(dev);\n\n\treturn dcon->bl_val;\n}\n\nstatic const struct backlight_ops dcon_bl_ops = {\n\t.update_status = dcon_bl_update,\n\t.get_brightness = dcon_bl_get,\n};\n\nstatic struct backlight_properties dcon_bl_props = {\n\t.max_brightness = 15,\n\t.type = BACKLIGHT_RAW,\n\t.power = FB_BLANK_UNBLANK,\n};\n\nstatic int dcon_reboot_notify(struct notifier_block *nb,\n\t\t\t      unsigned long foo, void *bar)\n{\n\tstruct dcon_priv *dcon = container_of(nb, struct dcon_priv, reboot_nb);\n\n\tif (!dcon || !dcon->client)\n\t\treturn NOTIFY_DONE;\n\n\t \n\tdcon_write(dcon, DCON_REG_MODE, 0x39);\n\tdcon_write(dcon, DCON_REG_MODE, 0x32);\n\treturn NOTIFY_DONE;\n}\n\nstatic int unfreeze_on_panic(struct notifier_block *nb,\n\t\t\t     unsigned long e, void *p)\n{\n\tpdata->set_dconload(1);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block dcon_panic_nb = {\n\t.notifier_call = unfreeze_on_panic,\n};\n\nstatic int dcon_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tstrscpy(info->type, \"olpc_dcon\", I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int dcon_probe(struct i2c_client *client)\n{\n\tstruct dcon_priv *dcon;\n\tint rc, i, j;\n\n\tif (!pdata)\n\t\treturn -ENXIO;\n\n\tdcon = kzalloc(sizeof(*dcon), GFP_KERNEL);\n\tif (!dcon)\n\t\treturn -ENOMEM;\n\n\tdcon->client = client;\n\tinit_waitqueue_head(&dcon->waitq);\n\tINIT_WORK(&dcon->switch_source, dcon_source_switch);\n\tdcon->reboot_nb.notifier_call = dcon_reboot_notify;\n\tdcon->reboot_nb.priority = -1;\n\n\ti2c_set_clientdata(client, dcon);\n\n\tif (num_registered_fb < 1) {\n\t\tdev_err(&client->dev, \"DCON driver requires a registered fb\\n\");\n\t\trc = -EIO;\n\t\tgoto einit;\n\t}\n\tdcon->fbinfo = registered_fb[0];\n\n\trc = dcon_hw_init(dcon, 1);\n\tif (rc)\n\t\tgoto einit;\n\n\t \n\n\tdcon_device = platform_device_alloc(\"dcon\", -1);\n\n\tif (!dcon_device) {\n\t\tpr_err(\"Unable to create the DCON device\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto eirq;\n\t}\n\trc = platform_device_add(dcon_device);\n\tplatform_set_drvdata(dcon_device, dcon);\n\n\tif (rc) {\n\t\tpr_err(\"Unable to add the DCON device\\n\");\n\t\tgoto edev;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(dcon_device_files); i++) {\n\t\trc = device_create_file(&dcon_device->dev,\n\t\t\t\t\t&dcon_device_files[i]);\n\t\tif (rc) {\n\t\t\tdev_err(&dcon_device->dev, \"Cannot create sysfs file\\n\");\n\t\t\tgoto ecreate;\n\t\t}\n\t}\n\n\tdcon->bl_val = dcon_read(dcon, DCON_REG_BRIGHT) & 0x0F;\n\n\t \n\tdcon_bl_props.brightness = dcon->bl_val;\n\tdcon->bl_dev = backlight_device_register(\"dcon-bl\", &dcon_device->dev,\n\t\t\t\t\t\t dcon, &dcon_bl_ops,\n\t\t\t\t\t\t &dcon_bl_props);\n\tif (IS_ERR(dcon->bl_dev)) {\n\t\tdev_err(&client->dev, \"cannot register backlight dev (%ld)\\n\",\n\t\t\tPTR_ERR(dcon->bl_dev));\n\t\tdcon->bl_dev = NULL;\n\t}\n\n\tregister_reboot_notifier(&dcon->reboot_nb);\n\tatomic_notifier_chain_register(&panic_notifier_list, &dcon_panic_nb);\n\n\treturn 0;\n\n ecreate:\n\tfor (j = 0; j < i; j++)\n\t\tdevice_remove_file(&dcon_device->dev, &dcon_device_files[j]);\n\tplatform_device_del(dcon_device);\n edev:\n\tplatform_device_put(dcon_device);\n\tdcon_device = NULL;\n eirq:\n\tfree_irq(DCON_IRQ, dcon);\n einit:\n\tkfree(dcon);\n\treturn rc;\n}\n\nstatic void dcon_remove(struct i2c_client *client)\n{\n\tstruct dcon_priv *dcon = i2c_get_clientdata(client);\n\n\tunregister_reboot_notifier(&dcon->reboot_nb);\n\tatomic_notifier_chain_unregister(&panic_notifier_list, &dcon_panic_nb);\n\n\tfree_irq(DCON_IRQ, dcon);\n\n\tbacklight_device_unregister(dcon->bl_dev);\n\n\tif (dcon_device)\n\t\tplatform_device_unregister(dcon_device);\n\tcancel_work_sync(&dcon->switch_source);\n\n\tkfree(dcon);\n}\n\n#ifdef CONFIG_PM\nstatic int dcon_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct dcon_priv *dcon = i2c_get_clientdata(client);\n\n\tif (!dcon->asleep) {\n\t\t \n\t\tdcon_set_source_sync(dcon, DCON_SOURCE_DCON);\n\t}\n\n\treturn 0;\n}\n\nstatic int dcon_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct dcon_priv *dcon = i2c_get_clientdata(client);\n\n\tif (!dcon->asleep) {\n\t\tdcon_bus_stabilize(dcon, 0);\n\t\tdcon_set_source(dcon, DCON_SOURCE_CPU);\n\t}\n\n\treturn 0;\n}\n\n#else\n\n#define dcon_suspend NULL\n#define dcon_resume NULL\n\n#endif  \n\nirqreturn_t dcon_interrupt(int irq, void *id)\n{\n\tstruct dcon_priv *dcon = id;\n\tu8 status;\n\n\tif (pdata->read_status(&status))\n\t\treturn IRQ_NONE;\n\n\tswitch (status & 3) {\n\tcase 3:\n\t\tpr_debug(\"DCONLOAD_MISSED interrupt\\n\");\n\t\tbreak;\n\n\tcase 2:\t \n\tcase 1:  \n\t\tdcon->switched = true;\n\t\tdcon->irq_time = ktime_get();\n\t\twake_up(&dcon->waitq);\n\t\tbreak;\n\n\tcase 0:\n\t\t \n\t\tif (dcon->curr_src != dcon->pending_src && !dcon->switched) {\n\t\t\tdcon->switched = true;\n\t\t\tdcon->irq_time = ktime_get();\n\t\t\twake_up(&dcon->waitq);\n\t\t\tpr_debug(\"switching w/ status 0/0\\n\");\n\t\t} else {\n\t\t\tpr_debug(\"scanline interrupt w/CPU\\n\");\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct dev_pm_ops dcon_pm_ops = {\n\t.suspend = dcon_suspend,\n\t.resume = dcon_resume,\n};\n\nstatic const struct i2c_device_id dcon_idtable[] = {\n\t{ \"olpc_dcon\",  0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, dcon_idtable);\n\nstatic struct i2c_driver dcon_driver = {\n\t.driver = {\n\t\t.name\t= \"olpc_dcon\",\n\t\t.pm = &dcon_pm_ops,\n\t},\n\t.class = I2C_CLASS_DDC | I2C_CLASS_HWMON,\n\t.id_table = dcon_idtable,\n\t.probe = dcon_probe,\n\t.remove = dcon_remove,\n\t.detect = dcon_detect,\n\t.address_list = normal_i2c,\n};\n\nstatic int __init olpc_dcon_init(void)\n{\n\t \n\tif (olpc_board_at_least(olpc_board(0xd0)))\n\t\tpdata = &dcon_pdata_xo_1_5;\n\telse\n\t\tpdata = &dcon_pdata_xo_1;\n\n\treturn i2c_add_driver(&dcon_driver);\n}\n\nstatic void __exit olpc_dcon_exit(void)\n{\n\ti2c_del_driver(&dcon_driver);\n}\n\nmodule_init(olpc_dcon_init);\nmodule_exit(olpc_dcon_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}