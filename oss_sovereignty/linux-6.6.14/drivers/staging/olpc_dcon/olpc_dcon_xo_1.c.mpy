{
  "module_name": "olpc_dcon_xo_1.c",
  "hash_id": "d02c67a9f46b2333b9f8021f83ba2428a9534a11609de27f869bcfcc9f877e51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/olpc_dcon/olpc_dcon_xo_1.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cs5535.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <asm/olpc.h>\n\n#include \"olpc_dcon.h\"\n\nenum dcon_gpios {\n\tOLPC_DCON_STAT0,\n\tOLPC_DCON_STAT1,\n\tOLPC_DCON_IRQ,\n\tOLPC_DCON_LOAD,\n\tOLPC_DCON_BLANK,\n};\n\nstatic const struct dcon_gpio gpios_asis[] = {\n\t[OLPC_DCON_STAT0] = { .name = \"dcon_stat0\", .flags = GPIOD_ASIS },\n\t[OLPC_DCON_STAT1] = { .name = \"dcon_stat1\", .flags = GPIOD_ASIS },\n\t[OLPC_DCON_IRQ] = { .name = \"dcon_irq\", .flags = GPIOD_ASIS },\n\t[OLPC_DCON_LOAD] = { .name = \"dcon_load\", .flags = GPIOD_ASIS },\n\t[OLPC_DCON_BLANK] = { .name = \"dcon_blank\", .flags = GPIOD_ASIS },\n};\n\nstatic struct gpio_desc *gpios[5];\n\nstatic int dcon_init_xo_1(struct dcon_priv *dcon)\n{\n\tunsigned char lob;\n\tint ret, i;\n\tconst struct dcon_gpio *pin = &gpios_asis[0];\n\n\tfor (i = 0; i < ARRAY_SIZE(gpios_asis); i++) {\n\t\tgpios[i] = devm_gpiod_get(&dcon->client->dev, pin[i].name,\n\t\t\t\t\t  pin[i].flags);\n\t\tif (IS_ERR(gpios[i])) {\n\t\t\tret = PTR_ERR(gpios[i]);\n\t\t\tpr_err(\"failed to request %s GPIO: %d\\n\", pin[i].name,\n\t\t\t       ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tcs5535_gpio_clear(OLPC_GPIO_DCON_IRQ, GPIO_EVENTS_ENABLE);\n\n\t \n\tdcon->curr_src = cs5535_gpio_isset(OLPC_GPIO_DCON_LOAD, GPIO_OUTPUT_VAL)\n\t\t? DCON_SOURCE_CPU\n\t\t: DCON_SOURCE_DCON;\n\tdcon->pending_src = dcon->curr_src;\n\n\t \n\tgpiod_direction_input(gpios[OLPC_DCON_STAT0]);\n\tgpiod_direction_input(gpios[OLPC_DCON_STAT1]);\n\tgpiod_direction_input(gpios[OLPC_DCON_IRQ]);\n\tgpiod_direction_input(gpios[OLPC_DCON_BLANK]);\n\tgpiod_direction_output(gpios[OLPC_DCON_LOAD],\n\t\t\t       dcon->curr_src == DCON_SOURCE_CPU);\n\n\t \n\n\t \n\tcs5535_gpio_setup_event(OLPC_GPIO_DCON_IRQ, 2, 0);\n\n\t \n\tcs5535_gpio_set_irq(2, DCON_IRQ);\n\n\t \n\tlob = inb(0x4d0);\n\tlob &= ~(1 << DCON_IRQ);\n\toutb(lob, 0x4d0);\n\n\t \n\tif (request_irq(DCON_IRQ, &dcon_interrupt, 0, \"DCON\", dcon)) {\n\t\tpr_err(\"failed to request DCON's irq\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tcs5535_gpio_clear(OLPC_GPIO_DCON_IRQ, GPIO_INPUT_INVERT);\n\n\t \n\tcs5535_gpio_set(OLPC_GPIO_DCON_BLANK, GPIO_INPUT_FILTER);\n\n\t \n\tcs5535_gpio_clear(OLPC_GPIO_DCON_IRQ, GPIO_INPUT_FILTER);\n\n\t \n\tcs5535_gpio_clear(OLPC_GPIO_DCON_IRQ, GPIO_INPUT_EVENT_COUNT);\n\tcs5535_gpio_clear(OLPC_GPIO_DCON_BLANK, GPIO_INPUT_EVENT_COUNT);\n\n\t \n\tcs5535_gpio_set(OLPC_GPIO_DCON_BLANK, GPIO_FE7_SEL);\n\n\t \n\tcs5535_gpio_clear(OLPC_GPIO_DCON_BLANK, GPIO_NEGATIVE_EDGE_EN);\n\n\t \n\tcs5535_gpio_set(OLPC_GPIO_DCON_IRQ, GPIO_NEGATIVE_EDGE_EN);\n\n\t \n\tcs5535_gpio_set(0, GPIO_FLTR7_AMOUNT);\n\n\t \n\tcs5535_gpio_set(OLPC_GPIO_DCON_IRQ, GPIO_NEGATIVE_EDGE_STS);\n\tcs5535_gpio_set(OLPC_GPIO_DCON_BLANK, GPIO_NEGATIVE_EDGE_STS);\n\n\t \n\tcs5535_gpio_set(OLPC_GPIO_DCON_IRQ, GPIO_POSITIVE_EDGE_STS);\n\tcs5535_gpio_set(OLPC_GPIO_DCON_BLANK, GPIO_POSITIVE_EDGE_STS);\n\n\t \n\tcs5535_gpio_set(OLPC_GPIO_DCON_IRQ, GPIO_EVENTS_ENABLE);\n\tcs5535_gpio_set(OLPC_GPIO_DCON_BLANK, GPIO_EVENTS_ENABLE);\n\n\treturn 0;\n}\n\nstatic void dcon_wiggle_xo_1(void)\n{\n\tint x;\n\n\t \n\tcs5535_gpio_set(OLPC_GPIO_SMB_CLK, GPIO_OUTPUT_VAL);\n\tcs5535_gpio_set(OLPC_GPIO_SMB_DATA, GPIO_OUTPUT_VAL);\n\tcs5535_gpio_set(OLPC_GPIO_SMB_CLK, GPIO_OUTPUT_ENABLE);\n\tcs5535_gpio_set(OLPC_GPIO_SMB_DATA, GPIO_OUTPUT_ENABLE);\n\tcs5535_gpio_clear(OLPC_GPIO_SMB_CLK, GPIO_OUTPUT_AUX1);\n\tcs5535_gpio_clear(OLPC_GPIO_SMB_DATA, GPIO_OUTPUT_AUX1);\n\tcs5535_gpio_clear(OLPC_GPIO_SMB_CLK, GPIO_OUTPUT_AUX2);\n\tcs5535_gpio_clear(OLPC_GPIO_SMB_DATA, GPIO_OUTPUT_AUX2);\n\tcs5535_gpio_clear(OLPC_GPIO_SMB_CLK, GPIO_INPUT_AUX1);\n\tcs5535_gpio_clear(OLPC_GPIO_SMB_DATA, GPIO_INPUT_AUX1);\n\n\tfor (x = 0; x < 16; x++) {\n\t\tudelay(5);\n\t\tcs5535_gpio_clear(OLPC_GPIO_SMB_CLK, GPIO_OUTPUT_VAL);\n\t\tudelay(5);\n\t\tcs5535_gpio_set(OLPC_GPIO_SMB_CLK, GPIO_OUTPUT_VAL);\n\t}\n\tudelay(5);\n\tcs5535_gpio_set(OLPC_GPIO_SMB_CLK, GPIO_OUTPUT_AUX1);\n\tcs5535_gpio_set(OLPC_GPIO_SMB_DATA, GPIO_OUTPUT_AUX1);\n\tcs5535_gpio_set(OLPC_GPIO_SMB_CLK, GPIO_INPUT_AUX1);\n\tcs5535_gpio_set(OLPC_GPIO_SMB_DATA, GPIO_INPUT_AUX1);\n}\n\nstatic void dcon_set_dconload_1(int val)\n{\n\tgpiod_set_value(gpios[OLPC_DCON_LOAD], val);\n}\n\nstatic int dcon_read_status_xo_1(u8 *status)\n{\n\t*status = gpiod_get_value(gpios[OLPC_DCON_STAT0]);\n\t*status |= gpiod_get_value(gpios[OLPC_DCON_STAT1]) << 1;\n\n\t \n\tcs5535_gpio_set(OLPC_GPIO_DCON_IRQ, GPIO_NEGATIVE_EDGE_STS);\n\n\treturn 0;\n}\n\nstruct dcon_platform_data dcon_pdata_xo_1 = {\n\t.init = dcon_init_xo_1,\n\t.bus_stabilize_wiggle = dcon_wiggle_xo_1,\n\t.set_dconload = dcon_set_dconload_1,\n\t.read_status = dcon_read_status_xo_1,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}