{
  "module_name": "nvec_power.c",
  "hash_id": "1ccfef3c370f5ed478eb789540eb4aab8f242d595f49df832a88f049dcabaf4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/nvec/nvec_power.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n\n#include \"nvec.h\"\n\n#define GET_SYSTEM_STATUS 0x00\n\nstruct nvec_power {\n\tstruct notifier_block notifier;\n\tstruct delayed_work poller;\n\tstruct nvec_chip *nvec;\n\tint on;\n\tint bat_present;\n\tint bat_status;\n\tint bat_voltage_now;\n\tint bat_current_now;\n\tint bat_current_avg;\n\tint time_remain;\n\tint charge_full_design;\n\tint charge_last_full;\n\tint critical_capacity;\n\tint capacity_remain;\n\tint bat_temperature;\n\tint bat_cap;\n\tint bat_type_enum;\n\tchar bat_manu[30];\n\tchar bat_model[30];\n\tchar bat_type[30];\n};\n\nenum {\n\tSLOT_STATUS,\n\tVOLTAGE,\n\tTIME_REMAINING,\n\tCURRENT,\n\tAVERAGE_CURRENT,\n\tAVERAGING_TIME_INTERVAL,\n\tCAPACITY_REMAINING,\n\tLAST_FULL_CHARGE_CAPACITY,\n\tDESIGN_CAPACITY,\n\tCRITICAL_CAPACITY,\n\tTEMPERATURE,\n\tMANUFACTURER,\n\tMODEL,\n\tTYPE,\n};\n\nenum {\n\tAC,\n\tBAT,\n};\n\nstruct bat_response {\n\tu8 event_type;\n\tu8 length;\n\tu8 sub_type;\n\tu8 status;\n\t \n\tunion {\n\t\tchar plc[30];\n\t\tu16 plu;\n\t\ts16 pls;\n\t};\n};\n\nstatic struct power_supply *nvec_bat_psy;\nstatic struct power_supply *nvec_psy;\n\nstatic int nvec_power_notifier(struct notifier_block *nb,\n\t\t\t       unsigned long event_type, void *data)\n{\n\tstruct nvec_power *power =\n\t    container_of(nb, struct nvec_power, notifier);\n\tstruct bat_response *res = data;\n\n\tif (event_type != NVEC_SYS)\n\t\treturn NOTIFY_DONE;\n\n\tif (res->sub_type == 0) {\n\t\tif (power->on != res->plu) {\n\t\t\tpower->on = res->plu;\n\t\t\tpower_supply_changed(nvec_psy);\n\t\t}\n\t\treturn NOTIFY_STOP;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic const int bat_init[] = {\n\tLAST_FULL_CHARGE_CAPACITY, DESIGN_CAPACITY, CRITICAL_CAPACITY,\n\tMANUFACTURER, MODEL, TYPE,\n};\n\nstatic void get_bat_mfg_data(struct nvec_power *power)\n{\n\tint i;\n\tchar buf[] = { NVEC_BAT, SLOT_STATUS };\n\n\tfor (i = 0; i < ARRAY_SIZE(bat_init); i++) {\n\t\tbuf[1] = bat_init[i];\n\t\tnvec_write_async(power->nvec, buf, 2);\n\t}\n}\n\nstatic int nvec_power_bat_notifier(struct notifier_block *nb,\n\t\t\t\t   unsigned long event_type, void *data)\n{\n\tstruct nvec_power *power =\n\t    container_of(nb, struct nvec_power, notifier);\n\tstruct bat_response *res = data;\n\tint status_changed = 0;\n\n\tif (event_type != NVEC_BAT)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (res->sub_type) {\n\tcase SLOT_STATUS:\n\t\tif (res->plc[0] & 1) {\n\t\t\tif (power->bat_present == 0) {\n\t\t\t\tstatus_changed = 1;\n\t\t\t\tget_bat_mfg_data(power);\n\t\t\t}\n\n\t\t\tpower->bat_present = 1;\n\n\t\t\tswitch ((res->plc[0] >> 1) & 3) {\n\t\t\tcase 0:\n\t\t\t\tpower->bat_status =\n\t\t\t\t    POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tpower->bat_status =\n\t\t\t\t    POWER_SUPPLY_STATUS_CHARGING;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tpower->bat_status =\n\t\t\t\t    POWER_SUPPLY_STATUS_DISCHARGING;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpower->bat_status = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\t\t}\n\t\t} else {\n\t\t\tif (power->bat_present == 1)\n\t\t\t\tstatus_changed = 1;\n\n\t\t\tpower->bat_present = 0;\n\t\t\tpower->bat_status = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\t}\n\t\tpower->bat_cap = res->plc[1];\n\t\tif (status_changed)\n\t\t\tpower_supply_changed(nvec_bat_psy);\n\t\tbreak;\n\tcase VOLTAGE:\n\t\tpower->bat_voltage_now = res->plu * 1000;\n\t\tbreak;\n\tcase TIME_REMAINING:\n\t\tpower->time_remain = res->plu * 3600;\n\t\tbreak;\n\tcase CURRENT:\n\t\tpower->bat_current_now = res->pls * 1000;\n\t\tbreak;\n\tcase AVERAGE_CURRENT:\n\t\tpower->bat_current_avg = res->pls * 1000;\n\t\tbreak;\n\tcase CAPACITY_REMAINING:\n\t\tpower->capacity_remain = res->plu * 1000;\n\t\tbreak;\n\tcase LAST_FULL_CHARGE_CAPACITY:\n\t\tpower->charge_last_full = res->plu * 1000;\n\t\tbreak;\n\tcase DESIGN_CAPACITY:\n\t\tpower->charge_full_design = res->plu * 1000;\n\t\tbreak;\n\tcase CRITICAL_CAPACITY:\n\t\tpower->critical_capacity = res->plu * 1000;\n\t\tbreak;\n\tcase TEMPERATURE:\n\t\tpower->bat_temperature = res->plu - 2732;\n\t\tbreak;\n\tcase MANUFACTURER:\n\t\tmemcpy(power->bat_manu, &res->plc, res->length - 2);\n\t\tpower->bat_model[res->length - 2] = '\\0';\n\t\tbreak;\n\tcase MODEL:\n\t\tmemcpy(power->bat_model, &res->plc, res->length - 2);\n\t\tpower->bat_model[res->length - 2] = '\\0';\n\t\tbreak;\n\tcase TYPE:\n\t\tmemcpy(power->bat_type, &res->plc, res->length - 2);\n\t\tpower->bat_type[res->length - 2] = '\\0';\n\t\t \n\t\tif (!strncmp(power->bat_type, \"Li\", 30))\n\t\t\tpower->bat_type_enum = POWER_SUPPLY_TECHNOLOGY_LION;\n\t\telse\n\t\t\tpower->bat_type_enum = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_STOP;\n\t}\n\n\treturn NOTIFY_STOP;\n}\n\nstatic int nvec_power_get_property(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tstruct nvec_power *power = dev_get_drvdata(psy->dev.parent);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = power->on;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int nvec_battery_get_property(struct power_supply *psy,\n\t\t\t\t     enum power_supply_property psp,\n\t\t\t\t     union power_supply_propval *val)\n{\n\tstruct nvec_power *power = dev_get_drvdata(psy->dev.parent);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = power->bat_status;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = power->bat_cap;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = power->bat_present;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = power->bat_voltage_now;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tval->intval = power->bat_current_now;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\tval->intval = power->bat_current_avg;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:\n\t\tval->intval = power->time_remain;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\tval->intval = power->charge_full_design;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\tval->intval = power->charge_last_full;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_EMPTY:\n\t\tval->intval = power->critical_capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tval->intval = power->capacity_remain;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tval->intval = power->bat_temperature;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = power->bat_manu;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = power->bat_model;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = power->bat_type_enum;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic enum power_supply_property nvec_power_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic enum power_supply_property nvec_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n#ifdef EC_FULL_DIAG\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,\n#endif\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_CHARGE_EMPTY,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n};\n\nstatic char *nvec_power_supplied_to[] = {\n\t\"battery\",\n};\n\nstatic const struct power_supply_desc nvec_bat_psy_desc = {\n\t.name = \"battery\",\n\t.type = POWER_SUPPLY_TYPE_BATTERY,\n\t.properties = nvec_battery_props,\n\t.num_properties = ARRAY_SIZE(nvec_battery_props),\n\t.get_property = nvec_battery_get_property,\n};\n\nstatic const struct power_supply_desc nvec_psy_desc = {\n\t.name = \"ac\",\n\t.type = POWER_SUPPLY_TYPE_MAINS,\n\t.properties = nvec_power_props,\n\t.num_properties = ARRAY_SIZE(nvec_power_props),\n\t.get_property = nvec_power_get_property,\n};\n\nstatic int counter;\nstatic const int bat_iter[] = {\n\tSLOT_STATUS, VOLTAGE, CURRENT, CAPACITY_REMAINING,\n#ifdef EC_FULL_DIAG\n\tAVERAGE_CURRENT, TEMPERATURE, TIME_REMAINING,\n#endif\n};\n\nstatic void nvec_power_poll(struct work_struct *work)\n{\n\tchar buf[] = { NVEC_SYS, GET_SYSTEM_STATUS };\n\tstruct nvec_power *power = container_of(work, struct nvec_power,\n\t\t\t\t\t\tpoller.work);\n\n\tif (counter >= ARRAY_SIZE(bat_iter))\n\t\tcounter = 0;\n\n\t \n\tnvec_write_async(power->nvec, buf, 2);\n\tmsleep(100);\n\n\t \n\tbuf[0] = NVEC_BAT;\n\tbuf[1] = bat_iter[counter++];\n\tnvec_write_async(power->nvec, buf, 2);\n\n\tschedule_delayed_work(to_delayed_work(work), msecs_to_jiffies(5000));\n};\n\nstatic int nvec_power_probe(struct platform_device *pdev)\n{\n\tstruct power_supply **psy;\n\tconst struct power_supply_desc *psy_desc;\n\tstruct nvec_power *power;\n\tstruct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);\n\tstruct power_supply_config psy_cfg = {};\n\n\tpower = devm_kzalloc(&pdev->dev, sizeof(struct nvec_power), GFP_NOWAIT);\n\tif (!power)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&pdev->dev, power);\n\tpower->nvec = nvec;\n\n\tswitch (pdev->id) {\n\tcase AC:\n\t\tpsy = &nvec_psy;\n\t\tpsy_desc = &nvec_psy_desc;\n\t\tpsy_cfg.supplied_to = nvec_power_supplied_to;\n\t\tpsy_cfg.num_supplicants = ARRAY_SIZE(nvec_power_supplied_to);\n\n\t\tpower->notifier.notifier_call = nvec_power_notifier;\n\n\t\tINIT_DELAYED_WORK(&power->poller, nvec_power_poll);\n\t\tschedule_delayed_work(&power->poller, msecs_to_jiffies(5000));\n\t\tbreak;\n\tcase BAT:\n\t\tpsy = &nvec_bat_psy;\n\t\tpsy_desc = &nvec_bat_psy_desc;\n\n\t\tpower->notifier.notifier_call = nvec_power_bat_notifier;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tnvec_register_notifier(nvec, &power->notifier, NVEC_SYS);\n\n\tif (pdev->id == BAT)\n\t\tget_bat_mfg_data(power);\n\n\t*psy = power_supply_register(&pdev->dev, psy_desc, &psy_cfg);\n\n\treturn PTR_ERR_OR_ZERO(*psy);\n}\n\nstatic void nvec_power_remove(struct platform_device *pdev)\n{\n\tstruct nvec_power *power = platform_get_drvdata(pdev);\n\n\tcancel_delayed_work_sync(&power->poller);\n\tnvec_unregister_notifier(power->nvec, &power->notifier);\n\tswitch (pdev->id) {\n\tcase AC:\n\t\tpower_supply_unregister(nvec_psy);\n\t\tbreak;\n\tcase BAT:\n\t\tpower_supply_unregister(nvec_bat_psy);\n\t}\n}\n\nstatic struct platform_driver nvec_power_driver = {\n\t.probe = nvec_power_probe,\n\t.remove_new = nvec_power_remove,\n\t.driver = {\n\t\t   .name = \"nvec-power\",\n\t}\n};\n\nmodule_platform_driver(nvec_power_driver);\n\nMODULE_AUTHOR(\"Ilya Petrov <ilya.muromec@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"NVEC battery and AC driver\");\nMODULE_ALIAS(\"platform:nvec-power\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}