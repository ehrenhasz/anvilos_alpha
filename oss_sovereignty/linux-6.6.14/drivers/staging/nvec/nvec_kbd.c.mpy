{
  "module_name": "nvec_kbd.c",
  "hash_id": "50c91aa756380586e04007324b84603c5fceb33a87b0e60152ca4de8cfcfa9f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/nvec/nvec_kbd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n\n#include \"nvec-keytable.h\"\n#include \"nvec.h\"\n\nenum kbd_subcmds {\n\tCNFG_WAKE = 3,\n\tCNFG_WAKE_KEY_REPORTING,\n\tSET_LEDS = 0xed,\n\tENABLE_KBD = 0xf4,\n\tDISABLE_KBD,\n};\n\nstatic unsigned char keycodes[ARRAY_SIZE(code_tab_102us)\n\t\t\t      + ARRAY_SIZE(extcode_tab_us102)];\n\nstruct nvec_keys {\n\tstruct input_dev *input;\n\tstruct notifier_block notifier;\n\tstruct nvec_chip *nvec;\n\tbool caps_lock;\n};\n\nstatic struct nvec_keys keys_dev;\n\nstatic void nvec_kbd_toggle_led(void)\n{\n\tchar buf[] = { NVEC_KBD, SET_LEDS, 0 };\n\n\tkeys_dev.caps_lock = !keys_dev.caps_lock;\n\n\tif (keys_dev.caps_lock)\n\t\t \n\t\tbuf[2] = BIT(0) | BIT(1) | BIT(2);\n\n\tnvec_write_async(keys_dev.nvec, buf, sizeof(buf));\n}\n\nstatic int nvec_keys_notifier(struct notifier_block *nb,\n\t\t\t      unsigned long event_type, void *data)\n{\n\tint code, state;\n\tunsigned char *msg = data;\n\n\tif (event_type == NVEC_KB_EVT) {\n\t\tint _size = (msg[0] & (3 << 5)) >> 5;\n\n \n\t\tif (_size == NVEC_VAR_SIZE)\n\t\t\treturn NOTIFY_STOP;\n\n\t\tif (_size == NVEC_3BYTES)\n\t\t\tmsg++;\n\n\t\tcode = msg[1] & 0x7f;\n\t\tstate = msg[1] & 0x80;\n\n\t\tif (code_tabs[_size][code] == KEY_CAPSLOCK && state)\n\t\t\tnvec_kbd_toggle_led();\n\n\t\tinput_report_key(keys_dev.input, code_tabs[_size][code],\n\t\t\t\t !state);\n\t\tinput_sync(keys_dev.input);\n\n\t\treturn NOTIFY_STOP;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int nvec_kbd_event(struct input_dev *dev, unsigned int type,\n\t\t\t  unsigned int code, int value)\n{\n\tstruct nvec_chip *nvec = keys_dev.nvec;\n\tchar buf[] = { NVEC_KBD, SET_LEDS, 0 };\n\n\tif (type == EV_REP)\n\t\treturn 0;\n\n\tif (type != EV_LED)\n\t\treturn -1;\n\n\tif (code != LED_CAPSL)\n\t\treturn -1;\n\n\tbuf[2] = !!value;\n\tnvec_write_async(nvec, buf, sizeof(buf));\n\n\treturn 0;\n}\n\nstatic int nvec_kbd_probe(struct platform_device *pdev)\n{\n\tstruct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);\n\tint i, j, err;\n\tstruct input_dev *idev;\n\tchar\tclear_leds[] = { NVEC_KBD, SET_LEDS, 0 },\n\t\tenable_kbd[] = { NVEC_KBD, ENABLE_KBD },\n\t\tcnfg_wake[] = { NVEC_KBD, CNFG_WAKE, true, true },\n\t\tcnfg_wake_key_reporting[] = { NVEC_KBD, CNFG_WAKE_KEY_REPORTING,\n\t\t\t\t\t\ttrue };\n\n\tj = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(code_tab_102us); ++i)\n\t\tkeycodes[j++] = code_tab_102us[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(extcode_tab_us102); ++i)\n\t\tkeycodes[j++] = extcode_tab_us102[i];\n\n\tidev = devm_input_allocate_device(&pdev->dev);\n\tif (!idev)\n\t\treturn -ENOMEM;\n\tidev->name = \"nvec keyboard\";\n\tidev->phys = \"nvec\";\n\tidev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) | BIT_MASK(EV_LED);\n\tidev->ledbit[0] = BIT_MASK(LED_CAPSL);\n\tidev->event = nvec_kbd_event;\n\tidev->keycode = keycodes;\n\tidev->keycodesize = sizeof(unsigned char);\n\tidev->keycodemax = ARRAY_SIZE(keycodes);\n\n\tfor (i = 0; i < ARRAY_SIZE(keycodes); ++i)\n\t\tset_bit(keycodes[i], idev->keybit);\n\n\tclear_bit(0, idev->keybit);\n\terr = input_register_device(idev);\n\tif (err)\n\t\treturn err;\n\n\tkeys_dev.input = idev;\n\tkeys_dev.notifier.notifier_call = nvec_keys_notifier;\n\tkeys_dev.nvec = nvec;\n\tnvec_register_notifier(nvec, &keys_dev.notifier, 0);\n\n\t \n\tnvec_write_async(nvec, enable_kbd, 2);\n\n\t \n\tnvec_write_async(nvec, cnfg_wake, 4);\n\t \n\tnvec_write_async(nvec, cnfg_wake_key_reporting, 3);\n\n\t \n\tnvec_write_async(nvec, clear_leds, sizeof(clear_leds));\n\n\treturn 0;\n}\n\nstatic void nvec_kbd_remove(struct platform_device *pdev)\n{\n\tstruct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);\n\tchar disable_kbd[] = { NVEC_KBD, DISABLE_KBD },\n\t     uncnfg_wake_key_reporting[] = { NVEC_KBD, CNFG_WAKE_KEY_REPORTING,\n\t\t\t\t\t\tfalse };\n\tnvec_write_async(nvec, uncnfg_wake_key_reporting, 3);\n\tnvec_write_async(nvec, disable_kbd, 2);\n\tnvec_unregister_notifier(nvec, &keys_dev.notifier);\n}\n\nstatic struct platform_driver nvec_kbd_driver = {\n\t.probe  = nvec_kbd_probe,\n\t.remove_new = nvec_kbd_remove,\n\t.driver = {\n\t\t.name = \"nvec-kbd\",\n\t},\n};\n\nmodule_platform_driver(nvec_kbd_driver);\n\nMODULE_AUTHOR(\"Marc Dietrich <marvin24@gmx.de>\");\nMODULE_DESCRIPTION(\"NVEC keyboard driver\");\nMODULE_ALIAS(\"platform:nvec-kbd\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}