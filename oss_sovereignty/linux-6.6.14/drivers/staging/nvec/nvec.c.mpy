{
  "module_name": "nvec.c",
  "hash_id": "36babfcbb829ede37e261aa90efc16df2dd4cba9d92f3120ae8cd6dc8b1b9010",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/nvec/nvec.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/mfd/core.h>\n#include <linux/mutex.h>\n#include <linux/notifier.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#include \"nvec.h\"\n\n#define I2C_CNFG\t\t\t0x00\n#define I2C_CNFG_PACKET_MODE_EN\t\tBIT(10)\n#define I2C_CNFG_NEW_MASTER_SFM\t\tBIT(11)\n#define I2C_CNFG_DEBOUNCE_CNT_SHIFT\t12\n\n#define I2C_SL_CNFG\t\t0x20\n#define I2C_SL_NEWSL\t\tBIT(2)\n#define I2C_SL_NACK\t\tBIT(1)\n#define I2C_SL_RESP\t\tBIT(0)\n#define I2C_SL_IRQ\t\tBIT(3)\n#define END_TRANS\t\tBIT(4)\n#define RCVD\t\t\tBIT(2)\n#define RNW\t\t\tBIT(1)\n\n#define I2C_SL_RCVD\t\t0x24\n#define I2C_SL_STATUS\t\t0x28\n#define I2C_SL_ADDR1\t\t0x2c\n#define I2C_SL_ADDR2\t\t0x30\n#define I2C_SL_DELAY_COUNT\t0x3c\n\n \nenum nvec_msg_category  {\n\tNVEC_MSG_RX,\n\tNVEC_MSG_TX,\n};\n\nenum nvec_sleep_subcmds {\n\tGLOBAL_EVENTS,\n\tAP_PWR_DOWN,\n\tAP_SUSPEND,\n};\n\n#define CNF_EVENT_REPORTING 0x01\n#define GET_FIRMWARE_VERSION 0x15\n#define LID_SWITCH BIT(1)\n#define PWR_BUTTON BIT(15)\n\nstatic struct nvec_chip *nvec_power_handle;\n\nstatic const struct mfd_cell nvec_devices[] = {\n\t{\n\t\t.name = \"nvec-kbd\",\n\t},\n\t{\n\t\t.name = \"nvec-mouse\",\n\t},\n\t{\n\t\t.name = \"nvec-power\",\n\t\t.id = 0,\n\t},\n\t{\n\t\t.name = \"nvec-power\",\n\t\t.id = 1,\n\t},\n\t{\n\t\t.name = \"nvec-paz00\",\n\t},\n};\n\n \nint nvec_register_notifier(struct nvec_chip *nvec, struct notifier_block *nb,\n\t\t\t   unsigned int events)\n{\n\treturn atomic_notifier_chain_register(&nvec->notifier_list, nb);\n}\nEXPORT_SYMBOL_GPL(nvec_register_notifier);\n\n \nint nvec_unregister_notifier(struct nvec_chip *nvec, struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&nvec->notifier_list, nb);\n}\nEXPORT_SYMBOL_GPL(nvec_unregister_notifier);\n\n \nstatic int nvec_status_notifier(struct notifier_block *nb,\n\t\t\t\tunsigned long event_type, void *data)\n{\n\tstruct nvec_chip *nvec = container_of(nb, struct nvec_chip,\n\t\t\t\t\t\tnvec_status_notifier);\n\tunsigned char *msg = data;\n\n\tif (event_type != NVEC_CNTL)\n\t\treturn NOTIFY_DONE;\n\n\tdev_warn(nvec->dev, \"unhandled msg type %ld\\n\", event_type);\n\tprint_hex_dump(KERN_WARNING, \"payload: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       msg, msg[1] + 2, true);\n\n\treturn NOTIFY_OK;\n}\n\n \nstatic struct nvec_msg *nvec_msg_alloc(struct nvec_chip *nvec,\n\t\t\t\t       enum nvec_msg_category category)\n{\n\tint i = (category == NVEC_MSG_TX) ? (NVEC_POOL_SIZE / 4) : 0;\n\n\tfor (; i < NVEC_POOL_SIZE; i++) {\n\t\tif (atomic_xchg(&nvec->msg_pool[i].used, 1) == 0) {\n\t\t\tdev_vdbg(nvec->dev, \"INFO: Allocate %i\\n\", i);\n\t\t\treturn &nvec->msg_pool[i];\n\t\t}\n\t}\n\n\tdev_err(nvec->dev, \"could not allocate %s buffer\\n\",\n\t\t(category == NVEC_MSG_TX) ? \"TX\" : \"RX\");\n\n\treturn NULL;\n}\n\n \nvoid nvec_msg_free(struct nvec_chip *nvec, struct nvec_msg *msg)\n{\n\tif (msg != &nvec->tx_scratch)\n\t\tdev_vdbg(nvec->dev, \"INFO: Free %ti\\n\", msg - nvec->msg_pool);\n\tatomic_set(&msg->used, 0);\n}\nEXPORT_SYMBOL_GPL(nvec_msg_free);\n\n \nstatic bool nvec_msg_is_event(struct nvec_msg *msg)\n{\n\treturn msg->data[0] >> 7;\n}\n\n \nstatic size_t nvec_msg_size(struct nvec_msg *msg)\n{\n\tbool is_event = nvec_msg_is_event(msg);\n\tint event_length = (msg->data[0] & 0x60) >> 5;\n\n\t \n\tif (!is_event || event_length == NVEC_VAR_SIZE)\n\t\treturn (msg->pos || msg->size) ? (msg->data[1] + 2) : 0;\n\telse if (event_length == NVEC_2BYTES)\n\t\treturn 2;\n\telse if (event_length == NVEC_3BYTES)\n\t\treturn 3;\n\treturn 0;\n}\n\n \nstatic void nvec_gpio_set_value(struct nvec_chip *nvec, int value)\n{\n\tdev_dbg(nvec->dev, \"GPIO changed from %u to %u\\n\",\n\t\tgpiod_get_value(nvec->gpiod), value);\n\tgpiod_set_value(nvec->gpiod, value);\n}\n\n \nint nvec_write_async(struct nvec_chip *nvec, const unsigned char *data,\n\t\t     short size)\n{\n\tstruct nvec_msg *msg;\n\tunsigned long flags;\n\n\tmsg = nvec_msg_alloc(nvec, NVEC_MSG_TX);\n\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->data[0] = size;\n\tmemcpy(msg->data + 1, data, size);\n\tmsg->size = size + 1;\n\n\tspin_lock_irqsave(&nvec->tx_lock, flags);\n\tlist_add_tail(&msg->node, &nvec->tx_data);\n\tspin_unlock_irqrestore(&nvec->tx_lock, flags);\n\n\tschedule_work(&nvec->tx_work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nvec_write_async);\n\n \nint nvec_write_sync(struct nvec_chip *nvec,\n\t\t    const unsigned char *data, short size,\n\t\t    struct nvec_msg **msg)\n{\n\tmutex_lock(&nvec->sync_write_mutex);\n\n\t*msg = NULL;\n\tnvec->sync_write_pending = (data[1] << 8) + data[0];\n\n\tif (nvec_write_async(nvec, data, size) < 0) {\n\t\tmutex_unlock(&nvec->sync_write_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_dbg(nvec->dev, \"nvec_sync_write: 0x%04x\\n\",\n\t\tnvec->sync_write_pending);\n\tif (!(wait_for_completion_timeout(&nvec->sync_write,\n\t\t\t\t\t  msecs_to_jiffies(2000)))) {\n\t\tdev_warn(nvec->dev,\n\t\t\t \"timeout waiting for sync write to complete\\n\");\n\t\tmutex_unlock(&nvec->sync_write_mutex);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdev_dbg(nvec->dev, \"nvec_sync_write: pong!\\n\");\n\n\t*msg = nvec->last_sync_msg;\n\n\tmutex_unlock(&nvec->sync_write_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nvec_write_sync);\n\n \nstatic void nvec_toggle_global_events(struct nvec_chip *nvec, bool state)\n{\n\tunsigned char global_events[] = { NVEC_SLEEP, GLOBAL_EVENTS, state };\n\n\tnvec_write_async(nvec, global_events, 3);\n}\n\n \nstatic void nvec_event_mask(char *ev, u32 mask)\n{\n\tev[3] = mask >> 16 & 0xff;\n\tev[4] = mask >> 24 & 0xff;\n\tev[5] = mask >> 0  & 0xff;\n\tev[6] = mask >> 8  & 0xff;\n}\n\n \nstatic void nvec_request_master(struct work_struct *work)\n{\n\tstruct nvec_chip *nvec = container_of(work, struct nvec_chip, tx_work);\n\tunsigned long flags;\n\tlong err;\n\tstruct nvec_msg *msg;\n\n\tspin_lock_irqsave(&nvec->tx_lock, flags);\n\twhile (!list_empty(&nvec->tx_data)) {\n\t\tmsg = list_first_entry(&nvec->tx_data, struct nvec_msg, node);\n\t\tspin_unlock_irqrestore(&nvec->tx_lock, flags);\n\t\tnvec_gpio_set_value(nvec, 0);\n\t\terr = wait_for_completion_interruptible_timeout(&nvec->ec_transfer,\n\t\t\t\t\t\t\t\tmsecs_to_jiffies(5000));\n\n\t\tif (err == 0) {\n\t\t\tdev_warn(nvec->dev, \"timeout waiting for ec transfer\\n\");\n\t\t\tnvec_gpio_set_value(nvec, 1);\n\t\t\tmsg->pos = 0;\n\t\t}\n\n\t\tspin_lock_irqsave(&nvec->tx_lock, flags);\n\n\t\tif (err > 0) {\n\t\t\tlist_del_init(&msg->node);\n\t\t\tnvec_msg_free(nvec, msg);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&nvec->tx_lock, flags);\n}\n\n \nstatic int parse_msg(struct nvec_chip *nvec, struct nvec_msg *msg)\n{\n\tif ((msg->data[0] & 1 << 7) == 0 && msg->data[3]) {\n\t\tdev_err(nvec->dev, \"ec responded %*ph\\n\", 4, msg->data);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((msg->data[0] >> 7) == 1 && (msg->data[0] & 0x0f) == 5)\n\t\tprint_hex_dump(KERN_WARNING, \"ec system event \",\n\t\t\t       DUMP_PREFIX_NONE, 16, 1, msg->data,\n\t\t\t       msg->data[1] + 2, true);\n\n\tatomic_notifier_call_chain(&nvec->notifier_list, msg->data[0] & 0x8f,\n\t\t\t\t   msg->data);\n\n\treturn 0;\n}\n\n \nstatic void nvec_dispatch(struct work_struct *work)\n{\n\tstruct nvec_chip *nvec = container_of(work, struct nvec_chip, rx_work);\n\tunsigned long flags;\n\tstruct nvec_msg *msg;\n\n\tspin_lock_irqsave(&nvec->rx_lock, flags);\n\twhile (!list_empty(&nvec->rx_data)) {\n\t\tmsg = list_first_entry(&nvec->rx_data, struct nvec_msg, node);\n\t\tlist_del_init(&msg->node);\n\t\tspin_unlock_irqrestore(&nvec->rx_lock, flags);\n\n\t\tif (nvec->sync_write_pending ==\n\t\t      (msg->data[2] << 8) + msg->data[0]) {\n\t\t\tdev_dbg(nvec->dev, \"sync write completed!\\n\");\n\t\t\tnvec->sync_write_pending = 0;\n\t\t\tnvec->last_sync_msg = msg;\n\t\t\tcomplete(&nvec->sync_write);\n\t\t} else {\n\t\t\tparse_msg(nvec, msg);\n\t\t\tnvec_msg_free(nvec, msg);\n\t\t}\n\t\tspin_lock_irqsave(&nvec->rx_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&nvec->rx_lock, flags);\n}\n\n \nstatic void nvec_tx_completed(struct nvec_chip *nvec)\n{\n\t \n\tif (nvec->tx->pos != nvec->tx->size) {\n\t\tdev_err(nvec->dev, \"premature END_TRANS, resending\\n\");\n\t\tnvec->tx->pos = 0;\n\t\tnvec_gpio_set_value(nvec, 0);\n\t} else {\n\t\tnvec->state = 0;\n\t}\n}\n\n \nstatic void nvec_rx_completed(struct nvec_chip *nvec)\n{\n\tif (nvec->rx->pos != nvec_msg_size(nvec->rx)) {\n\t\tdev_err(nvec->dev, \"RX incomplete: Expected %u bytes, got %u\\n\",\n\t\t\t(uint)nvec_msg_size(nvec->rx),\n\t\t\t(uint)nvec->rx->pos);\n\n\t\tnvec_msg_free(nvec, nvec->rx);\n\t\tnvec->state = 0;\n\n\t\t \n\t\tif (nvec->rx->data[0] == NVEC_BAT)\n\t\t\tcomplete(&nvec->ec_transfer);\n\n\t\treturn;\n\t}\n\n\tspin_lock(&nvec->rx_lock);\n\n\t \n\tlist_add_tail(&nvec->rx->node, &nvec->rx_data);\n\n\tspin_unlock(&nvec->rx_lock);\n\n\tnvec->state = 0;\n\n\tif (!nvec_msg_is_event(nvec->rx))\n\t\tcomplete(&nvec->ec_transfer);\n\n\tschedule_work(&nvec->rx_work);\n}\n\n \nstatic void nvec_invalid_flags(struct nvec_chip *nvec, unsigned int status,\n\t\t\t       bool reset)\n{\n\tdev_err(nvec->dev, \"unexpected status flags 0x%02x during state %i\\n\",\n\t\tstatus, nvec->state);\n\tif (reset)\n\t\tnvec->state = 0;\n}\n\n \nstatic void nvec_tx_set(struct nvec_chip *nvec)\n{\n\tspin_lock(&nvec->tx_lock);\n\tif (list_empty(&nvec->tx_data)) {\n\t\tdev_err(nvec->dev, \"empty tx - sending no-op\\n\");\n\t\tmemcpy(nvec->tx_scratch.data, \"\\x02\\x07\\x02\", 3);\n\t\tnvec->tx_scratch.size = 3;\n\t\tnvec->tx_scratch.pos = 0;\n\t\tnvec->tx = &nvec->tx_scratch;\n\t\tlist_add_tail(&nvec->tx->node, &nvec->tx_data);\n\t} else {\n\t\tnvec->tx = list_first_entry(&nvec->tx_data, struct nvec_msg,\n\t\t\t\t\t    node);\n\t\tnvec->tx->pos = 0;\n\t}\n\tspin_unlock(&nvec->tx_lock);\n\n\tdev_dbg(nvec->dev, \"Sending message of length %u, command 0x%x\\n\",\n\t\t(uint)nvec->tx->size, nvec->tx->data[1]);\n}\n\n \nstatic irqreturn_t nvec_interrupt(int irq, void *dev)\n{\n\tunsigned long status;\n\tunsigned int received = 0;\n\tunsigned char to_send = 0xff;\n\tconst unsigned long irq_mask = I2C_SL_IRQ | END_TRANS | RCVD | RNW;\n\tstruct nvec_chip *nvec = dev;\n\tunsigned int state = nvec->state;\n\n\tstatus = readl(nvec->base + I2C_SL_STATUS);\n\n\t \n\tif ((status & irq_mask) == 0 && (status & ~irq_mask) != 0) {\n\t\tdev_err(nvec->dev, \"unexpected irq mask %lx\\n\", status);\n\t\treturn IRQ_HANDLED;\n\t}\n\tif ((status & I2C_SL_IRQ) == 0) {\n\t\tdev_err(nvec->dev, \"Spurious IRQ\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif ((status & RNW) == 0) {\n\t\treceived = readl(nvec->base + I2C_SL_RCVD);\n\t\tif (status & RCVD)\n\t\t\twritel(0, nvec->base + I2C_SL_RCVD);\n\t}\n\n\tif (status == (I2C_SL_IRQ | RCVD))\n\t\tnvec->state = 0;\n\n\tswitch (nvec->state) {\n\tcase 0:\t\t \n\t\tif (status != (I2C_SL_IRQ | RCVD))\n\t\t\tnvec_invalid_flags(nvec, status, false);\n\t\tbreak;\n\tcase 1:\t\t \n\t\tif (status != I2C_SL_IRQ) {\n\t\t\tnvec_invalid_flags(nvec, status, true);\n\t\t} else {\n\t\t\tnvec->rx = nvec_msg_alloc(nvec, NVEC_MSG_RX);\n\t\t\t \n\t\t\tif (unlikely(!nvec->rx)) {\n\t\t\t\tnvec->state = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnvec->rx->data[0] = received;\n\t\t\tnvec->rx->pos = 1;\n\t\t\tnvec->state = 2;\n\t\t}\n\t\tbreak;\n\tcase 2:\t\t \n\t\tif (status == (I2C_SL_IRQ | RNW | RCVD)) {\n\t\t\tudelay(33);\n\t\t\tif (nvec->rx->data[0] != 0x01) {\n\t\t\t\tdev_err(nvec->dev,\n\t\t\t\t\t\"Read without prior read command\\n\");\n\t\t\t\tnvec->state = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnvec_msg_free(nvec, nvec->rx);\n\t\t\tnvec->state = 3;\n\t\t\tnvec_tx_set(nvec);\n\t\t\tto_send = nvec->tx->data[0];\n\t\t\tnvec->tx->pos = 1;\n\t\t} else if (status == (I2C_SL_IRQ)) {\n\t\t\tnvec->rx->data[1] = received;\n\t\t\tnvec->rx->pos = 2;\n\t\t\tnvec->state = 4;\n\t\t} else {\n\t\t\tnvec_invalid_flags(nvec, status, true);\n\t\t}\n\t\tbreak;\n\tcase 3:\t\t \n\t\tif (status & END_TRANS) {\n\t\t\tnvec_tx_completed(nvec);\n\t\t} else if ((status & RNW) == 0 || (status & RCVD)) {\n\t\t\tnvec_invalid_flags(nvec, status, true);\n\t\t} else if (nvec->tx && nvec->tx->pos < nvec->tx->size) {\n\t\t\tto_send = nvec->tx->data[nvec->tx->pos++];\n\t\t} else {\n\t\t\tdev_err(nvec->dev,\n\t\t\t\t\"tx buffer underflow on %p (%u > %u)\\n\",\n\t\t\t\tnvec->tx,\n\t\t\t\t(uint)(nvec->tx ? nvec->tx->pos : 0),\n\t\t\t\t(uint)(nvec->tx ? nvec->tx->size : 0));\n\t\t\tnvec->state = 0;\n\t\t}\n\t\tbreak;\n\tcase 4:\t\t \n\t\tif ((status & (END_TRANS | RNW)) == END_TRANS)\n\t\t\tnvec_rx_completed(nvec);\n\t\telse if (status & (RNW | RCVD))\n\t\t\tnvec_invalid_flags(nvec, status, true);\n\t\telse if (nvec->rx && nvec->rx->pos < NVEC_MSG_SIZE)\n\t\t\tnvec->rx->data[nvec->rx->pos++] = received;\n\t\telse\n\t\t\tdev_err(nvec->dev,\n\t\t\t\t\"RX buffer overflow on %p: Trying to write byte %u of %u\\n\",\n\t\t\t\tnvec->rx, nvec->rx ? nvec->rx->pos : 0,\n\t\t\t\tNVEC_MSG_SIZE);\n\t\tbreak;\n\tdefault:\n\t\tnvec->state = 0;\n\t}\n\n\t \n\tif ((status & (RCVD | RNW)) == RCVD) {\n\t\tif (received != nvec->i2c_addr)\n\t\t\tdev_err(nvec->dev,\n\t\t\t\t\"received address 0x%02x, expected 0x%02x\\n\",\n\t\t\t\treceived, nvec->i2c_addr);\n\t\tnvec->state = 1;\n\t}\n\n\t \n\tif ((status & (RNW | END_TRANS)) == RNW)\n\t\twritel(to_send, nvec->base + I2C_SL_RCVD);\n\n\t \n\tif (status == (I2C_SL_IRQ | RNW | RCVD))\n\t\tnvec_gpio_set_value(nvec, 1);\n\n\tdev_dbg(nvec->dev,\n\t\t\"Handled: %s 0x%02x, %s 0x%02x in state %u [%s%s%s]\\n\",\n\t\t(status & RNW) == 0 ? \"received\" : \"R=\",\n\t\treceived,\n\t\t(status & (RNW | END_TRANS)) ? \"sent\" : \"S=\",\n\t\tto_send,\n\t\tstate,\n\t\tstatus & END_TRANS ? \" END_TRANS\" : \"\",\n\t\tstatus & RCVD ? \" RCVD\" : \"\",\n\t\tstatus & RNW ? \" RNW\" : \"\");\n\n\t \n\tudelay(100);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void tegra_init_i2c_slave(struct nvec_chip *nvec)\n{\n\tu32 val;\n\n\tclk_prepare_enable(nvec->i2c_clk);\n\n\treset_control_assert(nvec->rst);\n\tudelay(2);\n\treset_control_deassert(nvec->rst);\n\n\tval = I2C_CNFG_NEW_MASTER_SFM | I2C_CNFG_PACKET_MODE_EN |\n\t    (0x2 << I2C_CNFG_DEBOUNCE_CNT_SHIFT);\n\twritel(val, nvec->base + I2C_CNFG);\n\n\tclk_set_rate(nvec->i2c_clk, 8 * 80000);\n\n\twritel(I2C_SL_NEWSL, nvec->base + I2C_SL_CNFG);\n\twritel(0x1E, nvec->base + I2C_SL_DELAY_COUNT);\n\n\twritel(nvec->i2c_addr >> 1, nvec->base + I2C_SL_ADDR1);\n\twritel(0, nvec->base + I2C_SL_ADDR2);\n\n\tenable_irq(nvec->irq);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void nvec_disable_i2c_slave(struct nvec_chip *nvec)\n{\n\tdisable_irq(nvec->irq);\n\twritel(I2C_SL_NEWSL | I2C_SL_NACK, nvec->base + I2C_SL_CNFG);\n\tclk_disable_unprepare(nvec->i2c_clk);\n}\n#endif\n\nstatic void nvec_power_off(void)\n{\n\tchar ap_pwr_down[] = { NVEC_SLEEP, AP_PWR_DOWN };\n\n\tnvec_toggle_global_events(nvec_power_handle, false);\n\tnvec_write_async(nvec_power_handle, ap_pwr_down, 2);\n}\n\nstatic int tegra_nvec_probe(struct platform_device *pdev)\n{\n\tint err, ret;\n\tstruct clk *i2c_clk;\n\tstruct device *dev = &pdev->dev;\n\tstruct nvec_chip *nvec;\n\tstruct nvec_msg *msg;\n\tvoid __iomem *base;\n\tchar\tget_firmware_version[] = { NVEC_CNTL, GET_FIRMWARE_VERSION },\n\t\tunmute_speakers[] = { NVEC_OEM0, 0x10, 0x59, 0x95 },\n\t\tenable_event[7] = { NVEC_SYS, CNF_EVENT_REPORTING, true };\n\n\tif (!dev->of_node) {\n\t\tdev_err(dev, \"must be instantiated using device tree\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tnvec = devm_kzalloc(dev, sizeof(struct nvec_chip), GFP_KERNEL);\n\tif (!nvec)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, nvec);\n\tnvec->dev = dev;\n\n\tif (of_property_read_u32(dev->of_node, \"slave-addr\", &nvec->i2c_addr)) {\n\t\tdev_err(dev, \"no i2c address specified\");\n\t\treturn -ENODEV;\n\t}\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tnvec->irq = platform_get_irq(pdev, 0);\n\tif (nvec->irq < 0)\n\t\treturn -ENODEV;\n\n\ti2c_clk = devm_clk_get(dev, \"div-clk\");\n\tif (IS_ERR(i2c_clk)) {\n\t\tdev_err(dev, \"failed to get controller clock\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tnvec->rst = devm_reset_control_get_exclusive(dev, \"i2c\");\n\tif (IS_ERR(nvec->rst)) {\n\t\tdev_err(dev, \"failed to get controller reset\\n\");\n\t\treturn PTR_ERR(nvec->rst);\n\t}\n\n\tnvec->base = base;\n\tnvec->i2c_clk = i2c_clk;\n\tnvec->rx = &nvec->msg_pool[0];\n\n\tATOMIC_INIT_NOTIFIER_HEAD(&nvec->notifier_list);\n\n\tinit_completion(&nvec->sync_write);\n\tinit_completion(&nvec->ec_transfer);\n\tmutex_init(&nvec->sync_write_mutex);\n\tspin_lock_init(&nvec->tx_lock);\n\tspin_lock_init(&nvec->rx_lock);\n\tINIT_LIST_HEAD(&nvec->rx_data);\n\tINIT_LIST_HEAD(&nvec->tx_data);\n\tINIT_WORK(&nvec->rx_work, nvec_dispatch);\n\tINIT_WORK(&nvec->tx_work, nvec_request_master);\n\n\tnvec->gpiod = devm_gpiod_get(dev, \"request\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(nvec->gpiod)) {\n\t\tdev_err(dev, \"couldn't request gpio\\n\");\n\t\treturn PTR_ERR(nvec->gpiod);\n\t}\n\n\terr = devm_request_irq(dev, nvec->irq, nvec_interrupt, 0,\n\t\t\t       \"nvec\", nvec);\n\tif (err) {\n\t\tdev_err(dev, \"couldn't request irq\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdisable_irq(nvec->irq);\n\n\ttegra_init_i2c_slave(nvec);\n\n\t \n\tnvec_toggle_global_events(nvec, true);\n\n\tnvec->nvec_status_notifier.notifier_call = nvec_status_notifier;\n\tnvec_register_notifier(nvec, &nvec->nvec_status_notifier, 0);\n\n\tnvec_power_handle = nvec;\n\tpm_power_off = nvec_power_off;\n\n\t \n\terr = nvec_write_sync(nvec, get_firmware_version, 2, &msg);\n\n\tif (!err) {\n\t\tdev_warn(dev,\n\t\t\t \"ec firmware version %02x.%02x.%02x / %02x\\n\",\n\t\t\t msg->data[4], msg->data[5],\n\t\t\t msg->data[6], msg->data[7]);\n\n\t\tnvec_msg_free(nvec, msg);\n\t}\n\n\tret = mfd_add_devices(dev, 0, nvec_devices,\n\t\t\t      ARRAY_SIZE(nvec_devices), NULL, 0, NULL);\n\tif (ret)\n\t\tdev_err(dev, \"error adding subdevices\\n\");\n\n\t \n\tnvec_write_async(nvec, unmute_speakers, 4);\n\n\t \n\tnvec_event_mask(enable_event, LID_SWITCH);\n\tnvec_write_async(nvec, enable_event, 7);\n\n\t \n\tnvec_event_mask(enable_event, PWR_BUTTON);\n\tnvec_write_async(nvec, enable_event, 7);\n\n\treturn 0;\n}\n\nstatic void tegra_nvec_remove(struct platform_device *pdev)\n{\n\tstruct nvec_chip *nvec = platform_get_drvdata(pdev);\n\n\tnvec_toggle_global_events(nvec, false);\n\tmfd_remove_devices(nvec->dev);\n\tnvec_unregister_notifier(nvec, &nvec->nvec_status_notifier);\n\tcancel_work_sync(&nvec->rx_work);\n\tcancel_work_sync(&nvec->tx_work);\n\t \n\tpm_power_off = NULL;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int nvec_suspend(struct device *dev)\n{\n\tint err;\n\tstruct nvec_chip *nvec = dev_get_drvdata(dev);\n\tstruct nvec_msg *msg;\n\tchar ap_suspend[] = { NVEC_SLEEP, AP_SUSPEND };\n\n\tdev_dbg(nvec->dev, \"suspending\\n\");\n\n\t \n\tnvec_toggle_global_events(nvec, false);\n\n\terr = nvec_write_sync(nvec, ap_suspend, sizeof(ap_suspend), &msg);\n\tif (!err)\n\t\tnvec_msg_free(nvec, msg);\n\n\tnvec_disable_i2c_slave(nvec);\n\n\treturn 0;\n}\n\nstatic int nvec_resume(struct device *dev)\n{\n\tstruct nvec_chip *nvec = dev_get_drvdata(dev);\n\n\tdev_dbg(nvec->dev, \"resuming\\n\");\n\ttegra_init_i2c_slave(nvec);\n\tnvec_toggle_global_events(nvec, true);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(nvec_pm_ops, nvec_suspend, nvec_resume);\n\n \nstatic const struct of_device_id nvidia_nvec_of_match[] = {\n\t{ .compatible = \"nvidia,nvec\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, nvidia_nvec_of_match);\n\nstatic struct platform_driver nvec_device_driver = {\n\t.probe   = tegra_nvec_probe,\n\t.remove_new = tegra_nvec_remove,\n\t.driver  = {\n\t\t.name = \"nvec\",\n\t\t.pm = &nvec_pm_ops,\n\t\t.of_match_table = nvidia_nvec_of_match,\n\t}\n};\n\nmodule_platform_driver(nvec_device_driver);\n\nMODULE_ALIAS(\"platform:nvec\");\nMODULE_DESCRIPTION(\"NVIDIA compliant embedded controller interface\");\nMODULE_AUTHOR(\"Marc Dietrich <marvin24@gmx.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}