{
  "module_name": "rtl871x_security.c",
  "hash_id": "b3891b41f3e55c311576251ad3450c6aeb15b927b533f00dc76df116dcf85e7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/rtl871x_security.c",
  "human_readable_source": "\n \n\n#define  _RTL871X_SECURITY_C_\n\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kref.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/circ_buf.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/atomic.h>\n#include <linux/crc32poly.h>\n#include <linux/semaphore.h>\n#include <linux/ieee80211.h>\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"osdep_intf.h\"\n\n \n\nstruct arc4context {\n\tu32 x;\n\tu32 y;\n\tu8 state[256];\n};\n\nstatic void arcfour_init(struct arc4context *parc4ctx, u8 *key, u32 key_len)\n{\n\tu32\tt, u;\n\tu32\tkeyindex;\n\tu32\tstateindex;\n\tu8 *state;\n\tu32\tcounter;\n\n\tstate = parc4ctx->state;\n\tparc4ctx->x = 0;\n\tparc4ctx->y = 0;\n\tfor (counter = 0; counter < 256; counter++)\n\t\tstate[counter] = (u8)counter;\n\tkeyindex = 0;\n\tstateindex = 0;\n\tfor (counter = 0; counter < 256; counter++) {\n\t\tt = state[counter];\n\t\tstateindex = (stateindex + key[keyindex] + t) & 0xff;\n\t\tu = state[stateindex];\n\t\tstate[stateindex] = (u8)t;\n\t\tstate[counter] = (u8)u;\n\t\tif (++keyindex >= key_len)\n\t\t\tkeyindex = 0;\n\t}\n}\n\nstatic u32 arcfour_byte(struct arc4context *parc4ctx)\n{\n\tu32 x;\n\tu32 y;\n\tu32 sx, sy;\n\tu8 *state;\n\n\tstate = parc4ctx->state;\n\tx = (parc4ctx->x + 1) & 0xff;\n\tsx = state[x];\n\ty = (sx + parc4ctx->y) & 0xff;\n\tsy = state[y];\n\tparc4ctx->x = x;\n\tparc4ctx->y = y;\n\tstate[y] = (u8)sx;\n\tstate[x] = (u8)sy;\n\treturn state[(sx + sy) & 0xff];\n}\n\nstatic void arcfour_encrypt(struct arc4context\t*parc4ctx,\n\t\t     u8 *dest, u8 *src, u32 len)\n{\n\tu32 i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);\n}\n\nstatic sint bcrc32initialized;\nstatic u32 crc32_table[256];\n\nstatic u8 crc32_reverseBit(u8 data)\n{\n\treturn ((u8)(data << 7) & 0x80) | ((data << 5) & 0x40) | ((data << 3)\n\t\t & 0x20) | ((data << 1) & 0x10) | ((data >> 1) & 0x08) |\n\t\t ((data >> 3) & 0x04) | ((data >> 5) & 0x02) | ((data >> 7) &\n\t\t 0x01);\n}\n\nstatic void crc32_init(void)\n{\n\tsint i, j;\n\tu32 c;\n\tu8 *p = (u8 *)&c, *p1;\n\tu8 k;\n\n\tif (bcrc32initialized == 1)\n\t\treturn;\n\n\tfor (i = 0; i < 256; ++i) {\n\t\tk = crc32_reverseBit((u8)i);\n\t\tfor (c = ((u32)k) << 24, j = 8; j > 0; --j)\n\t\t\tc = c & 0x80000000 ? (c << 1) ^ CRC32_POLY_BE : (c << 1);\n\t\tp1 = (u8 *)&crc32_table[i];\n\t\tp1[0] = crc32_reverseBit(p[3]);\n\t\tp1[1] = crc32_reverseBit(p[2]);\n\t\tp1[2] = crc32_reverseBit(p[1]);\n\t\tp1[3] = crc32_reverseBit(p[0]);\n\t}\n\tbcrc32initialized = 1;\n}\n\nstatic u32 getcrc32(u8 *buf, u32 len)\n{\n\tu8 *p;\n\tu32  crc;\n\n\tif (!bcrc32initialized)\n\t\tcrc32_init();\n\tcrc = 0xffffffff;  \n\tfor (p = buf; len > 0; ++p, --len)\n\t\tcrc = crc32_table[(crc ^ *p) & 0xff] ^ (crc >> 8);\n\treturn ~crc;     \n}\n\n \nvoid r8712_wep_encrypt(struct _adapter *padapter, u8 *pxmitframe)\n{\t \n\tunsigned char\tcrc[4];\n\tstruct arc4context  mycontext;\n\tu32 curfragnum, length, keylength, pki;\n\tu8 *pframe, *payload, *iv;     \n\tu8 wepkey[16];\n\tstruct\tpkt_attrib  *pattrib = &((struct xmit_frame *)\n\t\t\t\t       pxmitframe)->attrib;\n\tstruct\tsecurity_priv *psecuritypriv = &padapter->securitypriv;\n\tstruct\txmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tif (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)\n\t\treturn;\n\tpframe = ((struct xmit_frame *)pxmitframe)->buf_addr + TXDESC_OFFSET;\n\t \n\tif ((pattrib->encrypt == _WEP40_) || (pattrib->encrypt == _WEP104_)) {\n\t\tpki = psecuritypriv->PrivacyKeyIndex;\n\t\tkeylength = psecuritypriv->DefKeylen[pki];\n\t\tfor (curfragnum = 0; curfragnum < pattrib->nr_frags;\n\t\t     curfragnum++) {\n\t\t\tiv = pframe + pattrib->hdrlen;\n\t\t\tmemcpy(&wepkey[0], iv, 3);\n\t\t\tmemcpy(&wepkey[3], &psecuritypriv->DefKey[\n\t\t\t\tpsecuritypriv->PrivacyKeyIndex].skey[0],\n\t\t\t\tkeylength);\n\t\t\tpayload = pframe + pattrib->iv_len + pattrib->hdrlen;\n\t\t\tif ((curfragnum + 1) == pattrib->nr_frags) {\n\t\t\t\tlength = pattrib->last_txcmdsz -\n\t\t\t\t\tpattrib->hdrlen -\n\t\t\t\t\tpattrib->iv_len -\n\t\t\t\t\tpattrib->icv_len;\n\t\t\t\t*((__le32 *)crc) = cpu_to_le32(getcrc32(\n\t\t\t\t\t\tpayload, length));\n\t\t\t\tarcfour_init(&mycontext, wepkey, 3 + keylength);\n\t\t\t\tarcfour_encrypt(&mycontext, payload, payload,\n\t\t\t\t\t\tlength);\n\t\t\t\tarcfour_encrypt(&mycontext, payload + length,\n\t\t\t\t\t\tcrc, 4);\n\t\t\t} else {\n\t\t\t\tlength = pxmitpriv->frag_len -\n\t\t\t\t\t pattrib->hdrlen - pattrib->iv_len -\n\t\t\t\t\t pattrib->icv_len;\n\t\t\t\t*((__le32 *)crc) = cpu_to_le32(getcrc32(\n\t\t\t\t\t\tpayload, length));\n\t\t\t\tarcfour_init(&mycontext, wepkey, 3 + keylength);\n\t\t\t\tarcfour_encrypt(&mycontext, payload, payload,\n\t\t\t\t\t\tlength);\n\t\t\t\tarcfour_encrypt(&mycontext, payload + length,\n\t\t\t\t\t\tcrc, 4);\n\t\t\t\tpframe += pxmitpriv->frag_len;\n\t\t\t\tpframe = (u8 *)RND4((addr_t)(pframe));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid r8712_wep_decrypt(struct _adapter  *padapter, u8 *precvframe)\n{\n\t \n\tu8 crc[4];\n\tstruct arc4context  mycontext;\n\tu32 length, keylength;\n\tu8 *pframe, *payload, *iv, wepkey[16];\n\tu8  keyindex;\n\tstruct rx_pkt_attrib  *prxattrib = &(((union recv_frame *)\n\t\t\t\t\t  precvframe)->u.hdr.attrib);\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\n\tpframe = (unsigned char *)((union recv_frame *)precvframe)->\n\t\t  u.hdr.rx_data;\n\t \n\tif ((prxattrib->encrypt == _WEP40_) || (prxattrib->encrypt ==\n\t     _WEP104_)) {\n\t\tiv = pframe + prxattrib->hdrlen;\n\t\tkeyindex = (iv[3] & 0x3);\n\t\tkeylength = psecuritypriv->DefKeylen[keyindex];\n\t\tmemcpy(&wepkey[0], iv, 3);\n\t\tmemcpy(&wepkey[3], &psecuritypriv->DefKey[\n\t\t\tpsecuritypriv->PrivacyKeyIndex].skey[0],\n\t\t\tkeylength);\n\t\tlength = ((union recv_frame *)precvframe)->\n\t\t\t   u.hdr.len - prxattrib->hdrlen - prxattrib->iv_len;\n\t\tpayload = pframe + prxattrib->iv_len + prxattrib->hdrlen;\n\t\t \n\t\tarcfour_init(&mycontext, wepkey, 3 + keylength);\n\t\tarcfour_encrypt(&mycontext, payload, payload,  length);\n\t\t \n\t\t*((__le32 *)crc) = cpu_to_le32(getcrc32(payload, length - 4));\n\t}\n}\n\n \n\nstatic u32 secmicgetuint32(u8 *p)\n \n{\n\ts32 i;\n\tu32 res = 0;\n\n\tfor (i = 0; i < 4; i++)\n\t\tres |= ((u32)(*p++)) << (8 * i);\n\treturn res;\n}\n\nstatic void secmicputuint32(u8 *p, u32 val)\n \n{\n\tlong i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\t*p++ = (u8)(val & 0xff);\n\t\tval >>= 8;\n\t}\n}\n\nstatic void secmicclear(struct mic_data *pmicdata)\n{\n \n\tpmicdata->L = pmicdata->K0;\n\tpmicdata->R = pmicdata->K1;\n\tpmicdata->nBytesInM = 0;\n\tpmicdata->M = 0;\n}\n\nvoid r8712_secmicsetkey(struct mic_data *pmicdata, u8 *key)\n{\n\t \n\tpmicdata->K0 = secmicgetuint32(key);\n\tpmicdata->K1 = secmicgetuint32(key + 4);\n\t \n\tsecmicclear(pmicdata);\n}\n\nstatic void secmicappendbyte(struct mic_data *pmicdata, u8 b)\n{\n\t \n\tpmicdata->M |= ((u32)b) << (8 * pmicdata->nBytesInM);\n\tpmicdata->nBytesInM++;\n\t \n\tif (pmicdata->nBytesInM >= 4) {\n\t\tpmicdata->L ^= pmicdata->M;\n\t\tpmicdata->R ^= ROL32(pmicdata->L, 17);\n\t\tpmicdata->L += pmicdata->R;\n\t\tpmicdata->R ^= ((pmicdata->L & 0xff00ff00) >> 8) |\n\t\t\t       ((pmicdata->L & 0x00ff00ff) << 8);\n\t\tpmicdata->L += pmicdata->R;\n\t\tpmicdata->R ^= ROL32(pmicdata->L, 3);\n\t\tpmicdata->L += pmicdata->R;\n\t\tpmicdata->R ^= ROR32(pmicdata->L, 2);\n\t\tpmicdata->L += pmicdata->R;\n\t\t \n\t\tpmicdata->M = 0;\n\t\tpmicdata->nBytesInM = 0;\n\t}\n}\n\nvoid r8712_secmicappend(struct mic_data *pmicdata, u8 *src, u32 nbytes)\n{\n\t \n\twhile (nbytes > 0) {\n\t\tsecmicappendbyte(pmicdata, *src++);\n\t\tnbytes--;\n\t}\n}\n\nvoid r8712_secgetmic(struct mic_data *pmicdata, u8 *dst)\n{\n\t \n\tsecmicappendbyte(pmicdata, 0x5a);\n\tsecmicappendbyte(pmicdata, 0);\n\tsecmicappendbyte(pmicdata, 0);\n\tsecmicappendbyte(pmicdata, 0);\n\tsecmicappendbyte(pmicdata, 0);\n\t \n\twhile (pmicdata->nBytesInM != 0)\n\t\tsecmicappendbyte(pmicdata, 0);\n\t \n\tsecmicputuint32(dst, pmicdata->L);\n\tsecmicputuint32(dst + 4, pmicdata->R);\n\t \n\tsecmicclear(pmicdata);\n}\n\nvoid seccalctkipmic(u8 *key, u8 *header, u8 *data, u32 data_len, u8 *mic_code,\n\t\t    u8 pri)\n{\n\n\tstruct mic_data\tmicdata;\n\tu8 priority[4] = {0x0, 0x0, 0x0, 0x0};\n\n\tr8712_secmicsetkey(&micdata, key);\n\tpriority[0] = pri;\n\t \n\tif (header[1] & 1) {    \n\t\tr8712_secmicappend(&micdata, &header[16], 6);   \n\t\tif (header[1] & 2)   \n\t\t\tr8712_secmicappend(&micdata, &header[24], 6);\n\t\telse\n\t\t\tr8712_secmicappend(&micdata, &header[10], 6);\n\t} else {\t \n\t\tr8712_secmicappend(&micdata, &header[4], 6);    \n\t\tif (header[1] & 2)   \n\t\t\tr8712_secmicappend(&micdata, &header[16], 6);\n\t\telse\n\t\t\tr8712_secmicappend(&micdata, &header[10], 6);\n\t}\n\tr8712_secmicappend(&micdata, &priority[0], 4);\n\tr8712_secmicappend(&micdata, data, data_len);\n\tr8712_secgetmic(&micdata, mic_code);\n}\n\n \n#define RotR1(v16)   ((((v16) >> 1) & 0x7FFF) ^ (((v16) & 1) << 15))\n#define   Lo8(v16)   ((u8)((v16) & 0x00FF))\n#define   Hi8(v16)   ((u8)(((v16) >> 8) & 0x00FF))\n#define  Lo16(v32)   ((u16)((v32) & 0xFFFF))\n#define  Hi16(v32)   ((u16)(((v32) >> 16) & 0xFFFF))\n#define  Mk16(hi, lo) ((lo) ^ (((u16)(hi)) << 8))\n\n \n#define  TK16(N)  Mk16(tk[2 * (N) + 1], tk[2 * (N)])\n\n \n#define _S_(v16)  (Sbox1[0][Lo8(v16)] ^ Sbox1[1][Hi8(v16)])\n\n \n#define PHASE1_LOOP_CNT   8     \n#define TA_SIZE           6     \n#define TK_SIZE          16     \n#define P1K_SIZE         10     \n#define RC4_KEY_SIZE     16     \n\n \nstatic const unsigned short Sbox1[2][256] = { \n\t{\n\t0xC6A5, 0xF884, 0xEE99, 0xF68D, 0xFF0D, 0xD6BD, 0xDEB1, 0x9154,\n\t0x6050, 0x0203, 0xCEA9, 0x567D, 0xE719, 0xB562, 0x4DE6, 0xEC9A,\n\t0x8F45, 0x1F9D, 0x8940, 0xFA87, 0xEF15, 0xB2EB, 0x8EC9, 0xFB0B,\n\t0x41EC, 0xB367, 0x5FFD, 0x45EA, 0x23BF, 0x53F7, 0xE496, 0x9B5B,\n\t0x75C2, 0xE11C, 0x3DAE, 0x4C6A, 0x6C5A, 0x7E41, 0xF502, 0x834F,\n\t0x685C, 0x51F4, 0xD134, 0xF908, 0xE293, 0xAB73, 0x6253, 0x2A3F,\n\t0x080C, 0x9552, 0x4665, 0x9D5E, 0x3028, 0x37A1, 0x0A0F, 0x2FB5,\n\t0x0E09, 0x2436, 0x1B9B, 0xDF3D, 0xCD26, 0x4E69, 0x7FCD, 0xEA9F,\n\t0x121B, 0x1D9E, 0x5874, 0x342E, 0x362D, 0xDCB2, 0xB4EE, 0x5BFB,\n\t0xA4F6, 0x764D, 0xB761, 0x7DCE, 0x527B, 0xDD3E, 0x5E71, 0x1397,\n\t0xA6F5, 0xB968, 0x0000, 0xC12C, 0x4060, 0xE31F, 0x79C8, 0xB6ED,\n\t0xD4BE, 0x8D46, 0x67D9, 0x724B, 0x94DE, 0x98D4, 0xB0E8, 0x854A,\n\t0xBB6B, 0xC52A, 0x4FE5, 0xED16, 0x86C5, 0x9AD7, 0x6655, 0x1194,\n\t0x8ACF, 0xE910, 0x0406, 0xFE81, 0xA0F0, 0x7844, 0x25BA, 0x4BE3,\n\t0xA2F3, 0x5DFE, 0x80C0, 0x058A, 0x3FAD, 0x21BC, 0x7048, 0xF104,\n\t0x63DF, 0x77C1, 0xAF75, 0x4263, 0x2030, 0xE51A, 0xFD0E, 0xBF6D,\n\t0x814C, 0x1814, 0x2635, 0xC32F, 0xBEE1, 0x35A2, 0x88CC, 0x2E39,\n\t0x9357, 0x55F2, 0xFC82, 0x7A47, 0xC8AC, 0xBAE7, 0x322B, 0xE695,\n\t0xC0A0, 0x1998, 0x9ED1, 0xA37F, 0x4466, 0x547E, 0x3BAB, 0x0B83,\n\t0x8CCA, 0xC729, 0x6BD3, 0x283C, 0xA779, 0xBCE2, 0x161D, 0xAD76,\n\t0xDB3B, 0x6456, 0x744E, 0x141E, 0x92DB, 0x0C0A, 0x486C, 0xB8E4,\n\t0x9F5D, 0xBD6E, 0x43EF, 0xC4A6, 0x39A8, 0x31A4, 0xD337, 0xF28B,\n\t0xD532, 0x8B43, 0x6E59, 0xDAB7, 0x018C, 0xB164, 0x9CD2, 0x49E0,\n\t0xD8B4, 0xACFA, 0xF307, 0xCF25, 0xCAAF, 0xF48E, 0x47E9, 0x1018,\n\t0x6FD5, 0xF088, 0x4A6F, 0x5C72, 0x3824, 0x57F1, 0x73C7, 0x9751,\n\t0xCB23, 0xA17C, 0xE89C, 0x3E21, 0x96DD, 0x61DC, 0x0D86, 0x0F85,\n\t0xE090, 0x7C42, 0x71C4, 0xCCAA, 0x90D8, 0x0605, 0xF701, 0x1C12,\n\t0xC2A3, 0x6A5F, 0xAEF9, 0x69D0, 0x1791, 0x9958, 0x3A27, 0x27B9,\n\t0xD938, 0xEB13, 0x2BB3, 0x2233, 0xD2BB, 0xA970, 0x0789, 0x33A7,\n\t0x2DB6, 0x3C22, 0x1592, 0xC920, 0x8749, 0xAAFF, 0x5078, 0xA57A,\n\t0x038F, 0x59F8, 0x0980, 0x1A17, 0x65DA, 0xD731, 0x84C6, 0xD0B8,\n\t0x82C3, 0x29B0, 0x5A77, 0x1E11, 0x7BCB, 0xA8FC, 0x6DD6, 0x2C3A,\n\t},\n\t{   \n\t0xA5C6, 0x84F8, 0x99EE, 0x8DF6, 0x0DFF, 0xBDD6, 0xB1DE, 0x5491,\n\t0x5060, 0x0302, 0xA9CE, 0x7D56, 0x19E7, 0x62B5, 0xE64D, 0x9AEC,\n\t0x458F, 0x9D1F, 0x4089, 0x87FA, 0x15EF, 0xEBB2, 0xC98E, 0x0BFB,\n\t0xEC41, 0x67B3, 0xFD5F, 0xEA45, 0xBF23, 0xF753, 0x96E4, 0x5B9B,\n\t0xC275, 0x1CE1, 0xAE3D, 0x6A4C, 0x5A6C, 0x417E, 0x02F5, 0x4F83,\n\t0x5C68, 0xF451, 0x34D1, 0x08F9, 0x93E2, 0x73AB, 0x5362, 0x3F2A,\n\t0x0C08, 0x5295, 0x6546, 0x5E9D, 0x2830, 0xA137, 0x0F0A, 0xB52F,\n\t0x090E, 0x3624, 0x9B1B, 0x3DDF, 0x26CD, 0x694E, 0xCD7F, 0x9FEA,\n\t0x1B12, 0x9E1D, 0x7458, 0x2E34, 0x2D36, 0xB2DC, 0xEEB4, 0xFB5B,\n\t0xF6A4, 0x4D76, 0x61B7, 0xCE7D, 0x7B52, 0x3EDD, 0x715E, 0x9713,\n\t0xF5A6, 0x68B9, 0x0000, 0x2CC1, 0x6040, 0x1FE3, 0xC879, 0xEDB6,\n\t0xBED4, 0x468D, 0xD967, 0x4B72, 0xDE94, 0xD498, 0xE8B0, 0x4A85,\n\t0x6BBB, 0x2AC5, 0xE54F, 0x16ED, 0xC586, 0xD79A, 0x5566, 0x9411,\n\t0xCF8A, 0x10E9, 0x0604, 0x81FE, 0xF0A0, 0x4478, 0xBA25, 0xE34B,\n\t0xF3A2, 0xFE5D, 0xC080, 0x8A05, 0xAD3F, 0xBC21, 0x4870, 0x04F1,\n\t0xDF63, 0xC177, 0x75AF, 0x6342, 0x3020, 0x1AE5, 0x0EFD, 0x6DBF,\n\t0x4C81, 0x1418, 0x3526, 0x2FC3, 0xE1BE, 0xA235, 0xCC88, 0x392E,\n\t0x5793, 0xF255, 0x82FC, 0x477A, 0xACC8, 0xE7BA, 0x2B32, 0x95E6,\n\t0xA0C0, 0x9819, 0xD19E, 0x7FA3, 0x6644, 0x7E54, 0xAB3B, 0x830B,\n\t0xCA8C, 0x29C7, 0xD36B, 0x3C28, 0x79A7, 0xE2BC, 0x1D16, 0x76AD,\n\t0x3BDB, 0x5664, 0x4E74, 0x1E14, 0xDB92, 0x0A0C, 0x6C48, 0xE4B8,\n\t0x5D9F, 0x6EBD, 0xEF43, 0xA6C4, 0xA839, 0xA431, 0x37D3, 0x8BF2,\n\t0x32D5, 0x438B, 0x596E, 0xB7DA, 0x8C01, 0x64B1, 0xD29C, 0xE049,\n\t0xB4D8, 0xFAAC, 0x07F3, 0x25CF, 0xAFCA, 0x8EF4, 0xE947, 0x1810,\n\t0xD56F, 0x88F0, 0x6F4A, 0x725C, 0x2438, 0xF157, 0xC773, 0x5197,\n\t0x23CB, 0x7CA1, 0x9CE8, 0x213E, 0xDD96, 0xDC61, 0x860D, 0x850F,\n\t0x90E0, 0x427C, 0xC471, 0xAACC, 0xD890, 0x0506, 0x01F7, 0x121C,\n\t0xA3C2, 0x5F6A, 0xF9AE, 0xD069, 0x9117, 0x5899, 0x273A, 0xB927,\n\t0x38D9, 0x13EB, 0xB32B, 0x3322, 0xBBD2, 0x70A9, 0x8907, 0xA733,\n\t0xB62D, 0x223C, 0x9215, 0x20C9, 0x4987, 0xFFAA, 0x7850, 0x7AA5,\n\t0x8F03, 0xF859, 0x8009, 0x171A, 0xDA65, 0x31D7, 0xC684, 0xB8D0,\n\t0xC382, 0xB029, 0x775A, 0x111E, 0xCB7B, 0xFCA8, 0xD66D, 0x3A2C,\n\t}\n};\n\n \nstatic void phase1(u16 *p1k, const u8 *tk, const u8 *ta, u32 iv32)\n{\n\tsint  i;\n\n\t \n\tp1k[0] = Lo16(iv32);\n\tp1k[1] = Hi16(iv32);\n\tp1k[2] = Mk16(ta[1], ta[0]);  \n\tp1k[3] = Mk16(ta[3], ta[2]);\n\tp1k[4] = Mk16(ta[5], ta[4]);\n\t \n\t \n\tfor (i = 0; i < PHASE1_LOOP_CNT; i++) {   \n\t\tp1k[0] += _S_(p1k[4] ^ TK16((i & 1) + 0));\n\t\tp1k[1] += _S_(p1k[0] ^ TK16((i & 1) + 2));\n\t\tp1k[2] += _S_(p1k[1] ^ TK16((i & 1) + 4));\n\t\tp1k[3] += _S_(p1k[2] ^ TK16((i & 1) + 6));\n\t\tp1k[4] += _S_(p1k[3] ^ TK16((i & 1) + 0));\n\t\tp1k[4] +=  (unsigned short)i;\t \n\t}\n}\n\n \nstatic void phase2(u8 *rc4key, const u8 *tk, const u16 *p1k, u16 iv16)\n{\n\tsint  i;\n\tu16 PPK[6];\t\t\t \n\n\t \n\tfor (i = 0; i < 5; i++)\n\t\tPPK[i] = p1k[i];  \n\tPPK[5]  =  p1k[4] + iv16;  \n\t \n\tPPK[0] += _S_(PPK[5] ^ TK16(0));    \n\tPPK[1] += _S_(PPK[0] ^ TK16(1));\n\tPPK[2] += _S_(PPK[1] ^ TK16(2));\n\tPPK[3] += _S_(PPK[2] ^ TK16(3));\n\tPPK[4] += _S_(PPK[3] ^ TK16(4));\n\tPPK[5] += _S_(PPK[4] ^ TK16(5));    \n\t \n\tPPK[0] +=  RotR1(PPK[5] ^ TK16(6));\n\tPPK[1] +=  RotR1(PPK[0] ^ TK16(7));    \n\tPPK[2] +=  RotR1(PPK[1]);\n\tPPK[3] +=  RotR1(PPK[2]);\n\tPPK[4] +=  RotR1(PPK[3]);\n\tPPK[5] +=  RotR1(PPK[4]);\n\t \n\t \n\t \n\t \n\t \n\trc4key[0] = Hi8(iv16);  \n\trc4key[1] = (Hi8(iv16) | 0x20) & 0x7F;  \n\trc4key[2] = Lo8(iv16);\n\trc4key[3] = Lo8((PPK[5] ^ TK16(0)) >> 1);\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\trc4key[4 + 2 * i] = Lo8(PPK[i]);\n\t\trc4key[5 + 2 * i] = Hi8(PPK[i]);\n\t}\n}\n\n \nu32 r8712_tkip_encrypt(struct _adapter *padapter, u8 *pxmitframe)\n{\t \n\tu16 pnl;\n\tu32 pnh;\n\tu8 rc4key[16];\n\tu8 ttkey[16];\n\tu8 crc[4];\n\tstruct arc4context mycontext;\n\tu32 curfragnum, length;\n\n\tu8 *pframe, *payload, *iv, *prwskey;\n\tunion pn48 txpn;\n\tstruct sta_info *stainfo;\n\tstruct pkt_attrib *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tu32 res = _SUCCESS;\n\n\tif (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)\n\t\treturn _FAIL;\n\n\tpframe = ((struct xmit_frame *)pxmitframe)->buf_addr + TXDESC_OFFSET;\n\t \n\tif (pattrib->encrypt == _TKIP_) {\n\t\tif (pattrib->psta)\n\t\t\tstainfo = pattrib->psta;\n\t\telse\n\t\t\tstainfo = r8712_get_stainfo(&padapter->stapriv,\n\t\t\t\t  &pattrib->ra[0]);\n\t\tif (stainfo) {\n\t\t\tprwskey = &stainfo->x_UncstKey.skey[0];\n\t\t\tfor (curfragnum = 0; curfragnum < pattrib->nr_frags;\n\t\t\t     curfragnum++) {\n\t\t\t\tiv = pframe + pattrib->hdrlen;\n\t\t\t\tpayload = pframe + pattrib->iv_len +\n\t\t\t\t\t  pattrib->hdrlen;\n\t\t\t\tGET_TKIP_PN(iv, txpn);\n\t\t\t\tpnl = (u16)(txpn.val);\n\t\t\t\tpnh = (u32)(txpn.val >> 16);\n\t\t\t\tphase1((u16 *)&ttkey[0], prwskey,\n\t\t\t\t       &pattrib->ta[0], pnh);\n\t\t\t\tphase2(&rc4key[0], prwskey, (u16 *)&ttkey[0],\n\t\t\t\t       pnl);\n\t\t\t\tif ((curfragnum + 1) == pattrib->nr_frags) {\n\t\t\t\t\t \n\t\t\t\t\tlength = pattrib->last_txcmdsz -\n\t\t\t\t\t     pattrib->hdrlen -\n\t\t\t\t\t     pattrib->iv_len -\n\t\t\t\t\t     pattrib->icv_len;\n\t\t\t\t\t*((__le32 *)crc) = cpu_to_le32(\n\t\t\t\t\t\tgetcrc32(payload, length));\n\t\t\t\t\tarcfour_init(&mycontext, rc4key, 16);\n\t\t\t\t\tarcfour_encrypt(&mycontext, payload,\n\t\t\t\t\t\t\tpayload, length);\n\t\t\t\t\tarcfour_encrypt(&mycontext, payload +\n\t\t\t\t\t\t\tlength, crc, 4);\n\t\t\t\t} else {\n\t\t\t\t\tlength = pxmitpriv->frag_len -\n\t\t\t\t\t\t pattrib->hdrlen -\n\t\t\t\t\t\t pattrib->iv_len -\n\t\t\t\t\t\t pattrib->icv_len;\n\t\t\t\t\t*((__le32 *)crc) = cpu_to_le32(getcrc32(\n\t\t\t\t\t\t\tpayload, length));\n\t\t\t\t\tarcfour_init(&mycontext, rc4key, 16);\n\t\t\t\t\tarcfour_encrypt(&mycontext, payload,\n\t\t\t\t\t\t\t payload, length);\n\t\t\t\t\tarcfour_encrypt(&mycontext,\n\t\t\t\t\t\t\tpayload + length, crc,\n\t\t\t\t\t\t\t4);\n\t\t\t\t\tpframe += pxmitpriv->frag_len;\n\t\t\t\t\tpframe = (u8 *)RND4((addr_t)(pframe));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tres = _FAIL;\n\t\t}\n\t}\n\treturn res;\n}\n\n \nvoid r8712_tkip_decrypt(struct _adapter *padapter, u8 *precvframe)\n{\t \n\tu16 pnl;\n\tu32 pnh;\n\tu8 rc4key[16];\n\tu8 ttkey[16];\n\tu8 crc[4];\n\tstruct arc4context mycontext;\n\tu32 length;\n\tu8 *pframe, *payload, *iv, *prwskey, idx = 0;\n\tunion pn48 txpn;\n\tstruct\tsta_info *stainfo;\n\tstruct\trx_pkt_attrib *prxattrib = &((union recv_frame *)\n\t\t\t\t\t   precvframe)->u.hdr.attrib;\n\tstruct\tsecurity_priv\t*psecuritypriv = &padapter->securitypriv;\n\n\tpframe = (unsigned char *)((union recv_frame *)\n\t\t\t\t   precvframe)->u.hdr.rx_data;\n\t \n\tif (prxattrib->encrypt == _TKIP_) {\n\t\tstainfo = r8712_get_stainfo(&padapter->stapriv,\n\t\t\t\t\t    &prxattrib->ta[0]);\n\t\tif (stainfo) {\n\t\t\tiv = pframe + prxattrib->hdrlen;\n\t\t\tpayload = pframe + prxattrib->iv_len +\n\t\t\t\t  prxattrib->hdrlen;\n\t\t\tlength = ((union recv_frame *)precvframe)->\n\t\t\t\t u.hdr.len - prxattrib->hdrlen -\n\t\t\t\t prxattrib->iv_len;\n\t\t\tif (is_multicast_ether_addr(prxattrib->ra)) {\n\t\t\t\tidx = iv[3];\n\t\t\t\tprwskey = &psecuritypriv->XGrpKey[\n\t\t\t\t\t ((idx >> 6) & 0x3) - 1].skey[0];\n\t\t\t\tif (!psecuritypriv->binstallGrpkey)\n\t\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tprwskey = &stainfo->x_UncstKey.skey[0];\n\t\t\t}\n\t\t\tGET_TKIP_PN(iv, txpn);\n\t\t\tpnl = (u16)(txpn.val);\n\t\t\tpnh = (u32)(txpn.val >> 16);\n\t\t\tphase1((u16 *)&ttkey[0], prwskey, &prxattrib->ta[0],\n\t\t\t\tpnh);\n\t\t\tphase2(&rc4key[0], prwskey, (unsigned short *)\n\t\t\t       &ttkey[0], pnl);\n\t\t\t \n\t\t\tarcfour_init(&mycontext, rc4key, 16);\n\t\t\tarcfour_encrypt(&mycontext, payload, payload, length);\n\t\t\t*((__le32 *)crc) = cpu_to_le32(getcrc32(payload,\n\t\t\t\t\tlength - 4));\n\t\t}\n\t}\n}\n\n \n\n#define MAX_MSG_SIZE\t2048\n \n \n \n\nstatic const u8 sbox_table[256] = {\n\t0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n\t0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n\t0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n\t0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n\t0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n\t0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n\t0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n\t0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n\t0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n\t0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n\t0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n\t0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n\t0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n\t0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n\t0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n\t0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n\t0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n\t0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n\t0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n\t0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n\t0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n\t0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n\t0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n\t0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n\t0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n\t0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n\t0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n\t0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n\t0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n\t0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n\t0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n\t0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n};\n\n \n \n \n \n \nstatic void xor_128(u8 *a, u8 *b, u8 *out)\n{\n\tsint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tout[i] = a[i] ^ b[i];\n}\n\nstatic void xor_32(u8 *a, u8 *b, u8 *out)\n{\n\tsint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tout[i] = a[i] ^ b[i];\n}\n\nstatic u8 sbox(u8 a)\n{\n\treturn sbox_table[(sint)a];\n}\n\nstatic void next_key(u8 *key, sint round)\n{\n\tu8 rcon;\n\tu8 sbox_key[4];\n\tstatic const u8 rcon_table[12] = {\n\t\t0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,\n\t\t0x1b, 0x36, 0x36, 0x36\n\t};\n\n\tsbox_key[0] = sbox(key[13]);\n\tsbox_key[1] = sbox(key[14]);\n\tsbox_key[2] = sbox(key[15]);\n\tsbox_key[3] = sbox(key[12]);\n\trcon = rcon_table[round];\n\txor_32(&key[0], sbox_key, &key[0]);\n\tkey[0] = key[0] ^ rcon;\n\txor_32(&key[4], &key[0], &key[4]);\n\txor_32(&key[8], &key[4], &key[8]);\n\txor_32(&key[12], &key[8], &key[12]);\n}\n\nstatic void byte_sub(u8 *in, u8 *out)\n{\n\tsint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tout[i] = sbox(in[i]);\n}\n\nstatic void shift_row(u8 *in, u8 *out)\n{\n\tout[0] =  in[0];\n\tout[1] =  in[5];\n\tout[2] =  in[10];\n\tout[3] =  in[15];\n\tout[4] =  in[4];\n\tout[5] =  in[9];\n\tout[6] =  in[14];\n\tout[7] =  in[3];\n\tout[8] =  in[8];\n\tout[9] =  in[13];\n\tout[10] = in[2];\n\tout[11] = in[7];\n\tout[12] = in[12];\n\tout[13] = in[1];\n\tout[14] = in[6];\n\tout[15] = in[11];\n}\n\nstatic void mix_column(u8 *in, u8 *out)\n{\n\tsint i;\n\tu8 add1b[4];\n\tu8 add1bf7[4];\n\tu8 rotl[4];\n\tu8 swap_halves[4];\n\tu8 andf7[4];\n\tu8 rotr[4];\n\tu8 temp[4];\n\tu8 tempb[4];\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif ((in[i] & 0x80) == 0x80)\n\t\t\tadd1b[i] = 0x1b;\n\t\telse\n\t\t\tadd1b[i] = 0x00;\n\t}\n\tswap_halves[0] = in[2];     \n\tswap_halves[1] = in[3];\n\tswap_halves[2] = in[0];\n\tswap_halves[3] = in[1];\n\trotl[0] = in[3];         \n\trotl[1] = in[0];\n\trotl[2] = in[1];\n\trotl[3] = in[2];\n\tandf7[0] = in[0] & 0x7f;\n\tandf7[1] = in[1] & 0x7f;\n\tandf7[2] = in[2] & 0x7f;\n\tandf7[3] = in[3] & 0x7f;\n\tfor (i = 3; i > 0; i--) {    \n\t\tandf7[i] = andf7[i] << 1;\n\t\tif ((andf7[i - 1] & 0x80) == 0x80)\n\t\t\tandf7[i] = (andf7[i] | 0x01);\n\t}\n\tandf7[0] = andf7[0] << 1;\n\tandf7[0] = andf7[0] & 0xfe;\n\txor_32(add1b, andf7, add1bf7);\n\txor_32(in, add1bf7, rotr);\n\ttemp[0] = rotr[0];          \n\trotr[0] = rotr[1];\n\trotr[1] = rotr[2];\n\trotr[2] = rotr[3];\n\trotr[3] = temp[0];\n\txor_32(add1bf7, rotr, temp);\n\txor_32(swap_halves, rotl, tempb);\n\txor_32(temp, tempb, out);\n}\n\nstatic void aes128k128d(u8 *key, u8 *data, u8 *ciphertext)\n{\n\tsint round;\n\tsint i;\n\tu8 intermediatea[16];\n\tu8 intermediateb[16];\n\tu8 round_key[16];\n\n\tfor (i = 0; i < 16; i++)\n\t\tround_key[i] = key[i];\n\tfor (round = 0; round < 11; round++) {\n\t\tif (round == 0) {\n\t\t\txor_128(round_key, data, ciphertext);\n\t\t\tnext_key(round_key, round);\n\t\t} else if (round == 10) {\n\t\t\tbyte_sub(ciphertext, intermediatea);\n\t\t\tshift_row(intermediatea, intermediateb);\n\t\t\txor_128(intermediateb, round_key, ciphertext);\n\t\t} else {    \n\t\t\tbyte_sub(ciphertext, intermediatea);\n\t\t\tshift_row(intermediatea, intermediateb);\n\t\t\tmix_column(&intermediateb[0], &intermediatea[0]);\n\t\t\tmix_column(&intermediateb[4], &intermediatea[4]);\n\t\t\tmix_column(&intermediateb[8], &intermediatea[8]);\n\t\t\tmix_column(&intermediateb[12], &intermediatea[12]);\n\t\t\txor_128(intermediatea, round_key, ciphertext);\n\t\t\tnext_key(round_key, round);\n\t\t}\n\t}\n}\n\n \n \n \n \nstatic void construct_mic_iv(u8 *mic_iv, sint qc_exists, sint a4_exists,\n\t\t\t     u8 *mpdu, uint payload_length, u8 *pn_vector)\n{\n\tsint i;\n\n\tmic_iv[0] = 0x59;\n\tif (qc_exists && a4_exists)\n\t\tmic_iv[1] = mpdu[30] & 0x0f;     \n\tif (qc_exists && !a4_exists)\n\t\tmic_iv[1] = mpdu[24] & 0x0f;    \n\tif (!qc_exists)\n\t\tmic_iv[1] = 0x00;\n\tfor (i = 2; i < 8; i++)\n\t\tmic_iv[i] = mpdu[i + 8];\n\tfor (i = 8; i < 14; i++)\n\t\tmic_iv[i] = pn_vector[13 - i];  \n\tmic_iv[14] = (unsigned char)(payload_length / 256);\n\tmic_iv[15] = (unsigned char)(payload_length % 256);\n}\n\n \n \n \n \n \nstatic void construct_mic_header1(u8 *mic_header1, sint header_length, u8 *mpdu)\n{\n\tmic_header1[0] = (u8)((header_length - 2) / 256);\n\tmic_header1[1] = (u8)((header_length - 2) % 256);\n\tmic_header1[2] = mpdu[0] & 0xcf;     \n\t \n\tmic_header1[3] = mpdu[1] & 0xc7;\n\tmic_header1[4] = mpdu[4];        \n\tmic_header1[5] = mpdu[5];\n\tmic_header1[6] = mpdu[6];\n\tmic_header1[7] = mpdu[7];\n\tmic_header1[8] = mpdu[8];\n\tmic_header1[9] = mpdu[9];\n\tmic_header1[10] = mpdu[10];      \n\tmic_header1[11] = mpdu[11];\n\tmic_header1[12] = mpdu[12];\n\tmic_header1[13] = mpdu[13];\n\tmic_header1[14] = mpdu[14];\n\tmic_header1[15] = mpdu[15];\n}\n\n \n \n \n \n \nstatic void construct_mic_header2(u8 *mic_header2, u8 *mpdu, sint a4_exists,\n\t\t\t   sint qc_exists)\n{\n\tsint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tmic_header2[i] = 0x00;\n\tmic_header2[0] = mpdu[16];     \n\tmic_header2[1] = mpdu[17];\n\tmic_header2[2] = mpdu[18];\n\tmic_header2[3] = mpdu[19];\n\tmic_header2[4] = mpdu[20];\n\tmic_header2[5] = mpdu[21];\n\tmic_header2[6] = 0x00;\n\tmic_header2[7] = 0x00;  \n\tif (!qc_exists && a4_exists)\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tmic_header2[8 + i] = mpdu[24 + i];    \n\tif (qc_exists && !a4_exists) {\n\t\tmic_header2[8] = mpdu[24] & 0x0f;  \n\t\tmic_header2[9] = mpdu[25] & 0x00;\n\t}\n\tif (qc_exists && a4_exists) {\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tmic_header2[8 + i] = mpdu[24 + i];    \n\t\tmic_header2[14] = mpdu[30] & 0x0f;\n\t\tmic_header2[15] = mpdu[31] & 0x00;\n\t}\n}\n\n \n \n \n \n \nstatic void construct_ctr_preload(u8 *ctr_preload,\n\t\t\t\t  sint a4_exists, sint qc_exists,\n\t\t\t\t  u8 *mpdu, u8 *pn_vector, sint c)\n{\n\tsint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tctr_preload[i] = 0x00;\n\ti = 0;\n\tctr_preload[0] = 0x01;     \n\tif (qc_exists && a4_exists)\n\t\tctr_preload[1] = mpdu[30] & 0x0f;\n\tif (qc_exists && !a4_exists)\n\t\tctr_preload[1] = mpdu[24] & 0x0f;\n\tfor (i = 2; i < 8; i++)\n\t\tctr_preload[i] = mpdu[i + 8];\n\tfor (i = 8; i < 14; i++)\n\t\tctr_preload[i] = pn_vector[13 - i];\n\tctr_preload[14] = (unsigned char)(c / 256);  \n\tctr_preload[15] = (unsigned char)(c % 256);\n}\n\n \n \n \n \nstatic void bitwise_xor(u8 *ina, u8 *inb, u8 *out)\n{\n\tsint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tout[i] = ina[i] ^ inb[i];\n}\n\nstatic void aes_cipher(u8 *key, uint hdrlen,\n\t\t       u8 *pframe, uint plen)\n{\n\tuint qc_exists, a4_exists, i, j, payload_remainder;\n\tuint num_blocks, payload_index;\n\n\tu8 pn_vector[6];\n\tu8 mic_iv[16];\n\tu8 mic_header1[16];\n\tu8 mic_header2[16];\n\tu8 ctr_preload[16];\n\n\t \n\tu8 chain_buffer[16];\n\tu8 aes_out[16];\n\tu8 padded_buffer[16];\n\tu8 mic[8];\n\tu16 frtype  = GetFrameType(pframe);\n\tu16 frsubtype  = GetFrameSubType(pframe);\n\n\tfrsubtype >>= 4;\n\tmemset((void *)mic_iv, 0, 16);\n\tmemset((void *)mic_header1, 0, 16);\n\tmemset((void *)mic_header2, 0, 16);\n\tmemset((void *)ctr_preload, 0, 16);\n\tmemset((void *)chain_buffer, 0, 16);\n\tmemset((void *)aes_out, 0, 16);\n\tmemset((void *)padded_buffer, 0, 16);\n\n\tif ((hdrlen == WLAN_HDR_A3_LEN) || (hdrlen ==  WLAN_HDR_A3_QOS_LEN))\n\t\ta4_exists = 0;\n\telse\n\t\ta4_exists = 1;\n\n\tif ((frtype == (IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA_CFACK)) ||\n\t    (frtype == (IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA_CFPOLL)) ||\n\t    (frtype == (IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA_CFACKPOLL))) {\n\t\tqc_exists = 1;\n\t\tif (hdrlen !=  WLAN_HDR_A3_QOS_LEN)\n\t\t\thdrlen += 2;\n\t} else if ((frsubtype == 0x08) ||\n\t\t   (frsubtype == 0x09) ||\n\t\t   (frsubtype == 0x0a) ||\n\t\t   (frsubtype == 0x0b)) {\n\t\tif (hdrlen !=  WLAN_HDR_A3_QOS_LEN)\n\t\t\thdrlen += 2;\n\t\tqc_exists = 1;\n\t} else {\n\t\tqc_exists = 0;\n\t}\n\tpn_vector[0] = pframe[hdrlen];\n\tpn_vector[1] = pframe[hdrlen + 1];\n\tpn_vector[2] = pframe[hdrlen + 4];\n\tpn_vector[3] = pframe[hdrlen + 5];\n\tpn_vector[4] = pframe[hdrlen + 6];\n\tpn_vector[5] = pframe[hdrlen + 7];\n\tconstruct_mic_iv(mic_iv, qc_exists, a4_exists, pframe, plen, pn_vector);\n\tconstruct_mic_header1(mic_header1, hdrlen, pframe);\n\tconstruct_mic_header2(mic_header2, pframe, a4_exists, qc_exists);\n\tpayload_remainder = plen % 16;\n\tnum_blocks = plen / 16;\n\t \n\tpayload_index = hdrlen + 8;\n\t \n\taes128k128d(key, mic_iv, aes_out);\n\tbitwise_xor(aes_out, mic_header1, chain_buffer);\n\taes128k128d(key, chain_buffer, aes_out);\n\tbitwise_xor(aes_out, mic_header2, chain_buffer);\n\taes128k128d(key, chain_buffer, aes_out);\n\tfor (i = 0; i < num_blocks; i++) {\n\t\tbitwise_xor(aes_out, &pframe[payload_index], chain_buffer);\n\t\tpayload_index += 16;\n\t\taes128k128d(key, chain_buffer, aes_out);\n\t}\n\t \n\tif (payload_remainder > 0) {\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tpadded_buffer[j] = 0x00;\n\t\tfor (j = 0; j < payload_remainder; j++)\n\t\t\tpadded_buffer[j] = pframe[payload_index++];\n\t\tbitwise_xor(aes_out, padded_buffer, chain_buffer);\n\t\taes128k128d(key, chain_buffer, aes_out);\n\t}\n\tfor (j = 0; j < 8; j++)\n\t\tmic[j] = aes_out[j];\n\t \n\tfor (j = 0; j < 8; j++)\n\t\tpframe[payload_index + j] = mic[j];\n\tpayload_index = hdrlen + 8;\n\tfor (i = 0; i < num_blocks; i++) {\n\t\tconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\n\t\t\t\t      pframe, pn_vector, i + 1);\n\t\taes128k128d(key, ctr_preload, aes_out);\n\t\tbitwise_xor(aes_out, &pframe[payload_index], chain_buffer);\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tpframe[payload_index++] = chain_buffer[j];\n\t}\n\tif (payload_remainder > 0) {   \n\t\t\t\t       \n\t\tconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\n\t\t\t\t      pframe, pn_vector, num_blocks + 1);\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tpadded_buffer[j] = 0x00;\n\t\tfor (j = 0; j < payload_remainder; j++)\n\t\t\tpadded_buffer[j] = pframe[payload_index + j];\n\t\taes128k128d(key, ctr_preload, aes_out);\n\t\tbitwise_xor(aes_out, padded_buffer, chain_buffer);\n\t\tfor (j = 0; j < payload_remainder; j++)\n\t\t\tpframe[payload_index++] = chain_buffer[j];\n\t}\n\t \n\tconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\n\t\t\t      pframe, pn_vector, 0);\n\tfor (j = 0; j < 16; j++)\n\t\tpadded_buffer[j] = 0x00;\n\tfor (j = 0; j < 8; j++)\n\t\tpadded_buffer[j] = pframe[j + hdrlen + 8 + plen];\n\taes128k128d(key, ctr_preload, aes_out);\n\tbitwise_xor(aes_out, padded_buffer, chain_buffer);\n\tfor (j = 0; j < 8; j++)\n\t\tpframe[payload_index++] = chain_buffer[j];\n}\n\nu32 r8712_aes_encrypt(struct _adapter *padapter, u8 *pxmitframe)\n{\t \n\t \n\tsint\tcurfragnum, length;\n\tu8\t*pframe, *prwskey;\n\tstruct\tsta_info *stainfo;\n\tstruct\tpkt_attrib  *pattrib = &((struct xmit_frame *)\n\t\t\t\t       pxmitframe)->attrib;\n\tstruct\txmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tu32 res = _SUCCESS;\n\n\tif (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)\n\t\treturn _FAIL;\n\tpframe = ((struct xmit_frame *)pxmitframe)->buf_addr + TXDESC_OFFSET;\n\t \n\tif (pattrib->encrypt == _AES_) {\n\t\tif (pattrib->psta)\n\t\t\tstainfo = pattrib->psta;\n\t\telse\n\t\t\tstainfo = r8712_get_stainfo(&padapter->stapriv,\n\t\t\t\t  &pattrib->ra[0]);\n\t\tif (stainfo) {\n\t\t\tprwskey = &stainfo->x_UncstKey.skey[0];\n\t\t\tfor (curfragnum = 0; curfragnum < pattrib->nr_frags;\n\t\t\t     curfragnum++) {\n\t\t\t\tif ((curfragnum + 1) == pattrib->nr_frags) {\n\t\t\t\t\tlength = pattrib->last_txcmdsz -\n\t\t\t\t\t\t pattrib->hdrlen -\n\t\t\t\t\t\t pattrib->iv_len -\n\t\t\t\t\t\t pattrib->icv_len;\n\t\t\t\t\taes_cipher(prwskey, pattrib->hdrlen,\n\t\t\t\t\t\t   pframe, length);\n\t\t\t\t} else {\n\t\t\t\t\tlength = pxmitpriv->frag_len -\n\t\t\t\t\t\t pattrib->hdrlen -\n\t\t\t\t\t\t pattrib->iv_len -\n\t\t\t\t\t\t pattrib->icv_len;\n\t\t\t\t\taes_cipher(prwskey, pattrib->hdrlen,\n\t\t\t\t\t\t   pframe, length);\n\t\t\t\t\tpframe += pxmitpriv->frag_len;\n\t\t\t\t\tpframe = (u8 *)RND4((addr_t)(pframe));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tres = _FAIL;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic void aes_decipher(u8 *key, uint hdrlen,\n\t\t\t u8 *pframe, uint plen)\n{\n\tstatic u8 message[MAX_MSG_SIZE];\n\tuint qc_exists, a4_exists, i, j, payload_remainder;\n\tuint num_blocks, payload_index;\n\tu8 pn_vector[6];\n\tu8 mic_iv[16];\n\tu8 mic_header1[16];\n\tu8 mic_header2[16];\n\tu8 ctr_preload[16];\n\t \n\tu8 chain_buffer[16];\n\tu8 aes_out[16];\n\tu8 padded_buffer[16];\n\tu8 mic[8];\n\tuint frtype  = GetFrameType(pframe);\n\tuint frsubtype  = GetFrameSubType(pframe);\n\n\tfrsubtype >>= 4;\n\tmemset((void *)mic_iv, 0, 16);\n\tmemset((void *)mic_header1, 0, 16);\n\tmemset((void *)mic_header2, 0, 16);\n\tmemset((void *)ctr_preload, 0, 16);\n\tmemset((void *)chain_buffer, 0, 16);\n\tmemset((void *)aes_out, 0, 16);\n\tmemset((void *)padded_buffer, 0, 16);\n\t \n\t \n\tnum_blocks = (plen - 8) / 16;\n\tpayload_remainder = (plen - 8) % 16;\n\tpn_vector[0] = pframe[hdrlen];\n\tpn_vector[1] = pframe[hdrlen + 1];\n\tpn_vector[2] = pframe[hdrlen + 4];\n\tpn_vector[3] = pframe[hdrlen + 5];\n\tpn_vector[4] = pframe[hdrlen + 6];\n\tpn_vector[5] = pframe[hdrlen + 7];\n\tif ((hdrlen == WLAN_HDR_A3_LEN) || (hdrlen ==  WLAN_HDR_A3_QOS_LEN))\n\t\ta4_exists = 0;\n\telse\n\t\ta4_exists = 1;\n\tif ((frtype == (IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA_CFACK)) ||\n\t    (frtype == (IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA_CFPOLL)) ||\n\t    (frtype == (IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA_CFACKPOLL))) {\n\t\tqc_exists = 1;\n\t\tif (hdrlen != WLAN_HDR_A3_QOS_LEN)\n\t\t\thdrlen += 2;\n\t} else if ((frsubtype == 0x08) ||\n\t\t   (frsubtype == 0x09) ||\n\t\t   (frsubtype == 0x0a) ||\n\t\t   (frsubtype == 0x0b)) {\n\t\tif (hdrlen != WLAN_HDR_A3_QOS_LEN)\n\t\t\thdrlen += 2;\n\t\tqc_exists = 1;\n\t} else {\n\t\tqc_exists = 0;\n\t}\n\t \n\tpayload_index = hdrlen + 8;  \n\tfor (i = 0; i < num_blocks; i++) {\n\t\tconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\n\t\t\t\t      pframe, pn_vector, i + 1);\n\t\taes128k128d(key, ctr_preload, aes_out);\n\t\tbitwise_xor(aes_out, &pframe[payload_index], chain_buffer);\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tpframe[payload_index++] = chain_buffer[j];\n\t}\n\tif (payload_remainder > 0) {   \n\t\t \n\t\tconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\n\t\t\t\t      pframe, pn_vector, num_blocks + 1);\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tpadded_buffer[j] = 0x00;\n\t\tfor (j = 0; j < payload_remainder; j++)\n\t\t\tpadded_buffer[j] = pframe[payload_index + j];\n\t\taes128k128d(key, ctr_preload, aes_out);\n\t\tbitwise_xor(aes_out, padded_buffer, chain_buffer);\n\t\tfor (j = 0; j < payload_remainder; j++)\n\t\t\tpframe[payload_index++] = chain_buffer[j];\n\t}\n\t \n\tmemcpy((void *)message, pframe, (hdrlen + plen + 8));\n\tpn_vector[0] = pframe[hdrlen];\n\tpn_vector[1] = pframe[hdrlen + 1];\n\tpn_vector[2] = pframe[hdrlen + 4];\n\tpn_vector[3] = pframe[hdrlen + 5];\n\tpn_vector[4] = pframe[hdrlen + 6];\n\tpn_vector[5] = pframe[hdrlen + 7];\n\tconstruct_mic_iv(mic_iv, qc_exists, a4_exists, message, plen - 8,\n\t\t\t pn_vector);\n\tconstruct_mic_header1(mic_header1, hdrlen, message);\n\tconstruct_mic_header2(mic_header2, message, a4_exists, qc_exists);\n\tpayload_remainder = (plen - 8) % 16;\n\tnum_blocks = (plen - 8) / 16;\n\t \n\tpayload_index = hdrlen + 8;\n\t \n\taes128k128d(key, mic_iv, aes_out);\n\tbitwise_xor(aes_out, mic_header1, chain_buffer);\n\taes128k128d(key, chain_buffer, aes_out);\n\tbitwise_xor(aes_out, mic_header2, chain_buffer);\n\taes128k128d(key, chain_buffer, aes_out);\n\tfor (i = 0; i < num_blocks; i++) {\n\t\tbitwise_xor(aes_out, &message[payload_index], chain_buffer);\n\t\tpayload_index += 16;\n\t\taes128k128d(key, chain_buffer, aes_out);\n\t}\n\t \n\tif (payload_remainder > 0) {\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tpadded_buffer[j] = 0x00;\n\t\tfor (j = 0; j < payload_remainder; j++)\n\t\t\tpadded_buffer[j] = message[payload_index++];\n\t\tbitwise_xor(aes_out, padded_buffer, chain_buffer);\n\t\taes128k128d(key, chain_buffer, aes_out);\n\t}\n\tfor (j = 0; j < 8; j++)\n\t\tmic[j] = aes_out[j];\n\t \n\tfor (j = 0; j < 8; j++)\n\t\tmessage[payload_index + j] = mic[j];\n\tpayload_index = hdrlen + 8;\n\tfor (i = 0; i < num_blocks; i++) {\n\t\tconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\n\t\t\t\t      message, pn_vector, i + 1);\n\t\taes128k128d(key, ctr_preload, aes_out);\n\t\tbitwise_xor(aes_out, &message[payload_index], chain_buffer);\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tmessage[payload_index++] = chain_buffer[j];\n\t}\n\tif (payload_remainder > 0) {  \n\t\t\t\t      \n\t\tconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\n\t\t\t\t      message, pn_vector, num_blocks + 1);\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tpadded_buffer[j] = 0x00;\n\t\tfor (j = 0; j < payload_remainder; j++)\n\t\t\tpadded_buffer[j] = message[payload_index + j];\n\t\taes128k128d(key, ctr_preload, aes_out);\n\t\tbitwise_xor(aes_out, padded_buffer, chain_buffer);\n\t\tfor (j = 0; j < payload_remainder; j++)\n\t\t\tmessage[payload_index++] = chain_buffer[j];\n\t}\n\t \n\tconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, message,\n\t\t\t      pn_vector, 0);\n\tfor (j = 0; j < 16; j++)\n\t\tpadded_buffer[j] = 0x00;\n\tfor (j = 0; j < 8; j++)\n\t\tpadded_buffer[j] = message[j + hdrlen + plen];\n\taes128k128d(key, ctr_preload, aes_out);\n\tbitwise_xor(aes_out, padded_buffer, chain_buffer);\n\tfor (j = 0; j < 8; j++)\n\t\tmessage[payload_index++] = chain_buffer[j];\n\t \n}\n\nvoid r8712_aes_decrypt(struct _adapter *padapter, u8 *precvframe)\n{\t \n\t \n\tsint\t\tlength;\n\tu8\t*pframe, *prwskey, *iv, idx;\n\tstruct\tsta_info *stainfo;\n\tstruct\trx_pkt_attrib *prxattrib = &((union recv_frame *)\n\t\t\t\t\t   precvframe)->u.hdr.attrib;\n\tstruct\tsecurity_priv *psecuritypriv = &padapter->securitypriv;\n\n\tpframe = (unsigned char *)((union recv_frame *)precvframe)->\n\t\t u.hdr.rx_data;\n\t \n\tif (prxattrib->encrypt == _AES_) {\n\t\tstainfo = r8712_get_stainfo(&padapter->stapriv,\n\t\t\t\t\t    &prxattrib->ta[0]);\n\t\tif (stainfo) {\n\t\t\tif (is_multicast_ether_addr(prxattrib->ra)) {\n\t\t\t\tiv = pframe + prxattrib->hdrlen;\n\t\t\t\tidx = iv[3];\n\t\t\t\tprwskey = &psecuritypriv->XGrpKey[\n\t\t\t\t\t  ((idx >> 6) & 0x3) - 1].skey[0];\n\t\t\t\tif (!psecuritypriv->binstallGrpkey)\n\t\t\t\t\treturn;\n\n\t\t\t} else {\n\t\t\t\tprwskey = &stainfo->x_UncstKey.skey[0];\n\t\t\t}\n\t\t\tlength = ((union recv_frame *)precvframe)->\n\t\t\t\t u.hdr.len - prxattrib->hdrlen -\n\t\t\t\t prxattrib->iv_len;\n\t\t\taes_decipher(prwskey, prxattrib->hdrlen, pframe,\n\t\t\t\t     length);\n\t\t}\n\t}\n}\n\nvoid r8712_use_tkipkey_handler(struct timer_list *t)\n{\n\tstruct _adapter *padapter =\n\t\tfrom_timer(padapter, t, securitypriv.tkip_timer);\n\n\tpadapter->securitypriv.busetkipkey = true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}