{
  "module_name": "recv_linux.c",
  "hash_id": "a0858acabedc31c6b246b2e789d9b4b62c5df7b46826bf95478bab26691f0898",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/recv_linux.c",
  "human_readable_source": "\n \n\n#define _RECV_OSDEP_C_\n\n#include <linux/usb.h>\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"wifi.h\"\n#include \"recv_osdep.h\"\n#include \"osdep_intf.h\"\n#include \"ethernet.h\"\n#include <linux/if_arp.h>\n#include \"usb_ops.h\"\n\n \n \nvoid r8712_os_recv_resource_alloc(struct _adapter *padapter,\n\t\t\t\t  union recv_frame *precvframe)\n{\n\tprecvframe->u.hdr.pkt_newalloc = NULL;\n\tprecvframe->u.hdr.pkt = NULL;\n}\n\n \nint r8712_os_recvbuf_resource_alloc(struct _adapter *padapter,\n\t\t\t\t    struct recv_buf *precvbuf)\n{\n\tint res = 0;\n\n\tprecvbuf->irp_pending = false;\n\tprecvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!precvbuf->purb)\n\t\tres = -ENOMEM;\n\tprecvbuf->pskb = NULL;\n\tprecvbuf->pallocated_buf = NULL;\n\tprecvbuf->pbuf = NULL;\n\tprecvbuf->pdata = NULL;\n\tprecvbuf->phead = NULL;\n\tprecvbuf->ptail = NULL;\n\tprecvbuf->pend = NULL;\n\tprecvbuf->transfer_len = 0;\n\tprecvbuf->len = 0;\n\treturn res;\n}\n\n \nvoid r8712_os_recvbuf_resource_free(struct _adapter *padapter,\n\t\t\t\t    struct recv_buf *precvbuf)\n{\n\tif (precvbuf->pskb)\n\t\tdev_kfree_skb_any(precvbuf->pskb);\n\tif (precvbuf->purb) {\n\t\tusb_kill_urb(precvbuf->purb);\n\t\tusb_free_urb(precvbuf->purb);\n\t}\n}\n\nvoid r8712_handle_tkip_mic_err(struct _adapter *adapter, u8 bgroup)\n{\n\tunion iwreq_data wrqu;\n\tstruct iw_michaelmicfailure ev;\n\tstruct mlme_priv *mlmepriv  = &adapter->mlmepriv;\n\n\tmemset(&ev, 0x00, sizeof(ev));\n\tif (bgroup)\n\t\tev.flags |= IW_MICFAILURE_GROUP;\n\telse\n\t\tev.flags |= IW_MICFAILURE_PAIRWISE;\n\tev.src_addr.sa_family = ARPHRD_ETHER;\n\tether_addr_copy(ev.src_addr.sa_data, &mlmepriv->assoc_bssid[0]);\n\tmemset(&wrqu, 0x00, sizeof(wrqu));\n\twrqu.data.length = sizeof(ev);\n\twireless_send_event(adapter->pnetdev, IWEVMICHAELMICFAILURE, &wrqu,\n\t\t\t    (char *)&ev);\n}\n\nvoid r8712_recv_indicatepkt(struct _adapter *adapter,\n\t\t\t    union recv_frame *recvframe)\n{\n\tstruct recv_priv *recvpriv;\n\tstruct  __queue\t*free_recv_queue;\n\t_pkt *skb;\n\tstruct rx_pkt_attrib *attrib = &recvframe->u.hdr.attrib;\n\n\trecvpriv = &adapter->recvpriv;\n\tfree_recv_queue = &recvpriv->free_recv_queue;\n\tskb = recvframe->u.hdr.pkt;\n\tif (!skb)\n\t\tgoto _recv_indicatepkt_drop;\n\tskb->data = recvframe->u.hdr.rx_data;\n\tskb->len = recvframe->u.hdr.len;\n\tskb_set_tail_pointer(skb, skb->len);\n\tif ((attrib->tcpchk_valid == 1) && (attrib->tcp_chkrpt == 1))\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\telse\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\tskb->dev = adapter->pnetdev;\n\tskb->protocol = eth_type_trans(skb, adapter->pnetdev);\n\tnetif_rx(skb);\n\trecvframe->u.hdr.pkt = NULL;  \n\tr8712_free_recvframe(recvframe, free_recv_queue);\n\treturn;\n_recv_indicatepkt_drop:\n\t  \n\tif (recvframe)\n\t\tr8712_free_recvframe(recvframe, free_recv_queue);\n\trecvpriv->rx_drop++;\n}\n\nstatic void _r8712_reordering_ctrl_timeout_handler (struct timer_list *t)\n{\n\tstruct recv_reorder_ctrl *reorder_ctrl =\n\t\t\t from_timer(reorder_ctrl, t, reordering_ctrl_timer);\n\n\tr8712_reordering_ctrl_timeout_handler(reorder_ctrl);\n}\n\nvoid r8712_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl)\n{\n\ttimer_setup(&preorder_ctrl->reordering_ctrl_timer,\n\t\t    _r8712_reordering_ctrl_timeout_handler, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}