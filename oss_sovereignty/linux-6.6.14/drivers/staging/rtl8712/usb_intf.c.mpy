{
  "module_name": "usb_intf.c",
  "hash_id": "d945b7fddcf9a59398ac56e878c12750d2dc2d26b141bedd22750a665a146666",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/usb_intf.c",
  "human_readable_source": "\n \n\n#define _HCI_INTF_C_\n\n#include <linux/usb.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"recv_osdep.h\"\n#include \"xmit_osdep.h\"\n#include \"rtl8712_efuse.h\"\n#include \"usb_ops.h\"\n#include \"usb_osintf.h\"\n\nstatic struct usb_interface *pintf;\n\nstatic int r871xu_drv_init(struct usb_interface *pusb_intf,\n\t\t\t   const struct usb_device_id *pdid);\n\nstatic void r871xu_dev_remove(struct usb_interface *pusb_intf);\n\nstatic const struct usb_device_id rtl871x_usb_id_tbl[] = {\n \n\t \n\t{USB_DEVICE(0x0BDA, 0x8171)},\n\t{USB_DEVICE(0x0bda, 0x8173)},\n\t{USB_DEVICE(0x0bda, 0x8712)},\n\t{USB_DEVICE(0x0bda, 0x8713)},\n\t{USB_DEVICE(0x0bda, 0xC512)},\n\t \n\t{USB_DEVICE(0x07B8, 0x8188)},\n\t \n\t{USB_DEVICE(0x0B05, 0x1786)},\n\t{USB_DEVICE(0x0B05, 0x1791)},  \n\t \n\t{USB_DEVICE(0x050D, 0x945A)},\n\t \n\t{USB_DEVICE(0x050D, 0x11F1)},\n\t \n\t{USB_DEVICE(0x07AA, 0x0047)},\n\t \n\t{USB_DEVICE(0x2001, 0x3306)},\n\t{USB_DEVICE(0x07D1, 0x3306)},  \n\t \n\t{USB_DEVICE(0x7392, 0x7611)},\n\t \n\t{USB_DEVICE(0x1740, 0x9603)},\n\t \n\t{USB_DEVICE(0x0E66, 0x0016)},\n\t \n\t{USB_DEVICE(0x06F8, 0xE034)},\n\t{USB_DEVICE(0x06F8, 0xE032)},\n\t \n\t{USB_DEVICE(0x0789, 0x0167)},\n\t \n\t{USB_DEVICE(0x2019, 0xAB28)},\n\t{USB_DEVICE(0x2019, 0xED16)},\n\t \n\t{USB_DEVICE(0x0DF6, 0x0057)},\n\t{USB_DEVICE(0x0DF6, 0x0045)},\n\t{USB_DEVICE(0x0DF6, 0x0059)},  \n\t{USB_DEVICE(0x0DF6, 0x004B)},\n\t{USB_DEVICE(0x0DF6, 0x005B)},\n\t{USB_DEVICE(0x0DF6, 0x005D)},\n\t{USB_DEVICE(0x0DF6, 0x0063)},\n\t \n\t{USB_DEVICE(0x177F, 0x0154)},\n\t \n\t{USB_DEVICE(0x0BDA, 0x5077)},\n\t \n\t{USB_DEVICE(0x1690, 0x0752)},\n\t \n\t{USB_DEVICE(0x20F4, 0x646B)},\n\t{USB_DEVICE(0x083A, 0xC512)},\n\t{USB_DEVICE(0x25D4, 0x4CA1)},\n\t{USB_DEVICE(0x25D4, 0x4CAB)},\n\n \n\t \n\t{USB_DEVICE(0x0BDA, 0x8172)},\n\t{USB_DEVICE(0x0BDA, 0x8192)},\n\t \n\t{USB_DEVICE(0x0EB0, 0x9061)},\n\t \n\t{USB_DEVICE(0x13D3, 0x3323)},\n\t{USB_DEVICE(0x13D3, 0x3311)},  \n\t{USB_DEVICE(0x13D3, 0x3342)},\n\t \n\t{USB_DEVICE(0x13D3, 0x3333)},\n\t{USB_DEVICE(0x13D3, 0x3334)},\n\t{USB_DEVICE(0x13D3, 0x3335)},  \n\t{USB_DEVICE(0x13D3, 0x3336)},  \n\t \n\t{USB_DEVICE(0x13D3, 0x3309)},\n\t \n\t{USB_DEVICE(0x050D, 0x815F)},\n\t \n\t{USB_DEVICE(0x07D1, 0x3302)},\n\t{USB_DEVICE(0x07D1, 0x3300)},\n\t{USB_DEVICE(0x07D1, 0x3303)},\n\t \n\t{USB_DEVICE(0x7392, 0x7612)},\n\t \n\t{USB_DEVICE(0x1740, 0x9605)},\n\t \n\t{USB_DEVICE(0x06F8, 0xE031)},\n\t \n\t{USB_DEVICE(0x0E66, 0x0015)},\n\t \n\t{USB_DEVICE(0x13D3, 0x3306)},\n\t \n\t{USB_DEVICE(0x2019, 0xED18)},\n\t{USB_DEVICE(0x2019, 0x4901)},\n\t \n\t{USB_DEVICE(0x0DF6, 0x0058)},\n\t{USB_DEVICE(0x0DF6, 0x0049)},\n\t{USB_DEVICE(0x0DF6, 0x004C)},\n\t{USB_DEVICE(0x0DF6, 0x006C)},\n\t{USB_DEVICE(0x0DF6, 0x0064)},\n\t \n\t{USB_DEVICE(0x14b2, 0x3300)},\n\t{USB_DEVICE(0x14b2, 0x3301)},\n\t{USB_DEVICE(0x14B2, 0x3302)},\n\t \n\t{USB_DEVICE(0x04F2, 0xAFF2)},\n\t{USB_DEVICE(0x04F2, 0xAFF5)},\n\t{USB_DEVICE(0x04F2, 0xAFF6)},\n\t{USB_DEVICE(0x13D3, 0x3339)},\n\t{USB_DEVICE(0x13D3, 0x3340)},  \n\t{USB_DEVICE(0x13D3, 0x3341)},  \n\t{USB_DEVICE(0x13D3, 0x3310)},\n\t{USB_DEVICE(0x13D3, 0x3325)},\n\n \n\t \n\t{USB_DEVICE(0x0BDA, 0x8174)},\n\t \n\t{USB_DEVICE(0x050D, 0x845A)},\n\t \n\t{USB_DEVICE(0x07AA, 0x0051)},\n\t \n\t{USB_DEVICE(0x7392, 0x7622)},\n\t \n\t{USB_DEVICE(0x0409, 0x02B6)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, rtl871x_usb_id_tbl);\n\nstatic struct specific_device_id specific_device_id_tbl[] = {\n\t{.idVendor = 0x0b05, .idProduct = 0x1791,\n\t\t .flags = SPEC_DEV_ID_DISABLE_HT},\n\t{.idVendor = 0x0df6, .idProduct = 0x0059,\n\t\t .flags = SPEC_DEV_ID_DISABLE_HT},\n\t{.idVendor = 0x13d3, .idProduct = 0x3306,\n\t\t .flags = SPEC_DEV_ID_DISABLE_HT},\n\t{.idVendor = 0x13D3, .idProduct = 0x3311,\n\t\t .flags = SPEC_DEV_ID_DISABLE_HT},\n\t{.idVendor = 0x13d3, .idProduct = 0x3335,\n\t\t .flags = SPEC_DEV_ID_DISABLE_HT},\n\t{.idVendor = 0x13d3, .idProduct = 0x3336,\n\t\t .flags = SPEC_DEV_ID_DISABLE_HT},\n\t{.idVendor = 0x13d3, .idProduct = 0x3340,\n\t\t .flags = SPEC_DEV_ID_DISABLE_HT},\n\t{.idVendor = 0x13d3, .idProduct = 0x3341,\n\t\t .flags = SPEC_DEV_ID_DISABLE_HT},\n\t{}\n};\n\nstruct drv_priv {\n\tstruct usb_driver r871xu_drv;\n\tint drv_registered;\n};\n\n#ifdef CONFIG_PM\nstatic int r871x_suspend(struct usb_interface *pusb_intf, pm_message_t state)\n{\n\tstruct net_device *pnetdev = usb_get_intfdata(pusb_intf);\n\tstruct _adapter *padapter = netdev_priv(pnetdev);\n\n\tnetdev_info(pnetdev, \"Suspending...\\n\");\n\tpadapter->suspended = true;\n\trtl871x_intf_stop(padapter);\n\tif (pnetdev->netdev_ops->ndo_stop)\n\t\tpnetdev->netdev_ops->ndo_stop(pnetdev);\n\tmdelay(10);\n\tnetif_device_detach(pnetdev);\n\treturn 0;\n}\n\nstatic void rtl871x_intf_resume(struct _adapter *padapter)\n{\n\tif (padapter->dvobjpriv.inirp_init)\n\t\tpadapter->dvobjpriv.inirp_init(padapter);\n}\n\nstatic int r871x_resume(struct usb_interface *pusb_intf)\n{\n\tstruct net_device *pnetdev = usb_get_intfdata(pusb_intf);\n\tstruct _adapter *padapter = netdev_priv(pnetdev);\n\n\tnetdev_info(pnetdev,  \"Resuming...\\n\");\n\tnetif_device_attach(pnetdev);\n\tif (pnetdev->netdev_ops->ndo_open)\n\t\tpnetdev->netdev_ops->ndo_open(pnetdev);\n\tpadapter->suspended = false;\n\trtl871x_intf_resume(padapter);\n\treturn 0;\n}\n#endif\n\nstatic struct drv_priv drvpriv = {\n\t.r871xu_drv.name = \"r8712u\",\n\t.r871xu_drv.id_table = rtl871x_usb_id_tbl,\n\t.r871xu_drv.probe = r871xu_drv_init,\n\t.r871xu_drv.disconnect = r871xu_dev_remove,\n#ifdef CONFIG_PM\n\t.r871xu_drv.suspend = r871x_suspend,\n\t.r871xu_drv.resume = r871x_resume,\n#endif\n};\n\nstatic uint r8712_usb_dvobj_init(struct _adapter *padapter)\n{\n\tuint\tstatus = _SUCCESS;\n\tstruct\tusb_host_interface\t\t*phost_iface;\n\tstruct\tusb_interface_descriptor\t*piface_desc;\n\tstruct dvobj_priv *pdvobjpriv = &padapter->dvobjpriv;\n\tstruct usb_device *pusbd = pdvobjpriv->pusbdev;\n\n\tpdvobjpriv->padapter = padapter;\n\tpadapter->eeprom_address_size = 6;\n\tphost_iface = pintf->cur_altsetting;\n\tpiface_desc = &phost_iface->desc;\n\tpdvobjpriv->nr_endpoint = piface_desc->bNumEndpoints;\n\tif (pusbd->speed == USB_SPEED_HIGH) {\n\t\tpdvobjpriv->ishighspeed = true;\n\t\tdev_info(&pusbd->dev, \"r8712u: USB_SPEED_HIGH with %d endpoints\\n\",\n\t\t\t pdvobjpriv->nr_endpoint);\n\t} else {\n\t\tpdvobjpriv->ishighspeed = false;\n\t\tdev_info(&pusbd->dev, \"r8712u: USB_SPEED_LOW with %d endpoints\\n\",\n\t\t\t pdvobjpriv->nr_endpoint);\n\t}\n\tif ((r8712_alloc_io_queue(padapter)) == _FAIL)\n\t\tstatus = _FAIL;\n\treturn status;\n}\n\nstatic void r8712_usb_dvobj_deinit(struct _adapter *padapter)\n{\n\tr8712_free_io_queue(padapter);\n}\n\nvoid rtl871x_intf_stop(struct _adapter *padapter)\n{\n\t \n\tif (!padapter->surprise_removed) {\n\t\t \n\t}\n\n\t \n\tif (padapter->dvobjpriv.inirp_deinit)\n\t\tpadapter->dvobjpriv.inirp_deinit(padapter);\n\t \n\tr8712_usb_write_port_cancel(padapter);\n\t \n}\n\nvoid r871x_dev_unload(struct _adapter *padapter)\n{\n\tif (padapter->bup) {\n\t\t \n\t\tpadapter->driver_stopped = true;\n\n\t\t \n\t\trtl871x_intf_stop(padapter);\n\n\t\t \n\t\tr8712_stop_drv_threads(padapter);\n\n\t\t \n\t\tif (!padapter->surprise_removed) {\n\t\t\tpadapter->hw_init_completed = false;\n\t\t\trtl8712_hal_deinit(padapter);\n\t\t}\n\n\t\tpadapter->bup = false;\n\t}\n}\n\nstatic void disable_ht_for_spec_devid(const struct usb_device_id *pdid,\n\t\t\t\t      struct _adapter *padapter)\n{\n\tu16 vid, pid;\n\tu32 flags;\n\tint i;\n\tint num = ARRAY_SIZE(specific_device_id_tbl);\n\n\tfor (i = 0; i < num; i++) {\n\t\tvid = specific_device_id_tbl[i].idVendor;\n\t\tpid = specific_device_id_tbl[i].idProduct;\n\t\tflags = specific_device_id_tbl[i].flags;\n\n\t\tif ((pdid->idVendor == vid) && (pdid->idProduct == pid) &&\n\t\t    (flags & SPEC_DEV_ID_DISABLE_HT)) {\n\t\t\tpadapter->registrypriv.ht_enable = 0;\n\t\t\tpadapter->registrypriv.cbw40_enable = 0;\n\t\t\tpadapter->registrypriv.ampdu_enable = 0;\n\t\t}\n\t}\n}\n\nstatic const struct device_type wlan_type = {\n\t.name = \"wlan\",\n};\n\n \nstatic int r871xu_drv_init(struct usb_interface *pusb_intf,\n\t\t\t   const struct usb_device_id *pdid)\n{\n\tuint status;\n\tstruct _adapter *padapter = NULL;\n\tstruct dvobj_priv *pdvobjpriv;\n\tstruct net_device *pnetdev;\n\tstruct usb_device *udev;\n\n\t \n\tudev = interface_to_usbdev(pusb_intf);\n\tusb_get_dev(udev);\n\tpintf = pusb_intf;\n\t \n\tpnetdev = r8712_init_netdev();\n\tif (!pnetdev)\n\t\tgoto put_dev;\n\tpadapter = netdev_priv(pnetdev);\n\tdisable_ht_for_spec_devid(pdid, padapter);\n\tpdvobjpriv = &padapter->dvobjpriv;\n\tpdvobjpriv->padapter = padapter;\n\tpadapter->dvobjpriv.pusbdev = udev;\n\tpadapter->pusb_intf = pusb_intf;\n\tusb_set_intfdata(pusb_intf, pnetdev);\n\tSET_NETDEV_DEV(pnetdev, &pusb_intf->dev);\n\tpnetdev->dev.type = &wlan_type;\n\t \n\tpadapter->dvobj_init = r8712_usb_dvobj_init;\n\tpadapter->dvobj_deinit = r8712_usb_dvobj_deinit;\n\tpadapter->halpriv.hal_bus_init = r8712_usb_hal_bus_init;\n\tpadapter->dvobjpriv.inirp_init = r8712_usb_inirp_init;\n\tpadapter->dvobjpriv.inirp_deinit = r8712_usb_inirp_deinit;\n\t \n\n\tstatus = padapter->dvobj_init(padapter);\n\tif (status != _SUCCESS)\n\t\tgoto free_netdev;\n\n\t \n\tstatus = r8712_init_drv_sw(padapter);\n\tif (status)\n\t\tgoto dvobj_deinit;\n\t \n\t{\n\t\tint i, offset;\n\t\tu8 mac[6];\n\t\tu8 tmpU1b, AutoloadFail, eeprom_CustomerID;\n\t\tu8 *pdata = padapter->eeprompriv.efuse_eeprom_data;\n\n\t\ttmpU1b = r8712_read8(padapter, EE_9346CR); \n\n\t\t \n\t\tdev_info(&udev->dev, \"r8712u: Boot from %s: Autoload %s\\n\",\n\t\t\t (tmpU1b & _9356SEL) ? \"EEPROM\" : \"EFUSE\",\n\t\t\t (tmpU1b & _EEPROM_EN) ? \"OK\" : \"Failed\");\n\n\t\t \n\t\tif (tmpU1b & _EEPROM_EN) {\n\t\t\tAutoloadFail = true;\n\t\t\t \n\t\t\ttmpU1b = r8712_read8(padapter, EFUSE_TEST + 3);\n\t\t\tr8712_write8(padapter, EFUSE_TEST + 3, tmpU1b | 0x80);\n\t\t\tmsleep(20);\n\t\t\tr8712_write8(padapter, EFUSE_TEST + 3,\n\t\t\t\t     (tmpU1b & (~BIT(7))));\n\n\t\t\t \n\t\t\ttmpU1b = (u8)((r8712_read32(padapter, PMC_FSM) >> 15) &\n\t\t\t\t\t\t    0x1F);\n\t\t\tif (tmpU1b == 0x3)\n\t\t\t\tpadapter->registrypriv.chip_version =\n\t\t\t\t     RTL8712_3rdCUT;\n\t\t\telse\n\t\t\t\tpadapter->registrypriv.chip_version =\n\t\t\t\t     (tmpU1b >> 1) + 1;\n\t\t\tswitch (padapter->registrypriv.chip_version) {\n\t\t\tcase RTL8712_1stCUT:\n\t\t\tcase RTL8712_2ndCUT:\n\t\t\tcase RTL8712_3rdCUT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpadapter->registrypriv.chip_version =\n\t\t\t\t     RTL8712_2ndCUT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0, offset = 0; i < 128; i += 8, offset++)\n\t\t\t\tr8712_efuse_pg_packet_read(padapter, offset,\n\t\t\t\t\t\t     &pdata[i]);\n\n\t\t\tif (!r8712_initmac || !mac_pton(r8712_initmac, mac)) {\n\t\t\t\t \n\t\t\t\tether_addr_copy(mac, &pdata[0x12]);\n\t\t\t}\n\t\t\teeprom_CustomerID = pdata[0x52];\n\t\t\tswitch (eeprom_CustomerID) {\n\t\t\tcase EEPROM_CID_ALPHA:\n\t\t\t\tpadapter->eeprompriv.CustomerID =\n\t\t\t\t\t\t RT_CID_819x_ALPHA;\n\t\t\t\tbreak;\n\t\t\tcase EEPROM_CID_CAMEO:\n\t\t\t\tpadapter->eeprompriv.CustomerID =\n\t\t\t\t\t\t RT_CID_819x_CAMEO;\n\t\t\t\tbreak;\n\t\t\tcase EEPROM_CID_SITECOM:\n\t\t\t\tpadapter->eeprompriv.CustomerID =\n\t\t\t\t\t\t RT_CID_819x_Sitecom;\n\t\t\t\tbreak;\n\t\t\tcase EEPROM_CID_COREGA:\n\t\t\t\tpadapter->eeprompriv.CustomerID =\n\t\t\t\t\t\t RT_CID_COREGA;\n\t\t\t\tbreak;\n\t\t\tcase EEPROM_CID_Senao:\n\t\t\t\tpadapter->eeprompriv.CustomerID =\n\t\t\t\t\t\t RT_CID_819x_Senao;\n\t\t\t\tbreak;\n\t\t\tcase EEPROM_CID_EDIMAX_BELKIN:\n\t\t\t\tpadapter->eeprompriv.CustomerID =\n\t\t\t\t\t\t RT_CID_819x_Edimax_Belkin;\n\t\t\t\tbreak;\n\t\t\tcase EEPROM_CID_SERCOMM_BELKIN:\n\t\t\t\tpadapter->eeprompriv.CustomerID =\n\t\t\t\t\t\t RT_CID_819x_Sercomm_Belkin;\n\t\t\t\tbreak;\n\t\t\tcase EEPROM_CID_WNC_COREGA:\n\t\t\t\tpadapter->eeprompriv.CustomerID =\n\t\t\t\t\t\t RT_CID_819x_WNC_COREGA;\n\t\t\t\tbreak;\n\t\t\tcase EEPROM_CID_WHQL:\n\t\t\t\tbreak;\n\t\t\tcase EEPROM_CID_NetCore:\n\t\t\t\tpadapter->eeprompriv.CustomerID =\n\t\t\t\t\t\t RT_CID_819x_Netcore;\n\t\t\t\tbreak;\n\t\t\tcase EEPROM_CID_CAMEO1:\n\t\t\t\tpadapter->eeprompriv.CustomerID =\n\t\t\t\t\t\t RT_CID_819x_CAMEO1;\n\t\t\t\tbreak;\n\t\t\tcase EEPROM_CID_CLEVO:\n\t\t\t\tpadapter->eeprompriv.CustomerID =\n\t\t\t\t\t\t RT_CID_819x_CLEVO;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpadapter->eeprompriv.CustomerID =\n\t\t\t\t\t\t RT_CID_DEFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_info(&udev->dev, \"r8712u: CustomerID = 0x%.4x\\n\",\n\t\t\t\t padapter->eeprompriv.CustomerID);\n\t\t\t \n\t\t\tswitch (padapter->eeprompriv.CustomerID) {\n\t\t\tcase RT_CID_DEFAULT:\n\t\t\tcase RT_CID_819x_ALPHA:\n\t\t\tcase RT_CID_819x_CAMEO:\n\t\t\t\tpadapter->ledpriv.LedStrategy = SW_LED_MODE1;\n\t\t\t\tpadapter->ledpriv.bRegUseLed = true;\n\t\t\t\tbreak;\n\t\t\tcase RT_CID_819x_Sitecom:\n\t\t\t\tpadapter->ledpriv.LedStrategy = SW_LED_MODE2;\n\t\t\t\tpadapter->ledpriv.bRegUseLed = true;\n\t\t\t\tbreak;\n\t\t\tcase RT_CID_COREGA:\n\t\t\tcase RT_CID_819x_Senao:\n\t\t\t\tpadapter->ledpriv.LedStrategy = SW_LED_MODE3;\n\t\t\t\tpadapter->ledpriv.bRegUseLed = true;\n\t\t\t\tbreak;\n\t\t\tcase RT_CID_819x_Edimax_Belkin:\n\t\t\t\tpadapter->ledpriv.LedStrategy = SW_LED_MODE4;\n\t\t\t\tpadapter->ledpriv.bRegUseLed = true;\n\t\t\t\tbreak;\n\t\t\tcase RT_CID_819x_Sercomm_Belkin:\n\t\t\t\tpadapter->ledpriv.LedStrategy = SW_LED_MODE5;\n\t\t\t\tpadapter->ledpriv.bRegUseLed = true;\n\t\t\t\tbreak;\n\t\t\tcase RT_CID_819x_WNC_COREGA:\n\t\t\t\tpadapter->ledpriv.LedStrategy = SW_LED_MODE6;\n\t\t\t\tpadapter->ledpriv.bRegUseLed = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpadapter->ledpriv.LedStrategy = SW_LED_MODE0;\n\t\t\t\tpadapter->ledpriv.bRegUseLed = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tAutoloadFail = false;\n\t\t}\n\t\tif ((!AutoloadFail) ||\n\t\t    ((mac[0] == 0xff) && (mac[1] == 0xff) &&\n\t\t     (mac[2] == 0xff) && (mac[3] == 0xff) &&\n\t\t     (mac[4] == 0xff) && (mac[5] == 0xff)) ||\n\t\t    ((mac[0] == 0x00) && (mac[1] == 0x00) &&\n\t\t     (mac[2] == 0x00) && (mac[3] == 0x00) &&\n\t\t     (mac[4] == 0x00) && (mac[5] == 0x00))) {\n\t\t\tmac[0] = 0x00;\n\t\t\tmac[1] = 0xe0;\n\t\t\tmac[2] = 0x4c;\n\t\t\tmac[3] = 0x87;\n\t\t\tmac[4] = 0x00;\n\t\t\tmac[5] = 0x00;\n\t\t}\n\t\tif (r8712_initmac) {\n\t\t\t \n\t\t\tmac[0] &= 0xFE;\n\t\t\tdev_info(&udev->dev,\n\t\t\t\t\"r8712u: MAC Address from user = %pM\\n\", mac);\n\t\t} else {\n\t\t\tdev_info(&udev->dev,\n\t\t\t\t\"r8712u: MAC Address from efuse = %pM\\n\", mac);\n\t\t}\n\t\teth_hw_addr_set(pnetdev, mac);\n\t}\n\t \n\tif (rtl871x_load_fw(padapter))\n\t\tgoto deinit_drv_sw;\n\tinit_completion(&padapter->rx_filter_ready);\n\treturn 0;\n\ndeinit_drv_sw:\n\tr8712_free_drv_sw(padapter);\ndvobj_deinit:\n\tpadapter->dvobj_deinit(padapter);\nfree_netdev:\n\tfree_netdev(pnetdev);\nput_dev:\n\tusb_put_dev(udev);\n\tusb_set_intfdata(pusb_intf, NULL);\n\treturn -ENODEV;\n}\n\n \nstatic void r871xu_dev_remove(struct usb_interface *pusb_intf)\n{\n\tstruct net_device *pnetdev = usb_get_intfdata(pusb_intf);\n\tstruct usb_device *udev = interface_to_usbdev(pusb_intf);\n\tstruct _adapter *padapter = netdev_priv(pnetdev);\n\n\t \n\twait_for_completion(&padapter->rtl8712_fw_ready);\n\tif (pnetdev->reg_state != NETREG_UNINITIALIZED)\n\t\tunregister_netdev(pnetdev);  \n\tusb_set_intfdata(pusb_intf, NULL);\n\trelease_firmware(padapter->fw);\n\tif (drvpriv.drv_registered)\n\t\tpadapter->surprise_removed = true;\n\tr8712_flush_rwctrl_works(padapter);\n\tr8712_flush_led_works(padapter);\n\tudelay(1);\n\t \n\tr8712_stop_drv_timers(padapter);\n\tr871x_dev_unload(padapter);\n\tif (padapter->dvobj_deinit)\n\t\tpadapter->dvobj_deinit(padapter);\n\tr8712_free_drv_sw(padapter);\n\tfree_netdev(pnetdev);\n\n\t \n\tusb_put_dev(udev);\n\n\t \n\tif (udev->state != USB_STATE_NOTATTACHED)\n\t\tusb_reset_device(udev);\n}\n\nstatic int __init r8712u_drv_entry(void)\n{\n\tdrvpriv.drv_registered = true;\n\treturn usb_register(&drvpriv.r871xu_drv);\n}\n\nstatic void __exit r8712u_drv_halt(void)\n{\n\tdrvpriv.drv_registered = false;\n\tusb_deregister(&drvpriv.r871xu_drv);\n}\n\nmodule_init(r8712u_drv_entry);\nmodule_exit(r8712u_drv_halt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}