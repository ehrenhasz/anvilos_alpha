{
  "module_name": "rtl8712_cmd.c",
  "hash_id": "c8af506a04e21e19798d487274c42e43110207b65efb63a19c649d82b2363c96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/rtl8712_cmd.c",
  "human_readable_source": "\n \n\n#define _RTL8712_CMD_C_\n\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/module.h>\n#include <linux/kref.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/circ_buf.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/atomic.h>\n#include <linux/semaphore.h>\n#include <linux/rtnetlink.h>\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"recv_osdep.h\"\n#include \"mlme_osdep.h\"\n#include \"rtl871x_ioctl_set.h\"\n\nstatic void check_hw_pbc(struct _adapter *padapter)\n{\n\tu8\ttmp1byte;\n\n\tr8712_write8(padapter, MAC_PINMUX_CTRL, (GPIOMUX_EN | GPIOSEL_GPIO));\n\ttmp1byte = r8712_read8(padapter, GPIO_IO_SEL);\n\ttmp1byte &= ~(HAL_8192S_HW_GPIO_WPS_BIT);\n\tr8712_write8(padapter, GPIO_IO_SEL, tmp1byte);\n\ttmp1byte = r8712_read8(padapter, GPIO_CTRL);\n\tif (tmp1byte == 0xff)\n\t\treturn;\n\tif (tmp1byte & HAL_8192S_HW_GPIO_WPS_BIT) {\n\t\t \n\t\tnetdev_dbg(padapter->pnetdev, \"CheckPbcGPIO - PBC is pressed !!!!\\n\");\n\t\t \n\t\tif (padapter->pid == 0)\n\t\t\treturn;\n\t\tkill_pid(find_vpid(padapter->pid), SIGUSR1, 1);\n\t}\n}\n\n \nstatic void query_fw_rx_phy_status(struct _adapter *padapter)\n{\n\tu32 val32 = 0;\n\tint pollingcnts = 50;\n\n\tif (check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {\n\t\tr8712_write32(padapter, IOCMD_CTRL_REG, 0xf4000001);\n\t\tmsleep(100);\n\t\t \n\t\twhile ((r8712_read32(padapter, IOCMD_CTRL_REG)) &&\n\t\t       (pollingcnts > 0)) {\n\t\t\tpollingcnts--;\n\t\t\tmsleep(20);\n\t\t}\n\t\tif (pollingcnts != 0)\n\t\t\tval32 = r8712_read32(padapter, IOCMD_DATA_REG);\n\t\telse  \n\t\t\tval32 = 0;\n\t\tval32 >>= 4;\n\t\tpadapter->recvpriv.fw_rssi =\n\t\t\t (u8)r8712_signal_scale_mapping(val32);\n\t}\n}\n\n \nstatic void StatusWatchdogCallback(struct _adapter *padapter)\n{\n\tcheck_hw_pbc(padapter);\n\tquery_fw_rx_phy_status(padapter);\n}\n\nstatic void r871x_internal_cmd_hdl(struct _adapter *padapter, u8 *pbuf)\n{\n\tstruct drvint_cmd_parm *pdrvcmd;\n\n\tif (!pbuf)\n\t\treturn;\n\tpdrvcmd = (struct drvint_cmd_parm *)pbuf;\n\tswitch (pdrvcmd->i_cid) {\n\tcase WDG_WK_CID:\n\t\tStatusWatchdogCallback(padapter);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tkfree(pdrvcmd->pbuf);\n}\n\nstatic u8 read_bbreg_hdl(struct _adapter *padapter, u8 *pbuf)\n{\n\tstruct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;\n\n\tr8712_free_cmd_obj(pcmd);\n\treturn H2C_SUCCESS;\n}\n\nstatic u8 write_bbreg_hdl(struct _adapter *padapter, u8 *pbuf)\n{\n\tvoid (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);\n\tstruct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;\n\n\tpcmd_callback = cmd_callback[pcmd->cmdcode].callback;\n\tif (!pcmd_callback)\n\t\tr8712_free_cmd_obj(pcmd);\n\telse\n\t\tpcmd_callback(padapter, pcmd);\n\treturn H2C_SUCCESS;\n}\n\nstatic u8 read_rfreg_hdl(struct _adapter *padapter, u8 *pbuf)\n{\n\tu32 val;\n\tvoid (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);\n\tstruct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;\n\n\tif (pcmd->rsp && pcmd->rspsz > 0)\n\t\tmemcpy(pcmd->rsp, (u8 *)&val, pcmd->rspsz);\n\tpcmd_callback = cmd_callback[pcmd->cmdcode].callback;\n\tif (!pcmd_callback)\n\t\tr8712_free_cmd_obj(pcmd);\n\telse\n\t\tpcmd_callback(padapter, pcmd);\n\treturn H2C_SUCCESS;\n}\n\nstatic u8 write_rfreg_hdl(struct _adapter *padapter, u8 *pbuf)\n{\n\tvoid (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);\n\tstruct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;\n\n\tpcmd_callback = cmd_callback[pcmd->cmdcode].callback;\n\tif (!pcmd_callback)\n\t\tr8712_free_cmd_obj(pcmd);\n\telse\n\t\tpcmd_callback(padapter, pcmd);\n\treturn H2C_SUCCESS;\n}\n\nstatic u8 sys_suspend_hdl(struct _adapter *padapter, u8 *pbuf)\n{\n\tstruct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;\n\n\tr8712_free_cmd_obj(pcmd);\n\treturn H2C_SUCCESS;\n}\n\nstatic struct cmd_obj *cmd_hdl_filter(struct _adapter *padapter,\n\t\t\t\t      struct cmd_obj *pcmd)\n{\n\tstruct cmd_obj *pcmd_r;\n\n\tif (!pcmd)\n\t\treturn pcmd;\n\tpcmd_r = NULL;\n\n\tswitch (pcmd->cmdcode) {\n\tcase GEN_CMD_CODE(_Read_BBREG):\n\t\tread_bbreg_hdl(padapter, (u8 *)pcmd);\n\t\tbreak;\n\tcase GEN_CMD_CODE(_Write_BBREG):\n\t\twrite_bbreg_hdl(padapter, (u8 *)pcmd);\n\t\tbreak;\n\tcase GEN_CMD_CODE(_Read_RFREG):\n\t\tread_rfreg_hdl(padapter, (u8 *)pcmd);\n\t\tbreak;\n\tcase GEN_CMD_CODE(_Write_RFREG):\n\t\twrite_rfreg_hdl(padapter, (u8 *)pcmd);\n\t\tbreak;\n\tcase GEN_CMD_CODE(_SetUsbSuspend):\n\t\tsys_suspend_hdl(padapter, (u8 *)pcmd);\n\t\tbreak;\n\tcase GEN_CMD_CODE(_JoinBss):\n\t\tr8712_joinbss_reset(padapter);\n\t\t \n\t\tif (padapter->pwrctrlpriv.pwr_mode > PS_MODE_ACTIVE) {\n\t\t\tpadapter->pwrctrlpriv.pwr_mode = PS_MODE_ACTIVE;\n\t\t\tmutex_lock(&padapter->pwrctrlpriv.mutex_lock);\n\t\t\tr8712_set_rpwm(padapter, PS_STATE_S4);\n\t\t\tmutex_unlock(&padapter->pwrctrlpriv.mutex_lock);\n\t\t}\n\t\tpcmd_r = pcmd;\n\t\tbreak;\n\tcase _DRV_INT_CMD_:\n\t\tr871x_internal_cmd_hdl(padapter, pcmd->parmbuf);\n\t\tr8712_free_cmd_obj(pcmd);\n\t\tpcmd_r = NULL;\n\t\tbreak;\n\tdefault:\n\t\tpcmd_r = pcmd;\n\t\tbreak;\n\t}\n\treturn pcmd_r;  \n}\n\nu8 r8712_fw_cmd(struct _adapter *pAdapter, u32 cmd)\n{\n\tint pollingcnts = 50;\n\n\tr8712_write32(pAdapter, IOCMD_CTRL_REG, cmd);\n\tmsleep(100);\n\twhile ((r8712_read32(pAdapter, IOCMD_CTRL_REG != 0)) &&\n\t       (pollingcnts > 0)) {\n\t\tpollingcnts--;\n\t\tmsleep(20);\n\t}\n\tif (pollingcnts == 0)\n\t\treturn false;\n\treturn true;\n}\n\nvoid r8712_fw_cmd_data(struct _adapter *pAdapter, u32 *value, u8 flag)\n{\n\tif (flag == 0)\t \n\t\tr8712_write32(pAdapter, IOCMD_DATA_REG, *value);\n\telse\t\t \n\t\t*value = r8712_read32(pAdapter, IOCMD_DATA_REG);\n}\n\nint r8712_cmd_thread(void *context)\n{\n\tstruct cmd_obj *pcmd;\n\tunsigned int cmdsz, wr_sz;\n\t__le32 *pcmdbuf;\n\tstruct tx_desc *pdesc;\n\tvoid (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);\n\tstruct _adapter *padapter = context;\n\tstruct\tcmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tstruct completion *cmd_queue_comp =\n\t\t&pcmdpriv->cmd_queue_comp;\n\tstruct mutex *pwctrl_lock = &padapter->pwrctrlpriv.mutex_lock;\n\n\tallow_signal(SIGTERM);\n\twhile (1) {\n\t\tif (wait_for_completion_interruptible(cmd_queue_comp))\n\t\t\tbreak;\n\t\tif (padapter->driver_stopped || padapter->surprise_removed)\n\t\t\tbreak;\n\t\tif (r8712_register_cmd_alive(padapter))\n\t\t\tcontinue;\n_next:\n\t\tpcmd = r8712_dequeue_cmd(&pcmdpriv->cmd_queue);\n\t\tif (!(pcmd)) {\n\t\t\tr8712_unregister_cmd_alive(padapter);\n\t\t\tcontinue;\n\t\t}\n\t\tpcmdbuf = (__le32 *)pcmdpriv->cmd_buf;\n\t\tpdesc = (struct tx_desc *)pcmdbuf;\n\t\tmemset(pdesc, 0, TXDESC_SIZE);\n\t\tpcmd = cmd_hdl_filter(padapter, pcmd);\n\t\tif (pcmd) {  \n\t\t\tstruct dvobj_priv *pdvobj = &padapter->dvobjpriv;\n\t\t\tu8 blnPending = 0;\n\t\t\tu16 cmdcode = pcmd->cmdcode;\n\n\t\t\tpcmdpriv->cmd_issued_cnt++;\n\t\t\tcmdsz = round_up(pcmd->cmdsz, 8);\n\t\t\twr_sz = TXDESC_SIZE + 8 + cmdsz;\n\t\t\tpdesc->txdw0 |= cpu_to_le32((wr_sz - TXDESC_SIZE) &\n\t\t\t\t\t\t     0x0000ffff);\n\t\t\tif (pdvobj->ishighspeed) {\n\t\t\t\tif ((wr_sz % 512) == 0)\n\t\t\t\t\tblnPending = 1;\n\t\t\t} else {\n\t\t\t\tif ((wr_sz % 64) == 0)\n\t\t\t\t\tblnPending = 1;\n\t\t\t}\n\t\t\tif (blnPending) {  \n\t\t\t\tpdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE +\n\t\t\t\t\t\tOFFSET_SZ + 8) << OFFSET_SHT) &\n\t\t\t\t\t\t0x00ff0000);\n\t\t\t} else {\n\t\t\t\tpdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE +\n\t\t\t\t\t\t\t      OFFSET_SZ) <<\n\t\t\t\t\t\t\t      OFFSET_SHT) &\n\t\t\t\t\t\t\t      0x00ff0000);\n\t\t\t}\n\t\t\tpdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);\n\t\t\tpdesc->txdw1 |= cpu_to_le32((0x13 << QSEL_SHT) &\n\t\t\t\t\t\t    0x00001f00);\n\t\t\tpcmdbuf += (TXDESC_SIZE >> 2);\n\t\t\t*pcmdbuf = cpu_to_le32((cmdsz & 0x0000ffff) |\n\t\t\t\t\t       (pcmd->cmdcode << 16) |\n\t\t\t\t\t       (pcmdpriv->cmd_seq << 24));\n\t\t\tpcmdbuf += 2;  \n\t\t\tmemcpy((u8 *)pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);\n\t\t\tif (blnPending)\n\t\t\t\twr_sz += 8;    \n\t\t\tr8712_write_mem(padapter, RTL8712_DMA_H2CCMD, wr_sz,\n\t\t\t\t\t(u8 *)pdesc);\n\t\t\tpcmdpriv->cmd_seq++;\n\t\t\tif (cmdcode == GEN_CMD_CODE(_CreateBss)) {\n\t\t\t\tpcmd->res = H2C_SUCCESS;\n\t\t\t\tpcmd_callback = cmd_callback[cmdcode].callback;\n\t\t\t\tif (pcmd_callback)\n\t\t\t\t\tpcmd_callback(padapter, pcmd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cmdcode == GEN_CMD_CODE(_SetPwrMode)) {\n\t\t\t\tif (padapter->pwrctrlpriv.bSleep) {\n\t\t\t\t\tmutex_lock(pwctrl_lock);\n\t\t\t\t\tr8712_set_rpwm(padapter, PS_STATE_S2);\n\t\t\t\t\tmutex_unlock(pwctrl_lock);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr8712_free_cmd_obj(pcmd);\n\t\t\tif (list_empty(&pcmdpriv->cmd_queue.queue)) {\n\t\t\t\tr8712_unregister_cmd_alive(padapter);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tgoto _next;\n\t\t\t}\n\t\t} else {\n\t\t\tgoto _next;\n\t\t}\n\t\tflush_signals_thread();\n\t}\n\t \n\tdo {\n\t\tpcmd = r8712_dequeue_cmd(&pcmdpriv->cmd_queue);\n\t\tif (!pcmd)\n\t\t\tbreak;\n\t\tr8712_free_cmd_obj(pcmd);\n\t} while (1);\n\tcomplete(&pcmdpriv->terminate_cmdthread_comp);\n\treturn 0;\n}\n\nvoid r8712_event_handle(struct _adapter *padapter, __le32 *peventbuf)\n{\n\tu8 evt_code, evt_seq;\n\tu16 evt_sz;\n\tvoid (*event_callback)(struct _adapter *dev, u8 *pbuf);\n\tstruct\tevt_priv *pevt_priv = &padapter->evtpriv;\n\n\tif (!peventbuf)\n\t\tgoto _abort_event_;\n\tevt_sz = (u16)(le32_to_cpu(*peventbuf) & 0xffff);\n\tevt_seq = (u8)((le32_to_cpu(*peventbuf) >> 24) & 0x7f);\n\tevt_code = (u8)((le32_to_cpu(*peventbuf) >> 16) & 0xff);\n\t \n\tif ((evt_seq & 0x7f) != pevt_priv->event_seq) {\n\t\tpevt_priv->event_seq = ((evt_seq + 1) & 0x7f);\n\t\tgoto _abort_event_;\n\t}\n\t \n\tif (evt_code >= MAX_C2HEVT) {\n\t\tpevt_priv->event_seq = ((evt_seq + 1) & 0x7f);\n\t\tgoto _abort_event_;\n\t} else if ((evt_code == GEN_EVT_CODE(_Survey)) &&\n\t\t   (evt_sz > sizeof(struct wlan_bssid_ex))) {\n\t\tpevt_priv->event_seq = ((evt_seq + 1) & 0x7f);\n\t\tgoto _abort_event_;\n\t}\n\t \n\tif ((wlanevents[evt_code].parmsize) &&\n\t    (wlanevents[evt_code].parmsize != evt_sz)) {\n\t\tpevt_priv->event_seq = ((evt_seq + 1) & 0x7f);\n\t\tgoto _abort_event_;\n\t} else if ((evt_sz == 0) && (evt_code != GEN_EVT_CODE(_WPS_PBC))) {\n\t\tpevt_priv->event_seq = ((evt_seq + 1) & 0x7f);\n\t\tgoto _abort_event_;\n\t}\n\tpevt_priv->event_seq++;\t \n\tif (pevt_priv->event_seq > 127)\n\t\tpevt_priv->event_seq = 0;\n\t \n\tpeventbuf = peventbuf + 2;\n\tevent_callback = wlanevents[evt_code].event_callback;\n\tif (event_callback)\n\t\tevent_callback(padapter, (u8 *)peventbuf);\n\tpevt_priv->evt_done_cnt++;\n_abort_event_:\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}