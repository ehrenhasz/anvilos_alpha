{
  "module_name": "rtl871x_sta_mgt.c",
  "hash_id": "6ae2489743a6e6e7fc92128f1fb53ae25e427f76a6009a59bdc48976612a8947",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/rtl871x_sta_mgt.c",
  "human_readable_source": "\n \n\n#define _RTL871X_STA_MGT_C_\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"recv_osdep.h\"\n#include \"xmit_osdep.h\"\n#include \"sta_info.h\"\n\nstatic void _init_stainfo(struct sta_info *psta)\n{\n\tmemset((u8 *)psta, 0, sizeof(struct sta_info));\n\tspin_lock_init(&psta->lock);\n\tINIT_LIST_HEAD(&psta->list);\n\tINIT_LIST_HEAD(&psta->hash_list);\n\t_r8712_init_sta_xmit_priv(&psta->sta_xmitpriv);\n\t_r8712_init_sta_recv_priv(&psta->sta_recvpriv);\n\tINIT_LIST_HEAD(&psta->asoc_list);\n\tINIT_LIST_HEAD(&psta->auth_list);\n}\n\nint _r8712_init_sta_priv(struct\tsta_priv *pstapriv)\n{\n\tstruct sta_info *psta;\n\ts32 i;\n\n\tpstapriv->pallocated_stainfo_buf = kmalloc(sizeof(struct sta_info) *\n\t\t\t\t\t\t   NUM_STA + 4, GFP_ATOMIC);\n\tif (!pstapriv->pallocated_stainfo_buf)\n\t\treturn -ENOMEM;\n\tpstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 -\n\t\t((addr_t)(pstapriv->pallocated_stainfo_buf) & 3);\n\t_init_queue(&pstapriv->free_sta_queue);\n\tspin_lock_init(&pstapriv->sta_hash_lock);\n\tpstapriv->asoc_sta_count = 0;\n\t_init_queue(&pstapriv->sleep_q);\n\t_init_queue(&pstapriv->wakeup_q);\n\tpsta = (struct sta_info *)(pstapriv->pstainfo_buf);\n\tfor (i = 0; i < NUM_STA; i++) {\n\t\t_init_stainfo(psta);\n\t\tINIT_LIST_HEAD(&(pstapriv->sta_hash[i]));\n\t\tlist_add_tail(&psta->list, &pstapriv->free_sta_queue.queue);\n\t\tpsta++;\n\t}\n\tINIT_LIST_HEAD(&pstapriv->asoc_list);\n\tINIT_LIST_HEAD(&pstapriv->auth_list);\n\treturn 0;\n}\n\n \nstatic void mfree_all_stainfo(struct sta_priv *pstapriv)\n{\n\tunsigned long irqL;\n\tstruct list_head *plist, *phead;\n\n\tspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);\n\tphead = &pstapriv->free_sta_queue.queue;\n\tplist = phead->next;\n\twhile (!end_of_queue_search(phead, plist))\n\t\tplist = plist->next;\n\n\tspin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);\n}\n\nvoid _r8712_free_sta_priv(struct sta_priv *pstapriv)\n{\n\tif (pstapriv) {\n\t\t \n\t\tmfree_all_stainfo(pstapriv);\n\t\tkfree(pstapriv->pallocated_stainfo_buf);\n\t}\n}\n\nstruct sta_info *r8712_alloc_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)\n{\n\ts32\tindex;\n\tstruct list_head *phash_list;\n\tstruct sta_info\t*psta;\n\tstruct  __queue *pfree_sta_queue;\n\tstruct recv_reorder_ctrl *preorder_ctrl;\n\tint i = 0;\n\tu16  wRxSeqInitialValue = 0xffff;\n\tunsigned long flags;\n\n\tpfree_sta_queue = &pstapriv->free_sta_queue;\n\tspin_lock_irqsave(&pfree_sta_queue->lock, flags);\n\tpsta = list_first_entry_or_null(&pfree_sta_queue->queue,\n\t\t\t\t\tstruct sta_info, list);\n\tif (psta) {\n\t\tlist_del_init(&psta->list);\n\t\t_init_stainfo(psta);\n\t\tmemcpy(psta->hwaddr, hwaddr, ETH_ALEN);\n\t\tindex = wifi_mac_hash(hwaddr);\n\t\tif (index >= NUM_STA) {\n\t\t\tpsta = NULL;\n\t\t\tgoto exit;\n\t\t}\n\t\tphash_list = &pstapriv->sta_hash[index];\n\t\tlist_add_tail(&psta->hash_list, phash_list);\n\t\tpstapriv->asoc_sta_count++;\n\n \n\t\tfor (i = 0; i < 16; i++)\n\t\t\tmemcpy(&psta->sta_recvpriv.rxcache.tid_rxseq[i],\n\t\t\t\t&wRxSeqInitialValue, 2);\n\t\t \n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tpreorder_ctrl = &psta->recvreorder_ctrl[i];\n\t\t\tpreorder_ctrl->padapter = pstapriv->padapter;\n\t\t\tpreorder_ctrl->indicate_seq = 0xffff;\n\t\t\tpreorder_ctrl->wend_b = 0xffff;\n\t\t\tpreorder_ctrl->wsize_b = 64;\n\t\t\t_init_queue(&preorder_ctrl->pending_recvframe_queue);\n\t\t\tr8712_init_recv_timer(preorder_ctrl);\n\t\t}\n\t}\nexit:\n\tspin_unlock_irqrestore(&pfree_sta_queue->lock, flags);\n\treturn psta;\n}\n\n \nvoid r8712_free_stainfo(struct _adapter *padapter, struct sta_info *psta)\n{\n\tint i;\n\tunsigned long irqL0;\n\tstruct  __queue *pfree_sta_queue;\n\tstruct recv_reorder_ctrl *preorder_ctrl;\n\tstruct\tsta_xmit_priv *pstaxmitpriv;\n\tstruct\txmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct\tsta_priv *pstapriv = &padapter->stapriv;\n\n\tif (!psta)\n\t\treturn;\n\tpfree_sta_queue = &pstapriv->free_sta_queue;\n\tpstaxmitpriv = &psta->sta_xmitpriv;\n\tspin_lock_irqsave(&(pxmitpriv->vo_pending.lock), irqL0);\n\tr8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);\n\tlist_del_init(&(pstaxmitpriv->vo_q.tx_pending));\n\tspin_unlock_irqrestore(&(pxmitpriv->vo_pending.lock), irqL0);\n\tspin_lock_irqsave(&(pxmitpriv->vi_pending.lock), irqL0);\n\tr8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);\n\tlist_del_init(&(pstaxmitpriv->vi_q.tx_pending));\n\tspin_unlock_irqrestore(&(pxmitpriv->vi_pending.lock), irqL0);\n\tspin_lock_irqsave(&(pxmitpriv->bk_pending.lock), irqL0);\n\tr8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);\n\tlist_del_init(&(pstaxmitpriv->bk_q.tx_pending));\n\tspin_unlock_irqrestore(&(pxmitpriv->bk_pending.lock), irqL0);\n\tspin_lock_irqsave(&(pxmitpriv->be_pending.lock), irqL0);\n\tr8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->be_q.sta_pending);\n\tlist_del_init(&(pstaxmitpriv->be_q.tx_pending));\n\tspin_unlock_irqrestore(&(pxmitpriv->be_pending.lock), irqL0);\n\tlist_del_init(&psta->hash_list);\n\tpstapriv->asoc_sta_count--;\n\t \n\t_r8712_init_sta_xmit_priv(&psta->sta_xmitpriv);\n\t_r8712_init_sta_recv_priv(&psta->sta_recvpriv);\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tpreorder_ctrl = &psta->recvreorder_ctrl[i];\n\t\tdel_timer(&preorder_ctrl->reordering_ctrl_timer);\n\t}\n\tspin_lock(&(pfree_sta_queue->lock));\n\t \n\tlist_add_tail(&psta->list, &pfree_sta_queue->queue);\n\tspin_unlock(&(pfree_sta_queue->lock));\n}\n\n \nvoid r8712_free_all_stainfo(struct _adapter *padapter)\n{\n\tunsigned long irqL;\n\tstruct list_head *plist, *phead;\n\ts32 index;\n\tstruct sta_info *psta = NULL;\n\tstruct\tsta_priv *pstapriv = &padapter->stapriv;\n\tstruct sta_info *pbcmc_stainfo = r8712_get_bcmc_stainfo(padapter);\n\n\tif (pstapriv->asoc_sta_count == 1)\n\t\treturn;\n\tspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);\n\tfor (index = 0; index < NUM_STA; index++) {\n\t\tphead = &(pstapriv->sta_hash[index]);\n\t\tplist = phead->next;\n\t\twhile (!end_of_queue_search(phead, plist)) {\n\t\t\tpsta = container_of(plist,\n\t\t\t\t\t    struct sta_info, hash_list);\n\t\t\tplist = plist->next;\n\t\t\tif (pbcmc_stainfo != psta)\n\t\t\t\tr8712_free_stainfo(padapter, psta);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);\n}\n\n \nstruct sta_info *r8712_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)\n{\n\tunsigned long\t irqL;\n\tstruct list_head *plist, *phead;\n\tstruct sta_info *psta = NULL;\n\tu32\tindex;\n\n\tif (!hwaddr)\n\t\treturn NULL;\n\tindex = wifi_mac_hash(hwaddr);\n\tspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);\n\tphead = &(pstapriv->sta_hash[index]);\n\tplist = phead->next;\n\twhile (!end_of_queue_search(phead, plist)) {\n\t\tpsta = container_of(plist, struct sta_info, hash_list);\n\t\tif ((!memcmp(psta->hwaddr, hwaddr, ETH_ALEN))) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tpsta = NULL;\n\t\tplist = plist->next;\n\t}\n\tspin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);\n\treturn psta;\n}\n\nvoid r8712_init_bcmc_stainfo(struct _adapter *padapter)\n{\n\tunsigned char bcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tstruct\tsta_priv *pstapriv = &padapter->stapriv;\n\n\tr8712_alloc_stainfo(pstapriv, bcast_addr);\n}\n\nstruct sta_info *r8712_get_bcmc_stainfo(struct _adapter *padapter)\n{\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n\treturn r8712_get_stainfo(pstapriv, bc_addr);\n}\n\nu8 r8712_access_ctrl(struct wlan_acl_pool *pacl_list, u8 *mac_addr)\n{\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}