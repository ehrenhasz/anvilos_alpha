{
  "module_name": "rtl871x_mlme.c",
  "hash_id": "68401608556760acab2fe0c1f746d3b1b8a05787cbb86f76bbcc76e62dd7e888",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/rtl871x_mlme.c",
  "human_readable_source": "\n \n\n#define _RTL871X_MLME_C_\n\n#include <linux/etherdevice.h>\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"recv_osdep.h\"\n#include \"xmit_osdep.h\"\n#include \"mlme_osdep.h\"\n#include \"sta_info.h\"\n#include \"wifi.h\"\n#include \"wlan_bssdef.h\"\n\nstatic void update_ht_cap(struct _adapter *padapter, u8 *pie, uint ie_len);\n\nint r8712_init_mlme_priv(struct _adapter *padapter)\n{\n\tsint\ti;\n\tu8\t*pbuf;\n\tstruct wlan_network\t*pnetwork;\n\tstruct\tmlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tmemset((u8 *)pmlmepriv, 0, sizeof(struct mlme_priv));\n\tpmlmepriv->nic_hdl = (u8 *)padapter;\n\tpmlmepriv->pscanned = NULL;\n\tpmlmepriv->fw_state = 0;\n\tpmlmepriv->cur_network.network.InfrastructureMode =\n\t\t\t\t Ndis802_11AutoUnknown;\n\t \n\tpmlmepriv->passive_mode = 1;  \n\tspin_lock_init(&(pmlmepriv->lock));\n\tspin_lock_init(&(pmlmepriv->lock2));\n\t_init_queue(&(pmlmepriv->free_bss_pool));\n\t_init_queue(&(pmlmepriv->scanned_queue));\n\tset_scanned_network_val(pmlmepriv, 0);\n\tmemset(&pmlmepriv->assoc_ssid, 0, sizeof(struct ndis_802_11_ssid));\n\tpbuf = kmalloc_array(MAX_BSS_CNT, sizeof(struct wlan_network),\n\t\t\t     GFP_ATOMIC);\n\tif (!pbuf)\n\t\treturn -ENOMEM;\n\tpmlmepriv->free_bss_buf = pbuf;\n\tpnetwork = (struct wlan_network *)pbuf;\n\tfor (i = 0; i < MAX_BSS_CNT; i++) {\n\t\tINIT_LIST_HEAD(&(pnetwork->list));\n\t\tlist_add_tail(&(pnetwork->list),\n\t\t\t\t &(pmlmepriv->free_bss_pool.queue));\n\t\tpnetwork++;\n\t}\n\tpmlmepriv->sitesurveyctrl.last_rx_pkts = 0;\n\tpmlmepriv->sitesurveyctrl.last_tx_pkts = 0;\n\tpmlmepriv->sitesurveyctrl.traffic_busy = false;\n\t \n\tr8712_init_mlme_timer(padapter);\n\treturn 0;\n}\n\nstruct wlan_network *_r8712_alloc_network(struct mlme_priv *pmlmepriv)\n{\n\tunsigned long irqL;\n\tstruct wlan_network *pnetwork;\n\tstruct  __queue *free_queue = &pmlmepriv->free_bss_pool;\n\n\tspin_lock_irqsave(&free_queue->lock, irqL);\n\tpnetwork = list_first_entry_or_null(&free_queue->queue,\n\t\t\t\t\t    struct wlan_network, list);\n\tif (pnetwork) {\n\t\tlist_del_init(&pnetwork->list);\n\t\tpnetwork->last_scanned = jiffies;\n\t\tpmlmepriv->num_of_scanned++;\n\t}\n\tspin_unlock_irqrestore(&free_queue->lock, irqL);\n\treturn pnetwork;\n}\n\nstatic void _free_network(struct mlme_priv *pmlmepriv,\n\t\t\t  struct wlan_network *pnetwork)\n{\n\tu32 curr_time, delta_time;\n\tunsigned long irqL;\n\tstruct  __queue *free_queue = &(pmlmepriv->free_bss_pool);\n\n\tif (!pnetwork)\n\t\treturn;\n\tif (pnetwork->fixed)\n\t\treturn;\n\tcurr_time = jiffies;\n\tdelta_time = (curr_time - (u32)pnetwork->last_scanned) / HZ;\n\tif (delta_time < SCANQUEUE_LIFETIME)\n\t\treturn;\n\tspin_lock_irqsave(&free_queue->lock, irqL);\n\tlist_del_init(&pnetwork->list);\n\tlist_add_tail(&pnetwork->list, &free_queue->queue);\n\tpmlmepriv->num_of_scanned--;\n\tspin_unlock_irqrestore(&free_queue->lock, irqL);\n}\n\nstatic void free_network_nolock(struct mlme_priv *pmlmepriv,\n\t\t\t  struct wlan_network *pnetwork)\n{\n\tstruct  __queue *free_queue = &pmlmepriv->free_bss_pool;\n\n\tif (!pnetwork)\n\t\treturn;\n\tif (pnetwork->fixed)\n\t\treturn;\n\tlist_del_init(&pnetwork->list);\n\tlist_add_tail(&pnetwork->list, &free_queue->queue);\n\tpmlmepriv->num_of_scanned--;\n}\n\n \nstatic struct wlan_network *r8712_find_network(struct  __queue *scanned_queue,\n\t\t\t\t\t       u8 *addr)\n{\n\tunsigned long irqL;\n\tstruct list_head *phead, *plist;\n\tstruct wlan_network *pnetwork = NULL;\n\n\tif (is_zero_ether_addr(addr))\n\t\treturn NULL;\n\tspin_lock_irqsave(&scanned_queue->lock, irqL);\n\tphead = &scanned_queue->queue;\n\tlist_for_each(plist, phead) {\n\t\tpnetwork = list_entry(plist, struct wlan_network, list);\n\t\tif (!memcmp(addr, pnetwork->network.MacAddress, ETH_ALEN))\n\t\t\tbreak;\n\t}\n\tif (plist == phead)\n\t\tpnetwork = NULL;\n\tspin_unlock_irqrestore(&scanned_queue->lock, irqL);\n\treturn pnetwork;\n}\n\nvoid r8712_free_network_queue(struct _adapter *padapter)\n{\n\tunsigned long irqL;\n\tstruct list_head *phead, *plist;\n\tstruct wlan_network *pnetwork;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct  __queue *scanned_queue = &pmlmepriv->scanned_queue;\n\n\tspin_lock_irqsave(&scanned_queue->lock, irqL);\n\tphead = &scanned_queue->queue;\n\tplist = phead->next;\n\twhile (!end_of_queue_search(phead, plist)) {\n\t\tpnetwork = container_of(plist, struct wlan_network, list);\n\t\tplist = plist->next;\n\t\t_free_network(pmlmepriv, pnetwork);\n\t}\n\tspin_unlock_irqrestore(&scanned_queue->lock, irqL);\n}\n\nsint r8712_if_up(struct _adapter *padapter)\n{\n\tsint res;\n\n\tif (padapter->driver_stopped || padapter->surprise_removed ||\n\t    !check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {\n\t\tres = false;\n\t} else {\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nvoid r8712_generate_random_ibss(u8 *pibss)\n{\n\tu32 curtime = jiffies;\n\n\tpibss[0] = 0x02;  \n\tpibss[1] = 0x11;\n\tpibss[2] = 0x87;\n\tpibss[3] = (u8)(curtime & 0xff);\n\tpibss[4] = (u8)((curtime >> 8) & 0xff);\n\tpibss[5] = (u8)((curtime >> 16) & 0xff);\n}\n\nuint r8712_get_wlan_bssid_ex_sz(struct wlan_bssid_ex *bss)\n{\n\treturn sizeof(*bss) + bss->IELength - MAX_IE_SZ;\n}\n\nu8 *r8712_get_capability_from_ie(u8 *ie)\n{\n\treturn ie + 8 + 2;\n}\n\nvoid r8712_free_mlme_priv(struct mlme_priv *pmlmepriv)\n{\n\tkfree(pmlmepriv->free_bss_buf);\n}\n\nstatic struct\twlan_network *alloc_network(struct mlme_priv *pmlmepriv)\n{\n\treturn _r8712_alloc_network(pmlmepriv);\n}\n\nint r8712_is_same_ibss(struct _adapter *adapter, struct wlan_network *pnetwork)\n{\n\tint ret = true;\n\tstruct security_priv *psecuritypriv = &adapter->securitypriv;\n\n\tif ((psecuritypriv->PrivacyAlgrthm != _NO_PRIVACY_) &&\n\t\t    (pnetwork->network.Privacy == cpu_to_le32(0)))\n\t\tret = false;\n\telse if ((psecuritypriv->PrivacyAlgrthm == _NO_PRIVACY_) &&\n\t\t (pnetwork->network.Privacy == cpu_to_le32(1)))\n\t\tret = false;\n\telse\n\t\tret = true;\n\treturn ret;\n\n}\n\nstatic int is_same_network(struct wlan_bssid_ex *src,\n\t\t\t   struct wlan_bssid_ex *dst)\n{\n\tu16 s_cap, d_cap;\n\n\tmemcpy((u8 *)&s_cap, r8712_get_capability_from_ie(src->IEs), 2);\n\tmemcpy((u8 *)&d_cap, r8712_get_capability_from_ie(dst->IEs), 2);\n\treturn (src->Ssid.SsidLength == dst->Ssid.SsidLength) &&\n\t\t\t(src->Configuration.DSConfig ==\n\t\t\tdst->Configuration.DSConfig) &&\n\t\t\t((!memcmp(src->MacAddress, dst->MacAddress,\n\t\t\tETH_ALEN))) &&\n\t\t\t((!memcmp(src->Ssid.Ssid,\n\t\t\t  dst->Ssid.Ssid,\n\t\t\t  src->Ssid.SsidLength))) &&\n\t\t\t((s_cap & WLAN_CAPABILITY_IBSS) ==\n\t\t\t(d_cap & WLAN_CAPABILITY_IBSS)) &&\n\t\t\t((s_cap & WLAN_CAPABILITY_ESS) ==\n\t\t\t(d_cap & WLAN_CAPABILITY_ESS));\n\n}\n\nstruct\twlan_network *r8712_get_oldest_wlan_network(\n\t\t\t\tstruct  __queue *scanned_queue)\n{\n\tstruct list_head *plist, *phead;\n\tstruct\twlan_network\t*pwlan = NULL;\n\tstruct\twlan_network\t*oldest = NULL;\n\n\tphead = &scanned_queue->queue;\n\tplist = phead->next;\n\twhile (1) {\n\t\tif (end_of_queue_search(phead, plist))\n\t\t\tbreak;\n\t\tpwlan = container_of(plist, struct wlan_network, list);\n\t\tif (!pwlan->fixed) {\n\t\t\tif (!oldest ||\n\t\t\t    time_after((unsigned long)oldest->last_scanned,\n\t\t\t\t       (unsigned long)pwlan->last_scanned))\n\t\t\t\toldest = pwlan;\n\t\t}\n\t\tplist = plist->next;\n\t}\n\treturn oldest;\n}\n\nstatic void update_network(struct wlan_bssid_ex *dst,\n\t\t\t   struct wlan_bssid_ex *src,\n\t\t\t   struct _adapter *padapter)\n{\n\tu32 last_evm = 0, tmpVal;\n\tstruct smooth_rssi_data *sqd = &padapter->recvpriv.signal_qual_data;\n\n\tif (check_fwstate(&padapter->mlmepriv, _FW_LINKED) &&\n\t    is_same_network(&(padapter->mlmepriv.cur_network.network), src)) {\n\t\tif (padapter->recvpriv.signal_qual_data.total_num++ >=\n\t\t    PHY_LINKQUALITY_SLID_WIN_MAX) {\n\t\t\tpadapter->recvpriv.signal_qual_data.total_num =\n\t\t\t\t   PHY_LINKQUALITY_SLID_WIN_MAX;\n\t\t\tlast_evm = sqd->elements[sqd->index];\n\t\t\tpadapter->recvpriv.signal_qual_data.total_val -=\n\t\t\t\t last_evm;\n\t\t}\n\t\tpadapter->recvpriv.signal_qual_data.total_val += src->Rssi;\n\n\t\tsqd->elements[sqd->index++] = src->Rssi;\n\t\tif (padapter->recvpriv.signal_qual_data.index >=\n\t\t    PHY_LINKQUALITY_SLID_WIN_MAX)\n\t\t\tpadapter->recvpriv.signal_qual_data.index = 0;\n\t\t \n\t\ttmpVal = padapter->recvpriv.signal_qual_data.total_val /\n\t\t\t padapter->recvpriv.signal_qual_data.total_num;\n\t\tpadapter->recvpriv.signal = (u8)tmpVal;\n\n\t\tsrc->Rssi = padapter->recvpriv.signal;\n\t} else {\n\t\tsrc->Rssi = (src->Rssi + dst->Rssi) / 2;\n\t}\n\tmemcpy((u8 *)dst, (u8 *)src, r8712_get_wlan_bssid_ex_sz(src));\n}\n\nstatic void update_current_network(struct _adapter *adapter,\n\t\t\t\t   struct wlan_bssid_ex *pnetwork)\n{\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\n\tif (is_same_network(&(pmlmepriv->cur_network.network), pnetwork)) {\n\t\tupdate_network(&(pmlmepriv->cur_network.network),\n\t\t\t       pnetwork, adapter);\n\t\tr8712_update_protection(adapter,\n\t\t\t       (pmlmepriv->cur_network.network.IEs) +\n\t\t\t       sizeof(struct NDIS_802_11_FIXED_IEs),\n\t\t\t       pmlmepriv->cur_network.network.IELength);\n\t}\n}\n\n \nstatic void update_scanned_network(struct _adapter *adapter,\n\t\t\t    struct wlan_bssid_ex *target)\n{\n\tstruct list_head *plist, *phead;\n\n\tu32 bssid_ex_sz;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tstruct  __queue *queue = &pmlmepriv->scanned_queue;\n\tstruct wlan_network *pnetwork = NULL;\n\tstruct wlan_network *oldest = NULL;\n\n\tphead = &queue->queue;\n\tplist = phead->next;\n\n\twhile (1) {\n\t\tif (end_of_queue_search(phead, plist))\n\t\t\tbreak;\n\n\t\tpnetwork = container_of(plist, struct wlan_network, list);\n\t\tif (is_same_network(&pnetwork->network, target))\n\t\t\tbreak;\n\t\tif ((oldest == ((struct wlan_network *)0)) ||\n\t\t    time_after((unsigned long)oldest->last_scanned,\n\t\t\t\t(unsigned long)pnetwork->last_scanned))\n\t\t\toldest = pnetwork;\n\n\t\tplist = plist->next;\n\t}\n\n\t \n\tif (end_of_queue_search(phead, plist)) {\n\t\tif (list_empty(&pmlmepriv->free_bss_pool.queue)) {\n\t\t\t \n\t\t\tpnetwork = oldest;\n\t\t\ttarget->Rssi = (pnetwork->network.Rssi +\n\t\t\t\t\ttarget->Rssi) / 2;\n\t\t\tmemcpy(&pnetwork->network, target,\n\t\t\t\tr8712_get_wlan_bssid_ex_sz(target));\n\t\t\tpnetwork->last_scanned = jiffies;\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tpnetwork = alloc_network(pmlmepriv);\n\t\t\tif (!pnetwork)\n\t\t\t\treturn;\n\t\t\tbssid_ex_sz = r8712_get_wlan_bssid_ex_sz(target);\n\t\t\ttarget->Length = bssid_ex_sz;\n\t\t\tmemcpy(&pnetwork->network, target, bssid_ex_sz);\n\t\t\tlist_add_tail(&pnetwork->list, &queue->queue);\n\t\t}\n\t} else {\n\t\t \n\t\tupdate_network(&pnetwork->network, target, adapter);\n\t\tpnetwork->last_scanned = jiffies;\n\t}\n}\n\nstatic void rtl8711_add_network(struct _adapter *adapter,\n\t\t\t struct wlan_bssid_ex *pnetwork)\n{\n\tunsigned long irqL;\n\tstruct mlme_priv *pmlmepriv = &(((struct _adapter *)adapter)->mlmepriv);\n\tstruct  __queue *queue = &pmlmepriv->scanned_queue;\n\n\tspin_lock_irqsave(&queue->lock, irqL);\n\tupdate_current_network(adapter, pnetwork);\n\tupdate_scanned_network(adapter, pnetwork);\n\tspin_unlock_irqrestore(&queue->lock, irqL);\n}\n\n \nstatic int is_desired_network(struct _adapter *adapter,\n\t\t\t\tstruct wlan_network *pnetwork)\n{\n\tu8 wps_ie[512];\n\tuint wps_ielen;\n\tint bselected = true;\n\tstruct\tsecurity_priv *psecuritypriv = &adapter->securitypriv;\n\n\tif (psecuritypriv->wps_phase) {\n\t\tif (r8712_get_wps_ie(pnetwork->network.IEs,\n\t\t    pnetwork->network.IELength, wps_ie,\n\t\t    &wps_ielen))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tif ((psecuritypriv->PrivacyAlgrthm != _NO_PRIVACY_) &&\n\t\t    (pnetwork->network.Privacy == 0))\n\t\tbselected = false;\n\tif (check_fwstate(&adapter->mlmepriv, WIFI_ADHOC_STATE)) {\n\t\tif (pnetwork->network.InfrastructureMode !=\n\t\t\tadapter->mlmepriv.cur_network.network.InfrastructureMode)\n\t\t\tbselected = false;\n\t}\n\treturn bselected;\n}\n\n \nvoid r8712_atimdone_event_callback(struct _adapter *adapter, u8 *pbuf)\n{\n}\n\nvoid r8712_survey_event_callback(struct _adapter *adapter, u8 *pbuf)\n{\n\tunsigned long flags;\n\tu32 len;\n\tstruct wlan_bssid_ex *pnetwork;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\n\tpnetwork = (struct wlan_bssid_ex *)pbuf;\n#ifdef __BIG_ENDIAN\n\t \n\tpnetwork->Length = le32_to_cpu(pnetwork->Length);\n\tpnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);\n\tpnetwork->Privacy = le32_to_cpu(pnetwork->Privacy);\n\tpnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);\n\tpnetwork->NetworkTypeInUse = le32_to_cpu(pnetwork->NetworkTypeInUse);\n\tpnetwork->Configuration.ATIMWindow =\n\t\t le32_to_cpu(pnetwork->Configuration.ATIMWindow);\n\tpnetwork->Configuration.BeaconPeriod =\n\t\t le32_to_cpu(pnetwork->Configuration.BeaconPeriod);\n\tpnetwork->Configuration.DSConfig =\n\t\t le32_to_cpu(pnetwork->Configuration.DSConfig);\n\tpnetwork->Configuration.FHConfig.DwellTime =\n\t\t le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);\n\tpnetwork->Configuration.FHConfig.HopPattern =\n\t\t le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);\n\tpnetwork->Configuration.FHConfig.HopSet =\n\t\t le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);\n\tpnetwork->Configuration.FHConfig.Length =\n\t\t le32_to_cpu(pnetwork->Configuration.FHConfig.Length);\n\tpnetwork->Configuration.Length =\n\t\t le32_to_cpu(pnetwork->Configuration.Length);\n\tpnetwork->InfrastructureMode =\n\t\t le32_to_cpu(pnetwork->InfrastructureMode);\n\tpnetwork->IELength = le32_to_cpu(pnetwork->IELength);\n#endif\n\tlen = r8712_get_wlan_bssid_ex_sz(pnetwork);\n\tif (len > sizeof(struct wlan_bssid_ex))\n\t\treturn;\n\tspin_lock_irqsave(&pmlmepriv->lock2, flags);\n\t \n\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\n\t\tif (!memcmp(&(pmlmepriv->cur_network.network.MacAddress),\n\t\t    pnetwork->MacAddress, ETH_ALEN)) {\n\t\t\tstruct wlan_network *ibss_wlan = NULL;\n\n\t\t\tmemcpy(pmlmepriv->cur_network.network.IEs,\n\t\t\t\tpnetwork->IEs, 8);\n\t\t\tibss_wlan = r8712_find_network(\n\t\t\t\t\t\t&pmlmepriv->scanned_queue,\n\t\t\t\t\t\tpnetwork->MacAddress);\n\t\t\tif (ibss_wlan) {\n\t\t\t\tmemcpy(ibss_wlan->network.IEs,\n\t\t\t\t\tpnetwork->IEs, 8);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (!check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) {\n\t\tif (pnetwork->Ssid.Ssid[0] != 0) {\n\t\t\trtl8711_add_network(adapter, pnetwork);\n\t\t} else {\n\t\t\tpnetwork->Ssid.SsidLength = 8;\n\t\t\tmemcpy(pnetwork->Ssid.Ssid, \"<hidden>\", 8);\n\t\t\trtl8711_add_network(adapter, pnetwork);\n\t\t}\n\t}\nexit:\n\tspin_unlock_irqrestore(&pmlmepriv->lock2, flags);\n}\n\nvoid r8712_surveydone_event_callback(struct _adapter *adapter, u8 *pbuf)\n{\n\tunsigned long irqL;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\n\tspin_lock_irqsave(&pmlmepriv->lock, irqL);\n\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {\n\t\tdel_timer(&pmlmepriv->scan_to_timer);\n\n\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);\n\t}\n\n\tif (pmlmepriv->to_join) {\n\t\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {\n\t\t\tif (!check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\t\t\tset_fwstate(pmlmepriv, _FW_UNDER_LINKING);\n\n\t\t\t\tif (!r8712_select_and_join_from_scan(pmlmepriv)) {\n\t\t\t\t\tmod_timer(&pmlmepriv->assoc_timer, jiffies +\n\t\t\t\t\t\t  msecs_to_jiffies(MAX_JOIN_TIMEOUT));\n\t\t\t\t} else {\n\t\t\t\t\tstruct wlan_bssid_ex *pdev_network =\n\t\t\t\t\t  &(adapter->registrypriv.dev_network);\n\t\t\t\t\tu8 *pibss =\n\t\t\t\t\t\t adapter->registrypriv.dev_network.MacAddress;\n\t\t\t\t\tpmlmepriv->fw_state ^= _FW_UNDER_SURVEY;\n\t\t\t\t\tmemcpy(&pdev_network->Ssid,\n\t\t\t\t\t\t&pmlmepriv->assoc_ssid,\n\t\t\t\t\t\tsizeof(struct\n\t\t\t\t\t\t\t ndis_802_11_ssid));\n\t\t\t\t\tr8712_update_registrypriv_dev_network\n\t\t\t\t\t\t(adapter);\n\t\t\t\t\tr8712_generate_random_ibss(pibss);\n\t\t\t\t\tpmlmepriv->fw_state =\n\t\t\t\t\t\t WIFI_ADHOC_MASTER_STATE;\n\t\t\t\t\tpmlmepriv->to_join = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tpmlmepriv->to_join = false;\n\t\t\tset_fwstate(pmlmepriv, _FW_UNDER_LINKING);\n\t\t\tif (!r8712_select_and_join_from_scan(pmlmepriv))\n\t\t\t\tmod_timer(&pmlmepriv->assoc_timer, jiffies +\n\t\t\t\t\t  msecs_to_jiffies(MAX_JOIN_TIMEOUT));\n\t\t\telse\n\t\t\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\n}\n\n \nvoid r8712_free_assoc_resources(struct _adapter *adapter)\n{\n\tunsigned long irqL;\n\tstruct wlan_network *pwlan = NULL;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tstruct sta_priv *pstapriv = &adapter->stapriv;\n\tstruct wlan_network *tgt_network = &pmlmepriv->cur_network;\n\n\tpwlan = r8712_find_network(&pmlmepriv->scanned_queue,\n\t\t\t\t   tgt_network->network.MacAddress);\n\n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_AP_STATE)) {\n\t\tstruct sta_info *psta;\n\n\t\tpsta = r8712_get_stainfo(&adapter->stapriv,\n\t\t\t\t\t tgt_network->network.MacAddress);\n\n\t\tspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);\n\t\tr8712_free_stainfo(adapter,  psta);\n\t\tspin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);\n\t}\n\n\tif (check_fwstate(pmlmepriv,\n\t    WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE | WIFI_AP_STATE))\n\t\tr8712_free_all_stainfo(adapter);\n\tif (pwlan)\n\t\tpwlan->fixed = false;\n\n\tif (((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) &&\n\t     (adapter->stapriv.asoc_sta_count == 1)))\n\t\tfree_network_nolock(pmlmepriv, pwlan);\n}\n\n \nvoid r8712_indicate_connect(struct _adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tpmlmepriv->to_join = false;\n\tset_fwstate(pmlmepriv, _FW_LINKED);\n\tpadapter->ledpriv.LedControlHandler(padapter, LED_CTL_LINK);\n\tr8712_os_indicate_connect(padapter);\n\tif (padapter->registrypriv.power_mgnt > PS_MODE_ACTIVE)\n\t\tmod_timer(&pmlmepriv->dhcp_timer,\n\t\t\t  jiffies + msecs_to_jiffies(60000));\n}\n\n \nvoid r8712_ind_disconnect(struct _adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\t_clr_fwstate_(pmlmepriv, _FW_LINKED);\n\t\tpadapter->ledpriv.LedControlHandler(padapter, LED_CTL_NO_LINK);\n\t\tr8712_os_indicate_disconnect(padapter);\n\t}\n\tif (padapter->pwrctrlpriv.pwr_mode !=\n\t    padapter->registrypriv.power_mgnt) {\n\t\tdel_timer(&pmlmepriv->dhcp_timer);\n\t\tr8712_set_ps_mode(padapter, padapter->registrypriv.power_mgnt,\n\t\t\t\t  padapter->registrypriv.smart_ps);\n\t}\n}\n\n \nvoid r8712_joinbss_event_callback(struct _adapter *adapter, u8 *pbuf)\n{\n\tunsigned long irqL = 0, irqL2;\n\tstruct sta_info\t*ptarget_sta = NULL, *pcur_sta = NULL;\n\tstruct sta_priv\t*pstapriv = &adapter->stapriv;\n\tstruct mlme_priv\t*pmlmepriv = &adapter->mlmepriv;\n\tstruct wlan_network\t*cur_network = &pmlmepriv->cur_network;\n\tstruct wlan_network\t*pcur_wlan = NULL, *ptarget_wlan = NULL;\n\tunsigned int\t\tthe_same_macaddr = false;\n\tstruct wlan_network *pnetwork;\n\n\tif (sizeof(struct list_head) == 4 * sizeof(u32)) {\n\t\tpnetwork = kmalloc(sizeof(struct wlan_network), GFP_ATOMIC);\n\t\tif (!pnetwork)\n\t\t\treturn;\n\t\tmemcpy((u8 *)pnetwork + 16, (u8 *)pbuf + 8,\n\t\t\tsizeof(struct wlan_network) - 16);\n\t} else {\n\t\tpnetwork = (struct wlan_network *)pbuf;\n\t}\n\n#ifdef __BIG_ENDIAN\n\t \n\tpnetwork->join_res = le32_to_cpu(pnetwork->join_res);\n\tpnetwork->network_type = le32_to_cpu(pnetwork->network_type);\n\tpnetwork->network.Length = le32_to_cpu(pnetwork->network.Length);\n\tpnetwork->network.Ssid.SsidLength =\n\t\tle32_to_cpu(pnetwork->network.Ssid.SsidLength);\n\tpnetwork->network.Privacy = le32_to_cpu(pnetwork->network.Privacy);\n\tpnetwork->network.Rssi = le32_to_cpu(pnetwork->network.Rssi);\n\tpnetwork->network.NetworkTypeInUse =\n\t\tle32_to_cpu(pnetwork->network.NetworkTypeInUse);\n\tpnetwork->network.Configuration.ATIMWindow =\n\t\tle32_to_cpu(pnetwork->network.Configuration.ATIMWindow);\n\tpnetwork->network.Configuration.BeaconPeriod =\n\t\tle32_to_cpu(pnetwork->network.Configuration.BeaconPeriod);\n\tpnetwork->network.Configuration.DSConfig =\n\t\tle32_to_cpu(pnetwork->network.Configuration.DSConfig);\n\tpnetwork->network.Configuration.FHConfig.DwellTime =\n\t\tle32_to_cpu(pnetwork->network.Configuration.FHConfig.DwellTime);\n\tpnetwork->network.Configuration.FHConfig.HopPattern =\n\t\tle32_to_cpu(pnetwork->network.Configuration.FHConfig.HopPattern);\n\tpnetwork->network.Configuration.FHConfig.HopSet =\n\t\tle32_to_cpu(pnetwork->network.Configuration.FHConfig.HopSet);\n\tpnetwork->network.Configuration.FHConfig.Length =\n\t\tle32_to_cpu(pnetwork->network.Configuration.FHConfig.Length);\n\tpnetwork->network.Configuration.Length =\n\t\tle32_to_cpu(pnetwork->network.Configuration.Length);\n\tpnetwork->network.InfrastructureMode =\n\t\tle32_to_cpu(pnetwork->network.InfrastructureMode);\n\tpnetwork->network.IELength = le32_to_cpu(pnetwork->network.IELength);\n#endif\n\n\tthe_same_macaddr = !memcmp(pnetwork->network.MacAddress,\n\t\t\t\tcur_network->network.MacAddress, ETH_ALEN);\n\tpnetwork->network.Length =\n\t\tr8712_get_wlan_bssid_ex_sz(&pnetwork->network);\n\tspin_lock_irqsave(&pmlmepriv->lock, irqL);\n\tif (pnetwork->network.Length > sizeof(struct wlan_bssid_ex))\n\t\tgoto ignore_joinbss_callback;\n\tif (pnetwork->join_res > 0) {\n\t\tif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) {\n\t\t\t \n\t\t\tif (check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\t\t\tif (the_same_macaddr) {\n\t\t\t\t\tptarget_wlan =\n\t\t\t\t\t\tr8712_find_network(&pmlmepriv->scanned_queue,\n\t\t\t\t\t\tcur_network->network.MacAddress);\n\t\t\t\t} else {\n\t\t\t\t\tpcur_wlan =\n\t\t\t\t\t\tr8712_find_network(&pmlmepriv->scanned_queue,\n\t\t\t\t\t\tcur_network->network.MacAddress);\n\t\t\t\t\tif (pcur_wlan)\n\t\t\t\t\t\tpcur_wlan->fixed = false;\n\n\t\t\t\t\tpcur_sta = r8712_get_stainfo(pstapriv,\n\t\t\t\t\t\tcur_network->network.MacAddress);\n\t\t\t\t\tspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL2);\n\t\t\t\t\tr8712_free_stainfo(adapter, pcur_sta);\n\t\t\t\t\tspin_unlock_irqrestore(&(pstapriv->sta_hash_lock), irqL2);\n\n\t\t\t\t\tptarget_wlan =\n\t\t\t\t\t\tr8712_find_network(&pmlmepriv->scanned_queue,\n\t\t\t\t\t\tpnetwork->network.MacAddress);\n\t\t\t\t\tif (ptarget_wlan)\n\t\t\t\t\t\tptarget_wlan->fixed = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tptarget_wlan = r8712_find_network(&pmlmepriv->scanned_queue,\n\t\t\t\t\t\tpnetwork->network.MacAddress);\n\t\t\t\tif (ptarget_wlan)\n\t\t\t\t\tptarget_wlan->fixed = true;\n\t\t\t}\n\n\t\t\tif (!ptarget_wlan) {\n\t\t\t\tif (check_fwstate(pmlmepriv,\n\t\t\t\t\t_FW_UNDER_LINKING))\n\t\t\t\t\tpmlmepriv->fw_state ^=\n\t\t\t\t\t\t_FW_UNDER_LINKING;\n\t\t\t\tgoto ignore_joinbss_callback;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\n\t\t\t\tif (the_same_macaddr) {\n\t\t\t\t\tptarget_sta =\n\t\t\t\t\t\tr8712_get_stainfo(pstapriv,\n\t\t\t\t\t\tpnetwork->network.MacAddress);\n\t\t\t\t\tif (!ptarget_sta)\n\t\t\t\t\t\tptarget_sta =\n\t\t\t\t\t\tr8712_alloc_stainfo(pstapriv,\n\t\t\t\t\t\tpnetwork->network.MacAddress);\n\t\t\t\t} else {\n\t\t\t\t\tptarget_sta =\n\t\t\t\t\t\tr8712_alloc_stainfo(pstapriv,\n\t\t\t\t\t\tpnetwork->network.MacAddress);\n\t\t\t\t}\n\t\t\t\tif (ptarget_sta)   {\n\t\t\t\t\tptarget_sta->aid = pnetwork->join_res;\n\t\t\t\t\tptarget_sta->qos_option = 1;\n\t\t\t\t\tptarget_sta->mac_id = 5;\n\t\t\t\t\tif (adapter->securitypriv.AuthAlgrthm == 2) {\n\t\t\t\t\t\tadapter->securitypriv.binstallGrpkey = false;\n\t\t\t\t\t\tadapter->securitypriv.busetkipkey = false;\n\t\t\t\t\t\tadapter->securitypriv.bgrpkey_handshake = false;\n\t\t\t\t\t\tptarget_sta->ieee8021x_blocked = true;\n\t\t\t\t\t\tptarget_sta->XPrivacy =\n\t\t\t\t\t\t\tadapter->securitypriv.PrivacyAlgrthm;\n\t\t\t\t\t\tmemset((u8 *)&ptarget_sta->x_UncstKey,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tsizeof(union Keytype));\n\t\t\t\t\t\tmemset((u8 *)&ptarget_sta->tkiprxmickey,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tsizeof(union Keytype));\n\t\t\t\t\t\tmemset((u8 *)&ptarget_sta->tkiptxmickey,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tsizeof(union Keytype));\n\t\t\t\t\t\tmemset((u8 *)&ptarget_sta->txpn,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tsizeof(union pn48));\n\t\t\t\t\t\tmemset((u8 *)&ptarget_sta->rxpn,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tsizeof(union pn48));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))\n\t\t\t\t\t\tpmlmepriv->fw_state ^=\n\t\t\t\t\t\t\t_FW_UNDER_LINKING;\n\t\t\t\t\tgoto ignore_joinbss_callback;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tmemcpy(&cur_network->network, &pnetwork->network,\n\t\t\t\tpnetwork->network.Length);\n\t\t\tcur_network->aid = pnetwork->join_res;\n\t\t\t \n\t\t\tswitch (pnetwork->network.InfrastructureMode) {\n\t\t\tcase Ndis802_11Infrastructure:\n\t\t\t\tpmlmepriv->fw_state = WIFI_STATION_STATE;\n\t\t\t\tbreak;\n\t\t\tcase Ndis802_11IBSS:\n\t\t\t\tpmlmepriv->fw_state = WIFI_ADHOC_STATE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpmlmepriv->fw_state = WIFI_NULL_STATE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr8712_update_protection(adapter,\n\t\t\t\t(cur_network->network.IEs) +\n\t\t\t\tsizeof(struct NDIS_802_11_FIXED_IEs),\n\t\t\t\t(cur_network->network.IELength));\n\t\t\t \n\t\t\tupdate_ht_cap(adapter, cur_network->network.IEs,\n\t\t\t\tcur_network->network.IELength);\n\t\t\t \n\t\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE))\n\t\t\t\tr8712_indicate_connect(adapter);\n\t\t\tdel_timer(&pmlmepriv->assoc_timer);\n\t\t} else {\n\t\t\tgoto ignore_joinbss_callback;\n\t\t}\n\t} else {\n\t\tif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) {\n\t\t\tmod_timer(&pmlmepriv->assoc_timer,\n\t\t\t\tjiffies + msecs_to_jiffies(1));\n\t\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\n\t\t}\n\t}\nignore_joinbss_callback:\n\tspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\n\tif (sizeof(struct list_head) == 4 * sizeof(u32))\n\t\tkfree(pnetwork);\n}\n\nvoid r8712_stassoc_event_callback(struct _adapter *adapter, u8 *pbuf)\n{\n\tunsigned long irqL;\n\tstruct sta_info *psta;\n\tstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\n\tstruct stassoc_event *pstassoc\t= (struct stassoc_event *)pbuf;\n\n\t \n\tif (!r8712_access_ctrl(&adapter->acl_list, pstassoc->macaddr))\n\t\treturn;\n\tpsta = r8712_get_stainfo(&adapter->stapriv, pstassoc->macaddr);\n\tif (psta) {\n\t\t \n\t\treturn;\n\t}\n\n\tpsta = r8712_alloc_stainfo(&adapter->stapriv, pstassoc->macaddr);\n\tif (!psta)\n\t\treturn;\n\t \n\tpsta->qos_option = 0;\n\tpsta->mac_id = le32_to_cpu(pstassoc->cam_id);\n\t \n\n\tif (adapter->securitypriv.AuthAlgrthm == 2)\n\t\tpsta->XPrivacy = adapter->securitypriv.PrivacyAlgrthm;\n\tpsta->ieee8021x_blocked = false;\n\tspin_lock_irqsave(&pmlmepriv->lock, irqL);\n\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) ||\n\t    check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {\n\t\tif (adapter->stapriv.asoc_sta_count == 2) {\n\t\t\t \n\t\t\tr8712_indicate_connect(adapter);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\n}\n\nvoid r8712_stadel_event_callback(struct _adapter *adapter, u8 *pbuf)\n{\n\tunsigned long irqL, irqL2;\n\tstruct sta_info *psta;\n\tstruct wlan_network *pwlan = NULL;\n\tstruct wlan_bssid_ex *pdev_network = NULL;\n\tu8 *pibss = NULL;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tstruct stadel_event *pstadel = (struct stadel_event *)pbuf;\n\tstruct sta_priv *pstapriv = &adapter->stapriv;\n\tstruct wlan_network *tgt_network = &pmlmepriv->cur_network;\n\n\tspin_lock_irqsave(&pmlmepriv->lock, irqL2);\n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\n\t\tr8712_ind_disconnect(adapter);\n\t\tr8712_free_assoc_resources(adapter);\n\t}\n\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE |\n\t    WIFI_ADHOC_STATE)) {\n\t\tpsta = r8712_get_stainfo(&adapter->stapriv, pstadel->macaddr);\n\t\tspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);\n\t\tr8712_free_stainfo(adapter, psta);\n\t\tspin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);\n\t\tif (adapter->stapriv.asoc_sta_count == 1) {\n\t\t\t \n\t\t\tpwlan = r8712_find_network(&pmlmepriv->scanned_queue,\n\t\t\t\ttgt_network->network.MacAddress);\n\t\t\tif (pwlan) {\n\t\t\t\tpwlan->fixed = false;\n\t\t\t\tfree_network_nolock(pmlmepriv, pwlan);\n\t\t\t}\n\t\t\t \n\t\t\tpdev_network = &(adapter->registrypriv.dev_network);\n\t\t\tpibss = adapter->registrypriv.dev_network.MacAddress;\n\t\t\tmemcpy(pdev_network, &tgt_network->network,\n\t\t\t\tr8712_get_wlan_bssid_ex_sz(&tgt_network->network));\n\t\t\tmemcpy(&pdev_network->Ssid,\n\t\t\t\t&pmlmepriv->assoc_ssid,\n\t\t\t\tsizeof(struct ndis_802_11_ssid));\n\t\t\tr8712_update_registrypriv_dev_network(adapter);\n\t\t\tr8712_generate_random_ibss(pibss);\n\t\t\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {\n\t\t\t\t_clr_fwstate_(pmlmepriv, WIFI_ADHOC_STATE);\n\t\t\t\tset_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pmlmepriv->lock, irqL2);\n}\n\nvoid r8712_cpwm_event_callback(struct _adapter *adapter, u8 *pbuf)\n{\n\tstruct reportpwrstate_parm *preportpwrstate =\n\t\t\t (struct reportpwrstate_parm *)pbuf;\n\n\tpreportpwrstate->state |= (u8)(adapter->pwrctrlpriv.cpwm_tog + 0x80);\n\tr8712_cpwm_int_hdl(adapter, preportpwrstate);\n}\n\n \nvoid r8712_got_addbareq_event_callback(struct _adapter *adapter, u8 *pbuf)\n{\n\tstruct\tADDBA_Req_Report_parm *pAddbareq_pram =\n\t\t\t (struct ADDBA_Req_Report_parm *)pbuf;\n\tstruct\tsta_info *psta;\n\tstruct\tsta_priv *pstapriv = &adapter->stapriv;\n\tstruct\trecv_reorder_ctrl *precvreorder_ctrl = NULL;\n\n\tpsta = r8712_get_stainfo(pstapriv, pAddbareq_pram->MacAddress);\n\tif (psta) {\n\t\tprecvreorder_ctrl =\n\t\t\t &psta->recvreorder_ctrl[pAddbareq_pram->tid];\n\t\t \n\t\tprecvreorder_ctrl->indicate_seq = 0xffff;\n\t}\n}\n\nvoid r8712_wpspbc_event_callback(struct _adapter *adapter, u8 *pbuf)\n{\n\tif (!adapter->securitypriv.wps_hw_pbc_pressed)\n\t\tadapter->securitypriv.wps_hw_pbc_pressed = true;\n}\n\nvoid _r8712_sitesurvey_ctrl_handler(struct _adapter *adapter)\n{\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tstruct sitesurvey_ctrl\t*psitesurveyctrl = &pmlmepriv->sitesurveyctrl;\n\tstruct registry_priv\t*pregistrypriv = &adapter->registrypriv;\n\tu64 current_tx_pkts;\n\tuint current_rx_pkts;\n\n\tcurrent_tx_pkts = (adapter->xmitpriv.tx_pkts) -\n\t\t\t  (psitesurveyctrl->last_tx_pkts);\n\tcurrent_rx_pkts = (adapter->recvpriv.rx_pkts) -\n\t\t\t  (psitesurveyctrl->last_rx_pkts);\n\tpsitesurveyctrl->last_tx_pkts = adapter->xmitpriv.tx_pkts;\n\tpsitesurveyctrl->last_rx_pkts = adapter->recvpriv.rx_pkts;\n\tif ((current_tx_pkts > pregistrypriv->busy_thresh) ||\n\t    (current_rx_pkts > pregistrypriv->busy_thresh))\n\t\tpsitesurveyctrl->traffic_busy = true;\n\telse\n\t\tpsitesurveyctrl->traffic_busy = false;\n}\n\nvoid _r8712_join_timeout_handler(struct _adapter *adapter)\n{\n\tunsigned long irqL;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\n\tif (adapter->driver_stopped || adapter->surprise_removed)\n\t\treturn;\n\tspin_lock_irqsave(&pmlmepriv->lock, irqL);\n\t_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\n\tpmlmepriv->to_join = false;\n\tif (check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\tr8712_os_indicate_disconnect(adapter);\n\t\t_clr_fwstate_(pmlmepriv, _FW_LINKED);\n\t}\n\tif (adapter->pwrctrlpriv.pwr_mode != adapter->registrypriv.power_mgnt) {\n\t\tr8712_set_ps_mode(adapter, adapter->registrypriv.power_mgnt,\n\t\t\t\t  adapter->registrypriv.smart_ps);\n\t}\n\tspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\n}\n\nvoid r8712_scan_timeout_handler (struct _adapter *adapter)\n{\n\tunsigned long irqL;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\n\tspin_lock_irqsave(&pmlmepriv->lock, irqL);\n\t_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);\n\tpmlmepriv->to_join = false;\t \n\tspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\n}\n\nvoid _r8712_dhcp_timeout_handler (struct _adapter *adapter)\n{\n\tif (adapter->driver_stopped || adapter->surprise_removed)\n\t\treturn;\n\tif (adapter->pwrctrlpriv.pwr_mode != adapter->registrypriv.power_mgnt)\n\t\tr8712_set_ps_mode(adapter, adapter->registrypriv.power_mgnt,\n\t\t\t    adapter->registrypriv.smart_ps);\n}\n\nint r8712_select_and_join_from_scan(struct mlme_priv *pmlmepriv)\n{\n\tstruct list_head *phead;\n\tunsigned char *dst_ssid, *src_ssid;\n\tstruct _adapter *adapter;\n\tstruct  __queue *queue = NULL;\n\tstruct wlan_network *pnetwork = NULL;\n\tstruct wlan_network *pnetwork_max_rssi = NULL;\n\n\tadapter = (struct _adapter *)pmlmepriv->nic_hdl;\n\tqueue = &pmlmepriv->scanned_queue;\n\tphead = &queue->queue;\n\tpmlmepriv->pscanned = phead->next;\n\twhile (1) {\n\t\tif (end_of_queue_search(phead, pmlmepriv->pscanned)) {\n\t\t\tif (pmlmepriv->assoc_by_rssi && pnetwork_max_rssi) {\n\t\t\t\tpnetwork = pnetwork_max_rssi;\n\t\t\t\tgoto ask_for_joinbss;\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpnetwork = container_of(pmlmepriv->pscanned,\n\t\t\t\t\tstruct wlan_network, list);\n\t\tpmlmepriv->pscanned = pmlmepriv->pscanned->next;\n\t\tif (pmlmepriv->assoc_by_bssid) {\n\t\t\tdst_ssid = pnetwork->network.MacAddress;\n\t\t\tsrc_ssid = pmlmepriv->assoc_bssid;\n\t\t\tif (!memcmp(dst_ssid, src_ssid, ETH_ALEN)) {\n\t\t\t\tif (check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\t\t\t\tif (is_same_network(&pmlmepriv->cur_network.network,\n\t\t\t\t\t    &pnetwork->network)) {\n\t\t\t\t\t\t_clr_fwstate_(pmlmepriv,\n\t\t\t\t\t\t\t_FW_UNDER_LINKING);\n\t\t\t\t\t\t \n\t\t\t\t\t\tr8712_indicate_connect(adapter);\n\t\t\t\t\t\treturn 2;\n\t\t\t\t\t}\n\t\t\t\t\tr8712_disassoc_cmd(adapter);\n\t\t\t\t\tr8712_ind_disconnect(adapter);\n\t\t\t\t\tr8712_free_assoc_resources(adapter);\n\t\t\t\t}\n\t\t\t\tgoto ask_for_joinbss;\n\t\t\t}\n\t\t} else if (pmlmepriv->assoc_ssid.SsidLength == 0) {\n\t\t\tgoto ask_for_joinbss;\n\t\t}\n\t\tdst_ssid = pnetwork->network.Ssid.Ssid;\n\t\tsrc_ssid = pmlmepriv->assoc_ssid.Ssid;\n\t\tif ((pnetwork->network.Ssid.SsidLength ==\n\t\t    pmlmepriv->assoc_ssid.SsidLength) &&\n\t\t    (!memcmp(dst_ssid, src_ssid,\n\t\t     pmlmepriv->assoc_ssid.SsidLength))) {\n\t\t\tif (pmlmepriv->assoc_by_rssi) {\n\t\t\t\t \n\t\t\t\tif (pnetwork_max_rssi) {\n\t\t\t\t\tif (pnetwork->network.Rssi >\n\t\t\t\t\t    pnetwork_max_rssi->network.Rssi)\n\t\t\t\t\t\tpnetwork_max_rssi = pnetwork;\n\t\t\t\t} else {\n\t\t\t\t\tpnetwork_max_rssi = pnetwork;\n\t\t\t\t}\n\t\t\t} else if (is_desired_network(adapter, pnetwork)) {\n\t\t\t\tif (check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\t\t\t\tr8712_disassoc_cmd(adapter);\n\t\t\t\t\tr8712_free_assoc_resources(adapter);\n\t\t\t\t}\n\t\t\t\tgoto ask_for_joinbss;\n\t\t\t}\n\t\t}\n\t}\n\nask_for_joinbss:\n\treturn r8712_joinbss_cmd(adapter, pnetwork);\n}\n\nint r8712_set_auth(struct _adapter *adapter,\n\t\t   struct security_priv *psecuritypriv)\n{\n\tstruct cmd_priv\t*pcmdpriv = &adapter->cmdpriv;\n\tstruct cmd_obj *pcmd;\n\tstruct setauth_parm *psetauthparm;\n\n\tpcmd = kmalloc(sizeof(*pcmd), GFP_ATOMIC);\n\tif (!pcmd)\n\t\treturn -ENOMEM;\n\n\tpsetauthparm = kzalloc(sizeof(*psetauthparm), GFP_ATOMIC);\n\tif (!psetauthparm) {\n\t\tkfree(pcmd);\n\t\treturn -ENOMEM;\n\t}\n\tpsetauthparm->mode = (u8)psecuritypriv->AuthAlgrthm;\n\tpcmd->cmdcode = _SetAuth_CMD_;\n\tpcmd->parmbuf = (unsigned char *)psetauthparm;\n\tpcmd->cmdsz = sizeof(struct setauth_parm);\n\tpcmd->rsp = NULL;\n\tpcmd->rspsz = 0;\n\tINIT_LIST_HEAD(&pcmd->list);\n\tr8712_enqueue_cmd(pcmdpriv, pcmd);\n\treturn 0;\n}\n\nint r8712_set_key(struct _adapter *adapter,\n\t\t  struct security_priv *psecuritypriv,\n\t\t  sint keyid)\n{\n\tstruct cmd_priv *pcmdpriv = &adapter->cmdpriv;\n\tstruct cmd_obj *pcmd;\n\tstruct setkey_parm *psetkeyparm;\n\tu8 keylen;\n\tint ret;\n\n\tpcmd = kmalloc(sizeof(*pcmd), GFP_ATOMIC);\n\tif (!pcmd)\n\t\treturn -ENOMEM;\n\tpsetkeyparm = kzalloc(sizeof(*psetkeyparm), GFP_ATOMIC);\n\tif (!psetkeyparm) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_cmd;\n\t}\n\tif (psecuritypriv->AuthAlgrthm == 2) {  \n\t\tpsetkeyparm->algorithm =\n\t\t\t (u8)psecuritypriv->XGrpPrivacy;\n\t} else {  \n\t\tpsetkeyparm->algorithm =\n\t\t\t (u8)psecuritypriv->PrivacyAlgrthm;\n\t}\n\tpsetkeyparm->keyid = (u8)keyid;\n\n\tswitch (psetkeyparm->algorithm) {\n\tcase _WEP40_:\n\t\tkeylen = 5;\n\t\tmemcpy(psetkeyparm->key,\n\t\t\tpsecuritypriv->DefKey[keyid].skey, keylen);\n\t\tbreak;\n\tcase _WEP104_:\n\t\tkeylen = 13;\n\t\tmemcpy(psetkeyparm->key,\n\t\t\tpsecuritypriv->DefKey[keyid].skey, keylen);\n\t\tbreak;\n\tcase _TKIP_:\n\t\tif (keyid < 1 || keyid > 2) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_parm;\n\t\t}\n\t\tkeylen = 16;\n\t\tmemcpy(psetkeyparm->key,\n\t\t\t&psecuritypriv->XGrpKey[keyid - 1], keylen);\n\t\tpsetkeyparm->grpkey = 1;\n\t\tbreak;\n\tcase _AES_:\n\t\tif (keyid < 1 || keyid > 2) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_parm;\n\t\t}\n\t\tkeylen = 16;\n\t\tmemcpy(psetkeyparm->key,\n\t\t\t&psecuritypriv->XGrpKey[keyid - 1], keylen);\n\t\tpsetkeyparm->grpkey = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_free_parm;\n\t}\n\tpcmd->cmdcode = _SetKey_CMD_;\n\tpcmd->parmbuf = (u8 *)psetkeyparm;\n\tpcmd->cmdsz =  (sizeof(struct setkey_parm));\n\tpcmd->rsp = NULL;\n\tpcmd->rspsz = 0;\n\tINIT_LIST_HEAD(&pcmd->list);\n\tr8712_enqueue_cmd(pcmdpriv, pcmd);\n\treturn 0;\n\nerr_free_parm:\n\tkfree(psetkeyparm);\nerr_free_cmd:\n\tkfree(pcmd);\n\treturn ret;\n}\n\n \nint r8712_restruct_wmm_ie(struct _adapter *adapter, u8 *in_ie, u8 *out_ie,\n\t\t    uint in_len, uint initial_out_len)\n{\n\tunsigned int ielength = 0;\n\tunsigned int i, j;\n\n\ti = 12;  \n\twhile (i < in_len) {\n\t\tielength = initial_out_len;\n\t\tif (in_ie[i] == 0xDD && in_ie[i + 2] == 0x00 &&\n\t\t    in_ie[i + 3] == 0x50 && in_ie[i + 4] == 0xF2 &&\n\t\t    in_ie[i + 5] == 0x02 && i + 5 < in_len) {\n\t\t\t \n\t\t\tfor (j = i; j < i + 9; j++) {\n\t\t\t\tout_ie[ielength] = in_ie[j];\n\t\t\t\tielength++;\n\t\t\t}\n\t\t\tout_ie[initial_out_len + 1] = 0x07;\n\t\t\tout_ie[initial_out_len + 6] = 0x00;\n\t\t\tout_ie[initial_out_len + 8] = 0x00;\n\t\t\tbreak;\n\t\t}\n\t\ti += (in_ie[i + 1] + 2);  \n\t}\n\treturn ielength;\n}\n\n \nstatic int SecIsInPMKIDList(struct _adapter *Adapter, u8 *bssid)\n{\n\tstruct security_priv *p = &Adapter->securitypriv;\n\tint i;\n\n\tfor (i = 0; i < NUM_PMKID_CACHE; i++)\n\t\tif (p->PMKIDList[i].bUsed && !memcmp(p->PMKIDList[i].Bssid, bssid, ETH_ALEN))\n\t\t\treturn i;\n\treturn -1;\n}\n\nsint r8712_restruct_sec_ie(struct _adapter *adapter, u8 *in_ie,\n\t\t     u8 *out_ie, uint in_len)\n{\n\tu8 authmode = 0, match;\n\tu8 sec_ie[IW_CUSTOM_MAX], uncst_oui[4], bkup_ie[255];\n\tu8 wpa_oui[4] = {0x0, 0x50, 0xf2, 0x01};\n\tuint ielength, cnt, remove_cnt;\n\tint iEntry;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &adapter->securitypriv;\n\tuint ndisauthmode = psecuritypriv->ndisauthtype;\n\tuint ndissecuritytype = psecuritypriv->ndisencryptstatus;\n\n\tif ((ndisauthmode == Ndis802_11AuthModeWPA) ||\n\t    (ndisauthmode == Ndis802_11AuthModeWPAPSK)) {\n\t\tauthmode = _WPA_IE_ID_;\n\t\tuncst_oui[0] = 0x0;\n\t\tuncst_oui[1] = 0x50;\n\t\tuncst_oui[2] = 0xf2;\n\t}\n\tif ((ndisauthmode == Ndis802_11AuthModeWPA2) ||\n\t    (ndisauthmode == Ndis802_11AuthModeWPA2PSK)) {\n\t\tauthmode = _WPA2_IE_ID_;\n\t\tuncst_oui[0] = 0x0;\n\t\tuncst_oui[1] = 0x0f;\n\t\tuncst_oui[2] = 0xac;\n\t}\n\tswitch (ndissecuritytype) {\n\tcase Ndis802_11Encryption1Enabled:\n\tcase Ndis802_11Encryption1KeyAbsent:\n\t\tuncst_oui[3] = 0x1;\n\t\tbreak;\n\tcase Ndis802_11Encryption2Enabled:\n\tcase Ndis802_11Encryption2KeyAbsent:\n\t\tuncst_oui[3] = 0x2;\n\t\tbreak;\n\tcase Ndis802_11Encryption3Enabled:\n\tcase Ndis802_11Encryption3KeyAbsent:\n\t\tuncst_oui[3] = 0x4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\tcnt = 12;\n\tmatch = false;\n\twhile (cnt < in_len) {\n\t\tif (in_ie[cnt] == authmode) {\n\t\t\tif ((authmode == _WPA_IE_ID_) &&\n\t\t\t    (!memcmp(&in_ie[cnt + 2], &wpa_oui[0], 4))) {\n\t\t\t\tmemcpy(&sec_ie[0], &in_ie[cnt],\n\t\t\t\t\tin_ie[cnt + 1] + 2);\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (authmode == _WPA2_IE_ID_) {\n\t\t\t\tmemcpy(&sec_ie[0], &in_ie[cnt],\n\t\t\t\t\tin_ie[cnt + 1] + 2);\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (((authmode == _WPA_IE_ID_) &&\n\t\t\t     (!memcmp(&in_ie[cnt + 2], &wpa_oui[0], 4))) ||\n\t\t\t     (authmode == _WPA2_IE_ID_))\n\t\t\t\tmemcpy(&bkup_ie[0], &in_ie[cnt],\n\t\t\t\t\tin_ie[cnt + 1] + 2);\n\t\t}\n\t\tcnt += in_ie[cnt + 1] + 2;  \n\t}\n\t \n\tif (match) {\n\t\tif (sec_ie[0] == _WPA_IE_ID_) {\n\t\t\t \n\t\t\twhile (true) {\n\t\t\t\t \n\t\t\t\tif (memcmp(&sec_ie[2], &wpa_oui[0], 4)) {\n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((sec_ie[6] != 0x01) || (sec_ie[7] != 0x0)) {\n\t\t\t\t\t \n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!memcmp(&sec_ie[8], &wpa_oui[0], 3)) {\n\t\t\t\t\t \n\t\t\t\t\tswitch (sec_ie[11]) {\n\t\t\t\t\tcase 0x0:  \n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_NO_PRIVACY_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x1:  \n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_WEP40_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x2:  \n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_TKIP_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x3:  \n\t\t\t\t\tcase 0x4:\n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_AES_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x5:  \n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_WEP104_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (sec_ie[12] == 0x01) {\n\t\t\t\t\t \n\t\t\t\t\tif (memcmp(&sec_ie[14],\n\t\t\t\t\t    &uncst_oui[0], 4)) {\n\t\t\t\t\t\tmatch = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}  \n\t\t\t\t} else {  \n\t\t\t\t\t \n\t\t\t\t\tcnt = sec_ie[12];\n\t\t\t\t\tremove_cnt = (cnt - 1) * 4;\n\t\t\t\t\tsec_ie[12] = 0x01;\n\t\t\t\t\tmemcpy(&sec_ie[14], &uncst_oui[0], 4);\n\t\t\t\t\t \n\t\t\t\t\tmemcpy(&sec_ie[18],\n\t\t\t\t\t\t&sec_ie[18 + remove_cnt],\n\t\t\t\t\t\tsec_ie[1] - 18 + 2 -\n\t\t\t\t\t\tremove_cnt);\n\t\t\t\t\tsec_ie[1] = sec_ie[1] - remove_cnt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (authmode == _WPA2_IE_ID_) {\n\t\t\t \n\t\t\twhile (true) {\n\t\t\t\tif ((sec_ie[2] != 0x01) || (sec_ie[3] != 0x0)) {\n\t\t\t\t\t \n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!memcmp(&sec_ie[4], &uncst_oui[0], 3)) {\n\t\t\t\t\t \n\t\t\t\t\tswitch (sec_ie[7]) {\n\t\t\t\t\tcase 0x1:  \n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_WEP40_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x2:  \n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_TKIP_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x4:  \n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_AES_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x5:  \n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_WEP104_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:  \n\t\t\t\t\t\tpsecuritypriv->XGrpPrivacy =\n\t\t\t\t\t\t\t\t_NO_PRIVACY_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (sec_ie[8] == 0x01) {\n\t\t\t\t\t \n\t\t\t\t\tif (memcmp(&sec_ie[10],\n\t\t\t\t\t\t     &uncst_oui[0], 4)) {\n\t\t\t\t\t\tmatch = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}  \n\t\t\t\t} else {  \n\t\t\t\t\t \n\t\t\t\t\tcnt = sec_ie[8];\n\t\t\t\t\tremove_cnt = (cnt - 1) * 4;\n\t\t\t\t\tsec_ie[8] = 0x01;\n\t\t\t\t\tmemcpy(&sec_ie[10], &uncst_oui[0], 4);\n\t\t\t\t\t \n\t\t\t\t\tmemcpy(&sec_ie[14],\n\t\t\t\t\t\t&sec_ie[14 + remove_cnt],\n\t\t\t\t\t\t(sec_ie[1] - 14 + 2 -\n\t\t\t\t\t\tremove_cnt));\n\t\t\t\t\tsec_ie[1] = sec_ie[1] - remove_cnt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif ((authmode == _WPA_IE_ID_) || (authmode == _WPA2_IE_ID_)) {\n\t\t \n\t\tmemcpy(out_ie, in_ie, 12);\n\t\tielength = 12;\n\t\t \n\t\tif (match) {\n\t\t\tmemcpy(&out_ie[ielength], &sec_ie[0], sec_ie[1] + 2);\n\t\t\tielength += sec_ie[1] + 2;\n\t\t\tif (authmode == _WPA2_IE_ID_) {\n\t\t\t\t \n\t\t\t\tout_ie[ielength - 1] = 0;\n\t\t\t\tout_ie[ielength - 2] = 0;\n\t\t\t}\n\t\t\tr8712_report_sec_ie(adapter, authmode, sec_ie);\n\t\t}\n\t} else {\n\t\t \n\t\tmemcpy(out_ie, in_ie, 12);\n\t\tielength = 12;\n\t\tif (psecuritypriv->wps_phase) {\n\t\t\tmemcpy(out_ie + ielength, psecuritypriv->wps_ie,\n\t\t\t       psecuritypriv->wps_ie_len);\n\t\t\tielength += psecuritypriv->wps_ie_len;\n\t\t}\n\t}\n\tiEntry = SecIsInPMKIDList(adapter, pmlmepriv->assoc_bssid);\n\tif (iEntry < 0)\n\t\treturn ielength;\n\tif (authmode == _WPA2_IE_ID_) {\n\t\tout_ie[ielength] = 1;\n\t\tielength++;\n\t\tout_ie[ielength] = 0;\t \n\t\tielength++;\n\t\tmemcpy(&out_ie[ielength],\n\t\t\t&psecuritypriv->PMKIDList[iEntry].PMKID, 16);\n\t\tielength += 16;\n\t\tout_ie[13] += 18; \n\t}\n\treturn ielength;\n}\n\nvoid r8712_init_registrypriv_dev_network(struct _adapter *adapter)\n{\n\tstruct registry_priv *pregistrypriv = &adapter->registrypriv;\n\tstruct eeprom_priv *peepriv = &adapter->eeprompriv;\n\tstruct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;\n\tu8 *myhwaddr = myid(peepriv);\n\n\tmemcpy(pdev_network->MacAddress, myhwaddr, ETH_ALEN);\n\tmemcpy(&pdev_network->Ssid, &pregistrypriv->ssid,\n\t\tsizeof(struct ndis_802_11_ssid));\n\tpdev_network->Configuration.Length =\n\t\t\t sizeof(struct NDIS_802_11_CONFIGURATION);\n\tpdev_network->Configuration.BeaconPeriod = 100;\n\tpdev_network->Configuration.FHConfig.Length = 0;\n\tpdev_network->Configuration.FHConfig.HopPattern = 0;\n\tpdev_network->Configuration.FHConfig.HopSet = 0;\n\tpdev_network->Configuration.FHConfig.DwellTime = 0;\n}\n\nvoid r8712_update_registrypriv_dev_network(struct _adapter *adapter)\n{\n\tint sz = 0;\n\tstruct registry_priv\t*pregistrypriv = &adapter->registrypriv;\n\tstruct wlan_bssid_ex\t*pdev_network = &pregistrypriv->dev_network;\n\tstruct security_priv\t*psecuritypriv = &adapter->securitypriv;\n\tstruct wlan_network\t*cur_network = &adapter->mlmepriv.cur_network;\n\n\tpdev_network->Privacy = cpu_to_le32(psecuritypriv->PrivacyAlgrthm\n\t\t\t\t\t    > 0 ? 1 : 0);  \n\tpdev_network->Rssi = 0;\n\tswitch (pregistrypriv->wireless_mode) {\n\tcase WIRELESS_11B:\n\t\tpdev_network->NetworkTypeInUse = Ndis802_11DS;\n\t\tbreak;\n\tcase WIRELESS_11G:\n\tcase WIRELESS_11BG:\n\t\tpdev_network->NetworkTypeInUse = Ndis802_11OFDM24;\n\t\tbreak;\n\tcase WIRELESS_11A:\n\t\tpdev_network->NetworkTypeInUse = Ndis802_11OFDM5;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\tpdev_network->Configuration.DSConfig = pregistrypriv->channel;\n\tif (cur_network->network.InfrastructureMode == Ndis802_11IBSS)\n\t\tpdev_network->Configuration.ATIMWindow = 3;\n\tpdev_network->InfrastructureMode = cur_network->network.InfrastructureMode;\n\t \n\tsz = r8712_generate_ie(pregistrypriv);\n\tpdev_network->IELength = sz;\n\tpdev_network->Length = r8712_get_wlan_bssid_ex_sz(pdev_network);\n}\n\n \nvoid r8712_joinbss_reset(struct _adapter *padapter)\n{\n\tint i;\n\tstruct mlme_priv\t*pmlmepriv = &padapter->mlmepriv;\n\tstruct ht_priv\t\t*phtpriv = &pmlmepriv->htpriv;\n\n\t \n\tphtpriv->ampdu_enable = false; \n\tfor (i = 0; i < 16; i++)\n\t\tphtpriv->baddbareq_issued[i] = false; \n\tif (phtpriv->ht_option) {\n\t\t \n\t\tr8712_write8(padapter, 0x102500D9, 48); \n\t} else {\n\t\t \n\t\t \n\t\tr8712_write8(padapter, 0x102500D9, 1);\n\t}\n}\n\n \nunsigned int r8712_restructure_ht_ie(struct _adapter *padapter, u8 *in_ie,\n\t\t\t\t     u8 *out_ie, uint in_len, uint *pout_len)\n{\n\tu32 ielen, out_len;\n\tunsigned char *p;\n\tstruct ieee80211_ht_cap ht_capie;\n\tunsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\n\tstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\n\n\tphtpriv->ht_option = 0;\n\tp = r8712_get_ie(in_ie + 12, WLAN_EID_HT_CAPABILITY, &ielen, in_len - 12);\n\tif (p && (ielen > 0)) {\n\t\tif (pqospriv->qos_option == 0) {\n\t\t\tout_len = *pout_len;\n\t\t\tr8712_set_ie(out_ie + out_len, WLAN_EID_VENDOR_SPECIFIC,\n\t\t\t\t     _WMM_IE_Length_, WMM_IE, pout_len);\n\t\t\tpqospriv->qos_option = 1;\n\t\t}\n\t\tout_len = *pout_len;\n\t\tmemset(&ht_capie, 0, sizeof(struct ieee80211_ht_cap));\n\t\tht_capie.cap_info = cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t\t\t    IEEE80211_HT_CAP_SGI_20 |\n\t\t\t\t    IEEE80211_HT_CAP_SGI_40 |\n\t\t\t\t    IEEE80211_HT_CAP_TX_STBC |\n\t\t\t\t    IEEE80211_HT_CAP_MAX_AMSDU |\n\t\t\t\t    IEEE80211_HT_CAP_DSSSCCK40);\n\t\tht_capie.ampdu_params_info = (IEEE80211_HT_AMPDU_PARM_FACTOR &\n\t\t\t\t0x03) | (IEEE80211_HT_AMPDU_PARM_DENSITY & 0x00);\n\t\tr8712_set_ie(out_ie + out_len, WLAN_EID_HT_CAPABILITY,\n\t\t\t     sizeof(struct ieee80211_ht_cap),\n\t\t\t     (unsigned char *)&ht_capie, pout_len);\n\t\tphtpriv->ht_option = 1;\n\t}\n\treturn phtpriv->ht_option;\n}\n\n \nstatic void update_ht_cap(struct _adapter *padapter, u8 *pie, uint ie_len)\n{\n\tu8 *p, max_ampdu_sz;\n\tint i;\n\tuint len;\n\tstruct sta_info *bmc_sta, *psta;\n\tstruct ieee80211_ht_cap *pht_capie;\n\tstruct recv_reorder_ctrl *preorder_ctrl;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\tstruct wlan_network *pcur_network = &(pmlmepriv->cur_network);\n\n\tif (!phtpriv->ht_option)\n\t\treturn;\n\t \n\tif (!phtpriv->ampdu_enable &&\n\t    (pregistrypriv->ampdu_enable == 1))\n\t\tphtpriv->ampdu_enable = true;\n\t \n\tlen = 0;\n\tp = r8712_get_ie(pie + sizeof(struct NDIS_802_11_FIXED_IEs),\n\t\t\t\tWLAN_EID_HT_CAPABILITY,\n\t\t\t\t&len, ie_len -\n\t\t\t\tsizeof(struct NDIS_802_11_FIXED_IEs));\n\tif (p && len > 0) {\n\t\tpht_capie = (struct ieee80211_ht_cap *)(p + 2);\n\t\tmax_ampdu_sz = (pht_capie->ampdu_params_info &\n\t\t\t\tIEEE80211_HT_AMPDU_PARM_FACTOR);\n\t\t \n\t\tmax_ampdu_sz = 1 << (max_ampdu_sz + 3);\n\t\tphtpriv->rx_ampdu_maxlen = max_ampdu_sz;\n\t}\n\t \n\tbmc_sta = r8712_get_bcmc_stainfo(padapter);\n\tif (bmc_sta) {\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tpreorder_ctrl = &bmc_sta->recvreorder_ctrl[i];\n\t\t\tpreorder_ctrl->indicate_seq = 0xffff;\n\t\t\tpreorder_ctrl->wend_b = 0xffff;\n\t\t}\n\t}\n\tpsta = r8712_get_stainfo(&padapter->stapriv,\n\t\t\t\t pcur_network->network.MacAddress);\n\tif (psta) {\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tpreorder_ctrl = &psta->recvreorder_ctrl[i];\n\t\t\tpreorder_ctrl->indicate_seq = 0xffff;\n\t\t\tpreorder_ctrl->wend_b = 0xffff;\n\t\t}\n\t}\n\tlen = 0;\n\tp = r8712_get_ie(pie + sizeof(struct NDIS_802_11_FIXED_IEs),\n\t\t   WLAN_EID_HT_OPERATION, &len,\n\t\t   ie_len - sizeof(struct NDIS_802_11_FIXED_IEs));\n}\n\nvoid r8712_issue_addbareq_cmd(struct _adapter *padapter, int priority)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct ht_priv\t *phtpriv = &pmlmepriv->htpriv;\n\n\tif ((phtpriv->ht_option == 1) && (phtpriv->ampdu_enable)) {\n\t\tif (!phtpriv->baddbareq_issued[priority]) {\n\t\t\tr8712_addbareq_cmd(padapter, (u8)priority);\n\t\t\tphtpriv->baddbareq_issued[priority] = true;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}