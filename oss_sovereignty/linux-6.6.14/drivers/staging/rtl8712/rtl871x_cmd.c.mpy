{
  "module_name": "rtl871x_cmd.c",
  "hash_id": "0b9b713fb7b57483cb36ce5ec6a6768e86336d400c6095a664f87c84abee56e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/rtl871x_cmd.c",
  "human_readable_source": "\n \n\n#define _RTL871X_CMD_C_\n\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kref.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/circ_buf.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/atomic.h>\n#include <linux/semaphore.h>\n#include <linux/rtnetlink.h>\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"recv_osdep.h\"\n#include \"mlme_osdep.h\"\n\n \n\nint r8712_init_cmd_priv(struct cmd_priv *pcmdpriv)\n{\n\tinit_completion(&pcmdpriv->cmd_queue_comp);\n\tinit_completion(&pcmdpriv->terminate_cmdthread_comp);\n\n\t_init_queue(&(pcmdpriv->cmd_queue));\n\n\t \n\tpcmdpriv->cmd_seq = 1;\n\tpcmdpriv->cmd_allocated_buf = kmalloc(MAX_CMDSZ + CMDBUFF_ALIGN_SZ,\n\t\t\t\t\t      GFP_ATOMIC);\n\tif (!pcmdpriv->cmd_allocated_buf)\n\t\treturn -ENOMEM;\n\tpcmdpriv->cmd_buf = pcmdpriv->cmd_allocated_buf  +  CMDBUFF_ALIGN_SZ -\n\t\t\t    ((addr_t)(pcmdpriv->cmd_allocated_buf) &\n\t\t\t    (CMDBUFF_ALIGN_SZ - 1));\n\tpcmdpriv->rsp_allocated_buf = kmalloc(MAX_RSPSZ + 4, GFP_ATOMIC);\n\tif (!pcmdpriv->rsp_allocated_buf) {\n\t\tkfree(pcmdpriv->cmd_allocated_buf);\n\t\tpcmdpriv->cmd_allocated_buf = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tpcmdpriv->rsp_buf = pcmdpriv->rsp_allocated_buf  +  4 -\n\t\t\t    ((addr_t)(pcmdpriv->rsp_allocated_buf) & 3);\n\tpcmdpriv->cmd_issued_cnt = 0;\n\tpcmdpriv->cmd_done_cnt = 0;\n\tpcmdpriv->rsp_cnt = 0;\n\treturn 0;\n}\n\nint r8712_init_evt_priv(struct evt_priv *pevtpriv)\n{\n\t \n\tpevtpriv->event_seq = 0;\n\tpevtpriv->evt_allocated_buf = kmalloc(MAX_EVTSZ + 4, GFP_ATOMIC);\n\n\tif (!pevtpriv->evt_allocated_buf)\n\t\treturn -ENOMEM;\n\tpevtpriv->evt_buf = pevtpriv->evt_allocated_buf  +  4 -\n\t\t\t    ((addr_t)(pevtpriv->evt_allocated_buf) & 3);\n\tpevtpriv->evt_done_cnt = 0;\n\treturn 0;\n}\n\nvoid r8712_free_evt_priv(struct evt_priv *pevtpriv)\n{\n\tkfree(pevtpriv->evt_allocated_buf);\n}\n\nvoid r8712_free_cmd_priv(struct cmd_priv *pcmdpriv)\n{\n\tif (pcmdpriv) {\n\t\tkfree(pcmdpriv->cmd_allocated_buf);\n\t\tkfree(pcmdpriv->rsp_allocated_buf);\n\t}\n}\n\n \n\nvoid r8712_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj)\n{\n\tstruct __queue *queue;\n\tunsigned long irqL;\n\n\tif (pcmdpriv->padapter->eeprompriv.bautoload_fail_flag)\n\t\treturn;\n\tif (!obj)\n\t\treturn;\n\tqueue = &pcmdpriv->cmd_queue;\n\tspin_lock_irqsave(&queue->lock, irqL);\n\tlist_add_tail(&obj->list, &queue->queue);\n\tspin_unlock_irqrestore(&queue->lock, irqL);\n\tcomplete(&pcmdpriv->cmd_queue_comp);\n}\n\nstruct cmd_obj *r8712_dequeue_cmd(struct  __queue *queue)\n{\n\tunsigned long irqL;\n\tstruct cmd_obj *obj;\n\n\tspin_lock_irqsave(&queue->lock, irqL);\n\tobj = list_first_entry_or_null(&queue->queue,\n\t\t\t\t       struct cmd_obj, list);\n\tif (obj)\n\t\tlist_del_init(&obj->list);\n\tspin_unlock_irqrestore(&queue->lock, irqL);\n\treturn obj;\n}\n\nvoid r8712_enqueue_cmd_ex(struct cmd_priv *pcmdpriv, struct cmd_obj *obj)\n{\n\tunsigned long irqL;\n\tstruct  __queue *queue;\n\n\tif (!obj)\n\t\treturn;\n\tif (pcmdpriv->padapter->eeprompriv.bautoload_fail_flag)\n\t\treturn;\n\tqueue = &pcmdpriv->cmd_queue;\n\tspin_lock_irqsave(&queue->lock, irqL);\n\tlist_add_tail(&obj->list, &queue->queue);\n\tspin_unlock_irqrestore(&queue->lock, irqL);\n\tcomplete(&pcmdpriv->cmd_queue_comp);\n}\n\nvoid r8712_free_cmd_obj(struct cmd_obj *pcmd)\n{\n\tif ((pcmd->cmdcode != _JoinBss_CMD_) &&\n\t    (pcmd->cmdcode != _CreateBss_CMD_))\n\t\tkfree(pcmd->parmbuf);\n\tif (pcmd->rsp) {\n\t\tif (pcmd->rspsz != 0)\n\t\t\tkfree(pcmd->rsp);\n\t}\n\tkfree(pcmd);\n}\n\nu8 r8712_sitesurvey_cmd(struct _adapter *padapter,\n\t\t\tstruct ndis_802_11_ssid *pssid)\n\t__must_hold(&padapter->mlmepriv.lock)\n{\n\tstruct cmd_obj\t*ph2c;\n\tstruct sitesurvey_parm\t*psurveyPara;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tph2c = kmalloc(sizeof(*ph2c), GFP_ATOMIC);\n\tif (!ph2c)\n\t\treturn _FAIL;\n\tpsurveyPara = kmalloc(sizeof(*psurveyPara), GFP_ATOMIC);\n\tif (!psurveyPara) {\n\t\tkfree(ph2c);\n\t\treturn _FAIL;\n\t}\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara,\n\t\t\t\t   GEN_CMD_CODE(_SiteSurvey));\n\tpsurveyPara->bsslimit = cpu_to_le32(48);\n\tpsurveyPara->passive_mode = cpu_to_le32(pmlmepriv->passive_mode);\n\tpsurveyPara->ss_ssidlen = 0;\n\tmemset(psurveyPara->ss_ssid, 0, IW_ESSID_MAX_SIZE + 1);\n\tif (pssid && pssid->SsidLength) {\n\t\tint len = min_t(int, pssid->SsidLength, IW_ESSID_MAX_SIZE);\n\n\t\tmemcpy(psurveyPara->ss_ssid, pssid->Ssid, len);\n\t\tpsurveyPara->ss_ssidlen = cpu_to_le32(len);\n\t}\n\tset_fwstate(pmlmepriv, _FW_UNDER_SURVEY);\n\tr8712_enqueue_cmd(pcmdpriv, ph2c);\n\tmod_timer(&pmlmepriv->scan_to_timer,\n\t\t  jiffies + msecs_to_jiffies(SCANNING_TIMEOUT));\n\tpadapter->ledpriv.LedControlHandler(padapter, LED_CTL_SITE_SURVEY);\n\tcomplete(&padapter->rx_filter_ready);\n\treturn _SUCCESS;\n}\n\nint r8712_setdatarate_cmd(struct _adapter *padapter, u8 *rateset)\n{\n\tstruct cmd_obj\t\t*ph2c;\n\tstruct setdatarate_parm\t*pbsetdataratepara;\n\tstruct cmd_priv\t\t*pcmdpriv = &padapter->cmdpriv;\n\n\tph2c = kmalloc(sizeof(*ph2c), GFP_ATOMIC);\n\tif (!ph2c)\n\t\treturn -ENOMEM;\n\tpbsetdataratepara = kmalloc(sizeof(*pbsetdataratepara), GFP_ATOMIC);\n\tif (!pbsetdataratepara) {\n\t\tkfree(ph2c);\n\t\treturn -ENOMEM;\n\t}\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, pbsetdataratepara,\n\t\t\t\t   GEN_CMD_CODE(_SetDataRate));\n\tpbsetdataratepara->mac_id = 5;\n\tmemcpy(pbsetdataratepara->datarates, rateset, NumRates);\n\tr8712_enqueue_cmd(pcmdpriv, ph2c);\n\treturn 0;\n}\n\nvoid r8712_set_chplan_cmd(struct _adapter *padapter, int chplan)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct SetChannelPlan_param *psetchplanpara;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\n\tph2c = kmalloc(sizeof(*ph2c), GFP_ATOMIC);\n\tif (!ph2c)\n\t\treturn;\n\tpsetchplanpara = kmalloc(sizeof(*psetchplanpara), GFP_ATOMIC);\n\tif (!psetchplanpara) {\n\t\tkfree(ph2c);\n\t\treturn;\n\t}\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, psetchplanpara,\n\t\t\t\tGEN_CMD_CODE(_SetChannelPlan));\n\tpsetchplanpara->ChannelPlan = chplan;\n\tr8712_enqueue_cmd(pcmdpriv, ph2c);\n}\n\nint r8712_setrfreg_cmd(struct _adapter  *padapter, u8 offset, u32 val)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct writeRF_parm *pwriterfparm;\n\tstruct cmd_priv\t*pcmdpriv = &padapter->cmdpriv;\n\n\tph2c = kmalloc(sizeof(*ph2c), GFP_ATOMIC);\n\tif (!ph2c)\n\t\treturn -ENOMEM;\n\tpwriterfparm = kmalloc(sizeof(*pwriterfparm), GFP_ATOMIC);\n\tif (!pwriterfparm) {\n\t\tkfree(ph2c);\n\t\treturn -ENOMEM;\n\t}\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, pwriterfparm, GEN_CMD_CODE(_SetRFReg));\n\tpwriterfparm->offset = offset;\n\tpwriterfparm->value = val;\n\tr8712_enqueue_cmd(pcmdpriv, ph2c);\n\treturn 0;\n}\n\nint r8712_getrfreg_cmd(struct _adapter *padapter, u8 offset, u8 *pval)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct readRF_parm *prdrfparm;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\n\tph2c = kmalloc(sizeof(*ph2c), GFP_ATOMIC);\n\tif (!ph2c)\n\t\treturn -ENOMEM;\n\tprdrfparm = kmalloc(sizeof(*prdrfparm), GFP_ATOMIC);\n\tif (!prdrfparm) {\n\t\tkfree(ph2c);\n\t\treturn -ENOMEM;\n\t}\n\tINIT_LIST_HEAD(&ph2c->list);\n\tph2c->cmdcode = GEN_CMD_CODE(_GetRFReg);\n\tph2c->parmbuf = (unsigned char *)prdrfparm;\n\tph2c->cmdsz =  sizeof(struct readRF_parm);\n\tph2c->rsp = pval;\n\tph2c->rspsz = sizeof(struct readRF_rsp);\n\tprdrfparm->offset = offset;\n\tr8712_enqueue_cmd(pcmdpriv, ph2c);\n\treturn 0;\n}\n\nvoid r8712_getbbrfreg_cmdrsp_callback(struct _adapter *padapter,\n\t\t\t\t      struct cmd_obj *pcmd)\n{\n\tkfree(pcmd->parmbuf);\n\tkfree(pcmd);\n\tpadapter->mppriv.workparam.bcompleted = true;\n}\n\nvoid r8712_readtssi_cmdrsp_callback(struct _adapter *padapter,\n\t\t\t\tstruct cmd_obj *pcmd)\n{\n\tkfree(pcmd->parmbuf);\n\tkfree(pcmd);\n\n\tpadapter->mppriv.workparam.bcompleted = true;\n}\n\nint r8712_createbss_cmd(struct _adapter *padapter)\n{\n\tstruct cmd_obj *pcmd;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tstruct wlan_bssid_ex *pdev_network =\n\t\t\t\t &padapter->registrypriv.dev_network;\n\n\tpadapter->ledpriv.LedControlHandler(padapter, LED_CTL_START_TO_LINK);\n\tpcmd = kmalloc(sizeof(*pcmd), GFP_ATOMIC);\n\tif (!pcmd)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&pcmd->list);\n\tpcmd->cmdcode = _CreateBss_CMD_;\n\tpcmd->parmbuf = (unsigned char *)pdev_network;\n\tpcmd->cmdsz = r8712_get_wlan_bssid_ex_sz(pdev_network);\n\tpcmd->rsp = NULL;\n\tpcmd->rspsz = 0;\n\t \n\tpdev_network->Length = pcmd->cmdsz;\n\tpdev_network->IELength = pdev_network->IELength;\n\tpdev_network->Ssid.SsidLength =\tpdev_network->Ssid.SsidLength;\n\tr8712_enqueue_cmd(pcmdpriv, pcmd);\n\treturn 0;\n}\n\nint r8712_joinbss_cmd(struct _adapter  *padapter, struct wlan_network *pnetwork)\n{\n\tstruct wlan_bssid_ex *psecnetwork;\n\tstruct cmd_obj\t\t*pcmd;\n\tstruct cmd_priv\t\t*pcmdpriv = &padapter->cmdpriv;\n\tstruct mlme_priv\t*pmlmepriv = &padapter->mlmepriv;\n\tstruct qos_priv\t\t*pqospriv = &pmlmepriv->qospriv;\n\tstruct security_priv\t*psecuritypriv = &padapter->securitypriv;\n\tstruct registry_priv\t*pregistrypriv = &padapter->registrypriv;\n\tenum NDIS_802_11_NETWORK_INFRASTRUCTURE ndis_network_mode =\n\t\tpnetwork->network.InfrastructureMode;\n\n\tpadapter->ledpriv.LedControlHandler(padapter, LED_CTL_START_TO_LINK);\n\tpcmd = kmalloc(sizeof(*pcmd), GFP_ATOMIC);\n\tif (!pcmd)\n\t\treturn -ENOMEM;\n\n\t \n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE) !=\n\t    true) {\n\t\tswitch (ndis_network_mode) {\n\t\tcase Ndis802_11IBSS:\n\t\t\tpmlmepriv->fw_state |= WIFI_ADHOC_STATE;\n\t\t\tbreak;\n\t\tcase Ndis802_11Infrastructure:\n\t\t\tpmlmepriv->fw_state |= WIFI_STATION_STATE;\n\t\t\tbreak;\n\t\tcase Ndis802_11APMode:\n\t\tcase Ndis802_11AutoUnknown:\n\t\tcase Ndis802_11InfrastructureMax:\n\t\t\tbreak;\n\t\t}\n\t}\n\tpsecnetwork = &psecuritypriv->sec_bss;\n\tmemcpy(psecnetwork, &pnetwork->network, sizeof(*psecnetwork));\n\tpsecuritypriv->authenticator_ie[0] = (unsigned char)\n\t\t\t\t\t     psecnetwork->IELength;\n\tif ((psecnetwork->IELength - 12) < (256 - 1))\n\t\tmemcpy(&psecuritypriv->authenticator_ie[1],\n\t\t\t&psecnetwork->IEs[12], psecnetwork->IELength - 12);\n\telse\n\t\tmemcpy(&psecuritypriv->authenticator_ie[1],\n\t\t\t&psecnetwork->IEs[12], (256 - 1));\n\tpsecnetwork->IELength = 0;\n\t \n\tif (!pmlmepriv->assoc_by_bssid)\n\t\tether_addr_copy(&pmlmepriv->assoc_bssid[0],\n\t\t\t\t&pnetwork->network.MacAddress[0]);\n\tpsecnetwork->IELength = r8712_restruct_sec_ie(padapter,\n\t\t\t\t\t\t&pnetwork->network.IEs[0],\n\t\t\t\t\t\t&psecnetwork->IEs[0],\n\t\t\t\t\t\tpnetwork->network.IELength);\n\tpqospriv->qos_option = 0;\n\tif (pregistrypriv->wmm_enable) {\n\t\tu32 tmp_len;\n\n\t\ttmp_len = r8712_restruct_wmm_ie(padapter,\n\t\t\t\t\t  &pnetwork->network.IEs[0],\n\t\t\t\t\t  &psecnetwork->IEs[0],\n\t\t\t\t\t  pnetwork->network.IELength,\n\t\t\t\t\t  psecnetwork->IELength);\n\t\tif (psecnetwork->IELength != tmp_len) {\n\t\t\tpsecnetwork->IELength = tmp_len;\n\t\t\tpqospriv->qos_option = 1;  \n\t\t} else {\n\t\t\tpqospriv->qos_option = 0;  \n\t\t}\n\t}\n\tif (pregistrypriv->ht_enable) {\n\t\t \n\t\tif ((padapter->securitypriv.PrivacyAlgrthm != _WEP40_) &&\n\t\t    (padapter->securitypriv.PrivacyAlgrthm != _WEP104_)) {\n\t\t\t \n\t\t\tr8712_restructure_ht_ie(padapter,\n\t\t\t\t\t\t&pnetwork->network.IEs[0],\n\t\t\t\t\t\t&psecnetwork->IEs[0],\n\t\t\t\t\t\tpnetwork->network.IELength,\n\t\t\t\t\t\t&psecnetwork->IELength);\n\t\t}\n\t}\n\tpsecuritypriv->supplicant_ie[0] = (u8)psecnetwork->IELength;\n\tif (psecnetwork->IELength < 255)\n\t\tmemcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0],\n\t\t\tpsecnetwork->IELength);\n\telse\n\t\tmemcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0],\n\t\t\t255);\n\t \n\tpcmd->cmdsz = r8712_get_wlan_bssid_ex_sz(psecnetwork);\n#ifdef __BIG_ENDIAN\n\t \n\tpsecnetwork->Length = cpu_to_le32(psecnetwork->Length);\n\tpsecnetwork->Ssid.SsidLength = cpu_to_le32(\n\t\t\t\t       psecnetwork->Ssid.SsidLength);\n\tpsecnetwork->Privacy = cpu_to_le32(psecnetwork->Privacy);\n\tpsecnetwork->Rssi = cpu_to_le32(psecnetwork->Rssi);\n\tpsecnetwork->NetworkTypeInUse = cpu_to_le32(\n\t\t\t\t\tpsecnetwork->NetworkTypeInUse);\n\tpsecnetwork->Configuration.ATIMWindow = cpu_to_le32(\n\t\t\t\tpsecnetwork->Configuration.ATIMWindow);\n\tpsecnetwork->Configuration.BeaconPeriod = cpu_to_le32(\n\t\t\t\t psecnetwork->Configuration.BeaconPeriod);\n\tpsecnetwork->Configuration.DSConfig = cpu_to_le32(\n\t\t\t\tpsecnetwork->Configuration.DSConfig);\n\tpsecnetwork->Configuration.FHConfig.DwellTime = cpu_to_le32(\n\t\t\t\tpsecnetwork->Configuration.FHConfig.DwellTime);\n\tpsecnetwork->Configuration.FHConfig.HopPattern = cpu_to_le32(\n\t\t\t\tpsecnetwork->Configuration.FHConfig.HopPattern);\n\tpsecnetwork->Configuration.FHConfig.HopSet = cpu_to_le32(\n\t\t\t\tpsecnetwork->Configuration.FHConfig.HopSet);\n\tpsecnetwork->Configuration.FHConfig.Length = cpu_to_le32(\n\t\t\t\tpsecnetwork->Configuration.FHConfig.Length);\n\tpsecnetwork->Configuration.Length = cpu_to_le32(\n\t\t\t\tpsecnetwork->Configuration.Length);\n\tpsecnetwork->InfrastructureMode = cpu_to_le32(\n\t\t\t\tpsecnetwork->InfrastructureMode);\n\tpsecnetwork->IELength = cpu_to_le32(psecnetwork->IELength);\n#endif\n\tINIT_LIST_HEAD(&pcmd->list);\n\tpcmd->cmdcode = _JoinBss_CMD_;\n\tpcmd->parmbuf = (unsigned char *)psecnetwork;\n\tpcmd->rsp = NULL;\n\tpcmd->rspsz = 0;\n\tr8712_enqueue_cmd(pcmdpriv, pcmd);\n\treturn 0;\n}\n\nvoid r8712_disassoc_cmd(struct _adapter *padapter)  \n{\n\tstruct cmd_obj *pdisconnect_cmd;\n\tstruct disconnect_parm *pdisconnect;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\n\tpdisconnect_cmd = kmalloc(sizeof(*pdisconnect_cmd), GFP_ATOMIC);\n\tif (!pdisconnect_cmd)\n\t\treturn;\n\tpdisconnect = kmalloc(sizeof(*pdisconnect), GFP_ATOMIC);\n\tif (!pdisconnect) {\n\t\tkfree(pdisconnect_cmd);\n\t\treturn;\n\t}\n\tinit_h2fwcmd_w_parm_no_rsp(pdisconnect_cmd, pdisconnect,\n\t\t\t\t   _DisConnect_CMD_);\n\tr8712_enqueue_cmd(pcmdpriv, pdisconnect_cmd);\n}\n\nvoid r8712_setopmode_cmd(struct _adapter *padapter,\n\t\t enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct setopmode_parm *psetop;\n\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\n\tph2c = kmalloc(sizeof(*ph2c), GFP_ATOMIC);\n\tif (!ph2c)\n\t\treturn;\n\tpsetop = kmalloc(sizeof(*psetop), GFP_ATOMIC);\n\tif (!psetop) {\n\t\tkfree(ph2c);\n\t\treturn;\n\t}\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, psetop, _SetOpMode_CMD_);\n\tpsetop->mode = (u8)networktype;\n\tr8712_enqueue_cmd(pcmdpriv, ph2c);\n}\n\nvoid r8712_setstakey_cmd(struct _adapter *padapter, u8 *psta, u8 unicast_key)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct set_stakey_parm *psetstakey_para;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tstruct set_stakey_rsp *psetstakey_rsp = NULL;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tstruct sta_info *sta = (struct sta_info *)psta;\n\n\tph2c = kmalloc(sizeof(*ph2c), GFP_ATOMIC);\n\tif (!ph2c)\n\t\treturn;\n\tpsetstakey_para = kmalloc(sizeof(*psetstakey_para), GFP_ATOMIC);\n\tif (!psetstakey_para) {\n\t\tkfree(ph2c);\n\t\treturn;\n\t}\n\tpsetstakey_rsp = kmalloc(sizeof(*psetstakey_rsp), GFP_ATOMIC);\n\tif (!psetstakey_rsp) {\n\t\tkfree(ph2c);\n\t\tkfree(psetstakey_para);\n\t\treturn;\n\t}\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);\n\tph2c->rsp = (u8 *)psetstakey_rsp;\n\tph2c->rspsz = sizeof(struct set_stakey_rsp);\n\tether_addr_copy(psetstakey_para->addr, sta->hwaddr);\n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE))\n\t\tpsetstakey_para->algorithm = (unsigned char)\n\t\t\t\t\t    psecuritypriv->PrivacyAlgrthm;\n\telse\n\t\tGET_ENCRY_ALGO(psecuritypriv, sta,\n\t\t\t       psetstakey_para->algorithm, false);\n\tif (unicast_key)\n\t\tmemcpy(&psetstakey_para->key, &sta->x_UncstKey, 16);\n\telse\n\t\tmemcpy(&psetstakey_para->key,\n\t\t\t&psecuritypriv->XGrpKey[\n\t\t\tpsecuritypriv->XGrpKeyid - 1]. skey, 16);\n\tr8712_enqueue_cmd(pcmdpriv, ph2c);\n}\n\nvoid r8712_setMacAddr_cmd(struct _adapter *padapter, const u8 *mac_addr)\n{\n\tstruct cmd_priv\t*pcmdpriv = &padapter->cmdpriv;\n\tstruct cmd_obj *ph2c;\n\tstruct SetMacAddr_param\t*psetMacAddr_para;\n\n\tph2c = kmalloc(sizeof(*ph2c), GFP_ATOMIC);\n\tif (!ph2c)\n\t\treturn;\n\tpsetMacAddr_para = kmalloc(sizeof(*psetMacAddr_para), GFP_ATOMIC);\n\tif (!psetMacAddr_para) {\n\t\tkfree(ph2c);\n\t\treturn;\n\t}\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, psetMacAddr_para,\n\t\t\t\t   _SetMacAddress_CMD_);\n\tether_addr_copy(psetMacAddr_para->MacAddr, mac_addr);\n\tr8712_enqueue_cmd(pcmdpriv, ph2c);\n}\n\nvoid r8712_addbareq_cmd(struct _adapter *padapter, u8 tid)\n{\n\tstruct cmd_priv\t\t*pcmdpriv = &padapter->cmdpriv;\n\tstruct cmd_obj\t\t*ph2c;\n\tstruct addBaReq_parm\t*paddbareq_parm;\n\n\tph2c = kmalloc(sizeof(*ph2c), GFP_ATOMIC);\n\tif (!ph2c)\n\t\treturn;\n\tpaddbareq_parm = kmalloc(sizeof(*paddbareq_parm), GFP_ATOMIC);\n\tif (!paddbareq_parm) {\n\t\tkfree(ph2c);\n\t\treturn;\n\t}\n\tpaddbareq_parm->tid = tid;\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, paddbareq_parm,\n\t\t\t\t   GEN_CMD_CODE(_AddBAReq));\n\tr8712_enqueue_cmd_ex(pcmdpriv, ph2c);\n}\n\nvoid r8712_wdg_wk_cmd(struct _adapter *padapter)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct drvint_cmd_parm  *pdrvintcmd_param;\n\tstruct cmd_priv\t*pcmdpriv = &padapter->cmdpriv;\n\n\tph2c = kmalloc(sizeof(*ph2c), GFP_ATOMIC);\n\tif (!ph2c)\n\t\treturn;\n\tpdrvintcmd_param = kmalloc(sizeof(*pdrvintcmd_param), GFP_ATOMIC);\n\tif (!pdrvintcmd_param) {\n\t\tkfree(ph2c);\n\t\treturn;\n\t}\n\tpdrvintcmd_param->i_cid = WDG_WK_CID;\n\tpdrvintcmd_param->sz = 0;\n\tpdrvintcmd_param->pbuf = NULL;\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvintcmd_param, _DRV_INT_CMD_);\n\tr8712_enqueue_cmd_ex(pcmdpriv, ph2c);\n}\n\nvoid r8712_survey_cmd_callback(struct _adapter *padapter, struct cmd_obj *pcmd)\n{\n\tstruct\tmlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (pcmd->res != H2C_SUCCESS)\n\t\tclr_fwstate(pmlmepriv, _FW_UNDER_SURVEY);\n\tr8712_free_cmd_obj(pcmd);\n}\n\nvoid r8712_disassoc_cmd_callback(struct _adapter *padapter,\n\t\t\t\t struct cmd_obj *pcmd)\n{\n\tunsigned long irqL;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (pcmd->res != H2C_SUCCESS) {\n\t\tspin_lock_irqsave(&pmlmepriv->lock, irqL);\n\t\tset_fwstate(pmlmepriv, _FW_LINKED);\n\t\tspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\n\t\treturn;\n\t}\n\tr8712_free_cmd_obj(pcmd);\n}\n\nvoid r8712_joinbss_cmd_callback(struct _adapter *padapter, struct cmd_obj *pcmd)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (pcmd->res != H2C_SUCCESS)\n\t\tmod_timer(&pmlmepriv->assoc_timer,\n\t\t\t  jiffies + msecs_to_jiffies(1));\n\tr8712_free_cmd_obj(pcmd);\n}\n\nvoid r8712_createbss_cmd_callback(struct _adapter *padapter,\n\t\t\t\t  struct cmd_obj *pcmd)\n{\n\tunsigned long irqL;\n\tstruct sta_info *psta = NULL;\n\tstruct wlan_network *pwlan = NULL;\n\tstruct\tmlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct wlan_bssid_ex *pnetwork = (struct wlan_bssid_ex *)pcmd->parmbuf;\n\tstruct wlan_network *tgt_network = &(pmlmepriv->cur_network);\n\n\tif (pcmd->res != H2C_SUCCESS)\n\t\tmod_timer(&pmlmepriv->assoc_timer,\n\t\t\t  jiffies + msecs_to_jiffies(1));\n\tdel_timer(&pmlmepriv->assoc_timer);\n#ifdef __BIG_ENDIAN\n\t \n\tpnetwork->Length = le32_to_cpu(pnetwork->Length);\n\tpnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);\n\tpnetwork->Privacy = le32_to_cpu(pnetwork->Privacy);\n\tpnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);\n\tpnetwork->NetworkTypeInUse = le32_to_cpu(pnetwork->NetworkTypeInUse);\n\tpnetwork->Configuration.ATIMWindow =\n\t\tle32_to_cpu(pnetwork->Configuration.ATIMWindow);\n\tpnetwork->Configuration.DSConfig =\n\t\tle32_to_cpu(pnetwork->Configuration.DSConfig);\n\tpnetwork->Configuration.FHConfig.DwellTime =\n\t\tle32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);\n\tpnetwork->Configuration.FHConfig.HopPattern =\n\t\tle32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);\n\tpnetwork->Configuration.FHConfig.HopSet =\n\t\tle32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);\n\tpnetwork->Configuration.FHConfig.Length =\n\t\tle32_to_cpu(pnetwork->Configuration.FHConfig.Length);\n\tpnetwork->Configuration.Length =\n\t\tle32_to_cpu(pnetwork->Configuration.Length);\n\tpnetwork->InfrastructureMode =\n\t\tle32_to_cpu(pnetwork->InfrastructureMode);\n\tpnetwork->IELength = le32_to_cpu(pnetwork->IELength);\n#endif\n\tspin_lock_irqsave(&pmlmepriv->lock, irqL);\n\tif ((pmlmepriv->fw_state) & WIFI_AP_STATE) {\n\t\tpsta = r8712_get_stainfo(&padapter->stapriv,\n\t\t\t\t\t pnetwork->MacAddress);\n\t\tif (!psta) {\n\t\t\tpsta = r8712_alloc_stainfo(&padapter->stapriv,\n\t\t\t\t\t\t   pnetwork->MacAddress);\n\t\t\tif (!psta)\n\t\t\t\tgoto createbss_cmd_fail;\n\t\t}\n\t\tr8712_indicate_connect(padapter);\n\t} else {\n\t\tpwlan = _r8712_alloc_network(pmlmepriv);\n\t\tif (!pwlan) {\n\t\t\tpwlan = r8712_get_oldest_wlan_network(\n\t\t\t\t&pmlmepriv->scanned_queue);\n\t\t\tif (!pwlan)\n\t\t\t\tgoto createbss_cmd_fail;\n\t\t\tpwlan->last_scanned = jiffies;\n\t\t} else {\n\t\t\tlist_add_tail(&(pwlan->list),\n\t\t\t\t\t &pmlmepriv->scanned_queue.queue);\n\t\t}\n\t\tpnetwork->Length = r8712_get_wlan_bssid_ex_sz(pnetwork);\n\t\tmemcpy(&(pwlan->network), pnetwork, pnetwork->Length);\n\t\tpwlan->fixed = true;\n\t\tmemcpy(&tgt_network->network, pnetwork,\n\t\t\t(r8712_get_wlan_bssid_ex_sz(pnetwork)));\n\t\tif (pmlmepriv->fw_state & _FW_UNDER_LINKING)\n\t\t\tpmlmepriv->fw_state ^= _FW_UNDER_LINKING;\n\t\t \n\t}\ncreatebss_cmd_fail:\n\tspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\n\tr8712_free_cmd_obj(pcmd);\n}\n\nvoid r8712_setstaKey_cmdrsp_callback(struct _adapter *padapter,\n\t\t\t\t     struct cmd_obj *pcmd)\n{\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct set_stakey_rsp *psetstakey_rsp = (struct set_stakey_rsp *)\n\t\t\t\t\t\t(pcmd->rsp);\n\tstruct sta_info *psta = r8712_get_stainfo(pstapriv,\n\t\t\t\t\t\t  psetstakey_rsp->addr);\n\n\tif (!psta)\n\t\tgoto exit;\n\tpsta->aid = psta->mac_id = psetstakey_rsp->keyid;  \nexit:\n\tr8712_free_cmd_obj(pcmd);\n}\n\nvoid r8712_setassocsta_cmdrsp_callback(struct _adapter *padapter,\n\t\t\t\t       struct cmd_obj *pcmd)\n{\n\tunsigned long\tirqL;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct set_assocsta_parm *passocsta_parm =\n\t\t\t\t(struct set_assocsta_parm *)(pcmd->parmbuf);\n\tstruct set_assocsta_rsp *passocsta_rsp =\n\t\t\t\t(struct set_assocsta_rsp *) (pcmd->rsp);\n\tstruct sta_info *psta = r8712_get_stainfo(pstapriv,\n\t\t\t\t\t\t  passocsta_parm->addr);\n\n\tif (!psta)\n\t\treturn;\n\tpsta->aid = psta->mac_id = passocsta_rsp->cam_id;\n\tspin_lock_irqsave(&pmlmepriv->lock, irqL);\n\tif ((check_fwstate(pmlmepriv, WIFI_MP_STATE)) &&\n\t    (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)))\n\t\tpmlmepriv->fw_state ^= _FW_UNDER_LINKING;\n\tset_fwstate(pmlmepriv, _FW_LINKED);\n\tspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\n\tr8712_free_cmd_obj(pcmd);\n}\n\nvoid r8712_disconnectCtrlEx_cmd(struct _adapter *adapter, u32 enableDrvCtrl,\n\t\t\tu32 tryPktCnt, u32 tryPktInterval, u32 firstStageTO)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct DisconnectCtrlEx_param *param;\n\tstruct cmd_priv *pcmdpriv = &adapter->cmdpriv;\n\n\tph2c = kmalloc(sizeof(*ph2c), GFP_ATOMIC);\n\tif (!ph2c)\n\t\treturn;\n\tparam = kzalloc(sizeof(*param), GFP_ATOMIC);\n\tif (!param) {\n\t\tkfree(ph2c);\n\t\treturn;\n\t}\n\n\tparam->EnableDrvCtrl = (unsigned char)enableDrvCtrl;\n\tparam->TryPktCnt = (unsigned char)tryPktCnt;\n\tparam->TryPktInterval = (unsigned char)tryPktInterval;\n\tparam->FirstStageTO = (unsigned int)firstStageTO;\n\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, param,\n\t\t\t\tGEN_CMD_CODE(_DisconnectCtrlEx));\n\tr8712_enqueue_cmd(pcmdpriv, ph2c);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}