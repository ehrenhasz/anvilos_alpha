{
  "module_name": "rtl871x_recv.c",
  "hash_id": "56391e45a58b4e56f449169bec82ddf9c9e03c8b87ed1b88afe636be1f4e11a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/rtl871x_recv.c",
  "human_readable_source": "\n \n\n#define _RTL871X_RECV_C_\n\n#include <linux/ip.h>\n#include <linux/if_ether.h>\n#include <linux/etherdevice.h>\n#include <linux/ieee80211.h>\n#include <net/cfg80211.h>\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"recv_osdep.h\"\n#include \"mlme_osdep.h\"\n#include \"ethernet.h\"\n#include \"usb_ops.h\"\n#include \"wifi.h\"\n\nstatic const u8 SNAP_ETH_TYPE_IPX[2] = {0x81, 0x37};\n\n \nstatic const u8 SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};\n\nvoid _r8712_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)\n{\n\tmemset((u8 *)psta_recvpriv, 0, sizeof(struct sta_recv_priv));\n\tspin_lock_init(&psta_recvpriv->lock);\n\t_init_queue(&psta_recvpriv->defrag_q);\n}\n\nint _r8712_init_recv_priv(struct recv_priv *precvpriv,\n\t\t\t  struct _adapter *padapter)\n{\n\tint ret;\n\tsint i;\n\tunion recv_frame *precvframe;\n\n\tmemset((unsigned char *)precvpriv, 0, sizeof(struct  recv_priv));\n\tspin_lock_init(&precvpriv->lock);\n\t_init_queue(&precvpriv->free_recv_queue);\n\t_init_queue(&precvpriv->recv_pending_queue);\n\tprecvpriv->adapter = padapter;\n\tprecvpriv->free_recvframe_cnt = NR_RECVFRAME;\n\tprecvpriv->pallocated_frame_buf = kzalloc(NR_RECVFRAME *\n\t\t\t\tsizeof(union recv_frame) + RXFRAME_ALIGN_SZ,\n\t\t\t\tGFP_ATOMIC);\n\tif (!precvpriv->pallocated_frame_buf)\n\t\treturn -ENOMEM;\n\tprecvpriv->precv_frame_buf = precvpriv->pallocated_frame_buf +\n\t\t\t\t    RXFRAME_ALIGN_SZ -\n\t\t\t\t    ((addr_t)(precvpriv->pallocated_frame_buf) &\n\t\t\t\t    (RXFRAME_ALIGN_SZ - 1));\n\tprecvframe = (union recv_frame *)precvpriv->precv_frame_buf;\n\tfor (i = 0; i < NR_RECVFRAME; i++) {\n\t\tINIT_LIST_HEAD(&(precvframe->u.list));\n\t\tlist_add_tail(&(precvframe->u.list),\n\t\t\t      &(precvpriv->free_recv_queue.queue));\n\t\tr8712_os_recv_resource_alloc(padapter, precvframe);\n\t\tprecvframe->u.hdr.adapter = padapter;\n\t\tprecvframe++;\n\t}\n\tprecvpriv->rx_pending_cnt = 1;\n\tret = r8712_init_recv_priv(precvpriv, padapter);\n\tif (ret)\n\t\tkfree(precvpriv->pallocated_frame_buf);\n\n\treturn ret;\n}\n\nvoid _r8712_free_recv_priv(struct recv_priv *precvpriv)\n{\n\tkfree(precvpriv->pallocated_frame_buf);\n\tr8712_free_recv_priv(precvpriv);\n}\n\nunion recv_frame *r8712_alloc_recvframe(struct __queue *pfree_recv_queue)\n{\n\tunsigned long irqL;\n\tunion recv_frame  *precvframe;\n\tstruct _adapter *padapter;\n\tstruct recv_priv *precvpriv;\n\n\tspin_lock_irqsave(&pfree_recv_queue->lock, irqL);\n\tprecvframe = list_first_entry_or_null(&pfree_recv_queue->queue,\n\t\t\t\t\t      union recv_frame, u.hdr.list);\n\tif (precvframe) {\n\t\tlist_del_init(&precvframe->u.hdr.list);\n\t\tpadapter = precvframe->u.hdr.adapter;\n\t\tif (padapter) {\n\t\t\tprecvpriv = &padapter->recvpriv;\n\t\t\tif (pfree_recv_queue == &precvpriv->free_recv_queue)\n\t\t\t\tprecvpriv->free_recvframe_cnt--;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pfree_recv_queue->lock, irqL);\n\treturn precvframe;\n}\n\n \nvoid r8712_free_recvframe_queue(struct  __queue *pframequeue,\n\t\t\t\tstruct  __queue *pfree_recv_queue)\n{\n\tunion\trecv_frame *precvframe;\n\tstruct list_head *plist, *phead;\n\n\tspin_lock(&pframequeue->lock);\n\tphead = &pframequeue->queue;\n\tplist = phead->next;\n\twhile (!end_of_queue_search(phead, plist)) {\n\t\tprecvframe = container_of(plist, union recv_frame, u.list);\n\t\tplist = plist->next;\n\t\tr8712_free_recvframe(precvframe, pfree_recv_queue);\n\t}\n\tspin_unlock(&pframequeue->lock);\n}\n\nsint r8712_recvframe_chkmic(struct _adapter *adapter,\n\t\t\t    union recv_frame *precvframe)\n{\n\tsint i, res = _SUCCESS;\n\tu32\tdatalen;\n\tu8 miccode[8];\n\tu8 bmic_err = false;\n\tu8 *pframe, *payload, *pframemic;\n\tu8   *mickey, idx, *iv;\n\tstruct\tsta_info *stainfo;\n\tstruct\trx_pkt_attrib *prxattrib = &precvframe->u.hdr.attrib;\n\tstruct\tsecurity_priv *psecuritypriv = &adapter->securitypriv;\n\n\tstainfo = r8712_get_stainfo(&adapter->stapriv, &prxattrib->ta[0]);\n\tif (prxattrib->encrypt == _TKIP_) {\n\t\t \n\t\tif (stainfo) {\n\t\t\tif (is_multicast_ether_addr(prxattrib->ra)) {\n\t\t\t\tiv = precvframe->u.hdr.rx_data +\n\t\t\t\t     prxattrib->hdrlen;\n\t\t\t\tidx = iv[3];\n\t\t\t\tmickey = &psecuritypriv->XGrprxmickey[(((idx >>\n\t\t\t\t\t 6) & 0x3)) - 1].skey[0];\n\t\t\t\tif (!psecuritypriv->binstallGrpkey)\n\t\t\t\t\treturn _FAIL;\n\t\t\t} else {\n\t\t\t\tmickey = &stainfo->tkiprxmickey.skey[0];\n\t\t\t}\n\t\t\t \n\t\t\tdatalen = precvframe->u.hdr.len - prxattrib->hdrlen -\n\t\t\t\t  prxattrib->iv_len - prxattrib->icv_len - 8;\n\t\t\tpframe = precvframe->u.hdr.rx_data;\n\t\t\tpayload = pframe + prxattrib->hdrlen +\n\t\t\t\t  prxattrib->iv_len;\n\t\t\tseccalctkipmic(mickey, pframe, payload, datalen,\n\t\t\t\t       &miccode[0],\n\t\t\t\t       (unsigned char)prxattrib->priority);\n\t\t\tpframemic = payload + datalen;\n\t\t\tbmic_err = false;\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tif (miccode[i] != *(pframemic + i))\n\t\t\t\t\tbmic_err = true;\n\t\t\t}\n\t\t\tif (bmic_err) {\n\t\t\t\tif (prxattrib->bdecrypted)\n\t\t\t\t\tr8712_handle_tkip_mic_err(adapter,\n\t\t\t\t\t\t\t\t  (u8)is_multicast_ether_addr(prxattrib->ra));\n\t\t\t\tres = _FAIL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (!psecuritypriv->bcheck_grpkey &&\n\t\t\t\t    is_multicast_ether_addr(prxattrib->ra))\n\t\t\t\t\tpsecuritypriv->bcheck_grpkey = true;\n\t\t\t}\n\t\t\trecvframe_pull_tail(precvframe, 8);\n\t\t}\n\t}\n\treturn res;\n}\n\n \nunion recv_frame *r8712_decryptor(struct _adapter *padapter,\n\t\t\t\t  union recv_frame *precv_frame)\n{\n\tstruct rx_pkt_attrib *prxattrib = &precv_frame->u.hdr.attrib;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tunion recv_frame *return_packet = precv_frame;\n\n\tif ((prxattrib->encrypt > 0) && ((prxattrib->bdecrypted == 0) ||\n\t\t\t\t\t psecuritypriv->sw_decrypt)) {\n\t\tpsecuritypriv->hw_decrypted = false;\n\t\tswitch (prxattrib->encrypt) {\n\t\tcase _WEP40_:\n\t\tcase _WEP104_:\n\t\t\tr8712_wep_decrypt(padapter, (u8 *)precv_frame);\n\t\t\tbreak;\n\t\tcase _TKIP_:\n\t\t\tr8712_tkip_decrypt(padapter, (u8 *)precv_frame);\n\t\t\tbreak;\n\t\tcase _AES_:\n\t\t\tr8712_aes_decrypt(padapter, (u8 *)precv_frame);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t} else if (prxattrib->bdecrypted == 1) {\n\t\tpsecuritypriv->hw_decrypted = true;\n\t}\n\treturn return_packet;\n}\n\n \nunion recv_frame *r8712_portctrl(struct _adapter *adapter,\n\t\t\t\t union recv_frame *precv_frame)\n{\n\tu8 *psta_addr, *ptr;\n\tuint auth_alg;\n\tstruct recv_frame_hdr *pfhdr;\n\tstruct sta_info *psta;\n\tstruct\tsta_priv *pstapriv;\n\tunion recv_frame *prtnframe;\n\tu16 ether_type;\n\n\tpstapriv = &adapter->stapriv;\n\tptr = precv_frame->u.hdr.rx_data;\n\tpfhdr = &precv_frame->u.hdr;\n\tpsta_addr = pfhdr->attrib.ta;\n\tpsta = r8712_get_stainfo(pstapriv, psta_addr);\n\tauth_alg = adapter->securitypriv.AuthAlgrthm;\n\tif (auth_alg == 2) {\n\t\t \n\t\tptr = ptr + pfhdr->attrib.hdrlen + LLC_HEADER_SIZE;\n\t\tether_type = get_unaligned_be16(ptr);\n\n\t\tif (psta && psta->ieee8021x_blocked) {\n\t\t\t \n\t\t\tif (ether_type == 0x888e) {\n\t\t\t\tprtnframe = precv_frame;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tr8712_free_recvframe(precv_frame,\n\t\t\t\t\t\t     &adapter->recvpriv.free_recv_queue);\n\t\t\t\tprtnframe = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tprtnframe = precv_frame;\n\t\t\t \n\t\t\tif (ether_type == 0x888e) {\n\t\t\t\t \n\t\t\t\tprtnframe = precv_frame;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprtnframe = precv_frame;\n\t}\n\treturn prtnframe;\n}\n\nstatic sint recv_decache(union recv_frame *precv_frame, u8 bretry,\n\t\t\t struct stainfo_rxcache *prxcache)\n{\n\tsint tid = precv_frame->u.hdr.attrib.priority;\n\tu16 seq_ctrl = ((precv_frame->u.hdr.attrib.seq_num & 0xffff) << 4) |\n\t\t\t(precv_frame->u.hdr.attrib.frag_num & 0xf);\n\n\tif (tid > 15)\n\t\treturn _FAIL;\n\tif (seq_ctrl == prxcache->tid_rxseq[tid])\n\t\treturn _FAIL;\n\tprxcache->tid_rxseq[tid] = seq_ctrl;\n\treturn _SUCCESS;\n}\n\nstatic sint sta2sta_data_frame(struct _adapter *adapter,\n\t\t\t       union recv_frame *precv_frame,\n\t\t\t       struct sta_info **psta)\n{\n\tu8 *ptr = precv_frame->u.hdr.rx_data;\n\tsint ret = _SUCCESS;\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\tstruct\tsta_priv *pstapriv = &adapter->stapriv;\n\tstruct\tmlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tu8 *mybssid  = get_bssid(pmlmepriv);\n\tu8 *myhwaddr = myid(&adapter->eeprompriv);\n\tu8 *sta_addr = NULL;\n\tbool bmcast = is_multicast_ether_addr(pattrib->dst);\n\n\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) ||\n\t    check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\n\t\t \n\t\tif (!memcmp(myhwaddr, pattrib->src, ETH_ALEN))\n\t\t\treturn _FAIL;\n\t\tif ((memcmp(myhwaddr, pattrib->dst, ETH_ALEN)) && (!bmcast))\n\t\t\treturn _FAIL;\n\t\tif (is_zero_ether_addr(pattrib->bssid) ||\n\t\t    is_zero_ether_addr(mybssid) ||\n\t\t    (memcmp(pattrib->bssid, mybssid, ETH_ALEN)))\n\t\t\treturn _FAIL;\n\t\tsta_addr = pattrib->src;\n\t} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\n\t\t \n\t\tif (memcmp(pattrib->bssid, pattrib->src, ETH_ALEN))\n\t\t\treturn _FAIL;\n\t\tsta_addr = pattrib->bssid;\n\t} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\tif (bmcast) {\n\t\t\t \n\t\t\tif (!is_multicast_ether_addr(pattrib->bssid))\n\t\t\t\treturn _FAIL;\n\t\t} else {  \n\t\t\t \n\t\t\tif (memcmp(pattrib->bssid, pattrib->dst, ETH_ALEN))\n\t\t\t\treturn _FAIL;\n\t\t\tsta_addr = pattrib->src;\n\t\t}\n\t} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\n\t\tmemcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\n\t\tsta_addr = mybssid;\n\t} else {\n\t\tret  = _FAIL;\n\t}\n\tif (bmcast)\n\t\t*psta = r8712_get_bcmc_stainfo(adapter);\n\telse\n\t\t*psta = r8712_get_stainfo(pstapriv, sta_addr);  \n\tif (!*psta) {\n\t\tif (check_fwstate(pmlmepriv, WIFI_MP_STATE))\n\t\t\tadapter->mppriv.rx_pktloss++;\n\t\treturn _FAIL;\n\t}\n\treturn ret;\n}\n\nstatic sint ap2sta_data_frame(struct _adapter *adapter,\n\t\t\t      union recv_frame *precv_frame,\n\t\t\t      struct sta_info **psta)\n{\n\tu8 *ptr = precv_frame->u.hdr.rx_data;\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\tstruct\tsta_priv *pstapriv = &adapter->stapriv;\n\tstruct\tmlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tu8 *mybssid  = get_bssid(pmlmepriv);\n\tu8 *myhwaddr = myid(&adapter->eeprompriv);\n\tbool bmcast = is_multicast_ether_addr(pattrib->dst);\n\n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) &&\n\t    check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\t \n\t\tif ((GetFrameSubType(ptr)) == (IEEE80211_FTYPE_DATA | IEEE80211_STYPE_NULLFUNC))\n\t\t\treturn _FAIL;\n\t\t \n\t\tif ((GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE) ==\n\t\t     WIFI_QOS_DATA_TYPE) {\n\t\t\tif (GetFrameSubType(ptr) & (BIT(4) | BIT(5) | BIT(6)))\n\t\t\t\treturn _FAIL;\n\t\t}\n\n\t\t \n\t\tif (!memcmp(myhwaddr, pattrib->src, ETH_ALEN))\n\t\t\treturn _FAIL;\n\n\t\t \n\t\tif ((memcmp(myhwaddr, pattrib->dst, ETH_ALEN)) && (!bmcast))\n\t\t\treturn _FAIL;\n\t\t \n\t\tif (is_zero_ether_addr(pattrib->bssid) ||\n\t\t    is_zero_ether_addr(mybssid) ||\n\t\t     (memcmp(pattrib->bssid, mybssid, ETH_ALEN)))\n\t\t\treturn _FAIL;\n\t\tif (bmcast)\n\t\t\t*psta = r8712_get_bcmc_stainfo(adapter);\n\t\telse\n\t\t\t*psta = r8712_get_stainfo(pstapriv, pattrib->bssid);\n\t\tif (!*psta)\n\t\t\treturn _FAIL;\n\t} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) &&\n\t\t   check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\tmemcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\n\t\tmemcpy(pattrib->bssid,  mybssid, ETH_ALEN);\n\t\t*psta = r8712_get_stainfo(pstapriv, pattrib->bssid);\n\t\tif (!*psta)\n\t\t\treturn _FAIL;\n\t} else {\n\t\treturn _FAIL;\n\t}\n\treturn _SUCCESS;\n}\n\nstatic sint sta2ap_data_frame(struct _adapter *adapter,\n\t\t\t      union recv_frame *precv_frame,\n\t\t\t      struct sta_info **psta)\n{\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\tstruct\tsta_priv *pstapriv = &adapter->stapriv;\n\tstruct\tmlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tunsigned char *mybssid  = get_bssid(pmlmepriv);\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\t \n\t\tif (memcmp(pattrib->bssid, mybssid, ETH_ALEN))\n\t\t\treturn _FAIL;\n\t\t*psta = r8712_get_stainfo(pstapriv, pattrib->src);\n\t\tif (!*psta)\n\t\t\treturn _FAIL;\n\t}\n\treturn _SUCCESS;\n}\n\nstatic sint validate_recv_ctrl_frame(struct _adapter *adapter,\n\t\t\t\t     union recv_frame *precv_frame)\n{\n\treturn _FAIL;\n}\n\nstatic sint validate_recv_mgnt_frame(struct _adapter *adapter,\n\t\t\t\t     union recv_frame *precv_frame)\n{\n\treturn _FAIL;\n}\n\nstatic sint validate_recv_data_frame(struct _adapter *adapter,\n\t\t\t\t     union recv_frame *precv_frame)\n{\n\tint res;\n\tu8 bretry;\n\tu8 *psa, *pda, *pbssid;\n\tstruct sta_info *psta = NULL;\n\tu8 *ptr = precv_frame->u.hdr.rx_data;\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\tstruct security_priv *psecuritypriv = &adapter->securitypriv;\n\n\tbretry = GetRetry(ptr);\n\tpda = ieee80211_get_DA((struct ieee80211_hdr *)ptr);\n\tpsa = ieee80211_get_SA((struct ieee80211_hdr *)ptr);\n\tpbssid = get_hdr_bssid(ptr);\n\tif (!pbssid)\n\t\treturn _FAIL;\n\tmemcpy(pattrib->dst, pda, ETH_ALEN);\n\tmemcpy(pattrib->src, psa, ETH_ALEN);\n\tmemcpy(pattrib->bssid, pbssid, ETH_ALEN);\n\tswitch (pattrib->to_fr_ds) {\n\tcase 0:\n\t\tmemcpy(pattrib->ra, pda, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, psa, ETH_ALEN);\n\t\tres = sta2sta_data_frame(adapter, precv_frame, &psta);\n\t\tbreak;\n\tcase 1:\n\t\tmemcpy(pattrib->ra, pda, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, pbssid, ETH_ALEN);\n\t\tres = ap2sta_data_frame(adapter, precv_frame, &psta);\n\t\tbreak;\n\tcase 2:\n\t\tmemcpy(pattrib->ra, pbssid, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, psa, ETH_ALEN);\n\t\tres = sta2ap_data_frame(adapter, precv_frame, &psta);\n\t\tbreak;\n\tcase 3:\n\t\tmemcpy(pattrib->ra, GetAddr1Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->ta, GetAddr2Ptr(ptr), ETH_ALEN);\n\t\treturn _FAIL;\n\tdefault:\n\t\treturn _FAIL;\n\t}\n\tif (res == _FAIL)\n\t\treturn _FAIL;\n\tif (!psta)\n\t\treturn _FAIL;\n\tprecv_frame->u.hdr.psta = psta;\n\tpattrib->amsdu = 0;\n\t \n\tif (pattrib->qos == 1) {\n\t\tpattrib->priority = GetPriority((ptr + 24));\n\t\tpattrib->ack_policy = GetAckpolicy((ptr + 24));\n\t\tpattrib->amsdu = GetAMsdu((ptr + 24));\n\t\tpattrib->hdrlen = pattrib->to_fr_ds == 3 ? 32 : 26;\n\t} else {\n\t\tpattrib->priority = 0;\n\t\tpattrib->hdrlen = (pattrib->to_fr_ds == 3) ? 30 : 24;\n\t}\n\n\tif (pattrib->order) \n\t\tpattrib->hdrlen += 4;\n\tprecv_frame->u.hdr.preorder_ctrl =\n\t\t\t &psta->recvreorder_ctrl[pattrib->priority];\n\n\t \n\tif (recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) ==\n\t    _FAIL)\n\t\treturn _FAIL;\n\n\tif (pattrib->privacy) {\n\t\tGET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt,\n\t\t\t       is_multicast_ether_addr(pattrib->ra));\n\t\tSET_ICE_IV_LEN(pattrib->iv_len, pattrib->icv_len,\n\t\t\t       pattrib->encrypt);\n\t} else {\n\t\tpattrib->encrypt = 0;\n\t\tpattrib->iv_len = pattrib->icv_len = 0;\n\t}\n\treturn _SUCCESS;\n}\n\nsint r8712_validate_recv_frame(struct _adapter *adapter,\n\t\t\t       union recv_frame *precv_frame)\n{\n\t \n\t \n\n\tu8 type;\n\tu8 subtype;\n\tsint retval = _SUCCESS;\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\n\tu8 *ptr = precv_frame->u.hdr.rx_data;\n\tu8  ver = (unsigned char)(*ptr) & 0x3;\n\n\t \n\tif (ver != 0)\n\t\treturn _FAIL;\n\ttype =  GetFrameType(ptr);\n\tsubtype = GetFrameSubType(ptr);  \n\tpattrib->to_fr_ds = get_tofr_ds(ptr);\n\tpattrib->frag_num = GetFragNum(ptr);\n\tpattrib->seq_num = GetSequence(ptr);\n\tpattrib->pw_save = GetPwrMgt(ptr);\n\tpattrib->mfrag = GetMFrag(ptr);\n\tpattrib->mdata = GetMData(ptr);\n\tpattrib->privacy =  GetPrivacy(ptr);\n\tpattrib->order = GetOrder(ptr);\n\tswitch (type) {\n\tcase IEEE80211_FTYPE_MGMT:\n\t\tretval = validate_recv_mgnt_frame(adapter, precv_frame);\n\t\tbreak;\n\tcase IEEE80211_FTYPE_CTL:\n\t\tretval = validate_recv_ctrl_frame(adapter, precv_frame);\n\t\tbreak;\n\tcase IEEE80211_FTYPE_DATA:\n\t\tpattrib->qos = (subtype & BIT(7)) ? 1 : 0;\n\t\tretval = validate_recv_data_frame(adapter, precv_frame);\n\t\tbreak;\n\tdefault:\n\t\treturn _FAIL;\n\t}\n\treturn retval;\n}\n\nint r8712_wlanhdr_to_ethhdr(union recv_frame *precvframe)\n{\n\t \n\tsint\trmv_len;\n\tu16\tlen;\n\tu8\tbsnaphdr;\n\tu8\t*psnap_type;\n\tstruct ieee80211_snap_hdr *psnap;\n\tstruct _adapter\t*adapter = precvframe->u.hdr.adapter;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\n\tu8 *ptr = precvframe->u.hdr.rx_data;  \n\tstruct rx_pkt_attrib *pattrib = &precvframe->u.hdr.attrib;\n\n\tif (pattrib->encrypt)\n\t\trecvframe_pull_tail(precvframe, pattrib->icv_len);\n\tpsnap = (struct ieee80211_snap_hdr *)(ptr + pattrib->hdrlen +\n\t\t pattrib->iv_len);\n\tpsnap_type = ptr + pattrib->hdrlen + pattrib->iv_len + SNAP_SIZE;\n\t \n\tif ((!memcmp(psnap, (void *)rfc1042_header, SNAP_SIZE) &&\n\t     (memcmp(psnap_type, (void *)SNAP_ETH_TYPE_IPX, 2)) &&\n\t    (memcmp(psnap_type, (void *)SNAP_ETH_TYPE_APPLETALK_AARP, 2))) ||\n\t     !memcmp(psnap, (void *)bridge_tunnel_header, SNAP_SIZE)) {\n\t\t \n\t\tbsnaphdr = true;\n\t} else {\n\t\t \n\t\tbsnaphdr = false;\n\t}\n\trmv_len = pattrib->hdrlen + pattrib->iv_len +\n\t\t  (bsnaphdr ? SNAP_SIZE : 0);\n\tlen = precvframe->u.hdr.len - rmv_len;\n\tif (check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\n\t\tptr += rmv_len;\n\t\t*ptr = 0x87;\n\t\t*(ptr + 1) = 0x12;\n\t\t \n\t\tptr = recvframe_pull(precvframe, (rmv_len -\n\t\t      sizeof(struct ethhdr) + 2) - 24);\n\t\tif (!ptr)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(ptr, get_rxmem(precvframe), 24);\n\t\tptr += 24;\n\t} else {\n\t\tptr = recvframe_pull(precvframe, (rmv_len -\n\t\t      sizeof(struct ethhdr) + (bsnaphdr ? 2 : 0)));\n\t\tif (!ptr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(ptr, pattrib->dst, ETH_ALEN);\n\tmemcpy(ptr + ETH_ALEN, pattrib->src, ETH_ALEN);\n\tif (!bsnaphdr) {\n\t\t__be16 be_tmp = htons(len);\n\n\t\tmemcpy(ptr + 12, &be_tmp, 2);\n\t}\n\treturn 0;\n}\n\nvoid r8712_recv_entry(union recv_frame *precvframe)\n{\n\tstruct _adapter *padapter;\n\tstruct recv_priv *precvpriv;\n\n\ts32 ret = _SUCCESS;\n\n\tpadapter = precvframe->u.hdr.adapter;\n\tprecvpriv = &(padapter->recvpriv);\n\n\tpadapter->ledpriv.LedControlHandler(padapter, LED_CTL_RX);\n\n\tret = recv_func(padapter, precvframe);\n\tif (ret == _FAIL)\n\t\tgoto _recv_entry_drop;\n\tprecvpriv->rx_pkts++;\n\tprecvpriv->rx_bytes += (uint)(precvframe->u.hdr.rx_tail -\n\t\t\t\tprecvframe->u.hdr.rx_data);\n\treturn;\n_recv_entry_drop:\n\tprecvpriv->rx_drop++;\n\tpadapter->mppriv.rx_pktloss = precvpriv->rx_drop;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}