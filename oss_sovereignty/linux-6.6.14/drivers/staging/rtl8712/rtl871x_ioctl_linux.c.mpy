{
  "module_name": "rtl871x_ioctl_linux.c",
  "hash_id": "cadd3495235e3c6aed1844d21ce86a5366d59d46ea783a16a8be1ca58ea4e4f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/rtl871x_ioctl_linux.c",
  "human_readable_source": "\n \n\n#define _RTL871X_IOCTL_LINUX_C_\n#define _RTL871X_MP_IOCTL_C_\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"wlan_bssdef.h\"\n#include \"rtl871x_debug.h\"\n#include \"wifi.h\"\n#include \"rtl871x_mlme.h\"\n#include \"rtl871x_ioctl.h\"\n#include \"rtl871x_ioctl_set.h\"\n#include \"rtl871x_mp_ioctl.h\"\n#include \"mlme_osdep.h\"\n#include <linux/wireless.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/semaphore.h>\n#include <net/iw_handler.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n\n#define RTL_IOCTL_WPA_SUPPLICANT\t(SIOCIWFIRSTPRIV + 0x1E)\n\n#define SCAN_ITEM_SIZE 768\n#define MAX_CUSTOM_LEN 64\n#define RATE_COUNT 4\n\nstatic const u32 rtl8180_rates[] = {1000000, 2000000, 5500000, 11000000,\n\t\t       6000000, 9000000, 12000000, 18000000,\n\t\t       24000000, 36000000, 48000000, 54000000};\n\nstatic const long ieee80211_wlan_frequencies[] = {\n\t2412, 2417, 2422, 2427,\n\t2432, 2437, 2442, 2447,\n\t2452, 2457, 2462, 2467,\n\t2472, 2484\n};\n\nvoid r8712_indicate_wx_assoc_event(struct _adapter *padapter)\n{\n\tunion iwreq_data wrqu;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\tmemcpy(wrqu.ap_addr.sa_data, pmlmepriv->cur_network.network.MacAddress,\n\t\tETH_ALEN);\n\twireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);\n}\n\nvoid r8712_indicate_wx_disassoc_event(struct _adapter *padapter)\n{\n\tunion iwreq_data wrqu;\n\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\teth_zero_addr(wrqu.ap_addr.sa_data);\n\twireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);\n}\n\nstatic inline void handle_pairwise_key(struct sta_info *psta,\n\t\t\t\t       struct ieee_param *param,\n\t\t\t\t       struct _adapter *padapter)\n{\n\t \n\tmemcpy(psta->x_UncstKey.skey, param->u.crypt.key,\n\t       (param->u.crypt. key_len > 16 ? 16 : param->u.crypt.key_len));\n\tif (strcmp(param->u.crypt.alg, \"TKIP\") == 0) {  \n\t\tmemcpy(psta->tkiptxmickey. skey,\n\t\t       &param->u.crypt.key[16], 8);\n\t\tmemcpy(psta->tkiprxmickey. skey,\n\t\t       &param->u.crypt.key[24], 8);\n\t\tpadapter->securitypriv. busetkipkey = false;\n\t\tmod_timer(&padapter->securitypriv.tkip_timer,\n\t\t\t  jiffies + msecs_to_jiffies(50));\n\t}\n\tr8712_setstakey_cmd(padapter, (unsigned char *)psta, true);\n}\n\nstatic inline void handle_group_key(struct ieee_param *param,\n\t\t\t\t    struct _adapter *padapter)\n{\n\tunion Keytype *gk = padapter->securitypriv.XGrpKey;\n\tunion Keytype *gtk = padapter->securitypriv.XGrptxmickey;\n\tunion Keytype *grk = padapter->securitypriv.XGrprxmickey;\n\n\tif (param->u.crypt.idx > 0 &&\n\t    param->u.crypt.idx < 3) {\n\t\t \n\t\tmemcpy(gk[param->u.crypt.idx - 1].skey,\n\t\t       param->u.crypt.key,\n\t\t       (param->u.crypt.key_len > 16 ? 16 :\n\t\t\tparam->u.crypt.key_len));\n\t\tmemcpy(gtk[param->u.crypt.idx - 1].skey,\n\t\t       &param->u.crypt.key[16], 8);\n\t\tmemcpy(grk[param->u.crypt.idx - 1].skey,\n\t\t       &param->u.crypt.key[24], 8);\n\t\tpadapter->securitypriv.binstallGrpkey = true;\n\t\tr8712_set_key(padapter, &padapter->securitypriv,\n\t\t\tparam->u.crypt.idx);\n\t\tif (padapter->registrypriv.power_mgnt > PS_MODE_ACTIVE) {\n\t\t\tif (padapter->registrypriv.power_mgnt !=\n\t\t\t    padapter->pwrctrlpriv.pwr_mode)\n\t\t\t\tmod_timer(&padapter->mlmepriv.dhcp_timer,\n\t\t\t\t\t  jiffies + msecs_to_jiffies(60000));\n\t\t}\n\t}\n}\n\nstatic noinline_for_stack char *translate_scan_wpa(struct iw_request_info *info,\n\t\t\t\t\t\t   struct wlan_network *pnetwork,\n\t\t\t\t\t\t   struct iw_event *iwe,\n\t\t\t\t\t\t   char *start, char *stop)\n{\n\t \n\tu8 buf[MAX_WPA_IE_LEN];\n\tu8 wpa_ie[255], rsn_ie[255];\n\tu16 wpa_len = 0, rsn_len = 0;\n\tint n, i;\n\n\tr8712_get_sec_ie(pnetwork->network.IEs,\n\t\t\t pnetwork->network.IELength, rsn_ie, &rsn_len,\n\t\t\t wpa_ie, &wpa_len);\n\tif (wpa_len > 0) {\n\t\tmemset(buf, 0, MAX_WPA_IE_LEN);\n\t\tn = sprintf(buf, \"wpa_ie=\");\n\t\tfor (i = 0; i < wpa_len; i++) {\n\t\t\tn += scnprintf(buf + n, MAX_WPA_IE_LEN - n,\n\t\t\t\t\t\t\"%02x\", wpa_ie[i]);\n\t\t\tif (n == MAX_WPA_IE_LEN - 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tmemset(iwe, 0, sizeof(*iwe));\n\t\tiwe->cmd = IWEVCUSTOM;\n\t\tiwe->u.data.length = (u16)strlen(buf);\n\t\tstart = iwe_stream_add_point(info, start, stop,\n\t\t\tiwe, buf);\n\t\tmemset(iwe, 0, sizeof(*iwe));\n\t\tiwe->cmd = IWEVGENIE;\n\t\tiwe->u.data.length = (u16)wpa_len;\n\t\tstart = iwe_stream_add_point(info, start, stop,\n\t\t\tiwe, wpa_ie);\n\t}\n\tif (rsn_len > 0) {\n\t\tmemset(buf, 0, MAX_WPA_IE_LEN);\n\t\tn = sprintf(buf, \"rsn_ie=\");\n\t\tfor (i = 0; i < rsn_len; i++) {\n\t\t\tn += scnprintf(buf + n, MAX_WPA_IE_LEN - n,\n\t\t\t\t\t\t\"%02x\", rsn_ie[i]);\n\t\t\tif (n == MAX_WPA_IE_LEN - 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tmemset(iwe, 0, sizeof(*iwe));\n\t\tiwe->cmd = IWEVCUSTOM;\n\t\tiwe->u.data.length = strlen(buf);\n\t\tstart = iwe_stream_add_point(info, start, stop,\n\t\t\tiwe, buf);\n\t\tmemset(iwe, 0, sizeof(*iwe));\n\t\tiwe->cmd = IWEVGENIE;\n\t\tiwe->u.data.length = rsn_len;\n\t\tstart = iwe_stream_add_point(info, start, stop, iwe,\n\t\t\trsn_ie);\n\t}\n\n\treturn start;\n}\n\nstatic noinline_for_stack char *translate_scan_wps(struct iw_request_info *info,\n\t\t\t\t\t\t   struct wlan_network *pnetwork,\n\t\t\t\t\t\t   struct iw_event *iwe,\n\t\t\t\t\t\t   char *start, char *stop)\n{\n\t \n\tu8 wps_ie[512];\n\tuint wps_ielen;\n\n\tif (r8712_get_wps_ie(pnetwork->network.IEs,\n\t    pnetwork->network.IELength,\n\t    wps_ie, &wps_ielen)) {\n\t\tif (wps_ielen > 2) {\n\t\t\tiwe->cmd = IWEVGENIE;\n\t\t\tiwe->u.data.length = (u16)wps_ielen;\n\t\t\tstart = iwe_stream_add_point(info, start, stop,\n\t\t\t\tiwe, wps_ie);\n\t\t}\n\t}\n\n\treturn start;\n}\n\nstatic char *translate_scan(struct _adapter *padapter,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    struct wlan_network *pnetwork,\n\t\t\t    char *start, char *stop)\n{\n\tstruct iw_event iwe;\n\tchar *current_val;\n\ts8 *p;\n\tu32 i = 0, ht_ielen = 0;\n\tu16\tcap, ht_cap = false;\n\tu8 rssi;\n\n\tif ((pnetwork->network.Configuration.DSConfig < 1) ||\n\t    (pnetwork->network.Configuration.DSConfig > 14)) {\n\t\tif (pnetwork->network.Configuration.DSConfig < 1)\n\t\t\tpnetwork->network.Configuration.DSConfig = 1;\n\t\telse\n\t\t\tpnetwork->network.Configuration.DSConfig = 14;\n\t}\n\t \n\tiwe.cmd = SIOCGIWAP;\n\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\tether_addr_copy(iwe.u.ap_addr.sa_data, pnetwork->network.MacAddress);\n\tstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);\n\t \n\tiwe.cmd = SIOCGIWESSID;\n\tiwe.u.data.flags = 1;\n\tiwe.u.data.length = min_t(u32, pnetwork->network.Ssid.SsidLength, 32);\n\tstart = iwe_stream_add_point(info, start, stop, &iwe,\n\t\t\t\t     pnetwork->network.Ssid.Ssid);\n\t \n\tp = r8712_get_ie(&pnetwork->network.IEs[12], WLAN_EID_HT_CAPABILITY,\n\t\t\t &ht_ielen, pnetwork->network.IELength - 12);\n\tif (p && ht_ielen > 0)\n\t\tht_cap = true;\n\t \n\tiwe.cmd = SIOCGIWNAME;\n\tif (r8712_is_cckratesonly_included(pnetwork->network.rates)) {\n\t\tif (ht_cap)\n\t\t\tsnprintf(iwe.u.name, IFNAMSIZ, \"IEEE 802.11bn\");\n\t\telse\n\t\t\tsnprintf(iwe.u.name, IFNAMSIZ, \"IEEE 802.11b\");\n\t} else if (r8712_is_cckrates_included(pnetwork->network.rates)) {\n\t\tif (ht_cap)\n\t\t\tsnprintf(iwe.u.name, IFNAMSIZ, \"IEEE 802.11bgn\");\n\t\telse\n\t\t\tsnprintf(iwe.u.name, IFNAMSIZ, \"IEEE 802.11bg\");\n\t} else {\n\t\tif (ht_cap)\n\t\t\tsnprintf(iwe.u.name, IFNAMSIZ, \"IEEE 802.11gn\");\n\t\telse\n\t\t\tsnprintf(iwe.u.name, IFNAMSIZ, \"IEEE 802.11g\");\n\t}\n\tstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);\n\t \n\tiwe.cmd = SIOCGIWMODE;\n\tmemcpy((u8 *)&cap, r8712_get_capability_from_ie(pnetwork->network.IEs),\n\t\t2);\n\tle16_to_cpus(&cap);\n\tif (cap & (WLAN_CAPABILITY_IBSS | WLAN_CAPABILITY_ESS)) {\n\t\tif (cap & WLAN_CAPABILITY_ESS)\n\t\t\tiwe.u.mode = (u32)IW_MODE_MASTER;\n\t\telse\n\t\t\tiwe.u.mode = (u32)IW_MODE_ADHOC;\n\t\tstart = iwe_stream_add_event(info, start, stop, &iwe,\n\t\t\tIW_EV_UINT_LEN);\n\t}\n\t \n\tiwe.cmd = SIOCGIWFREQ;\n\t{\n\t\t \n\t\tu8 dsconfig = pnetwork->network.Configuration.DSConfig;\n\n\t\tif (dsconfig >= 1 && dsconfig <= sizeof(\n\t\t    ieee80211_wlan_frequencies) / sizeof(long))\n\t\t\tiwe.u.freq.m =\n\t\t\t\t(s32)(ieee80211_wlan_frequencies\n\t\t\t\t      [dsconfig - 1] * 100000);\n\t\telse\n\t\t\tiwe.u.freq.m = 0;\n\t}\n\tiwe.u.freq.e = (s16)1;\n\tiwe.u.freq.i = (u8)pnetwork->network.Configuration.DSConfig;\n\tstart = iwe_stream_add_event(info, start, stop, &iwe,\n\t\tIW_EV_FREQ_LEN);\n\t \n\tiwe.cmd = SIOCGIWENCODE;\n\tif (cap & WLAN_CAPABILITY_PRIVACY)\n\t\tiwe.u.data.flags = (u16)(IW_ENCODE_ENABLED |\n\t\t\t\t    IW_ENCODE_NOKEY);\n\telse\n\t\tiwe.u.data.flags = (u16)(IW_ENCODE_DISABLED);\n\tiwe.u.data.length = (u16)0;\n\tstart = iwe_stream_add_point(info, start, stop, &iwe,\n\t\tpnetwork->network.Ssid.Ssid);\n\t \n\tcurrent_val = start + iwe_stream_lcp_len(info);\n\tiwe.cmd = SIOCGIWRATE;\n\tiwe.u.bitrate.fixed = 0;\n\tiwe.u.bitrate.disabled = 0;\n\tiwe.u.bitrate.value = 0;\n\ti = 0;\n\twhile (pnetwork->network.rates[i] != 0) {\n\t\t \n\t\tiwe.u.bitrate.value = (pnetwork->network.rates[i++] &\n\t\t\t\t      0x7F) * 500000;\n\t\tcurrent_val = iwe_stream_add_value(info, start, current_val,\n\t\t\t      stop, &iwe, IW_EV_PARAM_LEN);\n\t}\n\t \n\tif ((current_val - start) > iwe_stream_lcp_len(info))\n\t\tstart = current_val;\n\n\tstart = translate_scan_wpa(info, pnetwork, &iwe, start, stop);\n\n\tstart = translate_scan_wps(info, pnetwork, &iwe, start, stop);\n\n\t \n\tiwe.cmd = IWEVQUAL;\n\trssi = r8712_signal_scale_mapping(pnetwork->network.Rssi);\n\t \n\tiwe.u.qual.updated = (u8)(IW_QUAL_QUAL_INVALID | IW_QUAL_LEVEL_UPDATED |\n\t\t\t\t  IW_QUAL_NOISE_INVALID);\n\tiwe.u.qual.level = rssi;   \n\tiwe.u.qual.qual = 0;  \n\tiwe.u.qual.noise = 0;  \n\tstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);\n\t \n\treturn start;\n}\n\nstatic int wpa_set_auth_algs(struct net_device *dev, u32 value)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tint ret = 0;\n\n\tif ((value & AUTH_ALG_SHARED_KEY) && (value & AUTH_ALG_OPEN_SYSTEM)) {\n\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t\t\t Ndis802_11Encryption1Enabled;\n\t\tpadapter->securitypriv.ndisauthtype =\n\t\t\t\t\t\t Ndis802_11AuthModeAutoSwitch;\n\t\tpadapter->securitypriv.AuthAlgrthm = 3;\n\t} else if (value & AUTH_ALG_SHARED_KEY) {\n\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t\t\t Ndis802_11Encryption1Enabled;\n\t\tpadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeShared;\n\t\tpadapter->securitypriv.AuthAlgrthm = 1;\n\t} else if (value & AUTH_ALG_OPEN_SYSTEM) {\n\t\tif (padapter->securitypriv.ndisauthtype <\n\t\t\t\t\t\t Ndis802_11AuthModeWPAPSK) {\n\t\t\tpadapter->securitypriv.ndisauthtype =\n\t\t\t\t\t\t Ndis802_11AuthModeOpen;\n\t\t\tpadapter->securitypriv.AuthAlgrthm = 0;\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,\n\t\t\t      u32 param_len)\n{\n\tint ret = 0;\n\tu32 wep_key_idx, wep_key_len = 0;\n\tstruct NDIS_802_11_WEP\t *pwep = NULL;\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\n\tparam->u.crypt.err = 0;\n\tparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\\0';\n\tif (param_len != (u32)((u8 *) param->u.crypt.key - (u8 *)param) +\n\t\t\t param->u.crypt.key_len)\n\t\treturn -EINVAL;\n\tif (!is_broadcast_ether_addr(param->sta_addr))\n\t\treturn -EINVAL;\n\n\tif (param->u.crypt.idx >= WEP_KEYS) {\n\t\t \n\t\tparam->u.crypt.idx = 0;\n\t}\n\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0) {\n\t\tnetdev_info(dev, \"r8712u: %s: crypt.alg = WEP\\n\", __func__);\n\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t     Ndis802_11Encryption1Enabled;\n\t\tpadapter->securitypriv.PrivacyAlgrthm = _WEP40_;\n\t\tpadapter->securitypriv.XGrpPrivacy = _WEP40_;\n\t\twep_key_idx = param->u.crypt.idx;\n\t\twep_key_len = param->u.crypt.key_len;\n\t\tif (wep_key_idx >= WEP_KEYS)\n\t\t\twep_key_idx = 0;\n\t\tif (wep_key_len <= 0)\n\t\t\treturn -EINVAL;\n\n\t\twep_key_len = wep_key_len <= 5 ? 5 : 13;\n\t\tpwep = kzalloc(sizeof(*pwep), GFP_ATOMIC);\n\t\tif (!pwep)\n\t\t\treturn -ENOMEM;\n\t\tpwep->KeyLength = wep_key_len;\n\t\tpwep->Length = wep_key_len +\n\t\t\toffsetof(struct NDIS_802_11_WEP, KeyMaterial);\n\t\tif (wep_key_len == 13) {\n\t\t\tpadapter->securitypriv.PrivacyAlgrthm = _WEP104_;\n\t\t\tpadapter->securitypriv.XGrpPrivacy = _WEP104_;\n\t\t}\n\t\tpwep->KeyIndex = wep_key_idx;\n\t\tpwep->KeyIndex |= 0x80000000;\n\t\tmemcpy(pwep->KeyMaterial, param->u.crypt.key, pwep->KeyLength);\n\t\tif (param->u.crypt.set_tx) {\n\t\t\tif (r8712_set_802_11_add_wep(padapter, pwep))\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t} else {\n\t\t\t \n\t\t\tif (wep_key_idx >= WEP_KEYS) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tmemcpy(&psecuritypriv->DefKey[wep_key_idx].skey[0],\n\t\t\t       pwep->KeyMaterial,\n\t\t\t       pwep->KeyLength);\n\t\t\tpsecuritypriv->DefKeylen[wep_key_idx] =\n\t\t\t\tpwep->KeyLength;\n\t\t\tr8712_set_key(padapter, psecuritypriv, wep_key_idx);\n\t\t}\n\t\tgoto exit;\n\t}\n\tif (padapter->securitypriv.AuthAlgrthm == 2) {  \n\t\tstruct sta_info *psta, *pbcmc_sta;\n\t\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\t\tstruct security_priv *spriv = &padapter->securitypriv;\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE |\n\t\t    WIFI_MP_STATE)) {  \n\t\t\tpsta = r8712_get_stainfo(pstapriv,\n\t\t\t\t\t\t get_bssid(pmlmepriv));\n\t\t\tif (psta) {\n\t\t\t\tpsta->ieee8021x_blocked = false;\n\t\t\t\tif (spriv->ndisencryptstatus ==\n\t\t\t\t    Ndis802_11Encryption2Enabled ||\n\t\t\t\t    spriv->ndisencryptstatus ==\n\t\t\t\t    Ndis802_11Encryption3Enabled)\n\t\t\t\t\tpsta->XPrivacy = spriv->PrivacyAlgrthm;\n\t\t\t\tif (param->u.crypt.set_tx == 1)\n\t\t\t\t\thandle_pairwise_key(psta, param,\n\t\t\t\t\t\t\t    padapter);\n\t\t\t\telse  \n\t\t\t\t\thandle_group_key(param, padapter);\n\t\t\t}\n\t\t\tpbcmc_sta = r8712_get_bcmc_stainfo(padapter);\n\t\t\tif (pbcmc_sta) {\n\t\t\t\tpbcmc_sta->ieee8021x_blocked = false;\n\t\t\t\tif (spriv->ndisencryptstatus ==\n\t\t\t\t    Ndis802_11Encryption2Enabled ||\n\t\t\t\t    spriv->ndisencryptstatus ==\n\t\t\t\t    Ndis802_11Encryption3Enabled)\n\t\t\t\t\tpbcmc_sta->XPrivacy =\n\t\t\t\t\t\tspriv->PrivacyAlgrthm;\n\t\t\t}\n\t\t}\n\t}\nexit:\n\tkfree(pwep);\n\treturn ret;\n}\n\nstatic int r871x_set_wpa_ie(struct _adapter *padapter, char *pie,\n\t\t\t    unsigned short ielen)\n{\n\tu8 *buf = NULL;\n\tint group_cipher = 0, pairwise_cipher = 0;\n\tint ret = 0;\n\n\tif (ielen > MAX_WPA_IE_LEN || !pie)\n\t\treturn -EINVAL;\n\tif (ielen) {\n\t\tbuf = kmemdup(pie, ielen, GFP_ATOMIC);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tif (ielen < RSN_HEADER_LEN) {\n\t\t\tret  = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (r8712_parse_wpa_ie(buf, ielen, &group_cipher,\n\t\t    &pairwise_cipher) == 0) {\n\t\t\tpadapter->securitypriv.AuthAlgrthm = 2;\n\t\t\tpadapter->securitypriv.ndisauthtype =\n\t\t\t\t  Ndis802_11AuthModeWPAPSK;\n\t\t}\n\t\tif (r8712_parse_wpa2_ie(buf, ielen, &group_cipher,\n\t\t    &pairwise_cipher) == 0) {\n\t\t\tpadapter->securitypriv.AuthAlgrthm = 2;\n\t\t\tpadapter->securitypriv.ndisauthtype =\n\t\t\t\t  Ndis802_11AuthModeWPA2PSK;\n\t\t}\n\t\tswitch (group_cipher) {\n\t\tcase WPA_CIPHER_NONE:\n\t\t\tpadapter->securitypriv.XGrpPrivacy =\n\t\t\t\t _NO_PRIVACY_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11EncryptionDisabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_WEP40:\n\t\t\tpadapter->securitypriv.XGrpPrivacy = _WEP40_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11Encryption1Enabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_TKIP:\n\t\t\tpadapter->securitypriv.XGrpPrivacy = _TKIP_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11Encryption2Enabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_CCMP:\n\t\t\tpadapter->securitypriv.XGrpPrivacy = _AES_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11Encryption3Enabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_WEP104:\n\t\t\tpadapter->securitypriv.XGrpPrivacy = _WEP104_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11Encryption1Enabled;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (pairwise_cipher) {\n\t\tcase WPA_CIPHER_NONE:\n\t\t\tpadapter->securitypriv.PrivacyAlgrthm =\n\t\t\t\t _NO_PRIVACY_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11EncryptionDisabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_WEP40:\n\t\t\tpadapter->securitypriv.PrivacyAlgrthm = _WEP40_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11Encryption1Enabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_TKIP:\n\t\t\tpadapter->securitypriv.PrivacyAlgrthm = _TKIP_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11Encryption2Enabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_CCMP:\n\t\t\tpadapter->securitypriv.PrivacyAlgrthm = _AES_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11Encryption3Enabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_WEP104:\n\t\t\tpadapter->securitypriv.PrivacyAlgrthm = _WEP104_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11Encryption1Enabled;\n\t\t\tbreak;\n\t\t}\n\t\tpadapter->securitypriv.wps_phase = false;\n\t\t{ \n\t\t\tu16 cnt = 0;\n\t\t\tu8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};\n\n\t\t\twhile (cnt < ielen) {\n\t\t\t\teid = buf[cnt];\n\n\t\t\t\tif ((eid == WLAN_EID_VENDOR_SPECIFIC) &&\n\t\t\t\t    (!memcmp(&buf[cnt + 2], wps_oui, 4))) {\n\t\t\t\t\tnetdev_info(padapter->pnetdev, \"r8712u: SET WPS_IE\\n\");\n\t\t\t\t\tpadapter->securitypriv.wps_ie_len =\n\t\t\t\t\t    ((buf[cnt + 1] + 2) <\n\t\t\t\t\t    (MAX_WPA_IE_LEN << 2)) ?\n\t\t\t\t\t    (buf[cnt + 1] + 2) :\n\t\t\t\t\t    (MAX_WPA_IE_LEN << 2);\n\t\t\t\t\tmemcpy(padapter->securitypriv.wps_ie,\n\t\t\t\t\t    &buf[cnt],\n\t\t\t\t\t    padapter->securitypriv.wps_ie_len);\n\t\t\t\t\tpadapter->securitypriv.wps_phase =\n\t\t\t\t\t\t\t\t true;\n\t\t\t\t\tnetdev_info(padapter->pnetdev, \"r8712u: SET WPS_IE, wps_phase==true\\n\");\n\t\t\t\t\tcnt += buf[cnt + 1] + 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcnt += buf[cnt + 1] + 2;\n\t\t\t}\n\t\t}\n\t}\nexit:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int r8711_wx_get_name(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tu32 ht_ielen = 0;\n\tchar *p;\n\tu8 ht_cap = false;\n\tstruct\tmlme_priv\t*pmlmepriv = &padapter->mlmepriv;\n\tstruct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\n\tu8 *prates;\n\n\tif (check_fwstate(pmlmepriv, _FW_LINKED | WIFI_ADHOC_MASTER_STATE) ==\n\t    true) {\n\t\t \n\t\tp = r8712_get_ie(&pcur_bss->IEs[12], WLAN_EID_HT_CAPABILITY,\n\t\t\t\t &ht_ielen, pcur_bss->IELength - 12);\n\t\tif (p && ht_ielen > 0)\n\t\t\tht_cap = true;\n\t\tprates = pcur_bss->rates;\n\t\tif (r8712_is_cckratesonly_included(prates)) {\n\t\t\tif (ht_cap)\n\t\t\t\tsnprintf(wrqu->name, IFNAMSIZ,\n\t\t\t\t\t \"IEEE 802.11bn\");\n\t\t\telse\n\t\t\t\tsnprintf(wrqu->name, IFNAMSIZ,\n\t\t\t\t\t \"IEEE 802.11b\");\n\t\t} else if (r8712_is_cckrates_included(prates)) {\n\t\t\tif (ht_cap)\n\t\t\t\tsnprintf(wrqu->name, IFNAMSIZ,\n\t\t\t\t\t \"IEEE 802.11bgn\");\n\t\t\telse\n\t\t\t\tsnprintf(wrqu->name, IFNAMSIZ,\n\t\t\t\t\t \"IEEE 802.11bg\");\n\t\t} else {\n\t\t\tif (ht_cap)\n\t\t\t\tsnprintf(wrqu->name, IFNAMSIZ,\n\t\t\t\t\t \"IEEE 802.11gn\");\n\t\t\telse\n\t\t\t\tsnprintf(wrqu->name, IFNAMSIZ,\n\t\t\t\t\t \"IEEE 802.11g\");\n\t\t}\n\t} else {\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"unassociated\");\n\t}\n\treturn 0;\n}\n\nstatic const long frequency_list[] = {\n\t2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 2462,\n\t2467, 2472, 2484, 4915, 4920, 4925, 4935, 4940, 4945, 4960, 4980,\n\t5035, 5040, 5045, 5055, 5060, 5080, 5170, 5180, 5190, 5200, 5210,\n\t5220, 5230, 5240, 5260, 5280, 5300, 5320, 5500, 5520, 5540, 5560,\n\t5580, 5600, 5620, 5640, 5660, 5680, 5700, 5745, 5765, 5785, 5805,\n\t5825\n};\n\nstatic int r8711_wx_set_freq(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct iw_freq *fwrq = &wrqu->freq;\n\tint rc = 0;\n\n \n\tif ((fwrq->e == 1) &&\n\t  (fwrq->m >= 241200000) &&\n\t  (fwrq->m <= 248700000)) {\n\t\tint f = fwrq->m / 100000;\n\t\tint c = 0;\n\n\t\twhile ((c < 14) && (f != frequency_list[c]))\n\t\t\tc++;\n\t\tfwrq->e = 0;\n\t\tfwrq->m = c + 1;\n\t}\n\t \n\tif ((fwrq->m > 14) || (fwrq->e > 0)) {\n\t\trc = -EOPNOTSUPP;\n\t} else {\n\t\tint channel = fwrq->m;\n\n\t\tif ((channel < 1) || (channel > 14)) {\n\t\t\trc = -EINVAL;\n\t\t} else {\n\t\t\t \n\t\t\tpadapter->registrypriv.channel = channel;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int r8711_wx_get_freq(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\n\n\tif (!check_fwstate(pmlmepriv, _FW_LINKED))\n\t\treturn -ENOLINK;\n\n\twrqu->freq.m = ieee80211_wlan_frequencies[\n\t\t       pcur_bss->Configuration.DSConfig - 1] * 100000;\n\twrqu->freq.e = 1;\n\twrqu->freq.i = pcur_bss->Configuration.DSConfig;\n\n\treturn 0;\n}\n\nstatic int r8711_wx_set_mode(struct net_device *dev,\n\t\t\t     struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tenum NDIS_802_11_NETWORK_INFRASTRUCTURE networkType;\n\n\tswitch (wrqu->mode) {\n\tcase IW_MODE_AUTO:\n\t\tnetworkType = Ndis802_11AutoUnknown;\n\t\tbreak;\n\tcase IW_MODE_ADHOC:\n\t\tnetworkType = Ndis802_11IBSS;\n\t\tbreak;\n\tcase IW_MODE_MASTER:\n\t\tnetworkType = Ndis802_11APMode;\n\t\tbreak;\n\tcase IW_MODE_INFRA:\n\t\tnetworkType = Ndis802_11Infrastructure;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (Ndis802_11APMode == networkType)\n\t\tr8712_setopmode_cmd(padapter, networkType);\n\telse\n\t\tr8712_setopmode_cmd(padapter, Ndis802_11AutoUnknown);\n\n\tr8712_set_802_11_infrastructure_mode(padapter, networkType);\n\treturn 0;\n}\n\nstatic int r8711_wx_get_mode(struct net_device *dev, struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE))\n\t\twrqu->mode = IW_MODE_INFRA;\n\telse if (check_fwstate(pmlmepriv,\n\t\t WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE))\n\t\twrqu->mode = IW_MODE_ADHOC;\n\telse if (check_fwstate(pmlmepriv, WIFI_AP_STATE))\n\t\twrqu->mode = IW_MODE_MASTER;\n\telse\n\t\twrqu->mode = IW_MODE_AUTO;\n\treturn 0;\n}\n\nstatic int r871x_wx_set_pmkid(struct net_device *dev,\n\t\t\t     struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tstruct iw_pmksa *pPMK = (struct iw_pmksa *) extra;\n\tstruct RT_PMKID_LIST *pl = psecuritypriv->PMKIDList;\n\tu8 strZeroMacAddress[ETH_ALEN] = {0x00};\n\tu8 strIssueBssid[ETH_ALEN] = {0x00};\n\tu8 j, blInserted = false;\n\tint intReturn = false;\n\n \n\tif (!pPMK)\n\t\treturn -EINVAL;\n\tmemcpy(strIssueBssid, pPMK->bssid.sa_data, ETH_ALEN);\n\tswitch (pPMK->cmd) {\n\tcase IW_PMKSA_ADD:\n\t\tif (!memcmp(strIssueBssid, strZeroMacAddress, ETH_ALEN))\n\t\t\treturn intReturn;\n\t\tintReturn = true;\n\t\tblInserted = false;\n\t\t \n\t\tfor (j = 0; j < NUM_PMKID_CACHE; j++) {\n\t\t\tif (!memcmp(pl[j].Bssid, strIssueBssid, ETH_ALEN)) {\n\t\t\t\t \n\t\t\t\tnetdev_info(dev, \"r8712u: %s: BSSID exists in the PMKList.\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\tmemcpy(pl[j].PMKID, pPMK->pmkid, IW_PMKID_LEN);\n\t\t\t\tpl[j].bUsed = true;\n\t\t\t\tpsecuritypriv->PMKIDIndex = j + 1;\n\t\t\t\tblInserted = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!blInserted) {\n\t\t\t \n\t\t\tnetdev_info(dev, \"r8712u: %s: Use the new entry index = %d for this PMKID.\\n\",\n\t\t\t\t    __func__, psecuritypriv->PMKIDIndex);\n\t\t\tmemcpy(pl[psecuritypriv->PMKIDIndex].Bssid,\n\t\t\t       strIssueBssid, ETH_ALEN);\n\t\t\tmemcpy(pl[psecuritypriv->PMKIDIndex].PMKID,\n\t\t\t       pPMK->pmkid, IW_PMKID_LEN);\n\t\t\tpl[psecuritypriv->PMKIDIndex].bUsed = true;\n\t\t\tpsecuritypriv->PMKIDIndex++;\n\t\t\tif (psecuritypriv->PMKIDIndex == NUM_PMKID_CACHE)\n\t\t\t\tpsecuritypriv->PMKIDIndex = 0;\n\t\t}\n\t\tbreak;\n\tcase IW_PMKSA_REMOVE:\n\t\tintReturn = true;\n\t\tfor (j = 0; j < NUM_PMKID_CACHE; j++) {\n\t\t\tif (!memcmp(pl[j].Bssid, strIssueBssid, ETH_ALEN)) {\n\t\t\t\t \n\t\t\t\teth_zero_addr(pl[j].Bssid);\n\t\t\t\tpl[j].bUsed = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IW_PMKSA_FLUSH:\n\t\tmemset(psecuritypriv->PMKIDList, 0,\n\t\t\tsizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);\n\t\tpsecuritypriv->PMKIDIndex = 0;\n\t\tintReturn = true;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_info(dev, \"r8712u: %s: unknown Command\\n\", __func__);\n\t\tintReturn = false;\n\t\tbreak;\n\t}\n\treturn intReturn;\n}\n\nstatic int r8711_wx_get_sens(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\twrqu->sens.value = 0;\n\twrqu->sens.fixed = 0;\t \n\twrqu->sens.disabled = 1;\n\treturn 0;\n}\n\nstatic int r8711_wx_get_range(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_range *range = (struct iw_range *)extra;\n\tu16 val;\n\tint i;\n\n\twrqu->data.length = sizeof(*range);\n\tmemset(range, 0, sizeof(*range));\n\t \n\n\t \n\t \n\trange->throughput = 5 * 1000 * 1000;\n\t \n\t \n\t \n\trange->max_qual.qual = 100;\n\trange->max_qual.level = 100;\n\trange->max_qual.noise = 100;\n\trange->max_qual.updated = 7;  \n\trange->avg_qual.qual = 92;  \n\t \n\trange->avg_qual.level = 0x100 - 78;\n\trange->avg_qual.noise = 0;\n\trange->avg_qual.updated = 7;  \n\trange->num_bitrates = RATE_COUNT;\n\tfor (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++)\n\t\trange->bitrate[i] = rtl8180_rates[i];\n\trange->min_frag = MIN_FRAG_THRESHOLD;\n\trange->max_frag = MAX_FRAG_THRESHOLD;\n\trange->pm_capa = 0;\n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->we_version_source = 16;\n\trange->num_channels = 14;\n\tfor (i = 0, val = 0; i < 14; i++) {\n\t\t \n\t\trange->freq[val].i = i + 1;\n\t\trange->freq[val].m = ieee80211_wlan_frequencies[i] * 100000;\n\t\trange->freq[val].e = 1;\n\t\tval++;\n\t\tif (val == IW_MAX_FREQUENCIES)\n\t\t\tbreak;\n\t}\n\trange->num_frequency = val;\n\trange->enc_capa = IW_ENC_CAPA_WPA |\n\t\t\t  IW_ENC_CAPA_WPA2 |\n\t\t\t  IW_ENC_CAPA_CIPHER_TKIP |\n\t\t\t  IW_ENC_CAPA_CIPHER_CCMP;\n\treturn 0;\n}\n\nstatic int r8711_wx_get_rate(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra);\n\nstatic int r871x_wx_set_priv(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *awrq,\n\t\t\t\tchar *extra)\n{\n\tint ret = 0, len = 0;\n\tchar *ext;\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct iw_point *dwrq = (struct iw_point *)awrq;\n\n\tlen = dwrq->length;\n\text = strndup_user(dwrq->pointer, len);\n\tif (IS_ERR(ext))\n\t\treturn PTR_ERR(ext);\n\n\tif (!strcasecmp(ext, \"RSSI\")) {\n\t\t \n\t\t \n\t\t \n\t\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\t\tstruct wlan_network *pcur_network = &pmlmepriv->cur_network;\n\t\t \n\t\tif (check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\t\tsprintf(ext, \"%s rssi %d\",\n\t\t\t\tpcur_network->network.Ssid.Ssid,\n\t\t\t\t \n\t\t\t\t((padapter->recvpriv.fw_rssi) >> 1) - 95\n\t\t\t\t \n\t\t\t\t);\n\t\t} else {\n\t\t\tsprintf(ext, \"OK\");\n\t\t}\n\t} else if (!strcasecmp(ext, \"LINKSPEED\")) {\n\t\t \n\t\t \n\t\tunion iwreq_data wrqd;\n\t\tint ret_inner;\n\t\tint mbps;\n\n\t\tret_inner = r8711_wx_get_rate(dev, info, &wrqd, extra);\n\t\tif (ret_inner != 0)\n\t\t\tmbps = 0;\n\t\telse\n\t\t\tmbps = wrqd.bitrate.value / 1000000;\n\t\tsprintf(ext, \"LINKSPEED %d\", mbps);\n\t} else if (!strcasecmp(ext, \"MACADDR\")) {\n\t\t \n\t\t \n\t\tsprintf(ext, \"MACADDR = %pM\", dev->dev_addr);\n\t} else if (!strcasecmp(ext, \"SCAN-ACTIVE\")) {\n\t\t \n\t\t \n\t\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\t\tpmlmepriv->passive_mode = 1;\n\t\tsprintf(ext, \"OK\");\n\t} else if (!strcasecmp(ext, \"SCAN-PASSIVE\")) {\n\t\t \n\t\t \n\t\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\t\tpmlmepriv->passive_mode = 0;\n\t\tsprintf(ext, \"OK\");\n\t} else if (!strncmp(ext, \"DCE-E\", 5)) {\n\t\t \n\t\t \n\t\tr8712_disconnectCtrlEx_cmd(padapter\n\t\t\t, 1  \n\t\t\t, 5  \n\t\t\t, 100  \n\t\t\t, 5000  \n\t\t);\n\t\tsprintf(ext, \"OK\");\n\t} else if (!strncmp(ext, \"DCE-D\", 5)) {\n\t\t \n\t\t \n\t\tr8712_disconnectCtrlEx_cmd(padapter\n\t\t\t, 0  \n\t\t\t, 5  \n\t\t\t, 100  \n\t\t\t, 5000  \n\t\t);\n\t\tsprintf(ext, \"OK\");\n\t} else {\n\t\tnetdev_info(dev, \"r8712u: %s: unknown Command %s.\\n\",\n\t\t\t    __func__, ext);\n\t\tgoto FREE_EXT;\n\t}\n\tif (copy_to_user(dwrq->pointer, ext,\n\t\t\t\tmin(dwrq->length, (__u16)(strlen(ext) + 1))))\n\t\tret = -EFAULT;\n\nFREE_EXT:\n\tkfree(ext);\n\treturn ret;\n}\n\n \nstatic int r8711_wx_set_wap(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *awrq,\n\t\t\t char *extra)\n{\n\tint ret = -EINPROGRESS;\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct  __queue *queue = &pmlmepriv->scanned_queue;\n\tstruct sockaddr *temp = (struct sockaddr *)awrq;\n\tunsigned long irqL;\n\tstruct list_head *phead;\n\tu8 *dst_bssid;\n\tstruct wlan_network *pnetwork = NULL;\n\tenum NDIS_802_11_AUTHENTICATION_MODE\tauthmode;\n\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))\n\t\treturn -EBUSY;\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))\n\t\treturn ret;\n\tif (temp->sa_family != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\tauthmode = padapter->securitypriv.ndisauthtype;\n\tspin_lock_irqsave(&queue->lock, irqL);\n\tphead = &queue->queue;\n\tpmlmepriv->pscanned = phead->next;\n\twhile (1) {\n\t\tif (end_of_queue_search(phead, pmlmepriv->pscanned))\n\t\t\tbreak;\n\t\tpnetwork = container_of(pmlmepriv->pscanned,\n\t\t\t\t\tstruct wlan_network, list);\n\t\tpmlmepriv->pscanned = pmlmepriv->pscanned->next;\n\t\tdst_bssid = pnetwork->network.MacAddress;\n\t\tif (!memcmp(dst_bssid, temp->sa_data, ETH_ALEN)) {\n\t\t\tr8712_set_802_11_infrastructure_mode(padapter,\n\t\t\t    pnetwork->network.InfrastructureMode);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&queue->lock, irqL);\n\tif (!ret) {\n\t\tif (!r8712_set_802_11_authentication_mode(padapter, authmode)) {\n\t\t\tret = -ENOMEM;\n\t\t} else {\n\t\t\tif (!r8712_set_802_11_bssid(padapter, temp->sa_data))\n\t\t\t\tret = -1;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int r8711_wx_get_wap(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\n\n\twrqu->ap_addr.sa_family = ARPHRD_ETHER;\n\tif (check_fwstate(pmlmepriv, _FW_LINKED | WIFI_ADHOC_MASTER_STATE |\n\t\t\t\t     WIFI_AP_STATE))\n\t\tether_addr_copy(wrqu->ap_addr.sa_data, pcur_bss->MacAddress);\n\telse\n\t\teth_zero_addr(wrqu->ap_addr.sa_data);\n\treturn 0;\n}\n\nstatic int r871x_wx_set_mlme(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tint ret = 0;\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct iw_mlme *mlme = (struct iw_mlme *) extra;\n\n\tif (!mlme)\n\t\treturn -1;\n\tswitch (mlme->cmd) {\n\tcase IW_MLME_DEAUTH:\n\t\tif (!r8712_set_802_11_disassociate(padapter))\n\t\t\tret = -1;\n\t\tbreak;\n\tcase IW_MLME_DISASSOC:\n\t\tif (!r8712_set_802_11_disassociate(padapter))\n\t\t\tret = -1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn ret;\n}\n\n \nstatic int r8711_wx_set_scan(struct net_device *dev,\n\t\t\tstruct iw_request_info *a,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tu8 status = true;\n\n\tif (padapter->driver_stopped) {\n\t\tnetdev_info(dev, \"In %s: driver_stopped=%d\\n\",\n\t\t\t    __func__, padapter->driver_stopped);\n\t\treturn -1;\n\t}\n\tif (!padapter->bup)\n\t\treturn -ENETDOWN;\n\tif (!padapter->hw_init_completed)\n\t\treturn -1;\n\tif ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY | _FW_UNDER_LINKING)) ||\n\t    (pmlmepriv->sitesurveyctrl.traffic_busy))\n\t\treturn 0;\n\tif (wrqu->data.length == sizeof(struct iw_scan_req)) {\n\t\tstruct iw_scan_req *req = (struct iw_scan_req *)extra;\n\n\t\tif (wrqu->data.flags & IW_SCAN_THIS_ESSID) {\n\t\t\tstruct ndis_802_11_ssid ssid;\n\t\t\tunsigned long irqL;\n\t\t\tu32 len = min_t(u8, req->essid_len, IW_ESSID_MAX_SIZE);\n\n\t\t\tmemset((unsigned char *)&ssid, 0,\n\t\t\t\t sizeof(struct ndis_802_11_ssid));\n\t\t\tmemcpy(ssid.Ssid, req->essid, len);\n\t\t\tssid.SsidLength = len;\n\t\t\tspin_lock_irqsave(&pmlmepriv->lock, irqL);\n\t\t\tif ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY |\n\t\t\t     _FW_UNDER_LINKING)) ||\n\t\t\t    (pmlmepriv->sitesurveyctrl.traffic_busy)) {\n\t\t\t\tif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))\n\t\t\t\t\tstatus = false;\n\t\t\t} else {\n\t\t\t\tstatus = r8712_sitesurvey_cmd(padapter, &ssid);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\n\t\t}\n\t} else {\n\t\tstatus = r8712_set_802_11_bssid_list_scan(padapter);\n\t}\n\tif (!status)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int r8711_wx_get_scan(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *a,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct  __queue *queue = &pmlmepriv->scanned_queue;\n\tstruct wlan_network *pnetwork = NULL;\n\tunsigned long irqL;\n\tstruct list_head *plist, *phead;\n\tchar *ev = extra;\n\tchar *stop = ev + wrqu->data.length;\n\tu32 ret = 0, cnt = 0;\n\n\tif (padapter->driver_stopped)\n\t\treturn -EINVAL;\n\twhile (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY |\n\t\t\t     _FW_UNDER_LINKING)) {\n\t\tmsleep(30);\n\t\tcnt++;\n\t\tif (cnt > 100)\n\t\t\tbreak;\n\t}\n\tspin_lock_irqsave(&queue->lock, irqL);\n\tphead = &queue->queue;\n\tplist = phead->next;\n\twhile (1) {\n\t\tif (end_of_queue_search(phead, plist))\n\t\t\tbreak;\n\t\tif ((stop - ev) < SCAN_ITEM_SIZE) {\n\t\t\tret = -E2BIG;\n\t\t\tbreak;\n\t\t}\n\t\tpnetwork = container_of(plist, struct wlan_network, list);\n\t\tev = translate_scan(padapter, a, pnetwork, ev, stop);\n\t\tplist = plist->next;\n\t}\n\tspin_unlock_irqrestore(&queue->lock, irqL);\n\twrqu->data.length = ev - extra;\n\twrqu->data.flags = 0;\n\treturn ret;\n}\n\n \nstatic int r8711_wx_set_essid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *a,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct  __queue *queue = &pmlmepriv->scanned_queue;\n\tstruct wlan_network *pnetwork = NULL;\n\tenum NDIS_802_11_AUTHENTICATION_MODE\tauthmode;\n\tstruct ndis_802_11_ssid ndis_ssid;\n\tu8 *dst_ssid, *src_ssid;\n\tstruct list_head *phead;\n\tu32 len;\n\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))\n\t\treturn -EBUSY;\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))\n\t\treturn 0;\n\tif (wrqu->essid.length > IW_ESSID_MAX_SIZE)\n\t\treturn -E2BIG;\n\tauthmode = padapter->securitypriv.ndisauthtype;\n\tif (wrqu->essid.flags && wrqu->essid.length) {\n\t\tlen = (wrqu->essid.length < IW_ESSID_MAX_SIZE) ?\n\t\t       wrqu->essid.length : IW_ESSID_MAX_SIZE;\n\t\tmemset(&ndis_ssid, 0, sizeof(struct ndis_802_11_ssid));\n\t\tndis_ssid.SsidLength = len;\n\t\tmemcpy(ndis_ssid.Ssid, extra, len);\n\t\tsrc_ssid = ndis_ssid.Ssid;\n\t\tphead = &queue->queue;\n\t\tpmlmepriv->pscanned = phead->next;\n\t\twhile (1) {\n\t\t\tif (end_of_queue_search(phead, pmlmepriv->pscanned))\n\t\t\t\tbreak;\n\t\t\tpnetwork = container_of(pmlmepriv->pscanned,\n\t\t\t\t\t\tstruct wlan_network, list);\n\t\t\tpmlmepriv->pscanned = pmlmepriv->pscanned->next;\n\t\t\tdst_ssid = pnetwork->network.Ssid.Ssid;\n\t\t\tif ((!memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength))\n\t\t\t    && (pnetwork->network.Ssid.SsidLength ==\n\t\t\t     ndis_ssid.SsidLength)) {\n\t\t\t\tif (check_fwstate(pmlmepriv,\n\t\t\t\t\t\t\tWIFI_ADHOC_STATE)) {\n\t\t\t\t\tif (pnetwork->network.\n\t\t\t\t\t\tInfrastructureMode\n\t\t\t\t\t\t!=\n\t\t\t\t\t\tpadapter->mlmepriv.\n\t\t\t\t\t\tcur_network.network.\n\t\t\t\t\t\tInfrastructureMode)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tr8712_set_802_11_infrastructure_mode(\n\t\t\t\t     padapter,\n\t\t\t\t     pnetwork->network.InfrastructureMode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tr8712_set_802_11_authentication_mode(padapter, authmode);\n\t\tr8712_set_802_11_ssid(padapter, &ndis_ssid);\n\t}\n\treturn -EINPROGRESS;\n}\n\nstatic int r8711_wx_get_essid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *a,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\n\tu32 len, ret = 0;\n\n\tif (check_fwstate(pmlmepriv, _FW_LINKED | WIFI_ADHOC_MASTER_STATE)) {\n\t\tlen = pcur_bss->Ssid.SsidLength;\n\t\twrqu->essid.length = len;\n\t\tmemcpy(extra, pcur_bss->Ssid.Ssid, len);\n\t\twrqu->essid.flags = 1;\n\t} else {\n\t\tret = -ENOLINK;\n\t}\n\treturn ret;\n}\n\nstatic int r8711_wx_set_rate(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *a,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tu32 target_rate = wrqu->bitrate.value;\n\tu32 fixed = wrqu->bitrate.fixed;\n\tu32 ratevalue = 0;\n\tu8 datarates[NumRates];\n\tu8 mpdatarate[NumRates] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};\n\tint i;\n\n\tif (target_rate == -1) {\n\t\tratevalue = 11;\n\t\tgoto set_rate;\n\t}\n\ttarget_rate = target_rate / 100000;\n\tswitch (target_rate) {\n\tcase 10:\n\t\tratevalue = 0;\n\t\tbreak;\n\tcase 20:\n\t\tratevalue = 1;\n\t\tbreak;\n\tcase 55:\n\t\tratevalue = 2;\n\t\tbreak;\n\tcase 60:\n\t\tratevalue = 3;\n\t\tbreak;\n\tcase 90:\n\t\tratevalue = 4;\n\t\tbreak;\n\tcase 110:\n\t\tratevalue = 5;\n\t\tbreak;\n\tcase 120:\n\t\tratevalue = 6;\n\t\tbreak;\n\tcase 180:\n\t\tratevalue = 7;\n\t\tbreak;\n\tcase 240:\n\t\tratevalue = 8;\n\t\tbreak;\n\tcase 360:\n\t\tratevalue = 9;\n\t\tbreak;\n\tcase 480:\n\t\tratevalue = 10;\n\t\tbreak;\n\tcase 540:\n\t\tratevalue = 11;\n\t\tbreak;\n\tdefault:\n\t\tratevalue = 11;\n\t\tbreak;\n\t}\nset_rate:\n\tfor (i = 0; i < NumRates; i++) {\n\t\tif (ratevalue == mpdatarate[i]) {\n\t\t\tdatarates[i] = mpdatarate[i];\n\t\t\tif (fixed == 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tdatarates[i] = 0xff;\n\t\t}\n\t}\n\treturn r8712_setdatarate_cmd(padapter, datarates);\n}\n\nstatic int r8711_wx_get_rate(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\n\tstruct ieee80211_ht_cap *pht_capie;\n\tunsigned char rf_type = padapter->registrypriv.rf_config;\n\tint i;\n\tu8 *p;\n\tu16 rate, max_rate = 0, ht_cap = false;\n\tu32 ht_ielen = 0;\n\tu8 bw_40MHz = 0, short_GI = 0;\n\tu16 mcs_rate = 0;\n\n\ti = 0;\n\tif (!check_fwstate(pmlmepriv, _FW_LINKED | WIFI_ADHOC_MASTER_STATE))\n\t\treturn -ENOLINK;\n\tp = r8712_get_ie(&pcur_bss->IEs[12], WLAN_EID_HT_CAPABILITY, &ht_ielen,\n\t\t\t pcur_bss->IELength - 12);\n\tif (p && ht_ielen > 0) {\n\t\tht_cap = true;\n\t\tpht_capie = (struct ieee80211_ht_cap *)(p + 2);\n\t\tmemcpy(&mcs_rate, &pht_capie->mcs, 2);\n\t\tbw_40MHz = (le16_to_cpu(pht_capie->cap_info) &\n\t\t\t    IEEE80211_HT_CAP_SUP_WIDTH_20_40) ? 1 : 0;\n\t\tshort_GI = (le16_to_cpu(pht_capie->cap_info) &\n\t\t\t    (IEEE80211_HT_CAP_SGI_20 |\n\t\t\t    IEEE80211_HT_CAP_SGI_40)) ? 1 : 0;\n\t}\n\twhile ((pcur_bss->rates[i] != 0) &&\n\t       (pcur_bss->rates[i] != 0xFF)) {\n\t\trate = pcur_bss->rates[i] & 0x7F;\n\t\tif (rate > max_rate)\n\t\t\tmax_rate = rate;\n\t\twrqu->bitrate.fixed = 0;\t \n\t\twrqu->bitrate.value = rate * 500000;\n\t\ti++;\n\t}\n\tif (ht_cap) {\n\t\tif (mcs_rate & 0x8000  \n\t\t    &&\n\t\t    rf_type == RTL8712_RF_2T2R)\n\t\t\tmax_rate = (bw_40MHz) ? ((short_GI) ? 300 : 270) :\n\t\t\t((short_GI) ? 144 : 130);\n\t\telse  \n\t\t\tmax_rate = (bw_40MHz) ? ((short_GI) ? 150 : 135) :\n\t\t\t((short_GI) ? 72 : 65);\n\t\tmax_rate *= 2;  \n\t}\n\twrqu->bitrate.value = max_rate * 500000;\n\treturn 0;\n}\n\nstatic int r8711_wx_get_rts(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\n\twrqu->rts.value = padapter->registrypriv.rts_thresh;\n\twrqu->rts.fixed = 0;\t \n\treturn 0;\n}\n\nstatic int r8711_wx_set_frag(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\n\tif (wrqu->frag.disabled) {\n\t\tpadapter->xmitpriv.frag_len = MAX_FRAG_THRESHOLD;\n\t} else {\n\t\tif (wrqu->frag.value < MIN_FRAG_THRESHOLD ||\n\t\t    wrqu->frag.value > MAX_FRAG_THRESHOLD)\n\t\t\treturn -EINVAL;\n\t\tpadapter->xmitpriv.frag_len = wrqu->frag.value & ~0x1;\n\t}\n\treturn 0;\n}\n\nstatic int r8711_wx_get_frag(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\n\twrqu->frag.value = padapter->xmitpriv.frag_len;\n\twrqu->frag.fixed = 0;\t \n\treturn 0;\n}\n\nstatic int r8711_wx_get_retry(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\twrqu->retry.value = 7;\n\twrqu->retry.fixed = 0;\t \n\twrqu->retry.disabled = 1;\n\treturn 0;\n}\n\nstatic int r8711_wx_set_enc(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *keybuf)\n{\n\tu32 key;\n\tu32 keyindex_provided;\n\tstruct NDIS_802_11_WEP\t wep;\n\tenum NDIS_802_11_AUTHENTICATION_MODE authmode;\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct _adapter *padapter = netdev_priv(dev);\n\n\tkey = erq->flags & IW_ENCODE_INDEX;\n\tmemset(&wep, 0, sizeof(struct NDIS_802_11_WEP));\n\tif (erq->flags & IW_ENCODE_DISABLED) {\n\t\tnetdev_info(dev, \"r8712u: %s: EncryptionDisabled\\n\", __func__);\n\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11EncryptionDisabled;\n\t\tpadapter->securitypriv.PrivacyAlgrthm = _NO_PRIVACY_;\n\t\tpadapter->securitypriv.XGrpPrivacy = _NO_PRIVACY_;\n\t\tpadapter->securitypriv.AuthAlgrthm = 0;  \n\t\tauthmode = Ndis802_11AuthModeOpen;\n\t\tpadapter->securitypriv.ndisauthtype = authmode;\n\t\treturn 0;\n\t}\n\tif (key) {\n\t\tif (key > WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tkey--;\n\t\tkeyindex_provided = 1;\n\t} else {\n\t\tkeyindex_provided = 0;\n\t\tkey = padapter->securitypriv.PrivacyKeyIndex;\n\t}\n\t \n\tif (erq->flags & IW_ENCODE_OPEN) {\n\t\tnetdev_info(dev, \"r8712u: %s: IW_ENCODE_OPEN\\n\", __func__);\n\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11Encryption1Enabled;\n\t\tpadapter->securitypriv.AuthAlgrthm = 0;  \n\t\tpadapter->securitypriv.PrivacyAlgrthm = _NO_PRIVACY_;\n\t\tpadapter->securitypriv.XGrpPrivacy = _NO_PRIVACY_;\n\t\tauthmode = Ndis802_11AuthModeOpen;\n\t\tpadapter->securitypriv.ndisauthtype = authmode;\n\t} else if (erq->flags & IW_ENCODE_RESTRICTED) {\n\t\tnetdev_info(dev,\n\t\t\t\t\"r8712u: %s: IW_ENCODE_RESTRICTED\\n\", __func__);\n\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11Encryption1Enabled;\n\t\tpadapter->securitypriv.AuthAlgrthm = 1;  \n\t\tpadapter->securitypriv.PrivacyAlgrthm = _WEP40_;\n\t\tpadapter->securitypriv.XGrpPrivacy = _WEP40_;\n\t\tauthmode = Ndis802_11AuthModeShared;\n\t\tpadapter->securitypriv.ndisauthtype = authmode;\n\t} else {\n\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t Ndis802_11Encryption1Enabled;\n\t\tpadapter->securitypriv.AuthAlgrthm = 0;  \n\t\tpadapter->securitypriv.PrivacyAlgrthm = _NO_PRIVACY_;\n\t\tpadapter->securitypriv.XGrpPrivacy = _NO_PRIVACY_;\n\t\tauthmode = Ndis802_11AuthModeOpen;\n\t\tpadapter->securitypriv.ndisauthtype = authmode;\n\t}\n\twep.KeyIndex = key;\n\tif (erq->length > 0) {\n\t\twep.KeyLength = erq->length <= 5 ? 5 : 13;\n\t\twep.Length = wep.KeyLength +\n\t\t\t     offsetof(struct NDIS_802_11_WEP, KeyMaterial);\n\t} else {\n\t\twep.KeyLength = 0;\n\t\tif (keyindex_provided == 1) {  \n\t\t\tpadapter->securitypriv.PrivacyKeyIndex = key;\n\t\t\tswitch (padapter->securitypriv.DefKeylen[key]) {\n\t\t\tcase 5:\n\t\t\t\tpadapter->securitypriv.PrivacyAlgrthm =\n\t\t\t\t\t\t _WEP40_;\n\t\t\t\tbreak;\n\t\t\tcase 13:\n\t\t\t\tpadapter->securitypriv.PrivacyAlgrthm =\n\t\t\t\t\t\t _WEP104_;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpadapter->securitypriv.PrivacyAlgrthm =\n\t\t\t\t\t\t _NO_PRIVACY_;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\twep.KeyIndex |= 0x80000000;\t \n\tmemcpy(wep.KeyMaterial, keybuf, wep.KeyLength);\n\tif (r8712_set_802_11_add_wep(padapter, &wep))\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n\nstatic int r8711_wx_get_enc(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *keybuf)\n{\n\tuint key;\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct\tmlme_priv\t*pmlmepriv = &padapter->mlmepriv;\n\tunion Keytype *dk = padapter->securitypriv.DefKey;\n\n\tif (!check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\tif (!check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\n\t\t\terq->length = 0;\n\t\t\terq->flags |= IW_ENCODE_DISABLED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tkey = erq->flags & IW_ENCODE_INDEX;\n\tif (key) {\n\t\tif (key > WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tkey--;\n\t} else {\n\t\tkey = padapter->securitypriv.PrivacyKeyIndex;\n\t}\n\terq->flags = key + 1;\n\tswitch (padapter->securitypriv.ndisencryptstatus) {\n\tcase Ndis802_11EncryptionNotSupported:\n\tcase Ndis802_11EncryptionDisabled:\n\t\terq->length = 0;\n\t\terq->flags |= IW_ENCODE_DISABLED;\n\t\tbreak;\n\tcase Ndis802_11Encryption1Enabled:\n\t\terq->length = padapter->securitypriv.DefKeylen[key];\n\t\tif (erq->length) {\n\t\t\tmemcpy(keybuf, dk[key].skey,\n\t\t\t       padapter->securitypriv.DefKeylen[key]);\n\t\t\terq->flags |= IW_ENCODE_ENABLED;\n\t\t\tif (padapter->securitypriv.ndisauthtype ==\n\t\t\t    Ndis802_11AuthModeOpen)\n\t\t\t\terq->flags |= IW_ENCODE_OPEN;\n\t\t\telse if (padapter->securitypriv.ndisauthtype ==\n\t\t\t\t Ndis802_11AuthModeShared)\n\t\t\t\terq->flags |= IW_ENCODE_RESTRICTED;\n\t\t} else {\n\t\t\terq->length = 0;\n\t\t\terq->flags |= IW_ENCODE_DISABLED;\n\t\t}\n\t\tbreak;\n\tcase Ndis802_11Encryption2Enabled:\n\tcase Ndis802_11Encryption3Enabled:\n\t\terq->length = 16;\n\t\terq->flags |= (IW_ENCODE_ENABLED | IW_ENCODE_OPEN |\n\t\t\t       IW_ENCODE_NOKEY);\n\t\tbreak;\n\tdefault:\n\t\terq->length = 0;\n\t\terq->flags |= IW_ENCODE_DISABLED;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int r8711_wx_get_power(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\twrqu->power.value = 0;\n\twrqu->power.fixed = 0;\t \n\twrqu->power.disabled = 1;\n\treturn 0;\n}\n\nstatic int r871x_wx_set_gen_ie(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\n\treturn r871x_set_wpa_ie(padapter, extra, wrqu->data.length);\n}\n\nstatic int r871x_wx_set_auth(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct iw_param *param = (struct iw_param *)&wrqu->param;\n\tint paramid;\n\tint paramval;\n\tint ret = 0;\n\n\tparamid = param->flags & IW_AUTH_INDEX;\n\tparamval = param->value;\n\tswitch (paramid) {\n\tcase IW_AUTH_WPA_VERSION:\n\t\tbreak;\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\t\tbreak;\n\tcase IW_AUTH_CIPHER_GROUP:\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\t \n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tif (paramval) {\n\t\t\t \n\t\t\tpadapter->securitypriv.btkip_countermeasure = true;\n\t\t} else {\n\t\t\t \n\t\t\tpadapter->securitypriv.btkip_countermeasure = false;\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\t \n\t\tif (padapter->securitypriv.ndisencryptstatus ==\n\t\t    Ndis802_11Encryption1Enabled) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tif (paramval) {\n\t\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\t   Ndis802_11EncryptionDisabled;\n\t\t\tpadapter->securitypriv.PrivacyAlgrthm =\n\t\t\t\t  _NO_PRIVACY_;\n\t\t\tpadapter->securitypriv.XGrpPrivacy =\n\t\t\t\t  _NO_PRIVACY_;\n\t\t\tpadapter->securitypriv.AuthAlgrthm = 0;\n\t\t\tpadapter->securitypriv.ndisauthtype =\n\t\t\t\t  Ndis802_11AuthModeOpen;\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tret = wpa_set_auth_algs(dev, (u32)paramval);\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tbreak;\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\t\tbreak;\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int r871x_wx_set_enc_ext(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *pencoding = &wrqu->encoding;\n\tstruct iw_encode_ext *pext = (struct iw_encode_ext *)extra;\n\tstruct ieee_param *param = NULL;\n\tchar *alg_name;\n\tu32 param_len;\n\tint ret = 0;\n\n\tswitch (pext->alg) {\n\tcase IW_ENCODE_ALG_NONE:\n\t\talg_name = \"none\";\n\t\tbreak;\n\tcase IW_ENCODE_ALG_WEP:\n\t\talg_name = \"WEP\";\n\t\tbreak;\n\tcase IW_ENCODE_ALG_TKIP:\n\t\talg_name = \"TKIP\";\n\t\tbreak;\n\tcase IW_ENCODE_ALG_CCMP:\n\t\talg_name = \"CCMP\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tparam_len = sizeof(struct ieee_param) + pext->key_len;\n\tparam = kzalloc(param_len, GFP_ATOMIC);\n\tif (!param)\n\t\treturn -ENOMEM;\n\tparam->cmd = IEEE_CMD_SET_ENCRYPTION;\n\teth_broadcast_addr(param->sta_addr);\n\tstrscpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);\n\tif (pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)\n\t\tparam->u.crypt.set_tx = 0;\n\tif (pext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)\n\t\tparam->u.crypt.set_tx = 1;\n\tparam->u.crypt.idx = (pencoding->flags & 0x00FF) - 1;\n\tif (pext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)\n\t\tmemcpy(param->u.crypt.seq, pext->rx_seq, 8);\n\tif (pext->key_len) {\n\t\tparam->u.crypt.key_len = pext->key_len;\n\t\tmemcpy(param + 1, pext + 1, pext->key_len);\n\t}\n\tret = wpa_set_encryption(dev, param, param_len);\n\tkfree(param);\n\treturn ret;\n}\n\nstatic int r871x_wx_get_nick(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tif (extra) {\n\t\twrqu->data.length = 8;\n\t\twrqu->data.flags = 1;\n\t\tmemcpy(extra, \"rtl_wifi\", 8);\n\t}\n\treturn 0;\n}\n\nstatic int r8711_wx_read32(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *keybuf)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tu32 addr;\n\tu32 data32;\n\n\tget_user(addr, (u32 __user *)wrqu->data.pointer);\n\tdata32 = r8712_read32(padapter, addr);\n\tput_user(data32, (u32 __user *)wrqu->data.pointer);\n\twrqu->data.length = (data32 & 0xffff0000) >> 16;\n\twrqu->data.flags = data32 & 0xffff;\n\tget_user(addr, (u32 __user *)wrqu->data.pointer);\n\treturn 0;\n}\n\nstatic int r8711_wx_write32(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *keybuf)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tu32 addr;\n\tu32 data32;\n\n\tget_user(addr, (u32 __user *)wrqu->data.pointer);\n\tdata32 = ((u32)wrqu->data.length << 16) | (u32)wrqu->data.flags;\n\tr8712_write32(padapter, addr, data32);\n\treturn 0;\n}\n\nstatic int dummy(struct net_device *dev,\n\t\tstruct iw_request_info *a,\n\t\tunion iwreq_data *wrqu, char *b)\n{\n\treturn -EINVAL;\n}\n\nstatic int r8711_drvext_hdl(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\treturn 0;\n}\n\nstatic int r871x_mp_ioctl_hdl(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct iw_point *p = &wrqu->data;\n\tstruct oid_par_priv oid_par;\n\tstruct mp_ioctl_handler *phandler;\n\tstruct mp_ioctl_param *poidparam;\n\tunsigned long BytesRead, BytesWritten, BytesNeeded;\n\tu8 *pparmbuf, bset;\n\tu16 len;\n\tuint status;\n\tint ret = 0;\n\n\tif ((!p->length) || (!p->pointer))\n\t\treturn -EINVAL;\n\n\tbset = (u8)(p->flags & 0xFFFF);\n\tlen = p->length;\n\tpparmbuf = memdup_user(p->pointer, len);\n\tif (IS_ERR(pparmbuf))\n\t\treturn PTR_ERR(pparmbuf);\n\n\tpoidparam = (struct mp_ioctl_param *)pparmbuf;\n\tif (poidparam->subcode >= MAX_MP_IOCTL_SUBCODE) {\n\t\tret = -EINVAL;\n\t\tgoto _r871x_mp_ioctl_hdl_exit;\n\t}\n\tphandler = mp_ioctl_hdl + poidparam->subcode;\n\tif ((phandler->paramsize != 0) &&\n\t    (poidparam->len < phandler->paramsize)) {\n\t\tret = -EINVAL;\n\t\tgoto _r871x_mp_ioctl_hdl_exit;\n\t}\n\tif (phandler->oid == 0 && phandler->handler) {\n\t\tstatus = phandler->handler(&oid_par);\n\t} else if (phandler->handler) {\n\t\toid_par.adapter_context = padapter;\n\t\toid_par.oid = phandler->oid;\n\t\toid_par.information_buf = poidparam->data;\n\t\toid_par.information_buf_len = poidparam->len;\n\t\toid_par.dbg = 0;\n\t\tBytesWritten = 0;\n\t\tBytesNeeded = 0;\n\t\tif (bset) {\n\t\t\toid_par.bytes_rw = &BytesRead;\n\t\t\toid_par.bytes_needed = &BytesNeeded;\n\t\t\toid_par.type_of_oid = SET_OID;\n\t\t} else {\n\t\t\toid_par.bytes_rw = &BytesWritten;\n\t\t\toid_par.bytes_needed = &BytesNeeded;\n\t\t\toid_par.type_of_oid = QUERY_OID;\n\t\t}\n\t\tstatus = phandler->handler(&oid_par);\n\t\t \n\t} else {\n\t\tnetdev_info(dev, \"r8712u: %s: err!, subcode=%d, oid=%d, handler=%p\\n\",\n\t\t\t    __func__, poidparam->subcode, phandler->oid,\n\t\t\t    phandler->handler);\n\t\tret = -EFAULT;\n\t\tgoto _r871x_mp_ioctl_hdl_exit;\n\t}\n\tif (bset == 0x00) {  \n\t\tif (copy_to_user(p->pointer, pparmbuf, len))\n\t\t\tret = -EFAULT;\n\t}\n\tif (status) {\n\t\tret = -EFAULT;\n\t\tgoto _r871x_mp_ioctl_hdl_exit;\n\t}\n_r871x_mp_ioctl_hdl_exit:\n\tkfree(pparmbuf);\n\treturn ret;\n}\n\nstatic int r871x_get_ap_info(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct  __queue *queue = &pmlmepriv->scanned_queue;\n\tstruct iw_point *pdata = &wrqu->data;\n\tstruct wlan_network *pnetwork = NULL;\n\tu32 cnt = 0, wpa_ielen;\n\tunsigned long irqL;\n\tstruct list_head *plist, *phead;\n\tunsigned char *pbuf;\n\tu8 bssid[ETH_ALEN];\n\tchar data[33];\n\n\tif (padapter->driver_stopped || !pdata)\n\t\treturn -EINVAL;\n\twhile (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY |\n\t\t\t     _FW_UNDER_LINKING)) {\n\t\tmsleep(30);\n\t\tcnt++;\n\t\tif (cnt > 100)\n\t\t\tbreak;\n\t}\n\tpdata->flags = 0;\n\tif (pdata->length < 32)\n\t\treturn -EINVAL;\n\tif (copy_from_user(data, pdata->pointer, 32))\n\t\treturn -EINVAL;\n\tdata[32] = 0;\n\n\tspin_lock_irqsave(&pmlmepriv->scanned_queue.lock, irqL);\n\tphead = &queue->queue;\n\tplist = phead->next;\n\twhile (1) {\n\t\tif (end_of_queue_search(phead, plist))\n\t\t\tbreak;\n\t\tpnetwork = container_of(plist, struct wlan_network, list);\n\t\tif (!mac_pton(data, bssid)) {\n\t\t\tnetdev_info(dev, \"r8712u: Invalid BSSID '%s'.\\n\",\n\t\t\t\t    (u8 *)data);\n\t\t\tspin_unlock_irqrestore(&pmlmepriv->scanned_queue.lock,\n\t\t\t\t\t       irqL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tnetdev_info(dev, \"r8712u: BSSID:%pM\\n\", bssid);\n\t\tif (ether_addr_equal(bssid, pnetwork->network.MacAddress)) {\n\t\t\t \n\t\t\tpbuf = r8712_get_wpa_ie(&pnetwork->network.IEs[12],\n\t\t\t       &wpa_ielen, pnetwork->network.IELength - 12);\n\t\t\tif (pbuf && (wpa_ielen > 0)) {\n\t\t\t\tpdata->flags = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpbuf = r8712_get_wpa2_ie(&pnetwork->network.IEs[12],\n\t\t\t       &wpa_ielen, pnetwork->network.IELength - 12);\n\t\t\tif (pbuf && (wpa_ielen > 0)) {\n\t\t\t\tpdata->flags = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tplist = plist->next;\n\t}\n\tspin_unlock_irqrestore(&pmlmepriv->scanned_queue.lock, irqL);\n\tif (pdata->length >= 34) {\n\t\tif (copy_to_user((u8 __user *)pdata->pointer + 32,\n\t\t    (u8 *)&pdata->flags, 1))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int r871x_set_pid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct iw_point *pdata = &wrqu->data;\n\n\tif (padapter->driver_stopped || !pdata)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&padapter->pid, pdata->pointer, sizeof(int)))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int r871x_set_chplan(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tint ret = 0;\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct iw_point *pdata = &wrqu->data;\n\tint ch_plan = -1;\n\n\tif (padapter->driver_stopped || !pdata) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\tch_plan = (int)*extra;\n\tr8712_set_chplan_cmd(padapter, ch_plan);\n\nexit:\n\n\treturn ret;\n}\n\nstatic int r871x_wps_start(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct iw_point *pdata = &wrqu->data;\n\tu32   u32wps_start = 0;\n\n\tif (padapter->driver_stopped || !pdata)\n\t\treturn -EINVAL;\n\tif (copy_from_user((void *)&u32wps_start, pdata->pointer, 4))\n\t\treturn -EFAULT;\n\tif (u32wps_start == 0)\n\t\tu32wps_start = *extra;\n\tif (u32wps_start == 1)  \n\t\tpadapter->ledpriv.LedControlHandler(padapter,\n\t\t\t   LED_CTL_START_WPS);\n\telse if (u32wps_start == 2)  \n\t\tpadapter->ledpriv.LedControlHandler(padapter,\n\t\t\t   LED_CTL_STOP_WPS);\n\telse if (u32wps_start == 3)  \n\t\tpadapter->ledpriv.LedControlHandler(padapter,\n\t\t\t   LED_CTL_STOP_WPS_FAIL);\n\treturn 0;\n}\n\nstatic int wpa_set_param(struct net_device *dev, u8 name, u32 value)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\n\tswitch (name) {\n\tcase IEEE_PARAM_WPA_ENABLED:\n\t\tpadapter->securitypriv.AuthAlgrthm = 2;  \n\t\tswitch ((value) & 0xff) {\n\t\tcase 1:  \n\t\t\tpadapter->securitypriv.ndisauthtype =\n\t\t\t\tNdis802_11AuthModeWPAPSK;  \n\t\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\tNdis802_11Encryption2Enabled;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tpadapter->securitypriv.ndisauthtype =\n\t\t\t\tNdis802_11AuthModeWPA2PSK;  \n\t\t\tpadapter->securitypriv.ndisencryptstatus =\n\t\t\t\tNdis802_11Encryption3Enabled;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IEEE_PARAM_TKIP_COUNTERMEASURES:\n\t\tbreak;\n\tcase IEEE_PARAM_DROP_UNENCRYPTED:\n\t\t \n\t\tbreak;\n\tcase IEEE_PARAM_PRIVACY_INVOKED:\n\t\tbreak;\n\tcase IEEE_PARAM_AUTH_ALGS:\n\t\treturn wpa_set_auth_algs(dev, value);\n\tcase IEEE_PARAM_IEEE_802_1X:\n\t\tbreak;\n\tcase IEEE_PARAM_WPAX_SELECT:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int wpa_mlme(struct net_device *dev, u32 command, u32 reason)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\n\tswitch (command) {\n\tcase IEEE_MLME_STA_DEAUTH:\n\t\tif (!r8712_set_802_11_disassociate(padapter))\n\t\t\treturn -1;\n\t\tbreak;\n\tcase IEEE_MLME_STA_DISASSOC:\n\t\tif (!r8712_set_802_11_disassociate(padapter))\n\t\t\treturn -1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)\n{\n\tstruct ieee_param *param;\n\tint ret = 0;\n\tstruct _adapter *padapter = netdev_priv(dev);\n\n\tif (p->length < sizeof(struct ieee_param) || !p->pointer)\n\t\treturn -EINVAL;\n\tparam = memdup_user(p->pointer, p->length);\n\tif (IS_ERR(param))\n\t\treturn PTR_ERR(param);\n\tswitch (param->cmd) {\n\tcase IEEE_CMD_SET_WPA_PARAM:\n\t\tret = wpa_set_param(dev, param->u.wpa_param.name,\n\t\t      param->u.wpa_param.value);\n\t\tbreak;\n\tcase IEEE_CMD_SET_WPA_IE:\n\t\tret =  r871x_set_wpa_ie(padapter, (char *)param->u.wpa_ie.data,\n\t\t       (u16)param->u.wpa_ie.len);\n\t\tbreak;\n\tcase IEEE_CMD_SET_ENCRYPTION:\n\t\tret = wpa_set_encryption(dev, param, p->length);\n\t\tbreak;\n\tcase IEEE_CMD_MLME:\n\t\tret = wpa_mlme(dev, param->u.mlme.command,\n\t\t      param->u.mlme.reason_code);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tif (ret == 0 && copy_to_user(p->pointer, param, p->length))\n\t\tret = -EFAULT;\n\tkfree(param);\n\treturn ret;\n}\n\n \nint r871x_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct iwreq *wrq = (struct iwreq *)rq;\n\n\tswitch (cmd) {\n\tcase RTL_IOCTL_WPA_SUPPLICANT:\n\t\treturn wpa_supplicant_ioctl(dev, &wrq->u.data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic iw_handler r8711_handlers[] = {\n\tNULL,\t\t\t\t \n\tr8711_wx_get_name,\t\t \n\tdummy,\t\t\t\t \n\tdummy,\t\t\t\t \n\tr8711_wx_set_freq,\t\t \n\tr8711_wx_get_freq,\t\t \n\tr8711_wx_set_mode,\t\t \n\tr8711_wx_get_mode,\t\t \n\tdummy,\t\t\t\t \n\tr8711_wx_get_sens,\t\t \n\tNULL,\t\t\t\t \n\tr8711_wx_get_range,\t\t \n\tr871x_wx_set_priv,\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tdummy,\t\t\t\t \n\tdummy,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tr8711_wx_set_wap,\t\t \n\tr8711_wx_get_wap,\t\t \n\tr871x_wx_set_mlme,\t\t \n\tdummy,\t\t\t\t \n\tr8711_wx_set_scan,\t\t \n\tr8711_wx_get_scan,\t\t \n\tr8711_wx_set_essid,\t\t \n\tr8711_wx_get_essid,\t\t \n\tdummy,\t\t\t\t \n\tr871x_wx_get_nick,\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tr8711_wx_set_rate,\t\t \n\tr8711_wx_get_rate,\t\t \n\tdummy,\t\t\t\t \n\tr8711_wx_get_rts,\t\t \n\tr8711_wx_set_frag,\t\t \n\tr8711_wx_get_frag,\t\t \n\tdummy,\t\t\t\t \n\tdummy,\t\t\t\t \n\tdummy,\t\t\t\t \n\tr8711_wx_get_retry,\t\t \n\tr8711_wx_set_enc,\t\t \n\tr8711_wx_get_enc,\t\t \n\tdummy,\t\t\t\t \n\tr8711_wx_get_power,\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tr871x_wx_set_gen_ie,\t\t \n\tNULL,\t\t\t\t \n\tr871x_wx_set_auth,\t\t \n\tNULL,\t\t\t\t \n\tr871x_wx_set_enc_ext,\t\t \n\tNULL,\t\t\t\t \n\tr871x_wx_set_pmkid,\t\t \n\tNULL,\t\t\t\t \n};\n\nstatic const struct iw_priv_args r8711_private_args[] = {\n\t{\n\t\tSIOCIWFIRSTPRIV + 0x0,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"read32\"\n\t},\n\t{\n\t\tSIOCIWFIRSTPRIV + 0x1,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"write32\"\n\t},\n\t{\n\t\tSIOCIWFIRSTPRIV + 0x2, 0, 0, \"driver_ext\"\n\t},\n\t{\n\t\tSIOCIWFIRSTPRIV + 0x3, 0, 0, \"mp_ioctl\"\n\t},\n\t{\n\t\tSIOCIWFIRSTPRIV + 0x4,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"apinfo\"\n\t},\n\t{\n\t\tSIOCIWFIRSTPRIV + 0x5,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"setpid\"\n\t},\n\t{\n\t\tSIOCIWFIRSTPRIV + 0x6,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"wps_start\"\n\t},\n\t{\n\t\tSIOCIWFIRSTPRIV + 0x7,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"chplan\"\n\t}\n};\n\nstatic iw_handler r8711_private_handler[] = {\n\tr8711_wx_read32,\n\tr8711_wx_write32,\n\tr8711_drvext_hdl,\n\tr871x_mp_ioctl_hdl,\n\tr871x_get_ap_info,  \n\tr871x_set_pid,\n\tr871x_wps_start,\n\tr871x_set_chplan\n};\n\nstatic struct iw_statistics *r871x_get_wireless_stats(struct net_device *dev)\n{\n\tstruct _adapter *padapter = netdev_priv(dev);\n\tstruct iw_statistics *piwstats = &padapter->iwstats;\n\tint tmp_level = 0;\n\tint tmp_qual = 0;\n\tint tmp_noise = 0;\n\n\tif (check_fwstate(&padapter->mlmepriv, _FW_LINKED) != true) {\n\t\tpiwstats->qual.qual = 0;\n\t\tpiwstats->qual.level = 0;\n\t\tpiwstats->qual.noise = 0;\n\t} else {\n\t\t \n\t\ttmp_level = padapter->recvpriv.fw_rssi;\n\t\ttmp_qual = padapter->recvpriv.signal;\n\t\ttmp_noise = padapter->recvpriv.noise;\n\t\tpiwstats->qual.level = tmp_level;\n\t\tpiwstats->qual.qual = tmp_qual;\n\t\tpiwstats->qual.noise = tmp_noise;\n\t}\n\tpiwstats->qual.updated = IW_QUAL_ALL_UPDATED;\n\treturn &padapter->iwstats;\n}\n\nstruct iw_handler_def r871x_handlers_def = {\n\t.standard = r8711_handlers,\n\t.num_standard = ARRAY_SIZE(r8711_handlers),\n\t.private = r8711_private_handler,\n\t.private_args = (struct iw_priv_args *)r8711_private_args,\n\t.num_private = ARRAY_SIZE(r8711_private_handler),\n\t.num_private_args = sizeof(r8711_private_args) /\n\t\t\t    sizeof(struct iw_priv_args),\n\t.get_wireless_stats = r871x_get_wireless_stats\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}