{
  "module_name": "usb_ops_linux.c",
  "hash_id": "4322c9d960fb1a3f6d974bdff810567721bf34a4610986f19f1c1debd5ef5847",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/usb_ops_linux.c",
  "human_readable_source": "\n \n\n#define _HCI_OPS_OS_C_\n\n#include <linux/usb.h>\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"osdep_intf.h\"\n#include \"usb_ops.h\"\n\n#define\tRTL871X_VENQT_READ\t0xc0\n#define\tRTL871X_VENQT_WRITE\t0x40\n\nstruct zero_bulkout_context {\n\tvoid *pbuf;\n\tvoid *purb;\n\tvoid *pirp;\n\tvoid *padapter;\n};\n\nuint r8712_usb_init_intf_priv(struct intf_priv *pintfpriv)\n{\n\tpintfpriv->piorw_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!pintfpriv->piorw_urb)\n\t\treturn _FAIL;\n\tinit_completion(&pintfpriv->io_retevt_comp);\n\treturn _SUCCESS;\n}\n\nvoid r8712_usb_unload_intf_priv(struct intf_priv *pintfpriv)\n{\n\tif (pintfpriv->piorw_urb) {\n\t\tusb_kill_urb(pintfpriv->piorw_urb);\n\t\tusb_free_urb(pintfpriv->piorw_urb);\n\t}\n}\n\nstatic unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr)\n{\n\tunsigned int pipe = 0;\n\tstruct usb_device *pusbd = pdvobj->pusbdev;\n\n\tif (pdvobj->nr_endpoint == 11) {\n\t\tswitch (addr) {\n\t\tcase RTL8712_DMA_BKQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x07);\n\t\t\tbreak;\n\t\tcase RTL8712_DMA_BEQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x06);\n\t\t\tbreak;\n\t\tcase RTL8712_DMA_VIQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x05);\n\t\t\tbreak;\n\t\tcase RTL8712_DMA_VOQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x04);\n\t\t\tbreak;\n\t\tcase RTL8712_DMA_BCNQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x0a);\n\t\t\tbreak;\n\t\tcase RTL8712_DMA_BMCQ:\t \n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x0b);\n\t\t\tbreak;\n\t\tcase RTL8712_DMA_MGTQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x0c);\n\t\t\tbreak;\n\t\tcase RTL8712_DMA_RX0FF:\n\t\t\tpipe = usb_rcvbulkpipe(pusbd, 0x03);  \n\t\t\tbreak;\n\t\tcase RTL8712_DMA_C2HCMD:\n\t\t\tpipe = usb_rcvbulkpipe(pusbd, 0x09);  \n\t\t\tbreak;\n\t\tcase RTL8712_DMA_H2CCMD:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x0d);\n\t\t\tbreak;\n\t\t}\n\t} else if (pdvobj->nr_endpoint == 6) {\n\t\tswitch (addr) {\n\t\tcase RTL8712_DMA_BKQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x07);\n\t\t\tbreak;\n\t\tcase RTL8712_DMA_BEQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x06);\n\t\t\tbreak;\n\t\tcase RTL8712_DMA_VIQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x05);\n\t\t\tbreak;\n\t\tcase RTL8712_DMA_VOQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x04);\n\t\t\tbreak;\n\t\tcase RTL8712_DMA_RX0FF:\n\t\tcase RTL8712_DMA_C2HCMD:\n\t\t\tpipe = usb_rcvbulkpipe(pusbd, 0x03);  \n\t\t\tbreak;\n\t\tcase RTL8712_DMA_H2CCMD:\n\t\tcase RTL8712_DMA_BCNQ:\n\t\tcase RTL8712_DMA_BMCQ:\n\t\tcase RTL8712_DMA_MGTQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x0d);\n\t\t\tbreak;\n\t\t}\n\t} else if (pdvobj->nr_endpoint == 4) {\n\t\tswitch (addr) {\n\t\tcase RTL8712_DMA_BEQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x06);\n\t\t\tbreak;\n\t\tcase RTL8712_DMA_VOQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x04);\n\t\t\tbreak;\n\t\tcase RTL8712_DMA_RX0FF:\n\t\tcase RTL8712_DMA_C2HCMD:\n\t\t\tpipe = usb_rcvbulkpipe(pusbd, 0x03);  \n\t\t\tbreak;\n\t\tcase RTL8712_DMA_H2CCMD:\n\t\tcase RTL8712_DMA_BCNQ:\n\t\tcase RTL8712_DMA_BMCQ:\n\t\tcase RTL8712_DMA_MGTQ:\n\t\t\tpipe = usb_sndbulkpipe(pusbd, 0x0d);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tpipe = 0;\n\t}\n\treturn pipe;\n}\n\nstatic void usb_write_mem_complete(struct urb *purb)\n{\n\tstruct io_queue *pio_q = (struct io_queue *)purb->context;\n\tstruct intf_hdl *pintf = &(pio_q->intf);\n\tstruct intf_priv *pintfpriv = pintf->pintfpriv;\n\tstruct _adapter *padapter = (struct _adapter *)pintf->adapter;\n\n\tif (purb->status != 0) {\n\t\tif (purb->status == (-ESHUTDOWN))\n\t\t\tpadapter->driver_stopped = true;\n\t\telse\n\t\t\tpadapter->surprise_removed = true;\n\t}\n\tcomplete(&pintfpriv->io_retevt_comp);\n}\n\nvoid r8712_usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)\n{\n\tunsigned int pipe;\n\tstruct _adapter *padapter = (struct _adapter *)pintfhdl->adapter;\n\tstruct intf_priv *pintfpriv = pintfhdl->pintfpriv;\n\tstruct io_queue *pio_queue = padapter->pio_queue;\n\tstruct dvobj_priv *pdvobj = (struct dvobj_priv *)pintfpriv->intf_dev;\n\tstruct usb_device *pusbd = pdvobj->pusbdev;\n\tstruct urb *piorw_urb = pintfpriv->piorw_urb;\n\n\tif ((padapter->driver_stopped) || (padapter->surprise_removed) ||\n\t    (padapter->pwrctrlpriv.pnp_bstop_trx))\n\t\treturn;\n\t \n\tpipe = ffaddr2pipehdl(pdvobj, addr);\n\tif (pipe == 0)\n\t\treturn;\n\tusb_fill_bulk_urb(piorw_urb, pusbd, pipe,\n\t\t\t  wmem, cnt, usb_write_mem_complete,\n\t\t\t  pio_queue);\n\tusb_submit_urb(piorw_urb, GFP_ATOMIC);\n\twait_for_completion_interruptible(&pintfpriv->io_retevt_comp);\n}\n\nstatic void r8712_usb_read_port_complete(struct urb *purb)\n{\n\tuint isevt;\n\t__le32 *pbuf;\n\tstruct recv_buf\t*precvbuf = (struct recv_buf *)purb->context;\n\tstruct _adapter *padapter = (struct _adapter *)precvbuf->adapter;\n\tstruct recv_priv *precvpriv = &padapter->recvpriv;\n\n\tif (padapter->surprise_removed || padapter->driver_stopped)\n\t\treturn;\n\tif (purb->status == 0) {  \n\t\tif ((purb->actual_length > (MAX_RECVBUF_SZ)) ||\n\t\t    (purb->actual_length < RXDESC_SIZE)) {\n\t\t\tr8712_read_port(padapter, precvpriv->ff_hwaddr, 0,\n\t\t\t\t  (unsigned char *)precvbuf);\n\t\t} else {\n\t\t\t_pkt *pskb = precvbuf->pskb;\n\n\t\t\tprecvbuf->transfer_len = purb->actual_length;\n\t\t\tpbuf = (__le32 *)precvbuf->pbuf;\n\t\t\tisevt = le32_to_cpu(*(pbuf + 1)) & 0x1ff;\n\t\t\tif ((isevt & 0x1ff) == 0x1ff) {\n\t\t\t\tr8712_rxcmd_event_hdl(padapter, pbuf);\n\t\t\t\tskb_queue_tail(&precvpriv->rx_skb_queue, pskb);\n\t\t\t\tr8712_read_port(padapter, precvpriv->ff_hwaddr,\n\t\t\t\t\t\t0, (unsigned char *)precvbuf);\n\t\t\t} else {\n\t\t\t\tskb_put(pskb, purb->actual_length);\n\t\t\t\tskb_queue_tail(&precvpriv->rx_skb_queue, pskb);\n\t\t\t\ttasklet_hi_schedule(&precvpriv->recv_tasklet);\n\t\t\t\tr8712_read_port(padapter, precvpriv->ff_hwaddr,\n\t\t\t\t\t\t0, (unsigned char *)precvbuf);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tswitch (purb->status) {\n\t\tcase -EINVAL:\n\t\tcase -EPIPE:\n\t\tcase -ENODEV:\n\t\tcase -ESHUTDOWN:\n\t\t\tpadapter->driver_stopped = true;\n\t\t\tbreak;\n\t\tcase -ENOENT:\n\t\t\tif (!padapter->suspended) {\n\t\t\t\tpadapter->driver_stopped = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase -EPROTO:\n\t\t\tr8712_read_port(padapter, precvpriv->ff_hwaddr, 0,\n\t\t\t\t  (unsigned char *)precvbuf);\n\t\t\tbreak;\n\t\tcase -EINPROGRESS:\n\t\t\tnetdev_err(padapter->pnetdev, \"ERROR: URB IS IN PROGRESS!\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nu32 r8712_usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)\n{\n\tunsigned int pipe;\n\tint err;\n\tu32 tmpaddr = 0;\n\tint alignment = 0;\n\tu32 ret = _SUCCESS;\n\tstruct urb *purb = NULL;\n\tstruct recv_buf\t*precvbuf = (struct recv_buf *)rmem;\n\tstruct intf_priv *pintfpriv = pintfhdl->pintfpriv;\n\tstruct dvobj_priv *pdvobj = (struct dvobj_priv *)pintfpriv->intf_dev;\n\tstruct _adapter *adapter = pdvobj->padapter;\n\tstruct recv_priv *precvpriv = &adapter->recvpriv;\n\tstruct usb_device *pusbd = pdvobj->pusbdev;\n\n\tif (adapter->driver_stopped || adapter->surprise_removed ||\n\t    adapter->pwrctrlpriv.pnp_bstop_trx || !precvbuf)\n\t\treturn _FAIL;\n\tr8712_init_recvbuf(adapter, precvbuf);\n\t \n\tprecvbuf->pskb = skb_dequeue(&precvpriv->free_recv_skb_queue);\n\n\tif (!precvbuf->pskb) {\n\t\tprecvbuf->pskb = netdev_alloc_skb(adapter->pnetdev,\n\t\t\t\t MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);\n\t\tif (!precvbuf->pskb)\n\t\t\treturn _FAIL;\n\t\ttmpaddr = (addr_t)precvbuf->pskb->data;\n\t\talignment = tmpaddr & (RECVBUFF_ALIGN_SZ - 1);\n\t\tskb_reserve(precvbuf->pskb,\n\t\t\t    (RECVBUFF_ALIGN_SZ - alignment));\n\t\tprecvbuf->phead = precvbuf->pskb->head;\n\t\tprecvbuf->pdata = precvbuf->pskb->data;\n\t\tprecvbuf->ptail = skb_tail_pointer(precvbuf->pskb);\n\t\tprecvbuf->pend = skb_end_pointer(precvbuf->pskb);\n\t\tprecvbuf->pbuf = precvbuf->pskb->data;\n\t} else {  \n\t\tprecvbuf->phead = precvbuf->pskb->head;\n\t\tprecvbuf->pdata = precvbuf->pskb->data;\n\t\tprecvbuf->ptail = skb_tail_pointer(precvbuf->pskb);\n\t\tprecvbuf->pend = skb_end_pointer(precvbuf->pskb);\n\t\tprecvbuf->pbuf = precvbuf->pskb->data;\n\t}\n\tpurb = precvbuf->purb;\n\t \n\tpipe = ffaddr2pipehdl(pdvobj, addr);\n\tusb_fill_bulk_urb(purb, pusbd, pipe,\n\t\t\t  precvbuf->pbuf, MAX_RECVBUF_SZ,\n\t\t\t  r8712_usb_read_port_complete,\n\t\t\t  precvbuf);\n\terr = usb_submit_urb(purb, GFP_ATOMIC);\n\tif ((err) && (err != (-EPERM)))\n\t\tret = _FAIL;\n\treturn ret;\n}\n\nvoid r8712_usb_read_port_cancel(struct _adapter *padapter)\n{\n\tint i;\n\tstruct recv_buf *precvbuf;\n\n\tprecvbuf = (struct recv_buf *)padapter->recvpriv.precv_buf;\n\tfor (i = 0; i < NR_RECVBUFF; i++) {\n\t\tif (precvbuf->purb)\n\t\t\tusb_kill_urb(precvbuf->purb);\n\t\tprecvbuf++;\n\t}\n}\n\nvoid r8712_xmit_bh(struct tasklet_struct *t)\n{\n\tint ret = false;\n\tstruct _adapter *padapter = from_tasklet(padapter, t,\n\t\t\t\t\t\t xmitpriv.xmit_tasklet);\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tif (padapter->driver_stopped ||\n\t    padapter->surprise_removed) {\n\t\tnetdev_err(padapter->pnetdev, \"xmit_bh => driver_stopped or surprise_removed\\n\");\n\t\treturn;\n\t}\n\tret = r8712_xmitframe_complete(padapter, pxmitpriv, NULL);\n\tif (!ret)\n\t\treturn;\n\ttasklet_hi_schedule(&pxmitpriv->xmit_tasklet);\n}\n\nstatic void usb_write_port_complete(struct urb *purb)\n{\n\tint i;\n\tstruct xmit_frame *pxmitframe = (struct xmit_frame *)purb->context;\n\tstruct xmit_buf *pxmitbuf = pxmitframe->pxmitbuf;\n\tstruct _adapter *padapter = pxmitframe->padapter;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct pkt_attrib *pattrib = &pxmitframe->attrib;\n\n\tswitch (pattrib->priority) {\n\tcase 1:\n\tcase 2:\n\t\tpxmitpriv->bkq_cnt--;\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tpxmitpriv->viq_cnt--;\n\t\tbreak;\n\tcase 6:\n\tcase 7:\n\t\tpxmitpriv->voq_cnt--;\n\t\tbreak;\n\tcase 0:\n\tcase 3:\n\tdefault:\n\t\tpxmitpriv->beq_cnt--;\n\t\tbreak;\n\t}\n\tpxmitpriv->txirp_cnt--;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (purb == pxmitframe->pxmit_urb[i]) {\n\t\t\tpxmitframe->bpending[i] = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (padapter->surprise_removed)\n\t\treturn;\n\tswitch (purb->status) {\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(padapter->pnetdev,\n\t\t\t\t\"r8712u: pipe error: (%d)\\n\", purb->status);\n\t\tbreak;\n\t}\n\t \n\tr8712_free_xmitframe_ex(pxmitpriv, pxmitframe);\n\tr8712_free_xmitbuf(pxmitpriv, pxmitbuf);\n\ttasklet_hi_schedule(&pxmitpriv->xmit_tasklet);\n}\n\nu32 r8712_usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)\n{\n\tunsigned long irqL;\n\tint i, status;\n\tunsigned int pipe;\n\tu32 ret, bwritezero;\n\tstruct urb *purb = NULL;\n\tstruct _adapter *padapter = (struct _adapter *)pintfhdl->adapter;\n\tstruct dvobj_priv *pdvobj = &padapter->dvobjpriv;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct xmit_frame *pxmitframe = (struct xmit_frame *)wmem;\n\tstruct usb_device *pusbd = pdvobj->pusbdev;\n\tstruct pkt_attrib *pattrib = &pxmitframe->attrib;\n\n\tif ((padapter->driver_stopped) || (padapter->surprise_removed) ||\n\t    (padapter->pwrctrlpriv.pnp_bstop_trx))\n\t\treturn _FAIL;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (!pxmitframe->bpending[i]) {\n\t\t\tspin_lock_irqsave(&pxmitpriv->lock, irqL);\n\t\t\tpxmitpriv->txirp_cnt++;\n\t\t\tpxmitframe->bpending[i]  = true;\n\t\t\tswitch (pattrib->priority) {\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\t\tpxmitpriv->bkq_cnt++;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\t\tpxmitpriv->viq_cnt++;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\t\tpxmitpriv->voq_cnt++;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase 3:\n\t\t\tdefault:\n\t\t\t\tpxmitpriv->beq_cnt++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&pxmitpriv->lock, irqL);\n\t\t\tpxmitframe->sz[i] = (u16)cnt;\n\t\t\tpurb = pxmitframe->pxmit_urb[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tbwritezero = false;\n\tif (pdvobj->ishighspeed) {\n\t\tif (cnt > 0 && cnt % 512 == 0)\n\t\t\tbwritezero = true;\n\t} else {\n\t\tif (cnt > 0 && cnt % 64 == 0)\n\t\t\tbwritezero = true;\n\t}\n\t \n\tpipe = ffaddr2pipehdl(pdvobj, addr);\n\tif (pxmitpriv->free_xmitbuf_cnt % NR_XMITBUFF == 0)\n\t\tpurb->transfer_flags  &=  (~URB_NO_INTERRUPT);\n\telse\n\t\tpurb->transfer_flags  |=  URB_NO_INTERRUPT;\n\tif (bwritezero)\n\t\tcnt += 8;\n\tusb_fill_bulk_urb(purb, pusbd, pipe,\n\t\t\t  pxmitframe->mem_addr,\n\t\t\t  cnt, usb_write_port_complete,\n\t\t\t  pxmitframe);  \n\tstatus = usb_submit_urb(purb, GFP_ATOMIC);\n\tif (!status)\n\t\tret = _SUCCESS;\n\telse\n\t\tret = _FAIL;\n\treturn ret;\n}\n\nvoid r8712_usb_write_port_cancel(struct _adapter *padapter)\n{\n\tint i, j;\n\tstruct xmit_buf\t*pxmitbuf = (struct xmit_buf *)\n\t\t\t\t     padapter->xmitpriv.pxmitbuf;\n\n\tfor (i = 0; i < NR_XMITBUFF; i++) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif (pxmitbuf->pxmit_urb[j])\n\t\t\t\tusb_kill_urb(pxmitbuf->pxmit_urb[j]);\n\t\t}\n\t\tpxmitbuf++;\n\t}\n}\n\nint r8712_usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value,\n\t\t      u16 index, void *pdata, u16 len, u8 requesttype)\n{\n\tunsigned int pipe;\n\tint status;\n\tu8 reqtype;\n\tstruct dvobj_priv *pdvobjpriv = (struct dvobj_priv *)\n\t\t\t\t\t pintfpriv->intf_dev;\n\tstruct usb_device *udev = pdvobjpriv->pusbdev;\n\t \n\tu8 *palloc_buf, *pIo_buf;\n\n\tpalloc_buf = kmalloc((u32)len + 16, GFP_ATOMIC);\n\tif (!palloc_buf)\n\t\treturn -ENOMEM;\n\tpIo_buf = palloc_buf + 16 - ((addr_t)(palloc_buf) & 0x0f);\n\tif (requesttype == 0x01) {\n\t\tpipe = usb_rcvctrlpipe(udev, 0);  \n\t\treqtype =  RTL871X_VENQT_READ;\n\t} else {\n\t\tpipe = usb_sndctrlpipe(udev, 0);  \n\t\treqtype =  RTL871X_VENQT_WRITE;\n\t\tmemcpy(pIo_buf, pdata, len);\n\t}\n\tstatus = usb_control_msg(udev, pipe, request, reqtype, value, index,\n\t\t\t\t pIo_buf, len, 500);\n\tif (status < 0)\n\t\tgoto free;\n\tif (status != len) {\n\t\tstatus = -EREMOTEIO;\n\t\tgoto free;\n\t}\n\t \n\tif (requesttype == 0x01) {\n\t\t \n\t\tmemcpy(pdata, pIo_buf, status);\n\t}\n\nfree:\n\tkfree(palloc_buf);\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}