{
  "module_name": "rtl871x_pwrctrl.c",
  "hash_id": "cf08ecfaf7c689f5ec6c6378687d07693c1bc9086371d02144e80973f59a7715",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/rtl871x_pwrctrl.c",
  "human_readable_source": "\n \n\n#define _RTL871X_PWRCTRL_C_\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"osdep_intf.h\"\n\n#define RTL8712_SDIO_LOCAL_BASE 0X10100000\n#define SDIO_HCPWM (RTL8712_SDIO_LOCAL_BASE + 0x0081)\n\nvoid r8712_set_rpwm(struct _adapter *padapter, u8 val8)\n{\n\tu8\trpwm;\n\tstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\n\n\tif (pwrpriv->rpwm == val8) {\n\t\tif (pwrpriv->rpwm_retry == 0)\n\t\t\treturn;\n\t}\n\tif (padapter->driver_stopped || padapter->surprise_removed)\n\t\treturn;\n\trpwm = val8 | pwrpriv->tog;\n\tswitch (val8) {\n\tcase PS_STATE_S1:\n\t\tpwrpriv->cpwm = val8;\n\t\tbreak;\n\tcase PS_STATE_S2: \n\tcase PS_STATE_S3:\n\tcase PS_STATE_S4:\n\t\tpwrpriv->cpwm = val8;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tpwrpriv->rpwm_retry = 0;\n\tpwrpriv->rpwm = val8;\n\tr8712_write8(padapter, 0x1025FE58, rpwm);\n\tpwrpriv->tog += 0x80;\n}\n\nvoid r8712_set_ps_mode(struct _adapter *padapter, uint ps_mode, uint smart_ps)\n{\n\tstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\n\n\tif (ps_mode > PM_Card_Disable)\n\t\treturn;\n\t \n\tif (ps_mode == PS_MODE_ACTIVE)\n\t\tsmart_ps = 0;\n\tif ((pwrpriv->pwr_mode != ps_mode) || (pwrpriv->smart_ps != smart_ps)) {\n\t\tif (pwrpriv->pwr_mode == PS_MODE_ACTIVE)\n\t\t\tpwrpriv->bSleep = true;\n\t\telse\n\t\t\tpwrpriv->bSleep = false;\n\t\tpwrpriv->pwr_mode = ps_mode;\n\t\tpwrpriv->smart_ps = smart_ps;\n\t\tschedule_work(&pwrpriv->SetPSModeWorkItem);\n\t}\n}\n\n \nvoid r8712_cpwm_int_hdl(struct _adapter *padapter,\n\t\t\tstruct reportpwrstate_parm *preportpwrstate)\n{\n\tstruct pwrctrl_priv *pwrpriv = &(padapter->pwrctrlpriv);\n\tstruct cmd_priv\t*pcmdpriv = &(padapter->cmdpriv);\n\n\tif (pwrpriv->cpwm_tog == ((preportpwrstate->state) & 0x80))\n\t\treturn;\n\tdel_timer(&padapter->pwrctrlpriv.rpwm_check_timer);\n\tmutex_lock(&pwrpriv->mutex_lock);\n\tpwrpriv->cpwm = (preportpwrstate->state) & 0xf;\n\tif (pwrpriv->cpwm >= PS_STATE_S2) {\n\t\tif (pwrpriv->alives & CMD_ALIVE)\n\t\t\tcomplete(&(pcmdpriv->cmd_queue_comp));\n\t}\n\tpwrpriv->cpwm_tog = (preportpwrstate->state) & 0x80;\n\tmutex_unlock(&pwrpriv->mutex_lock);\n}\n\nstatic inline void register_task_alive(struct pwrctrl_priv *pwrctrl, uint tag)\n{\n\t\tpwrctrl->alives |= tag;\n}\n\nstatic inline void unregister_task_alive(struct pwrctrl_priv *pwrctrl, uint tag)\n{\n\tif (pwrctrl->alives & tag)\n\t\tpwrctrl->alives ^= tag;\n}\n\nstatic void _rpwm_check_handler (struct _adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\n\n\tif (padapter->driver_stopped || padapter->surprise_removed)\n\t\treturn;\n\tif (pwrpriv->cpwm != pwrpriv->rpwm)\n\t\tschedule_work(&pwrpriv->rpwm_workitem);\n}\n\nstatic void SetPSModeWorkItemCallback(struct work_struct *work)\n{\n\tstruct pwrctrl_priv *pwrpriv = container_of(work,\n\t\t\t\t       struct pwrctrl_priv, SetPSModeWorkItem);\n\tstruct _adapter *padapter = container_of(pwrpriv,\n\t\t\t\t    struct _adapter, pwrctrlpriv);\n\tif (!pwrpriv->bSleep) {\n\t\tmutex_lock(&pwrpriv->mutex_lock);\n\t\tif (pwrpriv->pwr_mode == PS_MODE_ACTIVE)\n\t\t\tr8712_set_rpwm(padapter, PS_STATE_S4);\n\t\tmutex_unlock(&pwrpriv->mutex_lock);\n\t}\n}\n\nstatic void rpwm_workitem_callback(struct work_struct *work)\n{\n\tstruct pwrctrl_priv *pwrpriv = container_of(work,\n\t\t\t\t       struct pwrctrl_priv, rpwm_workitem);\n\tstruct _adapter *padapter = container_of(pwrpriv,\n\t\t\t\t    struct _adapter, pwrctrlpriv);\n\tif (pwrpriv->cpwm != pwrpriv->rpwm) {\n\t\tmutex_lock(&pwrpriv->mutex_lock);\n\t\tr8712_read8(padapter, SDIO_HCPWM);\n\t\tpwrpriv->rpwm_retry = 1;\n\t\tr8712_set_rpwm(padapter, pwrpriv->rpwm);\n\t\tmutex_unlock(&pwrpriv->mutex_lock);\n\t}\n}\n\nstatic void rpwm_check_handler (struct timer_list *t)\n{\n\tstruct _adapter *adapter =\n\t\tfrom_timer(adapter, t, pwrctrlpriv.rpwm_check_timer);\n\n\t_rpwm_check_handler(adapter);\n}\n\nvoid r8712_init_pwrctrl_priv(struct _adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;\n\n\tmemset((unsigned char *)pwrctrlpriv, 0, sizeof(struct pwrctrl_priv));\n\tmutex_init(&pwrctrlpriv->mutex_lock);\n\tpwrctrlpriv->cpwm = PS_STATE_S4;\n\tpwrctrlpriv->pwr_mode = PS_MODE_ACTIVE;\n\tpwrctrlpriv->smart_ps = 0;\n\tpwrctrlpriv->tog = 0x80;\n \n\tr8712_write8(padapter, 0x1025FE58, 0);\n\tINIT_WORK(&pwrctrlpriv->SetPSModeWorkItem, SetPSModeWorkItemCallback);\n\tINIT_WORK(&pwrctrlpriv->rpwm_workitem, rpwm_workitem_callback);\n\ttimer_setup(&pwrctrlpriv->rpwm_check_timer, rpwm_check_handler, 0);\n}\n\n \nint r8712_register_cmd_alive(struct _adapter *padapter)\n{\n\tint res = 0;\n\tstruct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;\n\n\tmutex_lock(&pwrctrl->mutex_lock);\n\tregister_task_alive(pwrctrl, CMD_ALIVE);\n\tif (pwrctrl->cpwm < PS_STATE_S2) {\n\t\tr8712_set_rpwm(padapter, PS_STATE_S3);\n\t\tres = -EINVAL;\n\t}\n\tmutex_unlock(&pwrctrl->mutex_lock);\n\treturn res;\n}\n\n \nvoid r8712_unregister_cmd_alive(struct _adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;\n\n\tmutex_lock(&pwrctrl->mutex_lock);\n\tunregister_task_alive(pwrctrl, CMD_ALIVE);\n\tif ((pwrctrl->cpwm > PS_STATE_S2) &&\n\t   (pwrctrl->pwr_mode > PS_MODE_ACTIVE)) {\n\t\tif ((pwrctrl->alives == 0) &&\n\t\t    (check_fwstate(&padapter->mlmepriv,\n\t\t     _FW_UNDER_LINKING) != true)) {\n\t\t\tr8712_set_rpwm(padapter, PS_STATE_S0);\n\t\t}\n\t}\n\tmutex_unlock(&pwrctrl->mutex_lock);\n}\n\nvoid r8712_flush_rwctrl_works(struct _adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;\n\n\tflush_work(&pwrctrl->SetPSModeWorkItem);\n\tflush_work(&pwrctrl->rpwm_workitem);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}