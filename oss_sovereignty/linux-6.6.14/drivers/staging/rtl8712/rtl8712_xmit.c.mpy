{
  "module_name": "rtl8712_xmit.c",
  "hash_id": "c3271b7d8406994162ceeb4a934f064b0a31b8a6fb7b424e9281c5fa2059dd9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/rtl8712_xmit.c",
  "human_readable_source": "\n \n\n#define _RTL8712_XMIT_C_\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"wifi.h\"\n#include \"osdep_intf.h\"\n#include \"usb_ops.h\"\n\nstatic void dump_xframe(struct _adapter *padapter,\n\t\t\tstruct xmit_frame *pxmitframe);\nstatic void update_txdesc(struct xmit_frame *pxmitframe, uint *pmem, int sz);\n\nsint _r8712_init_hw_txqueue(struct hw_txqueue *phw_txqueue, u8 ac_tag)\n{\n\tphw_txqueue->ac_tag = ac_tag;\n\tswitch (ac_tag) {\n\tcase BE_QUEUE_INX:\n\t\tphw_txqueue->ff_hwaddr = RTL8712_DMA_BEQ;\n\t\tbreak;\n\tcase BK_QUEUE_INX:\n\t\tphw_txqueue->ff_hwaddr = RTL8712_DMA_BKQ;\n\t\tbreak;\n\tcase VI_QUEUE_INX:\n\t\tphw_txqueue->ff_hwaddr = RTL8712_DMA_VIQ;\n\t\tbreak;\n\tcase VO_QUEUE_INX:\n\t\tphw_txqueue->ff_hwaddr = RTL8712_DMA_VOQ;\n\t\tbreak;\n\tcase BMC_QUEUE_INX:\n\t\tphw_txqueue->ff_hwaddr = RTL8712_DMA_BEQ;\n\t\tbreak;\n\t}\n\treturn _SUCCESS;\n}\n\nint r8712_txframes_sta_ac_pending(struct _adapter *padapter,\n\t\t\t\t  struct pkt_attrib *pattrib)\n{\n\tstruct sta_info *psta;\n\tstruct tx_servq *ptxservq;\n\tint priority = pattrib->priority;\n\n\tpsta = pattrib->psta;\n\tswitch (priority) {\n\tcase 1:\n\tcase 2:\n\t\tptxservq = &psta->sta_xmitpriv.bk_q;\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tptxservq = &psta->sta_xmitpriv.vi_q;\n\t\tbreak;\n\tcase 6:\n\tcase 7:\n\t\tptxservq = &psta->sta_xmitpriv.vo_q;\n\t\tbreak;\n\tcase 0:\n\tcase 3:\n\tdefault:\n\t\tptxservq = &psta->sta_xmitpriv.be_q;\n\tbreak;\n\t}\n\treturn ptxservq->qcnt;\n}\n\nstatic u32 get_ff_hwaddr(struct xmit_frame *pxmitframe)\n{\n\tu32 addr = 0;\n\tstruct pkt_attrib *pattrib = &pxmitframe->attrib;\n\tstruct _adapter *padapter = pxmitframe->padapter;\n\tstruct dvobj_priv *pdvobj = &padapter->dvobjpriv;\n\n\tif (pxmitframe->frame_tag == TXAGG_FRAMETAG) {\n\t\taddr = RTL8712_DMA_H2CCMD;\n\t} else if (pxmitframe->frame_tag == MGNT_FRAMETAG) {\n\t\taddr = RTL8712_DMA_MGTQ;\n\t} else if (pdvobj->nr_endpoint == 6) {\n\t\tswitch (pattrib->priority) {\n\t\tcase 0:\n\t\tcase 3:\n\t\t\taddr = RTL8712_DMA_BEQ;\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\t\taddr = RTL8712_DMA_BKQ;\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\t\taddr = RTL8712_DMA_VIQ;\n\t\t\tbreak;\n\t\tcase 6:\n\t\tcase 7:\n\t\t\taddr = RTL8712_DMA_VOQ;\n\t\t\tbreak;\n\t\tcase 0x10:\n\t\tcase 0x11:\n\t\tcase 0x12:\n\t\tcase 0x13:\n\t\t\taddr = RTL8712_DMA_H2CCMD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\taddr = RTL8712_DMA_BEQ;\n\t\t\tbreak;\n\t\t}\n\t} else if (pdvobj->nr_endpoint == 4) {\n\t\tswitch (pattrib->qsel) {\n\t\tcase 0:\n\t\tcase 3:\n\t\tcase 1:\n\t\tcase 2:\n\t\t\taddr = RTL8712_DMA_BEQ; \n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\t\taddr = RTL8712_DMA_VOQ; \n\t\t\tbreak;\n\t\tcase 0x10:\n\t\tcase 0x11:\n\t\tcase 0x12:\n\t\tcase 0x13:\n\t\t\taddr = RTL8712_DMA_H2CCMD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\taddr = RTL8712_DMA_BEQ; \n\t\t\tbreak;\n\t\t}\n\t}\n\treturn addr;\n}\n\nstatic struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv,\n\t\t\t\t\t struct hw_xmit *phwxmit,\n\t\t\t\t\t struct tx_servq *ptxservq,\n\t\t\t\t\t struct  __queue *pframe_queue)\n{\n\tstruct list_head *xmitframe_plist, *xmitframe_phead;\n\tstruct\txmit_frame *pxmitframe = NULL;\n\n\txmitframe_phead = &pframe_queue->queue;\n\txmitframe_plist = xmitframe_phead->next;\n\tif (!end_of_queue_search(xmitframe_phead, xmitframe_plist)) {\n\t\tpxmitframe = container_of(xmitframe_plist,\n\t\t\t\t\t  struct xmit_frame, list);\n\t\tlist_del_init(&pxmitframe->list);\n\t\tptxservq->qcnt--;\n\t\tphwxmit->txcmdcnt++;\n\t}\n\treturn pxmitframe;\n}\n\nstatic struct xmit_frame *dequeue_xframe_ex(struct xmit_priv *pxmitpriv,\n\t\t\t\t     struct hw_xmit *phwxmit_i, sint entry)\n{\n\tunsigned long irqL0;\n\tstruct list_head *sta_plist, *sta_phead;\n\tstruct hw_xmit *phwxmit;\n\tstruct tx_servq *ptxservq = NULL;\n\tstruct  __queue *pframe_queue = NULL;\n\tstruct\txmit_frame *pxmitframe = NULL;\n\tint i, inx[4];\n\tint j, acirp_cnt[4];\n\n\t \n\tinx[0] = 0; acirp_cnt[0] = pxmitpriv->voq_cnt;\n\tinx[1] = 1; acirp_cnt[1] = pxmitpriv->viq_cnt;\n\tinx[2] = 2; acirp_cnt[2] = pxmitpriv->beq_cnt;\n\tinx[3] = 3; acirp_cnt[3] = pxmitpriv->bkq_cnt;\n\tfor (i = 0; i < 4; i++) {\n\t\tfor (j = i + 1; j < 4; j++) {\n\t\t\tif (acirp_cnt[j] < acirp_cnt[i]) {\n\t\t\t\tswap(acirp_cnt[i], acirp_cnt[j]);\n\t\t\t\tswap(inx[i], inx[j]);\n\t\t\t}\n\t\t}\n\t}\n\tspin_lock_irqsave(&pxmitpriv->lock, irqL0);\n\tfor (i = 0; i < entry; i++) {\n\t\tphwxmit = phwxmit_i + inx[i];\n\t\tsta_phead = &phwxmit->sta_queue->queue;\n\t\tsta_plist = sta_phead->next;\n\t\twhile (!end_of_queue_search(sta_phead, sta_plist)) {\n\t\t\tptxservq = container_of(sta_plist, struct tx_servq,\n\t\t\t\t\t\ttx_pending);\n\t\t\tpframe_queue = &ptxservq->sta_pending;\n\t\t\tpxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit,\n\t\t\t\t     ptxservq, pframe_queue);\n\t\t\tif (pxmitframe) {\n\t\t\t\tphwxmit->accnt--;\n\t\t\t\tgoto exit_dequeue_xframe_ex;\n\t\t\t}\n\t\t\tsta_plist = sta_plist->next;\n\t\t\t \n\t\t\tif (list_empty(&pframe_queue->queue)) {\n\t\t\t\t \n\t\t\t\tlist_del_init(&ptxservq->tx_pending);\n\t\t\t}\n\t\t}\n\t}\nexit_dequeue_xframe_ex:\n\tspin_unlock_irqrestore(&pxmitpriv->lock, irqL0);\n\treturn pxmitframe;\n}\n\nvoid r8712_do_queue_select(struct _adapter *padapter,\n\t\t\t   struct pkt_attrib *pattrib)\n{\n\tunsigned int qsel = 0;\n\tstruct dvobj_priv *pdvobj = &padapter->dvobjpriv;\n\n\tif (pdvobj->nr_endpoint == 6) {\n\t\tqsel = (unsigned int)pattrib->priority;\n\t} else if (pdvobj->nr_endpoint == 4) {\n\t\tqsel = (unsigned int)pattrib->priority;\n\t\tif (qsel == 0 || qsel == 3)\n\t\t\tqsel = 3;\n\t\telse if (qsel == 1 || qsel == 2)\n\t\t\tqsel = 1;\n\t\telse if (qsel == 4 || qsel == 5)\n\t\t\tqsel = 5;\n\t\telse if (qsel == 6 || qsel == 7)\n\t\t\tqsel = 7;\n\t\telse\n\t\t\tqsel = 3;\n\t}\n\tpattrib->qsel = qsel;\n}\n\n#ifdef CONFIG_R8712_TX_AGGR\nvoid r8712_construct_txaggr_cmd_desc(struct xmit_buf *pxmitbuf)\n{\n\tstruct tx_desc *ptx_desc = (struct tx_desc *)pxmitbuf->pbuf;\n\n\t \n\t \n\tptx_desc->txdw0 = cpu_to_le32(CMD_HDR_SZ & 0xffff);\n\tptx_desc->txdw0 |=\n\t\tcpu_to_le32(((TXDESC_SIZE + OFFSET_SZ) << OFFSET_SHT) &\n\t\t\t    0x00ff0000);\n\tptx_desc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);\n\n\t \n\tptx_desc->txdw1 |= cpu_to_le32((0x13 << QSEL_SHT) & 0x00001f00);\n}\n\nvoid r8712_construct_txaggr_cmd_hdr(struct xmit_buf *pxmitbuf)\n{\n\tstruct xmit_frame *pxmitframe = (struct xmit_frame *)\n\t\tpxmitbuf->priv_data;\n\tstruct _adapter *padapter = pxmitframe->padapter;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tstruct cmd_hdr *pcmd_hdr = (struct cmd_hdr  *)\n\t\t(pxmitbuf->pbuf + TXDESC_SIZE);\n\n\t \n\t \n\tpcmd_hdr->cmd_dw0 = cpu_to_le32((GEN_CMD_CODE(_AMSDU_TO_AMPDU) << 16) |\n\t\t\t\t\t(pcmdpriv->cmd_seq << 24));\n\tpcmdpriv->cmd_seq++;\n}\n\nvoid r8712_append_mpdu_unit(struct xmit_buf *pxmitbuf,\n\t\t\t    struct xmit_frame *pxmitframe)\n{\n\tstruct _adapter *padapter = pxmitframe->padapter;\n\tstruct tx_desc *ptx_desc = (struct tx_desc *)pxmitbuf->pbuf;\n\tint last_txcmdsz = 0;\n\tint padding_sz = 0;\n\n\t \n\tr8712_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);\n\t \n\tr8712_xmit_complete(padapter, pxmitframe);\n\tif (pxmitframe->attrib.ether_type != 0x0806) {\n\t\tif ((pxmitframe->attrib.ether_type != 0x888e) &&\n\t\t\t(pxmitframe->attrib.dhcp_pkt != 1)) {\n\t\t\tr8712_issue_addbareq_cmd(padapter,\n\t\t\t\t\tpxmitframe->attrib.priority);\n\t\t}\n\t}\n\tpxmitframe->last[0] = 1;\n\tupdate_txdesc(pxmitframe, (uint *)(pxmitframe->buf_addr),\n\t\tpxmitframe->attrib.last_txcmdsz);\n\t \n\tlast_txcmdsz = pxmitframe->attrib.last_txcmdsz;\n\tpadding_sz = (8 - (last_txcmdsz % 8));\n\tif ((last_txcmdsz % 8) != 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < padding_sz; i++)\n\t\t\t*(pxmitframe->buf_addr + TXDESC_SIZE + last_txcmdsz +\n\t\t\t  i) = 0;\n\t}\n\t \n\tptx_desc->txdw0 = cpu_to_le32((ptx_desc->txdw0 & 0xffff0000) |\n\t\t((ptx_desc->txdw0 & 0x0000ffff) +\n\t\t\t((TXDESC_SIZE + last_txcmdsz + padding_sz) &\n\t\t\t 0x0000ffff)));\n}\n\nvoid r8712_xmitframe_aggr_1st(struct xmit_buf *pxmitbuf,\n\t\t\t      struct xmit_frame *pxmitframe)\n{\n\t \n\tpxmitframe->pxmitbuf = pxmitbuf;\n\tpxmitbuf->priv_data = pxmitframe;\n\tpxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];\n\t \n\tpxmitframe->buf_addr = pxmitbuf->pbuf + TXDESC_SIZE + CMD_HDR_SZ;\n\t \n\tr8712_construct_txaggr_cmd_desc(pxmitbuf);\n\tr8712_construct_txaggr_cmd_hdr(pxmitbuf);\n\tr8712_append_mpdu_unit(pxmitbuf, pxmitframe);\n\tpxmitbuf->aggr_nr = 1;\n}\n\nu16 r8712_xmitframe_aggr_next(struct xmit_buf *pxmitbuf,\n\t\t\tstruct xmit_frame *pxmitframe)\n{\n\tpxmitframe->pxmitbuf = pxmitbuf;\n\tpxmitbuf->priv_data = pxmitframe;\n\tpxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];\n\t \n\tpxmitframe->buf_addr = pxmitbuf->pbuf + TXDESC_SIZE +\n\t\t(((struct tx_desc *)pxmitbuf->pbuf)->txdw0 & 0x0000ffff);\n\tr8712_append_mpdu_unit(pxmitbuf, pxmitframe);\n\tr8712_free_xmitframe_ex(&pxmitframe->padapter->xmitpriv,\n\t\t\t\tpxmitframe);\n\tpxmitbuf->aggr_nr++;\n\n\treturn TXDESC_SIZE +\n\t\t(((struct tx_desc *)pxmitbuf->pbuf)->txdw0 & 0x0000ffff);\n}\n\nvoid r8712_dump_aggr_xframe(struct xmit_buf *pxmitbuf,\n\t\t\t    struct xmit_frame *pxmitframe)\n{\n\tstruct _adapter *padapter = pxmitframe->padapter;\n\tstruct dvobj_priv *pdvobj = &padapter->dvobjpriv;\n\tstruct tx_desc *ptxdesc = pxmitbuf->pbuf;\n\tstruct cmd_hdr *pcmd_hdr = (struct cmd_hdr *)\n\t\t(pxmitbuf->pbuf + TXDESC_SIZE);\n\tu16 total_length = (u16)(ptxdesc->txdw0 & 0xffff);\n\n\t \n\txmitframe_xmitbuf_attach(pxmitframe, pxmitbuf);\n\tpcmd_hdr->cmd_dw0 = cpu_to_le32(((total_length - CMD_HDR_SZ) &\n\t\t\t\t\t 0x0000ffff) | (pcmd_hdr->cmd_dw0 &\n\t\t\t\t\t\t\t0xffff0000));\n\n\t \n\tpcmd_hdr->cmd_dw1 = cpu_to_le32((pxmitbuf->aggr_nr & 0xff) |\n\t\t\t\t\t((total_length + TXDESC_SIZE) << 16));\n\tpxmitframe->last[0] = 1;\n\tpxmitframe->bpending[0] = false;\n\tpxmitframe->mem_addr = pxmitbuf->pbuf;\n\n\tif ((pdvobj->ishighspeed && ((total_length + TXDESC_SIZE) % 0x200) ==\n\t     0) || ((!pdvobj->ishighspeed && ((total_length + TXDESC_SIZE) %\n\t\t\t\t\t      0x40) == 0))) {\n\t\tptxdesc->txdw0 |= cpu_to_le32\n\t\t\t(((TXDESC_SIZE + OFFSET_SZ + 8) << OFFSET_SHT) &\n\t\t\t 0x00ff0000);\n\t\t \n\t} else {\n\t\tptxdesc->txdw0 |= cpu_to_le32\n\t\t\t(((TXDESC_SIZE + OFFSET_SZ) << OFFSET_SHT) &\n\t\t\t 0x00ff0000);\n\t\t \n\t}\n\tr8712_write_port(pxmitframe->padapter, RTL8712_DMA_H2CCMD,\n\t\t\ttotal_length + TXDESC_SIZE, (u8 *)pxmitframe);\n}\n\n#endif\n\nstatic void update_txdesc(struct xmit_frame *pxmitframe, uint *pmem, int sz)\n{\n\tuint qsel;\n\tstruct _adapter *padapter = pxmitframe->padapter;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tstruct pkt_attrib *pattrib = &pxmitframe->attrib;\n\tstruct tx_desc *ptxdesc = (struct tx_desc *)pmem;\n\tstruct dvobj_priv *pdvobj = &padapter->dvobjpriv;\n#ifdef CONFIG_R8712_TX_AGGR\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n#endif\n\tu8 blnSetTxDescOffset;\n\tbool bmcst = is_multicast_ether_addr(pattrib->ra);\n\tstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\n\tstruct tx_desc txdesc_mp;\n\n\tmemcpy(&txdesc_mp, ptxdesc, sizeof(struct tx_desc));\n\tmemset(ptxdesc, 0, sizeof(struct tx_desc));\n\t \n\tptxdesc->txdw0 |= cpu_to_le32(sz & 0x0000ffff);\n\tif (pdvobj->ishighspeed) {\n\t\tif (((sz + TXDESC_SIZE) % 512) == 0)\n\t\t\tblnSetTxDescOffset = 1;\n\t\telse\n\t\t\tblnSetTxDescOffset = 0;\n\t} else {\n\t\tif (((sz + TXDESC_SIZE) % 64) == 0)\n\t\t\tblnSetTxDescOffset = 1;\n\t\telse\n\t\t\tblnSetTxDescOffset = 0;\n\t}\n\tif (blnSetTxDescOffset) {\n\t\t \n\t\tptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE + OFFSET_SZ + 8) <<\n\t\t\t      OFFSET_SHT) & 0x00ff0000);\n\t} else {\n\t\t \n\t\tptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE + OFFSET_SZ) <<\n\t\t\t\t  OFFSET_SHT) & 0x00ff0000);\n\t}\n\tptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);\n\tif (pxmitframe->frame_tag == DATA_FRAMETAG) {\n\t\t \n\t\tptxdesc->txdw1 |= cpu_to_le32((pattrib->mac_id) & 0x1f);\n\n#ifdef CONFIG_R8712_TX_AGGR\n\t\t \n\t\tif ((u8 *)pmem != (u8 *)pxmitframe->pxmitbuf->pbuf) {\n\t\t\tptxdesc->txdw0 |= cpu_to_le32\n\t\t\t\t((0x3 << TYPE_SHT) & TYPE_MSK);\n\t\t\tqsel = (uint)(pattrib->qsel & 0x0000001f);\n\t\t\tif (qsel == 2)\n\t\t\t\tqsel = 0;\n\t\t\tptxdesc->txdw1 |= cpu_to_le32\n\t\t\t\t((qsel << QSEL_SHT) & 0x00001f00);\n\t\t\tptxdesc->txdw2 = cpu_to_le32\n\t\t\t\t((qsel << RTS_RC_SHT) & 0x001f0000);\n\t\t\tptxdesc->txdw6 |= cpu_to_le32\n\t\t\t\t((0x5 << RSVD6_SHT) & RSVD6_MSK);\n\t\t} else {\n\t\t\tptxdesc->txdw0 |= cpu_to_le32\n\t\t\t\t((0x3 << TYPE_SHT) & TYPE_MSK);\n\t\t\tptxdesc->txdw1 |= cpu_to_le32\n\t\t\t\t((0x13 << QSEL_SHT) & 0x00001f00);\n\t\t\tqsel = (uint)(pattrib->qsel & 0x0000001f);\n\t\t\tif (qsel == 2)\n\t\t\t\tqsel = 0;\n\t\t\tptxdesc->txdw2 = cpu_to_le32\n\t\t\t\t((qsel << RTS_RC_SHT) & 0x0001f000);\n\t\t\tptxdesc->txdw7 |= cpu_to_le32\n\t\t\t\t(pcmdpriv->cmd_seq << 24);\n\t\t\tpcmdpriv->cmd_seq++;\n\t\t}\n\t\tpattrib->qsel = 0x13;\n#else\n\t\tqsel = (uint)(pattrib->qsel & 0x0000001f);\n\t\tptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);\n#endif\n\t\tif (!pqospriv->qos_option)\n\t\t\tptxdesc->txdw1 |= cpu_to_le32(BIT(16)); \n\t\tif ((pattrib->encrypt > 0) && !pattrib->bswenc) {\n\t\t\tswitch (pattrib->encrypt) {\t \n\t\t\tcase _WEP40_:\n\t\t\tcase _WEP104_:\n\t\t\t\tptxdesc->txdw1 |= cpu_to_le32((0x01 << 22) &\n\t\t\t\t\t\t  0x00c00000);\n\t\t\t\t \n\t\t\t\tptxdesc->txdw1 |=\n\t\t\t\t\tcpu_to_le32((psecuritypriv->PrivacyKeyIndex << 17) &\n\t\t\t\t\t\t    0x00060000);\n\t\t\t\tbreak;\n\t\t\tcase _TKIP_:\n\t\t\tcase _TKIP_WTMIC_:\n\t\t\t\tptxdesc->txdw1 |= cpu_to_le32((0x02 << 22) &\n\t\t\t\t\t\t  0x00c00000);\n\t\t\t\tbreak;\n\t\t\tcase _AES_:\n\t\t\t\tptxdesc->txdw1 |= cpu_to_le32((0x03 << 22) &\n\t\t\t\t\t\t  0x00c00000);\n\t\t\t\tbreak;\n\t\t\tcase _NO_PRIVACY_:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (bmcst)\n\t\t\tptxdesc->txdw2 |= cpu_to_le32(BMC);\n\n\t\t \n\t\t \n\t\tptxdesc->txdw3 = cpu_to_le32((pattrib->priority << SEQ_SHT) &\n\t\t\t\t 0x0fff0000);\n\t\tif ((pattrib->ether_type != 0x888e) &&\n\t\t    (pattrib->ether_type != 0x0806) &&\n\t\t    (pattrib->dhcp_pkt != 1)) {\n\t\t\t \n\t\t\tif (phtpriv->ht_option == 1) {  \n\t\t\t\tif (!phtpriv->ampdu_enable)\n\t\t\t\t\tptxdesc->txdw2 |= cpu_to_le32(BK);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tptxdesc->txdw4 = cpu_to_le32(0x80000000);\n\t\t\tptxdesc->txdw5 = cpu_to_le32(0x001f8000); \n\t\t}\n\t\tif (pattrib->pctrl == 1) {  \n\t\t\tstruct tx_desc *ptxdesc_mp;\n\n\t\t\tptxdesc_mp = &txdesc_mp;\n\t\t\t \n\t\t\tptxdesc->txdw2 = ptxdesc_mp->txdw2;\n\t\t\tif (bmcst)\n\t\t\t\tptxdesc->txdw2 |= cpu_to_le32(BMC);\n\t\t\tptxdesc->txdw2 |= cpu_to_le32(BK);\n\t\t\t \n\t\t\tptxdesc->txdw4 = ptxdesc_mp->txdw4;\n\t\t\t \n\t\t\tptxdesc->txdw5 = ptxdesc_mp->txdw5;\n\t\t\tpattrib->pctrl = 0; \n\t\t}\n\t} else if (pxmitframe->frame_tag == MGNT_FRAMETAG) {\n\t\t \n\t\t \n\t\tptxdesc->txdw1 |= cpu_to_le32((0x05) & 0x1f);\n\t\tqsel = (uint)(pattrib->qsel & 0x0000001f);\n\t\tptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);\n\t\tptxdesc->txdw1 |= cpu_to_le32(BIT(16)); \n\t\t \n\t\tif (bmcst)\n\t\t\tptxdesc->txdw2 |= cpu_to_le32(BMC);\n\t\t \n\t\t \n\t\tptxdesc->txdw3 = cpu_to_le32((pattrib->priority << SEQ_SHT) &\n\t\t\t\t\t      0x0fff0000);\n\t\t \n\t\tptxdesc->txdw4 = cpu_to_le32(0x80002040); \n\t\t \n\t\tptxdesc->txdw5 = cpu_to_le32(0x001f8000); \n\t} else if (pxmitframe->frame_tag == TXAGG_FRAMETAG) {\n\t\t \n\t\tqsel = 0x13;\n\t\tptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);\n\t} else {\n\t\t \n\t\tqsel = (uint)(pattrib->priority & 0x0000001f);\n\t\tptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);\n\t\t \n\t\t \n\t\tptxdesc->txdw3 = cpu_to_le32((pattrib->seqnum << SEQ_SHT) &\n\t\t\t\t\t      0x0fff0000);\n\t\t \n\t\tptxdesc->txdw4 = cpu_to_le32(0x80002040); \n\t\t \n\t\tptxdesc->txdw5 = cpu_to_le32(0x001f9600); \n\t}\n}\n\nint r8712_xmitframe_complete(struct _adapter *padapter,\n\t\t\t     struct xmit_priv *pxmitpriv,\n\t\t\t     struct xmit_buf *pxmitbuf)\n{\n\tstruct hw_xmit *phwxmits;\n\tsint hwentry;\n\tstruct xmit_frame *pxmitframe = NULL;\n#ifdef CONFIG_R8712_TX_AGGR\n\tstruct xmit_frame *p2ndxmitframe = NULL;\n#else\n\tint res = _SUCCESS;\n#endif\n\n\tphwxmits = pxmitpriv->hwxmits;\n\thwentry = pxmitpriv->hwxmit_entry;\n\tif (!pxmitbuf) {\n\t\tpxmitbuf = r8712_alloc_xmitbuf(pxmitpriv);\n\t\tif (!pxmitbuf)\n\t\t\treturn false;\n#ifdef CONFIG_R8712_TX_AGGR\n\t\tpxmitbuf->aggr_nr = 0;\n#endif\n\t}\n\t \n\tpxmitframe = dequeue_xframe_ex(pxmitpriv, phwxmits, hwentry);\n\t \n\tif (pxmitframe) {\n\n#ifdef CONFIG_R8712_TX_AGGR\n\t\t \n\t\tif (AGGR_NR_HIGH_BOUND > 1)\n\t\t\tp2ndxmitframe = dequeue_xframe_ex(pxmitpriv, phwxmits,\n\t\t\t\t\t\t\thwentry);\n\t\tif (pxmitframe->frame_tag != DATA_FRAMETAG) {\n\t\t\tr8712_free_xmitbuf(pxmitpriv, pxmitbuf);\n\t\t\treturn false;\n\t\t}\n\t\tif (p2ndxmitframe)\n\t\t\tif (p2ndxmitframe->frame_tag != DATA_FRAMETAG) {\n\t\t\t\tr8712_free_xmitbuf(pxmitpriv, pxmitbuf);\n\t\t\t\treturn false;\n\t\t\t}\n\t\tr8712_xmitframe_aggr_1st(pxmitbuf, pxmitframe);\n\t\tif (p2ndxmitframe) {\n\t\t\tu16 total_length;\n\n\t\t\ttotal_length = r8712_xmitframe_aggr_next(\n\t\t\t\tpxmitbuf, p2ndxmitframe);\n\t\t\tdo {\n\t\t\t\tp2ndxmitframe = dequeue_xframe_ex(\n\t\t\t\t\tpxmitpriv, phwxmits, hwentry);\n\t\t\t\tif (p2ndxmitframe)\n\t\t\t\t\ttotal_length =\n\t\t\t\t\t\tr8712_xmitframe_aggr_next(\n\t\t\t\t\t\t\tpxmitbuf,\n\t\t\t\t\t\t\tp2ndxmitframe);\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} while (total_length <= 0x1800 &&\n\t\t\t\tpxmitbuf->aggr_nr <= AGGR_NR_HIGH_BOUND);\n\t\t}\n\t\tif (pxmitbuf->aggr_nr > 0)\n\t\t\tr8712_dump_aggr_xframe(pxmitbuf, pxmitframe);\n\n#else\n\n\t\txmitframe_xmitbuf_attach(pxmitframe, pxmitbuf);\n\t\tif (pxmitframe->frame_tag == DATA_FRAMETAG) {\n\t\t\tif (pxmitframe->attrib.priority <= 15)\n\t\t\t\tres = r8712_xmitframe_coalesce(padapter,\n\t\t\t\t\tpxmitframe->pkt, pxmitframe);\n\t\t\t \n\t\t\tr8712_xmit_complete(padapter, pxmitframe);\n\t\t}\n\t\tif (res == _SUCCESS)\n\t\t\tdump_xframe(padapter, pxmitframe);\n\t\telse\n\t\t\tr8712_free_xmitframe_ex(pxmitpriv, pxmitframe);\n#endif\n\n\t} else {  \n\t\tr8712_free_xmitbuf(pxmitpriv, pxmitbuf);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void dump_xframe(struct _adapter *padapter,\n\t\t\tstruct xmit_frame *pxmitframe)\n{\n\tint t, sz, w_sz;\n\tu8 *mem_addr;\n\tu32 ff_hwaddr;\n\tstruct pkt_attrib *pattrib = &pxmitframe->attrib;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\n\tif (pxmitframe->attrib.ether_type != 0x0806) {\n\t\tif (pxmitframe->attrib.ether_type != 0x888e)\n\t\t\tr8712_issue_addbareq_cmd(padapter, pattrib->priority);\n\t}\n\tmem_addr = pxmitframe->buf_addr;\n\tfor (t = 0; t < pattrib->nr_frags; t++) {\n\t\tif (t != (pattrib->nr_frags - 1)) {\n\t\t\tsz = pxmitpriv->frag_len;\n\t\t\tsz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 :\n\t\t\t     pattrib->icv_len);\n\t\t\tpxmitframe->last[t] = 0;\n\t\t} else {\n\t\t\tsz = pattrib->last_txcmdsz;\n\t\t\tpxmitframe->last[t] = 1;\n\t\t}\n\t\tupdate_txdesc(pxmitframe, (uint *)mem_addr, sz);\n\t\tw_sz = sz + TXDESC_SIZE;\n\t\tpxmitframe->mem_addr = mem_addr;\n\t\tpxmitframe->bpending[t] = false;\n\t\tff_hwaddr = get_ff_hwaddr(pxmitframe);\n#ifdef CONFIG_R8712_TX_AGGR\n\t\tr8712_write_port(padapter, RTL8712_DMA_H2CCMD, w_sz,\n\t\t\t\t(unsigned char *)pxmitframe);\n#else\n\t\tr8712_write_port(padapter, ff_hwaddr, w_sz,\n\t\t\t   (unsigned char *)pxmitframe);\n#endif\n\t\tmem_addr += w_sz;\n\t\tmem_addr = (u8 *)RND4(((addr_t)(mem_addr)));\n\t}\n}\n\nvoid r8712_xmit_direct(struct _adapter *padapter, struct xmit_frame *pxmitframe)\n{\n\tint res;\n\n\tres = r8712_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);\n\tpxmitframe->pkt = NULL;\n\tif (res == _SUCCESS)\n\t\tdump_xframe(padapter, pxmitframe);\n}\n\nint r8712_xmit_enqueue(struct _adapter *padapter, struct xmit_frame *pxmitframe)\n{\n\tif (r8712_xmit_classifier(padapter, pxmitframe)) {\n\t\tpxmitframe->pkt = NULL;\n\t\treturn _FAIL;\n\t}\n\treturn _SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}