{
  "module_name": "rtl8712_recv.c",
  "hash_id": "1b9f0c9ee1948adaa63948703718eb4f8f672a54d2a26f5dc38cbb956ffdc062",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/rtl8712_recv.c",
  "human_readable_source": "\n \n\n#define _RTL8712_RECV_C_\n\n#include <linux/if_ether.h>\n#include <linux/ip.h>\n#include <net/cfg80211.h>\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"recv_osdep.h\"\n#include \"mlme_osdep.h\"\n#include \"ethernet.h\"\n#include \"usb_ops.h\"\n#include \"wifi.h\"\n\nstatic void recv_tasklet(struct tasklet_struct *t);\n\nint r8712_init_recv_priv(struct recv_priv *precvpriv,\n\t\t\t struct _adapter *padapter)\n{\n\tint i;\n\tstruct recv_buf *precvbuf;\n\taddr_t tmpaddr = 0;\n\tint alignment = 0;\n\tstruct sk_buff *pskb = NULL;\n\n\t \n\t_init_queue(&precvpriv->free_recv_buf_queue);\n\tprecvpriv->pallocated_recv_buf =\n\t\tkzalloc(NR_RECVBUFF * sizeof(struct recv_buf) + 4, GFP_ATOMIC);\n\tif (!precvpriv->pallocated_recv_buf)\n\t\treturn -ENOMEM;\n\tprecvpriv->precv_buf = precvpriv->pallocated_recv_buf + 4 -\n\t\t\t      ((addr_t)(precvpriv->pallocated_recv_buf) & 3);\n\tprecvbuf = (struct recv_buf *)precvpriv->precv_buf;\n\tfor (i = 0; i < NR_RECVBUFF; i++) {\n\t\tINIT_LIST_HEAD(&precvbuf->list);\n\t\tspin_lock_init(&precvbuf->recvbuf_lock);\n\t\tif (r8712_os_recvbuf_resource_alloc(padapter, precvbuf))\n\t\t\tbreak;\n\t\tprecvbuf->ref_cnt = 0;\n\t\tprecvbuf->adapter = padapter;\n\t\tlist_add_tail(&precvbuf->list,\n\t\t\t      &precvpriv->free_recv_buf_queue.queue);\n\t\tprecvbuf++;\n\t}\n\tprecvpriv->free_recv_buf_queue_cnt = NR_RECVBUFF;\n\ttasklet_setup(&precvpriv->recv_tasklet, recv_tasklet);\n\tskb_queue_head_init(&precvpriv->rx_skb_queue);\n\n\tskb_queue_head_init(&precvpriv->free_recv_skb_queue);\n\tfor (i = 0; i < NR_PREALLOC_RECV_SKB; i++) {\n\t\tpskb = netdev_alloc_skb(padapter->pnetdev, MAX_RECVBUF_SZ +\n\t\t       RECVBUFF_ALIGN_SZ);\n\t\tif (pskb) {\n\t\t\ttmpaddr = (addr_t)pskb->data;\n\t\t\talignment = tmpaddr & (RECVBUFF_ALIGN_SZ - 1);\n\t\t\tskb_reserve(pskb, (RECVBUFF_ALIGN_SZ - alignment));\n\t\t\tskb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);\n\t\t}\n\t\tpskb = NULL;\n\t}\n\treturn 0;\n}\n\nvoid r8712_free_recv_priv(struct recv_priv *precvpriv)\n{\n\tint i;\n\tstruct recv_buf *precvbuf;\n\tstruct _adapter *padapter = precvpriv->adapter;\n\n\tprecvbuf = (struct recv_buf *)precvpriv->precv_buf;\n\tfor (i = 0; i < NR_RECVBUFF; i++) {\n\t\tr8712_os_recvbuf_resource_free(padapter, precvbuf);\n\t\tprecvbuf++;\n\t}\n\tkfree(precvpriv->pallocated_recv_buf);\n\tskb_queue_purge(&precvpriv->rx_skb_queue);\n\tif (skb_queue_len(&precvpriv->rx_skb_queue))\n\t\tnetdev_warn(padapter->pnetdev, \"r8712u: rx_skb_queue not empty\\n\");\n\tskb_queue_purge(&precvpriv->free_recv_skb_queue);\n\tif (skb_queue_len(&precvpriv->free_recv_skb_queue))\n\t\tnetdev_warn(padapter->pnetdev, \"r8712u: free_recv_skb_queue not empty %d\\n\",\n\t\t\t    skb_queue_len(&precvpriv->free_recv_skb_queue));\n}\n\nvoid r8712_init_recvbuf(struct _adapter *padapter, struct recv_buf *precvbuf)\n{\n\tprecvbuf->transfer_len = 0;\n\tprecvbuf->len = 0;\n\tprecvbuf->ref_cnt = 0;\n\tif (precvbuf->pbuf) {\n\t\tprecvbuf->pdata = precvbuf->pbuf;\n\t\tprecvbuf->phead = precvbuf->pbuf;\n\t\tprecvbuf->ptail = precvbuf->pbuf;\n\t\tprecvbuf->pend = precvbuf->pdata + MAX_RECVBUF_SZ;\n\t}\n}\n\nvoid r8712_free_recvframe(union recv_frame *precvframe,\n\t\t\t  struct  __queue *pfree_recv_queue)\n{\n\tunsigned long irqL;\n\tstruct _adapter *padapter = precvframe->u.hdr.adapter;\n\tstruct recv_priv *precvpriv = &padapter->recvpriv;\n\n\tif (precvframe->u.hdr.pkt) {\n\t\tdev_kfree_skb_any(precvframe->u.hdr.pkt); \n\t\tprecvframe->u.hdr.pkt = NULL;\n\t}\n\tspin_lock_irqsave(&pfree_recv_queue->lock, irqL);\n\tlist_del_init(&precvframe->u.hdr.list);\n\tlist_add_tail(&precvframe->u.hdr.list, &pfree_recv_queue->queue);\n\tif (padapter) {\n\t\tif (pfree_recv_queue == &precvpriv->free_recv_queue)\n\t\t\tprecvpriv->free_recvframe_cnt++;\n\t}\n\tspin_unlock_irqrestore(&pfree_recv_queue->lock, irqL);\n}\n\nstatic void update_recvframe_attrib_from_recvstat(struct rx_pkt_attrib *pattrib,\n\t\t\t\t\t\t  struct recv_stat *prxstat)\n{\n\tu16 drvinfo_sz;\n\n\tdrvinfo_sz = (le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16;\n\tdrvinfo_sz <<= 3;\n\t \n\tpattrib->bdecrypted = (le32_to_cpu(prxstat->rxdw0) & BIT(27)) == 0;\n\tpattrib->crc_err = (le32_to_cpu(prxstat->rxdw0) & BIT(14)) != 0;\n\t \n\t \n\t \n\tif (le32_to_cpu(prxstat->rxdw3) & BIT(13)) {\n\t\tpattrib->tcpchk_valid = 1;  \n\t\tif (le32_to_cpu(prxstat->rxdw3) & BIT(11))\n\t\t\tpattrib->tcp_chkrpt = 1;  \n\t\telse\n\t\t\tpattrib->tcp_chkrpt = 0;  \n\t\tif (le32_to_cpu(prxstat->rxdw3) & BIT(12))\n\t\t\tpattrib->ip_chkrpt = 1;  \n\t\telse\n\t\t\tpattrib->ip_chkrpt = 0;  \n\t} else {\n\t\tpattrib->tcpchk_valid = 0;  \n\t}\n\tpattrib->mcs_rate = (u8)((le32_to_cpu(prxstat->rxdw3)) & 0x3f);\n\tpattrib->htc = (u8)((le32_to_cpu(prxstat->rxdw3) >> 14) & 0x1);\n\t \n\t \n\t \n}\n\n \nstatic union recv_frame *recvframe_defrag(struct _adapter *adapter,\n\t\t\t\t\t  struct  __queue *defrag_q)\n{\n\tstruct list_head *plist, *phead;\n\tu8 wlanhdr_offset;\n\tu8\tcurfragnum;\n\tstruct recv_frame_hdr *pfhdr, *pnfhdr;\n\tunion recv_frame *prframe, *pnextrframe;\n\tstruct  __queue\t*pfree_recv_queue;\n\n\tpfree_recv_queue = &adapter->recvpriv.free_recv_queue;\n\tphead = &defrag_q->queue;\n\tplist = phead->next;\n\tprframe = container_of(plist, union recv_frame, u.list);\n\tlist_del_init(&prframe->u.list);\n\tpfhdr = &prframe->u.hdr;\n\tcurfragnum = 0;\n\tif (curfragnum != pfhdr->attrib.frag_num) {\n\t\t \n\t\tr8712_free_recvframe(prframe, pfree_recv_queue);\n\t\tr8712_free_recvframe_queue(defrag_q, pfree_recv_queue);\n\t\treturn NULL;\n\t}\n\tcurfragnum++;\n\tplist = &defrag_q->queue;\n\tplist = plist->next;\n\twhile (!end_of_queue_search(phead, plist)) {\n\t\tpnextrframe = container_of(plist, union recv_frame, u.list);\n\t\tpnfhdr = &pnextrframe->u.hdr;\n\t\t \n\t\tif (curfragnum != pnfhdr->attrib.frag_num) {\n\t\t\t \n\t\t\tr8712_free_recvframe(prframe, pfree_recv_queue);\n\t\t\tr8712_free_recvframe_queue(defrag_q, pfree_recv_queue);\n\t\t\treturn NULL;\n\t\t}\n\t\tcurfragnum++;\n\t\t \n\t\twlanhdr_offset = pnfhdr->attrib.hdrlen + pnfhdr->attrib.iv_len;\n\t\trecvframe_pull(pnextrframe, wlanhdr_offset);\n\t\t \n\t\trecvframe_pull_tail(prframe, pfhdr->attrib.icv_len);\n\t\tmemcpy(pfhdr->rx_tail, pnfhdr->rx_data, pnfhdr->len);\n\t\trecvframe_put(prframe, pnfhdr->len);\n\t\tpfhdr->attrib.icv_len = pnfhdr->attrib.icv_len;\n\t\tplist = plist->next;\n\t}\n\t \n\tr8712_free_recvframe_queue(defrag_q, pfree_recv_queue);\n\treturn prframe;\n}\n\n \nunion recv_frame *r8712_recvframe_chk_defrag(struct _adapter *padapter,\n\t\t\t\t\t     union recv_frame *precv_frame)\n{\n\tu8\tismfrag;\n\tu8\tfragnum;\n\tu8   *psta_addr;\n\tstruct recv_frame_hdr *pfhdr;\n\tstruct sta_info *psta;\n\tstruct\tsta_priv *pstapriv;\n\tstruct list_head *phead;\n\tunion recv_frame *prtnframe = NULL;\n\tstruct  __queue *pfree_recv_queue, *pdefrag_q;\n\n\tpstapriv = &padapter->stapriv;\n\tpfhdr = &precv_frame->u.hdr;\n\tpfree_recv_queue = &padapter->recvpriv.free_recv_queue;\n\t \n\tismfrag = pfhdr->attrib.mfrag;\n\tfragnum = pfhdr->attrib.frag_num;\n\tpsta_addr = pfhdr->attrib.ta;\n\tpsta = r8712_get_stainfo(pstapriv, psta_addr);\n\tif (!psta)\n\t\tpdefrag_q = NULL;\n\telse\n\t\tpdefrag_q = &psta->sta_recvpriv.defrag_q;\n\n\tif ((ismfrag == 0) && (fragnum == 0))\n\t\tprtnframe = precv_frame; \n\tif (ismfrag == 1) {\n\t\t \n\t\tif (pdefrag_q) {\n\t\t\tif (fragnum == 0) {\n\t\t\t\t \n\t\t\t\tif (!list_empty(&pdefrag_q->queue)) {\n\t\t\t\t\t \n\t\t\t\t\tr8712_free_recvframe_queue(pdefrag_q,\n\t\t\t\t\t\t\t     pfree_recv_queue);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tphead = &pdefrag_q->queue;\n\t\t\tlist_add_tail(&pfhdr->list, phead);\n\t\t\tprtnframe = NULL;\n\t\t} else {\n\t\t\t \n\t\t\tr8712_free_recvframe(precv_frame, pfree_recv_queue);\n\t\t\tprtnframe = NULL;\n\t\t}\n\t}\n\tif ((ismfrag == 0) && (fragnum != 0)) {\n\t\t \n\t\tif (pdefrag_q) {\n\t\t\tphead = &pdefrag_q->queue;\n\t\t\tlist_add_tail(&pfhdr->list, phead);\n\t\t\t \n\t\t\tprecv_frame = recvframe_defrag(padapter, pdefrag_q);\n\t\t\tprtnframe = precv_frame;\n\t\t} else {\n\t\t\t \n\t\t\tr8712_free_recvframe(precv_frame, pfree_recv_queue);\n\t\t\tprtnframe = NULL;\n\t\t}\n\t}\n\tif (prtnframe && (prtnframe->u.hdr.attrib.privacy)) {\n\t\t \n\t\tif (r8712_recvframe_chkmic(padapter, prtnframe) == _FAIL) {\n\t\t\tr8712_free_recvframe(prtnframe, pfree_recv_queue);\n\t\t\tprtnframe = NULL;\n\t\t}\n\t}\n\treturn prtnframe;\n}\n\nstatic void amsdu_to_msdu(struct _adapter *padapter, union recv_frame *prframe)\n{\n\tint\ta_len, padding_len;\n\tu16\teth_type, nSubframe_Length;\n\tu8\tnr_subframes, i;\n\tunsigned char *pdata;\n\tstruct rx_pkt_attrib *pattrib;\n\t_pkt *sub_skb, *subframes[MAX_SUBFRAME_COUNT];\n\tstruct recv_priv *precvpriv = &padapter->recvpriv;\n\tstruct  __queue *pfree_recv_queue = &precvpriv->free_recv_queue;\n\n\tnr_subframes = 0;\n\tpattrib = &prframe->u.hdr.attrib;\n\trecvframe_pull(prframe, prframe->u.hdr.attrib.hdrlen);\n\tif (prframe->u.hdr.attrib.iv_len > 0)\n\t\trecvframe_pull(prframe, prframe->u.hdr.attrib.iv_len);\n\ta_len = prframe->u.hdr.len;\n\tpdata = prframe->u.hdr.rx_data;\n\twhile (a_len > ETH_HLEN) {\n\t\t \n\t\tnSubframe_Length = *((u16 *)(pdata + 12));\n\t\t \n\t\tnSubframe_Length = (nSubframe_Length >> 8) +\n\t\t\t\t   (nSubframe_Length << 8);\n\t\tif (a_len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {\n\t\t\tnetdev_warn(padapter->pnetdev, \"r8712u: nRemain_Length is %d and nSubframe_Length is: %d\\n\",\n\t\t\t\t    a_len, nSubframe_Length);\n\t\t\tgoto exit;\n\t\t}\n\t\t \n\t\tpdata += ETH_HLEN;\n\t\ta_len -= ETH_HLEN;\n\t\t \n\t\tsub_skb = dev_alloc_skb(nSubframe_Length + 12);\n\t\tif (!sub_skb)\n\t\t\tbreak;\n\t\tskb_reserve(sub_skb, 12);\n\t\tskb_put_data(sub_skb, pdata, nSubframe_Length);\n\t\tsubframes[nr_subframes++] = sub_skb;\n\t\tif (nr_subframes >= MAX_SUBFRAME_COUNT) {\n\t\t\tnetdev_warn(padapter->pnetdev, \"r8712u: ParseSubframe(): Too many Subframes! Packets dropped!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tpdata += nSubframe_Length;\n\t\ta_len -= nSubframe_Length;\n\t\tif (a_len != 0) {\n\t\t\tpadding_len = 4 - ((nSubframe_Length + ETH_HLEN) & 3);\n\t\t\tif (padding_len == 4)\n\t\t\t\tpadding_len = 0;\n\t\t\tif (a_len < padding_len)\n\t\t\t\tgoto exit;\n\t\t\tpdata += padding_len;\n\t\t\ta_len -= padding_len;\n\t\t}\n\t}\n\tfor (i = 0; i < nr_subframes; i++) {\n\t\tsub_skb = subframes[i];\n\t\t \n\t\teth_type = (sub_skb->data[6] << 8) | sub_skb->data[7];\n\t\tif (sub_skb->len >= 8 &&\n\t\t    ((!memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) &&\n\t\t      eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||\n\t\t     !memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE))) {\n\t\t\t \n\t\t\tskb_pull(sub_skb, SNAP_SIZE);\n\t\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src,\n\t\t\t       ETH_ALEN);\n\t\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst,\n\t\t\t       ETH_ALEN);\n\t\t} else {\n\t\t\t__be16 len;\n\t\t\t \n\t\t\tlen = htons(sub_skb->len);\n\t\t\tmemcpy(skb_push(sub_skb, 2), &len, 2);\n\t\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src,\n\t\t\t       ETH_ALEN);\n\t\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst,\n\t\t\t       ETH_ALEN);\n\t\t}\n\t\t \n\t\tif (sub_skb) {\n\t\t\tsub_skb->protocol =\n\t\t\t\t eth_type_trans(sub_skb, padapter->pnetdev);\n\t\t\tsub_skb->dev = padapter->pnetdev;\n\t\t\tif ((pattrib->tcpchk_valid == 1) &&\n\t\t\t    (pattrib->tcp_chkrpt == 1)) {\n\t\t\t\tsub_skb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t} else {\n\t\t\t\tsub_skb->ip_summed = CHECKSUM_NONE;\n\t\t\t}\n\t\t\tnetif_rx(sub_skb);\n\t\t}\n\t}\nexit:\n\tprframe->u.hdr.len = 0;\n\tr8712_free_recvframe(prframe, pfree_recv_queue);\n}\n\nvoid r8712_rxcmd_event_hdl(struct _adapter *padapter, void *prxcmdbuf)\n{\n\t__le32 voffset;\n\tu8 *poffset;\n\tu16 cmd_len, drvinfo_sz;\n\tstruct recv_stat *prxstat;\n\n\tpoffset = prxcmdbuf;\n\tvoffset = *(__le32 *)poffset;\n\tprxstat = prxcmdbuf;\n\tdrvinfo_sz = (le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16;\n\tdrvinfo_sz <<= 3;\n\tpoffset += RXDESC_SIZE + drvinfo_sz;\n\tdo {\n\t\tvoffset  = *(__le32 *)poffset;\n\t\tcmd_len = (u16)(le32_to_cpu(voffset) & 0xffff);\n\t\tr8712_event_handle(padapter, (__le32 *)poffset);\n\t\tpoffset += (cmd_len + 8); \n\t} while (le32_to_cpu(voffset) & BIT(31));\n}\n\nstatic int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl,\n\t\t\t      u16 seq_num)\n{\n\tu8 wsize = preorder_ctrl->wsize_b;\n\tu16 wend = (preorder_ctrl->indicate_seq + wsize - 1) % 4096;\n\n\t \n\tif (preorder_ctrl->indicate_seq == 0xffff)\n\t\tpreorder_ctrl->indicate_seq = seq_num;\n\t \n\tif (SN_LESS(seq_num, preorder_ctrl->indicate_seq))\n\t\treturn false;\n\t \n\tif (SN_EQUAL(seq_num, preorder_ctrl->indicate_seq))\n\t\tpreorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq +\n\t\t\t\t\t      1) % 4096;\n\telse if (SN_LESS(wend, seq_num)) {\n\t\tif (seq_num >= (wsize - 1))\n\t\t\tpreorder_ctrl->indicate_seq = seq_num + 1 - wsize;\n\t\telse\n\t\t\tpreorder_ctrl->indicate_seq = 4095 - (wsize -\n\t\t\t\t\t\t      (seq_num + 1)) + 1;\n\t}\n\treturn true;\n}\n\nstatic int enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl,\n\t\t\t\t     union recv_frame *prframe)\n{\n\tstruct list_head *phead, *plist;\n\tunion recv_frame *pnextrframe;\n\tstruct rx_pkt_attrib *pnextattrib;\n\tstruct  __queue *ppending_recvframe_queue =\n\t\t\t\t\t&preorder_ctrl->pending_recvframe_queue;\n\tstruct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;\n\n\tphead = &ppending_recvframe_queue->queue;\n\tplist = phead->next;\n\twhile (!end_of_queue_search(phead, plist)) {\n\t\tpnextrframe = container_of(plist, union recv_frame, u.list);\n\t\tpnextattrib = &pnextrframe->u.hdr.attrib;\n\n\t\tif (SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num))\n\t\t\treturn false;\n\n\t\tif (SN_LESS(pnextattrib->seq_num, pattrib->seq_num))\n\t\t\tplist = plist->next;\n\t\telse\n\t\t\tbreak;\n\t}\n\tlist_del_init(&prframe->u.hdr.list);\n\tlist_add_tail(&prframe->u.hdr.list, plist);\n\treturn true;\n}\n\nint r8712_recv_indicatepkts_in_order(struct _adapter *padapter,\n\t\t\t\t     struct recv_reorder_ctrl *preorder_ctrl,\n\t\t\t\t     int bforced)\n{\n\tstruct list_head *phead, *plist;\n\tunion recv_frame *prframe;\n\tstruct rx_pkt_attrib *pattrib;\n\tint bPktInBuf = false;\n\tstruct  __queue *ppending_recvframe_queue =\n\t\t\t &preorder_ctrl->pending_recvframe_queue;\n\n\tphead = &ppending_recvframe_queue->queue;\n\tplist = phead->next;\n\t \n\tif (bforced) {\n\t\tif (list_empty(phead))\n\t\t\treturn true;\n\n\t\tprframe = container_of(plist, union recv_frame, u.list);\n\t\tpattrib = &prframe->u.hdr.attrib;\n\t\tpreorder_ctrl->indicate_seq = pattrib->seq_num;\n\t}\n\t \n\twhile (!list_empty(phead)) {\n\t\tprframe = container_of(plist, union recv_frame, u.list);\n\t\tpattrib = &prframe->u.hdr.attrib;\n\t\tif (!SN_LESS(preorder_ctrl->indicate_seq, pattrib->seq_num)) {\n\t\t\tplist = plist->next;\n\t\t\tlist_del_init(&prframe->u.hdr.list);\n\t\t\tif (SN_EQUAL(preorder_ctrl->indicate_seq,\n\t\t\t\t     pattrib->seq_num))\n\t\t\t\tpreorder_ctrl->indicate_seq =\n\t\t\t\t  (preorder_ctrl->indicate_seq + 1) % 4096;\n\t\t\t \n\t\t\tif (!pattrib->amsdu) {\n\t\t\t\tif (!padapter->driver_stopped &&\n\t\t\t\t    !padapter->surprise_removed) {\n\t\t\t\t\t \n\t\t\t\t\tr8712_recv_indicatepkt(padapter,\n\t\t\t\t\t\t\t       prframe);\n\t\t\t\t}\n\t\t\t} else if (pattrib->amsdu == 1) {\n\t\t\t\tamsdu_to_msdu(padapter, prframe);\n\t\t\t}\n\t\t\t \n\t\t\tbPktInBuf = false;\n\t\t} else {\n\t\t\tbPktInBuf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn bPktInBuf;\n}\n\nstatic int recv_indicatepkt_reorder(struct _adapter *padapter,\n\t\t\t\t    union recv_frame *prframe)\n{\n\tunsigned long irql;\n\tstruct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;\n\tstruct recv_reorder_ctrl *preorder_ctrl = prframe->u.hdr.preorder_ctrl;\n\tstruct  __queue *ppending_recvframe_queue =\n\t\t\t &preorder_ctrl->pending_recvframe_queue;\n\n\tif (!pattrib->amsdu) {\n\t\t \n\t\tr8712_wlanhdr_to_ethhdr(prframe);\n\t\tif (pattrib->qos != 1) {\n\t\t\tif (!padapter->driver_stopped &&\n\t\t\t    !padapter->surprise_removed) {\n\t\t\t\tr8712_recv_indicatepkt(padapter, prframe);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\tspin_lock_irqsave(&ppending_recvframe_queue->lock, irql);\n\t \n\tif (!check_indicate_seq(preorder_ctrl, pattrib->seq_num))\n\t\tgoto _err_exit;\n\t \n\tif (!enqueue_reorder_recvframe(preorder_ctrl, prframe))\n\t\tgoto _err_exit;\n\t \n\tif (r8712_recv_indicatepkts_in_order(padapter, preorder_ctrl, false)) {\n\t\tmod_timer(&preorder_ctrl->reordering_ctrl_timer,\n\t\t\t  jiffies + msecs_to_jiffies(REORDER_WAIT_TIME));\n\t\tspin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);\n\t} else {\n\t\tspin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);\n\t\tdel_timer(&preorder_ctrl->reordering_ctrl_timer);\n\t}\n\treturn 0;\n_err_exit:\n\tspin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);\n\treturn -ENOMEM;\n}\n\nvoid r8712_reordering_ctrl_timeout_handler(void *pcontext)\n{\n\tunsigned long irql;\n\tstruct recv_reorder_ctrl *preorder_ctrl = pcontext;\n\tstruct _adapter *padapter = preorder_ctrl->padapter;\n\tstruct  __queue *ppending_recvframe_queue =\n\t\t\t\t &preorder_ctrl->pending_recvframe_queue;\n\n\tif (padapter->driver_stopped || padapter->surprise_removed)\n\t\treturn;\n\tspin_lock_irqsave(&ppending_recvframe_queue->lock, irql);\n\tr8712_recv_indicatepkts_in_order(padapter, preorder_ctrl, true);\n\tspin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);\n}\n\nstatic int r8712_process_recv_indicatepkts(struct _adapter *padapter,\n\t\t\t\t\t   union recv_frame *prframe)\n{\n\tint retval = _SUCCESS;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct ht_priv\t*phtpriv = &pmlmepriv->htpriv;\n\n\tif (phtpriv->ht_option == 1) {  \n\t\tif (recv_indicatepkt_reorder(padapter, prframe)) {\n\t\t\t \n\t\t\tif (!padapter->driver_stopped &&\n\t\t\t    !padapter->surprise_removed)\n\t\t\t\treturn _FAIL;\n\t\t}\n\t} else {  \n\t\tretval = r8712_wlanhdr_to_ethhdr(prframe);\n\t\tif (retval)\n\t\t\treturn _FAIL;\n\t\tif (!padapter->driver_stopped && !padapter->surprise_removed) {\n\t\t\t \n\t\t\tr8712_recv_indicatepkt(padapter, prframe);\n\t\t} else {\n\t\t\treturn _FAIL;\n\t\t}\n\t}\n\treturn retval;\n}\n\nstatic u8 query_rx_pwr_percentage(s8 antpower)\n{\n\tif ((antpower <= -100) || (antpower >= 20))\n\t\treturn\t0;\n\telse if (antpower >= 0)\n\t\treturn\t100;\n\telse\n\t\treturn 100 + antpower;\n}\n\nstatic u8 evm_db2percentage(s8 value)\n{\n\t \n\ts8 ret_val = clamp(-value, 0, 33) * 3;\n\n\tif (ret_val == 99)\n\t\tret_val = 100;\n\n\treturn ret_val;\n}\n\ns32 r8712_signal_scale_mapping(s32 cur_sig)\n{\n\ts32 ret_sig;\n\n\tif (cur_sig >= 51 && cur_sig <= 100)\n\t\tret_sig = 100;\n\telse if (cur_sig >= 41 && cur_sig <= 50)\n\t\tret_sig = 80 + ((cur_sig - 40) * 2);\n\telse if (cur_sig >= 31 && cur_sig <= 40)\n\t\tret_sig = 66 + (cur_sig - 30);\n\telse if (cur_sig >= 21 && cur_sig <= 30)\n\t\tret_sig = 54 + (cur_sig - 20);\n\telse if (cur_sig >= 10 && cur_sig <= 20)\n\t\tret_sig = 42 + (((cur_sig - 10) * 2) / 3);\n\telse if (cur_sig >= 5 && cur_sig <= 9)\n\t\tret_sig = 22 + (((cur_sig - 5) * 3) / 2);\n\telse if (cur_sig >= 1 && cur_sig <= 4)\n\t\tret_sig = 6 + (((cur_sig - 1) * 3) / 2);\n\telse\n\t\tret_sig = cur_sig;\n\treturn ret_sig;\n}\n\nstatic s32  translate2dbm(struct _adapter *padapter, u8 signal_strength_idx)\n{\n\ts32 signal_power;  \n\t \n\tsignal_power = (s32)((signal_strength_idx + 1) >> 1);\n\tsignal_power -= 95;\n\treturn signal_power;\n}\n\nstatic void query_rx_phy_status(struct _adapter *padapter,\n\t\t\t\tunion recv_frame *prframe)\n{\n\tu8 i, max_spatial_stream, evm;\n\tstruct recv_stat *prxstat = (struct recv_stat *)prframe->u.hdr.rx_head;\n\tstruct phy_stat *pphy_stat = (struct phy_stat *)(prxstat + 1);\n\tu8 *pphy_head = (u8 *)(prxstat + 1);\n\ts8 rx_pwr[4], rx_pwr_all;\n\tu8 pwdb_all;\n\tu32 rssi, total_rssi = 0;\n\tu8 bcck_rate = 0, rf_rx_num = 0, cck_highpwr = 0;\n\tstruct phy_cck_rx_status *pcck_buf;\n\tu8 sq;\n\n\t \n\tbcck_rate = (prframe->u.hdr.attrib.mcs_rate <= 3 ? 1 : 0);\n\tif (bcck_rate) {\n\t\tu8 report;\n\n\t\t \n\t\tpcck_buf = (struct phy_cck_rx_status *)pphy_stat;\n\t\t \n\t\tif (!cck_highpwr) {\n\t\t\treport = pcck_buf->cck_agc_rpt & 0xc0;\n\t\t\treport >>= 6;\n\t\t\tswitch (report) {\n\t\t\t \n\t\t\tcase 0x3:\n\t\t\t\trx_pwr_all = -40 - (pcck_buf->cck_agc_rpt &\n\t\t\t\t\t     0x3e);\n\t\t\t\tbreak;\n\t\t\tcase 0x2:\n\t\t\t\trx_pwr_all = -20 - (pcck_buf->cck_agc_rpt &\n\t\t\t\t\t     0x3e);\n\t\t\t\tbreak;\n\t\t\tcase 0x1:\n\t\t\t\trx_pwr_all = -2 - (pcck_buf->cck_agc_rpt &\n\t\t\t\t\t     0x3e);\n\t\t\t\tbreak;\n\t\t\tcase 0x0:\n\t\t\t\trx_pwr_all = 14 - (pcck_buf->cck_agc_rpt &\n\t\t\t\t\t     0x3e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\treport = ((u8)(le32_to_cpu(pphy_stat->phydw1) >> 8)) &\n\t\t\t\t 0x60;\n\t\t\treport >>= 5;\n\t\t\tswitch (report) {\n\t\t\tcase 0x3:\n\t\t\t\trx_pwr_all = -40 - ((pcck_buf->cck_agc_rpt &\n\t\t\t\t\t     0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\tcase 0x2:\n\t\t\t\trx_pwr_all = -20 - ((pcck_buf->cck_agc_rpt &\n\t\t\t\t\t     0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\tcase 0x1:\n\t\t\t\trx_pwr_all = -2 - ((pcck_buf->cck_agc_rpt &\n\t\t\t\t\t     0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\tcase 0x0:\n\t\t\t\trx_pwr_all = 14 - ((pcck_buf->cck_agc_rpt &\n\t\t\t\t\t     0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpwdb_all = query_rx_pwr_percentage(rx_pwr_all);\n\t\t \n\t\t \n\t\tpwdb_all += 6;\n\t\tif (pwdb_all > 100)\n\t\t\tpwdb_all = 100;\n\t\t \n\t\tif (pwdb_all > 34 && pwdb_all <= 42)\n\t\t\tpwdb_all -= 2;\n\t\telse if (pwdb_all > 26 && pwdb_all <= 34)\n\t\t\tpwdb_all -= 6;\n\t\telse if (pwdb_all > 14 && pwdb_all <= 26)\n\t\t\tpwdb_all -= 8;\n\t\telse if (pwdb_all > 4 && pwdb_all <= 14)\n\t\t\tpwdb_all -= 4;\n\t\t \n\t\tif (pwdb_all > 40) {\n\t\t\tsq = 100;\n\t\t} else {\n\t\t\tsq = pcck_buf->sq_rpt;\n\t\t\tif (pcck_buf->sq_rpt > 64)\n\t\t\t\tsq = 0;\n\t\t\telse if (pcck_buf->sq_rpt < 20)\n\t\t\t\tsq = 100;\n\t\t\telse\n\t\t\t\tsq = ((64 - sq) * 100) / 44;\n\t\t}\n\t\tprframe->u.hdr.attrib.signal_qual = sq;\n\t\tprframe->u.hdr.attrib.rx_mimo_signal_qual[0] = sq;\n\t\tprframe->u.hdr.attrib.rx_mimo_signal_qual[1] = -1;\n\t} else {\n\t\t \n\t\tfor (i = 0; i < ((padapter->registrypriv.rf_config) &\n\t\t\t    0x0f); i++) {\n\t\t\trf_rx_num++;\n\t\t\trx_pwr[i] = ((pphy_head[PHY_STAT_GAIN_TRSW_SHT + i]\n\t\t\t\t    & 0x3F) * 2) - 110;\n\t\t\t \n\t\t\trssi = query_rx_pwr_percentage(rx_pwr[i]);\n\t\t\ttotal_rssi += rssi;\n\t\t}\n\t\t \n\t\trx_pwr_all = (((pphy_head[PHY_STAT_PWDB_ALL_SHT]) >> 1) & 0x7f)\n\t\t\t     - 106;\n\t\tpwdb_all = query_rx_pwr_percentage(rx_pwr_all);\n\n\t\t{\n\t\t\t \n\t\t\tif (prframe->u.hdr.attrib.htc &&\n\t\t\t    prframe->u.hdr.attrib.mcs_rate >= 20 &&\n\t\t\t    prframe->u.hdr.attrib.mcs_rate <= 27) {\n\t\t\t\t \n\t\t\t\tmax_spatial_stream = 2;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmax_spatial_stream = 1;\n\t\t\t}\n\t\t\tfor (i = 0; i < max_spatial_stream; i++) {\n\t\t\t\tevm = evm_db2percentage((pphy_head\n\t\t\t\t      [PHY_STAT_RXEVM_SHT + i])); \n\t\t\t\tprframe->u.hdr.attrib.signal_qual =\n\t\t\t\t\t (u8)(evm & 0xff);\n\t\t\t\tprframe->u.hdr.attrib.rx_mimo_signal_qual[i] =\n\t\t\t\t\t (u8)(evm & 0xff);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (bcck_rate) {\n\t\tprframe->u.hdr.attrib.signal_strength =\n\t\t\t (u8)r8712_signal_scale_mapping(pwdb_all);\n\t} else {\n\t\tif (rf_rx_num != 0)\n\t\t\tprframe->u.hdr.attrib.signal_strength =\n\t\t\t\t (u8)(r8712_signal_scale_mapping(total_rssi /=\n\t\t\t\t rf_rx_num));\n\t}\n}\n\nstatic void process_link_qual(struct _adapter *padapter,\n\t\t\t      union recv_frame *prframe)\n{\n\tu32\tlast_evm = 0, tmpVal;\n\tstruct rx_pkt_attrib *pattrib;\n\tstruct smooth_rssi_data *sqd = &padapter->recvpriv.signal_qual_data;\n\n\tif (!prframe || !padapter)\n\t\treturn;\n\tpattrib = &prframe->u.hdr.attrib;\n\tif (pattrib->signal_qual != 0) {\n\t\t \n\t\tif (sqd->total_num++ >= PHY_LINKQUALITY_SLID_WIN_MAX) {\n\t\t\tsqd->total_num = PHY_LINKQUALITY_SLID_WIN_MAX;\n\t\t\tlast_evm = sqd->elements[sqd->index];\n\t\t\tsqd->total_val -= last_evm;\n\t\t}\n\t\tsqd->total_val += pattrib->signal_qual;\n\t\tsqd->elements[sqd->index++] = pattrib->signal_qual;\n\t\tif (sqd->index >= PHY_LINKQUALITY_SLID_WIN_MAX)\n\t\t\tsqd->index = 0;\n\n\t\t \n\t\ttmpVal = sqd->total_val / sqd->total_num;\n\t\tpadapter->recvpriv.signal = (u8)tmpVal;\n\t}\n}\n\nstatic void process_rssi(struct _adapter *padapter, union recv_frame *prframe)\n{\n\tu32 last_rssi, tmp_val;\n\tstruct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;\n\tstruct smooth_rssi_data *ssd = &padapter->recvpriv.signal_strength_data;\n\n\tif (ssd->total_num++ >= PHY_RSSI_SLID_WIN_MAX) {\n\t\tssd->total_num = PHY_RSSI_SLID_WIN_MAX;\n\t\tlast_rssi = ssd->elements[ssd->index];\n\t\tssd->total_val -= last_rssi;\n\t}\n\tssd->total_val += pattrib->signal_strength;\n\tssd->elements[ssd->index++] = pattrib->signal_strength;\n\tif (ssd->index >= PHY_RSSI_SLID_WIN_MAX)\n\t\tssd->index = 0;\n\ttmp_val = ssd->total_val / ssd->total_num;\n\tpadapter->recvpriv.rssi = (s8)translate2dbm(padapter, (u8)tmp_val);\n}\n\nstatic void process_phy_info(struct _adapter *padapter,\n\t\t\t     union recv_frame *prframe)\n{\n\tquery_rx_phy_status(padapter, prframe);\n\tprocess_rssi(padapter, prframe);\n\tprocess_link_qual(padapter,  prframe);\n}\n\nint recv_func(struct _adapter *padapter, void *pcontext)\n{\n\tstruct rx_pkt_attrib *pattrib;\n\tunion recv_frame *prframe, *orig_prframe;\n\tint retval = _SUCCESS;\n\tstruct  __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;\n\tstruct\tmlme_priv\t*pmlmepriv = &padapter->mlmepriv;\n\n\tprframe = pcontext;\n\torig_prframe = prframe;\n\tpattrib = &prframe->u.hdr.attrib;\n\tif (check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\n\t\tif (pattrib->crc_err == 1)\n\t\t\tpadapter->mppriv.rx_crcerrpktcount++;\n\t\telse\n\t\t\tpadapter->mppriv.rx_pktcount++;\n\t\tif (!check_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE)) {\n\t\t\t \n\t\t\tr8712_free_recvframe(orig_prframe, pfree_recv_queue);\n\t\t\tgoto _exit_recv_func;\n\t\t}\n\t}\n\t \n\tretval = r8712_validate_recv_frame(padapter, prframe);\n\tif (retval != _SUCCESS) {\n\t\t \n\t\tr8712_free_recvframe(orig_prframe, pfree_recv_queue);\n\t\tgoto _exit_recv_func;\n\t}\n\tprocess_phy_info(padapter, prframe);\n\tprframe = r8712_decryptor(padapter, prframe);\n\tif (!prframe) {\n\t\tretval = _FAIL;\n\t\tgoto _exit_recv_func;\n\t}\n\tprframe = r8712_recvframe_chk_defrag(padapter, prframe);\n\tif (!prframe)\n\t\tgoto _exit_recv_func;\n\tprframe = r8712_portctrl(padapter, prframe);\n\tif (!prframe) {\n\t\tretval = _FAIL;\n\t\tgoto _exit_recv_func;\n\t}\n\tretval = r8712_process_recv_indicatepkts(padapter, prframe);\n\tif (retval != _SUCCESS) {\n\t\tr8712_free_recvframe(orig_prframe, pfree_recv_queue);\n\t\tgoto _exit_recv_func;\n\t}\n_exit_recv_func:\n\treturn retval;\n}\n\nstatic void recvbuf2recvframe(struct _adapter *padapter, struct sk_buff *pskb)\n{\n\tu8 *pbuf, shift_sz = 0;\n\tu8\tfrag, mf;\n\tuint\tpkt_len;\n\tu32 transfer_len;\n\tstruct recv_stat *prxstat;\n\tu16\tpkt_cnt, drvinfo_sz, pkt_offset, tmp_len, alloc_sz;\n\tstruct  __queue *pfree_recv_queue;\n\t_pkt  *pkt_copy = NULL;\n\tunion recv_frame *precvframe = NULL;\n\tstruct recv_priv *precvpriv = &padapter->recvpriv;\n\n\tpfree_recv_queue = &precvpriv->free_recv_queue;\n\tpbuf = pskb->data;\n\tprxstat = (struct recv_stat *)pbuf;\n\tpkt_cnt = (le32_to_cpu(prxstat->rxdw2) >> 16) & 0xff;\n\tpkt_len =  le32_to_cpu(prxstat->rxdw0) & 0x00003fff;\n\ttransfer_len = pskb->len;\n\t \n\tif (transfer_len < pkt_len) {\n\t\t \n\t\treturn;\n\t}\n\tdo {\n\t\tprxstat = (struct recv_stat *)pbuf;\n\t\tpkt_len =  le32_to_cpu(prxstat->rxdw0) & 0x00003fff;\n\t\t \n\t\tmf = (le32_to_cpu(prxstat->rxdw1) >> 27) & 0x1;\n\t\t \n\t\tfrag = (le32_to_cpu(prxstat->rxdw2) >> 12) & 0xf;\n\t\t \n\t\tdrvinfo_sz = (le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16;\n\t\tdrvinfo_sz <<= 3;\n\t\tif (pkt_len <= 0)\n\t\t\treturn;\n\t\t \n\t\tif ((le32_to_cpu(prxstat->rxdw0) >> 23) & 0x01)\n\t\t\tshift_sz = 2;\n\t\tprecvframe = r8712_alloc_recvframe(pfree_recv_queue);\n\t\tif (!precvframe)\n\t\t\treturn;\n\t\tINIT_LIST_HEAD(&precvframe->u.hdr.list);\n\t\tprecvframe->u.hdr.precvbuf = NULL;  \n\t\tprecvframe->u.hdr.len = 0;\n\t\ttmp_len = pkt_len + drvinfo_sz + RXDESC_SIZE;\n\t\tpkt_offset = (u16)round_up(tmp_len, 128);\n\t\t \n\t\tif ((mf == 1) && (frag == 0))\n\t\t\t \n\t\t\talloc_sz = max_t(u16, tmp_len, 1658);\n\t\telse\n\t\t\talloc_sz = tmp_len;\n\t\t \n\t\talloc_sz += 6;\n\t\tpkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);\n\t\tif (!pkt_copy)\n\t\t\treturn;\n\n\t\tprecvframe->u.hdr.pkt = pkt_copy;\n\t\tskb_reserve(pkt_copy, 4 - ((addr_t)(pkt_copy->data) % 4));\n\t\tskb_reserve(pkt_copy, shift_sz);\n\t\tmemcpy(pkt_copy->data, pbuf, tmp_len);\n\t\tprecvframe->u.hdr.rx_head = pkt_copy->data;\n\t\tprecvframe->u.hdr.rx_data = pkt_copy->data;\n\t\tprecvframe->u.hdr.rx_tail = pkt_copy->data;\n\t\tprecvframe->u.hdr.rx_end = pkt_copy->data + alloc_sz;\n\n\t\trecvframe_put(precvframe, tmp_len);\n\t\trecvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);\n\t\t \n\t\tupdate_recvframe_attrib_from_recvstat(&precvframe->u.hdr.attrib,\n\t\t\t\t\t\t      prxstat);\n\t\tr8712_recv_entry(precvframe);\n\t\ttransfer_len -= pkt_offset;\n\t\tpbuf += pkt_offset;\n\t\tpkt_cnt--;\n\t\tprecvframe = NULL;\n\t\tpkt_copy = NULL;\n\t} while ((transfer_len > 0) && pkt_cnt > 0);\n}\n\nstatic void recv_tasklet(struct tasklet_struct *t)\n{\n\tstruct sk_buff *pskb;\n\tstruct _adapter *padapter = from_tasklet(padapter, t,\n\t\t\t\t\t\t recvpriv.recv_tasklet);\n\tstruct recv_priv *precvpriv = &padapter->recvpriv;\n\n\twhile (NULL != (pskb = skb_dequeue(&precvpriv->rx_skb_queue))) {\n\t\trecvbuf2recvframe(padapter, pskb);\n\t\tskb_reset_tail_pointer(pskb);\n\t\tpskb->len = 0;\n\t\tif (!skb_cloned(pskb))\n\t\t\tskb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);\n\t\telse\n\t\t\tconsume_skb(pskb);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}