{
  "module_name": "mlme_linux.c",
  "hash_id": "d19698f97fee3543a4f0dd757155996983ea545250c39190ab3cb6b9e9babdfd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/mlme_linux.c",
  "human_readable_source": "\n \n\n#define _MLME_OSDEP_C_\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"mlme_osdep.h\"\n\nstatic void sitesurvey_ctrl_handler(struct timer_list *t)\n{\n\tstruct _adapter *adapter =\n\t\tfrom_timer(adapter, t,\n\t\t\t   mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer);\n\n\t_r8712_sitesurvey_ctrl_handler(adapter);\n\tmod_timer(&adapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer,\n\t\t  jiffies + msecs_to_jiffies(3000));\n}\n\nstatic void join_timeout_handler (struct timer_list *t)\n{\n\tstruct _adapter *adapter =\n\t\tfrom_timer(adapter, t, mlmepriv.assoc_timer);\n\n\t_r8712_join_timeout_handler(adapter);\n}\n\nstatic void _scan_timeout_handler (struct timer_list *t)\n{\n\tstruct _adapter *adapter =\n\t\tfrom_timer(adapter, t, mlmepriv.scan_to_timer);\n\n\tr8712_scan_timeout_handler(adapter);\n}\n\nstatic void dhcp_timeout_handler (struct timer_list *t)\n{\n\tstruct _adapter *adapter =\n\t\tfrom_timer(adapter, t, mlmepriv.dhcp_timer);\n\n\t_r8712_dhcp_timeout_handler(adapter);\n}\n\nstatic void wdg_timeout_handler (struct timer_list *t)\n{\n\tstruct _adapter *adapter =\n\t\tfrom_timer(adapter, t, mlmepriv.wdg_timer);\n\n\tr8712_wdg_wk_cmd(adapter);\n\n\tmod_timer(&adapter->mlmepriv.wdg_timer,\n\t\t  jiffies + msecs_to_jiffies(2000));\n}\n\nvoid r8712_init_mlme_timer(struct _adapter *adapter)\n{\n\tstruct\tmlme_priv *mlmepriv = &adapter->mlmepriv;\n\n\ttimer_setup(&mlmepriv->assoc_timer, join_timeout_handler, 0);\n\ttimer_setup(&mlmepriv->sitesurveyctrl.sitesurvey_ctrl_timer,\n\t\t    sitesurvey_ctrl_handler, 0);\n\ttimer_setup(&mlmepriv->scan_to_timer, _scan_timeout_handler, 0);\n\ttimer_setup(&mlmepriv->dhcp_timer, dhcp_timeout_handler, 0);\n\ttimer_setup(&mlmepriv->wdg_timer, wdg_timeout_handler, 0);\n}\n\nvoid r8712_os_indicate_connect(struct _adapter *adapter)\n{\n\tr8712_indicate_wx_assoc_event(adapter);\n\tnetif_carrier_on(adapter->pnetdev);\n}\n\nstatic struct RT_PMKID_LIST   backupPMKIDList[NUM_PMKID_CACHE];\nvoid r8712_os_indicate_disconnect(struct _adapter *adapter)\n{\n\tu8 backupPMKIDIndex = 0;\n\tu8 backupTKIPCountermeasure = 0x00;\n\n\tr8712_indicate_wx_disassoc_event(adapter);\n\tnetif_carrier_off(adapter->pnetdev);\n\tif (adapter->securitypriv.AuthAlgrthm == 2) {  \n\t\t \n\n\t\tmemcpy(&backupPMKIDList[0],\n\t\t       &adapter->securitypriv.PMKIDList[0],\n\t\t       sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);\n\t\tbackupPMKIDIndex = adapter->securitypriv.PMKIDIndex;\n\t\tbackupTKIPCountermeasure =\n\t\t\tadapter->securitypriv.btkip_countermeasure;\n\t\tmemset((unsigned char *)&adapter->securitypriv, 0,\n\t\t       sizeof(struct security_priv));\n\t\ttimer_setup(&adapter->securitypriv.tkip_timer,\n\t\t\t    r8712_use_tkipkey_handler, 0);\n\t\t \n\t\tmemcpy(&adapter->securitypriv.PMKIDList[0],\n\t\t       &backupPMKIDList[0],\n\t\t       sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);\n\t\tadapter->securitypriv.PMKIDIndex = backupPMKIDIndex;\n\t\tadapter->securitypriv.btkip_countermeasure =\n\t\t\t\t\t backupTKIPCountermeasure;\n\t} else {  \n\t\tstruct security_priv *sec_priv = &adapter->securitypriv;\n\n\t\tsec_priv->AuthAlgrthm = 0;  \n\t\tsec_priv->PrivacyAlgrthm = _NO_PRIVACY_;\n\t\tsec_priv->PrivacyKeyIndex = 0;\n\t\tsec_priv->XGrpPrivacy = _NO_PRIVACY_;\n\t\tsec_priv->XGrpKeyid = 1;\n\t\tsec_priv->ndisauthtype = Ndis802_11AuthModeOpen;\n\t\tsec_priv->ndisencryptstatus = Ndis802_11WEPDisabled;\n\t\tsec_priv->wps_phase = false;\n\t}\n}\n\nvoid r8712_report_sec_ie(struct _adapter *adapter, u8 authmode, u8 *sec_ie)\n{\n\tuint len;\n\tu8 *buff, *p, i;\n\tunion iwreq_data wrqu;\n\n\tbuff = NULL;\n\tif (authmode == _WPA_IE_ID_) {\n\t\tbuff = kzalloc(IW_CUSTOM_MAX, GFP_ATOMIC);\n\t\tif (!buff)\n\t\t\treturn;\n\t\tp = buff;\n\t\tp += sprintf(p, \"ASSOCINFO(ReqIEs=\");\n\t\tlen = sec_ie[1] + 2;\n\t\tlen =  (len < IW_CUSTOM_MAX) ? len : IW_CUSTOM_MAX;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tp += sprintf(p, \"%02x\", sec_ie[i]);\n\t\tp += sprintf(p, \")\");\n\t\tmemset(&wrqu, 0, sizeof(wrqu));\n\t\twrqu.data.length = p - buff;\n\t\twrqu.data.length = (wrqu.data.length < IW_CUSTOM_MAX) ?\n\t\t\t\t   wrqu.data.length : IW_CUSTOM_MAX;\n\t\twireless_send_event(adapter->pnetdev, IWEVCUSTOM, &wrqu, buff);\n\t\tkfree(buff);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}