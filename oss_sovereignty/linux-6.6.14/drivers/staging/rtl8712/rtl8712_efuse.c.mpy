{
  "module_name": "rtl8712_efuse.c",
  "hash_id": "07e46c69f98c82bf6ad22fb8d4fef80420861142a3ddff03f873d8d65df9ec9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/rtl8712_efuse.c",
  "human_readable_source": "\n \n\n#define _RTL8712_EFUSE_C_\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"rtl8712_efuse.h\"\n\n \nstatic int efuse_available_max_size = EFUSE_MAX_SIZE - 3  ;\n\nstatic void efuse_reg_ctrl(struct _adapter *adapter, u8 bPowerOn)\n{\n\tu8 tmpu8 = 0;\n\n\tif (bPowerOn) {\n\t\t \n\t\ttmpu8 = r8712_read8(adapter, EFUSE_TEST + 3);\n\t\ttmpu8 |= 0x80;\n\t\tr8712_write8(adapter, EFUSE_TEST + 3, tmpu8);\n\t\tmsleep(20);  \n\t\t \n\t\tr8712_write8(adapter, EFUSE_CLK_CTRL, 0x03);\n\t\tmsleep(20);  \n\t} else {\n\t\t \n\t\ttmpu8 = r8712_read8(adapter, EFUSE_TEST + 3);\n\t\ttmpu8 &= 0x7F;\n\t\tr8712_write8(adapter, EFUSE_TEST + 3, tmpu8);\n\t\t \n\t\tr8712_write8(adapter, EFUSE_CLK_CTRL, 0x02);\n\t}\n}\n\n \nu8 r8712_efuse_reg_init(struct _adapter *adapter)\n{\n\treturn true;\n}\n\nvoid r8712_efuse_reg_uninit(struct _adapter *adapter)\n{\n\tefuse_reg_ctrl(adapter, false);\n}\n\nstatic u8 efuse_one_byte_read(struct _adapter *adapter, u16 addr, u8 *data)\n{\n\tu8 tmpidx = 0, bResult;\n\n\t \n\tr8712_write8(adapter, EFUSE_CTRL + 1, (u8)(addr & 0xFF));  \n\tr8712_write8(adapter, EFUSE_CTRL + 2, ((u8)((addr >> 8) & 0x03)) |\n\t       (r8712_read8(adapter, EFUSE_CTRL + 2) & 0xFC));\n\tr8712_write8(adapter, EFUSE_CTRL + 3, 0x72);  \n\t \n\twhile (!(0x80 & r8712_read8(adapter, EFUSE_CTRL + 3)) &&\n\t       (tmpidx < 100))\n\t\ttmpidx++;\n\tif (tmpidx < 100) {\n\t\t*data = r8712_read8(adapter, EFUSE_CTRL);\n\t\tbResult = true;\n\t} else {\n\t\t*data = 0xff;\n\t\tbResult = false;\n\t}\n\treturn bResult;\n}\n\nstatic u8 efuse_one_byte_write(struct _adapter *adapter, u16 addr, u8 data)\n{\n\tu8 tmpidx = 0, bResult;\n\n\t \n\tr8712_write8(adapter, EFUSE_CTRL + 1, (u8)(addr & 0xFF));  \n\tr8712_write8(adapter, EFUSE_CTRL + 2, ((u8)((addr >> 8) & 0x03)) |\n\t       (r8712_read8(adapter, EFUSE_CTRL + 2) & 0xFC));\n\tr8712_write8(adapter, EFUSE_CTRL, data);  \n\tr8712_write8(adapter, EFUSE_CTRL + 3, 0xF2);  \n\t \n\twhile ((0x80 &  r8712_read8(adapter, EFUSE_CTRL + 3)) &&\n\t       (tmpidx < 100))\n\t\ttmpidx++;\n\tif (tmpidx < 100)\n\t\tbResult = true;\n\telse\n\t\tbResult = false;\n\treturn bResult;\n}\n\nstatic u8 efuse_one_byte_rw(struct _adapter *adapter, u8 bRead, u16 addr,\n\t\t\t    u8 *data)\n{\n\tu8 tmpidx = 0, tmpv8 = 0, bResult;\n\n\t \n\tr8712_write8(adapter, EFUSE_CTRL + 1, (u8)(addr & 0xFF));  \n\ttmpv8 = ((u8)((addr >> 8) & 0x03)) |\n\t\t (r8712_read8(adapter, EFUSE_CTRL + 2) & 0xFC);\n\tr8712_write8(adapter, EFUSE_CTRL + 2, tmpv8);\n\tif (bRead) {\n\t\tr8712_write8(adapter, EFUSE_CTRL + 3,  0x72);  \n\t\twhile (!(0x80 & r8712_read8(adapter, EFUSE_CTRL + 3)) &&\n\t\t       (tmpidx < 100))\n\t\t\ttmpidx++;\n\t\tif (tmpidx < 100) {\n\t\t\t*data = r8712_read8(adapter, EFUSE_CTRL);\n\t\t\tbResult = true;\n\t\t} else {\n\t\t\t*data = 0;\n\t\t\tbResult = false;\n\t\t}\n\t} else {\n\t\tr8712_write8(adapter, EFUSE_CTRL, *data);  \n\t\tr8712_write8(adapter, EFUSE_CTRL + 3, 0xF2);  \n\t\twhile ((0x80 & r8712_read8(adapter, EFUSE_CTRL + 3)) &&\n\t\t       (tmpidx < 100))\n\t\t\ttmpidx++;\n\t\tif (tmpidx < 100)\n\t\t\tbResult = true;\n\t\telse\n\t\t\tbResult = false;\n\t}\n\treturn bResult;\n}\n\nstatic u8 efuse_is_empty(struct _adapter *adapter, u8 *empty)\n{\n\tu8 value, ret = true;\n\n\t \n\tif (efuse_one_byte_rw(adapter, true, 0, &value)) {\n\t\tif (value == 0xFF)\n\t\t\t*empty = true;\n\t\telse\n\t\t\t*empty = false;\n\t} else {\n\t\tret = false;\n\t}\n\treturn ret;\n}\n\nvoid r8712_efuse_change_max_size(struct _adapter *adapter)\n{\n\tu16 pre_pg_data_saddr = 0x1FB;\n\tu16 i;\n\tu16 pre_pg_data_size = 5;\n\tu8 pre_pg_data[5];\n\n\tfor (i = 0; i < pre_pg_data_size; i++)\n\t\tefuse_one_byte_read(adapter, pre_pg_data_saddr + i,\n\t\t\t\t    &pre_pg_data[i]);\n\tif ((pre_pg_data[0] == 0x03) && (pre_pg_data[1] == 0x00) &&\n\t    (pre_pg_data[2] == 0x00) && (pre_pg_data[3] == 0x00) &&\n\t    (pre_pg_data[4] == 0x0C))\n\t\tefuse_available_max_size -= pre_pg_data_size;\n}\n\nint r8712_efuse_get_max_size(struct _adapter *adapter)\n{\n\treturn\tefuse_available_max_size;\n}\n\nstatic u8 calculate_word_cnts(const u8 word_en)\n{\n\tu8 word_cnts = 0;\n\tu8 word_idx;\n\n\tfor (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++)\n\t\tif (!(word_en & BIT(word_idx)))\n\t\t\tword_cnts++;  \n\treturn word_cnts;\n}\n\nstatic void pgpacket_copy_data(const u8 word_en, const u8 *sourdata,\n\t\t\t       u8 *targetdata)\n{\n\tu8 tmpindex = 0;\n\tu8 word_idx, byte_idx;\n\n\tfor (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++) {\n\t\tif (!(word_en & BIT(word_idx))) {\n\t\t\tbyte_idx = word_idx * 2;\n\t\t\ttargetdata[byte_idx] = sourdata[tmpindex++];\n\t\t\ttargetdata[byte_idx + 1] = sourdata[tmpindex++];\n\t\t}\n\t}\n}\n\nu16 r8712_efuse_get_current_size(struct _adapter *adapter)\n{\n\tint bContinual = true;\n\tu16 efuse_addr = 0;\n\tu8 hworden = 0;\n\tu8 efuse_data, word_cnts = 0;\n\n\twhile (bContinual && efuse_one_byte_read(adapter, efuse_addr,\n\t       &efuse_data) && (efuse_addr < efuse_available_max_size)) {\n\t\tif (efuse_data != 0xFF) {\n\t\t\thworden =  efuse_data & 0x0F;\n\t\t\tword_cnts = calculate_word_cnts(hworden);\n\t\t\t \n\t\t\tefuse_addr = efuse_addr + (word_cnts * 2) + 1;\n\t\t} else {\n\t\t\tbContinual = false;\n\t\t}\n\t}\n\treturn efuse_addr;\n}\n\nu8 r8712_efuse_pg_packet_read(struct _adapter *adapter, u8 offset, u8 *data)\n{\n\tu8 hoffset = 0, hworden = 0, word_cnts = 0;\n\tu16 efuse_addr = 0;\n\tu8 efuse_data;\n\tu8 tmpidx = 0;\n\tu8 tmpdata[PGPKT_DATA_SIZE];\n\tu8 ret = true;\n\n\tif (!data)\n\t\treturn false;\n\tif (offset > 0x0f)\n\t\treturn false;\n\tmemset(data, 0xFF, sizeof(u8) * PGPKT_DATA_SIZE);\n\twhile (efuse_addr < efuse_available_max_size) {\n\t\tif (efuse_one_byte_read(adapter, efuse_addr, &efuse_data)) {\n\t\t\tif (efuse_data == 0xFF)\n\t\t\t\tbreak;\n\t\t\thoffset = (efuse_data >> 4) & 0x0F;\n\t\t\thworden =  efuse_data & 0x0F;\n\t\t\tword_cnts = calculate_word_cnts(hworden);\n\t\t\tif (hoffset == offset) {\n\t\t\t\tmemset(tmpdata, 0xFF, PGPKT_DATA_SIZE);\n\t\t\t\tfor (tmpidx = 0; tmpidx < word_cnts * 2;\n\t\t\t\t     tmpidx++) {\n\t\t\t\t\tif (efuse_one_byte_read(adapter,\n\t\t\t\t\t    efuse_addr + 1 + tmpidx,\n\t\t\t\t\t    &efuse_data)) {\n\t\t\t\t\t\ttmpdata[tmpidx] = efuse_data;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpgpacket_copy_data(hworden, tmpdata, data);\n\t\t\t}\n\t\t\tefuse_addr += 1 + (word_cnts * 2);\n\t\t} else {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic u8 fix_header(struct _adapter *adapter, u8 header, u16 header_addr)\n{\n\tstruct PGPKT_STRUCT pkt;\n\tu8 offset, word_en, value;\n\tu16 addr;\n\tint i;\n\tu8 ret = true;\n\n\tpkt.offset = GET_EFUSE_OFFSET(header);\n\tpkt.word_en = GET_EFUSE_WORD_EN(header);\n\taddr = header_addr + 1 + calculate_word_cnts(pkt.word_en) * 2;\n\tif (addr > efuse_available_max_size)\n\t\treturn false;\n\t \n\taddr = 0;\n\twhile (addr < header_addr) {\n\t\tif (!efuse_one_byte_read(adapter, addr++, &value)) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t\toffset = GET_EFUSE_OFFSET(value);\n\t\tword_en = GET_EFUSE_WORD_EN(value);\n\t\tif (pkt.offset != offset) {\n\t\t\taddr += calculate_word_cnts(word_en) * 2;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = 0; i < PGPKG_MAX_WORDS; i++) {\n\t\t\tif (!(BIT(i) & word_en))\n\t\t\t\tcontinue;\n\t\t\tif (BIT(i) & pkt.word_en) {\n\t\t\t\tif (efuse_one_byte_read(adapter,\n\t\t\t\t\t\t\taddr,\n\t\t\t\t\t\t\t&value))\n\t\t\t\t\tpkt.data[i * 2] = value;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t\tif (efuse_one_byte_read(adapter,\n\t\t\t\t\t\t\taddr + 1,\n\t\t\t\t\t\t\t&value))\n\t\t\t\t\tpkt.data[i * 2 + 1] = value;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\taddr += 2;\n\t\t}\n\t}\n\tif (addr != header_addr)\n\t\treturn false;\n\taddr++;\n\t \n\tfor (i = 0; i < PGPKG_MAX_WORDS; i++) {\n\t\tif (BIT(i) & pkt.word_en) {\n\t\t\tefuse_one_byte_write(adapter, addr, pkt.data[i * 2]);\n\t\t\tefuse_one_byte_write(adapter, addr + 1,\n\t\t\t\t\t     pkt.data[i * 2 + 1]);\n\t\t\t \n\t\t\tif (!efuse_one_byte_read(adapter, addr, &value)) {\n\t\t\t\tret = false;\n\t\t\t} else if (pkt.data[i * 2] != value) {\n\t\t\t\tret = false;\n\t\t\t\tif (value == 0xFF)  \n\t\t\t\t\tefuse_one_byte_write(adapter, addr,\n\t\t\t\t\t\t\t     pkt.data[i * 2]);\n\t\t\t}\n\t\t\tif (!efuse_one_byte_read(adapter, addr + 1, &value)) {\n\t\t\t\tret = false;\n\t\t\t} else if (pkt.data[i * 2 + 1] != value) {\n\t\t\t\tret = false;\n\t\t\t\tif (value == 0xFF)  \n\t\t\t\t\tefuse_one_byte_write(adapter, addr + 1,\n\t\t\t\t\t\t\t     pkt.data[i * 2 +\n\t\t\t\t\t\t\t\t      1]);\n\t\t\t}\n\t\t}\n\t\taddr += 2;\n\t}\n\treturn ret;\n}\n\nu8 r8712_efuse_pg_packet_write(struct _adapter *adapter, const u8 offset,\n\t\t\t       const u8 word_en, const u8 *data)\n{\n\tu8 pg_header = 0;\n\tu16 efuse_addr = 0, curr_size = 0;\n\tu8 efuse_data, target_word_cnts = 0;\n\tint repeat_times;\n\tint sub_repeat;\n\tu8 bResult = true;\n\n\t \n\tefuse_data = r8712_read8(adapter, EFUSE_CLK_CTRL);\n\tif (efuse_data != 0x03)\n\t\treturn false;\n\tpg_header = MAKE_EFUSE_HEADER(offset, word_en);\n\ttarget_word_cnts = calculate_word_cnts(word_en);\n\trepeat_times = 0;\n\tefuse_addr = 0;\n\twhile (efuse_addr < efuse_available_max_size) {\n\t\tcurr_size = r8712_efuse_get_current_size(adapter);\n\t\tif ((curr_size + 1 + target_word_cnts * 2) >\n\t\t     efuse_available_max_size)\n\t\t\treturn false;  \n\t\tefuse_addr = curr_size;  \n\t\tefuse_one_byte_write(adapter, efuse_addr, pg_header);  \n\t\tsub_repeat = 0;\n\t\t \n\t\twhile (!efuse_one_byte_read(adapter, efuse_addr,\n\t\t\t\t\t    &efuse_data)) {\n\t\t\tif (++sub_repeat > _REPEAT_THRESHOLD_) {\n\t\t\t\tbResult = false;  \n\t\t\t\tbreak;  \n\t\t\t}\n\t\t}\n\t\tif ((sub_repeat > _REPEAT_THRESHOLD_) ||\n\t\t    (pg_header == efuse_data)) {\n\t\t\t \n\t\t\tu8 i;\n\n\t\t\t \n\t\t\tefuse_addr++;\n\t\t\tfor (i = 0; i < target_word_cnts * 2; i++) {\n\t\t\t\tefuse_one_byte_write(adapter,\n\t\t\t\t\t\t     efuse_addr + i,\n\t\t\t\t\t\t     *(data + i));\n\t\t\t\tif (!efuse_one_byte_read(adapter,\n\t\t\t\t\t\t\t efuse_addr + i,\n\t\t\t\t\t\t\t &efuse_data))\n\t\t\t\t\tbResult = false;\n\t\t\t\telse if (*(data + i) != efuse_data)  \n\t\t\t\t\tbResult = false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tbResult = false;\n\t\tif (efuse_data == 0xFF)\n\t\t\treturn bResult;  \n\t\t \n\t\tif (!fix_header(adapter, efuse_data, efuse_addr))\n\t\t\treturn false;  \n\n\t\tif (++repeat_times > _REPEAT_THRESHOLD_)  \n\t\t\tbreak;\n\t\t \n\t}\n\treturn bResult;\n}\n\nu8 r8712_efuse_access(struct _adapter *adapter, u8 bRead, u16 start_addr,\n\t\t      u16 cnts, u8 *data)\n{\n\tint i;\n\tu8 res = true;\n\n\tif (start_addr > EFUSE_MAX_SIZE)\n\t\treturn false;\n\tif (!bRead && ((start_addr + cnts) >\n\t   efuse_available_max_size))\n\t\treturn false;\n\tif (!bRead && !r8712_efuse_reg_init(adapter))\n\t\treturn false;\n\t \n\tfor (i = 0; i < cnts; i++) {\n\t\tif ((start_addr + i) > EFUSE_MAX_SIZE) {\n\t\t\tres = false;\n\t\t\tbreak;\n\t\t}\n\t\tres = efuse_one_byte_rw(adapter, bRead, start_addr + i,\n\t\t\t\t\tdata + i);\n\t\tif (!bRead && !res)\n\t\t\tbreak;\n\t}\n\tif (!bRead)\n\t\tr8712_efuse_reg_uninit(adapter);\n\treturn res;\n}\n\nu8 r8712_efuse_map_read(struct _adapter *adapter, u16 addr, u16 cnts, u8 *data)\n{\n\tu8 offset, ret = true;\n\tu8 pktdata[PGPKT_DATA_SIZE];\n\tint i, idx;\n\n\tif ((addr + cnts) > EFUSE_MAP_MAX_SIZE)\n\t\treturn false;\n\tif (efuse_is_empty(adapter, &offset) && offset) {\n\t\tfor (i = 0; i < cnts; i++)\n\t\t\tdata[i] = 0xFF;\n\t\treturn ret;\n\t}\n\toffset = (addr >> 3) & 0xF;\n\tret = r8712_efuse_pg_packet_read(adapter, offset, pktdata);\n\ti = addr & 0x7;\t \n\tidx = 0;\t \n\n\tdo {\n\t\tfor (; i < PGPKT_DATA_SIZE; i++) {\n\t\t\tdata[idx++] = pktdata[i];\n\t\t\tif (idx == cnts)\n\t\t\t\treturn ret;\n\t\t}\n\t\toffset++;\n\t\tif (!r8712_efuse_pg_packet_read(adapter, offset, pktdata))\n\t\t\tret = false;\n\t\ti = 0;\n\t} while (1);\n\treturn ret;\n}\n\nu8 r8712_efuse_map_write(struct _adapter *adapter, u16 addr, u16 cnts,\n\t\t\t u8 *data)\n{\n\tu8 offset, word_en, empty;\n\tu8 pktdata[PGPKT_DATA_SIZE], newdata[PGPKT_DATA_SIZE];\n\tint i, j, idx;\n\n\tif ((addr + cnts) > EFUSE_MAP_MAX_SIZE)\n\t\treturn false;\n\t \n\tempty = r8712_read8(adapter, EFUSE_CLK_CTRL);\n\tif (empty != 0x03)\n\t\treturn false;\n\tif (efuse_is_empty(adapter, &empty)) {\n\t\tif (empty)\n\t\t\tmemset(pktdata, 0xFF, PGPKT_DATA_SIZE);\n\t} else {\n\t\treturn false;\n\t}\n\toffset = (addr >> 3) & 0xF;\n\tif (!empty)\n\t\tif (!r8712_efuse_pg_packet_read(adapter, offset, pktdata))\n\t\t\treturn false;\n\tword_en = 0xF;\n\tmemset(newdata, 0xFF, PGPKT_DATA_SIZE);\n\ti = addr & 0x7;\t \n\tj = 0;\t\t \n\tidx = 0;\t \n\n\tif (i & 0x1) {\n\t\t \n\t\tif (data[idx] != pktdata[i]) {\n\t\t\tword_en &= ~BIT(i >> 1);\n\t\t\tnewdata[j++] = pktdata[i - 1];\n\t\t\tnewdata[j++] = data[idx];\n\t\t}\n\t\ti++;\n\t\tidx++;\n\t}\n\tdo {\n\t\tfor (; i < PGPKT_DATA_SIZE; i += 2) {\n\t\t\tif ((cnts - idx) == 1) {\n\t\t\t\tif (data[idx] != pktdata[i]) {\n\t\t\t\t\tword_en &= ~BIT(i >> 1);\n\t\t\t\t\tnewdata[j++] = data[idx];\n\t\t\t\t\tnewdata[j++] = pktdata[1 + 1];\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((data[idx] != pktdata[i]) || (data[idx + 1] !=\n\t\t\t     pktdata[i + 1])) {\n\t\t\t\tword_en &= ~BIT(i >> 1);\n\t\t\t\tnewdata[j++] = data[idx];\n\t\t\t\tnewdata[j++] = data[idx + 1];\n\t\t\t}\n\t\t\tidx += 2;\n\n\t\t\tif (idx == cnts)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (word_en != 0xF)\n\t\t\tif (!r8712_efuse_pg_packet_write(adapter, offset,\n\t\t\t\t\t\t\t word_en, newdata))\n\t\t\t\treturn false;\n\t\tif (idx == cnts)\n\t\t\tbreak;\n\t\toffset++;\n\t\tif (!empty)\n\t\t\tif (!r8712_efuse_pg_packet_read(adapter, offset,\n\t\t\t\t\t\t\tpktdata))\n\t\t\t\treturn false;\n\t\ti = 0;\n\t\tj = 0;\n\t\tword_en = 0xF;\n\t\tmemset(newdata, 0xFF, PGPKT_DATA_SIZE);\n\t} while (1);\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}