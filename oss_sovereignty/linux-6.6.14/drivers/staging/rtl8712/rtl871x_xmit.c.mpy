{
  "module_name": "rtl871x_xmit.c",
  "hash_id": "13f01c1fa0dfe491038ecaa5613847f685da05977ec03241711cfca487bb846e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8712/rtl871x_xmit.c",
  "human_readable_source": "\n \n\n#define _RTL871X_XMIT_C_\n\n#include \"osdep_service.h\"\n#include \"drv_types.h\"\n#include \"osdep_intf.h\"\n#include \"usb_ops.h\"\n\n#include <linux/usb.h>\n#include <linux/ieee80211.h>\n\nstatic const u8 P802_1H_OUI[P80211_OUI_LEN] = {0x00, 0x00, 0xf8};\nstatic const u8 RFC1042_OUI[P80211_OUI_LEN] = {0x00, 0x00, 0x00};\nstatic void init_hwxmits(struct hw_xmit *phwxmit, sint entry);\nstatic void alloc_hwxmits(struct _adapter *padapter);\nstatic void free_hwxmits(struct _adapter *padapter);\n\nstatic void _init_txservq(struct tx_servq *ptxservq)\n{\n\tINIT_LIST_HEAD(&ptxservq->tx_pending);\n\t_init_queue(&ptxservq->sta_pending);\n\tptxservq->qcnt = 0;\n}\n\nvoid _r8712_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)\n{\n\tmemset((unsigned char *)psta_xmitpriv, 0,\n\t\t sizeof(struct sta_xmit_priv));\n\tspin_lock_init(&psta_xmitpriv->lock);\n\t_init_txservq(&psta_xmitpriv->be_q);\n\t_init_txservq(&psta_xmitpriv->bk_q);\n\t_init_txservq(&psta_xmitpriv->vi_q);\n\t_init_txservq(&psta_xmitpriv->vo_q);\n\tINIT_LIST_HEAD(&psta_xmitpriv->legacy_dz);\n\tINIT_LIST_HEAD(&psta_xmitpriv->apsd);\n}\n\nint _r8712_init_xmit_priv(struct xmit_priv *pxmitpriv,\n\t\t\t  struct _adapter *padapter)\n{\n\tsint i;\n\tstruct xmit_buf *pxmitbuf;\n\tstruct xmit_frame *pxframe;\n\tint j;\n\n\tmemset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv));\n\tspin_lock_init(&pxmitpriv->lock);\n\t \n\tpxmitpriv->adapter = padapter;\n\t_init_queue(&pxmitpriv->be_pending);\n\t_init_queue(&pxmitpriv->bk_pending);\n\t_init_queue(&pxmitpriv->vi_pending);\n\t_init_queue(&pxmitpriv->vo_pending);\n\t_init_queue(&pxmitpriv->bm_pending);\n\t_init_queue(&pxmitpriv->legacy_dz_queue);\n\t_init_queue(&pxmitpriv->apsd_queue);\n\t_init_queue(&pxmitpriv->free_xmit_queue);\n\t \n\tpxmitpriv->pallocated_frame_buf =\n\t\tkmalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4,\n\t\t\tGFP_ATOMIC);\n\tif (!pxmitpriv->pallocated_frame_buf) {\n\t\tpxmitpriv->pxmit_frame_buf = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tpxmitpriv->pxmit_frame_buf = pxmitpriv->pallocated_frame_buf + 4 -\n\t\t\t((addr_t) (pxmitpriv->pallocated_frame_buf) & 3);\n\tpxframe = (struct xmit_frame *) pxmitpriv->pxmit_frame_buf;\n\tfor (i = 0; i < NR_XMITFRAME; i++) {\n\t\tINIT_LIST_HEAD(&(pxframe->list));\n\t\tpxframe->padapter = padapter;\n\t\tpxframe->frame_tag = DATA_FRAMETAG;\n\t\tpxframe->pkt = NULL;\n\t\tpxframe->buf_addr = NULL;\n\t\tpxframe->pxmitbuf = NULL;\n\t\tlist_add_tail(&(pxframe->list),\n\t\t\t\t &(pxmitpriv->free_xmit_queue.queue));\n\t\tpxframe++;\n\t}\n\tpxmitpriv->free_xmitframe_cnt = NR_XMITFRAME;\n\t \n\t_r8712_init_hw_txqueue(&pxmitpriv->be_txqueue, BE_QUEUE_INX);\n\t_r8712_init_hw_txqueue(&pxmitpriv->bk_txqueue, BK_QUEUE_INX);\n\t_r8712_init_hw_txqueue(&pxmitpriv->vi_txqueue, VI_QUEUE_INX);\n\t_r8712_init_hw_txqueue(&pxmitpriv->vo_txqueue, VO_QUEUE_INX);\n\t_r8712_init_hw_txqueue(&pxmitpriv->bmc_txqueue, BMC_QUEUE_INX);\n\tpxmitpriv->frag_len = MAX_FRAG_THRESHOLD;\n\tpxmitpriv->txirp_cnt = 1;\n\t \n\tpxmitpriv->beq_cnt = 0;\n\tpxmitpriv->bkq_cnt = 0;\n\tpxmitpriv->viq_cnt = 0;\n\tpxmitpriv->voq_cnt = 0;\n\t \n\t_init_queue(&pxmitpriv->free_xmitbuf_queue);\n\t_init_queue(&pxmitpriv->pending_xmitbuf_queue);\n\tpxmitpriv->pallocated_xmitbuf =\n\t\tkmalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4, GFP_ATOMIC);\n\tif (!pxmitpriv->pallocated_xmitbuf)\n\t\tgoto clean_up_frame_buf;\n\tpxmitpriv->pxmitbuf = pxmitpriv->pallocated_xmitbuf + 4 -\n\t\t\t      ((addr_t)(pxmitpriv->pallocated_xmitbuf) & 3);\n\tpxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;\n\tfor (i = 0; i < NR_XMITBUFF; i++) {\n\t\tINIT_LIST_HEAD(&pxmitbuf->list);\n\t\tpxmitbuf->pallocated_buf =\n\t\t\tkmalloc(MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ, GFP_ATOMIC);\n\t\tif (!pxmitbuf->pallocated_buf) {\n\t\t\tj = 0;\n\t\t\tgoto clean_up_alloc_buf;\n\t\t}\n\t\tpxmitbuf->pbuf = pxmitbuf->pallocated_buf + XMITBUF_ALIGN_SZ -\n\t\t\t\t ((addr_t) (pxmitbuf->pallocated_buf) &\n\t\t\t\t (XMITBUF_ALIGN_SZ - 1));\n\t\tif (r8712_xmit_resource_alloc(padapter, pxmitbuf)) {\n\t\t\tj = 1;\n\t\t\tgoto clean_up_alloc_buf;\n\t\t}\n\t\tlist_add_tail(&pxmitbuf->list,\n\t\t\t\t &(pxmitpriv->free_xmitbuf_queue.queue));\n\t\tpxmitbuf++;\n\t}\n\tpxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;\n\tINIT_WORK(&padapter->wk_filter_rx_ff0, r8712_SetFilter);\n\talloc_hwxmits(padapter);\n\tinit_hwxmits(pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);\n\ttasklet_setup(&pxmitpriv->xmit_tasklet, r8712_xmit_bh);\n\treturn 0;\n\nclean_up_alloc_buf:\n\tif (j) {\n\t\t \n\t\tkfree(pxmitbuf->pallocated_buf);\n\t}\n\tfor (j = 0; j < i; j++) {\n\t\tint k;\n\n\t\tpxmitbuf--;\t\t\t \n\t\tkfree(pxmitbuf->pallocated_buf);\n\t\tfor (k = 0; k < 8; k++)\t\t \n\t\t\tusb_free_urb(pxmitbuf->pxmit_urb[k]);\n\t}\n\tkfree(pxmitpriv->pallocated_xmitbuf);\n\tpxmitpriv->pallocated_xmitbuf = NULL;\nclean_up_frame_buf:\n\tkfree(pxmitpriv->pallocated_frame_buf);\n\tpxmitpriv->pallocated_frame_buf = NULL;\n\treturn -ENOMEM;\n}\n\nvoid _free_xmit_priv(struct xmit_priv *pxmitpriv)\n{\n\tint i;\n\tstruct _adapter *padapter = pxmitpriv->adapter;\n\tstruct xmit_frame *pxmitframe = (struct xmit_frame *)\n\t\t\t\t\tpxmitpriv->pxmit_frame_buf;\n\tstruct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;\n\n\tif (!pxmitpriv->pxmit_frame_buf)\n\t\treturn;\n\tfor (i = 0; i < NR_XMITFRAME; i++) {\n\t\tr8712_xmit_complete(padapter, pxmitframe);\n\t\tpxmitframe++;\n\t}\n\tfor (i = 0; i < NR_XMITBUFF; i++) {\n\t\tr8712_xmit_resource_free(padapter, pxmitbuf);\n\t\tkfree(pxmitbuf->pallocated_buf);\n\t\tpxmitbuf++;\n\t}\n\tkfree(pxmitpriv->pallocated_frame_buf);\n\tkfree(pxmitpriv->pallocated_xmitbuf);\n\tfree_hwxmits(padapter);\n}\n\nint r8712_update_attrib(struct _adapter *padapter, _pkt *pkt,\n\t\t\tstruct pkt_attrib *pattrib)\n{\n\tstruct pkt_file pktfile;\n\tstruct sta_info *psta = NULL;\n\tstruct ethhdr etherhdr;\n\n\tstruct tx_cmd txdesc;\n\n\tbool bmcast;\n\tstruct sta_priv\t\t*pstapriv = &padapter->stapriv;\n\tstruct security_priv\t*psecuritypriv = &padapter->securitypriv;\n\tstruct mlme_priv\t*pmlmepriv = &padapter->mlmepriv;\n\tstruct qos_priv\t\t*pqospriv = &pmlmepriv->qospriv;\n\n\t_r8712_open_pktfile(pkt, &pktfile);\n\n\t_r8712_pktfile_read(&pktfile, (unsigned char *)&etherhdr, ETH_HLEN);\n\n\tpattrib->ether_type = ntohs(etherhdr.h_proto);\n\n\t \n\tif (pattrib->ether_type == 0x0806) {\n\t\tif (padapter->pwrctrlpriv.pwr_mode !=\n\t\t    padapter->registrypriv.power_mgnt) {\n\t\t\tdel_timer_sync(&pmlmepriv->dhcp_timer);\n\t\t\tr8712_set_ps_mode(padapter,\n\t\t\t\t\t  padapter->registrypriv.power_mgnt,\n\t\t\t\t\t  padapter->registrypriv.smart_ps);\n\t\t}\n\t}\n\n\tmemcpy(pattrib->dst, &etherhdr.h_dest, ETH_ALEN);\n\tmemcpy(pattrib->src, &etherhdr.h_source, ETH_ALEN);\n\tpattrib->pctrl = 0;\n\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) ||\n\t    check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\n\t\tmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\n\t} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\n\t\tmemcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);\n\t\tmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\n\t} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\tmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);\n\t} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\n\t\t \n\t\tif (pattrib->ether_type != 0x8712)\n\t\t\treturn -EINVAL;\n\t\t \n\t\t \n\t\t_r8712_pktfile_read(&pktfile, (u8 *)&txdesc, TXDESC_SIZE);\n\t\tmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\n\t\tpattrib->pctrl = 1;\n\t}\n\t \n\tpattrib->pktlen = pktfile.pkt_len;\n\tif (pattrib->ether_type == ETH_P_IP) {\n\t\t \n\t\tu8 tmp[24];\n\n\t\t_r8712_pktfile_read(&pktfile, &tmp[0], 24);\n\t\tpattrib->dhcp_pkt = 0;\n\t\tif (pktfile.pkt_len > 282) { \n\t\t\tif (pattrib->ether_type == ETH_P_IP) { \n\t\t\t\tif (((tmp[21] == 68) && (tmp[23] == 67)) ||\n\t\t\t\t\t((tmp[21] == 67) && (tmp[23] == 68))) {\n\t\t\t\t\t \n\t\t\t\t\tpattrib->dhcp_pkt = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbmcast = is_multicast_ether_addr(pattrib->ra);\n\t \n\tif (bmcast) {\n\t\tpsta = r8712_get_bcmc_stainfo(padapter);\n\t\tpattrib->mac_id = 4;\n\t} else {\n\t\tif (check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\n\t\t\tpsta = r8712_get_stainfo(pstapriv,\n\t\t\t\t\t\t get_bssid(pmlmepriv));\n\t\t\tpattrib->mac_id = 5;\n\t\t} else {\n\t\t\tpsta = r8712_get_stainfo(pstapriv, pattrib->ra);\n\t\t\tif (!psta)   \n\t\t\t\treturn -ENOMEM;\n\t\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE))\n\t\t\t\tpattrib->mac_id = 5;\n\t\t\telse\n\t\t\t\tpattrib->mac_id = psta->mac_id;\n\t\t}\n\t}\n\n\tif (psta) {\n\t\tpattrib->psta = psta;\n\t} else {\n\t\t \n\t\treturn -ENOMEM;\n\t}\n\n\tpattrib->ack_policy = 0;\n\t \n\tpattrib->pkt_hdrlen = ETH_HLEN;\n\n\tif (pqospriv->qos_option) {\n\t\tr8712_set_qos(&pktfile, pattrib);\n\t} else {\n\t\tpattrib->hdrlen = WLAN_HDR_A3_LEN;\n\t\tpattrib->subtype = IEEE80211_FTYPE_DATA;\n\t\tpattrib->priority = 0;\n\t}\n\tif (psta->ieee8021x_blocked) {\n\t\tpattrib->encrypt = 0;\n\t\tif ((pattrib->ether_type != 0x888e) &&\n\t\t    !check_fwstate(pmlmepriv, WIFI_MP_STATE))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tGET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);\n\t}\n\tswitch (pattrib->encrypt) {\n\tcase _WEP40_:\n\tcase _WEP104_:\n\t\tpattrib->iv_len = 4;\n\t\tpattrib->icv_len = 4;\n\t\tbreak;\n\tcase _TKIP_:\n\t\tpattrib->iv_len = 8;\n\t\tpattrib->icv_len = 4;\n\t\tif (padapter->securitypriv.busetkipkey == _FAIL)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase _AES_:\n\t\tpattrib->iv_len = 8;\n\t\tpattrib->icv_len = 8;\n\t\tbreak;\n\tdefault:\n\t\tpattrib->iv_len = 0;\n\t\tpattrib->icv_len = 0;\n\t\tbreak;\n\t}\n\n\tif (pattrib->encrypt &&\n\t    (padapter->securitypriv.sw_encrypt ||\n\t    !psecuritypriv->hw_decrypted))\n\t\tpattrib->bswenc = true;\n\telse\n\t\tpattrib->bswenc = false;\n\t \n\tif (check_fwstate(pmlmepriv, WIFI_MP_STATE))\n\t\tpattrib->priority =\n\t\t    (le32_to_cpu(txdesc.txdw1) >> QSEL_SHT) & 0x1f;\n\treturn 0;\n}\n\nstatic int xmitframe_addmic(struct _adapter *padapter,\n\t\t\t    struct xmit_frame *pxmitframe)\n{\n\tu32\tcurfragnum, length;\n\tu8\t*pframe, *payload, mic[8];\n\tstruct\tmic_data micdata;\n\tstruct\tsta_info *stainfo;\n\tstruct\tqos_priv *pqospriv = &(padapter->mlmepriv.qospriv);\n\tstruct\tpkt_attrib  *pattrib = &pxmitframe->attrib;\n\tstruct\tsecurity_priv *psecpriv = &padapter->securitypriv;\n\tstruct\txmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tu8 priority[4] = {};\n\tbool bmcst = is_multicast_ether_addr(pattrib->ra);\n\n\tif (pattrib->psta)\n\t\tstainfo = pattrib->psta;\n\telse\n\t\tstainfo = r8712_get_stainfo(&padapter->stapriv,\n\t\t\t\t\t    &pattrib->ra[0]);\n\tif (pattrib->encrypt == _TKIP_) {\n\t\t \n\t\tif (stainfo) {\n\t\t\tu8 null_key[16] = {};\n\n\t\t\tpframe = pxmitframe->buf_addr + TXDESC_OFFSET;\n\t\t\tif (bmcst) {\n\t\t\t\tif (!memcmp(psecpriv->XGrptxmickey\n\t\t\t\t   [psecpriv->XGrpKeyid].skey,\n\t\t\t\t   null_key, 16))\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t \n\t\t\t\tr8712_secmicsetkey(&micdata,\n\t\t\t\t\tpsecpriv->XGrptxmickey\n\t\t\t\t\t[psecpriv->XGrpKeyid].skey);\n\t\t\t} else {\n\t\t\t\tif (!memcmp(&stainfo->tkiptxmickey.skey[0],\n\t\t\t\t\t    null_key, 16))\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t \n\t\t\t\tr8712_secmicsetkey(&micdata,\n\t\t\t\t\t     &stainfo->tkiptxmickey.skey[0]);\n\t\t\t}\n\t\t\tif (pframe[1] & 1) {    \n\t\t\t\tr8712_secmicappend(&micdata,\n\t\t\t\t\t\t   &pframe[16], 6);  \n\t\t\t\tif (pframe[1] & 2)   \n\t\t\t\t\tr8712_secmicappend(&micdata,\n\t\t\t\t\t\t\t   &pframe[24], 6);\n\t\t\t\telse\n\t\t\t\t\tr8712_secmicappend(&micdata,\n\t\t\t\t\t\t\t   &pframe[10], 6);\n\t\t\t} else {\t \n\t\t\t\tr8712_secmicappend(&micdata,\n\t\t\t\t\t\t   &pframe[4], 6);  \n\t\t\t\tif (pframe[1] & 2)   \n\t\t\t\t\tr8712_secmicappend(&micdata,\n\t\t\t\t\t\t\t   &pframe[16], 6);\n\t\t\t\telse\n\t\t\t\t\tr8712_secmicappend(&micdata,\n\t\t\t\t\t\t\t   &pframe[10], 6);\n\t\t\t}\n\t\t\tif (pqospriv->qos_option == 1)\n\t\t\t\tpriority[0] = (u8)pxmitframe->attrib.priority;\n\t\t\tr8712_secmicappend(&micdata, &priority[0], 4);\n\t\t\tpayload = pframe;\n\t\t\tfor (curfragnum = 0; curfragnum < pattrib->nr_frags;\n\t\t\t     curfragnum++) {\n\t\t\t\tpayload = (u8 *)RND4((addr_t)(payload));\n\t\t\t\tpayload += pattrib->hdrlen + pattrib->iv_len;\n\t\t\t\tif ((curfragnum + 1) == pattrib->nr_frags) {\n\t\t\t\t\tlength = pattrib->last_txcmdsz -\n\t\t\t\t\t\t  pattrib->hdrlen -\n\t\t\t\t\t\t  pattrib->iv_len -\n\t\t\t\t\t\t  ((psecpriv->sw_encrypt)\n\t\t\t\t\t\t  ? pattrib->icv_len : 0);\n\t\t\t\t\tr8712_secmicappend(&micdata, payload,\n\t\t\t\t\t\t\t   length);\n\t\t\t\t\tpayload = payload + length;\n\t\t\t\t} else {\n\t\t\t\t\tlength = pxmitpriv->frag_len -\n\t\t\t\t\t    pattrib->hdrlen - pattrib->iv_len -\n\t\t\t\t\t    ((psecpriv->sw_encrypt) ?\n\t\t\t\t\t    pattrib->icv_len : 0);\n\t\t\t\t\tr8712_secmicappend(&micdata, payload,\n\t\t\t\t\t\t\t   length);\n\t\t\t\t\tpayload = payload + length +\n\t\t\t\t\t\t  pattrib->icv_len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr8712_secgetmic(&micdata, &(mic[0]));\n\t\t\t \n\t\t\tmemcpy(payload, &(mic[0]), 8);\n\t\t\tpattrib->last_txcmdsz += 8;\n\t\t\tpayload = payload - pattrib->last_txcmdsz + 8;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic sint xmitframe_swencrypt(struct _adapter *padapter,\n\t\t\t\tstruct xmit_frame *pxmitframe)\n{\n\tstruct pkt_attrib\t*pattrib = &pxmitframe->attrib;\n\n\tif (pattrib->bswenc) {\n\t\tswitch (pattrib->encrypt) {\n\t\tcase _WEP40_:\n\t\tcase _WEP104_:\n\t\t\tr8712_wep_encrypt(padapter, (u8 *)pxmitframe);\n\t\t\tbreak;\n\t\tcase _TKIP_:\n\t\t\tr8712_tkip_encrypt(padapter, (u8 *)pxmitframe);\n\t\t\tbreak;\n\t\tcase _AES_:\n\t\t\tr8712_aes_encrypt(padapter, (u8 *)pxmitframe);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn _SUCCESS;\n}\n\nstatic int make_wlanhdr(struct _adapter *padapter, u8 *hdr,\n\t\t\tstruct pkt_attrib *pattrib)\n{\n\tu16 *qc;\n\n\tstruct ieee80211_hdr *pwlanhdr = (struct ieee80211_hdr *)hdr;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\n\t__le16 *fctrl = &pwlanhdr->frame_control;\n\tu8 *bssid;\n\n\tmemset(hdr, 0, WLANHDR_OFFSET);\n\tSetFrameSubType(fctrl, pattrib->subtype);\n\tif (!(pattrib->subtype & IEEE80211_FTYPE_DATA))\n\t\treturn 0;\n\n\tbssid = get_bssid(pmlmepriv);\n\n\tif (check_fwstate(pmlmepriv,  WIFI_STATION_STATE)) {\n\t\t \n\t\tSetToDs(fctrl);\n\t\tether_addr_copy(pwlanhdr->addr1, bssid);\n\t\tether_addr_copy(pwlanhdr->addr2, pattrib->src);\n\t\tether_addr_copy(pwlanhdr->addr3, pattrib->dst);\n\t} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\t \n\t\tSetFrDs(fctrl);\n\t\tether_addr_copy(pwlanhdr->addr1, pattrib->dst);\n\t\tether_addr_copy(pwlanhdr->addr2, bssid);\n\t\tether_addr_copy(pwlanhdr->addr3, pattrib->src);\n\t} else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) ||\n\t\t   check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\n\t\tether_addr_copy(pwlanhdr->addr1, pattrib->dst);\n\t\tether_addr_copy(pwlanhdr->addr2, pattrib->src);\n\t\tether_addr_copy(pwlanhdr->addr3, bssid);\n\t} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\n\t\tether_addr_copy(pwlanhdr->addr1, pattrib->dst);\n\t\tether_addr_copy(pwlanhdr->addr2, pattrib->src);\n\t\tether_addr_copy(pwlanhdr->addr3, bssid);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (pattrib->encrypt)\n\t\tSetPrivacy(fctrl);\n\tif (pqospriv->qos_option) {\n\t\tqc = (unsigned short *)(hdr + pattrib->hdrlen - 2);\n\t\tif (pattrib->priority)\n\t\t\tSetPriority(qc, pattrib->priority);\n\t\tSetAckpolicy(qc, pattrib->ack_policy);\n\t}\n\t \n\t \n\t{\n\t\tstruct sta_info *psta;\n\t\tbool bmcst = is_multicast_ether_addr(pattrib->ra);\n\n\t\tif (pattrib->psta)\n\t\t\tpsta = pattrib->psta;\n\t\telse if (bmcst)\n\t\t\tpsta = r8712_get_bcmc_stainfo(padapter);\n\t\telse\n\t\t\tpsta = r8712_get_stainfo(&padapter->stapriv,\n\t\t\t\t\t\t pattrib->ra);\n\n\t\tif (psta) {\n\t\t\tu16 *txtid = psta->sta_xmitpriv.txseq_tid;\n\n\t\t\ttxtid[pattrib->priority]++;\n\t\t\ttxtid[pattrib->priority] &= 0xFFF;\n\t\t\tpattrib->seqnum = txtid[pattrib->priority];\n\t\t\tSetSeqNum(hdr, pattrib->seqnum);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic sint r8712_put_snap(u8 *data, u16 h_proto)\n{\n\tstruct ieee80211_snap_hdr *snap;\n\tconst u8 *oui;\n\n\tsnap = (struct ieee80211_snap_hdr *)data;\n\tsnap->dsap = 0xaa;\n\tsnap->ssap = 0xaa;\n\tsnap->ctrl = 0x03;\n\tif (h_proto == 0x8137 || h_proto == 0x80f3)\n\t\toui = P802_1H_OUI;\n\telse\n\t\toui = RFC1042_OUI;\n\tsnap->oui[0] = oui[0];\n\tsnap->oui[1] = oui[1];\n\tsnap->oui[2] = oui[2];\n\t*(__be16 *)(data + SNAP_SIZE) = htons(h_proto);\n\treturn SNAP_SIZE + sizeof(u16);\n}\n\n \nsint r8712_xmitframe_coalesce(struct _adapter *padapter, _pkt *pkt,\n\t\t\tstruct xmit_frame *pxmitframe)\n{\n\tstruct pkt_file pktfile;\n\n\tsint\tfrg_len, mpdu_len, llc_sz;\n\tu32\tmem_sz;\n\tu8\tfrg_inx;\n\taddr_t addr;\n\tu8 *pframe, *mem_start, *ptxdesc;\n\tstruct sta_info\t\t*psta;\n\tstruct security_priv\t*psecpriv = &padapter->securitypriv;\n\tstruct mlme_priv\t*pmlmepriv = &padapter->mlmepriv;\n\tstruct xmit_priv\t*pxmitpriv = &padapter->xmitpriv;\n\tstruct pkt_attrib\t*pattrib = &pxmitframe->attrib;\n\tu8 *pbuf_start;\n\tbool bmcst = is_multicast_ether_addr(pattrib->ra);\n\n\tif (!pattrib->psta)\n\t\treturn _FAIL;\n\tpsta = pattrib->psta;\n\tif (!pxmitframe->buf_addr)\n\t\treturn _FAIL;\n\tpbuf_start = pxmitframe->buf_addr;\n\tptxdesc = pbuf_start;\n\tmem_start = pbuf_start + TXDESC_OFFSET;\n\tif (make_wlanhdr(padapter, mem_start, pattrib))\n\t\treturn _FAIL;\n\t_r8712_open_pktfile(pkt, &pktfile);\n\t_r8712_pktfile_read(&pktfile, NULL, (uint) pattrib->pkt_hdrlen);\n\tif (check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\n\t\t \n\t\tif (pattrib->ether_type == 0x8712) {\n\t\t\t \n\t\t\t_r8712_pktfile_read(&pktfile, ptxdesc, TXDESC_SIZE);\n\t\t}\n\t}\n\tpattrib->pktlen = pktfile.pkt_len;\n\tfrg_inx = 0;\n\tfrg_len = pxmitpriv->frag_len - 4;\n\twhile (1) {\n\t\tllc_sz = 0;\n\t\tmpdu_len = frg_len;\n\t\tpframe = mem_start;\n\t\tSetMFrag(mem_start);\n\t\tpframe += pattrib->hdrlen;\n\t\tmpdu_len -= pattrib->hdrlen;\n\t\t \n\t\tif (pattrib->iv_len) {\n\t\t\tif (psta) {\n\t\t\t\tswitch (pattrib->encrypt) {\n\t\t\t\tcase _WEP40_:\n\t\t\t\tcase _WEP104_:\n\t\t\t\t\tWEP_IV(pattrib->iv, psta->txpn,\n\t\t\t\t\t       (u8)psecpriv->PrivacyKeyIndex);\n\t\t\t\t\tbreak;\n\t\t\t\tcase _TKIP_:\n\t\t\t\t\tif (bmcst)\n\t\t\t\t\t\tTKIP_IV(pattrib->iv,\n\t\t\t\t\t\t    psta->txpn,\n\t\t\t\t\t\t    (u8)psecpriv->XGrpKeyid);\n\t\t\t\t\telse\n\t\t\t\t\t\tTKIP_IV(pattrib->iv, psta->txpn,\n\t\t\t\t\t\t\t0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase _AES_:\n\t\t\t\t\tif (bmcst)\n\t\t\t\t\t\tAES_IV(pattrib->iv, psta->txpn,\n\t\t\t\t\t\t    (u8)psecpriv->XGrpKeyid);\n\t\t\t\t\telse\n\t\t\t\t\t\tAES_IV(pattrib->iv, psta->txpn,\n\t\t\t\t\t\t       0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(pframe, pattrib->iv, pattrib->iv_len);\n\t\t\tpframe += pattrib->iv_len;\n\t\t\tmpdu_len -= pattrib->iv_len;\n\t\t}\n\t\tif (frg_inx == 0) {\n\t\t\tllc_sz = r8712_put_snap(pframe, pattrib->ether_type);\n\t\t\tpframe += llc_sz;\n\t\t\tmpdu_len -= llc_sz;\n\t\t}\n\t\tif ((pattrib->icv_len > 0) && (pattrib->bswenc))\n\t\t\tmpdu_len -= pattrib->icv_len;\n\t\tif (bmcst)\n\t\t\tmem_sz = _r8712_pktfile_read(&pktfile, pframe,\n\t\t\t\t pattrib->pktlen);\n\t\telse\n\t\t\tmem_sz = _r8712_pktfile_read(&pktfile, pframe,\n\t\t\t\t mpdu_len);\n\t\tpframe += mem_sz;\n\t\tif ((pattrib->icv_len > 0) && (pattrib->bswenc)) {\n\t\t\tmemcpy(pframe, pattrib->icv, pattrib->icv_len);\n\t\t\tpframe += pattrib->icv_len;\n\t\t}\n\t\tfrg_inx++;\n\t\tif (bmcst || r8712_endofpktfile(&pktfile)) {\n\t\t\tpattrib->nr_frags = frg_inx;\n\t\t\tpattrib->last_txcmdsz = pattrib->hdrlen +\n\t\t\t\t\t\tpattrib->iv_len +\n\t\t\t\t\t\t((pattrib->nr_frags == 1) ?\n\t\t\t\t\t\tllc_sz : 0) +\n\t\t\t\t\t\t((pattrib->bswenc) ?\n\t\t\t\t\t\tpattrib->icv_len : 0) + mem_sz;\n\t\t\tClearMFrag(mem_start);\n\t\t\tbreak;\n\t\t}\n\t\taddr = (addr_t)(pframe);\n\t\tmem_start = (unsigned char *)RND4(addr) + TXDESC_OFFSET;\n\t\tmemcpy(mem_start, pbuf_start + TXDESC_OFFSET, pattrib->hdrlen);\n\t}\n\n\tif (xmitframe_addmic(padapter, pxmitframe))\n\t\treturn _FAIL;\n\txmitframe_swencrypt(padapter, pxmitframe);\n\treturn _SUCCESS;\n}\n\nvoid r8712_update_protection(struct _adapter *padapter, u8 *ie, uint ie_len)\n{\n\tuint\tprotection;\n\tu8\t*perp;\n\tuint\terp_len;\n\tstruct\txmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct\tregistry_priv *pregistrypriv = &padapter->registrypriv;\n\n\tswitch (pxmitpriv->vcs_setting) {\n\tcase DISABLE_VCS:\n\t\tpxmitpriv->vcs = NONE_VCS;\n\t\tbreak;\n\tcase ENABLE_VCS:\n\t\tbreak;\n\tcase AUTO_VCS:\n\tdefault:\n\t\tperp = r8712_get_ie(ie, WLAN_EID_ERP_INFO, &erp_len, ie_len);\n\t\tif (!perp) {\n\t\t\tpxmitpriv->vcs = NONE_VCS;\n\t\t} else {\n\t\t\tprotection = (*(perp + 2)) & BIT(1);\n\t\t\tif (protection) {\n\t\t\t\tif (pregistrypriv->vcs_type == RTS_CTS)\n\t\t\t\t\tpxmitpriv->vcs = RTS_CTS;\n\t\t\t\telse\n\t\t\t\t\tpxmitpriv->vcs = CTS_TO_SELF;\n\t\t\t} else {\n\t\t\t\tpxmitpriv->vcs = NONE_VCS;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstruct xmit_buf *r8712_alloc_xmitbuf(struct xmit_priv *pxmitpriv)\n{\n\tunsigned long irqL;\n\tstruct xmit_buf *pxmitbuf;\n\tstruct  __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;\n\n\tspin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);\n\tpxmitbuf = list_first_entry_or_null(&pfree_xmitbuf_queue->queue,\n\t\t\t\t\t    struct xmit_buf, list);\n\tif (pxmitbuf) {\n\t\tlist_del_init(&pxmitbuf->list);\n\t\tpxmitpriv->free_xmitbuf_cnt--;\n\t}\n\tspin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);\n\treturn pxmitbuf;\n}\n\nvoid r8712_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)\n{\n\tunsigned long irqL;\n\tstruct  __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;\n\n\tif (!pxmitbuf)\n\t\treturn;\n\tspin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);\n\tlist_del_init(&pxmitbuf->list);\n\tlist_add_tail(&(pxmitbuf->list), &pfree_xmitbuf_queue->queue);\n\tpxmitpriv->free_xmitbuf_cnt++;\n\tspin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);\n}\n\n \nstruct xmit_frame *r8712_alloc_xmitframe(struct xmit_priv *pxmitpriv)\n{\n\t \n\tunsigned long irqL;\n\tstruct xmit_frame *pxframe;\n\tstruct  __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;\n\n\tspin_lock_irqsave(&pfree_xmit_queue->lock, irqL);\n\tpxframe = list_first_entry_or_null(&pfree_xmit_queue->queue,\n\t\t\t\t\t   struct xmit_frame, list);\n\tif (pxframe) {\n\t\tlist_del_init(&pxframe->list);\n\t\tpxmitpriv->free_xmitframe_cnt--;\n\t\tpxframe->buf_addr = NULL;\n\t\tpxframe->pxmitbuf = NULL;\n\t\tpxframe->attrib.psta = NULL;\n\t\tpxframe->pkt = NULL;\n\t}\n\tspin_unlock_irqrestore(&pfree_xmit_queue->lock, irqL);\n\treturn pxframe;\n}\n\nvoid r8712_free_xmitframe(struct xmit_priv *pxmitpriv,\n\t\t\t  struct xmit_frame *pxmitframe)\n{\n\tunsigned long irqL;\n\tstruct  __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;\n\tstruct _adapter *padapter = pxmitpriv->adapter;\n\n\tif (!pxmitframe)\n\t\treturn;\n\tspin_lock_irqsave(&pfree_xmit_queue->lock, irqL);\n\tlist_del_init(&pxmitframe->list);\n\tif (pxmitframe->pkt)\n\t\tpxmitframe->pkt = NULL;\n\tlist_add_tail(&pxmitframe->list, &pfree_xmit_queue->queue);\n\tpxmitpriv->free_xmitframe_cnt++;\n\tspin_unlock_irqrestore(&pfree_xmit_queue->lock, irqL);\n\tif (netif_queue_stopped(padapter->pnetdev))\n\t\tnetif_wake_queue(padapter->pnetdev);\n}\n\nvoid r8712_free_xmitframe_ex(struct xmit_priv *pxmitpriv,\n\t\t      struct xmit_frame *pxmitframe)\n{\n\tif (!pxmitframe)\n\t\treturn;\n\tif (pxmitframe->frame_tag == DATA_FRAMETAG)\n\t\tr8712_free_xmitframe(pxmitpriv, pxmitframe);\n}\n\nvoid r8712_free_xmitframe_queue(struct xmit_priv *pxmitpriv,\n\t\t\t\tstruct  __queue *pframequeue)\n{\n\tunsigned long irqL;\n\tstruct list_head *plist, *phead;\n\tstruct\txmit_frame\t*pxmitframe;\n\n\tspin_lock_irqsave(&(pframequeue->lock), irqL);\n\tphead = &pframequeue->queue;\n\tplist = phead->next;\n\twhile (!end_of_queue_search(phead, plist)) {\n\t\tpxmitframe = container_of(plist, struct xmit_frame, list);\n\t\tplist = plist->next;\n\t\tr8712_free_xmitframe(pxmitpriv, pxmitframe);\n\t}\n\tspin_unlock_irqrestore(&(pframequeue->lock), irqL);\n}\n\nstatic inline struct tx_servq *get_sta_pending(struct _adapter *padapter,\n\t\t\t\t\t       struct  __queue **ppstapending,\n\t\t\t\t\t       struct sta_info *psta, sint up)\n{\n\tstruct tx_servq *ptxservq;\n\tstruct hw_xmit *phwxmits =  padapter->xmitpriv.hwxmits;\n\n\tswitch (up) {\n\tcase 1:\n\tcase 2:\n\t\tptxservq = &(psta->sta_xmitpriv.bk_q);\n\t\t*ppstapending = &padapter->xmitpriv.bk_pending;\n\t\t(phwxmits + 3)->accnt++;\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tptxservq = &(psta->sta_xmitpriv.vi_q);\n\t\t*ppstapending = &padapter->xmitpriv.vi_pending;\n\t\t(phwxmits + 1)->accnt++;\n\t\tbreak;\n\tcase 6:\n\tcase 7:\n\t\tptxservq = &(psta->sta_xmitpriv.vo_q);\n\t\t*ppstapending = &padapter->xmitpriv.vo_pending;\n\t\t(phwxmits + 0)->accnt++;\n\t\tbreak;\n\tcase 0:\n\tcase 3:\n\tdefault:\n\t\tptxservq = &(psta->sta_xmitpriv.be_q);\n\t\t*ppstapending = &padapter->xmitpriv.be_pending;\n\t\t(phwxmits + 2)->accnt++;\n\t\tbreak;\n\t}\n\treturn ptxservq;\n}\n\n \nint r8712_xmit_classifier(struct _adapter *padapter,\n\t\t\t  struct xmit_frame *pxmitframe)\n{\n\tunsigned long irqL0;\n\tstruct  __queue *pstapending;\n\tstruct sta_info\t*psta;\n\tstruct tx_servq\t*ptxservq;\n\tstruct pkt_attrib *pattrib = &pxmitframe->attrib;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tbool bmcst = is_multicast_ether_addr(pattrib->ra);\n\n\tif (pattrib->psta) {\n\t\tpsta = pattrib->psta;\n\t} else {\n\t\tif (bmcst) {\n\t\t\tpsta = r8712_get_bcmc_stainfo(padapter);\n\t\t} else {\n\t\t\tif (check_fwstate(pmlmepriv, WIFI_MP_STATE))\n\t\t\t\tpsta = r8712_get_stainfo(pstapriv,\n\t\t\t\t       get_bssid(pmlmepriv));\n\t\t\telse\n\t\t\t\tpsta = r8712_get_stainfo(pstapriv, pattrib->ra);\n\t\t}\n\t}\n\tif (!psta)\n\t\treturn -EINVAL;\n\tptxservq = get_sta_pending(padapter, &pstapending,\n\t\t   psta, pattrib->priority);\n\tspin_lock_irqsave(&pstapending->lock, irqL0);\n\tif (list_empty(&ptxservq->tx_pending))\n\t\tlist_add_tail(&ptxservq->tx_pending, &pstapending->queue);\n\tlist_add_tail(&pxmitframe->list, &ptxservq->sta_pending.queue);\n\tptxservq->qcnt++;\n\tspin_unlock_irqrestore(&pstapending->lock, irqL0);\n\treturn 0;\n}\n\nstatic void alloc_hwxmits(struct _adapter *padapter)\n{\n\tstruct hw_xmit *hwxmits;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tpxmitpriv->hwxmit_entry = HWXMIT_ENTRY;\n\tpxmitpriv->hwxmits = kmalloc_array(pxmitpriv->hwxmit_entry,\n\t\t\t\tsizeof(struct hw_xmit), GFP_ATOMIC);\n\tif (!pxmitpriv->hwxmits)\n\t\treturn;\n\thwxmits = pxmitpriv->hwxmits;\n\tif (pxmitpriv->hwxmit_entry == 5) {\n\t\tpxmitpriv->bmc_txqueue.head = 0;\n\t\thwxmits[0] .phwtxqueue = &pxmitpriv->bmc_txqueue;\n\t\thwxmits[0] .sta_queue = &pxmitpriv->bm_pending;\n\t\tpxmitpriv->vo_txqueue.head = 0;\n\t\thwxmits[1] .phwtxqueue = &pxmitpriv->vo_txqueue;\n\t\thwxmits[1] .sta_queue = &pxmitpriv->vo_pending;\n\t\tpxmitpriv->vi_txqueue.head = 0;\n\t\thwxmits[2] .phwtxqueue = &pxmitpriv->vi_txqueue;\n\t\thwxmits[2] .sta_queue = &pxmitpriv->vi_pending;\n\t\tpxmitpriv->bk_txqueue.head = 0;\n\t\thwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;\n\t\thwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\n\t\tpxmitpriv->be_txqueue.head = 0;\n\t\thwxmits[4] .phwtxqueue = &pxmitpriv->be_txqueue;\n\t\thwxmits[4] .sta_queue = &pxmitpriv->be_pending;\n\t} else if (pxmitpriv->hwxmit_entry == 4) {\n\t\tpxmitpriv->vo_txqueue.head = 0;\n\t\thwxmits[0] .phwtxqueue = &pxmitpriv->vo_txqueue;\n\t\thwxmits[0] .sta_queue = &pxmitpriv->vo_pending;\n\t\tpxmitpriv->vi_txqueue.head = 0;\n\t\thwxmits[1] .phwtxqueue = &pxmitpriv->vi_txqueue;\n\t\thwxmits[1] .sta_queue = &pxmitpriv->vi_pending;\n\t\tpxmitpriv->be_txqueue.head = 0;\n\t\thwxmits[2] .phwtxqueue = &pxmitpriv->be_txqueue;\n\t\thwxmits[2] .sta_queue = &pxmitpriv->be_pending;\n\t\tpxmitpriv->bk_txqueue.head = 0;\n\t\thwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;\n\t\thwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\n\t}\n}\n\nstatic void free_hwxmits(struct _adapter *padapter)\n{\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tkfree(pxmitpriv->hwxmits);\n}\n\nstatic void init_hwxmits(struct hw_xmit *phwxmit, sint entry)\n{\n\tsint i;\n\n\tfor (i = 0; i < entry; i++, phwxmit++) {\n\t\tspin_lock_init(&phwxmit->xmit_lock);\n\t\tINIT_LIST_HEAD(&phwxmit->pending);\n\t\tphwxmit->txcmdcnt = 0;\n\t\tphwxmit->accnt = 0;\n\t}\n}\n\nvoid xmitframe_xmitbuf_attach(struct xmit_frame *pxmitframe,\n\t\t\tstruct xmit_buf *pxmitbuf)\n{\n\t \n\tpxmitframe->pxmitbuf = pxmitbuf;\n\t \n\tpxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];\n\t \n\tpxmitframe->buf_addr = pxmitbuf->pbuf;\n\t \n\tpxmitbuf->priv_data = pxmitframe;\n}\n\n \n\nint r8712_pre_xmit(struct _adapter *padapter, struct xmit_frame *pxmitframe)\n{\n\tunsigned long irqL;\n\tint ret;\n\tstruct xmit_buf *pxmitbuf = NULL;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct pkt_attrib *pattrib = &pxmitframe->attrib;\n\n\tr8712_do_queue_select(padapter, pattrib);\n\tspin_lock_irqsave(&pxmitpriv->lock, irqL);\n\tif (r8712_txframes_sta_ac_pending(padapter, pattrib) > 0) {\n\t\tret = false;\n\t\tr8712_xmit_enqueue(padapter, pxmitframe);\n\t\tspin_unlock_irqrestore(&pxmitpriv->lock, irqL);\n\t\treturn ret;\n\t}\n\tpxmitbuf = r8712_alloc_xmitbuf(pxmitpriv);\n\tif (!pxmitbuf) {  \n\t\tret = false;\n\t\tr8712_xmit_enqueue(padapter, pxmitframe);\n\t\tspin_unlock_irqrestore(&pxmitpriv->lock, irqL);\n\t} else {  \n\t\tspin_unlock_irqrestore(&pxmitpriv->lock, irqL);\n\t\tret = true;\n\t\txmitframe_xmitbuf_attach(pxmitframe, pxmitbuf);\n\t\tr8712_xmit_direct(padapter, pxmitframe);\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}