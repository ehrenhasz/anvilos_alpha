{
  "module_name": "bcm2835-camera.c",
  "hash_id": "51fd106c6947d134305f36e968570554a50bd92b832597b73e86b01cff6a17ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <media/videobuf2-vmalloc.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-common.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n\n#include \"../vchiq-mmal/mmal-common.h\"\n#include \"../vchiq-mmal/mmal-encodings.h\"\n#include \"../vchiq-mmal/mmal-vchiq.h\"\n#include \"../vchiq-mmal/mmal-msg.h\"\n#include \"../vchiq-mmal/mmal-parameters.h\"\n#include \"bcm2835-camera.h\"\n\n#define MIN_WIDTH 32\n#define MIN_HEIGHT 32\n#define MIN_BUFFER_SIZE (80 * 1024)\n\n#define MAX_VIDEO_MODE_WIDTH 1280\n#define MAX_VIDEO_MODE_HEIGHT 720\n\n#define MAX_BCM2835_CAMERAS 2\n\nint bcm2835_v4l2_debug;\nmodule_param_named(debug, bcm2835_v4l2_debug, int, 0644);\nMODULE_PARM_DESC(bcm2835_v4l2_debug, \"Debug level 0-2\");\n\n#define UNSET (-1)\nstatic int video_nr[] = {[0 ... (MAX_BCM2835_CAMERAS - 1)] = UNSET };\nmodule_param_array(video_nr, int, NULL, 0644);\nMODULE_PARM_DESC(video_nr, \"videoX start numbers, -1 is autodetect\");\n\nstatic int max_video_width = MAX_VIDEO_MODE_WIDTH;\nstatic int max_video_height = MAX_VIDEO_MODE_HEIGHT;\nmodule_param(max_video_width, int, 0644);\nMODULE_PARM_DESC(max_video_width, \"Threshold for video mode\");\nmodule_param(max_video_height, int, 0644);\nMODULE_PARM_DESC(max_video_height, \"Threshold for video mode\");\n\n \nstatic atomic_t camera_instance = ATOMIC_INIT(0);\n\n \nstatic struct bcm2835_mmal_dev *gdev[MAX_BCM2835_CAMERAS];\n\n#define FPS_MIN 1\n#define FPS_MAX 90\n\n \nstatic const struct v4l2_fract\n\ttpf_min     = {.numerator = 1,\t\t.denominator = FPS_MAX},\n\ttpf_max     = {.numerator = 1,\t        .denominator = FPS_MIN},\n\ttpf_default = {.numerator = 1000,\t.denominator = 30000};\n\n \nstruct vb2_mmal_buffer {\n\tstruct vb2_v4l2_buffer\tvb;\n\tstruct mmal_buffer\tmmal;\n};\n\n \nstatic struct mmal_fmt formats[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_YUV420,\n\t\t.mmal = MMAL_ENCODING_I420,\n\t\t.depth = 12,\n\t\t.mmal_component = COMP_CAMERA,\n\t\t.ybbp = 1,\n\t\t.remove_padding = true,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.mmal = MMAL_ENCODING_YUYV,\n\t\t.depth = 16,\n\t\t.mmal_component = COMP_CAMERA,\n\t\t.ybbp = 2,\n\t\t.remove_padding = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_RGB24,\n\t\t.mmal = MMAL_ENCODING_RGB24,\n\t\t.depth = 24,\n\t\t.mmal_component = COMP_CAMERA,\n\t\t.ybbp = 3,\n\t\t.remove_padding = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_JPEG,\n\t\t.flags = V4L2_FMT_FLAG_COMPRESSED,\n\t\t.mmal = MMAL_ENCODING_JPEG,\n\t\t.depth = 8,\n\t\t.mmal_component = COMP_IMAGE_ENCODE,\n\t\t.ybbp = 0,\n\t\t.remove_padding = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_H264,\n\t\t.flags = V4L2_FMT_FLAG_COMPRESSED,\n\t\t.mmal = MMAL_ENCODING_H264,\n\t\t.depth = 8,\n\t\t.mmal_component = COMP_VIDEO_ENCODE,\n\t\t.ybbp = 0,\n\t\t.remove_padding = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_MJPEG,\n\t\t.flags = V4L2_FMT_FLAG_COMPRESSED,\n\t\t.mmal = MMAL_ENCODING_MJPEG,\n\t\t.depth = 8,\n\t\t.mmal_component = COMP_VIDEO_ENCODE,\n\t\t.ybbp = 0,\n\t\t.remove_padding = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YVYU,\n\t\t.mmal = MMAL_ENCODING_YVYU,\n\t\t.depth = 16,\n\t\t.mmal_component = COMP_CAMERA,\n\t\t.ybbp = 2,\n\t\t.remove_padding = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_VYUY,\n\t\t.mmal = MMAL_ENCODING_VYUY,\n\t\t.depth = 16,\n\t\t.mmal_component = COMP_CAMERA,\n\t\t.ybbp = 2,\n\t\t.remove_padding = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_UYVY,\n\t\t.mmal = MMAL_ENCODING_UYVY,\n\t\t.depth = 16,\n\t\t.mmal_component = COMP_CAMERA,\n\t\t.ybbp = 2,\n\t\t.remove_padding = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV12,\n\t\t.mmal = MMAL_ENCODING_NV12,\n\t\t.depth = 12,\n\t\t.mmal_component = COMP_CAMERA,\n\t\t.ybbp = 1,\n\t\t.remove_padding = true,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_BGR24,\n\t\t.mmal = MMAL_ENCODING_BGR24,\n\t\t.depth = 24,\n\t\t.mmal_component = COMP_CAMERA,\n\t\t.ybbp = 3,\n\t\t.remove_padding = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YVU420,\n\t\t.mmal = MMAL_ENCODING_YV12,\n\t\t.depth = 12,\n\t\t.mmal_component = COMP_CAMERA,\n\t\t.ybbp = 1,\n\t\t.remove_padding = true,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV21,\n\t\t.mmal = MMAL_ENCODING_NV21,\n\t\t.depth = 12,\n\t\t.mmal_component = COMP_CAMERA,\n\t\t.ybbp = 1,\n\t\t.remove_padding = true,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_BGR32,\n\t\t.mmal = MMAL_ENCODING_BGRA,\n\t\t.depth = 32,\n\t\t.mmal_component = COMP_CAMERA,\n\t\t.ybbp = 4,\n\t\t.remove_padding = false,\n\t},\n};\n\nstatic struct mmal_fmt *get_format(struct v4l2_format *f)\n{\n\tstruct mmal_fmt *fmt;\n\tunsigned int k;\n\n\tfor (k = 0; k < ARRAY_SIZE(formats); k++) {\n\t\tfmt = &formats[k];\n\t\tif (fmt->fourcc == f->fmt.pix.pixelformat)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\n \n\nstatic int queue_setup(struct vb2_queue *vq,\n\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t       unsigned int sizes[], struct device *alloc_ctxs[])\n{\n\tstruct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vq);\n\tunsigned long size;\n\n\t \n\tif (!dev->capture.port) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"%s: capture port not configured\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (*nplanes) {\n\t\tif (*nplanes != 1 ||\n\t\t    sizes[0] < dev->capture.port->current_buffer.size) {\n\t\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t\t \"%s: dev:%p Invalid buffer request from CREATE_BUFS, size %u < %u, nplanes %u != 1\\n\",\n\t\t\t\t __func__, dev, sizes[0],\n\t\t\t\t dev->capture.port->current_buffer.size,\n\t\t\t\t *nplanes);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tsize = dev->capture.port->current_buffer.size;\n\tif (size == 0) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"%s: capture port buffer size is zero\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (*nbuffers < dev->capture.port->minimum_buffer.num)\n\t\t*nbuffers = dev->capture.port->minimum_buffer.num;\n\n\tdev->capture.port->current_buffer.num = *nbuffers;\n\n\t*nplanes = 1;\n\n\tsizes[0] = size;\n\n\t \n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, \"%s: dev:%p\\n\",\n\t\t __func__, dev);\n\n\treturn 0;\n}\n\nstatic int buffer_init(struct vb2_buffer *vb)\n{\n\tstruct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vb2 = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_mmal_buffer *buf =\n\t\t\t\tcontainer_of(vb2, struct vb2_mmal_buffer, vb);\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, \"%s: dev:%p, vb %p\\n\",\n\t\t __func__, dev, vb);\n\tbuf->mmal.buffer = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\tbuf->mmal.buffer_size = vb2_plane_size(&buf->vb.vb2_buf, 0);\n\n\treturn mmal_vchi_buffer_init(dev->instance, &buf->mmal);\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long size;\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, \"%s: dev:%p, vb %p\\n\",\n\t\t __func__, dev, vb);\n\n\tif (!dev->capture.port || !dev->capture.fmt)\n\t\treturn -ENODEV;\n\n\tsize = dev->capture.stride * dev->capture.height;\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"%s data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t __func__, vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void buffer_cleanup(struct vb2_buffer *vb)\n{\n\tstruct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vb2 = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_mmal_buffer *buf =\n\t\t\t\tcontainer_of(vb2, struct vb2_mmal_buffer, vb);\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, \"%s: dev:%p, vb %p\\n\",\n\t\t __func__, dev, vb);\n\n\tmmal_vchi_buffer_cleanup(&buf->mmal);\n}\n\nstatic inline bool is_capturing(struct bcm2835_mmal_dev *dev)\n{\n\treturn dev->capture.camera_port ==\n\t    &dev->component[COMP_CAMERA]->output[CAM_PORT_CAPTURE];\n}\n\nstatic void buffer_cb(struct vchiq_mmal_instance *instance,\n\t\t      struct vchiq_mmal_port *port,\n\t\t      int status,\n\t\t      struct mmal_buffer *mmal_buf)\n{\n\tstruct bcm2835_mmal_dev *dev = port->cb_ctx;\n\tstruct vb2_mmal_buffer *buf =\n\t\t\tcontainer_of(mmal_buf, struct vb2_mmal_buffer, mmal);\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t \"%s: status:%d, buf:%p, length:%lu, flags %u, pts %lld\\n\",\n\t\t __func__, status, buf, mmal_buf->length, mmal_buf->mmal_flags,\n\t\t mmal_buf->pts);\n\n\tif (status) {\n\t\t \n\t\tif (buf) {\n\t\t\t \n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (mmal_buf->length == 0) {\n\t\t \n\t\tif (dev->capture.frame_count) {\n\t\t\t \n\t\t\tif (is_capturing(dev)) {\n\t\t\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t\t\t \"Grab another frame\");\n\t\t\t\tvchiq_mmal_port_parameter_set(\n\t\t\t\t\tinstance,\n\t\t\t\t\tdev->capture.camera_port,\n\t\t\t\t\tMMAL_PARAMETER_CAPTURE,\n\t\t\t\t\t&dev->capture.frame_count,\n\t\t\t\t\tsizeof(dev->capture.frame_count));\n\t\t\t}\n\t\t\tif (vchiq_mmal_submit_buffer(instance, port,\n\t\t\t\t\t\t     &buf->mmal))\n\t\t\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t\t\t \"Failed to return EOS buffer\");\n\t\t} else {\n\t\t\t \n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\t\tcomplete(&dev->capture.frame_cmplt);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!dev->capture.frame_count) {\n\t\t \n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tcomplete(&dev->capture.frame_cmplt);\n\t\treturn;\n\t}\n\n\tif (dev->capture.vc_start_timestamp != -1 && mmal_buf->pts) {\n\t\tktime_t timestamp;\n\t\ts64 runtime_us = mmal_buf->pts -\n\t\t    dev->capture.vc_start_timestamp;\n\t\ttimestamp = ktime_add_us(dev->capture.kernel_start_ts,\n\t\t\t\t\t runtime_us);\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"Convert start time %llu and %llu with offset %llu to %llu\\n\",\n\t\t\t ktime_to_ns(dev->capture.kernel_start_ts),\n\t\t\t dev->capture.vc_start_timestamp, mmal_buf->pts,\n\t\t\t ktime_to_ns(timestamp));\n\t\tbuf->vb.vb2_buf.timestamp = ktime_to_ns(timestamp);\n\t} else {\n\t\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t}\n\tbuf->vb.sequence = dev->capture.sequence++;\n\tbuf->vb.field = V4L2_FIELD_NONE;\n\n\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0, mmal_buf->length);\n\tif (mmal_buf->mmal_flags & MMAL_BUFFER_HEADER_FLAG_KEYFRAME)\n\t\tbuf->vb.flags |= V4L2_BUF_FLAG_KEYFRAME;\n\n\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\n\tif (mmal_buf->mmal_flags & MMAL_BUFFER_HEADER_FLAG_EOS &&\n\t    is_capturing(dev)) {\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"Grab another frame as buffer has EOS\");\n\t\tvchiq_mmal_port_parameter_set(\n\t\t\tinstance,\n\t\t\tdev->capture.camera_port,\n\t\t\tMMAL_PARAMETER_CAPTURE,\n\t\t\t&dev->capture.frame_count,\n\t\t\tsizeof(dev->capture.frame_count));\n\t}\n}\n\nstatic int enable_camera(struct bcm2835_mmal_dev *dev)\n{\n\tint ret;\n\n\tif (!dev->camera_use_count) {\n\t\tret = vchiq_mmal_port_parameter_set(\n\t\t\tdev->instance,\n\t\t\t&dev->component[COMP_CAMERA]->control,\n\t\t\tMMAL_PARAMETER_CAMERA_NUM, &dev->camera_num,\n\t\t\tsizeof(dev->camera_num));\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"Failed setting camera num, ret %d\\n\", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = vchiq_mmal_component_enable(dev->instance,\n\t\t\t\t\t\t  dev->component[COMP_CAMERA]);\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"Failed enabling camera, ret %d\\n\", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tdev->camera_use_count++;\n\tv4l2_dbg(1, bcm2835_v4l2_debug,\n\t\t &dev->v4l2_dev, \"enabled camera (refcount %d)\\n\",\n\t\t\tdev->camera_use_count);\n\treturn 0;\n}\n\nstatic int disable_camera(struct bcm2835_mmal_dev *dev)\n{\n\tint ret;\n\n\tif (!dev->camera_use_count) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Disabled the camera when already disabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdev->camera_use_count--;\n\tif (!dev->camera_use_count) {\n\t\tunsigned int i = 0xFFFFFFFF;\n\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"Disabling camera\\n\");\n\t\tret = vchiq_mmal_component_disable(dev->instance,\n\t\t\t\t\t\t   dev->component[COMP_CAMERA]);\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"Failed disabling camera, ret %d\\n\", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvchiq_mmal_port_parameter_set(\n\t\t\tdev->instance,\n\t\t\t&dev->component[COMP_CAMERA]->control,\n\t\t\tMMAL_PARAMETER_CAMERA_NUM, &i,\n\t\t\tsizeof(i));\n\t}\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t \"Camera refcount now %d\\n\", dev->camera_use_count);\n\treturn 0;\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vb2 = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_mmal_buffer *buf =\n\t\t\t\tcontainer_of(vb2, struct vb2_mmal_buffer, vb);\n\tint ret;\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t \"%s: dev:%p buf:%p, idx %u\\n\",\n\t\t __func__, dev, buf, vb2->vb2_buf.index);\n\n\tret = vchiq_mmal_submit_buffer(dev->instance, dev->capture.port,\n\t\t\t\t       &buf->mmal);\n\tif (ret < 0)\n\t\tv4l2_err(&dev->v4l2_dev, \"%s: error submitting buffer\\n\",\n\t\t\t __func__);\n}\n\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vq);\n\tint ret;\n\tu32 parameter_size;\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, \"%s: dev:%p\\n\",\n\t\t __func__, dev);\n\n\t \n\tif (!dev->capture.port)\n\t\treturn -EINVAL;\n\n\tif (enable_camera(dev) < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to enable camera\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\t \n\tdev->capture.frame_count = 1;\n\n\t \n\tdev->capture.sequence = 0;\n\n\t \n\tif (!dev->component[COMP_PREVIEW]->enabled)\n\t\tmsleep(300);\n\n\t \n\tif (dev->capture.camera_port != dev->capture.port &&\n\t    dev->capture.camera_port) {\n\t\tret = vchiq_mmal_port_enable(dev->instance,\n\t\t\t\t\t     dev->capture.camera_port, NULL);\n\t\tif (ret) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"Failed to enable encode tunnel - error %d\\n\",\n\t\t\t\t ret);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tparameter_size = sizeof(dev->capture.vc_start_timestamp);\n\tif (vchiq_mmal_port_parameter_get(dev->instance,\n\t\t\t\t\t  dev->capture.camera_port,\n\t\t\t\t\t  MMAL_PARAMETER_SYSTEM_TIME,\n\t\t\t\t\t  &dev->capture.vc_start_timestamp,\n\t\t\t\t\t  &parameter_size)) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Failed to get VC start time - update your VC f/w\\n\");\n\n\t\t \n\t\tdev->capture.vc_start_timestamp = -1;\n\t} else {\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"Start time %lld size %d\\n\",\n\t\t\t dev->capture.vc_start_timestamp, parameter_size);\n\t}\n\n\tdev->capture.kernel_start_ts = ktime_get();\n\n\t \n\tdev->capture.port->cb_ctx = dev;\n\tret = vchiq_mmal_port_enable(dev->instance, dev->capture.port,\n\t\t\t\t     buffer_cb);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Failed to enable capture port - error %d. Disabling camera port again\\n\",\n\t\t\t ret);\n\n\t\tvchiq_mmal_port_disable(dev->instance,\n\t\t\t\t\tdev->capture.camera_port);\n\t\tif (disable_camera(dev) < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"Failed to disable camera\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t \n\tvchiq_mmal_port_parameter_set(dev->instance,\n\t\t\t\t      dev->capture.camera_port,\n\t\t\t\t      MMAL_PARAMETER_CAPTURE,\n\t\t\t\t      &dev->capture.frame_count,\n\t\t\t\t      sizeof(dev->capture.frame_count));\n\treturn 0;\n}\n\n \nstatic void stop_streaming(struct vb2_queue *vq)\n{\n\tint ret;\n\tunsigned long timeout;\n\tstruct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vq);\n\tstruct vchiq_mmal_port *port = dev->capture.port;\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, \"%s: dev:%p\\n\",\n\t\t __func__, dev);\n\n\tinit_completion(&dev->capture.frame_cmplt);\n\tdev->capture.frame_count = 0;\n\n\t \n\tif (!port) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"no capture port - stream not started?\\n\");\n\t\treturn;\n\t}\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, \"stopping capturing\\n\");\n\n\t \n\tvchiq_mmal_port_parameter_set(dev->instance,\n\t\t\t\t      dev->capture.camera_port,\n\t\t\t\t      MMAL_PARAMETER_CAPTURE,\n\t\t\t\t      &dev->capture.frame_count,\n\t\t\t\t      sizeof(dev->capture.frame_count));\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t \"disabling connection\\n\");\n\n\t \n\tret = vchiq_mmal_port_disable(dev->instance, dev->capture.camera_port);\n\tif (!ret && dev->capture.camera_port != port) {\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"disabling port\\n\");\n\t\tret = vchiq_mmal_port_disable(dev->instance, port);\n\t} else if (dev->capture.camera_port != port) {\n\t\tv4l2_err(&dev->v4l2_dev, \"port_disable failed, error %d\\n\",\n\t\t\t ret);\n\t}\n\n\t \n\twhile (atomic_read(&port->buffers_with_vpu)) {\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"%s: Waiting for buffers to be returned - %d outstanding\\n\",\n\t\t\t __func__, atomic_read(&port->buffers_with_vpu));\n\t\ttimeout = wait_for_completion_timeout(&dev->capture.frame_cmplt,\n\t\t\t\t\t\t      HZ);\n\t\tif (timeout == 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"%s: Timeout waiting for buffers to be returned - %d outstanding\\n\",\n\t\t\t\t __func__,\n\t\t\t\t atomic_read(&port->buffers_with_vpu));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (disable_camera(dev) < 0)\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to disable camera\\n\");\n}\n\nstatic const struct vb2_ops bcm2835_mmal_video_qops = {\n\t.queue_setup = queue_setup,\n\t.buf_init = buffer_init,\n\t.buf_prepare = buffer_prepare,\n\t.buf_cleanup = buffer_cleanup,\n\t.buf_queue = buffer_queue,\n\t.start_streaming = start_streaming,\n\t.stop_streaming = stop_streaming,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n\n \n\nstatic int set_overlay_params(struct bcm2835_mmal_dev *dev,\n\t\t\t      struct vchiq_mmal_port *port)\n{\n\tstruct mmal_parameter_displayregion prev_config = {\n\t\t.set =\tMMAL_DISPLAY_SET_LAYER |\n\t\t\tMMAL_DISPLAY_SET_ALPHA |\n\t\t\tMMAL_DISPLAY_SET_DEST_RECT |\n\t\t\tMMAL_DISPLAY_SET_FULLSCREEN,\n\t\t.layer = 2,\n\t\t.alpha = dev->overlay.global_alpha,\n\t\t.fullscreen = 0,\n\t\t.dest_rect = {\n\t\t\t.x = dev->overlay.w.left,\n\t\t\t.y = dev->overlay.w.top,\n\t\t\t.width = dev->overlay.w.width,\n\t\t\t.height = dev->overlay.w.height,\n\t\t},\n\t};\n\treturn vchiq_mmal_port_parameter_set(dev->instance, port,\n\t\t\t\t\t     MMAL_PARAMETER_DISPLAYREGION,\n\t\t\t\t\t     &prev_config, sizeof(prev_config));\n}\n\n \nstatic int vidioc_enum_fmt_vid_overlay(struct file *file, void *priv,\n\t\t\t\t       struct v4l2_fmtdesc *f)\n{\n\tstruct mmal_fmt *fmt;\n\n\tif (f->index >= ARRAY_SIZE(formats))\n\t\treturn -EINVAL;\n\n\tfmt = &formats[f->index];\n\n\tf->pixelformat = fmt->fourcc;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_overlay(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct bcm2835_mmal_dev *dev = video_drvdata(file);\n\n\tf->fmt.win = dev->overlay;\n\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_overlay(struct file *file, void *priv,\n\t\t\t\t      struct v4l2_format *f)\n{\n\tstruct bcm2835_mmal_dev *dev = video_drvdata(file);\n\n\tf->fmt.win.field = V4L2_FIELD_NONE;\n\tf->fmt.win.chromakey = 0;\n\tf->fmt.win.clips = NULL;\n\tf->fmt.win.clipcount = 0;\n\tf->fmt.win.bitmap = NULL;\n\n\tv4l_bound_align_image(&f->fmt.win.w.width, MIN_WIDTH, dev->max_width, 1,\n\t\t\t      &f->fmt.win.w.height, MIN_HEIGHT, dev->max_height,\n\t\t\t      1, 0);\n\tv4l_bound_align_image(&f->fmt.win.w.left, MIN_WIDTH, dev->max_width, 1,\n\t\t\t      &f->fmt.win.w.top, MIN_HEIGHT, dev->max_height,\n\t\t\t      1, 0);\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t \"Overlay: Now w/h %dx%d l/t %dx%d\\n\",\n\t\tf->fmt.win.w.width, f->fmt.win.w.height,\n\t\tf->fmt.win.w.left, f->fmt.win.w.top);\n\n\tv4l2_dump_win_format(1,\n\t\t\t     bcm2835_v4l2_debug,\n\t\t\t     &dev->v4l2_dev,\n\t\t\t     &f->fmt.win,\n\t\t\t     __func__);\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_overlay(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct bcm2835_mmal_dev *dev = video_drvdata(file);\n\n\tvidioc_try_fmt_vid_overlay(file, priv, f);\n\n\tdev->overlay = f->fmt.win;\n\tif (dev->component[COMP_PREVIEW]->enabled) {\n\t\tset_overlay_params(dev,\n\t\t\t\t   &dev->component[COMP_PREVIEW]->input[0]);\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_overlay(struct file *file, void *f, unsigned int on)\n{\n\tint ret;\n\tstruct bcm2835_mmal_dev *dev = video_drvdata(file);\n\tstruct vchiq_mmal_port *src;\n\tstruct vchiq_mmal_port *dst;\n\n\tif ((on && dev->component[COMP_PREVIEW]->enabled) ||\n\t    (!on && !dev->component[COMP_PREVIEW]->enabled))\n\t\treturn 0;\t \n\n\tsrc = &dev->component[COMP_CAMERA]->output[CAM_PORT_PREVIEW];\n\n\tif (!on) {\n\t\t \n\t\tret = vchiq_mmal_port_disable(dev->instance, src);\n\t\tif (!ret)\n\t\t\tret = vchiq_mmal_port_connect_tunnel(dev->instance, src,\n\t\t\t\t\t\t\t     NULL);\n\t\tif (ret >= 0)\n\t\t\tret = vchiq_mmal_component_disable(\n\t\t\t\t\tdev->instance,\n\t\t\t\t\tdev->component[COMP_PREVIEW]);\n\n\t\tdisable_camera(dev);\n\t\treturn ret;\n\t}\n\n\t \n\tdst = &dev->component[COMP_PREVIEW]->input[0];\n\n\tret = vchiq_mmal_port_set_format(dev->instance, src);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = set_overlay_params(dev, dst);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (enable_camera(dev) < 0)\n\t\treturn -EINVAL;\n\n\tret = vchiq_mmal_component_enable(dev->instance,\n\t\t\t\t\t  dev->component[COMP_PREVIEW]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, \"connecting %p to %p\\n\",\n\t\t src, dst);\n\tret = vchiq_mmal_port_connect_tunnel(dev->instance, src, dst);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vchiq_mmal_port_enable(dev->instance, src, NULL);\n}\n\nstatic int vidioc_g_fbuf(struct file *file, void *fh,\n\t\t\t struct v4l2_framebuffer *a)\n{\n\t \n\tstruct bcm2835_mmal_dev *dev = video_drvdata(file);\n\tstruct vchiq_mmal_port *preview_port =\n\t\t&dev->component[COMP_CAMERA]->output[CAM_PORT_PREVIEW];\n\n\ta->capability = V4L2_FBUF_CAP_EXTERNOVERLAY |\n\t\t\tV4L2_FBUF_CAP_GLOBAL_ALPHA;\n\ta->flags = V4L2_FBUF_FLAG_OVERLAY;\n\ta->fmt.width = preview_port->es.video.width;\n\ta->fmt.height = preview_port->es.video.height;\n\ta->fmt.pixelformat = V4L2_PIX_FMT_YUV420;\n\ta->fmt.bytesperline = preview_port->es.video.width;\n\ta->fmt.sizeimage = (preview_port->es.video.width *\n\t\t\t       preview_port->es.video.height * 3) >> 1;\n\ta->fmt.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\n \nstatic int vidioc_enum_input(struct file *file, void *priv,\n\t\t\t     struct v4l2_input *inp)\n{\n\t \n\tif (inp->index)\n\t\treturn -EINVAL;\n\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tsprintf((char *)inp->name, \"Camera %u\", inp->index);\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tif (i)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct bcm2835_mmal_dev *dev = video_drvdata(file);\n\tu32 major;\n\tu32 minor;\n\n\tvchiq_mmal_version(dev->instance, &major, &minor);\n\n\tstrscpy(cap->driver, \"bcm2835 mmal\", sizeof(cap->driver));\n\tsnprintf((char *)cap->card, sizeof(cap->card), \"mmal service %d.%d\", major, minor);\n\n\tsnprintf((char *)cap->bus_info, sizeof(cap->bus_info), \"platform:%s\", dev->v4l2_dev.name);\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tstruct mmal_fmt *fmt;\n\n\tif (f->index >= ARRAY_SIZE(formats))\n\t\treturn -EINVAL;\n\n\tfmt = &formats[f->index];\n\n\tf->pixelformat = fmt->fourcc;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct bcm2835_mmal_dev *dev = video_drvdata(file);\n\n\tf->fmt.pix.width = dev->capture.width;\n\tf->fmt.pix.height = dev->capture.height;\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\tf->fmt.pix.pixelformat = dev->capture.fmt->fourcc;\n\tf->fmt.pix.bytesperline = dev->capture.stride;\n\tf->fmt.pix.sizeimage = dev->capture.buffersize;\n\n\tif (dev->capture.fmt->fourcc == V4L2_PIX_FMT_RGB24)\n\t\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\n\telse if (dev->capture.fmt->fourcc == V4L2_PIX_FMT_JPEG)\n\t\tf->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;\n\telse\n\t\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tf->fmt.pix.priv = 0;\n\n\tv4l2_dump_pix_format(1, bcm2835_v4l2_debug, &dev->v4l2_dev, &f->fmt.pix,\n\t\t\t     __func__);\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct bcm2835_mmal_dev *dev = video_drvdata(file);\n\tstruct mmal_fmt *mfmt;\n\n\tmfmt = get_format(f);\n\tif (!mfmt) {\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"Fourcc format (0x%08x) unknown.\\n\",\n\t\t\t f->fmt.pix.pixelformat);\n\t\tf->fmt.pix.pixelformat = formats[0].fourcc;\n\t\tmfmt = get_format(f);\n\t}\n\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t \"Clipping/aligning %dx%d format %08X\\n\",\n\t\t f->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.pixelformat);\n\n\tv4l_bound_align_image(&f->fmt.pix.width, MIN_WIDTH, dev->max_width, 1,\n\t\t\t      &f->fmt.pix.height, MIN_HEIGHT, dev->max_height,\n\t\t\t      1, 0);\n\tf->fmt.pix.bytesperline = f->fmt.pix.width * mfmt->ybbp;\n\tif (!mfmt->remove_padding) {\n\t\tif (mfmt->depth == 24) {\n\t\t\t \n\t\t\tf->fmt.pix.bytesperline =\n\t\t\t\t((f->fmt.pix.width + 15) & ~15) * 3;\n\t\t} else {\n\t\t\t \n\t\t\tint align_mask = ((32 * mfmt->depth) >> 3) - 1;\n\n\t\t\tf->fmt.pix.bytesperline =\n\t\t\t\t(f->fmt.pix.bytesperline + align_mask) &\n\t\t\t\t\t\t\t~align_mask;\n\t\t}\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"Not removing padding, so bytes/line = %d\\n\",\n\t\t\t f->fmt.pix.bytesperline);\n\t}\n\n\t \n\tf->fmt.pix.sizeimage = ((f->fmt.pix.height + 15) & ~15) *\n\t\t\t(((f->fmt.pix.width + 31) & ~31) * mfmt->depth) >> 3;\n\n\tif ((mfmt->flags & V4L2_FMT_FLAG_COMPRESSED) &&\n\t    f->fmt.pix.sizeimage < MIN_BUFFER_SIZE)\n\t\tf->fmt.pix.sizeimage = MIN_BUFFER_SIZE;\n\n\tif (f->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB24)\n\t\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\n\telse if (f->fmt.pix.pixelformat == V4L2_PIX_FMT_JPEG)\n\t\tf->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;\n\telse\n\t\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tf->fmt.pix.priv = 0;\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t \"Now %dx%d format %08X\\n\",\n\t\tf->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.pixelformat);\n\n\tv4l2_dump_pix_format(1, bcm2835_v4l2_debug, &dev->v4l2_dev, &f->fmt.pix,\n\t\t\t     __func__);\n\treturn 0;\n}\n\n\nstatic int mmal_setup_video_component(struct bcm2835_mmal_dev *dev,\n\t\t\t\t      struct v4l2_format *f)\n{\n\tbool overlay_enabled = !!dev->component[COMP_PREVIEW]->enabled;\n\tstruct vchiq_mmal_port *preview_port;\n\tint ret;\n\n\tpreview_port = &dev->component[COMP_CAMERA]->output[CAM_PORT_PREVIEW];\n\n\t \n\tif (overlay_enabled) {\n\t\t \n\t\tret = vchiq_mmal_port_disable(dev->instance, preview_port);\n\t\tif (!ret) {\n\t\t\tret = vchiq_mmal_port_connect_tunnel(dev->instance,\n\t\t\t\t\t\t\t     preview_port,\n\t\t\t\t\t\t\t     NULL);\n\t\t}\n\t}\n\tpreview_port->es.video.width = f->fmt.pix.width;\n\tpreview_port->es.video.height = f->fmt.pix.height;\n\tpreview_port->es.video.crop.x = 0;\n\tpreview_port->es.video.crop.y = 0;\n\tpreview_port->es.video.crop.width = f->fmt.pix.width;\n\tpreview_port->es.video.crop.height = f->fmt.pix.height;\n\tpreview_port->es.video.frame_rate.numerator =\n\t\t\t\t  dev->capture.timeperframe.denominator;\n\tpreview_port->es.video.frame_rate.denominator =\n\t\t\t\t  dev->capture.timeperframe.numerator;\n\tret = vchiq_mmal_port_set_format(dev->instance, preview_port);\n\n\tif (overlay_enabled) {\n\t\tret = vchiq_mmal_port_connect_tunnel(dev->instance,\n\t\t\t\tpreview_port,\n\t\t\t\t&dev->component[COMP_PREVIEW]->input[0]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = vchiq_mmal_port_enable(dev->instance, preview_port, NULL);\n\t}\n\n\treturn ret;\n}\n\nstatic int mmal_setup_encode_component(struct bcm2835_mmal_dev *dev,\n\t\t\t\t       struct v4l2_format *f,\n\t\t\t\t       struct vchiq_mmal_port *port,\n\t\t\t\t       struct vchiq_mmal_port *camera_port,\n\t\t\t\t       struct vchiq_mmal_component *component)\n{\n\tstruct mmal_fmt *mfmt = get_format(f);\n\tint ret;\n\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t \"vid_cap - set up encode comp\\n\");\n\n\t \n\tcamera_port->current_buffer.size = camera_port->recommended_buffer.size;\n\tcamera_port->current_buffer.num = camera_port->recommended_buffer.num;\n\n\tret = vchiq_mmal_port_connect_tunnel(dev->instance, camera_port,\n\t\t\t\t\t     &component->input[0]);\n\tif (ret) {\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"%s failed to create connection\\n\", __func__);\n\t\t \n\t\tdev->capture.port = NULL;\n\t\treturn ret;\n\t}\n\n\tport->es.video.width = f->fmt.pix.width;\n\tport->es.video.height = f->fmt.pix.height;\n\tport->es.video.crop.x = 0;\n\tport->es.video.crop.y = 0;\n\tport->es.video.crop.width = f->fmt.pix.width;\n\tport->es.video.crop.height = f->fmt.pix.height;\n\tport->es.video.frame_rate.numerator =\n\t\t  dev->capture.timeperframe.denominator;\n\tport->es.video.frame_rate.denominator =\n\t\t  dev->capture.timeperframe.numerator;\n\n\tport->format.encoding = mfmt->mmal;\n\tport->format.encoding_variant = 0;\n\t \n\tswitch (mfmt->mmal_component) {\n\tcase COMP_VIDEO_ENCODE:\n\t\tport->format.bitrate = dev->capture.encode_bitrate;\n\t\tbreak;\n\tcase COMP_IMAGE_ENCODE:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = vchiq_mmal_port_set_format(dev->instance, port);\n\tif (ret) {\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"%s failed to set format %dx%d fmt %08X\\n\",\n\t\t\t __func__,\n\t\t\t f->fmt.pix.width,\n\t\t\t f->fmt.pix.height,\n\t\t\t f->fmt.pix.pixelformat);\n\t\treturn ret;\n\t}\n\n\tret = vchiq_mmal_component_enable(dev->instance, component);\n\tif (ret) {\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"%s Failed to enable encode components\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\t \n\tport->current_buffer.num = 1;\n\tport->current_buffer.size = f->fmt.pix.sizeimage;\n\tif (port->format.encoding == MMAL_ENCODING_JPEG) {\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"JPG - buf size now %d was %d\\n\",\n\t\t\t f->fmt.pix.sizeimage,\n\t\t\t port->current_buffer.size);\n\t\tport->current_buffer.size =\n\t\t    (f->fmt.pix.sizeimage < (100 << 10)) ?\n\t\t    (100 << 10) : f->fmt.pix.sizeimage;\n\t}\n\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t \"vid_cap - cur_buf.size set to %d\\n\", f->fmt.pix.sizeimage);\n\tport->current_buffer.alignment = 0;\n\n\treturn 0;\n}\n\nstatic int mmal_setup_components(struct bcm2835_mmal_dev *dev,\n\t\t\t\t struct v4l2_format *f)\n{\n\tint ret;\n\tstruct vchiq_mmal_port *port = NULL, *camera_port = NULL;\n\tstruct vchiq_mmal_component *encode_component = NULL;\n\tstruct mmal_fmt *mfmt = get_format(f);\n\tbool remove_padding;\n\n\tif (!mfmt)\n\t\treturn -EINVAL;\n\n\tif (dev->capture.encode_component) {\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"vid_cap - disconnect previous tunnel\\n\");\n\n\t\t \n\t\tvchiq_mmal_port_connect_tunnel(dev->instance,\n\t\t\t\t\t       dev->capture.camera_port, NULL);\n\t\tdev->capture.camera_port = NULL;\n\t\tret = vchiq_mmal_component_disable(dev->instance,\n\t\t\t\t\t\t   dev->capture.encode_component);\n\t\tif (ret)\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"Failed to disable encode component %d\\n\",\n\t\t\t\t ret);\n\n\t\tdev->capture.encode_component = NULL;\n\t}\n\t \n\tswitch (mfmt->mmal_component) {\n\tcase COMP_CAMERA:\n\t\t \n\t\tif (f->fmt.pix.width <= max_video_width &&\n\t\t    f->fmt.pix.height <= max_video_height)\n\t\t\tcamera_port =\n\t\t\t    &dev->component[COMP_CAMERA]->output[CAM_PORT_VIDEO];\n\t\telse\n\t\t\tcamera_port =\n\t\t\t    &dev->component[COMP_CAMERA]->output[CAM_PORT_CAPTURE];\n\t\tport = camera_port;\n\t\tbreak;\n\tcase COMP_IMAGE_ENCODE:\n\t\tencode_component = dev->component[COMP_IMAGE_ENCODE];\n\t\tport = &dev->component[COMP_IMAGE_ENCODE]->output[0];\n\t\tcamera_port =\n\t\t    &dev->component[COMP_CAMERA]->output[CAM_PORT_CAPTURE];\n\t\tbreak;\n\tcase COMP_VIDEO_ENCODE:\n\t\tencode_component = dev->component[COMP_VIDEO_ENCODE];\n\t\tport = &dev->component[COMP_VIDEO_ENCODE]->output[0];\n\t\tcamera_port =\n\t\t    &dev->component[COMP_CAMERA]->output[CAM_PORT_VIDEO];\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!port)\n\t\treturn -EINVAL;\n\n\tif (encode_component)\n\t\tcamera_port->format.encoding = MMAL_ENCODING_OPAQUE;\n\telse\n\t\tcamera_port->format.encoding = mfmt->mmal;\n\n\tif (dev->rgb_bgr_swapped) {\n\t\tif (camera_port->format.encoding == MMAL_ENCODING_RGB24)\n\t\t\tcamera_port->format.encoding = MMAL_ENCODING_BGR24;\n\t\telse if (camera_port->format.encoding == MMAL_ENCODING_BGR24)\n\t\t\tcamera_port->format.encoding = MMAL_ENCODING_RGB24;\n\t}\n\n\tremove_padding = mfmt->remove_padding;\n\tvchiq_mmal_port_parameter_set(dev->instance, camera_port,\n\t\t\t\t      MMAL_PARAMETER_NO_IMAGE_PADDING,\n\t\t\t\t      &remove_padding, sizeof(remove_padding));\n\n\tcamera_port->format.encoding_variant = 0;\n\tcamera_port->es.video.width = f->fmt.pix.width;\n\tcamera_port->es.video.height = f->fmt.pix.height;\n\tcamera_port->es.video.crop.x = 0;\n\tcamera_port->es.video.crop.y = 0;\n\tcamera_port->es.video.crop.width = f->fmt.pix.width;\n\tcamera_port->es.video.crop.height = f->fmt.pix.height;\n\tcamera_port->es.video.frame_rate.numerator = 0;\n\tcamera_port->es.video.frame_rate.denominator = 1;\n\tcamera_port->es.video.color_space = MMAL_COLOR_SPACE_JPEG_JFIF;\n\n\tret = vchiq_mmal_port_set_format(dev->instance, camera_port);\n\n\tif (!ret &&\n\t    camera_port ==\n\t    &dev->component[COMP_CAMERA]->output[CAM_PORT_VIDEO]) {\n\t\tret = mmal_setup_video_component(dev, f);\n\t}\n\n\tif (ret) {\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"%s failed to set format %dx%d %08X\\n\", __func__,\n\t\t\t f->fmt.pix.width, f->fmt.pix.height,\n\t\t\t f->fmt.pix.pixelformat);\n\t\t \n\t\tdev->capture.port = NULL;\n\t\treturn ret;\n\t}\n\n\tif (encode_component) {\n\t\tret = mmal_setup_encode_component(dev, f, port,\n\t\t\t\t\t\t  camera_port,\n\t\t\t\t\t\t  encode_component);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tcamera_port->current_buffer.num = 1;\n\t\tcamera_port->current_buffer.size = f->fmt.pix.sizeimage;\n\t\tcamera_port->current_buffer.alignment = 0;\n\t}\n\n\tdev->capture.fmt = mfmt;\n\tdev->capture.stride = f->fmt.pix.bytesperline;\n\tdev->capture.width = camera_port->es.video.crop.width;\n\tdev->capture.height = camera_port->es.video.crop.height;\n\tdev->capture.buffersize = port->current_buffer.size;\n\n\t \n\tdev->capture.port = port;\n\tdev->capture.camera_port = camera_port;\n\tdev->capture.encode_component = encode_component;\n\tv4l2_dbg(1, bcm2835_v4l2_debug,\n\t\t &dev->v4l2_dev,\n\t\t\"Set dev->capture.fmt %08X, %dx%d, stride %d, size %d\",\n\t\tport->format.encoding,\n\t\tdev->capture.width, dev->capture.height,\n\t\tdev->capture.stride, dev->capture.buffersize);\n\n\t \n\treturn ret;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tint ret;\n\tstruct bcm2835_mmal_dev *dev = video_drvdata(file);\n\tstruct mmal_fmt *mfmt;\n\n\t \n\tret = vidioc_try_fmt_vid_cap(file, priv, f);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"vid_cap - vidioc_try_fmt_vid_cap failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (vb2_is_busy(&dev->capture.vb_vidq)) {\n\t\tv4l2_info(&dev->v4l2_dev, \"%s device busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tmfmt = get_format(f);\n\tif (!mfmt) {\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"Fourcc format (0x%08x) unknown.\\n\",\n\t\t\t f->fmt.pix.pixelformat);\n\t\tf->fmt.pix.pixelformat = formats[0].fourcc;\n\t\tmfmt = get_format(f);\n\t}\n\n\tret = mmal_setup_components(dev, f);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"%s: failed to setup mmal components: %d\\n\",\n\t\t\t __func__, ret);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int vidioc_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tstruct bcm2835_mmal_dev *dev = video_drvdata(file);\n\tstatic const struct v4l2_frmsize_stepwise sizes = {\n\t\tMIN_WIDTH, 0, 2,\n\t\tMIN_HEIGHT, 0, 2\n\t};\n\tint i;\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++)\n\t\tif (formats[i].fourcc == fsize->pixel_format)\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(formats))\n\t\treturn -EINVAL;\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise = sizes;\n\tfsize->stepwise.max_width = dev->max_width;\n\tfsize->stepwise.max_height = dev->max_height;\n\treturn 0;\n}\n\n \nstatic int vidioc_enum_frameintervals(struct file *file, void *priv,\n\t\t\t\t      struct v4l2_frmivalenum *fival)\n{\n\tstruct bcm2835_mmal_dev *dev = video_drvdata(file);\n\tint i;\n\n\tif (fival->index)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++)\n\t\tif (formats[i].fourcc == fival->pixel_format)\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(formats))\n\t\treturn -EINVAL;\n\n\t \n\tif (fival->width < MIN_WIDTH || fival->width > dev->max_width ||\n\t    fival->height < MIN_HEIGHT || fival->height > dev->max_height)\n\t\treturn -EINVAL;\n\n\tfival->type = V4L2_FRMIVAL_TYPE_CONTINUOUS;\n\n\t \n\tfival->stepwise.min  = tpf_min;\n\tfival->stepwise.max  = tpf_max;\n\tfival->stepwise.step = (struct v4l2_fract) {1, 1};\n\n\treturn 0;\n}\n\nstatic int vidioc_g_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *parm)\n{\n\tstruct bcm2835_mmal_dev *dev = video_drvdata(file);\n\n\tif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tparm->parm.capture.capability   = V4L2_CAP_TIMEPERFRAME;\n\tparm->parm.capture.timeperframe = dev->capture.timeperframe;\n\tparm->parm.capture.readbuffers  = 1;\n\treturn 0;\n}\n\nstatic int vidioc_s_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *parm)\n{\n\tstruct bcm2835_mmal_dev *dev = video_drvdata(file);\n\tstruct v4l2_fract tpf;\n\n\tif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\ttpf = parm->parm.capture.timeperframe;\n\n\t \n\ttpf = tpf.denominator ? tpf : tpf_default;\n\ttpf = V4L2_FRACT_COMPARE(tpf, <, tpf_min) ? tpf_min : tpf;\n\ttpf = V4L2_FRACT_COMPARE(tpf, >, tpf_max) ? tpf_max : tpf;\n\n\tdev->capture.timeperframe = tpf;\n\tparm->parm.capture.timeperframe = tpf;\n\tparm->parm.capture.readbuffers  = 1;\n\tparm->parm.capture.capability   = V4L2_CAP_TIMEPERFRAME;\n\n\tset_framerate_params(dev);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops camera0_ioctl_ops = {\n\t \n\t.vidioc_enum_fmt_vid_overlay = vidioc_enum_fmt_vid_overlay,\n\t.vidioc_g_fmt_vid_overlay = vidioc_g_fmt_vid_overlay,\n\t.vidioc_try_fmt_vid_overlay = vidioc_try_fmt_vid_overlay,\n\t.vidioc_s_fmt_vid_overlay = vidioc_s_fmt_vid_overlay,\n\t.vidioc_overlay = vidioc_overlay,\n\t.vidioc_g_fbuf = vidioc_g_fbuf,\n\n\t \n\t.vidioc_enum_input = vidioc_enum_input,\n\t.vidioc_g_input = vidioc_g_input,\n\t.vidioc_s_input = vidioc_s_input,\n\n\t \n\t.vidioc_querycap = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap = vidioc_s_fmt_vid_cap,\n\n\t \n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t.vidioc_enum_framesizes = vidioc_enum_framesizes,\n\t.vidioc_enum_frameintervals = vidioc_enum_frameintervals,\n\t.vidioc_g_parm        = vidioc_g_parm,\n\t.vidioc_s_parm        = vidioc_s_parm,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n\n\t.vidioc_log_status = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\n \n\nstatic const struct v4l2_file_operations camera0_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.read = vb2_fop_read,\n\t.poll = vb2_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\t \n\t.mmap = vb2_fop_mmap,\n};\n\nstatic const struct video_device vdev_template = {\n\t.name = \"camera0\",\n\t.fops = &camera0_fops,\n\t.ioctl_ops = &camera0_ioctl_ops,\n\t.release = video_device_release_empty,\n\t.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OVERLAY |\n\t\t       V4L2_CAP_STREAMING | V4L2_CAP_READWRITE,\n};\n\n \nstatic int get_num_cameras(struct vchiq_mmal_instance *instance,\n\t\t\t   unsigned int resolutions[][2], int num_resolutions)\n{\n\tint ret;\n\tstruct vchiq_mmal_component  *cam_info_component;\n\tstruct mmal_parameter_camera_info cam_info = {0};\n\tu32 param_size = sizeof(cam_info);\n\tint i;\n\n\t \n\tret = vchiq_mmal_component_init(instance, \"camera_info\",\n\t\t\t\t\t&cam_info_component);\n\tif (ret < 0)\n\t\t \n\t\treturn 1;\n\n\tif (vchiq_mmal_port_parameter_get(instance,\n\t\t\t\t\t  &cam_info_component->control,\n\t\t\t\t\t  MMAL_PARAMETER_CAMERA_INFO,\n\t\t\t\t\t  &cam_info,\n\t\t\t\t\t  &param_size)) {\n\t\tpr_info(\"Failed to get camera info\\n\");\n\t}\n\tfor (i = 0;\n\t     i < min_t(unsigned int, cam_info.num_cameras, num_resolutions);\n\t     i++) {\n\t\tresolutions[i][0] = cam_info.cameras[i].max_width;\n\t\tresolutions[i][1] = cam_info.cameras[i].max_height;\n\t}\n\n\tvchiq_mmal_component_finalise(instance,\n\t\t\t\t      cam_info_component);\n\n\treturn cam_info.num_cameras;\n}\n\nstatic int set_camera_parameters(struct vchiq_mmal_instance *instance,\n\t\t\t\t struct vchiq_mmal_component *camera,\n\t\t\t\t struct bcm2835_mmal_dev *dev)\n{\n\tstruct mmal_parameter_camera_config cam_config = {\n\t\t.max_stills_w = dev->max_width,\n\t\t.max_stills_h = dev->max_height,\n\t\t.stills_yuv422 = 1,\n\t\t.one_shot_stills = 1,\n\t\t.max_preview_video_w = (max_video_width > 1920) ?\n\t\t\t\t\t\tmax_video_width : 1920,\n\t\t.max_preview_video_h = (max_video_height > 1088) ?\n\t\t\t\t\t\tmax_video_height : 1088,\n\t\t.num_preview_video_frames = 3,\n\t\t.stills_capture_circular_buffer_height = 0,\n\t\t.fast_preview_resume = 0,\n\t\t.use_stc_timestamp = MMAL_PARAM_TIMESTAMP_MODE_RAW_STC\n\t};\n\n\treturn vchiq_mmal_port_parameter_set(instance, &camera->control,\n\t\t\t\t\t    MMAL_PARAMETER_CAMERA_CONFIG,\n\t\t\t\t\t    &cam_config, sizeof(cam_config));\n}\n\n#define MAX_SUPPORTED_ENCODINGS 20\n\n \nstatic int mmal_init(struct bcm2835_mmal_dev *dev)\n{\n\tint ret;\n\tstruct mmal_es_format_local *format;\n\tu32 supported_encodings[MAX_SUPPORTED_ENCODINGS];\n\tu32 param_size;\n\tstruct vchiq_mmal_component  *camera;\n\n\tret = vchiq_mmal_init(&dev->instance);\n\tif (ret < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"%s: vchiq mmal init failed %d\\n\",\n\t\t\t __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = vchiq_mmal_component_init(dev->instance, \"ril.camera\",\n\t\t\t\t\t&dev->component[COMP_CAMERA]);\n\tif (ret < 0)\n\t\tgoto unreg_mmal;\n\n\tcamera = dev->component[COMP_CAMERA];\n\tif (camera->outputs < CAM_PORT_COUNT) {\n\t\tv4l2_err(&dev->v4l2_dev, \"%s: too few camera outputs %d needed %d\\n\",\n\t\t\t __func__, camera->outputs, CAM_PORT_COUNT);\n\t\tret = -EINVAL;\n\t\tgoto unreg_camera;\n\t}\n\n\tret = set_camera_parameters(dev->instance,\n\t\t\t\t    camera,\n\t\t\t\t    dev);\n\tif (ret < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"%s: unable to set camera parameters: %d\\n\",\n\t\t\t __func__, ret);\n\t\tgoto unreg_camera;\n\t}\n\n\t \n\tdev->rgb_bgr_swapped = true;\n\tparam_size = sizeof(supported_encodings);\n\tret = vchiq_mmal_port_parameter_get(dev->instance,\n\t\t\t\t\t    &camera->output[CAM_PORT_CAPTURE],\n\t\t\t\t\t    MMAL_PARAMETER_SUPPORTED_ENCODINGS,\n\t\t\t\t\t    &supported_encodings,\n\t\t\t\t\t    &param_size);\n\tif (ret == 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < param_size / sizeof(u32); i++) {\n\t\t\tif (supported_encodings[i] == MMAL_ENCODING_BGR24) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (supported_encodings[i] == MMAL_ENCODING_RGB24) {\n\t\t\t\t \n\t\t\t\tdev->rgb_bgr_swapped = false;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tformat = &camera->output[CAM_PORT_PREVIEW].format;\n\n\tformat->encoding = MMAL_ENCODING_OPAQUE;\n\tformat->encoding_variant = MMAL_ENCODING_I420;\n\n\tformat->es->video.width = 1024;\n\tformat->es->video.height = 768;\n\tformat->es->video.crop.x = 0;\n\tformat->es->video.crop.y = 0;\n\tformat->es->video.crop.width = 1024;\n\tformat->es->video.crop.height = 768;\n\tformat->es->video.frame_rate.numerator = 0;  \n\tformat->es->video.frame_rate.denominator = 1;\n\n\tformat = &camera->output[CAM_PORT_VIDEO].format;\n\n\tformat->encoding = MMAL_ENCODING_OPAQUE;\n\tformat->encoding_variant = MMAL_ENCODING_I420;\n\n\tformat->es->video.width = 1024;\n\tformat->es->video.height = 768;\n\tformat->es->video.crop.x = 0;\n\tformat->es->video.crop.y = 0;\n\tformat->es->video.crop.width = 1024;\n\tformat->es->video.crop.height = 768;\n\tformat->es->video.frame_rate.numerator = 0;  \n\tformat->es->video.frame_rate.denominator = 1;\n\n\tformat = &camera->output[CAM_PORT_CAPTURE].format;\n\n\tformat->encoding = MMAL_ENCODING_OPAQUE;\n\n\tformat->es->video.width = 2592;\n\tformat->es->video.height = 1944;\n\tformat->es->video.crop.x = 0;\n\tformat->es->video.crop.y = 0;\n\tformat->es->video.crop.width = 2592;\n\tformat->es->video.crop.height = 1944;\n\tformat->es->video.frame_rate.numerator = 0;  \n\tformat->es->video.frame_rate.denominator = 1;\n\n\tdev->capture.width = format->es->video.width;\n\tdev->capture.height = format->es->video.height;\n\tdev->capture.fmt = &formats[0];\n\tdev->capture.encode_component = NULL;\n\tdev->capture.timeperframe = tpf_default;\n\tdev->capture.enc_profile = V4L2_MPEG_VIDEO_H264_PROFILE_HIGH;\n\tdev->capture.enc_level = V4L2_MPEG_VIDEO_H264_LEVEL_4_0;\n\n\t \n\tret = vchiq_mmal_component_init(dev->instance, \"ril.video_render\",\n\t\t\t\t\t&dev->component[COMP_PREVIEW]);\n\tif (ret < 0)\n\t\tgoto unreg_camera;\n\n\tif (dev->component[COMP_PREVIEW]->inputs < 1) {\n\t\tret = -EINVAL;\n\t\tv4l2_err(&dev->v4l2_dev, \"%s: too few input ports %d needed %d\\n\",\n\t\t\t __func__, dev->component[COMP_PREVIEW]->inputs, 1);\n\t\tgoto unreg_preview;\n\t}\n\n\t \n\tret = vchiq_mmal_component_init(dev->instance, \"ril.image_encode\",\n\t\t\t\t\t&dev->component[COMP_IMAGE_ENCODE]);\n\tif (ret < 0)\n\t\tgoto unreg_preview;\n\n\tif (dev->component[COMP_IMAGE_ENCODE]->inputs < 1) {\n\t\tret = -EINVAL;\n\t\tv4l2_err(&dev->v4l2_dev, \"%s: too few input ports %d needed %d\\n\",\n\t\t\t __func__, dev->component[COMP_IMAGE_ENCODE]->inputs,\n\t\t\t 1);\n\t\tgoto unreg_image_encoder;\n\t}\n\n\t \n\tret = vchiq_mmal_component_init(dev->instance, \"ril.video_encode\",\n\t\t\t\t\t&dev->component[COMP_VIDEO_ENCODE]);\n\tif (ret < 0)\n\t\tgoto unreg_image_encoder;\n\n\tif (dev->component[COMP_VIDEO_ENCODE]->inputs < 1) {\n\t\tret = -EINVAL;\n\t\tv4l2_err(&dev->v4l2_dev, \"%s: too few input ports %d needed %d\\n\",\n\t\t\t __func__, dev->component[COMP_VIDEO_ENCODE]->inputs,\n\t\t\t 1);\n\t\tgoto unreg_vid_encoder;\n\t}\n\n\t{\n\t\tstruct vchiq_mmal_port *encoder_port =\n\t\t\t&dev->component[COMP_VIDEO_ENCODE]->output[0];\n\t\tencoder_port->format.encoding = MMAL_ENCODING_H264;\n\t\tret = vchiq_mmal_port_set_format(dev->instance,\n\t\t\t\t\t\t encoder_port);\n\t}\n\n\t{\n\t\tunsigned int enable = 1;\n\n\t\tvchiq_mmal_port_parameter_set(\n\t\t\tdev->instance,\n\t\t\t&dev->component[COMP_VIDEO_ENCODE]->control,\n\t\t\tMMAL_PARAMETER_VIDEO_IMMUTABLE_INPUT,\n\t\t\t&enable, sizeof(enable));\n\n\t\tvchiq_mmal_port_parameter_set(dev->instance,\n\t\t\t\t\t      &dev->component[COMP_VIDEO_ENCODE]->control,\n\t\t\t\t\t      MMAL_PARAMETER_MINIMISE_FRAGMENTATION,\n\t\t\t\t\t      &enable,\n\t\t\t\t\t      sizeof(enable));\n\t}\n\tret = bcm2835_mmal_set_all_camera_controls(dev);\n\tif (ret < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"%s: failed to set all camera controls: %d\\n\",\n\t\t\t __func__, ret);\n\t\tgoto unreg_vid_encoder;\n\t}\n\n\treturn 0;\n\nunreg_vid_encoder:\n\tpr_err(\"Cleanup: Destroy video encoder\\n\");\n\tvchiq_mmal_component_finalise(dev->instance,\n\t\t\t\t      dev->component[COMP_VIDEO_ENCODE]);\n\nunreg_image_encoder:\n\tpr_err(\"Cleanup: Destroy image encoder\\n\");\n\tvchiq_mmal_component_finalise(dev->instance,\n\t\t\t\t      dev->component[COMP_IMAGE_ENCODE]);\n\nunreg_preview:\n\tpr_err(\"Cleanup: Destroy video render\\n\");\n\tvchiq_mmal_component_finalise(dev->instance,\n\t\t\t\t      dev->component[COMP_PREVIEW]);\n\nunreg_camera:\n\tpr_err(\"Cleanup: Destroy camera\\n\");\n\tvchiq_mmal_component_finalise(dev->instance,\n\t\t\t\t      dev->component[COMP_CAMERA]);\n\nunreg_mmal:\n\tvchiq_mmal_finalise(dev->instance);\n\treturn ret;\n}\n\nstatic int bcm2835_mmal_init_device(struct bcm2835_mmal_dev *dev, struct video_device *vfd)\n{\n\tint ret;\n\n\t*vfd = vdev_template;\n\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\n\tvfd->lock = &dev->mutex;\n\n\tvfd->queue = &dev->capture.vb_vidq;\n\n\t \n\tvideo_set_drvdata(vfd, dev);\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO,\n\t\t\t\t    video_nr[dev->camera_num]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_info(vfd->v4l2_dev,\n\t\t  \"V4L2 device registered as %s - stills mode > %dx%d\\n\",\n\t\t  video_device_node_name(vfd),\n\t\t  max_video_width, max_video_height);\n\n\treturn 0;\n}\n\nstatic void bcm2835_cleanup_instance(struct bcm2835_mmal_dev *dev)\n{\n\tif (!dev)\n\t\treturn;\n\n\tv4l2_info(&dev->v4l2_dev, \"unregistering %s\\n\",\n\t\t  video_device_node_name(&dev->vdev));\n\n\tvideo_unregister_device(&dev->vdev);\n\n\tif (dev->capture.encode_component) {\n\t\tv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\n\t\t\t \"mmal_exit - disconnect tunnel\\n\");\n\t\tvchiq_mmal_port_connect_tunnel(dev->instance,\n\t\t\t\t\t       dev->capture.camera_port, NULL);\n\t\tvchiq_mmal_component_disable(dev->instance,\n\t\t\t\t\t     dev->capture.encode_component);\n\t}\n\tvchiq_mmal_component_disable(dev->instance,\n\t\t\t\t     dev->component[COMP_CAMERA]);\n\n\tvchiq_mmal_component_finalise(dev->instance,\n\t\t\t\t      dev->component[COMP_VIDEO_ENCODE]);\n\n\tvchiq_mmal_component_finalise(dev->instance,\n\t\t\t\t      dev->component[COMP_IMAGE_ENCODE]);\n\n\tvchiq_mmal_component_finalise(dev->instance,\n\t\t\t\t      dev->component[COMP_PREVIEW]);\n\n\tvchiq_mmal_component_finalise(dev->instance,\n\t\t\t\t      dev->component[COMP_CAMERA]);\n\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\n\tkfree(dev);\n}\n\nstatic struct v4l2_format default_v4l2_format = {\n\t.fmt.pix.pixelformat = V4L2_PIX_FMT_JPEG,\n\t.fmt.pix.width = 1024,\n\t.fmt.pix.bytesperline = 0,\n\t.fmt.pix.height = 768,\n\t.fmt.pix.sizeimage = 1024 * 768,\n};\n\nstatic int bcm2835_mmal_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct bcm2835_mmal_dev *dev;\n\tstruct vb2_queue *q;\n\tint camera;\n\tunsigned int num_cameras;\n\tstruct vchiq_mmal_instance *instance;\n\tunsigned int resolutions[MAX_BCM2835_CAMERAS][2];\n\tint i;\n\n\tret = vchiq_mmal_init(&instance);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnum_cameras = get_num_cameras(instance,\n\t\t\t\t      resolutions,\n\t\t\t\t      MAX_BCM2835_CAMERAS);\n\n\tif (num_cameras < 1) {\n\t\tret = -ENODEV;\n\t\tgoto cleanup_mmal;\n\t}\n\n\tif (num_cameras > MAX_BCM2835_CAMERAS)\n\t\tnum_cameras = MAX_BCM2835_CAMERAS;\n\n\tfor (camera = 0; camera < num_cameras; camera++) {\n\t\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\t\tif (!dev) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto cleanup_gdev;\n\t\t}\n\n\t\t \n\t\tmutex_init(&dev->mutex);\n\t\tdev->max_width = resolutions[camera][0];\n\t\tdev->max_height = resolutions[camera][1];\n\n\t\t \n\t\tdev->overlay.w.left = 150;\n\t\tdev->overlay.w.top = 50;\n\t\tdev->overlay.w.width = 1024;\n\t\tdev->overlay.w.height = 768;\n\t\tdev->overlay.clipcount = 0;\n\t\tdev->overlay.field = V4L2_FIELD_NONE;\n\t\tdev->overlay.global_alpha = 255;\n\n\t\tdev->capture.fmt = &formats[3];  \n\n\t\t \n\t\tdev->camera_num = v4l2_device_set_name(&dev->v4l2_dev, KBUILD_MODNAME,\n\t\t\t\t\t\t       &camera_instance);\n\t\tret = v4l2_device_register(NULL, &dev->v4l2_dev);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"%s: could not register V4L2 device: %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tgoto free_dev;\n\t\t}\n\n\t\t \n\t\tret = bcm2835_mmal_init_controls(dev, &dev->ctrl_handler);\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"%s: could not init controls: %d\\n\",\n\t\t\t\t __func__, ret);\n\t\t\tgoto unreg_dev;\n\t\t}\n\t\tdev->v4l2_dev.ctrl_handler = &dev->ctrl_handler;\n\n\t\t \n\t\tdev->instance = instance;\n\t\tret = mmal_init(dev);\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"%s: mmal init failed: %d\\n\",\n\t\t\t\t __func__, ret);\n\t\t\tgoto unreg_dev;\n\t\t}\n\t\t \n\t\tq = &dev->capture.vb_vidq;\n\t\tmemset(q, 0, sizeof(*q));\n\t\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\t\tq->drv_priv = dev;\n\t\tq->buf_struct_size = sizeof(struct vb2_mmal_buffer);\n\t\tq->ops = &bcm2835_mmal_video_qops;\n\t\tq->mem_ops = &vb2_vmalloc_memops;\n\t\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\t\tq->lock = &dev->mutex;\n\t\tret = vb2_queue_init(q);\n\t\tif (ret < 0)\n\t\t\tgoto unreg_dev;\n\n\t\t \n\t\tret = bcm2835_mmal_init_device(dev, &dev->vdev);\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"%s: could not init device: %d\\n\",\n\t\t\t\t __func__, ret);\n\t\t\tgoto unreg_dev;\n\t\t}\n\n\t\t \n\t\tret = mmal_setup_components(dev, &default_v4l2_format);\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"%s: could not setup components: %d\\n\",\n\t\t\t\t __func__, ret);\n\t\t\tgoto unreg_dev;\n\t\t}\n\n\t\tv4l2_info(&dev->v4l2_dev, \"Broadcom 2835 MMAL video capture loaded.\\n\");\n\n\t\tgdev[camera] = dev;\n\t}\n\treturn 0;\n\nunreg_dev:\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\nfree_dev:\n\tkfree(dev);\n\ncleanup_gdev:\n\tfor (i = 0; i < camera; i++) {\n\t\tbcm2835_cleanup_instance(gdev[i]);\n\t\tgdev[i] = NULL;\n\t}\n\ncleanup_mmal:\n\tvchiq_mmal_finalise(instance);\n\n\treturn ret;\n}\n\nstatic void bcm2835_mmal_remove(struct platform_device *pdev)\n{\n\tint camera;\n\tstruct vchiq_mmal_instance *instance = gdev[0]->instance;\n\n\tfor (camera = 0; camera < MAX_BCM2835_CAMERAS; camera++) {\n\t\tbcm2835_cleanup_instance(gdev[camera]);\n\t\tgdev[camera] = NULL;\n\t}\n\tvchiq_mmal_finalise(instance);\n}\n\nstatic struct platform_driver bcm2835_camera_driver = {\n\t.probe\t\t= bcm2835_mmal_probe,\n\t.remove_new\t= bcm2835_mmal_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"bcm2835-camera\",\n\t},\n};\n\nmodule_platform_driver(bcm2835_camera_driver)\n\nMODULE_DESCRIPTION(\"Broadcom 2835 MMAL video capture\");\nMODULE_AUTHOR(\"Vincent Sanders\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:bcm2835-camera\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}