{
  "module_name": "mmal-vchiq.c",
  "hash_id": "165cb87ed33bdd6a63bb5ca44e624149f095dcdaed7fb576409aa53924f89209",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vc04_services/vchiq-mmal/mmal-vchiq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"../include/linux/raspberrypi/vchiq.h\"\n#include \"mmal-common.h\"\n#include \"mmal-vchiq.h\"\n#include \"mmal-msg.h\"\n\n \n#define VCHIQ_MMAL_MAX_COMPONENTS 64\n\n \n#define SYNC_MSG_TIMEOUT       3\n\n \n\n#ifdef DEBUG\nstatic const char *const msg_type_names[] = {\n\t\"UNKNOWN\",\n\t\"QUIT\",\n\t\"SERVICE_CLOSED\",\n\t\"GET_VERSION\",\n\t\"COMPONENT_CREATE\",\n\t\"COMPONENT_DESTROY\",\n\t\"COMPONENT_ENABLE\",\n\t\"COMPONENT_DISABLE\",\n\t\"PORT_INFO_GET\",\n\t\"PORT_INFO_SET\",\n\t\"PORT_ACTION\",\n\t\"BUFFER_FROM_HOST\",\n\t\"BUFFER_TO_HOST\",\n\t\"GET_STATS\",\n\t\"PORT_PARAMETER_SET\",\n\t\"PORT_PARAMETER_GET\",\n\t\"EVENT_TO_HOST\",\n\t\"GET_CORE_STATS_FOR_PORT\",\n\t\"OPAQUE_ALLOCATOR\",\n\t\"CONSUME_MEM\",\n\t\"LMK\",\n\t\"OPAQUE_ALLOCATOR_DESC\",\n\t\"DRM_GET_LHS32\",\n\t\"DRM_GET_TIME\",\n\t\"BUFFER_FROM_HOST_ZEROLEN\",\n\t\"PORT_FLUSH\",\n\t\"HOST_LOG\",\n};\n#endif\n\nstatic const char *const port_action_type_names[] = {\n\t\"UNKNOWN\",\n\t\"ENABLE\",\n\t\"DISABLE\",\n\t\"FLUSH\",\n\t\"CONNECT\",\n\t\"DISCONNECT\",\n\t\"SET_REQUIREMENTS\",\n};\n\n#if defined(DEBUG)\n#if defined(FULL_MSG_DUMP)\n#define DBG_DUMP_MSG(MSG, MSG_LEN, TITLE)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tpr_debug(TITLE\" type:%s(%d) length:%d\\n\",\t\t\\\n\t\t\t msg_type_names[(MSG)->h.type],\t\t\t\\\n\t\t\t (MSG)->h.type, (MSG_LEN));\t\t\t\\\n\t\tprint_hex_dump(KERN_DEBUG, \"<<h: \", DUMP_PREFIX_OFFSET,\t\\\n\t\t\t       16, 4, (MSG),\t\t\t\t\\\n\t\t\t       sizeof(struct mmal_msg_header), 1);\t\\\n\t\tprint_hex_dump(KERN_DEBUG, \"<<p: \", DUMP_PREFIX_OFFSET,\t\\\n\t\t\t       16, 4,\t\t\t\t\t\\\n\t\t\t       ((u8 *)(MSG)) + sizeof(struct mmal_msg_header),\\\n\t\t\t       (MSG_LEN) - sizeof(struct mmal_msg_header), 1); \\\n\t} while (0)\n#else\n#define DBG_DUMP_MSG(MSG, MSG_LEN, TITLE)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tpr_debug(TITLE\" type:%s(%d) length:%d\\n\",\t\t\\\n\t\t\t msg_type_names[(MSG)->h.type],\t\t\t\\\n\t\t\t (MSG)->h.type, (MSG_LEN));\t\t\t\\\n\t}\n#endif\n#else\n#define DBG_DUMP_MSG(MSG, MSG_LEN, TITLE)\n#endif\n\nstruct vchiq_mmal_instance;\n\n \nstruct mmal_msg_context {\n\tstruct vchiq_mmal_instance *instance;\n\n\t \n\tint handle;\n\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\tstruct work_struct work;\n\t\t\t \n\t\t\tstruct work_struct buffer_to_host_work;\n\t\t\t \n\t\t\tstruct vchiq_mmal_instance *instance;\n\t\t\t \n\t\t\tstruct vchiq_mmal_port *port;\n\t\t\t \n\t\t\tstruct mmal_buffer *buffer;\n\t\t\t \n\t\t\tunsigned long buffer_used;\n\t\t\t \n\t\t\tu32 mmal_flags;\n\t\t\t \n\t\t\ts64 pts;\n\t\t\ts64 dts;\n\n\t\t\tint status;\t \n\n\t\t} bulk;\t\t \n\n\t\tstruct {\n\t\t\t \n\t\t\tstruct vchiq_header *msg_handle;\n\t\t\t \n\t\t\tstruct mmal_msg *msg;\n\t\t\t \n\t\t\tu32 msg_len;\n\t\t\t \n\t\t\tstruct completion cmplt;\n\t\t} sync;\t\t \n\t} u;\n\n};\n\nstruct vchiq_mmal_instance {\n\tunsigned int service_handle;\n\n\t \n\tstruct mutex vchiq_mutex;\n\n\tstruct idr context_map;\n\t \n\tstruct mutex context_map_lock;\n\n\tstruct vchiq_mmal_component component[VCHIQ_MMAL_MAX_COMPONENTS];\n\n\t \n\tstruct workqueue_struct *bulk_wq;\n\n\t \n\tstruct vchiq_instance *vchiq_instance;\n};\n\nstatic struct mmal_msg_context *\nget_msg_context(struct vchiq_mmal_instance *instance)\n{\n\tstruct mmal_msg_context *msg_context;\n\tint handle;\n\n\t \n\tmsg_context = kzalloc(sizeof(*msg_context), GFP_KERNEL);\n\n\tif (!msg_context)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tmutex_lock(&instance->context_map_lock);\n\thandle = idr_alloc(&instance->context_map, msg_context,\n\t\t\t   0, 0, GFP_KERNEL);\n\tmutex_unlock(&instance->context_map_lock);\n\n\tif (handle < 0) {\n\t\tkfree(msg_context);\n\t\treturn ERR_PTR(handle);\n\t}\n\n\tmsg_context->instance = instance;\n\tmsg_context->handle = handle;\n\n\treturn msg_context;\n}\n\nstatic struct mmal_msg_context *\nlookup_msg_context(struct vchiq_mmal_instance *instance, int handle)\n{\n\treturn idr_find(&instance->context_map, handle);\n}\n\nstatic void\nrelease_msg_context(struct mmal_msg_context *msg_context)\n{\n\tstruct vchiq_mmal_instance *instance = msg_context->instance;\n\n\tmutex_lock(&instance->context_map_lock);\n\tidr_remove(&instance->context_map, msg_context->handle);\n\tmutex_unlock(&instance->context_map_lock);\n\tkfree(msg_context);\n}\n\n \nstatic void event_to_host_cb(struct vchiq_mmal_instance *instance,\n\t\t\t     struct mmal_msg *msg, u32 msg_len)\n{\n\tpr_debug(\"unhandled event\\n\");\n\tpr_debug(\"component:%u port type:%d num:%d cmd:0x%x length:%d\\n\",\n\t\t msg->u.event_to_host.client_component,\n\t\t msg->u.event_to_host.port_type,\n\t\t msg->u.event_to_host.port_num,\n\t\t msg->u.event_to_host.cmd, msg->u.event_to_host.length);\n}\n\n \nstatic void buffer_work_cb(struct work_struct *work)\n{\n\tstruct mmal_msg_context *msg_context =\n\t\tcontainer_of(work, struct mmal_msg_context, u.bulk.work);\n\tstruct mmal_buffer *buffer = msg_context->u.bulk.buffer;\n\n\tif (!buffer) {\n\t\tpr_err(\"%s: ctx: %p, No mmal buffer to pass details\\n\",\n\t\t       __func__, msg_context);\n\t\treturn;\n\t}\n\n\tbuffer->length = msg_context->u.bulk.buffer_used;\n\tbuffer->mmal_flags = msg_context->u.bulk.mmal_flags;\n\tbuffer->dts = msg_context->u.bulk.dts;\n\tbuffer->pts = msg_context->u.bulk.pts;\n\n\tatomic_dec(&msg_context->u.bulk.port->buffers_with_vpu);\n\n\tmsg_context->u.bulk.port->buffer_cb(msg_context->u.bulk.instance,\n\t\t\t\t\t    msg_context->u.bulk.port,\n\t\t\t\t\t    msg_context->u.bulk.status,\n\t\t\t\t\t    msg_context->u.bulk.buffer);\n}\n\n \nstatic void buffer_to_host_work_cb(struct work_struct *work)\n{\n\tstruct mmal_msg_context *msg_context =\n\t\tcontainer_of(work, struct mmal_msg_context,\n\t\t\t     u.bulk.buffer_to_host_work);\n\tstruct vchiq_mmal_instance *instance = msg_context->instance;\n\tunsigned long len = msg_context->u.bulk.buffer_used;\n\tint ret;\n\n\tif (!len)\n\t\t \n\t\tlen = 8;\n\t \n\tvchiq_use_service(instance->vchiq_instance, instance->service_handle);\n\tret = vchiq_bulk_receive(instance->vchiq_instance, instance->service_handle,\n\t\t\t\t msg_context->u.bulk.buffer->buffer,\n\t\t\t\t  \n\t\t\t\t(len + 3) & ~3,\n\t\t\t\tmsg_context,\n\t\t\t\tVCHIQ_BULK_MODE_CALLBACK);\n\n\tvchiq_release_service(instance->vchiq_instance, instance->service_handle);\n\n\tif (ret != 0)\n\t\tpr_err(\"%s: ctx: %p, vchiq_bulk_receive failed %d\\n\",\n\t\t       __func__, msg_context, ret);\n}\n\n \nstatic int bulk_receive(struct vchiq_mmal_instance *instance,\n\t\t\tstruct mmal_msg *msg,\n\t\t\tstruct mmal_msg_context *msg_context)\n{\n\tunsigned long rd_len;\n\n\trd_len = msg->u.buffer_from_host.buffer_header.length;\n\n\tif (!msg_context->u.bulk.buffer) {\n\t\tpr_err(\"bulk.buffer not configured - error in buffer_from_host\\n\");\n\n\t\t \n\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rd_len > msg_context->u.bulk.buffer->buffer_size) {\n\t\trd_len = msg_context->u.bulk.buffer->buffer_size;\n\t\tpr_warn(\"short read as not enough receive buffer space\\n\");\n\t\t \n\t}\n\n\t \n\tmsg_context->u.bulk.buffer_used = rd_len;\n\tmsg_context->u.bulk.dts = msg->u.buffer_from_host.buffer_header.dts;\n\tmsg_context->u.bulk.pts = msg->u.buffer_from_host.buffer_header.pts;\n\n\tqueue_work(msg_context->instance->bulk_wq,\n\t\t   &msg_context->u.bulk.buffer_to_host_work);\n\n\treturn 0;\n}\n\n \nstatic int inline_receive(struct vchiq_mmal_instance *instance,\n\t\t\t  struct mmal_msg *msg,\n\t\t\t  struct mmal_msg_context *msg_context)\n{\n\tmemcpy(msg_context->u.bulk.buffer->buffer,\n\t       msg->u.buffer_from_host.short_data,\n\t       msg->u.buffer_from_host.payload_in_message);\n\n\tmsg_context->u.bulk.buffer_used =\n\t    msg->u.buffer_from_host.payload_in_message;\n\n\treturn 0;\n}\n\n \nstatic int\nbuffer_from_host(struct vchiq_mmal_instance *instance,\n\t\t struct vchiq_mmal_port *port, struct mmal_buffer *buf)\n{\n\tstruct mmal_msg_context *msg_context;\n\tstruct mmal_msg m;\n\tint ret;\n\n\tif (!port->enabled)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"instance:%u buffer:%p\\n\", instance->service_handle, buf);\n\n\t \n\tif (!buf->msg_context) {\n\t\tpr_err(\"%s: msg_context not allocated, buf %p\\n\", __func__,\n\t\t       buf);\n\t\treturn -EINVAL;\n\t}\n\tmsg_context = buf->msg_context;\n\n\t \n\tmsg_context->u.bulk.instance = instance;\n\tmsg_context->u.bulk.port = port;\n\tmsg_context->u.bulk.buffer = buf;\n\tmsg_context->u.bulk.buffer_used = 0;\n\n\t \n\tINIT_WORK(&msg_context->u.bulk.work, buffer_work_cb);\n\tINIT_WORK(&msg_context->u.bulk.buffer_to_host_work,\n\t\t  buffer_to_host_work_cb);\n\n\tatomic_inc(&port->buffers_with_vpu);\n\n\t \n\tmemset(&m, 0xbc, sizeof(m));\t \n\n\tm.h.type = MMAL_MSG_TYPE_BUFFER_FROM_HOST;\n\tm.h.magic = MMAL_MAGIC;\n\tm.h.context = msg_context->handle;\n\tm.h.status = 0;\n\n\t \n\tm.u.buffer_from_host.drvbuf.magic = MMAL_MAGIC;\n\tm.u.buffer_from_host.drvbuf.component_handle = port->component->handle;\n\tm.u.buffer_from_host.drvbuf.port_handle = port->handle;\n\tm.u.buffer_from_host.drvbuf.client_context = msg_context->handle;\n\n\t \n\tm.u.buffer_from_host.buffer_header.cmd = 0;\n\tm.u.buffer_from_host.buffer_header.data =\n\t\t(u32)(unsigned long)buf->buffer;\n\tm.u.buffer_from_host.buffer_header.alloc_size = buf->buffer_size;\n\tm.u.buffer_from_host.buffer_header.length = 0;\t \n\tm.u.buffer_from_host.buffer_header.offset = 0;\t \n\tm.u.buffer_from_host.buffer_header.flags = 0;\t \n\tm.u.buffer_from_host.buffer_header.pts = MMAL_TIME_UNKNOWN;\n\tm.u.buffer_from_host.buffer_header.dts = MMAL_TIME_UNKNOWN;\n\n\t \n\tmemset(&m.u.buffer_from_host.buffer_header_type_specific, 0,\n\t       sizeof(m.u.buffer_from_host.buffer_header_type_specific));\n\n\t \n\tm.u.buffer_from_host.payload_in_message = 0;\n\n\tvchiq_use_service(instance->vchiq_instance, instance->service_handle);\n\n\tret = vchiq_queue_kernel_message(instance->vchiq_instance, instance->service_handle, &m,\n\t\t\t\t\t sizeof(struct mmal_msg_header) +\n\t\t\t\t\t sizeof(m.u.buffer_from_host));\n\tif (ret)\n\t\tatomic_dec(&port->buffers_with_vpu);\n\n\tvchiq_release_service(instance->vchiq_instance, instance->service_handle);\n\n\treturn ret;\n}\n\n \nstatic void buffer_to_host_cb(struct vchiq_mmal_instance *instance,\n\t\t\t      struct mmal_msg *msg, u32 msg_len)\n{\n\tstruct mmal_msg_context *msg_context;\n\tu32 handle;\n\n\tpr_debug(\"%s: instance:%p msg:%p msg_len:%d\\n\",\n\t\t __func__, instance, msg, msg_len);\n\n\tif (msg->u.buffer_from_host.drvbuf.magic == MMAL_MAGIC) {\n\t\thandle = msg->u.buffer_from_host.drvbuf.client_context;\n\t\tmsg_context = lookup_msg_context(instance, handle);\n\n\t\tif (!msg_context) {\n\t\t\tpr_err(\"drvbuf.client_context(%u) is invalid\\n\",\n\t\t\t       handle);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tpr_err(\"MMAL_MSG_TYPE_BUFFER_TO_HOST with bad magic\\n\");\n\t\treturn;\n\t}\n\n\tmsg_context->u.bulk.mmal_flags =\n\t\t\t\tmsg->u.buffer_from_host.buffer_header.flags;\n\n\tif (msg->h.status != MMAL_MSG_STATUS_SUCCESS) {\n\t\t \n\t\tpr_warn(\"error %d in reply\\n\", msg->h.status);\n\n\t\tmsg_context->u.bulk.status = msg->h.status;\n\n\t} else if (msg->u.buffer_from_host.buffer_header.length == 0) {\n\t\t \n\t\tif (msg->u.buffer_from_host.buffer_header.flags &\n\t\t    MMAL_BUFFER_HEADER_FLAG_EOS) {\n\t\t\tmsg_context->u.bulk.status =\n\t\t\t    bulk_receive(instance, msg, msg_context);\n\t\t\tif (msg_context->u.bulk.status == 0)\n\t\t\t\treturn;\t \n\t\t} else {\n\t\t\t \n\t\t\tmsg_context->u.bulk.status = 0;\n\t\t\tmsg_context->u.bulk.buffer_used = 0;\n\t\t}\n\t} else if (msg->u.buffer_from_host.payload_in_message == 0) {\n\t\t \n\t\tmsg_context->u.bulk.status =\n\t\t    bulk_receive(instance, msg, msg_context);\n\t\tif (msg_context->u.bulk.status == 0)\n\t\t\treturn;\t \n\n\t\t \n\t\tpr_err(\"error %d on bulk submission\\n\",\n\t\t       msg_context->u.bulk.status);\n\n\t} else if (msg->u.buffer_from_host.payload_in_message <=\n\t\t   MMAL_VC_SHORT_DATA) {\n\t\t \n\t\tmsg_context->u.bulk.status = inline_receive(instance, msg,\n\t\t\t\t\t\t\t    msg_context);\n\t} else {\n\t\tpr_err(\"message with invalid short payload\\n\");\n\n\t\t \n\t\tmsg_context->u.bulk.status = -EINVAL;\n\t\tmsg_context->u.bulk.buffer_used =\n\t\t    msg->u.buffer_from_host.payload_in_message;\n\t}\n\n\t \n\tschedule_work(&msg_context->u.bulk.work);\n}\n\nstatic void bulk_receive_cb(struct vchiq_mmal_instance *instance,\n\t\t\t    struct mmal_msg_context *msg_context)\n{\n\tmsg_context->u.bulk.status = 0;\n\n\t \n\tschedule_work(&msg_context->u.bulk.work);\n}\n\nstatic void bulk_abort_cb(struct vchiq_mmal_instance *instance,\n\t\t\t  struct mmal_msg_context *msg_context)\n{\n\tpr_err(\"%s: bulk ABORTED msg_context:%p\\n\", __func__, msg_context);\n\n\tmsg_context->u.bulk.status = -EINTR;\n\n\tschedule_work(&msg_context->u.bulk.work);\n}\n\n \nstatic int service_callback(struct vchiq_instance *vchiq_instance,\n\t\t\t    enum vchiq_reason reason, struct vchiq_header *header,\n\t\t\t    unsigned int handle, void *bulk_ctx)\n{\n\tstruct vchiq_mmal_instance *instance = vchiq_get_service_userdata(vchiq_instance, handle);\n\tu32 msg_len;\n\tstruct mmal_msg *msg;\n\tstruct mmal_msg_context *msg_context;\n\n\tif (!instance) {\n\t\tpr_err(\"Message callback passed NULL instance\\n\");\n\t\treturn 0;\n\t}\n\n\tswitch (reason) {\n\tcase VCHIQ_MESSAGE_AVAILABLE:\n\t\tmsg = (void *)header->data;\n\t\tmsg_len = header->size;\n\n\t\tDBG_DUMP_MSG(msg, msg_len, \"<<< reply message\");\n\n\t\t \n\t\tswitch (msg->h.type) {\n\t\tcase MMAL_MSG_TYPE_BUFFER_FROM_HOST:\n\t\t\tvchiq_release_message(vchiq_instance, handle, header);\n\t\t\tbreak;\n\n\t\tcase MMAL_MSG_TYPE_EVENT_TO_HOST:\n\t\t\tevent_to_host_cb(instance, msg, msg_len);\n\t\t\tvchiq_release_message(vchiq_instance, handle, header);\n\n\t\t\tbreak;\n\n\t\tcase MMAL_MSG_TYPE_BUFFER_TO_HOST:\n\t\t\tbuffer_to_host_cb(instance, msg, msg_len);\n\t\t\tvchiq_release_message(vchiq_instance, handle, header);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tif (!msg->h.context) {\n\t\t\t\tpr_err(\"received message context was null!\\n\");\n\t\t\t\tvchiq_release_message(vchiq_instance, handle, header);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmsg_context = lookup_msg_context(instance,\n\t\t\t\t\t\t\t msg->h.context);\n\t\t\tif (!msg_context) {\n\t\t\t\tpr_err(\"received invalid message context %u!\\n\",\n\t\t\t\t       msg->h.context);\n\t\t\t\tvchiq_release_message(vchiq_instance, handle, header);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tmsg_context->u.sync.msg_handle = header;\n\t\t\tmsg_context->u.sync.msg = msg;\n\t\t\tmsg_context->u.sync.msg_len = msg_len;\n\n\t\t\t \n\n\t\t\t \n\t\t\tcomplete(&msg_context->u.sync.cmplt);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase VCHIQ_BULK_RECEIVE_DONE:\n\t\tbulk_receive_cb(instance, bulk_ctx);\n\t\tbreak;\n\n\tcase VCHIQ_BULK_RECEIVE_ABORTED:\n\t\tbulk_abort_cb(instance, bulk_ctx);\n\t\tbreak;\n\n\tcase VCHIQ_SERVICE_CLOSED:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"Received unhandled message reason %d\\n\", reason);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int send_synchronous_mmal_msg(struct vchiq_mmal_instance *instance,\n\t\t\t\t     struct mmal_msg *msg,\n\t\t\t\t     unsigned int payload_len,\n\t\t\t\t     struct mmal_msg **msg_out,\n\t\t\t\t     struct vchiq_header **msg_handle)\n{\n\tstruct mmal_msg_context *msg_context;\n\tint ret;\n\tunsigned long timeout;\n\n\t \n\tif (payload_len >\n\t    (MMAL_MSG_MAX_SIZE - sizeof(struct mmal_msg_header))) {\n\t\tpr_err(\"payload length %d exceeds max:%d\\n\", payload_len,\n\t\t       (int)(MMAL_MSG_MAX_SIZE -\n\t\t\t    sizeof(struct mmal_msg_header)));\n\t\treturn -EINVAL;\n\t}\n\n\tmsg_context = get_msg_context(instance);\n\tif (IS_ERR(msg_context))\n\t\treturn PTR_ERR(msg_context);\n\n\tinit_completion(&msg_context->u.sync.cmplt);\n\n\tmsg->h.magic = MMAL_MAGIC;\n\tmsg->h.context = msg_context->handle;\n\tmsg->h.status = 0;\n\n\tDBG_DUMP_MSG(msg, (sizeof(struct mmal_msg_header) + payload_len),\n\t\t     \">>> sync message\");\n\n\tvchiq_use_service(instance->vchiq_instance, instance->service_handle);\n\n\tret = vchiq_queue_kernel_message(instance->vchiq_instance, instance->service_handle, msg,\n\t\t\t\t\t sizeof(struct mmal_msg_header) +\n\t\t\t\t\t payload_len);\n\n\tvchiq_release_service(instance->vchiq_instance, instance->service_handle);\n\n\tif (ret) {\n\t\tpr_err(\"error %d queuing message\\n\", ret);\n\t\trelease_msg_context(msg_context);\n\t\treturn ret;\n\t}\n\n\ttimeout = wait_for_completion_timeout(&msg_context->u.sync.cmplt,\n\t\t\t\t\t      SYNC_MSG_TIMEOUT * HZ);\n\tif (timeout == 0) {\n\t\tpr_err(\"timed out waiting for sync completion\\n\");\n\t\tret = -ETIME;\n\t\t \n\t\trelease_msg_context(msg_context);\n\t\treturn ret;\n\t}\n\n\t*msg_out = msg_context->u.sync.msg;\n\t*msg_handle = msg_context->u.sync.msg_handle;\n\trelease_msg_context(msg_context);\n\n\treturn 0;\n}\n\nstatic void dump_port_info(struct vchiq_mmal_port *port)\n{\n\tpr_debug(\"port handle:0x%x enabled:%d\\n\", port->handle, port->enabled);\n\n\tpr_debug(\"buffer minimum num:%d size:%d align:%d\\n\",\n\t\t port->minimum_buffer.num,\n\t\t port->minimum_buffer.size, port->minimum_buffer.alignment);\n\n\tpr_debug(\"buffer recommended num:%d size:%d align:%d\\n\",\n\t\t port->recommended_buffer.num,\n\t\t port->recommended_buffer.size,\n\t\t port->recommended_buffer.alignment);\n\n\tpr_debug(\"buffer current values num:%d size:%d align:%d\\n\",\n\t\t port->current_buffer.num,\n\t\t port->current_buffer.size, port->current_buffer.alignment);\n\n\tpr_debug(\"elementary stream: type:%d encoding:0x%x variant:0x%x\\n\",\n\t\t port->format.type,\n\t\t port->format.encoding, port->format.encoding_variant);\n\n\tpr_debug(\"\t\t    bitrate:%d flags:0x%x\\n\",\n\t\t port->format.bitrate, port->format.flags);\n\n\tif (port->format.type == MMAL_ES_TYPE_VIDEO) {\n\t\tpr_debug\n\t\t    (\"es video format: width:%d height:%d colourspace:0x%x\\n\",\n\t\t     port->es.video.width, port->es.video.height,\n\t\t     port->es.video.color_space);\n\n\t\tpr_debug(\"\t\t : crop xywh %d,%d,%d,%d\\n\",\n\t\t\t port->es.video.crop.x,\n\t\t\t port->es.video.crop.y,\n\t\t\t port->es.video.crop.width, port->es.video.crop.height);\n\t\tpr_debug(\"\t\t : framerate %d/%d  aspect %d/%d\\n\",\n\t\t\t port->es.video.frame_rate.numerator,\n\t\t\t port->es.video.frame_rate.denominator,\n\t\t\t port->es.video.par.numerator, port->es.video.par.denominator);\n\t}\n}\n\nstatic void port_to_mmal_msg(struct vchiq_mmal_port *port, struct mmal_port *p)\n{\n\t \n\tp->type = port->type;\n\tp->index = port->index;\n\tp->index_all = 0;\n\tp->is_enabled = port->enabled;\n\tp->buffer_num_min = port->minimum_buffer.num;\n\tp->buffer_size_min = port->minimum_buffer.size;\n\tp->buffer_alignment_min = port->minimum_buffer.alignment;\n\tp->buffer_num_recommended = port->recommended_buffer.num;\n\tp->buffer_size_recommended = port->recommended_buffer.size;\n\n\t \n\tp->buffer_num = port->current_buffer.num;\n\tp->buffer_size = port->current_buffer.size;\n\tp->userdata = (u32)(unsigned long)port;\n}\n\nstatic int port_info_set(struct vchiq_mmal_instance *instance,\n\t\t\t struct vchiq_mmal_port *port)\n{\n\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tstruct vchiq_header *rmsg_handle;\n\n\tpr_debug(\"setting port info port %p\\n\", port);\n\tif (!port)\n\t\treturn -1;\n\tdump_port_info(port);\n\n\tm.h.type = MMAL_MSG_TYPE_PORT_INFO_SET;\n\n\tm.u.port_info_set.component_handle = port->component->handle;\n\tm.u.port_info_set.port_type = port->type;\n\tm.u.port_info_set.port_index = port->index;\n\n\tport_to_mmal_msg(port, &m.u.port_info_set.port);\n\n\t \n\tm.u.port_info_set.format.type = port->format.type;\n\tm.u.port_info_set.format.encoding = port->format.encoding;\n\tm.u.port_info_set.format.encoding_variant =\n\t    port->format.encoding_variant;\n\tm.u.port_info_set.format.bitrate = port->format.bitrate;\n\tm.u.port_info_set.format.flags = port->format.flags;\n\n\tmemcpy(&m.u.port_info_set.es, &port->es,\n\t       sizeof(union mmal_es_specific_format));\n\n\tm.u.port_info_set.format.extradata_size = port->format.extradata_size;\n\tmemcpy(&m.u.port_info_set.extradata, port->format.extradata,\n\t       port->format.extradata_size);\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\tsizeof(m.u.port_info_set),\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != MMAL_MSG_TYPE_PORT_INFO_SET) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto release_msg;\n\t}\n\n\t \n\tret = -rmsg->u.port_info_get_reply.status;\n\n\tpr_debug(\"%s:result:%d component:0x%x port:%d\\n\", __func__, ret,\n\t\t port->component->handle, port->handle);\n\nrelease_msg:\n\tvchiq_release_message(instance->vchiq_instance, instance->service_handle, rmsg_handle);\n\n\treturn ret;\n}\n\n \nstatic int port_info_get(struct vchiq_mmal_instance *instance,\n\t\t\t struct vchiq_mmal_port *port)\n{\n\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tstruct vchiq_header *rmsg_handle;\n\n\t \n\tm.h.type = MMAL_MSG_TYPE_PORT_INFO_GET;\n\tm.u.port_info_get.component_handle = port->component->handle;\n\tm.u.port_info_get.port_type = port->type;\n\tm.u.port_info_get.index = port->index;\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\tsizeof(m.u.port_info_get),\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != MMAL_MSG_TYPE_PORT_INFO_GET) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto release_msg;\n\t}\n\n\t \n\tret = -rmsg->u.port_info_get_reply.status;\n\tif (ret != MMAL_MSG_STATUS_SUCCESS)\n\t\tgoto release_msg;\n\n\tif (rmsg->u.port_info_get_reply.port.is_enabled == 0)\n\t\tport->enabled = false;\n\telse\n\t\tport->enabled = true;\n\n\t \n\tport->handle = rmsg->u.port_info_get_reply.port_handle;\n\n\t \n\tport->type = rmsg->u.port_info_get_reply.port_type;\n\tport->index = rmsg->u.port_info_get_reply.port_index;\n\n\tport->minimum_buffer.num =\n\t    rmsg->u.port_info_get_reply.port.buffer_num_min;\n\tport->minimum_buffer.size =\n\t    rmsg->u.port_info_get_reply.port.buffer_size_min;\n\tport->minimum_buffer.alignment =\n\t    rmsg->u.port_info_get_reply.port.buffer_alignment_min;\n\n\tport->recommended_buffer.alignment =\n\t    rmsg->u.port_info_get_reply.port.buffer_alignment_min;\n\tport->recommended_buffer.num =\n\t    rmsg->u.port_info_get_reply.port.buffer_num_recommended;\n\n\tport->current_buffer.num = rmsg->u.port_info_get_reply.port.buffer_num;\n\tport->current_buffer.size =\n\t    rmsg->u.port_info_get_reply.port.buffer_size;\n\n\t \n\tport->format.type = rmsg->u.port_info_get_reply.format.type;\n\tport->format.encoding = rmsg->u.port_info_get_reply.format.encoding;\n\tport->format.encoding_variant =\n\t    rmsg->u.port_info_get_reply.format.encoding_variant;\n\tport->format.bitrate = rmsg->u.port_info_get_reply.format.bitrate;\n\tport->format.flags = rmsg->u.port_info_get_reply.format.flags;\n\n\t \n\tmemcpy(&port->es,\n\t       &rmsg->u.port_info_get_reply.es,\n\t       sizeof(union mmal_es_specific_format));\n\tport->format.es = &port->es;\n\n\tport->format.extradata_size =\n\t    rmsg->u.port_info_get_reply.format.extradata_size;\n\tmemcpy(port->format.extradata,\n\t       rmsg->u.port_info_get_reply.extradata,\n\t       port->format.extradata_size);\n\n\tpr_debug(\"received port info\\n\");\n\tdump_port_info(port);\n\nrelease_msg:\n\n\tpr_debug(\"%s:result:%d component:0x%x port:%d\\n\",\n\t\t __func__, ret, port->component->handle, port->handle);\n\n\tvchiq_release_message(instance->vchiq_instance, instance->service_handle, rmsg_handle);\n\n\treturn ret;\n}\n\n \nstatic int create_component(struct vchiq_mmal_instance *instance,\n\t\t\t    struct vchiq_mmal_component *component,\n\t\t\t    const char *name)\n{\n\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tstruct vchiq_header *rmsg_handle;\n\n\t \n\tm.h.type = MMAL_MSG_TYPE_COMPONENT_CREATE;\n\tm.u.component_create.client_component = component->client_component;\n\tstrncpy(m.u.component_create.name, name,\n\t\tsizeof(m.u.component_create.name));\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\tsizeof(m.u.component_create),\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != m.h.type) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto release_msg;\n\t}\n\n\tret = -rmsg->u.component_create_reply.status;\n\tif (ret != MMAL_MSG_STATUS_SUCCESS)\n\t\tgoto release_msg;\n\n\t \n\tcomponent->handle = rmsg->u.component_create_reply.component_handle;\n\tcomponent->inputs = rmsg->u.component_create_reply.input_num;\n\tcomponent->outputs = rmsg->u.component_create_reply.output_num;\n\tcomponent->clocks = rmsg->u.component_create_reply.clock_num;\n\n\tpr_debug(\"Component handle:0x%x in:%d out:%d clock:%d\\n\",\n\t\t component->handle,\n\t\t component->inputs, component->outputs, component->clocks);\n\nrelease_msg:\n\tvchiq_release_message(instance->vchiq_instance, instance->service_handle, rmsg_handle);\n\n\treturn ret;\n}\n\n \nstatic int destroy_component(struct vchiq_mmal_instance *instance,\n\t\t\t     struct vchiq_mmal_component *component)\n{\n\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tstruct vchiq_header *rmsg_handle;\n\n\tm.h.type = MMAL_MSG_TYPE_COMPONENT_DESTROY;\n\tm.u.component_destroy.component_handle = component->handle;\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\tsizeof(m.u.component_destroy),\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != m.h.type) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto release_msg;\n\t}\n\n\tret = -rmsg->u.component_destroy_reply.status;\n\nrelease_msg:\n\n\tvchiq_release_message(instance->vchiq_instance, instance->service_handle, rmsg_handle);\n\n\treturn ret;\n}\n\n \nstatic int enable_component(struct vchiq_mmal_instance *instance,\n\t\t\t    struct vchiq_mmal_component *component)\n{\n\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tstruct vchiq_header *rmsg_handle;\n\n\tm.h.type = MMAL_MSG_TYPE_COMPONENT_ENABLE;\n\tm.u.component_enable.component_handle = component->handle;\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\tsizeof(m.u.component_enable),\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != m.h.type) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto release_msg;\n\t}\n\n\tret = -rmsg->u.component_enable_reply.status;\n\nrelease_msg:\n\tvchiq_release_message(instance->vchiq_instance, instance->service_handle, rmsg_handle);\n\n\treturn ret;\n}\n\n \nstatic int disable_component(struct vchiq_mmal_instance *instance,\n\t\t\t     struct vchiq_mmal_component *component)\n{\n\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tstruct vchiq_header *rmsg_handle;\n\n\tm.h.type = MMAL_MSG_TYPE_COMPONENT_DISABLE;\n\tm.u.component_disable.component_handle = component->handle;\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\tsizeof(m.u.component_disable),\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != m.h.type) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto release_msg;\n\t}\n\n\tret = -rmsg->u.component_disable_reply.status;\n\nrelease_msg:\n\n\tvchiq_release_message(instance->vchiq_instance, instance->service_handle, rmsg_handle);\n\n\treturn ret;\n}\n\n \nstatic int get_version(struct vchiq_mmal_instance *instance,\n\t\t       u32 *major_out, u32 *minor_out)\n{\n\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tstruct vchiq_header *rmsg_handle;\n\n\tm.h.type = MMAL_MSG_TYPE_GET_VERSION;\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\tsizeof(m.u.version),\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != m.h.type) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto release_msg;\n\t}\n\n\t*major_out = rmsg->u.version.major;\n\t*minor_out = rmsg->u.version.minor;\n\nrelease_msg:\n\tvchiq_release_message(instance->vchiq_instance, instance->service_handle, rmsg_handle);\n\n\treturn ret;\n}\n\n \nstatic int port_action_port(struct vchiq_mmal_instance *instance,\n\t\t\t    struct vchiq_mmal_port *port,\n\t\t\t    enum mmal_msg_port_action_type action_type)\n{\n\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tstruct vchiq_header *rmsg_handle;\n\n\tm.h.type = MMAL_MSG_TYPE_PORT_ACTION;\n\tm.u.port_action_port.component_handle = port->component->handle;\n\tm.u.port_action_port.port_handle = port->handle;\n\tm.u.port_action_port.action = action_type;\n\n\tport_to_mmal_msg(port, &m.u.port_action_port.port);\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\tsizeof(m.u.port_action_port),\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != MMAL_MSG_TYPE_PORT_ACTION) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto release_msg;\n\t}\n\n\tret = -rmsg->u.port_action_reply.status;\n\n\tpr_debug(\"%s:result:%d component:0x%x port:%d action:%s(%d)\\n\",\n\t\t __func__,\n\t\t ret, port->component->handle, port->handle,\n\t\t port_action_type_names[action_type], action_type);\n\nrelease_msg:\n\tvchiq_release_message(instance->vchiq_instance, instance->service_handle, rmsg_handle);\n\n\treturn ret;\n}\n\n \nstatic int port_action_handle(struct vchiq_mmal_instance *instance,\n\t\t\t      struct vchiq_mmal_port *port,\n\t\t\t      enum mmal_msg_port_action_type action_type,\n\t\t\t      u32 connect_component_handle,\n\t\t\t      u32 connect_port_handle)\n{\n\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tstruct vchiq_header *rmsg_handle;\n\n\tm.h.type = MMAL_MSG_TYPE_PORT_ACTION;\n\n\tm.u.port_action_handle.component_handle = port->component->handle;\n\tm.u.port_action_handle.port_handle = port->handle;\n\tm.u.port_action_handle.action = action_type;\n\n\tm.u.port_action_handle.connect_component_handle =\n\t    connect_component_handle;\n\tm.u.port_action_handle.connect_port_handle = connect_port_handle;\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\tsizeof(m.u.port_action_handle),\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != MMAL_MSG_TYPE_PORT_ACTION) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto release_msg;\n\t}\n\n\tret = -rmsg->u.port_action_reply.status;\n\n\tpr_debug(\"%s:result:%d component:0x%x port:%d action:%s(%d) connect component:0x%x connect port:%d\\n\",\n\t\t __func__,\n\t\t ret, port->component->handle, port->handle,\n\t\t port_action_type_names[action_type],\n\t\t action_type, connect_component_handle, connect_port_handle);\n\nrelease_msg:\n\tvchiq_release_message(instance->vchiq_instance, instance->service_handle, rmsg_handle);\n\n\treturn ret;\n}\n\nstatic int port_parameter_set(struct vchiq_mmal_instance *instance,\n\t\t\t      struct vchiq_mmal_port *port,\n\t\t\t      u32 parameter_id, void *value, u32 value_size)\n{\n\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tstruct vchiq_header *rmsg_handle;\n\n\tm.h.type = MMAL_MSG_TYPE_PORT_PARAMETER_SET;\n\n\tm.u.port_parameter_set.component_handle = port->component->handle;\n\tm.u.port_parameter_set.port_handle = port->handle;\n\tm.u.port_parameter_set.id = parameter_id;\n\tm.u.port_parameter_set.size = (2 * sizeof(u32)) + value_size;\n\tmemcpy(&m.u.port_parameter_set.value, value, value_size);\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\t(4 * sizeof(u32)) + value_size,\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != MMAL_MSG_TYPE_PORT_PARAMETER_SET) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto release_msg;\n\t}\n\n\tret = -rmsg->u.port_parameter_set_reply.status;\n\n\tpr_debug(\"%s:result:%d component:0x%x port:%d parameter:%d\\n\",\n\t\t __func__,\n\t\t ret, port->component->handle, port->handle, parameter_id);\n\nrelease_msg:\n\tvchiq_release_message(instance->vchiq_instance, instance->service_handle, rmsg_handle);\n\n\treturn ret;\n}\n\nstatic int port_parameter_get(struct vchiq_mmal_instance *instance,\n\t\t\t      struct vchiq_mmal_port *port,\n\t\t\t      u32 parameter_id, void *value, u32 *value_size)\n{\n\tint ret;\n\tstruct mmal_msg m;\n\tstruct mmal_msg *rmsg;\n\tstruct vchiq_header *rmsg_handle;\n\n\tm.h.type = MMAL_MSG_TYPE_PORT_PARAMETER_GET;\n\n\tm.u.port_parameter_get.component_handle = port->component->handle;\n\tm.u.port_parameter_get.port_handle = port->handle;\n\tm.u.port_parameter_get.id = parameter_id;\n\tm.u.port_parameter_get.size = (2 * sizeof(u32)) + *value_size;\n\n\tret = send_synchronous_mmal_msg(instance, &m,\n\t\t\t\t\tsizeof(struct\n\t\t\t\t\t       mmal_msg_port_parameter_get),\n\t\t\t\t\t&rmsg, &rmsg_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rmsg->h.type != MMAL_MSG_TYPE_PORT_PARAMETER_GET) {\n\t\t \n\t\tpr_err(\"Incorrect reply type %d\\n\", rmsg->h.type);\n\t\tret = -EINVAL;\n\t\tgoto release_msg;\n\t}\n\n\tret = rmsg->u.port_parameter_get_reply.status;\n\n\t \n\trmsg->u.port_parameter_get_reply.size -= (2 * sizeof(u32));\n\n\tif (ret || rmsg->u.port_parameter_get_reply.size > *value_size) {\n\t\t \n\t\tmemcpy(value, &rmsg->u.port_parameter_get_reply.value,\n\t\t       *value_size);\n\t} else {\n\t\tmemcpy(value, &rmsg->u.port_parameter_get_reply.value,\n\t\t       rmsg->u.port_parameter_get_reply.size);\n\t}\n\t \n\t*value_size = rmsg->u.port_parameter_get_reply.size;\n\n\tpr_debug(\"%s:result:%d component:0x%x port:%d parameter:%d\\n\", __func__,\n\t\t ret, port->component->handle, port->handle, parameter_id);\n\nrelease_msg:\n\tvchiq_release_message(instance->vchiq_instance, instance->service_handle, rmsg_handle);\n\n\treturn ret;\n}\n\n \nstatic int port_disable(struct vchiq_mmal_instance *instance,\n\t\t\tstruct vchiq_mmal_port *port)\n{\n\tint ret;\n\tstruct list_head *q, *buf_head;\n\tunsigned long flags = 0;\n\n\tif (!port->enabled)\n\t\treturn 0;\n\n\tport->enabled = false;\n\n\tret = port_action_port(instance, port,\n\t\t\t       MMAL_MSG_PORT_ACTION_TYPE_DISABLE);\n\tif (ret == 0) {\n\t\t \n\t\tspin_lock_irqsave(&port->slock, flags);\n\n\t\tlist_for_each_safe(buf_head, q, &port->buffers) {\n\t\t\tstruct mmal_buffer *mmalbuf;\n\n\t\t\tmmalbuf = list_entry(buf_head, struct mmal_buffer,\n\t\t\t\t\t     list);\n\t\t\tlist_del(buf_head);\n\t\t\tif (port->buffer_cb) {\n\t\t\t\tmmalbuf->length = 0;\n\t\t\t\tmmalbuf->mmal_flags = 0;\n\t\t\t\tmmalbuf->dts = MMAL_TIME_UNKNOWN;\n\t\t\t\tmmalbuf->pts = MMAL_TIME_UNKNOWN;\n\t\t\t\tport->buffer_cb(instance,\n\t\t\t\t\t\tport, 0, mmalbuf);\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock_irqrestore(&port->slock, flags);\n\n\t\tret = port_info_get(instance, port);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int port_enable(struct vchiq_mmal_instance *instance,\n\t\t       struct vchiq_mmal_port *port)\n{\n\tunsigned int hdr_count;\n\tstruct list_head *q, *buf_head;\n\tint ret;\n\n\tif (port->enabled)\n\t\treturn 0;\n\n\tret = port_action_port(instance, port,\n\t\t\t       MMAL_MSG_PORT_ACTION_TYPE_ENABLE);\n\tif (ret)\n\t\tgoto done;\n\n\tport->enabled = true;\n\n\tif (port->buffer_cb) {\n\t\t \n\t\thdr_count = 1;\n\t\tlist_for_each_safe(buf_head, q, &port->buffers) {\n\t\t\tstruct mmal_buffer *mmalbuf;\n\n\t\t\tmmalbuf = list_entry(buf_head, struct mmal_buffer,\n\t\t\t\t\t     list);\n\t\t\tret = buffer_from_host(instance, port, mmalbuf);\n\t\t\tif (ret)\n\t\t\t\tgoto done;\n\n\t\t\tlist_del(buf_head);\n\t\t\thdr_count++;\n\t\t\tif (hdr_count > port->current_buffer.num)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = port_info_get(instance, port);\n\ndone:\n\treturn ret;\n}\n\n \n\nint vchiq_mmal_port_set_format(struct vchiq_mmal_instance *instance,\n\t\t\t       struct vchiq_mmal_port *port)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&instance->vchiq_mutex))\n\t\treturn -EINTR;\n\n\tret = port_info_set(instance, port);\n\tif (ret)\n\t\tgoto release_unlock;\n\n\t \n\tret = port_info_get(instance, port);\n\nrelease_unlock:\n\tmutex_unlock(&instance->vchiq_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_port_set_format);\n\nint vchiq_mmal_port_parameter_set(struct vchiq_mmal_instance *instance,\n\t\t\t\t  struct vchiq_mmal_port *port,\n\t\t\t\t  u32 parameter, void *value, u32 value_size)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&instance->vchiq_mutex))\n\t\treturn -EINTR;\n\n\tret = port_parameter_set(instance, port, parameter, value, value_size);\n\n\tmutex_unlock(&instance->vchiq_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_port_parameter_set);\n\nint vchiq_mmal_port_parameter_get(struct vchiq_mmal_instance *instance,\n\t\t\t\t  struct vchiq_mmal_port *port,\n\t\t\t\t  u32 parameter, void *value, u32 *value_size)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&instance->vchiq_mutex))\n\t\treturn -EINTR;\n\n\tret = port_parameter_get(instance, port, parameter, value, value_size);\n\n\tmutex_unlock(&instance->vchiq_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_port_parameter_get);\n\n \nint vchiq_mmal_port_enable(struct vchiq_mmal_instance *instance,\n\t\t\t   struct vchiq_mmal_port *port,\n\t\t\t   vchiq_mmal_buffer_cb buffer_cb)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&instance->vchiq_mutex))\n\t\treturn -EINTR;\n\n\t \n\tif (port->enabled) {\n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\n\tport->buffer_cb = buffer_cb;\n\n\tret = port_enable(instance, port);\n\nunlock:\n\tmutex_unlock(&instance->vchiq_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_port_enable);\n\nint vchiq_mmal_port_disable(struct vchiq_mmal_instance *instance,\n\t\t\t    struct vchiq_mmal_port *port)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&instance->vchiq_mutex))\n\t\treturn -EINTR;\n\n\tif (!port->enabled) {\n\t\tmutex_unlock(&instance->vchiq_mutex);\n\t\treturn 0;\n\t}\n\n\tret = port_disable(instance, port);\n\n\tmutex_unlock(&instance->vchiq_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_port_disable);\n\n \nint vchiq_mmal_port_connect_tunnel(struct vchiq_mmal_instance *instance,\n\t\t\t\t   struct vchiq_mmal_port *src,\n\t\t\t\t   struct vchiq_mmal_port *dst)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&instance->vchiq_mutex))\n\t\treturn -EINTR;\n\n\t \n\tif (src->connected) {\n\t\tret = port_disable(instance, src);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed disabling src port(%d)\\n\", ret);\n\t\t\tgoto release_unlock;\n\t\t}\n\n\t\t \n\n\t\tret = port_action_handle(instance, src,\n\t\t\t\t\t MMAL_MSG_PORT_ACTION_TYPE_DISCONNECT,\n\t\t\t\t\t src->connected->component->handle,\n\t\t\t\t\t src->connected->handle);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"failed disconnecting src port\\n\");\n\t\t\tgoto release_unlock;\n\t\t}\n\t\tsrc->connected->enabled = false;\n\t\tsrc->connected = NULL;\n\t}\n\n\tif (!dst) {\n\t\t \n\t\tret = 0;\n\t\tpr_debug(\"not making new connection\\n\");\n\t\tgoto release_unlock;\n\t}\n\n\t \n\tdst->format.encoding = src->format.encoding;\n\tdst->es.video.width = src->es.video.width;\n\tdst->es.video.height = src->es.video.height;\n\tdst->es.video.crop.x = src->es.video.crop.x;\n\tdst->es.video.crop.y = src->es.video.crop.y;\n\tdst->es.video.crop.width = src->es.video.crop.width;\n\tdst->es.video.crop.height = src->es.video.crop.height;\n\tdst->es.video.frame_rate.numerator = src->es.video.frame_rate.numerator;\n\tdst->es.video.frame_rate.denominator = src->es.video.frame_rate.denominator;\n\n\t \n\tret = port_info_set(instance, dst);\n\tif (ret) {\n\t\tpr_debug(\"setting port info failed\\n\");\n\t\tgoto release_unlock;\n\t}\n\n\t \n\tret = port_info_get(instance, dst);\n\tif (ret) {\n\t\tpr_debug(\"read back port info failed\\n\");\n\t\tgoto release_unlock;\n\t}\n\n\t \n\tret = port_action_handle(instance, src,\n\t\t\t\t MMAL_MSG_PORT_ACTION_TYPE_CONNECT,\n\t\t\t\t dst->component->handle, dst->handle);\n\tif (ret < 0) {\n\t\tpr_debug(\"connecting port %d:%d to %d:%d failed\\n\",\n\t\t\t src->component->handle, src->handle,\n\t\t\t dst->component->handle, dst->handle);\n\t\tgoto release_unlock;\n\t}\n\tsrc->connected = dst;\n\nrelease_unlock:\n\n\tmutex_unlock(&instance->vchiq_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_port_connect_tunnel);\n\nint vchiq_mmal_submit_buffer(struct vchiq_mmal_instance *instance,\n\t\t\t     struct vchiq_mmal_port *port,\n\t\t\t     struct mmal_buffer *buffer)\n{\n\tunsigned long flags = 0;\n\tint ret;\n\n\tret = buffer_from_host(instance, port, buffer);\n\tif (ret == -EINVAL) {\n\t\t \n\t\tspin_lock_irqsave(&port->slock, flags);\n\t\tlist_add_tail(&buffer->list, &port->buffers);\n\t\tspin_unlock_irqrestore(&port->slock, flags);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_submit_buffer);\n\nint mmal_vchi_buffer_init(struct vchiq_mmal_instance *instance,\n\t\t\t  struct mmal_buffer *buf)\n{\n\tstruct mmal_msg_context *msg_context = get_msg_context(instance);\n\n\tif (IS_ERR(msg_context))\n\t\treturn (PTR_ERR(msg_context));\n\n\tbuf->msg_context = msg_context;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mmal_vchi_buffer_init);\n\nint mmal_vchi_buffer_cleanup(struct mmal_buffer *buf)\n{\n\tstruct mmal_msg_context *msg_context = buf->msg_context;\n\n\tif (msg_context)\n\t\trelease_msg_context(msg_context);\n\tbuf->msg_context = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mmal_vchi_buffer_cleanup);\n\n \nint vchiq_mmal_component_init(struct vchiq_mmal_instance *instance,\n\t\t\t      const char *name,\n\t\t\t      struct vchiq_mmal_component **component_out)\n{\n\tint ret;\n\tint idx;\t\t \n\tstruct vchiq_mmal_component *component = NULL;\n\n\tif (mutex_lock_interruptible(&instance->vchiq_mutex))\n\t\treturn -EINTR;\n\n\tfor (idx = 0; idx < VCHIQ_MMAL_MAX_COMPONENTS; idx++) {\n\t\tif (!instance->component[idx].in_use) {\n\t\t\tcomponent = &instance->component[idx];\n\t\t\tcomponent->in_use = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!component) {\n\t\tret = -EINVAL;\t \n\t\tgoto unlock;\n\t}\n\n\t \n\tcomponent->client_component = idx;\n\n\tret = create_component(instance, component, name);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: failed to create component %d (Not enough GPU mem?)\\n\",\n\t\t       __func__, ret);\n\t\tgoto unlock;\n\t}\n\n\t \n\tcomponent->control.type = MMAL_PORT_TYPE_CONTROL;\n\tcomponent->control.index = 0;\n\tcomponent->control.component = component;\n\tspin_lock_init(&component->control.slock);\n\tINIT_LIST_HEAD(&component->control.buffers);\n\tret = port_info_get(instance, &component->control);\n\tif (ret < 0)\n\t\tgoto release_component;\n\n\tfor (idx = 0; idx < component->inputs; idx++) {\n\t\tcomponent->input[idx].type = MMAL_PORT_TYPE_INPUT;\n\t\tcomponent->input[idx].index = idx;\n\t\tcomponent->input[idx].component = component;\n\t\tspin_lock_init(&component->input[idx].slock);\n\t\tINIT_LIST_HEAD(&component->input[idx].buffers);\n\t\tret = port_info_get(instance, &component->input[idx]);\n\t\tif (ret < 0)\n\t\t\tgoto release_component;\n\t}\n\n\tfor (idx = 0; idx < component->outputs; idx++) {\n\t\tcomponent->output[idx].type = MMAL_PORT_TYPE_OUTPUT;\n\t\tcomponent->output[idx].index = idx;\n\t\tcomponent->output[idx].component = component;\n\t\tspin_lock_init(&component->output[idx].slock);\n\t\tINIT_LIST_HEAD(&component->output[idx].buffers);\n\t\tret = port_info_get(instance, &component->output[idx]);\n\t\tif (ret < 0)\n\t\t\tgoto release_component;\n\t}\n\n\tfor (idx = 0; idx < component->clocks; idx++) {\n\t\tcomponent->clock[idx].type = MMAL_PORT_TYPE_CLOCK;\n\t\tcomponent->clock[idx].index = idx;\n\t\tcomponent->clock[idx].component = component;\n\t\tspin_lock_init(&component->clock[idx].slock);\n\t\tINIT_LIST_HEAD(&component->clock[idx].buffers);\n\t\tret = port_info_get(instance, &component->clock[idx]);\n\t\tif (ret < 0)\n\t\t\tgoto release_component;\n\t}\n\n\t*component_out = component;\n\n\tmutex_unlock(&instance->vchiq_mutex);\n\n\treturn 0;\n\nrelease_component:\n\tdestroy_component(instance, component);\nunlock:\n\tif (component)\n\t\tcomponent->in_use = false;\n\tmutex_unlock(&instance->vchiq_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_component_init);\n\n \nint vchiq_mmal_component_finalise(struct vchiq_mmal_instance *instance,\n\t\t\t\t  struct vchiq_mmal_component *component)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&instance->vchiq_mutex))\n\t\treturn -EINTR;\n\n\tif (component->enabled)\n\t\tret = disable_component(instance, component);\n\n\tret = destroy_component(instance, component);\n\n\tcomponent->in_use = false;\n\n\tmutex_unlock(&instance->vchiq_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_component_finalise);\n\n \nint vchiq_mmal_component_enable(struct vchiq_mmal_instance *instance,\n\t\t\t\tstruct vchiq_mmal_component *component)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&instance->vchiq_mutex))\n\t\treturn -EINTR;\n\n\tif (component->enabled) {\n\t\tmutex_unlock(&instance->vchiq_mutex);\n\t\treturn 0;\n\t}\n\n\tret = enable_component(instance, component);\n\tif (ret == 0)\n\t\tcomponent->enabled = true;\n\n\tmutex_unlock(&instance->vchiq_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_component_enable);\n\n \nint vchiq_mmal_component_disable(struct vchiq_mmal_instance *instance,\n\t\t\t\t struct vchiq_mmal_component *component)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&instance->vchiq_mutex))\n\t\treturn -EINTR;\n\n\tif (!component->enabled) {\n\t\tmutex_unlock(&instance->vchiq_mutex);\n\t\treturn 0;\n\t}\n\n\tret = disable_component(instance, component);\n\tif (ret == 0)\n\t\tcomponent->enabled = false;\n\n\tmutex_unlock(&instance->vchiq_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_component_disable);\n\nint vchiq_mmal_version(struct vchiq_mmal_instance *instance,\n\t\t       u32 *major_out, u32 *minor_out)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&instance->vchiq_mutex))\n\t\treturn -EINTR;\n\n\tret = get_version(instance, major_out, minor_out);\n\n\tmutex_unlock(&instance->vchiq_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_version);\n\nint vchiq_mmal_finalise(struct vchiq_mmal_instance *instance)\n{\n\tint status = 0;\n\n\tif (!instance)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&instance->vchiq_mutex))\n\t\treturn -EINTR;\n\n\tvchiq_use_service(instance->vchiq_instance, instance->service_handle);\n\n\tstatus = vchiq_close_service(instance->vchiq_instance, instance->service_handle);\n\tif (status != 0)\n\t\tpr_err(\"mmal-vchiq: VCHIQ close failed\\n\");\n\n\tmutex_unlock(&instance->vchiq_mutex);\n\n\tvchiq_shutdown(instance->vchiq_instance);\n\tdestroy_workqueue(instance->bulk_wq);\n\n\tidr_destroy(&instance->context_map);\n\n\tkfree(instance);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_finalise);\n\nint vchiq_mmal_init(struct vchiq_mmal_instance **out_instance)\n{\n\tint status;\n\tint err = -ENODEV;\n\tstruct vchiq_mmal_instance *instance;\n\tstruct vchiq_instance *vchiq_instance;\n\tstruct vchiq_service_params_kernel params = {\n\t\t.version\t\t= VC_MMAL_VER,\n\t\t.version_min\t\t= VC_MMAL_MIN_VER,\n\t\t.fourcc\t\t\t= VCHIQ_MAKE_FOURCC('m', 'm', 'a', 'l'),\n\t\t.callback\t\t= service_callback,\n\t\t.userdata\t\t= NULL,\n\t};\n\n\t \n\n\t \n\tBUILD_BUG_ON(sizeof(struct mmal_msg_header) != 24);\n\n\t \n\tBUILD_BUG_ON(sizeof(struct mmal_msg) > MMAL_MSG_MAX_SIZE);\n\n\t \n\tBUILD_BUG_ON(sizeof(struct mmal_port) != 64);\n\n\t \n\tstatus = vchiq_initialise(&vchiq_instance);\n\tif (status) {\n\t\tpr_err(\"Failed to initialise VCHI instance (status=%d)\\n\",\n\t\t       status);\n\t\treturn -EIO;\n\t}\n\n\tstatus = vchiq_connect(vchiq_instance);\n\tif (status) {\n\t\tpr_err(\"Failed to connect VCHI instance (status=%d)\\n\", status);\n\t\terr = -EIO;\n\t\tgoto err_shutdown_vchiq;\n\t}\n\n\tinstance = kzalloc(sizeof(*instance), GFP_KERNEL);\n\n\tif (!instance) {\n\t\terr = -ENOMEM;\n\t\tgoto err_shutdown_vchiq;\n\t}\n\n\tmutex_init(&instance->vchiq_mutex);\n\n\tinstance->vchiq_instance = vchiq_instance;\n\n\tmutex_init(&instance->context_map_lock);\n\tidr_init_base(&instance->context_map, 1);\n\n\tparams.userdata = instance;\n\n\tinstance->bulk_wq = alloc_ordered_workqueue(\"mmal-vchiq\",\n\t\t\t\t\t\t    WQ_MEM_RECLAIM);\n\tif (!instance->bulk_wq)\n\t\tgoto err_free;\n\n\tstatus = vchiq_open_service(vchiq_instance, &params,\n\t\t\t\t    &instance->service_handle);\n\tif (status) {\n\t\tpr_err(\"Failed to open VCHI service connection (status=%d)\\n\",\n\t\t       status);\n\t\tgoto err_close_services;\n\t}\n\n\tvchiq_release_service(instance->vchiq_instance, instance->service_handle);\n\n\t*out_instance = instance;\n\n\treturn 0;\n\nerr_close_services:\n\tvchiq_close_service(instance->vchiq_instance, instance->service_handle);\n\tdestroy_workqueue(instance->bulk_wq);\nerr_free:\n\tkfree(instance);\nerr_shutdown_vchiq:\n\tvchiq_shutdown(vchiq_instance);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vchiq_mmal_init);\n\nMODULE_DESCRIPTION(\"BCM2835 MMAL VCHIQ interface\");\nMODULE_AUTHOR(\"Dave Stevenson, <dave.stevenson@raspberrypi.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}