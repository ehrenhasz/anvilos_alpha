{
  "module_name": "vchiq_arm.c",
  "hash_id": "d22fe8511b311998b5740a31a71c85c282725338d64644cc10cee7fd9610368e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched/signal.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/cdev.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/bug.h>\n#include <linux/completion.h>\n#include <linux/list.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/compat.h>\n#include <linux/dma-mapping.h>\n#include <linux/rcupdate.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <soc/bcm2835/raspberrypi-firmware.h>\n\n#include \"vchiq_core.h\"\n#include \"vchiq_ioctl.h\"\n#include \"vchiq_arm.h\"\n#include \"vchiq_debugfs.h\"\n#include \"vchiq_connected.h\"\n#include \"vchiq_pagelist.h\"\n\n#define DEVICE_NAME \"vchiq\"\n\n#define TOTAL_SLOTS (VCHIQ_SLOT_ZERO_SLOTS + 2 * 32)\n\n#define MAX_FRAGMENTS (VCHIQ_NUM_CURRENT_BULKS * 2)\n\n#define VCHIQ_PLATFORM_FRAGMENTS_OFFSET_IDX 0\n#define VCHIQ_PLATFORM_FRAGMENTS_COUNT_IDX  1\n\n#define BELL0\t0x00\n#define BELL2\t0x08\n\n#define ARM_DS_ACTIVE\tBIT(2)\n\n \n#undef MODULE_PARAM_PREFIX\n#define MODULE_PARAM_PREFIX DEVICE_NAME \".\"\n\n#define KEEPALIVE_VER 1\n#define KEEPALIVE_VER_MIN KEEPALIVE_VER\n\n \nint vchiq_arm_log_level = VCHIQ_LOG_DEFAULT;\nint vchiq_susp_log_level = VCHIQ_LOG_ERROR;\n\nDEFINE_SPINLOCK(msg_queue_spinlock);\nstruct vchiq_state g_state;\n\nstatic struct platform_device *bcm2835_camera;\nstatic struct platform_device *bcm2835_audio;\n\nstruct vchiq_drvdata {\n\tconst unsigned int cache_line_size;\n\tstruct rpi_firmware *fw;\n};\n\nstatic struct vchiq_drvdata bcm2835_drvdata = {\n\t.cache_line_size = 32,\n};\n\nstatic struct vchiq_drvdata bcm2836_drvdata = {\n\t.cache_line_size = 64,\n};\n\nstruct vchiq_arm_state {\n\t \n\tstruct task_struct *ka_thread;\n\tstruct completion ka_evt;\n\tatomic_t ka_use_count;\n\tatomic_t ka_use_ack_count;\n\tatomic_t ka_release_count;\n\n\trwlock_t susp_res_lock;\n\n\tstruct vchiq_state *state;\n\n\t \n\tint videocore_use_count;\n\n\t \n\tint peer_use_count;\n\n\t \n\tint first_connect;\n};\n\nstruct vchiq_2835_state {\n\tint inited;\n\tstruct vchiq_arm_state arm_state;\n};\n\nstruct vchiq_pagelist_info {\n\tstruct pagelist *pagelist;\n\tsize_t pagelist_buffer_size;\n\tdma_addr_t dma_addr;\n\tenum dma_data_direction dma_dir;\n\tunsigned int num_pages;\n\tunsigned int pages_need_release;\n\tstruct page **pages;\n\tstruct scatterlist *scatterlist;\n\tunsigned int scatterlist_mapped;\n};\n\nstatic void __iomem *g_regs;\n \nstatic unsigned int g_cache_line_size = 32;\nstatic unsigned int g_fragments_size;\nstatic char *g_fragments_base;\nstatic char *g_free_fragments;\nstatic struct semaphore g_free_fragments_sema;\n\nstatic DEFINE_SEMAPHORE(g_free_fragments_mutex, 1);\n\nstatic int\nvchiq_blocking_bulk_transfer(struct vchiq_instance *instance, unsigned int handle, void *data,\n\t\t\t     unsigned int size, enum vchiq_bulk_dir dir);\n\nstatic irqreturn_t\nvchiq_doorbell_irq(int irq, void *dev_id)\n{\n\tstruct vchiq_state *state = dev_id;\n\tirqreturn_t ret = IRQ_NONE;\n\tunsigned int status;\n\n\t \n\tstatus = readl(g_regs + BELL0);\n\n\tif (status & ARM_DS_ACTIVE) {   \n\t\tremote_event_pollall(state);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic void\ncleanup_pagelistinfo(struct vchiq_instance *instance, struct vchiq_pagelist_info *pagelistinfo)\n{\n\tif (pagelistinfo->scatterlist_mapped) {\n\t\tdma_unmap_sg(instance->state->dev, pagelistinfo->scatterlist,\n\t\t\t     pagelistinfo->num_pages, pagelistinfo->dma_dir);\n\t}\n\n\tif (pagelistinfo->pages_need_release)\n\t\tunpin_user_pages(pagelistinfo->pages, pagelistinfo->num_pages);\n\n\tdma_free_coherent(instance->state->dev, pagelistinfo->pagelist_buffer_size,\n\t\t\t  pagelistinfo->pagelist, pagelistinfo->dma_addr);\n}\n\nstatic inline bool\nis_adjacent_block(u32 *addrs, u32 addr, unsigned int k)\n{\n\tu32 tmp;\n\n\tif (!k)\n\t\treturn false;\n\n\ttmp = (addrs[k - 1] & PAGE_MASK) +\n\t      (((addrs[k - 1] & ~PAGE_MASK) + 1) << PAGE_SHIFT);\n\n\treturn tmp == (addr & PAGE_MASK);\n}\n\n \n\nstatic struct vchiq_pagelist_info *\ncreate_pagelist(struct vchiq_instance *instance, char *buf, char __user *ubuf,\n\t\tsize_t count, unsigned short type)\n{\n\tstruct pagelist *pagelist;\n\tstruct vchiq_pagelist_info *pagelistinfo;\n\tstruct page **pages;\n\tu32 *addrs;\n\tunsigned int num_pages, offset, i, k;\n\tint actual_pages;\n\tsize_t pagelist_size;\n\tstruct scatterlist *scatterlist, *sg;\n\tint dma_buffers;\n\tdma_addr_t dma_addr;\n\n\tif (count >= INT_MAX - PAGE_SIZE)\n\t\treturn NULL;\n\n\tif (buf)\n\t\toffset = (uintptr_t)buf & (PAGE_SIZE - 1);\n\telse\n\t\toffset = (uintptr_t)ubuf & (PAGE_SIZE - 1);\n\tnum_pages = DIV_ROUND_UP(count + offset, PAGE_SIZE);\n\n\tif ((size_t)num_pages > (SIZE_MAX - sizeof(struct pagelist) -\n\t\t\t sizeof(struct vchiq_pagelist_info)) /\n\t\t\t(sizeof(u32) + sizeof(pages[0]) +\n\t\t\t sizeof(struct scatterlist)))\n\t\treturn NULL;\n\n\tpagelist_size = sizeof(struct pagelist) +\n\t\t\t(num_pages * sizeof(u32)) +\n\t\t\t(num_pages * sizeof(pages[0]) +\n\t\t\t(num_pages * sizeof(struct scatterlist))) +\n\t\t\tsizeof(struct vchiq_pagelist_info);\n\n\t \n\tpagelist = dma_alloc_coherent(instance->state->dev, pagelist_size, &dma_addr,\n\t\t\t\t      GFP_KERNEL);\n\n\tvchiq_log_trace(vchiq_arm_log_level, \"%s - %pK\", __func__, pagelist);\n\n\tif (!pagelist)\n\t\treturn NULL;\n\n\taddrs\t\t= pagelist->addrs;\n\tpages\t\t= (struct page **)(addrs + num_pages);\n\tscatterlist\t= (struct scatterlist *)(pages + num_pages);\n\tpagelistinfo\t= (struct vchiq_pagelist_info *)\n\t\t\t  (scatterlist + num_pages);\n\n\tpagelist->length = count;\n\tpagelist->type = type;\n\tpagelist->offset = offset;\n\n\t \n\tpagelistinfo->pagelist = pagelist;\n\tpagelistinfo->pagelist_buffer_size = pagelist_size;\n\tpagelistinfo->dma_addr = dma_addr;\n\tpagelistinfo->dma_dir =  (type == PAGELIST_WRITE) ?\n\t\t\t\t  DMA_TO_DEVICE : DMA_FROM_DEVICE;\n\tpagelistinfo->num_pages = num_pages;\n\tpagelistinfo->pages_need_release = 0;\n\tpagelistinfo->pages = pages;\n\tpagelistinfo->scatterlist = scatterlist;\n\tpagelistinfo->scatterlist_mapped = 0;\n\n\tif (buf) {\n\t\tunsigned long length = count;\n\t\tunsigned int off = offset;\n\n\t\tfor (actual_pages = 0; actual_pages < num_pages;\n\t\t     actual_pages++) {\n\t\t\tstruct page *pg =\n\t\t\t\tvmalloc_to_page((buf +\n\t\t\t\t\t\t (actual_pages * PAGE_SIZE)));\n\t\t\tsize_t bytes = PAGE_SIZE - off;\n\n\t\t\tif (!pg) {\n\t\t\t\tcleanup_pagelistinfo(instance, pagelistinfo);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif (bytes > length)\n\t\t\t\tbytes = length;\n\t\t\tpages[actual_pages] = pg;\n\t\t\tlength -= bytes;\n\t\t\toff = 0;\n\t\t}\n\t\t \n\t} else {\n\t\tactual_pages = pin_user_pages_fast((unsigned long)ubuf & PAGE_MASK, num_pages,\n\t\t\t\t\t\t   type == PAGELIST_READ, pages);\n\n\t\tif (actual_pages != num_pages) {\n\t\t\tvchiq_log_info(vchiq_arm_log_level,\n\t\t\t\t       \"%s - only %d/%d pages locked\",\n\t\t\t\t       __func__, actual_pages, num_pages);\n\n\t\t\t \n\t\t\tif (actual_pages > 0)\n\t\t\t\tunpin_user_pages(pages, actual_pages);\n\t\t\tcleanup_pagelistinfo(instance, pagelistinfo);\n\t\t\treturn NULL;\n\t\t}\n\t\t  \n\t\tpagelistinfo->pages_need_release = 1;\n\t}\n\n\t \n\tsg_init_table(scatterlist, num_pages);\n\t \n\tfor (i = 0; i < num_pages; i++)\t{\n\t\tunsigned int len = PAGE_SIZE - offset;\n\n\t\tif (len > count)\n\t\t\tlen = count;\n\t\tsg_set_page(scatterlist + i, pages[i], len, offset);\n\t\toffset = 0;\n\t\tcount -= len;\n\t}\n\n\tdma_buffers = dma_map_sg(instance->state->dev,\n\t\t\t\t scatterlist,\n\t\t\t\t num_pages,\n\t\t\t\t pagelistinfo->dma_dir);\n\n\tif (dma_buffers == 0) {\n\t\tcleanup_pagelistinfo(instance, pagelistinfo);\n\t\treturn NULL;\n\t}\n\n\tpagelistinfo->scatterlist_mapped = 1;\n\n\t \n\tk = 0;\n\tfor_each_sg(scatterlist, sg, dma_buffers, i) {\n\t\tu32 len = sg_dma_len(sg);\n\t\tu32 addr = sg_dma_address(sg);\n\n\t\t \n\t\tWARN_ON(len == 0);\n\t\tWARN_ON(i && (i != (dma_buffers - 1)) && (len & ~PAGE_MASK));\n\t\tWARN_ON(i && (addr & ~PAGE_MASK));\n\t\tif (is_adjacent_block(addrs, addr, k))\n\t\t\taddrs[k - 1] += ((len + PAGE_SIZE - 1) >> PAGE_SHIFT);\n\t\telse\n\t\t\taddrs[k++] = (addr & PAGE_MASK) |\n\t\t\t\t(((len + PAGE_SIZE - 1) >> PAGE_SHIFT) - 1);\n\t}\n\n\t \n\tif ((type == PAGELIST_READ) &&\n\t    ((pagelist->offset & (g_cache_line_size - 1)) ||\n\t    ((pagelist->offset + pagelist->length) &\n\t    (g_cache_line_size - 1)))) {\n\t\tchar *fragments;\n\n\t\tif (down_interruptible(&g_free_fragments_sema)) {\n\t\t\tcleanup_pagelistinfo(instance, pagelistinfo);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tWARN_ON(!g_free_fragments);\n\n\t\tdown(&g_free_fragments_mutex);\n\t\tfragments = g_free_fragments;\n\t\tWARN_ON(!fragments);\n\t\tg_free_fragments = *(char **)g_free_fragments;\n\t\tup(&g_free_fragments_mutex);\n\t\tpagelist->type = PAGELIST_READ_WITH_FRAGMENTS +\n\t\t\t(fragments - g_fragments_base) / g_fragments_size;\n\t}\n\n\treturn pagelistinfo;\n}\n\nstatic void\nfree_pagelist(struct vchiq_instance *instance, struct vchiq_pagelist_info *pagelistinfo,\n\t      int actual)\n{\n\tstruct pagelist *pagelist = pagelistinfo->pagelist;\n\tstruct page **pages = pagelistinfo->pages;\n\tunsigned int num_pages = pagelistinfo->num_pages;\n\n\tvchiq_log_trace(vchiq_arm_log_level, \"%s - %pK, %d\",\n\t\t\t__func__, pagelistinfo->pagelist, actual);\n\n\t \n\tdma_unmap_sg(instance->state->dev, pagelistinfo->scatterlist,\n\t\t     pagelistinfo->num_pages, pagelistinfo->dma_dir);\n\tpagelistinfo->scatterlist_mapped = 0;\n\n\t \n\tif (pagelist->type >= PAGELIST_READ_WITH_FRAGMENTS && g_fragments_base) {\n\t\tchar *fragments = g_fragments_base +\n\t\t\t(pagelist->type - PAGELIST_READ_WITH_FRAGMENTS) *\n\t\t\tg_fragments_size;\n\t\tint head_bytes, tail_bytes;\n\n\t\thead_bytes = (g_cache_line_size - pagelist->offset) &\n\t\t\t(g_cache_line_size - 1);\n\t\ttail_bytes = (pagelist->offset + actual) &\n\t\t\t(g_cache_line_size - 1);\n\n\t\tif ((actual >= 0) && (head_bytes != 0)) {\n\t\t\tif (head_bytes > actual)\n\t\t\t\thead_bytes = actual;\n\n\t\t\tmemcpy_to_page(pages[0],\n\t\t\t\tpagelist->offset,\n\t\t\t\tfragments,\n\t\t\t\thead_bytes);\n\t\t}\n\t\tif ((actual >= 0) && (head_bytes < actual) &&\n\t\t    (tail_bytes != 0))\n\t\t\tmemcpy_to_page(pages[num_pages - 1],\n\t\t\t\t(pagelist->offset + actual) &\n\t\t\t\t(PAGE_SIZE - 1) & ~(g_cache_line_size - 1),\n\t\t\t\tfragments + g_cache_line_size,\n\t\t\t\ttail_bytes);\n\n\t\tdown(&g_free_fragments_mutex);\n\t\t*(char **)fragments = g_free_fragments;\n\t\tg_free_fragments = fragments;\n\t\tup(&g_free_fragments_mutex);\n\t\tup(&g_free_fragments_sema);\n\t}\n\n\t \n\tif (pagelist->type != PAGELIST_WRITE &&\n\t    pagelistinfo->pages_need_release) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tset_page_dirty(pages[i]);\n\t}\n\n\tcleanup_pagelistinfo(instance, pagelistinfo);\n}\n\nstatic int vchiq_platform_init(struct platform_device *pdev, struct vchiq_state *state)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct vchiq_drvdata *drvdata = platform_get_drvdata(pdev);\n\tstruct rpi_firmware *fw = drvdata->fw;\n\tstruct vchiq_slot_zero *vchiq_slot_zero;\n\tvoid *slot_mem;\n\tdma_addr_t slot_phys;\n\tu32 channelbase;\n\tint slot_mem_size, frag_mem_size;\n\tint err, irq, i;\n\n\t \n\terr = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\n\tif (err < 0)\n\t\treturn err;\n\n\tg_cache_line_size = drvdata->cache_line_size;\n\tg_fragments_size = 2 * g_cache_line_size;\n\n\t \n\tslot_mem_size = PAGE_ALIGN(TOTAL_SLOTS * VCHIQ_SLOT_SIZE);\n\tfrag_mem_size = PAGE_ALIGN(g_fragments_size * MAX_FRAGMENTS);\n\n\tslot_mem = dmam_alloc_coherent(dev, slot_mem_size + frag_mem_size,\n\t\t\t\t       &slot_phys, GFP_KERNEL);\n\tif (!slot_mem) {\n\t\tdev_err(dev, \"could not allocate DMA memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tWARN_ON(((unsigned long)slot_mem & (PAGE_SIZE - 1)) != 0);\n\n\tvchiq_slot_zero = vchiq_init_slots(slot_mem, slot_mem_size);\n\tif (!vchiq_slot_zero)\n\t\treturn -ENOMEM;\n\n\tvchiq_slot_zero->platform_data[VCHIQ_PLATFORM_FRAGMENTS_OFFSET_IDX] =\n\t\t(int)slot_phys + slot_mem_size;\n\tvchiq_slot_zero->platform_data[VCHIQ_PLATFORM_FRAGMENTS_COUNT_IDX] =\n\t\tMAX_FRAGMENTS;\n\n\tg_fragments_base = (char *)slot_mem + slot_mem_size;\n\n\tg_free_fragments = g_fragments_base;\n\tfor (i = 0; i < (MAX_FRAGMENTS - 1); i++) {\n\t\t*(char **)&g_fragments_base[i * g_fragments_size] =\n\t\t\t&g_fragments_base[(i + 1) * g_fragments_size];\n\t}\n\t*(char **)&g_fragments_base[i * g_fragments_size] = NULL;\n\tsema_init(&g_free_fragments_sema, MAX_FRAGMENTS);\n\n\terr = vchiq_init_state(state, vchiq_slot_zero, dev);\n\tif (err)\n\t\treturn err;\n\n\tg_regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(g_regs))\n\t\treturn PTR_ERR(g_regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq <= 0)\n\t\treturn irq;\n\n\terr = devm_request_irq(dev, irq, vchiq_doorbell_irq, IRQF_IRQPOLL,\n\t\t\t       \"VCHIQ doorbell\", state);\n\tif (err) {\n\t\tdev_err(dev, \"failed to register irq=%d\\n\", irq);\n\t\treturn err;\n\t}\n\n\t \n\tchannelbase = slot_phys;\n\terr = rpi_firmware_property(fw, RPI_FIRMWARE_VCHIQ_INIT,\n\t\t\t\t    &channelbase, sizeof(channelbase));\n\tif (err) {\n\t\tdev_err(dev, \"failed to send firmware property: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (channelbase) {\n\t\tdev_err(dev, \"failed to set channelbase (response: %x)\\n\",\n\t\t\tchannelbase);\n\t\treturn -ENXIO;\n\t}\n\n\tvchiq_log_info(vchiq_arm_log_level, \"vchiq_init - done (slots %pK, phys %pad)\",\n\t\t       vchiq_slot_zero, &slot_phys);\n\n\tvchiq_call_connected_callbacks();\n\n\treturn 0;\n}\n\nstatic void\nvchiq_arm_init_state(struct vchiq_state *state,\n\t\t     struct vchiq_arm_state *arm_state)\n{\n\tif (arm_state) {\n\t\trwlock_init(&arm_state->susp_res_lock);\n\n\t\tinit_completion(&arm_state->ka_evt);\n\t\tatomic_set(&arm_state->ka_use_count, 0);\n\t\tatomic_set(&arm_state->ka_use_ack_count, 0);\n\t\tatomic_set(&arm_state->ka_release_count, 0);\n\n\t\tarm_state->state = state;\n\t\tarm_state->first_connect = 0;\n\t}\n}\n\nint\nvchiq_platform_init_state(struct vchiq_state *state)\n{\n\tstruct vchiq_2835_state *platform_state;\n\n\tstate->platform_state = kzalloc(sizeof(*platform_state), GFP_KERNEL);\n\tif (!state->platform_state)\n\t\treturn -ENOMEM;\n\n\tplatform_state = (struct vchiq_2835_state *)state->platform_state;\n\n\tplatform_state->inited = 1;\n\tvchiq_arm_init_state(state, &platform_state->arm_state);\n\n\treturn 0;\n}\n\nstatic struct vchiq_arm_state *vchiq_platform_get_arm_state(struct vchiq_state *state)\n{\n\tstruct vchiq_2835_state *platform_state;\n\n\tplatform_state   = (struct vchiq_2835_state *)state->platform_state;\n\n\tWARN_ON_ONCE(!platform_state->inited);\n\n\treturn &platform_state->arm_state;\n}\n\nvoid\nremote_event_signal(struct remote_event *event)\n{\n\t \n\twmb();\n\n\tevent->fired = 1;\n\n\tdsb(sy);          \n\n\tif (event->armed)\n\t\twritel(0, g_regs + BELL2);  \n}\n\nint\nvchiq_prepare_bulk_data(struct vchiq_instance *instance, struct vchiq_bulk *bulk, void *offset,\n\t\t\tvoid __user *uoffset, int size, int dir)\n{\n\tstruct vchiq_pagelist_info *pagelistinfo;\n\n\tpagelistinfo = create_pagelist(instance, offset, uoffset, size,\n\t\t\t\t       (dir == VCHIQ_BULK_RECEIVE)\n\t\t\t\t       ? PAGELIST_READ\n\t\t\t\t       : PAGELIST_WRITE);\n\n\tif (!pagelistinfo)\n\t\treturn -ENOMEM;\n\n\tbulk->data = pagelistinfo->dma_addr;\n\n\t \n\tbulk->remote_data = pagelistinfo;\n\n\treturn 0;\n}\n\nvoid\nvchiq_complete_bulk(struct vchiq_instance *instance, struct vchiq_bulk *bulk)\n{\n\tif (bulk && bulk->remote_data && bulk->actual)\n\t\tfree_pagelist(instance, (struct vchiq_pagelist_info *)bulk->remote_data,\n\t\t\t      bulk->actual);\n}\n\nint vchiq_dump_platform_state(void *dump_context)\n{\n\tchar buf[80];\n\tint len;\n\n\tlen = snprintf(buf, sizeof(buf), \"  Platform: 2835 (VC master)\");\n\treturn vchiq_dump(dump_context, buf, len + 1);\n}\n\n#define VCHIQ_INIT_RETRIES 10\nint vchiq_initialise(struct vchiq_instance **instance_out)\n{\n\tstruct vchiq_state *state;\n\tstruct vchiq_instance *instance = NULL;\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < VCHIQ_INIT_RETRIES; i++) {\n\t\tstate = vchiq_get_state();\n\t\tif (state)\n\t\t\tbreak;\n\t\tusleep_range(500, 600);\n\t}\n\tif (i == VCHIQ_INIT_RETRIES) {\n\t\tvchiq_log_error(vchiq_core_log_level, \"%s: videocore not initialized\\n\", __func__);\n\t\tret = -ENOTCONN;\n\t\tgoto failed;\n\t} else if (i > 0) {\n\t\tvchiq_log_warning(vchiq_core_log_level,\n\t\t\t\t  \"%s: videocore initialized after %d retries\\n\", __func__, i);\n\t}\n\n\tinstance = kzalloc(sizeof(*instance), GFP_KERNEL);\n\tif (!instance) {\n\t\tvchiq_log_error(vchiq_core_log_level,\n\t\t\t\t\"%s: error allocating vchiq instance\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tinstance->connected = 0;\n\tinstance->state = state;\n\tmutex_init(&instance->bulk_waiter_list_mutex);\n\tINIT_LIST_HEAD(&instance->bulk_waiter_list);\n\n\t*instance_out = instance;\n\n\tret = 0;\n\nfailed:\n\tvchiq_log_trace(vchiq_core_log_level, \"%s(%p): returning %d\", __func__, instance, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(vchiq_initialise);\n\nvoid free_bulk_waiter(struct vchiq_instance *instance)\n{\n\tstruct bulk_waiter_node *waiter, *next;\n\n\tlist_for_each_entry_safe(waiter, next,\n\t\t\t\t &instance->bulk_waiter_list, list) {\n\t\tlist_del(&waiter->list);\n\t\tvchiq_log_info(vchiq_arm_log_level, \"bulk_waiter - cleaned up %pK for pid %d\",\n\t\t\t       waiter, waiter->pid);\n\t\tkfree(waiter);\n\t}\n}\n\nint vchiq_shutdown(struct vchiq_instance *instance)\n{\n\tint status = 0;\n\tstruct vchiq_state *state = instance->state;\n\n\tif (mutex_lock_killable(&state->mutex))\n\t\treturn -EAGAIN;\n\n\t \n\tvchiq_shutdown_internal(state, instance);\n\n\tmutex_unlock(&state->mutex);\n\n\tvchiq_log_trace(vchiq_core_log_level, \"%s(%p): returning %d\", __func__, instance, status);\n\n\tfree_bulk_waiter(instance);\n\tkfree(instance);\n\n\treturn status;\n}\nEXPORT_SYMBOL(vchiq_shutdown);\n\nstatic int vchiq_is_connected(struct vchiq_instance *instance)\n{\n\treturn instance->connected;\n}\n\nint vchiq_connect(struct vchiq_instance *instance)\n{\n\tint status;\n\tstruct vchiq_state *state = instance->state;\n\n\tif (mutex_lock_killable(&state->mutex)) {\n\t\tvchiq_log_trace(vchiq_core_log_level, \"%s: call to mutex_lock failed\", __func__);\n\t\tstatus = -EAGAIN;\n\t\tgoto failed;\n\t}\n\tstatus = vchiq_connect_internal(state, instance);\n\n\tif (!status)\n\t\tinstance->connected = 1;\n\n\tmutex_unlock(&state->mutex);\n\nfailed:\n\tvchiq_log_trace(vchiq_core_log_level, \"%s(%p): returning %d\", __func__, instance, status);\n\n\treturn status;\n}\nEXPORT_SYMBOL(vchiq_connect);\n\nstatic int\nvchiq_add_service(struct vchiq_instance *instance,\n\t\t  const struct vchiq_service_params_kernel *params,\n\t\t  unsigned int *phandle)\n{\n\tint status;\n\tstruct vchiq_state *state = instance->state;\n\tstruct vchiq_service *service = NULL;\n\tint srvstate;\n\n\t*phandle = VCHIQ_SERVICE_HANDLE_INVALID;\n\n\tsrvstate = vchiq_is_connected(instance)\n\t\t? VCHIQ_SRVSTATE_LISTENING\n\t\t: VCHIQ_SRVSTATE_HIDDEN;\n\n\tservice = vchiq_add_service_internal(state, params, srvstate, instance, NULL);\n\n\tif (service) {\n\t\t*phandle = service->handle;\n\t\tstatus = 0;\n\t} else {\n\t\tstatus = -EINVAL;\n\t}\n\n\tvchiq_log_trace(vchiq_core_log_level, \"%s(%p): returning %d\", __func__, instance, status);\n\n\treturn status;\n}\n\nint\nvchiq_open_service(struct vchiq_instance *instance,\n\t\t   const struct vchiq_service_params_kernel *params,\n\t\t   unsigned int *phandle)\n{\n\tint status = -EINVAL;\n\tstruct vchiq_state   *state = instance->state;\n\tstruct vchiq_service *service = NULL;\n\n\t*phandle = VCHIQ_SERVICE_HANDLE_INVALID;\n\n\tif (!vchiq_is_connected(instance))\n\t\tgoto failed;\n\n\tservice = vchiq_add_service_internal(state, params, VCHIQ_SRVSTATE_OPENING, instance, NULL);\n\n\tif (service) {\n\t\t*phandle = service->handle;\n\t\tstatus = vchiq_open_service_internal(service, current->pid);\n\t\tif (status) {\n\t\t\tvchiq_remove_service(instance, service->handle);\n\t\t\t*phandle = VCHIQ_SERVICE_HANDLE_INVALID;\n\t\t}\n\t}\n\nfailed:\n\tvchiq_log_trace(vchiq_core_log_level, \"%s(%p): returning %d\", __func__, instance, status);\n\n\treturn status;\n}\nEXPORT_SYMBOL(vchiq_open_service);\n\nint\nvchiq_bulk_transmit(struct vchiq_instance *instance, unsigned int handle, const void *data,\n\t\t    unsigned int size, void *userdata, enum vchiq_bulk_mode mode)\n{\n\tint status;\n\n\twhile (1) {\n\t\tswitch (mode) {\n\t\tcase VCHIQ_BULK_MODE_NOCALLBACK:\n\t\tcase VCHIQ_BULK_MODE_CALLBACK:\n\t\t\tstatus = vchiq_bulk_transfer(instance, handle,\n\t\t\t\t\t\t     (void *)data, NULL,\n\t\t\t\t\t\t     size, userdata, mode,\n\t\t\t\t\t\t     VCHIQ_BULK_TRANSMIT);\n\t\t\tbreak;\n\t\tcase VCHIQ_BULK_MODE_BLOCKING:\n\t\t\tstatus = vchiq_blocking_bulk_transfer(instance, handle, (void *)data, size,\n\t\t\t\t\t\t\t      VCHIQ_BULK_TRANSMIT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (status != -EAGAIN)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t}\n\n\treturn status;\n}\nEXPORT_SYMBOL(vchiq_bulk_transmit);\n\nint vchiq_bulk_receive(struct vchiq_instance *instance, unsigned int handle,\n\t\t       void *data, unsigned int size, void *userdata,\n\t\t       enum vchiq_bulk_mode mode)\n{\n\tint status;\n\n\twhile (1) {\n\t\tswitch (mode) {\n\t\tcase VCHIQ_BULK_MODE_NOCALLBACK:\n\t\tcase VCHIQ_BULK_MODE_CALLBACK:\n\t\t\tstatus = vchiq_bulk_transfer(instance, handle, data, NULL,\n\t\t\t\t\t\t     size, userdata,\n\t\t\t\t\t\t     mode, VCHIQ_BULK_RECEIVE);\n\t\t\tbreak;\n\t\tcase VCHIQ_BULK_MODE_BLOCKING:\n\t\t\tstatus = vchiq_blocking_bulk_transfer(instance, handle, (void *)data, size,\n\t\t\t\t\t\t\t      VCHIQ_BULK_RECEIVE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (status != -EAGAIN)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t}\n\n\treturn status;\n}\nEXPORT_SYMBOL(vchiq_bulk_receive);\n\nstatic int\nvchiq_blocking_bulk_transfer(struct vchiq_instance *instance, unsigned int handle, void *data,\n\t\t\t     unsigned int size, enum vchiq_bulk_dir dir)\n{\n\tstruct vchiq_service *service;\n\tint status;\n\tstruct bulk_waiter_node *waiter = NULL, *iter;\n\n\tservice = find_service_by_handle(instance, handle);\n\tif (!service)\n\t\treturn -EINVAL;\n\n\tvchiq_service_put(service);\n\n\tmutex_lock(&instance->bulk_waiter_list_mutex);\n\tlist_for_each_entry(iter, &instance->bulk_waiter_list, list) {\n\t\tif (iter->pid == current->pid) {\n\t\t\tlist_del(&iter->list);\n\t\t\twaiter = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&instance->bulk_waiter_list_mutex);\n\n\tif (waiter) {\n\t\tstruct vchiq_bulk *bulk = waiter->bulk_waiter.bulk;\n\n\t\tif (bulk) {\n\t\t\t \n\t\t\t \n\t\t\tif ((bulk->data != (dma_addr_t)(uintptr_t)data) || (bulk->size != size)) {\n\t\t\t\t \n\t\t\t\tspin_lock(&bulk_waiter_spinlock);\n\t\t\t\tbulk->userdata = NULL;\n\t\t\t\tspin_unlock(&bulk_waiter_spinlock);\n\t\t\t}\n\t\t}\n\t} else {\n\t\twaiter = kzalloc(sizeof(*waiter), GFP_KERNEL);\n\t\tif (!waiter) {\n\t\t\tvchiq_log_error(vchiq_core_log_level, \"%s - out of memory\", __func__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tstatus = vchiq_bulk_transfer(instance, handle, data, NULL, size,\n\t\t\t\t     &waiter->bulk_waiter,\n\t\t\t\t     VCHIQ_BULK_MODE_BLOCKING, dir);\n\tif ((status != -EAGAIN) || fatal_signal_pending(current) || !waiter->bulk_waiter.bulk) {\n\t\tstruct vchiq_bulk *bulk = waiter->bulk_waiter.bulk;\n\n\t\tif (bulk) {\n\t\t\t \n\t\t\tspin_lock(&bulk_waiter_spinlock);\n\t\t\tbulk->userdata = NULL;\n\t\t\tspin_unlock(&bulk_waiter_spinlock);\n\t\t}\n\t\tkfree(waiter);\n\t} else {\n\t\twaiter->pid = current->pid;\n\t\tmutex_lock(&instance->bulk_waiter_list_mutex);\n\t\tlist_add(&waiter->list, &instance->bulk_waiter_list);\n\t\tmutex_unlock(&instance->bulk_waiter_list_mutex);\n\t\tvchiq_log_info(vchiq_arm_log_level, \"saved bulk_waiter %pK for pid %d\", waiter,\n\t\t\t       current->pid);\n\t}\n\n\treturn status;\n}\n\nstatic int\nadd_completion(struct vchiq_instance *instance, enum vchiq_reason reason,\n\t       struct vchiq_header *header, struct user_service *user_service,\n\t       void *bulk_userdata)\n{\n\tstruct vchiq_completion_data_kernel *completion;\n\tint insert;\n\n\tDEBUG_INITIALISE(g_state.local);\n\n\tinsert = instance->completion_insert;\n\twhile ((insert - instance->completion_remove) >= MAX_COMPLETIONS) {\n\t\t \n\t\tDEBUG_TRACE(SERVICE_CALLBACK_LINE);\n\t\tvchiq_log_trace(vchiq_arm_log_level, \"%s - completion queue full\", __func__);\n\t\tDEBUG_COUNT(COMPLETION_QUEUE_FULL_COUNT);\n\t\tif (wait_for_completion_interruptible(&instance->remove_event)) {\n\t\t\tvchiq_log_info(vchiq_arm_log_level, \"service_callback interrupted\");\n\t\t\treturn -EAGAIN;\n\t\t} else if (instance->closing) {\n\t\t\tvchiq_log_info(vchiq_arm_log_level, \"service_callback closing\");\n\t\t\treturn 0;\n\t\t}\n\t\tDEBUG_TRACE(SERVICE_CALLBACK_LINE);\n\t}\n\n\tcompletion = &instance->completions[insert & (MAX_COMPLETIONS - 1)];\n\n\tcompletion->header = header;\n\tcompletion->reason = reason;\n\t \n\tcompletion->service_userdata = user_service->service;\n\tcompletion->bulk_userdata = bulk_userdata;\n\n\tif (reason == VCHIQ_SERVICE_CLOSED) {\n\t\t \n\t\tvchiq_service_get(user_service->service);\n\t\tif (instance->use_close_delivered)\n\t\t\tuser_service->close_pending = 1;\n\t}\n\n\t \n\twmb();\n\n\tif (reason == VCHIQ_MESSAGE_AVAILABLE)\n\t\tuser_service->message_available_pos = insert;\n\n\tinsert++;\n\tinstance->completion_insert = insert;\n\n\tcomplete(&instance->insert_event);\n\n\treturn 0;\n}\n\nint\nservice_callback(struct vchiq_instance *instance, enum vchiq_reason reason,\n\t\t struct vchiq_header *header, unsigned int handle, void *bulk_userdata)\n{\n\t \n\tstruct user_service *user_service;\n\tstruct vchiq_service *service;\n\tbool skip_completion = false;\n\n\tDEBUG_INITIALISE(g_state.local);\n\n\tDEBUG_TRACE(SERVICE_CALLBACK_LINE);\n\n\trcu_read_lock();\n\tservice = handle_to_service(instance, handle);\n\tif (WARN_ON(!service)) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tuser_service = (struct user_service *)service->base.userdata;\n\n\tif (!instance || instance->closing) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\t \n\tvchiq_service_get(service);\n\trcu_read_unlock();\n\n\tvchiq_log_trace(vchiq_arm_log_level,\n\t\t\t\"%s - service %lx(%d,%p), reason %d, header %lx, instance %lx, bulk_userdata %lx\",\n\t\t\t__func__, (unsigned long)user_service, service->localport,\n\t\t\tuser_service->userdata, reason, (unsigned long)header,\n\t\t\t(unsigned long)instance, (unsigned long)bulk_userdata);\n\n\tif (header && user_service->is_vchi) {\n\t\tspin_lock(&msg_queue_spinlock);\n\t\twhile (user_service->msg_insert ==\n\t\t\t(user_service->msg_remove + MSG_QUEUE_SIZE)) {\n\t\t\tspin_unlock(&msg_queue_spinlock);\n\t\t\tDEBUG_TRACE(SERVICE_CALLBACK_LINE);\n\t\t\tDEBUG_COUNT(MSG_QUEUE_FULL_COUNT);\n\t\t\tvchiq_log_trace(vchiq_arm_log_level, \"%s - msg queue full\", __func__);\n\t\t\t \n\t\t\tif ((user_service->message_available_pos -\n\t\t\t\tinstance->completion_remove) < 0) {\n\t\t\t\tint status;\n\n\t\t\t\tvchiq_log_info(vchiq_arm_log_level,\n\t\t\t\t\t       \"Inserting extra MESSAGE_AVAILABLE\");\n\t\t\t\tDEBUG_TRACE(SERVICE_CALLBACK_LINE);\n\t\t\t\tstatus = add_completion(instance, reason, NULL, user_service,\n\t\t\t\t\t\t\tbulk_userdata);\n\t\t\t\tif (status) {\n\t\t\t\t\tDEBUG_TRACE(SERVICE_CALLBACK_LINE);\n\t\t\t\t\tvchiq_service_put(service);\n\t\t\t\t\treturn status;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDEBUG_TRACE(SERVICE_CALLBACK_LINE);\n\t\t\tif (wait_for_completion_interruptible(&user_service->remove_event)) {\n\t\t\t\tvchiq_log_info(vchiq_arm_log_level, \"%s interrupted\", __func__);\n\t\t\t\tDEBUG_TRACE(SERVICE_CALLBACK_LINE);\n\t\t\t\tvchiq_service_put(service);\n\t\t\t\treturn -EAGAIN;\n\t\t\t} else if (instance->closing) {\n\t\t\t\tvchiq_log_info(vchiq_arm_log_level, \"%s closing\", __func__);\n\t\t\t\tDEBUG_TRACE(SERVICE_CALLBACK_LINE);\n\t\t\t\tvchiq_service_put(service);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tDEBUG_TRACE(SERVICE_CALLBACK_LINE);\n\t\t\tspin_lock(&msg_queue_spinlock);\n\t\t}\n\n\t\tuser_service->msg_queue[user_service->msg_insert &\n\t\t\t(MSG_QUEUE_SIZE - 1)] = header;\n\t\tuser_service->msg_insert++;\n\n\t\t \n\t\tif (((user_service->message_available_pos -\n\t\t\tinstance->completion_remove) >= 0) ||\n\t\t\tuser_service->dequeue_pending) {\n\t\t\tuser_service->dequeue_pending = 0;\n\t\t\tskip_completion = true;\n\t\t}\n\n\t\tspin_unlock(&msg_queue_spinlock);\n\t\tcomplete(&user_service->insert_event);\n\n\t\theader = NULL;\n\t}\n\tDEBUG_TRACE(SERVICE_CALLBACK_LINE);\n\tvchiq_service_put(service);\n\n\tif (skip_completion)\n\t\treturn 0;\n\n\treturn add_completion(instance, reason, header, user_service,\n\t\tbulk_userdata);\n}\n\nint vchiq_dump(void *dump_context, const char *str, int len)\n{\n\tstruct dump_context *context = (struct dump_context *)dump_context;\n\tint copy_bytes;\n\n\tif (context->actual >= context->space)\n\t\treturn 0;\n\n\tif (context->offset > 0) {\n\t\tint skip_bytes = min_t(int, len, context->offset);\n\n\t\tstr += skip_bytes;\n\t\tlen -= skip_bytes;\n\t\tcontext->offset -= skip_bytes;\n\t\tif (context->offset > 0)\n\t\t\treturn 0;\n\t}\n\tcopy_bytes = min_t(int, len, context->space - context->actual);\n\tif (copy_bytes == 0)\n\t\treturn 0;\n\tif (copy_to_user(context->buf + context->actual, str,\n\t\t\t copy_bytes))\n\t\treturn -EFAULT;\n\tcontext->actual += copy_bytes;\n\tlen -= copy_bytes;\n\n\t \n\tif ((len == 0) && (str[copy_bytes - 1] == '\\0')) {\n\t\tchar cr = '\\n';\n\n\t\tif (copy_to_user(context->buf + context->actual - 1,\n\t\t\t\t &cr, 1))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nint vchiq_dump_platform_instances(void *dump_context)\n{\n\tstruct vchiq_state *state = vchiq_get_state();\n\tchar buf[80];\n\tint len;\n\tint i;\n\n\tif (!state)\n\t\treturn -ENOTCONN;\n\n\t \n\n\trcu_read_lock();\n\tfor (i = 0; i < state->unused_service; i++) {\n\t\tstruct vchiq_service *service;\n\t\tstruct vchiq_instance *instance;\n\n\t\tservice = rcu_dereference(state->services[i]);\n\t\tif (!service || service->base.callback != service_callback)\n\t\t\tcontinue;\n\n\t\tinstance = service->instance;\n\t\tif (instance)\n\t\t\tinstance->mark = 0;\n\t}\n\trcu_read_unlock();\n\n\tfor (i = 0; i < state->unused_service; i++) {\n\t\tstruct vchiq_service *service;\n\t\tstruct vchiq_instance *instance;\n\t\tint err;\n\n\t\trcu_read_lock();\n\t\tservice = rcu_dereference(state->services[i]);\n\t\tif (!service || service->base.callback != service_callback) {\n\t\t\trcu_read_unlock();\n\t\t\tcontinue;\n\t\t}\n\n\t\tinstance = service->instance;\n\t\tif (!instance || instance->mark) {\n\t\t\trcu_read_unlock();\n\t\t\tcontinue;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tlen = snprintf(buf, sizeof(buf),\n\t\t\t       \"Instance %pK: pid %d,%s completions %d/%d\",\n\t\t\t       instance, instance->pid,\n\t\t\t       instance->connected ? \" connected, \" :\n\t\t\t       \"\",\n\t\t\t       instance->completion_insert -\n\t\t\t       instance->completion_remove,\n\t\t\t       MAX_COMPLETIONS);\n\t\terr = vchiq_dump(dump_context, buf, len + 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tinstance->mark = 1;\n\t}\n\treturn 0;\n}\n\nint vchiq_dump_platform_service_state(void *dump_context,\n\t\t\t\t      struct vchiq_service *service)\n{\n\tstruct user_service *user_service =\n\t\t\t(struct user_service *)service->base.userdata;\n\tchar buf[80];\n\tint len;\n\n\tlen = scnprintf(buf, sizeof(buf), \"  instance %pK\", service->instance);\n\n\tif ((service->base.callback == service_callback) && user_service->is_vchi) {\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \", %d/%d messages\",\n\t\t\t\t user_service->msg_insert - user_service->msg_remove,\n\t\t\t\t MSG_QUEUE_SIZE);\n\n\t\tif (user_service->dequeue_pending)\n\t\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\t\" (dequeue pending)\");\n\t}\n\n\treturn vchiq_dump(dump_context, buf, len + 1);\n}\n\nstruct vchiq_state *\nvchiq_get_state(void)\n{\n\tif (!g_state.remote) {\n\t\tpr_err(\"%s: g_state.remote == NULL\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (g_state.remote->initialised != 1) {\n\t\tpr_notice(\"%s: g_state.remote->initialised != 1 (%d)\\n\",\n\t\t\t  __func__, g_state.remote->initialised);\n\t\treturn NULL;\n\t}\n\n\treturn &g_state;\n}\n\n \n\nstatic int\nvchiq_keepalive_vchiq_callback(struct vchiq_instance *instance,\n\t\t\t       enum vchiq_reason reason,\n\t\t\t       struct vchiq_header *header,\n\t\t\t       unsigned int service_user, void *bulk_user)\n{\n\tvchiq_log_error(vchiq_susp_log_level, \"%s callback reason %d\", __func__, reason);\n\treturn 0;\n}\n\nstatic int\nvchiq_keepalive_thread_func(void *v)\n{\n\tstruct vchiq_state *state = (struct vchiq_state *)v;\n\tstruct vchiq_arm_state *arm_state = vchiq_platform_get_arm_state(state);\n\n\tint status;\n\tstruct vchiq_instance *instance;\n\tunsigned int ka_handle;\n\tint ret;\n\n\tstruct vchiq_service_params_kernel params = {\n\t\t.fourcc      = VCHIQ_MAKE_FOURCC('K', 'E', 'E', 'P'),\n\t\t.callback    = vchiq_keepalive_vchiq_callback,\n\t\t.version     = KEEPALIVE_VER,\n\t\t.version_min = KEEPALIVE_VER_MIN\n\t};\n\n\tret = vchiq_initialise(&instance);\n\tif (ret) {\n\t\tvchiq_log_error(vchiq_susp_log_level, \"%s vchiq_initialise failed %d\", __func__,\n\t\t\t\tret);\n\t\tgoto exit;\n\t}\n\n\tstatus = vchiq_connect(instance);\n\tif (status) {\n\t\tvchiq_log_error(vchiq_susp_log_level, \"%s vchiq_connect failed %d\", __func__,\n\t\t\t\tstatus);\n\t\tgoto shutdown;\n\t}\n\n\tstatus = vchiq_add_service(instance, &params, &ka_handle);\n\tif (status) {\n\t\tvchiq_log_error(vchiq_susp_log_level, \"%s vchiq_open_service failed %d\", __func__,\n\t\t\t\tstatus);\n\t\tgoto shutdown;\n\t}\n\n\twhile (1) {\n\t\tlong rc = 0, uc = 0;\n\n\t\tif (wait_for_completion_interruptible(&arm_state->ka_evt)) {\n\t\t\tvchiq_log_error(vchiq_susp_log_level, \"%s interrupted\", __func__);\n\t\t\tflush_signals(current);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\trc = atomic_xchg(&arm_state->ka_release_count, 0);\n\t\tuc = atomic_xchg(&arm_state->ka_use_count, 0);\n\n\t\t \n\t\twhile (uc--) {\n\t\t\tatomic_inc(&arm_state->ka_use_ack_count);\n\t\t\tstatus = vchiq_use_service(instance, ka_handle);\n\t\t\tif (status) {\n\t\t\t\tvchiq_log_error(vchiq_susp_log_level,\n\t\t\t\t\t\t\"%s vchiq_use_service error %d\", __func__, status);\n\t\t\t}\n\t\t}\n\t\twhile (rc--) {\n\t\t\tstatus = vchiq_release_service(instance, ka_handle);\n\t\t\tif (status) {\n\t\t\t\tvchiq_log_error(vchiq_susp_log_level,\n\t\t\t\t\t\t\"%s vchiq_release_service error %d\", __func__,\n\t\t\t\t\t\tstatus);\n\t\t\t}\n\t\t}\n\t}\n\nshutdown:\n\tvchiq_shutdown(instance);\nexit:\n\treturn 0;\n}\n\nint\nvchiq_use_internal(struct vchiq_state *state, struct vchiq_service *service,\n\t\t   enum USE_TYPE_E use_type)\n{\n\tstruct vchiq_arm_state *arm_state = vchiq_platform_get_arm_state(state);\n\tint ret = 0;\n\tchar entity[16];\n\tint *entity_uc;\n\tint local_uc;\n\n\tif (!arm_state) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (use_type == USE_TYPE_VCHIQ) {\n\t\tsprintf(entity, \"VCHIQ:   \");\n\t\tentity_uc = &arm_state->peer_use_count;\n\t} else if (service) {\n\t\tsprintf(entity, \"%c%c%c%c:%03d\",\n\t\t\tVCHIQ_FOURCC_AS_4CHARS(service->base.fourcc),\n\t\t\tservice->client_id);\n\t\tentity_uc = &service->service_use_count;\n\t} else {\n\t\tvchiq_log_error(vchiq_susp_log_level, \"%s null service ptr\", __func__);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\twrite_lock_bh(&arm_state->susp_res_lock);\n\tlocal_uc = ++arm_state->videocore_use_count;\n\t++(*entity_uc);\n\n\tvchiq_log_trace(vchiq_susp_log_level, \"%s %s count %d, state count %d\", __func__, entity,\n\t\t\t*entity_uc, local_uc);\n\n\twrite_unlock_bh(&arm_state->susp_res_lock);\n\n\tif (!ret) {\n\t\tint status = 0;\n\t\tlong ack_cnt = atomic_xchg(&arm_state->ka_use_ack_count, 0);\n\n\t\twhile (ack_cnt && !status) {\n\t\t\t \n\t\t\tstatus = vchiq_send_remote_use_active(state);\n\t\t\tif (!status)\n\t\t\t\tack_cnt--;\n\t\t\telse\n\t\t\t\tatomic_add(ack_cnt, &arm_state->ka_use_ack_count);\n\t\t}\n\t}\n\nout:\n\tvchiq_log_trace(vchiq_susp_log_level, \"%s exit %d\", __func__, ret);\n\treturn ret;\n}\n\nint\nvchiq_release_internal(struct vchiq_state *state, struct vchiq_service *service)\n{\n\tstruct vchiq_arm_state *arm_state = vchiq_platform_get_arm_state(state);\n\tint ret = 0;\n\tchar entity[16];\n\tint *entity_uc;\n\n\tif (!arm_state) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (service) {\n\t\tsprintf(entity, \"%c%c%c%c:%03d\",\n\t\t\tVCHIQ_FOURCC_AS_4CHARS(service->base.fourcc),\n\t\t\tservice->client_id);\n\t\tentity_uc = &service->service_use_count;\n\t} else {\n\t\tsprintf(entity, \"PEER:   \");\n\t\tentity_uc = &arm_state->peer_use_count;\n\t}\n\n\twrite_lock_bh(&arm_state->susp_res_lock);\n\tif (!arm_state->videocore_use_count || !(*entity_uc)) {\n\t\t \n\t\tWARN_ON(!arm_state->videocore_use_count);\n\t\tWARN_ON(!(*entity_uc));\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\t--arm_state->videocore_use_count;\n\t--(*entity_uc);\n\n\tvchiq_log_trace(vchiq_susp_log_level, \"%s %s count %d, state count %d\", __func__, entity,\n\t\t\t*entity_uc, arm_state->videocore_use_count);\n\nunlock:\n\twrite_unlock_bh(&arm_state->susp_res_lock);\n\nout:\n\tvchiq_log_trace(vchiq_susp_log_level, \"%s exit %d\", __func__, ret);\n\treturn ret;\n}\n\nvoid\nvchiq_on_remote_use(struct vchiq_state *state)\n{\n\tstruct vchiq_arm_state *arm_state = vchiq_platform_get_arm_state(state);\n\n\tatomic_inc(&arm_state->ka_use_count);\n\tcomplete(&arm_state->ka_evt);\n}\n\nvoid\nvchiq_on_remote_release(struct vchiq_state *state)\n{\n\tstruct vchiq_arm_state *arm_state = vchiq_platform_get_arm_state(state);\n\n\tatomic_inc(&arm_state->ka_release_count);\n\tcomplete(&arm_state->ka_evt);\n}\n\nint\nvchiq_use_service_internal(struct vchiq_service *service)\n{\n\treturn vchiq_use_internal(service->state, service, USE_TYPE_SERVICE);\n}\n\nint\nvchiq_release_service_internal(struct vchiq_service *service)\n{\n\treturn vchiq_release_internal(service->state, service);\n}\n\nstruct vchiq_debugfs_node *\nvchiq_instance_get_debugfs_node(struct vchiq_instance *instance)\n{\n\treturn &instance->debugfs_node;\n}\n\nint\nvchiq_instance_get_use_count(struct vchiq_instance *instance)\n{\n\tstruct vchiq_service *service;\n\tint use_count = 0, i;\n\n\ti = 0;\n\trcu_read_lock();\n\twhile ((service = __next_service_by_instance(instance->state,\n\t\t\t\t\t\t     instance, &i)))\n\t\tuse_count += service->service_use_count;\n\trcu_read_unlock();\n\treturn use_count;\n}\n\nint\nvchiq_instance_get_pid(struct vchiq_instance *instance)\n{\n\treturn instance->pid;\n}\n\nint\nvchiq_instance_get_trace(struct vchiq_instance *instance)\n{\n\treturn instance->trace;\n}\n\nvoid\nvchiq_instance_set_trace(struct vchiq_instance *instance, int trace)\n{\n\tstruct vchiq_service *service;\n\tint i;\n\n\ti = 0;\n\trcu_read_lock();\n\twhile ((service = __next_service_by_instance(instance->state,\n\t\t\t\t\t\t     instance, &i)))\n\t\tservice->trace = trace;\n\trcu_read_unlock();\n\tinstance->trace = (trace != 0);\n}\n\nint\nvchiq_use_service(struct vchiq_instance *instance, unsigned int handle)\n{\n\tint ret = -EINVAL;\n\tstruct vchiq_service *service = find_service_by_handle(instance, handle);\n\n\tif (service) {\n\t\tret = vchiq_use_internal(service->state, service, USE_TYPE_SERVICE);\n\t\tvchiq_service_put(service);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(vchiq_use_service);\n\nint\nvchiq_release_service(struct vchiq_instance *instance, unsigned int handle)\n{\n\tint ret = -EINVAL;\n\tstruct vchiq_service *service = find_service_by_handle(instance, handle);\n\n\tif (service) {\n\t\tret = vchiq_release_internal(service->state, service);\n\t\tvchiq_service_put(service);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(vchiq_release_service);\n\nstruct service_data_struct {\n\tint fourcc;\n\tint clientid;\n\tint use_count;\n};\n\nvoid\nvchiq_dump_service_use_state(struct vchiq_state *state)\n{\n\tstruct vchiq_arm_state *arm_state = vchiq_platform_get_arm_state(state);\n\tstruct service_data_struct *service_data;\n\tint i, found = 0;\n\t \n\tint only_nonzero = 0;\n\tstatic const char *nz = \"<-- preventing suspend\";\n\n\tint peer_count;\n\tint vc_use_count;\n\tint active_services;\n\n\tif (!arm_state)\n\t\treturn;\n\n\tservice_data = kmalloc_array(MAX_SERVICES, sizeof(*service_data),\n\t\t\t\t     GFP_KERNEL);\n\tif (!service_data)\n\t\treturn;\n\n\tread_lock_bh(&arm_state->susp_res_lock);\n\tpeer_count = arm_state->peer_use_count;\n\tvc_use_count = arm_state->videocore_use_count;\n\tactive_services = state->unused_service;\n\tif (active_services > MAX_SERVICES)\n\t\tonly_nonzero = 1;\n\n\trcu_read_lock();\n\tfor (i = 0; i < active_services; i++) {\n\t\tstruct vchiq_service *service_ptr =\n\t\t\trcu_dereference(state->services[i]);\n\n\t\tif (!service_ptr)\n\t\t\tcontinue;\n\n\t\tif (only_nonzero && !service_ptr->service_use_count)\n\t\t\tcontinue;\n\n\t\tif (service_ptr->srvstate == VCHIQ_SRVSTATE_FREE)\n\t\t\tcontinue;\n\n\t\tservice_data[found].fourcc = service_ptr->base.fourcc;\n\t\tservice_data[found].clientid = service_ptr->client_id;\n\t\tservice_data[found].use_count = service_ptr->service_use_count;\n\t\tfound++;\n\t\tif (found >= MAX_SERVICES)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tread_unlock_bh(&arm_state->susp_res_lock);\n\n\tif (only_nonzero)\n\t\tvchiq_log_warning(vchiq_susp_log_level, \"Too many active services (%d). Only dumping up to first %d services with non-zero use-count\",\n\t\t\t\t  active_services, found);\n\n\tfor (i = 0; i < found; i++) {\n\t\tvchiq_log_warning(vchiq_susp_log_level, \"----- %c%c%c%c:%d service count %d %s\",\n\t\t\t\t  VCHIQ_FOURCC_AS_4CHARS(service_data[i].fourcc),\n\t\t\t\t  service_data[i].clientid, service_data[i].use_count,\n\t\t\t\t  service_data[i].use_count ? nz : \"\");\n\t}\n\tvchiq_log_warning(vchiq_susp_log_level, \"----- VCHIQ use count %d\", peer_count);\n\tvchiq_log_warning(vchiq_susp_log_level, \"--- Overall vchiq instance use count %d\",\n\t\t\t  vc_use_count);\n\n\tkfree(service_data);\n}\n\nint\nvchiq_check_service(struct vchiq_service *service)\n{\n\tstruct vchiq_arm_state *arm_state;\n\tint ret = -EINVAL;\n\n\tif (!service || !service->state)\n\t\tgoto out;\n\n\tarm_state = vchiq_platform_get_arm_state(service->state);\n\n\tread_lock_bh(&arm_state->susp_res_lock);\n\tif (service->service_use_count)\n\t\tret = 0;\n\tread_unlock_bh(&arm_state->susp_res_lock);\n\n\tif (ret) {\n\t\tvchiq_log_error(vchiq_susp_log_level,\n\t\t\t\t\"%s ERROR - %c%c%c%c:%d service count %d, state count %d\", __func__,\n\t\t\t\tVCHIQ_FOURCC_AS_4CHARS(service->base.fourcc), service->client_id,\n\t\t\t\tservice->service_use_count, arm_state->videocore_use_count);\n\t\tvchiq_dump_service_use_state(service->state);\n\t}\nout:\n\treturn ret;\n}\n\nvoid vchiq_platform_conn_state_changed(struct vchiq_state *state,\n\t\t\t\t       enum vchiq_connstate oldstate,\n\t\t\t\t       enum vchiq_connstate newstate)\n{\n\tstruct vchiq_arm_state *arm_state = vchiq_platform_get_arm_state(state);\n\tchar threadname[16];\n\n\tvchiq_log_info(vchiq_susp_log_level, \"%d: %s->%s\", state->id,\n\t\t       get_conn_state_name(oldstate), get_conn_state_name(newstate));\n\tif (state->conn_state != VCHIQ_CONNSTATE_CONNECTED)\n\t\treturn;\n\n\twrite_lock_bh(&arm_state->susp_res_lock);\n\tif (arm_state->first_connect) {\n\t\twrite_unlock_bh(&arm_state->susp_res_lock);\n\t\treturn;\n\t}\n\n\tarm_state->first_connect = 1;\n\twrite_unlock_bh(&arm_state->susp_res_lock);\n\tsnprintf(threadname, sizeof(threadname), \"vchiq-keep/%d\",\n\t\t state->id);\n\tarm_state->ka_thread = kthread_create(&vchiq_keepalive_thread_func,\n\t\t\t\t\t      (void *)state,\n\t\t\t\t\t      threadname);\n\tif (IS_ERR(arm_state->ka_thread)) {\n\t\tvchiq_log_error(vchiq_susp_log_level,\n\t\t\t\t\"vchiq: FATAL: couldn't create thread %s\",\n\t\t\t\tthreadname);\n\t} else {\n\t\twake_up_process(arm_state->ka_thread);\n\t}\n}\n\nstatic const struct of_device_id vchiq_of_match[] = {\n\t{ .compatible = \"brcm,bcm2835-vchiq\", .data = &bcm2835_drvdata },\n\t{ .compatible = \"brcm,bcm2836-vchiq\", .data = &bcm2836_drvdata },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, vchiq_of_match);\n\nstatic struct platform_device *\nvchiq_register_child(struct platform_device *pdev, const char *name)\n{\n\tstruct platform_device_info pdevinfo;\n\tstruct platform_device *child;\n\n\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\n\tpdevinfo.parent = &pdev->dev;\n\tpdevinfo.name = name;\n\tpdevinfo.id = PLATFORM_DEVID_NONE;\n\tpdevinfo.dma_mask = DMA_BIT_MASK(32);\n\n\tchild = platform_device_register_full(&pdevinfo);\n\tif (IS_ERR(child)) {\n\t\tdev_warn(&pdev->dev, \"%s not registered\\n\", name);\n\t\tchild = NULL;\n\t}\n\n\treturn child;\n}\n\nstatic int vchiq_probe(struct platform_device *pdev)\n{\n\tstruct device_node *fw_node;\n\tconst struct of_device_id *of_id;\n\tstruct vchiq_drvdata *drvdata;\n\tint err;\n\n\tof_id = of_match_node(vchiq_of_match, pdev->dev.of_node);\n\tdrvdata = (struct vchiq_drvdata *)of_id->data;\n\tif (!drvdata)\n\t\treturn -EINVAL;\n\n\tfw_node = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t  \"raspberrypi,bcm2835-firmware\");\n\tif (!fw_node) {\n\t\tdev_err(&pdev->dev, \"Missing firmware node\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tdrvdata->fw = devm_rpi_firmware_get(&pdev->dev, fw_node);\n\tof_node_put(fw_node);\n\tif (!drvdata->fw)\n\t\treturn -EPROBE_DEFER;\n\n\tplatform_set_drvdata(pdev, drvdata);\n\n\terr = vchiq_platform_init(pdev, &g_state);\n\tif (err)\n\t\tgoto failed_platform_init;\n\n\tvchiq_debugfs_init();\n\n\tvchiq_log_info(vchiq_arm_log_level,\n\t\t       \"vchiq: platform initialised - version %d (min %d)\",\n\t\t       VCHIQ_VERSION, VCHIQ_VERSION_MIN);\n\n\t \n\terr = vchiq_register_chrdev(&pdev->dev);\n\tif (err) {\n\t\tvchiq_log_warning(vchiq_arm_log_level,\n\t\t\t\t  \"Failed to initialize vchiq cdev\");\n\t\tgoto error_exit;\n\t}\n\n\tbcm2835_camera = vchiq_register_child(pdev, \"bcm2835-camera\");\n\tbcm2835_audio = vchiq_register_child(pdev, \"bcm2835_audio\");\n\n\treturn 0;\n\nfailed_platform_init:\n\tvchiq_log_warning(vchiq_arm_log_level, \"could not initialize vchiq platform\");\nerror_exit:\n\treturn err;\n}\n\nstatic void vchiq_remove(struct platform_device *pdev)\n{\n\tplatform_device_unregister(bcm2835_audio);\n\tplatform_device_unregister(bcm2835_camera);\n\tvchiq_debugfs_deinit();\n\tvchiq_deregister_chrdev();\n}\n\nstatic struct platform_driver vchiq_driver = {\n\t.driver = {\n\t\t.name = \"bcm2835_vchiq\",\n\t\t.of_match_table = vchiq_of_match,\n\t},\n\t.probe = vchiq_probe,\n\t.remove_new = vchiq_remove,\n};\n\nstatic int __init vchiq_driver_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&vchiq_driver);\n\tif (ret)\n\t\tpr_err(\"Failed to register vchiq driver\\n\");\n\n\treturn ret;\n}\nmodule_init(vchiq_driver_init);\n\nstatic void __exit vchiq_driver_exit(void)\n{\n\tplatform_driver_unregister(&vchiq_driver);\n}\nmodule_exit(vchiq_driver_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"Videocore VCHIQ driver\");\nMODULE_AUTHOR(\"Broadcom Corporation\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}