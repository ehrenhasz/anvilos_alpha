{
  "module_name": "vchiq_debugfs.c",
  "hash_id": "ec2df817b5bdf957b8624486b0396e51d82152032b011465b36d3b89cc42e293",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include \"vchiq_core.h\"\n#include \"vchiq_arm.h\"\n#include \"vchiq_debugfs.h\"\n\n#ifdef CONFIG_DEBUG_FS\n\n#define DEBUGFS_WRITE_BUF_SIZE 256\n\n#define VCHIQ_LOG_ERROR_STR   \"error\"\n#define VCHIQ_LOG_WARNING_STR \"warning\"\n#define VCHIQ_LOG_INFO_STR    \"info\"\n#define VCHIQ_LOG_TRACE_STR   \"trace\"\n\n \nstatic struct dentry *vchiq_dbg_dir;\nstatic struct dentry *vchiq_dbg_clients;\n\n \nstruct vchiq_debugfs_log_entry {\n\tconst char *name;\n\tvoid *plevel;\n};\n\nstatic struct vchiq_debugfs_log_entry vchiq_debugfs_log_entries[] = {\n\t{ \"core\", &vchiq_core_log_level },\n\t{ \"msg\",  &vchiq_core_msg_log_level },\n\t{ \"sync\", &vchiq_sync_log_level },\n\t{ \"susp\", &vchiq_susp_log_level },\n\t{ \"arm\",  &vchiq_arm_log_level },\n};\n\nstatic int debugfs_log_show(struct seq_file *f, void *offset)\n{\n\tint *levp = f->private;\n\tchar *log_value = NULL;\n\n\tswitch (*levp) {\n\tcase VCHIQ_LOG_ERROR:\n\t\tlog_value = VCHIQ_LOG_ERROR_STR;\n\t\tbreak;\n\tcase VCHIQ_LOG_WARNING:\n\t\tlog_value = VCHIQ_LOG_WARNING_STR;\n\t\tbreak;\n\tcase VCHIQ_LOG_INFO:\n\t\tlog_value = VCHIQ_LOG_INFO_STR;\n\t\tbreak;\n\tcase VCHIQ_LOG_TRACE:\n\t\tlog_value = VCHIQ_LOG_TRACE_STR;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tseq_printf(f, \"%s\\n\", log_value ? log_value : \"(null)\");\n\n\treturn 0;\n}\n\nstatic int debugfs_log_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, debugfs_log_show, inode->i_private);\n}\n\nstatic ssize_t debugfs_log_write(struct file *file,\n\tconst char __user *buffer,\n\tsize_t count, loff_t *ppos)\n{\n\tstruct seq_file *f = (struct seq_file *)file->private_data;\n\tint *levp = f->private;\n\tchar kbuf[DEBUGFS_WRITE_BUF_SIZE + 1];\n\n\tmemset(kbuf, 0, DEBUGFS_WRITE_BUF_SIZE + 1);\n\tif (count >= DEBUGFS_WRITE_BUF_SIZE)\n\t\tcount = DEBUGFS_WRITE_BUF_SIZE;\n\n\tif (copy_from_user(kbuf, buffer, count))\n\t\treturn -EFAULT;\n\tkbuf[count - 1] = 0;\n\n\tif (strncmp(\"error\", kbuf, strlen(\"error\")) == 0)\n\t\t*levp = VCHIQ_LOG_ERROR;\n\telse if (strncmp(\"warning\", kbuf, strlen(\"warning\")) == 0)\n\t\t*levp = VCHIQ_LOG_WARNING;\n\telse if (strncmp(\"info\", kbuf, strlen(\"info\")) == 0)\n\t\t*levp = VCHIQ_LOG_INFO;\n\telse if (strncmp(\"trace\", kbuf, strlen(\"trace\")) == 0)\n\t\t*levp = VCHIQ_LOG_TRACE;\n\telse\n\t\t*levp = VCHIQ_LOG_DEFAULT;\n\n\t*ppos += count;\n\n\treturn count;\n}\n\nstatic const struct file_operations debugfs_log_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= debugfs_log_open,\n\t.write\t\t= debugfs_log_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int debugfs_usecount_show(struct seq_file *f, void *offset)\n{\n\tstruct vchiq_instance *instance = f->private;\n\tint use_count;\n\n\tuse_count = vchiq_instance_get_use_count(instance);\n\tseq_printf(f, \"%d\\n\", use_count);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_usecount);\n\nstatic int debugfs_trace_show(struct seq_file *f, void *offset)\n{\n\tstruct vchiq_instance *instance = f->private;\n\tint trace;\n\n\ttrace = vchiq_instance_get_trace(instance);\n\tseq_printf(f, \"%s\\n\", trace ? \"Y\" : \"N\");\n\n\treturn 0;\n}\n\nstatic int debugfs_trace_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, debugfs_trace_show, inode->i_private);\n}\n\nstatic ssize_t debugfs_trace_write(struct file *file,\n\tconst char __user *buffer,\n\tsize_t count, loff_t *ppos)\n{\n\tstruct seq_file *f = (struct seq_file *)file->private_data;\n\tstruct vchiq_instance *instance = f->private;\n\tchar firstchar;\n\n\tif (copy_from_user(&firstchar, buffer, 1))\n\t\treturn -EFAULT;\n\n\tswitch (firstchar) {\n\tcase 'Y':\n\tcase 'y':\n\tcase '1':\n\t\tvchiq_instance_set_trace(instance, 1);\n\t\tbreak;\n\tcase 'N':\n\tcase 'n':\n\tcase '0':\n\t\tvchiq_instance_set_trace(instance, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t*ppos += count;\n\n\treturn count;\n}\n\nstatic const struct file_operations debugfs_trace_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= debugfs_trace_open,\n\t.write\t\t= debugfs_trace_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n \nvoid vchiq_debugfs_add_instance(struct vchiq_instance *instance)\n{\n\tchar pidstr[16];\n\tstruct dentry *top;\n\n\tsnprintf(pidstr, sizeof(pidstr), \"%d\",\n\t\t vchiq_instance_get_pid(instance));\n\n\ttop = debugfs_create_dir(pidstr, vchiq_dbg_clients);\n\n\tdebugfs_create_file(\"use_count\", 0444, top, instance,\n\t\t\t    &debugfs_usecount_fops);\n\tdebugfs_create_file(\"trace\", 0644, top, instance, &debugfs_trace_fops);\n\n\tvchiq_instance_get_debugfs_node(instance)->dentry = top;\n}\n\nvoid vchiq_debugfs_remove_instance(struct vchiq_instance *instance)\n{\n\tstruct vchiq_debugfs_node *node =\n\t\t\t\tvchiq_instance_get_debugfs_node(instance);\n\n\tdebugfs_remove_recursive(node->dentry);\n}\n\nvoid vchiq_debugfs_init(void)\n{\n\tstruct dentry *dir;\n\tint i;\n\n\tvchiq_dbg_dir = debugfs_create_dir(\"vchiq\", NULL);\n\tvchiq_dbg_clients = debugfs_create_dir(\"clients\", vchiq_dbg_dir);\n\n\t \n\tdir = debugfs_create_dir(\"log\", vchiq_dbg_dir);\n\n\tfor (i = 0; i < ARRAY_SIZE(vchiq_debugfs_log_entries); i++)\n\t\tdebugfs_create_file(vchiq_debugfs_log_entries[i].name, 0644,\n\t\t\t\t    dir, vchiq_debugfs_log_entries[i].plevel,\n\t\t\t\t    &debugfs_log_fops);\n}\n\n \nvoid vchiq_debugfs_deinit(void)\n{\n\tdebugfs_remove_recursive(vchiq_dbg_dir);\n}\n\n#else  \n\nvoid vchiq_debugfs_init(void)\n{\n}\n\nvoid vchiq_debugfs_deinit(void)\n{\n}\n\nvoid vchiq_debugfs_add_instance(struct vchiq_instance *instance)\n{\n}\n\nvoid vchiq_debugfs_remove_instance(struct vchiq_instance *instance)\n{\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}