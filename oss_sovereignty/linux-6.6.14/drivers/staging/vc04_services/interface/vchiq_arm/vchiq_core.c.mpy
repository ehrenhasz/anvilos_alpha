{
  "module_name": "vchiq_core.c",
  "hash_id": "a5728edc83fb06921687cda93d3f3139c7f186fd2a57cf9dabdb9c167a4e9d4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/rcupdate.h>\n#include <linux/sched/signal.h>\n\n#include \"vchiq_arm.h\"\n#include \"vchiq_core.h\"\n\n#define VCHIQ_SLOT_HANDLER_STACK 8192\n\n#define VCHIQ_MSG_PADDING            0   \n#define VCHIQ_MSG_CONNECT            1   \n#define VCHIQ_MSG_OPEN               2   \n#define VCHIQ_MSG_OPENACK            3   \n#define VCHIQ_MSG_CLOSE              4   \n#define VCHIQ_MSG_DATA               5   \n#define VCHIQ_MSG_BULK_RX            6   \n#define VCHIQ_MSG_BULK_TX            7   \n#define VCHIQ_MSG_BULK_RX_DONE       8   \n#define VCHIQ_MSG_BULK_TX_DONE       9   \n#define VCHIQ_MSG_PAUSE             10   \n#define VCHIQ_MSG_RESUME            11   \n#define VCHIQ_MSG_REMOTE_USE        12   \n#define VCHIQ_MSG_REMOTE_RELEASE    13   \n#define VCHIQ_MSG_REMOTE_USE_ACTIVE 14   \n\n#define TYPE_SHIFT 24\n\n#define VCHIQ_PORT_MAX                 (VCHIQ_MAX_SERVICES - 1)\n#define VCHIQ_PORT_FREE                0x1000\n#define VCHIQ_PORT_IS_VALID(port)      ((port) < VCHIQ_PORT_FREE)\n#define VCHIQ_MAKE_MSG(type, srcport, dstport) \\\n\t(((type) << TYPE_SHIFT) | ((srcport) << 12) | ((dstport) << 0))\n#define VCHIQ_MSG_TYPE(msgid)          ((unsigned int)(msgid) >> TYPE_SHIFT)\n#define VCHIQ_MSG_SRCPORT(msgid) \\\n\t(unsigned short)(((unsigned int)(msgid) >> 12) & 0xfff)\n#define VCHIQ_MSG_DSTPORT(msgid) \\\n\t((unsigned short)(msgid) & 0xfff)\n\n#define MAKE_CONNECT\t\t\t(VCHIQ_MSG_CONNECT << TYPE_SHIFT)\n#define MAKE_OPEN(srcport) \\\n\t((VCHIQ_MSG_OPEN << TYPE_SHIFT) | ((srcport) << 12))\n#define MAKE_OPENACK(srcport, dstport) \\\n\t((VCHIQ_MSG_OPENACK << TYPE_SHIFT) | ((srcport) << 12) | ((dstport) << 0))\n#define MAKE_CLOSE(srcport, dstport) \\\n\t((VCHIQ_MSG_CLOSE << TYPE_SHIFT) | ((srcport) << 12) | ((dstport) << 0))\n#define MAKE_DATA(srcport, dstport) \\\n\t((VCHIQ_MSG_DATA << TYPE_SHIFT) | ((srcport) << 12) | ((dstport) << 0))\n#define MAKE_PAUSE\t\t\t(VCHIQ_MSG_PAUSE << TYPE_SHIFT)\n#define MAKE_RESUME\t\t\t(VCHIQ_MSG_RESUME << TYPE_SHIFT)\n#define MAKE_REMOTE_USE\t\t\t(VCHIQ_MSG_REMOTE_USE << TYPE_SHIFT)\n#define MAKE_REMOTE_USE_ACTIVE\t\t(VCHIQ_MSG_REMOTE_USE_ACTIVE << TYPE_SHIFT)\n\n \nstatic_assert(VCHIQ_MSG_SRCPORT(VCHIQ_MAKE_MSG(0, 0, VCHIQ_PORT_MAX))\n\t== 0);\nstatic_assert(VCHIQ_MSG_TYPE(VCHIQ_MAKE_MSG(0, VCHIQ_PORT_MAX, 0)) == 0);\nstatic_assert((unsigned int)VCHIQ_PORT_MAX <\n\t(unsigned int)VCHIQ_PORT_FREE);\n\n#define VCHIQ_MSGID_PADDING            VCHIQ_MAKE_MSG(VCHIQ_MSG_PADDING, 0, 0)\n#define VCHIQ_MSGID_CLAIMED            0x40000000\n\n#define VCHIQ_FOURCC_INVALID           0x00000000\n#define VCHIQ_FOURCC_IS_LEGAL(fourcc)  ((fourcc) != VCHIQ_FOURCC_INVALID)\n\n#define VCHIQ_BULK_ACTUAL_ABORTED -1\n\n#if VCHIQ_ENABLE_STATS\n#define VCHIQ_STATS_INC(state, stat) (state->stats. stat++)\n#define VCHIQ_SERVICE_STATS_INC(service, stat) (service->stats. stat++)\n#define VCHIQ_SERVICE_STATS_ADD(service, stat, addend) \\\n\t(service->stats. stat += addend)\n#else\n#define VCHIQ_STATS_INC(state, stat) ((void)0)\n#define VCHIQ_SERVICE_STATS_INC(service, stat) ((void)0)\n#define VCHIQ_SERVICE_STATS_ADD(service, stat, addend) ((void)0)\n#endif\n\n#define HANDLE_STATE_SHIFT 12\n\n#define SLOT_INFO_FROM_INDEX(state, index) (state->slot_info + (index))\n#define SLOT_DATA_FROM_INDEX(state, index) (state->slot_data + (index))\n#define SLOT_INDEX_FROM_DATA(state, data) \\\n\t(((unsigned int)((char *)data - (char *)state->slot_data)) / \\\n\tVCHIQ_SLOT_SIZE)\n#define SLOT_INDEX_FROM_INFO(state, info) \\\n\t((unsigned int)(info - state->slot_info))\n#define SLOT_QUEUE_INDEX_FROM_POS(pos) \\\n\t((int)((unsigned int)(pos) / VCHIQ_SLOT_SIZE))\n#define SLOT_QUEUE_INDEX_FROM_POS_MASKED(pos) \\\n\t(SLOT_QUEUE_INDEX_FROM_POS(pos) & VCHIQ_SLOT_QUEUE_MASK)\n\n#define BULK_INDEX(x) ((x) & (VCHIQ_NUM_SERVICE_BULKS - 1))\n\n#define SRVTRACE_LEVEL(srv) \\\n\t(((srv) && (srv)->trace) ? VCHIQ_LOG_TRACE : vchiq_core_msg_log_level)\n#define SRVTRACE_ENABLED(srv, lev) \\\n\t(((srv) && (srv)->trace) || (vchiq_core_msg_log_level >= (lev)))\n\n#define NO_CLOSE_RECVD\t0\n#define CLOSE_RECVD\t1\n\n#define NO_RETRY_POLL\t0\n#define RETRY_POLL\t1\n\nstruct vchiq_open_payload {\n\tint fourcc;\n\tint client_id;\n\tshort version;\n\tshort version_min;\n};\n\nstruct vchiq_openack_payload {\n\tshort version;\n};\n\nenum {\n\tQMFLAGS_IS_BLOCKING     = BIT(0),\n\tQMFLAGS_NO_MUTEX_LOCK   = BIT(1),\n\tQMFLAGS_NO_MUTEX_UNLOCK = BIT(2)\n};\n\nenum {\n\tVCHIQ_POLL_TERMINATE,\n\tVCHIQ_POLL_REMOVE,\n\tVCHIQ_POLL_TXNOTIFY,\n\tVCHIQ_POLL_RXNOTIFY,\n\tVCHIQ_POLL_COUNT\n};\n\n \nstatic_assert(sizeof(struct vchiq_header) == 8);\nstatic_assert(VCHIQ_VERSION >= VCHIQ_VERSION_MIN);\n\nstatic inline void check_sizes(void)\n{\n\tBUILD_BUG_ON_NOT_POWER_OF_2(VCHIQ_SLOT_SIZE);\n\tBUILD_BUG_ON_NOT_POWER_OF_2(VCHIQ_MAX_SLOTS);\n\tBUILD_BUG_ON_NOT_POWER_OF_2(VCHIQ_MAX_SLOTS_PER_SIDE);\n\tBUILD_BUG_ON_NOT_POWER_OF_2(sizeof(struct vchiq_header));\n\tBUILD_BUG_ON_NOT_POWER_OF_2(VCHIQ_NUM_CURRENT_BULKS);\n\tBUILD_BUG_ON_NOT_POWER_OF_2(VCHIQ_NUM_SERVICE_BULKS);\n\tBUILD_BUG_ON_NOT_POWER_OF_2(VCHIQ_MAX_SERVICES);\n}\n\n \nint vchiq_core_log_level = VCHIQ_LOG_DEFAULT;\nint vchiq_core_msg_log_level = VCHIQ_LOG_DEFAULT;\nint vchiq_sync_log_level = VCHIQ_LOG_DEFAULT;\n\nDEFINE_SPINLOCK(bulk_waiter_spinlock);\nstatic DEFINE_SPINLOCK(quota_spinlock);\n\nstatic unsigned int handle_seq;\n\nstatic const char *const srvstate_names[] = {\n\t\"FREE\",\n\t\"HIDDEN\",\n\t\"LISTENING\",\n\t\"OPENING\",\n\t\"OPEN\",\n\t\"OPENSYNC\",\n\t\"CLOSESENT\",\n\t\"CLOSERECVD\",\n\t\"CLOSEWAIT\",\n\t\"CLOSED\"\n};\n\nstatic const char *const reason_names[] = {\n\t\"SERVICE_OPENED\",\n\t\"SERVICE_CLOSED\",\n\t\"MESSAGE_AVAILABLE\",\n\t\"BULK_TRANSMIT_DONE\",\n\t\"BULK_RECEIVE_DONE\",\n\t\"BULK_TRANSMIT_ABORTED\",\n\t\"BULK_RECEIVE_ABORTED\"\n};\n\nstatic const char *const conn_state_names[] = {\n\t\"DISCONNECTED\",\n\t\"CONNECTING\",\n\t\"CONNECTED\",\n\t\"PAUSING\",\n\t\"PAUSE_SENT\",\n\t\"PAUSED\",\n\t\"RESUMING\",\n\t\"PAUSE_TIMEOUT\",\n\t\"RESUME_TIMEOUT\"\n};\n\nstatic void\nrelease_message_sync(struct vchiq_state *state, struct vchiq_header *header);\n\nstatic const char *msg_type_str(unsigned int msg_type)\n{\n\tswitch (msg_type) {\n\tcase VCHIQ_MSG_PADDING:\t\t\treturn \"PADDING\";\n\tcase VCHIQ_MSG_CONNECT:\t\t\treturn \"CONNECT\";\n\tcase VCHIQ_MSG_OPEN:\t\t\treturn \"OPEN\";\n\tcase VCHIQ_MSG_OPENACK:\t\t\treturn \"OPENACK\";\n\tcase VCHIQ_MSG_CLOSE:\t\t\treturn \"CLOSE\";\n\tcase VCHIQ_MSG_DATA:\t\t\treturn \"DATA\";\n\tcase VCHIQ_MSG_BULK_RX:\t\t\treturn \"BULK_RX\";\n\tcase VCHIQ_MSG_BULK_TX:\t\t\treturn \"BULK_TX\";\n\tcase VCHIQ_MSG_BULK_RX_DONE:\t\treturn \"BULK_RX_DONE\";\n\tcase VCHIQ_MSG_BULK_TX_DONE:\t\treturn \"BULK_TX_DONE\";\n\tcase VCHIQ_MSG_PAUSE:\t\t\treturn \"PAUSE\";\n\tcase VCHIQ_MSG_RESUME:\t\t\treturn \"RESUME\";\n\tcase VCHIQ_MSG_REMOTE_USE:\t\treturn \"REMOTE_USE\";\n\tcase VCHIQ_MSG_REMOTE_RELEASE:\t\treturn \"REMOTE_RELEASE\";\n\tcase VCHIQ_MSG_REMOTE_USE_ACTIVE:\treturn \"REMOTE_USE_ACTIVE\";\n\t}\n\treturn \"???\";\n}\n\nstatic inline void\nset_service_state(struct vchiq_service *service, int newstate)\n{\n\tvchiq_log_info(vchiq_core_log_level, \"%d: srv:%d %s->%s\",\n\t\t       service->state->id, service->localport,\n\t\t       srvstate_names[service->srvstate],\n\t\t       srvstate_names[newstate]);\n\tservice->srvstate = newstate;\n}\n\nstruct vchiq_service *handle_to_service(struct vchiq_instance *instance, unsigned int handle)\n{\n\tint idx = handle & (VCHIQ_MAX_SERVICES - 1);\n\n\treturn rcu_dereference(instance->state->services[idx]);\n}\nstruct vchiq_service *\nfind_service_by_handle(struct vchiq_instance *instance, unsigned int handle)\n{\n\tstruct vchiq_service *service;\n\n\trcu_read_lock();\n\tservice = handle_to_service(instance, handle);\n\tif (service && service->srvstate != VCHIQ_SRVSTATE_FREE &&\n\t    service->handle == handle &&\n\t    kref_get_unless_zero(&service->ref_count)) {\n\t\tservice = rcu_pointer_handoff(service);\n\t\trcu_read_unlock();\n\t\treturn service;\n\t}\n\trcu_read_unlock();\n\tvchiq_log_info(vchiq_core_log_level,\n\t\t       \"Invalid service handle 0x%x\", handle);\n\treturn NULL;\n}\n\nstruct vchiq_service *\nfind_service_by_port(struct vchiq_state *state, unsigned int localport)\n{\n\tif (localport <= VCHIQ_PORT_MAX) {\n\t\tstruct vchiq_service *service;\n\n\t\trcu_read_lock();\n\t\tservice = rcu_dereference(state->services[localport]);\n\t\tif (service && service->srvstate != VCHIQ_SRVSTATE_FREE &&\n\t\t    kref_get_unless_zero(&service->ref_count)) {\n\t\t\tservice = rcu_pointer_handoff(service);\n\t\t\trcu_read_unlock();\n\t\t\treturn service;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tvchiq_log_info(vchiq_core_log_level,\n\t\t       \"Invalid port %u\", localport);\n\treturn NULL;\n}\n\nstruct vchiq_service *\nfind_service_for_instance(struct vchiq_instance *instance, unsigned int handle)\n{\n\tstruct vchiq_service *service;\n\n\trcu_read_lock();\n\tservice = handle_to_service(instance, handle);\n\tif (service && service->srvstate != VCHIQ_SRVSTATE_FREE &&\n\t    service->handle == handle &&\n\t    service->instance == instance &&\n\t    kref_get_unless_zero(&service->ref_count)) {\n\t\tservice = rcu_pointer_handoff(service);\n\t\trcu_read_unlock();\n\t\treturn service;\n\t}\n\trcu_read_unlock();\n\tvchiq_log_info(vchiq_core_log_level,\n\t\t       \"Invalid service handle 0x%x\", handle);\n\treturn NULL;\n}\n\nstruct vchiq_service *\nfind_closed_service_for_instance(struct vchiq_instance *instance, unsigned int handle)\n{\n\tstruct vchiq_service *service;\n\n\trcu_read_lock();\n\tservice = handle_to_service(instance, handle);\n\tif (service &&\n\t    (service->srvstate == VCHIQ_SRVSTATE_FREE ||\n\t     service->srvstate == VCHIQ_SRVSTATE_CLOSED) &&\n\t    service->handle == handle &&\n\t    service->instance == instance &&\n\t    kref_get_unless_zero(&service->ref_count)) {\n\t\tservice = rcu_pointer_handoff(service);\n\t\trcu_read_unlock();\n\t\treturn service;\n\t}\n\trcu_read_unlock();\n\tvchiq_log_info(vchiq_core_log_level,\n\t\t       \"Invalid service handle 0x%x\", handle);\n\treturn service;\n}\n\nstruct vchiq_service *\n__next_service_by_instance(struct vchiq_state *state,\n\t\t\t   struct vchiq_instance *instance,\n\t\t\t   int *pidx)\n{\n\tstruct vchiq_service *service = NULL;\n\tint idx = *pidx;\n\n\twhile (idx < state->unused_service) {\n\t\tstruct vchiq_service *srv;\n\n\t\tsrv = rcu_dereference(state->services[idx]);\n\t\tidx++;\n\t\tif (srv && srv->srvstate != VCHIQ_SRVSTATE_FREE &&\n\t\t    srv->instance == instance) {\n\t\t\tservice = srv;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*pidx = idx;\n\treturn service;\n}\n\nstruct vchiq_service *\nnext_service_by_instance(struct vchiq_state *state,\n\t\t\t struct vchiq_instance *instance,\n\t\t\t int *pidx)\n{\n\tstruct vchiq_service *service;\n\n\trcu_read_lock();\n\twhile (1) {\n\t\tservice = __next_service_by_instance(state, instance, pidx);\n\t\tif (!service)\n\t\t\tbreak;\n\t\tif (kref_get_unless_zero(&service->ref_count)) {\n\t\t\tservice = rcu_pointer_handoff(service);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn service;\n}\n\nvoid\nvchiq_service_get(struct vchiq_service *service)\n{\n\tif (!service) {\n\t\tWARN(1, \"%s service is NULL\\n\", __func__);\n\t\treturn;\n\t}\n\tkref_get(&service->ref_count);\n}\n\nstatic void service_release(struct kref *kref)\n{\n\tstruct vchiq_service *service =\n\t\tcontainer_of(kref, struct vchiq_service, ref_count);\n\tstruct vchiq_state *state = service->state;\n\n\tWARN_ON(service->srvstate != VCHIQ_SRVSTATE_FREE);\n\trcu_assign_pointer(state->services[service->localport], NULL);\n\tif (service->userdata_term)\n\t\tservice->userdata_term(service->base.userdata);\n\tkfree_rcu(service, rcu);\n}\n\nvoid\nvchiq_service_put(struct vchiq_service *service)\n{\n\tif (!service) {\n\t\tWARN(1, \"%s: service is NULL\\n\", __func__);\n\t\treturn;\n\t}\n\tkref_put(&service->ref_count, service_release);\n}\n\nint\nvchiq_get_client_id(struct vchiq_instance *instance, unsigned int handle)\n{\n\tstruct vchiq_service *service;\n\tint id;\n\n\trcu_read_lock();\n\tservice = handle_to_service(instance, handle);\n\tid = service ? service->client_id : 0;\n\trcu_read_unlock();\n\treturn id;\n}\n\nvoid *\nvchiq_get_service_userdata(struct vchiq_instance *instance, unsigned int handle)\n{\n\tvoid *userdata;\n\tstruct vchiq_service *service;\n\n\trcu_read_lock();\n\tservice = handle_to_service(instance, handle);\n\tuserdata = service ? service->base.userdata : NULL;\n\trcu_read_unlock();\n\treturn userdata;\n}\nEXPORT_SYMBOL(vchiq_get_service_userdata);\n\nstatic void\nmark_service_closing_internal(struct vchiq_service *service, int sh_thread)\n{\n\tstruct vchiq_state *state = service->state;\n\tstruct vchiq_service_quota *quota;\n\n\tservice->closing = 1;\n\n\t \n\tmutex_lock(&state->recycle_mutex);\n\tmutex_unlock(&state->recycle_mutex);\n\tif (!sh_thread || (state->conn_state != VCHIQ_CONNSTATE_PAUSE_SENT)) {\n\t\t \n\t\tmutex_lock(&state->slot_mutex);\n\t\tmutex_unlock(&state->slot_mutex);\n\t}\n\n\t \n\tquota = &state->service_quotas[service->localport];\n\tcomplete(&quota->quota_event);\n}\n\nstatic void\nmark_service_closing(struct vchiq_service *service)\n{\n\tmark_service_closing_internal(service, 0);\n}\n\nstatic inline int\nmake_service_callback(struct vchiq_service *service, enum vchiq_reason reason,\n\t\t      struct vchiq_header *header, void *bulk_userdata)\n{\n\tint status;\n\n\tvchiq_log_trace(vchiq_core_log_level, \"%d: callback:%d (%s, %pK, %pK)\",\n\t\t\tservice->state->id, service->localport, reason_names[reason],\n\t\t\theader, bulk_userdata);\n\tstatus = service->base.callback(service->instance, reason, header, service->handle,\n\t\t\t\t\tbulk_userdata);\n\tif (status && (status != -EAGAIN)) {\n\t\tvchiq_log_warning(vchiq_core_log_level,\n\t\t\t\t  \"%d: ignoring ERROR from callback to service %x\",\n\t\t\t\t  service->state->id, service->handle);\n\t\tstatus = 0;\n\t}\n\n\tif (reason != VCHIQ_MESSAGE_AVAILABLE)\n\t\tvchiq_release_message(service->instance, service->handle, header);\n\n\treturn status;\n}\n\ninline void\nvchiq_set_conn_state(struct vchiq_state *state, enum vchiq_connstate newstate)\n{\n\tenum vchiq_connstate oldstate = state->conn_state;\n\n\tvchiq_log_info(vchiq_core_log_level, \"%d: %s->%s\", state->id, conn_state_names[oldstate],\n\t\t       conn_state_names[newstate]);\n\tstate->conn_state = newstate;\n\tvchiq_platform_conn_state_changed(state, oldstate, newstate);\n}\n\n \nstatic inline void\nremote_event_create(wait_queue_head_t *wq, struct remote_event *event)\n{\n\tevent->armed = 0;\n\t \n\tinit_waitqueue_head(wq);\n}\n\n \nstatic inline int\nremote_event_wait(wait_queue_head_t *wq, struct remote_event *event)\n{\n\tif (!event->fired) {\n\t\tevent->armed = 1;\n\t\tdsb(sy);\n\t\tif (wait_event_interruptible(*wq, event->fired)) {\n\t\t\tevent->armed = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tevent->armed = 0;\n\t\t \n\t\twmb();\n\t}\n\n\tevent->fired = 0;\n\treturn 1;\n}\n\n \nstatic inline void\nremote_event_signal_local(wait_queue_head_t *wq, struct remote_event *event)\n{\n\tevent->fired = 1;\n\tevent->armed = 0;\n\twake_up_all(wq);\n}\n\n \nstatic inline void\nremote_event_poll(wait_queue_head_t *wq, struct remote_event *event)\n{\n\tif (event->fired && event->armed)\n\t\tremote_event_signal_local(wq, event);\n}\n\n \nvoid\nremote_event_pollall(struct vchiq_state *state)\n{\n\tremote_event_poll(&state->sync_trigger_event, &state->local->sync_trigger);\n\tremote_event_poll(&state->sync_release_event, &state->local->sync_release);\n\tremote_event_poll(&state->trigger_event, &state->local->trigger);\n\tremote_event_poll(&state->recycle_event, &state->local->recycle);\n}\n\n \n\nstatic inline size_t\ncalc_stride(size_t size)\n{\n\t \n\tsize += sizeof(struct vchiq_header);\n\n\t \n\treturn (size + sizeof(struct vchiq_header) - 1) &\n\t\t~(sizeof(struct vchiq_header) - 1);\n}\n\n \nstatic struct vchiq_service *\nget_listening_service(struct vchiq_state *state, int fourcc)\n{\n\tint i;\n\n\tWARN_ON(fourcc == VCHIQ_FOURCC_INVALID);\n\n\trcu_read_lock();\n\tfor (i = 0; i < state->unused_service; i++) {\n\t\tstruct vchiq_service *service;\n\n\t\tservice = rcu_dereference(state->services[i]);\n\t\tif (service &&\n\t\t    service->public_fourcc == fourcc &&\n\t\t    (service->srvstate == VCHIQ_SRVSTATE_LISTENING ||\n\t\t     (service->srvstate == VCHIQ_SRVSTATE_OPEN &&\n\t\t      service->remoteport == VCHIQ_PORT_FREE)) &&\n\t\t    kref_get_unless_zero(&service->ref_count)) {\n\t\t\tservice = rcu_pointer_handoff(service);\n\t\t\trcu_read_unlock();\n\t\t\treturn service;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}\n\n \nstatic struct vchiq_service *\nget_connected_service(struct vchiq_state *state, unsigned int port)\n{\n\tint i;\n\n\trcu_read_lock();\n\tfor (i = 0; i < state->unused_service; i++) {\n\t\tstruct vchiq_service *service =\n\t\t\trcu_dereference(state->services[i]);\n\n\t\tif (service && service->srvstate == VCHIQ_SRVSTATE_OPEN &&\n\t\t    service->remoteport == port &&\n\t\t    kref_get_unless_zero(&service->ref_count)) {\n\t\t\tservice = rcu_pointer_handoff(service);\n\t\t\trcu_read_unlock();\n\t\t\treturn service;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}\n\ninline void\nrequest_poll(struct vchiq_state *state, struct vchiq_service *service,\n\t     int poll_type)\n{\n\tu32 value;\n\tint index;\n\n\tif (!service)\n\t\tgoto skip_service;\n\n\tdo {\n\t\tvalue = atomic_read(&service->poll_flags);\n\t} while (atomic_cmpxchg(&service->poll_flags, value,\n\t\t value | BIT(poll_type)) != value);\n\n\tindex = BITSET_WORD(service->localport);\n\tdo {\n\t\tvalue = atomic_read(&state->poll_services[index]);\n\t} while (atomic_cmpxchg(&state->poll_services[index],\n\t\t value, value | BIT(service->localport & 0x1f)) != value);\n\nskip_service:\n\tstate->poll_needed = 1;\n\t \n\twmb();\n\n\t \n\tremote_event_signal_local(&state->trigger_event, &state->local->trigger);\n}\n\n \nstatic struct vchiq_header *\nreserve_space(struct vchiq_state *state, size_t space, int is_blocking)\n{\n\tstruct vchiq_shared_state *local = state->local;\n\tint tx_pos = state->local_tx_pos;\n\tint slot_space = VCHIQ_SLOT_SIZE - (tx_pos & VCHIQ_SLOT_MASK);\n\n\tif (space > slot_space) {\n\t\tstruct vchiq_header *header;\n\t\t \n\t\tWARN_ON(!state->tx_data);\n\t\theader = (struct vchiq_header *)\n\t\t\t(state->tx_data + (tx_pos & VCHIQ_SLOT_MASK));\n\t\theader->msgid = VCHIQ_MSGID_PADDING;\n\t\theader->size = slot_space - sizeof(struct vchiq_header);\n\n\t\ttx_pos += slot_space;\n\t}\n\n\t \n\tif ((tx_pos & VCHIQ_SLOT_MASK) == 0) {\n\t\tint slot_index;\n\n\t\t \n\n\t\tif (!try_wait_for_completion(&state->slot_available_event)) {\n\t\t\t \n\n\t\t\tVCHIQ_STATS_INC(state, slot_stalls);\n\n\t\t\t \n\t\t\tstate->local_tx_pos = tx_pos;\n\t\t\tlocal->tx_pos = tx_pos;\n\t\t\tremote_event_signal(&state->remote->trigger);\n\n\t\t\tif (!is_blocking ||\n\t\t\t    (wait_for_completion_interruptible(&state->slot_available_event)))\n\t\t\t\treturn NULL;  \n\t\t}\n\n\t\tif (tx_pos == (state->slot_queue_available * VCHIQ_SLOT_SIZE)) {\n\t\t\tcomplete(&state->slot_available_event);\n\t\t\tpr_warn(\"%s: invalid tx_pos: %d\\n\", __func__, tx_pos);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tslot_index = local->slot_queue[SLOT_QUEUE_INDEX_FROM_POS_MASKED(tx_pos)];\n\t\tstate->tx_data =\n\t\t\t(char *)SLOT_DATA_FROM_INDEX(state, slot_index);\n\t}\n\n\tstate->local_tx_pos = tx_pos + space;\n\n\treturn (struct vchiq_header *)(state->tx_data +\n\t\t\t\t\t\t(tx_pos & VCHIQ_SLOT_MASK));\n}\n\nstatic void\nprocess_free_data_message(struct vchiq_state *state, u32 *service_found,\n\t\t\t  struct vchiq_header *header)\n{\n\tint msgid = header->msgid;\n\tint port = VCHIQ_MSG_SRCPORT(msgid);\n\tstruct vchiq_service_quota *quota = &state->service_quotas[port];\n\tint count;\n\n\tspin_lock(&quota_spinlock);\n\tcount = quota->message_use_count;\n\tif (count > 0)\n\t\tquota->message_use_count = count - 1;\n\tspin_unlock(&quota_spinlock);\n\n\tif (count == quota->message_quota) {\n\t\t \n\t\tcomplete(&quota->quota_event);\n\t} else if (count == 0) {\n\t\tvchiq_log_error(vchiq_core_log_level,\n\t\t\t\t\"service %d message_use_count=%d (header %pK, msgid %x, header->msgid %x, header->size %x)\",\n\t\t\t\tport, quota->message_use_count, header, msgid, header->msgid,\n\t\t\t\theader->size);\n\t\tWARN(1, \"invalid message use count\\n\");\n\t}\n\tif (!BITSET_IS_SET(service_found, port)) {\n\t\t \n\t\tBITSET_SET(service_found, port);\n\n\t\tspin_lock(&quota_spinlock);\n\t\tcount = quota->slot_use_count;\n\t\tif (count > 0)\n\t\t\tquota->slot_use_count = count - 1;\n\t\tspin_unlock(&quota_spinlock);\n\n\t\tif (count > 0) {\n\t\t\t \n\t\t\tcomplete(&quota->quota_event);\n\t\t\tvchiq_log_trace(vchiq_core_log_level, \"%d: pfq:%d %x@%pK - slot_use->%d\",\n\t\t\t\t\tstate->id, port, header->size, header, count - 1);\n\t\t} else {\n\t\t\tvchiq_log_error(vchiq_core_log_level,\n\t\t\t\t\t\"service %d slot_use_count=%d (header %pK, msgid %x, header->msgid %x, header->size %x)\",\n\t\t\t\t\tport, count, header, msgid, header->msgid, header->size);\n\t\t\tWARN(1, \"bad slot use count\\n\");\n\t\t}\n\t}\n}\n\n \nstatic void\nprocess_free_queue(struct vchiq_state *state, u32 *service_found,\n\t\t   size_t length)\n{\n\tstruct vchiq_shared_state *local = state->local;\n\tint slot_queue_available;\n\n\t \n\tslot_queue_available = state->slot_queue_available;\n\n\t \n\tmb();\n\n\twhile (slot_queue_available != local->slot_queue_recycle) {\n\t\tunsigned int pos;\n\t\tint slot_index = local->slot_queue[slot_queue_available &\n\t\t\tVCHIQ_SLOT_QUEUE_MASK];\n\t\tchar *data = (char *)SLOT_DATA_FROM_INDEX(state, slot_index);\n\t\tint data_found = 0;\n\n\t\tslot_queue_available++;\n\t\t \n\t\trmb();\n\n\t\tvchiq_log_trace(vchiq_core_log_level, \"%d: pfq %d=%pK %x %x\",\n\t\t\t\tstate->id, slot_index, data, local->slot_queue_recycle,\n\t\t\t\tslot_queue_available);\n\n\t\t \n\t\tmemset(service_found, 0, length);\n\n\t\tpos = 0;\n\n\t\twhile (pos < VCHIQ_SLOT_SIZE) {\n\t\t\tstruct vchiq_header *header =\n\t\t\t\t(struct vchiq_header *)(data + pos);\n\t\t\tint msgid = header->msgid;\n\n\t\t\tif (VCHIQ_MSG_TYPE(msgid) == VCHIQ_MSG_DATA) {\n\t\t\t\tprocess_free_data_message(state, service_found,\n\t\t\t\t\t\t\t  header);\n\t\t\t\tdata_found = 1;\n\t\t\t}\n\n\t\t\tpos += calc_stride(header->size);\n\t\t\tif (pos > VCHIQ_SLOT_SIZE) {\n\t\t\t\tvchiq_log_error(vchiq_core_log_level,\n\t\t\t\t\t\t\"pfq - pos %x: header %pK, msgid %x, header->msgid %x, header->size %x\",\n\t\t\t\t\t\tpos, header, msgid, header->msgid, header->size);\n\t\t\t\tWARN(1, \"invalid slot position\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (data_found) {\n\t\t\tint count;\n\n\t\t\tspin_lock(&quota_spinlock);\n\t\t\tcount = state->data_use_count;\n\t\t\tif (count > 0)\n\t\t\t\tstate->data_use_count = count - 1;\n\t\t\tspin_unlock(&quota_spinlock);\n\t\t\tif (count == state->data_quota)\n\t\t\t\tcomplete(&state->data_quota_event);\n\t\t}\n\n\t\t \n\t\tmb();\n\n\t\tstate->slot_queue_available = slot_queue_available;\n\t\tcomplete(&state->slot_available_event);\n\t}\n}\n\nstatic ssize_t\nmemcpy_copy_callback(void *context, void *dest, size_t offset, size_t maxsize)\n{\n\tmemcpy(dest + offset, context + offset, maxsize);\n\treturn maxsize;\n}\n\nstatic ssize_t\ncopy_message_data(ssize_t (*copy_callback)(void *context, void *dest, size_t offset,\n\t\t\t\t\t   size_t maxsize),\n\tvoid *context,\n\tvoid *dest,\n\tsize_t size)\n{\n\tsize_t pos = 0;\n\n\twhile (pos < size) {\n\t\tssize_t callback_result;\n\t\tsize_t max_bytes = size - pos;\n\n\t\tcallback_result = copy_callback(context, dest + pos, pos,\n\t\t\t\t\t\tmax_bytes);\n\n\t\tif (callback_result < 0)\n\t\t\treturn callback_result;\n\n\t\tif (!callback_result)\n\t\t\treturn -EIO;\n\n\t\tif (callback_result > max_bytes)\n\t\t\treturn -EIO;\n\n\t\tpos += callback_result;\n\t}\n\n\treturn size;\n}\n\n \nstatic int\nqueue_message(struct vchiq_state *state, struct vchiq_service *service,\n\t      int msgid,\n\t      ssize_t (*copy_callback)(void *context, void *dest,\n\t\t\t\t       size_t offset, size_t maxsize),\n\t      void *context, size_t size, int flags)\n{\n\tstruct vchiq_shared_state *local;\n\tstruct vchiq_service_quota *quota = NULL;\n\tstruct vchiq_header *header;\n\tint type = VCHIQ_MSG_TYPE(msgid);\n\n\tsize_t stride;\n\n\tlocal = state->local;\n\n\tstride = calc_stride(size);\n\n\tWARN_ON(stride > VCHIQ_SLOT_SIZE);\n\n\tif (!(flags & QMFLAGS_NO_MUTEX_LOCK) &&\n\t    mutex_lock_killable(&state->slot_mutex))\n\t\treturn -EAGAIN;\n\n\tif (type == VCHIQ_MSG_DATA) {\n\t\tint tx_end_index;\n\n\t\tif (!service) {\n\t\t\tWARN(1, \"%s: service is NULL\\n\", __func__);\n\t\t\tmutex_unlock(&state->slot_mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tWARN_ON(flags & (QMFLAGS_NO_MUTEX_LOCK |\n\t\t\t\t QMFLAGS_NO_MUTEX_UNLOCK));\n\n\t\tif (service->closing) {\n\t\t\t \n\t\t\tmutex_unlock(&state->slot_mutex);\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\n\t\tquota = &state->service_quotas[service->localport];\n\n\t\tspin_lock(&quota_spinlock);\n\n\t\t \n\t\ttx_end_index = SLOT_QUEUE_INDEX_FROM_POS(state->local_tx_pos + stride - 1);\n\n\t\t \n\t\twhile ((tx_end_index != state->previous_data_index) &&\n\t\t       (state->data_use_count == state->data_quota)) {\n\t\t\tVCHIQ_STATS_INC(state, data_stalls);\n\t\t\tspin_unlock(&quota_spinlock);\n\t\t\tmutex_unlock(&state->slot_mutex);\n\n\t\t\tif (wait_for_completion_interruptible(&state->data_quota_event))\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tmutex_lock(&state->slot_mutex);\n\t\t\tspin_lock(&quota_spinlock);\n\t\t\ttx_end_index = SLOT_QUEUE_INDEX_FROM_POS(state->local_tx_pos + stride - 1);\n\t\t\tif ((tx_end_index == state->previous_data_index) ||\n\t\t\t    (state->data_use_count < state->data_quota)) {\n\t\t\t\t \n\t\t\t\tcomplete(&state->data_quota_event);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twhile ((quota->message_use_count == quota->message_quota) ||\n\t\t       ((tx_end_index != quota->previous_tx_index) &&\n\t\t\t(quota->slot_use_count == quota->slot_quota))) {\n\t\t\tspin_unlock(&quota_spinlock);\n\t\t\tvchiq_log_trace(vchiq_core_log_level,\n\t\t\t\t\t\"%d: qm:%d %s,%zx - quota stall (msg %d, slot %d)\",\n\t\t\t\t\tstate->id, service->localport, msg_type_str(type), size,\n\t\t\t\t\tquota->message_use_count, quota->slot_use_count);\n\t\t\tVCHIQ_SERVICE_STATS_INC(service, quota_stalls);\n\t\t\tmutex_unlock(&state->slot_mutex);\n\t\t\tif (wait_for_completion_interruptible(&quota->quota_event))\n\t\t\t\treturn -EAGAIN;\n\t\t\tif (service->closing)\n\t\t\t\treturn -EHOSTDOWN;\n\t\t\tif (mutex_lock_killable(&state->slot_mutex))\n\t\t\t\treturn -EAGAIN;\n\t\t\tif (service->srvstate != VCHIQ_SRVSTATE_OPEN) {\n\t\t\t\t \n\t\t\t\tmutex_unlock(&state->slot_mutex);\n\t\t\t\treturn -EHOSTDOWN;\n\t\t\t}\n\t\t\tspin_lock(&quota_spinlock);\n\t\t\ttx_end_index = SLOT_QUEUE_INDEX_FROM_POS(state->local_tx_pos + stride - 1);\n\t\t}\n\n\t\tspin_unlock(&quota_spinlock);\n\t}\n\n\theader = reserve_space(state, stride, flags & QMFLAGS_IS_BLOCKING);\n\n\tif (!header) {\n\t\tif (service)\n\t\t\tVCHIQ_SERVICE_STATS_INC(service, slot_stalls);\n\t\t \n\t\tif (!(flags & QMFLAGS_NO_MUTEX_LOCK))\n\t\t\tmutex_unlock(&state->slot_mutex);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (type == VCHIQ_MSG_DATA) {\n\t\tssize_t callback_result;\n\t\tint tx_end_index;\n\t\tint slot_use_count;\n\n\t\tvchiq_log_info(vchiq_core_log_level, \"%d: qm %s@%pK,%zx (%d->%d)\", state->id,\n\t\t\t       msg_type_str(VCHIQ_MSG_TYPE(msgid)), header, size,\n\t\t\t       VCHIQ_MSG_SRCPORT(msgid), VCHIQ_MSG_DSTPORT(msgid));\n\n\t\tWARN_ON(flags & (QMFLAGS_NO_MUTEX_LOCK |\n\t\t\t\t QMFLAGS_NO_MUTEX_UNLOCK));\n\n\t\tcallback_result =\n\t\t\tcopy_message_data(copy_callback, context,\n\t\t\t\t\t  header->data, size);\n\n\t\tif (callback_result < 0) {\n\t\t\tmutex_unlock(&state->slot_mutex);\n\t\t\tVCHIQ_SERVICE_STATS_INC(service, error_count);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (SRVTRACE_ENABLED(service,\n\t\t\t\t     VCHIQ_LOG_INFO))\n\t\t\tvchiq_log_dump_mem(\"Sent\", 0,\n\t\t\t\t\t   header->data,\n\t\t\t\t\t   min_t(size_t, 16, callback_result));\n\n\t\tspin_lock(&quota_spinlock);\n\t\tquota->message_use_count++;\n\n\t\ttx_end_index =\n\t\t\tSLOT_QUEUE_INDEX_FROM_POS(state->local_tx_pos - 1);\n\n\t\t \n\t\tif (tx_end_index != state->previous_data_index) {\n\t\t\tstate->previous_data_index = tx_end_index;\n\t\t\tstate->data_use_count++;\n\t\t}\n\n\t\t \n\t\tif (tx_end_index != quota->previous_tx_index) {\n\t\t\tquota->previous_tx_index = tx_end_index;\n\t\t\tslot_use_count = ++quota->slot_use_count;\n\t\t} else {\n\t\t\tslot_use_count = 0;\n\t\t}\n\n\t\tspin_unlock(&quota_spinlock);\n\n\t\tif (slot_use_count)\n\t\t\tvchiq_log_trace(vchiq_core_log_level,\n\t\t\t\t\t\"%d: qm:%d %s,%zx - slot_use->%d (hdr %p)\", state->id,\n\t\t\t\t\tservice->localport, msg_type_str(VCHIQ_MSG_TYPE(msgid)),\n\t\t\t\t\tsize, slot_use_count, header);\n\n\t\tVCHIQ_SERVICE_STATS_INC(service, ctrl_tx_count);\n\t\tVCHIQ_SERVICE_STATS_ADD(service, ctrl_tx_bytes, size);\n\t} else {\n\t\tvchiq_log_info(vchiq_core_log_level, \"%d: qm %s@%pK,%zx (%d->%d)\", state->id,\n\t\t\t       msg_type_str(VCHIQ_MSG_TYPE(msgid)), header, size,\n\t\t\t       VCHIQ_MSG_SRCPORT(msgid), VCHIQ_MSG_DSTPORT(msgid));\n\t\tif (size != 0) {\n\t\t\t \n\t\t\tcopy_message_data(copy_callback, context,\n\t\t\t\t\t  header->data, size);\n\t\t}\n\t\tVCHIQ_STATS_INC(state, ctrl_tx_count);\n\t}\n\n\theader->msgid = msgid;\n\theader->size = size;\n\n\t{\n\t\tint svc_fourcc;\n\n\t\tsvc_fourcc = service\n\t\t\t? service->base.fourcc\n\t\t\t: VCHIQ_MAKE_FOURCC('?', '?', '?', '?');\n\n\t\tvchiq_log_info(SRVTRACE_LEVEL(service),\n\t\t\t       \"Sent Msg %s(%u) to %c%c%c%c s:%u d:%d len:%zu\",\n\t\t\t       msg_type_str(VCHIQ_MSG_TYPE(msgid)), VCHIQ_MSG_TYPE(msgid),\n\t\t\t       VCHIQ_FOURCC_AS_4CHARS(svc_fourcc), VCHIQ_MSG_SRCPORT(msgid),\n\t\t\t       VCHIQ_MSG_DSTPORT(msgid), size);\n\t}\n\n\t \n\twmb();\n\n\t \n\tlocal->tx_pos = state->local_tx_pos;\n\twmb();\n\n\tif (service && (type == VCHIQ_MSG_CLOSE))\n\t\tset_service_state(service, VCHIQ_SRVSTATE_CLOSESENT);\n\n\tif (!(flags & QMFLAGS_NO_MUTEX_UNLOCK))\n\t\tmutex_unlock(&state->slot_mutex);\n\n\tremote_event_signal(&state->remote->trigger);\n\n\treturn 0;\n}\n\n \nstatic int\nqueue_message_sync(struct vchiq_state *state, struct vchiq_service *service,\n\t\t   int msgid,\n\t\t   ssize_t (*copy_callback)(void *context, void *dest,\n\t\t\t\t\t    size_t offset, size_t maxsize),\n\t\t   void *context, int size, int is_blocking)\n{\n\tstruct vchiq_shared_state *local;\n\tstruct vchiq_header *header;\n\tssize_t callback_result;\n\n\tlocal = state->local;\n\n\tif (VCHIQ_MSG_TYPE(msgid) != VCHIQ_MSG_RESUME &&\n\t    mutex_lock_killable(&state->sync_mutex))\n\t\treturn -EAGAIN;\n\n\tremote_event_wait(&state->sync_release_event, &local->sync_release);\n\n\t \n\trmb();\n\n\theader = (struct vchiq_header *)SLOT_DATA_FROM_INDEX(state,\n\t\tlocal->slot_sync);\n\n\t{\n\t\tint oldmsgid = header->msgid;\n\n\t\tif (oldmsgid != VCHIQ_MSGID_PADDING)\n\t\t\tvchiq_log_error(vchiq_core_log_level, \"%d: qms - msgid %x, not PADDING\",\n\t\t\t\t\tstate->id, oldmsgid);\n\t}\n\n\tvchiq_log_info(vchiq_sync_log_level,\n\t\t       \"%d: qms %s@%pK,%x (%d->%d)\", state->id,\n\t\t       msg_type_str(VCHIQ_MSG_TYPE(msgid)),\n\t\t       header, size, VCHIQ_MSG_SRCPORT(msgid),\n\t\t       VCHIQ_MSG_DSTPORT(msgid));\n\n\tcallback_result =\n\t\tcopy_message_data(copy_callback, context,\n\t\t\t\t  header->data, size);\n\n\tif (callback_result < 0) {\n\t\tmutex_unlock(&state->slot_mutex);\n\t\tVCHIQ_SERVICE_STATS_INC(service, error_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (service) {\n\t\tif (SRVTRACE_ENABLED(service,\n\t\t\t\t     VCHIQ_LOG_INFO))\n\t\t\tvchiq_log_dump_mem(\"Sent\", 0,\n\t\t\t\t\t   header->data,\n\t\t\t\t\t   min_t(size_t, 16, callback_result));\n\n\t\tVCHIQ_SERVICE_STATS_INC(service, ctrl_tx_count);\n\t\tVCHIQ_SERVICE_STATS_ADD(service, ctrl_tx_bytes, size);\n\t} else {\n\t\tVCHIQ_STATS_INC(state, ctrl_tx_count);\n\t}\n\n\theader->size = size;\n\theader->msgid = msgid;\n\n\tif (vchiq_sync_log_level >= VCHIQ_LOG_TRACE) {\n\t\tint svc_fourcc;\n\n\t\tsvc_fourcc = service\n\t\t\t? service->base.fourcc\n\t\t\t: VCHIQ_MAKE_FOURCC('?', '?', '?', '?');\n\n\t\tvchiq_log_trace(vchiq_sync_log_level,\n\t\t\t\t\"Sent Sync Msg %s(%u) to %c%c%c%c s:%u d:%d len:%d\",\n\t\t\t\tmsg_type_str(VCHIQ_MSG_TYPE(msgid)), VCHIQ_MSG_TYPE(msgid),\n\t\t\t\tVCHIQ_FOURCC_AS_4CHARS(svc_fourcc), VCHIQ_MSG_SRCPORT(msgid),\n\t\t\t\tVCHIQ_MSG_DSTPORT(msgid), size);\n\t}\n\n\tremote_event_signal(&state->remote->sync_trigger);\n\n\tif (VCHIQ_MSG_TYPE(msgid) != VCHIQ_MSG_PAUSE)\n\t\tmutex_unlock(&state->sync_mutex);\n\n\treturn 0;\n}\n\nstatic inline void\nclaim_slot(struct vchiq_slot_info *slot)\n{\n\tslot->use_count++;\n}\n\nstatic void\nrelease_slot(struct vchiq_state *state, struct vchiq_slot_info *slot_info,\n\t     struct vchiq_header *header, struct vchiq_service *service)\n{\n\tmutex_lock(&state->recycle_mutex);\n\n\tif (header) {\n\t\tint msgid = header->msgid;\n\n\t\tif (((msgid & VCHIQ_MSGID_CLAIMED) == 0) || (service && service->closing)) {\n\t\t\tmutex_unlock(&state->recycle_mutex);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\theader->msgid = msgid & ~VCHIQ_MSGID_CLAIMED;\n\t}\n\n\tslot_info->release_count++;\n\n\tif (slot_info->release_count == slot_info->use_count) {\n\t\tint slot_queue_recycle;\n\t\t \n\n\t\t \n\t\trmb();\n\n\t\tslot_queue_recycle = state->remote->slot_queue_recycle;\n\t\tstate->remote->slot_queue[slot_queue_recycle &\n\t\t\tVCHIQ_SLOT_QUEUE_MASK] =\n\t\t\tSLOT_INDEX_FROM_INFO(state, slot_info);\n\t\tstate->remote->slot_queue_recycle = slot_queue_recycle + 1;\n\t\tvchiq_log_info(vchiq_core_log_level, \"%d: %s %d - recycle->%x\", state->id, __func__,\n\t\t\t       SLOT_INDEX_FROM_INFO(state, slot_info),\n\t\t\t       state->remote->slot_queue_recycle);\n\n\t\t \n\t\tremote_event_signal(&state->remote->recycle);\n\t}\n\n\tmutex_unlock(&state->recycle_mutex);\n}\n\nstatic inline enum vchiq_reason\nget_bulk_reason(struct vchiq_bulk *bulk)\n{\n\tif (bulk->dir == VCHIQ_BULK_TRANSMIT) {\n\t\tif (bulk->actual == VCHIQ_BULK_ACTUAL_ABORTED)\n\t\t\treturn VCHIQ_BULK_TRANSMIT_ABORTED;\n\n\t\treturn VCHIQ_BULK_TRANSMIT_DONE;\n\t}\n\n\tif (bulk->actual == VCHIQ_BULK_ACTUAL_ABORTED)\n\t\treturn VCHIQ_BULK_RECEIVE_ABORTED;\n\n\treturn VCHIQ_BULK_RECEIVE_DONE;\n}\n\n \nstatic int\nnotify_bulks(struct vchiq_service *service, struct vchiq_bulk_queue *queue,\n\t     int retry_poll)\n{\n\tint status = 0;\n\n\tvchiq_log_trace(vchiq_core_log_level, \"%d: nb:%d %cx - p=%x rn=%x r=%x\", service->state->id,\n\t\t\tservice->localport, (queue == &service->bulk_tx) ? 't' : 'r',\n\t\t\tqueue->process, queue->remote_notify, queue->remove);\n\n\tqueue->remote_notify = queue->process;\n\n\twhile (queue->remove != queue->remote_notify) {\n\t\tstruct vchiq_bulk *bulk =\n\t\t\t&queue->bulks[BULK_INDEX(queue->remove)];\n\n\t\t \n\t\tif (bulk->data && service->instance) {\n\t\t\tif (bulk->actual != VCHIQ_BULK_ACTUAL_ABORTED) {\n\t\t\t\tif (bulk->dir == VCHIQ_BULK_TRANSMIT) {\n\t\t\t\t\tVCHIQ_SERVICE_STATS_INC(service, bulk_tx_count);\n\t\t\t\t\tVCHIQ_SERVICE_STATS_ADD(service, bulk_tx_bytes,\n\t\t\t\t\t\t\t\tbulk->actual);\n\t\t\t\t} else {\n\t\t\t\t\tVCHIQ_SERVICE_STATS_INC(service, bulk_rx_count);\n\t\t\t\t\tVCHIQ_SERVICE_STATS_ADD(service, bulk_rx_bytes,\n\t\t\t\t\t\t\t\tbulk->actual);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVCHIQ_SERVICE_STATS_INC(service, bulk_aborted_count);\n\t\t\t}\n\t\t\tif (bulk->mode == VCHIQ_BULK_MODE_BLOCKING) {\n\t\t\t\tstruct bulk_waiter *waiter;\n\n\t\t\t\tspin_lock(&bulk_waiter_spinlock);\n\t\t\t\twaiter = bulk->userdata;\n\t\t\t\tif (waiter) {\n\t\t\t\t\twaiter->actual = bulk->actual;\n\t\t\t\t\tcomplete(&waiter->event);\n\t\t\t\t}\n\t\t\t\tspin_unlock(&bulk_waiter_spinlock);\n\t\t\t} else if (bulk->mode == VCHIQ_BULK_MODE_CALLBACK) {\n\t\t\t\tenum vchiq_reason reason =\n\t\t\t\t\t\tget_bulk_reason(bulk);\n\t\t\t\tstatus = make_service_callback(service, reason,\tNULL,\n\t\t\t\t\t\t\t       bulk->userdata);\n\t\t\t\tif (status == -EAGAIN)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tqueue->remove++;\n\t\tcomplete(&service->bulk_remove_event);\n\t}\n\tif (!retry_poll)\n\t\tstatus = 0;\n\n\tif (status == -EAGAIN)\n\t\trequest_poll(service->state, service, (queue == &service->bulk_tx) ?\n\t\t\t     VCHIQ_POLL_TXNOTIFY : VCHIQ_POLL_RXNOTIFY);\n\n\treturn status;\n}\n\nstatic void\npoll_services_of_group(struct vchiq_state *state, int group)\n{\n\tu32 flags = atomic_xchg(&state->poll_services[group], 0);\n\tint i;\n\n\tfor (i = 0; flags; i++) {\n\t\tstruct vchiq_service *service;\n\t\tu32 service_flags;\n\n\t\tif ((flags & BIT(i)) == 0)\n\t\t\tcontinue;\n\n\t\tservice = find_service_by_port(state, (group << 5) + i);\n\t\tflags &= ~BIT(i);\n\n\t\tif (!service)\n\t\t\tcontinue;\n\n\t\tservice_flags = atomic_xchg(&service->poll_flags, 0);\n\t\tif (service_flags & BIT(VCHIQ_POLL_REMOVE)) {\n\t\t\tvchiq_log_info(vchiq_core_log_level, \"%d: ps - remove %d<->%d\",\n\t\t\t\t       state->id, service->localport,\n\t\t\t\t       service->remoteport);\n\n\t\t\t \n\t\t\tservice->public_fourcc = VCHIQ_FOURCC_INVALID;\n\n\t\t\tif (vchiq_close_service_internal(service, NO_CLOSE_RECVD))\n\t\t\t\trequest_poll(state, service, VCHIQ_POLL_REMOVE);\n\t\t} else if (service_flags & BIT(VCHIQ_POLL_TERMINATE)) {\n\t\t\tvchiq_log_info(vchiq_core_log_level, \"%d: ps - terminate %d<->%d\",\n\t\t\t\t       state->id, service->localport, service->remoteport);\n\t\t\tif (vchiq_close_service_internal(service, NO_CLOSE_RECVD))\n\t\t\t\trequest_poll(state, service, VCHIQ_POLL_TERMINATE);\n\t\t}\n\t\tif (service_flags & BIT(VCHIQ_POLL_TXNOTIFY))\n\t\t\tnotify_bulks(service, &service->bulk_tx, RETRY_POLL);\n\t\tif (service_flags & BIT(VCHIQ_POLL_RXNOTIFY))\n\t\t\tnotify_bulks(service, &service->bulk_rx, RETRY_POLL);\n\t\tvchiq_service_put(service);\n\t}\n}\n\n \nstatic void\npoll_services(struct vchiq_state *state)\n{\n\tint group;\n\n\tfor (group = 0; group < BITSET_SIZE(state->unused_service); group++)\n\t\tpoll_services_of_group(state, group);\n}\n\n \nstatic void\nabort_outstanding_bulks(struct vchiq_service *service,\n\t\t\tstruct vchiq_bulk_queue *queue)\n{\n\tint is_tx = (queue == &service->bulk_tx);\n\n\tvchiq_log_trace(vchiq_core_log_level, \"%d: aob:%d %cx - li=%x ri=%x p=%x\",\n\t\t\tservice->state->id, service->localport, is_tx ? 't' : 'r',\n\t\t\tqueue->local_insert, queue->remote_insert, queue->process);\n\n\tWARN_ON((int)(queue->local_insert - queue->process) < 0);\n\tWARN_ON((int)(queue->remote_insert - queue->process) < 0);\n\n\twhile ((queue->process != queue->local_insert) ||\n\t       (queue->process != queue->remote_insert)) {\n\t\tstruct vchiq_bulk *bulk = &queue->bulks[BULK_INDEX(queue->process)];\n\n\t\tif (queue->process == queue->remote_insert) {\n\t\t\t \n\t\t\tbulk->remote_data = NULL;\n\t\t\tbulk->remote_size = 0;\n\t\t\tqueue->remote_insert++;\n\t\t}\n\n\t\tif (queue->process != queue->local_insert) {\n\t\t\tvchiq_complete_bulk(service->instance, bulk);\n\n\t\t\tvchiq_log_info(SRVTRACE_LEVEL(service),\n\t\t\t\t       \"%s %c%c%c%c d:%d ABORTED - tx len:%d, rx len:%d\",\n\t\t\t\t       is_tx ? \"Send Bulk to\" : \"Recv Bulk from\",\n\t\t\t\t       VCHIQ_FOURCC_AS_4CHARS(service->base.fourcc),\n\t\t\t\t       service->remoteport, bulk->size, bulk->remote_size);\n\t\t} else {\n\t\t\t \n\t\t\tbulk->data = 0;\n\t\t\tbulk->size = 0;\n\t\t\tbulk->actual = VCHIQ_BULK_ACTUAL_ABORTED;\n\t\t\tbulk->dir = is_tx ? VCHIQ_BULK_TRANSMIT :\n\t\t\t\tVCHIQ_BULK_RECEIVE;\n\t\t\tqueue->local_insert++;\n\t\t}\n\n\t\tqueue->process++;\n\t}\n}\n\nstatic int\nparse_open(struct vchiq_state *state, struct vchiq_header *header)\n{\n\tconst struct vchiq_open_payload *payload;\n\tstruct vchiq_service *service = NULL;\n\tint msgid, size;\n\tunsigned int localport, remoteport, fourcc;\n\tshort version, version_min;\n\n\tmsgid = header->msgid;\n\tsize = header->size;\n\tlocalport = VCHIQ_MSG_DSTPORT(msgid);\n\tremoteport = VCHIQ_MSG_SRCPORT(msgid);\n\tif (size < sizeof(struct vchiq_open_payload))\n\t\tgoto fail_open;\n\n\tpayload = (struct vchiq_open_payload *)header->data;\n\tfourcc = payload->fourcc;\n\tvchiq_log_info(vchiq_core_log_level, \"%d: prs OPEN@%pK (%d->'%c%c%c%c')\",\n\t\t       state->id, header, localport, VCHIQ_FOURCC_AS_4CHARS(fourcc));\n\n\tservice = get_listening_service(state, fourcc);\n\tif (!service)\n\t\tgoto fail_open;\n\n\t \n\tversion = payload->version;\n\tversion_min = payload->version_min;\n\n\tif ((service->version < version_min) || (version < service->version_min)) {\n\t\t \n\t\tvchiq_loud_error_header();\n\t\tvchiq_loud_error(\"%d: service %d (%c%c%c%c) version mismatch - local (%d, min %d) vs. remote (%d, min %d)\",\n\t\t\t\t state->id, service->localport, VCHIQ_FOURCC_AS_4CHARS(fourcc),\n\t\t\t\t service->version, service->version_min, version, version_min);\n\t\tvchiq_loud_error_footer();\n\t\tvchiq_service_put(service);\n\t\tservice = NULL;\n\t\tgoto fail_open;\n\t}\n\tservice->peer_version = version;\n\n\tif (service->srvstate == VCHIQ_SRVSTATE_LISTENING) {\n\t\tstruct vchiq_openack_payload ack_payload = {\n\t\t\tservice->version\n\t\t};\n\t\tint openack_id = MAKE_OPENACK(service->localport, remoteport);\n\n\t\tif (state->version_common <\n\t\t    VCHIQ_VERSION_SYNCHRONOUS_MODE)\n\t\t\tservice->sync = 0;\n\n\t\t \n\t\tif (service->sync) {\n\t\t\tif (queue_message_sync(state, NULL, openack_id, memcpy_copy_callback,\n\t\t\t\t\t       &ack_payload, sizeof(ack_payload), 0) == -EAGAIN)\n\t\t\t\tgoto bail_not_ready;\n\n\t\t\t \n\t\t\tset_service_state(service, VCHIQ_SRVSTATE_OPENSYNC);\n\t\t} else {\n\t\t\tif (queue_message(state, NULL, openack_id, memcpy_copy_callback,\n\t\t\t\t\t  &ack_payload, sizeof(ack_payload), 0) == -EAGAIN)\n\t\t\t\tgoto bail_not_ready;\n\n\t\t\t \n\t\t\tset_service_state(service, VCHIQ_SRVSTATE_OPEN);\n\t\t}\n\t}\n\n\t \n\tvchiq_service_put(service);\n\treturn 1;\n\nfail_open:\n\t \n\tif (queue_message(state, NULL, MAKE_CLOSE(0, VCHIQ_MSG_SRCPORT(msgid)),\n\t\t\t  NULL, NULL, 0, 0) == -EAGAIN)\n\t\tgoto bail_not_ready;\n\n\treturn 1;\n\nbail_not_ready:\n\tif (service)\n\t\tvchiq_service_put(service);\n\n\treturn 0;\n}\n\n \nstatic int\nparse_message(struct vchiq_state *state, struct vchiq_header *header)\n{\n\tstruct vchiq_service *service = NULL;\n\tunsigned int localport, remoteport;\n\tint msgid, size, type, ret = -EINVAL;\n\n\tDEBUG_INITIALISE(state->local);\n\n\tDEBUG_VALUE(PARSE_HEADER, (int)(long)header);\n\tmsgid = header->msgid;\n\tDEBUG_VALUE(PARSE_MSGID, msgid);\n\tsize = header->size;\n\ttype = VCHIQ_MSG_TYPE(msgid);\n\tlocalport = VCHIQ_MSG_DSTPORT(msgid);\n\tremoteport = VCHIQ_MSG_SRCPORT(msgid);\n\n\tif (type != VCHIQ_MSG_DATA)\n\t\tVCHIQ_STATS_INC(state, ctrl_rx_count);\n\n\tswitch (type) {\n\tcase VCHIQ_MSG_OPENACK:\n\tcase VCHIQ_MSG_CLOSE:\n\tcase VCHIQ_MSG_DATA:\n\tcase VCHIQ_MSG_BULK_RX:\n\tcase VCHIQ_MSG_BULK_TX:\n\tcase VCHIQ_MSG_BULK_RX_DONE:\n\tcase VCHIQ_MSG_BULK_TX_DONE:\n\t\tservice = find_service_by_port(state, localport);\n\t\tif ((!service ||\n\t\t     ((service->remoteport != remoteport) &&\n\t\t      (service->remoteport != VCHIQ_PORT_FREE))) &&\n\t\t    (localport == 0) &&\n\t\t    (type == VCHIQ_MSG_CLOSE)) {\n\t\t\t \n\t\t\tif (service)\n\t\t\t\tvchiq_service_put(service);\n\t\t\tservice = get_connected_service(state, remoteport);\n\t\t\tif (service)\n\t\t\t\tvchiq_log_warning(vchiq_core_log_level,\n\t\t\t\t\t\t  \"%d: prs %s@%pK (%d->%d) - found connected service %d\",\n\t\t\t\t\t\t  state->id, msg_type_str(type), header,\n\t\t\t\t\t\t  remoteport, localport, service->localport);\n\t\t}\n\n\t\tif (!service) {\n\t\t\tvchiq_log_error(vchiq_core_log_level,\n\t\t\t\t\t\"%d: prs %s@%pK (%d->%d) - invalid/closed service %d\",\n\t\t\t\t\tstate->id, msg_type_str(type), header, remoteport,\n\t\t\t\t\tlocalport, localport);\n\t\t\tgoto skip_message;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (SRVTRACE_ENABLED(service, VCHIQ_LOG_INFO)) {\n\t\tint svc_fourcc;\n\n\t\tsvc_fourcc = service\n\t\t\t? service->base.fourcc\n\t\t\t: VCHIQ_MAKE_FOURCC('?', '?', '?', '?');\n\t\tvchiq_log_info(SRVTRACE_LEVEL(service),\n\t\t\t       \"Rcvd Msg %s(%u) from %c%c%c%c s:%d d:%d len:%d\",\n\t\t\t       msg_type_str(type), type, VCHIQ_FOURCC_AS_4CHARS(svc_fourcc),\n\t\t\t       remoteport, localport, size);\n\t\tif (size > 0)\n\t\t\tvchiq_log_dump_mem(\"Rcvd\", 0, header->data, min(16, size));\n\t}\n\n\tif (((unsigned long)header & VCHIQ_SLOT_MASK) +\n\t    calc_stride(size) > VCHIQ_SLOT_SIZE) {\n\t\tvchiq_log_error(vchiq_core_log_level,\n\t\t\t\t\"header %pK (msgid %x) - size %x too big for slot\",\n\t\t\t\theader, (unsigned int)msgid, (unsigned int)size);\n\t\tWARN(1, \"oversized for slot\\n\");\n\t}\n\n\tswitch (type) {\n\tcase VCHIQ_MSG_OPEN:\n\t\tWARN_ON(VCHIQ_MSG_DSTPORT(msgid));\n\t\tif (!parse_open(state, header))\n\t\t\tgoto bail_not_ready;\n\t\tbreak;\n\tcase VCHIQ_MSG_OPENACK:\n\t\tif (size >= sizeof(struct vchiq_openack_payload)) {\n\t\t\tconst struct vchiq_openack_payload *payload =\n\t\t\t\t(struct vchiq_openack_payload *)\n\t\t\t\theader->data;\n\t\t\tservice->peer_version = payload->version;\n\t\t}\n\t\tvchiq_log_info(vchiq_core_log_level, \"%d: prs OPENACK@%pK,%x (%d->%d) v:%d\",\n\t\t\t       state->id, header, size, remoteport, localport,\n\t\t\t       service->peer_version);\n\t\tif (service->srvstate == VCHIQ_SRVSTATE_OPENING) {\n\t\t\tservice->remoteport = remoteport;\n\t\t\tset_service_state(service, VCHIQ_SRVSTATE_OPEN);\n\t\t\tcomplete(&service->remove_event);\n\t\t} else {\n\t\t\tvchiq_log_error(vchiq_core_log_level, \"OPENACK received in state %s\",\n\t\t\t\t\tsrvstate_names[service->srvstate]);\n\t\t}\n\t\tbreak;\n\tcase VCHIQ_MSG_CLOSE:\n\t\tWARN_ON(size);  \n\n\t\tvchiq_log_info(vchiq_core_log_level, \"%d: prs CLOSE@%pK (%d->%d)\",\n\t\t\t       state->id, header, remoteport, localport);\n\n\t\tmark_service_closing_internal(service, 1);\n\n\t\tif (vchiq_close_service_internal(service, CLOSE_RECVD) == -EAGAIN)\n\t\t\tgoto bail_not_ready;\n\n\t\tvchiq_log_info(vchiq_core_log_level, \"Close Service %c%c%c%c s:%u d:%d\",\n\t\t\t       VCHIQ_FOURCC_AS_4CHARS(service->base.fourcc),\n\t\t\t       service->localport, service->remoteport);\n\t\tbreak;\n\tcase VCHIQ_MSG_DATA:\n\t\tvchiq_log_info(vchiq_core_log_level, \"%d: prs DATA@%pK,%x (%d->%d)\",\n\t\t\t       state->id, header, size, remoteport, localport);\n\n\t\tif ((service->remoteport == remoteport) &&\n\t\t    (service->srvstate == VCHIQ_SRVSTATE_OPEN)) {\n\t\t\theader->msgid = msgid | VCHIQ_MSGID_CLAIMED;\n\t\t\tclaim_slot(state->rx_info);\n\t\t\tDEBUG_TRACE(PARSE_LINE);\n\t\t\tif (make_service_callback(service, VCHIQ_MESSAGE_AVAILABLE, header,\n\t\t\t\t\t\t  NULL) == -EAGAIN) {\n\t\t\t\tDEBUG_TRACE(PARSE_LINE);\n\t\t\t\tgoto bail_not_ready;\n\t\t\t}\n\t\t\tVCHIQ_SERVICE_STATS_INC(service, ctrl_rx_count);\n\t\t\tVCHIQ_SERVICE_STATS_ADD(service, ctrl_rx_bytes, size);\n\t\t} else {\n\t\t\tVCHIQ_STATS_INC(state, error_count);\n\t\t}\n\t\tbreak;\n\tcase VCHIQ_MSG_CONNECT:\n\t\tvchiq_log_info(vchiq_core_log_level, \"%d: prs CONNECT@%pK\", state->id, header);\n\t\tstate->version_common =\t((struct vchiq_slot_zero *)\n\t\t\t\t\t state->slot_data)->version;\n\t\tcomplete(&state->connect);\n\t\tbreak;\n\tcase VCHIQ_MSG_BULK_RX:\n\tcase VCHIQ_MSG_BULK_TX:\n\t\t \n\t\tWARN_ON(1);\n\t\tbreak;\n\tcase VCHIQ_MSG_BULK_RX_DONE:\n\tcase VCHIQ_MSG_BULK_TX_DONE:\n\t\tif ((service->remoteport == remoteport) &&\n\t\t    (service->srvstate != VCHIQ_SRVSTATE_FREE)) {\n\t\t\tstruct vchiq_bulk_queue *queue;\n\t\t\tstruct vchiq_bulk *bulk;\n\n\t\t\tqueue = (type == VCHIQ_MSG_BULK_RX_DONE) ?\n\t\t\t\t&service->bulk_rx : &service->bulk_tx;\n\n\t\t\tDEBUG_TRACE(PARSE_LINE);\n\t\t\tif (mutex_lock_killable(&service->bulk_mutex)) {\n\t\t\t\tDEBUG_TRACE(PARSE_LINE);\n\t\t\t\tgoto bail_not_ready;\n\t\t\t}\n\t\t\tif ((int)(queue->remote_insert -\n\t\t\t\tqueue->local_insert) >= 0) {\n\t\t\t\tvchiq_log_error(vchiq_core_log_level,\n\t\t\t\t\t\t\"%d: prs %s@%pK (%d->%d) unexpected (ri=%d,li=%d)\",\n\t\t\t\t\t\tstate->id, msg_type_str(type), header, remoteport,\n\t\t\t\t\t\tlocalport, queue->remote_insert,\n\t\t\t\t\t\tqueue->local_insert);\n\t\t\t\tmutex_unlock(&service->bulk_mutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (queue->process != queue->remote_insert) {\n\t\t\t\tpr_err(\"%s: p %x != ri %x\\n\",\n\t\t\t\t       __func__,\n\t\t\t\t       queue->process,\n\t\t\t\t       queue->remote_insert);\n\t\t\t\tmutex_unlock(&service->bulk_mutex);\n\t\t\t\tgoto bail_not_ready;\n\t\t\t}\n\n\t\t\tbulk = &queue->bulks[BULK_INDEX(queue->remote_insert)];\n\t\t\tbulk->actual = *(int *)header->data;\n\t\t\tqueue->remote_insert++;\n\n\t\t\tvchiq_log_info(vchiq_core_log_level, \"%d: prs %s@%pK (%d->%d) %x@%pad\",\n\t\t\t\t       state->id, msg_type_str(type), header, remoteport, localport,\n\t\t\t\t       bulk->actual, &bulk->data);\n\n\t\t\tvchiq_log_trace(vchiq_core_log_level, \"%d: prs:%d %cx li=%x ri=%x p=%x\",\n\t\t\t\t\tstate->id, localport,\n\t\t\t\t\t(type == VCHIQ_MSG_BULK_RX_DONE) ? 'r' : 't',\n\t\t\t\t\tqueue->local_insert, queue->remote_insert, queue->process);\n\n\t\t\tDEBUG_TRACE(PARSE_LINE);\n\t\t\tWARN_ON(queue->process == queue->local_insert);\n\t\t\tvchiq_complete_bulk(service->instance, bulk);\n\t\t\tqueue->process++;\n\t\t\tmutex_unlock(&service->bulk_mutex);\n\t\t\tDEBUG_TRACE(PARSE_LINE);\n\t\t\tnotify_bulks(service, queue, RETRY_POLL);\n\t\t\tDEBUG_TRACE(PARSE_LINE);\n\t\t}\n\t\tbreak;\n\tcase VCHIQ_MSG_PADDING:\n\t\tvchiq_log_trace(vchiq_core_log_level, \"%d: prs PADDING@%pK,%x\",\n\t\t\t\tstate->id, header, size);\n\t\tbreak;\n\tcase VCHIQ_MSG_PAUSE:\n\t\t \n\t\tvchiq_log_trace(vchiq_core_log_level, \"%d: prs PAUSE@%pK,%x\",\n\t\t\t\tstate->id, header, size);\n\t\tif (state->conn_state == VCHIQ_CONNSTATE_PAUSED) {\n\t\t\tvchiq_log_error(vchiq_core_log_level, \"%d: PAUSE received in state PAUSED\",\n\t\t\t\t\tstate->id);\n\t\t\tbreak;\n\t\t}\n\t\tif (state->conn_state != VCHIQ_CONNSTATE_PAUSE_SENT) {\n\t\t\t \n\t\t\tif (queue_message(state, NULL, MAKE_PAUSE, NULL, NULL, 0,\n\t\t\t\t\t  QMFLAGS_NO_MUTEX_UNLOCK) == -EAGAIN)\n\t\t\t\tgoto bail_not_ready;\n\t\t}\n\t\t \n\t\tvchiq_set_conn_state(state, VCHIQ_CONNSTATE_PAUSED);\n\t\tbreak;\n\tcase VCHIQ_MSG_RESUME:\n\t\tvchiq_log_trace(vchiq_core_log_level, \"%d: prs RESUME@%pK,%x\",\n\t\t\t\tstate->id, header, size);\n\t\t \n\t\tmutex_unlock(&state->slot_mutex);\n\t\tvchiq_set_conn_state(state, VCHIQ_CONNSTATE_CONNECTED);\n\t\tbreak;\n\n\tcase VCHIQ_MSG_REMOTE_USE:\n\t\tvchiq_on_remote_use(state);\n\t\tbreak;\n\tcase VCHIQ_MSG_REMOTE_RELEASE:\n\t\tvchiq_on_remote_release(state);\n\t\tbreak;\n\tcase VCHIQ_MSG_REMOTE_USE_ACTIVE:\n\t\tbreak;\n\n\tdefault:\n\t\tvchiq_log_error(vchiq_core_log_level, \"%d: prs invalid msgid %x@%pK,%x\",\n\t\t\t\tstate->id, msgid, header, size);\n\t\tWARN(1, \"invalid message\\n\");\n\t\tbreak;\n\t}\n\nskip_message:\n\tret = size;\n\nbail_not_ready:\n\tif (service)\n\t\tvchiq_service_put(service);\n\n\treturn ret;\n}\n\n \nstatic void\nparse_rx_slots(struct vchiq_state *state)\n{\n\tstruct vchiq_shared_state *remote = state->remote;\n\tint tx_pos;\n\n\tDEBUG_INITIALISE(state->local);\n\n\ttx_pos = remote->tx_pos;\n\n\twhile (state->rx_pos != tx_pos) {\n\t\tstruct vchiq_header *header;\n\t\tint size;\n\n\t\tDEBUG_TRACE(PARSE_LINE);\n\t\tif (!state->rx_data) {\n\t\t\tint rx_index;\n\n\t\t\tWARN_ON(state->rx_pos & VCHIQ_SLOT_MASK);\n\t\t\trx_index = remote->slot_queue[\n\t\t\t\tSLOT_QUEUE_INDEX_FROM_POS_MASKED(state->rx_pos)];\n\t\t\tstate->rx_data = (char *)SLOT_DATA_FROM_INDEX(state,\n\t\t\t\trx_index);\n\t\t\tstate->rx_info = SLOT_INFO_FROM_INDEX(state, rx_index);\n\n\t\t\t \n\t\t\tstate->rx_info->use_count = 1;\n\t\t\tstate->rx_info->release_count = 0;\n\t\t}\n\n\t\theader = (struct vchiq_header *)(state->rx_data +\n\t\t\t(state->rx_pos & VCHIQ_SLOT_MASK));\n\t\tsize = parse_message(state, header);\n\t\tif (size < 0)\n\t\t\treturn;\n\n\t\tstate->rx_pos += calc_stride(size);\n\n\t\tDEBUG_TRACE(PARSE_LINE);\n\t\t \n\t\tif ((state->rx_pos & VCHIQ_SLOT_MASK) == 0) {\n\t\t\t \n\t\t\trelease_slot(state, state->rx_info, NULL, NULL);\n\t\t\tstate->rx_data = NULL;\n\t\t}\n\t}\n}\n\n \nstatic int\nhandle_poll(struct vchiq_state *state)\n{\n\tswitch (state->conn_state) {\n\tcase VCHIQ_CONNSTATE_CONNECTED:\n\t\t \n\t\tpoll_services(state);\n\t\tbreak;\n\n\tcase VCHIQ_CONNSTATE_PAUSING:\n\t\tif (queue_message(state, NULL, MAKE_PAUSE, NULL, NULL, 0,\n\t\t\t\t  QMFLAGS_NO_MUTEX_UNLOCK) != -EAGAIN) {\n\t\t\tvchiq_set_conn_state(state, VCHIQ_CONNSTATE_PAUSE_SENT);\n\t\t} else {\n\t\t\t \n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tbreak;\n\n\tcase VCHIQ_CONNSTATE_RESUMING:\n\t\tif (queue_message(state, NULL, MAKE_RESUME, NULL, NULL, 0,\n\t\t\t\t  QMFLAGS_NO_MUTEX_LOCK) != -EAGAIN) {\n\t\t\tvchiq_set_conn_state(state, VCHIQ_CONNSTATE_CONNECTED);\n\t\t} else {\n\t\t\t \n\t\t\tvchiq_log_error(vchiq_core_log_level, \"Failed to send RESUME message\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nslot_handler_func(void *v)\n{\n\tstruct vchiq_state *state = v;\n\tstruct vchiq_shared_state *local = state->local;\n\n\tDEBUG_INITIALISE(local);\n\n\twhile (1) {\n\t\tDEBUG_COUNT(SLOT_HANDLER_COUNT);\n\t\tDEBUG_TRACE(SLOT_HANDLER_LINE);\n\t\tremote_event_wait(&state->trigger_event, &local->trigger);\n\n\t\t \n\t\trmb();\n\n\t\tDEBUG_TRACE(SLOT_HANDLER_LINE);\n\t\tif (state->poll_needed) {\n\t\t\tstate->poll_needed = 0;\n\n\t\t\t \n\t\t\tif (handle_poll(state) == -EAGAIN)\n\t\t\t\tstate->poll_needed = 1;\n\t\t}\n\n\t\tDEBUG_TRACE(SLOT_HANDLER_LINE);\n\t\tparse_rx_slots(state);\n\t}\n\treturn 0;\n}\n\n \nstatic int\nrecycle_func(void *v)\n{\n\tstruct vchiq_state *state = v;\n\tstruct vchiq_shared_state *local = state->local;\n\tu32 *found;\n\tsize_t length;\n\n\tlength = sizeof(*found) * BITSET_SIZE(VCHIQ_MAX_SERVICES);\n\n\tfound = kmalloc_array(BITSET_SIZE(VCHIQ_MAX_SERVICES), sizeof(*found),\n\t\t\t      GFP_KERNEL);\n\tif (!found)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tremote_event_wait(&state->recycle_event, &local->recycle);\n\n\t\tprocess_free_queue(state, found, length);\n\t}\n\treturn 0;\n}\n\n \nstatic int\nsync_func(void *v)\n{\n\tstruct vchiq_state *state = v;\n\tstruct vchiq_shared_state *local = state->local;\n\tstruct vchiq_header *header =\n\t\t(struct vchiq_header *)SLOT_DATA_FROM_INDEX(state,\n\t\t\tstate->remote->slot_sync);\n\n\twhile (1) {\n\t\tstruct vchiq_service *service;\n\t\tint msgid, size;\n\t\tint type;\n\t\tunsigned int localport, remoteport;\n\n\t\tremote_event_wait(&state->sync_trigger_event, &local->sync_trigger);\n\n\t\t \n\t\trmb();\n\n\t\tmsgid = header->msgid;\n\t\tsize = header->size;\n\t\ttype = VCHIQ_MSG_TYPE(msgid);\n\t\tlocalport = VCHIQ_MSG_DSTPORT(msgid);\n\t\tremoteport = VCHIQ_MSG_SRCPORT(msgid);\n\n\t\tservice = find_service_by_port(state, localport);\n\n\t\tif (!service) {\n\t\t\tvchiq_log_error(vchiq_sync_log_level,\n\t\t\t\t\t\"%d: sf %s@%pK (%d->%d) - invalid/closed service %d\",\n\t\t\t\t\tstate->id, msg_type_str(type), header,\n\t\t\t\t\tremoteport, localport, localport);\n\t\t\trelease_message_sync(state, header);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (vchiq_sync_log_level >= VCHIQ_LOG_TRACE) {\n\t\t\tint svc_fourcc;\n\n\t\t\tsvc_fourcc = service\n\t\t\t\t? service->base.fourcc\n\t\t\t\t: VCHIQ_MAKE_FOURCC('?', '?', '?', '?');\n\t\t\tvchiq_log_trace(vchiq_sync_log_level,\n\t\t\t\t\t\"Rcvd Msg %s from %c%c%c%c s:%d d:%d len:%d\",\n\t\t\t\t\tmsg_type_str(type), VCHIQ_FOURCC_AS_4CHARS(svc_fourcc),\n\t\t\t\t\tremoteport, localport, size);\n\t\t\tif (size > 0)\n\t\t\t\tvchiq_log_dump_mem(\"Rcvd\", 0, header->data, min(16, size));\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase VCHIQ_MSG_OPENACK:\n\t\t\tif (size >= sizeof(struct vchiq_openack_payload)) {\n\t\t\t\tconst struct vchiq_openack_payload *payload =\n\t\t\t\t\t(struct vchiq_openack_payload *)\n\t\t\t\t\theader->data;\n\t\t\t\tservice->peer_version = payload->version;\n\t\t\t}\n\t\t\tvchiq_log_info(vchiq_sync_log_level, \"%d: sf OPENACK@%pK,%x (%d->%d) v:%d\",\n\t\t\t\t       state->id, header, size, remoteport, localport,\n\t\t\t\t       service->peer_version);\n\t\t\tif (service->srvstate == VCHIQ_SRVSTATE_OPENING) {\n\t\t\t\tservice->remoteport = remoteport;\n\t\t\t\tset_service_state(service, VCHIQ_SRVSTATE_OPENSYNC);\n\t\t\t\tservice->sync = 1;\n\t\t\t\tcomplete(&service->remove_event);\n\t\t\t}\n\t\t\trelease_message_sync(state, header);\n\t\t\tbreak;\n\n\t\tcase VCHIQ_MSG_DATA:\n\t\t\tvchiq_log_trace(vchiq_sync_log_level, \"%d: sf DATA@%pK,%x (%d->%d)\",\n\t\t\t\t\tstate->id, header, size, remoteport, localport);\n\n\t\t\tif ((service->remoteport == remoteport) &&\n\t\t\t    (service->srvstate == VCHIQ_SRVSTATE_OPENSYNC)) {\n\t\t\t\tif (make_service_callback(service, VCHIQ_MESSAGE_AVAILABLE, header,\n\t\t\t\t\t\t\t  NULL) == -EAGAIN)\n\t\t\t\t\tvchiq_log_error(vchiq_sync_log_level,\n\t\t\t\t\t\t\t\"synchronous callback to service %d returns -EAGAIN\",\n\t\t\t\t\t\t\tlocalport);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tvchiq_log_error(vchiq_sync_log_level, \"%d: sf unexpected msgid %x@%pK,%x\",\n\t\t\t\t\tstate->id, msgid, header, size);\n\t\t\trelease_message_sync(state, header);\n\t\t\tbreak;\n\t\t}\n\n\t\tvchiq_service_put(service);\n\t}\n\n\treturn 0;\n}\n\ninline const char *\nget_conn_state_name(enum vchiq_connstate conn_state)\n{\n\treturn conn_state_names[conn_state];\n}\n\nstruct vchiq_slot_zero *\nvchiq_init_slots(void *mem_base, int mem_size)\n{\n\tint mem_align =\n\t\t(int)((VCHIQ_SLOT_SIZE - (long)mem_base) & VCHIQ_SLOT_MASK);\n\tstruct vchiq_slot_zero *slot_zero =\n\t\t(struct vchiq_slot_zero *)(mem_base + mem_align);\n\tint num_slots = (mem_size - mem_align) / VCHIQ_SLOT_SIZE;\n\tint first_data_slot = VCHIQ_SLOT_ZERO_SLOTS;\n\n\tcheck_sizes();\n\n\t \n\tnum_slots -= first_data_slot;\n\n\tif (num_slots < 4) {\n\t\tvchiq_log_error(vchiq_core_log_level, \"%s - insufficient memory %x bytes\",\n\t\t\t\t__func__, mem_size);\n\t\treturn NULL;\n\t}\n\n\tmemset(slot_zero, 0, sizeof(struct vchiq_slot_zero));\n\n\tslot_zero->magic = VCHIQ_MAGIC;\n\tslot_zero->version = VCHIQ_VERSION;\n\tslot_zero->version_min = VCHIQ_VERSION_MIN;\n\tslot_zero->slot_zero_size = sizeof(struct vchiq_slot_zero);\n\tslot_zero->slot_size = VCHIQ_SLOT_SIZE;\n\tslot_zero->max_slots = VCHIQ_MAX_SLOTS;\n\tslot_zero->max_slots_per_side = VCHIQ_MAX_SLOTS_PER_SIDE;\n\n\tslot_zero->master.slot_sync = first_data_slot;\n\tslot_zero->master.slot_first = first_data_slot + 1;\n\tslot_zero->master.slot_last = first_data_slot + (num_slots / 2) - 1;\n\tslot_zero->slave.slot_sync = first_data_slot + (num_slots / 2);\n\tslot_zero->slave.slot_first = first_data_slot + (num_slots / 2) + 1;\n\tslot_zero->slave.slot_last = first_data_slot + num_slots - 1;\n\n\treturn slot_zero;\n}\n\nint\nvchiq_init_state(struct vchiq_state *state, struct vchiq_slot_zero *slot_zero, struct device *dev)\n{\n\tstruct vchiq_shared_state *local;\n\tstruct vchiq_shared_state *remote;\n\tchar threadname[16];\n\tint i, ret;\n\n\tlocal = &slot_zero->slave;\n\tremote = &slot_zero->master;\n\n\tif (local->initialised) {\n\t\tvchiq_loud_error_header();\n\t\tif (remote->initialised)\n\t\t\tvchiq_loud_error(\"local state has already been initialised\");\n\t\telse\n\t\t\tvchiq_loud_error(\"master/slave mismatch two slaves\");\n\t\tvchiq_loud_error_footer();\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(state, 0, sizeof(struct vchiq_state));\n\n\tstate->dev = dev;\n\n\t \n\n\tstate->local = local;\n\tstate->remote = remote;\n\tstate->slot_data = (struct vchiq_slot *)slot_zero;\n\n\t \n\n\tinit_completion(&state->connect);\n\tmutex_init(&state->mutex);\n\tmutex_init(&state->slot_mutex);\n\tmutex_init(&state->recycle_mutex);\n\tmutex_init(&state->sync_mutex);\n\tmutex_init(&state->bulk_transfer_mutex);\n\n\tinit_completion(&state->slot_available_event);\n\tinit_completion(&state->slot_remove_event);\n\tinit_completion(&state->data_quota_event);\n\n\tstate->slot_queue_available = 0;\n\n\tfor (i = 0; i < VCHIQ_MAX_SERVICES; i++) {\n\t\tstruct vchiq_service_quota *quota = &state->service_quotas[i];\n\t\tinit_completion(&quota->quota_event);\n\t}\n\n\tfor (i = local->slot_first; i <= local->slot_last; i++) {\n\t\tlocal->slot_queue[state->slot_queue_available] = i;\n\t\tstate->slot_queue_available++;\n\t\tcomplete(&state->slot_available_event);\n\t}\n\n\tstate->default_slot_quota = state->slot_queue_available / 2;\n\tstate->default_message_quota =\n\t\tmin_t(unsigned short, state->default_slot_quota * 256, ~0);\n\n\tstate->previous_data_index = -1;\n\tstate->data_use_count = 0;\n\tstate->data_quota = state->slot_queue_available - 1;\n\n\tremote_event_create(&state->trigger_event, &local->trigger);\n\tlocal->tx_pos = 0;\n\tremote_event_create(&state->recycle_event, &local->recycle);\n\tlocal->slot_queue_recycle = state->slot_queue_available;\n\tremote_event_create(&state->sync_trigger_event, &local->sync_trigger);\n\tremote_event_create(&state->sync_release_event, &local->sync_release);\n\n\t \n\t((struct vchiq_header *)\n\t\tSLOT_DATA_FROM_INDEX(state, local->slot_sync))->msgid =\n\t\t\t\t\t\t\tVCHIQ_MSGID_PADDING;\n\tremote_event_signal_local(&state->sync_release_event, &local->sync_release);\n\n\tlocal->debug[DEBUG_ENTRIES] = DEBUG_MAX;\n\n\tret = vchiq_platform_init_state(state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsnprintf(threadname, sizeof(threadname), \"vchiq-slot/%d\", state->id);\n\tstate->slot_handler_thread = kthread_create(&slot_handler_func, (void *)state, threadname);\n\n\tif (IS_ERR(state->slot_handler_thread)) {\n\t\tvchiq_loud_error_header();\n\t\tvchiq_loud_error(\"couldn't create thread %s\", threadname);\n\t\tvchiq_loud_error_footer();\n\t\treturn PTR_ERR(state->slot_handler_thread);\n\t}\n\tset_user_nice(state->slot_handler_thread, -19);\n\n\tsnprintf(threadname, sizeof(threadname), \"vchiq-recy/%d\", state->id);\n\tstate->recycle_thread = kthread_create(&recycle_func, (void *)state, threadname);\n\tif (IS_ERR(state->recycle_thread)) {\n\t\tvchiq_loud_error_header();\n\t\tvchiq_loud_error(\"couldn't create thread %s\", threadname);\n\t\tvchiq_loud_error_footer();\n\t\tret = PTR_ERR(state->recycle_thread);\n\t\tgoto fail_free_handler_thread;\n\t}\n\tset_user_nice(state->recycle_thread, -19);\n\n\tsnprintf(threadname, sizeof(threadname), \"vchiq-sync/%d\", state->id);\n\tstate->sync_thread = kthread_create(&sync_func, (void *)state, threadname);\n\tif (IS_ERR(state->sync_thread)) {\n\t\tvchiq_loud_error_header();\n\t\tvchiq_loud_error(\"couldn't create thread %s\", threadname);\n\t\tvchiq_loud_error_footer();\n\t\tret = PTR_ERR(state->sync_thread);\n\t\tgoto fail_free_recycle_thread;\n\t}\n\tset_user_nice(state->sync_thread, -20);\n\n\twake_up_process(state->slot_handler_thread);\n\twake_up_process(state->recycle_thread);\n\twake_up_process(state->sync_thread);\n\n\t \n\tlocal->initialised = 1;\n\n\treturn 0;\n\nfail_free_recycle_thread:\n\tkthread_stop(state->recycle_thread);\nfail_free_handler_thread:\n\tkthread_stop(state->slot_handler_thread);\n\n\treturn ret;\n}\n\nvoid vchiq_msg_queue_push(struct vchiq_instance *instance, unsigned int handle,\n\t\t\t  struct vchiq_header *header)\n{\n\tstruct vchiq_service *service = find_service_by_handle(instance, handle);\n\tint pos;\n\n\tif (!service)\n\t\treturn;\n\n\twhile (service->msg_queue_write == service->msg_queue_read +\n\t\tVCHIQ_MAX_SLOTS) {\n\t\tif (wait_for_completion_interruptible(&service->msg_queue_pop))\n\t\t\tflush_signals(current);\n\t}\n\n\tpos = service->msg_queue_write & (VCHIQ_MAX_SLOTS - 1);\n\tservice->msg_queue_write++;\n\tservice->msg_queue[pos] = header;\n\n\tcomplete(&service->msg_queue_push);\n}\nEXPORT_SYMBOL(vchiq_msg_queue_push);\n\nstruct vchiq_header *vchiq_msg_hold(struct vchiq_instance *instance, unsigned int handle)\n{\n\tstruct vchiq_service *service = find_service_by_handle(instance, handle);\n\tstruct vchiq_header *header;\n\tint pos;\n\n\tif (!service)\n\t\treturn NULL;\n\n\tif (service->msg_queue_write == service->msg_queue_read)\n\t\treturn NULL;\n\n\twhile (service->msg_queue_write == service->msg_queue_read) {\n\t\tif (wait_for_completion_interruptible(&service->msg_queue_push))\n\t\t\tflush_signals(current);\n\t}\n\n\tpos = service->msg_queue_read & (VCHIQ_MAX_SLOTS - 1);\n\tservice->msg_queue_read++;\n\theader = service->msg_queue[pos];\n\n\tcomplete(&service->msg_queue_pop);\n\n\treturn header;\n}\nEXPORT_SYMBOL(vchiq_msg_hold);\n\nstatic int vchiq_validate_params(const struct vchiq_service_params_kernel *params)\n{\n\tif (!params->callback || !params->fourcc) {\n\t\tvchiq_loud_error(\"Can't add service, invalid params\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstruct vchiq_service *\nvchiq_add_service_internal(struct vchiq_state *state,\n\t\t\t   const struct vchiq_service_params_kernel *params,\n\t\t\t   int srvstate, struct vchiq_instance *instance,\n\t\t\t   void (*userdata_term)(void *userdata))\n{\n\tstruct vchiq_service *service;\n\tstruct vchiq_service __rcu **pservice = NULL;\n\tstruct vchiq_service_quota *quota;\n\tint ret;\n\tint i;\n\n\tret = vchiq_validate_params(params);\n\tif (ret)\n\t\treturn NULL;\n\n\tservice = kzalloc(sizeof(*service), GFP_KERNEL);\n\tif (!service)\n\t\treturn service;\n\n\tservice->base.fourcc   = params->fourcc;\n\tservice->base.callback = params->callback;\n\tservice->base.userdata = params->userdata;\n\tservice->handle        = VCHIQ_SERVICE_HANDLE_INVALID;\n\tkref_init(&service->ref_count);\n\tservice->srvstate      = VCHIQ_SRVSTATE_FREE;\n\tservice->userdata_term = userdata_term;\n\tservice->localport     = VCHIQ_PORT_FREE;\n\tservice->remoteport    = VCHIQ_PORT_FREE;\n\n\tservice->public_fourcc = (srvstate == VCHIQ_SRVSTATE_OPENING) ?\n\t\tVCHIQ_FOURCC_INVALID : params->fourcc;\n\tservice->auto_close    = 1;\n\tatomic_set(&service->poll_flags, 0);\n\tservice->version       = params->version;\n\tservice->version_min   = params->version_min;\n\tservice->state         = state;\n\tservice->instance      = instance;\n\tinit_completion(&service->remove_event);\n\tinit_completion(&service->bulk_remove_event);\n\tinit_completion(&service->msg_queue_pop);\n\tinit_completion(&service->msg_queue_push);\n\tmutex_init(&service->bulk_mutex);\n\n\t \n\n\tmutex_lock(&state->mutex);\n\n\t \n\tif (state->unused_service < VCHIQ_MAX_SERVICES)\n\t\tpservice = &state->services[state->unused_service];\n\n\tif (srvstate == VCHIQ_SRVSTATE_OPENING) {\n\t\tfor (i = 0; i < state->unused_service; i++) {\n\t\t\tif (!rcu_access_pointer(state->services[i])) {\n\t\t\t\tpservice = &state->services[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trcu_read_lock();\n\t\tfor (i = (state->unused_service - 1); i >= 0; i--) {\n\t\t\tstruct vchiq_service *srv;\n\n\t\t\tsrv = rcu_dereference(state->services[i]);\n\t\t\tif (!srv) {\n\t\t\t\tpservice = &state->services[i];\n\t\t\t} else if ((srv->public_fourcc == params->fourcc) &&\n\t\t\t\t   ((srv->instance != instance) ||\n\t\t\t\t   (srv->base.callback != params->callback))) {\n\t\t\t\t \n\t\t\t\tpservice = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (pservice) {\n\t\tservice->localport = (pservice - state->services);\n\t\tif (!handle_seq)\n\t\t\thandle_seq = VCHIQ_MAX_STATES *\n\t\t\t\t VCHIQ_MAX_SERVICES;\n\t\tservice->handle = handle_seq |\n\t\t\t(state->id * VCHIQ_MAX_SERVICES) |\n\t\t\tservice->localport;\n\t\thandle_seq += VCHIQ_MAX_STATES * VCHIQ_MAX_SERVICES;\n\t\trcu_assign_pointer(*pservice, service);\n\t\tif (pservice == &state->services[state->unused_service])\n\t\t\tstate->unused_service++;\n\t}\n\n\tmutex_unlock(&state->mutex);\n\n\tif (!pservice) {\n\t\tkfree(service);\n\t\treturn NULL;\n\t}\n\n\tquota = &state->service_quotas[service->localport];\n\tquota->slot_quota = state->default_slot_quota;\n\tquota->message_quota = state->default_message_quota;\n\tif (quota->slot_use_count == 0)\n\t\tquota->previous_tx_index =\n\t\t\tSLOT_QUEUE_INDEX_FROM_POS(state->local_tx_pos)\n\t\t\t- 1;\n\n\t \n\tset_service_state(service, srvstate);\n\n\tvchiq_log_info(vchiq_core_msg_log_level, \"%s Service %c%c%c%c SrcPort:%d\",\n\t\t       (srvstate == VCHIQ_SRVSTATE_OPENING) ? \"Open\" : \"Add\",\n\t\t       VCHIQ_FOURCC_AS_4CHARS(params->fourcc), service->localport);\n\n\t \n\n\treturn service;\n}\n\nint\nvchiq_open_service_internal(struct vchiq_service *service, int client_id)\n{\n\tstruct vchiq_open_payload payload = {\n\t\tservice->base.fourcc,\n\t\tclient_id,\n\t\tservice->version,\n\t\tservice->version_min\n\t};\n\tint status = 0;\n\n\tservice->client_id = client_id;\n\tvchiq_use_service_internal(service);\n\tstatus = queue_message(service->state,\n\t\t\t       NULL, MAKE_OPEN(service->localport),\n\t\t\t       memcpy_copy_callback,\n\t\t\t       &payload,\n\t\t\t       sizeof(payload),\n\t\t\t       QMFLAGS_IS_BLOCKING);\n\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (wait_for_completion_interruptible(&service->remove_event)) {\n\t\tstatus = -EAGAIN;\n\t\tvchiq_release_service_internal(service);\n\t} else if ((service->srvstate != VCHIQ_SRVSTATE_OPEN) &&\n\t\t   (service->srvstate != VCHIQ_SRVSTATE_OPENSYNC)) {\n\t\tif (service->srvstate != VCHIQ_SRVSTATE_CLOSEWAIT)\n\t\t\tvchiq_log_error(vchiq_core_log_level,\n\t\t\t\t\t\"%d: osi - srvstate = %s (ref %u)\",\n\t\t\t\t\tservice->state->id,\n\t\t\t\t\tsrvstate_names[service->srvstate],\n\t\t\t\t\tkref_read(&service->ref_count));\n\t\tstatus = -EINVAL;\n\t\tVCHIQ_SERVICE_STATS_INC(service, error_count);\n\t\tvchiq_release_service_internal(service);\n\t}\n\n\treturn status;\n}\n\nstatic void\nrelease_service_messages(struct vchiq_service *service)\n{\n\tstruct vchiq_state *state = service->state;\n\tint slot_last = state->remote->slot_last;\n\tint i;\n\n\t \n\n\tif (service->sync) {\n\t\tstruct vchiq_header *header =\n\t\t\t(struct vchiq_header *)SLOT_DATA_FROM_INDEX(state,\n\t\t\t\t\t\tstate->remote->slot_sync);\n\t\tif (VCHIQ_MSG_DSTPORT(header->msgid) == service->localport)\n\t\t\trelease_message_sync(state, header);\n\n\t\treturn;\n\t}\n\n\tfor (i = state->remote->slot_first; i <= slot_last; i++) {\n\t\tstruct vchiq_slot_info *slot_info =\n\t\t\tSLOT_INFO_FROM_INDEX(state, i);\n\t\tunsigned int pos, end;\n\t\tchar *data;\n\n\t\tif (slot_info->release_count == slot_info->use_count)\n\t\t\tcontinue;\n\n\t\tdata = (char *)SLOT_DATA_FROM_INDEX(state, i);\n\t\tend = VCHIQ_SLOT_SIZE;\n\t\tif (data == state->rx_data)\n\t\t\t \n\t\t\tend = state->rx_pos & VCHIQ_SLOT_MASK;\n\n\t\tpos = 0;\n\n\t\twhile (pos < end) {\n\t\t\tstruct vchiq_header *header =\n\t\t\t\t(struct vchiq_header *)(data + pos);\n\t\t\tint msgid = header->msgid;\n\t\t\tint port = VCHIQ_MSG_DSTPORT(msgid);\n\n\t\t\tif ((port == service->localport) && (msgid & VCHIQ_MSGID_CLAIMED)) {\n\t\t\t\tvchiq_log_info(vchiq_core_log_level, \"  fsi - hdr %pK\", header);\n\t\t\t\trelease_slot(state, slot_info, header, NULL);\n\t\t\t}\n\t\t\tpos += calc_stride(header->size);\n\t\t\tif (pos > VCHIQ_SLOT_SIZE) {\n\t\t\t\tvchiq_log_error(vchiq_core_log_level,\n\t\t\t\t\t\t\"fsi - pos %x: header %pK, msgid %x, header->msgid %x, header->size %x\",\n\t\t\t\t\t\tpos, header, msgid, header->msgid, header->size);\n\t\t\t\tWARN(1, \"invalid slot position\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int\ndo_abort_bulks(struct vchiq_service *service)\n{\n\tint status;\n\n\t \n\tif (mutex_lock_killable(&service->bulk_mutex))\n\t\treturn 0;\n\tabort_outstanding_bulks(service, &service->bulk_tx);\n\tabort_outstanding_bulks(service, &service->bulk_rx);\n\tmutex_unlock(&service->bulk_mutex);\n\n\tstatus = notify_bulks(service, &service->bulk_tx, NO_RETRY_POLL);\n\tif (status)\n\t\treturn 0;\n\n\tstatus = notify_bulks(service, &service->bulk_rx, NO_RETRY_POLL);\n\treturn !status;\n}\n\nstatic int\nclose_service_complete(struct vchiq_service *service, int failstate)\n{\n\tint status;\n\tint is_server = (service->public_fourcc != VCHIQ_FOURCC_INVALID);\n\tint newstate;\n\n\tswitch (service->srvstate) {\n\tcase VCHIQ_SRVSTATE_OPEN:\n\tcase VCHIQ_SRVSTATE_CLOSESENT:\n\tcase VCHIQ_SRVSTATE_CLOSERECVD:\n\t\tif (is_server) {\n\t\t\tif (service->auto_close) {\n\t\t\t\tservice->client_id = 0;\n\t\t\t\tservice->remoteport = VCHIQ_PORT_FREE;\n\t\t\t\tnewstate = VCHIQ_SRVSTATE_LISTENING;\n\t\t\t} else {\n\t\t\t\tnewstate = VCHIQ_SRVSTATE_CLOSEWAIT;\n\t\t\t}\n\t\t} else {\n\t\t\tnewstate = VCHIQ_SRVSTATE_CLOSED;\n\t\t}\n\t\tset_service_state(service, newstate);\n\t\tbreak;\n\tcase VCHIQ_SRVSTATE_LISTENING:\n\t\tbreak;\n\tdefault:\n\t\tvchiq_log_error(vchiq_core_log_level, \"%s(%x) called in state %s\", __func__,\n\t\t\t\tservice->handle, srvstate_names[service->srvstate]);\n\t\tWARN(1, \"%s in unexpected state\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = make_service_callback(service, VCHIQ_SERVICE_CLOSED, NULL, NULL);\n\n\tif (status != -EAGAIN) {\n\t\tint uc = service->service_use_count;\n\t\tint i;\n\t\t \n\t\tfor (i = 0; i < uc; i++)\n\t\t\t \n\t\t\tvchiq_release_service_internal(service);\n\n\t\tservice->client_id = 0;\n\t\tservice->remoteport = VCHIQ_PORT_FREE;\n\n\t\tif (service->srvstate == VCHIQ_SRVSTATE_CLOSED) {\n\t\t\tvchiq_free_service_internal(service);\n\t\t} else if (service->srvstate != VCHIQ_SRVSTATE_CLOSEWAIT) {\n\t\t\tif (is_server)\n\t\t\t\tservice->closing = 0;\n\n\t\t\tcomplete(&service->remove_event);\n\t\t}\n\t} else {\n\t\tset_service_state(service, failstate);\n\t}\n\n\treturn status;\n}\n\n \nint\nvchiq_close_service_internal(struct vchiq_service *service, int close_recvd)\n{\n\tstruct vchiq_state *state = service->state;\n\tint status = 0;\n\tint is_server = (service->public_fourcc != VCHIQ_FOURCC_INVALID);\n\tint close_id = MAKE_CLOSE(service->localport,\n\t\t\t\t  VCHIQ_MSG_DSTPORT(service->remoteport));\n\n\tvchiq_log_info(vchiq_core_log_level, \"%d: csi:%d,%d (%s)\", service->state->id,\n\t\t       service->localport, close_recvd, srvstate_names[service->srvstate]);\n\n\tswitch (service->srvstate) {\n\tcase VCHIQ_SRVSTATE_CLOSED:\n\tcase VCHIQ_SRVSTATE_HIDDEN:\n\tcase VCHIQ_SRVSTATE_LISTENING:\n\tcase VCHIQ_SRVSTATE_CLOSEWAIT:\n\t\tif (close_recvd) {\n\t\t\tvchiq_log_error(vchiq_core_log_level, \"%s(1) called in state %s\",\n\t\t\t\t\t__func__, srvstate_names[service->srvstate]);\n\t\t} else if (is_server) {\n\t\t\tif (service->srvstate == VCHIQ_SRVSTATE_LISTENING) {\n\t\t\t\tstatus = -EINVAL;\n\t\t\t} else {\n\t\t\t\tservice->client_id = 0;\n\t\t\t\tservice->remoteport = VCHIQ_PORT_FREE;\n\t\t\t\tif (service->srvstate == VCHIQ_SRVSTATE_CLOSEWAIT)\n\t\t\t\t\tset_service_state(service, VCHIQ_SRVSTATE_LISTENING);\n\t\t\t}\n\t\t\tcomplete(&service->remove_event);\n\t\t} else {\n\t\t\tvchiq_free_service_internal(service);\n\t\t}\n\t\tbreak;\n\tcase VCHIQ_SRVSTATE_OPENING:\n\t\tif (close_recvd) {\n\t\t\t \n\t\t\tset_service_state(service, VCHIQ_SRVSTATE_CLOSEWAIT);\n\t\t\tcomplete(&service->remove_event);\n\t\t} else {\n\t\t\t \n\t\t\tstatus = queue_message(state, service, close_id, NULL, NULL, 0, 0);\n\t\t}\n\t\tbreak;\n\n\tcase VCHIQ_SRVSTATE_OPENSYNC:\n\t\tmutex_lock(&state->sync_mutex);\n\t\tfallthrough;\n\tcase VCHIQ_SRVSTATE_OPEN:\n\t\tif (close_recvd) {\n\t\t\tif (!do_abort_bulks(service))\n\t\t\t\tstatus = -EAGAIN;\n\t\t}\n\n\t\trelease_service_messages(service);\n\n\t\tif (!status)\n\t\t\tstatus = queue_message(state, service, close_id, NULL,\n\t\t\t\t\t       NULL, 0, QMFLAGS_NO_MUTEX_UNLOCK);\n\n\t\tif (status) {\n\t\t\tif (service->srvstate == VCHIQ_SRVSTATE_OPENSYNC)\n\t\t\t\tmutex_unlock(&state->sync_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!close_recvd) {\n\t\t\t \n\t\t\tset_service_state(service, VCHIQ_SRVSTATE_CLOSESENT);\n\t\t\tmutex_unlock(&state->slot_mutex);\n\t\t\tif (service->sync)\n\t\t\t\tmutex_unlock(&state->sync_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tset_service_state(service, VCHIQ_SRVSTATE_CLOSERECVD);\n\t\tmutex_unlock(&state->slot_mutex);\n\t\tif (service->sync)\n\t\t\tmutex_unlock(&state->sync_mutex);\n\n\t\tstatus = close_service_complete(service, VCHIQ_SRVSTATE_CLOSERECVD);\n\t\tbreak;\n\n\tcase VCHIQ_SRVSTATE_CLOSESENT:\n\t\tif (!close_recvd)\n\t\t\t \n\t\t\tbreak;\n\n\t\tif (!do_abort_bulks(service)) {\n\t\t\tstatus = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!status)\n\t\t\tstatus = close_service_complete(service, VCHIQ_SRVSTATE_CLOSERECVD);\n\t\tbreak;\n\n\tcase VCHIQ_SRVSTATE_CLOSERECVD:\n\t\tif (!close_recvd && is_server)\n\t\t\t \n\t\t\tset_service_state(service, VCHIQ_SRVSTATE_LISTENING);\n\t\tstatus = close_service_complete(service, VCHIQ_SRVSTATE_CLOSERECVD);\n\t\tbreak;\n\n\tdefault:\n\t\tvchiq_log_error(vchiq_core_log_level, \"%s(%d) called in state %s\", __func__,\n\t\t\t\tclose_recvd, srvstate_names[service->srvstate]);\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nvoid\nvchiq_terminate_service_internal(struct vchiq_service *service)\n{\n\tstruct vchiq_state *state = service->state;\n\n\tvchiq_log_info(vchiq_core_log_level, \"%d: tsi - (%d<->%d)\", state->id,\n\t\t       service->localport, service->remoteport);\n\n\tmark_service_closing(service);\n\n\t \n\trequest_poll(state, service, VCHIQ_POLL_REMOVE);\n}\n\n \nvoid\nvchiq_free_service_internal(struct vchiq_service *service)\n{\n\tstruct vchiq_state *state = service->state;\n\n\tvchiq_log_info(vchiq_core_log_level, \"%d: fsi - (%d)\", state->id, service->localport);\n\n\tswitch (service->srvstate) {\n\tcase VCHIQ_SRVSTATE_OPENING:\n\tcase VCHIQ_SRVSTATE_CLOSED:\n\tcase VCHIQ_SRVSTATE_HIDDEN:\n\tcase VCHIQ_SRVSTATE_LISTENING:\n\tcase VCHIQ_SRVSTATE_CLOSEWAIT:\n\t\tbreak;\n\tdefault:\n\t\tvchiq_log_error(vchiq_core_log_level, \"%d: fsi - (%d) in state %s\", state->id,\n\t\t\t\tservice->localport, srvstate_names[service->srvstate]);\n\t\treturn;\n\t}\n\n\tset_service_state(service, VCHIQ_SRVSTATE_FREE);\n\n\tcomplete(&service->remove_event);\n\n\t \n\tvchiq_service_put(service);\n}\n\nint\nvchiq_connect_internal(struct vchiq_state *state, struct vchiq_instance *instance)\n{\n\tstruct vchiq_service *service;\n\tint i;\n\n\t \n\ti = 0;\n\twhile ((service = next_service_by_instance(state, instance, &i)) != NULL) {\n\t\tif (service->srvstate == VCHIQ_SRVSTATE_HIDDEN)\n\t\t\tset_service_state(service, VCHIQ_SRVSTATE_LISTENING);\n\t\tvchiq_service_put(service);\n\t}\n\n\tif (state->conn_state == VCHIQ_CONNSTATE_DISCONNECTED) {\n\t\tif (queue_message(state, NULL, MAKE_CONNECT, NULL, NULL, 0,\n\t\t\t\t  QMFLAGS_IS_BLOCKING) == -EAGAIN)\n\t\t\treturn -EAGAIN;\n\n\t\tvchiq_set_conn_state(state, VCHIQ_CONNSTATE_CONNECTING);\n\t}\n\n\tif (state->conn_state == VCHIQ_CONNSTATE_CONNECTING) {\n\t\tif (wait_for_completion_interruptible(&state->connect))\n\t\t\treturn -EAGAIN;\n\n\t\tvchiq_set_conn_state(state, VCHIQ_CONNSTATE_CONNECTED);\n\t\tcomplete(&state->connect);\n\t}\n\n\treturn 0;\n}\n\nvoid\nvchiq_shutdown_internal(struct vchiq_state *state, struct vchiq_instance *instance)\n{\n\tstruct vchiq_service *service;\n\tint i;\n\n\t \n\ti = 0;\n\twhile ((service = next_service_by_instance(state, instance, &i)) != NULL) {\n\t\t(void)vchiq_remove_service(instance, service->handle);\n\t\tvchiq_service_put(service);\n\t}\n}\n\nint\nvchiq_close_service(struct vchiq_instance *instance, unsigned int handle)\n{\n\t \n\tstruct vchiq_service *service = find_service_by_handle(instance, handle);\n\tint status = 0;\n\n\tif (!service)\n\t\treturn -EINVAL;\n\n\tvchiq_log_info(vchiq_core_log_level, \"%d: close_service:%d\",\n\t\t       service->state->id, service->localport);\n\n\tif ((service->srvstate == VCHIQ_SRVSTATE_FREE) ||\n\t    (service->srvstate == VCHIQ_SRVSTATE_LISTENING) ||\n\t    (service->srvstate == VCHIQ_SRVSTATE_HIDDEN)) {\n\t\tvchiq_service_put(service);\n\t\treturn -EINVAL;\n\t}\n\n\tmark_service_closing(service);\n\n\tif (current == service->state->slot_handler_thread) {\n\t\tstatus = vchiq_close_service_internal(service, NO_CLOSE_RECVD);\n\t\tWARN_ON(status == -EAGAIN);\n\t} else {\n\t\t \n\t\trequest_poll(service->state, service, VCHIQ_POLL_TERMINATE);\n\t}\n\n\twhile (1) {\n\t\tif (wait_for_completion_interruptible(&service->remove_event)) {\n\t\t\tstatus = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((service->srvstate == VCHIQ_SRVSTATE_FREE) ||\n\t\t    (service->srvstate == VCHIQ_SRVSTATE_LISTENING) ||\n\t\t    (service->srvstate == VCHIQ_SRVSTATE_OPEN))\n\t\t\tbreak;\n\n\t\tvchiq_log_warning(vchiq_core_log_level,\n\t\t\t\t  \"%d: close_service:%d - waiting in state %s\",\n\t\t\t\t  service->state->id, service->localport,\n\t\t\t\t  srvstate_names[service->srvstate]);\n\t}\n\n\tif (!status &&\n\t    (service->srvstate != VCHIQ_SRVSTATE_FREE) &&\n\t    (service->srvstate != VCHIQ_SRVSTATE_LISTENING))\n\t\tstatus = -EINVAL;\n\n\tvchiq_service_put(service);\n\n\treturn status;\n}\nEXPORT_SYMBOL(vchiq_close_service);\n\nint\nvchiq_remove_service(struct vchiq_instance *instance, unsigned int handle)\n{\n\t \n\tstruct vchiq_service *service = find_service_by_handle(instance, handle);\n\tint status = 0;\n\n\tif (!service)\n\t\treturn -EINVAL;\n\n\tvchiq_log_info(vchiq_core_log_level, \"%d: remove_service:%d\",\n\t\t       service->state->id, service->localport);\n\n\tif (service->srvstate == VCHIQ_SRVSTATE_FREE) {\n\t\tvchiq_service_put(service);\n\t\treturn -EINVAL;\n\t}\n\n\tmark_service_closing(service);\n\n\tif ((service->srvstate == VCHIQ_SRVSTATE_HIDDEN) ||\n\t    (current == service->state->slot_handler_thread)) {\n\t\t \n\t\tservice->public_fourcc = VCHIQ_FOURCC_INVALID;\n\n\t\tstatus = vchiq_close_service_internal(service, NO_CLOSE_RECVD);\n\t\tWARN_ON(status == -EAGAIN);\n\t} else {\n\t\t \n\t\trequest_poll(service->state, service, VCHIQ_POLL_REMOVE);\n\t}\n\twhile (1) {\n\t\tif (wait_for_completion_interruptible(&service->remove_event)) {\n\t\t\tstatus = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((service->srvstate == VCHIQ_SRVSTATE_FREE) ||\n\t\t    (service->srvstate == VCHIQ_SRVSTATE_OPEN))\n\t\t\tbreak;\n\n\t\tvchiq_log_warning(vchiq_core_log_level,\n\t\t\t\t  \"%d: remove_service:%d - waiting in state %s\",\n\t\t\t\t  service->state->id, service->localport,\n\t\t\t\t  srvstate_names[service->srvstate]);\n\t}\n\n\tif (!status && (service->srvstate != VCHIQ_SRVSTATE_FREE))\n\t\tstatus = -EINVAL;\n\n\tvchiq_service_put(service);\n\n\treturn status;\n}\n\n \nint vchiq_bulk_transfer(struct vchiq_instance *instance, unsigned int handle,\n\t\t\tvoid *offset, void __user *uoffset, int size, void *userdata,\n\t\t\tenum vchiq_bulk_mode mode, enum vchiq_bulk_dir dir)\n{\n\tstruct vchiq_service *service = find_service_by_handle(instance, handle);\n\tstruct vchiq_bulk_queue *queue;\n\tstruct vchiq_bulk *bulk;\n\tstruct vchiq_state *state;\n\tstruct bulk_waiter *bulk_waiter = NULL;\n\tconst char dir_char = (dir == VCHIQ_BULK_TRANSMIT) ? 't' : 'r';\n\tconst int dir_msgtype = (dir == VCHIQ_BULK_TRANSMIT) ?\n\t\tVCHIQ_MSG_BULK_TX : VCHIQ_MSG_BULK_RX;\n\tint status = -EINVAL;\n\tint payload[2];\n\n\tif (!service)\n\t\tgoto error_exit;\n\n\tif (service->srvstate != VCHIQ_SRVSTATE_OPEN)\n\t\tgoto error_exit;\n\n\tif (!offset && !uoffset)\n\t\tgoto error_exit;\n\n\tif (vchiq_check_service(service))\n\t\tgoto error_exit;\n\n\tswitch (mode) {\n\tcase VCHIQ_BULK_MODE_NOCALLBACK:\n\tcase VCHIQ_BULK_MODE_CALLBACK:\n\t\tbreak;\n\tcase VCHIQ_BULK_MODE_BLOCKING:\n\t\tbulk_waiter = userdata;\n\t\tinit_completion(&bulk_waiter->event);\n\t\tbulk_waiter->actual = 0;\n\t\tbulk_waiter->bulk = NULL;\n\t\tbreak;\n\tcase VCHIQ_BULK_MODE_WAITING:\n\t\tbulk_waiter = userdata;\n\t\tbulk = bulk_waiter->bulk;\n\t\tgoto waiting;\n\tdefault:\n\t\tgoto error_exit;\n\t}\n\n\tstate = service->state;\n\n\tqueue = (dir == VCHIQ_BULK_TRANSMIT) ?\n\t\t&service->bulk_tx : &service->bulk_rx;\n\n\tif (mutex_lock_killable(&service->bulk_mutex)) {\n\t\tstatus = -EAGAIN;\n\t\tgoto error_exit;\n\t}\n\n\tif (queue->local_insert == queue->remove + VCHIQ_NUM_SERVICE_BULKS) {\n\t\tVCHIQ_SERVICE_STATS_INC(service, bulk_stalls);\n\t\tdo {\n\t\t\tmutex_unlock(&service->bulk_mutex);\n\t\t\tif (wait_for_completion_interruptible(&service->bulk_remove_event)) {\n\t\t\t\tstatus = -EAGAIN;\n\t\t\t\tgoto error_exit;\n\t\t\t}\n\t\t\tif (mutex_lock_killable(&service->bulk_mutex)) {\n\t\t\t\tstatus = -EAGAIN;\n\t\t\t\tgoto error_exit;\n\t\t\t}\n\t\t} while (queue->local_insert == queue->remove +\n\t\t\t\tVCHIQ_NUM_SERVICE_BULKS);\n\t}\n\n\tbulk = &queue->bulks[BULK_INDEX(queue->local_insert)];\n\n\tbulk->mode = mode;\n\tbulk->dir = dir;\n\tbulk->userdata = userdata;\n\tbulk->size = size;\n\tbulk->actual = VCHIQ_BULK_ACTUAL_ABORTED;\n\n\tif (vchiq_prepare_bulk_data(instance, bulk, offset, uoffset, size, dir))\n\t\tgoto unlock_error_exit;\n\n\t \n\twmb();\n\n\tvchiq_log_info(vchiq_core_log_level, \"%d: bt (%d->%d) %cx %x@%pad %pK\",\n\t\t       state->id, service->localport, service->remoteport,\n\t\t       dir_char, size, &bulk->data, userdata);\n\n\t \n\tif (mutex_lock_killable(&state->slot_mutex)) {\n\t\tstatus = -EAGAIN;\n\t\tgoto cancel_bulk_error_exit;\n\t}\n\n\tif (service->srvstate != VCHIQ_SRVSTATE_OPEN)\n\t\tgoto unlock_both_error_exit;\n\n\tpayload[0] = lower_32_bits(bulk->data);\n\tpayload[1] = bulk->size;\n\tstatus = queue_message(state,\n\t\t\t       NULL,\n\t\t\t       VCHIQ_MAKE_MSG(dir_msgtype,\n\t\t\t\t\t      service->localport,\n\t\t\t\t\t      service->remoteport),\n\t\t\t       memcpy_copy_callback,\n\t\t\t       &payload,\n\t\t\t       sizeof(payload),\n\t\t\t       QMFLAGS_IS_BLOCKING |\n\t\t\t       QMFLAGS_NO_MUTEX_LOCK |\n\t\t\t       QMFLAGS_NO_MUTEX_UNLOCK);\n\tif (status)\n\t\tgoto unlock_both_error_exit;\n\n\tqueue->local_insert++;\n\n\tmutex_unlock(&state->slot_mutex);\n\tmutex_unlock(&service->bulk_mutex);\n\n\tvchiq_log_trace(vchiq_core_log_level, \"%d: bt:%d %cx li=%x ri=%x p=%x\",\n\t\t\tstate->id, service->localport, dir_char, queue->local_insert,\n\t\t\tqueue->remote_insert, queue->process);\n\nwaiting:\n\tvchiq_service_put(service);\n\n\tstatus = 0;\n\n\tif (bulk_waiter) {\n\t\tbulk_waiter->bulk = bulk;\n\t\tif (wait_for_completion_interruptible(&bulk_waiter->event))\n\t\t\tstatus = -EAGAIN;\n\t\telse if (bulk_waiter->actual == VCHIQ_BULK_ACTUAL_ABORTED)\n\t\t\tstatus = -EINVAL;\n\t}\n\n\treturn status;\n\nunlock_both_error_exit:\n\tmutex_unlock(&state->slot_mutex);\ncancel_bulk_error_exit:\n\tvchiq_complete_bulk(service->instance, bulk);\nunlock_error_exit:\n\tmutex_unlock(&service->bulk_mutex);\n\nerror_exit:\n\tif (service)\n\t\tvchiq_service_put(service);\n\treturn status;\n}\n\nint\nvchiq_queue_message(struct vchiq_instance *instance, unsigned int handle,\n\t\t    ssize_t (*copy_callback)(void *context, void *dest,\n\t\t\t\t\t     size_t offset, size_t maxsize),\n\t\t    void *context,\n\t\t    size_t size)\n{\n\tstruct vchiq_service *service = find_service_by_handle(instance, handle);\n\tint status = -EINVAL;\n\tint data_id;\n\n\tif (!service)\n\t\tgoto error_exit;\n\n\tif (vchiq_check_service(service))\n\t\tgoto error_exit;\n\n\tif (!size) {\n\t\tVCHIQ_SERVICE_STATS_INC(service, error_count);\n\t\tgoto error_exit;\n\t}\n\n\tif (size > VCHIQ_MAX_MSG_SIZE) {\n\t\tVCHIQ_SERVICE_STATS_INC(service, error_count);\n\t\tgoto error_exit;\n\t}\n\n\tdata_id = MAKE_DATA(service->localport, service->remoteport);\n\n\tswitch (service->srvstate) {\n\tcase VCHIQ_SRVSTATE_OPEN:\n\t\tstatus = queue_message(service->state, service, data_id,\n\t\t\t\t       copy_callback, context, size, 1);\n\t\tbreak;\n\tcase VCHIQ_SRVSTATE_OPENSYNC:\n\t\tstatus = queue_message_sync(service->state, service, data_id,\n\t\t\t\t\t    copy_callback, context, size, 1);\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tbreak;\n\t}\n\nerror_exit:\n\tif (service)\n\t\tvchiq_service_put(service);\n\n\treturn status;\n}\n\nint vchiq_queue_kernel_message(struct vchiq_instance *instance, unsigned int handle, void *data,\n\t\t\t       unsigned int size)\n{\n\tint status;\n\n\twhile (1) {\n\t\tstatus = vchiq_queue_message(instance, handle, memcpy_copy_callback,\n\t\t\t\t\t     data, size);\n\n\t\t \n\t\tif (status != -EAGAIN)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t}\n\n\treturn status;\n}\nEXPORT_SYMBOL(vchiq_queue_kernel_message);\n\nvoid\nvchiq_release_message(struct vchiq_instance *instance, unsigned int handle,\n\t\t      struct vchiq_header *header)\n{\n\tstruct vchiq_service *service = find_service_by_handle(instance, handle);\n\tstruct vchiq_shared_state *remote;\n\tstruct vchiq_state *state;\n\tint slot_index;\n\n\tif (!service)\n\t\treturn;\n\n\tstate = service->state;\n\tremote = state->remote;\n\n\tslot_index = SLOT_INDEX_FROM_DATA(state, (void *)header);\n\n\tif ((slot_index >= remote->slot_first) &&\n\t    (slot_index <= remote->slot_last)) {\n\t\tint msgid = header->msgid;\n\n\t\tif (msgid & VCHIQ_MSGID_CLAIMED) {\n\t\t\tstruct vchiq_slot_info *slot_info =\n\t\t\t\tSLOT_INFO_FROM_INDEX(state, slot_index);\n\n\t\t\trelease_slot(state, slot_info, header, service);\n\t\t}\n\t} else if (slot_index == remote->slot_sync) {\n\t\trelease_message_sync(state, header);\n\t}\n\n\tvchiq_service_put(service);\n}\nEXPORT_SYMBOL(vchiq_release_message);\n\nstatic void\nrelease_message_sync(struct vchiq_state *state, struct vchiq_header *header)\n{\n\theader->msgid = VCHIQ_MSGID_PADDING;\n\tremote_event_signal(&state->remote->sync_release);\n}\n\nint\nvchiq_get_peer_version(struct vchiq_instance *instance, unsigned int handle, short *peer_version)\n{\n\tint status = -EINVAL;\n\tstruct vchiq_service *service = find_service_by_handle(instance, handle);\n\n\tif (!service)\n\t\tgoto exit;\n\n\tif (vchiq_check_service(service))\n\t\tgoto exit;\n\n\tif (!peer_version)\n\t\tgoto exit;\n\n\t*peer_version = service->peer_version;\n\tstatus = 0;\n\nexit:\n\tif (service)\n\t\tvchiq_service_put(service);\n\treturn status;\n}\nEXPORT_SYMBOL(vchiq_get_peer_version);\n\nvoid vchiq_get_config(struct vchiq_config *config)\n{\n\tconfig->max_msg_size           = VCHIQ_MAX_MSG_SIZE;\n\tconfig->bulk_threshold         = VCHIQ_MAX_MSG_SIZE;\n\tconfig->max_outstanding_bulks  = VCHIQ_NUM_SERVICE_BULKS;\n\tconfig->max_services           = VCHIQ_MAX_SERVICES;\n\tconfig->version                = VCHIQ_VERSION;\n\tconfig->version_min            = VCHIQ_VERSION_MIN;\n}\n\nint\nvchiq_set_service_option(struct vchiq_instance *instance, unsigned int handle,\n\t\t\t enum vchiq_service_option option, int value)\n{\n\tstruct vchiq_service *service = find_service_by_handle(instance, handle);\n\tstruct vchiq_service_quota *quota;\n\tint ret = -EINVAL;\n\n\tif (!service)\n\t\treturn -EINVAL;\n\n\tswitch (option) {\n\tcase VCHIQ_SERVICE_OPTION_AUTOCLOSE:\n\t\tservice->auto_close = value;\n\t\tret = 0;\n\t\tbreak;\n\n\tcase VCHIQ_SERVICE_OPTION_SLOT_QUOTA:\n\t\tquota = &service->state->service_quotas[service->localport];\n\t\tif (value == 0)\n\t\t\tvalue = service->state->default_slot_quota;\n\t\tif ((value >= quota->slot_use_count) &&\n\t\t    (value < (unsigned short)~0)) {\n\t\t\tquota->slot_quota = value;\n\t\t\tif ((value >= quota->slot_use_count) &&\n\t\t\t    (quota->message_quota >= quota->message_use_count))\n\t\t\t\t \n\t\t\t\tcomplete(&quota->quota_event);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase VCHIQ_SERVICE_OPTION_MESSAGE_QUOTA:\n\t\tquota = &service->state->service_quotas[service->localport];\n\t\tif (value == 0)\n\t\t\tvalue = service->state->default_message_quota;\n\t\tif ((value >= quota->message_use_count) &&\n\t\t    (value < (unsigned short)~0)) {\n\t\t\tquota->message_quota = value;\n\t\t\tif ((value >= quota->message_use_count) &&\n\t\t\t    (quota->slot_quota >= quota->slot_use_count))\n\t\t\t\t \n\t\t\t\tcomplete(&quota->quota_event);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase VCHIQ_SERVICE_OPTION_SYNCHRONOUS:\n\t\tif ((service->srvstate == VCHIQ_SRVSTATE_HIDDEN) ||\n\t\t    (service->srvstate == VCHIQ_SRVSTATE_LISTENING)) {\n\t\t\tservice->sync = value;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase VCHIQ_SERVICE_OPTION_TRACE:\n\t\tservice->trace = value;\n\t\tret = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tvchiq_service_put(service);\n\n\treturn ret;\n}\n\nstatic int\nvchiq_dump_shared_state(void *dump_context, struct vchiq_state *state,\n\t\t\tstruct vchiq_shared_state *shared, const char *label)\n{\n\tstatic const char *const debug_names[] = {\n\t\t\"<entries>\",\n\t\t\"SLOT_HANDLER_COUNT\",\n\t\t\"SLOT_HANDLER_LINE\",\n\t\t\"PARSE_LINE\",\n\t\t\"PARSE_HEADER\",\n\t\t\"PARSE_MSGID\",\n\t\t\"AWAIT_COMPLETION_LINE\",\n\t\t\"DEQUEUE_MESSAGE_LINE\",\n\t\t\"SERVICE_CALLBACK_LINE\",\n\t\t\"MSG_QUEUE_FULL_COUNT\",\n\t\t\"COMPLETION_QUEUE_FULL_COUNT\"\n\t};\n\tint i;\n\tchar buf[80];\n\tint len;\n\tint err;\n\n\tlen = scnprintf(buf, sizeof(buf), \"  %s: slots %d-%d tx_pos=%x recycle=%x\",\n\t\t\tlabel, shared->slot_first, shared->slot_last,\n\t\t\tshared->tx_pos, shared->slot_queue_recycle);\n\terr = vchiq_dump(dump_context, buf, len + 1);\n\tif (err)\n\t\treturn err;\n\n\tlen = scnprintf(buf, sizeof(buf), \"    Slots claimed:\");\n\terr = vchiq_dump(dump_context, buf, len + 1);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = shared->slot_first; i <= shared->slot_last; i++) {\n\t\tstruct vchiq_slot_info slot_info =\n\t\t\t\t\t\t*SLOT_INFO_FROM_INDEX(state, i);\n\t\tif (slot_info.use_count != slot_info.release_count) {\n\t\t\tlen = scnprintf(buf, sizeof(buf), \"      %d: %d/%d\", i, slot_info.use_count,\n\t\t\t\t\tslot_info.release_count);\n\t\t\terr = vchiq_dump(dump_context, buf, len + 1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tfor (i = 1; i < shared->debug[DEBUG_ENTRIES]; i++) {\n\t\tlen = scnprintf(buf, sizeof(buf), \"    DEBUG: %s = %d(%x)\",\n\t\t\t\tdebug_names[i], shared->debug[i], shared->debug[i]);\n\t\terr = vchiq_dump(dump_context, buf, len + 1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nint vchiq_dump_state(void *dump_context, struct vchiq_state *state)\n{\n\tchar buf[80];\n\tint len;\n\tint i;\n\tint err;\n\n\tlen = scnprintf(buf, sizeof(buf), \"State %d: %s\", state->id,\n\t\t\tconn_state_names[state->conn_state]);\n\terr = vchiq_dump(dump_context, buf, len + 1);\n\tif (err)\n\t\treturn err;\n\n\tlen = scnprintf(buf, sizeof(buf), \"  tx_pos=%x(@%pK), rx_pos=%x(@%pK)\",\n\t\t\tstate->local->tx_pos,\n\t\t\tstate->tx_data + (state->local_tx_pos & VCHIQ_SLOT_MASK),\n\t\t\tstate->rx_pos,\n\t\t\tstate->rx_data + (state->rx_pos & VCHIQ_SLOT_MASK));\n\terr = vchiq_dump(dump_context, buf, len + 1);\n\tif (err)\n\t\treturn err;\n\n\tlen = scnprintf(buf, sizeof(buf), \"  Version: %d (min %d)\",\n\t\t\tVCHIQ_VERSION, VCHIQ_VERSION_MIN);\n\terr = vchiq_dump(dump_context, buf, len + 1);\n\tif (err)\n\t\treturn err;\n\n\tif (VCHIQ_ENABLE_STATS) {\n\t\tlen = scnprintf(buf, sizeof(buf),\n\t\t\t\t\"  Stats: ctrl_tx_count=%d, ctrl_rx_count=%d, error_count=%d\",\n\t\t\t\tstate->stats.ctrl_tx_count, state->stats.ctrl_rx_count,\n\t\t\t\tstate->stats.error_count);\n\t\terr = vchiq_dump(dump_context, buf, len + 1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tlen = scnprintf(buf, sizeof(buf),\n\t\t\t\"  Slots: %d available (%d data), %d recyclable, %d stalls (%d data)\",\n\t\t\t((state->slot_queue_available * VCHIQ_SLOT_SIZE) -\n\t\t\tstate->local_tx_pos) / VCHIQ_SLOT_SIZE,\n\t\t\tstate->data_quota - state->data_use_count,\n\t\t\tstate->local->slot_queue_recycle - state->slot_queue_available,\n\t\t\tstate->stats.slot_stalls, state->stats.data_stalls);\n\terr = vchiq_dump(dump_context, buf, len + 1);\n\tif (err)\n\t\treturn err;\n\n\terr = vchiq_dump_platform_state(dump_context);\n\tif (err)\n\t\treturn err;\n\n\terr = vchiq_dump_shared_state(dump_context,\n\t\t\t\t      state,\n\t\t\t\t      state->local,\n\t\t\t\t      \"Local\");\n\tif (err)\n\t\treturn err;\n\terr = vchiq_dump_shared_state(dump_context,\n\t\t\t\t      state,\n\t\t\t\t      state->remote,\n\t\t\t\t      \"Remote\");\n\tif (err)\n\t\treturn err;\n\n\terr = vchiq_dump_platform_instances(dump_context);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < state->unused_service; i++) {\n\t\tstruct vchiq_service *service = find_service_by_port(state, i);\n\n\t\tif (service) {\n\t\t\terr = vchiq_dump_service_state(dump_context, service);\n\t\t\tvchiq_service_put(service);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint vchiq_dump_service_state(void *dump_context, struct vchiq_service *service)\n{\n\tchar buf[80];\n\tint len;\n\tint err;\n\tunsigned int ref_count;\n\n\t \n\tref_count = kref_read(&service->ref_count) - 1;\n\tlen = scnprintf(buf, sizeof(buf), \"Service %u: %s (ref %u)\",\n\t\t\tservice->localport, srvstate_names[service->srvstate],\n\t\t\tref_count);\n\n\tif (service->srvstate != VCHIQ_SRVSTATE_FREE) {\n\t\tchar remoteport[30];\n\t\tstruct vchiq_service_quota *quota =\n\t\t\t&service->state->service_quotas[service->localport];\n\t\tint fourcc = service->base.fourcc;\n\t\tint tx_pending, rx_pending;\n\n\t\tif (service->remoteport != VCHIQ_PORT_FREE) {\n\t\t\tint len2 = scnprintf(remoteport, sizeof(remoteport),\n\t\t\t\t\"%u\", service->remoteport);\n\n\t\t\tif (service->public_fourcc != VCHIQ_FOURCC_INVALID)\n\t\t\t\tscnprintf(remoteport + len2, sizeof(remoteport) - len2,\n\t\t\t\t\t  \" (client %x)\", service->client_id);\n\t\t} else {\n\t\t\tstrscpy(remoteport, \"n/a\", sizeof(remoteport));\n\t\t}\n\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\t \" '%c%c%c%c' remote %s (msg use %d/%d, slot use %d/%d)\",\n\t\t\t\t VCHIQ_FOURCC_AS_4CHARS(fourcc), remoteport,\n\t\t\t\t quota->message_use_count, quota->message_quota,\n\t\t\t\t quota->slot_use_count, quota->slot_quota);\n\n\t\terr = vchiq_dump(dump_context, buf, len + 1);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttx_pending = service->bulk_tx.local_insert -\n\t\t\tservice->bulk_tx.remote_insert;\n\n\t\trx_pending = service->bulk_rx.local_insert -\n\t\t\tservice->bulk_rx.remote_insert;\n\n\t\tlen = scnprintf(buf, sizeof(buf),\n\t\t\t\t\"  Bulk: tx_pending=%d (size %d), rx_pending=%d (size %d)\",\n\t\t\t\ttx_pending,\n\t\t\t\ttx_pending ?\n\t\t\t\tservice->bulk_tx.bulks[BULK_INDEX(service->bulk_tx.remove)].size :\n\t\t\t\t0, rx_pending, rx_pending ?\n\t\t\t\tservice->bulk_rx.bulks[BULK_INDEX(service->bulk_rx.remove)].size :\n\t\t\t\t0);\n\n\t\tif (VCHIQ_ENABLE_STATS) {\n\t\t\terr = vchiq_dump(dump_context, buf, len + 1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tlen = scnprintf(buf, sizeof(buf),\n\t\t\t\t\t\"  Ctrl: tx_count=%d, tx_bytes=%llu, rx_count=%d, rx_bytes=%llu\",\n\t\t\t\t\tservice->stats.ctrl_tx_count, service->stats.ctrl_tx_bytes,\n\t\t\t\t\tservice->stats.ctrl_rx_count, service->stats.ctrl_rx_bytes);\n\t\t\terr = vchiq_dump(dump_context, buf, len + 1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tlen = scnprintf(buf, sizeof(buf),\n\t\t\t\t\t\"  Bulk: tx_count=%d, tx_bytes=%llu, rx_count=%d, rx_bytes=%llu\",\n\t\t\t\t\tservice->stats.bulk_tx_count, service->stats.bulk_tx_bytes,\n\t\t\t\t\tservice->stats.bulk_rx_count, service->stats.bulk_rx_bytes);\n\t\t\terr = vchiq_dump(dump_context, buf, len + 1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tlen = scnprintf(buf, sizeof(buf),\n\t\t\t\t\t\"  %d quota stalls, %d slot stalls, %d bulk stalls, %d aborted, %d errors\",\n\t\t\t\t\tservice->stats.quota_stalls, service->stats.slot_stalls,\n\t\t\t\t\tservice->stats.bulk_stalls,\n\t\t\t\t\tservice->stats.bulk_aborted_count,\n\t\t\t\t\tservice->stats.error_count);\n\t\t}\n\t}\n\n\terr = vchiq_dump(dump_context, buf, len + 1);\n\tif (err)\n\t\treturn err;\n\n\tif (service->srvstate != VCHIQ_SRVSTATE_FREE)\n\t\terr = vchiq_dump_platform_service_state(dump_context, service);\n\treturn err;\n}\n\nvoid\nvchiq_loud_error_header(void)\n{\n\tvchiq_log_error(vchiq_core_log_level,\n\t\t\t\"============================================================================\");\n\tvchiq_log_error(vchiq_core_log_level,\n\t\t\t\"============================================================================\");\n\tvchiq_log_error(vchiq_core_log_level, \"=====\");\n}\n\nvoid\nvchiq_loud_error_footer(void)\n{\n\tvchiq_log_error(vchiq_core_log_level, \"=====\");\n\tvchiq_log_error(vchiq_core_log_level,\n\t\t\t\"============================================================================\");\n\tvchiq_log_error(vchiq_core_log_level,\n\t\t\t\"============================================================================\");\n}\n\nint vchiq_send_remote_use(struct vchiq_state *state)\n{\n\tif (state->conn_state == VCHIQ_CONNSTATE_DISCONNECTED)\n\t\treturn -ENOTCONN;\n\n\treturn queue_message(state, NULL, MAKE_REMOTE_USE, NULL, NULL, 0, 0);\n}\n\nint vchiq_send_remote_use_active(struct vchiq_state *state)\n{\n\tif (state->conn_state == VCHIQ_CONNSTATE_DISCONNECTED)\n\t\treturn -ENOTCONN;\n\n\treturn queue_message(state, NULL, MAKE_REMOTE_USE_ACTIVE,\n\t\t\t     NULL, NULL, 0, 0);\n}\n\nvoid vchiq_log_dump_mem(const char *label, u32 addr, const void *void_mem, size_t num_bytes)\n{\n\tconst u8 *mem = void_mem;\n\tsize_t offset;\n\tchar line_buf[100];\n\tchar *s;\n\n\twhile (num_bytes > 0) {\n\t\ts = line_buf;\n\n\t\tfor (offset = 0; offset < 16; offset++) {\n\t\t\tif (offset < num_bytes)\n\t\t\t\ts += scnprintf(s, 4, \"%02x \", mem[offset]);\n\t\t\telse\n\t\t\t\ts += scnprintf(s, 4, \"   \");\n\t\t}\n\n\t\tfor (offset = 0; offset < 16; offset++) {\n\t\t\tif (offset < num_bytes) {\n\t\t\t\tu8 ch = mem[offset];\n\n\t\t\t\tif ((ch < ' ') || (ch > '~'))\n\t\t\t\t\tch = '.';\n\t\t\t\t*s++ = (char)ch;\n\t\t\t}\n\t\t}\n\t\t*s++ = '\\0';\n\n\t\tif (label && (*label != '\\0'))\n\t\t\tvchiq_log_trace(VCHIQ_LOG_TRACE, \"%s: %08x: %s\", label, addr, line_buf);\n\t\telse\n\t\t\tvchiq_log_trace(VCHIQ_LOG_TRACE, \"%08x: %s\", addr, line_buf);\n\n\t\taddr += 16;\n\t\tmem += 16;\n\t\tif (num_bytes > 16)\n\t\t\tnum_bytes -= 16;\n\t\telse\n\t\t\tnum_bytes = 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}