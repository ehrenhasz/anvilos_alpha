{
  "module_name": "vchiq_arm.h",
  "hash_id": "afd25112647b3aaf28be8fb62cebf1e35cf6301dbe7ad0eb22711139e77bcb73",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.h",
  "human_readable_source": " \n \n\n#ifndef VCHIQ_ARM_H\n#define VCHIQ_ARM_H\n\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/semaphore.h>\n#include <linux/atomic.h>\n#include \"vchiq_core.h\"\n#include \"vchiq_debugfs.h\"\n\n \n#define MAX_COMPLETIONS 128\n#define MAX_SERVICES 64\n#define MAX_ELEMENTS 8\n#define MSG_QUEUE_SIZE 128\n\nenum USE_TYPE_E {\n\tUSE_TYPE_SERVICE,\n\tUSE_TYPE_VCHIQ\n};\n\nstruct user_service {\n\tstruct vchiq_service *service;\n\tvoid __user *userdata;\n\tstruct vchiq_instance *instance;\n\tchar is_vchi;\n\tchar dequeue_pending;\n\tchar close_pending;\n\tint message_available_pos;\n\tint msg_insert;\n\tint msg_remove;\n\tstruct completion insert_event;\n\tstruct completion remove_event;\n\tstruct completion close_event;\n\tstruct vchiq_header *msg_queue[MSG_QUEUE_SIZE];\n};\n\nstruct bulk_waiter_node {\n\tstruct bulk_waiter bulk_waiter;\n\tint pid;\n\tstruct list_head list;\n};\n\nstruct vchiq_instance {\n\tstruct vchiq_state *state;\n\tstruct vchiq_completion_data_kernel completions[MAX_COMPLETIONS];\n\tint completion_insert;\n\tint completion_remove;\n\tstruct completion insert_event;\n\tstruct completion remove_event;\n\tstruct mutex completion_mutex;\n\n\tint connected;\n\tint closing;\n\tint pid;\n\tint mark;\n\tint use_close_delivered;\n\tint trace;\n\n\tstruct list_head bulk_waiter_list;\n\tstruct mutex bulk_waiter_list_mutex;\n\n\tstruct vchiq_debugfs_node debugfs_node;\n};\n\nstruct dump_context {\n\tchar __user *buf;\n\tsize_t actual;\n\tsize_t space;\n\tloff_t offset;\n};\n\nextern int vchiq_arm_log_level;\nextern int vchiq_susp_log_level;\n\nextern spinlock_t msg_queue_spinlock;\nextern struct vchiq_state g_state;\n\nextern struct vchiq_state *\nvchiq_get_state(void);\n\nint\nvchiq_use_service(struct vchiq_instance *instance, unsigned int handle);\n\nextern int\nvchiq_release_service(struct vchiq_instance *instance, unsigned int handle);\n\nextern int\nvchiq_check_service(struct vchiq_service *service);\n\nextern void\nvchiq_dump_platform_use_state(struct vchiq_state *state);\n\nextern void\nvchiq_dump_service_use_state(struct vchiq_state *state);\n\nextern int\nvchiq_use_internal(struct vchiq_state *state, struct vchiq_service *service,\n\t\t   enum USE_TYPE_E use_type);\nextern int\nvchiq_release_internal(struct vchiq_state *state,\n\t\t       struct vchiq_service *service);\n\nextern struct vchiq_debugfs_node *\nvchiq_instance_get_debugfs_node(struct vchiq_instance *instance);\n\nextern int\nvchiq_instance_get_use_count(struct vchiq_instance *instance);\n\nextern int\nvchiq_instance_get_pid(struct vchiq_instance *instance);\n\nextern int\nvchiq_instance_get_trace(struct vchiq_instance *instance);\n\nextern void\nvchiq_instance_set_trace(struct vchiq_instance *instance, int trace);\n\n#if IS_ENABLED(CONFIG_VCHIQ_CDEV)\n\nextern void\nvchiq_deregister_chrdev(void);\n\nextern int\nvchiq_register_chrdev(struct device *parent);\n\n#else\n\nstatic inline void vchiq_deregister_chrdev(void) { }\nstatic inline int vchiq_register_chrdev(struct device *parent) { return 0; }\n\n#endif  \n\nextern int\nservice_callback(struct vchiq_instance *vchiq_instance, enum vchiq_reason reason,\n\t\t struct vchiq_header *header, unsigned int handle, void *bulk_userdata);\n\nextern void\nfree_bulk_waiter(struct vchiq_instance *instance);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}