{
  "module_name": "vchiq_dev.c",
  "hash_id": "6fe2a9cfe621c57b5c966c442f9769f4850361abd093c6c1e0e07f1ccb3a0764",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_dev.c",
  "human_readable_source": "\n \n\n#include <linux/cdev.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/miscdevice.h>\n\n#include \"vchiq_core.h\"\n#include \"vchiq_ioctl.h\"\n#include \"vchiq_arm.h\"\n#include \"vchiq_debugfs.h\"\n\nstatic const char *const ioctl_names[] = {\n\t\"CONNECT\",\n\t\"SHUTDOWN\",\n\t\"CREATE_SERVICE\",\n\t\"REMOVE_SERVICE\",\n\t\"QUEUE_MESSAGE\",\n\t\"QUEUE_BULK_TRANSMIT\",\n\t\"QUEUE_BULK_RECEIVE\",\n\t\"AWAIT_COMPLETION\",\n\t\"DEQUEUE_MESSAGE\",\n\t\"GET_CLIENT_ID\",\n\t\"GET_CONFIG\",\n\t\"CLOSE_SERVICE\",\n\t\"USE_SERVICE\",\n\t\"RELEASE_SERVICE\",\n\t\"SET_SERVICE_OPTION\",\n\t\"DUMP_PHYS_MEM\",\n\t\"LIB_VERSION\",\n\t\"CLOSE_DELIVERED\"\n};\n\nstatic_assert(ARRAY_SIZE(ioctl_names) == (VCHIQ_IOC_MAX + 1));\n\nstatic void\nuser_service_free(void *userdata)\n{\n\tkfree(userdata);\n}\n\nstatic void close_delivered(struct user_service *user_service)\n{\n\tvchiq_log_info(vchiq_arm_log_level,\n\t\t       \"%s(handle=%x)\",\n\t\t       __func__, user_service->service->handle);\n\n\tif (user_service->close_pending) {\n\t\t \n\t\tvchiq_service_put(user_service->service);\n\n\t\t \n\t\tcomplete(&user_service->close_event);\n\n\t\tuser_service->close_pending = 0;\n\t}\n}\n\nstruct vchiq_io_copy_callback_context {\n\tstruct vchiq_element *element;\n\tsize_t element_offset;\n\tunsigned long elements_to_go;\n};\n\nstatic ssize_t vchiq_ioc_copy_element_data(void *context, void *dest,\n\t\t\t\t\t   size_t offset, size_t maxsize)\n{\n\tstruct vchiq_io_copy_callback_context *cc = context;\n\tsize_t total_bytes_copied = 0;\n\tsize_t bytes_this_round;\n\n\twhile (total_bytes_copied < maxsize) {\n\t\tif (!cc->elements_to_go)\n\t\t\treturn total_bytes_copied;\n\n\t\tif (!cc->element->size) {\n\t\t\tcc->elements_to_go--;\n\t\t\tcc->element++;\n\t\t\tcc->element_offset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbytes_this_round = min(cc->element->size - cc->element_offset,\n\t\t\t\t       maxsize - total_bytes_copied);\n\n\t\tif (copy_from_user(dest + total_bytes_copied,\n\t\t\t\t   cc->element->data + cc->element_offset,\n\t\t\t\t   bytes_this_round))\n\t\t\treturn -EFAULT;\n\n\t\tcc->element_offset += bytes_this_round;\n\t\ttotal_bytes_copied += bytes_this_round;\n\n\t\tif (cc->element_offset == cc->element->size) {\n\t\t\tcc->elements_to_go--;\n\t\t\tcc->element++;\n\t\t\tcc->element_offset = 0;\n\t\t}\n\t}\n\n\treturn maxsize;\n}\n\nstatic int\nvchiq_ioc_queue_message(struct vchiq_instance *instance, unsigned int handle,\n\t\t\tstruct vchiq_element *elements, unsigned long count)\n{\n\tstruct vchiq_io_copy_callback_context context;\n\tint status = 0;\n\tunsigned long i;\n\tsize_t total_size = 0;\n\n\tcontext.element = elements;\n\tcontext.element_offset = 0;\n\tcontext.elements_to_go = count;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (!elements[i].data && elements[i].size != 0)\n\t\t\treturn -EFAULT;\n\n\t\ttotal_size += elements[i].size;\n\t}\n\n\tstatus = vchiq_queue_message(instance, handle, vchiq_ioc_copy_element_data,\n\t\t\t\t     &context, total_size);\n\n\tif (status == -EINVAL)\n\t\treturn -EIO;\n\telse if (status == -EAGAIN)\n\t\treturn -EINTR;\n\treturn 0;\n}\n\nstatic int vchiq_ioc_create_service(struct vchiq_instance *instance,\n\t\t\t\t    struct vchiq_create_service *args)\n{\n\tstruct user_service *user_service = NULL;\n\tstruct vchiq_service *service;\n\tint status = 0;\n\tstruct vchiq_service_params_kernel params;\n\tint srvstate;\n\n\tif (args->is_open && !instance->connected)\n\t\treturn -ENOTCONN;\n\n\tuser_service = kmalloc(sizeof(*user_service), GFP_KERNEL);\n\tif (!user_service)\n\t\treturn -ENOMEM;\n\n\tif (args->is_open) {\n\t\tsrvstate = VCHIQ_SRVSTATE_OPENING;\n\t} else {\n\t\tsrvstate = instance->connected ?\n\t\t\t VCHIQ_SRVSTATE_LISTENING : VCHIQ_SRVSTATE_HIDDEN;\n\t}\n\n\tparams = (struct vchiq_service_params_kernel) {\n\t\t.fourcc   = args->params.fourcc,\n\t\t.callback = service_callback,\n\t\t.userdata = user_service,\n\t\t.version  = args->params.version,\n\t\t.version_min = args->params.version_min,\n\t};\n\tservice = vchiq_add_service_internal(instance->state, &params,\n\t\t\t\t\t     srvstate, instance,\n\t\t\t\t\t     user_service_free);\n\tif (!service) {\n\t\tkfree(user_service);\n\t\treturn -EEXIST;\n\t}\n\n\tuser_service->service = service;\n\tuser_service->userdata = args->params.userdata;\n\tuser_service->instance = instance;\n\tuser_service->is_vchi = (args->is_vchi != 0);\n\tuser_service->dequeue_pending = 0;\n\tuser_service->close_pending = 0;\n\tuser_service->message_available_pos = instance->completion_remove - 1;\n\tuser_service->msg_insert = 0;\n\tuser_service->msg_remove = 0;\n\tinit_completion(&user_service->insert_event);\n\tinit_completion(&user_service->remove_event);\n\tinit_completion(&user_service->close_event);\n\n\tif (args->is_open) {\n\t\tstatus = vchiq_open_service_internal(service, instance->pid);\n\t\tif (status) {\n\t\t\tvchiq_remove_service(instance, service->handle);\n\t\t\treturn (status == -EAGAIN) ?\n\t\t\t\t-EINTR : -EIO;\n\t\t}\n\t}\n\targs->handle = service->handle;\n\n\treturn 0;\n}\n\nstatic int vchiq_ioc_dequeue_message(struct vchiq_instance *instance,\n\t\t\t\t     struct vchiq_dequeue_message *args)\n{\n\tstruct user_service *user_service;\n\tstruct vchiq_service *service;\n\tstruct vchiq_header *header;\n\tint ret;\n\n\tDEBUG_INITIALISE(g_state.local);\n\tDEBUG_TRACE(DEQUEUE_MESSAGE_LINE);\n\tservice = find_service_for_instance(instance, args->handle);\n\tif (!service)\n\t\treturn -EINVAL;\n\n\tuser_service = (struct user_service *)service->base.userdata;\n\tif (user_service->is_vchi == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&msg_queue_spinlock);\n\tif (user_service->msg_remove == user_service->msg_insert) {\n\t\tif (!args->blocking) {\n\t\t\tspin_unlock(&msg_queue_spinlock);\n\t\t\tDEBUG_TRACE(DEQUEUE_MESSAGE_LINE);\n\t\t\tret = -EWOULDBLOCK;\n\t\t\tgoto out;\n\t\t}\n\t\tuser_service->dequeue_pending = 1;\n\t\tret = 0;\n\t\tdo {\n\t\t\tspin_unlock(&msg_queue_spinlock);\n\t\t\tDEBUG_TRACE(DEQUEUE_MESSAGE_LINE);\n\t\t\tif (wait_for_completion_interruptible(&user_service->insert_event)) {\n\t\t\t\tvchiq_log_info(vchiq_arm_log_level,\n\t\t\t\t\t       \"DEQUEUE_MESSAGE interrupted\");\n\t\t\t\tret = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_lock(&msg_queue_spinlock);\n\t\t} while (user_service->msg_remove == user_service->msg_insert);\n\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE((int)(user_service->msg_insert -\n\t\t\t user_service->msg_remove) < 0)) {\n\t\tspin_unlock(&msg_queue_spinlock);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\theader = user_service->msg_queue[user_service->msg_remove &\n\t\t(MSG_QUEUE_SIZE - 1)];\n\tuser_service->msg_remove++;\n\tspin_unlock(&msg_queue_spinlock);\n\n\tcomplete(&user_service->remove_event);\n\tif (!header) {\n\t\tret = -ENOTCONN;\n\t} else if (header->size <= args->bufsize) {\n\t\t \n\t\tif (!args->buf || (copy_to_user(args->buf, header->data, header->size) == 0)) {\n\t\t\tret = header->size;\n\t\t\tvchiq_release_message(instance, service->handle, header);\n\t\t} else {\n\t\t\tret = -EFAULT;\n\t\t}\n\t} else {\n\t\tvchiq_log_error(vchiq_arm_log_level,\n\t\t\t\t\"header %pK: bufsize %x < size %x\",\n\t\t\t\theader, args->bufsize, header->size);\n\t\tWARN(1, \"invalid size\\n\");\n\t\tret = -EMSGSIZE;\n\t}\n\tDEBUG_TRACE(DEQUEUE_MESSAGE_LINE);\nout:\n\tvchiq_service_put(service);\n\treturn ret;\n}\n\nstatic int vchiq_irq_queue_bulk_tx_rx(struct vchiq_instance *instance,\n\t\t\t\t      struct vchiq_queue_bulk_transfer *args,\n\t\t\t\t      enum vchiq_bulk_dir dir,\n\t\t\t\t      enum vchiq_bulk_mode __user *mode)\n{\n\tstruct vchiq_service *service;\n\tstruct bulk_waiter_node *waiter = NULL, *iter;\n\tvoid *userdata;\n\tint status = 0;\n\tint ret;\n\n\tservice = find_service_for_instance(instance, args->handle);\n\tif (!service)\n\t\treturn -EINVAL;\n\n\tif (args->mode == VCHIQ_BULK_MODE_BLOCKING) {\n\t\twaiter = kzalloc(sizeof(*waiter), GFP_KERNEL);\n\t\tif (!waiter) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tuserdata = &waiter->bulk_waiter;\n\t} else if (args->mode == VCHIQ_BULK_MODE_WAITING) {\n\t\tmutex_lock(&instance->bulk_waiter_list_mutex);\n\t\tlist_for_each_entry(iter, &instance->bulk_waiter_list,\n\t\t\t\t    list) {\n\t\t\tif (iter->pid == current->pid) {\n\t\t\t\tlist_del(&iter->list);\n\t\t\t\twaiter = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&instance->bulk_waiter_list_mutex);\n\t\tif (!waiter) {\n\t\t\tvchiq_log_error(vchiq_arm_log_level,\n\t\t\t\t\t\"no bulk_waiter found for pid %d\", current->pid);\n\t\t\tret = -ESRCH;\n\t\t\tgoto out;\n\t\t}\n\t\tvchiq_log_info(vchiq_arm_log_level,\n\t\t\t       \"found bulk_waiter %pK for pid %d\", waiter, current->pid);\n\t\tuserdata = &waiter->bulk_waiter;\n\t} else {\n\t\tuserdata = args->userdata;\n\t}\n\n\tstatus = vchiq_bulk_transfer(instance, args->handle, NULL, args->data, args->size,\n\t\t\t\t     userdata, args->mode, dir);\n\n\tif (!waiter) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif ((status != -EAGAIN) || fatal_signal_pending(current) ||\n\t    !waiter->bulk_waiter.bulk) {\n\t\tif (waiter->bulk_waiter.bulk) {\n\t\t\t \n\t\t\tspin_lock(&bulk_waiter_spinlock);\n\t\t\twaiter->bulk_waiter.bulk->userdata = NULL;\n\t\t\tspin_unlock(&bulk_waiter_spinlock);\n\t\t}\n\t\tkfree(waiter);\n\t\tret = 0;\n\t} else {\n\t\tconst enum vchiq_bulk_mode mode_waiting =\n\t\t\tVCHIQ_BULK_MODE_WAITING;\n\t\twaiter->pid = current->pid;\n\t\tmutex_lock(&instance->bulk_waiter_list_mutex);\n\t\tlist_add(&waiter->list, &instance->bulk_waiter_list);\n\t\tmutex_unlock(&instance->bulk_waiter_list_mutex);\n\t\tvchiq_log_info(vchiq_arm_log_level,\n\t\t\t       \"saved bulk_waiter %pK for pid %d\", waiter, current->pid);\n\n\t\tret = put_user(mode_waiting, mode);\n\t}\nout:\n\tvchiq_service_put(service);\n\tif (ret)\n\t\treturn ret;\n\telse if (status == -EINVAL)\n\t\treturn -EIO;\n\telse if (status == -EAGAIN)\n\t\treturn -EINTR;\n\treturn 0;\n}\n\n \nstatic inline int vchiq_get_user_ptr(void __user **buf, void __user *ubuf, int index)\n{\n\tint ret;\n\n\tif (in_compat_syscall()) {\n\t\tcompat_uptr_t ptr32;\n\t\tcompat_uptr_t __user *uptr = ubuf;\n\n\t\tret = get_user(ptr32, uptr + index);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*buf = compat_ptr(ptr32);\n\t} else {\n\t\tuintptr_t ptr, __user *uptr = ubuf;\n\n\t\tret = get_user(ptr, uptr + index);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*buf = (void __user *)ptr;\n\t}\n\n\treturn 0;\n}\n\nstruct vchiq_completion_data32 {\n\tenum vchiq_reason reason;\n\tcompat_uptr_t header;\n\tcompat_uptr_t service_userdata;\n\tcompat_uptr_t bulk_userdata;\n};\n\nstatic int vchiq_put_completion(struct vchiq_completion_data __user *buf,\n\t\t\t\tstruct vchiq_completion_data *completion,\n\t\t\t\tint index)\n{\n\tstruct vchiq_completion_data32 __user *buf32 = (void __user *)buf;\n\n\tif (in_compat_syscall()) {\n\t\tstruct vchiq_completion_data32 tmp = {\n\t\t\t.reason\t\t  = completion->reason,\n\t\t\t.header\t\t  = ptr_to_compat(completion->header),\n\t\t\t.service_userdata = ptr_to_compat(completion->service_userdata),\n\t\t\t.bulk_userdata\t  = ptr_to_compat(completion->bulk_userdata),\n\t\t};\n\t\tif (copy_to_user(&buf32[index], &tmp, sizeof(tmp)))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (copy_to_user(&buf[index], completion, sizeof(*completion)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int vchiq_ioc_await_completion(struct vchiq_instance *instance,\n\t\t\t\t      struct vchiq_await_completion *args,\n\t\t\t\t      int __user *msgbufcountp)\n{\n\tint msgbufcount;\n\tint remove;\n\tint ret;\n\n\tDEBUG_INITIALISE(g_state.local);\n\n\tDEBUG_TRACE(AWAIT_COMPLETION_LINE);\n\tif (!instance->connected)\n\t\treturn -ENOTCONN;\n\n\tmutex_lock(&instance->completion_mutex);\n\n\tDEBUG_TRACE(AWAIT_COMPLETION_LINE);\n\twhile ((instance->completion_remove == instance->completion_insert) && !instance->closing) {\n\t\tint rc;\n\n\t\tDEBUG_TRACE(AWAIT_COMPLETION_LINE);\n\t\tmutex_unlock(&instance->completion_mutex);\n\t\trc = wait_for_completion_interruptible(&instance->insert_event);\n\t\tmutex_lock(&instance->completion_mutex);\n\t\tif (rc) {\n\t\t\tDEBUG_TRACE(AWAIT_COMPLETION_LINE);\n\t\t\tvchiq_log_info(vchiq_arm_log_level,\n\t\t\t\t       \"AWAIT_COMPLETION interrupted\");\n\t\t\tret = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tDEBUG_TRACE(AWAIT_COMPLETION_LINE);\n\n\tmsgbufcount = args->msgbufcount;\n\tremove = instance->completion_remove;\n\n\tfor (ret = 0; ret < args->count; ret++) {\n\t\tstruct vchiq_completion_data_kernel *completion;\n\t\tstruct vchiq_completion_data user_completion;\n\t\tstruct vchiq_service *service;\n\t\tstruct user_service *user_service;\n\t\tstruct vchiq_header *header;\n\n\t\tif (remove == instance->completion_insert)\n\t\t\tbreak;\n\n\t\tcompletion = &instance->completions[remove & (MAX_COMPLETIONS - 1)];\n\n\t\t \n\t\trmb();\n\n\t\tservice = completion->service_userdata;\n\t\tuser_service = service->base.userdata;\n\n\t\tmemset(&user_completion, 0, sizeof(user_completion));\n\t\tuser_completion = (struct vchiq_completion_data) {\n\t\t\t.reason = completion->reason,\n\t\t\t.service_userdata = user_service->userdata,\n\t\t};\n\n\t\theader = completion->header;\n\t\tif (header) {\n\t\t\tvoid __user *msgbuf;\n\t\t\tint msglen;\n\n\t\t\tmsglen = header->size + sizeof(struct vchiq_header);\n\t\t\t \n\t\t\tif (args->msgbufsize < msglen) {\n\t\t\t\tvchiq_log_error(vchiq_arm_log_level,\n\t\t\t\t\t\t\"header %pK: msgbufsize %x < msglen %x\",\n\t\t\t\t\t\theader, args->msgbufsize, msglen);\n\t\t\t\t\t\tWARN(1, \"invalid message size\\n\");\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = -EMSGSIZE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (msgbufcount <= 0)\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t \n\t\t\tmsgbufcount--;\n\t\t\tif (vchiq_get_user_ptr(&msgbuf, args->msgbufs,\n\t\t\t\t\t       msgbufcount)) {\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (copy_to_user(msgbuf, header, msglen)) {\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tvchiq_release_message(instance, service->handle, header);\n\n\t\t\t \n\t\t\tuser_completion.header = msgbuf;\n\t\t}\n\n\t\tif ((completion->reason == VCHIQ_SERVICE_CLOSED) &&\n\t\t    !instance->use_close_delivered)\n\t\t\tvchiq_service_put(service);\n\n\t\t \n\t\tuser_completion.bulk_userdata = completion->bulk_userdata;\n\n\t\tif (vchiq_put_completion(args->buf, &user_completion, ret)) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmb();\n\t\tremove++;\n\t\tinstance->completion_remove = remove;\n\t}\n\n\tif (msgbufcount != args->msgbufcount) {\n\t\tif (put_user(msgbufcount, msgbufcountp))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\tif (ret)\n\t\tcomplete(&instance->remove_event);\n\tmutex_unlock(&instance->completion_mutex);\n\tDEBUG_TRACE(AWAIT_COMPLETION_LINE);\n\n\treturn ret;\n}\n\nstatic long\nvchiq_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct vchiq_instance *instance = file->private_data;\n\tint status = 0;\n\tstruct vchiq_service *service = NULL;\n\tlong ret = 0;\n\tint i, rc;\n\n\tvchiq_log_trace(vchiq_arm_log_level,\n\t\t\t\"%s - instance %pK, cmd %s, arg %lx\", __func__, instance,\n\t\t\t((_IOC_TYPE(cmd) == VCHIQ_IOC_MAGIC) && (_IOC_NR(cmd) <= VCHIQ_IOC_MAX)) ?\n\t\t\tioctl_names[_IOC_NR(cmd)] : \"<invalid>\", arg);\n\n\tswitch (cmd) {\n\tcase VCHIQ_IOC_SHUTDOWN:\n\t\tif (!instance->connected)\n\t\t\tbreak;\n\n\t\t \n\t\ti = 0;\n\t\twhile ((service = next_service_by_instance(instance->state,\n\t\t\t\t\t\t\t   instance, &i))) {\n\t\t\tstatus = vchiq_remove_service(instance, service->handle);\n\t\t\tvchiq_service_put(service);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t}\n\t\tservice = NULL;\n\n\t\tif (!status) {\n\t\t\t \n\t\t\tinstance->closing = 1;\n\t\t\tcomplete(&instance->insert_event);\n\t\t}\n\n\t\tbreak;\n\n\tcase VCHIQ_IOC_CONNECT:\n\t\tif (instance->connected) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trc = mutex_lock_killable(&instance->state->mutex);\n\t\tif (rc) {\n\t\t\tvchiq_log_error(vchiq_arm_log_level,\n\t\t\t\t\t\"vchiq: connect: could not lock mutex for state %d: %d\",\n\t\t\t\t\tinstance->state->id, rc);\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tstatus = vchiq_connect_internal(instance->state, instance);\n\t\tmutex_unlock(&instance->state->mutex);\n\n\t\tif (!status)\n\t\t\tinstance->connected = 1;\n\t\telse\n\t\t\tvchiq_log_error(vchiq_arm_log_level,\n\t\t\t\t\t\"vchiq: could not connect: %d\", status);\n\t\tbreak;\n\n\tcase VCHIQ_IOC_CREATE_SERVICE: {\n\t\tstruct vchiq_create_service __user *argp;\n\t\tstruct vchiq_create_service args;\n\n\t\targp = (void __user *)arg;\n\t\tif (copy_from_user(&args, argp, sizeof(args))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = vchiq_ioc_create_service(instance, &args);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (put_user(args.handle, &argp->handle)) {\n\t\t\tvchiq_remove_service(instance, args.handle);\n\t\t\tret = -EFAULT;\n\t\t}\n\t} break;\n\n\tcase VCHIQ_IOC_CLOSE_SERVICE:\n\tcase VCHIQ_IOC_REMOVE_SERVICE: {\n\t\tunsigned int handle = (unsigned int)arg;\n\t\tstruct user_service *user_service;\n\n\t\tservice = find_service_for_instance(instance, handle);\n\t\tif (!service) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tuser_service = service->base.userdata;\n\n\t\t \n\t\tif (!user_service->close_pending) {\n\t\t\tstatus = (cmd == VCHIQ_IOC_CLOSE_SERVICE) ?\n\t\t\t\t vchiq_close_service(instance, service->handle) :\n\t\t\t\t vchiq_remove_service(instance, service->handle);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (user_service->close_pending &&\n\t\t    wait_for_completion_interruptible(&user_service->close_event))\n\t\t\tstatus = -EAGAIN;\n\t\tbreak;\n\t}\n\n\tcase VCHIQ_IOC_USE_SERVICE:\n\tcase VCHIQ_IOC_RELEASE_SERVICE:\t{\n\t\tunsigned int handle = (unsigned int)arg;\n\n\t\tservice = find_service_for_instance(instance, handle);\n\t\tif (service) {\n\t\t\tret = (cmd == VCHIQ_IOC_USE_SERVICE) ?\n\t\t\t\tvchiq_use_service_internal(service) :\n\t\t\t\tvchiq_release_service_internal(service);\n\t\t\tif (ret) {\n\t\t\t\tvchiq_log_error(vchiq_susp_log_level,\n\t\t\t\t\t\t\"%s: cmd %s returned error %ld for service %c%c%c%c:%03d\",\n\t\t\t\t\t\t__func__, (cmd == VCHIQ_IOC_USE_SERVICE) ?\n\t\t\t\t\t\t\"VCHIQ_IOC_USE_SERVICE\" :\n\t\t\t\t\t\t\"VCHIQ_IOC_RELEASE_SERVICE\",\n\t\t\t\t\tret,\n\t\t\t\t\tVCHIQ_FOURCC_AS_4CHARS(service->base.fourcc),\n\t\t\t\t\tservice->client_id);\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t} break;\n\n\tcase VCHIQ_IOC_QUEUE_MESSAGE: {\n\t\tstruct vchiq_queue_message args;\n\n\t\tif (copy_from_user(&args, (const void __user *)arg,\n\t\t\t\t   sizeof(args))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tservice = find_service_for_instance(instance, args.handle);\n\n\t\tif (service && (args.count <= MAX_ELEMENTS)) {\n\t\t\t \n\t\t\tstruct vchiq_element elements[MAX_ELEMENTS];\n\n\t\t\tif (copy_from_user(elements, args.elements,\n\t\t\t\t\t   args.count * sizeof(struct vchiq_element)) == 0)\n\t\t\t\tret = vchiq_ioc_queue_message(instance, args.handle, elements,\n\t\t\t\t\t\t\t      args.count);\n\t\t\telse\n\t\t\t\tret = -EFAULT;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t} break;\n\n\tcase VCHIQ_IOC_QUEUE_BULK_TRANSMIT:\n\tcase VCHIQ_IOC_QUEUE_BULK_RECEIVE: {\n\t\tstruct vchiq_queue_bulk_transfer args;\n\t\tstruct vchiq_queue_bulk_transfer __user *argp;\n\n\t\tenum vchiq_bulk_dir dir =\n\t\t\t(cmd == VCHIQ_IOC_QUEUE_BULK_TRANSMIT) ?\n\t\t\tVCHIQ_BULK_TRANSMIT : VCHIQ_BULK_RECEIVE;\n\n\t\targp = (void __user *)arg;\n\t\tif (copy_from_user(&args, argp, sizeof(args))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = vchiq_irq_queue_bulk_tx_rx(instance, &args,\n\t\t\t\t\t\t dir, &argp->mode);\n\t} break;\n\n\tcase VCHIQ_IOC_AWAIT_COMPLETION: {\n\t\tstruct vchiq_await_completion args;\n\t\tstruct vchiq_await_completion __user *argp;\n\n\t\targp = (void __user *)arg;\n\t\tif (copy_from_user(&args, argp, sizeof(args))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = vchiq_ioc_await_completion(instance, &args,\n\t\t\t\t\t\t &argp->msgbufcount);\n\t} break;\n\n\tcase VCHIQ_IOC_DEQUEUE_MESSAGE: {\n\t\tstruct vchiq_dequeue_message args;\n\n\t\tif (copy_from_user(&args, (const void __user *)arg,\n\t\t\t\t   sizeof(args))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = vchiq_ioc_dequeue_message(instance, &args);\n\t} break;\n\n\tcase VCHIQ_IOC_GET_CLIENT_ID: {\n\t\tunsigned int handle = (unsigned int)arg;\n\n\t\tret = vchiq_get_client_id(instance, handle);\n\t} break;\n\n\tcase VCHIQ_IOC_GET_CONFIG: {\n\t\tstruct vchiq_get_config args;\n\t\tstruct vchiq_config config;\n\n\t\tif (copy_from_user(&args, (const void __user *)arg,\n\t\t\t\t   sizeof(args))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (args.config_size > sizeof(config)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tvchiq_get_config(&config);\n\t\tif (copy_to_user(args.pconfig, &config, args.config_size)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t} break;\n\n\tcase VCHIQ_IOC_SET_SERVICE_OPTION: {\n\t\tstruct vchiq_set_service_option args;\n\n\t\tif (copy_from_user(&args, (const void __user *)arg,\n\t\t\t\t   sizeof(args))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tservice = find_service_for_instance(instance, args.handle);\n\t\tif (!service) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = vchiq_set_service_option(instance, args.handle, args.option,\n\t\t\t\t\t       args.value);\n\t} break;\n\n\tcase VCHIQ_IOC_LIB_VERSION: {\n\t\tunsigned int lib_version = (unsigned int)arg;\n\n\t\tif (lib_version < VCHIQ_VERSION_MIN)\n\t\t\tret = -EINVAL;\n\t\telse if (lib_version >= VCHIQ_VERSION_CLOSE_DELIVERED)\n\t\t\tinstance->use_close_delivered = 1;\n\t} break;\n\n\tcase VCHIQ_IOC_CLOSE_DELIVERED: {\n\t\tunsigned int handle = (unsigned int)arg;\n\n\t\tservice = find_closed_service_for_instance(instance, handle);\n\t\tif (service) {\n\t\t\tstruct user_service *user_service =\n\t\t\t\t(struct user_service *)service->base.userdata;\n\t\t\tclose_delivered(user_service);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t} break;\n\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\n\tif (service)\n\t\tvchiq_service_put(service);\n\n\tif (ret == 0) {\n\t\tif (status == -EINVAL)\n\t\t\tret = -EIO;\n\t\telse if (status == -EAGAIN)\n\t\t\tret = -EINTR;\n\t}\n\n\tif (!status && (ret < 0) && (ret != -EINTR) && (ret != -EWOULDBLOCK))\n\t\tvchiq_log_info(vchiq_arm_log_level,\n\t\t\t       \"  ioctl instance %pK, cmd %s -> status %d, %ld\",\n\t\t\t       instance, (_IOC_NR(cmd) <= VCHIQ_IOC_MAX) ?\n\t\t\t       ioctl_names[_IOC_NR(cmd)] : \"<invalid>\", status, ret);\n\telse\n\t\tvchiq_log_trace(vchiq_arm_log_level,\n\t\t\t\t\"  ioctl instance %pK, cmd %s -> status %d, %ld\",\n\t\t\t\tinstance, (_IOC_NR(cmd) <= VCHIQ_IOC_MAX) ?\n\t\t\t\tioctl_names[_IOC_NR(cmd)] : \"<invalid>\", status, ret);\n\n\treturn ret;\n}\n\n#if defined(CONFIG_COMPAT)\n\nstruct vchiq_service_params32 {\n\tint fourcc;\n\tcompat_uptr_t callback;\n\tcompat_uptr_t userdata;\n\tshort version;  \n\tshort version_min;  \n};\n\nstruct vchiq_create_service32 {\n\tstruct vchiq_service_params32 params;\n\tint is_open;\n\tint is_vchi;\n\tunsigned int handle;  \n};\n\n#define VCHIQ_IOC_CREATE_SERVICE32 \\\n\t_IOWR(VCHIQ_IOC_MAGIC, 2, struct vchiq_create_service32)\n\nstatic long\nvchiq_compat_ioctl_create_service(struct file *file, unsigned int cmd,\n\t\t\t\t  struct vchiq_create_service32 __user *ptrargs32)\n{\n\tstruct vchiq_create_service args;\n\tstruct vchiq_create_service32 args32;\n\tstruct vchiq_instance *instance = file->private_data;\n\tlong ret;\n\n\tif (copy_from_user(&args32, ptrargs32, sizeof(args32)))\n\t\treturn -EFAULT;\n\n\targs = (struct vchiq_create_service) {\n\t\t.params = {\n\t\t\t.fourcc\t     = args32.params.fourcc,\n\t\t\t.callback    = compat_ptr(args32.params.callback),\n\t\t\t.userdata    = compat_ptr(args32.params.userdata),\n\t\t\t.version     = args32.params.version,\n\t\t\t.version_min = args32.params.version_min,\n\t\t},\n\t\t.is_open = args32.is_open,\n\t\t.is_vchi = args32.is_vchi,\n\t\t.handle  = args32.handle,\n\t};\n\n\tret = vchiq_ioc_create_service(instance, &args);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (put_user(args.handle, &ptrargs32->handle)) {\n\t\tvchiq_remove_service(instance, args.handle);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstruct vchiq_element32 {\n\tcompat_uptr_t data;\n\tunsigned int size;\n};\n\nstruct vchiq_queue_message32 {\n\tunsigned int handle;\n\tunsigned int count;\n\tcompat_uptr_t elements;\n};\n\n#define VCHIQ_IOC_QUEUE_MESSAGE32 \\\n\t_IOW(VCHIQ_IOC_MAGIC,  4, struct vchiq_queue_message32)\n\nstatic long\nvchiq_compat_ioctl_queue_message(struct file *file,\n\t\t\t\t unsigned int cmd,\n\t\t\t\t struct vchiq_queue_message32 __user *arg)\n{\n\tstruct vchiq_queue_message args;\n\tstruct vchiq_queue_message32 args32;\n\tstruct vchiq_service *service;\n\tstruct vchiq_instance *instance = file->private_data;\n\tint ret;\n\n\tif (copy_from_user(&args32, arg, sizeof(args32)))\n\t\treturn -EFAULT;\n\n\targs = (struct vchiq_queue_message) {\n\t\t.handle   = args32.handle,\n\t\t.count    = args32.count,\n\t\t.elements = compat_ptr(args32.elements),\n\t};\n\n\tif (args32.count > MAX_ELEMENTS)\n\t\treturn -EINVAL;\n\n\tservice = find_service_for_instance(instance, args.handle);\n\tif (!service)\n\t\treturn -EINVAL;\n\n\tif (args32.elements && args32.count) {\n\t\tstruct vchiq_element32 element32[MAX_ELEMENTS];\n\t\tstruct vchiq_element elements[MAX_ELEMENTS];\n\t\tunsigned int count;\n\n\t\tif (copy_from_user(&element32, args.elements,\n\t\t\t\t   sizeof(element32))) {\n\t\t\tvchiq_service_put(service);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tfor (count = 0; count < args32.count; count++) {\n\t\t\telements[count].data =\n\t\t\t\tcompat_ptr(element32[count].data);\n\t\t\telements[count].size = element32[count].size;\n\t\t}\n\t\tret = vchiq_ioc_queue_message(instance, args.handle, elements,\n\t\t\t\t\t      args.count);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\tvchiq_service_put(service);\n\n\treturn ret;\n}\n\nstruct vchiq_queue_bulk_transfer32 {\n\tunsigned int handle;\n\tcompat_uptr_t data;\n\tunsigned int size;\n\tcompat_uptr_t userdata;\n\tenum vchiq_bulk_mode mode;\n};\n\n#define VCHIQ_IOC_QUEUE_BULK_TRANSMIT32 \\\n\t_IOWR(VCHIQ_IOC_MAGIC, 5, struct vchiq_queue_bulk_transfer32)\n#define VCHIQ_IOC_QUEUE_BULK_RECEIVE32 \\\n\t_IOWR(VCHIQ_IOC_MAGIC, 6, struct vchiq_queue_bulk_transfer32)\n\nstatic long\nvchiq_compat_ioctl_queue_bulk(struct file *file,\n\t\t\t      unsigned int cmd,\n\t\t\t      struct vchiq_queue_bulk_transfer32 __user *argp)\n{\n\tstruct vchiq_queue_bulk_transfer32 args32;\n\tstruct vchiq_queue_bulk_transfer args;\n\tenum vchiq_bulk_dir dir = (cmd == VCHIQ_IOC_QUEUE_BULK_TRANSMIT32) ?\n\t\t\t\t  VCHIQ_BULK_TRANSMIT : VCHIQ_BULK_RECEIVE;\n\n\tif (copy_from_user(&args32, argp, sizeof(args32)))\n\t\treturn -EFAULT;\n\n\targs = (struct vchiq_queue_bulk_transfer) {\n\t\t.handle   = args32.handle,\n\t\t.data\t  = compat_ptr(args32.data),\n\t\t.size\t  = args32.size,\n\t\t.userdata = compat_ptr(args32.userdata),\n\t\t.mode\t  = args32.mode,\n\t};\n\n\treturn vchiq_irq_queue_bulk_tx_rx(file->private_data, &args,\n\t\t\t\t\t  dir, &argp->mode);\n}\n\nstruct vchiq_await_completion32 {\n\tunsigned int count;\n\tcompat_uptr_t buf;\n\tunsigned int msgbufsize;\n\tunsigned int msgbufcount;  \n\tcompat_uptr_t msgbufs;\n};\n\n#define VCHIQ_IOC_AWAIT_COMPLETION32 \\\n\t_IOWR(VCHIQ_IOC_MAGIC, 7, struct vchiq_await_completion32)\n\nstatic long\nvchiq_compat_ioctl_await_completion(struct file *file,\n\t\t\t\t    unsigned int cmd,\n\t\t\t\t    struct vchiq_await_completion32 __user *argp)\n{\n\tstruct vchiq_await_completion args;\n\tstruct vchiq_await_completion32 args32;\n\n\tif (copy_from_user(&args32, argp, sizeof(args32)))\n\t\treturn -EFAULT;\n\n\targs = (struct vchiq_await_completion) {\n\t\t.count\t\t= args32.count,\n\t\t.buf\t\t= compat_ptr(args32.buf),\n\t\t.msgbufsize\t= args32.msgbufsize,\n\t\t.msgbufcount\t= args32.msgbufcount,\n\t\t.msgbufs\t= compat_ptr(args32.msgbufs),\n\t};\n\n\treturn vchiq_ioc_await_completion(file->private_data, &args,\n\t\t\t\t\t  &argp->msgbufcount);\n}\n\nstruct vchiq_dequeue_message32 {\n\tunsigned int handle;\n\tint blocking;\n\tunsigned int bufsize;\n\tcompat_uptr_t buf;\n};\n\n#define VCHIQ_IOC_DEQUEUE_MESSAGE32 \\\n\t_IOWR(VCHIQ_IOC_MAGIC, 8, struct vchiq_dequeue_message32)\n\nstatic long\nvchiq_compat_ioctl_dequeue_message(struct file *file,\n\t\t\t\t   unsigned int cmd,\n\t\t\t\t   struct vchiq_dequeue_message32 __user *arg)\n{\n\tstruct vchiq_dequeue_message32 args32;\n\tstruct vchiq_dequeue_message args;\n\n\tif (copy_from_user(&args32, arg, sizeof(args32)))\n\t\treturn -EFAULT;\n\n\targs = (struct vchiq_dequeue_message) {\n\t\t.handle\t\t= args32.handle,\n\t\t.blocking\t= args32.blocking,\n\t\t.bufsize\t= args32.bufsize,\n\t\t.buf\t\t= compat_ptr(args32.buf),\n\t};\n\n\treturn vchiq_ioc_dequeue_message(file->private_data, &args);\n}\n\nstruct vchiq_get_config32 {\n\tunsigned int config_size;\n\tcompat_uptr_t pconfig;\n};\n\n#define VCHIQ_IOC_GET_CONFIG32 \\\n\t_IOWR(VCHIQ_IOC_MAGIC, 10, struct vchiq_get_config32)\n\nstatic long\nvchiq_compat_ioctl_get_config(struct file *file,\n\t\t\t      unsigned int cmd,\n\t\t\t      struct vchiq_get_config32 __user *arg)\n{\n\tstruct vchiq_get_config32 args32;\n\tstruct vchiq_config config;\n\tvoid __user *ptr;\n\n\tif (copy_from_user(&args32, arg, sizeof(args32)))\n\t\treturn -EFAULT;\n\tif (args32.config_size > sizeof(config))\n\t\treturn -EINVAL;\n\n\tvchiq_get_config(&config);\n\tptr = compat_ptr(args32.pconfig);\n\tif (copy_to_user(ptr, &config, args32.config_size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long\nvchiq_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\n\tswitch (cmd) {\n\tcase VCHIQ_IOC_CREATE_SERVICE32:\n\t\treturn vchiq_compat_ioctl_create_service(file, cmd, argp);\n\tcase VCHIQ_IOC_QUEUE_MESSAGE32:\n\t\treturn vchiq_compat_ioctl_queue_message(file, cmd, argp);\n\tcase VCHIQ_IOC_QUEUE_BULK_TRANSMIT32:\n\tcase VCHIQ_IOC_QUEUE_BULK_RECEIVE32:\n\t\treturn vchiq_compat_ioctl_queue_bulk(file, cmd, argp);\n\tcase VCHIQ_IOC_AWAIT_COMPLETION32:\n\t\treturn vchiq_compat_ioctl_await_completion(file, cmd, argp);\n\tcase VCHIQ_IOC_DEQUEUE_MESSAGE32:\n\t\treturn vchiq_compat_ioctl_dequeue_message(file, cmd, argp);\n\tcase VCHIQ_IOC_GET_CONFIG32:\n\t\treturn vchiq_compat_ioctl_get_config(file, cmd, argp);\n\tdefault:\n\t\treturn vchiq_ioctl(file, cmd, (unsigned long)argp);\n\t}\n}\n\n#endif\n\nstatic int vchiq_open(struct inode *inode, struct file *file)\n{\n\tstruct vchiq_state *state = vchiq_get_state();\n\tstruct vchiq_instance *instance;\n\n\tvchiq_log_info(vchiq_arm_log_level, \"vchiq_open\");\n\n\tif (!state) {\n\t\tvchiq_log_error(vchiq_arm_log_level,\n\t\t\t\t\"vchiq has no connection to VideoCore\");\n\t\treturn -ENOTCONN;\n\t}\n\n\tinstance = kzalloc(sizeof(*instance), GFP_KERNEL);\n\tif (!instance)\n\t\treturn -ENOMEM;\n\n\tinstance->state = state;\n\tinstance->pid = current->tgid;\n\n\tvchiq_debugfs_add_instance(instance);\n\n\tinit_completion(&instance->insert_event);\n\tinit_completion(&instance->remove_event);\n\tmutex_init(&instance->completion_mutex);\n\tmutex_init(&instance->bulk_waiter_list_mutex);\n\tINIT_LIST_HEAD(&instance->bulk_waiter_list);\n\n\tfile->private_data = instance;\n\n\treturn 0;\n}\n\nstatic int vchiq_release(struct inode *inode, struct file *file)\n{\n\tstruct vchiq_instance *instance = file->private_data;\n\tstruct vchiq_state *state = vchiq_get_state();\n\tstruct vchiq_service *service;\n\tint ret = 0;\n\tint i;\n\n\tvchiq_log_info(vchiq_arm_log_level, \"%s: instance=%lx\", __func__,\n\t\t       (unsigned long)instance);\n\n\tif (!state) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\t \n\tvchiq_use_internal(instance->state, NULL, USE_TYPE_VCHIQ);\n\n\tmutex_lock(&instance->completion_mutex);\n\n\t \n\tinstance->closing = 1;\n\tcomplete(&instance->insert_event);\n\n\tmutex_unlock(&instance->completion_mutex);\n\n\t \n\tcomplete(&instance->remove_event);\n\n\t \n\ti = 0;\n\twhile ((service = next_service_by_instance(state, instance, &i))) {\n\t\tstruct user_service *user_service = service->base.userdata;\n\n\t\t \n\t\tcomplete(&user_service->remove_event);\n\n\t\tvchiq_terminate_service_internal(service);\n\t\tvchiq_service_put(service);\n\t}\n\n\t \n\ti = 0;\n\twhile ((service = next_service_by_instance(state, instance, &i))) {\n\t\tstruct user_service *user_service = service->base.userdata;\n\n\t\twait_for_completion(&service->remove_event);\n\n\t\tif (WARN_ON(service->srvstate != VCHIQ_SRVSTATE_FREE)) {\n\t\t\tvchiq_service_put(service);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock(&msg_queue_spinlock);\n\n\t\twhile (user_service->msg_remove != user_service->msg_insert) {\n\t\t\tstruct vchiq_header *header;\n\t\t\tint m = user_service->msg_remove & (MSG_QUEUE_SIZE - 1);\n\n\t\t\theader = user_service->msg_queue[m];\n\t\t\tuser_service->msg_remove++;\n\t\t\tspin_unlock(&msg_queue_spinlock);\n\n\t\t\tif (header)\n\t\t\t\tvchiq_release_message(instance, service->handle, header);\n\t\t\tspin_lock(&msg_queue_spinlock);\n\t\t}\n\n\t\tspin_unlock(&msg_queue_spinlock);\n\n\t\tvchiq_service_put(service);\n\t}\n\n\t \n\twhile (instance->completion_remove != instance->completion_insert) {\n\t\tstruct vchiq_completion_data_kernel *completion;\n\t\tstruct vchiq_service *service;\n\n\t\tcompletion = &instance->completions[instance->completion_remove\n\t\t\t\t\t\t    & (MAX_COMPLETIONS - 1)];\n\t\tservice = completion->service_userdata;\n\t\tif (completion->reason == VCHIQ_SERVICE_CLOSED) {\n\t\t\tstruct user_service *user_service =\n\t\t\t\t\t\t\tservice->base.userdata;\n\n\t\t\t \n\t\t\tif (instance->use_close_delivered)\n\t\t\t\tcomplete(&user_service->close_event);\n\t\t\tvchiq_service_put(service);\n\t\t}\n\t\tinstance->completion_remove++;\n\t}\n\n\t \n\tvchiq_release_internal(instance->state, NULL);\n\n\tfree_bulk_waiter(instance);\n\n\tvchiq_debugfs_remove_instance(instance);\n\n\tkfree(instance);\n\tfile->private_data = NULL;\n\nout:\n\treturn ret;\n}\n\nstatic ssize_t\nvchiq_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct dump_context context;\n\tint err;\n\n\tcontext.buf = buf;\n\tcontext.actual = 0;\n\tcontext.space = count;\n\tcontext.offset = *ppos;\n\n\terr = vchiq_dump_state(&context, &g_state);\n\tif (err)\n\t\treturn err;\n\n\t*ppos += context.actual;\n\n\treturn context.actual;\n}\n\nstatic const struct file_operations\nvchiq_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = vchiq_ioctl,\n#if defined(CONFIG_COMPAT)\n\t.compat_ioctl = vchiq_compat_ioctl,\n#endif\n\t.open = vchiq_open,\n\t.release = vchiq_release,\n\t.read = vchiq_read\n};\n\nstatic struct miscdevice vchiq_miscdev = {\n\t.fops = &vchiq_fops,\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"vchiq\",\n\n};\n\n \nint vchiq_register_chrdev(struct device *parent)\n{\n\tvchiq_miscdev.parent = parent;\n\n\treturn misc_register(&vchiq_miscdev);\n}\n\n \nvoid vchiq_deregister_chrdev(void)\n{\n\tmisc_deregister(&vchiq_miscdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}