{
  "module_name": "bcm2835-ctl.c",
  "hash_id": "4fdc9106ce7772621558a0579c697877b209c3b497978548475b259ffa27106a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vc04_services/bcm2835-audio/bcm2835-ctl.c",
  "human_readable_source": "\n \n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include <sound/asoundef.h>\n\n#include \"bcm2835.h\"\n\n \n#define CTRL_VOL_MAX 400\n#define CTRL_VOL_MIN -10239  \n\nstatic int bcm2835_audio_set_chip_ctls(struct bcm2835_chip *chip)\n{\n\tint i, err = 0;\n\n\t \n\tfor (i = 0; i < MAX_SUBSTREAMS; i++) {\n\t\tif (chip->alsa_stream[i]) {\n\t\t\terr = bcm2835_audio_set_ctls(chip->alsa_stream[i]);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int snd_bcm2835_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tif (kcontrol->private_value == PCM_PLAYBACK_VOLUME) {\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\t\tuinfo->count = 1;\n\t\tuinfo->value.integer.min = CTRL_VOL_MIN;\n\t\tuinfo->value.integer.max = CTRL_VOL_MAX;  \n\t} else if (kcontrol->private_value == PCM_PLAYBACK_MUTE) {\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\t\tuinfo->count = 1;\n\t\tuinfo->value.integer.min = 0;\n\t\tuinfo->value.integer.max = 1;\n\t} else if (kcontrol->private_value == PCM_PLAYBACK_DEVICE) {\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\t\tuinfo->count = 1;\n\t\tuinfo->value.integer.min = 0;\n\t\tuinfo->value.integer.max = AUDIO_DEST_MAX - 1;\n\t}\n\treturn 0;\n}\n\nstatic int snd_bcm2835_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&chip->audio_mutex);\n\n\tif (kcontrol->private_value == PCM_PLAYBACK_VOLUME)\n\t\tucontrol->value.integer.value[0] = chip->volume;\n\telse if (kcontrol->private_value == PCM_PLAYBACK_MUTE)\n\t\tucontrol->value.integer.value[0] = chip->mute;\n\telse if (kcontrol->private_value == PCM_PLAYBACK_DEVICE)\n\t\tucontrol->value.integer.value[0] = chip->dest;\n\n\tmutex_unlock(&chip->audio_mutex);\n\treturn 0;\n}\n\nstatic int snd_bcm2835_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);\n\tint val, *valp;\n\tint changed = 0;\n\n\tif (kcontrol->private_value == PCM_PLAYBACK_VOLUME)\n\t\tvalp = &chip->volume;\n\telse if (kcontrol->private_value == PCM_PLAYBACK_MUTE)\n\t\tvalp = &chip->mute;\n\telse if (kcontrol->private_value == PCM_PLAYBACK_DEVICE)\n\t\tvalp = &chip->dest;\n\telse\n\t\treturn -EINVAL;\n\n\tval = ucontrol->value.integer.value[0];\n\tmutex_lock(&chip->audio_mutex);\n\tif (val != *valp) {\n\t\t*valp = val;\n\t\tchanged = 1;\n\t\tif (bcm2835_audio_set_chip_ctls(chip))\n\t\t\tdev_err(chip->card->dev, \"Failed to set ALSA controls..\\n\");\n\t}\n\tmutex_unlock(&chip->audio_mutex);\n\treturn changed;\n}\n\nstatic DECLARE_TLV_DB_SCALE(snd_bcm2835_db_scale, CTRL_VOL_MIN, 1, 1);\n\nstatic const struct snd_kcontrol_new snd_bcm2835_ctl[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"PCM Playback Volume\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t.private_value = PCM_PLAYBACK_VOLUME,\n\t\t.info = snd_bcm2835_ctl_info,\n\t\t.get = snd_bcm2835_ctl_get,\n\t\t.put = snd_bcm2835_ctl_put,\n\t\t.tlv = {.p = snd_bcm2835_db_scale}\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"PCM Playback Switch\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.private_value = PCM_PLAYBACK_MUTE,\n\t\t.info = snd_bcm2835_ctl_info,\n\t\t.get = snd_bcm2835_ctl_get,\n\t\t.put = snd_bcm2835_ctl_put,\n\t},\n};\n\nstatic int snd_bcm2835_spdif_default_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_bcm2835_spdif_default_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);\n\tint i;\n\n\tmutex_lock(&chip->audio_mutex);\n\n\tfor (i = 0; i < 4; i++)\n\t\tucontrol->value.iec958.status[i] =\n\t\t\t(chip->spdif_status >> (i * 8)) & 0xff;\n\n\tmutex_unlock(&chip->audio_mutex);\n\treturn 0;\n}\n\nstatic int snd_bcm2835_spdif_default_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int val = 0;\n\tint i, change;\n\n\tmutex_lock(&chip->audio_mutex);\n\n\tfor (i = 0; i < 4; i++)\n\t\tval |= (unsigned int)ucontrol->value.iec958.status[i] << (i * 8);\n\n\tchange = val != chip->spdif_status;\n\tchip->spdif_status = val;\n\n\tmutex_unlock(&chip->audio_mutex);\n\treturn change;\n}\n\nstatic int snd_bcm2835_spdif_mask_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_bcm2835_spdif_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\t \n\tucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_bcm2835_spdif[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t\t.info = snd_bcm2835_spdif_default_info,\n\t\t.get = snd_bcm2835_spdif_default_get,\n\t\t.put = snd_bcm2835_spdif_default_put\n\t},\n\t{\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, CON_MASK),\n\t\t.info = snd_bcm2835_spdif_mask_info,\n\t\t.get = snd_bcm2835_spdif_mask_get,\n\t},\n};\n\nstatic int create_ctls(struct bcm2835_chip *chip, size_t size,\n\t\t       const struct snd_kcontrol_new *kctls)\n{\n\tint i, err;\n\n\tfor (i = 0; i < size; i++) {\n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&kctls[i], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nint snd_bcm2835_new_headphones_ctl(struct bcm2835_chip *chip)\n{\n\tstrscpy(chip->card->mixername, \"Broadcom Mixer\", sizeof(chip->card->mixername));\n\treturn create_ctls(chip, ARRAY_SIZE(snd_bcm2835_ctl),\n\t\t\t   snd_bcm2835_ctl);\n}\n\nint snd_bcm2835_new_hdmi_ctl(struct bcm2835_chip *chip)\n{\n\tint err;\n\n\tstrscpy(chip->card->mixername, \"Broadcom Mixer\", sizeof(chip->card->mixername));\n\terr = create_ctls(chip, ARRAY_SIZE(snd_bcm2835_ctl), snd_bcm2835_ctl);\n\tif (err < 0)\n\t\treturn err;\n\treturn create_ctls(chip, ARRAY_SIZE(snd_bcm2835_spdif),\n\t\t\t   snd_bcm2835_spdif);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}