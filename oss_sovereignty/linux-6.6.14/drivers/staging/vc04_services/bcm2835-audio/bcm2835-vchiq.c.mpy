{
  "module_name": "bcm2835-vchiq.c",
  "hash_id": "967f4b4e81554c8bd990541d4e90b3da7acf4286bc7ce9cb7c0799484b3f5817",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vc04_services/bcm2835-audio/bcm2835-vchiq.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/completion.h>\n#include \"bcm2835.h\"\n#include \"vc_vchi_audioserv_defs.h\"\n\nstruct bcm2835_audio_instance {\n\tstruct device *dev;\n\tunsigned int service_handle;\n\tstruct completion msg_avail_comp;\n\tstruct mutex vchi_mutex;  \n\tstruct bcm2835_alsa_stream *alsa_stream;\n\tint result;\n\tunsigned int max_packet;\n\tshort peer_version;\n};\n\nstatic bool force_bulk;\nmodule_param(force_bulk, bool, 0444);\nMODULE_PARM_DESC(force_bulk, \"Force use of vchiq bulk for audio\");\n\nstatic void bcm2835_audio_lock(struct bcm2835_audio_instance *instance)\n{\n\tmutex_lock(&instance->vchi_mutex);\n\tvchiq_use_service(instance->alsa_stream->chip->vchi_ctx->instance,\n\t\t\t  instance->service_handle);\n}\n\nstatic void bcm2835_audio_unlock(struct bcm2835_audio_instance *instance)\n{\n\tvchiq_release_service(instance->alsa_stream->chip->vchi_ctx->instance,\n\t\t\t      instance->service_handle);\n\tmutex_unlock(&instance->vchi_mutex);\n}\n\nstatic int bcm2835_audio_send_msg_locked(struct bcm2835_audio_instance *instance,\n\t\t\t\t\t struct vc_audio_msg *m, bool wait)\n{\n\tint status;\n\n\tif (wait) {\n\t\tinstance->result = -1;\n\t\tinit_completion(&instance->msg_avail_comp);\n\t}\n\n\tstatus = vchiq_queue_kernel_message(instance->alsa_stream->chip->vchi_ctx->instance,\n\t\t\t\t\t    instance->service_handle, m, sizeof(*m));\n\tif (status) {\n\t\tdev_err(instance->dev,\n\t\t\t\"vchi message queue failed: %d, msg=%d\\n\",\n\t\t\tstatus, m->type);\n\t\treturn -EIO;\n\t}\n\n\tif (wait) {\n\t\tif (!wait_for_completion_timeout(&instance->msg_avail_comp,\n\t\t\t\t\t\t msecs_to_jiffies(10 * 1000))) {\n\t\t\tdev_err(instance->dev,\n\t\t\t\t\"vchi message timeout, msg=%d\\n\", m->type);\n\t\t\treturn -ETIMEDOUT;\n\t\t} else if (instance->result) {\n\t\t\tdev_err(instance->dev,\n\t\t\t\t\"vchi message response error:%d, msg=%d\\n\",\n\t\t\t\tinstance->result, m->type);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm2835_audio_send_msg(struct bcm2835_audio_instance *instance,\n\t\t\t\t  struct vc_audio_msg *m, bool wait)\n{\n\tint err;\n\n\tbcm2835_audio_lock(instance);\n\terr = bcm2835_audio_send_msg_locked(instance, m, wait);\n\tbcm2835_audio_unlock(instance);\n\treturn err;\n}\n\nstatic int bcm2835_audio_send_simple(struct bcm2835_audio_instance *instance,\n\t\t\t\t     int type, bool wait)\n{\n\tstruct vc_audio_msg m = { .type = type };\n\n\treturn bcm2835_audio_send_msg(instance, &m, wait);\n}\n\nstatic int audio_vchi_callback(struct vchiq_instance *vchiq_instance,\n\t\t\t       enum vchiq_reason reason,\n\t\t\t       struct vchiq_header *header,\n\t\t\t       unsigned int handle, void *userdata)\n{\n\tstruct bcm2835_audio_instance *instance = vchiq_get_service_userdata(vchiq_instance,\n\t\t\t\t\t\t\t\t\t     handle);\n\tstruct vc_audio_msg *m;\n\n\tif (reason != VCHIQ_MESSAGE_AVAILABLE)\n\t\treturn 0;\n\n\tm = (void *)header->data;\n\tif (m->type == VC_AUDIO_MSG_TYPE_RESULT) {\n\t\tinstance->result = m->result.success;\n\t\tcomplete(&instance->msg_avail_comp);\n\t} else if (m->type == VC_AUDIO_MSG_TYPE_COMPLETE) {\n\t\tif (m->complete.cookie1 != VC_AUDIO_WRITE_COOKIE1 ||\n\t\t    m->complete.cookie2 != VC_AUDIO_WRITE_COOKIE2)\n\t\t\tdev_err(instance->dev, \"invalid cookie\\n\");\n\t\telse\n\t\t\tbcm2835_playback_fifo(instance->alsa_stream,\n\t\t\t\t\t      m->complete.count);\n\t} else {\n\t\tdev_err(instance->dev, \"unexpected callback type=%d\\n\", m->type);\n\t}\n\n\tvchiq_release_message(vchiq_instance, instance->service_handle, header);\n\treturn 0;\n}\n\nstatic int\nvc_vchi_audio_init(struct vchiq_instance *vchiq_instance,\n\t\t   struct bcm2835_audio_instance *instance)\n{\n\tstruct vchiq_service_params_kernel params = {\n\t\t.version\t\t= VC_AUDIOSERV_VER,\n\t\t.version_min\t\t= VC_AUDIOSERV_MIN_VER,\n\t\t.fourcc\t\t\t= VCHIQ_MAKE_FOURCC('A', 'U', 'D', 'S'),\n\t\t.callback\t\t= audio_vchi_callback,\n\t\t.userdata\t\t= instance,\n\t};\n\tint status;\n\n\t \n\tstatus = vchiq_open_service(vchiq_instance, &params,\n\t\t\t\t    &instance->service_handle);\n\n\tif (status) {\n\t\tdev_err(instance->dev,\n\t\t\t\"failed to open VCHI service connection (status=%d)\\n\",\n\t\t\tstatus);\n\t\treturn -EPERM;\n\t}\n\n\t \n\tvchiq_release_service(instance->alsa_stream->chip->vchi_ctx->instance,\n\t\t\t      instance->service_handle);\n\n\treturn 0;\n}\n\nstatic void vc_vchi_audio_deinit(struct bcm2835_audio_instance *instance)\n{\n\tint status;\n\n\tmutex_lock(&instance->vchi_mutex);\n\tvchiq_use_service(instance->alsa_stream->chip->vchi_ctx->instance,\n\t\t\t  instance->service_handle);\n\n\t \n\tstatus = vchiq_close_service(instance->alsa_stream->chip->vchi_ctx->instance,\n\t\t\t\t     instance->service_handle);\n\tif (status) {\n\t\tdev_err(instance->dev,\n\t\t\t\"failed to close VCHI service connection (status=%d)\\n\",\n\t\t\tstatus);\n\t}\n\n\tmutex_unlock(&instance->vchi_mutex);\n}\n\nint bcm2835_new_vchi_ctx(struct device *dev, struct bcm2835_vchi_ctx *vchi_ctx)\n{\n\tint ret;\n\n\t \n\tret = vchiq_initialise(&vchi_ctx->instance);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialise VCHI instance (ret=%d)\\n\",\n\t\t\tret);\n\t\treturn -EIO;\n\t}\n\n\tret = vchiq_connect(vchi_ctx->instance);\n\tif (ret) {\n\t\tdev_dbg(dev, \"failed to connect VCHI instance (ret=%d)\\n\",\n\t\t\tret);\n\n\t\tkfree(vchi_ctx->instance);\n\t\tvchi_ctx->instance = NULL;\n\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nvoid bcm2835_free_vchi_ctx(struct bcm2835_vchi_ctx *vchi_ctx)\n{\n\t \n\tWARN_ON(vchiq_shutdown(vchi_ctx->instance));\n\n\tvchi_ctx->instance = NULL;\n}\n\nint bcm2835_audio_open(struct bcm2835_alsa_stream *alsa_stream)\n{\n\tstruct bcm2835_vchi_ctx *vchi_ctx = alsa_stream->chip->vchi_ctx;\n\tstruct bcm2835_audio_instance *instance;\n\tint err;\n\n\t \n\tinstance = kzalloc(sizeof(*instance), GFP_KERNEL);\n\tif (!instance)\n\t\treturn -ENOMEM;\n\tmutex_init(&instance->vchi_mutex);\n\tinstance->dev = alsa_stream->chip->dev;\n\tinstance->alsa_stream = alsa_stream;\n\talsa_stream->instance = instance;\n\n\terr = vc_vchi_audio_init(vchi_ctx->instance,\n\t\t\t\t instance);\n\tif (err < 0)\n\t\tgoto free_instance;\n\n\terr = bcm2835_audio_send_simple(instance, VC_AUDIO_MSG_TYPE_OPEN,\n\t\t\t\t\tfalse);\n\tif (err < 0)\n\t\tgoto deinit;\n\n\tbcm2835_audio_lock(instance);\n\tvchiq_get_peer_version(vchi_ctx->instance, instance->service_handle,\n\t\t\t       &instance->peer_version);\n\tbcm2835_audio_unlock(instance);\n\tif (instance->peer_version < 2 || force_bulk)\n\t\tinstance->max_packet = 0;  \n\telse\n\t\tinstance->max_packet = 4000;\n\n\treturn 0;\n\n deinit:\n\tvc_vchi_audio_deinit(instance);\n free_instance:\n\talsa_stream->instance = NULL;\n\tkfree(instance);\n\treturn err;\n}\n\nint bcm2835_audio_set_ctls(struct bcm2835_alsa_stream *alsa_stream)\n{\n\tstruct bcm2835_chip *chip = alsa_stream->chip;\n\tstruct vc_audio_msg m = {};\n\n\tm.type = VC_AUDIO_MSG_TYPE_CONTROL;\n\tm.control.dest = chip->dest;\n\tif (!chip->mute)\n\t\tm.control.volume = CHIP_MIN_VOLUME;\n\telse\n\t\tm.control.volume = alsa2chip(chip->volume);\n\n\treturn bcm2835_audio_send_msg(alsa_stream->instance, &m, true);\n}\n\nint bcm2835_audio_set_params(struct bcm2835_alsa_stream *alsa_stream,\n\t\t\t     unsigned int channels, unsigned int samplerate,\n\t\t\t     unsigned int bps)\n{\n\tstruct vc_audio_msg m = {\n\t\t .type = VC_AUDIO_MSG_TYPE_CONFIG,\n\t\t .config.channels = channels,\n\t\t .config.samplerate = samplerate,\n\t\t .config.bps = bps,\n\t};\n\tint err;\n\n\t \n\terr = bcm2835_audio_set_ctls(alsa_stream);\n\tif (err)\n\t\treturn err;\n\n\treturn bcm2835_audio_send_msg(alsa_stream->instance, &m, true);\n}\n\nint bcm2835_audio_start(struct bcm2835_alsa_stream *alsa_stream)\n{\n\treturn bcm2835_audio_send_simple(alsa_stream->instance,\n\t\t\t\t\t VC_AUDIO_MSG_TYPE_START, false);\n}\n\nint bcm2835_audio_stop(struct bcm2835_alsa_stream *alsa_stream)\n{\n\treturn bcm2835_audio_send_simple(alsa_stream->instance,\n\t\t\t\t\t VC_AUDIO_MSG_TYPE_STOP, false);\n}\n\n \nint bcm2835_audio_drain(struct bcm2835_alsa_stream *alsa_stream)\n{\n\tstruct vc_audio_msg m = {\n\t\t.type = VC_AUDIO_MSG_TYPE_STOP,\n\t\t.stop.draining = 1,\n\t};\n\n\treturn bcm2835_audio_send_msg(alsa_stream->instance, &m, false);\n}\n\nint bcm2835_audio_close(struct bcm2835_alsa_stream *alsa_stream)\n{\n\tstruct bcm2835_audio_instance *instance = alsa_stream->instance;\n\tint err;\n\n\terr = bcm2835_audio_send_simple(alsa_stream->instance,\n\t\t\t\t\tVC_AUDIO_MSG_TYPE_CLOSE, true);\n\n\t \n\tvc_vchi_audio_deinit(instance);\n\talsa_stream->instance = NULL;\n\tkfree(instance);\n\n\treturn err;\n}\n\nint bcm2835_audio_write(struct bcm2835_alsa_stream *alsa_stream,\n\t\t\tunsigned int size, void *src)\n{\n\tstruct bcm2835_audio_instance *instance = alsa_stream->instance;\n\tstruct bcm2835_vchi_ctx *vchi_ctx = alsa_stream->chip->vchi_ctx;\n\tstruct vchiq_instance *vchiq_instance = vchi_ctx->instance;\n\tstruct vc_audio_msg m = {\n\t\t.type = VC_AUDIO_MSG_TYPE_WRITE,\n\t\t.write.count = size,\n\t\t.write.max_packet = instance->max_packet,\n\t\t.write.cookie1 = VC_AUDIO_WRITE_COOKIE1,\n\t\t.write.cookie2 = VC_AUDIO_WRITE_COOKIE2,\n\t};\n\tunsigned int count;\n\tint err, status;\n\n\tif (!size)\n\t\treturn 0;\n\n\tbcm2835_audio_lock(instance);\n\terr = bcm2835_audio_send_msg_locked(instance, &m, false);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tcount = size;\n\tif (!instance->max_packet) {\n\t\t \n\t\tstatus = vchiq_bulk_transmit(vchiq_instance, instance->service_handle, src, count,\n\t\t\t\t\t     NULL, VCHIQ_BULK_MODE_BLOCKING);\n\t} else {\n\t\twhile (count > 0) {\n\t\t\tint bytes = min(instance->max_packet, count);\n\n\t\t\tstatus = vchiq_queue_kernel_message(vchiq_instance,\n\t\t\t\t\t\t\t    instance->service_handle, src, bytes);\n\t\t\tsrc += bytes;\n\t\t\tcount -= bytes;\n\t\t}\n\t}\n\n\tif (status) {\n\t\tdev_err(instance->dev,\n\t\t\t\"failed on %d bytes transfer (status=%d)\\n\",\n\t\t\tsize, status);\n\t\terr = -EIO;\n\t}\n\n unlock:\n\tbcm2835_audio_unlock(instance);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}