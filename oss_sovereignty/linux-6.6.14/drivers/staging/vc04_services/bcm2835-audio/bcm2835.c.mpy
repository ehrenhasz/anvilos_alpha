{
  "module_name": "bcm2835.c",
  "hash_id": "91716fdcbc824e7b717140a40d044404616068036847df7d49da267bb7ca42a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vc04_services/bcm2835-audio/bcm2835.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include \"bcm2835.h\"\n\nstatic bool enable_hdmi;\nstatic bool enable_headphones = true;\nstatic int num_channels = MAX_SUBSTREAMS;\n\nmodule_param(enable_hdmi, bool, 0444);\nMODULE_PARM_DESC(enable_hdmi, \"Enables HDMI virtual audio device\");\nmodule_param(enable_headphones, bool, 0444);\nMODULE_PARM_DESC(enable_headphones, \"Enables Headphones virtual audio device\");\nmodule_param(num_channels, int, 0644);\nMODULE_PARM_DESC(num_channels, \"Number of audio channels (default: 8)\");\n\nstatic void bcm2835_devm_free_vchi_ctx(struct device *dev, void *res)\n{\n\tstruct bcm2835_vchi_ctx *vchi_ctx = res;\n\n\tbcm2835_free_vchi_ctx(vchi_ctx);\n}\n\nstatic int bcm2835_devm_add_vchi_ctx(struct device *dev)\n{\n\tstruct bcm2835_vchi_ctx *vchi_ctx;\n\tint ret;\n\n\tvchi_ctx = devres_alloc(bcm2835_devm_free_vchi_ctx, sizeof(*vchi_ctx),\n\t\t\t\tGFP_KERNEL);\n\tif (!vchi_ctx)\n\t\treturn -ENOMEM;\n\n\tret = bcm2835_new_vchi_ctx(dev, vchi_ctx);\n\tif (ret) {\n\t\tdevres_free(vchi_ctx);\n\t\treturn ret;\n\t}\n\n\tdevres_add(dev, vchi_ctx);\n\n\treturn 0;\n}\n\nstruct bcm2835_audio_driver {\n\tstruct device_driver driver;\n\tconst char *shortname;\n\tconst char *longname;\n\tint minchannels;\n\tint (*newpcm)(struct bcm2835_chip *chip, const char *name,\n\t\t      enum snd_bcm2835_route route, u32 numchannels);\n\tint (*newctl)(struct bcm2835_chip *chip);\n\tenum snd_bcm2835_route route;\n};\n\nstatic int bcm2835_audio_dual_newpcm(struct bcm2835_chip *chip,\n\t\t\t\t     const char *name,\n\t\t\t\t     enum snd_bcm2835_route route,\n\t\t\t\t     u32 numchannels)\n{\n\tint err;\n\n\terr = snd_bcm2835_new_pcm(chip, name, 0, route,\n\t\t\t\t  numchannels, false);\n\n\tif (err)\n\t\treturn err;\n\n\terr = snd_bcm2835_new_pcm(chip, \"IEC958\", 1, route, 1, true);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int bcm2835_audio_simple_newpcm(struct bcm2835_chip *chip,\n\t\t\t\t       const char *name,\n\t\t\t\t       enum snd_bcm2835_route route,\n\t\t\t\t       u32 numchannels)\n{\n\treturn snd_bcm2835_new_pcm(chip, name, 0, route, numchannels, false);\n}\n\nstatic struct bcm2835_audio_driver bcm2835_audio_hdmi = {\n\t.driver = {\n\t\t.name = \"bcm2835_hdmi\",\n\t\t.owner = THIS_MODULE,\n\t},\n\t.shortname = \"bcm2835 HDMI\",\n\t.longname  = \"bcm2835 HDMI\",\n\t.minchannels = 1,\n\t.newpcm = bcm2835_audio_dual_newpcm,\n\t.newctl = snd_bcm2835_new_hdmi_ctl,\n\t.route = AUDIO_DEST_HDMI\n};\n\nstatic struct bcm2835_audio_driver bcm2835_audio_headphones = {\n\t.driver = {\n\t\t.name = \"bcm2835_headphones\",\n\t\t.owner = THIS_MODULE,\n\t},\n\t.shortname = \"bcm2835 Headphones\",\n\t.longname  = \"bcm2835 Headphones\",\n\t.minchannels = 1,\n\t.newpcm = bcm2835_audio_simple_newpcm,\n\t.newctl = snd_bcm2835_new_headphones_ctl,\n\t.route = AUDIO_DEST_HEADPHONES\n};\n\nstruct bcm2835_audio_drivers {\n\tstruct bcm2835_audio_driver *audio_driver;\n\tconst bool *is_enabled;\n};\n\nstatic struct bcm2835_audio_drivers children_devices[] = {\n\t{\n\t\t.audio_driver = &bcm2835_audio_hdmi,\n\t\t.is_enabled = &enable_hdmi,\n\t},\n\t{\n\t\t.audio_driver = &bcm2835_audio_headphones,\n\t\t.is_enabled = &enable_headphones,\n\t},\n};\n\nstatic void bcm2835_card_free(void *data)\n{\n\tsnd_card_free(data);\n}\n\nstatic int snd_add_child_device(struct device *dev,\n\t\t\t\tstruct bcm2835_audio_driver *audio_driver,\n\t\t\t\tu32 numchans)\n{\n\tstruct bcm2835_chip *chip;\n\tstruct snd_card *card;\n\tint err;\n\n\terr = snd_card_new(dev, -1, NULL, THIS_MODULE, sizeof(*chip), &card);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Failed to create card\");\n\t\treturn err;\n\t}\n\n\tchip = card->private_data;\n\tchip->card = card;\n\tchip->dev = dev;\n\tmutex_init(&chip->audio_mutex);\n\n\tchip->vchi_ctx = devres_find(dev,\n\t\t\t\t     bcm2835_devm_free_vchi_ctx, NULL, NULL);\n\tif (!chip->vchi_ctx) {\n\t\terr = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tstrscpy(card->driver, audio_driver->driver.name, sizeof(card->driver));\n\tstrscpy(card->shortname, audio_driver->shortname, sizeof(card->shortname));\n\tstrscpy(card->longname, audio_driver->longname, sizeof(card->longname));\n\n\terr = audio_driver->newpcm(chip, audio_driver->shortname,\n\t\taudio_driver->route,\n\t\tnumchans);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to create pcm, error %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\terr = audio_driver->newctl(chip);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to create controls, error %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\terr = snd_card_register(card);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register card, error %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tdev_set_drvdata(dev, chip);\n\n\terr = devm_add_action(dev, bcm2835_card_free, card);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Failed to add devm action, err %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tdev_info(dev, \"card created with %d channels\\n\", numchans);\n\treturn 0;\n\n error:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic int snd_add_child_devices(struct device *device, u32 numchans)\n{\n\tint extrachannels_per_driver = 0;\n\tint extrachannels_remainder = 0;\n\tint count_devices = 0;\n\tint extrachannels = 0;\n\tint minchannels = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(children_devices); i++)\n\t\tif (*children_devices[i].is_enabled)\n\t\t\tcount_devices++;\n\n\tif (!count_devices)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(children_devices); i++)\n\t\tif (*children_devices[i].is_enabled)\n\t\t\tminchannels +=\n\t\t\t\tchildren_devices[i].audio_driver->minchannels;\n\n\tif (minchannels < numchans) {\n\t\textrachannels = numchans - minchannels;\n\t\textrachannels_per_driver = extrachannels / count_devices;\n\t\textrachannels_remainder = extrachannels % count_devices;\n\t}\n\n\tdev_dbg(device, \"minchannels %d\\n\", minchannels);\n\tdev_dbg(device, \"extrachannels %d\\n\", extrachannels);\n\tdev_dbg(device, \"extrachannels_per_driver %d\\n\",\n\t\textrachannels_per_driver);\n\tdev_dbg(device, \"extrachannels_remainder %d\\n\",\n\t\textrachannels_remainder);\n\n\tfor (i = 0; i < ARRAY_SIZE(children_devices); i++) {\n\t\tstruct bcm2835_audio_driver *audio_driver;\n\t\tint numchannels_this_device;\n\t\tint err;\n\n\t\tif (!*children_devices[i].is_enabled)\n\t\t\tcontinue;\n\n\t\taudio_driver = children_devices[i].audio_driver;\n\n\t\tif (audio_driver->minchannels > numchans) {\n\t\t\tdev_err(device,\n\t\t\t\t\"Out of channels, needed %d but only %d left\\n\",\n\t\t\t\taudio_driver->minchannels,\n\t\t\t\tnumchans);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnumchannels_this_device =\n\t\t\taudio_driver->minchannels + extrachannels_per_driver +\n\t\t\textrachannels_remainder;\n\t\textrachannels_remainder = 0;\n\n\t\tnumchans -= numchannels_this_device;\n\n\t\terr = snd_add_child_device(device, audio_driver,\n\t\t\t\t\t   numchannels_this_device);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_bcm2835_alsa_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint err;\n\n\tif (num_channels <= 0 || num_channels > MAX_SUBSTREAMS) {\n\t\tnum_channels = MAX_SUBSTREAMS;\n\t\tdev_warn(dev, \"Illegal num_channels value, will use %u\\n\",\n\t\t\t num_channels);\n\t}\n\n\terr = bcm2835_devm_add_vchi_ctx(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = snd_add_child_devices(dev, num_channels);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\nstatic int snd_bcm2835_alsa_suspend(struct platform_device *pdev,\n\t\t\t\t    pm_message_t state)\n{\n\treturn 0;\n}\n\nstatic int snd_bcm2835_alsa_resume(struct platform_device *pdev)\n{\n\treturn 0;\n}\n\n#endif\n\nstatic struct platform_driver bcm2835_alsa_driver = {\n\t.probe = snd_bcm2835_alsa_probe,\n#ifdef CONFIG_PM\n\t.suspend = snd_bcm2835_alsa_suspend,\n\t.resume = snd_bcm2835_alsa_resume,\n#endif\n\t.driver = {\n\t\t.name = \"bcm2835_audio\",\n\t},\n};\nmodule_platform_driver(bcm2835_alsa_driver);\n\nMODULE_AUTHOR(\"Dom Cobley\");\nMODULE_DESCRIPTION(\"Alsa driver for BCM2835 chip\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:bcm2835_audio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}