{
  "module_name": "bcm2835-pcm.c",
  "hash_id": "41820d8efdc7831afd584dfabbc900fe1bebbb5586f91f149269fbcec06518ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vc04_services/bcm2835-audio/bcm2835-pcm.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n\n#include <sound/asoundef.h>\n\n#include \"bcm2835.h\"\n\n \nstatic const struct snd_pcm_hardware snd_bcm2835_playback_hw = {\n\t.info = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\t SNDRV_PCM_INFO_SYNC_APPLPTR | SNDRV_PCM_INFO_BATCH),\n\t.formats = SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates = SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_192000,\n\t.rate_min = 8000,\n\t.rate_max = 192000,\n\t.channels_min = 1,\n\t.channels_max = 8,\n\t.buffer_bytes_max = 512 * 1024,\n\t.period_bytes_min = 1 * 1024,\n\t.period_bytes_max = 512 * 1024,\n\t.periods_min = 1,\n\t.periods_max = 128,\n};\n\nstatic const struct snd_pcm_hardware snd_bcm2835_playback_spdif_hw = {\n\t.info = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\t SNDRV_PCM_INFO_SYNC_APPLPTR | SNDRV_PCM_INFO_BATCH),\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates = SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_44100 |\n\tSNDRV_PCM_RATE_48000,\n\t.rate_min = 44100,\n\t.rate_max = 48000,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.buffer_bytes_max = 128 * 1024,\n\t.period_bytes_min = 1 * 1024,\n\t.period_bytes_max = 128 * 1024,\n\t.periods_min = 1,\n\t.periods_max = 128,\n};\n\nstatic void snd_bcm2835_playback_free(struct snd_pcm_runtime *runtime)\n{\n\tkfree(runtime->private_data);\n}\n\nvoid bcm2835_playback_fifo(struct bcm2835_alsa_stream *alsa_stream,\n\t\t\t   unsigned int bytes)\n{\n\tstruct snd_pcm_substream *substream = alsa_stream->substream;\n\tunsigned int pos;\n\n\tif (!alsa_stream->period_size)\n\t\treturn;\n\n\tif (bytes >= alsa_stream->buffer_size) {\n\t\tsnd_pcm_stream_lock(substream);\n\t\tsnd_pcm_stop(substream,\n\t\t\t     alsa_stream->draining ?\n\t\t\t     SNDRV_PCM_STATE_SETUP :\n\t\t\t     SNDRV_PCM_STATE_XRUN);\n\t\tsnd_pcm_stream_unlock(substream);\n\t\treturn;\n\t}\n\n\tpos = atomic_read(&alsa_stream->pos);\n\tpos += bytes;\n\tpos %= alsa_stream->buffer_size;\n\tatomic_set(&alsa_stream->pos, pos);\n\n\talsa_stream->period_offset += bytes;\n\talsa_stream->interpolate_start = ktime_get();\n\tif (alsa_stream->period_offset >= alsa_stream->period_size) {\n\t\talsa_stream->period_offset %= alsa_stream->period_size;\n\t\tsnd_pcm_period_elapsed(substream);\n\t}\n}\n\n \nstatic int snd_bcm2835_playback_open_generic(struct snd_pcm_substream *substream, int spdif)\n{\n\tstruct bcm2835_chip *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct bcm2835_alsa_stream *alsa_stream;\n\tint idx;\n\tint err;\n\n\tmutex_lock(&chip->audio_mutex);\n\tidx = substream->number;\n\n\tif (spdif && chip->opened) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t} else if (!spdif && (chip->opened & (1 << idx))) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (idx >= MAX_SUBSTREAMS) {\n\t\tdev_err(chip->dev,\n\t\t\t\"substream(%d) device doesn't exist max(%d) substreams allowed\\n\",\n\t\t\tidx, MAX_SUBSTREAMS);\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\talsa_stream = kzalloc(sizeof(*alsa_stream), GFP_KERNEL);\n\tif (!alsa_stream) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\talsa_stream->chip = chip;\n\talsa_stream->substream = substream;\n\talsa_stream->idx = idx;\n\n\terr = bcm2835_audio_open(alsa_stream);\n\tif (err) {\n\t\tkfree(alsa_stream);\n\t\tgoto out;\n\t}\n\truntime->private_data = alsa_stream;\n\truntime->private_free = snd_bcm2835_playback_free;\n\tif (spdif) {\n\t\truntime->hw = snd_bcm2835_playback_spdif_hw;\n\t} else {\n\t\t \n\t\tchip->spdif_status = 0;\n\t\truntime->hw = snd_bcm2835_playback_hw;\n\t}\n\t \n\tsnd_pcm_hw_constraint_step(runtime,\n\t\t\t\t   0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t   16);\n\n\t \n\tsnd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t     SNDRV_PCM_HW_PARAM_PERIOD_TIME,\n\t\t\t\t     10 * 1000, UINT_MAX);\n\n\tchip->alsa_stream[idx] = alsa_stream;\n\n\tchip->opened |= (1 << idx);\n\nout:\n\tmutex_unlock(&chip->audio_mutex);\n\n\treturn err;\n}\n\nstatic int snd_bcm2835_playback_open(struct snd_pcm_substream *substream)\n{\n\treturn snd_bcm2835_playback_open_generic(substream, 0);\n}\n\nstatic int snd_bcm2835_playback_spdif_open(struct snd_pcm_substream *substream)\n{\n\treturn snd_bcm2835_playback_open_generic(substream, 1);\n}\n\nstatic int snd_bcm2835_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct bcm2835_alsa_stream *alsa_stream;\n\tstruct snd_pcm_runtime *runtime;\n\tstruct bcm2835_chip *chip;\n\n\tchip = snd_pcm_substream_chip(substream);\n\tmutex_lock(&chip->audio_mutex);\n\truntime = substream->runtime;\n\talsa_stream = runtime->private_data;\n\n\talsa_stream->period_size = 0;\n\talsa_stream->buffer_size = 0;\n\n\tbcm2835_audio_close(alsa_stream);\n\talsa_stream->chip->alsa_stream[alsa_stream->idx] = NULL;\n\t \n\n\tchip->opened &= ~(1 << substream->number);\n\n\tmutex_unlock(&chip->audio_mutex);\n\n\treturn 0;\n}\n\nstatic int snd_bcm2835_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct bcm2835_chip *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct bcm2835_alsa_stream *alsa_stream = runtime->private_data;\n\tint channels;\n\tint err;\n\n\t \n\tif (chip->spdif_status & IEC958_AES0_NONAUDIO)\n\t\tchannels = 0;\n\telse\n\t\tchannels = runtime->channels;\n\n\terr = bcm2835_audio_set_params(alsa_stream, channels,\n\t\t\t\t       runtime->rate,\n\t\t\t\t       snd_pcm_format_width(runtime->format));\n\tif (err < 0)\n\t\treturn err;\n\n\tmemset(&alsa_stream->pcm_indirect, 0, sizeof(alsa_stream->pcm_indirect));\n\n\talsa_stream->pcm_indirect.hw_buffer_size =\n\t\talsa_stream->pcm_indirect.sw_buffer_size =\n\t\tsnd_pcm_lib_buffer_bytes(substream);\n\n\talsa_stream->buffer_size = snd_pcm_lib_buffer_bytes(substream);\n\talsa_stream->period_size = snd_pcm_lib_period_bytes(substream);\n\tatomic_set(&alsa_stream->pos, 0);\n\talsa_stream->period_offset = 0;\n\talsa_stream->draining = false;\n\talsa_stream->interpolate_start = ktime_get();\n\n\treturn 0;\n}\n\nstatic void snd_bcm2835_pcm_transfer(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_indirect *rec, size_t bytes)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct bcm2835_alsa_stream *alsa_stream = runtime->private_data;\n\tvoid *src = (void *)(substream->runtime->dma_area + rec->sw_data);\n\n\tbcm2835_audio_write(alsa_stream, bytes, src);\n}\n\nstatic int snd_bcm2835_pcm_ack(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct bcm2835_alsa_stream *alsa_stream = runtime->private_data;\n\tstruct snd_pcm_indirect *pcm_indirect = &alsa_stream->pcm_indirect;\n\n\treturn snd_pcm_indirect_playback_transfer(substream, pcm_indirect,\n\t\t\t\t\t\t  snd_bcm2835_pcm_transfer);\n}\n\n \nstatic int snd_bcm2835_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct bcm2835_alsa_stream *alsa_stream = runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\treturn bcm2835_audio_start(alsa_stream);\n\tcase SNDRV_PCM_TRIGGER_DRAIN:\n\t\talsa_stream->draining = true;\n\t\treturn bcm2835_audio_drain(alsa_stream);\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\treturn bcm2835_audio_stop(alsa_stream);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic snd_pcm_uframes_t\nsnd_bcm2835_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct bcm2835_alsa_stream *alsa_stream = runtime->private_data;\n\tktime_t now = ktime_get();\n\n\t \n\n\tif ((ktime_to_ns(alsa_stream->interpolate_start)) &&\n\t    (ktime_compare(alsa_stream->interpolate_start, now) < 0)) {\n\t\tu64 interval =\n\t\t\t(ktime_to_ns(ktime_sub(now,\n\t\t\t\talsa_stream->interpolate_start)));\n\t\tu64 frames_output_in_interval =\n\t\t\tdiv_u64((interval * runtime->rate), 1000000000);\n\t\tsnd_pcm_sframes_t frames_output_in_interval_sized =\n\t\t\t-frames_output_in_interval;\n\t\truntime->delay = frames_output_in_interval_sized;\n\t}\n\n\treturn snd_pcm_indirect_playback_pointer(substream,\n\t\t&alsa_stream->pcm_indirect,\n\t\tatomic_read(&alsa_stream->pos));\n}\n\n \nstatic const struct snd_pcm_ops snd_bcm2835_playback_ops = {\n\t.open = snd_bcm2835_playback_open,\n\t.close = snd_bcm2835_playback_close,\n\t.prepare = snd_bcm2835_pcm_prepare,\n\t.trigger = snd_bcm2835_pcm_trigger,\n\t.pointer = snd_bcm2835_pcm_pointer,\n\t.ack = snd_bcm2835_pcm_ack,\n};\n\nstatic const struct snd_pcm_ops snd_bcm2835_playback_spdif_ops = {\n\t.open = snd_bcm2835_playback_spdif_open,\n\t.close = snd_bcm2835_playback_close,\n\t.prepare = snd_bcm2835_pcm_prepare,\n\t.trigger = snd_bcm2835_pcm_trigger,\n\t.pointer = snd_bcm2835_pcm_pointer,\n\t.ack = snd_bcm2835_pcm_ack,\n};\n\n \nint snd_bcm2835_new_pcm(struct bcm2835_chip *chip, const char *name,\n\t\t\tint idx, enum snd_bcm2835_route route,\n\t\t\tu32 numchannels, bool spdif)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, name, idx, numchannels, 0, &pcm);\n\tif (err)\n\t\treturn err;\n\n\tpcm->private_data = chip;\n\tpcm->nonatomic = true;\n\tstrscpy(pcm->name, name, sizeof(pcm->name));\n\tif (!spdif) {\n\t\tchip->dest = route;\n\t\tchip->volume = 0;\n\t\tchip->mute = CTRL_VOL_UNMUTE;\n\t}\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\tspdif ? &snd_bcm2835_playback_spdif_ops :\n\t\t\t&snd_bcm2835_playback_ops);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       chip->card->dev, 128 * 1024, 128 * 1024);\n\n\tif (spdif)\n\t\tchip->pcm_spdif = pcm;\n\telse\n\t\tchip->pcm = pcm;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}