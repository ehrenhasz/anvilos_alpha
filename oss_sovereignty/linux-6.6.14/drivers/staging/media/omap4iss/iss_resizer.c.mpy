{
  "module_name": "iss_resizer.c",
  "hash_id": "81274f89528404a0000d8bcdd2c07a9cae61709debc784d721a8d25bb8b77a42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/omap4iss/iss_resizer.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#include \"iss.h\"\n#include \"iss_regs.h\"\n#include \"iss_resizer.h\"\n\nstatic const unsigned int resizer_fmts[] = {\n\tMEDIA_BUS_FMT_UYVY8_1X16,\n\tMEDIA_BUS_FMT_YUYV8_1X16,\n};\n\n \n#define RSZ_PRINT_REGISTER(iss, name)\\\n\tdev_dbg(iss->dev, \"###RSZ \" #name \"=0x%08x\\n\", \\\n\t\tiss_reg_read(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_##name))\n\n#define RZA_PRINT_REGISTER(iss, name)\\\n\tdev_dbg(iss->dev, \"###RZA \" #name \"=0x%08x\\n\", \\\n\t\tiss_reg_read(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_##name))\n\nstatic void resizer_print_status(struct iss_resizer_device *resizer)\n{\n\tstruct iss_device *iss = to_iss_device(resizer);\n\n\tdev_dbg(iss->dev, \"-------------RESIZER Register dump-------------\\n\");\n\n\tRSZ_PRINT_REGISTER(iss, SYSCONFIG);\n\tRSZ_PRINT_REGISTER(iss, IN_FIFO_CTRL);\n\tRSZ_PRINT_REGISTER(iss, FRACDIV);\n\tRSZ_PRINT_REGISTER(iss, SRC_EN);\n\tRSZ_PRINT_REGISTER(iss, SRC_MODE);\n\tRSZ_PRINT_REGISTER(iss, SRC_FMT0);\n\tRSZ_PRINT_REGISTER(iss, SRC_FMT1);\n\tRSZ_PRINT_REGISTER(iss, SRC_VPS);\n\tRSZ_PRINT_REGISTER(iss, SRC_VSZ);\n\tRSZ_PRINT_REGISTER(iss, SRC_HPS);\n\tRSZ_PRINT_REGISTER(iss, SRC_HSZ);\n\tRSZ_PRINT_REGISTER(iss, DMA_RZA);\n\tRSZ_PRINT_REGISTER(iss, DMA_RZB);\n\tRSZ_PRINT_REGISTER(iss, DMA_STA);\n\tRSZ_PRINT_REGISTER(iss, GCK_MMR);\n\tRSZ_PRINT_REGISTER(iss, GCK_SDR);\n\tRSZ_PRINT_REGISTER(iss, IRQ_RZA);\n\tRSZ_PRINT_REGISTER(iss, IRQ_RZB);\n\tRSZ_PRINT_REGISTER(iss, YUV_Y_MIN);\n\tRSZ_PRINT_REGISTER(iss, YUV_Y_MAX);\n\tRSZ_PRINT_REGISTER(iss, YUV_C_MIN);\n\tRSZ_PRINT_REGISTER(iss, YUV_C_MAX);\n\tRSZ_PRINT_REGISTER(iss, SEQ);\n\n\tRZA_PRINT_REGISTER(iss, EN);\n\tRZA_PRINT_REGISTER(iss, MODE);\n\tRZA_PRINT_REGISTER(iss, 420);\n\tRZA_PRINT_REGISTER(iss, I_VPS);\n\tRZA_PRINT_REGISTER(iss, I_HPS);\n\tRZA_PRINT_REGISTER(iss, O_VSZ);\n\tRZA_PRINT_REGISTER(iss, O_HSZ);\n\tRZA_PRINT_REGISTER(iss, V_PHS_Y);\n\tRZA_PRINT_REGISTER(iss, V_PHS_C);\n\tRZA_PRINT_REGISTER(iss, V_DIF);\n\tRZA_PRINT_REGISTER(iss, V_TYP);\n\tRZA_PRINT_REGISTER(iss, V_LPF);\n\tRZA_PRINT_REGISTER(iss, H_PHS);\n\tRZA_PRINT_REGISTER(iss, H_DIF);\n\tRZA_PRINT_REGISTER(iss, H_TYP);\n\tRZA_PRINT_REGISTER(iss, H_LPF);\n\tRZA_PRINT_REGISTER(iss, DWN_EN);\n\tRZA_PRINT_REGISTER(iss, SDR_Y_BAD_H);\n\tRZA_PRINT_REGISTER(iss, SDR_Y_BAD_L);\n\tRZA_PRINT_REGISTER(iss, SDR_Y_SAD_H);\n\tRZA_PRINT_REGISTER(iss, SDR_Y_SAD_L);\n\tRZA_PRINT_REGISTER(iss, SDR_Y_OFT);\n\tRZA_PRINT_REGISTER(iss, SDR_Y_PTR_S);\n\tRZA_PRINT_REGISTER(iss, SDR_Y_PTR_E);\n\tRZA_PRINT_REGISTER(iss, SDR_C_BAD_H);\n\tRZA_PRINT_REGISTER(iss, SDR_C_BAD_L);\n\tRZA_PRINT_REGISTER(iss, SDR_C_SAD_H);\n\tRZA_PRINT_REGISTER(iss, SDR_C_SAD_L);\n\tRZA_PRINT_REGISTER(iss, SDR_C_OFT);\n\tRZA_PRINT_REGISTER(iss, SDR_C_PTR_S);\n\tRZA_PRINT_REGISTER(iss, SDR_C_PTR_E);\n\n\tdev_dbg(iss->dev, \"-----------------------------------------------\\n\");\n}\n\n \nstatic void resizer_enable(struct iss_resizer_device *resizer, u8 enable)\n{\n\tstruct iss_device *iss = to_iss_device(resizer);\n\n\tiss_reg_update(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_SRC_EN,\n\t\t       RSZ_SRC_EN_SRC_EN, enable ? RSZ_SRC_EN_SRC_EN : 0);\n\n\t \n\tiss_reg_update(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_EN, RSZ_EN_EN,\n\t\t       enable ? RSZ_EN_EN : 0);\n}\n\n \n\n \nstatic void resizer_set_outaddr(struct iss_resizer_device *resizer, u32 addr)\n{\n\tstruct iss_device *iss = to_iss_device(resizer);\n\tstruct v4l2_mbus_framefmt *informat, *outformat;\n\n\tinformat = &resizer->formats[RESIZER_PAD_SINK];\n\toutformat = &resizer->formats[RESIZER_PAD_SOURCE_MEM];\n\n\t \n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_Y_BAD_H,\n\t\t      (addr >> 16) & 0xffff);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_Y_BAD_L,\n\t\t      addr & 0xffff);\n\n\t \n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_Y_SAD_H,\n\t\t      (addr >> 16) & 0xffff);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_Y_SAD_L,\n\t\t      addr & 0xffff);\n\n\t \n\tif ((informat->code == MEDIA_BUS_FMT_UYVY8_1X16) &&\n\t    (outformat->code == MEDIA_BUS_FMT_YUYV8_1_5X8)) {\n\t\tu32 c_addr = addr + resizer->video_out.bpl_value\n\t\t\t   * outformat->height;\n\n\t\t \n\t\tif ((c_addr ^ addr) & 0x7f) {\n\t\t\tc_addr &= ~0x7f;\n\t\t\tc_addr += 0x80;\n\t\t\tc_addr |= addr & 0x7f;\n\t\t}\n\n\t\t \n\t\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_C_BAD_H,\n\t\t\t      (c_addr >> 16) & 0xffff);\n\t\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_C_BAD_L,\n\t\t\t      c_addr & 0xffff);\n\n\t\t \n\t\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_C_SAD_H,\n\t\t\t      (c_addr >> 16) & 0xffff);\n\t\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_C_SAD_L,\n\t\t\t      c_addr & 0xffff);\n\t}\n}\n\nstatic void resizer_configure(struct iss_resizer_device *resizer)\n{\n\tstruct iss_device *iss = to_iss_device(resizer);\n\tstruct v4l2_mbus_framefmt *informat, *outformat;\n\n\tinformat = &resizer->formats[RESIZER_PAD_SINK];\n\toutformat = &resizer->formats[RESIZER_PAD_SOURCE_MEM];\n\n\t \n\tiss_reg_clr(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_SRC_FMT0,\n\t\t    RSZ_SRC_FMT0_BYPASS);\n\n\t \n\tiss_reg_update(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_SRC_FMT0,\n\t\t       RSZ_SRC_FMT0_SEL,\n\t\t       resizer->input == RESIZER_INPUT_IPIPEIF ?\n\t\t       RSZ_SRC_FMT0_SEL : 0);\n\n\t \n\tiss_reg_clr(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_SRC_MODE,\n\t\t    RSZ_SRC_MODE_WRT);\n\n\t \n\tiss_reg_clr(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_SRC_MODE,\n\t\t    RSZ_SRC_MODE_OST);\n\n\t \n\tiss_reg_clr(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_MODE,\n\t\t    RZA_MODE_ONE_SHOT);\n\n\t \n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_SRC_VPS, 0);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_SRC_HPS, 0);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_SRC_VSZ,\n\t\t      informat->height - 2);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_SRC_HSZ,\n\t\t      informat->width - 1);\n\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_I_VPS, 0);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_I_HPS, 0);\n\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_O_VSZ,\n\t\t      outformat->height - 2);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_O_HSZ,\n\t\t      outformat->width - 1);\n\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_V_DIF, 0x100);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_H_DIF, 0x100);\n\n\t \n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_Y_PTR_S, 0);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_Y_PTR_E,\n\t\t      outformat->height - 1);\n\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_Y_OFT,\n\t\t      resizer->video_out.bpl_value);\n\n\t \n\tif ((informat->code == MEDIA_BUS_FMT_UYVY8_1X16) &&\n\t    (outformat->code == MEDIA_BUS_FMT_YUYV8_1_5X8)) {\n\t\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_420,\n\t\t\t      RSZ_420_CEN | RSZ_420_YEN);\n\n\t\t \n\t\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_C_PTR_S,\n\t\t\t      0);\n\t\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_C_PTR_E,\n\t\t\t      outformat->height - 1);\n\n\t\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_SDR_C_OFT,\n\t\t\t      resizer->video_out.bpl_value);\n\t} else {\n\t\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_RESIZER, RZA_420, 0);\n\t}\n}\n\n \n\nstatic void resizer_isr_buffer(struct iss_resizer_device *resizer)\n{\n\tstruct iss_buffer *buffer;\n\n\t \n\tresizer_enable(resizer, 0);\n\n\tbuffer = omap4iss_video_buffer_next(&resizer->video_out);\n\tif (!buffer)\n\t\treturn;\n\n\tresizer_set_outaddr(resizer, buffer->iss_addr);\n\n\tresizer_enable(resizer, 1);\n}\n\n \nvoid omap4iss_resizer_isr(struct iss_resizer_device *resizer, u32 events)\n{\n\tstruct iss_device *iss = to_iss_device(resizer);\n\tstruct iss_pipeline *pipe =\n\t\t\t     to_iss_pipeline(&resizer->subdev.entity);\n\n\tif (events & (ISP5_IRQ_RSZ_FIFO_IN_BLK_ERR |\n\t\t      ISP5_IRQ_RSZ_FIFO_OVF)) {\n\t\tdev_dbg(iss->dev, \"RSZ Err: FIFO_IN_BLK:%d, FIFO_OVF:%d\\n\",\n\t\t\tevents & ISP5_IRQ_RSZ_FIFO_IN_BLK_ERR ? 1 : 0,\n\t\t\tevents & ISP5_IRQ_RSZ_FIFO_OVF ? 1 : 0);\n\t\tomap4iss_pipeline_cancel_stream(pipe);\n\t}\n\n\tif (omap4iss_module_sync_is_stopping(&resizer->wait,\n\t\t\t\t\t     &resizer->stopping))\n\t\treturn;\n\n\tif (events & ISP5_IRQ_RSZ_INT_DMA)\n\t\tresizer_isr_buffer(resizer);\n}\n\n \n\nstatic int resizer_video_queue(struct iss_video *video,\n\t\t\t       struct iss_buffer *buffer)\n{\n\tstruct iss_resizer_device *resizer = container_of(video,\n\t\t\t\tstruct iss_resizer_device, video_out);\n\n\tif (!(resizer->output & RESIZER_OUTPUT_MEMORY))\n\t\treturn -ENODEV;\n\n\tresizer_set_outaddr(resizer, buffer->iss_addr);\n\n\t \n\tif (video->dmaqueue_flags & ISS_VIDEO_DMAQUEUE_UNDERRUN) {\n\t\tresizer_enable(resizer, 1);\n\t\tiss_video_dmaqueue_flags_clr(video);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iss_video_operations resizer_video_ops = {\n\t.queue = resizer_video_queue,\n};\n\n \n\n \nstatic int resizer_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct iss_resizer_device *resizer = v4l2_get_subdevdata(sd);\n\tstruct iss_device *iss = to_iss_device(resizer);\n\tstruct iss_video *video_out = &resizer->video_out;\n\tint ret = 0;\n\n\tif (resizer->state == ISS_PIPELINE_STREAM_STOPPED) {\n\t\tif (enable == ISS_PIPELINE_STREAM_STOPPED)\n\t\t\treturn 0;\n\n\t\tomap4iss_isp_subclk_enable(iss, OMAP4_ISS_ISP_SUBCLK_RSZ);\n\n\t\tiss_reg_set(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_GCK_MMR,\n\t\t\t    RSZ_GCK_MMR_MMR);\n\t\tiss_reg_set(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_GCK_SDR,\n\t\t\t    RSZ_GCK_SDR_CORE);\n\n\t\t \n\t\tiss_reg_set(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_SYSCONFIG,\n\t\t\t    RSZ_SYSCONFIG_RSZA_CLK_EN);\n\t}\n\n\tswitch (enable) {\n\tcase ISS_PIPELINE_STREAM_CONTINUOUS:\n\n\t\tresizer_configure(resizer);\n\t\tresizer_print_status(resizer);\n\n\t\t \n\t\tif (resizer->output & RESIZER_OUTPUT_MEMORY &&\n\t\t    !(video_out->dmaqueue_flags & ISS_VIDEO_DMAQUEUE_QUEUED))\n\t\t\tbreak;\n\n\t\tatomic_set(&resizer->stopping, 0);\n\t\tresizer_enable(resizer, 1);\n\t\tiss_video_dmaqueue_flags_clr(video_out);\n\t\tbreak;\n\n\tcase ISS_PIPELINE_STREAM_STOPPED:\n\t\tif (resizer->state == ISS_PIPELINE_STREAM_STOPPED)\n\t\t\treturn 0;\n\t\tif (omap4iss_module_sync_idle(&sd->entity, &resizer->wait,\n\t\t\t\t\t      &resizer->stopping))\n\t\t\tret = -ETIMEDOUT;\n\n\t\tresizer_enable(resizer, 0);\n\t\tiss_reg_clr(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_SYSCONFIG,\n\t\t\t    RSZ_SYSCONFIG_RSZA_CLK_EN);\n\t\tiss_reg_clr(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_GCK_SDR,\n\t\t\t    RSZ_GCK_SDR_CORE);\n\t\tiss_reg_clr(iss, OMAP4_ISS_MEM_ISP_RESIZER, RSZ_GCK_MMR,\n\t\t\t    RSZ_GCK_MMR_MMR);\n\t\tomap4iss_isp_subclk_disable(iss, OMAP4_ISS_ISP_SUBCLK_RSZ);\n\t\tiss_video_dmaqueue_flags_clr(video_out);\n\t\tbreak;\n\t}\n\n\tresizer->state = enable;\n\treturn ret;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__resizer_get_format(struct iss_resizer_device *resizer,\n\t\t     struct v4l2_subdev_state *sd_state, unsigned int pad,\n\t\t     enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&resizer->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\treturn &resizer->formats[pad];\n}\n\n \nstatic void\nresizer_try_format(struct iss_resizer_device *resizer,\n\t\t   struct v4l2_subdev_state *sd_state, unsigned int pad,\n\t\t   struct v4l2_mbus_framefmt *fmt,\n\t\t   enum v4l2_subdev_format_whence which)\n{\n\tu32 pixelcode;\n\tstruct v4l2_mbus_framefmt *format;\n\tunsigned int width = fmt->width;\n\tunsigned int height = fmt->height;\n\tunsigned int i;\n\n\tswitch (pad) {\n\tcase RESIZER_PAD_SINK:\n\t\tfor (i = 0; i < ARRAY_SIZE(resizer_fmts); i++) {\n\t\t\tif (fmt->code == resizer_fmts[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i >= ARRAY_SIZE(resizer_fmts))\n\t\t\tfmt->code = MEDIA_BUS_FMT_UYVY8_1X16;\n\n\t\t \n\t\tfmt->width = clamp_t(u32, width, 1, 8192);\n\t\tfmt->height = clamp_t(u32, height, 1, 8192);\n\t\tbreak;\n\n\tcase RESIZER_PAD_SOURCE_MEM:\n\t\tpixelcode = fmt->code;\n\t\tformat = __resizer_get_format(resizer, sd_state,\n\t\t\t\t\t      RESIZER_PAD_SINK,\n\t\t\t\t\t      which);\n\t\tmemcpy(fmt, format, sizeof(*fmt));\n\n\t\tif ((pixelcode == MEDIA_BUS_FMT_YUYV8_1_5X8) &&\n\t\t    (fmt->code == MEDIA_BUS_FMT_UYVY8_1X16))\n\t\t\tfmt->code = pixelcode;\n\n\t\t \n\t\tfmt->width = clamp_t(u32, width, 32, (fmt->width + 15) & ~15);\n\t\tfmt->width &= ~15;\n\t\tfmt->height = clamp_t(u32, height, 32, fmt->height);\n\t\tbreak;\n\t}\n\n\tfmt->colorspace = V4L2_COLORSPACE_JPEG;\n\tfmt->field = V4L2_FIELD_NONE;\n}\n\n \nstatic int resizer_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct iss_resizer_device *resizer = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tswitch (code->pad) {\n\tcase RESIZER_PAD_SINK:\n\t\tif (code->index >= ARRAY_SIZE(resizer_fmts))\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = resizer_fmts[code->index];\n\t\tbreak;\n\n\tcase RESIZER_PAD_SOURCE_MEM:\n\t\tformat = __resizer_get_format(resizer, sd_state,\n\t\t\t\t\t      RESIZER_PAD_SINK,\n\t\t\t\t\t      code->which);\n\n\t\tif (code->index == 0) {\n\t\t\tcode->code = format->code;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (format->code) {\n\t\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\t\tif (code->index == 1)\n\t\t\t\tcode->code = MEDIA_BUS_FMT_YUYV8_1_5X8;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (code->index != 0)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int resizer_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct iss_resizer_device *resizer = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt format;\n\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = 1;\n\tformat.height = 1;\n\tresizer_try_format(resizer, sd_state, fse->pad, &format, fse->which);\n\tfse->min_width = format.width;\n\tfse->min_height = format.height;\n\n\tif (format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = -1;\n\tformat.height = -1;\n\tresizer_try_format(resizer, sd_state, fse->pad, &format, fse->which);\n\tfse->max_width = format.width;\n\tfse->max_height = format.height;\n\n\treturn 0;\n}\n\n \nstatic int resizer_get_format(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct iss_resizer_device *resizer = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __resizer_get_format(resizer, sd_state, fmt->pad, fmt->which);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\treturn 0;\n}\n\n \nstatic int resizer_set_format(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct iss_resizer_device *resizer = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __resizer_get_format(resizer, sd_state, fmt->pad, fmt->which);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\tresizer_try_format(resizer, sd_state, fmt->pad, &fmt->format,\n\t\t\t   fmt->which);\n\t*format = fmt->format;\n\n\t \n\tif (fmt->pad == RESIZER_PAD_SINK) {\n\t\tformat = __resizer_get_format(resizer, sd_state,\n\t\t\t\t\t      RESIZER_PAD_SOURCE_MEM,\n\t\t\t\t\t      fmt->which);\n\t\t*format = fmt->format;\n\t\tresizer_try_format(resizer, sd_state, RESIZER_PAD_SOURCE_MEM,\n\t\t\t\t   format,\n\t\t\t\t   fmt->which);\n\t}\n\n\treturn 0;\n}\n\nstatic int resizer_link_validate(struct v4l2_subdev *sd,\n\t\t\t\t struct media_link *link,\n\t\t\t\t struct v4l2_subdev_format *source_fmt,\n\t\t\t\t struct v4l2_subdev_format *sink_fmt)\n{\n\t \n\tif (source_fmt->format.width != sink_fmt->format.width ||\n\t    source_fmt->format.height != sink_fmt->format.height)\n\t\treturn -EPIPE;\n\n\tif (source_fmt->format.code != sink_fmt->format.code)\n\t\treturn -EPIPE;\n\n\treturn 0;\n}\n\n \nstatic int resizer_init_formats(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_subdev_format format;\n\n\tmemset(&format, 0, sizeof(format));\n\tformat.pad = RESIZER_PAD_SINK;\n\tformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\n\tformat.format.code = MEDIA_BUS_FMT_UYVY8_1X16;\n\tformat.format.width = 4096;\n\tformat.format.height = 4096;\n\tresizer_set_format(sd, fh ? fh->state : NULL, &format);\n\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_video_ops resizer_v4l2_video_ops = {\n\t.s_stream = resizer_set_stream,\n};\n\n \nstatic const struct v4l2_subdev_pad_ops resizer_v4l2_pad_ops = {\n\t.enum_mbus_code = resizer_enum_mbus_code,\n\t.enum_frame_size = resizer_enum_frame_size,\n\t.get_fmt = resizer_get_format,\n\t.set_fmt = resizer_set_format,\n\t.link_validate = resizer_link_validate,\n};\n\n \nstatic const struct v4l2_subdev_ops resizer_v4l2_ops = {\n\t.video = &resizer_v4l2_video_ops,\n\t.pad = &resizer_v4l2_pad_ops,\n};\n\n \nstatic const struct v4l2_subdev_internal_ops resizer_v4l2_internal_ops = {\n\t.open = resizer_init_formats,\n};\n\n \n\n \nstatic int resizer_link_setup(struct media_entity *entity,\n\t\t\t      const struct media_pad *local,\n\t\t\t      const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct iss_resizer_device *resizer = v4l2_get_subdevdata(sd);\n\tstruct iss_device *iss = to_iss_device(resizer);\n\tunsigned int index = local->index;\n\n\t \n\tif (is_media_entity_v4l2_subdev(remote->entity))\n\t\tindex |= 2 << 16;\n\n\tswitch (index) {\n\tcase RESIZER_PAD_SINK | 2 << 16:\n\t\t \n\t\tif (!(flags & MEDIA_LNK_FL_ENABLED)) {\n\t\t\tresizer->input = RESIZER_INPUT_NONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (resizer->input != RESIZER_INPUT_NONE)\n\t\t\treturn -EBUSY;\n\n\t\tif (remote->entity == &iss->ipipeif.subdev.entity)\n\t\t\tresizer->input = RESIZER_INPUT_IPIPEIF;\n\t\telse if (remote->entity == &iss->ipipe.subdev.entity)\n\t\t\tresizer->input = RESIZER_INPUT_IPIPE;\n\n\t\tbreak;\n\n\tcase RESIZER_PAD_SOURCE_MEM:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (resizer->output & ~RESIZER_OUTPUT_MEMORY)\n\t\t\t\treturn -EBUSY;\n\t\t\tresizer->output |= RESIZER_OUTPUT_MEMORY;\n\t\t} else {\n\t\t\tresizer->output &= ~RESIZER_OUTPUT_MEMORY;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct media_entity_operations resizer_media_ops = {\n\t.link_setup = resizer_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n \nstatic int resizer_init_entities(struct iss_resizer_device *resizer)\n{\n\tstruct v4l2_subdev *sd = &resizer->subdev;\n\tstruct media_pad *pads = resizer->pads;\n\tstruct media_entity *me = &sd->entity;\n\tint ret;\n\n\tresizer->input = RESIZER_INPUT_NONE;\n\n\tv4l2_subdev_init(sd, &resizer_v4l2_ops);\n\tsd->internal_ops = &resizer_v4l2_internal_ops;\n\tstrscpy(sd->name, \"OMAP4 ISS ISP resizer\", sizeof(sd->name));\n\tsd->grp_id = BIT(16);\t \n\tv4l2_set_subdevdata(sd, resizer);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tpads[RESIZER_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tpads[RESIZER_PAD_SOURCE_MEM].flags = MEDIA_PAD_FL_SOURCE;\n\n\tme->ops = &resizer_media_ops;\n\tret = media_entity_pads_init(me, RESIZER_PADS_NUM, pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tresizer_init_formats(sd, NULL);\n\n\tresizer->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tresizer->video_out.ops = &resizer_video_ops;\n\tresizer->video_out.iss = to_iss_device(resizer);\n\tresizer->video_out.capture_mem = PAGE_ALIGN(4096 * 4096) * 3;\n\tresizer->video_out.bpl_alignment = 32;\n\tresizer->video_out.bpl_zero_padding = 1;\n\tresizer->video_out.bpl_max = 0x1ffe0;\n\n\treturn omap4iss_video_init(&resizer->video_out, \"ISP resizer a\");\n}\n\nvoid omap4iss_resizer_unregister_entities(struct iss_resizer_device *resizer)\n{\n\tv4l2_device_unregister_subdev(&resizer->subdev);\n\tomap4iss_video_unregister(&resizer->video_out);\n}\n\nint omap4iss_resizer_register_entities(struct iss_resizer_device *resizer,\n\t\t\t\t       struct v4l2_device *vdev)\n{\n\tint ret;\n\n\t \n\tret = v4l2_device_register_subdev(vdev, &resizer->subdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = omap4iss_video_register(&resizer->video_out, vdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tomap4iss_resizer_unregister_entities(resizer);\n\treturn ret;\n}\n\n \n\n \nint omap4iss_resizer_init(struct iss_device *iss)\n{\n\tstruct iss_resizer_device *resizer = &iss->resizer;\n\n\tresizer->state = ISS_PIPELINE_STREAM_STOPPED;\n\tinit_waitqueue_head(&resizer->wait);\n\n\treturn resizer_init_entities(resizer);\n}\n\n \nint omap4iss_resizer_create_links(struct iss_device *iss)\n{\n\tstruct iss_resizer_device *resizer = &iss->resizer;\n\n\t \n\treturn media_create_pad_link(&resizer->subdev.entity,\n\t\t\t\t     RESIZER_PAD_SOURCE_MEM,\n\t\t\t\t     &resizer->video_out.video.entity, 0, 0);\n}\n\n \nvoid omap4iss_resizer_cleanup(struct iss_device *iss)\n{\n\tstruct iss_resizer_device *resizer = &iss->resizer;\n\n\tmedia_entity_cleanup(&resizer->subdev.entity);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}