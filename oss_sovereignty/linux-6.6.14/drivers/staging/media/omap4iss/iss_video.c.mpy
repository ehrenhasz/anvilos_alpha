{
  "module_name": "iss_video.c",
  "hash_id": "81edd0d26e24dfcfaed48d1e9aad9cbe51c9fc73c6df9c7174330354ced62275",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/omap4iss/iss_video.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\n#include <media/v4l2-dev.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mc.h>\n\n#include \"iss_video.h\"\n#include \"iss.h\"\n\n \n\nstatic struct iss_format_info formats[] = {\n\t{ MEDIA_BUS_FMT_Y8_1X8, MEDIA_BUS_FMT_Y8_1X8,\n\t  MEDIA_BUS_FMT_Y8_1X8, MEDIA_BUS_FMT_Y8_1X8,\n\t  V4L2_PIX_FMT_GREY, 8, },\n\t{ MEDIA_BUS_FMT_Y10_1X10, MEDIA_BUS_FMT_Y10_1X10,\n\t  MEDIA_BUS_FMT_Y10_1X10, MEDIA_BUS_FMT_Y8_1X8,\n\t  V4L2_PIX_FMT_Y10, 10, },\n\t{ MEDIA_BUS_FMT_Y12_1X12, MEDIA_BUS_FMT_Y10_1X10,\n\t  MEDIA_BUS_FMT_Y12_1X12, MEDIA_BUS_FMT_Y8_1X8,\n\t  V4L2_PIX_FMT_Y12, 12, },\n\t{ MEDIA_BUS_FMT_SBGGR8_1X8, MEDIA_BUS_FMT_SBGGR8_1X8,\n\t  MEDIA_BUS_FMT_SBGGR8_1X8, MEDIA_BUS_FMT_SBGGR8_1X8,\n\t  V4L2_PIX_FMT_SBGGR8, 8, },\n\t{ MEDIA_BUS_FMT_SGBRG8_1X8, MEDIA_BUS_FMT_SGBRG8_1X8,\n\t  MEDIA_BUS_FMT_SGBRG8_1X8, MEDIA_BUS_FMT_SGBRG8_1X8,\n\t  V4L2_PIX_FMT_SGBRG8, 8, },\n\t{ MEDIA_BUS_FMT_SGRBG8_1X8, MEDIA_BUS_FMT_SGRBG8_1X8,\n\t  MEDIA_BUS_FMT_SGRBG8_1X8, MEDIA_BUS_FMT_SGRBG8_1X8,\n\t  V4L2_PIX_FMT_SGRBG8, 8, },\n\t{ MEDIA_BUS_FMT_SRGGB8_1X8, MEDIA_BUS_FMT_SRGGB8_1X8,\n\t  MEDIA_BUS_FMT_SRGGB8_1X8, MEDIA_BUS_FMT_SRGGB8_1X8,\n\t  V4L2_PIX_FMT_SRGGB8, 8, },\n\t{ MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8, MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8,\n\t  MEDIA_BUS_FMT_SGRBG10_1X10, 0,\n\t  V4L2_PIX_FMT_SGRBG10DPCM8, 8, },\n\t{ MEDIA_BUS_FMT_SBGGR10_1X10, MEDIA_BUS_FMT_SBGGR10_1X10,\n\t  MEDIA_BUS_FMT_SBGGR10_1X10, MEDIA_BUS_FMT_SBGGR8_1X8,\n\t  V4L2_PIX_FMT_SBGGR10, 10, },\n\t{ MEDIA_BUS_FMT_SGBRG10_1X10, MEDIA_BUS_FMT_SGBRG10_1X10,\n\t  MEDIA_BUS_FMT_SGBRG10_1X10, MEDIA_BUS_FMT_SGBRG8_1X8,\n\t  V4L2_PIX_FMT_SGBRG10, 10, },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, MEDIA_BUS_FMT_SGRBG10_1X10,\n\t  MEDIA_BUS_FMT_SGRBG10_1X10, MEDIA_BUS_FMT_SGRBG8_1X8,\n\t  V4L2_PIX_FMT_SGRBG10, 10, },\n\t{ MEDIA_BUS_FMT_SRGGB10_1X10, MEDIA_BUS_FMT_SRGGB10_1X10,\n\t  MEDIA_BUS_FMT_SRGGB10_1X10, MEDIA_BUS_FMT_SRGGB8_1X8,\n\t  V4L2_PIX_FMT_SRGGB10, 10, },\n\t{ MEDIA_BUS_FMT_SBGGR12_1X12, MEDIA_BUS_FMT_SBGGR10_1X10,\n\t  MEDIA_BUS_FMT_SBGGR12_1X12, MEDIA_BUS_FMT_SBGGR8_1X8,\n\t  V4L2_PIX_FMT_SBGGR12, 12, },\n\t{ MEDIA_BUS_FMT_SGBRG12_1X12, MEDIA_BUS_FMT_SGBRG10_1X10,\n\t  MEDIA_BUS_FMT_SGBRG12_1X12, MEDIA_BUS_FMT_SGBRG8_1X8,\n\t  V4L2_PIX_FMT_SGBRG12, 12, },\n\t{ MEDIA_BUS_FMT_SGRBG12_1X12, MEDIA_BUS_FMT_SGRBG10_1X10,\n\t  MEDIA_BUS_FMT_SGRBG12_1X12, MEDIA_BUS_FMT_SGRBG8_1X8,\n\t  V4L2_PIX_FMT_SGRBG12, 12, },\n\t{ MEDIA_BUS_FMT_SRGGB12_1X12, MEDIA_BUS_FMT_SRGGB10_1X10,\n\t  MEDIA_BUS_FMT_SRGGB12_1X12, MEDIA_BUS_FMT_SRGGB8_1X8,\n\t  V4L2_PIX_FMT_SRGGB12, 12, },\n\t{ MEDIA_BUS_FMT_UYVY8_1X16, MEDIA_BUS_FMT_UYVY8_1X16,\n\t  MEDIA_BUS_FMT_UYVY8_1X16, 0,\n\t  V4L2_PIX_FMT_UYVY, 16, },\n\t{ MEDIA_BUS_FMT_YUYV8_1X16, MEDIA_BUS_FMT_YUYV8_1X16,\n\t  MEDIA_BUS_FMT_YUYV8_1X16, 0,\n\t  V4L2_PIX_FMT_YUYV, 16, },\n\t{ MEDIA_BUS_FMT_YUYV8_1_5X8, MEDIA_BUS_FMT_YUYV8_1_5X8,\n\t  MEDIA_BUS_FMT_YUYV8_1_5X8, 0,\n\t  V4L2_PIX_FMT_NV12, 8, },\n};\n\nconst struct iss_format_info *\nomap4iss_video_format_info(u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); ++i) {\n\t\tif (formats[i].code == code)\n\t\t\treturn &formats[i];\n\t}\n\n\treturn NULL;\n}\n\n \nstatic unsigned int iss_video_mbus_to_pix(const struct iss_video *video,\n\t\t\t\t\t  const struct v4l2_mbus_framefmt *mbus,\n\t\t\t\t\t  struct v4l2_pix_format *pix)\n{\n\tunsigned int bpl = pix->bytesperline;\n\tunsigned int min_bpl;\n\tunsigned int i;\n\n\tmemset(pix, 0, sizeof(*pix));\n\tpix->width = mbus->width;\n\tpix->height = mbus->height;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(formats) - 1; ++i) {\n\t\tif (formats[i].code == mbus->code)\n\t\t\tbreak;\n\t}\n\n\tmin_bpl = pix->width * ALIGN(formats[i].bpp, 8) / 8;\n\n\t \n\tif (video->bpl_max)\n\t\tbpl = clamp(bpl, min_bpl, video->bpl_max);\n\telse\n\t\tbpl = min_bpl;\n\n\tif (!video->bpl_zero_padding || bpl != min_bpl)\n\t\tbpl = ALIGN(bpl, video->bpl_alignment);\n\n\tpix->pixelformat = formats[i].pixelformat;\n\tpix->bytesperline = bpl;\n\tpix->sizeimage = pix->bytesperline * pix->height;\n\tpix->colorspace = mbus->colorspace;\n\tpix->field = mbus->field;\n\n\t \n\tif (pix->pixelformat == V4L2_PIX_FMT_NV12)\n\t\tpix->sizeimage += (pix->bytesperline * pix->height) / 2;\n\n\treturn bpl - min_bpl;\n}\n\nstatic void iss_video_pix_to_mbus(const struct v4l2_pix_format *pix,\n\t\t\t\t  struct v4l2_mbus_framefmt *mbus)\n{\n\tunsigned int i;\n\n\tmemset(mbus, 0, sizeof(*mbus));\n\tmbus->width = pix->width;\n\tmbus->height = pix->height;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(formats) - 1; ++i) {\n\t\tif (formats[i].pixelformat == pix->pixelformat)\n\t\t\tbreak;\n\t}\n\n\tmbus->code = formats[i].code;\n\tmbus->colorspace = pix->colorspace;\n\tmbus->field = pix->field;\n}\n\nstatic struct v4l2_subdev *\niss_video_remote_subdev(struct iss_video *video, u32 *pad)\n{\n\tstruct media_pad *remote;\n\n\tremote = media_pad_remote_pad_first(&video->pad);\n\n\tif (!remote || !is_media_entity_v4l2_subdev(remote->entity))\n\t\treturn NULL;\n\n\tif (pad)\n\t\t*pad = remote->index;\n\n\treturn media_entity_to_v4l2_subdev(remote->entity);\n}\n\n \nstatic struct iss_video *\niss_video_far_end(struct iss_video *video, struct iss_pipeline *pipe)\n{\n\tstruct media_pipeline_entity_iter iter;\n\tstruct media_entity *entity;\n\tstruct iss_video *far_end = NULL;\n\tint ret;\n\n\tret = media_pipeline_entity_iter_init(&pipe->pipe, &iter);\n\tif (ret)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmedia_pipeline_for_each_entity(&pipe->pipe, &iter, entity) {\n\t\tstruct iss_video *other;\n\n\t\tif (entity == &video->video.entity)\n\t\t\tcontinue;\n\n\t\tif (!is_media_entity_v4l2_video_device(entity))\n\t\t\tcontinue;\n\n\t\tother = to_iss_video(media_entity_to_video_device(entity));\n\t\tif (other->type != video->type) {\n\t\t\tfar_end = other;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmedia_pipeline_entity_iter_cleanup(&iter);\n\n\treturn far_end;\n}\n\nstatic int\n__iss_video_get_format(struct iss_video *video,\n\t\t       struct v4l2_mbus_framefmt *format)\n{\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_subdev *subdev;\n\tu32 pad;\n\tint ret;\n\n\tsubdev = iss_video_remote_subdev(video, &pad);\n\tif (!subdev)\n\t\treturn -EINVAL;\n\n\tfmt.pad = pad;\n\n\tmutex_lock(&video->mutex);\n\tret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);\n\tmutex_unlock(&video->mutex);\n\n\tif (ret)\n\t\treturn ret;\n\n\t*format = fmt.format;\n\treturn 0;\n}\n\nstatic int\niss_video_check_format(struct iss_video *video, struct iss_video_fh *vfh)\n{\n\tstruct v4l2_mbus_framefmt format;\n\tstruct v4l2_pix_format pixfmt;\n\tint ret;\n\n\tret = __iss_video_get_format(video, &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpixfmt.bytesperline = 0;\n\tret = iss_video_mbus_to_pix(video, &format, &pixfmt);\n\n\tif (vfh->format.fmt.pix.pixelformat != pixfmt.pixelformat ||\n\t    vfh->format.fmt.pix.height != pixfmt.height ||\n\t    vfh->format.fmt.pix.width != pixfmt.width ||\n\t    vfh->format.fmt.pix.bytesperline != pixfmt.bytesperline ||\n\t    vfh->format.fmt.pix.sizeimage != pixfmt.sizeimage)\n\t\treturn -EINVAL;\n\n\treturn ret;\n}\n\n \n\nstatic int iss_video_queue_setup(struct vb2_queue *vq,\n\t\t\t\t unsigned int *count, unsigned int *num_planes,\n\t\t\t\t unsigned int sizes[],\n\t\t\t\t struct device *alloc_devs[])\n{\n\tstruct iss_video_fh *vfh = vb2_get_drv_priv(vq);\n\tstruct iss_video *video = vfh->video;\n\n\t \n\t*num_planes = 1;\n\n\tsizes[0] = vfh->format.fmt.pix.sizeimage;\n\tif (sizes[0] == 0)\n\t\treturn -EINVAL;\n\n\t*count = min(*count, video->capture_mem / PAGE_ALIGN(sizes[0]));\n\n\treturn 0;\n}\n\nstatic void iss_video_buf_cleanup(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct iss_buffer *buffer = container_of(vbuf, struct iss_buffer, vb);\n\n\tif (buffer->iss_addr)\n\t\tbuffer->iss_addr = 0;\n}\n\nstatic int iss_video_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct iss_video_fh *vfh = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct iss_buffer *buffer = container_of(vbuf, struct iss_buffer, vb);\n\tstruct iss_video *video = vfh->video;\n\tunsigned long size = vfh->format.fmt.pix.sizeimage;\n\tdma_addr_t addr;\n\n\tif (vb2_plane_size(vb, 0) < size)\n\t\treturn -ENOBUFS;\n\n\taddr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\tif (!IS_ALIGNED(addr, 32)) {\n\t\tdev_dbg(video->iss->dev,\n\t\t\t\"Buffer address must be aligned to 32 bytes boundary.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, size);\n\tbuffer->iss_addr = addr;\n\treturn 0;\n}\n\nstatic void iss_video_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct iss_video_fh *vfh = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct iss_video *video = vfh->video;\n\tstruct iss_buffer *buffer = container_of(vbuf, struct iss_buffer, vb);\n\tstruct iss_pipeline *pipe = to_iss_pipeline(&video->video.entity);\n\tunsigned long flags;\n\tbool empty;\n\n\tspin_lock_irqsave(&video->qlock, flags);\n\n\t \n\tif (unlikely(video->error)) {\n\t\tvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\n\t\tspin_unlock_irqrestore(&video->qlock, flags);\n\t\treturn;\n\t}\n\n\tempty = list_empty(&video->dmaqueue);\n\tlist_add_tail(&buffer->list, &video->dmaqueue);\n\n\tspin_unlock_irqrestore(&video->qlock, flags);\n\n\tif (empty) {\n\t\tenum iss_pipeline_state state;\n\t\tunsigned int start;\n\n\t\tif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\tstate = ISS_PIPELINE_QUEUE_OUTPUT;\n\t\telse\n\t\t\tstate = ISS_PIPELINE_QUEUE_INPUT;\n\n\t\tspin_lock_irqsave(&pipe->lock, flags);\n\t\tpipe->state |= state;\n\t\tvideo->ops->queue(video, buffer);\n\t\tvideo->dmaqueue_flags |= ISS_VIDEO_DMAQUEUE_QUEUED;\n\n\t\tstart = iss_pipeline_ready(pipe);\n\t\tif (start)\n\t\t\tpipe->state |= ISS_PIPELINE_STREAM;\n\t\tspin_unlock_irqrestore(&pipe->lock, flags);\n\n\t\tif (start)\n\t\t\tomap4iss_pipeline_set_stream(pipe,\n\t\t\t\t\t\t     ISS_PIPELINE_STREAM_SINGLESHOT);\n\t}\n}\n\nstatic const struct vb2_ops iss_video_vb2ops = {\n\t.queue_setup\t= iss_video_queue_setup,\n\t.buf_prepare\t= iss_video_buf_prepare,\n\t.buf_queue\t= iss_video_buf_queue,\n\t.buf_cleanup\t= iss_video_buf_cleanup,\n};\n\n \nstruct iss_buffer *omap4iss_video_buffer_next(struct iss_video *video)\n{\n\tstruct iss_pipeline *pipe = to_iss_pipeline(&video->video.entity);\n\tenum iss_pipeline_state state;\n\tstruct iss_buffer *buf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&video->qlock, flags);\n\tif (WARN_ON(list_empty(&video->dmaqueue))) {\n\t\tspin_unlock_irqrestore(&video->qlock, flags);\n\t\treturn NULL;\n\t}\n\n\tbuf = list_first_entry(&video->dmaqueue, struct iss_buffer,\n\t\t\t       list);\n\tlist_del(&buf->list);\n\tspin_unlock_irqrestore(&video->qlock, flags);\n\n\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\n\t \n\tif (video == pipe->output && !pipe->do_propagation)\n\t\tbuf->vb.sequence =\n\t\t\tatomic_inc_return(&pipe->frame_number);\n\telse\n\t\tbuf->vb.sequence = atomic_read(&pipe->frame_number);\n\n\tvb2_buffer_done(&buf->vb.vb2_buf, pipe->error ?\n\t\t\tVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\tpipe->error = false;\n\n\tspin_lock_irqsave(&video->qlock, flags);\n\tif (list_empty(&video->dmaqueue)) {\n\t\tspin_unlock_irqrestore(&video->qlock, flags);\n\t\tif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\tstate = ISS_PIPELINE_QUEUE_OUTPUT\n\t\t\t      | ISS_PIPELINE_STREAM;\n\t\telse\n\t\t\tstate = ISS_PIPELINE_QUEUE_INPUT\n\t\t\t      | ISS_PIPELINE_STREAM;\n\n\t\tspin_lock_irqsave(&pipe->lock, flags);\n\t\tpipe->state &= ~state;\n\t\tif (video->pipe.stream_state == ISS_PIPELINE_STREAM_CONTINUOUS)\n\t\t\tvideo->dmaqueue_flags |= ISS_VIDEO_DMAQUEUE_UNDERRUN;\n\t\tspin_unlock_irqrestore(&pipe->lock, flags);\n\t\treturn NULL;\n\t}\n\n\tif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE && pipe->input) {\n\t\tspin_lock(&pipe->lock);\n\t\tpipe->state &= ~ISS_PIPELINE_STREAM;\n\t\tspin_unlock(&pipe->lock);\n\t}\n\n\tbuf = list_first_entry(&video->dmaqueue, struct iss_buffer,\n\t\t\t       list);\n\tspin_unlock_irqrestore(&video->qlock, flags);\n\tbuf->vb.vb2_buf.state = VB2_BUF_STATE_ACTIVE;\n\treturn buf;\n}\n\n \nvoid omap4iss_video_cancel_stream(struct iss_video *video)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&video->qlock, flags);\n\n\twhile (!list_empty(&video->dmaqueue)) {\n\t\tstruct iss_buffer *buf;\n\n\t\tbuf = list_first_entry(&video->dmaqueue, struct iss_buffer,\n\t\t\t\t       list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\n\tvb2_queue_error(video->queue);\n\tvideo->error = true;\n\n\tspin_unlock_irqrestore(&video->qlock, flags);\n}\n\n \n\nstatic int\niss_video_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\n{\n\tstruct iss_video *video = video_drvdata(file);\n\n\tstrscpy(cap->driver, ISS_VIDEO_DRIVER_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, video->video.name, sizeof(cap->card));\n\tstrscpy(cap->bus_info, \"media\", sizeof(cap->bus_info));\n\tcap->capabilities = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_STREAMING\n\t\t\t  | V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\n\treturn 0;\n}\n\nstatic int\niss_video_enum_format(struct file *file, void *fh, struct v4l2_fmtdesc *f)\n{\n\tstruct iss_video *video = video_drvdata(file);\n\tstruct v4l2_mbus_framefmt format;\n\tunsigned int index = f->index;\n\tunsigned int i;\n\tint ret;\n\n\tif (f->type != video->type)\n\t\treturn -EINVAL;\n\n\tret = __iss_video_get_format(video, &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); ++i) {\n\t\tconst struct iss_format_info *info = &formats[i];\n\n\t\tif (format.code != info->code)\n\t\t\tcontinue;\n\n\t\tif (index == 0) {\n\t\t\tf->pixelformat = info->pixelformat;\n\t\t\treturn 0;\n\t\t}\n\n\t\tindex--;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\niss_video_get_format(struct file *file, void *fh, struct v4l2_format *format)\n{\n\tstruct iss_video_fh *vfh = to_iss_video_fh(fh);\n\tstruct iss_video *video = video_drvdata(file);\n\n\tif (format->type != video->type)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&video->mutex);\n\t*format = vfh->format;\n\tmutex_unlock(&video->mutex);\n\n\treturn 0;\n}\n\nstatic int\niss_video_set_format(struct file *file, void *fh, struct v4l2_format *format)\n{\n\tstruct iss_video_fh *vfh = to_iss_video_fh(fh);\n\tstruct iss_video *video = video_drvdata(file);\n\tstruct v4l2_mbus_framefmt fmt;\n\n\tif (format->type != video->type)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&video->mutex);\n\n\t \n\tiss_video_pix_to_mbus(&format->fmt.pix, &fmt);\n\tiss_video_mbus_to_pix(video, &fmt, &format->fmt.pix);\n\n\tvfh->format = *format;\n\n\tmutex_unlock(&video->mutex);\n\treturn 0;\n}\n\nstatic int\niss_video_try_format(struct file *file, void *fh, struct v4l2_format *format)\n{\n\tstruct iss_video *video = video_drvdata(file);\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_subdev *subdev;\n\tu32 pad;\n\tint ret;\n\n\tif (format->type != video->type)\n\t\treturn -EINVAL;\n\n\tsubdev = iss_video_remote_subdev(video, &pad);\n\tif (!subdev)\n\t\treturn -EINVAL;\n\n\tiss_video_pix_to_mbus(&format->fmt.pix, &fmt.format);\n\n\tfmt.pad = pad;\n\tret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tiss_video_mbus_to_pix(video, &fmt.format, &format->fmt.pix);\n\treturn 0;\n}\n\nstatic int\niss_video_get_selection(struct file *file, void *fh, struct v4l2_selection *sel)\n{\n\tstruct iss_video *video = video_drvdata(file);\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_subdev *subdev;\n\tstruct v4l2_subdev_selection sdsel = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.target = sel->target,\n\t};\n\tu32 pad;\n\tint ret;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\t\tif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsubdev = iss_video_remote_subdev(video, &pad);\n\tif (!subdev)\n\t\treturn -EINVAL;\n\n\t \n\tsdsel.pad = pad;\n\tret = v4l2_subdev_call(subdev, pad, get_selection, NULL, &sdsel);\n\tif (!ret)\n\t\tsel->r = sdsel.r;\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\tformat.pad = pad;\n\tret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &format);\n\tif (ret < 0)\n\t\treturn ret == -ENOIOCTLCMD ? -ENOTTY : ret;\n\n\tsel->r.left = 0;\n\tsel->r.top = 0;\n\tsel->r.width = format.format.width;\n\tsel->r.height = format.format.height;\n\n\treturn 0;\n}\n\nstatic int\niss_video_set_selection(struct file *file, void *fh, struct v4l2_selection *sel)\n{\n\tstruct iss_video *video = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\tstruct v4l2_subdev_selection sdsel = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.target = sel->target,\n\t\t.flags = sel->flags,\n\t\t.r = sel->r,\n\t};\n\tu32 pad;\n\tint ret;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsubdev = iss_video_remote_subdev(video, &pad);\n\tif (!subdev)\n\t\treturn -EINVAL;\n\n\tsdsel.pad = pad;\n\tmutex_lock(&video->mutex);\n\tret = v4l2_subdev_call(subdev, pad, set_selection, NULL, &sdsel);\n\tmutex_unlock(&video->mutex);\n\tif (!ret)\n\t\tsel->r = sdsel.r;\n\n\treturn ret == -ENOIOCTLCMD ? -ENOTTY : ret;\n}\n\nstatic int\niss_video_get_param(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct iss_video_fh *vfh = to_iss_video_fh(fh);\n\tstruct iss_video *video = video_drvdata(file);\n\n\tif (video->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||\n\t    video->type != a->type)\n\t\treturn -EINVAL;\n\n\tmemset(a, 0, sizeof(*a));\n\ta->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\ta->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\n\ta->parm.output.timeperframe = vfh->timeperframe;\n\n\treturn 0;\n}\n\nstatic int\niss_video_set_param(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct iss_video_fh *vfh = to_iss_video_fh(fh);\n\tstruct iss_video *video = video_drvdata(file);\n\n\tif (video->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||\n\t    video->type != a->type)\n\t\treturn -EINVAL;\n\n\tif (a->parm.output.timeperframe.denominator == 0)\n\t\ta->parm.output.timeperframe.denominator = 1;\n\n\tvfh->timeperframe = a->parm.output.timeperframe;\n\n\treturn 0;\n}\n\nstatic int\niss_video_reqbufs(struct file *file, void *fh, struct v4l2_requestbuffers *rb)\n{\n\tstruct iss_video_fh *vfh = to_iss_video_fh(fh);\n\n\treturn vb2_reqbufs(&vfh->queue, rb);\n}\n\nstatic int\niss_video_querybuf(struct file *file, void *fh, struct v4l2_buffer *b)\n{\n\tstruct iss_video_fh *vfh = to_iss_video_fh(fh);\n\n\treturn vb2_querybuf(&vfh->queue, b);\n}\n\nstatic int\niss_video_qbuf(struct file *file, void *fh, struct v4l2_buffer *b)\n{\n\tstruct iss_video *video = video_drvdata(file);\n\tstruct iss_video_fh *vfh = to_iss_video_fh(fh);\n\n\treturn vb2_qbuf(&vfh->queue, video->video.v4l2_dev->mdev, b);\n}\n\nstatic int\niss_video_expbuf(struct file *file, void *fh, struct v4l2_exportbuffer *e)\n{\n\tstruct iss_video_fh *vfh = to_iss_video_fh(fh);\n\n\treturn vb2_expbuf(&vfh->queue, e);\n}\n\nstatic int\niss_video_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)\n{\n\tstruct iss_video_fh *vfh = to_iss_video_fh(fh);\n\n\treturn vb2_dqbuf(&vfh->queue, b, file->f_flags & O_NONBLOCK);\n}\n\n \nstatic int\niss_video_streamon(struct file *file, void *fh, enum v4l2_buf_type type)\n{\n\tstruct iss_video_fh *vfh = to_iss_video_fh(fh);\n\tstruct iss_video *video = video_drvdata(file);\n\tstruct media_device *mdev = video->video.entity.graph_obj.mdev;\n\tstruct media_pipeline_pad_iter iter;\n\tenum iss_pipeline_state state;\n\tstruct iss_pipeline *pipe;\n\tstruct iss_video *far_end;\n\tstruct media_pad *pad;\n\tunsigned long flags;\n\tint ret;\n\n\tif (type != video->type)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&video->stream_lock);\n\n\t \n\tpipe = to_iss_pipeline(&video->video.entity) ? : &video->pipe;\n\tpipe->external = NULL;\n\tpipe->external_rate = 0;\n\tpipe->external_bpp = 0;\n\n\tret = media_entity_enum_init(&pipe->ent_enum, mdev);\n\tif (ret)\n\t\tgoto err_entity_enum_init;\n\n\tif (video->iss->pdata->set_constraints)\n\t\tvideo->iss->pdata->set_constraints(video->iss, true);\n\n\tret = video_device_pipeline_start(&video->video, &pipe->pipe);\n\tif (ret < 0)\n\t\tgoto err_media_pipeline_start;\n\n\tmedia_pipeline_for_each_pad(&pipe->pipe, &iter, pad)\n\t\tmedia_entity_enum_set(&pipe->ent_enum, pad->entity);\n\n\t \n\tret = iss_video_check_format(video, vfh);\n\tif (ret < 0)\n\t\tgoto err_iss_video_check_format;\n\n\tvideo->bpl_padding = ret;\n\tvideo->bpl_value = vfh->format.fmt.pix.bytesperline;\n\n\t \n\tfar_end = iss_video_far_end(video, pipe);\n\tif (IS_ERR(far_end)) {\n\t\tret = PTR_ERR(far_end);\n\t\tgoto err_iss_video_check_format;\n\t}\n\n\tif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tstate = ISS_PIPELINE_STREAM_OUTPUT | ISS_PIPELINE_IDLE_OUTPUT;\n\t\tpipe->input = far_end;\n\t\tpipe->output = video;\n\t} else {\n\t\tif (!far_end) {\n\t\t\tret = -EPIPE;\n\t\t\tgoto err_iss_video_check_format;\n\t\t}\n\n\t\tstate = ISS_PIPELINE_STREAM_INPUT | ISS_PIPELINE_IDLE_INPUT;\n\t\tpipe->input = video;\n\t\tpipe->output = far_end;\n\t}\n\n\tspin_lock_irqsave(&pipe->lock, flags);\n\tpipe->state &= ~ISS_PIPELINE_STREAM;\n\tpipe->state |= state;\n\tspin_unlock_irqrestore(&pipe->lock, flags);\n\n\t \n\tif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tpipe->max_timeperframe = vfh->timeperframe;\n\n\tvideo->queue = &vfh->queue;\n\tINIT_LIST_HEAD(&video->dmaqueue);\n\tvideo->error = false;\n\tatomic_set(&pipe->frame_number, -1);\n\n\tret = vb2_streamon(&vfh->queue, type);\n\tif (ret < 0)\n\t\tgoto err_iss_video_check_format;\n\n\t \n\tif (!pipe->input) {\n\t\tunsigned long flags;\n\n\t\tret = omap4iss_pipeline_set_stream(pipe,\n\t\t\t\t\t\t   ISS_PIPELINE_STREAM_CONTINUOUS);\n\t\tif (ret < 0)\n\t\t\tgoto err_omap4iss_set_stream;\n\t\tspin_lock_irqsave(&video->qlock, flags);\n\t\tif (list_empty(&video->dmaqueue))\n\t\t\tvideo->dmaqueue_flags |= ISS_VIDEO_DMAQUEUE_UNDERRUN;\n\t\tspin_unlock_irqrestore(&video->qlock, flags);\n\t}\n\n\tmutex_unlock(&video->stream_lock);\n\n\treturn 0;\n\nerr_omap4iss_set_stream:\n\tvb2_streamoff(&vfh->queue, type);\nerr_iss_video_check_format:\n\tvideo_device_pipeline_stop(&video->video);\nerr_media_pipeline_start:\n\tif (video->iss->pdata->set_constraints)\n\t\tvideo->iss->pdata->set_constraints(video->iss, false);\n\tvideo->queue = NULL;\n\nerr_entity_enum_init:\n\tmedia_entity_enum_cleanup(&pipe->ent_enum);\n\n\tmutex_unlock(&video->stream_lock);\n\n\treturn ret;\n}\n\nstatic int\niss_video_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)\n{\n\tstruct iss_video_fh *vfh = to_iss_video_fh(fh);\n\tstruct iss_video *video = video_drvdata(file);\n\tstruct iss_pipeline *pipe = to_iss_pipeline(&video->video.entity);\n\tenum iss_pipeline_state state;\n\tunsigned long flags;\n\n\tif (type != video->type)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&video->stream_lock);\n\n\tif (!vb2_is_streaming(&vfh->queue))\n\t\tgoto done;\n\n\t \n\tif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tstate = ISS_PIPELINE_STREAM_OUTPUT\n\t\t      | ISS_PIPELINE_QUEUE_OUTPUT;\n\telse\n\t\tstate = ISS_PIPELINE_STREAM_INPUT\n\t\t      | ISS_PIPELINE_QUEUE_INPUT;\n\n\tspin_lock_irqsave(&pipe->lock, flags);\n\tpipe->state &= ~state;\n\tspin_unlock_irqrestore(&pipe->lock, flags);\n\n\t \n\tomap4iss_pipeline_set_stream(pipe, ISS_PIPELINE_STREAM_STOPPED);\n\tvb2_streamoff(&vfh->queue, type);\n\tvideo->queue = NULL;\n\n\tmedia_entity_enum_cleanup(&pipe->ent_enum);\n\n\tif (video->iss->pdata->set_constraints)\n\t\tvideo->iss->pdata->set_constraints(video->iss, false);\n\tvideo_device_pipeline_stop(&video->video);\n\ndone:\n\tmutex_unlock(&video->stream_lock);\n\treturn 0;\n}\n\nstatic int\niss_video_enum_input(struct file *file, void *fh, struct v4l2_input *input)\n{\n\tif (input->index > 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(input->name, \"camera\", sizeof(input->name));\n\tinput->type = V4L2_INPUT_TYPE_CAMERA;\n\n\treturn 0;\n}\n\nstatic int\niss_video_g_input(struct file *file, void *fh, unsigned int *input)\n{\n\t*input = 0;\n\n\treturn 0;\n}\n\nstatic int\niss_video_s_input(struct file *file, void *fh, unsigned int input)\n{\n\treturn input == 0 ? 0 : -EINVAL;\n}\n\nstatic const struct v4l2_ioctl_ops iss_video_ioctl_ops = {\n\t.vidioc_querycap\t\t= iss_video_querycap,\n\t.vidioc_enum_fmt_vid_cap        = iss_video_enum_format,\n\t.vidioc_g_fmt_vid_cap\t\t= iss_video_get_format,\n\t.vidioc_s_fmt_vid_cap\t\t= iss_video_set_format,\n\t.vidioc_try_fmt_vid_cap\t\t= iss_video_try_format,\n\t.vidioc_g_fmt_vid_out\t\t= iss_video_get_format,\n\t.vidioc_s_fmt_vid_out\t\t= iss_video_set_format,\n\t.vidioc_try_fmt_vid_out\t\t= iss_video_try_format,\n\t.vidioc_g_selection\t\t= iss_video_get_selection,\n\t.vidioc_s_selection\t\t= iss_video_set_selection,\n\t.vidioc_g_parm\t\t\t= iss_video_get_param,\n\t.vidioc_s_parm\t\t\t= iss_video_set_param,\n\t.vidioc_reqbufs\t\t\t= iss_video_reqbufs,\n\t.vidioc_querybuf\t\t= iss_video_querybuf,\n\t.vidioc_qbuf\t\t\t= iss_video_qbuf,\n\t.vidioc_expbuf\t\t\t= iss_video_expbuf,\n\t.vidioc_dqbuf\t\t\t= iss_video_dqbuf,\n\t.vidioc_streamon\t\t= iss_video_streamon,\n\t.vidioc_streamoff\t\t= iss_video_streamoff,\n\t.vidioc_enum_input\t\t= iss_video_enum_input,\n\t.vidioc_g_input\t\t\t= iss_video_g_input,\n\t.vidioc_s_input\t\t\t= iss_video_s_input,\n};\n\n \n\nstatic int iss_video_open(struct file *file)\n{\n\tstruct iss_video *video = video_drvdata(file);\n\tstruct iss_video_fh *handle;\n\tstruct vb2_queue *q;\n\tint ret = 0;\n\n\thandle = kzalloc(sizeof(*handle), GFP_KERNEL);\n\tif (!handle)\n\t\treturn -ENOMEM;\n\n\tv4l2_fh_init(&handle->vfh, &video->video);\n\tv4l2_fh_add(&handle->vfh);\n\n\t \n\tif (!omap4iss_get(video->iss)) {\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\n\tret = v4l2_pipeline_pm_get(&video->video.entity);\n\tif (ret < 0) {\n\t\tomap4iss_put(video->iss);\n\t\tgoto done;\n\t}\n\n\tq = &handle->queue;\n\n\tq->type = video->type;\n\tq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tq->drv_priv = handle;\n\tq->ops = &iss_video_vb2ops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->buf_struct_size = sizeof(struct iss_buffer);\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->dev = video->iss->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret) {\n\t\tomap4iss_put(video->iss);\n\t\tgoto done;\n\t}\n\n\tmemset(&handle->format, 0, sizeof(handle->format));\n\thandle->format.type = video->type;\n\thandle->timeperframe.denominator = 1;\n\n\thandle->video = video;\n\tfile->private_data = &handle->vfh;\n\ndone:\n\tif (ret < 0) {\n\t\tv4l2_fh_del(&handle->vfh);\n\t\tv4l2_fh_exit(&handle->vfh);\n\t\tkfree(handle);\n\t}\n\n\treturn ret;\n}\n\nstatic int iss_video_release(struct file *file)\n{\n\tstruct iss_video *video = video_drvdata(file);\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct iss_video_fh *handle = to_iss_video_fh(vfh);\n\n\t \n\tiss_video_streamoff(file, vfh, video->type);\n\n\tv4l2_pipeline_pm_put(&video->video.entity);\n\n\t \n\tvb2_queue_release(&handle->queue);\n\n\tv4l2_fh_del(vfh);\n\tv4l2_fh_exit(vfh);\n\tkfree(handle);\n\tfile->private_data = NULL;\n\n\tomap4iss_put(video->iss);\n\n\treturn 0;\n}\n\nstatic __poll_t iss_video_poll(struct file *file, poll_table *wait)\n{\n\tstruct iss_video_fh *vfh = to_iss_video_fh(file->private_data);\n\n\treturn vb2_poll(&vfh->queue, file, wait);\n}\n\nstatic int iss_video_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct iss_video_fh *vfh = to_iss_video_fh(file->private_data);\n\n\treturn vb2_mmap(&vfh->queue, vma);\n}\n\nstatic const struct v4l2_file_operations iss_video_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = video_ioctl2,\n\t.open = iss_video_open,\n\t.release = iss_video_release,\n\t.poll = iss_video_poll,\n\t.mmap = iss_video_mmap,\n};\n\n \n\nstatic const struct iss_video_operations iss_video_dummy_ops = {\n};\n\nint omap4iss_video_init(struct iss_video *video, const char *name)\n{\n\tconst char *direction;\n\tint ret;\n\n\tswitch (video->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tdirection = \"output\";\n\t\tvideo->pad.flags = MEDIA_PAD_FL_SINK;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tdirection = \"input\";\n\t\tvideo->pad.flags = MEDIA_PAD_FL_SOURCE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = media_entity_pads_init(&video->video.entity, 1, &video->pad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tspin_lock_init(&video->qlock);\n\tmutex_init(&video->mutex);\n\tatomic_set(&video->active, 0);\n\n\tspin_lock_init(&video->pipe.lock);\n\tmutex_init(&video->stream_lock);\n\n\t \n\tif (!video->ops)\n\t\tvideo->ops = &iss_video_dummy_ops;\n\n\tvideo->video.fops = &iss_video_fops;\n\tsnprintf(video->video.name, sizeof(video->video.name),\n\t\t \"OMAP4 ISS %s %s\", name, direction);\n\tvideo->video.vfl_type = VFL_TYPE_VIDEO;\n\tvideo->video.release = video_device_release_empty;\n\tvideo->video.ioctl_ops = &iss_video_ioctl_ops;\n\tvideo->pipe.stream_state = ISS_PIPELINE_STREAM_STOPPED;\n\n\tvideo_set_drvdata(&video->video, video);\n\n\treturn 0;\n}\n\nvoid omap4iss_video_cleanup(struct iss_video *video)\n{\n\tmedia_entity_cleanup(&video->video.entity);\n\tmutex_destroy(&video->stream_lock);\n\tmutex_destroy(&video->mutex);\n}\n\nint omap4iss_video_register(struct iss_video *video, struct v4l2_device *vdev)\n{\n\tint ret;\n\n\tvideo->video.v4l2_dev = vdev;\n\tif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tvideo->video.device_caps = V4L2_CAP_VIDEO_CAPTURE;\n\telse\n\t\tvideo->video.device_caps = V4L2_CAP_VIDEO_OUTPUT;\n\tvideo->video.device_caps |= V4L2_CAP_STREAMING;\n\n\tret = video_register_device(&video->video, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0)\n\t\tdev_err(video->iss->dev,\n\t\t\t\"could not register video device (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nvoid omap4iss_video_unregister(struct iss_video *video)\n{\n\tvideo_unregister_device(&video->video);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}