{
  "module_name": "iss_csiphy.c",
  "hash_id": "9f0802df3a724d5484e34ea0cef6b0b3341a34242de13b6fe7b08d273ea22a92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/omap4iss/iss_csiphy.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/regmap.h>\n\n#include \"../../../../arch/arm/mach-omap2/control.h\"\n\n#include \"iss.h\"\n#include \"iss_regs.h\"\n#include \"iss_csiphy.h\"\n\n \nstatic void csiphy_lanes_config(struct iss_csiphy *phy)\n{\n\tunsigned int i;\n\tu32 reg;\n\n\treg = iss_reg_read(phy->iss, phy->cfg_regs, CSI2_COMPLEXIO_CFG);\n\n\tfor (i = 0; i < phy->max_data_lanes; i++) {\n\t\treg &= ~(CSI2_COMPLEXIO_CFG_DATA_POL(i + 1) |\n\t\t\t CSI2_COMPLEXIO_CFG_DATA_POSITION_MASK(i + 1));\n\t\treg |= (phy->lanes.data[i].pol ?\n\t\t\tCSI2_COMPLEXIO_CFG_DATA_POL(i + 1) : 0);\n\t\treg |= (phy->lanes.data[i].pos <<\n\t\t\tCSI2_COMPLEXIO_CFG_DATA_POSITION_SHIFT(i + 1));\n\t}\n\n\treg &= ~(CSI2_COMPLEXIO_CFG_CLOCK_POL |\n\t\t CSI2_COMPLEXIO_CFG_CLOCK_POSITION_MASK);\n\treg |= phy->lanes.clk.pol ? CSI2_COMPLEXIO_CFG_CLOCK_POL : 0;\n\treg |= phy->lanes.clk.pos << CSI2_COMPLEXIO_CFG_CLOCK_POSITION_SHIFT;\n\n\tiss_reg_write(phy->iss, phy->cfg_regs, CSI2_COMPLEXIO_CFG, reg);\n}\n\n \nstatic int csiphy_set_power(struct iss_csiphy *phy, u32 power)\n{\n\tu32 reg;\n\tu8 retry_count;\n\n\tiss_reg_update(phy->iss, phy->cfg_regs, CSI2_COMPLEXIO_CFG,\n\t\t       CSI2_COMPLEXIO_CFG_PWD_CMD_MASK,\n\t\t       power | CSI2_COMPLEXIO_CFG_PWR_AUTO);\n\n\tretry_count = 0;\n\tdo {\n\t\tudelay(1);\n\t\treg = iss_reg_read(phy->iss, phy->cfg_regs, CSI2_COMPLEXIO_CFG)\n\t\t    & CSI2_COMPLEXIO_CFG_PWD_STATUS_MASK;\n\n\t\tif (reg != power >> 2)\n\t\t\tretry_count++;\n\n\t} while ((reg != power >> 2) && (retry_count < 250));\n\n\tif (retry_count == 250) {\n\t\tdev_err(phy->iss->dev, \"CSI2 CIO set power failed!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void csiphy_dphy_config(struct iss_csiphy *phy)\n{\n\tu32 reg;\n\n\t \n\treg = phy->dphy.ths_term << REGISTER0_THS_TERM_SHIFT;\n\treg |= phy->dphy.ths_settle << REGISTER0_THS_SETTLE_SHIFT;\n\n\tiss_reg_write(phy->iss, phy->phy_regs, REGISTER0, reg);\n\n\t \n\treg = phy->dphy.tclk_term << REGISTER1_TCLK_TERM_SHIFT;\n\treg |= phy->dphy.tclk_miss << REGISTER1_CTRLCLK_DIV_FACTOR_SHIFT;\n\treg |= phy->dphy.tclk_settle << REGISTER1_TCLK_SETTLE_SHIFT;\n\treg |= 0xb8 << REGISTER1_DPHY_HS_SYNC_PATTERN_SHIFT;\n\n\tiss_reg_write(phy->iss, phy->phy_regs, REGISTER1, reg);\n}\n\n \n#define TCLK_TERM\t0\n#define TCLK_MISS\t1\n#define TCLK_SETTLE\t14\n\nint omap4iss_csiphy_config(struct iss_device *iss,\n\t\t\t   struct v4l2_subdev *csi2_subdev)\n{\n\tstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(csi2_subdev);\n\tstruct iss_pipeline *pipe = to_iss_pipeline(&csi2_subdev->entity);\n\tstruct iss_v4l2_subdevs_group *subdevs = pipe->external->host_priv;\n\tstruct iss_csiphy_dphy_cfg csi2phy;\n\tint csi2_ddrclk_khz;\n\tstruct iss_csiphy_lanes_cfg *lanes;\n\tunsigned int used_lanes = 0;\n\tu32 cam_rx_ctrl;\n\tunsigned int i;\n\n\tlanes = &subdevs->bus.csi2.lanecfg;\n\n\t \n\t \n\tregmap_read(iss->syscon, 0x68, &cam_rx_ctrl);\n\n\tif (subdevs->interface == ISS_INTERFACE_CSI2A_PHY1) {\n\t\tcam_rx_ctrl &= ~(OMAP4_CAMERARX_CSI21_LANEENABLE_MASK |\n\t\t\t\tOMAP4_CAMERARX_CSI21_CAMMODE_MASK);\n\t\t \n\t\t \n\t\tcam_rx_ctrl |=\n\t\t\t0x1f << OMAP4_CAMERARX_CSI21_LANEENABLE_SHIFT;\n\t\t \n\t\tcam_rx_ctrl |= OMAP4_CAMERARX_CSI21_CTRLCLKEN_MASK;\n\t}\n\n\tif (subdevs->interface == ISS_INTERFACE_CSI2B_PHY2) {\n\t\tcam_rx_ctrl &= ~(OMAP4_CAMERARX_CSI22_LANEENABLE_MASK |\n\t\t\t\tOMAP4_CAMERARX_CSI22_CAMMODE_MASK);\n\t\t \n\t\t \n\t\tcam_rx_ctrl |=\n\t\t\t0x3 << OMAP4_CAMERARX_CSI22_LANEENABLE_SHIFT;\n\t\t \n\t\tcam_rx_ctrl |= OMAP4_CAMERARX_CSI22_CTRLCLKEN_MASK;\n\t}\n\n\tregmap_write(iss->syscon, 0x68, cam_rx_ctrl);\n\n\t \n\tcsi2->phy->used_data_lanes = 0;\n\n\t \n\tfor (i = 0; i < csi2->phy->max_data_lanes; i++) {\n\t\tif (lanes->data[i].pos == 0)\n\t\t\tcontinue;\n\n\t\tif (lanes->data[i].pol > 1 ||\n\t\t    lanes->data[i].pos > (csi2->phy->max_data_lanes + 1))\n\t\t\treturn -EINVAL;\n\n\t\tif (used_lanes & (1 << lanes->data[i].pos))\n\t\t\treturn -EINVAL;\n\n\t\tused_lanes |= 1 << lanes->data[i].pos;\n\t\tcsi2->phy->used_data_lanes++;\n\t}\n\n\tif (lanes->clk.pol > 1 ||\n\t    lanes->clk.pos > (csi2->phy->max_data_lanes + 1))\n\t\treturn -EINVAL;\n\n\tif (lanes->clk.pos == 0 || used_lanes & (1 << lanes->clk.pos))\n\t\treturn -EINVAL;\n\n\tcsi2_ddrclk_khz = pipe->external_rate / 1000\n\t\t/ (2 * csi2->phy->used_data_lanes)\n\t\t* pipe->external_bpp;\n\n\t \n\tcsi2phy.ths_term = DIV_ROUND_UP(25 * csi2_ddrclk_khz, 2000000) - 1;\n\tcsi2phy.ths_settle = DIV_ROUND_UP(90 * csi2_ddrclk_khz, 1000000) + 3;\n\tcsi2phy.tclk_term = TCLK_TERM;\n\tcsi2phy.tclk_miss = TCLK_MISS;\n\tcsi2phy.tclk_settle = TCLK_SETTLE;\n\n\tmutex_lock(&csi2->phy->mutex);\n\tcsi2->phy->dphy = csi2phy;\n\tcsi2->phy->lanes = *lanes;\n\tmutex_unlock(&csi2->phy->mutex);\n\n\treturn 0;\n}\n\nint omap4iss_csiphy_acquire(struct iss_csiphy *phy)\n{\n\tint rval;\n\n\tmutex_lock(&phy->mutex);\n\n\trval = omap4iss_csi2_reset(phy->csi2);\n\tif (rval)\n\t\tgoto done;\n\n\tcsiphy_dphy_config(phy);\n\tcsiphy_lanes_config(phy);\n\n\trval = csiphy_set_power(phy, CSI2_COMPLEXIO_CFG_PWD_CMD_ON);\n\tif (rval)\n\t\tgoto done;\n\n\tphy->phy_in_use = 1;\n\ndone:\n\tmutex_unlock(&phy->mutex);\n\treturn rval;\n}\n\nvoid omap4iss_csiphy_release(struct iss_csiphy *phy)\n{\n\tmutex_lock(&phy->mutex);\n\tif (phy->phy_in_use) {\n\t\tcsiphy_set_power(phy, CSI2_COMPLEXIO_CFG_PWD_CMD_OFF);\n\t\tphy->phy_in_use = 0;\n\t}\n\tmutex_unlock(&phy->mutex);\n}\n\n \nint omap4iss_csiphy_init(struct iss_device *iss)\n{\n\tstruct iss_csiphy *phy1 = &iss->csiphy1;\n\tstruct iss_csiphy *phy2 = &iss->csiphy2;\n\n\tphy1->iss = iss;\n\tphy1->csi2 = &iss->csi2a;\n\tphy1->max_data_lanes = ISS_CSIPHY1_NUM_DATA_LANES;\n\tphy1->used_data_lanes = 0;\n\tphy1->cfg_regs = OMAP4_ISS_MEM_CSI2_A_REGS1;\n\tphy1->phy_regs = OMAP4_ISS_MEM_CAMERARX_CORE1;\n\tmutex_init(&phy1->mutex);\n\n\tphy2->iss = iss;\n\tphy2->csi2 = &iss->csi2b;\n\tphy2->max_data_lanes = ISS_CSIPHY2_NUM_DATA_LANES;\n\tphy2->used_data_lanes = 0;\n\tphy2->cfg_regs = OMAP4_ISS_MEM_CSI2_B_REGS1;\n\tphy2->phy_regs = OMAP4_ISS_MEM_CAMERARX_CORE2;\n\tmutex_init(&phy2->mutex);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}