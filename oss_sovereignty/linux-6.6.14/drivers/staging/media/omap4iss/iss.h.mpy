{
  "module_name": "iss.h",
  "hash_id": "50f3eecdfc710196198f295b952aa1aa5dab78cb27fe7b2e2f592990d781788e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/omap4iss/iss.h",
  "human_readable_source": " \n \n\n#ifndef _OMAP4_ISS_H_\n#define _OMAP4_ISS_H_\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-mc.h>\n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/wait.h>\n\n#include <linux/platform_data/media/omap4iss.h>\n\n#include \"iss_regs.h\"\n#include \"iss_csiphy.h\"\n#include \"iss_csi2.h\"\n#include \"iss_ipipeif.h\"\n#include \"iss_ipipe.h\"\n#include \"iss_resizer.h\"\n\nstruct regmap;\n\n#define to_iss_device(ptr_module)\t\t\t\t\\\n\tcontainer_of(ptr_module, struct iss_device, ptr_module)\n#define to_device(ptr_module)\t\t\t\t\t\t\\\n\t(to_iss_device(ptr_module)->dev)\n\nenum iss_mem_resources {\n\tOMAP4_ISS_MEM_TOP,\n\tOMAP4_ISS_MEM_CSI2_A_REGS1,\n\tOMAP4_ISS_MEM_CAMERARX_CORE1,\n\tOMAP4_ISS_MEM_CSI2_B_REGS1,\n\tOMAP4_ISS_MEM_CAMERARX_CORE2,\n\tOMAP4_ISS_MEM_BTE,\n\tOMAP4_ISS_MEM_ISP_SYS1,\n\tOMAP4_ISS_MEM_ISP_RESIZER,\n\tOMAP4_ISS_MEM_ISP_IPIPE,\n\tOMAP4_ISS_MEM_ISP_ISIF,\n\tOMAP4_ISS_MEM_ISP_IPIPEIF,\n\tOMAP4_ISS_MEM_LAST,\n};\n\nenum iss_subclk_resource {\n\tOMAP4_ISS_SUBCLK_SIMCOP\t\t= (1 << 0),\n\tOMAP4_ISS_SUBCLK_ISP\t\t= (1 << 1),\n\tOMAP4_ISS_SUBCLK_CSI2_A\t\t= (1 << 2),\n\tOMAP4_ISS_SUBCLK_CSI2_B\t\t= (1 << 3),\n\tOMAP4_ISS_SUBCLK_CCP2\t\t= (1 << 4),\n};\n\nenum iss_isp_subclk_resource {\n\tOMAP4_ISS_ISP_SUBCLK_BL\t\t= (1 << 0),\n\tOMAP4_ISS_ISP_SUBCLK_ISIF\t= (1 << 1),\n\tOMAP4_ISS_ISP_SUBCLK_H3A\t= (1 << 2),\n\tOMAP4_ISS_ISP_SUBCLK_RSZ\t= (1 << 3),\n\tOMAP4_ISS_ISP_SUBCLK_IPIPE\t= (1 << 4),\n\tOMAP4_ISS_ISP_SUBCLK_IPIPEIF\t= (1 << 5),\n};\n\n \nstruct iss_reg {\n\tenum iss_mem_resources mmio_range;\n\tu32 reg;\n\tu32 val;\n};\n\n \nstruct iss_device {\n\tstruct v4l2_device v4l2_dev;\n\tstruct media_device media_dev;\n\tstruct device *dev;\n\tu32 revision;\n\n\t \n\tstruct iss_platform_data *pdata;\n\tunsigned int irq_num;\n\n\tstruct resource *res[OMAP4_ISS_MEM_LAST];\n\tvoid __iomem *regs[OMAP4_ISS_MEM_LAST];\n\tstruct regmap *syscon;\n\n\tu64 raw_dmamask;\n\n\tstruct mutex iss_mutex;\t \n\tstruct media_entity_enum crashed;\n\tint has_context;\n\tint ref_count;\n\n\tstruct clk *iss_fck;\n\tstruct clk *iss_ctrlclk;\n\n\t \n\tstruct iss_csi2_device csi2a;\n\tstruct iss_csi2_device csi2b;\n\tstruct iss_csiphy csiphy1;\n\tstruct iss_csiphy csiphy2;\n\tstruct iss_ipipeif_device ipipeif;\n\tstruct iss_ipipe_device ipipe;\n\tstruct iss_resizer_device resizer;\n\n\tunsigned int subclk_resources;\n\tunsigned int isp_subclk_resources;\n};\n\nint omap4iss_get_external_info(struct iss_pipeline *pipe,\n\t\t\t       struct media_link *link);\n\nint omap4iss_module_sync_idle(struct media_entity *me, wait_queue_head_t *wait,\n\t\t\t      atomic_t *stopping);\n\nint omap4iss_module_sync_is_stopping(wait_queue_head_t *wait,\n\t\t\t\t     atomic_t *stopping);\n\nint omap4iss_pipeline_set_stream(struct iss_pipeline *pipe,\n\t\t\t\t enum iss_pipeline_stream_state state);\nvoid omap4iss_pipeline_cancel_stream(struct iss_pipeline *pipe);\n\nvoid omap4iss_configure_bridge(struct iss_device *iss,\n\t\t\t       enum ipipeif_input_entity input);\n\nstruct iss_device *omap4iss_get(struct iss_device *iss);\nvoid omap4iss_put(struct iss_device *iss);\nint omap4iss_subclk_enable(struct iss_device *iss,\n\t\t\t   enum iss_subclk_resource res);\nint omap4iss_subclk_disable(struct iss_device *iss,\n\t\t\t    enum iss_subclk_resource res);\nvoid omap4iss_isp_subclk_enable(struct iss_device *iss,\n\t\t\t\tenum iss_isp_subclk_resource res);\nvoid omap4iss_isp_subclk_disable(struct iss_device *iss,\n\t\t\t\t enum iss_isp_subclk_resource res);\n\nint omap4iss_register_entities(struct platform_device *pdev,\n\t\t\t       struct v4l2_device *v4l2_dev);\nvoid omap4iss_unregister_entities(struct platform_device *pdev);\n\n \nstatic inline\nu32 iss_reg_read(struct iss_device *iss, enum iss_mem_resources res,\n\t\t u32 offset)\n{\n\treturn readl(iss->regs[res] + offset);\n}\n\n \nstatic inline\nvoid iss_reg_write(struct iss_device *iss, enum iss_mem_resources res,\n\t\t   u32 offset, u32 value)\n{\n\twritel(value, iss->regs[res] + offset);\n}\n\n \nstatic inline\nvoid iss_reg_clr(struct iss_device *iss, enum iss_mem_resources res,\n\t\t u32 offset, u32 clr)\n{\n\tu32 v = iss_reg_read(iss, res, offset);\n\n\tiss_reg_write(iss, res, offset, v & ~clr);\n}\n\n \nstatic inline\nvoid iss_reg_set(struct iss_device *iss, enum iss_mem_resources res,\n\t\t u32 offset, u32 set)\n{\n\tu32 v = iss_reg_read(iss, res, offset);\n\n\tiss_reg_write(iss, res, offset, v | set);\n}\n\n \nstatic inline\nvoid iss_reg_update(struct iss_device *iss, enum iss_mem_resources res,\n\t\t    u32 offset, u32 clr, u32 set)\n{\n\tu32 v = iss_reg_read(iss, res, offset);\n\n\tiss_reg_write(iss, res, offset, (v & ~clr) | set);\n}\n\n#define iss_poll_condition_timeout(cond, timeout, min_ival, max_ival)\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tunsigned long __timeout = jiffies + usecs_to_jiffies(timeout);\t\\\n\tunsigned int __min_ival = (min_ival);\t\t\t\t\\\n\tunsigned int __max_ival = (max_ival);\t\t\t\t\\\n\tbool __cond;\t\t\t\t\t\t\t\\\n\twhile (!(__cond = (cond))) {\t\t\t\t\t\\\n\t\tif (time_after(jiffies, __timeout))\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tusleep_range(__min_ival, __max_ival);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t!__cond;\t\t\t\t\t\t\t\\\n})\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}