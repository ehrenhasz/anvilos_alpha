{
  "module_name": "iss.c",
  "hash_id": "c67b06980ec816a858d36b5bd93a2703d4cce4f88f3c5c84ce486b324f6bac35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/omap4iss/iss.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n\n#include \"iss.h\"\n#include \"iss_regs.h\"\n\n#define ISS_PRINT_REGISTER(iss, name)\\\n\tdev_dbg(iss->dev, \"###ISS \" #name \"=0x%08x\\n\", \\\n\t\tiss_reg_read(iss, OMAP4_ISS_MEM_TOP, ISS_##name))\n\nstatic void iss_print_status(struct iss_device *iss)\n{\n\tdev_dbg(iss->dev, \"-------------ISS HL Register dump-------------\\n\");\n\n\tISS_PRINT_REGISTER(iss, HL_REVISION);\n\tISS_PRINT_REGISTER(iss, HL_SYSCONFIG);\n\tISS_PRINT_REGISTER(iss, HL_IRQSTATUS(5));\n\tISS_PRINT_REGISTER(iss, HL_IRQENABLE_SET(5));\n\tISS_PRINT_REGISTER(iss, HL_IRQENABLE_CLR(5));\n\tISS_PRINT_REGISTER(iss, CTRL);\n\tISS_PRINT_REGISTER(iss, CLKCTRL);\n\tISS_PRINT_REGISTER(iss, CLKSTAT);\n\n\tdev_dbg(iss->dev, \"-----------------------------------------------\\n\");\n}\n\n \nstatic void omap4iss_flush(struct iss_device *iss)\n{\n\tiss_reg_write(iss, OMAP4_ISS_MEM_TOP, ISS_HL_REVISION, 0);\n\tiss_reg_read(iss, OMAP4_ISS_MEM_TOP, ISS_HL_REVISION);\n}\n\n \nstatic void omap4iss_isp_enable_interrupts(struct iss_device *iss)\n{\n\tstatic const u32 isp_irq = ISP5_IRQ_OCP_ERR |\n\t\t\t\t   ISP5_IRQ_RSZ_FIFO_IN_BLK_ERR |\n\t\t\t\t   ISP5_IRQ_RSZ_FIFO_OVF |\n\t\t\t\t   ISP5_IRQ_RSZ_INT_DMA |\n\t\t\t\t   ISP5_IRQ_ISIF_INT(0);\n\n\t \n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_IRQSTATUS(0), isp_irq);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_IRQENABLE_SET(0),\n\t\t      isp_irq);\n}\n\n \nstatic void omap4iss_isp_disable_interrupts(struct iss_device *iss)\n{\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_IRQENABLE_CLR(0), ~0);\n}\n\n \nstatic void iss_enable_interrupts(struct iss_device *iss)\n{\n\tstatic const u32 hl_irq = ISS_HL_IRQ_CSIA | ISS_HL_IRQ_CSIB\n\t\t\t\t| ISS_HL_IRQ_ISP(0);\n\n\t \n\tiss_reg_write(iss, OMAP4_ISS_MEM_TOP, ISS_HL_IRQSTATUS(5), hl_irq);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_TOP, ISS_HL_IRQENABLE_SET(5), hl_irq);\n\n\tif (iss->regs[OMAP4_ISS_MEM_ISP_SYS1])\n\t\tomap4iss_isp_enable_interrupts(iss);\n}\n\n \nstatic void iss_disable_interrupts(struct iss_device *iss)\n{\n\tif (iss->regs[OMAP4_ISS_MEM_ISP_SYS1])\n\t\tomap4iss_isp_disable_interrupts(iss);\n\n\tiss_reg_write(iss, OMAP4_ISS_MEM_TOP, ISS_HL_IRQENABLE_CLR(5), ~0);\n}\n\nint omap4iss_get_external_info(struct iss_pipeline *pipe,\n\t\t\t       struct media_link *link)\n{\n\tstruct iss_device *iss =\n\t\tcontainer_of(pipe, struct iss_video, pipe)->iss;\n\tstruct v4l2_subdev_format fmt;\n\tstruct v4l2_ctrl *ctrl;\n\tint ret;\n\n\tif (!pipe->external)\n\t\treturn 0;\n\n\tif (pipe->external_rate)\n\t\treturn 0;\n\n\tmemset(&fmt, 0, sizeof(fmt));\n\n\tfmt.pad = link->source->index;\n\tfmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\n\tret = v4l2_subdev_call(media_entity_to_v4l2_subdev(link->sink->entity),\n\t\t\t       pad, get_fmt, NULL, &fmt);\n\tif (ret < 0)\n\t\treturn -EPIPE;\n\n\tpipe->external_bpp = omap4iss_video_format_info(fmt.format.code)->bpp;\n\n\tctrl = v4l2_ctrl_find(pipe->external->ctrl_handler,\n\t\t\t      V4L2_CID_PIXEL_RATE);\n\tif (!ctrl) {\n\t\tdev_warn(iss->dev, \"no pixel rate control in subdev %s\\n\",\n\t\t\t pipe->external->name);\n\t\treturn -EPIPE;\n\t}\n\n\tpipe->external_rate = v4l2_ctrl_g_ctrl_int64(ctrl);\n\n\treturn 0;\n}\n\n \nvoid omap4iss_configure_bridge(struct iss_device *iss,\n\t\t\t       enum ipipeif_input_entity input)\n{\n\tu32 issctrl_val;\n\tu32 isp5ctrl_val;\n\n\tissctrl_val = iss_reg_read(iss, OMAP4_ISS_MEM_TOP, ISS_CTRL);\n\tissctrl_val &= ~ISS_CTRL_INPUT_SEL_MASK;\n\tissctrl_val &= ~ISS_CTRL_CLK_DIV_MASK;\n\n\tisp5ctrl_val = iss_reg_read(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_CTRL);\n\n\tswitch (input) {\n\tcase IPIPEIF_INPUT_CSI2A:\n\t\tissctrl_val |= ISS_CTRL_INPUT_SEL_CSI2A;\n\t\tbreak;\n\n\tcase IPIPEIF_INPUT_CSI2B:\n\t\tissctrl_val |= ISS_CTRL_INPUT_SEL_CSI2B;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tissctrl_val |= ISS_CTRL_SYNC_DETECT_VS_RAISING;\n\n\tisp5ctrl_val |= ISP5_CTRL_VD_PULSE_EXT | ISP5_CTRL_PSYNC_CLK_SEL |\n\t\t\tISP5_CTRL_SYNC_ENABLE;\n\n\tiss_reg_write(iss, OMAP4_ISS_MEM_TOP, ISS_CTRL, issctrl_val);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_CTRL, isp5ctrl_val);\n}\n\n#ifdef ISS_ISR_DEBUG\nstatic void iss_isr_dbg(struct iss_device *iss, u32 irqstatus)\n{\n\tstatic const char * const name[] = {\n\t\t\"ISP_0\",\n\t\t\"ISP_1\",\n\t\t\"ISP_2\",\n\t\t\"ISP_3\",\n\t\t\"CSIA\",\n\t\t\"CSIB\",\n\t\t\"CCP2_0\",\n\t\t\"CCP2_1\",\n\t\t\"CCP2_2\",\n\t\t\"CCP2_3\",\n\t\t\"CBUFF\",\n\t\t\"BTE\",\n\t\t\"SIMCOP_0\",\n\t\t\"SIMCOP_1\",\n\t\t\"SIMCOP_2\",\n\t\t\"SIMCOP_3\",\n\t\t\"CCP2_8\",\n\t\t\"HS_VS\",\n\t\t\"18\",\n\t\t\"19\",\n\t\t\"20\",\n\t\t\"21\",\n\t\t\"22\",\n\t\t\"23\",\n\t\t\"24\",\n\t\t\"25\",\n\t\t\"26\",\n\t\t\"27\",\n\t\t\"28\",\n\t\t\"29\",\n\t\t\"30\",\n\t\t\"31\",\n\t};\n\tunsigned int i;\n\n\tdev_dbg(iss->dev, \"ISS IRQ: \");\n\n\tfor (i = 0; i < ARRAY_SIZE(name); i++) {\n\t\tif ((1 << i) & irqstatus)\n\t\t\tpr_cont(\"%s \", name[i]);\n\t}\n\tpr_cont(\"\\n\");\n}\n\nstatic void iss_isp_isr_dbg(struct iss_device *iss, u32 irqstatus)\n{\n\tstatic const char * const name[] = {\n\t\t\"ISIF_0\",\n\t\t\"ISIF_1\",\n\t\t\"ISIF_2\",\n\t\t\"ISIF_3\",\n\t\t\"IPIPEREQ\",\n\t\t\"IPIPELAST_PIX\",\n\t\t\"IPIPEDMA\",\n\t\t\"IPIPEBSC\",\n\t\t\"IPIPEHST\",\n\t\t\"IPIPEIF\",\n\t\t\"AEW\",\n\t\t\"AF\",\n\t\t\"H3A\",\n\t\t\"RSZ_REG\",\n\t\t\"RSZ_LAST_PIX\",\n\t\t\"RSZ_DMA\",\n\t\t\"RSZ_CYC_RZA\",\n\t\t\"RSZ_CYC_RZB\",\n\t\t\"RSZ_FIFO_OVF\",\n\t\t\"RSZ_FIFO_IN_BLK_ERR\",\n\t\t\"20\",\n\t\t\"21\",\n\t\t\"RSZ_EOF0\",\n\t\t\"RSZ_EOF1\",\n\t\t\"H3A_EOF\",\n\t\t\"IPIPE_EOF\",\n\t\t\"26\",\n\t\t\"IPIPE_DPC_INI\",\n\t\t\"IPIPE_DPC_RNEW0\",\n\t\t\"IPIPE_DPC_RNEW1\",\n\t\t\"30\",\n\t\t\"OCP_ERR\",\n\t};\n\tunsigned int i;\n\n\tdev_dbg(iss->dev, \"ISP IRQ: \");\n\n\tfor (i = 0; i < ARRAY_SIZE(name); i++) {\n\t\tif ((1 << i) & irqstatus)\n\t\t\tpr_cont(\"%s \", name[i]);\n\t}\n\tpr_cont(\"\\n\");\n}\n#endif\n\n \nstatic irqreturn_t iss_isr(int irq, void *_iss)\n{\n\tstatic const u32 ipipeif_events = ISP5_IRQ_IPIPEIF_IRQ |\n\t\t\t\t\t  ISP5_IRQ_ISIF_INT(0);\n\tstatic const u32 resizer_events = ISP5_IRQ_RSZ_FIFO_IN_BLK_ERR |\n\t\t\t\t\t  ISP5_IRQ_RSZ_FIFO_OVF |\n\t\t\t\t\t  ISP5_IRQ_RSZ_INT_DMA;\n\tstruct iss_device *iss = _iss;\n\tu32 irqstatus;\n\n\tirqstatus = iss_reg_read(iss, OMAP4_ISS_MEM_TOP, ISS_HL_IRQSTATUS(5));\n\tiss_reg_write(iss, OMAP4_ISS_MEM_TOP, ISS_HL_IRQSTATUS(5), irqstatus);\n\n\tif (irqstatus & ISS_HL_IRQ_CSIA)\n\t\tomap4iss_csi2_isr(&iss->csi2a);\n\n\tif (irqstatus & ISS_HL_IRQ_CSIB)\n\t\tomap4iss_csi2_isr(&iss->csi2b);\n\n\tif (irqstatus & ISS_HL_IRQ_ISP(0)) {\n\t\tu32 isp_irqstatus = iss_reg_read(iss, OMAP4_ISS_MEM_ISP_SYS1,\n\t\t\t\t\t\t ISP5_IRQSTATUS(0));\n\t\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_IRQSTATUS(0),\n\t\t\t      isp_irqstatus);\n\n\t\tif (isp_irqstatus & ISP5_IRQ_OCP_ERR)\n\t\t\tdev_dbg(iss->dev, \"ISP5 OCP Error!\\n\");\n\n\t\tif (isp_irqstatus & ipipeif_events) {\n\t\t\tomap4iss_ipipeif_isr(&iss->ipipeif,\n\t\t\t\t\t     isp_irqstatus & ipipeif_events);\n\t\t}\n\n\t\tif (isp_irqstatus & resizer_events)\n\t\t\tomap4iss_resizer_isr(&iss->resizer,\n\t\t\t\t\t     isp_irqstatus & resizer_events);\n\n#ifdef ISS_ISR_DEBUG\n\t\tiss_isp_isr_dbg(iss, isp_irqstatus);\n#endif\n\t}\n\n\tomap4iss_flush(iss);\n\n#ifdef ISS_ISR_DEBUG\n\tiss_isr_dbg(iss, irqstatus);\n#endif\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct media_device_ops iss_media_ops = {\n\t.link_notify = v4l2_pipeline_link_notify,\n};\n\n \n\n \nstatic int iss_pipeline_disable(struct iss_pipeline *pipe,\n\t\t\t\tstruct media_entity *until)\n{\n\tstruct iss_device *iss = pipe->output->iss;\n\tstruct media_entity *entity;\n\tstruct media_pad *pad;\n\tstruct v4l2_subdev *subdev;\n\tint failure = 0;\n\tint ret;\n\n\tentity = &pipe->output->video.entity;\n\twhile (1) {\n\t\tpad = &entity->pads[0];\n\t\tif (!(pad->flags & MEDIA_PAD_FL_SINK))\n\t\t\tbreak;\n\n\t\tpad = media_pad_remote_pad_first(pad);\n\t\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\t\tbreak;\n\n\t\tentity = pad->entity;\n\t\tif (entity == until)\n\t\t\tbreak;\n\n\t\tsubdev = media_entity_to_v4l2_subdev(entity);\n\t\tret = v4l2_subdev_call(subdev, video, s_stream, 0);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(iss->dev, \"%s: module stop timeout.\\n\",\n\t\t\t\t subdev->name);\n\t\t\t \n\t\t\tmedia_entity_enum_set(&iss->crashed, &subdev->entity);\n\t\t\tfailure = -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn failure;\n}\n\n \nstatic int iss_pipeline_enable(struct iss_pipeline *pipe,\n\t\t\t       enum iss_pipeline_stream_state mode)\n{\n\tstruct iss_device *iss = pipe->output->iss;\n\tstruct media_entity *entity;\n\tstruct media_pad *pad;\n\tstruct v4l2_subdev *subdev;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tif (media_entity_enum_intersects(&pipe->ent_enum, &iss->crashed))\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&pipe->lock, flags);\n\tpipe->state &= ~(ISS_PIPELINE_IDLE_INPUT | ISS_PIPELINE_IDLE_OUTPUT);\n\tspin_unlock_irqrestore(&pipe->lock, flags);\n\n\tpipe->do_propagation = false;\n\n\tmutex_lock(&iss->media_dev.graph_mutex);\n\n\tentity = &pipe->output->video.entity;\n\twhile (1) {\n\t\tpad = &entity->pads[0];\n\t\tif (!(pad->flags & MEDIA_PAD_FL_SINK))\n\t\t\tbreak;\n\n\t\tpad = media_pad_remote_pad_first(pad);\n\t\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\t\tbreak;\n\n\t\tentity = pad->entity;\n\t\tsubdev = media_entity_to_v4l2_subdev(entity);\n\n\t\tret = v4l2_subdev_call(subdev, video, s_stream, mode);\n\t\tif (ret < 0 && ret != -ENOIOCTLCMD) {\n\t\t\tiss_pipeline_disable(pipe, entity);\n\t\t\tmutex_unlock(&iss->media_dev.graph_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (subdev == &iss->csi2a.subdev ||\n\t\t    subdev == &iss->csi2b.subdev)\n\t\t\tpipe->do_propagation = true;\n\t}\n\n\tmutex_unlock(&iss->media_dev.graph_mutex);\n\tiss_print_status(pipe->output->iss);\n\n\treturn 0;\n}\n\n \nint omap4iss_pipeline_set_stream(struct iss_pipeline *pipe,\n\t\t\t\t enum iss_pipeline_stream_state state)\n{\n\tint ret;\n\n\tif (state == ISS_PIPELINE_STREAM_STOPPED)\n\t\tret = iss_pipeline_disable(pipe, NULL);\n\telse\n\t\tret = iss_pipeline_enable(pipe, state);\n\n\tif (ret == 0 || state == ISS_PIPELINE_STREAM_STOPPED)\n\t\tpipe->stream_state = state;\n\n\treturn ret;\n}\n\n \nvoid omap4iss_pipeline_cancel_stream(struct iss_pipeline *pipe)\n{\n\tif (pipe->input)\n\t\tomap4iss_video_cancel_stream(pipe->input);\n\tif (pipe->output)\n\t\tomap4iss_video_cancel_stream(pipe->output);\n}\n\n \nstatic int iss_pipeline_is_last(struct media_entity *me)\n{\n\tstruct iss_pipeline *pipe;\n\tstruct media_pad *pad;\n\n\tpipe = to_iss_pipeline(me);\n\tif (!pipe || pipe->stream_state == ISS_PIPELINE_STREAM_STOPPED)\n\t\treturn 0;\n\tpad = media_pad_remote_pad_first(&pipe->output->pad);\n\treturn pad->entity == me;\n}\n\nstatic int iss_reset(struct iss_device *iss)\n{\n\tunsigned int timeout;\n\n\tiss_reg_set(iss, OMAP4_ISS_MEM_TOP, ISS_HL_SYSCONFIG,\n\t\t    ISS_HL_SYSCONFIG_SOFTRESET);\n\n\ttimeout = iss_poll_condition_timeout(\n\t\t!(iss_reg_read(iss, OMAP4_ISS_MEM_TOP, ISS_HL_SYSCONFIG) &\n\t\tISS_HL_SYSCONFIG_SOFTRESET), 1000, 10, 100);\n\tif (timeout) {\n\t\tdev_err(iss->dev, \"ISS reset timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tmedia_entity_enum_zero(&iss->crashed);\n\n\treturn 0;\n}\n\nstatic int iss_isp_reset(struct iss_device *iss)\n{\n\tunsigned int timeout;\n\n\t \n\tiss_reg_update(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_SYSCONFIG,\n\t\t       ISP5_SYSCONFIG_STANDBYMODE_MASK,\n\t\t       ISP5_SYSCONFIG_STANDBYMODE_SMART);\n\n\tiss_reg_set(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_CTRL, ISP5_CTRL_MSTANDBY);\n\n\ttimeout = iss_poll_condition_timeout(\n\t\tiss_reg_read(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_CTRL) &\n\t\tISP5_CTRL_MSTANDBY_WAIT, 1000000, 1000, 1500);\n\tif (timeout) {\n\t\tdev_err(iss->dev, \"ISP5 standby timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tiss_reg_set(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_SYSCONFIG,\n\t\t    ISP5_SYSCONFIG_SOFTRESET);\n\n\ttimeout = iss_poll_condition_timeout(\n\t\t!(iss_reg_read(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_SYSCONFIG) &\n\t\tISP5_SYSCONFIG_SOFTRESET), 1000000, 1000, 1500);\n\tif (timeout) {\n\t\tdev_err(iss->dev, \"ISP5 reset timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n \nint omap4iss_module_sync_idle(struct media_entity *me, wait_queue_head_t *wait,\n\t\t\t      atomic_t *stopping)\n{\n\tstruct iss_pipeline *pipe = to_iss_pipeline(me);\n\tstruct iss_video *video = pipe->output;\n\tunsigned long flags;\n\n\tif (pipe->stream_state == ISS_PIPELINE_STREAM_STOPPED ||\n\t    (pipe->stream_state == ISS_PIPELINE_STREAM_SINGLESHOT &&\n\t     !iss_pipeline_ready(pipe)))\n\t\treturn 0;\n\n\t \n\tatomic_set(stopping, 1);\n\tsmp_wmb();\n\n\t \n\tif (!iss_pipeline_is_last(me))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&video->qlock, flags);\n\tif (video->dmaqueue_flags & ISS_VIDEO_DMAQUEUE_UNDERRUN) {\n\t\tspin_unlock_irqrestore(&video->qlock, flags);\n\t\tatomic_set(stopping, 0);\n\t\tsmp_wmb();\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&video->qlock, flags);\n\tif (!wait_event_timeout(*wait, !atomic_read(stopping),\n\t\t\t\tmsecs_to_jiffies(1000))) {\n\t\tatomic_set(stopping, 0);\n\t\tsmp_wmb();\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n \nint omap4iss_module_sync_is_stopping(wait_queue_head_t *wait,\n\t\t\t\t     atomic_t *stopping)\n{\n\tif (atomic_cmpxchg(stopping, 1, 0)) {\n\t\twake_up(wait);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \n\n#define ISS_CLKCTRL_MASK\t(ISS_CLKCTRL_CSI2_A |\\\n\t\t\t\t ISS_CLKCTRL_CSI2_B |\\\n\t\t\t\t ISS_CLKCTRL_ISP)\n\nstatic int __iss_subclk_update(struct iss_device *iss)\n{\n\tu32 clk = 0;\n\tint ret = 0, timeout = 1000;\n\n\tif (iss->subclk_resources & OMAP4_ISS_SUBCLK_CSI2_A)\n\t\tclk |= ISS_CLKCTRL_CSI2_A;\n\n\tif (iss->subclk_resources & OMAP4_ISS_SUBCLK_CSI2_B)\n\t\tclk |= ISS_CLKCTRL_CSI2_B;\n\n\tif (iss->subclk_resources & OMAP4_ISS_SUBCLK_ISP)\n\t\tclk |= ISS_CLKCTRL_ISP;\n\n\tiss_reg_update(iss, OMAP4_ISS_MEM_TOP, ISS_CLKCTRL,\n\t\t       ISS_CLKCTRL_MASK, clk);\n\n\t \n\twhile (--timeout > 0) {\n\t\tudelay(1);\n\t\tif ((iss_reg_read(iss, OMAP4_ISS_MEM_TOP, ISS_CLKSTAT) &\n\t\t    ISS_CLKCTRL_MASK) == clk)\n\t\t\tbreak;\n\t}\n\n\tif (!timeout)\n\t\tret = -EBUSY;\n\n\treturn ret;\n}\n\nint omap4iss_subclk_enable(struct iss_device *iss,\n\t\t\t   enum iss_subclk_resource res)\n{\n\tiss->subclk_resources |= res;\n\n\treturn __iss_subclk_update(iss);\n}\n\nint omap4iss_subclk_disable(struct iss_device *iss,\n\t\t\t    enum iss_subclk_resource res)\n{\n\tiss->subclk_resources &= ~res;\n\n\treturn __iss_subclk_update(iss);\n}\n\n#define ISS_ISP5_CLKCTRL_MASK\t(ISP5_CTRL_BL_CLK_ENABLE |\\\n\t\t\t\t ISP5_CTRL_ISIF_CLK_ENABLE |\\\n\t\t\t\t ISP5_CTRL_H3A_CLK_ENABLE |\\\n\t\t\t\t ISP5_CTRL_RSZ_CLK_ENABLE |\\\n\t\t\t\t ISP5_CTRL_IPIPE_CLK_ENABLE |\\\n\t\t\t\t ISP5_CTRL_IPIPEIF_CLK_ENABLE)\n\nstatic void __iss_isp_subclk_update(struct iss_device *iss)\n{\n\tu32 clk = 0;\n\n\tif (iss->isp_subclk_resources & OMAP4_ISS_ISP_SUBCLK_ISIF)\n\t\tclk |= ISP5_CTRL_ISIF_CLK_ENABLE;\n\n\tif (iss->isp_subclk_resources & OMAP4_ISS_ISP_SUBCLK_H3A)\n\t\tclk |= ISP5_CTRL_H3A_CLK_ENABLE;\n\n\tif (iss->isp_subclk_resources & OMAP4_ISS_ISP_SUBCLK_RSZ)\n\t\tclk |= ISP5_CTRL_RSZ_CLK_ENABLE;\n\n\tif (iss->isp_subclk_resources & OMAP4_ISS_ISP_SUBCLK_IPIPE)\n\t\tclk |= ISP5_CTRL_IPIPE_CLK_ENABLE;\n\n\tif (iss->isp_subclk_resources & OMAP4_ISS_ISP_SUBCLK_IPIPEIF)\n\t\tclk |= ISP5_CTRL_IPIPEIF_CLK_ENABLE;\n\n\tif (clk)\n\t\tclk |= ISP5_CTRL_BL_CLK_ENABLE;\n\n\tiss_reg_update(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_CTRL,\n\t\t       ISS_ISP5_CLKCTRL_MASK, clk);\n}\n\nvoid omap4iss_isp_subclk_enable(struct iss_device *iss,\n\t\t\t\tenum iss_isp_subclk_resource res)\n{\n\tiss->isp_subclk_resources |= res;\n\n\t__iss_isp_subclk_update(iss);\n}\n\nvoid omap4iss_isp_subclk_disable(struct iss_device *iss,\n\t\t\t\t enum iss_isp_subclk_resource res)\n{\n\tiss->isp_subclk_resources &= ~res;\n\n\t__iss_isp_subclk_update(iss);\n}\n\n \nstatic int iss_enable_clocks(struct iss_device *iss)\n{\n\tint ret;\n\n\tret = clk_enable(iss->iss_fck);\n\tif (ret) {\n\t\tdev_err(iss->dev, \"clk_enable iss_fck failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_enable(iss->iss_ctrlclk);\n\tif (ret) {\n\t\tdev_err(iss->dev, \"clk_enable iss_ctrlclk failed\\n\");\n\t\tclk_disable(iss->iss_fck);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void iss_disable_clocks(struct iss_device *iss)\n{\n\tclk_disable(iss->iss_ctrlclk);\n\tclk_disable(iss->iss_fck);\n}\n\nstatic int iss_get_clocks(struct iss_device *iss)\n{\n\tiss->iss_fck = devm_clk_get(iss->dev, \"iss_fck\");\n\tif (IS_ERR(iss->iss_fck)) {\n\t\tdev_err(iss->dev, \"Unable to get iss_fck clock info\\n\");\n\t\treturn PTR_ERR(iss->iss_fck);\n\t}\n\n\tiss->iss_ctrlclk = devm_clk_get(iss->dev, \"iss_ctrlclk\");\n\tif (IS_ERR(iss->iss_ctrlclk)) {\n\t\tdev_err(iss->dev, \"Unable to get iss_ctrlclk clock info\\n\");\n\t\treturn PTR_ERR(iss->iss_ctrlclk);\n\t}\n\n\treturn 0;\n}\n\n \nstruct iss_device *omap4iss_get(struct iss_device *iss)\n{\n\tstruct iss_device *__iss = iss;\n\n\tif (!iss)\n\t\treturn NULL;\n\n\tmutex_lock(&iss->iss_mutex);\n\tif (iss->ref_count > 0)\n\t\tgoto out;\n\n\tif (iss_enable_clocks(iss) < 0) {\n\t\t__iss = NULL;\n\t\tgoto out;\n\t}\n\n\tiss_enable_interrupts(iss);\n\nout:\n\tif (__iss)\n\t\tiss->ref_count++;\n\tmutex_unlock(&iss->iss_mutex);\n\n\treturn __iss;\n}\n\n \nvoid omap4iss_put(struct iss_device *iss)\n{\n\tif (!iss)\n\t\treturn;\n\n\tmutex_lock(&iss->iss_mutex);\n\tWARN_ON(iss->ref_count == 0);\n\tif (--iss->ref_count == 0) {\n\t\tiss_disable_interrupts(iss);\n\t\t \n\t\tif (!media_entity_enum_empty(&iss->crashed))\n\t\t\tiss_reset(iss);\n\t\tiss_disable_clocks(iss);\n\t}\n\tmutex_unlock(&iss->iss_mutex);\n}\n\nstatic int iss_map_mem_resource(struct platform_device *pdev,\n\t\t\t\tstruct iss_device *iss,\n\t\t\t\tenum iss_mem_resources res)\n{\n\tiss->regs[res] = devm_platform_ioremap_resource(pdev, res);\n\n\treturn PTR_ERR_OR_ZERO(iss->regs[res]);\n}\n\nstatic void iss_unregister_entities(struct iss_device *iss)\n{\n\tomap4iss_resizer_unregister_entities(&iss->resizer);\n\tomap4iss_ipipe_unregister_entities(&iss->ipipe);\n\tomap4iss_ipipeif_unregister_entities(&iss->ipipeif);\n\tomap4iss_csi2_unregister_entities(&iss->csi2a);\n\tomap4iss_csi2_unregister_entities(&iss->csi2b);\n\n\tv4l2_device_unregister(&iss->v4l2_dev);\n\tmedia_device_unregister(&iss->media_dev);\n}\n\n \nstatic struct v4l2_subdev *\niss_register_subdev_group(struct iss_device *iss,\n\t\t\t  struct iss_subdev_i2c_board_info *board_info)\n{\n\tstruct v4l2_subdev *sensor = NULL;\n\tunsigned int first;\n\n\tif (!board_info->board_info)\n\t\treturn NULL;\n\n\tfor (first = 1; board_info->board_info; ++board_info, first = 0) {\n\t\tstruct v4l2_subdev *subdev;\n\t\tstruct i2c_adapter *adapter;\n\n\t\tadapter = i2c_get_adapter(board_info->i2c_adapter_id);\n\t\tif (!adapter) {\n\t\t\tdev_err(iss->dev,\n\t\t\t\t\"%s: Unable to get I2C adapter %d for device %s\\n\",\n\t\t\t\t__func__, board_info->i2c_adapter_id,\n\t\t\t\tboard_info->board_info->type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsubdev = v4l2_i2c_new_subdev_board(&iss->v4l2_dev, adapter,\n\t\t\t\t\t\t   board_info->board_info, NULL);\n\t\tif (!subdev) {\n\t\t\tdev_err(iss->dev, \"Unable to register subdev %s\\n\",\n\t\t\t\tboard_info->board_info->type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (first)\n\t\t\tsensor = subdev;\n\t}\n\n\treturn sensor;\n}\n\nstatic int iss_register_entities(struct iss_device *iss)\n{\n\tstruct iss_platform_data *pdata = iss->pdata;\n\tstruct iss_v4l2_subdevs_group *subdevs;\n\tint ret;\n\n\tiss->media_dev.dev = iss->dev;\n\tstrscpy(iss->media_dev.model, \"TI OMAP4 ISS\",\n\t\tsizeof(iss->media_dev.model));\n\tiss->media_dev.hw_revision = iss->revision;\n\tiss->media_dev.ops = &iss_media_ops;\n\tret = media_device_register(&iss->media_dev);\n\tif (ret < 0) {\n\t\tdev_err(iss->dev, \"Media device registration failed (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tiss->v4l2_dev.mdev = &iss->media_dev;\n\tret = v4l2_device_register(iss->dev, &iss->v4l2_dev);\n\tif (ret < 0) {\n\t\tdev_err(iss->dev, \"V4L2 device registration failed (%d)\\n\",\n\t\t\tret);\n\t\tgoto done;\n\t}\n\n\t \n\tret = omap4iss_csi2_register_entities(&iss->csi2a, &iss->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = omap4iss_csi2_register_entities(&iss->csi2b, &iss->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = omap4iss_ipipeif_register_entities(&iss->ipipeif, &iss->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = omap4iss_ipipe_register_entities(&iss->ipipe, &iss->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = omap4iss_resizer_register_entities(&iss->resizer, &iss->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t \n\tfor (subdevs = pdata->subdevs; subdevs && subdevs->subdevs; ++subdevs) {\n\t\tstruct v4l2_subdev *sensor;\n\t\tstruct media_entity *input;\n\t\tunsigned int flags;\n\t\tunsigned int pad;\n\n\t\tsensor = iss_register_subdev_group(iss, subdevs->subdevs);\n\t\tif (!sensor)\n\t\t\tcontinue;\n\n\t\tsensor->host_priv = subdevs;\n\n\t\t \n\t\tswitch (subdevs->interface) {\n\t\tcase ISS_INTERFACE_CSI2A_PHY1:\n\t\t\tinput = &iss->csi2a.subdev.entity;\n\t\t\tpad = CSI2_PAD_SINK;\n\t\t\tflags = MEDIA_LNK_FL_IMMUTABLE\n\t\t\t      | MEDIA_LNK_FL_ENABLED;\n\t\t\tbreak;\n\n\t\tcase ISS_INTERFACE_CSI2B_PHY2:\n\t\t\tinput = &iss->csi2b.subdev.entity;\n\t\t\tpad = CSI2_PAD_SINK;\n\t\t\tflags = MEDIA_LNK_FL_IMMUTABLE\n\t\t\t      | MEDIA_LNK_FL_ENABLED;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(iss->dev, \"invalid interface type %u\\n\",\n\t\t\t\tsubdevs->interface);\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = media_create_pad_link(&sensor->entity, 0, input, pad,\n\t\t\t\t\t    flags);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tret = v4l2_device_register_subdev_nodes(&iss->v4l2_dev);\n\ndone:\n\tif (ret < 0)\n\t\tiss_unregister_entities(iss);\n\n\treturn ret;\n}\n\n \nstatic int iss_create_links(struct iss_device *iss)\n{\n\tint ret;\n\n\tret = omap4iss_csi2_create_links(iss);\n\tif (ret < 0) {\n\t\tdev_err(iss->dev, \"CSI2 pads links creation failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = omap4iss_ipipeif_create_links(iss);\n\tif (ret < 0) {\n\t\tdev_err(iss->dev, \"ISP IPIPEIF pads links creation failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = omap4iss_resizer_create_links(iss);\n\tif (ret < 0) {\n\t\tdev_err(iss->dev, \"ISP RESIZER pads links creation failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = media_create_pad_link(\n\t\t\t&iss->csi2a.subdev.entity, CSI2_PAD_SOURCE,\n\t\t\t&iss->ipipeif.subdev.entity, IPIPEIF_PAD_SINK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&iss->csi2b.subdev.entity, CSI2_PAD_SOURCE,\n\t\t\t&iss->ipipeif.subdev.entity, IPIPEIF_PAD_SINK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&iss->ipipeif.subdev.entity, IPIPEIF_PAD_SOURCE_VP,\n\t\t\t&iss->resizer.subdev.entity, RESIZER_PAD_SINK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&iss->ipipeif.subdev.entity, IPIPEIF_PAD_SOURCE_VP,\n\t\t\t&iss->ipipe.subdev.entity, IPIPE_PAD_SINK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&iss->ipipe.subdev.entity, IPIPE_PAD_SOURCE_VP,\n\t\t\t&iss->resizer.subdev.entity, RESIZER_PAD_SINK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n};\n\nstatic void iss_cleanup_modules(struct iss_device *iss)\n{\n\tomap4iss_csi2_cleanup(iss);\n\tomap4iss_ipipeif_cleanup(iss);\n\tomap4iss_ipipe_cleanup(iss);\n\tomap4iss_resizer_cleanup(iss);\n}\n\nstatic int iss_initialize_modules(struct iss_device *iss)\n{\n\tint ret;\n\n\tret = omap4iss_csiphy_init(iss);\n\tif (ret < 0) {\n\t\tdev_err(iss->dev, \"CSI PHY initialization failed\\n\");\n\t\tgoto error_csiphy;\n\t}\n\n\tret = omap4iss_csi2_init(iss);\n\tif (ret < 0) {\n\t\tdev_err(iss->dev, \"CSI2 initialization failed\\n\");\n\t\tgoto error_csi2;\n\t}\n\n\tret = omap4iss_ipipeif_init(iss);\n\tif (ret < 0) {\n\t\tdev_err(iss->dev, \"ISP IPIPEIF initialization failed\\n\");\n\t\tgoto error_ipipeif;\n\t}\n\n\tret = omap4iss_ipipe_init(iss);\n\tif (ret < 0) {\n\t\tdev_err(iss->dev, \"ISP IPIPE initialization failed\\n\");\n\t\tgoto error_ipipe;\n\t}\n\n\tret = omap4iss_resizer_init(iss);\n\tif (ret < 0) {\n\t\tdev_err(iss->dev, \"ISP RESIZER initialization failed\\n\");\n\t\tgoto error_resizer;\n\t}\n\n\treturn 0;\n\nerror_resizer:\n\tomap4iss_ipipe_cleanup(iss);\nerror_ipipe:\n\tomap4iss_ipipeif_cleanup(iss);\nerror_ipipeif:\n\tomap4iss_csi2_cleanup(iss);\nerror_csi2:\nerror_csiphy:\n\treturn ret;\n}\n\nstatic int iss_probe(struct platform_device *pdev)\n{\n\tstruct iss_platform_data *pdata = pdev->dev.platform_data;\n\tstruct iss_device *iss;\n\tunsigned int i;\n\tint ret;\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tiss = devm_kzalloc(&pdev->dev, sizeof(*iss), GFP_KERNEL);\n\tif (!iss)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&iss->iss_mutex);\n\n\tiss->dev = &pdev->dev;\n\tiss->pdata = pdata;\n\n\tiss->raw_dmamask = DMA_BIT_MASK(32);\n\tiss->dev->dma_mask = &iss->raw_dmamask;\n\tiss->dev->coherent_dma_mask = DMA_BIT_MASK(32);\n\n\tplatform_set_drvdata(pdev, iss);\n\n\t \n\tiss->syscon = syscon_regmap_lookup_by_compatible(\"syscon\");\n\tif (IS_ERR(iss->syscon)) {\n\t\tret = PTR_ERR(iss->syscon);\n\t\tgoto error;\n\t}\n\n\t \n\tret = iss_map_mem_resource(pdev, iss, OMAP4_ISS_MEM_TOP);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = iss_get_clocks(iss);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (!omap4iss_get(iss)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tret = iss_reset(iss);\n\tif (ret < 0)\n\t\tgoto error_iss;\n\n\tiss->revision = iss_reg_read(iss, OMAP4_ISS_MEM_TOP, ISS_HL_REVISION);\n\tdev_info(iss->dev, \"Revision %08x found\\n\", iss->revision);\n\n\tfor (i = 1; i < OMAP4_ISS_MEM_LAST; i++) {\n\t\tret = iss_map_mem_resource(pdev, iss, i);\n\t\tif (ret)\n\t\t\tgoto error_iss;\n\t}\n\n\t \n\tiss_reg_update(iss, OMAP4_ISS_MEM_BTE, BTE_CTRL,\n\t\t       BTE_CTRL_BW_LIMITER_MASK,\n\t\t       18 << BTE_CTRL_BW_LIMITER_SHIFT);\n\n\t \n\tret = omap4iss_subclk_enable(iss, OMAP4_ISS_SUBCLK_ISP);\n\tif (ret < 0)\n\t\tgoto error_iss;\n\n\tret = iss_isp_reset(iss);\n\tif (ret < 0)\n\t\tgoto error_iss;\n\n\tdev_info(iss->dev, \"ISP Revision %08x found\\n\",\n\t\t iss_reg_read(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_REVISION));\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret <= 0) {\n\t\tret = -ENODEV;\n\t\tgoto error_iss;\n\t}\n\tiss->irq_num = ret;\n\n\tif (devm_request_irq(iss->dev, iss->irq_num, iss_isr, IRQF_SHARED,\n\t\t\t     \"OMAP4 ISS\", iss)) {\n\t\tdev_err(iss->dev, \"Unable to request IRQ\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_iss;\n\t}\n\n\t \n\tret = iss_initialize_modules(iss);\n\tif (ret < 0)\n\t\tgoto error_iss;\n\n\tret = iss_register_entities(iss);\n\tif (ret < 0)\n\t\tgoto error_modules;\n\n\tret = media_entity_enum_init(&iss->crashed, &iss->media_dev);\n\tif (ret)\n\t\tgoto error_entities;\n\n\tret = iss_create_links(iss);\n\tif (ret < 0)\n\t\tgoto error_entities;\n\n\tomap4iss_put(iss);\n\n\treturn 0;\n\nerror_entities:\n\tiss_unregister_entities(iss);\n\tmedia_entity_enum_cleanup(&iss->crashed);\nerror_modules:\n\tiss_cleanup_modules(iss);\nerror_iss:\n\tomap4iss_put(iss);\nerror:\n\tmutex_destroy(&iss->iss_mutex);\n\n\treturn ret;\n}\n\nstatic void iss_remove(struct platform_device *pdev)\n{\n\tstruct iss_device *iss = platform_get_drvdata(pdev);\n\n\tiss_unregister_entities(iss);\n\tmedia_entity_enum_cleanup(&iss->crashed);\n\tiss_cleanup_modules(iss);\n}\n\nstatic const struct platform_device_id omap4iss_id_table[] = {\n\t{ \"omap4iss\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, omap4iss_id_table);\n\nstatic struct platform_driver iss_driver = {\n\t.probe\t\t= iss_probe,\n\t.remove_new\t= iss_remove,\n\t.id_table\t= omap4iss_id_table,\n\t.driver = {\n\t\t.name\t= \"omap4iss\",\n\t},\n};\n\nmodule_platform_driver(iss_driver);\n\nMODULE_DESCRIPTION(\"TI OMAP4 ISS driver\");\nMODULE_AUTHOR(\"Sergio Aguirre <sergio.a.aguirre@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}