{
  "module_name": "iss_ipipeif.c",
  "hash_id": "b6813b341e49c98750587237ee270a5e3a164b7499e18c557cbec532a8489c2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/omap4iss/iss_ipipeif.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#include \"iss.h\"\n#include \"iss_regs.h\"\n#include \"iss_ipipeif.h\"\n\nstatic const unsigned int ipipeif_fmts[] = {\n\tMEDIA_BUS_FMT_SGRBG10_1X10,\n\tMEDIA_BUS_FMT_SRGGB10_1X10,\n\tMEDIA_BUS_FMT_SBGGR10_1X10,\n\tMEDIA_BUS_FMT_SGBRG10_1X10,\n\tMEDIA_BUS_FMT_UYVY8_1X16,\n\tMEDIA_BUS_FMT_YUYV8_1X16,\n};\n\n \n#define IPIPEIF_PRINT_REGISTER(iss, name)\\\n\tdev_dbg(iss->dev, \"###IPIPEIF \" #name \"=0x%08x\\n\", \\\n\t\tiss_reg_read(iss, OMAP4_ISS_MEM_ISP_IPIPEIF, IPIPEIF_##name))\n\n#define ISIF_PRINT_REGISTER(iss, name)\\\n\tdev_dbg(iss->dev, \"###ISIF \" #name \"=0x%08x\\n\", \\\n\t\tiss_reg_read(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_##name))\n\n#define ISP5_PRINT_REGISTER(iss, name)\\\n\tdev_dbg(iss->dev, \"###ISP5 \" #name \"=0x%08x\\n\", \\\n\t\tiss_reg_read(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_##name))\n\nstatic void ipipeif_print_status(struct iss_ipipeif_device *ipipeif)\n{\n\tstruct iss_device *iss = to_iss_device(ipipeif);\n\n\tdev_dbg(iss->dev, \"-------------IPIPEIF Register dump-------------\\n\");\n\n\tIPIPEIF_PRINT_REGISTER(iss, CFG1);\n\tIPIPEIF_PRINT_REGISTER(iss, CFG2);\n\n\tISIF_PRINT_REGISTER(iss, SYNCEN);\n\tISIF_PRINT_REGISTER(iss, CADU);\n\tISIF_PRINT_REGISTER(iss, CADL);\n\tISIF_PRINT_REGISTER(iss, MODESET);\n\tISIF_PRINT_REGISTER(iss, CCOLP);\n\tISIF_PRINT_REGISTER(iss, SPH);\n\tISIF_PRINT_REGISTER(iss, LNH);\n\tISIF_PRINT_REGISTER(iss, LNV);\n\tISIF_PRINT_REGISTER(iss, VDINT(0));\n\tISIF_PRINT_REGISTER(iss, HSIZE);\n\n\tISP5_PRINT_REGISTER(iss, SYSCONFIG);\n\tISP5_PRINT_REGISTER(iss, CTRL);\n\tISP5_PRINT_REGISTER(iss, IRQSTATUS(0));\n\tISP5_PRINT_REGISTER(iss, IRQENABLE_SET(0));\n\tISP5_PRINT_REGISTER(iss, IRQENABLE_CLR(0));\n\n\tdev_dbg(iss->dev, \"-----------------------------------------------\\n\");\n}\n\nstatic void ipipeif_write_enable(struct iss_ipipeif_device *ipipeif, u8 enable)\n{\n\tstruct iss_device *iss = to_iss_device(ipipeif);\n\n\tiss_reg_update(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_SYNCEN,\n\t\t       ISIF_SYNCEN_DWEN, enable ? ISIF_SYNCEN_DWEN : 0);\n}\n\n \nstatic void ipipeif_enable(struct iss_ipipeif_device *ipipeif, u8 enable)\n{\n\tstruct iss_device *iss = to_iss_device(ipipeif);\n\n\tiss_reg_update(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_SYNCEN,\n\t\t       ISIF_SYNCEN_SYEN, enable ? ISIF_SYNCEN_SYEN : 0);\n}\n\n \n\n \nstatic void ipipeif_set_outaddr(struct iss_ipipeif_device *ipipeif, u32 addr)\n{\n\tstruct iss_device *iss = to_iss_device(ipipeif);\n\n\t \n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_CADU,\n\t\t      (addr >> (16 + 5)) & ISIF_CADU_MASK);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_CADL,\n\t\t      (addr >> 5) & ISIF_CADL_MASK);\n}\n\nstatic void ipipeif_configure(struct iss_ipipeif_device *ipipeif)\n{\n\tstruct iss_device *iss = to_iss_device(ipipeif);\n\tconst struct iss_format_info *info;\n\tstruct v4l2_mbus_framefmt *format;\n\tu32 isif_ccolp = 0;\n\n\tomap4iss_configure_bridge(iss, ipipeif->input);\n\n\t \n\tformat = &ipipeif->formats[IPIPEIF_PAD_SINK];\n\n\t \n\tiss_reg_clr(iss, OMAP4_ISS_MEM_ISP_IPIPEIF, IPIPEIF_CFG1,\n\t\t    IPIPEIF_CFG1_INPSRC1_MASK | IPIPEIF_CFG1_INPSRC2_MASK);\n\n\t \n\tswitch (format->code) {\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\t\tiss_reg_update(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_MODESET,\n\t\t\t       ISIF_MODESET_CCDMD | ISIF_MODESET_INPMOD_MASK |\n\t\t\t       ISIF_MODESET_CCDW_MASK,\n\t\t\t       ISIF_MODESET_INPMOD_YCBCR16);\n\n\t\tiss_reg_update(iss, OMAP4_ISS_MEM_ISP_IPIPEIF, IPIPEIF_CFG2,\n\t\t\t       IPIPEIF_CFG2_YUV8, IPIPEIF_CFG2_YUV16);\n\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SGRBG10_1X10:\n\t\tisif_ccolp = ISIF_CCOLP_CP0_F0_GR |\n\t\t\tISIF_CCOLP_CP1_F0_R |\n\t\t\tISIF_CCOLP_CP2_F0_B |\n\t\t\tISIF_CCOLP_CP3_F0_GB;\n\t\tgoto cont_raw;\n\tcase MEDIA_BUS_FMT_SRGGB10_1X10:\n\t\tisif_ccolp = ISIF_CCOLP_CP0_F0_R |\n\t\t\tISIF_CCOLP_CP1_F0_GR |\n\t\t\tISIF_CCOLP_CP2_F0_GB |\n\t\t\tISIF_CCOLP_CP3_F0_B;\n\t\tgoto cont_raw;\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\t\tisif_ccolp = ISIF_CCOLP_CP0_F0_B |\n\t\t\tISIF_CCOLP_CP1_F0_GB |\n\t\t\tISIF_CCOLP_CP2_F0_GR |\n\t\t\tISIF_CCOLP_CP3_F0_R;\n\t\tgoto cont_raw;\n\tcase MEDIA_BUS_FMT_SGBRG10_1X10:\n\t\tisif_ccolp = ISIF_CCOLP_CP0_F0_GB |\n\t\t\tISIF_CCOLP_CP1_F0_B |\n\t\t\tISIF_CCOLP_CP2_F0_R |\n\t\t\tISIF_CCOLP_CP3_F0_GR;\ncont_raw:\n\t\tiss_reg_clr(iss, OMAP4_ISS_MEM_ISP_IPIPEIF, IPIPEIF_CFG2,\n\t\t\t    IPIPEIF_CFG2_YUV16);\n\n\t\tiss_reg_update(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_MODESET,\n\t\t\t       ISIF_MODESET_CCDMD | ISIF_MODESET_INPMOD_MASK |\n\t\t\t       ISIF_MODESET_CCDW_MASK, ISIF_MODESET_INPMOD_RAW |\n\t\t\t       ISIF_MODESET_CCDW_2BIT);\n\n\t\tinfo = omap4iss_video_format_info(format->code);\n\t\tiss_reg_update(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_CGAMMAWD,\n\t\t\t       ISIF_CGAMMAWD_GWDI_MASK,\n\t\t\t       ISIF_CGAMMAWD_GWDI(info->bpp));\n\n\t\t \n\t\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_CCOLP,\n\t\t\t      isif_ccolp);\n\t\tbreak;\n\t}\n\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_SPH, 0 & ISIF_SPH_MASK);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_LNH,\n\t\t      (format->width - 1) & ISIF_LNH_MASK);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_LNV,\n\t\t      (format->height - 1) & ISIF_LNV_MASK);\n\n\t \n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_VDINT(0),\n\t\t      format->height - 1);\n\n\t \n\tformat = &ipipeif->formats[IPIPEIF_PAD_SOURCE_ISIF_SF];\n\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_ISIF, ISIF_HSIZE,\n\t\t      (ipipeif->video_out.bpl_value >> 5) &\n\t\t      ISIF_HSIZE_HSIZE_MASK);\n\n\t \n\t \n}\n\n \n\nstatic void ipipeif_isr_buffer(struct iss_ipipeif_device *ipipeif)\n{\n\tstruct iss_buffer *buffer;\n\n\t \n\tif (list_empty(&ipipeif->video_out.dmaqueue))\n\t\treturn;\n\n\tipipeif_write_enable(ipipeif, 0);\n\n\tbuffer = omap4iss_video_buffer_next(&ipipeif->video_out);\n\tif (!buffer)\n\t\treturn;\n\n\tipipeif_set_outaddr(ipipeif, buffer->iss_addr);\n\n\tipipeif_write_enable(ipipeif, 1);\n}\n\n \nvoid omap4iss_ipipeif_isr(struct iss_ipipeif_device *ipipeif, u32 events)\n{\n\tif (omap4iss_module_sync_is_stopping(&ipipeif->wait,\n\t\t\t\t\t     &ipipeif->stopping))\n\t\treturn;\n\n\tif ((events & ISP5_IRQ_ISIF_INT(0)) &&\n\t    (ipipeif->output & IPIPEIF_OUTPUT_MEMORY))\n\t\tipipeif_isr_buffer(ipipeif);\n}\n\n \n\nstatic int ipipeif_video_queue(struct iss_video *video,\n\t\t\t       struct iss_buffer *buffer)\n{\n\tstruct iss_ipipeif_device *ipipeif = container_of(video,\n\t\t\t\tstruct iss_ipipeif_device, video_out);\n\n\tif (!(ipipeif->output & IPIPEIF_OUTPUT_MEMORY))\n\t\treturn -ENODEV;\n\n\tipipeif_set_outaddr(ipipeif, buffer->iss_addr);\n\n\t \n\tif (video->dmaqueue_flags & ISS_VIDEO_DMAQUEUE_UNDERRUN) {\n\t\tif (ipipeif->output & IPIPEIF_OUTPUT_MEMORY)\n\t\t\tipipeif_write_enable(ipipeif, 1);\n\t\tipipeif_enable(ipipeif, 1);\n\t\tiss_video_dmaqueue_flags_clr(video);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iss_video_operations ipipeif_video_ops = {\n\t.queue = ipipeif_video_queue,\n};\n\n \n\n#define IPIPEIF_DRV_SUBCLK_MASK\t(OMAP4_ISS_ISP_SUBCLK_IPIPEIF |\\\n\t\t\t\t OMAP4_ISS_ISP_SUBCLK_ISIF)\n \nstatic int ipipeif_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct iss_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\n\tstruct iss_device *iss = to_iss_device(ipipeif);\n\tstruct iss_video *video_out = &ipipeif->video_out;\n\tint ret = 0;\n\n\tif (ipipeif->state == ISS_PIPELINE_STREAM_STOPPED) {\n\t\tif (enable == ISS_PIPELINE_STREAM_STOPPED)\n\t\t\treturn 0;\n\n\t\tomap4iss_isp_subclk_enable(iss, IPIPEIF_DRV_SUBCLK_MASK);\n\t}\n\n\tswitch (enable) {\n\tcase ISS_PIPELINE_STREAM_CONTINUOUS:\n\n\t\tipipeif_configure(ipipeif);\n\t\tipipeif_print_status(ipipeif);\n\n\t\t \n\t\tif (ipipeif->output & IPIPEIF_OUTPUT_MEMORY &&\n\t\t    !(video_out->dmaqueue_flags & ISS_VIDEO_DMAQUEUE_QUEUED))\n\t\t\tbreak;\n\n\t\tatomic_set(&ipipeif->stopping, 0);\n\t\tif (ipipeif->output & IPIPEIF_OUTPUT_MEMORY)\n\t\t\tipipeif_write_enable(ipipeif, 1);\n\t\tipipeif_enable(ipipeif, 1);\n\t\tiss_video_dmaqueue_flags_clr(video_out);\n\t\tbreak;\n\n\tcase ISS_PIPELINE_STREAM_STOPPED:\n\t\tif (ipipeif->state == ISS_PIPELINE_STREAM_STOPPED)\n\t\t\treturn 0;\n\t\tif (omap4iss_module_sync_idle(&sd->entity, &ipipeif->wait,\n\t\t\t\t\t      &ipipeif->stopping))\n\t\t\tret = -ETIMEDOUT;\n\n\t\tif (ipipeif->output & IPIPEIF_OUTPUT_MEMORY)\n\t\t\tipipeif_write_enable(ipipeif, 0);\n\t\tipipeif_enable(ipipeif, 0);\n\t\tomap4iss_isp_subclk_disable(iss, IPIPEIF_DRV_SUBCLK_MASK);\n\t\tiss_video_dmaqueue_flags_clr(video_out);\n\t\tbreak;\n\t}\n\n\tipipeif->state = enable;\n\treturn ret;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__ipipeif_get_format(struct iss_ipipeif_device *ipipeif,\n\t\t     struct v4l2_subdev_state *sd_state, unsigned int pad,\n\t\t     enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&ipipeif->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\treturn &ipipeif->formats[pad];\n}\n\n \nstatic void\nipipeif_try_format(struct iss_ipipeif_device *ipipeif,\n\t\t   struct v4l2_subdev_state *sd_state, unsigned int pad,\n\t\t   struct v4l2_mbus_framefmt *fmt,\n\t\t   enum v4l2_subdev_format_whence which)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\tunsigned int width = fmt->width;\n\tunsigned int height = fmt->height;\n\tunsigned int i;\n\n\tswitch (pad) {\n\tcase IPIPEIF_PAD_SINK:\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(ipipeif_fmts); i++) {\n\t\t\tif (fmt->code == ipipeif_fmts[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i >= ARRAY_SIZE(ipipeif_fmts))\n\t\t\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\n\t\t \n\t\tfmt->width = clamp_t(u32, width, 1, 8192);\n\t\tfmt->height = clamp_t(u32, height, 1, 8192);\n\t\tbreak;\n\n\tcase IPIPEIF_PAD_SOURCE_ISIF_SF:\n\t\tformat = __ipipeif_get_format(ipipeif, sd_state,\n\t\t\t\t\t      IPIPEIF_PAD_SINK,\n\t\t\t\t\t      which);\n\t\tmemcpy(fmt, format, sizeof(*fmt));\n\n\t\t \n\t\tfmt->width = clamp_t(u32, width, 32, (fmt->width + 15) & ~15);\n\t\tfmt->width &= ~15;\n\t\tfmt->height = clamp_t(u32, height, 32, fmt->height);\n\t\tbreak;\n\n\tcase IPIPEIF_PAD_SOURCE_VP:\n\t\tformat = __ipipeif_get_format(ipipeif, sd_state,\n\t\t\t\t\t      IPIPEIF_PAD_SINK,\n\t\t\t\t\t      which);\n\t\tmemcpy(fmt, format, sizeof(*fmt));\n\n\t\tfmt->width = clamp_t(u32, width, 32, fmt->width);\n\t\tfmt->height = clamp_t(u32, height, 32, fmt->height);\n\t\tbreak;\n\t}\n\n\t \n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\tfmt->field = V4L2_FIELD_NONE;\n}\n\n \nstatic int ipipeif_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct iss_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tswitch (code->pad) {\n\tcase IPIPEIF_PAD_SINK:\n\t\tif (code->index >= ARRAY_SIZE(ipipeif_fmts))\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = ipipeif_fmts[code->index];\n\t\tbreak;\n\n\tcase IPIPEIF_PAD_SOURCE_ISIF_SF:\n\tcase IPIPEIF_PAD_SOURCE_VP:\n\t\t \n\t\tif (code->index != 0)\n\t\t\treturn -EINVAL;\n\n\t\tformat = __ipipeif_get_format(ipipeif, sd_state,\n\t\t\t\t\t      IPIPEIF_PAD_SINK,\n\t\t\t\t\t      code->which);\n\n\t\tcode->code = format->code;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipipeif_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct iss_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt format;\n\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = 1;\n\tformat.height = 1;\n\tipipeif_try_format(ipipeif, sd_state, fse->pad, &format, fse->which);\n\tfse->min_width = format.width;\n\tfse->min_height = format.height;\n\n\tif (format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = -1;\n\tformat.height = -1;\n\tipipeif_try_format(ipipeif, sd_state, fse->pad, &format, fse->which);\n\tfse->max_width = format.width;\n\tfse->max_height = format.height;\n\n\treturn 0;\n}\n\n \nstatic int ipipeif_get_format(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct iss_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __ipipeif_get_format(ipipeif, sd_state, fmt->pad, fmt->which);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\treturn 0;\n}\n\n \nstatic int ipipeif_set_format(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct iss_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __ipipeif_get_format(ipipeif, sd_state, fmt->pad, fmt->which);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\tipipeif_try_format(ipipeif, sd_state, fmt->pad, &fmt->format,\n\t\t\t   fmt->which);\n\t*format = fmt->format;\n\n\t \n\tif (fmt->pad == IPIPEIF_PAD_SINK) {\n\t\tformat = __ipipeif_get_format(ipipeif, sd_state,\n\t\t\t\t\t      IPIPEIF_PAD_SOURCE_ISIF_SF,\n\t\t\t\t\t      fmt->which);\n\t\t*format = fmt->format;\n\t\tipipeif_try_format(ipipeif, sd_state,\n\t\t\t\t   IPIPEIF_PAD_SOURCE_ISIF_SF,\n\t\t\t\t   format, fmt->which);\n\n\t\tformat = __ipipeif_get_format(ipipeif, sd_state,\n\t\t\t\t\t      IPIPEIF_PAD_SOURCE_VP,\n\t\t\t\t\t      fmt->which);\n\t\t*format = fmt->format;\n\t\tipipeif_try_format(ipipeif, sd_state, IPIPEIF_PAD_SOURCE_VP,\n\t\t\t\t   format,\n\t\t\t\t   fmt->which);\n\t}\n\n\treturn 0;\n}\n\nstatic int ipipeif_link_validate(struct v4l2_subdev *sd,\n\t\t\t\t struct media_link *link,\n\t\t\t\t struct v4l2_subdev_format *source_fmt,\n\t\t\t\t struct v4l2_subdev_format *sink_fmt)\n{\n\t \n\tif (source_fmt->format.width != sink_fmt->format.width ||\n\t    source_fmt->format.height != sink_fmt->format.height)\n\t\treturn -EPIPE;\n\n\tif (source_fmt->format.code != sink_fmt->format.code)\n\t\treturn -EPIPE;\n\n\treturn 0;\n}\n\n \nstatic int ipipeif_init_formats(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_subdev_format format;\n\n\tmemset(&format, 0, sizeof(format));\n\tformat.pad = IPIPEIF_PAD_SINK;\n\tformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\n\tformat.format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\tformat.format.width = 4096;\n\tformat.format.height = 4096;\n\tipipeif_set_format(sd, fh ? fh->state : NULL, &format);\n\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_video_ops ipipeif_v4l2_video_ops = {\n\t.s_stream = ipipeif_set_stream,\n};\n\n \nstatic const struct v4l2_subdev_pad_ops ipipeif_v4l2_pad_ops = {\n\t.enum_mbus_code = ipipeif_enum_mbus_code,\n\t.enum_frame_size = ipipeif_enum_frame_size,\n\t.get_fmt = ipipeif_get_format,\n\t.set_fmt = ipipeif_set_format,\n\t.link_validate = ipipeif_link_validate,\n};\n\n \nstatic const struct v4l2_subdev_ops ipipeif_v4l2_ops = {\n\t.video = &ipipeif_v4l2_video_ops,\n\t.pad = &ipipeif_v4l2_pad_ops,\n};\n\n \nstatic const struct v4l2_subdev_internal_ops ipipeif_v4l2_internal_ops = {\n\t.open = ipipeif_init_formats,\n};\n\n \n\n \nstatic int ipipeif_link_setup(struct media_entity *entity,\n\t\t\t      const struct media_pad *local,\n\t\t\t      const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct iss_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\n\tstruct iss_device *iss = to_iss_device(ipipeif);\n\tunsigned int index = local->index;\n\n\t \n\tif (is_media_entity_v4l2_subdev(remote->entity))\n\t\tindex |= 2 << 16;\n\n\tswitch (index) {\n\tcase IPIPEIF_PAD_SINK | 2 << 16:\n\t\t \n\t\tif (!(flags & MEDIA_LNK_FL_ENABLED)) {\n\t\t\tipipeif->input = IPIPEIF_INPUT_NONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ipipeif->input != IPIPEIF_INPUT_NONE)\n\t\t\treturn -EBUSY;\n\n\t\tif (remote->entity == &iss->csi2a.subdev.entity)\n\t\t\tipipeif->input = IPIPEIF_INPUT_CSI2A;\n\t\telse if (remote->entity == &iss->csi2b.subdev.entity)\n\t\t\tipipeif->input = IPIPEIF_INPUT_CSI2B;\n\n\t\tbreak;\n\n\tcase IPIPEIF_PAD_SOURCE_ISIF_SF:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (ipipeif->output & ~IPIPEIF_OUTPUT_MEMORY)\n\t\t\t\treturn -EBUSY;\n\t\t\tipipeif->output |= IPIPEIF_OUTPUT_MEMORY;\n\t\t} else {\n\t\t\tipipeif->output &= ~IPIPEIF_OUTPUT_MEMORY;\n\t\t}\n\t\tbreak;\n\n\tcase IPIPEIF_PAD_SOURCE_VP | 2 << 16:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (ipipeif->output & ~IPIPEIF_OUTPUT_VP)\n\t\t\t\treturn -EBUSY;\n\t\t\tipipeif->output |= IPIPEIF_OUTPUT_VP;\n\t\t} else {\n\t\t\tipipeif->output &= ~IPIPEIF_OUTPUT_VP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct media_entity_operations ipipeif_media_ops = {\n\t.link_setup = ipipeif_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n \nstatic int ipipeif_init_entities(struct iss_ipipeif_device *ipipeif)\n{\n\tstruct v4l2_subdev *sd = &ipipeif->subdev;\n\tstruct media_pad *pads = ipipeif->pads;\n\tstruct media_entity *me = &sd->entity;\n\tint ret;\n\n\tipipeif->input = IPIPEIF_INPUT_NONE;\n\n\tv4l2_subdev_init(sd, &ipipeif_v4l2_ops);\n\tsd->internal_ops = &ipipeif_v4l2_internal_ops;\n\tstrscpy(sd->name, \"OMAP4 ISS ISP IPIPEIF\", sizeof(sd->name));\n\tsd->grp_id = BIT(16);\t \n\tv4l2_set_subdevdata(sd, ipipeif);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tpads[IPIPEIF_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tpads[IPIPEIF_PAD_SOURCE_ISIF_SF].flags = MEDIA_PAD_FL_SOURCE;\n\tpads[IPIPEIF_PAD_SOURCE_VP].flags = MEDIA_PAD_FL_SOURCE;\n\n\tme->ops = &ipipeif_media_ops;\n\tret = media_entity_pads_init(me, IPIPEIF_PADS_NUM, pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tipipeif_init_formats(sd, NULL);\n\n\tipipeif->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tipipeif->video_out.ops = &ipipeif_video_ops;\n\tipipeif->video_out.iss = to_iss_device(ipipeif);\n\tipipeif->video_out.capture_mem = PAGE_ALIGN(4096 * 4096) * 3;\n\tipipeif->video_out.bpl_alignment = 32;\n\tipipeif->video_out.bpl_zero_padding = 1;\n\tipipeif->video_out.bpl_max = 0x1ffe0;\n\n\treturn omap4iss_video_init(&ipipeif->video_out, \"ISP IPIPEIF\");\n}\n\nvoid omap4iss_ipipeif_unregister_entities(struct iss_ipipeif_device *ipipeif)\n{\n\tv4l2_device_unregister_subdev(&ipipeif->subdev);\n\tomap4iss_video_unregister(&ipipeif->video_out);\n}\n\nint omap4iss_ipipeif_register_entities(struct iss_ipipeif_device *ipipeif,\n\t\t\t\t       struct v4l2_device *vdev)\n{\n\tint ret;\n\n\t \n\tret = v4l2_device_register_subdev(vdev, &ipipeif->subdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = omap4iss_video_register(&ipipeif->video_out, vdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tomap4iss_ipipeif_unregister_entities(ipipeif);\n\treturn ret;\n}\n\n \n\n \nint omap4iss_ipipeif_init(struct iss_device *iss)\n{\n\tstruct iss_ipipeif_device *ipipeif = &iss->ipipeif;\n\n\tipipeif->state = ISS_PIPELINE_STREAM_STOPPED;\n\tinit_waitqueue_head(&ipipeif->wait);\n\n\treturn ipipeif_init_entities(ipipeif);\n}\n\n \nint omap4iss_ipipeif_create_links(struct iss_device *iss)\n{\n\tstruct iss_ipipeif_device *ipipeif = &iss->ipipeif;\n\n\t \n\treturn media_create_pad_link(&ipipeif->subdev.entity,\n\t\t\t\t     IPIPEIF_PAD_SOURCE_ISIF_SF,\n\t\t\t\t     &ipipeif->video_out.video.entity, 0, 0);\n}\n\n \nvoid omap4iss_ipipeif_cleanup(struct iss_device *iss)\n{\n\tstruct iss_ipipeif_device *ipipeif = &iss->ipipeif;\n\n\tmedia_entity_cleanup(&ipipeif->subdev.entity);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}