{
  "module_name": "iss_csi2.c",
  "hash_id": "544507000ce0d4d91b9518399a9965a6865cd9b880e472e4f6aa56edb9faf19b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/omap4iss/iss_csi2.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <media/v4l2-common.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/mm.h>\n\n#include \"iss.h\"\n#include \"iss_regs.h\"\n#include \"iss_csi2.h\"\n\n \nstatic void csi2_if_enable(struct iss_csi2_device *csi2, u8 enable)\n{\n\tstruct iss_csi2_ctrl_cfg *currctrl = &csi2->ctrl;\n\n\tiss_reg_update(csi2->iss, csi2->regs1, CSI2_CTRL, CSI2_CTRL_IF_EN,\n\t\t       enable ? CSI2_CTRL_IF_EN : 0);\n\n\tcurrctrl->if_enable = enable;\n}\n\n \nstatic void csi2_recv_config(struct iss_csi2_device *csi2,\n\t\t\t     struct iss_csi2_ctrl_cfg *currctrl)\n{\n\tu32 reg = 0;\n\n\tif (currctrl->frame_mode)\n\t\treg |= CSI2_CTRL_FRAME;\n\telse\n\t\treg &= ~CSI2_CTRL_FRAME;\n\n\tif (currctrl->vp_clk_enable)\n\t\treg |= CSI2_CTRL_VP_CLK_EN;\n\telse\n\t\treg &= ~CSI2_CTRL_VP_CLK_EN;\n\n\tif (currctrl->vp_only_enable)\n\t\treg |= CSI2_CTRL_VP_ONLY_EN;\n\telse\n\t\treg &= ~CSI2_CTRL_VP_ONLY_EN;\n\n\treg &= ~CSI2_CTRL_VP_OUT_CTRL_MASK;\n\treg |= currctrl->vp_out_ctrl << CSI2_CTRL_VP_OUT_CTRL_SHIFT;\n\n\tif (currctrl->ecc_enable)\n\t\treg |= CSI2_CTRL_ECC_EN;\n\telse\n\t\treg &= ~CSI2_CTRL_ECC_EN;\n\n\t \n\treg &= ~(CSI2_CTRL_MFLAG_LEVH_MASK | CSI2_CTRL_MFLAG_LEVL_MASK);\n\treg |= (2 << CSI2_CTRL_MFLAG_LEVH_SHIFT) |\n\t       (4 << CSI2_CTRL_MFLAG_LEVL_SHIFT);\n\n\t \n\treg |= CSI2_CTRL_BURST_SIZE_EXPAND;\n\n\t \n\treg |= CSI2_CTRL_NON_POSTED_WRITE;\n\n\t \n\treg |= CSI2_CTRL_ENDIANNESS;\n\n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_CTRL, reg);\n}\n\nstatic const unsigned int csi2_input_fmts[] = {\n\tMEDIA_BUS_FMT_SGRBG10_1X10,\n\tMEDIA_BUS_FMT_SGRBG10_DPCM8_1X8,\n\tMEDIA_BUS_FMT_SRGGB10_1X10,\n\tMEDIA_BUS_FMT_SRGGB10_DPCM8_1X8,\n\tMEDIA_BUS_FMT_SBGGR10_1X10,\n\tMEDIA_BUS_FMT_SBGGR10_DPCM8_1X8,\n\tMEDIA_BUS_FMT_SGBRG10_1X10,\n\tMEDIA_BUS_FMT_SGBRG10_DPCM8_1X8,\n\tMEDIA_BUS_FMT_SBGGR8_1X8,\n\tMEDIA_BUS_FMT_SGBRG8_1X8,\n\tMEDIA_BUS_FMT_SGRBG8_1X8,\n\tMEDIA_BUS_FMT_SRGGB8_1X8,\n\tMEDIA_BUS_FMT_UYVY8_1X16,\n\tMEDIA_BUS_FMT_YUYV8_1X16,\n};\n\n \nstatic const u16 __csi2_fmt_map[][2][2] = {\n\t \n\t{\n\t\t \n\t\t{\n\t\t\t \n\t\t\tCSI2_PIX_FMT_RAW10_EXP16,\n\t\t\t \n\t\t\t0,\n\t\t},\n\t\t \n\t\t{\n\t\t\t \n\t\t\tCSI2_PIX_FMT_RAW10_EXP16_VP,\n\t\t\t \n\t\t\t0,\n\t\t},\n\t},\n\t \n\t{\n\t\t \n\t\t{\n\t\t\t \n\t\t\tCSI2_USERDEF_8BIT_DATA1,\n\t\t\t \n\t\t\tCSI2_USERDEF_8BIT_DATA1_DPCM10,\n\t\t},\n\t\t \n\t\t{\n\t\t\t \n\t\t\tCSI2_PIX_FMT_RAW8_VP,\n\t\t\t \n\t\t\tCSI2_USERDEF_8BIT_DATA1_DPCM10_VP,\n\t\t},\n\t},\n\t \n\t{\n\t\t \n\t\t{\n\t\t\t \n\t\t\tCSI2_PIX_FMT_RAW8,\n\t\t\t \n\t\t\t0,\n\t\t},\n\t\t \n\t\t{\n\t\t\t \n\t\t\tCSI2_PIX_FMT_RAW8_VP,\n\t\t\t \n\t\t\t0,\n\t\t},\n\t},\n\t \n\t{\n\t\t \n\t\t{\n\t\t\t \n\t\t\tCSI2_PIX_FMT_YUV422_8BIT,\n\t\t\t \n\t\t\t0,\n\t\t},\n\t\t \n\t\t{\n\t\t\t \n\t\t\tCSI2_PIX_FMT_YUV422_8BIT_VP16,\n\t\t\t \n\t\t\t0,\n\t\t},\n\t},\n};\n\n \nstatic u16 csi2_ctx_map_format(struct iss_csi2_device *csi2)\n{\n\tconst struct v4l2_mbus_framefmt *fmt = &csi2->formats[CSI2_PAD_SINK];\n\tint fmtidx, destidx;\n\n\tswitch (fmt->code) {\n\tcase MEDIA_BUS_FMT_SGRBG10_1X10:\n\tcase MEDIA_BUS_FMT_SRGGB10_1X10:\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\tcase MEDIA_BUS_FMT_SGBRG10_1X10:\n\t\tfmtidx = 0;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:\n\tcase MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:\n\tcase MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:\n\tcase MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:\n\t\tfmtidx = 1;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\t\tfmtidx = 2;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\t\tfmtidx = 3;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"CSI2: pixel format %08x unsupported!\\n\",\n\t\t     fmt->code);\n\t\treturn 0;\n\t}\n\n\tif (!(csi2->output & CSI2_OUTPUT_IPIPEIF) &&\n\t    !(csi2->output & CSI2_OUTPUT_MEMORY)) {\n\t\t \n\t\treturn CSI2_PIX_FMT_OTHERS;\n\t}\n\n\t \n\tdestidx = csi2->frame_skip ? 0 : !!(csi2->output & CSI2_OUTPUT_IPIPEIF);\n\n\treturn __csi2_fmt_map[fmtidx][destidx][csi2->dpcm_decompress];\n}\n\n \nstatic void csi2_set_outaddr(struct iss_csi2_device *csi2, u32 addr)\n{\n\tstruct iss_csi2_ctx_cfg *ctx = &csi2->contexts[0];\n\n\tctx->ping_addr = addr;\n\tctx->pong_addr = addr;\n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_PING_ADDR(ctx->ctxnum),\n\t\t      ctx->ping_addr);\n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_PONG_ADDR(ctx->ctxnum),\n\t\t      ctx->pong_addr);\n}\n\n \nstatic inline int is_usr_def_mapping(u32 format_id)\n{\n\treturn (format_id & 0xf0) == 0x40 ? 1 : 0;\n}\n\n \nstatic void csi2_ctx_enable(struct iss_csi2_device *csi2, u8 ctxnum, u8 enable)\n{\n\tstruct iss_csi2_ctx_cfg *ctx = &csi2->contexts[ctxnum];\n\tu32 reg;\n\n\treg = iss_reg_read(csi2->iss, csi2->regs1, CSI2_CTX_CTRL1(ctxnum));\n\n\tif (enable) {\n\t\tunsigned int skip = 0;\n\n\t\tif (csi2->frame_skip)\n\t\t\tskip = csi2->frame_skip;\n\t\telse if (csi2->output & CSI2_OUTPUT_MEMORY)\n\t\t\tskip = 1;\n\n\t\treg &= ~CSI2_CTX_CTRL1_COUNT_MASK;\n\t\treg |= CSI2_CTX_CTRL1_COUNT_UNLOCK\n\t\t    |  (skip << CSI2_CTX_CTRL1_COUNT_SHIFT)\n\t\t    |  CSI2_CTX_CTRL1_CTX_EN;\n\t} else {\n\t\treg &= ~CSI2_CTX_CTRL1_CTX_EN;\n\t}\n\n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_CTRL1(ctxnum), reg);\n\tctx->enabled = enable;\n}\n\n \nstatic void csi2_ctx_config(struct iss_csi2_device *csi2,\n\t\t\t    struct iss_csi2_ctx_cfg *ctx)\n{\n\tu32 reg = 0;\n\n\tctx->frame = 0;\n\n\t \n\tif (ctx->eof_enabled)\n\t\treg = CSI2_CTX_CTRL1_EOF_EN;\n\n\tif (ctx->eol_enabled)\n\t\treg |= CSI2_CTX_CTRL1_EOL_EN;\n\n\tif (ctx->checksum_enabled)\n\t\treg |= CSI2_CTX_CTRL1_CS_EN;\n\n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_CTRL1(ctx->ctxnum), reg);\n\n\t \n\treg = ctx->virtual_id << CSI2_CTX_CTRL2_VIRTUAL_ID_SHIFT;\n\treg |= ctx->format_id << CSI2_CTX_CTRL2_FORMAT_SHIFT;\n\n\tif (ctx->dpcm_decompress && ctx->dpcm_predictor)\n\t\treg |= CSI2_CTX_CTRL2_DPCM_PRED;\n\n\tif (is_usr_def_mapping(ctx->format_id))\n\t\treg |= 2 << CSI2_CTX_CTRL2_USER_DEF_MAP_SHIFT;\n\n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_CTRL2(ctx->ctxnum), reg);\n\n\t \n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_CTRL3(ctx->ctxnum),\n\t\t      ctx->alpha << CSI2_CTX_CTRL3_ALPHA_SHIFT);\n\n\t \n\tiss_reg_update(csi2->iss, csi2->regs1, CSI2_CTX_DAT_OFST(ctx->ctxnum),\n\t\t       CSI2_CTX_DAT_OFST_MASK, ctx->data_offset);\n\n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_PING_ADDR(ctx->ctxnum),\n\t\t      ctx->ping_addr);\n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_PONG_ADDR(ctx->ctxnum),\n\t\t      ctx->pong_addr);\n}\n\n \nstatic void csi2_timing_config(struct iss_csi2_device *csi2,\n\t\t\t       struct iss_csi2_timing_cfg *timing)\n{\n\tu32 reg;\n\n\treg = iss_reg_read(csi2->iss, csi2->regs1, CSI2_TIMING);\n\n\tif (timing->force_rx_mode)\n\t\treg |= CSI2_TIMING_FORCE_RX_MODE_IO1;\n\telse\n\t\treg &= ~CSI2_TIMING_FORCE_RX_MODE_IO1;\n\n\tif (timing->stop_state_16x)\n\t\treg |= CSI2_TIMING_STOP_STATE_X16_IO1;\n\telse\n\t\treg &= ~CSI2_TIMING_STOP_STATE_X16_IO1;\n\n\tif (timing->stop_state_4x)\n\t\treg |= CSI2_TIMING_STOP_STATE_X4_IO1;\n\telse\n\t\treg &= ~CSI2_TIMING_STOP_STATE_X4_IO1;\n\n\treg &= ~CSI2_TIMING_STOP_STATE_COUNTER_IO1_MASK;\n\treg |= timing->stop_state_counter <<\n\t       CSI2_TIMING_STOP_STATE_COUNTER_IO1_SHIFT;\n\n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_TIMING, reg);\n}\n\n \nstatic void csi2_irq_ctx_set(struct iss_csi2_device *csi2, int enable)\n{\n\tconst u32 mask = CSI2_CTX_IRQ_FE | CSI2_CTX_IRQ_FS;\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_IRQSTATUS(i),\n\t\t\t      mask);\n\t\tif (enable)\n\t\t\tiss_reg_set(csi2->iss, csi2->regs1,\n\t\t\t\t    CSI2_CTX_IRQENABLE(i), mask);\n\t\telse\n\t\t\tiss_reg_clr(csi2->iss, csi2->regs1,\n\t\t\t\t    CSI2_CTX_IRQENABLE(i), mask);\n\t}\n}\n\n \nstatic void csi2_irq_complexio1_set(struct iss_csi2_device *csi2, int enable)\n{\n\tu32 reg;\n\n\treg = CSI2_COMPLEXIO_IRQ_STATEALLULPMEXIT |\n\t\tCSI2_COMPLEXIO_IRQ_STATEALLULPMENTER |\n\t\tCSI2_COMPLEXIO_IRQ_STATEULPM5 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRCONTROL5 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRESC5 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRSOTSYNCHS5 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRSOTHS5 |\n\t\tCSI2_COMPLEXIO_IRQ_STATEULPM4 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRCONTROL4 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRESC4 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRSOTSYNCHS4 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRSOTHS4 |\n\t\tCSI2_COMPLEXIO_IRQ_STATEULPM3 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRCONTROL3 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRESC3 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRSOTSYNCHS3 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRSOTHS3 |\n\t\tCSI2_COMPLEXIO_IRQ_STATEULPM2 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRCONTROL2 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRESC2 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRSOTSYNCHS2 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRSOTHS2 |\n\t\tCSI2_COMPLEXIO_IRQ_STATEULPM1 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRCONTROL1 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRESC1 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRSOTSYNCHS1 |\n\t\tCSI2_COMPLEXIO_IRQ_ERRSOTHS1;\n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_COMPLEXIO_IRQSTATUS, reg);\n\tif (enable)\n\t\tiss_reg_set(csi2->iss, csi2->regs1, CSI2_COMPLEXIO_IRQENABLE,\n\t\t\t    reg);\n\telse\n\t\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_COMPLEXIO_IRQENABLE,\n\t\t\t      0);\n}\n\n \nstatic void csi2_irq_status_set(struct iss_csi2_device *csi2, int enable)\n{\n\tu32 reg;\n\n\treg = CSI2_IRQ_OCP_ERR |\n\t\tCSI2_IRQ_SHORT_PACKET |\n\t\tCSI2_IRQ_ECC_CORRECTION |\n\t\tCSI2_IRQ_ECC_NO_CORRECTION |\n\t\tCSI2_IRQ_COMPLEXIO_ERR |\n\t\tCSI2_IRQ_FIFO_OVF |\n\t\tCSI2_IRQ_CONTEXT0;\n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_IRQSTATUS, reg);\n\tif (enable)\n\t\tiss_reg_set(csi2->iss, csi2->regs1, CSI2_IRQENABLE, reg);\n\telse\n\t\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_IRQENABLE, 0);\n}\n\n \nint omap4iss_csi2_reset(struct iss_csi2_device *csi2)\n{\n\tunsigned int timeout;\n\n\tif (!csi2->available)\n\t\treturn -ENODEV;\n\n\tif (csi2->phy->phy_in_use)\n\t\treturn -EBUSY;\n\n\tiss_reg_set(csi2->iss, csi2->regs1, CSI2_SYSCONFIG,\n\t\t    CSI2_SYSCONFIG_SOFT_RESET);\n\n\ttimeout = iss_poll_condition_timeout(\n\t\tiss_reg_read(csi2->iss, csi2->regs1, CSI2_SYSSTATUS) &\n\t\tCSI2_SYSSTATUS_RESET_DONE, 500, 100, 200);\n\tif (timeout) {\n\t\tdev_err(csi2->iss->dev, \"CSI2: Soft reset timeout!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tiss_reg_set(csi2->iss, csi2->regs1, CSI2_COMPLEXIO_CFG,\n\t\t    CSI2_COMPLEXIO_CFG_RESET_CTRL);\n\n\ttimeout = iss_poll_condition_timeout(\n\t\tiss_reg_read(csi2->iss, csi2->phy->phy_regs, REGISTER1) &\n\t\tREGISTER1_RESET_DONE_CTRLCLK, 10000, 100, 500);\n\tif (timeout) {\n\t\tdev_err(csi2->iss->dev, \"CSI2: CSI2_96M_FCLK reset timeout!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tiss_reg_update(csi2->iss, csi2->regs1, CSI2_SYSCONFIG,\n\t\t       CSI2_SYSCONFIG_MSTANDBY_MODE_MASK |\n\t\t       CSI2_SYSCONFIG_AUTO_IDLE,\n\t\t       CSI2_SYSCONFIG_MSTANDBY_MODE_NO);\n\n\treturn 0;\n}\n\nstatic int csi2_configure(struct iss_csi2_device *csi2)\n{\n\tconst struct iss_v4l2_subdevs_group *pdata;\n\tstruct iss_csi2_timing_cfg *timing = &csi2->timing[0];\n\tstruct v4l2_subdev *sensor;\n\tstruct media_pad *pad;\n\n\t \n\tif (csi2->contexts[0].enabled || csi2->ctrl.if_enable)\n\t\treturn -EBUSY;\n\n\tpad = media_pad_remote_pad_first(&csi2->pads[CSI2_PAD_SINK]);\n\tsensor = media_entity_to_v4l2_subdev(pad->entity);\n\tpdata = sensor->host_priv;\n\n\tcsi2->frame_skip = 0;\n\tv4l2_subdev_call(sensor, sensor, g_skip_frames, &csi2->frame_skip);\n\n\tcsi2->ctrl.vp_out_ctrl = pdata->bus.csi2.vpclk_div;\n\tcsi2->ctrl.frame_mode = ISS_CSI2_FRAME_IMMEDIATE;\n\tcsi2->ctrl.ecc_enable = pdata->bus.csi2.crc;\n\n\ttiming->force_rx_mode = 1;\n\ttiming->stop_state_16x = 1;\n\ttiming->stop_state_4x = 1;\n\ttiming->stop_state_counter = 0x1ff;\n\n\t \n\tif (csi2->formats[CSI2_PAD_SINK].code !=\n\t    csi2->formats[CSI2_PAD_SOURCE].code)\n\t\tcsi2->dpcm_decompress = true;\n\telse\n\t\tcsi2->dpcm_decompress = false;\n\n\tcsi2->contexts[0].format_id = csi2_ctx_map_format(csi2);\n\n\tif (csi2->video_out.bpl_padding == 0)\n\t\tcsi2->contexts[0].data_offset = 0;\n\telse\n\t\tcsi2->contexts[0].data_offset = csi2->video_out.bpl_value;\n\n\t \n\tcsi2->contexts[0].eof_enabled = 1;\n\tcsi2->contexts[0].eol_enabled = 1;\n\n\tcsi2_irq_complexio1_set(csi2, 1);\n\tcsi2_irq_ctx_set(csi2, 1);\n\tcsi2_irq_status_set(csi2, 1);\n\n\t \n\tcsi2_timing_config(csi2, timing);\n\tcsi2_recv_config(csi2, &csi2->ctrl);\n\tcsi2_ctx_config(csi2, &csi2->contexts[0]);\n\n\treturn 0;\n}\n\n \n#define CSI2_PRINT_REGISTER(iss, regs, name)\\\n\tdev_dbg(iss->dev, \"###CSI2 \" #name \"=0x%08x\\n\", \\\n\t\tiss_reg_read(iss, regs, CSI2_##name))\n\nstatic void csi2_print_status(struct iss_csi2_device *csi2)\n{\n\tstruct iss_device *iss = csi2->iss;\n\n\tif (!csi2->available)\n\t\treturn;\n\n\tdev_dbg(iss->dev, \"-------------CSI2 Register dump-------------\\n\");\n\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, SYSCONFIG);\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, SYSSTATUS);\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, IRQENABLE);\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, IRQSTATUS);\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, CTRL);\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, DBG_H);\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, COMPLEXIO_CFG);\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, COMPLEXIO_IRQSTATUS);\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, SHORT_PACKET);\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, COMPLEXIO_IRQENABLE);\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, DBG_P);\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, TIMING);\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_CTRL1(0));\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_CTRL2(0));\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_DAT_OFST(0));\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_PING_ADDR(0));\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_PONG_ADDR(0));\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_IRQENABLE(0));\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_IRQSTATUS(0));\n\tCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_CTRL3(0));\n\n\tdev_dbg(iss->dev, \"--------------------------------------------\\n\");\n}\n\n \n\n \nstatic void csi2_isr_buffer(struct iss_csi2_device *csi2)\n{\n\tstruct iss_buffer *buffer;\n\n\tcsi2_ctx_enable(csi2, 0, 0);\n\n\tbuffer = omap4iss_video_buffer_next(&csi2->video_out);\n\n\t \n\tif (!buffer)\n\t\treturn;\n\n\tcsi2_set_outaddr(csi2, buffer->iss_addr);\n\tcsi2_ctx_enable(csi2, 0, 1);\n}\n\nstatic void csi2_isr_ctx(struct iss_csi2_device *csi2,\n\t\t\t struct iss_csi2_ctx_cfg *ctx)\n{\n\tunsigned int n = ctx->ctxnum;\n\tu32 status;\n\n\tstatus = iss_reg_read(csi2->iss, csi2->regs1, CSI2_CTX_IRQSTATUS(n));\n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_IRQSTATUS(n), status);\n\n\tif (omap4iss_module_sync_is_stopping(&csi2->wait, &csi2->stopping))\n\t\treturn;\n\n\t \n\tif (status & CSI2_CTX_IRQ_FS) {\n\t\tstruct iss_pipeline *pipe =\n\t\t\t\t     to_iss_pipeline(&csi2->subdev.entity);\n\t\tu16 frame;\n\t\tu16 delta;\n\n\t\tframe = iss_reg_read(csi2->iss, csi2->regs1,\n\t\t\t\t     CSI2_CTX_CTRL2(ctx->ctxnum))\n\t\t      >> CSI2_CTX_CTRL2_FRAME_SHIFT;\n\n\t\tif (frame == 0) {\n\t\t\t \n\t\t\tatomic_inc(&pipe->frame_number);\n\t\t} else {\n\t\t\t \n\t\t\tdelta = frame - ctx->frame;\n\t\t\tif (frame < ctx->frame)\n\t\t\t\tdelta--;\n\t\t\tctx->frame = frame;\n\n\t\t\tatomic_add(delta, &pipe->frame_number);\n\t\t}\n\t}\n\n\tif (!(status & CSI2_CTX_IRQ_FE))\n\t\treturn;\n\n\t \n\tif (csi2->frame_skip) {\n\t\tcsi2->frame_skip--;\n\t\tif (csi2->frame_skip == 0) {\n\t\t\tctx->format_id = csi2_ctx_map_format(csi2);\n\t\t\tcsi2_ctx_config(csi2, ctx);\n\t\t\tcsi2_ctx_enable(csi2, n, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (csi2->output & CSI2_OUTPUT_MEMORY)\n\t\tcsi2_isr_buffer(csi2);\n}\n\n \nvoid omap4iss_csi2_isr(struct iss_csi2_device *csi2)\n{\n\tstruct iss_pipeline *pipe = to_iss_pipeline(&csi2->subdev.entity);\n\tu32 csi2_irqstatus, cpxio1_irqstatus;\n\tstruct iss_device *iss = csi2->iss;\n\n\tif (!csi2->available)\n\t\treturn;\n\n\tcsi2_irqstatus = iss_reg_read(csi2->iss, csi2->regs1, CSI2_IRQSTATUS);\n\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_IRQSTATUS, csi2_irqstatus);\n\n\t \n\tif (csi2_irqstatus & CSI2_IRQ_COMPLEXIO_ERR) {\n\t\tcpxio1_irqstatus = iss_reg_read(csi2->iss, csi2->regs1,\n\t\t\t\t\t\tCSI2_COMPLEXIO_IRQSTATUS);\n\t\tiss_reg_write(csi2->iss, csi2->regs1, CSI2_COMPLEXIO_IRQSTATUS,\n\t\t\t      cpxio1_irqstatus);\n\t\tdev_dbg(iss->dev, \"CSI2: ComplexIO Error IRQ %x\\n\",\n\t\t\tcpxio1_irqstatus);\n\t\tpipe->error = true;\n\t}\n\n\tif (csi2_irqstatus & (CSI2_IRQ_OCP_ERR |\n\t\t\t      CSI2_IRQ_SHORT_PACKET |\n\t\t\t      CSI2_IRQ_ECC_NO_CORRECTION |\n\t\t\t      CSI2_IRQ_COMPLEXIO_ERR |\n\t\t\t      CSI2_IRQ_FIFO_OVF)) {\n\t\tdev_dbg(iss->dev,\n\t\t\t\"CSI2 Err: OCP:%d SHORT:%d ECC:%d CPXIO:%d OVF:%d\\n\",\n\t\t\tcsi2_irqstatus & CSI2_IRQ_OCP_ERR ? 1 : 0,\n\t\t\tcsi2_irqstatus & CSI2_IRQ_SHORT_PACKET ? 1 : 0,\n\t\t\tcsi2_irqstatus & CSI2_IRQ_ECC_NO_CORRECTION ? 1 : 0,\n\t\t\tcsi2_irqstatus & CSI2_IRQ_COMPLEXIO_ERR ? 1 : 0,\n\t\t\tcsi2_irqstatus & CSI2_IRQ_FIFO_OVF ? 1 : 0);\n\t\tpipe->error = true;\n\t}\n\n\t \n\tif (csi2_irqstatus & CSI2_IRQ_CONTEXT0)\n\t\tcsi2_isr_ctx(csi2, &csi2->contexts[0]);\n\n\tif (csi2_irqstatus & CSI2_IRQ_ECC_CORRECTION)\n\t\tdev_dbg(iss->dev, \"CSI2: ECC correction done\\n\");\n}\n\n \n\n \nstatic int csi2_queue(struct iss_video *video, struct iss_buffer *buffer)\n{\n\tstruct iss_csi2_device *csi2 = container_of(video,\n\t\t\t\tstruct iss_csi2_device, video_out);\n\n\tcsi2_set_outaddr(csi2, buffer->iss_addr);\n\n\t \n\tif (csi2->video_out.dmaqueue_flags & ISS_VIDEO_DMAQUEUE_UNDERRUN) {\n\t\t \n\t\tcsi2_if_enable(csi2, 1);\n\t\tcsi2_ctx_enable(csi2, 0, 1);\n\t\tiss_video_dmaqueue_flags_clr(&csi2->video_out);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iss_video_operations csi2_issvideo_ops = {\n\t.queue = csi2_queue,\n};\n\n \n\nstatic struct v4l2_mbus_framefmt *\n__csi2_get_format(struct iss_csi2_device *csi2,\n\t\t  struct v4l2_subdev_state *sd_state,\n\t\t  unsigned int pad,\n\t\t  enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&csi2->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\n\treturn &csi2->formats[pad];\n}\n\nstatic void\ncsi2_try_format(struct iss_csi2_device *csi2,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tunsigned int pad,\n\t\tstruct v4l2_mbus_framefmt *fmt,\n\t\tenum v4l2_subdev_format_whence which)\n{\n\tu32 pixelcode;\n\tstruct v4l2_mbus_framefmt *format;\n\tconst struct iss_format_info *info;\n\tunsigned int i;\n\n\tswitch (pad) {\n\tcase CSI2_PAD_SINK:\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(csi2_input_fmts); i++) {\n\t\t\tif (fmt->code == csi2_input_fmts[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i >= ARRAY_SIZE(csi2_input_fmts))\n\t\t\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\n\t\tfmt->width = clamp_t(u32, fmt->width, 1, 8191);\n\t\tfmt->height = clamp_t(u32, fmt->height, 1, 8191);\n\t\tbreak;\n\n\tcase CSI2_PAD_SOURCE:\n\t\t \n\t\tpixelcode = fmt->code;\n\t\tformat = __csi2_get_format(csi2, sd_state, CSI2_PAD_SINK,\n\t\t\t\t\t   which);\n\t\tmemcpy(fmt, format, sizeof(*fmt));\n\n\t\t \n\t\tinfo = omap4iss_video_format_info(fmt->code);\n\t\tif (info->uncompressed == pixelcode)\n\t\t\tfmt->code = pixelcode;\n\t\tbreak;\n\t}\n\n\t \n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\tfmt->field = V4L2_FIELD_NONE;\n}\n\n \nstatic int csi2_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\tconst struct iss_format_info *info;\n\n\tif (code->pad == CSI2_PAD_SINK) {\n\t\tif (code->index >= ARRAY_SIZE(csi2_input_fmts))\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = csi2_input_fmts[code->index];\n\t} else {\n\t\tformat = __csi2_get_format(csi2, sd_state, CSI2_PAD_SINK,\n\t\t\t\t\t   code->which);\n\t\tswitch (code->index) {\n\t\tcase 0:\n\t\t\t \n\t\t\tcode->code = format->code;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\tinfo = omap4iss_video_format_info(format->code);\n\t\t\tif (info->uncompressed == format->code)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcode->code = info->uncompressed;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int csi2_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt format;\n\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = 1;\n\tformat.height = 1;\n\tcsi2_try_format(csi2, sd_state, fse->pad, &format, fse->which);\n\tfse->min_width = format.width;\n\tfse->min_height = format.height;\n\n\tif (format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = -1;\n\tformat.height = -1;\n\tcsi2_try_format(csi2, sd_state, fse->pad, &format, fse->which);\n\tfse->max_width = format.width;\n\tfse->max_height = format.height;\n\n\treturn 0;\n}\n\n \nstatic int csi2_get_format(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __csi2_get_format(csi2, sd_state, fmt->pad, fmt->which);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\treturn 0;\n}\n\n \nstatic int csi2_set_format(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __csi2_get_format(csi2, sd_state, fmt->pad, fmt->which);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\tcsi2_try_format(csi2, sd_state, fmt->pad, &fmt->format, fmt->which);\n\t*format = fmt->format;\n\n\t \n\tif (fmt->pad == CSI2_PAD_SINK) {\n\t\tformat = __csi2_get_format(csi2, sd_state, CSI2_PAD_SOURCE,\n\t\t\t\t\t   fmt->which);\n\t\t*format = fmt->format;\n\t\tcsi2_try_format(csi2, sd_state, CSI2_PAD_SOURCE, format,\n\t\t\t\tfmt->which);\n\t}\n\n\treturn 0;\n}\n\nstatic int csi2_link_validate(struct v4l2_subdev *sd, struct media_link *link,\n\t\t\t      struct v4l2_subdev_format *source_fmt,\n\t\t\t      struct v4l2_subdev_format *sink_fmt)\n{\n\tstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct iss_pipeline *pipe = to_iss_pipeline(&csi2->subdev.entity);\n\tint rval;\n\n\tpipe->external = media_entity_to_v4l2_subdev(link->source->entity);\n\trval = omap4iss_get_external_info(pipe, link);\n\tif (rval < 0)\n\t\treturn rval;\n\n\treturn v4l2_subdev_link_validate_default(sd, link, source_fmt,\n\t\t\t\t\t\t sink_fmt);\n}\n\n \nstatic int csi2_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_subdev_format format;\n\n\tmemset(&format, 0, sizeof(format));\n\tformat.pad = CSI2_PAD_SINK;\n\tformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\n\tformat.format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\tformat.format.width = 4096;\n\tformat.format.height = 4096;\n\tcsi2_set_format(sd, fh ? fh->state : NULL, &format);\n\n\treturn 0;\n}\n\n \nstatic int csi2_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct iss_device *iss = csi2->iss;\n\tstruct iss_video *video_out = &csi2->video_out;\n\tint ret = 0;\n\n\tif (csi2->state == ISS_PIPELINE_STREAM_STOPPED) {\n\t\tif (enable == ISS_PIPELINE_STREAM_STOPPED)\n\t\t\treturn 0;\n\n\t\tomap4iss_subclk_enable(iss, csi2->subclk);\n\t}\n\n\tswitch (enable) {\n\tcase ISS_PIPELINE_STREAM_CONTINUOUS: {\n\t\tret = omap4iss_csiphy_config(iss, sd);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (omap4iss_csiphy_acquire(csi2->phy) < 0)\n\t\t\treturn -ENODEV;\n\t\tcsi2_configure(csi2);\n\t\tcsi2_print_status(csi2);\n\n\t\t \n\t\tif (csi2->output & CSI2_OUTPUT_MEMORY &&\n\t\t    !(video_out->dmaqueue_flags & ISS_VIDEO_DMAQUEUE_QUEUED))\n\t\t\tbreak;\n\t\t \n\t\tatomic_set(&csi2->stopping, 0);\n\t\tcsi2_ctx_enable(csi2, 0, 1);\n\t\tcsi2_if_enable(csi2, 1);\n\t\tiss_video_dmaqueue_flags_clr(video_out);\n\t\tbreak;\n\t}\n\tcase ISS_PIPELINE_STREAM_STOPPED:\n\t\tif (csi2->state == ISS_PIPELINE_STREAM_STOPPED)\n\t\t\treturn 0;\n\t\tif (omap4iss_module_sync_idle(&sd->entity, &csi2->wait,\n\t\t\t\t\t      &csi2->stopping))\n\t\t\tret = -ETIMEDOUT;\n\t\tcsi2_ctx_enable(csi2, 0, 0);\n\t\tcsi2_if_enable(csi2, 0);\n\t\tcsi2_irq_ctx_set(csi2, 0);\n\t\tomap4iss_csiphy_release(csi2->phy);\n\t\tomap4iss_subclk_disable(iss, csi2->subclk);\n\t\tiss_video_dmaqueue_flags_clr(video_out);\n\t\tbreak;\n\t}\n\n\tcsi2->state = enable;\n\treturn ret;\n}\n\n \nstatic const struct v4l2_subdev_video_ops csi2_video_ops = {\n\t.s_stream = csi2_set_stream,\n};\n\n \nstatic const struct v4l2_subdev_pad_ops csi2_pad_ops = {\n\t.enum_mbus_code = csi2_enum_mbus_code,\n\t.enum_frame_size = csi2_enum_frame_size,\n\t.get_fmt = csi2_get_format,\n\t.set_fmt = csi2_set_format,\n\t.link_validate = csi2_link_validate,\n};\n\n \nstatic const struct v4l2_subdev_ops csi2_ops = {\n\t.video = &csi2_video_ops,\n\t.pad = &csi2_pad_ops,\n};\n\n \nstatic const struct v4l2_subdev_internal_ops csi2_internal_ops = {\n\t.open = csi2_init_formats,\n};\n\n \n\n \nstatic int csi2_link_setup(struct media_entity *entity,\n\t\t\t   const struct media_pad *local,\n\t\t\t   const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct iss_csi2_ctrl_cfg *ctrl = &csi2->ctrl;\n\tunsigned int index = local->index;\n\n\t \n\tif (is_media_entity_v4l2_subdev(remote->entity))\n\t\tindex |= 2 << 16;\n\n\t \n\n\tswitch (index) {\n\tcase CSI2_PAD_SOURCE:\n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (csi2->output & ~CSI2_OUTPUT_MEMORY)\n\t\t\t\treturn -EBUSY;\n\t\t\tcsi2->output |= CSI2_OUTPUT_MEMORY;\n\t\t} else {\n\t\t\tcsi2->output &= ~CSI2_OUTPUT_MEMORY;\n\t\t}\n\t\tbreak;\n\n\tcase CSI2_PAD_SOURCE | 2 << 16:\n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (csi2->output & ~CSI2_OUTPUT_IPIPEIF)\n\t\t\t\treturn -EBUSY;\n\t\t\tcsi2->output |= CSI2_OUTPUT_IPIPEIF;\n\t\t} else {\n\t\t\tcsi2->output &= ~CSI2_OUTPUT_IPIPEIF;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tctrl->vp_only_enable = csi2->output & CSI2_OUTPUT_MEMORY ? false : true;\n\tctrl->vp_clk_enable = !!(csi2->output & CSI2_OUTPUT_IPIPEIF);\n\n\treturn 0;\n}\n\n \nstatic const struct media_entity_operations csi2_media_ops = {\n\t.link_setup = csi2_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nvoid omap4iss_csi2_unregister_entities(struct iss_csi2_device *csi2)\n{\n\tv4l2_device_unregister_subdev(&csi2->subdev);\n\tomap4iss_video_unregister(&csi2->video_out);\n}\n\nint omap4iss_csi2_register_entities(struct iss_csi2_device *csi2,\n\t\t\t\t    struct v4l2_device *vdev)\n{\n\tint ret;\n\n\t \n\tret = v4l2_device_register_subdev(vdev, &csi2->subdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = omap4iss_video_register(&csi2->video_out, vdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tomap4iss_csi2_unregister_entities(csi2);\n\treturn ret;\n}\n\n \n\n \nstatic int csi2_init_entities(struct iss_csi2_device *csi2, const char *subname)\n{\n\tstruct v4l2_subdev *sd = &csi2->subdev;\n\tstruct media_pad *pads = csi2->pads;\n\tstruct media_entity *me = &sd->entity;\n\tint ret;\n\tchar name[V4L2_SUBDEV_NAME_SIZE];\n\n\tv4l2_subdev_init(sd, &csi2_ops);\n\tsd->internal_ops = &csi2_internal_ops;\n\tsnprintf(name, sizeof(name), \"CSI2%s\", subname);\n\tsnprintf(sd->name, sizeof(sd->name), \"OMAP4 ISS %s\", name);\n\n\tsd->grp_id = BIT(16);\t \n\tv4l2_set_subdevdata(sd, csi2);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tpads[CSI2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\tpads[CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\n\tme->ops = &csi2_media_ops;\n\tret = media_entity_pads_init(me, CSI2_PADS_NUM, pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcsi2_init_formats(sd, NULL);\n\n\t \n\tcsi2->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tcsi2->video_out.ops = &csi2_issvideo_ops;\n\tcsi2->video_out.bpl_alignment = 32;\n\tcsi2->video_out.bpl_zero_padding = 1;\n\tcsi2->video_out.bpl_max = 0x1ffe0;\n\tcsi2->video_out.iss = csi2->iss;\n\tcsi2->video_out.capture_mem = PAGE_ALIGN(4096 * 4096) * 3;\n\n\tret = omap4iss_video_init(&csi2->video_out, name);\n\tif (ret < 0)\n\t\tgoto error_video;\n\n\treturn 0;\n\nerror_video:\n\tmedia_entity_cleanup(&csi2->subdev.entity);\n\treturn ret;\n}\n\n \nint omap4iss_csi2_init(struct iss_device *iss)\n{\n\tstruct iss_csi2_device *csi2a = &iss->csi2a;\n\tstruct iss_csi2_device *csi2b = &iss->csi2b;\n\tint ret;\n\n\tcsi2a->iss = iss;\n\tcsi2a->available = 1;\n\tcsi2a->regs1 = OMAP4_ISS_MEM_CSI2_A_REGS1;\n\tcsi2a->phy = &iss->csiphy1;\n\tcsi2a->subclk = OMAP4_ISS_SUBCLK_CSI2_A;\n\tcsi2a->state = ISS_PIPELINE_STREAM_STOPPED;\n\tinit_waitqueue_head(&csi2a->wait);\n\n\tret = csi2_init_entities(csi2a, \"a\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcsi2b->iss = iss;\n\tcsi2b->available = 1;\n\tcsi2b->regs1 = OMAP4_ISS_MEM_CSI2_B_REGS1;\n\tcsi2b->phy = &iss->csiphy2;\n\tcsi2b->subclk = OMAP4_ISS_SUBCLK_CSI2_B;\n\tcsi2b->state = ISS_PIPELINE_STREAM_STOPPED;\n\tinit_waitqueue_head(&csi2b->wait);\n\n\tret = csi2_init_entities(csi2b, \"b\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nint omap4iss_csi2_create_links(struct iss_device *iss)\n{\n\tstruct iss_csi2_device *csi2a = &iss->csi2a;\n\tstruct iss_csi2_device *csi2b = &iss->csi2b;\n\tint ret;\n\n\t \n\tret = media_create_pad_link(&csi2a->subdev.entity, CSI2_PAD_SOURCE,\n\t\t\t\t    &csi2a->video_out.video.entity, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = media_create_pad_link(&csi2b->subdev.entity, CSI2_PAD_SOURCE,\n\t\t\t\t    &csi2b->video_out.video.entity, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nvoid omap4iss_csi2_cleanup(struct iss_device *iss)\n{\n\tstruct iss_csi2_device *csi2a = &iss->csi2a;\n\tstruct iss_csi2_device *csi2b = &iss->csi2b;\n\n\tomap4iss_video_cleanup(&csi2a->video_out);\n\tmedia_entity_cleanup(&csi2a->subdev.entity);\n\n\tomap4iss_video_cleanup(&csi2b->video_out);\n\tmedia_entity_cleanup(&csi2b->subdev.entity);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}