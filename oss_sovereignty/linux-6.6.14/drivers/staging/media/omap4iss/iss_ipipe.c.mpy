{
  "module_name": "iss_ipipe.c",
  "hash_id": "ec84592640785041f5d9a7146ee2a567b5d3acf9b980d1c20ad767f5c1db74e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/omap4iss/iss_ipipe.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#include \"iss.h\"\n#include \"iss_regs.h\"\n#include \"iss_ipipe.h\"\n\nstatic struct v4l2_mbus_framefmt *\n__ipipe_get_format(struct iss_ipipe_device *ipipe,\n\t\t   struct v4l2_subdev_state *sd_state,\n\t\t   unsigned int pad,\n\t\t   enum v4l2_subdev_format_whence which);\n\nstatic const unsigned int ipipe_fmts[] = {\n\tMEDIA_BUS_FMT_SGRBG10_1X10,\n\tMEDIA_BUS_FMT_SRGGB10_1X10,\n\tMEDIA_BUS_FMT_SBGGR10_1X10,\n\tMEDIA_BUS_FMT_SGBRG10_1X10,\n};\n\n \n#define IPIPE_PRINT_REGISTER(iss, name)\\\n\tdev_dbg(iss->dev, \"###IPIPE \" #name \"=0x%08x\\n\", \\\n\t\tiss_reg_read(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_##name))\n\nstatic void ipipe_print_status(struct iss_ipipe_device *ipipe)\n{\n\tstruct iss_device *iss = to_iss_device(ipipe);\n\n\tdev_dbg(iss->dev, \"-------------IPIPE Register dump-------------\\n\");\n\n\tIPIPE_PRINT_REGISTER(iss, SRC_EN);\n\tIPIPE_PRINT_REGISTER(iss, SRC_MODE);\n\tIPIPE_PRINT_REGISTER(iss, SRC_FMT);\n\tIPIPE_PRINT_REGISTER(iss, SRC_COL);\n\tIPIPE_PRINT_REGISTER(iss, SRC_VPS);\n\tIPIPE_PRINT_REGISTER(iss, SRC_VSZ);\n\tIPIPE_PRINT_REGISTER(iss, SRC_HPS);\n\tIPIPE_PRINT_REGISTER(iss, SRC_HSZ);\n\tIPIPE_PRINT_REGISTER(iss, GCK_MMR);\n\tIPIPE_PRINT_REGISTER(iss, YUV_PHS);\n\n\tdev_dbg(iss->dev, \"-----------------------------------------------\\n\");\n}\n\n \nstatic void ipipe_enable(struct iss_ipipe_device *ipipe, u8 enable)\n{\n\tstruct iss_device *iss = to_iss_device(ipipe);\n\n\tiss_reg_update(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_EN,\n\t\t       IPIPE_SRC_EN_EN, enable ? IPIPE_SRC_EN_EN : 0);\n}\n\n \n\nstatic void ipipe_configure(struct iss_ipipe_device *ipipe)\n{\n\tstruct iss_device *iss = to_iss_device(ipipe);\n\tstruct v4l2_mbus_framefmt *format;\n\n\t \n\tformat = &ipipe->formats[IPIPE_PAD_SINK];\n\n\t \n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_FMT,\n\t\t      IPIPE_SRC_FMT_RAW2YUV);\n\n\t \n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_YUV_PHS,\n\t\t      IPIPE_YUV_PHS_LPF);\n\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_VPS, 0);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_HPS, 0);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_VSZ,\n\t\t      (format->height - 2) & IPIPE_SRC_VSZ_MASK);\n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_HSZ,\n\t\t      (format->width - 1) & IPIPE_SRC_HSZ_MASK);\n\n\t \n\tiss_reg_clr(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_MODE,\n\t\t    IPIPE_SRC_MODE_WRT | IPIPE_SRC_MODE_OST);\n\n\t \n\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_COL,\n\t\t      IPIPE_SRC_COL_EE_B | IPIPE_SRC_COL_EO_GB |\n\t\t      IPIPE_SRC_COL_OE_GR | IPIPE_SRC_COL_OO_R);\n\n\t \n\tformat = &ipipe->formats[IPIPE_PAD_SOURCE_VP];\n\t \n}\n\n \n\n \nstatic int ipipe_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct iss_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\n\tstruct iss_device *iss = to_iss_device(ipipe);\n\tint ret = 0;\n\n\tif (ipipe->state == ISS_PIPELINE_STREAM_STOPPED) {\n\t\tif (enable == ISS_PIPELINE_STREAM_STOPPED)\n\t\t\treturn 0;\n\n\t\tomap4iss_isp_subclk_enable(iss, OMAP4_ISS_ISP_SUBCLK_IPIPE);\n\n\t\t \n\t\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_GCK_MMR,\n\t\t\t      IPIPE_GCK_MMR_REG);\n\n\t\t \n\t\tiss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_GCK_PIX,\n\t\t\t      IPIPE_GCK_PIX_G3 | IPIPE_GCK_PIX_G2 |\n\t\t\t      IPIPE_GCK_PIX_G1 | IPIPE_GCK_PIX_G0);\n\t}\n\n\tswitch (enable) {\n\tcase ISS_PIPELINE_STREAM_CONTINUOUS:\n\n\t\tipipe_configure(ipipe);\n\t\tipipe_print_status(ipipe);\n\n\t\tatomic_set(&ipipe->stopping, 0);\n\t\tipipe_enable(ipipe, 1);\n\t\tbreak;\n\n\tcase ISS_PIPELINE_STREAM_STOPPED:\n\t\tif (ipipe->state == ISS_PIPELINE_STREAM_STOPPED)\n\t\t\treturn 0;\n\t\tif (omap4iss_module_sync_idle(&sd->entity, &ipipe->wait,\n\t\t\t\t\t      &ipipe->stopping))\n\t\t\tret = -ETIMEDOUT;\n\n\t\tipipe_enable(ipipe, 0);\n\t\tomap4iss_isp_subclk_disable(iss, OMAP4_ISS_ISP_SUBCLK_IPIPE);\n\t\tbreak;\n\t}\n\n\tipipe->state = enable;\n\treturn ret;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__ipipe_get_format(struct iss_ipipe_device *ipipe,\n\t\t   struct v4l2_subdev_state *sd_state,\n\t\t   unsigned int pad,\n\t\t   enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&ipipe->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\n\treturn &ipipe->formats[pad];\n}\n\n \nstatic void\nipipe_try_format(struct iss_ipipe_device *ipipe,\n\t\t struct v4l2_subdev_state *sd_state,\n\t\t unsigned int pad,\n\t\t struct v4l2_mbus_framefmt *fmt,\n\t\t enum v4l2_subdev_format_whence which)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\tunsigned int width = fmt->width;\n\tunsigned int height = fmt->height;\n\tunsigned int i;\n\n\tswitch (pad) {\n\tcase IPIPE_PAD_SINK:\n\t\tfor (i = 0; i < ARRAY_SIZE(ipipe_fmts); i++) {\n\t\t\tif (fmt->code == ipipe_fmts[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i >= ARRAY_SIZE(ipipe_fmts))\n\t\t\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\n\t\t \n\t\tfmt->width = clamp_t(u32, width, 1, 8192);\n\t\tfmt->height = clamp_t(u32, height, 1, 8192);\n\t\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\t\tbreak;\n\n\tcase IPIPE_PAD_SOURCE_VP:\n\t\tformat = __ipipe_get_format(ipipe, sd_state, IPIPE_PAD_SINK,\n\t\t\t\t\t    which);\n\t\tmemcpy(fmt, format, sizeof(*fmt));\n\n\t\tfmt->code = MEDIA_BUS_FMT_UYVY8_1X16;\n\t\tfmt->width = clamp_t(u32, width, 32, fmt->width);\n\t\tfmt->height = clamp_t(u32, height, 32, fmt->height);\n\t\tfmt->colorspace = V4L2_COLORSPACE_JPEG;\n\t\tbreak;\n\t}\n\n\tfmt->field = V4L2_FIELD_NONE;\n}\n\n \nstatic int ipipe_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tswitch (code->pad) {\n\tcase IPIPE_PAD_SINK:\n\t\tif (code->index >= ARRAY_SIZE(ipipe_fmts))\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = ipipe_fmts[code->index];\n\t\tbreak;\n\n\tcase IPIPE_PAD_SOURCE_VP:\n\t\t \n\t\tif (code->index != 0)\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = MEDIA_BUS_FMT_UYVY8_1X16;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipipe_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct iss_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt format;\n\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = 1;\n\tformat.height = 1;\n\tipipe_try_format(ipipe, sd_state, fse->pad, &format, fse->which);\n\tfse->min_width = format.width;\n\tfse->min_height = format.height;\n\n\tif (format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = -1;\n\tformat.height = -1;\n\tipipe_try_format(ipipe, sd_state, fse->pad, &format, fse->which);\n\tfse->max_width = format.width;\n\tfse->max_height = format.height;\n\n\treturn 0;\n}\n\n \nstatic int ipipe_get_format(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct iss_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __ipipe_get_format(ipipe, sd_state, fmt->pad, fmt->which);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\treturn 0;\n}\n\n \nstatic int ipipe_set_format(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct iss_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __ipipe_get_format(ipipe, sd_state, fmt->pad, fmt->which);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\tipipe_try_format(ipipe, sd_state, fmt->pad, &fmt->format, fmt->which);\n\t*format = fmt->format;\n\n\t \n\tif (fmt->pad == IPIPE_PAD_SINK) {\n\t\tformat = __ipipe_get_format(ipipe, sd_state,\n\t\t\t\t\t    IPIPE_PAD_SOURCE_VP,\n\t\t\t\t\t    fmt->which);\n\t\t*format = fmt->format;\n\t\tipipe_try_format(ipipe, sd_state, IPIPE_PAD_SOURCE_VP, format,\n\t\t\t\t fmt->which);\n\t}\n\n\treturn 0;\n}\n\nstatic int ipipe_link_validate(struct v4l2_subdev *sd, struct media_link *link,\n\t\t\t       struct v4l2_subdev_format *source_fmt,\n\t\t\t       struct v4l2_subdev_format *sink_fmt)\n{\n\t \n\tif (source_fmt->format.width != sink_fmt->format.width ||\n\t    source_fmt->format.height != sink_fmt->format.height)\n\t\treturn -EPIPE;\n\n\tif (source_fmt->format.code != sink_fmt->format.code)\n\t\treturn -EPIPE;\n\n\treturn 0;\n}\n\n \nstatic int ipipe_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_subdev_format format;\n\n\tmemset(&format, 0, sizeof(format));\n\tformat.pad = IPIPE_PAD_SINK;\n\tformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\n\tformat.format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\tformat.format.width = 4096;\n\tformat.format.height = 4096;\n\tipipe_set_format(sd, fh ? fh->state : NULL, &format);\n\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_video_ops ipipe_v4l2_video_ops = {\n\t.s_stream = ipipe_set_stream,\n};\n\n \nstatic const struct v4l2_subdev_pad_ops ipipe_v4l2_pad_ops = {\n\t.enum_mbus_code = ipipe_enum_mbus_code,\n\t.enum_frame_size = ipipe_enum_frame_size,\n\t.get_fmt = ipipe_get_format,\n\t.set_fmt = ipipe_set_format,\n\t.link_validate = ipipe_link_validate,\n};\n\n \nstatic const struct v4l2_subdev_ops ipipe_v4l2_ops = {\n\t.video = &ipipe_v4l2_video_ops,\n\t.pad = &ipipe_v4l2_pad_ops,\n};\n\n \nstatic const struct v4l2_subdev_internal_ops ipipe_v4l2_internal_ops = {\n\t.open = ipipe_init_formats,\n};\n\n \n\n \nstatic int ipipe_link_setup(struct media_entity *entity,\n\t\t\t    const struct media_pad *local,\n\t\t\t    const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct iss_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\n\tstruct iss_device *iss = to_iss_device(ipipe);\n\n\tif (!is_media_entity_v4l2_subdev(remote->entity))\n\t\treturn -EINVAL;\n\n\tswitch (local->index) {\n\tcase IPIPE_PAD_SINK:\n\t\t \n\t\tif (!(flags & MEDIA_LNK_FL_ENABLED)) {\n\t\t\tipipe->input = IPIPE_INPUT_NONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ipipe->input != IPIPE_INPUT_NONE)\n\t\t\treturn -EBUSY;\n\n\t\tif (remote->entity == &iss->ipipeif.subdev.entity)\n\t\t\tipipe->input = IPIPE_INPUT_IPIPEIF;\n\n\t\tbreak;\n\n\tcase IPIPE_PAD_SOURCE_VP:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (ipipe->output & ~IPIPE_OUTPUT_VP)\n\t\t\t\treturn -EBUSY;\n\t\t\tipipe->output |= IPIPE_OUTPUT_VP;\n\t\t} else {\n\t\t\tipipe->output &= ~IPIPE_OUTPUT_VP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct media_entity_operations ipipe_media_ops = {\n\t.link_setup = ipipe_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n \nstatic int ipipe_init_entities(struct iss_ipipe_device *ipipe)\n{\n\tstruct v4l2_subdev *sd = &ipipe->subdev;\n\tstruct media_pad *pads = ipipe->pads;\n\tstruct media_entity *me = &sd->entity;\n\tint ret;\n\n\tipipe->input = IPIPE_INPUT_NONE;\n\n\tv4l2_subdev_init(sd, &ipipe_v4l2_ops);\n\tsd->internal_ops = &ipipe_v4l2_internal_ops;\n\tstrscpy(sd->name, \"OMAP4 ISS ISP IPIPE\", sizeof(sd->name));\n\tsd->grp_id = BIT(16);\t \n\tv4l2_set_subdevdata(sd, ipipe);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tpads[IPIPE_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tpads[IPIPE_PAD_SOURCE_VP].flags = MEDIA_PAD_FL_SOURCE;\n\n\tme->ops = &ipipe_media_ops;\n\tret = media_entity_pads_init(me, IPIPE_PADS_NUM, pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tipipe_init_formats(sd, NULL);\n\n\treturn 0;\n}\n\nvoid omap4iss_ipipe_unregister_entities(struct iss_ipipe_device *ipipe)\n{\n\tv4l2_device_unregister_subdev(&ipipe->subdev);\n}\n\nint omap4iss_ipipe_register_entities(struct iss_ipipe_device *ipipe,\n\t\t\t\t     struct v4l2_device *vdev)\n{\n\tint ret;\n\n\t \n\tret = v4l2_device_register_subdev(vdev, &ipipe->subdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tomap4iss_ipipe_unregister_entities(ipipe);\n\treturn ret;\n}\n\n \n\n \nint omap4iss_ipipe_init(struct iss_device *iss)\n{\n\tstruct iss_ipipe_device *ipipe = &iss->ipipe;\n\n\tipipe->state = ISS_PIPELINE_STREAM_STOPPED;\n\tinit_waitqueue_head(&ipipe->wait);\n\n\treturn ipipe_init_entities(ipipe);\n}\n\n \nvoid omap4iss_ipipe_cleanup(struct iss_device *iss)\n{\n\tstruct iss_ipipe_device *ipipe = &iss->ipipe;\n\n\tmedia_entity_cleanup(&ipipe->subdev.entity);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}