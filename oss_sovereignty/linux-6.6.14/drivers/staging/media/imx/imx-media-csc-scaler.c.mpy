{
  "module_name": "imx-media-csc-scaler.c",
  "hash_id": "042f487a01f759fa46256954fbd93bdc3b4b18691be783cc84f7365a749e1cf6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/imx/imx-media-csc-scaler.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <video/imx-ipu-v3.h>\n#include <video/imx-ipu-image-convert.h>\n\n#include <media/media-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"imx-media.h\"\n\n#define fh_to_ctx(__fh)\tcontainer_of(__fh, struct ipu_csc_scaler_ctx, fh)\n\n#define IMX_CSC_SCALER_NAME \"imx-csc-scaler\"\n\nenum {\n\tV4L2_M2M_SRC = 0,\n\tV4L2_M2M_DST = 1,\n};\n\nstruct ipu_csc_scaler_priv {\n\tstruct imx_media_video_dev\tvdev;\n\n\tstruct v4l2_m2m_dev\t\t*m2m_dev;\n\tstruct device\t\t\t*dev;\n\n\tstruct imx_media_dev\t\t*md;\n\n\tstruct mutex\t\t\tmutex;\t \n};\n\n#define vdev_to_priv(v) container_of(v, struct ipu_csc_scaler_priv, vdev)\n\n \nstruct ipu_csc_scaler_q_data {\n\tstruct v4l2_pix_format\t\tcur_fmt;\n\tstruct v4l2_rect\t\trect;\n};\n\nstruct ipu_csc_scaler_ctx {\n\tstruct ipu_csc_scaler_priv\t*priv;\n\n\tstruct v4l2_fh\t\t\tfh;\n\tstruct ipu_csc_scaler_q_data\tq_data[2];\n\tstruct ipu_image_convert_ctx\t*icc;\n\n\tstruct v4l2_ctrl_handler\tctrl_hdlr;\n\tint\t\t\t\trotate;\n\tbool\t\t\t\thflip;\n\tbool\t\t\t\tvflip;\n\tenum ipu_rotate_mode\t\trot_mode;\n\tunsigned int\t\t\tsequence;\n};\n\nstatic struct ipu_csc_scaler_q_data *get_q_data(struct ipu_csc_scaler_ctx *ctx,\n\t\t\t\t\t\tenum v4l2_buf_type type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn &ctx->q_data[V4L2_M2M_SRC];\n\telse\n\t\treturn &ctx->q_data[V4L2_M2M_DST];\n}\n\n \n\nstatic void job_abort(void *_ctx)\n{\n\tstruct ipu_csc_scaler_ctx *ctx = _ctx;\n\n\tif (ctx->icc)\n\t\tipu_image_convert_abort(ctx->icc);\n}\n\nstatic void ipu_ic_pp_complete(struct ipu_image_convert_run *run, void *_ctx)\n{\n\tstruct ipu_csc_scaler_ctx *ctx = _ctx;\n\tstruct ipu_csc_scaler_priv *priv = ctx->priv;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\n\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, true);\n\n\tsrc_buf->sequence = ctx->sequence++;\n\tdst_buf->sequence = src_buf->sequence;\n\n\tv4l2_m2m_buf_done(src_buf, run->status ? VB2_BUF_STATE_ERROR :\n\t\t\t\t\t\t VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst_buf, run->status ? VB2_BUF_STATE_ERROR :\n\t\t\t\t\t\t VB2_BUF_STATE_DONE);\n\n\tv4l2_m2m_job_finish(priv->m2m_dev, ctx->fh.m2m_ctx);\n\tkfree(run);\n}\n\nstatic void device_run(void *_ctx)\n{\n\tstruct ipu_csc_scaler_ctx *ctx = _ctx;\n\tstruct ipu_csc_scaler_priv *priv = ctx->priv;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct ipu_image_convert_run *run;\n\tint ret;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\trun = kzalloc(sizeof(*run), GFP_KERNEL);\n\tif (!run)\n\t\tgoto err;\n\n\trun->ctx = ctx->icc;\n\trun->in_phys = vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);\n\trun->out_phys = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\n\tret = ipu_image_convert_queue(run);\n\tif (ret < 0) {\n\t\tv4l2_err(ctx->priv->vdev.vfd->v4l2_dev,\n\t\t\t \"%s: failed to queue: %d\\n\", __func__, ret);\n\t\tgoto err;\n\t}\n\n\treturn;\n\nerr:\n\tv4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\n\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\n\tv4l2_m2m_job_finish(priv->m2m_dev, ctx->fh.m2m_ctx);\n}\n\n \nstatic int ipu_csc_scaler_querycap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, IMX_CSC_SCALER_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, IMX_CSC_SCALER_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:%s\", IMX_CSC_SCALER_NAME);\n\n\treturn 0;\n}\n\nstatic int ipu_csc_scaler_enum_fmt(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tu32 fourcc;\n\tint ret;\n\n\tret = imx_media_enum_pixel_formats(&fourcc, f->index,\n\t\t\t\t\t   PIXFMT_SEL_YUV_RGB, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tf->pixelformat = fourcc;\n\n\treturn 0;\n}\n\nstatic int ipu_csc_scaler_g_fmt(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct ipu_csc_scaler_ctx *ctx = fh_to_ctx(priv);\n\tstruct ipu_csc_scaler_q_data *q_data;\n\n\tq_data = get_q_data(ctx, f->type);\n\n\tf->fmt.pix = q_data->cur_fmt;\n\n\treturn 0;\n}\n\nstatic int ipu_csc_scaler_try_fmt(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct ipu_csc_scaler_ctx *ctx = fh_to_ctx(priv);\n\tstruct ipu_csc_scaler_q_data *q_data = get_q_data(ctx, f->type);\n\tstruct ipu_image test_in, test_out;\n\tenum v4l2_field field;\n\n\tfield = f->fmt.pix.field;\n\tif (field == V4L2_FIELD_ANY)\n\t\tfield = V4L2_FIELD_NONE;\n\telse if (field != V4L2_FIELD_NONE)\n\t\treturn -EINVAL;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tstruct ipu_csc_scaler_q_data *q_data_in =\n\t\t\tget_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\n\t\ttest_out.pix = f->fmt.pix;\n\t\ttest_in.pix = q_data_in->cur_fmt;\n\t} else {\n\t\tstruct ipu_csc_scaler_q_data *q_data_out =\n\t\t\tget_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\t\ttest_in.pix = f->fmt.pix;\n\t\ttest_out.pix = q_data_out->cur_fmt;\n\t}\n\n\tipu_image_convert_adjust(&test_in, &test_out, ctx->rot_mode);\n\n\tf->fmt.pix = (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?\n\t\ttest_out.pix : test_in.pix;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tf->fmt.pix.colorspace = q_data->cur_fmt.colorspace;\n\t\tf->fmt.pix.ycbcr_enc = q_data->cur_fmt.ycbcr_enc;\n\t\tf->fmt.pix.xfer_func = q_data->cur_fmt.xfer_func;\n\t\tf->fmt.pix.quantization = q_data->cur_fmt.quantization;\n\t} else if (f->fmt.pix.colorspace == V4L2_COLORSPACE_DEFAULT) {\n\t\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\n\t\tf->fmt.pix.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\t\tf->fmt.pix.xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\t\tf->fmt.pix.quantization = V4L2_QUANTIZATION_DEFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipu_csc_scaler_s_fmt(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct ipu_csc_scaler_q_data *q_data;\n\tstruct ipu_csc_scaler_ctx *ctx = fh_to_ctx(priv);\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(ctx->priv->vdev.vfd->v4l2_dev, \"%s: queue busy\\n\",\n\t\t\t __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tq_data = get_q_data(ctx, f->type);\n\n\tret = ipu_csc_scaler_try_fmt(file, priv, f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tq_data->cur_fmt.width = f->fmt.pix.width;\n\tq_data->cur_fmt.height = f->fmt.pix.height;\n\tq_data->cur_fmt.pixelformat = f->fmt.pix.pixelformat;\n\tq_data->cur_fmt.field = f->fmt.pix.field;\n\tq_data->cur_fmt.bytesperline = f->fmt.pix.bytesperline;\n\tq_data->cur_fmt.sizeimage = f->fmt.pix.sizeimage;\n\n\t \n\tq_data->rect.left = 0;\n\tq_data->rect.top = 0;\n\tq_data->rect.width = q_data->cur_fmt.width;\n\tq_data->rect.height = q_data->cur_fmt.height;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\t \n\t\tq_data->cur_fmt.colorspace = f->fmt.pix.colorspace;\n\t\tq_data->cur_fmt.ycbcr_enc = f->fmt.pix.ycbcr_enc;\n\t\tq_data->cur_fmt.xfer_func = f->fmt.pix.xfer_func;\n\t\tq_data->cur_fmt.quantization = f->fmt.pix.quantization;\n\t\t \n\t\tq_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\tq_data->cur_fmt.colorspace = f->fmt.pix.colorspace;\n\t\tq_data->cur_fmt.ycbcr_enc = f->fmt.pix.ycbcr_enc;\n\t\tq_data->cur_fmt.xfer_func = f->fmt.pix.xfer_func;\n\t\tq_data->cur_fmt.quantization = f->fmt.pix.quantization;\n\t}\n\n\t \n\n\treturn 0;\n}\n\nstatic int ipu_csc_scaler_g_selection(struct file *file, void *priv,\n\t\t\t\t      struct v4l2_selection *s)\n{\n\tstruct ipu_csc_scaler_ctx *ctx = fh_to_ctx(priv);\n\tstruct ipu_csc_scaler_q_data *q_data;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tq_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tq_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (s->target == V4L2_SEL_TGT_CROP ||\n\t    s->target == V4L2_SEL_TGT_COMPOSE) {\n\t\ts->r = q_data->rect;\n\t} else {\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = q_data->cur_fmt.width;\n\t\ts->r.height = q_data->cur_fmt.height;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipu_csc_scaler_s_selection(struct file *file, void *priv,\n\t\t\t\t      struct v4l2_selection *s)\n{\n\tstruct ipu_csc_scaler_ctx *ctx = fh_to_ctx(priv);\n\tstruct ipu_csc_scaler_q_data *q_data;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t    s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, s->type);\n\n\t \n\tif (s->flags & V4L2_SEL_FLAG_GE)\n\t\ts->r.width = round_up(s->r.width, 8);\n\tif (s->flags & V4L2_SEL_FLAG_LE)\n\t\ts->r.width = round_down(s->r.width, 8);\n\ts->r.width = clamp_t(unsigned int, s->r.width, 8,\n\t\t\t     round_down(q_data->cur_fmt.width, 8));\n\ts->r.height = clamp_t(unsigned int, s->r.height, 1,\n\t\t\t      q_data->cur_fmt.height);\n\ts->r.left = clamp_t(unsigned int, s->r.left, 0,\n\t\t\t    q_data->cur_fmt.width - s->r.width);\n\ts->r.top = clamp_t(unsigned int, s->r.top, 0,\n\t\t\t   q_data->cur_fmt.height - s->r.height);\n\n\t \n\tq_data->rect = s->r;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops ipu_csc_scaler_ioctl_ops = {\n\t.vidioc_querycap\t\t= ipu_csc_scaler_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= ipu_csc_scaler_enum_fmt,\n\t.vidioc_g_fmt_vid_cap\t\t= ipu_csc_scaler_g_fmt,\n\t.vidioc_try_fmt_vid_cap\t\t= ipu_csc_scaler_try_fmt,\n\t.vidioc_s_fmt_vid_cap\t\t= ipu_csc_scaler_s_fmt,\n\n\t.vidioc_enum_fmt_vid_out\t= ipu_csc_scaler_enum_fmt,\n\t.vidioc_g_fmt_vid_out\t\t= ipu_csc_scaler_g_fmt,\n\t.vidioc_try_fmt_vid_out\t\t= ipu_csc_scaler_try_fmt,\n\t.vidioc_s_fmt_vid_out\t\t= ipu_csc_scaler_s_fmt,\n\n\t.vidioc_g_selection\t\t= ipu_csc_scaler_g_selection,\n\t.vidioc_s_selection\t\t= ipu_csc_scaler_s_selection,\n\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= v4l2_m2m_ioctl_prepare_buf,\n\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\n \n\nstatic int ipu_csc_scaler_queue_setup(struct vb2_queue *vq,\n\t\t\t\t      unsigned int *nbuffers,\n\t\t\t\t      unsigned int *nplanes,\n\t\t\t\t      unsigned int sizes[],\n\t\t\t\t      struct device *alloc_devs[])\n{\n\tstruct ipu_csc_scaler_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct ipu_csc_scaler_q_data *q_data;\n\tunsigned int size, count = *nbuffers;\n\n\tq_data = get_q_data(ctx, vq->type);\n\n\tsize = q_data->cur_fmt.sizeimage;\n\n\t*nbuffers = count;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\tdev_dbg(ctx->priv->dev, \"get %d buffer(s) of size %d each.\\n\",\n\t\tcount, size);\n\n\treturn 0;\n}\n\nstatic int ipu_csc_scaler_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct ipu_csc_scaler_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct ipu_csc_scaler_q_data *q_data;\n\tunsigned long size;\n\n\tdev_dbg(ctx->priv->dev, \"type: %d\\n\", vq->type);\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\n\t\tif (vbuf->field == V4L2_FIELD_ANY)\n\t\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tif (vbuf->field != V4L2_FIELD_NONE) {\n\t\t\tdev_dbg(ctx->priv->dev, \"%s: field isn't supported\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tq_data = get_q_data(ctx, vq->type);\n\tsize = q_data->cur_fmt.sizeimage;\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdev_dbg(ctx->priv->dev,\n\t\t\t\"%s: data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t__func__, vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, size);\n\n\treturn 0;\n}\n\nstatic void ipu_csc_scaler_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct ipu_csc_scaler_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, to_vb2_v4l2_buffer(vb));\n}\n\nstatic void ipu_image_from_q_data(struct ipu_image *im,\n\t\t\t\t  struct ipu_csc_scaler_q_data *q_data)\n{\n\tstruct v4l2_pix_format *fmt = &q_data->cur_fmt;\n\n\tim->pix = *fmt;\n\tif (fmt->ycbcr_enc == V4L2_YCBCR_ENC_DEFAULT)\n\t\tim->pix.ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);\n\tif (fmt->quantization == V4L2_QUANTIZATION_DEFAULT)\n\t\tim->pix.ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);\n\tim->rect = q_data->rect;\n}\n\nstatic int ipu_csc_scaler_start_streaming(struct vb2_queue *q,\n\t\t\t\t\t  unsigned int count)\n{\n\tconst enum ipu_ic_task ic_task = IC_TASK_POST_PROCESSOR;\n\tstruct ipu_csc_scaler_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct ipu_csc_scaler_priv *priv = ctx->priv;\n\tstruct ipu_soc *ipu = priv->md->ipu[0];\n\tstruct ipu_csc_scaler_q_data *q_data;\n\tstruct vb2_queue *other_q;\n\tstruct ipu_image in, out;\n\n\tother_q = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t  (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?\n\t\t\t\t  V4L2_BUF_TYPE_VIDEO_OUTPUT :\n\t\t\t\t  V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tif (!vb2_is_streaming(other_q))\n\t\treturn 0;\n\n\tif (ctx->icc) {\n\t\tv4l2_warn(ctx->priv->vdev.vfd->v4l2_dev, \"removing old ICC\\n\");\n\t\tipu_image_convert_unprepare(ctx->icc);\n\t}\n\n\tq_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tipu_image_from_q_data(&in, q_data);\n\n\tq_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tipu_image_from_q_data(&out, q_data);\n\n\tctx->icc = ipu_image_convert_prepare(ipu, ic_task, &in, &out,\n\t\t\t\t\t     ctx->rot_mode,\n\t\t\t\t\t     ipu_ic_pp_complete, ctx);\n\tif (IS_ERR(ctx->icc)) {\n\t\tstruct vb2_v4l2_buffer *buf;\n\t\tint ret = PTR_ERR(ctx->icc);\n\n\t\tctx->icc = NULL;\n\t\tv4l2_err(ctx->priv->vdev.vfd->v4l2_dev, \"%s: error %d\\n\",\n\t\t\t __func__, ret);\n\t\twhile ((buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);\n\t\twhile ((buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ipu_csc_scaler_stop_streaming(struct vb2_queue *q)\n{\n\tstruct ipu_csc_scaler_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *buf;\n\n\tif (ctx->icc) {\n\t\tipu_image_convert_unprepare(ctx->icc);\n\t\tctx->icc = NULL;\n\t}\n\n\tctx->sequence = 0;\n\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\twhile ((buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);\n\t} else {\n\t\twhile ((buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic const struct vb2_ops ipu_csc_scaler_qops = {\n\t.queue_setup\t\t= ipu_csc_scaler_queue_setup,\n\t.buf_prepare\t\t= ipu_csc_scaler_buf_prepare,\n\t.buf_queue\t\t= ipu_csc_scaler_buf_queue,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n\t.start_streaming\t= ipu_csc_scaler_start_streaming,\n\t.stop_streaming\t\t= ipu_csc_scaler_stop_streaming,\n};\n\nstatic int ipu_csc_scaler_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t\t     struct vb2_queue *dst_vq)\n{\n\tstruct ipu_csc_scaler_ctx *ctx = priv;\n\tint ret;\n\n\tmemset(src_vq, 0, sizeof(*src_vq));\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->ops = &ipu_csc_scaler_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->priv->mutex;\n\tsrc_vq->dev = ctx->priv->dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(dst_vq, 0, sizeof(*dst_vq));\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->ops = &ipu_csc_scaler_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->priv->mutex;\n\tdst_vq->dev = ctx->priv->dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int ipu_csc_scaler_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ipu_csc_scaler_ctx *ctx = container_of(ctrl->handler,\n\t\t\t\t\t\t      struct ipu_csc_scaler_ctx,\n\t\t\t\t\t\t      ctrl_hdlr);\n\tenum ipu_rotate_mode rot_mode;\n\tint rotate;\n\tbool hflip, vflip;\n\tint ret = 0;\n\n\trotate = ctx->rotate;\n\thflip = ctx->hflip;\n\tvflip = ctx->vflip;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\thflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tvflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_ROTATE:\n\t\trotate = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = ipu_degrees_to_rot_mode(&rot_mode, rotate, hflip, vflip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rot_mode != ctx->rot_mode) {\n\t\tstruct v4l2_pix_format *in_fmt, *out_fmt;\n\t\tstruct ipu_image test_in, test_out;\n\n\t\tin_fmt = &ctx->q_data[V4L2_M2M_SRC].cur_fmt;\n\t\tout_fmt = &ctx->q_data[V4L2_M2M_DST].cur_fmt;\n\n\t\ttest_in.pix = *in_fmt;\n\t\ttest_out.pix = *out_fmt;\n\n\t\tif (ipu_rot_mode_is_irt(rot_mode) !=\n\t\t    ipu_rot_mode_is_irt(ctx->rot_mode)) {\n\t\t\t \n\t\t\ttest_out.pix.width = out_fmt->height;\n\t\t\ttest_out.pix.height = out_fmt->width;\n\t\t}\n\n\t\tipu_image_convert_adjust(&test_in, &test_out, ctx->rot_mode);\n\n\t\t \n\t\tif (test_in.pix.width != in_fmt->width ||\n\t\t    test_in.pix.height != in_fmt->height ||\n\t\t    test_in.pix.bytesperline != in_fmt->bytesperline ||\n\t\t    test_in.pix.sizeimage != in_fmt->sizeimage) {\n\t\t\tstruct vb2_queue *out_q;\n\n\t\t\tout_q = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t\t\tV4L2_BUF_TYPE_VIDEO_OUTPUT);\n\t\t\tif (vb2_is_busy(out_q))\n\t\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\t\tif (test_out.pix.width != out_fmt->width ||\n\t\t    test_out.pix.height != out_fmt->height ||\n\t\t    test_out.pix.bytesperline != out_fmt->bytesperline ||\n\t\t    test_out.pix.sizeimage != out_fmt->sizeimage) {\n\t\t\tstruct vb2_queue *cap_q;\n\n\t\t\tcap_q = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t\t\tV4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\t\tif (vb2_is_busy(cap_q))\n\t\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t*in_fmt = test_in.pix;\n\t\t*out_fmt = test_out.pix;\n\n\t\tctx->rot_mode = rot_mode;\n\t\tctx->rotate = rotate;\n\t\tctx->hflip = hflip;\n\t\tctx->vflip = vflip;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops ipu_csc_scaler_ctrl_ops = {\n\t.s_ctrl = ipu_csc_scaler_s_ctrl,\n};\n\nstatic int ipu_csc_scaler_init_controls(struct ipu_csc_scaler_ctx *ctx)\n{\n\tstruct v4l2_ctrl_handler *hdlr = &ctx->ctrl_hdlr;\n\n\tv4l2_ctrl_handler_init(hdlr, 3);\n\n\tv4l2_ctrl_new_std(hdlr, &ipu_csc_scaler_ctrl_ops, V4L2_CID_HFLIP,\n\t\t\t  0, 1, 1, 0);\n\tv4l2_ctrl_new_std(hdlr, &ipu_csc_scaler_ctrl_ops, V4L2_CID_VFLIP,\n\t\t\t  0, 1, 1, 0);\n\tv4l2_ctrl_new_std(hdlr, &ipu_csc_scaler_ctrl_ops, V4L2_CID_ROTATE,\n\t\t\t  0, 270, 90, 0);\n\n\tif (hdlr->error) {\n\t\tv4l2_ctrl_handler_free(hdlr);\n\t\treturn hdlr->error;\n\t}\n\n\tv4l2_ctrl_handler_setup(hdlr);\n\treturn 0;\n}\n\n#define DEFAULT_WIDTH\t720\n#define DEFAULT_HEIGHT\t576\nstatic const struct ipu_csc_scaler_q_data ipu_csc_scaler_q_data_default = {\n\t.cur_fmt = {\n\t\t.width = DEFAULT_WIDTH,\n\t\t.height = DEFAULT_HEIGHT,\n\t\t.pixelformat = V4L2_PIX_FMT_YUV420,\n\t\t.field = V4L2_FIELD_NONE,\n\t\t.bytesperline = DEFAULT_WIDTH,\n\t\t.sizeimage = DEFAULT_WIDTH * DEFAULT_HEIGHT * 3 / 2,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t},\n\t.rect = {\n\t\t.width = DEFAULT_WIDTH,\n\t\t.height = DEFAULT_HEIGHT,\n\t},\n};\n\n \nstatic int ipu_csc_scaler_open(struct file *file)\n{\n\tstruct ipu_csc_scaler_priv *priv = video_drvdata(file);\n\tstruct ipu_csc_scaler_ctx *ctx = NULL;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->rot_mode = IPU_ROTATE_NONE;\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\tctx->priv = priv;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(priv->m2m_dev, ctx,\n\t\t\t\t\t    &ipu_csc_scaler_queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto err_ctx;\n\t}\n\n\tret = ipu_csc_scaler_init_controls(ctx);\n\tif (ret)\n\t\tgoto err_ctrls;\n\n\tctx->fh.ctrl_handler = &ctx->ctrl_hdlr;\n\n\tctx->q_data[V4L2_M2M_SRC] = ipu_csc_scaler_q_data_default;\n\tctx->q_data[V4L2_M2M_DST] = ipu_csc_scaler_q_data_default;\n\n\tdev_dbg(priv->dev, \"Created instance %p, m2m_ctx: %p\\n\", ctx,\n\t\tctx->fh.m2m_ctx);\n\n\treturn 0;\n\nerr_ctrls:\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\nerr_ctx:\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic int ipu_csc_scaler_release(struct file *file)\n{\n\tstruct ipu_csc_scaler_priv *priv = video_drvdata(file);\n\tstruct ipu_csc_scaler_ctx *ctx = fh_to_ctx(file->private_data);\n\n\tdev_dbg(priv->dev, \"Releasing instance %p\\n\", ctx);\n\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations ipu_csc_scaler_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ipu_csc_scaler_open,\n\t.release\t= ipu_csc_scaler_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct v4l2_m2m_ops m2m_ops = {\n\t.device_run\t= device_run,\n\t.job_abort\t= job_abort,\n};\n\nstatic void ipu_csc_scaler_video_device_release(struct video_device *vdev)\n{\n\tstruct ipu_csc_scaler_priv *priv = video_get_drvdata(vdev);\n\n\tv4l2_m2m_release(priv->m2m_dev);\n\tvideo_device_release(vdev);\n\tkfree(priv);\n}\n\nstatic const struct video_device ipu_csc_scaler_videodev_template = {\n\t.name\t\t= \"ipu_ic_pp csc/scaler\",\n\t.fops\t\t= &ipu_csc_scaler_fops,\n\t.ioctl_ops\t= &ipu_csc_scaler_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= ipu_csc_scaler_video_device_release,\n\t.vfl_dir\t= VFL_DIR_M2M,\n\t.device_caps\t= V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING,\n};\n\nint imx_media_csc_scaler_device_register(struct imx_media_video_dev *vdev)\n{\n\tstruct ipu_csc_scaler_priv *priv = vdev_to_priv(vdev);\n\tstruct video_device *vfd = vdev->vfd;\n\tint ret;\n\n\tvfd->v4l2_dev = &priv->md->v4l2_dev;\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tv4l2_err(vfd->v4l2_dev, \"Failed to register video device\\n\");\n\t\treturn ret;\n\t}\n\n\tv4l2_info(vfd->v4l2_dev, \"Registered %s as /dev/%s\\n\", vfd->name,\n\t\t  video_device_node_name(vfd));\n\n\treturn 0;\n}\n\nvoid imx_media_csc_scaler_device_unregister(struct imx_media_video_dev *vdev)\n{\n\tstruct ipu_csc_scaler_priv *priv = vdev_to_priv(vdev);\n\tstruct video_device *vfd = priv->vdev.vfd;\n\n\tvideo_unregister_device(vfd);\n}\n\nstruct imx_media_video_dev *\nimx_media_csc_scaler_device_init(struct imx_media_dev *md)\n{\n\tstruct ipu_csc_scaler_priv *priv;\n\tstruct video_device *vfd;\n\tint ret;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpriv->md = md;\n\tpriv->dev = md->md.dev;\n\n\tmutex_init(&priv->mutex);\n\n\tvfd = video_device_alloc();\n\tif (!vfd) {\n\t\tret = -ENOMEM;\n\t\tgoto err_vfd;\n\t}\n\n\t*vfd = ipu_csc_scaler_videodev_template;\n\tvfd->lock = &priv->mutex;\n\tpriv->vdev.vfd = vfd;\n\n\tINIT_LIST_HEAD(&priv->vdev.list);\n\n\tvideo_set_drvdata(vfd, priv);\n\n\tpriv->m2m_dev = v4l2_m2m_init(&m2m_ops);\n\tif (IS_ERR(priv->m2m_dev)) {\n\t\tret = PTR_ERR(priv->m2m_dev);\n\t\tv4l2_err(&md->v4l2_dev, \"Failed to init mem2mem device: %d\\n\",\n\t\t\t ret);\n\t\tgoto err_m2m;\n\t}\n\n\treturn &priv->vdev;\n\nerr_m2m:\n\tvideo_set_drvdata(vfd, NULL);\nerr_vfd:\n\tkfree(priv);\n\treturn ERR_PTR(ret);\n}\n\nMODULE_DESCRIPTION(\"i.MX IPUv3 mem2mem scaler/CSC driver\");\nMODULE_AUTHOR(\"Sascha Hauer <s.hauer@pengutronix.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}