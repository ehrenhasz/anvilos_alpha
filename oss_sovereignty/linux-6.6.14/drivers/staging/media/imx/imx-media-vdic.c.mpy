{
  "module_name": "imx-media-vdic.c",
  "hash_id": "43d421053f489b33fa5f0baebfa3152bc8281a0ca13bd52917670cb0ed093aef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/imx/imx-media-vdic.c",
  "human_readable_source": "\n \n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-subdev.h>\n#include <media/imx.h>\n#include \"imx-media.h\"\n\n \n\nstruct vdic_priv;\n\nstruct vdic_pipeline_ops {\n\tint (*setup)(struct vdic_priv *priv);\n\tvoid (*start)(struct vdic_priv *priv);\n\tvoid (*stop)(struct vdic_priv *priv);\n\tvoid (*disable)(struct vdic_priv *priv);\n};\n\n \n#define MIN_W        32\n#define MIN_H        32\n#define MAX_W_VDIC  968\n#define MAX_H_VDIC 2048\n#define W_ALIGN    4  \n#define H_ALIGN    1  \n#define S_ALIGN    1  \n\nstruct vdic_priv {\n\tstruct device *ipu_dev;\n\tstruct ipu_soc *ipu;\n\n\tstruct v4l2_subdev   sd;\n\tstruct media_pad pad[VDIC_NUM_PADS];\n\n\t \n\tstruct mutex lock;\n\n\t \n\tstruct ipu_vdi *vdi;\n\n\tint active_input_pad;\n\n\tstruct ipuv3_channel *vdi_in_ch_p;  \n\tstruct ipuv3_channel *vdi_in_ch;    \n\tstruct ipuv3_channel *vdi_in_ch_n;  \n\n\t \n\tstruct vdic_pipeline_ops *ops;\n\n\t \n\tstruct imx_media_buffer *curr_in_buf;\n\tstruct imx_media_buffer *prev_in_buf;\n\n\t \n\tu32 fieldtype;\n\tu32 in_stride;\n\tu32 field_size;\n\n\t \n\tstruct media_entity *src;\n\t \n\tstruct v4l2_subdev *sink_sd;\n\n\tstruct v4l2_mbus_framefmt format_mbus[VDIC_NUM_PADS];\n\tconst struct imx_media_pixfmt *cc[VDIC_NUM_PADS];\n\tstruct v4l2_fract frame_interval[VDIC_NUM_PADS];\n\n\t \n\tstruct imx_media_video_dev *vdev;\n\n\tbool csi_direct;   \n\n\t \n\tstruct v4l2_ctrl_handler ctrl_hdlr;\n\tenum ipu_motion_sel motion;\n\n\tint stream_count;\n};\n\nstatic void vdic_put_ipu_resources(struct vdic_priv *priv)\n{\n\tif (priv->vdi_in_ch_p)\n\t\tipu_idmac_put(priv->vdi_in_ch_p);\n\tpriv->vdi_in_ch_p = NULL;\n\n\tif (priv->vdi_in_ch)\n\t\tipu_idmac_put(priv->vdi_in_ch);\n\tpriv->vdi_in_ch = NULL;\n\n\tif (priv->vdi_in_ch_n)\n\t\tipu_idmac_put(priv->vdi_in_ch_n);\n\tpriv->vdi_in_ch_n = NULL;\n\n\tif (!IS_ERR_OR_NULL(priv->vdi))\n\t\tipu_vdi_put(priv->vdi);\n\tpriv->vdi = NULL;\n}\n\nstatic int vdic_get_ipu_resources(struct vdic_priv *priv)\n{\n\tint ret, err_chan;\n\tstruct ipuv3_channel *ch;\n\tstruct ipu_vdi *vdi;\n\n\tvdi = ipu_vdi_get(priv->ipu);\n\tif (IS_ERR(vdi)) {\n\t\tv4l2_err(&priv->sd, \"failed to get VDIC\\n\");\n\t\tret = PTR_ERR(vdi);\n\t\tgoto out;\n\t}\n\tpriv->vdi = vdi;\n\n\tif (!priv->csi_direct) {\n\t\tch = ipu_idmac_get(priv->ipu, IPUV3_CHANNEL_MEM_VDI_PREV);\n\t\tif (IS_ERR(ch)) {\n\t\t\terr_chan = IPUV3_CHANNEL_MEM_VDI_PREV;\n\t\t\tret = PTR_ERR(ch);\n\t\t\tgoto out_err_chan;\n\t\t}\n\t\tpriv->vdi_in_ch_p = ch;\n\n\t\tch = ipu_idmac_get(priv->ipu, IPUV3_CHANNEL_MEM_VDI_CUR);\n\t\tif (IS_ERR(ch)) {\n\t\t\terr_chan = IPUV3_CHANNEL_MEM_VDI_CUR;\n\t\t\tret = PTR_ERR(ch);\n\t\t\tgoto out_err_chan;\n\t\t}\n\t\tpriv->vdi_in_ch = ch;\n\n\t\tch = ipu_idmac_get(priv->ipu, IPUV3_CHANNEL_MEM_VDI_NEXT);\n\t\tif (IS_ERR(ch)) {\n\t\t\terr_chan = IPUV3_CHANNEL_MEM_VDI_NEXT;\n\t\t\tret = PTR_ERR(ch);\n\t\t\tgoto out_err_chan;\n\t\t}\n\t\tpriv->vdi_in_ch_n = ch;\n\t}\n\n\treturn 0;\n\nout_err_chan:\n\tv4l2_err(&priv->sd, \"could not get IDMAC channel %u\\n\", err_chan);\nout:\n\tvdic_put_ipu_resources(priv);\n\treturn ret;\n}\n\n \nstatic void __maybe_unused prepare_vdi_in_buffers(struct vdic_priv *priv,\n\t\t\t\t\t\t  struct imx_media_buffer *curr)\n{\n\tdma_addr_t prev_phys, curr_phys, next_phys;\n\tstruct imx_media_buffer *prev;\n\tstruct vb2_buffer *curr_vb, *prev_vb;\n\tu32 fs = priv->field_size;\n\tu32 is = priv->in_stride;\n\n\t \n\tpriv->prev_in_buf = priv->curr_in_buf;\n\tpriv->curr_in_buf = curr;\n\tprev = priv->prev_in_buf ? priv->prev_in_buf : curr;\n\n\tprev_vb = &prev->vbuf.vb2_buf;\n\tcurr_vb = &curr->vbuf.vb2_buf;\n\n\tswitch (priv->fieldtype) {\n\tcase V4L2_FIELD_SEQ_TB:\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tprev_phys = vb2_dma_contig_plane_dma_addr(prev_vb, 0) + fs;\n\t\tcurr_phys = vb2_dma_contig_plane_dma_addr(curr_vb, 0);\n\t\tnext_phys = vb2_dma_contig_plane_dma_addr(curr_vb, 0) + fs;\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED_TB:\n\tcase V4L2_FIELD_INTERLACED_BT:\n\tcase V4L2_FIELD_INTERLACED:\n\t\tprev_phys = vb2_dma_contig_plane_dma_addr(prev_vb, 0) + is;\n\t\tcurr_phys = vb2_dma_contig_plane_dma_addr(curr_vb, 0);\n\t\tnext_phys = vb2_dma_contig_plane_dma_addr(curr_vb, 0) + is;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\tipu_cpmem_set_buffer(priv->vdi_in_ch_p, 0, prev_phys);\n\tipu_cpmem_set_buffer(priv->vdi_in_ch,   0, curr_phys);\n\tipu_cpmem_set_buffer(priv->vdi_in_ch_n, 0, next_phys);\n\n\tipu_idmac_select_buffer(priv->vdi_in_ch_p, 0);\n\tipu_idmac_select_buffer(priv->vdi_in_ch, 0);\n\tipu_idmac_select_buffer(priv->vdi_in_ch_n, 0);\n}\n\nstatic int setup_vdi_channel(struct vdic_priv *priv,\n\t\t\t     struct ipuv3_channel *channel,\n\t\t\t     dma_addr_t phys0, dma_addr_t phys1)\n{\n\tstruct imx_media_video_dev *vdev = priv->vdev;\n\tunsigned int burst_size;\n\tstruct ipu_image image;\n\tint ret;\n\n\tipu_cpmem_zero(channel);\n\n\tmemset(&image, 0, sizeof(image));\n\timage.pix = vdev->fmt;\n\timage.rect = vdev->compose;\n\t \n\timage.pix.height /= 2;\n\timage.rect.height /= 2;\n\timage.phys0 = phys0;\n\timage.phys1 = phys1;\n\n\tret = ipu_cpmem_set_image(channel, &image);\n\tif (ret)\n\t\treturn ret;\n\n\tburst_size = (image.pix.width & 0xf) ? 8 : 16;\n\tipu_cpmem_set_burstsize(channel, burst_size);\n\n\tipu_cpmem_set_axi_id(channel, 1);\n\n\tipu_idmac_set_double_buffer(channel, false);\n\n\treturn 0;\n}\n\nstatic int vdic_setup_direct(struct vdic_priv *priv)\n{\n\t \n\tipu_fsu_link(priv->ipu, IPUV3_CHANNEL_CSI_DIRECT,\n\t\t     IPUV3_CHANNEL_CSI_VDI_PREV);\n\n\treturn 0;\n}\n\nstatic void vdic_start_direct(struct vdic_priv *priv)\n{\n}\n\nstatic void vdic_stop_direct(struct vdic_priv *priv)\n{\n}\n\nstatic void vdic_disable_direct(struct vdic_priv *priv)\n{\n\tipu_fsu_unlink(priv->ipu, IPUV3_CHANNEL_CSI_DIRECT,\n\t\t       IPUV3_CHANNEL_CSI_VDI_PREV);\n}\n\nstatic int vdic_setup_indirect(struct vdic_priv *priv)\n{\n\tstruct v4l2_mbus_framefmt *infmt;\n\tconst struct imx_media_pixfmt *incc;\n\tint in_size, ret;\n\n\tinfmt = &priv->format_mbus[VDIC_SINK_PAD_IDMAC];\n\tincc = priv->cc[VDIC_SINK_PAD_IDMAC];\n\n\tin_size = (infmt->width * incc->bpp * infmt->height) >> 3;\n\n\t \n\tpriv->field_size = in_size / 2;\n\tpriv->in_stride = incc->planar ?\n\t\tinfmt->width : (infmt->width * incc->bpp) >> 3;\n\n\tpriv->prev_in_buf = NULL;\n\tpriv->curr_in_buf = NULL;\n\n\tpriv->fieldtype = infmt->field;\n\n\t \n\tret = setup_vdi_channel(priv, priv->vdi_in_ch_p, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\tret = setup_vdi_channel(priv, priv->vdi_in_ch, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\treturn setup_vdi_channel(priv, priv->vdi_in_ch_n, 0, 0);\n}\n\nstatic void vdic_start_indirect(struct vdic_priv *priv)\n{\n\t \n\tipu_idmac_enable_channel(priv->vdi_in_ch_p);\n\tipu_idmac_enable_channel(priv->vdi_in_ch);\n\tipu_idmac_enable_channel(priv->vdi_in_ch_n);\n}\n\nstatic void vdic_stop_indirect(struct vdic_priv *priv)\n{\n\t \n\tipu_idmac_disable_channel(priv->vdi_in_ch_p);\n\tipu_idmac_disable_channel(priv->vdi_in_ch);\n\tipu_idmac_disable_channel(priv->vdi_in_ch_n);\n}\n\nstatic void vdic_disable_indirect(struct vdic_priv *priv)\n{\n}\n\nstatic struct vdic_pipeline_ops direct_ops = {\n\t.setup = vdic_setup_direct,\n\t.start = vdic_start_direct,\n\t.stop = vdic_stop_direct,\n\t.disable = vdic_disable_direct,\n};\n\nstatic struct vdic_pipeline_ops indirect_ops = {\n\t.setup = vdic_setup_indirect,\n\t.start = vdic_start_indirect,\n\t.stop = vdic_stop_indirect,\n\t.disable = vdic_disable_indirect,\n};\n\nstatic int vdic_start(struct vdic_priv *priv)\n{\n\tstruct v4l2_mbus_framefmt *infmt;\n\tint ret;\n\n\tinfmt = &priv->format_mbus[priv->active_input_pad];\n\n\tpriv->ops = priv->csi_direct ? &direct_ops : &indirect_ops;\n\n\tret = vdic_get_ipu_resources(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tipu_vdi_setup(priv->vdi, MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t      infmt->width, infmt->height);\n\tipu_vdi_set_field_order(priv->vdi, V4L2_STD_UNKNOWN, infmt->field);\n\tipu_vdi_set_motion(priv->vdi, priv->motion);\n\n\tret = priv->ops->setup(priv);\n\tif (ret)\n\t\tgoto out_put_ipu;\n\n\tipu_vdi_enable(priv->vdi);\n\n\tpriv->ops->start(priv);\n\n\treturn 0;\n\nout_put_ipu:\n\tvdic_put_ipu_resources(priv);\n\treturn ret;\n}\n\nstatic void vdic_stop(struct vdic_priv *priv)\n{\n\tpriv->ops->stop(priv);\n\tipu_vdi_disable(priv->vdi);\n\tpriv->ops->disable(priv);\n\n\tvdic_put_ipu_resources(priv);\n}\n\n \n\nstatic int vdic_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vdic_priv *priv = container_of(ctrl->handler,\n\t\t\t\t\t      struct vdic_priv, ctrl_hdlr);\n\tenum ipu_motion_sel motion;\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_DEINTERLACING_MODE:\n\t\tmotion = ctrl->val;\n\t\tif (motion != priv->motion) {\n\t\t\t \n\t\t\tif (priv->stream_count > 0) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpriv->motion = motion;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tv4l2_err(&priv->sd, \"Invalid control\\n\");\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops vdic_ctrl_ops = {\n\t.s_ctrl = vdic_s_ctrl,\n};\n\nstatic const char * const vdic_ctrl_motion_menu[] = {\n\t\"No Motion Compensation\",\n\t\"Low Motion\",\n\t\"Medium Motion\",\n\t\"High Motion\",\n};\n\nstatic int vdic_init_controls(struct vdic_priv *priv)\n{\n\tstruct v4l2_ctrl_handler *hdlr = &priv->ctrl_hdlr;\n\tint ret;\n\n\tv4l2_ctrl_handler_init(hdlr, 1);\n\n\tv4l2_ctrl_new_std_menu_items(hdlr, &vdic_ctrl_ops,\n\t\t\t\t     V4L2_CID_DEINTERLACING_MODE,\n\t\t\t\t     HIGH_MOTION, 0, HIGH_MOTION,\n\t\t\t\t     vdic_ctrl_motion_menu);\n\n\tpriv->sd.ctrl_handler = hdlr;\n\n\tif (hdlr->error) {\n\t\tret = hdlr->error;\n\t\tgoto out_free;\n\t}\n\n\tv4l2_ctrl_handler_setup(hdlr);\n\treturn 0;\n\nout_free:\n\tv4l2_ctrl_handler_free(hdlr);\n\treturn ret;\n}\n\nstatic int vdic_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct vdic_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_subdev *src_sd = NULL;\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tif (!priv->src || !priv->sink_sd) {\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tif (priv->csi_direct)\n\t\tsrc_sd = media_entity_to_v4l2_subdev(priv->src);\n\n\t \n\tif (priv->stream_count != !enable)\n\t\tgoto update_count;\n\n\tdev_dbg(priv->ipu_dev, \"%s: stream %s\\n\", sd->name,\n\t\tenable ? \"ON\" : \"OFF\");\n\n\tif (enable)\n\t\tret = vdic_start(priv);\n\telse\n\t\tvdic_stop(priv);\n\tif (ret)\n\t\tgoto out;\n\n\tif (src_sd) {\n\t\t \n\t\tret = v4l2_subdev_call(src_sd, video, s_stream, enable);\n\t\tret = (ret && ret != -ENOIOCTLCMD) ? ret : 0;\n\t\tif (ret) {\n\t\t\tif (enable)\n\t\t\t\tvdic_stop(priv);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nupdate_count:\n\tpriv->stream_count += enable ? 1 : -1;\n\tif (priv->stream_count < 0)\n\t\tpriv->stream_count = 0;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__vdic_get_fmt(struct vdic_priv *priv, struct v4l2_subdev_state *sd_state,\n\t       unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&priv->sd, sd_state, pad);\n\telse\n\t\treturn &priv->format_mbus[pad];\n}\n\nstatic int vdic_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad >= VDIC_NUM_PADS)\n\t\treturn -EINVAL;\n\n\treturn imx_media_enum_ipu_formats(&code->code, code->index,\n\t\t\t\t\t  PIXFMT_SEL_YUV);\n}\n\nstatic int vdic_get_fmt(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tstruct v4l2_subdev_format *sdformat)\n{\n\tstruct vdic_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\tint ret = 0;\n\n\tif (sdformat->pad >= VDIC_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\tfmt = __vdic_get_fmt(priv, sd_state, sdformat->pad, sdformat->which);\n\tif (!fmt) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsdformat->format = *fmt;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic void vdic_try_fmt(struct vdic_priv *priv,\n\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t struct v4l2_subdev_format *sdformat,\n\t\t\t const struct imx_media_pixfmt **cc)\n{\n\tstruct v4l2_mbus_framefmt *infmt;\n\n\t*cc = imx_media_find_ipu_format(sdformat->format.code,\n\t\t\t\t\tPIXFMT_SEL_YUV);\n\tif (!*cc) {\n\t\tu32 code;\n\n\t\timx_media_enum_ipu_formats(&code, 0, PIXFMT_SEL_YUV);\n\t\t*cc = imx_media_find_ipu_format(code, PIXFMT_SEL_YUV);\n\t\tsdformat->format.code = (*cc)->codes[0];\n\t}\n\n\tinfmt = __vdic_get_fmt(priv, sd_state, priv->active_input_pad,\n\t\t\t       sdformat->which);\n\n\tswitch (sdformat->pad) {\n\tcase VDIC_SRC_PAD_DIRECT:\n\t\tsdformat->format = *infmt;\n\t\t \n\t\tsdformat->format.field = V4L2_FIELD_NONE;\n\t\tbreak;\n\tcase VDIC_SINK_PAD_DIRECT:\n\tcase VDIC_SINK_PAD_IDMAC:\n\t\tv4l_bound_align_image(&sdformat->format.width,\n\t\t\t\t      MIN_W, MAX_W_VDIC, W_ALIGN,\n\t\t\t\t      &sdformat->format.height,\n\t\t\t\t      MIN_H, MAX_H_VDIC, H_ALIGN, S_ALIGN);\n\n\t\t \n\t\tif (!V4L2_FIELD_HAS_BOTH(sdformat->format.field))\n\t\t\tsdformat->format.field = V4L2_FIELD_SEQ_TB;\n\t\tbreak;\n\t}\n\n\timx_media_try_colorimetry(&sdformat->format, true);\n}\n\nstatic int vdic_set_fmt(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tstruct v4l2_subdev_format *sdformat)\n{\n\tstruct vdic_priv *priv = v4l2_get_subdevdata(sd);\n\tconst struct imx_media_pixfmt *cc;\n\tstruct v4l2_mbus_framefmt *fmt;\n\tint ret = 0;\n\n\tif (sdformat->pad >= VDIC_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->stream_count > 0) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tvdic_try_fmt(priv, sd_state, sdformat, &cc);\n\n\tfmt = __vdic_get_fmt(priv, sd_state, sdformat->pad, sdformat->which);\n\t*fmt = sdformat->format;\n\n\t \n\tif (sdformat->pad == VDIC_SINK_PAD_DIRECT ||\n\t    sdformat->pad == VDIC_SINK_PAD_IDMAC) {\n\t\tconst struct imx_media_pixfmt *outcc;\n\t\tstruct v4l2_mbus_framefmt *outfmt;\n\t\tstruct v4l2_subdev_format format;\n\n\t\tformat.pad = VDIC_SRC_PAD_DIRECT;\n\t\tformat.which = sdformat->which;\n\t\tformat.format = sdformat->format;\n\t\tvdic_try_fmt(priv, sd_state, &format, &outcc);\n\n\t\toutfmt = __vdic_get_fmt(priv, sd_state, VDIC_SRC_PAD_DIRECT,\n\t\t\t\t\tsdformat->which);\n\t\t*outfmt = format.format;\n\t\tif (sdformat->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\t\tpriv->cc[VDIC_SRC_PAD_DIRECT] = outcc;\n\t}\n\n\tif (sdformat->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\tpriv->cc[sdformat->pad] = cc;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int vdic_link_setup(struct media_entity *entity,\n\t\t\t    const struct media_pad *local,\n\t\t\t    const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct vdic_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_subdev *remote_sd;\n\tint ret = 0;\n\n\tdev_dbg(priv->ipu_dev, \"%s: link setup %s -> %s\",\n\t\tsd->name, remote->entity->name, local->entity->name);\n\n\tmutex_lock(&priv->lock);\n\n\tif (local->flags & MEDIA_PAD_FL_SOURCE) {\n\t\tif (!is_media_entity_v4l2_subdev(remote->entity)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tremote_sd = media_entity_to_v4l2_subdev(remote->entity);\n\n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (priv->sink_sd) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpriv->sink_sd = remote_sd;\n\t\t} else {\n\t\t\tpriv->sink_sd = NULL;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\tif (priv->src) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpriv->src = NULL;\n\t\tgoto out;\n\t}\n\n\tif (local->index == VDIC_SINK_PAD_IDMAC) {\n\t\tstruct imx_media_video_dev *vdev = priv->vdev;\n\n\t\tif (!is_media_entity_v4l2_video_device(remote->entity)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!vdev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpriv->csi_direct = false;\n\t} else {\n\t\tif (!is_media_entity_v4l2_subdev(remote->entity)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tremote_sd = media_entity_to_v4l2_subdev(remote->entity);\n\n\t\t \n\t\tif (!(remote_sd->grp_id & IMX_MEDIA_GRP_ID_IPU_CSI) ||\n\t\t    remote->index != CSI_SRC_PAD_DIRECT) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpriv->csi_direct = true;\n\t}\n\n\tpriv->src = remote->entity;\n\t \n\tpriv->active_input_pad = local->index;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int vdic_link_validate(struct v4l2_subdev *sd,\n\t\t\t      struct media_link *link,\n\t\t\t      struct v4l2_subdev_format *source_fmt,\n\t\t\t      struct v4l2_subdev_format *sink_fmt)\n{\n\tstruct vdic_priv *priv = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tret = v4l2_subdev_link_validate_default(sd, link,\n\t\t\t\t\t\tsource_fmt, sink_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->csi_direct && priv->motion != HIGH_MOTION) {\n\t\tv4l2_err(&priv->sd,\n\t\t\t \"direct CSI pipeline requires high motion\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int vdic_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_frame_interval *fi)\n{\n\tstruct vdic_priv *priv = v4l2_get_subdevdata(sd);\n\n\tif (fi->pad >= VDIC_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\tfi->interval = priv->frame_interval[fi->pad];\n\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int vdic_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_frame_interval *fi)\n{\n\tstruct vdic_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_fract *input_fi, *output_fi;\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tinput_fi = &priv->frame_interval[priv->active_input_pad];\n\toutput_fi = &priv->frame_interval[VDIC_SRC_PAD_DIRECT];\n\n\tswitch (fi->pad) {\n\tcase VDIC_SINK_PAD_DIRECT:\n\tcase VDIC_SINK_PAD_IDMAC:\n\t\t \n\t\tif (fi->interval.numerator == 0 ||\n\t\t    fi->interval.denominator == 0)\n\t\t\tfi->interval = priv->frame_interval[fi->pad];\n\t\t \n\t\t*output_fi = fi->interval;\n\t\tif (priv->csi_direct)\n\t\t\toutput_fi->denominator *= 2;\n\t\tbreak;\n\tcase VDIC_SRC_PAD_DIRECT:\n\t\t \n\t\tfi->interval = *input_fi;\n\t\tif (priv->csi_direct)\n\t\t\tfi->interval.denominator *= 2;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->frame_interval[fi->pad] = fi->interval;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int vdic_registered(struct v4l2_subdev *sd)\n{\n\tstruct vdic_priv *priv = v4l2_get_subdevdata(sd);\n\tint i, ret;\n\tu32 code;\n\n\tfor (i = 0; i < VDIC_NUM_PADS; i++) {\n\t\tcode = 0;\n\t\tif (i != VDIC_SINK_PAD_IDMAC)\n\t\t\timx_media_enum_ipu_formats(&code, 0, PIXFMT_SEL_YUV);\n\n\t\t \n\t\tret = imx_media_init_mbus_fmt(&priv->format_mbus[i],\n\t\t\t\t\t      IMX_MEDIA_DEF_PIX_WIDTH,\n\t\t\t\t\t      IMX_MEDIA_DEF_PIX_HEIGHT, code,\n\t\t\t\t\t      V4L2_FIELD_NONE, &priv->cc[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tpriv->frame_interval[i].numerator = 1;\n\t\tpriv->frame_interval[i].denominator = 30;\n\t\tif (i == VDIC_SRC_PAD_DIRECT)\n\t\t\tpriv->frame_interval[i].denominator *= 2;\n\t}\n\n\tpriv->active_input_pad = VDIC_SINK_PAD_DIRECT;\n\n\treturn vdic_init_controls(priv);\n}\n\nstatic void vdic_unregistered(struct v4l2_subdev *sd)\n{\n\tstruct vdic_priv *priv = v4l2_get_subdevdata(sd);\n\n\tv4l2_ctrl_handler_free(&priv->ctrl_hdlr);\n}\n\nstatic const struct v4l2_subdev_pad_ops vdic_pad_ops = {\n\t.init_cfg = imx_media_init_cfg,\n\t.enum_mbus_code = vdic_enum_mbus_code,\n\t.get_fmt = vdic_get_fmt,\n\t.set_fmt = vdic_set_fmt,\n\t.link_validate = vdic_link_validate,\n};\n\nstatic const struct v4l2_subdev_video_ops vdic_video_ops = {\n\t.g_frame_interval = vdic_g_frame_interval,\n\t.s_frame_interval = vdic_s_frame_interval,\n\t.s_stream = vdic_s_stream,\n};\n\nstatic const struct media_entity_operations vdic_entity_ops = {\n\t.link_setup = vdic_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic const struct v4l2_subdev_ops vdic_subdev_ops = {\n\t.video = &vdic_video_ops,\n\t.pad = &vdic_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops vdic_internal_ops = {\n\t.registered = vdic_registered,\n\t.unregistered = vdic_unregistered,\n};\n\nstruct v4l2_subdev *imx_media_vdic_register(struct v4l2_device *v4l2_dev,\n\t\t\t\t\t    struct device *ipu_dev,\n\t\t\t\t\t    struct ipu_soc *ipu,\n\t\t\t\t\t    u32 grp_id)\n{\n\tstruct vdic_priv *priv;\n\tint i, ret;\n\n\tpriv = devm_kzalloc(ipu_dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpriv->ipu_dev = ipu_dev;\n\tpriv->ipu = ipu;\n\n\tv4l2_subdev_init(&priv->sd, &vdic_subdev_ops);\n\tv4l2_set_subdevdata(&priv->sd, priv);\n\tpriv->sd.internal_ops = &vdic_internal_ops;\n\tpriv->sd.entity.ops = &vdic_entity_ops;\n\tpriv->sd.entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;\n\tpriv->sd.owner = ipu_dev->driver->owner;\n\tpriv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tpriv->sd.grp_id = grp_id;\n\timx_media_grp_id_to_sd_name(priv->sd.name, sizeof(priv->sd.name),\n\t\t\t\t    priv->sd.grp_id, ipu_get_num(ipu));\n\n\tmutex_init(&priv->lock);\n\n\tfor (i = 0; i < VDIC_NUM_PADS; i++)\n\t\tpriv->pad[i].flags = (i == VDIC_SRC_PAD_DIRECT) ?\n\t\t\tMEDIA_PAD_FL_SOURCE : MEDIA_PAD_FL_SINK;\n\n\tret = media_entity_pads_init(&priv->sd.entity, VDIC_NUM_PADS,\n\t\t\t\t     priv->pad);\n\tif (ret)\n\t\tgoto free;\n\n\tret = v4l2_device_register_subdev(v4l2_dev, &priv->sd);\n\tif (ret)\n\t\tgoto free;\n\n\treturn &priv->sd;\nfree:\n\tmutex_destroy(&priv->lock);\n\treturn ERR_PTR(ret);\n}\n\nint imx_media_vdic_unregister(struct v4l2_subdev *sd)\n{\n\tstruct vdic_priv *priv = v4l2_get_subdevdata(sd);\n\n\tv4l2_info(sd, \"Removing\\n\");\n\n\tv4l2_device_unregister_subdev(sd);\n\tmutex_destroy(&priv->lock);\n\tmedia_entity_cleanup(&sd->entity);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}