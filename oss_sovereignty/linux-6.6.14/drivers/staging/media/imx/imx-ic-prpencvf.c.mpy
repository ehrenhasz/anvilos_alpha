{
  "module_name": "imx-ic-prpencvf.c",
  "hash_id": "0b3ce847d636453adea53bcb4dfd02d8664f06bde476d1c47edd6fe6714824ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/imx/imx-ic-prpencvf.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-subdev.h>\n#include <media/imx.h>\n#include \"imx-media.h\"\n#include \"imx-ic.h\"\n\n \n#define MIN_W_SINK   32\n#define MIN_H_SINK   32\n#define MAX_W_SINK 4096\n#define MAX_H_SINK 4096\n#define W_ALIGN_SINK  3  \n#define H_ALIGN_SINK  1  \n\n#define MAX_W_SRC  1024\n#define MAX_H_SRC  1024\n#define W_ALIGN_SRC   1  \n#define H_ALIGN_SRC   1  \n\n#define S_ALIGN       1  \n\nstruct prp_priv {\n\tstruct imx_ic_priv *ic_priv;\n\tstruct media_pad pad[PRPENCVF_NUM_PADS];\n\t \n\tstruct imx_media_video_dev *vdev;\n\n\t \n\tstruct mutex lock;\n\n\t \n\tstruct ipu_ic *ic;\n\tstruct ipuv3_channel *out_ch;\n\tstruct ipuv3_channel *rot_in_ch;\n\tstruct ipuv3_channel *rot_out_ch;\n\n\t \n\tstruct imx_media_buffer *active_vb2_buf[2];\n\tstruct imx_media_dma_buf underrun_buf;\n\n\tint ipu_buf_num;   \n\n\t \n\tstruct media_entity *sink;\n\t \n\tstruct v4l2_subdev *src_sd;\n\n\tstruct v4l2_mbus_framefmt format_mbus[PRPENCVF_NUM_PADS];\n\tconst struct imx_media_pixfmt *cc[PRPENCVF_NUM_PADS];\n\tstruct v4l2_fract frame_interval;\n\n\tstruct imx_media_dma_buf rot_buf[2];\n\n\t \n\tstruct v4l2_ctrl_handler ctrl_hdlr;\n\tint  rotation;  \n\tbool hflip;\n\tbool vflip;\n\n\t \n\tenum ipu_rotate_mode rot_mode;\n\n\tspinlock_t irqlock;  \n\n\tstruct timer_list eof_timeout_timer;\n\tint eof_irq;\n\tint nfb4eof_irq;\n\n\tint stream_count;\n\tu32 frame_sequence;  \n\tbool last_eof;   \n\tbool nfb4eof;     \n\tbool interweave_swap;  \n\tstruct completion last_eof_comp;\n};\n\nstatic const struct prp_channels {\n\tu32 out_ch;\n\tu32 rot_in_ch;\n\tu32 rot_out_ch;\n} prp_channel[] = {\n\t[IC_TASK_ENCODER] = {\n\t\t.out_ch = IPUV3_CHANNEL_IC_PRP_ENC_MEM,\n\t\t.rot_in_ch = IPUV3_CHANNEL_MEM_ROT_ENC,\n\t\t.rot_out_ch = IPUV3_CHANNEL_ROT_ENC_MEM,\n\t},\n\t[IC_TASK_VIEWFINDER] = {\n\t\t.out_ch = IPUV3_CHANNEL_IC_PRP_VF_MEM,\n\t\t.rot_in_ch = IPUV3_CHANNEL_MEM_ROT_VF,\n\t\t.rot_out_ch = IPUV3_CHANNEL_ROT_VF_MEM,\n\t},\n};\n\nstatic inline struct prp_priv *sd_to_priv(struct v4l2_subdev *sd)\n{\n\tstruct imx_ic_priv *ic_priv = v4l2_get_subdevdata(sd);\n\n\treturn ic_priv->task_priv;\n}\n\nstatic void prp_put_ipu_resources(struct prp_priv *priv)\n{\n\tif (priv->ic)\n\t\tipu_ic_put(priv->ic);\n\tpriv->ic = NULL;\n\n\tif (priv->out_ch)\n\t\tipu_idmac_put(priv->out_ch);\n\tpriv->out_ch = NULL;\n\n\tif (priv->rot_in_ch)\n\t\tipu_idmac_put(priv->rot_in_ch);\n\tpriv->rot_in_ch = NULL;\n\n\tif (priv->rot_out_ch)\n\t\tipu_idmac_put(priv->rot_out_ch);\n\tpriv->rot_out_ch = NULL;\n}\n\nstatic int prp_get_ipu_resources(struct prp_priv *priv)\n{\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\tstruct ipu_ic *ic;\n\tstruct ipuv3_channel *out_ch, *rot_in_ch, *rot_out_ch;\n\tint ret, task = ic_priv->task_id;\n\n\tic = ipu_ic_get(ic_priv->ipu, task);\n\tif (IS_ERR(ic)) {\n\t\tv4l2_err(&ic_priv->sd, \"failed to get IC\\n\");\n\t\tret = PTR_ERR(ic);\n\t\tgoto out;\n\t}\n\tpriv->ic = ic;\n\n\tout_ch = ipu_idmac_get(ic_priv->ipu, prp_channel[task].out_ch);\n\tif (IS_ERR(out_ch)) {\n\t\tv4l2_err(&ic_priv->sd, \"could not get IDMAC channel %u\\n\",\n\t\t\t prp_channel[task].out_ch);\n\t\tret = PTR_ERR(out_ch);\n\t\tgoto out;\n\t}\n\tpriv->out_ch = out_ch;\n\n\trot_in_ch = ipu_idmac_get(ic_priv->ipu, prp_channel[task].rot_in_ch);\n\tif (IS_ERR(rot_in_ch)) {\n\t\tv4l2_err(&ic_priv->sd, \"could not get IDMAC channel %u\\n\",\n\t\t\t prp_channel[task].rot_in_ch);\n\t\tret = PTR_ERR(rot_in_ch);\n\t\tgoto out;\n\t}\n\tpriv->rot_in_ch = rot_in_ch;\n\n\trot_out_ch = ipu_idmac_get(ic_priv->ipu, prp_channel[task].rot_out_ch);\n\tif (IS_ERR(rot_out_ch)) {\n\t\tv4l2_err(&ic_priv->sd, \"could not get IDMAC channel %u\\n\",\n\t\t\t prp_channel[task].rot_out_ch);\n\t\tret = PTR_ERR(rot_out_ch);\n\t\tgoto out;\n\t}\n\tpriv->rot_out_ch = rot_out_ch;\n\n\treturn 0;\nout:\n\tprp_put_ipu_resources(priv);\n\treturn ret;\n}\n\nstatic void prp_vb2_buf_done(struct prp_priv *priv, struct ipuv3_channel *ch)\n{\n\tstruct imx_media_video_dev *vdev = priv->vdev;\n\tstruct imx_media_buffer *done, *next;\n\tstruct vb2_buffer *vb;\n\tdma_addr_t phys;\n\n\tdone = priv->active_vb2_buf[priv->ipu_buf_num];\n\tif (done) {\n\t\tdone->vbuf.field = vdev->fmt.field;\n\t\tdone->vbuf.sequence = priv->frame_sequence;\n\t\tvb = &done->vbuf.vb2_buf;\n\t\tvb->timestamp = ktime_get_ns();\n\t\tvb2_buffer_done(vb, priv->nfb4eof ?\n\t\t\t\tVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\t}\n\n\tpriv->frame_sequence++;\n\tpriv->nfb4eof = false;\n\n\t \n\tnext = imx_media_capture_device_next_buf(vdev);\n\tif (next) {\n\t\tphys = vb2_dma_contig_plane_dma_addr(&next->vbuf.vb2_buf, 0);\n\t\tpriv->active_vb2_buf[priv->ipu_buf_num] = next;\n\t} else {\n\t\tphys = priv->underrun_buf.phys;\n\t\tpriv->active_vb2_buf[priv->ipu_buf_num] = NULL;\n\t}\n\n\tif (ipu_idmac_buffer_is_ready(ch, priv->ipu_buf_num))\n\t\tipu_idmac_clear_buffer(ch, priv->ipu_buf_num);\n\n\tif (priv->interweave_swap && ch == priv->out_ch)\n\t\tphys += vdev->fmt.bytesperline;\n\n\tipu_cpmem_set_buffer(ch, priv->ipu_buf_num, phys);\n}\n\nstatic irqreturn_t prp_eof_interrupt(int irq, void *dev_id)\n{\n\tstruct prp_priv *priv = dev_id;\n\tstruct ipuv3_channel *channel;\n\n\tspin_lock(&priv->irqlock);\n\n\tif (priv->last_eof) {\n\t\tcomplete(&priv->last_eof_comp);\n\t\tpriv->last_eof = false;\n\t\tgoto unlock;\n\t}\n\n\tchannel = (ipu_rot_mode_is_irt(priv->rot_mode)) ?\n\t\tpriv->rot_out_ch : priv->out_ch;\n\n\tprp_vb2_buf_done(priv, channel);\n\n\t \n\tipu_idmac_select_buffer(channel, priv->ipu_buf_num);\n\t \n\tpriv->ipu_buf_num ^= 1;\n\n\t \n\tmod_timer(&priv->eof_timeout_timer,\n\t\t  jiffies + msecs_to_jiffies(IMX_MEDIA_EOF_TIMEOUT));\n\nunlock:\n\tspin_unlock(&priv->irqlock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t prp_nfb4eof_interrupt(int irq, void *dev_id)\n{\n\tstruct prp_priv *priv = dev_id;\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\n\tspin_lock(&priv->irqlock);\n\n\t \n\tpriv->nfb4eof = true;\n\n\tv4l2_err(&ic_priv->sd, \"NFB4EOF\\n\");\n\n\tspin_unlock(&priv->irqlock);\n\n\treturn IRQ_HANDLED;\n}\n\n \n \nstatic void prp_eof_timeout(struct timer_list *t)\n{\n\tstruct prp_priv *priv = from_timer(priv, t, eof_timeout_timer);\n\tstruct imx_media_video_dev *vdev = priv->vdev;\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\n\tv4l2_err(&ic_priv->sd, \"EOF timeout\\n\");\n\n\t \n\timx_media_capture_device_error(vdev);\n}\n\nstatic void prp_setup_vb2_buf(struct prp_priv *priv, dma_addr_t *phys)\n{\n\tstruct imx_media_video_dev *vdev = priv->vdev;\n\tstruct imx_media_buffer *buf;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tbuf = imx_media_capture_device_next_buf(vdev);\n\t\tif (buf) {\n\t\t\tpriv->active_vb2_buf[i] = buf;\n\t\t\tphys[i] = vb2_dma_contig_plane_dma_addr(\n\t\t\t\t&buf->vbuf.vb2_buf, 0);\n\t\t} else {\n\t\t\tpriv->active_vb2_buf[i] = NULL;\n\t\t\tphys[i] = priv->underrun_buf.phys;\n\t\t}\n\t}\n}\n\nstatic void prp_unsetup_vb2_buf(struct prp_priv *priv,\n\t\t\t\tenum vb2_buffer_state return_status)\n{\n\tstruct imx_media_buffer *buf;\n\tint i;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tbuf = priv->active_vb2_buf[i];\n\t\tif (buf) {\n\t\t\tstruct vb2_buffer *vb = &buf->vbuf.vb2_buf;\n\n\t\t\tvb->timestamp = ktime_get_ns();\n\t\t\tvb2_buffer_done(vb, return_status);\n\t\t}\n\t}\n}\n\nstatic int prp_setup_channel(struct prp_priv *priv,\n\t\t\t     struct ipuv3_channel *channel,\n\t\t\t     enum ipu_rotate_mode rot_mode,\n\t\t\t     dma_addr_t addr0, dma_addr_t addr1,\n\t\t\t     bool rot_swap_width_height)\n{\n\tstruct imx_media_video_dev *vdev = priv->vdev;\n\tconst struct imx_media_pixfmt *outcc;\n\tstruct v4l2_mbus_framefmt *outfmt;\n\tunsigned int burst_size;\n\tstruct ipu_image image;\n\tbool interweave;\n\tint ret;\n\n\toutfmt = &priv->format_mbus[PRPENCVF_SRC_PAD];\n\toutcc = vdev->cc;\n\n\tipu_cpmem_zero(channel);\n\n\tmemset(&image, 0, sizeof(image));\n\timage.pix = vdev->fmt;\n\timage.rect = vdev->compose;\n\n\t \n\tinterweave = V4L2_FIELD_IS_INTERLACED(image.pix.field) &&\n\t\tV4L2_FIELD_IS_SEQUENTIAL(outfmt->field);\n\tpriv->interweave_swap = interweave &&\n\t\timage.pix.field == V4L2_FIELD_INTERLACED_BT;\n\n\tif (rot_swap_width_height) {\n\t\tswap(image.pix.width, image.pix.height);\n\t\tswap(image.rect.width, image.rect.height);\n\t\t \n\t\timage.pix.bytesperline = outcc->planar ?\n\t\t\timage.pix.width :\n\t\t\t(image.pix.width * outcc->bpp) >> 3;\n\t}\n\n\tif (priv->interweave_swap && channel == priv->out_ch) {\n\t\t \n\t\timage.rect.top = 1;\n\t}\n\n\timage.phys0 = addr0;\n\timage.phys1 = addr1;\n\n\t \n\tif ((channel == priv->out_ch && !interweave) ||\n\t    channel == priv->rot_out_ch) {\n\t\tswitch (image.pix.pixelformat) {\n\t\tcase V4L2_PIX_FMT_YUV420:\n\t\tcase V4L2_PIX_FMT_YVU420:\n\t\tcase V4L2_PIX_FMT_NV12:\n\t\t\tipu_cpmem_skip_odd_chroma_rows(channel);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = ipu_cpmem_set_image(channel, &image);\n\tif (ret)\n\t\treturn ret;\n\n\tif (channel == priv->rot_in_ch ||\n\t    channel == priv->rot_out_ch) {\n\t\tburst_size = 8;\n\t\tipu_cpmem_set_block_mode(channel);\n\t} else {\n\t\tburst_size = (image.pix.width & 0xf) ? 8 : 16;\n\t}\n\n\tipu_cpmem_set_burstsize(channel, burst_size);\n\n\tif (rot_mode)\n\t\tipu_cpmem_set_rotation(channel, rot_mode);\n\n\tif (interweave && channel == priv->out_ch)\n\t\tipu_cpmem_interlaced_scan(channel,\n\t\t\t\t\t  priv->interweave_swap ?\n\t\t\t\t\t  -image.pix.bytesperline :\n\t\t\t\t\t  image.pix.bytesperline,\n\t\t\t\t\t  image.pix.pixelformat);\n\n\tret = ipu_ic_task_idma_init(priv->ic, channel,\n\t\t\t\t    image.pix.width, image.pix.height,\n\t\t\t\t    burst_size, rot_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tipu_cpmem_set_axi_id(channel, 1);\n\n\tipu_idmac_set_double_buffer(channel, true);\n\n\treturn 0;\n}\n\nstatic int prp_setup_rotation(struct prp_priv *priv)\n{\n\tstruct imx_media_video_dev *vdev = priv->vdev;\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\tconst struct imx_media_pixfmt *outcc, *incc;\n\tstruct v4l2_mbus_framefmt *infmt;\n\tstruct v4l2_pix_format *outfmt;\n\tstruct ipu_ic_csc csc;\n\tdma_addr_t phys[2];\n\tint ret;\n\n\tinfmt = &priv->format_mbus[PRPENCVF_SINK_PAD];\n\toutfmt = &vdev->fmt;\n\tincc = priv->cc[PRPENCVF_SINK_PAD];\n\toutcc = vdev->cc;\n\n\tret = ipu_ic_calc_csc(&csc,\n\t\t\t      infmt->ycbcr_enc, infmt->quantization,\n\t\t\t      incc->cs,\n\t\t\t      outfmt->ycbcr_enc, outfmt->quantization,\n\t\t\t      outcc->cs);\n\tif (ret) {\n\t\tv4l2_err(&ic_priv->sd, \"ipu_ic_calc_csc failed, %d\\n\",\n\t\t\t ret);\n\t\treturn ret;\n\t}\n\n\tret = imx_media_alloc_dma_buf(ic_priv->ipu_dev, &priv->rot_buf[0],\n\t\t\t\t      outfmt->sizeimage);\n\tif (ret) {\n\t\tv4l2_err(&ic_priv->sd, \"failed to alloc rot_buf[0], %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = imx_media_alloc_dma_buf(ic_priv->ipu_dev, &priv->rot_buf[1],\n\t\t\t\t      outfmt->sizeimage);\n\tif (ret) {\n\t\tv4l2_err(&ic_priv->sd, \"failed to alloc rot_buf[1], %d\\n\", ret);\n\t\tgoto free_rot0;\n\t}\n\n\tret = ipu_ic_task_init(priv->ic, &csc,\n\t\t\t       infmt->width, infmt->height,\n\t\t\t       outfmt->height, outfmt->width);\n\tif (ret) {\n\t\tv4l2_err(&ic_priv->sd, \"ipu_ic_task_init failed, %d\\n\", ret);\n\t\tgoto free_rot1;\n\t}\n\n\t \n\tret = prp_setup_channel(priv, priv->out_ch, IPU_ROTATE_NONE,\n\t\t\t\tpriv->rot_buf[0].phys, priv->rot_buf[1].phys,\n\t\t\t\ttrue);\n\tif (ret) {\n\t\tv4l2_err(&ic_priv->sd,\n\t\t\t \"prp_setup_channel(out_ch) failed, %d\\n\", ret);\n\t\tgoto free_rot1;\n\t}\n\n\t \n\tret = prp_setup_channel(priv, priv->rot_in_ch, priv->rot_mode,\n\t\t\t\tpriv->rot_buf[0].phys, priv->rot_buf[1].phys,\n\t\t\t\ttrue);\n\tif (ret) {\n\t\tv4l2_err(&ic_priv->sd,\n\t\t\t \"prp_setup_channel(rot_in_ch) failed, %d\\n\", ret);\n\t\tgoto free_rot1;\n\t}\n\n\tprp_setup_vb2_buf(priv, phys);\n\n\t \n\tret = prp_setup_channel(priv, priv->rot_out_ch, IPU_ROTATE_NONE,\n\t\t\t\tphys[0], phys[1],\n\t\t\t\tfalse);\n\tif (ret) {\n\t\tv4l2_err(&ic_priv->sd,\n\t\t\t \"prp_setup_channel(rot_out_ch) failed, %d\\n\", ret);\n\t\tgoto unsetup_vb2;\n\t}\n\n\t \n\tipu_idmac_link(priv->out_ch, priv->rot_in_ch);\n\n\t \n\tipu_ic_enable(priv->ic);\n\n\t \n\tipu_idmac_select_buffer(priv->out_ch, 0);\n\tipu_idmac_select_buffer(priv->out_ch, 1);\n\tipu_idmac_select_buffer(priv->rot_out_ch, 0);\n\tipu_idmac_select_buffer(priv->rot_out_ch, 1);\n\n\t \n\tipu_idmac_enable_channel(priv->out_ch);\n\tipu_idmac_enable_channel(priv->rot_in_ch);\n\tipu_idmac_enable_channel(priv->rot_out_ch);\n\n\t \n\tipu_ic_task_enable(priv->ic);\n\n\treturn 0;\n\nunsetup_vb2:\n\tprp_unsetup_vb2_buf(priv, VB2_BUF_STATE_QUEUED);\nfree_rot1:\n\timx_media_free_dma_buf(ic_priv->ipu_dev, &priv->rot_buf[1]);\nfree_rot0:\n\timx_media_free_dma_buf(ic_priv->ipu_dev, &priv->rot_buf[0]);\n\treturn ret;\n}\n\nstatic void prp_unsetup_rotation(struct prp_priv *priv)\n{\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\n\tipu_ic_task_disable(priv->ic);\n\n\tipu_idmac_disable_channel(priv->out_ch);\n\tipu_idmac_disable_channel(priv->rot_in_ch);\n\tipu_idmac_disable_channel(priv->rot_out_ch);\n\n\tipu_idmac_unlink(priv->out_ch, priv->rot_in_ch);\n\n\tipu_ic_disable(priv->ic);\n\n\timx_media_free_dma_buf(ic_priv->ipu_dev, &priv->rot_buf[0]);\n\timx_media_free_dma_buf(ic_priv->ipu_dev, &priv->rot_buf[1]);\n}\n\nstatic int prp_setup_norotation(struct prp_priv *priv)\n{\n\tstruct imx_media_video_dev *vdev = priv->vdev;\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\tconst struct imx_media_pixfmt *outcc, *incc;\n\tstruct v4l2_mbus_framefmt *infmt;\n\tstruct v4l2_pix_format *outfmt;\n\tstruct ipu_ic_csc csc;\n\tdma_addr_t phys[2];\n\tint ret;\n\n\tinfmt = &priv->format_mbus[PRPENCVF_SINK_PAD];\n\toutfmt = &vdev->fmt;\n\tincc = priv->cc[PRPENCVF_SINK_PAD];\n\toutcc = vdev->cc;\n\n\tret = ipu_ic_calc_csc(&csc,\n\t\t\t      infmt->ycbcr_enc, infmt->quantization,\n\t\t\t      incc->cs,\n\t\t\t      outfmt->ycbcr_enc, outfmt->quantization,\n\t\t\t      outcc->cs);\n\tif (ret) {\n\t\tv4l2_err(&ic_priv->sd, \"ipu_ic_calc_csc failed, %d\\n\",\n\t\t\t ret);\n\t\treturn ret;\n\t}\n\n\tret = ipu_ic_task_init(priv->ic, &csc,\n\t\t\t       infmt->width, infmt->height,\n\t\t\t       outfmt->width, outfmt->height);\n\tif (ret) {\n\t\tv4l2_err(&ic_priv->sd, \"ipu_ic_task_init failed, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tprp_setup_vb2_buf(priv, phys);\n\n\t \n\tret = prp_setup_channel(priv, priv->out_ch, priv->rot_mode,\n\t\t\t\tphys[0], phys[1], false);\n\tif (ret) {\n\t\tv4l2_err(&ic_priv->sd,\n\t\t\t \"prp_setup_channel(out_ch) failed, %d\\n\", ret);\n\t\tgoto unsetup_vb2;\n\t}\n\n\tipu_cpmem_dump(priv->out_ch);\n\tipu_ic_dump(priv->ic);\n\tipu_dump(ic_priv->ipu);\n\n\tipu_ic_enable(priv->ic);\n\n\t \n\tipu_idmac_select_buffer(priv->out_ch, 0);\n\tipu_idmac_select_buffer(priv->out_ch, 1);\n\n\t \n\tipu_idmac_enable_channel(priv->out_ch);\n\n\t \n\tipu_ic_task_enable(priv->ic);\n\n\treturn 0;\n\nunsetup_vb2:\n\tprp_unsetup_vb2_buf(priv, VB2_BUF_STATE_QUEUED);\n\treturn ret;\n}\n\nstatic void prp_unsetup_norotation(struct prp_priv *priv)\n{\n\tipu_ic_task_disable(priv->ic);\n\tipu_idmac_disable_channel(priv->out_ch);\n\tipu_ic_disable(priv->ic);\n}\n\nstatic void prp_unsetup(struct prp_priv *priv,\n\t\t\tenum vb2_buffer_state state)\n{\n\tif (ipu_rot_mode_is_irt(priv->rot_mode))\n\t\tprp_unsetup_rotation(priv);\n\telse\n\t\tprp_unsetup_norotation(priv);\n\n\tprp_unsetup_vb2_buf(priv, state);\n}\n\nstatic int prp_start(struct prp_priv *priv)\n{\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\tstruct imx_media_video_dev *vdev = priv->vdev;\n\tint ret;\n\n\tret = prp_get_ipu_resources(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = imx_media_alloc_dma_buf(ic_priv->ipu_dev, &priv->underrun_buf,\n\t\t\t\t      vdev->fmt.sizeimage);\n\tif (ret)\n\t\tgoto out_put_ipu;\n\n\tpriv->ipu_buf_num = 0;\n\n\t \n\tinit_completion(&priv->last_eof_comp);\n\tpriv->frame_sequence = 0;\n\tpriv->last_eof = false;\n\tpriv->nfb4eof = false;\n\n\tif (ipu_rot_mode_is_irt(priv->rot_mode))\n\t\tret = prp_setup_rotation(priv);\n\telse\n\t\tret = prp_setup_norotation(priv);\n\tif (ret)\n\t\tgoto out_free_underrun;\n\n\tpriv->nfb4eof_irq = ipu_idmac_channel_irq(ic_priv->ipu,\n\t\t\t\t\t\t  priv->out_ch,\n\t\t\t\t\t\t  IPU_IRQ_NFB4EOF);\n\tret = devm_request_irq(ic_priv->ipu_dev, priv->nfb4eof_irq,\n\t\t\t       prp_nfb4eof_interrupt, 0,\n\t\t\t       \"imx-ic-prp-nfb4eof\", priv);\n\tif (ret) {\n\t\tv4l2_err(&ic_priv->sd,\n\t\t\t \"Error registering NFB4EOF irq: %d\\n\", ret);\n\t\tgoto out_unsetup;\n\t}\n\n\tif (ipu_rot_mode_is_irt(priv->rot_mode))\n\t\tpriv->eof_irq = ipu_idmac_channel_irq(\n\t\t\tic_priv->ipu, priv->rot_out_ch, IPU_IRQ_EOF);\n\telse\n\t\tpriv->eof_irq = ipu_idmac_channel_irq(\n\t\t\tic_priv->ipu, priv->out_ch, IPU_IRQ_EOF);\n\n\tret = devm_request_irq(ic_priv->ipu_dev, priv->eof_irq,\n\t\t\t       prp_eof_interrupt, 0,\n\t\t\t       \"imx-ic-prp-eof\", priv);\n\tif (ret) {\n\t\tv4l2_err(&ic_priv->sd,\n\t\t\t \"Error registering eof irq: %d\\n\", ret);\n\t\tgoto out_free_nfb4eof_irq;\n\t}\n\n\t \n\tret = v4l2_subdev_call(priv->src_sd, video, s_stream, 1);\n\tret = (ret && ret != -ENOIOCTLCMD) ? ret : 0;\n\tif (ret) {\n\t\tv4l2_err(&ic_priv->sd,\n\t\t\t \"upstream stream on failed: %d\\n\", ret);\n\t\tgoto out_free_eof_irq;\n\t}\n\n\t \n\tmod_timer(&priv->eof_timeout_timer,\n\t\t  jiffies + msecs_to_jiffies(IMX_MEDIA_EOF_TIMEOUT));\n\n\treturn 0;\n\nout_free_eof_irq:\n\tdevm_free_irq(ic_priv->ipu_dev, priv->eof_irq, priv);\nout_free_nfb4eof_irq:\n\tdevm_free_irq(ic_priv->ipu_dev, priv->nfb4eof_irq, priv);\nout_unsetup:\n\tprp_unsetup(priv, VB2_BUF_STATE_QUEUED);\nout_free_underrun:\n\timx_media_free_dma_buf(ic_priv->ipu_dev, &priv->underrun_buf);\nout_put_ipu:\n\tprp_put_ipu_resources(priv);\n\treturn ret;\n}\n\nstatic void prp_stop(struct prp_priv *priv)\n{\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tspin_lock_irqsave(&priv->irqlock, flags);\n\tpriv->last_eof = true;\n\tspin_unlock_irqrestore(&priv->irqlock, flags);\n\n\t \n\tret = wait_for_completion_timeout(\n\t\t&priv->last_eof_comp,\n\t\tmsecs_to_jiffies(IMX_MEDIA_EOF_TIMEOUT));\n\tif (ret == 0)\n\t\tv4l2_warn(&ic_priv->sd, \"wait last EOF timeout\\n\");\n\n\t \n\tret = v4l2_subdev_call(priv->src_sd, video, s_stream, 0);\n\tif (ret && ret != -ENOIOCTLCMD)\n\t\tv4l2_warn(&ic_priv->sd,\n\t\t\t  \"upstream stream off failed: %d\\n\", ret);\n\n\tdevm_free_irq(ic_priv->ipu_dev, priv->eof_irq, priv);\n\tdevm_free_irq(ic_priv->ipu_dev, priv->nfb4eof_irq, priv);\n\n\tprp_unsetup(priv, VB2_BUF_STATE_ERROR);\n\n\timx_media_free_dma_buf(ic_priv->ipu_dev, &priv->underrun_buf);\n\n\t \n\tdel_timer_sync(&priv->eof_timeout_timer);\n\n\tprp_put_ipu_resources(priv);\n}\n\nstatic struct v4l2_mbus_framefmt *\n__prp_get_fmt(struct prp_priv *priv, struct v4l2_subdev_state *sd_state,\n\t      unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&ic_priv->sd, sd_state, pad);\n\telse\n\t\treturn &priv->format_mbus[pad];\n}\n\n \nstatic bool prp_bound_align_output(struct v4l2_mbus_framefmt *outfmt,\n\t\t\t\t   struct v4l2_mbus_framefmt *infmt,\n\t\t\t\t   enum ipu_rotate_mode rot_mode)\n{\n\tu32 orig_width = outfmt->width;\n\tu32 orig_height = outfmt->height;\n\n\tif (ipu_rot_mode_is_irt(rot_mode))\n\t\tv4l_bound_align_image(&outfmt->width,\n\t\t\t\t      infmt->height / 4, MAX_H_SRC,\n\t\t\t\t      W_ALIGN_SRC,\n\t\t\t\t      &outfmt->height,\n\t\t\t\t      infmt->width / 4, MAX_W_SRC,\n\t\t\t\t      W_ALIGN_SRC, S_ALIGN);\n\telse\n\t\tv4l_bound_align_image(&outfmt->width,\n\t\t\t\t      infmt->width / 4, MAX_W_SRC,\n\t\t\t\t      W_ALIGN_SRC,\n\t\t\t\t      &outfmt->height,\n\t\t\t\t      infmt->height / 4, MAX_H_SRC,\n\t\t\t\t      H_ALIGN_SRC, S_ALIGN);\n\n\treturn outfmt->width != orig_width || outfmt->height != orig_height;\n}\n\n \n\nstatic int prp_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad >= PRPENCVF_NUM_PADS)\n\t\treturn -EINVAL;\n\n\treturn imx_media_enum_ipu_formats(&code->code, code->index,\n\t\t\t\t\t  PIXFMT_SEL_YUV_RGB);\n}\n\nstatic int prp_get_fmt(struct v4l2_subdev *sd,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       struct v4l2_subdev_format *sdformat)\n{\n\tstruct prp_priv *priv = sd_to_priv(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\tint ret = 0;\n\n\tif (sdformat->pad >= PRPENCVF_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\tfmt = __prp_get_fmt(priv, sd_state, sdformat->pad, sdformat->which);\n\tif (!fmt) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsdformat->format = *fmt;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic void prp_try_fmt(struct prp_priv *priv,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tstruct v4l2_subdev_format *sdformat,\n\t\t\tconst struct imx_media_pixfmt **cc)\n{\n\tstruct v4l2_mbus_framefmt *infmt;\n\n\t*cc = imx_media_find_ipu_format(sdformat->format.code,\n\t\t\t\t\tPIXFMT_SEL_YUV_RGB);\n\tif (!*cc) {\n\t\tu32 code;\n\n\t\timx_media_enum_ipu_formats(&code, 0, PIXFMT_SEL_YUV_RGB);\n\t\t*cc = imx_media_find_ipu_format(code, PIXFMT_SEL_YUV_RGB);\n\n\t\tsdformat->format.code = (*cc)->codes[0];\n\t}\n\n\tinfmt = __prp_get_fmt(priv, sd_state, PRPENCVF_SINK_PAD,\n\t\t\t      sdformat->which);\n\n\tif (sdformat->pad == PRPENCVF_SRC_PAD) {\n\t\tsdformat->format.field = infmt->field;\n\n\t\tprp_bound_align_output(&sdformat->format, infmt,\n\t\t\t\t       priv->rot_mode);\n\n\t\t \n\t\tsdformat->format.colorspace = infmt->colorspace;\n\t\tsdformat->format.xfer_func = infmt->xfer_func;\n\t} else {\n\t\tv4l_bound_align_image(&sdformat->format.width,\n\t\t\t\t      MIN_W_SINK, MAX_W_SINK, W_ALIGN_SINK,\n\t\t\t\t      &sdformat->format.height,\n\t\t\t\t      MIN_H_SINK, MAX_H_SINK, H_ALIGN_SINK,\n\t\t\t\t      S_ALIGN);\n\n\t\tif (sdformat->format.field == V4L2_FIELD_ANY)\n\t\t\tsdformat->format.field = V4L2_FIELD_NONE;\n\t}\n\n\timx_media_try_colorimetry(&sdformat->format, true);\n}\n\nstatic int prp_set_fmt(struct v4l2_subdev *sd,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       struct v4l2_subdev_format *sdformat)\n{\n\tstruct prp_priv *priv = sd_to_priv(sd);\n\tconst struct imx_media_pixfmt *cc;\n\tstruct v4l2_mbus_framefmt *fmt;\n\tint ret = 0;\n\n\tif (sdformat->pad >= PRPENCVF_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->stream_count > 0) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tprp_try_fmt(priv, sd_state, sdformat, &cc);\n\n\tfmt = __prp_get_fmt(priv, sd_state, sdformat->pad, sdformat->which);\n\t*fmt = sdformat->format;\n\n\t \n\tif (sdformat->pad == PRPENCVF_SINK_PAD) {\n\t\tconst struct imx_media_pixfmt *outcc;\n\t\tstruct v4l2_mbus_framefmt *outfmt;\n\t\tstruct v4l2_subdev_format format;\n\n\t\tformat.pad = PRPENCVF_SRC_PAD;\n\t\tformat.which = sdformat->which;\n\t\tformat.format = sdformat->format;\n\t\tprp_try_fmt(priv, sd_state, &format, &outcc);\n\n\t\toutfmt = __prp_get_fmt(priv, sd_state, PRPENCVF_SRC_PAD,\n\t\t\t\t       sdformat->which);\n\t\t*outfmt = format.format;\n\t\tif (sdformat->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\t\tpriv->cc[PRPENCVF_SRC_PAD] = outcc;\n\t}\n\n\tif (sdformat->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\tpriv->cc[sdformat->pad] = cc;\n\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int prp_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct prp_priv *priv = sd_to_priv(sd);\n\tstruct v4l2_subdev_format format = {};\n\tconst struct imx_media_pixfmt *cc;\n\tint ret = 0;\n\n\tif (fse->pad >= PRPENCVF_NUM_PADS || fse->index != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\tformat.pad = fse->pad;\n\tformat.which = fse->which;\n\tformat.format.code = fse->code;\n\tformat.format.width = 1;\n\tformat.format.height = 1;\n\tprp_try_fmt(priv, sd_state, &format, &cc);\n\tfse->min_width = format.format.width;\n\tfse->min_height = format.format.height;\n\n\tif (format.format.code != fse->code) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tformat.format.code = fse->code;\n\tformat.format.width = -1;\n\tformat.format.height = -1;\n\tprp_try_fmt(priv, sd_state, &format, &cc);\n\tfse->max_width = format.format.width;\n\tfse->max_height = format.format.height;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int prp_link_setup(struct media_entity *entity,\n\t\t\t  const struct media_pad *local,\n\t\t\t  const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct imx_ic_priv *ic_priv = v4l2_get_subdevdata(sd);\n\tstruct prp_priv *priv = ic_priv->task_priv;\n\tstruct v4l2_subdev *remote_sd;\n\tint ret = 0;\n\n\tdev_dbg(ic_priv->ipu_dev, \"%s: link setup %s -> %s\",\n\t\tic_priv->sd.name, remote->entity->name, local->entity->name);\n\n\tmutex_lock(&priv->lock);\n\n\tif (local->flags & MEDIA_PAD_FL_SINK) {\n\t\tif (!is_media_entity_v4l2_subdev(remote->entity)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tremote_sd = media_entity_to_v4l2_subdev(remote->entity);\n\n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (priv->src_sd) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpriv->src_sd = remote_sd;\n\t\t} else {\n\t\t\tpriv->src_sd = NULL;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t \n\n\t \n\tif (!is_media_entity_v4l2_video_device(remote->entity)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\tif (priv->sink) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpriv->sink = NULL;\n\t\tgoto out;\n\t}\n\n\tpriv->sink = remote->entity;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int prp_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct prp_priv *priv = container_of(ctrl->handler,\n\t\t\t\t\t       struct prp_priv, ctrl_hdlr);\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\tenum ipu_rotate_mode rot_mode;\n\tint rotation, ret = 0;\n\tbool hflip, vflip;\n\n\tmutex_lock(&priv->lock);\n\n\trotation = priv->rotation;\n\thflip = priv->hflip;\n\tvflip = priv->vflip;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\thflip = (ctrl->val == 1);\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tvflip = (ctrl->val == 1);\n\t\tbreak;\n\tcase V4L2_CID_ROTATE:\n\t\trotation = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\tv4l2_err(&ic_priv->sd, \"Invalid control\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ipu_degrees_to_rot_mode(&rot_mode, rotation, hflip, vflip);\n\tif (ret)\n\t\tgoto out;\n\n\tif (rot_mode != priv->rot_mode) {\n\t\tstruct v4l2_mbus_framefmt outfmt, infmt;\n\n\t\t \n\t\tif (priv->stream_count > 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\toutfmt = priv->format_mbus[PRPENCVF_SRC_PAD];\n\t\tinfmt = priv->format_mbus[PRPENCVF_SINK_PAD];\n\n\t\tif (prp_bound_align_output(&outfmt, &infmt, rot_mode)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpriv->rot_mode = rot_mode;\n\t\tpriv->rotation = rotation;\n\t\tpriv->hflip = hflip;\n\t\tpriv->vflip = vflip;\n\t}\n\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops prp_ctrl_ops = {\n\t.s_ctrl = prp_s_ctrl,\n};\n\nstatic int prp_init_controls(struct prp_priv *priv)\n{\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\tstruct v4l2_ctrl_handler *hdlr = &priv->ctrl_hdlr;\n\tint ret;\n\n\tv4l2_ctrl_handler_init(hdlr, 3);\n\n\tv4l2_ctrl_new_std(hdlr, &prp_ctrl_ops, V4L2_CID_HFLIP,\n\t\t\t  0, 1, 1, 0);\n\tv4l2_ctrl_new_std(hdlr, &prp_ctrl_ops, V4L2_CID_VFLIP,\n\t\t\t  0, 1, 1, 0);\n\tv4l2_ctrl_new_std(hdlr, &prp_ctrl_ops, V4L2_CID_ROTATE,\n\t\t\t  0, 270, 90, 0);\n\n\tic_priv->sd.ctrl_handler = hdlr;\n\n\tif (hdlr->error) {\n\t\tret = hdlr->error;\n\t\tgoto out_free;\n\t}\n\n\tv4l2_ctrl_handler_setup(hdlr);\n\treturn 0;\n\nout_free:\n\tv4l2_ctrl_handler_free(hdlr);\n\treturn ret;\n}\n\nstatic int prp_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct imx_ic_priv *ic_priv = v4l2_get_subdevdata(sd);\n\tstruct prp_priv *priv = ic_priv->task_priv;\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tif (!priv->src_sd || !priv->sink) {\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\t \n\tif (priv->stream_count != !enable)\n\t\tgoto update_count;\n\n\tdev_dbg(ic_priv->ipu_dev, \"%s: stream %s\\n\", sd->name,\n\t\tenable ? \"ON\" : \"OFF\");\n\n\tif (enable)\n\t\tret = prp_start(priv);\n\telse\n\t\tprp_stop(priv);\n\tif (ret)\n\t\tgoto out;\n\nupdate_count:\n\tpriv->stream_count += enable ? 1 : -1;\n\tif (priv->stream_count < 0)\n\t\tpriv->stream_count = 0;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int prp_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_frame_interval *fi)\n{\n\tstruct prp_priv *priv = sd_to_priv(sd);\n\n\tif (fi->pad >= PRPENCVF_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\tfi->interval = priv->frame_interval;\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int prp_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_frame_interval *fi)\n{\n\tstruct prp_priv *priv = sd_to_priv(sd);\n\n\tif (fi->pad >= PRPENCVF_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tif (fi->interval.numerator == 0 || fi->interval.denominator == 0)\n\t\tfi->interval = priv->frame_interval;\n\telse\n\t\tpriv->frame_interval = fi->interval;\n\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int prp_registered(struct v4l2_subdev *sd)\n{\n\tstruct prp_priv *priv = sd_to_priv(sd);\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\tint i, ret;\n\tu32 code;\n\n\t \n\timx_media_enum_ipu_formats(&code, 0, PIXFMT_SEL_YUV);\n\n\tfor (i = 0; i < PRPENCVF_NUM_PADS; i++) {\n\t\tret = imx_media_init_mbus_fmt(&priv->format_mbus[i],\n\t\t\t\t\t      IMX_MEDIA_DEF_PIX_WIDTH,\n\t\t\t\t\t      IMX_MEDIA_DEF_PIX_HEIGHT, code,\n\t\t\t\t\t      V4L2_FIELD_NONE, &priv->cc[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tpriv->frame_interval.numerator = 1;\n\tpriv->frame_interval.denominator = 30;\n\n\tpriv->vdev = imx_media_capture_device_init(ic_priv->ipu_dev,\n\t\t\t\t\t\t   &ic_priv->sd,\n\t\t\t\t\t\t   PRPENCVF_SRC_PAD, true);\n\tif (IS_ERR(priv->vdev))\n\t\treturn PTR_ERR(priv->vdev);\n\n\tret = imx_media_capture_device_register(priv->vdev, 0);\n\tif (ret)\n\t\tgoto remove_vdev;\n\n\tret = prp_init_controls(priv);\n\tif (ret)\n\t\tgoto unreg_vdev;\n\n\treturn 0;\n\nunreg_vdev:\n\timx_media_capture_device_unregister(priv->vdev);\nremove_vdev:\n\timx_media_capture_device_remove(priv->vdev);\n\treturn ret;\n}\n\nstatic void prp_unregistered(struct v4l2_subdev *sd)\n{\n\tstruct prp_priv *priv = sd_to_priv(sd);\n\n\timx_media_capture_device_unregister(priv->vdev);\n\timx_media_capture_device_remove(priv->vdev);\n\n\tv4l2_ctrl_handler_free(&priv->ctrl_hdlr);\n}\n\nstatic const struct v4l2_subdev_pad_ops prp_pad_ops = {\n\t.init_cfg = imx_media_init_cfg,\n\t.enum_mbus_code = prp_enum_mbus_code,\n\t.enum_frame_size = prp_enum_frame_size,\n\t.get_fmt = prp_get_fmt,\n\t.set_fmt = prp_set_fmt,\n};\n\nstatic const struct v4l2_subdev_video_ops prp_video_ops = {\n\t.g_frame_interval = prp_g_frame_interval,\n\t.s_frame_interval = prp_s_frame_interval,\n\t.s_stream = prp_s_stream,\n};\n\nstatic const struct media_entity_operations prp_entity_ops = {\n\t.link_setup = prp_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic const struct v4l2_subdev_ops prp_subdev_ops = {\n\t.video = &prp_video_ops,\n\t.pad = &prp_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops prp_internal_ops = {\n\t.registered = prp_registered,\n\t.unregistered = prp_unregistered,\n};\n\nstatic int prp_init(struct imx_ic_priv *ic_priv)\n{\n\tstruct prp_priv *priv;\n\tint i, ret;\n\n\tpriv = devm_kzalloc(ic_priv->ipu_dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tic_priv->task_priv = priv;\n\tpriv->ic_priv = ic_priv;\n\n\tspin_lock_init(&priv->irqlock);\n\ttimer_setup(&priv->eof_timeout_timer, prp_eof_timeout, 0);\n\n\tmutex_init(&priv->lock);\n\n\tfor (i = 0; i < PRPENCVF_NUM_PADS; i++) {\n\t\tpriv->pad[i].flags = (i == PRPENCVF_SINK_PAD) ?\n\t\t\tMEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;\n\t}\n\n\tret = media_entity_pads_init(&ic_priv->sd.entity, PRPENCVF_NUM_PADS,\n\t\t\t\t     priv->pad);\n\tif (ret)\n\t\tmutex_destroy(&priv->lock);\n\n\treturn ret;\n}\n\nstatic void prp_remove(struct imx_ic_priv *ic_priv)\n{\n\tstruct prp_priv *priv = ic_priv->task_priv;\n\n\tmutex_destroy(&priv->lock);\n}\n\nstruct imx_ic_ops imx_ic_prpencvf_ops = {\n\t.subdev_ops = &prp_subdev_ops,\n\t.internal_ops = &prp_internal_ops,\n\t.entity_ops = &prp_entity_ops,\n\t.init = prp_init,\n\t.remove = prp_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}