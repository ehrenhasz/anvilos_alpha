{
  "module_name": "imx-ic-prp.c",
  "hash_id": "e470a1cf874bb161c644f8f2ce63cf89b5708ca3f1692a924f27ffd7799041da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/imx/imx-ic-prp.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-subdev.h>\n#include <media/imx.h>\n#include \"imx-media.h\"\n#include \"imx-ic.h\"\n\n \n#define MIN_W        32\n#define MIN_H        32\n#define MAX_W      4096\n#define MAX_H      4096\n#define W_ALIGN    4  \n#define H_ALIGN    1  \n#define S_ALIGN    1  \n\nstruct prp_priv {\n\tstruct imx_ic_priv *ic_priv;\n\tstruct media_pad pad[PRP_NUM_PADS];\n\n\t \n\tstruct mutex lock;\n\n\tstruct v4l2_subdev *src_sd;\n\tstruct v4l2_subdev *sink_sd_prpenc;\n\tstruct v4l2_subdev *sink_sd_prpvf;\n\n\t \n\tint csi_id;\n\n\tstruct v4l2_mbus_framefmt format_mbus;\n\tstruct v4l2_fract frame_interval;\n\n\tint stream_count;\n};\n\nstatic inline struct prp_priv *sd_to_priv(struct v4l2_subdev *sd)\n{\n\tstruct imx_ic_priv *ic_priv = v4l2_get_subdevdata(sd);\n\n\treturn ic_priv->task_priv;\n}\n\nstatic int prp_start(struct prp_priv *priv)\n{\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\tbool src_is_vdic;\n\n\t \n\tsrc_is_vdic = !!(priv->src_sd->grp_id & IMX_MEDIA_GRP_ID_IPU_VDIC);\n\n\tipu_set_ic_src_mux(ic_priv->ipu, priv->csi_id, src_is_vdic);\n\n\treturn 0;\n}\n\nstatic void prp_stop(struct prp_priv *priv)\n{\n}\n\nstatic struct v4l2_mbus_framefmt *\n__prp_get_fmt(struct prp_priv *priv, struct v4l2_subdev_state *sd_state,\n\t      unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tstruct imx_ic_priv *ic_priv = priv->ic_priv;\n\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&ic_priv->sd, sd_state, pad);\n\telse\n\t\treturn &priv->format_mbus;\n}\n\n \n\nstatic int prp_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct prp_priv *priv = sd_to_priv(sd);\n\tstruct v4l2_mbus_framefmt *infmt;\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tswitch (code->pad) {\n\tcase PRP_SINK_PAD:\n\t\tret = imx_media_enum_ipu_formats(&code->code, code->index,\n\t\t\t\t\t\t PIXFMT_SEL_YUV_RGB);\n\t\tbreak;\n\tcase PRP_SRC_PAD_PRPENC:\n\tcase PRP_SRC_PAD_PRPVF:\n\t\tif (code->index != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tinfmt = __prp_get_fmt(priv, sd_state, PRP_SINK_PAD,\n\t\t\t\t      code->which);\n\t\tcode->code = infmt->code;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int prp_get_fmt(struct v4l2_subdev *sd,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       struct v4l2_subdev_format *sdformat)\n{\n\tstruct prp_priv *priv = sd_to_priv(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\tint ret = 0;\n\n\tif (sdformat->pad >= PRP_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\tfmt = __prp_get_fmt(priv, sd_state, sdformat->pad, sdformat->which);\n\tif (!fmt) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsdformat->format = *fmt;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int prp_set_fmt(struct v4l2_subdev *sd,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       struct v4l2_subdev_format *sdformat)\n{\n\tstruct prp_priv *priv = sd_to_priv(sd);\n\tstruct v4l2_mbus_framefmt *fmt, *infmt;\n\tconst struct imx_media_pixfmt *cc;\n\tint ret = 0;\n\tu32 code;\n\n\tif (sdformat->pad >= PRP_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->stream_count > 0) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tinfmt = __prp_get_fmt(priv, sd_state, PRP_SINK_PAD, sdformat->which);\n\n\tswitch (sdformat->pad) {\n\tcase PRP_SINK_PAD:\n\t\tv4l_bound_align_image(&sdformat->format.width, MIN_W, MAX_W,\n\t\t\t\t      W_ALIGN, &sdformat->format.height,\n\t\t\t\t      MIN_H, MAX_H, H_ALIGN, S_ALIGN);\n\n\t\tcc = imx_media_find_ipu_format(sdformat->format.code,\n\t\t\t\t\t       PIXFMT_SEL_YUV_RGB);\n\t\tif (!cc) {\n\t\t\timx_media_enum_ipu_formats(&code, 0,\n\t\t\t\t\t\t   PIXFMT_SEL_YUV_RGB);\n\t\t\tcc = imx_media_find_ipu_format(code,\n\t\t\t\t\t\t       PIXFMT_SEL_YUV_RGB);\n\t\t\tsdformat->format.code = cc->codes[0];\n\t\t}\n\n\t\tif (sdformat->format.field == V4L2_FIELD_ANY)\n\t\t\tsdformat->format.field = V4L2_FIELD_NONE;\n\t\tbreak;\n\tcase PRP_SRC_PAD_PRPENC:\n\tcase PRP_SRC_PAD_PRPVF:\n\t\t \n\t\tsdformat->format = *infmt;\n\t\tbreak;\n\t}\n\n\timx_media_try_colorimetry(&sdformat->format, true);\n\n\tfmt = __prp_get_fmt(priv, sd_state, sdformat->pad, sdformat->which);\n\t*fmt = sdformat->format;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int prp_link_setup(struct media_entity *entity,\n\t\t\t  const struct media_pad *local,\n\t\t\t  const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct imx_ic_priv *ic_priv = v4l2_get_subdevdata(sd);\n\tstruct prp_priv *priv = ic_priv->task_priv;\n\tstruct v4l2_subdev *remote_sd;\n\tint ret = 0;\n\n\tdev_dbg(ic_priv->ipu_dev, \"%s: link setup %s -> %s\",\n\t\tic_priv->sd.name, remote->entity->name, local->entity->name);\n\n\tremote_sd = media_entity_to_v4l2_subdev(remote->entity);\n\n\tmutex_lock(&priv->lock);\n\n\tif (local->flags & MEDIA_PAD_FL_SINK) {\n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (priv->src_sd) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (priv->sink_sd_prpenc &&\n\t\t\t    (remote_sd->grp_id & IMX_MEDIA_GRP_ID_IPU_VDIC)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpriv->src_sd = remote_sd;\n\t\t} else {\n\t\t\tpriv->src_sd = NULL;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t \n\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\tswitch (local->index) {\n\t\tcase PRP_SRC_PAD_PRPENC:\n\t\t\tif (priv->sink_sd_prpenc) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (priv->src_sd && (priv->src_sd->grp_id &\n\t\t\t\t\t     IMX_MEDIA_GRP_ID_IPU_VDIC)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpriv->sink_sd_prpenc = remote_sd;\n\t\t\tbreak;\n\t\tcase PRP_SRC_PAD_PRPVF:\n\t\t\tif (priv->sink_sd_prpvf) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpriv->sink_sd_prpvf = remote_sd;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tswitch (local->index) {\n\t\tcase PRP_SRC_PAD_PRPENC:\n\t\t\tpriv->sink_sd_prpenc = NULL;\n\t\t\tbreak;\n\t\tcase PRP_SRC_PAD_PRPVF:\n\t\t\tpriv->sink_sd_prpvf = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int prp_link_validate(struct v4l2_subdev *sd,\n\t\t\t     struct media_link *link,\n\t\t\t     struct v4l2_subdev_format *source_fmt,\n\t\t\t     struct v4l2_subdev_format *sink_fmt)\n{\n\tstruct imx_ic_priv *ic_priv = v4l2_get_subdevdata(sd);\n\tstruct prp_priv *priv = ic_priv->task_priv;\n\tstruct v4l2_subdev *csi;\n\tint ret;\n\n\tret = v4l2_subdev_link_validate_default(sd, link,\n\t\t\t\t\t\tsource_fmt, sink_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tcsi = imx_media_pipeline_subdev(&ic_priv->sd.entity,\n\t\t\t\t\tIMX_MEDIA_GRP_ID_IPU_CSI, true);\n\tif (IS_ERR(csi))\n\t\tcsi = NULL;\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->src_sd->grp_id & IMX_MEDIA_GRP_ID_IPU_VDIC) {\n\t\t \n\t\tif (priv->sink_sd_prpenc) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!csi) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (csi) {\n\t\tswitch (csi->grp_id) {\n\t\tcase IMX_MEDIA_GRP_ID_IPU_CSI0:\n\t\t\tpriv->csi_id = 0;\n\t\t\tbreak;\n\t\tcase IMX_MEDIA_GRP_ID_IPU_CSI1:\n\t\t\tpriv->csi_id = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tpriv->csi_id = 0;\n\t}\n\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int prp_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct imx_ic_priv *ic_priv = v4l2_get_subdevdata(sd);\n\tstruct prp_priv *priv = ic_priv->task_priv;\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tif (!priv->src_sd || (!priv->sink_sd_prpenc && !priv->sink_sd_prpvf)) {\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\t \n\tif (priv->stream_count != !enable)\n\t\tgoto update_count;\n\n\tdev_dbg(ic_priv->ipu_dev, \"%s: stream %s\\n\", sd->name,\n\t\tenable ? \"ON\" : \"OFF\");\n\n\tif (enable)\n\t\tret = prp_start(priv);\n\telse\n\t\tprp_stop(priv);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = v4l2_subdev_call(priv->src_sd, video, s_stream, enable);\n\tret = (ret && ret != -ENOIOCTLCMD) ? ret : 0;\n\tif (ret) {\n\t\tif (enable)\n\t\t\tprp_stop(priv);\n\t\tgoto out;\n\t}\n\nupdate_count:\n\tpriv->stream_count += enable ? 1 : -1;\n\tif (priv->stream_count < 0)\n\t\tpriv->stream_count = 0;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int prp_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_frame_interval *fi)\n{\n\tstruct prp_priv *priv = sd_to_priv(sd);\n\n\tif (fi->pad >= PRP_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\tfi->interval = priv->frame_interval;\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int prp_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_frame_interval *fi)\n{\n\tstruct prp_priv *priv = sd_to_priv(sd);\n\n\tif (fi->pad >= PRP_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tif (fi->interval.numerator == 0 || fi->interval.denominator == 0)\n\t\tfi->interval = priv->frame_interval;\n\telse\n\t\tpriv->frame_interval = fi->interval;\n\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int prp_registered(struct v4l2_subdev *sd)\n{\n\tstruct prp_priv *priv = sd_to_priv(sd);\n\tu32 code;\n\n\t \n\tpriv->frame_interval.numerator = 1;\n\tpriv->frame_interval.denominator = 30;\n\n\t \n\timx_media_enum_ipu_formats(&code, 0, PIXFMT_SEL_YUV);\n\n\treturn imx_media_init_mbus_fmt(&priv->format_mbus,\n\t\t\t\t       IMX_MEDIA_DEF_PIX_WIDTH,\n\t\t\t\t       IMX_MEDIA_DEF_PIX_HEIGHT, code,\n\t\t\t\t       V4L2_FIELD_NONE, NULL);\n}\n\nstatic const struct v4l2_subdev_pad_ops prp_pad_ops = {\n\t.init_cfg = imx_media_init_cfg,\n\t.enum_mbus_code = prp_enum_mbus_code,\n\t.get_fmt = prp_get_fmt,\n\t.set_fmt = prp_set_fmt,\n\t.link_validate = prp_link_validate,\n};\n\nstatic const struct v4l2_subdev_video_ops prp_video_ops = {\n\t.g_frame_interval = prp_g_frame_interval,\n\t.s_frame_interval = prp_s_frame_interval,\n\t.s_stream = prp_s_stream,\n};\n\nstatic const struct media_entity_operations prp_entity_ops = {\n\t.link_setup = prp_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic const struct v4l2_subdev_ops prp_subdev_ops = {\n\t.video = &prp_video_ops,\n\t.pad = &prp_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops prp_internal_ops = {\n\t.registered = prp_registered,\n};\n\nstatic int prp_init(struct imx_ic_priv *ic_priv)\n{\n\tstruct prp_priv *priv;\n\tint i;\n\n\tpriv = devm_kzalloc(ic_priv->ipu_dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->lock);\n\tic_priv->task_priv = priv;\n\tpriv->ic_priv = ic_priv;\n\n\tfor (i = 0; i < PRP_NUM_PADS; i++)\n\t\tpriv->pad[i].flags = (i == PRP_SINK_PAD) ?\n\t\t\tMEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;\n\n\treturn media_entity_pads_init(&ic_priv->sd.entity, PRP_NUM_PADS,\n\t\t\t\t      priv->pad);\n}\n\nstatic void prp_remove(struct imx_ic_priv *ic_priv)\n{\n\tstruct prp_priv *priv = ic_priv->task_priv;\n\n\tmutex_destroy(&priv->lock);\n}\n\nstruct imx_ic_ops imx_ic_prp_ops = {\n\t.subdev_ops = &prp_subdev_ops,\n\t.internal_ops = &prp_internal_ops,\n\t.entity_ops = &prp_entity_ops,\n\t.init = prp_init,\n\t.remove = prp_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}