{
  "module_name": "imx-media-dev-common.c",
  "hash_id": "60d1c6460589247c3cc9a9a865574dfcd2dd2bf5866905c77aacf55c831a690e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/imx/imx-media-dev-common.c",
  "human_readable_source": "\n \n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mc.h>\n#include \"imx-media.h\"\n\nstatic inline struct imx_media_dev *notifier2dev(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct imx_media_dev, notifier);\n}\n\n \nstatic void imx_media_create_csi2_links(struct imx_media_dev *imxmd)\n{\n\tstruct v4l2_subdev *sd, *csi2 = NULL;\n\n\tlist_for_each_entry(sd, &imxmd->v4l2_dev.subdevs, list) {\n\t\tif (sd->grp_id == IMX_MEDIA_GRP_ID_CSI2) {\n\t\t\tcsi2 = sd;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!csi2)\n\t\treturn;\n\n\tlist_for_each_entry(sd, &imxmd->v4l2_dev.subdevs, list) {\n\t\t \n\t\tif (!(sd->grp_id & IMX_MEDIA_GRP_ID_IPU_CSI) &&\n\t\t    !(sd->grp_id & IMX_MEDIA_GRP_ID_CSI_MUX))\n\t\t\tcontinue;\n\n\t\tv4l2_create_fwnode_links(csi2, sd);\n\t}\n}\n\n \nstatic int imx_media_add_vdev_to_pad(struct imx_media_dev *imxmd,\n\t\t\t\t     struct imx_media_video_dev *vdev,\n\t\t\t\t     struct media_pad *srcpad)\n{\n\tstruct media_entity *entity = srcpad->entity;\n\tstruct imx_media_pad_vdev *pad_vdev;\n\tstruct list_head *pad_vdev_list;\n\tstruct media_link *link;\n\tstruct v4l2_subdev *sd;\n\tint i, ret;\n\n\t \n\tif (!is_media_entity_v4l2_subdev(entity))\n\t\treturn 0;\n\n\tsd = media_entity_to_v4l2_subdev(entity);\n\n\tpad_vdev_list = to_pad_vdev_list(sd, srcpad->index);\n\tif (!pad_vdev_list) {\n\t\tv4l2_warn(&imxmd->v4l2_dev, \"%s:%u has no vdev list!\\n\",\n\t\t\t  entity->name, srcpad->index);\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tlist_for_each_entry(pad_vdev, pad_vdev_list, list) {\n\t\tif (pad_vdev->vdev == vdev)\n\t\t\treturn 0;\n\t}\n\n\tdev_dbg(imxmd->md.dev, \"adding %s to pad %s:%u\\n\",\n\t\tvdev->vfd->entity.name, entity->name, srcpad->index);\n\n\tpad_vdev = devm_kzalloc(imxmd->md.dev, sizeof(*pad_vdev), GFP_KERNEL);\n\tif (!pad_vdev)\n\t\treturn -ENOMEM;\n\n\t \n\tpad_vdev->vdev = vdev;\n\tlist_add_tail(&pad_vdev->list, pad_vdev_list);\n\n\t \n\tfor (i = 0; i < entity->num_pads; i++) {\n\t\tstruct media_pad *pad = &entity->pads[i];\n\n\t\tif (!(pad->flags & MEDIA_PAD_FL_SINK))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(link, &entity->links, list) {\n\t\t\tif (link->sink != pad)\n\t\t\t\tcontinue;\n\t\t\tret = imx_media_add_vdev_to_pad(imxmd, vdev,\n\t\t\t\t\t\t\tlink->source);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int imx_media_alloc_pad_vdev_lists(struct imx_media_dev *imxmd)\n{\n\tstruct list_head *vdev_lists;\n\tstruct media_entity *entity;\n\tstruct v4l2_subdev *sd;\n\tint i;\n\n\tlist_for_each_entry(sd, &imxmd->v4l2_dev.subdevs, list) {\n\t\tentity = &sd->entity;\n\t\tvdev_lists = devm_kcalloc(imxmd->md.dev,\n\t\t\t\t\t  entity->num_pads, sizeof(*vdev_lists),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!vdev_lists)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tsd->host_priv = vdev_lists;\n\n\t\tfor (i = 0; i < entity->num_pads; i++)\n\t\t\tINIT_LIST_HEAD(to_pad_vdev_list(sd, i));\n\t}\n\n\treturn 0;\n}\n\n \nstatic int imx_media_create_pad_vdev_lists(struct imx_media_dev *imxmd)\n{\n\tstruct imx_media_video_dev *vdev;\n\tstruct media_link *link;\n\tint ret;\n\n\tret = imx_media_alloc_pad_vdev_lists(imxmd);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_for_each_entry(vdev, &imxmd->vdev_list, list) {\n\t\tlink = list_first_entry(&vdev->vfd->entity.links,\n\t\t\t\t\tstruct media_link, list);\n\t\tret = imx_media_add_vdev_to_pad(imxmd, vdev, link->source);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint imx_media_probe_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct imx_media_dev *imxmd = notifier2dev(notifier);\n\tint ret;\n\n\tmutex_lock(&imxmd->mutex);\n\n\timx_media_create_csi2_links(imxmd);\n\n\tret = imx_media_create_pad_vdev_lists(imxmd);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = v4l2_device_register_subdev_nodes(&imxmd->v4l2_dev);\nunlock:\n\tmutex_unlock(&imxmd->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\treturn media_device_register(&imxmd->md);\n}\nEXPORT_SYMBOL_GPL(imx_media_probe_complete);\n\n \nstatic int imx_media_inherit_controls(struct imx_media_dev *imxmd,\n\t\t\t\t      struct video_device *vfd,\n\t\t\t\t      struct media_entity *entity)\n{\n\tint i, ret = 0;\n\n\tif (is_media_entity_v4l2_subdev(entity)) {\n\t\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\n\t\tdev_dbg(imxmd->md.dev,\n\t\t\t\"adding controls to %s from %s\\n\",\n\t\t\tvfd->entity.name, sd->entity.name);\n\n\t\tret = v4l2_ctrl_add_handler(vfd->ctrl_handler,\n\t\t\t\t\t    sd->ctrl_handler,\n\t\t\t\t\t    NULL, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < entity->num_pads; i++) {\n\t\tstruct media_pad *pad, *spad = &entity->pads[i];\n\n\t\tif (!(spad->flags & MEDIA_PAD_FL_SINK))\n\t\t\tcontinue;\n\n\t\tpad = media_pad_remote_pad_first(spad);\n\t\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\t\tcontinue;\n\n\t\tret = imx_media_inherit_controls(imxmd, vfd, pad->entity);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int imx_media_link_notify(struct media_link *link, u32 flags,\n\t\t\t\t unsigned int notification)\n{\n\tstruct imx_media_dev *imxmd = container_of(link->graph_obj.mdev,\n\t\t\t\t\t\t   struct imx_media_dev, md);\n\tstruct media_entity *source = link->source->entity;\n\tstruct imx_media_pad_vdev *pad_vdev;\n\tstruct list_head *pad_vdev_list;\n\tstruct video_device *vfd;\n\tstruct v4l2_subdev *sd;\n\tint pad_idx, ret;\n\n\tret = v4l2_pipeline_link_notify(link, flags, notification);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!is_media_entity_v4l2_subdev(source))\n\t\treturn 0;\n\n\tsd = media_entity_to_v4l2_subdev(source);\n\tpad_idx = link->source->index;\n\n\tpad_vdev_list = to_pad_vdev_list(sd, pad_idx);\n\tif (!pad_vdev_list) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (notification == MEDIA_DEV_NOTIFY_PRE_LINK_CH &&\n\t    !(flags & MEDIA_LNK_FL_ENABLED)) {\n\t\tlist_for_each_entry(pad_vdev, pad_vdev_list, list) {\n\t\t\tvfd = pad_vdev->vdev->vfd;\n\t\t\tif (!vfd->ctrl_handler)\n\t\t\t\tcontinue;\n\t\t\tdev_dbg(imxmd->md.dev,\n\t\t\t\t\"reset controls for %s\\n\",\n\t\t\t\tvfd->entity.name);\n\t\t\tv4l2_ctrl_handler_free(vfd->ctrl_handler);\n\t\t\tv4l2_ctrl_handler_init(vfd->ctrl_handler, 0);\n\t\t}\n\t} else if (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH &&\n\t\t   (link->flags & MEDIA_LNK_FL_ENABLED)) {\n\t\tlist_for_each_entry(pad_vdev, pad_vdev_list, list) {\n\t\t\tvfd = pad_vdev->vdev->vfd;\n\t\t\tif (!vfd->ctrl_handler)\n\t\t\t\tcontinue;\n\t\t\tdev_dbg(imxmd->md.dev,\n\t\t\t\t\"refresh controls for %s\\n\",\n\t\t\t\tvfd->entity.name);\n\t\t\tret = imx_media_inherit_controls(imxmd, vfd,\n\t\t\t\t\t\t\t &vfd->entity);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void imx_media_notify(struct v4l2_subdev *sd, unsigned int notification,\n\t\t\t     void *arg)\n{\n\tstruct media_entity *entity = &sd->entity;\n\tint i;\n\n\tif (notification != V4L2_DEVICE_NOTIFY_EVENT)\n\t\treturn;\n\n\tfor (i = 0; i < entity->num_pads; i++) {\n\t\tstruct media_pad *pad = &entity->pads[i];\n\t\tstruct imx_media_pad_vdev *pad_vdev;\n\t\tstruct list_head *pad_vdev_list;\n\n\t\tpad_vdev_list = to_pad_vdev_list(sd, pad->index);\n\t\tif (!pad_vdev_list)\n\t\t\tcontinue;\n\t\tlist_for_each_entry(pad_vdev, pad_vdev_list, list)\n\t\t\tv4l2_event_queue(pad_vdev->vdev->vfd, arg);\n\t}\n}\n\nstatic const struct v4l2_async_notifier_operations imx_media_notifier_ops = {\n\t.complete = imx_media_probe_complete,\n};\n\nstatic const struct media_device_ops imx_media_md_ops = {\n\t.link_notify = imx_media_link_notify,\n};\n\nstruct imx_media_dev *imx_media_dev_init(struct device *dev,\n\t\t\t\t\t const struct media_device_ops *ops)\n{\n\tstruct imx_media_dev *imxmd;\n\tint ret;\n\n\timxmd = devm_kzalloc(dev, sizeof(*imxmd), GFP_KERNEL);\n\tif (!imxmd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev_set_drvdata(dev, imxmd);\n\n\tstrscpy(imxmd->md.model, \"imx-media\", sizeof(imxmd->md.model));\n\timxmd->md.ops = ops ? ops : &imx_media_md_ops;\n\timxmd->md.dev = dev;\n\n\tmutex_init(&imxmd->mutex);\n\n\timxmd->v4l2_dev.mdev = &imxmd->md;\n\timxmd->v4l2_dev.notify = imx_media_notify;\n\tstrscpy(imxmd->v4l2_dev.name, \"imx-media\",\n\t\tsizeof(imxmd->v4l2_dev.name));\n\tsnprintf(imxmd->md.bus_info, sizeof(imxmd->md.bus_info),\n\t\t \"platform:%s\", dev_name(imxmd->md.dev));\n\n\tmedia_device_init(&imxmd->md);\n\n\tret = v4l2_device_register(dev, &imxmd->v4l2_dev);\n\tif (ret < 0) {\n\t\tv4l2_err(&imxmd->v4l2_dev,\n\t\t\t \"Failed to register v4l2_device: %d\\n\", ret);\n\t\tgoto cleanup;\n\t}\n\n\tINIT_LIST_HEAD(&imxmd->vdev_list);\n\n\tv4l2_async_nf_init(&imxmd->notifier, &imxmd->v4l2_dev);\n\n\treturn imxmd;\n\ncleanup:\n\tmedia_device_cleanup(&imxmd->md);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(imx_media_dev_init);\n\nint imx_media_dev_notifier_register(struct imx_media_dev *imxmd,\n\t\t\t    const struct v4l2_async_notifier_operations *ops)\n{\n\tint ret;\n\n\t \n\tif (list_empty(&imxmd->notifier.waiting_list)) {\n\t\tv4l2_err(&imxmd->v4l2_dev, \"no subdevs\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\timxmd->notifier.ops = ops ? ops : &imx_media_notifier_ops;\n\tret = v4l2_async_nf_register(&imxmd->notifier);\n\tif (ret) {\n\t\tv4l2_err(&imxmd->v4l2_dev,\n\t\t\t \"v4l2_async_nf_register failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(imx_media_dev_notifier_register);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}