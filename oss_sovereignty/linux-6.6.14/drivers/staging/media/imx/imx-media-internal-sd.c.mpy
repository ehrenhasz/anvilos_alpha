{
  "module_name": "imx-media-internal-sd.c",
  "hash_id": "604d43f8b66ca69b68cb1dda7ef3d08428bb4049fc859266036e31a09688666f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/imx/imx-media-internal-sd.c",
  "human_readable_source": "\n \n#include <linux/platform_device.h>\n#include \"imx-media.h\"\n\n \n#define MAX_INTERNAL_PADS   8\n \n#define MAX_INTERNAL_LINKS  8\n\nstruct internal_subdev;\n\nstruct internal_link {\n\tint remote;\n\tint local_pad;\n\tint remote_pad;\n};\n\nstruct internal_pad {\n\tint num_links;\n\tstruct internal_link link[MAX_INTERNAL_LINKS];\n};\n\nstruct internal_subdev {\n\tu32 grp_id;\n\tstruct internal_pad pad[MAX_INTERNAL_PADS];\n\n\tstruct v4l2_subdev * (*sync_register)(struct v4l2_device *v4l2_dev,\n\t\t\t\t\t      struct device *ipu_dev,\n\t\t\t\t\t      struct ipu_soc *ipu,\n\t\t\t\t\t      u32 grp_id);\n\tint (*sync_unregister)(struct v4l2_subdev *sd);\n};\n\nstatic const struct internal_subdev int_subdev[NUM_IPU_SUBDEVS] = {\n\t[IPU_CSI0] = {\n\t\t.grp_id = IMX_MEDIA_GRP_ID_IPU_CSI0,\n\t\t.pad[CSI_SRC_PAD_DIRECT] = {\n\t\t\t.num_links = 2,\n\t\t\t.link = {\n\t\t\t\t{\n\t\t\t\t\t.local_pad = CSI_SRC_PAD_DIRECT,\n\t\t\t\t\t.remote = IPU_IC_PRP,\n\t\t\t\t\t.remote_pad = PRP_SINK_PAD,\n\t\t\t\t}, {\n\t\t\t\t\t.local_pad = CSI_SRC_PAD_DIRECT,\n\t\t\t\t\t.remote = IPU_VDIC,\n\t\t\t\t\t.remote_pad = VDIC_SINK_PAD_DIRECT,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\n\t[IPU_CSI1] = {\n\t\t.grp_id = IMX_MEDIA_GRP_ID_IPU_CSI1,\n\t\t.pad[CSI_SRC_PAD_DIRECT] = {\n\t\t\t.num_links = 2,\n\t\t\t.link = {\n\t\t\t\t{\n\t\t\t\t\t.local_pad = CSI_SRC_PAD_DIRECT,\n\t\t\t\t\t.remote = IPU_IC_PRP,\n\t\t\t\t\t.remote_pad = PRP_SINK_PAD,\n\t\t\t\t}, {\n\t\t\t\t\t.local_pad = CSI_SRC_PAD_DIRECT,\n\t\t\t\t\t.remote = IPU_VDIC,\n\t\t\t\t\t.remote_pad = VDIC_SINK_PAD_DIRECT,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\n\t[IPU_VDIC] = {\n\t\t.grp_id = IMX_MEDIA_GRP_ID_IPU_VDIC,\n\t\t.sync_register = imx_media_vdic_register,\n\t\t.sync_unregister = imx_media_vdic_unregister,\n\t\t.pad[VDIC_SRC_PAD_DIRECT] = {\n\t\t\t.num_links = 1,\n\t\t\t.link = {\n\t\t\t\t{\n\t\t\t\t\t.local_pad = VDIC_SRC_PAD_DIRECT,\n\t\t\t\t\t.remote = IPU_IC_PRP,\n\t\t\t\t\t.remote_pad = PRP_SINK_PAD,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\n\t[IPU_IC_PRP] = {\n\t\t.grp_id = IMX_MEDIA_GRP_ID_IPU_IC_PRP,\n\t\t.sync_register = imx_media_ic_register,\n\t\t.sync_unregister = imx_media_ic_unregister,\n\t\t.pad[PRP_SRC_PAD_PRPENC] = {\n\t\t\t.num_links = 1,\n\t\t\t.link = {\n\t\t\t\t{\n\t\t\t\t\t.local_pad = PRP_SRC_PAD_PRPENC,\n\t\t\t\t\t.remote = IPU_IC_PRPENC,\n\t\t\t\t\t.remote_pad = PRPENCVF_SINK_PAD,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.pad[PRP_SRC_PAD_PRPVF] = {\n\t\t\t.num_links = 1,\n\t\t\t.link = {\n\t\t\t\t{\n\t\t\t\t\t.local_pad = PRP_SRC_PAD_PRPVF,\n\t\t\t\t\t.remote = IPU_IC_PRPVF,\n\t\t\t\t\t.remote_pad = PRPENCVF_SINK_PAD,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\n\t[IPU_IC_PRPENC] = {\n\t\t.grp_id = IMX_MEDIA_GRP_ID_IPU_IC_PRPENC,\n\t\t.sync_register = imx_media_ic_register,\n\t\t.sync_unregister = imx_media_ic_unregister,\n\t},\n\n\t[IPU_IC_PRPVF] = {\n\t\t.grp_id = IMX_MEDIA_GRP_ID_IPU_IC_PRPVF,\n\t\t.sync_register = imx_media_ic_register,\n\t\t.sync_unregister = imx_media_ic_unregister,\n\t},\n};\n\nstatic int create_internal_link(struct imx_media_dev *imxmd,\n\t\t\t\tstruct v4l2_subdev *src,\n\t\t\t\tstruct v4l2_subdev *sink,\n\t\t\t\tconst struct internal_link *link)\n{\n\tint ret;\n\n\t \n\tif (media_entity_find_link(&src->entity.pads[link->local_pad],\n\t\t\t\t   &sink->entity.pads[link->remote_pad]))\n\t\treturn 0;\n\n\tdev_dbg(imxmd->md.dev, \"%s:%d -> %s:%d\\n\",\n\t\tsrc->name, link->local_pad,\n\t\tsink->name, link->remote_pad);\n\n\tret = media_create_pad_link(&src->entity, link->local_pad,\n\t\t\t\t    &sink->entity, link->remote_pad, 0);\n\tif (ret)\n\t\tv4l2_err(&imxmd->v4l2_dev, \"%s failed: %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic int create_ipu_internal_links(struct imx_media_dev *imxmd,\n\t\t\t\t     const struct internal_subdev *intsd,\n\t\t\t\t     struct v4l2_subdev *sd,\n\t\t\t\t     int ipu_id)\n{\n\tconst struct internal_pad *intpad;\n\tconst struct internal_link *link;\n\tstruct media_pad *pad;\n\tint i, j, ret;\n\n\t \n\tfor (i = 0; i < sd->entity.num_pads; i++) {\n\t\tintpad = &intsd->pad[i];\n\t\tpad = &sd->entity.pads[i];\n\n\t\tif (!(pad->flags & MEDIA_PAD_FL_SOURCE))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < intpad->num_links; j++) {\n\t\t\tstruct v4l2_subdev *sink;\n\n\t\t\tlink = &intpad->link[j];\n\t\t\tsink = imxmd->sync_sd[ipu_id][link->remote];\n\n\t\t\tret = create_internal_link(imxmd, sd, sink, link);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint imx_media_register_ipu_internal_subdevs(struct imx_media_dev *imxmd,\n\t\t\t\t\t    struct v4l2_subdev *csi)\n{\n\tstruct device *ipu_dev = csi->dev->parent;\n\tconst struct internal_subdev *intsd;\n\tstruct v4l2_subdev *sd;\n\tstruct ipu_soc *ipu;\n\tint i, ipu_id, ret;\n\n\tipu = dev_get_drvdata(ipu_dev);\n\tif (!ipu) {\n\t\tv4l2_err(&imxmd->v4l2_dev, \"invalid IPU device!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tipu_id = ipu_get_num(ipu);\n\tif (ipu_id > 1) {\n\t\tv4l2_err(&imxmd->v4l2_dev, \"invalid IPU id %d!\\n\", ipu_id);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&imxmd->mutex);\n\n\t \n\tif (!imxmd->ipu[ipu_id])\n\t\timxmd->ipu[ipu_id] = ipu;\n\n\t \n\tfor (i = 0; i < NUM_IPU_SUBDEVS; i++) {\n\t\tintsd = &int_subdev[i];\n\n\t\tsd = imxmd->sync_sd[ipu_id][i];\n\n\t\t \n\t\tif (sd || !intsd->sync_register)\n\t\t\tcontinue;\n\n\t\tmutex_unlock(&imxmd->mutex);\n\t\tsd = intsd->sync_register(&imxmd->v4l2_dev, ipu_dev, ipu,\n\t\t\t\t\t  intsd->grp_id);\n\t\tmutex_lock(&imxmd->mutex);\n\t\tif (IS_ERR(sd)) {\n\t\t\tret = PTR_ERR(sd);\n\t\t\tgoto err_unwind;\n\t\t}\n\n\t\timxmd->sync_sd[ipu_id][i] = sd;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_IPU_SUBDEVS; i++) {\n\t\tintsd = &int_subdev[i];\n\n\t\tif (intsd->grp_id == csi->grp_id) {\n\t\t\tsd = csi;\n\t\t} else {\n\t\t\tsd = imxmd->sync_sd[ipu_id][i];\n\t\t\tif (!sd)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tret = create_ipu_internal_links(imxmd, intsd, sd, ipu_id);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&imxmd->mutex);\n\t\t\timx_media_unregister_ipu_internal_subdevs(imxmd);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_unlock(&imxmd->mutex);\n\treturn 0;\n\nerr_unwind:\n\twhile (--i >= 0) {\n\t\tintsd = &int_subdev[i];\n\t\tsd = imxmd->sync_sd[ipu_id][i];\n\t\tif (!sd || !intsd->sync_unregister)\n\t\t\tcontinue;\n\t\tmutex_unlock(&imxmd->mutex);\n\t\tintsd->sync_unregister(sd);\n\t\tmutex_lock(&imxmd->mutex);\n\t}\n\n\tmutex_unlock(&imxmd->mutex);\n\treturn ret;\n}\n\nvoid imx_media_unregister_ipu_internal_subdevs(struct imx_media_dev *imxmd)\n{\n\tconst struct internal_subdev *intsd;\n\tstruct v4l2_subdev *sd;\n\tint i, j;\n\n\tmutex_lock(&imxmd->mutex);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < NUM_IPU_SUBDEVS; j++) {\n\t\t\tintsd = &int_subdev[j];\n\t\t\tsd = imxmd->sync_sd[i][j];\n\n\t\t\tif (!sd || !intsd->sync_unregister)\n\t\t\t\tcontinue;\n\n\t\t\tmutex_unlock(&imxmd->mutex);\n\t\t\tintsd->sync_unregister(sd);\n\t\t\tmutex_lock(&imxmd->mutex);\n\t\t}\n\t}\n\n\tmutex_unlock(&imxmd->mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}