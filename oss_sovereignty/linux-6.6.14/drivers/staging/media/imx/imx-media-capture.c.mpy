{
  "module_name": "imx-media-capture.c",
  "hash_id": "af9f164d44638f51aaf0c348aa7bc68aee26da37f00728a808b4c174d0ce004b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/imx/imx-media-capture.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-dma-contig.h>\n#include <video/imx-ipu-v3.h>\n#include <media/imx.h>\n#include \"imx-media.h\"\n\n#define IMX_CAPTURE_NAME \"imx-capture\"\n\nstruct capture_priv {\n\tstruct imx_media_dev *md;\t\t \n\tstruct device *dev;\t\t\t \n\n\tstruct imx_media_video_dev vdev;\t \n\tstruct media_pad vdev_pad;\t\t \n\n\tstruct v4l2_subdev *src_sd;\t\t \n\tint src_sd_pad;\t\t\t\t \n\n\tstruct mutex mutex;\t\t\t \n\n\tstruct vb2_queue q;\t\t\t \n\tstruct list_head ready_q;\t\t \n\tspinlock_t q_lock;\t\t\t \n\n\tstruct v4l2_ctrl_handler ctrl_hdlr;\t \n\n\tbool legacy_api;\t\t\t \n};\n\n#define to_capture_priv(v) container_of(v, struct capture_priv, vdev)\n\n \n#define VID_MEM_LIMIT\tSZ_64M\n\n \n\nstatic const struct imx_media_pixfmt *capture_find_format(u32 code, u32 fourcc)\n{\n\tconst struct imx_media_pixfmt *cc;\n\n\tcc = imx_media_find_ipu_format(code, PIXFMT_SEL_YUV_RGB);\n\tif (cc) {\n\t\tenum imx_pixfmt_sel fmt_sel = cc->cs == IPUV3_COLORSPACE_YUV\n\t\t\t\t\t    ? PIXFMT_SEL_YUV : PIXFMT_SEL_RGB;\n\n\t\tcc = imx_media_find_pixel_format(fourcc, fmt_sel);\n\t\tif (!cc) {\n\t\t\timx_media_enum_pixel_formats(&fourcc, 0, fmt_sel, 0);\n\t\t\tcc = imx_media_find_pixel_format(fourcc, fmt_sel);\n\t\t}\n\n\t\treturn cc;\n\t}\n\n\treturn imx_media_find_mbus_format(code, PIXFMT_SEL_ANY);\n}\n\nstatic int capture_querycap(struct file *file, void *fh,\n\t\t\t    struct v4l2_capability *cap)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\n\tstrscpy(cap->driver, IMX_CAPTURE_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, IMX_CAPTURE_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:%s\", dev_name(priv->dev));\n\n\treturn 0;\n}\n\nstatic int capture_enum_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_fmtdesc *f)\n{\n\treturn imx_media_enum_pixel_formats(&f->pixelformat, f->index,\n\t\t\t\t\t    PIXFMT_SEL_ANY, f->mbus_code);\n}\n\nstatic int capture_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_frmsizeenum *fsize)\n{\n\tconst struct imx_media_pixfmt *cc;\n\n\tif (fsize->index > 0)\n\t\treturn -EINVAL;\n\n\tcc = imx_media_find_pixel_format(fsize->pixel_format, PIXFMT_SEL_ANY);\n\tif (!cc)\n\t\treturn -EINVAL;\n\n\t \n\tfsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\tfsize->stepwise.min_width = 1;\n\tfsize->stepwise.max_width = 65535;\n\tfsize->stepwise.min_height = 1;\n\tfsize->stepwise.max_height = 65535;\n\tfsize->stepwise.step_width = 1;\n\tfsize->stepwise.step_height = 1;\n\n\treturn 0;\n}\n\nstatic int capture_g_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\n\tf->fmt.pix = priv->vdev.fmt;\n\n\treturn 0;\n}\n\nstatic const struct imx_media_pixfmt *\n__capture_try_fmt(struct v4l2_pix_format *pixfmt, struct v4l2_rect *compose)\n{\n\tstruct v4l2_mbus_framefmt fmt_src;\n\tconst struct imx_media_pixfmt *cc;\n\n\t \n\tcc = imx_media_find_pixel_format(pixfmt->pixelformat, PIXFMT_SEL_ANY);\n\tif (!cc) {\n\t\timx_media_enum_pixel_formats(&pixfmt->pixelformat, 0,\n\t\t\t\t\t     PIXFMT_SEL_ANY, 0);\n\t\tcc = imx_media_find_pixel_format(pixfmt->pixelformat,\n\t\t\t\t\t\t PIXFMT_SEL_ANY);\n\t}\n\n\t \n\tif (V4L2_FIELD_IS_INTERLACED(pixfmt->field)) {\n\t\tswitch (pixfmt->field) {\n\t\tcase V4L2_FIELD_SEQ_TB:\n\t\t\tpixfmt->field = V4L2_FIELD_INTERLACED_TB;\n\t\t\tbreak;\n\t\tcase V4L2_FIELD_SEQ_BT:\n\t\t\tpixfmt->field = V4L2_FIELD_INTERLACED_BT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tv4l2_fill_mbus_format(&fmt_src, pixfmt, 0);\n\timx_media_mbus_fmt_to_pix_fmt(pixfmt, &fmt_src, cc);\n\n\tif (compose) {\n\t\tcompose->width = fmt_src.width;\n\t\tcompose->height = fmt_src.height;\n\t}\n\n\treturn cc;\n}\n\nstatic int capture_try_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_format *f)\n{\n\t__capture_try_fmt(&f->fmt.pix, NULL);\n\treturn 0;\n}\n\nstatic int capture_s_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\tconst struct imx_media_pixfmt *cc;\n\n\tif (vb2_is_busy(&priv->q)) {\n\t\tdev_err(priv->dev, \"%s queue busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tcc = __capture_try_fmt(&f->fmt.pix, &priv->vdev.compose);\n\n\tpriv->vdev.cc = cc;\n\tpriv->vdev.fmt = f->fmt.pix;\n\n\treturn 0;\n}\n\nstatic int capture_g_selection(struct file *file, void *fh,\n\t\t\t       struct v4l2_selection *s)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\t \n\t\ts->r = priv->vdev.compose;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_PADDED:\n\t\t \n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = priv->vdev.fmt.width;\n\t\ts->r.height = priv->vdev.fmt.height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int capture_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t   const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_IMX_FRAME_INTERVAL_ERROR:\n\t\treturn v4l2_event_subscribe(fh, sub, 0, NULL);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_ioctl_ops capture_ioctl_ops = {\n\t.vidioc_querycap\t\t= capture_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= capture_enum_fmt_vid_cap,\n\t.vidioc_enum_framesizes\t\t= capture_enum_framesizes,\n\n\t.vidioc_g_fmt_vid_cap\t\t= capture_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= capture_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= capture_s_fmt_vid_cap,\n\n\t.vidioc_g_selection\t\t= capture_g_selection,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\n\t.vidioc_subscribe_event\t\t= capture_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\n \n\nstatic int capture_legacy_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\tconst struct imx_media_pixfmt *cc;\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.index = fsize->index,\n\t\t.pad = priv->src_sd_pad,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tcc = imx_media_find_pixel_format(fsize->pixel_format, PIXFMT_SEL_ANY);\n\tif (!cc)\n\t\treturn -EINVAL;\n\n\tfse.code = cc->codes ? cc->codes[0] : 0;\n\n\tret = v4l2_subdev_call(priv->src_sd, pad, enum_frame_size, NULL, &fse);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fse.min_width == fse.max_width &&\n\t    fse.min_height == fse.max_height) {\n\t\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\t\tfsize->discrete.width = fse.min_width;\n\t\tfsize->discrete.height = fse.min_height;\n\t} else {\n\t\tfsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\t\tfsize->stepwise.min_width = fse.min_width;\n\t\tfsize->stepwise.max_width = fse.max_width;\n\t\tfsize->stepwise.min_height = fse.min_height;\n\t\tfsize->stepwise.max_height = fse.max_height;\n\t\tfsize->stepwise.step_width = 1;\n\t\tfsize->stepwise.step_height = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int capture_legacy_enum_frameintervals(struct file *file, void *fh,\n\t\t\t\t\t      struct v4l2_frmivalenum *fival)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\tconst struct imx_media_pixfmt *cc;\n\tstruct v4l2_subdev_frame_interval_enum fie = {\n\t\t.index = fival->index,\n\t\t.pad = priv->src_sd_pad,\n\t\t.width = fival->width,\n\t\t.height = fival->height,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tcc = imx_media_find_pixel_format(fival->pixel_format, PIXFMT_SEL_ANY);\n\tif (!cc)\n\t\treturn -EINVAL;\n\n\tfie.code = cc->codes ? cc->codes[0] : 0;\n\n\tret = v4l2_subdev_call(priv->src_sd, pad, enum_frame_interval,\n\t\t\t       NULL, &fie);\n\tif (ret)\n\t\treturn ret;\n\n\tfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tfival->discrete = fie.interval;\n\n\treturn 0;\n}\n\nstatic int capture_legacy_enum_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\tconst struct imx_media_pixfmt *cc_src;\n\tstruct v4l2_subdev_format fmt_src = {\n\t\t.pad = priv->src_sd_pad,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tu32 fourcc;\n\tint ret;\n\n\tret = v4l2_subdev_call(priv->src_sd, pad, get_fmt, NULL, &fmt_src);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to get src_sd format\\n\");\n\t\treturn ret;\n\t}\n\n\tcc_src = imx_media_find_ipu_format(fmt_src.format.code,\n\t\t\t\t\t   PIXFMT_SEL_YUV_RGB);\n\tif (cc_src) {\n\t\tenum imx_pixfmt_sel fmt_sel =\n\t\t\t(cc_src->cs == IPUV3_COLORSPACE_YUV) ?\n\t\t\tPIXFMT_SEL_YUV : PIXFMT_SEL_RGB;\n\n\t\tret = imx_media_enum_pixel_formats(&fourcc, f->index, fmt_sel,\n\t\t\t\t\t\t   0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tcc_src = imx_media_find_mbus_format(fmt_src.format.code,\n\t\t\t\t\t\t    PIXFMT_SEL_ANY);\n\t\tif (WARN_ON(!cc_src))\n\t\t\treturn -EINVAL;\n\n\t\tif (f->index != 0)\n\t\t\treturn -EINVAL;\n\t\tfourcc = cc_src->fourcc;\n\t}\n\n\tf->pixelformat = fourcc;\n\n\treturn 0;\n}\n\nstatic const struct imx_media_pixfmt *\n__capture_legacy_try_fmt(struct capture_priv *priv,\n\t\t\t struct v4l2_subdev_format *fmt_src,\n\t\t\t struct v4l2_pix_format *pixfmt)\n{\n\tconst struct imx_media_pixfmt *cc;\n\n\tcc = capture_find_format(fmt_src->format.code, pixfmt->pixelformat);\n\tif (WARN_ON(!cc))\n\t\treturn NULL;\n\n\t \n\tif (V4L2_FIELD_IS_INTERLACED(pixfmt->field)) {\n\t\tswitch (fmt_src->format.field) {\n\t\tcase V4L2_FIELD_SEQ_TB:\n\t\t\tfmt_src->format.field = V4L2_FIELD_INTERLACED_TB;\n\t\t\tbreak;\n\t\tcase V4L2_FIELD_SEQ_BT:\n\t\t\tfmt_src->format.field = V4L2_FIELD_INTERLACED_BT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\timx_media_mbus_fmt_to_pix_fmt(pixfmt, &fmt_src->format, cc);\n\n\treturn cc;\n}\n\nstatic int capture_legacy_try_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\tstruct v4l2_subdev_format fmt_src = {\n\t\t.pad = priv->src_sd_pad,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tret = v4l2_subdev_call(priv->src_sd, pad, get_fmt, NULL, &fmt_src);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!__capture_legacy_try_fmt(priv, &fmt_src, &f->fmt.pix))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int capture_legacy_s_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\tstruct v4l2_subdev_format fmt_src = {\n\t\t.pad = priv->src_sd_pad,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tconst struct imx_media_pixfmt *cc;\n\tint ret;\n\n\tif (vb2_is_busy(&priv->q)) {\n\t\tdev_err(priv->dev, \"%s queue busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tret = v4l2_subdev_call(priv->src_sd, pad, get_fmt, NULL, &fmt_src);\n\tif (ret)\n\t\treturn ret;\n\n\tcc = __capture_legacy_try_fmt(priv, &fmt_src, &f->fmt.pix);\n\tif (!cc)\n\t\treturn -EINVAL;\n\n\tpriv->vdev.cc = cc;\n\tpriv->vdev.fmt = f->fmt.pix;\n\tpriv->vdev.compose.width = fmt_src.format.width;\n\tpriv->vdev.compose.height = fmt_src.format.height;\n\n\treturn 0;\n}\n\nstatic int capture_legacy_querystd(struct file *file, void *fh,\n\t\t\t\t   v4l2_std_id *std)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\n\treturn v4l2_subdev_call(priv->src_sd, video, querystd, std);\n}\n\nstatic int capture_legacy_g_std(struct file *file, void *fh, v4l2_std_id *std)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\n\treturn v4l2_subdev_call(priv->src_sd, video, g_std, std);\n}\n\nstatic int capture_legacy_s_std(struct file *file, void *fh, v4l2_std_id std)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\n\tif (vb2_is_busy(&priv->q))\n\t\treturn -EBUSY;\n\n\treturn v4l2_subdev_call(priv->src_sd, video, s_std, std);\n}\n\nstatic int capture_legacy_g_parm(struct file *file, void *fh,\n\t\t\t\t struct v4l2_streamparm *a)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\tstruct v4l2_subdev_frame_interval fi = {\n\t\t.pad = priv->src_sd_pad,\n\t};\n\tint ret;\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tret = v4l2_subdev_call(priv->src_sd, video, g_frame_interval, &fi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ta->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\ta->parm.capture.timeperframe = fi.interval;\n\n\treturn 0;\n}\n\nstatic int capture_legacy_s_parm(struct file *file, void *fh,\n\t\t\t\t struct v4l2_streamparm *a)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\tstruct v4l2_subdev_frame_interval fi = {\n\t\t.pad = priv->src_sd_pad,\n\t};\n\tint ret;\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tfi.interval = a->parm.capture.timeperframe;\n\tret = v4l2_subdev_call(priv->src_sd, video, s_frame_interval, &fi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ta->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\ta->parm.capture.timeperframe = fi.interval;\n\n\treturn 0;\n}\n\nstatic int capture_legacy_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t\t  const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_IMX_FRAME_INTERVAL_ERROR:\n\t\treturn v4l2_event_subscribe(fh, sub, 0, NULL);\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_src_change_event_subscribe(fh, sub);\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_ioctl_ops capture_legacy_ioctl_ops = {\n\t.vidioc_querycap\t\t= capture_querycap,\n\n\t.vidioc_enum_framesizes\t\t= capture_legacy_enum_framesizes,\n\t.vidioc_enum_frameintervals\t= capture_legacy_enum_frameintervals,\n\n\t.vidioc_enum_fmt_vid_cap\t= capture_legacy_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= capture_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= capture_legacy_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= capture_legacy_s_fmt_vid_cap,\n\n\t.vidioc_querystd\t\t= capture_legacy_querystd,\n\t.vidioc_g_std\t\t\t= capture_legacy_g_std,\n\t.vidioc_s_std\t\t\t= capture_legacy_s_std,\n\n\t.vidioc_g_selection\t\t= capture_g_selection,\n\n\t.vidioc_g_parm\t\t\t= capture_legacy_g_parm,\n\t.vidioc_s_parm\t\t\t= capture_legacy_s_parm,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\n\t.vidioc_subscribe_event\t\t= capture_legacy_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\n \n\nstatic int capture_queue_setup(struct vb2_queue *vq,\n\t\t\t       unsigned int *nbuffers,\n\t\t\t       unsigned int *nplanes,\n\t\t\t       unsigned int sizes[],\n\t\t\t       struct device *alloc_devs[])\n{\n\tstruct capture_priv *priv = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format *pix = &priv->vdev.fmt;\n\tunsigned int count = *nbuffers;\n\n\tif (vq->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (*nplanes) {\n\t\tif (*nplanes != 1 || sizes[0] < pix->sizeimage)\n\t\t\treturn -EINVAL;\n\t\tcount += vq->num_buffers;\n\t}\n\n\tcount = min_t(__u32, VID_MEM_LIMIT / pix->sizeimage, count);\n\n\tif (*nplanes)\n\t\t*nbuffers = (count < vq->num_buffers) ? 0 :\n\t\t\tcount - vq->num_buffers;\n\telse\n\t\t*nbuffers = count;\n\n\t*nplanes = 1;\n\tsizes[0] = pix->sizeimage;\n\n\treturn 0;\n}\n\nstatic int capture_buf_init(struct vb2_buffer *vb)\n{\n\tstruct imx_media_buffer *buf = to_imx_media_vb(vb);\n\n\tINIT_LIST_HEAD(&buf->list);\n\n\treturn 0;\n}\n\nstatic int capture_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct capture_priv *priv = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format *pix = &priv->vdev.fmt;\n\n\tif (vb2_plane_size(vb, 0) < pix->sizeimage) {\n\t\tdev_err(priv->dev,\n\t\t\t\"data will not fit into plane (%lu < %lu)\\n\",\n\t\t\tvb2_plane_size(vb, 0), (long)pix->sizeimage);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, pix->sizeimage);\n\n\treturn 0;\n}\n\nstatic void capture_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct capture_priv *priv = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct imx_media_buffer *buf = to_imx_media_vb(vb);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->q_lock, flags);\n\n\tlist_add_tail(&buf->list, &priv->ready_q);\n\n\tspin_unlock_irqrestore(&priv->q_lock, flags);\n}\n\nstatic int capture_validate_fmt(struct capture_priv *priv)\n{\n\tstruct v4l2_subdev_format fmt_src = {\n\t\t.pad = priv->src_sd_pad,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tconst struct imx_media_pixfmt *cc;\n\tint ret;\n\n\t \n\tret = v4l2_subdev_call(priv->src_sd, pad, get_fmt, NULL, &fmt_src);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (priv->vdev.compose.width != fmt_src.format.width ||\n\t    priv->vdev.compose.height != fmt_src.format.height)\n\t\treturn -EPIPE;\n\n\t \n\tcc = capture_find_format(fmt_src.format.code, 0);\n\tif (!cc || priv->vdev.cc->cs != cc->cs)\n\t\treturn -EPIPE;\n\n\treturn 0;\n}\n\nstatic int capture_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct capture_priv *priv = vb2_get_drv_priv(vq);\n\tstruct imx_media_buffer *buf, *tmp;\n\tunsigned long flags;\n\tint ret;\n\n\tret = capture_validate_fmt(priv);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"capture format not valid\\n\");\n\t\tgoto return_bufs;\n\t}\n\n\tret = imx_media_pipeline_set_stream(priv->md, &priv->src_sd->entity,\n\t\t\t\t\t    true);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"pipeline start failed with %d\\n\", ret);\n\t\tgoto return_bufs;\n\t}\n\n\treturn 0;\n\nreturn_bufs:\n\tspin_lock_irqsave(&priv->q_lock, flags);\n\tlist_for_each_entry_safe(buf, tmp, &priv->ready_q, list) {\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vbuf.vb2_buf, VB2_BUF_STATE_QUEUED);\n\t}\n\tspin_unlock_irqrestore(&priv->q_lock, flags);\n\treturn ret;\n}\n\nstatic void capture_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct capture_priv *priv = vb2_get_drv_priv(vq);\n\tstruct imx_media_buffer *frame;\n\tstruct imx_media_buffer *tmp;\n\tunsigned long flags;\n\tint ret;\n\n\tret = imx_media_pipeline_set_stream(priv->md, &priv->src_sd->entity,\n\t\t\t\t\t    false);\n\tif (ret)\n\t\tdev_warn(priv->dev, \"pipeline stop failed with %d\\n\", ret);\n\n\t \n\tspin_lock_irqsave(&priv->q_lock, flags);\n\tlist_for_each_entry_safe(frame, tmp, &priv->ready_q, list) {\n\t\tlist_del(&frame->list);\n\t\tvb2_buffer_done(&frame->vbuf.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&priv->q_lock, flags);\n}\n\nstatic const struct vb2_ops capture_qops = {\n\t.queue_setup\t = capture_queue_setup,\n\t.buf_init        = capture_buf_init,\n\t.buf_prepare\t = capture_buf_prepare,\n\t.buf_queue\t = capture_buf_queue,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n\t.start_streaming = capture_start_streaming,\n\t.stop_streaming  = capture_stop_streaming,\n};\n\n \n\nstatic int capture_open(struct file *file)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\tstruct video_device *vfd = priv->vdev.vfd;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&priv->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tret = v4l2_fh_open(file);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"v4l2_fh_open failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = v4l2_pipeline_pm_get(&vfd->entity);\n\tif (ret)\n\t\tv4l2_fh_release(file);\n\nout:\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\nstatic int capture_release(struct file *file)\n{\n\tstruct capture_priv *priv = video_drvdata(file);\n\tstruct video_device *vfd = priv->vdev.vfd;\n\tstruct vb2_queue *vq = &priv->q;\n\n\tmutex_lock(&priv->mutex);\n\n\tif (file->private_data == vq->owner) {\n\t\tvb2_queue_release(vq);\n\t\tvq->owner = NULL;\n\t}\n\n\tv4l2_pipeline_pm_put(&vfd->entity);\n\n\tv4l2_fh_release(file);\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations capture_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= capture_open,\n\t.release\t= capture_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= vb2_fop_mmap,\n};\n\n \n\nstruct imx_media_buffer *\nimx_media_capture_device_next_buf(struct imx_media_video_dev *vdev)\n{\n\tstruct capture_priv *priv = to_capture_priv(vdev);\n\tstruct imx_media_buffer *buf = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->q_lock, flags);\n\n\t \n\tif (!list_empty(&priv->ready_q)) {\n\t\tbuf = list_entry(priv->ready_q.next, struct imx_media_buffer,\n\t\t\t\t list);\n\t\tlist_del(&buf->list);\n\t}\n\n\tspin_unlock_irqrestore(&priv->q_lock, flags);\n\n\treturn buf;\n}\nEXPORT_SYMBOL_GPL(imx_media_capture_device_next_buf);\n\nvoid imx_media_capture_device_error(struct imx_media_video_dev *vdev)\n{\n\tstruct capture_priv *priv = to_capture_priv(vdev);\n\tstruct vb2_queue *vq = &priv->q;\n\tunsigned long flags;\n\n\tif (!vb2_is_streaming(vq))\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->q_lock, flags);\n\tvb2_queue_error(vq);\n\tspin_unlock_irqrestore(&priv->q_lock, flags);\n}\nEXPORT_SYMBOL_GPL(imx_media_capture_device_error);\n\nstatic int capture_init_format(struct capture_priv *priv)\n{\n\tstruct v4l2_subdev_format fmt_src = {\n\t\t.pad = priv->src_sd_pad,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct imx_media_video_dev *vdev = &priv->vdev;\n\tint ret;\n\n\tif (priv->legacy_api) {\n\t\tret = v4l2_subdev_call(priv->src_sd, pad, get_fmt, NULL,\n\t\t\t\t       &fmt_src);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"failed to get source format\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tfmt_src.format.code = MEDIA_BUS_FMT_UYVY8_2X8;\n\t\tfmt_src.format.width = IMX_MEDIA_DEF_PIX_WIDTH;\n\t\tfmt_src.format.height = IMX_MEDIA_DEF_PIX_HEIGHT;\n\t}\n\n\timx_media_mbus_fmt_to_pix_fmt(&vdev->fmt, &fmt_src.format, NULL);\n\tvdev->compose.width = fmt_src.format.width;\n\tvdev->compose.height = fmt_src.format.height;\n\n\tvdev->cc = imx_media_find_pixel_format(vdev->fmt.pixelformat,\n\t\t\t\t\t       PIXFMT_SEL_ANY);\n\n\treturn 0;\n}\n\nint imx_media_capture_device_register(struct imx_media_video_dev *vdev,\n\t\t\t\t      u32 link_flags)\n{\n\tstruct capture_priv *priv = to_capture_priv(vdev);\n\tstruct v4l2_subdev *sd = priv->src_sd;\n\tstruct v4l2_device *v4l2_dev = sd->v4l2_dev;\n\tstruct video_device *vfd = vdev->vfd;\n\tint ret;\n\n\t \n\tpriv->md = container_of(v4l2_dev->mdev, struct imx_media_dev, md);\n\n\tvfd->v4l2_dev = v4l2_dev;\n\n\t \n\tret = capture_init_format(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to register video device\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(priv->dev, \"Registered %s as /dev/%s\\n\", vfd->name,\n\t\t video_device_node_name(vfd));\n\n\t \n\tif (link_flags & MEDIA_LNK_FL_IMMUTABLE)\n\t\tlink_flags |= MEDIA_LNK_FL_ENABLED;\n\tret = media_create_pad_link(&sd->entity, priv->src_sd_pad,\n\t\t\t\t    &vfd->entity, 0, link_flags);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to create link to device node\\n\");\n\t\tvideo_unregister_device(vfd);\n\t\treturn ret;\n\t}\n\n\t \n\timx_media_add_video_device(priv->md, vdev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(imx_media_capture_device_register);\n\nvoid imx_media_capture_device_unregister(struct imx_media_video_dev *vdev)\n{\n\tstruct capture_priv *priv = to_capture_priv(vdev);\n\tstruct video_device *vfd = priv->vdev.vfd;\n\n\tmedia_entity_cleanup(&vfd->entity);\n\tvideo_unregister_device(vfd);\n}\nEXPORT_SYMBOL_GPL(imx_media_capture_device_unregister);\n\nstruct imx_media_video_dev *\nimx_media_capture_device_init(struct device *dev, struct v4l2_subdev *src_sd,\n\t\t\t      int pad, bool legacy_api)\n{\n\tstruct capture_priv *priv;\n\tstruct video_device *vfd;\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpriv->src_sd = src_sd;\n\tpriv->src_sd_pad = pad;\n\tpriv->dev = dev;\n\tpriv->legacy_api = legacy_api;\n\n\tmutex_init(&priv->mutex);\n\tINIT_LIST_HEAD(&priv->ready_q);\n\tspin_lock_init(&priv->q_lock);\n\n\t \n\tvfd = video_device_alloc();\n\tif (!vfd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvfd->fops = &capture_fops;\n\tvfd->ioctl_ops = legacy_api ? &capture_legacy_ioctl_ops\n\t\t       : &capture_ioctl_ops;\n\tvfd->minor = -1;\n\tvfd->release = video_device_release;\n\tvfd->vfl_dir = VFL_DIR_RX;\n\tvfd->tvnorms = V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM;\n\tvfd->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING\n\t\t\t | (!legacy_api ? V4L2_CAP_IO_MC : 0);\n\tvfd->lock = &priv->mutex;\n\tvfd->queue = &priv->q;\n\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s capture\", src_sd->name);\n\n\tvideo_set_drvdata(vfd, priv);\n\tpriv->vdev.vfd = vfd;\n\tINIT_LIST_HEAD(&priv->vdev.list);\n\n\t \n\tpriv->vdev_pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&vfd->entity, 1, &priv->vdev_pad);\n\tif (ret) {\n\t\tvideo_device_release(vfd);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tvq = &priv->q;\n\tvq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tvq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tvq->drv_priv = priv;\n\tvq->buf_struct_size = sizeof(struct imx_media_buffer);\n\tvq->ops = &capture_qops;\n\tvq->mem_ops = &vb2_dma_contig_memops;\n\tvq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tvq->lock = &priv->mutex;\n\tvq->min_buffers_needed = 2;\n\tvq->dev = priv->dev;\n\n\tret = vb2_queue_init(vq);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"vb2_queue_init failed\\n\");\n\t\tvideo_device_release(vfd);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (legacy_api) {\n\t\t \n\t\tv4l2_ctrl_handler_init(&priv->ctrl_hdlr, 0);\n\t\tvfd->ctrl_handler = &priv->ctrl_hdlr;\n\t}\n\n\treturn &priv->vdev;\n}\nEXPORT_SYMBOL_GPL(imx_media_capture_device_init);\n\nvoid imx_media_capture_device_remove(struct imx_media_video_dev *vdev)\n{\n\tstruct capture_priv *priv = to_capture_priv(vdev);\n\n\tv4l2_ctrl_handler_free(&priv->ctrl_hdlr);\n}\nEXPORT_SYMBOL_GPL(imx_media_capture_device_remove);\n\nMODULE_DESCRIPTION(\"i.MX5/6 v4l2 video capture interface driver\");\nMODULE_AUTHOR(\"Steve Longerbeam <steve_longerbeam@mentor.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}