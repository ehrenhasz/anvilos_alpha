{
  "module_name": "imx-media-fim.c",
  "hash_id": "396e22d05421190627c8093a342f732c8004f9b351e52ab828aacca458da4059",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/imx/imx-media-fim.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-subdev.h>\n#include <media/imx.h>\n#include \"imx-media.h\"\n\nenum {\n\tFIM_CL_ENABLE = 0,\n\tFIM_CL_NUM,\n\tFIM_CL_TOLERANCE_MIN,\n\tFIM_CL_TOLERANCE_MAX,\n\tFIM_CL_NUM_SKIP,\n\tFIM_NUM_CONTROLS,\n};\n\nenum {\n\tFIM_CL_ICAP_EDGE = 0,\n\tFIM_CL_ICAP_CHANNEL,\n\tFIM_NUM_ICAP_CONTROLS,\n};\n\n#define FIM_CL_ENABLE_DEF          0  \n#define FIM_CL_NUM_DEF             8  \n#define FIM_CL_NUM_SKIP_DEF        2  \n#define FIM_CL_TOLERANCE_MIN_DEF  50  \n#define FIM_CL_TOLERANCE_MAX_DEF   0  \n\nstruct imx_media_fim {\n\t \n\tstruct v4l2_subdev *sd;\n\n\t \n\tstruct v4l2_ctrl_handler ctrl_handler;\n\n\t \n\tstruct v4l2_ctrl  *ctrl[FIM_NUM_CONTROLS];\n\tstruct v4l2_ctrl  *icap_ctrl[FIM_NUM_ICAP_CONTROLS];\n\n\tspinlock_t        lock;  \n\n\t \n\tbool              enabled;\n\tint               num_avg;\n\tint               num_skip;\n\tunsigned long     tolerance_min;  \n\tunsigned long     tolerance_max;  \n\t \n\tint               icap_channel;\n\tint               icap_flags;\n\n\tint               counter;\n\tktime_t\t\t  last_ts;\n\tunsigned long     sum;        \n\tunsigned long     nominal;    \n\n\tstruct completion icap_first_event;\n\tbool              stream_on;\n};\n\nstatic bool icap_enabled(struct imx_media_fim *fim)\n{\n\treturn fim->icap_flags != IRQ_TYPE_NONE;\n}\n\nstatic void update_fim_nominal(struct imx_media_fim *fim,\n\t\t\t       const struct v4l2_fract *fi)\n{\n\tif (fi->denominator == 0) {\n\t\tdev_dbg(fim->sd->dev, \"no frame interval, FIM disabled\\n\");\n\t\tfim->enabled = false;\n\t\treturn;\n\t}\n\n\tfim->nominal = DIV_ROUND_CLOSEST_ULL(1000000ULL * (u64)fi->numerator,\n\t\t\t\t\t     fi->denominator);\n\n\tdev_dbg(fim->sd->dev, \"FI=%lu usec\\n\", fim->nominal);\n}\n\nstatic void reset_fim(struct imx_media_fim *fim, bool curval)\n{\n\tstruct v4l2_ctrl *icap_chan = fim->icap_ctrl[FIM_CL_ICAP_CHANNEL];\n\tstruct v4l2_ctrl *icap_edge = fim->icap_ctrl[FIM_CL_ICAP_EDGE];\n\tstruct v4l2_ctrl *en = fim->ctrl[FIM_CL_ENABLE];\n\tstruct v4l2_ctrl *num = fim->ctrl[FIM_CL_NUM];\n\tstruct v4l2_ctrl *skip = fim->ctrl[FIM_CL_NUM_SKIP];\n\tstruct v4l2_ctrl *tol_min = fim->ctrl[FIM_CL_TOLERANCE_MIN];\n\tstruct v4l2_ctrl *tol_max = fim->ctrl[FIM_CL_TOLERANCE_MAX];\n\n\tif (curval) {\n\t\tfim->enabled = en->cur.val;\n\t\tfim->icap_flags = icap_edge->cur.val;\n\t\tfim->icap_channel = icap_chan->cur.val;\n\t\tfim->num_avg = num->cur.val;\n\t\tfim->num_skip = skip->cur.val;\n\t\tfim->tolerance_min = tol_min->cur.val;\n\t\tfim->tolerance_max = tol_max->cur.val;\n\t} else {\n\t\tfim->enabled = en->val;\n\t\tfim->icap_flags = icap_edge->val;\n\t\tfim->icap_channel = icap_chan->val;\n\t\tfim->num_avg = num->val;\n\t\tfim->num_skip = skip->val;\n\t\tfim->tolerance_min = tol_min->val;\n\t\tfim->tolerance_max = tol_max->val;\n\t}\n\n\t \n\tif (fim->tolerance_max <= fim->tolerance_min)\n\t\tfim->tolerance_max = 0;\n\n\t \n\tif (!icap_enabled(fim))\n\t\tfim->num_skip = max_t(int, fim->num_skip, 1);\n\n\tfim->counter = -fim->num_skip;\n\tfim->sum = 0;\n}\n\nstatic void send_fim_event(struct imx_media_fim *fim, unsigned long error)\n{\n\tstatic const struct v4l2_event ev = {\n\t\t.type = V4L2_EVENT_IMX_FRAME_INTERVAL_ERROR,\n\t};\n\n\tv4l2_subdev_notify_event(fim->sd, &ev);\n}\n\n \nstatic void frame_interval_monitor(struct imx_media_fim *fim,\n\t\t\t\t   ktime_t timestamp)\n{\n\tlong long interval, error;\n\tunsigned long error_avg;\n\tbool send_event = false;\n\n\tif (!fim->enabled || ++fim->counter <= 0)\n\t\tgoto out_update_ts;\n\n\t \n\tinterval = ktime_to_ns(ktime_sub(timestamp, fim->last_ts));\n\terror = abs(interval - NSEC_PER_USEC * (u64)fim->nominal);\n\tif (error > U32_MAX)\n\t\terror = U32_MAX;\n\telse\n\t\terror = abs((u32)error / NSEC_PER_USEC);\n\n\tif (fim->tolerance_max && error >= fim->tolerance_max) {\n\t\tdev_dbg(fim->sd->dev,\n\t\t\t\"FIM: %llu ignored, out of tolerance bounds\\n\",\n\t\t\terror);\n\t\tfim->counter--;\n\t\tgoto out_update_ts;\n\t}\n\n\tfim->sum += error;\n\n\tif (fim->counter == fim->num_avg) {\n\t\terror_avg = DIV_ROUND_CLOSEST(fim->sum, fim->num_avg);\n\n\t\tif (error_avg > fim->tolerance_min)\n\t\t\tsend_event = true;\n\n\t\tdev_dbg(fim->sd->dev, \"FIM: error: %lu usec%s\\n\",\n\t\t\terror_avg, send_event ? \" (!!!)\" : \"\");\n\n\t\tfim->counter = 0;\n\t\tfim->sum = 0;\n\t}\n\nout_update_ts:\n\tfim->last_ts = timestamp;\n\tif (send_event)\n\t\tsend_fim_event(fim, error_avg);\n}\n\n \nstatic void fim_acquire_first_ts(struct imx_media_fim *fim)\n{\n\tunsigned long ret;\n\n\tif (!fim->enabled || fim->num_skip > 0)\n\t\treturn;\n\n\tret = wait_for_completion_timeout(\n\t\t&fim->icap_first_event,\n\t\tmsecs_to_jiffies(IMX_MEDIA_EOF_TIMEOUT));\n\tif (ret == 0)\n\t\tv4l2_warn(fim->sd, \"wait first icap event timeout\\n\");\n}\n\n \nstatic int fim_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct imx_media_fim *fim = container_of(ctrl->handler,\n\t\t\t\t\t\t struct imx_media_fim,\n\t\t\t\t\t\t ctrl_handler);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&fim->lock, flags);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_IMX_FIM_ENABLE:\n\t\tbreak;\n\tcase V4L2_CID_IMX_FIM_ICAP_EDGE:\n\t\tif (fim->stream_on)\n\t\t\tret = -EBUSY;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (!ret)\n\t\treset_fim(fim, false);\n\n\tspin_unlock_irqrestore(&fim->lock, flags);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops fim_ctrl_ops = {\n\t.s_ctrl = fim_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config fim_ctrl[] = {\n\t[FIM_CL_ENABLE] = {\n\t\t.ops = &fim_ctrl_ops,\n\t\t.id = V4L2_CID_IMX_FIM_ENABLE,\n\t\t.name = \"FIM Enable\",\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.def = FIM_CL_ENABLE_DEF,\n\t\t.min = 0,\n\t\t.max = 1,\n\t\t.step = 1,\n\t},\n\t[FIM_CL_NUM] = {\n\t\t.ops = &fim_ctrl_ops,\n\t\t.id = V4L2_CID_IMX_FIM_NUM,\n\t\t.name = \"FIM Num Average\",\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.def = FIM_CL_NUM_DEF,\n\t\t.min =  1,  \n\t\t.max = 64,  \n\t\t.step = 1,\n\t},\n\t[FIM_CL_TOLERANCE_MIN] = {\n\t\t.ops = &fim_ctrl_ops,\n\t\t.id = V4L2_CID_IMX_FIM_TOLERANCE_MIN,\n\t\t.name = \"FIM Tolerance Min\",\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.def = FIM_CL_TOLERANCE_MIN_DEF,\n\t\t.min =    2,\n\t\t.max =  200,\n\t\t.step =   1,\n\t},\n\t[FIM_CL_TOLERANCE_MAX] = {\n\t\t.ops = &fim_ctrl_ops,\n\t\t.id = V4L2_CID_IMX_FIM_TOLERANCE_MAX,\n\t\t.name = \"FIM Tolerance Max\",\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.def = FIM_CL_TOLERANCE_MAX_DEF,\n\t\t.min =    0,\n\t\t.max =  500,\n\t\t.step =   1,\n\t},\n\t[FIM_CL_NUM_SKIP] = {\n\t\t.ops = &fim_ctrl_ops,\n\t\t.id = V4L2_CID_IMX_FIM_NUM_SKIP,\n\t\t.name = \"FIM Num Skip\",\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.def = FIM_CL_NUM_SKIP_DEF,\n\t\t.min =   0,  \n\t\t.max = 256,  \n\t\t.step =  1,\n\t},\n};\n\nstatic const struct v4l2_ctrl_config fim_icap_ctrl[] = {\n\t[FIM_CL_ICAP_EDGE] = {\n\t\t.ops = &fim_ctrl_ops,\n\t\t.id = V4L2_CID_IMX_FIM_ICAP_EDGE,\n\t\t.name = \"FIM Input Capture Edge\",\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.def =  IRQ_TYPE_NONE,  \n\t\t.min =  IRQ_TYPE_NONE,\n\t\t.max =  IRQ_TYPE_EDGE_BOTH,\n\t\t.step = 1,\n\t},\n\t[FIM_CL_ICAP_CHANNEL] = {\n\t\t.ops = &fim_ctrl_ops,\n\t\t.id = V4L2_CID_IMX_FIM_ICAP_CHANNEL,\n\t\t.name = \"FIM Input Capture Channel\",\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.def =  0,\n\t\t.min =  0,\n\t\t.max =  1,\n\t\t.step = 1,\n\t},\n};\n\nstatic int init_fim_controls(struct imx_media_fim *fim)\n{\n\tstruct v4l2_ctrl_handler *hdlr = &fim->ctrl_handler;\n\tint i, ret;\n\n\tv4l2_ctrl_handler_init(hdlr, FIM_NUM_CONTROLS + FIM_NUM_ICAP_CONTROLS);\n\n\tfor (i = 0; i < FIM_NUM_CONTROLS; i++)\n\t\tfim->ctrl[i] = v4l2_ctrl_new_custom(hdlr,\n\t\t\t\t\t\t    &fim_ctrl[i],\n\t\t\t\t\t\t    NULL);\n\tfor (i = 0; i < FIM_NUM_ICAP_CONTROLS; i++)\n\t\tfim->icap_ctrl[i] = v4l2_ctrl_new_custom(hdlr,\n\t\t\t\t\t\t\t &fim_icap_ctrl[i],\n\t\t\t\t\t\t\t NULL);\n\tif (hdlr->error) {\n\t\tret = hdlr->error;\n\t\tgoto err_free;\n\t}\n\n\tv4l2_ctrl_cluster(FIM_NUM_CONTROLS, fim->ctrl);\n\tv4l2_ctrl_cluster(FIM_NUM_ICAP_CONTROLS, fim->icap_ctrl);\n\n\treturn 0;\nerr_free:\n\tv4l2_ctrl_handler_free(hdlr);\n\treturn ret;\n}\n\n \nvoid imx_media_fim_eof_monitor(struct imx_media_fim *fim, ktime_t timestamp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fim->lock, flags);\n\n\tif (!icap_enabled(fim))\n\t\tframe_interval_monitor(fim, timestamp);\n\n\tspin_unlock_irqrestore(&fim->lock, flags);\n}\n\n \nvoid imx_media_fim_set_stream(struct imx_media_fim *fim,\n\t\t\t      const struct v4l2_fract *fi,\n\t\t\t      bool on)\n{\n\tunsigned long flags;\n\n\tv4l2_ctrl_lock(fim->ctrl[FIM_CL_ENABLE]);\n\n\tif (fim->stream_on == on)\n\t\tgoto out;\n\n\tif (on) {\n\t\tspin_lock_irqsave(&fim->lock, flags);\n\t\treset_fim(fim, true);\n\t\tupdate_fim_nominal(fim, fi);\n\t\tspin_unlock_irqrestore(&fim->lock, flags);\n\n\t\tif (icap_enabled(fim))\n\t\t\tfim_acquire_first_ts(fim);\n\t}\n\n\tfim->stream_on = on;\nout:\n\tv4l2_ctrl_unlock(fim->ctrl[FIM_CL_ENABLE]);\n}\n\nint imx_media_fim_add_controls(struct imx_media_fim *fim)\n{\n\t \n\treturn v4l2_ctrl_add_handler(fim->sd->ctrl_handler,\n\t\t\t\t     &fim->ctrl_handler, NULL, false);\n}\n\n \nstruct imx_media_fim *imx_media_fim_init(struct v4l2_subdev *sd)\n{\n\tstruct imx_media_fim *fim;\n\tint ret;\n\n\tfim = devm_kzalloc(sd->dev, sizeof(*fim), GFP_KERNEL);\n\tif (!fim)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfim->sd = sd;\n\n\tspin_lock_init(&fim->lock);\n\n\tret = init_fim_controls(fim);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn fim;\n}\n\nvoid imx_media_fim_free(struct imx_media_fim *fim)\n{\n\tv4l2_ctrl_handler_free(&fim->ctrl_handler);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}