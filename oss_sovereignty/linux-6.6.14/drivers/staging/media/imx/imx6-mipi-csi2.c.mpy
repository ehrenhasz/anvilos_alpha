{
  "module_name": "imx6-mipi-csi2.c",
  "hash_id": "6c334eef4c4d62fe606d3f6f1c265f93f2403aecdaf06760fdfedf4ec09883b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/imx/imx6-mipi-csi2.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-subdev.h>\n#include \"imx-media.h\"\n\n \n#define CSI2_SINK_PAD       0\n#define CSI2_NUM_SINK_PADS  1\n#define CSI2_NUM_SRC_PADS   4\n#define CSI2_NUM_PADS       5\n\n \n#define CSI2_DEFAULT_MAX_MBPS 849\n\nstruct csi2_dev {\n\tstruct device          *dev;\n\tstruct v4l2_subdev      sd;\n\tstruct v4l2_async_notifier notifier;\n\tstruct media_pad       pad[CSI2_NUM_PADS];\n\tstruct clk             *dphy_clk;\n\tstruct clk             *pllref_clk;\n\tstruct clk             *pix_clk;  \n\tvoid __iomem           *base;\n\n\tstruct v4l2_subdev\t*remote;\n\tunsigned int\t\tremote_pad;\n\tunsigned short\t\tdata_lanes;\n\n\t \n\tstruct mutex lock;\n\n\tstruct v4l2_mbus_framefmt format_mbus;\n\n\tint                     stream_count;\n\tstruct v4l2_subdev      *src_sd;\n\tbool                    sink_linked[CSI2_NUM_SRC_PADS];\n};\n\n#define DEVICE_NAME \"imx6-mipi-csi2\"\n\n \n#define CSI2_VERSION            0x000\n#define CSI2_N_LANES            0x004\n#define CSI2_PHY_SHUTDOWNZ      0x008\n#define CSI2_DPHY_RSTZ          0x00c\n#define CSI2_RESETN             0x010\n#define CSI2_PHY_STATE          0x014\n#define PHY_STOPSTATEDATA_BIT   4\n#define PHY_STOPSTATEDATA(n)    BIT(PHY_STOPSTATEDATA_BIT + (n))\n#define PHY_RXCLKACTIVEHS       BIT(8)\n#define PHY_RXULPSCLKNOT        BIT(9)\n#define PHY_STOPSTATECLK        BIT(10)\n#define CSI2_DATA_IDS_1         0x018\n#define CSI2_DATA_IDS_2         0x01c\n#define CSI2_ERR1               0x020\n#define CSI2_ERR2               0x024\n#define CSI2_MSK1               0x028\n#define CSI2_MSK2               0x02c\n#define CSI2_PHY_TST_CTRL0      0x030\n#define PHY_TESTCLR\t\tBIT(0)\n#define PHY_TESTCLK\t\tBIT(1)\n#define CSI2_PHY_TST_CTRL1      0x034\n#define PHY_TESTEN\t\tBIT(16)\n \n#define CSI2IPU_GASKET\t\t0xf00\n#define CSI2IPU_YUV422_YUYV\tBIT(2)\n\nstatic inline struct csi2_dev *sd_to_dev(struct v4l2_subdev *sdev)\n{\n\treturn container_of(sdev, struct csi2_dev, sd);\n}\n\nstatic inline struct csi2_dev *notifier_to_dev(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct csi2_dev, notifier);\n}\n\n \n\nstatic void csi2_enable(struct csi2_dev *csi2, bool enable)\n{\n\tif (enable) {\n\t\twritel(0x1, csi2->base + CSI2_PHY_SHUTDOWNZ);\n\t\twritel(0x1, csi2->base + CSI2_DPHY_RSTZ);\n\t\twritel(0x1, csi2->base + CSI2_RESETN);\n\t} else {\n\t\twritel(0x0, csi2->base + CSI2_PHY_SHUTDOWNZ);\n\t\twritel(0x0, csi2->base + CSI2_DPHY_RSTZ);\n\t\twritel(0x0, csi2->base + CSI2_RESETN);\n\t}\n}\n\nstatic void csi2_set_lanes(struct csi2_dev *csi2, unsigned int lanes)\n{\n\twritel(lanes - 1, csi2->base + CSI2_N_LANES);\n}\n\nstatic void dw_mipi_csi2_phy_write(struct csi2_dev *csi2,\n\t\t\t\t   u32 test_code, u32 test_data)\n{\n\t \n\twritel(PHY_TESTCLR, csi2->base + CSI2_PHY_TST_CTRL0);\n\twritel(0x0, csi2->base + CSI2_PHY_TST_CTRL1);\n\twritel(0x0, csi2->base + CSI2_PHY_TST_CTRL0);\n\n\t \n\twritel(PHY_TESTCLK, csi2->base + CSI2_PHY_TST_CTRL0);\n\n\t \n\twritel(PHY_TESTEN | test_code, csi2->base + CSI2_PHY_TST_CTRL1);\n\twritel(0x0, csi2->base + CSI2_PHY_TST_CTRL0);\n\n\t \n\twritel(test_data, csi2->base + CSI2_PHY_TST_CTRL1);\n\twritel(PHY_TESTCLK, csi2->base + CSI2_PHY_TST_CTRL0);\n\n\t \n\twritel(0x0, csi2->base + CSI2_PHY_TST_CTRL0);\n}\n\n \nstatic const struct {\n\tu32 max_mbps;\n\tu32 hsfreqrange_sel;\n} hsfreq_map[] = {\n\t{ 90, 0x00}, {100, 0x20}, {110, 0x40}, {125, 0x02},\n\t{140, 0x22}, {150, 0x42}, {160, 0x04}, {180, 0x24},\n\t{200, 0x44}, {210, 0x06}, {240, 0x26}, {250, 0x46},\n\t{270, 0x08}, {300, 0x28}, {330, 0x48}, {360, 0x2a},\n\t{400, 0x4a}, {450, 0x0c}, {500, 0x2c}, {550, 0x0e},\n\t{600, 0x2e}, {650, 0x10}, {700, 0x30}, {750, 0x12},\n\t{800, 0x32}, {850, 0x14}, {900, 0x34}, {950, 0x54},\n\t{1000, 0x74},\n};\n\nstatic int max_mbps_to_hsfreqrange_sel(u32 max_mbps)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hsfreq_map); i++)\n\t\tif (hsfreq_map[i].max_mbps > max_mbps)\n\t\t\treturn hsfreq_map[i].hsfreqrange_sel;\n\n\treturn -EINVAL;\n}\n\nstatic int csi2_dphy_init(struct csi2_dev *csi2)\n{\n\tstruct v4l2_ctrl *ctrl;\n\tu32 mbps_per_lane;\n\tint sel;\n\n\tctrl = v4l2_ctrl_find(csi2->src_sd->ctrl_handler,\n\t\t\t      V4L2_CID_LINK_FREQ);\n\tif (!ctrl)\n\t\tmbps_per_lane = CSI2_DEFAULT_MAX_MBPS;\n\telse\n\t\tmbps_per_lane = DIV_ROUND_UP_ULL(2 * ctrl->qmenu_int[ctrl->val],\n\t\t\t\t\t\t USEC_PER_SEC);\n\n\tsel = max_mbps_to_hsfreqrange_sel(mbps_per_lane);\n\tif (sel < 0)\n\t\treturn sel;\n\n\tdw_mipi_csi2_phy_write(csi2, 0x44, sel);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused csi2_dphy_wait_ulp(struct csi2_dev *csi2)\n{\n\tu32 reg;\n\tint ret;\n\n\t \n\tret = readl_poll_timeout(csi2->base + CSI2_PHY_STATE, reg,\n\t\t\t\t !(reg & PHY_RXULPSCLKNOT), 0, 500000);\n\tif (ret) {\n\t\tv4l2_err(&csi2->sd, \"ULP timeout, phy_state = 0x%08x\\n\", reg);\n\t\treturn ret;\n\t}\n\n\t \n\tret = readl_poll_timeout(csi2->base + CSI2_ERR1, reg,\n\t\t\t\t reg == 0x0, 0, 500000);\n\tif (ret) {\n\t\tv4l2_err(&csi2->sd, \"stable bus timeout, err1 = 0x%08x\\n\", reg);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void csi2_dphy_wait_stopstate(struct csi2_dev *csi2, unsigned int lanes)\n{\n\tu32 mask, reg;\n\tint ret;\n\n\tmask = PHY_STOPSTATECLK | (((1 << lanes) - 1) << PHY_STOPSTATEDATA_BIT);\n\n\tret = readl_poll_timeout(csi2->base + CSI2_PHY_STATE, reg,\n\t\t\t\t (reg & mask) == mask, 0, 500000);\n\tif (ret) {\n\t\tv4l2_warn(&csi2->sd, \"LP-11 wait timeout, likely a sensor driver bug, expect capture failures.\\n\");\n\t\tv4l2_warn(&csi2->sd, \"phy_state = 0x%08x\\n\", reg);\n\t}\n}\n\n \nstatic int csi2_dphy_wait_clock_lane(struct csi2_dev *csi2)\n{\n\tu32 reg;\n\tint ret;\n\n\tret = readl_poll_timeout(csi2->base + CSI2_PHY_STATE, reg,\n\t\t\t\t (reg & PHY_RXCLKACTIVEHS), 0, 500000);\n\tif (ret) {\n\t\tv4l2_err(&csi2->sd, \"clock lane timeout, phy_state = 0x%08x\\n\",\n\t\t\t reg);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void csi2ipu_gasket_init(struct csi2_dev *csi2)\n{\n\tu32 reg = 0;\n\n\tswitch (csi2->format_mbus.code) {\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\t\treg = CSI2IPU_YUV422_YUYV;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twritel(reg, csi2->base + CSI2IPU_GASKET);\n}\n\nstatic int csi2_get_active_lanes(struct csi2_dev *csi2, unsigned int *lanes)\n{\n\tstruct v4l2_mbus_config mbus_config = { 0 };\n\tint ret;\n\n\t*lanes = csi2->data_lanes;\n\n\tret = v4l2_subdev_call(csi2->remote, pad, get_mbus_config,\n\t\t\t       csi2->remote_pad, &mbus_config);\n\tif (ret == -ENOIOCTLCMD) {\n\t\tdev_dbg(csi2->dev, \"No remote mbus configuration available\\n\");\n\t\treturn 0;\n\t}\n\n\tif (ret) {\n\t\tdev_err(csi2->dev, \"Failed to get remote mbus configuration\\n\");\n\t\treturn ret;\n\t}\n\n\tif (mbus_config.type != V4L2_MBUS_CSI2_DPHY) {\n\t\tdev_err(csi2->dev, \"Unsupported media bus type %u\\n\",\n\t\t\tmbus_config.type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mbus_config.bus.mipi_csi2.num_data_lanes > csi2->data_lanes) {\n\t\tdev_err(csi2->dev,\n\t\t\t\"Unsupported mbus config: too many data lanes %u\\n\",\n\t\t\tmbus_config.bus.mipi_csi2.num_data_lanes);\n\t\treturn -EINVAL;\n\t}\n\n\t*lanes = mbus_config.bus.mipi_csi2.num_data_lanes;\n\n\treturn 0;\n}\n\nstatic int csi2_start(struct csi2_dev *csi2)\n{\n\tunsigned int lanes;\n\tint ret;\n\n\tret = clk_prepare_enable(csi2->pix_clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcsi2ipu_gasket_init(csi2);\n\n\t \n\tret = csi2_dphy_init(csi2);\n\tif (ret)\n\t\tgoto err_disable_clk;\n\n\tret = csi2_get_active_lanes(csi2, &lanes);\n\tif (ret)\n\t\tgoto err_disable_clk;\n\n\t \n\tcsi2_set_lanes(csi2, lanes);\n\tcsi2_enable(csi2, true);\n\n\t \n\tret = v4l2_subdev_call(csi2->src_sd, video, pre_streamon,\n\t\t\t       V4L2_SUBDEV_PRE_STREAMON_FL_MANUAL_LP);\n\tif (ret && ret != -ENOIOCTLCMD)\n\t\tgoto err_assert_reset;\n\tcsi2_dphy_wait_stopstate(csi2, lanes);\n\n\t \n\tret = v4l2_subdev_call(csi2->src_sd, video, s_stream, 1);\n\tret = (ret && ret != -ENOIOCTLCMD) ? ret : 0;\n\tif (ret)\n\t\tgoto err_stop_lp11;\n\n\t \n\tret = csi2_dphy_wait_clock_lane(csi2);\n\tif (ret)\n\t\tgoto err_stop_upstream;\n\n\treturn 0;\n\nerr_stop_upstream:\n\tv4l2_subdev_call(csi2->src_sd, video, s_stream, 0);\nerr_stop_lp11:\n\tv4l2_subdev_call(csi2->src_sd, video, post_streamoff);\nerr_assert_reset:\n\tcsi2_enable(csi2, false);\nerr_disable_clk:\n\tclk_disable_unprepare(csi2->pix_clk);\n\treturn ret;\n}\n\nstatic void csi2_stop(struct csi2_dev *csi2)\n{\n\t \n\tv4l2_subdev_call(csi2->src_sd, video, s_stream, 0);\n\tv4l2_subdev_call(csi2->src_sd, video, post_streamoff);\n\n\tcsi2_enable(csi2, false);\n\tclk_disable_unprepare(csi2->pix_clk);\n}\n\n \n\nstatic int csi2_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct csi2_dev *csi2 = sd_to_dev(sd);\n\tint i, ret = 0;\n\n\tmutex_lock(&csi2->lock);\n\n\tif (!csi2->src_sd) {\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < CSI2_NUM_SRC_PADS; i++) {\n\t\tif (csi2->sink_linked[i])\n\t\t\tbreak;\n\t}\n\tif (i >= CSI2_NUM_SRC_PADS) {\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\t \n\tif (csi2->stream_count != !enable)\n\t\tgoto update_count;\n\n\tdev_dbg(csi2->dev, \"stream %s\\n\", enable ? \"ON\" : \"OFF\");\n\tif (enable)\n\t\tret = csi2_start(csi2);\n\telse\n\t\tcsi2_stop(csi2);\n\tif (ret)\n\t\tgoto out;\n\nupdate_count:\n\tcsi2->stream_count += enable ? 1 : -1;\n\tif (csi2->stream_count < 0)\n\t\tcsi2->stream_count = 0;\nout:\n\tmutex_unlock(&csi2->lock);\n\treturn ret;\n}\n\nstatic int csi2_link_setup(struct media_entity *entity,\n\t\t\t   const struct media_pad *local,\n\t\t\t   const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct csi2_dev *csi2 = sd_to_dev(sd);\n\tstruct v4l2_subdev *remote_sd;\n\tint ret = 0;\n\n\tdev_dbg(csi2->dev, \"link setup %s -> %s\", remote->entity->name,\n\t\tlocal->entity->name);\n\n\tremote_sd = media_entity_to_v4l2_subdev(remote->entity);\n\n\tmutex_lock(&csi2->lock);\n\n\tif (local->flags & MEDIA_PAD_FL_SOURCE) {\n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (csi2->sink_linked[local->index - 1]) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcsi2->sink_linked[local->index - 1] = true;\n\t\t} else {\n\t\t\tcsi2->sink_linked[local->index - 1] = false;\n\t\t}\n\t} else {\n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (csi2->src_sd) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcsi2->src_sd = remote_sd;\n\t\t} else {\n\t\t\tcsi2->src_sd = NULL;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&csi2->lock);\n\treturn ret;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__csi2_get_fmt(struct csi2_dev *csi2, struct v4l2_subdev_state *sd_state,\n\t       unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&csi2->sd, sd_state, pad);\n\telse\n\t\treturn &csi2->format_mbus;\n}\n\nstatic int csi2_get_fmt(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tstruct v4l2_subdev_format *sdformat)\n{\n\tstruct csi2_dev *csi2 = sd_to_dev(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tmutex_lock(&csi2->lock);\n\n\tfmt = __csi2_get_fmt(csi2, sd_state, sdformat->pad, sdformat->which);\n\n\tsdformat->format = *fmt;\n\n\tmutex_unlock(&csi2->lock);\n\n\treturn 0;\n}\n\nstatic int csi2_set_fmt(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tstruct v4l2_subdev_format *sdformat)\n{\n\tstruct csi2_dev *csi2 = sd_to_dev(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\tint ret = 0;\n\n\tif (sdformat->pad >= CSI2_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&csi2->lock);\n\n\tif (csi2->stream_count > 0) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sdformat->pad != CSI2_SINK_PAD)\n\t\tsdformat->format = csi2->format_mbus;\n\n\tfmt = __csi2_get_fmt(csi2, sd_state, sdformat->pad, sdformat->which);\n\n\t*fmt = sdformat->format;\nout:\n\tmutex_unlock(&csi2->lock);\n\treturn ret;\n}\n\nstatic int csi2_registered(struct v4l2_subdev *sd)\n{\n\tstruct csi2_dev *csi2 = sd_to_dev(sd);\n\n\t \n\treturn imx_media_init_mbus_fmt(&csi2->format_mbus,\n\t\t\t\t      IMX_MEDIA_DEF_PIX_WIDTH,\n\t\t\t\t      IMX_MEDIA_DEF_PIX_HEIGHT, 0,\n\t\t\t\t      V4L2_FIELD_NONE, NULL);\n}\n\n \n\nstatic int csi2_log_status(struct v4l2_subdev *sd)\n{\n\tstruct csi2_dev *csi2 = sd_to_dev(sd);\n\n\tv4l2_info(sd, \"-----MIPI CSI status-----\\n\");\n\tv4l2_info(sd, \"VERSION: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_VERSION));\n\tv4l2_info(sd, \"N_LANES: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_N_LANES));\n\tv4l2_info(sd, \"PHY_SHUTDOWNZ: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_PHY_SHUTDOWNZ));\n\tv4l2_info(sd, \"DPHY_RSTZ: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_DPHY_RSTZ));\n\tv4l2_info(sd, \"RESETN: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_RESETN));\n\tv4l2_info(sd, \"PHY_STATE: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_PHY_STATE));\n\tv4l2_info(sd, \"DATA_IDS_1: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_DATA_IDS_1));\n\tv4l2_info(sd, \"DATA_IDS_2: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_DATA_IDS_2));\n\tv4l2_info(sd, \"ERR1: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_ERR1));\n\tv4l2_info(sd, \"ERR2: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_ERR2));\n\tv4l2_info(sd, \"MSK1: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_MSK1));\n\tv4l2_info(sd, \"MSK2: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_MSK2));\n\tv4l2_info(sd, \"PHY_TST_CTRL0: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_PHY_TST_CTRL0));\n\tv4l2_info(sd, \"PHY_TST_CTRL1: 0x%x\\n\",\n\t\t  readl(csi2->base + CSI2_PHY_TST_CTRL1));\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops csi2_core_ops = {\n\t.log_status = csi2_log_status,\n};\n\nstatic const struct media_entity_operations csi2_entity_ops = {\n\t.link_setup = csi2_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n\t.get_fwnode_pad = v4l2_subdev_get_fwnode_pad_1_to_1,\n};\n\nstatic const struct v4l2_subdev_video_ops csi2_video_ops = {\n\t.s_stream = csi2_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops csi2_pad_ops = {\n\t.init_cfg = imx_media_init_cfg,\n\t.get_fmt = csi2_get_fmt,\n\t.set_fmt = csi2_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops csi2_subdev_ops = {\n\t.core = &csi2_core_ops,\n\t.video = &csi2_video_ops,\n\t.pad = &csi2_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops csi2_internal_ops = {\n\t.registered = csi2_registered,\n};\n\nstatic int csi2_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t     struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_async_connection *asd)\n{\n\tstruct csi2_dev *csi2 = notifier_to_dev(notifier);\n\tstruct media_pad *sink = &csi2->sd.entity.pads[CSI2_SINK_PAD];\n\tint pad;\n\n\tpad = media_entity_get_fwnode_pad(&sd->entity, asd->match.fwnode,\n\t\t\t\t\t  MEDIA_PAD_FL_SOURCE);\n\tif (pad < 0) {\n\t\tdev_err(csi2->dev, \"Failed to find pad for %s\\n\", sd->name);\n\t\treturn pad;\n\t}\n\n\tcsi2->remote = sd;\n\tcsi2->remote_pad = pad;\n\n\tdev_dbg(csi2->dev, \"Bound %s pad: %d\\n\", sd->name, pad);\n\n\treturn v4l2_create_fwnode_links_to_pad(sd, sink, 0);\n}\n\nstatic void csi2_notify_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t       struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_async_connection *asd)\n{\n\tstruct csi2_dev *csi2 = notifier_to_dev(notifier);\n\n\tcsi2->remote = NULL;\n}\n\nstatic const struct v4l2_async_notifier_operations csi2_notify_ops = {\n\t.bound = csi2_notify_bound,\n\t.unbind = csi2_notify_unbind,\n};\n\nstatic int csi2_async_register(struct csi2_dev *csi2)\n{\n\tstruct v4l2_fwnode_endpoint vep = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tstruct v4l2_async_connection *asd;\n\tstruct fwnode_handle *ep;\n\tint ret;\n\n\tv4l2_async_subdev_nf_init(&csi2->notifier, &csi2->sd);\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(csi2->dev), 0, 0,\n\t\t\t\t\t     FWNODE_GRAPH_ENDPOINT_NEXT);\n\tif (!ep)\n\t\treturn -ENOTCONN;\n\n\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\tif (ret)\n\t\tgoto err_parse;\n\n\tcsi2->data_lanes = vep.bus.mipi_csi2.num_data_lanes;\n\n\tdev_dbg(csi2->dev, \"data lanes: %d\\n\", vep.bus.mipi_csi2.num_data_lanes);\n\tdev_dbg(csi2->dev, \"flags: 0x%08x\\n\", vep.bus.mipi_csi2.flags);\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&csi2->notifier, ep,\n\t\t\t\t\t      struct v4l2_async_connection);\n\tfwnode_handle_put(ep);\n\n\tif (IS_ERR(asd))\n\t\treturn PTR_ERR(asd);\n\n\tcsi2->notifier.ops = &csi2_notify_ops;\n\n\tret = v4l2_async_nf_register(&csi2->notifier);\n\tif (ret)\n\t\treturn ret;\n\n\treturn v4l2_async_register_subdev(&csi2->sd);\n\nerr_parse:\n\tfwnode_handle_put(ep);\n\treturn ret;\n}\n\nstatic int csi2_probe(struct platform_device *pdev)\n{\n\tstruct csi2_dev *csi2;\n\tstruct resource *res;\n\tint i, ret;\n\n\tcsi2 = devm_kzalloc(&pdev->dev, sizeof(*csi2), GFP_KERNEL);\n\tif (!csi2)\n\t\treturn -ENOMEM;\n\n\tcsi2->dev = &pdev->dev;\n\n\tv4l2_subdev_init(&csi2->sd, &csi2_subdev_ops);\n\tv4l2_set_subdevdata(&csi2->sd, &pdev->dev);\n\tcsi2->sd.internal_ops = &csi2_internal_ops;\n\tcsi2->sd.entity.ops = &csi2_entity_ops;\n\tcsi2->sd.dev = &pdev->dev;\n\tcsi2->sd.owner = THIS_MODULE;\n\tcsi2->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tstrscpy(csi2->sd.name, DEVICE_NAME, sizeof(csi2->sd.name));\n\tcsi2->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tcsi2->sd.grp_id = IMX_MEDIA_GRP_ID_CSI2;\n\n\tfor (i = 0; i < CSI2_NUM_PADS; i++) {\n\t\tcsi2->pad[i].flags = (i == CSI2_SINK_PAD) ?\n\t\tMEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;\n\t}\n\n\tret = media_entity_pads_init(&csi2->sd.entity, CSI2_NUM_PADS,\n\t\t\t\t     csi2->pad);\n\tif (ret)\n\t\treturn ret;\n\n\tcsi2->pllref_clk = devm_clk_get(&pdev->dev, \"ref\");\n\tif (IS_ERR(csi2->pllref_clk)) {\n\t\tv4l2_err(&csi2->sd, \"failed to get pll reference clock\\n\");\n\t\treturn PTR_ERR(csi2->pllref_clk);\n\t}\n\n\tcsi2->dphy_clk = devm_clk_get(&pdev->dev, \"dphy\");\n\tif (IS_ERR(csi2->dphy_clk)) {\n\t\tv4l2_err(&csi2->sd, \"failed to get dphy clock\\n\");\n\t\treturn PTR_ERR(csi2->dphy_clk);\n\t}\n\n\tcsi2->pix_clk = devm_clk_get(&pdev->dev, \"pix\");\n\tif (IS_ERR(csi2->pix_clk)) {\n\t\tv4l2_err(&csi2->sd, \"failed to get pixel clock\\n\");\n\t\treturn PTR_ERR(csi2->pix_clk);\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tv4l2_err(&csi2->sd, \"failed to get platform resources\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcsi2->base = devm_ioremap(&pdev->dev, res->start, PAGE_SIZE);\n\tif (!csi2->base)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&csi2->lock);\n\n\tret = clk_prepare_enable(csi2->pllref_clk);\n\tif (ret) {\n\t\tv4l2_err(&csi2->sd, \"failed to enable pllref_clk\\n\");\n\t\tgoto rmmutex;\n\t}\n\n\tret = clk_prepare_enable(csi2->dphy_clk);\n\tif (ret) {\n\t\tv4l2_err(&csi2->sd, \"failed to enable dphy_clk\\n\");\n\t\tgoto pllref_off;\n\t}\n\n\tplatform_set_drvdata(pdev, &csi2->sd);\n\n\tret = csi2_async_register(csi2);\n\tif (ret)\n\t\tgoto clean_notifier;\n\n\treturn 0;\n\nclean_notifier:\n\tv4l2_async_nf_unregister(&csi2->notifier);\n\tv4l2_async_nf_cleanup(&csi2->notifier);\n\tclk_disable_unprepare(csi2->dphy_clk);\npllref_off:\n\tclk_disable_unprepare(csi2->pllref_clk);\nrmmutex:\n\tmutex_destroy(&csi2->lock);\n\treturn ret;\n}\n\nstatic void csi2_remove(struct platform_device *pdev)\n{\n\tstruct v4l2_subdev *sd = platform_get_drvdata(pdev);\n\tstruct csi2_dev *csi2 = sd_to_dev(sd);\n\n\tv4l2_async_nf_unregister(&csi2->notifier);\n\tv4l2_async_nf_cleanup(&csi2->notifier);\n\tv4l2_async_unregister_subdev(sd);\n\tclk_disable_unprepare(csi2->dphy_clk);\n\tclk_disable_unprepare(csi2->pllref_clk);\n\tmutex_destroy(&csi2->lock);\n\tmedia_entity_cleanup(&sd->entity);\n}\n\nstatic const struct of_device_id csi2_dt_ids[] = {\n\t{ .compatible = \"fsl,imx6-mipi-csi2\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, csi2_dt_ids);\n\nstatic struct platform_driver csi2_driver = {\n\t.driver = {\n\t\t.name = DEVICE_NAME,\n\t\t.of_match_table = csi2_dt_ids,\n\t},\n\t.probe = csi2_probe,\n\t.remove_new = csi2_remove,\n};\n\nmodule_platform_driver(csi2_driver);\n\nMODULE_DESCRIPTION(\"i.MX5/6 MIPI CSI-2 Receiver driver\");\nMODULE_AUTHOR(\"Steve Longerbeam <steve_longerbeam@mentor.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}