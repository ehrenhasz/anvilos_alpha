{
  "module_name": "imx-media-csi.c",
  "hash_id": "9c0f9a8b40e76fb8262855b7276784c74bba4e6c85a7a7189e2c973339d31b18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/imx/imx-media-csi.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/gcd.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-dma-contig.h>\n#include <video/imx-ipu-v3.h>\n#include <media/imx.h>\n#include \"imx-media.h\"\n\n \n#define MIN_W       32\n#define MIN_H       32\n#define MAX_W      4096\n#define MAX_H      4096\n#define W_ALIGN    1  \n#define H_ALIGN    1  \n#define S_ALIGN    1  \n\n \nstruct csi_skip_desc {\n\tu8 keep;\n\tu8 max_ratio;\n\tu8 skip_smfc;\n};\n\nstruct csi_priv {\n\tstruct device *dev;\n\tstruct ipu_soc *ipu;\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad[CSI_NUM_PADS];\n\tstruct v4l2_async_notifier notifier;\n\n\t \n\tstruct imx_media_video_dev *vdev;\n\tstruct imx_media_fim *fim;\n\tint csi_id;\n\tint smfc_id;\n\n\t \n\tstruct mutex lock;\n\n\tint active_output_pad;\n\n\tstruct ipuv3_channel *idmac_ch;\n\tstruct ipu_smfc *smfc;\n\tstruct ipu_csi *csi;\n\n\tstruct v4l2_mbus_framefmt format_mbus[CSI_NUM_PADS];\n\tconst struct imx_media_pixfmt *cc[CSI_NUM_PADS];\n\tstruct v4l2_fract frame_interval[CSI_NUM_PADS];\n\tstruct v4l2_rect crop;\n\tstruct v4l2_rect compose;\n\tconst struct csi_skip_desc *skip;\n\n\t \n\tstruct imx_media_buffer *active_vb2_buf[2];\n\tstruct imx_media_dma_buf underrun_buf;\n\n\tint ipu_buf_num;   \n\n\t \n\tstruct media_entity *sink;\n\tenum ipu_csi_dest dest;\n\t \n\tstruct v4l2_subdev *src_sd;\n\n\t \n\tint vc_num;\n\n\t \n\tstruct v4l2_mbus_config mbus_cfg;\n\n\tspinlock_t irqlock;  \n\tstruct timer_list eof_timeout_timer;\n\tint eof_irq;\n\tint nfb4eof_irq;\n\n\tstruct v4l2_ctrl_handler ctrl_hdlr;\n\n\tint stream_count;  \n\tu32 frame_sequence;  \n\tbool last_eof;    \n\tbool nfb4eof;     \n\tbool interweave_swap;  \n\tstruct completion last_eof_comp;\n};\n\nstatic inline struct csi_priv *sd_to_dev(struct v4l2_subdev *sdev)\n{\n\treturn container_of(sdev, struct csi_priv, sd);\n}\n\nstatic inline struct csi_priv *notifier_to_dev(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct csi_priv, notifier);\n}\n\nstatic inline bool is_parallel_bus(struct v4l2_mbus_config *mbus_cfg)\n{\n\treturn mbus_cfg->type != V4L2_MBUS_CSI2_DPHY;\n}\n\nstatic inline bool is_parallel_16bit_bus(struct v4l2_mbus_config *mbus_cfg)\n{\n\treturn is_parallel_bus(mbus_cfg) && mbus_cfg->bus.parallel.bus_width >= 16;\n}\n\n \nstatic inline bool requires_passthrough(struct v4l2_mbus_config *mbus_cfg,\n\t\t\t\t\tstruct v4l2_mbus_framefmt *infmt,\n\t\t\t\t\tconst struct imx_media_pixfmt *incc)\n{\n\tif (mbus_cfg->type == V4L2_MBUS_BT656) \n\t\treturn false;\n\n\treturn incc->bayer || is_parallel_16bit_bus(mbus_cfg) ||\n\t\t(is_parallel_bus(mbus_cfg) &&\n\t\t infmt->code != MEDIA_BUS_FMT_UYVY8_2X8 &&\n\t\t infmt->code != MEDIA_BUS_FMT_YUYV8_2X8);\n}\n\n \nstatic int csi_get_upstream_mbus_config(struct csi_priv *priv,\n\t\t\t\t\tstruct v4l2_mbus_config *mbus_cfg)\n{\n\tstruct v4l2_subdev *sd, *remote_sd;\n\tstruct media_pad *remote_pad;\n\tint ret;\n\n\tif (!priv->src_sd)\n\t\treturn -EPIPE;\n\n\tsd = priv->src_sd;\n\n\tswitch (sd->grp_id) {\n\tcase IMX_MEDIA_GRP_ID_CSI_MUX:\n\t\t \n\t\tsd = imx_media_pipeline_subdev(&sd->entity,\n\t\t\t\t\t       IMX_MEDIA_GRP_ID_CSI2,\n\t\t\t\t\t       true);\n\t\tif (IS_ERR(sd))\n\t\t\tsd = priv->src_sd;\n\t\tbreak;\n\tcase IMX_MEDIA_GRP_ID_CSI2:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tsd = &priv->sd;\n\t\tbreak;\n\t}\n\n\t \n\tremote_pad = media_entity_remote_pad_unique(&sd->entity,\n\t\t\t\t\t\t    MEDIA_PAD_FL_SOURCE);\n\tif (IS_ERR(remote_pad))\n\t\treturn PTR_ERR(remote_pad);\n\n\tremote_sd = media_entity_to_v4l2_subdev(remote_pad->entity);\n\n\tret = v4l2_subdev_call(remote_sd, pad, get_mbus_config,\n\t\t\t       remote_pad->index, mbus_cfg);\n\tif (ret == -ENOIOCTLCMD)\n\t\tv4l2_err(&priv->sd,\n\t\t\t \"entity %s does not implement get_mbus_config()\\n\",\n\t\t\t remote_pad->entity->name);\n\n\treturn ret;\n}\n\nstatic void csi_idmac_put_ipu_resources(struct csi_priv *priv)\n{\n\tif (priv->idmac_ch)\n\t\tipu_idmac_put(priv->idmac_ch);\n\tpriv->idmac_ch = NULL;\n\n\tif (priv->smfc)\n\t\tipu_smfc_put(priv->smfc);\n\tpriv->smfc = NULL;\n}\n\nstatic int csi_idmac_get_ipu_resources(struct csi_priv *priv)\n{\n\tint ch_num, ret;\n\tstruct ipu_smfc *smfc;\n\tstruct ipuv3_channel *idmac_ch;\n\n\tch_num = IPUV3_CHANNEL_CSI0 + priv->smfc_id;\n\n\tsmfc = ipu_smfc_get(priv->ipu, ch_num);\n\tif (IS_ERR(smfc)) {\n\t\tv4l2_err(&priv->sd, \"failed to get SMFC\\n\");\n\t\tret = PTR_ERR(smfc);\n\t\tgoto out;\n\t}\n\tpriv->smfc = smfc;\n\n\tidmac_ch = ipu_idmac_get(priv->ipu, ch_num);\n\tif (IS_ERR(idmac_ch)) {\n\t\tv4l2_err(&priv->sd, \"could not get IDMAC channel %u\\n\",\n\t\t\t ch_num);\n\t\tret = PTR_ERR(idmac_ch);\n\t\tgoto out;\n\t}\n\tpriv->idmac_ch = idmac_ch;\n\n\treturn 0;\nout:\n\tcsi_idmac_put_ipu_resources(priv);\n\treturn ret;\n}\n\nstatic void csi_vb2_buf_done(struct csi_priv *priv)\n{\n\tstruct imx_media_video_dev *vdev = priv->vdev;\n\tstruct imx_media_buffer *done, *next;\n\tstruct vb2_buffer *vb;\n\tdma_addr_t phys;\n\n\tdone = priv->active_vb2_buf[priv->ipu_buf_num];\n\tif (done) {\n\t\tdone->vbuf.field = vdev->fmt.field;\n\t\tdone->vbuf.sequence = priv->frame_sequence;\n\t\tvb = &done->vbuf.vb2_buf;\n\t\tvb->timestamp = ktime_get_ns();\n\t\tvb2_buffer_done(vb, priv->nfb4eof ?\n\t\t\t\tVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\t}\n\n\tpriv->frame_sequence++;\n\tpriv->nfb4eof = false;\n\n\t \n\tnext = imx_media_capture_device_next_buf(vdev);\n\tif (next) {\n\t\tphys = vb2_dma_contig_plane_dma_addr(&next->vbuf.vb2_buf, 0);\n\t\tpriv->active_vb2_buf[priv->ipu_buf_num] = next;\n\t} else {\n\t\tphys = priv->underrun_buf.phys;\n\t\tpriv->active_vb2_buf[priv->ipu_buf_num] = NULL;\n\t}\n\n\tif (ipu_idmac_buffer_is_ready(priv->idmac_ch, priv->ipu_buf_num))\n\t\tipu_idmac_clear_buffer(priv->idmac_ch, priv->ipu_buf_num);\n\n\tif (priv->interweave_swap)\n\t\tphys += vdev->fmt.bytesperline;\n\n\tipu_cpmem_set_buffer(priv->idmac_ch, priv->ipu_buf_num, phys);\n}\n\nstatic irqreturn_t csi_idmac_eof_interrupt(int irq, void *dev_id)\n{\n\tstruct csi_priv *priv = dev_id;\n\n\tspin_lock(&priv->irqlock);\n\n\tif (priv->last_eof) {\n\t\tcomplete(&priv->last_eof_comp);\n\t\tpriv->last_eof = false;\n\t\tgoto unlock;\n\t}\n\n\tif (priv->fim)\n\t\t \n\t\timx_media_fim_eof_monitor(priv->fim, ktime_get());\n\n\tcsi_vb2_buf_done(priv);\n\n\t \n\tipu_idmac_select_buffer(priv->idmac_ch, priv->ipu_buf_num);\n\t \n\tpriv->ipu_buf_num ^= 1;\n\n\t \n\tmod_timer(&priv->eof_timeout_timer,\n\t\t  jiffies + msecs_to_jiffies(IMX_MEDIA_EOF_TIMEOUT));\n\nunlock:\n\tspin_unlock(&priv->irqlock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t csi_idmac_nfb4eof_interrupt(int irq, void *dev_id)\n{\n\tstruct csi_priv *priv = dev_id;\n\n\tspin_lock(&priv->irqlock);\n\n\t \n\tpriv->nfb4eof = true;\n\n\tv4l2_err(&priv->sd, \"NFB4EOF\\n\");\n\n\tspin_unlock(&priv->irqlock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void csi_idmac_eof_timeout(struct timer_list *t)\n{\n\tstruct csi_priv *priv = from_timer(priv, t, eof_timeout_timer);\n\tstruct imx_media_video_dev *vdev = priv->vdev;\n\n\tv4l2_err(&priv->sd, \"EOF timeout\\n\");\n\n\t \n\timx_media_capture_device_error(vdev);\n}\n\nstatic void csi_idmac_setup_vb2_buf(struct csi_priv *priv, dma_addr_t *phys)\n{\n\tstruct imx_media_video_dev *vdev = priv->vdev;\n\tstruct imx_media_buffer *buf;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tbuf = imx_media_capture_device_next_buf(vdev);\n\t\tif (buf) {\n\t\t\tpriv->active_vb2_buf[i] = buf;\n\t\t\tphys[i] = vb2_dma_contig_plane_dma_addr(\n\t\t\t\t&buf->vbuf.vb2_buf, 0);\n\t\t} else {\n\t\t\tpriv->active_vb2_buf[i] = NULL;\n\t\t\tphys[i] = priv->underrun_buf.phys;\n\t\t}\n\t}\n}\n\nstatic void csi_idmac_unsetup_vb2_buf(struct csi_priv *priv,\n\t\t\t\t      enum vb2_buffer_state return_status)\n{\n\tstruct imx_media_buffer *buf;\n\tint i;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tbuf = priv->active_vb2_buf[i];\n\t\tif (buf) {\n\t\t\tstruct vb2_buffer *vb = &buf->vbuf.vb2_buf;\n\n\t\t\tvb->timestamp = ktime_get_ns();\n\t\t\tvb2_buffer_done(vb, return_status);\n\t\t}\n\t}\n}\n\n \nstatic int csi_idmac_setup_channel(struct csi_priv *priv)\n{\n\tstruct imx_media_video_dev *vdev = priv->vdev;\n\tconst struct imx_media_pixfmt *incc;\n\tstruct v4l2_mbus_framefmt *infmt;\n\tstruct v4l2_mbus_framefmt *outfmt;\n\tbool passthrough, interweave;\n\tstruct ipu_image image;\n\tu32 passthrough_bits;\n\tu32 passthrough_cycles;\n\tdma_addr_t phys[2];\n\tu32 burst_size;\n\tint ret;\n\n\tinfmt = &priv->format_mbus[CSI_SINK_PAD];\n\tincc = priv->cc[CSI_SINK_PAD];\n\toutfmt = &priv->format_mbus[CSI_SRC_PAD_IDMAC];\n\n\tipu_cpmem_zero(priv->idmac_ch);\n\n\tmemset(&image, 0, sizeof(image));\n\timage.pix = vdev->fmt;\n\timage.rect = vdev->compose;\n\n\tcsi_idmac_setup_vb2_buf(priv, phys);\n\n\timage.phys0 = phys[0];\n\timage.phys1 = phys[1];\n\n\tpassthrough = requires_passthrough(&priv->mbus_cfg, infmt, incc);\n\tpassthrough_cycles = 1;\n\n\t \n\tinterweave = V4L2_FIELD_IS_INTERLACED(image.pix.field) &&\n\t\tV4L2_FIELD_IS_SEQUENTIAL(outfmt->field);\n\tpriv->interweave_swap = interweave &&\n\t\timage.pix.field == V4L2_FIELD_INTERLACED_BT;\n\n\tswitch (image.pix.pixelformat) {\n\tcase V4L2_PIX_FMT_SBGGR8:\n\tcase V4L2_PIX_FMT_SGBRG8:\n\tcase V4L2_PIX_FMT_SGRBG8:\n\tcase V4L2_PIX_FMT_SRGGB8:\n\tcase V4L2_PIX_FMT_GREY:\n\t\tburst_size = 16;\n\t\tpassthrough_bits = 8;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SBGGR16:\n\tcase V4L2_PIX_FMT_SGBRG16:\n\tcase V4L2_PIX_FMT_SGRBG16:\n\tcase V4L2_PIX_FMT_SRGGB16:\n\tcase V4L2_PIX_FMT_Y10:\n\tcase V4L2_PIX_FMT_Y12:\n\t\tburst_size = 8;\n\t\tpassthrough_bits = 16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\tcase V4L2_PIX_FMT_NV12:\n\t\tburst_size = (image.pix.width & 0x3f) ?\n\t\t\t     ((image.pix.width & 0x1f) ?\n\t\t\t      ((image.pix.width & 0xf) ? 8 : 16) : 32) : 64;\n\t\tpassthrough_bits = 16;\n\t\t \n\t\tif (!interweave)\n\t\t\tipu_cpmem_skip_odd_chroma_rows(priv->idmac_ch);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_UYVY:\n\t\tburst_size = (image.pix.width & 0x1f) ?\n\t\t\t     ((image.pix.width & 0xf) ? 8 : 16) : 32;\n\t\tpassthrough_bits = 16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565:\n\t\tif (passthrough) {\n\t\t\tburst_size = 16;\n\t\t\tpassthrough_bits = 8;\n\t\t\tpassthrough_cycles = incc->cycles;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\t \n\tdefault:\n\t\tburst_size = (image.pix.width & 0xf) ? 8 : 16;\n\t\tpassthrough_bits = 16;\n\t\tbreak;\n\t}\n\n\tif (passthrough) {\n\t\tif (priv->interweave_swap) {\n\t\t\t \n\t\t\timage.phys0 += image.pix.bytesperline;\n\t\t\timage.phys1 += image.pix.bytesperline;\n\t\t}\n\n\t\tipu_cpmem_set_resolution(priv->idmac_ch,\n\t\t\t\t\t image.rect.width * passthrough_cycles,\n\t\t\t\t\t image.rect.height);\n\t\tipu_cpmem_set_stride(priv->idmac_ch, image.pix.bytesperline);\n\t\tipu_cpmem_set_buffer(priv->idmac_ch, 0, image.phys0);\n\t\tipu_cpmem_set_buffer(priv->idmac_ch, 1, image.phys1);\n\t\tipu_cpmem_set_format_passthrough(priv->idmac_ch,\n\t\t\t\t\t\t passthrough_bits);\n\t} else {\n\t\tif (priv->interweave_swap) {\n\t\t\t \n\t\t\timage.rect.top = 1;\n\t\t}\n\n\t\tret = ipu_cpmem_set_image(priv->idmac_ch, &image);\n\t\tif (ret)\n\t\t\tgoto unsetup_vb2;\n\t}\n\n\tipu_cpmem_set_burstsize(priv->idmac_ch, burst_size);\n\n\t \n\tipu_smfc_set_watermark(priv->smfc, 0x02, 0x01);\n\tipu_cpmem_set_high_priority(priv->idmac_ch);\n\tipu_idmac_enable_watermark(priv->idmac_ch, true);\n\tipu_cpmem_set_axi_id(priv->idmac_ch, 0);\n\n\tburst_size = passthrough ?\n\t\t(burst_size >> 3) - 1 : (burst_size >> 2) - 1;\n\n\tipu_smfc_set_burstsize(priv->smfc, burst_size);\n\n\tif (interweave)\n\t\tipu_cpmem_interlaced_scan(priv->idmac_ch,\n\t\t\t\t\t  priv->interweave_swap ?\n\t\t\t\t\t  -image.pix.bytesperline :\n\t\t\t\t\t  image.pix.bytesperline,\n\t\t\t\t\t  image.pix.pixelformat);\n\n\tipu_idmac_set_double_buffer(priv->idmac_ch, true);\n\n\treturn 0;\n\nunsetup_vb2:\n\tcsi_idmac_unsetup_vb2_buf(priv, VB2_BUF_STATE_QUEUED);\n\treturn ret;\n}\n\nstatic void csi_idmac_unsetup(struct csi_priv *priv,\n\t\t\t      enum vb2_buffer_state state)\n{\n\tipu_idmac_disable_channel(priv->idmac_ch);\n\tipu_smfc_disable(priv->smfc);\n\n\tcsi_idmac_unsetup_vb2_buf(priv, state);\n}\n\nstatic int csi_idmac_setup(struct csi_priv *priv)\n{\n\tint ret;\n\n\tret = csi_idmac_setup_channel(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tipu_cpmem_dump(priv->idmac_ch);\n\tipu_dump(priv->ipu);\n\n\tipu_smfc_enable(priv->smfc);\n\n\t \n\tipu_idmac_select_buffer(priv->idmac_ch, 0);\n\tipu_idmac_select_buffer(priv->idmac_ch, 1);\n\n\t \n\tipu_idmac_enable_channel(priv->idmac_ch);\n\n\treturn 0;\n}\n\nstatic int csi_idmac_start(struct csi_priv *priv)\n{\n\tstruct imx_media_video_dev *vdev = priv->vdev;\n\tint ret;\n\n\tret = csi_idmac_get_ipu_resources(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tipu_smfc_map_channel(priv->smfc, priv->csi_id, priv->vc_num);\n\n\tret = imx_media_alloc_dma_buf(priv->dev, &priv->underrun_buf,\n\t\t\t\t      vdev->fmt.sizeimage);\n\tif (ret)\n\t\tgoto out_put_ipu;\n\n\tpriv->ipu_buf_num = 0;\n\n\t \n\tinit_completion(&priv->last_eof_comp);\n\tpriv->frame_sequence = 0;\n\tpriv->last_eof = false;\n\tpriv->nfb4eof = false;\n\n\tret = csi_idmac_setup(priv);\n\tif (ret) {\n\t\tv4l2_err(&priv->sd, \"csi_idmac_setup failed: %d\\n\", ret);\n\t\tgoto out_free_dma_buf;\n\t}\n\n\tpriv->nfb4eof_irq = ipu_idmac_channel_irq(priv->ipu,\n\t\t\t\t\t\t  priv->idmac_ch,\n\t\t\t\t\t\t  IPU_IRQ_NFB4EOF);\n\tret = devm_request_irq(priv->dev, priv->nfb4eof_irq,\n\t\t\t       csi_idmac_nfb4eof_interrupt, 0,\n\t\t\t       \"imx-smfc-nfb4eof\", priv);\n\tif (ret) {\n\t\tv4l2_err(&priv->sd,\n\t\t\t \"Error registering NFB4EOF irq: %d\\n\", ret);\n\t\tgoto out_unsetup;\n\t}\n\n\tpriv->eof_irq = ipu_idmac_channel_irq(priv->ipu, priv->idmac_ch,\n\t\t\t\t\t      IPU_IRQ_EOF);\n\n\tret = devm_request_irq(priv->dev, priv->eof_irq,\n\t\t\t       csi_idmac_eof_interrupt, 0,\n\t\t\t       \"imx-smfc-eof\", priv);\n\tif (ret) {\n\t\tv4l2_err(&priv->sd,\n\t\t\t \"Error registering eof irq: %d\\n\", ret);\n\t\tgoto out_free_nfb4eof_irq;\n\t}\n\n\t \n\tmod_timer(&priv->eof_timeout_timer,\n\t\t  jiffies + msecs_to_jiffies(IMX_MEDIA_EOF_TIMEOUT));\n\n\treturn 0;\n\nout_free_nfb4eof_irq:\n\tdevm_free_irq(priv->dev, priv->nfb4eof_irq, priv);\nout_unsetup:\n\tcsi_idmac_unsetup(priv, VB2_BUF_STATE_QUEUED);\nout_free_dma_buf:\n\timx_media_free_dma_buf(priv->dev, &priv->underrun_buf);\nout_put_ipu:\n\tcsi_idmac_put_ipu_resources(priv);\n\treturn ret;\n}\n\nstatic void csi_idmac_wait_last_eof(struct csi_priv *priv)\n{\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tspin_lock_irqsave(&priv->irqlock, flags);\n\tpriv->last_eof = true;\n\tspin_unlock_irqrestore(&priv->irqlock, flags);\n\n\t \n\tret = wait_for_completion_timeout(\n\t\t&priv->last_eof_comp, msecs_to_jiffies(IMX_MEDIA_EOF_TIMEOUT));\n\tif (ret == 0)\n\t\tv4l2_warn(&priv->sd, \"wait last EOF timeout\\n\");\n}\n\nstatic void csi_idmac_stop(struct csi_priv *priv)\n{\n\tdevm_free_irq(priv->dev, priv->eof_irq, priv);\n\tdevm_free_irq(priv->dev, priv->nfb4eof_irq, priv);\n\n\tcsi_idmac_unsetup(priv, VB2_BUF_STATE_ERROR);\n\n\timx_media_free_dma_buf(priv->dev, &priv->underrun_buf);\n\n\t \n\tdel_timer_sync(&priv->eof_timeout_timer);\n\n\tcsi_idmac_put_ipu_resources(priv);\n}\n\n \nstatic int csi_setup(struct csi_priv *priv)\n{\n\tstruct v4l2_mbus_framefmt *infmt, *outfmt;\n\tconst struct imx_media_pixfmt *incc;\n\tstruct v4l2_mbus_framefmt if_fmt;\n\tstruct v4l2_rect crop;\n\n\tinfmt = &priv->format_mbus[CSI_SINK_PAD];\n\tincc = priv->cc[CSI_SINK_PAD];\n\toutfmt = &priv->format_mbus[priv->active_output_pad];\n\n\tif_fmt = *infmt;\n\tcrop = priv->crop;\n\n\t \n\tif (is_parallel_bus(&priv->mbus_cfg) && incc->cycles) {\n\t\tif_fmt.width *= incc->cycles;\n\t\tcrop.width *= incc->cycles;\n\t}\n\n\tipu_csi_set_window(priv->csi, &crop);\n\n\tipu_csi_set_downsize(priv->csi,\n\t\t\t     priv->crop.width == 2 * priv->compose.width,\n\t\t\t     priv->crop.height == 2 * priv->compose.height);\n\n\tipu_csi_init_interface(priv->csi, &priv->mbus_cfg, &if_fmt, outfmt);\n\n\tipu_csi_set_dest(priv->csi, priv->dest);\n\n\tif (priv->dest == IPU_CSI_DEST_IDMAC)\n\t\tipu_csi_set_skip_smfc(priv->csi, priv->skip->skip_smfc,\n\t\t\t\t      priv->skip->max_ratio - 1, 0);\n\n\tipu_csi_dump(priv->csi);\n\n\treturn 0;\n}\n\nstatic int csi_start(struct csi_priv *priv)\n{\n\tstruct v4l2_fract *input_fi, *output_fi;\n\tint ret;\n\n\tinput_fi = &priv->frame_interval[CSI_SINK_PAD];\n\toutput_fi = &priv->frame_interval[priv->active_output_pad];\n\n\t \n\tret = v4l2_subdev_call(priv->src_sd, video, s_stream, 1);\n\tret = (ret && ret != -ENOIOCTLCMD) ? ret : 0;\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (priv->mbus_cfg.type == V4L2_MBUS_BT656) {\n\t\tu32 delay_usec, bad_frames = 20;\n\n\t\tdelay_usec = DIV_ROUND_UP_ULL((u64)USEC_PER_SEC *\n\t\t\tinput_fi->numerator * bad_frames,\n\t\t\tinput_fi->denominator);\n\n\t\tusleep_range(delay_usec, delay_usec + 1000);\n\t}\n\n\tif (priv->dest == IPU_CSI_DEST_IDMAC) {\n\t\tret = csi_idmac_start(priv);\n\t\tif (ret)\n\t\t\tgoto stop_upstream;\n\t}\n\n\tret = csi_setup(priv);\n\tif (ret)\n\t\tgoto idmac_stop;\n\n\t \n\tif (priv->fim && priv->dest == IPU_CSI_DEST_IDMAC)\n\t\timx_media_fim_set_stream(priv->fim, output_fi, true);\n\n\tret = ipu_csi_enable(priv->csi);\n\tif (ret) {\n\t\tv4l2_err(&priv->sd, \"CSI enable error: %d\\n\", ret);\n\t\tgoto fim_off;\n\t}\n\n\treturn 0;\n\nfim_off:\n\tif (priv->fim && priv->dest == IPU_CSI_DEST_IDMAC)\n\t\timx_media_fim_set_stream(priv->fim, NULL, false);\nidmac_stop:\n\tif (priv->dest == IPU_CSI_DEST_IDMAC)\n\t\tcsi_idmac_stop(priv);\nstop_upstream:\n\tv4l2_subdev_call(priv->src_sd, video, s_stream, 0);\n\treturn ret;\n}\n\nstatic void csi_stop(struct csi_priv *priv)\n{\n\tif (priv->dest == IPU_CSI_DEST_IDMAC)\n\t\tcsi_idmac_wait_last_eof(priv);\n\n\t \n\tipu_csi_disable(priv->csi);\n\n\t \n\tv4l2_subdev_call(priv->src_sd, video, s_stream, 0);\n\n\tif (priv->dest == IPU_CSI_DEST_IDMAC) {\n\t\tcsi_idmac_stop(priv);\n\n\t\t \n\t\tif (priv->fim)\n\t\t\timx_media_fim_set_stream(priv->fim, NULL, false);\n\t}\n}\n\nstatic const struct csi_skip_desc csi_skip[12] = {\n\t{ 1, 1, 0x00 },  \n\t{ 5, 6, 0x10 },  \n\t{ 4, 5, 0x08 },  \n\t{ 3, 4, 0x04 },  \n\t{ 2, 3, 0x02 },  \n\t{ 3, 5, 0x0a },  \n\t{ 1, 2, 0x01 },  \n\t{ 2, 5, 0x0b },  \n\t{ 1, 3, 0x03 },  \n\t{ 1, 4, 0x07 },  \n\t{ 1, 5, 0x0f },  \n\t{ 1, 6, 0x1f },  \n};\n\nstatic void csi_apply_skip_interval(const struct csi_skip_desc *skip,\n\t\t\t\t    struct v4l2_fract *interval)\n{\n\tunsigned int div;\n\n\tinterval->numerator *= skip->max_ratio;\n\tinterval->denominator *= skip->keep;\n\n\t \n\tdiv = gcd(interval->numerator, interval->denominator);\n\tif (div > 1) {\n\t\tinterval->numerator /= div;\n\t\tinterval->denominator /= div;\n\t}\n}\n\n \nstatic const struct csi_skip_desc *csi_find_best_skip(struct v4l2_fract *in,\n\t\t\t\t\t\t      struct v4l2_fract *out)\n{\n\tconst struct csi_skip_desc *skip = &csi_skip[0], *best_skip = skip;\n\tu32 min_err = UINT_MAX;\n\tu64 want_us;\n\tint i;\n\n\t \n\tif (out->numerator == 0 || out->denominator == 0 ||\n\t    in->numerator == 0 || in->denominator == 0) {\n\t\t*out = *in;\n\t\treturn best_skip;\n\t}\n\n\twant_us = div_u64((u64)USEC_PER_SEC * out->numerator, out->denominator);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(csi_skip); i++, skip++) {\n\t\tu64 tmp, err;\n\n\t\ttmp = div_u64((u64)USEC_PER_SEC * in->numerator *\n\t\t\t      skip->max_ratio, in->denominator * skip->keep);\n\n\t\terr = abs((s64)tmp - want_us);\n\t\tif (err < min_err) {\n\t\t\tmin_err = err;\n\t\t\tbest_skip = skip;\n\t\t}\n\t}\n\n\t*out = *in;\n\tcsi_apply_skip_interval(best_skip, out);\n\n\treturn best_skip;\n}\n\n \n\nstatic int csi_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_frame_interval *fi)\n{\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\n\tif (fi->pad >= CSI_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\tfi->interval = priv->frame_interval[fi->pad];\n\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int csi_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_frame_interval *fi)\n{\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_fract *input_fi;\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tinput_fi = &priv->frame_interval[CSI_SINK_PAD];\n\n\tswitch (fi->pad) {\n\tcase CSI_SINK_PAD:\n\t\t \n\t\tif (fi->interval.numerator == 0 ||\n\t\t    fi->interval.denominator == 0)\n\t\t\tfi->interval = *input_fi;\n\t\t \n\t\tpriv->frame_interval[CSI_SRC_PAD_IDMAC] = fi->interval;\n\t\tpriv->frame_interval[CSI_SRC_PAD_DIRECT] = fi->interval;\n\t\tpriv->skip = &csi_skip[0];\n\t\tbreak;\n\tcase CSI_SRC_PAD_IDMAC:\n\t\t \n\t\tpriv->skip = csi_find_best_skip(input_fi, &fi->interval);\n\t\tbreak;\n\tcase CSI_SRC_PAD_DIRECT:\n\t\t \n\t\tfi->interval = *input_fi;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->frame_interval[fi->pad] = fi->interval;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int csi_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tif (!priv->src_sd || !priv->sink) {\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\t \n\tif (priv->stream_count != !enable)\n\t\tgoto update_count;\n\n\tif (enable) {\n\t\tdev_dbg(priv->dev, \"stream ON\\n\");\n\t\tret = csi_start(priv);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\tdev_dbg(priv->dev, \"stream OFF\\n\");\n\t\tcsi_stop(priv);\n\t}\n\nupdate_count:\n\tpriv->stream_count += enable ? 1 : -1;\n\tif (priv->stream_count < 0)\n\t\tpriv->stream_count = 0;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int csi_link_setup(struct media_entity *entity,\n\t\t\t  const struct media_pad *local,\n\t\t\t  const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_subdev *remote_sd;\n\tint ret = 0;\n\n\tdev_dbg(priv->dev, \"link setup %s -> %s\\n\", remote->entity->name,\n\t\tlocal->entity->name);\n\n\tmutex_lock(&priv->lock);\n\n\tif (local->flags & MEDIA_PAD_FL_SINK) {\n\t\tif (!is_media_entity_v4l2_subdev(remote->entity)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tremote_sd = media_entity_to_v4l2_subdev(remote->entity);\n\n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (priv->src_sd) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpriv->src_sd = remote_sd;\n\t\t} else {\n\t\t\tpriv->src_sd = NULL;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\tif (priv->sink) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tv4l2_ctrl_handler_free(&priv->ctrl_hdlr);\n\t\tv4l2_ctrl_handler_init(&priv->ctrl_hdlr, 0);\n\t\tpriv->sink = NULL;\n\t\t \n\t\tpriv->active_output_pad = CSI_SRC_PAD_IDMAC;\n\t\tgoto out;\n\t}\n\n\t \n\tpriv->active_output_pad = local->index;\n\n\t \n\tif (local->index == CSI_SRC_PAD_IDMAC) {\n\t\tif (!is_media_entity_v4l2_video_device(remote->entity)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (priv->fim) {\n\t\t\tret = imx_media_fim_add_controls(priv->fim);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tpriv->dest = IPU_CSI_DEST_IDMAC;\n\t} else {\n\t\tif (!is_media_entity_v4l2_subdev(remote->entity)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tremote_sd = media_entity_to_v4l2_subdev(remote->entity);\n\t\tswitch (remote_sd->grp_id) {\n\t\tcase IMX_MEDIA_GRP_ID_IPU_VDIC:\n\t\t\tpriv->dest = IPU_CSI_DEST_VDIC;\n\t\t\tbreak;\n\t\tcase IMX_MEDIA_GRP_ID_IPU_IC_PRP:\n\t\t\tpriv->dest = IPU_CSI_DEST_IC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpriv->sink = remote->entity;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int csi_link_validate(struct v4l2_subdev *sd,\n\t\t\t     struct media_link *link,\n\t\t\t     struct v4l2_subdev_format *source_fmt,\n\t\t\t     struct v4l2_subdev_format *sink_fmt)\n{\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_config mbus_cfg = { .type = 0 };\n\tbool is_csi2;\n\tint ret;\n\n\tret = v4l2_subdev_link_validate_default(sd, link,\n\t\t\t\t\t\tsource_fmt, sink_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = csi_get_upstream_mbus_config(priv, &mbus_cfg);\n\tif (ret) {\n\t\tv4l2_err(&priv->sd,\n\t\t\t \"failed to get upstream media bus configuration\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\tpriv->mbus_cfg = mbus_cfg;\n\tis_csi2 = !is_parallel_bus(&mbus_cfg);\n\tif (is_csi2) {\n\t\t \n\t\tipu_csi_set_mipi_datatype(priv->csi, 0,\n\t\t\t\t\t  &priv->format_mbus[CSI_SINK_PAD]);\n\t}\n\n\t \n\tipu_set_csi_src_mux(priv->ipu, priv->csi_id, is_csi2);\n\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__csi_get_fmt(struct csi_priv *priv, struct v4l2_subdev_state *sd_state,\n\t      unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&priv->sd, sd_state, pad);\n\telse\n\t\treturn &priv->format_mbus[pad];\n}\n\nstatic struct v4l2_rect *\n__csi_get_crop(struct csi_priv *priv, struct v4l2_subdev_state *sd_state,\n\t       enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_crop(&priv->sd, sd_state,\n\t\t\t\t\t\tCSI_SINK_PAD);\n\telse\n\t\treturn &priv->crop;\n}\n\nstatic struct v4l2_rect *\n__csi_get_compose(struct csi_priv *priv, struct v4l2_subdev_state *sd_state,\n\t\t  enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_compose(&priv->sd, sd_state,\n\t\t\t\t\t\t   CSI_SINK_PAD);\n\telse\n\t\treturn &priv->compose;\n}\n\nstatic void csi_try_crop(struct csi_priv *priv,\n\t\t\t struct v4l2_rect *crop,\n\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t struct v4l2_mbus_framefmt *infmt,\n\t\t\t struct v4l2_mbus_config *mbus_cfg)\n{\n\tu32 in_height;\n\n\tcrop->width = min_t(__u32, infmt->width, crop->width);\n\tif (crop->left + crop->width > infmt->width)\n\t\tcrop->left = infmt->width - crop->width;\n\t \n\tcrop->left &= ~0x3;\n\tif (priv->active_output_pad == CSI_SRC_PAD_DIRECT)\n\t\tcrop->width &= ~0x7;  \n\telse\n\t\tcrop->width &= ~0x1;  \n\n\tin_height = infmt->height;\n\tif (infmt->field == V4L2_FIELD_ALTERNATE)\n\t\tin_height *= 2;\n\n\t \n\tif (mbus_cfg->type == V4L2_MBUS_BT656 &&\n\t    (V4L2_FIELD_HAS_BOTH(infmt->field) ||\n\t     infmt->field == V4L2_FIELD_ALTERNATE)) {\n\t\tcrop->height = in_height;\n\t\tcrop->top = (in_height == 480) ? 2 : 0;\n\t} else {\n\t\tcrop->height = min_t(__u32, in_height, crop->height);\n\t\tif (crop->top + crop->height > in_height)\n\t\t\tcrop->top = in_height - crop->height;\n\t}\n}\n\nstatic int csi_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_config mbus_cfg = { .type = 0 };\n\tconst struct imx_media_pixfmt *incc;\n\tstruct v4l2_mbus_framefmt *infmt;\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tinfmt = __csi_get_fmt(priv, sd_state, CSI_SINK_PAD, code->which);\n\tincc = imx_media_find_mbus_format(infmt->code, PIXFMT_SEL_ANY);\n\n\tswitch (code->pad) {\n\tcase CSI_SINK_PAD:\n\t\tret = imx_media_enum_mbus_formats(&code->code, code->index,\n\t\t\t\t\t\t  PIXFMT_SEL_ANY);\n\t\tbreak;\n\tcase CSI_SRC_PAD_DIRECT:\n\tcase CSI_SRC_PAD_IDMAC:\n\t\tret = csi_get_upstream_mbus_config(priv, &mbus_cfg);\n\t\tif (ret) {\n\t\t\tv4l2_err(&priv->sd,\n\t\t\t\t \"failed to get upstream media bus configuration\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (requires_passthrough(&mbus_cfg, infmt, incc)) {\n\t\t\tif (code->index != 0) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcode->code = infmt->code;\n\t\t} else {\n\t\t\tenum imx_pixfmt_sel fmt_sel =\n\t\t\t\t(incc->cs == IPUV3_COLORSPACE_YUV) ?\n\t\t\t\tPIXFMT_SEL_YUV : PIXFMT_SEL_RGB;\n\n\t\t\tret = imx_media_enum_ipu_formats(&code->code,\n\t\t\t\t\t\t\t code->index,\n\t\t\t\t\t\t\t fmt_sel);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int csi_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_rect *crop;\n\tint ret = 0;\n\n\tif (fse->pad >= CSI_NUM_PADS ||\n\t    fse->index > (fse->pad == CSI_SINK_PAD ? 0 : 3))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\tif (fse->pad == CSI_SINK_PAD) {\n\t\tfse->min_width = MIN_W;\n\t\tfse->max_width = MAX_W;\n\t\tfse->min_height = MIN_H;\n\t\tfse->max_height = MAX_H;\n\t} else {\n\t\tcrop = __csi_get_crop(priv, sd_state, fse->which);\n\n\t\tfse->min_width = fse->index & 1 ?\n\t\t\tcrop->width / 2 : crop->width;\n\t\tfse->max_width = fse->min_width;\n\t\tfse->min_height = fse->index & 2 ?\n\t\t\tcrop->height / 2 : crop->height;\n\t\tfse->max_height = fse->min_height;\n\t}\n\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int csi_enum_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_interval_enum *fie)\n{\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_fract *input_fi;\n\tstruct v4l2_rect *crop;\n\tint ret = 0;\n\n\tif (fie->pad >= CSI_NUM_PADS ||\n\t    fie->index >= (fie->pad != CSI_SRC_PAD_IDMAC ?\n\t\t\t   1 : ARRAY_SIZE(csi_skip)))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\tinput_fi = &priv->frame_interval[CSI_SINK_PAD];\n\tcrop = __csi_get_crop(priv, sd_state, fie->which);\n\n\tif ((fie->width != crop->width && fie->width != crop->width / 2) ||\n\t    (fie->height != crop->height && fie->height != crop->height / 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfie->interval = *input_fi;\n\n\tif (fie->pad == CSI_SRC_PAD_IDMAC)\n\t\tcsi_apply_skip_interval(&csi_skip[fie->index],\n\t\t\t\t\t&fie->interval);\n\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int csi_get_fmt(struct v4l2_subdev *sd,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       struct v4l2_subdev_format *sdformat)\n{\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\tint ret = 0;\n\n\tif (sdformat->pad >= CSI_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\tfmt = __csi_get_fmt(priv, sd_state, sdformat->pad, sdformat->which);\n\tif (!fmt) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsdformat->format = *fmt;\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic void csi_try_field(struct csi_priv *priv,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *sdformat)\n{\n\tstruct v4l2_mbus_framefmt *infmt =\n\t\t__csi_get_fmt(priv, sd_state, CSI_SINK_PAD, sdformat->which);\n\n\t \n\tif (sdformat->pad == CSI_SINK_PAD) {\n\t\tif (sdformat->format.field == V4L2_FIELD_ANY)\n\t\t\tsdformat->format.field = V4L2_FIELD_NONE;\n\t\treturn;\n\t}\n\n\tswitch (infmt->field) {\n\tcase V4L2_FIELD_SEQ_TB:\n\tcase V4L2_FIELD_SEQ_BT:\n\t\t \n\t\tif (!V4L2_FIELD_IS_SEQUENTIAL(sdformat->format.field))\n\t\t\tsdformat->format.field = infmt->field;\n\t\tbreak;\n\tcase V4L2_FIELD_ALTERNATE:\n\t\t \n\t\tif (!V4L2_FIELD_IS_SEQUENTIAL(sdformat->format.field))\n\t\t\tsdformat->format.field = (infmt->height == 480 / 2) ?\n\t\t\t\tV4L2_FIELD_SEQ_BT : V4L2_FIELD_SEQ_TB;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tsdformat->format.field = infmt->field;\n\t\tbreak;\n\t}\n}\n\nstatic void csi_try_fmt(struct csi_priv *priv,\n\t\t\tstruct v4l2_mbus_config *mbus_cfg,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tstruct v4l2_subdev_format *sdformat,\n\t\t\tstruct v4l2_rect *crop,\n\t\t\tstruct v4l2_rect *compose,\n\t\t\tconst struct imx_media_pixfmt **cc)\n{\n\tconst struct imx_media_pixfmt *incc;\n\tstruct v4l2_mbus_framefmt *infmt;\n\tu32 code;\n\n\tinfmt = __csi_get_fmt(priv, sd_state, CSI_SINK_PAD, sdformat->which);\n\n\tswitch (sdformat->pad) {\n\tcase CSI_SRC_PAD_DIRECT:\n\tcase CSI_SRC_PAD_IDMAC:\n\t\tincc = imx_media_find_mbus_format(infmt->code, PIXFMT_SEL_ANY);\n\n\t\tsdformat->format.width = compose->width;\n\t\tsdformat->format.height = compose->height;\n\n\t\tif (requires_passthrough(mbus_cfg, infmt, incc)) {\n\t\t\tsdformat->format.code = infmt->code;\n\t\t\t*cc = incc;\n\t\t} else {\n\t\t\tenum imx_pixfmt_sel fmt_sel =\n\t\t\t\t(incc->cs == IPUV3_COLORSPACE_YUV) ?\n\t\t\t\tPIXFMT_SEL_YUV : PIXFMT_SEL_RGB;\n\n\t\t\t*cc = imx_media_find_ipu_format(sdformat->format.code,\n\t\t\t\t\t\t\tfmt_sel);\n\t\t\tif (!*cc) {\n\t\t\t\timx_media_enum_ipu_formats(&code, 0, fmt_sel);\n\t\t\t\t*cc = imx_media_find_ipu_format(code, fmt_sel);\n\t\t\t\tsdformat->format.code = (*cc)->codes[0];\n\t\t\t}\n\t\t}\n\n\t\tcsi_try_field(priv, sd_state, sdformat);\n\n\t\t \n\t\tsdformat->format.colorspace = infmt->colorspace;\n\t\tsdformat->format.xfer_func = infmt->xfer_func;\n\t\tsdformat->format.quantization = infmt->quantization;\n\t\tsdformat->format.ycbcr_enc = infmt->ycbcr_enc;\n\n\t\tbreak;\n\tcase CSI_SINK_PAD:\n\t\tv4l_bound_align_image(&sdformat->format.width, MIN_W, MAX_W,\n\t\t\t\t      W_ALIGN, &sdformat->format.height,\n\t\t\t\t      MIN_H, MAX_H, H_ALIGN, S_ALIGN);\n\n\t\t*cc = imx_media_find_mbus_format(sdformat->format.code,\n\t\t\t\t\t\t PIXFMT_SEL_ANY);\n\t\tif (!*cc) {\n\t\t\timx_media_enum_mbus_formats(&code, 0,\n\t\t\t\t\t\t    PIXFMT_SEL_YUV_RGB);\n\t\t\t*cc = imx_media_find_mbus_format(code,\n\t\t\t\t\t\t\t PIXFMT_SEL_YUV_RGB);\n\t\t\tsdformat->format.code = (*cc)->codes[0];\n\t\t}\n\n\t\tcsi_try_field(priv, sd_state, sdformat);\n\n\t\t \n\t\tcrop->left = 0;\n\t\tcrop->top = 0;\n\t\tcrop->width = sdformat->format.width;\n\t\tcrop->height = sdformat->format.height;\n\t\tif (sdformat->format.field == V4L2_FIELD_ALTERNATE)\n\t\t\tcrop->height *= 2;\n\t\tcsi_try_crop(priv, crop, sd_state, &sdformat->format, mbus_cfg);\n\t\tcompose->left = 0;\n\t\tcompose->top = 0;\n\t\tcompose->width = crop->width;\n\t\tcompose->height = crop->height;\n\n\t\tbreak;\n\t}\n\n\timx_media_try_colorimetry(&sdformat->format,\n\t\t\tpriv->active_output_pad == CSI_SRC_PAD_DIRECT);\n}\n\nstatic int csi_set_fmt(struct v4l2_subdev *sd,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       struct v4l2_subdev_format *sdformat)\n{\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_config mbus_cfg = { .type = 0 };\n\tconst struct imx_media_pixfmt *cc;\n\tstruct v4l2_mbus_framefmt *fmt;\n\tstruct v4l2_rect *crop, *compose;\n\tint ret;\n\n\tif (sdformat->pad >= CSI_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tret = csi_get_upstream_mbus_config(priv, &mbus_cfg);\n\tif (ret) {\n\t\tv4l2_err(&priv->sd,\n\t\t\t \"failed to get upstream media bus configuration\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->stream_count > 0) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tcrop = __csi_get_crop(priv, sd_state, sdformat->which);\n\tcompose = __csi_get_compose(priv, sd_state, sdformat->which);\n\n\tcsi_try_fmt(priv, &mbus_cfg, sd_state, sdformat, crop, compose, &cc);\n\n\tfmt = __csi_get_fmt(priv, sd_state, sdformat->pad, sdformat->which);\n\t*fmt = sdformat->format;\n\n\tif (sdformat->pad == CSI_SINK_PAD) {\n\t\tint pad;\n\n\t\t \n\t\tfor (pad = CSI_SINK_PAD + 1; pad < CSI_NUM_PADS; pad++) {\n\t\t\tconst struct imx_media_pixfmt *outcc;\n\t\t\tstruct v4l2_mbus_framefmt *outfmt;\n\t\t\tstruct v4l2_subdev_format format;\n\n\t\t\tformat.pad = pad;\n\t\t\tformat.which = sdformat->which;\n\t\t\tformat.format = sdformat->format;\n\t\t\tcsi_try_fmt(priv, &mbus_cfg, sd_state, &format, NULL,\n\t\t\t\t    compose, &outcc);\n\n\t\t\toutfmt = __csi_get_fmt(priv, sd_state, pad,\n\t\t\t\t\t       sdformat->which);\n\t\t\t*outfmt = format.format;\n\n\t\t\tif (sdformat->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\t\t\tpriv->cc[pad] = outcc;\n\t\t}\n\t}\n\n\tif (sdformat->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\tpriv->cc[sdformat->pad] = cc;\n\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int csi_get_selection(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *infmt;\n\tstruct v4l2_rect *crop, *compose;\n\tint ret = 0;\n\n\tif (sel->pad != CSI_SINK_PAD)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\tinfmt = __csi_get_fmt(priv, sd_state, CSI_SINK_PAD, sel->which);\n\tcrop = __csi_get_crop(priv, sd_state, sel->which);\n\tcompose = __csi_get_compose(priv, sd_state, sel->which);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = infmt->width;\n\t\tsel->r.height = infmt->height;\n\t\tif (infmt->field == V4L2_FIELD_ALTERNATE)\n\t\t\tsel->r.height *= 2;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *crop;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = crop->width;\n\t\tsel->r.height = crop->height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tsel->r = *compose;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int csi_set_scale(u32 *compose, u32 crop, u32 flags)\n{\n\tif ((flags & (V4L2_SEL_FLAG_LE | V4L2_SEL_FLAG_GE)) ==\n\t\t     (V4L2_SEL_FLAG_LE | V4L2_SEL_FLAG_GE) &&\n\t    *compose != crop && *compose != crop / 2)\n\t\treturn -ERANGE;\n\n\tif (*compose <= crop / 2 ||\n\t    (*compose < crop * 3 / 4 && !(flags & V4L2_SEL_FLAG_GE)) ||\n\t    (*compose < crop && (flags & V4L2_SEL_FLAG_LE)))\n\t\t*compose = crop / 2;\n\telse\n\t\t*compose = crop;\n\n\treturn 0;\n}\n\nstatic int csi_set_selection(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_config mbus_cfg = { .type = 0 };\n\tstruct v4l2_mbus_framefmt *infmt;\n\tstruct v4l2_rect *crop, *compose;\n\tint pad, ret;\n\n\tif (sel->pad != CSI_SINK_PAD)\n\t\treturn -EINVAL;\n\n\tret = csi_get_upstream_mbus_config(priv, &mbus_cfg);\n\tif (ret) {\n\t\tv4l2_err(&priv->sd,\n\t\t\t \"failed to get upstream media bus configuration\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->stream_count > 0) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tinfmt = __csi_get_fmt(priv, sd_state, CSI_SINK_PAD, sel->which);\n\tcrop = __csi_get_crop(priv, sd_state, sel->which);\n\tcompose = __csi_get_compose(priv, sd_state, sel->which);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\t \n\t\tif (sel->flags & V4L2_SEL_FLAG_KEEP_CONFIG) {\n\t\t\tsel->r = priv->crop;\n\t\t\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t\t\t*crop = sel->r;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcsi_try_crop(priv, &sel->r, sd_state, infmt, &mbus_cfg);\n\n\t\t*crop = sel->r;\n\n\t\t \n\t\tcompose->width = crop->width;\n\t\tcompose->height = crop->height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\t \n\t\tif (sel->flags & V4L2_SEL_FLAG_KEEP_CONFIG) {\n\t\t\tsel->r = priv->compose;\n\t\t\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t\t\t*compose = sel->r;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tret = csi_set_scale(&sel->r.width, crop->width, sel->flags);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = csi_set_scale(&sel->r.height, crop->height, sel->flags);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t*compose = sel->r;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (pad = CSI_SINK_PAD + 1; pad < CSI_NUM_PADS; pad++) {\n\t\tstruct v4l2_mbus_framefmt *outfmt;\n\n\t\toutfmt = __csi_get_fmt(priv, sd_state, pad, sel->which);\n\t\toutfmt->width = compose->width;\n\t\toutfmt->height = compose->height;\n\t}\n\nout:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int csi_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,\n\t\t\t       struct v4l2_event_subscription *sub)\n{\n\tif (sub->type != V4L2_EVENT_IMX_FRAME_INTERVAL_ERROR)\n\t\treturn -EINVAL;\n\tif (sub->id != 0)\n\t\treturn -EINVAL;\n\n\treturn v4l2_event_subscribe(fh, sub, 0, NULL);\n}\n\nstatic int csi_unsubscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,\n\t\t\t\t struct v4l2_event_subscription *sub)\n{\n\treturn v4l2_event_unsubscribe(fh, sub);\n}\n\nstatic int csi_registered(struct v4l2_subdev *sd)\n{\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct ipu_csi *csi;\n\tint i, ret;\n\tu32 code;\n\n\t \n\tcsi = ipu_csi_get(priv->ipu, priv->csi_id);\n\tif (IS_ERR(csi)) {\n\t\tv4l2_err(&priv->sd, \"failed to get CSI%d\\n\", priv->csi_id);\n\t\treturn PTR_ERR(csi);\n\t}\n\tpriv->csi = csi;\n\n\tfor (i = 0; i < CSI_NUM_PADS; i++) {\n\t\tcode = 0;\n\t\tif (i != CSI_SINK_PAD)\n\t\t\timx_media_enum_ipu_formats(&code, 0, PIXFMT_SEL_YUV);\n\n\t\t \n\t\tret = imx_media_init_mbus_fmt(&priv->format_mbus[i],\n\t\t\t\t\t      IMX_MEDIA_DEF_PIX_WIDTH,\n\t\t\t\t\t      IMX_MEDIA_DEF_PIX_HEIGHT, code,\n\t\t\t\t\t      V4L2_FIELD_NONE, &priv->cc[i]);\n\t\tif (ret)\n\t\t\tgoto put_csi;\n\n\t\t \n\t\tpriv->frame_interval[i].numerator = 1;\n\t\tpriv->frame_interval[i].denominator = 30;\n\t}\n\n\t \n\tpriv->skip = &csi_skip[0];\n\n\t \n\tpriv->crop.width = IMX_MEDIA_DEF_PIX_WIDTH;\n\tpriv->crop.height = IMX_MEDIA_DEF_PIX_HEIGHT;\n\tpriv->compose.width = IMX_MEDIA_DEF_PIX_WIDTH;\n\tpriv->compose.height = IMX_MEDIA_DEF_PIX_HEIGHT;\n\n\tpriv->fim = imx_media_fim_init(&priv->sd);\n\tif (IS_ERR(priv->fim)) {\n\t\tret = PTR_ERR(priv->fim);\n\t\tgoto put_csi;\n\t}\n\n\tpriv->vdev = imx_media_capture_device_init(priv->sd.dev, &priv->sd,\n\t\t\t\t\t\t   CSI_SRC_PAD_IDMAC, true);\n\tif (IS_ERR(priv->vdev)) {\n\t\tret = PTR_ERR(priv->vdev);\n\t\tgoto free_fim;\n\t}\n\n\tret = imx_media_capture_device_register(priv->vdev, 0);\n\tif (ret)\n\t\tgoto remove_vdev;\n\n\treturn 0;\n\nremove_vdev:\n\timx_media_capture_device_remove(priv->vdev);\nfree_fim:\n\tif (priv->fim)\n\t\timx_media_fim_free(priv->fim);\nput_csi:\n\tipu_csi_put(priv->csi);\n\treturn ret;\n}\n\nstatic void csi_unregistered(struct v4l2_subdev *sd)\n{\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\n\timx_media_capture_device_unregister(priv->vdev);\n\timx_media_capture_device_remove(priv->vdev);\n\n\tif (priv->fim)\n\t\timx_media_fim_free(priv->fim);\n\n\tif (priv->csi)\n\t\tipu_csi_put(priv->csi);\n}\n\n \nstatic int csi_get_fwnode_pad(struct media_entity *entity,\n\t\t\t      struct fwnode_endpoint *endpoint)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct csi_priv *priv = v4l2_get_subdevdata(sd);\n\tstruct fwnode_handle *csi_port = dev_fwnode(priv->dev);\n\tstruct fwnode_handle *csi_ep;\n\tint ret;\n\n\tcsi_ep = fwnode_get_next_child_node(csi_port, NULL);\n\n\tret = endpoint->local_fwnode == csi_ep ? CSI_SINK_PAD : -ENXIO;\n\n\tfwnode_handle_put(csi_ep);\n\n\treturn ret;\n}\n\nstatic const struct media_entity_operations csi_entity_ops = {\n\t.link_setup = csi_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n\t.get_fwnode_pad = csi_get_fwnode_pad,\n};\n\nstatic const struct v4l2_subdev_core_ops csi_core_ops = {\n\t.subscribe_event = csi_subscribe_event,\n\t.unsubscribe_event = csi_unsubscribe_event,\n};\n\nstatic const struct v4l2_subdev_video_ops csi_video_ops = {\n\t.g_frame_interval = csi_g_frame_interval,\n\t.s_frame_interval = csi_s_frame_interval,\n\t.s_stream = csi_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops csi_pad_ops = {\n\t.init_cfg = imx_media_init_cfg,\n\t.enum_mbus_code = csi_enum_mbus_code,\n\t.enum_frame_size = csi_enum_frame_size,\n\t.enum_frame_interval = csi_enum_frame_interval,\n\t.get_fmt = csi_get_fmt,\n\t.set_fmt = csi_set_fmt,\n\t.get_selection = csi_get_selection,\n\t.set_selection = csi_set_selection,\n\t.link_validate = csi_link_validate,\n};\n\nstatic const struct v4l2_subdev_ops csi_subdev_ops = {\n\t.core = &csi_core_ops,\n\t.video = &csi_video_ops,\n\t.pad = &csi_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops csi_internal_ops = {\n\t.registered = csi_registered,\n\t.unregistered = csi_unregistered,\n};\n\nstatic int imx_csi_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\tstruct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_async_connection *asd)\n{\n\tstruct csi_priv *priv = notifier_to_dev(notifier);\n\tstruct media_pad *sink = &priv->sd.entity.pads[CSI_SINK_PAD];\n\n\t \n\tif (sd->entity.function == MEDIA_ENT_F_VID_MUX)\n\t\tsd->grp_id = IMX_MEDIA_GRP_ID_CSI_MUX;\n\n\treturn v4l2_create_fwnode_links_to_pad(sd, sink, 0);\n}\n\nstatic const struct v4l2_async_notifier_operations csi_notify_ops = {\n\t.bound = imx_csi_notify_bound,\n};\n\nstatic int imx_csi_async_register(struct csi_priv *priv)\n{\n\tstruct v4l2_async_connection *asd = NULL;\n\tstruct fwnode_handle *ep;\n\tunsigned int port;\n\tint ret;\n\n\tv4l2_async_subdev_nf_init(&priv->notifier, &priv->sd);\n\n\t \n\tret = fwnode_property_read_u32(dev_fwnode(priv->dev), \"reg\", &port);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(priv->dev->parent),\n\t\t\t\t\t     port, 0,\n\t\t\t\t\t     FWNODE_GRAPH_ENDPOINT_NEXT);\n\tif (ep) {\n\t\tasd = v4l2_async_nf_add_fwnode_remote(&priv->notifier, ep,\n\t\t\t\t\t\t      struct v4l2_async_connection);\n\n\t\tfwnode_handle_put(ep);\n\n\t\tif (IS_ERR(asd)) {\n\t\t\tret = PTR_ERR(asd);\n\t\t\t \n\t\t\tif (ret != -EEXIST)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpriv->notifier.ops = &csi_notify_ops;\n\n\tret = v4l2_async_nf_register(&priv->notifier);\n\tif (ret)\n\t\treturn ret;\n\n\treturn v4l2_async_register_subdev(&priv->sd);\n}\n\nstatic int imx_csi_probe(struct platform_device *pdev)\n{\n\tstruct ipu_client_platformdata *pdata;\n\tstruct pinctrl *pinctrl;\n\tstruct csi_priv *priv;\n\tint i, ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, &priv->sd);\n\tpriv->dev = &pdev->dev;\n\n\tret = dma_set_coherent_mask(priv->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpriv->ipu = dev_get_drvdata(priv->dev->parent);\n\n\t \n\tpdata = priv->dev->platform_data;\n\tpriv->csi_id = pdata->csi;\n\tpriv->smfc_id = (priv->csi_id == 0) ? 0 : 2;\n\n\tpriv->active_output_pad = CSI_SRC_PAD_IDMAC;\n\n\ttimer_setup(&priv->eof_timeout_timer, csi_idmac_eof_timeout, 0);\n\tspin_lock_init(&priv->irqlock);\n\n\tv4l2_subdev_init(&priv->sd, &csi_subdev_ops);\n\tv4l2_set_subdevdata(&priv->sd, priv);\n\tpriv->sd.internal_ops = &csi_internal_ops;\n\tpriv->sd.entity.ops = &csi_entity_ops;\n\tpriv->sd.entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;\n\tpriv->sd.dev = &pdev->dev;\n\tpriv->sd.fwnode = of_fwnode_handle(pdata->of_node);\n\tpriv->sd.owner = THIS_MODULE;\n\tpriv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\n\tpriv->sd.grp_id = priv->csi_id ?\n\t\tIMX_MEDIA_GRP_ID_IPU_CSI1 : IMX_MEDIA_GRP_ID_IPU_CSI0;\n\timx_media_grp_id_to_sd_name(priv->sd.name, sizeof(priv->sd.name),\n\t\t\t\t    priv->sd.grp_id, ipu_get_num(priv->ipu));\n\n\tfor (i = 0; i < CSI_NUM_PADS; i++)\n\t\tpriv->pad[i].flags = (i == CSI_SINK_PAD) ?\n\t\t\tMEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&priv->sd.entity, CSI_NUM_PADS,\n\t\t\t\t     priv->pad);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&priv->lock);\n\n\tv4l2_ctrl_handler_init(&priv->ctrl_hdlr, 0);\n\tpriv->sd.ctrl_handler = &priv->ctrl_hdlr;\n\n\t \n\tpriv->dev->of_node = pdata->of_node;\n\tpinctrl = devm_pinctrl_get_select_default(priv->dev);\n\tif (IS_ERR(pinctrl)) {\n\t\tret = PTR_ERR(pinctrl);\n\t\tdev_dbg(priv->dev,\n\t\t\t\"devm_pinctrl_get_select_default() failed: %d\\n\", ret);\n\t\tif (ret != -ENODEV)\n\t\t\tgoto free;\n\t}\n\n\tret = imx_csi_async_register(priv);\n\tif (ret)\n\t\tgoto cleanup;\n\n\treturn 0;\n\ncleanup:\n\tv4l2_async_nf_unregister(&priv->notifier);\n\tv4l2_async_nf_cleanup(&priv->notifier);\nfree:\n\tv4l2_ctrl_handler_free(&priv->ctrl_hdlr);\n\tmutex_destroy(&priv->lock);\n\treturn ret;\n}\n\nstatic void imx_csi_remove(struct platform_device *pdev)\n{\n\tstruct v4l2_subdev *sd = platform_get_drvdata(pdev);\n\tstruct csi_priv *priv = sd_to_dev(sd);\n\n\tv4l2_ctrl_handler_free(&priv->ctrl_hdlr);\n\tmutex_destroy(&priv->lock);\n\tv4l2_async_nf_unregister(&priv->notifier);\n\tv4l2_async_nf_cleanup(&priv->notifier);\n\tv4l2_async_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n}\n\nstatic const struct platform_device_id imx_csi_ids[] = {\n\t{ .name = \"imx-ipuv3-csi\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, imx_csi_ids);\n\nstatic struct platform_driver imx_csi_driver = {\n\t.probe = imx_csi_probe,\n\t.remove_new = imx_csi_remove,\n\t.id_table = imx_csi_ids,\n\t.driver = {\n\t\t.name = \"imx-ipuv3-csi\",\n\t},\n};\nmodule_platform_driver(imx_csi_driver);\n\nMODULE_DESCRIPTION(\"i.MX CSI subdev driver\");\nMODULE_AUTHOR(\"Steve Longerbeam <steve_longerbeam@mentor.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}