{
  "module_name": "atmel-isc-base.c",
  "hash_id": "cad80a1e66b806f0450c415893bc764e1fb50b4fc9625b54eed0d8623dcfca17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/deprecated/atmel/atmel-isc-base.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/videodev2.h>\n#include <linux/atmel-isc-media.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"atmel-isc-regs.h\"\n#include \"atmel-isc.h\"\n\nstatic unsigned int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"debug level (0-2)\");\n\nstatic unsigned int sensor_preferred = 1;\nmodule_param(sensor_preferred, uint, 0644);\nMODULE_PARM_DESC(sensor_preferred,\n\t\t \"Sensor is preferred to output the specified format (1-on 0-off), default 1\");\n\n#define ISC_IS_FORMAT_RAW(mbus_code) \\\n\t(((mbus_code) & 0xf000) == 0x3000)\n\n#define ISC_IS_FORMAT_GREY(mbus_code) \\\n\t(((mbus_code) == MEDIA_BUS_FMT_Y10_1X10) | \\\n\t(((mbus_code) == MEDIA_BUS_FMT_Y8_1X8)))\n\nstatic inline void isc_update_v4l2_ctrls(struct isc_device *isc)\n{\n\tstruct isc_ctrls *ctrls = &isc->ctrls;\n\n\t \n\tv4l2_ctrl_s_ctrl(isc->r_gain_ctrl, ctrls->gain[ISC_HIS_CFG_MODE_R]);\n\tv4l2_ctrl_s_ctrl(isc->b_gain_ctrl, ctrls->gain[ISC_HIS_CFG_MODE_B]);\n\tv4l2_ctrl_s_ctrl(isc->gr_gain_ctrl, ctrls->gain[ISC_HIS_CFG_MODE_GR]);\n\tv4l2_ctrl_s_ctrl(isc->gb_gain_ctrl, ctrls->gain[ISC_HIS_CFG_MODE_GB]);\n\n\tv4l2_ctrl_s_ctrl(isc->r_off_ctrl, ctrls->offset[ISC_HIS_CFG_MODE_R]);\n\tv4l2_ctrl_s_ctrl(isc->b_off_ctrl, ctrls->offset[ISC_HIS_CFG_MODE_B]);\n\tv4l2_ctrl_s_ctrl(isc->gr_off_ctrl, ctrls->offset[ISC_HIS_CFG_MODE_GR]);\n\tv4l2_ctrl_s_ctrl(isc->gb_off_ctrl, ctrls->offset[ISC_HIS_CFG_MODE_GB]);\n}\n\nstatic inline void isc_update_awb_ctrls(struct isc_device *isc)\n{\n\tstruct isc_ctrls *ctrls = &isc->ctrls;\n\n\t \n\n\tregmap_write(isc->regmap, ISC_WB_O_RGR,\n\t\t     ((ctrls->offset[ISC_HIS_CFG_MODE_R])) |\n\t\t     ((ctrls->offset[ISC_HIS_CFG_MODE_GR]) << 16));\n\tregmap_write(isc->regmap, ISC_WB_O_BGB,\n\t\t     ((ctrls->offset[ISC_HIS_CFG_MODE_B])) |\n\t\t     ((ctrls->offset[ISC_HIS_CFG_MODE_GB]) << 16));\n\tregmap_write(isc->regmap, ISC_WB_G_RGR,\n\t\t     ctrls->gain[ISC_HIS_CFG_MODE_R] |\n\t\t     (ctrls->gain[ISC_HIS_CFG_MODE_GR] << 16));\n\tregmap_write(isc->regmap, ISC_WB_G_BGB,\n\t\t     ctrls->gain[ISC_HIS_CFG_MODE_B] |\n\t\t     (ctrls->gain[ISC_HIS_CFG_MODE_GB] << 16));\n}\n\nstatic inline void isc_reset_awb_ctrls(struct isc_device *isc)\n{\n\tunsigned int c;\n\n\tfor (c = ISC_HIS_CFG_MODE_GR; c <= ISC_HIS_CFG_MODE_B; c++) {\n\t\t \n\t\tisc->ctrls.gain[c] = 1 << 9;\n\t\t \n\t\tisc->ctrls.offset[c] = 0;\n\t}\n}\n\n\nstatic int isc_queue_setup(struct vb2_queue *vq,\n\t\t\t    unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t    unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct isc_device *isc = vb2_get_drv_priv(vq);\n\tunsigned int size = isc->fmt.fmt.pix.sizeimage;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic int isc_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct isc_device *isc = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long size = isc->fmt.fmt.pix.sizeimage;\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tv4l2_err(&isc->v4l2_dev, \"buffer too small (%lu < %lu)\\n\",\n\t\t\t vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, size);\n\n\tvbuf->field = isc->fmt.fmt.pix.field;\n\n\treturn 0;\n}\n\nstatic void isc_crop_pfe(struct isc_device *isc)\n{\n\tstruct regmap *regmap = isc->regmap;\n\tu32 h, w;\n\n\th = isc->fmt.fmt.pix.height;\n\tw = isc->fmt.fmt.pix.width;\n\n\t \n\tif (!ISC_IS_FORMAT_RAW(isc->config.sd_format->mbus_code)) {\n\t\th <<= 1;\n\t\tw <<= 1;\n\t}\n\n\t \n\tregmap_write(regmap, ISC_PFE_CFG1,\n\t\t     (ISC_PFE_CFG1_COLMIN(0) & ISC_PFE_CFG1_COLMIN_MASK) |\n\t\t     (ISC_PFE_CFG1_COLMAX(w - 1) & ISC_PFE_CFG1_COLMAX_MASK));\n\n\tregmap_write(regmap, ISC_PFE_CFG2,\n\t\t     (ISC_PFE_CFG2_ROWMIN(0) & ISC_PFE_CFG2_ROWMIN_MASK) |\n\t\t     (ISC_PFE_CFG2_ROWMAX(h - 1) & ISC_PFE_CFG2_ROWMAX_MASK));\n\n\tregmap_update_bits(regmap, ISC_PFE_CFG0,\n\t\t\t   ISC_PFE_CFG0_COLEN | ISC_PFE_CFG0_ROWEN,\n\t\t\t   ISC_PFE_CFG0_COLEN | ISC_PFE_CFG0_ROWEN);\n}\n\nstatic void isc_start_dma(struct isc_device *isc)\n{\n\tstruct regmap *regmap = isc->regmap;\n\tu32 sizeimage = isc->fmt.fmt.pix.sizeimage;\n\tu32 dctrl_dview;\n\tdma_addr_t addr0;\n\n\taddr0 = vb2_dma_contig_plane_dma_addr(&isc->cur_frm->vb.vb2_buf, 0);\n\tregmap_write(regmap, ISC_DAD0 + isc->offsets.dma, addr0);\n\n\tswitch (isc->config.fourcc) {\n\tcase V4L2_PIX_FMT_YUV420:\n\t\tregmap_write(regmap, ISC_DAD1 + isc->offsets.dma,\n\t\t\t     addr0 + (sizeimage * 2) / 3);\n\t\tregmap_write(regmap, ISC_DAD2 + isc->offsets.dma,\n\t\t\t     addr0 + (sizeimage * 5) / 6);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV422P:\n\t\tregmap_write(regmap, ISC_DAD1 + isc->offsets.dma,\n\t\t\t     addr0 + sizeimage / 2);\n\t\tregmap_write(regmap, ISC_DAD2 + isc->offsets.dma,\n\t\t\t     addr0 + (sizeimage * 3) / 4);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdctrl_dview = isc->config.dctrl_dview;\n\n\tregmap_write(regmap, ISC_DCTRL + isc->offsets.dma,\n\t\t     dctrl_dview | ISC_DCTRL_IE_IS);\n\tspin_lock(&isc->awb_lock);\n\tregmap_write(regmap, ISC_CTRLEN, ISC_CTRL_CAPTURE);\n\tspin_unlock(&isc->awb_lock);\n}\n\nstatic void isc_set_pipeline(struct isc_device *isc, u32 pipeline)\n{\n\tstruct regmap *regmap = isc->regmap;\n\tstruct isc_ctrls *ctrls = &isc->ctrls;\n\tu32 val, bay_cfg;\n\tconst u32 *gamma;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ISC_PIPE_LINE_NODE_NUM; i++) {\n\t\tval = pipeline & BIT(i) ? 1 : 0;\n\t\tregmap_field_write(isc->pipeline[i], val);\n\t}\n\n\tif (!pipeline)\n\t\treturn;\n\n\tbay_cfg = isc->config.sd_format->cfa_baycfg;\n\n\tregmap_write(regmap, ISC_WB_CFG, bay_cfg);\n\tisc_update_awb_ctrls(isc);\n\tisc_update_v4l2_ctrls(isc);\n\n\tregmap_write(regmap, ISC_CFA_CFG, bay_cfg | ISC_CFA_CFG_EITPOL);\n\n\tgamma = &isc->gamma_table[ctrls->gamma_index][0];\n\tregmap_bulk_write(regmap, ISC_GAM_BENTRY, gamma, GAMMA_ENTRIES);\n\tregmap_bulk_write(regmap, ISC_GAM_GENTRY, gamma, GAMMA_ENTRIES);\n\tregmap_bulk_write(regmap, ISC_GAM_RENTRY, gamma, GAMMA_ENTRIES);\n\n\tisc->config_dpc(isc);\n\tisc->config_csc(isc);\n\tisc->config_cbc(isc);\n\tisc->config_cc(isc);\n\tisc->config_gam(isc);\n}\n\nstatic int isc_update_profile(struct isc_device *isc)\n{\n\tstruct regmap *regmap = isc->regmap;\n\tu32 sr;\n\tint counter = 100;\n\n\tregmap_write(regmap, ISC_CTRLEN, ISC_CTRL_UPPRO);\n\n\tregmap_read(regmap, ISC_CTRLSR, &sr);\n\twhile ((sr & ISC_CTRL_UPPRO) && counter--) {\n\t\tusleep_range(1000, 2000);\n\t\tregmap_read(regmap, ISC_CTRLSR, &sr);\n\t}\n\n\tif (counter < 0) {\n\t\tv4l2_warn(&isc->v4l2_dev, \"Time out to update profile\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void isc_set_histogram(struct isc_device *isc, bool enable)\n{\n\tstruct regmap *regmap = isc->regmap;\n\tstruct isc_ctrls *ctrls = &isc->ctrls;\n\n\tif (enable) {\n\t\tregmap_write(regmap, ISC_HIS_CFG + isc->offsets.his,\n\t\t\t     ISC_HIS_CFG_MODE_GR |\n\t\t\t     (isc->config.sd_format->cfa_baycfg\n\t\t\t\t\t<< ISC_HIS_CFG_BAYSEL_SHIFT) |\n\t\t\t\t\tISC_HIS_CFG_RAR);\n\t\tregmap_write(regmap, ISC_HIS_CTRL + isc->offsets.his,\n\t\t\t     ISC_HIS_CTRL_EN);\n\t\tregmap_write(regmap, ISC_INTEN, ISC_INT_HISDONE);\n\t\tctrls->hist_id = ISC_HIS_CFG_MODE_GR;\n\t\tisc_update_profile(isc);\n\t\tregmap_write(regmap, ISC_CTRLEN, ISC_CTRL_HISREQ);\n\n\t\tctrls->hist_stat = HIST_ENABLED;\n\t} else {\n\t\tregmap_write(regmap, ISC_INTDIS, ISC_INT_HISDONE);\n\t\tregmap_write(regmap, ISC_HIS_CTRL + isc->offsets.his,\n\t\t\t     ISC_HIS_CTRL_DIS);\n\n\t\tctrls->hist_stat = HIST_DISABLED;\n\t}\n}\n\nstatic int isc_configure(struct isc_device *isc)\n{\n\tstruct regmap *regmap = isc->regmap;\n\tu32 pfe_cfg0, dcfg, mask, pipeline;\n\tstruct isc_subdev_entity *subdev = isc->current_subdev;\n\n\tpfe_cfg0 = isc->config.sd_format->pfe_cfg0_bps;\n\tpipeline = isc->config.bits_pipeline;\n\n\tdcfg = isc->config.dcfg_imode | isc->dcfg;\n\n\tpfe_cfg0  |= subdev->pfe_cfg0 | ISC_PFE_CFG0_MODE_PROGRESSIVE;\n\tmask = ISC_PFE_CFG0_BPS_MASK | ISC_PFE_CFG0_HPOL_LOW |\n\t       ISC_PFE_CFG0_VPOL_LOW | ISC_PFE_CFG0_PPOL_LOW |\n\t       ISC_PFE_CFG0_MODE_MASK | ISC_PFE_CFG0_CCIR_CRC |\n\t       ISC_PFE_CFG0_CCIR656 | ISC_PFE_CFG0_MIPI;\n\n\tregmap_update_bits(regmap, ISC_PFE_CFG0, mask, pfe_cfg0);\n\n\tisc->config_rlp(isc);\n\n\tregmap_write(regmap, ISC_DCFG + isc->offsets.dma, dcfg);\n\n\t \n\tisc_set_pipeline(isc, pipeline);\n\n\t \n\tif (isc->ctrls.awb &&\n\t    ISC_IS_FORMAT_RAW(isc->config.sd_format->mbus_code))\n\t\tisc_set_histogram(isc, true);\n\telse\n\t\tisc_set_histogram(isc, false);\n\n\t \n\treturn isc_update_profile(isc);\n}\n\nstatic int isc_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct isc_device *isc = vb2_get_drv_priv(vq);\n\tstruct regmap *regmap = isc->regmap;\n\tstruct isc_buffer *buf;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tret = v4l2_subdev_call(isc->current_subdev->sd, video, s_stream, 1);\n\tif (ret && ret != -ENOIOCTLCMD) {\n\t\tv4l2_err(&isc->v4l2_dev, \"stream on failed in subdev %d\\n\",\n\t\t\t ret);\n\t\tgoto err_start_stream;\n\t}\n\n\tret = pm_runtime_resume_and_get(isc->dev);\n\tif (ret < 0) {\n\t\tv4l2_err(&isc->v4l2_dev, \"RPM resume failed in subdev %d\\n\",\n\t\t\t ret);\n\t\tgoto err_pm_get;\n\t}\n\n\tret = isc_configure(isc);\n\tif (unlikely(ret))\n\t\tgoto err_configure;\n\n\t \n\tregmap_write(regmap, ISC_INTEN, ISC_INT_DDONE);\n\n\tspin_lock_irqsave(&isc->dma_queue_lock, flags);\n\n\tisc->sequence = 0;\n\tisc->stop = false;\n\treinit_completion(&isc->comp);\n\n\tisc->cur_frm = list_first_entry(&isc->dma_queue,\n\t\t\t\t\tstruct isc_buffer, list);\n\tlist_del(&isc->cur_frm->list);\n\n\tisc_crop_pfe(isc);\n\tisc_start_dma(isc);\n\n\tspin_unlock_irqrestore(&isc->dma_queue_lock, flags);\n\n\t \n\tif (ISC_IS_FORMAT_RAW(isc->config.sd_format->mbus_code))\n\t\tv4l2_ctrl_activate(isc->do_wb_ctrl, true);\n\n\treturn 0;\n\nerr_configure:\n\tpm_runtime_put_sync(isc->dev);\nerr_pm_get:\n\tv4l2_subdev_call(isc->current_subdev->sd, video, s_stream, 0);\n\nerr_start_stream:\n\tspin_lock_irqsave(&isc->dma_queue_lock, flags);\n\tlist_for_each_entry(buf, &isc->dma_queue, list)\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\n\tINIT_LIST_HEAD(&isc->dma_queue);\n\tspin_unlock_irqrestore(&isc->dma_queue_lock, flags);\n\n\treturn ret;\n}\n\nstatic void isc_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct isc_device *isc = vb2_get_drv_priv(vq);\n\tunsigned long flags;\n\tstruct isc_buffer *buf;\n\tint ret;\n\n\tmutex_lock(&isc->awb_mutex);\n\tv4l2_ctrl_activate(isc->do_wb_ctrl, false);\n\n\tisc->stop = true;\n\n\t \n\tif (isc->cur_frm && !wait_for_completion_timeout(&isc->comp, 5 * HZ))\n\t\tv4l2_err(&isc->v4l2_dev,\n\t\t\t \"Timeout waiting for end of the capture\\n\");\n\n\tmutex_unlock(&isc->awb_mutex);\n\n\t \n\tregmap_write(isc->regmap, ISC_INTDIS, ISC_INT_DDONE);\n\n\tpm_runtime_put_sync(isc->dev);\n\n\t \n\tret = v4l2_subdev_call(isc->current_subdev->sd, video, s_stream, 0);\n\tif (ret && ret != -ENOIOCTLCMD)\n\t\tv4l2_err(&isc->v4l2_dev, \"stream off failed in subdev\\n\");\n\n\t \n\tspin_lock_irqsave(&isc->dma_queue_lock, flags);\n\tif (unlikely(isc->cur_frm)) {\n\t\tvb2_buffer_done(&isc->cur_frm->vb.vb2_buf,\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\t\tisc->cur_frm = NULL;\n\t}\n\tlist_for_each_entry(buf, &isc->dma_queue, list)\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\tINIT_LIST_HEAD(&isc->dma_queue);\n\tspin_unlock_irqrestore(&isc->dma_queue_lock, flags);\n}\n\nstatic void isc_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct isc_buffer *buf = container_of(vbuf, struct isc_buffer, vb);\n\tstruct isc_device *isc = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&isc->dma_queue_lock, flags);\n\tif (!isc->cur_frm && list_empty(&isc->dma_queue) &&\n\t\tvb2_start_streaming_called(vb->vb2_queue)) {\n\t\tisc->cur_frm = buf;\n\t\tisc_start_dma(isc);\n\t} else\n\t\tlist_add_tail(&buf->list, &isc->dma_queue);\n\tspin_unlock_irqrestore(&isc->dma_queue_lock, flags);\n}\n\nstatic struct isc_format *find_format_by_fourcc(struct isc_device *isc,\n\t\t\t\t\t\t unsigned int fourcc)\n{\n\tunsigned int num_formats = isc->num_user_formats;\n\tstruct isc_format *fmt;\n\tunsigned int i;\n\n\tfor (i = 0; i < num_formats; i++) {\n\t\tfmt = isc->user_formats[i];\n\t\tif (fmt->fourcc == fourcc)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct vb2_ops isc_vb2_ops = {\n\t.queue_setup\t\t= isc_queue_setup,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n\t.buf_prepare\t\t= isc_buffer_prepare,\n\t.start_streaming\t= isc_start_streaming,\n\t.stop_streaming\t\t= isc_stop_streaming,\n\t.buf_queue\t\t= isc_buffer_queue,\n};\n\nstatic int isc_querycap(struct file *file, void *priv,\n\t\t\t struct v4l2_capability *cap)\n{\n\tstruct isc_device *isc = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"microchip-isc\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"Atmel Image Sensor Controller\", sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:%s\", isc->v4l2_dev.name);\n\n\treturn 0;\n}\n\nstatic int isc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t struct v4l2_fmtdesc *f)\n{\n\tstruct isc_device *isc = video_drvdata(file);\n\tu32 index = f->index;\n\tu32 i, supported_index;\n\n\tif (index < isc->controller_formats_size) {\n\t\tf->pixelformat = isc->controller_formats[index].fourcc;\n\t\treturn 0;\n\t}\n\n\tindex -= isc->controller_formats_size;\n\n\tsupported_index = 0;\n\n\tfor (i = 0; i < isc->formats_list_size; i++) {\n\t\tif (!ISC_IS_FORMAT_RAW(isc->formats_list[i].mbus_code) ||\n\t\t    !isc->formats_list[i].sd_support)\n\t\t\tcontinue;\n\t\tif (supported_index == index) {\n\t\t\tf->pixelformat = isc->formats_list[i].fourcc;\n\t\t\treturn 0;\n\t\t}\n\t\tsupported_index++;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int isc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *fmt)\n{\n\tstruct isc_device *isc = video_drvdata(file);\n\n\t*fmt = isc->fmt;\n\n\treturn 0;\n}\n\n \nstatic int isc_try_validate_formats(struct isc_device *isc)\n{\n\tint ret;\n\tbool bayer = false, yuv = false, rgb = false, grey = false;\n\n\t \n\tswitch (isc->try_config.fourcc) {\n\tcase V4L2_PIX_FMT_SBGGR8:\n\tcase V4L2_PIX_FMT_SGBRG8:\n\tcase V4L2_PIX_FMT_SGRBG8:\n\tcase V4L2_PIX_FMT_SRGGB8:\n\tcase V4L2_PIX_FMT_SBGGR10:\n\tcase V4L2_PIX_FMT_SGBRG10:\n\tcase V4L2_PIX_FMT_SGRBG10:\n\tcase V4L2_PIX_FMT_SRGGB10:\n\tcase V4L2_PIX_FMT_SBGGR12:\n\tcase V4L2_PIX_FMT_SGBRG12:\n\tcase V4L2_PIX_FMT_SGRBG12:\n\tcase V4L2_PIX_FMT_SRGGB12:\n\t\tret = 0;\n\t\tbayer = true;\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YUV422P:\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_VYUY:\n\t\tret = 0;\n\t\tyuv = true;\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_RGB565:\n\tcase V4L2_PIX_FMT_ABGR32:\n\tcase V4L2_PIX_FMT_XBGR32:\n\tcase V4L2_PIX_FMT_ARGB444:\n\tcase V4L2_PIX_FMT_ARGB555:\n\t\tret = 0;\n\t\trgb = true;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_GREY:\n\tcase V4L2_PIX_FMT_Y10:\n\tcase V4L2_PIX_FMT_Y16:\n\t\tret = 0;\n\t\tgrey = true;\n\t\tbreak;\n\tdefault:\n\t \n\t\tret = -EINVAL;\n\t}\n\tv4l2_dbg(1, debug, &isc->v4l2_dev,\n\t\t \"Format validation, requested rgb=%u, yuv=%u, grey=%u, bayer=%u\\n\",\n\t\t rgb, yuv, grey, bayer);\n\n\t \n\tif ((bayer) && !ISC_IS_FORMAT_RAW(isc->try_config.sd_format->mbus_code))\n\t\treturn -EINVAL;\n\n\t \n\tif (grey && !ISC_IS_FORMAT_RAW(isc->try_config.sd_format->mbus_code) &&\n\t    !ISC_IS_FORMAT_GREY(isc->try_config.sd_format->mbus_code))\n\t\treturn -EINVAL;\n\n\treturn ret;\n}\n\n \nstatic int isc_try_configure_rlp_dma(struct isc_device *isc, bool direct_dump)\n{\n\tisc->try_config.rlp_cfg_mode = 0;\n\n\tswitch (isc->try_config.fourcc) {\n\tcase V4L2_PIX_FMT_SBGGR8:\n\tcase V4L2_PIX_FMT_SGBRG8:\n\tcase V4L2_PIX_FMT_SGRBG8:\n\tcase V4L2_PIX_FMT_SRGGB8:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_DAT8;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_PACKED8;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PACKED;\n\t\tisc->try_config.bpp = 8;\n\t\tisc->try_config.bpp_v4l2 = 8;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SBGGR10:\n\tcase V4L2_PIX_FMT_SGBRG10:\n\tcase V4L2_PIX_FMT_SGRBG10:\n\tcase V4L2_PIX_FMT_SRGGB10:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_DAT10;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_PACKED16;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PACKED;\n\t\tisc->try_config.bpp = 16;\n\t\tisc->try_config.bpp_v4l2 = 16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SBGGR12:\n\tcase V4L2_PIX_FMT_SGBRG12:\n\tcase V4L2_PIX_FMT_SGRBG12:\n\tcase V4L2_PIX_FMT_SRGGB12:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_DAT12;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_PACKED16;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PACKED;\n\t\tisc->try_config.bpp = 16;\n\t\tisc->try_config.bpp_v4l2 = 16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_RGB565;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_PACKED16;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PACKED;\n\t\tisc->try_config.bpp = 16;\n\t\tisc->try_config.bpp_v4l2 = 16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_ARGB444:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_ARGB444;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_PACKED16;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PACKED;\n\t\tisc->try_config.bpp = 16;\n\t\tisc->try_config.bpp_v4l2 = 16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_ARGB555:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_ARGB555;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_PACKED16;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PACKED;\n\t\tisc->try_config.bpp = 16;\n\t\tisc->try_config.bpp_v4l2 = 16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_ABGR32:\n\tcase V4L2_PIX_FMT_XBGR32:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_ARGB32;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_PACKED32;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PACKED;\n\t\tisc->try_config.bpp = 32;\n\t\tisc->try_config.bpp_v4l2 = 32;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV420:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_YYCC;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_YC420P;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PLANAR;\n\t\tisc->try_config.bpp = 12;\n\t\tisc->try_config.bpp_v4l2 = 8;  \n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV422P:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_YYCC;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_YC422P;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PLANAR;\n\t\tisc->try_config.bpp = 16;\n\t\tisc->try_config.bpp_v4l2 = 8;  \n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_YCYC | ISC_RLP_CFG_YMODE_YUYV;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_PACKED32;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PACKED;\n\t\tisc->try_config.bpp = 16;\n\t\tisc->try_config.bpp_v4l2 = 16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_UYVY:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_YCYC | ISC_RLP_CFG_YMODE_UYVY;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_PACKED32;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PACKED;\n\t\tisc->try_config.bpp = 16;\n\t\tisc->try_config.bpp_v4l2 = 16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VYUY:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_YCYC | ISC_RLP_CFG_YMODE_VYUY;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_PACKED32;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PACKED;\n\t\tisc->try_config.bpp = 16;\n\t\tisc->try_config.bpp_v4l2 = 16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_GREY:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_DATY8;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_PACKED8;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PACKED;\n\t\tisc->try_config.bpp = 8;\n\t\tisc->try_config.bpp_v4l2 = 8;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_Y16:\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_DATY10 | ISC_RLP_CFG_LSH;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_Y10:\n\t\tisc->try_config.rlp_cfg_mode |= ISC_RLP_CFG_MODE_DATY10;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_PACKED16;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PACKED;\n\t\tisc->try_config.bpp = 16;\n\t\tisc->try_config.bpp_v4l2 = 16;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (direct_dump) {\n\t\tisc->try_config.rlp_cfg_mode = ISC_RLP_CFG_MODE_DAT8;\n\t\tisc->try_config.dcfg_imode = ISC_DCFG_IMODE_PACKED8;\n\t\tisc->try_config.dctrl_dview = ISC_DCTRL_DVIEW_PACKED;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int isc_try_configure_pipeline(struct isc_device *isc)\n{\n\tswitch (isc->try_config.fourcc) {\n\tcase V4L2_PIX_FMT_RGB565:\n\tcase V4L2_PIX_FMT_ARGB555:\n\tcase V4L2_PIX_FMT_ARGB444:\n\tcase V4L2_PIX_FMT_ABGR32:\n\tcase V4L2_PIX_FMT_XBGR32:\n\t\t \n\t\tif (ISC_IS_FORMAT_RAW(isc->try_config.sd_format->mbus_code)) {\n\t\t\tisc->try_config.bits_pipeline = CFA_ENABLE |\n\t\t\t\tWB_ENABLE | GAM_ENABLES | DPC_BLCENABLE |\n\t\t\t\tCC_ENABLE;\n\t\t} else {\n\t\t\tisc->try_config.bits_pipeline = 0x0;\n\t\t}\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV420:\n\t\t \n\t\tif (ISC_IS_FORMAT_RAW(isc->try_config.sd_format->mbus_code)) {\n\t\t\tisc->try_config.bits_pipeline = CFA_ENABLE |\n\t\t\t\tCSC_ENABLE | GAM_ENABLES | WB_ENABLE |\n\t\t\t\tSUB420_ENABLE | SUB422_ENABLE | CBC_ENABLE |\n\t\t\t\tDPC_BLCENABLE;\n\t\t} else {\n\t\t\tisc->try_config.bits_pipeline = 0x0;\n\t\t}\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV422P:\n\t\t \n\t\tif (ISC_IS_FORMAT_RAW(isc->try_config.sd_format->mbus_code)) {\n\t\t\tisc->try_config.bits_pipeline = CFA_ENABLE |\n\t\t\t\tCSC_ENABLE | WB_ENABLE | GAM_ENABLES |\n\t\t\t\tSUB422_ENABLE | CBC_ENABLE | DPC_BLCENABLE;\n\t\t} else {\n\t\t\tisc->try_config.bits_pipeline = 0x0;\n\t\t}\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_VYUY:\n\t\t \n\t\tif (ISC_IS_FORMAT_RAW(isc->try_config.sd_format->mbus_code)) {\n\t\t\tisc->try_config.bits_pipeline = CFA_ENABLE |\n\t\t\t\tCSC_ENABLE | WB_ENABLE | GAM_ENABLES |\n\t\t\t\tSUB422_ENABLE | CBC_ENABLE | DPC_BLCENABLE;\n\t\t} else {\n\t\t\tisc->try_config.bits_pipeline = 0x0;\n\t\t}\n\t\tbreak;\n\tcase V4L2_PIX_FMT_GREY:\n\tcase V4L2_PIX_FMT_Y16:\n\t\t \n\t\tif (ISC_IS_FORMAT_RAW(isc->try_config.sd_format->mbus_code)) {\n\t\t\tisc->try_config.bits_pipeline = CFA_ENABLE |\n\t\t\t\tCSC_ENABLE | WB_ENABLE | GAM_ENABLES |\n\t\t\t\tCBC_ENABLE | DPC_BLCENABLE;\n\t\t} else {\n\t\t\tisc->try_config.bits_pipeline = 0x0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (ISC_IS_FORMAT_RAW(isc->try_config.sd_format->mbus_code))\n\t\t\tisc->try_config.bits_pipeline = WB_ENABLE | DPC_BLCENABLE;\n\t\telse\n\t\t\tisc->try_config.bits_pipeline = 0x0;\n\t}\n\n\t \n\tisc->adapt_pipeline(isc);\n\n\treturn 0;\n}\n\nstatic void isc_try_fse(struct isc_device *isc,\n\t\t\tstruct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tint ret;\n\n\t \n\tif (!isc->try_config.sd_format)\n\t\treturn;\n\n\tfse.code = isc->try_config.sd_format->mbus_code;\n\n\tret = v4l2_subdev_call(isc->current_subdev->sd, pad, enum_frame_size,\n\t\t\t       sd_state, &fse);\n\t \n\tif (ret) {\n\t\tsd_state->pads->try_crop.width = isc->max_width;\n\t\tsd_state->pads->try_crop.height = isc->max_height;\n\t} else {\n\t\tsd_state->pads->try_crop.width = fse.max_width;\n\t\tsd_state->pads->try_crop.height = fse.max_height;\n\t}\n}\n\nstatic int isc_try_fmt(struct isc_device *isc, struct v4l2_format *f,\n\t\t\tu32 *code)\n{\n\tint i;\n\tstruct isc_format *sd_fmt = NULL, *direct_fmt = NULL;\n\tstruct v4l2_pix_format *pixfmt = &f->fmt.pix;\n\tstruct v4l2_subdev_pad_config pad_cfg = {};\n\tstruct v4l2_subdev_state pad_state = {\n\t\t.pads = &pad_cfg,\n\t};\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tu32 mbus_code;\n\tint ret;\n\tbool rlp_dma_direct_dump = false;\n\n\tif (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < isc->num_user_formats; i++) {\n\t\tif (ISC_IS_FORMAT_RAW(isc->user_formats[i]->mbus_code)) {\n\t\t\tsd_fmt = isc->user_formats[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tdirect_fmt = find_format_by_fourcc(isc, pixfmt->pixelformat);\n\n\t \n\tif (direct_fmt && sd_fmt && sensor_preferred)\n\t\tsd_fmt = direct_fmt;\n\n\t \n\tif (direct_fmt && !sd_fmt)\n\t\tsd_fmt = direct_fmt;\n\n\t \n\tif (sd_fmt == direct_fmt)\n\t\trlp_dma_direct_dump = true;\n\n\t \n\tif (!sd_fmt && !direct_fmt) {\n\t\tsd_fmt = isc->user_formats[isc->num_user_formats - 1];\n\t\tv4l2_dbg(1, debug, &isc->v4l2_dev,\n\t\t\t \"Sensor not supporting %.4s, using %.4s\\n\",\n\t\t\t (char *)&pixfmt->pixelformat, (char *)&sd_fmt->fourcc);\n\t}\n\n\tif (!sd_fmt) {\n\t\tret = -EINVAL;\n\t\tgoto isc_try_fmt_err;\n\t}\n\n\t \n\tv4l2_dbg(1, debug, &isc->v4l2_dev,\n\t\t \"Preferring to have sensor using format %.4s\\n\",\n\t\t (char *)&sd_fmt->fourcc);\n\n\t \n\tisc->try_config.sd_format = sd_fmt;\n\n\t \n\tif (pixfmt->width > isc->max_width)\n\t\tpixfmt->width = isc->max_width;\n\tif (pixfmt->height > isc->max_height)\n\t\tpixfmt->height = isc->max_height;\n\n\t \n\tmbus_code = sd_fmt->mbus_code;\n\n\t \n\n\tisc->try_config.fourcc = pixfmt->pixelformat;\n\n\tif (isc_try_validate_formats(isc)) {\n\t\tpixfmt->pixelformat = isc->try_config.fourcc = sd_fmt->fourcc;\n\t\t \n\t\tret = isc_try_validate_formats(isc);\n\t\tif (ret)\n\t\t\tgoto isc_try_fmt_err;\n\t}\n\n\tret = isc_try_configure_rlp_dma(isc, rlp_dma_direct_dump);\n\tif (ret)\n\t\tgoto isc_try_fmt_err;\n\n\tret = isc_try_configure_pipeline(isc);\n\tif (ret)\n\t\tgoto isc_try_fmt_err;\n\n\t \n\tisc_try_fse(isc, &pad_state);\n\n\tv4l2_fill_mbus_format(&format.format, pixfmt, mbus_code);\n\tret = v4l2_subdev_call(isc->current_subdev->sd, pad, set_fmt,\n\t\t\t       &pad_state, &format);\n\tif (ret < 0)\n\t\tgoto isc_try_fmt_subdev_err;\n\n\tv4l2_fill_pix_format(pixfmt, &format.format);\n\n\t \n\tif (pixfmt->width > isc->max_width)\n\t\tpixfmt->width = isc->max_width;\n\tif (pixfmt->height > isc->max_height)\n\t\tpixfmt->height = isc->max_height;\n\n\tpixfmt->field = V4L2_FIELD_NONE;\n\tpixfmt->bytesperline = (pixfmt->width * isc->try_config.bpp_v4l2) >> 3;\n\tpixfmt->sizeimage = ((pixfmt->width * isc->try_config.bpp) >> 3) *\n\t\t\t     pixfmt->height;\n\n\tif (code)\n\t\t*code = mbus_code;\n\n\treturn 0;\n\nisc_try_fmt_err:\n\tv4l2_err(&isc->v4l2_dev, \"Could not find any possible format for a working pipeline\\n\");\nisc_try_fmt_subdev_err:\n\tmemset(&isc->try_config, 0, sizeof(isc->try_config));\n\n\treturn ret;\n}\n\nstatic int isc_set_fmt(struct isc_device *isc, struct v4l2_format *f)\n{\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tu32 mbus_code = 0;\n\tint ret;\n\n\tret = isc_try_fmt(isc, f, &mbus_code);\n\tif (ret)\n\t\treturn ret;\n\n\tv4l2_fill_mbus_format(&format.format, &f->fmt.pix, mbus_code);\n\tret = v4l2_subdev_call(isc->current_subdev->sd, pad,\n\t\t\t       set_fmt, NULL, &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (f->fmt.pix.width > isc->max_width)\n\t\tf->fmt.pix.width = isc->max_width;\n\tif (f->fmt.pix.height > isc->max_height)\n\t\tf->fmt.pix.height = isc->max_height;\n\n\tisc->fmt = *f;\n\n\tif (isc->try_config.sd_format && isc->config.sd_format &&\n\t    isc->try_config.sd_format != isc->config.sd_format) {\n\t\tisc->ctrls.hist_stat = HIST_INIT;\n\t\tisc_reset_awb_ctrls(isc);\n\t\tisc_update_v4l2_ctrls(isc);\n\t}\n\t \n\tisc->config = isc->try_config;\n\n\tv4l2_dbg(1, debug, &isc->v4l2_dev, \"New ISC configuration in place\\n\");\n\n\treturn 0;\n}\n\nstatic int isc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct isc_device *isc = video_drvdata(file);\n\n\tif (vb2_is_busy(&isc->vb2_vidq))\n\t\treturn -EBUSY;\n\n\treturn isc_set_fmt(isc, f);\n}\n\nstatic int isc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct isc_device *isc = video_drvdata(file);\n\n\treturn isc_try_fmt(isc, f, NULL);\n}\n\nstatic int isc_enum_input(struct file *file, void *priv,\n\t\t\t   struct v4l2_input *inp)\n{\n\tif (inp->index != 0)\n\t\treturn -EINVAL;\n\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tinp->std = 0;\n\tstrscpy(inp->name, \"Camera\", sizeof(inp->name));\n\n\treturn 0;\n}\n\nstatic int isc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\n\treturn 0;\n}\n\nstatic int isc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tif (i > 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int isc_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct isc_device *isc = video_drvdata(file);\n\n\treturn v4l2_g_parm_cap(video_devdata(file), isc->current_subdev->sd, a);\n}\n\nstatic int isc_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct isc_device *isc = video_drvdata(file);\n\n\treturn v4l2_s_parm_cap(video_devdata(file), isc->current_subdev->sd, a);\n}\n\nstatic int isc_enum_framesizes(struct file *file, void *fh,\n\t\t\t       struct v4l2_frmsizeenum *fsize)\n{\n\tstruct isc_device *isc = video_drvdata(file);\n\tint ret = -EINVAL;\n\tint i;\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < isc->num_user_formats; i++)\n\t\tif (isc->user_formats[i]->fourcc == fsize->pixel_format)\n\t\t\tret = 0;\n\n\tfor (i = 0; i < isc->controller_formats_size; i++)\n\t\tif (isc->controller_formats[i].fourcc == fsize->pixel_format)\n\t\t\tret = 0;\n\n\tif (ret)\n\t\treturn ret;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\n\tfsize->stepwise.min_width = 16;\n\tfsize->stepwise.max_width = isc->max_width;\n\tfsize->stepwise.min_height = 16;\n\tfsize->stepwise.max_height = isc->max_height;\n\tfsize->stepwise.step_width = 1;\n\tfsize->stepwise.step_height = 1;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops isc_ioctl_ops = {\n\t.vidioc_querycap\t\t= isc_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= isc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= isc_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= isc_s_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= isc_try_fmt_vid_cap,\n\n\t.vidioc_enum_input\t\t= isc_enum_input,\n\t.vidioc_g_input\t\t\t= isc_g_input,\n\t.vidioc_s_input\t\t\t= isc_s_input,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\n\t.vidioc_g_parm\t\t\t= isc_g_parm,\n\t.vidioc_s_parm\t\t\t= isc_s_parm,\n\t.vidioc_enum_framesizes\t\t= isc_enum_framesizes,\n\n\t.vidioc_log_status\t\t= v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nstatic int isc_open(struct file *file)\n{\n\tstruct isc_device *isc = video_drvdata(file);\n\tstruct v4l2_subdev *sd = isc->current_subdev->sd;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&isc->lock))\n\t\treturn -ERESTARTSYS;\n\n\tret = v4l2_fh_open(file);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tif (!v4l2_fh_is_singular_file(file))\n\t\tgoto unlock;\n\n\tret = v4l2_subdev_call(sd, core, s_power, 1);\n\tif (ret < 0 && ret != -ENOIOCTLCMD) {\n\t\tv4l2_fh_release(file);\n\t\tgoto unlock;\n\t}\n\n\tret = isc_set_fmt(isc, &isc->fmt);\n\tif (ret) {\n\t\tv4l2_subdev_call(sd, core, s_power, 0);\n\t\tv4l2_fh_release(file);\n\t}\n\nunlock:\n\tmutex_unlock(&isc->lock);\n\treturn ret;\n}\n\nstatic int isc_release(struct file *file)\n{\n\tstruct isc_device *isc = video_drvdata(file);\n\tstruct v4l2_subdev *sd = isc->current_subdev->sd;\n\tbool fh_singular;\n\tint ret;\n\n\tmutex_lock(&isc->lock);\n\n\tfh_singular = v4l2_fh_is_singular_file(file);\n\n\tret = _vb2_fop_release(file, NULL);\n\n\tif (fh_singular)\n\t\tv4l2_subdev_call(sd, core, s_power, 0);\n\n\tmutex_unlock(&isc->lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_file_operations isc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= isc_open,\n\t.release\t= isc_release,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.read\t\t= vb2_fop_read,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.poll\t\t= vb2_fop_poll,\n};\n\nirqreturn_t atmel_isc_interrupt(int irq, void *dev_id)\n{\n\tstruct isc_device *isc = (struct isc_device *)dev_id;\n\tstruct regmap *regmap = isc->regmap;\n\tu32 isc_intsr, isc_intmask, pending;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tregmap_read(regmap, ISC_INTSR, &isc_intsr);\n\tregmap_read(regmap, ISC_INTMASK, &isc_intmask);\n\n\tpending = isc_intsr & isc_intmask;\n\n\tif (likely(pending & ISC_INT_DDONE)) {\n\t\tspin_lock(&isc->dma_queue_lock);\n\t\tif (isc->cur_frm) {\n\t\t\tstruct vb2_v4l2_buffer *vbuf = &isc->cur_frm->vb;\n\t\t\tstruct vb2_buffer *vb = &vbuf->vb2_buf;\n\n\t\t\tvb->timestamp = ktime_get_ns();\n\t\t\tvbuf->sequence = isc->sequence++;\n\t\t\tvb2_buffer_done(vb, VB2_BUF_STATE_DONE);\n\t\t\tisc->cur_frm = NULL;\n\t\t}\n\n\t\tif (!list_empty(&isc->dma_queue) && !isc->stop) {\n\t\t\tisc->cur_frm = list_first_entry(&isc->dma_queue,\n\t\t\t\t\t\t     struct isc_buffer, list);\n\t\t\tlist_del(&isc->cur_frm->list);\n\n\t\t\tisc_start_dma(isc);\n\t\t}\n\n\t\tif (isc->stop)\n\t\t\tcomplete(&isc->comp);\n\n\t\tret = IRQ_HANDLED;\n\t\tspin_unlock(&isc->dma_queue_lock);\n\t}\n\n\tif (pending & ISC_INT_HISDONE) {\n\t\tschedule_work(&isc->awb_work);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(atmel_isc_interrupt);\n\nstatic void isc_hist_count(struct isc_device *isc, u32 *min, u32 *max)\n{\n\tstruct regmap *regmap = isc->regmap;\n\tstruct isc_ctrls *ctrls = &isc->ctrls;\n\tu32 *hist_count = &ctrls->hist_count[ctrls->hist_id];\n\tu32 *hist_entry = &ctrls->hist_entry[0];\n\tu32 i;\n\n\t*min = 0;\n\t*max = HIST_ENTRIES;\n\n\tregmap_bulk_read(regmap, ISC_HIS_ENTRY + isc->offsets.his_entry,\n\t\t\t hist_entry, HIST_ENTRIES);\n\n\t*hist_count = 0;\n\t \n\tfor (i = 1; i < HIST_ENTRIES; i++) {\n\t\tif (*hist_entry && !*min)\n\t\t\t*min = i;\n\t\tif (*hist_entry)\n\t\t\t*max = i;\n\t\t*hist_count += i * (*hist_entry++);\n\t}\n\n\tif (!*min)\n\t\t*min = 1;\n\n\tv4l2_dbg(1, debug, &isc->v4l2_dev,\n\t\t \"isc wb: hist_id %u, hist_count %u\",\n\t\t ctrls->hist_id, *hist_count);\n}\n\nstatic void isc_wb_update(struct isc_ctrls *ctrls)\n{\n\tstruct isc_device *isc = container_of(ctrls, struct isc_device, ctrls);\n\tu32 *hist_count = &ctrls->hist_count[0];\n\tu32 c, offset[4];\n\tu64 avg = 0;\n\t \n\tu32 s_gain[4], gw_gain[4];\n\n\t \n\tavg = (u64)hist_count[ISC_HIS_CFG_MODE_GR] +\n\t\t(u64)hist_count[ISC_HIS_CFG_MODE_GB];\n\tavg >>= 1;\n\n\tv4l2_dbg(1, debug, &isc->v4l2_dev,\n\t\t \"isc wb: green components average %llu\\n\", avg);\n\n\t \n\tif (!avg)\n\t\treturn;\n\n\tfor (c = ISC_HIS_CFG_MODE_GR; c <= ISC_HIS_CFG_MODE_B; c++) {\n\t\t \n\t\toffset[c] = ctrls->hist_minmax[c][HIST_MIN_INDEX];\n\t\t \n\t\tctrls->offset[c] = (offset[c] - 1) << 3;\n\n\t\t \n\t\tctrls->offset[c] = -ctrls->offset[c];\n\n\t\t \n\t\ts_gain[c] = (HIST_ENTRIES << 9) /\n\t\t\t(ctrls->hist_minmax[c][HIST_MAX_INDEX] -\n\t\t\tctrls->hist_minmax[c][HIST_MIN_INDEX] + 1);\n\n\t\t \n\t\tif (hist_count[c])\n\t\t\tgw_gain[c] = div_u64(avg << 9, hist_count[c]);\n\t\telse\n\t\t\tgw_gain[c] = 1 << 9;\n\n\t\tv4l2_dbg(1, debug, &isc->v4l2_dev,\n\t\t\t \"isc wb: component %d, s_gain %u, gw_gain %u\\n\",\n\t\t\t c, s_gain[c], gw_gain[c]);\n\t\t \n\t\tctrls->gain[c] = s_gain[c] * gw_gain[c];\n\t\tctrls->gain[c] >>= 9;\n\n\t\t \n\t\tctrls->gain[c] = clamp_val(ctrls->gain[c], 0, GENMASK(12, 0));\n\n\t\tv4l2_dbg(1, debug, &isc->v4l2_dev,\n\t\t\t \"isc wb: component %d, final gain %u\\n\",\n\t\t\t c, ctrls->gain[c]);\n\t}\n}\n\nstatic void isc_awb_work(struct work_struct *w)\n{\n\tstruct isc_device *isc =\n\t\tcontainer_of(w, struct isc_device, awb_work);\n\tstruct regmap *regmap = isc->regmap;\n\tstruct isc_ctrls *ctrls = &isc->ctrls;\n\tu32 hist_id = ctrls->hist_id;\n\tu32 baysel;\n\tunsigned long flags;\n\tu32 min, max;\n\tint ret;\n\n\tif (ctrls->hist_stat != HIST_ENABLED)\n\t\treturn;\n\n\tisc_hist_count(isc, &min, &max);\n\n\tv4l2_dbg(1, debug, &isc->v4l2_dev,\n\t\t \"isc wb mode %d: hist min %u , max %u\\n\", hist_id, min, max);\n\n\tctrls->hist_minmax[hist_id][HIST_MIN_INDEX] = min;\n\tctrls->hist_minmax[hist_id][HIST_MAX_INDEX] = max;\n\n\tif (hist_id != ISC_HIS_CFG_MODE_B) {\n\t\thist_id++;\n\t} else {\n\t\tisc_wb_update(ctrls);\n\t\thist_id = ISC_HIS_CFG_MODE_GR;\n\t}\n\n\tctrls->hist_id = hist_id;\n\tbaysel = isc->config.sd_format->cfa_baycfg << ISC_HIS_CFG_BAYSEL_SHIFT;\n\n\tret = pm_runtime_resume_and_get(isc->dev);\n\tif (ret < 0)\n\t\treturn;\n\n\t \n\tif (hist_id == ISC_HIS_CFG_MODE_GR || ctrls->awb == ISC_WB_NONE) {\n\t\t \n\t\tspin_lock_irqsave(&isc->awb_lock, flags);\n\t\tisc_update_awb_ctrls(isc);\n\t\tspin_unlock_irqrestore(&isc->awb_lock, flags);\n\n\t\t \n\t\tif (ctrls->awb == ISC_WB_ONETIME) {\n\t\t\tv4l2_info(&isc->v4l2_dev,\n\t\t\t\t  \"Completed one time white-balance adjustment.\\n\");\n\t\t\t \n\t\t\tisc_update_v4l2_ctrls(isc);\n\t\t\tctrls->awb = ISC_WB_NONE;\n\t\t}\n\t}\n\tregmap_write(regmap, ISC_HIS_CFG + isc->offsets.his,\n\t\t     hist_id | baysel | ISC_HIS_CFG_RAR);\n\n\t \n\tmutex_lock(&isc->awb_mutex);\n\n\t \n\tif (isc->stop) {\n\t\tmutex_unlock(&isc->awb_mutex);\n\t\treturn;\n\t}\n\n\tisc_update_profile(isc);\n\n\tmutex_unlock(&isc->awb_mutex);\n\n\t \n\tif (ctrls->awb)\n\t\tregmap_write(regmap, ISC_CTRLEN, ISC_CTRL_HISREQ);\n\n\tpm_runtime_put_sync(isc->dev);\n}\n\nstatic int isc_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct isc_device *isc = container_of(ctrl->handler,\n\t\t\t\t\t     struct isc_device, ctrls.handler);\n\tstruct isc_ctrls *ctrls = &isc->ctrls;\n\n\tif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tctrls->brightness = ctrl->val & ISC_CBC_BRIGHT_MASK;\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tctrls->contrast = ctrl->val & ISC_CBC_CONTRAST_MASK;\n\t\tbreak;\n\tcase V4L2_CID_GAMMA:\n\t\tctrls->gamma_index = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops isc_ctrl_ops = {\n\t.s_ctrl\t= isc_s_ctrl,\n};\n\nstatic int isc_s_awb_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct isc_device *isc = container_of(ctrl->handler,\n\t\t\t\t\t     struct isc_device, ctrls.handler);\n\tstruct isc_ctrls *ctrls = &isc->ctrls;\n\n\tif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tif (ctrl->val == 1)\n\t\t\tctrls->awb = ISC_WB_AUTO;\n\t\telse\n\t\t\tctrls->awb = ISC_WB_NONE;\n\n\t\t \n\t\tif (ctrl->cluster[ISC_CTRL_R_GAIN]->is_new)\n\t\t\tctrls->gain[ISC_HIS_CFG_MODE_R] = isc->r_gain_ctrl->val;\n\t\tif (ctrl->cluster[ISC_CTRL_B_GAIN]->is_new)\n\t\t\tctrls->gain[ISC_HIS_CFG_MODE_B] = isc->b_gain_ctrl->val;\n\t\tif (ctrl->cluster[ISC_CTRL_GR_GAIN]->is_new)\n\t\t\tctrls->gain[ISC_HIS_CFG_MODE_GR] = isc->gr_gain_ctrl->val;\n\t\tif (ctrl->cluster[ISC_CTRL_GB_GAIN]->is_new)\n\t\t\tctrls->gain[ISC_HIS_CFG_MODE_GB] = isc->gb_gain_ctrl->val;\n\n\t\tif (ctrl->cluster[ISC_CTRL_R_OFF]->is_new)\n\t\t\tctrls->offset[ISC_HIS_CFG_MODE_R] = isc->r_off_ctrl->val;\n\t\tif (ctrl->cluster[ISC_CTRL_B_OFF]->is_new)\n\t\t\tctrls->offset[ISC_HIS_CFG_MODE_B] = isc->b_off_ctrl->val;\n\t\tif (ctrl->cluster[ISC_CTRL_GR_OFF]->is_new)\n\t\t\tctrls->offset[ISC_HIS_CFG_MODE_GR] = isc->gr_off_ctrl->val;\n\t\tif (ctrl->cluster[ISC_CTRL_GB_OFF]->is_new)\n\t\t\tctrls->offset[ISC_HIS_CFG_MODE_GB] = isc->gb_off_ctrl->val;\n\n\t\tisc_update_awb_ctrls(isc);\n\n\t\tmutex_lock(&isc->awb_mutex);\n\t\tif (vb2_is_streaming(&isc->vb2_vidq)) {\n\t\t\t \n\t\t\tisc_update_profile(isc);\n\t\t} else {\n\t\t\t \n\t\t\tv4l2_ctrl_activate(isc->do_wb_ctrl, false);\n\t\t}\n\t\tmutex_unlock(&isc->awb_mutex);\n\n\t\t \n\t\tif (ctrls->awb == ISC_WB_AUTO &&\n\t\t    vb2_is_streaming(&isc->vb2_vidq) &&\n\t\t    ISC_IS_FORMAT_RAW(isc->config.sd_format->mbus_code))\n\t\t\tisc_set_histogram(isc, true);\n\n\t\t \n\t\tif (ctrls->awb == ISC_WB_NONE &&\n\t\t    ctrl->cluster[ISC_CTRL_DO_WB]->is_new &&\n\t\t    !(ctrl->cluster[ISC_CTRL_DO_WB]->flags &\n\t\t    V4L2_CTRL_FLAG_INACTIVE)) {\n\t\t\tctrls->awb = ISC_WB_ONETIME;\n\t\t\tisc_set_histogram(isc, true);\n\t\t\tv4l2_dbg(1, debug, &isc->v4l2_dev,\n\t\t\t\t \"One time white-balance started.\\n\");\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int isc_g_volatile_awb_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct isc_device *isc = container_of(ctrl->handler,\n\t\t\t\t\t     struct isc_device, ctrls.handler);\n\tstruct isc_ctrls *ctrls = &isc->ctrls;\n\n\tswitch (ctrl->id) {\n\t \n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tctrl->cluster[ISC_CTRL_R_GAIN]->val =\n\t\t\t\t\tctrls->gain[ISC_HIS_CFG_MODE_R];\n\t\tctrl->cluster[ISC_CTRL_B_GAIN]->val =\n\t\t\t\t\tctrls->gain[ISC_HIS_CFG_MODE_B];\n\t\tctrl->cluster[ISC_CTRL_GR_GAIN]->val =\n\t\t\t\t\tctrls->gain[ISC_HIS_CFG_MODE_GR];\n\t\tctrl->cluster[ISC_CTRL_GB_GAIN]->val =\n\t\t\t\t\tctrls->gain[ISC_HIS_CFG_MODE_GB];\n\n\t\tctrl->cluster[ISC_CTRL_R_OFF]->val =\n\t\t\tctrls->offset[ISC_HIS_CFG_MODE_R];\n\t\tctrl->cluster[ISC_CTRL_B_OFF]->val =\n\t\t\tctrls->offset[ISC_HIS_CFG_MODE_B];\n\t\tctrl->cluster[ISC_CTRL_GR_OFF]->val =\n\t\t\tctrls->offset[ISC_HIS_CFG_MODE_GR];\n\t\tctrl->cluster[ISC_CTRL_GB_OFF]->val =\n\t\t\tctrls->offset[ISC_HIS_CFG_MODE_GB];\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops isc_awb_ops = {\n\t.s_ctrl = isc_s_awb_ctrl,\n\t.g_volatile_ctrl = isc_g_volatile_awb_ctrl,\n};\n\n#define ISC_CTRL_OFF(_name, _id, _name_str) \\\n\tstatic const struct v4l2_ctrl_config _name = { \\\n\t\t.ops = &isc_awb_ops, \\\n\t\t.id = _id, \\\n\t\t.name = _name_str, \\\n\t\t.type = V4L2_CTRL_TYPE_INTEGER, \\\n\t\t.flags = V4L2_CTRL_FLAG_SLIDER, \\\n\t\t.min = -4095, \\\n\t\t.max = 4095, \\\n\t\t.step = 1, \\\n\t\t.def = 0, \\\n\t}\n\nISC_CTRL_OFF(isc_r_off_ctrl, ISC_CID_R_OFFSET, \"Red Component Offset\");\nISC_CTRL_OFF(isc_b_off_ctrl, ISC_CID_B_OFFSET, \"Blue Component Offset\");\nISC_CTRL_OFF(isc_gr_off_ctrl, ISC_CID_GR_OFFSET, \"Green Red Component Offset\");\nISC_CTRL_OFF(isc_gb_off_ctrl, ISC_CID_GB_OFFSET, \"Green Blue Component Offset\");\n\n#define ISC_CTRL_GAIN(_name, _id, _name_str) \\\n\tstatic const struct v4l2_ctrl_config _name = { \\\n\t\t.ops = &isc_awb_ops, \\\n\t\t.id = _id, \\\n\t\t.name = _name_str, \\\n\t\t.type = V4L2_CTRL_TYPE_INTEGER, \\\n\t\t.flags = V4L2_CTRL_FLAG_SLIDER, \\\n\t\t.min = 0, \\\n\t\t.max = 8191, \\\n\t\t.step = 1, \\\n\t\t.def = 512, \\\n\t}\n\nISC_CTRL_GAIN(isc_r_gain_ctrl, ISC_CID_R_GAIN, \"Red Component Gain\");\nISC_CTRL_GAIN(isc_b_gain_ctrl, ISC_CID_B_GAIN, \"Blue Component Gain\");\nISC_CTRL_GAIN(isc_gr_gain_ctrl, ISC_CID_GR_GAIN, \"Green Red Component Gain\");\nISC_CTRL_GAIN(isc_gb_gain_ctrl, ISC_CID_GB_GAIN, \"Green Blue Component Gain\");\n\nstatic int isc_ctrl_init(struct isc_device *isc)\n{\n\tconst struct v4l2_ctrl_ops *ops = &isc_ctrl_ops;\n\tstruct isc_ctrls *ctrls = &isc->ctrls;\n\tstruct v4l2_ctrl_handler *hdl = &ctrls->handler;\n\tint ret;\n\n\tctrls->hist_stat = HIST_INIT;\n\tisc_reset_awb_ctrls(isc);\n\n\tret = v4l2_ctrl_handler_init(hdl, 13);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tisc->config_ctrls(isc, ops);\n\n\tctrls->brightness = 0;\n\n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_BRIGHTNESS, -1024, 1023, 1, 0);\n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAMMA, 0, isc->gamma_max, 1,\n\t\t\t  isc->gamma_max);\n\tisc->awb_ctrl = v4l2_ctrl_new_std(hdl, &isc_awb_ops,\n\t\t\t\t\t  V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t\t\t\t  0, 1, 1, 1);\n\n\t \n\tisc->do_wb_ctrl = v4l2_ctrl_new_std(hdl, &isc_awb_ops,\n\t\t\t\t\t    V4L2_CID_DO_WHITE_BALANCE,\n\t\t\t\t\t    0, 0, 0, 0);\n\n\tif (!isc->do_wb_ctrl) {\n\t\tret = hdl->error;\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\treturn ret;\n\t}\n\n\tv4l2_ctrl_activate(isc->do_wb_ctrl, false);\n\n\tisc->r_gain_ctrl = v4l2_ctrl_new_custom(hdl, &isc_r_gain_ctrl, NULL);\n\tisc->b_gain_ctrl = v4l2_ctrl_new_custom(hdl, &isc_b_gain_ctrl, NULL);\n\tisc->gr_gain_ctrl = v4l2_ctrl_new_custom(hdl, &isc_gr_gain_ctrl, NULL);\n\tisc->gb_gain_ctrl = v4l2_ctrl_new_custom(hdl, &isc_gb_gain_ctrl, NULL);\n\tisc->r_off_ctrl = v4l2_ctrl_new_custom(hdl, &isc_r_off_ctrl, NULL);\n\tisc->b_off_ctrl = v4l2_ctrl_new_custom(hdl, &isc_b_off_ctrl, NULL);\n\tisc->gr_off_ctrl = v4l2_ctrl_new_custom(hdl, &isc_gr_off_ctrl, NULL);\n\tisc->gb_off_ctrl = v4l2_ctrl_new_custom(hdl, &isc_gb_off_ctrl, NULL);\n\n\t \n\tv4l2_ctrl_auto_cluster(10, &isc->awb_ctrl, 0, true);\n\n\tv4l2_ctrl_handler_setup(hdl);\n\n\treturn 0;\n}\n\nstatic int isc_async_bound(struct v4l2_async_notifier *notifier,\n\t\t\t    struct v4l2_subdev *subdev,\n\t\t\t    struct v4l2_async_connection *asd)\n{\n\tstruct isc_device *isc = container_of(notifier->v4l2_dev,\n\t\t\t\t\t      struct isc_device, v4l2_dev);\n\tstruct isc_subdev_entity *subdev_entity =\n\t\tcontainer_of(notifier, struct isc_subdev_entity, notifier);\n\n\tif (video_is_registered(&isc->video_dev)) {\n\t\tv4l2_err(&isc->v4l2_dev, \"only supports one sub-device.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tsubdev_entity->sd = subdev;\n\n\treturn 0;\n}\n\nstatic void isc_async_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t      struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_async_connection *asd)\n{\n\tstruct isc_device *isc = container_of(notifier->v4l2_dev,\n\t\t\t\t\t      struct isc_device, v4l2_dev);\n\tmutex_destroy(&isc->awb_mutex);\n\tcancel_work_sync(&isc->awb_work);\n\tvideo_unregister_device(&isc->video_dev);\n\tv4l2_ctrl_handler_free(&isc->ctrls.handler);\n}\n\nstatic struct isc_format *find_format_by_code(struct isc_device *isc,\n\t\t\t\t\t      unsigned int code, int *index)\n{\n\tstruct isc_format *fmt = &isc->formats_list[0];\n\tunsigned int i;\n\n\tfor (i = 0; i < isc->formats_list_size; i++) {\n\t\tif (fmt->mbus_code == code) {\n\t\t\t*index = i;\n\t\t\treturn fmt;\n\t\t}\n\n\t\tfmt++;\n\t}\n\n\treturn NULL;\n}\n\nstatic int isc_formats_init(struct isc_device *isc)\n{\n\tstruct isc_format *fmt;\n\tstruct v4l2_subdev *subdev = isc->current_subdev->sd;\n\tunsigned int num_fmts, i, j;\n\tu32 list_size = isc->formats_list_size;\n\tstruct v4l2_subdev_mbus_code_enum mbus_code = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\tnum_fmts = 0;\n\twhile (!v4l2_subdev_call(subdev, pad, enum_mbus_code,\n\t       NULL, &mbus_code)) {\n\t\tmbus_code.index++;\n\n\t\tfmt = find_format_by_code(isc, mbus_code.code, &i);\n\t\tif (!fmt) {\n\t\t\tv4l2_warn(&isc->v4l2_dev, \"Mbus code %x not supported\\n\",\n\t\t\t\t  mbus_code.code);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfmt->sd_support = true;\n\t\tnum_fmts++;\n\t}\n\n\tif (!num_fmts)\n\t\treturn -ENXIO;\n\n\tisc->num_user_formats = num_fmts;\n\tisc->user_formats = devm_kcalloc(isc->dev,\n\t\t\t\t\t num_fmts, sizeof(*isc->user_formats),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!isc->user_formats)\n\t\treturn -ENOMEM;\n\n\tfmt = &isc->formats_list[0];\n\tfor (i = 0, j = 0; i < list_size; i++) {\n\t\tif (fmt->sd_support)\n\t\t\tisc->user_formats[j++] = fmt;\n\t\tfmt++;\n\t}\n\n\treturn 0;\n}\n\nstatic int isc_set_default_fmt(struct isc_device *isc)\n{\n\tstruct v4l2_format f = {\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\n\t\t.fmt.pix = {\n\t\t\t.width\t\t= VGA_WIDTH,\n\t\t\t.height\t\t= VGA_HEIGHT,\n\t\t\t.field\t\t= V4L2_FIELD_NONE,\n\t\t\t.pixelformat\t= isc->user_formats[0]->fourcc,\n\t\t},\n\t};\n\tint ret;\n\n\tret = isc_try_fmt(isc, &f, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tisc->fmt = f;\n\treturn 0;\n}\n\nstatic int isc_async_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct isc_device *isc = container_of(notifier->v4l2_dev,\n\t\t\t\t\t      struct isc_device, v4l2_dev);\n\tstruct video_device *vdev = &isc->video_dev;\n\tstruct vb2_queue *q = &isc->vb2_vidq;\n\tint ret = 0;\n\n\tINIT_WORK(&isc->awb_work, isc_awb_work);\n\n\tret = v4l2_device_register_subdev_nodes(&isc->v4l2_dev);\n\tif (ret < 0) {\n\t\tv4l2_err(&isc->v4l2_dev, \"Failed to register subdev nodes\\n\");\n\t\treturn ret;\n\t}\n\n\tisc->current_subdev = container_of(notifier,\n\t\t\t\t\t   struct isc_subdev_entity, notifier);\n\tmutex_init(&isc->lock);\n\tmutex_init(&isc->awb_mutex);\n\n\tinit_completion(&isc->comp);\n\n\t \n\tq->type\t\t\t= V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes\t\t= VB2_MMAP | VB2_DMABUF | VB2_READ;\n\tq->drv_priv\t\t= isc;\n\tq->buf_struct_size\t= sizeof(struct isc_buffer);\n\tq->ops\t\t\t= &isc_vb2_ops;\n\tq->mem_ops\t\t= &vb2_dma_contig_memops;\n\tq->timestamp_flags\t= V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock\t\t\t= &isc->lock;\n\tq->min_buffers_needed\t= 1;\n\tq->dev\t\t\t= isc->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret < 0) {\n\t\tv4l2_err(&isc->v4l2_dev,\n\t\t\t \"vb2_queue_init() failed: %d\\n\", ret);\n\t\tgoto isc_async_complete_err;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&isc->dma_queue);\n\tspin_lock_init(&isc->dma_queue_lock);\n\tspin_lock_init(&isc->awb_lock);\n\n\tret = isc_formats_init(isc);\n\tif (ret < 0) {\n\t\tv4l2_err(&isc->v4l2_dev,\n\t\t\t \"Init format failed: %d\\n\", ret);\n\t\tgoto isc_async_complete_err;\n\t}\n\n\tret = isc_set_default_fmt(isc);\n\tif (ret) {\n\t\tv4l2_err(&isc->v4l2_dev, \"Could not set default format\\n\");\n\t\tgoto isc_async_complete_err;\n\t}\n\n\tret = isc_ctrl_init(isc);\n\tif (ret) {\n\t\tv4l2_err(&isc->v4l2_dev, \"Init isc ctrols failed: %d\\n\", ret);\n\t\tgoto isc_async_complete_err;\n\t}\n\n\t \n\tstrscpy(vdev->name, KBUILD_MODNAME, sizeof(vdev->name));\n\tvdev->release\t\t= video_device_release_empty;\n\tvdev->fops\t\t= &isc_fops;\n\tvdev->ioctl_ops\t\t= &isc_ioctl_ops;\n\tvdev->v4l2_dev\t\t= &isc->v4l2_dev;\n\tvdev->vfl_dir\t\t= VFL_DIR_RX;\n\tvdev->queue\t\t= q;\n\tvdev->lock\t\t= &isc->lock;\n\tvdev->ctrl_handler\t= &isc->ctrls.handler;\n\tvdev->device_caps\t= V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_CAPTURE;\n\tvideo_set_drvdata(vdev, isc);\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0) {\n\t\tv4l2_err(&isc->v4l2_dev,\n\t\t\t \"video_register_device failed: %d\\n\", ret);\n\t\tgoto isc_async_complete_err;\n\t}\n\n\treturn 0;\n\nisc_async_complete_err:\n\tmutex_destroy(&isc->awb_mutex);\n\tmutex_destroy(&isc->lock);\n\treturn ret;\n}\n\nconst struct v4l2_async_notifier_operations atmel_isc_async_ops = {\n\t.bound = isc_async_bound,\n\t.unbind = isc_async_unbind,\n\t.complete = isc_async_complete,\n};\nEXPORT_SYMBOL_GPL(atmel_isc_async_ops);\n\nvoid atmel_isc_subdev_cleanup(struct isc_device *isc)\n{\n\tstruct isc_subdev_entity *subdev_entity;\n\n\tlist_for_each_entry(subdev_entity, &isc->subdev_entities, list) {\n\t\tv4l2_async_nf_unregister(&subdev_entity->notifier);\n\t\tv4l2_async_nf_cleanup(&subdev_entity->notifier);\n\t}\n\n\tINIT_LIST_HEAD(&isc->subdev_entities);\n}\nEXPORT_SYMBOL_GPL(atmel_isc_subdev_cleanup);\n\nint atmel_isc_pipeline_init(struct isc_device *isc)\n{\n\tstruct device *dev = isc->dev;\n\tstruct regmap *regmap = isc->regmap;\n\tstruct regmap_field *regs;\n\tunsigned int i;\n\n\t \n\tconst struct reg_field regfields[ISC_PIPE_LINE_NODE_NUM] = {\n\t\tREG_FIELD(ISC_DPC_CTRL, 0, 0),\n\t\tREG_FIELD(ISC_DPC_CTRL, 1, 1),\n\t\tREG_FIELD(ISC_DPC_CTRL, 2, 2),\n\t\tREG_FIELD(ISC_WB_CTRL, 0, 0),\n\t\tREG_FIELD(ISC_CFA_CTRL, 0, 0),\n\t\tREG_FIELD(ISC_CC_CTRL, 0, 0),\n\t\tREG_FIELD(ISC_GAM_CTRL, 0, 0),\n\t\tREG_FIELD(ISC_GAM_CTRL, 1, 1),\n\t\tREG_FIELD(ISC_GAM_CTRL, 2, 2),\n\t\tREG_FIELD(ISC_GAM_CTRL, 3, 3),\n\t\tREG_FIELD(ISC_VHXS_CTRL, 0, 0),\n\t\tREG_FIELD(ISC_CSC_CTRL + isc->offsets.csc, 0, 0),\n\t\tREG_FIELD(ISC_CBC_CTRL + isc->offsets.cbc, 0, 0),\n\t\tREG_FIELD(ISC_SUB422_CTRL + isc->offsets.sub422, 0, 0),\n\t\tREG_FIELD(ISC_SUB420_CTRL + isc->offsets.sub420, 0, 0),\n\t};\n\n\tfor (i = 0; i < ISC_PIPE_LINE_NODE_NUM; i++) {\n\t\tregs = devm_regmap_field_alloc(dev, regmap, regfields[i]);\n\t\tif (IS_ERR(regs))\n\t\t\treturn PTR_ERR(regs);\n\n\t\tisc->pipeline[i] =  regs;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(atmel_isc_pipeline_init);\n\n \n#define ATMEL_ISC_REG_MAX    0xd5c\nconst struct regmap_config atmel_isc_regmap_config = {\n\t.reg_bits       = 32,\n\t.reg_stride     = 4,\n\t.val_bits       = 32,\n\t.max_register\t= ATMEL_ISC_REG_MAX,\n};\nEXPORT_SYMBOL_GPL(atmel_isc_regmap_config);\n\nMODULE_AUTHOR(\"Songjun Wu\");\nMODULE_AUTHOR(\"Eugen Hristev\");\nMODULE_DESCRIPTION(\"Atmel ISC common code base\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}