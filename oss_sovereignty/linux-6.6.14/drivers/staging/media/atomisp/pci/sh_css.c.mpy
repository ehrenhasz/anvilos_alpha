{
  "module_name": "sh_css.c",
  "hash_id": "8d3f6fc3402627ca1a530cace613c7934c73b3da8ad47e6e8230e78ca463761b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/sh_css.c",
  "human_readable_source": "\n \n\n \n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\n#include \"hmm.h\"\n\n#include \"atomisp_internal.h\"\n\n#include \"ia_css.h\"\n#include \"sh_css_hrt.h\"\t\t \n#include \"ia_css_buffer.h\"\n#include \"ia_css_binary.h\"\n#include \"sh_css_internal.h\"\n#include \"sh_css_mipi.h\"\n#include \"sh_css_sp.h\"\t\t \n#include \"ia_css_isys.h\"\n#include \"ia_css_frame.h\"\n#include \"sh_css_defs.h\"\n#include \"sh_css_firmware.h\"\n#include \"sh_css_params.h\"\n#include \"sh_css_params_internal.h\"\n#include \"sh_css_param_shading.h\"\n#include \"ia_css_refcount.h\"\n#include \"ia_css_rmgr.h\"\n#include \"ia_css_debug.h\"\n#include \"ia_css_debug_pipe.h\"\n#include \"ia_css_device_access.h\"\n#include \"device_access.h\"\n#include \"sh_css_legacy.h\"\n#include \"ia_css_pipeline.h\"\n#include \"ia_css_stream.h\"\n#include \"sh_css_stream_format.h\"\n#include \"ia_css_pipe.h\"\n#include \"ia_css_util.h\"\n#include \"ia_css_pipe_util.h\"\n#include \"ia_css_pipe_binarydesc.h\"\n#include \"ia_css_pipe_stagedesc.h\"\n\n#include \"tag.h\"\n#include \"assert_support.h\"\n#include \"math_support.h\"\n#include \"sw_event_global.h\"\t\t\t \n#if !defined(ISP2401)\n#include \"ia_css_ifmtr.h\"\n#endif\n#include \"input_system.h\"\n#include \"mmu_device.h\"\t\t \n#include \"ia_css_mmu_private.h\"  \n#include \"gdc_device.h\"\t\t \n#include \"dma.h\"\t\t \n#include \"irq.h\"\t\t \n#include \"sp.h\"\t\t\t \n#include \"isp.h\"\t\t \n#include \"gp_device.h\"\t\t \n#define __INLINE_GPIO__\n#include \"gpio.h\"\n#include \"timed_ctrl.h\"\n#include \"ia_css_inputfifo.h\"\n#define WITH_PC_MONITORING  0\n\n#define SH_CSS_VIDEO_BUFFER_ALIGNMENT 0\n\n\n#include \"ia_css_spctrl.h\"\n#include \"ia_css_version_data.h\"\n#include \"sh_css_struct.h\"\n#include \"ia_css_bufq.h\"\n#include \"ia_css_timer.h\"  \n\n#include \"isp/modes/interface/input_buf.isp.h\"\n\n \n#define SP_PROG_NAME \"sp\"\n \n#define REFCOUNT_SIZE 1000\n\n \n#define JPEG_BYTES (16 * 1024 * 1024)\n\nstruct sh_css my_css;\n\nint  __printf(1, 0) (*sh_css_printf)(const char *fmt, va_list args) = NULL;\n\n \nenum ia_sh_css_modes {\n\tsh_css_mode_none = 0,\n\tsh_css_mode_working,\n\tsh_css_mode_suspend,\n\tsh_css_mode_resume\n};\n\n \nstruct sh_css_stream_seed {\n\tstruct ia_css_stream\t\t**orig_stream;\n\tstruct ia_css_stream\t\t*stream;\n\tstruct ia_css_stream_config\tstream_config;\n\tint\t\t\t\tnum_pipes;\n\tstruct ia_css_pipe\t\t*pipes[IA_CSS_PIPE_ID_NUM];\n\tstruct ia_css_pipe\t\t**orig_pipes[IA_CSS_PIPE_ID_NUM];\n\tstruct ia_css_pipe_config\tpipe_config[IA_CSS_PIPE_ID_NUM];\n};\n\n#define MAX_ACTIVE_STREAMS\t5\n \nstruct sh_css_save {\n\tenum ia_sh_css_modes\t\tmode;\n\tu32\t\t       mmu_base;\t\t \n\tenum ia_css_irq_type           irq_type;\n\tstruct sh_css_stream_seed      stream_seeds[MAX_ACTIVE_STREAMS];\n\tstruct ia_css_fw\t       *loaded_fw;\t \n\tstruct ia_css_env\t       driver_env;\t \n};\n\nstatic bool my_css_save_initialized;\t \nstatic struct sh_css_save my_css_save;\n\n \n\n \n#define MAX_HMM_BUFFER_NUM\t\\\n\t(SH_CSS_MAX_NUM_QUEUES * (IA_CSS_NUM_ELEMS_SP2HOST_BUFFER_QUEUE + 2))\n\nstruct sh_css_hmm_buffer_record {\n\tbool in_use;\n\tenum ia_css_buffer_type type;\n\tstruct ia_css_rmgr_vbuf_handle *h_vbuf;\n\thrt_address kernel_ptr;\n};\n\nstatic struct sh_css_hmm_buffer_record hmm_buffer_record[MAX_HMM_BUFFER_NUM];\n\n#define GPIO_FLASH_PIN_MASK BIT(HIVE_GPIO_STROBE_TRIGGER_PIN)\n\nstatic bool fw_explicitly_loaded;\n\n \n\nstatic int\nallocate_delay_frames(struct ia_css_pipe *pipe);\n\nstatic int\nsh_css_pipe_start(struct ia_css_stream *stream);\n\n \n\n \nstatic int\nia_css_pipe_check_format(struct ia_css_pipe *pipe,\n\t\t\t enum ia_css_frame_format format);\n\n \nstatic void\nia_css_reset_defaults(struct sh_css *css);\n\nstatic void\nsh_css_init_host_sp_control_vars(void);\n\nstatic int\nset_num_primary_stages(unsigned int *num, enum ia_css_pipe_version version);\n\nstatic bool\nneed_capture_pp(const struct ia_css_pipe *pipe);\n\nstatic bool\nneed_yuv_scaler_stage(const struct ia_css_pipe *pipe);\n\nstatic int ia_css_pipe_create_cas_scaler_desc_single_output(\n    struct ia_css_frame_info *cas_scaler_in_info,\n    struct ia_css_frame_info *cas_scaler_out_info,\n    struct ia_css_frame_info *cas_scaler_vf_info,\n    struct ia_css_cas_binary_descr *descr);\n\nstatic void ia_css_pipe_destroy_cas_scaler_desc(struct ia_css_cas_binary_descr\n\t*descr);\n\nstatic bool\nneed_downscaling(const struct ia_css_resolution in_res,\n\t\t const struct ia_css_resolution out_res);\n\nstatic bool need_capt_ldc(const struct ia_css_pipe *pipe);\n\nstatic int\nsh_css_pipe_load_binaries(struct ia_css_pipe *pipe);\n\nstatic\nint sh_css_pipe_get_viewfinder_frame_info(\n    struct ia_css_pipe *pipe,\n    struct ia_css_frame_info *info,\n    unsigned int idx);\n\nstatic int\nsh_css_pipe_get_output_frame_info(struct ia_css_pipe *pipe,\n\t\t\t\t  struct ia_css_frame_info *info,\n\t\t\t\t  unsigned int idx);\n\nstatic int\ncapture_start(struct ia_css_pipe *pipe);\n\nstatic int\nvideo_start(struct ia_css_pipe *pipe);\n\nstatic int\npreview_start(struct ia_css_pipe *pipe);\n\nstatic int\nyuvpp_start(struct ia_css_pipe *pipe);\n\nstatic bool copy_on_sp(struct ia_css_pipe *pipe);\n\nstatic int\ninit_vf_frameinfo_defaults(struct ia_css_pipe *pipe,\n\t\t\t   struct ia_css_frame *vf_frame, unsigned int idx);\n\nstatic int\ninit_in_frameinfo_memory_defaults(struct ia_css_pipe *pipe,\n\t\t\t\t  struct ia_css_frame *frame, enum ia_css_frame_format format);\n\nstatic int\ninit_out_frameinfo_defaults(struct ia_css_pipe *pipe,\n\t\t\t    struct ia_css_frame *out_frame, unsigned int idx);\n\nstatic int\nalloc_continuous_frames(struct ia_css_pipe *pipe, bool init_time);\n\nstatic void\npipe_global_init(void);\n\nstatic int\npipe_generate_pipe_num(const struct ia_css_pipe *pipe,\n\t\t       unsigned int *pipe_number);\n\nstatic void\npipe_release_pipe_num(unsigned int pipe_num);\n\nstatic int\ncreate_host_pipeline_structure(struct ia_css_stream *stream);\n\nstatic int\ncreate_host_pipeline(struct ia_css_stream *stream);\n\nstatic int\ncreate_host_preview_pipeline(struct ia_css_pipe *pipe);\n\nstatic int\ncreate_host_video_pipeline(struct ia_css_pipe *pipe);\n\nstatic int\ncreate_host_copy_pipeline(struct ia_css_pipe *pipe,\n\t\t\t  unsigned int max_input_width,\n\t\t\t  struct ia_css_frame *out_frame);\n\nstatic int\ncreate_host_isyscopy_capture_pipeline(struct ia_css_pipe *pipe);\n\nstatic int\ncreate_host_capture_pipeline(struct ia_css_pipe *pipe);\n\nstatic int\ncreate_host_yuvpp_pipeline(struct ia_css_pipe *pipe);\n\nstatic unsigned int\nsh_css_get_sw_interrupt_value(unsigned int irq);\n\nstatic struct ia_css_binary *ia_css_pipe_get_shading_correction_binary(\n    const struct ia_css_pipe *pipe);\n\nstatic struct ia_css_binary *\nia_css_pipe_get_s3a_binary(const struct ia_css_pipe *pipe);\n\nstatic struct ia_css_binary *\nia_css_pipe_get_sdis_binary(const struct ia_css_pipe *pipe);\n\nstatic void\nsh_css_hmm_buffer_record_init(void);\n\nstatic void\nsh_css_hmm_buffer_record_uninit(void);\n\nstatic void\nsh_css_hmm_buffer_record_reset(struct sh_css_hmm_buffer_record *buffer_record);\n\nstatic struct sh_css_hmm_buffer_record\n*sh_css_hmm_buffer_record_acquire(struct ia_css_rmgr_vbuf_handle *h_vbuf,\n\t\t\t\t  enum ia_css_buffer_type type,\n\t\t\t\t  hrt_address kernel_ptr);\n\nstatic struct sh_css_hmm_buffer_record\n*sh_css_hmm_buffer_record_validate(ia_css_ptr ddr_buffer_addr,\n\t\t\t\t   enum ia_css_buffer_type type);\n\n#ifdef ISP2401\nstatic unsigned int get_crop_lines_for_bayer_order(const struct\n\tia_css_stream_config *config);\nstatic unsigned int get_crop_columns_for_bayer_order(const struct\n\tia_css_stream_config *config);\nstatic void get_pipe_extra_pixel(struct ia_css_pipe *pipe,\n\t\t\t\t unsigned int *extra_row, unsigned int *extra_column);\n\n#endif\n\nstatic void\nsh_css_pipe_free_shading_table(struct ia_css_pipe *pipe)\n{\n\tif (!pipe) {\n\t\tIA_CSS_ERROR(\"NULL input parameter\");\n\t\treturn;\n\t}\n\n\tif (pipe->shading_table)\n\t\tia_css_shading_table_free(pipe->shading_table);\n\tpipe->shading_table = NULL;\n}\n\nstatic enum ia_css_frame_format yuv420_copy_formats[] = {\n\tIA_CSS_FRAME_FORMAT_NV12,\n\tIA_CSS_FRAME_FORMAT_NV21,\n\tIA_CSS_FRAME_FORMAT_YV12,\n\tIA_CSS_FRAME_FORMAT_YUV420,\n\tIA_CSS_FRAME_FORMAT_YUV420_16,\n\tIA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8,\n\tIA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8\n};\n\nstatic enum ia_css_frame_format yuv422_copy_formats[] = {\n\tIA_CSS_FRAME_FORMAT_NV12,\n\tIA_CSS_FRAME_FORMAT_NV16,\n\tIA_CSS_FRAME_FORMAT_NV21,\n\tIA_CSS_FRAME_FORMAT_NV61,\n\tIA_CSS_FRAME_FORMAT_YV12,\n\tIA_CSS_FRAME_FORMAT_YV16,\n\tIA_CSS_FRAME_FORMAT_YUV420,\n\tIA_CSS_FRAME_FORMAT_YUV420_16,\n\tIA_CSS_FRAME_FORMAT_YUV422,\n\tIA_CSS_FRAME_FORMAT_YUV422_16,\n\tIA_CSS_FRAME_FORMAT_UYVY,\n\tIA_CSS_FRAME_FORMAT_YUYV\n};\n\n \nstatic int\nverify_copy_out_frame_format(struct ia_css_pipe *pipe)\n{\n\tenum ia_css_frame_format out_fmt = pipe->output_info[0].format;\n\tunsigned int i, found = 0;\n\n\tassert(pipe);\n\tassert(pipe->stream);\n\n\tswitch (pipe->stream->config.input_config.format) {\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY:\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8:\n\t\tfor (i = 0; i < ARRAY_SIZE(yuv420_copy_formats) && !found; i++)\n\t\t\tfound = (out_fmt == yuv420_copy_formats[i]);\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV420_10:\n\tcase ATOMISP_INPUT_FORMAT_YUV420_16:\n\t\tfound = (out_fmt == IA_CSS_FRAME_FORMAT_YUV420_16);\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV422_8:\n\t\tfor (i = 0; i < ARRAY_SIZE(yuv422_copy_formats) && !found; i++)\n\t\t\tfound = (out_fmt == yuv422_copy_formats[i]);\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV422_10:\n\tcase ATOMISP_INPUT_FORMAT_YUV422_16:\n\t\tfound = (out_fmt == IA_CSS_FRAME_FORMAT_YUV422_16 ||\n\t\t\t out_fmt == IA_CSS_FRAME_FORMAT_YUV420_16);\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RGB_444:\n\tcase ATOMISP_INPUT_FORMAT_RGB_555:\n\tcase ATOMISP_INPUT_FORMAT_RGB_565:\n\t\tfound = (out_fmt == IA_CSS_FRAME_FORMAT_RGBA888 ||\n\t\t\t out_fmt == IA_CSS_FRAME_FORMAT_RGB565);\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RGB_666:\n\tcase ATOMISP_INPUT_FORMAT_RGB_888:\n\t\tfound = (out_fmt == IA_CSS_FRAME_FORMAT_RGBA888 ||\n\t\t\t out_fmt == IA_CSS_FRAME_FORMAT_YUV420);\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RAW_6:\n\tcase ATOMISP_INPUT_FORMAT_RAW_7:\n\tcase ATOMISP_INPUT_FORMAT_RAW_8:\n\tcase ATOMISP_INPUT_FORMAT_RAW_10:\n\tcase ATOMISP_INPUT_FORMAT_RAW_12:\n\tcase ATOMISP_INPUT_FORMAT_RAW_14:\n\tcase ATOMISP_INPUT_FORMAT_RAW_16:\n\t\tfound = (out_fmt == IA_CSS_FRAME_FORMAT_RAW) ||\n\t\t(out_fmt == IA_CSS_FRAME_FORMAT_RAW_PACKED);\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_BINARY_8:\n\t\tfound = (out_fmt == IA_CSS_FRAME_FORMAT_BINARY_8);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!found)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nunsigned int\nia_css_stream_input_format_bits_per_pixel(struct ia_css_stream *stream)\n{\n\tint bpp = 0;\n\n\tif (stream)\n\t\tbpp = ia_css_util_input_format_bpp(stream->config.input_config.format,\n\t\t\t\t\t\t   stream->config.pixels_per_clock == 2);\n\n\treturn bpp;\n}\n\n \n#define GP_ISEL_TPG_MODE 0x90058\n\n#if !defined(ISP2401)\nstatic int\nsh_css_config_input_network(struct ia_css_stream *stream)\n{\n\tunsigned int fmt_type;\n\tstruct ia_css_pipe *pipe = stream->last_pipe;\n\tstruct ia_css_binary *binary = NULL;\n\tint err = 0;\n\n\tassert(stream);\n\tassert(pipe);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_config_input_network() enter:\\n\");\n\n\tif (pipe->pipeline.stages)\n\t\tbinary = pipe->pipeline.stages->binary;\n\n\terr = ia_css_isys_convert_stream_format_to_mipi_format(\n\t    stream->config.input_config.format,\n\t    stream->csi_rx_config.comp,\n\t    &fmt_type);\n\tif (err)\n\t\treturn err;\n\tsh_css_sp_program_input_circuit(fmt_type,\n\t\t\t\t\tstream->config.channel_id,\n\t\t\t\t\tstream->config.mode);\n\n\tif ((binary && (binary->online || stream->config.continuous)) ||\n\t    pipe->config.mode == IA_CSS_PIPE_MODE_COPY) {\n\t\terr = ia_css_ifmtr_configure(&stream->config,\n\t\t\t\t\t     binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (stream->config.mode == IA_CSS_INPUT_MODE_TPG ||\n\t    stream->config.mode == IA_CSS_INPUT_MODE_PRBS) {\n\t\tunsigned int hblank_cycles = 100,\n\t\tvblank_lines = 6,\n\t\twidth,\n\t\theight,\n\t\tvblank_cycles;\n\t\twidth  = (stream->config.input_config.input_res.width) / (1 +\n\t\t\t(stream->config.pixels_per_clock == 2));\n\t\theight = stream->config.input_config.input_res.height;\n\t\tvblank_cycles = vblank_lines * (width + hblank_cycles);\n\t\tsh_css_sp_configure_sync_gen(width, height, hblank_cycles,\n\t\t\t\t\t     vblank_cycles);\n\t\tif (pipe->stream->config.mode == IA_CSS_INPUT_MODE_TPG)\n\t\t\tia_css_device_store_uint32(GP_ISEL_TPG_MODE, 0);\n\t}\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_config_input_network() leave:\\n\");\n\treturn 0;\n}\n#elif defined(ISP2401)\nstatic unsigned int csi2_protocol_calculate_max_subpixels_per_line(\n    enum atomisp_input_format\tformat,\n    unsigned int\t\t\tpixels_per_line)\n{\n\tunsigned int rval;\n\n\tswitch (format) {\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY:\n\t\t \n\t\trval = pixels_per_line * 2;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8:\n\tcase ATOMISP_INPUT_FORMAT_YUV420_10:\n\tcase ATOMISP_INPUT_FORMAT_YUV420_16:\n\t\t \n\t\trval = pixels_per_line * 2;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV422_8:\n\tcase ATOMISP_INPUT_FORMAT_YUV422_10:\n\tcase ATOMISP_INPUT_FORMAT_YUV422_16:\n\t\t \n\t\trval = pixels_per_line * 2;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RGB_444:\n\tcase ATOMISP_INPUT_FORMAT_RGB_555:\n\tcase ATOMISP_INPUT_FORMAT_RGB_565:\n\tcase ATOMISP_INPUT_FORMAT_RGB_666:\n\tcase ATOMISP_INPUT_FORMAT_RGB_888:\n\t\t \n\t\trval = pixels_per_line * 4;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RAW_6:\n\tcase ATOMISP_INPUT_FORMAT_RAW_7:\n\tcase ATOMISP_INPUT_FORMAT_RAW_8:\n\tcase ATOMISP_INPUT_FORMAT_RAW_10:\n\tcase ATOMISP_INPUT_FORMAT_RAW_12:\n\tcase ATOMISP_INPUT_FORMAT_RAW_14:\n\tcase ATOMISP_INPUT_FORMAT_RAW_16:\n\tcase ATOMISP_INPUT_FORMAT_BINARY_8:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF1:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF2:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF3:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF4:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF5:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF6:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF7:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF8:\n\t\t \n\t\trval = pixels_per_line;\n\t\tbreak;\n\tdefault:\n\t\trval = 0;\n\t\tbreak;\n\t}\n\n\treturn rval;\n}\n\nstatic bool sh_css_translate_stream_cfg_to_input_system_input_port_id(\n    struct ia_css_stream_config *stream_cfg,\n    ia_css_isys_descr_t\t*isys_stream_descr)\n{\n\tbool rc;\n\n\trc = true;\n\tswitch (stream_cfg->mode) {\n\tcase IA_CSS_INPUT_MODE_TPG:\n\n\t\tif (stream_cfg->source.tpg.id == IA_CSS_TPG_ID0)\n\t\t\tisys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT0_ID;\n\t\telse if (stream_cfg->source.tpg.id == IA_CSS_TPG_ID1)\n\t\t\tisys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT1_ID;\n\t\telse if (stream_cfg->source.tpg.id == IA_CSS_TPG_ID2)\n\t\t\tisys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT2_ID;\n\n\t\tbreak;\n\tcase IA_CSS_INPUT_MODE_PRBS:\n\n\t\tif (stream_cfg->source.prbs.id == IA_CSS_PRBS_ID0)\n\t\t\tisys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT0_ID;\n\t\telse if (stream_cfg->source.prbs.id == IA_CSS_PRBS_ID1)\n\t\t\tisys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT1_ID;\n\t\telse if (stream_cfg->source.prbs.id == IA_CSS_PRBS_ID2)\n\t\t\tisys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT2_ID;\n\n\t\tbreak;\n\tcase IA_CSS_INPUT_MODE_BUFFERED_SENSOR:\n\n\t\tif (stream_cfg->source.port.port == MIPI_PORT0_ID)\n\t\t\tisys_stream_descr->input_port_id = INPUT_SYSTEM_CSI_PORT0_ID;\n\t\telse if (stream_cfg->source.port.port == MIPI_PORT1_ID)\n\t\t\tisys_stream_descr->input_port_id = INPUT_SYSTEM_CSI_PORT1_ID;\n\t\telse if (stream_cfg->source.port.port == MIPI_PORT2_ID)\n\t\t\tisys_stream_descr->input_port_id = INPUT_SYSTEM_CSI_PORT2_ID;\n\n\t\tbreak;\n\tdefault:\n\t\trc = false;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic bool sh_css_translate_stream_cfg_to_input_system_input_port_type(\n    struct ia_css_stream_config *stream_cfg,\n    ia_css_isys_descr_t\t*isys_stream_descr)\n{\n\tbool rc;\n\n\trc = true;\n\tswitch (stream_cfg->mode) {\n\tcase IA_CSS_INPUT_MODE_TPG:\n\n\t\tisys_stream_descr->mode = INPUT_SYSTEM_SOURCE_TYPE_TPG;\n\n\t\tbreak;\n\tcase IA_CSS_INPUT_MODE_PRBS:\n\n\t\tisys_stream_descr->mode = INPUT_SYSTEM_SOURCE_TYPE_PRBS;\n\n\t\tbreak;\n\tcase IA_CSS_INPUT_MODE_SENSOR:\n\tcase IA_CSS_INPUT_MODE_BUFFERED_SENSOR:\n\n\t\tisys_stream_descr->mode = INPUT_SYSTEM_SOURCE_TYPE_SENSOR;\n\t\tbreak;\n\n\tdefault:\n\t\trc = false;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic bool sh_css_translate_stream_cfg_to_input_system_input_port_attr(\n    struct ia_css_stream_config *stream_cfg,\n    ia_css_isys_descr_t\t*isys_stream_descr,\n    int isys_stream_idx)\n{\n\tbool rc;\n\n\trc = true;\n\tswitch (stream_cfg->mode) {\n\tcase IA_CSS_INPUT_MODE_TPG:\n\t\tif (stream_cfg->source.tpg.mode == IA_CSS_TPG_MODE_RAMP)\n\t\t\tisys_stream_descr->tpg_port_attr.mode = PIXELGEN_TPG_MODE_RAMP;\n\t\telse if (stream_cfg->source.tpg.mode == IA_CSS_TPG_MODE_CHECKERBOARD)\n\t\t\tisys_stream_descr->tpg_port_attr.mode = PIXELGEN_TPG_MODE_CHBO;\n\t\telse if (stream_cfg->source.tpg.mode == IA_CSS_TPG_MODE_MONO)\n\t\t\tisys_stream_descr->tpg_port_attr.mode = PIXELGEN_TPG_MODE_MONO;\n\t\telse\n\t\t\trc = false;\n\n\t\t \n\t\tisys_stream_descr->tpg_port_attr.color_cfg.R1 = 51;\n\t\tisys_stream_descr->tpg_port_attr.color_cfg.G1 = 102;\n\t\tisys_stream_descr->tpg_port_attr.color_cfg.B1 = 255;\n\t\tisys_stream_descr->tpg_port_attr.color_cfg.R2 = 0;\n\t\tisys_stream_descr->tpg_port_attr.color_cfg.G2 = 100;\n\t\tisys_stream_descr->tpg_port_attr.color_cfg.B2 = 160;\n\n\t\tisys_stream_descr->tpg_port_attr.mask_cfg.h_mask =\n\t\t    stream_cfg->source.tpg.x_mask;\n\t\tisys_stream_descr->tpg_port_attr.mask_cfg.v_mask =\n\t\t    stream_cfg->source.tpg.y_mask;\n\t\tisys_stream_descr->tpg_port_attr.mask_cfg.hv_mask =\n\t\t    stream_cfg->source.tpg.xy_mask;\n\n\t\tisys_stream_descr->tpg_port_attr.delta_cfg.h_delta =\n\t\t    stream_cfg->source.tpg.x_delta;\n\t\tisys_stream_descr->tpg_port_attr.delta_cfg.v_delta =\n\t\t    stream_cfg->source.tpg.y_delta;\n\n\t\t \n\t\tisys_stream_descr->tpg_port_attr.sync_gen_cfg.hblank_cycles = 100;\n\t\tisys_stream_descr->tpg_port_attr.sync_gen_cfg.vblank_cycles = 100;\n\t\tisys_stream_descr->tpg_port_attr.sync_gen_cfg.pixels_per_clock =\n\t\t    stream_cfg->pixels_per_clock;\n\t\tisys_stream_descr->tpg_port_attr.sync_gen_cfg.nr_of_frames = (uint32_t)~(0x0);\n\t\tisys_stream_descr->tpg_port_attr.sync_gen_cfg.pixels_per_line =\n\t\t    stream_cfg->isys_config[IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX].input_res.width;\n\t\tisys_stream_descr->tpg_port_attr.sync_gen_cfg.lines_per_frame =\n\t\t    stream_cfg->isys_config[IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX].input_res.height;\n\n\t\tbreak;\n\tcase IA_CSS_INPUT_MODE_PRBS:\n\n\t\tisys_stream_descr->prbs_port_attr.seed0 = stream_cfg->source.prbs.seed;\n\t\tisys_stream_descr->prbs_port_attr.seed1 = stream_cfg->source.prbs.seed1;\n\n\t\t \n\t\tisys_stream_descr->prbs_port_attr.sync_gen_cfg.hblank_cycles = 100;\n\t\tisys_stream_descr->prbs_port_attr.sync_gen_cfg.vblank_cycles = 100;\n\t\tisys_stream_descr->prbs_port_attr.sync_gen_cfg.pixels_per_clock =\n\t\t    stream_cfg->pixels_per_clock;\n\t\tisys_stream_descr->prbs_port_attr.sync_gen_cfg.nr_of_frames = (uint32_t)~(0x0);\n\t\tisys_stream_descr->prbs_port_attr.sync_gen_cfg.pixels_per_line =\n\t\t    stream_cfg->isys_config[IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX].input_res.width;\n\t\tisys_stream_descr->prbs_port_attr.sync_gen_cfg.lines_per_frame =\n\t\t    stream_cfg->isys_config[IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX].input_res.height;\n\n\t\tbreak;\n\tcase IA_CSS_INPUT_MODE_BUFFERED_SENSOR: {\n\t\tint err;\n\t\tunsigned int fmt_type;\n\n\t\terr = ia_css_isys_convert_stream_format_to_mipi_format(\n\t\t\t  stream_cfg->isys_config[isys_stream_idx].format,\n\t\t\t  MIPI_PREDICTOR_NONE,\n\t\t\t  &fmt_type);\n\t\tif (err)\n\t\t\trc = false;\n\n\t\tisys_stream_descr->csi_port_attr.active_lanes =\n\t\t    stream_cfg->source.port.num_lanes;\n\t\tisys_stream_descr->csi_port_attr.fmt_type = fmt_type;\n\t\tisys_stream_descr->csi_port_attr.ch_id = stream_cfg->channel_id;\n#ifdef ISP2401\n\t\tisys_stream_descr->online = stream_cfg->online;\n#endif\n\t\terr |= ia_css_isys_convert_compressed_format(\n\t\t\t   &stream_cfg->source.port.compression,\n\t\t\t   isys_stream_descr);\n\t\tif (err)\n\t\t\trc = false;\n\n\t\t \n\t\tisys_stream_descr->metadata.enable = false;\n\t\tif (stream_cfg->metadata_config.resolution.height > 0) {\n\t\t\terr = ia_css_isys_convert_stream_format_to_mipi_format(\n\t\t\t\t  stream_cfg->metadata_config.data_type,\n\t\t\t\t  MIPI_PREDICTOR_NONE,\n\t\t\t\t  &fmt_type);\n\t\t\tif (err)\n\t\t\t\trc = false;\n\t\t\tisys_stream_descr->metadata.fmt_type = fmt_type;\n\t\t\tisys_stream_descr->metadata.bits_per_pixel =\n\t\t\t    ia_css_util_input_format_bpp(stream_cfg->metadata_config.data_type, true);\n\t\t\tisys_stream_descr->metadata.pixels_per_line =\n\t\t\t    stream_cfg->metadata_config.resolution.width;\n\t\t\tisys_stream_descr->metadata.lines_per_frame =\n\t\t\t    stream_cfg->metadata_config.resolution.height;\n#ifdef ISP2401\n\t\t\t \n\t\t\tif (isys_stream_descr->metadata.lines_per_frame > 0)\n\t\t\t\tisys_stream_descr->metadata.lines_per_frame +=\n\t\t\t\t    (isys_stream_descr->metadata.lines_per_frame & 1);\n#endif\n\t\t\tisys_stream_descr->metadata.align_req_in_bytes =\n\t\t\t    ia_css_csi2_calculate_input_system_alignment(\n\t\t\t\tstream_cfg->metadata_config.data_type);\n\t\t\tisys_stream_descr->metadata.enable = true;\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\trc = false;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic bool sh_css_translate_stream_cfg_to_input_system_input_port_resolution(\n    struct ia_css_stream_config *stream_cfg,\n    ia_css_isys_descr_t\t*isys_stream_descr,\n    int isys_stream_idx)\n{\n\tunsigned int bits_per_subpixel;\n\tunsigned int max_subpixels_per_line;\n\tunsigned int lines_per_frame;\n\tunsigned int align_req_in_bytes;\n\tenum atomisp_input_format fmt_type;\n\n\tfmt_type = stream_cfg->isys_config[isys_stream_idx].format;\n\tif ((stream_cfg->mode == IA_CSS_INPUT_MODE_SENSOR ||\n\t     stream_cfg->mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) &&\n\t    stream_cfg->source.port.compression.type != IA_CSS_CSI2_COMPRESSION_TYPE_NONE) {\n\t\tif (stream_cfg->source.port.compression.uncompressed_bits_per_pixel ==\n\t\t    UNCOMPRESSED_BITS_PER_PIXEL_10)\n\t\t\tfmt_type = ATOMISP_INPUT_FORMAT_RAW_10;\n\t\telse if (stream_cfg->source.port.compression.uncompressed_bits_per_pixel ==\n\t\t\t   UNCOMPRESSED_BITS_PER_PIXEL_12)\n\t\t\tfmt_type = ATOMISP_INPUT_FORMAT_RAW_12;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tbits_per_subpixel =\n\t    sh_css_stream_format_2_bits_per_subpixel(fmt_type);\n\tif (bits_per_subpixel == 0)\n\t\treturn false;\n\n\tmax_subpixels_per_line =\n\t    csi2_protocol_calculate_max_subpixels_per_line(fmt_type,\n\t\t    stream_cfg->isys_config[isys_stream_idx].input_res.width);\n\tif (max_subpixels_per_line == 0)\n\t\treturn false;\n\n\tlines_per_frame = stream_cfg->isys_config[isys_stream_idx].input_res.height;\n\tif (lines_per_frame == 0)\n\t\treturn false;\n\n\talign_req_in_bytes = ia_css_csi2_calculate_input_system_alignment(fmt_type);\n\n\t \n\tisys_stream_descr->input_port_resolution.bits_per_pixel = bits_per_subpixel;\n\tisys_stream_descr->input_port_resolution.pixels_per_line =\n\t    max_subpixels_per_line;\n\tisys_stream_descr->input_port_resolution.lines_per_frame = lines_per_frame;\n\tisys_stream_descr->input_port_resolution.align_req_in_bytes =\n\t    align_req_in_bytes;\n\n\treturn true;\n}\n\nstatic bool sh_css_translate_stream_cfg_to_isys_stream_descr(\n    struct ia_css_stream_config *stream_cfg,\n    bool early_polling,\n    ia_css_isys_descr_t\t*isys_stream_descr,\n    int isys_stream_idx)\n{\n\tbool rc;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_translate_stream_cfg_to_isys_stream_descr() enter:\\n\");\n\trc  = sh_css_translate_stream_cfg_to_input_system_input_port_id(stream_cfg,\n\t\tisys_stream_descr);\n\trc &= sh_css_translate_stream_cfg_to_input_system_input_port_type(stream_cfg,\n\t\tisys_stream_descr);\n\trc &= sh_css_translate_stream_cfg_to_input_system_input_port_attr(stream_cfg,\n\t\tisys_stream_descr, isys_stream_idx);\n\trc &= sh_css_translate_stream_cfg_to_input_system_input_port_resolution(\n\t\t  stream_cfg, isys_stream_descr, isys_stream_idx);\n\n\tisys_stream_descr->raw_packed = stream_cfg->pack_raw_pixels;\n\tisys_stream_descr->linked_isys_stream_id = (int8_t)\n\t\tstream_cfg->isys_config[isys_stream_idx].linked_isys_stream_id;\n\n\tif (IS_ISP2401)\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t\t    \"sh_css_translate_stream_cfg_to_isys_stream_descr() leave:\\n\");\n\n\treturn rc;\n}\n\nstatic bool sh_css_translate_binary_info_to_input_system_output_port_attr(\n    struct ia_css_binary *binary,\n    ia_css_isys_descr_t     *isys_stream_descr)\n{\n\tif (!binary)\n\t\treturn false;\n\n\tisys_stream_descr->output_port_attr.left_padding = binary->left_padding;\n\tisys_stream_descr->output_port_attr.max_isp_input_width =\n\t    binary->info->sp.input.max_width;\n\n\treturn true;\n}\n\nstatic int\nsh_css_config_input_network(struct ia_css_stream *stream)\n{\n\tbool\t\t\t\t\trc;\n\tia_css_isys_descr_t\t\t\tisys_stream_descr;\n\tunsigned int\t\t\t\tsp_thread_id;\n\tstruct sh_css_sp_pipeline_terminal\t*sp_pipeline_input_terminal;\n\tstruct ia_css_pipe *pipe = NULL;\n\tstruct ia_css_binary *binary = NULL;\n\tint i;\n\tu32 isys_stream_id;\n\tbool early_polling = false;\n\n\tassert(stream);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_config_input_network() enter 0x%p:\\n\", stream);\n\n\tif (stream->config.continuous) {\n\t\tif (stream->last_pipe->config.mode == IA_CSS_PIPE_MODE_CAPTURE)\n\t\t\tpipe = stream->last_pipe;\n\t\telse if (stream->last_pipe->config.mode == IA_CSS_PIPE_MODE_YUVPP)\n\t\t\tpipe = stream->last_pipe;\n\t\telse if (stream->last_pipe->config.mode == IA_CSS_PIPE_MODE_PREVIEW)\n\t\t\tpipe = stream->last_pipe->pipe_settings.preview.copy_pipe;\n\t\telse if (stream->last_pipe->config.mode == IA_CSS_PIPE_MODE_VIDEO)\n\t\t\tpipe = stream->last_pipe->pipe_settings.video.copy_pipe;\n\t} else {\n\t\tpipe = stream->last_pipe;\n\t}\n\n\tif (!pipe)\n\t\treturn -EINVAL;\n\n\tif (pipe->pipeline.stages)\n\t\tif (pipe->pipeline.stages->binary)\n\t\t\tbinary = pipe->pipeline.stages->binary;\n\n\tif (binary) {\n\t\t \n\t\tia_css_get_crop_offsets(pipe, &binary->in_frame_info);\n\t}\n\n\t \n\trc = ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &sp_thread_id);\n\tif (!rc)\n\t\treturn -EINVAL;\n\t \n\tsp_pipeline_input_terminal = &sh_css_sp_group.pipe_io[sp_thread_id].input;\n\n\tfor (i = 0; i < IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH; i++) {\n\t\t \n\t\tmemset((void *)(&isys_stream_descr), 0, sizeof(ia_css_isys_descr_t));\n\t\tsp_pipeline_input_terminal->context.virtual_input_system_stream[i].valid = 0;\n\t\tsp_pipeline_input_terminal->ctrl.virtual_input_system_stream_cfg[i].valid = 0;\n\n\t\tif (!stream->config.isys_config[i].valid)\n\t\t\tcontinue;\n\n\t\t \n\t\trc = sh_css_translate_stream_cfg_to_isys_stream_descr(\n\t\t\t &stream->config,\n\t\t\t early_polling,\n\t\t\t &(isys_stream_descr), i);\n\n\t\tif (stream->config.online) {\n\t\t\trc &= sh_css_translate_binary_info_to_input_system_output_port_attr(\n\t\t\t\t  binary,\n\t\t\t\t  &(isys_stream_descr));\n\t\t}\n\n\t\tif (!rc)\n\t\t\treturn -EINVAL;\n\n\t\tisys_stream_id = ia_css_isys_generate_stream_id(sp_thread_id, i);\n\n\t\t \n\t\trc =  ia_css_isys_stream_create(\n\t\t\t  &(isys_stream_descr),\n\t\t\t  &sp_pipeline_input_terminal->context.virtual_input_system_stream[i],\n\t\t\t  isys_stream_id);\n\t\tif (!rc)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\trc = ia_css_isys_stream_calculate_cfg(\n\t\t\t &sp_pipeline_input_terminal->context.virtual_input_system_stream[i],\n\t\t\t &(isys_stream_descr),\n\t\t\t &sp_pipeline_input_terminal->ctrl.virtual_input_system_stream_cfg[i]);\n\t\tif (!rc) {\n\t\t\tia_css_isys_stream_destroy(\n\t\t\t    &sp_pipeline_input_terminal->context.virtual_input_system_stream[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_config_input_network() leave:\\n\");\n\n\treturn 0;\n}\n\nstatic inline struct ia_css_pipe *stream_get_last_pipe(\n    struct ia_css_stream *stream)\n{\n\tstruct ia_css_pipe *last_pipe = NULL;\n\n\tif (stream)\n\t\tlast_pipe = stream->last_pipe;\n\n\treturn last_pipe;\n}\n\nstatic inline struct ia_css_pipe *stream_get_copy_pipe(\n    struct ia_css_stream *stream)\n{\n\tstruct ia_css_pipe *copy_pipe = NULL;\n\tstruct ia_css_pipe *last_pipe = NULL;\n\tenum ia_css_pipe_id pipe_id;\n\n\tlast_pipe = stream_get_last_pipe(stream);\n\n\tif ((stream) &&\n\t    (last_pipe) &&\n\t    (stream->config.continuous)) {\n\t\tpipe_id = last_pipe->mode;\n\t\tswitch (pipe_id) {\n\t\tcase IA_CSS_PIPE_ID_PREVIEW:\n\t\t\tcopy_pipe = last_pipe->pipe_settings.preview.copy_pipe;\n\t\t\tbreak;\n\t\tcase IA_CSS_PIPE_ID_VIDEO:\n\t\t\tcopy_pipe = last_pipe->pipe_settings.video.copy_pipe;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_pipe = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn copy_pipe;\n}\n\nstatic inline struct ia_css_pipe *stream_get_target_pipe(\n    struct ia_css_stream *stream)\n{\n\tstruct ia_css_pipe *target_pipe;\n\n\t \n\tif (stream->config.continuous)\n\t\ttarget_pipe = stream_get_copy_pipe(stream);\n\telse\n\t\ttarget_pipe = stream_get_last_pipe(stream);\n\n\treturn target_pipe;\n}\n\nstatic int stream_csi_rx_helper(\n    struct ia_css_stream *stream,\n    int (*func)(enum mipi_port_id, uint32_t))\n{\n\tint retval = -EINVAL;\n\tu32 sp_thread_id, stream_id;\n\tbool rc;\n\tstruct ia_css_pipe *target_pipe = NULL;\n\n\tif ((!stream) || (stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR))\n\t\tgoto exit;\n\n\ttarget_pipe = stream_get_target_pipe(stream);\n\n\tif (!target_pipe)\n\t\tgoto exit;\n\n\trc = ia_css_pipeline_get_sp_thread_id(\n\t\t ia_css_pipe_get_pipe_num(target_pipe),\n\t\t &sp_thread_id);\n\n\tif (!rc)\n\t\tgoto exit;\n\n\t \n\tstream_id = 0;\n\tdo {\n\t\tif (stream->config.isys_config[stream_id].valid) {\n\t\t\tu32 isys_stream_id = ia_css_isys_generate_stream_id(sp_thread_id, stream_id);\n\n\t\t\tretval = func(stream->config.source.port.port, isys_stream_id);\n\t\t}\n\t\tstream_id++;\n\t} while ((retval == 0) &&\n\t\t (stream_id < IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH));\n\nexit:\n\treturn retval;\n}\n\nstatic inline int stream_register_with_csi_rx(\n    struct ia_css_stream *stream)\n{\n\treturn stream_csi_rx_helper(stream, ia_css_isys_csi_rx_register_stream);\n}\n\nstatic inline int stream_unregister_with_csi_rx(\n    struct ia_css_stream *stream)\n{\n\treturn stream_csi_rx_helper(stream, ia_css_isys_csi_rx_unregister_stream);\n}\n#endif\n\n\nstatic void\nstart_binary(struct ia_css_pipe *pipe,\n\t     struct ia_css_binary *binary)\n{\n\tassert(pipe);\n\t \n\n\tif (binary)\n\t\tsh_css_metrics_start_binary(&binary->metrics);\n\n\n#if !defined(ISP2401)\n\tif (pipe->stream->reconfigure_css_rx) {\n\t\tia_css_isys_rx_configure(&pipe->stream->csi_rx_config,\n\t\t\t\t\t pipe->stream->config.mode);\n\t\tpipe->stream->reconfigure_css_rx = false;\n\t}\n#endif\n}\n\n \nstatic int\nstart_copy_on_sp(struct ia_css_pipe *pipe,\n\t\t struct ia_css_frame *out_frame)\n{\n\t(void)out_frame;\n\n\tif ((!pipe) || (!pipe->stream))\n\t\treturn -EINVAL;\n\n#if !defined(ISP2401)\n\tif (pipe->stream->reconfigure_css_rx)\n\t\tia_css_isys_rx_disable();\n#endif\n\n\tif (pipe->stream->config.input_config.format != ATOMISP_INPUT_FORMAT_BINARY_8)\n\t\treturn -EINVAL;\n\tsh_css_sp_start_binary_copy(ia_css_pipe_get_pipe_num(pipe), out_frame, pipe->stream->config.pixels_per_clock == 2);\n\n#if !defined(ISP2401)\n\tif (pipe->stream->reconfigure_css_rx) {\n\t\tia_css_isys_rx_configure(&pipe->stream->csi_rx_config,\n\t\t\t\t\t pipe->stream->config.mode);\n\t\tpipe->stream->reconfigure_css_rx = false;\n\t}\n#endif\n\n\treturn 0;\n}\n\nvoid sh_css_binary_args_reset(struct sh_css_binary_args *args)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < NUM_VIDEO_TNR_FRAMES; i++)\n\t\targs->tnr_frames[i] = NULL;\n\tfor (i = 0; i < MAX_NUM_VIDEO_DELAY_FRAMES; i++)\n\t\targs->delay_frames[i] = NULL;\n\targs->in_frame      = NULL;\n\tfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)\n\t\targs->out_frame[i] = NULL;\n\targs->out_vf_frame  = NULL;\n\targs->copy_vf       = false;\n\targs->copy_output   = true;\n\targs->vf_downscale_log2 = 0;\n}\n\nstatic void start_pipe(\n    struct ia_css_pipe *me,\n    enum sh_css_pipe_config_override copy_ovrd,\n    enum ia_css_input_mode input_mode)\n{\n\tIA_CSS_ENTER_PRIVATE(\"me = %p, copy_ovrd = %d, input_mode = %d\",\n\t\t\t     me, copy_ovrd, input_mode);\n\n\tassert(me);  \n\n\tsh_css_sp_init_pipeline(&me->pipeline,\n\t\t\t\tme->mode,\n\t\t\t\t(uint8_t)ia_css_pipe_get_pipe_num(me),\n\t\t\t\tme->config.default_capture_config.enable_xnr != 0,\n\t\t\t\tme->stream->config.pixels_per_clock == 2,\n\t\t\t\tme->stream->config.continuous,\n\t\t\t\tfalse,\n\t\t\t\tme->required_bds_factor,\n\t\t\t\tcopy_ovrd,\n\t\t\t\tinput_mode,\n\t\t\t\t&me->stream->config.metadata_config,\n\t\t\t\t&me->stream->info.metadata_info\n\t\t\t\t, (input_mode == IA_CSS_INPUT_MODE_MEMORY) ?\n\t\t\t\t(enum mipi_port_id)0 :\n\t\t\t\tme->stream->config.source.port.port);\n\n\tif (me->config.mode != IA_CSS_PIPE_MODE_COPY) {\n\t\tstruct ia_css_pipeline_stage *stage;\n\n\t\tstage = me->pipeline.stages;\n\t\tif (stage) {\n\t\t\tme->pipeline.current_stage = stage;\n\t\t\tstart_binary(me, stage->binary);\n\t\t}\n\t}\n\tIA_CSS_LEAVE_PRIVATE(\"void\");\n}\n\nvoid\nsh_css_invalidate_shading_tables(struct ia_css_stream *stream)\n{\n\tint i;\n\n\tassert(stream);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"sh_css_invalidate_shading_tables() enter:\\n\");\n\n\tfor (i = 0; i < stream->num_pipes; i++) {\n\t\tassert(stream->pipes[i]);\n\t\tsh_css_pipe_free_shading_table(stream->pipes[i]);\n\t}\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"sh_css_invalidate_shading_tables() leave: return_void\\n\");\n}\n\nstatic void\nenable_interrupts(enum ia_css_irq_type irq_type)\n{\n#ifndef ISP2401\n\tenum mipi_port_id port;\n#endif\n\tbool enable_pulse = irq_type != IA_CSS_IRQ_TYPE_EDGE;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\t \n\tcnd_sp_irq_enable(SP0_ID, true);\n\t \n\tirq_enable_pulse(IRQ0_ID, enable_pulse);\n\n\tcnd_virq_enable_channel(virq_sp, true);\n\n\t \n\tcnd_virq_enable_channel(\n\t    (enum virq_id)(IRQ_SW_CHANNEL0_ID + IRQ_SW_CHANNEL_OFFSET),\n\t    true);\n\t \n\tcnd_virq_enable_channel(\n\t    (enum virq_id)(IRQ_SW_CHANNEL1_ID + IRQ_SW_CHANNEL_OFFSET),\n\t    true);\n\n#ifndef ISP2401\n\tfor (port = 0; port < N_MIPI_PORT_ID; port++)\n\t\tia_css_isys_rx_enable_all_interrupts(port);\n#endif\n\n\tIA_CSS_LEAVE_PRIVATE(\"\");\n}\n\nstatic bool sh_css_setup_spctrl_config(const struct ia_css_fw_info *fw,\n\t\t\t\t       const char *program,\n\t\t\t\t       ia_css_spctrl_cfg  *spctrl_cfg)\n{\n\tif ((!fw) || (!spctrl_cfg))\n\t\treturn false;\n\tspctrl_cfg->sp_entry = 0;\n\tspctrl_cfg->program_name = (char *)(program);\n\n\tspctrl_cfg->ddr_data_offset =  fw->blob.data_source;\n\tspctrl_cfg->dmem_data_addr = fw->blob.data_target;\n\tspctrl_cfg->dmem_bss_addr = fw->blob.bss_target;\n\tspctrl_cfg->data_size = fw->blob.data_size;\n\tspctrl_cfg->bss_size = fw->blob.bss_size;\n\n\tspctrl_cfg->spctrl_config_dmem_addr = fw->info.sp.init_dmem_data;\n\tspctrl_cfg->spctrl_state_dmem_addr = fw->info.sp.sw_state;\n\n\tspctrl_cfg->code_size = fw->blob.size;\n\tspctrl_cfg->code      = fw->blob.code;\n\tspctrl_cfg->sp_entry  = fw->info.sp.sp_entry;  \n\n\treturn true;\n}\n\nvoid\nia_css_unload_firmware(void)\n{\n\tif (sh_css_num_binaries) {\n\t\t \n\t\tia_css_binary_uninit();\n\t\tsh_css_unload_firmware();\n\t}\n\tfw_explicitly_loaded = false;\n}\n\nstatic void\nia_css_reset_defaults(struct sh_css *css)\n{\n\tstruct sh_css default_css;\n\n\t \n\tmemset(&default_css, 0, sizeof(default_css));\n\n\t \n\tdefault_css.check_system_idle = true;\n\tdefault_css.num_cont_raw_frames = NUM_CONTINUOUS_FRAMES;\n\n\t \n\n\tdefault_css.irq_type = IA_CSS_IRQ_TYPE_EDGE;\n\n\t \n\t*css = default_css;\n}\n\nint\nia_css_load_firmware(struct device *dev, const struct ia_css_env *env,\n\t\t     const struct ia_css_fw  *fw)\n{\n\tint err;\n\n\tif (!env)\n\t\treturn -EINVAL;\n\tif (!fw)\n\t\treturn -EINVAL;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_load_firmware() enter\\n\");\n\n\t \n\tif (my_css.flush != env->cpu_mem_env.flush) {\n\t\tia_css_reset_defaults(&my_css);\n\t\tmy_css.flush = env->cpu_mem_env.flush;\n\t}\n\n\tia_css_unload_firmware();  \n\terr = sh_css_load_firmware(dev, fw->data, fw->bytes);\n\tif (!err) {\n\t\terr = ia_css_binary_init_infos();\n\t\tif (!err)\n\t\t\tfw_explicitly_loaded = true;\n\t}\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_load_firmware() leave\\n\");\n\treturn err;\n}\n\nint\nia_css_init(struct device *dev, const struct ia_css_env *env,\n\t    const struct ia_css_fw  *fw,\n\t    u32                 mmu_l1_base,\n\t    enum ia_css_irq_type     irq_type)\n{\n\tint err;\n\tia_css_spctrl_cfg spctrl_cfg;\n\n\tvoid (*flush_func)(struct ia_css_acc_fw *fw);\n\thrt_data select, enable;\n\n\t \n\n\t \n\tCOMPILATION_ERROR_IF(sizeof(struct sh_css_ddr_address_map)\t\t!= SIZE_OF_SH_CSS_DDR_ADDRESS_MAP_STRUCT);\n\t \n\tCOMPILATION_ERROR_IF(sizeof(struct host_sp_queues)\t\t\t!= SIZE_OF_HOST_SP_QUEUES_STRUCT);\n\tCOMPILATION_ERROR_IF(sizeof(struct ia_css_circbuf_desc_s)\t\t!= SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT);\n\tCOMPILATION_ERROR_IF(sizeof(struct ia_css_circbuf_elem_s)\t\t!= SIZE_OF_IA_CSS_CIRCBUF_ELEM_S_STRUCT);\n\n\t \n\tCOMPILATION_ERROR_IF(sizeof(struct host_sp_communication)\t\t!= SIZE_OF_HOST_SP_COMMUNICATION_STRUCT);\n\tCOMPILATION_ERROR_IF(sizeof(struct sh_css_event_irq_mask)\t\t!= SIZE_OF_SH_CSS_EVENT_IRQ_MASK_STRUCT);\n\n\t \n\tCOMPILATION_ERROR_IF(sizeof(struct sh_css_hmm_buffer)\t\t\t!= SIZE_OF_SH_CSS_HMM_BUFFER_STRUCT);\n\tCOMPILATION_ERROR_IF(sizeof(struct ia_css_isp_3a_statistics)\t\t!= SIZE_OF_IA_CSS_ISP_3A_STATISTICS_STRUCT);\n\tCOMPILATION_ERROR_IF(sizeof(struct ia_css_isp_dvs_statistics)\t\t!= SIZE_OF_IA_CSS_ISP_DVS_STATISTICS_STRUCT);\n\tCOMPILATION_ERROR_IF(sizeof(struct ia_css_metadata)\t\t\t!= SIZE_OF_IA_CSS_METADATA_STRUCT);\n\n\t \n\tCOMPILATION_ERROR_IF(sizeof(struct ia_css_sp_init_dmem_cfg)\t\t!= SIZE_OF_IA_CSS_SP_INIT_DMEM_CFG_STRUCT);\n\n\tif (!fw && !fw_explicitly_loaded)\n\t\treturn -EINVAL;\n\tif (!env)\n\t\treturn -EINVAL;\n\n\tsh_css_printf = env->print_env.debug_print;\n\n\tIA_CSS_ENTER(\"void\");\n\n\tflush_func     = env->cpu_mem_env.flush;\n\n\tpipe_global_init();\n\tia_css_pipeline_init();\n\tia_css_queue_map_init();\n\n\tia_css_device_access_init(&env->hw_access_env);\n\n\tselect = gpio_reg_load(GPIO0_ID, _gpio_block_reg_do_select)\n\t& (~GPIO_FLASH_PIN_MASK);\n\tenable = gpio_reg_load(GPIO0_ID, _gpio_block_reg_do_e)\n\t| GPIO_FLASH_PIN_MASK;\n\tsh_css_mmu_set_page_table_base_index(mmu_l1_base);\n\n\tmy_css_save.mmu_base = mmu_l1_base;\n\n\tia_css_reset_defaults(&my_css);\n\n\tmy_css_save.driver_env = *env;\n\tmy_css.flush     = flush_func;\n\n\terr = ia_css_rmgr_init();\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR(err);\n\t\treturn err;\n\t}\n\n\tIA_CSS_LOG(\"init: %d\", my_css_save_initialized);\n\n\tif (!my_css_save_initialized) {\n\t\tmy_css_save_initialized = true;\n\t\tmy_css_save.mode = sh_css_mode_working;\n\t\tmemset(my_css_save.stream_seeds, 0,\n\t\t       sizeof(struct sh_css_stream_seed) * MAX_ACTIVE_STREAMS);\n\t\tIA_CSS_LOG(\"init: %d mode=%d\", my_css_save_initialized, my_css_save.mode);\n\t}\n\n\tmipi_init();\n\n\t \n\tif (!IS_ISP2401)\n\t\tmy_css.page_table_base_index = mmu_get_page_table_base_index(MMU0_ID);\n\n\tmy_css.irq_type = irq_type;\n\n\tmy_css_save.irq_type = irq_type;\n\n\tenable_interrupts(my_css.irq_type);\n\n\t \n\tgpio_reg_store(GPIO0_ID, _gpio_block_reg_do_select, select);\n\tgpio_reg_store(GPIO0_ID, _gpio_block_reg_do_e, enable);\n\tgpio_reg_store(GPIO0_ID, _gpio_block_reg_do_0, 0);\n\n\terr = ia_css_refcount_init(REFCOUNT_SIZE);\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR(err);\n\t\treturn err;\n\t}\n\terr = sh_css_params_init();\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR(err);\n\t\treturn err;\n\t}\n\tif (fw) {\n\t\tia_css_unload_firmware();  \n\t\terr = sh_css_load_firmware(dev, fw->data, fw->bytes);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR(err);\n\t\t\treturn err;\n\t\t}\n\t\terr = ia_css_binary_init_infos();\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR(err);\n\t\t\treturn err;\n\t\t}\n\t\tfw_explicitly_loaded = false;\n\n\t\tmy_css_save.loaded_fw = (struct ia_css_fw *)fw;\n\t}\n\tif (!sh_css_setup_spctrl_config(&sh_css_sp_fw, SP_PROG_NAME, &spctrl_cfg))\n\t\treturn -EINVAL;\n\n\terr = ia_css_spctrl_load_fw(SP0_ID, &spctrl_cfg);\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR(err);\n\t\treturn err;\n\t}\n\n\tif (!sh_css_hrt_system_is_idle()) {\n\t\tIA_CSS_LEAVE_ERR(-EBUSY);\n\t\treturn -EBUSY;\n\t}\n\t \n\n\tif (IS_ISP2401)\n\t\tgp_device_reg_store(GP_DEVICE0_ID, _REG_GP_SWITCH_ISYS2401_ADDR, 1);\n\n\tif (!IS_ISP2401)\n\t\tdma_set_max_burst_size(DMA0_ID, HIVE_DMA_BUS_DDR_CONN,\n\t\t\t\t       ISP2400_DMA_MAX_BURST_LENGTH);\n\telse\n\t\tdma_set_max_burst_size(DMA0_ID, HIVE_DMA_BUS_DDR_CONN,\n\t\t\t\t       ISP2401_DMA_MAX_BURST_LENGTH);\n\n\tif (ia_css_isys_init() != INPUT_SYSTEM_ERR_NO_ERROR)\n\t\terr = -EINVAL;\n\n\tsh_css_params_map_and_store_default_gdc_lut();\n\n\tIA_CSS_LEAVE_ERR(err);\n\treturn err;\n}\n\nint\nia_css_enable_isys_event_queue(bool enable)\n{\n\tif (sh_css_sp_is_running())\n\t\treturn -EBUSY;\n\tsh_css_sp_enable_isys_event_queue(enable);\n\treturn 0;\n}\n\n \nstatic int\nmap_sp_threads(struct ia_css_stream *stream, bool map)\n{\n\tstruct ia_css_pipe *main_pipe = NULL;\n\tstruct ia_css_pipe *copy_pipe = NULL;\n\tstruct ia_css_pipe *capture_pipe = NULL;\n\tint err = 0;\n\tenum ia_css_pipe_id pipe_id;\n\n\tIA_CSS_ENTER_PRIVATE(\"stream = %p, map = %s\",\n\t\t\t     stream, map ? \"true\" : \"false\");\n\n\tif (!stream) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmain_pipe = stream->last_pipe;\n\tpipe_id\t= main_pipe->mode;\n\n\tia_css_pipeline_map(main_pipe->pipe_num, map);\n\n\tswitch (pipe_id) {\n\tcase IA_CSS_PIPE_ID_PREVIEW:\n\t\tcopy_pipe    = main_pipe->pipe_settings.preview.copy_pipe;\n\t\tcapture_pipe = main_pipe->pipe_settings.preview.capture_pipe;\n\t\tbreak;\n\n\tcase IA_CSS_PIPE_ID_VIDEO:\n\t\tcopy_pipe    = main_pipe->pipe_settings.video.copy_pipe;\n\t\tcapture_pipe = main_pipe->pipe_settings.video.capture_pipe;\n\t\tbreak;\n\n\tcase IA_CSS_PIPE_ID_CAPTURE:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (capture_pipe)\n\t\tia_css_pipeline_map(capture_pipe->pipe_num, map);\n\n\t \n\tif (copy_pipe)\n\t\tia_css_pipeline_map(copy_pipe->pipe_num, map);\n\n\t \n\tif (!stream->config.continuous) {\n\t\tint i;\n\n\t\tfor (i = 1; i < stream->num_pipes; i++)\n\t\t\tia_css_pipeline_map(stream->pipes[i]->pipe_num, map);\n\t}\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\n \nstatic int\ncreate_host_pipeline_structure(struct ia_css_stream *stream)\n{\n\tstruct ia_css_pipe *copy_pipe = NULL, *capture_pipe = NULL;\n\tenum ia_css_pipe_id pipe_id;\n\tstruct ia_css_pipe *main_pipe = NULL;\n\tint err = 0;\n\tunsigned int copy_pipe_delay = 0,\n\tcapture_pipe_delay = 0;\n\n\tIA_CSS_ENTER_PRIVATE(\"stream = %p\", stream);\n\n\tif (!stream) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmain_pipe\t= stream->last_pipe;\n\tif (!main_pipe) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tpipe_id\t= main_pipe->mode;\n\n\tswitch (pipe_id) {\n\tcase IA_CSS_PIPE_ID_PREVIEW:\n\t\tcopy_pipe    = main_pipe->pipe_settings.preview.copy_pipe;\n\t\tcopy_pipe_delay = main_pipe->dvs_frame_delay;\n\t\tcapture_pipe = main_pipe->pipe_settings.preview.capture_pipe;\n\t\tcapture_pipe_delay = IA_CSS_FRAME_DELAY_0;\n\t\terr = ia_css_pipeline_create(&main_pipe->pipeline, main_pipe->mode,\n\t\t\t\t\t     main_pipe->pipe_num, main_pipe->dvs_frame_delay);\n\t\tbreak;\n\n\tcase IA_CSS_PIPE_ID_VIDEO:\n\t\tcopy_pipe    = main_pipe->pipe_settings.video.copy_pipe;\n\t\tcopy_pipe_delay = main_pipe->dvs_frame_delay;\n\t\tcapture_pipe = main_pipe->pipe_settings.video.capture_pipe;\n\t\tcapture_pipe_delay = IA_CSS_FRAME_DELAY_0;\n\t\terr = ia_css_pipeline_create(&main_pipe->pipeline, main_pipe->mode,\n\t\t\t\t\t     main_pipe->pipe_num, main_pipe->dvs_frame_delay);\n\t\tbreak;\n\n\tcase IA_CSS_PIPE_ID_CAPTURE:\n\t\tcapture_pipe = main_pipe;\n\t\tcapture_pipe_delay = main_pipe->dvs_frame_delay;\n\t\tbreak;\n\n\tcase IA_CSS_PIPE_ID_YUVPP:\n\t\terr = ia_css_pipeline_create(&main_pipe->pipeline, main_pipe->mode,\n\t\t\t\t\t     main_pipe->pipe_num, main_pipe->dvs_frame_delay);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\tif (!(err) && copy_pipe)\n\t\terr = ia_css_pipeline_create(&copy_pipe->pipeline,\n\t\t\t\t\t     copy_pipe->mode,\n\t\t\t\t\t     copy_pipe->pipe_num,\n\t\t\t\t\t     copy_pipe_delay);\n\n\tif (!(err) && capture_pipe)\n\t\terr = ia_css_pipeline_create(&capture_pipe->pipeline,\n\t\t\t\t\t     capture_pipe->mode,\n\t\t\t\t\t     capture_pipe->pipe_num,\n\t\t\t\t\t     capture_pipe_delay);\n\n\t \n\tif (!stream->config.continuous) {\n\t\tint i;\n\n\t\tfor (i = 1; i < stream->num_pipes && 0 == err; i++) {\n\t\t\tmain_pipe = stream->pipes[i];\n\t\t\terr = ia_css_pipeline_create(&main_pipe->pipeline,\n\t\t\t\t\t\t     main_pipe->mode,\n\t\t\t\t\t\t     main_pipe->pipe_num,\n\t\t\t\t\t\t     main_pipe->dvs_frame_delay);\n\t\t}\n\t}\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\n \nstatic int\ncreate_host_pipeline(struct ia_css_stream *stream)\n{\n\tstruct ia_css_pipe *copy_pipe = NULL, *capture_pipe = NULL;\n\tenum ia_css_pipe_id pipe_id;\n\tstruct ia_css_pipe *main_pipe = NULL;\n\tint err = 0;\n\tunsigned int max_input_width = 0;\n\n\tIA_CSS_ENTER_PRIVATE(\"stream = %p\", stream);\n\tif (!stream) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmain_pipe\t= stream->last_pipe;\n\tpipe_id\t= main_pipe->mode;\n\n\t \n\tif ((pipe_id == IA_CSS_PIPE_ID_PREVIEW) ||\n\t    (pipe_id == IA_CSS_PIPE_ID_VIDEO)) {\n\t\t \n\t\tif (stream->config.continuous ||\n\t\t    (pipe_id == IA_CSS_PIPE_ID_PREVIEW &&\n\t\t     stream->config.mode != IA_CSS_INPUT_MODE_MEMORY)) {\n\t\t\terr = alloc_continuous_frames(main_pipe, true);\n\t\t\tif (err)\n\t\t\t\tgoto ERR;\n\t\t}\n\t}\n\n\t \n\tif (!IS_ISP2401 || main_pipe->config.mode != IA_CSS_PIPE_MODE_COPY) {\n\t\terr = allocate_mipi_frames(main_pipe, &stream->info);\n\t\tif (err)\n\t\t\tgoto ERR;\n\t}\n\n\tswitch (pipe_id) {\n\tcase IA_CSS_PIPE_ID_PREVIEW:\n\t\tcopy_pipe    = main_pipe->pipe_settings.preview.copy_pipe;\n\t\tcapture_pipe = main_pipe->pipe_settings.preview.capture_pipe;\n\t\tmax_input_width =\n\t\t    main_pipe->pipe_settings.preview.preview_binary.info->sp.input.max_width;\n\n\t\terr = create_host_preview_pipeline(main_pipe);\n\t\tif (err)\n\t\t\tgoto ERR;\n\n\t\tbreak;\n\n\tcase IA_CSS_PIPE_ID_VIDEO:\n\t\tcopy_pipe    = main_pipe->pipe_settings.video.copy_pipe;\n\t\tcapture_pipe = main_pipe->pipe_settings.video.capture_pipe;\n\t\tmax_input_width =\n\t\t    main_pipe->pipe_settings.video.video_binary.info->sp.input.max_width;\n\n\t\terr = create_host_video_pipeline(main_pipe);\n\t\tif (err)\n\t\t\tgoto ERR;\n\n\t\tbreak;\n\n\tcase IA_CSS_PIPE_ID_CAPTURE:\n\t\tcapture_pipe = main_pipe;\n\n\t\tbreak;\n\n\tcase IA_CSS_PIPE_ID_YUVPP:\n\t\terr = create_host_yuvpp_pipeline(main_pipe);\n\t\tif (err)\n\t\t\tgoto ERR;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\tif (err)\n\t\tgoto ERR;\n\n\tif (copy_pipe) {\n\t\terr = create_host_copy_pipeline(copy_pipe, max_input_width,\n\t\t\t\t\t\tmain_pipe->continuous_frames[0]);\n\t\tif (err)\n\t\t\tgoto ERR;\n\t}\n\n\tif (capture_pipe) {\n\t\terr = create_host_capture_pipeline(capture_pipe);\n\t\tif (err)\n\t\t\tgoto ERR;\n\t}\n\n\t \n\tif (!stream->config.continuous) {\n\t\tint i;\n\n\t\tfor (i = 1; i < stream->num_pipes && 0 == err; i++) {\n\t\t\tswitch (stream->pipes[i]->mode) {\n\t\t\tcase IA_CSS_PIPE_ID_PREVIEW:\n\t\t\t\terr = create_host_preview_pipeline(stream->pipes[i]);\n\t\t\t\tbreak;\n\t\t\tcase IA_CSS_PIPE_ID_VIDEO:\n\t\t\t\terr = create_host_video_pipeline(stream->pipes[i]);\n\t\t\t\tbreak;\n\t\t\tcase IA_CSS_PIPE_ID_CAPTURE:\n\t\t\t\terr = create_host_capture_pipeline(stream->pipes[i]);\n\t\t\t\tbreak;\n\t\t\tcase IA_CSS_PIPE_ID_YUVPP:\n\t\t\t\terr = create_host_yuvpp_pipeline(stream->pipes[i]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tif (err)\n\t\t\t\tgoto ERR;\n\t\t}\n\t}\n\nERR:\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\nstatic const struct ia_css_pipe default_pipe = IA_CSS_DEFAULT_PIPE;\nstatic const struct ia_css_preview_settings preview = IA_CSS_DEFAULT_PREVIEW_SETTINGS;\nstatic const struct ia_css_capture_settings capture = IA_CSS_DEFAULT_CAPTURE_SETTINGS;\nstatic const struct ia_css_video_settings video = IA_CSS_DEFAULT_VIDEO_SETTINGS;\nstatic const struct ia_css_yuvpp_settings yuvpp = IA_CSS_DEFAULT_YUVPP_SETTINGS;\n\nstatic int\ninit_pipe_defaults(enum ia_css_pipe_mode mode,\n\t\t   struct ia_css_pipe *pipe,\n\t\t   bool copy_pipe)\n{\n\tif (!pipe) {\n\t\tIA_CSS_ERROR(\"NULL pipe parameter\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemcpy(pipe, &default_pipe, sizeof(default_pipe));\n\n\t \n\tswitch (mode) {\n\tcase IA_CSS_PIPE_MODE_PREVIEW:\n\t\tpipe->mode = IA_CSS_PIPE_ID_PREVIEW;\n\t\tmemcpy(&pipe->pipe_settings.preview, &preview, sizeof(preview));\n\t\tbreak;\n\tcase IA_CSS_PIPE_MODE_CAPTURE:\n\t\tif (copy_pipe)\n\t\t\tpipe->mode = IA_CSS_PIPE_ID_COPY;\n\t\telse\n\t\t\tpipe->mode = IA_CSS_PIPE_ID_CAPTURE;\n\n\t\tmemcpy(&pipe->pipe_settings.capture, &capture, sizeof(capture));\n\t\tbreak;\n\tcase IA_CSS_PIPE_MODE_VIDEO:\n\t\tpipe->mode = IA_CSS_PIPE_ID_VIDEO;\n\t\tmemcpy(&pipe->pipe_settings.video, &video, sizeof(video));\n\t\tbreak;\n\tcase IA_CSS_PIPE_MODE_COPY:\n\t\tpipe->mode = IA_CSS_PIPE_ID_CAPTURE;\n\t\tbreak;\n\tcase IA_CSS_PIPE_MODE_YUVPP:\n\t\tpipe->mode = IA_CSS_PIPE_ID_YUVPP;\n\t\tmemcpy(&pipe->pipe_settings.yuvpp, &yuvpp, sizeof(yuvpp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void\npipe_global_init(void)\n{\n\tu8 i;\n\n\tmy_css.pipe_counter = 0;\n\tfor (i = 0; i < IA_CSS_PIPELINE_NUM_MAX; i++)\n\t\tmy_css.all_pipes[i] = NULL;\n}\n\nstatic int\npipe_generate_pipe_num(const struct ia_css_pipe *pipe,\n\t\t       unsigned int *pipe_number)\n{\n\tconst u8 INVALID_PIPE_NUM = (uint8_t)~(0);\n\tu8 pipe_num = INVALID_PIPE_NUM;\n\tu8 i;\n\n\tif (!pipe) {\n\t\tIA_CSS_ERROR(\"NULL pipe parameter\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < IA_CSS_PIPELINE_NUM_MAX; i++) {\n\t\tif (!my_css.all_pipes[i]) {\n\t\t\t \n\t\t\tmy_css.all_pipes[i] = (struct ia_css_pipe *)pipe;\n\t\t\tpipe_num = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pipe_num == INVALID_PIPE_NUM) {\n\t\t \n\t\tIA_CSS_ERROR(\"Max number of pipes already created\");\n\t\treturn -ENOSPC;\n\t}\n\n\tmy_css.pipe_counter++;\n\n\tIA_CSS_LOG(\"pipe_num (%d)\", pipe_num);\n\n\t*pipe_number = pipe_num;\n\treturn 0;\n}\n\nstatic void\npipe_release_pipe_num(unsigned int pipe_num)\n{\n\tmy_css.all_pipes[pipe_num] = NULL;\n\tmy_css.pipe_counter--;\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"pipe_release_pipe_num (%d)\\n\", pipe_num);\n}\n\nstatic int\ncreate_pipe(enum ia_css_pipe_mode mode,\n\t    struct ia_css_pipe **pipe,\n\t    bool copy_pipe)\n{\n\tint err = 0;\n\tstruct ia_css_pipe *me;\n\n\tif (!pipe) {\n\t\tIA_CSS_ERROR(\"NULL pipe parameter\");\n\t\treturn -EINVAL;\n\t}\n\n\tme = kmalloc(sizeof(*me), GFP_KERNEL);\n\tif (!me)\n\t\treturn -ENOMEM;\n\n\terr = init_pipe_defaults(mode, me, copy_pipe);\n\tif (err) {\n\t\tkfree(me);\n\t\treturn err;\n\t}\n\n\terr = pipe_generate_pipe_num(me, &me->pipe_num);\n\tif (err) {\n\t\tkfree(me);\n\t\treturn err;\n\t}\n\n\t*pipe = me;\n\treturn 0;\n}\n\nstruct ia_css_pipe *\nfind_pipe_by_num(uint32_t pipe_num)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < IA_CSS_PIPELINE_NUM_MAX; i++) {\n\t\tif (my_css.all_pipes[i] &&\n\t\t    ia_css_pipe_get_pipe_num(my_css.all_pipes[i]) == pipe_num) {\n\t\t\treturn my_css.all_pipes[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint\nia_css_pipe_destroy(struct ia_css_pipe *pipe)\n{\n\tint err = 0;\n\n\tIA_CSS_ENTER(\"pipe = %p\", pipe);\n\n\tif (!pipe) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pipe->stream) {\n\t\tIA_CSS_LOG(\"ia_css_stream_destroy not called!\");\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (pipe->config.mode) {\n\tcase IA_CSS_PIPE_MODE_PREVIEW:\n\t\t \n\t\tif (pipe->mode == IA_CSS_PIPE_ID_PREVIEW) {\n\t\t\tia_css_frame_free_multiple(NUM_CONTINUOUS_FRAMES,\n\t\t\t\t\t\t   pipe->continuous_frames);\n\t\t\tia_css_metadata_free_multiple(NUM_CONTINUOUS_FRAMES,\n\t\t\t\t\t\t      pipe->cont_md_buffers);\n\t\t\tif (pipe->pipe_settings.preview.copy_pipe) {\n\t\t\t\terr = ia_css_pipe_destroy(pipe->pipe_settings.preview.copy_pipe);\n\t\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t\t    \"ia_css_pipe_destroy(): destroyed internal copy pipe err=%d\\n\",\n\t\t\t\t\t\t    err);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IA_CSS_PIPE_MODE_VIDEO:\n\t\tif (pipe->mode == IA_CSS_PIPE_ID_VIDEO) {\n\t\t\tia_css_frame_free_multiple(NUM_CONTINUOUS_FRAMES,\n\t\t\t\t\t\t   pipe->continuous_frames);\n\t\t\tia_css_metadata_free_multiple(NUM_CONTINUOUS_FRAMES,\n\t\t\t\t\t\t      pipe->cont_md_buffers);\n\t\t\tif (pipe->pipe_settings.video.copy_pipe) {\n\t\t\t\terr = ia_css_pipe_destroy(pipe->pipe_settings.video.copy_pipe);\n\t\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t\t    \"ia_css_pipe_destroy(): destroyed internal copy pipe err=%d\\n\",\n\t\t\t\t\t\t    err);\n\t\t\t}\n\t\t}\n\t\tia_css_frame_free_multiple(NUM_VIDEO_TNR_FRAMES,\n\t\t\t\t\t   pipe->pipe_settings.video.tnr_frames);\n\t\tia_css_frame_free_multiple(MAX_NUM_VIDEO_DELAY_FRAMES,\n\t\t\t\t\t   pipe->pipe_settings.video.delay_frames);\n\t\tbreak;\n\tcase IA_CSS_PIPE_MODE_CAPTURE:\n\t\tia_css_frame_free_multiple(MAX_NUM_VIDEO_DELAY_FRAMES,\n\t\t\t\t\t   pipe->pipe_settings.capture.delay_frames);\n\t\tbreak;\n\tcase IA_CSS_PIPE_MODE_COPY:\n\t\tbreak;\n\tcase IA_CSS_PIPE_MODE_YUVPP:\n\t\tbreak;\n\t}\n\n\tif (pipe->scaler_pp_lut != mmgr_NULL) {\n\t\thmm_free(pipe->scaler_pp_lut);\n\t\tpipe->scaler_pp_lut = mmgr_NULL;\n\t}\n\n\tmy_css.active_pipes[ia_css_pipe_get_pipe_num(pipe)] = NULL;\n\tsh_css_pipe_free_shading_table(pipe);\n\n\tia_css_pipeline_destroy(&pipe->pipeline);\n\tpipe_release_pipe_num(ia_css_pipe_get_pipe_num(pipe));\n\n\tkfree(pipe);\n\tIA_CSS_LEAVE(\"err = %d\", err);\n\treturn err;\n}\n\nvoid\nia_css_uninit(void)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_uninit() enter: void\\n\");\n\n\tsh_css_params_free_default_gdc_lut();\n\n\t \n\tif (!mipi_is_free())\n\t\tdev_warn(atomisp_dev, \"mipi frames are not freed.\\n\");\n\n\t \n\tsh_css_params_uninit();\n\tia_css_refcount_uninit();\n\n\tia_css_rmgr_uninit();\n\n#if !defined(ISP2401)\n\t \n\tifmtr_set_if_blocking_mode_reset = true;\n#endif\n\n\tif (!fw_explicitly_loaded)\n\t\tia_css_unload_firmware();\n\n\tia_css_spctrl_unload_fw(SP0_ID);\n\tsh_css_sp_set_sp_running(false);\n\t \n\tfree_mipi_frames(NULL);\n\n\tsh_css_sp_reset_global_vars();\n\n\tia_css_isys_uninit();\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_uninit() leave: return_void\\n\");\n}\n\nint ia_css_irq_translate(\n    unsigned int *irq_infos)\n{\n\tenum virq_id\tirq;\n\tenum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_more_irqs;\n\tunsigned int infos = 0;\n\n\t \n\t \n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_irq_translate() enter: irq_infos=%p\\n\", irq_infos);\n\n\twhile (status == hrt_isp_css_irq_status_more_irqs) {\n\t\tstatus = virq_get_channel_id(&irq);\n\t\tif (status == hrt_isp_css_irq_status_error)\n\t\t\treturn -EINVAL;\n\n\n\t\tswitch (irq) {\n\t\tcase virq_sp:\n\t\t\t \n\t\t\tinfos |= IA_CSS_IRQ_INFO_EVENTS_READY;\n\t\t\tbreak;\n\t\tcase virq_isp:\n\t\t\tbreak;\n\t\tcase virq_isys_sof:\n\t\t\tinfos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF;\n\t\t\tbreak;\n\t\tcase virq_isys_eof:\n\t\t\tinfos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF;\n\t\t\tbreak;\n\t\tcase virq_isys_csi:\n\t\t\tinfos |= IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR;\n\t\t\tbreak;\n\t\tcase virq_ifmt0_id:\n\t\t\tif (!IS_ISP2401)\n\t\t\t\tinfos |= IA_CSS_IRQ_INFO_IF_ERROR;\n\t\t\tbreak;\n\t\tcase virq_dma:\n\t\t\tinfos |= IA_CSS_IRQ_INFO_DMA_ERROR;\n\t\t\tbreak;\n\t\tcase virq_sw_pin_0:\n\t\t\tinfos |= sh_css_get_sw_interrupt_value(0);\n\t\t\tbreak;\n\t\tcase virq_sw_pin_1:\n\t\t\tinfos |= sh_css_get_sw_interrupt_value(1);\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (irq_infos)\n\t\t*irq_infos = infos;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_irq_translate() leave: irq_infos=%u\\n\",\n\t\t\t    infos);\n\n\treturn 0;\n}\n\nint ia_css_irq_enable(\n    enum ia_css_irq_info info,\n    bool enable)\n{\n\tenum virq_id\tirq = N_virq_id;\n\n\tIA_CSS_ENTER(\"info=%d, enable=%d\", info, enable);\n\n\tswitch (info) {\n\tcase IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF:\n\t\tif (IS_ISP2401)\n\t\t\t \n\t\t\treturn 0;\n\n\t\tirq = virq_isys_sof;\n\t\tbreak;\n\tcase IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF:\n\t\tif (IS_ISP2401)\n\t\t\t \n\t\t\treturn 0;\n\n\t\tirq = virq_isys_eof;\n\t\tbreak;\n\tcase IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR:\n\t\tif (IS_ISP2401)\n\t\t\t \n\t\t\treturn 0;\n\n\t\tirq = virq_isys_csi;\n\t\tbreak;\n\tcase IA_CSS_IRQ_INFO_IF_ERROR:\n\t\tif (IS_ISP2401)\n\t\t\t \n\t\t\treturn 0;\n\n\t\tirq = virq_ifmt0_id;\n\t\tbreak;\n\tcase IA_CSS_IRQ_INFO_DMA_ERROR:\n\t\tirq = virq_dma;\n\t\tbreak;\n\tcase IA_CSS_IRQ_INFO_SW_0:\n\t\tirq = virq_sw_pin_0;\n\t\tbreak;\n\tcase IA_CSS_IRQ_INFO_SW_1:\n\t\tirq = virq_sw_pin_1;\n\t\tbreak;\n\tdefault:\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tcnd_virq_enable_channel(irq, enable);\n\n\tIA_CSS_LEAVE_ERR(0);\n\treturn 0;\n}\n\n\nstatic unsigned int\nsh_css_get_sw_interrupt_value(unsigned int irq)\n{\n\tunsigned int irq_value;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"sh_css_get_sw_interrupt_value() enter: irq=%d\\n\", irq);\n\tirq_value = sh_css_sp_get_sw_interrupt_value(irq);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"sh_css_get_sw_interrupt_value() leave: irq_value=%d\\n\", irq_value);\n\treturn irq_value;\n}\n\n \nstatic int load_copy_binary(\n    struct ia_css_pipe *pipe,\n    struct ia_css_binary *copy_binary,\n    struct ia_css_binary *next_binary)\n{\n\tstruct ia_css_frame_info copy_out_info, copy_in_info, copy_vf_info;\n\tunsigned int left_padding;\n\tint err;\n\tstruct ia_css_binary_descr copy_descr;\n\n\t \n\tassert(pipe);\n\tassert(copy_binary);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"load_copy_binary() enter:\\n\");\n\n\tif (next_binary) {\n\t\tcopy_out_info = next_binary->in_frame_info;\n\t\tleft_padding = next_binary->left_padding;\n\t} else {\n\t\tcopy_out_info = pipe->output_info[0];\n\t\tcopy_vf_info = pipe->vf_output_info[0];\n\t\tia_css_frame_info_set_format(&copy_vf_info, IA_CSS_FRAME_FORMAT_YUV_LINE);\n\t\tleft_padding = 0;\n\t}\n\n\tia_css_pipe_get_copy_binarydesc(pipe, &copy_descr,\n\t\t\t\t\t&copy_in_info, &copy_out_info,\n\t\t\t\t\t(next_binary) ? NULL : NULL );\n\terr = ia_css_binary_find(&copy_descr, copy_binary);\n\tif (err)\n\t\treturn err;\n\tcopy_binary->left_padding = left_padding;\n\treturn 0;\n}\n\nstatic int\nalloc_continuous_frames(struct ia_css_pipe *pipe, bool init_time)\n{\n\tint err = 0;\n\tstruct ia_css_frame_info ref_info;\n\tenum ia_css_pipe_id pipe_id;\n\tbool continuous;\n\tunsigned int i, idx;\n\tunsigned int num_frames;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p, init_time = %d\", pipe, init_time);\n\n\tif ((!pipe) || (!pipe->stream)) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tpipe_id = pipe->mode;\n\tcontinuous = pipe->stream->config.continuous;\n\n\tif (continuous) {\n\t\tif (init_time) {\n\t\t\tnum_frames = pipe->stream->config.init_num_cont_raw_buf;\n\t\t\tpipe->stream->continuous_pipe = pipe;\n\t\t} else {\n\t\t\tnum_frames = pipe->stream->config.target_num_cont_raw_buf;\n\t\t}\n\t} else {\n\t\tnum_frames = NUM_ONLINE_INIT_CONTINUOUS_FRAMES;\n\t}\n\n\tif (pipe_id == IA_CSS_PIPE_ID_PREVIEW) {\n\t\tref_info = pipe->pipe_settings.preview.preview_binary.in_frame_info;\n\t} else if (pipe_id == IA_CSS_PIPE_ID_VIDEO) {\n\t\tref_info = pipe->pipe_settings.video.video_binary.in_frame_info;\n\t} else {\n\t\t \n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ISP2401) {\n\t\t \n\t\tref_info.res.width = pipe->stream->config.input_config.input_res.width;\n\t\tref_info.res.height = pipe->stream->config.input_config.input_res.height;\n\n\t\t \n\t\tref_info.padded_width = CEIL_MUL(ref_info.res.width, 2 * ISP_VEC_NELEMS);\n\t}\n\n\tif (pipe->stream->config.pack_raw_pixels) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t\t    \"alloc_continuous_frames() IA_CSS_FRAME_FORMAT_RAW_PACKED\\n\");\n\t\tref_info.format = IA_CSS_FRAME_FORMAT_RAW_PACKED;\n\t} else\n\t{\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t\t    \"alloc_continuous_frames() IA_CSS_FRAME_FORMAT_RAW\\n\");\n\t\tref_info.format = IA_CSS_FRAME_FORMAT_RAW;\n\t}\n\n\t \n\tif (pipe_id == IA_CSS_PIPE_ID_PREVIEW) {\n\t\tpipe->pipe_settings.preview.preview_binary.in_frame_info.format =\n\t\t    ref_info.format;\n\t} else if (pipe_id == IA_CSS_PIPE_ID_VIDEO) {\n\t\tpipe->pipe_settings.video.video_binary.in_frame_info.format = ref_info.format;\n\t} else {\n\t\t \n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tif (init_time)\n\t\tidx = 0;\n\telse\n\t\tidx = pipe->stream->config.init_num_cont_raw_buf;\n\n\tfor (i = idx; i < NUM_CONTINUOUS_FRAMES; i++) {\n\t\t \n\t\tif (pipe->continuous_frames[i]) {\n\t\t\tia_css_frame_free(pipe->continuous_frames[i]);\n\t\t\tpipe->continuous_frames[i] = NULL;\n\t\t}\n\t\t \n\t\tia_css_metadata_free(pipe->cont_md_buffers[i]);\n\t\tpipe->cont_md_buffers[i] = NULL;\n\n\t\t \n\t\tif (i < num_frames) {\n\t\t\t \n\t\t\terr = ia_css_frame_allocate_from_info(\n\t\t\t\t  &pipe->continuous_frames[i],\n\t\t\t\t  &ref_info);\n\t\t\tif (err) {\n\t\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\t \n\t\t\tpipe->cont_md_buffers[i] = ia_css_metadata_allocate(\n\t\t\t\t\t\t       &pipe->stream->info.metadata_info);\n\t\t}\n\t}\n\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\treturn 0;\n}\n\nint\nia_css_alloc_continuous_frame_remain(struct ia_css_stream *stream)\n{\n\tif (!stream)\n\t\treturn -EINVAL;\n\treturn alloc_continuous_frames(stream->continuous_pipe, false);\n}\n\nstatic int\nload_preview_binaries(struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_frame_info prev_in_info,\n\t\tprev_bds_out_info,\n\t\tprev_out_info,\n\t\tprev_vf_info;\n\tstruct ia_css_binary_descr preview_descr;\n\tbool online;\n\tint err = 0;\n\tbool need_vf_pp = false;\n\tbool need_isp_copy_binary = false;\n\tbool sensor = false;\n\tbool continuous;\n\n\t \n\tstruct ia_css_frame_info *pipe_out_info = &pipe->output_info[0];\n\tstruct ia_css_preview_settings *mycs  = &pipe->pipe_settings.preview;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\tassert(pipe);\n\tassert(pipe->stream);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_PREVIEW);\n\n\tonline = pipe->stream->config.online;\n\n\tsensor = pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR;\n\tcontinuous = pipe->stream->config.continuous;\n\n\tif (mycs->preview_binary.info)\n\t\treturn 0;\n\n\terr = ia_css_util_check_input(&pipe->stream->config, false, false);\n\tif (err)\n\t\treturn err;\n\terr = ia_css_frame_check_info(pipe_out_info);\n\tif (err)\n\t\treturn err;\n\n\t \n\tneed_vf_pp = pipe->config.enable_dz;\n\tneed_vf_pp |= pipe_out_info->format != IA_CSS_FRAME_FORMAT_YUV_LINE &&\n\t!(pipe_out_info->format == IA_CSS_FRAME_FORMAT_NV12 ||\n\t  pipe_out_info->format == IA_CSS_FRAME_FORMAT_NV12_16 ||\n\t  pipe_out_info->format == IA_CSS_FRAME_FORMAT_NV12_TILEY);\n\n\t \n\tif (pipe->vf_yuv_ds_input_info.res.width)\n\t\tprev_vf_info = pipe->vf_yuv_ds_input_info;\n\telse\n\t\tprev_vf_info = *pipe_out_info;\n\t \n\tif (need_vf_pp)\n\t\tia_css_frame_info_set_format(&prev_vf_info,\n\t\t\t\t\t     IA_CSS_FRAME_FORMAT_YUV_LINE);\n\n\terr = ia_css_pipe_get_preview_binarydesc(\n\t    pipe,\n\t    &preview_descr,\n\t    &prev_in_info,\n\t    &prev_bds_out_info,\n\t    &prev_out_info,\n\t    &prev_vf_info);\n\tif (err)\n\t\treturn err;\n\terr = ia_css_binary_find(&preview_descr, &mycs->preview_binary);\n\tif (err)\n\t\treturn err;\n\n\t \n\tneed_vf_pp |= mycs->preview_binary.out_frame_info[0].res.width != pipe_out_info->res.width;\n\tneed_vf_pp |= mycs->preview_binary.out_frame_info[0].res.height != pipe_out_info->res.height;\n\n\t \n\tif (need_vf_pp &&\n\t    (mycs->preview_binary.out_frame_info[0].format != IA_CSS_FRAME_FORMAT_YUV_LINE)) {\n\t\t \n\t\tif (pipe->vf_yuv_ds_input_info.res.width)\n\t\t\tprev_vf_info = pipe->vf_yuv_ds_input_info;\n\t\telse\n\t\t\tprev_vf_info = *pipe_out_info;\n\n\t\tia_css_frame_info_set_format(&prev_vf_info,\n\t\t\t\t\t     IA_CSS_FRAME_FORMAT_YUV_LINE);\n\n\t\terr = ia_css_pipe_get_preview_binarydesc(\n\t\t    pipe,\n\t\t    &preview_descr,\n\t\t    &prev_in_info,\n\t\t    &prev_bds_out_info,\n\t\t    &prev_out_info,\n\t\t    &prev_vf_info);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = ia_css_binary_find(&preview_descr,\n\t\t\t\t\t &mycs->preview_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (need_vf_pp) {\n\t\tstruct ia_css_binary_descr vf_pp_descr;\n\n\t\t \n\t\tia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,\n\t\t\t\t\t\t&mycs->preview_binary.out_frame_info[0],\n\t\t\t\t\t\tpipe_out_info);\n\t\terr = ia_css_binary_find(&vf_pp_descr,\n\t\t\t\t\t &mycs->vf_pp_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (IS_ISP2401) {\n\t\t \n\t\tneed_isp_copy_binary = !online && sensor;\n\t} else {\n\t\t \n\t\tneed_isp_copy_binary = !online && !continuous;\n\t}\n\n\t \n\tif (need_isp_copy_binary) {\n\t\terr = load_copy_binary(pipe,\n\t\t\t\t       &mycs->copy_binary,\n\t\t\t\t       &mycs->preview_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (pipe->shading_table) {\n\t\tia_css_shading_table_free(pipe->shading_table);\n\t\tpipe->shading_table = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nia_css_binary_unload(struct ia_css_binary *binary)\n{\n\tia_css_binary_destroy_isp_parameters(binary);\n}\n\nstatic int\nunload_preview_binaries(struct ia_css_pipe *pipe)\n{\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p\", pipe);\n\n\tif ((!pipe) || (pipe->mode != IA_CSS_PIPE_ID_PREVIEW)) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\tia_css_binary_unload(&pipe->pipe_settings.preview.copy_binary);\n\tia_css_binary_unload(&pipe->pipe_settings.preview.preview_binary);\n\tia_css_binary_unload(&pipe->pipe_settings.preview.vf_pp_binary);\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\treturn 0;\n}\n\nstatic const struct ia_css_fw_info *last_output_firmware(\n    const struct ia_css_fw_info *fw)\n{\n\tconst struct ia_css_fw_info *last_fw = NULL;\n\t \n\tIA_CSS_ENTER_LEAVE_PRIVATE(\"\");\n\n\tfor (; fw; fw = fw->next) {\n\t\tconst struct ia_css_fw_info *info = fw;\n\n\t\tif (info->info.isp.sp.enable.output)\n\t\t\tlast_fw = fw;\n\t}\n\treturn last_fw;\n}\n\nstatic int add_firmwares(\n    struct ia_css_pipeline *me,\n    struct ia_css_binary *binary,\n    const struct ia_css_fw_info *fw,\n    const struct ia_css_fw_info *last_fw,\n    unsigned int binary_mode,\n    struct ia_css_frame *in_frame,\n    struct ia_css_frame *out_frame,\n    struct ia_css_frame *vf_frame,\n    struct ia_css_pipeline_stage **my_stage,\n    struct ia_css_pipeline_stage **vf_stage)\n{\n\tint err = 0;\n\tstruct ia_css_pipeline_stage *extra_stage = NULL;\n\tstruct ia_css_pipeline_stage_desc stage_desc;\n\n\t \n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"add_firmwares() enter:\\n\");\n\n\tfor (; fw; fw = fw->next) {\n\t\tstruct ia_css_frame *out[IA_CSS_BINARY_MAX_OUTPUT_PORTS] = {NULL};\n\t\tstruct ia_css_frame *in = NULL;\n\t\tstruct ia_css_frame *vf = NULL;\n\n\t\tif ((fw == last_fw) && (fw->info.isp.sp.enable.out_frame  != 0))\n\t\t\tout[0] = out_frame;\n\n\t\tif (fw->info.isp.sp.enable.in_frame != 0)\n\t\t\tin = in_frame;\n\n\t\tif (fw->info.isp.sp.enable.out_frame != 0)\n\t\t\tvf = vf_frame;\n\n\t\tia_css_pipe_get_firmwares_stage_desc(&stage_desc, binary,\n\t\t\t\t\t\t     out, in, vf, fw, binary_mode);\n\t\terr = ia_css_pipeline_create_and_add_stage(me, &stage_desc,\n\t\t\t\t\t\t\t   &extra_stage);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (fw->info.isp.sp.enable.output != 0)\n\t\t\tin_frame = extra_stage->args.out_frame[0];\n\t\tif (my_stage && !*my_stage && extra_stage)\n\t\t\t*my_stage = extra_stage;\n\t\tif (vf_stage && !*vf_stage && extra_stage &&\n\t\t    fw->info.isp.sp.enable.vf_veceven)\n\t\t\t*vf_stage = extra_stage;\n\t}\n\treturn err;\n}\n\nstatic int add_vf_pp_stage(\n    struct ia_css_pipe *pipe,\n    struct ia_css_frame *in_frame,\n    struct ia_css_frame *out_frame,\n    struct ia_css_binary *vf_pp_binary,\n    struct ia_css_pipeline_stage **vf_pp_stage)\n{\n\tstruct ia_css_pipeline *me = NULL;\n\tconst struct ia_css_fw_info *last_fw = NULL;\n\tint err = 0;\n\tstruct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];\n\tstruct ia_css_pipeline_stage_desc stage_desc;\n\n\t \n\n\tif (!pipe)\n\t\treturn -EINVAL;\n\tif (!in_frame)\n\t\treturn -EINVAL;\n\tif (!vf_pp_binary)\n\t\treturn -EINVAL;\n\tif (!vf_pp_stage)\n\t\treturn -EINVAL;\n\n\tia_css_pipe_util_create_output_frames(out_frames);\n\tme = &pipe->pipeline;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"add_vf_pp_stage() enter:\\n\");\n\n\t*vf_pp_stage = NULL;\n\n\tlast_fw = last_output_firmware(pipe->vf_stage);\n\tif (!pipe->extra_config.disable_vf_pp) {\n\t\tif (last_fw) {\n\t\t\tia_css_pipe_util_set_output_frames(out_frames, 0, NULL);\n\t\t\tia_css_pipe_get_generic_stage_desc(&stage_desc, vf_pp_binary,\n\t\t\t\t\t\t\t   out_frames, in_frame, NULL);\n\t\t} else {\n\t\t\tia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);\n\t\t\tia_css_pipe_get_generic_stage_desc(&stage_desc, vf_pp_binary,\n\t\t\t\t\t\t\t   out_frames, in_frame, NULL);\n\t\t}\n\t\terr = ia_css_pipeline_create_and_add_stage(me, &stage_desc, vf_pp_stage);\n\t\tif (err)\n\t\t\treturn err;\n\t\tin_frame = (*vf_pp_stage)->args.out_frame[0];\n\t}\n\terr = add_firmwares(me, vf_pp_binary, pipe->vf_stage, last_fw,\n\t\t\t    IA_CSS_BINARY_MODE_VF_PP,\n\t\t\t    in_frame, out_frame, NULL,\n\t\t\t    vf_pp_stage, NULL);\n\treturn err;\n}\n\nstatic int add_yuv_scaler_stage(\n    struct ia_css_pipe *pipe,\n    struct ia_css_pipeline *me,\n    struct ia_css_frame *in_frame,\n    struct ia_css_frame *out_frame,\n    struct ia_css_frame *internal_out_frame,\n    struct ia_css_binary *yuv_scaler_binary,\n    struct ia_css_pipeline_stage **pre_vf_pp_stage)\n{\n\tconst struct ia_css_fw_info *last_fw;\n\tint err = 0;\n\tstruct ia_css_frame *vf_frame = NULL;\n\tstruct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];\n\tstruct ia_css_pipeline_stage_desc stage_desc;\n\n\t \n\tassert(in_frame);\n\tassert(pipe);\n\tassert(me);\n\tassert(yuv_scaler_binary);\n\tassert(pre_vf_pp_stage);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"add_yuv_scaler_stage() enter:\\n\");\n\n\t*pre_vf_pp_stage = NULL;\n\tia_css_pipe_util_create_output_frames(out_frames);\n\n\tlast_fw = last_output_firmware(pipe->output_stage);\n\n\tif (last_fw) {\n\t\tia_css_pipe_util_set_output_frames(out_frames, 0, NULL);\n\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t   yuv_scaler_binary, out_frames, in_frame, vf_frame);\n\t} else {\n\t\tia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);\n\t\tia_css_pipe_util_set_output_frames(out_frames, 1, internal_out_frame);\n\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t   yuv_scaler_binary, out_frames, in_frame, vf_frame);\n\t}\n\terr = ia_css_pipeline_create_and_add_stage(me, &stage_desc,\n\t\t\t\t\t\t   pre_vf_pp_stage);\n\tif (err)\n\t\treturn err;\n\tin_frame = (*pre_vf_pp_stage)->args.out_frame[0];\n\n\terr = add_firmwares(me, yuv_scaler_binary, pipe->output_stage, last_fw,\n\t\t\t    IA_CSS_BINARY_MODE_CAPTURE_PP,\n\t\t\t    in_frame, out_frame, vf_frame,\n\t\t\t    NULL, pre_vf_pp_stage);\n\t \n\t(*pre_vf_pp_stage)->args.vf_downscale_log2 =\n\t    yuv_scaler_binary->vf_downscale_log2;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"add_yuv_scaler_stage() leave:\\n\");\n\treturn err;\n}\n\nstatic int add_capture_pp_stage(\n    struct ia_css_pipe *pipe,\n    struct ia_css_pipeline *me,\n    struct ia_css_frame *in_frame,\n    struct ia_css_frame *out_frame,\n    struct ia_css_binary *capture_pp_binary,\n    struct ia_css_pipeline_stage **capture_pp_stage)\n{\n\tconst struct ia_css_fw_info *last_fw = NULL;\n\tint err = 0;\n\tstruct ia_css_frame *vf_frame = NULL;\n\tstruct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];\n\tstruct ia_css_pipeline_stage_desc stage_desc;\n\n\t \n\tassert(in_frame);\n\tassert(pipe);\n\tassert(me);\n\tassert(capture_pp_binary);\n\tassert(capture_pp_stage);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"add_capture_pp_stage() enter:\\n\");\n\n\t*capture_pp_stage = NULL;\n\tia_css_pipe_util_create_output_frames(out_frames);\n\n\tlast_fw = last_output_firmware(pipe->output_stage);\n\terr = ia_css_frame_allocate_from_info(&vf_frame,\n\t\t\t\t\t      &capture_pp_binary->vf_frame_info);\n\tif (err)\n\t\treturn err;\n\tif (last_fw)\t{\n\t\tia_css_pipe_util_set_output_frames(out_frames, 0, NULL);\n\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t   capture_pp_binary, out_frames, NULL, vf_frame);\n\t} else {\n\t\tia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);\n\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t   capture_pp_binary, out_frames, NULL, vf_frame);\n\t}\n\terr = ia_css_pipeline_create_and_add_stage(me, &stage_desc,\n\t\t\t\t\t\t   capture_pp_stage);\n\tif (err)\n\t\treturn err;\n\terr = add_firmwares(me, capture_pp_binary, pipe->output_stage, last_fw,\n\t\t\t    IA_CSS_BINARY_MODE_CAPTURE_PP,\n\t\t\t    in_frame, out_frame, vf_frame,\n\t\t\t    NULL, capture_pp_stage);\n\t \n\tif (*capture_pp_stage) {\n\t\t(*capture_pp_stage)->args.vf_downscale_log2 =\n\t\t    capture_pp_binary->vf_downscale_log2;\n\t}\n\treturn err;\n}\n\nstatic void sh_css_setup_queues(void)\n{\n\tconst struct ia_css_fw_info *fw;\n\tunsigned int HIVE_ADDR_host_sp_queues_initialized;\n\n\tsh_css_hmm_buffer_record_init();\n\n\tsh_css_event_init_irq_mask();\n\n\tfw = &sh_css_sp_fw;\n\tHIVE_ADDR_host_sp_queues_initialized =\n\t    fw->info.sp.host_sp_queues_initialized;\n\n\tia_css_bufq_init();\n\n\t \n\tsp_dmem_store_uint32(SP0_ID,\n\t\t\t     (unsigned int)sp_address_of(host_sp_queues_initialized),\n\t\t\t     (uint32_t)(1));\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"sh_css_setup_queues() leave:\\n\");\n}\n\nstatic int\ninit_vf_frameinfo_defaults(struct ia_css_pipe *pipe,\n\t\t\t   struct ia_css_frame *vf_frame, unsigned int idx)\n{\n\tint err = 0;\n\tunsigned int thread_id;\n\tenum sh_css_queue_id queue_id;\n\n\tassert(vf_frame);\n\n\tsh_css_pipe_get_viewfinder_frame_info(pipe, &vf_frame->frame_info, idx);\n\tvf_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;\n\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);\n\tia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME + idx, thread_id, &queue_id);\n\tvf_frame->dynamic_queue_id = queue_id;\n\tvf_frame->buf_type = IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME + idx;\n\n\terr = ia_css_frame_init_planes(vf_frame);\n\treturn err;\n}\n\n#ifdef ISP2401\nstatic unsigned int\nget_crop_lines_for_bayer_order(const struct ia_css_stream_config *config)\n{\n\tassert(config);\n\tif ((config->input_config.bayer_order == IA_CSS_BAYER_ORDER_BGGR) ||\n\t    (config->input_config.bayer_order == IA_CSS_BAYER_ORDER_GBRG))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic unsigned int\nget_crop_columns_for_bayer_order(const struct ia_css_stream_config *config)\n{\n\tassert(config);\n\tif ((config->input_config.bayer_order == IA_CSS_BAYER_ORDER_RGGB) ||\n\t    (config->input_config.bayer_order == IA_CSS_BAYER_ORDER_GBRG))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic void get_pipe_extra_pixel(struct ia_css_pipe *pipe,\n\t\t\t\t unsigned int *extra_row, unsigned int *extra_column)\n{\n\tenum ia_css_pipe_id pipe_id = pipe->mode;\n\tunsigned int left_cropping = 0, top_cropping = 0;\n\tunsigned int i;\n\tstruct ia_css_resolution dvs_env = pipe->config.dvs_envelope;\n\n\t \n\tswitch (pipe_id) {\n\tcase IA_CSS_PIPE_ID_PREVIEW:\n\t\tif (pipe->pipe_settings.preview.preview_binary.info) {\n\t\t\tleft_cropping =\n\t\t\t    pipe->pipe_settings.preview.preview_binary.info->sp.pipeline.left_cropping;\n\t\t\ttop_cropping =\n\t\t\t    pipe->pipe_settings.preview.preview_binary.info->sp.pipeline.top_cropping;\n\t\t}\n\t\tdvs_env = pipe->pipe_settings.preview.preview_binary.dvs_envelope;\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_VIDEO:\n\t\tif (pipe->pipe_settings.video.video_binary.info) {\n\t\t\tleft_cropping =\n\t\t\t    pipe->pipe_settings.video.video_binary.info->sp.pipeline.left_cropping;\n\t\t\ttop_cropping =\n\t\t\t    pipe->pipe_settings.video.video_binary.info->sp.pipeline.top_cropping;\n\t\t}\n\t\tdvs_env = pipe->pipe_settings.video.video_binary.dvs_envelope;\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_CAPTURE:\n\t\tfor (i = 0; i < pipe->pipe_settings.capture.num_primary_stage; i++) {\n\t\t\tif (pipe->pipe_settings.capture.primary_binary[i].info) {\n\t\t\t\tleft_cropping +=\n\t\t\t\t    pipe->pipe_settings.capture.primary_binary[i].info->sp.pipeline.left_cropping;\n\t\t\t\ttop_cropping +=\n\t\t\t\t    pipe->pipe_settings.capture.primary_binary[i].info->sp.pipeline.top_cropping;\n\t\t\t}\n\t\t\tdvs_env.width +=\n\t\t\t    pipe->pipe_settings.capture.primary_binary[i].dvs_envelope.width;\n\t\t\tdvs_env.height +=\n\t\t\t    pipe->pipe_settings.capture.primary_binary[i].dvs_envelope.height;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t*extra_row = top_cropping + dvs_env.height;\n\t*extra_column = left_cropping + dvs_env.width;\n}\n\nvoid\nia_css_get_crop_offsets(\n    struct ia_css_pipe *pipe,\n    struct ia_css_frame_info *in_frame)\n{\n\tunsigned int row = 0;\n\tunsigned int column = 0;\n\tstruct ia_css_resolution *input_res;\n\tstruct ia_css_resolution *effective_res;\n\tunsigned int extra_row = 0, extra_col = 0;\n\tunsigned int min_reqd_height, min_reqd_width;\n\n\tassert(pipe);\n\tassert(pipe->stream);\n\tassert(in_frame);\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p effective_wd = %u effective_ht = %u\",\n\t\t\t     pipe, pipe->config.input_effective_res.width,\n\t\t\t     pipe->config.input_effective_res.height);\n\n\tinput_res = &pipe->stream->config.input_config.input_res;\n#ifndef ISP2401\n\teffective_res = &pipe->stream->config.input_config.effective_res;\n#else\n\teffective_res = &pipe->config.input_effective_res;\n#endif\n\n\tget_pipe_extra_pixel(pipe, &extra_row, &extra_col);\n\n\tin_frame->raw_bayer_order = pipe->stream->config.input_config.bayer_order;\n\n\tmin_reqd_height = effective_res->height + extra_row;\n\tmin_reqd_width = effective_res->width + extra_col;\n\n\tif (input_res->height > min_reqd_height) {\n\t\trow = (input_res->height - min_reqd_height) / 2;\n\t\trow &= ~0x1;\n\t}\n\tif (input_res->width > min_reqd_width) {\n\t\tcolumn = (input_res->width - min_reqd_width) / 2;\n\t\tcolumn &= ~0x1;\n\t}\n\n\t \n\n\t \n\tcolumn += get_crop_columns_for_bayer_order(&pipe->stream->config);\n\trow += get_crop_lines_for_bayer_order(&pipe->stream->config);\n\n\tin_frame->crop_info.start_column = column;\n\tin_frame->crop_info.start_line = row;\n\n\tIA_CSS_LEAVE_PRIVATE(\"void start_col: %u start_row: %u\", column, row);\n\n\treturn;\n}\n#endif\n\nstatic int\ninit_in_frameinfo_memory_defaults(struct ia_css_pipe *pipe,\n\t\t\t\t  struct ia_css_frame *frame, enum ia_css_frame_format format)\n{\n\tstruct ia_css_frame *in_frame;\n\tint err = 0;\n\tunsigned int thread_id;\n\tenum sh_css_queue_id queue_id;\n\n\tassert(frame);\n\tin_frame = frame;\n\n\tin_frame->frame_info.format = format;\n\n\tif (IS_ISP2401 && format == IA_CSS_FRAME_FORMAT_RAW) {\n\t\tin_frame->frame_info.format = (pipe->stream->config.pack_raw_pixels) ?\n\t\tIA_CSS_FRAME_FORMAT_RAW_PACKED : IA_CSS_FRAME_FORMAT_RAW;\n\t}\n\n\tin_frame->frame_info.res.width = pipe->stream->config.input_config.input_res.width;\n\tin_frame->frame_info.res.height = pipe->stream->config.input_config.input_res.height;\n\tin_frame->frame_info.raw_bit_depth = ia_css_pipe_util_pipe_input_format_bpp(pipe);\n\tia_css_frame_info_set_width(&in_frame->frame_info,\n\t\t\t\t    pipe->stream->config.input_config.input_res.width, 0);\n\tin_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;\n\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);\n\tia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_INPUT_FRAME, thread_id, &queue_id);\n\tin_frame->dynamic_queue_id = queue_id;\n\tin_frame->buf_type = IA_CSS_BUFFER_TYPE_INPUT_FRAME;\n#ifdef ISP2401\n\tia_css_get_crop_offsets(pipe, &in_frame->frame_info);\n#endif\n\terr = ia_css_frame_init_planes(in_frame);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, \"%s() bayer_order = %d\\n\",\n\t\t\t    __func__, in_frame->frame_info.raw_bayer_order);\n\n\treturn err;\n}\n\nstatic int\ninit_out_frameinfo_defaults(struct ia_css_pipe *pipe,\n\t\t\t    struct ia_css_frame *out_frame, unsigned int idx)\n{\n\tint err = 0;\n\tunsigned int thread_id;\n\tenum sh_css_queue_id queue_id;\n\n\tassert(out_frame);\n\n\tsh_css_pipe_get_output_frame_info(pipe, &out_frame->frame_info, idx);\n\tout_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;\n\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);\n\tia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_OUTPUT_FRAME + idx, thread_id, &queue_id);\n\tout_frame->dynamic_queue_id = queue_id;\n\tout_frame->buf_type = IA_CSS_BUFFER_TYPE_OUTPUT_FRAME + idx;\n\terr = ia_css_frame_init_planes(out_frame);\n\n\treturn err;\n}\n\n \nstatic int create_host_video_pipeline(struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_pipeline_stage_desc stage_desc;\n\tstruct ia_css_binary *copy_binary, *video_binary,\n\t\t       *yuv_scaler_binary, *vf_pp_binary;\n\tstruct ia_css_pipeline_stage *copy_stage  = NULL;\n\tstruct ia_css_pipeline_stage *video_stage = NULL;\n\tstruct ia_css_pipeline_stage *yuv_scaler_stage  = NULL;\n\tstruct ia_css_pipeline_stage *vf_pp_stage = NULL;\n\tstruct ia_css_pipeline *me;\n\tstruct ia_css_frame *in_frame = NULL;\n\tstruct ia_css_frame *out_frame;\n\tstruct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];\n\tstruct ia_css_frame *vf_frame = NULL;\n\tint err = 0;\n\tbool need_copy   = false;\n\tbool need_vf_pp  = false;\n\tbool need_yuv_pp = false;\n\tbool need_in_frameinfo_memory = false;\n\n\tunsigned int i, num_yuv_scaler;\n\tbool *is_output_stage = NULL;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p\", pipe);\n\tif ((!pipe) || (!pipe->stream) || (pipe->mode != IA_CSS_PIPE_ID_VIDEO)) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\tia_css_pipe_util_create_output_frames(out_frames);\n\tout_frame = &pipe->out_frame_struct;\n\n\t \n\tme = &pipe->pipeline;\n\tia_css_pipeline_clean(me);\n\n\tme->dvs_frame_delay = pipe->dvs_frame_delay;\n\n\tif (IS_ISP2401) {\n\t\t \n\t\tneed_in_frameinfo_memory = !(pipe->stream->config.online ||\n\t\t\t\t\t     pipe->stream->config.continuous);\n\t} else {\n\t\t \n\t\tneed_in_frameinfo_memory = pipe->stream->config.mode ==\n\t\t\t\t\t   IA_CSS_INPUT_MODE_MEMORY;\n\t}\n\n\t \n\tif (need_in_frameinfo_memory) {\n\t\tin_frame = &pipe->in_frame_struct;\n\t\terr = init_in_frameinfo_memory_defaults(pipe, in_frame,\n\t\t\t\t\t\t\tIA_CSS_FRAME_FORMAT_RAW);\n\t\tif (err)\n\t\t\tgoto ERR;\n\t}\n\n\tout_frame->data = 0;\n\terr = init_out_frameinfo_defaults(pipe, out_frame, 0);\n\tif (err)\n\t\tgoto ERR;\n\n\tif (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0]) {\n\t\tvf_frame = &pipe->vf_frame_struct;\n\t\tvf_frame->data = 0;\n\t\terr = init_vf_frameinfo_defaults(pipe, vf_frame, 0);\n\t\tif (err)\n\t\t\tgoto ERR;\n\t}\n\n\tcopy_binary  = &pipe->pipe_settings.video.copy_binary;\n\tvideo_binary = &pipe->pipe_settings.video.video_binary;\n\tvf_pp_binary = &pipe->pipe_settings.video.vf_pp_binary;\n\n\tyuv_scaler_binary = pipe->pipe_settings.video.yuv_scaler_binary;\n\tnum_yuv_scaler  = pipe->pipe_settings.video.num_yuv_scaler;\n\tis_output_stage = pipe->pipe_settings.video.is_output_stage;\n\n\tneed_copy   = (copy_binary && copy_binary->info);\n\tneed_vf_pp  = (vf_pp_binary && vf_pp_binary->info);\n\tneed_yuv_pp = (yuv_scaler_binary && yuv_scaler_binary->info);\n\n\tif (need_copy) {\n\t\tia_css_pipe_util_set_output_frames(out_frames, 0, NULL);\n\t\tia_css_pipe_get_generic_stage_desc(&stage_desc, copy_binary,\n\t\t\t\t\t\t   out_frames, NULL, NULL);\n\t\terr = ia_css_pipeline_create_and_add_stage(me, &stage_desc,\n\t\t\t\t\t\t\t   &copy_stage);\n\t\tif (err)\n\t\t\tgoto ERR;\n\t\tin_frame = me->stages->args.out_frame[0];\n\t} else if (pipe->stream->config.continuous) {\n\t\tif (IS_ISP2401)\n\t\t\t \n\t\t\tin_frame = pipe->stream->last_pipe->continuous_frames[0];\n\t\telse\n\t\t\tin_frame = pipe->continuous_frames[0];\n\t}\n\n\tia_css_pipe_util_set_output_frames(out_frames, 0,\n\t\t\t\t\t   need_yuv_pp ? NULL : out_frame);\n\n\t \n\tif (need_vf_pp) {\n\t\tia_css_pipe_get_generic_stage_desc(&stage_desc, video_binary,\n\t\t\t\t\t\t   out_frames, in_frame, NULL);\n\t} else {\n\t\tia_css_pipe_get_generic_stage_desc(&stage_desc, video_binary,\n\t\t\t\t\t\t   out_frames, in_frame, vf_frame);\n\t}\n\terr = ia_css_pipeline_create_and_add_stage(me, &stage_desc,\n\t\t\t\t\t\t   &video_stage);\n\tif (err)\n\t\tgoto ERR;\n\n\t \n\tif (video_stage) {\n\t\tvideo_stage->args.copy_vf =\n\t\t    video_binary->info->sp.pipeline.mode == IA_CSS_BINARY_MODE_COPY;\n\t\tvideo_stage->args.copy_output = video_stage->args.copy_vf;\n\t}\n\n\t \n\tif (need_vf_pp && video_stage) {\n\t\tin_frame = video_stage->args.out_vf_frame;\n\t\terr = add_vf_pp_stage(pipe, in_frame, vf_frame, vf_pp_binary,\n\t\t\t\t      &vf_pp_stage);\n\t\tif (err)\n\t\t\tgoto ERR;\n\t}\n\tif (video_stage) {\n\t\tint frm;\n\n\t\tfor (frm = 0; frm < NUM_VIDEO_TNR_FRAMES; frm++) {\n\t\t\tvideo_stage->args.tnr_frames[frm] =\n\t\t\t    pipe->pipe_settings.video.tnr_frames[frm];\n\t\t}\n\t\tfor (frm = 0; frm < MAX_NUM_VIDEO_DELAY_FRAMES; frm++) {\n\t\t\tvideo_stage->args.delay_frames[frm] =\n\t\t\t    pipe->pipe_settings.video.delay_frames[frm];\n\t\t}\n\t}\n\n\tif (need_yuv_pp && video_stage) {\n\t\tstruct ia_css_frame *tmp_in_frame = video_stage->args.out_frame[0];\n\t\tstruct ia_css_frame *tmp_out_frame = NULL;\n\n\t\tfor (i = 0; i < num_yuv_scaler; i++) {\n\t\t\ttmp_out_frame = is_output_stage[i] ? out_frame : NULL;\n\n\t\t\terr = add_yuv_scaler_stage(pipe, me, tmp_in_frame,\n\t\t\t\t\t\t   tmp_out_frame, NULL,\n\t\t\t\t\t\t   &yuv_scaler_binary[i],\n\t\t\t\t\t\t   &yuv_scaler_stage);\n\n\t\t\tif (err) {\n\t\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\t \n\t\t\tif (yuv_scaler_stage)\n\t\t\t\ttmp_in_frame = yuv_scaler_stage->args.out_frame[1];\n\t\t}\n\t}\n\n\tpipe->pipeline.acquire_isp_each_stage = false;\n\tia_css_pipeline_finalize_stages(&pipe->pipeline,\n\t\t\t\t\tpipe->stream->config.continuous);\n\nERR:\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\n \nstatic int\ncreate_host_preview_pipeline(struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_pipeline_stage *copy_stage = NULL;\n\tstruct ia_css_pipeline_stage *preview_stage = NULL;\n\tstruct ia_css_pipeline_stage *vf_pp_stage = NULL;\n\tstruct ia_css_pipeline_stage_desc stage_desc;\n\tstruct ia_css_pipeline *me = NULL;\n\tstruct ia_css_binary *copy_binary, *preview_binary, *vf_pp_binary = NULL;\n\tstruct ia_css_frame *in_frame = NULL;\n\tint err = 0;\n\tstruct ia_css_frame *out_frame;\n\tstruct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];\n\tbool need_in_frameinfo_memory = false;\n\tbool sensor = false;\n\tbool buffered_sensor = false;\n\tbool online = false;\n\tbool continuous = false;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p\", pipe);\n\tif ((!pipe) || (!pipe->stream) || (pipe->mode != IA_CSS_PIPE_ID_PREVIEW)) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tia_css_pipe_util_create_output_frames(out_frames);\n\t \n\tme = &pipe->pipeline;\n\tia_css_pipeline_clean(me);\n\n\tif (IS_ISP2401) {\n\t\t \n\t\tsensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR);\n\t\tbuffered_sensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR);\n\t\tonline = pipe->stream->config.online;\n\t\tcontinuous = pipe->stream->config.continuous;\n\t\tneed_in_frameinfo_memory =\n\t\t!((sensor && (online || continuous)) || (buffered_sensor &&\n\t\t\t\t\t\t\t(online || continuous)));\n\t} else {\n\t\t \n\t\tneed_in_frameinfo_memory = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;\n\t}\n\tif (need_in_frameinfo_memory) {\n\t\terr = init_in_frameinfo_memory_defaults(pipe, &me->in_frame,\n\t\t\t\t\t\t\tIA_CSS_FRAME_FORMAT_RAW);\n\t\tif (err)\n\t\t\tgoto ERR;\n\n\t\tin_frame = &me->in_frame;\n\t} else {\n\t\tin_frame = NULL;\n\t}\n\terr = init_out_frameinfo_defaults(pipe, &me->out_frame[0], 0);\n\tif (err)\n\t\tgoto ERR;\n\tout_frame = &me->out_frame[0];\n\n\tcopy_binary    = &pipe->pipe_settings.preview.copy_binary;\n\tpreview_binary = &pipe->pipe_settings.preview.preview_binary;\n\tif (pipe->pipe_settings.preview.vf_pp_binary.info)\n\t\tvf_pp_binary = &pipe->pipe_settings.preview.vf_pp_binary;\n\n\tif (pipe->pipe_settings.preview.copy_binary.info) {\n\t\tia_css_pipe_util_set_output_frames(out_frames, 0, NULL);\n\t\tia_css_pipe_get_generic_stage_desc(&stage_desc, copy_binary,\n\t\t\t\t\t\t   out_frames, NULL, NULL);\n\t\terr = ia_css_pipeline_create_and_add_stage(me, &stage_desc,\n\t\t\t\t\t\t\t   &copy_stage);\n\t\tif (err)\n\t\t\tgoto ERR;\n\t\tin_frame = me->stages->args.out_frame[0];\n\t} else if (pipe->stream->config.continuous) {\n\t\tif (IS_ISP2401) {\n\t\t\t \n\t\t\tif (continuous || !online)\n\t\t\t\tin_frame = pipe->stream->last_pipe->continuous_frames[0];\n\t\t} else {\n\t\t\tin_frame = pipe->continuous_frames[0];\n\t\t}\n\t}\n\n\tif (vf_pp_binary) {\n\t\tia_css_pipe_util_set_output_frames(out_frames, 0, NULL);\n\t\tia_css_pipe_get_generic_stage_desc(&stage_desc, preview_binary,\n\t\t\t\t\t\t   out_frames, in_frame, NULL);\n\t} else {\n\t\tia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);\n\t\tia_css_pipe_get_generic_stage_desc(&stage_desc, preview_binary,\n\t\t\t\t\t\t   out_frames, in_frame, NULL);\n\t}\n\terr = ia_css_pipeline_create_and_add_stage(me, &stage_desc,\n\t\t\t\t\t\t   &preview_stage);\n\tif (err)\n\t\tgoto ERR;\n\t \n\tpreview_stage->args.copy_vf =\n\t    preview_binary->info->sp.pipeline.mode == IA_CSS_BINARY_MODE_COPY;\n\tpreview_stage->args.copy_output = !preview_stage->args.copy_vf;\n\tif (preview_stage->args.copy_vf && !preview_stage->args.out_vf_frame) {\n\t\t \n\t\tpreview_stage->args.out_vf_frame =\n\t\t    preview_stage->args.out_frame[0];\n\t}\n\tif (vf_pp_binary) {\n\t\tif (preview_binary->info->sp.pipeline.mode == IA_CSS_BINARY_MODE_COPY)\n\t\t\tin_frame = preview_stage->args.out_vf_frame;\n\t\telse\n\t\t\tin_frame = preview_stage->args.out_frame[0];\n\t\terr = add_vf_pp_stage(pipe, in_frame, out_frame, vf_pp_binary,\n\t\t\t\t      &vf_pp_stage);\n\t\tif (err)\n\t\t\tgoto ERR;\n\t}\n\n\tpipe->pipeline.acquire_isp_each_stage = false;\n\tia_css_pipeline_finalize_stages(&pipe->pipeline, pipe->stream->config.continuous);\n\nERR:\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\nstatic void send_raw_frames(struct ia_css_pipe *pipe)\n{\n\tif (pipe->stream->config.continuous) {\n\t\tunsigned int i;\n\n\t\tsh_css_update_host2sp_cont_num_raw_frames\n\t\t(pipe->stream->config.init_num_cont_raw_buf, true);\n\t\tsh_css_update_host2sp_cont_num_raw_frames\n\t\t(pipe->stream->config.target_num_cont_raw_buf, false);\n\n\t\t \n\t\tfor (i = 0; i < pipe->stream->config.init_num_cont_raw_buf; i++) {\n\t\t\tsh_css_update_host2sp_offline_frame(i,\n\t\t\t\t\t\t\t    pipe->continuous_frames[i], pipe->cont_md_buffers[i]);\n\t\t}\n\t}\n\n\treturn;\n}\n\nstatic int\npreview_start(struct ia_css_pipe *pipe)\n{\n\tint err = 0;\n\tstruct ia_css_pipe *copy_pipe, *capture_pipe;\n\tenum sh_css_pipe_config_override copy_ovrd;\n\tenum ia_css_input_mode preview_pipe_input_mode;\n\tunsigned int thread_id;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p\", pipe);\n\tif ((!pipe) || (!pipe->stream) || (pipe->mode != IA_CSS_PIPE_ID_PREVIEW)) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tpreview_pipe_input_mode = pipe->stream->config.mode;\n\n\tcopy_pipe    = pipe->pipe_settings.preview.copy_pipe;\n\tcapture_pipe = pipe->pipe_settings.preview.capture_pipe;\n\n\tsh_css_metrics_start_frame();\n\n\t \n\terr = send_mipi_frames(pipe);\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\tsend_raw_frames(pipe);\n\n\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);\n\tcopy_ovrd = 1 << thread_id;\n\n\tif (pipe->stream->cont_capt) {\n\t\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(capture_pipe),\n\t\t\t\t\t\t &thread_id);\n\t\tcopy_ovrd |= 1 << thread_id;\n\t}\n\n\t \n\tif (pipe->stream->config.continuous) {\n\t\tsh_css_sp_init_pipeline(&copy_pipe->pipeline,\n\t\t\t\t\tIA_CSS_PIPE_ID_COPY,\n\t\t\t\t\t(uint8_t)ia_css_pipe_get_pipe_num(copy_pipe),\n\t\t\t\t\tfalse,\n\t\t\t\t\tpipe->stream->config.pixels_per_clock == 2, false,\n\t\t\t\t\tfalse, pipe->required_bds_factor,\n\t\t\t\t\tcopy_ovrd,\n\t\t\t\t\tpipe->stream->config.mode,\n\t\t\t\t\t&pipe->stream->config.metadata_config,\n\t\t\t\t\t&pipe->stream->info.metadata_info,\n\t\t\t\t\tpipe->stream->config.source.port.port);\n\n\t\t \n\t\tpreview_pipe_input_mode = IA_CSS_INPUT_MODE_MEMORY;\n\t}\n\n\t \n\tif (pipe->stream->cont_capt) {\n\t\tsh_css_sp_init_pipeline(&capture_pipe->pipeline,\n\t\t\t\t\tIA_CSS_PIPE_ID_CAPTURE,\n\t\t\t\t\t(uint8_t)ia_css_pipe_get_pipe_num(capture_pipe),\n\t\t\t\t\tcapture_pipe->config.default_capture_config.enable_xnr != 0,\n\t\t\t\t\tcapture_pipe->stream->config.pixels_per_clock == 2,\n\t\t\t\t\ttrue,  \n\t\t\t\t\tfalse,  \n\t\t\t\t\tcapture_pipe->required_bds_factor,\n\t\t\t\t\t0,\n\t\t\t\t\tIA_CSS_INPUT_MODE_MEMORY,\n\t\t\t\t\t&pipe->stream->config.metadata_config,\n\t\t\t\t\t&pipe->stream->info.metadata_info,\n\t\t\t\t\t(enum mipi_port_id)0);\n\t}\n\n\tstart_pipe(pipe, copy_ovrd, preview_pipe_input_mode);\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\nint\nia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,\n\t\t\t   const struct ia_css_buffer *buffer)\n{\n\tint return_err = 0;\n\tunsigned int thread_id;\n\tenum sh_css_queue_id queue_id;\n\tstruct ia_css_pipeline *pipeline;\n\tstruct ia_css_pipeline_stage *stage;\n\tstruct ia_css_rmgr_vbuf_handle p_vbuf;\n\tstruct ia_css_rmgr_vbuf_handle *h_vbuf;\n\tstruct sh_css_hmm_buffer ddr_buffer;\n\tenum ia_css_buffer_type buf_type;\n\tenum ia_css_pipe_id pipe_id;\n\tbool ret_err;\n\n\tIA_CSS_ENTER(\"pipe=%p, buffer=%p\", pipe, buffer);\n\n\tif ((!pipe) || (!buffer)) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf_type = buffer->type;\n\n\tpipe_id = pipe->mode;\n\n\tIA_CSS_LOG(\"pipe_id=%d, buf_type=%d\", pipe_id, buf_type);\n\n\tassert(pipe_id < IA_CSS_PIPE_ID_NUM);\n\tassert(buf_type < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE);\n\tif (buf_type == IA_CSS_BUFFER_TYPE_INVALID ||\n\t    buf_type >= IA_CSS_NUM_DYNAMIC_BUFFER_TYPE ||\n\t    pipe_id >= IA_CSS_PIPE_ID_NUM) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tret_err = ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);\n\tif (!ret_err) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tret_err = ia_css_query_internal_queue_id(buf_type, thread_id, &queue_id);\n\tif (!ret_err) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((queue_id <= SH_CSS_INVALID_QUEUE_ID) || (queue_id >= SH_CSS_MAX_NUM_QUEUES)) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!sh_css_sp_is_running()) {\n\t\tIA_CSS_LOG(\"SP is not running!\");\n\t\tIA_CSS_LEAVE_ERR(-EBUSY);\n\t\t \n\t\treturn -EBUSY;\n\t}\n\n\tpipeline = &pipe->pipeline;\n\n\tassert(pipeline || pipe_id == IA_CSS_PIPE_ID_COPY);\n\n\tassert(sizeof(NULL) <= sizeof(ddr_buffer.kernel_ptr));\n\tddr_buffer.kernel_ptr = HOST_ADDRESS(NULL);\n\tddr_buffer.cookie_ptr = buffer->driver_cookie;\n\tddr_buffer.timing_data = buffer->timing_data;\n\n\tif (buf_type == IA_CSS_BUFFER_TYPE_3A_STATISTICS) {\n\t\tif (!buffer->data.stats_3a) {\n\t\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tddr_buffer.kernel_ptr = HOST_ADDRESS(buffer->data.stats_3a);\n\t\tddr_buffer.payload.s3a = *buffer->data.stats_3a;\n\t} else if (buf_type == IA_CSS_BUFFER_TYPE_DIS_STATISTICS) {\n\t\tif (!buffer->data.stats_dvs) {\n\t\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tddr_buffer.kernel_ptr = HOST_ADDRESS(buffer->data.stats_dvs);\n\t\tddr_buffer.payload.dis = *buffer->data.stats_dvs;\n\t} else if (buf_type == IA_CSS_BUFFER_TYPE_METADATA) {\n\t\tif (!buffer->data.metadata) {\n\t\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tddr_buffer.kernel_ptr = HOST_ADDRESS(buffer->data.metadata);\n\t\tddr_buffer.payload.metadata = *buffer->data.metadata;\n\t} else if (buf_type == IA_CSS_BUFFER_TYPE_INPUT_FRAME ||\n\t\t   buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME ||\n\t\t   buf_type == IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME ||\n\t\t   buf_type == IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME ||\n\t\t   buf_type == IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME) {\n\t\tif (!buffer->data.frame) {\n\t\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tddr_buffer.kernel_ptr = HOST_ADDRESS(buffer->data.frame);\n\t\tddr_buffer.payload.frame.frame_data = buffer->data.frame->data;\n\t\tddr_buffer.payload.frame.flashed = 0;\n\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"ia_css_pipe_enqueue_buffer() buf_type=%d, data(DDR address)=0x%x\\n\",\n\t\t\t\t    buf_type, buffer->data.frame->data);\n\n\t}\n\n\t \n\tp_vbuf.vptr = 0;\n\tp_vbuf.count = 0;\n\tp_vbuf.size = sizeof(struct sh_css_hmm_buffer);\n\th_vbuf = &p_vbuf;\n\t \n\tia_css_rmgr_acq_vbuf(hmm_buffer_pool, &h_vbuf);\n\n\tif ((!h_vbuf) || (h_vbuf->vptr == 0x0)) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\thmm_store(h_vbuf->vptr,\n\t\t  (void *)(&ddr_buffer),\n\t\t  sizeof(struct sh_css_hmm_buffer));\n\tif (buf_type == IA_CSS_BUFFER_TYPE_3A_STATISTICS ||\n\t    buf_type == IA_CSS_BUFFER_TYPE_DIS_STATISTICS ||\n\t    buf_type == IA_CSS_BUFFER_TYPE_LACE_STATISTICS) {\n\t\tif (!pipeline) {\n\t\t\tia_css_rmgr_rel_vbuf(hmm_buffer_pool, &h_vbuf);\n\t\t\tIA_CSS_LOG(\"pipeline is empty!\");\n\t\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (stage = pipeline->stages; stage; stage = stage->next) {\n\t\t\t \n\t\t\tif (stage->binary && stage->binary->info &&\n\t\t\t    (stage->binary->info->sp.enable.s3a ||\n\t\t\t     stage->binary->info->sp.enable.dis)) {\n\t\t\t\t \n\t\t\t\treturn_err = ia_css_bufq_enqueue_buffer(thread_id,\n\t\t\t\t\t\t\t\t\tqueue_id,\n\t\t\t\t\t\t\t\t\t(uint32_t)h_vbuf->vptr);\n\t\t\t}\n\t\t}\n\t} else if (buf_type == IA_CSS_BUFFER_TYPE_INPUT_FRAME ||\n\t\t   buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME ||\n\t\t   buf_type == IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME ||\n\t\t   buf_type == IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME ||\n\t\t   buf_type == IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME ||\n\t\t   buf_type == IA_CSS_BUFFER_TYPE_METADATA) {\n\t\treturn_err = ia_css_bufq_enqueue_buffer(thread_id,\n\t\t\t\t\t\t\tqueue_id,\n\t\t\t\t\t\t\t(uint32_t)h_vbuf->vptr);\n\t\tif (!return_err &&\n\t\t    buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME) {\n\t\t\tIA_CSS_LOG(\"pfp: enqueued OF %d to q %d thread %d\",\n\t\t\t\t   ddr_buffer.payload.frame.frame_data,\n\t\t\t\t   queue_id, thread_id);\n\t\t}\n\t}\n\n\tif (!return_err) {\n\t\tif (sh_css_hmm_buffer_record_acquire(\n\t\t\th_vbuf, buf_type,\n\t\t\tHOST_ADDRESS(ddr_buffer.kernel_ptr))) {\n\t\t\tIA_CSS_LOG(\"send vbuf=%p\", h_vbuf);\n\t\t} else {\n\t\t\treturn_err = -EINVAL;\n\t\t\tIA_CSS_ERROR(\"hmm_buffer_record[]: no available slots\\n\");\n\t\t}\n\t}\n\n\t \n\tif (!return_err) {\n\t\tif (!sh_css_sp_is_running()) {\n\t\t\t \n\t\t\tIA_CSS_LOG(\"SP is not running!\");\n\t\t\tIA_CSS_LEAVE_ERR(-EBUSY);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\treturn_err = ia_css_bufq_enqueue_psys_event(\n\t\t\t\t IA_CSS_PSYS_SW_EVENT_BUFFER_ENQUEUED,\n\t\t\t\t (uint8_t)thread_id,\n\t\t\t\t queue_id,\n\t\t\t\t 0);\n\t} else {\n\t\tia_css_rmgr_rel_vbuf(hmm_buffer_pool, &h_vbuf);\n\t\tIA_CSS_ERROR(\"buffer not enqueued\");\n\t}\n\n\tIA_CSS_LEAVE(\"return value = %d\", return_err);\n\n\treturn return_err;\n}\n\n \nint\nia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,\n\t\t\t   struct ia_css_buffer *buffer)\n{\n\tint return_err;\n\tenum sh_css_queue_id queue_id;\n\tia_css_ptr ddr_buffer_addr = (ia_css_ptr)0;\n\tstruct sh_css_hmm_buffer ddr_buffer;\n\tenum ia_css_buffer_type buf_type;\n\tenum ia_css_pipe_id pipe_id;\n\tunsigned int thread_id;\n\thrt_address kernel_ptr = 0;\n\tbool ret_err;\n\n\tIA_CSS_ENTER(\"pipe=%p, buffer=%p\", pipe, buffer);\n\n\tif ((!pipe) || (!buffer)) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tpipe_id = pipe->mode;\n\n\tbuf_type = buffer->type;\n\n\tIA_CSS_LOG(\"pipe_id=%d, buf_type=%d\", pipe_id, buf_type);\n\n\tddr_buffer.kernel_ptr = 0;\n\n\tret_err = ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);\n\tif (!ret_err) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tret_err = ia_css_query_internal_queue_id(buf_type, thread_id, &queue_id);\n\tif (!ret_err) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((queue_id <= SH_CSS_INVALID_QUEUE_ID) || (queue_id >= SH_CSS_MAX_NUM_QUEUES)) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!sh_css_sp_is_running()) {\n\t\tIA_CSS_LOG(\"SP is not running!\");\n\t\tIA_CSS_LEAVE_ERR(-EBUSY);\n\t\t \n\t\treturn -EBUSY;\n\t}\n\n\treturn_err = ia_css_bufq_dequeue_buffer(queue_id,\n\t\t\t\t\t\t(uint32_t *)&ddr_buffer_addr);\n\n\tif (!return_err) {\n\t\tstruct ia_css_frame *frame;\n\t\tstruct sh_css_hmm_buffer_record *hmm_buffer_record = NULL;\n\n\t\tIA_CSS_LOG(\"receive vbuf=%x\", (int)ddr_buffer_addr);\n\n\t\t \n\t\thmm_buffer_record = sh_css_hmm_buffer_record_validate(\n\t\t    ddr_buffer_addr, buf_type);\n\t\tif (hmm_buffer_record) {\n\t\t\t \n\t\t\tkernel_ptr = hmm_buffer_record->kernel_ptr;\n\t\t\tia_css_rmgr_rel_vbuf(hmm_buffer_pool, &hmm_buffer_record->h_vbuf);\n\t\t\tsh_css_hmm_buffer_record_reset(hmm_buffer_record);\n\t\t} else {\n\t\t\tIA_CSS_ERROR(\"hmm_buffer_record not found (0x%x) buf_type(%d)\",\n\t\t\t\t     ddr_buffer_addr, buf_type);\n\t\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thmm_load(ddr_buffer_addr,\n\t\t\t &ddr_buffer,\n\t\t\t sizeof(struct sh_css_hmm_buffer));\n\n\t\t \n\t\tif ((ddr_buffer.kernel_ptr == 0) ||\n\t\t    (kernel_ptr != HOST_ADDRESS(ddr_buffer.kernel_ptr))) {\n\t\t\tIA_CSS_ERROR(\"kernel_ptr invalid\");\n\t\t\tIA_CSS_ERROR(\"expected: (0x%llx)\", (u64)kernel_ptr);\n\t\t\tIA_CSS_ERROR(\"actual: (0x%llx)\", (u64)HOST_ADDRESS(ddr_buffer.kernel_ptr));\n\t\t\tIA_CSS_ERROR(\"buf_type: %d\\n\", buf_type);\n\t\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ddr_buffer.kernel_ptr != 0) {\n\t\t\t \n\t\t\tbuffer->exp_id = 0;\n\t\t\tbuffer->driver_cookie = ddr_buffer.cookie_ptr;\n\t\t\tbuffer->timing_data = ddr_buffer.timing_data;\n\n\t\t\tif (buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME ||\n\t\t\t    buf_type == IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME) {\n\t\t\t\tbuffer->isys_eof_clock_tick.ticks = ddr_buffer.isys_eof_clock_tick;\n\t\t\t}\n\n\t\t\tswitch (buf_type) {\n\t\t\tcase IA_CSS_BUFFER_TYPE_INPUT_FRAME:\n\t\t\tcase IA_CSS_BUFFER_TYPE_OUTPUT_FRAME:\n\t\t\tcase IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME:\n\t\t\t\tif (pipe && pipe->stop_requested) {\n\t\t\t\t\tif (!IS_ISP2401) {\n\t\t\t\t\t\t \n\t\t\t\t\t\treturn_err = free_mipi_frames(pipe);\n\t\t\t\t\t\tif (return_err) {\n\t\t\t\t\t\t\tIA_CSS_LOG(\"free_mipi_frames() failed\");\n\t\t\t\t\t\t\tIA_CSS_LEAVE_ERR(return_err);\n\t\t\t\t\t\t\treturn return_err;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpipe->stop_requested = false;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:\n\t\t\tcase IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME:\n\t\t\t\tframe = (struct ia_css_frame *)HOST_ADDRESS(ddr_buffer.kernel_ptr);\n\t\t\t\tbuffer->data.frame = frame;\n\t\t\t\tbuffer->exp_id = ddr_buffer.payload.frame.exp_id;\n\t\t\t\tframe->exp_id = ddr_buffer.payload.frame.exp_id;\n\t\t\t\tframe->isp_config_id = ddr_buffer.payload.frame.isp_parameters_id;\n\t\t\t\tif (ddr_buffer.payload.frame.flashed == 1)\n\t\t\t\t\tframe->flash_state =\n\t\t\t\t\t    IA_CSS_FRAME_FLASH_STATE_PARTIAL;\n\t\t\t\tif (ddr_buffer.payload.frame.flashed == 2)\n\t\t\t\t\tframe->flash_state =\n\t\t\t\t\t    IA_CSS_FRAME_FLASH_STATE_FULL;\n\t\t\t\tframe->valid = pipe->num_invalid_frames == 0;\n\t\t\t\tif (!frame->valid)\n\t\t\t\t\tpipe->num_invalid_frames--;\n\n\t\t\t\tif (frame->frame_info.format == IA_CSS_FRAME_FORMAT_BINARY_8) {\n\t\t\t\t\tif (IS_ISP2401)\n\t\t\t\t\t\tframe->planes.binary.size = frame->data_bytes;\n\t\t\t\t\telse\n\t\t\t\t\t\tframe->planes.binary.size =\n\t\t\t\t\t\t    sh_css_sp_get_binary_copy_size();\n\t\t\t\t}\n\t\t\t\tif (buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME) {\n\t\t\t\t\tIA_CSS_LOG(\"pfp: dequeued OF %d with config id %d thread %d\",\n\t\t\t\t\t\t   frame->data, frame->isp_config_id, thread_id);\n\t\t\t\t}\n\n\t\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t\t    \"ia_css_pipe_dequeue_buffer() buf_type=%d, data(DDR address)=0x%x\\n\",\n\t\t\t\t\t\t    buf_type, buffer->data.frame->data);\n\n\t\t\t\tbreak;\n\t\t\tcase IA_CSS_BUFFER_TYPE_3A_STATISTICS:\n\t\t\t\tbuffer->data.stats_3a =\n\t\t\t\t    (struct ia_css_isp_3a_statistics *)HOST_ADDRESS(ddr_buffer.kernel_ptr);\n\t\t\t\tbuffer->exp_id = ddr_buffer.payload.s3a.exp_id;\n\t\t\t\tbuffer->data.stats_3a->exp_id = ddr_buffer.payload.s3a.exp_id;\n\t\t\t\tbuffer->data.stats_3a->isp_config_id = ddr_buffer.payload.s3a.isp_config_id;\n\t\t\t\tbreak;\n\t\t\tcase IA_CSS_BUFFER_TYPE_DIS_STATISTICS:\n\t\t\t\tbuffer->data.stats_dvs =\n\t\t\t\t    (struct ia_css_isp_dvs_statistics *)\n\t\t\t\t    HOST_ADDRESS(ddr_buffer.kernel_ptr);\n\t\t\t\tbuffer->exp_id = ddr_buffer.payload.dis.exp_id;\n\t\t\t\tbuffer->data.stats_dvs->exp_id = ddr_buffer.payload.dis.exp_id;\n\t\t\t\tbreak;\n\t\t\tcase IA_CSS_BUFFER_TYPE_LACE_STATISTICS:\n\t\t\t\tbreak;\n\t\t\tcase IA_CSS_BUFFER_TYPE_METADATA:\n\t\t\t\tbuffer->data.metadata =\n\t\t\t\t    (struct ia_css_metadata *)HOST_ADDRESS(ddr_buffer.kernel_ptr);\n\t\t\t\tbuffer->exp_id = ddr_buffer.payload.metadata.exp_id;\n\t\t\t\tbuffer->data.metadata->exp_id = ddr_buffer.payload.metadata.exp_id;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn_err = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!return_err) {\n\t\tif (!sh_css_sp_is_running()) {\n\t\t\tIA_CSS_LOG(\"SP is not running!\");\n\t\t\tIA_CSS_LEAVE_ERR(-EBUSY);\n\t\t\t \n\t\t\treturn -EBUSY;\n\t\t}\n\t\tia_css_bufq_enqueue_psys_event(\n\t\t    IA_CSS_PSYS_SW_EVENT_BUFFER_DEQUEUED,\n\t\t    0,\n\t\t    queue_id,\n\t\t    0);\n\t}\n\tIA_CSS_LEAVE(\"buffer=%p\", buffer);\n\n\treturn return_err;\n}\n\n \nstatic enum ia_css_event_type convert_event_sp_to_host_domain[] = {\n\tIA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE,\t \n\tIA_CSS_EVENT_TYPE_SECOND_OUTPUT_FRAME_DONE,\t \n\tIA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE,\t \n\tIA_CSS_EVENT_TYPE_SECOND_VF_OUTPUT_FRAME_DONE,\t \n\tIA_CSS_EVENT_TYPE_3A_STATISTICS_DONE,\t \n\tIA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE,\t \n\tIA_CSS_EVENT_TYPE_PIPELINE_DONE,\t \n\tIA_CSS_EVENT_TYPE_FRAME_TAGGED,\t\t \n\tIA_CSS_EVENT_TYPE_INPUT_FRAME_DONE,\t \n\tIA_CSS_EVENT_TYPE_METADATA_DONE,\t \n\tIA_CSS_EVENT_TYPE_LACE_STATISTICS_DONE,\t \n\tIA_CSS_EVENT_TYPE_ACC_STAGE_COMPLETE,\t \n\tIA_CSS_EVENT_TYPE_TIMER,\t\t \n\tIA_CSS_EVENT_TYPE_PORT_EOF,\t\t \n\tIA_CSS_EVENT_TYPE_FW_WARNING,\t\t \n\tIA_CSS_EVENT_TYPE_FW_ASSERT,\t\t \n\t0,\t\t\t\t\t \n};\n\nint\nia_css_dequeue_psys_event(struct ia_css_event *event)\n{\n\tenum ia_css_pipe_id pipe_id = 0;\n\tu8 payload[4] = {0, 0, 0, 0};\n\tint ret_err;\n\n\t \n\tif (!event)\n\t\treturn -EINVAL;\n\n\t \n\tif (!sh_css_sp_is_running())\n\t\treturn -EBUSY;\n\n\t \n\tret_err = ia_css_bufq_dequeue_psys_event(payload);\n\tif (ret_err)\n\t\treturn ret_err;\n\n\tIA_CSS_LOG(\"event dequeued from psys event queue\");\n\n\t \n\tia_css_bufq_enqueue_psys_event(\n\t    IA_CSS_PSYS_SW_EVENT_EVENT_DEQUEUED, 0, 0, 0);\n\n\t \n\tevent->type = convert_event_sp_to_host_domain[payload[0]];\n\t \n\tevent->pipe = NULL;\n\tevent->port = MIPI_PORT0_ID;\n\tevent->exp_id = 0;\n\tevent->fw_warning = IA_CSS_FW_WARNING_NONE;\n\tevent->fw_handle = 0;\n\tevent->timer_data = 0;\n\tevent->timer_code = 0;\n\tevent->timer_subcode = 0;\n\n\tif (event->type == IA_CSS_EVENT_TYPE_TIMER) {\n\t\t \n\t\tu32 tmp_data;\n\t\t \n\t\tevent->timer_data = ((payload[1] & 0xFF) | ((payload[3] & 0xFF) << 8));\n\t\tevent->timer_code = payload[2];\n\t\tpayload[0] = payload[1] = payload[2] = payload[3] = 0;\n\t\tret_err = ia_css_bufq_dequeue_psys_event(payload);\n\t\tif (ret_err) {\n\t\t\t \n\t\t\t \n\t\t\tIA_CSS_WARNING(\"Timer: Error de-queuing the 2nd TIMER event!!!\\n\");\n\t\t\treturn ret_err;\n\t\t}\n\t\tia_css_bufq_enqueue_psys_event(\n\t\t    IA_CSS_PSYS_SW_EVENT_EVENT_DEQUEUED, 0, 0, 0);\n\t\tevent->type = convert_event_sp_to_host_domain[payload[0]];\n\t\t \n\t\tif (event->type == IA_CSS_EVENT_TYPE_TIMER) {\n\t\t\t \n\t\t\ttmp_data = ((payload[1] & 0xFF) | ((payload[3] & 0xFF) << 8));\n\t\t\tevent->timer_data |= (tmp_data << 16);\n\t\t\tevent->timer_subcode = payload[2];\n\t\t} else {\n\t\t\t \n\t\t\tevent->timer_data = 0;\n\t\t\tevent->timer_code = 0;\n\t\t\tevent->timer_subcode = 0;\n\t\t\tIA_CSS_ERROR(\"Missing 2nd timer event. Timer event discarded\");\n\t\t}\n\t}\n\tif (event->type == IA_CSS_EVENT_TYPE_PORT_EOF) {\n\t\tevent->port = (enum mipi_port_id)payload[1];\n\t\tevent->exp_id = payload[3];\n\t} else if (event->type == IA_CSS_EVENT_TYPE_FW_WARNING) {\n\t\tevent->fw_warning = (enum ia_css_fw_warning)payload[1];\n\t\t \n\t\tif (event->fw_warning == IA_CSS_FW_WARNING_EXP_ID_LOCKED ||\n\t\t    event->fw_warning == IA_CSS_FW_WARNING_TAG_EXP_ID_FAILED)\n\t\t\tevent->exp_id = payload[3];\n\t} else if (event->type == IA_CSS_EVENT_TYPE_FW_ASSERT) {\n\t\tevent->fw_assert_module_id = payload[1];  \n\t\tevent->fw_assert_line_no = (payload[2] << 8) + payload[3];\n\t\t \n\t} else if (event->type != IA_CSS_EVENT_TYPE_TIMER) {\n\t\t \n\t\tevent->pipe = find_pipe_by_num(payload[1]);\n\t\tpipe_id = (enum ia_css_pipe_id)payload[2];\n\t\t \n\t\tif (!event->pipe)\n\t\t\treturn -EBUSY;\n\n\t\tif (event->type == IA_CSS_EVENT_TYPE_FRAME_TAGGED) {\n\t\t\t \n\t\t\tint i, n;\n\n\t\t\tn = event->pipe->stream->num_pipes;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tstruct ia_css_pipe *p =\n\t\t\t\t\t    event->pipe->stream->pipes[i];\n\t\t\t\tif (p->config.mode == IA_CSS_PIPE_MODE_CAPTURE) {\n\t\t\t\t\tevent->pipe = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent->exp_id = payload[3];\n\t\t}\n\t\tif (event->type == IA_CSS_EVENT_TYPE_ACC_STAGE_COMPLETE) {\n\t\t\t \n\t\t\tu32 stage_num = (uint32_t)payload[3];\n\n\t\t\tret_err = ia_css_pipeline_get_fw_from_stage(\n\t\t\t\t      &event->pipe->pipeline,\n\t\t\t\t      stage_num,\n\t\t\t\t      &event->fw_handle);\n\t\t\tif (ret_err) {\n\t\t\t\tIA_CSS_ERROR(\"Invalid stage num received for ACC event. stage_num:%u\",\n\t\t\t\t\t     stage_num);\n\t\t\t\treturn ret_err;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (event->pipe)\n\t\tIA_CSS_LEAVE(\"event_id=%d, pipe_id=%d\", event->type, pipe_id);\n\telse\n\t\tIA_CSS_LEAVE(\"event_id=%d\", event->type);\n\n\treturn 0;\n}\n\nint\nia_css_dequeue_isys_event(struct ia_css_event *event)\n{\n\tu8 payload[4] = {0, 0, 0, 0};\n\tint err = 0;\n\n\t \n\tif (!event)\n\t\treturn -EINVAL;\n\n\t \n\tif (!sh_css_sp_is_running())\n\t\treturn -EBUSY;\n\n\terr = ia_css_bufq_dequeue_isys_event(payload);\n\tif (err)\n\t\treturn err;\n\n\tIA_CSS_LOG(\"event dequeued from isys event queue\");\n\n\t \n\tia_css_bufq_enqueue_isys_event(IA_CSS_ISYS_SW_EVENT_EVENT_DEQUEUED);\n\n\t \n\tevent->type = IA_CSS_EVENT_TYPE_PORT_EOF;\n\t \n\tevent->pipe = NULL;\n\tevent->port = payload[1];\n\tevent->exp_id = payload[3];\n\n\tIA_CSS_LEAVE_ERR(err);\n\treturn err;\n}\n\nstatic int\nsh_css_pipe_start(struct ia_css_stream *stream)\n{\n\tint err = 0;\n\n\tstruct ia_css_pipe *pipe;\n\tenum ia_css_pipe_id pipe_id;\n\tunsigned int thread_id;\n\n\tIA_CSS_ENTER_PRIVATE(\"stream = %p\", stream);\n\n\tif (!stream) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\tpipe = stream->last_pipe;\n\tif (!pipe) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tpipe_id = pipe->mode;\n\n\tif (stream->started) {\n\t\tIA_CSS_WARNING(\"Cannot start stream that is already started\");\n\t\tIA_CSS_LEAVE_ERR(err);\n\t\treturn err;\n\t}\n\n\tpipe->stop_requested = false;\n\n\tswitch (pipe_id) {\n\tcase IA_CSS_PIPE_ID_PREVIEW:\n\t\terr = preview_start(pipe);\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_VIDEO:\n\t\terr = video_start(pipe);\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_CAPTURE:\n\t\terr = capture_start(pipe);\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_YUVPP:\n\t\terr = yuvpp_start(pipe);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\t \n\tif (!stream->config.continuous) {\n\t\tint i;\n\n\t\tfor (i = 1; i < stream->num_pipes && 0 == err ; i++) {\n\t\t\tswitch (stream->pipes[i]->mode) {\n\t\t\tcase IA_CSS_PIPE_ID_PREVIEW:\n\t\t\t\tstream->pipes[i]->stop_requested = false;\n\t\t\t\terr = preview_start(stream->pipes[i]);\n\t\t\t\tbreak;\n\t\t\tcase IA_CSS_PIPE_ID_VIDEO:\n\t\t\t\tstream->pipes[i]->stop_requested = false;\n\t\t\t\terr = video_start(stream->pipes[i]);\n\t\t\t\tbreak;\n\t\t\tcase IA_CSS_PIPE_ID_CAPTURE:\n\t\t\t\tstream->pipes[i]->stop_requested = false;\n\t\t\t\terr = capture_start(stream->pipes[i]);\n\t\t\t\tbreak;\n\t\t\tcase IA_CSS_PIPE_ID_YUVPP:\n\t\t\t\tstream->pipes[i]->stop_requested = false;\n\t\t\t\terr = yuvpp_start(stream->pipes[i]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\n\t \n\tif (!copy_on_sp(pipe)) {\n\t\tsh_css_invalidate_params(stream);\n\t\terr = sh_css_param_update_isp_params(pipe,\n\t\t\t\t\t\t     stream->isp_params_configs, true, NULL);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tia_css_debug_pipe_graph_dump_epilogue();\n\n\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);\n\n\tif (!sh_css_sp_is_running()) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EBUSY);\n\t\t \n\t\treturn -EBUSY;\n\t}\n\tia_css_bufq_enqueue_psys_event(IA_CSS_PSYS_SW_EVENT_START_STREAM,\n\t\t\t\t       (uint8_t)thread_id, 0, 0);\n\n\t \n\tif (!stream->config.continuous) {\n\t\tint i;\n\n\t\tfor (i = 1; i < stream->num_pipes; i++) {\n\t\t\tia_css_pipeline_get_sp_thread_id(\n\t\t\t    ia_css_pipe_get_pipe_num(stream->pipes[i]),\n\t\t\t    &thread_id);\n\t\t\tia_css_bufq_enqueue_psys_event(\n\t\t\t    IA_CSS_PSYS_SW_EVENT_START_STREAM,\n\t\t\t    (uint8_t)thread_id, 0, 0);\n\t\t}\n\t}\n\n\t \n\tif (pipe->stream->config.continuous) {\n\t\tstruct ia_css_pipe *copy_pipe = NULL;\n\n\t\tif (pipe_id == IA_CSS_PIPE_ID_PREVIEW)\n\t\t\tcopy_pipe = pipe->pipe_settings.preview.copy_pipe;\n\t\telse if (pipe_id == IA_CSS_PIPE_ID_VIDEO)\n\t\t\tcopy_pipe = pipe->pipe_settings.video.copy_pipe;\n\n\t\tif (!copy_pipe) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(copy_pipe),\n\t\t\t\t\t\t &thread_id);\n\t\t \n\t\tia_css_bufq_enqueue_psys_event(\n\t\t    IA_CSS_PSYS_SW_EVENT_START_STREAM,\n\t\t    (uint8_t)thread_id, 0,  0);\n\t}\n\tif (pipe->stream->cont_capt) {\n\t\tstruct ia_css_pipe *capture_pipe = NULL;\n\n\t\tif (pipe_id == IA_CSS_PIPE_ID_PREVIEW)\n\t\t\tcapture_pipe = pipe->pipe_settings.preview.capture_pipe;\n\t\telse if (pipe_id == IA_CSS_PIPE_ID_VIDEO)\n\t\t\tcapture_pipe = pipe->pipe_settings.video.capture_pipe;\n\n\t\tif (!capture_pipe) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(capture_pipe),\n\t\t\t\t\t\t &thread_id);\n\t\t \n\t\tia_css_bufq_enqueue_psys_event(\n\t\t    IA_CSS_PSYS_SW_EVENT_START_STREAM,\n\t\t    (uint8_t)thread_id, 0,  0);\n\t}\n\n\tstream->started = true;\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\n \nvoid\nsh_css_enable_cont_capt(bool enable, bool stop_copy_preview)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"sh_css_enable_cont_capt() enter: enable=%d\\n\", enable);\n\n\tmy_css.stop_copy_preview = stop_copy_preview;\n}\n\nbool\nsh_css_continuous_is_enabled(uint8_t pipe_num)\n{\n\tstruct ia_css_pipe *pipe;\n\tbool continuous;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"sh_css_continuous_is_enabled() enter: pipe_num=%d\\n\", pipe_num);\n\n\tpipe = find_pipe_by_num(pipe_num);\n\tcontinuous = pipe && pipe->stream->config.continuous;\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"sh_css_continuous_is_enabled() leave: enable=%d\\n\",\n\t\t\t    continuous);\n\treturn continuous;\n}\n\n \nint\nia_css_stream_get_max_buffer_depth(struct ia_css_stream *stream,\n\t\t\t\t   int *buffer_depth)\n{\n\tif (!buffer_depth)\n\t\treturn -EINVAL;\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_stream_get_max_buffer_depth() enter: void\\n\");\n\t(void)stream;\n\t*buffer_depth = NUM_CONTINUOUS_FRAMES;\n\treturn 0;\n}\n\nint\nia_css_stream_set_buffer_depth(struct ia_css_stream *stream, int buffer_depth)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_stream_set_buffer_depth() enter: num_frames=%d\\n\", buffer_depth);\n\t(void)stream;\n\tif (buffer_depth > NUM_CONTINUOUS_FRAMES || buffer_depth < 1)\n\t\treturn -EINVAL;\n\t \n\tstream->config.target_num_cont_raw_buf = buffer_depth;\n\t \n\treturn 0;\n}\n\n \nint\nia_css_stream_get_buffer_depth(struct ia_css_stream *stream,\n\t\t\t       int *buffer_depth)\n{\n\tif (!buffer_depth)\n\t\treturn -EINVAL;\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_stream_get_buffer_depth() enter: void\\n\");\n\t(void)stream;\n\t*buffer_depth = stream->config.target_num_cont_raw_buf;\n\treturn 0;\n}\n\n#if !defined(ISP2401)\nunsigned int\nsh_css_get_mipi_sizes_for_check(const unsigned int port, const unsigned int idx)\n{\n\tOP___assert(port < N_CSI_PORTS);\n\tOP___assert(idx  < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_get_mipi_sizes_for_check(port %d, idx %d): %d\\n\",\n\t\t\t    port, idx, my_css.mipi_sizes_for_check[port][idx]);\n\treturn my_css.mipi_sizes_for_check[port][idx];\n}\n#endif\n\nstatic int sh_css_pipe_configure_output(\n    struct ia_css_pipe *pipe,\n    unsigned int width,\n    unsigned int height,\n    unsigned int padded_width,\n    enum ia_css_frame_format format,\n    unsigned int idx)\n{\n\tint err = 0;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p, width = %d, height = %d, padded width = %d, format = %d, idx = %d\",\n\t\t\t     pipe, width, height, padded_width, format, idx);\n\tif (!pipe) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\terr = ia_css_util_check_res(width, height);\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\tif (pipe->output_info[idx].res.width != width ||\n\t    pipe->output_info[idx].res.height != height ||\n\t    pipe->output_info[idx].format != format) {\n\t\tia_css_frame_info_init(\n\t\t    &pipe->output_info[idx],\n\t\t    width,\n\t\t    height,\n\t\t    format,\n\t\t    padded_width);\n\t}\n\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\treturn 0;\n}\n\nstatic int\nsh_css_pipe_get_shading_info(struct ia_css_pipe *pipe,\n\t\t\t     struct ia_css_shading_info *shading_info,\n\t\t\t     struct ia_css_pipe_config *pipe_config)\n{\n\tint err = 0;\n\tstruct ia_css_binary *binary = NULL;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_pipe_get_shading_info() enter:\\n\");\n\n\tbinary = ia_css_pipe_get_shading_correction_binary(pipe);\n\n\tif (binary) {\n\t\terr = ia_css_binary_get_shading_info(binary,\n\t\t\t\t\t\t     IA_CSS_SHADING_CORRECTION_TYPE_1,\n\t\t\t\t\t\t     pipe->required_bds_factor,\n\t\t\t\t\t\t     (const struct ia_css_stream_config *)&pipe->stream->config,\n\t\t\t\t\t\t     shading_info, pipe_config);\n\n\t\t \n\t} else {\n\t\t \n\t\tmemset(shading_info, 0, sizeof(*shading_info));\n\t}\n\treturn err;\n}\n\nstatic int\nsh_css_pipe_get_grid_info(struct ia_css_pipe *pipe,\n\t\t\t  struct ia_css_grid_info *info)\n{\n\tint err = 0;\n\tstruct ia_css_binary *binary = NULL;\n\n\tassert(pipe);\n\tassert(info);\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\n\tbinary = ia_css_pipe_get_s3a_binary(pipe);\n\n\tif (binary) {\n\t\terr = ia_css_binary_3a_grid_info(binary, info, pipe);\n\t\tif (err)\n\t\t\tgoto err;\n\t} else {\n\t\tmemset(&info->s3a_grid, 0, sizeof(info->s3a_grid));\n\t}\n\n\tbinary = ia_css_pipe_get_sdis_binary(pipe);\n\n\tif (binary) {\n\t\tia_css_binary_dvs_grid_info(binary, info, pipe);\n\t\tia_css_binary_dvs_stat_grid_info(binary, info, pipe);\n\t} else {\n\t\tmemset(&info->dvs_grid, 0, sizeof(info->dvs_grid));\n\t\tmemset(&info->dvs_grid.dvs_stat_grid_info, 0,\n\t\t\t   sizeof(info->dvs_grid.dvs_stat_grid_info));\n\t}\n\n\tif (binary) {\n\t\t \n\t\tinfo->isp_in_width = binary->internal_frame_info.res.width;\n\t\tinfo->isp_in_height = binary->internal_frame_info.res.height;\n\t}\n\n\tinfo->vamem_type = IA_CSS_VAMEM_TYPE_2;\n\nerr:\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\n \n \nstatic int\nia_css_pipe_check_format(struct ia_css_pipe *pipe,\n\t\t\t enum ia_css_frame_format format)\n{\n\tconst enum ia_css_frame_format *supported_formats;\n\tint number_of_formats;\n\tint found = 0;\n\tint i;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\n\tif (NULL == pipe || NULL == pipe->pipe_settings.video.video_binary.info) {\n\t\tIA_CSS_ERROR(\"Pipe or binary info is not set\");\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tsupported_formats = pipe->pipe_settings.video.video_binary.info->output_formats;\n\tnumber_of_formats = sizeof(pipe->pipe_settings.video.video_binary.info->output_formats) / sizeof(enum ia_css_frame_format);\n\n\tfor (i = 0; i < number_of_formats && !found; i++) {\n\t\tif (supported_formats[i] == format) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tIA_CSS_ERROR(\"Requested format is not supported by binary\");\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\treturn 0;\n}\n\nstatic int load_video_binaries(struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_frame_info video_in_info, tnr_info,\n\t\t       *video_vf_info, video_bds_out_info, *pipe_out_info, *pipe_vf_out_info;\n\tbool online;\n\tint err = 0;\n\tbool continuous = pipe->stream->config.continuous;\n\tunsigned int i;\n\tunsigned int num_output_pins;\n\tstruct ia_css_frame_info video_bin_out_info;\n\tbool need_scaler = false;\n\tbool vf_res_different_than_output = false;\n\tbool need_vf_pp = false;\n\tint vf_ds_log2;\n\tstruct ia_css_video_settings *mycs  = &pipe->pipe_settings.video;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\tassert(pipe);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_VIDEO);\n\t \n\tif (mycs->video_binary.info)\n\t\treturn 0;\n\n\tonline = pipe->stream->config.online;\n\tpipe_out_info = &pipe->output_info[0];\n\tpipe_vf_out_info = &pipe->vf_output_info[0];\n\n\tassert(pipe_out_info);\n\n\t \n\terr = ia_css_util_check_input(&pipe->stream->config, false, false);\n\tif (err)\n\t\treturn err;\n\t \n\tif (online && pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY)\n\t\treturn -EINVAL;\n\tif (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0]) {\n\t\terr = ia_css_util_check_vf_out_info(pipe_out_info,\n\t\t\t\t\t\t    pipe_vf_out_info);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\terr = ia_css_frame_check_info(pipe_out_info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (pipe->out_yuv_ds_input_info.res.width)\n\t\tvideo_bin_out_info = pipe->out_yuv_ds_input_info;\n\telse\n\t\tvideo_bin_out_info = *pipe_out_info;\n\n\t \n\tif (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0]) {\n\t\tvideo_vf_info = pipe_vf_out_info;\n\t\tvf_res_different_than_output = (video_vf_info->res.width !=\n\t\t\t\t\t\tvideo_bin_out_info.res.width) ||\n\t\t\t\t\t       (video_vf_info->res.height != video_bin_out_info.res.height);\n\t} else {\n\t\tvideo_vf_info = NULL;\n\t}\n\n\tneed_scaler = need_downscaling(video_bin_out_info.res, pipe_out_info->res);\n\n\t \n\t \n\tif (need_scaler) {\n\t\tstruct ia_css_cas_binary_descr cas_scaler_descr = { };\n\n\t\t \n\t\t \n\t\tvideo_bin_out_info.format = IA_CSS_FRAME_FORMAT_NV12;\n\n\t\terr = ia_css_pipe_create_cas_scaler_desc_single_output(\n\t\t\t  &video_bin_out_info,\n\t\t\t  pipe_out_info,\n\t\t\t  NULL,\n\t\t\t  &cas_scaler_descr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmycs->num_yuv_scaler = cas_scaler_descr.num_stage;\n\t\tmycs->yuv_scaler_binary = kcalloc(cas_scaler_descr.num_stage,\n\t\t\t\t\t\t  sizeof(struct ia_css_binary),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!mycs->yuv_scaler_binary) {\n\t\t\terr = -ENOMEM;\n\t\t\treturn err;\n\t\t}\n\t\tmycs->is_output_stage = kcalloc(cas_scaler_descr.num_stage,\n\t\t\t\t\t\tsizeof(bool), GFP_KERNEL);\n\t\tif (!mycs->is_output_stage) {\n\t\t\terr = -ENOMEM;\n\t\t\treturn err;\n\t\t}\n\t\tfor (i = 0; i < cas_scaler_descr.num_stage; i++) {\n\t\t\tstruct ia_css_binary_descr yuv_scaler_descr;\n\n\t\t\tmycs->is_output_stage[i] = cas_scaler_descr.is_output_stage[i];\n\t\t\tia_css_pipe_get_yuvscaler_binarydesc(pipe,\n\t\t\t\t\t\t\t     &yuv_scaler_descr, &cas_scaler_descr.in_info[i],\n\t\t\t\t\t\t\t     &cas_scaler_descr.out_info[i],\n\t\t\t\t\t\t\t     &cas_scaler_descr.internal_out_info[i],\n\t\t\t\t\t\t\t     &cas_scaler_descr.vf_info[i]);\n\t\t\terr = ia_css_binary_find(&yuv_scaler_descr,\n\t\t\t\t\t\t &mycs->yuv_scaler_binary[i]);\n\t\t\tif (err) {\n\t\t\t\tkfree(mycs->is_output_stage);\n\t\t\t\tmycs->is_output_stage = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tia_css_pipe_destroy_cas_scaler_desc(&cas_scaler_descr);\n\t}\n\n\t{\n\t\tstruct ia_css_binary_descr video_descr;\n\t\tenum ia_css_frame_format vf_info_format;\n\n\t\terr = ia_css_pipe_get_video_binarydesc(pipe,\n\t\t\t\t\t\t       &video_descr, &video_in_info, &video_bds_out_info, &video_bin_out_info,\n\t\t\t\t\t\t       video_vf_info,\n\t\t\t\t\t\t       pipe->stream->config.left_padding);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\terr = ia_css_binary_find(&video_descr,\n\t\t\t\t\t &mycs->video_binary);\n\n\t\tif (err) {\n\t\t\t \n\t\t\tif (video_vf_info)\n\t\t\t\tneed_vf_pp = true;\n\t\t\telse\n\t\t\t\treturn err;\n\t\t} else if (video_vf_info) {\n\t\t\t \n\t\t\tnum_output_pins = mycs->video_binary.info->num_output_pins;\n\t\t\tvf_ds_log2 = mycs->video_binary.vf_downscale_log2;\n\n\t\t\t \n\t\t\tneed_vf_pp |= ((num_output_pins == 2) && vf_res_different_than_output);\n\n\t\t\t \n\t\t\tneed_vf_pp |= ((num_output_pins == 1) &&\n\t\t\t\t       ((video_vf_info->res.width << vf_ds_log2 != pipe_out_info->res.width) ||\n\t\t\t\t\t(video_vf_info->res.height << vf_ds_log2 != pipe_out_info->res.height)));\n\t\t}\n\n\t\tif (need_vf_pp) {\n\t\t\t \n\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t    \"load_video_binaries() need_vf_pp; find video binary with YUV_LINE again\\n\");\n\n\t\t\tvf_info_format = video_vf_info->format;\n\n\t\t\tif (!pipe->config.enable_vfpp_bci)\n\t\t\t\tia_css_frame_info_set_format(video_vf_info,\n\t\t\t\t\t\t\t     IA_CSS_FRAME_FORMAT_YUV_LINE);\n\n\t\t\tia_css_binary_destroy_isp_parameters(&mycs->video_binary);\n\n\t\t\terr = ia_css_binary_find(&video_descr,\n\t\t\t\t\t\t &mycs->video_binary);\n\n\t\t\t \n\t\t\tia_css_frame_info_set_format(video_vf_info,\n\t\t\t\t\t\t     vf_info_format);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (!mycs->video_binary.info->sp.enable.ref_frame)\n\t\tpipe->dvs_frame_delay = 0;\n\n\t \n\tpipe->num_invalid_frames = pipe->dvs_frame_delay;\n\tpipe->info.num_invalid_frames = pipe->num_invalid_frames;\n\n\t \n\tif (video_vf_info)\n\t\tpipe->num_invalid_frames *= 2;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"load_video_binaries() num_invalid_frames=%d dvs_frame_delay=%d\\n\",\n\t\t\t    pipe->num_invalid_frames, pipe->dvs_frame_delay);\n\n\t \n\tif (!IS_ISP2401) {\n\t\t \n\t\tif (!online && !continuous) {\n\t\t\t \n\t\t\terr = load_copy_binary(pipe,\n\t\t\t\t\t       &mycs->copy_binary,\n\t\t\t\t\t       &mycs->video_binary);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0] && need_vf_pp) {\n\t\tstruct ia_css_binary_descr vf_pp_descr;\n\n\t\tif (mycs->video_binary.vf_frame_info.format\n\t\t    == IA_CSS_FRAME_FORMAT_YUV_LINE) {\n\t\t\tia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,\n\t\t\t\t\t\t\t&mycs->video_binary.vf_frame_info,\n\t\t\t\t\t\t\tpipe_vf_out_info);\n\t\t} else {\n\t\t\t \n\t\t\tassert(pipe->config.enable_vfpp_bci);\n\t\t\tia_css_pipe_get_yuvscaler_binarydesc(pipe, &vf_pp_descr,\n\t\t\t\t\t\t\t     &mycs->video_binary.vf_frame_info,\n\t\t\t\t\t\t\t     pipe_vf_out_info, NULL, NULL);\n\t\t}\n\n\t\terr = ia_css_binary_find(&vf_pp_descr,\n\t\t\t\t\t &mycs->vf_pp_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = allocate_delay_frames(pipe);\n\n\tif (err)\n\t\treturn err;\n\n\tif (mycs->video_binary.info->sp.enable.block_output) {\n\t\ttnr_info = mycs->video_binary.out_frame_info[0];\n\n\t\t \n\t\ttnr_info.res.height = CEIL_MUL(tnr_info.res.height,\n\t\t\t\t\t       mycs->video_binary.info->sp.block.output_block_height);\n\t} else {\n\t\ttnr_info = mycs->video_binary.internal_frame_info;\n\t}\n\ttnr_info.format = IA_CSS_FRAME_FORMAT_YUV_LINE;\n\ttnr_info.raw_bit_depth = SH_CSS_TNR_BIT_DEPTH;\n\n\tfor (i = 0; i < NUM_VIDEO_TNR_FRAMES; i++) {\n\t\tif (mycs->tnr_frames[i]) {\n\t\t\tia_css_frame_free(mycs->tnr_frames[i]);\n\t\t\tmycs->tnr_frames[i] = NULL;\n\t\t}\n\t\terr = ia_css_frame_allocate_from_info(\n\t\t\t  &mycs->tnr_frames[i],\n\t\t\t  &tnr_info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tIA_CSS_LEAVE_PRIVATE(\"\");\n\treturn 0;\n}\n\nstatic int\nunload_video_binaries(struct ia_css_pipe *pipe)\n{\n\tunsigned int i;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p\", pipe);\n\n\tif ((!pipe) || (pipe->mode != IA_CSS_PIPE_ID_VIDEO)) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\tia_css_binary_unload(&pipe->pipe_settings.video.copy_binary);\n\tia_css_binary_unload(&pipe->pipe_settings.video.video_binary);\n\tia_css_binary_unload(&pipe->pipe_settings.video.vf_pp_binary);\n\n\tfor (i = 0; i < pipe->pipe_settings.video.num_yuv_scaler; i++)\n\t\tia_css_binary_unload(&pipe->pipe_settings.video.yuv_scaler_binary[i]);\n\n\tkfree(pipe->pipe_settings.video.is_output_stage);\n\tpipe->pipe_settings.video.is_output_stage = NULL;\n\tkfree(pipe->pipe_settings.video.yuv_scaler_binary);\n\tpipe->pipe_settings.video.yuv_scaler_binary = NULL;\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\treturn 0;\n}\n\nstatic int video_start(struct ia_css_pipe *pipe)\n{\n\tint err = 0;\n\tstruct ia_css_pipe *copy_pipe, *capture_pipe;\n\tenum sh_css_pipe_config_override copy_ovrd;\n\tenum ia_css_input_mode video_pipe_input_mode;\n\tunsigned int thread_id;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p\", pipe);\n\tif ((!pipe) || (pipe->mode != IA_CSS_PIPE_ID_VIDEO)) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tvideo_pipe_input_mode = pipe->stream->config.mode;\n\n\tcopy_pipe    = pipe->pipe_settings.video.copy_pipe;\n\tcapture_pipe = pipe->pipe_settings.video.capture_pipe;\n\n\tsh_css_metrics_start_frame();\n\n\t \n\n\terr = send_mipi_frames(pipe);\n\tif (err)\n\t\treturn err;\n\n\tsend_raw_frames(pipe);\n\n\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);\n\tcopy_ovrd = 1 << thread_id;\n\n\tif (pipe->stream->cont_capt) {\n\t\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(capture_pipe),\n\t\t\t\t\t\t    &thread_id);\n\t\tcopy_ovrd |= 1 << thread_id;\n\t}\n\n\t \n\tif (pipe->stream->config.continuous) {\n\t\tsh_css_sp_init_pipeline(&copy_pipe->pipeline,\n\t\t\t\t\tIA_CSS_PIPE_ID_COPY,\n\t\t\t\t\t(uint8_t)ia_css_pipe_get_pipe_num(copy_pipe),\n\t\t\t\t\tfalse,\n\t\t\t\t\tpipe->stream->config.pixels_per_clock == 2, false,\n\t\t\t\t\tfalse, pipe->required_bds_factor,\n\t\t\t\t\tcopy_ovrd,\n\t\t\t\t\tpipe->stream->config.mode,\n\t\t\t\t\t&pipe->stream->config.metadata_config,\n\t\t\t\t\t&pipe->stream->info.metadata_info,\n\t\t\t\t\tpipe->stream->config.source.port.port);\n\n\t\t \n\t\tvideo_pipe_input_mode = IA_CSS_INPUT_MODE_MEMORY;\n\t}\n\n\t \n\tif (pipe->stream->cont_capt) {\n\t\tsh_css_sp_init_pipeline(&capture_pipe->pipeline,\n\t\t\t\t\tIA_CSS_PIPE_ID_CAPTURE,\n\t\t\t\t\t(uint8_t)ia_css_pipe_get_pipe_num(capture_pipe),\n\t\t\t\t\tcapture_pipe->config.default_capture_config.enable_xnr != 0,\n\t\t\t\t\tcapture_pipe->stream->config.pixels_per_clock == 2,\n\t\t\t\t\ttrue,  \n\t\t\t\t\tfalse,  \n\t\t\t\t\tcapture_pipe->required_bds_factor,\n\t\t\t\t\t0,\n\t\t\t\t\tIA_CSS_INPUT_MODE_MEMORY,\n\t\t\t\t\t&pipe->stream->config.metadata_config,\n\t\t\t\t\t&pipe->stream->info.metadata_info,\n\t\t\t\t\t(enum mipi_port_id)0);\n\t}\n\n\tstart_pipe(pipe, copy_ovrd, video_pipe_input_mode);\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\nstatic\nint sh_css_pipe_get_viewfinder_frame_info(\n    struct ia_css_pipe *pipe,\n    struct ia_css_frame_info *info,\n    unsigned int idx)\n{\n\tassert(pipe);\n\tassert(info);\n\n\t \n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_pipe_get_viewfinder_frame_info() enter: void\\n\");\n\n\tif (pipe->mode == IA_CSS_PIPE_ID_CAPTURE &&\n\t    (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW ||\n\t     pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER))\n\t\treturn -EINVAL;\n\t \n\t*info = pipe->vf_output_info[idx];\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_pipe_get_viewfinder_frame_info() leave: \\\n\t\tinfo.res.width=%d, info.res.height=%d, \\\n\t\tinfo.padded_width=%d, info.format=%d, \\\n\t\tinfo.raw_bit_depth=%d, info.raw_bayer_order=%d\\n\",\n\t\t\t    info->res.width, info->res.height,\n\t\t\t    info->padded_width, info->format,\n\t\t\t    info->raw_bit_depth, info->raw_bayer_order);\n\n\treturn 0;\n}\n\nstatic int\nsh_css_pipe_configure_viewfinder(struct ia_css_pipe *pipe, unsigned int width,\n\t\t\t\t unsigned int height, unsigned int min_width,\n\t\t\t\t enum ia_css_frame_format format,\n\t\t\t\t unsigned int idx)\n{\n\tint err = 0;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p, width = %d, height = %d, min_width = %d, format = %d, idx = %d\\n\",\n\t\t\t     pipe, width, height, min_width, format, idx);\n\n\tif (!pipe) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\terr = ia_css_util_check_res(width, height);\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\tif (pipe->vf_output_info[idx].res.width != width ||\n\t    pipe->vf_output_info[idx].res.height != height ||\n\t    pipe->vf_output_info[idx].format != format)\n\t\tia_css_frame_info_init(&pipe->vf_output_info[idx], width, height,\n\t\t\t\t       format, min_width);\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\treturn 0;\n}\n\nstatic int load_copy_binaries(struct ia_css_pipe *pipe)\n{\n\tint err = 0;\n\n\tassert(pipe);\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\n\tassert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE ||\n\t       pipe->mode == IA_CSS_PIPE_ID_COPY);\n\tif (pipe->pipe_settings.capture.copy_binary.info)\n\t\treturn 0;\n\n\terr = ia_css_frame_check_info(&pipe->output_info[0]);\n\tif (err)\n\t\tgoto ERR;\n\n\terr = verify_copy_out_frame_format(pipe);\n\tif (err)\n\t\tgoto ERR;\n\n\terr = load_copy_binary(pipe,\n\t\t\t       &pipe->pipe_settings.capture.copy_binary,\n\t\t\t       NULL);\n\nERR:\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\nstatic bool need_capture_pp(\n    const struct ia_css_pipe *pipe)\n{\n\tconst struct ia_css_frame_info *out_info = &pipe->output_info[0];\n\n\tIA_CSS_ENTER_LEAVE_PRIVATE(\"\");\n\tassert(pipe);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE);\n\n\t/* determine whether we need to use the capture_pp binary.\n\t * This is needed for:\n\t *   1. XNR or\n\t *   2. Digital Zoom or\n\t *   3. YUV downscaling\n\t */\n\tif (pipe->out_yuv_ds_input_info.res.width &&\n\t    ((pipe->out_yuv_ds_input_info.res.width != out_info->res.width) ||\n\t     (pipe->out_yuv_ds_input_info.res.height != out_info->res.height)))\n\t\treturn true;\n\n\tif (pipe->config.default_capture_config.enable_xnr != 0)\n\t\treturn true;\n\n\tif ((pipe->stream->isp_params_configs->dz_config.dx < HRT_GDC_N) ||\n\t    (pipe->stream->isp_params_configs->dz_config.dy < HRT_GDC_N) ||\n\t    pipe->config.enable_dz)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool need_capt_ldc(\n    const struct ia_css_pipe *pipe)\n{\n\tIA_CSS_ENTER_LEAVE_PRIVATE(\"\");\n\tassert(pipe);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE);\n\treturn (pipe->extra_config.enable_dvs_6axis) ? true : false;\n}\n\nstatic int set_num_primary_stages(unsigned int *num,\n\t\t\t\t  enum ia_css_pipe_version version)\n{\n\tint err = 0;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tswitch (version) {\n\tcase IA_CSS_PIPE_VERSION_2_6_1:\n\t\t*num = NUM_PRIMARY_HQ_STAGES;\n\t\tbreak;\n\tcase IA_CSS_PIPE_VERSION_2_2:\n\tcase IA_CSS_PIPE_VERSION_1:\n\t\t*num = NUM_PRIMARY_STAGES;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int load_primary_binaries(\n    struct ia_css_pipe *pipe)\n{\n\tbool online = false;\n\tbool need_pp = false;\n\tbool need_isp_copy_binary = false;\n\tbool need_ldc = false;\n\tbool sensor = false;\n\tbool memory, continuous;\n\tstruct ia_css_frame_info prim_in_info,\n\t\t       prim_out_info,\n\t\t       capt_pp_out_info, vf_info,\n\t\t       *vf_pp_in_info, *pipe_out_info,\n\t\t       *pipe_vf_out_info, *capt_pp_in_info,\n\t\t       capt_ldc_out_info;\n\tint err = 0;\n\tstruct ia_css_capture_settings *mycs;\n\tunsigned int i;\n\tbool need_extra_yuv_scaler = false;\n\tstruct ia_css_binary_descr prim_descr[MAX_NUM_PRIMARY_STAGES];\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\tassert(pipe);\n\tassert(pipe->stream);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE ||\n\t       pipe->mode == IA_CSS_PIPE_ID_COPY);\n\n\tonline = pipe->stream->config.online;\n\tsensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR);\n\tmemory = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;\n\tcontinuous = pipe->stream->config.continuous;\n\n\tmycs = &pipe->pipe_settings.capture;\n\tpipe_out_info = &pipe->output_info[0];\n\tpipe_vf_out_info = &pipe->vf_output_info[0];\n\n\tif (mycs->primary_binary[0].info)\n\t\treturn 0;\n\n\terr = set_num_primary_stages(&mycs->num_primary_stage,\n\t\t\t\t     pipe->config.isp_pipe_version);\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\n\tif (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0]) {\n\t\terr = ia_css_util_check_vf_out_info(pipe_out_info, pipe_vf_out_info);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\terr = ia_css_frame_check_info(pipe_out_info);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\tneed_pp = need_capture_pp(pipe);\n\n\t/*\n\t * we use the vf output info to get the primary/capture_pp binary\n\t * configured for vf_veceven. It will select the closest downscaling\n\t * factor.\n\t */\n\tvf_info = *pipe_vf_out_info;\n\n\t/*\n\t * WARNING: The #if def flag has been added below as a\n\t * temporary solution to solve the problem of enabling the\n\t * view finder in a single binary in a capture flow. The\n\t * vf-pp stage has been removed for Skycam in the solution\n\t * provided. The vf-pp stage should be re-introduced when\n\t * required. This should not be considered as a clean solution.\n\t * Proper investigation should be done to come up with the clean\n\t * solution.\n\t */\n\tia_css_frame_info_set_format(&vf_info, IA_CSS_FRAME_FORMAT_YUV_LINE);\n\n\t/*\n\t * TODO: All this yuv_scaler and capturepp calculation logic\n\t * can be shared later. Capture_pp is also a yuv_scale binary\n\t * with extra XNR funcionality. Therefore, it can be made as the\n\t * first step of the cascade.\n\t */\n\tcapt_pp_out_info = pipe->out_yuv_ds_input_info;\n\tcapt_pp_out_info.format = IA_CSS_FRAME_FORMAT_YUV420;\n\tcapt_pp_out_info.res.width  /= MAX_PREFERRED_YUV_DS_PER_STEP;\n\tcapt_pp_out_info.res.height /= MAX_PREFERRED_YUV_DS_PER_STEP;\n\tia_css_frame_info_set_width(&capt_pp_out_info, capt_pp_out_info.res.width, 0);\n\n\tneed_extra_yuv_scaler = need_downscaling(capt_pp_out_info.res,\n\t\t\t\t\t\t pipe_out_info->res);\n\n\tif (need_extra_yuv_scaler) {\n\t\tstruct ia_css_cas_binary_descr cas_scaler_descr = { };\n\n\t\terr = ia_css_pipe_create_cas_scaler_desc_single_output(\n\t\t\t  &capt_pp_out_info,\n\t\t\t  pipe_out_info,\n\t\t\t  NULL,\n\t\t\t  &cas_scaler_descr);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t\tmycs->num_yuv_scaler = cas_scaler_descr.num_stage;\n\t\tmycs->yuv_scaler_binary = kcalloc(cas_scaler_descr.num_stage,\n\t\t\t\t\t\t  sizeof(struct ia_css_binary),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!mycs->yuv_scaler_binary) {\n\t\t\terr = -ENOMEM;\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t\tmycs->is_output_stage = kcalloc(cas_scaler_descr.num_stage,\n\t\t\t\t\t\tsizeof(bool), GFP_KERNEL);\n\t\tif (!mycs->is_output_stage) {\n\t\t\terr = -ENOMEM;\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t\tfor (i = 0; i < cas_scaler_descr.num_stage; i++) {\n\t\t\tstruct ia_css_binary_descr yuv_scaler_descr;\n\n\t\t\tmycs->is_output_stage[i] = cas_scaler_descr.is_output_stage[i];\n\t\t\tia_css_pipe_get_yuvscaler_binarydesc(pipe,\n\t\t\t\t\t\t\t     &yuv_scaler_descr, &cas_scaler_descr.in_info[i],\n\t\t\t\t\t\t\t     &cas_scaler_descr.out_info[i],\n\t\t\t\t\t\t\t     &cas_scaler_descr.internal_out_info[i],\n\t\t\t\t\t\t\t     &cas_scaler_descr.vf_info[i]);\n\t\t\terr = ia_css_binary_find(&yuv_scaler_descr,\n\t\t\t\t\t\t &mycs->yuv_scaler_binary[i]);\n\t\t\tif (err) {\n\t\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tia_css_pipe_destroy_cas_scaler_desc(&cas_scaler_descr);\n\n\t} else {\n\t\tcapt_pp_out_info = pipe->output_info[0];\n\t}\n\n\t/* TODO Do we disable ldc for skycam */\n\tneed_ldc = need_capt_ldc(pipe);\n\n\t/* we build up the pipeline starting at the end */\n\t/* Capture post-processing */\n\tif (need_pp) {\n\t\tstruct ia_css_binary_descr capture_pp_descr;\n\n\t\tcapt_pp_in_info = need_ldc ? &capt_ldc_out_info : &prim_out_info;\n\n\t\tia_css_pipe_get_capturepp_binarydesc(pipe,\n\t\t\t\t\t\t     &capture_pp_descr,\n\t\t\t\t\t\t     capt_pp_in_info,\n\t\t\t\t\t\t     &capt_pp_out_info,\n\t\t\t\t\t\t     &vf_info);\n\n\t\terr = ia_css_binary_find(&capture_pp_descr,\n\t\t\t\t\t &mycs->capture_pp_binary);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (need_ldc) {\n\t\t\tstruct ia_css_binary_descr capt_ldc_descr;\n\n\t\t\tia_css_pipe_get_ldc_binarydesc(pipe,\n\t\t\t\t\t\t       &capt_ldc_descr,\n\t\t\t\t\t\t       &prim_out_info,\n\t\t\t\t\t\t       &capt_ldc_out_info);\n\n\t\t\terr = ia_css_binary_find(&capt_ldc_descr,\n\t\t\t\t\t\t &mycs->capture_ldc_binary);\n\t\t\tif (err) {\n\t\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprim_out_info = *pipe_out_info;\n\t}\n\n\t/* Primary */\n\tfor (i = 0; i < mycs->num_primary_stage; i++) {\n\t\tstruct ia_css_frame_info *local_vf_info = NULL;\n\n\t\tif (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0] &&\n\t\t    (i == mycs->num_primary_stage - 1))\n\t\t\tlocal_vf_info = &vf_info;\n\t\tia_css_pipe_get_primary_binarydesc(pipe, &prim_descr[i],\n\t\t\t\t\t\t   &prim_in_info, &prim_out_info,\n\t\t\t\t\t\t   local_vf_info, i);\n\t\terr = ia_css_binary_find(&prim_descr[i], &mycs->primary_binary[i]);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* Viewfinder post-processing */\n\tif (need_pp)\n\t\tvf_pp_in_info = &mycs->capture_pp_binary.vf_frame_info;\n\telse\n\t\tvf_pp_in_info = &mycs->primary_binary[mycs->num_primary_stage - 1].vf_frame_info;\n\n\t/*\n\t * WARNING: The #if def flag has been added below as a\n\t * temporary solution to solve the problem of enabling the\n\t * view finder in a single binary in a capture flow. The\n\t * vf-pp stage has been removed for Skycam in the solution\n\t * provided. The vf-pp stage should be re-introduced when\n\t * required. Thisshould not be considered as a clean solution.\n\t * Proper  * investigation should be done to come up with the clean\n\t * solution.\n\t */\n\tif (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0]) {\n\t\tstruct ia_css_binary_descr vf_pp_descr;\n\n\t\tia_css_pipe_get_vfpp_binarydesc(pipe,\n\t\t\t\t\t\t&vf_pp_descr, vf_pp_in_info, pipe_vf_out_info);\n\t\terr = ia_css_binary_find(&vf_pp_descr, &mycs->vf_pp_binary);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = allocate_delay_frames(pipe);\n\n\tif (err)\n\t\treturn err;\n\n\tif (IS_ISP2401)\n\t\t/*\n\t\t * When the input system is 2401, only the Direct Sensor Mode\n\t\t * Offline Capture uses the ISP copy binary.\n\t\t */\n\t\tneed_isp_copy_binary = !online && sensor;\n\telse\n\t\tneed_isp_copy_binary = !online && !continuous && !memory;\n\n\t/* ISP Copy */\n\tif (need_isp_copy_binary) {\n\t\terr = load_copy_binary(pipe,\n\t\t\t\t       &mycs->copy_binary,\n\t\t\t\t       &mycs->primary_binary[0]);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nallocate_delay_frames(struct ia_css_pipe *pipe)\n{\n\tunsigned int num_delay_frames = 0, i = 0;\n\tunsigned int dvs_frame_delay = 0;\n\tstruct ia_css_frame_info ref_info;\n\tint err = 0;\n\tenum ia_css_pipe_id mode = IA_CSS_PIPE_ID_VIDEO;\n\tstruct ia_css_frame **delay_frames = NULL;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\n\tif (!pipe) {\n\t\tIA_CSS_ERROR(\"Invalid args - pipe %p\", pipe);\n\t\treturn -EINVAL;\n\t}\n\n\tmode = pipe->mode;\n\tdvs_frame_delay = pipe->dvs_frame_delay;\n\n\tif (dvs_frame_delay > 0)\n\t\tnum_delay_frames = dvs_frame_delay + 1;\n\n\tswitch (mode) {\n\tcase IA_CSS_PIPE_ID_CAPTURE: {\n\t\tstruct ia_css_capture_settings *mycs_capture = &pipe->pipe_settings.capture;\n\t\t(void)mycs_capture;\n\t\treturn err;\n\t}\n\tbreak;\n\tcase IA_CSS_PIPE_ID_VIDEO: {\n\t\tstruct ia_css_video_settings *mycs_video = &pipe->pipe_settings.video;\n\n\t\tref_info = mycs_video->video_binary.internal_frame_info;\n\n\t\t/*\n\t\t * The ref frame expects\n\t\t * 1. Y plane\n\t\t * 2. UV plane with line interleaving, like below\n\t\t *\tUUUUUU(width/2 times) VVVVVVVV..(width/2 times)\n\t\t *\n\t\t * This format is not YUV420(which has Y, U and V planes).\n\t\t * Its closer to NV12, except that the UV plane has UV\n\t\t * interleaving, like UVUVUVUVUVUVUVUVU...\n\t\t *\n\t\t * TODO: make this ref_frame format as a separate frame format\n\t\t */\n\t\tref_info.format        = IA_CSS_FRAME_FORMAT_NV12;\n\t\tdelay_frames = mycs_video->delay_frames;\n\t}\n\tbreak;\n\tcase IA_CSS_PIPE_ID_PREVIEW: {\n\t\tstruct ia_css_preview_settings *mycs_preview = &pipe->pipe_settings.preview;\n\n\t\tref_info = mycs_preview->preview_binary.internal_frame_info;\n\n\t\t/*\n\t\t * The ref frame expects\n\t\t * 1. Y plane\n\t\t * 2. UV plane with line interleaving, like below\n\t\t *\tUUUUUU(width/2 times) VVVVVVVV..(width/2 times)\n\t\t *\n\t\t * This format is not YUV420(which has Y, U and V planes).\n\t\t * Its closer to NV12, except that the UV plane has UV\n\t\t * interleaving, like UVUVUVUVUVUVUVUVU...\n\t\t *\n\t\t * TODO: make this ref_frame format as a separate frame format\n\t\t */\n\t\tref_info.format        = IA_CSS_FRAME_FORMAT_NV12;\n\t\tdelay_frames = mycs_preview->delay_frames;\n\t}\n\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tref_info.raw_bit_depth = SH_CSS_REF_BIT_DEPTH;\n\n\tassert(num_delay_frames <= MAX_NUM_VIDEO_DELAY_FRAMES);\n\tfor (i = 0; i < num_delay_frames; i++) {\n\t\terr = ia_css_frame_allocate_from_info(&delay_frames[i],\t&ref_info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tIA_CSS_LEAVE_PRIVATE(\"\");\n\treturn 0;\n}\n\nstatic int load_advanced_binaries(struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_frame_info pre_in_info, gdc_in_info,\n\t\t\tpost_in_info, post_out_info,\n\t\t\tvf_info, *vf_pp_in_info, *pipe_out_info,\n\t\t\t*pipe_vf_out_info;\n\tbool need_pp;\n\tbool need_isp_copy = true;\n\tint err = 0;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\n\tassert(pipe);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE ||\n\t       pipe->mode == IA_CSS_PIPE_ID_COPY);\n\tif (pipe->pipe_settings.capture.pre_isp_binary.info)\n\t\treturn 0;\n\tpipe_out_info = &pipe->output_info[0];\n\tpipe_vf_out_info = &pipe->vf_output_info[0];\n\n\tvf_info = *pipe_vf_out_info;\n\terr = ia_css_util_check_vf_out_info(pipe_out_info, &vf_info);\n\tif (err)\n\t\treturn err;\n\tneed_pp = need_capture_pp(pipe);\n\n\tia_css_frame_info_set_format(&vf_info,\n\t\t\t\t     IA_CSS_FRAME_FORMAT_YUV_LINE);\n\n\t/* we build up the pipeline starting at the end */\n\t/* Capture post-processing */\n\tif (need_pp) {\n\t\tstruct ia_css_binary_descr capture_pp_descr;\n\n\t\tia_css_pipe_get_capturepp_binarydesc(pipe, &capture_pp_descr,\n\t\t\t\t\t\t     &post_out_info,\n\t\t\t\t\t\t     pipe_out_info, &vf_info);\n\t\terr = ia_css_binary_find(&capture_pp_descr,\n\t\t\t\t\t &pipe->pipe_settings.capture.capture_pp_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tpost_out_info = *pipe_out_info;\n\t}\n\n\t/* Post-gdc */\n\t{\n\t\tstruct ia_css_binary_descr post_gdc_descr;\n\n\t\tia_css_pipe_get_post_gdc_binarydesc(pipe, &post_gdc_descr,\n\t\t\t\t\t\t    &post_in_info,\n\t\t\t\t\t\t    &post_out_info, &vf_info);\n\t\terr = ia_css_binary_find(&post_gdc_descr,\n\t\t\t\t\t &pipe->pipe_settings.capture.post_isp_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Gdc */\n\t{\n\t\tstruct ia_css_binary_descr gdc_descr;\n\n\t\tia_css_pipe_get_gdc_binarydesc(pipe, &gdc_descr, &gdc_in_info,\n\t\t\t\t\t       &pipe->pipe_settings.capture.post_isp_binary.in_frame_info);\n\t\terr = ia_css_binary_find(&gdc_descr,\n\t\t\t\t\t &pipe->pipe_settings.capture.anr_gdc_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tpipe->pipe_settings.capture.anr_gdc_binary.left_padding =\n\t    pipe->pipe_settings.capture.post_isp_binary.left_padding;\n\n\t/* Pre-gdc */\n\t{\n\t\tstruct ia_css_binary_descr pre_gdc_descr;\n\n\t\tia_css_pipe_get_pre_gdc_binarydesc(pipe, &pre_gdc_descr, &pre_in_info,\n\t\t\t\t\t\t   &pipe->pipe_settings.capture.anr_gdc_binary.in_frame_info);\n\t\terr = ia_css_binary_find(&pre_gdc_descr,\n\t\t\t\t\t &pipe->pipe_settings.capture.pre_isp_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tpipe->pipe_settings.capture.pre_isp_binary.left_padding =\n\t    pipe->pipe_settings.capture.anr_gdc_binary.left_padding;\n\n\t/* Viewfinder post-processing */\n\tif (need_pp) {\n\t\tvf_pp_in_info =\n\t\t    &pipe->pipe_settings.capture.capture_pp_binary.vf_frame_info;\n\t} else {\n\t\tvf_pp_in_info =\n\t\t    &pipe->pipe_settings.capture.post_isp_binary.vf_frame_info;\n\t}\n\n\t{\n\t\tstruct ia_css_binary_descr vf_pp_descr;\n\n\t\tia_css_pipe_get_vfpp_binarydesc(pipe,\n\t\t\t\t\t\t&vf_pp_descr, vf_pp_in_info, pipe_vf_out_info);\n\t\terr = ia_css_binary_find(&vf_pp_descr,\n\t\t\t\t\t &pipe->pipe_settings.capture.vf_pp_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Copy */\n\tif (IS_ISP2401)\n\t\t/* For CSI2+, only the direct sensor mode/online requires ISP copy */\n\t\tneed_isp_copy = pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR;\n\n\tif (need_isp_copy)\n\t\tload_copy_binary(pipe,\n\t\t\t\t &pipe->pipe_settings.capture.copy_binary,\n\t\t\t\t &pipe->pipe_settings.capture.pre_isp_binary);\n\n\treturn err;\n}\n\nstatic int load_bayer_isp_binaries(struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_frame_info pre_isp_in_info, *pipe_out_info;\n\tint err = 0;\n\tstruct ia_css_binary_descr pre_de_descr;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\tassert(pipe);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE ||\n\t       pipe->mode == IA_CSS_PIPE_ID_COPY);\n\tpipe_out_info = &pipe->output_info[0];\n\n\tif (pipe->pipe_settings.capture.pre_isp_binary.info)\n\t\treturn 0;\n\n\terr = ia_css_frame_check_info(pipe_out_info);\n\tif (err)\n\t\treturn err;\n\n\tia_css_pipe_get_pre_de_binarydesc(pipe, &pre_de_descr,\n\t\t\t\t\t  &pre_isp_in_info,\n\t\t\t\t\t  pipe_out_info);\n\n\terr = ia_css_binary_find(&pre_de_descr,\n\t\t\t\t &pipe->pipe_settings.capture.pre_isp_binary);\n\n\treturn err;\n}\n\nstatic int load_low_light_binaries(struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_frame_info pre_in_info, anr_in_info,\n\t\t\tpost_in_info, post_out_info,\n\t\t\tvf_info, *pipe_vf_out_info, *pipe_out_info,\n\t\t\t*vf_pp_in_info;\n\tbool need_pp;\n\tbool need_isp_copy = true;\n\tint err = 0;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\tassert(pipe);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE ||\n\t       pipe->mode == IA_CSS_PIPE_ID_COPY);\n\n\tif (pipe->pipe_settings.capture.pre_isp_binary.info)\n\t\treturn 0;\n\tpipe_vf_out_info = &pipe->vf_output_info[0];\n\tpipe_out_info = &pipe->output_info[0];\n\n\tvf_info = *pipe_vf_out_info;\n\terr = ia_css_util_check_vf_out_info(pipe_out_info,\n\t\t\t\t\t    &vf_info);\n\tif (err)\n\t\treturn err;\n\tneed_pp = need_capture_pp(pipe);\n\n\tia_css_frame_info_set_format(&vf_info,\n\t\t\t\t     IA_CSS_FRAME_FORMAT_YUV_LINE);\n\n\t/* we build up the pipeline starting at the end */\n\t/* Capture post-processing */\n\tif (need_pp) {\n\t\tstruct ia_css_binary_descr capture_pp_descr;\n\n\t\tia_css_pipe_get_capturepp_binarydesc(pipe, &capture_pp_descr,\n\t\t\t\t\t\t     &post_out_info,\n\t\t\t\t\t\t     pipe_out_info, &vf_info);\n\t\terr = ia_css_binary_find(&capture_pp_descr,\n\t\t\t\t\t &pipe->pipe_settings.capture.capture_pp_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tpost_out_info = *pipe_out_info;\n\t}\n\n\t/* Post-anr */\n\t{\n\t\tstruct ia_css_binary_descr post_anr_descr;\n\n\t\tia_css_pipe_get_post_anr_binarydesc(pipe,\n\t\t\t\t\t\t    &post_anr_descr, &post_in_info, &post_out_info, &vf_info);\n\t\terr = ia_css_binary_find(&post_anr_descr,\n\t\t\t\t\t &pipe->pipe_settings.capture.post_isp_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Anr */\n\t{\n\t\tstruct ia_css_binary_descr anr_descr;\n\n\t\tia_css_pipe_get_anr_binarydesc(pipe, &anr_descr, &anr_in_info,\n\t\t\t\t\t       &pipe->pipe_settings.capture.post_isp_binary.in_frame_info);\n\t\terr = ia_css_binary_find(&anr_descr,\n\t\t\t\t\t &pipe->pipe_settings.capture.anr_gdc_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tpipe->pipe_settings.capture.anr_gdc_binary.left_padding =\n\t    pipe->pipe_settings.capture.post_isp_binary.left_padding;\n\n\t/* Pre-anr */\n\t{\n\t\tstruct ia_css_binary_descr pre_anr_descr;\n\n\t\tia_css_pipe_get_pre_anr_binarydesc(pipe, &pre_anr_descr, &pre_in_info,\n\t\t\t\t\t\t   &pipe->pipe_settings.capture.anr_gdc_binary.in_frame_info);\n\t\terr = ia_css_binary_find(&pre_anr_descr,\n\t\t\t\t\t &pipe->pipe_settings.capture.pre_isp_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tpipe->pipe_settings.capture.pre_isp_binary.left_padding =\n\t    pipe->pipe_settings.capture.anr_gdc_binary.left_padding;\n\n\t/* Viewfinder post-processing */\n\tif (need_pp) {\n\t\tvf_pp_in_info =\n\t\t    &pipe->pipe_settings.capture.capture_pp_binary.vf_frame_info;\n\t} else {\n\t\tvf_pp_in_info =\n\t\t    &pipe->pipe_settings.capture.post_isp_binary.vf_frame_info;\n\t}\n\n\t{\n\t\tstruct ia_css_binary_descr vf_pp_descr;\n\n\t\tia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,\n\t\t\t\t\t\tvf_pp_in_info, pipe_vf_out_info);\n\t\terr = ia_css_binary_find(&vf_pp_descr,\n\t\t\t\t\t &pipe->pipe_settings.capture.vf_pp_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Copy */\n\tif (IS_ISP2401)\n\t\t/* For CSI2+, only the direct sensor mode/online requires ISP copy */\n\t\tneed_isp_copy = pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR;\n\n\tif (need_isp_copy)\n\t\terr = load_copy_binary(pipe,\n\t\t\t\t       &pipe->pipe_settings.capture.copy_binary,\n\t\t\t\t       &pipe->pipe_settings.capture.pre_isp_binary);\n\n\treturn err;\n}\n\nstatic bool copy_on_sp(struct ia_css_pipe *pipe)\n{\n\tbool rval;\n\n\tassert(pipe);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, \"copy_on_sp() enter:\\n\");\n\n\trval = true;\n\n\trval &=\t(pipe->mode == IA_CSS_PIPE_ID_CAPTURE);\n\n\trval &= (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW);\n\n\trval &= ((pipe->stream->config.input_config.format ==\n\t\t    ATOMISP_INPUT_FORMAT_BINARY_8) ||\n\t\t    (pipe->config.mode == IA_CSS_PIPE_MODE_COPY));\n\n\treturn rval;\n}\n\nstatic int load_capture_binaries(struct ia_css_pipe *pipe)\n{\n\tint err = 0;\n\tbool must_be_raw;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\tassert(pipe);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE ||\n\t       pipe->mode == IA_CSS_PIPE_ID_COPY);\n\n\tif (pipe->pipe_settings.capture.primary_binary[0].info) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\t\treturn 0;\n\t}\n\n\t/* in primary, advanced,low light or bayer,\n\t\t\t\t\t\tthe input format must be raw */\n\tmust_be_raw =\n\t    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_ADVANCED ||\n\t    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER ||\n\t    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT;\n\terr = ia_css_util_check_input(&pipe->stream->config, must_be_raw, false);\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\tif (copy_on_sp(pipe) &&\n\t    pipe->stream->config.input_config.format == ATOMISP_INPUT_FORMAT_BINARY_8) {\n\t\tia_css_frame_info_init(\n\t\t    &pipe->output_info[0],\n\t\t    JPEG_BYTES,\n\t\t    1,\n\t\t    IA_CSS_FRAME_FORMAT_BINARY_8,\n\t\t    0);\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\t\treturn 0;\n\t}\n\n\tswitch (pipe->config.default_capture_config.mode) {\n\tcase IA_CSS_CAPTURE_MODE_RAW:\n\t\terr = load_copy_binaries(pipe);\n\t\tif (!err && IS_ISP2401)\n\t\t\tpipe->pipe_settings.capture.copy_binary.online = pipe->stream->config.online;\n\n\t\tbreak;\n\tcase IA_CSS_CAPTURE_MODE_BAYER:\n\t\terr = load_bayer_isp_binaries(pipe);\n\t\tbreak;\n\tcase IA_CSS_CAPTURE_MODE_PRIMARY:\n\t\terr = load_primary_binaries(pipe);\n\t\tbreak;\n\tcase IA_CSS_CAPTURE_MODE_ADVANCED:\n\t\terr = load_advanced_binaries(pipe);\n\t\tbreak;\n\tcase IA_CSS_CAPTURE_MODE_LOW_LIGHT:\n\t\terr = load_low_light_binaries(pipe);\n\t\tbreak;\n\t}\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\nstatic int\nunload_capture_binaries(struct ia_css_pipe *pipe)\n{\n\tunsigned int i;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p\", pipe);\n\n\tif (!pipe || (pipe->mode != IA_CSS_PIPE_ID_CAPTURE &&\n\t\t      pipe->mode != IA_CSS_PIPE_ID_COPY)) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\tia_css_binary_unload(&pipe->pipe_settings.capture.copy_binary);\n\tfor (i = 0; i < MAX_NUM_PRIMARY_STAGES; i++)\n\t\tia_css_binary_unload(&pipe->pipe_settings.capture.primary_binary[i]);\n\tia_css_binary_unload(&pipe->pipe_settings.capture.pre_isp_binary);\n\tia_css_binary_unload(&pipe->pipe_settings.capture.anr_gdc_binary);\n\tia_css_binary_unload(&pipe->pipe_settings.capture.post_isp_binary);\n\tia_css_binary_unload(&pipe->pipe_settings.capture.capture_pp_binary);\n\tia_css_binary_unload(&pipe->pipe_settings.capture.capture_ldc_binary);\n\tia_css_binary_unload(&pipe->pipe_settings.capture.vf_pp_binary);\n\n\tfor (i = 0; i < pipe->pipe_settings.capture.num_yuv_scaler; i++)\n\t\tia_css_binary_unload(&pipe->pipe_settings.capture.yuv_scaler_binary[i]);\n\n\tkfree(pipe->pipe_settings.capture.is_output_stage);\n\tpipe->pipe_settings.capture.is_output_stage = NULL;\n\tkfree(pipe->pipe_settings.capture.yuv_scaler_binary);\n\tpipe->pipe_settings.capture.yuv_scaler_binary = NULL;\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\treturn 0;\n}\n\nstatic bool\nneed_downscaling(const struct ia_css_resolution in_res,\n\t\t const struct ia_css_resolution out_res)\n{\n\tif (in_res.width > out_res.width || in_res.height > out_res.height)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool\nneed_yuv_scaler_stage(const struct ia_css_pipe *pipe)\n{\n\tunsigned int i;\n\tstruct ia_css_resolution in_res, out_res;\n\n\tbool need_format_conversion = false;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\tassert(pipe);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_YUVPP);\n\n\t/* TODO: make generic function */\n\tneed_format_conversion =\n\t    ((pipe->stream->config.input_config.format ==\n\t\tATOMISP_INPUT_FORMAT_YUV420_8_LEGACY) &&\n\t\t(pipe->output_info[0].format != IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8));\n\n\tin_res = pipe->config.input_effective_res;\n\n\tif (pipe->config.enable_dz)\n\t\treturn true;\n\n\tif ((pipe->output_info[0].res.width != 0) && need_format_conversion)\n\t\treturn true;\n\n\tfor (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {\n\t\tout_res = pipe->output_info[i].res;\n\n\t\t/* A non-zero width means it is a valid output port */\n\t\tif ((out_res.width != 0) && need_downscaling(in_res, out_res))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * TODO: it is temporarily created from ia_css_pipe_create_cas_scaler_desc\n * which has some hard-coded knowledge which prevents reuse of the function.\n * Later, merge this with ia_css_pipe_create_cas_scaler_desc\n */\nstatic int ia_css_pipe_create_cas_scaler_desc_single_output(\n\t    struct ia_css_frame_info *cas_scaler_in_info,\n\t    struct ia_css_frame_info *cas_scaler_out_info,\n\t    struct ia_css_frame_info *cas_scaler_vf_info,\n\t    struct ia_css_cas_binary_descr *descr)\n{\n\tunsigned int i;\n\tunsigned int hor_ds_factor = 0, ver_ds_factor = 0;\n\tint err = 0;\n\tstruct ia_css_frame_info tmp_in_info;\n\n\tunsigned int max_scale_factor_per_stage = MAX_PREFERRED_YUV_DS_PER_STEP;\n\n\tassert(cas_scaler_in_info);\n\tassert(cas_scaler_out_info);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"ia_css_pipe_create_cas_scaler_desc() enter:\\n\");\n\n\t/* We assume that this function is used only for single output port case. */\n\tdescr->num_output_stage = 1;\n\n\thor_ds_factor = CEIL_DIV(cas_scaler_in_info->res.width,\n\t\t\t\t cas_scaler_out_info->res.width);\n\tver_ds_factor = CEIL_DIV(cas_scaler_in_info->res.height,\n\t\t\t\t cas_scaler_out_info->res.height);\n\t/* use the same horizontal and vertical downscaling factor for simplicity */\n\tassert(hor_ds_factor == ver_ds_factor);\n\n\ti = 1;\n\twhile (i < hor_ds_factor) {\n\t\tdescr->num_stage++;\n\t\ti *= max_scale_factor_per_stage;\n\t}\n\n\tdescr->in_info = kmalloc(descr->num_stage *\n\t\t\t\t sizeof(struct ia_css_frame_info),\n\t\t\t\t GFP_KERNEL);\n\tif (!descr->in_info) {\n\t\terr = -ENOMEM;\n\t\tgoto ERR;\n\t}\n\tdescr->internal_out_info = kmalloc(descr->num_stage *\n\t\t\t\t\t   sizeof(struct ia_css_frame_info),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!descr->internal_out_info) {\n\t\terr = -ENOMEM;\n\t\tgoto ERR;\n\t}\n\tdescr->out_info = kmalloc(descr->num_stage *\n\t\t\t\t  sizeof(struct ia_css_frame_info),\n\t\t\t\t  GFP_KERNEL);\n\tif (!descr->out_info) {\n\t\terr = -ENOMEM;\n\t\tgoto ERR;\n\t}\n\tdescr->vf_info = kmalloc(descr->num_stage *\n\t\t\t\t sizeof(struct ia_css_frame_info),\n\t\t\t\t GFP_KERNEL);\n\tif (!descr->vf_info) {\n\t\terr = -ENOMEM;\n\t\tgoto ERR;\n\t}\n\tdescr->is_output_stage = kmalloc(descr->num_stage * sizeof(bool),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!descr->is_output_stage) {\n\t\terr = -ENOMEM;\n\t\tgoto ERR;\n\t}\n\n\ttmp_in_info = *cas_scaler_in_info;\n\tfor (i = 0; i < descr->num_stage; i++) {\n\t\tdescr->in_info[i] = tmp_in_info;\n\t\tif ((tmp_in_info.res.width / max_scale_factor_per_stage) <=\n\t\t    cas_scaler_out_info->res.width) {\n\t\t\tdescr->is_output_stage[i] = true;\n\t\t\tif ((descr->num_output_stage > 1) && (i != (descr->num_stage - 1))) {\n\t\t\t\tdescr->internal_out_info[i].res.width = cas_scaler_out_info->res.width;\n\t\t\t\tdescr->internal_out_info[i].res.height = cas_scaler_out_info->res.height;\n\t\t\t\tdescr->internal_out_info[i].padded_width = cas_scaler_out_info->padded_width;\n\t\t\t\tdescr->internal_out_info[i].format = IA_CSS_FRAME_FORMAT_YUV420;\n\t\t\t} else {\n\t\t\t\tassert(i == (descr->num_stage - 1));\n\t\t\t\tdescr->internal_out_info[i].res.width = 0;\n\t\t\t\tdescr->internal_out_info[i].res.height = 0;\n\t\t\t}\n\t\t\tdescr->out_info[i].res.width = cas_scaler_out_info->res.width;\n\t\t\tdescr->out_info[i].res.height = cas_scaler_out_info->res.height;\n\t\t\tdescr->out_info[i].padded_width = cas_scaler_out_info->padded_width;\n\t\t\tdescr->out_info[i].format = cas_scaler_out_info->format;\n\t\t\tif (cas_scaler_vf_info) {\n\t\t\t\tdescr->vf_info[i].res.width = cas_scaler_vf_info->res.width;\n\t\t\t\tdescr->vf_info[i].res.height = cas_scaler_vf_info->res.height;\n\t\t\t\tdescr->vf_info[i].padded_width = cas_scaler_vf_info->padded_width;\n\t\t\t\tia_css_frame_info_set_format(&descr->vf_info[i], IA_CSS_FRAME_FORMAT_YUV_LINE);\n\t\t\t} else {\n\t\t\t\tdescr->vf_info[i].res.width = 0;\n\t\t\t\tdescr->vf_info[i].res.height = 0;\n\t\t\t\tdescr->vf_info[i].padded_width = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tdescr->is_output_stage[i] = false;\n\t\t\tdescr->internal_out_info[i].res.width = tmp_in_info.res.width /\n\t\t\t\t\t\t\t\tmax_scale_factor_per_stage;\n\t\t\tdescr->internal_out_info[i].res.height = tmp_in_info.res.height /\n\t\t\t\tmax_scale_factor_per_stage;\n\t\t\tdescr->internal_out_info[i].format = IA_CSS_FRAME_FORMAT_YUV420;\n\t\t\tia_css_frame_info_init(&descr->internal_out_info[i],\n\t\t\t\t\t       tmp_in_info.res.width / max_scale_factor_per_stage,\n\t\t\t\t\t       tmp_in_info.res.height / max_scale_factor_per_stage,\n\t\t\t\t\t       IA_CSS_FRAME_FORMAT_YUV420, 0);\n\t\t\tdescr->out_info[i].res.width = 0;\n\t\t\tdescr->out_info[i].res.height = 0;\n\t\t\tdescr->vf_info[i].res.width = 0;\n\t\t\tdescr->vf_info[i].res.height = 0;\n\t\t}\n\t\ttmp_in_info = descr->internal_out_info[i];\n\t}\nERR:\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"ia_css_pipe_create_cas_scaler_desc() leave, err=%d\\n\",\n\t\t\t    err);\n\treturn err;\n}\n\n/* FIXME: merge most of this and single output version */\nstatic int\nia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pipe,\n\t\t\t\t   struct ia_css_cas_binary_descr *descr)\n{\n\tstruct ia_css_frame_info in_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO;\n\tstruct ia_css_frame_info *out_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];\n\tstruct ia_css_frame_info *vf_out_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];\n\tstruct ia_css_frame_info tmp_in_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO;\n\tunsigned int i, j;\n\tunsigned int hor_scale_factor[IA_CSS_PIPE_MAX_OUTPUT_STAGE],\n\t\t    ver_scale_factor[IA_CSS_PIPE_MAX_OUTPUT_STAGE],\n\t\t    scale_factor = 0;\n\tunsigned int num_stages = 0;\n\tint err = 0;\n\n\tunsigned int max_scale_factor_per_stage = MAX_PREFERRED_YUV_DS_PER_STEP;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"ia_css_pipe_create_cas_scaler_desc() enter:\\n\");\n\n\tfor (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {\n\t\tout_info[i] = NULL;\n\t\tvf_out_info[i] = NULL;\n\t\thor_scale_factor[i] = 0;\n\t\tver_scale_factor[i] = 0;\n\t}\n\n\tin_info.res = pipe->config.input_effective_res;\n\tin_info.padded_width = in_info.res.width;\n\tdescr->num_output_stage = 0;\n\t/* Find out how much scaling we need for each output */\n\tfor (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {\n\t\tif (pipe->output_info[i].res.width != 0) {\n\t\t\tout_info[i] = &pipe->output_info[i];\n\t\t\tif (pipe->vf_output_info[i].res.width != 0)\n\t\t\t\tvf_out_info[i] = &pipe->vf_output_info[i];\n\t\t\tdescr->num_output_stage += 1;\n\t\t}\n\n\t\tif (out_info[i]) {\n\t\t\thor_scale_factor[i] = CEIL_DIV(in_info.res.width, out_info[i]->res.width);\n\t\t\tver_scale_factor[i] = CEIL_DIV(in_info.res.height, out_info[i]->res.height);\n\t\t\t/* use the same horizontal and vertical scaling factor for simplicity */\n\t\t\tassert(hor_scale_factor[i] == ver_scale_factor[i]);\n\t\t\tscale_factor = 1;\n\t\t\tdo {\n\t\t\t\tnum_stages++;\n\t\t\t\tscale_factor *= max_scale_factor_per_stage;\n\t\t\t} while (scale_factor < hor_scale_factor[i]);\n\n\t\t\tin_info.res = out_info[i]->res;\n\t\t}\n\t}\n\n\tif (need_yuv_scaler_stage(pipe) && (num_stages == 0))\n\t\tnum_stages = 1;\n\n\tdescr->num_stage = num_stages;\n\n\tdescr->in_info = kmalloc_array(descr->num_stage,\n\t\t\t\t       sizeof(struct ia_css_frame_info),\n\t\t\t\t       GFP_KERNEL);\n\tif (!descr->in_info) {\n\t\terr = -ENOMEM;\n\t\tgoto ERR;\n\t}\n\tdescr->internal_out_info = kmalloc(descr->num_stage *\n\t\t\t\t\t   sizeof(struct ia_css_frame_info),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!descr->internal_out_info) {\n\t\terr = -ENOMEM;\n\t\tgoto ERR;\n\t}\n\tdescr->out_info = kmalloc(descr->num_stage *\n\t\t\t\t  sizeof(struct ia_css_frame_info),\n\t\t\t\t  GFP_KERNEL);\n\tif (!descr->out_info) {\n\t\terr = -ENOMEM;\n\t\tgoto ERR;\n\t}\n\tdescr->vf_info = kmalloc(descr->num_stage *\n\t\t\t\t sizeof(struct ia_css_frame_info),\n\t\t\t\t GFP_KERNEL);\n\tif (!descr->vf_info) {\n\t\terr = -ENOMEM;\n\t\tgoto ERR;\n\t}\n\tdescr->is_output_stage = kmalloc(descr->num_stage * sizeof(bool),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!descr->is_output_stage) {\n\t\terr = -ENOMEM;\n\t\tgoto ERR;\n\t}\n\n\tfor (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {\n\t\tif (out_info[i]) {\n\t\t\tif (i > 0) {\n\t\t\t\tassert((out_info[i - 1]->res.width >= out_info[i]->res.width) &&\n\t\t\t\t       (out_info[i - 1]->res.height >= out_info[i]->res.height));\n\t\t\t}\n\t\t}\n\t}\n\n\ttmp_in_info.res = pipe->config.input_effective_res;\n\ttmp_in_info.format = IA_CSS_FRAME_FORMAT_YUV420;\n\tfor (i = 0, j = 0; i < descr->num_stage; i++) {\n\t\tassert(j < 2);\n\t\tassert(out_info[j]);\n\n\t\tdescr->in_info[i] = tmp_in_info;\n\t\tif ((tmp_in_info.res.width / max_scale_factor_per_stage) <=\n\t\t    out_info[j]->res.width) {\n\t\t\tdescr->is_output_stage[i] = true;\n\t\t\tif ((descr->num_output_stage > 1) && (i != (descr->num_stage - 1))) {\n\t\t\t\tdescr->internal_out_info[i].res.width = out_info[j]->res.width;\n\t\t\t\tdescr->internal_out_info[i].res.height = out_info[j]->res.height;\n\t\t\t\tdescr->internal_out_info[i].padded_width = out_info[j]->padded_width;\n\t\t\t\tdescr->internal_out_info[i].format = IA_CSS_FRAME_FORMAT_YUV420;\n\t\t\t} else {\n\t\t\t\tassert(i == (descr->num_stage - 1));\n\t\t\t\tdescr->internal_out_info[i].res.width = 0;\n\t\t\t\tdescr->internal_out_info[i].res.height = 0;\n\t\t\t}\n\t\t\tdescr->out_info[i].res.width = out_info[j]->res.width;\n\t\t\tdescr->out_info[i].res.height = out_info[j]->res.height;\n\t\t\tdescr->out_info[i].padded_width = out_info[j]->padded_width;\n\t\t\tdescr->out_info[i].format = out_info[j]->format;\n\t\t\tif (vf_out_info[j]) {\n\t\t\t\tdescr->vf_info[i].res.width = vf_out_info[j]->res.width;\n\t\t\t\tdescr->vf_info[i].res.height = vf_out_info[j]->res.height;\n\t\t\t\tdescr->vf_info[i].padded_width = vf_out_info[j]->padded_width;\n\t\t\t\tia_css_frame_info_set_format(&descr->vf_info[i], IA_CSS_FRAME_FORMAT_YUV_LINE);\n\t\t\t} else {\n\t\t\t\tdescr->vf_info[i].res.width = 0;\n\t\t\t\tdescr->vf_info[i].res.height = 0;\n\t\t\t\tdescr->vf_info[i].padded_width = 0;\n\t\t\t}\n\t\t\tj++;\n\t\t} else {\n\t\t\tdescr->is_output_stage[i] = false;\n\t\t\tdescr->internal_out_info[i].res.width = tmp_in_info.res.width /\n\t\t\t\t\t\t\t\tmax_scale_factor_per_stage;\n\t\t\tdescr->internal_out_info[i].res.height = tmp_in_info.res.height /\n\t\t\t\tmax_scale_factor_per_stage;\n\t\t\tdescr->internal_out_info[i].format = IA_CSS_FRAME_FORMAT_YUV420;\n\t\t\tia_css_frame_info_init(&descr->internal_out_info[i],\n\t\t\t\t\t       tmp_in_info.res.width / max_scale_factor_per_stage,\n\t\t\t\t\t       tmp_in_info.res.height / max_scale_factor_per_stage,\n\t\t\t\t\t       IA_CSS_FRAME_FORMAT_YUV420, 0);\n\t\t\tdescr->out_info[i].res.width = 0;\n\t\t\tdescr->out_info[i].res.height = 0;\n\t\t\tdescr->vf_info[i].res.width = 0;\n\t\t\tdescr->vf_info[i].res.height = 0;\n\t\t}\n\t\ttmp_in_info = descr->internal_out_info[i];\n\t}\nERR:\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"ia_css_pipe_create_cas_scaler_desc() leave, err=%d\\n\",\n\t\t\t    err);\n\treturn err;\n}\n\nstatic void ia_css_pipe_destroy_cas_scaler_desc(struct ia_css_cas_binary_descr\n\t*descr)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"ia_css_pipe_destroy_cas_scaler_desc() enter:\\n\");\n\tkfree(descr->in_info);\n\tdescr->in_info = NULL;\n\tkfree(descr->internal_out_info);\n\tdescr->internal_out_info = NULL;\n\tkfree(descr->out_info);\n\tdescr->out_info = NULL;\n\tkfree(descr->vf_info);\n\tdescr->vf_info = NULL;\n\tkfree(descr->is_output_stage);\n\tdescr->is_output_stage = NULL;\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"ia_css_pipe_destroy_cas_scaler_desc() leave\\n\");\n}\n\nstatic int\nload_yuvpp_binaries(struct ia_css_pipe *pipe)\n{\n\tint err = 0;\n\tbool need_scaler = false;\n\tstruct ia_css_frame_info *vf_pp_in_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];\n\tstruct ia_css_yuvpp_settings *mycs;\n\tstruct ia_css_binary *next_binary;\n\tstruct ia_css_cas_binary_descr cas_scaler_descr = { };\n\tunsigned int i, j;\n\tbool need_isp_copy_binary = false;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\tassert(pipe);\n\tassert(pipe->stream);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_YUVPP);\n\n\tif (pipe->pipe_settings.yuvpp.copy_binary.info)\n\t\tgoto ERR;\n\n\t/* Set both must_be_raw and must_be_yuv to false then yuvpp can take rgb inputs */\n\terr = ia_css_util_check_input(&pipe->stream->config, false, false);\n\tif (err)\n\t\tgoto ERR;\n\n\tmycs = &pipe->pipe_settings.yuvpp;\n\n\tfor (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {\n\t\tif (pipe->vf_output_info[i].res.width != 0) {\n\t\t\terr = ia_css_util_check_vf_out_info(&pipe->output_info[i],\n\t\t\t\t\t\t\t    &pipe->vf_output_info[i]);\n\t\t\tif (err)\n\t\t\t\tgoto ERR;\n\t\t}\n\t\tvf_pp_in_info[i] = NULL;\n\t}\n\n\tneed_scaler = need_yuv_scaler_stage(pipe);\n\n\t/* we build up the pipeline starting at the end */\n\t/* Capture post-processing */\n\tif (need_scaler) {\n\t\tstruct ia_css_binary_descr yuv_scaler_descr;\n\n\t\terr = ia_css_pipe_create_cas_scaler_desc(pipe,\n\t\t\t\t\t\t\t &cas_scaler_descr);\n\t\tif (err)\n\t\t\tgoto ERR;\n\t\tmycs->num_output = cas_scaler_descr.num_output_stage;\n\t\tmycs->num_yuv_scaler = cas_scaler_descr.num_stage;\n\t\tmycs->yuv_scaler_binary = kcalloc(cas_scaler_descr.num_stage,\n\t\t\t\t\t\t  sizeof(struct ia_css_binary),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!mycs->yuv_scaler_binary) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto ERR;\n\t\t}\n\t\tmycs->is_output_stage = kcalloc(cas_scaler_descr.num_stage,\n\t\t\t\t\t\tsizeof(bool), GFP_KERNEL);\n\t\tif (!mycs->is_output_stage) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto ERR;\n\t\t}\n\t\tfor (i = 0; i < cas_scaler_descr.num_stage; i++) {\n\t\t\tmycs->is_output_stage[i] = cas_scaler_descr.is_output_stage[i];\n\t\t\tia_css_pipe_get_yuvscaler_binarydesc(pipe,\n\t\t\t\t\t\t\t     &yuv_scaler_descr,\n\t\t\t\t\t\t\t     &cas_scaler_descr.in_info[i],\n\t\t\t\t\t\t\t     &cas_scaler_descr.out_info[i],\n\t\t\t\t\t\t\t     &cas_scaler_descr.internal_out_info[i],\n\t\t\t\t\t\t\t     &cas_scaler_descr.vf_info[i]);\n\t\t\terr = ia_css_binary_find(&yuv_scaler_descr,\n\t\t\t\t\t\t &mycs->yuv_scaler_binary[i]);\n\t\t\tif (err)\n\t\t\t\tgoto ERR;\n\t\t}\n\t\tia_css_pipe_destroy_cas_scaler_desc(&cas_scaler_descr);\n\t} else {\n\t\tmycs->num_output = 1;\n\t}\n\n\tif (need_scaler)\n\t\tnext_binary = &mycs->yuv_scaler_binary[0];\n\telse\n\t\tnext_binary = NULL;\n\n\t/*\n\t * NOTES\n\t * - Why does the \"yuvpp\" pipe needs \"isp_copy_binary\" (i.e. ISP Copy) when\n\t *   its input is \"ATOMISP_INPUT_FORMAT_YUV422_8\"?\n\t *\n\t *   In most use cases, the first stage in the \"yuvpp\" pipe is the \"yuv_scale_\n\t *   binary\". However, the \"yuv_scale_binary\" does NOT support the input-frame\n\t *   format as \"IA_CSS_STREAM _FORMAT_YUV422_8\".\n\t *\n\t *   Hence, the \"isp_copy_binary\" is required to be present in front of the \"yuv\n\t *   _scale_binary\". It would translate the input-frame to the frame formats that\n\t *   are supported by the \"yuv_scale_binary\".\n\t *\n\t *   Please refer to \"FrameWork/css/isp/pipes/capture_pp/capture_pp_1.0/capture_\n\t *   pp_defs.h\" for the list of input-frame formats that are supported by the\n\t *   \"yuv_scale_binary\".\n\t */\n\tif (IS_ISP2401)\n\t\tneed_isp_copy_binary =\n\t\t    (pipe->stream->config.input_config.format == ATOMISP_INPUT_FORMAT_YUV422_8);\n\telse\n\t\tneed_isp_copy_binary = true;\n\n\tif (need_isp_copy_binary) {\n\t\terr = load_copy_binary(pipe,\n\t\t\t\t       &mycs->copy_binary,\n\t\t\t\t       next_binary);\n\n\t\tif (err)\n\t\t\tgoto ERR;\n\n\t\t/*\n\t\t * NOTES\n\t\t * - Why is \"pipe->pipe_settings.capture.copy_binary.online\" specified?\n\t\t *\n\t\t *   In some use cases, the first stage in the \"yuvpp\" pipe is the\n\t\t *   \"isp_copy_binary\". The \"isp_copy_binary\" is designed to process\n\t\t *   the input from either the system DDR or from the IPU internal VMEM.\n\t\t *   So it provides the flag \"online\" to specify where its input is from,\n\t\t *   i.e.:\n\t\t *\n\t\t *      (1) \"online <= true\", the input is from the IPU internal VMEM.\n\t\t *      (2) \"online <= false\", the input is from the system DDR.\n\t\t *\n\t\t *   In other use cases, the first stage in the \"yuvpp\" pipe is the\n\t\t *   \"yuv_scale_binary\". \"The \"yuv_scale_binary\" is designed to process the\n\t\t *   input ONLY from the system DDR. So it does not provide the flag \"online\"\n\t\t *   to specify where its input is from.\n\t\t */\n\t\tpipe->pipe_settings.capture.copy_binary.online = pipe->stream->config.online;\n\t}\n\n\t \n\tif (need_scaler) {\n\t\tfor (i = 0, j = 0; i < mycs->num_yuv_scaler; i++) {\n\t\t\tif (mycs->is_output_stage[i]) {\n\t\t\t\tassert(j < 2);\n\t\t\t\tvf_pp_in_info[j] =\n\t\t\t\t    &mycs->yuv_scaler_binary[i].vf_frame_info;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tmycs->num_vf_pp = j;\n\t} else {\n\t\tvf_pp_in_info[0] =\n\t\t    &mycs->copy_binary.vf_frame_info;\n\t\tfor (i = 1; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++)\n\t\t\tvf_pp_in_info[i] = NULL;\n\n\t\tmycs->num_vf_pp = 1;\n\t}\n\tmycs->vf_pp_binary = kcalloc(mycs->num_vf_pp,\n\t\t\t\t     sizeof(struct ia_css_binary),\n\t\t\t\t     GFP_KERNEL);\n\tif (!mycs->vf_pp_binary) {\n\t\terr = -ENOMEM;\n\t\tgoto ERR;\n\t}\n\n\t{\n\t\tstruct ia_css_binary_descr vf_pp_descr;\n\n\t\tfor (i = 0; i < mycs->num_vf_pp; i++) {\n\t\t\tif (pipe->vf_output_info[i].res.width != 0) {\n\t\t\t\tia_css_pipe_get_vfpp_binarydesc(pipe,\n\t\t\t\t\t\t\t\t&vf_pp_descr, vf_pp_in_info[i], &pipe->vf_output_info[i]);\n\t\t\t\terr = ia_css_binary_find(&vf_pp_descr, &mycs->vf_pp_binary[i]);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto ERR;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (err)\n\t\tgoto ERR;\n\nERR:\n\tif (need_scaler)\n\t\tia_css_pipe_destroy_cas_scaler_desc(&cas_scaler_descr);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, \"load_yuvpp_binaries() leave, err=%d\\n\",\n\t\t\t    err);\n\treturn err;\n}\n\nstatic int\nunload_yuvpp_binaries(struct ia_css_pipe *pipe)\n{\n\tunsigned int i;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p\", pipe);\n\n\tif ((!pipe) || (pipe->mode != IA_CSS_PIPE_ID_YUVPP)) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\tia_css_binary_unload(&pipe->pipe_settings.yuvpp.copy_binary);\n\tfor (i = 0; i < pipe->pipe_settings.yuvpp.num_yuv_scaler; i++)\n\t\tia_css_binary_unload(&pipe->pipe_settings.yuvpp.yuv_scaler_binary[i]);\n\n\tfor (i = 0; i < pipe->pipe_settings.yuvpp.num_vf_pp; i++)\n\t\tia_css_binary_unload(&pipe->pipe_settings.yuvpp.vf_pp_binary[i]);\n\n\tkfree(pipe->pipe_settings.yuvpp.is_output_stage);\n\tpipe->pipe_settings.yuvpp.is_output_stage = NULL;\n\tkfree(pipe->pipe_settings.yuvpp.yuv_scaler_binary);\n\tpipe->pipe_settings.yuvpp.yuv_scaler_binary = NULL;\n\tkfree(pipe->pipe_settings.yuvpp.vf_pp_binary);\n\tpipe->pipe_settings.yuvpp.vf_pp_binary = NULL;\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\treturn 0;\n}\n\nstatic int yuvpp_start(struct ia_css_pipe *pipe)\n{\n\tint err = 0;\n\tenum sh_css_pipe_config_override copy_ovrd;\n\tenum ia_css_input_mode yuvpp_pipe_input_mode;\n\tunsigned int thread_id;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p\", pipe);\n\tif ((!pipe) || (pipe->mode != IA_CSS_PIPE_ID_YUVPP)) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tyuvpp_pipe_input_mode = pipe->stream->config.mode;\n\n\tsh_css_metrics_start_frame();\n\n\t \n\n\terr = send_mipi_frames(pipe);\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\n\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);\n\tcopy_ovrd = 1 << thread_id;\n\n\tstart_pipe(pipe, copy_ovrd, yuvpp_pipe_input_mode);\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\nstatic int\nsh_css_pipe_unload_binaries(struct ia_css_pipe *pipe)\n{\n\tint err = 0;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p\", pipe);\n\n\tif (!pipe) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (pipe->config.mode == IA_CSS_PIPE_MODE_COPY) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\t\treturn 0;\n\t}\n\n\tswitch (pipe->mode) {\n\tcase IA_CSS_PIPE_ID_PREVIEW:\n\t\terr = unload_preview_binaries(pipe);\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_VIDEO:\n\t\terr = unload_video_binaries(pipe);\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_CAPTURE:\n\t\terr = unload_capture_binaries(pipe);\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_YUVPP:\n\t\terr = unload_yuvpp_binaries(pipe);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\nstatic int\nsh_css_pipe_load_binaries(struct ia_css_pipe *pipe)\n{\n\tint err = 0;\n\n\tassert(pipe);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, \"sh_css_pipe_load_binaries() enter:\\n\");\n\n\t \n\tif (pipe->config.mode == IA_CSS_PIPE_MODE_COPY)\n\t\treturn err;\n\n\tswitch (pipe->mode) {\n\tcase IA_CSS_PIPE_ID_PREVIEW:\n\t\terr = load_preview_binaries(pipe);\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_VIDEO:\n\t\terr = load_video_binaries(pipe);\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_CAPTURE:\n\t\terr = load_capture_binaries(pipe);\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_YUVPP:\n\t\terr = load_yuvpp_binaries(pipe);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tif (err) {\n\t\tif (sh_css_pipe_unload_binaries(pipe)) {\n\t\t\t \n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int\ncreate_host_yuvpp_pipeline(struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_pipeline *me;\n\tint err = 0;\n\tstruct ia_css_pipeline_stage *vf_pp_stage = NULL,\n\t\t*copy_stage = NULL,\n\t\t*yuv_scaler_stage = NULL;\n\tstruct ia_css_binary *copy_binary,\n\t\t*vf_pp_binary,\n\t\t*yuv_scaler_binary;\n\tbool need_scaler = false;\n\tunsigned int num_stage, num_output_stage;\n\tunsigned int i, j;\n\n\tstruct ia_css_frame *in_frame = NULL;\n\tstruct ia_css_frame *out_frame[IA_CSS_PIPE_MAX_OUTPUT_STAGE];\n\tstruct ia_css_frame *bin_out_frame[IA_CSS_BINARY_MAX_OUTPUT_PORTS];\n\tstruct ia_css_frame *vf_frame[IA_CSS_PIPE_MAX_OUTPUT_STAGE];\n\tstruct ia_css_pipeline_stage_desc stage_desc;\n\tbool need_in_frameinfo_memory = false;\n\tbool sensor = false;\n\tbool buffered_sensor = false;\n\tbool online = false;\n\tbool continuous = false;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p\", pipe);\n\tif ((!pipe) || (!pipe->stream) || (pipe->mode != IA_CSS_PIPE_ID_YUVPP)) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\tme = &pipe->pipeline;\n\tia_css_pipeline_clean(me);\n\tfor (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {\n\t\tout_frame[i] = NULL;\n\t\tvf_frame[i] = NULL;\n\t}\n\tia_css_pipe_util_create_output_frames(bin_out_frame);\n\tnum_stage  = pipe->pipe_settings.yuvpp.num_yuv_scaler;\n\tnum_output_stage   = pipe->pipe_settings.yuvpp.num_output;\n\n\tif (IS_ISP2401) {\n\t\t \n\t\tsensor = pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR;\n\t\tbuffered_sensor = pipe->stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR;\n\t\tonline = pipe->stream->config.online;\n\t\tcontinuous = pipe->stream->config.continuous;\n\t\tneed_in_frameinfo_memory =\n\t\t!((sensor && (online || continuous)) || (buffered_sensor && continuous));\n\t} else {\n\t\t \n\t\tneed_in_frameinfo_memory = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;\n\t}\n\t \n\tif (need_in_frameinfo_memory) {\n\t\t \n\n\t\t \n\t\tint in_frame_format;\n\n\t\tif (pipe->stream->config.input_config.format ==\n\t\t    ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY) {\n\t\t\tin_frame_format = IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8;\n\t\t} else if (pipe->stream->config.input_config.format ==\n\t\t\t    ATOMISP_INPUT_FORMAT_YUV422_8) {\n\t\t\t \n\t\t\tin_frame_format = IA_CSS_FRAME_FORMAT_RAW;\n\t\t} else {\n\t\t\tin_frame_format = IA_CSS_FRAME_FORMAT_NV12;\n\t\t}\n\n\t\terr = init_in_frameinfo_memory_defaults(pipe,\n\t\t\t\t\t\t\t&me->in_frame,\n\t\t\t\t\t\t\tin_frame_format);\n\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\n\t\tin_frame = &me->in_frame;\n\t} else {\n\t\tin_frame = NULL;\n\t}\n\n\tfor (i = 0; i < num_output_stage; i++) {\n\t\tassert(i < IA_CSS_PIPE_MAX_OUTPUT_STAGE);\n\t\tif (pipe->output_info[i].res.width != 0) {\n\t\t\terr = init_out_frameinfo_defaults(pipe, &me->out_frame[i], i);\n\t\t\tif (err) {\n\t\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tout_frame[i] = &me->out_frame[i];\n\t\t}\n\n\t\t \n\t\tif (pipe->vf_output_info[i].res.width != 0) {\n\t\t\terr = init_vf_frameinfo_defaults(pipe, &me->vf_frame[i], i);\n\t\t\tif (err) {\n\t\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tvf_frame[i] = &me->vf_frame[i];\n\t\t}\n\t}\n\n\tcopy_binary       = &pipe->pipe_settings.yuvpp.copy_binary;\n\tvf_pp_binary      = pipe->pipe_settings.yuvpp.vf_pp_binary;\n\tyuv_scaler_binary = pipe->pipe_settings.yuvpp.yuv_scaler_binary;\n\tneed_scaler = need_yuv_scaler_stage(pipe);\n\n\tif (pipe->pipe_settings.yuvpp.copy_binary.info) {\n\t\tstruct ia_css_frame *in_frame_local = NULL;\n\n\t\tif (IS_ISP2401 && !online) {\n\t\t\t \n\t\t\tin_frame_local = in_frame;\n\t\t}\n\n\t\tif (need_scaler) {\n\t\t\tia_css_pipe_util_set_output_frames(bin_out_frame,\n\t\t\t\t\t\t\t   0, NULL);\n\t\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t\t   copy_binary,\n\t\t\t\t\t\t\t   bin_out_frame,\n\t\t\t\t\t\t\t   in_frame_local,\n\t\t\t\t\t\t\t   NULL);\n\t\t} else {\n\t\t\tia_css_pipe_util_set_output_frames(bin_out_frame,\n\t\t\t\t\t\t\t   0, out_frame[0]);\n\t\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t\t   copy_binary,\n\t\t\t\t\t\t\t   bin_out_frame,\n\t\t\t\t\t\t\t   in_frame_local,\n\t\t\t\t\t\t\t   NULL);\n\t\t}\n\n\t\terr = ia_css_pipeline_create_and_add_stage(me,\n\t\t\t\t\t\t\t   &stage_desc,\n\t\t\t\t\t\t\t   &copy_stage);\n\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (copy_stage) {\n\t\t\t \n\t\t\tcopy_stage->args.copy_vf = !need_scaler;\n\t\t\t \n\t\t\tcopy_stage->args.copy_output = true;\n\t\t\t \n\t\t\tin_frame = copy_stage->args.out_frame[0];\n\t\t}\n\t}\n\n\tif (need_scaler) {\n\t\tstruct ia_css_frame *tmp_out_frame = NULL;\n\t\tstruct ia_css_frame *tmp_vf_frame = NULL;\n\t\tstruct ia_css_frame *tmp_in_frame = in_frame;\n\n\t\tfor (i = 0, j = 0; i < num_stage; i++) {\n\t\t\tassert(j < num_output_stage);\n\t\t\tif (pipe->pipe_settings.yuvpp.is_output_stage[i]) {\n\t\t\t\ttmp_out_frame = out_frame[j];\n\t\t\t\ttmp_vf_frame = vf_frame[j];\n\t\t\t} else {\n\t\t\t\ttmp_out_frame = NULL;\n\t\t\t\ttmp_vf_frame = NULL;\n\t\t\t}\n\n\t\t\terr = add_yuv_scaler_stage(pipe, me, tmp_in_frame,\n\t\t\t\t\t\t   tmp_out_frame,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   &yuv_scaler_binary[i],\n\t\t\t\t\t\t   &yuv_scaler_stage);\n\n\t\t\tif (err) {\n\t\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\t \n\t\t\ttmp_in_frame = yuv_scaler_stage->args.out_frame[1];\n\t\t\tif (pipe->pipe_settings.yuvpp.is_output_stage[i]) {\n\t\t\t\tif (tmp_vf_frame && (tmp_vf_frame->frame_info.res.width != 0)) {\n\t\t\t\t\tin_frame = yuv_scaler_stage->args.out_vf_frame;\n\t\t\t\t\terr = add_vf_pp_stage(pipe, in_frame,\n\t\t\t\t\t\t\t      tmp_vf_frame,\n\t\t\t\t\t\t\t      &vf_pp_binary[j],\n\t\t\t\t\t\t\t      &vf_pp_stage);\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\t\t\t\treturn err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t} else if (copy_stage) {\n\t\tif (vf_frame[0] && vf_frame[0]->frame_info.res.width != 0) {\n\t\t\tin_frame = copy_stage->args.out_vf_frame;\n\t\t\terr = add_vf_pp_stage(pipe, in_frame, vf_frame[0],\n\t\t\t\t\t      &vf_pp_binary[0], &vf_pp_stage);\n\t\t}\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tia_css_pipeline_finalize_stages(&pipe->pipeline,\n\t\t\t\t\tpipe->stream->config.continuous);\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\n\treturn 0;\n}\n\nstatic int\ncreate_host_copy_pipeline(struct ia_css_pipe *pipe,\n\t\t\t  unsigned int max_input_width,\n\t\t\t  struct ia_css_frame *out_frame)\n{\n\tstruct ia_css_pipeline *me;\n\tint err = 0;\n\tstruct ia_css_pipeline_stage_desc stage_desc;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"create_host_copy_pipeline() enter:\\n\");\n\n\t \n\tme = &pipe->pipeline;\n\tia_css_pipeline_clean(me);\n\n\t \n\tout_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;\n\n\tif (copy_on_sp(pipe) &&\n\t    pipe->stream->config.input_config.format == ATOMISP_INPUT_FORMAT_BINARY_8) {\n\t\tia_css_frame_info_init(&out_frame->frame_info, JPEG_BYTES, 1,\n\t\t\t\t       IA_CSS_FRAME_FORMAT_BINARY_8, 0);\n\t} else if (out_frame->frame_info.format == IA_CSS_FRAME_FORMAT_RAW) {\n\t\tout_frame->frame_info.raw_bit_depth =\n\t\tia_css_pipe_util_pipe_input_format_bpp(pipe);\n\t}\n\n\tme->num_stages = 1;\n\tme->pipe_id = IA_CSS_PIPE_ID_COPY;\n\tpipe->mode  = IA_CSS_PIPE_ID_COPY;\n\n\tia_css_pipe_get_sp_func_stage_desc(&stage_desc, out_frame,\n\t\t\t\t\t   IA_CSS_PIPELINE_RAW_COPY,\n\t\t\t\t\t   max_input_width);\n\terr = ia_css_pipeline_create_and_add_stage(me, &stage_desc, NULL);\n\n\tia_css_pipeline_finalize_stages(&pipe->pipeline,\n\t\t\t\t\tpipe->stream->config.continuous);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"create_host_copy_pipeline() leave:\\n\");\n\n\treturn err;\n}\n\nstatic int\ncreate_host_isyscopy_capture_pipeline(struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_pipeline *me = &pipe->pipeline;\n\tint err = 0;\n\tstruct ia_css_pipeline_stage_desc stage_desc;\n\tstruct ia_css_frame *out_frame = &me->out_frame[0];\n\tstruct ia_css_pipeline_stage *out_stage = NULL;\n\tunsigned int thread_id;\n\tenum sh_css_queue_id queue_id;\n\tunsigned int max_input_width = MAX_VECTORS_PER_INPUT_LINE_CONT * ISP_VEC_NELEMS;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"create_host_isyscopy_capture_pipeline() enter:\\n\");\n\tia_css_pipeline_clean(me);\n\n\t \n\terr = sh_css_pipe_get_output_frame_info(pipe, &out_frame->frame_info, 0);\n\tif (err)\n\t\treturn err;\n\tout_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;\n\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);\n\tia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, thread_id, &queue_id);\n\tout_frame->dynamic_queue_id = queue_id;\n\tout_frame->buf_type = IA_CSS_BUFFER_TYPE_OUTPUT_FRAME;\n\n\tme->num_stages = 1;\n\tme->pipe_id = IA_CSS_PIPE_ID_CAPTURE;\n\tpipe->mode  = IA_CSS_PIPE_ID_CAPTURE;\n\tia_css_pipe_get_sp_func_stage_desc(&stage_desc, out_frame,\n\t\t\t\t\t   IA_CSS_PIPELINE_ISYS_COPY,\n\t\t\t\t\t   max_input_width);\n\terr = ia_css_pipeline_create_and_add_stage(me,\n\t\t\t\t\t\t   &stage_desc, &out_stage);\n\tif (err)\n\t\treturn err;\n\n\tia_css_pipeline_finalize_stages(me, pipe->stream->config.continuous);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"create_host_isyscopy_capture_pipeline() leave:\\n\");\n\n\treturn err;\n}\n\nstatic int\ncreate_host_regular_capture_pipeline(struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_pipeline *me;\n\tint err = 0;\n\tenum ia_css_capture_mode mode;\n\tstruct ia_css_pipeline_stage *current_stage = NULL;\n\tstruct ia_css_pipeline_stage *yuv_scaler_stage = NULL;\n\tstruct ia_css_binary *copy_binary,\n\t\t*primary_binary[MAX_NUM_PRIMARY_STAGES],\n\t\t*vf_pp_binary,\n\t\t*pre_isp_binary,\n\t\t*anr_gdc_binary,\n\t\t*post_isp_binary,\n\t\t*yuv_scaler_binary,\n\t\t*capture_pp_binary,\n\t\t*capture_ldc_binary;\n\tbool need_pp = false;\n\tbool raw;\n\n\tstruct ia_css_frame *in_frame;\n\tstruct ia_css_frame *out_frame;\n\tstruct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];\n\tstruct ia_css_frame *vf_frame;\n\tstruct ia_css_pipeline_stage_desc stage_desc;\n\tbool need_in_frameinfo_memory = false;\n\tbool sensor = false;\n\tbool buffered_sensor = false;\n\tbool online = false;\n\tbool continuous = false;\n\tunsigned int i, num_yuv_scaler, num_primary_stage;\n\tbool need_yuv_pp = false;\n\tbool *is_output_stage = NULL;\n\tbool need_ldc = false;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\tassert(pipe);\n\tassert(pipe->stream);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE ||\n\t       pipe->mode == IA_CSS_PIPE_ID_COPY);\n\n\tme = &pipe->pipeline;\n\tmode = pipe->config.default_capture_config.mode;\n\traw = (mode == IA_CSS_CAPTURE_MODE_RAW);\n\tia_css_pipeline_clean(me);\n\tia_css_pipe_util_create_output_frames(out_frames);\n\n\tif (IS_ISP2401) {\n\t\t \n\t\tsensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR);\n\t\tbuffered_sensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR);\n\t\tonline = pipe->stream->config.online;\n\t\tcontinuous = pipe->stream->config.continuous;\n\t\tneed_in_frameinfo_memory =\n\t\t!((sensor && (online || continuous)) || (buffered_sensor &&\n\t\t\t\t\t\t\t(online || continuous)));\n\t} else {\n\t\t \n\t\tneed_in_frameinfo_memory = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;\n\t}\n\n\tif (need_in_frameinfo_memory) {\n\t\terr = init_in_frameinfo_memory_defaults(pipe, &me->in_frame,\n\t\t\t\t\t\t\tIA_CSS_FRAME_FORMAT_RAW);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\n\t\tin_frame = &me->in_frame;\n\t} else {\n\t\tin_frame = NULL;\n\t}\n\n\terr = init_out_frameinfo_defaults(pipe, &me->out_frame[0], 0);\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\tout_frame = &me->out_frame[0];\n\n\t \n\tif (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0]) {\n\t\tif (mode == IA_CSS_CAPTURE_MODE_RAW || mode == IA_CSS_CAPTURE_MODE_BAYER) {\n\t\t\t \n\t\t\tvf_frame = NULL;\n\t\t} else {\n\t\t\tinit_vf_frameinfo_defaults(pipe, &me->vf_frame[0], 0);\n\t\t\tvf_frame = &me->vf_frame[0];\n\t\t}\n\t} else {\n\t\tvf_frame = NULL;\n\t}\n\n\tcopy_binary       = &pipe->pipe_settings.capture.copy_binary;\n\tnum_primary_stage = pipe->pipe_settings.capture.num_primary_stage;\n\tif ((num_primary_stage == 0) && (mode == IA_CSS_CAPTURE_MODE_PRIMARY)) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_primary_stage; i++)\n\t\tprimary_binary[i] = &pipe->pipe_settings.capture.primary_binary[i];\n\n\tvf_pp_binary      = &pipe->pipe_settings.capture.vf_pp_binary;\n\tpre_isp_binary    = &pipe->pipe_settings.capture.pre_isp_binary;\n\tanr_gdc_binary    = &pipe->pipe_settings.capture.anr_gdc_binary;\n\tpost_isp_binary   = &pipe->pipe_settings.capture.post_isp_binary;\n\tcapture_pp_binary = &pipe->pipe_settings.capture.capture_pp_binary;\n\tyuv_scaler_binary = pipe->pipe_settings.capture.yuv_scaler_binary;\n\tnum_yuv_scaler\t  = pipe->pipe_settings.capture.num_yuv_scaler;\n\tis_output_stage   = pipe->pipe_settings.capture.is_output_stage;\n\tcapture_ldc_binary = &pipe->pipe_settings.capture.capture_ldc_binary;\n\n\tneed_pp = (need_capture_pp(pipe) || pipe->output_stage) &&\n\t\t    mode != IA_CSS_CAPTURE_MODE_RAW &&\n\t\t    mode != IA_CSS_CAPTURE_MODE_BAYER;\n\tneed_yuv_pp = (yuv_scaler_binary && yuv_scaler_binary->info);\n\tneed_ldc = (capture_ldc_binary && capture_ldc_binary->info);\n\n\tif (pipe->pipe_settings.capture.copy_binary.info) {\n\t\tif (raw) {\n\t\t\tia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);\n\t\t\tif (IS_ISP2401) {\n\t\t\t\tif (!continuous) {\n\t\t\t\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t\t\t\t   copy_binary,\n\t\t\t\t\t\t\t\t\t   out_frames,\n\t\t\t\t\t\t\t\t\t   in_frame,\n\t\t\t\t\t\t\t\t\t   NULL);\n\t\t\t\t} else {\n\t\t\t\t\tin_frame = pipe->stream->last_pipe->continuous_frames[0];\n\t\t\t\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t\t\t\t   copy_binary,\n\t\t\t\t\t\t\t\t\t   out_frames,\n\t\t\t\t\t\t\t\t\t   in_frame,\n\t\t\t\t\t\t\t\t\t   NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t\t\t   copy_binary,\n\t\t\t\t\t\t\t\t   out_frames,\n\t\t\t\t\t\t\t\t   NULL, NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tia_css_pipe_util_set_output_frames(out_frames, 0,\n\t\t\t\t\t\t\t   in_frame);\n\t\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t\t   copy_binary,\n\t\t\t\t\t\t\t   out_frames,\n\t\t\t\t\t\t\t   NULL, NULL);\n\t\t}\n\n\t\terr = ia_css_pipeline_create_and_add_stage(me,\n\t\t\t\t\t\t\t   &stage_desc,\n\t\t\t\t\t\t\t   &current_stage);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t} else if (pipe->stream->config.continuous) {\n\t\tin_frame = pipe->stream->last_pipe->continuous_frames[0];\n\t}\n\n\tif (mode == IA_CSS_CAPTURE_MODE_PRIMARY) {\n\t\tstruct ia_css_frame *local_in_frame = NULL;\n\t\tstruct ia_css_frame *local_out_frame = NULL;\n\n\t\tfor (i = 0; i < num_primary_stage; i++) {\n\t\t\tif (i == 0)\n\t\t\t\tlocal_in_frame = in_frame;\n\t\t\telse\n\t\t\t\tlocal_in_frame = NULL;\n\t\t\tif (!need_pp && (i == num_primary_stage - 1) && (!IS_ISP2401 || !need_ldc))\n\t\t\t\tlocal_out_frame = out_frame;\n\t\t\telse\n\t\t\t\tlocal_out_frame = NULL;\n\t\t\tia_css_pipe_util_set_output_frames(out_frames, 0, local_out_frame);\n\t\t\t \n\t\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t\t   primary_binary[i],\n\t\t\t\t\t\t\t   out_frames,\n\t\t\t\t\t\t\t   local_in_frame,\n\t\t\t\t\t\t\t   NULL);\n\t\t\terr = ia_css_pipeline_create_and_add_stage(me,\n\t\t\t\t\t\t\t\t   &stage_desc,\n\t\t\t\t\t\t\t\t   &current_stage);\n\t\t\tif (err) {\n\t\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\t \n\t\tcurrent_stage->args.copy_vf =\n\t\t    primary_binary[0]->info->sp.pipeline.mode ==\n\t\t    IA_CSS_BINARY_MODE_COPY;\n\t\tcurrent_stage->args.copy_output = current_stage->args.copy_vf;\n\t} else if (mode == IA_CSS_CAPTURE_MODE_ADVANCED ||\n\t\t    mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT) {\n\t\tia_css_pipe_util_set_output_frames(out_frames, 0, NULL);\n\t\tia_css_pipe_get_generic_stage_desc(&stage_desc, pre_isp_binary,\n\t\t\t\t\t\t   out_frames, in_frame, NULL);\n\t\terr = ia_css_pipeline_create_and_add_stage(me, &stage_desc,\n\t\t\t\t\t\t\t   NULL);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t\tia_css_pipe_util_set_output_frames(out_frames, 0, NULL);\n\t\tia_css_pipe_get_generic_stage_desc(&stage_desc, anr_gdc_binary,\n\t\t\t\t\t\t   out_frames, NULL, NULL);\n\t\terr = ia_css_pipeline_create_and_add_stage(me, &stage_desc,\n\t\t\t\t\t\t\t   NULL);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (need_pp) {\n\t\t\tia_css_pipe_util_set_output_frames(out_frames, 0, NULL);\n\t\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t\t   post_isp_binary,\n\t\t\t\t\t\t\t   out_frames,\n\t\t\t\t\t\t\t   NULL, NULL);\n\t\t} else {\n\t\t\tia_css_pipe_util_set_output_frames(out_frames, 0,\n\t\t\t\t\t\t\t   out_frame);\n\t\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t\t   post_isp_binary,\n\t\t\t\t\t\t\t   out_frames,\n\t\t\t\t\t\t\t   NULL, NULL);\n\t\t}\n\n\t\terr = ia_css_pipeline_create_and_add_stage(me, &stage_desc,\n\t\t\t\t\t\t\t   &current_stage);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t} else if (mode == IA_CSS_CAPTURE_MODE_BAYER) {\n\t\tia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);\n\t\tia_css_pipe_get_generic_stage_desc(&stage_desc, pre_isp_binary,\n\t\t\t\t\t\t   out_frames, in_frame, NULL);\n\t\terr = ia_css_pipeline_create_and_add_stage(me, &stage_desc,\n\t\t\t\t\t\t\t   NULL);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (need_pp && current_stage) {\n\t\tstruct ia_css_frame *local_in_frame = NULL;\n\n\t\tlocal_in_frame = current_stage->args.out_frame[0];\n\n\t\tif (need_ldc) {\n\t\t\tia_css_pipe_util_set_output_frames(out_frames, 0, NULL);\n\t\t\tia_css_pipe_get_generic_stage_desc(&stage_desc,\n\t\t\t\t\t\t\t   capture_ldc_binary,\n\t\t\t\t\t\t\t   out_frames,\n\t\t\t\t\t\t\t   local_in_frame,\n\t\t\t\t\t\t\t   NULL);\n\t\t\terr = ia_css_pipeline_create_and_add_stage(me,\n\t\t\t\t\t\t\t\t   &stage_desc,\n\t\t\t\t\t\t\t\t   &current_stage);\n\t\t\tlocal_in_frame = current_stage->args.out_frame[0];\n\t\t}\n\t\terr = add_capture_pp_stage(pipe, me, local_in_frame,\n\t\t\t\t\t   need_yuv_pp ? NULL : out_frame,\n\t\t\t\t\t   capture_pp_binary,\n\t\t\t\t\t   &current_stage);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (need_yuv_pp && current_stage) {\n\t\tstruct ia_css_frame *tmp_in_frame = current_stage->args.out_frame[0];\n\t\tstruct ia_css_frame *tmp_out_frame = NULL;\n\n\t\tfor (i = 0; i < num_yuv_scaler; i++) {\n\t\t\tif (is_output_stage[i])\n\t\t\t\ttmp_out_frame = out_frame;\n\t\t\telse\n\t\t\t\ttmp_out_frame = NULL;\n\n\t\t\terr = add_yuv_scaler_stage(pipe, me, tmp_in_frame,\n\t\t\t\t\t\t   tmp_out_frame, NULL,\n\t\t\t\t\t\t   &yuv_scaler_binary[i],\n\t\t\t\t\t\t   &yuv_scaler_stage);\n\t\t\tif (err) {\n\t\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\t \n\t\t\ttmp_in_frame = yuv_scaler_stage->args.out_frame[1];\n\t\t}\n\t}\n\n\t \n\tif (mode != IA_CSS_CAPTURE_MODE_RAW &&\n\t    mode != IA_CSS_CAPTURE_MODE_BAYER &&\n\t    current_stage && vf_frame) {\n\t\tin_frame = current_stage->args.out_vf_frame;\n\t\terr = add_vf_pp_stage(pipe, in_frame, vf_frame, vf_pp_binary,\n\t\t\t\t      &current_stage);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\tia_css_pipeline_finalize_stages(&pipe->pipeline, pipe->stream->config.continuous);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"create_host_regular_capture_pipeline() leave:\\n\");\n\n\treturn 0;\n}\n\nstatic int\ncreate_host_capture_pipeline(struct ia_css_pipe *pipe)\n{\n\tint err = 0;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p\", pipe);\n\n\tif (pipe->config.mode == IA_CSS_PIPE_MODE_COPY)\n\t\terr = create_host_isyscopy_capture_pipeline(pipe);\n\telse\n\t\terr = create_host_regular_capture_pipeline(pipe);\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\n\treturn err;\n}\n\nstatic int capture_start(struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_pipeline *me;\n\tunsigned int thread_id;\n\n\tint err = 0;\n\tenum sh_css_pipe_config_override copy_ovrd;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p\", pipe);\n\tif (!pipe) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tme = &pipe->pipeline;\n\n\tif ((pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW   ||\n\t     pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER) &&\n\t    (pipe->config.mode != IA_CSS_PIPE_MODE_COPY)) {\n\t\tif (copy_on_sp(pipe)) {\n\t\t\terr = start_copy_on_sp(pipe, &me->out_frame[0]);\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\t \n\tif (!IS_ISP2401 || (IS_ISP2401 && pipe->config.mode != IA_CSS_PIPE_MODE_COPY)) {\n\t\terr = send_mipi_frames(pipe);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);\n\tcopy_ovrd = 1 << thread_id;\n\n\tstart_pipe(pipe, copy_ovrd, pipe->stream->config.mode);\n\n#if !defined(ISP2401)\n\t \n\tif (pipe->config.mode == IA_CSS_PIPE_MODE_COPY &&\n\t    pipe->stream->reconfigure_css_rx) {\n\t\tia_css_isys_rx_configure(&pipe->stream->csi_rx_config,\n\t\t\t\t\t pipe->stream->config.mode);\n\t\tpipe->stream->reconfigure_css_rx = false;\n\t}\n#endif\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\nstatic int\nsh_css_pipe_get_output_frame_info(struct ia_css_pipe *pipe,\n\t\t\t\t  struct ia_css_frame_info *info,\n\t\t\t\t  unsigned int idx)\n{\n\tassert(pipe);\n\tassert(info);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_pipe_get_output_frame_info() enter:\\n\");\n\n\t*info = pipe->output_info[idx];\n\tif (copy_on_sp(pipe) &&\n\t    pipe->stream->config.input_config.format == ATOMISP_INPUT_FORMAT_BINARY_8) {\n\t\tia_css_frame_info_init(\n\t\t    info,\n\t\t    JPEG_BYTES,\n\t\t    1,\n\t\t    IA_CSS_FRAME_FORMAT_BINARY_8,\n\t\t    0);\n\t} else if (info->format == IA_CSS_FRAME_FORMAT_RAW ||\n\t\t   info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED) {\n\t\tinfo->raw_bit_depth =\n\t\tia_css_pipe_util_pipe_input_format_bpp(pipe);\n\t}\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_pipe_get_output_frame_info() leave:\\n\");\n\treturn 0;\n}\n\nvoid\nia_css_stream_send_input_frame(const struct ia_css_stream *stream,\n\t\t\t       const unsigned short *data,\n\t\t\t       unsigned int width,\n\t\t\t       unsigned int height)\n{\n\tassert(stream);\n\n\tia_css_inputfifo_send_input_frame(\n\t    data, width, height,\n\t    stream->config.channel_id,\n\t    stream->config.input_config.format,\n\t    stream->config.pixels_per_clock == 2);\n}\n\nvoid\nia_css_stream_start_input_frame(const struct ia_css_stream *stream)\n{\n\tassert(stream);\n\n\tia_css_inputfifo_start_frame(\n\t    stream->config.channel_id,\n\t    stream->config.input_config.format,\n\t    stream->config.pixels_per_clock == 2);\n}\n\nvoid\nia_css_stream_send_input_line(const struct ia_css_stream *stream,\n\t\t\t      const unsigned short *data,\n\t\t\t      unsigned int width,\n\t\t\t      const unsigned short *data2,\n\t\t\t      unsigned int width2)\n{\n\tassert(stream);\n\n\tia_css_inputfifo_send_line(stream->config.channel_id,\n\t\t\t\t   data, width, data2, width2);\n}\n\nvoid\nia_css_stream_send_input_embedded_line(const struct ia_css_stream *stream,\n\t\t\t\t       enum atomisp_input_format format,\n\t\t\t\t       const unsigned short *data,\n\t\t\t\t       unsigned int width)\n{\n\tassert(stream);\n\tif (!data || width == 0)\n\t\treturn;\n\tia_css_inputfifo_send_embedded_line(stream->config.channel_id,\n\t\t\t\t\t    format, data, width);\n}\n\nvoid\nia_css_stream_end_input_frame(const struct ia_css_stream *stream)\n{\n\tassert(stream);\n\n\tia_css_inputfifo_end_frame(stream->config.channel_id);\n}\n\nbool\nia_css_pipeline_uses_params(struct ia_css_pipeline *me)\n{\n\tstruct ia_css_pipeline_stage *stage;\n\n\tassert(me);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_pipeline_uses_params() enter: me=%p\\n\", me);\n\n\tfor (stage = me->stages; stage; stage = stage->next)\n\t\tif (stage->binary_info && stage->binary_info->enable.params) {\n\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t    \"ia_css_pipeline_uses_params() leave: return_bool=true\\n\");\n\t\t\treturn true;\n\t\t}\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_pipeline_uses_params() leave: return_bool=false\\n\");\n\treturn false;\n}\n\n \nint ia_css_stream_capture_frame(struct ia_css_stream *stream,\n\t\t\t\tunsigned int exp_id)\n{\n\tstruct sh_css_tag_descr tag_descr;\n\tu32 encoded_tag_descr;\n\tint err;\n\n\tassert(stream);\n\tIA_CSS_ENTER(\"exp_id=%d\", exp_id);\n\n\t \n\tif (exp_id == 0 || !stream->config.continuous) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!sh_css_sp_is_running()) {\n\t\t \n\t\tIA_CSS_LEAVE_ERR(-EBUSY);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tsh_css_create_tag_descr(0, 0, 0, exp_id, &tag_descr);\n\t \n\tencoded_tag_descr = sh_css_encode_tag_descr(&tag_descr);\n\t \n\terr = ia_css_bufq_enqueue_tag_cmd(encoded_tag_descr);\n\n\tIA_CSS_LEAVE_ERR(err);\n\treturn err;\n}\n\n \nint ia_css_stream_capture(struct ia_css_stream *stream, int num_captures,\n\t\t\t  unsigned int skip, int offset)\n{\n\tstruct sh_css_tag_descr tag_descr;\n\tunsigned int encoded_tag_descr;\n\tint return_err;\n\n\tif (!stream)\n\t\treturn -EINVAL;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_stream_capture() enter: num_captures=%d, skip=%d, offset=%d\\n\",\n\t\t\t    num_captures, skip, offset);\n\n\t \n\tif (num_captures < SH_CSS_MINIMUM_TAG_ID) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"ia_css_stream_capture() leave: return_err=%d\\n\",\n\t\t\t\t    -EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsh_css_create_tag_descr(num_captures, skip, offset, 0, &tag_descr);\n\n\t \n\tencoded_tag_descr = sh_css_encode_tag_descr(&tag_descr);\n\n\tif (!sh_css_sp_is_running()) {\n\t\t \n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"ia_css_stream_capture() leaving:queues unavailable\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\treturn_err = ia_css_bufq_enqueue_tag_cmd((uint32_t)encoded_tag_descr);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_stream_capture() leave: return_err=%d\\n\",\n\t\t\t    return_err);\n\n\treturn return_err;\n}\n\nvoid ia_css_stream_request_flash(struct ia_css_stream *stream)\n{\n\t(void)stream;\n\n\tassert(stream);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_stream_request_flash() enter: void\\n\");\n\n#ifndef ISP2401\n\tsh_css_write_host2sp_command(host2sp_cmd_start_flash);\n#else\n\tif (sh_css_sp_is_running()) {\n\t\tif (!sh_css_write_host2sp_command(host2sp_cmd_start_flash)) {\n\t\t\tIA_CSS_ERROR(\"Call to 'sh-css_write_host2sp_command()' failed\");\n\t\t\tia_css_debug_dump_sp_sw_debug_info();\n\t\t\tia_css_debug_dump_debug_info(NULL);\n\t\t}\n\t} else {\n\t\tIA_CSS_LOG(\"SP is not running!\");\n\t}\n\n#endif\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_stream_request_flash() leave: return_void\\n\");\n}\n\nstatic void\nsh_css_init_host_sp_control_vars(void)\n{\n\tconst struct ia_css_fw_info *fw;\n\tunsigned int HIVE_ADDR_ia_css_ispctrl_sp_isp_started;\n\n\tunsigned int HIVE_ADDR_host_sp_queues_initialized;\n\tunsigned int HIVE_ADDR_sp_sleep_mode;\n\tunsigned int HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb;\n\tunsigned int HIVE_ADDR_sp_stop_copy_preview;\n\tunsigned int HIVE_ADDR_host_sp_com;\n\tunsigned int o = offsetof(struct host_sp_communication, host2sp_command)\n\t\t\t    / sizeof(int);\n\n\tunsigned int i;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_init_host_sp_control_vars() enter: void\\n\");\n\n\tfw = &sh_css_sp_fw;\n\tHIVE_ADDR_ia_css_ispctrl_sp_isp_started = fw->info.sp.isp_started;\n\n\tHIVE_ADDR_host_sp_queues_initialized =\n\t    fw->info.sp.host_sp_queues_initialized;\n\tHIVE_ADDR_sp_sleep_mode = fw->info.sp.sleep_mode;\n\tHIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb = fw->info.sp.invalidate_tlb;\n\tHIVE_ADDR_sp_stop_copy_preview = fw->info.sp.stop_copy_preview;\n\tHIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;\n\n\tsp_dmem_store_uint32(SP0_ID,\n\t\t\t     (unsigned int)sp_address_of(ia_css_ispctrl_sp_isp_started),\n\t\t\t     (uint32_t)(0));\n\n\tsp_dmem_store_uint32(SP0_ID,\n\t\t\t     (unsigned int)sp_address_of(host_sp_queues_initialized),\n\t\t\t     (uint32_t)(0));\n\tsp_dmem_store_uint32(SP0_ID,\n\t\t\t     (unsigned int)sp_address_of(sp_sleep_mode),\n\t\t\t     (uint32_t)(0));\n\tsp_dmem_store_uint32(SP0_ID,\n\t\t\t     (unsigned int)sp_address_of(ia_css_dmaproxy_sp_invalidate_tlb),\n\t\t\t     (uint32_t)(false));\n\tsp_dmem_store_uint32(SP0_ID,\n\t\t\t     (unsigned int)sp_address_of(sp_stop_copy_preview),\n\t\t\t     my_css.stop_copy_preview ? (uint32_t)(1) : (uint32_t)(0));\n\tstore_sp_array_uint(host_sp_com, o, host2sp_cmd_ready);\n\n\tfor (i = 0; i < N_CSI_PORTS; i++) {\n\t\tsh_css_update_host2sp_num_mipi_frames\n\t\t(my_css.num_mipi_frames[i]);\n\t}\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_init_host_sp_control_vars() leave: return_void\\n\");\n}\n\n \n\nstatic const struct\nia_css_pipe_config ia_css_pipe_default_config = DEFAULT_PIPE_CONFIG;\n\nvoid ia_css_pipe_config_defaults(struct ia_css_pipe_config *pipe_config)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_pipe_config_defaults()\\n\");\n\tmemcpy(pipe_config, &ia_css_pipe_default_config, sizeof(*pipe_config));\n}\n\nvoid\nia_css_pipe_extra_config_defaults(struct ia_css_pipe_extra_config *extra_config)\n{\n\tif (!extra_config) {\n\t\tIA_CSS_ERROR(\"NULL input parameter\");\n\t\treturn;\n\t}\n\n\textra_config->enable_raw_binning = false;\n\textra_config->enable_yuv_ds = false;\n\textra_config->enable_high_speed = false;\n\textra_config->enable_dvs_6axis = false;\n\textra_config->enable_reduced_pipe = false;\n\textra_config->disable_vf_pp = false;\n\textra_config->enable_fractional_ds = false;\n}\n\nvoid ia_css_stream_config_defaults(struct ia_css_stream_config *stream_config)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_stream_config_defaults()\\n\");\n\tassert(stream_config);\n\tmemset(stream_config, 0, sizeof(*stream_config));\n\tstream_config->online = true;\n\tstream_config->left_padding = -1;\n\tstream_config->pixels_per_clock = 1;\n\t \n\tstream_config->source.port.rxcount = 0x04040404;\n}\n\nint ia_css_pipe_create(const struct ia_css_pipe_config *config,\n\t\t       struct ia_css_pipe **pipe)\n{\n\tint err = 0;\n\n\tIA_CSS_ENTER_PRIVATE(\"config = %p, pipe = %p\", config, pipe);\n\n\tif (!config || !pipe) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\terr = ia_css_pipe_create_extra(config, NULL, pipe);\n\n\tif (err == 0)\n\t\tIA_CSS_LOG(\"pipe created successfully = %p\", *pipe);\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\n\treturn err;\n}\n\nint\nia_css_pipe_create_extra(const struct ia_css_pipe_config *config,\n\t\t\t const struct ia_css_pipe_extra_config *extra_config,\n\t\t\t struct ia_css_pipe **pipe)\n{\n\tint err = -EINVAL;\n\tstruct ia_css_pipe *internal_pipe = NULL;\n\tunsigned int i;\n\n\tIA_CSS_ENTER_PRIVATE(\"config = %p, extra_config = %p and pipe = %p\", config, extra_config, pipe);\n\n\t \n\tif (my_css.pipe_counter >= IA_CSS_PIPELINE_NUM_MAX) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-ENOSPC);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((!pipe) || (!config)) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tia_css_debug_dump_pipe_config(config);\n\tia_css_debug_dump_pipe_extra_config(extra_config);\n\n\terr = create_pipe(config->mode, &internal_pipe, false);\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\n\t \n\tinternal_pipe->config = *config;\n\tif (extra_config)\n\t\tinternal_pipe->extra_config = *extra_config;\n\telse\n\t\tia_css_pipe_extra_config_defaults(&internal_pipe->extra_config);\n\n\t \n\tif (internal_pipe->config.dvs_frame_delay == IA_CSS_FRAME_DELAY_2)\n\t\tinternal_pipe->dvs_frame_delay = 2;\n\telse\n\t\tinternal_pipe->dvs_frame_delay = 1;\n\n\t \n\n\t \n\tif ((internal_pipe->config.vf_pp_in_res.width ||\n\t     internal_pipe->config.capt_pp_in_res.width)) {\n\t\tenum ia_css_frame_format format;\n\n\t\tif (internal_pipe->config.vf_pp_in_res.width) {\n\t\t\tformat = IA_CSS_FRAME_FORMAT_YUV_LINE;\n\t\t\tia_css_frame_info_init(\n\t\t\t    &internal_pipe->vf_yuv_ds_input_info,\n\t\t\t    internal_pipe->config.vf_pp_in_res.width,\n\t\t\t    internal_pipe->config.vf_pp_in_res.height,\n\t\t\t    format, 0);\n\t\t}\n\t\tif (internal_pipe->config.capt_pp_in_res.width) {\n\t\t\tformat = IA_CSS_FRAME_FORMAT_YUV420;\n\t\t\tia_css_frame_info_init(\n\t\t\t    &internal_pipe->out_yuv_ds_input_info,\n\t\t\t    internal_pipe->config.capt_pp_in_res.width,\n\t\t\t    internal_pipe->config.capt_pp_in_res.height,\n\t\t\t    format, 0);\n\t\t}\n\t}\n\tif (internal_pipe->config.vf_pp_in_res.width &&\n\t    internal_pipe->config.mode == IA_CSS_PIPE_MODE_PREVIEW) {\n\t\tia_css_frame_info_init(\n\t\t    &internal_pipe->vf_yuv_ds_input_info,\n\t\t    internal_pipe->config.vf_pp_in_res.width,\n\t\t    internal_pipe->config.vf_pp_in_res.height,\n\t\t    IA_CSS_FRAME_FORMAT_YUV_LINE, 0);\n\t}\n\t \n\tif (internal_pipe->config.bayer_ds_out_res.width) {\n\t\tia_css_frame_info_init(\n\t\t    &internal_pipe->bds_output_info,\n\t\t    internal_pipe->config.bayer_ds_out_res.width,\n\t\t    internal_pipe->config.bayer_ds_out_res.height,\n\t\t    IA_CSS_FRAME_FORMAT_RAW, 0);\n\t}\n\n\t \n\tfor (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {\n\t\tif (internal_pipe->config.output_info[i].res.width) {\n\t\t\terr = sh_css_pipe_configure_output(\n\t\t\t\t    internal_pipe,\n\t\t\t\t    internal_pipe->config.output_info[i].res.width,\n\t\t\t\t    internal_pipe->config.output_info[i].res.height,\n\t\t\t\t    internal_pipe->config.output_info[i].padded_width,\n\t\t\t\t    internal_pipe->config.output_info[i].format,\n\t\t\t\t    i);\n\t\t\tif (err) {\n\t\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\t\tkvfree(internal_pipe);\n\t\t\t\tinternal_pipe = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tinternal_pipe->enable_viewfinder[i] =\n\t\t    (internal_pipe->config.vf_output_info[i].res.width != 0);\n\t\tif (internal_pipe->config.vf_output_info[i].res.width) {\n\t\t\terr = sh_css_pipe_configure_viewfinder(\n\t\t\t\t    internal_pipe,\n\t\t\t\t    internal_pipe->config.vf_output_info[i].res.width,\n\t\t\t\t    internal_pipe->config.vf_output_info[i].res.height,\n\t\t\t\t    internal_pipe->config.vf_output_info[i].padded_width,\n\t\t\t\t    internal_pipe->config.vf_output_info[i].format,\n\t\t\t\t    i);\n\t\t\tif (err) {\n\t\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\t\tkvfree(internal_pipe);\n\t\t\t\tinternal_pipe = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tmemset(&internal_pipe->info, 0, sizeof(internal_pipe->info));\n\n\t \n\t*pipe = internal_pipe;\n\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\treturn 0;\n}\n\nint\nia_css_pipe_get_info(const struct ia_css_pipe *pipe,\n\t\t     struct ia_css_pipe_info *pipe_info)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_pipe_get_info()\\n\");\n\tif (!pipe_info) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,\n\t\t\t\t    \"ia_css_pipe_get_info: pipe_info cannot be NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!pipe || !pipe->stream) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,\n\t\t\t\t    \"ia_css_pipe_get_info: ia_css_stream_create needs to be called before ia_css_[stream/pipe]_get_info\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\t*pipe_info = pipe->info;\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_pipe_get_info() leave\\n\");\n\treturn 0;\n}\n\nbool ia_css_pipe_has_dvs_stats(struct ia_css_pipe_info *pipe_info)\n{\n\tunsigned int i;\n\n\tif (pipe_info) {\n\t\tfor (i = 0; i < IA_CSS_DVS_STAT_NUM_OF_LEVELS; i++) {\n\t\t\tif (pipe_info->grid_info.dvs_grid.dvs_stat_grid_info.grd_cfg[i].grd_start.enable)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint\nia_css_pipe_override_frame_format(struct ia_css_pipe *pipe,\n\t\t\t\t  int pin_index,\n\t\t\t\t  enum ia_css_frame_format new_format)\n{\n\tint err = 0;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe = %p, pin_index = %d, new_formats = %d\", pipe, pin_index, new_format);\n\n\tif (!pipe) {\n\t\tIA_CSS_ERROR(\"pipe is not set\");\n\t\terr = -EINVAL;\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\tif (0 != pin_index && 1 != pin_index) {\n\t\tIA_CSS_ERROR(\"pin index is not valid\");\n\t\terr = -EINVAL;\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\tif (new_format != IA_CSS_FRAME_FORMAT_NV12_TILEY) {\n\t\tIA_CSS_ERROR(\"new format is not valid\");\n\t\terr = -EINVAL;\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t} else {\n\t\terr = ia_css_pipe_check_format(pipe, new_format);\n\t\tif (!err) {\n\t\t\tif (pin_index == 0)\n\t\t\t\tpipe->output_info[0].format = new_format;\n\t\t\telse\n\t\t\t\tpipe->vf_output_info[0].format = new_format;\n\t\t}\n\t}\n\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\treturn err;\n}\n\n#if !defined(ISP2401)\n \nstatic int\nia_css_stream_configure_rx(struct ia_css_stream *stream)\n{\n\tstruct ia_css_input_port *config;\n\n\tassert(stream);\n\n\tconfig = &stream->config.source.port;\n\t \n\tif (config->num_lanes == 1)\n\t\tstream->csi_rx_config.mode = MONO_1L_1L_0L;\n\telse if (config->num_lanes == 2)\n\t\tstream->csi_rx_config.mode = MONO_2L_1L_0L;\n\telse if (config->num_lanes == 3)\n\t\tstream->csi_rx_config.mode = MONO_3L_1L_0L;\n\telse if (config->num_lanes == 4)\n\t\tstream->csi_rx_config.mode = MONO_4L_1L_0L;\n\telse if (config->num_lanes != 0)\n\t\treturn -EINVAL;\n\n\tif (config->port > MIPI_PORT2_ID)\n\t\treturn -EINVAL;\n\tstream->csi_rx_config.port =\n\tia_css_isys_port_to_mipi_port(config->port);\n\tstream->csi_rx_config.timeout    = config->timeout;\n\tstream->csi_rx_config.initcount  = 0;\n\tstream->csi_rx_config.synccount  = 0x28282828;\n\tstream->csi_rx_config.rxcount    = config->rxcount;\n\tif (config->compression.type == IA_CSS_CSI2_COMPRESSION_TYPE_NONE)\n\t\tstream->csi_rx_config.comp = MIPI_PREDICTOR_NONE;\n\telse\n\t\t \n\t\treturn -EINVAL;\n\n\tstream->csi_rx_config.is_two_ppc = (stream->config.pixels_per_clock == 2);\n\tstream->reconfigure_css_rx = true;\n\treturn 0;\n}\n#endif\n\nstatic struct ia_css_pipe *\nfind_pipe(struct ia_css_pipe *pipes[], unsigned int num_pipes,\n\t  enum ia_css_pipe_mode mode, bool copy_pipe)\n{\n\tunsigned int i;\n\n\tassert(pipes);\n\tfor (i = 0; i < num_pipes; i++) {\n\t\tassert(pipes[i]);\n\t\tif (pipes[i]->config.mode != mode)\n\t\t\tcontinue;\n\t\tif (copy_pipe && pipes[i]->mode != IA_CSS_PIPE_ID_COPY)\n\t\t\tcontinue;\n\t\treturn pipes[i];\n\t}\n\treturn NULL;\n}\n\nstatic int\nmetadata_info_init(const struct ia_css_metadata_config *mdc,\n\t\t   struct ia_css_metadata_info *md)\n{\n\t \n\tif ((mdc->resolution.height > 0) ^ (mdc->resolution.width > 0))\n\t\treturn -EINVAL;\n\n\tmd->resolution = mdc->resolution;\n\t \n\tmd->stride = CEIL_MUL(mdc->resolution.width, HIVE_ISP_DDR_WORD_BYTES);\n\tmd->size = mdc->resolution.height * md->stride;\n\treturn 0;\n}\n\nint\nia_css_stream_create(const struct ia_css_stream_config *stream_config,\n\t\t     int num_pipes,\n\t\t     struct ia_css_pipe *pipes[],\n\t\t     struct ia_css_stream **stream)\n{\n\tstruct ia_css_pipe *curr_pipe;\n\tstruct ia_css_stream *curr_stream = NULL;\n\tbool spcopyonly;\n\tbool sensor_binning_changed;\n\tint i, j;\n\tint err = -EINVAL;\n\tstruct ia_css_metadata_info md_info;\n\tstruct ia_css_resolution effective_res;\n\n\tIA_CSS_ENTER(\"num_pipes=%d\", num_pipes);\n\tia_css_debug_dump_stream_config(stream_config, num_pipes);\n\n\t \n\tif (num_pipes == 0 ||\n\t    !stream ||\n\t    !pipes) {\n\t\terr = -EINVAL;\n\t\tIA_CSS_LEAVE_ERR(err);\n\t\treturn err;\n\t}\n\n\tif (!IS_ISP2401) {\n\t\t \n\t\tif (stream_config->input_config.format == ATOMISP_INPUT_FORMAT_BINARY_8 &&\n\t\t    stream_config->metadata_config.resolution.height > 0) {\n\t\t\terr = -EINVAL;\n\t\t\tIA_CSS_LEAVE_ERR(err);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (stream_config->online && stream_config->pack_raw_pixels) {\n\t\t\tIA_CSS_LOG(\"online and pack raw is invalid on input system 2401\");\n\t\t\terr = -EINVAL;\n\t\t\tIA_CSS_LEAVE_ERR(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tia_css_debug_pipe_graph_dump_stream_config(stream_config);\n\n\t \n\tif (stream_config->mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR)\n#ifdef ISP2401\n\t\tif (!stream_config->online)\n#endif\n\t\t{\n\t\t\tunsigned int port = (unsigned int)stream_config->source.port.port;\n\n\t\t\tif (port >= N_MIPI_PORT_ID) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tIA_CSS_LEAVE_ERR(err);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tif (my_css.size_mem_words != 0) {\n\t\t\t\tmy_css.mipi_frame_size[port] = my_css.size_mem_words;\n\t\t\t} else if (stream_config->mipi_buffer_config.size_mem_words != 0) {\n\t\t\t\tmy_css.mipi_frame_size[port] = stream_config->mipi_buffer_config.size_mem_words;\n\t\t\t} else {\n\t\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t\t    \"ia_css_stream_create() exit: error, need to set mipi frame size.\\n\");\n\t\t\t\tassert(stream_config->mipi_buffer_config.size_mem_words != 0);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tIA_CSS_LEAVE_ERR(err);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tif (my_css.size_mem_words != 0) {\n\t\t\t\tmy_css.num_mipi_frames[port] =\n\t\t\t\t    2;  \n\t\t\t} else if (stream_config->mipi_buffer_config.nof_mipi_buffers != 0) {\n\t\t\t\tmy_css.num_mipi_frames[port] =\n\t\t\t\t    stream_config->mipi_buffer_config.nof_mipi_buffers;\n\t\t\t} else {\n\t\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t\t    \"ia_css_stream_create() exit: error, need to set number of mipi frames.\\n\");\n\t\t\t\tassert(stream_config->mipi_buffer_config.nof_mipi_buffers != 0);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tIA_CSS_LEAVE_ERR(err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t \n\terr = metadata_info_init(&stream_config->metadata_config, &md_info);\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR(err);\n\t\treturn err;\n\t}\n\n\t \n\tcurr_stream = kzalloc(sizeof(struct ia_css_stream), GFP_KERNEL);\n\tif (!curr_stream) {\n\t\terr = -ENOMEM;\n\t\tIA_CSS_LEAVE_ERR(err);\n\t\treturn err;\n\t}\n\t \n\tcurr_stream->info.metadata_info = md_info;\n\n\t \n\tcurr_stream->num_pipes = num_pipes;\n\tcurr_stream->pipes = kcalloc(num_pipes, sizeof(struct ia_css_pipe *), GFP_KERNEL);\n\tif (!curr_stream->pipes) {\n\t\tcurr_stream->num_pipes = 0;\n\t\tkfree(curr_stream);\n\t\tcurr_stream = NULL;\n\t\terr = -ENOMEM;\n\t\tIA_CSS_LEAVE_ERR(err);\n\t\treturn err;\n\t}\n\t \n\tspcopyonly = (num_pipes == 1) && (pipes[0]->config.mode == IA_CSS_PIPE_MODE_COPY);\n\tfor (i = 0; i < num_pipes; i++)\n\t\tcurr_stream->pipes[i] = pipes[i];\n\tcurr_stream->last_pipe = curr_stream->pipes[0];\n\t \n\tcurr_stream->config = *stream_config;\n\n\tif (IS_ISP2401) {\n\t\tif (stream_config->mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR &&\n\t\t    stream_config->online)\n\t\t\tcurr_stream->config.online = false;\n\n\t\tif (curr_stream->config.online) {\n\t\t\tcurr_stream->config.source.port.num_lanes =\n\t\t\t    stream_config->source.port.num_lanes;\n\t\t\tcurr_stream->config.mode =  IA_CSS_INPUT_MODE_BUFFERED_SENSOR;\n\t\t}\n\t}\n\t \n\tif (curr_stream->config.target_num_cont_raw_buf == 0)\n\t\tcurr_stream->config.target_num_cont_raw_buf = NUM_CONTINUOUS_FRAMES;\n\tif (curr_stream->config.init_num_cont_raw_buf == 0)\n\t\tcurr_stream->config.init_num_cont_raw_buf = curr_stream->config.target_num_cont_raw_buf;\n\n\t \n\tif (curr_stream->config.ia_css_enable_raw_buffer_locking)\n\t\tsh_css_sp_configure_enable_raw_pool_locking(\n\t\t    curr_stream->config.lock_all);\n\n\t \n\tswitch (curr_stream->config.mode) {\n\tcase IA_CSS_INPUT_MODE_SENSOR:\n\tcase IA_CSS_INPUT_MODE_BUFFERED_SENSOR:\n#if !defined(ISP2401)\n\t\tia_css_stream_configure_rx(curr_stream);\n#endif\n\t\tbreak;\n\tcase IA_CSS_INPUT_MODE_TPG:\n#if !defined(ISP2401)\n\t\tIA_CSS_LOG(\"tpg_configuration: x_mask=%d, y_mask=%d, x_delta=%d, y_delta=%d, xy_mask=%d\",\n\t\t\t   curr_stream->config.source.tpg.x_mask,\n\t\t\t   curr_stream->config.source.tpg.y_mask,\n\t\t\t   curr_stream->config.source.tpg.x_delta,\n\t\t\t   curr_stream->config.source.tpg.y_delta,\n\t\t\t   curr_stream->config.source.tpg.xy_mask);\n\n\t\tsh_css_sp_configure_tpg(\n\t\t    curr_stream->config.source.tpg.x_mask,\n\t\t    curr_stream->config.source.tpg.y_mask,\n\t\t    curr_stream->config.source.tpg.x_delta,\n\t\t    curr_stream->config.source.tpg.y_delta,\n\t\t    curr_stream->config.source.tpg.xy_mask);\n#endif\n\t\tbreak;\n\tcase IA_CSS_INPUT_MODE_PRBS:\n#if !defined(ISP2401)\n\t\tIA_CSS_LOG(\"mode prbs\");\n\t\tsh_css_sp_configure_prbs(curr_stream->config.source.prbs.seed);\n#endif\n\t\tbreak;\n\tcase IA_CSS_INPUT_MODE_MEMORY:\n\t\tIA_CSS_LOG(\"mode memory\");\n\t\tcurr_stream->reconfigure_css_rx = false;\n\t\tbreak;\n\tdefault:\n\t\tIA_CSS_LOG(\"mode sensor/default\");\n\t}\n\n\tfor (i = 0; i < num_pipes; i++) {\n\t\tstruct ia_css_resolution effective_res;\n\n\t\tcurr_pipe = pipes[i];\n\t\t \n\t\tcurr_pipe->stream = curr_stream;\n\t\t \n\n\t\teffective_res = curr_pipe->config.input_effective_res;\n\t\tif (effective_res.height == 0 || effective_res.width == 0) {\n\t\t\teffective_res = curr_pipe->stream->config.input_config.effective_res;\n\n\t\t\tcurr_pipe->config.input_effective_res = effective_res;\n\t\t}\n\t\tIA_CSS_LOG(\"effective_res=%dx%d\",\n\t\t\t   effective_res.width,\n\t\t\t   effective_res.height);\n\t}\n\n\terr = ia_css_stream_isp_parameters_init(curr_stream);\n\tif (err)\n\t\tgoto ERR;\n\tIA_CSS_LOG(\"isp_params_configs: %p\", curr_stream->isp_params_configs);\n\n\t \n\tif (!spcopyonly) {\n\t\tsensor_binning_changed =\n\t\t    sh_css_params_set_binning_factor(curr_stream,\n\t\t\t\t\t\t     curr_stream->config.sensor_binning_factor);\n\t} else {\n\t\tsensor_binning_changed = false;\n\t}\n\n\tIA_CSS_LOG(\"sensor_binning=%d, changed=%d\",\n\t\t   curr_stream->config.sensor_binning_factor, sensor_binning_changed);\n\t \n\tIA_CSS_LOG(\"num_pipes=%d\", num_pipes);\n\tcurr_stream->cont_capt = false;\n\t \n\tif (curr_stream->config.continuous) {\n\t\t \n\t\tstruct ia_css_pipe *preview_pipe;\n\t\tstruct ia_css_pipe *video_pipe;\n\t\tstruct ia_css_pipe *capture_pipe = NULL;\n\t\tstruct ia_css_pipe *copy_pipe = NULL;\n\n\t\tif (num_pipes >= 2) {\n\t\t\tcurr_stream->cont_capt = true;\n\t\t\tcurr_stream->disable_cont_vf = curr_stream->config.disable_cont_viewfinder;\n\t\t\tcurr_stream->stop_copy_preview = my_css.stop_copy_preview;\n\t\t}\n\n\t\t \n\t\tpreview_pipe = find_pipe(pipes, num_pipes,\n\t\t\t\t\t IA_CSS_PIPE_MODE_PREVIEW, false);\n\t\tvideo_pipe = find_pipe(pipes, num_pipes,\n\t\t\t\t       IA_CSS_PIPE_MODE_VIDEO, false);\n\n\t\tif (curr_stream->cont_capt) {\n\t\t\tcapture_pipe = find_pipe(pipes, num_pipes,\n\t\t\t\t\t\t IA_CSS_PIPE_MODE_CAPTURE,\n\t\t\t\t\t\t false);\n\t\t\tif (!capture_pipe) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto ERR;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (preview_pipe && video_pipe) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ERR;\n\t\t}\n\n\t\tif (preview_pipe && !preview_pipe->pipe_settings.preview.copy_pipe) {\n\t\t\terr = create_pipe(IA_CSS_PIPE_MODE_CAPTURE, &copy_pipe, true);\n\t\t\tif (err)\n\t\t\t\tgoto ERR;\n\t\t\tia_css_pipe_config_defaults(&copy_pipe->config);\n\t\t\tpreview_pipe->pipe_settings.preview.copy_pipe = copy_pipe;\n\t\t\tcopy_pipe->stream = curr_stream;\n\t\t}\n\t\tif (preview_pipe && curr_stream->cont_capt)\n\t\t\tpreview_pipe->pipe_settings.preview.capture_pipe = capture_pipe;\n\n\t\tif (video_pipe && !video_pipe->pipe_settings.video.copy_pipe) {\n\t\t\terr = create_pipe(IA_CSS_PIPE_MODE_CAPTURE, &copy_pipe, true);\n\t\t\tif (err)\n\t\t\t\tgoto ERR;\n\t\t\tia_css_pipe_config_defaults(&copy_pipe->config);\n\t\t\tvideo_pipe->pipe_settings.video.copy_pipe = copy_pipe;\n\t\t\tcopy_pipe->stream = curr_stream;\n\t\t}\n\t\tif (video_pipe && curr_stream->cont_capt)\n\t\t\tvideo_pipe->pipe_settings.video.capture_pipe = capture_pipe;\n\t}\n\tfor (i = 0; i < num_pipes; i++) {\n\t\tcurr_pipe = pipes[i];\n\t\t \n\t\tcurr_pipe->stream = curr_stream;\n\n\t\t \n\n\t\teffective_res = curr_pipe->config.input_effective_res;\n\t\terr = ia_css_util_check_res(\n\t\t\teffective_res.width,\n\t\t\teffective_res.height);\n\t\tif (err)\n\t\t\tgoto ERR;\n\n\t\t \n\t\tif (sensor_binning_changed)\n\t\t\tsh_css_pipe_free_shading_table(curr_pipe);\n\t}\n\n\t \n\tfor (i = 0; i < num_pipes; i++) {\n\t\tstruct ia_css_pipe_info *pipe_info = NULL;\n\n\t\tcurr_pipe = pipes[i];\n\n\t\terr = sh_css_pipe_load_binaries(curr_pipe);\n\t\tif (err)\n\t\t\tgoto ERR;\n\n\t\t \n\t\tpipe_info = &curr_pipe->info;\n\t\tfor (j = 0; j < IA_CSS_PIPE_MAX_OUTPUT_STAGE; j++) {\n\t\t\terr = sh_css_pipe_get_output_frame_info(curr_pipe,\n\t\t\t\t\t\t\t\t&pipe_info->output_info[j], j);\n\t\t\tif (err)\n\t\t\t\tgoto ERR;\n\t\t}\n\n\t\tif (!spcopyonly) {\n\t\t\tif (!IS_ISP2401)\n\t\t\t\terr = sh_css_pipe_get_shading_info(curr_pipe,\n\t\t\t\t\t\t\t\t   &pipe_info->shading_info,\n\t\t\t\t\t\t\t\t   NULL);\n\t\t\telse\n\t\t\t\terr = sh_css_pipe_get_shading_info(curr_pipe,\n\t\t\t\t\t\t\t\t   &pipe_info->shading_info,\n\t\t\t\t\t\t\t\t   &curr_pipe->config);\n\n\t\t\tif (err)\n\t\t\t\tgoto ERR;\n\t\t\terr = sh_css_pipe_get_grid_info(curr_pipe,\n\t\t\t\t\t\t\t&pipe_info->grid_info);\n\t\t\tif (err)\n\t\t\t\tgoto ERR;\n\t\t\tfor (j = 0; j < IA_CSS_PIPE_MAX_OUTPUT_STAGE; j++) {\n\t\t\t\tsh_css_pipe_get_viewfinder_frame_info(curr_pipe,\n\t\t\t\t\t\t\t\t      &pipe_info->vf_output_info[j],\n\t\t\t\t\t\t\t\t      j);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto ERR;\n\t\t\t}\n\t\t}\n\n\t\tmy_css.active_pipes[ia_css_pipe_get_pipe_num(curr_pipe)] = curr_pipe;\n\t}\n\n\tcurr_stream->started = false;\n\n\t \n\terr = map_sp_threads(curr_stream, true);\n\tif (err) {\n\t\tIA_CSS_LOG(\"map_sp_threads: return_err=%d\", err);\n\t\tgoto ERR;\n\t}\n\n\tfor (i = 0; i < num_pipes; i++) {\n\t\tcurr_pipe = pipes[i];\n\t\tia_css_pipe_map_queue(curr_pipe, true);\n\t}\n\n\t \n\terr = create_host_pipeline_structure(curr_stream);\n\tif (err) {\n\t\tIA_CSS_LOG(\"create_host_pipeline_structure: return_err=%d\", err);\n\t\tgoto ERR;\n\t}\n\n\t \n\t*stream = curr_stream;\n\nERR:\n\tif (!err) {\n\t\t \n\t\tif (my_css_save.mode == sh_css_mode_working) {\n\t\t\tfor (i = 0; i < MAX_ACTIVE_STREAMS; i++) {\n\t\t\t\tif (!my_css_save.stream_seeds[i].stream) {\n\t\t\t\t\tIA_CSS_LOG(\"entered stream into loc=%d\", i);\n\t\t\t\t\tmy_css_save.stream_seeds[i].orig_stream = stream;\n\t\t\t\t\tmy_css_save.stream_seeds[i].stream = curr_stream;\n\t\t\t\t\tmy_css_save.stream_seeds[i].num_pipes = num_pipes;\n\t\t\t\t\tmy_css_save.stream_seeds[i].stream_config = *stream_config;\n\t\t\t\t\tfor (j = 0; j < num_pipes; j++) {\n\t\t\t\t\t\tmy_css_save.stream_seeds[i].pipe_config[j] = pipes[j]->config;\n\t\t\t\t\t\tmy_css_save.stream_seeds[i].pipes[j] = pipes[j];\n\t\t\t\t\t\tmy_css_save.stream_seeds[i].orig_pipes[j] = &pipes[j];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tia_css_stream_destroy(curr_stream);\n\t\t}\n\t} else {\n\t\tia_css_stream_destroy(curr_stream);\n\t}\n\tIA_CSS_LEAVE(\"return_err=%d mode=%d\", err, my_css_save.mode);\n\treturn err;\n}\n\nint\nia_css_stream_destroy(struct ia_css_stream *stream)\n{\n\tint i;\n\tint err = 0;\n\n\tIA_CSS_ENTER_PRIVATE(\"stream = %p\", stream);\n\tif (!stream) {\n\t\terr = -EINVAL;\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\treturn err;\n\t}\n\n\tia_css_stream_isp_parameters_uninit(stream);\n\n\tif ((stream->last_pipe) &&\n\t    ia_css_pipeline_is_mapped(stream->last_pipe->pipe_num)) {\n#if defined(ISP2401)\n\t\tfor (i = 0; i < stream->num_pipes; i++) {\n\t\t\tstruct ia_css_pipe *entry = stream->pipes[i];\n\t\t\tunsigned int sp_thread_id;\n\t\t\tstruct sh_css_sp_pipeline_terminal *sp_pipeline_input_terminal;\n\n\t\t\tassert(entry);\n\t\t\tif (entry) {\n\t\t\t\t \n\t\t\t\tif (!ia_css_pipeline_get_sp_thread_id(\n\t\t\t\t\tia_css_pipe_get_pipe_num(entry), &sp_thread_id))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t \n\t\t\t\tsp_pipeline_input_terminal =\n\t\t\t\t&sh_css_sp_group.pipe_io[sp_thread_id].input;\n\n\t\t\t\tfor (i = 0; i < IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH; i++) {\n\t\t\t\t\tia_css_isys_stream_h isys_stream =\n\t\t\t\t\t&sp_pipeline_input_terminal->context.virtual_input_system_stream[i];\n\t\t\t\t\tif (stream->config.isys_config[i].valid && isys_stream->valid)\n\t\t\t\t\t\tia_css_isys_stream_destroy(isys_stream);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {\n\t\t\tfor (i = 0; i < stream->num_pipes; i++) {\n\t\t\t\tstruct ia_css_pipe *entry = stream->pipes[i];\n\t\t\t\t \n\t\t\t\tif (entry)\n\t\t\t\t\tfree_mipi_frames(entry);\n\t\t\t}\n\t\t}\n\t\tstream_unregister_with_csi_rx(stream);\n#endif\n\n\t\tfor (i = 0; i < stream->num_pipes; i++) {\n\t\t\tstruct ia_css_pipe *curr_pipe = stream->pipes[i];\n\n\t\t\tassert(curr_pipe);\n\t\t\tia_css_pipe_map_queue(curr_pipe, false);\n\t\t}\n\n\t\terr = map_sp_threads(stream, false);\n\t\tif (err) {\n\t\t\tIA_CSS_LEAVE_ERR_PRIVATE(err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < stream->num_pipes; i++) {\n\t\tstruct ia_css_pipe *entry = stream->pipes[i];\n\n\t\tassert(entry);\n\t\tif (entry) {\n\t\t\t \n\t\t\tentry->stream = NULL;\n\t\t\t \n\t\t\tif (entry->mode == IA_CSS_PIPE_ID_PREVIEW &&\n\t\t\t    entry->pipe_settings.preview.copy_pipe) {\n\t\t\t\tIA_CSS_LOG(\"clearing stream on internal preview copy pipe\");\n\t\t\t\tentry->pipe_settings.preview.copy_pipe->stream = NULL;\n\t\t\t}\n\t\t\tif (entry->mode == IA_CSS_PIPE_ID_VIDEO &&\n\t\t\t    entry->pipe_settings.video.copy_pipe) {\n\t\t\t\tIA_CSS_LOG(\"clearing stream on internal video copy pipe\");\n\t\t\t\tentry->pipe_settings.video.copy_pipe->stream = NULL;\n\t\t\t}\n\t\t\terr = sh_css_pipe_unload_binaries(entry);\n\t\t}\n\t}\n\t \n\tkfree(stream->pipes);\n\tstream->pipes = NULL;\n\tstream->num_pipes = 0;\n\n\t \n\tif (my_css_save.mode == sh_css_mode_working) {\n\t\tfor (i = 0; i < MAX_ACTIVE_STREAMS; i++) {\n\t\t\tif (my_css_save.stream_seeds[i].stream == stream) {\n\t\t\t\tIA_CSS_LOG(\"took out stream %d\", i);\n\t\t\t\tmy_css_save.stream_seeds[i].stream = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tkfree(stream);\n\tIA_CSS_LEAVE_ERR(err);\n\n\treturn err;\n}\n\nint\nia_css_stream_get_info(const struct ia_css_stream *stream,\n\t\t       struct ia_css_stream_info *stream_info)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_stream_get_info: enter/exit\\n\");\n\tassert(stream);\n\tassert(stream_info);\n\n\t*stream_info = stream->info;\n\treturn 0;\n}\n\nint\nia_css_stream_start(struct ia_css_stream *stream)\n{\n\tint err = 0;\n\n\tIA_CSS_ENTER(\"stream = %p\", stream);\n\tif ((!stream) || (!stream->last_pipe)) {\n\t\tIA_CSS_LEAVE_ERR(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\tIA_CSS_LOG(\"starting %d\", stream->last_pipe->mode);\n\n\tsh_css_sp_set_disable_continuous_viewfinder(stream->disable_cont_vf);\n\n\t \n\terr = create_host_pipeline(stream);\n\tif (err) {\n\t\tIA_CSS_LEAVE_ERR(err);\n\t\treturn err;\n\t}\n\n#if defined(ISP2401)\n\tif ((stream->config.mode == IA_CSS_INPUT_MODE_SENSOR) ||\n\t    (stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR))\n\t\tstream_register_with_csi_rx(stream);\n#endif\n\n#if !defined(ISP2401)\n\t \n\tif (stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {\n\t\tunsigned int idx;\n\t\tunsigned int port = (unsigned int)(stream->config.source.port.port);\n\n\t\tfor (idx = 0; idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT; idx++) {\n\t\t\tsh_css_sp_group.config.mipi_sizes_for_check[port][idx] =\n\t\t\tsh_css_get_mipi_sizes_for_check(port, idx);\n\t\t}\n\t}\n#endif\n\n\tif (stream->config.mode != IA_CSS_INPUT_MODE_MEMORY) {\n\t\terr = sh_css_config_input_network(stream);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = sh_css_pipe_start(stream);\n\tIA_CSS_LEAVE_ERR(err);\n\treturn err;\n}\n\nint\nia_css_stream_stop(struct ia_css_stream *stream)\n{\n\tint err = 0;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_stream_stop() enter/exit\\n\");\n\tassert(stream);\n\tassert(stream->last_pipe);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_stream_stop: stopping %d\\n\",\n\t\t\t    stream->last_pipe->mode);\n\n#if !defined(ISP2401)\n\t \n\tif (stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {\n\t\tunsigned int idx;\n\t\tunsigned int port = (unsigned int)(stream->config.source.port.port);\n\n\t\tfor (idx = 0; idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT; idx++)\n\t\t\tsh_css_sp_group.config.mipi_sizes_for_check[port][idx] = 0;\n\t}\n#endif\n\n\terr = ia_css_pipeline_request_stop(&stream->last_pipe->pipeline);\n\tif (err)\n\t\treturn err;\n\n\t \n\t \n\n\treturn err;\n}\n\nbool\nia_css_stream_has_stopped(struct ia_css_stream *stream)\n{\n\tbool stopped;\n\n\tassert(stream);\n\n\tstopped = ia_css_pipeline_has_stopped(&stream->last_pipe->pipeline);\n\n\treturn stopped;\n}\n\n \n \nint\nia_css_stream_unload(struct ia_css_stream *stream)\n{\n\tint i;\n\n\tassert(stream);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\t\"ia_css_stream_unload() enter,\\n\");\n\t \n\tassert(stream);\n\tfor (i = 0; i < MAX_ACTIVE_STREAMS; i++)\n\t\tif (my_css_save.stream_seeds[i].stream == stream) {\n\t\t\tint j;\n\n\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t    \"ia_css_stream_unload(): unloading %d (%p)\\n\", i,\n\t\t\t\t\t    my_css_save.stream_seeds[i].stream);\n\t\t\tia_css_stream_destroy(stream);\n\t\t\tfor (j = 0; j < my_css_save.stream_seeds[i].num_pipes; j++)\n\t\t\t\tia_css_pipe_destroy(my_css_save.stream_seeds[i].pipes[j]);\n\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t    \"ia_css_stream_unload(): after unloading %d (%p)\\n\", i,\n\t\t\t\t\t    my_css_save.stream_seeds[i].stream);\n\t\t\tbreak;\n\t\t}\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\t\"ia_css_stream_unload() exit,\\n\");\n\treturn 0;\n}\n\nint\nia_css_temp_pipe_to_pipe_id(const struct ia_css_pipe *pipe,\n\t\t\t    enum ia_css_pipe_id *pipe_id)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ia_css_temp_pipe_to_pipe_id() enter/exit\\n\");\n\tif (pipe)\n\t\t*pipe_id = pipe->mode;\n\telse\n\t\t*pipe_id = IA_CSS_PIPE_ID_COPY;\n\n\treturn 0;\n}\n\nenum atomisp_input_format\nia_css_stream_get_format(const struct ia_css_stream *stream)\n{\n\treturn stream->config.input_config.format;\n}\n\nbool\nia_css_stream_get_two_pixels_per_clock(const struct ia_css_stream *stream)\n{\n\treturn (stream->config.pixels_per_clock == 2);\n}\n\nstruct ia_css_binary *\nia_css_stream_get_shading_correction_binary(const struct ia_css_stream\n\t*stream)\n{\n\tstruct ia_css_pipe *pipe;\n\n\tassert(stream);\n\n\tpipe = stream->pipes[0];\n\n\tif (stream->num_pipes == 2) {\n\t\tassert(stream->pipes[1]);\n\t\tif (stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_VIDEO ||\n\t\t    stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_PREVIEW)\n\t\t\tpipe = stream->pipes[1];\n\t}\n\n\treturn ia_css_pipe_get_shading_correction_binary(pipe);\n}\n\nstruct ia_css_binary *\nia_css_stream_get_dvs_binary(const struct ia_css_stream *stream)\n{\n\tint i;\n\tstruct ia_css_pipe *video_pipe = NULL;\n\n\t \n\tfor (i = 0; i < stream->num_pipes; i++) {\n\t\tstruct ia_css_pipe *pipe = stream->pipes[i];\n\n\t\tif (pipe->config.mode == IA_CSS_PIPE_MODE_VIDEO) {\n\t\t\tvideo_pipe = pipe;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (video_pipe)\n\t\treturn &video_pipe->pipe_settings.video.video_binary;\n\treturn NULL;\n}\n\nstruct ia_css_binary *\nia_css_stream_get_3a_binary(const struct ia_css_stream *stream)\n{\n\tstruct ia_css_pipe *pipe;\n\tstruct ia_css_binary *s3a_binary = NULL;\n\n\tassert(stream);\n\n\tpipe = stream->pipes[0];\n\n\tif (stream->num_pipes == 2) {\n\t\tassert(stream->pipes[1]);\n\t\tif (stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_VIDEO ||\n\t\t    stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_PREVIEW)\n\t\t\tpipe = stream->pipes[1];\n\t}\n\n\ts3a_binary = ia_css_pipe_get_s3a_binary(pipe);\n\n\treturn s3a_binary;\n}\n\nint\nia_css_stream_set_output_padded_width(struct ia_css_stream *stream,\n\t\t\t\t      unsigned int output_padded_width)\n{\n\tstruct ia_css_pipe *pipe;\n\n\tassert(stream);\n\n\tpipe = stream->last_pipe;\n\n\tassert(pipe);\n\n\t \n\tpipe->config.output_info[IA_CSS_PIPE_OUTPUT_STAGE_0].padded_width = output_padded_width;\n\tpipe->output_info[IA_CSS_PIPE_OUTPUT_STAGE_0].padded_width = output_padded_width;\n\n\treturn 0;\n}\n\nstatic struct ia_css_binary *\nia_css_pipe_get_shading_correction_binary(const struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_binary *binary = NULL;\n\n\tassert(pipe);\n\n\tswitch (pipe->config.mode) {\n\tcase IA_CSS_PIPE_MODE_PREVIEW:\n\t\tbinary = (struct ia_css_binary *)&pipe->pipe_settings.preview.preview_binary;\n\t\tbreak;\n\tcase IA_CSS_PIPE_MODE_VIDEO:\n\t\tbinary = (struct ia_css_binary *)&pipe->pipe_settings.video.video_binary;\n\t\tbreak;\n\tcase IA_CSS_PIPE_MODE_CAPTURE:\n\t\tif (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_PRIMARY) {\n\t\t\tunsigned int i;\n\n\t\t\tfor (i = 0; i < pipe->pipe_settings.capture.num_primary_stage; i++) {\n\t\t\t\tif (pipe->pipe_settings.capture.primary_binary[i].info->sp.enable.sc) {\n\t\t\t\t\tbinary = (struct ia_css_binary *)&pipe->pipe_settings.capture.primary_binary[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pipe->config.default_capture_config.mode ==\n\t\t\t    IA_CSS_CAPTURE_MODE_BAYER)\n\t\t\tbinary = (struct ia_css_binary *)&pipe->pipe_settings.capture.pre_isp_binary;\n\t\telse if (pipe->config.default_capture_config.mode ==\n\t\t\t    IA_CSS_CAPTURE_MODE_ADVANCED ||\n\t\t\t    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT) {\n\t\t\tif (pipe->config.isp_pipe_version == IA_CSS_PIPE_VERSION_1)\n\t\t\t\tbinary = (struct ia_css_binary *)&pipe->pipe_settings.capture.pre_isp_binary;\n\t\t\telse if (pipe->config.isp_pipe_version == IA_CSS_PIPE_VERSION_2_2)\n\t\t\t\tbinary = (struct ia_css_binary *)&pipe->pipe_settings.capture.post_isp_binary;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (binary && binary->info->sp.enable.sc)\n\t\treturn binary;\n\n\treturn NULL;\n}\n\nstatic struct ia_css_binary *\nia_css_pipe_get_s3a_binary(const struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_binary *binary = NULL;\n\n\tassert(pipe);\n\n\tswitch (pipe->config.mode) {\n\tcase IA_CSS_PIPE_MODE_PREVIEW:\n\t\tbinary = (struct ia_css_binary *)&pipe->pipe_settings.preview.preview_binary;\n\t\tbreak;\n\tcase IA_CSS_PIPE_MODE_VIDEO:\n\t\tbinary = (struct ia_css_binary *)&pipe->pipe_settings.video.video_binary;\n\t\tbreak;\n\tcase IA_CSS_PIPE_MODE_CAPTURE:\n\t\tif (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_PRIMARY) {\n\t\t\tunsigned int i;\n\n\t\t\tfor (i = 0; i < pipe->pipe_settings.capture.num_primary_stage; i++) {\n\t\t\t\tif (pipe->pipe_settings.capture.primary_binary[i].info->sp.enable.s3a) {\n\t\t\t\t\tbinary = (struct ia_css_binary *)&pipe->pipe_settings.capture.primary_binary[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pipe->config.default_capture_config.mode ==\n\t\t\t    IA_CSS_CAPTURE_MODE_BAYER) {\n\t\t\tbinary = (struct ia_css_binary *)&pipe->pipe_settings.capture.pre_isp_binary;\n\t\t} else if (pipe->config.default_capture_config.mode ==\n\t\t\t    IA_CSS_CAPTURE_MODE_ADVANCED ||\n\t\t\t    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT) {\n\t\t\tif (pipe->config.isp_pipe_version == IA_CSS_PIPE_VERSION_1)\n\t\t\t\tbinary = (struct ia_css_binary *)&pipe->pipe_settings.capture.pre_isp_binary;\n\t\t\telse if (pipe->config.isp_pipe_version == IA_CSS_PIPE_VERSION_2_2)\n\t\t\t\tbinary = (struct ia_css_binary *)&pipe->pipe_settings.capture.post_isp_binary;\n\t\t\telse\n\t\t\t\tassert(0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (binary && !binary->info->sp.enable.s3a)\n\t\tbinary = NULL;\n\n\treturn binary;\n}\n\nstatic struct ia_css_binary *\nia_css_pipe_get_sdis_binary(const struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_binary *binary = NULL;\n\n\tassert(pipe);\n\n\tswitch (pipe->config.mode) {\n\tcase IA_CSS_PIPE_MODE_VIDEO:\n\t\tbinary = (struct ia_css_binary *)&pipe->pipe_settings.video.video_binary;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (binary && !binary->info->sp.enable.dis)\n\t\tbinary = NULL;\n\n\treturn binary;\n}\n\nstruct ia_css_pipeline *\nia_css_pipe_get_pipeline(const struct ia_css_pipe *pipe)\n{\n\tassert(pipe);\n\n\treturn (struct ia_css_pipeline *)&pipe->pipeline;\n}\n\nunsigned int\nia_css_pipe_get_pipe_num(const struct ia_css_pipe *pipe)\n{\n\tassert(pipe);\n\n\t \n\tassert(pipe->pipe_num < IA_CSS_PIPELINE_NUM_MAX);\n\n\tif (pipe->pipe_num >= IA_CSS_PIPELINE_NUM_MAX)\n\t\treturn (IA_CSS_PIPELINE_NUM_MAX - 1);\n\n\treturn pipe->pipe_num;\n}\n\nunsigned int\nia_css_pipe_get_isp_pipe_version(const struct ia_css_pipe *pipe)\n{\n\tassert(pipe);\n\n\treturn (unsigned int)pipe->config.isp_pipe_version;\n}\n\n#define SP_START_TIMEOUT_US 30000000\n\nint\nia_css_start_sp(void)\n{\n\tunsigned long timeout;\n\tint err = 0;\n\n\tIA_CSS_ENTER(\"\");\n\tsh_css_sp_start_isp();\n\n\t \n\ttimeout = SP_START_TIMEOUT_US;\n\twhile ((ia_css_spctrl_get_state(SP0_ID) != IA_CSS_SP_SW_INITIALIZED) && timeout) {\n\t\ttimeout--;\n\t\tudelay(1);\n\t}\n\tif (timeout == 0) {\n\t\tIA_CSS_ERROR(\"timeout during SP initialization\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t \n\n\tsh_css_init_host_sp_control_vars();\n\n\t \n\t \n\n\tsh_css_setup_queues();\n\tia_css_bufq_dump_queue_info();\n\n\tIA_CSS_LEAVE_ERR(err);\n\treturn err;\n}\n\n \n#define SP_SHUTDOWN_TIMEOUT_US 200000\n\nint\nia_css_stop_sp(void)\n{\n\tunsigned long timeout;\n\tint err = 0;\n\n\tIA_CSS_ENTER(\"void\");\n\n\tif (!sh_css_sp_is_running()) {\n\t\terr = -EINVAL;\n\t\tIA_CSS_LEAVE(\"SP already stopped : return_err=%d\", err);\n\n\t\t \n\t\treturn err;\n\t}\n\n\t \n\tif (!sh_css_write_host2sp_command(host2sp_cmd_terminate)) {\n\t\tIA_CSS_ERROR(\"Call to 'sh-css_write_host2sp_command()' failed\");\n\t\tia_css_debug_dump_sp_sw_debug_info();\n\t\tia_css_debug_dump_debug_info(NULL);\n\t}\n\n\tsh_css_sp_set_sp_running(false);\n\n\ttimeout = SP_SHUTDOWN_TIMEOUT_US;\n\twhile (!ia_css_spctrl_is_idle(SP0_ID) && timeout) {\n\t\ttimeout--;\n\t\tudelay(1);\n\t}\n\tif (ia_css_spctrl_get_state(SP0_ID) != IA_CSS_SP_SW_TERMINATED)\n\t\tIA_CSS_WARNING(\"SP has not terminated (SW)\");\n\n\tif (timeout == 0) {\n\t\tIA_CSS_WARNING(\"SP is not idle\");\n\t\tia_css_debug_dump_sp_sw_debug_info();\n\t}\n\ttimeout = SP_SHUTDOWN_TIMEOUT_US;\n\twhile (!isp_ctrl_getbit(ISP0_ID, ISP_SC_REG, ISP_IDLE_BIT) && timeout) {\n\t\ttimeout--;\n\t\tudelay(1);\n\t}\n\tif (timeout == 0) {\n\t\tIA_CSS_WARNING(\"ISP is not idle\");\n\t\tia_css_debug_dump_sp_sw_debug_info();\n\t}\n\n\tsh_css_hmm_buffer_record_uninit();\n\n\t \n\tsh_css_param_clear_param_sets();\n\n\tIA_CSS_LEAVE_ERR(err);\n\treturn err;\n}\n\nint\nia_css_update_continuous_frames(struct ia_css_stream *stream)\n{\n\tstruct ia_css_pipe *pipe;\n\tunsigned int i;\n\n\tia_css_debug_dtrace(\n\t    IA_CSS_DEBUG_TRACE,\n\t    \"sh_css_update_continuous_frames() enter:\\n\");\n\n\tif (!stream) {\n\t\tia_css_debug_dtrace(\n\t\t    IA_CSS_DEBUG_TRACE,\n\t\t    \"sh_css_update_continuous_frames() leave: invalid stream, return_void\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpipe = stream->continuous_pipe;\n\n\tfor (i = stream->config.init_num_cont_raw_buf;\n\t\ti < stream->config.target_num_cont_raw_buf; i++)\n\t\tsh_css_update_host2sp_offline_frame(i,\n\t\t\t\t\t\t    pipe->continuous_frames[i], pipe->cont_md_buffers[i]);\n\n\tsh_css_update_host2sp_cont_num_raw_frames\n\t(stream->config.target_num_cont_raw_buf, true);\n\tia_css_debug_dtrace(\n\t    IA_CSS_DEBUG_TRACE,\n\t    \"sh_css_update_continuous_frames() leave: return_void\\n\");\n\n\treturn 0;\n}\n\nvoid ia_css_pipe_map_queue(struct ia_css_pipe *pipe, bool map)\n{\n\tunsigned int thread_id;\n\tunsigned int pipe_num;\n\tbool need_input_queue;\n\n\tIA_CSS_ENTER(\"\");\n\tassert(pipe);\n\n\tpipe_num = pipe->pipe_num;\n\n\tia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\n\n\tif (IS_ISP2401)\n\t\tneed_input_queue = true;\n\telse\n\t\tneed_input_queue = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;\n\n\t \n\t \n\tif (pipe->mode == IA_CSS_PIPE_ID_PREVIEW) {\n\t\tif (need_input_queue)\n\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);\n\t\tif (pipe->pipe_settings.preview.preview_binary.info &&\n\t\t    pipe->pipe_settings.preview.preview_binary.info->sp.enable.s3a)\n\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);\n\t} else if (pipe->mode == IA_CSS_PIPE_ID_CAPTURE) {\n\t\tunsigned int i;\n\n\t\tif (need_input_queue)\n\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);\n\t\tif (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_PRIMARY) {\n\t\t\tfor (i = 0; i < pipe->pipe_settings.capture.num_primary_stage; i++) {\n\t\t\t\tif (pipe->pipe_settings.capture.primary_binary[i].info &&\n\t\t\t\t    pipe->pipe_settings.capture.primary_binary[i].info->sp.enable.s3a) {\n\t\t\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pipe->config.default_capture_config.mode ==\n\t\t\t    IA_CSS_CAPTURE_MODE_ADVANCED ||\n\t\t\t    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT ||\n\t\t\t    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER) {\n\t\t\tif (pipe->pipe_settings.capture.pre_isp_binary.info &&\n\t\t\t    pipe->pipe_settings.capture.pre_isp_binary.info->sp.enable.s3a)\n\t\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);\n\t\t}\n\t} else if (pipe->mode == IA_CSS_PIPE_ID_VIDEO) {\n\t\tif (need_input_queue)\n\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);\n\t\tif (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0])\n\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);\n\t\tif (pipe->pipe_settings.video.video_binary.info &&\n\t\t    pipe->pipe_settings.video.video_binary.info->sp.enable.s3a)\n\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);\n\t\tif (pipe->pipe_settings.video.video_binary.info &&\n\t\t    (pipe->pipe_settings.video.video_binary.info->sp.enable.dis\n\t\t    ))\n\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_DIS_STATISTICS, map);\n\t} else if (pipe->mode == IA_CSS_PIPE_ID_COPY) {\n\t\tif (need_input_queue)\n\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);\n\t\tif (!pipe->stream->config.continuous)\n\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);\n\t} else if (pipe->mode == IA_CSS_PIPE_ID_YUVPP) {\n\t\tunsigned int idx;\n\n\t\tfor (idx = 0; idx < IA_CSS_PIPE_MAX_OUTPUT_STAGE; idx++) {\n\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME + idx, map);\n\t\t\tif (pipe->enable_viewfinder[idx])\n\t\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME + idx, map);\n\t\t}\n\t\tif (need_input_queue)\n\t\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET, map);\n\t\tia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);\n\t}\n\tIA_CSS_LEAVE(\"\");\n}\n\n\nint\nia_css_unlock_raw_frame(struct ia_css_stream *stream, uint32_t exp_id)\n{\n\tint ret;\n\n\tIA_CSS_ENTER(\"\");\n\n\t \n\tif (!stream || !stream->config.continuous) {\n\t\tIA_CSS_ERROR(\"invalid stream pointer\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (exp_id > IA_CSS_ISYS_MAX_EXPOSURE_ID ||\n\t    exp_id < IA_CSS_ISYS_MIN_EXPOSURE_ID) {\n\t\tIA_CSS_ERROR(\"invalid exposure ID: %d\\n\", exp_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = ia_css_bufq_enqueue_psys_event(\n\t    IA_CSS_PSYS_SW_EVENT_UNLOCK_RAW_BUFFER, exp_id, 0, 0);\n\n\tIA_CSS_LEAVE_ERR(ret);\n\treturn ret;\n}\n\nstatic void\nsh_css_hmm_buffer_record_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_HMM_BUFFER_NUM; i++)\n\t\tsh_css_hmm_buffer_record_reset(&hmm_buffer_record[i]);\n}\n\nstatic void\nsh_css_hmm_buffer_record_uninit(void)\n{\n\tint i;\n\tstruct sh_css_hmm_buffer_record *buffer_record = NULL;\n\n\tbuffer_record = &hmm_buffer_record[0];\n\tfor (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {\n\t\tif (buffer_record->in_use) {\n\t\t\tif (buffer_record->h_vbuf)\n\t\t\t\tia_css_rmgr_rel_vbuf(hmm_buffer_pool, &buffer_record->h_vbuf);\n\t\t\tsh_css_hmm_buffer_record_reset(buffer_record);\n\t\t}\n\t\tbuffer_record++;\n\t}\n}\n\nstatic void\nsh_css_hmm_buffer_record_reset(struct sh_css_hmm_buffer_record *buffer_record)\n{\n\tassert(buffer_record);\n\tbuffer_record->in_use = false;\n\tbuffer_record->type = IA_CSS_BUFFER_TYPE_INVALID;\n\tbuffer_record->h_vbuf = NULL;\n\tbuffer_record->kernel_ptr = 0;\n}\n\nstatic struct sh_css_hmm_buffer_record\n*sh_css_hmm_buffer_record_acquire(struct ia_css_rmgr_vbuf_handle *h_vbuf,\n\t\t\t\t    enum ia_css_buffer_type type,\n\t\t\t\t    hrt_address kernel_ptr)\n{\n\tint i;\n\tstruct sh_css_hmm_buffer_record *buffer_record = NULL;\n\tstruct sh_css_hmm_buffer_record *out_buffer_record = NULL;\n\n\tassert(h_vbuf);\n\tassert((type > IA_CSS_BUFFER_TYPE_INVALID) &&\n\t       (type < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE));\n\tassert(kernel_ptr != 0);\n\n\tbuffer_record = &hmm_buffer_record[0];\n\tfor (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {\n\t\tif (!buffer_record->in_use) {\n\t\t\tbuffer_record->in_use = true;\n\t\t\tbuffer_record->type = type;\n\t\t\tbuffer_record->h_vbuf = h_vbuf;\n\t\t\tbuffer_record->kernel_ptr = kernel_ptr;\n\t\t\tout_buffer_record = buffer_record;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer_record++;\n\t}\n\n\treturn out_buffer_record;\n}\n\nstatic struct sh_css_hmm_buffer_record\n*sh_css_hmm_buffer_record_validate(ia_css_ptr ddr_buffer_addr,\n\t\t\t\t    enum ia_css_buffer_type type)\n{\n\tint i;\n\tstruct sh_css_hmm_buffer_record *buffer_record = NULL;\n\tbool found_record = false;\n\n\tbuffer_record = &hmm_buffer_record[0];\n\tfor (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {\n\t\tif ((buffer_record->in_use) &&\n\t\t    (buffer_record->type == type) &&\n\t\t    (buffer_record->h_vbuf) &&\n\t\t    (buffer_record->h_vbuf->vptr == ddr_buffer_addr)) {\n\t\t\tfound_record = true;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer_record++;\n\t}\n\n\tif (found_record)\n\t\treturn buffer_record;\n\telse\n\t\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}