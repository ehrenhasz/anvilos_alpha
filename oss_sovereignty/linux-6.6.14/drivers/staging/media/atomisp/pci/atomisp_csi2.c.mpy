{
  "module_name": "atomisp_csi2.c",
  "hash_id": "5f07b7148129ca8cd5d85f1fa352fcc8f6172a350f6dadecac3282ff9784cdff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/atomisp_csi2.c",
  "human_readable_source": "\n \n\n#include <media/v4l2-event.h>\n#include <media/v4l2-mediabus.h>\n#include \"atomisp_cmd.h\"\n#include \"atomisp_internal.h\"\n#include \"atomisp-regs.h\"\n\nstatic struct\nv4l2_mbus_framefmt *__csi2_get_format(struct atomisp_mipi_csi2_device *csi2,\n\t\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t\t      enum v4l2_subdev_format_whence which,\n\t\t\t\t      unsigned int pad)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&csi2->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\telse\n\t\treturn &csi2->formats[pad];\n}\n\n \nstatic int csi2_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_mbus_code_enum *code)\n{\n\tconst struct atomisp_in_fmt_conv *ic = atomisp_in_fmt_conv;\n\tunsigned int i = 0;\n\n\twhile (ic->code) {\n\t\tif (i == code->index) {\n\t\t\tcode->code = ic->code;\n\t\t\treturn 0;\n\t\t}\n\t\ti++, ic++;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int csi2_get_format(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __csi2_get_format(csi2, sd_state, fmt->which, fmt->pad);\n\n\tfmt->format = *format;\n\n\treturn 0;\n}\n\nint atomisp_csi2_set_ffmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  unsigned int which, uint16_t pad,\n\t\t\t  struct v4l2_mbus_framefmt *ffmt)\n{\n\tstruct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *actual_ffmt = __csi2_get_format(csi2,\n\t\t\t\t\t\t\t\t   sd_state,\n\t\t\t\t\t\t\t\t   which, pad);\n\n\tif (pad == CSI2_PAD_SINK) {\n\t\tconst struct atomisp_in_fmt_conv *ic;\n\t\tstruct v4l2_mbus_framefmt tmp_ffmt;\n\n\t\tic = atomisp_find_in_fmt_conv(ffmt->code);\n\t\tif (ic)\n\t\t\tactual_ffmt->code = ic->code;\n\t\telse\n\t\t\tactual_ffmt->code = atomisp_in_fmt_conv[0].code;\n\n\t\tactual_ffmt->width = clamp_t(u32, ffmt->width,\n\t\t\t\t\t     ATOM_ISP_MIN_WIDTH,\n\t\t\t\t\t     ATOM_ISP_MAX_WIDTH);\n\t\tactual_ffmt->height = clamp_t(u32, ffmt->height,\n\t\t\t\t\t      ATOM_ISP_MIN_HEIGHT,\n\t\t\t\t\t      ATOM_ISP_MAX_HEIGHT);\n\n\t\ttmp_ffmt = *ffmt = *actual_ffmt;\n\n\t\treturn atomisp_csi2_set_ffmt(sd, sd_state, which,\n\t\t\t\t\t     CSI2_PAD_SOURCE,\n\t\t\t\t\t     &tmp_ffmt);\n\t}\n\n\t \n\t*actual_ffmt = *ffmt = *__csi2_get_format(csi2, sd_state, which,\n\t\t\t\t\t\t  CSI2_PAD_SINK);\n\n\treturn 0;\n}\n\n \nstatic int csi2_set_format(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\treturn atomisp_csi2_set_ffmt(sd, sd_state, fmt->which, fmt->pad,\n\t\t\t\t     &fmt->format);\n}\n\n \nstatic int csi2_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_core_ops csi2_core_ops = {\n};\n\n \nstatic const struct v4l2_subdev_video_ops csi2_video_ops = {\n\t.s_stream = csi2_set_stream,\n};\n\n \nstatic const struct v4l2_subdev_pad_ops csi2_pad_ops = {\n\t.enum_mbus_code = csi2_enum_mbus_code,\n\t.get_fmt = csi2_get_format,\n\t.set_fmt = csi2_set_format,\n\t.link_validate = v4l2_subdev_link_validate_default,\n};\n\n \nstatic const struct v4l2_subdev_ops csi2_ops = {\n\t.core = &csi2_core_ops,\n\t.video = &csi2_video_ops,\n\t.pad = &csi2_pad_ops,\n};\n\n \nstatic const struct media_entity_operations csi2_media_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n \nstatic int mipi_csi2_init_entities(struct atomisp_mipi_csi2_device *csi2,\n\t\t\t\t   int port)\n{\n\tstruct v4l2_subdev *sd = &csi2->subdev;\n\tstruct media_pad *pads = csi2->pads;\n\tstruct media_entity *me = &sd->entity;\n\tint ret;\n\n\tv4l2_subdev_init(sd, &csi2_ops);\n\tsnprintf(sd->name, sizeof(sd->name), \"ATOM ISP CSI2-port%d\", port);\n\n\tv4l2_set_subdevdata(sd, csi2);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tpads[CSI2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\tpads[CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\n\tme->ops = &csi2_media_ops;\n\tme->function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tret = media_entity_pads_init(me, CSI2_PADS_NUM, pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcsi2->formats[CSI2_PAD_SINK].code = atomisp_in_fmt_conv[0].code;\n\tcsi2->formats[CSI2_PAD_SOURCE].code = atomisp_in_fmt_conv[0].code;\n\n\treturn 0;\n}\n\nvoid\natomisp_mipi_csi2_unregister_entities(struct atomisp_mipi_csi2_device *csi2)\n{\n\tmedia_entity_cleanup(&csi2->subdev.entity);\n\tv4l2_device_unregister_subdev(&csi2->subdev);\n}\n\nint atomisp_mipi_csi2_register_entities(struct atomisp_mipi_csi2_device *csi2,\n\t\t\t\t\tstruct v4l2_device *vdev)\n{\n\tint ret;\n\n\t \n\tret = v4l2_device_register_subdev(vdev, &csi2->subdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tatomisp_mipi_csi2_unregister_entities(csi2);\n\treturn ret;\n}\n\nstatic const int LIMIT_SHIFT = 6;\t \n\nstatic int\natomisp_csi2_configure_calc(const short int coeffs[2], int mipi_freq, int def)\n{\n\t \n\tstatic const int accinv = 16;\t\t \n\tint r;\n\n\tif (mipi_freq >> LIMIT_SHIFT <= 0)\n\t\treturn def;\n\n\tr = accinv * coeffs[1] * (500000000 >> LIMIT_SHIFT);\n\tr /= mipi_freq >> LIMIT_SHIFT;\n\tr += accinv * coeffs[0];\n\n\treturn r;\n}\n\nstatic void atomisp_csi2_configure_isp2401(struct atomisp_sub_device *asd)\n{\n\t \n\tstatic const short int coeff_clk_termen[] = { 0, 0 };\n\tstatic const short int coeff_clk_settle[] = { 95, -8 };\n\tstatic const short int coeff_dat_termen[] = { 0, 0 };\n\tstatic const short int coeff_dat_settle[] = { 85, -2 };\n\tstatic const int TERMEN_DEFAULT\t\t  = 0 * 0;\n\tstatic const int SETTLE_DEFAULT\t\t  = 0x480;\n\n\tstatic const hrt_address csi2_port_base[] = {\n\t\t[ATOMISP_CAMERA_PORT_PRIMARY]     = CSI2_PORT_A_BASE,\n\t\t[ATOMISP_CAMERA_PORT_SECONDARY]   = CSI2_PORT_B_BASE,\n\t\t[ATOMISP_CAMERA_PORT_TERTIARY]    = CSI2_PORT_C_BASE,\n\t};\n\t \n\tstatic const unsigned char csi2_port_lanes[] = {\n\t\t[ATOMISP_CAMERA_PORT_PRIMARY]     = 4,\n\t\t[ATOMISP_CAMERA_PORT_SECONDARY]   = 2,\n\t\t[ATOMISP_CAMERA_PORT_TERTIARY]    = 2,\n\t};\n\tstatic const hrt_address csi2_lane_base[] = {\n\t\tCSI2_LANE_CL_BASE,\n\t\tCSI2_LANE_D0_BASE,\n\t\tCSI2_LANE_D1_BASE,\n\t\tCSI2_LANE_D2_BASE,\n\t\tCSI2_LANE_D3_BASE,\n\t};\n\n\tint clk_termen;\n\tint clk_settle;\n\tint dat_termen;\n\tint dat_settle;\n\n\tstruct v4l2_control ctrl;\n\tstruct atomisp_device *isp = asd->isp;\n\tint mipi_freq = 0;\n\tenum atomisp_camera_port port;\n\tint n;\n\n\tport = isp->inputs[asd->input_curr].port;\n\n\tctrl.id = V4L2_CID_LINK_FREQ;\n\tif (v4l2_g_ctrl\n\t    (isp->inputs[asd->input_curr].camera->ctrl_handler, &ctrl) == 0)\n\t\tmipi_freq = ctrl.value;\n\n\tclk_termen = atomisp_csi2_configure_calc(coeff_clk_termen, mipi_freq,\n\t\t\t\t\t\t TERMEN_DEFAULT);\n\tclk_settle = atomisp_csi2_configure_calc(coeff_clk_settle, mipi_freq,\n\t\t\t\t\t\t SETTLE_DEFAULT);\n\tdat_termen = atomisp_csi2_configure_calc(coeff_dat_termen, mipi_freq,\n\t\t\t\t\t\t TERMEN_DEFAULT);\n\tdat_settle = atomisp_csi2_configure_calc(coeff_dat_settle, mipi_freq,\n\t\t\t\t\t\t SETTLE_DEFAULT);\n\n\tfor (n = 0; n < csi2_port_lanes[port] + 1; n++) {\n\t\thrt_address base = csi2_port_base[port] + csi2_lane_base[n];\n\n\t\tatomisp_css2_hw_store_32(base + CSI2_REG_RX_CSI_DLY_CNT_TERMEN,\n\t\t\t\t\t n == 0 ? clk_termen : dat_termen);\n\t\tatomisp_css2_hw_store_32(base + CSI2_REG_RX_CSI_DLY_CNT_SETTLE,\n\t\t\t\t\t n == 0 ? clk_settle : dat_settle);\n\t}\n}\n\nvoid atomisp_csi2_configure(struct atomisp_sub_device *asd)\n{\n\tif (IS_HWREVISION(asd->isp, ATOMISP_HW_REVISION_ISP2401))\n\t\tatomisp_csi2_configure_isp2401(asd);\n}\n\n \nvoid atomisp_mipi_csi2_cleanup(struct atomisp_device *isp)\n{\n}\n\nint atomisp_mipi_csi2_init(struct atomisp_device *isp)\n{\n\tstruct atomisp_mipi_csi2_device *csi2_port;\n\tunsigned int i;\n\tint ret;\n\n\tret = atomisp_csi2_bridge_init(isp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {\n\t\tcsi2_port = &isp->csi2_port[i];\n\t\tcsi2_port->isp = isp;\n\t\tret = mipi_csi2_init_entities(csi2_port, i);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tatomisp_mipi_csi2_cleanup(isp);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}