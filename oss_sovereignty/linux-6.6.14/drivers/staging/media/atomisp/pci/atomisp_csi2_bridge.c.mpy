{
  "module_name": "atomisp_csi2_bridge.c",
  "hash_id": "7a787add640e8b773b4d860e9aca27a26ff8abec04b8f04f4401f6e5b36382b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/atomisp_csi2_bridge.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/dmi.h>\n#include <linux/property.h>\n\n#include <media/ipu-bridge.h>\n#include <media/v4l2-fwnode.h>\n\n#include \"atomisp_cmd.h\"\n#include \"atomisp_csi2.h\"\n#include \"atomisp_internal.h\"\n\n#define PMC_CLK_RATE_19_2MHZ\t\t\t19200000\n\n \nstatic const guid_t intel_sensor_gpio_info_guid =\n\tGUID_INIT(0x79234640, 0x9e10, 0x4fea,\n\t\t  0xa5, 0xc1, 0xb5, 0xaa, 0x8b, 0x19, 0x75, 0x6f);\n\n#define INTEL_GPIO_DSM_TYPE_SHIFT\t\t\t0\n#define INTEL_GPIO_DSM_TYPE_MASK\t\t\tGENMASK(7, 0)\n#define INTEL_GPIO_DSM_PIN_SHIFT\t\t\t8\n#define INTEL_GPIO_DSM_PIN_MASK\t\t\t\tGENMASK(15, 8)\n#define INTEL_GPIO_DSM_SENSOR_ON_VAL_SHIFT\t\t24\n#define INTEL_GPIO_DSM_SENSOR_ON_VAL_MASK\t\tGENMASK(31, 24)\n\n#define INTEL_GPIO_DSM_TYPE(x) \\\n\t(((x) & INTEL_GPIO_DSM_TYPE_MASK) >> INTEL_GPIO_DSM_TYPE_SHIFT)\n#define INTEL_GPIO_DSM_PIN(x) \\\n\t(((x) & INTEL_GPIO_DSM_PIN_MASK) >> INTEL_GPIO_DSM_PIN_SHIFT)\n#define INTEL_GPIO_DSM_SENSOR_ON_VAL(x) \\\n\t(((x) & INTEL_GPIO_DSM_SENSOR_ON_VAL_MASK) >> INTEL_GPIO_DSM_SENSOR_ON_VAL_SHIFT)\n\n \nstatic const guid_t intel_sensor_module_guid =\n\tGUID_INIT(0x822ace8f, 0x2814, 0x4174,\n\t\t  0xa5, 0x6b, 0x5f, 0x02, 0x9f, 0xe0, 0x79, 0xee);\n\n \nstatic const guid_t atomisp_dsm_guid =\n\tGUID_INIT(0xdc2f6c4f, 0x045b, 0x4f1d,\n\t\t  0x97, 0xb9, 0x88, 0x2a, 0x68, 0x60, 0xa4, 0xbe);\n\n \nstatic const guid_t vcm_dsm_guid =\n\tGUID_INIT(0x75c9a639, 0x5c8a, 0x4a00,\n\t\t  0x9f, 0x48, 0xa9, 0xc3, 0xb5, 0xda, 0x78, 0x9f);\n\nstruct atomisp_sensor_config {\n\tint lanes;\n\tbool vcm;\n};\n\n#define ATOMISP_SENSOR_CONFIG(_HID, _LANES, _VCM)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.id = _HID,\t\t\t\t\t\t\t\\\n\t.driver_data = (long)&((const struct atomisp_sensor_config) {\t\\\n\t\t.lanes = _LANES,\t\t\t\t\t\\\n\t\t.vcm = _VCM,\t\t\t\t\t\t\\\n\t})\t\t\t\t\t\t\t\t\\\n}\n\n \nstruct gmin_cfg_var {\n\tconst char *acpi_dev_name;\n\tconst char *key;\n\tconst char *val;\n};\n\nstatic struct gmin_cfg_var lenovo_ideapad_miix_310_vars[] = {\n\t \n\t{ \"OVTI2680:01\", \"CsiPort\", \"0\" },\n\t{}\n};\n\nstatic const struct dmi_system_id gmin_cfg_dmi_overrides[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"MIIX 310-10\"),\n\t\t},\n\t\t.driver_data = lenovo_ideapad_miix_310_vars,\n\t},\n\t{}\n};\n\nstatic char *gmin_cfg_get_dsm(struct acpi_device *adev, const char *key)\n{\n\tunion acpi_object *obj, *key_el, *val_el;\n\tchar *val = NULL;\n\tint i;\n\n\tobj = acpi_evaluate_dsm_typed(adev->handle, &atomisp_dsm_guid, 0, 0,\n\t\t\t\t      NULL, ACPI_TYPE_PACKAGE);\n\tif (!obj)\n\t\treturn NULL;\n\n\tfor (i = 0; i < obj->package.count - 1; i += 2) {\n\t\tkey_el = &obj->package.elements[i + 0];\n\t\tval_el = &obj->package.elements[i + 1];\n\n\t\tif (key_el->type != ACPI_TYPE_STRING || val_el->type != ACPI_TYPE_STRING)\n\t\t\tbreak;\n\n\t\tif (!strcmp(key_el->string.pointer, key)) {\n\t\t\tval = kstrdup(val_el->string.pointer, GFP_KERNEL);\n\t\t\tif (!val)\n\t\t\t\tbreak;\n\n\t\t\tacpi_handle_info(adev->handle, \"%s: Using DSM entry %s=%s\\n\",\n\t\t\t\t\t dev_name(&adev->dev), key, val);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tACPI_FREE(obj);\n\treturn val;\n}\n\nstatic char *gmin_cfg_get_dmi_override(struct acpi_device *adev, const char *key)\n{\n\tconst struct dmi_system_id *id;\n\tstruct gmin_cfg_var *gv;\n\n\tid = dmi_first_match(gmin_cfg_dmi_overrides);\n\tif (!id)\n\t\treturn NULL;\n\n\tfor (gv = id->driver_data; gv->acpi_dev_name; gv++) {\n\t\tif (strcmp(gv->acpi_dev_name, acpi_dev_name(adev)))\n\t\t\tcontinue;\n\n\t\tif (strcmp(key, gv->key))\n\t\t\tcontinue;\n\n\t\tacpi_handle_info(adev->handle, \"%s: Using DMI entry %s=%s\\n\",\n\t\t\t\t dev_name(&adev->dev), key, gv->val);\n\t\treturn kstrdup(gv->val, GFP_KERNEL);\n\t}\n\n\treturn NULL;\n}\n\nstatic char *gmin_cfg_get(struct acpi_device *adev, const char *key)\n{\n\tchar *val;\n\n\tval = gmin_cfg_get_dmi_override(adev, key);\n\tif (val)\n\t\treturn val;\n\n\treturn gmin_cfg_get_dsm(adev, key);\n}\n\nstatic int gmin_cfg_get_int(struct acpi_device *adev, const char *key, int default_val)\n{\n\tchar *str_val;\n\tlong int_val;\n\tint ret;\n\n\tstr_val = gmin_cfg_get(adev, key);\n\tif (!str_val)\n\t\tgoto out_use_default;\n\n\tret = kstrtoul(str_val, 0, &int_val);\n\tkfree(str_val);\n\tif (ret)\n\t\tgoto out_use_default;\n\n\treturn int_val;\n\nout_use_default:\n\tacpi_handle_info(adev->handle, \"%s: Using default %s=%d\\n\",\n\t\t\t dev_name(&adev->dev), key, default_val);\n\treturn default_val;\n}\n\nstatic int atomisp_csi2_get_pmc_clk_nr_from_acpi_pr0(struct acpi_device *adev)\n{\n\t \n\tchar name[ACPI_PATH_SEGMENT_LENGTH];\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_buffer b_name = { sizeof(name), name };\n\tunion acpi_object *package, *element;\n\tint i, ret = -ENOENT;\n\tacpi_handle rhandle;\n\tacpi_status status;\n\tu8 clock_num;\n\n\tstatus = acpi_evaluate_object_typed(adev->handle, \"_PR0\", NULL, &buffer, ACPI_TYPE_PACKAGE);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENOENT;\n\n\tpackage = buffer.pointer;\n\tfor (i = 0; i < package->package.count; i++) {\n\t\telement = &package->package.elements[i];\n\n\t\tif (element->type != ACPI_TYPE_LOCAL_REFERENCE)\n\t\t\tcontinue;\n\n\t\trhandle = element->reference.handle;\n\t\tif (!rhandle)\n\t\t\tcontinue;\n\n\t\tacpi_get_name(rhandle, ACPI_SINGLE_NAME, &b_name);\n\n\t\tif (str_has_prefix(name, \"CLK\") && !kstrtou8(&name[3], 10, &clock_num) &&\n\t\t    clock_num <= 4) {\n\t\t\tret = clock_num;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tACPI_FREE(buffer.pointer);\n\n\tif (ret < 0)\n\t\tacpi_handle_warn(adev->handle, \"%s: Could not find PMC clk in _PR0\\n\",\n\t\t\t\t dev_name(&adev->dev));\n\n\treturn ret;\n}\n\nstatic int atomisp_csi2_set_pmc_clk_freq(struct acpi_device *adev, int clock_num)\n{\n\tstruct clk *clk;\n\tchar name[14];\n\tint ret;\n\n\tif (clock_num < 0)\n\t\treturn 0;\n\n\tsnprintf(name, sizeof(name), \"pmc_plt_clk_%d\", clock_num);\n\n\tclk = clk_get(NULL, name);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tacpi_handle_err(adev->handle, \"%s: Error getting clk %s: %d\\n\",\n\t\t\t\tdev_name(&adev->dev), name, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = clk_prepare_enable(clk);\n\tif (!ret)\n\t\tclk_disable_unprepare(clk);\n\tif (!ret)\n\t\tret = clk_set_rate(clk, PMC_CLK_RATE_19_2MHZ);\n\tif (ret)\n\t\tacpi_handle_err(adev->handle, \"%s: Error setting clk-rate for %s: %d\\n\",\n\t\t\t\tdev_name(&adev->dev), name, ret);\n\n\tclk_put(clk);\n\treturn ret;\n}\n\nstatic int atomisp_csi2_get_port(struct acpi_device *adev, int clock_num)\n{\n\tint port;\n\n\t \n\tif (IS_ISP2401)\n\t\tport = clock_num == 4 ? 1 : 0;\n\telse\n\t\tport = clock_num == 0 ? 1 : 0;\n\n\t \n\treturn gmin_cfg_get_int(adev, \"CsiPort\", port);\n}\n\n \nstatic int atomisp_csi2_handle_acpi_gpio_res(struct acpi_resource *ares, void *_data)\n{\n\tstruct atomisp_csi2_acpi_gpio_parsing_data *data = _data;\n\tstruct acpi_resource_gpio *agpio;\n\tconst char *name;\n\tbool active_low;\n\tunsigned int i;\n\tu32 settings = 0;\n\tu16 pin;\n\n\tif (!acpi_gpio_get_io_resource(ares, &agpio))\n\t\treturn 1;  \n\n\tdata->res_count++;\n\n\tpin = agpio->pin_table[0];\n\tfor (i = 0; i < data->settings_count; i++) {\n\t\tif (INTEL_GPIO_DSM_PIN(data->settings[i]) == pin) {\n\t\t\tsettings = data->settings[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == data->settings_count) {\n\t\tacpi_handle_warn(data->adev->handle,\n\t\t\t\t \"%s: Could not find DSM GPIO settings for pin %u\\n\",\n\t\t\t\t dev_name(&data->adev->dev), pin);\n\t\treturn 1;\n\t}\n\n\tswitch (INTEL_GPIO_DSM_TYPE(settings)) {\n\tcase 0:\n\t\tname = \"reset-gpios\";\n\t\tbreak;\n\tcase 1:\n\t\tname = \"powerdown-gpios\";\n\t\tbreak;\n\tdefault:\n\t\tacpi_handle_warn(data->adev->handle, \"%s: Unknown GPIO type 0x%02lx for pin %u\\n\",\n\t\t\t\t dev_name(&data->adev->dev),\n\t\t\t\t INTEL_GPIO_DSM_TYPE(settings), pin);\n\t\treturn 1;\n\t}\n\n\t \n\tactive_low = INTEL_GPIO_DSM_SENSOR_ON_VAL(settings);\n\n\ti = data->map_count;\n\tif (i == CSI2_MAX_ACPI_GPIOS)\n\t\treturn 1;\n\n\t \n\tdata->map->params[i].crs_entry_index = data->res_count - 1;\n\tdata->map->params[i].active_low = active_low;\n\tdata->map->mapping[i].name = name;\n\tdata->map->mapping[i].data = &data->map->params[i];\n\tdata->map->mapping[i].size = 1;\n\tdata->map_count++;\n\n\tacpi_handle_info(data->adev->handle, \"%s: %s crs %d %s pin %u active-%s\\n\",\n\t\t\t dev_name(&data->adev->dev), name,\n\t\t\t data->res_count - 1, agpio->resource_source.string_ptr,\n\t\t\t pin, active_low ? \"low\" : \"high\");\n\n\treturn 1;\n}\n\n \nstatic int atomisp_csi2_add_gpio_mappings(struct acpi_device *adev)\n{\n\tstruct atomisp_csi2_acpi_gpio_parsing_data data = { };\n\tLIST_HEAD(resource_list);\n\tunion acpi_object *obj;\n\tunsigned int i, j;\n\tint ret;\n\n\tobj = acpi_evaluate_dsm_typed(adev->handle, &intel_sensor_module_guid,\n\t\t\t\t      0x00, 1, NULL, ACPI_TYPE_STRING);\n\tif (obj) {\n\t\tacpi_handle_info(adev->handle, \"%s: Sensor module id: '%s'\\n\",\n\t\t\t\t dev_name(&adev->dev), obj->string.pointer);\n\t\tACPI_FREE(obj);\n\t}\n\n\t \n\tobj = acpi_evaluate_dsm_typed(adev->handle,\n\t\t\t\t      &intel_sensor_gpio_info_guid, 0x00, 1,\n\t\t\t\t      NULL, ACPI_TYPE_INTEGER);\n\tif (!obj) {\n\t\tacpi_handle_err(adev->handle, \"%s: No _DSM entry for GPIO pin count\\n\",\n\t\t\t\tdev_name(&adev->dev));\n\t\treturn -EIO;\n\t}\n\n\tdata.settings_count = obj->integer.value;\n\tACPI_FREE(obj);\n\n\tif (data.settings_count > CSI2_MAX_ACPI_GPIOS) {\n\t\tacpi_handle_err(adev->handle, \"%s: Too many GPIOs %u > %u\\n\",\n\t\t\t\tdev_name(&adev->dev), data.settings_count,\n\t\t\t\tCSI2_MAX_ACPI_GPIOS);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tfor (i = 0; i < data.settings_count; i++) {\n\t\t \n\t\tobj = acpi_evaluate_dsm_typed(adev->handle,\n\t\t\t\t\t      &intel_sensor_gpio_info_guid,\n\t\t\t\t\t      0x00, i + 2,\n\t\t\t\t\t      NULL, ACPI_TYPE_INTEGER);\n\t\tif (!obj) {\n\t\t\tacpi_handle_err(adev->handle, \"%s: No _DSM entry for pin %u\\n\",\n\t\t\t\t\tdev_name(&adev->dev), i);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tdata.settings[i] = obj->integer.value;\n\t\tACPI_FREE(obj);\n\t}\n\n\t \n\tfor (i = 0; i < data.settings_count; i++) {\n\t\tfor (j = i + 1; j < data.settings_count; j++) {\n\t\t\tif (INTEL_GPIO_DSM_PIN(data.settings[i]) !=\n\t\t\t    INTEL_GPIO_DSM_PIN(data.settings[j]))\n\t\t\t\tcontinue;\n\n\t\t\tacpi_handle_err(adev->handle, \"%s: Duplicate pin number %lu\\n\",\n\t\t\t\t\tdev_name(&adev->dev),\n\t\t\t\t\tINTEL_GPIO_DSM_PIN(data.settings[i]));\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tdata.map = kzalloc(sizeof(*data.map), GFP_KERNEL);\n\tif (!data.map)\n\t\treturn -ENOMEM;\n\n\t \n\tdata.adev = adev;\n\tret = acpi_dev_get_resources(adev, &resource_list,\n\t\t\t\t     atomisp_csi2_handle_acpi_gpio_res, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tacpi_dev_free_resource_list(&resource_list);\n\n\tif (data.map_count != data.settings_count ||\n\t    data.res_count != data.settings_count)\n\t\tacpi_handle_warn(adev->handle, \"%s: ACPI GPIO resources vs DSM GPIO-info count mismatch (dsm: %d res: %d map %d\\n\",\n\t\t\t\t dev_name(&adev->dev), data.settings_count,\n\t\t\t\t data.res_count, data.map_count);\n\n\tret = acpi_dev_add_driver_gpios(adev, data.map->mapping);\n\tif (ret)\n\t\tacpi_handle_err(adev->handle, \"%s: Error adding driver GPIOs: %d\\n\",\n\t\t\t\tdev_name(&adev->dev), ret);\n\n\treturn ret;\n}\n\nstatic char *atomisp_csi2_get_vcm_type(struct acpi_device *adev)\n{\n\tunion acpi_object *obj;\n\tchar *vcm_type;\n\n\tobj = acpi_evaluate_dsm_typed(adev->handle, &vcm_dsm_guid, 0, 0,\n\t\t\t\t      NULL, ACPI_TYPE_STRING);\n\tif (!obj)\n\t\treturn NULL;\n\n\tvcm_type = kstrdup(obj->string.pointer, GFP_KERNEL);\n\tACPI_FREE(obj);\n\n\tif (!vcm_type)\n\t\treturn NULL;\n\n\tstring_lower(vcm_type, vcm_type);\n\treturn vcm_type;\n}\n\nstatic const struct acpi_device_id atomisp_sensor_configs[] = {\n\tATOMISP_SENSOR_CONFIG(\"INT33BE\", 2, true),\t \n\t{}\n};\n\nstatic int atomisp_csi2_parse_sensor_fwnode(struct acpi_device *adev,\n\t\t\t\t\t    struct ipu_sensor *sensor)\n{\n\tconst struct acpi_device_id *id;\n\tint ret, clock_num;\n\tbool vcm = false;\n\tint lanes = 1;\n\n\tid = acpi_match_acpi_device(atomisp_sensor_configs, adev);\n\tif (id) {\n\t\tstruct atomisp_sensor_config *cfg =\n\t\t\t(struct atomisp_sensor_config *)id->driver_data;\n\n\t\tlanes = cfg->lanes;\n\t\tvcm = cfg->vcm;\n\t}\n\n\t \n\tclock_num = atomisp_csi2_get_pmc_clk_nr_from_acpi_pr0(adev);\n\n\tret = atomisp_csi2_set_pmc_clk_freq(adev, clock_num);\n\tif (ret)\n\t\treturn ret;\n\n\tsensor->link = atomisp_csi2_get_port(adev, clock_num);\n\tif (sensor->link >= ATOMISP_CAMERA_NR_PORTS) {\n\t\tacpi_handle_err(adev->handle, \"%s: Invalid port: %u\\n\",\n\t\t\t\tdev_name(&adev->dev), sensor->link);\n\t\treturn -EINVAL;\n\t}\n\n\tsensor->lanes = gmin_cfg_get_int(adev, \"CsiLanes\", lanes);\n\tif (sensor->lanes > IPU_MAX_LANES) {\n\t\tacpi_handle_err(adev->handle, \"%s: Invalid lane-count: %d\\n\",\n\t\t\t\tdev_name(&adev->dev), sensor->lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tret = atomisp_csi2_add_gpio_mappings(adev);\n\tif (ret)\n\t\treturn ret;\n\n\tsensor->mclkspeed = PMC_CLK_RATE_19_2MHZ;\n\tsensor->rotation = 0;\n\tsensor->orientation = (sensor->link == 1) ?\n\t\tV4L2_FWNODE_ORIENTATION_BACK : V4L2_FWNODE_ORIENTATION_FRONT;\n\n\tif (vcm)\n\t\tsensor->vcm_type = atomisp_csi2_get_vcm_type(adev);\n\n\treturn 0;\n}\n\nint atomisp_csi2_bridge_init(struct atomisp_device *isp)\n{\n\tstruct device *dev = isp->dev;\n\tstruct fwnode_handle *fwnode;\n\n\t \n\tfwnode = dev_fwnode(dev);\n\tif (fwnode && fwnode->secondary)\n\t\treturn 0;\n\n\treturn ipu_bridge_init(dev, atomisp_csi2_parse_sensor_fwnode);\n}\n\n \n\nstruct sensor_async_subdev {\n\tstruct v4l2_async_connection asd;\n\tint port;\n};\n\n#define to_sensor_asd(a)\tcontainer_of(a, struct sensor_async_subdev, asd)\n#define notifier_to_atomisp(n)\tcontainer_of(n, struct atomisp_device, notifier)\n\n \nstatic int atomisp_notifier_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t  struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_async_connection *asd)\n{\n\tstruct atomisp_device *isp = notifier_to_atomisp(notifier);\n\tstruct sensor_async_subdev *s_asd = to_sensor_asd(asd);\n\tint ret;\n\n\tif (s_asd->port >= ATOMISP_CAMERA_NR_PORTS) {\n\t\tdev_err(isp->dev, \"port %d not supported\\n\", s_asd->port);\n\t\treturn -EINVAL;\n\t}\n\n\tif (isp->sensor_subdevs[s_asd->port]) {\n\t\tdev_err(isp->dev, \"port %d already has a sensor attached\\n\", s_asd->port);\n\t\treturn -EBUSY;\n\t}\n\n\tret = ipu_bridge_instantiate_vcm(sd->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tisp->sensor_subdevs[s_asd->port] = sd;\n\treturn 0;\n}\n\n \nstatic void atomisp_notifier_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t\t    struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_async_connection *asd)\n{\n\tstruct atomisp_device *isp = notifier_to_atomisp(notifier);\n\tstruct sensor_async_subdev *s_asd = to_sensor_asd(asd);\n\n\tisp->sensor_subdevs[s_asd->port] = NULL;\n}\n\n \nstatic int atomisp_notifier_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct atomisp_device *isp = notifier_to_atomisp(notifier);\n\n\treturn atomisp_register_device_nodes(isp);\n}\n\nstatic const struct v4l2_async_notifier_operations atomisp_async_ops = {\n\t.bound = atomisp_notifier_bound,\n\t.unbind = atomisp_notifier_unbind,\n\t.complete = atomisp_notifier_complete,\n};\n\nint atomisp_csi2_bridge_parse_firmware(struct atomisp_device *isp)\n{\n\tint i, mipi_port, ret;\n\n\tv4l2_async_nf_init(&isp->notifier, &isp->v4l2_dev);\n\tisp->notifier.ops = &atomisp_async_ops;\n\n\tfor (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {\n\t\tstruct v4l2_fwnode_endpoint vep = {\n\t\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t\t};\n\t\tstruct sensor_async_subdev *s_asd;\n\t\tstruct fwnode_handle *ep;\n\n\t\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(isp->dev), i, 0,\n\t\t\t\t\t\t     FWNODE_GRAPH_ENDPOINT_NEXT);\n\t\tif (!ep)\n\t\t\tcontinue;\n\n\t\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\t\tif (ret)\n\t\t\tgoto err_parse;\n\n\t\tif (vep.base.port >= ATOMISP_CAMERA_NR_PORTS) {\n\t\t\tdev_err(isp->dev, \"port %d not supported\\n\", vep.base.port);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_parse;\n\t\t}\n\n\t\tmipi_port = atomisp_port_to_mipi_port(isp, vep.base.port);\n\t\tisp->sensor_lanes[mipi_port] = vep.bus.mipi_csi2.num_data_lanes;\n\n\t\ts_asd = v4l2_async_nf_add_fwnode_remote(&isp->notifier, ep,\n\t\t\t\t\t\t\tstruct sensor_async_subdev);\n\t\tif (IS_ERR(s_asd)) {\n\t\t\tret = PTR_ERR(s_asd);\n\t\t\tgoto err_parse;\n\t\t}\n\n\t\ts_asd->port = vep.base.port;\n\n\t\tfwnode_handle_put(ep);\n\t\tcontinue;\n\nerr_parse:\n\t\tfwnode_handle_put(ep);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}