{
  "module_name": "atomisp_gmin_platform.c",
  "hash_id": "6f6e00d54b2390e53134aadcd9bbc4a7baf726d355b93db052124a7d2d62a0cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/atomisp_gmin_platform.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/dmi.h>\n#include <linux/efi.h>\n#include <linux/pci.h>\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <media/v4l2-subdev.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio.h>\n#include <linux/platform_device.h>\n#include \"../../include/linux/atomisp_platform.h\"\n#include \"../../include/linux/atomisp_gmin_platform.h\"\n\n#define MAX_SUBDEVS 8\n\nenum clock_rate {\n\tVLV2_CLK_XTAL_25_0MHz = 0,\n\tVLV2_CLK_PLL_19P2MHZ = 1\n};\n\n#define CLK_RATE_19_2MHZ\t19200000\n#define CLK_RATE_25_0MHZ\t25000000\n\n \n#define MAX_CLK_COUNT                   5\n\n \n#define ALDO1_SEL_REG\t0x28\n#define ALDO1_CTRL3_REG\t0x13\n#define ALDO1_2P8V\t0x16\n#define ALDO1_CTRL3_SHIFT 0x05\n\n#define ELDO_CTRL_REG   0x12\n\n#define ELDO1_SEL_REG\t0x19\n#define ELDO1_1P6V\t0x12\n#define ELDO1_CTRL_SHIFT 0x00\n\n#define ELDO2_SEL_REG\t0x1a\n#define ELDO2_1P8V\t0x16\n#define ELDO2_CTRL_SHIFT 0x01\n\n \n#define LDO9_REG\t0x49\n#define LDO10_REG\t0x4a\n#define LDO11_REG\t0x4b\n\n#define LDO_2P8V_ON\t0x2f  \n#define LDO_2P8V_OFF\t0x2e  \n\n#define LDO_1P8V_ON\t0x59  \n#define LDO_1P8V_OFF\t0x58  \n\n \n#define CRYSTAL_BYT_1P8V_REG\t0x5d\n#define CRYSTAL_BYT_2P8V_REG\t0x66\n\n#define CRYSTAL_CHT_1P8V_REG\t0x57\n#define CRYSTAL_CHT_2P8V_REG\t0x5d\n\n#define CRYSTAL_ON\t\t0x63\n#define CRYSTAL_OFF\t\t0x62\n\nstruct gmin_subdev {\n\tstruct v4l2_subdev *subdev;\n\tenum clock_rate clock_src;\n\tstruct clk *pmc_clk;\n\tstruct gpio_desc *gpio0;\n\tstruct gpio_desc *gpio1;\n\tstruct regulator *v1p8_reg;\n\tstruct regulator *v2p8_reg;\n\tstruct regulator *v1p2_reg;\n\tstruct regulator *v2p8_vcm_reg;\n\tenum atomisp_camera_port csi_port;\n\tunsigned int csi_lanes;\n\tenum atomisp_input_format csi_fmt;\n\tenum atomisp_bayer_order csi_bayer;\n\n\tbool clock_on;\n\tbool v1p8_on;\n\tbool v2p8_on;\n\tbool v1p2_on;\n\tbool v2p8_vcm_on;\n\n\tint v1p8_gpio;\n\tint v2p8_gpio;\n\n\tu8 pwm_i2c_addr;\n\n\t \n\tint eldo1_sel_reg, eldo1_1p6v, eldo1_ctrl_shift;\n\tint eldo2_sel_reg, eldo2_1p8v, eldo2_ctrl_shift;\n};\n\nstatic struct gmin_subdev gmin_subdevs[MAX_SUBDEVS];\n\n \n#define PMIC_ACPI_AXP\t\t\"INT33F4\"\t \n#define PMIC_ACPI_TI\t\t\"INT33F5\"\t \n#define PMIC_ACPI_CRYSTALCOVE\t\"INT33FD\"\t \n\n#define PMIC_PLATFORM_TI\t\"intel_soc_pmic_chtdc_ti\"\n\nstatic enum {\n\tPMIC_UNSET = 0,\n\tPMIC_REGULATOR,\n\tPMIC_AXP,\n\tPMIC_TI,\n\tPMIC_CRYSTALCOVE\n} pmic_id;\n\nstatic const char *pmic_name[] = {\n\t[PMIC_UNSET]\t\t= \"ACPI device PM\",\n\t[PMIC_REGULATOR]\t= \"regulator driver\",\n\t[PMIC_AXP]\t\t= \"XPower AXP288 PMIC\",\n\t[PMIC_TI]\t\t= \"Dollar Cove TI PMIC\",\n\t[PMIC_CRYSTALCOVE]\t= \"Crystal Cove PMIC\",\n};\n\nstatic DEFINE_MUTEX(gmin_regulator_mutex);\nstatic int gmin_v1p8_enable_count;\nstatic int gmin_v2p8_enable_count;\n\n \nstatic struct intel_v4l2_subdev_table pdata_subdevs[MAX_SUBDEVS + 1];\n\nstatic const struct atomisp_platform_data pdata = {\n\t.subdevs = pdata_subdevs,\n};\n\nstatic LIST_HEAD(vcm_devices);\nstatic DEFINE_MUTEX(vcm_lock);\n\nstatic struct gmin_subdev *find_gmin_subdev(struct v4l2_subdev *subdev);\n\nconst struct atomisp_platform_data *atomisp_get_platform_data(void)\n{\n\treturn &pdata;\n}\nEXPORT_SYMBOL_GPL(atomisp_get_platform_data);\n\nint atomisp_register_i2c_module(struct v4l2_subdev *subdev,\n\t\t\t\tstruct camera_sensor_platform_data *plat_data,\n\t\t\t\tenum intel_v4l2_subdev_type type)\n{\n\tint i;\n\tstruct gmin_subdev *gs;\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tstruct acpi_device *adev = ACPI_COMPANION(&client->dev);\n\n\tdev_info(&client->dev, \"register atomisp i2c module type %d\\n\", type);\n\n\t \n\n\t \n\tacpi_device_set_power(adev, ACPI_STATE_D3_COLD);\n\tadev->power.flags.power_resources = 0;\n\n\tfor (i = 0; i < MAX_SUBDEVS; i++)\n\t\tif (!pdata.subdevs[i].type)\n\t\t\tbreak;\n\n\tif (pdata.subdevs[i].type)\n\t\treturn -ENOMEM;\n\n\t \n\tgs = find_gmin_subdev(subdev);\n\tif (!gs)\n\t\treturn -ENODEV;\n\n\tpdata.subdevs[i].type = type;\n\tpdata.subdevs[i].port = gs->csi_port;\n\tpdata.subdevs[i].lanes = gs->csi_lanes;\n\tpdata.subdevs[i].subdev = subdev;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(atomisp_register_i2c_module);\n\nint atomisp_gmin_remove_subdev(struct v4l2_subdev *sd)\n{\n\tint i, j;\n\n\tif (!sd)\n\t\treturn 0;\n\n\tfor (i = 0; i < MAX_SUBDEVS; i++) {\n\t\tif (pdata.subdevs[i].subdev == sd) {\n\t\t\tfor (j = i + 1; j <= MAX_SUBDEVS; j++)\n\t\t\t\tpdata.subdevs[j - 1] = pdata.subdevs[j];\n\t\t}\n\t\tif (gmin_subdevs[i].subdev == sd) {\n\t\t\tif (gmin_subdevs[i].gpio0)\n\t\t\t\tgpiod_put(gmin_subdevs[i].gpio0);\n\t\t\tgmin_subdevs[i].gpio0 = NULL;\n\t\t\tif (gmin_subdevs[i].gpio1)\n\t\t\t\tgpiod_put(gmin_subdevs[i].gpio1);\n\t\t\tgmin_subdevs[i].gpio1 = NULL;\n\t\t\tif (pmic_id == PMIC_REGULATOR) {\n\t\t\t\tregulator_put(gmin_subdevs[i].v1p8_reg);\n\t\t\t\tregulator_put(gmin_subdevs[i].v2p8_reg);\n\t\t\t\tregulator_put(gmin_subdevs[i].v1p2_reg);\n\t\t\t\tregulator_put(gmin_subdevs[i].v2p8_vcm_reg);\n\t\t\t}\n\t\t\tgmin_subdevs[i].subdev = NULL;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(atomisp_gmin_remove_subdev);\n\nstruct gmin_cfg_var {\n\tconst char *name, *val;\n};\n\nstatic struct gmin_cfg_var ffrd8_vars[] = {\n\t{ \"INTCF1B:00_ImxId\",    \"0x134\" },\n\t{ \"INTCF1B:00_CsiPort\",  \"1\" },\n\t{ \"INTCF1B:00_CsiLanes\", \"4\" },\n\t{ \"INTCF1B:00_CamClk\", \"0\" },\n\t{},\n};\n\n \nstatic struct gmin_cfg_var t100_vars[] = {\n\t{ \"INT33F0:00_CsiPort\",  \"0\" },\n\t{ \"INT33F0:00_CsiLanes\", \"1\" },\n\t{ \"INT33F0:00_CamClk\",   \"1\" },\n\t{},\n};\n\nstatic struct gmin_cfg_var mrd7_vars[] = {\n\t{\"INT33F8:00_CamType\", \"1\"},\n\t{\"INT33F8:00_CsiPort\", \"1\"},\n\t{\"INT33F8:00_CsiLanes\", \"2\"},\n\t{\"INT33F8:00_CsiFmt\", \"13\"},\n\t{\"INT33F8:00_CsiBayer\", \"0\"},\n\t{\"INT33F8:00_CamClk\", \"0\"},\n\n\t{\"INT33F9:00_CamType\", \"1\"},\n\t{\"INT33F9:00_CsiPort\", \"0\"},\n\t{\"INT33F9:00_CsiLanes\", \"1\"},\n\t{\"INT33F9:00_CsiFmt\", \"13\"},\n\t{\"INT33F9:00_CsiBayer\", \"0\"},\n\t{\"INT33F9:00_CamClk\", \"1\"},\n\t{},\n};\n\nstatic struct gmin_cfg_var ecs7_vars[] = {\n\t{\"INT33BE:00_CsiPort\", \"1\"},\n\t{\"INT33BE:00_CsiLanes\", \"2\"},\n\t{\"INT33BE:00_CsiFmt\", \"13\"},\n\t{\"INT33BE:00_CsiBayer\", \"2\"},\n\t{\"INT33BE:00_CamClk\", \"0\"},\n\n\t{\"INT33F0:00_CsiPort\", \"0\"},\n\t{\"INT33F0:00_CsiLanes\", \"1\"},\n\t{\"INT33F0:00_CsiFmt\", \"13\"},\n\t{\"INT33F0:00_CsiBayer\", \"0\"},\n\t{\"INT33F0:00_CamClk\", \"1\"},\n\t{\"gmin_V2P8GPIO\", \"402\"},\n\t{},\n};\n\nstatic struct gmin_cfg_var i8880_vars[] = {\n\t{\"XXOV2680:00_CsiPort\", \"1\"},\n\t{\"XXOV2680:00_CsiLanes\", \"1\"},\n\t{\"XXOV2680:00_CamClk\", \"0\"},\n\n\t{\"XXGC0310:00_CsiPort\", \"0\"},\n\t{\"XXGC0310:00_CsiLanes\", \"1\"},\n\t{\"XXGC0310:00_CamClk\", \"1\"},\n\t{},\n};\n\n \nstatic struct gmin_cfg_var surface3_vars[] = {\n\t{\"APTA0330:00_CsiPort\", \"0\"},\n\t{\"APTA0330:00_CsiLanes\", \"2\"},\n\n\t{\"OVTI8835:00_CsiPort\", \"1\"},\n\t{\"OVTI8835:00_CsiLanes\", \"4\"},\n\t{},\n};\n\nstatic struct gmin_cfg_var lenovo_ideapad_miix_310_vars[] = {\n\t \n\t{ \"OVTI2680:01_CsiPort\", \"0\" },\n\t{}\n};\n\nstatic const struct dmi_system_id gmin_vars[] = {\n\t \n\t{\n\t\t.ident = \"BYT-T FFD8\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"BYT-T FFD8\"),\n\t\t},\n\t\t.driver_data = ffrd8_vars,\n\t},\n\t{\n\t\t.ident = \"T100TA\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"T100TA\"),\n\t\t},\n\t\t.driver_data = t100_vars,\n\t},\n\t{\n\t\t.ident = \"MRD7\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"TABLET\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VERSION, \"MRD 7\"),\n\t\t},\n\t\t.driver_data = mrd7_vars,\n\t},\n\t{\n\t\t.ident = \"ST70408\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"ST70408\"),\n\t\t},\n\t\t.driver_data = ecs7_vars,\n\t},\n\t{\n\t\t.ident = \"VTA0803\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"VTA0803\"),\n\t\t},\n\t\t.driver_data = i8880_vars,\n\t},\n\t \n\t{\n\t\t.ident = \"Surface 3\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Surface 3\"),\n\t\t},\n\t\t.driver_data = surface3_vars,\n\t},\n\t{\n\t\t.ident = \"Lenovo Ideapad Miix 310\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"MIIX 310-10\"),\n\t\t},\n\t\t.driver_data = lenovo_ideapad_miix_310_vars,\n\t},\n\t{}\n};\n\n#define GMIN_CFG_VAR_EFI_GUID EFI_GUID(0xecb54cd9, 0xe5ae, 0x4fdc, \\\n\t\t\t\t       0xa9, 0x71, 0xe8, 0x77,\t   \\\n\t\t\t\t       0x75, 0x60, 0x68, 0xf7)\n\nstatic const guid_t atomisp_dsm_guid = GUID_INIT(0xdc2f6c4f, 0x045b, 0x4f1d,\n\t\t\t\t\t\t 0x97, 0xb9, 0x88, 0x2a,\n\t\t\t\t\t\t 0x68, 0x60, 0xa4, 0xbe);\n\n#define CFG_VAR_NAME_MAX 64\n\n#define GMIN_PMC_CLK_NAME 14  \nstatic char gmin_pmc_clk_name[GMIN_PMC_CLK_NAME];\n\nstatic struct i2c_client *gmin_i2c_dev_exists(struct device *dev, char *name,\n\t\t\t\t\t      struct i2c_client **client)\n{\n\tstruct acpi_device *adev;\n\tstruct device *d;\n\n\tadev = acpi_dev_get_first_match_dev(name, NULL, -1);\n\tif (!adev)\n\t\treturn NULL;\n\n\td = bus_find_device_by_acpi_dev(&i2c_bus_type, adev);\n\tacpi_dev_put(adev);\n\tif (!d)\n\t\treturn NULL;\n\n\t*client = i2c_verify_client(d);\n\tput_device(d);\n\n\tdev_dbg(dev, \"found '%s' at address 0x%02x, adapter %d\\n\",\n\t\t(*client)->name, (*client)->addr, (*client)->adapter->nr);\n\treturn *client;\n}\n\nstatic int gmin_i2c_write(struct device *dev, u16 i2c_addr, u8 reg,\n\t\t\t  u32 value, u32 mask)\n{\n\tint ret;\n\n\t \n\n\tdev_dbg(dev,\n\t\t\"I2C write, addr: 0x%02x, reg: 0x%02x, value: 0x%02x, mask: 0x%02x\\n\",\n\t\ti2c_addr, reg, value, mask);\n\n\tret = intel_soc_pmic_exec_mipi_pmic_seq_element(i2c_addr, reg, value, mask);\n\tif (ret == -EOPNOTSUPP)\n\t\tdev_err(dev,\n\t\t\t\"ACPI didn't mapped the OpRegion needed to access I2C address 0x%02x.\\n\"\n\t\t\t\"Need to compile the kernel using CONFIG_*_PMIC_OPREGION settings\\n\",\n\t\t\ti2c_addr);\n\n\treturn ret;\n}\n\nstatic int atomisp_get_acpi_power(struct device *dev)\n{\n\tchar name[5];\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_buffer b_name = { sizeof(name), name };\n\tunion acpi_object *package, *element;\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tacpi_handle rhandle;\n\tacpi_status status;\n\tint clock_num = -1;\n\tint i;\n\n\tstatus = acpi_evaluate_object(handle, \"_PR0\", NULL, &buffer);\n\tif (!ACPI_SUCCESS(status))\n\t\treturn -1;\n\n\tpackage = buffer.pointer;\n\n\tif (!buffer.length || !package\n\t    || package->type != ACPI_TYPE_PACKAGE\n\t    || !package->package.count)\n\t\tgoto fail;\n\n\tfor (i = 0; i < package->package.count; i++) {\n\t\telement = &package->package.elements[i];\n\n\t\tif (element->type != ACPI_TYPE_LOCAL_REFERENCE)\n\t\t\tcontinue;\n\n\t\trhandle = element->reference.handle;\n\t\tif (!rhandle)\n\t\t\tgoto fail;\n\n\t\tacpi_get_name(rhandle, ACPI_SINGLE_NAME, &b_name);\n\n\t\tdev_dbg(dev, \"Found PM resource '%s'\\n\", name);\n\t\tif (strlen(name) == 4 && !strncmp(name, \"CLK\", 3)) {\n\t\t\tif (name[3] >= '0' && name[3] <= '4')\n\t\t\t\tclock_num = name[3] - '0';\n#if 0\n\t\t\t \n\t\t\tif (clock_num >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t}\n\t}\n\nfail:\n\tACPI_FREE(buffer.pointer);\n\n\treturn clock_num;\n}\n\nstatic u8 gmin_get_pmic_id_and_addr(struct device *dev)\n{\n\tstruct i2c_client *power = NULL;\n\tstatic u8 pmic_i2c_addr;\n\n\tif (pmic_id)\n\t\treturn pmic_i2c_addr;\n\n\tif (gmin_i2c_dev_exists(dev, PMIC_ACPI_TI, &power))\n\t\tpmic_id = PMIC_TI;\n\telse if (gmin_i2c_dev_exists(dev, PMIC_ACPI_AXP, &power))\n\t\tpmic_id = PMIC_AXP;\n\telse if (gmin_i2c_dev_exists(dev, PMIC_ACPI_CRYSTALCOVE, &power))\n\t\tpmic_id = PMIC_CRYSTALCOVE;\n\telse\n\t\tpmic_id = PMIC_REGULATOR;\n\n\tpmic_i2c_addr = power ? power->addr : 0;\n\treturn pmic_i2c_addr;\n}\n\nstatic int gmin_detect_pmic(struct v4l2_subdev *subdev)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tstruct device *dev = &client->dev;\n\tu8 pmic_i2c_addr;\n\n\tpmic_i2c_addr = gmin_get_pmic_id_and_addr(dev);\n\tdev_info(dev, \"gmin: power management provided via %s (i2c addr 0x%02x)\\n\",\n\t\t pmic_name[pmic_id], pmic_i2c_addr);\n\treturn pmic_i2c_addr;\n}\n\nstatic int gmin_subdev_add(struct gmin_subdev *gs)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(gs->subdev);\n\tstruct device *dev = &client->dev;\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tint ret, default_val, clock_num = -1;\n\n\tdev_info(dev, \"%s: ACPI path is %pfw\\n\", __func__, dev_fwnode(dev));\n\n\t \n\tgs->clock_src = gmin_get_var_int(dev, false, \"ClkSrc\",\n\t\t\t\t         VLV2_CLK_PLL_19P2MHZ);\n\n\t \n\tif (acpi_device_power_manageable(adev))\n\t\tclock_num = atomisp_get_acpi_power(dev);\n\n\t \n\tif (IS_ISP2401)\n\t\tdefault_val = clock_num == 4 ? 1 : 0;\n\telse\n\t\tdefault_val = clock_num == 0 ? 1 : 0;\n\n\tgs->csi_port = gmin_get_var_int(dev, false, \"CsiPort\", default_val);\n\tgs->csi_lanes = gmin_get_var_int(dev, false, \"CsiLanes\", 1);\n\n\tgs->gpio0 = gpiod_get_index(dev, NULL, 0, GPIOD_OUT_LOW);\n\tif (IS_ERR(gs->gpio0))\n\t\tgs->gpio0 = NULL;\n\telse\n\t\tdev_info(dev, \"will handle gpio0 via ACPI\\n\");\n\n\tgs->gpio1 = gpiod_get_index(dev, NULL, 1, GPIOD_OUT_LOW);\n\tif (IS_ERR(gs->gpio1))\n\t\tgs->gpio1 = NULL;\n\telse\n\t\tdev_info(dev, \"will handle gpio1 via ACPI\\n\");\n\n\t \n\n\tgs->v1p8_gpio = gmin_get_var_int(dev, true, \"V1P8GPIO\", -1);\n\tgs->v2p8_gpio = gmin_get_var_int(dev, true, \"V2P8GPIO\", -1);\n\n\t \n\tif (acpi_device_can_wakeup(adev) &&\n\t    acpi_device_can_poweroff(adev)) {\n\t\tdev_info(dev,\n\t\t\t \"gmin: power management provided via device PM\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\n\t \n\n\t \n\tif (clock_num < 0)\n\t\tclock_num = gmin_get_var_int(dev, false, \"CamClk\", 0);\n\n\tif (clock_num < 0 || clock_num > MAX_CLK_COUNT) {\n\t\tdev_err(dev, \"Invalid clock number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnprintf(gmin_pmc_clk_name, sizeof(gmin_pmc_clk_name),\n\t\t \"%s_%d\", \"pmc_plt_clk\", clock_num);\n\n\tgs->pmc_clk = devm_clk_get(dev, gmin_pmc_clk_name);\n\tif (IS_ERR(gs->pmc_clk)) {\n\t\tret = PTR_ERR(gs->pmc_clk);\n\t\tdev_err(dev, \"Failed to get clk from %s: %d\\n\", gmin_pmc_clk_name, ret);\n\t\treturn ret;\n\t}\n\tdev_info(dev, \"Will use CLK%d (%s)\\n\", clock_num, gmin_pmc_clk_name);\n\n\t \n\tret = clk_prepare_enable(gs->pmc_clk);\n\tif (!ret)\n\t\tclk_disable_unprepare(gs->pmc_clk);\n\n\tswitch (pmic_id) {\n\tcase PMIC_REGULATOR:\n\t\tgs->v1p8_reg = regulator_get(dev, \"V1P8SX\");\n\t\tgs->v2p8_reg = regulator_get(dev, \"V2P8SX\");\n\n\t\tgs->v1p2_reg = regulator_get(dev, \"V1P2A\");\n\t\tgs->v2p8_vcm_reg = regulator_get(dev, \"VPROG4B\");\n\n\t\t \n\t\tbreak;\n\n\tcase PMIC_AXP:\n\t\tgs->eldo1_1p6v = gmin_get_var_int(dev, false,\n\t\t\t\t\t\t  \"eldo1_1p8v\",\n\t\t\t\t\t\t  ELDO1_1P6V);\n\t\tgs->eldo1_sel_reg = gmin_get_var_int(dev, false,\n\t\t\t\t\t\t     \"eldo1_sel_reg\",\n\t\t\t\t\t\t     ELDO1_SEL_REG);\n\t\tgs->eldo1_ctrl_shift = gmin_get_var_int(dev, false,\n\t\t\t\t\t\t\t\"eldo1_ctrl_shift\",\n\t\t\t\t\t\t\tELDO1_CTRL_SHIFT);\n\t\tgs->eldo2_1p8v = gmin_get_var_int(dev, false,\n\t\t\t\t\t\t  \"eldo2_1p8v\",\n\t\t\t\t\t\t  ELDO2_1P8V);\n\t\tgs->eldo2_sel_reg = gmin_get_var_int(dev, false,\n\t\t\t\t\t\t     \"eldo2_sel_reg\",\n\t\t\t\t\t\t     ELDO2_SEL_REG);\n\t\tgs->eldo2_ctrl_shift = gmin_get_var_int(dev, false,\n\t\t\t\t\t\t\t\"eldo2_ctrl_shift\",\n\t\t\t\t\t\t\tELDO2_CTRL_SHIFT);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct gmin_subdev *find_gmin_subdev(struct v4l2_subdev *subdev)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_SUBDEVS; i++)\n\t\tif (gmin_subdevs[i].subdev == subdev)\n\t\t\treturn &gmin_subdevs[i];\n\treturn NULL;\n}\n\nstatic struct gmin_subdev *find_free_gmin_subdev_slot(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < MAX_SUBDEVS; i++)\n\t\tif (gmin_subdevs[i].subdev == NULL)\n\t\t\treturn &gmin_subdevs[i];\n\treturn NULL;\n}\n\nstatic int axp_regulator_set(struct device *dev, struct gmin_subdev *gs,\n\t\t\t     int sel_reg, u8 setting,\n\t\t\t     int ctrl_reg, int shift, bool on)\n{\n\tint ret;\n\tint val;\n\n\tret = gmin_i2c_write(dev, gs->pwm_i2c_addr, sel_reg, setting, 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tval = on ? 1 << shift : 0;\n\n\tret = gmin_i2c_write(dev, gs->pwm_i2c_addr, ctrl_reg, val, 1 << shift);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic const struct dmi_system_id axp_leave_eldo2_on_ids[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TrekStor\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"SurfTab duo W1 10.1 (VT4)\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int axp_v1p8_on(struct device *dev, struct gmin_subdev *gs)\n{\n\tint ret;\n\n\tret = axp_regulator_set(dev, gs, gs->eldo2_sel_reg, gs->eldo2_1p8v,\n\t\t\t\tELDO_CTRL_REG, gs->eldo2_ctrl_shift, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(110, 150);\n\n\tret = axp_regulator_set(dev, gs, gs->eldo1_sel_reg, gs->eldo1_1p6v,\n\t\t\t\tELDO_CTRL_REG, gs->eldo1_ctrl_shift, true);\n\treturn ret;\n}\n\nstatic int axp_v1p8_off(struct device *dev, struct gmin_subdev *gs)\n{\n\tint ret;\n\n\tret = axp_regulator_set(dev, gs, gs->eldo1_sel_reg, gs->eldo1_1p6v,\n\t\t\t\tELDO_CTRL_REG, gs->eldo1_ctrl_shift, false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dmi_check_system(axp_leave_eldo2_on_ids))\n\t\treturn 0;\n\n\tret = axp_regulator_set(dev, gs, gs->eldo2_sel_reg, gs->eldo2_1p8v,\n\t\t\t\tELDO_CTRL_REG, gs->eldo2_ctrl_shift, false);\n\treturn ret;\n}\n\nstatic int gmin_gpio0_ctrl(struct v4l2_subdev *subdev, int on)\n{\n\tstruct gmin_subdev *gs = find_gmin_subdev(subdev);\n\n\tif (gs) {\n\t\tgpiod_set_value(gs->gpio0, on);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int gmin_gpio1_ctrl(struct v4l2_subdev *subdev, int on)\n{\n\tstruct gmin_subdev *gs = find_gmin_subdev(subdev);\n\n\tif (gs) {\n\t\tgpiod_set_value(gs->gpio1, on);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int gmin_v1p2_ctrl(struct v4l2_subdev *subdev, int on)\n{\n\tstruct gmin_subdev *gs = find_gmin_subdev(subdev);\n\n\tif (!gs || gs->v1p2_on == on)\n\t\treturn 0;\n\tgs->v1p2_on = on;\n\n\t \n\tif (gs->v1p2_reg) {\n\t\tif (on)\n\t\t\treturn regulator_enable(gs->v1p2_reg);\n\t\telse\n\t\t\treturn regulator_disable(gs->v1p2_reg);\n\t}\n\n\t \n\n\treturn -EINVAL;\n}\n\nstatic int gmin_v1p8_ctrl(struct v4l2_subdev *subdev, int on)\n{\n\tstruct gmin_subdev *gs = find_gmin_subdev(subdev);\n\tint ret;\n\tint value;\n\tint reg;\n\n\tif (!gs || gs->v1p8_on == on)\n\t\treturn 0;\n\n\tif (gs->v1p8_gpio >= 0) {\n\t\tpr_info(\"atomisp_gmin_platform: 1.8v power on GPIO %d\\n\",\n\t\t\tgs->v1p8_gpio);\n\t\tret = gpio_request(gs->v1p8_gpio, \"camera_v1p8_en\");\n\t\tif (!ret)\n\t\t\tret = gpio_direction_output(gs->v1p8_gpio, 0);\n\t\tif (ret)\n\t\t\tpr_err(\"V1P8 GPIO initialization failed\\n\");\n\t}\n\n\tgs->v1p8_on = on;\n\n\tret = 0;\n\tmutex_lock(&gmin_regulator_mutex);\n\tif (on) {\n\t\tgmin_v1p8_enable_count++;\n\t\tif (gmin_v1p8_enable_count > 1)\n\t\t\tgoto out;  \n\t} else {\n\t\tgmin_v1p8_enable_count--;\n\t\tif (gmin_v1p8_enable_count > 0)\n\t\t\tgoto out;  \n\t}\n\n\tif (gs->v1p8_gpio >= 0)\n\t\tgpio_set_value(gs->v1p8_gpio, on);\n\n\tif (gs->v1p8_reg) {\n\t\tregulator_set_voltage(gs->v1p8_reg, 1800000, 1800000);\n\t\tif (on)\n\t\t\tret = regulator_enable(gs->v1p8_reg);\n\t\telse\n\t\t\tret = regulator_disable(gs->v1p8_reg);\n\n\t\tgoto out;\n\t}\n\n\tswitch (pmic_id) {\n\tcase PMIC_AXP:\n\t\tif (on)\n\t\t\tret = axp_v1p8_on(subdev->dev, gs);\n\t\telse\n\t\t\tret = axp_v1p8_off(subdev->dev, gs);\n\t\tbreak;\n\tcase PMIC_TI:\n\t\tvalue = on ? LDO_1P8V_ON : LDO_1P8V_OFF;\n\n\t\tret = gmin_i2c_write(subdev->dev, gs->pwm_i2c_addr,\n\t\t\t\t     LDO10_REG, value, 0xff);\n\t\tbreak;\n\tcase PMIC_CRYSTALCOVE:\n\t\tif (IS_ISP2401)\n\t\t\treg = CRYSTAL_CHT_1P8V_REG;\n\t\telse\n\t\t\treg = CRYSTAL_BYT_1P8V_REG;\n\n\t\tvalue = on ? CRYSTAL_ON : CRYSTAL_OFF;\n\n\t\tret = gmin_i2c_write(subdev->dev, gs->pwm_i2c_addr,\n\t\t\t\t     reg, value, 0xff);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(subdev->dev, \"Couldn't set power mode for v1p8\\n\");\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&gmin_regulator_mutex);\n\treturn ret;\n}\n\nstatic int gmin_v2p8_ctrl(struct v4l2_subdev *subdev, int on)\n{\n\tstruct gmin_subdev *gs = find_gmin_subdev(subdev);\n\tint ret;\n\tint value;\n\tint reg;\n\n\tif (WARN_ON(!gs))\n\t\treturn -ENODEV;\n\n\tif (gs->v2p8_gpio >= 0) {\n\t\tpr_info(\"atomisp_gmin_platform: 2.8v power on GPIO %d\\n\",\n\t\t\tgs->v2p8_gpio);\n\t\tret = gpio_request(gs->v2p8_gpio, \"camera_v2p8\");\n\t\tif (!ret)\n\t\t\tret = gpio_direction_output(gs->v2p8_gpio, 0);\n\t\tif (ret)\n\t\t\tpr_err(\"V2P8 GPIO initialization failed\\n\");\n\t}\n\n\tif (gs->v2p8_on == on)\n\t\treturn 0;\n\tgs->v2p8_on = on;\n\n\tret = 0;\n\tmutex_lock(&gmin_regulator_mutex);\n\tif (on) {\n\t\tgmin_v2p8_enable_count++;\n\t\tif (gmin_v2p8_enable_count > 1)\n\t\t\tgoto out;  \n\t} else {\n\t\tgmin_v2p8_enable_count--;\n\t\tif (gmin_v2p8_enable_count > 0)\n\t\t\tgoto out;  \n\t}\n\n\tif (gs->v2p8_gpio >= 0)\n\t\tgpio_set_value(gs->v2p8_gpio, on);\n\n\tif (gs->v2p8_reg) {\n\t\tregulator_set_voltage(gs->v2p8_reg, 2900000, 2900000);\n\t\tif (on)\n\t\t\tret = regulator_enable(gs->v2p8_reg);\n\t\telse\n\t\t\tret = regulator_disable(gs->v2p8_reg);\n\n\t\tgoto out;\n\t}\n\n\tswitch (pmic_id) {\n\tcase PMIC_AXP:\n\t\tret = axp_regulator_set(subdev->dev, gs, ALDO1_SEL_REG,\n\t\t\t\t\tALDO1_2P8V, ALDO1_CTRL3_REG,\n\t\t\t\t\tALDO1_CTRL3_SHIFT, on);\n\t\tbreak;\n\tcase PMIC_TI:\n\t\tvalue = on ? LDO_2P8V_ON : LDO_2P8V_OFF;\n\n\t\tret = gmin_i2c_write(subdev->dev, gs->pwm_i2c_addr,\n\t\t\t\t     LDO9_REG, value, 0xff);\n\t\tbreak;\n\tcase PMIC_CRYSTALCOVE:\n\t\tif (IS_ISP2401)\n\t\t\treg = CRYSTAL_CHT_2P8V_REG;\n\t\telse\n\t\t\treg = CRYSTAL_BYT_2P8V_REG;\n\n\t\tvalue = on ? CRYSTAL_ON : CRYSTAL_OFF;\n\n\t\tret = gmin_i2c_write(subdev->dev, gs->pwm_i2c_addr,\n\t\t\t\t     reg, value, 0xff);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(subdev->dev, \"Couldn't set power mode for v2p8\\n\");\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&gmin_regulator_mutex);\n\treturn ret;\n}\n\nstatic int gmin_acpi_pm_ctrl(struct v4l2_subdev *subdev, int on)\n{\n\tint ret = 0;\n\tstruct gmin_subdev *gs = find_gmin_subdev(subdev);\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tstruct acpi_device *adev = ACPI_COMPANION(&client->dev);\n\n\t \n\ton = !!on;\n\tif (gs->clock_on == on)\n\t\treturn 0;\n\n\tdev_dbg(subdev->dev, \"Setting power state to %s\\n\",\n\t\ton ? \"on\" : \"off\");\n\n\tif (on)\n\t\tret = acpi_device_set_power(adev,\n\t\t\t\t\t    ACPI_STATE_D0);\n\telse\n\t\tret = acpi_device_set_power(adev,\n\t\t\t\t\t    ACPI_STATE_D3_COLD);\n\n\tif (!ret)\n\t\tgs->clock_on = on;\n\telse\n\t\tdev_err(subdev->dev, \"Couldn't set power state to %s\\n\",\n\t\t\ton ? \"on\" : \"off\");\n\n\treturn ret;\n}\n\nstatic int gmin_flisclk_ctrl(struct v4l2_subdev *subdev, int on)\n{\n\tint ret = 0;\n\tstruct gmin_subdev *gs = find_gmin_subdev(subdev);\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\n\tif (gs->clock_on == !!on)\n\t\treturn 0;\n\n\tif (on) {\n\t\tret = clk_set_rate(gs->pmc_clk,\n\t\t\t\t   gs->clock_src ? CLK_RATE_19_2MHZ : CLK_RATE_25_0MHZ);\n\n\t\tif (ret)\n\t\t\tdev_err(&client->dev, \"unable to set PMC rate %d\\n\",\n\t\t\t\tgs->clock_src);\n\n\t\tret = clk_prepare_enable(gs->pmc_clk);\n\t\tif (ret == 0)\n\t\t\tgs->clock_on = true;\n\t} else {\n\t\tclk_disable_unprepare(gs->pmc_clk);\n\t\tgs->clock_on = false;\n\t}\n\n\treturn ret;\n}\n\nstatic int camera_sensor_csi_alloc(struct v4l2_subdev *sd, u32 port, u32 lanes,\n\t\t\t\t   u32 format, u32 bayer_order)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct camera_mipi_info *csi;\n\n\tcsi = kzalloc(sizeof(*csi), GFP_KERNEL);\n\tif (!csi)\n\t\treturn -ENOMEM;\n\n\tcsi->port = port;\n\tcsi->num_lanes = lanes;\n\tcsi->input_format = format;\n\tcsi->raw_bayer_order = bayer_order;\n\tv4l2_set_subdev_hostdata(sd, csi);\n\tcsi->metadata_format = ATOMISP_INPUT_FORMAT_EMBEDDED;\n\tcsi->metadata_effective_width = NULL;\n\tdev_info(&client->dev,\n\t\t \"camera pdata: port: %d lanes: %d order: %8.8x\\n\",\n\t\t port, lanes, bayer_order);\n\n\treturn 0;\n}\n\nstatic void camera_sensor_csi_free(struct v4l2_subdev *sd)\n{\n\tstruct camera_mipi_info *csi;\n\n\tcsi = v4l2_get_subdev_hostdata(sd);\n\tkfree(csi);\n}\n\nstatic int gmin_csi_cfg(struct v4l2_subdev *sd, int flag)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct gmin_subdev *gs = find_gmin_subdev(sd);\n\n\tif (!client || !gs)\n\t\treturn -ENODEV;\n\n\tif (flag)\n\t\treturn camera_sensor_csi_alloc(sd, gs->csi_port, gs->csi_lanes,\n\t\t\t\t\t       gs->csi_fmt, gs->csi_bayer);\n\tcamera_sensor_csi_free(sd);\n\treturn 0;\n}\n\nint atomisp_register_sensor_no_gmin(struct v4l2_subdev *subdev, u32 lanes,\n\t\t\t\t    enum atomisp_input_format format,\n\t\t\t\t    enum atomisp_bayer_order bayer_order)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tstruct acpi_device *adev = ACPI_COMPANION(&client->dev);\n\tint i, ret, clock_num, port = 0;\n\n\tif (adev) {\n\t\t \n\t\tif (acpi_device_power_manageable(adev)) {\n\t\t\tclock_num = atomisp_get_acpi_power(&client->dev);\n\n\t\t\t \n\t\t\tif (IS_ISP2401)\n\t\t\t\tport = clock_num == 4 ? 1 : 0;\n\t\t\telse\n\t\t\t\tport = clock_num == 0 ? 1 : 0;\n\t\t}\n\n\t\tport = gmin_get_var_int(&client->dev, false, \"CsiPort\", port);\n\t\tlanes = gmin_get_var_int(&client->dev, false, \"CsiLanes\", lanes);\n\t}\n\n\tfor (i = 0; i < MAX_SUBDEVS; i++)\n\t\tif (!pdata.subdevs[i].type)\n\t\t\tbreak;\n\n\tif (i >= MAX_SUBDEVS) {\n\t\tdev_err(&client->dev, \"Error too many subdevs already registered\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = camera_sensor_csi_alloc(subdev, port, lanes, format, bayer_order);\n\tif (ret)\n\t\treturn ret;\n\n\tpdata.subdevs[i].type = RAW_CAMERA;\n\tpdata.subdevs[i].port = port;\n\tpdata.subdevs[i].lanes = lanes;\n\tpdata.subdevs[i].subdev = subdev;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(atomisp_register_sensor_no_gmin);\n\nvoid atomisp_unregister_subdev(struct v4l2_subdev *subdev)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_SUBDEVS; i++) {\n\t\tif (pdata.subdevs[i].subdev != subdev)\n\t\t\tcontinue;\n\n\t\tcamera_sensor_csi_free(subdev);\n\t\tpdata.subdevs[i].subdev = NULL;\n\t\tpdata.subdevs[i].type = 0;\n\t\tpdata.subdevs[i].port = 0;\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(atomisp_unregister_subdev);\n\nstatic struct camera_vcm_control *gmin_get_vcm_ctrl(struct v4l2_subdev *subdev,\n\tchar *camera_module)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tstruct gmin_subdev *gs = find_gmin_subdev(subdev);\n\tstruct camera_vcm_control *vcm;\n\n\tif (!client || !gs)\n\t\treturn NULL;\n\n\tif (!camera_module)\n\t\treturn NULL;\n\n\tmutex_lock(&vcm_lock);\n\tlist_for_each_entry(vcm, &vcm_devices, list) {\n\t\tif (!strcmp(camera_module, vcm->camera_module)) {\n\t\t\tmutex_unlock(&vcm_lock);\n\t\t\treturn vcm;\n\t\t}\n\t}\n\n\tmutex_unlock(&vcm_lock);\n\treturn NULL;\n}\n\nstatic struct camera_sensor_platform_data pmic_gmin_plat = {\n\t.gpio0_ctrl = gmin_gpio0_ctrl,\n\t.gpio1_ctrl = gmin_gpio1_ctrl,\n\t.v1p8_ctrl = gmin_v1p8_ctrl,\n\t.v2p8_ctrl = gmin_v2p8_ctrl,\n\t.v1p2_ctrl = gmin_v1p2_ctrl,\n\t.flisclk_ctrl = gmin_flisclk_ctrl,\n\t.csi_cfg = gmin_csi_cfg,\n\t.get_vcm_ctrl = gmin_get_vcm_ctrl,\n};\n\nstatic struct camera_sensor_platform_data acpi_gmin_plat = {\n\t.gpio0_ctrl = gmin_gpio0_ctrl,\n\t.gpio1_ctrl = gmin_gpio1_ctrl,\n\t.v1p8_ctrl = gmin_acpi_pm_ctrl,\n\t.v2p8_ctrl = gmin_acpi_pm_ctrl,\n\t.v1p2_ctrl = gmin_acpi_pm_ctrl,\n\t.flisclk_ctrl = gmin_acpi_pm_ctrl,\n\t.csi_cfg = gmin_csi_cfg,\n\t.get_vcm_ctrl = gmin_get_vcm_ctrl,\n};\n\nstruct camera_sensor_platform_data *\ngmin_camera_platform_data(struct v4l2_subdev *subdev,\n\t\t\t  enum atomisp_input_format csi_format,\n\t\t\t  enum atomisp_bayer_order csi_bayer)\n{\n\tu8 pmic_i2c_addr = gmin_detect_pmic(subdev);\n\tstruct gmin_subdev *gs;\n\n\tgs = find_free_gmin_subdev_slot();\n\tgs->subdev = subdev;\n\tgs->csi_fmt = csi_format;\n\tgs->csi_bayer = csi_bayer;\n\tgs->pwm_i2c_addr = pmic_i2c_addr;\n\n\tgmin_subdev_add(gs);\n\tif (gs->pmc_clk)\n\t\treturn &pmic_gmin_plat;\n\telse\n\t\treturn &acpi_gmin_plat;\n}\nEXPORT_SYMBOL_GPL(gmin_camera_platform_data);\n\nint atomisp_gmin_register_vcm_control(struct camera_vcm_control *vcmCtrl)\n{\n\tif (!vcmCtrl)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&vcm_lock);\n\tlist_add_tail(&vcmCtrl->list, &vcm_devices);\n\tmutex_unlock(&vcm_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(atomisp_gmin_register_vcm_control);\n\nstatic int gmin_get_hardcoded_var(struct device *dev,\n\t\t\t\t  struct gmin_cfg_var *varlist,\n\t\t\t\t  const char *var8, char *out, size_t *out_len)\n{\n\tstruct gmin_cfg_var *gv;\n\n\tfor (gv = varlist; gv->name; gv++) {\n\t\tsize_t vl;\n\n\t\tif (strcmp(var8, gv->name))\n\t\t\tcontinue;\n\n\t\tdev_info(dev, \"Found DMI entry for '%s'\\n\", var8);\n\n\t\tvl = strlen(gv->val);\n\t\tif (vl > *out_len - 1)\n\t\t\treturn -ENOSPC;\n\n\t\tstrscpy(out, gv->val, *out_len);\n\t\t*out_len = vl;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n\nstatic int gmin_get_config_dsm_var(struct device *dev,\n\t\t\t\t   const char *var,\n\t\t\t\t   char *out, size_t *out_len)\n{\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tunion acpi_object *obj, *cur = NULL;\n\tint i;\n\n\t \n\tif (!strcmp(var, \"CamClk\"))\n\t\treturn -EINVAL;\n\n\t \n\tobj = acpi_evaluate_dsm_typed(handle, &atomisp_dsm_guid, 0, 0, NULL,\n\t\t\t\t      ACPI_TYPE_PACKAGE);\n\tif (!obj) {\n\t\tdev_info_once(dev, \"Didn't find ACPI _DSM table.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n#if 0  \n\tfor (i = 0; i < obj->package.count; i++) {\n\t\tunion acpi_object *cur = &obj->package.elements[i];\n\n\t\tif (cur->type == ACPI_TYPE_INTEGER)\n\t\t\tdev_info(dev, \"object #%d, type %d, value: %lld\\n\",\n\t\t\t\t i, cur->type, cur->integer.value);\n\t\telse if (cur->type == ACPI_TYPE_STRING)\n\t\t\tdev_info(dev, \"object #%d, type %d, string: %s\\n\",\n\t\t\t\t i, cur->type, cur->string.pointer);\n\t\telse\n\t\t\tdev_info(dev, \"object #%d, type %d\\n\",\n\t\t\t\t i, cur->type);\n\t}\n#endif\n\n\t \n\tfor (i = 0; i < obj->package.count - 1; i += 2) {\n\t\tif (obj->package.elements[i].type == ACPI_TYPE_STRING &&\n\t\t    !strcmp(obj->package.elements[i].string.pointer, var)) {\n\t\t\t \n\t\t\tcur = &obj->package.elements[i + 1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!cur) {\n\t\tdev_info(dev, \"didn't found _DSM entry for '%s'\\n\", var);\n\t\tACPI_FREE(obj);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cur && cur->type != ACPI_TYPE_STRING) {\n\t\tdev_info(dev, \"found non-string _DSM entry for '%s'\\n\", var);\n\t\tACPI_FREE(obj);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(dev, \"found _DSM entry for '%s': %s\\n\", var,\n\t\t cur->string.pointer);\n\tstrscpy(out, cur->string.pointer, *out_len);\n\t*out_len = strlen(out);\n\n\tACPI_FREE(obj);\n\treturn 0;\n}\n\n \nstatic int gmin_get_config_var(struct device *maindev,\n\t\t\t       bool is_gmin,\n\t\t\t       const char *var,\n\t\t\t       char *out, size_t *out_len)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(maindev);\n\tefi_char16_t var16[CFG_VAR_NAME_MAX];\n\tconst struct dmi_system_id *id;\n\tchar var8[CFG_VAR_NAME_MAX];\n\tefi_status_t status;\n\tint i, ret;\n\n\tif (!is_gmin && adev)\n\t\tret = snprintf(var8, sizeof(var8), \"%s_%s\", acpi_dev_name(adev), var);\n\telse\n\t\tret = snprintf(var8, sizeof(var8), \"gmin_%s\", var);\n\n\tif (ret < 0 || ret >= sizeof(var8) - 1)\n\t\treturn -EINVAL;\n\n\t \n\tid = dmi_first_match(gmin_vars);\n\tif (id) {\n\t\tret = gmin_get_hardcoded_var(maindev, id->driver_data, var8,\n\t\t\t\t\t     out, out_len);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (!is_gmin) {\n\t\tret = gmin_get_config_dsm_var(maindev, var, out, out_len);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\t \n\tmemset(var16, 0, sizeof(var16));\n\tfor (i = 0; i < sizeof(var8) && var8[i]; i++)\n\t\tvar16[i] = var8[i];\n\n\tstatus = EFI_UNSUPPORTED;\n\tif (efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE))\n\t\tstatus = efi.get_variable(var16, &GMIN_CFG_VAR_EFI_GUID, NULL,\n\t\t\t\t\t  (unsigned long *)out_len, out);\n\tif (status == EFI_SUCCESS) {\n\t\tdev_info(maindev, \"found EFI entry for '%s'\\n\", var8);\n\t} else if (is_gmin) {\n\t\tdev_info(maindev, \"Failed to find EFI gmin variable %s\\n\", var8);\n\t} else {\n\t\tdev_info(maindev, \"Failed to find EFI variable %s\\n\", var8);\n\t}\n\n\treturn ret;\n}\n\nint gmin_get_var_int(struct device *dev, bool is_gmin, const char *var, int def)\n{\n\tchar val[CFG_VAR_NAME_MAX + 1];\n\tsize_t len = CFG_VAR_NAME_MAX;\n\tlong result;\n\tint ret;\n\n\tret = gmin_get_config_var(dev, is_gmin, var, val, &len);\n\tif (!ret) {\n\t\tval[len] = 0;\n\t\tret = kstrtol(val, 0, &result);\n\t} else {\n\t\tdev_info(dev, \"%s: using default (%d)\\n\", var, def);\n\t}\n\n\treturn ret ? def : result;\n}\nEXPORT_SYMBOL_GPL(gmin_get_var_int);\n\n \nstatic void isp_pm_cap_fixup(struct pci_dev *pdev)\n{\n\tdev_info(&pdev->dev, \"Disabling PCI power management on camera ISP\\n\");\n\tpdev->pm_cap = 0;\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0f38, isp_pm_cap_fixup);\n\nMODULE_DESCRIPTION(\"Ancillary routines for binding ACPI devices\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}