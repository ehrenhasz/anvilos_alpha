{
  "module_name": "atomisp_cmd.c",
  "hash_id": "7a75619200bb10f2094b69fee9c13f4e53a4cc047b3a2b01705d859167ba75de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/atomisp_cmd.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/firmware.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/kfifo.h>\n#include <linux/pm_runtime.h>\n#include <linux/timer.h>\n\n#include <asm/iosf_mbi.h>\n\n#include <media/v4l2-event.h>\n\n#define CREATE_TRACE_POINTS\n#include \"atomisp_trace_event.h\"\n\n#include \"atomisp_cmd.h\"\n#include \"atomisp_common.h\"\n#include \"atomisp_fops.h\"\n#include \"atomisp_internal.h\"\n#include \"atomisp_ioctl.h\"\n#include \"atomisp-regs.h\"\n#include \"atomisp_tables.h\"\n#include \"atomisp_compat.h\"\n#include \"atomisp_subdev.h\"\n#include \"atomisp_dfs_tables.h\"\n\n#include <hmm/hmm.h>\n\n#include \"sh_css_hrt.h\"\n#include \"sh_css_defs.h\"\n#include \"system_global.h\"\n#include \"sh_css_internal.h\"\n#include \"sh_css_sp.h\"\n#include \"gp_device.h\"\n#include \"device_access.h\"\n#include \"irq.h\"\n\n#include \"ia_css_types.h\"\n#include \"ia_css_stream.h\"\n#include \"ia_css_debug.h\"\n#include \"bits.h\"\n\n \n#define FLASH_TIMEOUT 800  \n\nunion host {\n\tstruct {\n\t\tvoid *kernel_ptr;\n\t\tvoid __user *user_ptr;\n\t\tint size;\n\t} scalar;\n\tstruct {\n\t\tvoid *hmm_ptr;\n\t} ptr;\n};\n\n \nstruct camera_mipi_info *atomisp_to_sensor_mipi_info(struct v4l2_subdev *sd)\n{\n\treturn (struct camera_mipi_info *)v4l2_get_subdev_hostdata(sd);\n}\n\n \nstruct atomisp_video_pipe *atomisp_to_video_pipe(struct video_device *dev)\n{\n\treturn (struct atomisp_video_pipe *)\n\t       container_of(dev, struct atomisp_video_pipe, vdev);\n}\n\nstatic unsigned short atomisp_get_sensor_fps(struct atomisp_sub_device *asd)\n{\n\tstruct v4l2_subdev_frame_interval fi = { 0 };\n\tstruct atomisp_device *isp = asd->isp;\n\n\tunsigned short fps = 0;\n\tint ret;\n\n\tret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,\n\t\t\t       video, g_frame_interval, &fi);\n\n\tif (!ret && fi.interval.numerator)\n\t\tfps = fi.interval.denominator / fi.interval.numerator;\n\n\treturn fps;\n}\n\n \nstatic int write_target_freq_to_hw(struct atomisp_device *isp,\n\t\t\t\t   unsigned int new_freq)\n{\n\tunsigned int ratio, timeout, guar_ratio;\n\tu32 isp_sspm1 = 0;\n\tint i;\n\n\tif (!isp->hpll_freq) {\n\t\tdev_err(isp->dev, \"failed to get hpll_freq. no change to freq\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tiosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM1, &isp_sspm1);\n\tif (isp_sspm1 & ISP_FREQ_VALID_MASK) {\n\t\tdev_dbg(isp->dev, \"clearing ISPSSPM1 valid bit.\\n\");\n\t\tiosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE, ISPSSPM1,\n\t\t\t       isp_sspm1 & ~(1 << ISP_FREQ_VALID_OFFSET));\n\t}\n\n\tratio = (2 * isp->hpll_freq + new_freq / 2) / new_freq - 1;\n\tguar_ratio = (2 * isp->hpll_freq + 200 / 2) / 200 - 1;\n\n\tiosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM1, &isp_sspm1);\n\tisp_sspm1 &= ~(0x1F << ISP_REQ_FREQ_OFFSET);\n\n\tfor (i = 0; i < ISP_DFS_TRY_TIMES; i++) {\n\t\tiosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE, ISPSSPM1,\n\t\t\t       isp_sspm1\n\t\t\t       | ratio << ISP_REQ_FREQ_OFFSET\n\t\t\t       | 1 << ISP_FREQ_VALID_OFFSET\n\t\t\t       | guar_ratio << ISP_REQ_GUAR_FREQ_OFFSET);\n\n\t\tiosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM1, &isp_sspm1);\n\t\ttimeout = 20;\n\t\twhile ((isp_sspm1 & ISP_FREQ_VALID_MASK) && timeout) {\n\t\t\tiosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM1, &isp_sspm1);\n\t\t\tdev_dbg(isp->dev, \"waiting for ISPSSPM1 valid bit to be 0.\\n\");\n\t\t\tudelay(100);\n\t\t\ttimeout--;\n\t\t}\n\n\t\tif (timeout != 0)\n\t\t\tbreak;\n\t}\n\n\tif (timeout == 0) {\n\t\tdev_err(isp->dev, \"DFS failed due to HW error.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tiosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM1, &isp_sspm1);\n\ttimeout = 10;\n\twhile (((isp_sspm1 >> ISP_FREQ_STAT_OFFSET) != ratio) && timeout) {\n\t\tiosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM1, &isp_sspm1);\n\t\tdev_dbg(isp->dev, \"waiting for ISPSSPM1 status bit to be 0x%x.\\n\",\n\t\t\tnew_freq);\n\t\tudelay(100);\n\t\ttimeout--;\n\t}\n\tif (timeout == 0) {\n\t\tdev_err(isp->dev, \"DFS target freq is rejected by HW.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint atomisp_freq_scaling(struct atomisp_device *isp,\n\t\t\t enum atomisp_dfs_mode mode,\n\t\t\t bool force)\n{\n\tconst struct atomisp_dfs_config *dfs;\n\tunsigned int new_freq;\n\tstruct atomisp_freq_scaling_rule curr_rules;\n\tint i, ret;\n\tunsigned short fps = 0;\n\n\tdfs = isp->dfs;\n\n\tif (dfs->lowest_freq == 0 || dfs->max_freq_at_vmin == 0 ||\n\t    dfs->highest_freq == 0 || dfs->dfs_table_size == 0 ||\n\t    !dfs->dfs_table) {\n\t\tdev_err(isp->dev, \"DFS configuration is invalid.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode == ATOMISP_DFS_MODE_LOW) {\n\t\tnew_freq = dfs->lowest_freq;\n\t\tgoto done;\n\t}\n\n\tif (mode == ATOMISP_DFS_MODE_MAX) {\n\t\tnew_freq = dfs->highest_freq;\n\t\tgoto done;\n\t}\n\n\tfps = atomisp_get_sensor_fps(&isp->asd);\n\tif (fps == 0) {\n\t\tdev_info(isp->dev,\n\t\t\t \"Sensor didn't report FPS. Using DFS max mode.\\n\");\n\t\tnew_freq = dfs->highest_freq;\n\t\tgoto done;\n\t}\n\n\tcurr_rules.width = isp->asd.fmt[ATOMISP_SUBDEV_PAD_SOURCE].fmt.width;\n\tcurr_rules.height = isp->asd.fmt[ATOMISP_SUBDEV_PAD_SOURCE].fmt.height;\n\tcurr_rules.fps = fps;\n\tcurr_rules.run_mode = isp->asd.run_mode->val;\n\n\t \n\tfor (i = 0; i < dfs->dfs_table_size; i++) {\n\t\tif (curr_rules.width != dfs->dfs_table[i].width &&\n\t\t    dfs->dfs_table[i].width != ISP_FREQ_RULE_ANY)\n\t\t\tcontinue;\n\t\tif (curr_rules.height != dfs->dfs_table[i].height &&\n\t\t    dfs->dfs_table[i].height != ISP_FREQ_RULE_ANY)\n\t\t\tcontinue;\n\t\tif (curr_rules.fps != dfs->dfs_table[i].fps &&\n\t\t    dfs->dfs_table[i].fps != ISP_FREQ_RULE_ANY)\n\t\t\tcontinue;\n\t\tif (curr_rules.run_mode != dfs->dfs_table[i].run_mode &&\n\t\t    dfs->dfs_table[i].run_mode != ISP_FREQ_RULE_ANY)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (i == dfs->dfs_table_size)\n\t\tnew_freq = dfs->max_freq_at_vmin;\n\telse\n\t\tnew_freq = dfs->dfs_table[i].isp_freq;\n\ndone:\n\tdev_dbg(isp->dev, \"DFS target frequency=%d.\\n\", new_freq);\n\n\tif ((new_freq == isp->running_freq) && !force)\n\t\treturn 0;\n\n\tdev_dbg(isp->dev, \"Programming DFS frequency to %d\\n\", new_freq);\n\n\tret = write_target_freq_to_hw(isp, new_freq);\n\tif (!ret) {\n\t\tisp->running_freq = new_freq;\n\t\ttrace_ipu_pstate(new_freq, -1);\n\t}\n\treturn ret;\n}\n\n \nint atomisp_reset(struct atomisp_device *isp)\n{\n\t \n\tint ret = 0;\n\n\tdev_dbg(isp->dev, \"%s\\n\", __func__);\n\n\tret = atomisp_power_off(isp->dev);\n\tif (ret < 0)\n\t\tdev_err(isp->dev, \"atomisp_power_off failed, %d\\n\", ret);\n\n\tret = atomisp_power_on(isp->dev);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"atomisp_power_on failed, %d\\n\", ret);\n\t\tisp->isp_fatal_error = true;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void disable_isp_irq(enum hrt_isp_css_irq irq)\n{\n\tirq_disable_channel(IRQ0_ID, irq);\n\n\tif (irq != hrt_isp_css_irq_sp)\n\t\treturn;\n\n\tcnd_sp_irq_enable(SP0_ID, false);\n}\n\n \nstatic void clear_isp_irq(enum hrt_isp_css_irq irq)\n{\n\tirq_clear_all(IRQ0_ID);\n}\n\nvoid atomisp_msi_irq_init(struct atomisp_device *isp)\n{\n\tstruct pci_dev *pdev = to_pci_dev(isp->dev);\n\tu32 msg32;\n\tu16 msg16;\n\n\tpci_read_config_dword(pdev, PCI_MSI_CAPID, &msg32);\n\tmsg32 |= 1 << MSI_ENABLE_BIT;\n\tpci_write_config_dword(pdev, PCI_MSI_CAPID, msg32);\n\n\tmsg32 = (1 << INTR_IER) | (1 << INTR_IIR);\n\tpci_write_config_dword(pdev, PCI_INTERRUPT_CTRL, msg32);\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &msg16);\n\tmsg16 |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |\n\t\t  PCI_COMMAND_INTX_DISABLE);\n\tpci_write_config_word(pdev, PCI_COMMAND, msg16);\n}\n\nvoid atomisp_msi_irq_uninit(struct atomisp_device *isp)\n{\n\tstruct pci_dev *pdev = to_pci_dev(isp->dev);\n\tu32 msg32;\n\tu16 msg16;\n\n\tpci_read_config_dword(pdev, PCI_MSI_CAPID, &msg32);\n\tmsg32 &=  ~(1 << MSI_ENABLE_BIT);\n\tpci_write_config_dword(pdev, PCI_MSI_CAPID, msg32);\n\n\tmsg32 = 0x0;\n\tpci_write_config_dword(pdev, PCI_INTERRUPT_CTRL, msg32);\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &msg16);\n\tmsg16 &= ~(PCI_COMMAND_MASTER);\n\tpci_write_config_word(pdev, PCI_COMMAND, msg16);\n}\n\nstatic void atomisp_sof_event(struct atomisp_sub_device *asd)\n{\n\tstruct v4l2_event event = {0};\n\n\tevent.type = V4L2_EVENT_FRAME_SYNC;\n\tevent.u.frame_sync.frame_sequence = atomic_read(&asd->sof_count);\n\n\tv4l2_event_queue(asd->subdev.devnode, &event);\n}\n\nvoid atomisp_eof_event(struct atomisp_sub_device *asd, uint8_t exp_id)\n{\n\tstruct v4l2_event event = {0};\n\n\tevent.type = V4L2_EVENT_FRAME_END;\n\tevent.u.frame_sync.frame_sequence = exp_id;\n\n\tv4l2_event_queue(asd->subdev.devnode, &event);\n}\n\nstatic void atomisp_3a_stats_ready_event(struct atomisp_sub_device *asd,\n\tuint8_t exp_id)\n{\n\tstruct v4l2_event event = {0};\n\n\tevent.type = V4L2_EVENT_ATOMISP_3A_STATS_READY;\n\tevent.u.frame_sync.frame_sequence = exp_id;\n\n\tv4l2_event_queue(asd->subdev.devnode, &event);\n}\n\nstatic void atomisp_metadata_ready_event(struct atomisp_sub_device *asd,\n\tenum atomisp_metadata_type md_type)\n{\n\tstruct v4l2_event event = {0};\n\n\tevent.type = V4L2_EVENT_ATOMISP_METADATA_READY;\n\tevent.u.data[0] = md_type;\n\n\tv4l2_event_queue(asd->subdev.devnode, &event);\n}\n\nstatic void atomisp_reset_event(struct atomisp_sub_device *asd)\n{\n\tstruct v4l2_event event = {0};\n\n\tevent.type = V4L2_EVENT_ATOMISP_CSS_RESET;\n\n\tv4l2_event_queue(asd->subdev.devnode, &event);\n}\n\nstatic void print_csi_rx_errors(enum mipi_port_id port,\n\t\t\t\tstruct atomisp_device *isp)\n{\n\tu32 infos = 0;\n\n\tatomisp_css_rx_get_irq_info(port, &infos);\n\n\tdev_err(isp->dev, \"CSI Receiver port %d errors:\\n\", port);\n\tif (infos & IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN)\n\t\tdev_err(isp->dev, \"  buffer overrun\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_SOT)\n\t\tdev_err(isp->dev, \"  start-of-transmission error\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC)\n\t\tdev_err(isp->dev, \"  start-of-transmission sync error\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_CONTROL)\n\t\tdev_err(isp->dev, \"  control error\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE)\n\t\tdev_err(isp->dev, \"  2 or more ECC errors\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_CRC)\n\t\tdev_err(isp->dev, \"  CRC mismatch\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID)\n\t\tdev_err(isp->dev, \"  unknown error\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC)\n\t\tdev_err(isp->dev, \"  frame sync error\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA)\n\t\tdev_err(isp->dev, \"  frame data error\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT)\n\t\tdev_err(isp->dev, \"  data timeout\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC)\n\t\tdev_err(isp->dev, \"  unknown escape command entry\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC)\n\t\tdev_err(isp->dev, \"  line sync error\");\n}\n\n \nstatic void clear_irq_reg(struct atomisp_device *isp)\n{\n\tstruct pci_dev *pdev = to_pci_dev(isp->dev);\n\tu32 msg_ret;\n\n\tpci_read_config_dword(pdev, PCI_INTERRUPT_CTRL, &msg_ret);\n\tmsg_ret |= 1 << INTR_IIR;\n\tpci_write_config_dword(pdev, PCI_INTERRUPT_CTRL, msg_ret);\n}\n\n \nirqreturn_t atomisp_isr(int irq, void *dev)\n{\n\tstruct atomisp_device *isp = (struct atomisp_device *)dev;\n\tstruct atomisp_css_event eof_event;\n\tunsigned int irq_infos = 0;\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&isp->lock, flags);\n\n\tif (!isp->css_initialized) {\n\t\tspin_unlock_irqrestore(&isp->lock, flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\terr = atomisp_css_irq_translate(isp, &irq_infos);\n\tif (err) {\n\t\tspin_unlock_irqrestore(&isp->lock, flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\tclear_irq_reg(isp);\n\n\tif (!isp->asd.streaming)\n\t\tgoto out_nowake;\n\n\tif (irq_infos & IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF) {\n\t\tatomic_inc(&isp->asd.sof_count);\n\t\tatomisp_sof_event(&isp->asd);\n\n\t\t \n\t\tif (atomic_read(&isp->asd.sequence) == atomic_read(&isp->asd.sequence_temp))\n\t\t\tatomic_set(&isp->asd.sequence_temp, atomic_read(&isp->asd.sof_count));\n\n\t\tdev_dbg_ratelimited(isp->dev, \"irq:0x%x (SOF)\\n\", irq_infos);\n\t\tirq_infos &= ~IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF;\n\t}\n\n\tif (irq_infos & IA_CSS_IRQ_INFO_EVENTS_READY)\n\t\tatomic_set(&isp->asd.sequence, atomic_read(&isp->asd.sequence_temp));\n\n\tif ((irq_infos & IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR) ||\n\t    (irq_infos & IA_CSS_IRQ_INFO_IF_ERROR)) {\n\t\t \n\t\tu32 rx_infos;\n\t\tenum mipi_port_id port;\n\n\t\tfor (port = MIPI_PORT0_ID; port <= MIPI_PORT2_ID;\n\t\t     port++) {\n\t\t\tprint_csi_rx_errors(port, isp);\n\t\t\tatomisp_css_rx_get_irq_info(port, &rx_infos);\n\t\t\tatomisp_css_rx_clear_irq_info(port, rx_infos);\n\t\t}\n\t}\n\n\tif (irq_infos & IA_CSS_IRQ_INFO_ISYS_EVENTS_READY) {\n\t\twhile (ia_css_dequeue_isys_event(&eof_event.event) == 0) {\n\t\t\tatomisp_eof_event(&isp->asd, eof_event.event.exp_id);\n\t\t\tdev_dbg_ratelimited(isp->dev, \"ISYS event: EOF exp_id %d\\n\",\n\t\t\t\t\t    eof_event.event.exp_id);\n\t\t}\n\n\t\tirq_infos &= ~IA_CSS_IRQ_INFO_ISYS_EVENTS_READY;\n\t\tif (irq_infos == 0)\n\t\t\tgoto out_nowake;\n\t}\n\n\tspin_unlock_irqrestore(&isp->lock, flags);\n\n\tdev_dbg_ratelimited(isp->dev, \"irq:0x%x (unhandled)\\n\", irq_infos);\n\n\treturn IRQ_WAKE_THREAD;\n\nout_nowake:\n\tspin_unlock_irqrestore(&isp->lock, flags);\n\n\tif (irq_infos)\n\t\tdev_dbg_ratelimited(isp->dev, \"irq:0x%x (ignored, as not streaming anymore)\\n\",\n\t\t\t\t    irq_infos);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid atomisp_clear_css_buffer_counters(struct atomisp_sub_device *asd)\n{\n\tint i;\n\n\tmemset(asd->s3a_bufs_in_css, 0, sizeof(asd->s3a_bufs_in_css));\n\tfor (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++)\n\t\tmemset(asd->metadata_bufs_in_css[i], 0,\n\t\t       sizeof(asd->metadata_bufs_in_css[i]));\n\tasd->dis_bufs_in_css = 0;\n}\n\n \n#define SP_DMEM_BASE\t0x100000\n\nvoid dump_sp_dmem(struct atomisp_device *isp, unsigned int addr,\n\t\t  unsigned int size)\n{\n\tunsigned int data = 0;\n\tunsigned int size32 = DIV_ROUND_UP(size, sizeof(u32));\n\n\tdev_dbg(isp->dev, \"atomisp mmio base: %p\\n\", isp->base);\n\tdev_dbg(isp->dev, \"%s, addr:0x%x, size: %d, size32: %d\\n\", __func__,\n\t\taddr, size, size32);\n\tif (size32 * 4 + addr > 0x4000) {\n\t\tdev_err(isp->dev, \"illegal size (%d) or addr (0x%x)\\n\",\n\t\t\tsize32, addr);\n\t\treturn;\n\t}\n\taddr += SP_DMEM_BASE;\n\taddr &= 0x003FFFFF;\n\tdo {\n\t\tdata = readl(isp->base + addr);\n\t\tdev_dbg(isp->dev, \"%s, \\t [0x%x]:0x%x\\n\", __func__, addr, data);\n\t\taddr += sizeof(u32);\n\t} while (--size32);\n}\n\nint atomisp_buffers_in_css(struct atomisp_video_pipe *pipe)\n{\n\tunsigned long irqflags;\n\tstruct list_head *pos;\n\tint buffers_in_css = 0;\n\n\tspin_lock_irqsave(&pipe->irq_lock, irqflags);\n\n\tlist_for_each(pos, &pipe->buffers_in_css)\n\t\tbuffers_in_css++;\n\n\tspin_unlock_irqrestore(&pipe->irq_lock, irqflags);\n\n\treturn buffers_in_css;\n}\n\nvoid atomisp_buffer_done(struct ia_css_frame *frame, enum vb2_buffer_state state)\n{\n\tstruct atomisp_video_pipe *pipe = vb_to_pipe(&frame->vb.vb2_buf);\n\n\tlockdep_assert_held(&pipe->irq_lock);\n\n\tframe->vb.vb2_buf.timestamp = ktime_get_ns();\n\tframe->vb.field = pipe->pix.field;\n\tframe->vb.sequence = atomic_read(&pipe->asd->sequence);\n\tlist_del(&frame->queue);\n\tif (state == VB2_BUF_STATE_DONE)\n\t\tvb2_set_plane_payload(&frame->vb.vb2_buf, 0, pipe->pix.sizeimage);\n\tvb2_buffer_done(&frame->vb.vb2_buf, state);\n}\n\nvoid atomisp_flush_video_pipe(struct atomisp_video_pipe *pipe, enum vb2_buffer_state state,\n\t\t\t      bool warn_on_css_frames)\n{\n\tstruct ia_css_frame *frame, *_frame;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&pipe->irq_lock, irqflags);\n\n\tlist_for_each_entry_safe(frame, _frame, &pipe->buffers_in_css, queue) {\n\t\tif (warn_on_css_frames)\n\t\t\tdev_warn(pipe->isp->dev, \"Warning: CSS frames queued on flush\\n\");\n\t\tatomisp_buffer_done(frame, state);\n\t}\n\n\tlist_for_each_entry_safe(frame, _frame, &pipe->activeq, queue)\n\t\tatomisp_buffer_done(frame, state);\n\n\tlist_for_each_entry_safe(frame, _frame, &pipe->buffers_waiting_for_param, queue) {\n\t\tpipe->frame_request_config_id[frame->vb.vb2_buf.index] = 0;\n\t\tatomisp_buffer_done(frame, state);\n\t}\n\n\tspin_unlock_irqrestore(&pipe->irq_lock, irqflags);\n}\n\n \nvoid atomisp_flush_params_queue(struct atomisp_video_pipe *pipe)\n{\n\tstruct atomisp_css_params_with_list *param;\n\n\twhile (!list_empty(&pipe->per_frame_params)) {\n\t\tparam = list_entry(pipe->per_frame_params.next,\n\t\t\t\t   struct atomisp_css_params_with_list, list);\n\t\tlist_del(&param->list);\n\t\tatomisp_free_css_parameters(&param->params);\n\t\tkvfree(param);\n\t}\n}\n\n \nstatic void atomisp_recover_params_queue(struct atomisp_video_pipe *pipe)\n{\n\tstruct atomisp_css_params_with_list *param;\n\tint i;\n\n\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\tparam = pipe->frame_params[i];\n\t\tif (param)\n\t\t\tlist_add_tail(&param->list, &pipe->per_frame_params);\n\t\tpipe->frame_params[i] = NULL;\n\t}\n\tatomisp_handle_parameter_and_buffer(pipe);\n}\n\nvoid atomisp_buf_done(struct atomisp_sub_device *asd, int error,\n\t\t      enum ia_css_buffer_type buf_type,\n\t\t      enum ia_css_pipe_id css_pipe_id,\n\t\t      bool q_buffers, enum atomisp_input_stream_id stream_id)\n{\n\tstruct atomisp_video_pipe *pipe = NULL;\n\tstruct atomisp_css_buffer buffer;\n\tbool requeue = false;\n\tunsigned long irqflags;\n\tstruct ia_css_frame *frame = NULL;\n\tstruct atomisp_s3a_buf *s3a_buf = NULL, *_s3a_buf_tmp, *s3a_iter;\n\tstruct atomisp_dis_buf *dis_buf = NULL, *_dis_buf_tmp, *dis_iter;\n\tstruct atomisp_metadata_buf *md_buf = NULL, *_md_buf_tmp, *md_iter;\n\tenum atomisp_metadata_type md_type;\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct v4l2_control ctrl;\n\tint i, err;\n\n\tlockdep_assert_held(&isp->mutex);\n\n\tif (\n\t    buf_type != IA_CSS_BUFFER_TYPE_METADATA &&\n\t    buf_type != IA_CSS_BUFFER_TYPE_3A_STATISTICS &&\n\t    buf_type != IA_CSS_BUFFER_TYPE_DIS_STATISTICS &&\n\t    buf_type != IA_CSS_BUFFER_TYPE_OUTPUT_FRAME &&\n\t    buf_type != IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME &&\n\t    buf_type != IA_CSS_BUFFER_TYPE_RAW_OUTPUT_FRAME &&\n\t    buf_type != IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME &&\n\t    buf_type != IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME) {\n\t\tdev_err(isp->dev, \"%s, unsupported buffer type: %d\\n\",\n\t\t\t__func__, buf_type);\n\t\treturn;\n\t}\n\n\tmemset(&buffer, 0, sizeof(struct atomisp_css_buffer));\n\tbuffer.css_buffer.type = buf_type;\n\terr = atomisp_css_dequeue_buffer(asd, stream_id, css_pipe_id,\n\t\t\t\t\t buf_type, &buffer);\n\tif (err) {\n\t\tdev_err(isp->dev,\n\t\t\t\"atomisp_css_dequeue_buffer failed: 0x%x\\n\", err);\n\t\treturn;\n\t}\n\n\tswitch (buf_type) {\n\tcase IA_CSS_BUFFER_TYPE_3A_STATISTICS:\n\t\tlist_for_each_entry_safe(s3a_iter, _s3a_buf_tmp,\n\t\t\t\t\t &asd->s3a_stats_in_css, list) {\n\t\t\tif (s3a_iter->s3a_data ==\n\t\t\t    buffer.css_buffer.data.stats_3a) {\n\t\t\t\tlist_del_init(&s3a_iter->list);\n\t\t\t\tlist_add_tail(&s3a_iter->list,\n\t\t\t\t\t      &asd->s3a_stats_ready);\n\t\t\t\ts3a_buf = s3a_iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tasd->s3a_bufs_in_css[css_pipe_id]--;\n\t\tatomisp_3a_stats_ready_event(asd, buffer.css_buffer.exp_id);\n\t\tif (s3a_buf)\n\t\t\tdev_dbg(isp->dev, \"%s: s3a stat with exp_id %d is ready\\n\",\n\t\t\t\t__func__, s3a_buf->s3a_data->exp_id);\n\t\telse\n\t\t\tdev_dbg(isp->dev, \"%s: s3a stat is ready with no exp_id found\\n\",\n\t\t\t\t__func__);\n\t\tbreak;\n\tcase IA_CSS_BUFFER_TYPE_METADATA:\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tmd_type = ATOMISP_MAIN_METADATA;\n\t\tlist_for_each_entry_safe(md_iter, _md_buf_tmp,\n\t\t\t\t\t &asd->metadata_in_css[md_type], list) {\n\t\t\tif (md_iter->metadata ==\n\t\t\t    buffer.css_buffer.data.metadata) {\n\t\t\t\tlist_del_init(&md_iter->list);\n\t\t\t\tlist_add_tail(&md_iter->list,\n\t\t\t\t\t      &asd->metadata_ready[md_type]);\n\t\t\t\tmd_buf = md_iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tasd->metadata_bufs_in_css[stream_id][css_pipe_id]--;\n\t\tatomisp_metadata_ready_event(asd, md_type);\n\t\tif (md_buf)\n\t\t\tdev_dbg(isp->dev, \"%s: metadata with exp_id %d is ready\\n\",\n\t\t\t\t__func__, md_buf->metadata->exp_id);\n\t\telse\n\t\t\tdev_dbg(isp->dev, \"%s: metadata is ready with no exp_id found\\n\",\n\t\t\t\t__func__);\n\t\tbreak;\n\tcase IA_CSS_BUFFER_TYPE_DIS_STATISTICS:\n\t\tlist_for_each_entry_safe(dis_iter, _dis_buf_tmp,\n\t\t\t\t\t &asd->dis_stats_in_css, list) {\n\t\t\tif (dis_iter->dis_data ==\n\t\t\t    buffer.css_buffer.data.stats_dvs) {\n\t\t\t\tspin_lock_irqsave(&asd->dis_stats_lock,\n\t\t\t\t\t\t  irqflags);\n\t\t\t\tlist_del_init(&dis_iter->list);\n\t\t\t\tlist_add(&dis_iter->list, &asd->dis_stats);\n\t\t\t\tasd->params.dis_proj_data_valid = true;\n\t\t\t\tspin_unlock_irqrestore(&asd->dis_stats_lock,\n\t\t\t\t\t\t       irqflags);\n\t\t\t\tdis_buf = dis_iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tasd->dis_bufs_in_css--;\n\t\tif (dis_buf)\n\t\t\tdev_dbg(isp->dev, \"%s: dis stat with exp_id %d is ready\\n\",\n\t\t\t\t__func__, dis_buf->dis_data->exp_id);\n\t\telse\n\t\t\tdev_dbg(isp->dev, \"%s: dis stat is ready with no exp_id found\\n\",\n\t\t\t\t__func__);\n\t\tbreak;\n\tcase IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:\n\tcase IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME:\n\t\tframe = buffer.css_buffer.data.frame;\n\t\tif (!frame) {\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tif (!frame->valid)\n\t\t\terror = true;\n\n\t\tpipe = vb_to_pipe(&frame->vb.vb2_buf);\n\n\t\tdev_dbg(isp->dev, \"%s: vf frame with exp_id %d is ready\\n\",\n\t\t\t__func__, frame->exp_id);\n\t\tif (asd->params.flash_state == ATOMISP_FLASH_ONGOING) {\n\t\t\tif (frame->flash_state\n\t\t\t    == IA_CSS_FRAME_FLASH_STATE_PARTIAL)\n\t\t\t\tdev_dbg(isp->dev, \"%s thumb partially flashed\\n\",\n\t\t\t\t\t__func__);\n\t\t\telse if (frame->flash_state\n\t\t\t\t == IA_CSS_FRAME_FLASH_STATE_FULL)\n\t\t\t\tdev_dbg(isp->dev, \"%s thumb completely flashed\\n\",\n\t\t\t\t\t__func__);\n\t\t\telse\n\t\t\t\tdev_dbg(isp->dev, \"%s thumb no flash in this frame\\n\",\n\t\t\t\t\t__func__);\n\t\t}\n\t\tpipe->frame_config_id[frame->vb.vb2_buf.index] = frame->isp_config_id;\n\t\tbreak;\n\tcase IA_CSS_BUFFER_TYPE_OUTPUT_FRAME:\n\tcase IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME:\n\t\tframe = buffer.css_buffer.data.frame;\n\t\tif (!frame) {\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!frame->valid)\n\t\t\terror = true;\n\n\t\tpipe = vb_to_pipe(&frame->vb.vb2_buf);\n\n\t\tdev_dbg(isp->dev, \"%s: main frame with exp_id %d is ready\\n\",\n\t\t\t__func__, frame->exp_id);\n\n\t\ti = frame->vb.vb2_buf.index;\n\n\t\t \n\t\tif (pipe->frame_params[i]) {\n\t\t\tif (asd->params.dvs_6axis == pipe->frame_params[i]->params.dvs_6axis)\n\t\t\t\tasd->params.dvs_6axis = NULL;\n\t\t\tatomisp_free_css_parameters(&pipe->frame_params[i]->params);\n\t\t\tkvfree(pipe->frame_params[i]);\n\t\t\tpipe->frame_params[i] = NULL;\n\t\t}\n\n\t\tpipe->frame_config_id[i] = frame->isp_config_id;\n\t\tctrl.id = V4L2_CID_FLASH_MODE;\n\t\tif (asd->params.flash_state == ATOMISP_FLASH_ONGOING) {\n\t\t\tif (frame->flash_state == IA_CSS_FRAME_FLASH_STATE_PARTIAL) {\n\t\t\t\tasd->frame_status[i] = ATOMISP_FRAME_STATUS_FLASH_PARTIAL;\n\t\t\t\tdev_dbg(isp->dev, \"%s partially flashed\\n\", __func__);\n\t\t\t} else if (frame->flash_state == IA_CSS_FRAME_FLASH_STATE_FULL) {\n\t\t\t\tasd->frame_status[i] = ATOMISP_FRAME_STATUS_FLASH_EXPOSED;\n\t\t\t\tasd->params.num_flash_frames--;\n\t\t\t\tdev_dbg(isp->dev, \"%s completely flashed\\n\", __func__);\n\t\t\t} else {\n\t\t\t\tasd->frame_status[i] = ATOMISP_FRAME_STATUS_OK;\n\t\t\t\tdev_dbg(isp->dev, \"%s no flash in this frame\\n\", __func__);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (asd->frame_status[i] == ATOMISP_FRAME_STATUS_FLASH_EXPOSED)\n\t\t\t\tasd->params.flash_state = ATOMISP_FLASH_DONE;\n\t\t} else if (isp->flash) {\n\t\t\tif (v4l2_g_ctrl(isp->flash->ctrl_handler, &ctrl) == 0 &&\n\t\t\t    ctrl.value == ATOMISP_FLASH_MODE_TORCH) {\n\t\t\t\tctrl.id = V4L2_CID_FLASH_TORCH_INTENSITY;\n\t\t\t\tif (v4l2_g_ctrl(isp->flash->ctrl_handler, &ctrl) == 0 &&\n\t\t\t\t    ctrl.value > 0)\n\t\t\t\t\tasd->frame_status[i] = ATOMISP_FRAME_STATUS_FLASH_EXPOSED;\n\t\t\t\telse\n\t\t\t\t\tasd->frame_status[i] = ATOMISP_FRAME_STATUS_OK;\n\t\t\t} else {\n\t\t\t\tasd->frame_status[i] = ATOMISP_FRAME_STATUS_OK;\n\t\t\t}\n\t\t} else {\n\t\t\tasd->frame_status[i] = ATOMISP_FRAME_STATUS_OK;\n\t\t}\n\n\t\tasd->params.last_frame_status = asd->frame_status[i];\n\n\t\tif (asd->params.css_update_params_needed) {\n\t\t\tatomisp_apply_css_parameters(asd,\n\t\t\t\t\t\t     &asd->params.css_param);\n\t\t\tif (asd->params.css_param.update_flag.dz_config)\n\t\t\t\tasd->params.config.dz_config = &asd->params.css_param.dz_config;\n\t\t\t \n\t\t\tif (asd->params.dvs_6axis)\n\t\t\t\tatomisp_css_set_dvs_6axis(asd,\n\t\t\t\t\t\t\t  asd->params.dvs_6axis);\n\t\t\telse\n\t\t\t\tasd->params.css_update_params_needed = false;\n\t\t\t \n\t\t\tatomisp_css_update_isp_params(asd);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (frame) {\n\t\tspin_lock_irqsave(&pipe->irq_lock, irqflags);\n\t\tatomisp_buffer_done(frame, error ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\t\tspin_unlock_irqrestore(&pipe->irq_lock, irqflags);\n\t}\n\n\t \n\tif (requeue) {\n\t\terr = atomisp_css_queue_buffer(asd,\n\t\t\t\t\t       stream_id, css_pipe_id,\n\t\t\t\t\t       buf_type, &buffer);\n\t\tif (err)\n\t\t\tdev_err(isp->dev, \"%s, q to css fails: %d\\n\",\n\t\t\t\t__func__, err);\n\t\treturn;\n\t}\n\tif (!error && q_buffers)\n\t\tatomisp_qbuffers_to_css(asd);\n}\n\nvoid atomisp_assert_recovery_work(struct work_struct *work)\n{\n\tstruct atomisp_device *isp = container_of(work, struct atomisp_device,\n\t\t\t\t\t\t  assert_recovery_work);\n\tstruct pci_dev *pdev = to_pci_dev(isp->dev);\n\tunsigned long flags;\n\tint ret;\n\n\tmutex_lock(&isp->mutex);\n\n\tif (!isp->asd.streaming)\n\t\tgoto out_unlock;\n\n\tatomisp_css_irq_enable(isp, IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF, false);\n\n\tspin_lock_irqsave(&isp->lock, flags);\n\tisp->asd.streaming = false;\n\tspin_unlock_irqrestore(&isp->lock, flags);\n\n\t \n\tret = v4l2_subdev_call(isp->inputs[isp->asd.input_curr].camera, video, s_stream, 0);\n\tif (ret)\n\t\tdev_warn(isp->dev, \"Stopping sensor stream failed: %d\\n\", ret);\n\n\tatomisp_clear_css_buffer_counters(&isp->asd);\n\n\tatomisp_css_stop(&isp->asd, true);\n\n\tisp->asd.preview_exp_id = 1;\n\tisp->asd.postview_exp_id = 1;\n\t \n\tdev_dbg(isp->dev, \"send reset event to %s\\n\", isp->asd.subdev.devnode->name);\n\tatomisp_reset_event(&isp->asd);\n\n\t \n\tdisable_isp_irq(hrt_isp_css_irq_sp);\n\tclear_isp_irq(hrt_isp_css_irq_sp);\n\n\t \n\tpci_write_config_dword(pdev, PCI_I_CONTROL,\n\t\t\t       isp->saved_regs.i_control | MRFLD_PCI_I_CONTROL_SRSE_RESET_MASK);\n\n\t \n\tatomisp_reset(isp);\n\n\tatomisp_css_input_set_mode(&isp->asd, IA_CSS_INPUT_MODE_BUFFERED_SENSOR);\n\n\t \n\tatomisp_create_pipes_stream(&isp->asd);\n\n\t \n\twbinvd();\n\n\tif (atomisp_css_start(&isp->asd)) {\n\t\tdev_warn(isp->dev, \"start SP failed, so do not set streaming to be enable!\\n\");\n\t} else {\n\t\tspin_lock_irqsave(&isp->lock, flags);\n\t\tisp->asd.streaming = true;\n\t\tspin_unlock_irqrestore(&isp->lock, flags);\n\t}\n\n\tatomisp_csi2_configure(&isp->asd);\n\n\tatomisp_css_irq_enable(isp, IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF,\n\t\t\t       atomisp_css_valid_sof(isp));\n\n\tif (atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_AUTO, true) < 0)\n\t\tdev_dbg(isp->dev, \"DFS auto failed while recovering!\\n\");\n\n\t \n\tatomisp_flush_video_pipe(&isp->asd.video_out, VB2_BUF_STATE_ERROR, false);\n\n\t \n\tatomisp_recover_params_queue(&isp->asd.video_out);\n\n\tret = v4l2_subdev_call(isp->inputs[isp->asd.input_curr].camera, video, s_stream, 1);\n\tif (ret)\n\t\tdev_err(isp->dev, \"Starting sensor stream failed: %d\\n\", ret);\n\nout_unlock:\n\tmutex_unlock(&isp->mutex);\n}\n\nvoid atomisp_setup_flash(struct atomisp_sub_device *asd)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct v4l2_control ctrl;\n\n\tif (!isp->flash)\n\t\treturn;\n\n\tif (asd->params.flash_state != ATOMISP_FLASH_REQUESTED &&\n\t    asd->params.flash_state != ATOMISP_FLASH_DONE)\n\t\treturn;\n\n\tif (asd->params.num_flash_frames) {\n\t\t \n\t\tctrl.id = V4L2_CID_FLASH_TIMEOUT;\n\t\tctrl.value = FLASH_TIMEOUT;\n\n\t\tif (v4l2_s_ctrl(NULL, isp->flash->ctrl_handler, &ctrl)) {\n\t\t\tdev_err(isp->dev, \"flash timeout configure failed\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tia_css_stream_request_flash(asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream);\n\n\t\tasd->params.flash_state = ATOMISP_FLASH_ONGOING;\n\t} else {\n\t\tasd->params.flash_state = ATOMISP_FLASH_IDLE;\n\t}\n}\n\nirqreturn_t atomisp_isr_thread(int irq, void *isp_ptr)\n{\n\tstruct atomisp_device *isp = isp_ptr;\n\tunsigned long flags;\n\n\tdev_dbg(isp->dev, \">%s\\n\", __func__);\n\n\tspin_lock_irqsave(&isp->lock, flags);\n\n\tif (!isp->asd.streaming) {\n\t\tspin_unlock_irqrestore(&isp->lock, flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_unlock_irqrestore(&isp->lock, flags);\n\n\t \n\tmutex_lock(&isp->mutex);\n\tif (atomisp_css_isr_thread(isp))\n\t\tgoto out;\n\n\tif (isp->asd.streaming)\n\t\tatomisp_setup_flash(&isp->asd);\nout:\n\tmutex_unlock(&isp->mutex);\n\tdev_dbg(isp->dev, \"<%s\\n\", __func__);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic enum ia_css_frame_format\nv4l2_fmt_to_sh_fmt(u32 fmt)\n{\n\tswitch (fmt) {\n\tcase V4L2_PIX_FMT_YUV420:\n\t\t\t\treturn IA_CSS_FRAME_FORMAT_YUV420;\n\tcase V4L2_PIX_FMT_YVU420:\n\t\treturn IA_CSS_FRAME_FORMAT_YV12;\n\tcase V4L2_PIX_FMT_YUV422P:\n\t\treturn IA_CSS_FRAME_FORMAT_YUV422;\n\tcase V4L2_PIX_FMT_YUV444:\n\t\treturn IA_CSS_FRAME_FORMAT_YUV444;\n\tcase V4L2_PIX_FMT_NV12:\n\t\treturn IA_CSS_FRAME_FORMAT_NV12;\n\tcase V4L2_PIX_FMT_NV21:\n\t\treturn IA_CSS_FRAME_FORMAT_NV21;\n\tcase V4L2_PIX_FMT_NV16:\n\t\treturn IA_CSS_FRAME_FORMAT_NV16;\n\tcase V4L2_PIX_FMT_NV61:\n\t\treturn IA_CSS_FRAME_FORMAT_NV61;\n\tcase V4L2_PIX_FMT_UYVY:\n\t\treturn IA_CSS_FRAME_FORMAT_UYVY;\n\tcase V4L2_PIX_FMT_YUYV:\n\t\treturn IA_CSS_FRAME_FORMAT_YUYV;\n\tcase V4L2_PIX_FMT_RGB24:\n\t\treturn IA_CSS_FRAME_FORMAT_PLANAR_RGB888;\n\tcase V4L2_PIX_FMT_RGB32:\n\t\treturn IA_CSS_FRAME_FORMAT_RGBA888;\n\tcase V4L2_PIX_FMT_RGB565:\n\t\treturn IA_CSS_FRAME_FORMAT_RGB565;\n#if 0\n\tcase V4L2_PIX_FMT_JPEG:\n\tcase V4L2_PIX_FMT_CUSTOM_M10MO_RAW:\n\t\treturn IA_CSS_FRAME_FORMAT_BINARY_8;\n#endif\n\tcase V4L2_PIX_FMT_SBGGR16:\n\tcase V4L2_PIX_FMT_SBGGR10:\n\tcase V4L2_PIX_FMT_SGBRG10:\n\tcase V4L2_PIX_FMT_SGRBG10:\n\tcase V4L2_PIX_FMT_SRGGB10:\n\tcase V4L2_PIX_FMT_SBGGR12:\n\tcase V4L2_PIX_FMT_SGBRG12:\n\tcase V4L2_PIX_FMT_SGRBG12:\n\tcase V4L2_PIX_FMT_SRGGB12:\n\tcase V4L2_PIX_FMT_SBGGR8:\n\tcase V4L2_PIX_FMT_SGBRG8:\n\tcase V4L2_PIX_FMT_SGRBG8:\n\tcase V4L2_PIX_FMT_SRGGB8:\n\t\treturn IA_CSS_FRAME_FORMAT_RAW;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int raw_output_format_match_input(u32 input, u32 output)\n{\n\tif ((input == ATOMISP_INPUT_FORMAT_RAW_12) &&\n\t    ((output == V4L2_PIX_FMT_SRGGB12) ||\n\t     (output == V4L2_PIX_FMT_SGRBG12) ||\n\t     (output == V4L2_PIX_FMT_SBGGR12) ||\n\t     (output == V4L2_PIX_FMT_SGBRG12)))\n\t\treturn 0;\n\n\tif ((input == ATOMISP_INPUT_FORMAT_RAW_10) &&\n\t    ((output == V4L2_PIX_FMT_SRGGB10) ||\n\t     (output == V4L2_PIX_FMT_SGRBG10) ||\n\t     (output == V4L2_PIX_FMT_SBGGR10) ||\n\t     (output == V4L2_PIX_FMT_SGBRG10)))\n\t\treturn 0;\n\n\tif ((input == ATOMISP_INPUT_FORMAT_RAW_8) &&\n\t    ((output == V4L2_PIX_FMT_SRGGB8) ||\n\t     (output == V4L2_PIX_FMT_SGRBG8) ||\n\t     (output == V4L2_PIX_FMT_SBGGR8) ||\n\t     (output == V4L2_PIX_FMT_SGBRG8)))\n\t\treturn 0;\n\n\tif ((input == ATOMISP_INPUT_FORMAT_RAW_16) && (output == V4L2_PIX_FMT_SBGGR16))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nu32 atomisp_get_pixel_depth(u32 pixelformat)\n{\n\tswitch (pixelformat) {\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\tcase V4L2_PIX_FMT_YVU420:\n\t\treturn 12;\n\tcase V4L2_PIX_FMT_YUV422P:\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\tcase V4L2_PIX_FMT_RGB565:\n\tcase V4L2_PIX_FMT_SBGGR16:\n\tcase V4L2_PIX_FMT_SBGGR12:\n\tcase V4L2_PIX_FMT_SGBRG12:\n\tcase V4L2_PIX_FMT_SGRBG12:\n\tcase V4L2_PIX_FMT_SRGGB12:\n\tcase V4L2_PIX_FMT_SBGGR10:\n\tcase V4L2_PIX_FMT_SGBRG10:\n\tcase V4L2_PIX_FMT_SGRBG10:\n\tcase V4L2_PIX_FMT_SRGGB10:\n\t\treturn 16;\n\tcase V4L2_PIX_FMT_RGB24:\n\tcase V4L2_PIX_FMT_YUV444:\n\t\treturn 24;\n\tcase V4L2_PIX_FMT_RGB32:\n\t\treturn 32;\n\tcase V4L2_PIX_FMT_JPEG:\n\tcase V4L2_PIX_FMT_CUSTOM_M10MO_RAW:\n\tcase V4L2_PIX_FMT_SBGGR8:\n\tcase V4L2_PIX_FMT_SGBRG8:\n\tcase V4L2_PIX_FMT_SGRBG8:\n\tcase V4L2_PIX_FMT_SRGGB8:\n\t\treturn 8;\n\tdefault:\n\t\treturn 8 * 2;\t \n\t}\n}\n\nbool atomisp_is_mbuscode_raw(uint32_t code)\n{\n\treturn code >= 0x3000 && code < 0x4000;\n}\n\n \n\n \nstatic void atomisp_update_capture_mode(struct atomisp_sub_device *asd)\n{\n\tif (asd->params.gdc_cac_en)\n\t\tatomisp_css_capture_set_mode(asd, IA_CSS_CAPTURE_MODE_ADVANCED);\n\telse if (asd->params.low_light)\n\t\tatomisp_css_capture_set_mode(asd, IA_CSS_CAPTURE_MODE_LOW_LIGHT);\n\telse if (asd->video_out.sh_fmt == IA_CSS_FRAME_FORMAT_RAW)\n\t\tatomisp_css_capture_set_mode(asd, IA_CSS_CAPTURE_MODE_RAW);\n\telse\n\t\tatomisp_css_capture_set_mode(asd, IA_CSS_CAPTURE_MODE_PRIMARY);\n}\n\n \nint atomisp_set_sensor_runmode(struct atomisp_sub_device *asd,\n\t\t\t       struct atomisp_s_runmode *runmode)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct v4l2_ctrl *c;\n\tint ret = 0;\n\n\tif (!(runmode && (runmode->mode & RUNMODE_MASK)))\n\t\treturn -EINVAL;\n\n\tmutex_lock(asd->ctrl_handler.lock);\n\tc = v4l2_ctrl_find(isp->inputs[asd->input_curr].camera->ctrl_handler,\n\t\t\t   V4L2_CID_RUN_MODE);\n\n\tif (c)\n\t\tret = v4l2_ctrl_s_ctrl(c, runmode->mode);\n\n\tmutex_unlock(asd->ctrl_handler.lock);\n\treturn ret;\n}\n\n \nint atomisp_gdc_cac(struct atomisp_sub_device *asd, int flag,\n\t\t    __s32 *value)\n{\n\tif (flag == 0) {\n\t\t*value = asd->params.gdc_cac_en;\n\t\treturn 0;\n\t}\n\n\tasd->params.gdc_cac_en = !!*value;\n\tif (asd->params.gdc_cac_en) {\n\t\tasd->params.config.morph_table = asd->params.css_param.morph_table;\n\t} else {\n\t\tasd->params.config.morph_table = NULL;\n\t}\n\tasd->params.css_update_params_needed = true;\n\tatomisp_update_capture_mode(asd);\n\treturn 0;\n}\n\n \nint atomisp_low_light(struct atomisp_sub_device *asd, int flag,\n\t\t      __s32 *value)\n{\n\tif (flag == 0) {\n\t\t*value = asd->params.low_light;\n\t\treturn 0;\n\t}\n\n\tasd->params.low_light = (*value != 0);\n\tatomisp_update_capture_mode(asd);\n\treturn 0;\n}\n\n \nint atomisp_xnr(struct atomisp_sub_device *asd, int flag,\n\t\tint *xnr_enable)\n{\n\tif (flag == 0) {\n\t\t*xnr_enable = asd->params.xnr_en;\n\t\treturn 0;\n\t}\n\n\tatomisp_css_capture_enable_xnr(asd, !!*xnr_enable);\n\n\treturn 0;\n}\n\n \nint atomisp_nr(struct atomisp_sub_device *asd, int flag,\n\t       struct atomisp_nr_config *arg)\n{\n\tif (flag == 0) {\n\t\t \n\t\tif (atomisp_css_get_nr_config(asd, arg))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tmemcpy(&asd->params.css_param.nr_config, arg,\n\t\t       sizeof(struct ia_css_nr_config));\n\t\tasd->params.config.nr_config = &asd->params.css_param.nr_config;\n\t\tasd->params.css_update_params_needed = true;\n\t}\n\treturn 0;\n}\n\n \nint atomisp_tnr(struct atomisp_sub_device *asd, int flag,\n\t\tstruct atomisp_tnr_config *config)\n{\n\t \n\tif (flag == 0) {\n\t\t \n\t\tif (atomisp_css_get_tnr_config(asd, config))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tmemcpy(&asd->params.css_param.tnr_config, config,\n\t\t       sizeof(struct ia_css_tnr_config));\n\t\tasd->params.config.tnr_config = &asd->params.css_param.tnr_config;\n\t\tasd->params.css_update_params_needed = true;\n\t}\n\n\treturn 0;\n}\n\n \nint atomisp_black_level(struct atomisp_sub_device *asd, int flag,\n\t\t\tstruct atomisp_ob_config *config)\n{\n\tif (flag == 0) {\n\t\t \n\t\tif (atomisp_css_get_ob_config(asd, config))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tmemcpy(&asd->params.css_param.ob_config, config,\n\t\t       sizeof(struct ia_css_ob_config));\n\t\tasd->params.config.ob_config = &asd->params.css_param.ob_config;\n\t\tasd->params.css_update_params_needed = true;\n\t}\n\n\treturn 0;\n}\n\n \nint atomisp_ee(struct atomisp_sub_device *asd, int flag,\n\t       struct atomisp_ee_config *config)\n{\n\tif (flag == 0) {\n\t\t \n\t\tif (atomisp_css_get_ee_config(asd, config))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tmemcpy(&asd->params.css_param.ee_config, config,\n\t\t       sizeof(asd->params.css_param.ee_config));\n\t\tasd->params.config.ee_config = &asd->params.css_param.ee_config;\n\t\tasd->params.css_update_params_needed = true;\n\t}\n\n\treturn 0;\n}\n\n \nint atomisp_gamma(struct atomisp_sub_device *asd, int flag,\n\t\t  struct atomisp_gamma_table *config)\n{\n\tif (flag == 0) {\n\t\t \n\t\tif (atomisp_css_get_gamma_table(asd, config))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tmemcpy(&asd->params.css_param.gamma_table, config,\n\t\t       sizeof(asd->params.css_param.gamma_table));\n\t\tasd->params.config.gamma_table = &asd->params.css_param.gamma_table;\n\t}\n\n\treturn 0;\n}\n\n \nint atomisp_ctc(struct atomisp_sub_device *asd, int flag,\n\t\tstruct atomisp_ctc_table *config)\n{\n\tif (flag == 0) {\n\t\t \n\t\tif (atomisp_css_get_ctc_table(asd, config))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tmemcpy(&asd->params.css_param.ctc_table, config,\n\t\t       sizeof(asd->params.css_param.ctc_table));\n\t\tatomisp_css_set_ctc_table(asd, &asd->params.css_param.ctc_table);\n\t}\n\n\treturn 0;\n}\n\n \nint atomisp_gamma_correction(struct atomisp_sub_device *asd, int flag,\n\t\t\t     struct atomisp_gc_config *config)\n{\n\tif (flag == 0) {\n\t\t \n\t\tif (atomisp_css_get_gc_config(asd, config))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tmemcpy(&asd->params.css_param.gc_config, config,\n\t\t       sizeof(asd->params.css_param.gc_config));\n\t\tasd->params.config.gc_config = &asd->params.css_param.gc_config;\n\t\tasd->params.css_update_params_needed = true;\n\t}\n\n\treturn 0;\n}\n\n \nint atomisp_formats(struct atomisp_sub_device *asd, int flag,\n\t\t    struct atomisp_formats_config *config)\n{\n\tif (flag == 0) {\n\t\t \n\t\tif (atomisp_css_get_formats_config(asd, config))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tmemcpy(&asd->params.css_param.formats_config, config,\n\t\t       sizeof(asd->params.css_param.formats_config));\n\t\tasd->params.config.formats_config = &asd->params.css_param.formats_config;\n\t}\n\n\treturn 0;\n}\n\nvoid atomisp_free_internal_buffers(struct atomisp_sub_device *asd)\n{\n\tatomisp_free_css_parameters(&asd->params.css_param);\n}\n\nstatic void atomisp_update_grid_info(struct atomisp_sub_device *asd,\n\t\t\t\t     enum ia_css_pipe_id pipe_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tint err;\n\n\tif (atomisp_css_get_grid_info(asd, pipe_id))\n\t\treturn;\n\n\t \n\tatomisp_css_free_stat_buffers(asd);\n\n\terr = atomisp_alloc_css_stat_bufs(asd, ATOMISP_INPUT_STREAM_GENERAL);\n\tif (err) {\n\t\tdev_err(isp->dev, \"stat_buf allocate error\\n\");\n\t\tgoto err;\n\t}\n\n\tif (atomisp_alloc_3a_output_buf(asd)) {\n\t\t \n\t\tif (asd->params.s3a_output_bytes != 0) {\n\t\t\t \n\t\t\tdev_err(isp->dev, \"Failed to allocate memory for 3A statistics\\n\");\n\t\t}\n\t\tgoto err;\n\t}\n\n\tif (atomisp_alloc_dis_coef_buf(asd)) {\n\t\tdev_err(isp->dev,\n\t\t\t\"Failed to allocate memory for DIS statistics\\n\");\n\t\tgoto err;\n\t}\n\n\tif (atomisp_alloc_metadata_output_buf(asd)) {\n\t\tdev_err(isp->dev, \"Failed to allocate memory for metadata\\n\");\n\t\tgoto err;\n\t}\n\n\treturn;\n\nerr:\n\tatomisp_css_free_stat_buffers(asd);\n\treturn;\n}\n\nstatic void atomisp_curr_user_grid_info(struct atomisp_sub_device *asd,\n\t\t\t\t\tstruct atomisp_grid_info *info)\n{\n\tmemcpy(info, &asd->params.curr_grid_info.s3a_grid,\n\t       sizeof(struct ia_css_3a_grid_info));\n}\n\nint atomisp_compare_grid(struct atomisp_sub_device *asd,\n\t\t\t struct atomisp_grid_info *atomgrid)\n{\n\tstruct atomisp_grid_info tmp = {0};\n\n\tatomisp_curr_user_grid_info(asd, &tmp);\n\treturn memcmp(atomgrid, &tmp, sizeof(tmp));\n}\n\n \nint atomisp_gdc_cac_table(struct atomisp_sub_device *asd, int flag,\n\t\t\t  struct atomisp_morph_table *config)\n{\n\tint ret;\n\tint i;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (flag == 0) {\n\t\t \n\t\tstruct ia_css_morph_table tab = {0};\n\n\t\tatomisp_css_get_morph_table(asd, &tab);\n\n\t\tconfig->width = tab.width;\n\t\tconfig->height = tab.height;\n\n\t\tfor (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {\n\t\t\tret = copy_to_user(config->coordinates_x[i],\n\t\t\t\t\t   tab.coordinates_x[i], tab.height *\n\t\t\t\t\t   tab.width * sizeof(*tab.coordinates_x[i]));\n\t\t\tif (ret) {\n\t\t\t\tdev_err(isp->dev,\n\t\t\t\t\t\"Failed to copy to User for x\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tret = copy_to_user(config->coordinates_y[i],\n\t\t\t\t\t   tab.coordinates_y[i], tab.height *\n\t\t\t\t\t   tab.width * sizeof(*tab.coordinates_y[i]));\n\t\t\tif (ret) {\n\t\t\t\tdev_err(isp->dev,\n\t\t\t\t\t\"Failed to copy to User for y\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct ia_css_morph_table *tab =\n\t\t\t    asd->params.css_param.morph_table;\n\n\t\t \n\t\tif (tab) {\n\t\t\tatomisp_css_morph_table_free(tab);\n\t\t\tasd->params.css_param.morph_table = NULL;\n\t\t}\n\n\t\t \n\t\ttab = atomisp_css_morph_table_allocate(config->width,\n\t\t\t\t\t\t       config->height);\n\n\t\tif (!tab) {\n\t\t\tdev_err(isp->dev, \"out of memory\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {\n\t\t\tret = copy_from_user(tab->coordinates_x[i],\n\t\t\t\t\t     config->coordinates_x[i],\n\t\t\t\t\t     config->height * config->width *\n\t\t\t\t\t     sizeof(*config->coordinates_x[i]));\n\t\t\tif (ret) {\n\t\t\t\tdev_err(isp->dev,\n\t\t\t\t\t\"Failed to copy from User for x, ret %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tatomisp_css_morph_table_free(tab);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tret = copy_from_user(tab->coordinates_y[i],\n\t\t\t\t\t     config->coordinates_y[i],\n\t\t\t\t\t     config->height * config->width *\n\t\t\t\t\t     sizeof(*config->coordinates_y[i]));\n\t\t\tif (ret) {\n\t\t\t\tdev_err(isp->dev,\n\t\t\t\t\t\"Failed to copy from User for y, ret is %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tatomisp_css_morph_table_free(tab);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t\tasd->params.css_param.morph_table = tab;\n\t\tif (asd->params.gdc_cac_en)\n\t\t\tasd->params.config.morph_table = tab;\n\t}\n\n\treturn 0;\n}\n\nint atomisp_macc_table(struct atomisp_sub_device *asd, int flag,\n\t\t       struct atomisp_macc_config *config)\n{\n\tstruct ia_css_macc_table *macc_table;\n\n\tswitch (config->color_effect) {\n\tcase V4L2_COLORFX_NONE:\n\t\tmacc_table = &asd->params.css_param.macc_table;\n\t\tbreak;\n\tcase V4L2_COLORFX_SKY_BLUE:\n\t\tmacc_table = &blue_macc_table;\n\t\tbreak;\n\tcase V4L2_COLORFX_GRASS_GREEN:\n\t\tmacc_table = &green_macc_table;\n\t\tbreak;\n\tcase V4L2_COLORFX_SKIN_WHITEN_LOW:\n\t\tmacc_table = &skin_low_macc_table;\n\t\tbreak;\n\tcase V4L2_COLORFX_SKIN_WHITEN:\n\t\tmacc_table = &skin_medium_macc_table;\n\t\tbreak;\n\tcase V4L2_COLORFX_SKIN_WHITEN_HIGH:\n\t\tmacc_table = &skin_high_macc_table;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (flag == 0) {\n\t\t \n\t\tmemcpy(&config->table, macc_table,\n\t\t       sizeof(struct ia_css_macc_table));\n\t} else {\n\t\tmemcpy(macc_table, &config->table,\n\t\t       sizeof(struct ia_css_macc_table));\n\t\tif (config->color_effect == asd->params.color_effect)\n\t\t\tasd->params.config.macc_table = macc_table;\n\t}\n\n\treturn 0;\n}\n\nint atomisp_set_dis_vector(struct atomisp_sub_device *asd,\n\t\t\t   struct atomisp_dis_vector *vector)\n{\n\tatomisp_css_video_set_dis_vector(asd, vector);\n\n\tasd->params.dis_proj_data_valid = false;\n\tasd->params.css_update_params_needed = true;\n\treturn 0;\n}\n\n \nint atomisp_get_dis_stat(struct atomisp_sub_device *asd,\n\t\t\t struct atomisp_dis_statistics *stats)\n{\n\treturn atomisp_css_get_dis_stat(asd, stats);\n}\n\n \nint atomisp_set_array_res(struct atomisp_sub_device *asd,\n\t\t\t  struct atomisp_resolution  *config)\n{\n\tdev_dbg(asd->isp->dev, \">%s start\\n\", __func__);\n\tif (!config) {\n\t\tdev_err(asd->isp->dev, \"Set sensor array size is not valid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tasd->sensor_array_res.width = config->width;\n\tasd->sensor_array_res.height = config->height;\n\treturn 0;\n}\n\n \nint atomisp_get_dvs2_bq_resolutions(struct atomisp_sub_device *asd,\n\t\t\t\t    struct atomisp_dvs2_bq_resolutions *bq_res)\n{\n\tstruct ia_css_pipe_config *pipe_cfg = NULL;\n\n\tstruct ia_css_stream *stream =\n\t\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream;\n\tif (!stream) {\n\t\tdev_warn(asd->isp->dev, \"stream is not created\");\n\t\treturn -EAGAIN;\n\t}\n\n\tpipe_cfg = &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t\t   .pipe_configs[IA_CSS_PIPE_ID_VIDEO];\n\n\tif (!bq_res)\n\t\treturn -EINVAL;\n\n\t \n\tbq_res->output_bq.width_bq = pipe_cfg->output_info[0].res.width / 2;\n\tbq_res->output_bq.height_bq = pipe_cfg->output_info[0].res.height / 2;\n\n\tbq_res->envelope_bq.width_bq = 0;\n\tbq_res->envelope_bq.height_bq = 0;\n\t \n\tbq_res->source_bq.width_bq = bq_res->output_bq.width_bq +\n\t\t\t\t     pipe_cfg->dvs_envelope.width / 2;\n\tbq_res->source_bq.height_bq = bq_res->output_bq.height_bq +\n\t\t\t\t      pipe_cfg->dvs_envelope.height / 2;\n\t \n\tbq_res->ispfilter_bq.width_bq = 12 / 2;\n\tbq_res->ispfilter_bq.height_bq = 12 / 2;\n\t \n\tbq_res->gdc_shift_bq.width_bq = 4 / 2;\n\tbq_res->gdc_shift_bq.height_bq = 4 / 2;\n\n\tif (asd->params.video_dis_en) {\n\t\tbq_res->envelope_bq.width_bq = pipe_cfg->dvs_envelope.width / 2 -\n\t\t\t\t\t       bq_res->ispfilter_bq.width_bq;\n\t\tbq_res->envelope_bq.height_bq = pipe_cfg->dvs_envelope.height / 2 -\n\t\t\t\t\t\tbq_res->ispfilter_bq.height_bq;\n\t}\n\n\tdev_dbg(asd->isp->dev,\n\t\t\"source_bq.width_bq %d, source_bq.height_bq %d,\\nispfilter_bq.width_bq %d, ispfilter_bq.height_bq %d,\\ngdc_shift_bq.width_bq %d, gdc_shift_bq.height_bq %d,\\nenvelope_bq.width_bq %d, envelope_bq.height_bq %d,\\noutput_bq.width_bq %d, output_bq.height_bq %d\\n\",\n\t\tbq_res->source_bq.width_bq, bq_res->source_bq.height_bq,\n\t\tbq_res->ispfilter_bq.width_bq, bq_res->ispfilter_bq.height_bq,\n\t\tbq_res->gdc_shift_bq.width_bq, bq_res->gdc_shift_bq.height_bq,\n\t\tbq_res->envelope_bq.width_bq, bq_res->envelope_bq.height_bq,\n\t\tbq_res->output_bq.width_bq, bq_res->output_bq.height_bq);\n\n\treturn 0;\n}\n\nint atomisp_set_dis_coefs(struct atomisp_sub_device *asd,\n\t\t\t  struct atomisp_dis_coefficients *coefs)\n{\n\treturn atomisp_css_set_dis_coefs(asd, coefs);\n}\n\n \nint atomisp_3a_stat(struct atomisp_sub_device *asd, int flag,\n\t\t    struct atomisp_3a_statistics *config)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct atomisp_s3a_buf *s3a_buf;\n\tunsigned long ret;\n\n\tif (flag != 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (asd->params.s3a_output_bytes == 0)\n\t\treturn -EINVAL;\n\n\tif (atomisp_compare_grid(asd, &config->grid_info) != 0) {\n\t\t \n\t\treturn -EAGAIN;\n\t}\n\n\tif (list_empty(&asd->s3a_stats_ready)) {\n\t\tdev_err(isp->dev, \"3a statistics is not valid.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\ts3a_buf = list_entry(asd->s3a_stats_ready.next,\n\t\t\t     struct atomisp_s3a_buf, list);\n\tif (s3a_buf->s3a_map)\n\t\tia_css_translate_3a_statistics(\n\t\t    asd->params.s3a_user_stat, s3a_buf->s3a_map);\n\telse\n\t\tia_css_get_3a_statistics(asd->params.s3a_user_stat,\n\t\t\t\t\t s3a_buf->s3a_data);\n\n\tconfig->exp_id = s3a_buf->s3a_data->exp_id;\n\tconfig->isp_config_id = s3a_buf->s3a_data->isp_config_id;\n\n\tret = copy_to_user(config->data, asd->params.s3a_user_stat->data,\n\t\t\t   asd->params.s3a_output_bytes);\n\tif (ret) {\n\t\tdev_err(isp->dev, \"copy to user failed: copied %lu bytes\\n\",\n\t\t\tret);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tlist_del_init(&s3a_buf->list);\n\tlist_add_tail(&s3a_buf->list, &asd->s3a_stats);\n\tdev_dbg(isp->dev, \"%s: finish getting exp_id %d 3a stat, isp_config_id %d\\n\",\n\t\t__func__,\n\t\tconfig->exp_id, config->isp_config_id);\n\treturn 0;\n}\n\n \nint atomisp_calculate_real_zoom_region(struct atomisp_sub_device *asd,\n\t\t\t\t       struct ia_css_dz_config   *dz_config,\n\t\t\t\t       enum ia_css_pipe_id css_pipe_id)\n\n{\n\tstruct atomisp_stream_env *stream_env =\n\t\t    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];\n\tstruct atomisp_resolution  eff_res, out_res;\n\tint w_offset, h_offset;\n\n\tmemset(&eff_res, 0, sizeof(eff_res));\n\tmemset(&out_res, 0, sizeof(out_res));\n\n\tif (dz_config->dx || dz_config->dy)\n\t\treturn 0;\n\n\tif (css_pipe_id != IA_CSS_PIPE_ID_PREVIEW\n\t    && css_pipe_id != IA_CSS_PIPE_ID_CAPTURE) {\n\t\tdev_err(asd->isp->dev, \"%s the set pipe no support crop region\"\n\t\t\t, __func__);\n\t\treturn -EINVAL;\n\t}\n\n\teff_res.width =\n\t    stream_env->stream_config.input_config.effective_res.width;\n\teff_res.height =\n\t    stream_env->stream_config.input_config.effective_res.height;\n\tif (eff_res.width == 0 || eff_res.height == 0) {\n\t\tdev_err(asd->isp->dev, \"%s err effective resolution\"\n\t\t\t, __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dz_config->zoom_region.resolution.width\n\t    == asd->sensor_array_res.width\n\t    || dz_config->zoom_region.resolution.height\n\t    == asd->sensor_array_res.height) {\n\t\t \n\t\tdz_config->zoom_region.origin.x = 0;\n\t\tdz_config->zoom_region.origin.y = 0;\n\t\tdz_config->zoom_region.resolution.width = eff_res.width;\n\t\tdz_config->zoom_region.resolution.height = eff_res.height;\n\t\treturn 0;\n\t}\n\n\t \n\n\tif (!IS_ISP2401) {\n\t\tdz_config->zoom_region.origin.x = dz_config->zoom_region.origin.x\n\t\t\t\t\t\t  * eff_res.width\n\t\t\t\t\t\t  / asd->sensor_array_res.width;\n\t\tdz_config->zoom_region.origin.y = dz_config->zoom_region.origin.y\n\t\t\t\t\t\t  * eff_res.height\n\t\t\t\t\t\t  / asd->sensor_array_res.height;\n\t\tdz_config->zoom_region.resolution.width = dz_config->zoom_region.resolution.width\n\t\t\t\t\t\t\t  * eff_res.width\n\t\t\t\t\t\t\t  / asd->sensor_array_res.width;\n\t\tdz_config->zoom_region.resolution.height = dz_config->zoom_region.resolution.height\n\t\t\t\t\t\t\t  * eff_res.height\n\t\t\t\t\t\t\t  / asd->sensor_array_res.height;\n\t\t \n\t\tout_res.width = stream_env->pipe_configs[css_pipe_id].output_info[0].res.width;\n\t\tout_res.height = stream_env->pipe_configs[css_pipe_id].output_info[0].res.height;\n\t\tif (out_res.width == 0 || out_res.height == 0) {\n\t\t\tdev_err(asd->isp->dev, \"%s err current pipe output resolution\"\n\t\t\t\t, __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tout_res.width = stream_env->pipe_configs[css_pipe_id].output_info[0].res.width;\n\t\tout_res.height = stream_env->pipe_configs[css_pipe_id].output_info[0].res.height;\n\t\tif (out_res.width == 0 || out_res.height == 0) {\n\t\t\tdev_err(asd->isp->dev, \"%s err current pipe output resolution\"\n\t\t\t\t, __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (asd->sensor_array_res.width * out_res.height\n\t\t    < out_res.width * asd->sensor_array_res.height) {\n\t\t\th_offset = asd->sensor_array_res.height\n\t\t\t\t   - asd->sensor_array_res.width\n\t\t\t\t   * out_res.height / out_res.width;\n\t\t\th_offset = h_offset / 2;\n\t\t\tif (dz_config->zoom_region.origin.y < h_offset)\n\t\t\t\tdz_config->zoom_region.origin.y = 0;\n\t\t\telse\n\t\t\t\tdz_config->zoom_region.origin.y = dz_config->zoom_region.origin.y - h_offset;\n\t\t\tw_offset = 0;\n\t\t} else {\n\t\t\tw_offset = asd->sensor_array_res.width\n\t\t\t\t   - asd->sensor_array_res.height\n\t\t\t\t   * out_res.width / out_res.height;\n\t\t\tw_offset = w_offset / 2;\n\t\t\tif (dz_config->zoom_region.origin.x < w_offset)\n\t\t\t\tdz_config->zoom_region.origin.x = 0;\n\t\t\telse\n\t\t\t\tdz_config->zoom_region.origin.x = dz_config->zoom_region.origin.x - w_offset;\n\t\t\th_offset = 0;\n\t\t}\n\t\tdz_config->zoom_region.origin.x = dz_config->zoom_region.origin.x\n\t\t\t\t\t\t  * eff_res.width\n\t\t\t\t\t\t  / (asd->sensor_array_res.width - 2 * w_offset);\n\t\tdz_config->zoom_region.origin.y = dz_config->zoom_region.origin.y\n\t\t\t\t\t\t  * eff_res.height\n\t\t\t\t\t\t  / (asd->sensor_array_res.height - 2 * h_offset);\n\t\tdz_config->zoom_region.resolution.width = dz_config->zoom_region.resolution.width\n\t\t\t\t\t\t  * eff_res.width\n\t\t\t\t\t\t  / (asd->sensor_array_res.width - 2 * w_offset);\n\t\tdz_config->zoom_region.resolution.height = dz_config->zoom_region.resolution.height\n\t\t\t\t\t\t  * eff_res.height\n\t\t\t\t\t\t  / (asd->sensor_array_res.height - 2 * h_offset);\n\t}\n\n\tif (out_res.width * dz_config->zoom_region.resolution.height\n\t    > dz_config->zoom_region.resolution.width * out_res.height) {\n\t\tdz_config->zoom_region.resolution.height =\n\t\t    dz_config->zoom_region.resolution.width\n\t\t    * out_res.height / out_res.width;\n\t} else {\n\t\tdz_config->zoom_region.resolution.width =\n\t\t    dz_config->zoom_region.resolution.height\n\t\t    * out_res.width / out_res.height;\n\t}\n\tdev_dbg(asd->isp->dev,\n\t\t\"%s crop region:(%d,%d),(%d,%d) eff_res(%d, %d) array_size(%d,%d) out_res(%d, %d)\\n\",\n\t\t__func__, dz_config->zoom_region.origin.x,\n\t\tdz_config->zoom_region.origin.y,\n\t\tdz_config->zoom_region.resolution.width,\n\t\tdz_config->zoom_region.resolution.height,\n\t\teff_res.width, eff_res.height,\n\t\tasd->sensor_array_res.width,\n\t\tasd->sensor_array_res.height,\n\t\tout_res.width, out_res.height);\n\n\tif ((dz_config->zoom_region.origin.x +\n\t     dz_config->zoom_region.resolution.width\n\t     > eff_res.width) ||\n\t    (dz_config->zoom_region.origin.y +\n\t     dz_config->zoom_region.resolution.height\n\t     > eff_res.height))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic bool atomisp_check_zoom_region(\n    struct atomisp_sub_device *asd,\n    struct ia_css_dz_config *dz_config)\n{\n\tstruct atomisp_resolution  config;\n\tbool flag = false;\n\tunsigned int w, h;\n\n\tmemset(&config, 0, sizeof(struct atomisp_resolution));\n\n\tif (dz_config->dx && dz_config->dy)\n\t\treturn true;\n\n\tconfig.width = asd->sensor_array_res.width;\n\tconfig.height = asd->sensor_array_res.height;\n\tw = dz_config->zoom_region.origin.x +\n\t    dz_config->zoom_region.resolution.width;\n\th = dz_config->zoom_region.origin.y +\n\t    dz_config->zoom_region.resolution.height;\n\n\tif ((w <= config.width) && (h <= config.height) && w > 0 && h > 0)\n\t\tflag = true;\n\telse\n\t\t \n\t\tdev_err(asd->isp->dev,\n\t\t\t\"%s zoom region ERROR:dz_config:(%d,%d),(%d,%d)array_res(%d, %d)\\n\",\n\t\t\t__func__, dz_config->zoom_region.origin.x,\n\t\t\tdz_config->zoom_region.origin.y,\n\t\t\tdz_config->zoom_region.resolution.width,\n\t\t\tdz_config->zoom_region.resolution.height,\n\t\t\tconfig.width, config.height);\n\n\treturn flag;\n}\n\nvoid atomisp_apply_css_parameters(\n    struct atomisp_sub_device *asd,\n    struct atomisp_css_params *css_param)\n{\n\tif (css_param->update_flag.wb_config)\n\t\tasd->params.config.wb_config = &css_param->wb_config;\n\n\tif (css_param->update_flag.ob_config)\n\t\tasd->params.config.ob_config = &css_param->ob_config;\n\n\tif (css_param->update_flag.dp_config)\n\t\tasd->params.config.dp_config = &css_param->dp_config;\n\n\tif (css_param->update_flag.nr_config)\n\t\tasd->params.config.nr_config = &css_param->nr_config;\n\n\tif (css_param->update_flag.ee_config)\n\t\tasd->params.config.ee_config = &css_param->ee_config;\n\n\tif (css_param->update_flag.tnr_config)\n\t\tasd->params.config.tnr_config = &css_param->tnr_config;\n\n\tif (css_param->update_flag.a3a_config)\n\t\tasd->params.config.s3a_config = &css_param->s3a_config;\n\n\tif (css_param->update_flag.ctc_config)\n\t\tasd->params.config.ctc_config = &css_param->ctc_config;\n\n\tif (css_param->update_flag.cnr_config)\n\t\tasd->params.config.cnr_config = &css_param->cnr_config;\n\n\tif (css_param->update_flag.ecd_config)\n\t\tasd->params.config.ecd_config = &css_param->ecd_config;\n\n\tif (css_param->update_flag.ynr_config)\n\t\tasd->params.config.ynr_config = &css_param->ynr_config;\n\n\tif (css_param->update_flag.fc_config)\n\t\tasd->params.config.fc_config = &css_param->fc_config;\n\n\tif (css_param->update_flag.macc_config)\n\t\tasd->params.config.macc_config = &css_param->macc_config;\n\n\tif (css_param->update_flag.aa_config)\n\t\tasd->params.config.aa_config = &css_param->aa_config;\n\n\tif (css_param->update_flag.anr_config)\n\t\tasd->params.config.anr_config = &css_param->anr_config;\n\n\tif (css_param->update_flag.xnr_config)\n\t\tasd->params.config.xnr_config = &css_param->xnr_config;\n\n\tif (css_param->update_flag.yuv2rgb_cc_config)\n\t\tasd->params.config.yuv2rgb_cc_config = &css_param->yuv2rgb_cc_config;\n\n\tif (css_param->update_flag.rgb2yuv_cc_config)\n\t\tasd->params.config.rgb2yuv_cc_config = &css_param->rgb2yuv_cc_config;\n\n\tif (css_param->update_flag.macc_table)\n\t\tasd->params.config.macc_table = &css_param->macc_table;\n\n\tif (css_param->update_flag.xnr_table)\n\t\tasd->params.config.xnr_table = &css_param->xnr_table;\n\n\tif (css_param->update_flag.r_gamma_table)\n\t\tasd->params.config.r_gamma_table = &css_param->r_gamma_table;\n\n\tif (css_param->update_flag.g_gamma_table)\n\t\tasd->params.config.g_gamma_table = &css_param->g_gamma_table;\n\n\tif (css_param->update_flag.b_gamma_table)\n\t\tasd->params.config.b_gamma_table = &css_param->b_gamma_table;\n\n\tif (css_param->update_flag.anr_thres)\n\t\tatomisp_css_set_anr_thres(asd, &css_param->anr_thres);\n\n\tif (css_param->update_flag.shading_table)\n\t\tasd->params.config.shading_table = css_param->shading_table;\n\n\tif (css_param->update_flag.morph_table && asd->params.gdc_cac_en)\n\t\tasd->params.config.morph_table = css_param->morph_table;\n\n\tif (css_param->update_flag.dvs2_coefs) {\n\t\tstruct ia_css_dvs_grid_info *dvs_grid_info =\n\t\t    atomisp_css_get_dvs_grid_info(\n\t\t\t&asd->params.curr_grid_info);\n\n\t\tif (dvs_grid_info && dvs_grid_info->enable)\n\t\t\tatomisp_css_set_dvs2_coefs(asd, css_param->dvs2_coeff);\n\t}\n\n\tif (css_param->update_flag.dvs_6axis_config)\n\t\tatomisp_css_set_dvs_6axis(asd, css_param->dvs_6axis);\n\n\tatomisp_css_set_isp_config_id(asd, css_param->isp_config_id);\n\t \n}\n\nstatic unsigned int long copy_from_compatible(void *to, const void *from,\n\tunsigned long n, bool from_user)\n{\n\tif (from_user)\n\t\treturn copy_from_user(to, (void __user *)from, n);\n\telse\n\t\tmemcpy(to, from, n);\n\treturn 0;\n}\n\nint atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,\n\t\t\t\t      struct atomisp_parameters *arg,\n\t\t\t\t      struct atomisp_css_params *css_param,\n\t\t\t\t      bool from_user)\n{\n\tstruct atomisp_parameters *cur_config = &css_param->update_flag;\n\n\tif (!arg || !asd || !css_param)\n\t\treturn -EINVAL;\n\n\tif (arg->wb_config && (from_user || !cur_config->wb_config)) {\n\t\tif (copy_from_compatible(&css_param->wb_config, arg->wb_config,\n\t\t\t\t\t sizeof(struct ia_css_wb_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.wb_config =\n\t\t    (struct atomisp_wb_config *)&css_param->wb_config;\n\t}\n\n\tif (arg->ob_config && (from_user || !cur_config->ob_config)) {\n\t\tif (copy_from_compatible(&css_param->ob_config, arg->ob_config,\n\t\t\t\t\t sizeof(struct ia_css_ob_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.ob_config =\n\t\t    (struct atomisp_ob_config *)&css_param->ob_config;\n\t}\n\n\tif (arg->dp_config && (from_user || !cur_config->dp_config)) {\n\t\tif (copy_from_compatible(&css_param->dp_config, arg->dp_config,\n\t\t\t\t\t sizeof(struct ia_css_dp_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.dp_config =\n\t\t    (struct atomisp_dp_config *)&css_param->dp_config;\n\t}\n\n\tif (asd->run_mode->val != ATOMISP_RUN_MODE_VIDEO) {\n\t\tif (arg->dz_config && (from_user || !cur_config->dz_config)) {\n\t\t\tif (copy_from_compatible(&css_param->dz_config,\n\t\t\t\t\t\t arg->dz_config,\n\t\t\t\t\t\t sizeof(struct ia_css_dz_config),\n\t\t\t\t\t\t from_user))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (!atomisp_check_zoom_region(asd,\n\t\t\t\t\t\t       &css_param->dz_config)) {\n\t\t\t\tdev_err(asd->isp->dev, \"crop region error!\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcss_param->update_flag.dz_config =\n\t\t\t    (struct atomisp_dz_config *)\n\t\t\t    &css_param->dz_config;\n\t\t}\n\t}\n\n\tif (arg->nr_config && (from_user || !cur_config->nr_config)) {\n\t\tif (copy_from_compatible(&css_param->nr_config, arg->nr_config,\n\t\t\t\t\t sizeof(struct ia_css_nr_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.nr_config =\n\t\t    (struct atomisp_nr_config *)&css_param->nr_config;\n\t}\n\n\tif (arg->ee_config && (from_user || !cur_config->ee_config)) {\n\t\tif (copy_from_compatible(&css_param->ee_config, arg->ee_config,\n\t\t\t\t\t sizeof(struct ia_css_ee_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.ee_config =\n\t\t    (struct atomisp_ee_config *)&css_param->ee_config;\n\t}\n\n\tif (arg->tnr_config && (from_user || !cur_config->tnr_config)) {\n\t\tif (copy_from_compatible(&css_param->tnr_config,\n\t\t\t\t\t arg->tnr_config,\n\t\t\t\t\t sizeof(struct ia_css_tnr_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.tnr_config =\n\t\t    (struct atomisp_tnr_config *)\n\t\t    &css_param->tnr_config;\n\t}\n\n\tif (arg->a3a_config && (from_user || !cur_config->a3a_config)) {\n\t\tif (copy_from_compatible(&css_param->s3a_config,\n\t\t\t\t\t arg->a3a_config,\n\t\t\t\t\t sizeof(struct ia_css_3a_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.a3a_config =\n\t\t    (struct atomisp_3a_config *)&css_param->s3a_config;\n\t}\n\n\tif (arg->ctc_config && (from_user || !cur_config->ctc_config)) {\n\t\tif (copy_from_compatible(&css_param->ctc_config,\n\t\t\t\t\t arg->ctc_config,\n\t\t\t\t\t sizeof(struct ia_css_ctc_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.ctc_config =\n\t\t    (struct atomisp_ctc_config *)\n\t\t    &css_param->ctc_config;\n\t}\n\n\tif (arg->cnr_config && (from_user || !cur_config->cnr_config)) {\n\t\tif (copy_from_compatible(&css_param->cnr_config,\n\t\t\t\t\t arg->cnr_config,\n\t\t\t\t\t sizeof(struct ia_css_cnr_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.cnr_config =\n\t\t    (struct atomisp_cnr_config *)\n\t\t    &css_param->cnr_config;\n\t}\n\n\tif (arg->ecd_config && (from_user || !cur_config->ecd_config)) {\n\t\tif (copy_from_compatible(&css_param->ecd_config,\n\t\t\t\t\t arg->ecd_config,\n\t\t\t\t\t sizeof(struct ia_css_ecd_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.ecd_config =\n\t\t    (struct atomisp_ecd_config *)\n\t\t    &css_param->ecd_config;\n\t}\n\n\tif (arg->ynr_config && (from_user || !cur_config->ynr_config)) {\n\t\tif (copy_from_compatible(&css_param->ynr_config,\n\t\t\t\t\t arg->ynr_config,\n\t\t\t\t\t sizeof(struct ia_css_ynr_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.ynr_config =\n\t\t    (struct atomisp_ynr_config *)\n\t\t    &css_param->ynr_config;\n\t}\n\n\tif (arg->fc_config && (from_user || !cur_config->fc_config)) {\n\t\tif (copy_from_compatible(&css_param->fc_config,\n\t\t\t\t\t arg->fc_config,\n\t\t\t\t\t sizeof(struct ia_css_fc_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.fc_config =\n\t\t    (struct atomisp_fc_config *)&css_param->fc_config;\n\t}\n\n\tif (arg->macc_config && (from_user || !cur_config->macc_config)) {\n\t\tif (copy_from_compatible(&css_param->macc_config,\n\t\t\t\t\t arg->macc_config,\n\t\t\t\t\t sizeof(struct ia_css_macc_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.macc_config =\n\t\t    (struct atomisp_macc_config *)\n\t\t    &css_param->macc_config;\n\t}\n\n\tif (arg->aa_config && (from_user || !cur_config->aa_config)) {\n\t\tif (copy_from_compatible(&css_param->aa_config, arg->aa_config,\n\t\t\t\t\t sizeof(struct ia_css_aa_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.aa_config =\n\t\t    (struct atomisp_aa_config *)&css_param->aa_config;\n\t}\n\n\tif (arg->anr_config && (from_user || !cur_config->anr_config)) {\n\t\tif (copy_from_compatible(&css_param->anr_config,\n\t\t\t\t\t arg->anr_config,\n\t\t\t\t\t sizeof(struct ia_css_anr_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.anr_config =\n\t\t    (struct atomisp_anr_config *)\n\t\t    &css_param->anr_config;\n\t}\n\n\tif (arg->xnr_config && (from_user || !cur_config->xnr_config)) {\n\t\tif (copy_from_compatible(&css_param->xnr_config,\n\t\t\t\t\t arg->xnr_config,\n\t\t\t\t\t sizeof(struct ia_css_xnr_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.xnr_config =\n\t\t    (struct atomisp_xnr_config *)\n\t\t    &css_param->xnr_config;\n\t}\n\n\tif (arg->yuv2rgb_cc_config &&\n\t    (from_user || !cur_config->yuv2rgb_cc_config)) {\n\t\tif (copy_from_compatible(&css_param->yuv2rgb_cc_config,\n\t\t\t\t\t arg->yuv2rgb_cc_config,\n\t\t\t\t\t sizeof(struct ia_css_cc_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.yuv2rgb_cc_config =\n\t\t    (struct atomisp_cc_config *)\n\t\t    &css_param->yuv2rgb_cc_config;\n\t}\n\n\tif (arg->rgb2yuv_cc_config &&\n\t    (from_user || !cur_config->rgb2yuv_cc_config)) {\n\t\tif (copy_from_compatible(&css_param->rgb2yuv_cc_config,\n\t\t\t\t\t arg->rgb2yuv_cc_config,\n\t\t\t\t\t sizeof(struct ia_css_cc_config),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.rgb2yuv_cc_config =\n\t\t    (struct atomisp_cc_config *)\n\t\t    &css_param->rgb2yuv_cc_config;\n\t}\n\n\tif (arg->macc_table && (from_user || !cur_config->macc_table)) {\n\t\tif (copy_from_compatible(&css_param->macc_table,\n\t\t\t\t\t arg->macc_table,\n\t\t\t\t\t sizeof(struct ia_css_macc_table),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.macc_table =\n\t\t    (struct atomisp_macc_table *)\n\t\t    &css_param->macc_table;\n\t}\n\n\tif (arg->xnr_table && (from_user || !cur_config->xnr_table)) {\n\t\tif (copy_from_compatible(&css_param->xnr_table,\n\t\t\t\t\t arg->xnr_table,\n\t\t\t\t\t sizeof(struct ia_css_xnr_table),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.xnr_table =\n\t\t    (struct atomisp_xnr_table *)&css_param->xnr_table;\n\t}\n\n\tif (arg->r_gamma_table && (from_user || !cur_config->r_gamma_table)) {\n\t\tif (copy_from_compatible(&css_param->r_gamma_table,\n\t\t\t\t\t arg->r_gamma_table,\n\t\t\t\t\t sizeof(struct ia_css_rgb_gamma_table),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.r_gamma_table =\n\t\t    (struct atomisp_rgb_gamma_table *)\n\t\t    &css_param->r_gamma_table;\n\t}\n\n\tif (arg->g_gamma_table && (from_user || !cur_config->g_gamma_table)) {\n\t\tif (copy_from_compatible(&css_param->g_gamma_table,\n\t\t\t\t\t arg->g_gamma_table,\n\t\t\t\t\t sizeof(struct ia_css_rgb_gamma_table),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.g_gamma_table =\n\t\t    (struct atomisp_rgb_gamma_table *)\n\t\t    &css_param->g_gamma_table;\n\t}\n\n\tif (arg->b_gamma_table && (from_user || !cur_config->b_gamma_table)) {\n\t\tif (copy_from_compatible(&css_param->b_gamma_table,\n\t\t\t\t\t arg->b_gamma_table,\n\t\t\t\t\t sizeof(struct ia_css_rgb_gamma_table),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.b_gamma_table =\n\t\t    (struct atomisp_rgb_gamma_table *)\n\t\t    &css_param->b_gamma_table;\n\t}\n\n\tif (arg->anr_thres && (from_user || !cur_config->anr_thres)) {\n\t\tif (copy_from_compatible(&css_param->anr_thres, arg->anr_thres,\n\t\t\t\t\t sizeof(struct ia_css_anr_thres),\n\t\t\t\t\t from_user))\n\t\t\treturn -EFAULT;\n\t\tcss_param->update_flag.anr_thres =\n\t\t    (struct atomisp_anr_thres *)&css_param->anr_thres;\n\t}\n\n\tif (from_user)\n\t\tcss_param->isp_config_id = arg->isp_config_id;\n\t \n\treturn 0;\n}\n\nint atomisp_cp_lsc_table(struct atomisp_sub_device *asd,\n\t\t\t struct atomisp_shading_table *source_st,\n\t\t\t struct atomisp_css_params *css_param,\n\t\t\t bool from_user)\n{\n\tunsigned int i;\n\tunsigned int len_table;\n\tstruct ia_css_shading_table *shading_table;\n\tstruct ia_css_shading_table *old_table;\n\tstruct atomisp_shading_table *st, dest_st;\n\n\tif (!source_st)\n\t\treturn 0;\n\n\tif (!css_param)\n\t\treturn -EINVAL;\n\n\tif (!from_user && css_param->update_flag.shading_table)\n\t\treturn 0;\n\n\tif (IS_ISP2401) {\n\t\tif (copy_from_compatible(&dest_st, source_st,\n\t\t\t\t\tsizeof(struct atomisp_shading_table),\n\t\t\t\t\tfrom_user)) {\n\t\t\tdev_err(asd->isp->dev, \"copy shading table failed!\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tst = &dest_st;\n\t} else {\n\t\tst = source_st;\n\t}\n\n\told_table = css_param->shading_table;\n\n\t \n\tif (!st->enable) {\n\t\t \n\t\tshading_table = atomisp_css_shading_table_alloc(1, 1);\n\t\tif (!shading_table)\n\t\t\treturn -ENOMEM;\n\t\tshading_table->enable = 0;\n\t\tgoto set_lsc;\n\t}\n\n\t \n\tfor (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {\n\t\tif (!st->data[i]) {\n\t\t\tdev_err(asd->isp->dev, \"shading table validate failed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (st->width > SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR ||\n\t    st->height > SH_CSS_MAX_SCTBL_HEIGHT_PER_COLOR) {\n\t\tdev_err(asd->isp->dev, \"shading table w/h validate failed!\");\n\t\treturn -EINVAL;\n\t}\n\n\tshading_table = atomisp_css_shading_table_alloc(st->width, st->height);\n\tif (!shading_table)\n\t\treturn -ENOMEM;\n\n\tlen_table = st->width * st->height * ATOMISP_SC_TYPE_SIZE;\n\tfor (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {\n\t\tif (copy_from_compatible(shading_table->data[i],\n\t\t\t\t\t st->data[i], len_table, from_user)) {\n\t\t\tatomisp_css_shading_table_free(shading_table);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tshading_table->sensor_width = st->sensor_width;\n\tshading_table->sensor_height = st->sensor_height;\n\tshading_table->fraction_bits = st->fraction_bits;\n\tshading_table->enable = st->enable;\n\n\t \n\tif (old_table &&\n\t    old_table->sensor_width == shading_table->sensor_width &&\n\t    old_table->sensor_height == shading_table->sensor_height &&\n\t    old_table->width == shading_table->width &&\n\t    old_table->height == shading_table->height &&\n\t    old_table->fraction_bits == shading_table->fraction_bits &&\n\t    old_table->enable == shading_table->enable) {\n\t\tbool data_is_same = true;\n\n\t\tfor (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {\n\t\t\tif (memcmp(shading_table->data[i], old_table->data[i],\n\t\t\t\t   len_table) != 0) {\n\t\t\t\tdata_is_same = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (data_is_same) {\n\t\t\tatomisp_css_shading_table_free(shading_table);\n\t\t\treturn 0;\n\t\t}\n\t}\n\nset_lsc:\n\t \n\tcss_param->shading_table = shading_table;\n\tcss_param->update_flag.shading_table = (struct atomisp_shading_table *)shading_table;\n\tasd->params.sc_en = shading_table;\n\n\tif (old_table)\n\t\tatomisp_css_shading_table_free(old_table);\n\n\treturn 0;\n}\n\nint atomisp_css_cp_dvs2_coefs(struct atomisp_sub_device *asd,\n\t\t\t      struct ia_css_dvs2_coefficients *coefs,\n\t\t\t      struct atomisp_css_params *css_param,\n\t\t\t      bool from_user)\n{\n\tstruct ia_css_dvs_grid_info *cur =\n\t    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);\n\tint dvs_hor_coef_bytes, dvs_ver_coef_bytes;\n\tstruct ia_css_dvs2_coefficients dvs2_coefs;\n\n\tif (!coefs || !cur)\n\t\treturn 0;\n\n\tif (!from_user && css_param->update_flag.dvs2_coefs)\n\t\treturn 0;\n\n\tif (!IS_ISP2401) {\n\t\tif (sizeof(*cur) != sizeof(coefs->grid) ||\n\t\t    memcmp(&coefs->grid, cur, sizeof(coefs->grid))) {\n\t\t\tdev_err(asd->isp->dev, \"dvs grid mismatch!\\n\");\n\t\t\t \n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (!coefs->hor_coefs.odd_real ||\n\t\t    !coefs->hor_coefs.odd_imag ||\n\t\t    !coefs->hor_coefs.even_real ||\n\t\t    !coefs->hor_coefs.even_imag ||\n\t\t    !coefs->ver_coefs.odd_real ||\n\t\t    !coefs->ver_coefs.odd_imag ||\n\t\t    !coefs->ver_coefs.even_real ||\n\t\t    !coefs->ver_coefs.even_imag)\n\t\t\treturn -EINVAL;\n\n\t\tif (!css_param->dvs2_coeff) {\n\t\t\t \n\t\t\tcss_param->dvs2_coeff = ia_css_dvs2_coefficients_allocate(cur);\n\t\t\tif (!css_param->dvs2_coeff)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdvs_hor_coef_bytes = asd->params.dvs_hor_coef_bytes;\n\t\tdvs_ver_coef_bytes = asd->params.dvs_ver_coef_bytes;\n\t\tif (copy_from_compatible(css_param->dvs2_coeff->hor_coefs.odd_real,\n\t\t\t\t\tcoefs->hor_coefs.odd_real, dvs_hor_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->hor_coefs.odd_imag,\n\t\t\t\t\tcoefs->hor_coefs.odd_imag, dvs_hor_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->hor_coefs.even_real,\n\t\t\t\t\tcoefs->hor_coefs.even_real, dvs_hor_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->hor_coefs.even_imag,\n\t\t\t\t\tcoefs->hor_coefs.even_imag, dvs_hor_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.odd_real,\n\t\t\t\t\tcoefs->ver_coefs.odd_real, dvs_ver_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.odd_imag,\n\t\t\t\t\tcoefs->ver_coefs.odd_imag, dvs_ver_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.even_real,\n\t\t\t\t\tcoefs->ver_coefs.even_real, dvs_ver_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.even_imag,\n\t\t\t\t\tcoefs->ver_coefs.even_imag, dvs_ver_coef_bytes, from_user)) {\n\t\t\tia_css_dvs2_coefficients_free(css_param->dvs2_coeff);\n\t\t\tcss_param->dvs2_coeff = NULL;\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else {\n\t\tif (copy_from_compatible(&dvs2_coefs, coefs,\n\t\t\t\t\tsizeof(struct ia_css_dvs2_coefficients),\n\t\t\t\t\tfrom_user)) {\n\t\t\tdev_err(asd->isp->dev, \"copy dvs2 coef failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (sizeof(*cur) != sizeof(dvs2_coefs.grid) ||\n\t\t    memcmp(&dvs2_coefs.grid, cur, sizeof(dvs2_coefs.grid))) {\n\t\t\tdev_err(asd->isp->dev, \"dvs grid mismatch!\\n\");\n\t\t\t \n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (!dvs2_coefs.hor_coefs.odd_real ||\n\t\t    !dvs2_coefs.hor_coefs.odd_imag ||\n\t\t    !dvs2_coefs.hor_coefs.even_real ||\n\t\t    !dvs2_coefs.hor_coefs.even_imag ||\n\t\t    !dvs2_coefs.ver_coefs.odd_real ||\n\t\t    !dvs2_coefs.ver_coefs.odd_imag ||\n\t\t    !dvs2_coefs.ver_coefs.even_real ||\n\t\t    !dvs2_coefs.ver_coefs.even_imag)\n\t\t\treturn -EINVAL;\n\n\t\tif (!css_param->dvs2_coeff) {\n\t\t\t \n\t\t\tcss_param->dvs2_coeff = ia_css_dvs2_coefficients_allocate(cur);\n\t\t\tif (!css_param->dvs2_coeff)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdvs_hor_coef_bytes = asd->params.dvs_hor_coef_bytes;\n\t\tdvs_ver_coef_bytes = asd->params.dvs_ver_coef_bytes;\n\t\tif (copy_from_compatible(css_param->dvs2_coeff->hor_coefs.odd_real,\n\t\t\t\t\tdvs2_coefs.hor_coefs.odd_real, dvs_hor_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->hor_coefs.odd_imag,\n\t\t\t\t\tdvs2_coefs.hor_coefs.odd_imag, dvs_hor_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->hor_coefs.even_real,\n\t\t\t\t\tdvs2_coefs.hor_coefs.even_real, dvs_hor_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->hor_coefs.even_imag,\n\t\t\t\t\tdvs2_coefs.hor_coefs.even_imag, dvs_hor_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.odd_real,\n\t\t\t\t\tdvs2_coefs.ver_coefs.odd_real, dvs_ver_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.odd_imag,\n\t\t\t\t\tdvs2_coefs.ver_coefs.odd_imag, dvs_ver_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.even_real,\n\t\t\t\t\tdvs2_coefs.ver_coefs.even_real, dvs_ver_coef_bytes, from_user) ||\n\t\t    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.even_imag,\n\t\t\t\t\tdvs2_coefs.ver_coefs.even_imag, dvs_ver_coef_bytes, from_user)) {\n\t\t\tia_css_dvs2_coefficients_free(css_param->dvs2_coeff);\n\t\t\tcss_param->dvs2_coeff = NULL;\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tcss_param->update_flag.dvs2_coefs =\n\t    (struct atomisp_dis_coefficients *)css_param->dvs2_coeff;\n\treturn 0;\n}\n\nint atomisp_cp_dvs_6axis_config(struct atomisp_sub_device *asd,\n\t\t\t\tstruct atomisp_dvs_6axis_config *source_6axis_config,\n\t\t\t\tstruct atomisp_css_params *css_param,\n\t\t\t\tbool from_user)\n{\n\tstruct ia_css_dvs_6axis_config *dvs_6axis_config;\n\tstruct ia_css_dvs_6axis_config *old_6axis_config;\n\tstruct ia_css_stream *stream =\n\t\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream;\n\tstruct ia_css_dvs_grid_info *dvs_grid_info =\n\t    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);\n\tint ret = -EFAULT;\n\n\tif (!stream) {\n\t\tdev_err(asd->isp->dev, \"%s: internal error!\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!source_6axis_config || !dvs_grid_info)\n\t\treturn 0;\n\n\tif (!dvs_grid_info->enable)\n\t\treturn 0;\n\n\tif (!from_user && css_param->update_flag.dvs_6axis_config)\n\t\treturn 0;\n\n\t \n\told_6axis_config = css_param->dvs_6axis;\n\tdvs_6axis_config = old_6axis_config;\n\n\tif (IS_ISP2401) {\n\t\tstruct ia_css_dvs_6axis_config t_6axis_config;\n\n\t\tif (copy_from_compatible(&t_6axis_config, source_6axis_config,\n\t\t\t\t\tsizeof(struct atomisp_dvs_6axis_config),\n\t\t\t\t\tfrom_user)) {\n\t\t\tdev_err(asd->isp->dev, \"copy morph table failed!\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (old_6axis_config &&\n\t\t    (old_6axis_config->width_y != t_6axis_config.width_y ||\n\t\t    old_6axis_config->height_y != t_6axis_config.height_y ||\n\t\t    old_6axis_config->width_uv != t_6axis_config.width_uv ||\n\t\t    old_6axis_config->height_uv != t_6axis_config.height_uv)) {\n\t\t\tia_css_dvs2_6axis_config_free(css_param->dvs_6axis);\n\t\t\tcss_param->dvs_6axis = NULL;\n\n\t\t\tdvs_6axis_config = ia_css_dvs2_6axis_config_allocate(stream);\n\t\t\tif (!dvs_6axis_config)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!dvs_6axis_config) {\n\t\t\tdvs_6axis_config = ia_css_dvs2_6axis_config_allocate(stream);\n\t\t\tif (!dvs_6axis_config)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdvs_6axis_config->exp_id = t_6axis_config.exp_id;\n\n\t\tif (copy_from_compatible(dvs_6axis_config->xcoords_y,\n\t\t\t\t\tt_6axis_config.xcoords_y,\n\t\t\t\t\tt_6axis_config.width_y *\n\t\t\t\t\tt_6axis_config.height_y *\n\t\t\t\t\tsizeof(*dvs_6axis_config->xcoords_y),\n\t\t\t\t\tfrom_user))\n\t\t\tgoto error;\n\t\tif (copy_from_compatible(dvs_6axis_config->ycoords_y,\n\t\t\t\t\tt_6axis_config.ycoords_y,\n\t\t\t\t\tt_6axis_config.width_y *\n\t\t\t\t\tt_6axis_config.height_y *\n\t\t\t\t\tsizeof(*dvs_6axis_config->ycoords_y),\n\t\t\t\t\tfrom_user))\n\t\t\tgoto error;\n\t\tif (copy_from_compatible(dvs_6axis_config->xcoords_uv,\n\t\t\t\t\tt_6axis_config.xcoords_uv,\n\t\t\t\t\tt_6axis_config.width_uv *\n\t\t\t\t\tt_6axis_config.height_uv *\n\t\t\t\t\tsizeof(*dvs_6axis_config->xcoords_uv),\n\t\t\t\t\tfrom_user))\n\t\t\tgoto error;\n\t\tif (copy_from_compatible(dvs_6axis_config->ycoords_uv,\n\t\t\t\t\tt_6axis_config.ycoords_uv,\n\t\t\t\t\tt_6axis_config.width_uv *\n\t\t\t\t\tt_6axis_config.height_uv *\n\t\t\t\t\tsizeof(*dvs_6axis_config->ycoords_uv),\n\t\t\t\t\tfrom_user))\n\t\t\tgoto error;\n\t} else {\n\t\tif (old_6axis_config &&\n\t\t    (old_6axis_config->width_y != source_6axis_config->width_y ||\n\t\t    old_6axis_config->height_y != source_6axis_config->height_y ||\n\t\t    old_6axis_config->width_uv != source_6axis_config->width_uv ||\n\t\t    old_6axis_config->height_uv != source_6axis_config->height_uv)) {\n\t\t\tia_css_dvs2_6axis_config_free(css_param->dvs_6axis);\n\t\t\tcss_param->dvs_6axis = NULL;\n\n\t\t\tdvs_6axis_config = ia_css_dvs2_6axis_config_allocate(stream);\n\t\t\tif (!dvs_6axis_config)\n\t\t\t\treturn -ENOMEM;\n\t\t} else if (!dvs_6axis_config) {\n\t\t\tdvs_6axis_config = ia_css_dvs2_6axis_config_allocate(stream);\n\t\t\tif (!dvs_6axis_config)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdvs_6axis_config->exp_id = source_6axis_config->exp_id;\n\n\t\tif (copy_from_compatible(dvs_6axis_config->xcoords_y,\n\t\t\t\t\tsource_6axis_config->xcoords_y,\n\t\t\t\t\tsource_6axis_config->width_y *\n\t\t\t\t\tsource_6axis_config->height_y *\n\t\t\t\t\tsizeof(*source_6axis_config->xcoords_y),\n\t\t\t\t\tfrom_user))\n\t\t\tgoto error;\n\t\tif (copy_from_compatible(dvs_6axis_config->ycoords_y,\n\t\t\t\t\tsource_6axis_config->ycoords_y,\n\t\t\t\t\tsource_6axis_config->width_y *\n\t\t\t\t\tsource_6axis_config->height_y *\n\t\t\t\t\tsizeof(*source_6axis_config->ycoords_y),\n\t\t\t\t\tfrom_user))\n\t\t\tgoto error;\n\t\tif (copy_from_compatible(dvs_6axis_config->xcoords_uv,\n\t\t\t\t\tsource_6axis_config->xcoords_uv,\n\t\t\t\t\tsource_6axis_config->width_uv *\n\t\t\t\t\tsource_6axis_config->height_uv *\n\t\t\t\t\tsizeof(*source_6axis_config->xcoords_uv),\n\t\t\t\t\tfrom_user))\n\t\t\tgoto error;\n\t\tif (copy_from_compatible(dvs_6axis_config->ycoords_uv,\n\t\t\t\t\tsource_6axis_config->ycoords_uv,\n\t\t\t\t\tsource_6axis_config->width_uv *\n\t\t\t\t\tsource_6axis_config->height_uv *\n\t\t\t\t\tsizeof(*source_6axis_config->ycoords_uv),\n\t\t\t\t\tfrom_user))\n\t\t\tgoto error;\n\t}\n\tcss_param->dvs_6axis = dvs_6axis_config;\n\tcss_param->update_flag.dvs_6axis_config =\n\t    (struct atomisp_dvs_6axis_config *)dvs_6axis_config;\n\treturn 0;\n\nerror:\n\tif (dvs_6axis_config)\n\t\tia_css_dvs2_6axis_config_free(dvs_6axis_config);\n\treturn ret;\n}\n\nint atomisp_cp_morph_table(struct atomisp_sub_device *asd,\n\t\t\t   struct atomisp_morph_table *source_morph_table,\n\t\t\t   struct atomisp_css_params *css_param,\n\t\t\t   bool from_user)\n{\n\tint ret = -EFAULT;\n\tunsigned int i;\n\tstruct ia_css_morph_table *morph_table;\n\tstruct ia_css_morph_table *old_morph_table;\n\n\tif (!source_morph_table)\n\t\treturn 0;\n\n\tif (!from_user && css_param->update_flag.morph_table)\n\t\treturn 0;\n\n\told_morph_table = css_param->morph_table;\n\n\tif (IS_ISP2401) {\n\t\tstruct ia_css_morph_table mtbl;\n\n\t\tif (copy_from_compatible(&mtbl, source_morph_table,\n\t\t\t\tsizeof(struct atomisp_morph_table),\n\t\t\t\tfrom_user)) {\n\t\t\tdev_err(asd->isp->dev, \"copy morph table failed!\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tmorph_table = atomisp_css_morph_table_allocate(\n\t\t\t\tmtbl.width,\n\t\t\t\tmtbl.height);\n\t\tif (!morph_table)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {\n\t\t\tif (copy_from_compatible(morph_table->coordinates_x[i],\n\t\t\t\t\t\t(__force void *)source_morph_table->coordinates_x[i],\n\t\t\t\t\t\tmtbl.height * mtbl.width *\n\t\t\t\t\t\tsizeof(*morph_table->coordinates_x[i]),\n\t\t\t\t\t\tfrom_user))\n\t\t\t\tgoto error;\n\n\t\t\tif (copy_from_compatible(morph_table->coordinates_y[i],\n\t\t\t\t\t\t(__force void *)source_morph_table->coordinates_y[i],\n\t\t\t\t\t\tmtbl.height * mtbl.width *\n\t\t\t\t\t\tsizeof(*morph_table->coordinates_y[i]),\n\t\t\t\t\t\tfrom_user))\n\t\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tmorph_table = atomisp_css_morph_table_allocate(\n\t\t\t\tsource_morph_table->width,\n\t\t\t\tsource_morph_table->height);\n\t\tif (!morph_table)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {\n\t\t\tif (copy_from_compatible(morph_table->coordinates_x[i],\n\t\t\t\t\t\t(__force void *)source_morph_table->coordinates_x[i],\n\t\t\t\t\t\tsource_morph_table->height * source_morph_table->width *\n\t\t\t\t\t\tsizeof(*source_morph_table->coordinates_x[i]),\n\t\t\t\t\t\tfrom_user))\n\t\t\t\tgoto error;\n\n\t\t\tif (copy_from_compatible(morph_table->coordinates_y[i],\n\t\t\t\t\t\t(__force void *)source_morph_table->coordinates_y[i],\n\t\t\t\t\t\tsource_morph_table->height * source_morph_table->width *\n\t\t\t\t\t\tsizeof(*source_morph_table->coordinates_y[i]),\n\t\t\t\t\t\tfrom_user))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\tcss_param->morph_table = morph_table;\n\tif (old_morph_table)\n\t\tatomisp_css_morph_table_free(old_morph_table);\n\tcss_param->update_flag.morph_table =\n\t    (struct atomisp_morph_table *)morph_table;\n\treturn 0;\n\nerror:\n\tif (morph_table)\n\t\tatomisp_css_morph_table_free(morph_table);\n\treturn ret;\n}\n\nint atomisp_makeup_css_parameters(struct atomisp_sub_device *asd,\n\t\t\t\t  struct atomisp_parameters *arg,\n\t\t\t\t  struct atomisp_css_params *css_param)\n{\n\tint ret;\n\n\tret = atomisp_cp_general_isp_parameters(asd, arg, css_param, false);\n\tif (ret)\n\t\treturn ret;\n\tret = atomisp_cp_lsc_table(asd, arg->shading_table, css_param, false);\n\tif (ret)\n\t\treturn ret;\n\tret = atomisp_cp_morph_table(asd, arg->morph_table, css_param, false);\n\tif (ret)\n\t\treturn ret;\n\tret = atomisp_css_cp_dvs2_coefs(asd,\n\t\t\t\t\t(struct ia_css_dvs2_coefficients *)arg->dvs2_coefs,\n\t\t\t\t\tcss_param, false);\n\tif (ret)\n\t\treturn ret;\n\tret = atomisp_cp_dvs_6axis_config(asd, arg->dvs_6axis_config,\n\t\t\t\t\t  css_param, false);\n\treturn ret;\n}\n\nvoid atomisp_free_css_parameters(struct atomisp_css_params *css_param)\n{\n\tif (css_param->dvs_6axis) {\n\t\tia_css_dvs2_6axis_config_free(css_param->dvs_6axis);\n\t\tcss_param->dvs_6axis = NULL;\n\t}\n\tif (css_param->dvs2_coeff) {\n\t\tia_css_dvs2_coefficients_free(css_param->dvs2_coeff);\n\t\tcss_param->dvs2_coeff = NULL;\n\t}\n\tif (css_param->shading_table) {\n\t\tia_css_shading_table_free(css_param->shading_table);\n\t\tcss_param->shading_table = NULL;\n\t}\n\tif (css_param->morph_table) {\n\t\tia_css_morph_table_free(css_param->morph_table);\n\t\tcss_param->morph_table = NULL;\n\t}\n}\n\nstatic void atomisp_move_frame_to_activeq(struct ia_css_frame *frame,\n\t\t\t\t\t  struct atomisp_css_params_with_list *param)\n{\n\tstruct atomisp_video_pipe *pipe = vb_to_pipe(&frame->vb.vb2_buf);\n\tunsigned long irqflags;\n\n\tpipe->frame_params[frame->vb.vb2_buf.index] = param;\n\tspin_lock_irqsave(&pipe->irq_lock, irqflags);\n\tlist_move_tail(&frame->queue, &pipe->activeq);\n\tspin_unlock_irqrestore(&pipe->irq_lock, irqflags);\n}\n\n \nvoid atomisp_handle_parameter_and_buffer(struct atomisp_video_pipe *pipe)\n{\n\tstruct atomisp_sub_device *asd = pipe->asd;\n\tstruct ia_css_frame *frame = NULL, *frame_tmp;\n\tstruct atomisp_css_params_with_list *param = NULL, *param_tmp;\n\tbool need_to_enqueue_buffer = false;\n\tint i;\n\n\tlockdep_assert_held(&asd->isp->mutex);\n\n\t \n\tif (!asd->streaming)\n\t\treturn;\n\n\tif (list_empty(&pipe->per_frame_params) ||\n\t    list_empty(&pipe->buffers_waiting_for_param))\n\t\treturn;\n\n\tlist_for_each_entry_safe(frame, frame_tmp,\n\t\t\t\t &pipe->buffers_waiting_for_param, queue) {\n\t\ti = frame->vb.vb2_buf.index;\n\t\tif (pipe->frame_request_config_id[i]) {\n\t\t\tlist_for_each_entry_safe(param, param_tmp,\n\t\t\t\t\t\t &pipe->per_frame_params, list) {\n\t\t\t\tif (pipe->frame_request_config_id[i] != param->params.isp_config_id)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlist_del(&param->list);\n\n\t\t\t\t \n\t\t\t\tpipe->frame_request_config_id[i] = 0;\n\t\t\t\tatomisp_move_frame_to_activeq(frame, param);\n\t\t\t\tneed_to_enqueue_buffer = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (list_entry_is_head(param, &pipe->per_frame_params, list))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tatomisp_move_frame_to_activeq(frame, NULL);\n\t\t\tneed_to_enqueue_buffer = true;\n\t\t}\n\t}\n\n\tif (!need_to_enqueue_buffer)\n\t\treturn;\n\n\tatomisp_qbuffers_to_css(asd);\n}\n\n \nint atomisp_set_parameters(struct video_device *vdev,\n\t\t\t   struct atomisp_parameters *arg)\n{\n\tstruct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);\n\tstruct atomisp_sub_device *asd = pipe->asd;\n\tstruct atomisp_css_params_with_list *param = NULL;\n\tstruct atomisp_css_params *css_param = &asd->params.css_param;\n\tint ret;\n\n\tlockdep_assert_held(&asd->isp->mutex);\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(asd->isp->dev, \"%s: internal error!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(asd->isp->dev, \"set parameter(per_frame_setting %d) isp_config_id %d of %s\\n\",\n\t\targ->per_frame_setting, arg->isp_config_id, vdev->name);\n\n\tif (arg->per_frame_setting) {\n\t\t \n\t\tparam = kvzalloc(sizeof(*param), GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tdev_err(asd->isp->dev, \"%s: failed to alloc params buffer\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcss_param = &param->params;\n\t}\n\n\tret = atomisp_cp_general_isp_parameters(asd, arg, css_param, true);\n\tif (ret)\n\t\tgoto apply_parameter_failed;\n\n\tret = atomisp_cp_lsc_table(asd, arg->shading_table, css_param, true);\n\tif (ret)\n\t\tgoto apply_parameter_failed;\n\n\tret = atomisp_cp_morph_table(asd, arg->morph_table, css_param, true);\n\tif (ret)\n\t\tgoto apply_parameter_failed;\n\n\tret = atomisp_css_cp_dvs2_coefs(asd,\n\t\t\t\t\t(struct ia_css_dvs2_coefficients *)arg->dvs2_coefs,\n\t\t\t\t\tcss_param, true);\n\tif (ret)\n\t\tgoto apply_parameter_failed;\n\n\tret = atomisp_cp_dvs_6axis_config(asd, arg->dvs_6axis_config,\n\t\t\t\t\t  css_param, true);\n\tif (ret)\n\t\tgoto apply_parameter_failed;\n\n\tif (!arg->per_frame_setting) {\n\t\t \n\t\tasd->params.css_update_params_needed = true;\n\t} else {\n\t\tlist_add_tail(&param->list, &pipe->per_frame_params);\n\t\tatomisp_handle_parameter_and_buffer(pipe);\n\t}\n\n\treturn 0;\n\napply_parameter_failed:\n\tif (css_param)\n\t\tatomisp_free_css_parameters(css_param);\n\tkvfree(param);\n\n\treturn ret;\n}\n\n \nint atomisp_param(struct atomisp_sub_device *asd, int flag,\n\t\t  struct atomisp_parm *config)\n{\n\tstruct ia_css_pipe_config *vp_cfg =\n\t\t    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].\n\t\t    pipe_configs[IA_CSS_PIPE_ID_VIDEO];\n\n\t \n\tif (flag == 0) {\n\t\tstruct ia_css_dvs_grid_info *dvs_grid_info =\n\t\t    atomisp_css_get_dvs_grid_info(\n\t\t\t&asd->params.curr_grid_info);\n\n\t\tatomisp_curr_user_grid_info(asd, &config->info);\n\n\t\t \n\t\tconfig->metadata_config.metadata_height = asd->\n\t\t\tstream_env[ATOMISP_INPUT_STREAM_GENERAL].stream_info.\n\t\t\tmetadata_info.resolution.height;\n\t\tconfig->metadata_config.metadata_stride = asd->\n\t\t\tstream_env[ATOMISP_INPUT_STREAM_GENERAL].stream_info.\n\t\t\tmetadata_info.stride;\n\n\t\t \n\t\tif (dvs_grid_info)\n\t\t\tmemcpy(&config->dvs_grid,\n\t\t\t       dvs_grid_info,\n\t\t\t       sizeof(struct ia_css_dvs_grid_info));\n\n\t\tif (asd->run_mode->val != ATOMISP_RUN_MODE_VIDEO) {\n\t\t\tconfig->dvs_envelop.width = 0;\n\t\t\tconfig->dvs_envelop.height = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tconfig->dvs_envelop.width = vp_cfg->dvs_envelope.width;\n\t\tconfig->dvs_envelop.height = vp_cfg->dvs_envelope.height;\n\t\treturn 0;\n\t}\n\n\tmemcpy(&asd->params.css_param.wb_config, &config->wb_config,\n\t       sizeof(struct ia_css_wb_config));\n\tmemcpy(&asd->params.css_param.ob_config, &config->ob_config,\n\t       sizeof(struct ia_css_ob_config));\n\tmemcpy(&asd->params.css_param.dp_config, &config->dp_config,\n\t       sizeof(struct ia_css_dp_config));\n\tmemcpy(&asd->params.css_param.de_config, &config->de_config,\n\t       sizeof(struct ia_css_de_config));\n\tmemcpy(&asd->params.css_param.dz_config, &config->dz_config,\n\t       sizeof(struct ia_css_dz_config));\n\tmemcpy(&asd->params.css_param.ce_config, &config->ce_config,\n\t       sizeof(struct ia_css_ce_config));\n\tmemcpy(&asd->params.css_param.nr_config, &config->nr_config,\n\t       sizeof(struct ia_css_nr_config));\n\tmemcpy(&asd->params.css_param.ee_config, &config->ee_config,\n\t       sizeof(struct ia_css_ee_config));\n\tmemcpy(&asd->params.css_param.tnr_config, &config->tnr_config,\n\t       sizeof(struct ia_css_tnr_config));\n\n\tif (asd->params.color_effect == V4L2_COLORFX_NEGATIVE) {\n\t\tasd->params.css_param.cc_config.matrix[3] = -config->cc_config.matrix[3];\n\t\tasd->params.css_param.cc_config.matrix[4] = -config->cc_config.matrix[4];\n\t\tasd->params.css_param.cc_config.matrix[5] = -config->cc_config.matrix[5];\n\t\tasd->params.css_param.cc_config.matrix[6] = -config->cc_config.matrix[6];\n\t\tasd->params.css_param.cc_config.matrix[7] = -config->cc_config.matrix[7];\n\t\tasd->params.css_param.cc_config.matrix[8] = -config->cc_config.matrix[8];\n\t}\n\n\tif (asd->params.color_effect != V4L2_COLORFX_SEPIA &&\n\t    asd->params.color_effect != V4L2_COLORFX_BW) {\n\t\tmemcpy(&asd->params.css_param.cc_config, &config->cc_config,\n\t\t       sizeof(struct ia_css_cc_config));\n\t\tasd->params.config.cc_config = &asd->params.css_param.cc_config;\n\t}\n\n\tasd->params.config.wb_config = &asd->params.css_param.wb_config;\n\tasd->params.config.ob_config = &asd->params.css_param.ob_config;\n\tasd->params.config.de_config = &asd->params.css_param.de_config;\n\tasd->params.config.dz_config = &asd->params.css_param.dz_config;\n\tasd->params.config.ce_config = &asd->params.css_param.ce_config;\n\tasd->params.config.dp_config = &asd->params.css_param.dp_config;\n\tasd->params.config.nr_config = &asd->params.css_param.nr_config;\n\tasd->params.config.ee_config = &asd->params.css_param.ee_config;\n\tasd->params.config.tnr_config = &asd->params.css_param.tnr_config;\n\tasd->params.css_update_params_needed = true;\n\n\treturn 0;\n}\n\n \nint atomisp_color_effect(struct atomisp_sub_device *asd, int flag,\n\t\t\t __s32 *effect)\n{\n\tstruct ia_css_cc_config *cc_config = NULL;\n\tstruct ia_css_macc_table *macc_table = NULL;\n\tstruct ia_css_ctc_table *ctc_table = NULL;\n\tint ret = 0;\n\tstruct v4l2_control control;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (flag == 0) {\n\t\t*effect = asd->params.color_effect;\n\t\treturn 0;\n\t}\n\n\tcontrol.id = V4L2_CID_COLORFX;\n\tcontrol.value = *effect;\n\tret =\n\t    v4l2_s_ctrl(NULL, isp->inputs[asd->input_curr].camera->ctrl_handler,\n\t\t\t&control);\n\t \n\tif (!ret) {\n\t\tasd->params.color_effect = (u32)*effect;\n\t\treturn 0;\n\t}\n\n\tif (*effect == asd->params.color_effect)\n\t\treturn 0;\n\n\t \n\tasd->params.macc_en = false;\n\n\tswitch (*effect) {\n\tcase V4L2_COLORFX_NONE:\n\t\tmacc_table = &asd->params.css_param.macc_table;\n\t\tasd->params.macc_en = true;\n\t\tbreak;\n\tcase V4L2_COLORFX_SEPIA:\n\t\tcc_config = &sepia_cc_config;\n\t\tbreak;\n\tcase V4L2_COLORFX_NEGATIVE:\n\t\tcc_config = &nega_cc_config;\n\t\tbreak;\n\tcase V4L2_COLORFX_BW:\n\t\tcc_config = &mono_cc_config;\n\t\tbreak;\n\tcase V4L2_COLORFX_SKY_BLUE:\n\t\tmacc_table = &blue_macc_table;\n\t\tasd->params.macc_en = true;\n\t\tbreak;\n\tcase V4L2_COLORFX_GRASS_GREEN:\n\t\tmacc_table = &green_macc_table;\n\t\tasd->params.macc_en = true;\n\t\tbreak;\n\tcase V4L2_COLORFX_SKIN_WHITEN_LOW:\n\t\tmacc_table = &skin_low_macc_table;\n\t\tasd->params.macc_en = true;\n\t\tbreak;\n\tcase V4L2_COLORFX_SKIN_WHITEN:\n\t\tmacc_table = &skin_medium_macc_table;\n\t\tasd->params.macc_en = true;\n\t\tbreak;\n\tcase V4L2_COLORFX_SKIN_WHITEN_HIGH:\n\t\tmacc_table = &skin_high_macc_table;\n\t\tasd->params.macc_en = true;\n\t\tbreak;\n\tcase V4L2_COLORFX_VIVID:\n\t\tctc_table = &vivid_ctc_table;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tatomisp_update_capture_mode(asd);\n\n\tif (cc_config)\n\t\tasd->params.config.cc_config = cc_config;\n\tif (macc_table)\n\t\tasd->params.config.macc_table = macc_table;\n\tif (ctc_table)\n\t\tatomisp_css_set_ctc_table(asd, ctc_table);\n\tasd->params.color_effect = (u32)*effect;\n\tasd->params.css_update_params_needed = true;\n\treturn 0;\n}\n\n \nint atomisp_bad_pixel(struct atomisp_sub_device *asd, int flag,\n\t\t      __s32 *value)\n{\n\tif (flag == 0) {\n\t\t*value = asd->params.bad_pixel_en;\n\t\treturn 0;\n\t}\n\tasd->params.bad_pixel_en = !!*value;\n\n\treturn 0;\n}\n\n \nint atomisp_bad_pixel_param(struct atomisp_sub_device *asd, int flag,\n\t\t\t    struct atomisp_dp_config *config)\n{\n\tif (flag == 0) {\n\t\t \n\t\tif (atomisp_css_get_dp_config(asd, config))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tmemcpy(&asd->params.css_param.dp_config, config,\n\t\t       sizeof(asd->params.css_param.dp_config));\n\t\tasd->params.config.dp_config = &asd->params.css_param.dp_config;\n\t\tasd->params.css_update_params_needed = true;\n\t}\n\n\treturn 0;\n}\n\n \nint atomisp_video_stable(struct atomisp_sub_device *asd, int flag,\n\t\t\t __s32 *value)\n{\n\tif (flag == 0)\n\t\t*value = asd->params.video_dis_en;\n\telse\n\t\tasd->params.video_dis_en = !!*value;\n\n\treturn 0;\n}\n\n \nint atomisp_fixed_pattern(struct atomisp_sub_device *asd, int flag,\n\t\t\t  __s32 *value)\n{\n\tif (flag == 0) {\n\t\t*value = asd->params.fpn_en;\n\t\treturn 0;\n\t}\n\n\tif (*value == 0) {\n\t\tasd->params.fpn_en = false;\n\t\treturn 0;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic unsigned int\natomisp_bytesperline_to_padded_width(unsigned int bytesperline,\n\t\t\t\t     enum ia_css_frame_format format)\n{\n\tswitch (format) {\n\tcase IA_CSS_FRAME_FORMAT_UYVY:\n\tcase IA_CSS_FRAME_FORMAT_YUYV:\n\tcase IA_CSS_FRAME_FORMAT_RAW:\n\tcase IA_CSS_FRAME_FORMAT_RGB565:\n\t\treturn bytesperline / 2;\n\tcase IA_CSS_FRAME_FORMAT_RGBA888:\n\t\treturn bytesperline / 4;\n\t \n\tcase IA_CSS_FRAME_FORMAT_NV11:\n\tcase IA_CSS_FRAME_FORMAT_NV12:\n\tcase IA_CSS_FRAME_FORMAT_NV16:\n\tcase IA_CSS_FRAME_FORMAT_NV21:\n\tcase IA_CSS_FRAME_FORMAT_NV61:\n\tcase IA_CSS_FRAME_FORMAT_YV12:\n\tcase IA_CSS_FRAME_FORMAT_YV16:\n\tcase IA_CSS_FRAME_FORMAT_YUV420:\n\tcase IA_CSS_FRAME_FORMAT_YUV420_16:\n\tcase IA_CSS_FRAME_FORMAT_YUV422:\n\tcase IA_CSS_FRAME_FORMAT_YUV422_16:\n\tcase IA_CSS_FRAME_FORMAT_YUV444:\n\tcase IA_CSS_FRAME_FORMAT_YUV_LINE:\n\tcase IA_CSS_FRAME_FORMAT_PLANAR_RGB888:\n\tcase IA_CSS_FRAME_FORMAT_QPLANE6:\n\tcase IA_CSS_FRAME_FORMAT_BINARY_8:\n\tdefault:\n\t\treturn bytesperline;\n\t}\n}\n\nstatic int\natomisp_v4l2_framebuffer_to_css_frame(const struct v4l2_framebuffer *arg,\n\t\t\t\t      struct ia_css_frame **result)\n{\n\tstruct ia_css_frame *res = NULL;\n\tunsigned int padded_width;\n\tenum ia_css_frame_format sh_format;\n\tchar *tmp_buf = NULL;\n\tint ret = 0;\n\n\tsh_format = v4l2_fmt_to_sh_fmt(arg->fmt.pixelformat);\n\tpadded_width = atomisp_bytesperline_to_padded_width(\n\t\t\t   arg->fmt.bytesperline, sh_format);\n\n\t \n\tif (ia_css_frame_allocate(&res, arg->fmt.width, arg->fmt.height,\n\t\t\t\t       sh_format, padded_width, 0)) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\ttmp_buf = vmalloc(arg->fmt.sizeimage);\n\tif (!tmp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (copy_from_user(tmp_buf, (void __user __force *)arg->base,\n\t\t\t   arg->fmt.sizeimage)) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tif (hmm_store(res->data, tmp_buf, arg->fmt.sizeimage)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\nerr:\n\tif (ret && res)\n\t\tia_css_frame_free(res);\n\tvfree(tmp_buf);\n\tif (ret == 0)\n\t\t*result = res;\n\treturn ret;\n}\n\n \nint atomisp_fixed_pattern_table(struct atomisp_sub_device *asd,\n\t\t\t\tstruct v4l2_framebuffer *arg)\n{\n\tstruct ia_css_frame *raw_black_frame = NULL;\n\tint ret;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tret = atomisp_v4l2_framebuffer_to_css_frame(arg, &raw_black_frame);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sh_css_set_black_frame(asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t\t\t\t   raw_black_frame) != 0)\n\t\treturn -ENOMEM;\n\n\tia_css_frame_free(raw_black_frame);\n\treturn ret;\n}\n\n \nint atomisp_false_color(struct atomisp_sub_device *asd, int flag,\n\t\t\t__s32 *value)\n{\n\t \n\tif (flag == 0) {\n\t\t*value = asd->params.false_color;\n\t\treturn 0;\n\t}\n\n\t \n\tif (*value) {\n\t\tasd->params.config.de_config = NULL;\n\t} else {\n\t\tasd->params.css_param.de_config.pixelnoise = 0;\n\t\tasd->params.config.de_config = &asd->params.css_param.de_config;\n\t}\n\tasd->params.css_update_params_needed = true;\n\tasd->params.false_color = *value;\n\treturn 0;\n}\n\n \nint atomisp_false_color_param(struct atomisp_sub_device *asd, int flag,\n\t\t\t      struct atomisp_de_config *config)\n{\n\tif (flag == 0) {\n\t\t \n\t\tif (atomisp_css_get_de_config(asd, config))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tmemcpy(&asd->params.css_param.de_config, config,\n\t\t       sizeof(asd->params.css_param.de_config));\n\t\tasd->params.config.de_config = &asd->params.css_param.de_config;\n\t\tasd->params.css_update_params_needed = true;\n\t}\n\n\treturn 0;\n}\n\n \nint atomisp_white_balance_param(struct atomisp_sub_device *asd, int flag,\n\t\t\t\tstruct atomisp_wb_config *config)\n{\n\tif (flag == 0) {\n\t\t \n\t\tif (atomisp_css_get_wb_config(asd, config))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tmemcpy(&asd->params.css_param.wb_config, config,\n\t\t       sizeof(asd->params.css_param.wb_config));\n\t\tasd->params.config.wb_config = &asd->params.css_param.wb_config;\n\t\tasd->params.css_update_params_needed = true;\n\t}\n\n\treturn 0;\n}\n\nint atomisp_3a_config_param(struct atomisp_sub_device *asd, int flag,\n\t\t\t    struct atomisp_3a_config *config)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\n\tdev_dbg(isp->dev, \">%s %d\\n\", __func__, flag);\n\n\tif (flag == 0) {\n\t\t \n\t\tif (atomisp_css_get_3a_config(asd, config))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tmemcpy(&asd->params.css_param.s3a_config, config,\n\t\t       sizeof(asd->params.css_param.s3a_config));\n\t\tasd->params.config.s3a_config = &asd->params.css_param.s3a_config;\n\t\tasd->params.css_update_params_needed = true;\n\t}\n\n\tdev_dbg(isp->dev, \"<%s %d\\n\", __func__, flag);\n\treturn 0;\n}\n\n \nint atomisp_digital_zoom(struct atomisp_sub_device *asd, int flag,\n\t\t\t __s32 *value)\n{\n\tu32 zoom;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tunsigned int max_zoom = MRFLD_MAX_ZOOM_FACTOR;\n\n\tif (flag == 0) {\n\t\tatomisp_css_get_zoom_factor(asd, &zoom);\n\t\t*value = max_zoom - zoom;\n\t} else {\n\t\tif (*value < 0)\n\t\t\treturn -EINVAL;\n\n\t\tzoom = max_zoom - min_t(u32, max_zoom - 1, *value);\n\t\tatomisp_css_set_zoom_factor(asd, zoom);\n\n\t\tdev_dbg(isp->dev, \"%s, zoom: %d\\n\", __func__, zoom);\n\t\tasd->params.css_update_params_needed = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void __atomisp_update_stream_env(struct atomisp_sub_device *asd,\n\t\t\t\t\tu16 stream_index, struct atomisp_input_stream_info *stream_info)\n{\n\tint i;\n\n\t \n\tasd->stream_env[stream_index].ch_id = stream_info->ch_id;\n\tasd->stream_env[stream_index].isys_configs = stream_info->isys_configs;\n\tfor (i = 0; i < stream_info->isys_configs; i++) {\n\t\tasd->stream_env[stream_index].isys_info[i].input_format =\n\t\t    stream_info->isys_info[i].input_format;\n\t\tasd->stream_env[stream_index].isys_info[i].width =\n\t\t    stream_info->isys_info[i].width;\n\t\tasd->stream_env[stream_index].isys_info[i].height =\n\t\t    stream_info->isys_info[i].height;\n\t}\n}\n\nstatic void __atomisp_init_stream_info(u16 stream_index,\n\t\t\t\t       struct atomisp_input_stream_info *stream_info)\n{\n\tint i;\n\n\tstream_info->enable = 1;\n\tstream_info->stream = stream_index;\n\tstream_info->ch_id = 0;\n\tstream_info->isys_configs = 0;\n\tfor (i = 0; i < MAX_STREAMS_PER_CHANNEL; i++) {\n\t\tstream_info->isys_info[i].input_format = 0;\n\t\tstream_info->isys_info[i].width = 0;\n\t\tstream_info->isys_info[i].height = 0;\n\t}\n}\n\nstatic void atomisp_fill_pix_format(struct v4l2_pix_format *f,\n\t\t\t\t    u32 width, u32 height,\n\t\t\t\t    const struct atomisp_format_bridge *br_fmt)\n{\n\tu32 bytes;\n\n\tf->width = width;\n\tf->height = height;\n\tf->pixelformat = br_fmt->pixelformat;\n\n\t \n\twidth = ia_css_frame_pad_width(width, br_fmt->sh_fmt);\n\tbytes = BITS_TO_BYTES(br_fmt->depth * width);\n\n\tif (br_fmt->planar)\n\t\tf->bytesperline = width;\n\telse\n\t\tf->bytesperline = bytes;\n\n\tf->sizeimage = PAGE_ALIGN(height * bytes);\n\n\tif (f->field == V4L2_FIELD_ANY)\n\t\tf->field = V4L2_FIELD_NONE;\n\n\t \n\tf->colorspace = V4L2_COLORSPACE_REC709;\n\tf->ycbcr_enc = V4L2_YCBCR_ENC_709;\n\tf->xfer_func = V4L2_XFER_FUNC_709;\n}\n\n \nvoid atomisp_get_padding(struct atomisp_device *isp, u32 width, u32 height,\n\t\t\t u32 *padding_w, u32 *padding_h)\n{\n\tstruct atomisp_input_subdev *input = &isp->inputs[isp->asd.input_curr];\n\tstruct v4l2_rect native_rect = input->native_rect;\n\tconst struct atomisp_in_fmt_conv *fc = NULL;\n\tu32 min_pad_w = ISP2400_MIN_PAD_W;\n\tu32 min_pad_h = ISP2400_MIN_PAD_H;\n\tstruct v4l2_mbus_framefmt *sink;\n\n\tif (!input->crop_support) {\n\t\t*padding_w = pad_w;\n\t\t*padding_h = pad_h;\n\t\treturn;\n\t}\n\n\twidth = min(width, input->active_rect.width);\n\theight = min(height, input->active_rect.height);\n\n\tif (input->binning_support && width <= (input->active_rect.width / 2) &&\n\t\t\t\t      height <= (input->active_rect.height / 2)) {\n\t\tnative_rect.width /= 2;\n\t\tnative_rect.height /= 2;\n\t}\n\n\t*padding_w = min_t(u32, (native_rect.width - width) & ~1, pad_w);\n\t*padding_h = min_t(u32, (native_rect.height - height) & ~1, pad_h);\n\n\t \n\tif (IS_ISP2401)\n\t\treturn;\n\n\tsink = atomisp_subdev_get_ffmt(&isp->asd.subdev, NULL, V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t\t       ATOMISP_SUBDEV_PAD_SINK);\n\tif (sink)\n\t\tfc = atomisp_find_in_fmt_conv(sink->code);\n\tif (!fc) {\n\t\tdev_warn(isp->dev, \"%s: Could not get sensor format\\n\", __func__);\n\t\tgoto apply_min_padding;\n\t}\n\n\t \n\tif (fc->bayer_order == IA_CSS_BAYER_ORDER_RGGB ||\n\t    fc->bayer_order == IA_CSS_BAYER_ORDER_GBRG)\n\t\tmin_pad_w += 2;\n\n\tif (fc->bayer_order == IA_CSS_BAYER_ORDER_BGGR ||\n\t    fc->bayer_order == IA_CSS_BAYER_ORDER_GBRG)\n\t\tmin_pad_h += 2;\n\napply_min_padding:\n\t*padding_w = max_t(u32, *padding_w, min_pad_w);\n\t*padding_h = max_t(u32, *padding_h, min_pad_h);\n}\n\nstatic int atomisp_set_crop(struct atomisp_device *isp,\n\t\t\t    const struct v4l2_mbus_framefmt *format,\n\t\t\t    int which)\n{\n\tstruct atomisp_input_subdev *input = &isp->inputs[isp->asd.input_curr];\n\tstruct v4l2_subdev_state pad_state = {\n\t\t.pads = &input->pad_cfg,\n\t};\n\tstruct v4l2_subdev_selection sel = {\n\t\t.which = which,\n\t\t.target = V4L2_SEL_TGT_CROP,\n\t\t.r.width = format->width,\n\t\t.r.height = format->height,\n\t};\n\tint ret;\n\n\tif (!input->crop_support)\n\t\treturn 0;\n\n\t \n\tif (input->binning_support && sel.r.width <= (input->native_rect.width / 2) &&\n\t\t\t\t      sel.r.height <= (input->native_rect.height / 2)) {\n\t\tsel.r.width *= 2;\n\t\tsel.r.height *= 2;\n\t}\n\n\t \n\tsel.r.width = min(sel.r.width, input->native_rect.width);\n\tsel.r.height = min(sel.r.height, input->native_rect.height);\n\n\tsel.r.left = ((input->native_rect.width - sel.r.width) / 2) & ~1;\n\tsel.r.top = ((input->native_rect.height - sel.r.height) / 2) & ~1;\n\n\tret = v4l2_subdev_call(input->camera, pad, set_selection, &pad_state, &sel);\n\tif (ret)\n\t\tdev_err(isp->dev, \"Error setting crop to %ux%u @%ux%u: %d\\n\",\n\t\t\tsel.r.width, sel.r.height, sel.r.left, sel.r.top, ret);\n\n\treturn ret;\n}\n\n \nint atomisp_try_fmt(struct atomisp_device *isp, struct v4l2_pix_format *f,\n\t\t    const struct atomisp_format_bridge **fmt_ret,\n\t\t    const struct atomisp_format_bridge **snr_fmt_ret)\n{\n\tconst struct atomisp_format_bridge *fmt, *snr_fmt;\n\tstruct atomisp_sub_device *asd = &isp->asd;\n\tstruct atomisp_input_subdev *input = &isp->inputs[asd->input_curr];\n\tstruct v4l2_subdev_state pad_state = {\n\t\t.pads = &input->pad_cfg,\n\t};\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tu32 padding_w, padding_h;\n\tint ret;\n\n\tif (!input->camera)\n\t\treturn -EINVAL;\n\n\tfmt = atomisp_get_format_bridge(f->pixelformat);\n\t \n\tif (!fmt || fmt->sh_fmt == IA_CSS_FRAME_FORMAT_RAW) {\n\t\tf->pixelformat = V4L2_PIX_FMT_YUV420;\n\n\t\tfmt = atomisp_get_format_bridge(f->pixelformat);\n\t\tif (!fmt)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tatomisp_get_padding(isp, f->width, f->height, &padding_w, &padding_h);\n\tv4l2_fill_mbus_format(&format.format, f, fmt->mbus_code);\n\tformat.format.width += padding_w;\n\tformat.format.height += padding_h;\n\n\tdev_dbg(isp->dev, \"try_mbus_fmt: asking for %ux%u\\n\",\n\t\tformat.format.width, format.format.height);\n\n\tret = atomisp_set_crop(isp, &format.format, V4L2_SUBDEV_FORMAT_TRY);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_subdev_call(input->camera, pad, set_fmt, &pad_state, &format);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(isp->dev, \"try_mbus_fmt: got %ux%u\\n\",\n\t\tformat.format.width, format.format.height);\n\n\tsnr_fmt = atomisp_get_format_bridge_from_mbus(format.format.code);\n\tif (!snr_fmt) {\n\t\tdev_err(isp->dev, \"unknown sensor format 0x%8.8x\\n\",\n\t\t\tformat.format.code);\n\t\treturn -EINVAL;\n\t}\n\n\tf->width = format.format.width - padding_w;\n\tf->height = format.format.height - padding_h;\n\n\t \n\tif (f->pixelformat == V4L2_PIX_FMT_JPEG ||\n\t    f->pixelformat == V4L2_PIX_FMT_CUSTOM_M10MO_RAW)\n\t\tgoto out_fill_pix_format;\n\n\t \n\tf->width = rounddown(clamp_t(u32, f->width, ATOM_ISP_MIN_WIDTH,\n\t\t\t\t     ATOM_ISP_MAX_WIDTH), ATOM_ISP_STEP_WIDTH);\n\tf->height = rounddown(clamp_t(u32, f->height, ATOM_ISP_MIN_HEIGHT,\n\t\t\t\t      ATOM_ISP_MAX_HEIGHT), ATOM_ISP_STEP_HEIGHT);\n\nout_fill_pix_format:\n\tatomisp_fill_pix_format(f, f->width, f->height, fmt);\n\n\tif (fmt_ret)\n\t\t*fmt_ret = fmt;\n\n\tif (snr_fmt_ret)\n\t\t*snr_fmt_ret = snr_fmt;\n\n\treturn 0;\n}\n\nenum mipi_port_id atomisp_port_to_mipi_port(struct atomisp_device *isp,\n\t\t\t\t\t    enum atomisp_camera_port port)\n{\n\tswitch (port) {\n\tcase ATOMISP_CAMERA_PORT_PRIMARY:\n\t\treturn MIPI_PORT0_ID;\n\tcase ATOMISP_CAMERA_PORT_SECONDARY:\n\t\treturn MIPI_PORT1_ID;\n\tcase ATOMISP_CAMERA_PORT_TERTIARY:\n\t\treturn MIPI_PORT2_ID;\n\tdefault:\n\t\tdev_err(isp->dev, \"unsupported port: %d\\n\", port);\n\t\treturn MIPI_PORT0_ID;\n\t}\n}\n\nstatic inline int atomisp_set_sensor_mipi_to_isp(\n    struct atomisp_sub_device *asd,\n    enum atomisp_input_stream_id stream_id,\n    struct camera_mipi_info *mipi_info)\n{\n\tstruct v4l2_control ctrl;\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct atomisp_input_subdev *input = &isp->inputs[asd->input_curr];\n\tconst struct atomisp_in_fmt_conv *fc;\n\tint mipi_freq = 0;\n\tunsigned int input_format, bayer_order;\n\tenum atomisp_input_format metadata_format = ATOMISP_INPUT_FORMAT_EMBEDDED;\n\tu32 mipi_port, metadata_width = 0, metadata_height = 0;\n\n\tctrl.id = V4L2_CID_LINK_FREQ;\n\tif (v4l2_g_ctrl(input->camera->ctrl_handler, &ctrl) == 0)\n\t\tmipi_freq = ctrl.value;\n\n\tif (asd->stream_env[stream_id].isys_configs == 1) {\n\t\tinput_format =\n\t\t    asd->stream_env[stream_id].isys_info[0].input_format;\n\t\tatomisp_css_isys_set_format(asd, stream_id,\n\t\t\t\t\t    input_format, IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX);\n\t} else if (asd->stream_env[stream_id].isys_configs == 2) {\n\t\tatomisp_css_isys_two_stream_cfg_update_stream1(\n\t\t    asd, stream_id,\n\t\t    asd->stream_env[stream_id].isys_info[0].input_format,\n\t\t    asd->stream_env[stream_id].isys_info[0].width,\n\t\t    asd->stream_env[stream_id].isys_info[0].height);\n\n\t\tatomisp_css_isys_two_stream_cfg_update_stream2(\n\t\t    asd, stream_id,\n\t\t    asd->stream_env[stream_id].isys_info[1].input_format,\n\t\t    asd->stream_env[stream_id].isys_info[1].width,\n\t\t    asd->stream_env[stream_id].isys_info[1].height);\n\t}\n\n\t \n\tif (mipi_info && mipi_info->input_format != -1) {\n\t\tbayer_order = mipi_info->raw_bayer_order;\n\n\t\t \n\t\t \n\t\tfc = atomisp_find_in_fmt_conv_by_atomisp_in_fmt(\n\t\t\t mipi_info->input_format);\n\t\tif (!fc)\n\t\t\treturn -EINVAL;\n\t\tinput_format = fc->atomisp_in_fmt;\n\t\tmetadata_format = mipi_info->metadata_format;\n\t\tmetadata_width = mipi_info->metadata_width;\n\t\tmetadata_height = mipi_info->metadata_height;\n\t} else {\n\t\tstruct v4l2_mbus_framefmt *sink;\n\n\t\tsink = atomisp_subdev_get_ffmt(&asd->subdev, NULL,\n\t\t\t\t\t       V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t\t\t       ATOMISP_SUBDEV_PAD_SINK);\n\t\tfc = atomisp_find_in_fmt_conv(sink->code);\n\t\tif (!fc)\n\t\t\treturn -EINVAL;\n\t\tinput_format = fc->atomisp_in_fmt;\n\t\tbayer_order = fc->bayer_order;\n\t}\n\n\tatomisp_css_input_set_format(asd, stream_id, input_format);\n\tatomisp_css_input_set_bayer_order(asd, stream_id, bayer_order);\n\n\tfc = atomisp_find_in_fmt_conv_by_atomisp_in_fmt(metadata_format);\n\tif (!fc)\n\t\treturn -EINVAL;\n\n\tinput_format = fc->atomisp_in_fmt;\n\tmipi_port = atomisp_port_to_mipi_port(isp, input->port);\n\tatomisp_css_input_configure_port(asd, mipi_port,\n\t\t\t\t\t isp->sensor_lanes[mipi_port],\n\t\t\t\t\t 0xffff4, mipi_freq,\n\t\t\t\t\t input_format,\n\t\t\t\t\t metadata_width, metadata_height);\n\treturn 0;\n}\n\nstatic int configure_pp_input_nop(struct atomisp_sub_device *asd,\n\t\t\t\t  unsigned int width, unsigned int height)\n{\n\treturn 0;\n}\n\nstatic int configure_output_nop(struct atomisp_sub_device *asd,\n\t\t\t\tunsigned int width, unsigned int height,\n\t\t\t\tunsigned int min_width,\n\t\t\t\tenum ia_css_frame_format sh_fmt)\n{\n\treturn 0;\n}\n\nstatic int get_frame_info_nop(struct atomisp_sub_device *asd,\n\t\t\t      struct ia_css_frame_info *finfo)\n{\n\treturn 0;\n}\n\n \nstatic int css_input_resolution_changed(struct atomisp_sub_device *asd,\n\t\t\t\t\tstruct v4l2_mbus_framefmt *ffmt)\n{\n\tstruct atomisp_metadata_buf *md_buf = NULL, *_md_buf;\n\tunsigned int i;\n\n\tdev_dbg(asd->isp->dev, \"css_input_resolution_changed to %ux%u\\n\",\n\t\tffmt->width, ffmt->height);\n\n\tif (IS_ISP2401)\n\t\tatomisp_css_input_set_two_pixels_per_clock(asd, false);\n\telse\n\t\tatomisp_css_input_set_two_pixels_per_clock(asd, true);\n\n\t \n\tfor (i = 0; i < ATOMISP_METADATA_TYPE_NUM; i++) {\n\t\tlist_for_each_entry_safe(md_buf, _md_buf, &asd->metadata[i],\n\t\t\t\t\t list) {\n\t\t\tatomisp_css_free_metadata_buffer(md_buf);\n\t\t\tlist_del(&md_buf->list);\n\t\t\tkfree(md_buf);\n\t\t}\n\t}\n\treturn 0;\n\n\t \n}\n\nstatic int atomisp_set_fmt_to_isp(struct video_device *vdev,\n\t\t\t\t  struct ia_css_frame_info *output_info,\n\t\t\t\t  const struct v4l2_pix_format *pix)\n{\n\tstruct camera_mipi_info *mipi_info;\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;\n\tstruct atomisp_input_subdev *input = &isp->inputs[asd->input_curr];\n\tconst struct atomisp_format_bridge *format;\n\tstruct v4l2_rect *isp_sink_crop;\n\tenum ia_css_pipe_id pipe_id;\n\tint (*configure_output)(struct atomisp_sub_device *asd,\n\t\t\t\tunsigned int width, unsigned int height,\n\t\t\t\tunsigned int min_width,\n\t\t\t\tenum ia_css_frame_format sh_fmt) =\n\t\t\t\t    configure_output_nop;\n\tint (*get_frame_info)(struct atomisp_sub_device *asd,\n\t\t\t      struct ia_css_frame_info *finfo) =\n\t\t\t\t  get_frame_info_nop;\n\tint (*configure_pp_input)(struct atomisp_sub_device *asd,\n\t\t\t\t  unsigned int width, unsigned int height) =\n\t\t\t\t      configure_pp_input_nop;\n\tconst struct atomisp_in_fmt_conv *fc = NULL;\n\tint ret, i;\n\n\tisp_sink_crop = atomisp_subdev_get_rect(\n\t\t\t    &asd->subdev, NULL, V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t    ATOMISP_SUBDEV_PAD_SINK, V4L2_SEL_TGT_CROP);\n\n\tformat = atomisp_get_format_bridge(pix->pixelformat);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\tif (input->type != TEST_PATTERN) {\n\t\tmipi_info = atomisp_to_sensor_mipi_info(input->camera);\n\n\t\tif (atomisp_set_sensor_mipi_to_isp(asd, ATOMISP_INPUT_STREAM_GENERAL,\n\t\t\t\t\t\t   mipi_info))\n\t\t\treturn -EINVAL;\n\n\t\tif (mipi_info)\n\t\t\tfc = atomisp_find_in_fmt_conv_by_atomisp_in_fmt(mipi_info->input_format);\n\n\t\tif (!fc)\n\t\t\tfc = atomisp_find_in_fmt_conv(\n\t\t\t\t atomisp_subdev_get_ffmt(&asd->subdev,\n\t\t\t\t\t\t\t NULL, V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t\t\t\t\t ATOMISP_SUBDEV_PAD_SINK)->code);\n\t\tif (!fc)\n\t\t\treturn -EINVAL;\n\t\tif (format->sh_fmt == IA_CSS_FRAME_FORMAT_RAW &&\n\t\t    raw_output_format_match_input(fc->atomisp_in_fmt,\n\t\t\t\t\t\t  pix->pixelformat))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\t{\n\t\tu32 width, height;\n\n\t\tif (pix->width < 640 || pix->height < 480) {\n\t\t\twidth = pix->width;\n\t\t\theight = pix->height;\n\t\t} else {\n\t\t\twidth = 640;\n\t\t\theight = 480;\n\t\t}\n\n\t\tif (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO ||\n\t\t    asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER) {\n\t\t\tatomisp_css_video_configure_viewfinder(asd, width, height, 0,\n\t\t\t\t\t\t\t       IA_CSS_FRAME_FORMAT_NV12);\n\t\t} else if (asd->run_mode->val == ATOMISP_RUN_MODE_STILL_CAPTURE ||\n\t\t\t   asd->vfpp->val == ATOMISP_VFPP_DISABLE_LOWLAT) {\n\t\t\tatomisp_css_capture_configure_viewfinder(asd, width, height, 0,\n\t\t\t\t\t\t\t\t IA_CSS_FRAME_FORMAT_NV12);\n\t\t}\n\t}\n\n\tatomisp_css_input_set_mode(asd, IA_CSS_INPUT_MODE_BUFFERED_SENSOR);\n\n\tfor (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)\n\t\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].pipe_extra_configs[i].disable_vf_pp = asd->vfpp->val != ATOMISP_VFPP_ENABLE;\n\n\t \n\tif (asd->copy_mode) {\n\t\tpipe_id = IA_CSS_PIPE_ID_COPY;\n\t\tatomisp_css_capture_enable_online(asd, ATOMISP_INPUT_STREAM_GENERAL, false);\n\t} else if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER) {\n\t\t \n\t\tconfigure_output = atomisp_css_video_configure_output;\n\t\tget_frame_info = atomisp_css_video_get_output_frame_info;\n\t\tpipe_id = IA_CSS_PIPE_ID_VIDEO;\n\t} else if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {\n\t\tconfigure_output = atomisp_css_video_configure_output;\n\t\tget_frame_info = atomisp_css_video_get_output_frame_info;\n\t\tpipe_id = IA_CSS_PIPE_ID_VIDEO;\n\t} else if (asd->run_mode->val == ATOMISP_RUN_MODE_PREVIEW) {\n\t\tconfigure_output = atomisp_css_preview_configure_output;\n\t\tget_frame_info = atomisp_css_preview_get_output_frame_info;\n\t\tconfigure_pp_input = atomisp_css_preview_configure_pp_input;\n\t\tpipe_id = IA_CSS_PIPE_ID_PREVIEW;\n\t} else {\n\t\tif (format->sh_fmt == IA_CSS_FRAME_FORMAT_RAW) {\n\t\t\tatomisp_css_capture_set_mode(asd, IA_CSS_CAPTURE_MODE_RAW);\n\t\t\tatomisp_css_enable_dz(asd, false);\n\t\t} else {\n\t\t\tatomisp_update_capture_mode(asd);\n\t\t}\n\n\t\t \n\t\tatomisp_css_capture_enable_online(asd, ATOMISP_INPUT_STREAM_GENERAL,\n\t\t\t\t\t\t  !asd->params.low_light);\n\n\t\tconfigure_output = atomisp_css_capture_configure_output;\n\t\tget_frame_info = atomisp_css_capture_get_output_frame_info;\n\t\tconfigure_pp_input = atomisp_css_capture_configure_pp_input;\n\t\tpipe_id = IA_CSS_PIPE_ID_CAPTURE;\n\n\t\tif (asd->run_mode->val != ATOMISP_RUN_MODE_STILL_CAPTURE) {\n\t\t\tdev_err(isp->dev,\n\t\t\t\t\"Need to set the running mode first\\n\");\n\t\t\tasd->run_mode->val = ATOMISP_RUN_MODE_STILL_CAPTURE;\n\t\t}\n\t}\n\n\tif (asd->copy_mode)\n\t\tret = atomisp_css_copy_configure_output(asd, ATOMISP_INPUT_STREAM_GENERAL,\n\t\t\t\t\t\t\tpix->width, pix->height,\n\t\t\t\t\t\t\tformat->planar ? pix->bytesperline :\n\t\t\t\t\t\t\tpix->bytesperline * 8 / format->depth,\n\t\t\t\t\t\t\tformat->sh_fmt);\n\telse\n\t\tret = configure_output(asd, pix->width, pix->height,\n\t\t\t\t       format->planar ? pix->bytesperline :\n\t\t\t\t       pix->bytesperline * 8 / format->depth,\n\t\t\t\t       format->sh_fmt);\n\tif (ret) {\n\t\tdev_err(isp->dev, \"configure_output %ux%u, format %8.8x\\n\",\n\t\t\tpix->width, pix->height, format->sh_fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tret = configure_pp_input(asd, isp_sink_crop->width, isp_sink_crop->height);\n\tif (ret) {\n\t\tdev_err(isp->dev, \"configure_pp_input %ux%u\\n\",\n\t\t\tisp_sink_crop->width,\n\t\t\tisp_sink_crop->height);\n\t\treturn -EINVAL;\n\t}\n\tif (asd->copy_mode)\n\t\tret = atomisp_css_copy_get_output_frame_info(asd,\n\t\t\t\t\t\t\t     ATOMISP_INPUT_STREAM_GENERAL,\n\t\t\t\t\t\t\t     output_info);\n\telse\n\t\tret = get_frame_info(asd, output_info);\n\tif (ret) {\n\t\tdev_err(isp->dev, \"__get_frame_info %ux%u (padded to %u) returned %d\\n\",\n\t\t\tpix->width, pix->height, pix->bytesperline, ret);\n\t\treturn ret;\n\t}\n\n\tatomisp_update_grid_info(asd, pipe_id);\n\treturn 0;\n}\n\nstatic void atomisp_get_dis_envelop(struct atomisp_sub_device *asd,\n\t\t\t\t    unsigned int width, unsigned int height,\n\t\t\t\t    unsigned int *dvs_env_w, unsigned int *dvs_env_h)\n{\n\tif (asd->params.video_dis_en &&\n\t    asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {\n\t\t \n\t\t \n\t\t*dvs_env_w = rounddown(width / 5, ATOM_ISP_STEP_WIDTH);\n\t\t*dvs_env_h = rounddown(height / 5, ATOM_ISP_STEP_HEIGHT);\n\t}\n\n\tasd->params.dis_proj_data_valid = false;\n\tasd->params.css_update_params_needed = true;\n}\n\nstatic void atomisp_check_copy_mode(struct atomisp_sub_device *asd,\n\t\t\t\t    const struct v4l2_pix_format *f)\n{\n\tstruct v4l2_mbus_framefmt *sink, *src;\n\n\tif (!IS_ISP2401) {\n\t\t \n\t\tasd->copy_mode = false;\n\t\treturn;\n\t}\n\n\tsink = atomisp_subdev_get_ffmt(&asd->subdev, NULL,\n\t\t\t\t       V4L2_SUBDEV_FORMAT_ACTIVE, ATOMISP_SUBDEV_PAD_SINK);\n\tsrc = atomisp_subdev_get_ffmt(&asd->subdev, NULL,\n\t\t\t\t      V4L2_SUBDEV_FORMAT_ACTIVE, ATOMISP_SUBDEV_PAD_SOURCE);\n\n\tif (sink->code == src->code && sink->width == f->width && sink->height == f->height)\n\t\tasd->copy_mode = true;\n\telse\n\t\tasd->copy_mode = false;\n\n\tdev_dbg(asd->isp->dev, \"copy_mode: %d\\n\", asd->copy_mode);\n}\n\nstatic int atomisp_set_fmt_to_snr(struct video_device *vdev, const struct v4l2_pix_format *f,\n\t\t\t\t  unsigned int dvs_env_w, unsigned int dvs_env_h)\n{\n\tstruct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);\n\tstruct atomisp_sub_device *asd = pipe->asd;\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct atomisp_input_subdev *input = &isp->inputs[asd->input_curr];\n\tconst struct atomisp_format_bridge *format;\n\tstruct v4l2_subdev_state pad_state = {\n\t\t.pads = &input->pad_cfg,\n\t};\n\tstruct v4l2_subdev_format vformat = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tstruct v4l2_mbus_framefmt *ffmt = &vformat.format;\n\tstruct v4l2_mbus_framefmt *req_ffmt;\n\tstruct atomisp_input_stream_info *stream_info =\n\t    (struct atomisp_input_stream_info *)ffmt->reserved;\n\tint ret;\n\n\tformat = atomisp_get_format_bridge(f->pixelformat);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\tv4l2_fill_mbus_format(ffmt, f, format->mbus_code);\n\tffmt->height += asd->sink_pad_padding_h + dvs_env_h;\n\tffmt->width += asd->sink_pad_padding_w + dvs_env_w;\n\n\tdev_dbg(isp->dev, \"s_mbus_fmt: ask %ux%u (padding %ux%u, dvs %ux%u)\\n\",\n\t\tffmt->width, ffmt->height, asd->sink_pad_padding_w, asd->sink_pad_padding_h,\n\t\tdvs_env_w, dvs_env_h);\n\n\t__atomisp_init_stream_info(ATOMISP_INPUT_STREAM_GENERAL, stream_info);\n\n\treq_ffmt = ffmt;\n\n\t \n\tif (asd->params.video_dis_en && asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {\n\t\tret = atomisp_set_crop(isp, &vformat.format, V4L2_SUBDEV_FORMAT_TRY);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvformat.which = V4L2_SUBDEV_FORMAT_TRY;\n\t\tret = v4l2_subdev_call(input->camera, pad, set_fmt, &pad_state, &vformat);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdev_dbg(isp->dev, \"video dis: sensor width: %d, height: %d\\n\",\n\t\t\tffmt->width, ffmt->height);\n\n\t\tif (ffmt->width < req_ffmt->width ||\n\t\t    ffmt->height < req_ffmt->height) {\n\t\t\treq_ffmt->height -= dvs_env_h;\n\t\t\treq_ffmt->width -= dvs_env_w;\n\t\t\tffmt = req_ffmt;\n\t\t\tdev_warn(isp->dev,\n\t\t\t\t \"can not enable video dis due to sensor limitation.\");\n\t\t\tasd->params.video_dis_en = false;\n\t\t}\n\t}\n\n\tret = atomisp_set_crop(isp, &vformat.format, V4L2_SUBDEV_FORMAT_ACTIVE);\n\tif (ret)\n\t\treturn ret;\n\n\tvformat.which = V4L2_SUBDEV_FORMAT_ACTIVE;\n\tret = v4l2_subdev_call(input->camera, pad, set_fmt, NULL, &vformat);\n\tif (ret)\n\t\treturn ret;\n\n\t__atomisp_update_stream_env(asd, ATOMISP_INPUT_STREAM_GENERAL, stream_info);\n\n\tdev_dbg(isp->dev, \"sensor width: %d, height: %d\\n\",\n\t\tffmt->width, ffmt->height);\n\n\tif (ffmt->width < ATOM_ISP_STEP_WIDTH ||\n\t    ffmt->height < ATOM_ISP_STEP_HEIGHT)\n\t\treturn -EINVAL;\n\n\tif (asd->params.video_dis_en && asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO &&\n\t    (ffmt->width < req_ffmt->width || ffmt->height < req_ffmt->height)) {\n\t\tdev_warn(isp->dev,\n\t\t\t \"can not enable video dis due to sensor limitation.\");\n\t\tasd->params.video_dis_en = false;\n\t}\n\n\tatomisp_subdev_set_ffmt(&asd->subdev, NULL,\n\t\t\t\tV4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t\tATOMISP_SUBDEV_PAD_SINK, ffmt);\n\n\treturn css_input_resolution_changed(asd, ffmt);\n}\n\nint atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *f)\n{\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);\n\tstruct atomisp_sub_device *asd = pipe->asd;\n\tconst struct atomisp_format_bridge *format_bridge;\n\tconst struct atomisp_format_bridge *snr_format_bridge;\n\tstruct ia_css_frame_info output_info;\n\tunsigned int dvs_env_w = 0, dvs_env_h = 0;\n\tstruct v4l2_mbus_framefmt isp_source_fmt = {0};\n\tstruct v4l2_rect isp_sink_crop;\n\tint ret;\n\n\tret = atomisp_pipe_check(pipe, true);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(isp->dev,\n\t\t\"setting resolution %ux%u bytesperline %u\\n\",\n\t\tf->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.bytesperline);\n\n\t \n\tret = atomisp_try_fmt(isp, &f->fmt.pix, &format_bridge, &snr_format_bridge);\n\tif (ret)\n\t\treturn ret;\n\n\tpipe->sh_fmt = format_bridge->sh_fmt;\n\tpipe->pix.pixelformat = format_bridge->pixelformat;\n\n\tatomisp_subdev_get_ffmt(&asd->subdev, NULL,\n\t\t\t\tV4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t\tATOMISP_SUBDEV_PAD_SINK)->code =\n\t\t\t\t    snr_format_bridge->mbus_code;\n\n\tisp_source_fmt.code = format_bridge->mbus_code;\n\tatomisp_subdev_set_ffmt(&asd->subdev, NULL,\n\t\t\t\tV4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t\tATOMISP_SUBDEV_PAD_SOURCE, &isp_source_fmt);\n\n\tif (atomisp_subdev_format_conversion(asd)) {\n\t\tatomisp_get_padding(isp, f->fmt.pix.width, f->fmt.pix.height,\n\t\t\t\t    &asd->sink_pad_padding_w, &asd->sink_pad_padding_h);\n\t} else {\n\t\tasd->sink_pad_padding_w = 0;\n\t\tasd->sink_pad_padding_h = 0;\n\t}\n\n\tatomisp_get_dis_envelop(asd, f->fmt.pix.width, f->fmt.pix.height,\n\t\t\t\t&dvs_env_w, &dvs_env_h);\n\n\tret = atomisp_set_fmt_to_snr(vdev, &f->fmt.pix, dvs_env_w, dvs_env_h);\n\tif (ret) {\n\t\tdev_warn(isp->dev,\n\t\t\t \"Set format to sensor failed with %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tatomisp_csi_lane_config(isp);\n\n\tatomisp_check_copy_mode(asd, &f->fmt.pix);\n\n\tisp_sink_crop = *atomisp_subdev_get_rect(&asd->subdev, NULL,\n\t\t\tV4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\tATOMISP_SUBDEV_PAD_SINK,\n\t\t\tV4L2_SEL_TGT_CROP);\n\n\t \n\tif (!IS_MOFD ||\n\t    isp_sink_crop.width * 9 / 10 < f->fmt.pix.width ||\n\t    isp_sink_crop.height * 9 / 10 < f->fmt.pix.height ||\n\t    (atomisp_subdev_format_conversion(asd) &&\n\t     (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO ||\n\t      asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER))) {\n\t\tisp_sink_crop.width = f->fmt.pix.width;\n\t\tisp_sink_crop.height = f->fmt.pix.height;\n\n\t\tatomisp_subdev_set_selection(&asd->subdev, NULL,\n\t\t\t\t\t     V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t\t\t     ATOMISP_SUBDEV_PAD_SOURCE, V4L2_SEL_TGT_COMPOSE,\n\t\t\t\t\t     0, &isp_sink_crop);\n\t} else {\n\t\tstruct v4l2_rect main_compose = {0};\n\n\t\tmain_compose.width = isp_sink_crop.width;\n\t\tmain_compose.height =\n\t\t    DIV_ROUND_UP(main_compose.width * f->fmt.pix.height,\n\t\t\t\t f->fmt.pix.width);\n\t\tif (main_compose.height > isp_sink_crop.height) {\n\t\t\tmain_compose.height = isp_sink_crop.height;\n\t\t\tmain_compose.width =\n\t\t\t    DIV_ROUND_UP(main_compose.height *\n\t\t\t\t\t f->fmt.pix.width,\n\t\t\t\t\t f->fmt.pix.height);\n\t\t}\n\n\t\tatomisp_subdev_set_selection(&asd->subdev, NULL,\n\t\t\t\t\t     V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t\t\t     ATOMISP_SUBDEV_PAD_SOURCE,\n\t\t\t\t\t     V4L2_SEL_TGT_COMPOSE, 0,\n\t\t\t\t\t     &main_compose);\n\t}\n\n\tret = atomisp_set_fmt_to_isp(vdev, &output_info, &f->fmt.pix);\n\tif (ret) {\n\t\tdev_warn(isp->dev, \"Can't set format on ISP. Error %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tatomisp_fill_pix_format(&pipe->pix, f->fmt.pix.width, f->fmt.pix.height, format_bridge);\n\n\tf->fmt.pix = pipe->pix;\n\tf->fmt.pix.priv = PAGE_ALIGN(pipe->pix.width *\n\t\t\t\t     pipe->pix.height * 2);\n\n\tdev_dbg(isp->dev, \"%s: %dx%d, image size: %d, %d bytes per line\\n\",\n\t\t__func__,\n\t\tf->fmt.pix.width, f->fmt.pix.height,\n\t\tf->fmt.pix.sizeimage, f->fmt.pix.bytesperline);\n\n\treturn 0;\n}\n\nint atomisp_set_shading_table(struct atomisp_sub_device *asd,\n\t\t\t      struct atomisp_shading_table *user_shading_table)\n{\n\tstruct ia_css_shading_table *shading_table;\n\tstruct ia_css_shading_table *free_table;\n\tunsigned int len_table;\n\tint i;\n\tint ret = 0;\n\n\tif (!user_shading_table)\n\t\treturn -EINVAL;\n\n\tif (!user_shading_table->enable) {\n\t\tasd->params.config.shading_table = NULL;\n\t\tasd->params.sc_en = false;\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {\n\t\tif (!user_shading_table->data[i])\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (user_shading_table->width > SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR ||\n\t    user_shading_table->height > SH_CSS_MAX_SCTBL_HEIGHT_PER_COLOR)\n\t\treturn -EINVAL;\n\n\tshading_table = atomisp_css_shading_table_alloc(\n\t\t\t    user_shading_table->width, user_shading_table->height);\n\tif (!shading_table)\n\t\treturn -ENOMEM;\n\n\tlen_table = user_shading_table->width * user_shading_table->height *\n\t\t    ATOMISP_SC_TYPE_SIZE;\n\tfor (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {\n\t\tret = copy_from_user(shading_table->data[i],\n\t\t\t\t     (void __user *)user_shading_table->data[i],\n\t\t\t\t     len_table);\n\t\tif (ret) {\n\t\t\tfree_table = shading_table;\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tshading_table->sensor_width = user_shading_table->sensor_width;\n\tshading_table->sensor_height = user_shading_table->sensor_height;\n\tshading_table->fraction_bits = user_shading_table->fraction_bits;\n\n\tfree_table = asd->params.css_param.shading_table;\n\tasd->params.css_param.shading_table = shading_table;\n\tasd->params.config.shading_table = shading_table;\n\tasd->params.sc_en = true;\n\nout:\n\tif (free_table)\n\t\tatomisp_css_shading_table_free(free_table);\n\n\treturn ret;\n}\n\nint atomisp_flash_enable(struct atomisp_sub_device *asd, int num_frames)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (num_frames < 0) {\n\t\tdev_dbg(isp->dev, \"%s ERROR: num_frames: %d\\n\", __func__,\n\t\t\tnum_frames);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (num_frames && asd->params.flash_state != ATOMISP_FLASH_IDLE) {\n\t\tdev_dbg(isp->dev, \"%s flash busy: %d frames left: %d\\n\",\n\t\t\t__func__, asd->params.flash_state,\n\t\t\tasd->params.num_flash_frames);\n\t\treturn -EBUSY;\n\t}\n\n\tasd->params.num_flash_frames = num_frames;\n\tasd->params.flash_state = ATOMISP_FLASH_REQUESTED;\n\treturn 0;\n}\n\nstatic int __checking_exp_id(struct atomisp_sub_device *asd, int exp_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->enable_raw_buffer_lock->val) {\n\t\tdev_warn(isp->dev, \"%s Raw Buffer Lock is disable.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (!asd->streaming) {\n\t\tdev_err(isp->dev, \"%s streaming %d invalid exp_id %d.\\n\",\n\t\t\t__func__, exp_id, asd->streaming);\n\t\treturn -EINVAL;\n\t}\n\tif ((exp_id > ATOMISP_MAX_EXP_ID) || (exp_id <= 0)) {\n\t\tdev_err(isp->dev, \"%s exp_id %d invalid.\\n\", __func__, exp_id);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nvoid atomisp_init_raw_buffer_bitmap(struct atomisp_sub_device *asd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&asd->raw_buffer_bitmap_lock, flags);\n\tmemset(asd->raw_buffer_bitmap, 0, sizeof(asd->raw_buffer_bitmap));\n\tasd->raw_buffer_locked_count = 0;\n\tspin_unlock_irqrestore(&asd->raw_buffer_bitmap_lock, flags);\n}\n\nstatic int __is_raw_buffer_locked(struct atomisp_sub_device *asd, int exp_id)\n{\n\tint *bitmap, bit;\n\tunsigned long flags;\n\tint ret;\n\n\tif (__checking_exp_id(asd, exp_id))\n\t\treturn -EINVAL;\n\n\tbitmap = asd->raw_buffer_bitmap + exp_id / 32;\n\tbit = exp_id % 32;\n\tspin_lock_irqsave(&asd->raw_buffer_bitmap_lock, flags);\n\tret = ((*bitmap) & (1 << bit));\n\tspin_unlock_irqrestore(&asd->raw_buffer_bitmap_lock, flags);\n\treturn !ret;\n}\n\nstatic int __clear_raw_buffer_bitmap(struct atomisp_sub_device *asd, int exp_id)\n{\n\tint *bitmap, bit;\n\tunsigned long flags;\n\n\tif (__is_raw_buffer_locked(asd, exp_id))\n\t\treturn -EINVAL;\n\n\tbitmap = asd->raw_buffer_bitmap + exp_id / 32;\n\tbit = exp_id % 32;\n\tspin_lock_irqsave(&asd->raw_buffer_bitmap_lock, flags);\n\t(*bitmap) &= ~(1 << bit);\n\tasd->raw_buffer_locked_count--;\n\tspin_unlock_irqrestore(&asd->raw_buffer_bitmap_lock, flags);\n\n\tdev_dbg(asd->isp->dev, \"%s: exp_id %d,  raw_buffer_locked_count %d\\n\",\n\t\t__func__, exp_id, asd->raw_buffer_locked_count);\n\treturn 0;\n}\n\nint atomisp_exp_id_capture(struct atomisp_sub_device *asd, int *exp_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tint value = *exp_id;\n\tint ret;\n\n\tlockdep_assert_held(&isp->mutex);\n\n\tret = __is_raw_buffer_locked(asd, value);\n\tif (ret) {\n\t\tdev_err(isp->dev, \"%s exp_id %d invalid %d.\\n\", __func__, value, ret);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(isp->dev, \"%s exp_id %d\\n\", __func__, value);\n\tret = atomisp_css_exp_id_capture(asd, value);\n\tif (ret) {\n\t\tdev_err(isp->dev, \"%s exp_id %d failed.\\n\", __func__, value);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nint atomisp_exp_id_unlock(struct atomisp_sub_device *asd, int *exp_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tint value = *exp_id;\n\tint ret;\n\n\tlockdep_assert_held(&isp->mutex);\n\n\tret = __clear_raw_buffer_bitmap(asd, value);\n\tif (ret) {\n\t\tdev_err(isp->dev, \"%s exp_id %d invalid %d.\\n\", __func__, value, ret);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(isp->dev, \"%s exp_id %d\\n\", __func__, value);\n\tret = atomisp_css_exp_id_unlock(asd, value);\n\tif (ret)\n\t\tdev_err(isp->dev, \"%s exp_id %d failed, err %d.\\n\",\n\t\t\t__func__, value, ret);\n\n\treturn ret;\n}\n\nint atomisp_enable_dz_capt_pipe(struct atomisp_sub_device *asd,\n\t\t\t\tunsigned int *enable)\n{\n\tbool value;\n\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tvalue = *enable > 0;\n\n\tatomisp_en_dz_capt_pipe(asd, value);\n\n\treturn 0;\n}\n\nint atomisp_inject_a_fake_event(struct atomisp_sub_device *asd, int *event)\n{\n\tif (!event || !asd->streaming)\n\t\treturn -EINVAL;\n\n\tlockdep_assert_held(&asd->isp->mutex);\n\n\tdev_dbg(asd->isp->dev, \"%s: trying to inject a fake event 0x%x\\n\",\n\t\t__func__, *event);\n\n\tswitch (*event) {\n\tcase V4L2_EVENT_FRAME_SYNC:\n\t\tatomisp_sof_event(asd);\n\t\tbreak;\n\tcase V4L2_EVENT_FRAME_END:\n\t\tatomisp_eof_event(asd, 0);\n\t\tbreak;\n\tcase V4L2_EVENT_ATOMISP_3A_STATS_READY:\n\t\tatomisp_3a_stats_ready_event(asd, 0);\n\t\tbreak;\n\tcase V4L2_EVENT_ATOMISP_METADATA_READY:\n\t\tatomisp_metadata_ready_event(asd, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}