{
  "module_name": "isp2400_input_system_private.h",
  "hash_id": "b80dff41901b9b528bc3d674655605c7eddac5303d01eca9f69a330c36243d71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/isp2400_input_system_private.h",
  "human_readable_source": " \n \n\n#ifndef __INPUT_SYSTEM_PRIVATE_H_INCLUDED__\n#define __INPUT_SYSTEM_PRIVATE_H_INCLUDED__\n\n#include \"input_system_public.h\"\n\n#include \"device_access.h\"\n\n#include \"assert_support.h\"\n\nSTORAGE_CLASS_INPUT_SYSTEM_C void input_system_reg_store(\n    const input_system_ID_t\t\t\tID,\n    const hrt_address\t\t\treg,\n    const hrt_data\t\t\t\tvalue)\n{\n\tassert(ID < N_INPUT_SYSTEM_ID);\n\tassert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);\n\tia_css_device_store_uint32(INPUT_SYSTEM_BASE[ID] + reg * sizeof(hrt_data),\n\t\t\t\t   value);\n\treturn;\n}\n\nSTORAGE_CLASS_INPUT_SYSTEM_C hrt_data input_system_reg_load(\n    const input_system_ID_t\t\t\tID,\n    const hrt_address\t\t\treg)\n{\n\tassert(ID < N_INPUT_SYSTEM_ID);\n\tassert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);\n\treturn ia_css_device_load_uint32(INPUT_SYSTEM_BASE[ID] + reg * sizeof(\n\t\t\t\t\t     hrt_data));\n}\n\nSTORAGE_CLASS_INPUT_SYSTEM_C void receiver_reg_store(\n    const rx_ID_t\t\t\t\tID,\n    const hrt_address\t\t\treg,\n    const hrt_data\t\t\t\tvalue)\n{\n\tassert(ID < N_RX_ID);\n\tassert(RX_BASE[ID] != (hrt_address)-1);\n\tia_css_device_store_uint32(RX_BASE[ID] + reg * sizeof(hrt_data), value);\n\treturn;\n}\n\nSTORAGE_CLASS_INPUT_SYSTEM_C hrt_data receiver_reg_load(\n    const rx_ID_t\t\t\t\tID,\n    const hrt_address\t\t\treg)\n{\n\tassert(ID < N_RX_ID);\n\tassert(RX_BASE[ID] != (hrt_address)-1);\n\treturn ia_css_device_load_uint32(RX_BASE[ID] + reg * sizeof(hrt_data));\n}\n\nSTORAGE_CLASS_INPUT_SYSTEM_C void receiver_port_reg_store(\n    const rx_ID_t\t\t\t\tID,\n    const enum mipi_port_id\t\t\tport_ID,\n    const hrt_address\t\t\treg,\n    const hrt_data\t\t\t\tvalue)\n{\n\tassert(ID < N_RX_ID);\n\tassert(port_ID < N_MIPI_PORT_ID);\n\tassert(RX_BASE[ID] != (hrt_address)-1);\n\tassert(MIPI_PORT_OFFSET[port_ID] != (hrt_address)-1);\n\tia_css_device_store_uint32(RX_BASE[ID] + MIPI_PORT_OFFSET[port_ID] + reg *\n\t\t\t\t   sizeof(hrt_data), value);\n\treturn;\n}\n\nSTORAGE_CLASS_INPUT_SYSTEM_C hrt_data receiver_port_reg_load(\n    const rx_ID_t\t\t\t\tID,\n    const enum mipi_port_id\t\t\tport_ID,\n    const hrt_address\t\t\treg)\n{\n\tassert(ID < N_RX_ID);\n\tassert(port_ID < N_MIPI_PORT_ID);\n\tassert(RX_BASE[ID] != (hrt_address)-1);\n\tassert(MIPI_PORT_OFFSET[port_ID] != (hrt_address)-1);\n\treturn ia_css_device_load_uint32(RX_BASE[ID] + MIPI_PORT_OFFSET[port_ID] + reg *\n\t\t\t\t\t sizeof(hrt_data));\n}\n\nSTORAGE_CLASS_INPUT_SYSTEM_C void input_system_sub_system_reg_store(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_ID,\n    const hrt_address\t\t\treg,\n    const hrt_data\t\t\t\tvalue)\n{\n\tassert(ID < N_INPUT_SYSTEM_ID);\n\tassert(sub_ID < N_SUB_SYSTEM_ID);\n\tassert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);\n\tassert(SUB_SYSTEM_OFFSET[sub_ID] != (hrt_address)-1);\n\tia_css_device_store_uint32(INPUT_SYSTEM_BASE[ID] + SUB_SYSTEM_OFFSET[sub_ID] +\n\t\t\t\t   reg * sizeof(hrt_data), value);\n\treturn;\n}\n\nSTORAGE_CLASS_INPUT_SYSTEM_C hrt_data input_system_sub_system_reg_load(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_ID,\n    const hrt_address\t\t\treg)\n{\n\tassert(ID < N_INPUT_SYSTEM_ID);\n\tassert(sub_ID < N_SUB_SYSTEM_ID);\n\tassert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);\n\tassert(SUB_SYSTEM_OFFSET[sub_ID] != (hrt_address)-1);\n\treturn ia_css_device_load_uint32(INPUT_SYSTEM_BASE[ID] +\n\t\t\t\t\t SUB_SYSTEM_OFFSET[sub_ID] + reg * sizeof(hrt_data));\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}