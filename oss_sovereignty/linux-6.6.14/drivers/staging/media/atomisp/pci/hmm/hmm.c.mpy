{
  "module_name": "hmm.c",
  "hash_id": "7c55552a1d7d6b35b301f6a7eef88705a6e29871fc9aa10682ba6a20aa7d056d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/hmm/hmm.c",
  "human_readable_source": "\n \n \n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\t \n#include <linux/io.h>\t\t \n#include <linux/sysfs.h>\n\n#include \"hmm/hmm.h\"\n#include \"hmm/hmm_bo.h\"\n\n#include \"atomisp_internal.h\"\n#include \"asm/cacheflush.h\"\n#include \"mmu/isp_mmu.h\"\n#include \"mmu/sh_mmu_mrfld.h\"\n\nstruct hmm_bo_device bo_device;\nstatic ia_css_ptr dummy_ptr = mmgr_EXCEPTION;\nstatic bool hmm_initialized;\n\n \nstatic const char hmm_bo_type_string[] = \"pv\";\n\nstatic ssize_t bo_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf, struct list_head *bo_list, bool active)\n{\n\tssize_t ret = 0;\n\tstruct hmm_buffer_object *bo;\n\tunsigned long flags;\n\tint i;\n\tlong total[HMM_BO_LAST] = { 0 };\n\tlong count[HMM_BO_LAST] = { 0 };\n\tint index1 = 0;\n\tint index2 = 0;\n\n\tret = scnprintf(buf, PAGE_SIZE, \"type pgnr\\n\");\n\tif (ret <= 0)\n\t\treturn 0;\n\n\tindex1 += ret;\n\n\tspin_lock_irqsave(&bo_device.list_lock, flags);\n\tlist_for_each_entry(bo, bo_list, list) {\n\t\tif ((active && (bo->status & HMM_BO_ALLOCED)) ||\n\t\t    (!active && !(bo->status & HMM_BO_ALLOCED))) {\n\t\t\tret = scnprintf(buf + index1, PAGE_SIZE - index1,\n\t\t\t\t\t\"%c %d\\n\",\n\t\t\t\t\thmm_bo_type_string[bo->type], bo->pgnr);\n\n\t\t\ttotal[bo->type] += bo->pgnr;\n\t\t\tcount[bo->type]++;\n\t\t\tif (ret > 0)\n\t\t\t\tindex1 += ret;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&bo_device.list_lock, flags);\n\n\tfor (i = 0; i < HMM_BO_LAST; i++) {\n\t\tif (count[i]) {\n\t\t\tret = scnprintf(buf + index1 + index2,\n\t\t\t\t\tPAGE_SIZE - index1 - index2,\n\t\t\t\t\t\"%ld %c buffer objects: %ld KB\\n\",\n\t\t\t\t\tcount[i], hmm_bo_type_string[i],\n\t\t\t\t\ttotal[i] * 4);\n\t\t\tif (ret > 0)\n\t\t\t\tindex2 += ret;\n\t\t}\n\t}\n\n\t \n\treturn index1 + index2 + 1;\n}\n\nstatic ssize_t active_bo_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn bo_show(dev, attr, buf, &bo_device.entire_bo_list, true);\n}\n\nstatic ssize_t free_bo_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\treturn bo_show(dev, attr, buf, &bo_device.entire_bo_list, false);\n}\n\n\nstatic DEVICE_ATTR_RO(active_bo);\nstatic DEVICE_ATTR_RO(free_bo);\n\nstatic struct attribute *sysfs_attrs_ctrl[] = {\n\t&dev_attr_active_bo.attr,\n\t&dev_attr_free_bo.attr,\n\tNULL\n};\n\nstatic struct attribute_group atomisp_attribute_group[] = {\n\t{.attrs = sysfs_attrs_ctrl },\n};\n\nint hmm_init(void)\n{\n\tint ret;\n\n\tret = hmm_bo_device_init(&bo_device, &sh_mmu_mrfld,\n\t\t\t\t ISP_VM_START, ISP_VM_SIZE);\n\tif (ret)\n\t\tdev_err(atomisp_dev, \"hmm_bo_device_init failed.\\n\");\n\n\thmm_initialized = true;\n\n\t \n\tdummy_ptr = hmm_alloc(1);\n\n\tif (!ret) {\n\t\tret = sysfs_create_group(&atomisp_dev->kobj,\n\t\t\t\t\t atomisp_attribute_group);\n\t\tif (ret)\n\t\t\tdev_err(atomisp_dev,\n\t\t\t\t\"%s Failed to create sysfs\\n\", __func__);\n\t}\n\n\treturn ret;\n}\n\nvoid hmm_cleanup(void)\n{\n\tif (dummy_ptr == mmgr_EXCEPTION)\n\t\treturn;\n\tsysfs_remove_group(&atomisp_dev->kobj, atomisp_attribute_group);\n\n\t \n\thmm_free(dummy_ptr);\n\tdummy_ptr = 0;\n\n\thmm_bo_device_exit(&bo_device);\n\thmm_initialized = false;\n}\n\nstatic ia_css_ptr __hmm_alloc(size_t bytes, enum hmm_bo_type type,\n\t\t\t      void *vmalloc_addr)\n{\n\tunsigned int pgnr;\n\tstruct hmm_buffer_object *bo;\n\tint ret;\n\n\t \n\n\tif (!hmm_initialized)\n\t\thmm_init();\n\t \n\tpgnr = size_to_pgnr_ceil(bytes);\n\n\t \n\tbo = hmm_bo_alloc(&bo_device, pgnr);\n\tif (!bo) {\n\t\tdev_err(atomisp_dev, \"hmm_bo_create failed.\\n\");\n\t\tgoto create_bo_err;\n\t}\n\n\t \n\tret = hmm_bo_alloc_pages(bo, type, vmalloc_addr);\n\tif (ret) {\n\t\tdev_err(atomisp_dev, \"hmm_bo_alloc_pages failed.\\n\");\n\t\tgoto alloc_page_err;\n\t}\n\n\t \n\tret = hmm_bo_bind(bo);\n\tif (ret) {\n\t\tdev_err(atomisp_dev, \"hmm_bo_bind failed.\\n\");\n\t\tgoto bind_err;\n\t}\n\n\tdev_dbg(atomisp_dev, \"pages: 0x%08x (%zu bytes), type: %d, vmalloc %p\\n\",\n\t\tbo->start, bytes, type, vmalloc);\n\n\treturn bo->start;\n\nbind_err:\n\thmm_bo_free_pages(bo);\nalloc_page_err:\n\thmm_bo_unref(bo);\ncreate_bo_err:\n\treturn 0;\n}\n\nia_css_ptr hmm_alloc(size_t bytes)\n{\n\treturn __hmm_alloc(bytes, HMM_BO_PRIVATE, NULL);\n}\n\nia_css_ptr hmm_create_from_vmalloc_buf(size_t bytes, void *vmalloc_addr)\n{\n\treturn __hmm_alloc(bytes, HMM_BO_VMALLOC, vmalloc_addr);\n}\n\nvoid hmm_free(ia_css_ptr virt)\n{\n\tstruct hmm_buffer_object *bo;\n\n\tdev_dbg(atomisp_dev, \"%s: free 0x%08x\\n\", __func__, virt);\n\n\tif (WARN_ON(virt == mmgr_EXCEPTION))\n\t\treturn;\n\n\tbo = hmm_bo_device_search_start(&bo_device, (unsigned int)virt);\n\n\tif (!bo) {\n\t\tdev_err(atomisp_dev,\n\t\t\t\"can not find buffer object start with address 0x%x\\n\",\n\t\t\t(unsigned int)virt);\n\t\treturn;\n\t}\n\n\thmm_bo_unbind(bo);\n\thmm_bo_free_pages(bo);\n\thmm_bo_unref(bo);\n}\n\nstatic inline int hmm_check_bo(struct hmm_buffer_object *bo, unsigned int ptr)\n{\n\tif (!bo) {\n\t\tdev_err(atomisp_dev,\n\t\t\t\"can not find buffer object contains address 0x%x\\n\",\n\t\t\tptr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!hmm_bo_page_allocated(bo)) {\n\t\tdev_err(atomisp_dev,\n\t\t\t\"buffer object has no page allocated.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!hmm_bo_allocated(bo)) {\n\t\tdev_err(atomisp_dev,\n\t\t\t\"buffer object has no virtual address space allocated.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int load_and_flush_by_kmap(ia_css_ptr virt, void *data,\n\t\t\t\t  unsigned int bytes)\n{\n\tstruct hmm_buffer_object *bo;\n\tunsigned int idx, offset, len;\n\tchar *src, *des;\n\tint ret;\n\n\tbo = hmm_bo_device_search_in_range(&bo_device, virt);\n\tret = hmm_check_bo(bo, virt);\n\tif (ret)\n\t\treturn ret;\n\n\tdes = (char *)data;\n\twhile (bytes) {\n\t\tidx = (virt - bo->start) >> PAGE_SHIFT;\n\t\toffset = (virt - bo->start) - (idx << PAGE_SHIFT);\n\n\t\tsrc = (char *)kmap_local_page(bo->pages[idx]) + offset;\n\n\t\tif ((bytes + offset) >= PAGE_SIZE) {\n\t\t\tlen = PAGE_SIZE - offset;\n\t\t\tbytes -= len;\n\t\t} else {\n\t\t\tlen = bytes;\n\t\t\tbytes = 0;\n\t\t}\n\n\t\tvirt += len;\t \n\n\t\tif (des) {\n\t\t\tmemcpy(des, src, len);\n\t\t\tdes += len;\n\t\t}\n\n\t\tclflush_cache_range(src, len);\n\n\t\tkunmap_local(src);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int load_and_flush(ia_css_ptr virt, void *data, unsigned int bytes)\n{\n\tstruct hmm_buffer_object *bo;\n\tint ret;\n\n\tbo = hmm_bo_device_search_in_range(&bo_device, virt);\n\tret = hmm_check_bo(bo, virt);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bo->status & HMM_BO_VMAPED || bo->status & HMM_BO_VMAPED_CACHED) {\n\t\tvoid *src = bo->vmap_addr;\n\n\t\tsrc += (virt - bo->start);\n\t\tmemcpy(data, src, bytes);\n\t\tif (bo->status & HMM_BO_VMAPED_CACHED)\n\t\t\tclflush_cache_range(src, bytes);\n\t} else {\n\t\tvoid *vptr;\n\n\t\tvptr = hmm_bo_vmap(bo, true);\n\t\tif (!vptr)\n\t\t\treturn load_and_flush_by_kmap(virt, data, bytes);\n\t\telse\n\t\t\tvptr = vptr + (virt - bo->start);\n\n\t\tmemcpy(data, vptr, bytes);\n\t\tclflush_cache_range(vptr, bytes);\n\t\thmm_bo_vunmap(bo);\n\t}\n\n\treturn 0;\n}\n\n \nint hmm_load(ia_css_ptr virt, void *data, unsigned int bytes)\n{\n\tif (!virt) {\n\t\tdev_warn(atomisp_dev,\n\t\t\t\"hmm_store: address is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!data) {\n\t\tdev_err(atomisp_dev,\n\t\t\t\"hmm_store: data is a NULL argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn load_and_flush(virt, data, bytes);\n}\n\n \nint hmm_flush(ia_css_ptr virt, unsigned int bytes)\n{\n\treturn load_and_flush(virt, NULL, bytes);\n}\n\n \nint hmm_store(ia_css_ptr virt, const void *data, unsigned int bytes)\n{\n\tstruct hmm_buffer_object *bo;\n\tunsigned int idx, offset, len;\n\tchar *src, *des;\n\tint ret;\n\n\tif (!virt) {\n\t\tdev_warn(atomisp_dev,\n\t\t\t\"hmm_store: address is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!data) {\n\t\tdev_err(atomisp_dev,\n\t\t\t\"hmm_store: data is a NULL argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbo = hmm_bo_device_search_in_range(&bo_device, virt);\n\tret = hmm_check_bo(bo, virt);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bo->status & HMM_BO_VMAPED || bo->status & HMM_BO_VMAPED_CACHED) {\n\t\tvoid *dst = bo->vmap_addr;\n\n\t\tdst += (virt - bo->start);\n\t\tmemcpy(dst, data, bytes);\n\t\tif (bo->status & HMM_BO_VMAPED_CACHED)\n\t\t\tclflush_cache_range(dst, bytes);\n\t} else {\n\t\tvoid *vptr;\n\n\t\tvptr = hmm_bo_vmap(bo, true);\n\t\tif (vptr) {\n\t\t\tvptr = vptr + (virt - bo->start);\n\n\t\t\tmemcpy(vptr, data, bytes);\n\t\t\tclflush_cache_range(vptr, bytes);\n\t\t\thmm_bo_vunmap(bo);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsrc = (char *)data;\n\twhile (bytes) {\n\t\tidx = (virt - bo->start) >> PAGE_SHIFT;\n\t\toffset = (virt - bo->start) - (idx << PAGE_SHIFT);\n\n\t\tdes = (char *)kmap_local_page(bo->pages[idx]);\n\n\t\tif (!des) {\n\t\t\tdev_err(atomisp_dev,\n\t\t\t\t\"kmap buffer object page failed: pg_idx = %d\\n\",\n\t\t\t\tidx);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdes += offset;\n\n\t\tif ((bytes + offset) >= PAGE_SIZE) {\n\t\t\tlen = PAGE_SIZE - offset;\n\t\t\tbytes -= len;\n\t\t} else {\n\t\t\tlen = bytes;\n\t\t\tbytes = 0;\n\t\t}\n\n\t\tvirt += len;\n\n\t\tmemcpy(des, src, len);\n\n\t\tsrc += len;\n\n\t\tclflush_cache_range(des, len);\n\n\t\tkunmap_local(des);\n\t}\n\n\treturn 0;\n}\n\n \nint hmm_set(ia_css_ptr virt, int c, unsigned int bytes)\n{\n\tstruct hmm_buffer_object *bo;\n\tunsigned int idx, offset, len;\n\tchar *des;\n\tint ret;\n\n\tbo = hmm_bo_device_search_in_range(&bo_device, virt);\n\tret = hmm_check_bo(bo, virt);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bo->status & HMM_BO_VMAPED || bo->status & HMM_BO_VMAPED_CACHED) {\n\t\tvoid *dst = bo->vmap_addr;\n\n\t\tdst += (virt - bo->start);\n\t\tmemset(dst, c, bytes);\n\n\t\tif (bo->status & HMM_BO_VMAPED_CACHED)\n\t\t\tclflush_cache_range(dst, bytes);\n\t} else {\n\t\tvoid *vptr;\n\n\t\tvptr = hmm_bo_vmap(bo, true);\n\t\tif (vptr) {\n\t\t\tvptr = vptr + (virt - bo->start);\n\t\t\tmemset(vptr, c, bytes);\n\t\t\tclflush_cache_range(vptr, bytes);\n\t\t\thmm_bo_vunmap(bo);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (bytes) {\n\t\tidx = (virt - bo->start) >> PAGE_SHIFT;\n\t\toffset = (virt - bo->start) - (idx << PAGE_SHIFT);\n\n\t\tdes = (char *)kmap_local_page(bo->pages[idx]) + offset;\n\n\t\tif ((bytes + offset) >= PAGE_SIZE) {\n\t\t\tlen = PAGE_SIZE - offset;\n\t\t\tbytes -= len;\n\t\t} else {\n\t\t\tlen = bytes;\n\t\t\tbytes = 0;\n\t\t}\n\n\t\tvirt += len;\n\n\t\tmemset(des, c, len);\n\n\t\tclflush_cache_range(des, len);\n\n\t\tkunmap_local(des);\n\t}\n\n\treturn 0;\n}\n\n \nphys_addr_t hmm_virt_to_phys(ia_css_ptr virt)\n{\n\tunsigned int idx, offset;\n\tstruct hmm_buffer_object *bo;\n\n\tbo = hmm_bo_device_search_in_range(&bo_device, virt);\n\tif (!bo) {\n\t\tdev_err(atomisp_dev,\n\t\t\t\"can not find buffer object contains address 0x%x\\n\",\n\t\t\tvirt);\n\t\treturn -1;\n\t}\n\n\tidx = (virt - bo->start) >> PAGE_SHIFT;\n\toffset = (virt - bo->start) - (idx << PAGE_SHIFT);\n\n\treturn page_to_phys(bo->pages[idx]) + offset;\n}\n\nint hmm_mmap(struct vm_area_struct *vma, ia_css_ptr virt)\n{\n\tstruct hmm_buffer_object *bo;\n\n\tbo = hmm_bo_device_search_start(&bo_device, virt);\n\tif (!bo) {\n\t\tdev_err(atomisp_dev,\n\t\t\t\"can not find buffer object start with address 0x%x\\n\",\n\t\t\tvirt);\n\t\treturn -EINVAL;\n\t}\n\n\treturn hmm_bo_mmap(vma, bo);\n}\n\n \nvoid *hmm_vmap(ia_css_ptr virt, bool cached)\n{\n\tstruct hmm_buffer_object *bo;\n\tvoid *ptr;\n\n\tbo = hmm_bo_device_search_in_range(&bo_device, virt);\n\tif (!bo) {\n\t\tdev_err(atomisp_dev,\n\t\t\t\"can not find buffer object contains address 0x%x\\n\",\n\t\t\tvirt);\n\t\treturn NULL;\n\t}\n\n\tptr = hmm_bo_vmap(bo, cached);\n\tif (ptr)\n\t\treturn ptr + (virt - bo->start);\n\telse\n\t\treturn NULL;\n}\n\n \nvoid hmm_flush_vmap(ia_css_ptr virt)\n{\n\tstruct hmm_buffer_object *bo;\n\n\tbo = hmm_bo_device_search_in_range(&bo_device, virt);\n\tif (!bo) {\n\t\tdev_warn(atomisp_dev,\n\t\t\t \"can not find buffer object contains address 0x%x\\n\",\n\t\t\t virt);\n\t\treturn;\n\t}\n\n\thmm_bo_flush_vmap(bo);\n}\n\nvoid hmm_vunmap(ia_css_ptr virt)\n{\n\tstruct hmm_buffer_object *bo;\n\n\tbo = hmm_bo_device_search_in_range(&bo_device, virt);\n\tif (!bo) {\n\t\tdev_warn(atomisp_dev,\n\t\t\t \"can not find buffer object contains address 0x%x\\n\",\n\t\t\t virt);\n\t\treturn;\n\t}\n\n\thmm_bo_vunmap(bo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}