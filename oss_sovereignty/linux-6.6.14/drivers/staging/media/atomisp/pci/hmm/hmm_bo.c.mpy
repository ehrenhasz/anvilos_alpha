{
  "module_name": "hmm_bo.c",
  "hash_id": "21c44f26b12e697fe6a7f5bd388776f154dfb28313c32009220e999891d56e34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/hmm/hmm_bo.c",
  "human_readable_source": "\n \n \n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/gfp.h>\t\t \n#include <linux/mm.h>\n#include <linux/mm_types.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\t\t \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <asm/current.h>\n#include <linux/sched/signal.h>\n#include <linux/file.h>\n\n#include <asm/set_memory.h>\n\n#include \"atomisp_internal.h\"\n#include \"hmm/hmm_common.h\"\n#include \"hmm/hmm_bo.h\"\n\nstatic int __bo_init(struct hmm_bo_device *bdev, struct hmm_buffer_object *bo,\n\t\t     unsigned int pgnr)\n{\n\tcheck_bodev_null_return(bdev, -EINVAL);\n\tvar_equal_return(hmm_bo_device_inited(bdev), 0, -EINVAL,\n\t\t\t \"hmm_bo_device not inited yet.\\n\");\n\t \n\tif (pgnr == 0) {\n\t\tdev_err(atomisp_dev, \"0 size buffer is not allowed.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(bo, 0, sizeof(*bo));\n\tmutex_init(&bo->mutex);\n\n\t \n\tINIT_LIST_HEAD(&bo->list);\n\n\tbo->bdev = bdev;\n\tbo->vmap_addr = NULL;\n\tbo->status = HMM_BO_FREE;\n\tbo->start = bdev->start;\n\tbo->pgnr = pgnr;\n\tbo->end = bo->start + pgnr_to_size(pgnr);\n\tbo->prev = NULL;\n\tbo->next = NULL;\n\n\treturn 0;\n}\n\nstatic struct hmm_buffer_object *__bo_search_and_remove_from_free_rbtree(\n    struct rb_node *node, unsigned int pgnr)\n{\n\tstruct hmm_buffer_object *this, *ret_bo, *temp_bo;\n\n\tthis = rb_entry(node, struct hmm_buffer_object, node);\n\tif (this->pgnr == pgnr ||\n\t    (this->pgnr > pgnr && !this->node.rb_left)) {\n\t\tgoto remove_bo_and_return;\n\t} else {\n\t\tif (this->pgnr < pgnr) {\n\t\t\tif (!this->node.rb_right)\n\t\t\t\treturn NULL;\n\t\t\tret_bo = __bo_search_and_remove_from_free_rbtree(\n\t\t\t\t     this->node.rb_right, pgnr);\n\t\t} else {\n\t\t\tret_bo = __bo_search_and_remove_from_free_rbtree(\n\t\t\t\t     this->node.rb_left, pgnr);\n\t\t}\n\t\tif (!ret_bo) {\n\t\t\tif (this->pgnr > pgnr)\n\t\t\t\tgoto remove_bo_and_return;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t\treturn ret_bo;\n\t}\n\nremove_bo_and_return:\n\t \n\tif (!this->next) {\n\t\trb_erase(&this->node, &this->bdev->free_rbtree);\n\t\treturn this;\n\t}\n\t \n\ttemp_bo = this->next;\n\tthis->next = temp_bo->next;\n\tif (temp_bo->next)\n\t\ttemp_bo->next->prev = this;\n\ttemp_bo->next = NULL;\n\ttemp_bo->prev = NULL;\n\treturn temp_bo;\n}\n\nstatic struct hmm_buffer_object *__bo_search_by_addr(struct rb_root *root,\n\tia_css_ptr start)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct hmm_buffer_object *bo;\n\n\tdo {\n\t\tbo = rb_entry(n, struct hmm_buffer_object, node);\n\n\t\tif (bo->start > start) {\n\t\t\tif (!n->rb_left)\n\t\t\t\treturn NULL;\n\t\t\tn = n->rb_left;\n\t\t} else if (bo->start < start) {\n\t\t\tif (!n->rb_right)\n\t\t\t\treturn NULL;\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\treturn bo;\n\t\t}\n\t} while (n);\n\n\treturn NULL;\n}\n\nstatic struct hmm_buffer_object *__bo_search_by_addr_in_range(\n    struct rb_root *root, unsigned int start)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct hmm_buffer_object *bo;\n\n\tdo {\n\t\tbo = rb_entry(n, struct hmm_buffer_object, node);\n\n\t\tif (bo->start > start) {\n\t\t\tif (!n->rb_left)\n\t\t\t\treturn NULL;\n\t\t\tn = n->rb_left;\n\t\t} else {\n\t\t\tif (bo->end > start)\n\t\t\t\treturn bo;\n\t\t\tif (!n->rb_right)\n\t\t\t\treturn NULL;\n\t\t\tn = n->rb_right;\n\t\t}\n\t} while (n);\n\n\treturn NULL;\n}\n\nstatic void __bo_insert_to_free_rbtree(struct rb_root *root,\n\t\t\t\t       struct hmm_buffer_object *bo)\n{\n\tstruct rb_node **new = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct hmm_buffer_object *this;\n\tunsigned int pgnr = bo->pgnr;\n\n\twhile (*new) {\n\t\tparent = *new;\n\t\tthis = container_of(*new, struct hmm_buffer_object, node);\n\n\t\tif (pgnr < this->pgnr) {\n\t\t\tnew = &((*new)->rb_left);\n\t\t} else if (pgnr > this->pgnr) {\n\t\t\tnew = &((*new)->rb_right);\n\t\t} else {\n\t\t\tbo->prev = this;\n\t\t\tbo->next = this->next;\n\t\t\tif (this->next)\n\t\t\t\tthis->next->prev = bo;\n\t\t\tthis->next = bo;\n\t\t\tbo->status = (bo->status & ~HMM_BO_MASK) | HMM_BO_FREE;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbo->status = (bo->status & ~HMM_BO_MASK) | HMM_BO_FREE;\n\n\trb_link_node(&bo->node, parent, new);\n\trb_insert_color(&bo->node, root);\n}\n\nstatic void __bo_insert_to_alloc_rbtree(struct rb_root *root,\n\t\t\t\t\tstruct hmm_buffer_object *bo)\n{\n\tstruct rb_node **new = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct hmm_buffer_object *this;\n\tunsigned int start = bo->start;\n\n\twhile (*new) {\n\t\tparent = *new;\n\t\tthis = container_of(*new, struct hmm_buffer_object, node);\n\n\t\tif (start < this->start)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\tkref_init(&bo->kref);\n\tbo->status = (bo->status & ~HMM_BO_MASK) | HMM_BO_ALLOCED;\n\n\trb_link_node(&bo->node, parent, new);\n\trb_insert_color(&bo->node, root);\n}\n\nstatic struct hmm_buffer_object *__bo_break_up(struct hmm_bo_device *bdev,\n\tstruct hmm_buffer_object *bo,\n\tunsigned int pgnr)\n{\n\tstruct hmm_buffer_object *new_bo;\n\tunsigned long flags;\n\tint ret;\n\n\tnew_bo = kmem_cache_alloc(bdev->bo_cache, GFP_KERNEL);\n\tif (!new_bo) {\n\t\tdev_err(atomisp_dev, \"%s: __bo_alloc failed!\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tret = __bo_init(bdev, new_bo, pgnr);\n\tif (ret) {\n\t\tdev_err(atomisp_dev, \"%s: __bo_init failed!\\n\", __func__);\n\t\tkmem_cache_free(bdev->bo_cache, new_bo);\n\t\treturn NULL;\n\t}\n\n\tnew_bo->start = bo->start;\n\tnew_bo->end = new_bo->start + pgnr_to_size(pgnr);\n\tbo->start = new_bo->end;\n\tbo->pgnr = bo->pgnr - pgnr;\n\n\tspin_lock_irqsave(&bdev->list_lock, flags);\n\tlist_add_tail(&new_bo->list, &bo->list);\n\tspin_unlock_irqrestore(&bdev->list_lock, flags);\n\n\treturn new_bo;\n}\n\nstatic void __bo_take_off_handling(struct hmm_buffer_object *bo)\n{\n\tstruct hmm_bo_device *bdev = bo->bdev;\n\t \n\tif (!bo->prev && !bo->next) {\n\t\trb_erase(&bo->node, &bdev->free_rbtree);\n\t\t \n\t} else if (!bo->prev && bo->next) {\n\t\tbo->next->prev = NULL;\n\t\trb_erase(&bo->node, &bdev->free_rbtree);\n\t\t__bo_insert_to_free_rbtree(&bdev->free_rbtree, bo->next);\n\t\tbo->next = NULL;\n\t\t \n\t} else if (bo->prev && !bo->next) {\n\t\tbo->prev->next = NULL;\n\t\tbo->prev = NULL;\n\t\t \n\t} else if (bo->prev && bo->next) {\n\t\tbo->next->prev = bo->prev;\n\t\tbo->prev->next = bo->next;\n\t\tbo->next = NULL;\n\t\tbo->prev = NULL;\n\t}\n}\n\nstatic struct hmm_buffer_object *__bo_merge(struct hmm_buffer_object *bo,\n\tstruct hmm_buffer_object *next_bo)\n{\n\tstruct hmm_bo_device *bdev;\n\tunsigned long flags;\n\n\tbdev = bo->bdev;\n\tnext_bo->start = bo->start;\n\tnext_bo->pgnr = next_bo->pgnr + bo->pgnr;\n\n\tspin_lock_irqsave(&bdev->list_lock, flags);\n\tlist_del(&bo->list);\n\tspin_unlock_irqrestore(&bdev->list_lock, flags);\n\n\tkmem_cache_free(bo->bdev->bo_cache, bo);\n\n\treturn next_bo;\n}\n\n \nint hmm_bo_device_init(struct hmm_bo_device *bdev,\n\t\t       struct isp_mmu_client *mmu_driver,\n\t\t       unsigned int vaddr_start,\n\t\t       unsigned int size)\n{\n\tstruct hmm_buffer_object *bo;\n\tunsigned long flags;\n\tint ret;\n\n\tcheck_bodev_null_return(bdev, -EINVAL);\n\n\tret = isp_mmu_init(&bdev->mmu, mmu_driver);\n\tif (ret) {\n\t\tdev_err(atomisp_dev, \"isp_mmu_init failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tbdev->start = vaddr_start;\n\tbdev->pgnr = size_to_pgnr_ceil(size);\n\tbdev->size = pgnr_to_size(bdev->pgnr);\n\n\tspin_lock_init(&bdev->list_lock);\n\tmutex_init(&bdev->rbtree_mutex);\n\n\tbdev->flag = HMM_BO_DEVICE_INITED;\n\n\tINIT_LIST_HEAD(&bdev->entire_bo_list);\n\tbdev->allocated_rbtree = RB_ROOT;\n\tbdev->free_rbtree = RB_ROOT;\n\n\tbdev->bo_cache = kmem_cache_create(\"bo_cache\",\n\t\t\t\t\t   sizeof(struct hmm_buffer_object), 0, 0, NULL);\n\tif (!bdev->bo_cache) {\n\t\tdev_err(atomisp_dev, \"%s: create cache failed!\\n\", __func__);\n\t\tisp_mmu_exit(&bdev->mmu);\n\t\treturn -ENOMEM;\n\t}\n\n\tbo = kmem_cache_alloc(bdev->bo_cache, GFP_KERNEL);\n\tif (!bo) {\n\t\tdev_err(atomisp_dev, \"%s: __bo_alloc failed!\\n\", __func__);\n\t\tisp_mmu_exit(&bdev->mmu);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = __bo_init(bdev, bo, bdev->pgnr);\n\tif (ret) {\n\t\tdev_err(atomisp_dev, \"%s: __bo_init failed!\\n\", __func__);\n\t\tkmem_cache_free(bdev->bo_cache, bo);\n\t\tisp_mmu_exit(&bdev->mmu);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&bdev->list_lock, flags);\n\tlist_add_tail(&bo->list, &bdev->entire_bo_list);\n\tspin_unlock_irqrestore(&bdev->list_lock, flags);\n\n\t__bo_insert_to_free_rbtree(&bdev->free_rbtree, bo);\n\n\treturn 0;\n}\n\nstruct hmm_buffer_object *hmm_bo_alloc(struct hmm_bo_device *bdev,\n\t\t\t\t       unsigned int pgnr)\n{\n\tstruct hmm_buffer_object *bo, *new_bo;\n\tstruct rb_root *root = &bdev->free_rbtree;\n\n\tcheck_bodev_null_return(bdev, NULL);\n\tvar_equal_return(hmm_bo_device_inited(bdev), 0, NULL,\n\t\t\t \"hmm_bo_device not inited yet.\\n\");\n\n\tif (pgnr == 0) {\n\t\tdev_err(atomisp_dev, \"0 size buffer is not allowed.\\n\");\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&bdev->rbtree_mutex);\n\tbo = __bo_search_and_remove_from_free_rbtree(root->rb_node, pgnr);\n\tif (!bo) {\n\t\tmutex_unlock(&bdev->rbtree_mutex);\n\t\tdev_err(atomisp_dev, \"%s: Out of Memory! hmm_bo_alloc failed\",\n\t\t\t__func__);\n\t\treturn NULL;\n\t}\n\n\tif (bo->pgnr > pgnr) {\n\t\tnew_bo = __bo_break_up(bdev, bo, pgnr);\n\t\tif (!new_bo) {\n\t\t\tmutex_unlock(&bdev->rbtree_mutex);\n\t\t\tdev_err(atomisp_dev, \"%s: __bo_break_up failed!\\n\",\n\t\t\t\t__func__);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t__bo_insert_to_alloc_rbtree(&bdev->allocated_rbtree, new_bo);\n\t\t__bo_insert_to_free_rbtree(&bdev->free_rbtree, bo);\n\n\t\tmutex_unlock(&bdev->rbtree_mutex);\n\t\treturn new_bo;\n\t}\n\n\t__bo_insert_to_alloc_rbtree(&bdev->allocated_rbtree, bo);\n\n\tmutex_unlock(&bdev->rbtree_mutex);\n\treturn bo;\n}\n\nvoid hmm_bo_release(struct hmm_buffer_object *bo)\n{\n\tstruct hmm_bo_device *bdev = bo->bdev;\n\tstruct hmm_buffer_object *next_bo, *prev_bo;\n\n\tmutex_lock(&bdev->rbtree_mutex);\n\n\t \n\tif (bo->status & HMM_BO_MMAPED) {\n\t\tmutex_unlock(&bdev->rbtree_mutex);\n\t\tdev_dbg(atomisp_dev, \"destroy bo which is MMAPED, do nothing\\n\");\n\t\treturn;\n\t}\n\n\tif (bo->status & HMM_BO_BINDED) {\n\t\tdev_warn(atomisp_dev, \"the bo is still binded, unbind it first...\\n\");\n\t\thmm_bo_unbind(bo);\n\t}\n\n\tif (bo->status & HMM_BO_PAGE_ALLOCED) {\n\t\tdev_warn(atomisp_dev, \"the pages is not freed, free pages first\\n\");\n\t\thmm_bo_free_pages(bo);\n\t}\n\tif (bo->status & HMM_BO_VMAPED || bo->status & HMM_BO_VMAPED_CACHED) {\n\t\tdev_warn(atomisp_dev, \"the vunmap is not done, do it...\\n\");\n\t\thmm_bo_vunmap(bo);\n\t}\n\n\trb_erase(&bo->node, &bdev->allocated_rbtree);\n\n\tprev_bo = list_entry(bo->list.prev, struct hmm_buffer_object, list);\n\tnext_bo = list_entry(bo->list.next, struct hmm_buffer_object, list);\n\n\tif (bo->list.prev != &bdev->entire_bo_list &&\n\t    prev_bo->end == bo->start &&\n\t    (prev_bo->status & HMM_BO_MASK) == HMM_BO_FREE) {\n\t\t__bo_take_off_handling(prev_bo);\n\t\tbo = __bo_merge(prev_bo, bo);\n\t}\n\n\tif (bo->list.next != &bdev->entire_bo_list &&\n\t    next_bo->start == bo->end &&\n\t    (next_bo->status & HMM_BO_MASK) == HMM_BO_FREE) {\n\t\t__bo_take_off_handling(next_bo);\n\t\tbo = __bo_merge(bo, next_bo);\n\t}\n\n\t__bo_insert_to_free_rbtree(&bdev->free_rbtree, bo);\n\n\tmutex_unlock(&bdev->rbtree_mutex);\n\treturn;\n}\n\nvoid hmm_bo_device_exit(struct hmm_bo_device *bdev)\n{\n\tstruct hmm_buffer_object *bo;\n\tunsigned long flags;\n\n\tdev_dbg(atomisp_dev, \"%s: entering!\\n\", __func__);\n\n\tcheck_bodev_null_return_void(bdev);\n\n\t \n\twhile (!RB_EMPTY_ROOT(&bdev->allocated_rbtree))\n\t\thmm_bo_release(\n\t\t    rbtree_node_to_hmm_bo(bdev->allocated_rbtree.rb_node));\n\n\tdev_dbg(atomisp_dev, \"%s: finished releasing all allocated bos!\\n\",\n\t\t__func__);\n\n\t \n\twhile (!list_empty(&bdev->entire_bo_list)) {\n\t\tbo = list_to_hmm_bo(bdev->entire_bo_list.next);\n\n\t\tspin_lock_irqsave(&bdev->list_lock, flags);\n\t\tlist_del(&bo->list);\n\t\tspin_unlock_irqrestore(&bdev->list_lock, flags);\n\n\t\tkmem_cache_free(bdev->bo_cache, bo);\n\t}\n\n\tdev_dbg(atomisp_dev, \"%s: finished to free all bos!\\n\", __func__);\n\n\tkmem_cache_destroy(bdev->bo_cache);\n\n\tisp_mmu_exit(&bdev->mmu);\n}\n\nint hmm_bo_device_inited(struct hmm_bo_device *bdev)\n{\n\tcheck_bodev_null_return(bdev, -EINVAL);\n\n\treturn bdev->flag == HMM_BO_DEVICE_INITED;\n}\n\nint hmm_bo_allocated(struct hmm_buffer_object *bo)\n{\n\tcheck_bo_null_return(bo, 0);\n\n\treturn bo->status & HMM_BO_ALLOCED;\n}\n\nstruct hmm_buffer_object *hmm_bo_device_search_start(\n    struct hmm_bo_device *bdev, ia_css_ptr vaddr)\n{\n\tstruct hmm_buffer_object *bo;\n\n\tcheck_bodev_null_return(bdev, NULL);\n\n\tmutex_lock(&bdev->rbtree_mutex);\n\tbo = __bo_search_by_addr(&bdev->allocated_rbtree, vaddr);\n\tif (!bo) {\n\t\tmutex_unlock(&bdev->rbtree_mutex);\n\t\tdev_err(atomisp_dev, \"%s can not find bo with addr: 0x%x\\n\",\n\t\t\t__func__, vaddr);\n\t\treturn NULL;\n\t}\n\tmutex_unlock(&bdev->rbtree_mutex);\n\n\treturn bo;\n}\n\nstruct hmm_buffer_object *hmm_bo_device_search_in_range(\n    struct hmm_bo_device *bdev, unsigned int vaddr)\n{\n\tstruct hmm_buffer_object *bo;\n\n\tcheck_bodev_null_return(bdev, NULL);\n\n\tmutex_lock(&bdev->rbtree_mutex);\n\tbo = __bo_search_by_addr_in_range(&bdev->allocated_rbtree, vaddr);\n\tif (!bo) {\n\t\tmutex_unlock(&bdev->rbtree_mutex);\n\t\tdev_err(atomisp_dev, \"%s can not find bo contain addr: 0x%x\\n\",\n\t\t\t__func__, vaddr);\n\t\treturn NULL;\n\t}\n\tmutex_unlock(&bdev->rbtree_mutex);\n\n\treturn bo;\n}\n\nstruct hmm_buffer_object *hmm_bo_device_search_vmap_start(\n    struct hmm_bo_device *bdev, const void *vaddr)\n{\n\tstruct list_head *pos;\n\tstruct hmm_buffer_object *bo;\n\tunsigned long flags;\n\n\tcheck_bodev_null_return(bdev, NULL);\n\n\tspin_lock_irqsave(&bdev->list_lock, flags);\n\tlist_for_each(pos, &bdev->entire_bo_list) {\n\t\tbo = list_to_hmm_bo(pos);\n\t\t \n\t\tif ((bo->status & HMM_BO_MASK) == HMM_BO_FREE)\n\t\t\tcontinue;\n\t\tif (bo->vmap_addr == vaddr)\n\t\t\tgoto found;\n\t}\n\tspin_unlock_irqrestore(&bdev->list_lock, flags);\n\treturn NULL;\nfound:\n\tspin_unlock_irqrestore(&bdev->list_lock, flags);\n\treturn bo;\n}\n\nstatic void free_pages_bulk_array(unsigned long nr_pages, struct page **page_array)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < nr_pages; i++)\n\t\t__free_pages(page_array[i], 0);\n}\n\nstatic void free_private_bo_pages(struct hmm_buffer_object *bo)\n{\n\tset_pages_array_wb(bo->pages, bo->pgnr);\n\tfree_pages_bulk_array(bo->pgnr, bo->pages);\n}\n\n \nstatic int alloc_private_pages(struct hmm_buffer_object *bo)\n{\n\tconst gfp_t gfp = __GFP_NOWARN | __GFP_RECLAIM | __GFP_FS;\n\tint ret;\n\n\tret = alloc_pages_bulk_array(gfp, bo->pgnr, bo->pages);\n\tif (ret != bo->pgnr) {\n\t\tfree_pages_bulk_array(ret, bo->pages);\n\t\tdev_err(atomisp_dev, \"alloc_pages_bulk_array() failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = set_pages_array_uc(bo->pages, bo->pgnr);\n\tif (ret) {\n\t\tdev_err(atomisp_dev, \"set pages uncacheable failed.\\n\");\n\t\tfree_pages_bulk_array(bo->pgnr, bo->pages);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int alloc_vmalloc_pages(struct hmm_buffer_object *bo, void *vmalloc_addr)\n{\n\tvoid *vaddr = vmalloc_addr;\n\tint i;\n\n\tfor (i = 0; i < bo->pgnr; i++) {\n\t\tbo->pages[i] = vmalloc_to_page(vaddr);\n\t\tif (!bo->pages[i]) {\n\t\t\tdev_err(atomisp_dev, \"Error could not get page %d of vmalloc buf\\n\", i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tvaddr += PAGE_SIZE;\n\t}\n\n\treturn 0;\n}\n\n \nint hmm_bo_alloc_pages(struct hmm_buffer_object *bo,\n\t\t       enum hmm_bo_type type,\n\t\t       void *vmalloc_addr)\n{\n\tint ret = -EINVAL;\n\n\tcheck_bo_null_return(bo, -EINVAL);\n\n\tmutex_lock(&bo->mutex);\n\tcheck_bo_status_no_goto(bo, HMM_BO_PAGE_ALLOCED, status_err);\n\n\tbo->pages = kcalloc(bo->pgnr, sizeof(struct page *), GFP_KERNEL);\n\tif (unlikely(!bo->pages)) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_err;\n\t}\n\n\tif (type == HMM_BO_PRIVATE) {\n\t\tret = alloc_private_pages(bo);\n\t} else if (type == HMM_BO_VMALLOC) {\n\t\tret = alloc_vmalloc_pages(bo, vmalloc_addr);\n\t} else {\n\t\tdev_err(atomisp_dev, \"invalid buffer type.\\n\");\n\t\tret = -EINVAL;\n\t}\n\tif (ret)\n\t\tgoto alloc_err;\n\n\tbo->type = type;\n\n\tbo->status |= HMM_BO_PAGE_ALLOCED;\n\n\tmutex_unlock(&bo->mutex);\n\n\treturn 0;\n\nalloc_err:\n\tkfree(bo->pages);\n\tmutex_unlock(&bo->mutex);\n\tdev_err(atomisp_dev, \"alloc pages err...\\n\");\n\treturn ret;\nstatus_err:\n\tmutex_unlock(&bo->mutex);\n\tdev_err(atomisp_dev,\n\t\t\"buffer object has already page allocated.\\n\");\n\treturn -EINVAL;\n}\n\n \nvoid hmm_bo_free_pages(struct hmm_buffer_object *bo)\n{\n\tcheck_bo_null_return_void(bo);\n\n\tmutex_lock(&bo->mutex);\n\n\tcheck_bo_status_yes_goto(bo, HMM_BO_PAGE_ALLOCED, status_err2);\n\n\t \n\tbo->status &= (~HMM_BO_PAGE_ALLOCED);\n\n\tif (bo->type == HMM_BO_PRIVATE)\n\t\tfree_private_bo_pages(bo);\n\telse if (bo->type == HMM_BO_VMALLOC)\n\t\t;  \n\telse\n\t\tdev_err(atomisp_dev, \"invalid buffer type.\\n\");\n\n\tkfree(bo->pages);\n\tmutex_unlock(&bo->mutex);\n\n\treturn;\n\nstatus_err2:\n\tmutex_unlock(&bo->mutex);\n\tdev_err(atomisp_dev,\n\t\t\"buffer object not page allocated yet.\\n\");\n}\n\nint hmm_bo_page_allocated(struct hmm_buffer_object *bo)\n{\n\tcheck_bo_null_return(bo, 0);\n\n\treturn bo->status & HMM_BO_PAGE_ALLOCED;\n}\n\n \nint hmm_bo_bind(struct hmm_buffer_object *bo)\n{\n\tint ret;\n\tunsigned int virt;\n\tstruct hmm_bo_device *bdev;\n\tunsigned int i;\n\n\tcheck_bo_null_return(bo, -EINVAL);\n\n\tmutex_lock(&bo->mutex);\n\n\tcheck_bo_status_yes_goto(bo,\n\t\t\t\t HMM_BO_PAGE_ALLOCED | HMM_BO_ALLOCED,\n\t\t\t\t status_err1);\n\n\tcheck_bo_status_no_goto(bo, HMM_BO_BINDED, status_err2);\n\n\tbdev = bo->bdev;\n\n\tvirt = bo->start;\n\n\tfor (i = 0; i < bo->pgnr; i++) {\n\t\tret =\n\t\t    isp_mmu_map(&bdev->mmu, virt,\n\t\t\t\tpage_to_phys(bo->pages[i]), 1);\n\t\tif (ret)\n\t\t\tgoto map_err;\n\t\tvirt += (1 << PAGE_SHIFT);\n\t}\n\n\t \n\tif (bo->start != 0x0)\n\t\tisp_mmu_flush_tlb_range(&bdev->mmu, bo->start,\n\t\t\t\t\t(bo->pgnr << PAGE_SHIFT));\n\n\tbo->status |= HMM_BO_BINDED;\n\n\tmutex_unlock(&bo->mutex);\n\n\treturn 0;\n\nmap_err:\n\t \n\tvirt = bo->start;\n\tfor ( ; i > 0; i--) {\n\t\tisp_mmu_unmap(&bdev->mmu, virt, 1);\n\t\tvirt += pgnr_to_size(1);\n\t}\n\n\tmutex_unlock(&bo->mutex);\n\tdev_err(atomisp_dev,\n\t\t\"setup MMU address mapping failed.\\n\");\n\treturn ret;\n\nstatus_err2:\n\tmutex_unlock(&bo->mutex);\n\tdev_err(atomisp_dev, \"buffer object already binded.\\n\");\n\treturn -EINVAL;\nstatus_err1:\n\tmutex_unlock(&bo->mutex);\n\tdev_err(atomisp_dev,\n\t\t\"buffer object vm_node or page not allocated.\\n\");\n\treturn -EINVAL;\n}\n\n \nvoid hmm_bo_unbind(struct hmm_buffer_object *bo)\n{\n\tunsigned int virt;\n\tstruct hmm_bo_device *bdev;\n\tunsigned int i;\n\n\tcheck_bo_null_return_void(bo);\n\n\tmutex_lock(&bo->mutex);\n\n\tcheck_bo_status_yes_goto(bo,\n\t\t\t\t HMM_BO_PAGE_ALLOCED |\n\t\t\t\t HMM_BO_ALLOCED |\n\t\t\t\t HMM_BO_BINDED, status_err);\n\n\tbdev = bo->bdev;\n\n\tvirt = bo->start;\n\n\tfor (i = 0; i < bo->pgnr; i++) {\n\t\tisp_mmu_unmap(&bdev->mmu, virt, 1);\n\t\tvirt += pgnr_to_size(1);\n\t}\n\n\t \n\tisp_mmu_flush_tlb_range(&bdev->mmu, bo->start,\n\t\t\t\t(bo->pgnr << PAGE_SHIFT));\n\n\tbo->status &= (~HMM_BO_BINDED);\n\n\tmutex_unlock(&bo->mutex);\n\n\treturn;\n\nstatus_err:\n\tmutex_unlock(&bo->mutex);\n\tdev_err(atomisp_dev,\n\t\t\"buffer vm or page not allocated or not binded yet.\\n\");\n}\n\nint hmm_bo_binded(struct hmm_buffer_object *bo)\n{\n\tint ret;\n\n\tcheck_bo_null_return(bo, 0);\n\n\tmutex_lock(&bo->mutex);\n\n\tret = bo->status & HMM_BO_BINDED;\n\n\tmutex_unlock(&bo->mutex);\n\n\treturn ret;\n}\n\nvoid *hmm_bo_vmap(struct hmm_buffer_object *bo, bool cached)\n{\n\tcheck_bo_null_return(bo, NULL);\n\n\tmutex_lock(&bo->mutex);\n\tif (((bo->status & HMM_BO_VMAPED) && !cached) ||\n\t    ((bo->status & HMM_BO_VMAPED_CACHED) && cached)) {\n\t\tmutex_unlock(&bo->mutex);\n\t\treturn bo->vmap_addr;\n\t}\n\n\t \n\tif (bo->status & HMM_BO_VMAPED || bo->status & HMM_BO_VMAPED_CACHED) {\n\t\tvunmap(bo->vmap_addr);\n\t\tbo->vmap_addr = NULL;\n\t\tbo->status &= ~(HMM_BO_VMAPED | HMM_BO_VMAPED_CACHED);\n\t}\n\n\tbo->vmap_addr = vmap(bo->pages, bo->pgnr, VM_MAP,\n\t\t\t     cached ? PAGE_KERNEL : PAGE_KERNEL_NOCACHE);\n\tif (unlikely(!bo->vmap_addr)) {\n\t\tmutex_unlock(&bo->mutex);\n\t\tdev_err(atomisp_dev, \"vmap failed...\\n\");\n\t\treturn NULL;\n\t}\n\tbo->status |= (cached ? HMM_BO_VMAPED_CACHED : HMM_BO_VMAPED);\n\n\tmutex_unlock(&bo->mutex);\n\treturn bo->vmap_addr;\n}\n\nvoid hmm_bo_flush_vmap(struct hmm_buffer_object *bo)\n{\n\tcheck_bo_null_return_void(bo);\n\n\tmutex_lock(&bo->mutex);\n\tif (!(bo->status & HMM_BO_VMAPED_CACHED) || !bo->vmap_addr) {\n\t\tmutex_unlock(&bo->mutex);\n\t\treturn;\n\t}\n\n\tclflush_cache_range(bo->vmap_addr, bo->pgnr * PAGE_SIZE);\n\tmutex_unlock(&bo->mutex);\n}\n\nvoid hmm_bo_vunmap(struct hmm_buffer_object *bo)\n{\n\tcheck_bo_null_return_void(bo);\n\n\tmutex_lock(&bo->mutex);\n\tif (bo->status & HMM_BO_VMAPED || bo->status & HMM_BO_VMAPED_CACHED) {\n\t\tvunmap(bo->vmap_addr);\n\t\tbo->vmap_addr = NULL;\n\t\tbo->status &= ~(HMM_BO_VMAPED | HMM_BO_VMAPED_CACHED);\n\t}\n\n\tmutex_unlock(&bo->mutex);\n\treturn;\n}\n\nvoid hmm_bo_ref(struct hmm_buffer_object *bo)\n{\n\tcheck_bo_null_return_void(bo);\n\n\tkref_get(&bo->kref);\n}\n\nstatic void kref_hmm_bo_release(struct kref *kref)\n{\n\tif (!kref)\n\t\treturn;\n\n\thmm_bo_release(kref_to_hmm_bo(kref));\n}\n\nvoid hmm_bo_unref(struct hmm_buffer_object *bo)\n{\n\tcheck_bo_null_return_void(bo);\n\n\tkref_put(&bo->kref, kref_hmm_bo_release);\n}\n\nstatic void hmm_bo_vm_open(struct vm_area_struct *vma)\n{\n\tstruct hmm_buffer_object *bo =\n\t    (struct hmm_buffer_object *)vma->vm_private_data;\n\n\tcheck_bo_null_return_void(bo);\n\n\thmm_bo_ref(bo);\n\n\tmutex_lock(&bo->mutex);\n\n\tbo->status |= HMM_BO_MMAPED;\n\n\tbo->mmap_count++;\n\n\tmutex_unlock(&bo->mutex);\n}\n\nstatic void hmm_bo_vm_close(struct vm_area_struct *vma)\n{\n\tstruct hmm_buffer_object *bo =\n\t    (struct hmm_buffer_object *)vma->vm_private_data;\n\n\tcheck_bo_null_return_void(bo);\n\n\thmm_bo_unref(bo);\n\n\tmutex_lock(&bo->mutex);\n\n\tbo->mmap_count--;\n\n\tif (!bo->mmap_count) {\n\t\tbo->status &= (~HMM_BO_MMAPED);\n\t\tvma->vm_private_data = NULL;\n\t}\n\n\tmutex_unlock(&bo->mutex);\n}\n\nstatic const struct vm_operations_struct hmm_bo_vm_ops = {\n\t.open = hmm_bo_vm_open,\n\t.close = hmm_bo_vm_close,\n};\n\n \nint hmm_bo_mmap(struct vm_area_struct *vma, struct hmm_buffer_object *bo)\n{\n\tunsigned int start, end;\n\tunsigned int virt;\n\tunsigned int pgnr, i;\n\tunsigned int pfn;\n\n\tcheck_bo_null_return(bo, -EINVAL);\n\n\tcheck_bo_status_yes_goto(bo, HMM_BO_PAGE_ALLOCED, status_err);\n\n\tpgnr = bo->pgnr;\n\tstart = vma->vm_start;\n\tend = vma->vm_end;\n\n\t \n\tif ((start + pgnr_to_size(pgnr)) != end) {\n\t\tdev_warn(atomisp_dev,\n\t\t\t \"vma's address space size not equal to buffer object's size\");\n\t\treturn -EINVAL;\n\t}\n\n\tvirt = vma->vm_start;\n\tfor (i = 0; i < pgnr; i++) {\n\t\tpfn = page_to_pfn(bo->pages[i]);\n\t\tif (remap_pfn_range(vma, virt, pfn, PAGE_SIZE, PAGE_SHARED)) {\n\t\t\tdev_warn(atomisp_dev,\n\t\t\t\t \"remap_pfn_range failed: virt = 0x%x, pfn = 0x%x, mapped_pgnr = %d\\n\",\n\t\t\t\t virt, pfn, 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvirt += PAGE_SIZE;\n\t}\n\n\tvma->vm_private_data = bo;\n\n\tvma->vm_ops = &hmm_bo_vm_ops;\n\tvm_flags_set(vma, VM_IO | VM_DONTEXPAND | VM_DONTDUMP);\n\n\t \n\thmm_bo_vm_open(vma);\n\n\treturn 0;\n\nstatus_err:\n\tdev_err(atomisp_dev, \"buffer page not allocated yet.\\n\");\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}