{
  "module_name": "isp.c",
  "hash_id": "2d4e26040b3ac75fb68b0d383ba35e2b9fc0989a7c675c52780f6646ca7b85be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/isp.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include <system_global.h>\n#include \"isp.h\"\n\n#ifndef __INLINE_ISP__\n#include \"isp_private.h\"\n#endif  \n\n#include \"assert_support.h\"\n\nvoid cnd_isp_irq_enable(\n    const isp_ID_t\t\tID,\n    const bool\t\tcnd)\n{\n\tif (cnd) {\n\t\tisp_ctrl_setbit(ID, ISP_IRQ_READY_REG, ISP_IRQ_READY_BIT);\n\t\t \n\t\tisp_ctrl_setbit(ID, ISP_IRQ_CLEAR_REG, ISP_IRQ_CLEAR_BIT);\n\t} else {\n\t\tisp_ctrl_clearbit(ID, ISP_IRQ_READY_REG,\n\t\t\t\t  ISP_IRQ_READY_BIT);\n\t}\n\treturn;\n}\n\nvoid isp_get_state(\n    const isp_ID_t\t\tID,\n    isp_state_t\t\t\t*state,\n    isp_stall_t\t\t\t*stall)\n{\n\thrt_data sc = isp_ctrl_load(ID, ISP_SC_REG);\n\n\tassert(state);\n\tassert(stall);\n\n#if defined(_hrt_sysmem_ident_address)\n\t \n\t(void)__hrt_sysmem_ident_address;\n\t(void)_hrt_sysmem_map_var;\n#endif\n\n\tstate->pc = isp_ctrl_load(ID, ISP_PC_REG);\n\tstate->status_register = sc;\n\tstate->is_broken = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_BROKEN_BIT);\n\tstate->is_idle = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_IDLE_BIT);\n\tstate->is_sleeping = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_SLEEPING_BIT);\n\tstate->is_stalling = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_STALLING_BIT);\n\tstall->stat_ctrl =\n\t    !isp_ctrl_getbit(ID, ISP_CTRL_SINK_REG, ISP_CTRL_SINK_BIT);\n\tstall->pmem =\n\t    !isp_ctrl_getbit(ID, ISP_PMEM_SINK_REG, ISP_PMEM_SINK_BIT);\n\tstall->dmem =\n\t    !isp_ctrl_getbit(ID, ISP_DMEM_SINK_REG, ISP_DMEM_SINK_BIT);\n\tstall->vmem =\n\t    !isp_ctrl_getbit(ID, ISP_VMEM_SINK_REG, ISP_VMEM_SINK_BIT);\n\tstall->fifo0 =\n\t    !isp_ctrl_getbit(ID, ISP_FIFO0_SINK_REG, ISP_FIFO0_SINK_BIT);\n\tstall->fifo1 =\n\t    !isp_ctrl_getbit(ID, ISP_FIFO1_SINK_REG, ISP_FIFO1_SINK_BIT);\n\tstall->fifo2 =\n\t    !isp_ctrl_getbit(ID, ISP_FIFO2_SINK_REG, ISP_FIFO2_SINK_BIT);\n\tstall->fifo3 =\n\t    !isp_ctrl_getbit(ID, ISP_FIFO3_SINK_REG, ISP_FIFO3_SINK_BIT);\n\tstall->fifo4 =\n\t    !isp_ctrl_getbit(ID, ISP_FIFO4_SINK_REG, ISP_FIFO4_SINK_BIT);\n\tstall->fifo5 =\n\t    !isp_ctrl_getbit(ID, ISP_FIFO5_SINK_REG, ISP_FIFO5_SINK_BIT);\n\tstall->fifo6 =\n\t    !isp_ctrl_getbit(ID, ISP_FIFO6_SINK_REG, ISP_FIFO6_SINK_BIT);\n\tstall->vamem1 =\n\t    !isp_ctrl_getbit(ID, ISP_VAMEM1_SINK_REG, ISP_VAMEM1_SINK_BIT);\n\tstall->vamem2 =\n\t    !isp_ctrl_getbit(ID, ISP_VAMEM2_SINK_REG, ISP_VAMEM2_SINK_BIT);\n\tstall->vamem3 =\n\t    !isp_ctrl_getbit(ID, ISP_VAMEM3_SINK_REG, ISP_VAMEM3_SINK_BIT);\n\tstall->hmem =\n\t    !isp_ctrl_getbit(ID, ISP_HMEM_SINK_REG, ISP_HMEM_SINK_BIT);\n\t \n\treturn;\n}\n\n \n\n \nunsigned int isp_is_ready(isp_ID_t ID)\n{\n\tassert(ID < N_ISP_ID);\n\treturn isp_ctrl_getbit(ID, ISP_SC_REG, ISP_IDLE_BIT);\n}\n\n \nunsigned int isp_is_sleeping(isp_ID_t ID)\n{\n\tassert(ID < N_ISP_ID);\n\treturn isp_ctrl_getbit(ID, ISP_SC_REG, ISP_SLEEPING_BIT);\n}\n\n \nvoid isp_start(isp_ID_t ID)\n{\n\tassert(ID < N_ISP_ID);\n}\n\n \nvoid isp_wake(isp_ID_t ID)\n{\n\tassert(ID < N_ISP_ID);\n\tisp_ctrl_setbit(ID, ISP_SC_REG, ISP_START_BIT);\n\tudelay(1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}