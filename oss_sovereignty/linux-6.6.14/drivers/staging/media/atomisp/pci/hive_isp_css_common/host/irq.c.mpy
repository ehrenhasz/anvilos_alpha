{
  "module_name": "irq.c",
  "hash_id": "f8fa9004e9b68aa54c36dcbe34594ab0121c0f6cd18c8b2bfc616eec1f9d325f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/irq.c",
  "human_readable_source": "\n \n\n#include \"assert_support.h\"\n#include \"irq.h\"\n\n#ifndef __INLINE_GP_DEVICE__\n#define __INLINE_GP_DEVICE__\n#endif\n#include \"gp_device.h\"\t \n\nstatic inline void irq_wait_for_write_complete(\n    const irq_ID_t\t\tID);\n\nstatic inline bool any_irq_channel_enabled(\n    const irq_ID_t\t\t\t\tID);\n\nstatic inline irq_ID_t virq_get_irq_id(const enum virq_id irq_ID,\n\t\t\t\t       unsigned int *channel_ID);\n\n#ifndef __INLINE_IRQ__\n#include \"irq_private.h\"\n#endif  \n\nstatic unsigned short IRQ_N_CHANNEL[N_IRQ_ID] = {\n\tIRQ0_ID_N_CHANNEL,\n\tIRQ1_ID_N_CHANNEL,\n\tIRQ2_ID_N_CHANNEL,\n\tIRQ3_ID_N_CHANNEL\n};\n\nstatic unsigned short IRQ_N_ID_OFFSET[N_IRQ_ID + 1] = {\n\tIRQ0_ID_OFFSET,\n\tIRQ1_ID_OFFSET,\n\tIRQ2_ID_OFFSET,\n\tIRQ3_ID_OFFSET,\n\tIRQ_END_OFFSET\n};\n\nstatic enum virq_id IRQ_NESTING_ID[N_IRQ_ID] = {\n\tN_virq_id,\n\tvirq_ifmt,\n\tvirq_isys,\n\tvirq_isel\n};\n\nvoid irq_clear_all(\n    const irq_ID_t\t\t\t\tID)\n{\n\thrt_data\tmask = 0xFFFFFFFF;\n\n\tassert(ID < N_IRQ_ID);\n\tassert(IRQ_N_CHANNEL[ID] <= HRT_DATA_WIDTH);\n\n\tif (IRQ_N_CHANNEL[ID] < HRT_DATA_WIDTH) {\n\t\tmask = ~((~(hrt_data)0) >> IRQ_N_CHANNEL[ID]);\n\t}\n\n\tirq_reg_store(ID,\n\t\t      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, mask);\n\treturn;\n}\n\n \nvoid irq_enable_channel(\n    const irq_ID_t\t\t\t\tID,\n    const unsigned int\t\t\tirq_id)\n{\n\tunsigned int mask = irq_reg_load(ID,\n\t\t\t\t\t _HRT_IRQ_CONTROLLER_MASK_REG_IDX);\n\tunsigned int enable = irq_reg_load(ID,\n\t\t\t\t\t   _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);\n\tunsigned int edge_in = irq_reg_load(ID,\n\t\t\t\t\t    _HRT_IRQ_CONTROLLER_EDGE_REG_IDX);\n\tunsigned int me = 1U << irq_id;\n\n\tassert(ID < N_IRQ_ID);\n\tassert(irq_id < IRQ_N_CHANNEL[ID]);\n\n\tmask |= me;\n\tenable |= me;\n\tedge_in |= me;\t \n\n\t \n\n\t \n\tirq_reg_store(ID,\n\t\t      _HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask & ~me);\n\t \n\tirq_reg_store(ID,\n\t\t      _HRT_IRQ_CONTROLLER_EDGE_REG_IDX, edge_in);\n\t \n\tirq_reg_store(ID,\n\t\t      _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX, enable);\n\t \n\tirq_reg_store(ID,\n\t\t      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, me);\n\t \n\tirq_reg_store(ID,\n\t\t      _HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask);\n\n\tirq_wait_for_write_complete(ID);\n\n\treturn;\n}\n\nvoid irq_enable_pulse(\n    const irq_ID_t\tID,\n    bool\t\t\tpulse)\n{\n\tunsigned int edge_out = 0x0;\n\n\tif (pulse) {\n\t\tedge_out = 0xffffffff;\n\t}\n\t \n\tirq_reg_store(ID,\n\t\t      _HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX, edge_out);\n\treturn;\n}\n\nvoid irq_disable_channel(\n    const irq_ID_t\t\t\t\tID,\n    const unsigned int\t\t\tirq_id)\n{\n\tunsigned int mask = irq_reg_load(ID,\n\t\t\t\t\t _HRT_IRQ_CONTROLLER_MASK_REG_IDX);\n\tunsigned int enable = irq_reg_load(ID,\n\t\t\t\t\t   _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);\n\tunsigned int me = 1U << irq_id;\n\n\tassert(ID < N_IRQ_ID);\n\tassert(irq_id < IRQ_N_CHANNEL[ID]);\n\n\tmask &= ~me;\n\tenable &= ~me;\n\n\t \n\tirq_reg_store(ID,\n\t\t      _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX, enable);\n\t \n\tirq_reg_store(ID,\n\t\t      _HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask);\n\t \n\tirq_reg_store(ID,\n\t\t      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, me);\n\n\tirq_wait_for_write_complete(ID);\n\n\treturn;\n}\n\nenum hrt_isp_css_irq_status irq_get_channel_id(\n    const irq_ID_t\t\t\t\tID,\n    unsigned int\t\t\t\t*irq_id)\n{\n\tunsigned int irq_status = irq_reg_load(ID,\n\t\t\t\t\t       _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);\n\tunsigned int idx;\n\tenum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_success;\n\n\tassert(ID < N_IRQ_ID);\n\tassert(irq_id);\n\n\t \n\tfor (idx = 0; idx < IRQ_N_CHANNEL[ID]; idx++) {\n\t\tif (irq_status & (1U << idx))\n\t\t\tbreak;\n\t}\n\tif (idx == IRQ_N_CHANNEL[ID])\n\t\treturn hrt_isp_css_irq_status_error;\n\n\t \n\tif (irq_status != (1U << idx))\n\t\tstatus = hrt_isp_css_irq_status_more_irqs;\n\n\tirq_reg_store(ID,\n\t\t      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << idx);\n\n\tirq_wait_for_write_complete(ID);\n\n\tif (irq_id)\n\t\t*irq_id = (unsigned int)idx;\n\n\treturn status;\n}\n\nstatic const hrt_address IRQ_REQUEST_ADDR[N_IRQ_SW_CHANNEL_ID] = {\n\t_REG_GP_IRQ_REQUEST0_ADDR,\n\t_REG_GP_IRQ_REQUEST1_ADDR\n};\n\nvoid irq_raise(\n    const irq_ID_t\t\t\t\tID,\n    const irq_sw_channel_id_t\tirq_id)\n{\n\thrt_address\t\taddr;\n\n\tOP___assert(ID == IRQ0_ID);\n\tOP___assert(IRQ_BASE[ID] != (hrt_address)-1);\n\tOP___assert(irq_id < N_IRQ_SW_CHANNEL_ID);\n\n\t(void)ID;\n\n\taddr = IRQ_REQUEST_ADDR[irq_id];\n\t \n\tgp_device_reg_store(GP_DEVICE0_ID,\n\t\t\t    (unsigned int)addr, 1);\n\tgp_device_reg_store(GP_DEVICE0_ID,\n\t\t\t    (unsigned int)addr, 0);\n\treturn;\n}\n\nvoid irq_controller_get_state(const irq_ID_t ID,\n\t\t\t      struct irq_controller_state *state)\n{\n\tassert(ID < N_IRQ_ID);\n\tassert(state);\n\n\tstate->irq_edge = irq_reg_load(ID,\n\t\t\t\t       _HRT_IRQ_CONTROLLER_EDGE_REG_IDX);\n\tstate->irq_mask = irq_reg_load(ID,\n\t\t\t\t       _HRT_IRQ_CONTROLLER_MASK_REG_IDX);\n\tstate->irq_status = irq_reg_load(ID,\n\t\t\t\t\t _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);\n\tstate->irq_enable = irq_reg_load(ID,\n\t\t\t\t\t _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);\n\tstate->irq_level_not_pulse = irq_reg_load(ID,\n\t\t\t\t     _HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX);\n\treturn;\n}\n\nbool any_virq_signal(void)\n{\n\tunsigned int irq_status = irq_reg_load(IRQ0_ID,\n\t\t\t\t\t       _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);\n\n\treturn (irq_status != 0);\n}\n\nvoid cnd_virq_enable_channel(\n    const enum virq_id\t\t\t\tirq_ID,\n    const bool\t\t\t\t\ten)\n{\n\tirq_ID_t\t\ti;\n\tunsigned int\tchannel_ID;\n\tirq_ID_t\t\tID = virq_get_irq_id(irq_ID, &channel_ID);\n\n\tassert(ID < N_IRQ_ID);\n\n\tfor (i = IRQ1_ID; i < N_IRQ_ID; i++) {\n\t\t \n\t\tassert(irq_ID != IRQ_NESTING_ID[i]);\n\t}\n\n\tif (en) {\n\t\tirq_enable_channel(ID, channel_ID);\n\t\tif (IRQ_NESTING_ID[ID] != N_virq_id) {\n\t\t\t \n\t\t\tirq_enable_channel(IRQ0_ID, IRQ_NESTING_ID[ID]);\n\t\t}\n\t} else {\n\t\tirq_disable_channel(ID, channel_ID);\n\t\tif ((IRQ_NESTING_ID[ID] != N_virq_id) && !any_irq_channel_enabled(ID)) {\n\t\t\t \n\t\t\tirq_disable_channel(IRQ0_ID, IRQ_NESTING_ID[ID]);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid virq_clear_all(void)\n{\n\tirq_ID_t\tirq_id;\n\n\tfor (irq_id = (irq_ID_t)0; irq_id < N_IRQ_ID; irq_id++) {\n\t\tirq_clear_all(irq_id);\n\t}\n\treturn;\n}\n\nenum hrt_isp_css_irq_status\nvirq_get_channel_signals(struct virq_info *irq_info)\n{\n\tenum hrt_isp_css_irq_status irq_status = hrt_isp_css_irq_status_error;\n\tirq_ID_t ID;\n\n\tassert(irq_info);\n\n\tfor (ID = (irq_ID_t)0 ; ID < N_IRQ_ID; ID++) {\n\t\tif (any_irq_channel_enabled(ID)) {\n\t\t\thrt_data\tirq_data = irq_reg_load(ID,\n\t\t\t\t\t\t\t    _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);\n\n\t\t\tif (irq_data != 0) {\n\t\t\t\t \n\t\t\t\tirq_status = hrt_isp_css_irq_status_success;\n\t\t\t}\n\n\t\t\tirq_info->irq_status_reg[ID] |= irq_data;\n\n\t\t\tirq_reg_store(ID,\n\t\t\t\t      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, irq_data);\n\n\t\t\tirq_wait_for_write_complete(ID);\n\t\t}\n\t}\n\n\treturn irq_status;\n}\n\nvoid virq_clear_info(struct virq_info *irq_info)\n{\n\tirq_ID_t ID;\n\n\tassert(irq_info);\n\n\tfor (ID = (irq_ID_t)0 ; ID < N_IRQ_ID; ID++) {\n\t\tirq_info->irq_status_reg[ID] = 0;\n\t}\n\treturn;\n}\n\nenum hrt_isp_css_irq_status virq_get_channel_id(\n    enum virq_id\t\t\t\t\t*irq_id)\n{\n\tunsigned int irq_status = irq_reg_load(IRQ0_ID,\n\t\t\t\t\t       _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);\n\tunsigned int idx;\n\tenum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_success;\n\tirq_ID_t ID;\n\n\tassert(irq_id);\n\n\t \n\tfor (idx = 0; idx < IRQ_N_CHANNEL[IRQ0_ID]; idx++) {\n\t\tif (irq_status & (1U << idx))\n\t\t\tbreak;\n\t}\n\n\tif (idx == IRQ_N_CHANNEL[IRQ0_ID]) {\n\t\treturn hrt_isp_css_irq_status_error;\n\t}\n\n\t \n\tif (irq_status != (1U << idx)) {\n\t\tstatus = hrt_isp_css_irq_status_more_irqs;\n\t}\n\n\t \n\tfor (ID = N_IRQ_ID - 1 ; ID > (irq_ID_t)0; ID--) {\n\t\tif (IRQ_NESTING_ID[ID] == (enum virq_id)idx) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (ID != IRQ0_ID) {\n\t\tirq_status = irq_reg_load(ID,\n\t\t\t\t\t  _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);\n\t\t \n\t\tfor (idx = 0; idx < IRQ_N_CHANNEL[ID]; idx++) {\n\t\t\tif (irq_status & (1U << idx))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (idx == IRQ_N_CHANNEL[ID]) {\n\t\t\treturn hrt_isp_css_irq_status_error;\n\t\t}\n\n\t\t \n\t\tif (irq_status != (1U << idx)) {\n\t\t\tstatus = hrt_isp_css_irq_status_more_irqs;\n\t\t} else {\n\t\t\t \n\t\t\tirq_reg_store(IRQ0_ID,\n\t\t\t\t      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << IRQ_NESTING_ID[ID]);\n\t\t}\n\t}  \n\n\t \n\tirq_reg_store(ID,\n\t\t      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << idx);\n\n\tirq_wait_for_write_complete(ID);\n\n\tidx += IRQ_N_ID_OFFSET[ID];\n\tif (irq_id)\n\t\t*irq_id = (enum virq_id)idx;\n\n\treturn status;\n}\n\nstatic inline void irq_wait_for_write_complete(\n    const irq_ID_t\t\tID)\n{\n\tassert(ID < N_IRQ_ID);\n\tassert(IRQ_BASE[ID] != (hrt_address)-1);\n\t(void)ia_css_device_load_uint32(IRQ_BASE[ID] +\n\t\t\t\t\t_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX * sizeof(hrt_data));\n}\n\nstatic inline bool any_irq_channel_enabled(\n    const irq_ID_t\t\t\t\tID)\n{\n\thrt_data\ten_reg;\n\n\tassert(ID < N_IRQ_ID);\n\n\ten_reg = irq_reg_load(ID,\n\t\t\t      _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);\n\n\treturn (en_reg != 0);\n}\n\nstatic inline irq_ID_t virq_get_irq_id(\n    const enum virq_id\t\tirq_ID,\n    unsigned int\t\t*channel_ID)\n{\n\tirq_ID_t ID;\n\n\tassert(channel_ID);\n\n\tfor (ID = (irq_ID_t)0 ; ID < N_IRQ_ID; ID++) {\n\t\tif (irq_ID < IRQ_N_ID_OFFSET[ID + 1]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*channel_ID = (unsigned int)irq_ID - IRQ_N_ID_OFFSET[ID];\n\n\treturn ID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}