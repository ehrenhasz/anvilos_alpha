{
  "module_name": "vmem.c",
  "hash_id": "645b4c8dc2c0060f32fb777d1a1b591443de64e7e4c8a0020c01a6fef655b178",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/vmem.c",
  "human_readable_source": "\n \n\n#include \"isp.h\"\n#include \"vmem.h\"\n#include \"vmem_local.h\"\n\n#if !defined(HRT_MEMORY_ACCESS)\n#include \"ia_css_device_access.h\"\n#endif\n#include \"assert_support.h\"\n\ntypedef unsigned long long hive_uedge;\ntypedef hive_uedge *hive_wide;\n\n \n\n \nstatic inline hive_uedge\nsubword(hive_uedge w, unsigned int start, unsigned int end)\n{\n\treturn (w & (((1ULL << (end - 1)) - 1) << 1 | 1)) >> start;\n}\n\n \nstatic inline hive_uedge\ninv_subword(hive_uedge w, unsigned int start, unsigned int end)\n{\n\treturn w & (~(((1ULL << (end - 1)) - 1) << 1 | 1) | ((1ULL << start) - 1));\n}\n\n#define uedge_bits (8 * sizeof(hive_uedge))\n#define move_lower_bits(target, target_bit, src, src_bit) move_subword(target, target_bit, src, 0, src_bit)\n#define move_upper_bits(target, target_bit, src, src_bit) move_subword(target, target_bit, src, src_bit, uedge_bits)\n#define move_word(target, target_bit, src) move_subword(target, target_bit, src, 0, uedge_bits)\n\nstatic void\nmove_subword(\n    hive_uedge *target,\n    unsigned int target_bit,\n    hive_uedge src,\n    unsigned int src_start,\n    unsigned int src_end)\n{\n\tunsigned int start_elem = target_bit / uedge_bits;\n\tunsigned int start_bit  = target_bit % uedge_bits;\n\tunsigned int subword_width = src_end - src_start;\n\n\thive_uedge src_subword = subword(src, src_start, src_end);\n\n\tif (subword_width + start_bit > uedge_bits) {  \n\t\thive_uedge old_val1;\n\t\thive_uedge old_val0 = inv_subword(target[start_elem], start_bit, uedge_bits);\n\n\t\ttarget[start_elem] = old_val0 | (src_subword << start_bit);\n\t\told_val1 = inv_subword(target[start_elem + 1], 0,\n\t\t\t\t       subword_width + start_bit - uedge_bits);\n\t\ttarget[start_elem + 1] = old_val1 | (src_subword >> (uedge_bits - start_bit));\n\t} else {\n\t\thive_uedge old_val = inv_subword(target[start_elem], start_bit,\n\t\t\t\t\t\t start_bit + subword_width);\n\n\t\ttarget[start_elem] = old_val | (src_subword << start_bit);\n\t}\n}\n\nstatic void\nhive_sim_wide_unpack(\n    hive_wide vector,\n    hive_wide elem,\n    hive_uint elem_bits,\n    hive_uint index)\n{\n\t \n\tunsigned int start_elem = (elem_bits * index) / uedge_bits;\n\tunsigned int start_bit  = (elem_bits * index) % uedge_bits;\n\tunsigned int end_elem   = (elem_bits * (index + 1) - 1) / uedge_bits;\n\tunsigned int end_bit    = ((elem_bits * (index + 1) - 1) % uedge_bits) + 1;\n\n\tif (elem_bits == uedge_bits) {\n\t\t \n\t\telem[0] = vector[index];\n\t} else if (start_elem == end_elem) {\n\t\t \n\t\tmove_subword(elem, 0, vector[start_elem], start_bit, end_bit);\n\t} else {\n\t\t \n\t\tunsigned int bits_written = 0;\n\t\tunsigned int i;\n\n\t\tmove_upper_bits(elem, bits_written, vector[start_elem], start_bit);\n\t\tbits_written += (64 - start_bit);\n\t\tfor (i = start_elem + 1; i < end_elem; i++) {\n\t\t\tmove_word(elem, bits_written, vector[i]);\n\t\t\tbits_written += uedge_bits;\n\t\t}\n\t\tmove_lower_bits(elem, bits_written, vector[end_elem], end_bit);\n\t}\n}\n\nstatic void\nhive_sim_wide_pack(\n    hive_wide vector,\n    hive_wide elem,\n    hive_uint elem_bits,\n    hive_uint index)\n{\n\t \n\tunsigned int start_elem = (elem_bits * index) / uedge_bits;\n\n\t \n\tif (elem_bits == uedge_bits) {\n\t\tvector[start_elem] = elem[0];\n\t} else if (elem_bits > uedge_bits) {\n\t\tunsigned int bits_to_write = elem_bits;\n\t\tunsigned int start_bit = elem_bits * index;\n\t\tunsigned int i = 0;\n\n\t\tfor (; bits_to_write > uedge_bits;\n\t\t     bits_to_write -= uedge_bits, i++, start_bit += uedge_bits) {\n\t\t\tmove_word(vector, start_bit, elem[i]);\n\t\t}\n\t\tmove_lower_bits(vector, start_bit, elem[i], bits_to_write);\n\t} else {\n\t\t \n\t\tmove_lower_bits(vector, elem_bits * index, elem[0], elem_bits);\n\t}\n}\n\nstatic void load_vector(\n    const isp_ID_t\t\tID,\n    t_vmem_elem\t\t*to,\n    const t_vmem_elem\t*from)\n{\n\tunsigned int i;\n\thive_uedge *data;\n\tunsigned int size = sizeof(short) * ISP_NWAY;\n\n\tVMEM_ARRAY(v, 2 * ISP_NWAY);  \n\tassert(ISP_BAMEM_BASE[ID] != (hrt_address) - 1);\n#if !defined(HRT_MEMORY_ACCESS)\n\tia_css_device_load(ISP_BAMEM_BASE[ID] + (unsigned long)from, &v[0][0], size);\n#else\n\thrt_master_port_load(ISP_BAMEM_BASE[ID] + (unsigned long)from, &v[0][0], size);\n#endif\n\tdata = (hive_uedge *)v;\n\tfor (i = 0; i < ISP_NWAY; i++) {\n\t\thive_uedge elem = 0;\n\n\t\thive_sim_wide_unpack(data, &elem, ISP_VEC_ELEMBITS, i);\n\t\tto[i] = elem;\n\t}\n\tudelay(1);  \n}\n\nstatic void store_vector(\n    const isp_ID_t\t\tID,\n    t_vmem_elem\t\t*to,\n    const t_vmem_elem\t*from)\n{\n\tunsigned int i;\n\tunsigned int size = sizeof(short) * ISP_NWAY;\n\n\tVMEM_ARRAY(v, 2 * ISP_NWAY);  \n\t\n\thive_uedge *data = (hive_uedge *)v;\n\n\tfor (i = 0; i < ISP_NWAY; i++) {\n\t\thive_sim_wide_pack(data, (hive_wide)&from[i], ISP_VEC_ELEMBITS, i);\n\t}\n\tassert(ISP_BAMEM_BASE[ID] != (hrt_address) - 1);\n#if !defined(HRT_MEMORY_ACCESS)\n\tia_css_device_store(ISP_BAMEM_BASE[ID] + (unsigned long)to, &v, size);\n#else\n\t\n\thrt_master_port_store(ISP_BAMEM_BASE[ID] + (unsigned long)to, &v, size);\n#endif\n\tudelay(1);  \n}\n\nvoid isp_vmem_load(\n    const isp_ID_t\t\tID,\n    const t_vmem_elem\t*from,\n    t_vmem_elem\t\t*to,\n    unsigned int elems)  \n{\n\tunsigned int c;\n\tconst t_vmem_elem *vp = from;\n\n\tassert(ID < N_ISP_ID);\n\tassert((unsigned long)from % ISP_VEC_ALIGN == 0);\n\tassert(elems % ISP_NWAY == 0);\n\tfor (c = 0; c < elems; c += ISP_NWAY) {\n\t\tload_vector(ID, &to[c], vp);\n\t\tvp = (t_vmem_elem *)((char *)vp + ISP_VEC_ALIGN);\n\t}\n}\n\nvoid isp_vmem_store(\n    const isp_ID_t\t\tID,\n    t_vmem_elem\t\t*to,\n    const t_vmem_elem\t*from,\n    unsigned int elems)  \n{\n\tunsigned int c;\n\tt_vmem_elem *vp = to;\n\n\tassert(ID < N_ISP_ID);\n\tassert((unsigned long)to % ISP_VEC_ALIGN == 0);\n\tassert(elems % ISP_NWAY == 0);\n\tfor (c = 0; c < elems; c += ISP_NWAY) {\n\t\tstore_vector(ID, vp, &from[c]);\n\t\tvp = (t_vmem_elem *)((char *)vp + ISP_VEC_ALIGN);\n\t}\n}\n\nvoid isp_vmem_2d_load(\n    const isp_ID_t\t\tID,\n    const t_vmem_elem\t*from,\n    t_vmem_elem\t\t*to,\n    unsigned int height,\n    unsigned int width,\n    unsigned int stride_to,   \n\n    unsigned stride_from  )\n{\n\tunsigned int h;\n\n\tassert(ID < N_ISP_ID);\n\tassert((unsigned long)from % ISP_VEC_ALIGN == 0);\n\tassert(width % ISP_NWAY == 0);\n\tassert(stride_from % ISP_NWAY == 0);\n\tfor (h = 0; h < height; h++) {\n\t\tunsigned int c;\n\t\tconst t_vmem_elem *vp = from;\n\n\t\tfor (c = 0; c < width; c += ISP_NWAY) {\n\t\t\tload_vector(ID, &to[stride_to * h + c], vp);\n\t\t\tvp = (t_vmem_elem *)((char *)vp + ISP_VEC_ALIGN);\n\t\t}\n\t\tfrom = (const t_vmem_elem *)((const char *)from + stride_from / ISP_NWAY *\n\t\t\t\t\t     ISP_VEC_ALIGN);\n\t}\n}\n\nvoid isp_vmem_2d_store(\n    const isp_ID_t\t\tID,\n    t_vmem_elem\t\t*to,\n    const t_vmem_elem\t*from,\n    unsigned int height,\n    unsigned int width,\n    unsigned int stride_to,   \n\n    unsigned stride_from  )\n{\n\tunsigned int h;\n\n\tassert(ID < N_ISP_ID);\n\tassert((unsigned long)to % ISP_VEC_ALIGN == 0);\n\tassert(width % ISP_NWAY == 0);\n\tassert(stride_to % ISP_NWAY == 0);\n\tfor (h = 0; h < height; h++) {\n\t\tunsigned int c;\n\t\tt_vmem_elem *vp = to;\n\n\t\tfor (c = 0; c < width; c += ISP_NWAY) {\n\t\t\tstore_vector(ID, vp, &from[stride_from * h + c]);\n\t\t\tvp = (t_vmem_elem *)((char *)vp + ISP_VEC_ALIGN);\n\t\t}\n\t\tto = (t_vmem_elem *)((char *)to + stride_to / ISP_NWAY * ISP_VEC_ALIGN);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}