{
  "module_name": "sp_private.h",
  "hash_id": "2be2e76a6c7382c6f16c49c5ed5766650d6bc1dc4bdc22c6adcadfae018c9c6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/sp_private.h",
  "human_readable_source": " \n \n\n#ifndef __SP_PRIVATE_H_INCLUDED__\n#define __SP_PRIVATE_H_INCLUDED__\n\n#include \"sp_public.h\"\n\n#include \"device_access.h\"\n\n#include \"assert_support.h\"\n\nSTORAGE_CLASS_SP_C void sp_ctrl_store(\n    const sp_ID_t\t\tID,\n    const hrt_address\treg,\n    const hrt_data\t\tvalue)\n{\n\tassert(ID < N_SP_ID);\n\tassert(SP_CTRL_BASE[ID] != (hrt_address)-1);\n\tia_css_device_store_uint32(SP_CTRL_BASE[ID] + reg * sizeof(hrt_data), value);\n\treturn;\n}\n\nSTORAGE_CLASS_SP_C hrt_data sp_ctrl_load(\n    const sp_ID_t\t\tID,\n    const hrt_address\treg)\n{\n\tassert(ID < N_SP_ID);\n\tassert(SP_CTRL_BASE[ID] != (hrt_address)-1);\n\treturn ia_css_device_load_uint32(SP_CTRL_BASE[ID] + reg * sizeof(hrt_data));\n}\n\nSTORAGE_CLASS_SP_C bool sp_ctrl_getbit(\n    const sp_ID_t\t\tID,\n    const hrt_address\treg,\n    const unsigned int\tbit)\n{\n\thrt_data val = sp_ctrl_load(ID, reg);\n\n\treturn (val & (1UL << bit)) != 0;\n}\n\nSTORAGE_CLASS_SP_C void sp_ctrl_setbit(\n    const sp_ID_t\t\tID,\n    const hrt_address\treg,\n    const unsigned int\tbit)\n{\n\thrt_data\tdata = sp_ctrl_load(ID, reg);\n\n\tsp_ctrl_store(ID, reg, (data | (1UL << bit)));\n\treturn;\n}\n\nSTORAGE_CLASS_SP_C void sp_ctrl_clearbit(\n    const sp_ID_t\t\tID,\n    const hrt_address\treg,\n    const unsigned int\tbit)\n{\n\thrt_data\tdata = sp_ctrl_load(ID, reg);\n\n\tsp_ctrl_store(ID, reg, (data & ~(1UL << bit)));\n\treturn;\n}\n\nSTORAGE_CLASS_SP_C void sp_dmem_store(\n    const sp_ID_t\t\tID,\n    hrt_address\t\taddr,\n    const void\t\t\t*data,\n    const size_t\t\tsize)\n{\n\tassert(ID < N_SP_ID);\n\tassert(SP_DMEM_BASE[ID] != (hrt_address)-1);\n\tia_css_device_store(SP_DMEM_BASE[ID] + addr, data, size);\n\treturn;\n}\n\nSTORAGE_CLASS_SP_C void sp_dmem_load(\n    const sp_ID_t\t\tID,\n    const hrt_address\taddr,\n    void\t\t\t\t*data,\n    const size_t\t\tsize)\n{\n\tassert(ID < N_SP_ID);\n\tassert(SP_DMEM_BASE[ID] != (hrt_address)-1);\n\tia_css_device_load(SP_DMEM_BASE[ID] + addr, data, size);\n\treturn;\n}\n\nSTORAGE_CLASS_SP_C void sp_dmem_store_uint8(\n    const sp_ID_t\t\tID,\n    hrt_address\t\taddr,\n    const uint8_t\t\tdata)\n{\n\tassert(ID < N_SP_ID);\n\tassert(SP_DMEM_BASE[ID] != (hrt_address)-1);\n\t(void)ID;\n\tia_css_device_store_uint8(SP_DMEM_BASE[SP0_ID] + addr, data);\n\treturn;\n}\n\nSTORAGE_CLASS_SP_C void sp_dmem_store_uint16(\n    const sp_ID_t\t\tID,\n    hrt_address\t\taddr,\n    const uint16_t\t\tdata)\n{\n\tassert(ID < N_SP_ID);\n\tassert(SP_DMEM_BASE[ID] != (hrt_address)-1);\n\t(void)ID;\n\tia_css_device_store_uint16(SP_DMEM_BASE[SP0_ID] + addr, data);\n\treturn;\n}\n\nSTORAGE_CLASS_SP_C void sp_dmem_store_uint32(\n    const sp_ID_t\t\tID,\n    hrt_address\t\taddr,\n    const uint32_t\t\tdata)\n{\n\tassert(ID < N_SP_ID);\n\tassert(SP_DMEM_BASE[ID] != (hrt_address)-1);\n\t(void)ID;\n\tia_css_device_store_uint32(SP_DMEM_BASE[SP0_ID] + addr, data);\n\treturn;\n}\n\nSTORAGE_CLASS_SP_C uint8_t sp_dmem_load_uint8(\n    const sp_ID_t\t\tID,\n    const hrt_address\taddr)\n{\n\tassert(ID < N_SP_ID);\n\tassert(SP_DMEM_BASE[ID] != (hrt_address)-1);\n\t(void)ID;\n\treturn ia_css_device_load_uint8(SP_DMEM_BASE[SP0_ID] + addr);\n}\n\nSTORAGE_CLASS_SP_C uint16_t sp_dmem_load_uint16(\n    const sp_ID_t\t\tID,\n    const hrt_address\taddr)\n{\n\tassert(ID < N_SP_ID);\n\tassert(SP_DMEM_BASE[ID] != (hrt_address)-1);\n\t(void)ID;\n\treturn ia_css_device_load_uint16(SP_DMEM_BASE[SP0_ID] + addr);\n}\n\nSTORAGE_CLASS_SP_C uint32_t sp_dmem_load_uint32(\n    const sp_ID_t\t\tID,\n    const hrt_address\taddr)\n{\n\tassert(ID < N_SP_ID);\n\tassert(SP_DMEM_BASE[ID] != (hrt_address)-1);\n\t(void)ID;\n\treturn ia_css_device_load_uint32(SP_DMEM_BASE[SP0_ID] + addr);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}