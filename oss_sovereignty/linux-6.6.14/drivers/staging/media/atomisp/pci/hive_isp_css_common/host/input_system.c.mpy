{
  "module_name": "input_system.c",
  "hash_id": "bd1fedb41a83823216911732c4c651e78bd5ab7c3b3decaa1de9401ff5ac74c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_system.c",
  "human_readable_source": "\n \n\n#include \"system_global.h\"\n\n#ifndef ISP2401\n\n#include \"input_system.h\"\n#include <type_support.h>\n#include \"gp_device.h\"\n\n#include \"assert_support.h\"\n\n#ifndef __INLINE_INPUT_SYSTEM__\n#include \"input_system_private.h\"\n#endif  \n\n#define ZERO (0x0)\n#define ONE  (1U)\n\nstatic const isp2400_ib_buffer_t   IB_BUFFER_NULL = {0, 0, 0 };\n\nstatic input_system_err_t input_system_configure_channel(\n    const channel_cfg_t\t\tchannel);\n\nstatic input_system_err_t input_system_configure_channel_sensor(\n    const channel_cfg_t\t\tchannel);\n\nstatic input_system_err_t input_buffer_configuration(void);\n\nstatic input_system_err_t configuration_to_registers(void);\n\nstatic void receiver_rst(const rx_ID_t ID);\nstatic void input_system_network_rst(const input_system_ID_t ID);\n\nstatic void capture_unit_configure(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_id,\n    const isp2400_ib_buffer_t *const cfg);\n\nstatic void acquisition_unit_configure(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_id,\n    const isp2400_ib_buffer_t *const cfg);\n\nstatic void ctrl_unit_configure(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_id,\n    const ctrl_unit_cfg_t *const cfg);\n\nstatic void input_system_network_configure(\n    const input_system_ID_t\t\t\tID,\n    const input_system_network_cfg_t *const cfg);\n\n\nstatic input_system_err_t set_csi_cfg(\n    csi_cfg_t *const lhs,\n    const csi_cfg_t *const rhs,\n    input_system_config_flags_t *const flags);\n\nstatic input_system_err_t set_source_type(\n    input_system_source_t *const lhs,\n    const input_system_source_t\t\t\t\trhs,\n    input_system_config_flags_t *const flags);\n\nstatic input_system_err_t input_system_multiplexer_cfg(\n    input_system_multiplex_t *const lhs,\n    const input_system_multiplex_t\t\t\trhs,\n    input_system_config_flags_t *const flags);\n\nstatic inline void capture_unit_get_state(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_id,\n    capture_unit_state_t\t\t\t*state);\n\nstatic inline void acquisition_unit_get_state(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_id,\n    acquisition_unit_state_t\t\t*state);\n\nstatic inline void ctrl_unit_get_state(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_id,\n    ctrl_unit_state_t\t\t\t\t*state);\n\nstatic inline void mipi_port_get_state(\n    const rx_ID_t\t\t\t\t\tID,\n    const enum mipi_port_id\t\t\tport_ID,\n    mipi_port_state_t\t\t\t\t*state);\n\nstatic inline void rx_channel_get_state(\n    const rx_ID_t\t\t\t\t\tID,\n    const unsigned int\t\t\t\tch_id,\n    rx_channel_state_t\t\t\t\t*state);\n\nstatic void gp_device_rst(const gp_device_ID_t\t\tID);\n\nstatic void input_selector_cfg_for_sensor(const gp_device_ID_t\tID);\n\nstatic void input_switch_rst(const gp_device_ID_t\tID);\n\nstatic void input_switch_cfg(\n    const gp_device_ID_t\t\t\t\tID,\n    const input_switch_cfg_t *const cfg\n);\n\nvoid input_system_get_state(\n    const input_system_ID_t\t\t\tID,\n    input_system_state_t\t\t\t*state)\n{\n\tsub_system_ID_t\tsub_id;\n\n\tassert(ID < N_INPUT_SYSTEM_ID);\n\tassert(state);\n\n\tstate->str_multicastA_sel = input_system_sub_system_reg_load(ID,\n\t\t\t\t    GPREGS_UNIT0_ID,\n\t\t\t\t    HIVE_ISYS_GPREG_MULTICAST_A_IDX);\n\tstate->str_multicastB_sel = input_system_sub_system_reg_load(ID,\n\t\t\t\t    GPREGS_UNIT0_ID,\n\t\t\t\t    HIVE_ISYS_GPREG_MULTICAST_B_IDX);\n\tstate->str_multicastC_sel = input_system_sub_system_reg_load(ID,\n\t\t\t\t    GPREGS_UNIT0_ID,\n\t\t\t\t    HIVE_ISYS_GPREG_MULTICAST_C_IDX);\n\tstate->str_mux_sel = input_system_sub_system_reg_load(ID,\n\t\t\t     GPREGS_UNIT0_ID,\n\t\t\t     HIVE_ISYS_GPREG_MUX_IDX);\n\tstate->str_mon_status = input_system_sub_system_reg_load(ID,\n\t\t\t\tGPREGS_UNIT0_ID,\n\t\t\t\tHIVE_ISYS_GPREG_STRMON_STAT_IDX);\n\tstate->str_mon_irq_cond = input_system_sub_system_reg_load(ID,\n\t\t\t\t  GPREGS_UNIT0_ID,\n\t\t\t\t  HIVE_ISYS_GPREG_STRMON_COND_IDX);\n\tstate->str_mon_irq_en = input_system_sub_system_reg_load(ID,\n\t\t\t\tGPREGS_UNIT0_ID,\n\t\t\t\tHIVE_ISYS_GPREG_STRMON_IRQ_EN_IDX);\n\tstate->isys_srst = input_system_sub_system_reg_load(ID,\n\t\t\t   GPREGS_UNIT0_ID,\n\t\t\t   HIVE_ISYS_GPREG_SRST_IDX);\n\tstate->isys_slv_reg_srst = input_system_sub_system_reg_load(ID,\n\t\t\t\t   GPREGS_UNIT0_ID,\n\t\t\t\t   HIVE_ISYS_GPREG_SLV_REG_SRST_IDX);\n\tstate->str_deint_portA_cnt = input_system_sub_system_reg_load(ID,\n\t\t\t\t     GPREGS_UNIT0_ID,\n\t\t\t\t     HIVE_ISYS_GPREG_REG_PORT_A_IDX);\n\tstate->str_deint_portB_cnt = input_system_sub_system_reg_load(ID,\n\t\t\t\t     GPREGS_UNIT0_ID,\n\t\t\t\t     HIVE_ISYS_GPREG_REG_PORT_B_IDX);\n\n\tfor (sub_id = CAPTURE_UNIT0_ID; sub_id < CAPTURE_UNIT0_ID + N_CAPTURE_UNIT_ID;\n\t     sub_id++) {\n\t\tcapture_unit_get_state(ID, sub_id,\n\t\t\t\t       &state->capture_unit[sub_id - CAPTURE_UNIT0_ID]);\n\t}\n\tfor (sub_id = ACQUISITION_UNIT0_ID;\n\t     sub_id < ACQUISITION_UNIT0_ID + N_ACQUISITION_UNIT_ID; sub_id++) {\n\t\tacquisition_unit_get_state(ID, sub_id,\n\t\t\t\t\t   &state->acquisition_unit[sub_id - ACQUISITION_UNIT0_ID]);\n\t}\n\tfor (sub_id = CTRL_UNIT0_ID; sub_id < CTRL_UNIT0_ID + N_CTRL_UNIT_ID;\n\t     sub_id++) {\n\t\tctrl_unit_get_state(ID, sub_id,\n\t\t\t\t    &state->ctrl_unit_state[sub_id - CTRL_UNIT0_ID]);\n\t}\n}\n\nvoid receiver_get_state(\n    const rx_ID_t\t\t\t\tID,\n    receiver_state_t\t\t\t*state)\n{\n\tenum mipi_port_id\tport_id;\n\tunsigned int\tch_id;\n\n\tassert(ID < N_RX_ID);\n\tassert(state);\n\n\tstate->fs_to_ls_delay = (uint8_t)receiver_reg_load(ID,\n\t\t\t\t_HRT_CSS_RECEIVER_FS_TO_LS_DELAY_REG_IDX);\n\tstate->ls_to_data_delay = (uint8_t)receiver_reg_load(ID,\n\t\t\t\t  _HRT_CSS_RECEIVER_LS_TO_DATA_DELAY_REG_IDX);\n\tstate->data_to_le_delay = (uint8_t)receiver_reg_load(ID,\n\t\t\t\t  _HRT_CSS_RECEIVER_DATA_TO_LE_DELAY_REG_IDX);\n\tstate->le_to_fe_delay = (uint8_t)receiver_reg_load(ID,\n\t\t\t\t_HRT_CSS_RECEIVER_LE_TO_FE_DELAY_REG_IDX);\n\tstate->fe_to_fs_delay = (uint8_t)receiver_reg_load(ID,\n\t\t\t\t_HRT_CSS_RECEIVER_FE_TO_FS_DELAY_REG_IDX);\n\tstate->le_to_fs_delay = (uint8_t)receiver_reg_load(ID,\n\t\t\t\t_HRT_CSS_RECEIVER_LE_TO_LS_DELAY_REG_IDX);\n\tstate->is_two_ppc = (bool)receiver_reg_load(ID,\n\t\t\t    _HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX);\n\tstate->backend_rst = receiver_reg_load(ID,\n\t\t\t\t\t       _HRT_CSS_RECEIVER_BACKEND_RST_REG_IDX);\n\tstate->raw18 = (uint16_t)receiver_reg_load(ID,\n\t\t       _HRT_CSS_RECEIVER_RAW18_REG_IDX);\n\tstate->force_raw8 = (bool)receiver_reg_load(ID,\n\t\t\t    _HRT_CSS_RECEIVER_FORCE_RAW8_REG_IDX);\n\tstate->raw16 = (uint16_t)receiver_reg_load(ID,\n\t\t       _HRT_CSS_RECEIVER_RAW16_REG_IDX);\n\n\tfor (port_id = (enum mipi_port_id)0; port_id < N_MIPI_PORT_ID; port_id++) {\n\t\tmipi_port_get_state(ID, port_id,\n\t\t\t\t    &state->mipi_port_state[port_id]);\n\t}\n\tfor (ch_id = 0U; ch_id < N_RX_CHANNEL_ID; ch_id++) {\n\t\trx_channel_get_state(ID, ch_id,\n\t\t\t\t     &state->rx_channel_state[ch_id]);\n\t}\n\n\tstate->be_gsp_acc_ovl = receiver_reg_load(ID,\n\t\t\t\t_HRT_CSS_RECEIVER_BE_GSP_ACC_OVL_REG_IDX);\n\tstate->be_srst = receiver_reg_load(ID,\n\t\t\t\t\t   _HRT_CSS_RECEIVER_BE_SRST_REG_IDX);\n\tstate->be_is_two_ppc = receiver_reg_load(ID,\n\t\t\t       _HRT_CSS_RECEIVER_BE_TWO_PPC_REG_IDX);\n\tstate->be_comp_format0 = receiver_reg_load(ID,\n\t\t\t\t _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG0_IDX);\n\tstate->be_comp_format1 = receiver_reg_load(ID,\n\t\t\t\t _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG1_IDX);\n\tstate->be_comp_format2 = receiver_reg_load(ID,\n\t\t\t\t _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG2_IDX);\n\tstate->be_comp_format3 = receiver_reg_load(ID,\n\t\t\t\t _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG3_IDX);\n\tstate->be_sel = receiver_reg_load(ID,\n\t\t\t\t\t  _HRT_CSS_RECEIVER_BE_SEL_REG_IDX);\n\tstate->be_raw16_config = receiver_reg_load(ID,\n\t\t\t\t _HRT_CSS_RECEIVER_BE_RAW16_CONFIG_REG_IDX);\n\tstate->be_raw18_config = receiver_reg_load(ID,\n\t\t\t\t _HRT_CSS_RECEIVER_BE_RAW18_CONFIG_REG_IDX);\n\tstate->be_force_raw8 = receiver_reg_load(ID,\n\t\t\t       _HRT_CSS_RECEIVER_BE_FORCE_RAW8_REG_IDX);\n\tstate->be_irq_status = receiver_reg_load(ID,\n\t\t\t       _HRT_CSS_RECEIVER_BE_IRQ_STATUS_REG_IDX);\n\tstate->be_irq_clear = receiver_reg_load(ID,\n\t\t\t\t\t\t_HRT_CSS_RECEIVER_BE_IRQ_CLEAR_REG_IDX);\n}\n\nbool is_mipi_format_yuv420(\n    const mipi_format_t\t\t\tmipi_format)\n{\n\tbool\tis_yuv420 = (\n\t\t\t\t(mipi_format == MIPI_FORMAT_YUV420_8) ||\n\t\t\t\t(mipi_format == MIPI_FORMAT_YUV420_10) ||\n\t\t\t\t(mipi_format == MIPI_FORMAT_YUV420_8_SHIFT) ||\n\t\t\t\t(mipi_format == MIPI_FORMAT_YUV420_10_SHIFT));\n\t \n\n\treturn is_yuv420;\n}\n\nvoid receiver_set_compression(\n    const rx_ID_t\t\t\tID,\n    const unsigned int\t\tcfg_ID,\n    const mipi_compressor_t\t\tcomp,\n    const mipi_predictor_t\t\tpred)\n{\n\tconst unsigned int\t\tfield_id = cfg_ID % N_MIPI_FORMAT_CUSTOM;\n\tconst unsigned int\t\tch_id = cfg_ID / N_MIPI_FORMAT_CUSTOM;\n\thrt_data\t\t\tval;\n\thrt_address\t\t\taddr = 0;\n\thrt_data\t\t\treg;\n\n\tassert(ID < N_RX_ID);\n\tassert(cfg_ID < N_MIPI_COMPRESSOR_CONTEXT);\n\tassert(field_id < N_MIPI_FORMAT_CUSTOM);\n\tassert(ch_id < N_RX_CHANNEL_ID);\n\tassert(comp < N_MIPI_COMPRESSOR_METHODS);\n\tassert(pred < N_MIPI_PREDICTOR_TYPES);\n\n\tval = (((uint8_t)pred) << 3) | comp;\n\n\tswitch (ch_id) {\n\tcase 0:\n\t\taddr = ((field_id < 6) ? _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX :\n\t\t\t_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX);\n\t\tbreak;\n\tcase 1:\n\t\taddr = ((field_id < 6) ? _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX :\n\t\t\t_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX);\n\t\tbreak;\n\tcase 2:\n\t\taddr = ((field_id < 6) ? _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX :\n\t\t\t_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX);\n\t\tbreak;\n\tcase 3:\n\t\taddr = ((field_id < 6) ? _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX :\n\t\t\t_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tassert(false);\n\t\treturn;\n\t}\n\n\treg = ((field_id < 6) ? (val << (field_id * 5)) : (val << ((\n\t\t    field_id - 6) * 5)));\n\treceiver_reg_store(ID, addr, reg);\n}\n\nvoid receiver_port_enable(\n    const rx_ID_t\t\t\tID,\n    const enum mipi_port_id\t\tport_ID,\n    const bool\t\t\tcnd)\n{\n\thrt_data\treg = receiver_port_reg_load(ID, port_ID,\n\t\t\t  _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);\n\n\tif (cnd) {\n\t\treg |= 0x01;\n\t} else {\n\t\treg &= ~0x01;\n\t}\n\n\treceiver_port_reg_store(ID, port_ID,\n\t\t\t\t_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX, reg);\n}\n\nbool is_receiver_port_enabled(\n    const rx_ID_t\t\t\tID,\n    const enum mipi_port_id\t\tport_ID)\n{\n\thrt_data\treg = receiver_port_reg_load(ID, port_ID,\n\t\t\t  _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);\n\treturn ((reg & 0x01) != 0);\n}\n\nvoid receiver_irq_enable(\n    const rx_ID_t\t\t\tID,\n    const enum mipi_port_id\t\tport_ID,\n    const rx_irq_info_t\t\tirq_info)\n{\n\treceiver_port_reg_store(ID,\n\t\t\t\tport_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, irq_info);\n}\n\nrx_irq_info_t receiver_get_irq_info(\n    const rx_ID_t\t\t\tID,\n    const enum mipi_port_id\t\tport_ID)\n{\n\treturn receiver_port_reg_load(ID,\n\t\t\t\t      port_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);\n}\n\nvoid receiver_irq_clear(\n    const rx_ID_t\t\t\tID,\n    const enum mipi_port_id\t\tport_ID,\n    const rx_irq_info_t\t\tirq_info)\n{\n\treceiver_port_reg_store(ID,\n\t\t\t\tport_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX, irq_info);\n}\n\nstatic inline void capture_unit_get_state(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_id,\n    capture_unit_state_t\t\t\t*state)\n{\n\tassert(  (sub_id <= CAPTURE_UNIT2_ID));\n\tassert(state);\n\n\tstate->StartMode = input_system_sub_system_reg_load(ID,\n\t\t\t   sub_id,\n\t\t\t   CAPT_START_MODE_REG_ID);\n\tstate->Start_Addr = input_system_sub_system_reg_load(ID,\n\t\t\t    sub_id,\n\t\t\t    CAPT_START_ADDR_REG_ID);\n\tstate->Mem_Region_Size = input_system_sub_system_reg_load(ID,\n\t\t\t\t sub_id,\n\t\t\t\t CAPT_MEM_REGION_SIZE_REG_ID);\n\tstate->Num_Mem_Regions = input_system_sub_system_reg_load(ID,\n\t\t\t\t sub_id,\n\t\t\t\t CAPT_NUM_MEM_REGIONS_REG_ID);\n\n\t \n\tstate->Packet_Length = input_system_sub_system_reg_load(ID,\n\t\t\t       sub_id,\n\t\t\t       CAPT_PACKET_LENGTH_REG_ID);\n\tstate->Received_Length = input_system_sub_system_reg_load(ID,\n\t\t\t\t sub_id,\n\t\t\t\t CAPT_RECEIVED_LENGTH_REG_ID);\n\tstate->Received_Short_Packets = input_system_sub_system_reg_load(ID,\n\t\t\t\t\tsub_id,\n\t\t\t\t\tCAPT_RECEIVED_SHORT_PACKETS_REG_ID);\n\tstate->Received_Long_Packets = input_system_sub_system_reg_load(ID,\n\t\t\t\t       sub_id,\n\t\t\t\t       CAPT_RECEIVED_LONG_PACKETS_REG_ID);\n\tstate->Last_Command = input_system_sub_system_reg_load(ID,\n\t\t\t      sub_id,\n\t\t\t      CAPT_LAST_COMMAND_REG_ID);\n\tstate->Next_Command = input_system_sub_system_reg_load(ID,\n\t\t\t      sub_id,\n\t\t\t      CAPT_NEXT_COMMAND_REG_ID);\n\tstate->Last_Acknowledge = input_system_sub_system_reg_load(ID,\n\t\t\t\t  sub_id,\n\t\t\t\t  CAPT_LAST_ACKNOWLEDGE_REG_ID);\n\tstate->Next_Acknowledge = input_system_sub_system_reg_load(ID,\n\t\t\t\t  sub_id,\n\t\t\t\t  CAPT_NEXT_ACKNOWLEDGE_REG_ID);\n\tstate->FSM_State_Info = input_system_sub_system_reg_load(ID,\n\t\t\t\tsub_id,\n\t\t\t\tCAPT_FSM_STATE_INFO_REG_ID);\n}\n\nstatic inline void acquisition_unit_get_state(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_id,\n    acquisition_unit_state_t\t\t*state)\n{\n\tassert(sub_id == ACQUISITION_UNIT0_ID);\n\tassert(state);\n\n\tstate->Start_Addr = input_system_sub_system_reg_load(ID,\n\t\t\t    sub_id,\n\t\t\t    ACQ_START_ADDR_REG_ID);\n\tstate->Mem_Region_Size = input_system_sub_system_reg_load(ID,\n\t\t\t\t sub_id,\n\t\t\t\t ACQ_MEM_REGION_SIZE_REG_ID);\n\tstate->Num_Mem_Regions = input_system_sub_system_reg_load(ID,\n\t\t\t\t sub_id,\n\t\t\t\t ACQ_NUM_MEM_REGIONS_REG_ID);\n\n\t \n\tstate->Received_Short_Packets = input_system_sub_system_reg_load(ID,\n\t\t\t\t\tsub_id,\n\t\t\t\t\tACQ_RECEIVED_SHORT_PACKETS_REG_ID);\n\tstate->Received_Long_Packets = input_system_sub_system_reg_load(ID,\n\t\t\t\t       sub_id,\n\t\t\t\t       ACQ_RECEIVED_LONG_PACKETS_REG_ID);\n\tstate->Last_Command = input_system_sub_system_reg_load(ID,\n\t\t\t      sub_id,\n\t\t\t      ACQ_LAST_COMMAND_REG_ID);\n\tstate->Next_Command = input_system_sub_system_reg_load(ID,\n\t\t\t      sub_id,\n\t\t\t      ACQ_NEXT_COMMAND_REG_ID);\n\tstate->Last_Acknowledge = input_system_sub_system_reg_load(ID,\n\t\t\t\t  sub_id,\n\t\t\t\t  ACQ_LAST_ACKNOWLEDGE_REG_ID);\n\tstate->Next_Acknowledge = input_system_sub_system_reg_load(ID,\n\t\t\t\t  sub_id,\n\t\t\t\t  ACQ_NEXT_ACKNOWLEDGE_REG_ID);\n\tstate->FSM_State_Info = input_system_sub_system_reg_load(ID,\n\t\t\t\tsub_id,\n\t\t\t\tACQ_FSM_STATE_INFO_REG_ID);\n\tstate->Int_Cntr_Info = input_system_sub_system_reg_load(ID,\n\t\t\t       sub_id,\n\t\t\t       ACQ_INT_CNTR_INFO_REG_ID);\n}\n\nstatic inline void ctrl_unit_get_state(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_id,\n    ctrl_unit_state_t\t\t\t*state)\n{\n\tassert(sub_id == CTRL_UNIT0_ID);\n\tassert(state);\n\n\tstate->captA_start_addr = input_system_sub_system_reg_load(ID,\n\t\t\t\t  sub_id,\n\t\t\t\t  ISYS_CTRL_CAPT_START_ADDR_A_REG_ID);\n\tstate->captB_start_addr = input_system_sub_system_reg_load(ID,\n\t\t\t\t  sub_id,\n\t\t\t\t  ISYS_CTRL_CAPT_START_ADDR_B_REG_ID);\n\tstate->captC_start_addr = input_system_sub_system_reg_load(ID,\n\t\t\t\t  sub_id,\n\t\t\t\t  ISYS_CTRL_CAPT_START_ADDR_C_REG_ID);\n\tstate->captA_mem_region_size = input_system_sub_system_reg_load(ID,\n\t\t\t\t       sub_id,\n\t\t\t\t       ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_ID);\n\tstate->captB_mem_region_size = input_system_sub_system_reg_load(ID,\n\t\t\t\t       sub_id,\n\t\t\t\t       ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_ID);\n\tstate->captC_mem_region_size = input_system_sub_system_reg_load(ID,\n\t\t\t\t       sub_id,\n\t\t\t\t       ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_ID);\n\tstate->captA_num_mem_regions = input_system_sub_system_reg_load(ID,\n\t\t\t\t       sub_id,\n\t\t\t\t       ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_ID);\n\tstate->captB_num_mem_regions = input_system_sub_system_reg_load(ID,\n\t\t\t\t       sub_id,\n\t\t\t\t       ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_ID);\n\tstate->captC_num_mem_regions = input_system_sub_system_reg_load(ID,\n\t\t\t\t       sub_id,\n\t\t\t\t       ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_ID);\n\tstate->acq_start_addr = input_system_sub_system_reg_load(ID,\n\t\t\t\tsub_id,\n\t\t\t\tISYS_CTRL_ACQ_START_ADDR_REG_ID);\n\tstate->acq_mem_region_size = input_system_sub_system_reg_load(ID,\n\t\t\t\t     sub_id,\n\t\t\t\t     ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_ID);\n\tstate->acq_num_mem_regions = input_system_sub_system_reg_load(ID,\n\t\t\t\t     sub_id,\n\t\t\t\t     ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_ID);\n\n\t \n\tstate->last_cmd = input_system_sub_system_reg_load(ID,\n\t\t\t  sub_id,\n\t\t\t  ISYS_CTRL_LAST_COMMAND_REG_ID);\n\tstate->next_cmd = input_system_sub_system_reg_load(ID,\n\t\t\t  sub_id,\n\t\t\t  ISYS_CTRL_NEXT_COMMAND_REG_ID);\n\tstate->last_ack = input_system_sub_system_reg_load(ID,\n\t\t\t  sub_id,\n\t\t\t  ISYS_CTRL_LAST_ACKNOWLEDGE_REG_ID);\n\tstate->next_ack = input_system_sub_system_reg_load(ID,\n\t\t\t  sub_id,\n\t\t\t  ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_ID);\n\tstate->top_fsm_state = input_system_sub_system_reg_load(ID,\n\t\t\t       sub_id,\n\t\t\t       ISYS_CTRL_FSM_STATE_INFO_REG_ID);\n\tstate->captA_fsm_state = input_system_sub_system_reg_load(ID,\n\t\t\t\t sub_id,\n\t\t\t\t ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_ID);\n\tstate->captB_fsm_state = input_system_sub_system_reg_load(ID,\n\t\t\t\t sub_id,\n\t\t\t\t ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_ID);\n\tstate->captC_fsm_state = input_system_sub_system_reg_load(ID,\n\t\t\t\t sub_id,\n\t\t\t\t ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_ID);\n\tstate->acq_fsm_state = input_system_sub_system_reg_load(ID,\n\t\t\t       sub_id,\n\t\t\t       ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_ID);\n\tstate->capt_reserve_one_mem_region = input_system_sub_system_reg_load(ID,\n\t\t\t\t\t     sub_id,\n\t\t\t\t\t     ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_ID);\n}\n\nstatic inline void mipi_port_get_state(\n    const rx_ID_t\t\t\t\tID,\n    const enum mipi_port_id\t\t\tport_ID,\n    mipi_port_state_t\t\t\t*state)\n{\n\tint\ti;\n\n\tassert(ID < N_RX_ID);\n\tassert(port_ID < N_MIPI_PORT_ID);\n\tassert(state);\n\n\tstate->device_ready = receiver_port_reg_load(ID,\n\t\t\t      port_ID, _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);\n\tstate->irq_status = receiver_port_reg_load(ID,\n\t\t\t    port_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);\n\tstate->irq_enable = receiver_port_reg_load(ID,\n\t\t\t    port_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);\n\tstate->timeout_count = receiver_port_reg_load(ID,\n\t\t\t       port_ID, _HRT_CSS_RECEIVER_TIMEOUT_COUNT_REG_IDX);\n\tstate->init_count = (uint16_t)receiver_port_reg_load(ID,\n\t\t\t    port_ID, _HRT_CSS_RECEIVER_INIT_COUNT_REG_IDX);\n\tstate->raw16_18 = (uint16_t)receiver_port_reg_load(ID,\n\t\t\t  port_ID, _HRT_CSS_RECEIVER_RAW16_18_DATAID_REG_IDX);\n\tstate->sync_count = receiver_port_reg_load(ID,\n\t\t\t    port_ID, _HRT_CSS_RECEIVER_SYNC_COUNT_REG_IDX);\n\tstate->rx_count = receiver_port_reg_load(ID,\n\t\t\t  port_ID, _HRT_CSS_RECEIVER_RX_COUNT_REG_IDX);\n\n\tfor (i = 0; i < MIPI_4LANE_CFG ; i++) {\n\t\tstate->lane_sync_count[i] = (uint8_t)((state->sync_count) >> (i * 8));\n\t\tstate->lane_rx_count[i] = (uint8_t)((state->rx_count) >> (i * 8));\n\t}\n}\n\nstatic inline void rx_channel_get_state(\n    const rx_ID_t\t\t\t\t\tID,\n    const unsigned int\t\t\t\tch_id,\n    rx_channel_state_t\t\t\t\t*state)\n{\n\tint\ti;\n\n\tassert(ID < N_RX_ID);\n\tassert(ch_id < N_RX_CHANNEL_ID);\n\tassert(state);\n\n\tswitch (ch_id) {\n\tcase 0:\n\t\tstate->comp_scheme0 = receiver_reg_load(ID,\n\t\t\t\t\t\t\t_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX);\n\t\tstate->comp_scheme1 = receiver_reg_load(ID,\n\t\t\t\t\t\t\t_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX);\n\t\tbreak;\n\tcase 1:\n\t\tstate->comp_scheme0 = receiver_reg_load(ID,\n\t\t\t\t\t\t\t_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX);\n\t\tstate->comp_scheme1 = receiver_reg_load(ID,\n\t\t\t\t\t\t\t_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX);\n\t\tbreak;\n\tcase 2:\n\t\tstate->comp_scheme0 = receiver_reg_load(ID,\n\t\t\t\t\t\t\t_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX);\n\t\tstate->comp_scheme1 = receiver_reg_load(ID,\n\t\t\t\t\t\t\t_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX);\n\t\tbreak;\n\tcase 3:\n\t\tstate->comp_scheme0 = receiver_reg_load(ID,\n\t\t\t\t\t\t\t_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX);\n\t\tstate->comp_scheme1 = receiver_reg_load(ID,\n\t\t\t\t\t\t\t_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX);\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tu8\tval = (uint8_t)((state->comp_scheme0) >> (i * 5)) & 0x1f;\n\n\t\tstate->comp[i] = (mipi_compressor_t)(val & 0x07);\n\t\tstate->pred[i] = (mipi_predictor_t)((val & 0x18) >> 3);\n\t}\n\tfor (i = 6; i < N_MIPI_FORMAT_CUSTOM; i++) {\n\t\tu8\tval = (uint8_t)((state->comp_scheme0) >> ((i - 6) * 5)) & 0x1f;\n\n\t\tstate->comp[i] = (mipi_compressor_t)(val & 0x07);\n\t\tstate->pred[i] = (mipi_predictor_t)((val & 0x18) >> 3);\n\t}\n}\n\n\nstatic input_system_cfg2400_t config;\n\nstatic void receiver_rst(\n    const rx_ID_t\t\t\t\tID)\n{\n\tenum mipi_port_id\t\tport_id;\n\n\tassert(ID < N_RX_ID);\n\n\n\tfor (port_id = MIPI_PORT0_ID; port_id < N_MIPI_PORT_ID; port_id++) {\n\t\treceiver_port_enable(ID, port_id, false);\n\t}\n\n\t\n}\n\n\nstatic void gp_device_rst(const gp_device_ID_t\t\tID)\n{\n\tassert(ID < N_GP_DEVICE_ID);\n\n\tgp_device_reg_store(ID, _REG_GP_SYNCGEN_ENABLE_ADDR, ZERO);\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\n\n\n\n\n\tgp_device_reg_store(ID, _REG_GP_ISEL_LFSR_ENABLE_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_LFSR_ENABLE_B_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_TPG_ENABLE_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_TPG_ENABLE_B_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_HOR_CNT_MASK_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_VER_CNT_MASK_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_XY_CNT_MASK_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_HOR_CNT_DELTA_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_VER_CNT_DELTA_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_TPG_MODE_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_TPG_RED1_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_TPG_GREEN1_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_TPG_BLUE1_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_TPG_RED2_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_TPG_GREEN2_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_TPG_BLUE2_ADDR, ZERO);\n\t\n\t\n\tgp_device_reg_store(ID, _REG_GP_ISEL_DATA_SEL_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_SBAND_SEL_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_SYNC_SEL_ADDR, ZERO);\n\t\n\t\n\t\n\tgp_device_reg_store(ID, _REG_GP_SOFT_RESET_ADDR,\n\t\t\t    ZERO); \n}\n\nstatic void input_selector_cfg_for_sensor(const gp_device_ID_t ID)\n{\n\tassert(ID < N_GP_DEVICE_ID);\n\n\tgp_device_reg_store(ID, _REG_GP_ISEL_SOF_ADDR, ONE);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_EOF_ADDR, ONE);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_SOL_ADDR, ONE);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_EOL_ADDR, ONE);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_CH_ID_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_FMT_TYPE_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_DATA_SEL_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_SBAND_SEL_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_ISEL_SYNC_SEL_ADDR, ZERO);\n\tgp_device_reg_store(ID, _REG_GP_SOFT_RESET_ADDR, ZERO);\n}\n\nstatic void input_switch_rst(const gp_device_ID_t ID)\n{\n\tint addr;\n\n\tassert(ID < N_GP_DEVICE_ID);\n\n\t\n\tfor (addr = _REG_GP_IFMT_input_switch_lut_reg0;\n\t     addr <= _REG_GP_IFMT_input_switch_lut_reg7; addr += SIZEOF_HRT_REG) {\n\t\tgp_device_reg_store(ID, addr, ZERO);\n\t}\n\n\t\n\tgp_device_reg_store(ID,\n\t\t\t    _REG_GP_IFMT_input_switch_fsync_lut,\n\t\t\t    ZERO);\n}\n\nstatic void input_switch_cfg(\n    const gp_device_ID_t\t\t\tID,\n    const input_switch_cfg_t *const cfg)\n{\n\tint addr_offset;\n\n\tassert(ID < N_GP_DEVICE_ID);\n\tassert(cfg);\n\n\t\n\tfor (addr_offset = 0; addr_offset < N_RX_CHANNEL_ID * 2; addr_offset++) {\n\t\tassert(addr_offset * SIZEOF_HRT_REG + _REG_GP_IFMT_input_switch_lut_reg0 <=\n\t\t       _REG_GP_IFMT_input_switch_lut_reg7);\n\t\tgp_device_reg_store(ID,\n\t\t\t\t    _REG_GP_IFMT_input_switch_lut_reg0 + addr_offset * SIZEOF_HRT_REG,\n\t\t\t\t    cfg->hsync_data_reg[addr_offset]);\n\t}\n\n\t\n\tgp_device_reg_store(ID,\n\t\t\t    _REG_GP_IFMT_input_switch_fsync_lut,\n\t\t\t    cfg->vsync_data_reg);\n}\n\nstatic void input_system_network_rst(const input_system_ID_t ID)\n{\n\tunsigned int sub_id;\n\n\t\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  GPREGS_UNIT0_ID,\n\t\t\t\t\t  HIVE_ISYS_GPREG_MULTICAST_A_IDX,\n\t\t\t\t\t  INPUT_SYSTEM_DISCARD_ALL);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  GPREGS_UNIT0_ID,\n\t\t\t\t\t  HIVE_ISYS_GPREG_MULTICAST_B_IDX,\n\t\t\t\t\t  INPUT_SYSTEM_DISCARD_ALL);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  GPREGS_UNIT0_ID,\n\t\t\t\t\t  HIVE_ISYS_GPREG_MULTICAST_C_IDX,\n\t\t\t\t\t  INPUT_SYSTEM_DISCARD_ALL);\n\n\t\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  GPREGS_UNIT0_ID,\n\t\t\t\t\t  HIVE_ISYS_GPREG_MUX_IDX,\n\t\t\t\t\t  N_INPUT_SYSTEM_MULTIPLEX);\n\n\t\n\tfor (sub_id = CAPTURE_UNIT0_ID; sub_id < CAPTURE_UNIT0_ID + N_CAPTURE_UNIT_ID;\n\t     sub_id++) {\n\t\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t\t  sub_id,\n\t\t\t\t\t\t  CAPT_INIT_REG_ID,\n\t\t\t\t\t\t  1U << CAPT_INIT_RST_REG_BIT);\n\t}\n\n\t\n\tfor (sub_id = ACQUISITION_UNIT0_ID;\n\t     sub_id < ACQUISITION_UNIT0_ID + N_ACQUISITION_UNIT_ID; sub_id++) {\n\t\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t\t  sub_id,\n\t\t\t\t\t\t  ACQ_INIT_REG_ID,\n\t\t\t\t\t\t  1U << ACQ_INIT_RST_REG_BIT);\n\t}\n\n\t\n\n\t\n\t\n\tfor (sub_id = CTRL_UNIT0_ID; sub_id < CTRL_UNIT0_ID + N_CTRL_UNIT_ID;\n\t     sub_id++) {\n\t\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t\t  sub_id,\n\t\t\t\t\t\t  ISYS_CTRL_INIT_REG_ID,\n\t\t\t\t\t\t  1U); \n\t}\n}\n\n\ninput_system_err_t input_system_configuration_reset(void)\n{\n\tunsigned int i;\n\n\treceiver_rst(RX0_ID);\n\n\tinput_system_network_rst(INPUT_SYSTEM0_ID);\n\n\tgp_device_rst(GP_DEVICE0_ID);\n\n\tinput_switch_rst(GP_DEVICE0_ID);\n\n\t\n\n\t\n\n\t\n\tfor (i = 0; i < N_CHANNELS; i++) {\n\t\tconfig.ch_flags[i] = INPUT_SYSTEM_CFG_FLAG_RESET;\n\t\tconfig.target_isp_flags[i] = INPUT_SYSTEM_CFG_FLAG_RESET;\n\t\tconfig.target_sp_flags[i] = INPUT_SYSTEM_CFG_FLAG_RESET;\n\t\tconfig.target_strm2mem_flags[i] = INPUT_SYSTEM_CFG_FLAG_RESET;\n\t}\n\n\tfor (i = 0; i < N_CSI_PORTS; i++) {\n\t\tconfig.csi_buffer_flags[i]\t = INPUT_SYSTEM_CFG_FLAG_RESET;\n\t\tconfig.multicast[i]\t\t = INPUT_SYSTEM_DISCARD_ALL;\n\t}\n\n\tconfig.source_type_flags\t\t\t\t = INPUT_SYSTEM_CFG_FLAG_RESET;\n\tconfig.acquisition_buffer_unique_flags\t = INPUT_SYSTEM_CFG_FLAG_RESET;\n\tconfig.unallocated_ib_mem_words\t\t\t = IB_CAPACITY_IN_WORDS;\n\t\n\n\t\n\tconfig.session_flags = INPUT_SYSTEM_CFG_FLAG_REQUIRED;\n\n\treturn INPUT_SYSTEM_ERR_NO_ERROR;\n}\n\n\n\nstatic input_system_err_t input_system_configure_channel(\n    const channel_cfg_t\t\tchannel)\n{\n\tinput_system_err_t error = INPUT_SYSTEM_ERR_NO_ERROR;\n\t\n\tif (config.ch_flags[channel.ch_id] & INPUT_SYSTEM_CFG_FLAG_SET) {\n\t\treturn INPUT_SYSTEM_ERR_CHANNEL_ALREADY_SET;\n\t} else {\n\t\tswitch (channel.source_type) {\n\t\tcase INPUT_SYSTEM_SOURCE_SENSOR:\n\t\t\terror = input_system_configure_channel_sensor(channel);\n\t\t\tbreak;\n\t\tcase INPUT_SYSTEM_SOURCE_TPG:\n\t\tcase INPUT_SYSTEM_SOURCE_PRBS:\n\t\tcase INPUT_SYSTEM_SOURCE_FIFO:\n\t\tdefault:\n\t\t\treturn INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;\n\t\t}\n\n\t\tif (error != INPUT_SYSTEM_ERR_NO_ERROR) return error;\n\t\t\n\t\tconfig.input_switch_cfg.hsync_data_reg[channel.source_cfg.csi_cfg.csi_port * 2]\n\t\t    =\n\t\t\tchannel.target_cfg.input_switch_channel_cfg.hsync_data_reg[0];\n\t\tconfig.input_switch_cfg.hsync_data_reg[channel.source_cfg.csi_cfg.csi_port * 2 +\n\t\t\t\t\t\t\t\t\t\t\t   1] =\n\t\t\t\t\t\t\t       channel.target_cfg.input_switch_channel_cfg.hsync_data_reg[1];\n\t\tconfig.input_switch_cfg.vsync_data_reg |=\n\t\t    (channel.target_cfg.input_switch_channel_cfg.vsync_data_reg & 0x7) <<\n\t\t    (channel.source_cfg.csi_cfg.csi_port * 3);\n\n\t\t\n\t\tconfig.target_isp[channel.source_cfg.csi_cfg.csi_port] =\n\t\t    channel.target_cfg.target_isp_cfg;\n\t\tconfig.target_sp[channel.source_cfg.csi_cfg.csi_port] =\n\t\t    channel.target_cfg.target_sp_cfg;\n\t\tconfig.target_strm2mem[channel.source_cfg.csi_cfg.csi_port] =\n\t\t    channel.target_cfg.target_strm2mem_cfg;\n\t\tconfig.target_isp_flags[channel.source_cfg.csi_cfg.csi_port] |=\n\t\t    INPUT_SYSTEM_CFG_FLAG_SET;\n\t\tconfig.target_sp_flags[channel.source_cfg.csi_cfg.csi_port] |=\n\t\t    INPUT_SYSTEM_CFG_FLAG_SET;\n\t\tconfig.target_strm2mem_flags[channel.source_cfg.csi_cfg.csi_port] |=\n\t\t    INPUT_SYSTEM_CFG_FLAG_SET;\n\n\t\tconfig.ch_flags[channel.ch_id] = INPUT_SYSTEM_CFG_FLAG_SET;\n\t}\n\treturn INPUT_SYSTEM_ERR_NO_ERROR;\n}\n\n\nstatic input_system_err_t input_buffer_configuration(void)\n{\n\tu32 current_address    = 0;\n\tu32 unallocated_memory = IB_CAPACITY_IN_WORDS;\n\n\tisp2400_ib_buffer_t\tcandidate_buffer_acq  = IB_BUFFER_NULL;\n\tu32 size_requested;\n\tinput_system_config_flags_t\tacq_already_specified = INPUT_SYSTEM_CFG_FLAG_RESET;\n\tinput_system_csi_port_t port;\n\n\tfor (port = INPUT_SYSTEM_PORT_A; port < N_INPUT_SYSTEM_PORTS; port++) {\n\t\tcsi_cfg_t source = config.csi_value[port];\n\n\t\tif (config.csi_flags[port] & INPUT_SYSTEM_CFG_FLAG_SET) {\n\t\t\t\n\t\t\tswitch (source.buffering_mode) {\n\t\t\tcase INPUT_SYSTEM_FIFO_CAPTURE:\n\t\t\tcase INPUT_SYSTEM_XMEM_ACQUIRE:\n\t\t\t\tconfig.csi_buffer_flags[port] =\n\t\t\t\t    INPUT_SYSTEM_CFG_FLAG_BLOCKED; \n\t\t\t\tbreak;\n\n\t\t\tcase INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING:\n\t\t\tcase INPUT_SYSTEM_SRAM_BUFFERING:\n\t\t\tcase INPUT_SYSTEM_XMEM_BUFFERING:\n\t\t\tcase INPUT_SYSTEM_XMEM_CAPTURE:\n\t\t\t\tsize_requested = source.csi_buffer.mem_reg_size *\n\t\t\t\t\t\t source.csi_buffer.nof_mem_regs;\n\t\t\t\tif (source.csi_buffer.mem_reg_size > 0\n\t\t\t\t    && source.csi_buffer.nof_mem_regs > 0\n\t\t\t\t    && size_requested <= unallocated_memory\n\t\t\t\t   ) {\n\t\t\t\t\tconfig.csi_buffer[port].mem_reg_addr = current_address;\n\t\t\t\t\tconfig.csi_buffer[port].mem_reg_size = source.csi_buffer.mem_reg_size;\n\t\t\t\t\tconfig.csi_buffer[port].nof_mem_regs = source.csi_buffer.nof_mem_regs;\n\t\t\t\t\tcurrent_address\t\t+= size_requested;\n\t\t\t\t\tunallocated_memory\t-= size_requested;\n\t\t\t\t\tconfig.csi_buffer_flags[port] = INPUT_SYSTEM_CFG_FLAG_SET;\n\t\t\t\t} else {\n\t\t\t\t\tconfig.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;\n\t\t\t\t\treturn INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconfig.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;\n\t\t\t\treturn INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;\n\t\t\t}\n\n\t\t\t\n\t\t\tswitch (source.buffering_mode) {\n\t\t\tcase INPUT_SYSTEM_FIFO_CAPTURE:\n\t\t\tcase INPUT_SYSTEM_SRAM_BUFFERING:\n\t\t\tcase INPUT_SYSTEM_XMEM_CAPTURE:\n\t\t\t\t\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING:\n\t\t\tcase INPUT_SYSTEM_XMEM_BUFFERING:\n\t\t\tcase INPUT_SYSTEM_XMEM_ACQUIRE:\n\t\t\t\tif (acq_already_specified == INPUT_SYSTEM_CFG_FLAG_RESET) {\n\t\t\t\t\tsize_requested = source.acquisition_buffer.mem_reg_size\n\t\t\t\t\t\t\t * source.acquisition_buffer.nof_mem_regs;\n\t\t\t\t\tif (source.acquisition_buffer.mem_reg_size > 0\n\t\t\t\t\t    && source.acquisition_buffer.nof_mem_regs > 0\n\t\t\t\t\t    && size_requested <= unallocated_memory\n\t\t\t\t\t   ) {\n\t\t\t\t\t\tcandidate_buffer_acq = source.acquisition_buffer;\n\t\t\t\t\t\tacq_already_specified = INPUT_SYSTEM_CFG_FLAG_SET;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tif (source.acquisition_buffer.mem_reg_size != candidate_buffer_acq.mem_reg_size\n\t\t\t\t\t    || source.acquisition_buffer.nof_mem_regs !=  candidate_buffer_acq.nof_mem_regs\n\t\t\t\t\t   ) {\n\t\t\t\t\t\tconfig.acquisition_buffer_unique_flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;\n\t\t\t\t\t\treturn INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;\n\t\t\t}\n\t\t} else {\n\t\t\tconfig.csi_buffer_flags[port] = INPUT_SYSTEM_CFG_FLAG_BLOCKED;\n\t\t}\n\t} \n\n\t\n\tsize_requested = candidate_buffer_acq.mem_reg_size *\n\t\t\t candidate_buffer_acq.nof_mem_regs;\n\tif (acq_already_specified == INPUT_SYSTEM_CFG_FLAG_SET\n\t    && size_requested <= unallocated_memory) {\n\t\tconfig.acquisition_buffer_unique.mem_reg_addr = current_address;\n\t\tconfig.acquisition_buffer_unique.mem_reg_size =\n\t\t    candidate_buffer_acq.mem_reg_size;\n\t\tconfig.acquisition_buffer_unique.nof_mem_regs =\n\t\t    candidate_buffer_acq.nof_mem_regs;\n\t\tcurrent_address\t\t+= size_requested;\n\t\tunallocated_memory\t-= size_requested;\n\t\tconfig.acquisition_buffer_unique_flags = INPUT_SYSTEM_CFG_FLAG_SET;\n\n\t\tassert(current_address <= IB_CAPACITY_IN_WORDS);\n\t}\n\n\treturn INPUT_SYSTEM_ERR_NO_ERROR;\n}\n\nstatic void capture_unit_configure(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_id,\n    const isp2400_ib_buffer_t *const cfg)\n{\n\tassert(ID < N_INPUT_SYSTEM_ID);\n\tassert(  (sub_id <=\n\t\tCAPTURE_UNIT2_ID)); \n\tassert(cfg);\n\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  CAPT_START_ADDR_REG_ID,\n\t\t\t\t\t  cfg->mem_reg_addr);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  CAPT_MEM_REGION_SIZE_REG_ID,\n\t\t\t\t\t  cfg->mem_reg_size);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  CAPT_NUM_MEM_REGIONS_REG_ID,\n\t\t\t\t\t  cfg->nof_mem_regs);\n}\n\nstatic void acquisition_unit_configure(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_id,\n    const isp2400_ib_buffer_t *const cfg)\n{\n\tassert(ID < N_INPUT_SYSTEM_ID);\n\tassert(sub_id == ACQUISITION_UNIT0_ID);\n\tassert(cfg);\n\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ACQ_START_ADDR_REG_ID,\n\t\t\t\t\t  cfg->mem_reg_addr);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ACQ_NUM_MEM_REGIONS_REG_ID,\n\t\t\t\t\t  cfg->nof_mem_regs);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ACQ_MEM_REGION_SIZE_REG_ID,\n\t\t\t\t\t  cfg->mem_reg_size);\n}\n\nstatic void ctrl_unit_configure(\n    const input_system_ID_t\t\t\tID,\n    const sub_system_ID_t\t\t\tsub_id,\n    const ctrl_unit_cfg_t *const cfg)\n{\n\tassert(ID < N_INPUT_SYSTEM_ID);\n\tassert(sub_id == CTRL_UNIT0_ID);\n\tassert(cfg);\n\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ISYS_CTRL_CAPT_START_ADDR_A_REG_ID,\n\t\t\t\t\t  cfg->buffer_mipi[CAPTURE_UNIT0_ID].mem_reg_addr);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_ID,\n\t\t\t\t\t  cfg->buffer_mipi[CAPTURE_UNIT0_ID].mem_reg_size);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_ID,\n\t\t\t\t\t  cfg->buffer_mipi[CAPTURE_UNIT0_ID].nof_mem_regs);\n\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ISYS_CTRL_CAPT_START_ADDR_B_REG_ID,\n\t\t\t\t\t  cfg->buffer_mipi[CAPTURE_UNIT1_ID].mem_reg_addr);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_ID,\n\t\t\t\t\t  cfg->buffer_mipi[CAPTURE_UNIT1_ID].mem_reg_size);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_ID,\n\t\t\t\t\t  cfg->buffer_mipi[CAPTURE_UNIT1_ID].nof_mem_regs);\n\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ISYS_CTRL_CAPT_START_ADDR_C_REG_ID,\n\t\t\t\t\t  cfg->buffer_mipi[CAPTURE_UNIT2_ID].mem_reg_addr);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_ID,\n\t\t\t\t\t  cfg->buffer_mipi[CAPTURE_UNIT2_ID].mem_reg_size);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_ID,\n\t\t\t\t\t  cfg->buffer_mipi[CAPTURE_UNIT2_ID].nof_mem_regs);\n\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ISYS_CTRL_ACQ_START_ADDR_REG_ID,\n\t\t\t\t\t  cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID].mem_reg_addr);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_ID,\n\t\t\t\t\t  cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID].mem_reg_size);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_ID,\n\t\t\t\t\t  cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID].nof_mem_regs);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  sub_id,\n\t\t\t\t\t  ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_ID,\n\t\t\t\t\t  0);\n}\n\nstatic void input_system_network_configure(\n    const input_system_ID_t\t\t\t\tID,\n    const input_system_network_cfg_t *const cfg)\n{\n\tu32 sub_id;\n\n\tassert(ID < N_INPUT_SYSTEM_ID);\n\tassert(cfg);\n\n\t\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  GPREGS_UNIT0_ID,\n\t\t\t\t\t  HIVE_ISYS_GPREG_MULTICAST_A_IDX,\n\t\t\t\t\t  cfg->multicast_cfg[CAPTURE_UNIT0_ID]);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  GPREGS_UNIT0_ID,\n\t\t\t\t\t  HIVE_ISYS_GPREG_MULTICAST_B_IDX,\n\t\t\t\t\t  cfg->multicast_cfg[CAPTURE_UNIT1_ID]);\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  GPREGS_UNIT0_ID,\n\t\t\t\t\t  HIVE_ISYS_GPREG_MULTICAST_C_IDX,\n\t\t\t\t\t  cfg->multicast_cfg[CAPTURE_UNIT2_ID]);\n\n\t\n\tinput_system_sub_system_reg_store(ID,\n\t\t\t\t\t  GPREGS_UNIT0_ID,\n\t\t\t\t\t  HIVE_ISYS_GPREG_MUX_IDX,\n\t\t\t\t\t  cfg->mux_cfg);\n\n\t\n\tfor (sub_id = CAPTURE_UNIT0_ID; sub_id < CAPTURE_UNIT0_ID + N_CAPTURE_UNIT_ID;\n\t     sub_id++) {\n\t\tcapture_unit_configure(ID,\n\t\t\t\t       sub_id,\n\t\t\t\t       &cfg->ctrl_unit_cfg[ID].buffer_mipi[sub_id - CAPTURE_UNIT0_ID]);\n\t}\n\n\t\n\tfor (sub_id = ACQUISITION_UNIT0_ID;\n\t     sub_id < ACQUISITION_UNIT0_ID + N_ACQUISITION_UNIT_ID; sub_id++) {\n\t\tacquisition_unit_configure(ID,\n\t\t\t\t\t   sub_id,\n\t\t\t\t\t   &cfg->ctrl_unit_cfg[sub_id - ACQUISITION_UNIT0_ID].buffer_acquire[sub_id -\n\t\t\t\t\t\t   ACQUISITION_UNIT0_ID]);\n\t}\n\n\t\n\n\t\n\tfor (sub_id = CTRL_UNIT0_ID; sub_id < CTRL_UNIT0_ID + N_CTRL_UNIT_ID;\n\t     sub_id++) {\n\t\tctrl_unit_configure(ID,\n\t\t\t\t    sub_id,\n\t\t\t\t    &cfg->ctrl_unit_cfg[sub_id - CTRL_UNIT0_ID]);\n\t}\n}\n\nstatic input_system_err_t configuration_to_registers(void)\n{\n\tinput_system_network_cfg_t input_system_network_cfg;\n\tint i;\n\n\tassert(config.source_type_flags & INPUT_SYSTEM_CFG_FLAG_SET);\n\n\tswitch (config.source_type) {\n\tcase INPUT_SYSTEM_SOURCE_SENSOR:\n\n\t\t\n\t\t\n\t\t\n\t\tfor (i = MIPI_PORT0_ID; i < N_MIPI_PORT_ID; i++) {\n\t\t\tif (config.csi_flags[i] & INPUT_SYSTEM_CFG_FLAG_SET) {\n\t\t\t\tswitch (config.csi_value[i].buffering_mode) {\n\t\t\t\tcase INPUT_SYSTEM_FIFO_CAPTURE:\n\t\t\t\t\tconfig.multicast[i] = INPUT_SYSTEM_CSI_BACKEND;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT_SYSTEM_XMEM_CAPTURE:\n\t\t\t\tcase INPUT_SYSTEM_SRAM_BUFFERING:\n\t\t\t\tcase INPUT_SYSTEM_XMEM_BUFFERING:\n\t\t\t\t\tconfig.multicast[i] = INPUT_SYSTEM_INPUT_BUFFER;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING:\n\t\t\t\t\tconfig.multicast[i] = INPUT_SYSTEM_MULTICAST;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT_SYSTEM_XMEM_ACQUIRE:\n\t\t\t\t\tconfig.multicast[i] = INPUT_SYSTEM_DISCARD_ALL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconfig.multicast[i] = INPUT_SYSTEM_DISCARD_ALL;\n\t\t\t\t\treturn INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconfig.multicast[i] = INPUT_SYSTEM_DISCARD_ALL;\n\t\t\t}\n\n\t\t\tinput_system_network_cfg.multicast_cfg[i] = config.multicast[i];\n\n\t\t} \n\n\t\tinput_system_network_cfg.mux_cfg = config.multiplexer;\n\n\t\tinput_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID -\n\t\t\t\t\t\t       CTRL_UNIT0_ID].buffer_mipi[CAPTURE_UNIT0_ID] =\n\t\t\t\t\t\t\t       config.csi_buffer[MIPI_PORT0_ID];\n\t\tinput_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID -\n\t\t\t\t\t\t       CTRL_UNIT0_ID].buffer_mipi[CAPTURE_UNIT1_ID] =\n\t\t\t\t\t\t\t       config.csi_buffer[MIPI_PORT1_ID];\n\t\tinput_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID -\n\t\t\t\t\t\t       CTRL_UNIT0_ID].buffer_mipi[CAPTURE_UNIT2_ID] =\n\t\t\t\t\t\t\t       config.csi_buffer[MIPI_PORT2_ID];\n\t\tinput_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID -\n\t\t\t\t\t\t       CTRL_UNIT0_ID].buffer_acquire[ACQUISITION_UNIT0_ID -\n\t\t\t\t\t\t\t       ACQUISITION_UNIT0_ID] =\n\t\t\t\t\t\t\t\t       config.acquisition_buffer_unique;\n\n\t\t\n\t\tinput_system_network_configure(INPUT_SYSTEM0_ID, &input_system_network_cfg);\n\n\t\t\n\t\t\n\t\tbreak;\n\n\tcase INPUT_SYSTEM_SOURCE_TPG:\n\tcase INPUT_SYSTEM_SOURCE_PRBS:\n\tcase INPUT_SYSTEM_SOURCE_FIFO:\n\t\tbreak;\n\n\tdefault:\n\t\treturn INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;\n\n\t} \n\n\t\n\tinput_selector_cfg_for_sensor(GP_DEVICE0_ID);\n\n\t\n\tinput_switch_cfg(GP_DEVICE0_ID, &config.input_switch_cfg);\n\n\t\n\t\n\treturn INPUT_SYSTEM_ERR_NO_ERROR;\n}\n\n\ninput_system_err_t input_system_configuration_commit(void)\n{\n\t\n\tinput_system_err_t error = input_buffer_configuration();\n\n\tif (error != INPUT_SYSTEM_ERR_NO_ERROR) {\n\t\treturn error;\n\t}\n\n\t\n\terror = configuration_to_registers();\n\tif (error != INPUT_SYSTEM_ERR_NO_ERROR) {\n\t\treturn error;\n\t}\n\n\t\n\n\treturn INPUT_SYSTEM_ERR_NO_ERROR;\n}\n\n\n\ninput_system_err_t\tinput_system_csi_fifo_channel_cfg(\n    u32\t\tch_id,\n    input_system_csi_port_t\tport,\n    backend_channel_cfg_t\tbackend_ch,\n    target_cfg2400_t\ttarget\n)\n{\n\tchannel_cfg_t channel;\n\n\tchannel.ch_id\t= ch_id;\n\tchannel.backend_ch\t= backend_ch;\n\tchannel.source_type = INPUT_SYSTEM_SOURCE_SENSOR;\n\t\n\tchannel.source_cfg.csi_cfg.csi_port\t\t\t= port;\n\tchannel.source_cfg.csi_cfg.buffering_mode\t= INPUT_SYSTEM_FIFO_CAPTURE;\n\tchannel.source_cfg.csi_cfg.csi_buffer\t\t\t= IB_BUFFER_NULL;\n\tchannel.source_cfg.csi_cfg.acquisition_buffer\t= IB_BUFFER_NULL;\n\tchannel.source_cfg.csi_cfg.nof_xmem_buffers\t= 0;\n\n\tchannel.target_cfg\t= target;\n\treturn input_system_configure_channel(channel);\n}\n\ninput_system_err_t\tinput_system_csi_fifo_channel_with_counting_cfg(\n    u32\t\t\t\tch_id,\n    u32\t\t\t\tnof_frames,\n    input_system_csi_port_t\t\t\tport,\n    backend_channel_cfg_t\t\t\tbackend_ch,\n    u32\t\t\t\tcsi_mem_reg_size,\n    u32\t\t\t\tcsi_nof_mem_regs,\n    target_cfg2400_t\t\t\ttarget\n)\n{\n\tchannel_cfg_t channel;\n\n\tchannel.ch_id\t= ch_id;\n\tchannel.backend_ch\t= backend_ch;\n\tchannel.source_type\t\t= INPUT_SYSTEM_SOURCE_SENSOR;\n\t\n\tchannel.source_cfg.csi_cfg.csi_port\t\t\t= port;\n\tchannel.source_cfg.csi_cfg.buffering_mode\t=\n\t    INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING;\n\tchannel.source_cfg.csi_cfg.csi_buffer.mem_reg_size\t\t= csi_mem_reg_size;\n\tchannel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs\t\t= csi_nof_mem_regs;\n\tchannel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr\t\t= 0;\n\tchannel.source_cfg.csi_cfg.acquisition_buffer\t\t\t= IB_BUFFER_NULL;\n\tchannel.source_cfg.csi_cfg.nof_xmem_buffers\t= nof_frames;\n\n\tchannel.target_cfg\t= target;\n\treturn input_system_configure_channel(channel);\n}\n\n\n\ninput_system_err_t\tinput_system_csi_sram_channel_cfg(\n    u32\t\t\t\tch_id,\n    input_system_csi_port_t\t\t\tport,\n    backend_channel_cfg_t\t\t\tbackend_ch,\n    u32\t\t\t\tcsi_mem_reg_size,\n    u32\t\t\t\tcsi_nof_mem_regs,\n    \n    \n    target_cfg2400_t\t\t\ttarget\n)\n{\n\tchannel_cfg_t channel;\n\n\tchannel.ch_id\t= ch_id;\n\tchannel.backend_ch\t= backend_ch;\n\tchannel.source_type\t\t= INPUT_SYSTEM_SOURCE_SENSOR;\n\t\n\tchannel.source_cfg.csi_cfg.csi_port\t\t\t= port;\n\tchannel.source_cfg.csi_cfg.buffering_mode\t= INPUT_SYSTEM_SRAM_BUFFERING;\n\tchannel.source_cfg.csi_cfg.csi_buffer.mem_reg_size\t\t= csi_mem_reg_size;\n\tchannel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs\t\t= csi_nof_mem_regs;\n\tchannel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr\t\t= 0;\n\tchannel.source_cfg.csi_cfg.acquisition_buffer\t\t\t= IB_BUFFER_NULL;\n\tchannel.source_cfg.csi_cfg.nof_xmem_buffers\t= 0;\n\n\tchannel.target_cfg\t= target;\n\treturn input_system_configure_channel(channel);\n}\n\n\n\n\ninput_system_err_t\tinput_system_csi_xmem_channel_cfg(\n    u32\t\t\t\tch_id,\n    input_system_csi_port_t\t\t\tport,\n    backend_channel_cfg_t\t\t\tbackend_ch,\n    u32\t\t\t\tcsi_mem_reg_size,\n    u32\t\t\t\tcsi_nof_mem_regs,\n    u32\t\t\t\tacq_mem_reg_size,\n    u32\t\t\t\tacq_nof_mem_regs,\n    target_cfg2400_t\t\t\ttarget,\n    uint32_t\t\t\t\tnof_xmem_buffers\n)\n{\n\tchannel_cfg_t channel;\n\n\tchannel.ch_id\t= ch_id;\n\tchannel.backend_ch\t= backend_ch;\n\tchannel.source_type\t\t= INPUT_SYSTEM_SOURCE_SENSOR;\n\t\n\tchannel.source_cfg.csi_cfg.csi_port\t\t\t= port;\n\tchannel.source_cfg.csi_cfg.buffering_mode\t= INPUT_SYSTEM_XMEM_BUFFERING;\n\tchannel.source_cfg.csi_cfg.csi_buffer.mem_reg_size\t\t= csi_mem_reg_size;\n\tchannel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs\t\t= csi_nof_mem_regs;\n\tchannel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr\t\t= 0;\n\tchannel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size\t= acq_mem_reg_size;\n\tchannel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs\t= acq_nof_mem_regs;\n\tchannel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr\t= 0;\n\tchannel.source_cfg.csi_cfg.nof_xmem_buffers\t= nof_xmem_buffers;\n\n\tchannel.target_cfg\t= target;\n\treturn input_system_configure_channel(channel);\n}\n\ninput_system_err_t\tinput_system_csi_xmem_acquire_only_channel_cfg(\n    u32\t\t\t\tch_id,\n    u32\t\t\t\tnof_frames,\n    input_system_csi_port_t\t\t\tport,\n    backend_channel_cfg_t\t\t\tbackend_ch,\n    u32\t\t\t\tacq_mem_reg_size,\n    u32\t\t\t\tacq_nof_mem_regs,\n    target_cfg2400_t\t\t\ttarget)\n{\n\tchannel_cfg_t channel;\n\n\tchannel.ch_id\t= ch_id;\n\tchannel.backend_ch\t= backend_ch;\n\tchannel.source_type\t\t= INPUT_SYSTEM_SOURCE_SENSOR;\n\t\n\tchannel.source_cfg.csi_cfg.csi_port\t\t\t= port;\n\tchannel.source_cfg.csi_cfg.buffering_mode\t= INPUT_SYSTEM_XMEM_ACQUIRE;\n\tchannel.source_cfg.csi_cfg.csi_buffer\t\t= IB_BUFFER_NULL;\n\tchannel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size\t= acq_mem_reg_size;\n\tchannel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs\t= acq_nof_mem_regs;\n\tchannel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr\t= 0;\n\tchannel.source_cfg.csi_cfg.nof_xmem_buffers\t= nof_frames;\n\n\tchannel.target_cfg\t= target;\n\treturn input_system_configure_channel(channel);\n}\n\ninput_system_err_t\tinput_system_csi_xmem_capture_only_channel_cfg(\n    u32\t\t\t\tch_id,\n    u32\t\t\t\tnof_frames,\n    input_system_csi_port_t\t\t\tport,\n    u32\t\t\t\tcsi_mem_reg_size,\n    u32\t\t\t\tcsi_nof_mem_regs,\n    u32\t\t\t\tacq_mem_reg_size,\n    u32\t\t\t\tacq_nof_mem_regs,\n    target_cfg2400_t\t\t\ttarget)\n{\n\tchannel_cfg_t channel;\n\n\tchannel.ch_id\t= ch_id;\n\t\n\tchannel.source_type\t\t= INPUT_SYSTEM_SOURCE_SENSOR;\n\t\n\tchannel.source_cfg.csi_cfg.csi_port\t\t\t= port;\n\t\n\tchannel.source_cfg.csi_cfg.buffering_mode\t= INPUT_SYSTEM_XMEM_CAPTURE;\n\tchannel.source_cfg.csi_cfg.csi_buffer.mem_reg_size\t\t= csi_mem_reg_size;\n\tchannel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs\t\t= csi_nof_mem_regs;\n\tchannel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr\t\t= 0;\n\tchannel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size\t= acq_mem_reg_size;\n\tchannel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs\t= acq_nof_mem_regs;\n\tchannel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr\t= 0;\n\tchannel.source_cfg.csi_cfg.nof_xmem_buffers\t= nof_frames;\n\n\tchannel.target_cfg\t= target;\n\treturn input_system_configure_channel(channel);\n}\n\n\n\ninput_system_err_t\tinput_system_prbs_channel_cfg(\n    u32\t\tch_id,\n    u32\t\tnof_frames,\n    u32\t\tseed,\n    u32\t\tsync_gen_width,\n    u32\t\tsync_gen_height,\n    u32\t\tsync_gen_hblank_cycles,\n    u32\t\tsync_gen_vblank_cycles,\n    target_cfg2400_t\ttarget\n)\n{\n\tchannel_cfg_t channel;\n\n\t(void)nof_frames;\n\n\tchannel.ch_id\t= ch_id;\n\tchannel.source_type = INPUT_SYSTEM_SOURCE_PRBS;\n\n\tchannel.source_cfg.prbs_cfg.seed = seed;\n\tchannel.source_cfg.prbs_cfg.sync_gen_cfg.width\t\t= sync_gen_width;\n\tchannel.source_cfg.prbs_cfg.sync_gen_cfg.height\t\t= sync_gen_height;\n\tchannel.source_cfg.prbs_cfg.sync_gen_cfg.hblank_cycles\t= sync_gen_hblank_cycles;\n\tchannel.source_cfg.prbs_cfg.sync_gen_cfg.vblank_cycles\t= sync_gen_vblank_cycles;\n\n\tchannel.target_cfg\t= target;\n\n\treturn input_system_configure_channel(channel);\n}\n\ninput_system_err_t\tinput_system_tpg_channel_cfg(\n    u32\t\tch_id,\n    u32\t\tnof_frames,\n    u32\t\tx_mask,\n    u32\t\ty_mask,\n    u32\t\tx_delta,\n    u32\t\ty_delta,\n    u32\t\txy_mask,\n    u32\t\tsync_gen_width,\n    u32\t\tsync_gen_height,\n    u32\t\tsync_gen_hblank_cycles,\n    u32\t\tsync_gen_vblank_cycles,\n    target_cfg2400_t\ttarget\n)\n{\n\tchannel_cfg_t channel;\n\n\t(void)nof_frames;\n\n\tchannel.ch_id\t= ch_id;\n\tchannel.source_type\t\t= INPUT_SYSTEM_SOURCE_TPG;\n\n\tchannel.source_cfg.tpg_cfg.x_mask\t= x_mask;\n\tchannel.source_cfg.tpg_cfg.y_mask\t= y_mask;\n\tchannel.source_cfg.tpg_cfg.x_delta\t= x_delta;\n\tchannel.source_cfg.tpg_cfg.y_delta\t= y_delta;\n\tchannel.source_cfg.tpg_cfg.xy_mask\t= xy_mask;\n\tchannel.source_cfg.tpg_cfg.sync_gen_cfg.width\t\t= sync_gen_width;\n\tchannel.source_cfg.tpg_cfg.sync_gen_cfg.height\t\t= sync_gen_height;\n\tchannel.source_cfg.tpg_cfg.sync_gen_cfg.hblank_cycles\t= sync_gen_hblank_cycles;\n\tchannel.source_cfg.tpg_cfg.sync_gen_cfg.vblank_cycles\t= sync_gen_vblank_cycles;\n\n\tchannel.target_cfg\t= target;\n\treturn input_system_configure_channel(channel);\n}\n\n\ninput_system_err_t\tinput_system_gpfifo_channel_cfg(\n    u32\t\tch_id,\n    u32\t\tnof_frames, \n\n    target_cfg2400_t\ttarget)\n{\n\tchannel_cfg_t channel;\n\n\t(void)nof_frames;\n\n\tchannel.ch_id\t= ch_id;\n\tchannel.source_type\t= INPUT_SYSTEM_SOURCE_FIFO;\n\n\tchannel.target_cfg\t= target;\n\treturn input_system_configure_channel(channel);\n}\n\n\n\n\n\n\n\n\nstatic input_system_err_t input_system_configure_channel_sensor(\n    const channel_cfg_t channel)\n{\n\tconst u32 port = channel.source_cfg.csi_cfg.csi_port;\n\tinput_system_err_t status = INPUT_SYSTEM_ERR_NO_ERROR;\n\n\tinput_system_multiplex_t mux;\n\n\tif (port >= N_INPUT_SYSTEM_PORTS)\n\t\treturn INPUT_SYSTEM_ERR_GENERIC;\n\n\t\n\n\tstatus = set_source_type(&config.source_type, channel.source_type,\n\t\t\t\t &config.source_type_flags);\n\tif (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;\n\n\t\n\n\tstatus = set_csi_cfg(&config.csi_value[port], &channel.source_cfg.csi_cfg,\n\t\t\t     &config.csi_flags[port]);\n\tif (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;\n\n\tswitch (channel.source_cfg.csi_cfg.buffering_mode) {\n\tcase INPUT_SYSTEM_FIFO_CAPTURE:\n\n\t\t\n\t\tmux = INPUT_SYSTEM_MIPI_PORT0 + port;\n\t\tstatus = input_system_multiplexer_cfg(&config.multiplexer, mux,\n\t\t\t\t\t\t      &config.multiplexer_flags);\n\t\tif (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;\n\t\tconfig.multicast[port] = INPUT_SYSTEM_CSI_BACKEND;\n\n\t\t\n\t\t\n\t\t\n\t\t\n\n\t\tbreak;\n\tcase INPUT_SYSTEM_SRAM_BUFFERING:\n\n\t\t\n\t\tmux = INPUT_SYSTEM_ACQUISITION_UNIT;\n\t\tstatus = input_system_multiplexer_cfg(&config.multiplexer, mux,\n\t\t\t\t\t\t      &config.multiplexer_flags);\n\t\tif (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;\n\t\tconfig.multicast[port] = INPUT_SYSTEM_INPUT_BUFFER;\n\n\t\t\n\t\t\n\t\t\n\t\t\n\n\t\tbreak;\n\tcase INPUT_SYSTEM_XMEM_BUFFERING:\n\n\t\t\n\t\tmux = INPUT_SYSTEM_ACQUISITION_UNIT;\n\t\tstatus = input_system_multiplexer_cfg(&config.multiplexer, mux,\n\t\t\t\t\t\t      &config.multiplexer_flags);\n\t\tif (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;\n\t\tconfig.multicast[port] = INPUT_SYSTEM_INPUT_BUFFER;\n\n\t\t\n\t\t\n\t\t\n\t\t\n\n\t\tbreak;\n\tcase INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING:\n\tcase INPUT_SYSTEM_XMEM_CAPTURE:\n\tcase INPUT_SYSTEM_XMEM_ACQUIRE:\n\tdefault:\n\t\treturn INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;\n\t}\n\n\treturn INPUT_SYSTEM_ERR_NO_ERROR;\n}\n\n\nstatic input_system_err_t set_source_type(\n    input_system_source_t *const lhs,\n    const input_system_source_t\t\t\trhs,\n    input_system_config_flags_t *const flags)\n{\n\t\n\tassert(lhs);\n\tassert(flags);\n\n\tif ((*flags) & INPUT_SYSTEM_CFG_FLAG_BLOCKED) {\n\t\t*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;\n\t\treturn INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;\n\t}\n\n\tif ((*flags) & INPUT_SYSTEM_CFG_FLAG_SET) {\n\t\t\n\t\tif ((*lhs) == (rhs)) {\n\t\t\treturn INPUT_SYSTEM_ERR_NO_ERROR;\n\t\t} else {\n\t\t\t*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;\n\t\t\treturn INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;\n\t\t}\n\t}\n\t\n\tif (rhs >= N_INPUT_SYSTEM_SOURCE) {\n\t\t*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;\n\t\treturn INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;\n\t}\n\t\n\t*lhs = rhs;\n\n\t*flags |= INPUT_SYSTEM_CFG_FLAG_SET;\n\treturn INPUT_SYSTEM_ERR_NO_ERROR;\n}\n\n\nstatic input_system_err_t set_csi_cfg(\n    csi_cfg_t *const lhs,\n    const csi_cfg_t *const rhs,\n    input_system_config_flags_t *const flags)\n{\n\tu32 memory_required;\n\tu32 acq_memory_required;\n\n\tassert(lhs);\n\tassert(flags);\n\n\tif ((*flags) & INPUT_SYSTEM_CFG_FLAG_BLOCKED) {\n\t\t*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;\n\t\treturn INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;\n\t}\n\n\tif (*flags & INPUT_SYSTEM_CFG_FLAG_SET) {\n\t\t\n\t\tif (  lhs->buffering_mode == rhs->buffering_mode\n\t\t    && lhs->csi_buffer.mem_reg_size == rhs->csi_buffer.mem_reg_size\n\t\t    && lhs->csi_buffer.nof_mem_regs  == rhs->csi_buffer.nof_mem_regs\n\t\t    && lhs->acquisition_buffer.mem_reg_size == rhs->acquisition_buffer.mem_reg_size\n\t\t    && lhs->acquisition_buffer.nof_mem_regs  == rhs->acquisition_buffer.nof_mem_regs\n\t\t    && lhs->nof_xmem_buffers  == rhs->nof_xmem_buffers\n\t\t) {\n\t\t\treturn INPUT_SYSTEM_ERR_NO_ERROR;\n\t\t} else {\n\t\t\t*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;\n\t\t\treturn INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;\n\t\t}\n\t}\n\t\n\t\n\t\n\tmemory_required = rhs->csi_buffer.mem_reg_size * rhs->csi_buffer.nof_mem_regs;\n\tacq_memory_required = rhs->acquisition_buffer.mem_reg_size *\n\t\t\t      rhs->acquisition_buffer.nof_mem_regs;\n\tif (rhs->buffering_mode >= N_INPUT_SYSTEM_BUFFERING_MODE\n\t    ||\n\t    \n\t    (memory_required + acq_memory_required) > config.unallocated_ib_mem_words\n\n\t   ) {\n\t\t*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;\n\t\treturn INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;\n\t}\n\t\n\t\n\tlhs->buffering_mode\t= rhs->buffering_mode;\n\tlhs->nof_xmem_buffers = rhs->nof_xmem_buffers;\n\n\tlhs->csi_buffer.mem_reg_size = rhs->csi_buffer.mem_reg_size;\n\tlhs->csi_buffer.nof_mem_regs  = rhs->csi_buffer.nof_mem_regs;\n\tlhs->acquisition_buffer.mem_reg_size = rhs->acquisition_buffer.mem_reg_size;\n\tlhs->acquisition_buffer.nof_mem_regs  = rhs->acquisition_buffer.nof_mem_regs;\n\t\n\t\n\n\t\n\tconfig.unallocated_ib_mem_words -= memory_required;\n\n\t*flags |= INPUT_SYSTEM_CFG_FLAG_SET;\n\treturn INPUT_SYSTEM_ERR_NO_ERROR;\n}\n\n\nstatic input_system_err_t input_system_multiplexer_cfg(\n    input_system_multiplex_t *const lhs,\n    const input_system_multiplex_t\t\trhs,\n    input_system_config_flags_t *const flags)\n{\n\tassert(lhs);\n\tassert(flags);\n\n\tif ((*flags) & INPUT_SYSTEM_CFG_FLAG_BLOCKED) {\n\t\t*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;\n\t\treturn INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;\n\t}\n\n\tif ((*flags) & INPUT_SYSTEM_CFG_FLAG_SET) {\n\t\t\n\t\tif ((*lhs) == (rhs)) {\n\t\t\treturn INPUT_SYSTEM_ERR_NO_ERROR;\n\t\t} else {\n\t\t\t*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;\n\t\t\treturn INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;\n\t\t}\n\t}\n\t\n\tif (rhs >= N_INPUT_SYSTEM_MULTIPLEX) {\n\t\t*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;\n\t\treturn INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;\n\t}\n\t\n\t*lhs = rhs;\n\n\t*flags |= INPUT_SYSTEM_CFG_FLAG_SET;\n\treturn INPUT_SYSTEM_ERR_NO_ERROR;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}