{
  "module_name": "atomisp_subdev.c",
  "hash_id": "314365b0e0727660f53adfa98010446f3e63f2ee70f4510583409f1fc8ad2699",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/atomisp_subdev.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-event.h>\n#include <media/v4l2-mediabus.h>\n#include <media/videobuf2-vmalloc.h>\n#include \"atomisp_cmd.h\"\n#include \"atomisp_common.h\"\n#include \"atomisp_compat.h\"\n#include \"atomisp_fops.h\"\n#include \"atomisp_internal.h\"\n\nconst struct atomisp_in_fmt_conv atomisp_in_fmt_conv[] = {\n\t{ MEDIA_BUS_FMT_SBGGR8_1X8, 8, 8, ATOMISP_INPUT_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_BGGR },\n\t{ MEDIA_BUS_FMT_SGBRG8_1X8, 8, 8, ATOMISP_INPUT_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_GBRG },\n\t{ MEDIA_BUS_FMT_SGRBG8_1X8, 8, 8, ATOMISP_INPUT_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_GRBG },\n\t{ MEDIA_BUS_FMT_SRGGB8_1X8, 8, 8, ATOMISP_INPUT_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_RGGB },\n\t{ MEDIA_BUS_FMT_SBGGR10_1X10, 10, 10, ATOMISP_INPUT_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_BGGR },\n\t{ MEDIA_BUS_FMT_SGBRG10_1X10, 10, 10, ATOMISP_INPUT_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_GBRG },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, 10, 10, ATOMISP_INPUT_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_GRBG },\n\t{ MEDIA_BUS_FMT_SRGGB10_1X10, 10, 10, ATOMISP_INPUT_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_RGGB },\n\t{ MEDIA_BUS_FMT_SBGGR12_1X12, 12, 12, ATOMISP_INPUT_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_BGGR },\n\t{ MEDIA_BUS_FMT_SGBRG12_1X12, 12, 12, ATOMISP_INPUT_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_GBRG },\n\t{ MEDIA_BUS_FMT_SGRBG12_1X12, 12, 12, ATOMISP_INPUT_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_GRBG },\n\t{ MEDIA_BUS_FMT_SRGGB12_1X12, 12, 12, ATOMISP_INPUT_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_RGGB },\n\t{ MEDIA_BUS_FMT_UYVY8_1X16, 8, 8, ATOMISP_INPUT_FORMAT_YUV422_8, 0 },\n\t{ MEDIA_BUS_FMT_YUYV8_1X16, 8, 8, ATOMISP_INPUT_FORMAT_YUV422_8, 0 },\n#if 0 \n\t{ MEDIA_BUS_FMT_JPEG_1X8, 8, 8, IA_CSS_FRAME_FORMAT_BINARY_8, 0 },\n\t{ V4L2_MBUS_FMT_CUSTOM_NV12, 12, 12, IA_CSS_FRAME_FORMAT_NV12, 0 },\n\t{ V4L2_MBUS_FMT_CUSTOM_NV21, 12, 12, IA_CSS_FRAME_FORMAT_NV21, 0 },\n#endif\n\t{ V4L2_MBUS_FMT_CUSTOM_YUV420, 12, 12, ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY, 0 },\n#if 0\n\t{ V4L2_MBUS_FMT_CUSTOM_M10MO_RAW, 8, 8, IA_CSS_FRAME_FORMAT_BINARY_8, 0 },\n#endif\n\t \n\t{ 0, 0, 0, ATOMISP_INPUT_FORMAT_EMBEDDED, 0 },\n\t{}\n};\n\nstatic const struct {\n\tu32 code;\n\tu32 compressed;\n} compressed_codes[] = {\n\t{ MEDIA_BUS_FMT_SBGGR10_1X10, MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8 },\n\t{ MEDIA_BUS_FMT_SGBRG10_1X10, MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8 },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8 },\n\t{ MEDIA_BUS_FMT_SRGGB10_1X10, MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8 },\n};\n\nu32 atomisp_subdev_uncompressed_code(u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(compressed_codes); i++)\n\t\tif (code == compressed_codes[i].compressed)\n\t\t\treturn compressed_codes[i].code;\n\n\treturn code;\n}\n\nbool atomisp_subdev_is_compressed(u32 code)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(atomisp_in_fmt_conv) - 1; i++)\n\t\tif (code == atomisp_in_fmt_conv[i].code)\n\t\t\treturn atomisp_in_fmt_conv[i].bpp !=\n\t\t\t       atomisp_in_fmt_conv[i].depth;\n\n\treturn false;\n}\n\nconst struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv(u32 code)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(atomisp_in_fmt_conv) - 1; i++)\n\t\tif (code == atomisp_in_fmt_conv[i].code)\n\t\t\treturn atomisp_in_fmt_conv + i;\n\n\treturn NULL;\n}\n\nconst struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv_by_atomisp_in_fmt(\n    enum atomisp_input_format atomisp_in_fmt)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(atomisp_in_fmt_conv) - 1; i++)\n\t\tif (atomisp_in_fmt_conv[i].atomisp_in_fmt == atomisp_in_fmt)\n\t\t\treturn atomisp_in_fmt_conv + i;\n\n\treturn NULL;\n}\n\nbool atomisp_subdev_format_conversion(struct atomisp_sub_device *asd)\n{\n\tstruct v4l2_mbus_framefmt *sink, *src;\n\n\tsink = atomisp_subdev_get_ffmt(&asd->subdev, NULL,\n\t\t\t\t       V4L2_SUBDEV_FORMAT_ACTIVE, ATOMISP_SUBDEV_PAD_SINK);\n\tsrc = atomisp_subdev_get_ffmt(&asd->subdev, NULL,\n\t\t\t\t      V4L2_SUBDEV_FORMAT_ACTIVE, ATOMISP_SUBDEV_PAD_SOURCE);\n\n\treturn atomisp_is_mbuscode_raw(sink->code)\n\t       && !atomisp_is_mbuscode_raw(src->code);\n}\n\n \n\n \nstatic long isp_subdev_ioctl(struct v4l2_subdev *sd,\n\t\t\t     unsigned int cmd, void *arg)\n{\n\treturn 0;\n}\n\n \nstatic int isp_subdev_set_power(struct v4l2_subdev *sd, int on)\n{\n\treturn 0;\n}\n\nstatic int isp_subdev_subscribe_event(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_fh *fh,\n\t\t\t\t      struct v4l2_event_subscription *sub)\n{\n\tstruct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);\n\tstruct atomisp_device *isp = isp_sd->isp;\n\n\tif (sub->type != V4L2_EVENT_FRAME_SYNC &&\n\t    sub->type != V4L2_EVENT_FRAME_END &&\n\t    sub->type != V4L2_EVENT_ATOMISP_3A_STATS_READY &&\n\t    sub->type != V4L2_EVENT_ATOMISP_METADATA_READY &&\n\t    sub->type != V4L2_EVENT_ATOMISP_PAUSE_BUFFER &&\n\t    sub->type != V4L2_EVENT_ATOMISP_CSS_RESET &&\n\t    sub->type != V4L2_EVENT_ATOMISP_ACC_COMPLETE)\n\t\treturn -EINVAL;\n\n\tif (sub->type == V4L2_EVENT_FRAME_SYNC &&\n\t    !atomisp_css_valid_sof(isp))\n\t\treturn -EINVAL;\n\n\treturn v4l2_event_subscribe(fh, sub, 16, NULL);\n}\n\nstatic int isp_subdev_unsubscribe_event(struct v4l2_subdev *sd,\n\t\t\t\t\tstruct v4l2_fh *fh,\n\t\t\t\t\tstruct v4l2_event_subscription *sub)\n{\n\treturn v4l2_event_unsubscribe(fh, sub);\n}\n\n \nstatic int isp_subdev_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index >= ARRAY_SIZE(atomisp_in_fmt_conv) - 1)\n\t\treturn -EINVAL;\n\n\tcode->code = atomisp_in_fmt_conv[code->index].code;\n\n\treturn 0;\n}\n\nstatic int isp_subdev_validate_rect(struct v4l2_subdev *sd, uint32_t pad,\n\t\t\t\t    uint32_t target)\n{\n\tswitch (pad) {\n\tcase ATOMISP_SUBDEV_PAD_SINK:\n\t\tswitch (target) {\n\t\tcase V4L2_SEL_TGT_CROP:\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tswitch (target) {\n\t\tcase V4L2_SEL_TGT_COMPOSE:\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstruct v4l2_rect *atomisp_subdev_get_rect(struct v4l2_subdev *sd,\n\tstruct v4l2_subdev_state *sd_state,\n\tu32 which, uint32_t pad,\n\tuint32_t target)\n{\n\tstruct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);\n\n\tif (which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tswitch (target) {\n\t\tcase V4L2_SEL_TGT_CROP:\n\t\t\treturn v4l2_subdev_get_try_crop(sd, sd_state, pad);\n\t\tcase V4L2_SEL_TGT_COMPOSE:\n\t\t\treturn v4l2_subdev_get_try_compose(sd, sd_state, pad);\n\t\t}\n\t}\n\n\tswitch (target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\treturn &isp_sd->fmt[pad].crop;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\treturn &isp_sd->fmt[pad].compose;\n\t}\n\n\treturn NULL;\n}\n\nstruct v4l2_mbus_framefmt\n*atomisp_subdev_get_ffmt(struct v4l2_subdev *sd,\n\t\t\t struct v4l2_subdev_state *sd_state, uint32_t which,\n\t\t\t uint32_t pad)\n{\n\tstruct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);\n\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(sd, sd_state, pad);\n\n\treturn &isp_sd->fmt[pad].fmt;\n}\n\nstatic void isp_get_fmt_rect(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     uint32_t which,\n\t\t\t     struct v4l2_mbus_framefmt **ffmt,\n\t\t\t     struct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],\n\t\t\t     struct v4l2_rect *comp[ATOMISP_SUBDEV_PADS_NUM])\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ATOMISP_SUBDEV_PADS_NUM; i++) {\n\t\tffmt[i] = atomisp_subdev_get_ffmt(sd, sd_state, which, i);\n\t\tcrop[i] = atomisp_subdev_get_rect(sd, sd_state, which, i,\n\t\t\t\t\t\t  V4L2_SEL_TGT_CROP);\n\t\tcomp[i] = atomisp_subdev_get_rect(sd, sd_state, which, i,\n\t\t\t\t\t\t  V4L2_SEL_TGT_COMPOSE);\n\t}\n}\n\nstatic void isp_subdev_propagate(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t u32 which, uint32_t pad, uint32_t target,\n\t\t\t\t uint32_t flags)\n{\n\tstruct v4l2_mbus_framefmt *ffmt[ATOMISP_SUBDEV_PADS_NUM];\n\tstruct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],\n\t\t       *comp[ATOMISP_SUBDEV_PADS_NUM];\n\n\tif (flags & V4L2_SEL_FLAG_KEEP_CONFIG)\n\t\treturn;\n\n\tisp_get_fmt_rect(sd, sd_state, which, ffmt, crop, comp);\n\n\tswitch (pad) {\n\tcase ATOMISP_SUBDEV_PAD_SINK: {\n\t\tstruct v4l2_rect r = {0};\n\n\t\t \n\t\tr.width = ffmt[pad]->width;\n\t\tr.height = ffmt[pad]->height;\n\n\t\tatomisp_subdev_set_selection(sd, sd_state, which, pad,\n\t\t\t\t\t     target, flags, &r);\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic int isp_subdev_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_selection *sel)\n{\n\tstruct v4l2_rect *rec;\n\tint rval = isp_subdev_validate_rect(sd, sel->pad, sel->target);\n\n\tif (rval)\n\t\treturn rval;\n\n\trec = atomisp_subdev_get_rect(sd, sd_state, sel->which, sel->pad,\n\t\t\t\t      sel->target);\n\tif (!rec)\n\t\treturn -EINVAL;\n\n\tsel->r = *rec;\n\treturn 0;\n}\n\nstatic const char *atomisp_pad_str(unsigned int pad)\n{\n\tstatic const char *const pad_str[] = {\n\t\t\"ATOMISP_SUBDEV_PAD_SINK\",\n\t\t\"ATOMISP_SUBDEV_PAD_SOURCE\",\n\t};\n\n\tif (pad >= ARRAY_SIZE(pad_str))\n\t\treturn \"ATOMISP_INVALID_PAD\";\n\treturn pad_str[pad];\n}\n\nint atomisp_subdev_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t u32 which, uint32_t pad, uint32_t target,\n\t\t\t\t u32 flags, struct v4l2_rect *r)\n{\n\tstruct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);\n\tstruct atomisp_device *isp = isp_sd->isp;\n\tstruct v4l2_mbus_framefmt *ffmt[ATOMISP_SUBDEV_PADS_NUM];\n\tstruct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],\n\t\t       *comp[ATOMISP_SUBDEV_PADS_NUM];\n\n\tif ((pad == ATOMISP_SUBDEV_PAD_SINK && target != V4L2_SEL_TGT_CROP) ||\n\t    (pad == ATOMISP_SUBDEV_PAD_SOURCE && target != V4L2_SEL_TGT_COMPOSE))\n\t\treturn -EINVAL;\n\n\tisp_get_fmt_rect(sd, sd_state, which, ffmt, crop, comp);\n\n\tdev_dbg(isp->dev,\n\t\t\"sel: pad %s tgt %s l %d t %d w %d h %d which %s f 0x%8.8x\\n\",\n\t\tatomisp_pad_str(pad), target == V4L2_SEL_TGT_CROP\n\t\t? \"V4L2_SEL_TGT_CROP\" : \"V4L2_SEL_TGT_COMPOSE\",\n\t\tr->left, r->top, r->width, r->height,\n\t\twhich == V4L2_SUBDEV_FORMAT_TRY ? \"V4L2_SUBDEV_FORMAT_TRY\"\n\t\t: \"V4L2_SUBDEV_FORMAT_ACTIVE\", flags);\n\n\tr->width = rounddown(r->width, ATOM_ISP_STEP_WIDTH);\n\tr->height = rounddown(r->height, ATOM_ISP_STEP_HEIGHT);\n\n\tif (pad == ATOMISP_SUBDEV_PAD_SINK) {\n\t\t \n\t\tunsigned int dvs_w, dvs_h;\n\n\t\tcrop[pad]->width = ffmt[pad]->width;\n\t\tcrop[pad]->height = ffmt[pad]->height;\n\n\t\tif (atomisp_subdev_format_conversion(isp_sd)\n\t\t    && crop[pad]->width && crop[pad]->height) {\n\t\t\tcrop[pad]->width -= isp_sd->sink_pad_padding_w;\n\t\t\tcrop[pad]->height -= isp_sd->sink_pad_padding_h;\n\t\t}\n\n\t\tif (isp_sd->params.video_dis_en &&\n\t\t    isp_sd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {\n\t\t\t \n\t\t\tcrop[pad]->width = roundup(crop[pad]->width * 5 / 6,\n\t\t\t\t\t\t   ATOM_ISP_STEP_WIDTH);\n\t\t\tcrop[pad]->height = roundup(crop[pad]->height * 5 / 6,\n\t\t\t\t\t\t    ATOM_ISP_STEP_HEIGHT);\n\t\t}\n\n\t\tcrop[pad]->width = min(crop[pad]->width, r->width);\n\t\tcrop[pad]->height = min(crop[pad]->height, r->height);\n\n\t\tif (!(flags & V4L2_SEL_FLAG_KEEP_CONFIG)) {\n\t\t\tstruct v4l2_rect tmp = *crop[pad];\n\n\t\t\tatomisp_subdev_set_selection(sd, sd_state, which,\n\t\t\t\t\t\t     ATOMISP_SUBDEV_PAD_SOURCE,\n\t\t\t\t\t\t     V4L2_SEL_TGT_COMPOSE, flags, &tmp);\n\t\t}\n\n\t\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t\tgoto get_rect;\n\n\t\tif (isp_sd->params.video_dis_en &&\n\t\t    isp_sd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {\n\t\t\tdvs_w = rounddown(crop[pad]->width / 5,\n\t\t\t\t\t  ATOM_ISP_STEP_WIDTH);\n\t\t\tdvs_h = rounddown(crop[pad]->height / 5,\n\t\t\t\t\t  ATOM_ISP_STEP_HEIGHT);\n\t\t} else if (!isp_sd->params.video_dis_en &&\n\t\t\t   isp_sd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {\n\t\t\t \n\t\t\tdvs_w = dvs_h = 12;\n\t\t} else {\n\t\t\tdvs_w = dvs_h = 0;\n\t\t}\n\t\tatomisp_css_video_set_dis_envelope(isp_sd, dvs_w, dvs_h);\n\t\tatomisp_css_input_set_effective_resolution(isp_sd,\n\t\t\t\t\t\t\t   ATOMISP_INPUT_STREAM_GENERAL,\n\t\t\t\t\t\t\t   crop[pad]->width,\n\t\t\t\t\t\t\t   crop[pad]->height);\n\t} else if (isp_sd->run_mode->val != ATOMISP_RUN_MODE_PREVIEW) {\n\t\t \n\t\tif (isp_sd->vfpp->val == ATOMISP_VFPP_DISABLE_LOWLAT) {\n\t\t\t \n\t\t\tr->width = crop[ATOMISP_SUBDEV_PAD_SINK]->width;\n\t\t\tr->height = crop[ATOMISP_SUBDEV_PAD_SINK]->height;\n\t\t}\n\n\t\tif (crop[ATOMISP_SUBDEV_PAD_SINK]->width == r->width\n\t\t    && crop[ATOMISP_SUBDEV_PAD_SINK]->height == r->height)\n\t\t\tisp_sd->params.yuv_ds_en = false;\n\t\telse\n\t\t\tisp_sd->params.yuv_ds_en = true;\n\n\t\tcomp[pad]->width = r->width;\n\t\tcomp[pad]->height = r->height;\n\n\t\tif (r->width == 0 || r->height == 0 ||\n\t\t    crop[ATOMISP_SUBDEV_PAD_SINK]->width == 0 ||\n\t\t    crop[ATOMISP_SUBDEV_PAD_SINK]->height == 0)\n\t\t\tgoto get_rect;\n\t\t \n\t\tif (r->width * crop[ATOMISP_SUBDEV_PAD_SINK]->height <\n\t\t    crop[ATOMISP_SUBDEV_PAD_SINK]->width * r->height)\n\t\t\tatomisp_css_input_set_effective_resolution(isp_sd,\n\t\t\t\tATOMISP_INPUT_STREAM_GENERAL,\n\t\t\t\trounddown(crop[ATOMISP_SUBDEV_PAD_SINK]->\n\t\t\t\t\t  height * r->width / r->height,\n\t\t\t\t\t  ATOM_ISP_STEP_WIDTH),\n\t\t\t\tcrop[ATOMISP_SUBDEV_PAD_SINK]->height);\n\t\telse\n\t\t\tatomisp_css_input_set_effective_resolution(isp_sd,\n\t\t\t\tATOMISP_INPUT_STREAM_GENERAL,\n\t\t\t\tcrop[ATOMISP_SUBDEV_PAD_SINK]->width,\n\t\t\t\trounddown(crop[ATOMISP_SUBDEV_PAD_SINK]->\n\t\t\t\t\t  width * r->height / r->width,\n\t\t\t\t\t  ATOM_ISP_STEP_WIDTH));\n\t} else {\n\t\tcomp[pad]->width = r->width;\n\t\tcomp[pad]->height = r->height;\n\t}\n\nget_rect:\n\t \n\tif (pad != ATOMISP_SUBDEV_PAD_SINK) {\n\t\tffmt[pad]->width = comp[pad]->width;\n\t\tffmt[pad]->height = comp[pad]->height;\n\t}\n\n\tif (!atomisp_subdev_get_rect(sd, sd_state, which, pad, target))\n\t\treturn -EINVAL;\n\t*r = *atomisp_subdev_get_rect(sd, sd_state, which, pad, target);\n\n\tdev_dbg(isp->dev, \"sel actual: l %d t %d w %d h %d\\n\",\n\t\tr->left, r->top, r->width, r->height);\n\n\treturn 0;\n}\n\nstatic int isp_subdev_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_selection *sel)\n{\n\tint rval = isp_subdev_validate_rect(sd, sel->pad, sel->target);\n\n\tif (rval)\n\t\treturn rval;\n\n\treturn atomisp_subdev_set_selection(sd, sd_state, sel->which,\n\t\t\t\t\t    sel->pad,\n\t\t\t\t\t    sel->target, sel->flags, &sel->r);\n}\n\nvoid atomisp_subdev_set_ffmt(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     uint32_t which,\n\t\t\t     u32 pad, struct v4l2_mbus_framefmt *ffmt)\n{\n\tstruct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);\n\tstruct atomisp_device *isp = isp_sd->isp;\n\tstruct v4l2_mbus_framefmt *__ffmt =\n\t    atomisp_subdev_get_ffmt(sd, sd_state, which, pad);\n\n\tdev_dbg(isp->dev, \"ffmt: pad %s w %d h %d code 0x%8.8x which %s\\n\",\n\t\tatomisp_pad_str(pad), ffmt->width, ffmt->height, ffmt->code,\n\t\twhich == V4L2_SUBDEV_FORMAT_TRY ? \"V4L2_SUBDEV_FORMAT_TRY\"\n\t\t: \"V4L2_SUBDEV_FORMAT_ACTIVE\");\n\n\tswitch (pad) {\n\tcase ATOMISP_SUBDEV_PAD_SINK: {\n\t\tconst struct atomisp_in_fmt_conv *fc =\n\t\t    atomisp_find_in_fmt_conv(ffmt->code);\n\n\t\tif (!fc) {\n\t\t\tfc = atomisp_in_fmt_conv;\n\t\t\tffmt->code = fc->code;\n\t\t\tdev_dbg(isp->dev, \"using 0x%8.8x instead\\n\",\n\t\t\t\tffmt->code);\n\t\t}\n\n\t\t*__ffmt = *ffmt;\n\n\t\tisp_subdev_propagate(sd, sd_state, which, pad,\n\t\t\t\t     V4L2_SEL_TGT_CROP, 0);\n\n\t\tif (which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\t\tatomisp_css_input_set_resolution(isp_sd,\n\t\t\t\t\t\t\t ATOMISP_INPUT_STREAM_GENERAL, ffmt);\n\t\t\tatomisp_css_input_set_binning_factor(isp_sd,\n\t\t\t\t\t\t\t     ATOMISP_INPUT_STREAM_GENERAL,\n\t\t\t\t\t\t\t     0);\n\t\t\tatomisp_css_input_set_bayer_order(isp_sd, ATOMISP_INPUT_STREAM_GENERAL,\n\t\t\t\t\t\t\t  fc->bayer_order);\n\t\t\tatomisp_css_input_set_format(isp_sd, ATOMISP_INPUT_STREAM_GENERAL,\n\t\t\t\t\t\t     fc->atomisp_in_fmt);\n\t\t\tatomisp_css_set_default_isys_config(isp_sd, ATOMISP_INPUT_STREAM_GENERAL,\n\t\t\t\t\t\t\t    ffmt);\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase ATOMISP_SUBDEV_PAD_SOURCE:\n\t\t__ffmt->code = ffmt->code;\n\t\tbreak;\n\t}\n}\n\n \nstatic int isp_subdev_get_format(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_format *fmt)\n{\n\tfmt->format = *atomisp_subdev_get_ffmt(sd, sd_state, fmt->which,\n\t\t\t\t\t       fmt->pad);\n\n\treturn 0;\n}\n\n \nstatic int isp_subdev_set_format(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_format *fmt)\n{\n\tatomisp_subdev_set_ffmt(sd, sd_state, fmt->which, fmt->pad,\n\t\t\t\t&fmt->format);\n\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_core_ops isp_subdev_v4l2_core_ops = {\n\t.ioctl = isp_subdev_ioctl, .s_power = isp_subdev_set_power,\n\t.subscribe_event = isp_subdev_subscribe_event,\n\t.unsubscribe_event = isp_subdev_unsubscribe_event,\n};\n\n \nstatic const struct v4l2_subdev_pad_ops isp_subdev_v4l2_pad_ops = {\n\t.enum_mbus_code = isp_subdev_enum_mbus_code,\n\t.get_fmt = isp_subdev_get_format,\n\t.set_fmt = isp_subdev_set_format,\n\t.get_selection = isp_subdev_get_selection,\n\t.set_selection = isp_subdev_set_selection,\n\t.link_validate = v4l2_subdev_link_validate_default,\n};\n\n \nstatic const struct v4l2_subdev_ops isp_subdev_v4l2_ops = {\n\t.core = &isp_subdev_v4l2_core_ops,\n\t.pad = &isp_subdev_v4l2_pad_ops,\n};\n\nstatic void isp_subdev_init_params(struct atomisp_sub_device *asd)\n{\n\tunsigned int i;\n\n\t \n\tINIT_LIST_HEAD(&asd->s3a_stats);\n\tINIT_LIST_HEAD(&asd->s3a_stats_in_css);\n\tINIT_LIST_HEAD(&asd->s3a_stats_ready);\n\tINIT_LIST_HEAD(&asd->dis_stats);\n\tINIT_LIST_HEAD(&asd->dis_stats_in_css);\n\tspin_lock_init(&asd->dis_stats_lock);\n\tfor (i = 0; i < ATOMISP_METADATA_TYPE_NUM; i++) {\n\t\tINIT_LIST_HEAD(&asd->metadata[i]);\n\t\tINIT_LIST_HEAD(&asd->metadata_in_css[i]);\n\t\tINIT_LIST_HEAD(&asd->metadata_ready[i]);\n\t}\n}\n\n \nstatic const struct media_entity_operations isp_subdev_media_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n\t \n};\n\nstatic int __atomisp_update_run_mode(struct atomisp_sub_device *asd)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct v4l2_ctrl *ctrl = asd->run_mode;\n\tstruct v4l2_ctrl *c;\n\ts32 mode;\n\n\tmode = ctrl->val;\n\n\tc = v4l2_ctrl_find(\n\t\tisp->inputs[asd->input_curr].camera->ctrl_handler,\n\t\tV4L2_CID_RUN_MODE);\n\n\tif (c)\n\t\treturn v4l2_ctrl_s_ctrl(c, mode);\n\n\treturn 0;\n}\n\nint atomisp_update_run_mode(struct atomisp_sub_device *asd)\n{\n\tint rval;\n\n\tmutex_lock(asd->ctrl_handler.lock);\n\trval = __atomisp_update_run_mode(asd);\n\tmutex_unlock(asd->ctrl_handler.lock);\n\n\treturn rval;\n}\n\nstatic int s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct atomisp_sub_device *asd = container_of(\n\t\t\t\t\t     ctrl->handler, struct atomisp_sub_device, ctrl_handler);\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_RUN_MODE:\n\t\treturn __atomisp_update_run_mode(asd);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops ctrl_ops = {\n\t.s_ctrl = &s_ctrl,\n};\n\nstatic const char *const ctrl_run_mode_menu[] = {\n\t[ATOMISP_RUN_MODE_VIDEO]\t\t= \"Video\",\n\t[ATOMISP_RUN_MODE_STILL_CAPTURE]\t= \"Still capture\",\n\t[ATOMISP_RUN_MODE_PREVIEW]\t\t= \"Preview\",\n};\n\nstatic const struct v4l2_ctrl_config ctrl_run_mode = {\n\t.ops = &ctrl_ops,\n\t.id = V4L2_CID_RUN_MODE,\n\t.name = \"Atomisp run mode\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.min = ATOMISP_RUN_MODE_MIN,\n\t.def = ATOMISP_RUN_MODE_PREVIEW,\n\t.max = ATOMISP_RUN_MODE_MAX,\n\t.qmenu = ctrl_run_mode_menu,\n};\n\nstatic const char *const ctrl_vfpp_mode_menu[] = {\n\t\"Enable\",\t\t\t \n\t\"Disable to scaler mode\",\t \n\t\"Disable to low latency mode\",\t \n};\n\nstatic const struct v4l2_ctrl_config ctrl_vfpp = {\n\t.id = V4L2_CID_VFPP,\n\t.name = \"Atomisp vf postprocess\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.min = 0,\n\t.def = 0,\n\t.max = 2,\n\t.qmenu = ctrl_vfpp_mode_menu,\n};\n\n \nstatic const struct v4l2_ctrl_config ctrl_continuous_raw_buffer_size = {\n\t.ops = &ctrl_ops,\n\t.id = V4L2_CID_ATOMISP_CONTINUOUS_RAW_BUFFER_SIZE,\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.name = \"Continuous raw ringbuffer size\",\n\t.min = 1,\n\t.max = 100,  \n\t.step = 1,\n\t.def = 3,\n};\n\n \nstatic const struct v4l2_ctrl_config ctrl_continuous_viewfinder = {\n\t.id = V4L2_CID_ATOMISP_CONTINUOUS_VIEWFINDER,\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.name = \"Continuous viewfinder\",\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 0,\n};\n\n \nstatic const struct v4l2_ctrl_config ctrl_enable_raw_buffer_lock = {\n\t.id = V4L2_CID_ENABLE_RAW_BUFFER_LOCK,\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.name = \"Lock Unlock Raw Buffer\",\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 0,\n};\n\n \nstatic const struct v4l2_ctrl_config ctrl_disable_dz = {\n\t.id = V4L2_CID_DISABLE_DZ,\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.name = \"Disable digital zoom\",\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 0,\n};\n\nstatic int atomisp_init_subdev_pipe(struct atomisp_sub_device *asd,\n\t\t\t\t    struct atomisp_video_pipe *pipe, enum v4l2_buf_type buf_type)\n{\n\tint ret;\n\n\tpipe->type = buf_type;\n\tpipe->asd = asd;\n\tpipe->isp = asd->isp;\n\tspin_lock_init(&pipe->irq_lock);\n\tmutex_init(&pipe->vb_queue_mutex);\n\n\t \n\tpipe->vb_queue.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tpipe->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR;\n\tpipe->vb_queue.buf_struct_size = sizeof(struct ia_css_frame);\n\tpipe->vb_queue.ops = &atomisp_vb2_ops;\n\tpipe->vb_queue.mem_ops = &vb2_vmalloc_memops;\n\tpipe->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tret = vb2_queue_init(&pipe->vb_queue);\n\tif (ret)\n\t\treturn ret;\n\n\tpipe->vdev.queue = &pipe->vb_queue;\n\tpipe->vdev.queue->lock = &pipe->vb_queue_mutex;\n\n\tINIT_LIST_HEAD(&pipe->buffers_in_css);\n\tINIT_LIST_HEAD(&pipe->activeq);\n\tINIT_LIST_HEAD(&pipe->buffers_waiting_for_param);\n\tINIT_LIST_HEAD(&pipe->per_frame_params);\n\n\treturn 0;\n}\n\n \nstatic int isp_subdev_init_entities(struct atomisp_sub_device *asd)\n{\n\tstruct v4l2_subdev *sd = &asd->subdev;\n\tstruct media_pad *pads = asd->pads;\n\tstruct media_entity *me = &sd->entity;\n\tint ret;\n\n\tv4l2_subdev_init(sd, &isp_subdev_v4l2_ops);\n\tsprintf(sd->name, \"ATOMISP_SUBDEV\");\n\tv4l2_set_subdevdata(sd, asd);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsd->devnode = &asd->video_out.vdev;\n\n\tpads[ATOMISP_SUBDEV_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tpads[ATOMISP_SUBDEV_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\n\tasd->fmt[ATOMISP_SUBDEV_PAD_SINK].fmt.code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\tasd->fmt[ATOMISP_SUBDEV_PAD_SOURCE].fmt.code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\n\tme->ops = &isp_subdev_media_ops;\n\tme->function = MEDIA_ENT_F_PROC_VIDEO_ISP;\n\tret = media_entity_pads_init(me, ATOMISP_SUBDEV_PADS_NUM, pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = atomisp_init_subdev_pipe(asd, &asd->video_out, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = atomisp_video_init(&asd->video_out);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = v4l2_ctrl_handler_init(&asd->ctrl_handler, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tasd->run_mode = v4l2_ctrl_new_custom(&asd->ctrl_handler,\n\t\t\t\t\t     &ctrl_run_mode, NULL);\n\tasd->vfpp = v4l2_ctrl_new_custom(&asd->ctrl_handler,\n\t\t\t\t\t &ctrl_vfpp, NULL);\n\tasd->continuous_viewfinder = v4l2_ctrl_new_custom(&asd->ctrl_handler,\n\t\t\t\t     &ctrl_continuous_viewfinder,\n\t\t\t\t     NULL);\n\tasd->continuous_raw_buffer_size =\n\t    v4l2_ctrl_new_custom(&asd->ctrl_handler,\n\t\t\t\t &ctrl_continuous_raw_buffer_size,\n\t\t\t\t NULL);\n\n\tasd->enable_raw_buffer_lock =\n\t    v4l2_ctrl_new_custom(&asd->ctrl_handler,\n\t\t\t\t &ctrl_enable_raw_buffer_lock,\n\t\t\t\t NULL);\n\tasd->disable_dz =\n\t    v4l2_ctrl_new_custom(&asd->ctrl_handler,\n\t\t\t\t &ctrl_disable_dz,\n\t\t\t\t NULL);\n\n\t \n\tasd->subdev.ctrl_handler = &asd->ctrl_handler;\n\tspin_lock_init(&asd->raw_buffer_bitmap_lock);\n\treturn asd->ctrl_handler.error;\n}\n\nstatic void atomisp_subdev_cleanup_entities(struct atomisp_sub_device *asd)\n{\n\tv4l2_ctrl_handler_free(&asd->ctrl_handler);\n\n\tmedia_entity_cleanup(&asd->subdev.entity);\n}\n\nvoid atomisp_subdev_cleanup_pending_events(struct atomisp_sub_device *asd)\n{\n\tstruct v4l2_fh *fh, *fh_tmp;\n\tstruct v4l2_event event;\n\tunsigned int i, pending_event;\n\n\tlist_for_each_entry_safe(fh, fh_tmp,\n\t\t\t\t &asd->subdev.devnode->fh_list, list) {\n\t\tpending_event = v4l2_event_pending(fh);\n\t\tfor (i = 0; i < pending_event; i++)\n\t\t\tv4l2_event_dequeue(fh, &event, 1);\n\t}\n}\n\nvoid atomisp_subdev_unregister_entities(struct atomisp_sub_device *asd)\n{\n\tatomisp_subdev_cleanup_entities(asd);\n\tv4l2_device_unregister_subdev(&asd->subdev);\n\tatomisp_video_unregister(&asd->video_out);\n}\n\nint atomisp_subdev_register_subdev(struct atomisp_sub_device *asd,\n\t\t\t\t   struct v4l2_device *vdev)\n{\n\treturn v4l2_device_register_subdev(vdev, &asd->subdev);\n}\n\n \nint atomisp_subdev_init(struct atomisp_device *isp)\n{\n\tint ret;\n\n\tisp->asd.isp = isp;\n\tisp_subdev_init_params(&isp->asd);\n\tret = isp_subdev_init_entities(&isp->asd);\n\tif (ret < 0)\n\t\tatomisp_subdev_cleanup_entities(&isp->asd);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}