{
  "module_name": "sh_css_param_shading.c",
  "hash_id": "973b4f37e388c44b6e4734c34a6231e4e6a4036b0823da5204e3c8b54cad343f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/sh_css_param_shading.c",
  "human_readable_source": "\n \n\n#include <linux/math.h>\n#include <linux/slab.h>\n\n#include <math_support.h>\n#include \"sh_css_param_shading.h\"\n#include \"ia_css_shading.h\"\n#include \"assert_support.h\"\n#include \"sh_css_defs.h\"\n#include \"sh_css_internal.h\"\n#include \"ia_css_debug.h\"\n#include \"ia_css_pipe_binarydesc.h\"\n\n#include \"sh_css_hrt.h\"\n\n#include \"platform_support.h\"\n\n \nstatic void\ncrop_and_interpolate(unsigned int cropped_width,\n\t\t     unsigned int cropped_height,\n\t\t     unsigned int left_padding,\n\t\t     int right_padding,\n\t\t     int top_padding,\n\t\t     const struct ia_css_shading_table *in_table,\n\t\t     struct ia_css_shading_table *out_table,\n\t\t     enum ia_css_sc_color color)\n{\n\tunsigned int i, j,\n\t\t sensor_width,\n\t\t sensor_height,\n\t\t table_width,\n\t\t table_height,\n\t\t table_cell_h,\n\t\t out_cell_size,\n\t\t in_cell_size,\n\t\t out_start_row,\n\t\t padded_width;\n\tint out_start_col,  \n\t    table_cell_w;\n\tunsigned short *in_ptr,\n\t\t *out_ptr;\n\n\tassert(in_table);\n\tassert(out_table);\n\n\tsensor_width  = in_table->sensor_width;\n\tsensor_height = in_table->sensor_height;\n\ttable_width   = in_table->width;\n\ttable_height  = in_table->height;\n\tin_ptr = in_table->data[color];\n\tout_ptr = out_table->data[color];\n\n\tpadded_width = cropped_width + left_padding + right_padding;\n\tout_cell_size = CEIL_DIV(padded_width, out_table->width - 1);\n\tin_cell_size  = CEIL_DIV(sensor_width, table_width - 1);\n\n\tout_start_col = ((int)sensor_width - (int)cropped_width) / 2 - left_padding;\n\tout_start_row = ((int)sensor_height - (int)cropped_height) / 2 - top_padding;\n\ttable_cell_w = (int)((table_width - 1) * in_cell_size);\n\ttable_cell_h = (table_height - 1) * in_cell_size;\n\n\tfor (i = 0; i < out_table->height; i++) {\n\t\tint ty, src_y0, src_y1;\n\t\tunsigned int sy0, sy1, dy0, dy1, divy;\n\n\t\t \n\t\tty = out_start_row + i * out_cell_size;\n\n\t\t \n\t\tsrc_y0 = ty / (int)in_cell_size;\n\t\tif (in_cell_size < out_cell_size)\n\t\t\tsrc_y1 = (ty + out_cell_size) / in_cell_size;\n\t\telse\n\t\t\tsrc_y1 = src_y0 + 1;\n\t\tsrc_y0 = clamp(src_y0, 0, (int)table_height - 1);\n\t\tsrc_y1 = clamp(src_y1, 0, (int)table_height - 1);\n\t\tty = min(clamp(ty, 0, (int)sensor_height - 1),\n\t\t\t (int)table_cell_h);\n\n\t\t \n\t\tsy0 = min(src_y0 * in_cell_size, sensor_height - 1);\n\t\tsy1 = min(src_y1 * in_cell_size, sensor_height - 1);\n\t\t \n\t\tdy0 = ty - sy0;\n\t\tdy1 = sy1 - ty;\n\t\tdivy = sy1 - sy0;\n\t\tif (divy == 0) {\n\t\t\tdy0 = 1;\n\t\t\tdivy = 1;\n\t\t}\n\n\t\tfor (j = 0; j < out_table->width; j++, out_ptr++) {\n\t\t\tint tx, src_x0, src_x1;\n\t\t\tunsigned int sx0, sx1, dx0, dx1, divx;\n\t\t\tunsigned short s_ul, s_ur, s_ll, s_lr;\n\n\t\t\t \n\t\t\ttx = out_start_col + j * out_cell_size;\n\t\t\t \n\t\t\tsrc_x0 = tx / (int)in_cell_size;\n\t\t\tif (in_cell_size < out_cell_size) {\n\t\t\t\tsrc_x1 = (tx + out_cell_size) /\n\t\t\t\t\t (int)in_cell_size;\n\t\t\t} else {\n\t\t\t\tsrc_x1 = src_x0 + 1;\n\t\t\t}\n\t\t\t \n\t\t\tsrc_x0 = clamp(src_x0, 0, (int)table_width - 1);\n\t\t\tsrc_x1 = clamp(src_x1, 0, (int)table_width - 1);\n\t\t\ttx = min(clamp(tx, 0, (int)sensor_width - 1),\n\t\t\t\t (int)table_cell_w);\n\t\t\t \n\t\t\tsx0 = min(src_x0 * in_cell_size, sensor_width - 1);\n\t\t\tsx1 = min(src_x1 * in_cell_size, sensor_width - 1);\n\t\t\t \n\t\t\tdx0 = tx - sx0;\n\t\t\tdx1 = sx1 - tx;\n\t\t\tdivx = sx1 - sx0;\n\t\t\t \n\t\t\tif (divx == 0) {\n\t\t\t\tdx0 = 1;\n\t\t\t\tdivx = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\ts_ul = in_ptr[(table_width * src_y0) + src_x0];\n\t\t\ts_ur = in_ptr[(table_width * src_y0) + src_x1];\n\t\t\ts_ll = in_ptr[(table_width * src_y1) + src_x0];\n\t\t\ts_lr = in_ptr[(table_width * src_y1) + src_x1];\n\n\t\t\t*out_ptr = (unsigned short)((dx0 * dy0 * s_lr + dx0 * dy1 * s_ur + dx1 * dy0 *\n\t\t\t\t\t\t     s_ll + dx1 * dy1 * s_ul) /\n\t\t\t\t\t\t    (divx * divy));\n\t\t}\n\t}\n}\n\nvoid\nsh_css_params_shading_id_table_generate(\n    struct ia_css_shading_table **target_table,\n    unsigned int table_width,\n    unsigned int table_height)\n{\n\t \n\tunsigned int i, j;\n\tstruct ia_css_shading_table *result;\n\n\tassert(target_table);\n\n\tresult = ia_css_shading_table_alloc(table_width, table_height);\n\tif (!result) {\n\t\t*target_table = NULL;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {\n\t\tfor (j = 0; j < table_height * table_width; j++)\n\t\t\tresult->data[i][j] = 1;\n\t}\n\tresult->fraction_bits = 0;\n\t*target_table = result;\n}\n\nvoid\nprepare_shading_table(const struct ia_css_shading_table *in_table,\n\t\t      unsigned int sensor_binning,\n\t\t      struct ia_css_shading_table **target_table,\n\t\t      const struct ia_css_binary *binary,\n\t\t      unsigned int bds_factor)\n{\n\tunsigned int input_width, input_height, table_width, table_height, i;\n\tunsigned int left_padding, top_padding, left_cropping;\n\tstruct ia_css_shading_table *result;\n\tstruct u32_fract bds;\n\tint right_padding;\n\n\tassert(target_table);\n\tassert(binary);\n\n\tif (!in_table) {\n\t\tsh_css_params_shading_id_table_generate(target_table,\n\t\t\t\t\t\t\tbinary->sctbl_width_per_color,\n\t\t\t\t\t\t\tbinary->sctbl_height);\n\t\treturn;\n\t}\n\n\t \n\tinput_height  = binary->in_frame_info.res.height;\n\tinput_width   = binary->in_frame_info.res.width;\n\tleft_padding  = binary->left_padding;\n\tleft_cropping = (binary->info->sp.pipeline.left_cropping == 0) ?\n\t\t\tbinary->dvs_envelope.width : 2 * ISP_VEC_NELEMS;\n\n\tsh_css_bds_factor_get_fract(bds_factor, &bds);\n\n\tleft_padding  = (left_padding + binary->info->sp.pipeline.left_cropping) *\n\t\t\tbds.numerator / bds.denominator -\n\t\t\tbinary->info->sp.pipeline.left_cropping;\n\tright_padding = (binary->internal_frame_info.res.width -\n\t\t\t binary->effective_in_frame_res.width * bds.denominator /\n\t\t\t bds.numerator - left_cropping) * bds.numerator / bds.denominator;\n\ttop_padding = binary->info->sp.pipeline.top_cropping * bds.numerator /\n\t\t      bds.denominator -\n\t\t      binary->info->sp.pipeline.top_cropping;\n\n\t \n\tinput_width  <<= sensor_binning;\n\tinput_height <<= sensor_binning;\n\t \n\tleft_padding  <<= sensor_binning;\n\tright_padding <<= sensor_binning;\n\ttop_padding   <<= sensor_binning;\n\n\t \n\tinput_width  = min(input_width,  in_table->sensor_width);\n\tinput_height = min(input_height, in_table->sensor_height);\n\n\t \n\ttable_width  = binary->sctbl_width_per_color;\n\ttable_height = binary->sctbl_height;\n\n\tresult = ia_css_shading_table_alloc(table_width, table_height);\n\tif (!result) {\n\t\t*target_table = NULL;\n\t\treturn;\n\t}\n\tresult->sensor_width  = in_table->sensor_width;\n\tresult->sensor_height = in_table->sensor_height;\n\tresult->fraction_bits = in_table->fraction_bits;\n\n\t \n\tfor (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {\n\t\tcrop_and_interpolate(input_width, input_height,\n\t\t\t\t     left_padding, right_padding, top_padding,\n\t\t\t\t     in_table,\n\t\t\t\t     result, i);\n\t}\n\t*target_table = result;\n}\n\nstruct ia_css_shading_table *\nia_css_shading_table_alloc(\n    unsigned int width,\n    unsigned int height)\n{\n\tunsigned int i;\n\tstruct ia_css_shading_table *me;\n\n\tIA_CSS_ENTER(\"\");\n\n\tme = kmalloc(sizeof(*me), GFP_KERNEL);\n\tif (!me)\n\t\treturn me;\n\n\tme->width         = width;\n\tme->height        = height;\n\tme->sensor_width  = 0;\n\tme->sensor_height = 0;\n\tme->fraction_bits = 0;\n\tfor (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {\n\t\tme->data[i] =\n\t\t    kvmalloc(width * height * sizeof(*me->data[0]),\n\t\t\t     GFP_KERNEL);\n\t\tif (!me->data[i]) {\n\t\t\tunsigned int j;\n\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tkvfree(me->data[j]);\n\t\t\t\tme->data[j] = NULL;\n\t\t\t}\n\t\t\tkfree(me);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tIA_CSS_LEAVE(\"\");\n\treturn me;\n}\n\nvoid\nia_css_shading_table_free(struct ia_css_shading_table *table)\n{\n\tunsigned int i;\n\n\tif (!table)\n\t\treturn;\n\n\t \n\tIA_CSS_ENTER(\"\");\n\n\tfor (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {\n\t\tif (table->data[i]) {\n\t\t\tkvfree(table->data[i]);\n\t\t\ttable->data[i] = NULL;\n\t\t}\n\t}\n\tkfree(table);\n\n\tIA_CSS_LEAVE(\"\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}