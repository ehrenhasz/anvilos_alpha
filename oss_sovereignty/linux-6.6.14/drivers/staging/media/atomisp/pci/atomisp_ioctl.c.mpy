{
  "module_name": "atomisp_ioctl.c",
  "hash_id": "41de12946f986c749787c7b5930ba62abb2da7ca0bfdcc3f180ca03d6672e172",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/atomisp_ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/pci.h>\n\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n\n#include \"atomisp_cmd.h\"\n#include \"atomisp_common.h\"\n#include \"atomisp_fops.h\"\n#include \"atomisp_internal.h\"\n#include \"atomisp_ioctl.h\"\n#include \"atomisp-regs.h\"\n#include \"atomisp_compat.h\"\n\n#include \"sh_css_hrt.h\"\n\n#include \"gp_device.h\"\n#include \"device_access.h\"\n#include \"irq.h\"\n\nstatic const char *DRIVER = \"atomisp\";\t \nstatic const char *CARD = \"ATOM ISP\";\t \n\n \nstatic struct v4l2_queryctrl ci_v4l2_controls[] = {\n\t{\n\t\t.id = V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"Automatic White Balance\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_RED_BALANCE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Red Balance\",\n\t\t.minimum = 0x00,\n\t\t.maximum = 0xff,\n\t\t.step = 1,\n\t\t.default_value = 0x00,\n\t},\n\t{\n\t\t.id = V4L2_CID_BLUE_BALANCE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Blue Balance\",\n\t\t.minimum = 0x00,\n\t\t.maximum = 0xff,\n\t\t.step = 1,\n\t\t.default_value = 0x00,\n\t},\n\t{\n\t\t.id = V4L2_CID_GAMMA,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Gamma\",\n\t\t.minimum = 0x00,\n\t\t.maximum = 0xff,\n\t\t.step = 1,\n\t\t.default_value = 0x00,\n\t},\n\t{\n\t\t.id = V4L2_CID_POWER_LINE_FREQUENCY,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.name = \"Light frequency filter\",\n\t\t.minimum = 1,\n\t\t.maximum = 2,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_COLORFX,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Image Color Effect\",\n\t\t.minimum = 0,\n\t\t.maximum = 9,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_COLORFX_CBCR,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Image Color Effect CbCr\",\n\t\t.minimum = 0,\n\t\t.maximum = 0xffff,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Bad Pixel Correction\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"GDC/CAC\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_ATOMISP_VIDEO_STABLIZATION,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Video Stablization\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_ATOMISP_FIXED_PATTERN_NR,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Fixed Pattern Noise Reduction\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"False Color Correction\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_REQUEST_FLASH,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Request flash frames\",\n\t\t.minimum = 0,\n\t\t.maximum = 10,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_ATOMISP_LOW_LIGHT,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"Low light mode\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_2A_STATUS,\n\t\t.type = V4L2_CTRL_TYPE_BITMASK,\n\t\t.name = \"AE and AWB status\",\n\t\t.minimum = 0,\n\t\t.maximum = V4L2_2A_STATUS_AE_READY | V4L2_2A_STATUS_AWB_READY,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_EXPOSURE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"exposure\",\n\t\t.minimum = -4,\n\t\t.maximum = 4,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_EXPOSURE_ZONE_NUM,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"one-time exposure zone number\",\n\t\t.minimum = 0x0,\n\t\t.maximum = 0xffff,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_EXPOSURE_AUTO_PRIORITY,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Exposure auto priority\",\n\t\t.minimum = V4L2_EXPOSURE_AUTO,\n\t\t.maximum = V4L2_EXPOSURE_APERTURE_PRIORITY,\n\t\t.step = 1,\n\t\t.default_value = V4L2_EXPOSURE_AUTO,\n\t},\n\t{\n\t\t.id = V4L2_CID_SCENE_MODE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"scene mode\",\n\t\t.minimum = 0,\n\t\t.maximum = 13,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_ISO_SENSITIVITY,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"iso\",\n\t\t.minimum = -4,\n\t\t.maximum = 4,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_ISO_SENSITIVITY_AUTO,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"iso mode\",\n\t\t.minimum = V4L2_ISO_SENSITIVITY_MANUAL,\n\t\t.maximum = V4L2_ISO_SENSITIVITY_AUTO,\n\t\t.step = 1,\n\t\t.default_value = V4L2_ISO_SENSITIVITY_AUTO,\n\t},\n\t{\n\t\t.id = V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"white balance\",\n\t\t.minimum = 0,\n\t\t.maximum = 9,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_EXPOSURE_METERING,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.name = \"metering\",\n\t\t.minimum = 0,\n\t\t.maximum = 3,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_3A_LOCK,\n\t\t.type = V4L2_CTRL_TYPE_BITMASK,\n\t\t.name = \"3a lock\",\n\t\t.minimum = 0,\n\t\t.maximum = V4L2_LOCK_EXPOSURE | V4L2_LOCK_WHITE_BALANCE\n\t\t| V4L2_LOCK_FOCUS,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_TEST_PATTERN,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Test Pattern\",\n\t\t.minimum = 0,\n\t\t.maximum = 0xffff,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_TEST_PATTERN_COLOR_R,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Test Pattern Solid Color R\",\n\t\t.minimum = INT_MIN,\n\t\t.maximum = INT_MAX,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_TEST_PATTERN_COLOR_GR,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Test Pattern Solid Color GR\",\n\t\t.minimum = INT_MIN,\n\t\t.maximum = INT_MAX,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_TEST_PATTERN_COLOR_GB,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Test Pattern Solid Color GB\",\n\t\t.minimum = INT_MIN,\n\t\t.maximum = INT_MAX,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_TEST_PATTERN_COLOR_B,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Test Pattern Solid Color B\",\n\t\t.minimum = INT_MIN,\n\t\t.maximum = INT_MAX,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n};\n\nstatic const u32 ctrls_num = ARRAY_SIZE(ci_v4l2_controls);\n\n \nconst struct atomisp_format_bridge atomisp_output_fmts[] = {\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_YUV420,\n\t\t.depth = 12,\n\t\t.mbus_code = V4L2_MBUS_FMT_CUSTOM_YUV420,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_YUV420,\n\t\t.description = \"YUV420, planar\",\n\t\t.planar = true\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_YVU420,\n\t\t.depth = 12,\n\t\t.mbus_code = V4L2_MBUS_FMT_CUSTOM_YVU420,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_YV12,\n\t\t.description = \"YVU420, planar\",\n\t\t.planar = true\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_YUV422P,\n\t\t.depth = 16,\n\t\t.mbus_code = V4L2_MBUS_FMT_CUSTOM_YUV422P,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_YUV422,\n\t\t.description = \"YUV422, planar\",\n\t\t.planar = true\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_YUV444,\n\t\t.depth = 24,\n\t\t.mbus_code = V4L2_MBUS_FMT_CUSTOM_YUV444,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_YUV444,\n\t\t.description = \"YUV444\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_NV12,\n\t\t.depth = 12,\n\t\t.mbus_code = V4L2_MBUS_FMT_CUSTOM_NV12,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_NV12,\n\t\t.description = \"NV12, Y-plane, CbCr interleaved\",\n\t\t.planar = true\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_NV21,\n\t\t.depth = 12,\n\t\t.mbus_code = V4L2_MBUS_FMT_CUSTOM_NV21,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_NV21,\n\t\t.description = \"NV21, Y-plane, CbCr interleaved\",\n\t\t.planar = true\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_NV16,\n\t\t.depth = 16,\n\t\t.mbus_code = V4L2_MBUS_FMT_CUSTOM_NV16,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_NV16,\n\t\t.description = \"NV16, Y-plane, CbCr interleaved\",\n\t\t.planar = true\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_YUYV,\n\t\t.depth = 16,\n\t\t.mbus_code = V4L2_MBUS_FMT_CUSTOM_YUYV,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_YUYV,\n\t\t.description = \"YUYV, interleaved\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_UYVY,\n\t\t.depth = 16,\n\t\t.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_UYVY,\n\t\t.description = \"UYVY, interleaved\"\n\t}, {  \n\t\t.pixelformat = V4L2_PIX_FMT_UYVY,\n\t\t.depth = 16,\n\t\t.mbus_code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_UYVY,\n\t\t.description = \"UYVY, interleaved\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_SBGGR16,\n\t\t.depth = 16,\n\t\t.mbus_code = V4L2_MBUS_FMT_CUSTOM_SBGGR16,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,\n\t\t.description = \"Bayer 16\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_SBGGR8,\n\t\t.depth = 8,\n\t\t.mbus_code = MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,\n\t\t.description = \"Bayer 8\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_SGBRG8,\n\t\t.depth = 8,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,\n\t\t.description = \"Bayer 8\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_SGRBG8,\n\t\t.depth = 8,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,\n\t\t.description = \"Bayer 8\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_SRGGB8,\n\t\t.depth = 8,\n\t\t.mbus_code = MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,\n\t\t.description = \"Bayer 8\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_SBGGR10,\n\t\t.depth = 16,\n\t\t.mbus_code = MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,\n\t\t.description = \"Bayer 10\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_SGBRG10,\n\t\t.depth = 16,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,\n\t\t.description = \"Bayer 10\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_SGRBG10,\n\t\t.depth = 16,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,\n\t\t.description = \"Bayer 10\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_SRGGB10,\n\t\t.depth = 16,\n\t\t.mbus_code = MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,\n\t\t.description = \"Bayer 10\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_SBGGR12,\n\t\t.depth = 16,\n\t\t.mbus_code = MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,\n\t\t.description = \"Bayer 12\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_SGBRG12,\n\t\t.depth = 16,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,\n\t\t.description = \"Bayer 12\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_SGRBG12,\n\t\t.depth = 16,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,\n\t\t.description = \"Bayer 12\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_SRGGB12,\n\t\t.depth = 16,\n\t\t.mbus_code = MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,\n\t\t.description = \"Bayer 12\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_RGB32,\n\t\t.depth = 32,\n\t\t.mbus_code = V4L2_MBUS_FMT_CUSTOM_RGB32,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RGBA888,\n\t\t.description = \"32 RGB 8-8-8-8\"\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_RGB565,\n\t\t.depth = 16,\n\t\t.mbus_code = MEDIA_BUS_FMT_BGR565_2X8_LE,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_RGB565,\n\t\t.description = \"16 RGB 5-6-5\"\n#if 0\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_JPEG,\n\t\t.depth = 8,\n\t\t.mbus_code = MEDIA_BUS_FMT_JPEG_1X8,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_BINARY_8,\n\t\t.description = \"JPEG\"\n\t}, {\n\t\t \n\t\t.pixelformat = V4L2_PIX_FMT_CUSTOM_M10MO_RAW,\n\t\t.depth = 8,\n\t\t.mbus_code = V4L2_MBUS_FMT_CUSTOM_M10MO_RAW,\n\t\t.sh_fmt = IA_CSS_FRAME_FORMAT_BINARY_8,\n\t\t.description = \"Custom RAW for M10MO\"\n#endif\n\t},\n};\n\nconst struct atomisp_format_bridge *\natomisp_get_format_bridge(unsigned int pixelformat)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(atomisp_output_fmts); i++) {\n\t\tif (atomisp_output_fmts[i].pixelformat == pixelformat)\n\t\t\treturn &atomisp_output_fmts[i];\n\t}\n\n\treturn NULL;\n}\n\nconst struct atomisp_format_bridge *\natomisp_get_format_bridge_from_mbus(u32 mbus_code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(atomisp_output_fmts); i++) {\n\t\tif (mbus_code == atomisp_output_fmts[i].mbus_code)\n\t\t\treturn &atomisp_output_fmts[i];\n\t}\n\n\treturn NULL;\n}\n\nint atomisp_pipe_check(struct atomisp_video_pipe *pipe, bool settings_change)\n{\n\tlockdep_assert_held(&pipe->isp->mutex);\n\n\tif (pipe->isp->isp_fatal_error)\n\t\treturn -EIO;\n\n\tif (settings_change && vb2_is_busy(&pipe->vb_queue)) {\n\t\tdev_err(pipe->isp->dev, \"Set fmt/input IOCTL while streaming\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int atomisp_querycap(struct file *file, void *fh,\n\t\t\t    struct v4l2_capability *cap)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\n\tstrscpy(cap->driver, DRIVER, sizeof(cap->driver));\n\tstrscpy(cap->card, CARD, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"PCI:%s\", dev_name(isp->dev));\n\n\treturn 0;\n}\n\n \nstatic int atomisp_enum_input(struct file *file, void *fh,\n\t\t\t      struct v4l2_input *input)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tint index = input->index;\n\tstruct v4l2_subdev *motor;\n\n\tif (index >= isp->input_cnt)\n\t\treturn -EINVAL;\n\n\tif (!isp->inputs[index].camera)\n\t\treturn -EINVAL;\n\n\tmemset(input, 0, sizeof(struct v4l2_input));\n\tstrscpy(input->name, isp->inputs[index].camera->name,\n\t\tsizeof(input->name));\n\n\t \n\tif (!IS_ISP2401)\n\t\tmotor = isp->inputs[index].motor;\n\telse\n\t\tmotor = isp->motor;\n\n\tif (motor && strlen(motor->name) > 0) {\n\t\tconst int cur_len = strlen(input->name);\n\t\tconst int max_size = sizeof(input->name) - cur_len - 1;\n\n\t\tif (max_size > 1) {\n\t\t\tinput->name[cur_len] = '+';\n\t\t\tstrscpy(&input->name[cur_len + 1],\n\t\t\t\tmotor->name, max_size);\n\t\t}\n\t}\n\n\tinput->type = V4L2_INPUT_TYPE_CAMERA;\n\tinput->index = index;\n\tinput->reserved[0] = isp->inputs[index].type;\n\tinput->reserved[1] = isp->inputs[index].port;\n\n\treturn 0;\n}\n\n \nstatic int atomisp_g_input(struct file *file, void *fh, unsigned int *input)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;\n\n\t*input = asd->input_curr;\n\treturn 0;\n}\n\nstatic int atomisp_s_fmt_cap(struct file *file, void *fh,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\treturn atomisp_set_fmt(vdev, f);\n}\n\n \nstatic int atomisp_s_input(struct file *file, void *fh, unsigned int input)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);\n\tstruct atomisp_sub_device *asd = pipe->asd;\n\tstruct v4l2_subdev *camera = NULL;\n\tstruct v4l2_subdev *motor;\n\tint ret;\n\n\tret = atomisp_pipe_check(pipe, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (input >= ATOM_ISP_MAX_INPUTS || input >= isp->input_cnt) {\n\t\tdev_dbg(isp->dev, \"input_cnt: %d\\n\", isp->input_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\tcamera = isp->inputs[input].camera;\n\tif (!camera) {\n\t\tdev_err(isp->dev, \"%s, no camera\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (isp->inputs[asd->input_curr].asd == asd &&\n\t    asd->input_curr != input) {\n\t\tret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,\n\t\t\t\t       core, s_power, 0);\n\t\tif (ret && ret != -ENOIOCTLCMD)\n\t\t\tdev_warn(isp->dev,\n\t\t\t\t \"Failed to power-off sensor\\n\");\n\t\t \n\t\tisp->inputs[asd->input_curr].asd = NULL;\n\t}\n\n\t \n\tret = v4l2_subdev_call(isp->inputs[input].camera, core, s_power, 1);\n\tif (ret && ret != -ENOIOCTLCMD) {\n\t\tdev_err(isp->dev, \"Failed to power-on sensor\\n\");\n\t\treturn ret;\n\t}\n\t \n\tatomisp_update_run_mode(asd);\n\n\t \n\tret = v4l2_subdev_call(isp->inputs[input].camera, video, s_routing,\n\t\t\t       0, 0, 0);\n\tif (ret && (ret != -ENOIOCTLCMD)) {\n\t\tdev_err(isp->dev, \"Failed to select sensor\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!IS_ISP2401) {\n\t\tmotor = isp->inputs[input].motor;\n\t} else {\n\t\tmotor = isp->motor;\n\t\tif (motor)\n\t\t\tret = v4l2_subdev_call(motor, core, s_power, 1);\n\t}\n\n\tif (motor)\n\t\tret = v4l2_subdev_call(motor, core, init, 1);\n\n\tasd->input_curr = input;\n\t \n\tisp->inputs[input].asd = asd;\n\n\treturn 0;\n}\n\n \nstatic int atomisp_enum_framesizes_crop_inner(struct atomisp_device *isp,\n\t\t\t\t\t      struct v4l2_frmsizeenum *fsize,\n\t\t\t\t\t      const struct v4l2_rect *active,\n\t\t\t\t\t      const struct v4l2_rect *native,\n\t\t\t\t\t      int *valid_sizes)\n{\n\tstatic const struct v4l2_frmsize_discrete frame_sizes[] = {\n\t\t{ 1600, 1200 },\n\t\t{ 1600, 1080 },\n\t\t{ 1600,  900 },\n\t\t{ 1440, 1080 },\n\t\t{ 1280,  960 },\n\t\t{ 1280,  720 },\n\t\t{  800,  600 },\n\t\t{  640,  480 },\n\t};\n\tu32 padding_w, padding_h;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_sizes); i++) {\n\t\tatomisp_get_padding(isp, frame_sizes[i].width, frame_sizes[i].height,\n\t\t\t\t    &padding_w, &padding_h);\n\n\t\tif ((frame_sizes[i].width + padding_w) > native->width ||\n\t\t    (frame_sizes[i].height + padding_h) > native->height)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (frame_sizes[i].width < (active->width * 2 / 3) &&\n\t\t    frame_sizes[i].height < (active->height * 2 / 3))\n\t\t\tcontinue;\n\n\t\tif (*valid_sizes == fsize->index) {\n\t\t\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\t\t\tfsize->discrete = frame_sizes[i];\n\t\t\treturn 0;\n\t\t}\n\n\t\t(*valid_sizes)++;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int atomisp_enum_framesizes_crop(struct atomisp_device *isp,\n\t\t\t\t\tstruct v4l2_frmsizeenum *fsize)\n{\n\tstruct atomisp_input_subdev *input = &isp->inputs[isp->asd.input_curr];\n\tstruct v4l2_rect active = input->active_rect;\n\tstruct v4l2_rect native = input->native_rect;\n\tint ret, valid_sizes = 0;\n\n\tret = atomisp_enum_framesizes_crop_inner(isp, fsize, &active, &native, &valid_sizes);\n\tif (ret == 0)\n\t\treturn 0;\n\n\tif (!input->binning_support)\n\t\treturn -EINVAL;\n\n\tactive.width /= 2;\n\tactive.height /= 2;\n\tnative.width /= 2;\n\tnative.height /= 2;\n\n\treturn atomisp_enum_framesizes_crop_inner(isp, fsize, &active, &native, &valid_sizes);\n}\n\nstatic int atomisp_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_frmsizeenum *fsize)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;\n\tstruct atomisp_input_subdev *input = &isp->inputs[asd->input_curr];\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.index = fsize->index,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.code = input->code,\n\t};\n\tint ret;\n\n\tif (input->crop_support)\n\t\treturn atomisp_enum_framesizes_crop(isp, fsize);\n\n\tret = v4l2_subdev_call(input->camera, pad, enum_frame_size, NULL, &fse);\n\tif (ret)\n\t\treturn ret;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfsize->discrete.width = fse.max_width - pad_w;\n\tfsize->discrete.height = fse.max_height - pad_h;\n\n\treturn 0;\n}\n\nstatic int atomisp_enum_frameintervals(struct file *file, void *priv,\n\t\t\t\t       struct v4l2_frmivalenum *fival)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;\n\tstruct v4l2_subdev_frame_interval_enum fie = {\n\t\t.code\t= atomisp_in_fmt_conv[0].code,\n\t\t.index = fival->index,\n\t\t.width = fival->width,\n\t\t.height = fival->height,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,\n\t\t\t       pad, enum_frame_interval, NULL,\n\t\t\t       &fie);\n\tif (ret)\n\t\treturn ret;\n\n\tfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tfival->discrete = fie.interval;\n\n\treturn ret;\n}\n\nstatic int atomisp_enum_fmt_cap(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;\n\tstruct v4l2_subdev_mbus_code_enum code = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tconst struct atomisp_format_bridge *format;\n\tstruct v4l2_subdev *camera;\n\tunsigned int i, fi = 0;\n\tint rval;\n\n\tcamera = isp->inputs[asd->input_curr].camera;\n\tif(!camera) {\n\t\tdev_err(isp->dev, \"%s(): camera is NULL, device is %s\\n\",\n\t\t\t__func__, vdev->name);\n\t\treturn -EINVAL;\n\t}\n\n\trval = v4l2_subdev_call(camera, pad, enum_mbus_code, NULL, &code);\n\tif (rval == -ENOIOCTLCMD) {\n\t\tdev_warn(isp->dev,\n\t\t\t \"enum_mbus_code pad op not supported by %s. Please fix your sensor driver!\\n\",\n\t\t\t camera->name);\n\t}\n\n\tif (rval)\n\t\treturn rval;\n\n\tfor (i = 0; i < ARRAY_SIZE(atomisp_output_fmts); i++) {\n\t\tformat = &atomisp_output_fmts[i];\n\n\t\t \n\t\tif (format->sh_fmt == IA_CSS_FRAME_FORMAT_RAW)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (fi < f->index) {\n\t\t\tfi++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstrscpy(f->description, format->description,\n\t\t\tsizeof(f->description));\n\t\tf->pixelformat = format->pixelformat;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int atomisp_try_fmt_cap(struct file *file, void *fh,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\n\treturn atomisp_try_fmt(isp, &f->fmt.pix, NULL, NULL);\n}\n\nstatic int atomisp_g_fmt_cap(struct file *file, void *fh,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_video_pipe *pipe;\n\n\tpipe = atomisp_to_video_pipe(vdev);\n\n\tf->fmt.pix = pipe->pix;\n\n\t \n\tif (f->fmt.pix.sizeimage)\n\t\treturn 0;\n\n\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;\n\tf->fmt.pix.width = 10000;\n\tf->fmt.pix.height = 10000;\n\n\treturn atomisp_try_fmt_cap(file, fh, f);\n}\n\nint atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *asd,\n\t\t\t\tuint16_t stream_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct atomisp_s3a_buf *s3a_buf = NULL, *_s3a_buf;\n\tstruct atomisp_dis_buf *dis_buf = NULL, *_dis_buf;\n\tstruct atomisp_metadata_buf *md_buf = NULL, *_md_buf;\n\tint count;\n\tstruct ia_css_dvs_grid_info *dvs_grid_info =\n\t    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);\n\tunsigned int i;\n\n\tif (list_empty(&asd->s3a_stats) &&\n\t    asd->params.curr_grid_info.s3a_grid.enable) {\n\t\tcount = ATOMISP_CSS_Q_DEPTH +\n\t\t\tATOMISP_S3A_BUF_QUEUE_DEPTH_FOR_HAL;\n\t\tdev_dbg(isp->dev, \"allocating %d 3a buffers\\n\", count);\n\t\twhile (count--) {\n\t\t\ts3a_buf = kzalloc(sizeof(struct atomisp_s3a_buf), GFP_KERNEL);\n\t\t\tif (!s3a_buf)\n\t\t\t\tgoto error;\n\n\t\t\tif (atomisp_css_allocate_stat_buffers(\n\t\t\t\tasd, stream_id, s3a_buf, NULL, NULL)) {\n\t\t\t\tkfree(s3a_buf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tlist_add_tail(&s3a_buf->list, &asd->s3a_stats);\n\t\t}\n\t}\n\n\tif (list_empty(&asd->dis_stats) && dvs_grid_info &&\n\t    dvs_grid_info->enable) {\n\t\tcount = ATOMISP_CSS_Q_DEPTH + 1;\n\t\tdev_dbg(isp->dev, \"allocating %d dis buffers\\n\", count);\n\t\twhile (count--) {\n\t\t\tdis_buf = kzalloc(sizeof(struct atomisp_dis_buf), GFP_KERNEL);\n\t\t\tif (!dis_buf)\n\t\t\t\tgoto error;\n\t\t\tif (atomisp_css_allocate_stat_buffers(\n\t\t\t\tasd, stream_id, NULL, dis_buf, NULL)) {\n\t\t\t\tkfree(dis_buf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tlist_add_tail(&dis_buf->list, &asd->dis_stats);\n\t\t}\n\t}\n\n\tfor (i = 0; i < ATOMISP_METADATA_TYPE_NUM; i++) {\n\t\tif (list_empty(&asd->metadata[i]) &&\n\t\t    list_empty(&asd->metadata_ready[i]) &&\n\t\t    list_empty(&asd->metadata_in_css[i])) {\n\t\t\tcount = ATOMISP_CSS_Q_DEPTH +\n\t\t\t\tATOMISP_METADATA_QUEUE_DEPTH_FOR_HAL;\n\t\t\tdev_dbg(isp->dev, \"allocating %d metadata buffers for type %d\\n\",\n\t\t\t\tcount, i);\n\t\t\twhile (count--) {\n\t\t\t\tmd_buf = kzalloc(sizeof(struct atomisp_metadata_buf),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\t\tif (!md_buf)\n\t\t\t\t\tgoto error;\n\n\t\t\t\tif (atomisp_css_allocate_stat_buffers(\n\t\t\t\t\tasd, stream_id, NULL, NULL, md_buf)) {\n\t\t\t\t\tkfree(md_buf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tlist_add_tail(&md_buf->list, &asd->metadata[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\nerror:\n\tdev_err(isp->dev, \"failed to allocate statistics buffers\\n\");\n\n\tlist_for_each_entry_safe(dis_buf, _dis_buf, &asd->dis_stats, list) {\n\t\tatomisp_css_free_dis_buffer(dis_buf);\n\t\tlist_del(&dis_buf->list);\n\t\tkfree(dis_buf);\n\t}\n\n\tlist_for_each_entry_safe(s3a_buf, _s3a_buf, &asd->s3a_stats, list) {\n\t\tatomisp_css_free_3a_buffer(s3a_buf);\n\t\tlist_del(&s3a_buf->list);\n\t\tkfree(s3a_buf);\n\t}\n\n\tfor (i = 0; i < ATOMISP_METADATA_TYPE_NUM; i++) {\n\t\tlist_for_each_entry_safe(md_buf, _md_buf, &asd->metadata[i],\n\t\t\t\t\t list) {\n\t\t\tatomisp_css_free_metadata_buffer(md_buf);\n\t\t\tlist_del(&md_buf->list);\n\t\t\tkfree(md_buf);\n\t\t}\n\t}\n\treturn -ENOMEM;\n}\n\n \nstatic int atomisp_qbuf_wrapper(struct file *file, void *fh, struct v4l2_buffer *buf)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);\n\n\tif (buf->index >= vdev->queue->num_buffers)\n\t\treturn -EINVAL;\n\n\tif (buf->reserved2 & ATOMISP_BUFFER_HAS_PER_FRAME_SETTING) {\n\t\t \n\t\tpipe->frame_request_config_id[buf->index] = buf->reserved2 &\n\t\t\t~ATOMISP_BUFFER_HAS_PER_FRAME_SETTING;\n\t\tdev_dbg(isp->dev,\n\t\t\t\"This buffer requires per_frame setting which has isp_config_id %d\\n\",\n\t\t\tpipe->frame_request_config_id[buf->index]);\n\t} else {\n\t\tpipe->frame_request_config_id[buf->index] = 0;\n\t}\n\n\treturn vb2_ioctl_qbuf(file, fh, buf);\n}\n\nstatic int atomisp_dqbuf_wrapper(struct file *file, void *fh, struct v4l2_buffer *buf)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);\n\tstruct atomisp_sub_device *asd = pipe->asd;\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct ia_css_frame *frame;\n\tstruct vb2_buffer *vb;\n\tint ret;\n\n\tret = vb2_ioctl_dqbuf(file, fh, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tvb = pipe->vb_queue.bufs[buf->index];\n\tframe = vb_to_frame(vb);\n\n\tbuf->reserved = asd->frame_status[buf->index];\n\n\t \n\tbuf->reserved &= 0x0000ffff;\n\tif (!(buf->flags & V4L2_BUF_FLAG_ERROR))\n\t\tbuf->reserved |= frame->exp_id;\n\tbuf->reserved2 = pipe->frame_config_id[buf->index];\n\n\tdev_dbg(isp->dev,\n\t\t\"dqbuf buffer %d (%s) with exp_id %d, isp_config_id %d\\n\",\n\t\tbuf->index, vdev->name, buf->reserved >> 16, buf->reserved2);\n\treturn 0;\n}\n\n \n \n \n \nstatic void atomisp_dma_burst_len_cfg(struct atomisp_sub_device *asd)\n{\n\tstruct v4l2_mbus_framefmt *sink;\n\n\tsink = atomisp_subdev_get_ffmt(&asd->subdev, NULL,\n\t\t\t\t       V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t\t       ATOMISP_SUBDEV_PAD_SINK);\n\n\tif (sink->width * sink->height >= 4096 * 3072)\n\t\tatomisp_css2_hw_store_32(DMA_BURST_SIZE_REG, 0x7F);\n\telse\n\t\tatomisp_css2_hw_store_32(DMA_BURST_SIZE_REG, 0x00);\n}\n\nint atomisp_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct atomisp_video_pipe *pipe = vq_to_pipe(vq);\n\tstruct atomisp_sub_device *asd = pipe->asd;\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct pci_dev *pdev = to_pci_dev(isp->dev);\n\tunsigned long irqflags;\n\tint ret;\n\n\tdev_dbg(isp->dev, \"Start stream\\n\");\n\n\tmutex_lock(&isp->mutex);\n\n\tret = atomisp_pipe_check(pipe, false);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tatomisp_dma_burst_len_cfg(asd);\n\n\t \n\twbinvd();\n\n\tif (asd->params.css_update_params_needed) {\n\t\tatomisp_apply_css_parameters(asd, &asd->params.css_param);\n\t\tif (asd->params.css_param.update_flag.dz_config)\n\t\t\tasd->params.config.dz_config = &asd->params.css_param.dz_config;\n\t\tatomisp_css_update_isp_params(asd);\n\t\tasd->params.css_update_params_needed = false;\n\t\tmemset(&asd->params.css_param.update_flag, 0,\n\t\t       sizeof(struct atomisp_parameters));\n\t}\n\tasd->params.dvs_6axis = NULL;\n\n\tret = atomisp_css_start(asd);\n\tif (ret) {\n\t\tatomisp_flush_video_pipe(pipe, VB2_BUF_STATE_QUEUED, true);\n\t\tgoto out_unlock;\n\t}\n\n\tspin_lock_irqsave(&isp->lock, irqflags);\n\tasd->streaming = true;\n\tspin_unlock_irqrestore(&isp->lock, irqflags);\n\tatomic_set(&asd->sof_count, -1);\n\tatomic_set(&asd->sequence, -1);\n\tatomic_set(&asd->sequence_temp, -1);\n\n\tasd->params.dis_proj_data_valid = false;\n\tasd->latest_preview_exp_id = 0;\n\tasd->postview_exp_id = 1;\n\tasd->preview_exp_id = 1;\n\n\t \n\tatomisp_handle_parameter_and_buffer(pipe);\n\n\tatomisp_qbuffers_to_css(asd);\n\n\tif (isp->flash) {\n\t\tasd->params.num_flash_frames = 0;\n\t\tasd->params.flash_state = ATOMISP_FLASH_IDLE;\n\t\tatomisp_setup_flash(asd);\n\t}\n\n\tatomisp_css_irq_enable(isp, IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF,\n\t\t\t       atomisp_css_valid_sof(isp));\n\tatomisp_csi2_configure(asd);\n\n\tif (atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_AUTO, false) < 0)\n\t\tdev_dbg(isp->dev, \"DFS auto mode failed!\\n\");\n\n\t \n\tif (isp->media_dev.hw_revision >= ((ATOMISP_HW_REVISION_ISP2401 <<\n\t\t\t\t\t    ATOMISP_HW_REVISION_SHIFT) | ATOMISP_HW_STEPPING_B0)) {\n\t\tpci_write_config_word(pdev, MRFLD_PCI_CSI_CONTROL,\n\t\t\t\t      isp->saved_regs.csi_control | MRFLD_PCI_CSI_CONTROL_CSI_READY);\n\t}\n\n\t \n\tret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,\n\t\t\t       video, s_stream, 1);\n\tif (ret) {\n\t\tdev_err(isp->dev, \"Starting sensor stream failed: %d\\n\", ret);\n\t\tspin_lock_irqsave(&isp->lock, irqflags);\n\t\tasd->streaming = false;\n\t\tspin_unlock_irqrestore(&isp->lock, irqflags);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&isp->mutex);\n\treturn ret;\n}\n\nvoid atomisp_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct atomisp_video_pipe *pipe = vq_to_pipe(vq);\n\tstruct atomisp_sub_device *asd = pipe->asd;\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct pci_dev *pdev = to_pci_dev(isp->dev);\n\tunsigned long flags;\n\tint ret;\n\n\tdev_dbg(isp->dev, \"Stop stream\\n\");\n\n\tmutex_lock(&isp->mutex);\n\t \n\tpipe->stopping = true;\n\tmutex_unlock(&isp->mutex);\n\t \n\tret = wait_event_timeout(pipe->vb_queue.done_wq,\n\t\t\t\t atomisp_buffers_in_css(pipe) == 0, HZ);\n\tmutex_lock(&isp->mutex);\n\tpipe->stopping = false;\n\tif (ret == 0)\n\t\tdev_warn(isp->dev, \"Warning timeout waiting for CSS to return buffers\\n\");\n\n\tspin_lock_irqsave(&isp->lock, flags);\n\tasd->streaming = false;\n\tspin_unlock_irqrestore(&isp->lock, flags);\n\n\tatomisp_clear_css_buffer_counters(asd);\n\tatomisp_css_irq_enable(isp, IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF, false);\n\n\tatomisp_css_stop(asd, false);\n\n\tatomisp_flush_video_pipe(pipe, VB2_BUF_STATE_ERROR, true);\n\n\tatomisp_subdev_cleanup_pending_events(asd);\n\n\tret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,\n\t\t\t       video, s_stream, 0);\n\tif (ret)\n\t\tdev_warn(isp->dev, \"Stopping sensor stream failed: %d\\n\", ret);\n\n\tif (isp->flash) {\n\t\tasd->params.num_flash_frames = 0;\n\t\tasd->params.flash_state = ATOMISP_FLASH_IDLE;\n\t}\n\n\t \n\tif (isp->media_dev.hw_revision >= ((ATOMISP_HW_REVISION_ISP2401 <<\n\t\t\t\t\t    ATOMISP_HW_REVISION_SHIFT) | ATOMISP_HW_STEPPING_B0)) {\n\t\tpci_write_config_word(pdev, MRFLD_PCI_CSI_CONTROL,\n\t\t\t\t      isp->saved_regs.csi_control & ~MRFLD_PCI_CSI_CONTROL_CSI_READY);\n\t}\n\n\tif (atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW, false))\n\t\tdev_warn(isp->dev, \"DFS failed.\\n\");\n\n\t \n\tpci_write_config_dword(pdev, PCI_I_CONTROL,\n\t\t\t       isp->saved_regs.i_control | MRFLD_PCI_I_CONTROL_SRSE_RESET_MASK);\n\tatomisp_reset(isp);\n\n\t \n\tret = atomisp_create_pipes_stream(&isp->asd);\n\tif (ret)\n\t\tdev_warn(isp->dev, \"Recreating streams failed: %d\\n\", ret);\n\n\tmutex_unlock(&isp->mutex);\n}\n\n \nstatic int atomisp_g_ctrl(struct file *file, void *fh,\n\t\t\t  struct v4l2_control *control)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tint i, ret = -EINVAL;\n\n\tfor (i = 0; i < ctrls_num; i++) {\n\t\tif (ci_v4l2_controls[i].id == control->id) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (control->id) {\n\tcase V4L2_CID_IRIS_ABSOLUTE:\n\tcase V4L2_CID_EXPOSURE_ABSOLUTE:\n\tcase V4L2_CID_2A_STATUS:\n\tcase V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:\n\tcase V4L2_CID_EXPOSURE:\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\tcase V4L2_CID_SCENE_MODE:\n\tcase V4L2_CID_ISO_SENSITIVITY:\n\tcase V4L2_CID_ISO_SENSITIVITY_AUTO:\n\tcase V4L2_CID_CONTRAST:\n\tcase V4L2_CID_SATURATION:\n\tcase V4L2_CID_SHARPNESS:\n\tcase V4L2_CID_3A_LOCK:\n\tcase V4L2_CID_EXPOSURE_ZONE_NUM:\n\tcase V4L2_CID_TEST_PATTERN:\n\tcase V4L2_CID_TEST_PATTERN_COLOR_R:\n\tcase V4L2_CID_TEST_PATTERN_COLOR_GR:\n\tcase V4L2_CID_TEST_PATTERN_COLOR_GB:\n\tcase V4L2_CID_TEST_PATTERN_COLOR_B:\n\t\treturn v4l2_g_ctrl(isp->inputs[asd->input_curr].camera->\n\t\t\t\t   ctrl_handler, control);\n\tcase V4L2_CID_COLORFX:\n\t\tret = atomisp_color_effect(asd, 0, &control->value);\n\t\tbreak;\n\tcase V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION:\n\t\tret = atomisp_bad_pixel(asd, 0, &control->value);\n\t\tbreak;\n\tcase V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC:\n\t\tret = atomisp_gdc_cac(asd, 0, &control->value);\n\t\tbreak;\n\tcase V4L2_CID_ATOMISP_VIDEO_STABLIZATION:\n\t\tret = atomisp_video_stable(asd, 0, &control->value);\n\t\tbreak;\n\tcase V4L2_CID_ATOMISP_FIXED_PATTERN_NR:\n\t\tret = atomisp_fixed_pattern(asd, 0, &control->value);\n\t\tbreak;\n\tcase V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION:\n\t\tret = atomisp_false_color(asd, 0, &control->value);\n\t\tbreak;\n\tcase V4L2_CID_ATOMISP_LOW_LIGHT:\n\t\tret = atomisp_low_light(asd, 0, &control->value);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int atomisp_s_ctrl(struct file *file, void *fh,\n\t\t\t  struct v4l2_control *control)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tint i, ret = -EINVAL;\n\n\tfor (i = 0; i < ctrls_num; i++) {\n\t\tif (ci_v4l2_controls[i].id == control->id) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (control->id) {\n\tcase V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:\n\tcase V4L2_CID_EXPOSURE:\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\tcase V4L2_CID_EXPOSURE_AUTO_PRIORITY:\n\tcase V4L2_CID_SCENE_MODE:\n\tcase V4L2_CID_ISO_SENSITIVITY:\n\tcase V4L2_CID_ISO_SENSITIVITY_AUTO:\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\tcase V4L2_CID_EXPOSURE_METERING:\n\tcase V4L2_CID_CONTRAST:\n\tcase V4L2_CID_SATURATION:\n\tcase V4L2_CID_SHARPNESS:\n\tcase V4L2_CID_3A_LOCK:\n\tcase V4L2_CID_COLORFX_CBCR:\n\tcase V4L2_CID_TEST_PATTERN:\n\tcase V4L2_CID_TEST_PATTERN_COLOR_R:\n\tcase V4L2_CID_TEST_PATTERN_COLOR_GR:\n\tcase V4L2_CID_TEST_PATTERN_COLOR_GB:\n\tcase V4L2_CID_TEST_PATTERN_COLOR_B:\n\t\treturn v4l2_s_ctrl(NULL,\n\t\t\t\t   isp->inputs[asd->input_curr].camera->\n\t\t\t\t   ctrl_handler, control);\n\tcase V4L2_CID_COLORFX:\n\t\tret = atomisp_color_effect(asd, 1, &control->value);\n\t\tbreak;\n\tcase V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION:\n\t\tret = atomisp_bad_pixel(asd, 1, &control->value);\n\t\tbreak;\n\tcase V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC:\n\t\tret = atomisp_gdc_cac(asd, 1, &control->value);\n\t\tbreak;\n\tcase V4L2_CID_ATOMISP_VIDEO_STABLIZATION:\n\t\tret = atomisp_video_stable(asd, 1, &control->value);\n\t\tbreak;\n\tcase V4L2_CID_ATOMISP_FIXED_PATTERN_NR:\n\t\tret = atomisp_fixed_pattern(asd, 1, &control->value);\n\t\tbreak;\n\tcase V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION:\n\t\tret = atomisp_false_color(asd, 1, &control->value);\n\t\tbreak;\n\tcase V4L2_CID_REQUEST_FLASH:\n\t\tret = atomisp_flash_enable(asd, control->value);\n\t\tbreak;\n\tcase V4L2_CID_ATOMISP_LOW_LIGHT:\n\t\tret = atomisp_low_light(asd, 1, &control->value);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic int atomisp_queryctl(struct file *file, void *fh,\n\t\t\t    struct v4l2_queryctrl *qc)\n{\n\tint i, ret = -EINVAL;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\n\tswitch (qc->id) {\n\tcase V4L2_CID_FOCUS_ABSOLUTE:\n\tcase V4L2_CID_FOCUS_RELATIVE:\n\tcase V4L2_CID_FOCUS_STATUS:\n\t\tif (!IS_ISP2401) {\n\t\t\treturn v4l2_queryctrl(isp->inputs[asd->input_curr].camera->\n\t\t\t\t\t    ctrl_handler, qc);\n\t\t}\n\t\t \n\t\tif (isp->motor)\n\t\t\treturn v4l2_queryctrl(isp->motor->ctrl_handler, qc);\n\t\telse\n\t\t\treturn v4l2_queryctrl(isp->inputs[asd->input_curr].\n\t\t\t\t\t      camera->ctrl_handler, qc);\n\t}\n\n\tif (qc->id & V4L2_CTRL_FLAG_NEXT_CTRL)\n\t\treturn ret;\n\n\tfor (i = 0; i < ctrls_num; i++) {\n\t\tif (ci_v4l2_controls[i].id == qc->id) {\n\t\t\tmemcpy(qc, &ci_v4l2_controls[i],\n\t\t\t       sizeof(struct v4l2_queryctrl));\n\t\t\tqc->reserved[0] = 0;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret != 0)\n\t\tqc->flags = V4L2_CTRL_FLAG_DISABLED;\n\n\treturn ret;\n}\n\nstatic int atomisp_camera_g_ext_ctrls(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_ext_controls *c)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct v4l2_subdev *motor;\n\tstruct v4l2_control ctrl;\n\tint i;\n\tint ret = 0;\n\n\tif (!IS_ISP2401)\n\t\tmotor = isp->inputs[asd->input_curr].motor;\n\telse\n\t\tmotor = isp->motor;\n\n\tfor (i = 0; i < c->count; i++) {\n\t\tctrl.id = c->controls[i].id;\n\t\tctrl.value = c->controls[i].value;\n\t\tswitch (ctrl.id) {\n\t\tcase V4L2_CID_EXPOSURE_ABSOLUTE:\n\t\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tcase V4L2_CID_IRIS_ABSOLUTE:\n\t\tcase V4L2_CID_3A_LOCK:\n\t\tcase V4L2_CID_TEST_PATTERN:\n\t\tcase V4L2_CID_TEST_PATTERN_COLOR_R:\n\t\tcase V4L2_CID_TEST_PATTERN_COLOR_GR:\n\t\tcase V4L2_CID_TEST_PATTERN_COLOR_GB:\n\t\tcase V4L2_CID_TEST_PATTERN_COLOR_B:\n\t\t\t \n\t\t\tret =\n\t\t\t    v4l2_g_ctrl(isp->inputs[asd->input_curr].camera->\n\t\t\t\t\tctrl_handler, &ctrl);\n\t\t\tbreak;\n\t\tcase V4L2_CID_FOCUS_ABSOLUTE:\n\t\tcase V4L2_CID_FOCUS_RELATIVE:\n\t\tcase V4L2_CID_FOCUS_STATUS:\n\t\tcase V4L2_CID_FOCUS_AUTO:\n\t\t\tif (motor)\n\t\t\t\tret = v4l2_g_ctrl(motor->ctrl_handler, &ctrl);\n\t\t\tbreak;\n\t\tcase V4L2_CID_FLASH_STATUS:\n\t\tcase V4L2_CID_FLASH_INTENSITY:\n\t\tcase V4L2_CID_FLASH_TORCH_INTENSITY:\n\t\tcase V4L2_CID_FLASH_INDICATOR_INTENSITY:\n\t\tcase V4L2_CID_FLASH_TIMEOUT:\n\t\tcase V4L2_CID_FLASH_STROBE:\n\t\tcase V4L2_CID_FLASH_MODE:\n\t\tcase V4L2_CID_FLASH_STATUS_REGISTER:\n\t\t\tif (isp->flash)\n\t\t\t\tret =\n\t\t\t\t    v4l2_g_ctrl(isp->flash->ctrl_handler,\n\t\t\t\t\t\t&ctrl);\n\t\t\tbreak;\n\t\tcase V4L2_CID_ZOOM_ABSOLUTE:\n\t\t\tret = atomisp_digital_zoom(asd, 0, &ctrl.value);\n\t\t\tbreak;\n\t\tcase V4L2_CID_G_SKIP_FRAMES:\n\t\t\tret = v4l2_subdev_call(\n\t\t\t\t  isp->inputs[asd->input_curr].camera,\n\t\t\t\t  sensor, g_skip_frames, (u32 *)&ctrl.value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tc->error_idx = i;\n\t\t\tbreak;\n\t\t}\n\t\tc->controls[i].value = ctrl.value;\n\t}\n\treturn ret;\n}\n\n \nstatic int atomisp_g_ext_ctrls(struct file *file, void *fh,\n\t\t\t       struct v4l2_ext_controls *c)\n{\n\tstruct v4l2_control ctrl;\n\tint i, ret = 0;\n\n\t \n\tret = atomisp_camera_g_ext_ctrls(file, fh, c);\n\tif (ret != -EINVAL)\n\t\treturn ret;\n\n\tfor (i = 0; i < c->count; i++) {\n\t\tctrl.id = c->controls[i].id;\n\t\tctrl.value = c->controls[i].value;\n\t\tret = atomisp_g_ctrl(file, fh, &ctrl);\n\t\tc->controls[i].value = ctrl.value;\n\t\tif (ret) {\n\t\t\tc->error_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int atomisp_camera_s_ext_ctrls(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_ext_controls *c)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct v4l2_subdev *motor;\n\tstruct v4l2_control ctrl;\n\tint i;\n\tint ret = 0;\n\n\tif (!IS_ISP2401)\n\t\tmotor = isp->inputs[asd->input_curr].motor;\n\telse\n\t\tmotor = isp->motor;\n\n\tfor (i = 0; i < c->count; i++) {\n\t\tstruct v4l2_ctrl *ctr;\n\n\t\tctrl.id = c->controls[i].id;\n\t\tctrl.value = c->controls[i].value;\n\t\tswitch (ctrl.id) {\n\t\tcase V4L2_CID_EXPOSURE_ABSOLUTE:\n\t\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tcase V4L2_CID_EXPOSURE_METERING:\n\t\tcase V4L2_CID_IRIS_ABSOLUTE:\n\t\tcase V4L2_CID_VCM_TIMING:\n\t\tcase V4L2_CID_VCM_SLEW:\n\t\tcase V4L2_CID_3A_LOCK:\n\t\tcase V4L2_CID_TEST_PATTERN:\n\t\tcase V4L2_CID_TEST_PATTERN_COLOR_R:\n\t\tcase V4L2_CID_TEST_PATTERN_COLOR_GR:\n\t\tcase V4L2_CID_TEST_PATTERN_COLOR_GB:\n\t\tcase V4L2_CID_TEST_PATTERN_COLOR_B:\n\t\t\tret = v4l2_s_ctrl(NULL,\n\t\t\t\t\t  isp->inputs[asd->input_curr].camera->\n\t\t\t\t\t  ctrl_handler, &ctrl);\n\t\t\tbreak;\n\t\tcase V4L2_CID_FOCUS_ABSOLUTE:\n\t\tcase V4L2_CID_FOCUS_RELATIVE:\n\t\tcase V4L2_CID_FOCUS_STATUS:\n\t\tcase V4L2_CID_FOCUS_AUTO:\n\t\t\tif (motor)\n\t\t\t\tret = v4l2_s_ctrl(NULL, motor->ctrl_handler,\n\t\t\t\t\t\t  &ctrl);\n\t\t\telse\n\t\t\t\tret = v4l2_s_ctrl(NULL,\n\t\t\t\t\t\t  isp->inputs[asd->input_curr].\n\t\t\t\t\t\t  camera->ctrl_handler, &ctrl);\n\t\t\tbreak;\n\t\tcase V4L2_CID_FLASH_STATUS:\n\t\tcase V4L2_CID_FLASH_INTENSITY:\n\t\tcase V4L2_CID_FLASH_TORCH_INTENSITY:\n\t\tcase V4L2_CID_FLASH_INDICATOR_INTENSITY:\n\t\tcase V4L2_CID_FLASH_TIMEOUT:\n\t\tcase V4L2_CID_FLASH_STROBE:\n\t\tcase V4L2_CID_FLASH_MODE:\n\t\tcase V4L2_CID_FLASH_STATUS_REGISTER:\n\t\t\tif (isp->flash) {\n\t\t\t\tret =\n\t\t\t\t    v4l2_s_ctrl(NULL, isp->flash->ctrl_handler,\n\t\t\t\t\t\t&ctrl);\n\t\t\t\t \n\t\t\t\tif (ctrl.id == V4L2_CID_FLASH_MODE) {\n\t\t\t\t\tasd->params.flash_state =\n\t\t\t\t\t    ATOMISP_FLASH_IDLE;\n\t\t\t\t\tasd->params.num_flash_frames = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_CID_ZOOM_ABSOLUTE:\n\t\t\tret = atomisp_digital_zoom(asd, 1, &ctrl.value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tctr = v4l2_ctrl_find(&asd->ctrl_handler, ctrl.id);\n\t\t\tif (ctr)\n\t\t\t\tret = v4l2_ctrl_s_ctrl(ctr, ctrl.value);\n\t\t\telse\n\t\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tc->error_idx = i;\n\t\t\tbreak;\n\t\t}\n\t\tc->controls[i].value = ctrl.value;\n\t}\n\treturn ret;\n}\n\n \nstatic int atomisp_s_ext_ctrls(struct file *file, void *fh,\n\t\t\t       struct v4l2_ext_controls *c)\n{\n\tstruct v4l2_control ctrl;\n\tint i, ret = 0;\n\n\t \n\tret = atomisp_camera_s_ext_ctrls(file, fh, c);\n\tif (ret != -EINVAL)\n\t\treturn ret;\n\n\tfor (i = 0; i < c->count; i++) {\n\t\tctrl.id = c->controls[i].id;\n\t\tctrl.value = c->controls[i].value;\n\t\tret = atomisp_s_ctrl(file, fh, &ctrl);\n\t\tc->controls[i].value = ctrl.value;\n\t\tif (ret) {\n\t\t\tc->error_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstatic int atomisp_g_parm(struct file *file, void *fh,\n\t\t\t  struct v4l2_streamparm *parm)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\n\tif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tdev_err(isp->dev, \"unsupported v4l2 buf type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tparm->parm.capture.capturemode = asd->run_mode->val;\n\n\treturn 0;\n}\n\nstatic int atomisp_s_parm(struct file *file, void *fh,\n\t\t\t  struct v4l2_streamparm *parm)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;\n\tint mode;\n\tint rval;\n\tint fps;\n\n\tif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tdev_err(isp->dev, \"unsupported v4l2 buf type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tasd->high_speed_mode = false;\n\tswitch (parm->parm.capture.capturemode) {\n\tcase CI_MODE_NONE: {\n\t\tstruct v4l2_subdev_frame_interval fi = {0};\n\n\t\tfi.interval = parm->parm.capture.timeperframe;\n\n\t\trval = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,\n\t\t\t\t\tvideo, s_frame_interval, &fi);\n\t\tif (!rval)\n\t\t\tparm->parm.capture.timeperframe = fi.interval;\n\n\t\tif (fi.interval.numerator != 0) {\n\t\t\tfps = fi.interval.denominator / fi.interval.numerator;\n\t\t\tif (fps > 30)\n\t\t\t\tasd->high_speed_mode = true;\n\t\t}\n\n\t\treturn rval == -ENOIOCTLCMD ? 0 : rval;\n\t}\n\tcase CI_MODE_VIDEO:\n\t\tmode = ATOMISP_RUN_MODE_VIDEO;\n\t\tbreak;\n\tcase CI_MODE_STILL_CAPTURE:\n\t\tmode = ATOMISP_RUN_MODE_STILL_CAPTURE;\n\t\tbreak;\n\tcase CI_MODE_PREVIEW:\n\t\tmode = ATOMISP_RUN_MODE_PREVIEW;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trval = v4l2_ctrl_s_ctrl(asd->run_mode, mode);\n\n\treturn rval == -ENOIOCTLCMD ? 0 : rval;\n}\n\nstatic long atomisp_vidioc_default(struct file *file, void *fh,\n\t\t\t\t   bool valid_prio, unsigned int cmd, void *arg)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;\n\tint err;\n\n\tswitch (cmd) {\n\tcase ATOMISP_IOC_S_SENSOR_RUNMODE:\n\t\tif (IS_ISP2401)\n\t\t\terr = atomisp_set_sensor_runmode(asd, arg);\n\t\telse\n\t\t\terr = -EINVAL;\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_XNR:\n\t\terr = atomisp_xnr(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_XNR:\n\t\terr = atomisp_xnr(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_NR:\n\t\terr = atomisp_nr(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_NR:\n\t\terr = atomisp_nr(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_TNR:\n\t\terr = atomisp_tnr(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_TNR:\n\t\terr = atomisp_tnr(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_BLACK_LEVEL_COMP:\n\t\terr = atomisp_black_level(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_BLACK_LEVEL_COMP:\n\t\terr = atomisp_black_level(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_EE:\n\t\terr = atomisp_ee(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_EE:\n\t\terr = atomisp_ee(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_DIS_STAT:\n\t\terr = atomisp_get_dis_stat(asd, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_DVS2_BQ_RESOLUTIONS:\n\t\terr = atomisp_get_dvs2_bq_resolutions(asd, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_DIS_COEFS:\n\t\terr = atomisp_css_cp_dvs2_coefs(asd, arg,\n\t\t\t\t\t\t&asd->params.css_param, true);\n\t\tif (!err && arg)\n\t\t\tasd->params.css_update_params_needed = true;\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_DIS_VECTOR:\n\t\terr = atomisp_cp_dvs_6axis_config(asd, arg,\n\t\t\t\t\t\t  &asd->params.css_param, true);\n\t\tif (!err && arg)\n\t\t\tasd->params.css_update_params_needed = true;\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_ISP_PARM:\n\t\terr = atomisp_param(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_ISP_PARM:\n\t\terr = atomisp_param(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_3A_STAT:\n\t\terr = atomisp_3a_stat(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_ISP_GAMMA:\n\t\terr = atomisp_gamma(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_ISP_GAMMA:\n\t\terr = atomisp_gamma(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_ISP_GDC_TAB:\n\t\terr = atomisp_gdc_cac_table(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_ISP_GDC_TAB:\n\t\terr = atomisp_gdc_cac_table(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_ISP_MACC:\n\t\terr = atomisp_macc_table(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_ISP_MACC:\n\t\terr = atomisp_macc_table(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_ISP_BAD_PIXEL_DETECTION:\n\t\terr = atomisp_bad_pixel_param(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_ISP_BAD_PIXEL_DETECTION:\n\t\terr = atomisp_bad_pixel_param(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_ISP_FALSE_COLOR_CORRECTION:\n\t\terr = atomisp_false_color_param(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_ISP_FALSE_COLOR_CORRECTION:\n\t\terr = atomisp_false_color_param(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_ISP_CTC:\n\t\terr = atomisp_ctc(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_ISP_CTC:\n\t\terr = atomisp_ctc(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_ISP_WHITE_BALANCE:\n\t\terr = atomisp_white_balance_param(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_ISP_WHITE_BALANCE:\n\t\terr = atomisp_white_balance_param(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_3A_CONFIG:\n\t\terr = atomisp_3a_config_param(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_3A_CONFIG:\n\t\terr = atomisp_3a_config_param(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_ISP_FPN_TABLE:\n\t\terr = atomisp_fixed_pattern_table(asd, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_EXPOSURE:\n\t\terr = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,\n\t\t\t\t       core, ioctl, cmd, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_ISP_SHD_TAB:\n\t\terr = atomisp_set_shading_table(asd, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_G_ISP_GAMMA_CORRECTION:\n\t\terr = atomisp_gamma_correction(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_ISP_GAMMA_CORRECTION:\n\t\terr = atomisp_gamma_correction(asd, 1, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_PARAMETERS:\n\t\terr = atomisp_set_parameters(vdev, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_EXT_ISP_CTRL:\n\t\terr = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,\n\t\t\t\t       core, ioctl, cmd, arg);\n\t\tbreak;\n\tcase ATOMISP_IOC_EXP_ID_UNLOCK:\n\t\terr = atomisp_exp_id_unlock(asd, arg);\n\t\tbreak;\n\tcase ATOMISP_IOC_EXP_ID_CAPTURE:\n\t\terr = atomisp_exp_id_capture(asd, arg);\n\t\tbreak;\n\tcase ATOMISP_IOC_S_ENABLE_DZ_CAPT_PIPE:\n\t\terr = atomisp_enable_dz_capt_pipe(asd, arg);\n\t\tbreak;\n\tcase ATOMISP_IOC_G_FORMATS_CONFIG:\n\t\terr = atomisp_formats(asd, 0, arg);\n\t\tbreak;\n\n\tcase ATOMISP_IOC_S_FORMATS_CONFIG:\n\t\terr = atomisp_formats(asd, 1, arg);\n\t\tbreak;\n\tcase ATOMISP_IOC_INJECT_A_FAKE_EVENT:\n\t\terr = atomisp_inject_a_fake_event(asd, arg);\n\t\tbreak;\n\tcase ATOMISP_IOC_S_ARRAY_RESOLUTION:\n\t\terr = atomisp_set_array_res(asd, arg);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nconst struct v4l2_ioctl_ops atomisp_ioctl_ops = {\n\t.vidioc_querycap = atomisp_querycap,\n\t.vidioc_enum_input = atomisp_enum_input,\n\t.vidioc_g_input = atomisp_g_input,\n\t.vidioc_s_input = atomisp_s_input,\n\t.vidioc_queryctrl = atomisp_queryctl,\n\t.vidioc_s_ctrl = atomisp_s_ctrl,\n\t.vidioc_g_ctrl = atomisp_g_ctrl,\n\t.vidioc_s_ext_ctrls = atomisp_s_ext_ctrls,\n\t.vidioc_g_ext_ctrls = atomisp_g_ext_ctrls,\n\t.vidioc_enum_framesizes   = atomisp_enum_framesizes,\n\t.vidioc_enum_frameintervals = atomisp_enum_frameintervals,\n\t.vidioc_enum_fmt_vid_cap = atomisp_enum_fmt_cap,\n\t.vidioc_try_fmt_vid_cap = atomisp_try_fmt_cap,\n\t.vidioc_g_fmt_vid_cap = atomisp_g_fmt_cap,\n\t.vidioc_s_fmt_vid_cap = atomisp_s_fmt_cap,\n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_qbuf = atomisp_qbuf_wrapper,\n\t.vidioc_dqbuf = atomisp_dqbuf_wrapper,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n\t.vidioc_default = atomisp_vidioc_default,\n\t.vidioc_s_parm = atomisp_s_parm,\n\t.vidioc_g_parm = atomisp_g_parm,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}