{
  "module_name": "atomisp_compat_css20.c",
  "hash_id": "a35c127f74b73004e93bd6e1d0ba587bb7fdf69d5c719f5c605e39e4f8e8a0ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/atomisp_compat_css20.c",
  "human_readable_source": "\n \n\n#include <media/videobuf-vmalloc.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-event.h>\n\n#include \"mmu/isp_mmu.h\"\n#include \"mmu/sh_mmu_mrfld.h\"\n#include \"hmm/hmm_bo.h\"\n#include \"hmm/hmm.h\"\n\n#include \"atomisp_compat.h\"\n#include \"atomisp_internal.h\"\n#include \"atomisp_cmd.h\"\n#include \"atomisp-regs.h\"\n#include \"atomisp_fops.h\"\n#include \"atomisp_ioctl.h\"\n\n#include \"ia_css_debug.h\"\n#include \"ia_css_isp_param.h\"\n#include \"sh_css_hrt.h\"\n#include \"ia_css_isys.h\"\n\n#include <linux/io.h>\n#include <linux/pm_runtime.h>\n\n \n#define MAX_ACC_STAGES\t20\n\n \n#define NO_LINK -1\n\n \nstatic DEFINE_SPINLOCK(mmio_lock);\n\nenum frame_info_type {\n\tATOMISP_CSS_VF_FRAME,\n\tATOMISP_CSS_SECOND_VF_FRAME,\n\tATOMISP_CSS_OUTPUT_FRAME,\n\tATOMISP_CSS_SECOND_OUTPUT_FRAME,\n\tATOMISP_CSS_RAW_FRAME,\n};\n\nstruct bayer_ds_factor {\n\tunsigned int numerator;\n\tunsigned int denominator;\n};\n\nstatic void atomisp_css2_hw_store_8(hrt_address addr, uint8_t data)\n{\n\tstruct atomisp_device *isp = dev_get_drvdata(atomisp_dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mmio_lock, flags);\n\twriteb(data, isp->base + (addr & 0x003FFFFF));\n\tspin_unlock_irqrestore(&mmio_lock, flags);\n}\n\nstatic void atomisp_css2_hw_store_16(hrt_address addr, uint16_t data)\n{\n\tstruct atomisp_device *isp = dev_get_drvdata(atomisp_dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mmio_lock, flags);\n\twritew(data, isp->base + (addr & 0x003FFFFF));\n\tspin_unlock_irqrestore(&mmio_lock, flags);\n}\n\nvoid atomisp_css2_hw_store_32(hrt_address addr, uint32_t data)\n{\n\tstruct atomisp_device *isp = dev_get_drvdata(atomisp_dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mmio_lock, flags);\n\twritel(data, isp->base + (addr & 0x003FFFFF));\n\tspin_unlock_irqrestore(&mmio_lock, flags);\n}\n\nstatic uint8_t atomisp_css2_hw_load_8(hrt_address addr)\n{\n\tstruct atomisp_device *isp = dev_get_drvdata(atomisp_dev);\n\tunsigned long flags;\n\tu8 ret;\n\n\tspin_lock_irqsave(&mmio_lock, flags);\n\tret = readb(isp->base + (addr & 0x003FFFFF));\n\tspin_unlock_irqrestore(&mmio_lock, flags);\n\treturn ret;\n}\n\nstatic uint16_t atomisp_css2_hw_load_16(hrt_address addr)\n{\n\tstruct atomisp_device *isp = dev_get_drvdata(atomisp_dev);\n\tunsigned long flags;\n\tu16 ret;\n\n\tspin_lock_irqsave(&mmio_lock, flags);\n\tret = readw(isp->base + (addr & 0x003FFFFF));\n\tspin_unlock_irqrestore(&mmio_lock, flags);\n\treturn ret;\n}\n\nstatic uint32_t atomisp_css2_hw_load_32(hrt_address addr)\n{\n\tstruct atomisp_device *isp = dev_get_drvdata(atomisp_dev);\n\tunsigned long flags;\n\tu32 ret;\n\n\tspin_lock_irqsave(&mmio_lock, flags);\n\tret = readl(isp->base + (addr & 0x003FFFFF));\n\tspin_unlock_irqrestore(&mmio_lock, flags);\n\treturn ret;\n}\n\nstatic void atomisp_css2_hw_store(hrt_address addr, const void *from, uint32_t n)\n{\n\tstruct atomisp_device *isp = dev_get_drvdata(atomisp_dev);\n\tunsigned long flags;\n\tunsigned int i;\n\n\taddr &= 0x003FFFFF;\n\tspin_lock_irqsave(&mmio_lock, flags);\n\tfor (i = 0; i < n; i++, from++)\n\t\twriteb(*(s8 *)from, isp->base + addr + i);\n\n\tspin_unlock_irqrestore(&mmio_lock, flags);\n}\n\nstatic void atomisp_css2_hw_load(hrt_address addr, void *to, uint32_t n)\n{\n\tstruct atomisp_device *isp = dev_get_drvdata(atomisp_dev);\n\tunsigned long flags;\n\tunsigned int i;\n\n\taddr &= 0x003FFFFF;\n\tspin_lock_irqsave(&mmio_lock, flags);\n\tfor (i = 0; i < n; i++, to++)\n\t\t*(s8 *)to = readb(isp->base + addr + i);\n\tspin_unlock_irqrestore(&mmio_lock, flags);\n}\n\nstatic int  __printf(1, 0) atomisp_vprintk(const char *fmt, va_list args)\n{\n\tvprintk(fmt, args);\n\treturn 0;\n}\n\nvoid atomisp_load_uint32(hrt_address addr, uint32_t *data)\n{\n\t*data = atomisp_css2_hw_load_32(addr);\n}\n\nstatic int hmm_get_mmu_base_addr(struct device *dev, unsigned int *mmu_base_addr)\n{\n\tif (!sh_mmu_mrfld.get_pd_base) {\n\t\tdev_err(dev, \"get mmu base address failed.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*mmu_base_addr = sh_mmu_mrfld.get_pd_base(&bo_device.mmu,\n\t\t\t bo_device.mmu.base_address);\n\treturn 0;\n}\n\nstatic void __dump_pipe_config(struct atomisp_sub_device *asd,\n\t\t\t       struct atomisp_stream_env *stream_env,\n\t\t\t       unsigned int pipe_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (stream_env->pipes[pipe_id]) {\n\t\tstruct ia_css_pipe_config *p_config;\n\t\tstruct ia_css_pipe_extra_config *pe_config;\n\n\t\tp_config = &stream_env->pipe_configs[pipe_id];\n\t\tpe_config = &stream_env->pipe_extra_configs[pipe_id];\n\t\tdev_dbg(isp->dev, \"dumping pipe[%d] config:\\n\", pipe_id);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_config.pipe_mode:%d.\\n\", p_config->mode);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_config.output_info[0] w=%d, h=%d.\\n\",\n\t\t\tp_config->output_info[0].res.width,\n\t\t\tp_config->output_info[0].res.height);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_config.vf_pp_in_res w=%d, h=%d.\\n\",\n\t\t\tp_config->vf_pp_in_res.width,\n\t\t\tp_config->vf_pp_in_res.height);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_config.capt_pp_in_res w=%d, h=%d.\\n\",\n\t\t\tp_config->capt_pp_in_res.width,\n\t\t\tp_config->capt_pp_in_res.height);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_config.output.padded w=%d.\\n\",\n\t\t\tp_config->output_info[0].padded_width);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_config.vf_output_info[0] w=%d, h=%d.\\n\",\n\t\t\tp_config->vf_output_info[0].res.width,\n\t\t\tp_config->vf_output_info[0].res.height);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_config.bayer_ds_out_res w=%d, h=%d.\\n\",\n\t\t\tp_config->bayer_ds_out_res.width,\n\t\t\tp_config->bayer_ds_out_res.height);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_config.envelope w=%d, h=%d.\\n\",\n\t\t\tp_config->dvs_envelope.width,\n\t\t\tp_config->dvs_envelope.height);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_config.dvs_frame_delay=%d.\\n\",\n\t\t\tp_config->dvs_frame_delay);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_config.isp_pipe_version:%d.\\n\",\n\t\t\tp_config->isp_pipe_version);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_config.default_capture_config.capture_mode=%d.\\n\",\n\t\t\tp_config->default_capture_config.mode);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_config.enable_dz=%d.\\n\",\n\t\t\tp_config->enable_dz);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_config.default_capture_config.enable_xnr=%d.\\n\",\n\t\t\tp_config->default_capture_config.enable_xnr);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"dumping pipe[%d] extra config:\\n\", pipe_id);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_extra_config.enable_raw_binning:%d.\\n\",\n\t\t\tpe_config->enable_raw_binning);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_extra_config.enable_yuv_ds:%d.\\n\",\n\t\t\tpe_config->enable_yuv_ds);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_extra_config.enable_high_speed:%d.\\n\",\n\t\t\tpe_config->enable_high_speed);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_extra_config.enable_dvs_6axis:%d.\\n\",\n\t\t\tpe_config->enable_dvs_6axis);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_extra_config.enable_reduced_pipe:%d.\\n\",\n\t\t\tpe_config->enable_reduced_pipe);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_(extra_)config.enable_dz:%d.\\n\",\n\t\t\tp_config->enable_dz);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"pipe_extra_config.disable_vf_pp:%d.\\n\",\n\t\t\tpe_config->disable_vf_pp);\n\t}\n}\n\nstatic void __dump_stream_config(struct atomisp_sub_device *asd,\n\t\t\t\t struct atomisp_stream_env *stream_env)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct ia_css_stream_config *s_config;\n\tint j;\n\tbool valid_stream = false;\n\n\tfor (j = 0; j < IA_CSS_PIPE_ID_NUM; j++) {\n\t\tif (stream_env->pipes[j]) {\n\t\t\t__dump_pipe_config(asd, stream_env, j);\n\t\t\tvalid_stream = true;\n\t\t}\n\t}\n\tif (!valid_stream)\n\t\treturn;\n\ts_config = &stream_env->stream_config;\n\tdev_dbg(isp->dev, \"stream_config.mode=%d.\\n\", s_config->mode);\n\n\tif (s_config->mode == IA_CSS_INPUT_MODE_SENSOR ||\n\t    s_config->mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {\n\t\tdev_dbg(isp->dev, \"stream_config.source.port.port=%d.\\n\",\n\t\t\ts_config->source.port.port);\n\t\tdev_dbg(isp->dev, \"stream_config.source.port.num_lanes=%d.\\n\",\n\t\t\ts_config->source.port.num_lanes);\n\t\tdev_dbg(isp->dev, \"stream_config.source.port.timeout=%d.\\n\",\n\t\t\ts_config->source.port.timeout);\n\t\tdev_dbg(isp->dev, \"stream_config.source.port.rxcount=0x%x.\\n\",\n\t\t\ts_config->source.port.rxcount);\n\t\tdev_dbg(isp->dev, \"stream_config.source.port.compression.type=%d.\\n\",\n\t\t\ts_config->source.port.compression.type);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"stream_config.source.port.compression.compressed_bits_per_pixel=%d.\\n\",\n\t\t\ts_config->source.port.compression.\n\t\t\tcompressed_bits_per_pixel);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"stream_config.source.port.compression.uncompressed_bits_per_pixel=%d.\\n\",\n\t\t\ts_config->source.port.compression.\n\t\t\tuncompressed_bits_per_pixel);\n\t} else if (s_config->mode == IA_CSS_INPUT_MODE_TPG) {\n\t\tdev_dbg(isp->dev, \"stream_config.source.tpg.id=%d.\\n\",\n\t\t\ts_config->source.tpg.id);\n\t\tdev_dbg(isp->dev, \"stream_config.source.tpg.mode=%d.\\n\",\n\t\t\ts_config->source.tpg.mode);\n\t\tdev_dbg(isp->dev, \"stream_config.source.tpg.x_mask=%d.\\n\",\n\t\t\ts_config->source.tpg.x_mask);\n\t\tdev_dbg(isp->dev, \"stream_config.source.tpg.x_delta=%d.\\n\",\n\t\t\ts_config->source.tpg.x_delta);\n\t\tdev_dbg(isp->dev, \"stream_config.source.tpg.y_mask=%d.\\n\",\n\t\t\ts_config->source.tpg.y_mask);\n\t\tdev_dbg(isp->dev, \"stream_config.source.tpg.y_delta=%d.\\n\",\n\t\t\ts_config->source.tpg.y_delta);\n\t\tdev_dbg(isp->dev, \"stream_config.source.tpg.xy_mask=%d.\\n\",\n\t\t\ts_config->source.tpg.xy_mask);\n\t} else if (s_config->mode == IA_CSS_INPUT_MODE_PRBS) {\n\t\tdev_dbg(isp->dev, \"stream_config.source.prbs.id=%d.\\n\",\n\t\t\ts_config->source.prbs.id);\n\t\tdev_dbg(isp->dev, \"stream_config.source.prbs.h_blank=%d.\\n\",\n\t\t\ts_config->source.prbs.h_blank);\n\t\tdev_dbg(isp->dev, \"stream_config.source.prbs.v_blank=%d.\\n\",\n\t\t\ts_config->source.prbs.v_blank);\n\t\tdev_dbg(isp->dev, \"stream_config.source.prbs.seed=%d.\\n\",\n\t\t\ts_config->source.prbs.seed);\n\t\tdev_dbg(isp->dev, \"stream_config.source.prbs.seed1=%d.\\n\",\n\t\t\ts_config->source.prbs.seed1);\n\t}\n\n\tfor (j = 0; j < IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH; j++) {\n\t\tdev_dbg(isp->dev, \"stream_configisys_config[%d].input_res w=%d, h=%d.\\n\",\n\t\t\tj,\n\t\t\ts_config->isys_config[j].input_res.width,\n\t\t\ts_config->isys_config[j].input_res.height);\n\n\t\tdev_dbg(isp->dev, \"stream_configisys_config[%d].linked_isys_stream_id=%d\\n\",\n\t\t\tj,\n\t\t\ts_config->isys_config[j].linked_isys_stream_id);\n\n\t\tdev_dbg(isp->dev, \"stream_configisys_config[%d].format=%d\\n\",\n\t\t\tj,\n\t\t\ts_config->isys_config[j].format);\n\n\t\tdev_dbg(isp->dev, \"stream_configisys_config[%d].valid=%d.\\n\",\n\t\t\tj,\n\t\t\ts_config->isys_config[j].valid);\n\t}\n\n\tdev_dbg(isp->dev, \"stream_config.input_config.input_res w=%d, h=%d.\\n\",\n\t\ts_config->input_config.input_res.width,\n\t\ts_config->input_config.input_res.height);\n\n\tdev_dbg(isp->dev, \"stream_config.input_config.effective_res w=%d, h=%d.\\n\",\n\t\ts_config->input_config.effective_res.width,\n\t\ts_config->input_config.effective_res.height);\n\n\tdev_dbg(isp->dev, \"stream_config.input_config.format=%d\\n\",\n\t\ts_config->input_config.format);\n\n\tdev_dbg(isp->dev, \"stream_config.input_config.bayer_order=%d.\\n\",\n\t\ts_config->input_config.bayer_order);\n\n\tdev_dbg(isp->dev, \"stream_config.pixels_per_clock=%d.\\n\",\n\t\ts_config->pixels_per_clock);\n\tdev_dbg(isp->dev, \"stream_config.online=%d.\\n\", s_config->online);\n\tdev_dbg(isp->dev, \"stream_config.continuous=%d.\\n\",\n\t\ts_config->continuous);\n\tdev_dbg(isp->dev, \"stream_config.disable_cont_viewfinder=%d.\\n\",\n\t\ts_config->disable_cont_viewfinder);\n\tdev_dbg(isp->dev, \"stream_config.channel_id=%d.\\n\",\n\t\ts_config->channel_id);\n\tdev_dbg(isp->dev, \"stream_config.init_num_cont_raw_buf=%d.\\n\",\n\t\ts_config->init_num_cont_raw_buf);\n\tdev_dbg(isp->dev, \"stream_config.target_num_cont_raw_buf=%d.\\n\",\n\t\ts_config->target_num_cont_raw_buf);\n\tdev_dbg(isp->dev, \"stream_config.left_padding=%d.\\n\",\n\t\ts_config->left_padding);\n\tdev_dbg(isp->dev, \"stream_config.sensor_binning_factor=%d.\\n\",\n\t\ts_config->sensor_binning_factor);\n\tdev_dbg(isp->dev, \"stream_config.pixels_per_clock=%d.\\n\",\n\t\ts_config->pixels_per_clock);\n\tdev_dbg(isp->dev, \"stream_config.pack_raw_pixels=%d.\\n\",\n\t\ts_config->pack_raw_pixels);\n\tdev_dbg(isp->dev, \"stream_config.flash_gpio_pin=%d.\\n\",\n\t\ts_config->flash_gpio_pin);\n\tdev_dbg(isp->dev, \"stream_config.mipi_buffer_config.size_mem_words=%d.\\n\",\n\t\ts_config->mipi_buffer_config.size_mem_words);\n\tdev_dbg(isp->dev, \"stream_config.mipi_buffer_config.contiguous=%d.\\n\",\n\t\ts_config->mipi_buffer_config.contiguous);\n\tdev_dbg(isp->dev, \"stream_config.metadata_config.data_type=%d.\\n\",\n\t\ts_config->metadata_config.data_type);\n\tdev_dbg(isp->dev, \"stream_config.metadata_config.resolution w=%d, h=%d.\\n\",\n\t\ts_config->metadata_config.resolution.width,\n\t\ts_config->metadata_config.resolution.height);\n}\n\nstatic int __destroy_stream(struct atomisp_sub_device *asd,\n\t\t\t    struct atomisp_stream_env *stream_env)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tunsigned long timeout;\n\n\tif (!stream_env->stream)\n\t\treturn 0;\n\n\tif (stream_env->stream_state == CSS_STREAM_STARTED\n\t    && ia_css_stream_stop(stream_env->stream) != 0) {\n\t\tdev_err(isp->dev, \"stop stream failed.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (stream_env->stream_state == CSS_STREAM_STARTED) {\n\t\ttimeout = jiffies + msecs_to_jiffies(40);\n\t\twhile (1) {\n\t\t\tif (ia_css_stream_has_stopped(stream_env->stream))\n\t\t\t\tbreak;\n\n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\tdev_warn(isp->dev, \"stop stream timeout.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tusleep_range(100, 200);\n\t\t}\n\t}\n\n\tstream_env->stream_state = CSS_STREAM_STOPPED;\n\n\tif (ia_css_stream_destroy(stream_env->stream)) {\n\t\tdev_err(isp->dev, \"destroy stream failed.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tstream_env->stream_state = CSS_STREAM_UNINIT;\n\tstream_env->stream = NULL;\n\n\treturn 0;\n}\n\nstatic int __destroy_streams(struct atomisp_sub_device *asd)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {\n\t\tret = __destroy_stream(asd, &asd->stream_env[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tasd->stream_prepared = false;\n\treturn 0;\n}\n\nstatic int __create_stream(struct atomisp_sub_device *asd,\n\t\t\t   struct atomisp_stream_env *stream_env)\n{\n\tint pipe_index = 0, i;\n\tstruct ia_css_pipe *multi_pipes[IA_CSS_PIPE_ID_NUM];\n\n\tfor (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {\n\t\tif (stream_env->pipes[i])\n\t\t\tmulti_pipes[pipe_index++] = stream_env->pipes[i];\n\t}\n\tif (pipe_index == 0)\n\t\treturn 0;\n\n\tstream_env->stream_config.target_num_cont_raw_buf =\n\t    asd->continuous_raw_buffer_size->val;\n\tstream_env->stream_config.channel_id = stream_env->ch_id;\n\tstream_env->stream_config.ia_css_enable_raw_buffer_locking =\n\t    asd->enable_raw_buffer_lock->val;\n\n\t__dump_stream_config(asd, stream_env);\n\tif (ia_css_stream_create(&stream_env->stream_config,\n\t\t\t\t pipe_index, multi_pipes, &stream_env->stream) != 0)\n\t\treturn -EINVAL;\n\tif (ia_css_stream_get_info(stream_env->stream,\n\t\t\t\t   &stream_env->stream_info) != 0) {\n\t\tia_css_stream_destroy(stream_env->stream);\n\t\tstream_env->stream = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tstream_env->stream_state = CSS_STREAM_CREATED;\n\treturn 0;\n}\n\nstatic int __create_streams(struct atomisp_sub_device *asd)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {\n\t\tret = __create_stream(asd, &asd->stream_env[i]);\n\t\tif (ret)\n\t\t\tgoto rollback;\n\t}\n\tasd->stream_prepared = true;\n\treturn 0;\nrollback:\n\tfor (i--; i >= 0; i--)\n\t\t__destroy_stream(asd, &asd->stream_env[i]);\n\treturn ret;\n}\n\nstatic int __destroy_stream_pipes(struct atomisp_sub_device *asd,\n\t\t\t\t  struct atomisp_stream_env *stream_env)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {\n\t\tif (!stream_env->pipes[i])\n\t\t\tcontinue;\n\t\tif (ia_css_pipe_destroy(stream_env->pipes[i])\n\t\t    != 0) {\n\t\t\tdev_err(isp->dev,\n\t\t\t\t\"destroy pipe[%d]failed.cannot recover.\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tstream_env->pipes[i] = NULL;\n\t\tstream_env->update_pipe[i] = false;\n\t}\n\treturn ret;\n}\n\nstatic int __destroy_pipes(struct atomisp_sub_device *asd)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {\n\t\tif (asd->stream_env[i].stream) {\n\t\t\tdev_err(isp->dev,\n\t\t\t\t\"cannot destroy css pipes for stream[%d].\\n\",\n\t\t\t\ti);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = __destroy_stream_pipes(asd, &asd->stream_env[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid atomisp_destroy_pipes_stream(struct atomisp_sub_device *asd)\n{\n\tif (__destroy_streams(asd))\n\t\tdev_warn(asd->isp->dev, \"destroy stream failed.\\n\");\n\n\tif (__destroy_pipes(asd))\n\t\tdev_warn(asd->isp->dev, \"destroy pipe failed.\\n\");\n}\n\nstatic void __apply_additional_pipe_config(\n    struct atomisp_sub_device *asd,\n    struct atomisp_stream_env *stream_env,\n    enum ia_css_pipe_id pipe_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (pipe_id < 0 || pipe_id >= IA_CSS_PIPE_ID_NUM) {\n\t\tdev_err(isp->dev,\n\t\t\t\"wrong pipe_id for additional pipe config.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tstream_env->pipe_configs[pipe_id].isp_pipe_version = 2;\n\tstream_env->pipe_configs[pipe_id].enable_dz =\n\t    asd->disable_dz->val ? false : true;\n\t \n\tswitch (pipe_id) {\n\tcase IA_CSS_PIPE_ID_CAPTURE:\n\t\t \n\t\tif (stream_env->pipe_configs[pipe_id].\n\t\t    default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW)\n\t\t\tstream_env->pipe_configs[pipe_id].enable_dz = false;\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_VIDEO:\n\t\t \n\t\tstream_env->pipe_extra_configs[pipe_id]\n\t\t.enable_reduced_pipe = true;\n\t\tstream_env->pipe_configs[pipe_id]\n\t\t.enable_dz = false;\n\n\t\tif (asd->params.video_dis_en) {\n\t\t\tstream_env->pipe_extra_configs[pipe_id]\n\t\t\t.enable_dvs_6axis = true;\n\t\t\tstream_env->pipe_configs[pipe_id]\n\t\t\t.dvs_frame_delay =\n\t\t\t    ATOMISP_CSS2_NUM_DVS_FRAME_DELAY;\n\t\t}\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_PREVIEW:\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_YUVPP:\n\tcase IA_CSS_PIPE_ID_COPY:\n\t\tstream_env->pipe_configs[pipe_id].enable_dz = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic bool is_pipe_valid_to_current_run_mode(struct atomisp_sub_device *asd,\n\tenum ia_css_pipe_id pipe_id)\n{\n\tif (pipe_id == IA_CSS_PIPE_ID_YUVPP)\n\t\treturn true;\n\n\tif (asd->vfpp) {\n\t\tif (asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER) {\n\t\t\tif (pipe_id == IA_CSS_PIPE_ID_VIDEO)\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t} else if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_LOWLAT) {\n\t\t\tif (pipe_id == IA_CSS_PIPE_ID_CAPTURE)\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!asd->run_mode)\n\t\treturn false;\n\n\tif (asd->copy_mode && pipe_id == IA_CSS_PIPE_ID_COPY)\n\t\treturn true;\n\n\tswitch (asd->run_mode->val) {\n\tcase ATOMISP_RUN_MODE_STILL_CAPTURE:\n\t\tif (pipe_id == IA_CSS_PIPE_ID_CAPTURE)\n\t\t\treturn true;\n\n\t\treturn false;\n\tcase ATOMISP_RUN_MODE_PREVIEW:\n\t\tif (pipe_id == IA_CSS_PIPE_ID_PREVIEW)\n\t\t\treturn true;\n\n\t\treturn false;\n\tcase ATOMISP_RUN_MODE_VIDEO:\n\t\tif (pipe_id == IA_CSS_PIPE_ID_VIDEO || pipe_id == IA_CSS_PIPE_ID_YUVPP)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic int __create_pipe(struct atomisp_sub_device *asd,\n\t\t\t struct atomisp_stream_env *stream_env,\n\t\t\t enum ia_css_pipe_id pipe_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct ia_css_pipe_extra_config extra_config;\n\tint ret;\n\n\tif (pipe_id >= IA_CSS_PIPE_ID_NUM)\n\t\treturn -EINVAL;\n\n\tif (!stream_env->pipe_configs[pipe_id].output_info[0].res.width)\n\t\treturn 0;\n\n\tif (!is_pipe_valid_to_current_run_mode(asd, pipe_id))\n\t\treturn 0;\n\n\tia_css_pipe_extra_config_defaults(&extra_config);\n\n\t__apply_additional_pipe_config(asd, stream_env, pipe_id);\n\tif (!memcmp(&extra_config,\n\t\t    &stream_env->pipe_extra_configs[pipe_id],\n\t\t    sizeof(extra_config)))\n\t\tret = ia_css_pipe_create(\n\t\t\t  &stream_env->pipe_configs[pipe_id],\n\t\t\t  &stream_env->pipes[pipe_id]);\n\telse\n\t\tret = ia_css_pipe_create_extra(\n\t\t\t  &stream_env->pipe_configs[pipe_id],\n\t\t\t  &stream_env->pipe_extra_configs[pipe_id],\n\t\t\t  &stream_env->pipes[pipe_id]);\n\tif (ret)\n\t\tdev_err(isp->dev, \"create pipe[%d] error.\\n\", pipe_id);\n\treturn ret;\n}\n\nstatic int __create_pipes(struct atomisp_sub_device *asd)\n{\n\tint ret;\n\tint i, j;\n\n\tfor (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {\n\t\tfor (j = 0; j < IA_CSS_PIPE_ID_NUM; j++) {\n\t\t\tret = __create_pipe(asd, &asd->stream_env[i], j);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j < IA_CSS_PIPE_ID_NUM)\n\t\t\tgoto pipe_err;\n\t}\n\treturn 0;\npipe_err:\n\tfor (; i >= 0; i--) {\n\t\tfor (j--; j >= 0; j--) {\n\t\t\tif (asd->stream_env[i].pipes[j]) {\n\t\t\t\tia_css_pipe_destroy(asd->stream_env[i].pipes[j]);\n\t\t\t\tasd->stream_env[i].pipes[j] = NULL;\n\t\t\t}\n\t\t}\n\t\tj = IA_CSS_PIPE_ID_NUM;\n\t}\n\treturn -EINVAL;\n}\n\nint atomisp_create_pipes_stream(struct atomisp_sub_device *asd)\n{\n\tint ret;\n\n\tret = __create_pipes(asd);\n\tif (ret) {\n\t\tdev_err(asd->isp->dev, \"create pipe failed %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = __create_streams(asd);\n\tif (ret) {\n\t\tdev_warn(asd->isp->dev, \"create stream failed %d.\\n\", ret);\n\t\t__destroy_pipes(asd);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint atomisp_css_update_stream(struct atomisp_sub_device *asd)\n{\n\tatomisp_destroy_pipes_stream(asd);\n\treturn atomisp_create_pipes_stream(asd);\n}\n\nint atomisp_css_init(struct atomisp_device *isp)\n{\n\tunsigned int mmu_base_addr;\n\tint ret;\n\tint err;\n\n\tret = hmm_get_mmu_base_addr(isp->dev, &mmu_base_addr);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\terr = ia_css_init(isp->dev, &isp->css_env.isp_css_env, NULL,\n\t\t\t  (uint32_t)mmu_base_addr, IA_CSS_IRQ_TYPE_PULSE);\n\tif (err) {\n\t\tdev_err(isp->dev, \"css init failed --- bad firmware?\\n\");\n\t\treturn -EINVAL;\n\t}\n\tia_css_enable_isys_event_queue(true);\n\n\tisp->css_initialized = true;\n\tdev_dbg(isp->dev, \"sh_css_init success\\n\");\n\n\treturn 0;\n}\n\nstatic inline int __set_css_print_env(struct atomisp_device *isp, int opt)\n{\n\tint ret = 0;\n\n\tif (opt == 0)\n\t\tisp->css_env.isp_css_env.print_env.debug_print = NULL;\n\telse if (opt == 1)\n\t\tisp->css_env.isp_css_env.print_env.debug_print = atomisp_vprintk;\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nint atomisp_css_load_firmware(struct atomisp_device *isp)\n{\n\tint err;\n\n\t \n\tisp->css_env.isp_css_fw.data = (void *)isp->firmware->data;\n\tisp->css_env.isp_css_fw.bytes = isp->firmware->size;\n\n\tisp->css_env.isp_css_env.hw_access_env.store_8 =\n\t    atomisp_css2_hw_store_8;\n\tisp->css_env.isp_css_env.hw_access_env.store_16 =\n\t    atomisp_css2_hw_store_16;\n\tisp->css_env.isp_css_env.hw_access_env.store_32 =\n\t    atomisp_css2_hw_store_32;\n\n\tisp->css_env.isp_css_env.hw_access_env.load_8 = atomisp_css2_hw_load_8;\n\tisp->css_env.isp_css_env.hw_access_env.load_16 =\n\t    atomisp_css2_hw_load_16;\n\tisp->css_env.isp_css_env.hw_access_env.load_32 =\n\t    atomisp_css2_hw_load_32;\n\n\tisp->css_env.isp_css_env.hw_access_env.load = atomisp_css2_hw_load;\n\tisp->css_env.isp_css_env.hw_access_env.store = atomisp_css2_hw_store;\n\n\t__set_css_print_env(isp, dbg_func);\n\n\tisp->css_env.isp_css_env.print_env.error_print = atomisp_vprintk;\n\n\t \n\terr = ia_css_load_firmware(isp->dev, &isp->css_env.isp_css_env,\n\t\t\t\t   &isp->css_env.isp_css_fw);\n\tif (err) {\n\t\tdev_err(isp->dev, \"css load fw failed.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid atomisp_css_uninit(struct atomisp_device *isp)\n{\n\tisp->css_initialized = false;\n\tia_css_uninit();\n}\n\nint atomisp_css_irq_translate(struct atomisp_device *isp,\n\t\t\t      unsigned int *infos)\n{\n\tint err;\n\n\terr = ia_css_irq_translate(infos);\n\tif (err) {\n\t\tdev_warn(isp->dev,\n\t\t\t \"%s:failed to translate irq (err = %d,infos = %d)\\n\",\n\t\t\t __func__, err, *infos);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid atomisp_css_rx_get_irq_info(enum mipi_port_id port,\n\t\t\t\t unsigned int *infos)\n{\n#ifndef ISP2401\n\tia_css_isys_rx_get_irq_info(port, infos);\n#else\n\t*infos = 0;\n#endif\n}\n\nvoid atomisp_css_rx_clear_irq_info(enum mipi_port_id port,\n\t\t\t\t   unsigned int infos)\n{\n#ifndef ISP2401\n\tia_css_isys_rx_clear_irq_info(port, infos);\n#endif\n}\n\nint atomisp_css_irq_enable(struct atomisp_device *isp,\n\t\t\t   enum ia_css_irq_info info, bool enable)\n{\n\tdev_dbg(isp->dev, \"%s: css irq info 0x%08x: %s (%d).\\n\",\n\t\t__func__, info,\n\t\tenable ? \"enable\" : \"disable\", enable);\n\tif (ia_css_irq_enable(info, enable)) {\n\t\tdev_warn(isp->dev, \"%s:Invalid irq info: 0x%08x when %s.\\n\",\n\t\t\t __func__, info,\n\t\t\t enable ? \"enabling\" : \"disabling\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid atomisp_css_init_struct(struct atomisp_sub_device *asd)\n{\n\tint i, j;\n\n\tfor (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {\n\t\tasd->stream_env[i].stream = NULL;\n\t\tfor (j = 0; j < IA_CSS_PIPE_MODE_NUM; j++) {\n\t\t\tasd->stream_env[i].pipes[j] = NULL;\n\t\t\tasd->stream_env[i].update_pipe[j] = false;\n\t\t\tia_css_pipe_config_defaults(\n\t\t\t    &asd->stream_env[i].pipe_configs[j]);\n\t\t\tia_css_pipe_extra_config_defaults(\n\t\t\t    &asd->stream_env[i].pipe_extra_configs[j]);\n\t\t}\n\t\tia_css_stream_config_defaults(&asd->stream_env[i].stream_config);\n\t}\n}\n\nint atomisp_q_video_buffer_to_css(struct atomisp_sub_device *asd,\n\t\t\t\t  struct ia_css_frame *frame,\n\t\t\t\t  enum atomisp_input_stream_id stream_id,\n\t\t\t\t  enum ia_css_buffer_type css_buf_type,\n\t\t\t\t  enum ia_css_pipe_id css_pipe_id)\n{\n\tstruct atomisp_stream_env *stream_env = &asd->stream_env[stream_id];\n\tstruct ia_css_buffer css_buf = {0};\n\tint err;\n\n\tcss_buf.type = css_buf_type;\n\tcss_buf.data.frame = frame;\n\n\terr = ia_css_pipe_enqueue_buffer(\n\t\t  stream_env->pipes[css_pipe_id], &css_buf);\n\tif (err)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint atomisp_q_metadata_buffer_to_css(struct atomisp_sub_device *asd,\n\t\t\t\t     struct atomisp_metadata_buf *metadata_buf,\n\t\t\t\t     enum atomisp_input_stream_id stream_id,\n\t\t\t\t     enum ia_css_pipe_id css_pipe_id)\n{\n\tstruct atomisp_stream_env *stream_env = &asd->stream_env[stream_id];\n\tstruct ia_css_buffer buffer = {0};\n\tstruct atomisp_device *isp = asd->isp;\n\n\tbuffer.type = IA_CSS_BUFFER_TYPE_METADATA;\n\tbuffer.data.metadata = metadata_buf->metadata;\n\tif (ia_css_pipe_enqueue_buffer(stream_env->pipes[css_pipe_id],\n\t\t\t\t       &buffer)) {\n\t\tdev_err(isp->dev, \"failed to q meta data buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint atomisp_q_s3a_buffer_to_css(struct atomisp_sub_device *asd,\n\t\t\t\tstruct atomisp_s3a_buf *s3a_buf,\n\t\t\t\tenum atomisp_input_stream_id stream_id,\n\t\t\t\tenum ia_css_pipe_id css_pipe_id)\n{\n\tstruct atomisp_stream_env *stream_env = &asd->stream_env[stream_id];\n\tstruct ia_css_buffer buffer = {0};\n\tstruct atomisp_device *isp = asd->isp;\n\n\tbuffer.type = IA_CSS_BUFFER_TYPE_3A_STATISTICS;\n\tbuffer.data.stats_3a = s3a_buf->s3a_data;\n\tif (ia_css_pipe_enqueue_buffer(\n\t\tstream_env->pipes[css_pipe_id],\n\t\t&buffer)) {\n\t\tdev_dbg(isp->dev, \"failed to q s3a stat buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint atomisp_q_dis_buffer_to_css(struct atomisp_sub_device *asd,\n\t\t\t\tstruct atomisp_dis_buf *dis_buf,\n\t\t\t\tenum atomisp_input_stream_id stream_id,\n\t\t\t\tenum ia_css_pipe_id css_pipe_id)\n{\n\tstruct atomisp_stream_env *stream_env = &asd->stream_env[stream_id];\n\tstruct ia_css_buffer buffer = {0};\n\tstruct atomisp_device *isp = asd->isp;\n\n\tbuffer.type = IA_CSS_BUFFER_TYPE_DIS_STATISTICS;\n\tbuffer.data.stats_dvs = dis_buf->dis_data;\n\tif (ia_css_pipe_enqueue_buffer(\n\t\tstream_env->pipes[css_pipe_id],\n\t\t&buffer)) {\n\t\tdev_dbg(isp->dev, \"failed to q dvs stat buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint atomisp_css_start(struct atomisp_sub_device *asd)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tbool sp_is_started = false;\n\tint ret = 0, i = 0;\n\n\tif (!sh_css_hrt_system_is_idle())\n\t\tdev_err(isp->dev, \"CSS HW not idle before starting SP\\n\");\n\n\tif (ia_css_start_sp()) {\n\t\tdev_err(isp->dev, \"start sp error.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto start_err;\n\t}\n\n\tsp_is_started = true;\n\n\tfor (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {\n\t\tif (asd->stream_env[i].stream) {\n\t\t\tif (ia_css_stream_start(asd->stream_env[i]\n\t\t\t\t\t\t.stream) != 0) {\n\t\t\t\tdev_err(isp->dev, \"stream[%d] start error.\\n\", i);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto start_err;\n\t\t\t} else {\n\t\t\t\tasd->stream_env[i].stream_state = CSS_STREAM_STARTED;\n\t\t\t\tdev_dbg(isp->dev, \"stream[%d] started.\\n\", i);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nstart_err:\n\t \n\tif (sp_is_started) {\n\t\tatomisp_destroy_pipes_stream(asd);\n\t\tia_css_stop_sp();\n\t\tatomisp_create_pipes_stream(asd);\n\t}\n\n\treturn ret;\n}\n\nvoid atomisp_css_update_isp_params(struct atomisp_sub_device *asd)\n{\n\t \n\tif (asd->copy_mode) {\n\t\tdev_warn(asd->isp->dev,\n\t\t\t \"%s: ia_css_stream_set_isp_config() not supported in copy mode!.\\n\",\n\t\t\t __func__);\n\t\treturn;\n\t}\n\n\tia_css_stream_set_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &asd->params.config);\n\tmemset(&asd->params.config, 0, sizeof(asd->params.config));\n}\n\nvoid atomisp_css_update_isp_params_on_pipe(struct atomisp_sub_device *asd,\n\tstruct ia_css_pipe *pipe)\n{\n\tint ret;\n\n\tif (!pipe) {\n\t\tatomisp_css_update_isp_params(asd);\n\t\treturn;\n\t}\n\n\tdev_dbg(asd->isp->dev,\n\t\t\"%s: apply parameter for ia_css_frame %p with isp_config_id %d on pipe %p.\\n\",\n\t\t__func__, asd->params.config.output_frame,\n\t\tasd->params.config.isp_config_id, pipe);\n\n\tret = ia_css_stream_set_isp_config_on_pipe(\n\t\t  asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t\t  &asd->params.config, pipe);\n\tif (ret)\n\t\tdev_warn(asd->isp->dev, \"%s: ia_css_stream_set_isp_config_on_pipe failed %d\\n\",\n\t\t\t __func__, ret);\n\tmemset(&asd->params.config, 0, sizeof(asd->params.config));\n}\n\nint atomisp_css_queue_buffer(struct atomisp_sub_device *asd,\n\t\t\t     enum atomisp_input_stream_id stream_id,\n\t\t\t     enum ia_css_pipe_id pipe_id,\n\t\t\t     enum ia_css_buffer_type buf_type,\n\t\t\t     struct atomisp_css_buffer *isp_css_buffer)\n{\n\tif (ia_css_pipe_enqueue_buffer(\n\t\tasd->stream_env[stream_id].pipes[pipe_id],\n\t\t&isp_css_buffer->css_buffer)\n\t    != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint atomisp_css_dequeue_buffer(struct atomisp_sub_device *asd,\n\t\t\t       enum atomisp_input_stream_id stream_id,\n\t\t\t       enum ia_css_pipe_id pipe_id,\n\t\t\t       enum ia_css_buffer_type buf_type,\n\t\t\t       struct atomisp_css_buffer *isp_css_buffer)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tint err;\n\n\terr = ia_css_pipe_dequeue_buffer(\n\t\t  asd->stream_env[stream_id].pipes[pipe_id],\n\t\t  &isp_css_buffer->css_buffer);\n\tif (err) {\n\t\tdev_err(isp->dev,\n\t\t\t\"ia_css_pipe_dequeue_buffer failed: 0x%x\\n\", err);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint atomisp_css_allocate_stat_buffers(struct atomisp_sub_device   *asd,\n\t\t\t\t      u16 stream_id,\n\t\t\t\t      struct atomisp_s3a_buf      *s3a_buf,\n\t\t\t\t      struct atomisp_dis_buf      *dis_buf,\n\t\t\t\t      struct atomisp_metadata_buf *md_buf)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct ia_css_dvs_grid_info *dvs_grid_info =\n\t    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);\n\n\tif (s3a_buf && asd->params.curr_grid_info.s3a_grid.enable) {\n\t\tvoid *s3a_ptr;\n\n\t\ts3a_buf->s3a_data = ia_css_isp_3a_statistics_allocate(\n\t\t\t\t\t&asd->params.curr_grid_info.s3a_grid);\n\t\tif (!s3a_buf->s3a_data) {\n\t\t\tdev_err(isp->dev, \"3a buf allocation failed.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ts3a_ptr = hmm_vmap(s3a_buf->s3a_data->data_ptr, true);\n\t\ts3a_buf->s3a_map = ia_css_isp_3a_statistics_map_allocate(\n\t\t\t\t       s3a_buf->s3a_data, s3a_ptr);\n\t}\n\n\tif (dis_buf && dvs_grid_info && dvs_grid_info->enable) {\n\t\tvoid *dvs_ptr;\n\n\t\tdis_buf->dis_data = ia_css_isp_dvs2_statistics_allocate(\n\t\t\t\t\tdvs_grid_info);\n\t\tif (!dis_buf->dis_data) {\n\t\t\tdev_err(isp->dev, \"dvs buf allocation failed.\\n\");\n\t\t\tif (s3a_buf)\n\t\t\t\tia_css_isp_3a_statistics_free(s3a_buf->s3a_data);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdvs_ptr = hmm_vmap(dis_buf->dis_data->data_ptr, true);\n\t\tdis_buf->dvs_map = ia_css_isp_dvs_statistics_map_allocate(\n\t\t\t\t       dis_buf->dis_data, dvs_ptr);\n\t}\n\n\tif (asd->stream_env[stream_id].stream_info.\n\t    metadata_info.size && md_buf) {\n\t\tmd_buf->metadata = ia_css_metadata_allocate(\n\t\t\t\t       &asd->stream_env[stream_id].stream_info.metadata_info);\n\t\tif (!md_buf->metadata) {\n\t\t\tif (s3a_buf)\n\t\t\t\tia_css_isp_3a_statistics_free(s3a_buf->s3a_data);\n\t\t\tif (dis_buf)\n\t\t\t\tia_css_isp_dvs2_statistics_free(dis_buf->dis_data);\n\t\t\tdev_err(isp->dev, \"metadata buf allocation failed.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmd_buf->md_vptr = hmm_vmap(md_buf->metadata->address, false);\n\t}\n\n\treturn 0;\n}\n\nvoid atomisp_css_free_3a_buffer(struct atomisp_s3a_buf *s3a_buf)\n{\n\tif (s3a_buf->s3a_data)\n\t\thmm_vunmap(s3a_buf->s3a_data->data_ptr);\n\n\tia_css_isp_3a_statistics_map_free(s3a_buf->s3a_map);\n\ts3a_buf->s3a_map = NULL;\n\tia_css_isp_3a_statistics_free(s3a_buf->s3a_data);\n}\n\nvoid atomisp_css_free_dis_buffer(struct atomisp_dis_buf *dis_buf)\n{\n\tif (dis_buf->dis_data)\n\t\thmm_vunmap(dis_buf->dis_data->data_ptr);\n\n\tia_css_isp_dvs_statistics_map_free(dis_buf->dvs_map);\n\tdis_buf->dvs_map = NULL;\n\tia_css_isp_dvs2_statistics_free(dis_buf->dis_data);\n}\n\nvoid atomisp_css_free_metadata_buffer(struct atomisp_metadata_buf *metadata_buf)\n{\n\tif (metadata_buf->md_vptr) {\n\t\thmm_vunmap(metadata_buf->metadata->address);\n\t\tmetadata_buf->md_vptr = NULL;\n\t}\n\tia_css_metadata_free(metadata_buf->metadata);\n}\n\nvoid atomisp_css_free_stat_buffers(struct atomisp_sub_device *asd)\n{\n\tstruct atomisp_s3a_buf *s3a_buf, *_s3a_buf;\n\tstruct atomisp_dis_buf *dis_buf, *_dis_buf;\n\tstruct atomisp_metadata_buf *md_buf, *_md_buf;\n\tstruct ia_css_dvs_grid_info *dvs_grid_info =\n\t    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);\n\tunsigned int i;\n\n\t \n\tif (dvs_grid_info && dvs_grid_info->enable) {\n\t\tia_css_dvs2_coefficients_free(asd->params.css_param.dvs2_coeff);\n\t\tia_css_dvs2_statistics_free(asd->params.dvs_stat);\n\t\tasd->params.css_param.dvs2_coeff = NULL;\n\t\tasd->params.dvs_stat = NULL;\n\t\tasd->params.dvs_hor_proj_bytes = 0;\n\t\tasd->params.dvs_ver_proj_bytes = 0;\n\t\tasd->params.dvs_hor_coef_bytes = 0;\n\t\tasd->params.dvs_ver_coef_bytes = 0;\n\t\tasd->params.dis_proj_data_valid = false;\n\t\tlist_for_each_entry_safe(dis_buf, _dis_buf,\n\t\t\t\t\t &asd->dis_stats, list) {\n\t\t\tatomisp_css_free_dis_buffer(dis_buf);\n\t\t\tlist_del(&dis_buf->list);\n\t\t\tkfree(dis_buf);\n\t\t}\n\t\tlist_for_each_entry_safe(dis_buf, _dis_buf,\n\t\t\t\t\t &asd->dis_stats_in_css, list) {\n\t\t\tatomisp_css_free_dis_buffer(dis_buf);\n\t\t\tlist_del(&dis_buf->list);\n\t\t\tkfree(dis_buf);\n\t\t}\n\t}\n\tif (asd->params.curr_grid_info.s3a_grid.enable) {\n\t\tia_css_3a_statistics_free(asd->params.s3a_user_stat);\n\t\tasd->params.s3a_user_stat = NULL;\n\t\tasd->params.s3a_output_bytes = 0;\n\t\tlist_for_each_entry_safe(s3a_buf, _s3a_buf,\n\t\t\t\t\t &asd->s3a_stats, list) {\n\t\t\tatomisp_css_free_3a_buffer(s3a_buf);\n\t\t\tlist_del(&s3a_buf->list);\n\t\t\tkfree(s3a_buf);\n\t\t}\n\t\tlist_for_each_entry_safe(s3a_buf, _s3a_buf,\n\t\t\t\t\t &asd->s3a_stats_in_css, list) {\n\t\t\tatomisp_css_free_3a_buffer(s3a_buf);\n\t\t\tlist_del(&s3a_buf->list);\n\t\t\tkfree(s3a_buf);\n\t\t}\n\t\tlist_for_each_entry_safe(s3a_buf, _s3a_buf,\n\t\t\t\t\t &asd->s3a_stats_ready, list) {\n\t\t\tatomisp_css_free_3a_buffer(s3a_buf);\n\t\t\tlist_del(&s3a_buf->list);\n\t\t\tkfree(s3a_buf);\n\t\t}\n\t}\n\n\tif (asd->params.css_param.dvs_6axis) {\n\t\tia_css_dvs2_6axis_config_free(asd->params.css_param.dvs_6axis);\n\t\tasd->params.css_param.dvs_6axis = NULL;\n\t}\n\n\tfor (i = 0; i < ATOMISP_METADATA_TYPE_NUM; i++) {\n\t\tlist_for_each_entry_safe(md_buf, _md_buf,\n\t\t\t\t\t &asd->metadata[i], list) {\n\t\t\tatomisp_css_free_metadata_buffer(md_buf);\n\t\t\tlist_del(&md_buf->list);\n\t\t\tkfree(md_buf);\n\t\t}\n\t\tlist_for_each_entry_safe(md_buf, _md_buf,\n\t\t\t\t\t &asd->metadata_in_css[i], list) {\n\t\t\tatomisp_css_free_metadata_buffer(md_buf);\n\t\t\tlist_del(&md_buf->list);\n\t\t\tkfree(md_buf);\n\t\t}\n\t\tlist_for_each_entry_safe(md_buf, _md_buf,\n\t\t\t\t\t &asd->metadata_ready[i], list) {\n\t\t\tatomisp_css_free_metadata_buffer(md_buf);\n\t\t\tlist_del(&md_buf->list);\n\t\t\tkfree(md_buf);\n\t\t}\n\t}\n\tasd->params.metadata_width_size = 0;\n\tatomisp_free_metadata_output_buf(asd);\n}\n\nint atomisp_css_get_grid_info(struct atomisp_sub_device *asd,\n\t\t\t      enum ia_css_pipe_id pipe_id)\n{\n\tstruct ia_css_pipe_info p_info;\n\tstruct ia_css_grid_info old_info;\n\tstruct atomisp_device *isp = asd->isp;\n\tint md_width = asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].\n\t\t       stream_config.metadata_config.resolution.width;\n\n\tmemset(&p_info, 0, sizeof(struct ia_css_pipe_info));\n\tmemset(&old_info, 0, sizeof(struct ia_css_grid_info));\n\n\tif (ia_css_pipe_get_info(\n\t\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].pipes[pipe_id],\n\t\t&p_info) != 0) {\n\t\tdev_err(isp->dev, \"ia_css_pipe_get_info failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&old_info, &asd->params.curr_grid_info,\n\t       sizeof(struct ia_css_grid_info));\n\tmemcpy(&asd->params.curr_grid_info, &p_info.grid_info,\n\t       sizeof(struct ia_css_grid_info));\n\t \n\tif (asd->params.curr_grid_info.s3a_grid.enable) {\n\t\tif (asd->params.s3a_enabled_pipe != IA_CSS_PIPE_ID_NUM)\n\t\t\tdev_dbg(isp->dev, \"css pipe %d enabled s3a grid replaced by: %d.\\n\",\n\t\t\t\tasd->params.s3a_enabled_pipe, pipe_id);\n\t\tasd->params.s3a_enabled_pipe = pipe_id;\n\t}\n\n\t \n\tif (((!memcmp(&old_info, &asd->params.curr_grid_info, sizeof(old_info))\n\t      && asd->params.s3a_user_stat && asd->params.dvs_stat)\n\t     || asd->params.curr_grid_info.s3a_grid.width == 0\n\t     || asd->params.curr_grid_info.s3a_grid.height == 0)\n\t    && asd->params.metadata_width_size == md_width) {\n\t\tdev_dbg(isp->dev,\n\t\t\t\"grid info change escape. memcmp=%d, s3a_user_stat=%d,dvs_stat=%d, s3a.width=%d, s3a.height=%d, metadata width =%d\\n\",\n\t\t\t!memcmp(&old_info, &asd->params.curr_grid_info,\n\t\t\t\tsizeof(old_info)),\n\t\t\t!!asd->params.s3a_user_stat, !!asd->params.dvs_stat,\n\t\t\tasd->params.curr_grid_info.s3a_grid.width,\n\t\t\tasd->params.curr_grid_info.s3a_grid.height,\n\t\t\tasd->params.metadata_width_size);\n\t\treturn -EINVAL;\n\t}\n\tasd->params.metadata_width_size = md_width;\n\n\treturn 0;\n}\n\nint atomisp_alloc_3a_output_buf(struct atomisp_sub_device *asd)\n{\n\tif (!asd->params.curr_grid_info.s3a_grid.width ||\n\t    !asd->params.curr_grid_info.s3a_grid.height)\n\t\treturn 0;\n\n\tasd->params.s3a_user_stat = ia_css_3a_statistics_allocate(\n\t\t\t\t\t&asd->params.curr_grid_info.s3a_grid);\n\tif (!asd->params.s3a_user_stat)\n\t\treturn -ENOMEM;\n\t \n\tasd->params.s3a_output_bytes =\n\t    asd->params.curr_grid_info.s3a_grid.width *\n\t    asd->params.curr_grid_info.s3a_grid.height *\n\t    sizeof(*asd->params.s3a_user_stat->data);\n\n\treturn 0;\n}\n\nint atomisp_alloc_dis_coef_buf(struct atomisp_sub_device *asd)\n{\n\tstruct ia_css_dvs_grid_info *dvs_grid =\n\t    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);\n\n\tif (!dvs_grid)\n\t\treturn 0;\n\n\tif (!dvs_grid->enable) {\n\t\tdev_dbg(asd->isp->dev, \"%s: dvs_grid not enabled.\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t \n\tasd->params.css_param.dvs2_coeff = ia_css_dvs2_coefficients_allocate(\n\t\t\t\t\t       dvs_grid);\n\tif (!asd->params.css_param.dvs2_coeff)\n\t\treturn -ENOMEM;\n\n\tasd->params.dvs_hor_coef_bytes = dvs_grid->num_hor_coefs *\n\t\t\t\t\t sizeof(*asd->params.css_param.dvs2_coeff->hor_coefs.odd_real);\n\n\tasd->params.dvs_ver_coef_bytes = dvs_grid->num_ver_coefs *\n\t\t\t\t\t sizeof(*asd->params.css_param.dvs2_coeff->ver_coefs.odd_real);\n\n\t \n\tasd->params.dis_proj_data_valid = false;\n\tasd->params.dvs_stat = ia_css_dvs2_statistics_allocate(dvs_grid);\n\tif (!asd->params.dvs_stat)\n\t\treturn -ENOMEM;\n\n\tasd->params.dvs_hor_proj_bytes =\n\t    dvs_grid->aligned_height * dvs_grid->aligned_width *\n\t    sizeof(*asd->params.dvs_stat->hor_prod.odd_real);\n\n\tasd->params.dvs_ver_proj_bytes =\n\t    dvs_grid->aligned_height * dvs_grid->aligned_width *\n\t    sizeof(*asd->params.dvs_stat->ver_prod.odd_real);\n\n\treturn 0;\n}\n\nint atomisp_alloc_metadata_output_buf(struct atomisp_sub_device *asd)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ATOMISP_METADATA_TYPE_NUM; i++) {\n\t\tasd->params.metadata_user[i] = kvmalloc(\n\t\t\t\t\t\t   asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].\n\t\t\t\t\t\t   stream_info.metadata_info.size, GFP_KERNEL);\n\t\tif (!asd->params.metadata_user[i]) {\n\t\t\twhile (--i >= 0) {\n\t\t\t\tkvfree(asd->params.metadata_user[i]);\n\t\t\t\tasd->params.metadata_user[i] = NULL;\n\t\t\t}\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid atomisp_free_metadata_output_buf(struct atomisp_sub_device *asd)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ATOMISP_METADATA_TYPE_NUM; i++) {\n\t\tif (asd->params.metadata_user[i]) {\n\t\t\tkvfree(asd->params.metadata_user[i]);\n\t\t\tasd->params.metadata_user[i] = NULL;\n\t\t}\n\t}\n}\n\nvoid atomisp_css_temp_pipe_to_pipe_id(struct atomisp_sub_device *asd,\n\t\t\t\t      struct atomisp_css_event *current_event)\n{\n\t \n\tia_css_temp_pipe_to_pipe_id(current_event->event.pipe,\n\t\t\t\t    &current_event->pipe);\n\tif (asd && asd->copy_mode &&\n\t    current_event->pipe == IA_CSS_PIPE_ID_CAPTURE)\n\t\tcurrent_event->pipe = IA_CSS_PIPE_ID_COPY;\n}\n\nint atomisp_css_isys_set_resolution(struct atomisp_sub_device *asd,\n\t\t\t\t    enum atomisp_input_stream_id stream_id,\n\t\t\t\t    struct v4l2_mbus_framefmt *ffmt,\n\t\t\t\t    int isys_stream)\n{\n\tstruct ia_css_stream_config *s_config =\n\t\t    &asd->stream_env[stream_id].stream_config;\n\n\tif (isys_stream >= IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH)\n\t\treturn -EINVAL;\n\n\ts_config->isys_config[isys_stream].input_res.width = ffmt->width;\n\ts_config->isys_config[isys_stream].input_res.height = ffmt->height;\n\treturn 0;\n}\n\nint atomisp_css_input_set_resolution(struct atomisp_sub_device *asd,\n\t\t\t\t     enum atomisp_input_stream_id stream_id,\n\t\t\t\t     struct v4l2_mbus_framefmt *ffmt)\n{\n\tstruct ia_css_stream_config *s_config =\n\t\t    &asd->stream_env[stream_id].stream_config;\n\n\ts_config->input_config.input_res.width = ffmt->width;\n\ts_config->input_config.input_res.height = ffmt->height;\n\treturn 0;\n}\n\nvoid atomisp_css_input_set_binning_factor(struct atomisp_sub_device *asd,\n\tenum atomisp_input_stream_id stream_id,\n\tunsigned int bin_factor)\n{\n\tasd->stream_env[stream_id]\n\t.stream_config.sensor_binning_factor = bin_factor;\n}\n\nvoid atomisp_css_input_set_bayer_order(struct atomisp_sub_device *asd,\n\t\t\t\t       enum atomisp_input_stream_id stream_id,\n\t\t\t\t       enum ia_css_bayer_order bayer_order)\n{\n\tstruct ia_css_stream_config *s_config =\n\t\t    &asd->stream_env[stream_id].stream_config;\n\ts_config->input_config.bayer_order = bayer_order;\n}\n\nvoid atomisp_css_isys_set_link(struct atomisp_sub_device *asd,\n\t\t\t       enum atomisp_input_stream_id stream_id,\n\t\t\t       int link,\n\t\t\t       int isys_stream)\n{\n\tstruct ia_css_stream_config *s_config =\n\t\t    &asd->stream_env[stream_id].stream_config;\n\n\ts_config->isys_config[isys_stream].linked_isys_stream_id = link;\n}\n\nvoid atomisp_css_isys_set_valid(struct atomisp_sub_device *asd,\n\t\t\t\tenum atomisp_input_stream_id stream_id,\n\t\t\t\tbool valid,\n\t\t\t\tint isys_stream)\n{\n\tstruct ia_css_stream_config *s_config =\n\t\t    &asd->stream_env[stream_id].stream_config;\n\n\ts_config->isys_config[isys_stream].valid = valid;\n}\n\nvoid atomisp_css_isys_set_format(struct atomisp_sub_device *asd,\n\t\t\t\t enum atomisp_input_stream_id stream_id,\n\t\t\t\t enum atomisp_input_format format,\n\t\t\t\t int isys_stream)\n{\n\tstruct ia_css_stream_config *s_config =\n\t\t    &asd->stream_env[stream_id].stream_config;\n\n\ts_config->isys_config[isys_stream].format = format;\n}\n\nvoid atomisp_css_input_set_format(struct atomisp_sub_device *asd,\n\t\t\t\t  enum atomisp_input_stream_id stream_id,\n\t\t\t\t  enum atomisp_input_format format)\n{\n\tstruct ia_css_stream_config *s_config =\n\t\t    &asd->stream_env[stream_id].stream_config;\n\n\ts_config->input_config.format = format;\n}\n\nint atomisp_css_set_default_isys_config(struct atomisp_sub_device *asd,\n\t\t\t\t\tenum atomisp_input_stream_id stream_id,\n\t\t\t\t\tstruct v4l2_mbus_framefmt *ffmt)\n{\n\tint i;\n\tstruct ia_css_stream_config *s_config =\n\t\t    &asd->stream_env[stream_id].stream_config;\n\t \n\tfor (i = IA_CSS_STREAM_ISYS_STREAM_0;\n\t     i < IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH; i++)\n\t\ts_config->isys_config[i].valid = false;\n\n\tatomisp_css_isys_set_resolution(asd, stream_id, ffmt,\n\t\t\t\t\tIA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX);\n\tatomisp_css_isys_set_format(asd, stream_id,\n\t\t\t\t    s_config->input_config.format,\n\t\t\t\t    IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX);\n\tatomisp_css_isys_set_link(asd, stream_id, NO_LINK,\n\t\t\t\t  IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX);\n\tatomisp_css_isys_set_valid(asd, stream_id, true,\n\t\t\t\t   IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX);\n\n\treturn 0;\n}\n\nvoid atomisp_css_isys_two_stream_cfg_update_stream1(\n    struct atomisp_sub_device *asd,\n    enum atomisp_input_stream_id stream_id,\n    enum atomisp_input_format input_format,\n    unsigned int width, unsigned int height)\n{\n\tstruct ia_css_stream_config *s_config =\n\t\t    &asd->stream_env[stream_id].stream_config;\n\n\ts_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_0].input_res.width =\n\t    width;\n\ts_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_0].input_res.height =\n\t    height;\n\ts_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_0].format =\n\t    input_format;\n\ts_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_0].valid = true;\n}\n\nvoid atomisp_css_isys_two_stream_cfg_update_stream2(\n    struct atomisp_sub_device *asd,\n    enum atomisp_input_stream_id stream_id,\n    enum atomisp_input_format input_format,\n    unsigned int width, unsigned int height)\n{\n\tstruct ia_css_stream_config *s_config =\n\t\t    &asd->stream_env[stream_id].stream_config;\n\n\ts_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_1].input_res.width =\n\t    width;\n\ts_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_1].input_res.height =\n\t    height;\n\ts_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_1].linked_isys_stream_id\n\t    = IA_CSS_STREAM_ISYS_STREAM_0;\n\ts_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_1].format =\n\t    input_format;\n\ts_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_1].valid = true;\n}\n\nint atomisp_css_input_set_effective_resolution(\n    struct atomisp_sub_device *asd,\n    enum atomisp_input_stream_id stream_id,\n    unsigned int width, unsigned int height)\n{\n\tstruct ia_css_stream_config *s_config =\n\t\t    &asd->stream_env[stream_id].stream_config;\n\ts_config->input_config.effective_res.width = width;\n\ts_config->input_config.effective_res.height = height;\n\treturn 0;\n}\n\nvoid atomisp_css_video_set_dis_envelope(struct atomisp_sub_device *asd,\n\t\t\t\t\tunsigned int dvs_w, unsigned int dvs_h)\n{\n\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t.pipe_configs[IA_CSS_PIPE_ID_VIDEO].dvs_envelope.width = dvs_w;\n\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t.pipe_configs[IA_CSS_PIPE_ID_VIDEO].dvs_envelope.height = dvs_h;\n}\n\nvoid atomisp_css_input_set_two_pixels_per_clock(\n    struct atomisp_sub_device *asd,\n    bool two_ppc)\n{\n\tint i;\n\n\tif (asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t    .stream_config.pixels_per_clock == (two_ppc ? 2 : 1))\n\t\treturn;\n\n\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t.stream_config.pixels_per_clock = (two_ppc ? 2 : 1);\n\tfor (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)\n\t\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t\t.update_pipe[i] = true;\n}\n\nvoid atomisp_css_enable_dz(struct atomisp_sub_device *asd, bool enable)\n{\n\tint i;\n\n\tfor (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)\n\t\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t\t.pipe_configs[i].enable_dz = enable;\n}\n\nvoid atomisp_css_capture_set_mode(struct atomisp_sub_device *asd,\n\t\t\t\t  enum ia_css_capture_mode mode)\n{\n\tstruct atomisp_stream_env *stream_env =\n\t\t    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];\n\n\tif (stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE]\n\t    .default_capture_config.mode == mode)\n\t\treturn;\n\n\tstream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE].\n\tdefault_capture_config.mode = mode;\n\tstream_env->update_pipe[IA_CSS_PIPE_ID_CAPTURE] = true;\n}\n\nvoid atomisp_css_input_set_mode(struct atomisp_sub_device *asd,\n\t\t\t\tenum ia_css_input_mode mode)\n{\n\tint i;\n\tstruct atomisp_device *isp = asd->isp;\n\tunsigned int size_mem_words;\n\n\tfor (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++)\n\t\tasd->stream_env[i].stream_config.mode = mode;\n\n\tif (isp->inputs[asd->input_curr].type == TEST_PATTERN) {\n\t\tstruct ia_css_stream_config *s_config =\n\t\t\t    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream_config;\n\t\ts_config->mode = IA_CSS_INPUT_MODE_TPG;\n\t\ts_config->source.tpg.mode = IA_CSS_TPG_MODE_CHECKERBOARD;\n\t\ts_config->source.tpg.x_mask = (1 << 4) - 1;\n\t\ts_config->source.tpg.x_delta = -2;\n\t\ts_config->source.tpg.y_mask = (1 << 4) - 1;\n\t\ts_config->source.tpg.y_delta = 3;\n\t\ts_config->source.tpg.xy_mask = (1 << 8) - 1;\n\t\treturn;\n\t}\n\n\tif (mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR)\n\t\treturn;\n\n\tfor (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {\n\t\t \n\t\tstruct ia_css_stream_config *s_config =\n\t\t\t    &asd->stream_env[i].stream_config;\n\n\t\tif (s_config->input_config.input_res.width == 0)\n\t\t\tcontinue;\n\n\t\tif (ia_css_mipi_frame_calculate_size(\n\t\t\ts_config->input_config.input_res.width,\n\t\t\ts_config->input_config.input_res.height,\n\t\t\ts_config->input_config.format,\n\t\t\ttrue,\n\t\t\t0x13000,\n\t\t\t&size_mem_words) != 0) {\n\t\t\tif (IS_MRFD)\n\t\t\t\tsize_mem_words = CSS_MIPI_FRAME_BUFFER_SIZE_2;\n\t\t\telse\n\t\t\t\tsize_mem_words = CSS_MIPI_FRAME_BUFFER_SIZE_1;\n\t\t\tdev_warn(asd->isp->dev,\n\t\t\t\t \"ia_css_mipi_frame_calculate_size failed,applying pre-defined MIPI buffer size %u.\\n\",\n\t\t\t\t size_mem_words);\n\t\t}\n\t\ts_config->mipi_buffer_config.size_mem_words = size_mem_words;\n\t\ts_config->mipi_buffer_config.nof_mipi_buffers = 2;\n\t}\n}\n\nvoid atomisp_css_capture_enable_online(struct atomisp_sub_device *asd,\n\t\t\t\t       unsigned short stream_index, bool enable)\n{\n\tstruct atomisp_stream_env *stream_env =\n\t\t    &asd->stream_env[stream_index];\n\n\tif (stream_env->stream_config.online == !!enable)\n\t\treturn;\n\n\tstream_env->stream_config.online = !!enable;\n\tstream_env->update_pipe[IA_CSS_PIPE_ID_CAPTURE] = true;\n}\n\nvoid atomisp_css_preview_enable_online(struct atomisp_sub_device *asd,\n\t\t\t\t       unsigned short stream_index, bool enable)\n{\n\tstruct atomisp_stream_env *stream_env =\n\t\t    &asd->stream_env[stream_index];\n\tint i;\n\n\tif (stream_env->stream_config.online != !!enable) {\n\t\tstream_env->stream_config.online = !!enable;\n\t\tfor (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)\n\t\t\tstream_env->update_pipe[i] = true;\n\t}\n}\n\nint atomisp_css_input_configure_port(\n    struct atomisp_sub_device *asd,\n    enum mipi_port_id port,\n    unsigned int num_lanes,\n    unsigned int timeout,\n    unsigned int mipi_freq,\n    enum atomisp_input_format metadata_format,\n    unsigned int metadata_width,\n    unsigned int metadata_height)\n{\n\tint i;\n\tstruct atomisp_stream_env *stream_env;\n\t \n\tconst unsigned int rxcount =\n\t    min(((mipi_freq / 46000) - 1280) >> 10, 0xffU) * 0x01010101U;\n\n\tfor (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {\n\t\tstream_env = &asd->stream_env[i];\n\t\tstream_env->stream_config.source.port.port = port;\n\t\tstream_env->stream_config.source.port.num_lanes = num_lanes;\n\t\tstream_env->stream_config.source.port.timeout = timeout;\n\t\tif (mipi_freq)\n\t\t\tstream_env->stream_config.source.port.rxcount = rxcount;\n\t\tstream_env->stream_config.\n\t\tmetadata_config.data_type = metadata_format;\n\t\tstream_env->stream_config.\n\t\tmetadata_config.resolution.width = metadata_width;\n\t\tstream_env->stream_config.\n\t\tmetadata_config.resolution.height = metadata_height;\n\t}\n\n\treturn 0;\n}\n\nvoid atomisp_css_stop(struct atomisp_sub_device *asd, bool in_reset)\n{\n\tunsigned long irqflags;\n\tunsigned int i;\n\n\t \n\tatomisp_destroy_pipes_stream(asd);\n\n\tatomisp_init_raw_buffer_bitmap(asd);\n\n\tia_css_stop_sp();\n\n\tif (!in_reset) {\n\t\tstruct atomisp_stream_env *stream_env;\n\t\tint i, j;\n\n\t\tfor (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {\n\t\t\tstream_env = &asd->stream_env[i];\n\t\t\tfor (j = 0; j < IA_CSS_PIPE_ID_NUM; j++) {\n\t\t\t\tia_css_pipe_config_defaults(\n\t\t\t\t    &stream_env->pipe_configs[j]);\n\t\t\t\tia_css_pipe_extra_config_defaults(\n\t\t\t\t    &stream_env->pipe_extra_configs[j]);\n\t\t\t}\n\t\t\tia_css_stream_config_defaults(\n\t\t\t    &stream_env->stream_config);\n\t\t}\n\t\tmemset(&asd->params.config, 0, sizeof(asd->params.config));\n\t\tasd->params.css_update_params_needed = false;\n\t}\n\n\t \n\tlist_splice_init(&asd->s3a_stats_in_css, &asd->s3a_stats);\n\tlist_splice_init(&asd->s3a_stats_ready, &asd->s3a_stats);\n\n\tspin_lock_irqsave(&asd->dis_stats_lock, irqflags);\n\tlist_splice_init(&asd->dis_stats_in_css, &asd->dis_stats);\n\tasd->params.dis_proj_data_valid = false;\n\tspin_unlock_irqrestore(&asd->dis_stats_lock, irqflags);\n\n\tfor (i = 0; i < ATOMISP_METADATA_TYPE_NUM; i++) {\n\t\tlist_splice_init(&asd->metadata_in_css[i], &asd->metadata[i]);\n\t\tlist_splice_init(&asd->metadata_ready[i], &asd->metadata[i]);\n\t}\n\n\tatomisp_flush_params_queue(&asd->video_out);\n\tatomisp_free_css_parameters(&asd->params.css_param);\n\tmemset(&asd->params.css_param, 0, sizeof(asd->params.css_param));\n}\n\nvoid atomisp_css_continuous_set_num_raw_frames(\n     struct atomisp_sub_device *asd,\n     int num_frames)\n{\n\tif (asd->enable_raw_buffer_lock->val) {\n\t\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t\t.stream_config.init_num_cont_raw_buf =\n\t\t    ATOMISP_CSS2_NUM_OFFLINE_INIT_CONTINUOUS_FRAMES_LOCK_EN;\n\t\tif (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO &&\n\t\t    asd->params.video_dis_en)\n\t\t\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t\t\t.stream_config.init_num_cont_raw_buf +=\n\t\t\t    ATOMISP_CSS2_NUM_DVS_FRAME_DELAY;\n\t} else {\n\t\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t\t.stream_config.init_num_cont_raw_buf =\n\t\t    ATOMISP_CSS2_NUM_OFFLINE_INIT_CONTINUOUS_FRAMES;\n\t}\n\n\tif (asd->params.video_dis_en)\n\t\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t\t.stream_config.init_num_cont_raw_buf +=\n\t\t    ATOMISP_CSS2_NUM_DVS_FRAME_DELAY;\n\n\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t.stream_config.target_num_cont_raw_buf = num_frames;\n}\n\nstatic enum ia_css_pipe_mode __pipe_id_to_pipe_mode(\n    struct atomisp_sub_device *asd,\n    enum ia_css_pipe_id pipe_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct camera_mipi_info *mipi_info = atomisp_to_sensor_mipi_info(\n\t\tisp->inputs[asd->input_curr].camera);\n\n\tswitch (pipe_id) {\n\tcase IA_CSS_PIPE_ID_COPY:\n\t\t \n\t\tif (mipi_info && mipi_info->input_format ==\n\t\t    ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY)\n\t\t\treturn IA_CSS_PIPE_MODE_YUVPP;\n\t\treturn IA_CSS_PIPE_MODE_COPY;\n\tcase IA_CSS_PIPE_ID_PREVIEW:\n\t\treturn IA_CSS_PIPE_MODE_PREVIEW;\n\tcase IA_CSS_PIPE_ID_CAPTURE:\n\t\treturn IA_CSS_PIPE_MODE_CAPTURE;\n\tcase IA_CSS_PIPE_ID_VIDEO:\n\t\treturn IA_CSS_PIPE_MODE_VIDEO;\n\tcase IA_CSS_PIPE_ID_YUVPP:\n\t\treturn IA_CSS_PIPE_MODE_YUVPP;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn IA_CSS_PIPE_MODE_PREVIEW;\n\t}\n}\n\nstatic void __configure_output(struct atomisp_sub_device *asd,\n\t\t\t       unsigned int stream_index,\n\t\t\t       unsigned int width, unsigned int height,\n\t\t\t       unsigned int min_width,\n\t\t\t       enum ia_css_frame_format format,\n\t\t\t       enum ia_css_pipe_id pipe_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct atomisp_stream_env *stream_env =\n\t\t    &asd->stream_env[stream_index];\n\tstruct ia_css_stream_config *s_config = &stream_env->stream_config;\n\n\tstream_env->pipe_configs[pipe_id].mode =\n\t    __pipe_id_to_pipe_mode(asd, pipe_id);\n\tstream_env->update_pipe[pipe_id] = true;\n\n\tstream_env->pipe_configs[pipe_id].output_info[0].res.width = width;\n\tstream_env->pipe_configs[pipe_id].output_info[0].res.height = height;\n\tstream_env->pipe_configs[pipe_id].output_info[0].format = format;\n\tstream_env->pipe_configs[pipe_id].output_info[0].padded_width = min_width;\n\n\t \n\tif (width > s_config->input_config.effective_res.width ||\n\t    height > s_config->input_config.effective_res.height) {\n\t\ts_config->input_config.effective_res.width = width;\n\t\ts_config->input_config.effective_res.height = height;\n\t}\n\n\tdev_dbg(isp->dev, \"configuring pipe[%d] output info w=%d.h=%d.f=%d.\\n\",\n\t\tpipe_id, width, height, format);\n}\n\n \nstatic void __configure_capture_pp_input(struct atomisp_sub_device *asd,\n\tunsigned int width, unsigned int height,\n\tenum ia_css_pipe_id pipe_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct atomisp_stream_env *stream_env =\n\t\t    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];\n\tstruct ia_css_stream_config *stream_config = &stream_env->stream_config;\n\tstruct ia_css_pipe_config *pipe_configs =\n\t\t    &stream_env->pipe_configs[pipe_id];\n\tstruct ia_css_pipe_extra_config *pipe_extra_configs =\n\t\t    &stream_env->pipe_extra_configs[pipe_id];\n\tunsigned int hor_ds_factor = 0, ver_ds_factor = 0;\n\n\tif (width == 0 && height == 0)\n\t\treturn;\n\n\tif (width * 9 / 10 < pipe_configs->output_info[0].res.width ||\n\t    height * 9 / 10 < pipe_configs->output_info[0].res.height)\n\t\treturn;\n\t \n\thor_ds_factor = CEIL_DIV(width >> 1,\n\t\t\t\t pipe_configs->output_info[0].res.width);\n\tver_ds_factor = CEIL_DIV(height >> 1,\n\t\t\t\t pipe_configs->output_info[0].res.height);\n\n\tif ((asd->isp->media_dev.hw_revision <\n\t     (ATOMISP_HW_REVISION_ISP2401 << ATOMISP_HW_REVISION_SHIFT) ||\n\t     IS_CHT) && hor_ds_factor != ver_ds_factor) {\n\t\tdev_warn(asd->isp->dev,\n\t\t\t \"Cropping for capture due to FW limitation\");\n\t\treturn;\n\t}\n\n\tpipe_configs->mode = __pipe_id_to_pipe_mode(asd, pipe_id);\n\tstream_env->update_pipe[pipe_id] = true;\n\n\tpipe_extra_configs->enable_yuv_ds = true;\n\n\tpipe_configs->capt_pp_in_res.width =\n\t    stream_config->input_config.effective_res.width;\n\tpipe_configs->capt_pp_in_res.height =\n\t    stream_config->input_config.effective_res.height;\n\n\tdev_dbg(isp->dev, \"configuring pipe[%d]capture pp input w=%d.h=%d.\\n\",\n\t\tpipe_id, width, height);\n}\n\n \nstatic void __configure_preview_pp_input(struct atomisp_sub_device *asd,\n\tunsigned int width, unsigned int height,\n\tenum ia_css_pipe_id pipe_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tint out_width, out_height, yuv_ds_in_width, yuv_ds_in_height;\n\tstruct atomisp_stream_env *stream_env =\n\t\t    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];\n\tstruct ia_css_stream_config *stream_config = &stream_env->stream_config;\n\tstruct ia_css_pipe_config *pipe_configs =\n\t\t    &stream_env->pipe_configs[pipe_id];\n\tstruct ia_css_pipe_extra_config *pipe_extra_configs =\n\t\t    &stream_env->pipe_extra_configs[pipe_id];\n\tstruct ia_css_resolution *bayer_ds_out_res =\n\t\t    &pipe_configs->bayer_ds_out_res;\n\tstruct ia_css_resolution *vf_pp_in_res =\n\t\t    &pipe_configs->vf_pp_in_res;\n\tstruct ia_css_resolution  *effective_res =\n\t\t    &stream_config->input_config.effective_res;\n\n\tstatic const struct bayer_ds_factor bds_fct[] = {{2, 1}, {3, 2}, {5, 4} };\n\t \n\tstatic const unsigned int yuv_dec_fct[] = { 2 };\n\tunsigned int i;\n\n\tif (width == 0 && height == 0)\n\t\treturn;\n\n\tpipe_configs->mode = __pipe_id_to_pipe_mode(asd, pipe_id);\n\tstream_env->update_pipe[pipe_id] = true;\n\n\tout_width = pipe_configs->output_info[0].res.width;\n\tout_height = pipe_configs->output_info[0].res.height;\n\n\t \n\tif (stream_config->online || !stream_config->continuous ||\n\t    !pipe_extra_configs->enable_raw_binning) {\n\t\tbayer_ds_out_res->width = 0;\n\t\tbayer_ds_out_res->height = 0;\n\t} else {\n\t\tbayer_ds_out_res->width = effective_res->width;\n\t\tbayer_ds_out_res->height = effective_res->height;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(bds_fct); i++) {\n\t\t\tif (effective_res->width >= out_width *\n\t\t\t    bds_fct[i].numerator / bds_fct[i].denominator &&\n\t\t\t    effective_res->height >= out_height *\n\t\t\t    bds_fct[i].numerator / bds_fct[i].denominator) {\n\t\t\t\tbayer_ds_out_res->width =\n\t\t\t\t    effective_res->width *\n\t\t\t\t    bds_fct[i].denominator /\n\t\t\t\t    bds_fct[i].numerator;\n\t\t\t\tbayer_ds_out_res->height =\n\t\t\t\t    effective_res->height *\n\t\t\t\t    bds_fct[i].denominator /\n\t\t\t\t    bds_fct[i].numerator;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t \n\t \n\tif (bayer_ds_out_res->width == 0) {\n\t\tyuv_ds_in_width = effective_res->width;\n\t\tyuv_ds_in_height = effective_res->height;\n\t} else {\n\t\tyuv_ds_in_width = bayer_ds_out_res->width;\n\t\tyuv_ds_in_height = bayer_ds_out_res->height;\n\t}\n\n\tvf_pp_in_res->width = yuv_ds_in_width;\n\tvf_pp_in_res->height = yuv_ds_in_height;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(yuv_dec_fct); i++) {\n\t\tif (yuv_ds_in_width >= out_width * yuv_dec_fct[i] &&\n\t\t    yuv_ds_in_height >= out_height * yuv_dec_fct[i]) {\n\t\t\tvf_pp_in_res->width = yuv_ds_in_width / yuv_dec_fct[i];\n\t\t\tvf_pp_in_res->height = yuv_ds_in_height / yuv_dec_fct[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (vf_pp_in_res->width == out_width &&\n\t    vf_pp_in_res->height == out_height) {\n\t\tpipe_extra_configs->enable_yuv_ds = false;\n\t\tvf_pp_in_res->width = 0;\n\t\tvf_pp_in_res->height = 0;\n\t} else {\n\t\tpipe_extra_configs->enable_yuv_ds = true;\n\t}\n\n\tdev_dbg(isp->dev, \"configuring pipe[%d]preview pp input w=%d.h=%d.\\n\",\n\t\tpipe_id, width, height);\n}\n\n \nstatic void __configure_video_pp_input(struct atomisp_sub_device *asd,\n\t\t\t\t       unsigned int width, unsigned int height,\n\t\t\t\t       enum ia_css_pipe_id pipe_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tint out_width, out_height;\n\tstruct atomisp_stream_env *stream_env =\n\t\t    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];\n\tstruct ia_css_stream_config *stream_config = &stream_env->stream_config;\n\tstruct ia_css_pipe_config *pipe_configs =\n\t\t    &stream_env->pipe_configs[pipe_id];\n\tstruct ia_css_pipe_extra_config *pipe_extra_configs =\n\t\t    &stream_env->pipe_extra_configs[pipe_id];\n\tstruct ia_css_resolution *bayer_ds_out_res =\n\t\t    &pipe_configs->bayer_ds_out_res;\n\tstruct ia_css_resolution  *effective_res =\n\t\t    &stream_config->input_config.effective_res;\n\n\tstatic const struct bayer_ds_factor bds_factors[] = {\n\t\t{8, 1}, {6, 1}, {4, 1}, {3, 1}, {2, 1}, {3, 2}\n\t};\n\tunsigned int i;\n\n\tif (width == 0 && height == 0)\n\t\treturn;\n\n\tpipe_configs->mode = __pipe_id_to_pipe_mode(asd, pipe_id);\n\tstream_env->update_pipe[pipe_id] = true;\n\n\tpipe_extra_configs->enable_yuv_ds = false;\n\n\t \n\t \n\tif (asd->params.video_dis_en) {\n\t\tout_width = pipe_configs->output_info[0].res.width * 110 / 100;\n\t\tout_height = pipe_configs->output_info[0].res.height * 110 / 100;\n\t} else {\n\t\tout_width = pipe_configs->output_info[0].res.width;\n\t\tout_height = pipe_configs->output_info[0].res.height;\n\t}\n\n\t \n\tif (stream_config->online || !stream_config->continuous) {\n\t\tbayer_ds_out_res->width = 0;\n\t\tbayer_ds_out_res->height = 0;\n\t\tgoto done;\n\t}\n\n\tpipe_extra_configs->enable_raw_binning = true;\n\tbayer_ds_out_res->width = effective_res->width;\n\tbayer_ds_out_res->height = effective_res->height;\n\n\tfor (i = 0; i < sizeof(bds_factors) / sizeof(struct bayer_ds_factor);\n\t     i++) {\n\t\tif (effective_res->width >= out_width *\n\t\t    bds_factors[i].numerator / bds_factors[i].denominator &&\n\t\t    effective_res->height >= out_height *\n\t\t    bds_factors[i].numerator / bds_factors[i].denominator) {\n\t\t\tbayer_ds_out_res->width = effective_res->width *\n\t\t\t\t\t\t  bds_factors[i].denominator /\n\t\t\t\t\t\t  bds_factors[i].numerator;\n\t\t\tbayer_ds_out_res->height = effective_res->height *\n\t\t\t\t\t\t   bds_factors[i].denominator /\n\t\t\t\t\t\t   bds_factors[i].numerator;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tpipe_configs->dvs_envelope.width = 12;\n\tpipe_configs->dvs_envelope.height = 12;\n\ndone:\n\tif (pipe_id == IA_CSS_PIPE_ID_YUVPP)\n\t\tstream_config->left_padding = -1;\n\telse\n\t\tstream_config->left_padding = 12;\n\tdev_dbg(isp->dev, \"configuring pipe[%d]video pp input w=%d.h=%d.\\n\",\n\t\tpipe_id, width, height);\n}\n\nstatic void __configure_vf_output(struct atomisp_sub_device *asd,\n\t\t\t\t  unsigned int width, unsigned int height,\n\t\t\t\t  unsigned int min_width,\n\t\t\t\t  enum ia_css_frame_format format,\n\t\t\t\t  enum ia_css_pipe_id pipe_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct atomisp_stream_env *stream_env =\n\t\t    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];\n\tstream_env->pipe_configs[pipe_id].mode =\n\t    __pipe_id_to_pipe_mode(asd, pipe_id);\n\tstream_env->update_pipe[pipe_id] = true;\n\n\tstream_env->pipe_configs[pipe_id].vf_output_info[0].res.width = width;\n\tstream_env->pipe_configs[pipe_id].vf_output_info[0].res.height = height;\n\tstream_env->pipe_configs[pipe_id].vf_output_info[0].format = format;\n\tstream_env->pipe_configs[pipe_id].vf_output_info[0].padded_width =\n\t    min_width;\n\tdev_dbg(isp->dev,\n\t\t\"configuring pipe[%d] vf output info w=%d.h=%d.f=%d.\\n\",\n\t\tpipe_id, width, height, format);\n}\n\nstatic int __get_frame_info(struct atomisp_sub_device *asd,\n\t\t\t    unsigned int stream_index,\n\t\t\t    struct ia_css_frame_info *info,\n\t\t\t    enum frame_info_type type,\n\t\t\t    enum ia_css_pipe_id pipe_id)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tint ret;\n\tstruct ia_css_pipe_info p_info;\n\n\t \n\tret = atomisp_css_update_stream(asd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ia_css_pipe_get_info(asd->stream_env[stream_index].pipes[pipe_id],\n\t\t\t\t   &p_info);\n\tif (ret) {\n\t\tdev_err(isp->dev, \"can't get info from pipe\\n\");\n\t\tgoto get_info_err;\n\t}\n\n\tswitch (type) {\n\tcase ATOMISP_CSS_VF_FRAME:\n\t\t*info = p_info.vf_output_info[0];\n\t\tdev_dbg(isp->dev, \"getting vf frame info.\\n\");\n\t\tbreak;\n\tcase ATOMISP_CSS_SECOND_VF_FRAME:\n\t\t*info = p_info.vf_output_info[1];\n\t\tdev_dbg(isp->dev, \"getting second vf frame info.\\n\");\n\t\tbreak;\n\tcase ATOMISP_CSS_OUTPUT_FRAME:\n\t\t*info = p_info.output_info[0];\n\t\tdev_dbg(isp->dev, \"getting main frame info.\\n\");\n\t\tbreak;\n\tcase ATOMISP_CSS_SECOND_OUTPUT_FRAME:\n\t\t*info = p_info.output_info[1];\n\t\tdev_dbg(isp->dev, \"getting second main frame info.\\n\");\n\t\tbreak;\n\tdefault:\n\tcase ATOMISP_CSS_RAW_FRAME:\n\t\t*info = p_info.raw_output_info;\n\t\tdev_dbg(isp->dev, \"getting raw frame info.\\n\");\n\t\tbreak;\n\t}\n\tdev_dbg(isp->dev, \"get frame info: w=%d, h=%d, num_invalid_frames %d.\\n\",\n\t\tinfo->res.width, info->res.height, p_info.num_invalid_frames);\n\n\treturn 0;\n\nget_info_err:\n\tatomisp_destroy_pipes_stream(asd);\n\treturn -EINVAL;\n}\n\nstatic unsigned int atomisp_get_pipe_index(struct atomisp_sub_device *asd)\n{\n\tif (asd->copy_mode)\n\t\treturn IA_CSS_PIPE_ID_COPY;\n\n\tswitch (asd->run_mode->val) {\n\tcase ATOMISP_RUN_MODE_VIDEO:\n\t\treturn IA_CSS_PIPE_ID_VIDEO;\n\tcase ATOMISP_RUN_MODE_STILL_CAPTURE:\n\t\treturn IA_CSS_PIPE_ID_CAPTURE;\n\tcase ATOMISP_RUN_MODE_PREVIEW:\n\t\treturn IA_CSS_PIPE_ID_PREVIEW;\n\t}\n\n\tdev_warn(asd->isp->dev, \"cannot determine pipe-index return default preview pipe\\n\");\n\treturn IA_CSS_PIPE_ID_PREVIEW;\n}\n\nint atomisp_get_css_frame_info(struct atomisp_sub_device *asd,\n\t\t\t       struct ia_css_frame_info *frame_info)\n{\n\tstruct ia_css_pipe_info info;\n\tint pipe_index = atomisp_get_pipe_index(asd);\n\tint stream_index;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tstream_index = (pipe_index == IA_CSS_PIPE_ID_YUVPP) ?\n\t\t\t       ATOMISP_INPUT_STREAM_VIDEO :\n\t\t\t       ATOMISP_INPUT_STREAM_GENERAL;\n\n\tif (0 != ia_css_pipe_get_info(asd->stream_env[stream_index]\n\t\t.pipes[pipe_index], &info)) {\n\t\tdev_dbg(isp->dev, \"ia_css_pipe_get_info FAILED\");\n\t\treturn -EINVAL;\n\t}\n\n\t*frame_info = info.output_info[0];\n\treturn 0;\n}\n\nint atomisp_css_copy_configure_output(struct atomisp_sub_device *asd,\n\t\t\t\t      unsigned int stream_index,\n\t\t\t\t      unsigned int width, unsigned int height,\n\t\t\t\t      unsigned int padded_width,\n\t\t\t\t      enum ia_css_frame_format format)\n{\n\tasd->stream_env[stream_index].pipe_configs[IA_CSS_PIPE_ID_COPY].\n\tdefault_capture_config.mode =\n\t    IA_CSS_CAPTURE_MODE_RAW;\n\n\t__configure_output(asd, stream_index, width, height, padded_width,\n\t\t\t   format, IA_CSS_PIPE_ID_COPY);\n\treturn 0;\n}\n\nint atomisp_css_preview_configure_output(struct atomisp_sub_device *asd,\n\tunsigned int width, unsigned int height,\n\tunsigned int min_width,\n\tenum ia_css_frame_format format)\n{\n\t__configure_output(asd, ATOMISP_INPUT_STREAM_GENERAL, width, height,\n\t\t\t   min_width, format, IA_CSS_PIPE_ID_PREVIEW);\n\treturn 0;\n}\n\nint atomisp_css_capture_configure_output(struct atomisp_sub_device *asd,\n\tunsigned int width, unsigned int height,\n\tunsigned int min_width,\n\tenum ia_css_frame_format format)\n{\n\t__configure_output(asd, ATOMISP_INPUT_STREAM_GENERAL, width, height,\n\t\t\t   min_width, format, IA_CSS_PIPE_ID_CAPTURE);\n\treturn 0;\n}\n\nint atomisp_css_video_configure_output(struct atomisp_sub_device *asd,\n\t\t\t\t       unsigned int width, unsigned int height,\n\t\t\t\t       unsigned int min_width,\n\t\t\t\t       enum ia_css_frame_format format)\n{\n\t__configure_output(asd, ATOMISP_INPUT_STREAM_GENERAL, width, height,\n\t\t\t   min_width, format, IA_CSS_PIPE_ID_VIDEO);\n\treturn 0;\n}\n\nint atomisp_css_video_configure_viewfinder(\n    struct atomisp_sub_device *asd,\n    unsigned int width, unsigned int height,\n    unsigned int min_width,\n    enum ia_css_frame_format format)\n{\n\t__configure_vf_output(asd, width, height, min_width, format,\n\t\t\t      IA_CSS_PIPE_ID_VIDEO);\n\treturn 0;\n}\n\nint atomisp_css_capture_configure_viewfinder(\n    struct atomisp_sub_device *asd,\n    unsigned int width, unsigned int height,\n    unsigned int min_width,\n    enum ia_css_frame_format format)\n{\n\t__configure_vf_output(asd, width, height, min_width, format, IA_CSS_PIPE_ID_CAPTURE);\n\treturn 0;\n}\n\nint atomisp_css_video_get_viewfinder_frame_info(\n    struct atomisp_sub_device *asd,\n    struct ia_css_frame_info *info)\n{\n\treturn __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,\n\t\t\t\tATOMISP_CSS_VF_FRAME, IA_CSS_PIPE_ID_VIDEO);\n}\n\nint atomisp_css_capture_get_viewfinder_frame_info(\n    struct atomisp_sub_device *asd,\n    struct ia_css_frame_info *info)\n{\n\treturn __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,\n\t\t\t\tATOMISP_CSS_VF_FRAME, IA_CSS_PIPE_ID_CAPTURE);\n}\n\nint atomisp_css_copy_get_output_frame_info(\n    struct atomisp_sub_device *asd,\n    unsigned int stream_index,\n    struct ia_css_frame_info *info)\n{\n\treturn __get_frame_info(asd, stream_index, info,\n\t\t\t\tATOMISP_CSS_OUTPUT_FRAME, IA_CSS_PIPE_ID_COPY);\n}\n\nint atomisp_css_preview_get_output_frame_info(\n    struct atomisp_sub_device *asd,\n    struct ia_css_frame_info *info)\n{\n\treturn __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,\n\t\t\t\tATOMISP_CSS_OUTPUT_FRAME, IA_CSS_PIPE_ID_PREVIEW);\n}\n\nint atomisp_css_capture_get_output_frame_info(\n    struct atomisp_sub_device *asd,\n    struct ia_css_frame_info *info)\n{\n\treturn __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,\n\t\t\t\tATOMISP_CSS_OUTPUT_FRAME, IA_CSS_PIPE_ID_CAPTURE);\n}\n\nint atomisp_css_video_get_output_frame_info(\n    struct atomisp_sub_device *asd,\n    struct ia_css_frame_info *info)\n{\n\treturn __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,\n\t\t\t\tATOMISP_CSS_OUTPUT_FRAME, IA_CSS_PIPE_ID_VIDEO);\n}\n\nint atomisp_css_preview_configure_pp_input(\n    struct atomisp_sub_device *asd,\n    unsigned int width, unsigned int height)\n{\n\tstruct atomisp_stream_env *stream_env =\n\t\t    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];\n\t__configure_preview_pp_input(asd, width, height, IA_CSS_PIPE_ID_PREVIEW);\n\n\tif (width > stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE].\n\t    capt_pp_in_res.width)\n\t\t__configure_capture_pp_input(asd, width, height, IA_CSS_PIPE_ID_CAPTURE);\n\n\treturn 0;\n}\n\nint atomisp_css_capture_configure_pp_input(\n    struct atomisp_sub_device *asd,\n    unsigned int width, unsigned int height)\n{\n\t__configure_capture_pp_input(asd, width, height, IA_CSS_PIPE_ID_CAPTURE);\n\treturn 0;\n}\n\nint atomisp_css_video_configure_pp_input(\n    struct atomisp_sub_device *asd,\n    unsigned int width, unsigned int height)\n{\n\tstruct atomisp_stream_env *stream_env =\n\t\t    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];\n\n\t__configure_video_pp_input(asd, width, height, IA_CSS_PIPE_ID_VIDEO);\n\n\tif (width > stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE].\n\t    capt_pp_in_res.width)\n\t\t__configure_capture_pp_input(asd, width, height, IA_CSS_PIPE_ID_CAPTURE);\n\n\treturn 0;\n}\n\nint atomisp_css_offline_capture_configure(struct atomisp_sub_device *asd,\n\tint num_captures, unsigned int skip, int offset)\n{\n\tint ret;\n\n\tdev_dbg(asd->isp->dev, \"%s num_capture:%d skip:%d offset:%d\\n\",\n\t\t__func__, num_captures, skip, offset);\n\n\tret = ia_css_stream_capture(\n\t\t  asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t\t  num_captures, skip, offset);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint atomisp_css_exp_id_capture(struct atomisp_sub_device *asd, int exp_id)\n{\n\tint ret;\n\n\tret = ia_css_stream_capture_frame(\n\t\t  asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t\t  exp_id);\n\tif (ret == -ENOBUFS) {\n\t\t \n\t\treturn -EBUSY;\n\t} else if (ret) {\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint atomisp_css_exp_id_unlock(struct atomisp_sub_device *asd, int exp_id)\n{\n\tint ret;\n\n\tret = ia_css_unlock_raw_frame(\n\t\t  asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t\t  exp_id);\n\tif (ret == -ENOBUFS)\n\t\treturn -EAGAIN;\n\telse if (ret)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint atomisp_css_capture_enable_xnr(struct atomisp_sub_device *asd,\n\t\t\t\t   bool enable)\n{\n\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t.pipe_configs[IA_CSS_PIPE_ID_CAPTURE]\n\t.default_capture_config.enable_xnr = enable;\n\tasd->params.capture_config.enable_xnr = enable;\n\tasd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]\n\t.update_pipe[IA_CSS_PIPE_ID_CAPTURE] = true;\n\n\treturn 0;\n}\n\nvoid atomisp_css_set_ctc_table(struct atomisp_sub_device *asd,\n\t\t\t       struct ia_css_ctc_table *ctc_table)\n{\n\tint i;\n\tu16 *vamem_ptr = ctc_table->data.vamem_1;\n\tint data_size = IA_CSS_VAMEM_1_CTC_TABLE_SIZE;\n\tbool valid = false;\n\n\t \n\tif (ctc_table->vamem_type == IA_CSS_VAMEM_TYPE_2) {\n\t\tvamem_ptr = ctc_table->data.vamem_2;\n\t\tdata_size = IA_CSS_VAMEM_2_CTC_TABLE_SIZE;\n\t}\n\n\tfor (i = 0; i < data_size; i++) {\n\t\tif (*(vamem_ptr + i)) {\n\t\t\tvalid = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (valid)\n\t\tasd->params.config.ctc_table = ctc_table;\n\telse\n\t\tdev_warn(asd->isp->dev, \"Bypass the invalid ctc_table.\\n\");\n}\n\nvoid atomisp_css_set_anr_thres(struct atomisp_sub_device *asd,\n\t\t\t       struct ia_css_anr_thres *anr_thres)\n{\n\tasd->params.config.anr_thres = anr_thres;\n}\n\nvoid atomisp_css_set_dvs_6axis(struct atomisp_sub_device *asd,\n\t\t\t       struct ia_css_dvs_6axis_config *dvs_6axis)\n{\n\tasd->params.config.dvs_6axis_config = dvs_6axis;\n}\n\nvoid atomisp_css_video_set_dis_vector(struct atomisp_sub_device *asd,\n\t\t\t\t      struct atomisp_dis_vector *vector)\n{\n\tif (!asd->params.config.motion_vector)\n\t\tasd->params.config.motion_vector = &asd->params.css_param.motion_vector;\n\n\tmemset(asd->params.config.motion_vector,\n\t       0, sizeof(struct ia_css_vector));\n\tasd->params.css_param.motion_vector.x = vector->x;\n\tasd->params.css_param.motion_vector.y = vector->y;\n}\n\nstatic int atomisp_compare_dvs_grid(struct atomisp_sub_device *asd,\n\t\t\t\t    struct atomisp_dvs_grid_info *atomgrid)\n{\n\tstruct ia_css_dvs_grid_info *cur =\n\t    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);\n\n\tif (!cur) {\n\t\tdev_err(asd->isp->dev, \"dvs grid not available!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sizeof(*cur) != sizeof(*atomgrid)) {\n\t\tdev_err(asd->isp->dev, \"dvs grid mismatch!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cur->enable) {\n\t\tdev_err(asd->isp->dev, \"dvs not enabled!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn memcmp(atomgrid, cur, sizeof(*cur));\n}\n\nvoid  atomisp_css_set_dvs2_coefs(struct atomisp_sub_device *asd,\n\t\t\t\t struct ia_css_dvs2_coefficients *coefs)\n{\n\tasd->params.config.dvs2_coefs = coefs;\n}\n\nint atomisp_css_set_dis_coefs(struct atomisp_sub_device *asd,\n\t\t\t      struct atomisp_dis_coefficients *coefs)\n{\n\tif (atomisp_compare_dvs_grid(asd, &coefs->grid_info) != 0)\n\t\t \n\t\treturn -EAGAIN;\n\n\tif (!coefs->hor_coefs.odd_real ||\n\t    !coefs->hor_coefs.odd_imag ||\n\t    !coefs->hor_coefs.even_real ||\n\t    !coefs->hor_coefs.even_imag ||\n\t    !coefs->ver_coefs.odd_real ||\n\t    !coefs->ver_coefs.odd_imag ||\n\t    !coefs->ver_coefs.even_real ||\n\t    !coefs->ver_coefs.even_imag ||\n\t    !asd->params.css_param.dvs2_coeff->hor_coefs.odd_real ||\n\t    !asd->params.css_param.dvs2_coeff->hor_coefs.odd_imag ||\n\t    !asd->params.css_param.dvs2_coeff->hor_coefs.even_real ||\n\t    !asd->params.css_param.dvs2_coeff->hor_coefs.even_imag ||\n\t    !asd->params.css_param.dvs2_coeff->ver_coefs.odd_real ||\n\t    !asd->params.css_param.dvs2_coeff->ver_coefs.odd_imag ||\n\t    !asd->params.css_param.dvs2_coeff->ver_coefs.even_real ||\n\t    !asd->params.css_param.dvs2_coeff->ver_coefs.even_imag)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(asd->params.css_param.dvs2_coeff->hor_coefs.odd_real,\n\t\t\t   coefs->hor_coefs.odd_real, asd->params.dvs_hor_coef_bytes))\n\t\treturn -EFAULT;\n\tif (copy_from_user(asd->params.css_param.dvs2_coeff->hor_coefs.odd_imag,\n\t\t\t   coefs->hor_coefs.odd_imag, asd->params.dvs_hor_coef_bytes))\n\t\treturn -EFAULT;\n\tif (copy_from_user(asd->params.css_param.dvs2_coeff->hor_coefs.even_real,\n\t\t\t   coefs->hor_coefs.even_real, asd->params.dvs_hor_coef_bytes))\n\t\treturn -EFAULT;\n\tif (copy_from_user(asd->params.css_param.dvs2_coeff->hor_coefs.even_imag,\n\t\t\t   coefs->hor_coefs.even_imag, asd->params.dvs_hor_coef_bytes))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(asd->params.css_param.dvs2_coeff->ver_coefs.odd_real,\n\t\t\t   coefs->ver_coefs.odd_real, asd->params.dvs_ver_coef_bytes))\n\t\treturn -EFAULT;\n\tif (copy_from_user(asd->params.css_param.dvs2_coeff->ver_coefs.odd_imag,\n\t\t\t   coefs->ver_coefs.odd_imag, asd->params.dvs_ver_coef_bytes))\n\t\treturn -EFAULT;\n\tif (copy_from_user(asd->params.css_param.dvs2_coeff->ver_coefs.even_real,\n\t\t\t   coefs->ver_coefs.even_real, asd->params.dvs_ver_coef_bytes))\n\t\treturn -EFAULT;\n\tif (copy_from_user(asd->params.css_param.dvs2_coeff->ver_coefs.even_imag,\n\t\t\t   coefs->ver_coefs.even_imag, asd->params.dvs_ver_coef_bytes))\n\t\treturn -EFAULT;\n\n\tasd->params.css_param.update_flag.dvs2_coefs =\n\t\t(struct atomisp_dis_coefficients *)\n\t\tasd->params.css_param.dvs2_coeff;\n\t \n\t \n\tasd->params.css_update_params_needed = true;\n\n\treturn 0;\n}\n\nvoid atomisp_css_set_zoom_factor(struct atomisp_sub_device *asd,\n\t\t\t\t unsigned int zoom)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (zoom == asd->params.css_param.dz_config.dx &&\n\t    zoom == asd->params.css_param.dz_config.dy) {\n\t\tdev_dbg(isp->dev, \"same zoom scale. skipped.\\n\");\n\t\treturn;\n\t}\n\n\tmemset(&asd->params.css_param.dz_config, 0,\n\t       sizeof(struct ia_css_dz_config));\n\tasd->params.css_param.dz_config.dx = zoom;\n\tasd->params.css_param.dz_config.dy = zoom;\n\n\tasd->params.css_param.update_flag.dz_config =\n\t    (struct atomisp_dz_config *)&asd->params.css_param.dz_config;\n\tasd->params.css_update_params_needed = true;\n}\n\nvoid atomisp_css_set_formats_config(struct atomisp_sub_device *asd,\n\t\t\t\t    struct ia_css_formats_config *formats_config)\n{\n\tasd->params.config.formats_config = formats_config;\n}\n\nint atomisp_css_get_wb_config(struct atomisp_sub_device *asd,\n\t\t\t      struct atomisp_wb_config *config)\n{\n\tstruct ia_css_wb_config wb_config;\n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev, \"%s called after streamoff, skipping.\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tmemset(&wb_config, 0, sizeof(struct ia_css_wb_config));\n\tmemset(&isp_config, 0, sizeof(struct ia_css_isp_config));\n\tisp_config.wb_config = &wb_config;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n\tmemcpy(config, &wb_config, sizeof(*config));\n\n\treturn 0;\n}\n\nint atomisp_css_get_ob_config(struct atomisp_sub_device *asd,\n\t\t\t      struct atomisp_ob_config *config)\n{\n\tstruct ia_css_ob_config ob_config;\n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev, \"%s called after streamoff, skipping.\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tmemset(&ob_config, 0, sizeof(struct ia_css_ob_config));\n\tmemset(&isp_config, 0, sizeof(struct ia_css_isp_config));\n\tisp_config.ob_config = &ob_config;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n\tmemcpy(config, &ob_config, sizeof(*config));\n\n\treturn 0;\n}\n\nint atomisp_css_get_dp_config(struct atomisp_sub_device *asd,\n\t\t\t      struct atomisp_dp_config *config)\n{\n\tstruct ia_css_dp_config dp_config;\n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev, \"%s called after streamoff, skipping.\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tmemset(&dp_config, 0, sizeof(struct ia_css_dp_config));\n\tmemset(&isp_config, 0, sizeof(struct ia_css_isp_config));\n\tisp_config.dp_config = &dp_config;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n\tmemcpy(config, &dp_config, sizeof(*config));\n\n\treturn 0;\n}\n\nint atomisp_css_get_de_config(struct atomisp_sub_device *asd,\n\t\t\t      struct atomisp_de_config *config)\n{\n\tstruct ia_css_de_config de_config;\n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev, \"%s called after streamoff, skipping.\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tmemset(&de_config, 0, sizeof(struct ia_css_de_config));\n\tmemset(&isp_config, 0, sizeof(struct ia_css_isp_config));\n\tisp_config.de_config = &de_config;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n\tmemcpy(config, &de_config, sizeof(*config));\n\n\treturn 0;\n}\n\nint atomisp_css_get_nr_config(struct atomisp_sub_device *asd,\n\t\t\t      struct atomisp_nr_config *config)\n{\n\tstruct ia_css_nr_config nr_config;\n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev, \"%s called after streamoff, skipping.\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tmemset(&nr_config, 0, sizeof(struct ia_css_nr_config));\n\tmemset(&isp_config, 0, sizeof(struct ia_css_isp_config));\n\n\tisp_config.nr_config = &nr_config;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n\tmemcpy(config, &nr_config, sizeof(*config));\n\n\treturn 0;\n}\n\nint atomisp_css_get_ee_config(struct atomisp_sub_device *asd,\n\t\t\t      struct atomisp_ee_config *config)\n{\n\tstruct ia_css_ee_config ee_config;\n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev, \"%s called after streamoff, skipping.\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tmemset(&ee_config, 0, sizeof(struct ia_css_ee_config));\n\tmemset(&isp_config, 0, sizeof(struct ia_css_isp_config));\n\tisp_config.ee_config = &ee_config;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n\tmemcpy(config, &ee_config, sizeof(*config));\n\n\treturn 0;\n}\n\nint atomisp_css_get_tnr_config(struct atomisp_sub_device *asd,\n\t\t\t       struct atomisp_tnr_config *config)\n{\n\tstruct ia_css_tnr_config tnr_config;\n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev, \"%s called after streamoff, skipping.\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tmemset(&tnr_config, 0, sizeof(struct ia_css_tnr_config));\n\tmemset(&isp_config, 0, sizeof(struct ia_css_isp_config));\n\tisp_config.tnr_config = &tnr_config;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n\tmemcpy(config, &tnr_config, sizeof(*config));\n\n\treturn 0;\n}\n\nint atomisp_css_get_ctc_table(struct atomisp_sub_device *asd,\n\t\t\t      struct atomisp_ctc_table *config)\n{\n\tstruct ia_css_ctc_table *tab;\n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev, \"%s called after streamoff, skipping.\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\ttab = vzalloc(sizeof(struct ia_css_ctc_table));\n\tif (!tab)\n\t\treturn -ENOMEM;\n\n\tmemset(&isp_config, 0, sizeof(struct ia_css_isp_config));\n\tisp_config.ctc_table = tab;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n\tmemcpy(config, tab, sizeof(*tab));\n\tvfree(tab);\n\n\treturn 0;\n}\n\nint atomisp_css_get_gamma_table(struct atomisp_sub_device *asd,\n\t\t\t\tstruct atomisp_gamma_table *config)\n{\n\tstruct ia_css_gamma_table *tab;\n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev, \"%s called after streamoff, skipping.\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\ttab = vzalloc(sizeof(struct ia_css_gamma_table));\n\tif (!tab)\n\t\treturn -ENOMEM;\n\n\tmemset(&isp_config, 0, sizeof(struct ia_css_isp_config));\n\tisp_config.gamma_table = tab;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n\tmemcpy(config, tab, sizeof(*tab));\n\tvfree(tab);\n\n\treturn 0;\n}\n\nint atomisp_css_get_gc_config(struct atomisp_sub_device *asd,\n\t\t\t      struct atomisp_gc_config *config)\n{\n\tstruct ia_css_gc_config gc_config;\n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev, \"%s called after streamoff, skipping.\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tmemset(&gc_config, 0, sizeof(struct ia_css_gc_config));\n\tmemset(&isp_config, 0, sizeof(struct ia_css_isp_config));\n\tisp_config.gc_config = &gc_config;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n\t \n\tmemcpy(config, &gc_config, sizeof(*config));\n\n\treturn 0;\n}\n\nint atomisp_css_get_3a_config(struct atomisp_sub_device *asd,\n\t\t\t      struct atomisp_3a_config *config)\n{\n\tstruct ia_css_3a_config s3a_config;\n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev, \"%s called after streamoff, skipping.\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tmemset(&s3a_config, 0, sizeof(struct ia_css_3a_config));\n\tmemset(&isp_config, 0, sizeof(struct ia_css_isp_config));\n\tisp_config.s3a_config = &s3a_config;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n\t \n\tmemcpy(config, &s3a_config, sizeof(*config));\n\n\treturn 0;\n}\n\nint atomisp_css_get_formats_config(struct atomisp_sub_device *asd,\n\t\t\t\t   struct atomisp_formats_config *config)\n{\n\tstruct ia_css_formats_config formats_config;\n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev, \"%s called after streamoff, skipping.\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tmemset(&formats_config, 0, sizeof(formats_config));\n\tmemset(&isp_config, 0, sizeof(isp_config));\n\tisp_config.formats_config = &formats_config;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n\t \n\tmemcpy(config, &formats_config, sizeof(*config));\n\n\treturn 0;\n}\n\nint atomisp_css_get_zoom_factor(struct atomisp_sub_device *asd,\n\t\t\t\tunsigned int *zoom)\n{\n\tstruct ia_css_dz_config dz_config;   \n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev, \"%s called after streamoff, skipping.\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tmemset(&dz_config, 0, sizeof(struct ia_css_dz_config));\n\tmemset(&isp_config, 0, sizeof(struct ia_css_isp_config));\n\tisp_config.dz_config = &dz_config;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n\t*zoom = dz_config.dx;\n\n\treturn 0;\n}\n\n \nint atomisp_css_get_dis_stat(struct atomisp_sub_device *asd,\n\t\t\t     struct atomisp_dis_statistics *stats)\n{\n\tstruct atomisp_device *isp = asd->isp;\n\tstruct atomisp_dis_buf *dis_buf;\n\tunsigned long flags;\n\n\tlockdep_assert_held(&isp->mutex);\n\n\tif (!asd->params.dvs_stat->hor_prod.odd_real ||\n\t    !asd->params.dvs_stat->hor_prod.odd_imag ||\n\t    !asd->params.dvs_stat->hor_prod.even_real ||\n\t    !asd->params.dvs_stat->hor_prod.even_imag ||\n\t    !asd->params.dvs_stat->ver_prod.odd_real ||\n\t    !asd->params.dvs_stat->ver_prod.odd_imag ||\n\t    !asd->params.dvs_stat->ver_prod.even_real ||\n\t    !asd->params.dvs_stat->ver_prod.even_imag)\n\t\treturn -EINVAL;\n\n\t \n\tif (!asd->streaming)\n\t\treturn -EINVAL;\n\n\tif (atomisp_compare_dvs_grid(asd, &stats->dvs2_stat.grid_info) != 0)\n\t\t \n\t\treturn -EAGAIN;\n\n\tspin_lock_irqsave(&asd->dis_stats_lock, flags);\n\tif (!asd->params.dis_proj_data_valid || list_empty(&asd->dis_stats)) {\n\t\tspin_unlock_irqrestore(&asd->dis_stats_lock, flags);\n\t\tdev_err(isp->dev, \"dis statistics is not valid.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tdis_buf = list_entry(asd->dis_stats.next,\n\t\t\t     struct atomisp_dis_buf, list);\n\tlist_del_init(&dis_buf->list);\n\tspin_unlock_irqrestore(&asd->dis_stats_lock, flags);\n\n\tif (dis_buf->dvs_map)\n\t\tia_css_translate_dvs2_statistics(\n\t\t    asd->params.dvs_stat, dis_buf->dvs_map);\n\telse\n\t\tia_css_get_dvs2_statistics(asd->params.dvs_stat,\n\t\t\t\t\t   dis_buf->dis_data);\n\tstats->exp_id = dis_buf->dis_data->exp_id;\n\n\tspin_lock_irqsave(&asd->dis_stats_lock, flags);\n\tlist_add_tail(&dis_buf->list, &asd->dis_stats);\n\tspin_unlock_irqrestore(&asd->dis_stats_lock, flags);\n\n\tif (copy_to_user(stats->dvs2_stat.ver_prod.odd_real,\n\t\t\t asd->params.dvs_stat->ver_prod.odd_real,\n\t\t\t asd->params.dvs_ver_proj_bytes))\n\t\treturn -EFAULT;\n\tif (copy_to_user(stats->dvs2_stat.ver_prod.odd_imag,\n\t\t\t asd->params.dvs_stat->ver_prod.odd_imag,\n\t\t\t asd->params.dvs_ver_proj_bytes))\n\t\treturn -EFAULT;\n\tif (copy_to_user(stats->dvs2_stat.ver_prod.even_real,\n\t\t\t asd->params.dvs_stat->ver_prod.even_real,\n\t\t\t asd->params.dvs_ver_proj_bytes))\n\t\treturn -EFAULT;\n\tif (copy_to_user(stats->dvs2_stat.ver_prod.even_imag,\n\t\t\t asd->params.dvs_stat->ver_prod.even_imag,\n\t\t\t asd->params.dvs_ver_proj_bytes))\n\t\treturn -EFAULT;\n\tif (copy_to_user(stats->dvs2_stat.hor_prod.odd_real,\n\t\t\t asd->params.dvs_stat->hor_prod.odd_real,\n\t\t\t asd->params.dvs_hor_proj_bytes))\n\t\treturn -EFAULT;\n\tif (copy_to_user(stats->dvs2_stat.hor_prod.odd_imag,\n\t\t\t asd->params.dvs_stat->hor_prod.odd_imag,\n\t\t\t asd->params.dvs_hor_proj_bytes))\n\t\treturn -EFAULT;\n\tif (copy_to_user(stats->dvs2_stat.hor_prod.even_real,\n\t\t\t asd->params.dvs_stat->hor_prod.even_real,\n\t\t\t asd->params.dvs_hor_proj_bytes))\n\t\treturn -EFAULT;\n\tif (copy_to_user(stats->dvs2_stat.hor_prod.even_imag,\n\t\t\t asd->params.dvs_stat->hor_prod.even_imag,\n\t\t\t asd->params.dvs_hor_proj_bytes))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstruct ia_css_shading_table *atomisp_css_shading_table_alloc(\n    unsigned int width, unsigned int height)\n{\n\treturn ia_css_shading_table_alloc(width, height);\n}\n\nvoid atomisp_css_set_shading_table(struct atomisp_sub_device *asd,\n\t\t\t\t   struct ia_css_shading_table *table)\n{\n\tasd->params.config.shading_table = table;\n}\n\nvoid atomisp_css_shading_table_free(struct ia_css_shading_table *table)\n{\n\tia_css_shading_table_free(table);\n}\n\nstruct ia_css_morph_table *atomisp_css_morph_table_allocate(\n    unsigned int width, unsigned int height)\n{\n\treturn ia_css_morph_table_allocate(width, height);\n}\n\nvoid atomisp_css_set_morph_table(struct atomisp_sub_device *asd,\n\t\t\t\t struct ia_css_morph_table *table)\n{\n\tasd->params.config.morph_table = table;\n}\n\nvoid atomisp_css_get_morph_table(struct atomisp_sub_device *asd,\n\t\t\t\t struct ia_css_morph_table *table)\n{\n\tstruct ia_css_isp_config isp_config;\n\tstruct atomisp_device *isp = asd->isp;\n\n\tif (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {\n\t\tdev_err(isp->dev,\n\t\t\t\"%s called after streamoff, skipping.\\n\", __func__);\n\t\treturn;\n\t}\n\tmemset(table, 0, sizeof(struct ia_css_morph_table));\n\tmemset(&isp_config, 0, sizeof(struct ia_css_isp_config));\n\tisp_config.morph_table = table;\n\tia_css_stream_get_isp_config(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    &isp_config);\n}\n\nvoid atomisp_css_morph_table_free(struct ia_css_morph_table *table)\n{\n\tia_css_morph_table_free(table);\n}\n\nstatic bool atomisp_css_isr_get_stream_id(struct ia_css_pipe *css_pipe,\n\t\t\t\t\t  struct atomisp_device *isp,\n\t\t\t\t\t  enum atomisp_input_stream_id *stream_id)\n{\n\tstruct atomisp_stream_env *stream_env;\n\tint i, j;\n\n\tif (!isp->asd.streaming)\n\t\treturn false;\n\n\tfor (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {\n\t\tstream_env = &isp->asd.stream_env[i];\n\t\tfor (j = 0; j < IA_CSS_PIPE_ID_NUM; j++) {\n\t\t\tif (stream_env->pipes[j] && stream_env->pipes[j] == css_pipe) {\n\t\t\t\t*stream_id = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint atomisp_css_isr_thread(struct atomisp_device *isp)\n{\n\tenum atomisp_input_stream_id stream_id = 0;\n\tstruct atomisp_css_event current_event;\n\n\tlockdep_assert_held(&isp->mutex);\n\n\twhile (!ia_css_dequeue_psys_event(&current_event.event)) {\n\t\tif (current_event.event.type ==\n\t\t    IA_CSS_EVENT_TYPE_FW_ASSERT) {\n\t\t\t \n\t\t\tdev_err(isp->dev,\n\t\t\t\t\"%s: ISP reports FW_ASSERT event! fw_assert_module_id %d fw_assert_line_no %d\\n\",\n\t\t\t\t__func__,\n\t\t\t\tcurrent_event.event.fw_assert_module_id,\n\t\t\t\tcurrent_event.event.fw_assert_line_no);\n\n\t\t\tqueue_work(system_long_wq, &isp->assert_recovery_work);\n\t\t\treturn -EINVAL;\n\t\t} else if (current_event.event.type == IA_CSS_EVENT_TYPE_FW_WARNING) {\n\t\t\tdev_warn(isp->dev, \"%s: ISP reports warning, code is %d, exp_id %d\\n\",\n\t\t\t\t __func__, current_event.event.fw_warning,\n\t\t\t\t current_event.event.exp_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!atomisp_css_isr_get_stream_id(current_event.event.pipe, isp, &stream_id)) {\n\t\t\tif (current_event.event.type == IA_CSS_EVENT_TYPE_TIMER)\n\t\t\t\tdev_dbg(isp->dev,\n\t\t\t\t\t\"event: Timer event.\");\n\t\t\telse\n\t\t\t\tdev_warn(isp->dev, \"%s:no subdev.event:%d\",\n\t\t\t\t\t __func__,\n\t\t\t\t\t current_event.event.type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tatomisp_css_temp_pipe_to_pipe_id(&isp->asd, &current_event);\n\t\tswitch (current_event.event.type) {\n\t\tcase IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE:\n\t\t\tdev_dbg(isp->dev, \"event: Output frame done\");\n\t\t\tatomisp_buf_done(&isp->asd, 0, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME,\n\t\t\t\t\t current_event.pipe, true, stream_id);\n\t\t\tbreak;\n\t\tcase IA_CSS_EVENT_TYPE_SECOND_OUTPUT_FRAME_DONE:\n\t\t\tdev_dbg(isp->dev, \"event: Second output frame done\");\n\t\t\tatomisp_buf_done(&isp->asd, 0, IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME,\n\t\t\t\t\t current_event.pipe, true, stream_id);\n\t\t\tbreak;\n\t\tcase IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE:\n\t\t\tdev_dbg(isp->dev, \"event: 3A stats frame done\");\n\t\t\tatomisp_buf_done(&isp->asd, 0,\n\t\t\t\t\t IA_CSS_BUFFER_TYPE_3A_STATISTICS,\n\t\t\t\t\t current_event.pipe,\n\t\t\t\t\t false, stream_id);\n\t\t\tbreak;\n\t\tcase IA_CSS_EVENT_TYPE_METADATA_DONE:\n\t\t\tdev_dbg(isp->dev, \"event: metadata frame done\");\n\t\t\tatomisp_buf_done(&isp->asd, 0,\n\t\t\t\t\t IA_CSS_BUFFER_TYPE_METADATA,\n\t\t\t\t\t current_event.pipe,\n\t\t\t\t\t false, stream_id);\n\t\t\tbreak;\n\t\tcase IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE:\n\t\t\tdev_dbg(isp->dev, \"event: VF output frame done\");\n\t\t\tatomisp_buf_done(&isp->asd, 0,\n\t\t\t\t\t IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME,\n\t\t\t\t\t current_event.pipe, true, stream_id);\n\t\t\tbreak;\n\t\tcase IA_CSS_EVENT_TYPE_SECOND_VF_OUTPUT_FRAME_DONE:\n\t\t\tdev_dbg(isp->dev, \"event: second VF output frame done\");\n\t\t\tatomisp_buf_done(&isp->asd, 0,\n\t\t\t\t\t IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME,\n\t\t\t\t\t current_event.pipe, true, stream_id);\n\t\t\tbreak;\n\t\tcase IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE:\n\t\t\tdev_dbg(isp->dev, \"event: dis stats frame done\");\n\t\t\tatomisp_buf_done(&isp->asd, 0,\n\t\t\t\t\t IA_CSS_BUFFER_TYPE_DIS_STATISTICS,\n\t\t\t\t\t current_event.pipe,\n\t\t\t\t\t false, stream_id);\n\t\t\tbreak;\n\t\tcase IA_CSS_EVENT_TYPE_PIPELINE_DONE:\n\t\t\tdev_dbg(isp->dev, \"event: pipeline done\");\n\t\t\tbreak;\n\t\tcase IA_CSS_EVENT_TYPE_ACC_STAGE_COMPLETE:\n\t\t\tdev_warn(isp->dev, \"unexpected event: acc stage done\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(isp->dev, \"unhandled css stored event: 0x%x\\n\",\n\t\t\t\tcurrent_event.event.type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nbool atomisp_css_valid_sof(struct atomisp_device *isp)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {\n\t\tif (!isp->asd.stream_env[i].stream)\n\t\t\tcontinue;\n\n\t\tdev_dbg(isp->dev, \"stream #%d: mode: %d\\n\",\n\t\t\ti, isp->asd.stream_env[i].stream_config.mode);\n\t\tif (isp->asd.stream_env[i].stream_config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint atomisp_css_debug_dump_isp_binary(void)\n{\n\tia_css_debug_dump_isp_binary();\n\treturn 0;\n}\n\nint atomisp_css_dump_sp_raw_copy_linecount(bool reduced)\n{\n\tsh_css_dump_sp_raw_copy_linecount(reduced);\n\treturn 0;\n}\n\nstatic const char * const fw_type_name[] = {\n\t[ia_css_sp_firmware]\t\t= \"SP\",\n\t[ia_css_isp_firmware]\t\t= \"ISP\",\n\t[ia_css_bootloader_firmware]\t= \"BootLoader\",\n\t[ia_css_acc_firmware]\t\t= \"accel\",\n};\n\nstatic const char * const fw_acc_type_name[] = {\n\t[IA_CSS_ACC_NONE] =\t\t\"Normal\",\n\t[IA_CSS_ACC_OUTPUT] =\t\t\"Accel stage on output\",\n\t[IA_CSS_ACC_VIEWFINDER] =\t\"Accel stage on viewfinder\",\n\t[IA_CSS_ACC_STANDALONE] =\t\"Stand-alone acceleration\",\n};\n\nint atomisp_css_dump_blob_infor(struct atomisp_device *isp)\n{\n\tstruct ia_css_blob_descr *bd = sh_css_blob_info;\n\tunsigned int i, nm = sh_css_num_binaries;\n\n\tif (nm == 0)\n\t\treturn -EPERM;\n\tif (!bd)\n\t\treturn -EPERM;\n\n\t \n\tfor (i = 0; i < sh_css_num_binaries - NUM_OF_SPS; i++) {\n\t\tswitch (bd[i].header.type) {\n\t\tcase ia_css_isp_firmware:\n\t\t\tdev_dbg(isp->dev, \"Num%2d type %s (%s), binary id is %2d, name is %s\\n\",\n\t\t\t\ti + NUM_OF_SPS,\n\t\t\t\tfw_type_name[bd[i].header.type],\n\t\t\t\tfw_acc_type_name[bd[i].header.info.isp.type],\n\t\t\t\tbd[i].header.info.isp.sp.id,\n\t\t\t\tbd[i].name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(isp->dev, \"Num%2d type %s, name is %s\\n\",\n\t\t\t\ti + NUM_OF_SPS, fw_type_name[bd[i].header.type],\n\t\t\t\tbd[i].name);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid atomisp_css_set_isp_config_id(struct atomisp_sub_device *asd,\n\t\t\t\t   uint32_t isp_config_id)\n{\n\tasd->params.config.isp_config_id = isp_config_id;\n}\n\nvoid atomisp_css_set_isp_config_applied_frame(struct atomisp_sub_device *asd,\n\tstruct ia_css_frame *output_frame)\n{\n\tasd->params.config.output_frame = output_frame;\n}\n\nint atomisp_get_css_dbgfunc(void)\n{\n\treturn dbg_func;\n}\n\nint atomisp_set_css_dbgfunc(struct atomisp_device *isp, int opt)\n{\n\tint ret;\n\n\tret = __set_css_print_env(isp, opt);\n\tif (ret == 0)\n\t\tdbg_func = opt;\n\n\treturn ret;\n}\n\nvoid atomisp_en_dz_capt_pipe(struct atomisp_sub_device *asd, bool enable)\n{\n\tia_css_en_dz_capt_pipe(\n\t    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,\n\t    enable);\n}\n\nstruct ia_css_dvs_grid_info *atomisp_css_get_dvs_grid_info(\n    struct ia_css_grid_info *grid_info)\n{\n\tif (!grid_info)\n\t\treturn NULL;\n\n#ifdef IA_CSS_DVS_STAT_GRID_INFO_SUPPORTED\n\treturn &grid_info->dvs_grid.dvs_grid_info;\n#else\n\treturn &grid_info->dvs_grid;\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}