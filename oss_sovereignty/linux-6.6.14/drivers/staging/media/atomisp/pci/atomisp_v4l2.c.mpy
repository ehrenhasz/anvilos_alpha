{
  "module_name": "atomisp_v4l2.c",
  "hash_id": "796f10ecb6eafbf3e7cd3347758df68876453451220f42de0ff8ced2e22641aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/atomisp_v4l2.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_qos.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/interrupt.h>\n#include <linux/bits.h>\n#include <media/v4l2-fwnode.h>\n\n#include <asm/iosf_mbi.h>\n\n#include \"../../include/linux/atomisp_gmin_platform.h\"\n\n#include \"atomisp_cmd.h\"\n#include \"atomisp_common.h\"\n#include \"atomisp_fops.h\"\n#include \"atomisp_ioctl.h\"\n#include \"atomisp_internal.h\"\n#include \"atomisp-regs.h\"\n#include \"atomisp_dfs_tables.h\"\n#include \"atomisp_drvfs.h\"\n#include \"hmm/hmm.h\"\n#include \"atomisp_trace_event.h\"\n\n#include \"sh_css_firmware.h\"\n\n#include \"device_access.h\"\n\n \n#define SUBDEV_WAIT_TIMEOUT\t\t50  \n#define SUBDEV_WAIT_TIMEOUT_MAX_COUNT\t40  \n\n \n#define CSTATE_EXIT_LATENCY_C1  1\n\nstatic uint skip_fwload;\nmodule_param(skip_fwload, uint, 0644);\nMODULE_PARM_DESC(skip_fwload, \"Skip atomisp firmware load\");\n\n \nint dbg_level;\nmodule_param(dbg_level, int, 0644);\nMODULE_PARM_DESC(dbg_level, \"debug message level (default:0)\");\n\n \nint dbg_func = 1;\nmodule_param(dbg_func, int, 0644);\nMODULE_PARM_DESC(dbg_func,\n\t\t \"log function switch non/printk (default:printk)\");\n\nint mipicsi_flag;\nmodule_param(mipicsi_flag, int, 0644);\nMODULE_PARM_DESC(mipicsi_flag, \"mipi csi compression predictor algorithm\");\n\nstatic char firmware_name[256];\nmodule_param_string(firmware_name, firmware_name, sizeof(firmware_name), 0);\nMODULE_PARM_DESC(firmware_name, \"Firmware file name. Allows overriding the default firmware name.\");\n\n \nint pad_w = 16;\nmodule_param(pad_w, int, 0644);\nMODULE_PARM_DESC(pad_w, \"extra data for ISP processing\");\n\nint pad_h = 16;\nmodule_param(pad_h, int, 0644);\nMODULE_PARM_DESC(pad_h, \"extra data for ISP processing\");\n\n \n\nstruct device *atomisp_dev;\n\nstatic const struct atomisp_freq_scaling_rule dfs_rules_merr[] = {\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_400MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_VIDEO,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_400MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_400MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_PREVIEW,\n\t},\n};\n\n \nstatic const struct atomisp_dfs_config dfs_config_merr = {\n\t.lowest_freq = ISP_FREQ_200MHZ,\n\t.max_freq_at_vmin = ISP_FREQ_400MHZ,\n\t.highest_freq = ISP_FREQ_457MHZ,\n\t.dfs_table = dfs_rules_merr,\n\t.dfs_table_size = ARRAY_SIZE(dfs_rules_merr),\n};\n\nstatic const struct atomisp_freq_scaling_rule dfs_rules_merr_1179[] = {\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_400MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_VIDEO,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_400MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_400MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_PREVIEW,\n\t},\n};\n\nstatic const struct atomisp_dfs_config dfs_config_merr_1179 = {\n\t.lowest_freq = ISP_FREQ_200MHZ,\n\t.max_freq_at_vmin = ISP_FREQ_400MHZ,\n\t.highest_freq = ISP_FREQ_400MHZ,\n\t.dfs_table = dfs_rules_merr_1179,\n\t.dfs_table_size = ARRAY_SIZE(dfs_rules_merr_1179),\n};\n\nstatic const struct atomisp_freq_scaling_rule dfs_rules_merr_117a[] = {\n\t{\n\t\t.width = 1920,\n\t\t.height = 1080,\n\t\t.fps = 30,\n\t\t.isp_freq = ISP_FREQ_266MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_VIDEO,\n\t},\n\t{\n\t\t.width = 1080,\n\t\t.height = 1920,\n\t\t.fps = 30,\n\t\t.isp_freq = ISP_FREQ_266MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_VIDEO,\n\t},\n\t{\n\t\t.width = 1920,\n\t\t.height = 1080,\n\t\t.fps = 45,\n\t\t.isp_freq = ISP_FREQ_320MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_VIDEO,\n\t},\n\t{\n\t\t.width = 1080,\n\t\t.height = 1920,\n\t\t.fps = 45,\n\t\t.isp_freq = ISP_FREQ_320MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_VIDEO,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = 60,\n\t\t.isp_freq = ISP_FREQ_356MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_VIDEO,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_200MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_VIDEO,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_400MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_200MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_PREVIEW,\n\t},\n};\n\nstatic struct atomisp_dfs_config dfs_config_merr_117a = {\n\t.lowest_freq = ISP_FREQ_200MHZ,\n\t.max_freq_at_vmin = ISP_FREQ_200MHZ,\n\t.highest_freq = ISP_FREQ_400MHZ,\n\t.dfs_table = dfs_rules_merr_117a,\n\t.dfs_table_size = ARRAY_SIZE(dfs_rules_merr_117a),\n};\n\nstatic const struct atomisp_freq_scaling_rule dfs_rules_byt[] = {\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_400MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_VIDEO,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_400MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_400MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_PREVIEW,\n\t},\n};\n\nstatic const struct atomisp_dfs_config dfs_config_byt = {\n\t.lowest_freq = ISP_FREQ_200MHZ,\n\t.max_freq_at_vmin = ISP_FREQ_400MHZ,\n\t.highest_freq = ISP_FREQ_400MHZ,\n\t.dfs_table = dfs_rules_byt,\n\t.dfs_table_size = ARRAY_SIZE(dfs_rules_byt),\n};\n\nstatic const struct atomisp_freq_scaling_rule dfs_rules_cht[] = {\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_320MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_VIDEO,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_356MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_320MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_PREVIEW,\n\t},\n};\n\nstatic const struct atomisp_freq_scaling_rule dfs_rules_cht_soc[] = {\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_356MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_VIDEO,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_356MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,\n\t},\n\t{\n\t\t.width = ISP_FREQ_RULE_ANY,\n\t\t.height = ISP_FREQ_RULE_ANY,\n\t\t.fps = ISP_FREQ_RULE_ANY,\n\t\t.isp_freq = ISP_FREQ_320MHZ,\n\t\t.run_mode = ATOMISP_RUN_MODE_PREVIEW,\n\t},\n};\n\nstatic const struct atomisp_dfs_config dfs_config_cht = {\n\t.lowest_freq = ISP_FREQ_100MHZ,\n\t.max_freq_at_vmin = ISP_FREQ_356MHZ,\n\t.highest_freq = ISP_FREQ_356MHZ,\n\t.dfs_table = dfs_rules_cht,\n\t.dfs_table_size = ARRAY_SIZE(dfs_rules_cht),\n};\n\n \nconst struct atomisp_dfs_config dfs_config_cht_soc = {\n\t.lowest_freq = ISP_FREQ_100MHZ,\n\t.max_freq_at_vmin = ISP_FREQ_356MHZ,\n\t.highest_freq = ISP_FREQ_356MHZ,\n\t.dfs_table = dfs_rules_cht_soc,\n\t.dfs_table_size = ARRAY_SIZE(dfs_rules_cht_soc),\n};\n\nint atomisp_video_init(struct atomisp_video_pipe *video)\n{\n\tint ret;\n\n\tvideo->pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&video->vdev.entity, 1, &video->pad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tstrscpy(video->vdev.name, \"ATOMISP video output\", sizeof(video->vdev.name));\n\tvideo->vdev.fops = &atomisp_fops;\n\tvideo->vdev.ioctl_ops = &atomisp_ioctl_ops;\n\tvideo->vdev.lock = &video->isp->mutex;\n\tvideo->vdev.release = video_device_release_empty;\n\tvideo_set_drvdata(&video->vdev, video->isp);\n\n\treturn 0;\n}\n\nvoid atomisp_video_unregister(struct atomisp_video_pipe *video)\n{\n\tif (video_is_registered(&video->vdev)) {\n\t\tmedia_entity_cleanup(&video->vdev.entity);\n\t\tvideo_unregister_device(&video->vdev);\n\t}\n}\n\nstatic int atomisp_save_iunit_reg(struct atomisp_device *isp)\n{\n\tstruct pci_dev *pdev = to_pci_dev(isp->dev);\n\n\tdev_dbg(isp->dev, \"%s\\n\", __func__);\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &isp->saved_regs.pcicmdsts);\n\t \n\tpci_read_config_dword(pdev, PCI_MSI_CAPID, &isp->saved_regs.msicap);\n\tpci_read_config_dword(pdev, PCI_MSI_ADDR, &isp->saved_regs.msi_addr);\n\tpci_read_config_word(pdev, PCI_MSI_DATA,  &isp->saved_regs.msi_data);\n\tpci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &isp->saved_regs.intr);\n\tpci_read_config_dword(pdev, PCI_INTERRUPT_CTRL, &isp->saved_regs.interrupt_control);\n\n\tpci_read_config_dword(pdev, MRFLD_PCI_PMCS, &isp->saved_regs.pmcs);\n\t \n\tpci_read_config_dword(pdev, PCI_I_CONTROL, &isp->saved_regs.i_control);\n\tisp->saved_regs.i_control |=\n\t    MRFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING |\n\t    MRFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING;\n\tpci_read_config_dword(pdev, MRFLD_PCI_CSI_ACCESS_CTRL_VIOL,\n\t\t\t      &isp->saved_regs.csi_access_viol);\n\tpci_read_config_dword(pdev, MRFLD_PCI_CSI_RCOMP_CONTROL,\n\t\t\t      &isp->saved_regs.csi_rcomp_config);\n\t \n\tisp->saved_regs.csi_rcomp_config |= MRFLD_PCI_CSI_HS_OVR_CLK_GATE_ON_UPDATE;\n\tpci_read_config_dword(pdev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,\n\t\t\t      &isp->saved_regs.csi_afe_dly);\n\tpci_read_config_dword(pdev, MRFLD_PCI_CSI_CONTROL,\n\t\t\t      &isp->saved_regs.csi_control);\n\tif (isp->media_dev.hw_revision >=\n\t    (ATOMISP_HW_REVISION_ISP2401 << ATOMISP_HW_REVISION_SHIFT))\n\t\tisp->saved_regs.csi_control |= MRFLD_PCI_CSI_CONTROL_PARPATHEN;\n\t \n\tif (IS_CHT && (isp->media_dev.hw_revision >= ((ATOMISP_HW_REVISION_ISP2401 <<\n\t\t       ATOMISP_HW_REVISION_SHIFT) | ATOMISP_HW_STEPPING_B0)))\n\t\tisp->saved_regs.csi_control |= MRFLD_PCI_CSI_CONTROL_CSI_READY;\n\tpci_read_config_dword(pdev, MRFLD_PCI_CSI_AFE_RCOMP_CONTROL,\n\t\t\t      &isp->saved_regs.csi_afe_rcomp_config);\n\tpci_read_config_dword(pdev, MRFLD_PCI_CSI_AFE_HS_CONTROL,\n\t\t\t      &isp->saved_regs.csi_afe_hs_control);\n\tpci_read_config_dword(pdev, MRFLD_PCI_CSI_DEADLINE_CONTROL,\n\t\t\t      &isp->saved_regs.csi_deadline_control);\n\treturn 0;\n}\n\nstatic int atomisp_restore_iunit_reg(struct atomisp_device *isp)\n{\n\tstruct pci_dev *pdev = to_pci_dev(isp->dev);\n\n\tdev_dbg(isp->dev, \"%s\\n\", __func__);\n\n\tpci_write_config_word(pdev, PCI_COMMAND, isp->saved_regs.pcicmdsts);\n\tpci_write_config_dword(pdev, PCI_BASE_ADDRESS_0, isp->saved_regs.ispmmadr);\n\tpci_write_config_dword(pdev, PCI_MSI_CAPID, isp->saved_regs.msicap);\n\tpci_write_config_dword(pdev, PCI_MSI_ADDR, isp->saved_regs.msi_addr);\n\tpci_write_config_word(pdev, PCI_MSI_DATA, isp->saved_regs.msi_data);\n\tpci_write_config_byte(pdev, PCI_INTERRUPT_LINE, isp->saved_regs.intr);\n\tpci_write_config_dword(pdev, PCI_INTERRUPT_CTRL, isp->saved_regs.interrupt_control);\n\tpci_write_config_dword(pdev, PCI_I_CONTROL, isp->saved_regs.i_control);\n\n\tpci_write_config_dword(pdev, MRFLD_PCI_PMCS, isp->saved_regs.pmcs);\n\tpci_write_config_dword(pdev, MRFLD_PCI_CSI_ACCESS_CTRL_VIOL,\n\t\t\t       isp->saved_regs.csi_access_viol);\n\tpci_write_config_dword(pdev, MRFLD_PCI_CSI_RCOMP_CONTROL,\n\t\t\t       isp->saved_regs.csi_rcomp_config);\n\tpci_write_config_dword(pdev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,\n\t\t\t       isp->saved_regs.csi_afe_dly);\n\tpci_write_config_dword(pdev, MRFLD_PCI_CSI_CONTROL,\n\t\t\t       isp->saved_regs.csi_control);\n\tpci_write_config_dword(pdev, MRFLD_PCI_CSI_AFE_RCOMP_CONTROL,\n\t\t\t       isp->saved_regs.csi_afe_rcomp_config);\n\tpci_write_config_dword(pdev, MRFLD_PCI_CSI_AFE_HS_CONTROL,\n\t\t\t       isp->saved_regs.csi_afe_hs_control);\n\tpci_write_config_dword(pdev, MRFLD_PCI_CSI_DEADLINE_CONTROL,\n\t\t\t       isp->saved_regs.csi_deadline_control);\n\n\t \n\tatomisp_css2_hw_store_32(MRFLD_CSI_RECEIVER_SELECTION_REG, 1);\n\treturn 0;\n}\n\nstatic int atomisp_mrfld_pre_power_down(struct atomisp_device *isp)\n{\n\tstruct pci_dev *pdev = to_pci_dev(isp->dev);\n\tu32 irq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&isp->lock, flags);\n\n\t \n\tpci_read_config_dword(pdev, PCI_INTERRUPT_CTRL, &irq);\n\tirq &= BIT(INTR_IIR);\n\tpci_write_config_dword(pdev, PCI_INTERRUPT_CTRL, irq);\n\n\tpci_read_config_dword(pdev, PCI_INTERRUPT_CTRL, &irq);\n\tif (!(irq & BIT(INTR_IIR)))\n\t\tgoto done;\n\n\tatomisp_css2_hw_store_32(MRFLD_INTR_CLEAR_REG, 0xFFFFFFFF);\n\tatomisp_load_uint32(MRFLD_INTR_STATUS_REG, &irq);\n\tif (irq != 0) {\n\t\tdev_err(isp->dev,\n\t\t\t\"%s: fail to clear isp interrupt status reg=0x%x\\n\",\n\t\t\t__func__, irq);\n\t\tspin_unlock_irqrestore(&isp->lock, flags);\n\t\treturn -EAGAIN;\n\t} else {\n\t\tpci_read_config_dword(pdev, PCI_INTERRUPT_CTRL, &irq);\n\t\tirq &= BIT(INTR_IIR);\n\t\tpci_write_config_dword(pdev, PCI_INTERRUPT_CTRL, irq);\n\n\t\tpci_read_config_dword(pdev, PCI_INTERRUPT_CTRL, &irq);\n\t\tif (!(irq & BIT(INTR_IIR))) {\n\t\t\tatomisp_css2_hw_store_32(MRFLD_INTR_ENABLE_REG, 0x0);\n\t\t\tgoto done;\n\t\t}\n\t\tdev_err(isp->dev,\n\t\t\t\"%s: error in iunit interrupt. status reg=0x%x\\n\",\n\t\t\t__func__, irq);\n\t\tspin_unlock_irqrestore(&isp->lock, flags);\n\t\treturn -EAGAIN;\n\t}\ndone:\n\t \n\tpci_read_config_dword(pdev, PCI_INTERRUPT_CTRL, &irq);\n\tirq &= ~BIT(INTR_IER);\n\tpci_write_config_dword(pdev, PCI_INTERRUPT_CTRL, irq);\n\n\tatomisp_msi_irq_uninit(isp);\n\tatomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW, true);\n\tspin_unlock_irqrestore(&isp->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void punit_ddr_dvfs_enable(bool enable)\n{\n\tint reg;\n\n\tiosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, MRFLD_ISPSSDVFS, &reg);\n\tif (enable) {\n\t\treg &= ~(MRFLD_BIT0 | MRFLD_BIT1);\n\t} else {\n\t\treg |= MRFLD_BIT1;\n\t\treg &= ~(MRFLD_BIT0);\n\t}\n\tiosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE, MRFLD_ISPSSDVFS, reg);\n}\n\nstatic int atomisp_mrfld_power(struct atomisp_device *isp, bool enable)\n{\n\tstruct pci_dev *pdev = to_pci_dev(isp->dev);\n\tunsigned long timeout;\n\tu32 val = enable ? MRFLD_ISPSSPM0_IUNIT_POWER_ON :\n\t\t\t   MRFLD_ISPSSPM0_IUNIT_POWER_OFF;\n\n\tdev_dbg(isp->dev, \"IUNIT power-%s.\\n\", enable ? \"on\" : \"off\");\n\n\t \n\tif (IS_CHT && enable) {\n\t\tpunit_ddr_dvfs_enable(false);\n\t\tmsleep(20);\n\t}\n\n\t \n\tiosf_mbi_modify(BT_MBI_UNIT_PMC, MBI_REG_READ, MRFLD_ISPSSPM0,\n\t\t\tval, MRFLD_ISPSSPM0_ISPSSC_MASK);\n\n\t \n\tif (IS_CHT && !enable)\n\t\tpunit_ddr_dvfs_enable(true);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(50);\n\tdo {\n\t\tu32 tmp;\n\n\t\t \n\t\tiosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, MRFLD_ISPSSPM0, &tmp);\n\t\ttmp = (tmp >> MRFLD_ISPSSPM0_ISPSSS_OFFSET) & MRFLD_ISPSSPM0_ISPSSC_MASK;\n\t\tif (tmp == val) {\n\t\t\ttrace_ipu_cstate(enable);\n\t\t\tpdev->current_state = enable ? PCI_D0 : PCI_D3cold;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\n\t\t \n\t\tusleep_range(100, 150);\n\t} while (1);\n\n\tif (enable)\n\t\tmsleep(10);\n\n\tdev_err(isp->dev, \"IUNIT power-%s timeout.\\n\", enable ? \"on\" : \"off\");\n\treturn -EBUSY;\n}\n\nint atomisp_power_off(struct device *dev)\n{\n\tstruct atomisp_device *isp = dev_get_drvdata(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint ret;\n\tu32 reg;\n\n\tatomisp_css_uninit(isp);\n\n\tret = atomisp_mrfld_pre_power_down(isp);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpci_read_config_dword(pdev, MRFLD_PCI_CSI_CONTROL, &reg);\n\treg |= MRFLD_ALL_CSI_PORTS_OFF_MASK;\n\tpci_write_config_dword(pdev, MRFLD_PCI_CSI_CONTROL, reg);\n\n\tcpu_latency_qos_update_request(&isp->pm_qos, PM_QOS_DEFAULT_VALUE);\n\tpci_save_state(pdev);\n\treturn atomisp_mrfld_power(isp, false);\n}\n\nint atomisp_power_on(struct device *dev)\n{\n\tstruct atomisp_device *isp = (struct atomisp_device *)\n\t\t\t\t     dev_get_drvdata(dev);\n\tint ret;\n\n\tret = atomisp_mrfld_power(isp, true);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_restore_state(to_pci_dev(dev));\n\tcpu_latency_qos_update_request(&isp->pm_qos, isp->max_isr_latency);\n\n\t \n\tif (isp->saved_regs.pcicmdsts)\n\t\tatomisp_restore_iunit_reg(isp);\n\n\tatomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW, true);\n\n\treturn atomisp_css_init(isp);\n}\n\nstatic int atomisp_suspend(struct device *dev)\n{\n\tstruct atomisp_device *isp = (struct atomisp_device *)\n\t\t\t\t     dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&isp->lock, flags);\n\tif (isp->asd.streaming) {\n\t\tspin_unlock_irqrestore(&isp->lock, flags);\n\t\tdev_err(isp->dev, \"atomisp cannot suspend at this time.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&isp->lock, flags);\n\n\tpm_runtime_resume(dev);\n\n\tisp->asd.recreate_streams_on_resume = isp->asd.stream_prepared;\n\tatomisp_destroy_pipes_stream(&isp->asd);\n\n\treturn atomisp_power_off(dev);\n}\n\nstatic int atomisp_resume(struct device *dev)\n{\n\tstruct atomisp_device *isp = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = atomisp_power_on(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (isp->asd.recreate_streams_on_resume)\n\t\tret = atomisp_create_pipes_stream(&isp->asd);\n\n\treturn ret;\n}\n\nint atomisp_csi_lane_config(struct atomisp_device *isp)\n{\n\tstruct pci_dev *pdev = to_pci_dev(isp->dev);\n\tstatic const struct {\n\t\tu8 code;\n\t\tu8 lanes[N_MIPI_PORT_ID];\n\t} portconfigs[] = {\n\t\t \n\t\t{ 0x00, { 4, 1, 0 } },\t\t \n\t\t{ 0x01, { 3, 1, 0 } },\t\t \n\t\t{ 0x02, { 2, 1, 0 } },\t\t \n\t\t{ 0x03, { 1, 1, 0 } },\t\t \n\t\t{ 0x04, { 2, 1, 2 } },\t\t \n\t\t{ 0x08, { 3, 1, 1 } },\t\t \n\t\t{ 0x09, { 2, 1, 1 } },\t\t \n\t\t{ 0x0a, { 1, 1, 1 } },\t\t \n\n\t\t \n\t\t{ 0x10, { 4, 2, 0 } },\t\t \n\t\t{ 0x11, { 3, 2, 0 } },\t\t \n\t\t{ 0x12, { 2, 2, 0 } },\t\t \n\t\t{ 0x13, { 1, 2, 0 } },\t\t \n\t\t{ 0x14, { 2, 2, 2 } },\t\t \n\t\t{ 0x18, { 3, 2, 1 } },\t\t \n\t\t{ 0x19, { 2, 2, 1 } },\t\t \n\t\t{ 0x1a, { 1, 2, 1 } },\t\t \n\t};\n\n\tunsigned int i, j;\n\tu32 csi_control;\n\tint nportconfigs;\n\tu32 port_config_mask;\n\tint port3_lanes_shift;\n\n\tif (isp->media_dev.hw_revision <\n\t    ATOMISP_HW_REVISION_ISP2401_LEGACY <<\n\t    ATOMISP_HW_REVISION_SHIFT) {\n\t\t \n\t\tport_config_mask = MRFLD_PORT_CONFIG_MASK;\n\t\tport3_lanes_shift = MRFLD_PORT3_LANES_SHIFT;\n\t} else {\n\t\t \n\t\tport_config_mask = CHV_PORT_CONFIG_MASK;\n\t\tport3_lanes_shift = CHV_PORT3_LANES_SHIFT;\n\t}\n\n\tif (isp->media_dev.hw_revision <\n\t    ATOMISP_HW_REVISION_ISP2401 <<\n\t    ATOMISP_HW_REVISION_SHIFT) {\n\t\t \n\t\tnportconfigs = MRFLD_PORT_CONFIG_NUM;\n\t} else {\n\t\t \n\t\tnportconfigs = ARRAY_SIZE(portconfigs);\n\t}\n\n\tfor (i = 0; i < nportconfigs; i++) {\n\t\tfor (j = 0; j < N_MIPI_PORT_ID; j++)\n\t\t\tif (isp->sensor_lanes[j] &&\n\t\t\t    isp->sensor_lanes[j] != portconfigs[i].lanes[j])\n\t\t\t\tbreak;\n\n\t\tif (j == N_MIPI_PORT_ID)\n\t\t\tbreak;\t\t\t \n\t}\n\n\tif (i >= nportconfigs) {\n\t\tdev_err(isp->dev,\n\t\t\t\"%s: could not find the CSI port setting for %d-%d-%d\\n\",\n\t\t\t__func__,\n\t\t\tisp->sensor_lanes[0], isp->sensor_lanes[1], isp->sensor_lanes[2]);\n\t\treturn -EINVAL;\n\t}\n\n\tpci_read_config_dword(pdev, MRFLD_PCI_CSI_CONTROL, &csi_control);\n\tcsi_control &= ~port_config_mask;\n\tcsi_control |= (portconfigs[i].code << MRFLD_PORT_CONFIGCODE_SHIFT)\n\t\t       | (portconfigs[i].lanes[0] ? 0 : (1 << MRFLD_PORT1_ENABLE_SHIFT))\n\t\t       | (portconfigs[i].lanes[1] ? 0 : (1 << MRFLD_PORT2_ENABLE_SHIFT))\n\t\t       | (portconfigs[i].lanes[2] ? 0 : (1 << MRFLD_PORT3_ENABLE_SHIFT))\n\t\t       | (((1 << portconfigs[i].lanes[0]) - 1) << MRFLD_PORT1_LANES_SHIFT)\n\t\t       | (((1 << portconfigs[i].lanes[1]) - 1) << MRFLD_PORT2_LANES_SHIFT)\n\t\t       | (((1 << portconfigs[i].lanes[2]) - 1) << port3_lanes_shift);\n\n\tpci_write_config_dword(pdev, MRFLD_PCI_CSI_CONTROL, csi_control);\n\n\tdev_dbg(isp->dev,\n\t\t\"%s: the portconfig is %d-%d-%d, CSI_CONTROL is 0x%08X\\n\",\n\t\t__func__, portconfigs[i].lanes[0], portconfigs[i].lanes[1],\n\t\tportconfigs[i].lanes[2], csi_control);\n\n\treturn 0;\n}\n\nstatic int atomisp_subdev_probe(struct atomisp_device *isp)\n{\n\tconst struct atomisp_platform_data *pdata;\n\tstruct intel_v4l2_subdev_table *subdevs;\n\tint ret, mipi_port;\n\n\tret = atomisp_csi2_bridge_parse_firmware(isp);\n\tif (ret)\n\t\treturn ret;\n\n\tpdata = atomisp_get_platform_data();\n\tif (!pdata) {\n\t\tdev_err(isp->dev, \"no platform data available\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tfor (subdevs = pdata->subdevs; subdevs->type; ++subdevs) {\n\t\tret = v4l2_device_register_subdev(&isp->v4l2_dev, subdevs->subdev);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tswitch (subdevs->type) {\n\t\tcase RAW_CAMERA:\n\t\t\tif (subdevs->port >= ATOMISP_CAMERA_NR_PORTS) {\n\t\t\t\tdev_err(isp->dev, \"port %d not supported\\n\", subdevs->port);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isp->sensor_subdevs[subdevs->port]) {\n\t\t\t\tdev_err(isp->dev, \"port %d already has a sensor attached\\n\",\n\t\t\t\t\tsubdevs->port);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmipi_port = atomisp_port_to_mipi_port(isp, subdevs->port);\n\t\t\tisp->sensor_lanes[mipi_port] = subdevs->lanes;\n\t\t\tisp->sensor_subdevs[subdevs->port] = subdevs->subdev;\n\t\t\tbreak;\n\t\tcase CAMERA_MOTOR:\n\t\t\tif (isp->motor) {\n\t\t\t\tdev_warn(isp->dev, \"too many atomisp motors\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisp->motor = subdevs->subdev;\n\t\t\tbreak;\n\t\tcase LED_FLASH:\n\t\t\tif (isp->flash) {\n\t\t\t\tdev_warn(isp->dev, \"too many atomisp flash devices\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisp->flash = subdevs->subdev;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(isp->dev, \"unknown subdev probed\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn atomisp_csi_lane_config(isp);\n}\n\nstatic void atomisp_unregister_entities(struct atomisp_device *isp)\n{\n\tunsigned int i;\n\tstruct v4l2_subdev *sd, *next;\n\n\tatomisp_subdev_unregister_entities(&isp->asd);\n\tatomisp_tpg_unregister_entities(&isp->tpg);\n\tfor (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++)\n\t\tatomisp_mipi_csi2_unregister_entities(&isp->csi2_port[i]);\n\n\tlist_for_each_entry_safe(sd, next, &isp->v4l2_dev.subdevs, list)\n\t\tv4l2_device_unregister_subdev(sd);\n\n\tv4l2_device_unregister(&isp->v4l2_dev);\n\tmedia_device_unregister(&isp->media_dev);\n\tmedia_device_cleanup(&isp->media_dev);\n}\n\nstatic int atomisp_register_entities(struct atomisp_device *isp)\n{\n\tint ret = 0;\n\tunsigned int i;\n\n\tisp->media_dev.dev = isp->dev;\n\n\tstrscpy(isp->media_dev.model, \"Intel Atom ISP\",\n\t\tsizeof(isp->media_dev.model));\n\n\tmedia_device_init(&isp->media_dev);\n\tisp->v4l2_dev.mdev = &isp->media_dev;\n\tret = v4l2_device_register(isp->dev, &isp->v4l2_dev);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"%s: V4L2 device registration failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\tgoto v4l2_device_failed;\n\t}\n\n\tret = atomisp_subdev_probe(isp);\n\tif (ret < 0)\n\t\tgoto csi_and_subdev_probe_failed;\n\n\t \n\tfor (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {\n\t\tret = atomisp_mipi_csi2_register_entities(&isp->csi2_port[i],\n\t\t\t&isp->v4l2_dev);\n\t\tif (ret == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tdev_err(isp->dev, \"failed to register the CSI port: %d\\n\", i);\n\t\t \n\t\twhile (i--)\n\t\t\tatomisp_mipi_csi2_unregister_entities(\n\t\t\t    &isp->csi2_port[i]);\n\n\t\tgoto csi_and_subdev_probe_failed;\n\t}\n\n\tret = atomisp_tpg_register_entities(&isp->tpg, &isp->v4l2_dev);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"atomisp_tpg_register_entities\\n\");\n\t\tgoto tpg_register_failed;\n\t}\n\n\tret = atomisp_subdev_register_subdev(&isp->asd, &isp->v4l2_dev);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"atomisp_subdev_register_subdev fail\\n\");\n\t\tgoto subdev_register_failed;\n\t}\n\n\treturn 0;\n\nsubdev_register_failed:\n\tatomisp_tpg_unregister_entities(&isp->tpg);\ntpg_register_failed:\n\tfor (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++)\n\t\tatomisp_mipi_csi2_unregister_entities(&isp->csi2_port[i]);\ncsi_and_subdev_probe_failed:\n\tv4l2_device_unregister(&isp->v4l2_dev);\nv4l2_device_failed:\n\tmedia_device_unregister(&isp->media_dev);\n\tmedia_device_cleanup(&isp->media_dev);\n\treturn ret;\n}\n\nstatic void atomisp_init_sensor(struct atomisp_input_subdev *input)\n{\n\tstruct v4l2_subdev_mbus_code_enum mbus_code_enum = { };\n\tstruct v4l2_subdev_frame_size_enum fse = { };\n\tstruct v4l2_subdev_state sd_state = {\n\t\t.pads = &input->pad_cfg,\n\t};\n\tstruct v4l2_subdev_selection sel = { };\n\tint i, err;\n\n\tmbus_code_enum.which = V4L2_SUBDEV_FORMAT_ACTIVE;\n\terr = v4l2_subdev_call(input->camera, pad, enum_mbus_code, NULL, &mbus_code_enum);\n\tif (!err)\n\t\tinput->code = mbus_code_enum.code;\n\n\tsel.which = V4L2_SUBDEV_FORMAT_ACTIVE;\n\tsel.target = V4L2_SEL_TGT_NATIVE_SIZE;\n\terr = v4l2_subdev_call(input->camera, pad, get_selection, NULL, &sel);\n\tif (err)\n\t\treturn;\n\n\tinput->native_rect = sel.r;\n\n\tsel.which = V4L2_SUBDEV_FORMAT_ACTIVE;\n\tsel.target = V4L2_SEL_TGT_CROP_DEFAULT;\n\terr = v4l2_subdev_call(input->camera, pad, get_selection, NULL, &sel);\n\tif (err)\n\t\treturn;\n\n\tinput->active_rect = sel.r;\n\n\t \n\tfor (i = 0; ; i++) {\n\t\tfse.index = i;\n\t\tfse.code = input->code;\n\t\tfse.which = V4L2_SUBDEV_FORMAT_ACTIVE;\n\n\t\terr = v4l2_subdev_call(input->camera, pad, enum_frame_size, NULL, &fse);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (fse.min_width <= (input->active_rect.width / 2) &&\n\t\t    fse.min_height <= (input->active_rect.height / 2)) {\n\t\t\tinput->binning_support = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tsel.which = V4L2_SUBDEV_FORMAT_TRY;\n\tsel.target = V4L2_SEL_TGT_CROP;\n\tsel.r = input->native_rect;\n\terr = v4l2_subdev_call(input->camera, pad, set_selection, &sd_state, &sel);\n\tif (err)\n\t\treturn;\n\n\tsel.which = V4L2_SUBDEV_FORMAT_ACTIVE;\n\tsel.target = V4L2_SEL_TGT_CROP;\n\tsel.r = input->native_rect;\n\terr = v4l2_subdev_call(input->camera, pad, set_selection, NULL, &sel);\n\tif (err)\n\t\treturn;\n\n\tdev_info(input->camera->dev, \"Supports crop native %dx%d active %dx%d binning %d\\n\",\n\t\t input->native_rect.width, input->native_rect.height,\n\t\t input->active_rect.width, input->active_rect.height,\n\t\t input->binning_support);\n\n\tinput->crop_support = true;\n}\n\nint atomisp_register_device_nodes(struct atomisp_device *isp)\n{\n\tstruct atomisp_input_subdev *input;\n\tint i, err;\n\n\tfor (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {\n\t\terr = media_create_pad_link(&isp->csi2_port[i].subdev.entity,\n\t\t\t\t\t    CSI2_PAD_SOURCE, &isp->asd.subdev.entity,\n\t\t\t\t\t    ATOMISP_SUBDEV_PAD_SINK, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!isp->sensor_subdevs[i])\n\t\t\tcontinue;\n\n\t\tinput = &isp->inputs[isp->input_cnt];\n\n\t\tinput->type = RAW_CAMERA;\n\t\tinput->port = i;\n\t\tinput->camera = isp->sensor_subdevs[i];\n\n\t\tatomisp_init_sensor(input);\n\n\t\t \n\t\tif (i == ATOMISP_CAMERA_PORT_PRIMARY)\n\t\t\tinput->motor = isp->motor;\n\n\t\terr = media_create_pad_link(&input->camera->entity, 0,\n\t\t\t\t\t    &isp->csi2_port[i].subdev.entity,\n\t\t\t\t\t    CSI2_PAD_SINK,\n\t\t\t\t\t    MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tisp->input_cnt++;\n\t}\n\n\tif (!isp->input_cnt)\n\t\tdev_warn(isp->dev, \"no camera attached or fail to detect\\n\");\n\telse\n\t\tdev_info(isp->dev, \"detected %d camera sensors\\n\", isp->input_cnt);\n\n\tif (isp->input_cnt < ATOM_ISP_MAX_INPUTS) {\n\t\tdev_dbg(isp->dev, \"TPG detected, camera_cnt: %d\\n\", isp->input_cnt);\n\t\tisp->inputs[isp->input_cnt].type = TEST_PATTERN;\n\t\tisp->inputs[isp->input_cnt].port = -1;\n\t\tisp->inputs[isp->input_cnt++].camera = &isp->tpg.sd;\n\t} else {\n\t\tdev_warn(isp->dev, \"too many atomisp inputs, TPG ignored.\\n\");\n\t}\n\n\tisp->asd.video_out.vdev.v4l2_dev = &isp->v4l2_dev;\n\tisp->asd.video_out.vdev.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\n\terr = video_register_device(&isp->asd.video_out.vdev, VFL_TYPE_VIDEO, -1);\n\tif (err)\n\t\treturn err;\n\n\terr = media_create_pad_link(&isp->asd.subdev.entity, ATOMISP_SUBDEV_PAD_SOURCE,\n\t\t\t\t    &isp->asd.video_out.vdev.entity, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = v4l2_device_register_subdev_nodes(&isp->v4l2_dev);\n\tif (err)\n\t\treturn err;\n\n\treturn media_device_register(&isp->media_dev);\n}\n\nstatic int atomisp_initialize_modules(struct atomisp_device *isp)\n{\n\tint ret;\n\n\tret = atomisp_mipi_csi2_init(isp);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"mipi csi2 initialization failed\\n\");\n\t\tgoto error_mipi_csi2;\n\t}\n\n\tret = atomisp_tpg_init(isp);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"tpg initialization failed\\n\");\n\t\tgoto error_tpg;\n\t}\n\n\tret = atomisp_subdev_init(isp);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"ISP subdev initialization failed\\n\");\n\t\tgoto error_isp_subdev;\n\t}\n\n\treturn 0;\n\nerror_isp_subdev:\nerror_tpg:\n\tatomisp_tpg_cleanup(isp);\nerror_mipi_csi2:\n\tatomisp_mipi_csi2_cleanup(isp);\n\treturn ret;\n}\n\nstatic void atomisp_uninitialize_modules(struct atomisp_device *isp)\n{\n\tatomisp_tpg_cleanup(isp);\n\tatomisp_mipi_csi2_cleanup(isp);\n}\n\nconst struct firmware *\natomisp_load_firmware(struct atomisp_device *isp)\n{\n\tconst struct firmware *fw;\n\tint rc;\n\tchar *fw_path = NULL;\n\n\tif (skip_fwload)\n\t\treturn NULL;\n\n\tif (firmware_name[0] != '\\0') {\n\t\tfw_path = firmware_name;\n\t} else {\n\t\tif ((isp->media_dev.hw_revision  >> ATOMISP_HW_REVISION_SHIFT)\n\t\t    == ATOMISP_HW_REVISION_ISP2401)\n\t\t\tfw_path = \"shisp_2401a0_v21.bin\";\n\n\t\tif (isp->media_dev.hw_revision ==\n\t\t    ((ATOMISP_HW_REVISION_ISP2401_LEGACY << ATOMISP_HW_REVISION_SHIFT)\n\t\t    | ATOMISP_HW_STEPPING_A0))\n\t\t\tfw_path = \"shisp_2401a0_legacy_v21.bin\";\n\n\t\tif (isp->media_dev.hw_revision ==\n\t\t    ((ATOMISP_HW_REVISION_ISP2400 << ATOMISP_HW_REVISION_SHIFT)\n\t\t    | ATOMISP_HW_STEPPING_B0))\n\t\t\tfw_path = \"shisp_2400b0_v21.bin\";\n\t}\n\n\tif (!fw_path) {\n\t\tdev_err(isp->dev, \"Unsupported hw_revision 0x%x\\n\",\n\t\t\tisp->media_dev.hw_revision);\n\t\treturn NULL;\n\t}\n\n\trc = request_firmware(&fw, fw_path, isp->dev);\n\tif (rc) {\n\t\tdev_err(isp->dev,\n\t\t\t\"atomisp: Error %d while requesting firmware %s\\n\",\n\t\t\trc, fw_path);\n\t\treturn NULL;\n\t}\n\n\treturn fw;\n}\n\n \nstatic bool is_valid_device(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tconst char *name;\n\tconst char *product;\n\n\tproduct = dmi_get_system_info(DMI_PRODUCT_NAME);\n\n\tswitch (id->device & ATOMISP_PCI_DEVICE_SOC_MASK) {\n\tcase ATOMISP_PCI_DEVICE_SOC_MRFLD:\n\t\tname = \"Merrifield\";\n\t\tbreak;\n\tcase ATOMISP_PCI_DEVICE_SOC_BYT:\n\t\tname = \"Baytrail\";\n\t\tbreak;\n\tcase ATOMISP_PCI_DEVICE_SOC_ANN:\n\t\tname = \"Anniedale\";\n\t\tbreak;\n\tcase ATOMISP_PCI_DEVICE_SOC_CHT:\n\t\tname = \"Cherrytrail\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"%s: unknown device ID %x04:%x04\\n\",\n\t\t\tproduct, id->vendor, id->device);\n\t\treturn false;\n\t}\n\n\tif (pdev->revision <= ATOMISP_PCI_REV_BYT_A0_MAX) {\n\t\tdev_err(&pdev->dev, \"%s revision %d is not unsupported\\n\",\n\t\t\tname, pdev->revision);\n\t\treturn false;\n\t}\n\n\t \n\n#ifndef ISP2401\n\tif (IS_ISP2401) {\n\t\tdev_err(&pdev->dev, \"Support for %s (ISP2401) was disabled at compile time\\n\",\n\t\t\tname);\n\t\treturn false;\n\t}\n#else\n\tif (!IS_ISP2401) {\n\t\tdev_err(&pdev->dev, \"Support for %s (ISP2400) was disabled at compile time\\n\",\n\t\t\tname);\n\t\treturn false;\n\t}\n#endif\n\n\tdev_info(&pdev->dev, \"Detected %s version %d (ISP240%c) on %s\\n\",\n\t\t name, pdev->revision, IS_ISP2401 ? '1' : '0', product);\n\n\treturn true;\n}\n\n#define ATOM_ISP_PCI_BAR\t0\n\nstatic int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tconst struct atomisp_platform_data *pdata;\n\tstruct atomisp_device *isp;\n\tunsigned int start;\n\tint err, val;\n\tu32 irq;\n\n\tif (!is_valid_device(pdev, id))\n\t\treturn -ENODEV;\n\n\t \n\tatomisp_dev = &pdev->dev;\n\n\tpdata = atomisp_get_platform_data();\n\tif (!pdata)\n\t\tdev_warn(&pdev->dev, \"no platform data available\\n\");\n\n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to enable CI ISP device (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tstart = pci_resource_start(pdev, ATOM_ISP_PCI_BAR);\n\tdev_dbg(&pdev->dev, \"start: 0x%x\\n\", start);\n\n\terr = pcim_iomap_regions(pdev, BIT(ATOM_ISP_PCI_BAR), pci_name(pdev));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to I/O memory remapping (%d)\\n\", err);\n\t\tgoto ioremap_fail;\n\t}\n\n\tisp = devm_kzalloc(&pdev->dev, sizeof(*isp), GFP_KERNEL);\n\tif (!isp) {\n\t\terr = -ENOMEM;\n\t\tgoto atomisp_dev_alloc_fail;\n\t}\n\n\tisp->dev = &pdev->dev;\n\tisp->base = pcim_iomap_table(pdev)[ATOM_ISP_PCI_BAR];\n\tisp->saved_regs.ispmmadr = start;\n\n\tdev_dbg(&pdev->dev, \"atomisp mmio base: %p\\n\", isp->base);\n\n\tmutex_init(&isp->mutex);\n\tspin_lock_init(&isp->lock);\n\n\t \n\tpdev->d3hot_delay = 0;\n\n\tpci_set_drvdata(pdev, isp);\n\n\tswitch (id->device & ATOMISP_PCI_DEVICE_SOC_MASK) {\n\tcase ATOMISP_PCI_DEVICE_SOC_MRFLD:\n\t\tisp->media_dev.hw_revision =\n\t\t    (ATOMISP_HW_REVISION_ISP2400\n\t\t     << ATOMISP_HW_REVISION_SHIFT) |\n\t\t    ATOMISP_HW_STEPPING_B0;\n\n\t\tswitch (id->device) {\n\t\tcase ATOMISP_PCI_DEVICE_SOC_MRFLD_1179:\n\t\t\tisp->dfs = &dfs_config_merr_1179;\n\t\t\tbreak;\n\t\tcase ATOMISP_PCI_DEVICE_SOC_MRFLD_117A:\n\t\t\tisp->dfs = &dfs_config_merr_117a;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tisp->dfs = &dfs_config_merr;\n\t\t\tbreak;\n\t\t}\n\t\tisp->hpll_freq = HPLL_FREQ_1600MHZ;\n\t\tbreak;\n\tcase ATOMISP_PCI_DEVICE_SOC_BYT:\n\t\tisp->media_dev.hw_revision =\n\t\t    (ATOMISP_HW_REVISION_ISP2400\n\t\t     << ATOMISP_HW_REVISION_SHIFT) |\n\t\t    ATOMISP_HW_STEPPING_B0;\n\n\t\t \n\t\tisp->dfs = &dfs_config_byt;\n\n\t\t \n\t\tisp->hpll_freq = gmin_get_var_int(&pdev->dev, false, \"HpllFreq\", HPLL_FREQ_2000MHZ);\n\n\t\t \n\t\tpdev->d3cold_delay = 0;\n\t\tbreak;\n\tcase ATOMISP_PCI_DEVICE_SOC_ANN:\n\t\tisp->media_dev.hw_revision = (\t ATOMISP_HW_REVISION_ISP2401\n\t\t\t\t\t\t << ATOMISP_HW_REVISION_SHIFT);\n\t\tisp->media_dev.hw_revision |= pdev->revision < 2 ?\n\t\t\t\t\t      ATOMISP_HW_STEPPING_A0 : ATOMISP_HW_STEPPING_B0;\n\t\tisp->dfs = &dfs_config_merr;\n\t\tisp->hpll_freq = HPLL_FREQ_1600MHZ;\n\t\tbreak;\n\tcase ATOMISP_PCI_DEVICE_SOC_CHT:\n\t\tisp->media_dev.hw_revision = (\t ATOMISP_HW_REVISION_ISP2401\n\t\t\t\t\t\t << ATOMISP_HW_REVISION_SHIFT);\n\t\tisp->media_dev.hw_revision |= pdev->revision < 2 ?\n\t\t\t\t\t      ATOMISP_HW_STEPPING_A0 : ATOMISP_HW_STEPPING_B0;\n\n\t\tisp->dfs = &dfs_config_cht;\n\t\tpdev->d3cold_delay = 0;\n\n\t\tiosf_mbi_read(BT_MBI_UNIT_CCK, MBI_REG_READ, CCK_FUSE_REG_0, &val);\n\t\tswitch (val & CCK_FUSE_HPLL_FREQ_MASK) {\n\t\tcase 0x00:\n\t\t\tisp->hpll_freq = HPLL_FREQ_800MHZ;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tisp->hpll_freq = HPLL_FREQ_1600MHZ;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tisp->hpll_freq = HPLL_FREQ_2000MHZ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tisp->hpll_freq = HPLL_FREQ_1600MHZ;\n\t\t\tdev_warn(&pdev->dev, \"read HPLL from cck failed. Default to 1600 MHz.\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"un-supported IUNIT device\\n\");\n\t\terr = -ENODEV;\n\t\tgoto atomisp_dev_alloc_fail;\n\t}\n\n\tdev_info(&pdev->dev, \"ISP HPLL frequency base = %d MHz\\n\", isp->hpll_freq);\n\n\tisp->max_isr_latency = ATOMISP_MAX_ISR_LATENCY;\n\n\t \n\tisp->firmware = atomisp_load_firmware(isp);\n\tif (!isp->firmware) {\n\t\terr = -ENOENT;\n\t\tdev_dbg(&pdev->dev, \"Firmware load failed\\n\");\n\t\tgoto load_fw_fail;\n\t}\n\n\terr = sh_css_check_firmware_version(isp->dev, isp->firmware->data);\n\tif (err) {\n\t\tdev_dbg(&pdev->dev, \"Firmware version check failed\\n\");\n\t\tgoto fw_validation_fail;\n\t}\n\n\tpci_set_master(pdev);\n\n\terr = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to enable msi (%d)\\n\", err);\n\t\tgoto enable_msi_fail;\n\t}\n\n\tatomisp_msi_irq_init(isp);\n\n\tcpu_latency_qos_add_request(&isp->pm_qos, PM_QOS_DEFAULT_VALUE);\n\n\t \n\tatomisp_css2_hw_store_32(MRFLD_CSI_RECEIVER_SELECTION_REG, 1);\n\n\tif ((id->device & ATOMISP_PCI_DEVICE_SOC_MASK) ==\n\t    ATOMISP_PCI_DEVICE_SOC_MRFLD) {\n\t\tu32 csi_afe_trim;\n\n\t\t \n\t\tpci_read_config_dword(pdev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL, &csi_afe_trim);\n\t\tcsi_afe_trim &= ~((MRFLD_PCI_CSI_HSRXCLKTRIM_MASK <<\n\t\t\t\t   MRFLD_PCI_CSI1_HSRXCLKTRIM_SHIFT) |\n\t\t\t\t  (MRFLD_PCI_CSI_HSRXCLKTRIM_MASK <<\n\t\t\t\t   MRFLD_PCI_CSI2_HSRXCLKTRIM_SHIFT) |\n\t\t\t\t  (MRFLD_PCI_CSI_HSRXCLKTRIM_MASK <<\n\t\t\t\t   MRFLD_PCI_CSI3_HSRXCLKTRIM_SHIFT));\n\t\tcsi_afe_trim |= (MRFLD_PCI_CSI1_HSRXCLKTRIM <<\n\t\t\t\t MRFLD_PCI_CSI1_HSRXCLKTRIM_SHIFT) |\n\t\t\t\t(MRFLD_PCI_CSI2_HSRXCLKTRIM <<\n\t\t\t\t MRFLD_PCI_CSI2_HSRXCLKTRIM_SHIFT) |\n\t\t\t\t(MRFLD_PCI_CSI3_HSRXCLKTRIM <<\n\t\t\t\t MRFLD_PCI_CSI3_HSRXCLKTRIM_SHIFT);\n\t\tpci_write_config_dword(pdev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL, csi_afe_trim);\n\t}\n\n\terr = atomisp_initialize_modules(isp);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"atomisp_initialize_modules (%d)\\n\", err);\n\t\tgoto initialize_modules_fail;\n\t}\n\n\terr = atomisp_register_entities(isp);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"atomisp_register_entities failed (%d)\\n\", err);\n\t\tgoto register_entities_fail;\n\t}\n\n\tINIT_WORK(&isp->assert_recovery_work, atomisp_assert_recovery_work);\n\n\t \n\tatomisp_save_iunit_reg(isp);\n\n\t \n\tisp->pm_domain.ops.runtime_suspend = atomisp_power_off;\n\tisp->pm_domain.ops.runtime_resume = atomisp_power_on;\n\tisp->pm_domain.ops.suspend = atomisp_suspend;\n\tisp->pm_domain.ops.resume = atomisp_resume;\n\n\tdev_pm_domain_set(&pdev->dev, &isp->pm_domain);\n\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_allow(&pdev->dev);\n\n\t \n\thmm_init();\n\n\terr = devm_request_threaded_irq(&pdev->dev, pdev->irq,\n\t\t\t\t\tatomisp_isr, atomisp_isr_thread,\n\t\t\t\t\tIRQF_SHARED, \"isp_irq\", isp);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq (%d)\\n\", err);\n\t\tgoto request_irq_fail;\n\t}\n\n\t \n\terr = atomisp_css_load_firmware(isp);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to init css.\\n\");\n\t\tgoto css_init_fail;\n\t}\n\t \n\trelease_firmware(isp->firmware);\n\tisp->firmware = NULL;\n\tisp->css_env.isp_css_fw.data = NULL;\n\n\terr = v4l2_async_nf_register(&isp->notifier);\n\tif (err) {\n\t\tdev_err(isp->dev, \"failed to register async notifier : %d\\n\", err);\n\t\tgoto css_init_fail;\n\t}\n\n\tatomisp_drvfs_init(isp);\n\n\treturn 0;\n\ncss_init_fail:\n\tdevm_free_irq(&pdev->dev, pdev->irq, isp);\nrequest_irq_fail:\n\thmm_cleanup();\n\tpm_runtime_get_noresume(&pdev->dev);\n\tdev_pm_domain_set(&pdev->dev, NULL);\n\tatomisp_unregister_entities(isp);\nregister_entities_fail:\n\tatomisp_uninitialize_modules(isp);\ninitialize_modules_fail:\n\tcpu_latency_qos_remove_request(&isp->pm_qos);\n\tatomisp_msi_irq_uninit(isp);\n\tpci_free_irq_vectors(pdev);\nenable_msi_fail:\nfw_validation_fail:\n\trelease_firmware(isp->firmware);\nload_fw_fail:\n\t \n\n\tpci_read_config_dword(pdev, PCI_INTERRUPT_CTRL, &irq);\n\tirq &= BIT(INTR_IIR);\n\tpci_write_config_dword(pdev, PCI_INTERRUPT_CTRL, irq);\n\n\tpci_read_config_dword(pdev, PCI_INTERRUPT_CTRL, &irq);\n\tirq &= ~BIT(INTR_IER);\n\tpci_write_config_dword(pdev, PCI_INTERRUPT_CTRL, irq);\n\n\tatomisp_msi_irq_uninit(isp);\n\n\t \n\tif (IS_ENABLED(CONFIG_PM) && atomisp_mrfld_power(isp, false))\n\t\tdev_err(&pdev->dev, \"Failed to switch off ISP\\n\");\n\natomisp_dev_alloc_fail:\n\tpcim_iounmap_regions(pdev, BIT(ATOM_ISP_PCI_BAR));\n\nioremap_fail:\n\treturn err;\n}\n\nstatic void atomisp_pci_remove(struct pci_dev *pdev)\n{\n\tstruct atomisp_device *isp = pci_get_drvdata(pdev);\n\n\tdev_info(&pdev->dev, \"Removing atomisp driver\\n\");\n\n\tatomisp_drvfs_exit();\n\n\tia_css_unload_firmware();\n\thmm_cleanup();\n\n\tpm_runtime_forbid(&pdev->dev);\n\tpm_runtime_get_noresume(&pdev->dev);\n\tdev_pm_domain_set(&pdev->dev, NULL);\n\tcpu_latency_qos_remove_request(&isp->pm_qos);\n\n\tatomisp_msi_irq_uninit(isp);\n\tatomisp_unregister_entities(isp);\n\n\trelease_firmware(isp->firmware);\n}\n\nstatic const struct pci_device_id atomisp_pci_tbl[] = {\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_MRFLD)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_MRFLD_1179)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_MRFLD_117A)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_BYT)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_ANN)},\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_CHT)},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, atomisp_pci_tbl);\n\n\nstatic struct pci_driver atomisp_pci_driver = {\n\t.name = \"atomisp-isp2\",\n\t.id_table = atomisp_pci_tbl,\n\t.probe = atomisp_pci_probe,\n\t.remove = atomisp_pci_remove,\n};\n\nmodule_pci_driver(atomisp_pci_driver);\n\nMODULE_AUTHOR(\"Wen Wang <wen.w.wang@intel.com>\");\nMODULE_AUTHOR(\"Xiaolin Zhang <xiaolin.zhang@intel.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Intel ATOM Platform ISP Driver\");\nMODULE_IMPORT_NS(INTEL_IPU_BRIDGE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}