{
  "module_name": "atomisp_tpg.c",
  "hash_id": "05ef85125d3c5a144970bb92c3cb0f33d0153ae4ea0afa48f08a0ef9ea49e5dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/atomisp_tpg.c",
  "human_readable_source": "\n \n\n#include <media/v4l2-event.h>\n#include <media/v4l2-mediabus.h>\n#include \"atomisp_internal.h\"\n#include \"atomisp_tpg.h\"\n\nstatic int tpg_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\treturn 0;\n}\n\nstatic int tpg_get_fmt(struct v4l2_subdev *sd,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       struct v4l2_subdev_format *format)\n{\n\t \n\treturn 0;\n}\n\nstatic int tpg_set_fmt(struct v4l2_subdev *sd,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\t \n\tfmt->code = MEDIA_BUS_FMT_SGRBG8_1X8;\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tsd_state->pads->try_fmt = *fmt;\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int tpg_log_status(struct v4l2_subdev *sd)\n{\n\t \n\treturn 0;\n}\n\nstatic int tpg_s_power(struct v4l2_subdev *sd, int on)\n{\n\treturn 0;\n}\n\nstatic int tpg_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\t \n\treturn 0;\n}\n\nstatic int tpg_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_frame_size_enum *fse)\n{\n\t \n\treturn 0;\n}\n\nstatic int tpg_enum_frame_ival(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_frame_interval_enum *fie)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops tpg_video_ops = {\n\t.s_stream = tpg_s_stream,\n};\n\nstatic const struct v4l2_subdev_core_ops tpg_core_ops = {\n\t.log_status = tpg_log_status,\n\t.s_power = tpg_s_power,\n};\n\nstatic const struct v4l2_subdev_pad_ops tpg_pad_ops = {\n\t.enum_mbus_code = tpg_enum_mbus_code,\n\t.enum_frame_size = tpg_enum_frame_size,\n\t.enum_frame_interval = tpg_enum_frame_ival,\n\t.get_fmt = tpg_get_fmt,\n\t.set_fmt = tpg_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops tpg_ops = {\n\t.core = &tpg_core_ops,\n\t.video = &tpg_video_ops,\n\t.pad = &tpg_pad_ops,\n};\n\nvoid atomisp_tpg_unregister_entities(struct atomisp_tpg_device *tpg)\n{\n\tmedia_entity_cleanup(&tpg->sd.entity);\n\tv4l2_device_unregister_subdev(&tpg->sd);\n}\n\nint atomisp_tpg_register_entities(struct atomisp_tpg_device *tpg,\n\t\t\t\t  struct v4l2_device *vdev)\n{\n\tint ret;\n\t \n\tret = v4l2_device_register_subdev(vdev, &tpg->sd);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tatomisp_tpg_unregister_entities(tpg);\n\treturn ret;\n}\n\nvoid atomisp_tpg_cleanup(struct atomisp_device *isp)\n{\n}\n\nint atomisp_tpg_init(struct atomisp_device *isp)\n{\n\tstruct atomisp_tpg_device *tpg = &isp->tpg;\n\tstruct v4l2_subdev *sd = &tpg->sd;\n\tstruct media_pad *pads = tpg->pads;\n\tstruct media_entity *me = &sd->entity;\n\tint ret;\n\n\ttpg->isp = isp;\n\tv4l2_subdev_init(sd, &tpg_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tstrscpy(sd->name, \"tpg_subdev\", sizeof(sd->name));\n\tv4l2_set_subdevdata(sd, tpg);\n\n\tpads[0].flags = MEDIA_PAD_FL_SINK;\n\tme->function = MEDIA_ENT_F_PROC_VIDEO_ISP;\n\n\tret = media_entity_pads_init(me, 1, pads);\n\tif (ret < 0)\n\t\tgoto fail;\n\treturn 0;\nfail:\n\tatomisp_tpg_cleanup(isp);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}