{
  "module_name": "refcount.c",
  "hash_id": "5379b7186a12c46682cde9594206a7f299c0201b9532a5ff4779125f747fec52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/base/refcount/src/refcount.c",
  "human_readable_source": "\n \n\n#include \"hmm.h\"\n\n#include \"ia_css_refcount.h\"\n#include \"sh_css_defs.h\"\n\n#include \"platform_support.h\"\n\n#include \"assert_support.h\"\n\n#include \"ia_css_debug.h\"\n\n \nstruct ia_css_refcount_entry {\n\tu32 count;\n\tia_css_ptr data;\n\ts32 id;\n};\n\nstruct ia_css_refcount_list {\n\tu32 size;\n\tstruct ia_css_refcount_entry *items;\n};\n\nstatic struct ia_css_refcount_list myrefcount;\n\nstatic struct ia_css_refcount_entry *refcount_find_entry(ia_css_ptr ptr,\n\tbool firstfree)\n{\n\tu32 i;\n\n\tif (ptr == 0)\n\t\treturn NULL;\n\tif (!myrefcount.items) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,\n\t\t\t\t    \"%s(): Ref count not initialized!\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < myrefcount.size; i++) {\n\t\tif ((&myrefcount.items[i])->data == 0) {\n\t\t\tif (firstfree) {\n\t\t\t\t \n\t\t\t\treturn &myrefcount.items[i];\n\t\t\t}\n\t\t}\n\t\tif ((&myrefcount.items[i])->data == ptr) {\n\t\t\t \n\t\t\treturn &myrefcount.items[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint ia_css_refcount_init(uint32_t size)\n{\n\tint err = 0;\n\n\tif (size == 0) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"%s(): Size of 0 for Ref count init!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (myrefcount.items) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"%s(): Ref count is already initialized\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tmyrefcount.items =\n\t    kvmalloc(sizeof(struct ia_css_refcount_entry) * size, GFP_KERNEL);\n\tif (!myrefcount.items)\n\t\terr = -ENOMEM;\n\tif (!err) {\n\t\tmemset(myrefcount.items, 0,\n\t\t       sizeof(struct ia_css_refcount_entry) * size);\n\t\tmyrefcount.size = size;\n\t}\n\treturn err;\n}\n\nvoid ia_css_refcount_uninit(void)\n{\n\tstruct ia_css_refcount_entry *entry;\n\tu32 i;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"%s() entry\\n\", __func__);\n\tfor (i = 0; i < myrefcount.size; i++) {\n\t\t \n\t\tentry = myrefcount.items + i;\n\t\tif (entry->data != mmgr_NULL) {\n\t\t\t \n\t\t\thmm_free(entry->data);\n\t\t\tentry->data = mmgr_NULL;\n\t\t\tentry->count = 0;\n\t\t\tentry->id = 0;\n\t\t}\n\t}\n\tkvfree(myrefcount.items);\n\tmyrefcount.items = NULL;\n\tmyrefcount.size = 0;\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"%s() leave\\n\", __func__);\n}\n\nia_css_ptr ia_css_refcount_increment(s32 id, ia_css_ptr ptr)\n{\n\tstruct ia_css_refcount_entry *entry;\n\n\tif (ptr == mmgr_NULL)\n\t\treturn ptr;\n\n\tentry = refcount_find_entry(ptr, false);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"%s(%x) 0x%x\\n\", __func__, id, ptr);\n\n\tif (!entry) {\n\t\tentry = refcount_find_entry(ptr, true);\n\t\tassert(entry);\n\t\tif (!entry)\n\t\t\treturn mmgr_NULL;\n\t\tentry->id = id;\n\t}\n\n\tif (entry->id != id) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,\n\t\t\t\t    \"%s(): Ref count IDS do not match!\\n\", __func__);\n\t\treturn mmgr_NULL;\n\t}\n\n\tif (entry->data == ptr)\n\t\tentry->count += 1;\n\telse if (entry->data == mmgr_NULL) {\n\t\tentry->data = ptr;\n\t\tentry->count = 1;\n\t} else\n\t\treturn mmgr_NULL;\n\n\treturn ptr;\n}\n\nbool ia_css_refcount_decrement(s32 id, ia_css_ptr ptr)\n{\n\tstruct ia_css_refcount_entry *entry;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"%s(%x) 0x%x\\n\", __func__, id, ptr);\n\n\tif (ptr == mmgr_NULL)\n\t\treturn false;\n\n\tentry = refcount_find_entry(ptr, false);\n\n\tif (entry) {\n\t\tif (entry->id != id) {\n\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,\n\t\t\t\t\t    \"%s(): Ref count IDS do not match!\\n\", __func__);\n\t\t\treturn false;\n\t\t}\n\t\tif (entry->count > 0) {\n\t\t\tentry->count -= 1;\n\t\t\tif (entry->count == 0) {\n\t\t\t\t \n\t\t\t\thmm_free(ptr);\n\t\t\t\tentry->data = mmgr_NULL;\n\t\t\t\tentry->id = 0;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t \n\tif (entry)\n\t\tIA_CSS_ERROR(\"id %x, ptr 0x%x entry %p entry->id %x entry->count %d\\n\",\n\t\t\t     id, ptr, entry, entry->id, entry->count);\n\telse\n\t\tIA_CSS_ERROR(\"entry NULL\\n\");\n\tassert(false);\n\n\treturn false;\n}\n\nbool ia_css_refcount_is_single(ia_css_ptr ptr)\n{\n\tstruct ia_css_refcount_entry *entry;\n\n\tif (ptr == mmgr_NULL)\n\t\treturn false;\n\n\tentry = refcount_find_entry(ptr, false);\n\n\tif (entry)\n\t\treturn (entry->count == 1);\n\n\treturn true;\n}\n\nvoid ia_css_refcount_clear(s32 id, clear_func clear_func_ptr)\n{\n\tstruct ia_css_refcount_entry *entry;\n\tu32 i;\n\tu32 count = 0;\n\n\tassert(clear_func_ptr);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%s(%x)\\n\",\n\t\t\t    __func__, id);\n\n\tfor (i = 0; i < myrefcount.size; i++) {\n\t\t \n\t\tentry = myrefcount.items + i;\n\t\tif ((entry->data != mmgr_NULL) && (entry->id == id)) {\n\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t    \"%s: %x: 0x%x\\n\", __func__,\n\t\t\t\t\t    id, entry->data);\n\t\t\tif (clear_func_ptr) {\n\t\t\t\t \n\t\t\t\tclear_func_ptr(entry->data);\n\t\t\t} else {\n\t\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t\t    \"%s: using hmm_free: no clear_func\\n\", __func__);\n\t\t\t\thmm_free(entry->data);\n\t\t\t}\n\n\t\t\tif (entry->count != 0) {\n\t\t\t\tIA_CSS_WARNING(\"Ref count for entry %x is not zero!\", entry->id);\n\t\t\t}\n\n\t\t\tassert(entry->count == 0);\n\n\t\t\tentry->data = mmgr_NULL;\n\t\t\tentry->count = 0;\n\t\t\tentry->id = 0;\n\t\t\tcount++;\n\t\t}\n\t}\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"%s(%x): cleared %d\\n\", __func__, id,\n\t\t\t    count);\n}\n\nbool ia_css_refcount_is_valid(ia_css_ptr ptr)\n{\n\tstruct ia_css_refcount_entry *entry;\n\n\tif (ptr == mmgr_NULL)\n\t\treturn false;\n\n\tentry = refcount_find_entry(ptr, false);\n\n\treturn entry;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}