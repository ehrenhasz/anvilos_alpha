{
  "module_name": "circbuf.c",
  "hash_id": "fa500d21b3dd2e7b1d9b77a2ce60710c56571d1ee5ed1e00c62ec84d3a538187",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/base/circbuf/src/circbuf.c",
  "human_readable_source": "\n \n\n#include \"ia_css_circbuf.h\"\n\n#include <assert_support.h>\n\n \n \nstatic inline ia_css_circbuf_elem_t\nia_css_circbuf_read(ia_css_circbuf_t *cb);\n\n \nstatic inline void ia_css_circbuf_shift_chunk(ia_css_circbuf_t *cb,\n\tu32 chunk_src,\n\tuint32_t chunk_dest);\n\n \nstatic inline uint32_t\nia_css_circbuf_elem_get_val(ia_css_circbuf_elem_t *elem);\n\n \n \nvoid\nia_css_circbuf_create(ia_css_circbuf_t *cb,\n\t\t      ia_css_circbuf_elem_t *elems,\n\t\t      ia_css_circbuf_desc_t *desc)\n{\n\tu32 i;\n\n\tOP___assert(desc);\n\n\tcb->desc = desc;\n\t \n\tcb->desc->start = 0;\n\tcb->desc->end = 0;\n\tcb->desc->step = 0;\n\n\tfor (i = 0; i < cb->desc->size; i++)\n\t\tia_css_circbuf_elem_init(&elems[i]);\n\n\tcb->elems = elems;\n}\n\n \nvoid ia_css_circbuf_destroy(ia_css_circbuf_t *cb)\n{\n\tcb->desc = NULL;\n\n\tcb->elems = NULL;\n}\n\n \nuint32_t ia_css_circbuf_pop(ia_css_circbuf_t *cb)\n{\n\tu32 ret;\n\tia_css_circbuf_elem_t elem;\n\n\tassert(!ia_css_circbuf_is_empty(cb));\n\n\t \n\telem = ia_css_circbuf_read(cb);\n\tret = ia_css_circbuf_elem_get_val(&elem);\n\treturn ret;\n}\n\n \nuint32_t ia_css_circbuf_extract(ia_css_circbuf_t *cb, int offset)\n{\n\tint max_offset;\n\tu32 val;\n\tu32 pos;\n\tu32 src_pos;\n\tu32 dest_pos;\n\n\t \n\tmax_offset = ia_css_circbuf_get_offset(cb, cb->desc->start, cb->desc->end);\n\tmax_offset--;\n\n\t \n\tif (offset == 0) {\n\t\tval = ia_css_circbuf_pop(cb);\n\t\treturn val;\n\t}\n\n\t \n\tif (offset > max_offset) {\n\t\tval = 0;\n\t\treturn val;\n\t}\n\n\t \n\t \n\tpos = ia_css_circbuf_get_pos_at_offset(cb, cb->desc->start, offset);\n\n\t \n\tval = ia_css_circbuf_elem_get_val(&cb->elems[pos]);\n\n\t \n\tsrc_pos = ia_css_circbuf_get_pos_at_offset(cb, pos, -1);\n\tdest_pos = pos;\n\tia_css_circbuf_shift_chunk(cb, src_pos, dest_pos);\n\n\treturn val;\n}\n\n \nuint32_t ia_css_circbuf_peek(ia_css_circbuf_t *cb, int offset)\n{\n\tint pos;\n\n\tpos = ia_css_circbuf_get_pos_at_offset(cb, cb->desc->end, offset);\n\n\t \n\treturn cb->elems[pos].val;\n}\n\n \nuint32_t ia_css_circbuf_peek_from_start(ia_css_circbuf_t *cb, int offset)\n{\n\tint pos;\n\n\tpos = ia_css_circbuf_get_pos_at_offset(cb, cb->desc->start, offset);\n\n\t \n\treturn cb->elems[pos].val;\n}\n\n \nbool ia_css_circbuf_increase_size(\n    ia_css_circbuf_t *cb,\n    unsigned int sz_delta,\n    ia_css_circbuf_elem_t *elems)\n{\n\tu8 curr_size;\n\tu8 curr_end;\n\tunsigned int i = 0;\n\n\tif (!cb || sz_delta == 0)\n\t\treturn false;\n\n\tcurr_size = cb->desc->size;\n\tcurr_end = cb->desc->end;\n\t \n\t \n\tif (((uint8_t)(cb->desc->size + (uint8_t)sz_delta) > cb->desc->size) &&\n\t    ((uint8_t)sz_delta == sz_delta))\n\t\tcb->desc->size += (uint8_t)sz_delta;\n\telse\n\t\treturn false;  \n\n\t \n\tif (elems) {\n\t\t \n\t\tfor (i = curr_size; i <  cb->desc->size; i++)\n\t\t\tcb->elems[i] = elems[i - curr_size];\n\t}\n\t \n\tif (curr_end < cb->desc->start) {\n\t\tif (curr_end == 0) {\n\t\t\t \n\t\t\tcb->desc->end = curr_size;\n\t\t} else {\n\t\t\t \n\t\t\tia_css_circbuf_shift_chunk(cb,\n\t\t\t\t\t\t   curr_size - 1,\n\t\t\t\t\t\t   curr_size + sz_delta - 1);\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \n \nstatic inline uint32_t\nia_css_circbuf_elem_get_val(ia_css_circbuf_elem_t *elem)\n{\n\treturn elem->val;\n}\n\n \nstatic inline ia_css_circbuf_elem_t\nia_css_circbuf_read(ia_css_circbuf_t *cb)\n{\n\tia_css_circbuf_elem_t elem;\n\n\t \n\telem = cb->elems[cb->desc->start];\n\n\t \n\tia_css_circbuf_elem_init(&cb->elems[cb->desc->start]);\n\n\t \n\tcb->desc->start = ia_css_circbuf_get_pos_at_offset(cb, cb->desc->start, 1);\n\treturn elem;\n}\n\n \nstatic inline void\nia_css_circbuf_shift_chunk(ia_css_circbuf_t *cb,\n\t\t\t   u32 chunk_src, uint32_t chunk_dest)\n{\n\tint chunk_offset;\n\tint chunk_sz;\n\tint i;\n\n\t \n\tchunk_offset = ia_css_circbuf_get_offset(cb,\n\t\t       chunk_src, chunk_dest);\n\tchunk_sz = ia_css_circbuf_get_offset(cb, cb->desc->start, chunk_src) + 1;\n\n\t \n\tfor (i = 0; i < chunk_sz; i++) {\n\t\t \n\t\tia_css_circbuf_elem_cpy(&cb->elems[chunk_src],\n\t\t\t\t\t&cb->elems[chunk_dest]);\n\n\t\t \n\t\tia_css_circbuf_elem_init(&cb->elems[chunk_src]);\n\n\t\t \n\t\tchunk_src = ia_css_circbuf_get_pos_at_offset(cb, chunk_src, -1);\n\t\tchunk_dest = ia_css_circbuf_get_pos_at_offset(cb, chunk_dest, -1);\n\t}\n\n\t \n\tcb->desc->start = ia_css_circbuf_get_pos_at_offset(cb, cb->desc->start,\n\t\t\t  chunk_offset);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}