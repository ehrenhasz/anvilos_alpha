{
  "module_name": "spctrl.c",
  "hash_id": "e959230b26fd6a4e9dc7c1638a9138a03757957861862be600b0cb66e8272cfe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/runtime/spctrl/src/spctrl.c",
  "human_readable_source": "\n \n\n#include \"hmm.h\"\n\n#include \"ia_css_types.h\"\n#define __INLINE_SP__\n#include \"sp.h\"\n\n#include \"assert_support.h\"\n#include \"ia_css_spctrl.h\"\n#include \"ia_css_debug.h\"\n\nstruct spctrl_context_info {\n\tstruct ia_css_sp_init_dmem_cfg dmem_config;\n\tu32        spctrl_config_dmem_addr;  \n\tu32        spctrl_state_dmem_addr;\n\tunsigned int    sp_entry;            \n\tia_css_ptr    code_addr;           \n\tu32        code_size;\n\tchar           *program_name;        \n};\n\nstatic struct spctrl_context_info spctrl_cofig_info[N_SP_ID];\nstatic bool spctrl_loaded[N_SP_ID] = {0};\n\n \nint ia_css_spctrl_load_fw(sp_ID_t sp_id, ia_css_spctrl_cfg *spctrl_cfg)\n{\n\tia_css_ptr code_addr = mmgr_NULL;\n\tstruct ia_css_sp_init_dmem_cfg *init_dmem_cfg;\n\n\tif ((sp_id >= N_SP_ID) || (!spctrl_cfg))\n\t\treturn -EINVAL;\n\n\tspctrl_cofig_info[sp_id].code_addr = mmgr_NULL;\n\n\tinit_dmem_cfg = &spctrl_cofig_info[sp_id].dmem_config;\n\tinit_dmem_cfg->dmem_data_addr = spctrl_cfg->dmem_data_addr;\n\tinit_dmem_cfg->dmem_bss_addr  = spctrl_cfg->dmem_bss_addr;\n\tinit_dmem_cfg->data_size      = spctrl_cfg->data_size;\n\tinit_dmem_cfg->bss_size       = spctrl_cfg->bss_size;\n\tinit_dmem_cfg->sp_id          = sp_id;\n\n\tspctrl_cofig_info[sp_id].spctrl_config_dmem_addr =\n\t    spctrl_cfg->spctrl_config_dmem_addr;\n\tspctrl_cofig_info[sp_id].spctrl_state_dmem_addr =\n\t    spctrl_cfg->spctrl_state_dmem_addr;\n\n\t \n\tcode_addr = hmm_alloc(spctrl_cfg->code_size);\n\tif (code_addr == mmgr_NULL)\n\t\treturn -ENOMEM;\n\thmm_store(code_addr, spctrl_cfg->code, spctrl_cfg->code_size);\n\n\tif (sizeof(ia_css_ptr) > sizeof(hrt_data)) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,\n\t\t\t\t    \"size of ia_css_ptr can not be greater than hrt_data\\n\");\n\t\thmm_free(code_addr);\n\t\tcode_addr = mmgr_NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tinit_dmem_cfg->ddr_data_addr  = code_addr + spctrl_cfg->ddr_data_offset;\n\tif ((init_dmem_cfg->ddr_data_addr % HIVE_ISP_DDR_WORD_BYTES) != 0) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,\n\t\t\t\t    \"DDR address pointer is not properly aligned for DMA transfer\\n\");\n\t\thmm_free(code_addr);\n\t\tcode_addr = mmgr_NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tspctrl_cofig_info[sp_id].sp_entry = spctrl_cfg->sp_entry;\n\tspctrl_cofig_info[sp_id].code_addr = code_addr;\n\tspctrl_cofig_info[sp_id].program_name = spctrl_cfg->program_name;\n\n\t \n\tsp_ctrl_store(sp_id, SP_ICACHE_ADDR_REG,\n\t\t      (hrt_data)spctrl_cofig_info[sp_id].code_addr);\n\tsp_ctrl_setbit(sp_id, SP_ICACHE_INV_REG, SP_ICACHE_INV_BIT);\n\tspctrl_loaded[sp_id] = true;\n\treturn 0;\n}\n\n \n \nvoid sh_css_spctrl_reload_fw(sp_ID_t sp_id)\n{\n\t \n\tsp_ctrl_store(sp_id, SP_ICACHE_ADDR_REG,\n\t\t      (hrt_data)spctrl_cofig_info[sp_id].code_addr);\n\tsp_ctrl_setbit(sp_id, SP_ICACHE_INV_REG, SP_ICACHE_INV_BIT);\n\tspctrl_loaded[sp_id] = true;\n}\n\nia_css_ptr get_sp_code_addr(sp_ID_t  sp_id)\n{\n\treturn spctrl_cofig_info[sp_id].code_addr;\n}\n\nint ia_css_spctrl_unload_fw(sp_ID_t sp_id)\n{\n\tif ((sp_id >= N_SP_ID) || ((sp_id < N_SP_ID) && (!spctrl_loaded[sp_id])))\n\t\treturn -EINVAL;\n\n\t \n\tif (spctrl_cofig_info[sp_id].code_addr) {\n\t\thmm_free(spctrl_cofig_info[sp_id].code_addr);\n\t\tspctrl_cofig_info[sp_id].code_addr = mmgr_NULL;\n\t}\n\tspctrl_loaded[sp_id] = false;\n\treturn 0;\n}\n\n \nint ia_css_spctrl_start(sp_ID_t sp_id)\n{\n\tif ((sp_id >= N_SP_ID) || ((sp_id < N_SP_ID) && (!spctrl_loaded[sp_id])))\n\t\treturn -EINVAL;\n\n\t \n\t \n\tassert(sizeof(unsigned int) <= sizeof(hrt_data));\n\n\tsp_dmem_store(sp_id,\n\t\t      spctrl_cofig_info[sp_id].spctrl_config_dmem_addr,\n\t\t      &spctrl_cofig_info[sp_id].dmem_config,\n\t\t      sizeof(spctrl_cofig_info[sp_id].dmem_config));\n\t \n\tsp_ctrl_store(sp_id, SP_START_ADDR_REG,\n\t\t      (hrt_data)spctrl_cofig_info[sp_id].sp_entry);\n\tsp_ctrl_setbit(sp_id, SP_SC_REG, SP_RUN_BIT);\n\tsp_ctrl_setbit(sp_id, SP_SC_REG, SP_START_BIT);\n\treturn 0;\n}\n\n \nia_css_spctrl_sp_sw_state ia_css_spctrl_get_state(sp_ID_t sp_id)\n{\n\tia_css_spctrl_sp_sw_state state = 0;\n\tunsigned int HIVE_ADDR_sp_sw_state;\n\n\tif (sp_id >= N_SP_ID)\n\t\treturn IA_CSS_SP_SW_TERMINATED;\n\n\tHIVE_ADDR_sp_sw_state = spctrl_cofig_info[sp_id].spctrl_state_dmem_addr;\n\t(void)HIVE_ADDR_sp_sw_state;  \n\tif (sp_id == SP0_ID)\n\t\tstate = sp_dmem_load_uint32(sp_id, (unsigned int)sp_address_of(sp_sw_state));\n\treturn state;\n}\n\nint ia_css_spctrl_is_idle(sp_ID_t sp_id)\n{\n\tint state = 0;\n\n\tassert(sp_id < N_SP_ID);\n\n\tstate = sp_ctrl_getbit(sp_id, SP_SC_REG, SP_IDLE_BIT);\n\treturn state;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}