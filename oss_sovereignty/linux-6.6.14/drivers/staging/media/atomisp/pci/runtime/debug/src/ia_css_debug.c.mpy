{
  "module_name": "ia_css_debug.c",
  "hash_id": "8b031f7d93c6477fc540f917913edf3862c603c1cfc4b651add0d22db9519dd3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/runtime/debug/src/ia_css_debug.c",
  "human_readable_source": "\n \n\n#include \"debug.h\"\n\n#ifndef __INLINE_INPUT_SYSTEM__\n#define __INLINE_INPUT_SYSTEM__\n#endif\n#ifndef __INLINE_IBUF_CTRL__\n#define __INLINE_IBUF_CTRL__\n#endif\n#ifndef __INLINE_CSI_RX__\n#define __INLINE_CSI_RX__\n#endif\n#ifndef __INLINE_PIXELGEN__\n#define __INLINE_PIXELGEN__\n#endif\n#ifndef __INLINE_STREAM2MMIO__\n#define __INLINE_STREAM2MMIO__\n#endif\n\n#include <linux/string.h>  \n\n#include \"ia_css_debug.h\"\n#include \"ia_css_debug_pipe.h\"\n#include \"ia_css_irq.h\"\n#include \"ia_css_stream.h\"\n#include \"ia_css_pipeline.h\"\n#include \"ia_css_isp_param.h\"\n#include \"sh_css_params.h\"\n#include \"ia_css_bufq.h\"\n \n#include \"ia_css_queue.h\"\n\n#include \"ia_css_isp_params.h\"\n\n#include \"system_local.h\"\n#include \"assert_support.h\"\n#include \"print_support.h\"\n\n#include \"fifo_monitor.h\"\n\n#include \"input_formatter.h\"\n#include \"dma.h\"\n#include \"irq.h\"\n#include \"gp_device.h\"\n#include \"sp.h\"\n#include \"isp.h\"\n#include \"type_support.h\"\n#include \"math_support.h\"  \n#include \"input_system.h\"\t \n#include \"ia_css_tagger_common.h\"\n\n#include \"sh_css_internal.h\"\n#include \"ia_css_isys.h\"\n#include \"sh_css_sp.h\"\t\t \n\n#include \"css_trace.h\"       \n\n#include \"device_access.h\"\t \n\n \n#include \"anr/anr_1.0/ia_css_anr.host.h\"\n#include \"cnr/cnr_1.0/ia_css_cnr.host.h\"\n#include \"csc/csc_1.0/ia_css_csc.host.h\"\n#include \"de/de_1.0/ia_css_de.host.h\"\n#include \"dp/dp_1.0/ia_css_dp.host.h\"\n#include \"bnr/bnr_1.0/ia_css_bnr.host.h\"\n#include \"fpn/fpn_1.0/ia_css_fpn.host.h\"\n#include \"gc/gc_1.0/ia_css_gc.host.h\"\n#include \"ob/ob_1.0/ia_css_ob.host.h\"\n#include \"s3a/s3a_1.0/ia_css_s3a.host.h\"\n#include \"sc/sc_1.0/ia_css_sc.host.h\"\n#include \"tnr/tnr_1.0/ia_css_tnr.host.h\"\n#include \"uds/uds_1.0/ia_css_uds_param.h\"\n#include \"wb/wb_1.0/ia_css_wb.host.h\"\n#include \"ynr/ynr_1.0/ia_css_ynr.host.h\"\n\n \n#include \"aa/aa_2/ia_css_aa2.host.h\"\n#include \"anr/anr_2/ia_css_anr2.host.h\"\n#include \"cnr/cnr_2/ia_css_cnr2.host.h\"\n#include \"de/de_2/ia_css_de2.host.h\"\n#include \"gc/gc_2/ia_css_gc2.host.h\"\n#include \"ynr/ynr_2/ia_css_ynr2.host.h\"\n\n#define DPG_START \"ia_css_debug_pipe_graph_dump_start \"\n#define DPG_END   \" ia_css_debug_pipe_graph_dump_end\\n\"\n\n#define ENABLE_LINE_MAX_LENGTH (25)\n\n \n#define MAX_THREAD_NUM (SH_CSS_MAX_SP_THREADS + SH_CSS_MAX_SP_INTERNAL_THREADS)\n\nstatic struct pipe_graph_class {\n\tbool do_init;\n\tint height;\n\tint width;\n\tint eff_height;\n\tint eff_width;\n\tenum atomisp_input_format stream_format;\n} pg_inst = {true, 0, 0, 0, 0, N_ATOMISP_INPUT_FORMAT};\n\nstatic const char *const queue_id_to_str[] = {\n\t  \"queue_A\",\n\t  \"queue_B\",\n\t  \"queue_C\",\n\t  \"queue_D\",\n\t  \"queue_E\",\n\t  \"queue_F\",\n\t  \"queue_G\",\n\t  \"queue_H\"\n};\n\nstatic const char *const pipe_id_to_str[] = {\n\t  \"preview\",\n\t  \"copy\",\n\t  \"video\",\n\t  \"capture\",\n\t  \"yuvpp\",\n};\n\nstatic char dot_id_input_bin[SH_CSS_MAX_BINARY_NAME + 10];\nstatic char ring_buffer[200];\n\nvoid ia_css_debug_dtrace(unsigned int level, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tia_css_debug_vdtrace(level, fmt, ap);\n\tva_end(ap);\n}\n\nstatic void debug_dump_long_array_formatted(\n    const sp_ID_t sp_id,\n    hrt_address stack_sp_addr,\n    unsigned int stack_size)\n{\n\tunsigned int i;\n\tu32 val;\n\tu32 addr = (uint32_t)stack_sp_addr;\n\tu32 stack_size_words = CEIL_DIV(stack_size, sizeof(uint32_t));\n\n\t \n\tfor (i = 0; i < stack_size_words; i++) {\n\t\tval = sp_dmem_load_uint32(sp_id, (hrt_address)addr);\n\t\tif ((i % 8) == 0)\n\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"\\n\");\n\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"0x%08x \", val);\n\t\taddr += sizeof(uint32_t);\n\t}\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"\\n\");\n}\n\nstatic void debug_dump_sp_stack_info(\n    const sp_ID_t sp_id)\n{\n\tconst struct ia_css_fw_info *fw;\n\tunsigned int HIVE_ADDR_sp_threads_stack;\n\tunsigned int HIVE_ADDR_sp_threads_stack_size;\n\tu32 stack_sizes[MAX_THREAD_NUM];\n\tu32 stack_sp_addr[MAX_THREAD_NUM];\n\tunsigned int i;\n\n\tfw = &sh_css_sp_fw;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"sp_id(%u) stack info\\n\", sp_id);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"from objects stack_addr_offset:0x%x stack_size_offset:0x%x\\n\",\n\t\t\t    fw->info.sp.threads_stack,\n\t\t\t    fw->info.sp.threads_stack_size);\n\n\tHIVE_ADDR_sp_threads_stack = fw->info.sp.threads_stack;\n\tHIVE_ADDR_sp_threads_stack_size = fw->info.sp.threads_stack_size;\n\n\tif (fw->info.sp.threads_stack == 0 ||\n\t    fw->info.sp.threads_stack_size == 0)\n\t\treturn;\n\n\t(void)HIVE_ADDR_sp_threads_stack;\n\t(void)HIVE_ADDR_sp_threads_stack_size;\n\n\tsp_dmem_load(sp_id,\n\t\t     (unsigned int)sp_address_of(sp_threads_stack),\n\t\t     &stack_sp_addr, sizeof(stack_sp_addr));\n\tsp_dmem_load(sp_id,\n\t\t     (unsigned int)sp_address_of(sp_threads_stack_size),\n\t\t     &stack_sizes, sizeof(stack_sizes));\n\n\tfor (i = 0 ; i < MAX_THREAD_NUM; i++) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t\t    \"thread: %u stack_addr: 0x%08x stack_size: %u\\n\",\n\t\t\t\t    i, stack_sp_addr[i], stack_sizes[i]);\n\t\tdebug_dump_long_array_formatted(sp_id, (hrt_address)stack_sp_addr[i],\n\t\t\t\t\t\tstack_sizes[i]);\n\t}\n}\n\nvoid ia_css_debug_dump_sp_stack_info(void)\n{\n\tdebug_dump_sp_stack_info(SP0_ID);\n}\n\nvoid ia_css_debug_set_dtrace_level(const unsigned int trace_level)\n{\n\tdbg_level = trace_level;\n\treturn;\n}\n\nunsigned int ia_css_debug_get_dtrace_level(void)\n{\n\treturn dbg_level;\n}\n\nstatic const char *debug_stream_format2str(const enum atomisp_input_format\n\tstream_format)\n{\n\tswitch (stream_format) {\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY:\n\t\treturn \"yuv420-8-legacy\";\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8:\n\t\treturn \"yuv420-8\";\n\tcase ATOMISP_INPUT_FORMAT_YUV420_10:\n\t\treturn \"yuv420-10\";\n\tcase ATOMISP_INPUT_FORMAT_YUV420_16:\n\t\treturn \"yuv420-16\";\n\tcase ATOMISP_INPUT_FORMAT_YUV422_8:\n\t\treturn \"yuv422-8\";\n\tcase ATOMISP_INPUT_FORMAT_YUV422_10:\n\t\treturn \"yuv422-10\";\n\tcase ATOMISP_INPUT_FORMAT_YUV422_16:\n\t\treturn \"yuv422-16\";\n\tcase ATOMISP_INPUT_FORMAT_RGB_444:\n\t\treturn \"rgb444\";\n\tcase ATOMISP_INPUT_FORMAT_RGB_555:\n\t\treturn \"rgb555\";\n\tcase ATOMISP_INPUT_FORMAT_RGB_565:\n\t\treturn \"rgb565\";\n\tcase ATOMISP_INPUT_FORMAT_RGB_666:\n\t\treturn \"rgb666\";\n\tcase ATOMISP_INPUT_FORMAT_RGB_888:\n\t\treturn \"rgb888\";\n\tcase ATOMISP_INPUT_FORMAT_RAW_6:\n\t\treturn \"raw6\";\n\tcase ATOMISP_INPUT_FORMAT_RAW_7:\n\t\treturn \"raw7\";\n\tcase ATOMISP_INPUT_FORMAT_RAW_8:\n\t\treturn \"raw8\";\n\tcase ATOMISP_INPUT_FORMAT_RAW_10:\n\t\treturn \"raw10\";\n\tcase ATOMISP_INPUT_FORMAT_RAW_12:\n\t\treturn \"raw12\";\n\tcase ATOMISP_INPUT_FORMAT_RAW_14:\n\t\treturn \"raw14\";\n\tcase ATOMISP_INPUT_FORMAT_RAW_16:\n\t\treturn \"raw16\";\n\tcase ATOMISP_INPUT_FORMAT_BINARY_8:\n\t\treturn \"binary8\";\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT1:\n\t\treturn \"generic-short1\";\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT2:\n\t\treturn \"generic-short2\";\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT3:\n\t\treturn \"generic-short3\";\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT4:\n\t\treturn \"generic-short4\";\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT5:\n\t\treturn \"generic-short5\";\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT6:\n\t\treturn \"generic-short6\";\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT7:\n\t\treturn \"generic-short7\";\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT8:\n\t\treturn \"generic-short8\";\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8_SHIFT:\n\t\treturn \"yuv420-8-shift\";\n\tcase ATOMISP_INPUT_FORMAT_YUV420_10_SHIFT:\n\t\treturn \"yuv420-10-shift\";\n\tcase ATOMISP_INPUT_FORMAT_EMBEDDED:\n\t\treturn \"embedded-8\";\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF1:\n\t\treturn \"user-def-8-type-1\";\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF2:\n\t\treturn \"user-def-8-type-2\";\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF3:\n\t\treturn \"user-def-8-type-3\";\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF4:\n\t\treturn \"user-def-8-type-4\";\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF5:\n\t\treturn \"user-def-8-type-5\";\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF6:\n\t\treturn \"user-def-8-type-6\";\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF7:\n\t\treturn \"user-def-8-type-7\";\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF8:\n\t\treturn \"user-def-8-type-8\";\n\n\tdefault:\n\t\tassert(!\"Unknown stream format\");\n\t\treturn \"unknown-stream-format\";\n\t}\n};\n\nstatic const char *debug_frame_format2str(const enum ia_css_frame_format\n\tframe_format)\n{\n\tswitch (frame_format) {\n\tcase IA_CSS_FRAME_FORMAT_NV11:\n\t\treturn \"NV11\";\n\tcase IA_CSS_FRAME_FORMAT_NV12:\n\t\treturn \"NV12\";\n\tcase IA_CSS_FRAME_FORMAT_NV12_16:\n\t\treturn \"NV12_16\";\n\tcase IA_CSS_FRAME_FORMAT_NV12_TILEY:\n\t\treturn \"NV12_TILEY\";\n\tcase IA_CSS_FRAME_FORMAT_NV16:\n\t\treturn \"NV16\";\n\tcase IA_CSS_FRAME_FORMAT_NV21:\n\t\treturn \"NV21\";\n\tcase IA_CSS_FRAME_FORMAT_NV61:\n\t\treturn \"NV61\";\n\tcase IA_CSS_FRAME_FORMAT_YV12:\n\t\treturn \"YV12\";\n\tcase IA_CSS_FRAME_FORMAT_YV16:\n\t\treturn \"YV16\";\n\tcase IA_CSS_FRAME_FORMAT_YUV420:\n\t\treturn \"YUV420\";\n\tcase IA_CSS_FRAME_FORMAT_YUV420_16:\n\t\treturn \"YUV420_16\";\n\tcase IA_CSS_FRAME_FORMAT_YUV422:\n\t\treturn \"YUV422\";\n\tcase IA_CSS_FRAME_FORMAT_YUV422_16:\n\t\treturn \"YUV422_16\";\n\tcase IA_CSS_FRAME_FORMAT_UYVY:\n\t\treturn \"UYVY\";\n\tcase IA_CSS_FRAME_FORMAT_YUYV:\n\t\treturn \"YUYV\";\n\tcase IA_CSS_FRAME_FORMAT_YUV444:\n\t\treturn \"YUV444\";\n\tcase IA_CSS_FRAME_FORMAT_YUV_LINE:\n\t\treturn \"YUV_LINE\";\n\tcase IA_CSS_FRAME_FORMAT_RAW:\n\t\treturn \"RAW\";\n\tcase IA_CSS_FRAME_FORMAT_RGB565:\n\t\treturn \"RGB565\";\n\tcase IA_CSS_FRAME_FORMAT_PLANAR_RGB888:\n\t\treturn \"PLANAR_RGB888\";\n\tcase IA_CSS_FRAME_FORMAT_RGBA888:\n\t\treturn \"RGBA888\";\n\tcase IA_CSS_FRAME_FORMAT_QPLANE6:\n\t\treturn \"QPLANE6\";\n\tcase IA_CSS_FRAME_FORMAT_BINARY_8:\n\t\treturn \"BINARY_8\";\n\tcase IA_CSS_FRAME_FORMAT_MIPI:\n\t\treturn \"MIPI\";\n\tcase IA_CSS_FRAME_FORMAT_RAW_PACKED:\n\t\treturn \"RAW_PACKED\";\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:\n\t\treturn \"CSI_MIPI_YUV420_8\";\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8:\n\t\treturn \"CSI_MIPI_LEGACY_YUV420_8\";\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_10:\n\t\treturn \"CSI_MIPI_YUV420_10\";\n\n\tdefault:\n\t\tassert(!\"Unknown frame format\");\n\t\treturn \"unknown-frame-format\";\n\t}\n}\n\nstatic void debug_print_sp_state(const sp_state_t *state, const char *cell)\n{\n\tassert(cell);\n\tassert(state);\n\n\tia_css_debug_dtrace(2, \"%s state:\\n\", cell);\n\tia_css_debug_dtrace(2, \"\\t%-32s: 0x%X\\n\", \"PC\", state->pc);\n\tia_css_debug_dtrace(2, \"\\t%-32s: 0x%X\\n\", \"Status register\",\n\t\t\t    state->status_register);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"Is broken\", state->is_broken);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"Is idle\", state->is_idle);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"Is sleeping\",\n\t\t\t    state->is_sleeping);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"Is stalling\",\n\t\t\t    state->is_stalling);\n\treturn;\n}\n\nstatic void debug_print_isp_state(const isp_state_t *state, const char *cell)\n{\n\tassert(state);\n\tassert(cell);\n\n\tia_css_debug_dtrace(2, \"%s state:\\n\", cell);\n\tia_css_debug_dtrace(2, \"\\t%-32s: 0x%X\\n\", \"PC\", state->pc);\n\tia_css_debug_dtrace(2, \"\\t%-32s: 0x%X\\n\", \"Status register\",\n\t\t\t    state->status_register);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"Is broken\", state->is_broken);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"Is idle\", state->is_idle);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"Is sleeping\",\n\t\t\t    state->is_sleeping);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"Is stalling\",\n\t\t\t    state->is_stalling);\n\treturn;\n}\n\nvoid ia_css_debug_dump_isp_state(void)\n{\n\tisp_state_t state;\n\tisp_stall_t stall;\n\n\tisp_get_state(ISP0_ID, &state, &stall);\n\n\tdebug_print_isp_state(&state, \"ISP\");\n\n\tif (state.is_stalling) {\n\t\tif (!IS_ISP2401) {\n\t\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\",\n\t\t\t\t\t    \"[0] if_prim_a_FIFO stalled\", stall.fifo0);\n\t\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\",\n\t\t\t\t\t    \"[1] if_prim_b_FIFO stalled\", stall.fifo1);\n\t\t}\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"[2] dma_FIFO stalled\",\n\t\t\t\t    stall.fifo2);\n\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"[3] gdc0_FIFO stalled\",\n\t\t\t\t    stall.fifo3);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"[4] gdc1_FIFO stalled\",\n\t\t\t\t    stall.fifo4);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"[5] gpio_FIFO stalled\",\n\t\t\t\t    stall.fifo5);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"[6] sp_FIFO stalled\",\n\t\t\t\t    stall.fifo6);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\",\n\t\t\t\t    \"status & control stalled\",\n\t\t\t\t    stall.stat_ctrl);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"dmem stalled\",\n\t\t\t\t    stall.dmem);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"vmem stalled\",\n\t\t\t\t    stall.vmem);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"vamem1 stalled\",\n\t\t\t\t    stall.vamem1);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"vamem2 stalled\",\n\t\t\t\t    stall.vamem2);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"vamem3 stalled\",\n\t\t\t\t    stall.vamem3);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"hmem stalled\",\n\t\t\t\t    stall.hmem);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"pmem stalled\",\n\t\t\t\t    stall.pmem);\n\t}\n\treturn;\n}\n\nvoid ia_css_debug_dump_sp_state(void)\n{\n\tsp_state_t state;\n\tsp_stall_t stall;\n\n\tsp_get_state(SP0_ID, &state, &stall);\n\tdebug_print_sp_state(&state, \"SP\");\n\tif (state.is_stalling) {\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"isys_FIFO stalled\",\n\t\t\t\t    stall.fifo0);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"if_sec_FIFO stalled\",\n\t\t\t\t    stall.fifo1);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\",\n\t\t\t\t    \"str_to_mem_FIFO stalled\", stall.fifo2);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"dma_FIFO stalled\",\n\t\t\t\t    stall.fifo3);\n\t\tif (!IS_ISP2401)\n\t\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\",\n\t\t\t\t\t    \"if_prim_a_FIFO stalled\", stall.fifo4);\n\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"isp_FIFO stalled\",\n\t\t\t\t    stall.fifo5);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"gp_FIFO stalled\",\n\t\t\t\t    stall.fifo6);\n\t\tif (!IS_ISP2401)\n\t\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\",\n\t\t\t\t\t    \"if_prim_b_FIFO stalled\", stall.fifo7);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"gdc0_FIFO stalled\",\n\t\t\t\t    stall.fifo8);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"gdc1_FIFO stalled\",\n\t\t\t\t    stall.fifo9);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"irq FIFO stalled\",\n\t\t\t\t    stall.fifoa);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"dmem stalled\",\n\t\t\t\t    stall.dmem);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\",\n\t\t\t\t    \"control master stalled\",\n\t\t\t\t    stall.control_master);\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\",\n\t\t\t\t    \"i-cache master stalled\",\n\t\t\t\t    stall.icache_master);\n\t}\n\tia_css_debug_dump_trace();\n\treturn;\n}\n\nstatic void debug_print_fifo_channel_state(const fifo_channel_state_t *state,\n\tconst char *descr)\n{\n\tassert(state);\n\tassert(descr);\n\n\tia_css_debug_dtrace(2, \"FIFO channel: %s\\n\", descr);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"source valid\",\n\t\t\t    state->src_valid);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"fifo accept\",\n\t\t\t    state->fifo_accept);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"fifo valid\",\n\t\t\t    state->fifo_valid);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"sink accept\",\n\t\t\t    state->sink_accept);\n\treturn;\n}\n\nvoid ia_css_debug_dump_pif_a_isp_fifo_state(void)\n{\n\tfifo_channel_state_t pif_to_isp, isp_to_pif;\n\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_IF0_TO_ISP0, &pif_to_isp);\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_ISP0_TO_IF0, &isp_to_pif);\n\tdebug_print_fifo_channel_state(&pif_to_isp, \"Primary IF A to ISP\");\n\tdebug_print_fifo_channel_state(&isp_to_pif, \"ISP to Primary IF A\");\n}\n\nvoid ia_css_debug_dump_pif_b_isp_fifo_state(void)\n{\n\tfifo_channel_state_t pif_to_isp, isp_to_pif;\n\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_IF1_TO_ISP0, &pif_to_isp);\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_ISP0_TO_IF1, &isp_to_pif);\n\tdebug_print_fifo_channel_state(&pif_to_isp, \"Primary IF B to ISP\");\n\tdebug_print_fifo_channel_state(&isp_to_pif, \"ISP to Primary IF B\");\n}\n\nvoid ia_css_debug_dump_str2mem_sp_fifo_state(void)\n{\n\tfifo_channel_state_t s2m_to_sp, sp_to_s2m;\n\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_STREAM2MEM0_TO_SP0, &s2m_to_sp);\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_SP0_TO_STREAM2MEM0, &sp_to_s2m);\n\tdebug_print_fifo_channel_state(&s2m_to_sp, \"Stream-to-memory to SP\");\n\tdebug_print_fifo_channel_state(&sp_to_s2m, \"SP to stream-to-memory\");\n}\n\n#ifndef ISP2401\nstatic void debug_print_if_state(input_formatter_state_t *state, const char *id)\n{\n\tunsigned int val;\n\n\tconst char *st_vsync_active_low =\n\t    (state->vsync_active_low ? \"low\" : \"high\");\n\tconst char *st_hsync_active_low =\n\t    (state->hsync_active_low ? \"low\" : \"high\");\n\n\tconst char *fsm_sync_status_str = \"unknown\";\n\tconst char *fsm_crop_status_str = \"unknown\";\n\tconst char *fsm_padding_status_str = \"unknown\";\n\n\tint st_stline = state->start_line;\n\tint st_stcol = state->start_column;\n\tint st_crpht = state->cropped_height;\n\tint st_crpwd = state->cropped_width;\n\tint st_verdcm = state->ver_decimation;\n\tint st_hordcm = state->hor_decimation;\n\tint st_ver_deinterleaving = state->ver_deinterleaving;\n\tint st_hor_deinterleaving = state->hor_deinterleaving;\n\tint st_leftpd = state->left_padding;\n\tint st_eoloff = state->eol_offset;\n\tint st_vmstartaddr = state->vmem_start_address;\n\tint st_vmendaddr = state->vmem_end_address;\n\tint st_vmincr = state->vmem_increment;\n\tint st_yuv420 = state->is_yuv420;\n\tint st_allow_fifo_overflow = state->allow_fifo_overflow;\n\tint st_block_fifo_when_no_req = state->block_fifo_when_no_req;\n\n\tassert(state);\n\tia_css_debug_dtrace(2, \"InputFormatter State (%s):\\n\", id);\n\n\tia_css_debug_dtrace(2, \"\\tConfiguration:\\n\");\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Start line\", st_stline);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Start column\", st_stcol);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Cropped height\", st_crpht);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Cropped width\", st_crpwd);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Ver decimation\", st_verdcm);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Hor decimation\", st_hordcm);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Ver deinterleaving\", st_ver_deinterleaving);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Hor deinterleaving\", st_hor_deinterleaving);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Left padding\", st_leftpd);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"EOL offset (bytes)\", st_eoloff);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: 0x%06X\\n\",\n\t\t\t    \"VMEM start address\", st_vmstartaddr);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: 0x%06X\\n\",\n\t\t\t    \"VMEM end address\", st_vmendaddr);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: 0x%06X\\n\",\n\t\t\t    \"VMEM increment\", st_vmincr);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"YUV 420 format\", st_yuv420);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: Active %s\\n\",\n\t\t\t    \"Vsync\", st_vsync_active_low);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: Active %s\\n\",\n\t\t\t    \"Hsync\", st_hsync_active_low);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Allow FIFO overflow\", st_allow_fifo_overflow);\n\t \n\t \n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Block when no request\", st_block_fifo_when_no_req);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"IF_BLOCKED_FIFO_NO_REQ_ADDRESS\",\n\t\t\t    input_formatter_reg_load(INPUT_FORMATTER0_ID,\n\t\t\t\t    HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS)\n\t\t\t   );\n\n\tia_css_debug_dtrace(2, \"\\t%-32s:\\n\", \"InputSwitch State\");\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"_REG_GP_IFMT_input_switch_lut_reg0\",\n\t\t\t    gp_device_reg_load(GP_DEVICE0_ID,\n\t\t\t\t\t       _REG_GP_IFMT_input_switch_lut_reg0));\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"_REG_GP_IFMT_input_switch_lut_reg1\",\n\t\t\t    gp_device_reg_load(GP_DEVICE0_ID,\n\t\t\t\t\t       _REG_GP_IFMT_input_switch_lut_reg1));\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"_REG_GP_IFMT_input_switch_lut_reg2\",\n\t\t\t    gp_device_reg_load(GP_DEVICE0_ID,\n\t\t\t\t\t       _REG_GP_IFMT_input_switch_lut_reg2));\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"_REG_GP_IFMT_input_switch_lut_reg3\",\n\t\t\t    gp_device_reg_load(GP_DEVICE0_ID,\n\t\t\t\t\t       _REG_GP_IFMT_input_switch_lut_reg3));\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"_REG_GP_IFMT_input_switch_lut_reg4\",\n\t\t\t    gp_device_reg_load(GP_DEVICE0_ID,\n\t\t\t\t\t       _REG_GP_IFMT_input_switch_lut_reg4));\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"_REG_GP_IFMT_input_switch_lut_reg5\",\n\t\t\t    gp_device_reg_load(GP_DEVICE0_ID,\n\t\t\t\t\t       _REG_GP_IFMT_input_switch_lut_reg5));\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"_REG_GP_IFMT_input_switch_lut_reg6\",\n\t\t\t    gp_device_reg_load(GP_DEVICE0_ID,\n\t\t\t\t\t       _REG_GP_IFMT_input_switch_lut_reg6));\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"_REG_GP_IFMT_input_switch_lut_reg7\",\n\t\t\t    gp_device_reg_load(GP_DEVICE0_ID,\n\t\t\t\t\t       _REG_GP_IFMT_input_switch_lut_reg7));\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"_REG_GP_IFMT_input_switch_fsync_lut\",\n\t\t\t    gp_device_reg_load(GP_DEVICE0_ID,\n\t\t\t\t\t       _REG_GP_IFMT_input_switch_fsync_lut));\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"_REG_GP_IFMT_srst\",\n\t\t\t    gp_device_reg_load(GP_DEVICE0_ID,\n\t\t\t\t\t       _REG_GP_IFMT_srst));\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"_REG_GP_IFMT_slv_reg_srst\",\n\t\t\t    gp_device_reg_load(GP_DEVICE0_ID,\n\t\t\t\t\t       _REG_GP_IFMT_slv_reg_srst));\n\n\tia_css_debug_dtrace(2, \"\\tFSM Status:\\n\");\n\n\tval = state->fsm_sync_status;\n\n\tif (val > 7)\n\t\tfsm_sync_status_str = \"ERROR\";\n\n\tswitch (val & 0x7) {\n\tcase 0:\n\t\tfsm_sync_status_str = \"idle\";\n\t\tbreak;\n\tcase 1:\n\t\tfsm_sync_status_str = \"request frame\";\n\t\tbreak;\n\tcase 2:\n\t\tfsm_sync_status_str = \"request lines\";\n\t\tbreak;\n\tcase 3:\n\t\tfsm_sync_status_str = \"request vectors\";\n\t\tbreak;\n\tcase 4:\n\t\tfsm_sync_status_str = \"send acknowledge\";\n\t\tbreak;\n\tdefault:\n\t\tfsm_sync_status_str = \"unknown\";\n\t\tbreak;\n\t}\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: (0x%X: %s)\\n\",\n\t\t\t    \"FSM Synchronization Status\", val,\n\t\t\t    fsm_sync_status_str);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"FSM Synchronization Counter\",\n\t\t\t    state->fsm_sync_counter);\n\n\tval = state->fsm_crop_status;\n\n\tif (val > 7)\n\t\tfsm_crop_status_str = \"ERROR\";\n\n\tswitch (val & 0x7) {\n\tcase 0:\n\t\tfsm_crop_status_str = \"idle\";\n\t\tbreak;\n\tcase 1:\n\t\tfsm_crop_status_str = \"wait line\";\n\t\tbreak;\n\tcase 2:\n\t\tfsm_crop_status_str = \"crop line\";\n\t\tbreak;\n\tcase 3:\n\t\tfsm_crop_status_str = \"crop pixel\";\n\t\tbreak;\n\tcase 4:\n\t\tfsm_crop_status_str = \"pass pixel\";\n\t\tbreak;\n\tcase 5:\n\t\tfsm_crop_status_str = \"pass line\";\n\t\tbreak;\n\tcase 6:\n\t\tfsm_crop_status_str = \"lost line\";\n\t\tbreak;\n\tdefault:\n\t\tfsm_crop_status_str = \"unknown\";\n\t\tbreak;\n\t}\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: (0x%X: %s)\\n\",\n\t\t\t    \"FSM Crop Status\", val, fsm_crop_status_str);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"FSM Crop Line Counter\",\n\t\t\t    state->fsm_crop_line_counter);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"FSM Crop Pixel Counter\",\n\t\t\t    state->fsm_crop_pixel_counter);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"FSM Deinterleaving idx buffer\",\n\t\t\t    state->fsm_deinterleaving_index);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"FSM H decimation counter\",\n\t\t\t    state->fsm_dec_h_counter);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"FSM V decimation counter\",\n\t\t\t    state->fsm_dec_v_counter);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"FSM block V decimation counter\",\n\t\t\t    state->fsm_dec_block_v_counter);\n\n\tval = state->fsm_padding_status;\n\n\tif (val > 7)\n\t\tfsm_padding_status_str = \"ERROR\";\n\n\tswitch (val & 0x7) {\n\tcase 0:\n\t\tfsm_padding_status_str = \"idle\";\n\t\tbreak;\n\tcase 1:\n\t\tfsm_padding_status_str = \"left pad\";\n\t\tbreak;\n\tcase 2:\n\t\tfsm_padding_status_str = \"write\";\n\t\tbreak;\n\tcase 3:\n\t\tfsm_padding_status_str = \"right pad\";\n\t\tbreak;\n\tcase 4:\n\t\tfsm_padding_status_str = \"send end of line\";\n\t\tbreak;\n\tdefault:\n\t\tfsm_padding_status_str = \"unknown\";\n\t\tbreak;\n\t}\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: (0x%X: %s)\\n\", \"FSM Padding Status\",\n\t\t\t    val, fsm_padding_status_str);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"FSM Padding element idx counter\",\n\t\t\t    state->fsm_padding_elem_counter);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Vector support error\",\n\t\t\t    state->fsm_vector_support_error);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Vector support buf full\",\n\t\t\t    state->fsm_vector_buffer_full);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Vector support\",\n\t\t\t    state->vector_support);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Fifo sensor data lost\",\n\t\t\t    state->sensor_data_lost);\n}\n\nstatic void debug_print_if_bin_state(input_formatter_bin_state_t *state)\n{\n\tia_css_debug_dtrace(2, \"Stream-to-memory state:\\n\");\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"reset\", state->reset);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"input endianness\",\n\t\t\t    state->input_endianness);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"output endianness\",\n\t\t\t    state->output_endianness);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"bitswap\", state->bitswap);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"block_synch\",\n\t\t\t    state->block_synch);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"packet_synch\",\n\t\t\t    state->packet_synch);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"readpostwrite_sync\",\n\t\t\t    state->readpostwrite_synch);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"is_2ppc\", state->is_2ppc);\n\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"en_status_update\",\n\t\t\t    state->en_status_update);\n}\n\nstatic void ia_css_debug_dump_if_state(void)\n{\n\tinput_formatter_state_t if_state;\n\tinput_formatter_bin_state_t if_bin_state;\n\n\tinput_formatter_get_state(INPUT_FORMATTER0_ID, &if_state);\n\tdebug_print_if_state(&if_state, \"Primary IF A\");\n\tia_css_debug_dump_pif_a_isp_fifo_state();\n\n\tinput_formatter_get_state(INPUT_FORMATTER1_ID, &if_state);\n\tdebug_print_if_state(&if_state, \"Primary IF B\");\n\tia_css_debug_dump_pif_b_isp_fifo_state();\n\n\tinput_formatter_bin_get_state(INPUT_FORMATTER3_ID, &if_bin_state);\n\tdebug_print_if_bin_state(&if_bin_state);\n\tia_css_debug_dump_str2mem_sp_fifo_state();\n}\n#endif\n\nvoid ia_css_debug_dump_dma_state(void)\n{\n\t \n\tstatic dma_state_t state;\n\tint i, ch_id;\n\n\tconst char *fsm_cmd_st_lbl = \"FSM Command flag state\";\n\tconst char *fsm_ctl_st_lbl = \"FSM Control flag state\";\n\tconst char *fsm_ctl_state = NULL;\n\tconst char *fsm_ctl_flag = NULL;\n\tconst char *fsm_pack_st = NULL;\n\tconst char *fsm_read_st = NULL;\n\tconst char *fsm_write_st = NULL;\n\tchar last_cmd_str[64];\n\n\tdma_get_state(DMA0_ID, &state);\n\t \n\tia_css_debug_dtrace(2, \"DMA dump status:\\n\");\n\n\t \n\tif (state.fsm_command_idle)\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %s\\n\", fsm_cmd_st_lbl, \"IDLE\");\n\tif (state.fsm_command_run)\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %s\\n\", fsm_cmd_st_lbl, \"RUN\");\n\tif (state.fsm_command_stalling)\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %s\\n\", fsm_cmd_st_lbl,\n\t\t\t\t    \"STALL\");\n\tif (state.fsm_command_error)\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %s\\n\", fsm_cmd_st_lbl,\n\t\t\t\t    \"ERROR\");\n\n\t \n\tch_id = state.last_command_channel;\n\n\tswitch (state.last_command) {\n\tcase DMA_COMMAND_READ:\n\t\tsnprintf(last_cmd_str, 64,\n\t\t\t \"Read 2D Block [Channel: %d]\", ch_id);\n\t\tbreak;\n\tcase DMA_COMMAND_WRITE:\n\t\tsnprintf(last_cmd_str, 64,\n\t\t\t \"Write 2D Block [Channel: %d]\", ch_id);\n\t\tbreak;\n\tcase DMA_COMMAND_SET_CHANNEL:\n\t\tsnprintf(last_cmd_str, 64, \"Set Channel [Channel: %d]\", ch_id);\n\t\tbreak;\n\tcase DMA_COMMAND_SET_PARAM:\n\t\tsnprintf(last_cmd_str, 64,\n\t\t\t \"Set Param: %d [Channel: %d]\",\n\t\t\t state.last_command_param, ch_id);\n\t\tbreak;\n\tcase DMA_COMMAND_READ_SPECIFIC:\n\t\tsnprintf(last_cmd_str, 64,\n\t\t\t \"Read Specific 2D Block [Channel: %d]\", ch_id);\n\t\tbreak;\n\tcase DMA_COMMAND_WRITE_SPECIFIC:\n\t\tsnprintf(last_cmd_str, 64,\n\t\t\t \"Write Specific 2D Block [Channel: %d]\", ch_id);\n\t\tbreak;\n\tcase DMA_COMMAND_INIT:\n\t\tsnprintf(last_cmd_str, 64,\n\t\t\t \"Init 2D Block on Device A [Channel: %d]\", ch_id);\n\t\tbreak;\n\tcase DMA_COMMAND_INIT_SPECIFIC:\n\t\tsnprintf(last_cmd_str, 64,\n\t\t\t \"Init Specific 2D Block [Channel: %d]\", ch_id);\n\t\tbreak;\n\tcase DMA_COMMAND_RST:\n\t\tsnprintf(last_cmd_str, 64, \"DMA SW Reset\");\n\t\tbreak;\n\tcase N_DMA_COMMANDS:\n\t\tsnprintf(last_cmd_str, 64, \"UNKNOWN\");\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(last_cmd_str, 64,\n\t\t\t \"unknown [Channel: %d]\", ch_id);\n\t\tbreak;\n\t}\n\tia_css_debug_dtrace(2, \"\\t%-32s: (0x%X : %s)\\n\",\n\t\t\t    \"last command received\", state.last_command,\n\t\t\t    last_cmd_str);\n\n\t \n\tia_css_debug_dtrace(2, \"\\t%-32s\\n\",\n\t\t\t    \"DMA registers, connection group 0\");\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: 0x%X\\n\", \"Cmd Fifo Command\",\n\t\t\t    state.current_command);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: 0x%X\\n\", \"Cmd Fifo Address A\",\n\t\t\t    state.current_addr_a);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: 0x%X\\n\", \"Cmd Fifo Address B\",\n\t\t\t    state.current_addr_b);\n\n\tif (state.fsm_ctrl_idle)\n\t\tfsm_ctl_flag = \"IDLE\";\n\telse if (state.fsm_ctrl_run)\n\t\tfsm_ctl_flag = \"RUN\";\n\telse if (state.fsm_ctrl_stalling)\n\t\tfsm_ctl_flag = \"STAL\";\n\telse if (state.fsm_ctrl_error)\n\t\tfsm_ctl_flag = \"ERROR\";\n\telse\n\t\tfsm_ctl_flag = \"UNKNOWN\";\n\n\tswitch (state.fsm_ctrl_state) {\n\tcase DMA_CTRL_STATE_IDLE:\n\t\tfsm_ctl_state = \"Idle state\";\n\t\tbreak;\n\tcase DMA_CTRL_STATE_REQ_RCV:\n\t\tfsm_ctl_state = \"Req Rcv state\";\n\t\tbreak;\n\tcase DMA_CTRL_STATE_RCV:\n\t\tfsm_ctl_state = \"Rcv state\";\n\t\tbreak;\n\tcase DMA_CTRL_STATE_RCV_REQ:\n\t\tfsm_ctl_state = \"Rcv Req state\";\n\t\tbreak;\n\tcase DMA_CTRL_STATE_INIT:\n\t\tfsm_ctl_state = \"Init state\";\n\t\tbreak;\n\tcase N_DMA_CTRL_STATES:\n\t\tfsm_ctl_state = \"Unknown\";\n\t\tbreak;\n\t}\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %s -> %s\\n\", fsm_ctl_st_lbl,\n\t\t\t    fsm_ctl_flag, fsm_ctl_state);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Ctrl source dev\",\n\t\t\t    state.fsm_ctrl_source_dev);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: 0x%X\\n\", \"FSM Ctrl source addr\",\n\t\t\t    state.fsm_ctrl_source_addr);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: 0x%X\\n\", \"FSM Ctrl source stride\",\n\t\t\t    state.fsm_ctrl_source_stride);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Ctrl source width\",\n\t\t\t    state.fsm_ctrl_source_width);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Ctrl source height\",\n\t\t\t    state.fsm_ctrl_source_height);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Ctrl pack source dev\",\n\t\t\t    state.fsm_ctrl_pack_source_dev);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Ctrl pack dest dev\",\n\t\t\t    state.fsm_ctrl_pack_dest_dev);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: 0x%X\\n\", \"FSM Ctrl dest addr\",\n\t\t\t    state.fsm_ctrl_dest_addr);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: 0x%X\\n\", \"FSM Ctrl dest stride\",\n\t\t\t    state.fsm_ctrl_dest_stride);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Ctrl pack source width\",\n\t\t\t    state.fsm_ctrl_pack_source_width);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Ctrl pack dest height\",\n\t\t\t    state.fsm_ctrl_pack_dest_height);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Ctrl pack dest width\",\n\t\t\t    state.fsm_ctrl_pack_dest_width);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Ctrl pack source elems\",\n\t\t\t    state.fsm_ctrl_pack_source_elems);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Ctrl pack dest elems\",\n\t\t\t    state.fsm_ctrl_pack_dest_elems);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Ctrl pack extension\",\n\t\t\t    state.fsm_ctrl_pack_extension);\n\n\tif (state.pack_idle)\n\t\tfsm_pack_st = \"IDLE\";\n\tif (state.pack_run)\n\t\tfsm_pack_st = \"RUN\";\n\tif (state.pack_stalling)\n\t\tfsm_pack_st = \"STALL\";\n\tif (state.pack_error)\n\t\tfsm_pack_st = \"ERROR\";\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %s\\n\", \"FSM Pack flag state\",\n\t\t\t    fsm_pack_st);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Pack cnt height\",\n\t\t\t    state.pack_cnt_height);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Pack src cnt width\",\n\t\t\t    state.pack_src_cnt_width);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Pack dest cnt width\",\n\t\t\t    state.pack_dest_cnt_width);\n\n\tif (state.read_state == DMA_RW_STATE_IDLE)\n\t\tfsm_read_st = \"Idle state\";\n\tif (state.read_state == DMA_RW_STATE_REQ)\n\t\tfsm_read_st = \"Req state\";\n\tif (state.read_state == DMA_RW_STATE_NEXT_LINE)\n\t\tfsm_read_st = \"Next line\";\n\tif (state.read_state == DMA_RW_STATE_UNLOCK_CHANNEL)\n\t\tfsm_read_st = \"Unlock channel\";\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %s\\n\", \"FSM Read state\",\n\t\t\t    fsm_read_st);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Read cnt height\",\n\t\t\t    state.read_cnt_height);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Read cnt width\",\n\t\t\t    state.read_cnt_width);\n\n\tif (state.write_state == DMA_RW_STATE_IDLE)\n\t\tfsm_write_st = \"Idle state\";\n\tif (state.write_state == DMA_RW_STATE_REQ)\n\t\tfsm_write_st = \"Req state\";\n\tif (state.write_state == DMA_RW_STATE_NEXT_LINE)\n\t\tfsm_write_st = \"Next line\";\n\tif (state.write_state == DMA_RW_STATE_UNLOCK_CHANNEL)\n\t\tfsm_write_st = \"Unlock channel\";\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %s\\n\", \"FSM Write state\",\n\t\t\t    fsm_write_st);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Write height\",\n\t\t\t    state.write_height);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"FSM Write width\",\n\t\t\t    state.write_width);\n\n\tfor (i = 0; i < HIVE_ISP_NUM_DMA_CONNS; i++) {\n\t\tdma_port_state_t *port = &state.port_states[i];\n\n\t\tia_css_debug_dtrace(2, \"\\tDMA device interface %d\\n\", i);\n\t\tia_css_debug_dtrace(2, \"\\t\\tDMA internal side state\\n\");\n\t\tia_css_debug_dtrace(2,\n\t\t\t\t    \"\\t\\t\\tCS:%d - We_n:%d - Run:%d - Ack:%d\\n\",\n\t\t\t\t    port->req_cs, port->req_we_n, port->req_run,\n\t\t\t\t    port->req_ack);\n\t\tia_css_debug_dtrace(2, \"\\t\\tMaster Output side state\\n\");\n\t\tia_css_debug_dtrace(2,\n\t\t\t\t    \"\\t\\t\\tCS:%d - We_n:%d - Run:%d - Ack:%d\\n\",\n\t\t\t\t    port->send_cs, port->send_we_n,\n\t\t\t\t    port->send_run, port->send_ack);\n\t\tia_css_debug_dtrace(2, \"\\t\\tFifo state\\n\");\n\t\tif (port->fifo_state == DMA_FIFO_STATE_WILL_BE_FULL)\n\t\t\tia_css_debug_dtrace(2, \"\\t\\t\\tFiFo will be full\\n\");\n\t\telse if (port->fifo_state == DMA_FIFO_STATE_FULL)\n\t\t\tia_css_debug_dtrace(2, \"\\t\\t\\tFifo Full\\n\");\n\t\telse if (port->fifo_state == DMA_FIFO_STATE_EMPTY)\n\t\t\tia_css_debug_dtrace(2, \"\\t\\t\\tFifo Empty\\n\");\n\t\telse\n\t\t\tia_css_debug_dtrace(2, \"\\t\\t\\tFifo state unknown\\n\");\n\n\t\tia_css_debug_dtrace(2, \"\\t\\tFifo counter %d\\n\\n\",\n\t\t\t\t    port->fifo_counter);\n\t}\n\n\tfor (i = 0; i < HIVE_DMA_NUM_CHANNELS; i++) {\n\t\tdma_channel_state_t *ch = &state.channel_states[i];\n\n\t\tia_css_debug_dtrace(2, \"\\t%-32s: %d\\n\", \"DMA channel register\",\n\t\t\t\t    i);\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Connection\",\n\t\t\t\t    ch->connection);\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Sign extend\",\n\t\t\t\t    ch->sign_extend);\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: 0x%X\\n\", \"Stride Dev A\",\n\t\t\t\t    ch->stride_a);\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Elems Dev A\",\n\t\t\t\t    ch->elems_a);\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Cropping Dev A\",\n\t\t\t\t    ch->cropping_a);\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Width Dev A\",\n\t\t\t\t    ch->width_a);\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: 0x%X\\n\", \"Stride Dev B\",\n\t\t\t\t    ch->stride_b);\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Elems Dev B\",\n\t\t\t\t    ch->elems_b);\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Cropping Dev B\",\n\t\t\t\t    ch->cropping_b);\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Width Dev B\",\n\t\t\t\t    ch->width_b);\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"Height\", ch->height);\n\t}\n\tia_css_debug_dtrace(2, \"\\n\");\n\treturn;\n}\n\nvoid ia_css_debug_dump_dma_sp_fifo_state(void)\n{\n\tfifo_channel_state_t dma_to_sp, sp_to_dma;\n\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_DMA0_TO_SP0, &dma_to_sp);\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_SP0_TO_DMA0, &sp_to_dma);\n\tdebug_print_fifo_channel_state(&dma_to_sp, \"DMA to SP\");\n\tdebug_print_fifo_channel_state(&sp_to_dma, \"SP to DMA\");\n\treturn;\n}\n\nvoid ia_css_debug_dump_dma_isp_fifo_state(void)\n{\n\tfifo_channel_state_t dma_to_isp, isp_to_dma;\n\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_DMA0_TO_ISP0, &dma_to_isp);\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_ISP0_TO_DMA0, &isp_to_dma);\n\tdebug_print_fifo_channel_state(&dma_to_isp, \"DMA to ISP\");\n\tdebug_print_fifo_channel_state(&isp_to_dma, \"ISP to DMA\");\n\treturn;\n}\n\nvoid ia_css_debug_dump_isp_sp_fifo_state(void)\n{\n\tfifo_channel_state_t sp_to_isp, isp_to_sp;\n\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_SP0_TO_ISP0, &sp_to_isp);\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_ISP0_TO_SP0, &isp_to_sp);\n\tdebug_print_fifo_channel_state(&sp_to_isp, \"SP to ISP\");\n\tdebug_print_fifo_channel_state(&isp_to_sp, \"ISP to SP\");\n\treturn;\n}\n\nvoid ia_css_debug_dump_isp_gdc_fifo_state(void)\n{\n\tfifo_channel_state_t gdc_to_isp, isp_to_gdc;\n\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_GDC0_TO_ISP0, &gdc_to_isp);\n\tfifo_channel_get_state(FIFO_MONITOR0_ID,\n\t\t\t       FIFO_CHANNEL_ISP0_TO_GDC0, &isp_to_gdc);\n\tdebug_print_fifo_channel_state(&gdc_to_isp, \"GDC to ISP\");\n\tdebug_print_fifo_channel_state(&isp_to_gdc, \"ISP to GDC\");\n\treturn;\n}\n\nvoid ia_css_debug_dump_all_fifo_state(void)\n{\n\tint i;\n\tfifo_monitor_state_t state;\n\n\tfifo_monitor_get_state(FIFO_MONITOR0_ID, &state);\n\n\tfor (i = 0; i < N_FIFO_CHANNEL; i++)\n\t\tdebug_print_fifo_channel_state(&state.fifo_channels[i],\n\t\t\t\t\t       \"squepfstqkt\");\n\treturn;\n}\n\nstatic void debug_binary_info_print(const struct ia_css_binary_xinfo *info)\n{\n\tassert(info);\n\tia_css_debug_dtrace(2, \"id = %d\\n\", info->sp.id);\n\tia_css_debug_dtrace(2, \"mode = %d\\n\", info->sp.pipeline.mode);\n\tia_css_debug_dtrace(2, \"max_input_width = %d\\n\", info->sp.input.max_width);\n\tia_css_debug_dtrace(2, \"min_output_width = %d\\n\",\n\t\t\t    info->sp.output.min_width);\n\tia_css_debug_dtrace(2, \"max_output_width = %d\\n\",\n\t\t\t    info->sp.output.max_width);\n\tia_css_debug_dtrace(2, \"top_cropping = %d\\n\", info->sp.pipeline.top_cropping);\n\tia_css_debug_dtrace(2, \"left_cropping = %d\\n\", info->sp.pipeline.left_cropping);\n\tia_css_debug_dtrace(2, \"xmem_addr = %d\\n\", info->xmem_addr);\n\tia_css_debug_dtrace(2, \"enable_vf_veceven = %d\\n\",\n\t\t\t    info->sp.enable.vf_veceven);\n\tia_css_debug_dtrace(2, \"enable_dis = %d\\n\", info->sp.enable.dis);\n\tia_css_debug_dtrace(2, \"enable_uds = %d\\n\", info->sp.enable.uds);\n\tia_css_debug_dtrace(2, \"enable ds = %d\\n\", info->sp.enable.ds);\n\tia_css_debug_dtrace(2, \"s3atbl_use_dmem = %d\\n\", info->sp.s3a.s3atbl_use_dmem);\n\treturn;\n}\n\nvoid ia_css_debug_binary_print(const struct ia_css_binary *bi)\n{\n\tunsigned int i;\n\n\tdebug_binary_info_print(bi->info);\n\tia_css_debug_dtrace(2,\n\t\t\t    \"input:  %dx%d, format = %d, padded width = %d\\n\",\n\t\t\t    bi->in_frame_info.res.width,\n\t\t\t    bi->in_frame_info.res.height,\n\t\t\t    bi->in_frame_info.format,\n\t\t\t    bi->in_frame_info.padded_width);\n\tia_css_debug_dtrace(2,\n\t\t\t    \"internal :%dx%d, format = %d, padded width = %d\\n\",\n\t\t\t    bi->internal_frame_info.res.width,\n\t\t\t    bi->internal_frame_info.res.height,\n\t\t\t    bi->internal_frame_info.format,\n\t\t\t    bi->internal_frame_info.padded_width);\n\tfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {\n\t\tif (bi->out_frame_info[i].res.width != 0) {\n\t\t\tia_css_debug_dtrace(2,\n\t\t\t\t\t    \"out%d:    %dx%d, format = %d, padded width = %d\\n\",\n\t\t\t\t\t    i,\n\t\t\t\t\t    bi->out_frame_info[i].res.width,\n\t\t\t\t\t    bi->out_frame_info[i].res.height,\n\t\t\t\t\t    bi->out_frame_info[i].format,\n\t\t\t\t\t    bi->out_frame_info[i].padded_width);\n\t\t}\n\t}\n\tia_css_debug_dtrace(2,\n\t\t\t    \"vf out: %dx%d, format = %d, padded width = %d\\n\",\n\t\t\t    bi->vf_frame_info.res.width,\n\t\t\t    bi->vf_frame_info.res.height,\n\t\t\t    bi->vf_frame_info.format,\n\t\t\t    bi->vf_frame_info.padded_width);\n\tia_css_debug_dtrace(2, \"online = %d\\n\", bi->online);\n\tia_css_debug_dtrace(2, \"input_buf_vectors = %d\\n\",\n\t\t\t    bi->input_buf_vectors);\n\tia_css_debug_dtrace(2, \"deci_factor_log2 = %d\\n\", bi->deci_factor_log2);\n\tia_css_debug_dtrace(2, \"vf_downscale_log2 = %d\\n\",\n\t\t\t    bi->vf_downscale_log2);\n\tia_css_debug_dtrace(2, \"dis_deci_factor_log2 = %d\\n\",\n\t\t\t    bi->dis.deci_factor_log2);\n\tia_css_debug_dtrace(2, \"dis hor coef num = %d\\n\",\n\t\t\t    bi->dis.coef.pad.width);\n\tia_css_debug_dtrace(2, \"dis ver coef num = %d\\n\",\n\t\t\t    bi->dis.coef.pad.height);\n\tia_css_debug_dtrace(2, \"dis hor proj num = %d\\n\",\n\t\t\t    bi->dis.proj.pad.height);\n\tia_css_debug_dtrace(2, \"sctbl_width_per_color = %d\\n\",\n\t\t\t    bi->sctbl_width_per_color);\n\tia_css_debug_dtrace(2, \"s3atbl_width = %d\\n\", bi->s3atbl_width);\n\tia_css_debug_dtrace(2, \"s3atbl_height = %d\\n\", bi->s3atbl_height);\n\treturn;\n}\n\nvoid ia_css_debug_frame_print(const struct ia_css_frame *frame,\n\t\t\t      const char *descr)\n{\n\tchar *data = NULL;\n\n\tassert(frame);\n\tassert(descr);\n\n\tdata = (char *)HOST_ADDRESS(frame->data);\n\tia_css_debug_dtrace(2, \"frame %s (%p):\\n\", descr, frame);\n\tia_css_debug_dtrace(2, \"  resolution    = %dx%d\\n\",\n\t\t\t    frame->frame_info.res.width, frame->frame_info.res.height);\n\tia_css_debug_dtrace(2, \"  padded width  = %d\\n\",\n\t\t\t    frame->frame_info.padded_width);\n\tia_css_debug_dtrace(2, \"  format        = %d\\n\", frame->frame_info.format);\n\tswitch (frame->frame_info.format) {\n\tcase IA_CSS_FRAME_FORMAT_NV12:\n\tcase IA_CSS_FRAME_FORMAT_NV16:\n\tcase IA_CSS_FRAME_FORMAT_NV21:\n\tcase IA_CSS_FRAME_FORMAT_NV61:\n\t\tia_css_debug_dtrace(2, \"  Y = %p\\n\",\n\t\t\t\t    data + frame->planes.nv.y.offset);\n\t\tia_css_debug_dtrace(2, \"  UV = %p\\n\",\n\t\t\t\t    data + frame->planes.nv.uv.offset);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_YUYV:\n\tcase IA_CSS_FRAME_FORMAT_UYVY:\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8:\n\tcase IA_CSS_FRAME_FORMAT_YUV_LINE:\n\t\tia_css_debug_dtrace(2, \"  YUYV = %p\\n\",\n\t\t\t\t    data + frame->planes.yuyv.offset);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_YUV420:\n\tcase IA_CSS_FRAME_FORMAT_YUV422:\n\tcase IA_CSS_FRAME_FORMAT_YUV444:\n\tcase IA_CSS_FRAME_FORMAT_YV12:\n\tcase IA_CSS_FRAME_FORMAT_YV16:\n\tcase IA_CSS_FRAME_FORMAT_YUV420_16:\n\tcase IA_CSS_FRAME_FORMAT_YUV422_16:\n\t\tia_css_debug_dtrace(2, \"  Y = %p\\n\",\n\t\t\t\t    data + frame->planes.yuv.y.offset);\n\t\tia_css_debug_dtrace(2, \"  U = %p\\n\",\n\t\t\t\t    data + frame->planes.yuv.u.offset);\n\t\tia_css_debug_dtrace(2, \"  V = %p\\n\",\n\t\t\t\t    data + frame->planes.yuv.v.offset);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_RAW_PACKED:\n\t\tia_css_debug_dtrace(2, \"  RAW PACKED = %p\\n\",\n\t\t\t\t    data + frame->planes.raw.offset);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_RAW:\n\t\tia_css_debug_dtrace(2, \"  RAW = %p\\n\",\n\t\t\t\t    data + frame->planes.raw.offset);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_RGBA888:\n\tcase IA_CSS_FRAME_FORMAT_RGB565:\n\t\tia_css_debug_dtrace(2, \"  RGB = %p\\n\",\n\t\t\t\t    data + frame->planes.rgb.offset);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_QPLANE6:\n\t\tia_css_debug_dtrace(2, \"  R    = %p\\n\",\n\t\t\t\t    data + frame->planes.plane6.r.offset);\n\t\tia_css_debug_dtrace(2, \"  RatB = %p\\n\",\n\t\t\t\t    data + frame->planes.plane6.r_at_b.offset);\n\t\tia_css_debug_dtrace(2, \"  Gr   = %p\\n\",\n\t\t\t\t    data + frame->planes.plane6.gr.offset);\n\t\tia_css_debug_dtrace(2, \"  Gb   = %p\\n\",\n\t\t\t\t    data + frame->planes.plane6.gb.offset);\n\t\tia_css_debug_dtrace(2, \"  B    = %p\\n\",\n\t\t\t\t    data + frame->planes.plane6.b.offset);\n\t\tia_css_debug_dtrace(2, \"  BatR = %p\\n\",\n\t\t\t\t    data + frame->planes.plane6.b_at_r.offset);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_BINARY_8:\n\t\tia_css_debug_dtrace(2, \"  Binary data = %p\\n\",\n\t\t\t\t    data + frame->planes.binary.data.offset);\n\t\tbreak;\n\tdefault:\n\t\tia_css_debug_dtrace(2, \"  unknown frame type\\n\");\n\t\tbreak;\n\t}\n\treturn;\n}\n\n#if SP_DEBUG != SP_DEBUG_NONE\n\nvoid ia_css_debug_print_sp_debug_state(const struct sh_css_sp_debug_state\n\t\t\t\t       *state)\n{\n#endif\n\n#if SP_DEBUG == SP_DEBUG_DUMP\n\n\tassert(state);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"current SP software counter: %d\\n\",\n\t\t\t    state->debug[0]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty output buffer queue head: 0x%x\\n\",\n\t\t\t    state->debug[1]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty output buffer queue tail: 0x%x\\n\",\n\t\t\t    state->debug[2]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty s3a buffer queue head: 0x%x\\n\",\n\t\t\t    state->debug[3]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty s3a buffer queue tail: 0x%x\\n\",\n\t\t\t    state->debug[4]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"full output buffer queue head: 0x%x\\n\",\n\t\t\t    state->debug[5]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"full output buffer queue tail: 0x%x\\n\",\n\t\t\t    state->debug[6]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"full s3a buffer queue head: 0x%x\\n\",\n\t\t\t    state->debug[7]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"full s3a buffer queue tail: 0x%x\\n\",\n\t\t\t    state->debug[8]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"event queue head: 0x%x\\n\",\n\t\t\t    state->debug[9]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"event queue tail: 0x%x\\n\",\n\t\t\t    state->debug[10]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"num of stages of current pipeline: 0x%x\\n\",\n\t\t\t    state->debug[11]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"DDR address of stage 1: 0x%x\\n\",\n\t\t\t    state->debug[12]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"DDR address of stage 2: 0x%x\\n\",\n\t\t\t    state->debug[13]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"current stage out_vf buffer idx: 0x%x\\n\",\n\t\t\t    state->debug[14]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"current stage output buffer idx: 0x%x\\n\",\n\t\t\t    state->debug[15]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"current stage s3a buffer idx: 0x%x\\n\",\n\t\t\t    state->debug[16]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"first char of current stage name: 0x%x\\n\",\n\t\t\t    state->debug[17]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"current SP thread id: 0x%x\\n\",\n\t\t\t    state->debug[18]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty output buffer address 1: 0x%x\\n\",\n\t\t\t    state->debug[19]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty output buffer address 2: 0x%x\\n\",\n\t\t\t    state->debug[20]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty out_vf buffer address 1: 0x%x\\n\",\n\t\t\t    state->debug[21]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty out_vf buffer address 2: 0x%x\\n\",\n\t\t\t    state->debug[22]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty s3a_hi buffer address 1: 0x%x\\n\",\n\t\t\t    state->debug[23]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty s3a_hi buffer address 2: 0x%x\\n\",\n\t\t\t    state->debug[24]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty s3a_lo buffer address 1: 0x%x\\n\",\n\t\t\t    state->debug[25]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty s3a_lo buffer address 2: 0x%x\\n\",\n\t\t\t    state->debug[26]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty dis_hor buffer address 1: 0x%x\\n\",\n\t\t\t    state->debug[27]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty dis_hor buffer address 2: 0x%x\\n\",\n\t\t\t    state->debug[28]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty dis_ver buffer address 1: 0x%x\\n\",\n\t\t\t    state->debug[29]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty dis_ver buffer address 2: 0x%x\\n\",\n\t\t\t    state->debug[30]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"empty param buffer address: 0x%x\\n\",\n\t\t\t    state->debug[31]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"first incorrect frame address: 0x%x\\n\",\n\t\t\t    state->debug[32]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"first incorrect frame container address: 0x%x\\n\",\n\t\t\t    state->debug[33]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"first incorrect frame container payload: 0x%x\\n\",\n\t\t\t    state->debug[34]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"first incorrect s3a_hi address: 0x%x\\n\",\n\t\t\t    state->debug[35]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"first incorrect s3a_hi container address: 0x%x\\n\",\n\t\t\t    state->debug[36]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"first incorrect s3a_hi container payload: 0x%x\\n\",\n\t\t\t    state->debug[37]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"first incorrect s3a_lo address: 0x%x\\n\",\n\t\t\t    state->debug[38]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"first incorrect s3a_lo container address: 0x%x\\n\",\n\t\t\t    state->debug[39]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"first incorrect s3a_lo container payload: 0x%x\\n\",\n\t\t\t    state->debug[40]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"number of calling flash start function: 0x%x\\n\",\n\t\t\t    state->debug[41]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"number of calling flash close function: 0x%x\\n\",\n\t\t\t    state->debug[42]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"number of flashed frame: 0x%x\\n\",\n\t\t\t    state->debug[43]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"flash in use flag: 0x%x\\n\",\n\t\t\t    state->debug[44]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"number of update frame flashed flag: 0x%x\\n\",\n\t\t\t    state->debug[46]);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t    \"number of active threads: 0x%x\\n\",\n\t\t\t    state->debug[45]);\n\n#elif SP_DEBUG == SP_DEBUG_COPY\n\n\t \n\tstatic int last_index;\n\tint sp_index = state->index;\n\tint n;\n\n\tassert(state);\n\tif (sp_index < last_index) {\n\t\t \n\t\tlast_index = 0;\n\t}\n\n\tif (last_index == 0) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t\t    \"copy-trace init: sp_dbg_if_start_line=%d, sp_dbg_if_start_column=%d, sp_dbg_if_cropped_height=%d, sp_debg_if_cropped_width=%d\\n\",\n\t\t\t\t    state->if_start_line,\n\t\t\t\t    state->if_start_column,\n\t\t\t\t    state->if_cropped_height,\n\t\t\t\t    state->if_cropped_width);\n\t}\n\n\tif ((last_index + SH_CSS_SP_DBG_TRACE_DEPTH) < sp_index) {\n\t\t \n\t\t \n\t\tlast_index = sp_index - SH_CSS_SP_DBG_TRACE_DEPTH;\n\t}\n\n\tfor (n = last_index; n < sp_index; n++) {\n\t\tint i = n % SH_CSS_SP_DBG_TRACE_DEPTH;\n\n\t\tif (state->trace[i].frame != 0) {\n\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t\t\t    \"copy-trace: frame=%d, line=%d, pixel_distance=%d, mipi_used_dword=%d, sp_index=%d\\n\",\n\t\t\t\t\t    state->trace[i].frame,\n\t\t\t\t\t    state->trace[i].line,\n\t\t\t\t\t    state->trace[i].pixel_distance,\n\t\t\t\t\t    state->trace[i].mipi_used_dword,\n\t\t\t\t\t    state->trace[i].sp_index);\n\t\t}\n\t}\n\n\tlast_index = sp_index;\n\n#elif SP_DEBUG == SP_DEBUG_TRACE\n\n\t \n\tstatic char const *const id2filename[8] = {\n\t\t\"param_buffer.sp.c | tagger.sp.c | pipe_data.sp.c\",\n\t\t\"isp_init.sp.c\",\n\t\t\"sp_raw_copy.hive.c\",\n\t\t\"dma_configure.sp.c\",\n\t\t\"sp.hive.c\",\n\t\t\"event_proxy_sp.hive.c\",\n\t\t\"circular_buffer.sp.c\",\n\t\t\"frame_buffer.sp.c\"\n\t};\n\n\t \n\t \n\tstatic char const *trace_name[SH_CSS_SP_DBG_NR_OF_TRACES] = {\n\t\t\"default\"\n\t};\n\n\t \n\tstatic int host_index_last[SH_CSS_SP_DBG_NR_OF_TRACES] = { 0 };\n\tint t, n;\n\n\tassert(state);\n\n\tfor (t = 0; t < SH_CSS_SP_DBG_NR_OF_TRACES; t++) {\n\t\tint sp_index_last = state->index_last[t];\n\n\t\tif (sp_index_last < host_index_last[t]) {\n\t\t\t \n\t\t\thost_index_last[t] = 0;\n\t\t}\n\n\t\tif ((host_index_last[t] + SH_CSS_SP_DBG_TRACE_DEPTH) <\n\t\t    sp_index_last) {\n\t\t\t \n\t\t\t \n\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t\t\t    \"Warning: trace %s has gap of %d traces\\n\",\n\t\t\t\t\t    trace_name[t],\n\t\t\t\t\t    (sp_index_last -\n\t\t\t\t\t     (host_index_last[t] +\n\t\t\t\t\t      SH_CSS_SP_DBG_TRACE_DEPTH)));\n\n\t\t\thost_index_last[t] =\n\t\t\t    sp_index_last - SH_CSS_SP_DBG_TRACE_DEPTH;\n\t\t}\n\n\t\tfor (n = host_index_last[t]; n < sp_index_last; n++) {\n\t\t\tint i = n % SH_CSS_SP_DBG_TRACE_DEPTH;\n\t\t\tint l = state->trace[t][i].location &\n\t\t\t\t((1 << SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS) - 1);\n\t\t\tint fid = state->trace[t][i].location >>\n\t\t\t\t  SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS;\n\t\t\tint ts = state->trace[t][i].time_stamp;\n\n\t\t\tif (ts) {\n\t\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t\t\t\t    \"%05d trace=%s, file=%s:%d, data=0x%08x\\n\",\n\t\t\t\t\t\t    ts,\n\t\t\t\t\t\t    trace_name[t],\n\t\t\t\t\t\t    id2filename[fid], l,\n\t\t\t\t\t\t    state->trace[t][i].data);\n\t\t\t}\n\t\t}\n\t\thost_index_last[t] = sp_index_last;\n\t}\n\n#elif SP_DEBUG == SP_DEBUG_MINIMAL\n\tint i;\n\tint base = 0;\n\tint limit = SH_CSS_NUM_SP_DEBUG;\n\tint step = 1;\n\n\tassert(state);\n\n\tfor (i = base; i < limit; i += step) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t\t    \"sp_dbg_trace[%d] = %d\\n\",\n\t\t\t\t    i, state->debug[i]);\n\t}\n#endif\n\n#if SP_DEBUG != SP_DEBUG_NONE\n\n\treturn;\n}\n#endif\n\n#if !defined(ISP2401)\nstatic void debug_print_rx_mipi_port_state(mipi_port_state_t *state)\n{\n\tint i;\n\tunsigned int bits, infos;\n\n\tassert(state);\n\n\tbits = state->irq_status;\n\tinfos = ia_css_isys_rx_translate_irq_infos(bits);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: (irq reg = 0x%X)\\n\",\n\t\t\t    \"receiver errors\", bits);\n\n\tif (infos & IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN)\n\t\tia_css_debug_dtrace(2, \"\\t\\t\\tbuffer overrun\\n\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_SOT)\n\t\tia_css_debug_dtrace(2, \"\\t\\t\\tstart-of-transmission error\\n\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC)\n\t\tia_css_debug_dtrace(2, \"\\t\\t\\tstart-of-transmission sync error\\n\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_CONTROL)\n\t\tia_css_debug_dtrace(2, \"\\t\\t\\tcontrol error\\n\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE)\n\t\tia_css_debug_dtrace(2, \"\\t\\t\\t2 or more ECC errors\\n\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_CRC)\n\t\tia_css_debug_dtrace(2, \"\\t\\t\\tCRC mismatch\\n\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID)\n\t\tia_css_debug_dtrace(2, \"\\t\\t\\tunknown error\\n\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC)\n\t\tia_css_debug_dtrace(2, \"\\t\\t\\tframe sync error\\n\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA)\n\t\tia_css_debug_dtrace(2, \"\\t\\t\\tframe data error\\n\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT)\n\t\tia_css_debug_dtrace(2, \"\\t\\t\\tdata timeout\\n\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC)\n\t\tia_css_debug_dtrace(2, \"\\t\\t\\tunknown escape command entry\\n\");\n\tif (infos & IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC)\n\t\tia_css_debug_dtrace(2, \"\\t\\t\\tline sync error\\n\");\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"device_ready\", state->device_ready);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"irq_status\", state->irq_status);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"irq_enable\", state->irq_enable);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"timeout_count\", state->timeout_count);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"init_count\", state->init_count);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"raw16_18\", state->raw16_18);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"sync_count\", state->sync_count);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"rx_count\", state->rx_count);\n\n\tfor (i = 0; i < MIPI_4LANE_CFG; i++) {\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s%d%-32s: %d\\n\",\n\t\t\t\t    \"lane_sync_count[\", i, \"]\",\n\t\t\t\t    state->lane_sync_count[i]);\n\t}\n\n\tfor (i = 0; i < MIPI_4LANE_CFG; i++) {\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s%d%-32s: %d\\n\",\n\t\t\t\t    \"lane_rx_count[\", i, \"]\",\n\t\t\t\t    state->lane_rx_count[i]);\n\t}\n\n\treturn;\n}\n\nstatic void debug_print_rx_channel_state(rx_channel_state_t *state)\n{\n\tint i;\n\n\tassert(state);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"compression_scheme0\", state->comp_scheme0);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"compression_scheme1\", state->comp_scheme1);\n\n\tfor (i = 0; i < N_MIPI_FORMAT_CUSTOM; i++) {\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s%d: %d\\n\",\n\t\t\t\t    \"MIPI Predictor \", i, state->pred[i]);\n\t}\n\n\tfor (i = 0; i < N_MIPI_FORMAT_CUSTOM; i++) {\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s%d: %d\\n\",\n\t\t\t\t    \"MIPI Compressor \", i, state->comp[i]);\n\t}\n\n\treturn;\n}\n\nstatic void debug_print_rx_state(receiver_state_t *state)\n{\n\tint i;\n\n\tassert(state);\n\tia_css_debug_dtrace(2, \"CSI Receiver State:\\n\");\n\n\tia_css_debug_dtrace(2, \"\\tConfiguration:\\n\");\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"fs_to_ls_delay\", state->fs_to_ls_delay);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"ls_to_data_delay\", state->ls_to_data_delay);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"data_to_le_delay\", state->data_to_le_delay);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"le_to_fe_delay\", state->le_to_fe_delay);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"fe_to_fs_delay\", state->fe_to_fs_delay);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"le_to_fs_delay\", state->le_to_fs_delay);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"is_two_ppc\", state->is_two_ppc);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"backend_rst\", state->backend_rst);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"raw18\", state->raw18);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"force_raw8\", state->force_raw8);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"raw16\", state->raw16);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"be_gsp_acc_ovl\", state->be_gsp_acc_ovl);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"be_srst\", state->be_srst);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"be_is_two_ppc\", state->be_is_two_ppc);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"be_comp_format0\", state->be_comp_format0);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"be_comp_format1\", state->be_comp_format1);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"be_comp_format2\", state->be_comp_format2);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"be_comp_format3\", state->be_comp_format3);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"be_sel\", state->be_sel);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"be_raw16_config\", state->be_raw16_config);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"be_raw18_config\", state->be_raw18_config);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"be_force_raw8\", state->be_force_raw8);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"be_irq_status\", state->be_irq_status);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"be_irq_clear\", state->be_irq_clear);\n\n\t \n\tfor (i = 0; i < N_MIPI_PORT_ID; i++) {\n\t\tia_css_debug_dtrace(2, \"\\tMIPI Port %d State:\\n\", i);\n\n\t\tdebug_print_rx_mipi_port_state(&state->mipi_port_state[i]);\n\t}\n\t \n\n\t \n\tfor (i = 0; i < N_RX_CHANNEL_ID; i++) {\n\t\tia_css_debug_dtrace(2, \"\\tRX Channel %d State:\\n\", i);\n\n\t\tdebug_print_rx_channel_state(&state->rx_channel_state[i]);\n\t}\n\t \n\n\treturn;\n}\n#endif\n\nvoid ia_css_debug_dump_rx_state(void)\n{\n#if !defined(ISP2401)\n\treceiver_state_t state;\n\n\treceiver_get_state(RX0_ID, &state);\n\tdebug_print_rx_state(&state);\n#endif\n}\n\nvoid ia_css_debug_dump_sp_sw_debug_info(void)\n{\n#if SP_DEBUG != SP_DEBUG_NONE\n\tstruct sh_css_sp_debug_state state;\n\n\tsh_css_sp_get_debug_state(&state);\n\tia_css_debug_print_sp_debug_state(&state);\n#endif\n\tia_css_bufq_dump_queue_info();\n\tia_css_pipeline_dump_thread_map_info();\n\treturn;\n}\n\n#if !defined(ISP2401)\nstatic void debug_print_isys_capture_unit_state(capture_unit_state_t *state)\n{\n\tassert(state);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Packet_Length\", state->Packet_Length);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Received_Length\", state->Received_Length);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Received_Short_Packets\",\n\t\t\t    state->Received_Short_Packets);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Received_Long_Packets\",\n\t\t\t    state->Received_Long_Packets);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Last_Command\", state->Last_Command);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Next_Command\", state->Next_Command);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Last_Acknowledge\", state->Last_Acknowledge);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Next_Acknowledge\", state->Next_Acknowledge);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"FSM_State_Info\", state->FSM_State_Info);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"StartMode\", state->StartMode);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Start_Addr\", state->Start_Addr);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Mem_Region_Size\", state->Mem_Region_Size);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Num_Mem_Regions\", state->Num_Mem_Regions);\n\treturn;\n}\n\nstatic void debug_print_isys_acquisition_unit_state(\n    acquisition_unit_state_t *state)\n{\n\tassert(state);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Received_Short_Packets\",\n\t\t\t    state->Received_Short_Packets);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Received_Long_Packets\",\n\t\t\t    state->Received_Long_Packets);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Last_Command\", state->Last_Command);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Next_Command\", state->Next_Command);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Last_Acknowledge\", state->Last_Acknowledge);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Next_Acknowledge\", state->Next_Acknowledge);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"FSM_State_Info\", state->FSM_State_Info);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Int_Cntr_Info\", state->Int_Cntr_Info);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Start_Addr\", state->Start_Addr);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Mem_Region_Size\", state->Mem_Region_Size);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"Num_Mem_Regions\", state->Num_Mem_Regions);\n}\n\nstatic void debug_print_isys_ctrl_unit_state(ctrl_unit_state_t *state)\n{\n\tassert(state);\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"last_cmd\", state->last_cmd);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"next_cmd\", state->next_cmd);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"last_ack\", state->last_ack);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\", \"next_ack\", state->next_ack);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"top_fsm_state\", state->top_fsm_state);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"captA_fsm_state\", state->captA_fsm_state);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"captB_fsm_state\", state->captB_fsm_state);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"captC_fsm_state\", state->captC_fsm_state);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"acq_fsm_state\", state->acq_fsm_state);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"captA_start_addr\", state->captA_start_addr);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"captB_start_addr\", state->captB_start_addr);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"captC_start_addr\", state->captC_start_addr);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"captA_mem_region_size\",\n\t\t\t    state->captA_mem_region_size);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"captB_mem_region_size\",\n\t\t\t    state->captB_mem_region_size);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"captC_mem_region_size\",\n\t\t\t    state->captC_mem_region_size);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"captA_num_mem_regions\",\n\t\t\t    state->captA_num_mem_regions);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"captB_num_mem_regions\",\n\t\t\t    state->captB_num_mem_regions);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"captC_num_mem_regions\",\n\t\t\t    state->captC_num_mem_regions);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"acq_start_addr\", state->acq_start_addr);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"acq_mem_region_size\", state->acq_mem_region_size);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"acq_num_mem_regions\", state->acq_num_mem_regions);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"capt_reserve_one_mem_region\",\n\t\t\t    state->capt_reserve_one_mem_region);\n\n\treturn;\n}\n\nstatic void debug_print_isys_state(input_system_state_t *state)\n{\n\tint i;\n\n\tassert(state);\n\tia_css_debug_dtrace(2, \"InputSystem State:\\n\");\n\n\t \n\tia_css_debug_dtrace(2, \"\\tConfiguration:\\n\");\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"str_multiCastA_sel\", state->str_multicastA_sel);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"str_multicastB_sel\", state->str_multicastB_sel);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"str_multicastC_sel\", state->str_multicastC_sel);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"str_mux_sel\", state->str_mux_sel);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"str_mon_status\", state->str_mon_status);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"str_mon_irq_cond\", state->str_mon_irq_cond);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"str_mon_irq_en\", state->str_mon_irq_en);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"isys_srst\", state->isys_srst);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"isys_slv_reg_srst\", state->isys_slv_reg_srst);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"str_deint_portA_cnt\", state->str_deint_portA_cnt);\n\n\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t    \"str_deint_portB_cnd\", state->str_deint_portB_cnt);\n\t \n\n\t \n\tfor (i = 0; i < N_CAPTURE_UNIT_ID; i++) {\n\t\tcapture_unit_state_t *capture_unit_state;\n\n\t\tia_css_debug_dtrace(2, \"\\tCaptureUnit %d State:\\n\", i);\n\n\t\tcapture_unit_state = &state->capture_unit[i];\n\t\tdebug_print_isys_capture_unit_state(capture_unit_state);\n\t}\n\t \n\n\t \n\tfor (i = 0; i < N_ACQUISITION_UNIT_ID; i++) {\n\t\tacquisition_unit_state_t *acquisition_unit_state;\n\n\t\tia_css_debug_dtrace(2, \"\\tAcquisitionUnit %d State:\\n\", i);\n\n\t\tacquisition_unit_state = &state->acquisition_unit[i];\n\t\tdebug_print_isys_acquisition_unit_state(acquisition_unit_state);\n\t}\n\t \n\n\t \n\tfor (i = 0; i < N_CTRL_UNIT_ID; i++) {\n\t\tia_css_debug_dtrace(2, \"\\tControlUnit %d State:\\n\", i);\n\n\t\tdebug_print_isys_ctrl_unit_state(&state->ctrl_unit_state[i]);\n\t}\n\t \n}\n#endif\n\nvoid ia_css_debug_dump_isys_state(void)\n{\n\tstatic input_system_state_t state;\n\n\tinput_system_get_state(INPUT_SYSTEM0_ID, &state);\n\n#ifndef ISP2401\n\tdebug_print_isys_state(&state);\n#else\n\tinput_system_dump_state(INPUT_SYSTEM0_ID, &state);\n#endif\n}\n\nvoid ia_css_debug_dump_debug_info(const char *context)\n{\n\tif (!context)\n\t\tcontext = \"No Context provided\";\n\n\tia_css_debug_dtrace(2, \"CSS Debug Info dump [Context = %s]\\n\", context);\n\tif (!IS_ISP2401)\n\t\tia_css_debug_dump_rx_state();\n\n#ifndef ISP2401\n\tia_css_debug_dump_if_state();\n#endif\n\tia_css_debug_dump_isp_state();\n\tia_css_debug_dump_isp_sp_fifo_state();\n\tia_css_debug_dump_isp_gdc_fifo_state();\n\tia_css_debug_dump_sp_state();\n\tia_css_debug_dump_perf_counters();\n\n#ifdef HAS_WATCHDOG_SP_THREAD_DEBUG\n\tsh_css_dump_thread_wait_info();\n\tsh_css_dump_pipe_stage_info();\n\tsh_css_dump_pipe_stripe_info();\n#endif\n\tia_css_debug_dump_dma_isp_fifo_state();\n\tia_css_debug_dump_dma_sp_fifo_state();\n\tia_css_debug_dump_dma_state();\n\n\tif (!IS_ISP2401) {\n\t\tstruct irq_controller_state state;\n\n\t\tia_css_debug_dump_isys_state();\n\n\t\tirq_controller_get_state(IRQ2_ID, &state);\n\n\t\tia_css_debug_dtrace(2, \"\\t%-32s:\\n\",\n\t\t\t\t    \"Input System IRQ Controller State\");\n\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t\t    \"irq_edge\", state.irq_edge);\n\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t\t    \"irq_mask\", state.irq_mask);\n\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t\t    \"irq_status\", state.irq_status);\n\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t\t    \"irq_enable\", state.irq_enable);\n\n\t\tia_css_debug_dtrace(2, \"\\t\\t%-32s: %d\\n\",\n\t\t\t\t    \"irq_level_not_pulse\",\n\t\t\t\t    state.irq_level_not_pulse);\n\t} else {\n\t\tia_css_debug_dump_isys_state();\n\t}\n\n\tia_css_debug_tagger_state();\n\n\treturn;\n}\n\n \nvoid ia_css_debug_enable_sp_sleep_mode(enum ia_css_sp_sleep_mode mode)\n{\n\tconst struct ia_css_fw_info *fw;\n\tunsigned int HIVE_ADDR_sp_sleep_mode;\n\n\tfw = &sh_css_sp_fw;\n\tHIVE_ADDR_sp_sleep_mode = fw->info.sp.sleep_mode;\n\n\t(void)HIVE_ADDR_sp_sleep_mode;\t \n\n\tsp_dmem_store_uint32(SP0_ID,\n\t\t\t     (unsigned int)sp_address_of(sp_sleep_mode),\n\t\t\t     (uint32_t)mode);\n}\n\nvoid ia_css_debug_wake_up_sp(void)\n{\n\t \n\tsp_ctrl_setbit(SP0_ID, SP_SC_REG, SP_START_BIT);\n}\n\n#define FIND_DMEM_PARAMS_TYPE(stream, kernel, type) \\\n\t(struct HRTCAT(HRTCAT(sh_css_isp_, type), _params) *) \\\n\tfindf_dmem_params(stream, offsetof(struct ia_css_memory_offsets, dmem.kernel))\n\n#define FIND_DMEM_PARAMS(stream, kernel) FIND_DMEM_PARAMS_TYPE(stream, kernel, kernel)\n\n \nstatic char *\nfindf_dmem_params(struct ia_css_stream *stream, short idx)\n{\n\tint i;\n\n\tfor (i = 0; i < stream->num_pipes; i++) {\n\t\tstruct ia_css_pipe *pipe = stream->pipes[i];\n\t\tstruct ia_css_pipeline *pipeline = ia_css_pipe_get_pipeline(pipe);\n\t\tstruct ia_css_pipeline_stage *stage;\n\n\t\tfor (stage = pipeline->stages; stage; stage = stage->next) {\n\t\t\tstruct ia_css_binary *binary = stage->binary;\n\t\t\tshort *offsets = (short *)&binary->info->mem_offsets.offsets.param->dmem;\n\t\t\tshort dmem_offset = offsets[idx];\n\t\t\tconst struct ia_css_host_data *isp_data =\n\t\t\t    ia_css_isp_param_get_mem_init(&binary->mem_params,\n\t\t\t\t\t\t\t  IA_CSS_PARAM_CLASS_PARAM, IA_CSS_ISP_DMEM0);\n\t\t\tif (dmem_offset < 0)\n\t\t\t\tcontinue;\n\t\t\treturn &isp_data->address[dmem_offset];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid ia_css_debug_dump_isp_params(struct ia_css_stream *stream,\n\t\t\t\t  unsigned int enable)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"ISP PARAMETERS:\\n\");\n\n\tassert(stream);\n\tif ((enable & IA_CSS_DEBUG_DUMP_FPN)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_fpn_dump(FIND_DMEM_PARAMS(stream, fpn), IA_CSS_DEBUG_VERBOSE);\n\t}\n\tif ((enable & IA_CSS_DEBUG_DUMP_OB)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_ob_dump(FIND_DMEM_PARAMS(stream, ob), IA_CSS_DEBUG_VERBOSE);\n\t}\n\tif ((enable & IA_CSS_DEBUG_DUMP_SC)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_sc_dump(FIND_DMEM_PARAMS(stream, sc), IA_CSS_DEBUG_VERBOSE);\n\t}\n\tif ((enable & IA_CSS_DEBUG_DUMP_WB)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_wb_dump(FIND_DMEM_PARAMS(stream, wb), IA_CSS_DEBUG_VERBOSE);\n\t}\n\tif ((enable & IA_CSS_DEBUG_DUMP_DP)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_dp_dump(FIND_DMEM_PARAMS(stream, dp), IA_CSS_DEBUG_VERBOSE);\n\t}\n\tif ((enable & IA_CSS_DEBUG_DUMP_BNR)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_bnr_dump(FIND_DMEM_PARAMS(stream, bnr), IA_CSS_DEBUG_VERBOSE);\n\t}\n\tif ((enable & IA_CSS_DEBUG_DUMP_S3A)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_s3a_dump(FIND_DMEM_PARAMS(stream, s3a), IA_CSS_DEBUG_VERBOSE);\n\t}\n\tif ((enable & IA_CSS_DEBUG_DUMP_DE)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_de_dump(FIND_DMEM_PARAMS(stream, de), IA_CSS_DEBUG_VERBOSE);\n\t}\n\tif ((enable & IA_CSS_DEBUG_DUMP_YNR)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_nr_dump(FIND_DMEM_PARAMS_TYPE(stream, nr, ynr),  IA_CSS_DEBUG_VERBOSE);\n\t\tia_css_yee_dump(FIND_DMEM_PARAMS(stream, yee), IA_CSS_DEBUG_VERBOSE);\n\t}\n\tif ((enable & IA_CSS_DEBUG_DUMP_CSC)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_csc_dump(FIND_DMEM_PARAMS(stream, csc), IA_CSS_DEBUG_VERBOSE);\n\t\tia_css_yuv2rgb_dump(FIND_DMEM_PARAMS_TYPE(stream, yuv2rgb, csc),\n\t\t\t\t    IA_CSS_DEBUG_VERBOSE);\n\t\tia_css_rgb2yuv_dump(FIND_DMEM_PARAMS_TYPE(stream, rgb2yuv, csc),\n\t\t\t\t    IA_CSS_DEBUG_VERBOSE);\n\t}\n\tif ((enable & IA_CSS_DEBUG_DUMP_GC)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_gc_dump(FIND_DMEM_PARAMS(stream, gc), IA_CSS_DEBUG_VERBOSE);\n\t}\n\tif ((enable & IA_CSS_DEBUG_DUMP_TNR)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_tnr_dump(FIND_DMEM_PARAMS(stream, tnr), IA_CSS_DEBUG_VERBOSE);\n\t}\n\tif ((enable & IA_CSS_DEBUG_DUMP_ANR)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_anr_dump(FIND_DMEM_PARAMS(stream, anr), IA_CSS_DEBUG_VERBOSE);\n\t}\n\tif ((enable & IA_CSS_DEBUG_DUMP_CE)\n\t    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {\n\t\tia_css_ce_dump(FIND_DMEM_PARAMS(stream, ce), IA_CSS_DEBUG_VERBOSE);\n\t}\n}\n\nvoid sh_css_dump_sp_raw_copy_linecount(bool reduced)\n{\n\tconst struct ia_css_fw_info *fw;\n\tunsigned int HIVE_ADDR_raw_copy_line_count;\n\ts32 raw_copy_line_count;\n\tstatic s32 prev_raw_copy_line_count = -1;\n\n\tfw = &sh_css_sp_fw;\n\tHIVE_ADDR_raw_copy_line_count =\n\t    fw->info.sp.raw_copy_line_count;\n\n\t(void)HIVE_ADDR_raw_copy_line_count;\n\n\tsp_dmem_load(SP0_ID,\n\t\t     (unsigned int)sp_address_of(raw_copy_line_count),\n\t\t     &raw_copy_line_count,\n\t\t     sizeof(raw_copy_line_count));\n\n\t \n\tif (reduced)\n\t\traw_copy_line_count = (raw_copy_line_count < 0) ? raw_copy_line_count : 1;\n\t \n\tif (prev_raw_copy_line_count != raw_copy_line_count) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t\t    \"sh_css_dump_sp_raw_copy_linecount() line_count=%d\\n\",\n\t\t\t\t    raw_copy_line_count);\n\t\tprev_raw_copy_line_count = raw_copy_line_count;\n\t}\n}\n\nvoid ia_css_debug_dump_isp_binary(void)\n{\n\tconst struct ia_css_fw_info *fw;\n\tunsigned int HIVE_ADDR_pipeline_sp_curr_binary_id;\n\tu32 curr_binary_id;\n\tstatic u32 prev_binary_id = 0xFFFFFFFF;\n\tstatic u32 sample_count;\n\n\tfw = &sh_css_sp_fw;\n\tHIVE_ADDR_pipeline_sp_curr_binary_id = fw->info.sp.curr_binary_id;\n\n\t(void)HIVE_ADDR_pipeline_sp_curr_binary_id;\n\n\tsp_dmem_load(SP0_ID,\n\t\t     (unsigned int)sp_address_of(pipeline_sp_curr_binary_id),\n\t\t     &curr_binary_id,\n\t\t     sizeof(curr_binary_id));\n\n\t \n\tsample_count++;\n\tif (prev_binary_id != curr_binary_id) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t\t    \"sh_css_dump_isp_binary() pipe_id=%d, binary_id=%d, sample_count=%d\\n\",\n\t\t\t\t    (curr_binary_id >> 16),\n\t\t\t\t    (curr_binary_id & 0x0ffff),\n\t\t\t\t    sample_count);\n\t\tsample_count = 0;\n\t\tprev_binary_id = curr_binary_id;\n\t}\n}\n\nvoid ia_css_debug_dump_perf_counters(void)\n{\n\tconst struct ia_css_fw_info *fw;\n\tint i;\n\tunsigned int HIVE_ADDR_ia_css_isys_sp_error_cnt;\n\t \n\ts32 ia_css_sp_input_system_error_cnt[N_MIPI_PORT_ID + 1];\n\n\tif (IS_ISP2401)\n\t\treturn;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"Input System Error Counters:\\n\");\n\n\tfw = &sh_css_sp_fw;\n\tHIVE_ADDR_ia_css_isys_sp_error_cnt =\n\t    fw->info.sp.perf_counter_input_system_error;\n\n\t(void)HIVE_ADDR_ia_css_isys_sp_error_cnt;\n\n\tsp_dmem_load(SP0_ID,\n\t\t     (unsigned int)sp_address_of(ia_css_isys_sp_error_cnt),\n\t\t     &ia_css_sp_input_system_error_cnt,\n\t\t     sizeof(ia_css_sp_input_system_error_cnt));\n\n\tfor (i = 0; i < N_MIPI_PORT_ID + 1; i++) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"\\tport[%d] = %d\\n\",\n\t\t\t\t    i, ia_css_sp_input_system_error_cnt[i]);\n\t}\n}\n\n \nbool ia_css_debug_mode_init(void)\n{\n\tbool rc;\n\n\trc = sh_css_sp_init_dma_sw_reg(0);\n\treturn rc;\n}\n\n \nbool\nia_css_debug_mode_disable_dma_channel(int dma_id,\n\t\t\t\t      int channel_id, int request_type)\n{\n\tbool rc;\n\n\trc = sh_css_sp_set_dma_sw_reg(dma_id, channel_id, request_type, false);\n\n\treturn rc;\n}\n\n \nbool\nia_css_debug_mode_enable_dma_channel(int dma_id,\n\t\t\t\t     int channel_id, int request_type)\n{\n\tbool rc;\n\n\trc = sh_css_sp_set_dma_sw_reg(dma_id, channel_id, request_type, true);\n\n\treturn rc;\n}\n\nstatic void __printf(1, 2) dtrace_dot(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tassert(fmt);\n\tva_start(ap, fmt);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_INFO, \"%s\", DPG_START);\n\tia_css_debug_vdtrace(IA_CSS_DEBUG_INFO, fmt, ap);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_INFO, \"%s\", DPG_END);\n\tva_end(ap);\n}\n\n#ifdef HAS_WATCHDOG_SP_THREAD_DEBUG\nvoid sh_css_dump_thread_wait_info(void)\n{\n\tconst struct ia_css_fw_info *fw;\n\tint i;\n\tunsigned int HIVE_ADDR_sp_thread_wait;\n\ts32 sp_thread_wait[MAX_THREAD_NUM];\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"SEM WAITS:\\n\");\n\n\tfw = &sh_css_sp_fw;\n\tHIVE_ADDR_sp_thread_wait =\n\t    fw->info.sp.debug_wait;\n\n\t(void)HIVE_ADDR_sp_thread_wait;\n\n\tsp_dmem_load(SP0_ID,\n\t\t     (unsigned int)sp_address_of(sp_thread_wait),\n\t\t     &sp_thread_wait,\n\t\t     sizeof(sp_thread_wait));\n\tfor (i = 0; i < MAX_THREAD_NUM; i++) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t\t    \"\\twait[%d] = 0x%X\\n\",\n\t\t\t\t    i, sp_thread_wait[i]);\n\t}\n}\n\nvoid sh_css_dump_pipe_stage_info(void)\n{\n\tconst struct ia_css_fw_info *fw;\n\tint i;\n\tunsigned int HIVE_ADDR_sp_pipe_stage;\n\ts32 sp_pipe_stage[MAX_THREAD_NUM];\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"PIPE STAGE:\\n\");\n\n\tfw = &sh_css_sp_fw;\n\tHIVE_ADDR_sp_pipe_stage =\n\t    fw->info.sp.debug_stage;\n\n\t(void)HIVE_ADDR_sp_pipe_stage;\n\n\tsp_dmem_load(SP0_ID,\n\t\t     (unsigned int)sp_address_of(sp_pipe_stage),\n\t\t     &sp_pipe_stage,\n\t\t     sizeof(sp_pipe_stage));\n\tfor (i = 0; i < MAX_THREAD_NUM; i++) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t\t    \"\\tstage[%d] = %d\\n\",\n\t\t\t\t    i, sp_pipe_stage[i]);\n\t}\n}\n\nvoid sh_css_dump_pipe_stripe_info(void)\n{\n\tconst struct ia_css_fw_info *fw;\n\tint i;\n\tunsigned int HIVE_ADDR_sp_pipe_stripe;\n\ts32 sp_pipe_stripe[MAX_THREAD_NUM];\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, \"PIPE STRIPE:\\n\");\n\n\tfw = &sh_css_sp_fw;\n\tHIVE_ADDR_sp_pipe_stripe =\n\t    fw->info.sp.debug_stripe;\n\n\t(void)HIVE_ADDR_sp_pipe_stripe;\n\n\tsp_dmem_load(SP0_ID,\n\t\t     (unsigned int)sp_address_of(sp_pipe_stripe),\n\t\t     &sp_pipe_stripe,\n\t\t     sizeof(sp_pipe_stripe));\n\tfor (i = 0; i < MAX_THREAD_NUM; i++) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,\n\t\t\t\t    \"\\tstripe[%d] = %d\\n\",\n\t\t\t\t    i, sp_pipe_stripe[i]);\n\t}\n}\n#endif\n\nstatic void\nia_css_debug_pipe_graph_dump_frame(\n    const struct ia_css_frame *frame,\n    enum ia_css_pipe_id id,\n    char const *blob_name,\n    char const *frame_name,\n    bool in_frame)\n{\n\tchar bufinfo[100];\n\n\tif (frame->dynamic_queue_id == SH_CSS_INVALID_QUEUE_ID) {\n\t\tsnprintf(bufinfo, sizeof(bufinfo), \"Internal\");\n\t} else {\n\t\tsnprintf(bufinfo, sizeof(bufinfo), \"Queue: %s %s\",\n\t\t\t pipe_id_to_str[id],\n\t\t\t queue_id_to_str[frame->dynamic_queue_id]);\n\t}\n\tdtrace_dot(\n\t    \"node [shape = box, fixedsize=true, width=2, height=0.7]; \\\"%p\\\" [label = \\\"%s\\\\n%d(%d) x %d, %dbpp\\\\n%s\\\"];\",\n\t    frame,\n\t    debug_frame_format2str(frame->frame_info.format),\n\t    frame->frame_info.res.width,\n\t    frame->frame_info.padded_width,\n\t    frame->frame_info.res.height,\n\t    frame->frame_info.raw_bit_depth,\n\t    bufinfo);\n\n\tif (in_frame) {\n\t\tdtrace_dot(\n\t\t    \"\\\"%p\\\"->\\\"%s(pipe%d)\\\" [label = %s_frame];\",\n\t\t    frame,\n\t\t    blob_name, id, frame_name);\n\t} else {\n\t\tdtrace_dot(\n\t\t    \"\\\"%s(pipe%d)\\\"->\\\"%p\\\" [label = %s_frame];\",\n\t\t    blob_name, id,\n\t\t    frame,\n\t\t    frame_name);\n\t}\n}\n\nvoid\nia_css_debug_pipe_graph_dump_prologue(void)\n{\n\tdtrace_dot(\"digraph sh_css_pipe_graph {\");\n\tdtrace_dot(\"rankdir=LR;\");\n\n\tdtrace_dot(\"fontsize=9;\");\n\tdtrace_dot(\"label = \\\"\\\\nEnable options: rp=reduced pipe, vfve=vf_veceven, dvse=dvs_envelope, dvs6=dvs_6axis, bo=block_out, fbds=fixed_bayer_ds, bf6=bayer_fir_6db, rawb=raw_binning, cont=continuous, disc=dis_crop\\\\n\"\n\t\t   \"dp2a=dp_2adjacent, outp=output, outt=out_table, reff=ref_frame, par=params, gam=gamma, cagdc=ca_gdc, ispa=isp_addresses, inf=in_frame, outf=out_frame, hs=high_speed, inpc=input_chunking\\\"\");\n}\n\nvoid ia_css_debug_pipe_graph_dump_epilogue(void)\n{\n\tif (strlen(ring_buffer) > 0) {\n\t\tdtrace_dot(ring_buffer);\n\t}\n\n\tif (pg_inst.stream_format != N_ATOMISP_INPUT_FORMAT) {\n\t\t \n\n\t\tdtrace_dot(\n\t\t    \"node [shape = doublecircle, fixedsize=true, width=2.5]; \\\"input_system\\\" [label = \\\"Input system\\\"];\");\n\n\t\tdtrace_dot(\n\t\t    \"\\\"input_system\\\"->\\\"%s\\\" [label = \\\"%s\\\"];\",\n\t\t    dot_id_input_bin, debug_stream_format2str(pg_inst.stream_format));\n\n\t\tdtrace_dot(\n\t\t    \"node [shape = doublecircle, fixedsize=true, width=2.5]; \\\"sensor\\\" [label = \\\"Sensor\\\"];\");\n\n\t\tdtrace_dot(\n\t\t    \"\\\"sensor\\\"->\\\"input_system\\\" [label = \\\"%s\\\\n%d x %d\\\\n(%d x %d)\\\"];\",\n\t\t    debug_stream_format2str(pg_inst.stream_format),\n\t\t    pg_inst.width, pg_inst.height,\n\t\t    pg_inst.eff_width, pg_inst.eff_height);\n\t}\n\n\tdtrace_dot(\"}\");\n\n\t \n\tmemset(dot_id_input_bin, 0, sizeof(dot_id_input_bin));\n\tmemset(ring_buffer, 0, sizeof(ring_buffer));\n\n\tpg_inst.do_init = true;\n\tpg_inst.width = 0;\n\tpg_inst.height = 0;\n\tpg_inst.eff_width = 0;\n\tpg_inst.eff_height = 0;\n\tpg_inst.stream_format = N_ATOMISP_INPUT_FORMAT;\n}\n\nvoid\nia_css_debug_pipe_graph_dump_stage(\n    struct ia_css_pipeline_stage *stage,\n    enum ia_css_pipe_id id)\n{\n\tchar blob_name[SH_CSS_MAX_BINARY_NAME + 10] = \"<unknown type>\";\n\tchar const *bin_type = \"<unknown type>\";\n\tint i;\n\n\tassert(stage);\n\tif (stage->sp_func != IA_CSS_PIPELINE_NO_FUNC)\n\t\treturn;\n\n\tif (pg_inst.do_init) {\n\t\tia_css_debug_pipe_graph_dump_prologue();\n\t\tpg_inst.do_init = false;\n\t}\n\n\tif (stage->binary) {\n\t\tbin_type = \"binary\";\n\t\tif (stage->binary->info->blob)\n\t\t\tsnprintf(blob_name, sizeof(blob_name), \"%s_stage%d\",\n\t\t\t\t stage->binary->info->blob->name, stage->stage_num);\n\t} else if (stage->firmware) {\n\t\tbin_type = \"firmware\";\n\n\t\tstrscpy(blob_name, IA_CSS_EXT_ISP_PROG_NAME(stage->firmware),\n\t\t\tsizeof(blob_name));\n\t}\n\n\t \n\tif (stage->binary_info) {\n\t\tchar enable_info1[100];\n\t\tchar enable_info2[100];\n\t\tchar enable_info3[100];\n\t\tchar enable_info[200];\n\t\tstruct ia_css_binary_info *bi = stage->binary_info;\n\n\t\t \n\t\tsnprintf(enable_info1, sizeof(enable_info1),\n\t\t\t \"%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n\t\t\t bi->enable.reduced_pipe ?\t\"rp,\" : \"\",\n\t\t\t bi->enable.vf_veceven ?\t\t\"vfve,\" : \"\",\n\t\t\t bi->enable.dis ?\t\t\"dis,\" : \"\",\n\t\t\t bi->enable.dvs_envelope ?\t\"dvse,\" : \"\",\n\t\t\t bi->enable.uds ?\t\t\"uds,\" : \"\",\n\t\t\t bi->enable.dvs_6axis ?\t\t\"dvs6,\" : \"\",\n\t\t\t bi->enable.block_output ?\t\"bo,\" : \"\",\n\t\t\t bi->enable.ds ?\t\t\t\"ds,\" : \"\",\n\t\t\t bi->enable.bayer_fir_6db ?\t\"bf6,\" : \"\",\n\t\t\t bi->enable.raw_binning ?\t\"rawb,\" : \"\",\n\t\t\t bi->enable.continuous ?\t\t\"cont,\" : \"\",\n\t\t\t bi->enable.s3a ?\t\t\"s3a,\" : \"\",\n\t\t\t bi->enable.fpnr ?\t\t\"fpnr,\" : \"\",\n\t\t\t bi->enable.sc ?\t\t\t\"sc,\" : \"\"\n\t\t\t);\n\n\t\tsnprintf(enable_info2, sizeof(enable_info2),\n\t\t\t \"%s%s%s%s%s%s%s%s%s%s%s\",\n\t\t\t bi->enable.macc ?\t\t\"macc,\" : \"\",\n\t\t\t bi->enable.output ?\t\t\"outp,\" : \"\",\n\t\t\t bi->enable.ref_frame ?\t\t\"reff,\" : \"\",\n\t\t\t bi->enable.tnr ?\t\t\"tnr,\" : \"\",\n\t\t\t bi->enable.xnr ?\t\t\"xnr,\" : \"\",\n\t\t\t bi->enable.params ?\t\t\"par,\" : \"\",\n\t\t\t bi->enable.ca_gdc ?\t\t\"cagdc,\" : \"\",\n\t\t\t bi->enable.isp_addresses ?\t\"ispa,\" : \"\",\n\t\t\t bi->enable.in_frame ?\t\t\"inf,\" : \"\",\n\t\t\t bi->enable.out_frame ?\t\t\"outf,\" : \"\",\n\t\t\t bi->enable.high_speed ?\t\t\"hs,\" : \"\"\n\t\t\t);\n\n\t\t \n\t\tsnprintf(enable_info, sizeof(enable_info), \"%s%s\",\n\t\t\t enable_info1, enable_info2);\n\t\t{\n\t\t\tint l, p;\n\t\t\tchar *ei = enable_info;\n\n\t\t\tl = strlen(ei);\n\n\t\t\t \n\t\t\tif (l && enable_info[l - 1] == ',')\n\t\t\t\tenable_info[--l] = '\\0';\n\n\t\t\tif (l > ENABLE_LINE_MAX_LENGTH) {\n\t\t\t\t \n\t\t\t\tp = ENABLE_LINE_MAX_LENGTH;\n\t\t\t\twhile (ei[p] != ',')\n\t\t\t\t\tp--;\n\t\t\t\t \n\t\t\t\tstrscpy(enable_info1, ei,\n                                        p > sizeof(enable_info1) ? sizeof(enable_info1) : p);\n\n\t\t\t\tei += p + 1;\n\t\t\t\tl = strlen(ei);\n\n\t\t\t\tif (l <= ENABLE_LINE_MAX_LENGTH) {\n\t\t\t\t\t \n\t\t\t\t\t \n\n\t\t\t\t\tstrscpy(enable_info2, ei,\n\t\t\t\t\t\tl > sizeof(enable_info2) ? sizeof(enable_info2) : l);\n\n\t\t\t\t\tsnprintf(enable_info, sizeof(enable_info), \"%s\\\\n%s\",\n\t\t\t\t\t\t enable_info1, enable_info2);\n\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tp = ENABLE_LINE_MAX_LENGTH;\n\t\t\t\t\twhile (ei[p] != ',')\n\t\t\t\t\t\tp--;\n\n\t\t\t\t\tstrscpy(enable_info2, ei,\n\t\t\t\t\t\tp > sizeof(enable_info2) ? sizeof(enable_info2) : p);\n\n\t\t\t\t\tei += p + 1;\n\t\t\t\t\tl = strlen(ei);\n\n\t\t\t\t\tif (l <= ENABLE_LINE_MAX_LENGTH) {\n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\tstrscpy(enable_info3, ei,\n\t\t\t\t\t\t\tsizeof(enable_info3));\n\t\t\t\t\t\tsnprintf(enable_info, sizeof(enable_info),\n\t\t\t\t\t\t\t \"%s\\\\n%s\\\\n%s\",\n\t\t\t\t\t\t\t enable_info1, enable_info2,\n\t\t\t\t\t\t\t enable_info3);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\tp = ENABLE_LINE_MAX_LENGTH;\n\t\t\t\t\t\twhile (ei[p] != ',')\n\t\t\t\t\t\t\tp--;\n\t\t\t\t\t\tstrscpy(enable_info3, ei,\n\t\t\t\t\t\t\tp > sizeof(enable_info3) ? sizeof(enable_info3) : p);\n\t\t\t\t\t\tei += p + 1;\n\t\t\t\t\t\tstrscpy(enable_info3, ei,\n\t\t\t\t\t\t\tsizeof(enable_info3));\n\t\t\t\t\t\tsnprintf(enable_info, sizeof(enable_info),\n\t\t\t\t\t\t\t \"%s\\\\n%s\\\\n%s\",\n\t\t\t\t\t\t\t enable_info1, enable_info2,\n\t\t\t\t\t\t\t enable_info3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdtrace_dot(\"node [shape = circle, fixedsize=true, width=2.5, label=\\\"%s\\\\n%s\\\\n\\\\n%s\\\"]; \\\"%s(pipe%d)\\\"\",\n\t\t\t   bin_type, blob_name, enable_info, blob_name, id);\n\t} else {\n\t\tdtrace_dot(\"node [shape = circle, fixedsize=true, width=2.5, label=\\\"%s\\\\n%s\\\\n\\\"]; \\\"%s(pipe%d)\\\"\",\n\t\t\t   bin_type, blob_name, blob_name, id);\n\t}\n\n\tif (stage->stage_num == 0) {\n\t\t \n\t\tif (strlen(dot_id_input_bin) == 0) {\n\t\t\tsnprintf(dot_id_input_bin, sizeof(dot_id_input_bin),\n\t\t\t\t \"%s(pipe%d)\", blob_name, id);\n\t\t}\n\t}\n\n\tif (stage->args.in_frame) {\n\t\tia_css_debug_pipe_graph_dump_frame(\n\t\t    stage->args.in_frame, id, blob_name,\n\t\t    \"in\", true);\n\t}\n\n\tfor (i = 0; i < NUM_VIDEO_TNR_FRAMES; i++) {\n\t\tif (stage->args.tnr_frames[i]) {\n\t\t\tia_css_debug_pipe_graph_dump_frame(\n\t\t\t    stage->args.tnr_frames[i], id,\n\t\t\t    blob_name, \"tnr_frame\", true);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_NUM_VIDEO_DELAY_FRAMES; i++) {\n\t\tif (stage->args.delay_frames[i]) {\n\t\t\tia_css_debug_pipe_graph_dump_frame(\n\t\t\t    stage->args.delay_frames[i], id,\n\t\t\t    blob_name, \"delay_frame\", true);\n\t\t}\n\t}\n\n\tfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {\n\t\tif (stage->args.out_frame[i]) {\n\t\t\tia_css_debug_pipe_graph_dump_frame(\n\t\t\t    stage->args.out_frame[i], id, blob_name,\n\t\t\t    \"out\", false);\n\t\t}\n\t}\n\n\tif (stage->args.out_vf_frame) {\n\t\tia_css_debug_pipe_graph_dump_frame(\n\t\t    stage->args.out_vf_frame, id, blob_name,\n\t\t    \"out_vf\", false);\n\t}\n}\n\nvoid\nia_css_debug_pipe_graph_dump_sp_raw_copy(\n    struct ia_css_frame *out_frame)\n{\n\tassert(out_frame);\n\tif (pg_inst.do_init) {\n\t\tia_css_debug_pipe_graph_dump_prologue();\n\t\tpg_inst.do_init = false;\n\t}\n\n\tdtrace_dot(\"node [shape = circle, fixedsize=true, width=2.5, label=\\\"%s\\\\n%s\\\"]; \\\"%s(pipe%d)\\\"\",\n\t\t   \"sp-binary\", \"sp_raw_copy\", \"sp_raw_copy\", 1);\n\n\tsnprintf(ring_buffer, sizeof(ring_buffer),\n\t\t \"node [shape = box, fixedsize=true, width=2, height=0.7]; \\\"%p\\\" [label = \\\"%s\\\\n%d(%d) x %d\\\\nRingbuffer\\\"];\",\n\t\t out_frame,\n\t\t debug_frame_format2str(out_frame->frame_info.format),\n\t\t out_frame->frame_info.res.width,\n\t\t out_frame->frame_info.padded_width,\n\t\t out_frame->frame_info.res.height);\n\n\tdtrace_dot(ring_buffer);\n\n\tdtrace_dot(\n\t    \"\\\"%s(pipe%d)\\\"->\\\"%p\\\" [label = out_frame];\",\n\t    \"sp_raw_copy\", 1, out_frame);\n\n\tsnprintf(dot_id_input_bin, sizeof(dot_id_input_bin), \"%s(pipe%d)\",\n\t\t \"sp_raw_copy\", 1);\n}\n\nvoid\nia_css_debug_pipe_graph_dump_stream_config(\n    const struct ia_css_stream_config *stream_config)\n{\n\tpg_inst.width = stream_config->input_config.input_res.width;\n\tpg_inst.height = stream_config->input_config.input_res.height;\n\tpg_inst.eff_width = stream_config->input_config.effective_res.width;\n\tpg_inst.eff_height = stream_config->input_config.effective_res.height;\n\tpg_inst.stream_format = stream_config->input_config.format;\n}\n\nvoid\nia_css_debug_dump_resolution(\n    const struct ia_css_resolution *res,\n    const char *label)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%s: =%d x =%d\\n\",\n\t\t\t    label, res->width, res->height);\n}\n\nvoid\nia_css_debug_dump_frame_info(\n    const struct ia_css_frame_info *info,\n    const char *label)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%s\\n\", label);\n\tia_css_debug_dump_resolution(&info->res, \"res\");\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"padded_width: %d\\n\",\n\t\t\t    info->padded_width);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"format: %d\\n\", info->format);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"raw_bit_depth: %d\\n\",\n\t\t\t    info->raw_bit_depth);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"raw_bayer_order: %d\\n\",\n\t\t\t    info->raw_bayer_order);\n}\n\nvoid\nia_css_debug_dump_capture_config(\n    const struct ia_css_capture_config *config)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%s\\n\", __func__);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"mode: %d\\n\", config->mode);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"enable_xnr:  %d\\n\",\n\t\t\t    config->enable_xnr);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"enable_raw_output: %d\\n\",\n\t\t\t    config->enable_raw_output);\n}\n\nvoid\nia_css_debug_dump_pipe_extra_config(\n    const struct ia_css_pipe_extra_config *extra_config)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%s\\n\", __func__);\n\tif (extra_config) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"enable_raw_binning: %d\\n\",\n\t\t\t\t    extra_config->enable_raw_binning);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"enable_yuv_ds: %d\\n\",\n\t\t\t\t    extra_config->enable_yuv_ds);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"enable_high_speed:  %d\\n\",\n\t\t\t\t    extra_config->enable_high_speed);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"enable_dvs_6axis: %d\\n\",\n\t\t\t\t    extra_config->enable_dvs_6axis);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"enable_reduced_pipe: %d\\n\",\n\t\t\t\t    extra_config->enable_reduced_pipe);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"enable_fractional_ds: %d\\n\",\n\t\t\t\t    extra_config->enable_fractional_ds);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"disable_vf_pp: %d\\n\",\n\t\t\t\t    extra_config->disable_vf_pp);\n\t}\n}\n\nvoid\nia_css_debug_dump_pipe_config(\n    const struct ia_css_pipe_config *config)\n{\n\tunsigned int i;\n\n\tIA_CSS_ENTER_PRIVATE(\"config = %p\", config);\n\tif (!config) {\n\t\tIA_CSS_ERROR(\"NULL input parameter\");\n\t\tIA_CSS_LEAVE_PRIVATE(\"\");\n\t\treturn;\n\t}\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"mode: %d\\n\", config->mode);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"isp_pipe_version: %d\\n\",\n\t\t\t    config->isp_pipe_version);\n\tia_css_debug_dump_resolution(&config->bayer_ds_out_res,\n\t\t\t\t     \"bayer_ds_out_res\");\n\tia_css_debug_dump_resolution(&config->capt_pp_in_res,\n\t\t\t\t     \"capt_pp_in_res\");\n\tia_css_debug_dump_resolution(&config->vf_pp_in_res, \"vf_pp_in_res\");\n\n\tif (IS_ISP2401) {\n\t\tia_css_debug_dump_resolution(&config->output_system_in_res,\n\t\t\t\t\t    \"output_system_in_res\");\n\t}\n\tia_css_debug_dump_resolution(&config->dvs_crop_out_res,\n\t\t\t\t     \"dvs_crop_out_res\");\n\tfor (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {\n\t\tia_css_debug_dump_frame_info(&config->output_info[i], \"output_info\");\n\t\tia_css_debug_dump_frame_info(&config->vf_output_info[i],\n\t\t\t\t\t     \"vf_output_info\");\n\t}\n\tia_css_debug_dump_capture_config(&config->default_capture_config);\n\tia_css_debug_dump_resolution(&config->dvs_envelope, \"dvs_envelope\");\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"dvs_frame_delay: %d\\n\",\n\t\t\t    config->dvs_frame_delay);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"enable_dz: %d\\n\",\n\t\t\t    config->enable_dz);\n\tIA_CSS_LEAVE_PRIVATE(\"\");\n}\n\nvoid\nia_css_debug_dump_stream_config_source(\n    const struct ia_css_stream_config *config)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%s()\\n\", __func__);\n\tswitch (config->mode) {\n\tcase IA_CSS_INPUT_MODE_SENSOR:\n\tcase IA_CSS_INPUT_MODE_BUFFERED_SENSOR:\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"source.port\\n\");\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"port: %d\\n\",\n\t\t\t\t    config->source.port.port);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"num_lanes: %d\\n\",\n\t\t\t\t    config->source.port.num_lanes);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"timeout: %d\\n\",\n\t\t\t\t    config->source.port.timeout);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"compression: %d\\n\",\n\t\t\t\t    config->source.port.compression.type);\n\t\tbreak;\n\tcase IA_CSS_INPUT_MODE_TPG:\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"source.tpg\\n\");\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"id: %d\\n\",\n\t\t\t\t    config->source.tpg.id);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"mode: %d\\n\",\n\t\t\t\t    config->source.tpg.mode);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"x_mask: 0x%x\\n\",\n\t\t\t\t    config->source.tpg.x_mask);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"x_delta: %d\\n\",\n\t\t\t\t    config->source.tpg.x_delta);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"y_mask: 0x%x\\n\",\n\t\t\t\t    config->source.tpg.y_mask);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"y_delta: %d\\n\",\n\t\t\t\t    config->source.tpg.y_delta);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"xy_mask: 0x%x\\n\",\n\t\t\t\t    config->source.tpg.xy_mask);\n\t\tbreak;\n\tcase IA_CSS_INPUT_MODE_PRBS:\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"source.prbs\\n\");\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"id: %d\\n\",\n\t\t\t\t    config->source.prbs.id);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"h_blank: %d\\n\",\n\t\t\t\t    config->source.prbs.h_blank);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"v_blank: %d\\n\",\n\t\t\t\t    config->source.prbs.v_blank);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"seed: 0x%x\\n\",\n\t\t\t\t    config->source.prbs.seed);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"seed1: 0x%x\\n\",\n\t\t\t\t    config->source.prbs.seed1);\n\t\tbreak;\n\tdefault:\n\tcase IA_CSS_INPUT_MODE_FIFO:\n\tcase IA_CSS_INPUT_MODE_MEMORY:\n\t\tbreak;\n\t}\n}\n\nvoid\nia_css_debug_dump_mipi_buffer_config(\n    const struct ia_css_mipi_buffer_config *config)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%s()\\n\", __func__);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"size_mem_words: %d\\n\",\n\t\t\t    config->size_mem_words);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"nof_mipi_buffers: %d\\n\",\n\t\t\t    config->nof_mipi_buffers);\n}\n\nvoid\nia_css_debug_dump_metadata_config(\n    const struct ia_css_metadata_config *config)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%s()\\n\", __func__);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"data_type: %d\\n\",\n\t\t\t    config->data_type);\n\tia_css_debug_dump_resolution(&config->resolution, \"resolution\");\n}\n\nvoid\nia_css_debug_dump_stream_config(\n    const struct ia_css_stream_config *config,\n    int num_pipes)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%s()\\n\", __func__);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"num_pipes: %d\\n\", num_pipes);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"mode: %d\\n\", config->mode);\n\tia_css_debug_dump_stream_config_source(config);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"channel_id: %d\\n\",\n\t\t\t    config->channel_id);\n\tia_css_debug_dump_resolution(&config->input_config.input_res, \"input_res\");\n\tia_css_debug_dump_resolution(&config->input_config.effective_res,\n\t\t\t\t     \"effective_res\");\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"format: %d\\n\",\n\t\t\t    config->input_config.format);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"bayer_order: %d\\n\",\n\t\t\t    config->input_config.bayer_order);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"sensor_binning_factor: %d\\n\",\n\t\t\t    config->sensor_binning_factor);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"pixels_per_clock: %d\\n\",\n\t\t\t    config->pixels_per_clock);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"online: %d\\n\",\n\t\t\t    config->online);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"init_num_cont_raw_buf: %d\\n\",\n\t\t\t    config->init_num_cont_raw_buf);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"target_num_cont_raw_buf: %d\\n\",\n\t\t\t    config->target_num_cont_raw_buf);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"pack_raw_pixels: %d\\n\",\n\t\t\t    config->pack_raw_pixels);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"continuous: %d\\n\",\n\t\t\t    config->continuous);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"flash_gpio_pin: %d\\n\",\n\t\t\t    config->flash_gpio_pin);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"left_padding: %d\\n\",\n\t\t\t    config->left_padding);\n\tia_css_debug_dump_mipi_buffer_config(&config->mipi_buffer_config);\n\tia_css_debug_dump_metadata_config(&config->metadata_config);\n}\n\n \n\n \n#if TRACE_ENABLE_SP0 || TRACE_ENABLE_SP1 || TRACE_ENABLE_ISP\nstatic void debug_dump_one_trace(enum TRACE_CORE_ID proc_id)\n{\n#if defined(HAS_TRACER_V2)\n\tu32 start_addr;\n\tu32 start_addr_data;\n\tu32 item_size;\n\tu32 tmp;\n\tu8 tid_val;\n\tenum TRACE_DUMP_FORMAT dump_format;\n\n\tint i, j, max_trace_points, point_num, limit = -1;\n\t \n\tstatic u32 trace_read_buf[TRACE_BUFF_SIZE] = {0};\n\tstatic struct trace_header_t header;\n\tu8 *header_arr;\n\n\t \n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"~~~ Tracer \");\n\tswitch (proc_id) {\n\tcase TRACE_SP0_ID:\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"SP0\");\n\t\tstart_addr = TRACE_SP0_ADDR;\n\t\tstart_addr_data = TRACE_SP0_DATA_ADDR;\n\t\titem_size = TRACE_SP0_ITEM_SIZE;\n\t\tmax_trace_points = TRACE_SP0_MAX_POINTS;\n\t\tbreak;\n\tcase TRACE_SP1_ID:\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"SP1\");\n\t\tstart_addr = TRACE_SP1_ADDR;\n\t\tstart_addr_data = TRACE_SP1_DATA_ADDR;\n\t\titem_size = TRACE_SP1_ITEM_SIZE;\n\t\tmax_trace_points = TRACE_SP1_MAX_POINTS;\n\t\tbreak;\n\tcase TRACE_ISP_ID:\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"ISP\");\n\t\tstart_addr = TRACE_ISP_ADDR;\n\t\tstart_addr_data = TRACE_ISP_DATA_ADDR;\n\t\titem_size = TRACE_ISP_ITEM_SIZE;\n\t\tmax_trace_points = TRACE_ISP_MAX_POINTS;\n\t\tbreak;\n\tdefault:\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"\\t\\ttraces are not supported for this processor ID - exiting\\n\");\n\t\treturn;\n\t}\n\n\tif (!IS_ISP2401) {\n\t\ttmp = ia_css_device_load_uint32(start_addr);\n\t\tpoint_num = (tmp >> 16) & 0xFFFF;\n\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \" ver %d %d points\\n\", tmp & 0xFF,\n\t\t\t\t    point_num);\n\t} else {\n\t\t \n\t\theader_arr = (uint8_t *)&header;\n\t\tfor (i = 0; i < (int)sizeof(struct trace_header_t); i++)\n\t\t\theader_arr[i] = ia_css_device_load_uint8(start_addr + (i));\n\n\t\tpoint_num = header.max_tracer_points;\n\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \" ver %d %d points\\n\", header.version,\n\t\t\t\t    point_num);\n\n\t\ttmp = header.version;\n\t}\n\tif ((tmp & 0xFF) != TRACER_VER) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"\\t\\tUnknown version - exiting\\n\");\n\t\treturn;\n\t}\n\tif (point_num > max_trace_points) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"\\t\\tToo many points - exiting\\n\");\n\t\treturn;\n\t}\n\t \n\tfor (i = 0; i < point_num; i++) {\n\t\ttrace_read_buf[i] = ia_css_device_load_uint32(start_addr_data +\n\t\t\t\t    (i * item_size));\n\t\tif ((limit == (-1)) && (trace_read_buf[i] == 0))\n\t\t\tlimit = i;\n\t}\n\tif (IS_ISP2401) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"Status:\\n\");\n\t\tfor (i = 0; i < SH_CSS_MAX_SP_THREADS; i++)\n\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t    \"\\tT%d: %3d (%02x)  %6d (%04x)  %10d (%08x)\\n\", i,\n\t\t\t\t\t    header.thr_status_byte[i], header.thr_status_byte[i],\n\t\t\t\t\t    header.thr_status_word[i], header.thr_status_word[i],\n\t\t\t\t\t    header.thr_status_dword[i], header.thr_status_dword[i]);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"Scratch:\\n\");\n\t\tfor (i = 0; i < MAX_SCRATCH_DATA; i++)\n\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%10d (%08x)  \",\n\t\t\t\t\t    header.scratch_debug[i], header.scratch_debug[i]);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"\\n\");\n\t}\n\t \n\tif ((trace_read_buf[0] == 0) && (trace_read_buf[1] == 0)) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"\\t\\tEmpty tracer - exiting\\n\");\n\t\treturn;\n\t}\n\t \n\tif ((limit == point_num - 1) ||\n\t     \n\t    (trace_read_buf[limit + 1] ==\n\t     0))    \n\t\tlimit = 0;\n\t \n\telse\n\t\tlimit++;\n\n\t \n\tfor (i = 0; i < point_num; i++) {\n\t\tj = (limit + i) % point_num;\n\t\tif (trace_read_buf[j]) {\n\t\t\tif (!IS_ISP2401) {\n\t\t\t\tTRACE_DUMP_FORMAT dump_format = FIELD_FORMAT_UNPACK(trace_read_buf[j]);\n\t\t\t} else {\n\t\t\t\ttid_val = FIELD_TID_UNPACK(trace_read_buf[j]);\n\t\t\t\tdump_format = TRACE_DUMP_FORMAT_POINT;\n\n\t\t\t\t \n\t\t\t\tif (tid_val == FIELD_TID_SEL_FORMAT_PAT) {\n\t\t\t\t\tdump_format = FIELD_FORMAT_UNPACK(trace_read_buf[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (dump_format) {\n\t\t\tcase TRACE_DUMP_FORMAT_POINT:\n\t\t\t\tia_css_debug_dtrace(\n\t\t\t\t    IA_CSS_DEBUG_TRACE,\t\"\\t\\t%d %d:%d value - %d\\n\",\n\t\t\t\t    j, FIELD_MAJOR_UNPACK(trace_read_buf[j]),\n\t\t\t\t    FIELD_MINOR_UNPACK(trace_read_buf[j]),\n\t\t\t\t    FIELD_VALUE_UNPACK(trace_read_buf[j]));\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase TRACE_DUMP_FORMAT_VALUE24_HEX:\n\t\t\t\tia_css_debug_dtrace(\n\t\t\t\t    IA_CSS_DEBUG_TRACE,\t\"\\t\\t%d, %d, 24bit value %x H\\n\",\n\t\t\t\t    j,\n\t\t\t\t    FIELD_MAJOR_UNPACK(trace_read_buf[j]),\n\t\t\t\t    FIELD_VALUE_24_UNPACK(trace_read_buf[j]));\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase TRACE_DUMP_FORMAT_VALUE24_DEC:\n\t\t\t\tia_css_debug_dtrace(\n\t\t\t\t    IA_CSS_DEBUG_TRACE,\t\"\\t\\t%d, %d, 24bit value %d D\\n\",\n\t\t\t\t    j,\n\t\t\t\t    FIELD_MAJOR_UNPACK(trace_read_buf[j]),\n\t\t\t\t    FIELD_VALUE_24_UNPACK(trace_read_buf[j]));\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase TRACE_DUMP_FORMAT_POINT_NO_TID:\n\t\t\t\tia_css_debug_dtrace(\n\t\t\t\t    IA_CSS_DEBUG_TRACE,\t\"\\t\\t%d %d:%d value - %x (%d)\\n\",\n\t\t\t\t    j,\n\t\t\t\t    FIELD_MAJOR_W_FMT_UNPACK(trace_read_buf[j]),\n\t\t\t\t    FIELD_MINOR_UNPACK(trace_read_buf[j]),\n\t\t\t\t    FIELD_VALUE_UNPACK(trace_read_buf[j]),\n\t\t\t\t    FIELD_VALUE_UNPACK(trace_read_buf[j]));\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase TRACE_DUMP_FORMAT_VALUE24:\n\t\t\t\tia_css_debug_dtrace(\n\t\t\t\t    IA_CSS_DEBUG_TRACE,\t\"\\t\\t%d, %d, 24bit value %x (%d)\\n\",\n\t\t\t\t    j,\n\t\t\t\t    FIELD_MAJOR_UNPACK(trace_read_buf[j]),\n\t\t\t\t    FIELD_MAJOR_W_FMT_UNPACK(trace_read_buf[j]),\n\t\t\t\t    FIELD_VALUE_24_UNPACK(trace_read_buf[j]),\n\t\t\t\t    FIELD_VALUE_24_UNPACK(trace_read_buf[j]));\n\t\t\t\tbreak;\n\t\t\tcase TRACE_DUMP_FORMAT_VALUE24_TIMING:\n\t\t\t\tia_css_debug_dtrace(\n\t\t\t\t    IA_CSS_DEBUG_TRACE,\t\"\\t\\t%d, %d, timing %x\\n\",\n\t\t\t\t    j,\n\t\t\t\t    FIELD_MAJOR_UNPACK(trace_read_buf[j]),\n\t\t\t\t    FIELD_VALUE_24_UNPACK(trace_read_buf[j]));\n\t\t\t\tbreak;\n\t\t\tcase TRACE_DUMP_FORMAT_VALUE24_TIMING_DELTA:\n\t\t\t\tia_css_debug_dtrace(\n\t\t\t\t    IA_CSS_DEBUG_TRACE,\t\"\\t\\t%d, %d, timing delta %x\\n\",\n\t\t\t\t    j,\n\t\t\t\t    FIELD_MAJOR_UNPACK(trace_read_buf[j]),\n\t\t\t\t    FIELD_VALUE_24_UNPACK(trace_read_buf[j]));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tia_css_debug_dtrace(\n\t\t\t\t    IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"no such trace dump format %d\",\n\t\t\t\t    dump_format);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#else\n\t(void)proc_id;\n#endif  \n}\n#endif  \n\nvoid ia_css_debug_dump_trace(void)\n{\n#if TRACE_ENABLE_SP0\n\tdebug_dump_one_trace(TRACE_SP0_ID);\n#endif\n#if TRACE_ENABLE_SP1\n\tdebug_dump_one_trace(TRACE_SP1_ID);\n#endif\n#if TRACE_ENABLE_ISP\n\tdebug_dump_one_trace(TRACE_ISP_ID);\n#endif\n}\n\n \nvoid ia_css_debug_tagger_state(void)\n{\n\tunsigned int i;\n\tunsigned int HIVE_ADDR_tagger_frames;\n\tia_css_tagger_buf_sp_elem_t tbuf_frames[MAX_CB_ELEMS_FOR_TAGGER];\n\n\tHIVE_ADDR_tagger_frames = sh_css_sp_fw.info.sp.tagger_frames_addr;\n\n\t \n\t(void)HIVE_ADDR_tagger_frames;\n\n\t \n\tsp_dmem_load(SP0_ID,\n\t\t     (unsigned int)sp_address_of(tagger_frames),\n\t\t     tbuf_frames,\n\t\t     sizeof(tbuf_frames));\n\n\tia_css_debug_dtrace(2, \"Tagger Info:\\n\");\n\tfor (i = 0; i < MAX_CB_ELEMS_FOR_TAGGER; i++) {\n\t\tia_css_debug_dtrace(2, \"\\t tagger frame[%d]: exp_id=%d, marked=%d, locked=%d\\n\",\n\t\t\t\t    i, tbuf_frames[i].exp_id, tbuf_frames[i].mark, tbuf_frames[i].lock);\n\t}\n}\n\n \nvoid ia_css_debug_pc_dump(sp_ID_t id, unsigned int num_of_dumps)\n{\n\tunsigned int pc;\n\tunsigned int i;\n\thrt_data sc = sp_ctrl_load(id, SP_SC_REG);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"SP%-1d Status reg: 0x%X\\n\", id, sc);\n\tsc = sp_ctrl_load(id, SP_CTRL_SINK_REG);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"SP%-1d Stall reg: 0x%X\\n\", id, sc);\n\tfor (i = 0; i < num_of_dumps; i++) {\n\t\tpc = sp_ctrl_load(id, SP_PC_REG);\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"SP%-1d PC: 0x%X\\n\", id, pc);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}