{
  "module_name": "frame.c",
  "hash_id": "152dd874f85188b3fea606a985f5685e9e00c684a8e63e7c13436d7caf1d0d7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/runtime/frame/src/frame.c",
  "human_readable_source": "\n \n\n#include \"hmm.h\"\n\n#include \"ia_css_frame.h\"\n#include <math_support.h>\n#include \"assert_support.h\"\n#include \"ia_css_debug.h\"\n#include \"isp.h\"\n#include \"sh_css_internal.h\"\n#include \"atomisp_internal.h\"\n\n#define NV12_TILEY_TILE_WIDTH  128\n#define NV12_TILEY_TILE_HEIGHT  32\n\n \nstatic void frame_init_plane(struct ia_css_frame_plane *plane,\n\t\t\t     unsigned int width,\n\t\t\t     unsigned int stride,\n\t\t\t     unsigned int height,\n\t\t\t     unsigned int offset);\n\nstatic void frame_init_single_plane(struct ia_css_frame *frame,\n\t\t\t\t    struct ia_css_frame_plane *plane,\n\t\t\t\t    unsigned int height,\n\t\t\t\t    unsigned int subpixels_per_line,\n\t\t\t\t    unsigned int bytes_per_pixel);\n\nstatic void frame_init_raw_single_plane(\n    struct ia_css_frame *frame,\n    struct ia_css_frame_plane *plane,\n    unsigned int height,\n    unsigned int subpixels_per_line,\n    unsigned int bits_per_pixel);\n\nstatic void frame_init_nv_planes(struct ia_css_frame *frame,\n\t\t\t\t unsigned int horizontal_decimation,\n\t\t\t\t unsigned int vertical_decimation,\n\t\t\t\t unsigned int bytes_per_element);\n\nstatic void frame_init_yuv_planes(struct ia_css_frame *frame,\n\t\t\t\t  unsigned int horizontal_decimation,\n\t\t\t\t  unsigned int vertical_decimation,\n\t\t\t\t  bool swap_uv,\n\t\t\t\t  unsigned int bytes_per_element);\n\nstatic void frame_init_rgb_planes(struct ia_css_frame *frame,\n\t\t\t\t  unsigned int bytes_per_element);\n\nstatic void frame_init_qplane6_planes(struct ia_css_frame *frame);\n\nstatic int frame_allocate_buffer_data(struct ia_css_frame *frame);\n\nstatic int frame_allocate_with_data(struct ia_css_frame **frame,\n\tunsigned int width,\n\tunsigned int height,\n\tenum ia_css_frame_format format,\n\tunsigned int padded_width,\n\tunsigned int raw_bit_depth);\n\nstatic struct ia_css_frame *frame_create(unsigned int width,\n\tunsigned int height,\n\tenum ia_css_frame_format format,\n\tunsigned int padded_width,\n\tunsigned int raw_bit_depth,\n\tbool valid);\n\nstatic unsigned\nia_css_elems_bytes_from_info(\n    const struct ia_css_frame_info *info);\n\n \n\nint ia_css_frame_allocate_from_info(struct ia_css_frame **frame,\n\tconst struct ia_css_frame_info *info)\n{\n\tint err = 0;\n\n\tif (!frame || !info)\n\t\treturn -EINVAL;\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_frame_allocate_from_info() enter:\\n\");\n\terr =\n\t    ia_css_frame_allocate(frame, info->res.width, info->res.height,\n\t\t\t\t  info->format, info->padded_width,\n\t\t\t\t  info->raw_bit_depth);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_frame_allocate_from_info() leave:\\n\");\n\treturn err;\n}\n\nint ia_css_frame_allocate(struct ia_css_frame **frame,\n\t\t\t\t      unsigned int width,\n\t\t\t\t      unsigned int height,\n\t\t\t\t      enum ia_css_frame_format format,\n\t\t\t\t      unsigned int padded_width,\n\t\t\t\t      unsigned int raw_bit_depth)\n{\n\tint err = 0;\n\n\tif (!frame || width == 0 || height == 0)\n\t\treturn -EINVAL;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_frame_allocate() enter: width=%d, height=%d, format=%d, padded_width=%d, raw_bit_depth=%d\\n\",\n\t\t\t    width, height, format, padded_width, raw_bit_depth);\n\n\terr = frame_allocate_with_data(frame, width, height, format,\n\t\t\t\t       padded_width, raw_bit_depth);\n\n\tif ((*frame) && err == 0)\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"ia_css_frame_allocate() leave: frame=%p, data(DDR address)=0x%x\\n\", *frame,\n\t\t\t\t    (*frame)->data);\n\telse\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"ia_css_frame_allocate() leave: frame=%p, data(DDR address)=0x%x\\n\",\n\t\t\t\t    (void *)-1, (unsigned int)-1);\n\n\treturn err;\n}\n\nvoid ia_css_frame_free(struct ia_css_frame *frame)\n{\n\tIA_CSS_ENTER_PRIVATE(\"frame = %p\", frame);\n\n\tif (frame) {\n\t\thmm_free(frame->data);\n\t\tkvfree(frame);\n\t}\n\n\tIA_CSS_LEAVE_PRIVATE(\"void\");\n}\n\n \n\nint ia_css_frame_check_info(const struct ia_css_frame_info *info)\n{\n\tassert(info);\n\tif (info->res.width == 0 || info->res.height == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nint ia_css_frame_init_planes(struct ia_css_frame *frame)\n{\n\tassert(frame);\n\n\tswitch (frame->frame_info.format) {\n\tcase IA_CSS_FRAME_FORMAT_MIPI:\n\t\tdev_err(atomisp_dev,\n\t\t\t\"%s: unexpected use of IA_CSS_FRAME_FORMAT_MIPI\\n\", __func__);\n\t\treturn -EINVAL;\n\tcase IA_CSS_FRAME_FORMAT_RAW_PACKED:\n\t\tframe_init_raw_single_plane(frame, &frame->planes.raw,\n\t\t\t\t\t    frame->frame_info.res.height,\n\t\t\t\t\t    frame->frame_info.padded_width,\n\t\t\t\t\t    frame->frame_info.raw_bit_depth);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_RAW:\n\t\tframe_init_single_plane(frame, &frame->planes.raw,\n\t\t\t\t\tframe->frame_info.res.height,\n\t\t\t\t\tframe->frame_info.padded_width,\n\t\t\t\t\tframe->frame_info.raw_bit_depth <= 8 ? 1 : 2);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_RGB565:\n\t\tframe_init_single_plane(frame, &frame->planes.rgb,\n\t\t\t\t\tframe->frame_info.res.height,\n\t\t\t\t\tframe->frame_info.padded_width, 2);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_RGBA888:\n\t\tframe_init_single_plane(frame, &frame->planes.rgb,\n\t\t\t\t\tframe->frame_info.res.height,\n\t\t\t\t\tframe->frame_info.padded_width * 4, 1);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_PLANAR_RGB888:\n\t\tframe_init_rgb_planes(frame, 1);\n\t\tbreak;\n\t \n\tcase IA_CSS_FRAME_FORMAT_YUYV:\n\tcase IA_CSS_FRAME_FORMAT_UYVY:\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8:\n\t\tframe_init_single_plane(frame, &frame->planes.yuyv,\n\t\t\t\t\tframe->frame_info.res.height,\n\t\t\t\t\tframe->frame_info.padded_width * 2, 1);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_YUV_LINE:\n\t\t \n\t\tframe_init_single_plane(frame, &frame->planes.yuyv,\n\t\t\t\t\tframe->frame_info.res.height * 3 / 2 + 3,\n\t\t\t\t\tframe->frame_info.padded_width, 1);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_NV11:\n\t\tframe_init_nv_planes(frame, 4, 1, 1);\n\t\tbreak;\n\t \n\tcase IA_CSS_FRAME_FORMAT_NV12:\n\tcase IA_CSS_FRAME_FORMAT_NV21:\n\tcase IA_CSS_FRAME_FORMAT_NV12_TILEY:\n\t\tframe_init_nv_planes(frame, 2, 2, 1);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_NV12_16:\n\t\tframe_init_nv_planes(frame, 2, 2, 2);\n\t\tbreak;\n\t \n\tcase IA_CSS_FRAME_FORMAT_NV16:\n\tcase IA_CSS_FRAME_FORMAT_NV61:\n\t\tframe_init_nv_planes(frame, 2, 1, 1);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_YUV420:\n\t\tframe_init_yuv_planes(frame, 2, 2, false, 1);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_YUV422:\n\t\tframe_init_yuv_planes(frame, 2, 1, false, 1);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_YUV444:\n\t\tframe_init_yuv_planes(frame, 1, 1, false, 1);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_YUV420_16:\n\t\tframe_init_yuv_planes(frame, 2, 2, false, 2);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_YUV422_16:\n\t\tframe_init_yuv_planes(frame, 2, 1, false, 2);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_YV12:\n\t\tframe_init_yuv_planes(frame, 2, 2, true, 1);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_YV16:\n\t\tframe_init_yuv_planes(frame, 2, 1, true, 1);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_QPLANE6:\n\t\tframe_init_qplane6_planes(frame);\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_BINARY_8:\n\t\tframe_init_single_plane(frame, &frame->planes.binary.data,\n\t\t\t\t\tframe->frame_info.res.height,\n\t\t\t\t\tframe->frame_info.padded_width, 1);\n\t\tframe->planes.binary.size = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nunsigned int ia_css_frame_pad_width(unsigned int width, enum ia_css_frame_format format)\n{\n\tswitch (format) {\n\t \n\tcase IA_CSS_FRAME_FORMAT_YUV420:\n\tcase IA_CSS_FRAME_FORMAT_YV12:\n\tcase IA_CSS_FRAME_FORMAT_NV12:\n\tcase IA_CSS_FRAME_FORMAT_NV21:\n\tcase IA_CSS_FRAME_FORMAT_BINARY_8:\n\tcase IA_CSS_FRAME_FORMAT_YUV_LINE:\n\t\treturn CEIL_MUL(width, 2 * HIVE_ISP_DDR_WORD_BYTES);\n\n\tcase IA_CSS_FRAME_FORMAT_NV12_TILEY:\n\t\treturn CEIL_MUL(width, NV12_TILEY_TILE_WIDTH);\n\n\tcase IA_CSS_FRAME_FORMAT_RAW:\n\tcase IA_CSS_FRAME_FORMAT_RAW_PACKED:\n\t\treturn CEIL_MUL(width, 2 * ISP_VEC_NELEMS);\n\n\tdefault:\n\t\treturn CEIL_MUL(width, HIVE_ISP_DDR_WORD_BYTES);\n\t}\n}\n\nvoid ia_css_frame_info_set_width(struct ia_css_frame_info *info,\n\t\t\t\t unsigned int width,\n\t\t\t\t unsigned int min_padded_width)\n{\n\tunsigned int align;\n\n\tIA_CSS_ENTER_PRIVATE(\"info = %p,width = %d, minimum padded width = %d\",\n\t\t\t     info, width, min_padded_width);\n\tif (!info) {\n\t\tIA_CSS_ERROR(\"NULL input parameter\");\n\t\tIA_CSS_LEAVE_PRIVATE(\"\");\n\t\treturn;\n\t}\n\talign = max(min_padded_width, width);\n\n\tinfo->res.width = width;\n\tinfo->padded_width = ia_css_frame_pad_width(align, info->format);\n\n\tIA_CSS_LEAVE_PRIVATE(\"\");\n}\n\nvoid ia_css_frame_info_set_format(struct ia_css_frame_info *info,\n\t\t\t\t  enum ia_css_frame_format format)\n{\n\tassert(info);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_frame_info_set_format() enter:\\n\");\n\tinfo->format = format;\n}\n\nvoid ia_css_frame_info_init(struct ia_css_frame_info *info,\n\t\t\t    unsigned int width,\n\t\t\t    unsigned int height,\n\t\t\t    enum ia_css_frame_format format,\n\t\t\t    unsigned int aligned)\n{\n\tIA_CSS_ENTER_PRIVATE(\"info = %p, width = %d, height = %d, format = %d, aligned = %d\",\n\t\t\t     info, width, height, format, aligned);\n\tif (!info) {\n\t\tIA_CSS_ERROR(\"NULL input parameter\");\n\t\tIA_CSS_LEAVE_PRIVATE(\"\");\n\t\treturn;\n\t}\n\tinfo->res.height = height;\n\tinfo->format     = format;\n\tia_css_frame_info_set_width(info, width, aligned);\n\tIA_CSS_LEAVE_PRIVATE(\"\");\n}\n\nvoid ia_css_frame_free_multiple(unsigned int num_frames,\n\t\t\t\tstruct ia_css_frame **frames_array)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num_frames; i++) {\n\t\tif (frames_array[i]) {\n\t\t\tia_css_frame_free(frames_array[i]);\n\t\t\tframes_array[i] = NULL;\n\t\t}\n\t}\n}\n\nint ia_css_frame_allocate_with_buffer_size(struct ia_css_frame **frame,\n\t\t\t\t\t   const unsigned int buffer_size_bytes)\n{\n\t \n\tint err;\n\tstruct ia_css_frame *me = frame_create(0, 0,\n\t\t\t\t\t       IA_CSS_FRAME_FORMAT_NUM, \n\t\t\t\t\t       0, 0, false);\n\n\tif (!me)\n\t\treturn -ENOMEM;\n\n\t \n\tme->data_bytes = buffer_size_bytes;\n\n\terr = frame_allocate_buffer_data(me);\n\n\tif (err) {\n\t\tkvfree(me);\n\t\tme = NULL;\n\t}\n\n\t*frame = me;\n\n\treturn err;\n}\n\nbool ia_css_frame_info_is_same_resolution(\n    const struct ia_css_frame_info *info_a,\n    const struct ia_css_frame_info *info_b)\n{\n\tif (!info_a || !info_b)\n\t\treturn false;\n\treturn (info_a->res.width == info_b->res.width) &&\n\t       (info_a->res.height == info_b->res.height);\n}\n\nbool ia_css_frame_is_same_type(const struct ia_css_frame *frame_a,\n\t\t\t       const struct ia_css_frame *frame_b)\n{\n\tbool is_equal = false;\n\tconst struct ia_css_frame_info *info_a = &frame_a->frame_info;\n\tconst struct ia_css_frame_info *info_b = &frame_b->frame_info;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_frame_is_same_type() enter:\\n\");\n\n\tif (!info_a || !info_b)\n\t\treturn false;\n\tif (info_a->format != info_b->format)\n\t\treturn false;\n\tif (info_a->padded_width != info_b->padded_width)\n\t\treturn false;\n\tis_equal = ia_css_frame_info_is_same_resolution(info_a, info_b);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_frame_is_same_type() leave:\\n\");\n\n\treturn is_equal;\n}\n\nint ia_css_dma_configure_from_info(struct dma_port_config *config,\n\t\t\t\t   const struct ia_css_frame_info *info)\n{\n\tunsigned int is_raw_packed = info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED;\n\tunsigned int bits_per_pixel = is_raw_packed ? info->raw_bit_depth :\n\t\t\t\t      ia_css_elems_bytes_from_info(info) * 8;\n\tunsigned int pix_per_ddrword = HIVE_ISP_DDR_WORD_BITS / bits_per_pixel;\n\tunsigned int words_per_line = CEIL_DIV(info->padded_width, pix_per_ddrword);\n\tunsigned int elems_b = pix_per_ddrword;\n\n\tconfig->stride = HIVE_ISP_DDR_WORD_BYTES * words_per_line;\n\tconfig->elems  = (uint8_t)elems_b;\n\tconfig->width  = (uint16_t)info->res.width;\n\tconfig->crop   = 0;\n\n\tif (config->width > info->padded_width) {\n\t\tdev_err(atomisp_dev, \"internal error: padded_width is too small!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void frame_init_plane(struct ia_css_frame_plane *plane,\n\t\t\t     unsigned int width,\n\t\t\t     unsigned int stride,\n\t\t\t     unsigned int height,\n\t\t\t     unsigned int offset)\n{\n\tplane->height = height;\n\tplane->width = width;\n\tplane->stride = stride;\n\tplane->offset = offset;\n}\n\nstatic void frame_init_single_plane(struct ia_css_frame *frame,\n\t\t\t\t    struct ia_css_frame_plane *plane,\n\t\t\t\t    unsigned int height,\n\t\t\t\t    unsigned int subpixels_per_line,\n\t\t\t\t    unsigned int bytes_per_pixel)\n{\n\tunsigned int stride;\n\n\tstride = subpixels_per_line * bytes_per_pixel;\n\t \n\tframe->data_bytes = stride * CEIL_MUL2(height, 2);\n\tframe_init_plane(plane, subpixels_per_line, stride, height, 0);\n\treturn;\n}\n\nstatic void frame_init_raw_single_plane(\n    struct ia_css_frame *frame,\n    struct ia_css_frame_plane *plane,\n    unsigned int height,\n    unsigned int subpixels_per_line,\n    unsigned int bits_per_pixel)\n{\n\tunsigned int stride;\n\n\tassert(frame);\n\n\tstride = HIVE_ISP_DDR_WORD_BYTES *\n\t\t CEIL_DIV(subpixels_per_line,\n\t\t\t  HIVE_ISP_DDR_WORD_BITS / bits_per_pixel);\n\tframe->data_bytes = stride * height;\n\tframe_init_plane(plane, subpixels_per_line, stride, height, 0);\n\treturn;\n}\n\nstatic void frame_init_nv_planes(struct ia_css_frame *frame,\n\t\t\t\t unsigned int horizontal_decimation,\n\t\t\t\t unsigned int vertical_decimation,\n\t\t\t\t unsigned int bytes_per_element)\n{\n\tunsigned int y_width = frame->frame_info.padded_width;\n\tunsigned int y_height = frame->frame_info.res.height;\n\tunsigned int uv_width;\n\tunsigned int uv_height;\n\tunsigned int y_bytes;\n\tunsigned int uv_bytes;\n\tunsigned int y_stride;\n\tunsigned int uv_stride;\n\n\tassert(horizontal_decimation != 0 && vertical_decimation != 0);\n\n\tuv_width = 2 * (y_width / horizontal_decimation);\n\tuv_height = y_height / vertical_decimation;\n\n\tif (frame->frame_info.format == IA_CSS_FRAME_FORMAT_NV12_TILEY) {\n\t\ty_width   = CEIL_MUL(y_width,   NV12_TILEY_TILE_WIDTH);\n\t\tuv_width  = CEIL_MUL(uv_width,  NV12_TILEY_TILE_WIDTH);\n\t\ty_height  = CEIL_MUL(y_height,  NV12_TILEY_TILE_HEIGHT);\n\t\tuv_height = CEIL_MUL(uv_height, NV12_TILEY_TILE_HEIGHT);\n\t}\n\n\ty_stride = y_width * bytes_per_element;\n\tuv_stride = uv_width * bytes_per_element;\n\ty_bytes = y_stride * y_height;\n\tuv_bytes = uv_stride * uv_height;\n\n\tframe->data_bytes = y_bytes + uv_bytes;\n\tframe_init_plane(&frame->planes.nv.y, y_width, y_stride, y_height, 0);\n\tframe_init_plane(&frame->planes.nv.uv, uv_width,\n\t\t\t uv_stride, uv_height, y_bytes);\n\treturn;\n}\n\nstatic void frame_init_yuv_planes(struct ia_css_frame *frame,\n\t\t\t\t  unsigned int horizontal_decimation,\n\t\t\t\t  unsigned int vertical_decimation,\n\t\t\t\t  bool swap_uv,\n\t\t\t\t  unsigned int bytes_per_element)\n{\n\tunsigned int y_width = frame->frame_info.padded_width,\n\t\t     y_height = frame->frame_info.res.height,\n\t\t     uv_width = y_width / horizontal_decimation,\n\t\t     uv_height = y_height / vertical_decimation,\n\t\t     y_stride, y_bytes, uv_bytes, uv_stride;\n\n\ty_stride = y_width * bytes_per_element;\n\tuv_stride = uv_width * bytes_per_element;\n\ty_bytes = y_stride * y_height;\n\tuv_bytes = uv_stride * uv_height;\n\n\tframe->data_bytes = y_bytes + 2 * uv_bytes;\n\tframe_init_plane(&frame->planes.yuv.y, y_width, y_stride, y_height, 0);\n\tif (swap_uv) {\n\t\tframe_init_plane(&frame->planes.yuv.v, uv_width, uv_stride,\n\t\t\t\t uv_height, y_bytes);\n\t\tframe_init_plane(&frame->planes.yuv.u, uv_width, uv_stride,\n\t\t\t\t uv_height, y_bytes + uv_bytes);\n\t} else {\n\t\tframe_init_plane(&frame->planes.yuv.u, uv_width, uv_stride,\n\t\t\t\t uv_height, y_bytes);\n\t\tframe_init_plane(&frame->planes.yuv.v, uv_width, uv_stride,\n\t\t\t\t uv_height, y_bytes + uv_bytes);\n\t}\n\treturn;\n}\n\nstatic void frame_init_rgb_planes(struct ia_css_frame *frame,\n\t\t\t\t  unsigned int bytes_per_element)\n{\n\tunsigned int width = frame->frame_info.res.width,\n\t\t     height = frame->frame_info.res.height, stride, bytes;\n\n\tstride = width * bytes_per_element;\n\tbytes = stride * height;\n\tframe->data_bytes = 3 * bytes;\n\tframe_init_plane(&frame->planes.planar_rgb.r, width, stride, height, 0);\n\tframe_init_plane(&frame->planes.planar_rgb.g,\n\t\t\t width, stride, height, 1 * bytes);\n\tframe_init_plane(&frame->planes.planar_rgb.b,\n\t\t\t width, stride, height, 2 * bytes);\n\treturn;\n}\n\nstatic void frame_init_qplane6_planes(struct ia_css_frame *frame)\n{\n\tunsigned int width = frame->frame_info.padded_width / 2,\n\t\t     height = frame->frame_info.res.height / 2, bytes, stride;\n\n\tstride = width * 2;\n\tbytes = stride * height;\n\n\tframe->data_bytes = 6 * bytes;\n\tframe_init_plane(&frame->planes.plane6.r,\n\t\t\t width, stride, height, 0 * bytes);\n\tframe_init_plane(&frame->planes.plane6.r_at_b,\n\t\t\t width, stride, height, 1 * bytes);\n\tframe_init_plane(&frame->planes.plane6.gr,\n\t\t\t width, stride, height, 2 * bytes);\n\tframe_init_plane(&frame->planes.plane6.gb,\n\t\t\t width, stride, height, 3 * bytes);\n\tframe_init_plane(&frame->planes.plane6.b,\n\t\t\t width, stride, height, 4 * bytes);\n\tframe_init_plane(&frame->planes.plane6.b_at_r,\n\t\t\t width, stride, height, 5 * bytes);\n\treturn;\n}\n\nstatic int frame_allocate_buffer_data(struct ia_css_frame *frame)\n{\n\tframe->data = hmm_alloc(frame->data_bytes);\n\tif (frame->data == mmgr_NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int frame_allocate_with_data(struct ia_css_frame **frame,\n\tunsigned int width,\n\tunsigned int height,\n\tenum ia_css_frame_format format,\n\tunsigned int padded_width,\n\tunsigned int raw_bit_depth)\n{\n\tint err;\n\tstruct ia_css_frame *me = frame_create(width,\n\t\t\t\t\t       height,\n\t\t\t\t\t       format,\n\t\t\t\t\t       padded_width,\n\t\t\t\t\t       raw_bit_depth,\n\t\t\t\t\t       true);\n\n\tif (!me)\n\t\treturn -ENOMEM;\n\n\terr = ia_css_frame_init_planes(me);\n\n\tif (!err)\n\t\terr = frame_allocate_buffer_data(me);\n\n\tif (err) {\n\t\tkvfree(me);\n\t\t*frame = NULL;\n\t} else {\n\t\t*frame = me;\n\t}\n\n\treturn err;\n}\n\nstatic struct ia_css_frame *frame_create(unsigned int width,\n\tunsigned int height,\n\tenum ia_css_frame_format format,\n\tunsigned int padded_width,\n\tunsigned int raw_bit_depth,\n\tbool valid)\n{\n\tstruct ia_css_frame *me = kvmalloc(sizeof(*me), GFP_KERNEL);\n\n\tif (!me)\n\t\treturn NULL;\n\n\tmemset(me, 0, sizeof(*me));\n\tme->frame_info.res.width = width;\n\tme->frame_info.res.height = height;\n\tme->frame_info.format = format;\n\tme->frame_info.padded_width = padded_width;\n\tme->frame_info.raw_bit_depth = raw_bit_depth;\n\tme->valid = valid;\n\tme->data_bytes = 0;\n\tme->data = mmgr_NULL;\n\t \n\tme->dynamic_queue_id = (int)SH_CSS_INVALID_QUEUE_ID;\n\tme->buf_type = IA_CSS_BUFFER_TYPE_INVALID;\n\n\treturn me;\n}\n\nstatic unsigned\nia_css_elems_bytes_from_info(const struct ia_css_frame_info *info)\n{\n\tif (info->format == IA_CSS_FRAME_FORMAT_RGB565)\n\t\treturn 2;  \n\tif (info->format == IA_CSS_FRAME_FORMAT_YUV420_16)\n\t\treturn 2;  \n\tif (info->format == IA_CSS_FRAME_FORMAT_YUV422_16)\n\t\treturn 2;  \n\t \n\tif (info->format == IA_CSS_FRAME_FORMAT_NV12_16)\n\t\treturn 1;  \n\n\tif (info->format == IA_CSS_FRAME_FORMAT_RAW\n\t    || (info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED)) {\n\t\tif (info->raw_bit_depth)\n\t\t\treturn CEIL_DIV(info->raw_bit_depth, 8);\n\t\telse\n\t\t\treturn 2;  \n\t}\n\tif (info->format == IA_CSS_FRAME_FORMAT_PLANAR_RGB888)\n\t\treturn 3;  \n\tif (info->format == IA_CSS_FRAME_FORMAT_RGBA888)\n\t\treturn 4;  \n\tif (info->format == IA_CSS_FRAME_FORMAT_QPLANE6)\n\t\treturn 2;  \n\treturn 1;  \n}\n\nvoid ia_css_frame_info_to_frame_sp_info(\n    struct ia_css_frame_sp_info *to,\n    const struct ia_css_frame_info *from)\n{\n\tia_css_resolution_to_sp_resolution(&to->res, &from->res);\n\tto->padded_width = (uint16_t)from->padded_width;\n\tto->format = (uint8_t)from->format;\n\tto->raw_bit_depth = (uint8_t)from->raw_bit_depth;\n\tto->raw_bayer_order = from->raw_bayer_order;\n}\n\nvoid ia_css_resolution_to_sp_resolution(\n    struct ia_css_sp_resolution *to,\n    const struct ia_css_resolution *from)\n{\n\tto->width  = (uint16_t)from->width;\n\tto->height = (uint16_t)from->height;\n}\n\nint ia_css_frame_init_from_info(struct ia_css_frame *frame,\n\t\t\t\tconst struct ia_css_frame_info *frame_info)\n{\n\tframe->frame_info.res.width = frame_info->res.width;\n\tframe->frame_info.res.height = frame_info->res.height;\n\tframe->frame_info.format = frame_info->format;\n\tframe->frame_info.padded_width = frame_info->padded_width;\n\tframe->frame_info.raw_bit_depth = frame_info->raw_bit_depth;\n\tframe->valid = true;\n\t \n\tframe->dynamic_queue_id = SH_CSS_INVALID_QUEUE_ID;\n\tframe->buf_type = IA_CSS_BUFFER_TYPE_INVALID;\n\n\treturn ia_css_frame_init_planes(frame);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}