{
  "module_name": "pipeline.c",
  "hash_id": "4c0ead1fa6f9a46ed18d52f336c2169aeef68e58ff1978e438e92f9425c0529e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/runtime/pipeline/src/pipeline.c",
  "human_readable_source": "\n \n\n#include \"hmm.h\"\n\n#include \"ia_css_debug.h\"\n#include \"sw_event_global.h\"\t\t \n#include \"sp.h\"\t\t\t \n#include \"assert_support.h\"\n#include \"sh_css_sp.h\"\n#include \"ia_css_pipeline.h\"\n#include \"ia_css_isp_param.h\"\n#include \"ia_css_bufq.h\"\n\n#define PIPELINE_NUM_UNMAPPED                   (~0U)\n#define PIPELINE_SP_THREAD_EMPTY_TOKEN          (0x0)\n#define PIPELINE_SP_THREAD_RESERVED_TOKEN       (0x1)\n\n \nstatic unsigned int pipeline_num_to_sp_thread_map[IA_CSS_PIPELINE_NUM_MAX];\nstatic unsigned int pipeline_sp_thread_list[SH_CSS_MAX_SP_THREADS];\n\n \nstatic void pipeline_init_sp_thread_map(void);\nstatic void pipeline_map_num_to_sp_thread(unsigned int pipe_num);\nstatic void pipeline_unmap_num_to_sp_thread(unsigned int pipe_num);\nstatic void pipeline_init_defaults(\n    struct ia_css_pipeline *pipeline,\n    enum ia_css_pipe_id pipe_id,\n    unsigned int pipe_num,\n    unsigned int dvs_frame_delay);\n\nstatic void pipeline_stage_destroy(struct ia_css_pipeline_stage *stage);\nstatic int pipeline_stage_create(\n    struct ia_css_pipeline_stage_desc *stage_desc,\n    struct ia_css_pipeline_stage **new_stage);\nstatic void ia_css_pipeline_set_zoom_stage(struct ia_css_pipeline *pipeline);\nstatic void ia_css_pipeline_configure_inout_port(struct ia_css_pipeline *me,\n\tbool continuous);\n\n \nvoid ia_css_pipeline_init(void)\n{\n\tpipeline_init_sp_thread_map();\n}\n\nint ia_css_pipeline_create(\n    struct ia_css_pipeline *pipeline,\n    enum ia_css_pipe_id pipe_id,\n    unsigned int pipe_num,\n    unsigned int dvs_frame_delay)\n{\n\tassert(pipeline);\n\tIA_CSS_ENTER_PRIVATE(\"pipeline = %p, pipe_id = %d, pipe_num = %d, dvs_frame_delay = %d\",\n\t\t\t     pipeline, pipe_id, pipe_num, dvs_frame_delay);\n\tif (!pipeline) {\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tpipeline_init_defaults(pipeline, pipe_id, pipe_num, dvs_frame_delay);\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\treturn 0;\n}\n\nvoid ia_css_pipeline_map(unsigned int pipe_num, bool map)\n{\n\tassert(pipe_num < IA_CSS_PIPELINE_NUM_MAX);\n\tIA_CSS_ENTER_PRIVATE(\"pipe_num = %d, map = %d\", pipe_num, map);\n\n\tif (pipe_num >= IA_CSS_PIPELINE_NUM_MAX) {\n\t\tIA_CSS_ERROR(\"Invalid pipe number\");\n\t\tIA_CSS_LEAVE_PRIVATE(\"void\");\n\t\treturn;\n\t}\n\tif (map)\n\t\tpipeline_map_num_to_sp_thread(pipe_num);\n\telse\n\t\tpipeline_unmap_num_to_sp_thread(pipe_num);\n\tIA_CSS_LEAVE_PRIVATE(\"void\");\n}\n\n \nvoid ia_css_pipeline_destroy(struct ia_css_pipeline *pipeline)\n{\n\tassert(pipeline);\n\tIA_CSS_ENTER_PRIVATE(\"pipeline = %p\", pipeline);\n\n\tif (!pipeline) {\n\t\tIA_CSS_ERROR(\"NULL input parameter\");\n\t\tIA_CSS_LEAVE_PRIVATE(\"void\");\n\t\treturn;\n\t}\n\n\tIA_CSS_LOG(\"pipe_num = %d\", pipeline->pipe_num);\n\n\t \n\tia_css_pipeline_clean(pipeline);\n\n\tIA_CSS_LEAVE_PRIVATE(\"void\");\n}\n\n \nvoid ia_css_pipeline_start(enum ia_css_pipe_id pipe_id,\n\t\t\t   struct ia_css_pipeline *pipeline)\n{\n\tu8 pipe_num = 0;\n\tunsigned int thread_id;\n\n\tassert(pipeline);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_pipeline_start() enter: pipe_id=%d, pipeline=%p\\n\",\n\t\t\t    pipe_id, pipeline);\n\tpipeline->pipe_id = pipe_id;\n\tsh_css_sp_init_pipeline(pipeline, pipe_id, pipe_num,\n\t\t\t\tfalse, false, false, true, SH_CSS_BDS_FACTOR_1_00,\n\t\t\t\tSH_CSS_PIPE_CONFIG_OVRD_NO_OVRD,\n\t\t\t\tIA_CSS_INPUT_MODE_MEMORY, NULL, NULL,\n\t\t\t\t(enum mipi_port_id)0);\n\n\tia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\n\tif (!sh_css_sp_is_running()) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"ia_css_pipeline_start() error,leaving\\n\");\n\t\t \n\t\treturn;\n\t}\n\tia_css_bufq_enqueue_psys_event(IA_CSS_PSYS_SW_EVENT_START_STREAM,\n\t\t\t\t       (uint8_t)thread_id,\n\t\t\t\t       0,\n\t\t\t\t       0);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_pipeline_start() leave: return_void\\n\");\n}\n\n \nbool ia_css_pipeline_get_sp_thread_id(unsigned int key, unsigned int *val)\n{\n\tIA_CSS_ENTER(\"key=%d, val=%p\", key, val);\n\n\tif ((!val) || (key >= IA_CSS_PIPELINE_NUM_MAX) || (key >= IA_CSS_PIPE_ID_NUM)) {\n\t\tIA_CSS_LEAVE(\"return value = false\");\n\t\treturn false;\n\t}\n\n\t*val = pipeline_num_to_sp_thread_map[key];\n\n\tif (*val == (unsigned int)PIPELINE_NUM_UNMAPPED) {\n\t\tIA_CSS_LOG(\"unmapped pipeline number\");\n\t\tIA_CSS_LEAVE(\"return value = false\");\n\t\treturn false;\n\t}\n\tIA_CSS_LEAVE(\"return value = true\");\n\treturn true;\n}\n\nvoid ia_css_pipeline_dump_thread_map_info(void)\n{\n\tunsigned int i;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"pipeline_num_to_sp_thread_map:\\n\");\n\tfor (i = 0; i < IA_CSS_PIPELINE_NUM_MAX; i++) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"pipe_num: %u, tid: 0x%x\\n\", i, pipeline_num_to_sp_thread_map[i]);\n\t}\n}\n\nint ia_css_pipeline_request_stop(struct ia_css_pipeline *pipeline)\n{\n\tint err = 0;\n\tunsigned int thread_id;\n\n\tassert(pipeline);\n\n\tif (!pipeline)\n\t\treturn -EINVAL;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_pipeline_request_stop() enter: pipeline=%p\\n\",\n\t\t\t    pipeline);\n\tpipeline->stop_requested = true;\n\n\t \n\t \n\tia_css_pipeline_get_sp_thread_id(pipeline->pipe_num, &thread_id);\n\tif (!sh_css_sp_is_running()) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"ia_css_pipeline_request_stop() leaving\\n\");\n\t\t \n\t\treturn -EBUSY;\n\t}\n\tia_css_bufq_enqueue_psys_event(IA_CSS_PSYS_SW_EVENT_STOP_STREAM,\n\t\t\t\t       (uint8_t)thread_id,\n\t\t\t\t       0,\n\t\t\t\t       0);\n\tsh_css_sp_uninit_pipeline(pipeline->pipe_num);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_pipeline_request_stop() leave: return_err=%d\\n\",\n\t\t\t    err);\n\treturn err;\n}\n\nvoid ia_css_pipeline_clean(struct ia_css_pipeline *pipeline)\n{\n\tstruct ia_css_pipeline_stage *s;\n\n\tassert(pipeline);\n\tIA_CSS_ENTER_PRIVATE(\"pipeline = %p\", pipeline);\n\n\tif (!pipeline) {\n\t\tIA_CSS_ERROR(\"NULL input parameter\");\n\t\tIA_CSS_LEAVE_PRIVATE(\"void\");\n\t\treturn;\n\t}\n\ts = pipeline->stages;\n\n\twhile (s) {\n\t\tstruct ia_css_pipeline_stage *next = s->next;\n\n\t\tpipeline_stage_destroy(s);\n\t\ts = next;\n\t}\n\tpipeline_init_defaults(pipeline, pipeline->pipe_id, pipeline->pipe_num,\n\t\t\t       pipeline->dvs_frame_delay);\n\n\tIA_CSS_LEAVE_PRIVATE(\"void\");\n}\n\n \nint ia_css_pipeline_create_and_add_stage(\n    struct ia_css_pipeline *pipeline,\n    struct ia_css_pipeline_stage_desc *stage_desc,\n    struct ia_css_pipeline_stage **stage)\n{\n\tstruct ia_css_pipeline_stage *last, *new_stage = NULL;\n\tint err;\n\n\t \n\tassert(pipeline);\n\tassert(stage_desc);\n\tlast = pipeline->stages;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_pipeline_create_and_add_stage() enter:\\n\");\n\tif (!stage_desc->binary && !stage_desc->firmware\n\t    && (stage_desc->sp_func == IA_CSS_PIPELINE_NO_FUNC)) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"ia_css_pipeline_create_and_add_stage() done: Invalid args\\n\");\n\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twhile (last && last->next)\n\t\tlast = last->next;\n\n\t \n\tif ((stage_desc->sp_func == IA_CSS_PIPELINE_NO_FUNC)\n\t    && (!stage_desc->in_frame)\n\t    && (!stage_desc->firmware)\n\t    && (!stage_desc->binary->online)) {\n\t\t \n\t\tif (last && last->args.out_frame[0])\n\t\t\tstage_desc->in_frame = last->args.out_frame[0];\n\n\t\tif (!stage_desc->in_frame)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = pipeline_stage_create(stage_desc, &new_stage);\n\tif (err) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t    \"ia_css_pipeline_create_and_add_stage() done: stage_create_failed\\n\");\n\t\treturn err;\n\t}\n\n\tif (last)\n\t\tlast->next = new_stage;\n\telse\n\t\tpipeline->stages = new_stage;\n\n\t \n\tif (stage)\n\t\t*stage = new_stage;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_pipeline_create_and_add_stage() done:\\n\");\n\treturn 0;\n}\n\nvoid ia_css_pipeline_finalize_stages(struct ia_css_pipeline *pipeline,\n\t\t\t\t     bool continuous)\n{\n\tunsigned int i = 0;\n\tstruct ia_css_pipeline_stage *stage;\n\n\tassert(pipeline);\n\tfor (stage = pipeline->stages; stage; stage = stage->next) {\n\t\tstage->stage_num = i;\n\t\ti++;\n\t}\n\tpipeline->num_stages = i;\n\n\tia_css_pipeline_set_zoom_stage(pipeline);\n\tia_css_pipeline_configure_inout_port(pipeline, continuous);\n}\n\nint ia_css_pipeline_get_stage(struct ia_css_pipeline *pipeline,\n\tint mode,\n\tstruct ia_css_pipeline_stage **stage)\n{\n\tstruct ia_css_pipeline_stage *s;\n\n\tassert(pipeline);\n\tassert(stage);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_pipeline_get_stage() enter:\\n\");\n\tfor (s = pipeline->stages; s; s = s->next) {\n\t\tif (s->mode == mode) {\n\t\t\t*stage = s;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nint ia_css_pipeline_get_stage_from_fw(struct ia_css_pipeline\n\t*pipeline,\n\tu32 fw_handle,\n\tstruct ia_css_pipeline_stage **stage)\n{\n\tstruct ia_css_pipeline_stage *s;\n\n\tassert(pipeline);\n\tassert(stage);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%s()\\n\", __func__);\n\tfor (s = pipeline->stages; s; s = s->next) {\n\t\tif ((s->firmware) && (s->firmware->handle == fw_handle)) {\n\t\t\t*stage = s;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nint ia_css_pipeline_get_fw_from_stage(struct ia_css_pipeline\n\t*pipeline,\n\tu32 stage_num,\n\tuint32_t *fw_handle)\n{\n\tstruct ia_css_pipeline_stage *s;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%s()\\n\", __func__);\n\tif ((!pipeline) || (!fw_handle))\n\t\treturn -EINVAL;\n\n\tfor (s = pipeline->stages; s; s = s->next) {\n\t\tif ((s->stage_num == stage_num) && (s->firmware)) {\n\t\t\t*fw_handle = s->firmware->handle;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nint ia_css_pipeline_get_output_stage(\n    struct ia_css_pipeline *pipeline,\n    int mode,\n    struct ia_css_pipeline_stage **stage)\n{\n\tstruct ia_css_pipeline_stage *s;\n\n\tassert(pipeline);\n\tassert(stage);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_pipeline_get_output_stage() enter:\\n\");\n\n\t*stage = NULL;\n\t \n\tfor (s = pipeline->stages; s; s = s->next) {\n\t\tif (s->firmware && s->mode == mode &&\n\t\t    s->firmware->info.isp.sp.enable.output)\n\t\t\t*stage = s;\n\t}\n\tif (*stage)\n\t\treturn 0;\n\t \n\treturn ia_css_pipeline_get_stage(pipeline, mode, stage);\n}\n\nbool ia_css_pipeline_has_stopped(struct ia_css_pipeline *pipeline)\n{\n\t \n\tstatic struct sh_css_sp_group sp_group;\n\tunsigned int thread_id;\n\tconst struct ia_css_fw_info *fw;\n\tunsigned int HIVE_ADDR_sp_group;\n\n\tfw = &sh_css_sp_fw;\n\tHIVE_ADDR_sp_group = fw->info.sp.group;\n\n\tia_css_pipeline_get_sp_thread_id(pipeline->pipe_num, &thread_id);\n\tsp_dmem_load(SP0_ID,\n\t\t     (unsigned int)sp_address_of(sp_group),\n\t\t     &sp_group, sizeof(struct sh_css_sp_group));\n\treturn sp_group.pipe[thread_id].num_stages == 0;\n}\n\n#if defined(ISP2401)\nstruct sh_css_sp_pipeline_io_status *ia_css_pipeline_get_pipe_io_status(void)\n{\n\treturn(&sh_css_sp_group.pipe_io_status);\n}\n#endif\n\nbool ia_css_pipeline_is_mapped(unsigned int key)\n{\n\tbool ret = false;\n\n\tIA_CSS_ENTER_PRIVATE(\"key = %d\", key);\n\n\tif ((key >= IA_CSS_PIPELINE_NUM_MAX) || (key >= IA_CSS_PIPE_ID_NUM)) {\n\t\tIA_CSS_ERROR(\"Invalid key!!\");\n\t\tIA_CSS_LEAVE_PRIVATE(\"return = %d\", false);\n\t\treturn false;\n\t}\n\n\tret = (bool)(pipeline_num_to_sp_thread_map[key] != (unsigned int)\n\t\t     PIPELINE_NUM_UNMAPPED);\n\n\tIA_CSS_LEAVE_PRIVATE(\"return = %d\", ret);\n\treturn ret;\n}\n\n \n\n \nstatic void pipeline_stage_destroy(struct ia_css_pipeline_stage *stage)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {\n\t\tif (stage->out_frame_allocated[i]) {\n\t\t\tia_css_frame_free(stage->args.out_frame[i]);\n\t\t\tstage->args.out_frame[i] = NULL;\n\t\t}\n\t}\n\tif (stage->vf_frame_allocated) {\n\t\tia_css_frame_free(stage->args.out_vf_frame);\n\t\tstage->args.out_vf_frame = NULL;\n\t}\n\tkvfree(stage);\n}\n\nstatic void pipeline_init_sp_thread_map(void)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < SH_CSS_MAX_SP_THREADS; i++)\n\t\tpipeline_sp_thread_list[i] = PIPELINE_SP_THREAD_EMPTY_TOKEN;\n\n\tfor (i = 0; i < IA_CSS_PIPELINE_NUM_MAX; i++)\n\t\tpipeline_num_to_sp_thread_map[i] = PIPELINE_NUM_UNMAPPED;\n}\n\nstatic void pipeline_map_num_to_sp_thread(unsigned int pipe_num)\n{\n\tunsigned int i;\n\tbool found_sp_thread = false;\n\n\t \n\tassert(pipeline_num_to_sp_thread_map[pipe_num]\n\t       == (unsigned int)PIPELINE_NUM_UNMAPPED);\n\n\tfor (i = 0; i < SH_CSS_MAX_SP_THREADS; i++) {\n\t\tif (pipeline_sp_thread_list[i] ==\n\t\t    PIPELINE_SP_THREAD_EMPTY_TOKEN) {\n\t\t\tpipeline_sp_thread_list[i] =\n\t\t\t    PIPELINE_SP_THREAD_RESERVED_TOKEN;\n\t\t\tpipeline_num_to_sp_thread_map[pipe_num] = i;\n\t\t\tfound_sp_thread = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\t \n\tassert(found_sp_thread);\n}\n\nstatic void pipeline_unmap_num_to_sp_thread(unsigned int pipe_num)\n{\n\tunsigned int thread_id;\n\n\tassert(pipeline_num_to_sp_thread_map[pipe_num]\n\t       != (unsigned int)PIPELINE_NUM_UNMAPPED);\n\n\tthread_id = pipeline_num_to_sp_thread_map[pipe_num];\n\tpipeline_num_to_sp_thread_map[pipe_num] = PIPELINE_NUM_UNMAPPED;\n\tpipeline_sp_thread_list[thread_id] = PIPELINE_SP_THREAD_EMPTY_TOKEN;\n}\n\nstatic int pipeline_stage_create(\n    struct ia_css_pipeline_stage_desc *stage_desc,\n    struct ia_css_pipeline_stage **new_stage)\n{\n\tint err = 0;\n\tstruct ia_css_pipeline_stage *stage = NULL;\n\tstruct ia_css_binary *binary;\n\tstruct ia_css_frame *vf_frame;\n\tstruct ia_css_frame *out_frame[IA_CSS_BINARY_MAX_OUTPUT_PORTS];\n\tconst struct ia_css_fw_info *firmware;\n\tunsigned int i;\n\n\t \n\tif (!(stage_desc->in_frame) && !(stage_desc->firmware)\n\t    && (stage_desc->binary) && !(stage_desc->binary->online)) {\n\t\terr = -EINVAL;\n\t\tgoto ERR;\n\t}\n\n\tbinary = stage_desc->binary;\n\tfirmware = stage_desc->firmware;\n\tvf_frame = stage_desc->vf_frame;\n\tfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {\n\t\tout_frame[i] = stage_desc->out_frame[i];\n\t}\n\n\tstage = kvzalloc(sizeof(*stage), GFP_KERNEL);\n\tif (!stage) {\n\t\terr = -ENOMEM;\n\t\tgoto ERR;\n\t}\n\n\tif (firmware) {\n\t\tstage->binary = NULL;\n\t\tstage->binary_info =\n\t\t    (struct ia_css_binary_info *)&firmware->info.isp;\n\t} else {\n\t\tstage->binary = binary;\n\t\tif (binary)\n\t\t\tstage->binary_info =\n\t\t\t    (struct ia_css_binary_info *)binary->info;\n\t\telse\n\t\t\tstage->binary_info = NULL;\n\t}\n\n\tstage->firmware = firmware;\n\tstage->sp_func = stage_desc->sp_func;\n\tstage->max_input_width = stage_desc->max_input_width;\n\tstage->mode = stage_desc->mode;\n\tfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)\n\t\tstage->out_frame_allocated[i] = false;\n\tstage->vf_frame_allocated = false;\n\tstage->next = NULL;\n\tsh_css_binary_args_reset(&stage->args);\n\n\tfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {\n\t\tif (!(out_frame[i]) && (binary)\n\t\t    && (binary->out_frame_info[i].res.width)) {\n\t\t\terr = ia_css_frame_allocate_from_info(&out_frame[i],\n\t\t\t\t\t\t\t      &binary->out_frame_info[i]);\n\t\t\tif (err)\n\t\t\t\tgoto ERR;\n\t\t\tstage->out_frame_allocated[i] = true;\n\t\t}\n\t}\n\t \n\tif (!vf_frame) {\n\t\tif ((binary && binary->vf_frame_info.res.width) ||\n\t\t    (firmware && firmware->info.isp.sp.enable.vf_veceven)\n\t\t   ) {\n\t\t\terr = ia_css_frame_allocate_from_info(&vf_frame,\n\t\t\t\t\t\t\t      &binary->vf_frame_info);\n\t\t\tif (err)\n\t\t\t\tgoto ERR;\n\t\t\tstage->vf_frame_allocated = true;\n\t\t}\n\t} else if (vf_frame && binary && binary->vf_frame_info.res.width\n\t\t   && !firmware) {\n\t\t \n\t\tif (vf_frame->data != mmgr_NULL)\n\t\t\tstage->vf_frame_allocated = true;\n\t}\n\n\tstage->args.in_frame = stage_desc->in_frame;\n\tfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)\n\t\tstage->args.out_frame[i] = out_frame[i];\n\tstage->args.out_vf_frame = vf_frame;\n\t*new_stage = stage;\n\treturn err;\nERR:\n\tif (stage)\n\t\tpipeline_stage_destroy(stage);\n\treturn err;\n}\n\nstatic const struct ia_css_frame ia_css_default_frame = DEFAULT_FRAME;\n\nstatic void pipeline_init_defaults(\n    struct ia_css_pipeline *pipeline,\n    enum ia_css_pipe_id pipe_id,\n    unsigned int pipe_num,\n    unsigned int dvs_frame_delay)\n{\n\tunsigned int i;\n\n\tpipeline->pipe_id = pipe_id;\n\tpipeline->stages = NULL;\n\tpipeline->stop_requested = false;\n\tpipeline->current_stage = NULL;\n\n\tmemcpy(&pipeline->in_frame, &ia_css_default_frame,\n\t       sizeof(ia_css_default_frame));\n\n\tfor (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {\n\t\tmemcpy(&pipeline->out_frame[i], &ia_css_default_frame,\n\t\t       sizeof(ia_css_default_frame));\n\t\tmemcpy(&pipeline->vf_frame[i], &ia_css_default_frame,\n\t\t       sizeof(ia_css_default_frame));\n\t}\n\tpipeline->num_execs = -1;\n\tpipeline->acquire_isp_each_stage = true;\n\tpipeline->pipe_num = (uint8_t)pipe_num;\n\tpipeline->dvs_frame_delay = dvs_frame_delay;\n}\n\nstatic void ia_css_pipeline_set_zoom_stage(struct ia_css_pipeline *pipeline)\n{\n\tstruct ia_css_pipeline_stage *stage = NULL;\n\tint err = 0;\n\n\tassert(pipeline);\n\tif (pipeline->pipe_id == IA_CSS_PIPE_ID_PREVIEW) {\n\t\t \n\t\terr = ia_css_pipeline_get_stage(pipeline, IA_CSS_BINARY_MODE_VF_PP, &stage);\n\t\tif (!err)\n\t\t\tstage->enable_zoom = true;\n\t} else if (pipeline->pipe_id == IA_CSS_PIPE_ID_CAPTURE) {\n\t\t \n\t\terr = ia_css_pipeline_get_stage(pipeline, IA_CSS_BINARY_MODE_CAPTURE_PP,\n\t\t\t\t\t\t&stage);\n\t\tif (!err)\n\t\t\tstage->enable_zoom = true;\n\t} else if (pipeline->pipe_id == IA_CSS_PIPE_ID_VIDEO) {\n\t\t \n\t\terr = ia_css_pipeline_get_stage(pipeline, IA_CSS_BINARY_MODE_VIDEO, &stage);\n\t\tif (!err)\n\t\t\tstage->enable_zoom = true;\n\t} else if (pipeline->pipe_id == IA_CSS_PIPE_ID_YUVPP) {\n\t\t \n\t\terr = ia_css_pipeline_get_stage(pipeline, IA_CSS_BINARY_MODE_CAPTURE_PP,\n\t\t\t\t\t\t&stage);\n\t\tif (!err)\n\t\t\tstage->enable_zoom = true;\n\t}\n}\n\nstatic void\nia_css_pipeline_configure_inout_port(struct ia_css_pipeline *me,\n\t\t\t\t     bool continuous)\n{\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"ia_css_pipeline_configure_inout_port() enter: pipe_id(%d) continuous(%d)\\n\",\n\t\t\t    me->pipe_id, continuous);\n\tswitch (me->pipe_id) {\n\tcase IA_CSS_PIPE_ID_PREVIEW:\n\tcase IA_CSS_PIPE_ID_VIDEO:\n\t\tSH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,\n\t\t\t\t\t    (uint8_t)SH_CSS_PORT_INPUT,\n\t\t\t\t\t    (uint8_t)(continuous ? SH_CSS_COPYSINK_TYPE : SH_CSS_HOST_TYPE), 1);\n\t\tSH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,\n\t\t\t\t\t    (uint8_t)SH_CSS_PORT_OUTPUT,\n\t\t\t\t\t    (uint8_t)SH_CSS_HOST_TYPE, 1);\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_COPY:  \n\t\tSH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,\n\t\t\t\t\t    (uint8_t)SH_CSS_PORT_INPUT,\n\t\t\t\t\t    (uint8_t)SH_CSS_HOST_TYPE, 1);\n\t\tif (continuous) {\n\t\t\tSH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,\n\t\t\t\t\t\t    (uint8_t)SH_CSS_PORT_OUTPUT,\n\t\t\t\t\t\t    (uint8_t)SH_CSS_COPYSINK_TYPE, 1);\n\t\t\tSH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,\n\t\t\t\t\t\t    (uint8_t)SH_CSS_PORT_OUTPUT,\n\t\t\t\t\t\t    (uint8_t)SH_CSS_TAGGERSINK_TYPE, 1);\n\t\t} else {\n\t\t\tSH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,\n\t\t\t\t\t\t    (uint8_t)SH_CSS_PORT_OUTPUT,\n\t\t\t\t\t\t    (uint8_t)SH_CSS_HOST_TYPE, 1);\n\t\t}\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_CAPTURE:\n\t\tSH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,\n\t\t\t\t\t    (uint8_t)SH_CSS_PORT_INPUT,\n\t\t\t\t\t    (uint8_t)(continuous ? SH_CSS_TAGGERSINK_TYPE : SH_CSS_HOST_TYPE),\n\t\t\t\t\t    1);\n\t\tSH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,\n\t\t\t\t\t    (uint8_t)SH_CSS_PORT_OUTPUT,\n\t\t\t\t\t    (uint8_t)SH_CSS_HOST_TYPE, 1);\n\t\tbreak;\n\tcase IA_CSS_PIPE_ID_YUVPP:\n\t\tSH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,\n\t\t\t\t\t    (uint8_t)SH_CSS_PORT_INPUT,\n\t\t\t\t\t    (uint8_t)(SH_CSS_HOST_TYPE), 1);\n\t\tSH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,\n\t\t\t\t\t    (uint8_t)SH_CSS_PORT_OUTPUT,\n\t\t\t\t\t    (uint8_t)SH_CSS_HOST_TYPE, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"ia_css_pipeline_configure_inout_port() leave: inout_port_config(%x)\\n\",\n\t\t\t    me->inout_port_config);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}