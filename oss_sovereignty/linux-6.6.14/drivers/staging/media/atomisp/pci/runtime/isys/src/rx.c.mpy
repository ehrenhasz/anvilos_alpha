{
  "module_name": "rx.c",
  "hash_id": "928240fda0e62450b96ec6d17e2476f04a3e90c62b7566eea93dcdaa9ace78b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/runtime/isys/src/rx.c",
  "human_readable_source": "\n \n\n#define __INLINE_INPUT_SYSTEM__\n#include \"input_system.h\"\n#include \"assert_support.h\"\n#include \"ia_css_isys.h\"\n#include \"ia_css_irq.h\"\n#include \"sh_css_internal.h\"\n\n#if !defined(ISP2401)\nvoid ia_css_isys_rx_enable_all_interrupts(enum mipi_port_id port)\n{\n\thrt_data bits = receiver_port_reg_load(RX0_ID,\n\t\t\t\t\t       port,\n\t\t\t\t\t       _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);\n\n\tbits |= (1U << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT) |\n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT) |\n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT) |\n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT) |\n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT) |\n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT) |\n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT) |\n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT) |\n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT) |\n\t\t \n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT) |\n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT) |\n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT) |\n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT) |\n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT) |\n\t\t(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT);\n\t \n\n\treceiver_port_reg_store(RX0_ID,\n\t\t\t\tport,\n\t\t\t\t_HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, bits);\n\n\t \n\tia_css_irq_enable(IA_CSS_IRQ_INFO_CSS_RECEIVER_ERROR, true);\n\n\treturn;\n}\n\n \nenum mipi_port_id ia_css_isys_port_to_mipi_port(enum mipi_port_id api_port)\n{\n\t \n\tenum mipi_port_id port = MIPI_PORT0_ID;\n\n\tif (api_port == MIPI_PORT1_ID)\n\t\tport = MIPI_PORT1_ID;\n\telse if (api_port == MIPI_PORT2_ID)\n\t\tport = MIPI_PORT2_ID;\n\n\treturn port;\n}\n\nunsigned int ia_css_isys_rx_get_interrupt_reg(enum mipi_port_id port)\n{\n\treturn receiver_port_reg_load(RX0_ID,\n\t\t\t\t      port,\n\t\t\t\t      _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);\n}\n\nvoid ia_css_rx_get_irq_info(unsigned int *irq_infos)\n{\n\tia_css_rx_port_get_irq_info(MIPI_PORT1_ID, irq_infos);\n}\n\nvoid ia_css_rx_port_get_irq_info(enum mipi_port_id api_port,\n\t\t\t\t unsigned int *irq_infos)\n{\n\tenum mipi_port_id port = ia_css_isys_port_to_mipi_port(api_port);\n\n\tia_css_isys_rx_get_irq_info(port, irq_infos);\n}\n\nvoid ia_css_isys_rx_get_irq_info(enum mipi_port_id port,\n\t\t\t\t unsigned int *irq_infos)\n{\n\tunsigned int bits;\n\n\tassert(irq_infos);\n\tbits = ia_css_isys_rx_get_interrupt_reg(port);\n\t*irq_infos = ia_css_isys_rx_translate_irq_infos(bits);\n}\n\n \nunsigned int ia_css_isys_rx_translate_irq_infos(unsigned int bits)\n{\n\tunsigned int infos = 0;\n\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_INIT_TIMEOUT;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_ECC_CORRECTED;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_ERR_SOT;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_ERR_CONTROL;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_ERR_CRC;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC;\n\tif (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT))\n\t\tinfos |= IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC;\n\n\treturn infos;\n}\n\nvoid ia_css_rx_clear_irq_info(unsigned int irq_infos)\n{\n\tia_css_rx_port_clear_irq_info(MIPI_PORT1_ID, irq_infos);\n}\n\nvoid ia_css_rx_port_clear_irq_info(enum mipi_port_id api_port,\n\t\t\t\t   unsigned int irq_infos)\n{\n\tenum mipi_port_id port = ia_css_isys_port_to_mipi_port(api_port);\n\n\tia_css_isys_rx_clear_irq_info(port, irq_infos);\n}\n\nvoid ia_css_isys_rx_clear_irq_info(enum mipi_port_id port,\n\t\t\t\t   unsigned int irq_infos)\n{\n\thrt_data bits = receiver_port_reg_load(RX0_ID,\n\t\t\t\t\t       port,\n\t\t\t\t\t       _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);\n\n\t \n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_INIT_TIMEOUT)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_ECC_CORRECTED)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_SOT)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_CONTROL)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_CRC)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT;\n\tif (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC)\n\t\tbits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT;\n\n\treceiver_port_reg_store(RX0_ID,\n\t\t\t\tport,\n\t\t\t\t_HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, bits);\n\n\treturn;\n}\n#endif  \n\nint ia_css_isys_convert_stream_format_to_mipi_format(\n    enum atomisp_input_format input_format,\n    mipi_predictor_t compression,\n    unsigned int *fmt_type)\n{\n\tassert(fmt_type);\n\t \n\tif (compression != MIPI_PREDICTOR_NONE) {\n\t\tswitch (input_format) {\n\t\tcase ATOMISP_INPUT_FORMAT_RAW_6:\n\t\t\t*fmt_type = 6;\n\t\t\tbreak;\n\t\tcase ATOMISP_INPUT_FORMAT_RAW_7:\n\t\t\t*fmt_type = 7;\n\t\t\tbreak;\n\t\tcase ATOMISP_INPUT_FORMAT_RAW_8:\n\t\t\t*fmt_type = 8;\n\t\t\tbreak;\n\t\tcase ATOMISP_INPUT_FORMAT_RAW_10:\n\t\t\t*fmt_type = 10;\n\t\t\tbreak;\n\t\tcase ATOMISP_INPUT_FORMAT_RAW_12:\n\t\t\t*fmt_type = 12;\n\t\t\tbreak;\n\t\tcase ATOMISP_INPUT_FORMAT_RAW_14:\n\t\t\t*fmt_type = 14;\n\t\t\tbreak;\n\t\tcase ATOMISP_INPUT_FORMAT_RAW_16:\n\t\t\t*fmt_type = 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\t \n\tswitch (input_format) {\n\tcase ATOMISP_INPUT_FORMAT_RGB_888:\n\t\t*fmt_type = MIPI_FORMAT_RGB888;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RGB_555:\n\t\t*fmt_type = MIPI_FORMAT_RGB555;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RGB_444:\n\t\t*fmt_type = MIPI_FORMAT_RGB444;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RGB_565:\n\t\t*fmt_type = MIPI_FORMAT_RGB565;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RGB_666:\n\t\t*fmt_type = MIPI_FORMAT_RGB666;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RAW_8:\n\t\t*fmt_type = MIPI_FORMAT_RAW8;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RAW_10:\n\t\t*fmt_type = MIPI_FORMAT_RAW10;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RAW_6:\n\t\t*fmt_type = MIPI_FORMAT_RAW6;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RAW_7:\n\t\t*fmt_type = MIPI_FORMAT_RAW7;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RAW_12:\n\t\t*fmt_type = MIPI_FORMAT_RAW12;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RAW_14:\n\t\t*fmt_type = MIPI_FORMAT_RAW14;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8:\n\t\t*fmt_type = MIPI_FORMAT_YUV420_8;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV420_10:\n\t\t*fmt_type = MIPI_FORMAT_YUV420_10;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV422_8:\n\t\t*fmt_type = MIPI_FORMAT_YUV422_8;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV422_10:\n\t\t*fmt_type = MIPI_FORMAT_YUV422_10;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY:\n\t\t*fmt_type = MIPI_FORMAT_YUV420_8_LEGACY;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_EMBEDDED:\n\t\t*fmt_type = MIPI_FORMAT_EMBEDDED;\n\t\tbreak;\n#ifndef ISP2401\n\tcase ATOMISP_INPUT_FORMAT_RAW_16:\n\t\t \n\t\t*fmt_type = MIPI_FORMAT_RAW16;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_BINARY_8:\n\t\t*fmt_type = MIPI_FORMAT_BINARY_8;\n\t\tbreak;\n#else\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF1:\n\t\t*fmt_type = MIPI_FORMAT_CUSTOM0;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF2:\n\t\t*fmt_type = MIPI_FORMAT_CUSTOM1;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF3:\n\t\t*fmt_type = MIPI_FORMAT_CUSTOM2;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF4:\n\t\t*fmt_type = MIPI_FORMAT_CUSTOM3;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF5:\n\t\t*fmt_type = MIPI_FORMAT_CUSTOM4;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF6:\n\t\t*fmt_type = MIPI_FORMAT_CUSTOM5;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF7:\n\t\t*fmt_type = MIPI_FORMAT_CUSTOM6;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF8:\n\t\t*fmt_type = MIPI_FORMAT_CUSTOM7;\n\t\tbreak;\n#endif\n\n\tcase ATOMISP_INPUT_FORMAT_YUV420_16:\n\tcase ATOMISP_INPUT_FORMAT_YUV422_16:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#if defined(ISP2401)\nstatic mipi_predictor_t sh_css_csi2_compression_type_2_mipi_predictor(\n    enum ia_css_csi2_compression_type type)\n{\n\tmipi_predictor_t predictor = MIPI_PREDICTOR_NONE;\n\n\tswitch (type) {\n\tcase IA_CSS_CSI2_COMPRESSION_TYPE_1:\n\t\tpredictor = MIPI_PREDICTOR_TYPE1 - 1;\n\t\tbreak;\n\tcase IA_CSS_CSI2_COMPRESSION_TYPE_2:\n\t\tpredictor = MIPI_PREDICTOR_TYPE2 - 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn predictor;\n}\n\nint ia_css_isys_convert_compressed_format(\n    struct ia_css_csi2_compression *comp,\n    struct isp2401_input_system_cfg_s *cfg)\n{\n\tint err = 0;\n\n\tassert(comp);\n\tassert(cfg);\n\n\tif (comp->type != IA_CSS_CSI2_COMPRESSION_TYPE_NONE) {\n\t\t \n\t\tif (comp->uncompressed_bits_per_pixel == UNCOMPRESSED_BITS_PER_PIXEL_10) {\n\t\t\tswitch (comp->compressed_bits_per_pixel) {\n\t\t\tcase COMPRESSED_BITS_PER_PIXEL_6:\n\t\t\t\tcfg->csi_port_attr.comp_scheme = MIPI_COMPRESSOR_10_6_10;\n\t\t\t\tbreak;\n\t\t\tcase COMPRESSED_BITS_PER_PIXEL_7:\n\t\t\t\tcfg->csi_port_attr.comp_scheme = MIPI_COMPRESSOR_10_7_10;\n\t\t\t\tbreak;\n\t\t\tcase COMPRESSED_BITS_PER_PIXEL_8:\n\t\t\t\tcfg->csi_port_attr.comp_scheme = MIPI_COMPRESSOR_10_8_10;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t} else if (comp->uncompressed_bits_per_pixel ==\n\t\t\t   UNCOMPRESSED_BITS_PER_PIXEL_12) {\n\t\t\tswitch (comp->compressed_bits_per_pixel) {\n\t\t\tcase COMPRESSED_BITS_PER_PIXEL_6:\n\t\t\t\tcfg->csi_port_attr.comp_scheme = MIPI_COMPRESSOR_12_6_12;\n\t\t\t\tbreak;\n\t\t\tcase COMPRESSED_BITS_PER_PIXEL_7:\n\t\t\t\tcfg->csi_port_attr.comp_scheme = MIPI_COMPRESSOR_12_7_12;\n\t\t\t\tbreak;\n\t\t\tcase COMPRESSED_BITS_PER_PIXEL_8:\n\t\t\t\tcfg->csi_port_attr.comp_scheme = MIPI_COMPRESSOR_12_8_12;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t} else\n\t\t\terr = -EINVAL;\n\t\tcfg->csi_port_attr.comp_predictor =\n\t\t    sh_css_csi2_compression_type_2_mipi_predictor(comp->type);\n\t\tcfg->csi_port_attr.comp_enable = true;\n\t} else  \n\t\tcfg->csi_port_attr.comp_enable = false;\n\treturn err;\n}\n\nunsigned int ia_css_csi2_calculate_input_system_alignment(\n    enum atomisp_input_format fmt_type)\n{\n\tunsigned int memory_alignment_in_bytes = HIVE_ISP_DDR_WORD_BYTES;\n\n\tswitch (fmt_type) {\n\tcase ATOMISP_INPUT_FORMAT_RAW_6:\n\tcase ATOMISP_INPUT_FORMAT_RAW_7:\n\tcase ATOMISP_INPUT_FORMAT_RAW_8:\n\tcase ATOMISP_INPUT_FORMAT_RAW_10:\n\tcase ATOMISP_INPUT_FORMAT_RAW_12:\n\tcase ATOMISP_INPUT_FORMAT_RAW_14:\n\t\tmemory_alignment_in_bytes = 2 * ISP_VEC_NELEMS;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8:\n\tcase ATOMISP_INPUT_FORMAT_YUV422_8:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF1:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF2:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF3:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF4:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF5:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF6:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF7:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF8:\n\t\t \n\t\tmemory_alignment_in_bytes = 2 * HIVE_ISP_DDR_WORD_BYTES;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_EMBEDDED:\n\tdefault:\n\t\tmemory_alignment_in_bytes = HIVE_ISP_DDR_WORD_BYTES;\n\t\tbreak;\n\t}\n\treturn memory_alignment_in_bytes;\n}\n\n#endif\n\n#if !defined(ISP2401)\nstatic const mipi_lane_cfg_t MIPI_PORT_LANES[N_RX_MODE][N_MIPI_PORT_ID] = {\n\t{MIPI_4LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},\n\t{MIPI_3LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},\n\t{MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},\n\t{MIPI_1LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},\n\t{MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_2LANE_CFG},\n\t{MIPI_3LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG},\n\t{MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG},\n\t{MIPI_1LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG}\n};\n\nvoid ia_css_isys_rx_configure(const rx_cfg_t *config,\n\t\t\t      const enum ia_css_input_mode input_mode)\n{\n\tbool any_port_enabled = false;\n\tenum mipi_port_id port;\n\n\tif ((!config)\n\t    || (config->mode >= N_RX_MODE)\n\t    || (config->port >= N_MIPI_PORT_ID)) {\n\t\tassert(0);\n\t\treturn;\n\t}\n\tfor (port = (enum mipi_port_id)0; port < N_MIPI_PORT_ID; port++) {\n\t\tif (is_receiver_port_enabled(RX0_ID, port))\n\t\t\tany_port_enabled = true;\n\t}\n\t \n\n\tport = config->port;\n\treceiver_port_enable(RX0_ID, port, false);\n\n\tport = config->port;\n\n\t \n\tif (MIPI_PORT_LANES[config->mode][port] != MIPI_0LANE_CFG) {\n\t\treceiver_port_reg_store(RX0_ID, port,\n\t\t\t\t\t_HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX,\n\t\t\t\t\tconfig->timeout);\n\t\treceiver_port_reg_store(RX0_ID, port,\n\t\t\t\t\t_HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX,\n\t\t\t\t\tconfig->initcount);\n\t\treceiver_port_reg_store(RX0_ID, port,\n\t\t\t\t\t_HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX,\n\t\t\t\t\tconfig->synccount);\n\t\treceiver_port_reg_store(RX0_ID, port,\n\t\t\t\t\t_HRT_CSS_RECEIVER_2400_RX_COUNT_REG_IDX,\n\t\t\t\t\tconfig->rxcount);\n\n\t\tif (input_mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {\n\t\t\t \n\t\t\tinput_system_sub_system_reg_store(INPUT_SYSTEM0_ID,\n\t\t\t\t\t\t\t  GPREGS_UNIT0_ID,\n\t\t\t\t\t\t\t  HIVE_ISYS_GPREG_MULTICAST_A_IDX\n\t\t\t\t\t\t\t  + (unsigned int)port,\n\t\t\t\t\t\t\t  INPUT_SYSTEM_CSI_BACKEND);\n\t\t\t \n\t\t\tinput_system_sub_system_reg_store(INPUT_SYSTEM0_ID,\n\t\t\t\t\t\t\t  GPREGS_UNIT0_ID,\n\t\t\t\t\t\t\t  HIVE_ISYS_GPREG_MUX_IDX,\n\t\t\t\t\t\t\t  (input_system_multiplex_t)port);\n\t\t} else {\n\t\t\t \n\t\t\tinput_system_sub_system_reg_store(INPUT_SYSTEM0_ID,\n\t\t\t\t\t\t\t  GPREGS_UNIT0_ID,\n\t\t\t\t\t\t\t  HIVE_ISYS_GPREG_MULTICAST_A_IDX\n\t\t\t\t\t\t\t  + (unsigned int)port,\n\t\t\t\t\t\t\t  INPUT_SYSTEM_INPUT_BUFFER);\n\t\t\tinput_system_sub_system_reg_store(INPUT_SYSTEM0_ID,\n\t\t\t\t\t\t\t  GPREGS_UNIT0_ID,\n\t\t\t\t\t\t\t  HIVE_ISYS_GPREG_MUX_IDX,\n\t\t\t\t\t\t\t  INPUT_SYSTEM_ACQUISITION_UNIT);\n\t\t}\n\t}\n\t \n\t \n\t \n\tif (!any_port_enabled) {\n\t\treceiver_reg_store(RX0_ID,\n\t\t\t\t   _HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX,\n\t\t\t\t   config->is_two_ppc);\n\t\treceiver_reg_store(RX0_ID, _HRT_CSS_RECEIVER_BE_TWO_PPC_REG_IDX,\n\t\t\t\t   config->is_two_ppc);\n\t}\n\treceiver_port_enable(RX0_ID, port, true);\n\t \n\t \n\t \n\tinput_system_reg_store(INPUT_SYSTEM0_ID, 0x207, 1);\n\n\treturn;\n}\n\nvoid ia_css_isys_rx_disable(void)\n{\n\tenum mipi_port_id port;\n\n\tfor (port = (enum mipi_port_id)0; port < N_MIPI_PORT_ID; port++) {\n\t\treceiver_port_reg_store(RX0_ID, port,\n\t\t\t\t\t_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX,\n\t\t\t\t\tfalse);\n\t}\n\treturn;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}