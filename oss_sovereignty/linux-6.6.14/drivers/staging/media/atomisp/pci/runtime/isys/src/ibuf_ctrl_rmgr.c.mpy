{
  "module_name": "ibuf_ctrl_rmgr.c",
  "hash_id": "9aff4f6a2e69b0c2bd3b0c28f1d4ae1d9768b01cfca21e627b540bd34aaa6a71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/runtime/isys/src/ibuf_ctrl_rmgr.c",
  "human_readable_source": "\n \n\n#include \"system_global.h\"\n\n#include \"assert_support.h\"\n#include \"platform_support.h\"\n#include \"ia_css_isys.h\"\n#include \"ibuf_ctrl_rmgr.h\"\n\nstatic ibuf_rsrc_t\tibuf_rsrc;\n\nstatic ibuf_handle_t *getHandle(uint16_t index)\n{\n\tibuf_handle_t *handle = NULL;\n\n\tif (index < MAX_IBUF_HANDLES)\n\t\thandle = &ibuf_rsrc.handles[index];\n\treturn handle;\n}\n\nvoid ia_css_isys_ibuf_rmgr_init(void)\n{\n\tmemset(&ibuf_rsrc, 0, sizeof(ibuf_rsrc));\n\tibuf_rsrc.free_size = MAX_INPUT_BUFFER_SIZE;\n}\n\nvoid ia_css_isys_ibuf_rmgr_uninit(void)\n{\n\tmemset(&ibuf_rsrc, 0, sizeof(ibuf_rsrc));\n\tibuf_rsrc.free_size = MAX_INPUT_BUFFER_SIZE;\n}\n\nbool ia_css_isys_ibuf_rmgr_acquire(\n    u32\tsize,\n    uint32_t\t*start_addr)\n{\n\tbool retval = false;\n\tbool input_buffer_found = false;\n\tu32 aligned_size;\n\tibuf_handle_t *handle = NULL;\n\tu16 i;\n\n\tassert(start_addr);\n\tassert(size > 0);\n\n\taligned_size = (size + (IBUF_ALIGN - 1)) & ~(IBUF_ALIGN - 1);\n\n\t \n\tif (ibuf_rsrc.num_active < ibuf_rsrc.num_allocated) {\n\t\tfor (i = 0; i < ibuf_rsrc.num_allocated; i++) {\n\t\t\thandle = getHandle(i);\n\t\t\tif (!handle->active) {\n\t\t\t\tif (handle->size >= aligned_size) {\n\t\t\t\t\thandle->active = true;\n\t\t\t\t\tinput_buffer_found = true;\n\t\t\t\t\tibuf_rsrc.num_active++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!input_buffer_found) {\n\t\t \n\t\tif ((ibuf_rsrc.num_allocated < MAX_IBUF_HANDLES) &&\n\t\t    (ibuf_rsrc.free_size >= aligned_size)) {\n\t\t\thandle = getHandle(ibuf_rsrc.num_allocated);\n\t\t\thandle->start_addr\t= ibuf_rsrc.free_start_addr;\n\t\t\thandle->size\t\t= aligned_size;\n\t\t\thandle->active\t\t= true;\n\n\t\t\tibuf_rsrc.free_start_addr += aligned_size;\n\t\t\tibuf_rsrc.free_size -= aligned_size;\n\t\t\tibuf_rsrc.num_active++;\n\t\t\tibuf_rsrc.num_allocated++;\n\n\t\t\tinput_buffer_found = true;\n\t\t}\n\t}\n\n\tif (input_buffer_found && handle) {\n\t\t*start_addr = handle->start_addr;\n\t\tretval = true;\n\t}\n\n\treturn retval;\n}\n\nvoid ia_css_isys_ibuf_rmgr_release(\n    uint32_t\t*start_addr)\n{\n\tu16 i;\n\tibuf_handle_t *handle = NULL;\n\n\tassert(start_addr);\n\n\tfor (i = 0; i < ibuf_rsrc.num_allocated; i++) {\n\t\thandle = getHandle(i);\n\t\tif (handle->active && handle->start_addr == *start_addr) {\n\t\t\thandle->active = false;\n\t\t\tibuf_rsrc.num_active--;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}