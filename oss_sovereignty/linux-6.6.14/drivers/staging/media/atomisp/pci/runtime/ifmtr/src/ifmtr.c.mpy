{
  "module_name": "ifmtr.c",
  "hash_id": "ace170aaf42d1cea798852fdef4f57f99ee4dca1657dbea7fa7db0a59700df5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/runtime/ifmtr/src/ifmtr.c",
  "human_readable_source": "\n \n\n#include \"system_global.h\"\n#include <linux/kernel.h>\n\n#ifndef ISP2401\n\n#include \"ia_css_ifmtr.h\"\n#include <math_support.h>\n#include \"sh_css_internal.h\"\n#include \"input_formatter.h\"\n#include \"assert_support.h\"\n#include \"sh_css_sp.h\"\n#include \"isp/modes/interface/input_buf.isp.h\"\n\n \nstatic int ifmtr_start_column(\n    const struct ia_css_stream_config *config,\n    unsigned int bin_in,\n    unsigned int *start_column);\n\nstatic int ifmtr_input_start_line(\n    const struct ia_css_stream_config *config,\n    unsigned int bin_in,\n    unsigned int *start_line);\n\nstatic void ifmtr_set_if_blocking_mode(\n    const input_formatter_cfg_t *const config_a,\n    const input_formatter_cfg_t *const config_b);\n\n \n\n \nunsigned int ia_css_ifmtr_lines_needed_for_bayer_order(\n    const struct ia_css_stream_config *config)\n{\n\tassert(config);\n\tif ((config->input_config.bayer_order == IA_CSS_BAYER_ORDER_BGGR)\n\t    || (config->input_config.bayer_order == IA_CSS_BAYER_ORDER_GBRG))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nunsigned int ia_css_ifmtr_columns_needed_for_bayer_order(\n    const struct ia_css_stream_config *config)\n{\n\tassert(config);\n\tif ((config->input_config.bayer_order == IA_CSS_BAYER_ORDER_RGGB)\n\t    || (config->input_config.bayer_order == IA_CSS_BAYER_ORDER_GBRG))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint ia_css_ifmtr_configure(struct ia_css_stream_config *config,\n\t\t\t\t       struct ia_css_binary *binary)\n{\n\tunsigned int start_line, start_column = 0,\n\t\t\t\t cropped_height,\n\t\t\t\t cropped_width,\n\t\t\t\t num_vectors,\n\t\t\t\t buffer_height = 2,\n\t\t\t\t buffer_width,\n\t\t\t\t two_ppc,\n\t\t\t\t vmem_increment = 0,\n\t\t\t\t deinterleaving = 0,\n\t\t\t\t deinterleaving_b = 0,\n\t\t\t\t width_a = 0,\n\t\t\t\t width_b = 0,\n\t\t\t\t bits_per_pixel,\n\t\t\t\t vectors_per_buffer,\n\t\t\t\t vectors_per_line = 0,\n\t\t\t\t buffers_per_line = 0,\n\t\t\t\t buf_offset_a = 0,\n\t\t\t\t buf_offset_b = 0,\n\t\t\t\t line_width = 0,\n\t\t\t\t width_b_factor = 1, start_column_b,\n\t\t\t\t left_padding = 0;\n\tinput_formatter_cfg_t if_a_config, if_b_config;\n\tenum atomisp_input_format input_format;\n\tint err = 0;\n\tu8 if_config_index;\n\n\t \n\t \n\tenum mipi_port_id port;\n\n\tif (binary) {\n\t\tcropped_height = binary->in_frame_info.res.height;\n\t\tcropped_width = binary->in_frame_info.res.width;\n\t\t \n\t\tif (binary->info->sp.enable.continuous &&\n\t\t    binary->info->sp.pipeline.mode != IA_CSS_BINARY_MODE_COPY)\n\t\t\tbuffer_width = MAX_VECTORS_PER_INPUT_LINE_CONT * ISP_VEC_NELEMS;\n\t\telse\n\t\t\tbuffer_width = binary->info->sp.input.max_width;\n\t\tinput_format = binary->input_format;\n\t} else {\n\t\t \n\t\tcropped_height = config->input_config.input_res.height;\n\t\tcropped_width = config->input_config.input_res.width;\n\t\tbuffer_width = MAX_VECTORS_PER_INPUT_LINE_CONT * ISP_VEC_NELEMS;\n\t\tinput_format = config->input_config.format;\n\t}\n\ttwo_ppc = config->pixels_per_clock == 2;\n\tif (config->mode == IA_CSS_INPUT_MODE_SENSOR\n\t    || config->mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {\n\t\tport = config->source.port.port;\n\t\tif_config_index = (uint8_t)(port - MIPI_PORT0_ID);\n\t} else if (config->mode == IA_CSS_INPUT_MODE_MEMORY) {\n\t\tif_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;\n\t} else {\n\t\tif_config_index = 0;\n\t}\n\n\tassert(if_config_index <= SH_CSS_MAX_IF_CONFIGS\n\t       || if_config_index == SH_CSS_IF_CONFIG_NOT_NEEDED);\n\n\t \n\terr = ifmtr_input_start_line(config, cropped_height, &start_line);\n\tif (err)\n\t\treturn err;\n\terr = ifmtr_start_column(config, cropped_width, &start_column);\n\tif (err)\n\t\treturn err;\n\n\tif (config->left_padding == -1)\n\t\tif (!binary)\n\t\t\t \n\t\t\tleft_padding = 0;\n\t\telse\n\t\t\tleft_padding = binary->left_padding;\n\telse\n\t\tleft_padding = 2 * ISP_VEC_NELEMS - config->left_padding;\n\n\tif (left_padding) {\n\t\tnum_vectors = CEIL_DIV(cropped_width + left_padding,\n\t\t\t\t       ISP_VEC_NELEMS);\n\t} else {\n\t\tnum_vectors = CEIL_DIV(cropped_width, ISP_VEC_NELEMS);\n\t\tnum_vectors *= buffer_height;\n\t\t \n\t}\n\n\tstart_column_b = start_column;\n\n\tbits_per_pixel = input_formatter_get_alignment(INPUT_FORMATTER0_ID)\n\t\t\t * 8 / ISP_VEC_NELEMS;\n\tswitch (input_format) {\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY:\n\t\tif (two_ppc) {\n\t\t\tvmem_increment = 1;\n\t\t\tdeinterleaving = 1;\n\t\t\tdeinterleaving_b = 1;\n\t\t\t \n\t\t\twidth_a = cropped_width * deinterleaving / 2;\n\t\t\twidth_b_factor = 2;\n\t\t\t \n\t\t\twidth_b = width_a * width_b_factor;\n\t\t\tbuffer_width *= deinterleaving * 2;\n\t\t\t \n\t\t\tnum_vectors *= deinterleaving;\n\t\t\tbuf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;\n\t\t\tvectors_per_line = num_vectors / buffer_height;\n\t\t\t \n\t\t\tline_width = vectors_per_line *\n\t\t\t\t     input_formatter_get_alignment(INPUT_FORMATTER0_ID) /\n\t\t\t\t     2;\n\t\t\tstart_column /= 2;\n\t\t} else {\n\t\t\tvmem_increment = 1;\n\t\t\tdeinterleaving = 3;\n\t\t\twidth_a = cropped_width * deinterleaving / 2;\n\t\t\tbuffer_width = buffer_width * deinterleaving / 2;\n\t\t\t \n\t\t\tnum_vectors = num_vectors / 2 * deinterleaving;\n\t\t\tstart_column = start_column * deinterleaving / 2;\n\t\t}\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8:\n\tcase ATOMISP_INPUT_FORMAT_YUV420_10:\n\tcase ATOMISP_INPUT_FORMAT_YUV420_16:\n\t\tif (two_ppc) {\n\t\t\tvmem_increment = 1;\n\t\t\tdeinterleaving = 1;\n\t\t\twidth_a = width_b = cropped_width * deinterleaving / 2;\n\t\t\tbuffer_width *= deinterleaving * 2;\n\t\t\tnum_vectors *= deinterleaving;\n\t\t\tbuf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;\n\t\t\tvectors_per_line = num_vectors / buffer_height;\n\t\t\t \n\t\t\tline_width = vectors_per_line *\n\t\t\t\t     input_formatter_get_alignment(INPUT_FORMATTER0_ID) /\n\t\t\t\t     2;\n\t\t\tstart_column *= deinterleaving;\n\t\t\tstart_column /= 2;\n\t\t\tstart_column_b = start_column;\n\t\t} else {\n\t\t\tvmem_increment = 1;\n\t\t\tdeinterleaving = 1;\n\t\t\twidth_a = cropped_width * deinterleaving;\n\t\t\tbuffer_width *= deinterleaving * 2;\n\t\t\tnum_vectors *= deinterleaving;\n\t\t\tstart_column *= deinterleaving;\n\t\t}\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV422_8:\n\tcase ATOMISP_INPUT_FORMAT_YUV422_10:\n\tcase ATOMISP_INPUT_FORMAT_YUV422_16:\n\t\tif (two_ppc) {\n\t\t\tvmem_increment = 1;\n\t\t\tdeinterleaving = 1;\n\t\t\twidth_a = width_b = cropped_width * deinterleaving;\n\t\t\tbuffer_width *= deinterleaving * 2;\n\t\t\tnum_vectors *= deinterleaving;\n\t\t\tstart_column *= deinterleaving;\n\t\t\tbuf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;\n\t\t\tstart_column_b = start_column;\n\t\t} else {\n\t\t\tvmem_increment = 1;\n\t\t\tdeinterleaving = 2;\n\t\t\twidth_a = cropped_width * deinterleaving;\n\t\t\tbuffer_width *= deinterleaving;\n\t\t\tnum_vectors *= deinterleaving;\n\t\t\tstart_column *= deinterleaving;\n\t\t}\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RGB_444:\n\tcase ATOMISP_INPUT_FORMAT_RGB_555:\n\tcase ATOMISP_INPUT_FORMAT_RGB_565:\n\tcase ATOMISP_INPUT_FORMAT_RGB_666:\n\tcase ATOMISP_INPUT_FORMAT_RGB_888:\n\t\tnum_vectors *= 2;\n\t\tif (two_ppc) {\n\t\t\tdeinterleaving = 2;\t \n\t\t\tdeinterleaving_b = 1;\t \n\t\t\tbuffers_per_line = 4;\n\t\t\tstart_column_b = start_column;\n\t\t\tstart_column *= deinterleaving;\n\t\t\tstart_column_b *= deinterleaving_b;\n\t\t} else {\n\t\t\tdeinterleaving = 3;\t \n\t\t\tbuffers_per_line = 3;\n\t\t\tstart_column *= deinterleaving;\n\t\t}\n\t\tvmem_increment = 1;\n\t\twidth_a = cropped_width * deinterleaving;\n\t\twidth_b = cropped_width * deinterleaving_b;\n\t\tbuffer_width *= buffers_per_line;\n\t\t \n\t\tnum_vectors = num_vectors / 2 * deinterleaving;\n\t\tbuf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RAW_6:\n\tcase ATOMISP_INPUT_FORMAT_RAW_7:\n\tcase ATOMISP_INPUT_FORMAT_RAW_8:\n\tcase ATOMISP_INPUT_FORMAT_RAW_10:\n\tcase ATOMISP_INPUT_FORMAT_RAW_12:\n\t\tif (two_ppc) {\n\t\t\tint crop_col = (start_column % 2) == 1;\n\n\t\t\tvmem_increment = 2;\n\t\t\tdeinterleaving = 1;\n\t\t\twidth_a = width_b = cropped_width / 2;\n\n\t\t\t \n\t\t\tbuf_offset_a   = crop_col ? 1 : 0;\n\t\t\tbuf_offset_b   = crop_col ? 0 : 1;\n\t\t\tstart_column_b = start_column / 2;\n\t\t\tstart_column   = start_column / 2 + crop_col;\n\t\t} else {\n\t\t\tvmem_increment = 1;\n\t\t\tdeinterleaving = 2;\n\t\t\tif ((!binary) || (config->continuous && binary\n\t\t\t\t\t  && binary->info->sp.pipeline.mode == IA_CSS_BINARY_MODE_COPY)) {\n\t\t\t\t \n\t\t\t\tdeinterleaving = 1;\n\t\t\t}\n\t\t\twidth_a = cropped_width;\n\t\t\t \n\t\t\tnum_vectors = CEIL_MUL(num_vectors, deinterleaving);\n\t\t}\n\t\tbuffer_height *= 2;\n\t\tif ((!binary) || config->continuous)\n\t\t\t \n\t\t\tbuffer_height *= 2;\n\t\tvectors_per_line = CEIL_DIV(cropped_width, ISP_VEC_NELEMS);\n\t\tvectors_per_line = CEIL_MUL(vectors_per_line, deinterleaving);\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RAW_14:\n\tcase ATOMISP_INPUT_FORMAT_RAW_16:\n\t\tif (two_ppc) {\n\t\t\tnum_vectors *= 2;\n\t\t\tvmem_increment = 1;\n\t\t\tdeinterleaving = 2;\n\t\t\twidth_a = width_b = cropped_width;\n\t\t\t \n\t\t\tbuf_offset_b = buffer_width / ISP_VEC_NELEMS;\n\t\t\tbits_per_pixel *= 2;\n\t\t} else {\n\t\t\tvmem_increment = 1;\n\t\t\tdeinterleaving = 2;\n\t\t\twidth_a = cropped_width;\n\t\t\tstart_column /= deinterleaving;\n\t\t}\n\t\tbuffer_height *= 2;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_BINARY_8:\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT1:\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT2:\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT3:\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT4:\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT5:\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT6:\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT7:\n\tcase ATOMISP_INPUT_FORMAT_GENERIC_SHORT8:\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8_SHIFT:\n\tcase ATOMISP_INPUT_FORMAT_YUV420_10_SHIFT:\n\tcase ATOMISP_INPUT_FORMAT_EMBEDDED:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF1:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF2:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF3:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF4:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF5:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF6:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF7:\n\tcase ATOMISP_INPUT_FORMAT_USER_DEF8:\n\t\tbreak;\n\t}\n\tif (width_a == 0)\n\t\treturn -EINVAL;\n\n\tif (two_ppc)\n\t\tleft_padding /= 2;\n\n\t \n\tif (left_padding)\n\t\tvectors_per_line = num_vectors;\n\tif (!vectors_per_line) {\n\t\tvectors_per_line = CEIL_MUL(num_vectors / buffer_height,\n\t\t\t\t\t    deinterleaving);\n\t\tline_width = 0;\n\t}\n\tif (!line_width)\n\t\tline_width = vectors_per_line *\n\t\t\t     input_formatter_get_alignment(INPUT_FORMATTER0_ID);\n\tif (!buffers_per_line)\n\t\tbuffers_per_line = deinterleaving;\n\tline_width = CEIL_MUL(line_width,\n\t\t\t      input_formatter_get_alignment(INPUT_FORMATTER0_ID)\n\t\t\t      * vmem_increment);\n\n\tvectors_per_buffer = buffer_height * buffer_width / ISP_VEC_NELEMS;\n\n\tif (config->mode == IA_CSS_INPUT_MODE_TPG &&\n\t    ((binary && binary->info->sp.pipeline.mode == IA_CSS_BINARY_MODE_VIDEO) ||\n\t     (!binary))) {\n\t\t \n\t\t \n\t\tstart_line = 0;\n\t\tstart_column = 0;\n\t\tcropped_height -= start_line;\n\t\twidth_a -= start_column;\n\t}\n\n\tif_a_config.start_line = start_line;\n\tif_a_config.start_column = start_column;\n\tif_a_config.left_padding = left_padding / deinterleaving;\n\tif_a_config.cropped_height = cropped_height;\n\tif_a_config.cropped_width = width_a;\n\tif_a_config.deinterleaving = deinterleaving;\n\tif_a_config.buf_vecs = vectors_per_buffer;\n\tif_a_config.buf_start_index = buf_offset_a;\n\tif_a_config.buf_increment = vmem_increment;\n\tif_a_config.buf_eol_offset =\n\t    buffer_width * bits_per_pixel / 8 - line_width;\n\tif_a_config.is_yuv420_format =\n\t    (input_format == ATOMISP_INPUT_FORMAT_YUV420_8)\n\t    || (input_format == ATOMISP_INPUT_FORMAT_YUV420_10)\n\t    || (input_format == ATOMISP_INPUT_FORMAT_YUV420_16);\n\tif_a_config.block_no_reqs = (config->mode != IA_CSS_INPUT_MODE_SENSOR);\n\n\tif (two_ppc) {\n\t\tif (deinterleaving_b) {\n\t\t\tdeinterleaving = deinterleaving_b;\n\t\t\twidth_b = cropped_width * deinterleaving;\n\t\t\tbuffer_width *= deinterleaving;\n\t\t\t \n\t\t\tnum_vectors = num_vectors / 2 *\n\t\t\t\t      deinterleaving * width_b_factor;\n\t\t\tvectors_per_line = num_vectors / buffer_height;\n\t\t\tline_width = vectors_per_line *\n\t\t\t\t     input_formatter_get_alignment(INPUT_FORMATTER0_ID);\n\t\t}\n\t\tif_b_config.start_line = start_line;\n\t\tif_b_config.start_column = start_column_b;\n\t\tif_b_config.left_padding = left_padding / deinterleaving;\n\t\tif_b_config.cropped_height = cropped_height;\n\t\tif_b_config.cropped_width = width_b;\n\t\tif_b_config.deinterleaving = deinterleaving;\n\t\tif_b_config.buf_vecs = vectors_per_buffer;\n\t\tif_b_config.buf_start_index = buf_offset_b;\n\t\tif_b_config.buf_increment = vmem_increment;\n\t\tif_b_config.buf_eol_offset =\n\t\t    buffer_width * bits_per_pixel / 8 - line_width;\n\t\tif_b_config.is_yuv420_format =\n\t\t    input_format == ATOMISP_INPUT_FORMAT_YUV420_8\n\t\t    || input_format == ATOMISP_INPUT_FORMAT_YUV420_10\n\t\t    || input_format == ATOMISP_INPUT_FORMAT_YUV420_16;\n\t\tif_b_config.block_no_reqs =\n\t\t    (config->mode != IA_CSS_INPUT_MODE_SENSOR);\n\n\t\tif (if_config_index != SH_CSS_IF_CONFIG_NOT_NEEDED) {\n\t\t\tassert(if_config_index <= SH_CSS_MAX_IF_CONFIGS);\n\n\t\t\tifmtr_set_if_blocking_mode(&if_a_config, &if_b_config);\n\t\t\t \n\t\t\tsh_css_sp_set_if_configs(&if_a_config, &if_b_config,\n\t\t\t\t\t\t if_config_index);\n\t\t}\n\t} else {\n\t\tif (if_config_index != SH_CSS_IF_CONFIG_NOT_NEEDED) {\n\t\t\tassert(if_config_index <= SH_CSS_MAX_IF_CONFIGS);\n\n\t\t\tifmtr_set_if_blocking_mode(&if_a_config, NULL);\n\t\t\t \n\t\t\tsh_css_sp_set_if_configs(&if_a_config, NULL,\n\t\t\t\t\t\t if_config_index);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nbool ifmtr_set_if_blocking_mode_reset = true;\n\n \nstatic void ifmtr_set_if_blocking_mode(\n    const input_formatter_cfg_t *const config_a,\n    const input_formatter_cfg_t *const config_b)\n{\n\tint i;\n\tbool block[] = { false, false, false, false };\n\n\tassert(N_INPUT_FORMATTER_ID <= (ARRAY_SIZE(block)));\n\n\tblock[INPUT_FORMATTER0_ID] = (bool)config_a->block_no_reqs;\n\tif (config_b)\n\t\tblock[INPUT_FORMATTER1_ID] = (bool)config_b->block_no_reqs;\n\n\t \n\t \n\tif (ifmtr_set_if_blocking_mode_reset) {\n\t\tifmtr_set_if_blocking_mode_reset = false;\n\t\tfor (i = 0; i < N_INPUT_FORMATTER_ID; i++) {\n\t\t\tinput_formatter_ID_t id = (input_formatter_ID_t)i;\n\n\t\t\tinput_formatter_rst(id);\n\t\t\tinput_formatter_set_fifo_blocking_mode(id, block[id]);\n\t\t}\n\t}\n\n\treturn;\n}\n\nstatic int ifmtr_start_column(\n    const struct ia_css_stream_config *config,\n    unsigned int bin_in,\n    unsigned int *start_column)\n{\n\tunsigned int in = config->input_config.input_res.width, start,\n\t\t     for_bayer = ia_css_ifmtr_columns_needed_for_bayer_order(config);\n\n\tif (bin_in + 2 * for_bayer > in)\n\t\treturn -EINVAL;\n\n\t \n\tstart = (in - bin_in) / 2;\n\t \n\tstart &= ~0x1;\n\n\t \n\tstart += for_bayer;\n\t*start_column = start;\n\treturn 0;\n}\n\nstatic int ifmtr_input_start_line(\n    const struct ia_css_stream_config *config,\n    unsigned int bin_in,\n    unsigned int *start_line)\n{\n\tunsigned int in = config->input_config.input_res.height, start,\n\t\t     for_bayer = ia_css_ifmtr_lines_needed_for_bayer_order(config);\n\n\tif (bin_in + 2 * for_bayer > in)\n\t\treturn -EINVAL;\n\n\t \n\tstart = (in - bin_in) / 2;\n\t \n\tstart &= ~0x1;\n\n\t \n\tstart += for_bayer;\n\t*start_line = start;\n\treturn 0;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}