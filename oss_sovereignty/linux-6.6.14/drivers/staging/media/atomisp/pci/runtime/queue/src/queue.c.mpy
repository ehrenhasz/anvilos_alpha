{
  "module_name": "queue.c",
  "hash_id": "8ad5485576e4282e788414fb98c3508da61caef9499cbab15998cf9acf8e357f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/runtime/queue/src/queue.c",
  "human_readable_source": "\n \n\n#include \"ia_css_queue.h\"\n#include <math_support.h>\n#include <ia_css_circbuf.h>\n#include <ia_css_circbuf_desc.h>\n#include \"queue_access.h\"\n\n \nint ia_css_queue_local_init(ia_css_queue_t *qhandle, ia_css_queue_local_t *desc)\n{\n\tif (NULL == qhandle || NULL == desc\n\t    || NULL == desc->cb_elems || NULL == desc->cb_desc) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tqhandle->type = IA_CSS_QUEUE_TYPE_LOCAL;\n\n\t \n\tia_css_circbuf_create(&qhandle->desc.cb_local,\n\t\t\t      desc->cb_elems,\n\t\t\t      desc->cb_desc);\n\n\treturn 0;\n}\n\nint ia_css_queue_remote_init(ia_css_queue_t *qhandle, ia_css_queue_remote_t *desc)\n{\n\tif (NULL == qhandle || NULL == desc) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tqhandle->type = IA_CSS_QUEUE_TYPE_REMOTE;\n\n\t \n\tqhandle->location = desc->location;\n\tqhandle->proc_id = desc->proc_id;\n\tqhandle->desc.remote.cb_desc_addr = desc->cb_desc_addr;\n\tqhandle->desc.remote.cb_elems_addr = desc->cb_elems_addr;\n\n\t \n\n\treturn 0;\n}\n\nint ia_css_queue_uninit(ia_css_queue_t *qhandle)\n{\n\tif (!qhandle)\n\t\treturn -EINVAL;\n\n\t \n\tif (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {\n\t\t \n\t\tia_css_circbuf_destroy(&qhandle->desc.cb_local);\n\t}\n\n\treturn 0;\n}\n\nint ia_css_queue_enqueue(ia_css_queue_t *qhandle, uint32_t item)\n{\n\tint error = 0;\n\n\tif (!qhandle)\n\t\treturn -EINVAL;\n\n\t \n\tif (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {\n\t\t \n\t\tif (ia_css_circbuf_is_full(&qhandle->desc.cb_local)) {\n\t\t\t \n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\t \n\t\tia_css_circbuf_push(&qhandle->desc.cb_local, item);\n\t} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {\n\t\tia_css_circbuf_desc_t cb_desc;\n\t\tia_css_circbuf_elem_t cb_elem;\n\t\tu32 ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;\n\n\t\t \n\t\tQUEUE_CB_DESC_INIT(&cb_desc);\n\t\terror = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);\n\t\tif (error != 0)\n\t\t\treturn error;\n\n\t\t \n\t\tif (ia_css_circbuf_desc_is_full(&cb_desc))\n\t\t\treturn -ENOBUFS;\n\n\t\tcb_elem.val = item;\n\n\t\terror = ia_css_queue_item_store(qhandle, cb_desc.end, &cb_elem);\n\t\tif (error != 0)\n\t\t\treturn error;\n\n\t\tcb_desc.end = (cb_desc.end + 1) % cb_desc.size;\n\n\t\t \n\t\t \n\t\tignore_desc_flags = QUEUE_IGNORE_SIZE_START_STEP_FLAGS;\n\n\t\terror = ia_css_queue_store(qhandle, &cb_desc, ignore_desc_flags);\n\t\tif (error != 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nint ia_css_queue_dequeue(ia_css_queue_t *qhandle, uint32_t *item)\n{\n\tint error = 0;\n\n\tif (!qhandle || NULL == item)\n\t\treturn -EINVAL;\n\n\t \n\tif (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {\n\t\t \n\t\tif (ia_css_circbuf_is_empty(&qhandle->desc.cb_local)) {\n\t\t\t \n\t\t\treturn -ENODATA;\n\t\t}\n\n\t\t*item = ia_css_circbuf_pop(&qhandle->desc.cb_local);\n\t} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {\n\t\t \n\t\tia_css_circbuf_desc_t cb_desc;\n\t\tia_css_circbuf_elem_t cb_elem;\n\t\tu32 ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;\n\n\t\tQUEUE_CB_DESC_INIT(&cb_desc);\n\n\t\terror = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);\n\t\tif (error != 0)\n\t\t\treturn error;\n\n\t\t \n\t\tif (ia_css_circbuf_desc_is_empty(&cb_desc))\n\t\t\treturn -ENODATA;\n\n\t\terror = ia_css_queue_item_load(qhandle, cb_desc.start, &cb_elem);\n\t\tif (error != 0)\n\t\t\treturn error;\n\n\t\t*item = cb_elem.val;\n\n\t\tcb_desc.start = OP_std_modadd(cb_desc.start, 1, cb_desc.size);\n\n\t\t \n\t\t \n\t\tignore_desc_flags = QUEUE_IGNORE_SIZE_END_STEP_FLAGS;\n\t\terror = ia_css_queue_store(qhandle, &cb_desc, ignore_desc_flags);\n\t\tif (error != 0)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}\n\nint ia_css_queue_is_full(ia_css_queue_t *qhandle, bool *is_full)\n{\n\tint error = 0;\n\n\tif ((!qhandle) || (!is_full))\n\t\treturn -EINVAL;\n\n\t \n\tif (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {\n\t\t \n\t\t*is_full = ia_css_circbuf_is_full(&qhandle->desc.cb_local);\n\t\treturn 0;\n\t} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {\n\t\t \n\t\tia_css_circbuf_desc_t cb_desc;\n\t\tu32 ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;\n\n\t\tQUEUE_CB_DESC_INIT(&cb_desc);\n\t\terror = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);\n\t\tif (error != 0)\n\t\t\treturn error;\n\n\t\t \n\t\t*is_full = ia_css_circbuf_desc_is_full(&cb_desc);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nint ia_css_queue_get_free_space(ia_css_queue_t *qhandle, uint32_t *size)\n{\n\tint error = 0;\n\n\tif ((!qhandle) || (!size))\n\t\treturn -EINVAL;\n\n\t \n\tif (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {\n\t\t \n\t\t*size = ia_css_circbuf_get_free_elems(&qhandle->desc.cb_local);\n\t\treturn 0;\n\t} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {\n\t\t \n\t\tia_css_circbuf_desc_t cb_desc;\n\t\tu32 ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;\n\n\t\tQUEUE_CB_DESC_INIT(&cb_desc);\n\t\terror = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);\n\t\tif (error != 0)\n\t\t\treturn error;\n\n\t\t \n\t\t*size = ia_css_circbuf_desc_get_free_elems(&cb_desc);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nint ia_css_queue_get_used_space(ia_css_queue_t *qhandle, uint32_t *size)\n{\n\tint error = 0;\n\n\tif ((!qhandle) || (!size))\n\t\treturn -EINVAL;\n\n\t \n\tif (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {\n\t\t \n\t\t*size = ia_css_circbuf_get_num_elems(&qhandle->desc.cb_local);\n\t\treturn 0;\n\t} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {\n\t\t \n\t\tia_css_circbuf_desc_t cb_desc;\n\t\tu32 ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;\n\n\t\tQUEUE_CB_DESC_INIT(&cb_desc);\n\t\terror = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);\n\t\tif (error != 0)\n\t\t\treturn error;\n\n\t\t \n\t\t*size = ia_css_circbuf_desc_get_num_elems(&cb_desc);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nint ia_css_queue_peek(ia_css_queue_t *qhandle, u32 offset, uint32_t *element)\n{\n\tu32 num_elems = 0;\n\tint error = 0;\n\n\tif ((!qhandle) || (!element))\n\t\treturn -EINVAL;\n\n\t \n\tif (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {\n\t\t \n\t\t \n\t\tnum_elems = ia_css_circbuf_get_num_elems(&qhandle->desc.cb_local);\n\t\tif (offset > num_elems)\n\t\t\treturn -EINVAL;\n\n\t\t*element = ia_css_circbuf_peek_from_start(&qhandle->desc.cb_local, (int)offset);\n\t\treturn 0;\n\t} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {\n\t\t \n\t\tia_css_circbuf_desc_t cb_desc;\n\t\tia_css_circbuf_elem_t cb_elem;\n\t\tu32 ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;\n\n\t\tQUEUE_CB_DESC_INIT(&cb_desc);\n\n\t\terror =  ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);\n\t\tif (error != 0)\n\t\t\treturn error;\n\n\t\t \n\t\tnum_elems = ia_css_circbuf_desc_get_num_elems(&cb_desc);\n\t\tif (offset > num_elems)\n\t\t\treturn -EINVAL;\n\n\t\toffset = OP_std_modadd(cb_desc.start, offset, cb_desc.size);\n\t\terror = ia_css_queue_item_load(qhandle, (uint8_t)offset, &cb_elem);\n\t\tif (error != 0)\n\t\t\treturn error;\n\n\t\t*element = cb_elem.val;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nint ia_css_queue_is_empty(ia_css_queue_t *qhandle, bool *is_empty)\n{\n\tint error = 0;\n\n\tif ((!qhandle) || (!is_empty))\n\t\treturn -EINVAL;\n\n\t \n\tif (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {\n\t\t \n\t\t*is_empty = ia_css_circbuf_is_empty(&qhandle->desc.cb_local);\n\t\treturn 0;\n\t} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {\n\t\t \n\t\tia_css_circbuf_desc_t cb_desc;\n\t\tu32 ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;\n\n\t\tQUEUE_CB_DESC_INIT(&cb_desc);\n\t\terror = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);\n\t\tif (error != 0)\n\t\t\treturn error;\n\n\t\t \n\t\t*is_empty = ia_css_circbuf_desc_is_empty(&cb_desc);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nint ia_css_queue_get_size(ia_css_queue_t *qhandle, uint32_t *size)\n{\n\tint error = 0;\n\n\tif ((!qhandle) || (!size))\n\t\treturn -EINVAL;\n\n\t \n\tif (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {\n\t\t \n\t\t \n\t\t*size = ia_css_circbuf_get_size(&qhandle->desc.cb_local);\n\t} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {\n\t\t \n\t\tia_css_circbuf_desc_t cb_desc;\n\t\tu32 ignore_desc_flags = QUEUE_IGNORE_START_END_STEP_FLAGS;\n\n\t\tQUEUE_CB_DESC_INIT(&cb_desc);\n\n\t\terror = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);\n\t\tif (error != 0)\n\t\t\treturn error;\n\n\t\t \n\t\t*size = cb_desc.size;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}