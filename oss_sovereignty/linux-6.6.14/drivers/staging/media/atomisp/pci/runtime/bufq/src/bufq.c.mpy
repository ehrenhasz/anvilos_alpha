{
  "module_name": "bufq.c",
  "hash_id": "17d13b0d5a412878a5c5a5068b122aa56e77afafb2658d38cc546c5a27373418",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/runtime/bufq/src/bufq.c",
  "human_readable_source": "\n \n\n#include \"assert_support.h\"\t\t \n#include \"ia_css_buffer.h\"\n#include \"sp.h\"\n#include \"ia_css_bufq.h\"\t\t \n#include \"ia_css_queue.h\"\t\t \n#include \"sw_event_global.h\"\t\t \n#include \"ia_css_eventq.h\"\t\t \n#include \"ia_css_debug.h\"\t\t \n#include \"sh_css_internal.h\"\t\t \n#include \"sp_local.h\"\t\t\t \n#include \"sh_css_firmware.h\"\t\t \n\n#define BUFQ_DUMP_FILE_NAME_PREFIX_SIZE 256\n\nstatic char prefix[BUFQ_DUMP_FILE_NAME_PREFIX_SIZE] = {0};\n\n \n \n \n\nstruct sh_css_queues {\n\t \n\tia_css_queue_t host2sp_buffer_queue_handles\n\t[SH_CSS_MAX_SP_THREADS][SH_CSS_MAX_NUM_QUEUES];\n\t \n\tia_css_queue_t sp2host_buffer_queue_handles\n\t[SH_CSS_MAX_NUM_QUEUES];\n\n\t \n\tia_css_queue_t host2sp_psys_event_queue_handle;\n\n\t \n\tia_css_queue_t sp2host_psys_event_queue_handle;\n\n\t \n\tia_css_queue_t host2sp_isys_event_queue_handle;\n\n\t \n\tia_css_queue_t sp2host_isys_event_queue_handle;\n\t \n\tia_css_queue_t host2sp_tag_cmd_queue_handle;\n};\n\n \nstatic struct sh_css_queues css_queues;\n\nstatic int\nbuffer_type_to_queue_id_map[SH_CSS_MAX_SP_THREADS][IA_CSS_NUM_DYNAMIC_BUFFER_TYPE];\nstatic bool queue_availability[SH_CSS_MAX_SP_THREADS][SH_CSS_MAX_NUM_QUEUES];\n\n \nstatic void map_buffer_type_to_queue_id(\n    unsigned int thread_id,\n    enum ia_css_buffer_type buf_type\n);\nstatic void unmap_buffer_type_to_queue_id(\n    unsigned int thread_id,\n    enum ia_css_buffer_type buf_type\n);\n\nstatic ia_css_queue_t *bufq_get_qhandle(\n    enum sh_css_queue_type type,\n    enum sh_css_queue_id id,\n    int thread\n);\n\n \nvoid ia_css_queue_map_init(void)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0; i < SH_CSS_MAX_SP_THREADS; i++) {\n\t\tfor (j = 0; j < SH_CSS_MAX_NUM_QUEUES; j++)\n\t\t\tqueue_availability[i][j] = true;\n\t}\n\n\tfor (i = 0; i < SH_CSS_MAX_SP_THREADS; i++) {\n\t\tfor (j = 0; j < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE; j++)\n\t\t\tbuffer_type_to_queue_id_map[i][j] = SH_CSS_INVALID_QUEUE_ID;\n\t}\n}\n\nvoid ia_css_queue_map(\n    unsigned int thread_id,\n    enum ia_css_buffer_type buf_type,\n    bool map)\n{\n\tassert(buf_type < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE);\n\tassert(thread_id < SH_CSS_MAX_SP_THREADS);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"ia_css_queue_map() enter: buf_type=%d, thread_id=%d\\n\", buf_type, thread_id);\n\n\tif (map)\n\t\tmap_buffer_type_to_queue_id(thread_id, buf_type);\n\telse\n\t\tunmap_buffer_type_to_queue_id(thread_id, buf_type);\n}\n\n \nbool ia_css_query_internal_queue_id(\n    enum ia_css_buffer_type buf_type,\n    unsigned int thread_id,\n    enum sh_css_queue_id *val)\n{\n\tIA_CSS_ENTER(\"buf_type=%d, thread_id=%d, val = %p\", buf_type, thread_id, val);\n\n\tif ((!val) || (thread_id >= SH_CSS_MAX_SP_THREADS) ||\n\t    (buf_type >= IA_CSS_NUM_DYNAMIC_BUFFER_TYPE)) {\n\t\tIA_CSS_LEAVE(\"return_val = false\");\n\t\treturn false;\n\t}\n\n\t*val = buffer_type_to_queue_id_map[thread_id][buf_type];\n\tif ((*val == SH_CSS_INVALID_QUEUE_ID) || (*val >= SH_CSS_MAX_NUM_QUEUES)) {\n\t\tIA_CSS_LOG(\"INVALID queue ID MAP = %d\\n\", *val);\n\t\tIA_CSS_LEAVE(\"return_val = false\");\n\t\treturn false;\n\t}\n\tIA_CSS_LEAVE(\"return_val = true\");\n\treturn true;\n}\n\n \nstatic void map_buffer_type_to_queue_id(\n    unsigned int thread_id,\n    enum ia_css_buffer_type buf_type)\n{\n\tunsigned int i;\n\n\tassert(thread_id < SH_CSS_MAX_SP_THREADS);\n\tassert(buf_type < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE);\n\tassert(buffer_type_to_queue_id_map[thread_id][buf_type] ==\n\t       SH_CSS_INVALID_QUEUE_ID);\n\n\t \n\tif (buf_type == IA_CSS_BUFFER_TYPE_PARAMETER_SET) {\n\t\tassert(queue_availability[thread_id][IA_CSS_PARAMETER_SET_QUEUE_ID]);\n\t\tqueue_availability[thread_id][IA_CSS_PARAMETER_SET_QUEUE_ID] = false;\n\t\tbuffer_type_to_queue_id_map[thread_id][buf_type] =\n\t\t    IA_CSS_PARAMETER_SET_QUEUE_ID;\n\t\treturn;\n\t}\n\n\t \n\tif (buf_type == IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET) {\n\t\tassert(queue_availability[thread_id][IA_CSS_PER_FRAME_PARAMETER_SET_QUEUE_ID]);\n\t\tqueue_availability[thread_id][IA_CSS_PER_FRAME_PARAMETER_SET_QUEUE_ID] = false;\n\t\tbuffer_type_to_queue_id_map[thread_id][buf_type] =\n\t\t    IA_CSS_PER_FRAME_PARAMETER_SET_QUEUE_ID;\n\t\treturn;\n\t}\n\n\tfor (i = SH_CSS_QUEUE_C_ID; i < SH_CSS_MAX_NUM_QUEUES; i++) {\n\t\tif (queue_availability[thread_id][i]) {\n\t\t\tqueue_availability[thread_id][i] = false;\n\t\t\tbuffer_type_to_queue_id_map[thread_id][buf_type] = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tassert(i != SH_CSS_MAX_NUM_QUEUES);\n\treturn;\n}\n\nstatic void unmap_buffer_type_to_queue_id(\n    unsigned int thread_id,\n    enum ia_css_buffer_type buf_type)\n{\n\tint queue_id;\n\n\tassert(thread_id < SH_CSS_MAX_SP_THREADS);\n\tassert(buf_type < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE);\n\tassert(buffer_type_to_queue_id_map[thread_id][buf_type] !=\n\t       SH_CSS_INVALID_QUEUE_ID);\n\n\tqueue_id = buffer_type_to_queue_id_map[thread_id][buf_type];\n\tbuffer_type_to_queue_id_map[thread_id][buf_type] = SH_CSS_INVALID_QUEUE_ID;\n\tqueue_availability[thread_id][queue_id] = true;\n}\n\nstatic ia_css_queue_t *bufq_get_qhandle(\n    enum sh_css_queue_type type,\n    enum sh_css_queue_id id,\n    int thread)\n{\n\tia_css_queue_t *q = NULL;\n\n\tswitch (type) {\n\tcase sh_css_host2sp_buffer_queue:\n\t\tif ((thread >= SH_CSS_MAX_SP_THREADS) || (thread < 0) ||\n\t\t    (id == SH_CSS_INVALID_QUEUE_ID))\n\t\t\tbreak;\n\t\tq = &css_queues.host2sp_buffer_queue_handles[thread][id];\n\t\tbreak;\n\tcase sh_css_sp2host_buffer_queue:\n\t\tif (id == SH_CSS_INVALID_QUEUE_ID)\n\t\t\tbreak;\n\t\tq = &css_queues.sp2host_buffer_queue_handles[id];\n\t\tbreak;\n\tcase sh_css_host2sp_psys_event_queue:\n\t\tq = &css_queues.host2sp_psys_event_queue_handle;\n\t\tbreak;\n\tcase sh_css_sp2host_psys_event_queue:\n\t\tq = &css_queues.sp2host_psys_event_queue_handle;\n\t\tbreak;\n\tcase sh_css_host2sp_isys_event_queue:\n\t\tq = &css_queues.host2sp_isys_event_queue_handle;\n\t\tbreak;\n\tcase sh_css_sp2host_isys_event_queue:\n\t\tq = &css_queues.sp2host_isys_event_queue_handle;\n\t\tbreak;\n\tcase sh_css_host2sp_tag_cmd_queue:\n\t\tq = &css_queues.host2sp_tag_cmd_queue_handle;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn q;\n}\n\n \nstatic inline void\ninit_bufq(unsigned int desc_offset,\n\t  unsigned int elems_offset,\n\t  ia_css_queue_t *handle)\n{\n\tconst struct ia_css_fw_info *fw;\n\tunsigned int q_base_addr;\n\tia_css_queue_remote_t remoteq;\n\n\tfw = &sh_css_sp_fw;\n\tq_base_addr = fw->info.sp.host_sp_queue;\n\n\t \n\tremoteq.location = IA_CSS_QUEUE_LOC_SP;\n\tremoteq.proc_id = SP0_ID;\n\tremoteq.cb_desc_addr = q_base_addr + desc_offset;\n\tremoteq.cb_elems_addr = q_base_addr + elems_offset;\n\t \n\tia_css_queue_remote_init(handle, &remoteq);\n}\n\nvoid ia_css_bufq_init(void)\n{\n\tint i, j;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\n\t \n\tfor (i = 0; i < SH_CSS_MAX_SP_THREADS; i++)\n\t\tfor (j = 0; j < SH_CSS_MAX_NUM_QUEUES; j++) {\n\t\t\tinit_bufq((uint32_t)offsetof(struct host_sp_queues,\n\t\t\t\t\t\t     host2sp_buffer_queues_desc[i][j]),\n\t\t\t\t  (uint32_t)offsetof(struct host_sp_queues, host2sp_buffer_queues_elems[i][j]),\n\t\t\t\t  &css_queues.host2sp_buffer_queue_handles[i][j]);\n\t\t}\n\n\t \n\tfor (i = 0; i < SH_CSS_MAX_NUM_QUEUES; i++) {\n\t\tinit_bufq(offsetof(struct host_sp_queues, sp2host_buffer_queues_desc[i]),\n\t\t\t  offsetof(struct host_sp_queues, sp2host_buffer_queues_elems[i]),\n\t\t\t  &css_queues.sp2host_buffer_queue_handles[i]);\n\t}\n\n\t \n\tinit_bufq((uint32_t)offsetof(struct host_sp_queues,\n\t\t\t\t     host2sp_psys_event_queue_desc),\n\t\t  (uint32_t)offsetof(struct host_sp_queues, host2sp_psys_event_queue_elems),\n\t\t  &css_queues.host2sp_psys_event_queue_handle);\n\n\t \n\tinit_bufq((uint32_t)offsetof(struct host_sp_queues,\n\t\t\t\t     sp2host_psys_event_queue_desc),\n\t\t  (uint32_t)offsetof(struct host_sp_queues, sp2host_psys_event_queue_elems),\n\t\t  &css_queues.sp2host_psys_event_queue_handle);\n\n\t \n\tinit_bufq((uint32_t)offsetof(struct host_sp_queues,\n\t\t\t\t     host2sp_isys_event_queue_desc),\n\t\t  (uint32_t)offsetof(struct host_sp_queues, host2sp_isys_event_queue_elems),\n\t\t  &css_queues.host2sp_isys_event_queue_handle);\n\n\t \n\tinit_bufq((uint32_t)offsetof(struct host_sp_queues,\n\t\t\t\t     sp2host_isys_event_queue_desc),\n\t\t  (uint32_t)offsetof(struct host_sp_queues, sp2host_isys_event_queue_elems),\n\t\t  &css_queues.sp2host_isys_event_queue_handle);\n\n\t \n\tinit_bufq((uint32_t)offsetof(struct host_sp_queues, host2sp_tag_cmd_queue_desc),\n\t\t  (uint32_t)offsetof(struct host_sp_queues, host2sp_tag_cmd_queue_elems),\n\t\t  &css_queues.host2sp_tag_cmd_queue_handle);\n\n\tIA_CSS_LEAVE_PRIVATE(\"\");\n}\n\nint ia_css_bufq_enqueue_buffer(\n    int thread_index,\n    int queue_id,\n    uint32_t item)\n{\n\tia_css_queue_t *q;\n\tint error;\n\n\tIA_CSS_ENTER_PRIVATE(\"queue_id=%d\", queue_id);\n\tif ((thread_index >= SH_CSS_MAX_SP_THREADS) || (thread_index < 0) ||\n\t    (queue_id == SH_CSS_INVALID_QUEUE_ID))\n\t\treturn -EINVAL;\n\n\t \n\tq = bufq_get_qhandle(sh_css_host2sp_buffer_queue,\n\t\t\t     queue_id,\n\t\t\t     thread_index);\n\tif (q) {\n\t\terror = ia_css_queue_enqueue(q, item);\n\t} else {\n\t\tIA_CSS_ERROR(\"queue is not initialized\");\n\t\terror = -EBUSY;\n\t}\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(error);\n\treturn error;\n}\n\nint ia_css_bufq_dequeue_buffer(\n    int queue_id,\n    uint32_t *item)\n{\n\tint error;\n\tia_css_queue_t *q;\n\n\tIA_CSS_ENTER_PRIVATE(\"queue_id=%d\", queue_id);\n\tif ((!item) ||\n\t    (queue_id <= SH_CSS_INVALID_QUEUE_ID) ||\n\t    (queue_id >= SH_CSS_MAX_NUM_QUEUES)\n\t   )\n\t\treturn -EINVAL;\n\n\tq = bufq_get_qhandle(sh_css_sp2host_buffer_queue,\n\t\t\t     queue_id,\n\t\t\t     -1);\n\tif (q) {\n\t\terror = ia_css_queue_dequeue(q, item);\n\t} else {\n\t\tIA_CSS_ERROR(\"queue is not initialized\");\n\t\terror = -EBUSY;\n\t}\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(error);\n\treturn error;\n}\n\nint ia_css_bufq_enqueue_psys_event(\n    u8 evt_id,\n    u8 evt_payload_0,\n    u8 evt_payload_1,\n    uint8_t evt_payload_2)\n{\n\tint error = 0;\n\tia_css_queue_t *q;\n\n\tIA_CSS_ENTER_PRIVATE(\"evt_id=%d\", evt_id);\n\tq = bufq_get_qhandle(sh_css_host2sp_psys_event_queue, -1, -1);\n\tif (!q) {\n\t\tIA_CSS_ERROR(\"queue is not initialized\");\n\t\treturn -EBUSY;\n\t}\n\n\terror = ia_css_eventq_send(q,\n\t\t\t\t   evt_id, evt_payload_0, evt_payload_1, evt_payload_2);\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(error);\n\treturn error;\n}\n\nint ia_css_bufq_dequeue_psys_event(\n    u8 item[BUFQ_EVENT_SIZE])\n{\n\tint error = 0;\n\tia_css_queue_t *q;\n\n\t \n\tif (!item)\n\t\treturn -EINVAL;\n\n\tq = bufq_get_qhandle(sh_css_sp2host_psys_event_queue, -1, -1);\n\tif (!q) {\n\t\tIA_CSS_ERROR(\"queue is not initialized\");\n\t\treturn -EBUSY;\n\t}\n\terror = ia_css_eventq_recv(q, item);\n\n\treturn error;\n}\n\nint ia_css_bufq_dequeue_isys_event(\n    u8 item[BUFQ_EVENT_SIZE])\n{\n\tint error = 0;\n\tia_css_queue_t *q;\n\n\t \n\tif (!item)\n\t\treturn -EINVAL;\n\n\tq = bufq_get_qhandle(sh_css_sp2host_isys_event_queue, -1, -1);\n\tif (!q) {\n\t\tIA_CSS_ERROR(\"queue is not initialized\");\n\t\treturn -EBUSY;\n\t}\n\terror = ia_css_eventq_recv(q, item);\n\treturn error;\n}\n\nint ia_css_bufq_enqueue_isys_event(uint8_t evt_id)\n{\n\tint error = 0;\n\tia_css_queue_t *q;\n\n\tIA_CSS_ENTER_PRIVATE(\"event_id=%d\", evt_id);\n\tq = bufq_get_qhandle(sh_css_host2sp_isys_event_queue, -1, -1);\n\tif (!q) {\n\t\tIA_CSS_ERROR(\"queue is not initialized\");\n\t\treturn -EBUSY;\n\t}\n\n\terror = ia_css_eventq_send(q, evt_id, 0, 0, 0);\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(error);\n\treturn error;\n}\n\nint ia_css_bufq_enqueue_tag_cmd(\n    uint32_t item)\n{\n\tint error;\n\tia_css_queue_t *q;\n\n\tIA_CSS_ENTER_PRIVATE(\"item=%d\", item);\n\tq = bufq_get_qhandle(sh_css_host2sp_tag_cmd_queue, -1, -1);\n\tif (!q) {\n\t\tIA_CSS_ERROR(\"queue is not initialized\");\n\t\treturn -EBUSY;\n\t}\n\terror = ia_css_queue_enqueue(q, item);\n\n\tIA_CSS_LEAVE_ERR_PRIVATE(error);\n\treturn error;\n}\n\nint ia_css_bufq_deinit(void)\n{\n\treturn 0;\n}\n\nstatic void bufq_dump_queue_info(const char *prefix, ia_css_queue_t *qhandle)\n{\n\tu32 free = 0, used = 0;\n\n\tassert(prefix && qhandle);\n\tia_css_queue_get_used_space(qhandle, &used);\n\tia_css_queue_get_free_space(qhandle, &free);\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%s: used=%u free=%u\\n\",\n\t\t\t    prefix, used, free);\n}\n\nvoid ia_css_bufq_dump_queue_info(void)\n{\n\tint i, j;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"Queue Information:\\n\");\n\n\tfor (i = 0; i < SH_CSS_MAX_SP_THREADS; i++) {\n\t\tfor (j = 0; j < SH_CSS_MAX_NUM_QUEUES; j++) {\n\t\t\tsnprintf(prefix, BUFQ_DUMP_FILE_NAME_PREFIX_SIZE,\n\t\t\t\t \"host2sp_buffer_queue[%u][%u]\", i, j);\n\t\t\tbufq_dump_queue_info(prefix,\n\t\t\t\t\t     &css_queues.host2sp_buffer_queue_handles[i][j]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < SH_CSS_MAX_NUM_QUEUES; i++) {\n\t\tsnprintf(prefix, BUFQ_DUMP_FILE_NAME_PREFIX_SIZE,\n\t\t\t \"sp2host_buffer_queue[%u]\", i);\n\t\tbufq_dump_queue_info(prefix,\n\t\t\t\t     &css_queues.sp2host_buffer_queue_handles[i]);\n\t}\n\tbufq_dump_queue_info(\"host2sp_psys_event\",\n\t\t\t     &css_queues.host2sp_psys_event_queue_handle);\n\tbufq_dump_queue_info(\"sp2host_psys_event\",\n\t\t\t     &css_queues.sp2host_psys_event_queue_handle);\n\n\tbufq_dump_queue_info(\"host2sp_isys_event\",\n\t\t\t     &css_queues.host2sp_isys_event_queue_handle);\n\tbufq_dump_queue_info(\"sp2host_isys_event\",\n\t\t\t     &css_queues.sp2host_isys_event_queue_handle);\n\tbufq_dump_queue_info(\"host2sp_tag_cmd\",\n\t\t\t     &css_queues.host2sp_tag_cmd_queue_handle);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}