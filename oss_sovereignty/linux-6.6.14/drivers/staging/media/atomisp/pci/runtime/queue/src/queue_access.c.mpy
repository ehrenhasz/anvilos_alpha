{
  "module_name": "queue_access.c",
  "hash_id": "f570f800c73aea7e4533818a2ce7a4cff1eebad37ffceca53077c1586fd8bc0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/runtime/queue/src/queue_access.c",
  "human_readable_source": "\n \n\n#include \"hmm.h\"\n\n#include \"type_support.h\"\n#include \"queue_access.h\"\n#include \"ia_css_circbuf.h\"\n#include \"sp.h\"\n#include \"assert_support.h\"\n\nint ia_css_queue_load(\n    struct ia_css_queue *rdesc,\n    ia_css_circbuf_desc_t *cb_desc,\n    uint32_t ignore_desc_flags)\n{\n\tif (!rdesc || !cb_desc)\n\t\treturn -EINVAL;\n\n\tif (rdesc->location == IA_CSS_QUEUE_LOC_SP) {\n\t\tassert(ignore_desc_flags <= QUEUE_IGNORE_DESC_FLAGS_MAX);\n\n\t\tif (0 == (ignore_desc_flags & QUEUE_IGNORE_SIZE_FLAG)) {\n\t\t\tcb_desc->size = sp_dmem_load_uint8(rdesc->proc_id,\n\t\t\t\t\t\t\t   rdesc->desc.remote.cb_desc_addr\n\t\t\t\t\t\t\t   + offsetof(ia_css_circbuf_desc_t, size));\n\n\t\t\tif (cb_desc->size == 0) {\n\t\t\t\t \n\t\t\t\treturn -EDOM;\n\t\t\t}\n\t\t}\n\n\t\tif (0 == (ignore_desc_flags & QUEUE_IGNORE_START_FLAG))\n\t\t\tcb_desc->start = sp_dmem_load_uint8(rdesc->proc_id,\n\t\t\t\t\t\t\t    rdesc->desc.remote.cb_desc_addr\n\t\t\t\t\t\t\t    + offsetof(ia_css_circbuf_desc_t, start));\n\n\t\tif (0 == (ignore_desc_flags & QUEUE_IGNORE_END_FLAG))\n\t\t\tcb_desc->end = sp_dmem_load_uint8(rdesc->proc_id,\n\t\t\t\t\t\t\t  rdesc->desc.remote.cb_desc_addr\n\t\t\t\t\t\t\t  + offsetof(ia_css_circbuf_desc_t, end));\n\n\t\tif (0 == (ignore_desc_flags & QUEUE_IGNORE_STEP_FLAG))\n\t\t\tcb_desc->step = sp_dmem_load_uint8(rdesc->proc_id,\n\t\t\t\t\t\t\t   rdesc->desc.remote.cb_desc_addr\n\t\t\t\t\t\t\t   + offsetof(ia_css_circbuf_desc_t, step));\n\n\t} else if (rdesc->location == IA_CSS_QUEUE_LOC_HOST) {\n\t\t \n\t\thmm_load(rdesc->desc.remote.cb_desc_addr,\n\t\t\t  (void *)cb_desc,\n\t\t\t  sizeof(ia_css_circbuf_desc_t));\n\t} else if (rdesc->location == IA_CSS_QUEUE_LOC_ISP) {\n\t\t \n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint ia_css_queue_store(\n    struct ia_css_queue *rdesc,\n    ia_css_circbuf_desc_t *cb_desc,\n    uint32_t ignore_desc_flags)\n{\n\tif (!rdesc || !cb_desc)\n\t\treturn -EINVAL;\n\n\tif (rdesc->location == IA_CSS_QUEUE_LOC_SP) {\n\t\tassert(ignore_desc_flags <= QUEUE_IGNORE_DESC_FLAGS_MAX);\n\n\t\tif (0 == (ignore_desc_flags & QUEUE_IGNORE_SIZE_FLAG))\n\t\t\tsp_dmem_store_uint8(rdesc->proc_id,\n\t\t\t\t\t    rdesc->desc.remote.cb_desc_addr\n\t\t\t\t\t    + offsetof(ia_css_circbuf_desc_t, size),\n\t\t\t\t\t    cb_desc->size);\n\n\t\tif (0 == (ignore_desc_flags & QUEUE_IGNORE_START_FLAG))\n\t\t\tsp_dmem_store_uint8(rdesc->proc_id,\n\t\t\t\t\t    rdesc->desc.remote.cb_desc_addr\n\t\t\t\t\t    + offsetof(ia_css_circbuf_desc_t, start),\n\t\t\t\t\t    cb_desc->start);\n\n\t\tif (0 == (ignore_desc_flags & QUEUE_IGNORE_END_FLAG))\n\t\t\tsp_dmem_store_uint8(rdesc->proc_id,\n\t\t\t\t\t    rdesc->desc.remote.cb_desc_addr\n\t\t\t\t\t    + offsetof(ia_css_circbuf_desc_t, end),\n\t\t\t\t\t    cb_desc->end);\n\n\t\tif (0 == (ignore_desc_flags & QUEUE_IGNORE_STEP_FLAG))\n\t\t\tsp_dmem_store_uint8(rdesc->proc_id,\n\t\t\t\t\t    rdesc->desc.remote.cb_desc_addr\n\t\t\t\t\t    + offsetof(ia_css_circbuf_desc_t, step),\n\t\t\t\t\t    cb_desc->step);\n\t} else if (rdesc->location == IA_CSS_QUEUE_LOC_HOST) {\n\t\t \n\t\thmm_store(rdesc->desc.remote.cb_desc_addr,\n\t\t\t   (void *)cb_desc,\n\t\t\t   sizeof(ia_css_circbuf_desc_t));\n\t} else if (rdesc->location == IA_CSS_QUEUE_LOC_ISP) {\n\t\t \n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint ia_css_queue_item_load(\n    struct ia_css_queue *rdesc,\n    u8 position,\n    ia_css_circbuf_elem_t *item)\n{\n\tif (!rdesc || !item)\n\t\treturn -EINVAL;\n\n\tif (rdesc->location == IA_CSS_QUEUE_LOC_SP) {\n\t\tsp_dmem_load(rdesc->proc_id,\n\t\t\t     rdesc->desc.remote.cb_elems_addr\n\t\t\t     + position * sizeof(ia_css_circbuf_elem_t),\n\t\t\t     item,\n\t\t\t     sizeof(ia_css_circbuf_elem_t));\n\t} else if (rdesc->location == IA_CSS_QUEUE_LOC_HOST) {\n\t\thmm_load(rdesc->desc.remote.cb_elems_addr\n\t\t\t  + position * sizeof(ia_css_circbuf_elem_t),\n\t\t\t  (void *)item,\n\t\t\t  sizeof(ia_css_circbuf_elem_t));\n\t} else if (rdesc->location == IA_CSS_QUEUE_LOC_ISP) {\n\t\t \n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint ia_css_queue_item_store(\n    struct ia_css_queue *rdesc,\n    u8 position,\n    ia_css_circbuf_elem_t *item)\n{\n\tif (!rdesc || !item)\n\t\treturn -EINVAL;\n\n\tif (rdesc->location == IA_CSS_QUEUE_LOC_SP) {\n\t\tsp_dmem_store(rdesc->proc_id,\n\t\t\t      rdesc->desc.remote.cb_elems_addr\n\t\t\t      + position * sizeof(ia_css_circbuf_elem_t),\n\t\t\t      item,\n\t\t\t      sizeof(ia_css_circbuf_elem_t));\n\t} else if (rdesc->location == IA_CSS_QUEUE_LOC_HOST) {\n\t\thmm_store(rdesc->desc.remote.cb_elems_addr\n\t\t\t   + position * sizeof(ia_css_circbuf_elem_t),\n\t\t\t   (void *)item,\n\t\t\t   sizeof(ia_css_circbuf_elem_t));\n\t} else if (rdesc->location == IA_CSS_QUEUE_LOC_ISP) {\n\t\t \n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}