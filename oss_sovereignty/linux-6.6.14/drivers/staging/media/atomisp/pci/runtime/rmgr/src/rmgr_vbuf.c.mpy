{
  "module_name": "rmgr_vbuf.c",
  "hash_id": "854252aea0090900bd2c55067eff882afa3050cc7833c12333223cf7ecfa850e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/runtime/rmgr/src/rmgr_vbuf.c",
  "human_readable_source": "\n \n\n#include \"hmm.h\"\n#include \"ia_css_rmgr.h\"\n\n#include <type_support.h>\n#include <assert_support.h>\n#include <platform_support.h>  \n#include <ia_css_debug.h>\n\n \n#define NUM_HANDLES 1000\nstatic struct ia_css_rmgr_vbuf_handle handle_table[NUM_HANDLES];\n\n \nstatic struct ia_css_rmgr_vbuf_pool refpool;\n\n \nstatic struct ia_css_rmgr_vbuf_pool writepool = {\n\t.copy_on_write\t= true,\n};\n\n \nstatic struct ia_css_rmgr_vbuf_pool hmmbufferpool = {\n\t.copy_on_write\t= true,\n\t.recycle\t= true,\n\t.size\t\t= 32,\n};\n\nstruct ia_css_rmgr_vbuf_pool *vbuf_ref = &refpool;\nstruct ia_css_rmgr_vbuf_pool *vbuf_write = &writepool;\nstruct ia_css_rmgr_vbuf_pool *hmm_buffer_pool = &hmmbufferpool;\n\n \nstatic void rmgr_refcount_init_vbuf(void)\n{\n\t \n\tmemset(&handle_table, 0, sizeof(handle_table));\n}\n\n \nvoid ia_css_rmgr_refcount_retain_vbuf(struct ia_css_rmgr_vbuf_handle **handle)\n{\n\tint i;\n\tstruct ia_css_rmgr_vbuf_handle *h;\n\n\tif ((!handle) || (!*handle)) {\n\t\tIA_CSS_LOG(\"Invalid inputs\");\n\t\treturn;\n\t}\n\t \n\tif ((*handle)->count == 0) {\n\t\th = *handle;\n\t\t*handle = NULL;\n\t\tfor (i = 0; i < NUM_HANDLES; i++) {\n\t\t\tif (handle_table[i].count == 0) {\n\t\t\t\t*handle = &handle_table[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (!*handle) {\n\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,\n\t\t\t\t\t    \"ia_css_i_host_refcount_retain_vbuf() failed to find empty slot!\\n\");\n\t\t\treturn;\n\t\t}\n\t\t(*handle)->vptr = h->vptr;\n\t\t(*handle)->size = h->size;\n\t}\n\t(*handle)->count++;\n}\n\n \nvoid ia_css_rmgr_refcount_release_vbuf(struct ia_css_rmgr_vbuf_handle **handle)\n{\n\tif ((!handle) || ((*handle) == NULL) || (((*handle)->count) == 0)) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, \"%s invalid arguments!\\n\", __func__);\n\t\treturn;\n\t}\n\t \n\t(*handle)->count--;\n\t \n\tif ((*handle)->count == 0) {\n\t\t(*handle)->vptr = 0x0;\n\t\t(*handle)->size = 0;\n\t\t*handle = NULL;\n\t}\n}\n\n \nint ia_css_rmgr_init_vbuf(struct ia_css_rmgr_vbuf_pool *pool)\n{\n\tint err = 0;\n\tsize_t bytes_needed;\n\n\trmgr_refcount_init_vbuf();\n\tassert(pool);\n\tif (!pool)\n\t\treturn -EINVAL;\n\t \n\tif (pool->recycle && pool->size) {\n\t\t \n\t\tbytes_needed =\n\t\t    sizeof(void *) *\n\t\t    pool->size;\n\t\tpool->handles = kvmalloc(bytes_needed, GFP_KERNEL);\n\t\tif (pool->handles)\n\t\t\tmemset(pool->handles, 0, bytes_needed);\n\t\telse\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\t \n\t\tpool->size = 0;\n\t\tpool->handles = NULL;\n\t}\n\treturn err;\n}\n\n \nvoid ia_css_rmgr_uninit_vbuf(struct ia_css_rmgr_vbuf_pool *pool)\n{\n\tu32 i;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \"%s\\n\", __func__);\n\tif (!pool) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, \"%s NULL argument\\n\", __func__);\n\t\treturn;\n\t}\n\tif (pool->handles) {\n\t\t \n\t\tfor (i = 0; i < pool->size; i++) {\n\t\t\tif (pool->handles[i]) {\n\t\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t\t    \"   freeing/releasing %x (count=%d)\\n\",\n\t\t\t\t\t\t    pool->handles[i]->vptr,\n\t\t\t\t\t\t    pool->handles[i]->count);\n\t\t\t\t \n\t\t\t\thmm_free(pool->handles[i]->vptr);\n\t\t\t\t \n\t\t\t\tia_css_rmgr_refcount_release_vbuf(&pool->handles[i]);\n\t\t\t}\n\t\t}\n\t\t \n\t\tkvfree(pool->handles);\n\t\tpool->handles = NULL;\n\t}\n}\n\n \nstatic\nvoid rmgr_push_handle(struct ia_css_rmgr_vbuf_pool *pool,\n\t\t      struct ia_css_rmgr_vbuf_handle **handle)\n{\n\tu32 i;\n\tbool succes = false;\n\n\tassert(pool);\n\tassert(pool->recycle);\n\tassert(pool->handles);\n\tassert(handle);\n\tfor (i = 0; i < pool->size; i++) {\n\t\tif (!pool->handles[i]) {\n\t\t\tia_css_rmgr_refcount_retain_vbuf(handle);\n\t\t\tpool->handles[i] = *handle;\n\t\t\tsucces = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tassert(succes);\n}\n\n \nstatic\nvoid rmgr_pop_handle(struct ia_css_rmgr_vbuf_pool *pool,\n\t\t     struct ia_css_rmgr_vbuf_handle **handle)\n{\n\tu32 i;\n\n\tassert(pool);\n\tassert(pool->recycle);\n\tassert(pool->handles);\n\tassert(handle);\n\tassert(*handle);\n\tfor (i = 0; i < pool->size; i++) {\n\t\tif ((pool->handles[i]) &&\n\t\t    (pool->handles[i]->size == (*handle)->size)) {\n\t\t\t*handle = pool->handles[i];\n\t\t\tpool->handles[i] = NULL;\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nvoid ia_css_rmgr_acq_vbuf(struct ia_css_rmgr_vbuf_pool *pool,\n\t\t\t  struct ia_css_rmgr_vbuf_handle **handle)\n{\n\tif ((!pool) || (!handle) || (!*handle)) {\n\t\tIA_CSS_LOG(\"Invalid inputs\");\n\t\treturn;\n\t}\n\n\tif (pool->copy_on_write) {\n\t\tstruct ia_css_rmgr_vbuf_handle *new_handle;\n\t\tstruct ia_css_rmgr_vbuf_handle h = { 0 };\n\n\t\t \n\t\tif ((*handle)->count == 1)\n\t\t\treturn;\n\t\t \n\t\tif ((*handle)->count > 1) {\n\t\t\t \n\t\t\th.vptr = 0x0;\n\t\t\th.size = (*handle)->size;\n\t\t\t \n\t\t\tia_css_rmgr_refcount_release_vbuf(handle);\n\t\t\tnew_handle = &h;\n\t\t} else {\n\t\t\tnew_handle = *handle;\n\t\t}\n\t\t \n\t\tif (new_handle->vptr == 0x0) {\n\t\t\tif (pool->recycle) {\n\t\t\t\t \n\t\t\t\trmgr_pop_handle(pool, &new_handle);\n\t\t\t}\n\t\t\tif (new_handle->vptr == 0x0) {\n\t\t\t\t \n\t\t\t\tnew_handle->vptr = hmm_alloc(new_handle->size);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t*handle = new_handle;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t \n\t\tia_css_rmgr_refcount_retain_vbuf(&new_handle);\n\t\t*handle = new_handle;\n\t\treturn;\n\t}\n\t \n\tia_css_rmgr_refcount_retain_vbuf(handle);\n}\n\n \nvoid ia_css_rmgr_rel_vbuf(struct ia_css_rmgr_vbuf_pool *pool,\n\t\t\t  struct ia_css_rmgr_vbuf_handle **handle)\n{\n\tif ((!pool) || (!handle) || (!*handle)) {\n\t\tIA_CSS_LOG(\"Invalid inputs\");\n\t\treturn;\n\t}\n\t \n\tif ((*handle)->count == 1) {\n\t\tif (!pool->recycle) {\n\t\t\t \n\t\t\thmm_free((*handle)->vptr);\n\t\t} else {\n\t\t\t \n\t\t\trmgr_push_handle(pool, handle);\n\t\t}\n\t}\n\tia_css_rmgr_refcount_release_vbuf(handle);\n\t*handle = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}