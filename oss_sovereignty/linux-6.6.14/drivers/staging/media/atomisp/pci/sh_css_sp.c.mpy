{
  "module_name": "sh_css_sp.c",
  "hash_id": "591fbb56310996018218388ecf7116912c9fe550a5938cff596b046e321cffd0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/sh_css_sp.c",
  "human_readable_source": "\n \n\n#include \"hmm.h\"\n\n#include \"sh_css_sp.h\"\n\n#if !defined(ISP2401)\n#include \"input_formatter.h\"\n#endif\n\n#include \"dma.h\"\t \n\n#include \"ia_css_buffer.h\"\n#include \"ia_css_binary.h\"\n#include \"sh_css_hrt.h\"\n#include \"sh_css_defs.h\"\n#include \"sh_css_internal.h\"\n#include \"ia_css_control.h\"\n#include \"ia_css_debug.h\"\n#include \"ia_css_debug_pipe.h\"\n#include \"ia_css_event_public.h\"\n#include \"ia_css_mmu.h\"\n#include \"ia_css_stream.h\"\n#include \"ia_css_isp_param.h\"\n#include \"sh_css_params.h\"\n#include \"sh_css_legacy.h\"\n#include \"ia_css_frame_comm.h\"\n#include \"ia_css_isys.h\"\n\n#include \"gdc_device.h\"\t\t\t\t \n\n \t \n\n\n#include \"assert_support.h\"\n\n#include \"sw_event_global.h\"\t\t\t \n#include \"ia_css_event.h\"\n#include \"mmu_device.h\"\n#include \"ia_css_spctrl.h\"\n#include \"atomisp_internal.h\"\n\n#ifndef offsetof\n#define offsetof(T, x) ((unsigned int)&(((T *)0)->x))\n#endif\n\n#define IA_CSS_INCLUDE_CONFIGURATIONS\n#include \"ia_css_isp_configs.h\"\n#define IA_CSS_INCLUDE_STATES\n#include \"ia_css_isp_states.h\"\n\n#include \"isp/kernels/ipu2_io_ls/bayer_io_ls/ia_css_bayer_io.host.h\"\n\nstruct sh_css_sp_group\t\tsh_css_sp_group;\nstruct sh_css_sp_stage\t\tsh_css_sp_stage;\nstruct sh_css_isp_stage\t\tsh_css_isp_stage;\nstatic struct sh_css_sp_output\t\tsh_css_sp_output;\nstatic struct sh_css_sp_per_frame_data per_frame_data;\n\n \n \n \nstatic bool sp_running;\n\nstatic int\nset_output_frame_buffer(const struct ia_css_frame *frame,\n\t\t\tunsigned int idx);\n\nstatic void\nsh_css_copy_buffer_attr_to_spbuffer(struct ia_css_buffer_sp *dest_buf,\n\t\t\t\t    const enum sh_css_queue_id queue_id,\n\t\t\t\t    const ia_css_ptr xmem_addr,\n\t\t\t\t    const enum ia_css_buffer_type buf_type);\n\nstatic void\ninitialize_frame_buffer_attribute(struct ia_css_buffer_sp *buf_attr);\n\nstatic void\ninitialize_stage_frames(struct ia_css_frames_sp *frames);\n\n \nvoid\nstore_sp_group_data(void)\n{\n\tper_frame_data.sp_group_addr = sh_css_store_sp_group_to_ddr();\n}\n\nstatic void\ncopy_isp_stage_to_sp_stage(void)\n{\n\t \n\tsh_css_sp_stage.num_stripes = (uint8_t)\n\t\t\t\t      sh_css_isp_stage.binary_info.iterator.num_stripes;\n\tsh_css_sp_stage.row_stripes_height = (uint16_t)\n\t\t\t\t\t     sh_css_isp_stage.binary_info.iterator.row_stripes_height;\n\tsh_css_sp_stage.row_stripes_overlap_lines = (uint16_t)\n\t\tsh_css_isp_stage.binary_info.iterator.row_stripes_overlap_lines;\n\tsh_css_sp_stage.top_cropping = (uint16_t)\n\t\t\t\t       sh_css_isp_stage.binary_info.pipeline.top_cropping;\n\t \n\tsh_css_sp_stage.enable.sdis = sh_css_isp_stage.binary_info.enable.dis;\n\tsh_css_sp_stage.enable.s3a = sh_css_isp_stage.binary_info.enable.s3a;\n}\n\nvoid\nstore_sp_stage_data(enum ia_css_pipe_id id, unsigned int pipe_num,\n\t\t    unsigned int stage)\n{\n\tunsigned int thread_id;\n\n\tia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\n\tcopy_isp_stage_to_sp_stage();\n\tif (id != IA_CSS_PIPE_ID_COPY)\n\t\tsh_css_sp_stage.isp_stage_addr =\n\t\t    sh_css_store_isp_stage_to_ddr(pipe_num, stage);\n\tsh_css_sp_group.pipe[thread_id].sp_stage_addr[stage] =\n\t    sh_css_store_sp_stage_to_ddr(pipe_num, stage);\n\n\t \n\tsh_css_sp_stage.program_input_circuit = false;\n}\n\nstatic void\nstore_sp_per_frame_data(const struct ia_css_fw_info *fw)\n{\n\tunsigned int HIVE_ADDR_sp_per_frame_data = 0;\n\n\tassert(fw);\n\n\tswitch (fw->type) {\n\tcase ia_css_sp_firmware:\n\t\tHIVE_ADDR_sp_per_frame_data = fw->info.sp.per_frame_data;\n\t\tbreak;\n\tcase ia_css_acc_firmware:\n\t\tHIVE_ADDR_sp_per_frame_data = fw->info.acc.per_frame_data;\n\t\tbreak;\n\tcase ia_css_isp_firmware:\n\t\treturn;\n\t}\n\n\tsp_dmem_store(SP0_ID,\n\t\t      (unsigned int)sp_address_of(sp_per_frame_data),\n\t\t      &per_frame_data,\n\t\t      sizeof(per_frame_data));\n}\n\nstatic void\nsh_css_store_sp_per_frame_data(enum ia_css_pipe_id pipe_id,\n\t\t\t       unsigned int pipe_num,\n\t\t\t       const struct ia_css_fw_info *sp_fw)\n{\n\tif (!sp_fw)\n\t\tsp_fw = &sh_css_sp_fw;\n\n\tstore_sp_stage_data(pipe_id, pipe_num, 0);\n\tstore_sp_group_data();\n\tstore_sp_per_frame_data(sp_fw);\n}\n\n#if SP_DEBUG != SP_DEBUG_NONE\n\nvoid\nsh_css_sp_get_debug_state(struct sh_css_sp_debug_state *state)\n{\n\tconst struct ia_css_fw_info *fw = &sh_css_sp_fw;\n\tunsigned int HIVE_ADDR_sp_output = fw->info.sp.output;\n\tunsigned int i;\n\tunsigned int offset = (unsigned int)offsetof(struct sh_css_sp_output,\n\t\t\t      debug) / sizeof(int);\n\n\tassert(state);\n\n\t(void)HIVE_ADDR_sp_output;  \n\tfor (i = 0; i < sizeof(*state) / sizeof(int); i++)\n\t\t((unsigned *)state)[i] = load_sp_array_uint(sp_output, i + offset);\n}\n\n#endif\n\nvoid\nsh_css_sp_start_binary_copy(unsigned int pipe_num,\n\t\t\t    struct ia_css_frame *out_frame,\n\t\t\t    unsigned int two_ppc)\n{\n\tenum ia_css_pipe_id pipe_id;\n\tunsigned int thread_id;\n\tstruct sh_css_sp_pipeline *pipe;\n\tu8 stage_num = 0;\n\n\tassert(out_frame);\n\tpipe_id = IA_CSS_PIPE_ID_CAPTURE;\n\tia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\n\tpipe = &sh_css_sp_group.pipe[thread_id];\n\n\tpipe->copy.bin.bytes_available = out_frame->data_bytes;\n\tpipe->num_stages = 1;\n\tpipe->pipe_id = pipe_id;\n\tpipe->pipe_num = pipe_num;\n\tpipe->thread_id = thread_id;\n\tpipe->pipe_config = 0x0;  \n\tpipe->pipe_qos_config = QOS_INVALID;\n\n\tif (pipe->inout_port_config == 0) {\n\t\tSH_CSS_PIPE_PORT_CONFIG_SET(pipe->inout_port_config,\n\t\t\t\t\t    (uint8_t)SH_CSS_PORT_INPUT,\n\t\t\t\t\t    (uint8_t)SH_CSS_HOST_TYPE, 1);\n\t\tSH_CSS_PIPE_PORT_CONFIG_SET(pipe->inout_port_config,\n\t\t\t\t\t    (uint8_t)SH_CSS_PORT_OUTPUT,\n\t\t\t\t\t    (uint8_t)SH_CSS_HOST_TYPE, 1);\n\t}\n\tIA_CSS_LOG(\"pipe_id %d port_config %08x\",\n\t\t   pipe->pipe_id, pipe->inout_port_config);\n\n#if !defined(ISP2401)\n\tsh_css_sp_group.config.input_formatter.isp_2ppc = (uint8_t)two_ppc;\n#else\n\t(void)two_ppc;\n#endif\n\n\tsh_css_sp_stage.num = stage_num;\n\tsh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;\n\tsh_css_sp_stage.func =\n\t    (unsigned int)IA_CSS_PIPELINE_BIN_COPY;\n\n\tset_output_frame_buffer(out_frame, 0);\n\n\t \n\t \n\tsh_css_store_sp_per_frame_data(pipe_id, pipe_num, &sh_css_sp_fw);\n}\n\nstatic void\nsh_css_sp_start_raw_copy(struct ia_css_frame *out_frame,\n\t\t\t unsigned int pipe_num,\n\t\t\t unsigned int two_ppc,\n\t\t\t unsigned int max_input_width,\n\t\t\t enum sh_css_pipe_config_override pipe_conf_override,\n\t\t\t unsigned int if_config_index)\n{\n\tenum ia_css_pipe_id pipe_id;\n\tunsigned int thread_id;\n\tu8 stage_num = 0;\n\tstruct sh_css_sp_pipeline *pipe;\n\n\tassert(out_frame);\n\n\t{\n\t\t \n\t\tu8 program_input_circuit;\n\n\t\tprogram_input_circuit = sh_css_sp_stage.program_input_circuit;\n\t\tmemset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));\n\t\tsh_css_sp_stage.program_input_circuit = program_input_circuit;\n\t}\n\n\tpipe_id = IA_CSS_PIPE_ID_COPY;\n\tia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\n\tpipe = &sh_css_sp_group.pipe[thread_id];\n\n\tpipe->copy.raw.height\t    = out_frame->frame_info.res.height;\n\tpipe->copy.raw.width\t    = out_frame->frame_info.res.width;\n\tpipe->copy.raw.padded_width  = out_frame->frame_info.padded_width;\n\tpipe->copy.raw.raw_bit_depth = out_frame->frame_info.raw_bit_depth;\n\tpipe->copy.raw.max_input_width = max_input_width;\n\tpipe->num_stages = 1;\n\tpipe->pipe_id = pipe_id;\n\t \n\tif (pipe_conf_override == SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD)\n\t\tpipe->pipe_config =\n\t\t    (SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id);\n\telse\n\t\tpipe->pipe_config = pipe_conf_override;\n\n\tpipe->pipe_qos_config = QOS_INVALID;\n\n\tif (pipe->inout_port_config == 0) {\n\t\tSH_CSS_PIPE_PORT_CONFIG_SET(pipe->inout_port_config,\n\t\t\t\t\t    (uint8_t)SH_CSS_PORT_INPUT,\n\t\t\t\t\t    (uint8_t)SH_CSS_HOST_TYPE, 1);\n\t\tSH_CSS_PIPE_PORT_CONFIG_SET(pipe->inout_port_config,\n\t\t\t\t\t    (uint8_t)SH_CSS_PORT_OUTPUT,\n\t\t\t\t\t    (uint8_t)SH_CSS_HOST_TYPE, 1);\n\t}\n\tIA_CSS_LOG(\"pipe_id %d port_config %08x\",\n\t\t   pipe->pipe_id, pipe->inout_port_config);\n\n#if !defined(ISP2401)\n\tsh_css_sp_group.config.input_formatter.isp_2ppc = (uint8_t)two_ppc;\n#else\n\t(void)two_ppc;\n#endif\n\n\tsh_css_sp_stage.num = stage_num;\n\tsh_css_sp_stage.xmem_bin_addr = 0x0;\n\tsh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;\n\tsh_css_sp_stage.func = (unsigned int)IA_CSS_PIPELINE_RAW_COPY;\n\tsh_css_sp_stage.if_config_index = (uint8_t)if_config_index;\n\tset_output_frame_buffer(out_frame, 0);\n\n\tia_css_debug_pipe_graph_dump_sp_raw_copy(out_frame);\n}\n\nstatic void\nsh_css_sp_start_isys_copy(struct ia_css_frame *out_frame,\n\t\t\t  unsigned int pipe_num, unsigned int max_input_width,\n\t\t\t  unsigned int if_config_index)\n{\n\tenum ia_css_pipe_id pipe_id;\n\tunsigned int thread_id;\n\tu8 stage_num = 0;\n\tstruct sh_css_sp_pipeline *pipe;\n\tenum sh_css_queue_id queue_id;\n\n\tassert(out_frame);\n\n\t{\n\t\t \n\t\tu8 program_input_circuit;\n\n\t\tprogram_input_circuit = sh_css_sp_stage.program_input_circuit;\n\t\tmemset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));\n\t\tsh_css_sp_stage.program_input_circuit = program_input_circuit;\n\t}\n\n\tpipe_id = IA_CSS_PIPE_ID_COPY;\n\tia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\n\tpipe = &sh_css_sp_group.pipe[thread_id];\n\n\tpipe->copy.raw.height\t\t= out_frame->frame_info.res.height;\n\tpipe->copy.raw.width\t\t= out_frame->frame_info.res.width;\n\tpipe->copy.raw.padded_width\t= out_frame->frame_info.padded_width;\n\tpipe->copy.raw.raw_bit_depth\t= out_frame->frame_info.raw_bit_depth;\n\tpipe->copy.raw.max_input_width\t= max_input_width;\n\tpipe->num_stages\t\t= 1;\n\tpipe->pipe_id\t\t\t= pipe_id;\n\tpipe->pipe_config\t\t= 0x0;\t \n\tpipe->pipe_qos_config\t\t= QOS_INVALID;\n\n\tinitialize_stage_frames(&sh_css_sp_stage.frames);\n\tsh_css_sp_stage.num = stage_num;\n\tsh_css_sp_stage.xmem_bin_addr = 0x0;\n\tsh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;\n\tsh_css_sp_stage.func = (unsigned int)IA_CSS_PIPELINE_ISYS_COPY;\n\tsh_css_sp_stage.if_config_index = (uint8_t)if_config_index;\n\n\tset_output_frame_buffer(out_frame, 0);\n\n\tif (pipe->metadata.height > 0) {\n\t\tia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_METADATA, thread_id,\n\t\t\t\t\t       &queue_id);\n\t\tsh_css_copy_buffer_attr_to_spbuffer(&sh_css_sp_stage.frames.metadata_buf,\n\t\t\t\t\t\t    queue_id, mmgr_EXCEPTION,\n\t\t\t\t\t\t    IA_CSS_BUFFER_TYPE_METADATA);\n\t}\n\n\tia_css_debug_pipe_graph_dump_sp_raw_copy(out_frame);\n}\n\nunsigned int\nsh_css_sp_get_binary_copy_size(void)\n{\n\tconst struct ia_css_fw_info *fw = &sh_css_sp_fw;\n\tunsigned int HIVE_ADDR_sp_output = fw->info.sp.output;\n\tunsigned int offset = (unsigned int)offsetof(struct sh_css_sp_output,\n\t\t\t      bin_copy_bytes_copied) / sizeof(int);\n\t(void)HIVE_ADDR_sp_output;  \n\treturn load_sp_array_uint(sp_output, offset);\n}\n\nunsigned int\nsh_css_sp_get_sw_interrupt_value(unsigned int irq)\n{\n\tconst struct ia_css_fw_info *fw = &sh_css_sp_fw;\n\tunsigned int HIVE_ADDR_sp_output = fw->info.sp.output;\n\tunsigned int offset = (unsigned int)offsetof(struct sh_css_sp_output,\n\t\t\t      sw_interrupt_value)\n\t\t\t      / sizeof(int);\n\t(void)HIVE_ADDR_sp_output;  \n\treturn load_sp_array_uint(sp_output, offset + irq);\n}\n\nstatic void\nsh_css_copy_buffer_attr_to_spbuffer(struct ia_css_buffer_sp *dest_buf,\n\t\t\t\t    const enum sh_css_queue_id queue_id,\n\t\t\t\t    const ia_css_ptr xmem_addr,\n\t\t\t\t    const enum ia_css_buffer_type buf_type)\n{\n\tassert(buf_type < IA_CSS_NUM_BUFFER_TYPE);\n\tif (queue_id > SH_CSS_INVALID_QUEUE_ID) {\n\t\t \n\t\tassert(queue_id < SH_CSS_MAX_NUM_QUEUES);\n\n\t\t \n\t\tif ((queue_id < SH_CSS_MAX_NUM_QUEUES)) {\n\t\t\tdest_buf->buf_src.queue_id = queue_id;\n\t\t}\n\t} else {\n\t\tassert(xmem_addr != mmgr_EXCEPTION);\n\t\tdest_buf->buf_src.xmem_addr = xmem_addr;\n\t}\n\tdest_buf->buf_type = buf_type;\n}\n\nstatic void\nsh_css_copy_frame_to_spframe(struct ia_css_frame_sp *sp_frame_out,\n\t\t\t     const struct ia_css_frame *frame_in)\n{\n\tassert(frame_in);\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"sh_css_copy_frame_to_spframe():\\n\");\n\n\tsh_css_copy_buffer_attr_to_spbuffer(&sp_frame_out->buf_attr,\n\t\t\t\t\t    frame_in->dynamic_queue_id,\n\t\t\t\t\t    frame_in->data,\n\t\t\t\t\t    frame_in->buf_type);\n\n\tia_css_frame_info_to_frame_sp_info(&sp_frame_out->info, &frame_in->frame_info);\n\n\tswitch (frame_in->frame_info.format) {\n\tcase IA_CSS_FRAME_FORMAT_RAW_PACKED:\n\tcase IA_CSS_FRAME_FORMAT_RAW:\n\t\tsp_frame_out->planes.raw.offset = frame_in->planes.raw.offset;\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_RGB565:\n\tcase IA_CSS_FRAME_FORMAT_RGBA888:\n\t\tsp_frame_out->planes.rgb.offset = frame_in->planes.rgb.offset;\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_PLANAR_RGB888:\n\t\tsp_frame_out->planes.planar_rgb.r.offset =\n\t\t    frame_in->planes.planar_rgb.r.offset;\n\t\tsp_frame_out->planes.planar_rgb.g.offset =\n\t\t    frame_in->planes.planar_rgb.g.offset;\n\t\tsp_frame_out->planes.planar_rgb.b.offset =\n\t\t    frame_in->planes.planar_rgb.b.offset;\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_YUYV:\n\tcase IA_CSS_FRAME_FORMAT_UYVY:\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8:\n\tcase IA_CSS_FRAME_FORMAT_YUV_LINE:\n\t\tsp_frame_out->planes.yuyv.offset = frame_in->planes.yuyv.offset;\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_NV11:\n\tcase IA_CSS_FRAME_FORMAT_NV12:\n\tcase IA_CSS_FRAME_FORMAT_NV12_16:\n\tcase IA_CSS_FRAME_FORMAT_NV12_TILEY:\n\tcase IA_CSS_FRAME_FORMAT_NV21:\n\tcase IA_CSS_FRAME_FORMAT_NV16:\n\tcase IA_CSS_FRAME_FORMAT_NV61:\n\t\tsp_frame_out->planes.nv.y.offset =\n\t\t    frame_in->planes.nv.y.offset;\n\t\tsp_frame_out->planes.nv.uv.offset =\n\t\t    frame_in->planes.nv.uv.offset;\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_YUV420:\n\tcase IA_CSS_FRAME_FORMAT_YUV422:\n\tcase IA_CSS_FRAME_FORMAT_YUV444:\n\tcase IA_CSS_FRAME_FORMAT_YUV420_16:\n\tcase IA_CSS_FRAME_FORMAT_YUV422_16:\n\tcase IA_CSS_FRAME_FORMAT_YV12:\n\tcase IA_CSS_FRAME_FORMAT_YV16:\n\t\tsp_frame_out->planes.yuv.y.offset =\n\t\t    frame_in->planes.yuv.y.offset;\n\t\tsp_frame_out->planes.yuv.u.offset =\n\t\t    frame_in->planes.yuv.u.offset;\n\t\tsp_frame_out->planes.yuv.v.offset =\n\t\t    frame_in->planes.yuv.v.offset;\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_QPLANE6:\n\t\tsp_frame_out->planes.plane6.r.offset =\n\t\t    frame_in->planes.plane6.r.offset;\n\t\tsp_frame_out->planes.plane6.r_at_b.offset =\n\t\t    frame_in->planes.plane6.r_at_b.offset;\n\t\tsp_frame_out->planes.plane6.gr.offset =\n\t\t    frame_in->planes.plane6.gr.offset;\n\t\tsp_frame_out->planes.plane6.gb.offset =\n\t\t    frame_in->planes.plane6.gb.offset;\n\t\tsp_frame_out->planes.plane6.b.offset =\n\t\t    frame_in->planes.plane6.b.offset;\n\t\tsp_frame_out->planes.plane6.b_at_r.offset =\n\t\t    frame_in->planes.plane6.b_at_r.offset;\n\t\tbreak;\n\tcase IA_CSS_FRAME_FORMAT_BINARY_8:\n\t\tsp_frame_out->planes.binary.data.offset =\n\t\t    frame_in->planes.binary.data.offset;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tmemset(&sp_frame_out->planes, 0, sizeof(sp_frame_out->planes));\n\t\tbreak;\n\t}\n}\n\nstatic int\nset_input_frame_buffer(const struct ia_css_frame *frame)\n{\n\tif (!frame)\n\t\treturn -EINVAL;\n\n\tswitch (frame->frame_info.format) {\n\tcase IA_CSS_FRAME_FORMAT_QPLANE6:\n\tcase IA_CSS_FRAME_FORMAT_YUV420_16:\n\tcase IA_CSS_FRAME_FORMAT_RAW_PACKED:\n\tcase IA_CSS_FRAME_FORMAT_RAW:\n\tcase IA_CSS_FRAME_FORMAT_YUV420:\n\tcase IA_CSS_FRAME_FORMAT_YUYV:\n\tcase IA_CSS_FRAME_FORMAT_YUV_LINE:\n\tcase IA_CSS_FRAME_FORMAT_NV12:\n\tcase IA_CSS_FRAME_FORMAT_NV12_16:\n\tcase IA_CSS_FRAME_FORMAT_NV12_TILEY:\n\tcase IA_CSS_FRAME_FORMAT_NV21:\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8:\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_10:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.in, frame);\n\n\treturn 0;\n}\n\nstatic int\nset_output_frame_buffer(const struct ia_css_frame *frame,\n\t\t\tunsigned int idx)\n{\n\tif (!frame)\n\t\treturn -EINVAL;\n\n\tswitch (frame->frame_info.format) {\n\tcase IA_CSS_FRAME_FORMAT_YUV420:\n\tcase IA_CSS_FRAME_FORMAT_YUV422:\n\tcase IA_CSS_FRAME_FORMAT_YUV444:\n\tcase IA_CSS_FRAME_FORMAT_YV12:\n\tcase IA_CSS_FRAME_FORMAT_YV16:\n\tcase IA_CSS_FRAME_FORMAT_YUV420_16:\n\tcase IA_CSS_FRAME_FORMAT_YUV422_16:\n\tcase IA_CSS_FRAME_FORMAT_NV11:\n\tcase IA_CSS_FRAME_FORMAT_NV12:\n\tcase IA_CSS_FRAME_FORMAT_NV12_16:\n\tcase IA_CSS_FRAME_FORMAT_NV12_TILEY:\n\tcase IA_CSS_FRAME_FORMAT_NV16:\n\tcase IA_CSS_FRAME_FORMAT_NV21:\n\tcase IA_CSS_FRAME_FORMAT_NV61:\n\tcase IA_CSS_FRAME_FORMAT_YUYV:\n\tcase IA_CSS_FRAME_FORMAT_UYVY:\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8:\n\tcase IA_CSS_FRAME_FORMAT_YUV_LINE:\n\tcase IA_CSS_FRAME_FORMAT_RGB565:\n\tcase IA_CSS_FRAME_FORMAT_RGBA888:\n\tcase IA_CSS_FRAME_FORMAT_PLANAR_RGB888:\n\tcase IA_CSS_FRAME_FORMAT_RAW:\n\tcase IA_CSS_FRAME_FORMAT_RAW_PACKED:\n\tcase IA_CSS_FRAME_FORMAT_QPLANE6:\n\tcase IA_CSS_FRAME_FORMAT_BINARY_8:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.out[idx], frame);\n\treturn 0;\n}\n\nstatic int\nset_view_finder_buffer(const struct ia_css_frame *frame)\n{\n\tif (!frame)\n\t\treturn -EINVAL;\n\n\tswitch (frame->frame_info.format) {\n\t \n\tcase IA_CSS_FRAME_FORMAT_NV12:\n\tcase IA_CSS_FRAME_FORMAT_NV12_16:\n\tcase IA_CSS_FRAME_FORMAT_NV21:\n\tcase IA_CSS_FRAME_FORMAT_YUYV:\n\tcase IA_CSS_FRAME_FORMAT_UYVY:\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:\n\tcase IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8:\n\tcase IA_CSS_FRAME_FORMAT_YUV420:\n\tcase IA_CSS_FRAME_FORMAT_YV12:\n\tcase IA_CSS_FRAME_FORMAT_NV12_TILEY:\n\n\t \n\tcase IA_CSS_FRAME_FORMAT_YUV_LINE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.out_vf, frame);\n\treturn 0;\n}\n\n#if !defined(ISP2401)\nvoid sh_css_sp_set_if_configs(\n    const input_formatter_cfg_t\t*config_a,\n    const input_formatter_cfg_t\t*config_b,\n    const uint8_t\t\tif_config_index\n)\n{\n\tassert(if_config_index < SH_CSS_MAX_IF_CONFIGS);\n\tassert(config_a);\n\n\tsh_css_sp_group.config.input_formatter.set[if_config_index].config_a =\n\t    *config_a;\n\tsh_css_sp_group.config.input_formatter.a_changed = true;\n\n\tif (config_b) {\n\t\tsh_css_sp_group.config.input_formatter.set[if_config_index].config_b =\n\t\t    *config_b;\n\t\tsh_css_sp_group.config.input_formatter.b_changed = true;\n\t}\n\n\treturn;\n}\n#endif\n\n#if !defined(ISP2401)\nvoid\nsh_css_sp_program_input_circuit(int fmt_type,\n\t\t\t\tint ch_id,\n\t\t\t\tenum ia_css_input_mode input_mode)\n{\n\tsh_css_sp_group.config.input_circuit.no_side_band = false;\n\tsh_css_sp_group.config.input_circuit.fmt_type     = fmt_type;\n\tsh_css_sp_group.config.input_circuit.ch_id\t      = ch_id;\n\tsh_css_sp_group.config.input_circuit.input_mode   = input_mode;\n\t \n\tsh_css_sp_group.config.input_circuit_cfg_changed = true;\n\tsh_css_sp_stage.program_input_circuit = true;\n}\n#endif\n\n#if !defined(ISP2401)\nvoid\nsh_css_sp_configure_sync_gen(int width, int height,\n\t\t\t     int hblank_cycles,\n\t\t\t     int vblank_cycles)\n{\n\tsh_css_sp_group.config.sync_gen.width\t       = width;\n\tsh_css_sp_group.config.sync_gen.height\t       = height;\n\tsh_css_sp_group.config.sync_gen.hblank_cycles = hblank_cycles;\n\tsh_css_sp_group.config.sync_gen.vblank_cycles = vblank_cycles;\n}\n\nvoid\nsh_css_sp_configure_tpg(int x_mask,\n\t\t\tint y_mask,\n\t\t\tint x_delta,\n\t\t\tint y_delta,\n\t\t\tint xy_mask)\n{\n\tsh_css_sp_group.config.tpg.x_mask  = x_mask;\n\tsh_css_sp_group.config.tpg.y_mask  = y_mask;\n\tsh_css_sp_group.config.tpg.x_delta = x_delta;\n\tsh_css_sp_group.config.tpg.y_delta = y_delta;\n\tsh_css_sp_group.config.tpg.xy_mask = xy_mask;\n}\n\nvoid\nsh_css_sp_configure_prbs(int seed)\n{\n\tsh_css_sp_group.config.prbs.seed = seed;\n}\n#endif\n\nvoid\nsh_css_sp_configure_enable_raw_pool_locking(bool lock_all)\n{\n\tsh_css_sp_group.config.enable_raw_pool_locking = true;\n\tsh_css_sp_group.config.lock_all = lock_all;\n}\n\nvoid\nsh_css_sp_enable_isys_event_queue(bool enable)\n{\n\tsh_css_sp_group.config.enable_isys_event_queue = enable;\n}\n\nvoid\nsh_css_sp_set_disable_continuous_viewfinder(bool flag)\n{\n\tsh_css_sp_group.config.disable_cont_vf = flag;\n}\n\nstatic int\nsh_css_sp_write_frame_pointers(const struct sh_css_binary_args *args)\n{\n\tint err = 0;\n\tint i;\n\n\tassert(args);\n\n\tif (args->in_frame)\n\t\terr = set_input_frame_buffer(args->in_frame);\n\tif (!err && args->out_vf_frame)\n\t\terr = set_view_finder_buffer(args->out_vf_frame);\n\tfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {\n\t\tif (!err && args->out_frame[i])\n\t\t\terr = set_output_frame_buffer(args->out_frame[i], i);\n\t}\n\n\t \n\tif (err) assert(false);\n\treturn err;\n}\n\nstatic void\nsh_css_sp_init_group(bool two_ppc,\n\t\t     enum atomisp_input_format input_format,\n\t\t     bool no_isp_sync,\n\t\t     uint8_t if_config_index)\n{\n#if !defined(ISP2401)\n\tsh_css_sp_group.config.input_formatter.isp_2ppc = two_ppc;\n#else\n\t(void)two_ppc;\n#endif\n\n\tsh_css_sp_group.config.no_isp_sync = (uint8_t)no_isp_sync;\n\t \n\tif (if_config_index == SH_CSS_IF_CONFIG_NOT_NEEDED) return;\n#if !defined(ISP2401)\n\tassert(if_config_index < SH_CSS_MAX_IF_CONFIGS);\n\tsh_css_sp_group.config.input_formatter.set[if_config_index].stream_format =\n\t    input_format;\n#else\n\t(void)input_format;\n#endif\n}\n\nvoid\nsh_css_stage_write_binary_info(struct ia_css_binary_info *info)\n{\n\tassert(info);\n\tsh_css_isp_stage.binary_info = *info;\n}\n\nstatic int\ncopy_isp_mem_if_to_ddr(struct ia_css_binary *binary)\n{\n\tint err;\n\n\terr = ia_css_isp_param_copy_isp_mem_if_to_ddr(\n\t    &binary->css_params,\n\t    &binary->mem_params,\n\t    IA_CSS_PARAM_CLASS_CONFIG);\n\tif (err)\n\t\treturn err;\n\terr = ia_css_isp_param_copy_isp_mem_if_to_ddr(\n\t    &binary->css_params,\n\t    &binary->mem_params,\n\t    IA_CSS_PARAM_CLASS_STATE);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic bool\nis_sp_stage(struct ia_css_pipeline_stage *stage)\n{\n\tassert(stage);\n\treturn stage->sp_func != IA_CSS_PIPELINE_NO_FUNC;\n}\n\nstatic int configure_isp_from_args(const struct sh_css_sp_pipeline *pipeline,\n\t\t\t\t   const struct ia_css_binary      *binary,\n\t\t\t\t   const struct sh_css_binary_args *args,\n\t\t\t\t   bool\t\t\t\t   two_ppc,\n\t\t\t\t   bool\t\t\t\t   deinterleaved)\n{\n\tint ret;\n\n\tret = ia_css_fpn_configure(binary,  &binary->in_frame_info);\n\tif (ret)\n\t\treturn ret;\n\tret = ia_css_crop_configure(binary, ia_css_frame_get_info(args->delay_frames[0]));\n\tif (ret)\n\t\treturn ret;\n\tret = ia_css_qplane_configure(pipeline, binary, &binary->in_frame_info);\n\tif (ret)\n\t\treturn ret;\n\tret = ia_css_output0_configure(binary, ia_css_frame_get_info(args->out_frame[0]));\n\tif (ret)\n\t\treturn ret;\n\tret = ia_css_output1_configure(binary, ia_css_frame_get_info(args->out_vf_frame));\n\tif (ret)\n\t\treturn ret;\n\tret = ia_css_copy_output_configure(binary, args->copy_output);\n\tif (ret)\n\t\treturn ret;\n\tret = ia_css_output0_configure(binary, ia_css_frame_get_info(args->out_frame[0]));\n\tif (ret)\n\t\treturn ret;\n\tret = ia_css_iterator_configure(binary, ia_css_frame_get_info(args->in_frame));\n\tif (ret)\n\t\treturn ret;\n\tret = ia_css_dvs_configure(binary, ia_css_frame_get_info(args->out_frame[0]));\n\tif (ret)\n\t\treturn ret;\n\tret = ia_css_output_configure(binary, ia_css_frame_get_info(args->out_frame[0]));\n\tif (ret)\n\t\treturn ret;\n\tret = ia_css_raw_configure(pipeline, binary, ia_css_frame_get_info(args->in_frame),\n\t\t\t\t   &binary->in_frame_info, two_ppc, deinterleaved);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ia_css_ref_configure(binary, args->delay_frames, pipeline->dvs_frame_delay);\n\tif (ret)\n\t\treturn ret;\n\tret = ia_css_tnr_configure(binary, args->tnr_frames);\n\tif (ret)\n\t\treturn ret;\n\treturn ia_css_bayer_io_config(binary, args);\n}\n\nstatic void\ninitialize_isp_states(const struct ia_css_binary *binary)\n{\n\tunsigned int i;\n\n\tif (!binary->info->mem_offsets.offsets.state)\n\t\treturn;\n\tfor (i = 0; i < IA_CSS_NUM_STATE_IDS; i++) {\n\t\tia_css_kernel_init_state[i](binary);\n\t}\n}\n\nstatic void\ninitialize_frame_buffer_attribute(struct ia_css_buffer_sp *buf_attr)\n{\n\tbuf_attr->buf_src.queue_id = SH_CSS_INVALID_QUEUE_ID;\n\tbuf_attr->buf_type = IA_CSS_BUFFER_TYPE_INVALID;\n}\n\nstatic void\ninitialize_stage_frames(struct ia_css_frames_sp *frames)\n{\n\tunsigned int i;\n\n\tinitialize_frame_buffer_attribute(&frames->in.buf_attr);\n\tfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {\n\t\tinitialize_frame_buffer_attribute(&frames->out[i].buf_attr);\n\t}\n\tinitialize_frame_buffer_attribute(&frames->out_vf.buf_attr);\n\tinitialize_frame_buffer_attribute(&frames->s3a_buf);\n\tinitialize_frame_buffer_attribute(&frames->dvs_buf);\n\tinitialize_frame_buffer_attribute(&frames->metadata_buf);\n}\n\nstatic int\nsh_css_sp_init_stage(struct ia_css_binary *binary,\n\t\t     const char *binary_name,\n\t\t     const struct ia_css_blob_info *blob_info,\n\t\t     const struct sh_css_binary_args *args,\n\t\t     unsigned int pipe_num,\n\t\t     unsigned int stage,\n\t\t     bool xnr,\n\t\t     const struct ia_css_isp_param_css_segments *isp_mem_if,\n\t\t     unsigned int if_config_index,\n\t\t     bool two_ppc)\n{\n\tconst struct ia_css_binary_xinfo *xinfo;\n\tconst struct ia_css_binary_info  *info;\n\tint err = 0;\n\tint i;\n\tstruct ia_css_pipe *pipe = NULL;\n\tunsigned int thread_id;\n\tenum sh_css_queue_id queue_id;\n\tbool continuous = sh_css_continuous_is_enabled((uint8_t)pipe_num);\n\n\tassert(binary);\n\tassert(blob_info);\n\tassert(args);\n\tassert(isp_mem_if);\n\n\txinfo = binary->info;\n\tinfo  = &xinfo->sp;\n\t{\n\t\t \n\t\tu8 program_input_circuit;\n\n\t\tprogram_input_circuit = sh_css_sp_stage.program_input_circuit;\n\t\tmemset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));\n\t\tsh_css_sp_stage.program_input_circuit = (uint8_t)program_input_circuit;\n\t}\n\n\tia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\n\n\tif (!info) {\n\t\tsh_css_sp_group.pipe[thread_id].sp_stage_addr[stage] = mmgr_NULL;\n\t\treturn 0;\n\t}\n\n\tif (IS_ISP2401)\n\t\tsh_css_sp_stage.deinterleaved = 0;\n\telse\n\t\tsh_css_sp_stage.deinterleaved = ((stage == 0) && continuous);\n\n\tinitialize_stage_frames(&sh_css_sp_stage.frames);\n\t \n\tsh_css_sp_stage.stage_type = SH_CSS_ISP_STAGE_TYPE;\n\tsh_css_sp_stage.num\t\t= (uint8_t)stage;\n\tsh_css_sp_stage.isp_online\t= (uint8_t)binary->online;\n\tsh_css_sp_stage.isp_copy_vf     = (uint8_t)args->copy_vf;\n\tsh_css_sp_stage.isp_copy_output = (uint8_t)args->copy_output;\n\tsh_css_sp_stage.enable.vf_output = (args->out_vf_frame != NULL);\n\n\t \n\tsh_css_sp_stage.frames.effective_in_res.width = binary->effective_in_frame_res.width;\n\tsh_css_sp_stage.frames.effective_in_res.height = binary->effective_in_frame_res.height;\n\n\tia_css_frame_info_to_frame_sp_info(&sh_css_sp_stage.frames.in.info,\n\t\t\t\t\t   &binary->in_frame_info);\n\tfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {\n\t\tia_css_frame_info_to_frame_sp_info(&sh_css_sp_stage.frames.out[i].info,\n\t\t\t\t\t\t   &binary->out_frame_info[i]);\n\t}\n\tia_css_frame_info_to_frame_sp_info(&sh_css_sp_stage.frames.internal_frame_info,\n\t\t\t\t\t   &binary->internal_frame_info);\n\tsh_css_sp_stage.dvs_envelope.width    = binary->dvs_envelope.width;\n\tsh_css_sp_stage.dvs_envelope.height   = binary->dvs_envelope.height;\n\tsh_css_sp_stage.isp_pipe_version      = (uint8_t)info->pipeline.isp_pipe_version;\n\tsh_css_sp_stage.isp_deci_log_factor   = (uint8_t)binary->deci_factor_log2;\n\tsh_css_sp_stage.isp_vf_downscale_bits = (uint8_t)binary->vf_downscale_log2;\n\n\tsh_css_sp_stage.if_config_index = (uint8_t)if_config_index;\n\n\tsh_css_sp_stage.sp_enable_xnr = (uint8_t)xnr;\n\tsh_css_sp_stage.xmem_bin_addr = xinfo->xmem_addr;\n\tsh_css_sp_stage.xmem_map_addr = sh_css_params_ddr_address_map();\n\tsh_css_isp_stage.blob_info = *blob_info;\n\tsh_css_stage_write_binary_info((struct ia_css_binary_info *)info);\n\n\t \n\tassert(strlen(binary_name) < SH_CSS_MAX_BINARY_NAME - 1);\n\tstrscpy(sh_css_isp_stage.binary_name, binary_name, SH_CSS_MAX_BINARY_NAME);\n\tsh_css_isp_stage.mem_initializers = *isp_mem_if;\n\n\t \n\n\terr = sh_css_sp_write_frame_pointers(args);\n\t \n\tif (binary->info->sp.enable.s3a) {\n\t\tia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_3A_STATISTICS, thread_id,\n\t\t\t\t\t       &queue_id);\n\t\tsh_css_copy_buffer_attr_to_spbuffer(&sh_css_sp_stage.frames.s3a_buf, queue_id,\n\t\t\t\t\t\t    mmgr_EXCEPTION,\n\t\t\t\t\t\t    IA_CSS_BUFFER_TYPE_3A_STATISTICS);\n\t}\n\tif (binary->info->sp.enable.dis) {\n\t\tia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_DIS_STATISTICS, thread_id,\n\t\t\t\t\t       &queue_id);\n\t\tsh_css_copy_buffer_attr_to_spbuffer(&sh_css_sp_stage.frames.dvs_buf, queue_id,\n\t\t\t\t\t\t    mmgr_EXCEPTION,\n\t\t\t\t\t\t    IA_CSS_BUFFER_TYPE_DIS_STATISTICS);\n\t}\n\tia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_METADATA, thread_id, &queue_id);\n\tsh_css_copy_buffer_attr_to_spbuffer(&sh_css_sp_stage.frames.metadata_buf, queue_id, mmgr_EXCEPTION, IA_CSS_BUFFER_TYPE_METADATA);\n\tif (err)\n\t\treturn err;\n\n#ifdef ISP2401\n\tpipe = find_pipe_by_num(sh_css_sp_group.pipe[thread_id].pipe_num);\n\tif (!pipe)\n\t\treturn -EINVAL;\n\n\tif (args->in_frame)\n\t\tia_css_get_crop_offsets(pipe, &args->in_frame->frame_info);\n\telse\n\t\tia_css_get_crop_offsets(pipe, &binary->in_frame_info);\n#else\n\t(void)pipe;  \n#endif\n\n\terr = configure_isp_from_args(&sh_css_sp_group.pipe[thread_id],\n\t\t\t\t      binary, args, two_ppc, sh_css_sp_stage.deinterleaved);\n\tif (err)\n\t\treturn err;\n\n\tinitialize_isp_states(binary);\n\n\t \n\tif (binary->info->sp.pipeline.mode == IA_CSS_BINARY_MODE_PREVIEW &&\n\t    (binary->vf_downscale_log2 > 0)) {\n\t\t \n\t\tsh_css_sp_stage.frames.out[0].info.padded_width\n\t\t<<= binary->vf_downscale_log2;\n\t\tsh_css_sp_stage.frames.out[0].info.res.width\n\t\t<<= binary->vf_downscale_log2;\n\t\tsh_css_sp_stage.frames.out[0].info.res.height\n\t\t<<= binary->vf_downscale_log2;\n\t}\n\terr = copy_isp_mem_if_to_ddr(binary);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int\nsp_init_stage(struct ia_css_pipeline_stage *stage,\n\t      unsigned int pipe_num,\n\t      bool xnr,\n\t      unsigned int if_config_index,\n\t      bool two_ppc)\n{\n\tstruct ia_css_binary *binary;\n\tconst struct ia_css_fw_info *firmware;\n\tconst struct sh_css_binary_args *args;\n\tunsigned int stage_num;\n\t \n\tconst char *binary_name = \"\";\n\tconst struct ia_css_binary_xinfo *info = NULL;\n\t \n\tstatic struct ia_css_binary tmp_binary;\n\tconst struct ia_css_blob_info *blob_info = NULL;\n\tstruct ia_css_isp_param_css_segments isp_mem_if;\n\t \n\tstruct ia_css_isp_param_css_segments *mem_if = &isp_mem_if;\n\n\tint err = 0;\n\n\tassert(stage);\n\n\tbinary = stage->binary;\n\tfirmware = stage->firmware;\n\targs = &stage->args;\n\tstage_num = stage->stage_num;\n\n\tif (binary) {\n\t\tinfo = binary->info;\n\t\tbinary_name = (const char *)(info->blob->name);\n\t\tblob_info = &info->blob->header.blob;\n\t\tia_css_init_memory_interface(mem_if, &binary->mem_params, &binary->css_params);\n\t} else if (firmware) {\n\t\tconst struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS] = {NULL};\n\n\t\tif (args->out_frame[0])\n\t\t\tout_infos[0] = &args->out_frame[0]->frame_info;\n\t\tinfo = &firmware->info.isp;\n\t\tia_css_binary_fill_info(info, false, false,\n\t\t\t\t\tATOMISP_INPUT_FORMAT_RAW_10,\n\t\t\t\t\tia_css_frame_get_info(args->in_frame),\n\t\t\t\t\tNULL,\n\t\t\t\t\tout_infos,\n\t\t\t\t\tia_css_frame_get_info(args->out_vf_frame),\n\t\t\t\t\t&tmp_binary,\n\t\t\t\t\tNULL,\n\t\t\t\t\t-1, true);\n\t\tbinary = &tmp_binary;\n\t\tbinary->info = info;\n\t\tbinary_name = IA_CSS_EXT_ISP_PROG_NAME(firmware);\n\t\tblob_info = &firmware->blob;\n\t\tmem_if = (struct ia_css_isp_param_css_segments *)&firmware->mem_initializers;\n\t} else {\n\t\t \n\t\tassert(stage->sp_func != IA_CSS_PIPELINE_NO_FUNC);\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\terr = sh_css_sp_init_stage(binary,\n\t\t\t\t   (const char *)binary_name,\n\t\t\t\t   blob_info,\n\t\t\t\t   args,\n\t\t\t\t   pipe_num,\n\t\t\t\t   stage_num,\n\t\t\t\t   xnr,\n\t\t\t\t   mem_if,\n\t\t\t\t   if_config_index,\n\t\t\t\t   two_ppc);\n\treturn err;\n}\n\nstatic void\nsp_init_sp_stage(struct ia_css_pipeline_stage *stage,\n\t\t unsigned int pipe_num,\n\t\t bool two_ppc,\n\t\t enum sh_css_pipe_config_override copy_ovrd,\n\t\t unsigned int if_config_index)\n{\n\tconst struct sh_css_binary_args *args = &stage->args;\n\n\tassert(stage);\n\tswitch (stage->sp_func) {\n\tcase IA_CSS_PIPELINE_RAW_COPY:\n\t\tsh_css_sp_start_raw_copy(args->out_frame[0],\n\t\t\t\t\t pipe_num, two_ppc,\n\t\t\t\t\t stage->max_input_width,\n\t\t\t\t\t copy_ovrd, if_config_index);\n\t\tbreak;\n\tcase IA_CSS_PIPELINE_BIN_COPY:\n\t\tassert(false);  \n\t\tbreak;\n\tcase IA_CSS_PIPELINE_ISYS_COPY:\n\t\tsh_css_sp_start_isys_copy(args->out_frame[0],\n\t\t\t\t\t  pipe_num, stage->max_input_width, if_config_index);\n\t\tbreak;\n\tcase IA_CSS_PIPELINE_NO_FUNC:\n\t\tassert(false);\n\t\tbreak;\n\t}\n}\n\nvoid\nsh_css_sp_init_pipeline(struct ia_css_pipeline *me,\n\t\t\tenum ia_css_pipe_id id,\n\t\t\tu8 pipe_num,\n\t\t\tbool xnr,\n\t\t\tbool two_ppc,\n\t\t\tbool continuous,\n\t\t\tbool offline,\n\t\t\tunsigned int required_bds_factor,\n\t\t\tenum sh_css_pipe_config_override copy_ovrd,\n\t\t\tenum ia_css_input_mode input_mode,\n\t\t\tconst struct ia_css_metadata_config *md_config,\n\t\t\tconst struct ia_css_metadata_info *md_info,\n\t\t\tconst enum mipi_port_id port_id)\n{\n\t \n\tstruct ia_css_pipeline_stage *stage        = NULL;\n\tstruct ia_css_binary\t     *first_binary = NULL;\n\tstruct ia_css_pipe *pipe = NULL;\n\tunsigned int num;\n\tenum ia_css_pipe_id pipe_id = id;\n\tunsigned int thread_id;\n\tu8 if_config_index, tmp_if_config_index;\n\n\tif (!me->stages) {\n\t\tdev_err(atomisp_dev, \"%s called on a pipeline without stages\\n\",\n\t\t\t__func__);\n\t\treturn;  \n\t}\n\n\tfirst_binary = me->stages->binary;\n\n\tif (input_mode == IA_CSS_INPUT_MODE_SENSOR ||\n\t    input_mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {\n\t\tassert(port_id < N_MIPI_PORT_ID);\n\t\tif (port_id >= N_MIPI_PORT_ID)  \n\t\t\treturn;  \n\t\tif_config_index  = (uint8_t)(port_id - MIPI_PORT0_ID);\n\t} else if (input_mode == IA_CSS_INPUT_MODE_MEMORY) {\n\t\tif_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;\n\t} else {\n\t\tif_config_index = 0x0;\n\t}\n\n\tia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\n\tmemset(&sh_css_sp_group.pipe[thread_id], 0, sizeof(struct sh_css_sp_pipeline));\n\n\t \n\tfor (stage = me->stages, num = 0; stage; stage = stage->next, num++) {\n\t\tstage->stage_num = num;\n\t\tia_css_debug_pipe_graph_dump_stage(stage, id);\n\t}\n\tme->num_stages = num;\n\n\tif (first_binary) {\n\t\t \n\t\tsh_css_sp_init_group(two_ppc, first_binary->input_format,\n\t\t\t\t     offline, if_config_index);\n\t}  \n\n\t \n\tif (me->num_stages == 1 &&\n\t    me->stages->sp_func == IA_CSS_PIPELINE_ISYS_COPY)\n\t\tsh_css_sp_group.config.no_isp_sync = true;\n\n\t \n\tsh_css_init_host2sp_frame_data();\n\n\tsh_css_sp_group.pipe[thread_id].num_stages = 0;\n\tsh_css_sp_group.pipe[thread_id].pipe_id = pipe_id;\n\tsh_css_sp_group.pipe[thread_id].thread_id = thread_id;\n\tsh_css_sp_group.pipe[thread_id].pipe_num = pipe_num;\n\tsh_css_sp_group.pipe[thread_id].num_execs = me->num_execs;\n\tsh_css_sp_group.pipe[thread_id].pipe_qos_config = QOS_INVALID;\n\tsh_css_sp_group.pipe[thread_id].required_bds_factor = required_bds_factor;\n\tsh_css_sp_group.pipe[thread_id].input_system_mode\n\t= (uint32_t)input_mode;\n\tsh_css_sp_group.pipe[thread_id].port_id = port_id;\n\tsh_css_sp_group.pipe[thread_id].dvs_frame_delay = (uint32_t)me->dvs_frame_delay;\n\n\t \n\tif (ia_css_pipeline_uses_params(me)) {\n\t\tsh_css_sp_group.pipe[thread_id].pipe_config =\n\t\tSH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id;\n\t}\n\n\t \n\tif (continuous)\n\t\tsh_css_sp_group.pipe[thread_id].pipe_config = 0;\n\n\tsh_css_sp_group.pipe[thread_id].inout_port_config = me->inout_port_config;\n\n\tpipe = find_pipe_by_num(pipe_num);\n\tassert(pipe);\n\tif (!pipe) {\n\t\treturn;\n\t}\n\tsh_css_sp_group.pipe[thread_id].scaler_pp_lut = sh_css_pipe_get_pp_gdc_lut(pipe);\n\n\tif (md_info && md_info->size > 0) {\n\t\tsh_css_sp_group.pipe[thread_id].metadata.width  = md_info->resolution.width;\n\t\tsh_css_sp_group.pipe[thread_id].metadata.height = md_info->resolution.height;\n\t\tsh_css_sp_group.pipe[thread_id].metadata.stride = md_info->stride;\n\t\tsh_css_sp_group.pipe[thread_id].metadata.size   = md_info->size;\n\t\tia_css_isys_convert_stream_format_to_mipi_format(\n\t\t    md_config->data_type, MIPI_PREDICTOR_NONE,\n\t\t    &sh_css_sp_group.pipe[thread_id].metadata.format);\n\t}\n\n\tsh_css_sp_group.pipe[thread_id].output_frame_queue_id = (uint32_t)SH_CSS_INVALID_QUEUE_ID;\n\tif (pipe_id != IA_CSS_PIPE_ID_COPY) {\n\t\tia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, thread_id,\n\t\t\t\t\t       (enum sh_css_queue_id *)(\n\t\t\t\t\t\t   &sh_css_sp_group.pipe[thread_id].output_frame_queue_id));\n\t}\n\n\tIA_CSS_LOG(\"pipe_id %d port_config %08x\",\n\t\t   pipe_id, sh_css_sp_group.pipe[thread_id].inout_port_config);\n\n\tfor (stage = me->stages, num = 0; stage; stage = stage->next, num++) {\n\t\tsh_css_sp_group.pipe[thread_id].num_stages++;\n\t\tif (is_sp_stage(stage)) {\n\t\t\tsp_init_sp_stage(stage, pipe_num, two_ppc,\n\t\t\t\t\t copy_ovrd, if_config_index);\n\t\t} else {\n\t\t\tif ((stage->stage_num != 0) ||\n\t\t\t    SH_CSS_PIPE_PORT_CONFIG_IS_CONTINUOUS(me->inout_port_config))\n\t\t\t\ttmp_if_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;\n\t\t\telse\n\t\t\t\ttmp_if_config_index = if_config_index;\n\t\t\tsp_init_stage(stage, pipe_num,\n\t\t\t\t      xnr, tmp_if_config_index, two_ppc);\n\t\t}\n\n\t\tstore_sp_stage_data(pipe_id, pipe_num, num);\n\t}\n\tsh_css_sp_group.pipe[thread_id].pipe_config |= (uint32_t)\n\t\t(me->acquire_isp_each_stage << IA_CSS_ACQUIRE_ISP_POS);\n\tstore_sp_group_data();\n}\n\nvoid\nsh_css_sp_uninit_pipeline(unsigned int pipe_num)\n{\n\tunsigned int thread_id;\n\n\tia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\n\t \n\tsh_css_sp_group.pipe[thread_id].num_stages = 0;\n}\n\nbool sh_css_write_host2sp_command(enum host2sp_commands host2sp_command)\n{\n\tunsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\n\tunsigned int offset = (unsigned int)offsetof(struct host_sp_communication,\n\t\t\t      host2sp_command)\n\t\t\t      / sizeof(int);\n\tenum host2sp_commands last_cmd = host2sp_cmd_error;\n\t(void)HIVE_ADDR_host_sp_com;  \n\n\t \n\tlast_cmd = load_sp_array_uint(host_sp_com, offset);\n\tif (last_cmd != host2sp_cmd_ready)\n\t\tIA_CSS_ERROR(\"last host command not handled by SP(%d)\", last_cmd);\n\n\tstore_sp_array_uint(host_sp_com, offset, host2sp_command);\n\n\treturn (last_cmd == host2sp_cmd_ready);\n}\n\nenum host2sp_commands\nsh_css_read_host2sp_command(void)\n{\n\tunsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\n\tunsigned int offset = (unsigned int)offsetof(struct host_sp_communication, host2sp_command)\n\t/ sizeof(int);\n\t(void)HIVE_ADDR_host_sp_com;  \n\treturn (enum host2sp_commands)load_sp_array_uint(host_sp_com, offset);\n}\n\n \nvoid\nsh_css_init_host2sp_frame_data(void)\n{\n\t \n\tunsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\n\n\t(void)HIVE_ADDR_host_sp_com;  \n\t \n}\n\n \nvoid\nsh_css_update_host2sp_offline_frame(\n    unsigned int frame_num,\n    struct ia_css_frame *frame,\n    struct ia_css_metadata *metadata)\n{\n\tunsigned int HIVE_ADDR_host_sp_com;\n\tunsigned int offset;\n\n\tassert(frame_num < NUM_CONTINUOUS_FRAMES);\n\n\t \n\tHIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\n\toffset = (unsigned int)offsetof(struct host_sp_communication,\n\t\t\t\t\thost2sp_offline_frames)\n\t\t / sizeof(int);\n\toffset += frame_num;\n\tstore_sp_array_uint(host_sp_com, offset, frame ? frame->data : 0);\n\n\t \n\toffset = (unsigned int)offsetof(struct host_sp_communication,\n\t\t\t\t\thost2sp_offline_metadata)\n\t\t / sizeof(int);\n\toffset += frame_num;\n\tstore_sp_array_uint(host_sp_com, offset, metadata ? metadata->address : 0);\n}\n\n \nvoid\nsh_css_update_host2sp_mipi_frame(\n    unsigned int frame_num,\n    struct ia_css_frame *frame)\n{\n\tunsigned int HIVE_ADDR_host_sp_com;\n\tunsigned int offset;\n\n\t \n\tassert(frame_num < (N_CSI_PORTS * NUM_MIPI_FRAMES_PER_STREAM));\n\n\t \n\tHIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\n\toffset = (unsigned int)offsetof(struct host_sp_communication,\n\t\t\t\t\thost2sp_mipi_frames)\n\t\t / sizeof(int);\n\toffset += frame_num;\n\n\tstore_sp_array_uint(host_sp_com, offset,\n\t\t\t    frame ? frame->data : 0);\n}\n\n \nvoid\nsh_css_update_host2sp_mipi_metadata(\n    unsigned int frame_num,\n    struct ia_css_metadata *metadata)\n{\n\tunsigned int HIVE_ADDR_host_sp_com;\n\tunsigned int o;\n\n\t \n\tassert(frame_num < (N_CSI_PORTS * NUM_MIPI_FRAMES_PER_STREAM));\n\n\t \n\tHIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\n\to = offsetof(struct host_sp_communication, host2sp_mipi_metadata)\n\t    / sizeof(int);\n\to += frame_num;\n\tstore_sp_array_uint(host_sp_com, o,\n\t\t\t    metadata ? metadata->address : 0);\n}\n\nvoid\nsh_css_update_host2sp_num_mipi_frames(unsigned int num_frames)\n{\n\tunsigned int HIVE_ADDR_host_sp_com;\n\tunsigned int offset;\n\n\t \n\tHIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\n\toffset = (unsigned int)offsetof(struct host_sp_communication,\n\t\t\t\t\thost2sp_num_mipi_frames)\n\t\t / sizeof(int);\n\n\tstore_sp_array_uint(host_sp_com, offset, num_frames);\n}\n\nvoid\nsh_css_update_host2sp_cont_num_raw_frames(unsigned int num_frames,\n\tbool set_avail)\n{\n\tconst struct ia_css_fw_info *fw;\n\tunsigned int HIVE_ADDR_host_sp_com;\n\tunsigned int extra_num_frames, avail_num_frames;\n\tunsigned int offset, offset_extra;\n\n\t \n\tfw = &sh_css_sp_fw;\n\tHIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;\n\tif (set_avail) {\n\t\toffset = (unsigned int)offsetof(struct host_sp_communication,\n\t\t\t\t\t\thost2sp_cont_avail_num_raw_frames)\n\t\t\t / sizeof(int);\n\t\tavail_num_frames = load_sp_array_uint(host_sp_com, offset);\n\t\textra_num_frames = num_frames - avail_num_frames;\n\t\toffset_extra = (unsigned int)offsetof(struct host_sp_communication,\n\t\t\t\t\t\t      host2sp_cont_extra_num_raw_frames)\n\t\t\t       / sizeof(int);\n\t\tstore_sp_array_uint(host_sp_com, offset_extra, extra_num_frames);\n\t} else\n\t\toffset = (unsigned int)offsetof(struct host_sp_communication,\n\t\t\t\t\t\thost2sp_cont_target_num_raw_frames)\n\t\t\t / sizeof(int);\n\n\tstore_sp_array_uint(host_sp_com, offset, num_frames);\n}\n\nvoid\nsh_css_event_init_irq_mask(void)\n{\n\tint i;\n\tunsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\n\tunsigned int offset;\n\tstruct sh_css_event_irq_mask event_irq_mask_init;\n\n\tevent_irq_mask_init.or_mask  = IA_CSS_EVENT_TYPE_ALL;\n\tevent_irq_mask_init.and_mask = IA_CSS_EVENT_TYPE_NONE;\n\t(void)HIVE_ADDR_host_sp_com;  \n\n\tassert(sizeof(event_irq_mask_init) % HRT_BUS_BYTES == 0);\n\tfor (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {\n\t\toffset = (unsigned int)offsetof(struct host_sp_communication,\n\t\t\t\t\t\thost2sp_event_irq_mask[i]);\n\t\tassert(offset % HRT_BUS_BYTES == 0);\n\t\tsp_dmem_store(SP0_ID,\n\t\t\t      (unsigned int)sp_address_of(host_sp_com) + offset,\n\t\t\t      &event_irq_mask_init, sizeof(event_irq_mask_init));\n\t}\n}\n\nint\nia_css_pipe_set_irq_mask(struct ia_css_pipe *pipe,\n\t\t\t unsigned int or_mask,\n\t\t\t unsigned int and_mask)\n{\n\tunsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\n\tunsigned int offset;\n\tstruct sh_css_event_irq_mask event_irq_mask;\n\tunsigned int pipe_num;\n\n\tassert(pipe);\n\n\tassert(IA_CSS_PIPE_ID_NUM == NR_OF_PIPELINES);\n\t \n\n\t(void)HIVE_ADDR_host_sp_com;  \n\n\tIA_CSS_LOG(\"or_mask=%x, and_mask=%x\", or_mask, and_mask);\n\tevent_irq_mask.or_mask  = (uint16_t)or_mask;\n\tevent_irq_mask.and_mask = (uint16_t)and_mask;\n\n\tpipe_num = ia_css_pipe_get_pipe_num(pipe);\n\tif (pipe_num >= IA_CSS_PIPE_ID_NUM)\n\t\treturn -EINVAL;\n\toffset = (unsigned int)offsetof(struct host_sp_communication,\n\t\t\t\t\thost2sp_event_irq_mask[pipe_num]);\n\tassert(offset % HRT_BUS_BYTES == 0);\n\tsp_dmem_store(SP0_ID,\n\t\t      (unsigned int)sp_address_of(host_sp_com) + offset,\n\t\t      &event_irq_mask, sizeof(event_irq_mask));\n\n\treturn 0;\n}\n\nint\nia_css_event_get_irq_mask(const struct ia_css_pipe *pipe,\n\t\t\t  unsigned int *or_mask,\n\t\t\t  unsigned int *and_mask)\n{\n\tunsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\n\tunsigned int offset;\n\tstruct sh_css_event_irq_mask event_irq_mask;\n\tunsigned int pipe_num;\n\n\t(void)HIVE_ADDR_host_sp_com;  \n\n\tIA_CSS_ENTER_LEAVE(\"\");\n\n\tassert(pipe);\n\tassert(IA_CSS_PIPE_ID_NUM == NR_OF_PIPELINES);\n\n\tpipe_num = ia_css_pipe_get_pipe_num(pipe);\n\tif (pipe_num >= IA_CSS_PIPE_ID_NUM)\n\t\treturn -EINVAL;\n\toffset = (unsigned int)offsetof(struct host_sp_communication,\n\t\t\t\t\thost2sp_event_irq_mask[pipe_num]);\n\tassert(offset % HRT_BUS_BYTES == 0);\n\tsp_dmem_load(SP0_ID,\n\t\t     (unsigned int)sp_address_of(host_sp_com) + offset,\n\t\t     &event_irq_mask, sizeof(event_irq_mask));\n\n\tif (or_mask)\n\t\t*or_mask = event_irq_mask.or_mask;\n\n\tif (and_mask)\n\t\t*and_mask = event_irq_mask.and_mask;\n\n\treturn 0;\n}\n\nvoid\nsh_css_sp_set_sp_running(bool flag)\n{\n\tsp_running = flag;\n}\n\nbool\nsh_css_sp_is_running(void)\n{\n\treturn sp_running;\n}\n\nvoid\nsh_css_sp_start_isp(void)\n{\n\tconst struct ia_css_fw_info *fw;\n\tunsigned int HIVE_ADDR_sp_sw_state;\n\n\tfw = &sh_css_sp_fw;\n\tHIVE_ADDR_sp_sw_state = fw->info.sp.sw_state;\n\n\tif (sp_running)\n\t\treturn;\n\n\t(void)HIVE_ADDR_sp_sw_state;  \n\n\t \n\t \n\n\tstore_sp_group_data();\n\tstore_sp_per_frame_data(fw);\n\n\tsp_dmem_store_uint32(SP0_ID,\n\t\t\t     (unsigned int)sp_address_of(sp_sw_state),\n\t\t\t     (uint32_t)(IA_CSS_SP_SW_TERMINATED));\n\n\t \n\n\t \n\tsp_running = true;\n\tia_css_mmu_invalidate_cache();\n\t \n\tmmu_invalidate_cache_all();\n\n\tia_css_spctrl_start(SP0_ID);\n}\n\nbool\nia_css_isp_has_started(void)\n{\n\tconst struct ia_css_fw_info *fw = &sh_css_sp_fw;\n\tunsigned int HIVE_ADDR_ia_css_ispctrl_sp_isp_started = fw->info.sp.isp_started;\n\t(void)HIVE_ADDR_ia_css_ispctrl_sp_isp_started;  \n\n\treturn (bool)load_sp_uint(ia_css_ispctrl_sp_isp_started);\n}\n\n \nbool\nsh_css_sp_init_dma_sw_reg(int dma_id)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < N_DMA_CHANNEL_ID; i++) {\n\t\t \n\t\tsh_css_sp_set_dma_sw_reg(dma_id,\n\t\t\t\t\t i,\n\t\t\t\t\t 0,\n\t\t\t\t\t true);\n\t\t \n\t\tsh_css_sp_set_dma_sw_reg(dma_id,\n\t\t\t\t\t i,\n\t\t\t\t\t 1,\n\t\t\t\t\t true);\n\t}\n\n\treturn true;\n}\n\n \nbool\nsh_css_sp_set_dma_sw_reg(int dma_id,\n\t\t\t int channel_id,\n\t\t\t int request_type,\n\t\t\t bool enable)\n{\n\tu32 sw_reg;\n\tu32 bit_val;\n\tu32 bit_offset;\n\tu32 bit_mask;\n\n\t(void)dma_id;\n\n\tassert(channel_id >= 0 && channel_id < N_DMA_CHANNEL_ID);\n\tassert(request_type >= 0);\n\n\t \n\tsw_reg =\n\t    sh_css_sp_group.debug.dma_sw_reg;\n\n\t \n\tbit_offset = (8 * request_type) + channel_id;\n\n\t \n\tbit_mask = ~(1 << bit_offset);\n\tsw_reg &= bit_mask;\n\n\t \n\tbit_val = enable ? 1 : 0;\n\tbit_val <<= bit_offset;\n\tsw_reg |= bit_val;\n\n\t \n\tsh_css_sp_group.debug.dma_sw_reg = sw_reg;\n\n\treturn true;\n}\n\nvoid\nsh_css_sp_reset_global_vars(void)\n{\n\tmemset(&sh_css_sp_group, 0, sizeof(struct sh_css_sp_group));\n\tmemset(&sh_css_sp_stage, 0, sizeof(struct sh_css_sp_stage));\n\tmemset(&sh_css_isp_stage, 0, sizeof(struct sh_css_isp_stage));\n\tmemset(&sh_css_sp_output, 0, sizeof(struct sh_css_sp_output));\n\tmemset(&per_frame_data, 0, sizeof(struct sh_css_sp_per_frame_data));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}