{
  "module_name": "sh_css_firmware.c",
  "hash_id": "71fbe456de9eeee9c4dc5faf7acfd45c39317b9558168fc9459ecc0f338c18e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/sh_css_firmware.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>  \n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\n#include \"hmm.h\"\n\n#include <math_support.h>\n#include \"platform_support.h\"\n#include \"sh_css_firmware.h\"\n\n#include \"sh_css_defs.h\"\n#include \"ia_css_debug.h\"\n#include \"sh_css_internal.h\"\n#include \"ia_css_isp_param.h\"\n\n#include \"assert_support.h\"\n\n#include \"isp.h\"\t\t\t\t \n\n#include \"ia_css_isp_params.h\"\n#include \"ia_css_isp_configs.h\"\n#include \"ia_css_isp_states.h\"\n\n#define _STR(x) #x\n#define STR(x) _STR(x)\n\nstruct firmware_header {\n\tstruct sh_css_fw_bi_file_h file_header;\n\tstruct ia_css_fw_info      binary_header;\n};\n\nstruct fw_param {\n\tconst char *name;\n\tconst void *buffer;\n};\n\nstatic struct firmware_header *firmware_header;\n\n \nstatic const char *release_version_2401 = STR(irci_stable_candrpv_0415_20150521_0458);\nstatic const char *release_version_2400 = STR(irci_stable_candrpv_0415_20150423_1753);\n\n#define MAX_FW_REL_VER_NAME\t300\nstatic char FW_rel_ver_name[MAX_FW_REL_VER_NAME] = \"---\";\n\nstruct ia_css_fw_info\t  sh_css_sp_fw;\nstruct ia_css_blob_descr *sh_css_blob_info;  \nunsigned int sh_css_num_binaries;  \n\nstatic struct fw_param *fw_minibuffer;\n\nchar *sh_css_get_fw_version(void)\n{\n\treturn FW_rel_ver_name;\n}\n\n \n\n \nstatic int\nsetup_binary(struct ia_css_fw_info *fw, const char *fw_data,\n\t     struct ia_css_fw_info *sh_css_fw, unsigned int binary_id)\n{\n\tconst char *blob_data;\n\n\tif ((!fw) || (!fw_data))\n\t\treturn -EINVAL;\n\n\tblob_data = fw_data + fw->blob.offset;\n\n\t*sh_css_fw = *fw;\n\n\tsh_css_fw->blob.code = vmalloc(fw->blob.size);\n\tif (!sh_css_fw->blob.code)\n\t\treturn -ENOMEM;\n\n\tmemcpy((void *)sh_css_fw->blob.code, blob_data, fw->blob.size);\n\tsh_css_fw->blob.data = (char *)sh_css_fw->blob.code + fw->blob.data_source;\n\tfw_minibuffer[binary_id].buffer = sh_css_fw->blob.code;\n\n\treturn 0;\n}\n\nint\nsh_css_load_blob_info(const char *fw, const struct ia_css_fw_info *bi,\n\t\t      struct ia_css_blob_descr *bd,\n\t\t      unsigned int index)\n{\n\tconst char *name;\n\tconst unsigned char *blob;\n\n\tif ((!fw) || (!bd))\n\t\treturn -EINVAL;\n\n\t \n\tif (!bi)\n\t\tbi = (const struct ia_css_fw_info *)fw;\n\n\tname = fw + bi->blob.prog_name_offset;\n\tblob = (const unsigned char *)fw + bi->blob.offset;\n\n\t \n\tif (bi->blob.size !=\n\t\tbi->blob.text_size + bi->blob.icache_size +\n\t\t\tbi->blob.data_size + bi->blob.padding_size) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif ((bi->blob.offset % (1UL << (ISP_PMEM_WIDTH_LOG2 - 3))) != 0)\n\t\treturn -EINVAL;\n\n\tbd->blob = blob;\n\tbd->header = *bi;\n\n\tif (bi->type == ia_css_isp_firmware || bi->type == ia_css_sp_firmware) {\n\t\tchar *namebuffer;\n\n\t\tnamebuffer = kstrdup(name, GFP_KERNEL);\n\t\tif (!namebuffer)\n\t\t\treturn -ENOMEM;\n\t\tbd->name = fw_minibuffer[index].name = namebuffer;\n\t} else {\n\t\tbd->name = name;\n\t}\n\n\tif (bi->type == ia_css_isp_firmware) {\n\t\tsize_t paramstruct_size = sizeof(struct ia_css_memory_offsets);\n\t\tsize_t configstruct_size = sizeof(struct ia_css_config_memory_offsets);\n\t\tsize_t statestruct_size = sizeof(struct ia_css_state_memory_offsets);\n\n\t\tchar *parambuf = kmalloc(paramstruct_size + configstruct_size +\n\t\t\t\t\t statestruct_size,\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!parambuf)\n\t\t\treturn -ENOMEM;\n\n\t\tbd->mem_offsets.array[IA_CSS_PARAM_CLASS_PARAM].ptr = NULL;\n\t\tbd->mem_offsets.array[IA_CSS_PARAM_CLASS_CONFIG].ptr = NULL;\n\t\tbd->mem_offsets.array[IA_CSS_PARAM_CLASS_STATE].ptr = NULL;\n\n\t\tfw_minibuffer[index].buffer = parambuf;\n\n\t\t \n\t\tmemcpy(parambuf, (void *)(fw +\n\t\t\t\t\t  bi->blob.memory_offsets.offsets[IA_CSS_PARAM_CLASS_PARAM]),\n\t\t       paramstruct_size);\n\t\tbd->mem_offsets.array[IA_CSS_PARAM_CLASS_PARAM].ptr = parambuf;\n\n\t\t \n\t\tmemcpy(parambuf + paramstruct_size,\n\t\t       (void *)(fw + bi->blob.memory_offsets.offsets[IA_CSS_PARAM_CLASS_CONFIG]),\n\t\t       configstruct_size);\n\t\tbd->mem_offsets.array[IA_CSS_PARAM_CLASS_CONFIG].ptr = parambuf +\n\t\tparamstruct_size;\n\n\t\t \n\t\tmemcpy(parambuf + paramstruct_size + configstruct_size,\n\t\t       (void *)(fw + bi->blob.memory_offsets.offsets[IA_CSS_PARAM_CLASS_STATE]),\n\t\t       statestruct_size);\n\t\tbd->mem_offsets.array[IA_CSS_PARAM_CLASS_STATE].ptr = parambuf +\n\t\tparamstruct_size + configstruct_size;\n\t}\n\treturn 0;\n}\n\nbool\nsh_css_check_firmware_version(struct device *dev, const char *fw_data)\n{\n\tconst char *release_version;\n\tstruct sh_css_fw_bi_file_h *file_header;\n\n\tif (IS_ISP2401)\n\t\trelease_version = release_version_2401;\n\telse\n\t\trelease_version = release_version_2400;\n\n\tfirmware_header = (struct firmware_header *)fw_data;\n\tfile_header = &firmware_header->file_header;\n\n\tif (strcmp(file_header->version, release_version) != 0) {\n\t\tdev_err(dev, \"Firmware version may not be compatible with this driver\\n\");\n\t\tdev_err(dev, \"Expecting version '%s', but firmware is '%s'.\\n\",\n\t\t\trelease_version, file_header->version);\n\t}\n\n\t \n\treturn false;\n}\n\nstatic const char * const fw_type_name[] = {\n\t[ia_css_sp_firmware]\t\t= \"SP\",\n\t[ia_css_isp_firmware]\t\t= \"ISP\",\n\t[ia_css_bootloader_firmware]\t= \"BootLoader\",\n\t[ia_css_acc_firmware]\t\t= \"accel\",\n};\n\nstatic const char * const fw_acc_type_name[] = {\n\t[IA_CSS_ACC_NONE] =\t\t\"Normal\",\n\t[IA_CSS_ACC_OUTPUT] =\t\t\"Accel for output\",\n\t[IA_CSS_ACC_VIEWFINDER] =\t\"Accel for viewfinder\",\n\t[IA_CSS_ACC_STANDALONE] =\t\"Stand-alone accel\",\n};\n\nint\nsh_css_load_firmware(struct device *dev, const char *fw_data,\n\t\t     unsigned int fw_size)\n{\n\tunsigned int i;\n\tconst char *release_version;\n\tstruct ia_css_fw_info *binaries;\n\tstruct sh_css_fw_bi_file_h *file_header;\n\tint ret;\n\n\t \n\tif (!fw_data || fw_size < sizeof(struct sh_css_fw_bi_file_h))\n\t\treturn -EINVAL;\n\n\tfirmware_header = (struct firmware_header *)fw_data;\n\tfile_header = &firmware_header->file_header;\n\n\tif (file_header->h_size != sizeof(struct sh_css_fw_bi_file_h))\n\t\treturn -EINVAL;\n\n\tbinaries = &firmware_header->binary_header;\n\tstrscpy(FW_rel_ver_name, file_header->version,\n\t\tmin(sizeof(FW_rel_ver_name), sizeof(file_header->version)));\n\tif (IS_ISP2401)\n\t\trelease_version = release_version_2401;\n\telse\n\t\trelease_version = release_version_2400;\n\tret = sh_css_check_firmware_version(dev, fw_data);\n\tif (ret) {\n\t\tIA_CSS_ERROR(\"CSS code version (%s) and firmware version (%s) mismatch!\",\n\t\t\t     file_header->version, release_version);\n\t\treturn -EINVAL;\n\t} else {\n\t\tIA_CSS_LOG(\"successfully load firmware version %s\", release_version);\n\t}\n\n\tsh_css_num_binaries = file_header->binary_nr;\n\t \n\tif (sh_css_num_binaries > NUM_OF_SPS) {\n\t\tsh_css_blob_info = kmalloc(\n\t\t    (sh_css_num_binaries - NUM_OF_SPS) *\n\t\t    sizeof(*sh_css_blob_info), GFP_KERNEL);\n\t\tif (!sh_css_blob_info)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tsh_css_blob_info = NULL;\n\t}\n\n\tfw_minibuffer = kcalloc(sh_css_num_binaries, sizeof(struct fw_param),\n\t\t\t\tGFP_KERNEL);\n\tif (!fw_minibuffer)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < sh_css_num_binaries; i++) {\n\t\tstruct ia_css_fw_info *bi = &binaries[i];\n\t\t \n\t\tstatic struct ia_css_blob_descr bd;\n\t\tint err;\n\n\t\terr = sh_css_load_blob_info(fw_data, bi, &bd, i);\n\n\t\tif (err)\n\t\t\treturn -EINVAL;\n\n\t\tif (bi->blob.offset + bi->blob.size > fw_size)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (bd.header.type) {\n\t\tcase ia_css_isp_firmware:\n\t\t\tif (bd.header.info.isp.type > IA_CSS_ACC_STANDALONE) {\n\t\t\t\tdev_err(dev, \"binary #%2d: invalid SP type\\n\",\n\t\t\t\t\ti);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"binary #%-2d type %s (%s), binary id is %2d: %s\\n\",\n\t\t\t\ti,\n\t\t\t\tfw_type_name[bd.header.type],\n\t\t\t\tfw_acc_type_name[bd.header.info.isp.type],\n\t\t\t\tbd.header.info.isp.sp.id,\n\t\t\t\tbd.name);\n\t\t\tbreak;\n\t\tcase ia_css_sp_firmware:\n\t\tcase ia_css_bootloader_firmware:\n\t\tcase ia_css_acc_firmware:\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"binary #%-2d type %s: %s\\n\",\n\t\t\t\ti, fw_type_name[bd.header.type],\n\t\t\t\tbd.name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (bd.header.info.isp.type > IA_CSS_ACC_STANDALONE) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"binary #%2d: invalid firmware type\\n\",\n\t\t\t\t\ti);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (bi->type == ia_css_sp_firmware) {\n\t\t\tif (i != SP_FIRMWARE)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = setup_binary(bi, fw_data, &sh_css_sp_fw, i);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else {\n\t\t\t \n\t\t\tif (i < NUM_OF_SPS)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (bi->type != ia_css_isp_firmware)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!sh_css_blob_info)  \n\t\t\t\treturn -EINVAL;\n\t\t\tsh_css_blob_info[i - NUM_OF_SPS] = bd;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid sh_css_unload_firmware(void)\n{\n\t \n\tif (fw_minibuffer) {\n\t\tunsigned int i = 0;\n\n\t\tfor (i = 0; i < sh_css_num_binaries; i++) {\n\t\t\tkfree(fw_minibuffer[i].name);\n\t\t\tkvfree(fw_minibuffer[i].buffer);\n\t\t}\n\t\tkfree(fw_minibuffer);\n\t\tfw_minibuffer = NULL;\n\t}\n\n\tmemset(&sh_css_sp_fw, 0, sizeof(sh_css_sp_fw));\n\tkfree(sh_css_blob_info);\n\tsh_css_blob_info = NULL;\n\tsh_css_num_binaries = 0;\n}\n\nia_css_ptr\nsh_css_load_blob(const unsigned char *blob, unsigned int size)\n{\n\tia_css_ptr target_addr = hmm_alloc(size);\n\t \n\n\tassert(blob);\n\tif (target_addr)\n\t\thmm_store(target_addr, blob, size);\n\treturn target_addr;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}