{
  "module_name": "ia_css_ctc2.host.c",
  "hash_id": "406e5a207e409e0b54cc80cf890950a7c3936f0ca919aec387c7c4cc5ab04eee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c",
  "human_readable_source": "\n \n\n#include \"ia_css_types.h\"\n#include \"sh_css_defs.h\"\n#include \"assert_support.h\"\n\n#include \"ia_css_ctc2.host.h\"\n\n#define INEFFECTIVE_VAL 4096\n#define BASIC_VAL 819\n\n \nconst struct ia_css_ctc2_config default_ctc2_config = {\n\tINEFFECTIVE_VAL, INEFFECTIVE_VAL, INEFFECTIVE_VAL,\n\tINEFFECTIVE_VAL, INEFFECTIVE_VAL, INEFFECTIVE_VAL,\n\tBASIC_VAL * 2, BASIC_VAL * 4, BASIC_VAL * 6,\n\tBASIC_VAL * 8, INEFFECTIVE_VAL, INEFFECTIVE_VAL,\n\tBASIC_VAL >> 1, BASIC_VAL\n};\n\n \nstatic int ctc2_slope(int y1, int y0, int x1, int x0)\n{\n\tconst int shift_val = 8;\n\tconst int max_slope = (1 << IA_CSS_CTC_COEF_SHIFT) - 1;\n\tint dy = y1 - y0;\n\tint dx = x1 - x0;\n\tint rounding = (dx + 1) >> 1;\n\tint dy_shift = dy << shift_val;\n\tint slope, dydx;\n\n\t \n\tassert(y0 >= 0 && y0 <= max_slope);\n\tassert(y1 >= 0 && y1 <= max_slope);\n\tassert(x0 >= 0 && x0 <= max_slope);\n\tassert(x1 > 0 && x1 <= max_slope);\n\tassert(dx > 0);\n\n\tif (dy < 0)\n\t\trounding = -rounding;\n\tslope = (int)(dy_shift + rounding) / dx;\n\n\t \n\tif (slope <= -max_slope - 1) {\n\t\tdydx = -max_slope - 1;\n\t} else if (slope >= max_slope) {\n\t\tdydx = max_slope;\n\t} else {\n\t\tdydx = slope;\n\t}\n\n\treturn dydx;\n}\n\n \nvoid ia_css_ctc2_vmem_encode(struct ia_css_isp_ctc2_vmem_params *to,\n\t\t\t     const struct ia_css_ctc2_config *from,\n\t\t\t     size_t size)\n{\n\tunsigned int i, j;\n\tconst unsigned int shffl_blck = 4;\n\tconst unsigned int length_zeros = 11;\n\tshort dydx0, dydx1, dydx2, dydx3, dydx4;\n\n\t(void)size;\n\t \n\tdydx0 = ctc2_slope(from->y_y1, from->y_y0,\n\t\t\t   from->y_x1, 0);\n\tdydx1 = ctc2_slope(from->y_y2, from->y_y1,\n\t\t\t   from->y_x2, from->y_x1);\n\tdydx2 = ctc2_slope(from->y_y3, from->y_y2,\n\t\t\t   from->y_x3, from->y_x2);\n\tdydx3 = ctc2_slope(from->y_y4, from->y_y3,\n\t\t\t   from->y_x4, from->y_x3);\n\tdydx4 = ctc2_slope(from->y_y5, from->y_y4,\n\t\t\t   SH_CSS_BAYER_MAXVAL, from->y_x4);\n\n\t \n\tfor (i = 0; i < shffl_blck; i++) {\n\t\tto->y_x[0][(i << shffl_blck)]     = 0;\n\t\tto->y_x[0][(i << shffl_blck) + 1] = from->y_x1;\n\t\tto->y_x[0][(i << shffl_blck) + 2] = from->y_x2;\n\t\tto->y_x[0][(i << shffl_blck) + 3] = from->y_x3;\n\t\tto->y_x[0][(i << shffl_blck) + 4] = from->y_x4;\n\n\t\tto->y_y[0][(i << shffl_blck)]     = from->y_y0;\n\t\tto->y_y[0][(i << shffl_blck) + 1] = from->y_y1;\n\t\tto->y_y[0][(i << shffl_blck) + 2] = from->y_y2;\n\t\tto->y_y[0][(i << shffl_blck) + 3] = from->y_y3;\n\t\tto->y_y[0][(i << shffl_blck) + 4] = from->y_y4;\n\n\t\tto->e_y_slope[0][(i << shffl_blck)]    = dydx0;\n\t\tto->e_y_slope[0][(i << shffl_blck) + 1] = dydx1;\n\t\tto->e_y_slope[0][(i << shffl_blck) + 2] = dydx2;\n\t\tto->e_y_slope[0][(i << shffl_blck) + 3] = dydx3;\n\t\tto->e_y_slope[0][(i << shffl_blck) + 4] = dydx4;\n\n\t\tfor (j = 0; j < length_zeros; j++) {\n\t\t\tto->y_x[0][(i << shffl_blck) + 5 + j] = 0;\n\t\t\tto->y_y[0][(i << shffl_blck) + 5 + j] = 0;\n\t\t\tto->e_y_slope[0][(i << shffl_blck) + 5 + j] = 0;\n\t\t}\n\t}\n}\n\n \nvoid ia_css_ctc2_encode(struct ia_css_isp_ctc2_dmem_params *to,\n\t\t\tstruct ia_css_ctc2_config *from,\n\t\t\tsize_t size)\n{\n\t(void)size;\n\n\tto->uv_y0 = from->uv_y0;\n\tto->uv_y1 = from->uv_y1;\n\tto->uv_x0 = from->uv_x0;\n\tto->uv_x1 = from->uv_x1;\n\n\t \n\tto->uv_dydx = ctc2_slope(from->uv_y1, from->uv_y0,\n\t\t\t\t from->uv_x1, from->uv_x0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}