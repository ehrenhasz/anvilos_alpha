{
  "module_name": "ia_css_dvs.host.c",
  "hash_id": "e6ab6f72b1386a2909b5a6d6289f755551c91ae8e5193ea6ad8fba405b6f4327",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c",
  "human_readable_source": "\n \n\n#include \"hmm.h\"\n\n#include \"ia_css_frame_public.h\"\n#define IA_CSS_INCLUDE_CONFIGURATIONS\n#include \"ia_css_isp_configs.h\"\n\n#include \"ia_css_types.h\"\n#include \"ia_css_host_data.h\"\n#include \"sh_css_param_dvs.h\"\n#include \"sh_css_params.h\"\n#include \"ia_css_binary.h\"\n#include \"ia_css_debug.h\"\n#include \"assert_support.h\"\n\n#include \"ia_css_dvs.host.h\"\n\nstatic const struct ia_css_dvs_configuration default_config = {\n\t.info = (struct ia_css_frame_info *)NULL,\n};\n\nvoid\nia_css_dvs_config(\n    struct sh_css_isp_dvs_isp_config *to,\n    const struct ia_css_dvs_configuration  *from,\n    unsigned int size)\n{\n\t(void)size;\n\tto->num_horizontal_blocks =\n\t    DVS_NUM_BLOCKS_X(from->info->res.width);\n\tto->num_vertical_blocks =\n\t    DVS_NUM_BLOCKS_Y(from->info->res.height);\n}\n\nint ia_css_dvs_configure(const struct ia_css_binary     *binary,\n\t\t\t const struct ia_css_frame_info *info)\n{\n\tstruct ia_css_dvs_configuration config = default_config;\n\n\tconfig.info = info;\n\n\treturn ia_css_configure_dvs(binary, &config);\n}\n\nstatic void\nconvert_coords_to_ispparams(\n    struct ia_css_host_data *gdc_warp_table,\n    const struct ia_css_dvs_6axis_config *config,\n    unsigned int i_stride,\n    unsigned int o_width,\n    unsigned int o_height,\n    unsigned int uv_flag)\n{\n\tunsigned int i, j;\n\tgdc_warp_param_mem_t s = { 0 };\n\tunsigned int x00, x01, x10, x11,\n\t\t y00, y01, y10, y11;\n\n\tunsigned int xmin, ymin, xmax, ymax;\n\tunsigned int topleft_x, topleft_y, bottom_x, bottom_y,\n\t\t topleft_x_frac, topleft_y_frac;\n\tunsigned int dvs_interp_envelope = (DVS_GDC_INTERP_METHOD == HRT_GDC_BLI_MODE ?\n\t\t\t\t\t    DVS_GDC_BLI_INTERP_ENVELOPE : DVS_GDC_BCI_INTERP_ENVELOPE);\n\n\t \n\tunsigned int num_blocks_y =  (uv_flag ? DVS_NUM_BLOCKS_Y_CHROMA(\n\t\t\t\t\t  o_height) : DVS_NUM_BLOCKS_Y(o_height));\n\tunsigned int num_blocks_x =  (uv_flag ? DVS_NUM_BLOCKS_X_CHROMA(\n\t\t\t\t\t  o_width)  : DVS_NUM_BLOCKS_X(\n\t\t\t\t\t  o_width)); \n\n\tunsigned int in_stride = i_stride * DVS_INPUT_BYTES_PER_PIXEL;\n\tunsigned int width, height;\n\tunsigned int *xbuff = NULL;\n\tunsigned int *ybuff = NULL;\n\tstruct gdc_warp_param_mem_s *ptr;\n\n\tassert(config);\n\tassert(gdc_warp_table);\n\tassert(gdc_warp_table->address);\n\n\tptr = (struct gdc_warp_param_mem_s *)gdc_warp_table->address;\n\n\tptr += (2 * uv_flag);  \n\n\tif (uv_flag == 0) {\n\t\txbuff = config->xcoords_y;\n\t\tybuff = config->ycoords_y;\n\t\twidth = config->width_y;\n\t\theight = config->height_y;\n\t} else {\n\t\txbuff = config->xcoords_uv;\n\t\tybuff = config->ycoords_uv;\n\t\twidth = config->width_uv;\n\t\theight = config->height_uv;\n\t}\n\n\tIA_CSS_LOG(\"blockdim_x %d blockdim_y %d\",\n\t\t   DVS_BLOCKDIM_X, DVS_BLOCKDIM_Y_LUMA >> uv_flag);\n\tIA_CSS_LOG(\"num_blocks_x %d num_blocks_y %d\", num_blocks_x, num_blocks_y);\n\tIA_CSS_LOG(\"width %d height %d\", width, height);\n\n\tassert(width == num_blocks_x +\n\t       1); \n\tassert(height == num_blocks_y + 1);\n\n\tfor (j = 0; j < num_blocks_y; j++) {\n\t\tfor (i = 0; i < num_blocks_x; i++) {\n\t\t\tx00 = xbuff[j * width + i];\n\t\t\tx01 = xbuff[j * width + (i + 1)];\n\t\t\tx10 = xbuff[(j + 1) * width + i];\n\t\t\tx11 = xbuff[(j + 1) * width + (i + 1)];\n\n\t\t\ty00 = ybuff[j * width + i];\n\t\t\ty01 = ybuff[j * width + (i + 1)];\n\t\t\ty10 = ybuff[(j + 1) * width + i];\n\t\t\ty11 = ybuff[(j + 1) * width + (i + 1)];\n\n\t\t\txmin = min(x00, x10);\n\t\t\txmax = max(x01, x11);\n\t\t\tymin = min(y00, y01);\n\t\t\tymax = max(y10, y11);\n\n\t\t\t \n\t\t\tassert(x01 >= xmin);\n\t\t\tassert(x11 >= xmin);\n\t\t\t \n\t\t\tassert(y10 >= ymin);\n\t\t\tassert(y11 >= ymin);\n\n\t\t\ttopleft_y = ymin >> DVS_COORD_FRAC_BITS;\n\t\t\ttopleft_x = ((xmin >> DVS_COORD_FRAC_BITS)\n\t\t\t\t     >> XMEM_ALIGN_LOG2)\n\t\t\t\t    << (XMEM_ALIGN_LOG2);\n\t\t\ts.in_addr_offset = topleft_y * in_stride + topleft_x;\n\n\t\t\t \n\t\t\tbottom_y = CEIL_DIV(ymax, 1 << DVS_COORD_FRAC_BITS);\n\t\t\ts.in_block_height = bottom_y - topleft_y + dvs_interp_envelope;\n\n\t\t\tbottom_x = CEIL_DIV(xmax, 1 << DVS_COORD_FRAC_BITS);\n\t\t\ts.in_block_width = bottom_x - topleft_x + dvs_interp_envelope;\n\n\t\t\ttopleft_x_frac = topleft_x << (DVS_COORD_FRAC_BITS);\n\t\t\ttopleft_y_frac = topleft_y << (DVS_COORD_FRAC_BITS);\n\n\t\t\ts.p0_x = x00 - topleft_x_frac;\n\t\t\ts.p1_x = x01 - topleft_x_frac;\n\t\t\ts.p2_x = x10 - topleft_x_frac;\n\t\t\ts.p3_x = x11 - topleft_x_frac;\n\n\t\t\ts.p0_y = y00 - topleft_y_frac;\n\t\t\ts.p1_y = y01 - topleft_y_frac;\n\t\t\ts.p2_y = y10 - topleft_y_frac;\n\t\t\ts.p3_y = y11 - topleft_y_frac;\n\n\t\t\t\n\t\t\tassert(s.p0_x < (s.in_block_width << DVS_COORD_FRAC_BITS));\n\t\t\tassert(s.p1_x < (s.in_block_width << DVS_COORD_FRAC_BITS));\n\t\t\tassert(s.p2_x < (s.in_block_width << DVS_COORD_FRAC_BITS));\n\t\t\tassert(s.p3_x < (s.in_block_width << DVS_COORD_FRAC_BITS));\n\t\t\tassert(s.p0_y < (s.in_block_height << DVS_COORD_FRAC_BITS));\n\t\t\tassert(s.p1_y < (s.in_block_height << DVS_COORD_FRAC_BITS));\n\t\t\tassert(s.p2_y < (s.in_block_height << DVS_COORD_FRAC_BITS));\n\t\t\tassert(s.p3_y < (s.in_block_height << DVS_COORD_FRAC_BITS));\n\n\t\t\t\n\t\t\tassert(s.p0_x < s.p1_x);\n\t\t\tassert(s.p2_x < s.p3_x);\n\t\t\tassert(s.p0_y < s.p2_y);\n\t\t\tassert(s.p1_y < s.p3_y);\n\n#if 0\n\t\t\tprintf(\"j: %d\\ti:%d\\n\", j, i);\n\t\t\tprintf(\"offset: %d\\n\", s.in_addr_offset);\n\t\t\tprintf(\"p0_x: %d\\n\", s.p0_x);\n\t\t\tprintf(\"p0_y: %d\\n\", s.p0_y);\n\t\t\tprintf(\"p1_x: %d\\n\", s.p1_x);\n\t\t\tprintf(\"p1_y: %d\\n\", s.p1_y);\n\t\t\tprintf(\"p2_x: %d\\n\", s.p2_x);\n\t\t\tprintf(\"p2_y: %d\\n\", s.p2_y);\n\t\t\tprintf(\"p3_x: %d\\n\", s.p3_x);\n\t\t\tprintf(\"p3_y: %d\\n\", s.p3_y);\n\n\t\t\tprintf(\"p0_x_nofrac[0]: %d\\n\", s.p0_x >> DVS_COORD_FRAC_BITS);\n\t\t\tprintf(\"p0_y_nofrac[1]: %d\\n\", s.p0_y >> DVS_COORD_FRAC_BITS);\n\t\t\tprintf(\"p1_x_nofrac[2]: %d\\n\", s.p1_x >> DVS_COORD_FRAC_BITS);\n\t\t\tprintf(\"p1_y_nofrac[3]: %d\\n\", s.p1_y >> DVS_COORD_FRAC_BITS);\n\t\t\tprintf(\"p2_x_nofrac[0]: %d\\n\", s.p2_x >> DVS_COORD_FRAC_BITS);\n\t\t\tprintf(\"p2_y_nofrac[1]: %d\\n\", s.p2_y >> DVS_COORD_FRAC_BITS);\n\t\t\tprintf(\"p3_x_nofrac[2]: %d\\n\", s.p3_x >> DVS_COORD_FRAC_BITS);\n\t\t\tprintf(\"p3_y_nofrac[3]: %d\\n\", s.p3_y >> DVS_COORD_FRAC_BITS);\n\t\t\tprintf(\"\\n\");\n#endif\n\n\t\t\t*ptr = s;\n\n\t\t\t\n\t\t\t\n\t\t\t \n\t\t\tif (uv_flag)\n\t\t\t\tptr += 3;\n\t\t\telse\n\t\t\t\tptr += (1 + (i & 1));\n\t\t}\n\t}\n}\n\nstruct ia_css_host_data *\nconvert_allocate_dvs_6axis_config(\n    const struct ia_css_dvs_6axis_config *dvs_6axis_config,\n    const struct ia_css_binary *binary,\n    const struct ia_css_frame_info *dvs_in_frame_info)\n{\n\tunsigned int i_stride;\n\tunsigned int o_width;\n\tunsigned int o_height;\n\tstruct ia_css_host_data *me;\n\n\tassert(binary);\n\tassert(dvs_6axis_config);\n\tassert(dvs_in_frame_info);\n\n\tme = ia_css_host_data_allocate((size_t)((DVS_6AXIS_BYTES(binary) / 2) * 3));\n\n\tif (!me)\n\t\treturn NULL;\n\n\t \n\tassert((dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_NV12)\n\t       || (dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_YUV420));\n\n\ti_stride  = dvs_in_frame_info->padded_width;\n\n\to_width  = binary->out_frame_info[0].res.width;\n\to_height = binary->out_frame_info[0].res.height;\n\n\t \n\tconvert_coords_to_ispparams(me, dvs_6axis_config,\n\t\t\t\t    i_stride, o_width, o_height, 0);\n\n\tif (dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_YUV420) {\n\t\t \n\t\ti_stride /= 2;\n\t}\n\n\t \n\tconvert_coords_to_ispparams(me, dvs_6axis_config,\n\t\t\t\t    i_stride, o_width / 2, o_height / 2, 1);\n\n\treturn me;\n}\n\nint\nstore_dvs_6axis_config(\n    const struct ia_css_dvs_6axis_config *dvs_6axis_config,\n    const struct ia_css_binary *binary,\n    const struct ia_css_frame_info *dvs_in_frame_info,\n    ia_css_ptr ddr_addr_y) {\n\tstruct ia_css_host_data *me;\n\n\tassert(dvs_6axis_config);\n\tassert(ddr_addr_y != mmgr_NULL);\n\tassert(dvs_in_frame_info);\n\n\tme = convert_allocate_dvs_6axis_config(dvs_6axis_config,\n\t\t\t\t\t       binary,\n\t\t\t\t\t       dvs_in_frame_info);\n\n\tif (!me)\n\t{\n\t\tIA_CSS_LEAVE_ERR_PRIVATE(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tia_css_params_store_ia_css_host_data(\n\t    ddr_addr_y,\n\t    me);\n\tia_css_host_data_free(me);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}