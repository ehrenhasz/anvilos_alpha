{
  "module_name": "ia_css_bnlm.host.c",
  "hash_id": "b9aa112589fedae347ac3e3437951c75953f52de4d4bd23a1575395b013004cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/isp/kernels/bnlm/ia_css_bnlm.host.c",
  "human_readable_source": "\n \n\n#include \"type_support.h\"\n#include \"ia_css_bnlm.host.h\"\n\n#ifndef IA_CSS_NO_DEBUG\n#include \"ia_css_debug.h\"  \n#endif\n#include <assert_support.h>\n\n#define BNLM_DIV_LUT_SIZE\t(12)\nstatic const s32 div_lut_nearests[BNLM_DIV_LUT_SIZE] = {\n\t0, 454, 948, 1484, 2070, 2710, 3412, 4184, 5035, 5978, 7025, 8191\n};\n\nstatic const s32 div_lut_slopes[BNLM_DIV_LUT_SIZE] = {\n\t-7760, -6960, -6216, -5536, -4912, -4344, -3832, -3360, -2936, -2552, -2208, -2208\n    };\n\nstatic const s32 div_lut_intercepts[BNLM_DIV_LUT_SIZE] = {\n\t8184, 7752, 7336, 6928, 6536, 6152, 5776, 5416, 5064, 4728, 4408, 4408\n};\n\n \nstatic inline void\nbnlm_lut_encode(struct bnlm_lut *lut, const int32_t *lut_thr,\n\t\tconst s32 *lut_val, const uint32_t lut_size)\n{\n\tu32 blk, i;\n\tconst u32 block_size = 16;\n\tconst u32 total_blocks = ISP_VEC_NELEMS / block_size;\n\n\t \n\tassert((lut_size >= 2) && (lut_size <= block_size));\n\t \n\tfor (i = 0; i < lut_size - 2; i++) {\n\t\t \n\t\tassert(lut_thr[i] <= lut_thr[i + 1]);\n\t}\n\n\t \n\tfor (i = 0; i < total_blocks * block_size; i++) {\n\t\tlut->thr[0][i] = 0;\n\t\tlut->val[0][i] = 0;\n\t}\n\n\t \n\tfor (i = 0; i < lut_size - 1; i++) {\n\t\tlut->thr[0][i] = lut_thr[i];\n\t\tlut->val[0][i] = lut_val[i];\n\t}\n\tlut->val[0][i] = lut_val[i];  \n\n\t \n\tfor (blk = 1; blk < total_blocks; blk++) {\n\t\tu32 blk_offset = blk * block_size;\n\n\t\tfor (i = 1; i < lut_size; i++) {\n\t\t\tlut->thr[0][blk_offset + i] = lut->thr[0][i];\n\t\t\tlut->val[0][blk_offset + i] = lut->val[0][i];\n\t\t}\n\t}\n}\n\n \nvoid\nia_css_bnlm_vmem_encode(\n    struct bnlm_vmem_params *to,\n    const struct ia_css_bnlm_config *from,\n    size_t size)\n{\n\tint i;\n\t(void)size;\n\n\t \n\tbnlm_lut_encode(&to->mu_root_lut, from->mu_root_lut_thr, from->mu_root_lut_val,\n\t\t\t16);\n\tbnlm_lut_encode(&to->sad_norm_lut, from->sad_norm_lut_thr,\n\t\t\tfrom->sad_norm_lut_val, 16);\n\tbnlm_lut_encode(&to->sig_detail_lut, from->sig_detail_lut_thr,\n\t\t\tfrom->sig_detail_lut_val, 16);\n\tbnlm_lut_encode(&to->sig_rad_lut, from->sig_rad_lut_thr, from->sig_rad_lut_val,\n\t\t\t16);\n\tbnlm_lut_encode(&to->rad_pow_lut, from->rad_pow_lut_thr, from->rad_pow_lut_val,\n\t\t\t16);\n\tbnlm_lut_encode(&to->nl_0_lut, from->nl_0_lut_thr, from->nl_0_lut_val, 16);\n\tbnlm_lut_encode(&to->nl_1_lut, from->nl_1_lut_thr, from->nl_1_lut_val, 16);\n\tbnlm_lut_encode(&to->nl_2_lut, from->nl_2_lut_thr, from->nl_2_lut_val, 16);\n\tbnlm_lut_encode(&to->nl_3_lut, from->nl_3_lut_thr, from->nl_3_lut_val, 16);\n\n\t \n\tmemset(to->nl_th, 0, sizeof(to->nl_th));\n\tto->nl_th[0][0] = from->nl_th[0];\n\tto->nl_th[0][1] = from->nl_th[1];\n\tto->nl_th[0][2] = from->nl_th[2];\n\n\tmemset(to->match_quality_max_idx, 0, sizeof(to->match_quality_max_idx));\n\tto->match_quality_max_idx[0][0] = from->match_quality_max_idx[0];\n\tto->match_quality_max_idx[0][1] = from->match_quality_max_idx[1];\n\tto->match_quality_max_idx[0][2] = from->match_quality_max_idx[2];\n\tto->match_quality_max_idx[0][3] = from->match_quality_max_idx[3];\n\n\tbnlm_lut_encode(&to->div_lut, div_lut_nearests, div_lut_slopes,\n\t\t\tBNLM_DIV_LUT_SIZE);\n\tmemset(to->div_lut_intercepts, 0, sizeof(to->div_lut_intercepts));\n\tfor (i = 0; i < BNLM_DIV_LUT_SIZE; i++) {\n\t\tto->div_lut_intercepts[0][i] = div_lut_intercepts[i];\n\t}\n\n\tmemset(to->power_of_2, 0, sizeof(to->power_of_2));\n\tfor (i = 0; i < (ISP_VEC_ELEMBITS - 1); i++) {\n\t\tto->power_of_2[0][i] = 1 << i;\n\t}\n}\n\n \nvoid\nia_css_bnlm_encode(\n    struct bnlm_dmem_params *to,\n    const struct ia_css_bnlm_config *from,\n    size_t size)\n{\n\t(void)size;\n\tto->rad_enable = from->rad_enable;\n\tto->rad_x_origin = from->rad_x_origin;\n\tto->rad_y_origin = from->rad_y_origin;\n\tto->avg_min_th = from->avg_min_th;\n\tto->max_min_th = from->max_min_th;\n\n\tto->exp_coeff_a = from->exp_coeff_a;\n\tto->exp_coeff_b = from->exp_coeff_b;\n\tto->exp_coeff_c = from->exp_coeff_c;\n\tto->exp_exponent = from->exp_exponent;\n}\n\n \nvoid\nia_css_bnlm_debug_trace(\n    const struct ia_css_bnlm_config *config,\n    unsigned int level)\n{\n\tif (!config)\n\t\treturn;\n\n#ifndef IA_CSS_NO_DEBUG\n\tia_css_debug_dtrace(level, \"BNLM:\\n\");\n\tia_css_debug_dtrace(level, \"\\t%-32s = %d\\n\", \"rad_enable\", config->rad_enable);\n\tia_css_debug_dtrace(level, \"\\t%-32s = %d\\n\", \"rad_x_origin\",\n\t\t\t    config->rad_x_origin);\n\tia_css_debug_dtrace(level, \"\\t%-32s = %d\\n\", \"rad_y_origin\",\n\t\t\t    config->rad_y_origin);\n\tia_css_debug_dtrace(level, \"\\t%-32s = %d\\n\", \"avg_min_th\", config->avg_min_th);\n\tia_css_debug_dtrace(level, \"\\t%-32s = %d\\n\", \"max_min_th\", config->max_min_th);\n\n\tia_css_debug_dtrace(level, \"\\t%-32s = %d\\n\", \"exp_coeff_a\",\n\t\t\t    config->exp_coeff_a);\n\tia_css_debug_dtrace(level, \"\\t%-32s = %d\\n\", \"exp_coeff_b\",\n\t\t\t    config->exp_coeff_b);\n\tia_css_debug_dtrace(level, \"\\t%-32s = %d\\n\", \"exp_coeff_c\",\n\t\t\t    config->exp_coeff_c);\n\tia_css_debug_dtrace(level, \"\\t%-32s = %d\\n\", \"exp_exponent\",\n\t\t\t    config->exp_exponent);\n\n\t \n#endif  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}