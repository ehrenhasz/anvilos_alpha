{
  "module_name": "ia_css_xnr3.host.c",
  "hash_id": "5ba85f8b9b38322d83b919cccec8c56684b5382b32182d105d2b4f8294abd5b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c",
  "human_readable_source": "\n \n\n#include \"type_support.h\"\n#include \"math_support.h\"\n#include \"sh_css_defs.h\"\n#include \"ia_css_types.h\"\n#include \"assert_support.h\"\n#include \"ia_css_xnr3.host.h\"\n\n \n#define XNR_MAX_ALPHA  ((1 << (ISP_VEC_ELEMBITS - 1)) - 1)\n\n \n#define XNR_MIN_SIGMA  (IA_CSS_XNR3_SIGMA_SCALE / 100)\n\n \n#define XNR3_LOOK_UP_TABLE_POINTS 16\n\nstatic const s16 x[XNR3_LOOK_UP_TABLE_POINTS] = {\n\t1024, 1164, 1320, 1492, 1680, 1884, 2108, 2352,\n\t2616, 2900, 3208, 3540, 3896, 4276, 4684, 5120\n};\n\nstatic const s16 a[XNR3_LOOK_UP_TABLE_POINTS] = {\n\t-7213, -5580, -4371, -3421, -2722, -2159, -6950, -5585,\n\t    -4529, -3697, -3010, -2485, -2070, -1727, -1428, 0\n    };\n\nstatic const s16 b[XNR3_LOOK_UP_TABLE_POINTS] = {\n\t4096, 3603, 3178, 2811, 2497, 2226, 1990, 1783,\n\t1603, 1446, 1307, 1185, 1077, 981, 895, 819\n};\n\nstatic const s16 c[XNR3_LOOK_UP_TABLE_POINTS] = {\n\t1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n};\n\n \nconst struct ia_css_xnr3_config default_xnr3_config = {\n\t \n\t{ 0, 0, 0, 0, 0, 0 },\n\t \n\t{ 0, 0, 0, 0 },\n\t \n\t{ 0 }\n};\n\n \nstatic int32_t\ncompute_alpha(int sigma)\n{\n\ts32 alpha;\n\tint offset = sigma / 2;\n\n\tif (sigma < XNR_MIN_SIGMA) {\n\t\talpha = XNR_MAX_ALPHA;\n\t} else {\n\t\talpha = ((IA_CSS_XNR3_SIGMA_SCALE * XNR_ALPHA_SCALE_FACTOR) + offset) / sigma;\n\n\t\tif (alpha > XNR_MAX_ALPHA)\n\t\t\talpha = XNR_MAX_ALPHA;\n\t}\n\n\treturn alpha;\n}\n\n \nstatic int32_t\ncompute_coring(int coring)\n{\n\ts32 isp_coring;\n\ts32 isp_scale = XNR_CORING_SCALE_FACTOR;\n\ts32 host_scale = IA_CSS_XNR3_CORING_SCALE;\n\ts32 offset = host_scale / 2;  \n\n\t \n\tisp_coring = ((coring * isp_scale) + offset) / host_scale;\n\treturn min(max(isp_coring, 0), isp_scale - 1);\n}\n\n \nstatic int32_t\ncompute_blending(int strength)\n{\n\ts32 isp_strength;\n\ts32 isp_scale = XNR_BLENDING_SCALE_FACTOR;\n\ts32 host_scale = IA_CSS_XNR3_BLENDING_SCALE;\n\ts32 offset = host_scale / 2;  \n\n\t \n\tisp_strength = -(((strength * isp_scale) + offset) / host_scale);\n\treturn MAX(MIN(isp_strength, 0), -isp_scale);\n}\n\nvoid\nia_css_xnr3_encode(\n    struct sh_css_isp_xnr3_params *to,\n    const struct ia_css_xnr3_config *from,\n    unsigned int size)\n{\n\tint kernel_size = XNR_FILTER_SIZE;\n\t \n\tint adjust_factor = ceil_pow2(kernel_size);\n\ts32 max_diff = (1 << (ISP_VEC_ELEMBITS - 1)) - 1;\n\ts32 min_diff = -(1 << (ISP_VEC_ELEMBITS - 1));\n\n\ts32 alpha_y0 = compute_alpha(from->sigma.y0);\n\ts32 alpha_y1 = compute_alpha(from->sigma.y1);\n\ts32 alpha_u0 = compute_alpha(from->sigma.u0);\n\ts32 alpha_u1 = compute_alpha(from->sigma.u1);\n\ts32 alpha_v0 = compute_alpha(from->sigma.v0);\n\ts32 alpha_v1 = compute_alpha(from->sigma.v1);\n\ts32 alpha_ydiff = (alpha_y1 - alpha_y0) * adjust_factor / kernel_size;\n\ts32 alpha_udiff = (alpha_u1 - alpha_u0) * adjust_factor / kernel_size;\n\ts32 alpha_vdiff = (alpha_v1 - alpha_v0) * adjust_factor / kernel_size;\n\n\ts32 coring_u0 = compute_coring(from->coring.u0);\n\ts32 coring_u1 = compute_coring(from->coring.u1);\n\ts32 coring_v0 = compute_coring(from->coring.v0);\n\ts32 coring_v1 = compute_coring(from->coring.v1);\n\ts32 coring_udiff = (coring_u1 - coring_u0) * adjust_factor / kernel_size;\n\ts32 coring_vdiff = (coring_v1 - coring_v0) * adjust_factor / kernel_size;\n\n\ts32 blending = compute_blending(from->blending.strength);\n\n\t(void)size;\n\n\t \n\tto->alpha.y0 = alpha_y0;\n\tto->alpha.u0 = alpha_u0;\n\tto->alpha.v0 = alpha_v0;\n\tto->alpha.ydiff = min(max(alpha_ydiff, min_diff), max_diff);\n\tto->alpha.udiff = min(max(alpha_udiff, min_diff), max_diff);\n\tto->alpha.vdiff = min(max(alpha_vdiff, min_diff), max_diff);\n\n\t \n\tto->coring.u0 = coring_u0;\n\tto->coring.v0 = coring_v0;\n\tto->coring.udiff = min(max(coring_udiff, min_diff), max_diff);\n\tto->coring.vdiff = min(max(coring_vdiff, min_diff), max_diff);\n\n\t \n\tto->blending.strength = blending;\n}\n\n \n \nvoid\nia_css_xnr3_vmem_encode(\n    struct sh_css_isp_xnr3_vmem_params *to,\n    const struct ia_css_xnr3_config *from,\n    unsigned int size)\n{\n\tunsigned int i, j, base;\n\tconst unsigned int total_blocks = 4;\n\tconst unsigned int shuffle_block = 16;\n\n\t(void)from;\n\t(void)size;\n\n\t \n\tfor (i = 0; i < ISP_VEC_NELEMS; i++) {\n\t\tto->x[0][i] = 0;\n\t\tto->a[0][i] = 0;\n\t\tto->b[0][i] = 0;\n\t\tto->c[0][i] = 0;\n\t}\n\n\t \n\tassert(x[0] >= 0);\n\n\tfor (j = 1; j < XNR3_LOOK_UP_TABLE_POINTS; j++) {\n\t\tassert(x[j] >= 0);\n\t\tassert(x[j] > x[j - 1]);\n\t}\n\n\t \n\t \n\tfor (i = 0; i < total_blocks; i++) {\n\t\tbase = shuffle_block * i;\n\n\t\tfor (j = 0; j < XNR3_LOOK_UP_TABLE_POINTS; j++) {\n\t\t\tto->x[0][base + j] = x[j];\n\t\t\tto->a[0][base + j] = a[j];\n\t\t\tto->b[0][base + j] = b[j];\n\t\t\tto->c[0][base + j] = c[j];\n\t\t}\n\t}\n}\n\n \nvoid\nia_css_xnr3_debug_dtrace(\n    const struct ia_css_xnr3_config *config,\n    unsigned int level)\n{\n\t(void)config;\n\t(void)level;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}