{
  "module_name": "sh_css_mipi.c",
  "hash_id": "16dfa8a45ff795440c876a6fbe038ca62081048dee55187af0bbb1331202b501",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/sh_css_mipi.c",
  "human_readable_source": "\n \n\n#include \"ia_css_mipi.h\"\n#include \"sh_css_mipi.h\"\n#include <type_support.h>\n#include \"system_global.h\"\n#include \"ia_css_err.h\"\n#include \"ia_css_pipe.h\"\n#include \"ia_css_stream_format.h\"\n#include \"sh_css_stream_format.h\"\n#include \"ia_css_stream_public.h\"\n#include \"ia_css_frame_public.h\"\n#include \"ia_css_input_port.h\"\n#include \"ia_css_debug.h\"\n#include \"sh_css_struct.h\"\n#include \"sh_css_defs.h\"\n#include \"sh_css_sp.h\"  \n#include \"sw_event_global.h\"  \n\nstatic u32\nref_count_mipi_allocation[N_CSI_PORTS];  \n\n \nint\nia_css_mipi_frame_calculate_size(const unsigned int width,\n\t\t\t\t const unsigned int height,\n\t\t\t\t const enum atomisp_input_format format,\n\t\t\t\t const bool hasSOLandEOL,\n\t\t\t\t const unsigned int embedded_data_size_words,\n\t\t\t\t unsigned int *size_mem_words)\n{\n\tint err = 0;\n\n\tunsigned int bits_per_pixel = 0;\n\tunsigned int even_line_bytes = 0;\n\tunsigned int odd_line_bytes = 0;\n\tunsigned int words_per_odd_line = 0;\n\tunsigned int words_for_first_line = 0;\n\tunsigned int words_per_even_line = 0;\n\tunsigned int mem_words_per_even_line = 0;\n\tunsigned int mem_words_per_odd_line = 0;\n\tunsigned int mem_words_for_first_line = 0;\n\tunsigned int mem_words_for_EOF = 0;\n\tunsigned int mem_words = 0;\n\tunsigned int width_padded = width;\n\n\t \n\tif (IS_ISP2401)\n\t\twidth_padded += (2 * ISP_VEC_NELEMS);\n\n\tIA_CSS_ENTER(\"padded_width=%d, height=%d, format=%d, hasSOLandEOL=%d, embedded_data_size_words=%d\\n\",\n\t\t     width_padded, height, format, hasSOLandEOL, embedded_data_size_words);\n\n\tswitch (format) {\n\tcase ATOMISP_INPUT_FORMAT_RAW_6:\t\t \n\t\tbits_per_pixel = 6;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RAW_7:\t\t \n\t\tbits_per_pixel = 7;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RAW_8:\t\t \n\tcase ATOMISP_INPUT_FORMAT_BINARY_8:\t\t \n\tcase ATOMISP_INPUT_FORMAT_YUV420_8:\t\t \n\t\tbits_per_pixel = 8;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV420_10:\t\t \n\tcase ATOMISP_INPUT_FORMAT_RAW_10:\t\t \n\t\t \n\t\tbits_per_pixel = 10;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY:\t \n\tcase ATOMISP_INPUT_FORMAT_RAW_12:\t\t \n\t\tbits_per_pixel = 12;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RAW_14:\t\t \n\t\tbits_per_pixel = 14;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RGB_444:\t\t \n\tcase ATOMISP_INPUT_FORMAT_RGB_555:\t\t \n\tcase ATOMISP_INPUT_FORMAT_RGB_565:\t\t \n\tcase ATOMISP_INPUT_FORMAT_YUV422_8:\t\t \n\t\tbits_per_pixel = 16;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RGB_666:\t\t \n\t\tbits_per_pixel = 18;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_YUV422_10:\t\t \n\t\tbits_per_pixel = 20;\n\t\tbreak;\n\tcase ATOMISP_INPUT_FORMAT_RGB_888:\t\t \n\t\tbits_per_pixel = 24;\n\t\tbreak;\n\n\tcase ATOMISP_INPUT_FORMAT_YUV420_16:\t\t \n\tcase ATOMISP_INPUT_FORMAT_YUV422_16:\t\t \n\tcase ATOMISP_INPUT_FORMAT_RAW_16:\t\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\todd_line_bytes = (width_padded * bits_per_pixel + 7) >> 3;  \n\n\t \n\tif (format == ATOMISP_INPUT_FORMAT_YUV420_8\n\t    || format == ATOMISP_INPUT_FORMAT_YUV420_10\n\t    || format == ATOMISP_INPUT_FORMAT_YUV420_16) {\n\t\teven_line_bytes = (width_padded * 2 * bits_per_pixel + 7) >>\n\t\t\t3;  \n\t} else {\n\t\teven_line_bytes = odd_line_bytes;\n\t}\n\n\t \n\n\twords_per_odd_line = (odd_line_bytes + 3) >> 2;\n\t \n\twords_per_even_line  = (even_line_bytes  + 3) >> 2;\n\twords_for_first_line = words_per_odd_line + 2 + (hasSOLandEOL ? 1 : 0);\n\t \n\twords_per_odd_line\t+= (1 + (hasSOLandEOL ? 2 : 0));\n\t \n\twords_per_even_line += (1 + (hasSOLandEOL ? 2 : 0));\n\n\tmem_words_per_odd_line\t = (words_per_odd_line + 7) >> 3;\n\t \n\tmem_words_for_first_line = (words_for_first_line + 7) >> 3;\n\tmem_words_per_even_line  = (words_per_even_line + 7) >> 3;\n\tmem_words_for_EOF        = 1;  \n\n\tmem_words = ((embedded_data_size_words + 7) >> 3) +\n\tmem_words_for_first_line +\n\t(((height + 1) >> 1) - 1) * mem_words_per_odd_line +\n\t \n\t(height      >> 1) * mem_words_per_even_line +  \n\tmem_words_for_EOF;\n\n\t*size_mem_words = mem_words;  \n\t \n\n\tIA_CSS_LEAVE_ERR(err);\n\treturn err;\n}\n\n \n\n#if !defined(ISP2401)\nint\nia_css_mipi_frame_enable_check_on_size(const enum mipi_port_id port,\n\t\t\t\t       const unsigned int\tsize_mem_words)\n{\n\tu32 idx;\n\n\tint err = -EBUSY;\n\n\tOP___assert(port < N_CSI_PORTS);\n\tOP___assert(size_mem_words != 0);\n\n\tfor (idx = 0; idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT &&\n\t     my_css.mipi_sizes_for_check[port][idx] != 0;\n\t     idx++) {  \n\t}\n\tif (idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT) {\n\t\tmy_css.mipi_sizes_for_check[port][idx] = size_mem_words;\n\t\terr = 0;\n\t}\n\n\treturn err;\n}\n#endif\n\nvoid\nmipi_init(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < N_CSI_PORTS; i++)\n\t\tref_count_mipi_allocation[i] = 0;\n}\n\nbool mipi_is_free(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < N_CSI_PORTS; i++)\n\t\tif (ref_count_mipi_allocation[i])\n\t\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int calculate_mipi_buff_size(struct ia_css_stream_config *stream_cfg,\n\t\t\t\t    unsigned int *size_mem_words)\n{\n\tunsigned int width;\n\tunsigned int height;\n\tenum atomisp_input_format format;\n\tbool pack_raw_pixels;\n\n\tunsigned int width_padded;\n\tunsigned int bits_per_pixel = 0;\n\n\tunsigned int even_line_bytes = 0;\n\tunsigned int odd_line_bytes = 0;\n\n\tunsigned int words_per_odd_line = 0;\n\tunsigned int words_per_even_line = 0;\n\n\tunsigned int mem_words_per_even_line = 0;\n\tunsigned int mem_words_per_odd_line = 0;\n\n\tunsigned int mem_words_per_buff_line = 0;\n\tunsigned int mem_words_per_buff = 0;\n\tint err = 0;\n\n\t \n\twidth = stream_cfg->input_config.input_res.width;\n\theight = stream_cfg->input_config.input_res.height;\n\tformat = stream_cfg->input_config.format;\n\tpack_raw_pixels = stream_cfg->pack_raw_pixels;\n\t \n\n\t \n\t \n\twidth_padded = width + (2 * ISP_VEC_NELEMS);\n\t \n\n\tIA_CSS_ENTER(\"padded_width=%d, height=%d, format=%d\\n\",\n\t\t     width_padded, height, format);\n\n\tbits_per_pixel = sh_css_stream_format_2_bits_per_subpixel(format);\n\tbits_per_pixel =\n\t(format == ATOMISP_INPUT_FORMAT_RAW_10 && pack_raw_pixels) ? bits_per_pixel : 16;\n\tif (bits_per_pixel == 0)\n\t\treturn -EINVAL;\n\n\todd_line_bytes = (width_padded * bits_per_pixel + 7) >> 3;  \n\n\t \n\tif (format == ATOMISP_INPUT_FORMAT_YUV420_8\n\t    || format == ATOMISP_INPUT_FORMAT_YUV420_10) {\n\t\teven_line_bytes = (width_padded * 2 * bits_per_pixel + 7) >>\n\t\t\t3;  \n\t} else {\n\t\teven_line_bytes = odd_line_bytes;\n\t}\n\n\twords_per_odd_line\t = (odd_line_bytes   + 3) >> 2;\n\t \n\twords_per_even_line  = (even_line_bytes  + 3) >> 2;\n\n\tmem_words_per_odd_line\t = (words_per_odd_line + 7) >> 3;\n\t \n\tmem_words_per_even_line  = (words_per_even_line + 7) >> 3;\n\n\tmem_words_per_buff_line =\n\t(mem_words_per_odd_line > mem_words_per_even_line) ? mem_words_per_odd_line : mem_words_per_even_line;\n\tmem_words_per_buff = mem_words_per_buff_line * height;\n\n\t*size_mem_words = mem_words_per_buff;\n\n\tIA_CSS_LEAVE_ERR(err);\n\treturn err;\n}\n\nint\nallocate_mipi_frames(struct ia_css_pipe *pipe,\n\t\t     struct ia_css_stream_info *info)\n{\n\tint err = -EINVAL;\n\tunsigned int port;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"allocate_mipi_frames(%p) enter:\\n\", pipe);\n\n\tif (IS_ISP2401 && pipe->stream->config.online) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t\t    \"allocate_mipi_frames(%p) exit: no buffers needed for 2401 pipe mode.\\n\",\n\t\t\t\t    pipe);\n\t\treturn 0;\n\t}\n\n\tif (pipe->stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t\t    \"allocate_mipi_frames(%p) exit: no buffers needed for pipe mode.\\n\",\n\t\t\t\t    pipe);\n\t\treturn 0;  \n\t}\n\n\tport = (unsigned int)pipe->stream->config.source.port.port;\n\tif (port >= N_CSI_PORTS) {\n\t\tIA_CSS_ERROR(\"allocate_mipi_frames(%p) exit: port is not correct (port=%d).\",\n\t\t\t     pipe, port);\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ISP2401)\n\t\terr = calculate_mipi_buff_size(&pipe->stream->config,\n\t\t\t\t\t       &my_css.mipi_frame_size[port]);\n\n\t \n\tif (ref_count_mipi_allocation[port] != 0) {\n\t\tif (IS_ISP2401)\n\t\t\tref_count_mipi_allocation[port]++;\n\n\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t\t    \"allocate_mipi_frames(%p) leave: nothing to do, already allocated for this port (port=%d).\\n\",\n\t\t\t\t    pipe, port);\n\t\treturn 0;\n\t}\n\n\tref_count_mipi_allocation[port]++;\n\n\t \n\tmy_css.num_mipi_frames[port] = NUM_MIPI_FRAMES_PER_STREAM;\n\n\t \n\t{  \n\t\tunsigned int i, j;\n\n\t\tfor (i = 0; i < my_css.num_mipi_frames[port]; i++) {\n\t\t\t \n\t\t\tif (my_css.mipi_frames[port][i]) {\n\t\t\t\tia_css_frame_free(my_css.mipi_frames[port][i]);\n\t\t\t\tmy_css.mipi_frames[port][i] = NULL;\n\t\t\t}\n\t\t\t \n\t\t\tif (i < my_css.num_mipi_frames[port]) {\n\t\t\t\t \n\t\t\t\terr = ia_css_frame_allocate_with_buffer_size(\n\t\t\t\t\t  &my_css.mipi_frames[port][i],\n\t\t\t\t\t  my_css.mipi_frame_size[port] * HIVE_ISP_DDR_WORD_BYTES);\n\t\t\t\tif (err) {\n\t\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\t\tif (my_css.mipi_frames[port][j]) {\n\t\t\t\t\t\t\tia_css_frame_free(my_css.mipi_frames[port][j]);\n\t\t\t\t\t\t\tmy_css.mipi_frames[port][j] = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tIA_CSS_ERROR(\"allocate_mipi_frames(%p, %d) exit: allocation failed.\",\n\t\t\t\t\t\t     pipe, port);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (info->metadata_info.size > 0) {\n\t\t\t\t \n\t\t\t\tif (my_css.mipi_metadata[port][i]) {\n\t\t\t\t\tia_css_metadata_free(my_css.mipi_metadata[port][i]);\n\t\t\t\t\tmy_css.mipi_metadata[port][i] = NULL;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (i < my_css.num_mipi_frames[port]) {\n\t\t\t\t\t \n\t\t\t\t\tmy_css.mipi_metadata[port][i] = ia_css_metadata_allocate(&info->metadata_info);\n\t\t\t\t\tif (!my_css.mipi_metadata[port][i]) {\n\t\t\t\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t\t\t\t\t\t    \"allocate_mipi_metadata(%p, %d) failed.\\n\",\n\t\t\t\t\t\t\t\t    pipe, port);\n\t\t\t\t\t\treturn err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"allocate_mipi_frames(%p) exit:\\n\", pipe);\n\n\treturn err;\n}\n\nint\nfree_mipi_frames(struct ia_css_pipe *pipe)\n{\n\tint err = -EINVAL;\n\tunsigned int port;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t    \"free_mipi_frames(%p) enter:\\n\", pipe);\n\n\t \n\tif (pipe) {\n\t\tassert(pipe->stream);\n\t\tif ((!pipe) || (!pipe->stream)) {\n\t\t\tIA_CSS_ERROR(\"free_mipi_frames(%p) exit: pipe or stream is null.\",\n\t\t\t\t     pipe);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (pipe->stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {\n\t\t\tIA_CSS_ERROR(\"free_mipi_frames(%p) exit: wrong mode.\",\n\t\t\t\t     pipe);\n\t\t\treturn err;\n\t\t}\n\n\t\tport = (unsigned int)pipe->stream->config.source.port.port;\n\n\t\tif (port >= N_CSI_PORTS) {\n\t\t\tIA_CSS_ERROR(\"free_mipi_frames(%p, %d) exit: pipe port is not correct.\",\n\t\t\t\t     pipe, port);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (ref_count_mipi_allocation[port] > 0) {\n\t\t\tif (!IS_ISP2401) {\n\t\t\t\tassert(ref_count_mipi_allocation[port] == 1);\n\t\t\t\tif (ref_count_mipi_allocation[port] != 1) {\n\t\t\t\t\tIA_CSS_ERROR(\"free_mipi_frames(%p) exit: wrong ref_count (ref_count=%d).\",\n\t\t\t\t\t\t     pipe, ref_count_mipi_allocation[port]);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tref_count_mipi_allocation[port]--;\n\n\t\t\tif (ref_count_mipi_allocation[port] == 0) {\n\t\t\t\t \n\t\t\t\tunsigned int i;\n\n\t\t\t\tfor (i = 0; i < my_css.num_mipi_frames[port]; i++) {\n\t\t\t\t\tif (my_css.mipi_frames[port][i]) {\n\t\t\t\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t\t\t\t\t\t    \"free_mipi_frames(port=%d, num=%d).\\n\", port, i);\n\t\t\t\t\t\tia_css_frame_free(my_css.mipi_frames[port][i]);\n\t\t\t\t\t\tmy_css.mipi_frames[port][i] = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (my_css.mipi_metadata[port][i]) {\n\t\t\t\t\t\tia_css_metadata_free(my_css.mipi_metadata[port][i]);\n\t\t\t\t\t\tmy_css.mipi_metadata[port][i] = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t\t\t\t    \"free_mipi_frames(%p) exit (deallocated).\\n\", pipe);\n\t\t\t}\n\t\t}\n\t} else {  \n\t\t \n\t\tfor (port = CSI_PORT0_ID; port < N_CSI_PORTS; port++) {\n\t\t\tunsigned int i;\n\n\t\t\tfor (i = 0; i < my_css.num_mipi_frames[port]; i++) {\n\t\t\t\tif (my_css.mipi_frames[port][i]) {\n\t\t\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\n\t\t\t\t\t\t\t    \"free_mipi_frames(port=%d, num=%d).\\n\", port, i);\n\t\t\t\t\tia_css_frame_free(my_css.mipi_frames[port][i]);\n\t\t\t\t\tmy_css.mipi_frames[port][i] = NULL;\n\t\t\t\t}\n\t\t\t\tif (my_css.mipi_metadata[port][i]) {\n\t\t\t\t\tia_css_metadata_free(my_css.mipi_metadata[port][i]);\n\t\t\t\t\tmy_css.mipi_metadata[port][i] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tref_count_mipi_allocation[port] = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint\nsend_mipi_frames(struct ia_css_pipe *pipe)\n{\n\tint err = -EINVAL;\n\tunsigned int i;\n\tunsigned int port;\n\n\tIA_CSS_ENTER_PRIVATE(\"pipe=%p\", pipe);\n\n\t \n\t \n\tif (pipe->stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {\n\t\tIA_CSS_LOG(\"nothing to be done for this mode\");\n\t\treturn 0;\n\t\t \n\t}\n\n\tport = (unsigned int)pipe->stream->config.source.port.port;\n\n\tif (port >= N_CSI_PORTS) {\n\t\tIA_CSS_ERROR(\"send_mipi_frames(%p) exit: invalid port specified (port=%d).\",\n\t\t\t     pipe, port);\n\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < my_css.num_mipi_frames[port]; i++) {\n\t\t \n\t\tsh_css_update_host2sp_mipi_frame(port * NUM_MIPI_FRAMES_PER_STREAM + i,\n\t\t\t\t\t\t my_css.mipi_frames[port][i]);\n\t\tsh_css_update_host2sp_mipi_metadata(port * NUM_MIPI_FRAMES_PER_STREAM + i,\n\t\t\t\t\t\t    my_css.mipi_metadata[port][i]);\n\t}\n\tsh_css_update_host2sp_num_mipi_frames(my_css.num_mipi_frames[port]);\n\n\t \n\tif (!sh_css_sp_is_running()) {\n\t\t \n\t\tIA_CSS_ERROR(\"sp is not running\");\n\t\treturn err;\n\t}\n\n\tia_css_bufq_enqueue_psys_event(\n\t    IA_CSS_PSYS_SW_EVENT_MIPI_BUFFERS_READY,\n\t    (uint8_t)port,\n\t    (uint8_t)my_css.num_mipi_frames[port],\n\t    0  );\n\tIA_CSS_LEAVE_ERR_PRIVATE(0);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}