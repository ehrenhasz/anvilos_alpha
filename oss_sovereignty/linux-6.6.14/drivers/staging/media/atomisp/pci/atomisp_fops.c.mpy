{
  "module_name": "atomisp_fops.c",
  "hash_id": "950998c0d9238678edf49d2d44b89eb06a820592f5089923bc2ba6ce477490f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/atomisp_fops.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"atomisp_cmd.h\"\n#include \"atomisp_common.h\"\n#include \"atomisp_fops.h\"\n#include \"atomisp_internal.h\"\n#include \"atomisp_ioctl.h\"\n#include \"atomisp_compat.h\"\n#include \"atomisp_subdev.h\"\n#include \"atomisp_v4l2.h\"\n#include \"atomisp-regs.h\"\n#include \"hmm/hmm.h\"\n\n#include \"ia_css_frame.h\"\n#include \"type_support.h\"\n#include \"device_access/device_access.h\"\n\n \nstatic int atomisp_queue_setup(struct vb2_queue *vq,\n\t\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct atomisp_video_pipe *pipe = container_of(vq, struct atomisp_video_pipe, vb_queue);\n\tint ret;\n\n\tmutex_lock(&pipe->asd->isp->mutex);  \n\n\t \n\tret = atomisp_get_css_frame_info(pipe->asd, &pipe->frame_info);\n\tif (ret) {\n\t\tstruct v4l2_format f = {\n\t\t\t.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420,\n\t\t\t.fmt.pix.width = 10000,\n\t\t\t.fmt.pix.height = 10000,\n\t\t};\n\n\t\tret = atomisp_set_fmt(&pipe->vdev, &f);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = atomisp_get_css_frame_info(pipe->asd, &pipe->frame_info);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tatomisp_alloc_css_stat_bufs(pipe->asd, ATOMISP_INPUT_STREAM_GENERAL);\n\n\t*nplanes = 1;\n\tsizes[0] = PAGE_ALIGN(pipe->pix.sizeimage);\n\nout:\n\tmutex_unlock(&pipe->asd->isp->mutex);\n\treturn ret;\n}\n\nstatic int atomisp_buf_init(struct vb2_buffer *vb)\n{\n\tstruct atomisp_video_pipe *pipe = vb_to_pipe(vb);\n\tstruct ia_css_frame *frame = vb_to_frame(vb);\n\tint ret;\n\n\tret = ia_css_frame_init_from_info(frame, &pipe->frame_info);\n\tif (ret)\n\t\treturn ret;\n\n\tif (frame->data_bytes > vb2_plane_size(vb, 0)) {\n\t\tdev_err(pipe->asd->isp->dev, \"Internal error frame.data_bytes(%u) > vb.length(%lu)\\n\",\n\t\t\tframe->data_bytes, vb2_plane_size(vb, 0));\n\t\treturn -EIO;\n\t}\n\n\tframe->data = hmm_create_from_vmalloc_buf(vb2_plane_size(vb, 0),\n\t\t\t\t\t\t  vb2_plane_vaddr(vb, 0));\n\tif (frame->data == mmgr_NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int atomisp_q_one_metadata_buffer(struct atomisp_sub_device *asd,\n\tenum atomisp_input_stream_id stream_id,\n\tenum ia_css_pipe_id css_pipe_id)\n{\n\tstruct atomisp_metadata_buf *metadata_buf;\n\tenum atomisp_metadata_type md_type = ATOMISP_MAIN_METADATA;\n\tstruct list_head *metadata_list;\n\n\tif (asd->metadata_bufs_in_css[stream_id][css_pipe_id] >=\n\t    ATOMISP_CSS_Q_DEPTH)\n\t\treturn 0;  \n\n\tif (!list_empty(&asd->metadata[md_type])) {\n\t\tmetadata_list = &asd->metadata[md_type];\n\t} else if (!list_empty(&asd->metadata_ready[md_type])) {\n\t\tmetadata_list = &asd->metadata_ready[md_type];\n\t} else {\n\t\tdev_warn(asd->isp->dev, \"%s: No metadata buffers available for type %d!\\n\",\n\t\t\t __func__, md_type);\n\t\treturn -EINVAL;\n\t}\n\n\tmetadata_buf = list_entry(metadata_list->next,\n\t\t\t\t  struct atomisp_metadata_buf, list);\n\tlist_del_init(&metadata_buf->list);\n\n\tif (atomisp_q_metadata_buffer_to_css(asd, metadata_buf,\n\t\t\t\t\t     stream_id, css_pipe_id)) {\n\t\tlist_add(&metadata_buf->list, metadata_list);\n\t\treturn -EINVAL;\n\t} else {\n\t\tlist_add_tail(&metadata_buf->list,\n\t\t\t      &asd->metadata_in_css[md_type]);\n\t}\n\tasd->metadata_bufs_in_css[stream_id][css_pipe_id]++;\n\n\treturn 0;\n}\n\nstatic int atomisp_q_one_s3a_buffer(struct atomisp_sub_device *asd,\n\t\t\t\t    enum atomisp_input_stream_id stream_id,\n\t\t\t\t    enum ia_css_pipe_id css_pipe_id)\n{\n\tstruct atomisp_s3a_buf *s3a_buf;\n\tstruct list_head *s3a_list;\n\tunsigned int exp_id;\n\n\tif (asd->s3a_bufs_in_css[css_pipe_id] >= ATOMISP_CSS_Q_DEPTH)\n\t\treturn 0;  \n\n\tif (!list_empty(&asd->s3a_stats)) {\n\t\ts3a_list = &asd->s3a_stats;\n\t} else if (!list_empty(&asd->s3a_stats_ready)) {\n\t\ts3a_list = &asd->s3a_stats_ready;\n\t} else {\n\t\tdev_warn(asd->isp->dev, \"%s: No s3a buffers available!\\n\",\n\t\t\t __func__);\n\t\treturn -EINVAL;\n\t}\n\n\ts3a_buf = list_entry(s3a_list->next, struct atomisp_s3a_buf, list);\n\tlist_del_init(&s3a_buf->list);\n\texp_id = s3a_buf->s3a_data->exp_id;\n\n\thmm_flush_vmap(s3a_buf->s3a_data->data_ptr);\n\tif (atomisp_q_s3a_buffer_to_css(asd, s3a_buf,\n\t\t\t\t\tstream_id, css_pipe_id)) {\n\t\t \n\t\tlist_add(&s3a_buf->list, s3a_list);\n\t\treturn -EINVAL;\n\t} else {\n\t\tlist_add_tail(&s3a_buf->list, &asd->s3a_stats_in_css);\n\t\tif (s3a_list == &asd->s3a_stats_ready)\n\t\t\tdev_dbg(asd->isp->dev, \"drop one s3a stat with exp_id %d\\n\", exp_id);\n\t}\n\n\tasd->s3a_bufs_in_css[css_pipe_id]++;\n\treturn 0;\n}\n\nstatic int atomisp_q_one_dis_buffer(struct atomisp_sub_device *asd,\n\t\t\t\t    enum atomisp_input_stream_id stream_id,\n\t\t\t\t    enum ia_css_pipe_id css_pipe_id)\n{\n\tstruct atomisp_dis_buf *dis_buf;\n\tunsigned long irqflags;\n\n\tif (asd->dis_bufs_in_css >=  ATOMISP_CSS_Q_DEPTH)\n\t\treturn 0;  \n\n\tspin_lock_irqsave(&asd->dis_stats_lock, irqflags);\n\tif (list_empty(&asd->dis_stats)) {\n\t\tspin_unlock_irqrestore(&asd->dis_stats_lock, irqflags);\n\t\tdev_warn(asd->isp->dev, \"%s: No dis buffers available!\\n\",\n\t\t\t __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdis_buf = list_entry(asd->dis_stats.prev,\n\t\t\t     struct atomisp_dis_buf, list);\n\tlist_del_init(&dis_buf->list);\n\tspin_unlock_irqrestore(&asd->dis_stats_lock, irqflags);\n\n\thmm_flush_vmap(dis_buf->dis_data->data_ptr);\n\tif (atomisp_q_dis_buffer_to_css(asd, dis_buf,\n\t\t\t\t\tstream_id, css_pipe_id)) {\n\t\tspin_lock_irqsave(&asd->dis_stats_lock, irqflags);\n\t\t \n\t\tlist_add_tail(&dis_buf->list, &asd->dis_stats);\n\t\tspin_unlock_irqrestore(&asd->dis_stats_lock, irqflags);\n\t\treturn -EINVAL;\n\t} else {\n\t\tspin_lock_irqsave(&asd->dis_stats_lock, irqflags);\n\t\tlist_add_tail(&dis_buf->list, &asd->dis_stats_in_css);\n\t\tspin_unlock_irqrestore(&asd->dis_stats_lock, irqflags);\n\t}\n\n\tasd->dis_bufs_in_css++;\n\n\treturn 0;\n}\n\nstatic int atomisp_q_video_buffers_to_css(struct atomisp_sub_device *asd,\n\t\t\t\t\t  struct atomisp_video_pipe *pipe,\n\t\t\t\t\t  enum atomisp_input_stream_id stream_id,\n\t\t\t\t\t  enum ia_css_buffer_type css_buf_type,\n\t\t\t\t\t  enum ia_css_pipe_id css_pipe_id)\n{\n\tstruct atomisp_css_params_with_list *param;\n\tstruct ia_css_dvs_grid_info *dvs_grid =\n\t    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);\n\tunsigned long irqflags;\n\tint space, err = 0;\n\n\tlockdep_assert_held(&asd->isp->mutex);\n\n\tif (WARN_ON(css_pipe_id >= IA_CSS_PIPE_ID_NUM))\n\t\treturn -EINVAL;\n\n\tif (pipe->stopping)\n\t\treturn -EINVAL;\n\n\tspace = ATOMISP_CSS_Q_DEPTH - atomisp_buffers_in_css(pipe);\n\twhile (space--) {\n\t\tstruct ia_css_frame *frame;\n\n\t\tspin_lock_irqsave(&pipe->irq_lock, irqflags);\n\t\tframe = list_first_entry_or_null(&pipe->activeq, struct ia_css_frame, queue);\n\t\tif (frame)\n\t\t\tlist_move_tail(&frame->queue, &pipe->buffers_in_css);\n\t\tspin_unlock_irqrestore(&pipe->irq_lock, irqflags);\n\n\t\tif (!frame)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tparam = pipe->frame_params[frame->vb.vb2_buf.index];\n\t\tif (param) {\n\t\t\tatomisp_makeup_css_parameters(asd,\n\t\t\t\t\t\t      &asd->params.css_param.update_flag,\n\t\t\t\t\t\t      &param->params);\n\t\t\tatomisp_apply_css_parameters(asd, &param->params);\n\n\t\t\tif (param->params.update_flag.dz_config &&\n\t\t\t    asd->run_mode->val != ATOMISP_RUN_MODE_VIDEO) {\n\t\t\t\terr = atomisp_calculate_real_zoom_region(asd,\n\t\t\t\t\t&param->params.dz_config, css_pipe_id);\n\t\t\t\tif (!err)\n\t\t\t\t\tasd->params.config.dz_config = &param->params.dz_config;\n\t\t\t}\n\t\t\tatomisp_css_set_isp_config_applied_frame(asd, frame);\n\t\t\tatomisp_css_update_isp_params_on_pipe(asd,\n\t\t\t\t\t\t\t      asd->stream_env[stream_id].pipes[css_pipe_id]);\n\t\t\tasd->params.dvs_6axis = (struct ia_css_dvs_6axis_config *)\n\t\t\t\t\t\tparam->params.dvs_6axis;\n\n\t\t\t \n\t\t\tif (param->params.update_flag.dz_config &&\n\t\t\t    asd->run_mode->val != ATOMISP_RUN_MODE_VIDEO\n\t\t\t    && !err) {\n\t\t\t\tmemcpy(&asd->params.css_param.dz_config,\n\t\t\t\t       &param->params.dz_config,\n\t\t\t\t       sizeof(struct ia_css_dz_config));\n\t\t\t\tasd->params.css_param.update_flag.dz_config =\n\t\t\t\t    (struct atomisp_dz_config *)\n\t\t\t\t    &asd->params.css_param.dz_config;\n\t\t\t\tasd->params.css_update_params_needed = true;\n\t\t\t}\n\t\t\tpipe->frame_params[frame->vb.vb2_buf.index] = NULL;\n\t\t}\n\t\t \n\t\terr = atomisp_q_video_buffer_to_css(asd, frame, stream_id,\n\t\t\t\t\t\t    css_buf_type, css_pipe_id);\n\t\tif (err) {\n\t\t\tspin_lock_irqsave(&pipe->irq_lock, irqflags);\n\t\t\tlist_move_tail(&frame->queue, &pipe->activeq);\n\t\t\tspin_unlock_irqrestore(&pipe->irq_lock, irqflags);\n\t\t\tdev_err(asd->isp->dev, \"%s, css q fails: %d\\n\",\n\t\t\t\t__func__, err);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (asd->params.curr_grid_info.s3a_grid.enable &&\n\t\t    css_pipe_id == asd->params.s3a_enabled_pipe &&\n\t\t    css_buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME)\n\t\t\tatomisp_q_one_s3a_buffer(asd, stream_id,\n\t\t\t\t\t\t css_pipe_id);\n\n\t\tif (asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream_info.\n\t\t    metadata_info.size &&\n\t\t    css_buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME)\n\t\t\tatomisp_q_one_metadata_buffer(asd, stream_id,\n\t\t\t\t\t\t      css_pipe_id);\n\n\t\tif (dvs_grid && dvs_grid->enable &&\n\t\t    css_pipe_id == IA_CSS_PIPE_ID_VIDEO &&\n\t\t    css_buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME)\n\t\t\tatomisp_q_one_dis_buffer(asd, stream_id,\n\t\t\t\t\t\t css_pipe_id);\n\t}\n\n\treturn 0;\n}\n\n \nint atomisp_qbuffers_to_css(struct atomisp_sub_device *asd)\n{\n\tenum ia_css_pipe_id pipe_id;\n\n\tif (asd->copy_mode) {\n\t\tpipe_id = IA_CSS_PIPE_ID_COPY;\n\t} else if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER) {\n\t\tpipe_id = IA_CSS_PIPE_ID_VIDEO;\n\t} else if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_LOWLAT) {\n\t\tpipe_id = IA_CSS_PIPE_ID_CAPTURE;\n\t} else if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {\n\t\tpipe_id = IA_CSS_PIPE_ID_VIDEO;\n\t} else if (asd->run_mode->val == ATOMISP_RUN_MODE_PREVIEW) {\n\t\tpipe_id = IA_CSS_PIPE_ID_PREVIEW;\n\t} else {\n\t\t \n\t\tpipe_id = IA_CSS_PIPE_ID_CAPTURE;\n\t}\n\n\tatomisp_q_video_buffers_to_css(asd, &asd->video_out,\n\t\t\t\t       ATOMISP_INPUT_STREAM_GENERAL,\n\t\t\t\t       IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, pipe_id);\n\treturn 0;\n}\n\nstatic void atomisp_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct atomisp_video_pipe *pipe = vb_to_pipe(vb);\n\tstruct ia_css_frame *frame = vb_to_frame(vb);\n\tstruct atomisp_sub_device *asd = pipe->asd;\n\tunsigned long irqflags;\n\tint ret;\n\n\tmutex_lock(&asd->isp->mutex);\n\n\tret = atomisp_pipe_check(pipe, false);\n\tif (ret || pipe->stopping) {\n\t\tspin_lock_irqsave(&pipe->irq_lock, irqflags);\n\t\tatomisp_buffer_done(frame, VB2_BUF_STATE_ERROR);\n\t\tspin_unlock_irqrestore(&pipe->irq_lock, irqflags);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (!(vb->skip_cache_sync_on_finish && vb->skip_cache_sync_on_prepare))\n\t\twbinvd();\n\n\tpipe->frame_params[vb->index] = NULL;\n\n\tspin_lock_irqsave(&pipe->irq_lock, irqflags);\n\t \n\tif (pipe->frame_request_config_id[vb->index] ||\n\t    !list_empty(&pipe->buffers_waiting_for_param))\n\t\tlist_add_tail(&frame->queue, &pipe->buffers_waiting_for_param);\n\telse\n\t\tlist_add_tail(&frame->queue, &pipe->activeq);\n\n\tspin_unlock_irqrestore(&pipe->irq_lock, irqflags);\n\n\t \n\tif (asd->streaming) {\n\t\tif (!list_empty(&pipe->buffers_waiting_for_param))\n\t\t\tatomisp_handle_parameter_and_buffer(pipe);\n\t\telse\n\t\t\tatomisp_qbuffers_to_css(asd);\n\t}\n\nout_unlock:\n\tmutex_unlock(&asd->isp->mutex);\n}\n\nstatic void atomisp_buf_cleanup(struct vb2_buffer *vb)\n{\n\tstruct atomisp_video_pipe *pipe = vb_to_pipe(vb);\n\tstruct ia_css_frame *frame = vb_to_frame(vb);\n\tint index = frame->vb.vb2_buf.index;\n\n\tpipe->frame_request_config_id[index] = 0;\n\tpipe->frame_params[index] = NULL;\n\n\thmm_free(frame->data);\n}\n\nconst struct vb2_ops atomisp_vb2_ops = {\n\t.queue_setup\t\t= atomisp_queue_setup,\n\t.buf_init\t\t= atomisp_buf_init,\n\t.buf_cleanup\t\t= atomisp_buf_cleanup,\n\t.buf_queue\t\t= atomisp_buf_queue,\n\t.start_streaming\t= atomisp_start_streaming,\n\t.stop_streaming\t\t= atomisp_stop_streaming,\n};\n\nstatic void atomisp_dev_init_struct(struct atomisp_device *isp)\n{\n\tunsigned int i;\n\n\tisp->isp_fatal_error = false;\n\n\tfor (i = 0; i < isp->input_cnt; i++)\n\t\tisp->inputs[i].asd = NULL;\n\t \n\tisp->running_freq = ISP_FREQ_200MHZ;\n}\n\nstatic void atomisp_subdev_init_struct(struct atomisp_sub_device *asd)\n{\n\tv4l2_ctrl_s_ctrl(asd->run_mode, ATOMISP_RUN_MODE_STILL_CAPTURE);\n\tmemset(&asd->params.css_param, 0, sizeof(asd->params.css_param));\n\tasd->params.color_effect = V4L2_COLORFX_NONE;\n\tasd->params.bad_pixel_en = true;\n\tasd->params.gdc_cac_en = false;\n\tasd->params.video_dis_en = false;\n\tasd->params.sc_en = false;\n\tasd->params.fpn_en = false;\n\tasd->params.xnr_en = false;\n\tasd->params.false_color = 0;\n\tasd->params.yuv_ds_en = 0;\n\t \n\tasd->params.s3a_enabled_pipe = IA_CSS_PIPE_ID_NUM;\n\n\tasd->copy_mode = false;\n\n\tasd->stream_prepared = false;\n\tasd->high_speed_mode = false;\n\tasd->sensor_array_res.height = 0;\n\tasd->sensor_array_res.width = 0;\n\tatomisp_css_init_struct(asd);\n}\n\n \nstatic int atomisp_open(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);\n\tstruct atomisp_sub_device *asd = pipe->asd;\n\tint ret;\n\n\tdev_dbg(isp->dev, \"open device %s\\n\", vdev->name);\n\n\tret = v4l2_fh_open(file);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&isp->mutex);\n\n\tif (!isp->input_cnt) {\n\t\tdev_err(isp->dev, \"no camera attached\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tif (pipe->users) {\n\t\tdev_dbg(isp->dev, \"video node already opened\\n\");\n\t\tmutex_unlock(&isp->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tret = pm_runtime_resume_and_get(vdev->v4l2_dev->dev);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"Failed to power on device\\n\");\n\t\tgoto error;\n\t}\n\n\tatomisp_dev_init_struct(isp);\n\n\tret = v4l2_subdev_call(isp->flash, core, s_power, 1);\n\tif (ret < 0 && ret != -ENODEV && ret != -ENOIOCTLCMD) {\n\t\tdev_err(isp->dev, \"Failed to power-on flash\\n\");\n\t\tgoto css_error;\n\t}\n\n\tatomisp_subdev_init_struct(asd);\n\t \n\tv4l2_ctrl_s_ctrl(asd->run_mode, ATOMISP_RUN_MODE_PREVIEW);\n\n\tpipe->users++;\n\tmutex_unlock(&isp->mutex);\n\treturn 0;\n\ncss_error:\n\tpm_runtime_put(vdev->v4l2_dev->dev);\nerror:\n\tmutex_unlock(&isp->mutex);\n\tv4l2_fh_release(file);\n\treturn ret;\n}\n\nstatic int atomisp_release(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct atomisp_device *isp = video_get_drvdata(vdev);\n\tstruct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);\n\tstruct atomisp_sub_device *asd = pipe->asd;\n\tstruct v4l2_subdev_fh fh;\n\tstruct v4l2_rect clear_compose = {0};\n\tint ret;\n\n\tv4l2_fh_init(&fh.vfh, vdev);\n\n\tdev_dbg(isp->dev, \"release device %s\\n\", vdev->name);\n\n\t \n\tvb2_fop_release(file);\n\n\tmutex_lock(&isp->mutex);\n\n\tpipe->users--;\n\n\t \n\t{\n\t\tstruct v4l2_mbus_framefmt isp_sink_fmt = { 0 };\n\n\t\tatomisp_subdev_set_ffmt(&asd->subdev, fh.state,\n\t\t\t\t\tV4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t\t\tATOMISP_SUBDEV_PAD_SINK, &isp_sink_fmt);\n\t}\n\n\tatomisp_css_free_stat_buffers(asd);\n\tatomisp_free_internal_buffers(asd);\n\n\tif (isp->inputs[asd->input_curr].asd == asd) {\n\t\tret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,\n\t\t\t\t       core, s_power, 0);\n\t\tif (ret && ret != -ENOIOCTLCMD)\n\t\t\tdev_warn(isp->dev, \"Failed to power-off sensor\\n\");\n\n\t\t \n\t\tisp->inputs[asd->input_curr].asd = NULL;\n\t}\n\n\tatomisp_destroy_pipes_stream(asd);\n\n\tret = v4l2_subdev_call(isp->flash, core, s_power, 0);\n\tif (ret < 0 && ret != -ENODEV && ret != -ENOIOCTLCMD)\n\t\tdev_warn(isp->dev, \"Failed to power-off flash\\n\");\n\n\tif (pm_runtime_put_sync(vdev->v4l2_dev->dev) < 0)\n\t\tdev_err(isp->dev, \"Failed to power off device\\n\");\n\n\tatomisp_subdev_set_selection(&asd->subdev, fh.state,\n\t\t\t\t     V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t\t\t     ATOMISP_SUBDEV_PAD_SOURCE,\n\t\t\t\t     V4L2_SEL_TGT_COMPOSE, 0,\n\t\t\t\t     &clear_compose);\n\tmutex_unlock(&isp->mutex);\n\treturn 0;\n}\n\nconst struct v4l2_file_operations atomisp_fops = {\n\t.owner = THIS_MODULE,\n\t.open = atomisp_open,\n\t.release = atomisp_release,\n\t.mmap = vb2_fop_mmap,\n\t.poll = vb2_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n#ifdef CONFIG_COMPAT\n\t \n#endif\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}