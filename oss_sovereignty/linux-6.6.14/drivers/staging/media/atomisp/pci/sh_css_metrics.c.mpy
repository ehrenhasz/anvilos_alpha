{
  "module_name": "sh_css_metrics.c",
  "hash_id": "ec795857fa59f9a69b83ef35b77a9f8bd8c1a422ac31b0ac5df1276965cbef76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/pci/sh_css_metrics.c",
  "human_readable_source": "\n \n\n#include \"assert_support.h\"\n#include \"sh_css_metrics.h\"\n\n#include \"sp.h\"\n#include \"isp.h\"\n\n#include \"sh_css_internal.h\"\n\n#define MULTIPLE_PCS 0\n#define SUSPEND      0\n#define NOF_PCS      1\n#define RESUME_MASK  0x8\n#define STOP_MASK    0x0\n\nstatic bool pc_histogram_enabled;\nstatic struct sh_css_pc_histogram *isp_histogram;\nstatic struct sh_css_pc_histogram *sp_histogram;\n\nstruct sh_css_metrics sh_css_metrics;\n\nvoid\nsh_css_metrics_start_frame(void)\n{\n\tsh_css_metrics.frame_metrics.num_frames++;\n}\n\nstatic void\nclear_histogram(struct sh_css_pc_histogram *histogram)\n{\n\tunsigned int i;\n\n\tassert(histogram);\n\n\tfor (i = 0; i < histogram->length; i++) {\n\t\thistogram->run[i] = 0;\n\t\thistogram->stall[i] = 0;\n\t\thistogram->msink[i] = 0xFFFF;\n\t}\n}\n\nvoid\nsh_css_metrics_enable_pc_histogram(bool enable)\n{\n\tpc_histogram_enabled = enable;\n}\n\nstatic void\nmake_histogram(struct sh_css_pc_histogram *histogram, unsigned int length)\n{\n\tassert(histogram);\n\n\tif (histogram->length)\n\t\treturn;\n\tif (histogram->run)\n\t\treturn;\n\thistogram->run = kvmalloc(length * sizeof(*histogram->run),\n\t\t\t\t  GFP_KERNEL);\n\tif (!histogram->run)\n\t\treturn;\n\thistogram->stall = kvmalloc(length * sizeof(*histogram->stall),\n\t\t\t\t    GFP_KERNEL);\n\tif (!histogram->stall)\n\t\treturn;\n\thistogram->msink = kvmalloc(length * sizeof(*histogram->msink),\n\t\t\t\t    GFP_KERNEL);\n\tif (!histogram->msink)\n\t\treturn;\n\n\thistogram->length = length;\n\tclear_histogram(histogram);\n}\n\nstatic void\ninsert_binary_metrics(struct sh_css_binary_metrics **l,\n\t\t      struct sh_css_binary_metrics *metrics)\n{\n\tassert(l);\n\tassert(*l);\n\tassert(metrics);\n\n\tfor (; *l; l = &(*l)->next)\n\t\tif (*l == metrics)\n\t\t\treturn;\n\n\t*l = metrics;\n\tmetrics->next = NULL;\n}\n\nvoid\nsh_css_metrics_start_binary(struct sh_css_binary_metrics *metrics)\n{\n\tassert(metrics);\n\n\tif (!pc_histogram_enabled)\n\t\treturn;\n\n\tisp_histogram = &metrics->isp_histogram;\n\tsp_histogram = &metrics->sp_histogram;\n\tmake_histogram(isp_histogram, ISP_PMEM_DEPTH);\n\tmake_histogram(sp_histogram, SP_PMEM_DEPTH);\n\tinsert_binary_metrics(&sh_css_metrics.binary_metrics, metrics);\n}\n\nvoid\nsh_css_metrics_sample_pcs(void)\n{\n\tbool stall;\n\tunsigned int pc;\n\tunsigned int msink;\n\n\n\n\tif (!pc_histogram_enabled)\n\t\treturn;\n\n\tif (isp_histogram) {\n\t\tmsink = isp_ctrl_load(ISP0_ID, ISP_CTRL_SINK_REG);\n\t\tpc = isp_ctrl_load(ISP0_ID, ISP_PC_REG);\n\n\t\tisp_histogram->msink[pc] &= msink;\n\t\tstall = (msink != 0x7FF);\n\n\t\tif (stall)\n\t\t\tisp_histogram->stall[pc]++;\n\t\telse\n\t\t\tisp_histogram->run[pc]++;\n\t}\n\n\tif (sp_histogram && 0) {\n\t\tmsink = sp_ctrl_load(SP0_ID, SP_CTRL_SINK_REG);\n\t\tpc = sp_ctrl_load(SP0_ID, SP_PC_REG);\n\t\tsp_histogram->msink[pc] &= msink;\n\t\tstall = (msink != 0x7FF);\n\t\tif (stall)\n\t\t\tsp_histogram->stall[pc]++;\n\t\telse\n\t\t\tsp_histogram->run[pc]++;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}