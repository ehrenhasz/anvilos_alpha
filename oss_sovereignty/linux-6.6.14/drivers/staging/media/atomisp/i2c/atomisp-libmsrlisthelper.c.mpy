{
  "module_name": "atomisp-libmsrlisthelper.c",
  "hash_id": "b2181005b3b921d1213854d9b0590b8ffb5ea9c8a92180519b1379faaddcabea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/i2c/atomisp-libmsrlisthelper.c",
  "human_readable_source": "\n \n#include <linux/i2c.h>\n#include <linux/firmware.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include \"../include/linux/libmsrlisthelper.h\"\n#include <linux/module.h>\n#include <linux/slab.h>\n\n \nstruct tbd_header {\n\tu32 tag;           \n\tu32 size;          \n\tu32 version;       \n\tu32 revision;      \n\tu32 config_bits;   \n\tu32 checksum;      \n} __packed;\n\nstruct tbd_record_header {\n\tu32 size;         \n\tu8 format_id;     \n\tu8 packing_key;   \n\tu16 class_id;     \n} __packed;\n\nstruct tbd_data_record_header {\n\tu16 next_offset;\n\tu16 flags;\n\tu16 data_offset;\n\tu16 data_size;\n} __packed;\n\n#define TBD_CLASS_DRV_ID 2\n\nstatic int set_msr_configuration(struct i2c_client *client, uint8_t *bufptr,\n\t\t\t\t unsigned int size)\n{\n\t \n\n\tu8 *ptr = bufptr;\n\n\twhile (ptr < bufptr + size) {\n\t\tstruct i2c_msg msg = {\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t};\n\t\tint ret;\n\n\t\t \n\t\tmsg.len = *ptr++;\n\t\t \n\t\tmsg.buf = ptr;\n\t\tptr += msg.len;\n\n\t\tif (ptr > bufptr + size)\n\t\t\t \n\t\t\treturn -EINVAL;\n\n\t\tret = i2c_transfer(client->adapter, &msg, 1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"i2c write error: %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int parse_and_apply(struct i2c_client *client, uint8_t *buffer,\n\t\t\t   unsigned int size)\n{\n\tu8 *endptr8 = buffer + size;\n\tstruct tbd_data_record_header *header =\n\t    (struct tbd_data_record_header *)buffer;\n\n\t \n\tunsigned int dataset = 0;\n\n\tdo {\n\t\t \n\t\tif ((uint8_t *)header + sizeof(*header) > endptr8)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif ((uint8_t *)header + header->data_offset +\n\t\t    header->data_size > endptr8)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tdataset++;\n\t\t \n\t\t \n\t\tif (header->data_size && (header->flags & 1)) {\n\t\t\tint ret;\n\n\t\t\tdev_info(&client->dev,\n\t\t\t\t \"New MSR data for sensor driver (dataset %02d) size:%d\\n\",\n\t\t\t\t dataset, header->data_size);\n\t\t\tret = set_msr_configuration(client,\n\t\t\t\t\t\t    buffer + header->data_offset,\n\t\t\t\t\t\t    header->data_size);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\theader = (struct tbd_data_record_header *)(buffer +\n\t\t\t header->next_offset);\n\t} while (header->next_offset);\n\n\treturn 0;\n}\n\nint apply_msr_data(struct i2c_client *client, const struct firmware *fw)\n{\n\tstruct tbd_header *header;\n\tstruct tbd_record_header *record;\n\n\tif (!fw) {\n\t\tdev_warn(&client->dev, \"Drv data is not loaded.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sizeof(*header) > fw->size)\n\t\treturn -EINVAL;\n\n\theader = (struct tbd_header *)fw->data;\n\t \n\tif (memcmp(&header->tag, \"DRVB\", 4))\n\t\treturn -EINVAL;\n\n\t \n\tif (header->size != fw->size)\n\t\treturn -EINVAL;\n\n\tif (sizeof(*header) + sizeof(*record) > fw->size)\n\t\treturn -EINVAL;\n\n\trecord = (struct tbd_record_header *)(header + 1);\n\t \n\tif (record->class_id != TBD_CLASS_DRV_ID)\n\t\treturn -EINVAL;\n\n\t \n\tif (!record->size)\n\t\treturn 0;\n\n\treturn parse_and_apply(client, (uint8_t *)(record + 1), record->size);\n}\nEXPORT_SYMBOL_GPL(apply_msr_data);\n\nint load_msr_list(struct i2c_client *client, char *name,\n\t\t  const struct firmware **fw)\n{\n\tint ret = request_firmware(fw, name, &client->dev);\n\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Error %d while requesting firmware %s\\n\",\n\t\t\tret, name);\n\t\treturn ret;\n\t}\n\tdev_info(&client->dev, \"Received %lu bytes drv data\\n\",\n\t\t (unsigned long)(*fw)->size);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(load_msr_list);\n\nvoid release_msr_list(struct i2c_client *client, const struct firmware *fw)\n{\n\trelease_firmware(fw);\n}\nEXPORT_SYMBOL_GPL(release_msr_list);\n\nstatic int init_msrlisthelper(void)\n{\n\treturn 0;\n}\n\nstatic void exit_msrlisthelper(void)\n{\n}\n\nmodule_init(init_msrlisthelper);\nmodule_exit(exit_msrlisthelper);\n\nMODULE_AUTHOR(\"Jukka Kaartinen <jukka.o.kaartinen@intel.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}