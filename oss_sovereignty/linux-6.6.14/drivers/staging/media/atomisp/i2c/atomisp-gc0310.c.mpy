{
  "module_name": "atomisp-gc0310.c",
  "hash_id": "ba383ac9deaf120ca669af093259aab59fa543be02c4cbc80e8147be96e7a0b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/i2c/atomisp-gc0310.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n\n#define GC0310_NATIVE_WIDTH\t\t\t656\n#define GC0310_NATIVE_HEIGHT\t\t\t496\n\n#define GC0310_FPS\t\t\t\t30\n#define GC0310_SKIP_FRAMES\t\t\t3\n\n#define GC0310_FOCAL_LENGTH_NUM\t\t\t278  \n\n#define GC0310_ID\t\t\t\t0xa310\n\n#define GC0310_RESET_RELATED\t\t\t0xFE\n#define GC0310_REGISTER_PAGE_0\t\t\t0x0\n#define GC0310_REGISTER_PAGE_3\t\t\t0x3\n\n \n#define GC0310_SW_STREAM\t\t\t0x10\n\n#define GC0310_SC_CMMN_CHIP_ID_H\t\t0xf0\n#define GC0310_SC_CMMN_CHIP_ID_L\t\t0xf1\n\n#define GC0310_AEC_PK_EXPO_H\t\t\t0x03\n#define GC0310_AEC_PK_EXPO_L\t\t\t0x04\n#define GC0310_AGC_ADJ\t\t\t\t0x48\n#define GC0310_DGC_ADJ\t\t\t\t0x71\n#define GC0310_GROUP_ACCESS\t\t\t0x3208\n\n#define GC0310_H_CROP_START_H\t\t\t0x09\n#define GC0310_H_CROP_START_L\t\t\t0x0A\n#define GC0310_V_CROP_START_H\t\t\t0x0B\n#define GC0310_V_CROP_START_L\t\t\t0x0C\n#define GC0310_H_OUTSIZE_H\t\t\t0x0F\n#define GC0310_H_OUTSIZE_L\t\t\t0x10\n#define GC0310_V_OUTSIZE_H\t\t\t0x0D\n#define GC0310_V_OUTSIZE_L\t\t\t0x0E\n#define GC0310_H_BLANKING_H\t\t\t0x05\n#define GC0310_H_BLANKING_L\t\t\t0x06\n#define GC0310_V_BLANKING_H\t\t\t0x07\n#define GC0310_V_BLANKING_L\t\t\t0x08\n#define GC0310_SH_DELAY\t\t\t\t0x11\n\n#define GC0310_START_STREAMING\t\t\t0x94  \n#define GC0310_STOP_STREAMING\t\t\t0x0  \n\n#define to_gc0310_sensor(x) container_of(x, struct gc0310_device, sd)\n\nstruct gc0310_device {\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\t \n\tstruct mutex input_lock;\n\tbool is_streaming;\n\n\tstruct fwnode_handle *ep_fwnode;\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *powerdown;\n\n\tstruct gc0310_mode {\n\t\tstruct v4l2_mbus_framefmt fmt;\n\t} mode;\n\n\tstruct gc0310_ctrls {\n\t\tstruct v4l2_ctrl_handler handler;\n\t\tstruct v4l2_ctrl *exposure;\n\t\tstruct v4l2_ctrl *gain;\n\t} ctrls;\n};\n\nstruct gc0310_reg {\n\tu8 reg;\n\tu8 val;\n};\n\nstatic const struct gc0310_reg gc0310_reset_register[] = {\n\t \n\t{ 0xfe, 0xf0 },\n\t{ 0xfe, 0xf0 },\n\t{ 0xfe, 0x00 },\n\n\t{ 0xfc, 0x0e },  \n\t{ 0xfc, 0x0e },  \n\t{ 0xf3, 0x00 },  \n\t{ 0xf8, 0x05 },  \n\t{ 0xf9, 0x0e },  \n\t{ 0xfe, 0x03 },\n\t{ 0x01, 0x03 },  \n\t{ 0x02, 0x22 },  \n\t{ 0x03, 0x94 },\n\t{ 0x04, 0x01 },  \n\t{ 0x05, 0x00 },  \n\t{ 0x06, 0x80 },  \n\t{ 0x22, 0x02 },  \n\t{ 0x23, 0x01 },  \n\t{ 0x00, 0x2f },  \n\t{ 0x02, 0x04 },\n\t{ 0x4f, 0x00 },  \n\t{ 0x03, 0x01 },  \n\t{ 0x0a, 0x00 },\n\t{ 0x0b, 0x00 },  \n\t{ 0x0c, 0x00 },\n\t{ 0x0d, 0x01 },  \n\t{ 0x0e, 0xf2 },  \n\t{ 0x10, 0x94 },  \n\t{ 0x1b, 0x48 },\n\t{ 0x1e, 0x6b },  \n\t{ 0x24, 0x16 },  \n\t{ 0x34, 0x20 },  \n\t{ 0x26, 0x23 },  \n\t{ 0x28, 0xff },  \n\t{ 0x29, 0x00 },  \n\t{ 0x33, 0x18 },  \n\t{ 0x37, 0x20 },  \n\t{ 0x2a, 0x00 },\n\t{ 0x2b, 0x00 },\n\t{ 0x2c, 0x00 },\n\t{ 0x2d, 0x00 },\n\t{ 0x2e, 0x00 },\n\t{ 0x2f, 0x00 },\n\t{ 0x30, 0x00 },\n\t{ 0x31, 0x00 },\n\t{ 0x47, 0x80 },  \n\t{ 0x4e, 0x66 },  \n\t{ 0xa8, 0x02 },  \n\t{ 0xa9, 0x80 },\n\n\t \n\t{ 0x40, 0x06 },  \n\t{ 0x50, 0x01 },  \n\t{ 0x51, 0x00 },\n\t{ 0x52, 0x00 },\n\t{ 0x53, 0x00 },\n\t{ 0x54, 0x01 },\n\t{ 0x55, 0x01 },  \n\t{ 0x56, 0xf0 },\n\t{ 0x57, 0x02 },  \n\t{ 0x58, 0x90 },\n\n\t \n\t{ 0x70, 0x70 },  \n\t{ 0x72, 0x40 },  \n\t{ 0x5a, 0x84 },  \n\t{ 0x5c, 0xed },  \n\t{ 0x79, 0x40 },  \n\n\t{ 0x48, 0x00 },\n\t{ 0xfe, 0x01 },\n\t{ 0x0a, 0x45 },  \n\n\t{ 0x3e, 0x40 },\n\t{ 0x3f, 0x5c },\n\t{ 0x40, 0x7b },\n\t{ 0x41, 0xbd },\n\t{ 0x42, 0xf6 },\n\t{ 0x43, 0x63 },\n\t{ 0x03, 0x60 },\n\t{ 0x44, 0x03 },\n\n\t \n\t{ 0xfe, 0x01 },\n\t{ 0x45, 0xa4 },  \n\t{ 0x46, 0xf0 },  \n\t{ 0x4f, 0x60 },  \n\t{ 0xfe, 0x00 },\n};\n\nstatic const struct gc0310_reg gc0310_VGA_30fps[] = {\n\t{ 0xfe, 0x00 },\n\t{ 0x0d, 0x01 },  \n\t{ 0x0e, 0xf2 },  \n\t{ 0x10, 0x94 },  \n\t{ 0x51, 0x00 },\n\t{ 0x52, 0x00 },\n\t{ 0x53, 0x00 },\n\t{ 0x54, 0x01 },\n\t{ 0x55, 0x01 },  \n\t{ 0x56, 0xf0 },\n\t{ 0x57, 0x02 },  \n\t{ 0x58, 0x90 },\n\n\t{ 0xfe, 0x03 },\n\t{ 0x12, 0x90 },  \nstatic int gc0310_write_reg_array(struct i2c_client *client,\n\t\t\t\t  const struct gc0310_reg *reglist, int count)\n{\n\tint i, err;\n\n\tfor (i = 0; i < count; i++) {\n\t\terr = i2c_smbus_write_byte_data(client, reglist[i].reg, reglist[i].val);\n\t\tif (err) {\n\t\t\tdev_err(&client->dev, \"write error: wrote 0x%x to offset 0x%x error %d\",\n\t\t\t\treglist[i].val, reglist[i].reg, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int gc0310_exposure_set(struct gc0310_device *dev, u32 exp)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&dev->sd);\n\n\treturn i2c_smbus_write_word_swapped(client, GC0310_AEC_PK_EXPO_H, exp);\n}\n\nstatic int gc0310_gain_set(struct gc0310_device *dev, u32 gain)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&dev->sd);\n\tu8 again, dgain;\n\tint ret;\n\n\t \n\n\t \n\tgain += 32;\n\n\tif (gain < 64) {\n\t\tagain = 0x0;  \n\t\tdgain = gain;\n\t} else {\n\t\tagain = 0x2;  \n\t\tdgain = gain / 2;\n\t}\n\n\tret = i2c_smbus_write_byte_data(client, GC0310_AGC_ADJ, again);\n\tif (ret)\n\t\treturn ret;\n\n\treturn i2c_smbus_write_byte_data(client, GC0310_DGC_ADJ, dgain);\n}\n\nstatic int gc0310_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gc0310_device *dev =\n\t\tcontainer_of(ctrl->handler, struct gc0310_device, ctrls.handler);\n\tint ret;\n\n\t \n\tif (!pm_runtime_get_if_in_use(dev->sd.dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\tret = gc0310_exposure_set(dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\tret = gc0310_gain_set(dev, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_put(dev->sd.dev);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ctrl_ops = {\n\t.s_ctrl = gc0310_s_ctrl,\n};\n\nstatic struct v4l2_mbus_framefmt *\ngc0310_get_pad_format(struct gc0310_device *dev,\n\t\t      struct v4l2_subdev_state *state,\n\t\t      unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&dev->sd, state, pad);\n\n\treturn &dev->mode.fmt;\n}\n\n \nstatic void gc0310_fill_format(struct v4l2_mbus_framefmt *fmt)\n{\n\tmemset(fmt, 0, sizeof(*fmt));\n\tfmt->width = GC0310_NATIVE_WIDTH;\n\tfmt->height = GC0310_NATIVE_HEIGHT;\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->code = MEDIA_BUS_FMT_SGRBG8_1X8;\n}\n\nstatic int gc0310_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct gc0310_device *dev = to_gc0310_sensor(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tfmt = gc0310_get_pad_format(dev, sd_state, format->pad, format->which);\n\tgc0310_fill_format(fmt);\n\n\tformat->format = *fmt;\n\treturn 0;\n}\n\nstatic int gc0310_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct gc0310_device *dev = to_gc0310_sensor(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tfmt = gc0310_get_pad_format(dev, sd_state, format->pad, format->which);\n\tformat->format = *fmt;\n\treturn 0;\n}\n\nstatic int gc0310_detect(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint ret;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tret = pm_runtime_get_sync(&client->dev);\n\tif (ret >= 0)\n\t\tret = i2c_smbus_read_word_swapped(client, GC0310_SC_CMMN_CHIP_ID_H);\n\tpm_runtime_put(&client->dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"read sensor_id failed: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&client->dev, \"sensor ID = 0x%x\\n\", ret);\n\n\tif (ret != GC0310_ID) {\n\t\tdev_err(&client->dev, \"sensor ID error, read id = 0x%x, target id = 0x%x\\n\",\n\t\t\tret, GC0310_ID);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&client->dev, \"detect gc0310 success\\n\");\n\n\treturn 0;\n}\n\nstatic int gc0310_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct gc0310_device *dev = to_gc0310_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tdev_dbg(&client->dev, \"%s S enable=%d\\n\", __func__, enable);\n\tmutex_lock(&dev->input_lock);\n\n\tif (dev->is_streaming == enable) {\n\t\tdev_warn(&client->dev, \"stream already %s\\n\", enable ? \"started\" : \"stopped\");\n\t\tgoto error_unlock;\n\t}\n\n\tif (enable) {\n\t\tret = pm_runtime_get_sync(&client->dev);\n\t\tif (ret < 0)\n\t\t\tgoto error_power_down;\n\n\t\tmsleep(100);\n\n\t\tret = gc0310_write_reg_array(client, gc0310_reset_register,\n\t\t\t\t\t     ARRAY_SIZE(gc0310_reset_register));\n\t\tif (ret)\n\t\t\tgoto error_power_down;\n\n\t\tret = gc0310_write_reg_array(client, gc0310_VGA_30fps,\n\t\t\t\t\t     ARRAY_SIZE(gc0310_VGA_30fps));\n\t\tif (ret)\n\t\t\tgoto error_power_down;\n\n\t\t \n\t\tret = __v4l2_ctrl_handler_setup(&dev->ctrls.handler);\n\t\tif (ret)\n\t\t\tgoto error_power_down;\n\n\t\t \n\t\tret = i2c_smbus_write_byte_data(client, 0xFE, 0x30);\n\t\tif (ret)\n\t\t\tgoto error_power_down;\n\t}\n\n\tret = i2c_smbus_write_byte_data(client, GC0310_RESET_RELATED, GC0310_REGISTER_PAGE_3);\n\tif (ret)\n\t\tgoto error_power_down;\n\n\tret = i2c_smbus_write_byte_data(client, GC0310_SW_STREAM,\n\t\t\t\t\tenable ? GC0310_START_STREAMING : GC0310_STOP_STREAMING);\n\tif (ret)\n\t\tgoto error_power_down;\n\n\tret = i2c_smbus_write_byte_data(client, GC0310_RESET_RELATED, GC0310_REGISTER_PAGE_0);\n\tif (ret)\n\t\tgoto error_power_down;\n\n\tif (!enable)\n\t\tpm_runtime_put(&client->dev);\n\n\tdev->is_streaming = enable;\n\tmutex_unlock(&dev->input_lock);\n\treturn 0;\n\nerror_power_down:\n\tpm_runtime_put(&client->dev);\n\tdev->is_streaming = false;\nerror_unlock:\n\tmutex_unlock(&dev->input_lock);\n\treturn ret;\n}\n\nstatic int gc0310_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *interval)\n{\n\tinterval->interval.numerator = 1;\n\tinterval->interval.denominator = GC0310_FPS;\n\n\treturn 0;\n}\n\nstatic int gc0310_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\t \n\tif (code->index)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_SGRBG8_1X8;\n\treturn 0;\n}\n\nstatic int gc0310_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\t \n\tif (fse->index)\n\t\treturn -EINVAL;\n\n\tfse->min_width = GC0310_NATIVE_WIDTH;\n\tfse->max_width = GC0310_NATIVE_WIDTH;\n\tfse->min_height = GC0310_NATIVE_HEIGHT;\n\tfse->max_height = GC0310_NATIVE_HEIGHT;\n\n\treturn 0;\n}\n\nstatic int gc0310_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)\n{\n\t*frames = GC0310_SKIP_FRAMES;\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_sensor_ops gc0310_sensor_ops = {\n\t.g_skip_frames\t= gc0310_g_skip_frames,\n};\n\nstatic const struct v4l2_subdev_video_ops gc0310_video_ops = {\n\t.s_stream = gc0310_s_stream,\n\t.g_frame_interval = gc0310_g_frame_interval,\n};\n\nstatic const struct v4l2_subdev_pad_ops gc0310_pad_ops = {\n\t.enum_mbus_code = gc0310_enum_mbus_code,\n\t.enum_frame_size = gc0310_enum_frame_size,\n\t.get_fmt = gc0310_get_fmt,\n\t.set_fmt = gc0310_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops gc0310_ops = {\n\t.video = &gc0310_video_ops,\n\t.pad = &gc0310_pad_ops,\n\t.sensor = &gc0310_sensor_ops,\n};\n\nstatic int gc0310_init_controls(struct gc0310_device *dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &dev->ctrls.handler;\n\n\tv4l2_ctrl_handler_init(hdl, 2);\n\n\t \n\thdl->lock = &dev->input_lock;\n\tdev->sd.ctrl_handler = hdl;\n\n\tdev->ctrls.exposure =\n\t\tv4l2_ctrl_new_std(hdl, &ctrl_ops, V4L2_CID_EXPOSURE, 0, 4095, 1, 1023);\n\n\t \n\tdev->ctrls.gain =\n\t\tv4l2_ctrl_new_std(hdl, &ctrl_ops, V4L2_CID_GAIN, 0, 95, 1, 31);\n\n\treturn hdl->error;\n}\n\nstatic void gc0310_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct gc0310_device *dev = to_gc0310_sensor(sd);\n\n\tdev_dbg(&client->dev, \"gc0310_remove...\\n\");\n\n\tv4l2_async_unregister_subdev(sd);\n\tmedia_entity_cleanup(&dev->sd.entity);\n\tv4l2_ctrl_handler_free(&dev->ctrls.handler);\n\tmutex_destroy(&dev->input_lock);\n\tfwnode_handle_put(dev->ep_fwnode);\n\tpm_runtime_disable(&client->dev);\n}\n\nstatic int gc0310_probe(struct i2c_client *client)\n{\n\tstruct gc0310_device *dev;\n\tint ret;\n\n\tdev = devm_kzalloc(&client->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tdev->ep_fwnode = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);\n\tif (!dev->ep_fwnode)\n\t\treturn dev_err_probe(&client->dev, -EPROBE_DEFER, \"waiting for fwnode graph endpoint\\n\");\n\n\tdev->reset = devm_gpiod_get(&client->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(dev->reset)) {\n\t\tfwnode_handle_put(dev->ep_fwnode);\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(dev->reset),\n\t\t\t\t     \"getting reset GPIO\\n\");\n\t}\n\n\tdev->powerdown = devm_gpiod_get(&client->dev, \"powerdown\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(dev->powerdown)) {\n\t\tfwnode_handle_put(dev->ep_fwnode);\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(dev->powerdown),\n\t\t\t\t     \"getting powerdown GPIO\\n\");\n\t}\n\n\tmutex_init(&dev->input_lock);\n\tv4l2_i2c_subdev_init(&dev->sd, client, &gc0310_ops);\n\tgc0310_fill_format(&dev->mode.fmt);\n\n\tpm_runtime_set_suspended(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev, 1000);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\tret = gc0310_detect(client);\n\tif (ret) {\n\t\tgc0310_remove(client);\n\t\treturn ret;\n\t}\n\n\tdev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tdev->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tdev->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tdev->sd.fwnode = dev->ep_fwnode;\n\n\tret = gc0310_init_controls(dev);\n\tif (ret) {\n\t\tgc0310_remove(client);\n\t\treturn ret;\n\t}\n\n\tret = media_entity_pads_init(&dev->sd.entity, 1, &dev->pad);\n\tif (ret) {\n\t\tgc0310_remove(client);\n\t\treturn ret;\n\t}\n\n\tret = v4l2_async_register_subdev_sensor(&dev->sd);\n\tif (ret) {\n\t\tgc0310_remove(client);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int gc0310_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct gc0310_device *gc0310_dev = to_gc0310_sensor(sd);\n\n\tgpiod_set_value_cansleep(gc0310_dev->powerdown, 1);\n\tgpiod_set_value_cansleep(gc0310_dev->reset, 1);\n\treturn 0;\n}\n\nstatic int gc0310_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct gc0310_device *gc0310_dev = to_gc0310_sensor(sd);\n\n\tusleep_range(10000, 15000);\n\tgpiod_set_value_cansleep(gc0310_dev->reset, 0);\n\tusleep_range(10000, 15000);\n\tgpiod_set_value_cansleep(gc0310_dev->powerdown, 0);\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(gc0310_pm_ops, gc0310_suspend, gc0310_resume, NULL);\n\nstatic const struct acpi_device_id gc0310_acpi_match[] = {\n\t{\"INT0310\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, gc0310_acpi_match);\n\nstatic struct i2c_driver gc0310_driver = {\n\t.driver = {\n\t\t.name = \"gc0310\",\n\t\t.pm = pm_sleep_ptr(&gc0310_pm_ops),\n\t\t.acpi_match_table = gc0310_acpi_match,\n\t},\n\t.probe = gc0310_probe,\n\t.remove = gc0310_remove,\n};\nmodule_i2c_driver(gc0310_driver);\n\nMODULE_AUTHOR(\"Lai, Angie <angie.lai@intel.com>\");\nMODULE_DESCRIPTION(\"A low-level driver for GalaxyCore GC0310 sensors\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}