{
  "module_name": "atomisp-gc2235.c",
  "hash_id": "e8fefa345b0b19b62fc6e3e1daa090250317a7b238f25fc010423a7bf44a8f9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/i2c/atomisp-gc2235.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/moduleparam.h>\n#include <media/v4l2-device.h>\n#include \"../include/linux/atomisp_gmin_platform.h\"\n#include <linux/acpi.h>\n#include <linux/io.h>\n\n#include \"gc2235.h\"\n\n \nstatic int gc2235_read_reg(struct i2c_client *client,\n\t\t\t   u16 data_length, u16 reg, u16 *val)\n{\n\tint err;\n\tstruct i2c_msg msg[2];\n\tunsigned char data[6];\n\n\tif (!client->adapter) {\n\t\tdev_err(&client->dev, \"%s error, no client->adapter\\n\",\n\t\t\t__func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (data_length != GC2235_8BIT) {\n\t\tdev_err(&client->dev, \"%s error, invalid data length\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(msg, 0, sizeof(msg));\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = 0;\n\tmsg[0].len = 1;\n\tmsg[0].buf = data;\n\n\t \n\tdata[0] = (u8)(reg & 0xff);\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].len = data_length;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].buf = data;\n\n\terr = i2c_transfer(client->adapter, msg, 2);\n\tif (err != 2) {\n\t\tif (err >= 0)\n\t\t\terr = -EIO;\n\t\tdev_err(&client->dev,\n\t\t\t\"read from offset 0x%x error %d\", reg, err);\n\t\treturn err;\n\t}\n\n\t*val = 0;\n\t \n\tif (data_length == GC2235_8BIT)\n\t\t*val = (u8)data[0];\n\n\treturn 0;\n}\n\nstatic int gc2235_i2c_write(struct i2c_client *client, u16 len, u8 *data)\n{\n\tstruct i2c_msg msg;\n\tconst int num_msg = 1;\n\tint ret;\n\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\tmsg.len = len;\n\tmsg.buf = data;\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\n\treturn ret == num_msg ? 0 : -EIO;\n}\n\nstatic int gc2235_write_reg(struct i2c_client *client, u16 data_length,\n\t\t\t    u8 reg, u8 val)\n{\n\tint ret;\n\tunsigned char data[4] = {0};\n\tconst u16 len = data_length + sizeof(u8);  \n\n\tif (data_length != GC2235_8BIT) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s error, invalid data_length\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdata[0] = reg;\n\tdata[1] = val;\n\n\tret = gc2235_i2c_write(client, len, data);\n\tif (ret)\n\t\tdev_err(&client->dev,\n\t\t\t\"write error: wrote 0x%x to offset 0x%x error %d\",\n\t\t\tval, reg, ret);\n\n\treturn ret;\n}\n\nstatic int __gc2235_flush_reg_array(struct i2c_client *client,\n\t\t\t\t    struct gc2235_write_ctrl *ctrl)\n{\n\tu16 size;\n\n\tif (ctrl->index == 0)\n\t\treturn 0;\n\n\tsize = sizeof(u8) + ctrl->index;  \n\tctrl->index = 0;\n\n\treturn gc2235_i2c_write(client, size, (u8 *)&ctrl->buffer);\n}\n\nstatic int __gc2235_buf_reg_array(struct i2c_client *client,\n\t\t\t\t  struct gc2235_write_ctrl *ctrl,\n\t\t\t\t  const struct gc2235_reg *next)\n{\n\tint size;\n\n\tif (next->type != GC2235_8BIT)\n\t\treturn -EINVAL;\n\n\tsize = 1;\n\tctrl->buffer.data[ctrl->index] = (u8)next->val;\n\n\t \n\tif (ctrl->index == 0)\n\t\tctrl->buffer.addr = next->reg;\n\n\tctrl->index += size;\n\n\t \n\tif (ctrl->index + sizeof(u8) >= GC2235_MAX_WRITE_BUF_SIZE)\n\t\treturn __gc2235_flush_reg_array(client, ctrl);\n\n\treturn 0;\n}\n\nstatic int __gc2235_write_reg_is_consecutive(struct i2c_client *client,\n\t\t\t\t\t     struct gc2235_write_ctrl *ctrl,\n\t\t\t\t\t     const struct gc2235_reg *next)\n{\n\tif (ctrl->index == 0)\n\t\treturn 1;\n\n\treturn ctrl->buffer.addr + ctrl->index == next->reg;\n}\n\nstatic int gc2235_write_reg_array(struct i2c_client *client,\n\t\t\t\t  const struct gc2235_reg *reglist)\n{\n\tconst struct gc2235_reg *next = reglist;\n\tstruct gc2235_write_ctrl ctrl;\n\tint err;\n\n\tctrl.index = 0;\n\tfor (; next->type != GC2235_TOK_TERM; next++) {\n\t\tswitch (next->type & GC2235_TOK_MASK) {\n\t\tcase GC2235_TOK_DELAY:\n\t\t\terr = __gc2235_flush_reg_array(client, &ctrl);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tmsleep(next->val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tif (!__gc2235_write_reg_is_consecutive(client, &ctrl,\n\t\t\t\t\t\t\t       next)) {\n\t\t\t\terr = __gc2235_flush_reg_array(client, &ctrl);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\terr = __gc2235_buf_reg_array(client, &ctrl, next);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&client->dev, \"%s: write error, aborted\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn __gc2235_flush_reg_array(client, &ctrl);\n}\n\nstatic long __gc2235_set_exposure(struct v4l2_subdev *sd, int coarse_itg,\n\t\t\t\t  int gain, int digitgain)\n\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu16 coarse_integration = (u16)coarse_itg;\n\tint ret = 0;\n\tu16 expo_coarse_h, expo_coarse_l, gain_val = 0xF0, gain_val2 = 0xF0;\n\n\texpo_coarse_h = coarse_integration >> 8;\n\texpo_coarse_l = coarse_integration & 0xff;\n\n\tret = gc2235_write_reg(client, GC2235_8BIT,\n\t\t\t       GC2235_EXPOSURE_H, expo_coarse_h);\n\tret = gc2235_write_reg(client, GC2235_8BIT,\n\t\t\t       GC2235_EXPOSURE_L, expo_coarse_l);\n\n\tif (gain <= 0x58) {\n\t\tgain_val = 0x40;\n\t\tgain_val2 = 0x58;\n\t} else if (gain < 256) {\n\t\tgain_val = 0x40;\n\t\tgain_val2 = gain;\n\t} else {\n\t\tgain_val2 = 64 * gain / 256;\n\t\tgain_val = 0xff;\n\t}\n\n\tret = gc2235_write_reg(client, GC2235_8BIT,\n\t\t\t       GC2235_GLOBAL_GAIN, (u8)gain_val);\n\tret = gc2235_write_reg(client, GC2235_8BIT,\n\t\t\t       GC2235_PRE_GAIN, (u8)gain_val2);\n\n\treturn ret;\n}\n\nstatic int gc2235_set_exposure(struct v4l2_subdev *sd, int exposure,\n\t\t\t       int gain, int digitgain)\n{\n\tstruct gc2235_device *dev = to_gc2235_sensor(sd);\n\tint ret;\n\n\tmutex_lock(&dev->input_lock);\n\tret = __gc2235_set_exposure(sd, exposure, gain, digitgain);\n\tmutex_unlock(&dev->input_lock);\n\n\treturn ret;\n}\n\nstatic long gc2235_s_exposure(struct v4l2_subdev *sd,\n\t\t\t      struct atomisp_exposure *exposure)\n{\n\tint exp = exposure->integration_time[0];\n\tint gain = exposure->gain[0];\n\tint digitgain = exposure->gain[1];\n\n\t \n\tif (gain == 0) {\n\t\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\t\tv4l2_err(client, \"%s: invalid value\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn gc2235_set_exposure(sd, exp, gain, digitgain);\n}\n\nstatic long gc2235_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase ATOMISP_IOC_S_EXPOSURE:\n\t\treturn gc2235_s_exposure(sd, arg);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int gc2235_q_exposure(struct v4l2_subdev *sd, s32 *value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu16 reg_v, reg_v2;\n\tint ret;\n\n\t \n\tret = gc2235_read_reg(client, GC2235_8BIT,\n\t\t\t      GC2235_EXPOSURE_L,\n\t\t\t      &reg_v);\n\tif (ret)\n\t\tgoto err;\n\n\tret = gc2235_read_reg(client, GC2235_8BIT,\n\t\t\t      GC2235_EXPOSURE_H,\n\t\t\t      &reg_v2);\n\tif (ret)\n\t\tgoto err;\n\n\treg_v += reg_v2 << 8;\n\n\t*value = reg_v;\nerr:\n\treturn ret;\n}\n\nstatic int gc2235_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gc2235_device *dev =\n\t    container_of(ctrl->handler, struct gc2235_device, ctrl_handler);\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE_ABSOLUTE:\n\t\tret = gc2235_q_exposure(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ctrl_ops = {\n\t.g_volatile_ctrl = gc2235_g_volatile_ctrl\n};\n\nstatic struct v4l2_ctrl_config gc2235_controls[] = {\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_EXPOSURE_ABSOLUTE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"exposure\",\n\t\t.min = 0x0,\n\t\t.max = 0xffff,\n\t\t.step = 0x01,\n\t\t.def = 0x00,\n\t\t.flags = 0,\n\t},\n};\n\nstatic int __gc2235_init(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\t \n\tgc2235_res = gc2235_res_preview;\n\tN_RES = N_RES_PREVIEW;\n\n\treturn gc2235_write_reg_array(client, gc2235_init_settings);\n}\n\nstatic int is_init;\n\nstatic int power_ctrl(struct v4l2_subdev *sd, bool flag)\n{\n\tint ret = -1;\n\tstruct gc2235_device *dev = to_gc2235_sensor(sd);\n\n\tif (!dev || !dev->platform_data)\n\t\treturn -ENODEV;\n\n\tif (flag) {\n\t\tret = dev->platform_data->v1p8_ctrl(sd, 1);\n\t\tusleep_range(60, 90);\n\t\tif (ret == 0)\n\t\t\tret |= dev->platform_data->v2p8_ctrl(sd, 1);\n\t} else {\n\t\tret = dev->platform_data->v1p8_ctrl(sd, 0);\n\t\tret |= dev->platform_data->v2p8_ctrl(sd, 0);\n\t}\n\treturn ret;\n}\n\nstatic int gpio_ctrl(struct v4l2_subdev *sd, bool flag)\n{\n\tstruct gc2235_device *dev = to_gc2235_sensor(sd);\n\tint ret;\n\n\tif (!dev || !dev->platform_data)\n\t\treturn -ENODEV;\n\n\tret = dev->platform_data->gpio1_ctrl(sd, !flag);\n\tusleep_range(60, 90);\n\tret |= dev->platform_data->gpio0_ctrl(sd, flag);\n\n\treturn ret;\n}\n\nstatic int power_up(struct v4l2_subdev *sd)\n{\n\tstruct gc2235_device *dev = to_gc2235_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tif (!dev->platform_data) {\n\t\tdev_err(&client->dev,\n\t\t\t\"no camera_sensor_platform_data\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tret = power_ctrl(sd, 1);\n\tif (ret)\n\t\tgoto fail_power;\n\n\t \n\tusleep_range(5000, 6000);\n\n\tret = dev->platform_data->flisclk_ctrl(sd, 1);\n\tif (ret)\n\t\tgoto fail_clk;\n\tusleep_range(5000, 6000);\n\n\t \n\tret = gpio_ctrl(sd, 1);\n\tif (ret) {\n\t\tret = gpio_ctrl(sd, 1);\n\t\tif (ret)\n\t\t\tgoto fail_power;\n\t}\n\n\tmsleep(5);\n\treturn 0;\n\nfail_clk:\n\tgpio_ctrl(sd, 0);\nfail_power:\n\tpower_ctrl(sd, 0);\n\tdev_err(&client->dev, \"sensor power-up failed\\n\");\n\n\treturn ret;\n}\n\nstatic int power_down(struct v4l2_subdev *sd)\n{\n\tstruct gc2235_device *dev = to_gc2235_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tif (!dev->platform_data) {\n\t\tdev_err(&client->dev,\n\t\t\t\"no camera_sensor_platform_data\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tret = gpio_ctrl(sd, 0);\n\tif (ret) {\n\t\tret = gpio_ctrl(sd, 0);\n\t\tif (ret)\n\t\t\tdev_err(&client->dev, \"gpio failed 2\\n\");\n\t}\n\n\tret = dev->platform_data->flisclk_ctrl(sd, 0);\n\tif (ret)\n\t\tdev_err(&client->dev, \"flisclk failed\\n\");\n\n\t \n\tret = power_ctrl(sd, 0);\n\tif (ret)\n\t\tdev_err(&client->dev, \"vprog failed.\\n\");\n\n\treturn ret;\n}\n\nstatic int gc2235_s_power(struct v4l2_subdev *sd, int on)\n{\n\tint ret;\n\n\tif (on == 0) {\n\t\tret = power_down(sd);\n\t} else {\n\t\tret = power_up(sd);\n\t\tif (!ret)\n\t\t\tret = __gc2235_init(sd);\n\t\tis_init = 1;\n\t}\n\treturn ret;\n}\n\nstatic int startup(struct v4l2_subdev *sd)\n{\n\tstruct gc2235_device *dev = to_gc2235_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tif (is_init == 0) {\n\t\t \n\t\tpower_down(sd);\n\t\tpower_up(sd);\n\t\tgc2235_write_reg_array(client, gc2235_init_settings);\n\t}\n\n\tret = gc2235_write_reg_array(client, dev->res->regs);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"gc2235 write register err.\\n\");\n\t\treturn ret;\n\t}\n\tis_init = 0;\n\n\treturn ret;\n}\n\nstatic int gc2235_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tstruct gc2235_device *dev = to_gc2235_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct camera_mipi_info *gc2235_info = NULL;\n\tstruct gc2235_resolution *res;\n\tint ret = 0;\n\n\tgc2235_info = v4l2_get_subdev_hostdata(sd);\n\tif (!gc2235_info)\n\t\treturn -EINVAL;\n\tif (format->pad)\n\t\treturn -EINVAL;\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->input_lock);\n\tres = v4l2_find_nearest_size(gc2235_res_preview,\n\t\t\t\t     ARRAY_SIZE(gc2235_res_preview), width,\n\t\t\t\t     height, fmt->width, fmt->height);\n\tif (!res)\n\t\tres = &gc2235_res_preview[N_RES - 1];\n\n\tfmt->width = res->width;\n\tfmt->height = res->height;\n\tdev->res = res;\n\n\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tsd_state->pads->try_fmt = *fmt;\n\t\tmutex_unlock(&dev->input_lock);\n\t\treturn 0;\n\t}\n\n\tret = startup(sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"gc2235 startup err\\n\");\n\t\tgoto err;\n\t}\n\nerr:\n\tmutex_unlock(&dev->input_lock);\n\treturn ret;\n}\n\nstatic int gc2235_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tstruct gc2235_device *dev = to_gc2235_sensor(sd);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tfmt->width = dev->res->width;\n\tfmt->height = dev->res->height;\n\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\n\treturn 0;\n}\n\nstatic int gc2235_detect(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tu16 high = 0, low = 0;\n\tu16 id;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tgc2235_read_reg(client, GC2235_8BIT, GC2235_SENSOR_ID_H, &high);\n\tgc2235_read_reg(client, GC2235_8BIT, GC2235_SENSOR_ID_L, &low);\n\tid = ((high << 8) | low);\n\n\tif (id != GC2235_ID) {\n\t\tdev_err(&client->dev, \"sensor ID error, 0x%x\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&client->dev, \"detect gc2235 success\\n\");\n\treturn 0;\n}\n\nstatic int gc2235_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct gc2235_device *dev = to_gc2235_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tmutex_lock(&dev->input_lock);\n\n\tif (enable)\n\t\tret = gc2235_write_reg_array(client, gc2235_stream_on);\n\telse\n\t\tret = gc2235_write_reg_array(client, gc2235_stream_off);\n\n\tmutex_unlock(&dev->input_lock);\n\treturn ret;\n}\n\nstatic int gc2235_s_config(struct v4l2_subdev *sd,\n\t\t\t   int irq, void *platform_data)\n{\n\tstruct gc2235_device *dev = to_gc2235_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tif (!platform_data)\n\t\treturn -ENODEV;\n\n\tdev->platform_data =\n\t    (struct camera_sensor_platform_data *)platform_data;\n\n\tmutex_lock(&dev->input_lock);\n\t \n\tret = power_down(sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"gc2235 power-off err.\\n\");\n\t\tgoto fail_power_off;\n\t}\n\n\tret = power_up(sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"gc2235 power-up err.\\n\");\n\t\tgoto fail_power_on;\n\t}\n\n\tret = dev->platform_data->csi_cfg(sd, 1);\n\tif (ret)\n\t\tgoto fail_csi_cfg;\n\n\t \n\tret = gc2235_detect(client);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"gc2235_detect err s_config.\\n\");\n\t\tgoto fail_csi_cfg;\n\t}\n\n\t \n\tret = power_down(sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"gc2235 power-off err.\\n\");\n\t\tgoto fail_csi_cfg;\n\t}\n\tmutex_unlock(&dev->input_lock);\n\n\treturn 0;\n\nfail_csi_cfg:\n\tdev->platform_data->csi_cfg(sd, 0);\nfail_power_on:\n\tpower_down(sd);\n\tdev_err(&client->dev, \"sensor power-gating failed\\n\");\nfail_power_off:\n\tmutex_unlock(&dev->input_lock);\n\treturn ret;\n}\n\nstatic int gc2235_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *interval)\n{\n\tstruct gc2235_device *dev = to_gc2235_sensor(sd);\n\n\tinterval->interval.numerator = 1;\n\tinterval->interval.denominator = dev->res->fps;\n\n\treturn 0;\n}\n\nstatic int gc2235_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index >= MAX_FMTS)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\treturn 0;\n}\n\nstatic int gc2235_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tint index = fse->index;\n\n\tif (index >= N_RES)\n\t\treturn -EINVAL;\n\n\tfse->min_width = gc2235_res[index].width;\n\tfse->min_height = gc2235_res[index].height;\n\tfse->max_width = gc2235_res[index].width;\n\tfse->max_height = gc2235_res[index].height;\n\n\treturn 0;\n}\n\nstatic int gc2235_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)\n{\n\tstruct gc2235_device *dev = to_gc2235_sensor(sd);\n\n\tmutex_lock(&dev->input_lock);\n\t*frames = dev->res->skip_frames;\n\tmutex_unlock(&dev->input_lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_sensor_ops gc2235_sensor_ops = {\n\t.g_skip_frames\t= gc2235_g_skip_frames,\n};\n\nstatic const struct v4l2_subdev_video_ops gc2235_video_ops = {\n\t.s_stream = gc2235_s_stream,\n\t.g_frame_interval = gc2235_g_frame_interval,\n};\n\nstatic const struct v4l2_subdev_core_ops gc2235_core_ops = {\n\t.s_power = gc2235_s_power,\n\t.ioctl = gc2235_ioctl,\n};\n\nstatic const struct v4l2_subdev_pad_ops gc2235_pad_ops = {\n\t.enum_mbus_code = gc2235_enum_mbus_code,\n\t.enum_frame_size = gc2235_enum_frame_size,\n\t.get_fmt = gc2235_get_fmt,\n\t.set_fmt = gc2235_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops gc2235_ops = {\n\t.core = &gc2235_core_ops,\n\t.video = &gc2235_video_ops,\n\t.pad = &gc2235_pad_ops,\n\t.sensor = &gc2235_sensor_ops,\n};\n\nstatic void gc2235_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct gc2235_device *dev = to_gc2235_sensor(sd);\n\n\tdev_dbg(&client->dev, \"gc2235_remove...\\n\");\n\n\tdev->platform_data->csi_cfg(sd, 0);\n\n\tv4l2_device_unregister_subdev(sd);\n\tmedia_entity_cleanup(&dev->sd.entity);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tkfree(dev);\n}\n\nstatic int gc2235_probe(struct i2c_client *client)\n{\n\tstruct gc2235_device *dev;\n\tvoid *gcpdev;\n\tint ret;\n\tunsigned int i;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->input_lock);\n\n\tdev->res = &gc2235_res_preview[0];\n\tv4l2_i2c_subdev_init(&dev->sd, client, &gc2235_ops);\n\n\tgcpdev = gmin_camera_platform_data(&dev->sd,\n\t\t\t\t\t   ATOMISP_INPUT_FORMAT_RAW_10,\n\t\t\t\t\t   atomisp_bayer_order_grbg);\n\n\tret = gc2235_s_config(&dev->sd, client->irq, gcpdev);\n\tif (ret)\n\t\tgoto out_free;\n\n\tdev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tdev->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tdev->format.code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\tdev->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret =\n\t    v4l2_ctrl_handler_init(&dev->ctrl_handler,\n\t\t\t\t   ARRAY_SIZE(gc2235_controls));\n\tif (ret) {\n\t\tgc2235_remove(client);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(gc2235_controls); i++)\n\t\tv4l2_ctrl_new_custom(&dev->ctrl_handler, &gc2235_controls[i],\n\t\t\t\t     NULL);\n\n\tif (dev->ctrl_handler.error) {\n\t\tgc2235_remove(client);\n\t\treturn dev->ctrl_handler.error;\n\t}\n\n\t \n\tdev->ctrl_handler.lock = &dev->input_lock;\n\tdev->sd.ctrl_handler = &dev->ctrl_handler;\n\n\tret = media_entity_pads_init(&dev->sd.entity, 1, &dev->pad);\n\tif (ret)\n\t\tgc2235_remove(client);\n\n\treturn atomisp_register_i2c_module(&dev->sd, gcpdev, RAW_CAMERA);\n\nout_free:\n\tv4l2_device_unregister_subdev(&dev->sd);\n\tkfree(dev);\n\n\treturn ret;\n}\n\nstatic const struct acpi_device_id gc2235_acpi_match[] = {\n\t{ \"INT33F8\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, gc2235_acpi_match);\n\nstatic struct i2c_driver gc2235_driver = {\n\t.driver = {\n\t\t.name = \"gc2235\",\n\t\t.acpi_match_table = gc2235_acpi_match,\n\t},\n\t.probe = gc2235_probe,\n\t.remove = gc2235_remove,\n};\nmodule_i2c_driver(gc2235_driver);\n\nMODULE_AUTHOR(\"Shuguang Gong <Shuguang.Gong@intel.com>\");\nMODULE_DESCRIPTION(\"A low-level driver for GC2235 sensors\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}