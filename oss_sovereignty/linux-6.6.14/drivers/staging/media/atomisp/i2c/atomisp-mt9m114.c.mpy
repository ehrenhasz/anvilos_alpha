{
  "module_name": "atomisp-mt9m114.c",
  "hash_id": "7ed1a28bb0154be0e8685111412b65f8709662f62707a6c4a157e910ad3de4a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/i2c/atomisp-mt9m114.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include \"../include/linux/atomisp_gmin_platform.h\"\n#include <media/v4l2-device.h>\n\n#include \"mt9m114.h\"\n\n#define to_mt9m114_sensor(sd) container_of(sd, struct mt9m114_device, sd)\n\n \nstatic int debug;\nstatic int aaalock;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\nstatic int mt9m114_t_vflip(struct v4l2_subdev *sd, int value);\nstatic int mt9m114_t_hflip(struct v4l2_subdev *sd, int value);\nstatic int mt9m114_wait_state(struct i2c_client *client, int timeout);\n\nstatic int\nmt9m114_read_reg(struct i2c_client *client, u16 data_length, u32 reg, u32 *val)\n{\n\tint err;\n\tstruct i2c_msg msg[2];\n\tunsigned char data[4];\n\n\tif (!client->adapter) {\n\t\tv4l2_err(client, \"%s error, no client->adapter\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT\n\t    && data_length != MISENSOR_32BIT) {\n\t\tv4l2_err(client, \"%s error, invalid data length\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = 0;\n\tmsg[0].len = MSG_LEN_OFFSET;\n\tmsg[0].buf = data;\n\n\t \n\tdata[0] = (u16)(reg >> 8);\n\tdata[1] = (u16)(reg & 0xff);\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].len = data_length;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].buf = data;\n\n\terr = i2c_transfer(client->adapter, msg, 2);\n\n\tif (err >= 0) {\n\t\t*val = 0;\n\t\t \n\t\tif (data_length == MISENSOR_8BIT)\n\t\t\t*val = data[0];\n\t\telse if (data_length == MISENSOR_16BIT)\n\t\t\t*val = data[1] + (data[0] << 8);\n\t\telse\n\t\t\t*val = data[3] + (data[2] << 8) +\n\t\t\t       (data[1] << 16) + (data[0] << 24);\n\n\t\treturn 0;\n\t}\n\n\tdev_err(&client->dev, \"read from offset 0x%x error %d\", reg, err);\n\treturn err;\n}\n\nstatic int\nmt9m114_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 val)\n{\n\tint num_msg;\n\tstruct i2c_msg msg;\n\tunsigned char data[6] = {0};\n\t__be16 *wreg;\n\tint retry = 0;\n\n\tif (!client->adapter) {\n\t\tv4l2_err(client, \"%s error, no client->adapter\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT\n\t    && data_length != MISENSOR_32BIT) {\n\t\tv4l2_err(client, \"%s error, invalid data_length\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&msg, 0, sizeof(msg));\n\nagain:\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\tmsg.len = 2 + data_length;\n\tmsg.buf = data;\n\n\t \n\twreg = (void *)data;\n\t*wreg = cpu_to_be16(reg);\n\n\tif (data_length == MISENSOR_8BIT) {\n\t\tdata[2] = (u8)(val);\n\t} else if (data_length == MISENSOR_16BIT) {\n\t\tu16 *wdata = (void *)&data[2];\n\n\t\t*wdata = be16_to_cpu(*(__be16 *)&data[2]);\n\t} else {\n\t\t \n\t\tu32 *wdata = (void *)&data[2];\n\n\t\t*wdata = be32_to_cpu(*(__be32 *)&data[2]);\n\t}\n\n\tnum_msg = i2c_transfer(client->adapter, &msg, 1);\n\n\t \n\tmdelay(1);\n\n\tif (num_msg >= 0)\n\t\treturn 0;\n\n\tdev_err(&client->dev, \"write error: wrote 0x%x to offset 0x%x error %d\",\n\t\tval, reg, num_msg);\n\tif (retry <= I2C_RETRY_COUNT) {\n\t\tdev_dbg(&client->dev, \"retrying... %d\", retry);\n\t\tretry++;\n\t\tmsleep(20);\n\t\tgoto again;\n\t}\n\n\treturn num_msg;\n}\n\n \nstatic int\nmisensor_rmw_reg(struct i2c_client *client, u16 data_length, u16 reg,\n\t\t u32 mask, u32 set)\n{\n\tint err;\n\tu32 val;\n\n\t \n\tif (mask == 0)\n\t\treturn 0;\n\n\t \n\tswitch (data_length) {\n\tcase MISENSOR_8BIT:\n\t\tif (mask & ~0xff)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase MISENSOR_16BIT:\n\t\tif (mask & ~0xffff)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase MISENSOR_32BIT:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\terr = mt9m114_read_reg(client, data_length, reg, &val);\n\tif (err) {\n\t\tv4l2_err(client, \"%s error exit, read failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tval &= ~mask;\n\n\t \n\tset <<= ffs(mask) - 1;\n\tval |= set & mask;\n\n\terr = mt9m114_write_reg(client, data_length, reg, val);\n\tif (err) {\n\t\tv4l2_err(client, \"%s error exit, write failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __mt9m114_flush_reg_array(struct i2c_client *client,\n\t\t\t\t     struct mt9m114_write_ctrl *ctrl)\n{\n\tstruct i2c_msg msg;\n\tconst int num_msg = 1;\n\tint ret;\n\tint retry = 0;\n\t__be16 *data16 = (void *)&ctrl->buffer.addr;\n\n\tif (ctrl->index == 0)\n\t\treturn 0;\n\nagain:\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\tmsg.len = 2 + ctrl->index;\n\t*data16 = cpu_to_be16(ctrl->buffer.addr);\n\tmsg.buf = (u8 *)&ctrl->buffer;\n\n\tret = i2c_transfer(client->adapter, &msg, num_msg);\n\tif (ret != num_msg) {\n\t\tif (++retry <= I2C_RETRY_COUNT) {\n\t\t\tdev_dbg(&client->dev, \"retrying... %d\\n\", retry);\n\t\t\tmsleep(20);\n\t\t\tgoto again;\n\t\t}\n\t\tdev_err(&client->dev, \"%s: i2c transfer error\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tctrl->index = 0;\n\n\t \n\n\treturn 0;\n}\n\nstatic int __mt9m114_buf_reg_array(struct i2c_client *client,\n\t\t\t\t   struct mt9m114_write_ctrl *ctrl,\n\t\t\t\t   const struct misensor_reg *next)\n{\n\t__be16 *data16;\n\t__be32 *data32;\n\tint err;\n\n\t \n\tif (ctrl->index + next->length >= MT9M114_MAX_WRITE_BUF_SIZE) {\n\t\terr = __mt9m114_flush_reg_array(client, ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tswitch (next->length) {\n\tcase MISENSOR_8BIT:\n\t\tctrl->buffer.data[ctrl->index] = (u8)next->val;\n\t\tbreak;\n\tcase MISENSOR_16BIT:\n\t\tdata16 = (__be16 *)&ctrl->buffer.data[ctrl->index];\n\t\t*data16 = cpu_to_be16((u16)next->val);\n\t\tbreak;\n\tcase MISENSOR_32BIT:\n\t\tdata32 = (__be32 *)&ctrl->buffer.data[ctrl->index];\n\t\t*data32 = cpu_to_be32(next->val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ctrl->index == 0)\n\t\tctrl->buffer.addr = next->reg;\n\n\tctrl->index += next->length;\n\n\treturn 0;\n}\n\nstatic int\n__mt9m114_write_reg_is_consecutive(struct i2c_client *client,\n\t\t\t\t   struct mt9m114_write_ctrl *ctrl,\n\t\t\t\t   const struct misensor_reg *next)\n{\n\tif (ctrl->index == 0)\n\t\treturn 1;\n\n\treturn ctrl->buffer.addr + ctrl->index == next->reg;\n}\n\n \nstatic int mt9m114_write_reg_array(struct i2c_client *client,\n\t\t\t\t   const struct misensor_reg *reglist,\n\t\t\t\t   int poll)\n{\n\tconst struct misensor_reg *next = reglist;\n\tstruct mt9m114_write_ctrl ctrl;\n\tint err;\n\n\tif (poll == PRE_POLLING) {\n\t\terr = mt9m114_wait_state(client, MT9M114_WAIT_STAT_TIMEOUT);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tctrl.index = 0;\n\tfor (; next->length != MISENSOR_TOK_TERM; next++) {\n\t\tswitch (next->length & MISENSOR_TOK_MASK) {\n\t\tcase MISENSOR_TOK_DELAY:\n\t\t\terr = __mt9m114_flush_reg_array(client, &ctrl);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tmsleep(next->val);\n\t\t\tbreak;\n\t\tcase MISENSOR_TOK_RMW:\n\t\t\terr = __mt9m114_flush_reg_array(client, &ctrl);\n\t\t\terr |= misensor_rmw_reg(client,\n\t\t\t\t\t\tnext->length &\n\t\t\t\t\t\t~MISENSOR_TOK_RMW,\n\t\t\t\t\t\tnext->reg, next->val,\n\t\t\t\t\t\tnext->val2);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&client->dev, \"%s read err. aborted\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tif (!__mt9m114_write_reg_is_consecutive(client, &ctrl,\n\t\t\t\t\t\t\t\tnext)) {\n\t\t\t\terr = __mt9m114_flush_reg_array(client, &ctrl);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\terr = __mt9m114_buf_reg_array(client, &ctrl, next);\n\t\t\tif (err) {\n\t\t\t\tv4l2_err(client, \"%s: write error, aborted\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\terr = __mt9m114_flush_reg_array(client, &ctrl);\n\tif (err)\n\t\treturn err;\n\n\tif (poll == POST_POLLING)\n\t\treturn mt9m114_wait_state(client, MT9M114_WAIT_STAT_TIMEOUT);\n\n\treturn 0;\n}\n\nstatic int mt9m114_wait_state(struct i2c_client *client, int timeout)\n{\n\tint ret;\n\tunsigned int val;\n\n\twhile (timeout-- > 0) {\n\t\tret = mt9m114_read_reg(client, MISENSOR_16BIT, 0x0080, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif ((val & 0x2) == 0)\n\t\t\treturn 0;\n\t\tmsleep(20);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mt9m114_set_suspend(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn mt9m114_write_reg_array(client,\n\t\t\t\t       mt9m114_standby_reg, POST_POLLING);\n}\n\nstatic int mt9m114_init_common(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn mt9m114_write_reg_array(client, mt9m114_common, PRE_POLLING);\n}\n\nstatic int power_ctrl(struct v4l2_subdev *sd, bool flag)\n{\n\tint ret;\n\tstruct mt9m114_device *dev = to_mt9m114_sensor(sd);\n\n\tif (!dev || !dev->platform_data)\n\t\treturn -ENODEV;\n\n\tif (flag) {\n\t\tret = dev->platform_data->v2p8_ctrl(sd, 1);\n\t\tif (ret == 0) {\n\t\t\tret = dev->platform_data->v1p8_ctrl(sd, 1);\n\t\t\tif (ret)\n\t\t\t\tret = dev->platform_data->v2p8_ctrl(sd, 0);\n\t\t}\n\t} else {\n\t\tret = dev->platform_data->v2p8_ctrl(sd, 0);\n\t\tret = dev->platform_data->v1p8_ctrl(sd, 0);\n\t}\n\treturn ret;\n}\n\nstatic int gpio_ctrl(struct v4l2_subdev *sd, bool flag)\n{\n\tint ret;\n\tstruct mt9m114_device *dev = to_mt9m114_sensor(sd);\n\n\tif (!dev || !dev->platform_data)\n\t\treturn -ENODEV;\n\n\t \n\n\tif (flag) {\n\t\tret = dev->platform_data->gpio0_ctrl(sd, 0);\n\t\tret = dev->platform_data->gpio1_ctrl(sd, 0);\n\t\tmsleep(60);\n\t\tret |= dev->platform_data->gpio0_ctrl(sd, 1);\n\t\tret |= dev->platform_data->gpio1_ctrl(sd, 1);\n\t} else {\n\t\tret = dev->platform_data->gpio0_ctrl(sd, 0);\n\t\tret = dev->platform_data->gpio1_ctrl(sd, 0);\n\t}\n\treturn ret;\n}\n\nstatic int power_up(struct v4l2_subdev *sd)\n{\n\tstruct mt9m114_device *dev = to_mt9m114_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tif (!dev->platform_data) {\n\t\tdev_err(&client->dev, \"no camera_sensor_platform_data\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = power_ctrl(sd, 1);\n\tif (ret)\n\t\tgoto fail_power;\n\n\t \n\tret = dev->platform_data->flisclk_ctrl(sd, 1);\n\tif (ret)\n\t\tgoto fail_clk;\n\n\t \n\tret = gpio_ctrl(sd, 1);\n\tif (ret)\n\t\tdev_err(&client->dev, \"gpio failed 1\\n\");\n\t \n\tmsleep(50);\n\n\treturn 0;\n\nfail_clk:\n\tdev->platform_data->flisclk_ctrl(sd, 0);\nfail_power:\n\tpower_ctrl(sd, 0);\n\tdev_err(&client->dev, \"sensor power-up failed\\n\");\n\n\treturn ret;\n}\n\nstatic int power_down(struct v4l2_subdev *sd)\n{\n\tstruct mt9m114_device *dev = to_mt9m114_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tif (!dev->platform_data) {\n\t\tdev_err(&client->dev, \"no camera_sensor_platform_data\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = dev->platform_data->flisclk_ctrl(sd, 0);\n\tif (ret)\n\t\tdev_err(&client->dev, \"flisclk failed\\n\");\n\n\t \n\tret = gpio_ctrl(sd, 0);\n\tif (ret)\n\t\tdev_err(&client->dev, \"gpio failed 1\\n\");\n\n\t \n\tret = power_ctrl(sd, 0);\n\tif (ret)\n\t\tdev_err(&client->dev, \"vprog failed.\\n\");\n\n\t \n\tmsleep(20);\n\n\treturn ret;\n}\n\nstatic int mt9m114_s_power(struct v4l2_subdev *sd, int power)\n{\n\tif (power == 0)\n\t\treturn power_down(sd);\n\n\tif (power_up(sd))\n\t\treturn -EINVAL;\n\n\treturn mt9m114_init_common(sd);\n}\n\nstatic int mt9m114_res2size(struct v4l2_subdev *sd, int *h_size, int *v_size)\n{\n\tstruct mt9m114_device *dev = to_mt9m114_sensor(sd);\n\tunsigned short hsize;\n\tunsigned short vsize;\n\n\tswitch (dev->res) {\n\tcase MT9M114_RES_736P:\n\t\thsize = MT9M114_RES_736P_SIZE_H;\n\t\tvsize = MT9M114_RES_736P_SIZE_V;\n\t\tbreak;\n\tcase MT9M114_RES_864P:\n\t\thsize = MT9M114_RES_864P_SIZE_H;\n\t\tvsize = MT9M114_RES_864P_SIZE_V;\n\t\tbreak;\n\tcase MT9M114_RES_960P:\n\t\thsize = MT9M114_RES_960P_SIZE_H;\n\t\tvsize = MT9M114_RES_960P_SIZE_V;\n\t\tbreak;\n\tdefault:\n\t\tv4l2_err(sd, \"%s: Resolution 0x%08x unknown\\n\", __func__,\n\t\t\t dev->res);\n\t\treturn -EINVAL;\n\t}\n\n\tif (h_size)\n\t\t*h_size = hsize;\n\tif (v_size)\n\t\t*v_size = vsize;\n\n\treturn 0;\n}\n\nstatic int mt9m114_get_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tint width, height;\n\tint ret;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\n\tret = mt9m114_res2size(sd, &width, &height);\n\tif (ret)\n\t\treturn ret;\n\tfmt->width = width;\n\tfmt->height = height;\n\n\treturn 0;\n}\n\nstatic int mt9m114_set_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\tstruct mt9m114_device *dev = to_mt9m114_sensor(sd);\n\tstruct mt9m114_res_struct *res;\n\tu32 width = fmt->width;\n\tu32 height = fmt->height;\n\tstruct camera_mipi_info *mt9m114_info = NULL;\n\n\tint ret;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\tdev->streamon = 0;\n\tdev->first_exp = MT9M114_DEFAULT_FIRST_EXP;\n\n\tmt9m114_info = v4l2_get_subdev_hostdata(sd);\n\tif (!mt9m114_info)\n\t\treturn -EINVAL;\n\n\tres = v4l2_find_nearest_size(mt9m114_res,\n\t\t\t\t     ARRAY_SIZE(mt9m114_res), width,\n\t\t\t\t     height, fmt->width, fmt->height);\n\tif (!res)\n\t\tres = &mt9m114_res[N_RES - 1];\n\n\tfmt->width = res->width;\n\tfmt->height = res->height;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tsd_state->pads->try_fmt = *fmt;\n\t\treturn 0;\n\t}\n\n\tswitch (res->res) {\n\tcase MT9M114_RES_736P:\n\t\tret = mt9m114_write_reg_array(c, mt9m114_736P_init, NO_POLLING);\n\t\tret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,\n\t\t\t\t\tMISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);\n\t\tbreak;\n\tcase MT9M114_RES_864P:\n\t\tret = mt9m114_write_reg_array(c, mt9m114_864P_init, NO_POLLING);\n\t\tret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,\n\t\t\t\t\tMISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);\n\t\tbreak;\n\tcase MT9M114_RES_960P:\n\t\tret = mt9m114_write_reg_array(c, mt9m114_976P_init, NO_POLLING);\n\t\t \n\t\tret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,\n\t\t\t\t\tMISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);\n\t\tbreak;\n\tdefault:\n\t\tv4l2_err(sd, \"set resolution: %d failed!\\n\", res->res);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tret = mt9m114_write_reg_array(c, mt9m114_chgstat_reg, POST_POLLING);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (mt9m114_set_suspend(sd))\n\t\treturn -EINVAL;\n\n\tif (dev->res != res->res) {\n\t\tint index;\n\n\t\t \n\t\tif (width <= 640) {\n\t\t\tdev->nctx = 0x00;  \n\t\t} else {\n\t\t\t \n\t\t\tdev->nctx = 0x01;  \n\t\t}\n\n\t\t \n\t\tfor (index = 0; index < N_RES; index++) {\n\t\t\tif ((width == mt9m114_res[index].width) &&\n\t\t\t    (height == mt9m114_res[index].height)) {\n\t\t\t\tmt9m114_res[index].used = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmt9m114_res[index].used = false;\n\t\t}\n\t}\n\t \n\tdev->res = res->res;\n\n\tfmt->width = width;\n\tfmt->height = height;\n\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\treturn 0;\n}\n\n \nstatic int mt9m114_g_hflip(struct v4l2_subdev *sd, s32 *val)\n{\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\tint ret;\n\tu32 data;\n\n\tret = mt9m114_read_reg(c, MISENSOR_16BIT,\n\t\t\t       (u32)MISENSOR_READ_MODE, &data);\n\tif (ret)\n\t\treturn ret;\n\t*val = !!(data & MISENSOR_HFLIP_MASK);\n\n\treturn 0;\n}\n\nstatic int mt9m114_g_vflip(struct v4l2_subdev *sd, s32 *val)\n{\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\tint ret;\n\tu32 data;\n\n\tret = mt9m114_read_reg(c, MISENSOR_16BIT,\n\t\t\t       (u32)MISENSOR_READ_MODE, &data);\n\tif (ret)\n\t\treturn ret;\n\t*val = !!(data & MISENSOR_VFLIP_MASK);\n\n\treturn 0;\n}\n\nstatic long mt9m114_s_exposure(struct v4l2_subdev *sd,\n\t\t\t       struct atomisp_exposure *exposure)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m114_device *dev = to_mt9m114_sensor(sd);\n\tint ret = 0;\n\tunsigned int coarse_integration = 0;\n\tunsigned int f_lines = 0;\n\tunsigned int frame_len_lines = 0;  \n\tunsigned int analog_gain, digital_gain;\n\tu32 analog_gain_to_write = 0;\n\n\tdev_dbg(&client->dev, \"%s(0x%X 0x%X 0x%X)\\n\", __func__,\n\t\texposure->integration_time[0], exposure->gain[0],\n\t\texposure->gain[1]);\n\n\tcoarse_integration = exposure->integration_time[0];\n\t \n\tf_lines = mt9m114_res[dev->res].lines_per_frame;\n\tanalog_gain = exposure->gain[0];\n\tdigital_gain = exposure->gain[1];\n\tif (!dev->streamon) {\n\t\t \n\t\tdev->first_exp = coarse_integration;\n\t\tdev->first_gain = analog_gain;\n\t\tdev->first_diggain = digital_gain;\n\t}\n\t \n\t \n\n\t \n\tif (f_lines < coarse_integration + 6)\n\t\tf_lines = coarse_integration + 6;\n\tif (f_lines < frame_len_lines)\n\t\tf_lines = frame_len_lines;\n\tret = mt9m114_write_reg(client, MISENSOR_16BIT, 0x300A, f_lines);\n\tif (ret) {\n\t\tv4l2_err(client, \"%s: fail to set f_lines\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t \n\tret = mt9m114_write_reg(client, MISENSOR_16BIT,\n\t\t\t\tREG_EXPO_COARSE, (u16)(coarse_integration));\n\tif (ret) {\n\t\tv4l2_err(client, \"%s: fail to set exposure time\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (digital_gain >= 16 || digital_gain <= 1)\n\t\tdigital_gain = 1;\n\t \n\tanalog_gain_to_write = (u16)((digital_gain << 12) | (u16)analog_gain);\n\tret = mt9m114_write_reg(client, MISENSOR_16BIT,\n\t\t\t\tREG_GAIN, analog_gain_to_write);\n\tif (ret) {\n\t\tv4l2_err(client, \"%s: fail to set analog_gain_to_write\\n\",\n\t\t\t __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic long mt9m114_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase ATOMISP_IOC_S_EXPOSURE:\n\t\treturn mt9m114_s_exposure(sd, arg);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mt9m114_g_exposure(struct v4l2_subdev *sd, s32 *value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu32 coarse;\n\tint ret;\n\n\t \n\tret = mt9m114_read_reg(client, MISENSOR_16BIT,\n\t\t\t       REG_EXPO_COARSE, &coarse);\n\tif (ret)\n\t\treturn ret;\n\n\t*value = coarse;\n\treturn 0;\n}\n\n \nstatic int mt9m114_g_exposure_zone_num(struct v4l2_subdev *sd, s32 *val)\n{\n\t*val = 1;\n\n\treturn 0;\n}\n\n \nstatic int mt9m114_s_exposure_metering(struct v4l2_subdev *sd, s32 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tswitch (val) {\n\tcase V4L2_EXPOSURE_METERING_SPOT:\n\t\tret = mt9m114_write_reg_array(client, mt9m114_exp_average,\n\t\t\t\t\t      NO_POLLING);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"write exp_average reg err.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase V4L2_EXPOSURE_METERING_CENTER_WEIGHTED:\n\tdefault:\n\t\tret = mt9m114_write_reg_array(client, mt9m114_exp_center,\n\t\t\t\t\t      NO_POLLING);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"write exp_default reg err\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mt9m114_s_exposure_selection(struct v4l2_subdev *sd,\n\t\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct misensor_reg exp_reg;\n\tint width, height;\n\tint grid_width, grid_height;\n\tint grid_left, grid_top, grid_right, grid_bottom;\n\tint win_left, win_top, win_right, win_bottom;\n\tint i, j;\n\tint ret;\n\n\tif (sel->which != V4L2_SUBDEV_FORMAT_TRY &&\n\t    sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\n\tgrid_left = sel->r.left;\n\tgrid_top = sel->r.top;\n\tgrid_right = sel->r.left + sel->r.width - 1;\n\tgrid_bottom = sel->r.top + sel->r.height - 1;\n\n\tret = mt9m114_res2size(sd, &width, &height);\n\tif (ret)\n\t\treturn ret;\n\n\tgrid_width = width / 5;\n\tgrid_height = height / 5;\n\n\tif (grid_width && grid_height) {\n\t\twin_left = grid_left / grid_width;\n\t\twin_top = grid_top / grid_height;\n\t\twin_right = grid_right / grid_width;\n\t\twin_bottom = grid_bottom / grid_height;\n\t} else {\n\t\tdev_err(&client->dev, \"Incorrect exp grid.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twin_left   = clamp_t(int, win_left, 0, 4);\n\twin_top    = clamp_t(int, win_top, 0, 4);\n\twin_right  = clamp_t(int, win_right, 0, 4);\n\twin_bottom = clamp_t(int, win_bottom, 0, 4);\n\n\tret = mt9m114_write_reg_array(client, mt9m114_exp_average, NO_POLLING);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"write exp_average reg err.\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = win_top; i <= win_bottom; i++) {\n\t\tfor (j = win_left; j <= win_right; j++) {\n\t\t\texp_reg = mt9m114_exp_win[i][j];\n\n\t\t\tret = mt9m114_write_reg(client, exp_reg.length,\n\t\t\t\t\t\texp_reg.reg, exp_reg.val);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&client->dev, \"write exp_reg err.\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mt9m114_s_ev(struct v4l2_subdev *sd, s32 val)\n{\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\ts32 luma = 0x37;\n\tint err;\n\n\t \n\tif (val < -2 || val > 2)\n\t\treturn -EINVAL;\n\tluma += 0x10 * val;\n\tdev_dbg(&c->dev, \"%s val:%d luma:0x%x\\n\", __func__, val, luma);\n\terr = mt9m114_write_reg(c, MISENSOR_16BIT, 0x098E, 0xC87A);\n\tif (err) {\n\t\tdev_err(&c->dev, \"%s logic addr access error\\n\", __func__);\n\t\treturn err;\n\t}\n\terr = mt9m114_write_reg(c, MISENSOR_8BIT, 0xC87A, (u32)luma);\n\tif (err) {\n\t\tdev_err(&c->dev, \"%s write target_average_luma failed\\n\",\n\t\t\t__func__);\n\t\treturn err;\n\t}\n\tudelay(10);\n\n\treturn 0;\n}\n\nstatic int mt9m114_g_ev(struct v4l2_subdev *sd, s32 *val)\n{\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\tint err;\n\tu32 luma;\n\n\terr = mt9m114_write_reg(c, MISENSOR_16BIT, 0x098E, 0xC87A);\n\tif (err) {\n\t\tdev_err(&c->dev, \"%s logic addr access error\\n\", __func__);\n\t\treturn err;\n\t}\n\terr = mt9m114_read_reg(c, MISENSOR_8BIT, 0xC87A, &luma);\n\tif (err) {\n\t\tdev_err(&c->dev, \"%s read target_average_luma failed\\n\",\n\t\t\t__func__);\n\t\treturn err;\n\t}\n\tluma -= 0x17;\n\tluma /= 0x10;\n\t*val = (s32)luma - 2;\n\tdev_dbg(&c->dev, \"%s val:%d\\n\", __func__, *val);\n\n\treturn 0;\n}\n\n \nstatic int mt9m114_s_3a_lock(struct v4l2_subdev *sd, s32 val)\n{\n\taaalock = val;\n\treturn 0;\n}\n\nstatic int mt9m114_g_3a_lock(struct v4l2_subdev *sd, s32 *val)\n{\n\tif (aaalock)\n\t\treturn V4L2_LOCK_EXPOSURE | V4L2_LOCK_WHITE_BALANCE\n\t\t       | V4L2_LOCK_FOCUS;\n\treturn 0;\n}\n\nstatic int mt9m114_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mt9m114_device *dev =\n\t    container_of(ctrl->handler, struct mt9m114_device, ctrl_handler);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&dev->sd);\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VFLIP:\n\t\tdev_dbg(&client->dev, \"%s: CID_VFLIP:%d.\\n\",\n\t\t\t__func__, ctrl->val);\n\t\tret = mt9m114_t_vflip(&dev->sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tdev_dbg(&client->dev, \"%s: CID_HFLIP:%d.\\n\",\n\t\t\t__func__, ctrl->val);\n\t\tret = mt9m114_t_hflip(&dev->sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_METERING:\n\t\tret = mt9m114_s_exposure_metering(&dev->sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\tret = mt9m114_s_ev(&dev->sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_3A_LOCK:\n\t\tret = mt9m114_s_3a_lock(&dev->sd, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int mt9m114_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mt9m114_device *dev =\n\t    container_of(ctrl->handler, struct mt9m114_device, ctrl_handler);\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VFLIP:\n\t\tret = mt9m114_g_vflip(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tret = mt9m114_g_hflip(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_ABSOLUTE:\n\t\tret = mt9m114_g_exposure(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_ZONE_NUM:\n\t\tret = mt9m114_g_exposure_zone_num(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\tret = mt9m114_g_ev(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_3A_LOCK:\n\t\tret = mt9m114_g_3a_lock(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ctrl_ops = {\n\t.s_ctrl = mt9m114_s_ctrl,\n\t.g_volatile_ctrl = mt9m114_g_volatile_ctrl\n};\n\nstatic struct v4l2_ctrl_config mt9m114_controls[] = {\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_VFLIP,\n\t\t.name = \"Image v-Flip\",\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.min = 0,\n\t\t.max = 1,\n\t\t.step = 1,\n\t\t.def = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_HFLIP,\n\t\t.name = \"Image h-Flip\",\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.min = 0,\n\t\t.max = 1,\n\t\t.step = 1,\n\t\t.def = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_EXPOSURE_ABSOLUTE,\n\t\t.name = \"exposure\",\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.min = 0,\n\t\t.max = 0xffff,\n\t\t.step = 1,\n\t\t.def = 0,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_EXPOSURE_ZONE_NUM,\n\t\t.name = \"one-time exposure zone number\",\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.min = 0,\n\t\t.max = 0xffff,\n\t\t.step = 1,\n\t\t.def = 0,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_EXPOSURE_METERING,\n\t\t.name = \"metering\",\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.min = 0,\n\t\t.max = 3,\n\t\t.step = 0,\n\t\t.def = 1,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_EXPOSURE,\n\t\t.name = \"exposure biasx\",\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.min = -2,\n\t\t.max = 2,\n\t\t.step = 1,\n\t\t.def = 0,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_3A_LOCK,\n\t\t.name = \"3a lock\",\n\t\t.type = V4L2_CTRL_TYPE_BITMASK,\n\t\t.min = 0,\n\t\t.max = V4L2_LOCK_EXPOSURE | V4L2_LOCK_WHITE_BALANCE | V4L2_LOCK_FOCUS,\n\t\t.step = 1,\n\t\t.def = 0,\n\t\t.flags = 0,\n\t},\n};\n\nstatic int mt9m114_detect(struct mt9m114_device *dev, struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tu32 model;\n\tint ret;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"%s: i2c error\", __func__);\n\t\treturn -ENODEV;\n\t}\n\tret = mt9m114_read_reg(client, MISENSOR_16BIT, MT9M114_PID, &model);\n\tif (ret)\n\t\treturn ret;\n\tdev->real_model_id = model;\n\n\tif (model != MT9M114_MOD_ID) {\n\t\tdev_err(&client->dev, \"%s: failed: client->addr = %x\\n\",\n\t\t\t__func__, client->addr);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmt9m114_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)\n{\n\tstruct mt9m114_device *dev = to_mt9m114_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tif (!platform_data)\n\t\treturn -ENODEV;\n\n\tdev->platform_data =\n\t    (struct camera_sensor_platform_data *)platform_data;\n\n\tret = power_up(sd);\n\tif (ret) {\n\t\tv4l2_err(client, \"mt9m114 power-up err\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = mt9m114_detect(dev, client);\n\tif (ret) {\n\t\tv4l2_err(client, \"mt9m114_detect err s_config.\\n\");\n\t\tgoto fail_detect;\n\t}\n\n\tret = dev->platform_data->csi_cfg(sd, 1);\n\tif (ret)\n\t\tgoto fail_csi_cfg;\n\n\tret = mt9m114_set_suspend(sd);\n\tif (ret) {\n\t\tv4l2_err(client, \"mt9m114 suspend err\");\n\t\treturn ret;\n\t}\n\n\tret = power_down(sd);\n\tif (ret) {\n\t\tv4l2_err(client, \"mt9m114 power down err\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n\nfail_csi_cfg:\n\tdev->platform_data->csi_cfg(sd, 0);\nfail_detect:\n\tpower_down(sd);\n\tdev_err(&client->dev, \"sensor power-gating failed\\n\");\n\treturn ret;\n}\n\n \nstatic int mt9m114_t_hflip(struct v4l2_subdev *sd, int value)\n{\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\tstruct mt9m114_device *dev = to_mt9m114_sensor(sd);\n\tint err;\n\t \n\terr = mt9m114_write_reg(c, MISENSOR_16BIT, 0x098E, 0xC850);\n\tif (value) {\n\t\t \n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x01, 0x01);\n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x01, 0x01);\n\t\t \n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x01, 0x01);\n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x01, 0x01);\n\n\t\terr += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,\n\t\t\t\t\tMISENSOR_HFLIP_MASK, MISENSOR_FLIP_EN);\n\n\t\tdev->bpat = MT9M114_BPAT_GRGRBGBG;\n\t} else {\n\t\t \n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x01, 0x00);\n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x01, 0x00);\n\t\t \n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x01, 0x00);\n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x01, 0x00);\n\n\t\terr += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,\n\t\t\t\t\tMISENSOR_HFLIP_MASK, MISENSOR_FLIP_DIS);\n\n\t\tdev->bpat = MT9M114_BPAT_BGBGGRGR;\n\t}\n\n\terr += mt9m114_write_reg(c, MISENSOR_8BIT, 0x8404, 0x06);\n\tudelay(10);\n\n\treturn !!err;\n}\n\n \nstatic int mt9m114_t_vflip(struct v4l2_subdev *sd, int value)\n{\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\tint err;\n\t \n\terr = mt9m114_write_reg(c, MISENSOR_16BIT, 0x098E, 0xC850);\n\tif (value >= 1) {\n\t\t \n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x02, 0x01);\n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x02, 0x01);\n\t\t \n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x02, 0x01);\n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x02, 0x01);\n\n\t\terr += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,\n\t\t\t\t\tMISENSOR_VFLIP_MASK, MISENSOR_FLIP_EN);\n\t} else {\n\t\t \n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x02, 0x00);\n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x02, 0x00);\n\t\t \n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x02, 0x00);\n\t\terr += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x02, 0x00);\n\n\t\terr += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,\n\t\t\t\t\tMISENSOR_VFLIP_MASK, MISENSOR_FLIP_DIS);\n\t}\n\n\terr += mt9m114_write_reg(c, MISENSOR_8BIT, 0x8404, 0x06);\n\tudelay(10);\n\n\treturn !!err;\n}\n\nstatic int mt9m114_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_frame_interval *interval)\n{\n\tstruct mt9m114_device *dev = to_mt9m114_sensor(sd);\n\n\tinterval->interval.numerator = 1;\n\tinterval->interval.denominator = mt9m114_res[dev->res].fps;\n\n\treturn 0;\n}\n\nstatic int mt9m114_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tint ret;\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\tstruct mt9m114_device *dev = to_mt9m114_sensor(sd);\n\tstruct atomisp_exposure exposure;\n\n\tif (enable) {\n\t\tret = mt9m114_write_reg_array(c, mt9m114_chgstat_reg,\n\t\t\t\t\t      POST_POLLING);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (dev->first_exp > MT9M114_MAX_FIRST_EXP) {\n\t\t\texposure.integration_time[0] = dev->first_exp;\n\t\t\texposure.gain[0] = dev->first_gain;\n\t\t\texposure.gain[1] = dev->first_diggain;\n\t\t\tmt9m114_s_exposure(sd, &exposure);\n\t\t}\n\t\tdev->streamon = 1;\n\n\t} else {\n\t\tdev->streamon = 0;\n\t\tret = mt9m114_set_suspend(sd);\n\t}\n\n\treturn ret;\n}\n\nstatic int mt9m114_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index)\n\t\treturn -EINVAL;\n\tcode->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\n\treturn 0;\n}\n\nstatic int mt9m114_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tunsigned int index = fse->index;\n\n\tif (index >= N_RES)\n\t\treturn -EINVAL;\n\n\tfse->min_width = mt9m114_res[index].width;\n\tfse->min_height = mt9m114_res[index].height;\n\tfse->max_width = mt9m114_res[index].width;\n\tfse->max_height = mt9m114_res[index].height;\n\n\treturn 0;\n}\n\nstatic int mt9m114_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)\n{\n\tint index;\n\tstruct mt9m114_device *snr = to_mt9m114_sensor(sd);\n\n\tif (!frames)\n\t\treturn -EINVAL;\n\n\tfor (index = 0; index < N_RES; index++) {\n\t\tif (mt9m114_res[index].res == snr->res)\n\t\t\tbreak;\n\t}\n\n\tif (index >= N_RES)\n\t\treturn -EINVAL;\n\n\t*frames = mt9m114_res[index].skip_frames;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops mt9m114_video_ops = {\n\t.s_stream = mt9m114_s_stream,\n\t.g_frame_interval = mt9m114_g_frame_interval,\n};\n\nstatic const struct v4l2_subdev_sensor_ops mt9m114_sensor_ops = {\n\t.g_skip_frames\t= mt9m114_g_skip_frames,\n};\n\nstatic const struct v4l2_subdev_core_ops mt9m114_core_ops = {\n\t.s_power = mt9m114_s_power,\n\t.ioctl = mt9m114_ioctl,\n};\n\n \nstatic const struct v4l2_subdev_pad_ops mt9m114_pad_ops = {\n\t.enum_mbus_code = mt9m114_enum_mbus_code,\n\t.enum_frame_size = mt9m114_enum_frame_size,\n\t.get_fmt = mt9m114_get_fmt,\n\t.set_fmt = mt9m114_set_fmt,\n\t.set_selection = mt9m114_s_exposure_selection,\n};\n\nstatic const struct v4l2_subdev_ops mt9m114_ops = {\n\t.core = &mt9m114_core_ops,\n\t.video = &mt9m114_video_ops,\n\t.pad = &mt9m114_pad_ops,\n\t.sensor = &mt9m114_sensor_ops,\n};\n\nstatic void mt9m114_remove(struct i2c_client *client)\n{\n\tstruct mt9m114_device *dev;\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\tdev = container_of(sd, struct mt9m114_device, sd);\n\tdev->platform_data->csi_cfg(sd, 0);\n\tv4l2_device_unregister_subdev(sd);\n\tmedia_entity_cleanup(&dev->sd.entity);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tkfree(dev);\n}\n\nstatic int mt9m114_probe(struct i2c_client *client)\n{\n\tstruct mt9m114_device *dev;\n\tint ret = 0;\n\tunsigned int i;\n\tvoid *pdata;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tv4l2_i2c_subdev_init(&dev->sd, client, &mt9m114_ops);\n\tpdata = gmin_camera_platform_data(&dev->sd,\n\t\t\t\t\t  ATOMISP_INPUT_FORMAT_RAW_10,\n\t\t\t\t\t  atomisp_bayer_order_grbg);\n\tif (pdata)\n\t\tret = mt9m114_s_config(&dev->sd, client->irq, pdata);\n\tif (!pdata || ret) {\n\t\tv4l2_device_unregister_subdev(&dev->sd);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\n\tret = atomisp_register_i2c_module(&dev->sd, pdata, RAW_CAMERA);\n\tif (ret) {\n\t\tv4l2_device_unregister_subdev(&dev->sd);\n\t\tkfree(dev);\n\t\t \n\t\treturn ret;\n\t}\n\n\t \n\tdev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tdev->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tdev->format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\tdev->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\tret =\n\t    v4l2_ctrl_handler_init(&dev->ctrl_handler,\n\t\t\t\t   ARRAY_SIZE(mt9m114_controls));\n\tif (ret) {\n\t\tmt9m114_remove(client);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mt9m114_controls); i++)\n\t\tv4l2_ctrl_new_custom(&dev->ctrl_handler, &mt9m114_controls[i],\n\t\t\t\t     NULL);\n\n\tif (dev->ctrl_handler.error) {\n\t\tmt9m114_remove(client);\n\t\treturn dev->ctrl_handler.error;\n\t}\n\n\t \n\tdev->ctrl_handler.lock = &dev->input_lock;\n\tdev->sd.ctrl_handler = &dev->ctrl_handler;\n\n\t \n\tret = media_entity_pads_init(&dev->sd.entity, 1, &dev->pad);\n\tif (ret) {\n\t\tmt9m114_remove(client);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic const struct acpi_device_id mt9m114_acpi_match[] = {\n\t{ \"INT33F0\" },\n\t{ \"CRMT1040\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, mt9m114_acpi_match);\n\nstatic struct i2c_driver mt9m114_driver = {\n\t.driver = {\n\t\t.name = \"mt9m114\",\n\t\t.acpi_match_table = mt9m114_acpi_match,\n\t},\n\t.probe = mt9m114_probe,\n\t.remove = mt9m114_remove,\n};\nmodule_i2c_driver(mt9m114_driver);\n\nMODULE_AUTHOR(\"Shuguang Gong <Shuguang.gong@intel.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}