{
  "module_name": "atomisp-ov5693.c",
  "hash_id": "b6286d89ce142a79d23e964ed68914fcd2902fea66986dcafe617554c44702d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/i2c/ov5693/atomisp-ov5693.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/moduleparam.h>\n#include <media/v4l2-device.h>\n#include <linux/io.h>\n#include <linux/acpi.h>\n#include \"../../include/linux/atomisp_gmin_platform.h\"\n\n#include \"ov5693.h\"\n#include \"ad5823.h\"\n\n#define __cci_delay(t) \\\n\tdo { \\\n\t\tif ((t) < 10) { \\\n\t\t\tusleep_range((t) * 1000, ((t) + 1) * 1000); \\\n\t\t} else { \\\n\t\t\tmsleep((t)); \\\n\t\t} \\\n\t} while (0)\n\n \nstatic uint up_delay = 30;\nmodule_param(up_delay, uint, 0644);\nMODULE_PARM_DESC(up_delay,\n\t\t \"Delay prior to the first CCI transaction for ov5693\");\n\nstatic int vcm_ad_i2c_wr8(struct i2c_client *client, u8 reg, u8 val)\n{\n\tint err;\n\tstruct i2c_msg msg;\n\tu8 buf[2];\n\n\tbuf[0] = reg;\n\tbuf[1] = val;\n\n\tmsg.addr = VCM_ADDR;\n\tmsg.flags = 0;\n\tmsg.len = 2;\n\tmsg.buf = &buf[0];\n\n\terr = i2c_transfer(client->adapter, &msg, 1);\n\tif (err != 1) {\n\t\tdev_err(&client->dev, \"%s: vcm i2c fail, err code = %d\\n\",\n\t\t\t__func__, err);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int ad5823_i2c_write(struct i2c_client *client, u8 reg, u8 val)\n{\n\tstruct i2c_msg msg;\n\tu8 buf[2];\n\n\tbuf[0] = reg;\n\tbuf[1] = val;\n\tmsg.addr = AD5823_VCM_ADDR;\n\tmsg.flags = 0;\n\tmsg.len = 0x02;\n\tmsg.buf = &buf[0];\n\n\tif (i2c_transfer(client->adapter, &msg, 1) != 1)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int ad5823_i2c_read(struct i2c_client *client, u8 reg, u8 *val)\n{\n\tstruct i2c_msg msg[2];\n\tu8 buf[2];\n\n\tbuf[0] = reg;\n\tbuf[1] = 0;\n\n\tmsg[0].addr = AD5823_VCM_ADDR;\n\tmsg[0].flags = 0;\n\tmsg[0].len = 0x01;\n\tmsg[0].buf = &buf[0];\n\n\tmsg[1].addr = 0x0c;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].len = 0x01;\n\tmsg[1].buf = &buf[1];\n\t*val = 0;\n\tif (i2c_transfer(client->adapter, msg, 2) != 2)\n\t\treturn -EIO;\n\t*val = buf[1];\n\treturn 0;\n}\n\nstatic const u32 ov5693_embedded_effective_size = 28;\n\n \nstatic int ov5693_read_reg(struct i2c_client *client,\n\t\t\t   u16 data_length, u16 reg, u16 *val)\n{\n\tint err;\n\tstruct i2c_msg msg[2];\n\tunsigned char data[6];\n\n\tif (!client->adapter) {\n\t\tdev_err(&client->dev, \"%s error, no client->adapter\\n\",\n\t\t\t__func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (data_length != OV5693_8BIT && data_length != OV5693_16BIT\n\t    && data_length != OV5693_32BIT) {\n\t\tdev_err(&client->dev, \"%s error, invalid data length\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(msg, 0, sizeof(msg));\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = 0;\n\tmsg[0].len = I2C_MSG_LENGTH;\n\tmsg[0].buf = data;\n\n\t \n\tdata[0] = (u8)(reg >> 8);\n\tdata[1] = (u8)(reg & 0xff);\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].len = data_length;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].buf = data;\n\n\terr = i2c_transfer(client->adapter, msg, 2);\n\tif (err != 2) {\n\t\tif (err >= 0)\n\t\t\terr = -EIO;\n\t\tdev_err(&client->dev,\n\t\t\t\"read from offset 0x%x error %d\", reg, err);\n\t\treturn err;\n\t}\n\n\t*val = 0;\n\t \n\tif (data_length == OV5693_8BIT)\n\t\t*val = (u8)data[0];\n\telse if (data_length == OV5693_16BIT)\n\t\t*val = be16_to_cpu(*(__be16 *)&data[0]);\n\telse\n\t\t*val = be32_to_cpu(*(__be32 *)&data[0]);\n\n\treturn 0;\n}\n\nstatic int ov5693_i2c_write(struct i2c_client *client, u16 len, u8 *data)\n{\n\tstruct i2c_msg msg;\n\tconst int num_msg = 1;\n\tint ret;\n\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\tmsg.len = len;\n\tmsg.buf = data;\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\n\treturn ret == num_msg ? 0 : -EIO;\n}\n\nstatic int vcm_dw_i2c_write(struct i2c_client *client, u16 data)\n{\n\tstruct i2c_msg msg;\n\tconst int num_msg = 1;\n\tint ret;\n\t__be16 val;\n\n\tval = cpu_to_be16(data);\n\tmsg.addr = VCM_ADDR;\n\tmsg.flags = 0;\n\tmsg.len = OV5693_16BIT;\n\tmsg.buf = (void *)&val;\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\n\treturn ret == num_msg ? 0 : -EIO;\n}\n\n \nstatic int vcm_detect(struct i2c_client *client)\n{\n\tint i, ret;\n\tstruct i2c_msg msg;\n\tu16 data0 = 0, data;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tmsg.addr = VCM_ADDR;\n\t\tmsg.flags = I2C_M_RD;\n\t\tmsg.len = sizeof(data);\n\t\tmsg.buf = (u8 *)&data;\n\t\tret = i2c_transfer(client->adapter, &msg, 1);\n\n\t\t \n\t\tif (i == 0 && ret == -EREMOTEIO) {\n\t\t\tdata0 = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i == 0)\n\t\t\tdata0 = data;\n\n\t\tif (data != data0)\n\t\t\treturn VCM_AD5823;\n\t}\n\treturn ret == 1 ? VCM_DW9714 : ret;\n}\n\nstatic int ov5693_write_reg(struct i2c_client *client, u16 data_length,\n\t\t\t    u16 reg, u16 val)\n{\n\tint ret;\n\tunsigned char data[4] = {0};\n\t__be16 *wreg = (void *)data;\n\tconst u16 len = data_length + sizeof(u16);  \n\n\tif (data_length != OV5693_8BIT && data_length != OV5693_16BIT) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s error, invalid data_length\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t*wreg = cpu_to_be16(reg);\n\n\tif (data_length == OV5693_8BIT) {\n\t\tdata[2] = (u8)(val);\n\t} else {\n\t\t \n\t\t__be16 *wdata = (void *)&data[2];\n\n\t\t*wdata = cpu_to_be16(val);\n\t}\n\n\tret = ov5693_i2c_write(client, len, data);\n\tif (ret)\n\t\tdev_err(&client->dev,\n\t\t\t\"write error: wrote 0x%x to offset 0x%x error %d\",\n\t\t\tval, reg, ret);\n\n\treturn ret;\n}\n\n \n\nstatic int __ov5693_flush_reg_array(struct i2c_client *client,\n\t\t\t\t    struct ov5693_write_ctrl *ctrl)\n{\n\tu16 size;\n\t__be16 *reg = (void *)&ctrl->buffer.addr;\n\n\tif (ctrl->index == 0)\n\t\treturn 0;\n\n\tsize = sizeof(u16) + ctrl->index;  \n\n\t*reg = cpu_to_be16(ctrl->buffer.addr);\n\tctrl->index = 0;\n\n\treturn ov5693_i2c_write(client, size, (u8 *)reg);\n}\n\nstatic int __ov5693_buf_reg_array(struct i2c_client *client,\n\t\t\t\t  struct ov5693_write_ctrl *ctrl,\n\t\t\t\t  const struct ov5693_reg *next)\n{\n\tint size;\n\t__be16 *data16;\n\n\tswitch (next->type) {\n\tcase OV5693_8BIT:\n\t\tsize = 1;\n\t\tctrl->buffer.data[ctrl->index] = (u8)next->val;\n\t\tbreak;\n\tcase OV5693_16BIT:\n\t\tsize = 2;\n\n\t\tdata16 = (void *)&ctrl->buffer.data[ctrl->index];\n\t\t*data16 = cpu_to_be16((u16)next->val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ctrl->index == 0)\n\t\tctrl->buffer.addr = next->reg;\n\n\tctrl->index += size;\n\n\t \n\tif (ctrl->index + sizeof(u16) >= OV5693_MAX_WRITE_BUF_SIZE)\n\t\treturn __ov5693_flush_reg_array(client, ctrl);\n\n\treturn 0;\n}\n\nstatic int __ov5693_write_reg_is_consecutive(struct i2c_client *client,\n\tstruct ov5693_write_ctrl *ctrl,\n\tconst struct ov5693_reg *next)\n{\n\tif (ctrl->index == 0)\n\t\treturn 1;\n\n\treturn ctrl->buffer.addr + ctrl->index == next->reg;\n}\n\nstatic int ov5693_write_reg_array(struct i2c_client *client,\n\t\t\t\t  const struct ov5693_reg *reglist)\n{\n\tconst struct ov5693_reg *next = reglist;\n\tstruct ov5693_write_ctrl ctrl;\n\tint err;\n\n\tctrl.index = 0;\n\tfor (; next->type != OV5693_TOK_TERM; next++) {\n\t\tswitch (next->type & OV5693_TOK_MASK) {\n\t\tcase OV5693_TOK_DELAY:\n\t\t\terr = __ov5693_flush_reg_array(client, &ctrl);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tmsleep(next->val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tif (!__ov5693_write_reg_is_consecutive(client, &ctrl,\n\t\t\t\t\t\t\t       next)) {\n\t\t\t\terr = __ov5693_flush_reg_array(client, &ctrl);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\terr = __ov5693_buf_reg_array(client, &ctrl, next);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"%s: write error, aborted\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn __ov5693_flush_reg_array(client, &ctrl);\n}\n\nstatic long __ov5693_set_exposure(struct v4l2_subdev *sd, int coarse_itg,\n\t\t\t\t  int gain, int digitgain)\n\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\tu16 vts, hts;\n\tint ret, exp_val;\n\n\thts = ov5693_res[dev->fmt_idx].pixels_per_line;\n\tvts = ov5693_res[dev->fmt_idx].lines_per_frame;\n\t \n\tif (coarse_itg > (1 << 15)) {\n\t\thts = hts * 2;\n\t\tcoarse_itg = (int)coarse_itg / 2;\n\t}\n\t \n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_GROUP_ACCESS, 0x00);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: write %x error, aborted\\n\",\n\t\t\t__func__, OV5693_GROUP_ACCESS);\n\t\treturn ret;\n\t}\n\n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_TIMING_HTS_H, (hts >> 8) & 0xFF);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: write %x error, aborted\\n\",\n\t\t\t__func__, OV5693_TIMING_HTS_H);\n\t\treturn ret;\n\t}\n\n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_TIMING_HTS_L, hts & 0xFF);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: write %x error, aborted\\n\",\n\t\t\t__func__, OV5693_TIMING_HTS_L);\n\t\treturn ret;\n\t}\n\t \n\tif (coarse_itg > vts - OV5693_INTEGRATION_TIME_MARGIN)\n\t\tvts = (u16)coarse_itg + OV5693_INTEGRATION_TIME_MARGIN;\n\n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_TIMING_VTS_H, (vts >> 8) & 0xFF);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: write %x error, aborted\\n\",\n\t\t\t__func__, OV5693_TIMING_VTS_H);\n\t\treturn ret;\n\t}\n\n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_TIMING_VTS_L, vts & 0xFF);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: write %x error, aborted\\n\",\n\t\t\t__func__, OV5693_TIMING_VTS_L);\n\t\treturn ret;\n\t}\n\n\t \n\n\t \n\texp_val = coarse_itg << 4;\n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_EXPOSURE_L, exp_val & 0xFF);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: write %x error, aborted\\n\",\n\t\t\t__func__, OV5693_EXPOSURE_L);\n\t\treturn ret;\n\t}\n\n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_EXPOSURE_M, (exp_val >> 8) & 0xFF);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: write %x error, aborted\\n\",\n\t\t\t__func__, OV5693_EXPOSURE_M);\n\t\treturn ret;\n\t}\n\n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_EXPOSURE_H, (exp_val >> 16) & 0x0F);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: write %x error, aborted\\n\",\n\t\t\t__func__, OV5693_EXPOSURE_H);\n\t\treturn ret;\n\t}\n\n\t \n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_AGC_L, gain & 0xff);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: write %x error, aborted\\n\",\n\t\t\t__func__, OV5693_AGC_L);\n\t\treturn ret;\n\t}\n\n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_AGC_H, (gain >> 8) & 0xff);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: write %x error, aborted\\n\",\n\t\t\t__func__, OV5693_AGC_H);\n\t\treturn ret;\n\t}\n\n\t \n\tif (digitgain) {\n\t\tret = ov5693_write_reg(client, OV5693_16BIT,\n\t\t\t\t       OV5693_MWB_RED_GAIN_H, digitgain);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"%s: write %x error, aborted\\n\",\n\t\t\t\t__func__, OV5693_MWB_RED_GAIN_H);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ov5693_write_reg(client, OV5693_16BIT,\n\t\t\t\t       OV5693_MWB_GREEN_GAIN_H, digitgain);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"%s: write %x error, aborted\\n\",\n\t\t\t\t__func__, OV5693_MWB_RED_GAIN_H);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ov5693_write_reg(client, OV5693_16BIT,\n\t\t\t\t       OV5693_MWB_BLUE_GAIN_H, digitgain);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"%s: write %x error, aborted\\n\",\n\t\t\t\t__func__, OV5693_MWB_RED_GAIN_H);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_GROUP_ACCESS, 0x10);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_GROUP_ACCESS, 0xa0);\n\tif (ret)\n\t\treturn ret;\n\treturn ret;\n}\n\nstatic int ov5693_set_exposure(struct v4l2_subdev *sd, int exposure,\n\t\t\t       int gain, int digitgain)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\tint ret;\n\n\tmutex_lock(&dev->input_lock);\n\tret = __ov5693_set_exposure(sd, exposure, gain, digitgain);\n\tmutex_unlock(&dev->input_lock);\n\n\treturn ret;\n}\n\nstatic long ov5693_s_exposure(struct v4l2_subdev *sd,\n\t\t\t      struct atomisp_exposure *exposure)\n{\n\tu16 coarse_itg = exposure->integration_time[0];\n\tu16 analog_gain = exposure->gain[0];\n\tu16 digital_gain = exposure->gain[1];\n\n\t \n\tif (analog_gain == 0) {\n\t\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\t\tv4l2_err(client, \"%s: invalid value\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\treturn ov5693_set_exposure(sd, coarse_itg, analog_gain, digital_gain);\n}\n\nstatic int ov5693_read_otp_reg_array(struct i2c_client *client, u16 size,\n\t\t\t\t     u16 addr, u8 *buf)\n{\n\tu16 index;\n\tint ret;\n\tu16 *pVal = NULL;\n\n\tfor (index = 0; index <= size; index++) {\n\t\tpVal = (u16 *)(buf + index);\n\t\tret =\n\t\t    ov5693_read_reg(client, OV5693_8BIT, addr + index,\n\t\t\t\t    pVal);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __ov5693_otp_read(struct v4l2_subdev *sd, u8 *buf)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\tint ret;\n\tint i;\n\tu8 *b = buf;\n\n\tdev->otp_size = 0;\n\tfor (i = 1; i < OV5693_OTP_BANK_MAX; i++) {\n\t\t \n\t\tret = ov5693_write_reg(client, OV5693_8BIT, OV5693_OTP_BANK_REG,\n\t\t\t\t       (i | 0xc0));\t \n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"failed to prepare OTP page\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t\n\n\t\t \n\t\tret = ov5693_write_reg(client, OV5693_8BIT, OV5693_OTP_READ_REG,\n\t\t\t\t       OV5693_OTP_MODE_READ);\t\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to set OTP reading mode page\");\n\t\t\treturn ret;\n\t\t}\n\t\t\n\n\t\t \n\t\tret = ov5693_read_otp_reg_array(client, OV5693_OTP_BANK_SIZE,\n\t\t\t\t\t\tOV5693_OTP_START_ADDR,\n\t\t\t\t\t\tb);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"failed to read OTP data\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t\n\n\t\t\n\t\tif (i == 21) {\n\t\t\tif ((*b) == 0) {\n\t\t\t\tdev->otp_size = 320;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tb = buf;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (i ==\n\t\t\t   24) {\t\t\n\t\t\tif ((*b) == 0) {\n\t\t\t\tdev->otp_size = 32;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tb = buf;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (i ==\n\t\t\t   27) {\t\t\n\t\t\tif ((*b) == 0) {\n\t\t\t\tdev->otp_size = 32;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdev->otp_size = 0;\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tb = b + OV5693_OTP_BANK_SIZE;\n\t}\n\treturn 0;\n}\n\n \nstatic void *ov5693_otp_read(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu8 *buf;\n\tint ret;\n\n\tbuf = devm_kzalloc(&client->dev, (OV5693_OTP_DATA_SIZE + 16), GFP_KERNEL);\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t\n\tret = ov5693_write_reg(client, OV5693_8BIT, OV5693_FRAME_OFF_NUM, 0x00);\n\n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_SW_STREAM, OV5693_START_STREAMING);\n\n\tret = __ov5693_otp_read(sd, buf);\n\n\t\n\tret = ov5693_write_reg(client, OV5693_8BIT, OV5693_FRAME_OFF_NUM, 0x0f);\n\n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_SW_STREAM, OV5693_STOP_STREAMING);\n\n\t \n\tif (ret) {\n\t\tdev_err(&client->dev, \"sensor found no valid OTP data\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn buf;\n}\n\nstatic long ov5693_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase ATOMISP_IOC_S_EXPOSURE:\n\t\treturn ov5693_s_exposure(sd, arg);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int ov5693_q_exposure(struct v4l2_subdev *sd, s32 *value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu16 reg_v, reg_v2;\n\tint ret;\n\n\t \n\tret = ov5693_read_reg(client, OV5693_8BIT,\n\t\t\t      OV5693_EXPOSURE_L,\n\t\t\t      &reg_v);\n\tif (ret)\n\t\tgoto err;\n\n\tret = ov5693_read_reg(client, OV5693_8BIT,\n\t\t\t      OV5693_EXPOSURE_M,\n\t\t\t      &reg_v2);\n\tif (ret)\n\t\tgoto err;\n\n\treg_v += reg_v2 << 8;\n\tret = ov5693_read_reg(client, OV5693_8BIT,\n\t\t\t      OV5693_EXPOSURE_H,\n\t\t\t      &reg_v2);\n\tif (ret)\n\t\tgoto err;\n\n\t*value = reg_v + (((u32)reg_v2 << 16));\nerr:\n\treturn ret;\n}\n\nstatic int ad5823_t_focus_vcm(struct v4l2_subdev *sd, u16 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\tu8 vcm_code;\n\n\tret = ad5823_i2c_read(client, AD5823_REG_VCM_CODE_MSB, &vcm_code);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tvcm_code = (vcm_code & VCM_CODE_MSB_MASK) |\n\t\t   ((val >> 8) & ~VCM_CODE_MSB_MASK);\n\tret = ad5823_i2c_write(client, AD5823_REG_VCM_CODE_MSB, vcm_code);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ad5823_i2c_write(client, AD5823_REG_VCM_CODE_LSB, (val & 0xff));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tvcm_code = AD5823_RESONANCE_PERIOD / AD5823_RESONANCE_COEF\n\t\t   - AD5823_HIGH_FREQ_RANGE;\n\tret = ad5823_i2c_write(client, AD5823_REG_VCM_MOVE_TIME, vcm_code);\n\n\treturn ret;\n}\n\nstatic int ad5823_t_focus_abs(struct v4l2_subdev *sd, s32 value)\n{\n\tvalue = min(value, AD5823_MAX_FOCUS_POS);\n\treturn ad5823_t_focus_vcm(sd, value);\n}\n\nstatic int ov5693_t_focus_abs(struct v4l2_subdev *sd, s32 value)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tdev_dbg(&client->dev, \"%s: FOCUS_POS: 0x%x\\n\", __func__, value);\n\tvalue = clamp(value, 0, OV5693_VCM_MAX_FOCUS_POS);\n\tif (dev->vcm == VCM_DW9714) {\n\t\tif (dev->vcm_update) {\n\t\t\tret = vcm_dw_i2c_write(client, VCM_PROTECTION_OFF);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = vcm_dw_i2c_write(client, DIRECT_VCM);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = vcm_dw_i2c_write(client, VCM_PROTECTION_ON);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdev->vcm_update = false;\n\t\t}\n\t\tret = vcm_dw_i2c_write(client,\n\t\t\t\t       vcm_val(value, VCM_DEFAULT_S));\n\t} else if (dev->vcm == VCM_AD5823) {\n\t\tad5823_t_focus_abs(sd, value);\n\t}\n\tif (ret == 0) {\n\t\tdev->number_of_steps = value - dev->focus;\n\t\tdev->focus = value;\n\t\tdev->timestamp_t_focus_abs = ktime_get();\n\t} else\n\t\tdev_err(&client->dev,\n\t\t\t\"%s: i2c failed. ret %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic int ov5693_t_focus_rel(struct v4l2_subdev *sd, s32 value)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\n\treturn ov5693_t_focus_abs(sd, dev->focus + value);\n}\n\n#define DELAY_PER_STEP_NS\t1000000\n#define DELAY_MAX_PER_STEP_NS\t(1000000 * 1023)\nstatic int ov5693_q_focus_status(struct v4l2_subdev *sd, s32 *value)\n{\n\tu32 status = 0;\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\tktime_t temptime;\n\tktime_t timedelay = ns_to_ktime(min_t(u32,\n\t\t\t\t\t      abs(dev->number_of_steps) * DELAY_PER_STEP_NS,\n\t\t\t\t\t      DELAY_MAX_PER_STEP_NS));\n\n\ttemptime = ktime_sub(ktime_get(), (dev->timestamp_t_focus_abs));\n\tif (ktime_compare(temptime, timedelay) <= 0) {\n\t\tstatus |= ATOMISP_FOCUS_STATUS_MOVING;\n\t\tstatus |= ATOMISP_FOCUS_HP_IN_PROGRESS;\n\t} else {\n\t\tstatus |= ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE;\n\t\tstatus |= ATOMISP_FOCUS_HP_COMPLETE;\n\t}\n\n\t*value = status;\n\n\treturn 0;\n}\n\nstatic int ov5693_q_focus_abs(struct v4l2_subdev *sd, s32 *value)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\ts32 val;\n\n\tov5693_q_focus_status(sd, &val);\n\n\tif (val & ATOMISP_FOCUS_STATUS_MOVING)\n\t\t*value  = dev->focus - dev->number_of_steps;\n\telse\n\t\t*value  = dev->focus;\n\n\treturn 0;\n}\n\nstatic int ov5693_t_vcm_slew(struct v4l2_subdev *sd, s32 value)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\n\tdev->number_of_steps = value;\n\tdev->vcm_update = true;\n\treturn 0;\n}\n\nstatic int ov5693_t_vcm_timing(struct v4l2_subdev *sd, s32 value)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\n\tdev->number_of_steps = value;\n\tdev->vcm_update = true;\n\treturn 0;\n}\n\nstatic int ov5693_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov5693_device *dev =\n\t    container_of(ctrl->handler, struct ov5693_device, ctrl_handler);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&dev->sd);\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_FOCUS_ABSOLUTE:\n\t\tdev_dbg(&client->dev, \"%s: CID_FOCUS_ABSOLUTE:%d.\\n\",\n\t\t\t__func__, ctrl->val);\n\t\tret = ov5693_t_focus_abs(&dev->sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FOCUS_RELATIVE:\n\t\tdev_dbg(&client->dev, \"%s: CID_FOCUS_RELATIVE:%d.\\n\",\n\t\t\t__func__, ctrl->val);\n\t\tret = ov5693_t_focus_rel(&dev->sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VCM_SLEW:\n\t\tret = ov5693_t_vcm_slew(&dev->sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VCM_TIMING:\n\t\tret = ov5693_t_vcm_timing(&dev->sd, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int ov5693_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov5693_device *dev =\n\t    container_of(ctrl->handler, struct ov5693_device, ctrl_handler);\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE_ABSOLUTE:\n\t\tret = ov5693_q_exposure(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FOCUS_ABSOLUTE:\n\t\tret = ov5693_q_focus_abs(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FOCUS_STATUS:\n\t\tret = ov5693_q_focus_status(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ctrl_ops = {\n\t.s_ctrl = ov5693_s_ctrl,\n\t.g_volatile_ctrl = ov5693_g_volatile_ctrl\n};\n\nstatic const struct v4l2_ctrl_config ov5693_controls[] = {\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_EXPOSURE_ABSOLUTE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"exposure\",\n\t\t.min = 0x0,\n\t\t.max = 0xffff,\n\t\t.step = 0x01,\n\t\t.def = 0x00,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_FOCUS_ABSOLUTE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"focus move absolute\",\n\t\t.min = 0,\n\t\t.max = OV5693_VCM_MAX_FOCUS_POS,\n\t\t.step = 1,\n\t\t.def = 0,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_FOCUS_RELATIVE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"focus move relative\",\n\t\t.min = OV5693_VCM_MAX_FOCUS_NEG,\n\t\t.max = OV5693_VCM_MAX_FOCUS_POS,\n\t\t.step = 1,\n\t\t.def = 0,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_FOCUS_STATUS,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"focus status\",\n\t\t.min = 0,\n\t\t.max = 100,\t\t \n\t\t.step = 1,\n\t\t.def = 0,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_VCM_SLEW,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"vcm slew\",\n\t\t.min = 0,\n\t\t.max = OV5693_VCM_SLEW_STEP_MAX,\n\t\t.step = 1,\n\t\t.def = 0,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_VCM_TIMING,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"vcm step time\",\n\t\t.min = 0,\n\t\t.max = OV5693_VCM_SLEW_TIME_MAX,\n\t\t.step = 1,\n\t\t.def = 0,\n\t\t.flags = 0,\n\t},\n};\n\nstatic int ov5693_init(struct v4l2_subdev *sd)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tpr_info(\"%s\\n\", __func__);\n\tmutex_lock(&dev->input_lock);\n\tdev->vcm_update = false;\n\n\tif (dev->vcm == VCM_AD5823) {\n\t\tret = vcm_ad_i2c_wr8(client, 0x01, 0x01);  \n\t\tif (ret)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"vcm reset failed\\n\");\n\t\t \n\t\tret = ad5823_i2c_write(client, AD5823_REG_VCM_CODE_MSB,\n\t\t\t\t       AD5823_RING_CTRL_ENABLE);\n\t\tif (ret)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"vcm enable ringing failed\\n\");\n\t\tret = ad5823_i2c_write(client, AD5823_REG_MODE,\n\t\t\t\t       AD5823_ARC_RES1);\n\t\tif (ret)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"vcm change mode failed\\n\");\n\t}\n\n\t \n\tif (dev->vcm == VCM_AD5823) {\n\t\tdev->focus = AD5823_INIT_FOCUS_POS;\n\t\tov5693_t_focus_abs(sd, AD5823_INIT_FOCUS_POS);\n\t} else {\n\t\tdev->focus = 0;\n\t\tov5693_t_focus_abs(sd, 0);\n\t}\n\n\tmutex_unlock(&dev->input_lock);\n\n\treturn 0;\n}\n\nstatic int power_ctrl(struct v4l2_subdev *sd, bool flag)\n{\n\tint ret;\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\n\tif (!dev || !dev->platform_data)\n\t\treturn -ENODEV;\n\n\t \n\tif (flag) {\n\t\tret = dev->platform_data->v2p8_ctrl(sd, 1);\n\t\tdev->platform_data->gpio1_ctrl(sd, 1);\n\t\tif (ret == 0) {\n\t\t\tret = dev->platform_data->v1p8_ctrl(sd, 1);\n\t\t\tif (ret) {\n\t\t\t\tdev->platform_data->gpio1_ctrl(sd, 0);\n\t\t\t\tret = dev->platform_data->v2p8_ctrl(sd, 0);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev->platform_data->gpio1_ctrl(sd, 0);\n\t\tret = dev->platform_data->v1p8_ctrl(sd, 0);\n\t\tret |= dev->platform_data->v2p8_ctrl(sd, 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int gpio_ctrl(struct v4l2_subdev *sd, bool flag)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\n\tif (!dev || !dev->platform_data)\n\t\treturn -ENODEV;\n\n\treturn dev->platform_data->gpio0_ctrl(sd, flag);\n}\n\nstatic int __power_up(struct v4l2_subdev *sd)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tif (!dev->platform_data) {\n\t\tdev_err(&client->dev,\n\t\t\t\"no camera_sensor_platform_data\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = power_ctrl(sd, 1);\n\tif (ret)\n\t\tgoto fail_power;\n\n\t \n\t \n\tusleep_range(10000, 11000);\n\n\t \n\tret = gpio_ctrl(sd, 1);\n\tif (ret) {\n\t\tret = gpio_ctrl(sd, 1);\n\t\tif (ret)\n\t\t\tgoto fail_power;\n\t}\n\n\t \n\tret = dev->platform_data->flisclk_ctrl(sd, 1);\n\tif (ret)\n\t\tgoto fail_clk;\n\n\t__cci_delay(up_delay);\n\n\treturn 0;\n\nfail_clk:\n\tgpio_ctrl(sd, 0);\nfail_power:\n\tpower_ctrl(sd, 0);\n\tdev_err(&client->dev, \"sensor power-up failed\\n\");\n\n\treturn ret;\n}\n\nstatic int power_down(struct v4l2_subdev *sd)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tdev->focus = OV5693_INVALID_CONFIG;\n\tif (!dev->platform_data) {\n\t\tdev_err(&client->dev,\n\t\t\t\"no camera_sensor_platform_data\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = dev->platform_data->flisclk_ctrl(sd, 0);\n\tif (ret)\n\t\tdev_err(&client->dev, \"flisclk failed\\n\");\n\n\t \n\tret = gpio_ctrl(sd, 0);\n\tif (ret) {\n\t\tret = gpio_ctrl(sd, 0);\n\t\tif (ret)\n\t\t\tdev_err(&client->dev, \"gpio failed 2\\n\");\n\t}\n\n\t \n\tret = power_ctrl(sd, 0);\n\tif (ret)\n\t\tdev_err(&client->dev, \"vprog failed.\\n\");\n\n\treturn ret;\n}\n\nstatic int power_up(struct v4l2_subdev *sd)\n{\n\tstatic const int retry_count = 4;\n\tint i, ret;\n\n\tfor (i = 0; i < retry_count; i++) {\n\t\tret = __power_up(sd);\n\t\tif (!ret)\n\t\t\treturn 0;\n\n\t\tpower_down(sd);\n\t}\n\treturn ret;\n}\n\nstatic int ov5693_s_power(struct v4l2_subdev *sd, int on)\n{\n\tint ret;\n\n\tpr_info(\"%s: on %d\\n\", __func__, on);\n\tif (on == 0)\n\t\treturn power_down(sd);\n\telse {\n\t\tret = power_up(sd);\n\t\tif (!ret) {\n\t\t\tret = ov5693_init(sd);\n\t\t\t \n\t\t\tov5693_res = ov5693_res_preview;\n\t\t\tN_RES = N_RES_PREVIEW;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \n#define LARGEST_ALLOWED_RATIO_MISMATCH 1024\nstatic int distance(struct ov5693_resolution *res, u32 w, u32 h)\n{\n\tint ratio;\n\tint distance;\n\n\tif (w == 0 || h == 0 ||\n\t    res->width < w || res->height < h)\n\t\treturn -1;\n\n\tratio = res->width << 13;\n\tratio /= w;\n\tratio *= h;\n\tratio /= res->height;\n\n\tdistance = abs(ratio - 8192);\n\n\tif (distance > LARGEST_ALLOWED_RATIO_MISMATCH)\n\t\treturn -1;\n\n\treturn distance;\n}\n\n \nstatic int nearest_resolution_index(int w, int h)\n{\n\tint i;\n\tint idx = -1;\n\tint dist;\n\tint min_dist = INT_MAX;\n\tint min_res_w = INT_MAX;\n\tstruct ov5693_resolution *tmp_res = NULL;\n\n\tfor (i = 0; i < N_RES; i++) {\n\t\ttmp_res = &ov5693_res[i];\n\t\tdist = distance(tmp_res, w, h);\n\t\tif (dist == -1)\n\t\t\tcontinue;\n\t\tif (dist < min_dist) {\n\t\t\tmin_dist = dist;\n\t\t\tidx = i;\n\t\t\tmin_res_w = ov5693_res[i].width;\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist == min_dist && ov5693_res[i].width < min_res_w)\n\t\t\tidx = i;\n\t}\n\n\treturn idx;\n}\n\nstatic int get_resolution_index(int w, int h)\n{\n\tint i;\n\n\tfor (i = 0; i < N_RES; i++) {\n\t\tif (w != ov5693_res[i].width)\n\t\t\tcontinue;\n\t\tif (h != ov5693_res[i].height)\n\t\t\tcontinue;\n\n\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\n \nstatic int startup(struct v4l2_subdev *sd)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tret = ov5693_write_reg(client, OV5693_8BIT,\n\t\t\t       OV5693_SW_RESET, 0x01);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"ov5693 reset err.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov5693_write_reg_array(client, ov5693_global_setting);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"ov5693 write register err.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov5693_write_reg_array(client, ov5693_res[dev->fmt_idx].regs);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"ov5693 write register err.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int ov5693_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct camera_mipi_info *ov5693_info = NULL;\n\tint ret = 0;\n\tint idx;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\tif (!fmt)\n\t\treturn -EINVAL;\n\tov5693_info = v4l2_get_subdev_hostdata(sd);\n\tif (!ov5693_info)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->input_lock);\n\tidx = nearest_resolution_index(fmt->width, fmt->height);\n\tif (idx == -1) {\n\t\t \n\t\tfmt->width = ov5693_res[N_RES - 1].width;\n\t\tfmt->height = ov5693_res[N_RES - 1].height;\n\t} else {\n\t\tfmt->width = ov5693_res[idx].width;\n\t\tfmt->height = ov5693_res[idx].height;\n\t}\n\n\tfmt->code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tsd_state->pads->try_fmt = *fmt;\n\t\tmutex_unlock(&dev->input_lock);\n\t\treturn 0;\n\t}\n\n\tdev->fmt_idx = get_resolution_index(fmt->width, fmt->height);\n\tif (dev->fmt_idx == -1) {\n\t\tdev_err(&client->dev, \"get resolution fail\\n\");\n\t\tmutex_unlock(&dev->input_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tret = startup(sd);\n\tif (ret) {\n\t\tint i = 0;\n\n\t\tdev_err(&client->dev, \"ov5693 startup err, retry to power up\\n\");\n\t\tfor (i = 0; i < OV5693_POWER_UP_RETRY_NUM; i++) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"ov5693 retry to power up %d/%d times, result: \",\n\t\t\t\ti + 1, OV5693_POWER_UP_RETRY_NUM);\n\t\t\tpower_down(sd);\n\t\t\tret = power_up(sd);\n\t\t\tif (!ret) {\n\t\t\t\tmutex_unlock(&dev->input_lock);\n\t\t\t\tov5693_init(sd);\n\t\t\t\tmutex_lock(&dev->input_lock);\n\t\t\t} else {\n\t\t\t\tdev_err(&client->dev, \"power up failed, continue\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = startup(sd);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&client->dev, \" startup FAILED!\\n\");\n\t\t\t} else {\n\t\t\t\tdev_err(&client->dev, \" startup SUCCESS!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tret = ov5693_write_reg(client, OV5693_8BIT, OV5693_SW_STREAM,\n\t\t\t       OV5693_STOP_STREAMING);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"ov5693 stream off err\\n\");\n\n\tov5693_info->metadata_width = fmt->width * 10 / 8;\n\tov5693_info->metadata_height = 1;\n\tov5693_info->metadata_effective_width = &ov5693_embedded_effective_size;\n\n\tmutex_unlock(&dev->input_lock);\n\treturn ret;\n}\n\nstatic int ov5693_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tfmt->width = ov5693_res[dev->fmt_idx].width;\n\tfmt->height = ov5693_res[dev->fmt_idx].height;\n\tfmt->code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\n\treturn 0;\n}\n\nstatic int ov5693_detect(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tu16 high, low;\n\tint ret;\n\tu16 id;\n\tu8 revision;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tret = ov5693_read_reg(client, OV5693_8BIT,\n\t\t\t      OV5693_SC_CMMN_CHIP_ID_H, &high);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"sensor_id_high = 0x%x\\n\", high);\n\t\treturn -ENODEV;\n\t}\n\tret = ov5693_read_reg(client, OV5693_8BIT,\n\t\t\t      OV5693_SC_CMMN_CHIP_ID_L, &low);\n\tif (ret)\n\t\treturn ret;\n\tid = ((((u16)high) << 8) | (u16)low);\n\n\tif (id != OV5693_ID) {\n\t\tdev_err(&client->dev, \"sensor ID error 0x%x\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\tret = ov5693_read_reg(client, OV5693_8BIT,\n\t\t\t      OV5693_SC_CMMN_SUB_ID, &high);\n\trevision = (u8)high & 0x0f;\n\n\tdev_dbg(&client->dev, \"sensor_revision = 0x%x\\n\", revision);\n\tdev_dbg(&client->dev, \"detect ov5693 success\\n\");\n\treturn 0;\n}\n\nstatic int ov5693_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tmutex_lock(&dev->input_lock);\n\n\tret = ov5693_write_reg(client, OV5693_8BIT, OV5693_SW_STREAM,\n\t\t\t       enable ? OV5693_START_STREAMING :\n\t\t\t       OV5693_STOP_STREAMING);\n\n\tmutex_unlock(&dev->input_lock);\n\n\treturn ret;\n}\n\nstatic int ov5693_s_config(struct v4l2_subdev *sd,\n\t\t\t   int irq, void *platform_data)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tif (!platform_data)\n\t\treturn -ENODEV;\n\n\tdev->platform_data =\n\t    (struct camera_sensor_platform_data *)platform_data;\n\n\tmutex_lock(&dev->input_lock);\n\t \n\tret = power_down(sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"ov5693 power-off err.\\n\");\n\t\tgoto fail_power_off;\n\t}\n\n\tret = power_up(sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"ov5693 power-up err.\\n\");\n\t\tgoto fail_power_on;\n\t}\n\n\tif (!dev->vcm)\n\t\tdev->vcm = vcm_detect(client);\n\n\tret = dev->platform_data->csi_cfg(sd, 1);\n\tif (ret)\n\t\tgoto fail_csi_cfg;\n\n\t \n\tret = ov5693_detect(client);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"ov5693_detect err s_config.\\n\");\n\t\tgoto fail_csi_cfg;\n\t}\n\n\tdev->otp_data = ov5693_otp_read(sd);\n\n\t \n\tret = power_down(sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"ov5693 power-off err.\\n\");\n\t\tgoto fail_csi_cfg;\n\t}\n\tmutex_unlock(&dev->input_lock);\n\n\treturn ret;\n\nfail_csi_cfg:\n\tdev->platform_data->csi_cfg(sd, 0);\nfail_power_on:\n\tpower_down(sd);\n\tdev_err(&client->dev, \"sensor power-gating failed\\n\");\nfail_power_off:\n\tmutex_unlock(&dev->input_lock);\n\treturn ret;\n}\n\nstatic int ov5693_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *interval)\n{\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\n\tinterval->interval.numerator = 1;\n\tinterval->interval.denominator = ov5693_res[dev->fmt_idx].fps;\n\n\treturn 0;\n}\n\nstatic int ov5693_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index >= MAX_FMTS)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\treturn 0;\n}\n\nstatic int ov5693_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tint index = fse->index;\n\n\tif (index >= N_RES)\n\t\treturn -EINVAL;\n\n\tfse->min_width = ov5693_res[index].width;\n\tfse->min_height = ov5693_res[index].height;\n\tfse->max_width = ov5693_res[index].width;\n\tfse->max_height = ov5693_res[index].height;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops ov5693_video_ops = {\n\t.s_stream = ov5693_s_stream,\n\t.g_frame_interval = ov5693_g_frame_interval,\n};\n\nstatic const struct v4l2_subdev_core_ops ov5693_core_ops = {\n\t.s_power = ov5693_s_power,\n\t.ioctl = ov5693_ioctl,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov5693_pad_ops = {\n\t.enum_mbus_code = ov5693_enum_mbus_code,\n\t.enum_frame_size = ov5693_enum_frame_size,\n\t.get_fmt = ov5693_get_fmt,\n\t.set_fmt = ov5693_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops ov5693_ops = {\n\t.core = &ov5693_core_ops,\n\t.video = &ov5693_video_ops,\n\t.pad = &ov5693_pad_ops,\n};\n\nstatic void ov5693_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov5693_device *dev = to_ov5693_sensor(sd);\n\n\tdev_dbg(&client->dev, \"ov5693_remove...\\n\");\n\n\tdev->platform_data->csi_cfg(sd, 0);\n\n\tv4l2_device_unregister_subdev(sd);\n\n\tatomisp_gmin_remove_subdev(sd);\n\n\tmedia_entity_cleanup(&dev->sd.entity);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tkfree(dev);\n}\n\nstatic int ov5693_probe(struct i2c_client *client)\n{\n\tstruct ov5693_device *dev;\n\tint i2c;\n\tint ret;\n\tvoid *pdata;\n\tunsigned int i;\n\n\t \n\ti2c = gmin_get_var_int(&client->dev, false, \"I2CAddr\", -1);\n\tif (i2c != -1) {\n\t\tdev_info(&client->dev,\n\t\t\t \"Overriding firmware-provided I2C address (0x%x) with 0x%x\\n\",\n\t\t\t client->addr, i2c);\n\t\tclient->addr = i2c;\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->input_lock);\n\n\tdev->fmt_idx = 0;\n\tv4l2_i2c_subdev_init(&dev->sd, client, &ov5693_ops);\n\n\tpdata = gmin_camera_platform_data(&dev->sd,\n\t\t\t\t\t  ATOMISP_INPUT_FORMAT_RAW_10,\n\t\t\t\t\t  atomisp_bayer_order_bggr);\n\tif (!pdata) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tret = ov5693_s_config(&dev->sd, client->irq, pdata);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = atomisp_register_i2c_module(&dev->sd, pdata, RAW_CAMERA);\n\tif (ret)\n\t\tgoto out_free;\n\n\tdev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tdev->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tdev->format.code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\tdev->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret =\n\t    v4l2_ctrl_handler_init(&dev->ctrl_handler,\n\t\t\t\t   ARRAY_SIZE(ov5693_controls));\n\tif (ret) {\n\t\tov5693_remove(client);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ov5693_controls); i++)\n\t\tv4l2_ctrl_new_custom(&dev->ctrl_handler, &ov5693_controls[i],\n\t\t\t\t     NULL);\n\n\tif (dev->ctrl_handler.error) {\n\t\tov5693_remove(client);\n\t\treturn dev->ctrl_handler.error;\n\t}\n\n\t \n\tdev->ctrl_handler.lock = &dev->input_lock;\n\tdev->sd.ctrl_handler = &dev->ctrl_handler;\n\n\tret = media_entity_pads_init(&dev->sd.entity, 1, &dev->pad);\n\tif (ret)\n\t\tov5693_remove(client);\n\n\treturn ret;\nout_free:\n\tv4l2_device_unregister_subdev(&dev->sd);\n\tkfree(dev);\n\treturn ret;\n}\n\nstatic const struct acpi_device_id ov5693_acpi_match[] = {\n\t{\"INT33BE\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, ov5693_acpi_match);\n\nstatic struct i2c_driver ov5693_driver = {\n\t.driver = {\n\t\t.name = \"ov5693\",\n\t\t.acpi_match_table = ov5693_acpi_match,\n\t},\n\t.probe = ov5693_probe,\n\t.remove = ov5693_remove,\n};\nmodule_i2c_driver(ov5693_driver);\n\nMODULE_DESCRIPTION(\"A low-level driver for OmniVision 5693 sensors\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}