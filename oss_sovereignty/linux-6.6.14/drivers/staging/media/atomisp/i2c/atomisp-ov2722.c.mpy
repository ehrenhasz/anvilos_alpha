{
  "module_name": "atomisp-ov2722.c",
  "hash_id": "ba230e9b01b68b28460a1a37a9aee2da347bafd8deffb5770c080f1f04698fbc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/i2c/atomisp-ov2722.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/moduleparam.h>\n#include <media/v4l2-device.h>\n#include \"../include/linux/atomisp_gmin_platform.h\"\n#include <linux/acpi.h>\n#include <linux/io.h>\n\n#include \"ov2722.h\"\n\n \nstatic int ov2722_read_reg(struct i2c_client *client,\n\t\t\t   u16 data_length, u16 reg, u16 *val)\n{\n\tint err;\n\tstruct i2c_msg msg[2];\n\tunsigned char data[6];\n\n\tif (!client->adapter) {\n\t\tdev_err(&client->dev, \"%s error, no client->adapter\\n\",\n\t\t\t__func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (data_length != OV2722_8BIT && data_length != OV2722_16BIT &&\n\t    data_length != OV2722_32BIT) {\n\t\tdev_err(&client->dev, \"%s error, invalid data length\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(msg, 0, sizeof(msg));\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = 0;\n\tmsg[0].len = I2C_MSG_LENGTH;\n\tmsg[0].buf = data;\n\n\t \n\tdata[0] = (u8)(reg >> 8);\n\tdata[1] = (u8)(reg & 0xff);\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].len = data_length;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].buf = data;\n\n\terr = i2c_transfer(client->adapter, msg, 2);\n\tif (err != 2) {\n\t\tif (err >= 0)\n\t\t\terr = -EIO;\n\t\tdev_err(&client->dev,\n\t\t\t\"read from offset 0x%x error %d\", reg, err);\n\t\treturn err;\n\t}\n\n\t*val = 0;\n\t \n\tif (data_length == OV2722_8BIT)\n\t\t*val = (u8)data[0];\n\telse if (data_length == OV2722_16BIT)\n\t\t*val = be16_to_cpu(*(__be16 *)&data[0]);\n\telse\n\t\t*val = be32_to_cpu(*(__be32 *)&data[0]);\n\n\treturn 0;\n}\n\nstatic int ov2722_i2c_write(struct i2c_client *client, u16 len, u8 *data)\n{\n\tstruct i2c_msg msg;\n\tconst int num_msg = 1;\n\tint ret;\n\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\tmsg.len = len;\n\tmsg.buf = data;\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\n\treturn ret == num_msg ? 0 : -EIO;\n}\n\nstatic int ov2722_write_reg(struct i2c_client *client, u16 data_length,\n\t\t\t    u16 reg, u16 val)\n{\n\tint ret;\n\tunsigned char data[4] = {0};\n\t__be16 *wreg = (__be16 *)data;\n\tconst u16 len = data_length + sizeof(u16);  \n\n\tif (data_length != OV2722_8BIT && data_length != OV2722_16BIT) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s error, invalid data_length\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t*wreg = cpu_to_be16(reg);\n\n\tif (data_length == OV2722_8BIT) {\n\t\tdata[2] = (u8)(val);\n\t} else {\n\t\t \n\t\t__be16 *wdata = (__be16 *)&data[2];\n\n\t\t*wdata = cpu_to_be16(val);\n\t}\n\n\tret = ov2722_i2c_write(client, len, data);\n\tif (ret)\n\t\tdev_err(&client->dev,\n\t\t\t\"write error: wrote 0x%x to offset 0x%x error %d\",\n\t\t\tval, reg, ret);\n\n\treturn ret;\n}\n\n \n\nstatic int __ov2722_flush_reg_array(struct i2c_client *client,\n\t\t\t\t    struct ov2722_write_ctrl *ctrl)\n{\n\tu16 size;\n\t__be16 *data16 = (void *)&ctrl->buffer.addr;\n\n\tif (ctrl->index == 0)\n\t\treturn 0;\n\n\tsize = sizeof(u16) + ctrl->index;  \n\t*data16 = cpu_to_be16(ctrl->buffer.addr);\n\tctrl->index = 0;\n\n\treturn ov2722_i2c_write(client, size, (u8 *)&ctrl->buffer);\n}\n\nstatic int __ov2722_buf_reg_array(struct i2c_client *client,\n\t\t\t\t  struct ov2722_write_ctrl *ctrl,\n\t\t\t\t  const struct ov2722_reg *next)\n{\n\tint size;\n\t__be16 *data16;\n\n\tswitch (next->type) {\n\tcase OV2722_8BIT:\n\t\tsize = 1;\n\t\tctrl->buffer.data[ctrl->index] = (u8)next->val;\n\t\tbreak;\n\tcase OV2722_16BIT:\n\t\tsize = 2;\n\t\tdata16 = (void *)&ctrl->buffer.data[ctrl->index];\n\t\t*data16 = cpu_to_be16((u16)next->val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ctrl->index == 0)\n\t\tctrl->buffer.addr = next->reg;\n\n\tctrl->index += size;\n\n\t \n\tif (ctrl->index + sizeof(u16) >= OV2722_MAX_WRITE_BUF_SIZE)\n\t\treturn __ov2722_flush_reg_array(client, ctrl);\n\n\treturn 0;\n}\n\nstatic int __ov2722_write_reg_is_consecutive(struct i2c_client *client,\n\t\t\t\t\t     struct ov2722_write_ctrl *ctrl,\n\t\t\t\t\t     const struct ov2722_reg *next)\n{\n\tif (ctrl->index == 0)\n\t\treturn 1;\n\n\treturn ctrl->buffer.addr + ctrl->index == next->reg;\n}\n\nstatic int ov2722_write_reg_array(struct i2c_client *client,\n\t\t\t\t  const struct ov2722_reg *reglist)\n{\n\tconst struct ov2722_reg *next = reglist;\n\tstruct ov2722_write_ctrl ctrl;\n\tint err;\n\n\tctrl.index = 0;\n\tfor (; next->type != OV2722_TOK_TERM; next++) {\n\t\tswitch (next->type & OV2722_TOK_MASK) {\n\t\tcase OV2722_TOK_DELAY:\n\t\t\terr = __ov2722_flush_reg_array(client, &ctrl);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tmsleep(next->val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tif (!__ov2722_write_reg_is_consecutive(client, &ctrl,\n\t\t\t\t\t\t\t       next)) {\n\t\t\t\terr = __ov2722_flush_reg_array(client, &ctrl);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\terr = __ov2722_buf_reg_array(client, &ctrl, next);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&client->dev, \"%s: write error, aborted\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn __ov2722_flush_reg_array(client, &ctrl);\n}\n\nstatic long __ov2722_set_exposure(struct v4l2_subdev *sd, int coarse_itg,\n\t\t\t\t  int gain, int digitgain)\n\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\tu16 hts, vts;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"set_exposure without group hold\\n\");\n\n\t \n\tret = ov2722_write_reg(client, OV2722_16BIT, OV2722_VTS_DIFF_H, 0);\n\tif (ret)\n\t\treturn ret;\n\n\thts = dev->pixels_per_line;\n\tvts = dev->lines_per_frame;\n\n\tif ((coarse_itg + OV2722_COARSE_INTG_TIME_MAX_MARGIN) > vts)\n\t\tvts = coarse_itg + OV2722_COARSE_INTG_TIME_MAX_MARGIN;\n\n\tcoarse_itg <<= 4;\n\tdigitgain <<= 2;\n\n\tret = ov2722_write_reg(client, OV2722_16BIT,\n\t\t\t       OV2722_VTS_H, vts);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov2722_write_reg(client, OV2722_16BIT,\n\t\t\t       OV2722_HTS_H, hts);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov2722_write_reg(client, OV2722_8BIT,\n\t\t\t       OV2722_AEC_PK_EXPO_L,\n\t\t\t       coarse_itg & 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov2722_write_reg(client, OV2722_16BIT,\n\t\t\t       OV2722_AEC_PK_EXPO_H,\n\t\t\t       (coarse_itg >> 8) & 0xfff);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov2722_write_reg(client, OV2722_16BIT,\n\t\t\t       OV2722_AGC_ADJ_H, gain);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov2722_write_reg(client, OV2722_16BIT,\n\t\t\t       OV2722_MWB_GAIN_R_H, digitgain);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov2722_write_reg(client, OV2722_16BIT,\n\t\t\t       OV2722_MWB_GAIN_G_H, digitgain);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov2722_write_reg(client, OV2722_16BIT,\n\t\t\t       OV2722_MWB_GAIN_B_H, digitgain);\n\n\treturn ret;\n}\n\nstatic int ov2722_set_exposure(struct v4l2_subdev *sd, int exposure,\n\t\t\t       int gain, int digitgain)\n{\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\tint ret;\n\n\tmutex_lock(&dev->input_lock);\n\tret = __ov2722_set_exposure(sd, exposure, gain, digitgain);\n\tmutex_unlock(&dev->input_lock);\n\n\treturn ret;\n}\n\nstatic long ov2722_s_exposure(struct v4l2_subdev *sd,\n\t\t\t      struct atomisp_exposure *exposure)\n{\n\tint exp = exposure->integration_time[0];\n\tint gain = exposure->gain[0];\n\tint digitgain = exposure->gain[1];\n\n\t \n\tif (gain == 0) {\n\t\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\t\tv4l2_err(client, \"%s: invalid value\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ov2722_set_exposure(sd, exp, gain, digitgain);\n}\n\nstatic long ov2722_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase ATOMISP_IOC_S_EXPOSURE:\n\t\treturn ov2722_s_exposure(sd, arg);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int ov2722_q_exposure(struct v4l2_subdev *sd, s32 *value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu16 reg_v, reg_v2;\n\tint ret;\n\n\t \n\tret = ov2722_read_reg(client, OV2722_8BIT,\n\t\t\t      OV2722_AEC_PK_EXPO_L,\n\t\t\t      &reg_v);\n\tif (ret)\n\t\tgoto err;\n\n\tret = ov2722_read_reg(client, OV2722_8BIT,\n\t\t\t      OV2722_AEC_PK_EXPO_M,\n\t\t\t      &reg_v2);\n\tif (ret)\n\t\tgoto err;\n\n\treg_v += reg_v2 << 8;\n\tret = ov2722_read_reg(client, OV2722_8BIT,\n\t\t\t      OV2722_AEC_PK_EXPO_H,\n\t\t\t      &reg_v2);\n\tif (ret)\n\t\tgoto err;\n\n\t*value = reg_v + (((u32)reg_v2 << 16));\nerr:\n\treturn ret;\n}\n\nstatic int ov2722_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov2722_device *dev =\n\t    container_of(ctrl->handler, struct ov2722_device, ctrl_handler);\n\tint ret = 0;\n\tunsigned int val;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE_ABSOLUTE:\n\t\tret = ov2722_q_exposure(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_LINK_FREQ:\n\t\tval = dev->res->mipi_freq;\n\t\tif (val == 0)\n\t\t\treturn -EINVAL;\n\n\t\tctrl->val = val * 1000;\t \n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ctrl_ops = {\n\t.g_volatile_ctrl = ov2722_g_volatile_ctrl\n};\n\nstatic const struct v4l2_ctrl_config ov2722_controls[] = {\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_EXPOSURE_ABSOLUTE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"exposure\",\n\t\t.min = 0x0,\n\t\t.max = 0xffff,\n\t\t.step = 0x01,\n\t\t.def = 0x00,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_LINK_FREQ,\n\t\t.name = \"Link Frequency\",\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.min = 1,\n\t\t.max = 1500000 * 1000,\n\t\t.step = 1,\n\t\t.def = 1,\n\t\t.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,\n\t},\n};\n\nstatic int ov2722_init(struct v4l2_subdev *sd)\n{\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\n\tmutex_lock(&dev->input_lock);\n\n\t \n\tov2722_res = ov2722_res_preview;\n\tN_RES = N_RES_PREVIEW;\n\n\tmutex_unlock(&dev->input_lock);\n\n\treturn 0;\n}\n\nstatic int power_ctrl(struct v4l2_subdev *sd, bool flag)\n{\n\tint ret = -1;\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\n\tif (!dev || !dev->platform_data)\n\t\treturn -ENODEV;\n\n\tif (flag) {\n\t\tret = dev->platform_data->v1p8_ctrl(sd, 1);\n\t\tif (ret == 0) {\n\t\t\tret = dev->platform_data->v2p8_ctrl(sd, 1);\n\t\t\tif (ret)\n\t\t\t\tdev->platform_data->v1p8_ctrl(sd, 0);\n\t\t}\n\t} else {\n\t\tret = dev->platform_data->v1p8_ctrl(sd, 0);\n\t\tret |= dev->platform_data->v2p8_ctrl(sd, 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int gpio_ctrl(struct v4l2_subdev *sd, bool flag)\n{\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\tint ret = -1;\n\n\tif (!dev || !dev->platform_data)\n\t\treturn -ENODEV;\n\n\t \n\tret = dev->platform_data->gpio0_ctrl(sd, flag);\n\tret |= dev->platform_data->gpio1_ctrl(sd, flag);\n\treturn ret;\n}\n\nstatic int power_up(struct v4l2_subdev *sd)\n{\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tif (!dev->platform_data) {\n\t\tdev_err(&client->dev,\n\t\t\t\"no camera_sensor_platform_data\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dev->power_on == 1)\n\t\treturn 0;  \n\n\t \n\tret = power_ctrl(sd, 1);\n\tif (ret)\n\t\tgoto fail_power;\n\n\t \n\tusleep_range(5000, 6000);\n\n\t \n\tret = gpio_ctrl(sd, 1);\n\tif (ret) {\n\t\tret = gpio_ctrl(sd, 0);\n\t\tif (ret)\n\t\t\tgoto fail_power;\n\t}\n\n\t \n\tret = dev->platform_data->flisclk_ctrl(sd, 1);\n\tif (ret)\n\t\tgoto fail_clk;\n\n\t \n\tmsleep(20);\n\n\tdev->power_on = 1;\n\treturn 0;\n\nfail_clk:\n\tgpio_ctrl(sd, 0);\nfail_power:\n\tpower_ctrl(sd, 0);\n\tdev_err(&client->dev, \"sensor power-up failed\\n\");\n\n\treturn ret;\n}\n\nstatic int power_down(struct v4l2_subdev *sd)\n{\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tif (!dev->platform_data) {\n\t\tdev_err(&client->dev,\n\t\t\t\"no camera_sensor_platform_data\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dev->power_on == 0)\n\t\treturn 0;  \n\n\tret = dev->platform_data->flisclk_ctrl(sd, 0);\n\tif (ret)\n\t\tdev_err(&client->dev, \"flisclk failed\\n\");\n\n\t \n\tret = gpio_ctrl(sd, 0);\n\tif (ret) {\n\t\tret = gpio_ctrl(sd, 0);\n\t\tif (ret)\n\t\t\tdev_err(&client->dev, \"gpio failed 2\\n\");\n\t}\n\n\t \n\tret = power_ctrl(sd, 0);\n\tif (ret)\n\t\tdev_err(&client->dev, \"vprog failed.\\n\");\n\n\tdev->power_on = 0;\n\treturn ret;\n}\n\nstatic int ov2722_s_power(struct v4l2_subdev *sd, int on)\n{\n\tint ret;\n\n\tif (on == 0)\n\t\treturn power_down(sd);\n\n\tret = power_up(sd);\n\tif (!ret)\n\t\treturn ov2722_init(sd);\n\n\treturn ret;\n}\n\n \nstatic int startup(struct v4l2_subdev *sd)\n{\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tret = ov2722_write_reg(client, OV2722_8BIT,\n\t\t\t       OV2722_SW_RESET, 0x01);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"ov2722 reset err.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov2722_write_reg_array(client, dev->res->regs);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"ov2722 write register err.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int ov2722_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov2722_resolution *res;\n\tstruct camera_mipi_info *ov2722_info = NULL;\n\tint ret = 0;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\tif (!fmt)\n\t\treturn -EINVAL;\n\tov2722_info = v4l2_get_subdev_hostdata(sd);\n\tif (!ov2722_info)\n\t\treturn -EINVAL;\n\n\tres = v4l2_find_nearest_size(ov2722_res_preview,\n\t\t\t\t     ARRAY_SIZE(ov2722_res_preview), width,\n\t\t\t\t     height, fmt->width, fmt->height);\n\tif (!res)\n\t\tres = &ov2722_res_preview[N_RES - 1];\n\n\tfmt->width = res->width;\n\tfmt->height = res->height;\n\tdev->res = res;\n\n\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tsd_state->pads->try_fmt = *fmt;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&dev->input_lock);\n\n\t \n\tpower_up(sd);\n\n\tdev->pixels_per_line = dev->res->pixels_per_line;\n\tdev->lines_per_frame = dev->res->lines_per_frame;\n\n\tret = startup(sd);\n\tif (ret) {\n\t\tint i = 0;\n\n\t\tdev_err(&client->dev, \"ov2722 startup err, retry to power up\\n\");\n\t\tfor (i = 0; i < OV2722_POWER_UP_RETRY_NUM; i++) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"ov2722 retry to power up %d/%d times, result: \",\n\t\t\t\ti + 1, OV2722_POWER_UP_RETRY_NUM);\n\t\t\tpower_down(sd);\n\t\t\tret = power_up(sd);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&client->dev, \"power up failed, continue\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = startup(sd);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&client->dev, \" startup FAILED!\\n\");\n\t\t\t} else {\n\t\t\t\tdev_err(&client->dev, \" startup SUCCESS!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"ov2722 startup err\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\tmutex_unlock(&dev->input_lock);\n\treturn ret;\n}\n\nstatic int ov2722_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tfmt->width = dev->res->width;\n\tfmt->height = dev->res->height;\n\tfmt->code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\n\treturn 0;\n}\n\nstatic int ov2722_detect(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tu16 high = 0, low = 0;\n\tu16 id;\n\tu8 revision;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tov2722_read_reg(client, OV2722_8BIT,\n\t\t\tOV2722_SC_CMMN_CHIP_ID_H, &high);\n\tov2722_read_reg(client, OV2722_8BIT,\n\t\t\tOV2722_SC_CMMN_CHIP_ID_L, &low);\n\tid = (high << 8) | low;\n\n\tif ((id != OV2722_ID) && (id != OV2720_ID)) {\n\t\tdev_err(&client->dev, \"sensor ID error\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thigh = 0;\n\tov2722_read_reg(client, OV2722_8BIT,\n\t\t\tOV2722_SC_CMMN_SUB_ID, &high);\n\trevision = (u8)high & 0x0f;\n\n\tdev_dbg(&client->dev, \"sensor_revision = 0x%x\\n\", revision);\n\tdev_dbg(&client->dev, \"detect ov2722 success\\n\");\n\treturn 0;\n}\n\nstatic int ov2722_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tmutex_lock(&dev->input_lock);\n\n\tret = ov2722_write_reg(client, OV2722_8BIT, OV2722_SW_STREAM,\n\t\t\t       enable ? OV2722_START_STREAMING :\n\t\t\t       OV2722_STOP_STREAMING);\n\n\tmutex_unlock(&dev->input_lock);\n\treturn ret;\n}\n\nstatic int ov2722_s_config(struct v4l2_subdev *sd,\n\t\t\t   int irq, void *platform_data)\n{\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tif (!platform_data)\n\t\treturn -ENODEV;\n\n\tdev->platform_data =\n\t    (struct camera_sensor_platform_data *)platform_data;\n\n\tmutex_lock(&dev->input_lock);\n\n\t \n\tret = power_down(sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"ov2722 power-off err.\\n\");\n\t\tgoto fail_power_off;\n\t}\n\n\tret = power_up(sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"ov2722 power-up err.\\n\");\n\t\tgoto fail_power_on;\n\t}\n\n\tret = dev->platform_data->csi_cfg(sd, 1);\n\tif (ret)\n\t\tgoto fail_csi_cfg;\n\n\t \n\tret = ov2722_detect(client);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"ov2722_detect err s_config.\\n\");\n\t\tgoto fail_csi_cfg;\n\t}\n\n\t \n\tret = power_down(sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"ov2722 power-off err.\\n\");\n\t\tgoto fail_csi_cfg;\n\t}\n\tmutex_unlock(&dev->input_lock);\n\n\treturn 0;\n\nfail_csi_cfg:\n\tdev->platform_data->csi_cfg(sd, 0);\nfail_power_on:\n\tpower_down(sd);\n\tdev_err(&client->dev, \"sensor power-gating failed\\n\");\nfail_power_off:\n\tmutex_unlock(&dev->input_lock);\n\treturn ret;\n}\n\nstatic int ov2722_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *interval)\n{\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\n\tinterval->interval.numerator = 1;\n\tinterval->interval.denominator = dev->res->fps;\n\n\treturn 0;\n}\n\nstatic int ov2722_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index >= MAX_FMTS)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\treturn 0;\n}\n\nstatic int ov2722_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tint index = fse->index;\n\n\tif (index >= N_RES)\n\t\treturn -EINVAL;\n\n\tfse->min_width = ov2722_res[index].width;\n\tfse->min_height = ov2722_res[index].height;\n\tfse->max_width = ov2722_res[index].width;\n\tfse->max_height = ov2722_res[index].height;\n\n\treturn 0;\n}\n\nstatic int ov2722_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)\n{\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\n\tmutex_lock(&dev->input_lock);\n\t*frames = dev->res->skip_frames;\n\tmutex_unlock(&dev->input_lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_sensor_ops ov2722_sensor_ops = {\n\t.g_skip_frames\t= ov2722_g_skip_frames,\n};\n\nstatic const struct v4l2_subdev_video_ops ov2722_video_ops = {\n\t.s_stream = ov2722_s_stream,\n\t.g_frame_interval = ov2722_g_frame_interval,\n};\n\nstatic const struct v4l2_subdev_core_ops ov2722_core_ops = {\n\t.s_power = ov2722_s_power,\n\t.ioctl = ov2722_ioctl,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov2722_pad_ops = {\n\t.enum_mbus_code = ov2722_enum_mbus_code,\n\t.enum_frame_size = ov2722_enum_frame_size,\n\t.get_fmt = ov2722_get_fmt,\n\t.set_fmt = ov2722_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops ov2722_ops = {\n\t.core = &ov2722_core_ops,\n\t.video = &ov2722_video_ops,\n\t.pad = &ov2722_pad_ops,\n\t.sensor = &ov2722_sensor_ops,\n};\n\nstatic void ov2722_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov2722_device *dev = to_ov2722_sensor(sd);\n\n\tdev->platform_data->csi_cfg(sd, 0);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tv4l2_device_unregister_subdev(sd);\n\n\tatomisp_gmin_remove_subdev(sd);\n\n\tmedia_entity_cleanup(&dev->sd.entity);\n\tkfree(dev);\n}\n\nstatic int __ov2722_init_ctrl_handler(struct ov2722_device *dev)\n{\n\tstruct v4l2_ctrl_handler *hdl;\n\tunsigned int i;\n\n\thdl = &dev->ctrl_handler;\n\tv4l2_ctrl_handler_init(&dev->ctrl_handler, ARRAY_SIZE(ov2722_controls));\n\tfor (i = 0; i < ARRAY_SIZE(ov2722_controls); i++)\n\t\tv4l2_ctrl_new_custom(&dev->ctrl_handler, &ov2722_controls[i],\n\t\t\t\t     NULL);\n\n\tdev->link_freq = v4l2_ctrl_find(&dev->ctrl_handler, V4L2_CID_LINK_FREQ);\n\n\tif (dev->ctrl_handler.error || !dev->link_freq)\n\t\treturn dev->ctrl_handler.error;\n\n\tdev->sd.ctrl_handler = hdl;\n\n\treturn 0;\n}\n\nstatic int ov2722_probe(struct i2c_client *client)\n{\n\tstruct ov2722_device *dev;\n\tvoid *ovpdev;\n\tint ret;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->input_lock);\n\tdev->power_on = -1;\n\n\tdev->res = &ov2722_res_preview[0];\n\tv4l2_i2c_subdev_init(&dev->sd, client, &ov2722_ops);\n\n\tovpdev = gmin_camera_platform_data(&dev->sd,\n\t\t\t\t\t   ATOMISP_INPUT_FORMAT_RAW_10,\n\t\t\t\t\t   atomisp_bayer_order_grbg);\n\n\tret = ov2722_s_config(&dev->sd, client->irq, ovpdev);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = __ov2722_init_ctrl_handler(dev);\n\tif (ret)\n\t\tgoto out_ctrl_handler_free;\n\n\tdev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tdev->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tdev->format.code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\tdev->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\tret = media_entity_pads_init(&dev->sd.entity, 1, &dev->pad);\n\tif (ret)\n\t\tov2722_remove(client);\n\n\treturn atomisp_register_i2c_module(&dev->sd, ovpdev, RAW_CAMERA);\n\nout_ctrl_handler_free:\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\nout_free:\n\tatomisp_gmin_remove_subdev(&dev->sd);\n\tv4l2_device_unregister_subdev(&dev->sd);\n\tkfree(dev);\n\treturn ret;\n}\n\nstatic const struct acpi_device_id ov2722_acpi_match[] = {\n\t{ \"INT33FB\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, ov2722_acpi_match);\n\nstatic struct i2c_driver ov2722_driver = {\n\t.driver = {\n\t\t.name = \"ov2722\",\n\t\t.acpi_match_table = ov2722_acpi_match,\n\t},\n\t.probe = ov2722_probe,\n\t.remove = ov2722_remove,\n};\nmodule_i2c_driver(ov2722_driver);\n\nMODULE_AUTHOR(\"Wei Liu <wei.liu@intel.com>\");\nMODULE_DESCRIPTION(\"A low-level driver for OmniVision 2722 sensors\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}