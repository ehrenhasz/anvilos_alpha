{
  "module_name": "atomisp-lm3554.c",
  "hash_id": "f1da437727d771a7f452468b32cb017c172d036057413a1572ae079e73d78298",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/i2c/atomisp-lm3554.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n\n#include \"../include/media/lm3554.h\"\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <linux/acpi.h>\n#include \"../include/linux/atomisp_gmin_platform.h\"\n#include \"../include/linux/atomisp.h\"\n\n \n\n#define LM3554_TORCH_BRIGHTNESS_REG\t0xA0\n#define LM3554_TORCH_MODE_SHIFT\t\t0\n#define LM3554_TORCH_CURRENT_SHIFT\t3\n#define LM3554_INDICATOR_CURRENT_SHIFT\t6\n\n#define LM3554_FLASH_BRIGHTNESS_REG\t0xB0\n#define LM3554_FLASH_MODE_SHIFT\t\t0\n#define LM3554_FLASH_CURRENT_SHIFT\t3\n#define LM3554_STROBE_SENSITIVITY_SHIFT\t7\n\n#define LM3554_FLASH_DURATION_REG\t0xC0\n#define LM3554_FLASH_TIMEOUT_SHIFT\t0\n#define LM3554_CURRENT_LIMIT_SHIFT\t5\n\n#define LM3554_FLAGS_REG\t\t0xD0\n#define LM3554_FLAG_TIMEOUT\t\tBIT(0)\n#define LM3554_FLAG_THERMAL_SHUTDOWN\tBIT(1)\n#define LM3554_FLAG_LED_FAULT\t\tBIT(2)\n#define LM3554_FLAG_TX1_INTERRUPT\tBIT(3)\n#define LM3554_FLAG_TX2_INTERRUPT\tBIT(4)\n#define LM3554_FLAG_LED_THERMAL_FAULT\tBIT(5)\n#define LM3554_FLAG_UNUSED\t\tBIT(6)\n#define LM3554_FLAG_INPUT_VOLTAGE_LOW\tBIT(7)\n\n#define LM3554_CONFIG_REG_1\t\t0xE0\n#define LM3554_ENVM_TX2_SHIFT\t\t5\n#define LM3554_TX2_POLARITY_SHIFT\t6\n\nstruct lm3554 {\n\tstruct v4l2_subdev sd;\n\n\tstruct mutex power_lock;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tint power_count;\n\n\tunsigned int mode;\n\tint timeout;\n\tu8 torch_current;\n\tu8 indicator_current;\n\tu8 flash_current;\n\n\tstruct timer_list flash_off_delay;\n\tstruct lm3554_platform_data *pdata;\n};\n\n#define to_lm3554(p_sd)\tcontainer_of(p_sd, struct lm3554, sd)\n\n \nstatic int lm3554_write(struct lm3554 *flash, u8 addr, u8 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&flash->sd);\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, addr, val);\n\n\tdev_dbg(&client->dev, \"Write Addr:%02X Val:%02X %s\\n\", addr, val,\n\t\tret < 0 ? \"fail\" : \"ok\");\n\n\treturn ret;\n}\n\n \nstatic int lm3554_read(struct lm3554 *flash, u8 addr)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&flash->sd);\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, addr);\n\n\tdev_dbg(&client->dev, \"Read Addr:%02X Val:%02X %s\\n\", addr, ret,\n\t\tret < 0 ? \"fail\" : \"ok\");\n\n\treturn ret;\n}\n\n \n\nstatic int lm3554_set_mode(struct lm3554 *flash, unsigned int mode)\n{\n\tu8 val;\n\tint ret;\n\n\tval = (mode << LM3554_FLASH_MODE_SHIFT) |\n\t      (flash->flash_current << LM3554_FLASH_CURRENT_SHIFT);\n\n\tret = lm3554_write(flash, LM3554_FLASH_BRIGHTNESS_REG, val);\n\tif (ret == 0)\n\t\tflash->mode = mode;\n\treturn ret;\n}\n\nstatic int lm3554_set_torch(struct lm3554 *flash)\n{\n\tu8 val;\n\n\tval = (flash->mode << LM3554_TORCH_MODE_SHIFT) |\n\t      (flash->torch_current << LM3554_TORCH_CURRENT_SHIFT) |\n\t      (flash->indicator_current << LM3554_INDICATOR_CURRENT_SHIFT);\n\n\treturn lm3554_write(flash, LM3554_TORCH_BRIGHTNESS_REG, val);\n}\n\nstatic int lm3554_set_flash(struct lm3554 *flash)\n{\n\tu8 val;\n\n\tval = (flash->mode << LM3554_FLASH_MODE_SHIFT) |\n\t      (flash->flash_current << LM3554_FLASH_CURRENT_SHIFT);\n\n\treturn lm3554_write(flash, LM3554_FLASH_BRIGHTNESS_REG, val);\n}\n\nstatic int lm3554_set_duration(struct lm3554 *flash)\n{\n\tu8 val;\n\n\tval = (flash->timeout << LM3554_FLASH_TIMEOUT_SHIFT) |\n\t      (flash->pdata->current_limit << LM3554_CURRENT_LIMIT_SHIFT);\n\n\treturn lm3554_write(flash, LM3554_FLASH_DURATION_REG, val);\n}\n\nstatic int lm3554_set_config1(struct lm3554 *flash)\n{\n\tu8 val;\n\n\tval = (flash->pdata->envm_tx2 << LM3554_ENVM_TX2_SHIFT) |\n\t      (flash->pdata->tx2_polarity << LM3554_TX2_POLARITY_SHIFT);\n\treturn lm3554_write(flash, LM3554_CONFIG_REG_1, val);\n}\n\n \nstatic void lm3554_flash_off_delay(struct timer_list *t)\n{\n\tstruct lm3554 *flash = from_timer(flash, t, flash_off_delay);\n\tstruct lm3554_platform_data *pdata = flash->pdata;\n\n\tgpiod_set_value(pdata->gpio_strobe, 0);\n}\n\nstatic int lm3554_hw_strobe(struct i2c_client *client, bool strobe)\n{\n\tint ret, timer_pending;\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct lm3554 *flash = to_lm3554(sd);\n\tstruct lm3554_platform_data *pdata = flash->pdata;\n\n\t \n\n\ttimer_pending = del_timer_sync(&flash->flash_off_delay);\n\n\t \n\tif (!strobe) {\n\t\t \n\t\tret = lm3554_write(flash, LM3554_FLASH_BRIGHTNESS_REG, 0);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tmod_timer(&flash->flash_off_delay,\n\t\t\t  jiffies + msecs_to_jiffies(LM3554_TIMER_DELAY));\n\t\treturn 0;\n\t}\n\n\t \n\n\t \n\tif (timer_pending)\n\t\tgpiod_set_value(pdata->gpio_strobe, 0);\n\n\t \n\tret = lm3554_set_flash(flash);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tgpiod_set_value(pdata->gpio_strobe, 1);\n\n\treturn 0;\nerr:\n\tdev_err(&client->dev, \"failed to %s flash strobe (%d)\\n\",\n\t\tstrobe ? \"on\" : \"off\", ret);\n\treturn ret;\n}\n\n \n\nstatic int lm3554_read_status(struct lm3554 *flash)\n{\n\tint ret;\n\tstruct i2c_client *client = v4l2_get_subdevdata(&flash->sd);\n\n\t \n\tret = lm3554_read(flash, LM3554_FLAGS_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret &= ~LM3554_FLAG_UNUSED;\n\n\t \n\tret &= ~(LM3554_FLAG_TX1_INTERRUPT | LM3554_FLAG_TX2_INTERRUPT);\n\n\tif (ret > 0)\n\t\tdev_dbg(&client->dev, \"LM3554 flag status: %02x\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int lm3554_s_flash_timeout(struct v4l2_subdev *sd, u32 val)\n{\n\tstruct lm3554 *flash = to_lm3554(sd);\n\n\tval = clamp(val, LM3554_MIN_TIMEOUT, LM3554_MAX_TIMEOUT);\n\tval = val / LM3554_TIMEOUT_STEPSIZE - 1;\n\n\tflash->timeout = val;\n\n\treturn lm3554_set_duration(flash);\n}\n\nstatic int lm3554_g_flash_timeout(struct v4l2_subdev *sd, s32 *val)\n{\n\tstruct lm3554 *flash = to_lm3554(sd);\n\n\t*val = (u32)(flash->timeout + 1) * LM3554_TIMEOUT_STEPSIZE;\n\n\treturn 0;\n}\n\nstatic int lm3554_s_flash_intensity(struct v4l2_subdev *sd, u32 intensity)\n{\n\tstruct lm3554 *flash = to_lm3554(sd);\n\n\tintensity = LM3554_CLAMP_PERCENTAGE(intensity);\n\tintensity = LM3554_PERCENT_TO_VALUE(intensity, LM3554_FLASH_STEP);\n\n\tflash->flash_current = intensity;\n\n\treturn lm3554_set_flash(flash);\n}\n\nstatic int lm3554_g_flash_intensity(struct v4l2_subdev *sd, s32 *val)\n{\n\tstruct lm3554 *flash = to_lm3554(sd);\n\n\t*val = LM3554_VALUE_TO_PERCENT((u32)flash->flash_current,\n\t\t\t\t       LM3554_FLASH_STEP);\n\n\treturn 0;\n}\n\nstatic int lm3554_s_torch_intensity(struct v4l2_subdev *sd, u32 intensity)\n{\n\tstruct lm3554 *flash = to_lm3554(sd);\n\n\tintensity = LM3554_CLAMP_PERCENTAGE(intensity);\n\tintensity = LM3554_PERCENT_TO_VALUE(intensity, LM3554_TORCH_STEP);\n\n\tflash->torch_current = intensity;\n\n\treturn lm3554_set_torch(flash);\n}\n\nstatic int lm3554_g_torch_intensity(struct v4l2_subdev *sd, s32 *val)\n{\n\tstruct lm3554 *flash = to_lm3554(sd);\n\n\t*val = LM3554_VALUE_TO_PERCENT((u32)flash->torch_current,\n\t\t\t\t       LM3554_TORCH_STEP);\n\n\treturn 0;\n}\n\nstatic int lm3554_s_indicator_intensity(struct v4l2_subdev *sd, u32 intensity)\n{\n\tstruct lm3554 *flash = to_lm3554(sd);\n\n\tintensity = LM3554_CLAMP_PERCENTAGE(intensity);\n\tintensity = LM3554_PERCENT_TO_VALUE(intensity, LM3554_INDICATOR_STEP);\n\n\tflash->indicator_current = intensity;\n\n\treturn lm3554_set_torch(flash);\n}\n\nstatic int lm3554_g_indicator_intensity(struct v4l2_subdev *sd, s32 *val)\n{\n\tstruct lm3554 *flash = to_lm3554(sd);\n\n\t*val = LM3554_VALUE_TO_PERCENT((u32)flash->indicator_current,\n\t\t\t\t       LM3554_INDICATOR_STEP);\n\n\treturn 0;\n}\n\nstatic int lm3554_s_flash_strobe(struct v4l2_subdev *sd, u32 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn lm3554_hw_strobe(client, val);\n}\n\nstatic int lm3554_s_flash_mode(struct v4l2_subdev *sd, u32 new_mode)\n{\n\tstruct lm3554 *flash = to_lm3554(sd);\n\tunsigned int mode;\n\n\tswitch (new_mode) {\n\tcase ATOMISP_FLASH_MODE_OFF:\n\t\tmode = LM3554_MODE_SHUTDOWN;\n\t\tbreak;\n\tcase ATOMISP_FLASH_MODE_FLASH:\n\t\tmode = LM3554_MODE_FLASH;\n\t\tbreak;\n\tcase ATOMISP_FLASH_MODE_INDICATOR:\n\t\tmode = LM3554_MODE_INDICATOR;\n\t\tbreak;\n\tcase ATOMISP_FLASH_MODE_TORCH:\n\t\tmode = LM3554_MODE_TORCH;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn lm3554_set_mode(flash, mode);\n}\n\nstatic int lm3554_g_flash_mode(struct v4l2_subdev *sd, s32 *val)\n{\n\tstruct lm3554 *flash = to_lm3554(sd);\n\t*val = flash->mode;\n\treturn 0;\n}\n\nstatic int lm3554_g_flash_status(struct v4l2_subdev *sd, s32 *val)\n{\n\tstruct lm3554 *flash = to_lm3554(sd);\n\tint value;\n\n\tvalue = lm3554_read_status(flash);\n\tif (value < 0)\n\t\treturn value;\n\n\tif (value & LM3554_FLAG_TIMEOUT)\n\t\t*val = ATOMISP_FLASH_STATUS_TIMEOUT;\n\telse if (value > 0)\n\t\t*val = ATOMISP_FLASH_STATUS_HW_ERROR;\n\telse\n\t\t*val = ATOMISP_FLASH_STATUS_OK;\n\n\treturn 0;\n}\n\nstatic int lm3554_g_flash_status_register(struct v4l2_subdev *sd, s32 *val)\n{\n\tstruct lm3554 *flash = to_lm3554(sd);\n\tint ret;\n\n\tret = lm3554_read(flash, LM3554_FLAGS_REG);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\treturn 0;\n}\n\nstatic int lm3554_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct lm3554 *dev =\n\t    container_of(ctrl->handler, struct lm3554, ctrl_handler);\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_FLASH_TIMEOUT:\n\t\tret = lm3554_s_flash_timeout(&dev->sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FLASH_INTENSITY:\n\t\tret = lm3554_s_flash_intensity(&dev->sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FLASH_TORCH_INTENSITY:\n\t\tret = lm3554_s_torch_intensity(&dev->sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FLASH_INDICATOR_INTENSITY:\n\t\tret = lm3554_s_indicator_intensity(&dev->sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FLASH_STROBE:\n\t\tret = lm3554_s_flash_strobe(&dev->sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FLASH_MODE:\n\t\tret = lm3554_s_flash_mode(&dev->sd, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int lm3554_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct lm3554 *dev =\n\t    container_of(ctrl->handler, struct lm3554, ctrl_handler);\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_FLASH_TIMEOUT:\n\t\tret = lm3554_g_flash_timeout(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FLASH_INTENSITY:\n\t\tret = lm3554_g_flash_intensity(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FLASH_TORCH_INTENSITY:\n\t\tret = lm3554_g_torch_intensity(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FLASH_INDICATOR_INTENSITY:\n\t\tret = lm3554_g_indicator_intensity(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FLASH_MODE:\n\t\tret = lm3554_g_flash_mode(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FLASH_STATUS:\n\t\tret = lm3554_g_flash_status(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FLASH_STATUS_REGISTER:\n\t\tret = lm3554_g_flash_status_register(&dev->sd, &ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ctrl_ops = {\n\t.s_ctrl = lm3554_s_ctrl,\n\t.g_volatile_ctrl = lm3554_g_volatile_ctrl\n};\n\nstatic const struct v4l2_ctrl_config lm3554_controls[] = {\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_FLASH_TIMEOUT,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Flash Timeout\",\n\t\t.min = 0x0,\n\t\t.max = LM3554_MAX_TIMEOUT,\n\t\t.step = 0x01,\n\t\t.def = LM3554_DEFAULT_TIMEOUT,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_FLASH_INTENSITY,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Flash Intensity\",\n\t\t.min = LM3554_MIN_PERCENT,\n\t\t.max = LM3554_MAX_PERCENT,\n\t\t.step = 0x01,\n\t\t.def = LM3554_FLASH_DEFAULT_BRIGHTNESS,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_FLASH_TORCH_INTENSITY,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Torch Intensity\",\n\t\t.min = LM3554_MIN_PERCENT,\n\t\t.max = LM3554_MAX_PERCENT,\n\t\t.step = 0x01,\n\t\t.def = LM3554_TORCH_DEFAULT_BRIGHTNESS,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_FLASH_INDICATOR_INTENSITY,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Indicator Intensity\",\n\t\t.min = LM3554_MIN_PERCENT,\n\t\t.max = LM3554_MAX_PERCENT,\n\t\t.step = 0x01,\n\t\t.def = LM3554_INDICATOR_DEFAULT_BRIGHTNESS,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_FLASH_STROBE,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"Flash Strobe\",\n\t\t.min = 0,\n\t\t.max = 1,\n\t\t.step = 1,\n\t\t.def = 0,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_FLASH_MODE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Flash Mode\",\n\t\t.min = 0,\n\t\t.max = 100,\n\t\t.step = 1,\n\t\t.def = ATOMISP_FLASH_MODE_OFF,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_FLASH_STATUS,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Flash Status\",\n\t\t.min = ATOMISP_FLASH_STATUS_OK,\n\t\t.max = ATOMISP_FLASH_STATUS_TIMEOUT,\n\t\t.step = 1,\n\t\t.def = ATOMISP_FLASH_STATUS_OK,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.ops = &ctrl_ops,\n\t\t.id = V4L2_CID_FLASH_STATUS_REGISTER,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Flash Status Register\",\n\t\t.min = 0,\n\t\t.max = 255,\n\t\t.step = 1,\n\t\t.def = 0,\n\t\t.flags = 0,\n\t},\n};\n\n \n\n \nstatic int lm3554_setup(struct lm3554 *flash)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&flash->sd);\n\tint ret;\n\n\t \n\tret = lm3554_read(flash, LM3554_FLAGS_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(&client->dev, \"Fault info: %02x\\n\", ret);\n\n\tret = lm3554_set_config1(flash);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lm3554_set_duration(flash);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lm3554_set_torch(flash);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lm3554_set_flash(flash);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = lm3554_read_status(flash);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret ? -EIO : 0;\n}\n\nstatic int __lm3554_s_power(struct lm3554 *flash, int power)\n{\n\tstruct lm3554_platform_data *pdata = flash->pdata;\n\tint ret;\n\n\t \n\tgpiod_set_value(pdata->gpio_reset, power);\n\tusleep_range(100, 100 + 1);\n\n\tif (power) {\n\t\t \n\t\tret = lm3554_setup(flash);\n\t\tif (ret < 0) {\n\t\t\t__lm3554_s_power(flash, 0);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lm3554_s_power(struct v4l2_subdev *sd, int power)\n{\n\tstruct lm3554 *flash = to_lm3554(sd);\n\tint ret = 0;\n\n\tmutex_lock(&flash->power_lock);\n\n\tif (flash->power_count == !power) {\n\t\tret = __lm3554_s_power(flash, !!power);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tflash->power_count += power ? 1 : -1;\n\tWARN_ON(flash->power_count < 0);\n\ndone:\n\tmutex_unlock(&flash->power_lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_core_ops lm3554_core_ops = {\n\t.s_power = lm3554_s_power,\n};\n\nstatic const struct v4l2_subdev_ops lm3554_ops = {\n\t.core = &lm3554_core_ops,\n};\n\nstatic int lm3554_detect(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct lm3554 *flash = to_lm3554(sd);\n\tint ret;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&client->dev, \"lm3554_detect i2c error\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = lm3554_s_power(&flash->sd, 1);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to power on lm3554 LED flash\\n\");\n\t} else {\n\t\tdev_dbg(&client->dev, \"Successfully detected lm3554 LED flash\\n\");\n\t\tlm3554_s_power(&flash->sd, 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int lm3554_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\treturn lm3554_s_power(sd, 1);\n}\n\nstatic int lm3554_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\treturn lm3554_s_power(sd, 0);\n}\n\nstatic const struct v4l2_subdev_internal_ops lm3554_internal_ops = {\n\t.registered = lm3554_detect,\n\t.open = lm3554_open,\n\t.close = lm3554_close,\n};\n\n \n#ifdef CONFIG_PM\n\nstatic int lm3554_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct lm3554 *flash = to_lm3554(subdev);\n\tint rval;\n\n\tif (flash->power_count == 0)\n\t\treturn 0;\n\n\trval = __lm3554_s_power(flash, 0);\n\n\tdev_dbg(&client->dev, \"Suspend %s\\n\", rval < 0 ? \"failed\" : \"ok\");\n\n\treturn rval;\n}\n\nstatic int lm3554_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct lm3554 *flash = to_lm3554(subdev);\n\tint rval;\n\n\tif (flash->power_count == 0)\n\t\treturn 0;\n\n\trval = __lm3554_s_power(flash, 1);\n\n\tdev_dbg(&client->dev, \"Resume %s\\n\", rval < 0 ? \"fail\" : \"ok\");\n\n\treturn rval;\n}\n\n#else\n\n#define lm3554_suspend NULL\n#define lm3554_resume  NULL\n\n#endif  \n\nstatic int lm3554_gpio_init(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct lm3554 *flash = to_lm3554(sd);\n\tstruct lm3554_platform_data *pdata = flash->pdata;\n\tint ret;\n\n\tif (!pdata->gpio_reset)\n\t\treturn -EINVAL;\n\n\tret = gpiod_direction_output(pdata->gpio_reset, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!pdata->gpio_strobe)\n\t\treturn -EINVAL;\n\n\tret = gpiod_direction_output(pdata->gpio_strobe, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void lm3554_gpio_uninit(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct lm3554 *flash = to_lm3554(sd);\n\tstruct lm3554_platform_data *pdata = flash->pdata;\n\tint ret;\n\n\tret = gpiod_direction_output(pdata->gpio_strobe, 0);\n\tif (ret < 0)\n\t\tdev_err(&client->dev,\n\t\t\t\"gpio request/direction_output fail for gpio_strobe\");\n\n\tret = gpiod_direction_output(pdata->gpio_reset, 0);\n\tif (ret < 0)\n\t\tdev_err(&client->dev,\n\t\t\t\"gpio request/direction_output fail for gpio_reset\");\n}\n\nstatic void *lm3554_platform_data_func(struct i2c_client *client)\n{\n\tstatic struct lm3554_platform_data platform_data;\n\n\tplatform_data.gpio_reset = gpiod_get_index(&client->dev,\n\t\t\t\t\t\t   NULL, 2, GPIOD_OUT_LOW);\n\tif (IS_ERR(platform_data.gpio_reset))\n\t\treturn ERR_CAST(platform_data.gpio_reset);\n\tplatform_data.gpio_strobe = gpiod_get_index(&client->dev,\n\t\t\t\t\t\t    NULL, 0, GPIOD_OUT_LOW);\n\tif (IS_ERR(platform_data.gpio_strobe))\n\t\treturn ERR_CAST(platform_data.gpio_strobe);\n\tplatform_data.gpio_torch = gpiod_get_index(&client->dev,\n\t\t\t\t\t\t   NULL, 1, GPIOD_OUT_LOW);\n\tif (IS_ERR(platform_data.gpio_torch))\n\t\treturn ERR_CAST(platform_data.gpio_torch);\n\n\t \n\tplatform_data.envm_tx2 = 1;\n\tplatform_data.tx2_polarity = 0;\n\n\t \n\tplatform_data.current_limit = 0;\n\n\treturn &platform_data;\n}\n\nstatic int lm3554_probe(struct i2c_client *client)\n{\n\tint err = 0;\n\tstruct lm3554 *flash;\n\tunsigned int i;\n\n\tflash = kzalloc(sizeof(*flash), GFP_KERNEL);\n\tif (!flash)\n\t\treturn -ENOMEM;\n\n\tflash->pdata = lm3554_platform_data_func(client);\n\tif (IS_ERR(flash->pdata)) {\n\t\terr = PTR_ERR(flash->pdata);\n\t\tgoto free_flash;\n\t}\n\n\tv4l2_i2c_subdev_init(&flash->sd, client, &lm3554_ops);\n\tflash->sd.internal_ops = &lm3554_internal_ops;\n\tflash->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tflash->mode = ATOMISP_FLASH_MODE_OFF;\n\tflash->timeout = LM3554_MAX_TIMEOUT / LM3554_TIMEOUT_STEPSIZE - 1;\n\terr =\n\t    v4l2_ctrl_handler_init(&flash->ctrl_handler,\n\t\t\t\t   ARRAY_SIZE(lm3554_controls));\n\tif (err) {\n\t\tdev_err(&client->dev, \"error initialize a ctrl_handler.\\n\");\n\t\tgoto unregister_subdev;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(lm3554_controls); i++)\n\t\tv4l2_ctrl_new_custom(&flash->ctrl_handler, &lm3554_controls[i],\n\t\t\t\t     NULL);\n\n\tif (flash->ctrl_handler.error) {\n\t\tdev_err(&client->dev, \"ctrl_handler error.\\n\");\n\t\terr = flash->ctrl_handler.error;\n\t\tgoto free_handler;\n\t}\n\n\tflash->sd.ctrl_handler = &flash->ctrl_handler;\n\terr = media_entity_pads_init(&flash->sd.entity, 0, NULL);\n\tif (err) {\n\t\tdev_err(&client->dev, \"error initialize a media entity.\\n\");\n\t\tgoto free_handler;\n\t}\n\n\tflash->sd.entity.function = MEDIA_ENT_F_FLASH;\n\n\tmutex_init(&flash->power_lock);\n\n\ttimer_setup(&flash->flash_off_delay, lm3554_flash_off_delay, 0);\n\n\terr = lm3554_gpio_init(client);\n\tif (err) {\n\t\tdev_err(&client->dev, \"gpio request/direction_output fail.\\n\");\n\t\tgoto cleanup_media;\n\t}\n\n\terr = atomisp_register_i2c_module(&flash->sd, NULL, LED_FLASH);\n\tif (err) {\n\t\tdev_err(&client->dev, \"fail to register atomisp i2c module.\\n\");\n\t\tgoto uninit_gpio;\n\t}\n\n\treturn 0;\n\nuninit_gpio:\n\tlm3554_gpio_uninit(client);\ncleanup_media:\n\tmedia_entity_cleanup(&flash->sd.entity);\nfree_handler:\n\tv4l2_ctrl_handler_free(&flash->ctrl_handler);\nunregister_subdev:\n\tv4l2_device_unregister_subdev(&flash->sd);\nfree_flash:\n\tkfree(flash);\n\n\treturn err;\n}\n\nstatic void lm3554_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct lm3554 *flash = to_lm3554(sd);\n\n\tmedia_entity_cleanup(&flash->sd.entity);\n\tv4l2_ctrl_handler_free(&flash->ctrl_handler);\n\tv4l2_device_unregister_subdev(sd);\n\n\tatomisp_gmin_remove_subdev(sd);\n\n\ttimer_shutdown_sync(&flash->flash_off_delay);\n\n\tlm3554_gpio_uninit(client);\n\n\tkfree(flash);\n}\n\nstatic const struct dev_pm_ops lm3554_pm_ops = {\n\t.suspend = lm3554_suspend,\n\t.resume = lm3554_resume,\n};\n\nstatic const struct acpi_device_id lm3554_acpi_match[] = {\n\t{ \"INTCF1C\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, lm3554_acpi_match);\n\nstatic struct i2c_driver lm3554_driver = {\n\t.driver = {\n\t\t.name = \"lm3554\",\n\t\t.pm   = &lm3554_pm_ops,\n\t\t.acpi_match_table = lm3554_acpi_match,\n\t},\n\t.probe = lm3554_probe,\n\t.remove = lm3554_remove,\n};\nmodule_i2c_driver(lm3554_driver);\n\nMODULE_AUTHOR(\"Jing Tao <jing.tao@intel.com>\");\nMODULE_DESCRIPTION(\"LED flash driver for LM3554\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}