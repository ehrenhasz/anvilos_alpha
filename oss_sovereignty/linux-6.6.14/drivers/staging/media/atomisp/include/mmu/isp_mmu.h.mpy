{
  "module_name": "isp_mmu.h",
  "hash_id": "d34b00db2f22fa8b8a7bd67eacf8c36290c477211387641803596b3823360fb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/atomisp/include/mmu/isp_mmu.h",
  "human_readable_source": " \n \n \n#ifndef\t__ISP_MMU_H__\n#define\t__ISP_MMU_H__\n\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\n \n#define\tISP_PAGE_OFFSET\t\t12\n#define\tISP_PAGE_SIZE\t\tBIT(ISP_PAGE_OFFSET)\n#define\tISP_PAGE_MASK\t\t(~(phys_addr_t)(ISP_PAGE_SIZE - 1))\n\n#define\tISP_L1PT_OFFSET\t\t22\n#define\tISP_L1PT_MASK\t\t(~((1U << ISP_L1PT_OFFSET) - 1))\n\n#define\tISP_L2PT_OFFSET\t\t12\n#define\tISP_L2PT_MASK\t\t(~(ISP_L1PT_MASK | (~(ISP_PAGE_MASK))))\n\n#define\tISP_L1PT_PTES\t\t1024\n#define\tISP_L2PT_PTES\t\t1024\n\n#define\tISP_PTR_TO_L1_IDX(x)\t((((x) & ISP_L1PT_MASK)) \\\n\t\t\t\t\t>> ISP_L1PT_OFFSET)\n\n#define\tISP_PTR_TO_L2_IDX(x)\t((((x) & ISP_L2PT_MASK)) \\\n\t\t\t\t\t>> ISP_L2PT_OFFSET)\n\n#define\tISP_PAGE_ALIGN(x)\t(((x) + (ISP_PAGE_SIZE - 1)) \\\n\t\t\t\t\t& ISP_PAGE_MASK)\n\n#define\tISP_PT_TO_VIRT(l1_idx, l2_idx, offset) do {\\\n\t\t((l1_idx) << ISP_L1PT_OFFSET) | \\\n\t\t((l2_idx) << ISP_L2PT_OFFSET) | \\\n\t\t(offset)\\\n} while (0)\n\n#define\tpgnr_to_size(pgnr)\t((pgnr) << ISP_PAGE_OFFSET)\n#define\tsize_to_pgnr_ceil(size)\t(((size) + (1 << ISP_PAGE_OFFSET) - 1)\\\n\t\t\t\t\t\t>> ISP_PAGE_OFFSET)\n#define\tsize_to_pgnr_bottom(size)\t((size) >> ISP_PAGE_OFFSET)\n\nstruct isp_mmu;\n\nstruct isp_mmu_client {\n\t \n\tchar *name;\n\tunsigned int pte_valid_mask;\n\tunsigned int null_pte;\n\n\t \n\tunsigned int (*get_pd_base)(struct isp_mmu *mmu, phys_addr_t pd_base);\n\t \n\tvoid (*tlb_flush_range)(struct isp_mmu *mmu,\n\t\t\t\tunsigned int addr, unsigned int size);\n\tvoid (*tlb_flush_all)(struct isp_mmu *mmu);\n\tunsigned int (*phys_to_pte)(struct isp_mmu *mmu,\n\t\t\t\t    phys_addr_t phys);\n\tphys_addr_t (*pte_to_phys)(struct isp_mmu *mmu,\n\t\t\t\t   unsigned int pte);\n\n};\n\nstruct isp_mmu {\n\tstruct isp_mmu_client *driver;\n\tunsigned int l1_pte;\n\tint l2_pgt_refcount[ISP_L1PT_PTES];\n\tphys_addr_t base_address;\n\n\tstruct mutex pt_mutex;\n};\n\n \n#define\tISP_PTE_VALID_MASK(mmu)\t\\\n\t((mmu)->driver->pte_valid_mask)\n\n#define\tISP_PTE_VALID(mmu, pte)\t\\\n\t((pte) & ISP_PTE_VALID_MASK(mmu))\n\n#define\tNULL_PAGE\t((phys_addr_t)(-1) & ISP_PAGE_MASK)\n#define\tPAGE_VALID(page)\t((page) != NULL_PAGE)\n\n \nint isp_mmu_init(struct isp_mmu *mmu, struct isp_mmu_client *driver);\n \nvoid isp_mmu_exit(struct isp_mmu *mmu);\n\n \nint isp_mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,\n\t\tphys_addr_t phys, unsigned int pgnr);\n\nvoid isp_mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,\n\t\t   unsigned int pgnr);\n\nstatic inline void isp_mmu_flush_tlb_all(struct isp_mmu *mmu)\n{\n\tif (mmu->driver && mmu->driver->tlb_flush_all)\n\t\tmmu->driver->tlb_flush_all(mmu);\n}\n\n#define isp_mmu_flush_tlb isp_mmu_flush_tlb_all\n\nstatic inline void isp_mmu_flush_tlb_range(struct isp_mmu *mmu,\n\tunsigned int start, unsigned int size)\n{\n\tif (mmu->driver && mmu->driver->tlb_flush_range)\n\t\tmmu->driver->tlb_flush_range(mmu, start, size);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}