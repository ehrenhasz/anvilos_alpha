{
  "module_name": "ipu3-css-fw.c",
  "hash_id": "1b5257b61a0c2d74f69a8e6c83b7886660cecf0d6eca5fd596831f272ecdb047",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/ipu3/ipu3-css-fw.c",
  "human_readable_source": "\n\n\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#include \"ipu3-css.h\"\n#include \"ipu3-css-fw.h\"\n#include \"ipu3-dmamap.h\"\n\nstatic void imgu_css_fw_show_binary(struct device *dev, struct imgu_fw_info *bi,\n\t\t\t\t    const char *name)\n{\n\tunsigned int i;\n\n\tdev_dbg(dev, \"found firmware binary type %i size %i name %s\\n\",\n\t\tbi->type, bi->blob.size, name);\n\tif (bi->type != IMGU_FW_ISP_FIRMWARE)\n\t\treturn;\n\n\tdev_dbg(dev, \"    id %i mode %i bds 0x%x veceven %i/%i out_pins %i\\n\",\n\t\tbi->info.isp.sp.id, bi->info.isp.sp.pipeline.mode,\n\t\tbi->info.isp.sp.bds.supported_bds_factors,\n\t\tbi->info.isp.sp.enable.vf_veceven,\n\t\tbi->info.isp.sp.vf_dec.is_variable,\n\t\tbi->info.isp.num_output_pins);\n\n\tdev_dbg(dev, \"    input (%i,%i)-(%i,%i) formats %s%s%s\\n\",\n\t\tbi->info.isp.sp.input.min_width,\n\t\tbi->info.isp.sp.input.min_height,\n\t\tbi->info.isp.sp.input.max_width,\n\t\tbi->info.isp.sp.input.max_height,\n\t\tbi->info.isp.sp.enable.input_yuv ? \"yuv420 \" : \"\",\n\t\tbi->info.isp.sp.enable.input_feeder ||\n\t\tbi->info.isp.sp.enable.input_raw ? \"raw8 raw10 \" : \"\",\n\t\tbi->info.isp.sp.enable.input_raw ? \"raw12\" : \"\");\n\n\tdev_dbg(dev, \"    internal (%i,%i)\\n\",\n\t\tbi->info.isp.sp.internal.max_width,\n\t\tbi->info.isp.sp.internal.max_height);\n\n\tdev_dbg(dev, \"    output (%i,%i)-(%i,%i) formats\",\n\t\tbi->info.isp.sp.output.min_width,\n\t\tbi->info.isp.sp.output.min_height,\n\t\tbi->info.isp.sp.output.max_width,\n\t\tbi->info.isp.sp.output.max_height);\n\tfor (i = 0; i < bi->info.isp.num_output_formats; i++)\n\t\tdev_dbg(dev, \" %i\", bi->info.isp.output_formats[i]);\n\tdev_dbg(dev, \" vf\");\n\tfor (i = 0; i < bi->info.isp.num_vf_formats; i++)\n\t\tdev_dbg(dev, \" %i\", bi->info.isp.vf_formats[i]);\n\tdev_dbg(dev, \"\\n\");\n}\n\nunsigned int imgu_css_fw_obgrid_size(const struct imgu_fw_info *bi)\n{\n\tunsigned int width = DIV_ROUND_UP(bi->info.isp.sp.internal.max_width,\n\t\t\t\t\t  IMGU_OBGRID_TILE_SIZE * 2) + 1;\n\tunsigned int height = DIV_ROUND_UP(bi->info.isp.sp.internal.max_height,\n\t\t\t\t\t   IMGU_OBGRID_TILE_SIZE * 2) + 1;\n\tunsigned int obgrid_size;\n\n\twidth = ALIGN(width, IPU3_UAPI_ISP_VEC_ELEMS / 4);\n\tobgrid_size = PAGE_ALIGN(width * height *\n\t\t\t\t sizeof(struct ipu3_uapi_obgrid_param)) *\n\t\t\t\t bi->info.isp.sp.iterator.num_stripes;\n\treturn obgrid_size;\n}\n\nvoid *imgu_css_fw_pipeline_params(struct imgu_css *css, unsigned int pipe,\n\t\t\t\t  enum imgu_abi_param_class cls,\n\t\t\t\t  enum imgu_abi_memories mem,\n\t\t\t\t  struct imgu_fw_isp_parameter *par,\n\t\t\t\t  size_t par_size, void *binary_params)\n{\n\tstruct imgu_fw_info *bi =\n\t\t&css->fwp->binary_header[css->pipes[pipe].bindex];\n\n\tif (par->offset + par->size >\n\t    bi->info.isp.sp.mem_initializers.params[cls][mem].size)\n\t\treturn NULL;\n\n\tif (par->size != par_size)\n\t\tpr_warn(\"parameter size doesn't match defined size\\n\");\n\n\tif (par->size < par_size)\n\t\treturn NULL;\n\n\treturn binary_params + par->offset;\n}\n\nvoid imgu_css_fw_cleanup(struct imgu_css *css)\n{\n\tstruct imgu_device *imgu = dev_get_drvdata(css->dev);\n\n\tif (css->binary) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < css->fwp->file_header.binary_nr; i++)\n\t\t\timgu_dmamap_free(imgu, &css->binary[i]);\n\t\tkfree(css->binary);\n\t}\n\tif (css->fw)\n\t\trelease_firmware(css->fw);\n\n\tcss->binary = NULL;\n\tcss->fw = NULL;\n}\n\nint imgu_css_fw_init(struct imgu_css *css)\n{\n\tstatic const u32 BLOCK_MAX = 65536;\n\tstruct imgu_device *imgu = dev_get_drvdata(css->dev);\n\tstruct device *dev = css->dev;\n\tunsigned int i, j, binary_nr;\n\tint r;\n\n\tr = request_firmware(&css->fw, IMGU_FW_NAME_20161208, css->dev);\n\tif (r == -ENOENT)\n\t\tr = request_firmware(&css->fw, IMGU_FW_NAME, css->dev);\n\tif (r)\n\t\treturn r;\n\n\t \n\n\tcss->fwp = (struct imgu_fw_header *)css->fw->data;\n\tif (css->fw->size < struct_size(css->fwp, binary_header, 1) ||\n\t    css->fwp->file_header.h_size != sizeof(struct imgu_fw_bi_file_h))\n\t\tgoto bad_fw;\n\tif (struct_size(css->fwp, binary_header,\n\t\t\tcss->fwp->file_header.binary_nr) > css->fw->size)\n\t\tgoto bad_fw;\n\n\tdev_info(dev, \"loaded firmware version %.64s, %u binaries, %zu bytes\\n\",\n\t\t css->fwp->file_header.version, css->fwp->file_header.binary_nr,\n\t\t css->fw->size);\n\n\t \n\n\tbinary_nr = css->fwp->file_header.binary_nr;\n\n\tcss->fw_bl = -1;\n\tcss->fw_sp[0] = -1;\n\tcss->fw_sp[1] = -1;\n\n\tfor (i = 0; i < binary_nr; i++) {\n\t\tstruct imgu_fw_info *bi = &css->fwp->binary_header[i];\n\t\tconst char *name = (void *)css->fwp + bi->blob.prog_name_offset;\n\t\tsize_t len;\n\n\t\tif (bi->blob.prog_name_offset >= css->fw->size)\n\t\t\tgoto bad_fw;\n\t\tlen = strnlen(name, css->fw->size - bi->blob.prog_name_offset);\n\t\tif (len + 1 > css->fw->size - bi->blob.prog_name_offset ||\n\t\t    len + 1 >= IMGU_ABI_MAX_BINARY_NAME)\n\t\t\tgoto bad_fw;\n\n\t\tif (bi->blob.size != bi->blob.text_size + bi->blob.icache_size\n\t\t    + bi->blob.data_size + bi->blob.padding_size)\n\t\t\tgoto bad_fw;\n\t\tif (bi->blob.offset + bi->blob.size > css->fw->size)\n\t\t\tgoto bad_fw;\n\n\t\tif (bi->type == IMGU_FW_BOOTLOADER_FIRMWARE) {\n\t\t\tcss->fw_bl = i;\n\t\t\tif (bi->info.bl.sw_state >= css->iomem_length ||\n\t\t\t    bi->info.bl.num_dma_cmds >= css->iomem_length ||\n\t\t\t    bi->info.bl.dma_cmd_list >= css->iomem_length)\n\t\t\t\tgoto bad_fw;\n\t\t}\n\t\tif (bi->type == IMGU_FW_SP_FIRMWARE ||\n\t\t    bi->type == IMGU_FW_SP1_FIRMWARE) {\n\t\t\tcss->fw_sp[bi->type == IMGU_FW_SP_FIRMWARE ? 0 : 1] = i;\n\t\t\tif (bi->info.sp.per_frame_data >= css->iomem_length ||\n\t\t\t    bi->info.sp.init_dmem_data >= css->iomem_length ||\n\t\t\t    bi->info.sp.host_sp_queue >= css->iomem_length ||\n\t\t\t    bi->info.sp.isp_started >= css->iomem_length ||\n\t\t\t    bi->info.sp.sw_state >= css->iomem_length ||\n\t\t\t    bi->info.sp.sleep_mode >= css->iomem_length ||\n\t\t\t    bi->info.sp.invalidate_tlb >= css->iomem_length ||\n\t\t\t    bi->info.sp.host_sp_com >= css->iomem_length ||\n\t\t\t    bi->info.sp.output + 12 >= css->iomem_length ||\n\t\t\t    bi->info.sp.host_sp_queues_initialized >=\n\t\t\t    css->iomem_length)\n\t\t\t\tgoto bad_fw;\n\t\t}\n\t\tif (bi->type != IMGU_FW_ISP_FIRMWARE)\n\t\t\tcontinue;\n\n\t\tif (bi->info.isp.sp.pipeline.mode >= IPU3_CSS_PIPE_ID_NUM)\n\t\t\tgoto bad_fw;\n\n\t\tif (bi->info.isp.sp.iterator.num_stripes >\n\t\t    IPU3_UAPI_MAX_STRIPES)\n\t\t\tgoto bad_fw;\n\n\t\tif (bi->info.isp.num_vf_formats > IMGU_ABI_FRAME_FORMAT_NUM ||\n\t\t    bi->info.isp.num_output_formats > IMGU_ABI_FRAME_FORMAT_NUM)\n\t\t\tgoto bad_fw;\n\n\t\tfor (j = 0; j < bi->info.isp.num_output_formats; j++)\n\t\t\tif (bi->info.isp.output_formats[j] >=\n\t\t\t    IMGU_ABI_FRAME_FORMAT_NUM)\n\t\t\t\tgoto bad_fw;\n\t\tfor (j = 0; j < bi->info.isp.num_vf_formats; j++)\n\t\t\tif (bi->info.isp.vf_formats[j] >=\n\t\t\t    IMGU_ABI_FRAME_FORMAT_NUM)\n\t\t\t\tgoto bad_fw;\n\n\t\tif (bi->info.isp.sp.block.block_width <= 0 ||\n\t\t    bi->info.isp.sp.block.block_width > BLOCK_MAX ||\n\t\t    bi->info.isp.sp.block.output_block_height <= 0 ||\n\t\t    bi->info.isp.sp.block.output_block_height > BLOCK_MAX)\n\t\t\tgoto bad_fw;\n\n\t\tif (bi->blob.memory_offsets.offsets[IMGU_ABI_PARAM_CLASS_PARAM]\n\t\t    + sizeof(struct imgu_fw_param_memory_offsets) >\n\t\t    css->fw->size ||\n\t\t    bi->blob.memory_offsets.offsets[IMGU_ABI_PARAM_CLASS_CONFIG]\n\t\t    + sizeof(struct imgu_fw_config_memory_offsets) >\n\t\t    css->fw->size ||\n\t\t    bi->blob.memory_offsets.offsets[IMGU_ABI_PARAM_CLASS_STATE]\n\t\t    + sizeof(struct imgu_fw_state_memory_offsets) >\n\t\t    css->fw->size)\n\t\t\tgoto bad_fw;\n\n\t\timgu_css_fw_show_binary(dev, bi, name);\n\t}\n\n\tif (css->fw_bl == -1 || css->fw_sp[0] == -1 || css->fw_sp[1] == -1)\n\t\tgoto bad_fw;\n\n\t \n\n\tcss->binary = kcalloc(binary_nr, sizeof(*css->binary), GFP_KERNEL);\n\tif (!css->binary) {\n\t\tr = -ENOMEM;\n\t\tgoto error_out;\n\t}\n\n\tfor (i = 0; i < css->fwp->file_header.binary_nr; i++) {\n\t\tstruct imgu_fw_info *bi = &css->fwp->binary_header[i];\n\t\tvoid *blob = (void *)css->fwp + bi->blob.offset;\n\t\tsize_t size = bi->blob.size;\n\n\t\tif (!imgu_dmamap_alloc(imgu, &css->binary[i], size)) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto error_out;\n\t\t}\n\t\tmemcpy(css->binary[i].vaddr, blob, size);\n\t}\n\n\treturn 0;\n\nbad_fw:\n\tdev_err(dev, \"invalid firmware binary, size %u\\n\", (int)css->fw->size);\n\tr = -ENODEV;\n\nerror_out:\n\timgu_css_fw_cleanup(css);\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}