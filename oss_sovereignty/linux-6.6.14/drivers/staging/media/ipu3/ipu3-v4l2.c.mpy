{
  "module_name": "ipu3-v4l2.c",
  "hash_id": "4e8fa233cfc11a94beadf28a2ed286fcfaf863b31b24fb91f2580139c7e710a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/ipu3/ipu3-v4l2.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"ipu3.h\"\n#include \"ipu3-dmamap.h\"\n\n \n\n#define IPU3_RUNNING_MODE_VIDEO\t\t0\n#define IPU3_RUNNING_MODE_STILL\t\t1\n\nstatic int imgu_subdev_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct imgu_v4l2_subdev *imgu_sd = container_of(sd,\n\t\t\t\t\t\t\tstruct imgu_v4l2_subdev,\n\t\t\t\t\t\t\tsubdev);\n\tstruct imgu_device *imgu = v4l2_get_subdevdata(sd);\n\tstruct imgu_media_pipe *imgu_pipe = &imgu->imgu_pipe[imgu_sd->pipe];\n\tstruct v4l2_rect try_crop = {\n\t\t.top = 0,\n\t\t.left = 0,\n\t};\n\tunsigned int i;\n\n\ttry_crop.width =\n\t\timgu_pipe->nodes[IMGU_NODE_IN].vdev_fmt.fmt.pix_mp.width;\n\ttry_crop.height =\n\t\timgu_pipe->nodes[IMGU_NODE_IN].vdev_fmt.fmt.pix_mp.height;\n\n\t \n\tfor (i = 0; i < IMGU_NODE_NUM; i++) {\n\t\tstruct v4l2_mbus_framefmt *try_fmt =\n\t\t\tv4l2_subdev_get_try_format(sd, fh->state, i);\n\n\t\ttry_fmt->width = try_crop.width;\n\t\ttry_fmt->height = try_crop.height;\n\t\ttry_fmt->code = imgu_pipe->nodes[i].pad_fmt.code;\n\t\ttry_fmt->field = V4L2_FIELD_NONE;\n\t}\n\n\t*v4l2_subdev_get_try_crop(sd, fh->state, IMGU_NODE_IN) = try_crop;\n\t*v4l2_subdev_get_try_compose(sd, fh->state, IMGU_NODE_IN) = try_crop;\n\n\treturn 0;\n}\n\nstatic int imgu_subdev_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tint i;\n\tunsigned int node;\n\tint r = 0;\n\tstruct imgu_device *imgu = v4l2_get_subdevdata(sd);\n\tstruct imgu_v4l2_subdev *imgu_sd = container_of(sd,\n\t\t\t\t\t\t\tstruct imgu_v4l2_subdev,\n\t\t\t\t\t\t\tsubdev);\n\tunsigned int pipe = imgu_sd->pipe;\n\tstruct device *dev = &imgu->pci_dev->dev;\n\tstruct v4l2_pix_format_mplane *fmts[IPU3_CSS_QUEUES] = { NULL };\n\tstruct v4l2_rect *rects[IPU3_CSS_RECTS] = { NULL };\n\tstruct imgu_css_pipe *css_pipe = &imgu->css.pipes[pipe];\n\tstruct imgu_media_pipe *imgu_pipe = &imgu->imgu_pipe[pipe];\n\n\tdev_dbg(dev, \"%s %d for pipe %u\", __func__, enable, pipe);\n\t \n\tv4l2_ctrl_grab(imgu_sd->ctrl, enable);\n\n\tif (!enable) {\n\t\timgu_sd->active = false;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < IMGU_NODE_NUM; i++)\n\t\timgu_pipe->queue_enabled[i] = imgu_pipe->nodes[i].enabled;\n\n\t \n\timgu_pipe->queue_enabled[IPU3_CSS_QUEUE_PARAMS] = false;\n\n\t \n\tfor (i = 0; i < IPU3_CSS_QUEUES; i++) {\n\t\tnode = imgu_map_node(imgu, i);\n\t\t \n\t\tif (node == IMGU_NODE_STAT_3A || node == IMGU_NODE_PARAMS)\n\t\t\tcontinue;\n\t\tfmts[i] = imgu_pipe->queue_enabled[node] ?\n\t\t\t&imgu_pipe->nodes[node].vdev_fmt.fmt.pix_mp : NULL;\n\t}\n\n\t \n\tcss_pipe->vf_output_en = false;\n\tif (imgu_pipe->nodes[IMGU_NODE_VF].enabled)\n\t\tcss_pipe->vf_output_en = true;\n\n\tif (atomic_read(&imgu_sd->running_mode) == IPU3_RUNNING_MODE_VIDEO)\n\t\tcss_pipe->pipe_id = IPU3_CSS_PIPE_ID_VIDEO;\n\telse\n\t\tcss_pipe->pipe_id = IPU3_CSS_PIPE_ID_CAPTURE;\n\n\tdev_dbg(dev, \"IPU3 pipe %u pipe_id %u\", pipe, css_pipe->pipe_id);\n\n\trects[IPU3_CSS_RECT_EFFECTIVE] = &imgu_sd->rect.eff;\n\trects[IPU3_CSS_RECT_BDS] = &imgu_sd->rect.bds;\n\trects[IPU3_CSS_RECT_GDC] = &imgu_sd->rect.gdc;\n\n\tr = imgu_css_fmt_set(&imgu->css, fmts, rects, pipe);\n\tif (r) {\n\t\tdev_err(dev, \"failed to set initial formats pipe %u with (%d)\",\n\t\t\tpipe, r);\n\t\treturn r;\n\t}\n\n\timgu_sd->active = true;\n\n\treturn 0;\n}\n\nstatic int imgu_subdev_get_fmt(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_format *fmt)\n{\n\tstruct imgu_device *imgu = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *mf;\n\tstruct imgu_media_pipe *imgu_pipe;\n\tu32 pad = fmt->pad;\n\tstruct imgu_v4l2_subdev *imgu_sd = container_of(sd,\n\t\t\t\t\t\t\tstruct imgu_v4l2_subdev,\n\t\t\t\t\t\t\tsubdev);\n\tunsigned int pipe = imgu_sd->pipe;\n\n\timgu_pipe = &imgu->imgu_pipe[pipe];\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tfmt->format = imgu_pipe->nodes[pad].pad_fmt;\n\t} else {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, pad);\n\t\tfmt->format = *mf;\n\t}\n\n\treturn 0;\n}\n\nstatic int imgu_subdev_set_fmt(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_format *fmt)\n{\n\tstruct imgu_media_pipe *imgu_pipe;\n\tstruct imgu_device *imgu = v4l2_get_subdevdata(sd);\n\tstruct imgu_v4l2_subdev *imgu_sd = container_of(sd,\n\t\t\t\t\t\t\tstruct imgu_v4l2_subdev,\n\t\t\t\t\t\t\tsubdev);\n\tstruct v4l2_mbus_framefmt *mf;\n\tu32 pad = fmt->pad;\n\tunsigned int pipe = imgu_sd->pipe;\n\n\tdev_dbg(&imgu->pci_dev->dev, \"set subdev %u pad %u fmt to [%ux%u]\",\n\t\tpipe, pad, fmt->format.width, fmt->format.height);\n\n\timgu_pipe = &imgu->imgu_pipe[pipe];\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, pad);\n\telse\n\t\tmf = &imgu_pipe->nodes[pad].pad_fmt;\n\n\tfmt->format.code = mf->code;\n\t \n\tif (imgu_sd->subdev_pads[pad].flags & MEDIA_PAD_FL_SOURCE) {\n\t\tfmt->format.width = clamp(fmt->format.width,\n\t\t\t\t\t  IPU3_OUTPUT_MIN_WIDTH,\n\t\t\t\t\t  IPU3_OUTPUT_MAX_WIDTH);\n\t\tfmt->format.height = clamp(fmt->format.height,\n\t\t\t\t\t   IPU3_OUTPUT_MIN_HEIGHT,\n\t\t\t\t\t   IPU3_OUTPUT_MAX_HEIGHT);\n\t} else {\n\t\tfmt->format.width = clamp(fmt->format.width,\n\t\t\t\t\t  IPU3_INPUT_MIN_WIDTH,\n\t\t\t\t\t  IPU3_INPUT_MAX_WIDTH);\n\t\tfmt->format.height = clamp(fmt->format.height,\n\t\t\t\t\t   IPU3_INPUT_MIN_HEIGHT,\n\t\t\t\t\t   IPU3_INPUT_MAX_HEIGHT);\n\t}\n\n\t*mf = fmt->format;\n\n\treturn 0;\n}\n\nstatic struct v4l2_rect *\nimgu_subdev_get_crop(struct imgu_v4l2_subdev *sd,\n\t\t     struct v4l2_subdev_state *sd_state, unsigned int pad,\n\t\t     enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_crop(&sd->subdev, sd_state, pad);\n\telse\n\t\treturn &sd->rect.eff;\n}\n\nstatic struct v4l2_rect *\nimgu_subdev_get_compose(struct imgu_v4l2_subdev *sd,\n\t\t\tstruct v4l2_subdev_state *sd_state, unsigned int pad,\n\t\t\tenum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_compose(&sd->subdev, sd_state, pad);\n\telse\n\t\treturn &sd->rect.bds;\n}\n\nstatic int imgu_subdev_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct imgu_v4l2_subdev *imgu_sd =\n\t\tcontainer_of(sd, struct imgu_v4l2_subdev, subdev);\n\n\tif (sel->pad != IMGU_NODE_IN)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *imgu_subdev_get_crop(imgu_sd, sd_state, sel->pad,\n\t\t\t\t\t       sel->which);\n\t\treturn 0;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tsel->r = *imgu_subdev_get_compose(imgu_sd, sd_state, sel->pad,\n\t\t\t\t\t\t  sel->which);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int imgu_subdev_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct imgu_device *imgu = v4l2_get_subdevdata(sd);\n\tstruct imgu_v4l2_subdev *imgu_sd =\n\t\tcontainer_of(sd, struct imgu_v4l2_subdev, subdev);\n\tstruct v4l2_rect *rect;\n\n\tdev_dbg(&imgu->pci_dev->dev,\n\t\t \"set subdev %u sel which %u target 0x%4x rect [%ux%u]\",\n\t\t imgu_sd->pipe, sel->which, sel->target,\n\t\t sel->r.width, sel->r.height);\n\n\tif (sel->pad != IMGU_NODE_IN)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\trect = imgu_subdev_get_crop(imgu_sd, sd_state, sel->pad,\n\t\t\t\t\t    sel->which);\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\trect = imgu_subdev_get_compose(imgu_sd, sd_state, sel->pad,\n\t\t\t\t\t       sel->which);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*rect = sel->r;\n\treturn 0;\n}\n\n \n\nstatic int imgu_link_setup(struct media_entity *entity,\n\t\t\t   const struct media_pad *local,\n\t\t\t   const struct media_pad *remote, u32 flags)\n{\n\tstruct imgu_media_pipe *imgu_pipe;\n\tstruct v4l2_subdev *sd = container_of(entity, struct v4l2_subdev,\n\t\t\t\t\t      entity);\n\tstruct imgu_device *imgu = v4l2_get_subdevdata(sd);\n\tstruct imgu_v4l2_subdev *imgu_sd = container_of(sd,\n\t\t\t\t\t\t\tstruct imgu_v4l2_subdev,\n\t\t\t\t\t\t\tsubdev);\n\tunsigned int pipe = imgu_sd->pipe;\n\tu32 pad = local->index;\n\n\tWARN_ON(pad >= IMGU_NODE_NUM);\n\n\tdev_dbg(&imgu->pci_dev->dev, \"pipe %u pad %u is %s\", pipe, pad,\n\t\t flags & MEDIA_LNK_FL_ENABLED ? \"enabled\" : \"disabled\");\n\n\timgu_pipe = &imgu->imgu_pipe[pipe];\n\timgu_pipe->nodes[pad].enabled = flags & MEDIA_LNK_FL_ENABLED;\n\n\t \n\tif (pad != IMGU_NODE_IN)\n\t\treturn 0;\n\n\tif (flags & MEDIA_LNK_FL_ENABLED)\n\t\t__set_bit(pipe, imgu->css.enabled_pipes);\n\telse\n\t\t__clear_bit(pipe, imgu->css.enabled_pipes);\n\n\tdev_dbg(&imgu->pci_dev->dev, \"pipe %u is %s\", pipe,\n\t\t flags & MEDIA_LNK_FL_ENABLED ? \"enabled\" : \"disabled\");\n\n\treturn 0;\n}\n\n \n\nstatic int imgu_vb2_buf_init(struct vb2_buffer *vb)\n{\n\tstruct sg_table *sg = vb2_dma_sg_plane_desc(vb, 0);\n\tstruct imgu_device *imgu = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct imgu_buffer *buf = container_of(vb,\n\t\tstruct imgu_buffer, vid_buf.vbb.vb2_buf);\n\tstruct imgu_video_device *node =\n\t\tcontainer_of(vb->vb2_queue, struct imgu_video_device, vbq);\n\tunsigned int queue = imgu_node_to_queue(node->id);\n\n\tif (queue == IPU3_CSS_QUEUE_PARAMS)\n\t\treturn 0;\n\n\treturn imgu_dmamap_map_sg(imgu, sg->sgl, sg->nents, &buf->map);\n}\n\n \nstatic void imgu_vb2_buf_cleanup(struct vb2_buffer *vb)\n{\n\tstruct imgu_device *imgu = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct imgu_buffer *buf = container_of(vb,\n\t\tstruct imgu_buffer, vid_buf.vbb.vb2_buf);\n\tstruct imgu_video_device *node =\n\t\tcontainer_of(vb->vb2_queue, struct imgu_video_device, vbq);\n\tunsigned int queue = imgu_node_to_queue(node->id);\n\n\tif (queue == IPU3_CSS_QUEUE_PARAMS)\n\t\treturn;\n\n\timgu_dmamap_unmap(imgu, &buf->map);\n}\n\n \nstatic void imgu_vb2_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct imgu_device *imgu = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct imgu_video_device *node =\n\t\tcontainer_of(vb->vb2_queue, struct imgu_video_device, vbq);\n\tunsigned int queue = imgu_node_to_queue(node->id);\n\tstruct imgu_buffer *buf = container_of(vb, struct imgu_buffer,\n\t\t\t\t\t       vid_buf.vbb.vb2_buf);\n\tunsigned long need_bytes;\n\tunsigned long payload = vb2_get_plane_payload(vb, 0);\n\n\tif (vb->vb2_queue->type == V4L2_BUF_TYPE_META_CAPTURE ||\n\t    vb->vb2_queue->type == V4L2_BUF_TYPE_META_OUTPUT)\n\t\tneed_bytes = node->vdev_fmt.fmt.meta.buffersize;\n\telse\n\t\tneed_bytes = node->vdev_fmt.fmt.pix_mp.plane_fmt[0].sizeimage;\n\n\tif (queue == IPU3_CSS_QUEUE_PARAMS && payload && payload < need_bytes) {\n\t\tdev_err(&imgu->pci_dev->dev, \"invalid data size for params.\");\n\t\tvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\n\t\treturn;\n\t}\n\n\tmutex_lock(&imgu->lock);\n\tif (queue != IPU3_CSS_QUEUE_PARAMS)\n\t\timgu_css_buf_init(&buf->css_buf, queue, buf->map.daddr);\n\n\tlist_add_tail(&buf->vid_buf.list, &node->buffers);\n\tmutex_unlock(&imgu->lock);\n\n\tvb2_set_plane_payload(vb, 0, need_bytes);\n\n\tmutex_lock(&imgu->streaming_lock);\n\tif (imgu->streaming)\n\t\timgu_queue_buffers(imgu, false, node->pipe);\n\tmutex_unlock(&imgu->streaming_lock);\n\n\tdev_dbg(&imgu->pci_dev->dev, \"%s for pipe %u node %u\", __func__,\n\t\tnode->pipe, node->id);\n}\n\nstatic int imgu_vb2_queue_setup(struct vb2_queue *vq,\n\t\t\t\tunsigned int *num_buffers,\n\t\t\t\tunsigned int *num_planes,\n\t\t\t\tunsigned int sizes[],\n\t\t\t\tstruct device *alloc_devs[])\n{\n\tstruct imgu_device *imgu = vb2_get_drv_priv(vq);\n\tstruct imgu_video_device *node =\n\t\tcontainer_of(vq, struct imgu_video_device, vbq);\n\tconst struct v4l2_format *fmt = &node->vdev_fmt;\n\tunsigned int size;\n\n\t*num_buffers = clamp_val(*num_buffers, 1, VB2_MAX_FRAME);\n\talloc_devs[0] = &imgu->pci_dev->dev;\n\n\tif (vq->type == V4L2_BUF_TYPE_META_CAPTURE ||\n\t    vq->type == V4L2_BUF_TYPE_META_OUTPUT)\n\t\tsize = fmt->fmt.meta.buffersize;\n\telse\n\t\tsize = fmt->fmt.pix_mp.plane_fmt[0].sizeimage;\n\n\tif (*num_planes) {\n\t\tif (sizes[0] < size)\n\t\t\treturn -EINVAL;\n\t\tsize = sizes[0];\n\t}\n\n\t*num_planes = 1;\n\tsizes[0] = size;\n\n\t \n\tINIT_LIST_HEAD(&node->buffers);\n\n\treturn 0;\n}\n\n \nstatic bool imgu_all_nodes_streaming(struct imgu_device *imgu,\n\t\t\t\t     struct imgu_video_device *except)\n{\n\tunsigned int i, pipe, p;\n\tstruct imgu_video_device *node;\n\tstruct device *dev = &imgu->pci_dev->dev;\n\n\tpipe = except->pipe;\n\tif (!test_bit(pipe, imgu->css.enabled_pipes)) {\n\t\tdev_warn(&imgu->pci_dev->dev,\n\t\t\t \"pipe %u link is not ready yet\", pipe);\n\t\treturn false;\n\t}\n\n\tfor_each_set_bit(p, imgu->css.enabled_pipes, IMGU_MAX_PIPE_NUM) {\n\t\tfor (i = 0; i < IMGU_NODE_NUM; i++) {\n\t\t\tnode = &imgu->imgu_pipe[p].nodes[i];\n\t\t\tdev_dbg(dev, \"%s pipe %u queue %u name %s enabled = %u\",\n\t\t\t\t__func__, p, i, node->name, node->enabled);\n\t\t\tif (node == except)\n\t\t\t\tcontinue;\n\t\t\tif (node->enabled && !vb2_start_streaming_called(&node->vbq))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic void imgu_return_all_buffers(struct imgu_device *imgu,\n\t\t\t\t    struct imgu_video_device *node,\n\t\t\t\t    enum vb2_buffer_state state)\n{\n\tstruct imgu_vb2_buffer *b, *b0;\n\n\t \n\tmutex_lock(&imgu->lock);\n\tlist_for_each_entry_safe(b, b0, &node->buffers, list) {\n\t\tlist_del(&b->list);\n\t\tvb2_buffer_done(&b->vbb.vb2_buf, state);\n\t}\n\tmutex_unlock(&imgu->lock);\n}\n\nstatic int imgu_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct imgu_media_pipe *imgu_pipe;\n\tstruct imgu_device *imgu = vb2_get_drv_priv(vq);\n\tstruct device *dev = &imgu->pci_dev->dev;\n\tstruct imgu_video_device *node =\n\t\tcontainer_of(vq, struct imgu_video_device, vbq);\n\tint r;\n\tunsigned int pipe;\n\n\tdev_dbg(dev, \"%s node name %s pipe %u id %u\", __func__,\n\t\tnode->name, node->pipe, node->id);\n\n\tmutex_lock(&imgu->streaming_lock);\n\tif (imgu->streaming) {\n\t\tr = -EBUSY;\n\t\tmutex_unlock(&imgu->streaming_lock);\n\t\tgoto fail_return_bufs;\n\t}\n\tmutex_unlock(&imgu->streaming_lock);\n\n\tif (!node->enabled) {\n\t\tdev_err(dev, \"IMGU node is not enabled\");\n\t\tr = -EINVAL;\n\t\tgoto fail_return_bufs;\n\t}\n\n\tpipe = node->pipe;\n\timgu_pipe = &imgu->imgu_pipe[pipe];\n\tatomic_set(&node->sequence, 0);\n\tr = video_device_pipeline_start(&node->vdev, &imgu_pipe->pipeline);\n\tif (r < 0)\n\t\tgoto fail_return_bufs;\n\n\tif (!imgu_all_nodes_streaming(imgu, node))\n\t\treturn 0;\n\n\tfor_each_set_bit(pipe, imgu->css.enabled_pipes, IMGU_MAX_PIPE_NUM) {\n\t\tr = v4l2_subdev_call(&imgu->imgu_pipe[pipe].imgu_sd.subdev,\n\t\t\t\t     video, s_stream, 1);\n\t\tif (r < 0)\n\t\t\tgoto fail_stop_pipeline;\n\t}\n\n\t \n\tdev_dbg(dev, \"IMGU streaming is ready to start\");\n\tmutex_lock(&imgu->streaming_lock);\n\tr = imgu_s_stream(imgu, true);\n\tif (!r)\n\t\timgu->streaming = true;\n\tmutex_unlock(&imgu->streaming_lock);\n\n\treturn 0;\n\nfail_stop_pipeline:\n\tvideo_device_pipeline_stop(&node->vdev);\nfail_return_bufs:\n\timgu_return_all_buffers(imgu, node, VB2_BUF_STATE_QUEUED);\n\n\treturn r;\n}\n\nstatic void imgu_vb2_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct imgu_media_pipe *imgu_pipe;\n\tstruct imgu_device *imgu = vb2_get_drv_priv(vq);\n\tstruct device *dev = &imgu->pci_dev->dev;\n\tstruct imgu_video_device *node =\n\t\tcontainer_of(vq, struct imgu_video_device, vbq);\n\tint r;\n\tunsigned int pipe;\n\n\tWARN_ON(!node->enabled);\n\n\tpipe = node->pipe;\n\tdev_dbg(dev, \"Try to stream off node [%u][%u]\", pipe, node->id);\n\timgu_pipe = &imgu->imgu_pipe[pipe];\n\tr = v4l2_subdev_call(&imgu_pipe->imgu_sd.subdev, video, s_stream, 0);\n\tif (r)\n\t\tdev_err(&imgu->pci_dev->dev,\n\t\t\t\"failed to stop subdev streaming\\n\");\n\n\tmutex_lock(&imgu->streaming_lock);\n\t \n\tif (imgu->streaming && imgu_all_nodes_streaming(imgu, node)) {\n\t\t \n\t\tdev_dbg(dev, \"IMGU streaming is ready to stop\");\n\t\tr = imgu_s_stream(imgu, false);\n\t\tif (!r)\n\t\t\timgu->streaming = false;\n\t}\n\n\timgu_return_all_buffers(imgu, node, VB2_BUF_STATE_ERROR);\n\tmutex_unlock(&imgu->streaming_lock);\n\n\tvideo_device_pipeline_stop(&node->vdev);\n}\n\n \n\n#define VID_CAPTURE\t0\n#define VID_OUTPUT\t1\n#define DEF_VID_CAPTURE\t0\n#define DEF_VID_OUTPUT\t1\n\nstruct imgu_fmt {\n\tu32\tfourcc;\n\tu16\ttype;  \n};\n\n \nstatic const struct imgu_fmt formats[] = {\n\t{ V4L2_PIX_FMT_NV12, VID_CAPTURE },\n\t{ V4L2_PIX_FMT_IPU3_SGRBG10, VID_OUTPUT },\n\t{ V4L2_PIX_FMT_IPU3_SBGGR10, VID_OUTPUT },\n\t{ V4L2_PIX_FMT_IPU3_SGBRG10, VID_OUTPUT },\n\t{ V4L2_PIX_FMT_IPU3_SRGGB10, VID_OUTPUT },\n};\n\n \nstatic const struct imgu_fmt *find_format(struct v4l2_format *f, u32 type)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\tif (formats[i].fourcc == f->fmt.pix_mp.pixelformat &&\n\t\t    formats[i].type == type)\n\t\t\treturn &formats[i];\n\t}\n\n\treturn type == VID_CAPTURE ? &formats[DEF_VID_CAPTURE] :\n\t\t\t\t     &formats[DEF_VID_OUTPUT];\n}\n\nstatic int imgu_vidioc_querycap(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct imgu_device *imgu = video_drvdata(file);\n\n\tstrscpy(cap->driver, IMGU_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, IMGU_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"PCI:%s\",\n\t\t pci_name(imgu->pci_dev));\n\n\treturn 0;\n}\n\nstatic int enum_fmts(struct v4l2_fmtdesc *f, u32 type)\n{\n\tunsigned int i, j;\n\n\tif (f->mbus_code != 0 && f->mbus_code != MEDIA_BUS_FMT_FIXED)\n\t\treturn -EINVAL;\n\n\tfor (i = j = 0; i < ARRAY_SIZE(formats); ++i) {\n\t\tif (formats[i].type == type) {\n\t\t\tif (j == f->index)\n\t\t\t\tbreak;\n\t\t\t++j;\n\t\t}\n\t}\n\n\tif (i < ARRAY_SIZE(formats)) {\n\t\tf->pixelformat = formats[i].fourcc;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tif (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn -EINVAL;\n\n\treturn enum_fmts(f, VID_CAPTURE);\n}\n\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tif (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn -EINVAL;\n\n\treturn enum_fmts(f, VID_OUTPUT);\n}\n\n \nstatic int imgu_vidioc_g_fmt(struct file *file, void *fh,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct imgu_video_device *node = file_to_intel_imgu_node(file);\n\n\tf->fmt = node->vdev_fmt.fmt;\n\n\treturn 0;\n}\n\n \nstatic int imgu_fmt(struct imgu_device *imgu, unsigned int pipe, int node,\n\t\t    struct v4l2_format *f, bool try)\n{\n\tstruct device *dev = &imgu->pci_dev->dev;\n\tstruct v4l2_pix_format_mplane *fmts[IPU3_CSS_QUEUES] = { NULL };\n\tstruct v4l2_rect *rects[IPU3_CSS_RECTS] = { NULL };\n\tstruct v4l2_mbus_framefmt pad_fmt;\n\tunsigned int i, css_q;\n\tint ret;\n\tstruct imgu_css_pipe *css_pipe = &imgu->css.pipes[pipe];\n\tstruct imgu_media_pipe *imgu_pipe = &imgu->imgu_pipe[pipe];\n\tstruct imgu_v4l2_subdev *imgu_sd = &imgu_pipe->imgu_sd;\n\n\tdev_dbg(dev, \"set fmt node [%u][%u](try = %u)\", pipe, node, try);\n\n\tfor (i = 0; i < IMGU_NODE_NUM; i++)\n\t\tdev_dbg(dev, \"IMGU pipe %u node %u enabled = %u\",\n\t\t\tpipe, i, imgu_pipe->nodes[i].enabled);\n\n\tif (imgu_pipe->nodes[IMGU_NODE_VF].enabled)\n\t\tcss_pipe->vf_output_en = true;\n\n\tif (atomic_read(&imgu_sd->running_mode) == IPU3_RUNNING_MODE_VIDEO)\n\t\tcss_pipe->pipe_id = IPU3_CSS_PIPE_ID_VIDEO;\n\telse\n\t\tcss_pipe->pipe_id = IPU3_CSS_PIPE_ID_CAPTURE;\n\n\tdev_dbg(dev, \"IPU3 pipe %u pipe_id = %u\", pipe, css_pipe->pipe_id);\n\n\tcss_q = imgu_node_to_queue(node);\n\tfor (i = 0; i < IPU3_CSS_QUEUES; i++) {\n\t\tunsigned int inode = imgu_map_node(imgu, i);\n\n\t\t \n\t\tif (inode == IMGU_NODE_STAT_3A || inode == IMGU_NODE_PARAMS)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (i != IPU3_CSS_QUEUE_OUT &&\n\t\t    !imgu_pipe->nodes[inode].enabled && !try) {\n\t\t\tfmts[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i == css_q) {\n\t\t\tfmts[i] = &f->fmt.pix_mp;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (try) {\n\t\t\tfmts[i] = kmemdup(&imgu_pipe->nodes[inode].vdev_fmt.fmt.pix_mp,\n\t\t\t\t\t  sizeof(struct v4l2_pix_format_mplane),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!fmts[i]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tfmts[i] = &imgu_pipe->nodes[inode].vdev_fmt.fmt.pix_mp;\n\t\t}\n\n\t}\n\n\tif (!try) {\n\t\t \n\t\tstruct imgu_v4l2_subdev *imgu_sd = &imgu_pipe->imgu_sd;\n\n\t\trects[IPU3_CSS_RECT_EFFECTIVE] = &imgu_sd->rect.eff;\n\t\trects[IPU3_CSS_RECT_BDS] = &imgu_sd->rect.bds;\n\t\trects[IPU3_CSS_RECT_GDC] = &imgu_sd->rect.gdc;\n\n\t\t \n\t\tpad_fmt = imgu_pipe->nodes[IMGU_NODE_IN].pad_fmt;\n\t\trects[IPU3_CSS_RECT_GDC]->width = pad_fmt.width;\n\t\trects[IPU3_CSS_RECT_GDC]->height = pad_fmt.height;\n\t}\n\n\tif (!fmts[css_q]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (try)\n\t\tret = imgu_css_fmt_try(&imgu->css, fmts, rects, pipe);\n\telse\n\t\tret = imgu_css_fmt_set(&imgu->css, fmts, rects, pipe);\n\n\t \n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (!try)\n\t\timgu_pipe->nodes[node].vdev_fmt.fmt.pix_mp = f->fmt.pix_mp;\n\nout:\n\tif (try) {\n\t\tfor (i = 0; i < IPU3_CSS_QUEUES; i++)\n\t\t\tif (i != css_q)\n\t\t\t\tkfree(fmts[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic int imgu_try_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pixm = &f->fmt.pix_mp;\n\tconst struct imgu_fmt *fmt;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tfmt = find_format(f, VID_CAPTURE);\n\telse if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tfmt = find_format(f, VID_OUTPUT);\n\telse\n\t\treturn -EINVAL;\n\n\tpixm->pixelformat = fmt->fourcc;\n\n\treturn 0;\n}\n\nstatic int imgu_vidioc_try_fmt(struct file *file, void *fh,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct imgu_device *imgu = video_drvdata(file);\n\tstruct device *dev = &imgu->pci_dev->dev;\n\tstruct imgu_video_device *node = file_to_intel_imgu_node(file);\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tint r;\n\n\tdev_dbg(dev, \"%s [%ux%u] for node %u\\n\", __func__,\n\t\tpix_mp->width, pix_mp->height, node->id);\n\n\tr = imgu_try_fmt(file, fh, f);\n\tif (r)\n\t\treturn r;\n\n\treturn imgu_fmt(imgu, node->pipe, node->id, f, true);\n}\n\nstatic int imgu_vidioc_s_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct imgu_device *imgu = video_drvdata(file);\n\tstruct device *dev = &imgu->pci_dev->dev;\n\tstruct imgu_video_device *node = file_to_intel_imgu_node(file);\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tint r;\n\n\tdev_dbg(dev, \"%s [%ux%u] for node %u\\n\", __func__,\n\t\tpix_mp->width, pix_mp->height, node->id);\n\n\tr = imgu_try_fmt(file, fh, f);\n\tif (r)\n\t\treturn r;\n\n\treturn imgu_fmt(imgu, node->pipe, node->id, f, false);\n}\n\nstruct imgu_meta_fmt {\n\t__u32 fourcc;\n\tchar *name;\n};\n\n \nstatic const struct imgu_meta_fmt meta_fmts[] = {\n\t{ V4L2_META_FMT_IPU3_PARAMS, \"IPU3 processing parameters\" },\n\t{ V4L2_META_FMT_IPU3_STAT_3A, \"IPU3 3A statistics\" },\n};\n\nstatic int imgu_meta_enum_format(struct file *file, void *fh,\n\t\t\t\t struct v4l2_fmtdesc *fmt)\n{\n\tstruct imgu_video_device *node = file_to_intel_imgu_node(file);\n\tunsigned int i = fmt->type == V4L2_BUF_TYPE_META_OUTPUT ? 0 : 1;\n\n\t \n\tif (fmt->index > 0 || fmt->type != node->vbq.type)\n\t\treturn -EINVAL;\n\n\tif (fmt->mbus_code != 0 && fmt->mbus_code != MEDIA_BUS_FMT_FIXED)\n\t\treturn -EINVAL;\n\n\tstrscpy(fmt->description, meta_fmts[i].name, sizeof(fmt->description));\n\tfmt->pixelformat = meta_fmts[i].fourcc;\n\n\treturn 0;\n}\n\nstatic int imgu_vidioc_g_meta_fmt(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct imgu_video_device *node = file_to_intel_imgu_node(file);\n\n\tif (f->type != node->vbq.type)\n\t\treturn -EINVAL;\n\n\tf->fmt = node->vdev_fmt.fmt;\n\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_subdev_internal_ops imgu_subdev_internal_ops = {\n\t.open = imgu_subdev_open,\n};\n\nstatic const struct v4l2_subdev_core_ops imgu_subdev_core_ops = {\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_video_ops imgu_subdev_video_ops = {\n\t.s_stream = imgu_subdev_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops imgu_subdev_pad_ops = {\n\t.link_validate = v4l2_subdev_link_validate_default,\n\t.get_fmt = imgu_subdev_get_fmt,\n\t.set_fmt = imgu_subdev_set_fmt,\n\t.get_selection = imgu_subdev_get_selection,\n\t.set_selection = imgu_subdev_set_selection,\n};\n\nstatic const struct v4l2_subdev_ops imgu_subdev_ops = {\n\t.core = &imgu_subdev_core_ops,\n\t.video = &imgu_subdev_video_ops,\n\t.pad = &imgu_subdev_pad_ops,\n};\n\nstatic const struct media_entity_operations imgu_media_ops = {\n\t.link_setup = imgu_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n \n\nstatic const struct vb2_ops imgu_vb2_ops = {\n\t.buf_init = imgu_vb2_buf_init,\n\t.buf_cleanup = imgu_vb2_buf_cleanup,\n\t.buf_queue = imgu_vb2_buf_queue,\n\t.queue_setup = imgu_vb2_queue_setup,\n\t.start_streaming = imgu_vb2_start_streaming,\n\t.stop_streaming = imgu_vb2_stop_streaming,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n\n \n\nstatic const struct v4l2_file_operations imgu_v4l2_fops = {\n\t.unlocked_ioctl = video_ioctl2,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.poll = vb2_fop_poll,\n\t.mmap = vb2_fop_mmap,\n};\n\n \n\nstatic const struct v4l2_ioctl_ops imgu_v4l2_ioctl_ops = {\n\t.vidioc_querycap = imgu_vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap_mplane = imgu_vidioc_g_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane = imgu_vidioc_s_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane = imgu_vidioc_try_fmt,\n\n\t.vidioc_enum_fmt_vid_out = vidioc_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out_mplane = imgu_vidioc_g_fmt,\n\t.vidioc_s_fmt_vid_out_mplane = imgu_vidioc_s_fmt,\n\t.vidioc_try_fmt_vid_out_mplane = imgu_vidioc_try_fmt,\n\n\t \n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n\t.vidioc_expbuf = vb2_ioctl_expbuf,\n};\n\nstatic const struct v4l2_ioctl_ops imgu_v4l2_meta_ioctl_ops = {\n\t.vidioc_querycap = imgu_vidioc_querycap,\n\n\t \n\t.vidioc_enum_fmt_meta_cap = imgu_meta_enum_format,\n\t.vidioc_g_fmt_meta_cap = imgu_vidioc_g_meta_fmt,\n\t.vidioc_s_fmt_meta_cap = imgu_vidioc_g_meta_fmt,\n\t.vidioc_try_fmt_meta_cap = imgu_vidioc_g_meta_fmt,\n\n\t \n\t.vidioc_enum_fmt_meta_out = imgu_meta_enum_format,\n\t.vidioc_g_fmt_meta_out = imgu_vidioc_g_meta_fmt,\n\t.vidioc_s_fmt_meta_out = imgu_vidioc_g_meta_fmt,\n\t.vidioc_try_fmt_meta_out = imgu_vidioc_g_meta_fmt,\n\n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n\t.vidioc_expbuf = vb2_ioctl_expbuf,\n};\n\nstatic int imgu_sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct imgu_v4l2_subdev *imgu_sd =\n\t\tcontainer_of(ctrl->handler, struct imgu_v4l2_subdev, ctrl_handler);\n\tstruct imgu_device *imgu = v4l2_get_subdevdata(&imgu_sd->subdev);\n\tstruct device *dev = &imgu->pci_dev->dev;\n\n\tdev_dbg(dev, \"set val %d to ctrl 0x%8x for subdev %u\",\n\t\tctrl->val, ctrl->id, imgu_sd->pipe);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_INTEL_IPU3_MODE:\n\t\tatomic_set(&imgu_sd->running_mode, ctrl->val);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_ctrl_ops imgu_subdev_ctrl_ops = {\n\t.s_ctrl = imgu_sd_s_ctrl,\n};\n\nstatic const char * const imgu_ctrl_mode_strings[] = {\n\t\"Video mode\",\n\t\"Still mode\",\n};\n\nstatic const struct v4l2_ctrl_config imgu_subdev_ctrl_mode = {\n\t.ops = &imgu_subdev_ctrl_ops,\n\t.id = V4L2_CID_INTEL_IPU3_MODE,\n\t.name = \"IPU3 Pipe Mode\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = ARRAY_SIZE(imgu_ctrl_mode_strings) - 1,\n\t.def = IPU3_RUNNING_MODE_VIDEO,\n\t.qmenu = imgu_ctrl_mode_strings,\n};\n\n \n\n \nstatic void imgu_node_to_v4l2(u32 node, struct video_device *vdev,\n\t\t\t      struct v4l2_format *f)\n{\n\tu32 cap;\n\n\t \n\tWARN_ON(node >= IMGU_NODE_NUM);\n\n\tswitch (node) {\n\tcase IMGU_NODE_IN:\n\t\tcap = V4L2_CAP_VIDEO_OUTPUT_MPLANE;\n\t\tf->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\t\tvdev->ioctl_ops = &imgu_v4l2_ioctl_ops;\n\t\tbreak;\n\tcase IMGU_NODE_PARAMS:\n\t\tcap = V4L2_CAP_META_OUTPUT;\n\t\tf->type = V4L2_BUF_TYPE_META_OUTPUT;\n\t\tf->fmt.meta.dataformat = V4L2_META_FMT_IPU3_PARAMS;\n\t\tvdev->ioctl_ops = &imgu_v4l2_meta_ioctl_ops;\n\t\timgu_css_meta_fmt_set(&f->fmt.meta);\n\t\tbreak;\n\tcase IMGU_NODE_STAT_3A:\n\t\tcap = V4L2_CAP_META_CAPTURE;\n\t\tf->type = V4L2_BUF_TYPE_META_CAPTURE;\n\t\tf->fmt.meta.dataformat = V4L2_META_FMT_IPU3_STAT_3A;\n\t\tvdev->ioctl_ops = &imgu_v4l2_meta_ioctl_ops;\n\t\timgu_css_meta_fmt_set(&f->fmt.meta);\n\t\tbreak;\n\tdefault:\n\t\tcap = V4L2_CAP_VIDEO_CAPTURE_MPLANE;\n\t\tf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\t\tvdev->ioctl_ops = &imgu_v4l2_ioctl_ops;\n\t}\n\n\tvdev->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_IO_MC | cap;\n}\n\nstatic int imgu_v4l2_subdev_register(struct imgu_device *imgu,\n\t\t\t\t     struct imgu_v4l2_subdev *imgu_sd,\n\t\t\t\t     unsigned int pipe)\n{\n\tint i, r;\n\tstruct v4l2_ctrl_handler *hdl = &imgu_sd->ctrl_handler;\n\tstruct imgu_media_pipe *imgu_pipe = &imgu->imgu_pipe[pipe];\n\n\t \n\tr = media_entity_pads_init(&imgu_sd->subdev.entity, IMGU_NODE_NUM,\n\t\t\t\t   imgu_sd->subdev_pads);\n\tif (r) {\n\t\tdev_err(&imgu->pci_dev->dev,\n\t\t\t\"failed initialize subdev media entity (%d)\\n\", r);\n\t\treturn r;\n\t}\n\timgu_sd->subdev.entity.ops = &imgu_media_ops;\n\tfor (i = 0; i < IMGU_NODE_NUM; i++) {\n\t\timgu_sd->subdev_pads[i].flags = imgu_pipe->nodes[i].output ?\n\t\t\tMEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;\n\t}\n\n\t \n\tv4l2_subdev_init(&imgu_sd->subdev, &imgu_subdev_ops);\n\timgu_sd->subdev.entity.function = MEDIA_ENT_F_PROC_VIDEO_STATISTICS;\n\timgu_sd->subdev.internal_ops = &imgu_subdev_internal_ops;\n\timgu_sd->subdev.flags = V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t\t\tV4L2_SUBDEV_FL_HAS_EVENTS;\n\tsnprintf(imgu_sd->subdev.name, sizeof(imgu_sd->subdev.name),\n\t\t \"%s %u\", IMGU_NAME, pipe);\n\tv4l2_set_subdevdata(&imgu_sd->subdev, imgu);\n\tatomic_set(&imgu_sd->running_mode, IPU3_RUNNING_MODE_VIDEO);\n\tv4l2_ctrl_handler_init(hdl, 1);\n\timgu_sd->subdev.ctrl_handler = hdl;\n\timgu_sd->ctrl = v4l2_ctrl_new_custom(hdl, &imgu_subdev_ctrl_mode, NULL);\n\tif (hdl->error) {\n\t\tr = hdl->error;\n\t\tdev_err(&imgu->pci_dev->dev,\n\t\t\t\"failed to create subdev v4l2 ctrl with err %d\", r);\n\t\tgoto fail_subdev;\n\t}\n\tr = v4l2_device_register_subdev(&imgu->v4l2_dev, &imgu_sd->subdev);\n\tif (r) {\n\t\tdev_err(&imgu->pci_dev->dev,\n\t\t\t\"failed initialize subdev (%d)\\n\", r);\n\t\tgoto fail_subdev;\n\t}\n\n\timgu_sd->pipe = pipe;\n\treturn 0;\n\nfail_subdev:\n\tv4l2_ctrl_handler_free(imgu_sd->subdev.ctrl_handler);\n\tmedia_entity_cleanup(&imgu_sd->subdev.entity);\n\n\treturn r;\n}\n\nstatic int imgu_v4l2_node_setup(struct imgu_device *imgu, unsigned int pipe,\n\t\t\t\tint node_num)\n{\n\tint r;\n\tu32 flags;\n\tstruct v4l2_mbus_framefmt def_bus_fmt = { 0 };\n\tstruct v4l2_pix_format_mplane def_pix_fmt = { 0 };\n\tstruct device *dev = &imgu->pci_dev->dev;\n\tstruct imgu_media_pipe *imgu_pipe = &imgu->imgu_pipe[pipe];\n\tstruct v4l2_subdev *sd = &imgu_pipe->imgu_sd.subdev;\n\tstruct imgu_video_device *node = &imgu_pipe->nodes[node_num];\n\tstruct video_device *vdev = &node->vdev;\n\tstruct vb2_queue *vbq = &node->vbq;\n\n\t \n\tdef_bus_fmt.width = 1920;\n\tdef_bus_fmt.height = 1080;\n\tdef_bus_fmt.code = MEDIA_BUS_FMT_FIXED;\n\tdef_bus_fmt.field = V4L2_FIELD_NONE;\n\tdef_bus_fmt.colorspace = V4L2_COLORSPACE_RAW;\n\tdef_bus_fmt.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tdef_bus_fmt.quantization = V4L2_QUANTIZATION_DEFAULT;\n\tdef_bus_fmt.xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\n\tdef_pix_fmt.width = def_bus_fmt.width;\n\tdef_pix_fmt.height = def_bus_fmt.height;\n\tdef_pix_fmt.field = def_bus_fmt.field;\n\tdef_pix_fmt.num_planes = 1;\n\tdef_pix_fmt.plane_fmt[0].bytesperline =\n\t\timgu_bytesperline(def_pix_fmt.width,\n\t\t\t\t  IMGU_ABI_FRAME_FORMAT_RAW_PACKED);\n\tdef_pix_fmt.plane_fmt[0].sizeimage =\n\t\tdef_pix_fmt.height * def_pix_fmt.plane_fmt[0].bytesperline;\n\tdef_pix_fmt.flags = 0;\n\tdef_pix_fmt.colorspace = def_bus_fmt.colorspace;\n\tdef_pix_fmt.ycbcr_enc = def_bus_fmt.ycbcr_enc;\n\tdef_pix_fmt.quantization = def_bus_fmt.quantization;\n\tdef_pix_fmt.xfer_func = def_bus_fmt.xfer_func;\n\n\t \n\tmutex_init(&node->lock);\n\tINIT_LIST_HEAD(&node->buffers);\n\n\t \n\tnode->pad_fmt = def_bus_fmt;\n\tnode->id = node_num;\n\tnode->pipe = pipe;\n\timgu_node_to_v4l2(node_num, vdev, &node->vdev_fmt);\n\tif (node->vdev_fmt.type ==\n\t    V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE ||\n\t    node->vdev_fmt.type ==\n\t    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tdef_pix_fmt.pixelformat = node->output ?\n\t\t\tV4L2_PIX_FMT_IPU3_SGRBG10 :\n\t\t\tV4L2_PIX_FMT_NV12;\n\t\tnode->vdev_fmt.fmt.pix_mp = def_pix_fmt;\n\t}\n\n\t \n\tr = media_entity_pads_init(&vdev->entity, 1, &node->vdev_pad);\n\tif (r) {\n\t\tdev_err(dev, \"failed initialize media entity (%d)\\n\", r);\n\t\tmutex_destroy(&node->lock);\n\t\treturn r;\n\t}\n\tnode->vdev_pad.flags = node->output ?\n\t\tMEDIA_PAD_FL_SOURCE : MEDIA_PAD_FL_SINK;\n\tvdev->entity.ops = NULL;\n\n\t \n\tvbq->type = node->vdev_fmt.type;\n\tvbq->io_modes = VB2_USERPTR | VB2_MMAP | VB2_DMABUF;\n\tvbq->ops = &imgu_vb2_ops;\n\tvbq->mem_ops = &vb2_dma_sg_memops;\n\tif (imgu->buf_struct_size <= 0)\n\t\timgu->buf_struct_size =\n\t\t\tsizeof(struct imgu_vb2_buffer);\n\tvbq->buf_struct_size = imgu->buf_struct_size;\n\tvbq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\t \n\tvbq->min_buffers_needed = 0;\n\tvbq->drv_priv = imgu;\n\tvbq->lock = &node->lock;\n\tr = vb2_queue_init(vbq);\n\tif (r) {\n\t\tdev_err(dev, \"failed to initialize video queue (%d)\", r);\n\t\tmedia_entity_cleanup(&vdev->entity);\n\t\treturn r;\n\t}\n\n\t \n\tsnprintf(vdev->name, sizeof(vdev->name), \"%s %u %s\",\n\t\t IMGU_NAME, pipe, node->name);\n\tvdev->release = video_device_release_empty;\n\tvdev->fops = &imgu_v4l2_fops;\n\tvdev->lock = &node->lock;\n\tvdev->v4l2_dev = &imgu->v4l2_dev;\n\tvdev->queue = &node->vbq;\n\tvdev->vfl_dir = node->output ? VFL_DIR_TX : VFL_DIR_RX;\n\tvideo_set_drvdata(vdev, imgu);\n\tr = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (r) {\n\t\tdev_err(dev, \"failed to register video device (%d)\", r);\n\t\tmedia_entity_cleanup(&vdev->entity);\n\t\treturn r;\n\t}\n\n\t \n\tflags = 0;\n\tif (node->enabled)\n\t\tflags |= MEDIA_LNK_FL_ENABLED;\n\tif (node->output) {\n\t\tr = media_create_pad_link(&vdev->entity, 0, &sd->entity,\n\t\t\t\t\t  node_num, flags);\n\t} else {\n\t\tif (node->id == IMGU_NODE_OUT) {\n\t\t\tflags |= MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE;\n\t\t\tnode->enabled = true;\n\t\t}\n\n\t\tr = media_create_pad_link(&sd->entity, node_num, &vdev->entity,\n\t\t\t\t\t  0, flags);\n\t}\n\tif (r) {\n\t\tdev_err(dev, \"failed to create pad link (%d)\", r);\n\t\tvideo_unregister_device(vdev);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void imgu_v4l2_nodes_cleanup_pipe(struct imgu_device *imgu,\n\t\t\t\t\t unsigned int pipe, int node)\n{\n\tint i;\n\tstruct imgu_media_pipe *imgu_pipe = &imgu->imgu_pipe[pipe];\n\n\tfor (i = 0; i < node; i++) {\n\t\tvideo_unregister_device(&imgu_pipe->nodes[i].vdev);\n\t\tmedia_entity_cleanup(&imgu_pipe->nodes[i].vdev.entity);\n\t\tmutex_destroy(&imgu_pipe->nodes[i].lock);\n\t}\n}\n\nstatic int imgu_v4l2_nodes_setup_pipe(struct imgu_device *imgu, int pipe)\n{\n\tint i;\n\n\tfor (i = 0; i < IMGU_NODE_NUM; i++) {\n\t\tint r = imgu_v4l2_node_setup(imgu, pipe, i);\n\n\t\tif (r) {\n\t\t\timgu_v4l2_nodes_cleanup_pipe(imgu, pipe, i);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void imgu_v4l2_subdev_cleanup(struct imgu_device *imgu, unsigned int i)\n{\n\tstruct imgu_media_pipe *imgu_pipe = &imgu->imgu_pipe[i];\n\n\tv4l2_device_unregister_subdev(&imgu_pipe->imgu_sd.subdev);\n\tv4l2_ctrl_handler_free(imgu_pipe->imgu_sd.subdev.ctrl_handler);\n\tmedia_entity_cleanup(&imgu_pipe->imgu_sd.subdev.entity);\n}\n\nstatic void imgu_v4l2_cleanup_pipes(struct imgu_device *imgu, unsigned int pipe)\n{\n\tint i;\n\n\tfor (i = 0; i < pipe; i++) {\n\t\timgu_v4l2_nodes_cleanup_pipe(imgu, i, IMGU_NODE_NUM);\n\t\timgu_v4l2_subdev_cleanup(imgu, i);\n\t}\n}\n\nstatic int imgu_v4l2_register_pipes(struct imgu_device *imgu)\n{\n\tstruct imgu_media_pipe *imgu_pipe;\n\tint i, r;\n\n\tfor (i = 0; i < IMGU_MAX_PIPE_NUM; i++) {\n\t\timgu_pipe = &imgu->imgu_pipe[i];\n\t\tr = imgu_v4l2_subdev_register(imgu, &imgu_pipe->imgu_sd, i);\n\t\tif (r) {\n\t\t\tdev_err(&imgu->pci_dev->dev,\n\t\t\t\t\"failed to register subdev%u ret (%d)\\n\", i, r);\n\t\t\tgoto pipes_cleanup;\n\t\t}\n\t\tr = imgu_v4l2_nodes_setup_pipe(imgu, i);\n\t\tif (r) {\n\t\t\timgu_v4l2_subdev_cleanup(imgu, i);\n\t\t\tgoto pipes_cleanup;\n\t\t}\n\t}\n\n\treturn 0;\n\npipes_cleanup:\n\timgu_v4l2_cleanup_pipes(imgu, i);\n\treturn r;\n}\n\nint imgu_v4l2_register(struct imgu_device *imgu)\n{\n\tint r;\n\n\t \n\timgu->streaming = false;\n\n\t \n\tmedia_device_pci_init(&imgu->media_dev, imgu->pci_dev, IMGU_NAME);\n\n\t \n\timgu->v4l2_dev.mdev = &imgu->media_dev;\n\timgu->v4l2_dev.ctrl_handler = NULL;\n\tr = v4l2_device_register(&imgu->pci_dev->dev, &imgu->v4l2_dev);\n\tif (r) {\n\t\tdev_err(&imgu->pci_dev->dev,\n\t\t\t\"failed to register V4L2 device (%d)\\n\", r);\n\t\tgoto fail_v4l2_dev;\n\t}\n\n\tr = imgu_v4l2_register_pipes(imgu);\n\tif (r) {\n\t\tdev_err(&imgu->pci_dev->dev,\n\t\t\t\"failed to register pipes (%d)\\n\", r);\n\t\tgoto fail_v4l2_pipes;\n\t}\n\n\tr = v4l2_device_register_subdev_nodes(&imgu->v4l2_dev);\n\tif (r) {\n\t\tdev_err(&imgu->pci_dev->dev,\n\t\t\t\"failed to register subdevs (%d)\\n\", r);\n\t\tgoto fail_subdevs;\n\t}\n\n\tr = media_device_register(&imgu->media_dev);\n\tif (r) {\n\t\tdev_err(&imgu->pci_dev->dev,\n\t\t\t\"failed to register media device (%d)\\n\", r);\n\t\tgoto fail_subdevs;\n\t}\n\n\treturn 0;\n\nfail_subdevs:\n\timgu_v4l2_cleanup_pipes(imgu, IMGU_MAX_PIPE_NUM);\nfail_v4l2_pipes:\n\tv4l2_device_unregister(&imgu->v4l2_dev);\nfail_v4l2_dev:\n\tmedia_device_cleanup(&imgu->media_dev);\n\n\treturn r;\n}\n\nint imgu_v4l2_unregister(struct imgu_device *imgu)\n{\n\tmedia_device_unregister(&imgu->media_dev);\n\timgu_v4l2_cleanup_pipes(imgu, IMGU_MAX_PIPE_NUM);\n\tv4l2_device_unregister(&imgu->v4l2_dev);\n\tmedia_device_cleanup(&imgu->media_dev);\n\n\treturn 0;\n}\n\nvoid imgu_v4l2_buffer_done(struct vb2_buffer *vb,\n\t\t\t   enum vb2_buffer_state state)\n{\n\tstruct imgu_vb2_buffer *b =\n\t\tcontainer_of(vb, struct imgu_vb2_buffer, vbb.vb2_buf);\n\n\tlist_del(&b->list);\n\tvb2_buffer_done(&b->vbb.vb2_buf, state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}