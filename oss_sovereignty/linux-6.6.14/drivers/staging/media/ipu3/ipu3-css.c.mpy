{
  "module_name": "ipu3-css.c",
  "hash_id": "46cffb0296deabebbf6adb402f39546e26eacd3253e694dd2bf1eaf0a344b83a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/ipu3/ipu3-css.c",
  "human_readable_source": "\n\n\n#include <linux/device.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n\n#include \"ipu3.h\"\n#include \"ipu3-css.h\"\n#include \"ipu3-css-fw.h\"\n#include \"ipu3-css-params.h\"\n#include \"ipu3-dmamap.h\"\n#include \"ipu3-tables.h\"\n\n \n#define IMGU_IRQCTRL_IRQ_MASK\t(IMGU_IRQCTRL_IRQ_SP1 | \\\n\t\t\t\t IMGU_IRQCTRL_IRQ_SP2 | \\\n\t\t\t\t IMGU_IRQCTRL_IRQ_SW_PIN(0) | \\\n\t\t\t\t IMGU_IRQCTRL_IRQ_SW_PIN(1))\n\n#define IPU3_CSS_FORMAT_BPP_DEN\t50\t \n\n \n#define IPU3_CSS_MIN_RES\t32\n#define IPU3_CSS_MAX_H\t\t3136\n#define IPU3_CSS_MAX_W\t\t4224\n\n \n#define MIN_ENVELOPE            4\n\n \n#define CSS_ABI_SIZE    136\n#define CSS_BDS_SIZE    (4480 * 3200 * 3)\n#define CSS_GDC_SIZE    (4224 * 3200 * 12 / 8)\n\n#define IPU3_CSS_QUEUE_TO_FLAGS(q)\t(1 << (q))\n#define IPU3_CSS_FORMAT_FL_IN\t\t\\\n\t\t\tIPU3_CSS_QUEUE_TO_FLAGS(IPU3_CSS_QUEUE_IN)\n#define IPU3_CSS_FORMAT_FL_OUT\t\t\\\n\t\t\tIPU3_CSS_QUEUE_TO_FLAGS(IPU3_CSS_QUEUE_OUT)\n#define IPU3_CSS_FORMAT_FL_VF\t\t\\\n\t\t\tIPU3_CSS_QUEUE_TO_FLAGS(IPU3_CSS_QUEUE_VF)\n\n \nstatic const struct imgu_css_format imgu_css_formats[] = {\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_NV12,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.frame_format = IMGU_ABI_FRAME_FORMAT_NV12,\n\t\t.osys_format = IMGU_ABI_OSYS_FORMAT_NV12,\n\t\t.osys_tiling = IMGU_ABI_OSYS_TILING_NONE,\n\t\t.chroma_decim = 4,\n\t\t.width_align = IPU3_UAPI_ISP_VEC_ELEMS,\n\t\t.flags = IPU3_CSS_FORMAT_FL_OUT | IPU3_CSS_FORMAT_FL_VF,\n\t}, {\n\t\t \n\t\t.pixelformat = V4L2_PIX_FMT_IPU3_SBGGR10,\n\t\t.colorspace = V4L2_COLORSPACE_RAW,\n\t\t.frame_format = IMGU_ABI_FRAME_FORMAT_RAW_PACKED,\n\t\t.bayer_order = IMGU_ABI_BAYER_ORDER_BGGR,\n\t\t.bit_depth = 10,\n\t\t.width_align = 2 * IPU3_UAPI_ISP_VEC_ELEMS,\n\t\t.flags = IPU3_CSS_FORMAT_FL_IN,\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_IPU3_SGBRG10,\n\t\t.colorspace = V4L2_COLORSPACE_RAW,\n\t\t.frame_format = IMGU_ABI_FRAME_FORMAT_RAW_PACKED,\n\t\t.bayer_order = IMGU_ABI_BAYER_ORDER_GBRG,\n\t\t.bit_depth = 10,\n\t\t.width_align = 2 * IPU3_UAPI_ISP_VEC_ELEMS,\n\t\t.flags = IPU3_CSS_FORMAT_FL_IN,\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_IPU3_SGRBG10,\n\t\t.colorspace = V4L2_COLORSPACE_RAW,\n\t\t.frame_format = IMGU_ABI_FRAME_FORMAT_RAW_PACKED,\n\t\t.bayer_order = IMGU_ABI_BAYER_ORDER_GRBG,\n\t\t.bit_depth = 10,\n\t\t.width_align = 2 * IPU3_UAPI_ISP_VEC_ELEMS,\n\t\t.flags = IPU3_CSS_FORMAT_FL_IN,\n\t}, {\n\t\t.pixelformat = V4L2_PIX_FMT_IPU3_SRGGB10,\n\t\t.colorspace = V4L2_COLORSPACE_RAW,\n\t\t.frame_format = IMGU_ABI_FRAME_FORMAT_RAW_PACKED,\n\t\t.bayer_order = IMGU_ABI_BAYER_ORDER_RGGB,\n\t\t.bit_depth = 10,\n\t\t.width_align = 2 * IPU3_UAPI_ISP_VEC_ELEMS,\n\t\t.flags = IPU3_CSS_FORMAT_FL_IN,\n\t},\n};\n\nstatic const struct {\n\tenum imgu_abi_queue_id qid;\n\tsize_t ptr_ofs;\n} imgu_css_queues[IPU3_CSS_QUEUES] = {\n\t[IPU3_CSS_QUEUE_IN] = {\n\t\tIMGU_ABI_QUEUE_C_ID,\n\t\toffsetof(struct imgu_abi_buffer, payload.frame.frame_data)\n\t},\n\t[IPU3_CSS_QUEUE_OUT] = {\n\t\tIMGU_ABI_QUEUE_D_ID,\n\t\toffsetof(struct imgu_abi_buffer, payload.frame.frame_data)\n\t},\n\t[IPU3_CSS_QUEUE_VF] = {\n\t\tIMGU_ABI_QUEUE_E_ID,\n\t\toffsetof(struct imgu_abi_buffer, payload.frame.frame_data)\n\t},\n\t[IPU3_CSS_QUEUE_STAT_3A] = {\n\t\tIMGU_ABI_QUEUE_F_ID,\n\t\toffsetof(struct imgu_abi_buffer, payload.s3a.data_ptr)\n\t},\n};\n\n \nstatic int imgu_css_queue_init(struct imgu_css_queue *queue,\n\t\t\t       struct v4l2_pix_format_mplane *fmt, u32 flags)\n{\n\tstruct v4l2_pix_format_mplane *const f = &queue->fmt.mpix;\n\tunsigned int i;\n\tu32 sizeimage;\n\n\tINIT_LIST_HEAD(&queue->bufs);\n\n\tqueue->css_fmt = NULL;\t \n\tif (!fmt)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(imgu_css_formats); i++) {\n\t\tif (!(imgu_css_formats[i].flags & flags))\n\t\t\tcontinue;\n\t\tqueue->css_fmt = &imgu_css_formats[i];\n\t\tif (imgu_css_formats[i].pixelformat == fmt->pixelformat)\n\t\t\tbreak;\n\t}\n\tif (!queue->css_fmt)\n\t\treturn -EINVAL;\t \n\n\tqueue->fmt.mpix = *fmt;\n\n\tf->width = ALIGN(clamp_t(u32, f->width,\n\t\t\t\t IPU3_CSS_MIN_RES, IPU3_CSS_MAX_W), 2);\n\tf->height = ALIGN(clamp_t(u32, f->height,\n\t\t\t\t  IPU3_CSS_MIN_RES, IPU3_CSS_MAX_H), 2);\n\tqueue->width_pad = ALIGN(f->width, queue->css_fmt->width_align);\n\tf->plane_fmt[0].bytesperline =\n\t\timgu_bytesperline(f->width, queue->css_fmt->frame_format);\n\tsizeimage = f->height * f->plane_fmt[0].bytesperline;\n\tif (queue->css_fmt->chroma_decim)\n\t\tsizeimage += 2 * sizeimage / queue->css_fmt->chroma_decim;\n\n\tf->plane_fmt[0].sizeimage = sizeimage;\n\tf->field = V4L2_FIELD_NONE;\n\tf->num_planes = 1;\n\tf->colorspace = queue->css_fmt->colorspace;\n\tf->flags = 0;\n\tf->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tf->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tf->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\tmemset(f->reserved, 0, sizeof(f->reserved));\n\n\treturn 0;\n}\n\nstatic bool imgu_css_queue_enabled(struct imgu_css_queue *q)\n{\n\treturn q->css_fmt;\n}\n\n \n\n \nstatic inline void writes(const void *mem, ssize_t count, void __iomem *addr)\n{\n\tif (count >= 4) {\n\t\tconst u32 *buf = mem;\n\n\t\tcount /= 4;\n\t\tdo {\n\t\t\twritel(*buf++, addr);\n\t\t\taddr += 4;\n\t\t} while (--count);\n\t}\n}\n\n \nstatic int imgu_hw_wait(void __iomem *base, int reg, u32 mask, u32 cmp)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(base + reg, val, (val & mask) == cmp,\n\t\t\t\t  1000, 100 * 1000);\n}\n\n \n\nint imgu_css_set_powerup(struct device *dev, void __iomem *base,\n\t\t\t unsigned int freq)\n{\n\tu32 pm_ctrl, state, val;\n\n\tdev_dbg(dev, \"%s with freq %u\\n\", __func__, freq);\n\t \n\treadl(base + IMGU_REG_GP_BUSY);\n\twritel(0, base + IMGU_REG_GP_BUSY);\n\n\t \n\tif (imgu_hw_wait(base, IMGU_REG_STATE, IMGU_STATE_IDLE_STS,\n\t\t\t IMGU_STATE_IDLE_STS)) {\n\t\tdev_err(dev, \"failed to set CSS idle\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\twritel(readl(base + IMGU_REG_PM_CTRL) | IMGU_PM_CTRL_FORCE_RESET,\n\t       base + IMGU_REG_PM_CTRL);\n\n\tusleep_range(200, 300);\n\n\t \n\n\tpm_ctrl = readl(base + IMGU_REG_PM_CTRL);\n\tstate = readl(base + IMGU_REG_STATE);\n\n\tdev_dbg(dev, \"CSS pm_ctrl 0x%x state 0x%x (power %s)\\n\",\n\t\tpm_ctrl, state, state & IMGU_STATE_POWER_DOWN ? \"down\" : \"up\");\n\n\t \n\tif (state & IMGU_STATE_POWER_DOWN) {\n\t\twritel(IMGU_PM_CTRL_RACE_TO_HALT | IMGU_PM_CTRL_START,\n\t\t       base + IMGU_REG_PM_CTRL);\n\t\tif (imgu_hw_wait(base, IMGU_REG_PM_CTRL,\n\t\t\t\t IMGU_PM_CTRL_START, 0)) {\n\t\t\tdev_err(dev, \"failed to power up CSS\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tusleep_range(2000, 3000);\n\t} else {\n\t\twritel(IMGU_PM_CTRL_RACE_TO_HALT, base + IMGU_REG_PM_CTRL);\n\t}\n\n\t \n\twritel(readl(base + IMGU_REG_GP_BUSY) | 1, base + IMGU_REG_GP_BUSY);\n\n\t \n\tpm_ctrl = readl(base + IMGU_REG_PM_CTRL);\n\tval = pm_ctrl & ~(IMGU_PM_CTRL_CSS_PWRDN | IMGU_PM_CTRL_RST_AT_EOF);\n\twritel(val, base + IMGU_REG_PM_CTRL);\n\twritel(0, base + IMGU_REG_GP_BUSY);\n\tif (imgu_hw_wait(base, IMGU_REG_STATE,\n\t\t\t IMGU_STATE_PWRDNM_FSM_MASK, 0)) {\n\t\tdev_err(dev, \"failed to pwrdn CSS\\n\");\n\t\tgoto fail;\n\t}\n\tval = (freq / IMGU_SYSTEM_REQ_FREQ_DIVIDER) & IMGU_SYSTEM_REQ_FREQ_MASK;\n\twritel(val, base + IMGU_REG_SYSTEM_REQ);\n\twritel(1, base + IMGU_REG_GP_BUSY);\n\twritel(readl(base + IMGU_REG_PM_CTRL) | IMGU_PM_CTRL_FORCE_HALT,\n\t       base + IMGU_REG_PM_CTRL);\n\tif (imgu_hw_wait(base, IMGU_REG_STATE, IMGU_STATE_HALT_STS,\n\t\t\t IMGU_STATE_HALT_STS)) {\n\t\tdev_err(dev, \"failed to halt CSS\\n\");\n\t\tgoto fail;\n\t}\n\n\twritel(readl(base + IMGU_REG_PM_CTRL) | IMGU_PM_CTRL_START,\n\t       base + IMGU_REG_PM_CTRL);\n\tif (imgu_hw_wait(base, IMGU_REG_PM_CTRL, IMGU_PM_CTRL_START, 0)) {\n\t\tdev_err(dev, \"failed to start CSS\\n\");\n\t\tgoto fail;\n\t}\n\twritel(readl(base + IMGU_REG_PM_CTRL) | IMGU_PM_CTRL_FORCE_UNHALT,\n\t       base + IMGU_REG_PM_CTRL);\n\n\tval = readl(base + IMGU_REG_PM_CTRL);\t \n\tval &= ~(IMGU_PM_CTRL_CSS_PWRDN | IMGU_PM_CTRL_RST_AT_EOF);\n\tval |= pm_ctrl & (IMGU_PM_CTRL_CSS_PWRDN | IMGU_PM_CTRL_RST_AT_EOF);\n\twritel(val, base + IMGU_REG_PM_CTRL);\n\n\treturn 0;\n\nfail:\n\timgu_css_set_powerdown(dev, base);\n\treturn -EIO;\n}\n\nvoid imgu_css_set_powerdown(struct device *dev, void __iomem *base)\n{\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\t \n\tif (imgu_hw_wait(base, IMGU_REG_CIO_GATE_BURST_STATE,\n\t\t\t IMGU_CIO_GATE_BURST_MASK, 0))\n\t\tdev_warn(dev, \"wait cio gate idle timeout\");\n\n\t \n\tif (imgu_hw_wait(base, IMGU_REG_STATE, IMGU_STATE_IDLE_STS,\n\t\t\t IMGU_STATE_IDLE_STS))\n\t\tdev_warn(dev, \"wait css idle timeout\\n\");\n\n\t \n\twritel(1, base + IMGU_REG_GP_HALT);\n\tif (imgu_hw_wait(base, IMGU_REG_STATE, IMGU_STATE_HALT_STS,\n\t\t\t IMGU_STATE_HALT_STS))\n\t\tdev_warn(dev, \"failed to halt css\");\n\n\t \n\twritel(0, base + IMGU_REG_GP_BUSY);\n}\n\nstatic void imgu_css_hw_enable_irq(struct imgu_css *css)\n{\n\tvoid __iomem *const base = css->base;\n\tu32 val, i;\n\n\t \n\n\t \n\tval = readl(base + IMGU_REG_SP_CTRL(0)) | IMGU_CTRL_IRQ_READY;\n\twritel(val, base + IMGU_REG_SP_CTRL(0));\n\twritel(val | IMGU_CTRL_IRQ_CLEAR, base + IMGU_REG_SP_CTRL(0));\n\n\t \n\twritel(IMGU_REG_INT_CSS_IRQ, base + IMGU_REG_INT_ENABLE);\n\t \n\twritel(IMGU_REG_INT_CSS_IRQ, base + IMGU_REG_INT_STATUS);\n\n\t \n\twritel(~0, base + IMGU_REG_IRQCTRL_EDGE_NOT_PULSE(IMGU_IRQCTRL_MAIN));\n\twritel(0, base + IMGU_REG_IRQCTRL_MASK(IMGU_IRQCTRL_MAIN));\n\twritel(IMGU_IRQCTRL_IRQ_MASK,\n\t       base + IMGU_REG_IRQCTRL_EDGE(IMGU_IRQCTRL_MAIN));\n\twritel(IMGU_IRQCTRL_IRQ_MASK,\n\t       base + IMGU_REG_IRQCTRL_ENABLE(IMGU_IRQCTRL_MAIN));\n\twritel(IMGU_IRQCTRL_IRQ_MASK,\n\t       base + IMGU_REG_IRQCTRL_CLEAR(IMGU_IRQCTRL_MAIN));\n\twritel(IMGU_IRQCTRL_IRQ_MASK,\n\t       base + IMGU_REG_IRQCTRL_MASK(IMGU_IRQCTRL_MAIN));\n\t \n\treadl(base + IMGU_REG_IRQCTRL_ENABLE(IMGU_IRQCTRL_MAIN));\n\n\t \n\tfor (i = IMGU_IRQCTRL_SP0; i <= IMGU_IRQCTRL_SP1; i++) {\n\t\twritel(~0, base + IMGU_REG_IRQCTRL_EDGE_NOT_PULSE(i));\n\t\twritel(0, base + IMGU_REG_IRQCTRL_MASK(i));\n\t\twritel(IMGU_IRQCTRL_IRQ_MASK, base + IMGU_REG_IRQCTRL_EDGE(i));\n\t\twritel(IMGU_IRQCTRL_IRQ_MASK,\n\t\t       base + IMGU_REG_IRQCTRL_ENABLE(i));\n\t\twritel(IMGU_IRQCTRL_IRQ_MASK, base + IMGU_REG_IRQCTRL_CLEAR(i));\n\t\twritel(IMGU_IRQCTRL_IRQ_MASK, base + IMGU_REG_IRQCTRL_MASK(i));\n\t\t \n\t\treadl(base + IMGU_REG_IRQCTRL_ENABLE(i));\n\t}\n}\n\nstatic int imgu_css_hw_init(struct imgu_css *css)\n{\n\t \n\tstatic const struct {\n\t\tu32 reg;\n\t\tu32 mask;\n\t\tconst char *name;\n\t} stream_monitors[] = {\n\t\t{\n\t\t\tIMGU_REG_GP_SP1_STRMON_STAT,\n\t\t\tIMGU_GP_STRMON_STAT_ISP_PORT_SP12ISP,\n\t\t\t\"ISP0 to SP0\"\n\t\t}, {\n\t\t\tIMGU_REG_GP_ISP_STRMON_STAT,\n\t\t\tIMGU_GP_STRMON_STAT_SP1_PORT_ISP2SP1,\n\t\t\t\"SP0 to ISP0\"\n\t\t}, {\n\t\t\tIMGU_REG_GP_MOD_STRMON_STAT,\n\t\t\tIMGU_GP_STRMON_STAT_MOD_PORT_ISP2DMA,\n\t\t\t\"ISP0 to DMA0\"\n\t\t}, {\n\t\t\tIMGU_REG_GP_ISP_STRMON_STAT,\n\t\t\tIMGU_GP_STRMON_STAT_ISP_PORT_DMA2ISP,\n\t\t\t\"DMA0 to ISP0\"\n\t\t}, {\n\t\t\tIMGU_REG_GP_MOD_STRMON_STAT,\n\t\t\tIMGU_GP_STRMON_STAT_MOD_PORT_CELLS2GDC,\n\t\t\t\"ISP0 to GDC0\"\n\t\t}, {\n\t\t\tIMGU_REG_GP_MOD_STRMON_STAT,\n\t\t\tIMGU_GP_STRMON_STAT_MOD_PORT_GDC2CELLS,\n\t\t\t\"GDC0 to ISP0\"\n\t\t}, {\n\t\t\tIMGU_REG_GP_MOD_STRMON_STAT,\n\t\t\tIMGU_GP_STRMON_STAT_MOD_PORT_SP12DMA,\n\t\t\t\"SP0 to DMA0\"\n\t\t}, {\n\t\t\tIMGU_REG_GP_SP1_STRMON_STAT,\n\t\t\tIMGU_GP_STRMON_STAT_SP1_PORT_DMA2SP1,\n\t\t\t\"DMA0 to SP0\"\n\t\t}, {\n\t\t\tIMGU_REG_GP_MOD_STRMON_STAT,\n\t\t\tIMGU_GP_STRMON_STAT_MOD_PORT_CELLS2GDC,\n\t\t\t\"SP0 to GDC0\"\n\t\t}, {\n\t\t\tIMGU_REG_GP_MOD_STRMON_STAT,\n\t\t\tIMGU_GP_STRMON_STAT_MOD_PORT_GDC2CELLS,\n\t\t\t\"GDC0 to SP0\"\n\t\t},\n\t};\n\n\tstruct device *dev = css->dev;\n\tvoid __iomem *const base = css->base;\n\tu32 val, i;\n\n\t \n\tfor (i = 0; i < IMGU_NUM_SP; i++) {\n\t\tstruct imgu_fw_info *bi =\n\t\t\t\t\t&css->fwp->binary_header[css->fw_sp[i]];\n\n\t\twritel(css->binary[css->fw_sp[i]].daddr,\n\t\t       base + IMGU_REG_SP_ICACHE_ADDR(bi->type));\n\t\twritel(readl(base + IMGU_REG_SP_CTRL(bi->type)) |\n\t\t       IMGU_CTRL_ICACHE_INV,\n\t\t       base + IMGU_REG_SP_CTRL(bi->type));\n\t}\n\twritel(css->binary[css->fw_bl].daddr, base + IMGU_REG_ISP_ICACHE_ADDR);\n\twritel(readl(base + IMGU_REG_ISP_CTRL) | IMGU_CTRL_ICACHE_INV,\n\t       base + IMGU_REG_ISP_CTRL);\n\n\t \n\n\tif (!(readl(base + IMGU_REG_SP_CTRL(0)) & IMGU_CTRL_IDLE)) {\n\t\tdev_err(dev, \"SP is not idle\\n\");\n\t\treturn -EIO;\n\t}\n\tif (!(readl(base + IMGU_REG_ISP_CTRL) & IMGU_CTRL_IDLE)) {\n\t\tdev_err(dev, \"ISP is not idle\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(stream_monitors); i++) {\n\t\tval = readl(base + stream_monitors[i].reg);\n\t\tif (val & stream_monitors[i].mask) {\n\t\t\tdev_err(dev, \"error: Stream monitor %s is valid\\n\",\n\t\t\t\tstream_monitors[i].name);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(imgu_css_gdc_lut[0]); i++) {\n\t\tu32 val0 = imgu_css_gdc_lut[0][i] & IMGU_GDC_LUT_MASK;\n\t\tu32 val1 = imgu_css_gdc_lut[1][i] & IMGU_GDC_LUT_MASK;\n\t\tu32 val2 = imgu_css_gdc_lut[2][i] & IMGU_GDC_LUT_MASK;\n\t\tu32 val3 = imgu_css_gdc_lut[3][i] & IMGU_GDC_LUT_MASK;\n\n\t\twritel(val0 | (val1 << 16),\n\t\t       base + IMGU_REG_GDC_LUT_BASE + i * 8);\n\t\twritel(val2 | (val3 << 16),\n\t\t       base + IMGU_REG_GDC_LUT_BASE + i * 8 + 4);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int imgu_css_hw_start_sp(struct imgu_css *css, int sp)\n{\n\tvoid __iomem *const base = css->base;\n\tstruct imgu_fw_info *bi = &css->fwp->binary_header[css->fw_sp[sp]];\n\tstruct imgu_abi_sp_init_dmem_cfg dmem_cfg = {\n\t\t.ddr_data_addr = css->binary[css->fw_sp[sp]].daddr\n\t\t\t+ bi->blob.data_source,\n\t\t.dmem_data_addr = bi->blob.data_target,\n\t\t.dmem_bss_addr = bi->blob.bss_target,\n\t\t.data_size = bi->blob.data_size,\n\t\t.bss_size = bi->blob.bss_size,\n\t\t.sp_id = sp,\n\t};\n\n\twrites(&dmem_cfg, sizeof(dmem_cfg), base +\n\t       IMGU_REG_SP_DMEM_BASE(sp) + bi->info.sp.init_dmem_data);\n\n\twritel(bi->info.sp.sp_entry, base + IMGU_REG_SP_START_ADDR(sp));\n\n\twritel(readl(base + IMGU_REG_SP_CTRL(sp))\n\t\t| IMGU_CTRL_START | IMGU_CTRL_RUN, base + IMGU_REG_SP_CTRL(sp));\n\n\tif (imgu_hw_wait(css->base, IMGU_REG_SP_DMEM_BASE(sp)\n\t\t\t + bi->info.sp.sw_state,\n\t\t\t ~0, IMGU_ABI_SP_SWSTATE_INITIALIZED))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int imgu_css_hw_start(struct imgu_css *css)\n{\n\tstatic const u32 event_mask =\n\t\t((1 << IMGU_ABI_EVTTYPE_OUT_FRAME_DONE) |\n\t\t(1 << IMGU_ABI_EVTTYPE_2ND_OUT_FRAME_DONE) |\n\t\t(1 << IMGU_ABI_EVTTYPE_VF_OUT_FRAME_DONE) |\n\t\t(1 << IMGU_ABI_EVTTYPE_2ND_VF_OUT_FRAME_DONE) |\n\t\t(1 << IMGU_ABI_EVTTYPE_3A_STATS_DONE) |\n\t\t(1 << IMGU_ABI_EVTTYPE_DIS_STATS_DONE) |\n\t\t(1 << IMGU_ABI_EVTTYPE_PIPELINE_DONE) |\n\t\t(1 << IMGU_ABI_EVTTYPE_FRAME_TAGGED) |\n\t\t(1 << IMGU_ABI_EVTTYPE_INPUT_FRAME_DONE) |\n\t\t(1 << IMGU_ABI_EVTTYPE_METADATA_DONE) |\n\t\t(1 << IMGU_ABI_EVTTYPE_ACC_STAGE_COMPLETE))\n\t\t<< IMGU_ABI_SP_COMM_EVENT_IRQ_MASK_OR_SHIFT;\n\n\tvoid __iomem *const base = css->base;\n\tstruct imgu_fw_info *bi, *bl = &css->fwp->binary_header[css->fw_bl];\n\tunsigned int i;\n\n\twritel(IMGU_TLB_INVALIDATE, base + IMGU_REG_TLB_INVALIDATE);\n\n\t \n\n\twritel(IMGU_ABI_BL_SWSTATE_BUSY,\n\t       base + IMGU_REG_ISP_DMEM_BASE + bl->info.bl.sw_state);\n\twritel(IMGU_NUM_SP,\n\t       base + IMGU_REG_ISP_DMEM_BASE + bl->info.bl.num_dma_cmds);\n\n\tfor (i = 0; i < IMGU_NUM_SP; i++) {\n\t\tint j = IMGU_NUM_SP - i - 1;\t \n\t\tstruct imgu_fw_info *sp =\n\t\t\t\t\t&css->fwp->binary_header[css->fw_sp[j]];\n\t\tstruct imgu_abi_bl_dma_cmd_entry dma_cmd = {\n\t\t\t.src_addr = css->binary[css->fw_sp[j]].daddr\n\t\t\t\t+ sp->blob.text_source,\n\t\t\t.size = sp->blob.text_size,\n\t\t\t.dst_type = IMGU_ABI_BL_DMACMD_TYPE_SP_PMEM,\n\t\t\t.dst_addr = IMGU_SP_PMEM_BASE(j),\n\t\t};\n\n\t\twrites(&dma_cmd, sizeof(dma_cmd),\n\t\t       base + IMGU_REG_ISP_DMEM_BASE + i * sizeof(dma_cmd) +\n\t\t       bl->info.bl.dma_cmd_list);\n\t}\n\n\twritel(bl->info.bl.bl_entry, base + IMGU_REG_ISP_START_ADDR);\n\n\twritel(readl(base + IMGU_REG_ISP_CTRL)\n\t\t| IMGU_CTRL_START | IMGU_CTRL_RUN, base + IMGU_REG_ISP_CTRL);\n\tif (imgu_hw_wait(css->base, IMGU_REG_ISP_DMEM_BASE\n\t\t\t + bl->info.bl.sw_state, ~0,\n\t\t\t IMGU_ABI_BL_SWSTATE_OK)) {\n\t\tdev_err(css->dev, \"failed to start bootloader\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\n\tmemset(css->xmem_sp_group_ptrs.vaddr, 0,\n\t       sizeof(struct imgu_abi_sp_group));\n\n\tbi = &css->fwp->binary_header[css->fw_sp[0]];\n\n\twritel(css->xmem_sp_group_ptrs.daddr,\n\t       base + IMGU_REG_SP_DMEM_BASE(0) + bi->info.sp.per_frame_data);\n\n\twritel(IMGU_ABI_SP_SWSTATE_TERMINATED,\n\t       base + IMGU_REG_SP_DMEM_BASE(0) + bi->info.sp.sw_state);\n\twritel(1, base + IMGU_REG_SP_DMEM_BASE(0) + bi->info.sp.invalidate_tlb);\n\n\tif (imgu_css_hw_start_sp(css, 0))\n\t\treturn -EIO;\n\n\twritel(0, base + IMGU_REG_SP_DMEM_BASE(0) + bi->info.sp.isp_started);\n\twritel(0, base + IMGU_REG_SP_DMEM_BASE(0) +\n\t\tbi->info.sp.host_sp_queues_initialized);\n\twritel(0, base + IMGU_REG_SP_DMEM_BASE(0) + bi->info.sp.sleep_mode);\n\twritel(0, base + IMGU_REG_SP_DMEM_BASE(0) + bi->info.sp.invalidate_tlb);\n\twritel(IMGU_ABI_SP_COMM_COMMAND_READY, base + IMGU_REG_SP_DMEM_BASE(0)\n\t\t+ bi->info.sp.host_sp_com + IMGU_ABI_SP_COMM_COMMAND);\n\n\t \n\n\tfor (i = 0; i < IPU3_CSS_PIPE_ID_NUM; i++)\n\t\twritel(event_mask, base + IMGU_REG_SP_DMEM_BASE(0)\n\t\t\t+ bi->info.sp.host_sp_com\n\t\t\t+ IMGU_ABI_SP_COMM_EVENT_IRQ_MASK(i));\n\twritel(1, base + IMGU_REG_SP_DMEM_BASE(0) +\n\t\tbi->info.sp.host_sp_queues_initialized);\n\n\t \n\n\tbi = &css->fwp->binary_header[css->fw_sp[1]];\n\n\twritel(IMGU_ABI_SP_SWSTATE_TERMINATED,\n\t       base + IMGU_REG_SP_DMEM_BASE(1) + bi->info.sp.sw_state);\n\n\tif (imgu_css_hw_start_sp(css, 1))\n\t\treturn -EIO;\n\n\twritel(IMGU_ABI_SP_COMM_COMMAND_READY, base + IMGU_REG_SP_DMEM_BASE(1)\n\t\t+ bi->info.sp.host_sp_com + IMGU_ABI_SP_COMM_COMMAND);\n\n\treturn 0;\n}\n\nstatic void imgu_css_hw_stop(struct imgu_css *css)\n{\n\tvoid __iomem *const base = css->base;\n\tstruct imgu_fw_info *bi = &css->fwp->binary_header[css->fw_sp[0]];\n\n\t \n\twritel(IMGU_ABI_SP_COMM_COMMAND_TERMINATE,\n\t       base + IMGU_REG_SP_DMEM_BASE(0) +\n\t       bi->info.sp.host_sp_com + IMGU_ABI_SP_COMM_COMMAND);\n\tif (imgu_hw_wait(css->base, IMGU_REG_SP_CTRL(0),\n\t\t\t IMGU_CTRL_IDLE, IMGU_CTRL_IDLE))\n\t\tdev_err(css->dev, \"wait sp0 idle timeout.\\n\");\n\tif (readl(base + IMGU_REG_SP_DMEM_BASE(0) + bi->info.sp.sw_state) !=\n\t\t  IMGU_ABI_SP_SWSTATE_TERMINATED)\n\t\tdev_err(css->dev, \"sp0 is not terminated.\\n\");\n\tif (imgu_hw_wait(css->base, IMGU_REG_ISP_CTRL,\n\t\t\t IMGU_CTRL_IDLE, IMGU_CTRL_IDLE))\n\t\tdev_err(css->dev, \"wait isp idle timeout\\n\");\n}\n\nstatic void imgu_css_hw_cleanup(struct imgu_css *css)\n{\n\tvoid __iomem *const base = css->base;\n\n\t \n\n\t \n\treadl(base + IMGU_REG_GP_BUSY);\n\twritel(0, base + IMGU_REG_GP_BUSY);\n\n\t \n\tif (imgu_hw_wait(css->base, IMGU_REG_STATE, IMGU_STATE_IDLE_STS,\n\t\t\t IMGU_STATE_IDLE_STS))\n\t\tdev_err(css->dev, \"failed to shut down hw cleanly\\n\");\n\n\t \n\twritel(readl(base + IMGU_REG_PM_CTRL) | IMGU_PM_CTRL_FORCE_RESET,\n\t       base + IMGU_REG_PM_CTRL);\n\n\tusleep_range(200, 300);\n}\n\nstatic void imgu_css_pipeline_cleanup(struct imgu_css *css, unsigned int pipe)\n{\n\tstruct imgu_device *imgu = dev_get_drvdata(css->dev);\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\tunsigned int i;\n\n\timgu_css_pool_cleanup(imgu, &css_pipe->pool.parameter_set_info);\n\timgu_css_pool_cleanup(imgu, &css_pipe->pool.acc);\n\timgu_css_pool_cleanup(imgu, &css_pipe->pool.gdc);\n\timgu_css_pool_cleanup(imgu, &css_pipe->pool.obgrid);\n\n\tfor (i = 0; i < IMGU_ABI_NUM_MEMORIES; i++)\n\t\timgu_css_pool_cleanup(imgu, &css_pipe->pool.binary_params_p[i]);\n}\n\n \nstatic int imgu_css_pipeline_init(struct imgu_css *css, unsigned int pipe)\n{\n\tstatic const int BYPC = 2;\t \n\tstatic const struct imgu_abi_buffer_sp buffer_sp_init = {\n\t\t.buf_src = {.queue_id = IMGU_ABI_QUEUE_EVENT_ID},\n\t\t.buf_type = IMGU_ABI_BUFFER_TYPE_INVALID,\n\t};\n\n\tstruct imgu_abi_isp_iterator_config *cfg_iter;\n\tstruct imgu_abi_isp_ref_config *cfg_ref;\n\tstruct imgu_abi_isp_dvs_config *cfg_dvs;\n\tstruct imgu_abi_isp_tnr3_config *cfg_tnr;\n\tstruct imgu_abi_isp_ref_dmem_state *cfg_ref_state;\n\tstruct imgu_abi_isp_tnr3_dmem_state *cfg_tnr_state;\n\n\tconst int stage = 0;\n\tunsigned int i, j;\n\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\tstruct imgu_css_queue *css_queue_in =\n\t\t\t&css_pipe->queue[IPU3_CSS_QUEUE_IN];\n\tstruct imgu_css_queue *css_queue_out =\n\t\t\t&css_pipe->queue[IPU3_CSS_QUEUE_OUT];\n\tstruct imgu_css_queue *css_queue_vf =\n\t\t\t&css_pipe->queue[IPU3_CSS_QUEUE_VF];\n\tconst struct imgu_fw_info *bi =\n\t\t\t&css->fwp->binary_header[css_pipe->bindex];\n\tconst unsigned int stripes = bi->info.isp.sp.iterator.num_stripes;\n\n\tstruct imgu_fw_config_memory_offsets *cofs = (void *)css->fwp +\n\t\tbi->blob.memory_offsets.offsets[IMGU_ABI_PARAM_CLASS_CONFIG];\n\tstruct imgu_fw_state_memory_offsets *sofs = (void *)css->fwp +\n\t\tbi->blob.memory_offsets.offsets[IMGU_ABI_PARAM_CLASS_STATE];\n\n\tstruct imgu_abi_isp_stage *isp_stage;\n\tstruct imgu_abi_sp_stage *sp_stage;\n\tstruct imgu_abi_sp_group *sp_group;\n\tstruct imgu_abi_frames_sp *frames_sp;\n\tstruct imgu_abi_frame_sp *frame_sp;\n\tstruct imgu_abi_frame_sp_info *frame_sp_info;\n\n\tconst unsigned int bds_width_pad =\n\t\t\t\tALIGN(css_pipe->rect[IPU3_CSS_RECT_BDS].width,\n\t\t\t\t      2 * IPU3_UAPI_ISP_VEC_ELEMS);\n\n\tconst enum imgu_abi_memories m0 = IMGU_ABI_MEM_ISP_DMEM0;\n\tenum imgu_abi_param_class cfg = IMGU_ABI_PARAM_CLASS_CONFIG;\n\tvoid *vaddr = css_pipe->binary_params_cs[cfg - 1][m0].vaddr;\n\n\tstruct imgu_device *imgu = dev_get_drvdata(css->dev);\n\n\tdev_dbg(css->dev, \"%s for pipe %d\", __func__, pipe);\n\n\t \n\n\tcfg_iter = imgu_css_fw_pipeline_params(css, pipe, cfg, m0,\n\t\t\t\t\t       &cofs->dmem.iterator,\n\t\t\t\t\t       sizeof(*cfg_iter), vaddr);\n\tif (!cfg_iter)\n\t\tgoto bad_firmware;\n\n\tframe_sp_info = &cfg_iter->input_info;\n\tframe_sp_info->res.width\t= css_queue_in->fmt.mpix.width;\n\tframe_sp_info->res.height\t= css_queue_in->fmt.mpix.height;\n\tframe_sp_info->padded_width\t= css_queue_in->width_pad;\n\tframe_sp_info->format\t\t= css_queue_in->css_fmt->frame_format;\n\tframe_sp_info->raw_bit_depth\t= css_queue_in->css_fmt->bit_depth;\n\tframe_sp_info->raw_bayer_order\t= css_queue_in->css_fmt->bayer_order;\n\tframe_sp_info->raw_type\t\t= IMGU_ABI_RAW_TYPE_BAYER;\n\n\tframe_sp_info = &cfg_iter->internal_info;\n\tframe_sp_info->res.width = css_pipe->rect[IPU3_CSS_RECT_BDS].width;\n\tframe_sp_info->res.height = css_pipe->rect[IPU3_CSS_RECT_BDS].height;\n\tframe_sp_info->padded_width\t= bds_width_pad;\n\tframe_sp_info->format\t\t= css_queue_out->css_fmt->frame_format;\n\tframe_sp_info->raw_bit_depth\t= css_queue_out->css_fmt->bit_depth;\n\tframe_sp_info->raw_bayer_order\t= css_queue_out->css_fmt->bayer_order;\n\tframe_sp_info->raw_type\t\t= IMGU_ABI_RAW_TYPE_BAYER;\n\n\tframe_sp_info = &cfg_iter->output_info;\n\tframe_sp_info->res.width\t= css_queue_out->fmt.mpix.width;\n\tframe_sp_info->res.height\t= css_queue_out->fmt.mpix.height;\n\tframe_sp_info->padded_width\t= css_queue_out->width_pad;\n\tframe_sp_info->format\t\t= css_queue_out->css_fmt->frame_format;\n\tframe_sp_info->raw_bit_depth\t= css_queue_out->css_fmt->bit_depth;\n\tframe_sp_info->raw_bayer_order\t= css_queue_out->css_fmt->bayer_order;\n\tframe_sp_info->raw_type\t\t= IMGU_ABI_RAW_TYPE_BAYER;\n\n\tframe_sp_info = &cfg_iter->vf_info;\n\tframe_sp_info->res.width\t= css_queue_vf->fmt.mpix.width;\n\tframe_sp_info->res.height\t= css_queue_vf->fmt.mpix.height;\n\tframe_sp_info->padded_width\t= css_queue_vf->width_pad;\n\tframe_sp_info->format\t\t= css_queue_vf->css_fmt->frame_format;\n\tframe_sp_info->raw_bit_depth\t= css_queue_vf->css_fmt->bit_depth;\n\tframe_sp_info->raw_bayer_order\t= css_queue_vf->css_fmt->bayer_order;\n\tframe_sp_info->raw_type\t\t= IMGU_ABI_RAW_TYPE_BAYER;\n\n\tcfg_iter->dvs_envelope.width =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_ENVELOPE].width;\n\tcfg_iter->dvs_envelope.height =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_ENVELOPE].height;\n\n\t \n\n\tcfg_ref = imgu_css_fw_pipeline_params(css, pipe, cfg, m0,\n\t\t\t\t\t      &cofs->dmem.ref,\n\t\t\t\t\t      sizeof(*cfg_ref), vaddr);\n\tif (!cfg_ref)\n\t\tgoto bad_firmware;\n\n\tcfg_ref->port_b.crop = 0;\n\tcfg_ref->port_b.elems = IMGU_ABI_ISP_DDR_WORD_BYTES / BYPC;\n\tcfg_ref->port_b.width =\n\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].width;\n\tcfg_ref->port_b.stride =\n\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].bytesperline;\n\tcfg_ref->width_a_over_b =\n\t\t\t\tIPU3_UAPI_ISP_VEC_ELEMS / cfg_ref->port_b.elems;\n\tcfg_ref->dvs_frame_delay = IPU3_CSS_AUX_FRAMES - 1;\n\tfor (i = 0; i < IPU3_CSS_AUX_FRAMES; i++) {\n\t\tcfg_ref->ref_frame_addr_y[i] =\n\t\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].mem[i].daddr;\n\t\tcfg_ref->ref_frame_addr_c[i] =\n\t\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].mem[i].daddr +\n\t\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].bytesperline *\n\t\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].height;\n\t}\n\tfor (; i < IMGU_ABI_FRAMES_REF; i++) {\n\t\tcfg_ref->ref_frame_addr_y[i] = 0;\n\t\tcfg_ref->ref_frame_addr_c[i] = 0;\n\t}\n\n\t \n\n\tcfg_dvs = imgu_css_fw_pipeline_params(css, pipe, cfg, m0,\n\t\t\t\t\t      &cofs->dmem.dvs, sizeof(*cfg_dvs),\n\t\t\t\t\t      vaddr);\n\tif (!cfg_dvs)\n\t\tgoto bad_firmware;\n\n\tcfg_dvs->num_horizontal_blocks =\n\t\t\tALIGN(DIV_ROUND_UP(css_pipe->rect[IPU3_CSS_RECT_GDC].width,\n\t\t\t\t\t   IMGU_DVS_BLOCK_W), 2);\n\tcfg_dvs->num_vertical_blocks =\n\t\t\tDIV_ROUND_UP(css_pipe->rect[IPU3_CSS_RECT_GDC].height,\n\t\t\t\t     IMGU_DVS_BLOCK_H);\n\n\t \n\n\tif (css_pipe->pipe_id == IPU3_CSS_PIPE_ID_VIDEO) {\n\t\tcfg_tnr = imgu_css_fw_pipeline_params(css, pipe, cfg, m0,\n\t\t\t\t\t\t      &cofs->dmem.tnr3,\n\t\t\t\t\t\t      sizeof(*cfg_tnr),\n\t\t\t\t\t\t      vaddr);\n\t\tif (!cfg_tnr)\n\t\t\tgoto bad_firmware;\n\n\t\tcfg_tnr->port_b.crop = 0;\n\t\tcfg_tnr->port_b.elems = IMGU_ABI_ISP_DDR_WORD_BYTES;\n\t\tcfg_tnr->port_b.width =\n\t\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_TNR].width;\n\t\tcfg_tnr->port_b.stride =\n\t\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_TNR].bytesperline;\n\t\tcfg_tnr->width_a_over_b =\n\t\t\tIPU3_UAPI_ISP_VEC_ELEMS / cfg_tnr->port_b.elems;\n\t\tcfg_tnr->frame_height =\n\t\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_TNR].height;\n\t\tcfg_tnr->delay_frame = IPU3_CSS_AUX_FRAMES - 1;\n\t\tfor (i = 0; i < IPU3_CSS_AUX_FRAMES; i++)\n\t\t\tcfg_tnr->frame_addr[i] =\n\t\t\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_TNR]\n\t\t\t\t\t.mem[i].daddr;\n\t\tfor (; i < IMGU_ABI_FRAMES_TNR; i++)\n\t\t\tcfg_tnr->frame_addr[i] = 0;\n\t}\n\n\t \n\n\tcfg = IMGU_ABI_PARAM_CLASS_STATE;\n\tvaddr = css_pipe->binary_params_cs[cfg - 1][m0].vaddr;\n\n\tcfg_ref_state = imgu_css_fw_pipeline_params(css, pipe, cfg, m0,\n\t\t\t\t\t\t    &sofs->dmem.ref,\n\t\t\t\t\t\t    sizeof(*cfg_ref_state),\n\t\t\t\t\t\t    vaddr);\n\tif (!cfg_ref_state)\n\t\tgoto bad_firmware;\n\n\tcfg_ref_state->ref_in_buf_idx = 0;\n\tcfg_ref_state->ref_out_buf_idx = 1;\n\n\t \n\tif (css_pipe->pipe_id == IPU3_CSS_PIPE_ID_VIDEO) {\n\t\tcfg_tnr_state =\n\t\t\timgu_css_fw_pipeline_params(css, pipe, cfg, m0,\n\t\t\t\t\t\t    &sofs->dmem.tnr3,\n\t\t\t\t\t\t    sizeof(*cfg_tnr_state),\n\t\t\t\t\t\t    vaddr);\n\t\tif (!cfg_tnr_state)\n\t\t\tgoto bad_firmware;\n\n\t\tcfg_tnr_state->in_bufidx = 0;\n\t\tcfg_tnr_state->out_bufidx = 1;\n\t\tcfg_tnr_state->bypass_filter = 0;\n\t\tcfg_tnr_state->total_frame_counter = 0;\n\t\tfor (i = 0; i < IMGU_ABI_BUF_SETS_TNR; i++)\n\t\t\tcfg_tnr_state->buffer_frame_counter[i] = 0;\n\t}\n\n\t \n\n\tisp_stage = css_pipe->xmem_isp_stage_ptrs[pipe][stage].vaddr;\n\tmemset(isp_stage, 0, sizeof(*isp_stage));\n\tisp_stage->blob_info = bi->blob;\n\tisp_stage->binary_info = bi->info.isp.sp;\n\tstrscpy(isp_stage->binary_name,\n\t\t(char *)css->fwp + bi->blob.prog_name_offset,\n\t\tsizeof(isp_stage->binary_name));\n\tisp_stage->mem_initializers = bi->info.isp.sp.mem_initializers;\n\tfor (i = IMGU_ABI_PARAM_CLASS_CONFIG; i < IMGU_ABI_PARAM_CLASS_NUM; i++)\n\t\tfor (j = 0; j < IMGU_ABI_NUM_MEMORIES; j++)\n\t\t\tisp_stage->mem_initializers.params[i][j].address =\n\t\t\t\t\tcss_pipe->binary_params_cs[i - 1][j].daddr;\n\n\t \n\n\tsp_stage = css_pipe->xmem_sp_stage_ptrs[pipe][stage].vaddr;\n\tmemset(sp_stage, 0, sizeof(*sp_stage));\n\n\tframes_sp = &sp_stage->frames;\n\tframes_sp->in.buf_attr = buffer_sp_init;\n\tfor (i = 0; i < IMGU_ABI_BINARY_MAX_OUTPUT_PORTS; i++)\n\t\tframes_sp->out[i].buf_attr = buffer_sp_init;\n\tframes_sp->out_vf.buf_attr = buffer_sp_init;\n\tframes_sp->s3a_buf = buffer_sp_init;\n\tframes_sp->dvs_buf = buffer_sp_init;\n\n\tsp_stage->stage_type = IMGU_ABI_STAGE_TYPE_ISP;\n\tsp_stage->num = stage;\n\tsp_stage->isp_online = 0;\n\tsp_stage->isp_copy_vf = 0;\n\tsp_stage->isp_copy_output = 0;\n\n\tsp_stage->enable.vf_output = css_pipe->vf_output_en;\n\n\tframes_sp->effective_in_res.width =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_EFFECTIVE].width;\n\tframes_sp->effective_in_res.height =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_EFFECTIVE].height;\n\n\tframe_sp = &frames_sp->in;\n\tframe_sp->info.res.width\t= css_queue_in->fmt.mpix.width;\n\tframe_sp->info.res.height\t= css_queue_in->fmt.mpix.height;\n\tframe_sp->info.padded_width\t= css_queue_in->width_pad;\n\tframe_sp->info.format\t\t= css_queue_in->css_fmt->frame_format;\n\tframe_sp->info.raw_bit_depth\t= css_queue_in->css_fmt->bit_depth;\n\tframe_sp->info.raw_bayer_order\t= css_queue_in->css_fmt->bayer_order;\n\tframe_sp->info.raw_type\t\t= IMGU_ABI_RAW_TYPE_BAYER;\n\tframe_sp->buf_attr.buf_src.queue_id = IMGU_ABI_QUEUE_C_ID;\n\tframe_sp->buf_attr.buf_type\t= IMGU_ABI_BUFFER_TYPE_INPUT_FRAME;\n\n\tframe_sp = &frames_sp->out[0];\n\tframe_sp->info.res.width\t= css_queue_out->fmt.mpix.width;\n\tframe_sp->info.res.height\t= css_queue_out->fmt.mpix.height;\n\tframe_sp->info.padded_width\t= css_queue_out->width_pad;\n\tframe_sp->info.format\t\t= css_queue_out->css_fmt->frame_format;\n\tframe_sp->info.raw_bit_depth\t= css_queue_out->css_fmt->bit_depth;\n\tframe_sp->info.raw_bayer_order\t= css_queue_out->css_fmt->bayer_order;\n\tframe_sp->info.raw_type\t\t= IMGU_ABI_RAW_TYPE_BAYER;\n\tframe_sp->planes.nv.uv.offset\t= css_queue_out->width_pad *\n\t\t\t\t\t  css_queue_out->fmt.mpix.height;\n\tframe_sp->buf_attr.buf_src.queue_id = IMGU_ABI_QUEUE_D_ID;\n\tframe_sp->buf_attr.buf_type\t= IMGU_ABI_BUFFER_TYPE_OUTPUT_FRAME;\n\n\tframe_sp = &frames_sp->out[1];\n\tframe_sp->buf_attr.buf_src.queue_id = IMGU_ABI_QUEUE_EVENT_ID;\n\n\tframe_sp_info = &frames_sp->internal_frame_info;\n\tframe_sp_info->res.width = css_pipe->rect[IPU3_CSS_RECT_BDS].width;\n\tframe_sp_info->res.height = css_pipe->rect[IPU3_CSS_RECT_BDS].height;\n\tframe_sp_info->padded_width\t= bds_width_pad;\n\tframe_sp_info->format\t\t= css_queue_out->css_fmt->frame_format;\n\tframe_sp_info->raw_bit_depth\t= css_queue_out->css_fmt->bit_depth;\n\tframe_sp_info->raw_bayer_order\t= css_queue_out->css_fmt->bayer_order;\n\tframe_sp_info->raw_type\t\t= IMGU_ABI_RAW_TYPE_BAYER;\n\n\tframe_sp = &frames_sp->out_vf;\n\tframe_sp->info.res.width\t= css_queue_vf->fmt.mpix.width;\n\tframe_sp->info.res.height\t= css_queue_vf->fmt.mpix.height;\n\tframe_sp->info.padded_width\t= css_queue_vf->width_pad;\n\tframe_sp->info.format\t\t= css_queue_vf->css_fmt->frame_format;\n\tframe_sp->info.raw_bit_depth\t= css_queue_vf->css_fmt->bit_depth;\n\tframe_sp->info.raw_bayer_order\t= css_queue_vf->css_fmt->bayer_order;\n\tframe_sp->info.raw_type\t\t= IMGU_ABI_RAW_TYPE_BAYER;\n\tframe_sp->planes.yuv.u.offset\t= css_queue_vf->width_pad *\n\t\t\t\t\t  css_queue_vf->fmt.mpix.height;\n\tframe_sp->planes.yuv.v.offset\t= css_queue_vf->width_pad *\n\t\t\t\t\t  css_queue_vf->fmt.mpix.height * 5 / 4;\n\tframe_sp->buf_attr.buf_src.queue_id = IMGU_ABI_QUEUE_E_ID;\n\tframe_sp->buf_attr.buf_type\t= IMGU_ABI_BUFFER_TYPE_VF_OUTPUT_FRAME;\n\n\tframes_sp->s3a_buf.buf_src.queue_id = IMGU_ABI_QUEUE_F_ID;\n\tframes_sp->s3a_buf.buf_type\t= IMGU_ABI_BUFFER_TYPE_3A_STATISTICS;\n\n\tframes_sp->dvs_buf.buf_src.queue_id = IMGU_ABI_QUEUE_G_ID;\n\tframes_sp->dvs_buf.buf_type\t= IMGU_ABI_BUFFER_TYPE_DIS_STATISTICS;\n\n\tsp_stage->dvs_envelope.width =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_ENVELOPE].width;\n\tsp_stage->dvs_envelope.height =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_ENVELOPE].height;\n\n\tsp_stage->isp_pipe_version =\n\t\t\t\tbi->info.isp.sp.pipeline.isp_pipe_version;\n\tsp_stage->isp_deci_log_factor =\n\t\t\tclamp(max(fls(css_pipe->rect[IPU3_CSS_RECT_BDS].width /\n\t\t\t\t      IMGU_MAX_BQ_GRID_WIDTH),\n\t\t\t\t  fls(css_pipe->rect[IPU3_CSS_RECT_BDS].height /\n\t\t\t\t      IMGU_MAX_BQ_GRID_HEIGHT)) - 1, 3, 5);\n\tsp_stage->isp_vf_downscale_bits = 0;\n\tsp_stage->if_config_index = 255;\n\tsp_stage->sp_enable_xnr = 0;\n\tsp_stage->num_stripes = stripes;\n\tsp_stage->enable.s3a = 1;\n\tsp_stage->enable.dvs_stats = 0;\n\n\tsp_stage->xmem_bin_addr = css->binary[css_pipe->bindex].daddr;\n\tsp_stage->xmem_map_addr = css_pipe->sp_ddr_ptrs.daddr;\n\tsp_stage->isp_stage_addr =\n\t\tcss_pipe->xmem_isp_stage_ptrs[pipe][stage].daddr;\n\n\t \n\n\tsp_group = css->xmem_sp_group_ptrs.vaddr;\n\tmemset(&sp_group->pipe[pipe], 0, sizeof(struct imgu_abi_sp_pipeline));\n\n\tsp_group->pipe[pipe].num_stages = 1;\n\tsp_group->pipe[pipe].pipe_id = css_pipe->pipe_id;\n\tsp_group->pipe[pipe].thread_id = pipe;\n\tsp_group->pipe[pipe].pipe_num = pipe;\n\tsp_group->pipe[pipe].num_execs = -1;\n\tsp_group->pipe[pipe].pipe_qos_config = -1;\n\tsp_group->pipe[pipe].required_bds_factor = 0;\n\tsp_group->pipe[pipe].dvs_frame_delay = IPU3_CSS_AUX_FRAMES - 1;\n\tsp_group->pipe[pipe].inout_port_config =\n\t\t\t\t\tIMGU_ABI_PORT_CONFIG_TYPE_INPUT_HOST |\n\t\t\t\t\tIMGU_ABI_PORT_CONFIG_TYPE_OUTPUT_HOST;\n\tsp_group->pipe[pipe].scaler_pp_lut = 0;\n\tsp_group->pipe[pipe].shading.internal_frame_origin_x_bqs_on_sctbl = 0;\n\tsp_group->pipe[pipe].shading.internal_frame_origin_y_bqs_on_sctbl = 0;\n\tsp_group->pipe[pipe].sp_stage_addr[stage] =\n\t\t\tcss_pipe->xmem_sp_stage_ptrs[pipe][stage].daddr;\n\tsp_group->pipe[pipe].pipe_config =\n\t\t\tbi->info.isp.sp.enable.params ? (1 << pipe) : 0;\n\tsp_group->pipe[pipe].pipe_config |= IMGU_ABI_PIPE_CONFIG_ACQUIRE_ISP;\n\n\t \n\n\tif (imgu_css_pool_init(imgu, &css_pipe->pool.parameter_set_info,\n\t\t\t       sizeof(struct imgu_abi_parameter_set_info)) ||\n\t    imgu_css_pool_init(imgu, &css_pipe->pool.acc,\n\t\t\t       sizeof(struct imgu_abi_acc_param)) ||\n\t    imgu_css_pool_init(imgu, &css_pipe->pool.gdc,\n\t\t\t       sizeof(struct imgu_abi_gdc_warp_param) *\n\t\t\t       3 * cfg_dvs->num_horizontal_blocks / 2 *\n\t\t\t       cfg_dvs->num_vertical_blocks) ||\n\t    imgu_css_pool_init(imgu, &css_pipe->pool.obgrid,\n\t\t\t       imgu_css_fw_obgrid_size(\n\t\t\t       &css->fwp->binary_header[css_pipe->bindex])))\n\t\tgoto out_of_memory;\n\n\tfor (i = 0; i < IMGU_ABI_NUM_MEMORIES; i++)\n\t\tif (imgu_css_pool_init(imgu,\n\t\t\t\t       &css_pipe->pool.binary_params_p[i],\n\t\t\t\t       bi->info.isp.sp.mem_initializers.params\n\t\t\t\t       [IMGU_ABI_PARAM_CLASS_PARAM][i].size))\n\t\t\tgoto out_of_memory;\n\n\treturn 0;\n\nbad_firmware:\n\timgu_css_pipeline_cleanup(css, pipe);\n\treturn -EPROTO;\n\nout_of_memory:\n\timgu_css_pipeline_cleanup(css, pipe);\n\treturn -ENOMEM;\n}\n\nstatic u8 imgu_css_queue_pos(struct imgu_css *css, int queue, int thread)\n{\n\tstatic const unsigned int sp;\n\tvoid __iomem *const base = css->base;\n\tstruct imgu_fw_info *bi = &css->fwp->binary_header[css->fw_sp[sp]];\n\tstruct imgu_abi_queues __iomem *q = base + IMGU_REG_SP_DMEM_BASE(sp) +\n\t\t\t\t\t\tbi->info.sp.host_sp_queue;\n\n\treturn queue >= 0 ? readb(&q->host2sp_bufq_info[thread][queue].end) :\n\t\t\t    readb(&q->host2sp_evtq_info.end);\n}\n\n \nstatic int imgu_css_queue_data(struct imgu_css *css,\n\t\t\t       int queue, int thread, u32 data)\n{\n\tstatic const unsigned int sp;\n\tvoid __iomem *const base = css->base;\n\tstruct imgu_fw_info *bi = &css->fwp->binary_header[css->fw_sp[sp]];\n\tstruct imgu_abi_queues __iomem *q = base + IMGU_REG_SP_DMEM_BASE(sp) +\n\t\t\t\t\t\tbi->info.sp.host_sp_queue;\n\tu8 size, start, end, end2;\n\n\tif (queue >= 0) {\n\t\tsize = readb(&q->host2sp_bufq_info[thread][queue].size);\n\t\tstart = readb(&q->host2sp_bufq_info[thread][queue].start);\n\t\tend = readb(&q->host2sp_bufq_info[thread][queue].end);\n\t} else {\n\t\tsize = readb(&q->host2sp_evtq_info.size);\n\t\tstart = readb(&q->host2sp_evtq_info.start);\n\t\tend = readb(&q->host2sp_evtq_info.end);\n\t}\n\n\tif (size == 0)\n\t\treturn -EIO;\n\n\tend2 = (end + 1) % size;\n\tif (end2 == start)\n\t\treturn -EBUSY;\t \n\n\tif (queue >= 0) {\n\t\twritel(data, &q->host2sp_bufq[thread][queue][end]);\n\t\twriteb(end2, &q->host2sp_bufq_info[thread][queue].end);\n\t} else {\n\t\twritel(data, &q->host2sp_evtq[end]);\n\t\twriteb(end2, &q->host2sp_evtq_info.end);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int imgu_css_dequeue_data(struct imgu_css *css, int queue, u32 *data)\n{\n\tstatic const unsigned int sp;\n\tvoid __iomem *const base = css->base;\n\tstruct imgu_fw_info *bi = &css->fwp->binary_header[css->fw_sp[sp]];\n\tstruct imgu_abi_queues __iomem *q = base + IMGU_REG_SP_DMEM_BASE(sp) +\n\t\t\t\t\t\tbi->info.sp.host_sp_queue;\n\tu8 size, start, end, start2;\n\n\tif (queue >= 0) {\n\t\tsize = readb(&q->sp2host_bufq_info[queue].size);\n\t\tstart = readb(&q->sp2host_bufq_info[queue].start);\n\t\tend = readb(&q->sp2host_bufq_info[queue].end);\n\t} else {\n\t\tsize = readb(&q->sp2host_evtq_info.size);\n\t\tstart = readb(&q->sp2host_evtq_info.start);\n\t\tend = readb(&q->sp2host_evtq_info.end);\n\t}\n\n\tif (size == 0)\n\t\treturn -EIO;\n\n\tif (end == start)\n\t\treturn -EBUSY;\t \n\n\tstart2 = (start + 1) % size;\n\n\tif (queue >= 0) {\n\t\t*data = readl(&q->sp2host_bufq[queue][start]);\n\t\twriteb(start2, &q->sp2host_bufq_info[queue].start);\n\t} else {\n\t\tint r;\n\n\t\t*data = readl(&q->sp2host_evtq[start]);\n\t\twriteb(start2, &q->sp2host_evtq_info.start);\n\n\t\t \n\t\tr = imgu_css_queue_data(css, queue, 0,\n\t\t\t\t\tIMGU_ABI_EVENT_EVENT_DEQUEUED);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void imgu_css_binary_cleanup(struct imgu_css *css, unsigned int pipe)\n{\n\tstruct imgu_device *imgu = dev_get_drvdata(css->dev);\n\tunsigned int i, j;\n\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\n\tfor (j = 0; j < IMGU_ABI_PARAM_CLASS_NUM - 1; j++)\n\t\tfor (i = 0; i < IMGU_ABI_NUM_MEMORIES; i++)\n\t\t\timgu_dmamap_free(imgu,\n\t\t\t\t\t &css_pipe->binary_params_cs[j][i]);\n\n\tj = IPU3_CSS_AUX_FRAME_REF;\n\tfor (i = 0; i < IPU3_CSS_AUX_FRAMES; i++)\n\t\timgu_dmamap_free(imgu,\n\t\t\t\t &css_pipe->aux_frames[j].mem[i]);\n\n\tj = IPU3_CSS_AUX_FRAME_TNR;\n\tfor (i = 0; i < IPU3_CSS_AUX_FRAMES; i++)\n\t\timgu_dmamap_free(imgu,\n\t\t\t\t &css_pipe->aux_frames[j].mem[i]);\n}\n\nstatic int imgu_css_binary_preallocate(struct imgu_css *css, unsigned int pipe)\n{\n\tstruct imgu_device *imgu = dev_get_drvdata(css->dev);\n\tunsigned int i, j;\n\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\n\tfor (j = IMGU_ABI_PARAM_CLASS_CONFIG;\n\t     j < IMGU_ABI_PARAM_CLASS_NUM; j++)\n\t\tfor (i = 0; i < IMGU_ABI_NUM_MEMORIES; i++)\n\t\t\tif (!imgu_dmamap_alloc(imgu,\n\t\t\t\t\t       &css_pipe->binary_params_cs[j - 1][i],\n\t\t\t\t\t       CSS_ABI_SIZE))\n\t\t\t\tgoto out_of_memory;\n\n\tfor (i = 0; i < IPU3_CSS_AUX_FRAMES; i++)\n\t\tif (!imgu_dmamap_alloc(imgu,\n\t\t\t\t       &css_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].mem[i],\n\t\t\t\t       CSS_BDS_SIZE))\n\t\t\tgoto out_of_memory;\n\n\tfor (i = 0; i < IPU3_CSS_AUX_FRAMES; i++)\n\t\tif (!imgu_dmamap_alloc(imgu,\n\t\t\t\t       &css_pipe->aux_frames[IPU3_CSS_AUX_FRAME_TNR].mem[i],\n\t\t\t\t       CSS_GDC_SIZE))\n\t\t\tgoto out_of_memory;\n\n\treturn 0;\n\nout_of_memory:\n\timgu_css_binary_cleanup(css, pipe);\n\treturn -ENOMEM;\n}\n\n \nstatic int imgu_css_binary_setup(struct imgu_css *css, unsigned int pipe)\n{\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\tstruct imgu_fw_info *bi = &css->fwp->binary_header[css_pipe->bindex];\n\tstruct imgu_device *imgu = dev_get_drvdata(css->dev);\n\tint i, j, size;\n\tstatic const int BYPC = 2;\t \n\tunsigned int w, h;\n\n\t \n\n\tfor (j = IMGU_ABI_PARAM_CLASS_CONFIG; j < IMGU_ABI_PARAM_CLASS_NUM; j++)\n\t\tfor (i = 0; i < IMGU_ABI_NUM_MEMORIES; i++) {\n\t\t\tif (imgu_css_dma_buffer_resize(\n\t\t\t    imgu,\n\t\t\t    &css_pipe->binary_params_cs[j - 1][i],\n\t\t\t    bi->info.isp.sp.mem_initializers.params[j][i].size))\n\t\t\t\tgoto out_of_memory;\n\t\t}\n\n\t \n\n\t \n\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].bytesperpixel = BYPC;\n\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].width =\n\t\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].width;\n\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].height =\n\t\t\t\tALIGN(css_pipe->rect[IPU3_CSS_RECT_BDS].height,\n\t\t\t\t      IMGU_DVS_BLOCK_H) + 2 * IMGU_GDC_BUF_Y;\n\th = css_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].height;\n\tw = ALIGN(css_pipe->rect[IPU3_CSS_RECT_BDS].width,\n\t\t  2 * IPU3_UAPI_ISP_VEC_ELEMS) + 2 * IMGU_GDC_BUF_X;\n\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].bytesperline =\n\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].bytesperpixel * w;\n\tsize = w * h * BYPC + (w / 2) * (h / 2) * BYPC * 2;\n\tfor (i = 0; i < IPU3_CSS_AUX_FRAMES; i++)\n\t\tif (imgu_css_dma_buffer_resize(\n\t\t\timgu,\n\t\t\t&css_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].mem[i],\n\t\t\tsize))\n\t\t\tgoto out_of_memory;\n\n\t \n\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_TNR].bytesperpixel = 1;\n\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_TNR].width =\n\t\t\troundup(css_pipe->rect[IPU3_CSS_RECT_GDC].width,\n\t\t\t\tbi->info.isp.sp.block.block_width *\n\t\t\t\tIPU3_UAPI_ISP_VEC_ELEMS);\n\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_TNR].height =\n\t\t\troundup(css_pipe->rect[IPU3_CSS_RECT_GDC].height,\n\t\t\t\tbi->info.isp.sp.block.output_block_height);\n\n\tw = css_pipe->aux_frames[IPU3_CSS_AUX_FRAME_TNR].width;\n\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_TNR].bytesperline = w;\n\th = css_pipe->aux_frames[IPU3_CSS_AUX_FRAME_TNR].height;\n\tsize = w * ALIGN(h * 3 / 2 + 3, 2);\t \n\tfor (i = 0; i < IPU3_CSS_AUX_FRAMES; i++)\n\t\tif (imgu_css_dma_buffer_resize(\n\t\t\timgu,\n\t\t\t&css_pipe->aux_frames[IPU3_CSS_AUX_FRAME_TNR].mem[i],\n\t\t\tsize))\n\t\t\tgoto out_of_memory;\n\n\treturn 0;\n\nout_of_memory:\n\timgu_css_binary_cleanup(css, pipe);\n\treturn -ENOMEM;\n}\n\nint imgu_css_start_streaming(struct imgu_css *css)\n{\n\tu32 data;\n\tint r, pipe;\n\n\tif (css->streaming)\n\t\treturn -EPROTO;\n\n\tfor_each_set_bit(pipe, css->enabled_pipes, IMGU_MAX_PIPE_NUM) {\n\t\tr = imgu_css_binary_setup(css, pipe);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tr = imgu_css_hw_init(css);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = imgu_css_hw_start(css);\n\tif (r < 0)\n\t\tgoto fail;\n\n\tfor_each_set_bit(pipe, css->enabled_pipes, IMGU_MAX_PIPE_NUM) {\n\t\tr = imgu_css_pipeline_init(css, pipe);\n\t\tif (r < 0)\n\t\t\tgoto fail;\n\t}\n\n\tcss->streaming = true;\n\n\timgu_css_hw_enable_irq(css);\n\n\t \n\tfor_each_set_bit(pipe, css->enabled_pipes, IMGU_MAX_PIPE_NUM) {\n\t\tr = imgu_css_set_parameters(css, pipe, NULL);\n\t\tif (r < 0)\n\t\t\tgoto fail;\n\t}\n\n\twhile (!(r = imgu_css_dequeue_data(css, IMGU_ABI_QUEUE_A_ID, &data)))\n\t\t;\n\tif (r != -EBUSY)\n\t\tgoto fail;\n\n\twhile (!(r = imgu_css_dequeue_data(css, IMGU_ABI_QUEUE_B_ID, &data)))\n\t\t;\n\tif (r != -EBUSY)\n\t\tgoto fail;\n\n\tfor_each_set_bit(pipe, css->enabled_pipes, IMGU_MAX_PIPE_NUM) {\n\t\tr = imgu_css_queue_data(css, IMGU_ABI_QUEUE_EVENT_ID, pipe,\n\t\t\t\t\tIMGU_ABI_EVENT_START_STREAM |\n\t\t\t\t\tpipe << 16);\n\t\tif (r < 0)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tcss->streaming = false;\n\timgu_css_hw_cleanup(css);\n\tfor_each_set_bit(pipe, css->enabled_pipes, IMGU_MAX_PIPE_NUM) {\n\t\timgu_css_pipeline_cleanup(css, pipe);\n\t\timgu_css_binary_cleanup(css, pipe);\n\t}\n\n\treturn r;\n}\n\nvoid imgu_css_stop_streaming(struct imgu_css *css)\n{\n\tstruct imgu_css_buffer *b, *b0;\n\tint q, r, pipe;\n\n\tfor_each_set_bit(pipe, css->enabled_pipes, IMGU_MAX_PIPE_NUM) {\n\t\tr = imgu_css_queue_data(css, IMGU_ABI_QUEUE_EVENT_ID, pipe,\n\t\t\t\t\tIMGU_ABI_EVENT_STOP_STREAM);\n\t\tif (r < 0)\n\t\t\tdev_warn(css->dev, \"failed on stop stream event\\n\");\n\t}\n\n\tif (!css->streaming)\n\t\treturn;\n\n\timgu_css_hw_stop(css);\n\n\timgu_css_hw_cleanup(css);\n\n\tfor_each_set_bit(pipe, css->enabled_pipes, IMGU_MAX_PIPE_NUM) {\n\t\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\n\t\timgu_css_pipeline_cleanup(css, pipe);\n\n\t\tspin_lock(&css_pipe->qlock);\n\t\tfor (q = 0; q < IPU3_CSS_QUEUES; q++)\n\t\t\tlist_for_each_entry_safe(b, b0,\n\t\t\t\t\t\t &css_pipe->queue[q].bufs,\n\t\t\t\t\t\t list) {\n\t\t\t\tb->state = IPU3_CSS_BUFFER_FAILED;\n\t\t\t\tlist_del(&b->list);\n\t\t\t}\n\t\tspin_unlock(&css_pipe->qlock);\n\t}\n\n\tcss->streaming = false;\n}\n\nbool imgu_css_pipe_queue_empty(struct imgu_css *css, unsigned int pipe)\n{\n\tint q;\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\n\tspin_lock(&css_pipe->qlock);\n\tfor (q = 0; q < IPU3_CSS_QUEUES; q++)\n\t\tif (!list_empty(&css_pipe->queue[q].bufs))\n\t\t\tbreak;\n\tspin_unlock(&css_pipe->qlock);\n\treturn (q == IPU3_CSS_QUEUES);\n}\n\nbool imgu_css_queue_empty(struct imgu_css *css)\n{\n\tunsigned int pipe;\n\tbool ret = false;\n\n\tfor (pipe = 0; pipe < IMGU_MAX_PIPE_NUM; pipe++)\n\t\tret &= imgu_css_pipe_queue_empty(css, pipe);\n\n\treturn ret;\n}\n\nbool imgu_css_is_streaming(struct imgu_css *css)\n{\n\treturn css->streaming;\n}\n\nstatic int imgu_css_map_init(struct imgu_css *css, unsigned int pipe)\n{\n\tstruct imgu_device *imgu = dev_get_drvdata(css->dev);\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\tunsigned int p, q, i;\n\n\t \n\tfor (p = 0; p < IPU3_CSS_PIPE_ID_NUM; p++)\n\t\tfor (i = 0; i < IMGU_ABI_MAX_STAGES; i++) {\n\t\t\tif (!imgu_dmamap_alloc(imgu,\n\t\t\t\t\t       &css_pipe->xmem_sp_stage_ptrs[p][i],\n\t\t\t\t\t       sizeof(struct imgu_abi_sp_stage)))\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!imgu_dmamap_alloc(imgu,\n\t\t\t\t\t       &css_pipe->xmem_isp_stage_ptrs[p][i],\n\t\t\t\t\t       sizeof(struct imgu_abi_isp_stage)))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\tif (!imgu_dmamap_alloc(imgu, &css_pipe->sp_ddr_ptrs,\n\t\t\t       ALIGN(sizeof(struct imgu_abi_ddr_address_map),\n\t\t\t\t     IMGU_ABI_ISP_DDR_WORD_BYTES)))\n\t\treturn -ENOMEM;\n\n\tfor (q = 0; q < IPU3_CSS_QUEUES; q++) {\n\t\tunsigned int abi_buf_num = ARRAY_SIZE(css_pipe->abi_buffers[q]);\n\n\t\tfor (i = 0; i < abi_buf_num; i++)\n\t\t\tif (!imgu_dmamap_alloc(imgu,\n\t\t\t\t\t       &css_pipe->abi_buffers[q][i],\n\t\t\t\t\t       sizeof(struct imgu_abi_buffer)))\n\t\t\t\treturn -ENOMEM;\n\t}\n\n\tif (imgu_css_binary_preallocate(css, pipe)) {\n\t\timgu_css_binary_cleanup(css, pipe);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void imgu_css_pipe_cleanup(struct imgu_css *css, unsigned int pipe)\n{\n\tstruct imgu_device *imgu = dev_get_drvdata(css->dev);\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\tunsigned int p, q, i, abi_buf_num;\n\n\timgu_css_binary_cleanup(css, pipe);\n\n\tfor (q = 0; q < IPU3_CSS_QUEUES; q++) {\n\t\tabi_buf_num = ARRAY_SIZE(css_pipe->abi_buffers[q]);\n\t\tfor (i = 0; i < abi_buf_num; i++)\n\t\t\timgu_dmamap_free(imgu, &css_pipe->abi_buffers[q][i]);\n\t}\n\n\tfor (p = 0; p < IPU3_CSS_PIPE_ID_NUM; p++)\n\t\tfor (i = 0; i < IMGU_ABI_MAX_STAGES; i++) {\n\t\t\timgu_dmamap_free(imgu,\n\t\t\t\t\t &css_pipe->xmem_sp_stage_ptrs[p][i]);\n\t\t\timgu_dmamap_free(imgu,\n\t\t\t\t\t &css_pipe->xmem_isp_stage_ptrs[p][i]);\n\t\t}\n\n\timgu_dmamap_free(imgu, &css_pipe->sp_ddr_ptrs);\n}\n\nvoid imgu_css_cleanup(struct imgu_css *css)\n{\n\tstruct imgu_device *imgu = dev_get_drvdata(css->dev);\n\tunsigned int pipe;\n\n\timgu_css_stop_streaming(css);\n\tfor (pipe = 0; pipe < IMGU_MAX_PIPE_NUM; pipe++)\n\t\timgu_css_pipe_cleanup(css, pipe);\n\timgu_dmamap_free(imgu, &css->xmem_sp_group_ptrs);\n\timgu_css_fw_cleanup(css);\n}\n\nint imgu_css_init(struct device *dev, struct imgu_css *css,\n\t\t  void __iomem *base, int length)\n{\n\tstruct imgu_device *imgu = dev_get_drvdata(dev);\n\tint r, q, pipe;\n\n\t \n\tcss->dev = dev;\n\tcss->base = base;\n\tcss->iomem_length = length;\n\n\tfor (pipe = 0; pipe < IMGU_MAX_PIPE_NUM; pipe++) {\n\t\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\n\t\tcss_pipe->vf_output_en = false;\n\t\tspin_lock_init(&css_pipe->qlock);\n\t\tcss_pipe->bindex = IPU3_CSS_DEFAULT_BINARY;\n\t\tcss_pipe->pipe_id = IPU3_CSS_PIPE_ID_VIDEO;\n\t\tfor (q = 0; q < IPU3_CSS_QUEUES; q++) {\n\t\t\tr = imgu_css_queue_init(&css_pipe->queue[q], NULL, 0);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t\tr = imgu_css_map_init(css, pipe);\n\t\tif (r) {\n\t\t\timgu_css_cleanup(css);\n\t\t\treturn r;\n\t\t}\n\t}\n\tif (!imgu_dmamap_alloc(imgu, &css->xmem_sp_group_ptrs,\n\t\t\t       sizeof(struct imgu_abi_sp_group)))\n\t\treturn -ENOMEM;\n\n\tr = imgu_css_fw_init(css);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic u32 imgu_css_adjust(u32 res, u32 align)\n{\n\tu32 val = max_t(u32, IPU3_CSS_MIN_RES, res);\n\n\treturn DIV_ROUND_CLOSEST(val, align) * align;\n}\n\n \nstatic int imgu_css_find_binary(struct imgu_css *css,\n\t\t\t\tunsigned int pipe,\n\t\t\t\tstruct imgu_css_queue queue[IPU3_CSS_QUEUES],\n\t\t\t\tstruct v4l2_rect rects[IPU3_CSS_RECTS])\n{\n\tconst int binary_nr = css->fwp->file_header.binary_nr;\n\tunsigned int binary_mode =\n\t\t(css->pipes[pipe].pipe_id == IPU3_CSS_PIPE_ID_CAPTURE) ?\n\t\tIA_CSS_BINARY_MODE_PRIMARY : IA_CSS_BINARY_MODE_VIDEO;\n\tconst struct v4l2_pix_format_mplane *in =\n\t\t\t\t\t&queue[IPU3_CSS_QUEUE_IN].fmt.mpix;\n\tconst struct v4l2_pix_format_mplane *out =\n\t\t\t\t\t&queue[IPU3_CSS_QUEUE_OUT].fmt.mpix;\n\tconst struct v4l2_pix_format_mplane *vf =\n\t\t\t\t\t&queue[IPU3_CSS_QUEUE_VF].fmt.mpix;\n\tu32 stripe_w = 0, stripe_h = 0;\n\tconst char *name;\n\tint i, j;\n\n\tif (!imgu_css_queue_enabled(&queue[IPU3_CSS_QUEUE_IN]))\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < binary_nr; i++) {\n\t\tstruct imgu_fw_info *bi = &css->fwp->binary_header[i];\n\n\t\tu32 max_width = bi->info.isp.sp.output.max_width;\n\t\tu32 max_height = bi->info.isp.sp.output.max_height;\n\n\t\tif (bi->info.isp.sp.iterator.num_stripes <= 1) {\n\t\t\tstripe_w = stripe_w ?\n\t\t\t\tmin(stripe_w, max_width) : max_width;\n\t\t\tstripe_h = stripe_h ?\n\t\t\t\tmin(stripe_h, max_height) : max_height;\n\t\t}\n\t}\n\n\tfor (i = 0; i < binary_nr; i++) {\n\t\tstruct imgu_fw_info *bi = &css->fwp->binary_header[i];\n\t\tenum imgu_abi_frame_format q_fmt;\n\n\t\tname = (void *)css->fwp + bi->blob.prog_name_offset;\n\n\t\t \n\t\tif (bi->info.isp.sp.input.source !=\n\t\t    IMGU_ABI_BINARY_INPUT_SOURCE_MEMORY)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!bi->info.isp.sp.enable.input_feeder &&\n\t\t    !bi->info.isp.sp.enable.input_raw)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (bi->info.isp.sp.pipeline.mode != binary_mode)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (bi->info.isp.sp.enable.luma_only)\n\t\t\tcontinue;\n\n\t\tif (in->width < bi->info.isp.sp.input.min_width ||\n\t\t    in->width > bi->info.isp.sp.input.max_width ||\n\t\t    in->height < bi->info.isp.sp.input.min_height ||\n\t\t    in->height > bi->info.isp.sp.input.max_height)\n\t\t\tcontinue;\n\n\t\tif (imgu_css_queue_enabled(&queue[IPU3_CSS_QUEUE_OUT])) {\n\t\t\tif (bi->info.isp.num_output_pins <= 0)\n\t\t\t\tcontinue;\n\n\t\t\tq_fmt = queue[IPU3_CSS_QUEUE_OUT].css_fmt->frame_format;\n\t\t\tfor (j = 0; j < bi->info.isp.num_output_formats; j++)\n\t\t\t\tif (bi->info.isp.output_formats[j] == q_fmt)\n\t\t\t\t\tbreak;\n\t\t\tif (j >= bi->info.isp.num_output_formats)\n\t\t\t\tcontinue;\n\n\t\t\tif (out->width < bi->info.isp.sp.output.min_width ||\n\t\t\t    out->width > bi->info.isp.sp.output.max_width ||\n\t\t\t    out->height < bi->info.isp.sp.output.min_height ||\n\t\t\t    out->height > bi->info.isp.sp.output.max_height)\n\t\t\t\tcontinue;\n\n\t\t\tif (out->width > bi->info.isp.sp.internal.max_width ||\n\t\t\t    out->height > bi->info.isp.sp.internal.max_height)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (imgu_css_queue_enabled(&queue[IPU3_CSS_QUEUE_VF])) {\n\t\t\tif (bi->info.isp.num_output_pins <= 1)\n\t\t\t\tcontinue;\n\n\t\t\tq_fmt = queue[IPU3_CSS_QUEUE_VF].css_fmt->frame_format;\n\t\t\tfor (j = 0; j < bi->info.isp.num_output_formats; j++)\n\t\t\t\tif (bi->info.isp.output_formats[j] == q_fmt)\n\t\t\t\t\tbreak;\n\t\t\tif (j >= bi->info.isp.num_output_formats)\n\t\t\t\tcontinue;\n\n\t\t\tif (vf->width < bi->info.isp.sp.output.min_width ||\n\t\t\t    vf->width > bi->info.isp.sp.output.max_width ||\n\t\t\t    vf->height < bi->info.isp.sp.output.min_height ||\n\t\t\t    vf->height > bi->info.isp.sp.output.max_height)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdev_dbg(css->dev, \"using binary %s id = %u\\n\", name,\n\t\t\tbi->info.isp.sp.id);\n\t\treturn i;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\n \nint imgu_css_fmt_try(struct imgu_css *css,\n\t\t     struct v4l2_pix_format_mplane *fmts[IPU3_CSS_QUEUES],\n\t\t     struct v4l2_rect *rects[IPU3_CSS_RECTS],\n\t\t     unsigned int pipe)\n{\n\tstatic const u32 EFF_ALIGN_W = 2;\n\tstatic const u32 BDS_ALIGN_W = 4;\n\tstatic const u32 OUT_ALIGN_W = 8;\n\tstatic const u32 OUT_ALIGN_H = 4;\n\tstatic const u32 VF_ALIGN_W  = 2;\n\tstatic const char *qnames[IPU3_CSS_QUEUES] = {\n\t\t[IPU3_CSS_QUEUE_IN] = \"in\",\n\t\t[IPU3_CSS_QUEUE_PARAMS]    = \"params\",\n\t\t[IPU3_CSS_QUEUE_OUT] = \"out\",\n\t\t[IPU3_CSS_QUEUE_VF] = \"vf\",\n\t\t[IPU3_CSS_QUEUE_STAT_3A]   = \"3a\",\n\t};\n\tstatic const char *rnames[IPU3_CSS_RECTS] = {\n\t\t[IPU3_CSS_RECT_EFFECTIVE] = \"effective resolution\",\n\t\t[IPU3_CSS_RECT_BDS]       = \"bayer-domain scaled resolution\",\n\t\t[IPU3_CSS_RECT_ENVELOPE]  = \"DVS envelope size\",\n\t\t[IPU3_CSS_RECT_GDC]  = \"GDC output res\",\n\t};\n\tstruct v4l2_rect r[IPU3_CSS_RECTS] = { };\n\tstruct v4l2_rect *const eff = &r[IPU3_CSS_RECT_EFFECTIVE];\n\tstruct v4l2_rect *const bds = &r[IPU3_CSS_RECT_BDS];\n\tstruct v4l2_rect *const env = &r[IPU3_CSS_RECT_ENVELOPE];\n\tstruct v4l2_rect *const gdc = &r[IPU3_CSS_RECT_GDC];\n\tstruct imgu_css_queue *q;\n\tstruct v4l2_pix_format_mplane *in, *out, *vf;\n\tint i, s, ret;\n\n\tq = kcalloc(IPU3_CSS_QUEUES, sizeof(struct imgu_css_queue), GFP_KERNEL);\n\tif (!q)\n\t\treturn -ENOMEM;\n\n\tin  = &q[IPU3_CSS_QUEUE_IN].fmt.mpix;\n\tout = &q[IPU3_CSS_QUEUE_OUT].fmt.mpix;\n\tvf  = &q[IPU3_CSS_QUEUE_VF].fmt.mpix;\n\n\t \n\tfor (i = 0; i < IPU3_CSS_QUEUES; i++) {\n\t\tif (fmts[i])\n\t\t\tdev_dbg(css->dev, \"%s %s: (%i,%i) fmt 0x%x\\n\", __func__,\n\t\t\t\tqnames[i], fmts[i]->width, fmts[i]->height,\n\t\t\t\tfmts[i]->pixelformat);\n\t\telse\n\t\t\tdev_dbg(css->dev, \"%s %s: (not set)\\n\", __func__,\n\t\t\t\tqnames[i]);\n\t\tif (imgu_css_queue_init(&q[i], fmts[i],\n\t\t\t\t\tIPU3_CSS_QUEUE_TO_FLAGS(i))) {\n\t\t\tdev_notice(css->dev, \"can not initialize queue %s\\n\",\n\t\t\t\t   qnames[i]);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor (i = 0; i < IPU3_CSS_RECTS; i++) {\n\t\tif (rects[i]) {\n\t\t\tdev_dbg(css->dev, \"%s %s: (%i,%i)\\n\", __func__,\n\t\t\t\trnames[i], rects[i]->width, rects[i]->height);\n\t\t\tr[i].width  = rects[i]->width;\n\t\t\tr[i].height = rects[i]->height;\n\t\t} else {\n\t\t\tdev_dbg(css->dev, \"%s %s: (not set)\\n\", __func__,\n\t\t\t\trnames[i]);\n\t\t}\n\t\t \n\t\tr[i].left = 0;\n\t\tr[i].top  = 0;\n\t}\n\n\t \n\tif (!imgu_css_queue_enabled(&q[IPU3_CSS_QUEUE_IN]) ||\n\t    !imgu_css_queue_enabled(&q[IPU3_CSS_QUEUE_OUT])) {\n\t\tdev_warn(css->dev, \"required queues are disabled\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!imgu_css_queue_enabled(&q[IPU3_CSS_QUEUE_OUT])) {\n\t\tout->width = in->width;\n\t\tout->height = in->height;\n\t}\n\tif (eff->width <= 0 || eff->height <= 0) {\n\t\teff->width = in->width;\n\t\teff->height = in->height;\n\t}\n\tif (bds->width <= 0 || bds->height <= 0) {\n\t\tbds->width = out->width;\n\t\tbds->height = out->height;\n\t}\n\tif (gdc->width <= 0 || gdc->height <= 0) {\n\t\tgdc->width = out->width;\n\t\tgdc->height = out->height;\n\t}\n\n\tin->width   = imgu_css_adjust(in->width, 1);\n\tin->height  = imgu_css_adjust(in->height, 1);\n\teff->width  = imgu_css_adjust(eff->width, EFF_ALIGN_W);\n\teff->height = imgu_css_adjust(eff->height, 1);\n\tbds->width  = imgu_css_adjust(bds->width, BDS_ALIGN_W);\n\tbds->height = imgu_css_adjust(bds->height, 1);\n\tgdc->width  = imgu_css_adjust(gdc->width, OUT_ALIGN_W);\n\tgdc->height = imgu_css_adjust(gdc->height, OUT_ALIGN_H);\n\tout->width  = imgu_css_adjust(out->width, OUT_ALIGN_W);\n\tout->height = imgu_css_adjust(out->height, OUT_ALIGN_H);\n\tvf->width   = imgu_css_adjust(vf->width, VF_ALIGN_W);\n\tvf->height  = imgu_css_adjust(vf->height, 1);\n\n\ts = (bds->width - gdc->width) / 2;\n\tenv->width = s < MIN_ENVELOPE ? MIN_ENVELOPE : s;\n\ts = (bds->height - gdc->height) / 2;\n\tenv->height = s < MIN_ENVELOPE ? MIN_ENVELOPE : s;\n\n\tret = imgu_css_find_binary(css, pipe, q, r);\n\tif (ret < 0) {\n\t\tdev_err(css->dev, \"failed to find suitable binary\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tcss->pipes[pipe].bindex = ret;\n\n\tdev_dbg(css->dev, \"Binary index %d for pipe %d found.\",\n\t\tcss->pipes[pipe].bindex, pipe);\n\n\t \n\tfor (i = 0; i < IPU3_CSS_QUEUES; i++) {\n\t\tif (fmts[i]) {\n\t\t\tif (imgu_css_queue_init(&q[i], &q[i].fmt.mpix,\n\t\t\t\t\t\tIPU3_CSS_QUEUE_TO_FLAGS(i))) {\n\t\t\t\tdev_err(css->dev,\n\t\t\t\t\t\"final resolution adjustment failed\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*fmts[i] = q[i].fmt.mpix;\n\t\t}\n\t}\n\n\tfor (i = 0; i < IPU3_CSS_RECTS; i++)\n\t\tif (rects[i])\n\t\t\t*rects[i] = r[i];\n\n\tdev_dbg(css->dev,\n\t\t\"in(%u,%u) if(%u,%u) ds(%u,%u) gdc(%u,%u) out(%u,%u) vf(%u,%u)\",\n\t\t in->width, in->height, eff->width, eff->height,\n\t\t bds->width, bds->height, gdc->width, gdc->height,\n\t\t out->width, out->height, vf->width, vf->height);\n\n\tret = 0;\nout:\n\tkfree(q);\n\treturn ret;\n}\n\nint imgu_css_fmt_set(struct imgu_css *css,\n\t\t     struct v4l2_pix_format_mplane *fmts[IPU3_CSS_QUEUES],\n\t\t     struct v4l2_rect *rects[IPU3_CSS_RECTS],\n\t\t     unsigned int pipe)\n{\n\tstruct v4l2_rect rect_data[IPU3_CSS_RECTS];\n\tstruct v4l2_rect *all_rects[IPU3_CSS_RECTS];\n\tint i, r;\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\n\tfor (i = 0; i < IPU3_CSS_RECTS; i++) {\n\t\tif (rects[i])\n\t\t\trect_data[i] = *rects[i];\n\t\telse\n\t\t\tmemset(&rect_data[i], 0, sizeof(rect_data[i]));\n\t\tall_rects[i] = &rect_data[i];\n\t}\n\tr = imgu_css_fmt_try(css, fmts, all_rects, pipe);\n\tif (r < 0)\n\t\treturn r;\n\n\tfor (i = 0; i < IPU3_CSS_QUEUES; i++)\n\t\tif (imgu_css_queue_init(&css_pipe->queue[i], fmts[i],\n\t\t\t\t\tIPU3_CSS_QUEUE_TO_FLAGS(i)))\n\t\t\treturn -EINVAL;\n\tfor (i = 0; i < IPU3_CSS_RECTS; i++) {\n\t\tcss_pipe->rect[i] = rect_data[i];\n\t\tif (rects[i])\n\t\t\t*rects[i] = rect_data[i];\n\t}\n\n\treturn 0;\n}\n\nint imgu_css_meta_fmt_set(struct v4l2_meta_format *fmt)\n{\n\tswitch (fmt->dataformat) {\n\tcase V4L2_META_FMT_IPU3_PARAMS:\n\t\tfmt->buffersize = sizeof(struct ipu3_uapi_params);\n\n\t\t \n\t\tBUILD_BUG_ON(sizeof(struct ipu3_uapi_params) != 39328);\n\n\t\tbreak;\n\tcase V4L2_META_FMT_IPU3_STAT_3A:\n\t\tfmt->buffersize = sizeof(struct ipu3_uapi_stats_3a);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint imgu_css_buf_queue(struct imgu_css *css, unsigned int pipe,\n\t\t       struct imgu_css_buffer *b)\n{\n\tstruct imgu_abi_buffer *abi_buf;\n\tstruct imgu_addr_t *buf_addr;\n\tu32 data;\n\tint r;\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\n\tif (!css->streaming)\n\t\treturn -EPROTO;\t \n\n\tif (b->queue >= IPU3_CSS_QUEUES || !imgu_css_queues[b->queue].qid)\n\t\treturn -EINVAL;\n\n\tb->queue_pos = imgu_css_queue_pos(css, imgu_css_queues[b->queue].qid,\n\t\t\t\t\t  pipe);\n\n\tif (b->queue_pos >= ARRAY_SIZE(css->pipes[pipe].abi_buffers[b->queue]))\n\t\treturn -EIO;\n\tabi_buf = css->pipes[pipe].abi_buffers[b->queue][b->queue_pos].vaddr;\n\n\t \n\tmemset(abi_buf, 0, sizeof(*abi_buf));\n\n\tbuf_addr = (void *)abi_buf + imgu_css_queues[b->queue].ptr_ofs;\n\t*(imgu_addr_t *)buf_addr = b->daddr;\n\n\tif (b->queue == IPU3_CSS_QUEUE_STAT_3A)\n\t\tabi_buf->payload.s3a.data.dmem.s3a_tbl = b->daddr;\n\n\tif (b->queue == IPU3_CSS_QUEUE_OUT)\n\t\tabi_buf->payload.frame.padded_width =\n\t\t\t\tcss_pipe->queue[IPU3_CSS_QUEUE_OUT].width_pad;\n\n\tif (b->queue == IPU3_CSS_QUEUE_VF)\n\t\tabi_buf->payload.frame.padded_width =\n\t\t\t\t\tcss_pipe->queue[IPU3_CSS_QUEUE_VF].width_pad;\n\n\tspin_lock(&css_pipe->qlock);\n\tlist_add_tail(&b->list, &css_pipe->queue[b->queue].bufs);\n\tspin_unlock(&css_pipe->qlock);\n\tb->state = IPU3_CSS_BUFFER_QUEUED;\n\n\tdata = css->pipes[pipe].abi_buffers[b->queue][b->queue_pos].daddr;\n\tr = imgu_css_queue_data(css, imgu_css_queues[b->queue].qid,\n\t\t\t\tpipe, data);\n\tif (r < 0)\n\t\tgoto queueing_failed;\n\n\tdata = IMGU_ABI_EVENT_BUFFER_ENQUEUED(pipe,\n\t\t\t\t\t      imgu_css_queues[b->queue].qid);\n\tr = imgu_css_queue_data(css, IMGU_ABI_QUEUE_EVENT_ID, pipe, data);\n\tif (r < 0)\n\t\tgoto queueing_failed;\n\n\tdev_dbg(css->dev, \"queued buffer %p to css queue %i in pipe %d\\n\",\n\t\tb, b->queue, pipe);\n\n\treturn 0;\n\nqueueing_failed:\n\tb->state = (r == -EBUSY || r == -EAGAIN) ?\n\t\tIPU3_CSS_BUFFER_NEW : IPU3_CSS_BUFFER_FAILED;\n\tlist_del(&b->list);\n\n\treturn r;\n}\n\n \nstruct imgu_css_buffer *imgu_css_buf_dequeue(struct imgu_css *css)\n{\n\tstatic const unsigned char evtype_to_queue[] = {\n\t\t[IMGU_ABI_EVTTYPE_INPUT_FRAME_DONE] = IPU3_CSS_QUEUE_IN,\n\t\t[IMGU_ABI_EVTTYPE_OUT_FRAME_DONE] = IPU3_CSS_QUEUE_OUT,\n\t\t[IMGU_ABI_EVTTYPE_VF_OUT_FRAME_DONE] = IPU3_CSS_QUEUE_VF,\n\t\t[IMGU_ABI_EVTTYPE_3A_STATS_DONE] = IPU3_CSS_QUEUE_STAT_3A,\n\t};\n\tstruct imgu_css_buffer *b = ERR_PTR(-EAGAIN);\n\tu32 event, daddr;\n\tint evtype, pipe, pipeid, queue, qid, r;\n\tstruct imgu_css_pipe *css_pipe;\n\n\tif (!css->streaming)\n\t\treturn ERR_PTR(-EPROTO);\n\n\tr = imgu_css_dequeue_data(css, IMGU_ABI_QUEUE_EVENT_ID, &event);\n\tif (r < 0)\n\t\treturn ERR_PTR(r);\n\n\tevtype = (event & IMGU_ABI_EVTTYPE_EVENT_MASK) >>\n\t\t  IMGU_ABI_EVTTYPE_EVENT_SHIFT;\n\n\tswitch (evtype) {\n\tcase IMGU_ABI_EVTTYPE_OUT_FRAME_DONE:\n\tcase IMGU_ABI_EVTTYPE_VF_OUT_FRAME_DONE:\n\tcase IMGU_ABI_EVTTYPE_3A_STATS_DONE:\n\tcase IMGU_ABI_EVTTYPE_INPUT_FRAME_DONE:\n\t\tpipe = (event & IMGU_ABI_EVTTYPE_PIPE_MASK) >>\n\t\t\tIMGU_ABI_EVTTYPE_PIPE_SHIFT;\n\t\tpipeid = (event & IMGU_ABI_EVTTYPE_PIPEID_MASK) >>\n\t\t\tIMGU_ABI_EVTTYPE_PIPEID_SHIFT;\n\t\tqueue = evtype_to_queue[evtype];\n\t\tqid = imgu_css_queues[queue].qid;\n\n\t\tif (pipe >= IMGU_MAX_PIPE_NUM) {\n\t\t\tdev_err(css->dev, \"Invalid pipe: %i\\n\", pipe);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tif (qid >= IMGU_ABI_QUEUE_NUM) {\n\t\t\tdev_err(css->dev, \"Invalid qid: %i\\n\", qid);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t\tcss_pipe = &css->pipes[pipe];\n\t\tdev_dbg(css->dev,\n\t\t\t\"event: buffer done 0x%x queue %i pipe %i pipeid %i\\n\",\n\t\t\tevent, queue, pipe, pipeid);\n\n\t\tr = imgu_css_dequeue_data(css, qid, &daddr);\n\t\tif (r < 0) {\n\t\t\tdev_err(css->dev, \"failed to dequeue buffer\\n\");\n\t\t\t \n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tr = imgu_css_queue_data(css, IMGU_ABI_QUEUE_EVENT_ID, pipe,\n\t\t\t\t\tIMGU_ABI_EVENT_BUFFER_DEQUEUED(qid));\n\t\tif (r < 0) {\n\t\t\tdev_err(css->dev, \"failed to queue event\\n\");\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tspin_lock(&css_pipe->qlock);\n\t\tif (list_empty(&css_pipe->queue[queue].bufs)) {\n\t\t\tspin_unlock(&css_pipe->qlock);\n\t\t\tdev_err(css->dev, \"event on empty queue\\n\");\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t\tb = list_first_entry(&css_pipe->queue[queue].bufs,\n\t\t\t\t     struct imgu_css_buffer, list);\n\t\tif (queue != b->queue ||\n\t\t    daddr != css_pipe->abi_buffers\n\t\t\t[b->queue][b->queue_pos].daddr) {\n\t\t\tspin_unlock(&css_pipe->qlock);\n\t\t\tdev_err(css->dev, \"dequeued bad buffer 0x%x\\n\", daddr);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tdev_dbg(css->dev, \"buffer 0x%8x done from pipe %d\\n\", daddr, pipe);\n\t\tb->pipe = pipe;\n\t\tb->state = IPU3_CSS_BUFFER_DONE;\n\t\tlist_del(&b->list);\n\t\tspin_unlock(&css_pipe->qlock);\n\t\tbreak;\n\tcase IMGU_ABI_EVTTYPE_PIPELINE_DONE:\n\t\tpipe = (event & IMGU_ABI_EVTTYPE_PIPE_MASK) >>\n\t\t\tIMGU_ABI_EVTTYPE_PIPE_SHIFT;\n\t\tif (pipe >= IMGU_MAX_PIPE_NUM) {\n\t\t\tdev_err(css->dev, \"Invalid pipe: %i\\n\", pipe);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tcss_pipe = &css->pipes[pipe];\n\t\tdev_dbg(css->dev, \"event: pipeline done 0x%8x for pipe %d\\n\",\n\t\t\tevent, pipe);\n\t\tbreak;\n\tcase IMGU_ABI_EVTTYPE_TIMER:\n\t\tr = imgu_css_dequeue_data(css, IMGU_ABI_QUEUE_EVENT_ID, &event);\n\t\tif (r < 0)\n\t\t\treturn ERR_PTR(r);\n\n\t\tif ((event & IMGU_ABI_EVTTYPE_EVENT_MASK) >>\n\t\t    IMGU_ABI_EVTTYPE_EVENT_SHIFT == IMGU_ABI_EVTTYPE_TIMER)\n\t\t\tdev_dbg(css->dev, \"event: timer\\n\");\n\t\telse\n\t\t\tdev_warn(css->dev, \"half of timer event missing\\n\");\n\t\tbreak;\n\tcase IMGU_ABI_EVTTYPE_FW_WARNING:\n\t\tdev_warn(css->dev, \"event: firmware warning 0x%x\\n\", event);\n\t\tbreak;\n\tcase IMGU_ABI_EVTTYPE_FW_ASSERT:\n\t\tdev_err(css->dev,\n\t\t\t\"event: firmware assert 0x%x module_id %i line_no %i\\n\",\n\t\t\tevent,\n\t\t\t(event & IMGU_ABI_EVTTYPE_MODULEID_MASK) >>\n\t\t\tIMGU_ABI_EVTTYPE_MODULEID_SHIFT,\n\t\t\tswab16((event & IMGU_ABI_EVTTYPE_LINENO_MASK) >>\n\t\t\t       IMGU_ABI_EVTTYPE_LINENO_SHIFT));\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(css->dev, \"received unknown event 0x%x\\n\", event);\n\t}\n\n\treturn b;\n}\n\n \nint imgu_css_set_parameters(struct imgu_css *css, unsigned int pipe,\n\t\t\t    struct ipu3_uapi_params *set_params)\n{\n\tstatic const unsigned int queue_id = IMGU_ABI_QUEUE_A_ID;\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\tconst int stage = 0;\n\tconst struct imgu_fw_info *bi;\n\tint obgrid_size;\n\tunsigned int stripes, i;\n\tstruct ipu3_uapi_flags *use = set_params ? &set_params->use : NULL;\n\n\t \n\tstruct imgu_abi_parameter_set_info *param_set;\n\tstruct imgu_abi_acc_param *acc = NULL;\n\tstruct imgu_abi_gdc_warp_param *gdc = NULL;\n\tstruct ipu3_uapi_obgrid_param *obgrid = NULL;\n\tconst struct imgu_css_map *map;\n\tvoid *vmem0 = NULL;\n\tvoid *dmem0 = NULL;\n\n\tenum imgu_abi_memories m;\n\tint r = -EBUSY;\n\n\tif (!css->streaming)\n\t\treturn -EPROTO;\n\n\tdev_dbg(css->dev, \"%s for pipe %d\", __func__, pipe);\n\n\tbi = &css->fwp->binary_header[css_pipe->bindex];\n\tobgrid_size = imgu_css_fw_obgrid_size(bi);\n\tstripes = bi->info.isp.sp.iterator.num_stripes ? : 1;\n\n\timgu_css_pool_get(&css_pipe->pool.parameter_set_info);\n\tparam_set = imgu_css_pool_last(&css_pipe->pool.parameter_set_info,\n\t\t\t\t       0)->vaddr;\n\n\t \n\tmap = imgu_css_pool_last(&css_pipe->pool.acc, 0);\n\tif (set_params || !map->vaddr) {\n\t\timgu_css_pool_get(&css_pipe->pool.acc);\n\t\tmap = imgu_css_pool_last(&css_pipe->pool.acc, 0);\n\t\tacc = map->vaddr;\n\t}\n\n\t \n\tm = IMGU_ABI_MEM_ISP_VMEM0;\n\tmap = imgu_css_pool_last(&css_pipe->pool.binary_params_p[m], 0);\n\tif (!map->vaddr || (set_params && (set_params->use.lin_vmem_params ||\n\t\t\t\t\t   set_params->use.tnr3_vmem_params ||\n\t\t\t\t\t   set_params->use.xnr3_vmem_params))) {\n\t\timgu_css_pool_get(&css_pipe->pool.binary_params_p[m]);\n\t\tmap = imgu_css_pool_last(&css_pipe->pool.binary_params_p[m], 0);\n\t\tvmem0 = map->vaddr;\n\t}\n\n\t \n\tm = IMGU_ABI_MEM_ISP_DMEM0;\n\tmap = imgu_css_pool_last(&css_pipe->pool.binary_params_p[m], 0);\n\tif (!map->vaddr || (set_params && (set_params->use.tnr3_dmem_params ||\n\t\t\t\t\t   set_params->use.xnr3_dmem_params))) {\n\t\timgu_css_pool_get(&css_pipe->pool.binary_params_p[m]);\n\t\tmap = imgu_css_pool_last(&css_pipe->pool.binary_params_p[m], 0);\n\t\tdmem0 = map->vaddr;\n\t}\n\n\t \n\tif (acc) {\n\t\t \n\t\tmap = imgu_css_pool_last(&css_pipe->pool.acc, 1);\n\t\t \n\t\tr = imgu_css_cfg_acc(css, pipe, use, acc, map->vaddr,\n\t\t\tset_params ? &set_params->acc_param : NULL);\n\t\tif (r < 0)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tif (vmem0) {\n\t\tm = IMGU_ABI_MEM_ISP_VMEM0;\n\t\tmap = imgu_css_pool_last(&css_pipe->pool.binary_params_p[m], 1);\n\t\tr = imgu_css_cfg_vmem0(css, pipe, use, vmem0,\n\t\t\t\t       map->vaddr, set_params);\n\t\tif (r < 0)\n\t\t\tgoto fail;\n\t}\n\n\tif (dmem0) {\n\t\tm = IMGU_ABI_MEM_ISP_DMEM0;\n\t\tmap = imgu_css_pool_last(&css_pipe->pool.binary_params_p[m], 1);\n\t\tr = imgu_css_cfg_dmem0(css, pipe, use, dmem0,\n\t\t\t\t       map->vaddr, set_params);\n\t\tif (r < 0)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tif (bi->info.isp.sp.enable.dvs_6axis) {\n\t\tunsigned int a = IPU3_CSS_AUX_FRAME_REF;\n\t\tunsigned int g = IPU3_CSS_RECT_GDC;\n\t\tunsigned int e = IPU3_CSS_RECT_ENVELOPE;\n\n\t\tmap = imgu_css_pool_last(&css_pipe->pool.gdc, 0);\n\t\tif (!map->vaddr) {\n\t\t\timgu_css_pool_get(&css_pipe->pool.gdc);\n\t\t\tmap = imgu_css_pool_last(&css_pipe->pool.gdc, 0);\n\t\t\tgdc = map->vaddr;\n\t\t\timgu_css_cfg_gdc_table(map->vaddr,\n\t\t\t\tcss_pipe->aux_frames[a].bytesperline /\n\t\t\t\tcss_pipe->aux_frames[a].bytesperpixel,\n\t\t\t\tcss_pipe->aux_frames[a].height,\n\t\t\t\tcss_pipe->rect[g].width,\n\t\t\t\tcss_pipe->rect[g].height,\n\t\t\t\tcss_pipe->rect[e].width,\n\t\t\t\tcss_pipe->rect[e].height);\n\t\t}\n\t}\n\n\t \n\tmap = imgu_css_pool_last(&css_pipe->pool.obgrid, 0);\n\tif (!map->vaddr || (set_params && set_params->use.obgrid_param)) {\n\t\timgu_css_pool_get(&css_pipe->pool.obgrid);\n\t\tmap = imgu_css_pool_last(&css_pipe->pool.obgrid, 0);\n\t\tobgrid = map->vaddr;\n\n\t\t \n\t\tif (set_params && set_params->use.obgrid_param)\n\t\t\tfor (i = 0; i < obgrid_size / sizeof(*obgrid); i++)\n\t\t\t\tobgrid[i] = set_params->obgrid_param;\n\t\telse\n\t\t\tmemset(obgrid, 0, obgrid_size);\n\t}\n\n\t \n\n\tmemset(param_set, 0, sizeof(*param_set));\n\tmap = imgu_css_pool_last(&css_pipe->pool.acc, 0);\n\tparam_set->mem_map.acc_cluster_params_for_sp = map->daddr;\n\n\tmap = imgu_css_pool_last(&css_pipe->pool.gdc, 0);\n\tparam_set->mem_map.dvs_6axis_params_y = map->daddr;\n\n\tfor (i = 0; i < stripes; i++) {\n\t\tmap = imgu_css_pool_last(&css_pipe->pool.obgrid, 0);\n\t\tparam_set->mem_map.obgrid_tbl[i] =\n\t\t\tmap->daddr + (obgrid_size / stripes) * i;\n\t}\n\n\tfor (m = 0; m < IMGU_ABI_NUM_MEMORIES; m++) {\n\t\tmap = imgu_css_pool_last(&css_pipe->pool.binary_params_p[m], 0);\n\t\tparam_set->mem_map.isp_mem_param[stage][m] = map->daddr;\n\t}\n\n\t \n\tmap = imgu_css_pool_last(&css_pipe->pool.parameter_set_info, 0);\n\tr = imgu_css_queue_data(css, queue_id, pipe, map->daddr);\n\tif (r < 0)\n\t\tgoto fail;\n\n\tr = imgu_css_queue_data(css, IMGU_ABI_QUEUE_EVENT_ID, pipe,\n\t\t\t\tIMGU_ABI_EVENT_BUFFER_ENQUEUED(pipe,\n\t\t\t\t\t\t\t       queue_id));\n\tif (r < 0)\n\t\tgoto fail_no_put;\n\n\t \n\n\tdo {\n\t\tu32 daddr;\n\n\t\tr = imgu_css_dequeue_data(css, queue_id, &daddr);\n\t\tif (r == -EBUSY)\n\t\t\tbreak;\n\t\tif (r)\n\t\t\tgoto fail_no_put;\n\t\tr = imgu_css_queue_data(css, IMGU_ABI_QUEUE_EVENT_ID, pipe,\n\t\t\t\t\tIMGU_ABI_EVENT_BUFFER_DEQUEUED\n\t\t\t\t\t(queue_id));\n\t\tif (r < 0) {\n\t\t\tdev_err(css->dev, \"failed to queue parameter event\\n\");\n\t\t\tgoto fail_no_put;\n\t\t}\n\t} while (1);\n\n\treturn 0;\n\nfail:\n\t \n\n\timgu_css_pool_put(&css_pipe->pool.parameter_set_info);\n\tif (acc)\n\t\timgu_css_pool_put(&css_pipe->pool.acc);\n\tif (gdc)\n\t\timgu_css_pool_put(&css_pipe->pool.gdc);\n\tif (obgrid)\n\t\timgu_css_pool_put(&css_pipe->pool.obgrid);\n\tif (vmem0)\n\t\timgu_css_pool_put(\n\t\t\t&css_pipe->pool.binary_params_p\n\t\t\t[IMGU_ABI_MEM_ISP_VMEM0]);\n\tif (dmem0)\n\t\timgu_css_pool_put(\n\t\t\t&css_pipe->pool.binary_params_p\n\t\t\t[IMGU_ABI_MEM_ISP_DMEM0]);\n\nfail_no_put:\n\treturn r;\n}\n\nint imgu_css_irq_ack(struct imgu_css *css)\n{\n\tstatic const int NUM_SWIRQS = 3;\n\tstruct imgu_fw_info *bi = &css->fwp->binary_header[css->fw_sp[0]];\n\tvoid __iomem *const base = css->base;\n\tu32 irq_status[IMGU_IRQCTRL_NUM];\n\tint i;\n\n\tu32 imgu_status = readl(base + IMGU_REG_INT_STATUS);\n\n\twritel(imgu_status, base + IMGU_REG_INT_STATUS);\n\tfor (i = 0; i < IMGU_IRQCTRL_NUM; i++)\n\t\tirq_status[i] = readl(base + IMGU_REG_IRQCTRL_STATUS(i));\n\n\tfor (i = 0; i < NUM_SWIRQS; i++) {\n\t\tif (irq_status[IMGU_IRQCTRL_SP0] & IMGU_IRQCTRL_IRQ_SW_PIN(i)) {\n\t\t\t \n\t\t\tu32 cnt = readl(base + IMGU_REG_SP_DMEM_BASE(0) +\n\t\t\t\t\tbi->info.sp.output);\n\t\t\tu32 val = readl(base + IMGU_REG_SP_DMEM_BASE(0) +\n\t\t\t\t\tbi->info.sp.output + 4 + 4 * i);\n\n\t\t\tdev_dbg(css->dev, \"%s: swirq %i cnt %i val 0x%x\\n\",\n\t\t\t\t__func__, i, cnt, val);\n\t\t}\n\t}\n\n\tfor (i = IMGU_IRQCTRL_NUM - 1; i >= 0; i--)\n\t\tif (irq_status[i]) {\n\t\t\twritel(irq_status[i], base + IMGU_REG_IRQCTRL_CLEAR(i));\n\t\t\t \n\t\t\treadl(base + IMGU_REG_IRQCTRL_ENABLE(i));\n\t\t}\n\n\tdev_dbg(css->dev, \"%s: imgu 0x%x main 0x%x sp0 0x%x sp1 0x%x\\n\",\n\t\t__func__, imgu_status, irq_status[IMGU_IRQCTRL_MAIN],\n\t\tirq_status[IMGU_IRQCTRL_SP0], irq_status[IMGU_IRQCTRL_SP1]);\n\n\tif (!imgu_status && !irq_status[IMGU_IRQCTRL_MAIN])\n\t\treturn -ENOMSG;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}