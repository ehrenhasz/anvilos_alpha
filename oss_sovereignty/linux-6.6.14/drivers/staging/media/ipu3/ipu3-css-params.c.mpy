{
  "module_name": "ipu3-css-params.c",
  "hash_id": "76d32728eb65a42d5bc03f7117314ec1cb17f40d1f378d291473577debc27f2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/ipu3/ipu3-css-params.c",
  "human_readable_source": "\n\n\n#include <linux/device.h>\n\n#include \"ipu3-css.h\"\n#include \"ipu3-css-fw.h\"\n#include \"ipu3-tables.h\"\n#include \"ipu3-css-params.h\"\n\n#define DIV_ROUND_CLOSEST_DOWN(a, b)\t(((a) + ((b) / 2) - 1) / (b))\n#define roundclosest_down(a, b)\t\t(DIV_ROUND_CLOSEST_DOWN(a, b) * (b))\n\n#define IPU3_UAPI_ANR_MAX_RESET\t\t((1 << 12) - 1)\n#define IPU3_UAPI_ANR_MIN_RESET\t\t(((-1) << 12) + 1)\n\nstruct imgu_css_scaler_info {\n\tunsigned int phase_step;\t \n\tint exp_shift;\n\n\tunsigned int phase_init;\t \n\tint pad_left;\n\tint pad_right;\n\tint crop_left;\n\tint crop_top;\n};\n\nstatic unsigned int imgu_css_scaler_get_exp(unsigned int counter,\n\t\t\t\t\t    unsigned int divider)\n{\n\tint i = fls(divider) - fls(counter);\n\n\tif (i <= 0)\n\t\treturn 0;\n\n\tif (divider >> i < counter)\n\t\ti = i - 1;\n\n\treturn i;\n}\n\n \nstatic void\nimgu_css_scaler_setup_lut(unsigned int taps, unsigned int input_width,\n\t\t\t  unsigned int output_width, int phase_step_correction,\n\t\t\t  const int *coeffs, unsigned int coeffs_size,\n\t\t\t  s8 coeff_lut[], struct imgu_css_scaler_info *info)\n{\n\tint tap, phase, phase_sum_left, phase_sum_right;\n\tint exponent = imgu_css_scaler_get_exp(output_width, input_width);\n\tint mantissa = (1 << exponent) * output_width;\n\tunsigned int phase_step, phase_taps;\n\n\tif (input_width == output_width) {\n\t\tfor (phase = 0; phase < IMGU_SCALER_PHASES; phase++) {\n\t\t\tphase_taps = phase * IMGU_SCALER_FILTER_TAPS;\n\t\t\tfor (tap = 0; tap < taps; tap++)\n\t\t\t\tcoeff_lut[phase_taps + tap] = 0;\n\t\t}\n\n\t\tinfo->phase_step = IMGU_SCALER_PHASES *\n\t\t\t(1 << IMGU_SCALER_PHASE_COUNTER_PREC_REF);\n\t\tinfo->exp_shift = 0;\n\t\tinfo->pad_left = 0;\n\t\tinfo->pad_right = 0;\n\t\tinfo->phase_init = 0;\n\t\tinfo->crop_left = 0;\n\t\tinfo->crop_top = 0;\n\t\treturn;\n\t}\n\n\tfor (phase = 0; phase < IMGU_SCALER_PHASES; phase++) {\n\t\tphase_taps = phase * IMGU_SCALER_FILTER_TAPS;\n\t\tfor (tap = 0; tap < taps; tap++) {\n\t\t\t \n\t\t\ts64 coeff = coeffs[coeffs_size -\n\t\t\t\t((tap * (coeffs_size / taps)) + phase) - 1];\n\t\t\tcoeff *= mantissa;\n\t\t\tcoeff = div64_long(coeff, input_width);\n\n\t\t\t \n\t\t\tcoeff += 1 << (IMGU_SCALER_COEFF_BITS - 1);\n\t\t\tcoeff >>= IMGU_SCALER_COEFF_BITS;\n\t\t\tcoeff_lut[phase_taps + tap] = coeff;\n\t\t}\n\t}\n\n\tphase_step = IMGU_SCALER_PHASES *\n\t\t\t(1 << IMGU_SCALER_PHASE_COUNTER_PREC_REF) *\n\t\t\toutput_width / input_width;\n\tphase_step += phase_step_correction;\n\tphase_sum_left = (taps / 2 * IMGU_SCALER_PHASES *\n\t\t\t(1 << IMGU_SCALER_PHASE_COUNTER_PREC_REF)) -\n\t\t\t(1 << (IMGU_SCALER_PHASE_COUNTER_PREC_REF - 1));\n\tphase_sum_right = (taps / 2 * IMGU_SCALER_PHASES *\n\t\t\t(1 << IMGU_SCALER_PHASE_COUNTER_PREC_REF)) +\n\t\t\t(1 << (IMGU_SCALER_PHASE_COUNTER_PREC_REF - 1));\n\n\tinfo->exp_shift = IMGU_SCALER_MAX_EXPONENT_SHIFT - exponent;\n\tinfo->pad_left = (phase_sum_left % phase_step == 0) ?\n\t\tphase_sum_left / phase_step - 1 : phase_sum_left / phase_step;\n\tinfo->pad_right = (phase_sum_right % phase_step == 0) ?\n\t\tphase_sum_right / phase_step - 1 : phase_sum_right / phase_step;\n\tinfo->phase_init = phase_sum_left - phase_step * info->pad_left;\n\tinfo->phase_step = phase_step;\n\tinfo->crop_left = taps - 1;\n\tinfo->crop_top = taps - 1;\n}\n\n \nstatic unsigned int\nimgu_css_scaler_calc_scaled_output(unsigned int input,\n\t\t\t\t   struct imgu_css_scaler_info *info)\n{\n\tunsigned int arg1 = input * info->phase_step +\n\t\t\t(1 - IMGU_SCALER_TAPS_Y / 2) * IMGU_SCALER_FIR_PHASES -\n\t\t\tIMGU_SCALER_FIR_PHASES / (2 * IMGU_SCALER_PHASES);\n\tunsigned int arg2 = ((IMGU_SCALER_TAPS_Y / 2) * IMGU_SCALER_FIR_PHASES +\n\t\t\tIMGU_SCALER_FIR_PHASES / (2 * IMGU_SCALER_PHASES)) *\n\t\t\tIMGU_SCALER_FIR_PHASES + info->phase_step / 2;\n\n\treturn ((arg1 + (arg2 - IMGU_SCALER_FIR_PHASES * info->phase_step) /\n\t\tIMGU_SCALER_FIR_PHASES) / (2 * IMGU_SCALER_FIR_PHASES)) * 2;\n}\n\n \nstatic void\nimgu_css_scaler_calc(u32 input_width, u32 input_height, u32 target_width,\n\t\t     u32 target_height, struct imgu_abi_osys_config *cfg,\n\t\t     struct imgu_css_scaler_info *info_luma,\n\t\t     struct imgu_css_scaler_info *info_chroma,\n\t\t     unsigned int *output_width, unsigned int *output_height,\n\t\t     unsigned int *procmode)\n{\n\tu32 out_width = target_width;\n\tu32 out_height = target_height;\n\tconst unsigned int height_alignment = 2;\n\tint phase_step_correction = -1;\n\n\t \n\tif (target_height * input_width > target_width * input_height)\n\t\ttarget_width = DIV_ROUND_UP(target_height * input_width,\n\t\t\t\t\t    input_height);\n\n\tif (input_width == target_width)\n\t\t*procmode = IMGU_ABI_OSYS_PROCMODE_BYPASS;\n\telse\n\t\t*procmode = IMGU_ABI_OSYS_PROCMODE_DOWNSCALE;\n\n\tmemset(&cfg->scaler_coeffs_chroma, 0,\n\t       sizeof(cfg->scaler_coeffs_chroma));\n\tmemset(&cfg->scaler_coeffs_luma, 0, sizeof(cfg->scaler_coeffs_luma));\n\tdo {\n\t\tphase_step_correction++;\n\n\t\timgu_css_scaler_setup_lut(IMGU_SCALER_TAPS_Y,\n\t\t\t\t\t  input_width, target_width,\n\t\t\t\t\t  phase_step_correction,\n\t\t\t\t\t  imgu_css_downscale_4taps,\n\t\t\t\t\t  IMGU_SCALER_DOWNSCALE_4TAPS_LEN,\n\t\t\t\t\t  cfg->scaler_coeffs_luma, info_luma);\n\n\t\timgu_css_scaler_setup_lut(IMGU_SCALER_TAPS_UV,\n\t\t\t\t\t  input_width, target_width,\n\t\t\t\t\t  phase_step_correction,\n\t\t\t\t\t  imgu_css_downscale_2taps,\n\t\t\t\t\t  IMGU_SCALER_DOWNSCALE_2TAPS_LEN,\n\t\t\t\t\t  cfg->scaler_coeffs_chroma,\n\t\t\t\t\t  info_chroma);\n\n\t\tout_width = imgu_css_scaler_calc_scaled_output(input_width,\n\t\t\t\t\t\t\t       info_luma);\n\t\tout_height = imgu_css_scaler_calc_scaled_output(input_height,\n\t\t\t\t\t\t\t\tinfo_luma);\n\t} while ((out_width < target_width || out_height < target_height ||\n\t\t !IS_ALIGNED(out_height, height_alignment)) &&\n\t\t phase_step_correction <= 5);\n\n\t*output_width = out_width;\n\t*output_height = out_height;\n}\n\n \n\nstatic void imgu_css_osys_set_format(enum imgu_abi_frame_format host_format,\n\t\t\t\t     unsigned int *osys_format,\n\t\t\t\t     unsigned int *osys_tiling)\n{\n\t*osys_format = IMGU_ABI_OSYS_FORMAT_YUV420;\n\t*osys_tiling = IMGU_ABI_OSYS_TILING_NONE;\n\n\tswitch (host_format) {\n\tcase IMGU_ABI_FRAME_FORMAT_YUV420:\n\t\t*osys_format = IMGU_ABI_OSYS_FORMAT_YUV420;\n\t\tbreak;\n\tcase IMGU_ABI_FRAME_FORMAT_YV12:\n\t\t*osys_format = IMGU_ABI_OSYS_FORMAT_YV12;\n\t\tbreak;\n\tcase IMGU_ABI_FRAME_FORMAT_NV12:\n\t\t*osys_format = IMGU_ABI_OSYS_FORMAT_NV12;\n\t\tbreak;\n\tcase IMGU_ABI_FRAME_FORMAT_NV16:\n\t\t*osys_format = IMGU_ABI_OSYS_FORMAT_NV16;\n\t\tbreak;\n\tcase IMGU_ABI_FRAME_FORMAT_NV21:\n\t\t*osys_format = IMGU_ABI_OSYS_FORMAT_NV21;\n\t\tbreak;\n\tcase IMGU_ABI_FRAME_FORMAT_NV12_TILEY:\n\t\t*osys_format = IMGU_ABI_OSYS_FORMAT_NV12;\n\t\t*osys_tiling = IMGU_ABI_OSYS_TILING_Y;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\n \nstatic int imgu_css_osys_calc_stripe_offset(int stripe_offset_out,\n\t\t\t\t\t    int fir_phases, int phase_init,\n\t\t\t\t\t    int phase_step, int pad_left)\n{\n\tint stripe_offset_inp = stripe_offset_out * fir_phases -\n\t\t\t\tpad_left * phase_step;\n\n\treturn DIV_ROUND_UP(stripe_offset_inp - phase_init, phase_step);\n}\n\n \nstatic int imgu_css_osys_calc_stripe_phase_init(int stripe_offset_out,\n\t\t\t\t\t\tint fir_phases, int phase_init,\n\t\t\t\t\t\tint phase_step, int pad_left)\n{\n\tint stripe_offset_inp =\n\t\timgu_css_osys_calc_stripe_offset(stripe_offset_out,\n\t\t\t\t\t\t fir_phases, phase_init,\n\t\t\t\t\t\t phase_step, pad_left);\n\n\treturn phase_init + ((pad_left + stripe_offset_inp) * phase_step) -\n\t\tstripe_offset_out * fir_phases;\n}\n\n \nstatic int imgu_css_osys_calc_inp_stripe_width(int stripe_width_out,\n\t\t\t\t\t       int fir_phases, int phase_init,\n\t\t\t\t\t       int phase_step, int fir_taps,\n\t\t\t\t\t       int pad_left, int pad_right)\n{\n\tint stripe_width_inp = (stripe_width_out + fir_taps - 1) * fir_phases;\n\n\tstripe_width_inp = DIV_ROUND_UP(stripe_width_inp - phase_init,\n\t\t\t\t\tphase_step);\n\n\treturn stripe_width_inp - pad_left - pad_right;\n}\n\n \nstatic int imgu_css_osys_out_stripe_width(int stripe_width_inp, int fir_phases,\n\t\t\t\t\t  int phase_init, int phase_step,\n\t\t\t\t\t  int fir_taps, int pad_left,\n\t\t\t\t\t  int pad_right, int column_offset)\n{\n\tint stripe_width_out = (pad_left + stripe_width_inp +\n\t\t\t\tpad_right - column_offset) * phase_step;\n\n\tstripe_width_out = (stripe_width_out + phase_init) / fir_phases;\n\n\treturn stripe_width_out - (fir_taps - 1);\n}\n\nstruct imgu_css_reso {\n\tunsigned int input_width;\n\tunsigned int input_height;\n\tenum imgu_abi_frame_format input_format;\n\tunsigned int pin_width[IMGU_ABI_OSYS_PINS];\n\tunsigned int pin_height[IMGU_ABI_OSYS_PINS];\n\tunsigned int pin_stride[IMGU_ABI_OSYS_PINS];\n\tenum imgu_abi_frame_format pin_format[IMGU_ABI_OSYS_PINS];\n\tint chunk_width;\n\tint chunk_height;\n\tint block_height;\n\tint block_width;\n};\n\nstruct imgu_css_frame_params {\n\t \n\tunsigned int enable;\n\tunsigned int format;\n\tunsigned int flip;\n\tunsigned int mirror;\n\tunsigned int tiling;\n\tunsigned int reduce_range;\n\tunsigned int width;\n\tunsigned int height;\n\tunsigned int stride;\n\tunsigned int scaled;\n\tunsigned int crop_left;\n\tunsigned int crop_top;\n};\n\nstruct imgu_css_stripe_params {\n\tunsigned int processing_mode;\n\tunsigned int phase_step;\n\tunsigned int exp_shift;\n\tunsigned int phase_init_left_y;\n\tunsigned int phase_init_left_uv;\n\tunsigned int phase_init_top_y;\n\tunsigned int phase_init_top_uv;\n\tunsigned int pad_left_y;\n\tunsigned int pad_left_uv;\n\tunsigned int pad_right_y;\n\tunsigned int pad_right_uv;\n\tunsigned int pad_top_y;\n\tunsigned int pad_top_uv;\n\tunsigned int pad_bottom_y;\n\tunsigned int pad_bottom_uv;\n\tunsigned int crop_left_y;\n\tunsigned int crop_top_y;\n\tunsigned int crop_left_uv;\n\tunsigned int crop_top_uv;\n\tunsigned int start_column_y;\n\tunsigned int start_column_uv;\n\tunsigned int chunk_width;\n\tunsigned int chunk_height;\n\tunsigned int block_width;\n\tunsigned int block_height;\n\tunsigned int input_width;\n\tunsigned int input_height;\n\tint output_width[IMGU_ABI_OSYS_PINS];\n\tint output_height[IMGU_ABI_OSYS_PINS];\n\tint output_offset[IMGU_ABI_OSYS_PINS];\n};\n\n \nstatic int imgu_css_osys_calc_frame_and_stripe_params(\n\t\tstruct imgu_css *css, unsigned int stripes,\n\t\tstruct imgu_abi_osys_config *osys,\n\t\tstruct imgu_css_scaler_info *scaler_luma,\n\t\tstruct imgu_css_scaler_info *scaler_chroma,\n\t\tstruct imgu_css_frame_params frame_params[],\n\t\tstruct imgu_css_stripe_params stripe_params[],\n\t\tunsigned int pipe)\n{\n\tstruct imgu_css_reso reso;\n\tunsigned int output_width, pin, s;\n\tu32 input_width, input_height, target_width, target_height;\n\tunsigned int procmode = 0;\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\n\tinput_width = css_pipe->rect[IPU3_CSS_RECT_GDC].width;\n\tinput_height = css_pipe->rect[IPU3_CSS_RECT_GDC].height;\n\ttarget_width = css_pipe->queue[IPU3_CSS_QUEUE_VF].fmt.mpix.width;\n\ttarget_height = css_pipe->queue[IPU3_CSS_QUEUE_VF].fmt.mpix.height;\n\n\t \n\n\t \n\treso.input_width = css_pipe->rect[IPU3_CSS_RECT_GDC].width;\n\n\t \n\treso.input_height = css_pipe->rect[IPU3_CSS_RECT_GDC].height;\n\n\treso.input_format =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_OUT].css_fmt->frame_format;\n\n\treso.pin_width[IMGU_ABI_OSYS_PIN_OUT] =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_OUT].fmt.mpix.width;\n\treso.pin_height[IMGU_ABI_OSYS_PIN_OUT] =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_OUT].fmt.mpix.height;\n\treso.pin_stride[IMGU_ABI_OSYS_PIN_OUT] =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_OUT].width_pad;\n\treso.pin_format[IMGU_ABI_OSYS_PIN_OUT] =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_OUT].css_fmt->frame_format;\n\n\treso.pin_width[IMGU_ABI_OSYS_PIN_VF] =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_VF].fmt.mpix.width;\n\treso.pin_height[IMGU_ABI_OSYS_PIN_VF] =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_VF].fmt.mpix.height;\n\treso.pin_stride[IMGU_ABI_OSYS_PIN_VF] =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_VF].width_pad;\n\treso.pin_format[IMGU_ABI_OSYS_PIN_VF] =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_VF].css_fmt->frame_format;\n\n\t \n\n\tframe_params[IMGU_ABI_OSYS_PIN_OUT].width =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_OUT].fmt.mpix.width;\n\tframe_params[IMGU_ABI_OSYS_PIN_OUT].height =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_OUT].fmt.mpix.height;\n\tframe_params[IMGU_ABI_OSYS_PIN_VF].width =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_VF].fmt.mpix.width;\n\tframe_params[IMGU_ABI_OSYS_PIN_VF].height =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_VF].fmt.mpix.height;\n\tframe_params[IMGU_ABI_OSYS_PIN_VF].crop_top = 0;\n\tframe_params[IMGU_ABI_OSYS_PIN_VF].crop_left = 0;\n\n\tfor (pin = 0; pin < IMGU_ABI_OSYS_PINS; pin++) {\n\t\tint enable = 0;\n\t\tint scaled = 0;\n\t\tunsigned int format = 0;\n\t\tunsigned int tiling = 0;\n\n\t\tframe_params[pin].flip = 0;\n\t\tframe_params[pin].mirror = 0;\n\t\tframe_params[pin].reduce_range = 0;\n\t\tif (reso.pin_width[pin] != 0 && reso.pin_height[pin] != 0) {\n\t\t\tenable = 1;\n\t\t\tif (pin == IMGU_ABI_OSYS_PIN_OUT) {\n\t\t\t\tif (reso.input_width < reso.pin_width[pin] ||\n\t\t\t\t    reso.input_height < reso.pin_height[pin])\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t \n\t\t\t\tframe_params[pin].crop_left = roundclosest_down(\n\t\t\t\t\t\t(reso.input_width -\n\t\t\t\t\t\t reso.pin_width[pin]) / 2,\n\t\t\t\t\t\t IMGU_OSYS_DMA_CROP_W_LIMIT);\n\t\t\t\tframe_params[pin].crop_top = roundclosest_down(\n\t\t\t\t\t\t(reso.input_height -\n\t\t\t\t\t\t reso.pin_height[pin]) / 2,\n\t\t\t\t\t\t IMGU_OSYS_DMA_CROP_H_LIMIT);\n\t\t\t} else {\n\t\t\t\tif (reso.pin_width[pin] != reso.input_width ||\n\t\t\t\t    reso.pin_height[pin] != reso.input_height) {\n\t\t\t\t\t \n\t\t\t\t\tscaled = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\timgu_css_osys_set_format(reso.pin_format[pin], &format,\n\t\t\t\t\t\t &tiling);\n\t\t} else {\n\t\t\tenable = 0;\n\t\t}\n\t\tframe_params[pin].enable = enable;\n\t\tframe_params[pin].format = format;\n\t\tframe_params[pin].tiling = tiling;\n\t\tframe_params[pin].stride = reso.pin_stride[pin];\n\t\tframe_params[pin].scaled = scaled;\n\t}\n\n\timgu_css_scaler_calc(input_width, input_height, target_width,\n\t\t\t     target_height, osys, scaler_luma, scaler_chroma,\n\t\t\t     &reso.pin_width[IMGU_ABI_OSYS_PIN_VF],\n\t\t\t     &reso.pin_height[IMGU_ABI_OSYS_PIN_VF], &procmode);\n\tdev_dbg(css->dev, \"osys scaler procmode is %u\", procmode);\n\toutput_width = reso.pin_width[IMGU_ABI_OSYS_PIN_VF];\n\n\tif (output_width < reso.input_width / 2) {\n\t\t \n\t\treso.chunk_width = IMGU_OSYS_BLOCK_WIDTH;\n\t\treso.block_width = IMGU_OSYS_BLOCK_WIDTH;\n\t} else {  \n\t\treso.chunk_width = IMGU_OSYS_BLOCK_WIDTH / 2;\n\t\treso.block_width = IMGU_OSYS_BLOCK_WIDTH;\n\t}\n\n\tif (output_width <= reso.input_width * 7 / 8) {\n\t\t \n\t\treso.chunk_height = IMGU_OSYS_BLOCK_HEIGHT;\n\t\treso.block_height = IMGU_OSYS_BLOCK_HEIGHT;\n\t} else {  \n\t\treso.chunk_height = IMGU_OSYS_BLOCK_HEIGHT / 2;\n\t\treso.block_height = IMGU_OSYS_BLOCK_HEIGHT;\n\t}\n\n\t \n\n\tif (frame_params[IMGU_ABI_OSYS_PIN_VF].enable) {\n\t\t \n\t\tu32 w = reso.pin_width[IMGU_ABI_OSYS_PIN_VF] -\n\t\t\tframe_params[IMGU_ABI_OSYS_PIN_VF].width;\n\t\tu32 h = reso.pin_height[IMGU_ABI_OSYS_PIN_VF] -\n\t\t\tframe_params[IMGU_ABI_OSYS_PIN_VF].height;\n\n\t\tframe_params[IMGU_ABI_OSYS_PIN_VF].crop_left =\n\t\t\troundclosest_down(w / 2, IMGU_OSYS_DMA_CROP_W_LIMIT);\n\t\tframe_params[IMGU_ABI_OSYS_PIN_VF].crop_top =\n\t\t\troundclosest_down(h / 2, IMGU_OSYS_DMA_CROP_H_LIMIT);\n\n\t\tif (reso.input_height % 4 || reso.input_width % 8) {\n\t\t\tdev_err(css->dev, \"OSYS input width is not multiple of 8 or\\n\");\n\t\t\tdev_err(css->dev, \"height is not multiple of 4\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\n\tif (frame_params[IMGU_ABI_OSYS_PIN_VF].enable) {\n\t\toutput_width = reso.pin_width[IMGU_ABI_OSYS_PIN_VF];\n\t} else {\n\t\t \n\t\toutput_width = reso.input_width;\n\t}\n\n\tfor (s = 0; s < stripes; s++) {\n\t\tint stripe_offset_inp_y = 0;\n\t\tint stripe_offset_inp_uv = 0;\n\t\tint stripe_offset_out_y = 0;\n\t\tint stripe_offset_out_uv = 0;\n\t\tint stripe_phase_init_y = scaler_luma->phase_init;\n\t\tint stripe_phase_init_uv = scaler_chroma->phase_init;\n\t\tint stripe_offset_blk_y = 0;\n\t\tint stripe_offset_blk_uv = 0;\n\t\tint stripe_offset_col_y = 0;\n\t\tint stripe_offset_col_uv = 0;\n\t\tint stripe_pad_left_y = scaler_luma->pad_left;\n\t\tint stripe_pad_left_uv = scaler_chroma->pad_left;\n\t\tint stripe_pad_right_y = scaler_luma->pad_right;\n\t\tint stripe_pad_right_uv = scaler_chroma->pad_right;\n\t\tint stripe_crop_left_y = scaler_luma->crop_left;\n\t\tint stripe_crop_left_uv = scaler_chroma->crop_left;\n\t\tint stripe_input_width_y = reso.input_width;\n\t\tint stripe_input_width_uv = 0;\n\t\tint stripe_output_width_y = output_width;\n\t\tint stripe_output_width_uv = 0;\n\t\tint chunk_floor_y = 0;\n\t\tint chunk_floor_uv = 0;\n\t\tint chunk_ceil_uv = 0;\n\n\t\tif (stripes > 1) {\n\t\t\tif (s > 0) {\n\t\t\t\t \n\t\t\t\tstripe_offset_out_y =\n\t\t\t\t\toutput_width * s / stripes;\n\t\t\t\tstripe_offset_out_y =\n\t\t\t\t\trounddown(stripe_offset_out_y,\n\t\t\t\t\t\t  IPU3_UAPI_ISP_VEC_ELEMS);\n\t\t\t\tstripe_offset_out_uv = stripe_offset_out_y /\n\t\t\t\t\t\tIMGU_LUMA_TO_CHROMA_RATIO;\n\t\t\t\tstripe_offset_inp_y =\n\t\t\t\t\timgu_css_osys_calc_stripe_offset(\n\t\t\t\t\t\tstripe_offset_out_y,\n\t\t\t\t\t\tIMGU_OSYS_FIR_PHASES,\n\t\t\t\t\t\tscaler_luma->phase_init,\n\t\t\t\t\t\tscaler_luma->phase_step,\n\t\t\t\t\t\tscaler_luma->pad_left);\n\t\t\t\tstripe_offset_inp_uv =\n\t\t\t\t\timgu_css_osys_calc_stripe_offset(\n\t\t\t\t\t\tstripe_offset_out_uv,\n\t\t\t\t\t\tIMGU_OSYS_FIR_PHASES,\n\t\t\t\t\t\tscaler_chroma->phase_init,\n\t\t\t\t\t\tscaler_chroma->phase_step,\n\t\t\t\t\t\tscaler_chroma->pad_left);\n\n\t\t\t\t \n\t\t\t\tstripe_phase_init_y =\n\t\t\t\t\timgu_css_osys_calc_stripe_phase_init(\n\t\t\t\t\t\tstripe_offset_out_y,\n\t\t\t\t\t\tIMGU_OSYS_FIR_PHASES,\n\t\t\t\t\t\tscaler_luma->phase_init,\n\t\t\t\t\t\tscaler_luma->phase_step,\n\t\t\t\t\t\tscaler_luma->pad_left);\n\t\t\t\tstripe_phase_init_uv =\n\t\t\t\t\timgu_css_osys_calc_stripe_phase_init(\n\t\t\t\t\t\tstripe_offset_out_uv,\n\t\t\t\t\t\tIMGU_OSYS_FIR_PHASES,\n\t\t\t\t\t\tscaler_chroma->phase_init,\n\t\t\t\t\t\tscaler_chroma->phase_step,\n\t\t\t\t\t\tscaler_chroma->pad_left);\n\n\t\t\t\t \n\t\t\t\tchunk_floor_y = rounddown(stripe_offset_inp_y,\n\t\t\t\t\t\t\t  reso.chunk_width);\n\t\t\t\tchunk_floor_uv =\n\t\t\t\t\trounddown(stripe_offset_inp_uv,\n\t\t\t\t\t\t  reso.chunk_width /\n\t\t\t\t\t\t  IMGU_LUMA_TO_CHROMA_RATIO);\n\n\t\t\t\tif (chunk_floor_y != chunk_floor_uv *\n\t\t\t\t    IMGU_LUMA_TO_CHROMA_RATIO) {\n\t\t\t\t\t \n\t\t\t\t\tstripe_offset_inp_uv -= 1;\n\t\t\t\t\tstripe_crop_left_uv += 1;\n\t\t\t\t\tstripe_phase_init_uv -=\n\t\t\t\t\t\tscaler_luma->phase_step;\n\t\t\t\t\tif (stripe_phase_init_uv < 0)\n\t\t\t\t\t\tstripe_phase_init_uv =\n\t\t\t\t\t\t\tstripe_phase_init_uv +\n\t\t\t\t\t\t\tIMGU_OSYS_FIR_PHASES;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tchunk_ceil_uv =\n\t\t\t\t\troundup(stripe_offset_inp_uv,\n\t\t\t\t\t\treso.chunk_width /\n\t\t\t\t\t\tIMGU_LUMA_TO_CHROMA_RATIO);\n\n\t\t\t\tif (stripe_offset_inp_uv ==\n\t\t\t\t    chunk_ceil_uv - IMGU_OSYS_TAPS_UV) {\n\t\t\t\t\t \n\t\t\t\t\tstripe_offset_inp_uv -= 1;\n\t\t\t\t\tstripe_phase_init_uv -=\n\t\t\t\t\t\tscaler_luma->phase_step;\n\t\t\t\t\tif (stripe_phase_init_uv < 0) {\n\t\t\t\t\t\tstripe_phase_init_uv +=\n\t\t\t\t\t\t\tIMGU_OSYS_FIR_PHASES;\n\t\t\t\t\t\tstripe_crop_left_uv += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tstripe_offset_blk_y =\n\t\t\t\t\trounddown(stripe_offset_inp_y,\n\t\t\t\t\t\t  IMGU_INPUT_BLOCK_WIDTH);\n\t\t\t\tstripe_offset_blk_uv =\n\t\t\t\t\trounddown(stripe_offset_inp_uv,\n\t\t\t\t\t\t  IMGU_INPUT_BLOCK_WIDTH /\n\t\t\t\t\t\t  IMGU_LUMA_TO_CHROMA_RATIO);\n\t\t\t\tstripe_offset_col_y = stripe_offset_inp_y -\n\t\t\t\t\t\t\tstripe_offset_blk_y;\n\t\t\t\tstripe_offset_col_uv = stripe_offset_inp_uv -\n\t\t\t\t\t\t\tstripe_offset_blk_uv;\n\n\t\t\t\t \n\t\t\t\tstripe_pad_left_y = 0;\n\t\t\t\tstripe_pad_left_uv = 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (s < stripes - 1) {\n\t\t\t\tint next_offset;\n\n\t\t\t\tstripe_pad_right_y = 0;\n\t\t\t\tstripe_pad_right_uv = 0;\n\n\t\t\t\tnext_offset = output_width * (s + 1) / stripes;\n\t\t\t\tnext_offset = rounddown(next_offset, 64);\n\t\t\t\tstripe_output_width_y = next_offset -\n\t\t\t\t\t\t\tstripe_offset_out_y;\n\t\t\t} else {\n\t\t\t\tstripe_output_width_y = output_width -\n\t\t\t\t\t\t\tstripe_offset_out_y;\n\t\t\t}\n\n\t\t\t \n\t\t\tstripe_output_width_uv = stripe_output_width_y /\n\t\t\t\t\t\tIMGU_LUMA_TO_CHROMA_RATIO;\n\t\t\t \n\t\t\tstripe_input_width_y = stripe_offset_col_y +\n\t\t\t\timgu_css_osys_calc_inp_stripe_width(\n\t\t\t\t\t\tstripe_output_width_y,\n\t\t\t\t\t\tIMGU_OSYS_FIR_PHASES,\n\t\t\t\t\t\tstripe_phase_init_y,\n\t\t\t\t\t\tscaler_luma->phase_step,\n\t\t\t\t\t\tIMGU_OSYS_TAPS_Y,\n\t\t\t\t\t\tstripe_pad_left_y,\n\t\t\t\t\t\tstripe_pad_right_y);\n\n\t\t\tstripe_input_width_uv = stripe_offset_col_uv +\n\t\t\t\timgu_css_osys_calc_inp_stripe_width(\n\t\t\t\t\t\tstripe_output_width_uv,\n\t\t\t\t\t\tIMGU_OSYS_FIR_PHASES,\n\t\t\t\t\t\tstripe_phase_init_uv,\n\t\t\t\t\t\tscaler_chroma->phase_step,\n\t\t\t\t\t\tIMGU_OSYS_TAPS_UV,\n\t\t\t\t\t\tstripe_pad_left_uv,\n\t\t\t\t\t\tstripe_pad_right_uv);\n\n\t\t\tstripe_input_width_uv = max(DIV_ROUND_UP(\n\t\t\t\t\t\t    stripe_input_width_y,\n\t\t\t\t\t\t    IMGU_LUMA_TO_CHROMA_RATIO),\n\t\t\t\t\t\t    stripe_input_width_uv);\n\n\t\t\tstripe_input_width_y = stripe_input_width_uv *\n\t\t\t\t\t\tIMGU_LUMA_TO_CHROMA_RATIO;\n\n\t\t\tif (s >= stripes - 1) {\n\t\t\t\tstripe_input_width_y = reso.input_width -\n\t\t\t\t\tstripe_offset_blk_y;\n\t\t\t\t \n\t\t\t}\n\n\t\t\t \n\t\t\tstripe_input_width_y = ALIGN(stripe_input_width_y, 8);\n\t\t\tstripe_output_width_y =\n\t\t\t\timgu_css_osys_out_stripe_width(\n\t\t\t\t\t\tstripe_input_width_y,\n\t\t\t\t\t\tIMGU_OSYS_FIR_PHASES,\n\t\t\t\t\t\tstripe_phase_init_y,\n\t\t\t\t\t\tscaler_luma->phase_step,\n\t\t\t\t\t\tIMGU_OSYS_TAPS_Y,\n\t\t\t\t\t\tstripe_pad_left_y,\n\t\t\t\t\t\tstripe_pad_right_y,\n\t\t\t\t\t\tstripe_offset_col_y);\n\n\t\t\tstripe_output_width_y =\n\t\t\t\t\trounddown(stripe_output_width_y,\n\t\t\t\t\t\t  IMGU_LUMA_TO_CHROMA_RATIO);\n\t\t}\n\t\t \n\t\t{\n\t\t\tunsigned int i;\n\t\t\t \n\n\t\t\tstripe_params[s].input_width = stripe_input_width_y;\n\t\t\tstripe_params[s].input_height = reso.input_height;\n\n\t\t\tfor (i = 0; i < IMGU_ABI_OSYS_PINS; i++) {\n\t\t\t\tif (frame_params[i].scaled) {\n\t\t\t\t\t \n\t\t\t\t\tstripe_params[s].output_width[i] =\n\t\t\t\t\t\tstripe_output_width_y;\n\t\t\t\t\tstripe_params[s].output_height[i] =\n\t\t\t\t\t\treso.pin_height[i];\n\t\t\t\t\tstripe_params[s].output_offset[i] =\n\t\t\t\t\t\tstripe_offset_out_y;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tstripe_params[s].output_width[i] =\n\t\t\t\t\t\tstripe_params[s].input_width;\n\t\t\t\t\tstripe_params[s].output_height[i] =\n\t\t\t\t\t\tstripe_params[s].input_height;\n\t\t\t\t\tstripe_params[s].output_offset[i] =\n\t\t\t\t\t\tstripe_offset_blk_y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tstripe_params[s].processing_mode = procmode;\n\t\t\tstripe_params[s].phase_step = scaler_luma->phase_step;\n\t\t\tstripe_params[s].exp_shift = scaler_luma->exp_shift;\n\t\t\tstripe_params[s].phase_init_left_y =\n\t\t\t\tstripe_phase_init_y;\n\t\t\tstripe_params[s].phase_init_left_uv =\n\t\t\t\tstripe_phase_init_uv;\n\t\t\tstripe_params[s].phase_init_top_y =\n\t\t\t\tscaler_luma->phase_init;\n\t\t\tstripe_params[s].phase_init_top_uv =\n\t\t\t\tscaler_chroma->phase_init;\n\t\t\tstripe_params[s].pad_left_y = stripe_pad_left_y;\n\t\t\tstripe_params[s].pad_left_uv = stripe_pad_left_uv;\n\t\t\tstripe_params[s].pad_right_y = stripe_pad_right_y;\n\t\t\tstripe_params[s].pad_right_uv = stripe_pad_right_uv;\n\t\t\tstripe_params[s].pad_top_y = scaler_luma->pad_left;\n\t\t\tstripe_params[s].pad_top_uv = scaler_chroma->pad_left;\n\t\t\tstripe_params[s].pad_bottom_y = scaler_luma->pad_right;\n\t\t\tstripe_params[s].pad_bottom_uv =\n\t\t\t\tscaler_chroma->pad_right;\n\t\t\tstripe_params[s].crop_left_y = stripe_crop_left_y;\n\t\t\tstripe_params[s].crop_top_y = scaler_luma->crop_top;\n\t\t\tstripe_params[s].crop_left_uv = stripe_crop_left_uv;\n\t\t\tstripe_params[s].crop_top_uv = scaler_chroma->crop_top;\n\t\t\tstripe_params[s].start_column_y = stripe_offset_col_y;\n\t\t\tstripe_params[s].start_column_uv = stripe_offset_col_uv;\n\t\t\tstripe_params[s].chunk_width = reso.chunk_width;\n\t\t\tstripe_params[s].chunk_height = reso.chunk_height;\n\t\t\tstripe_params[s].block_width = reso.block_width;\n\t\t\tstripe_params[s].block_height = reso.block_height;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int imgu_css_osys_calc(struct imgu_css *css, unsigned int pipe,\n\t\t\t      unsigned int stripes,\n\t\t\t      struct imgu_abi_osys_config *osys,\n\t\t\t      struct imgu_css_scaler_info *scaler_luma,\n\t\t\t      struct imgu_css_scaler_info *scaler_chroma,\n\t\t\t      struct imgu_abi_stripes block_stripes[])\n{\n\tstruct imgu_css_frame_params frame_params[IMGU_ABI_OSYS_PINS];\n\tstruct imgu_css_stripe_params stripe_params[IPU3_UAPI_MAX_STRIPES];\n\tstruct imgu_abi_osys_formatter_params *param;\n\tunsigned int pin, s;\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\n\tmemset(osys, 0, sizeof(*osys));\n\n\t \n\tif (imgu_css_osys_calc_frame_and_stripe_params(css, stripes, osys,\n\t\t\t\t\t\t       scaler_luma,\n\t\t\t\t\t\t       scaler_chroma,\n\t\t\t\t\t\t       frame_params,\n\t\t\t\t\t\t       stripe_params, pipe))\n\t\treturn -EINVAL;\n\n\t \n\n\tfor (s = 0; s < stripes; s++) {\n\t\tstruct imgu_abi_osys_scaler_params *scaler =\n\t\t\t\t\t&osys->scaler[s].param;\n\t\tint fifo_addr_fmt = IMGU_FIFO_ADDR_SCALER_TO_FMT;\n\t\tint fifo_addr_ack = IMGU_FIFO_ADDR_SCALER_TO_SP;\n\n\t\t \n\t\tscaler->inp_buf_y_st_addr = IMGU_VMEM1_INP_BUF_ADDR;\n\n\t\t \n\t\tscaler->inp_buf_y_line_stride = IMGU_VMEM1_Y_STRIDE;\n\t\t \n\t\tscaler->inp_buf_y_buffer_stride = IMGU_VMEM1_BUF_SIZE;\n\t\tscaler->inp_buf_u_st_addr = IMGU_VMEM1_INP_BUF_ADDR +\n\t\t\t\t\t\tIMGU_VMEM1_U_OFFSET;\n\t\tscaler->inp_buf_v_st_addr = IMGU_VMEM1_INP_BUF_ADDR +\n\t\t\t\t\t\tIMGU_VMEM1_V_OFFSET;\n\t\tscaler->inp_buf_uv_line_stride = IMGU_VMEM1_UV_STRIDE;\n\t\tscaler->inp_buf_uv_buffer_stride = IMGU_VMEM1_BUF_SIZE;\n\t\tscaler->inp_buf_chunk_width = stripe_params[s].chunk_width;\n\t\tscaler->inp_buf_nr_buffers = IMGU_OSYS_NUM_INPUT_BUFFERS;\n\n\t\t \n\t\tscaler->out_buf_y_st_addr = IMGU_VMEM1_INT_BUF_ADDR;\n\t\tscaler->out_buf_y_line_stride = stripe_params[s].block_width /\n\t\t\t\t\t\tIMGU_VMEM1_ELEMS_PER_VEC;\n\t\tscaler->out_buf_y_buffer_stride = IMGU_VMEM1_BUF_SIZE;\n\t\tscaler->out_buf_u_st_addr = IMGU_VMEM1_INT_BUF_ADDR +\n\t\t\t\t\t\tIMGU_VMEM1_U_OFFSET;\n\t\tscaler->out_buf_v_st_addr = IMGU_VMEM1_INT_BUF_ADDR +\n\t\t\t\t\t\tIMGU_VMEM1_V_OFFSET;\n\t\tscaler->out_buf_uv_line_stride = stripe_params[s].block_width /\n\t\t\t\t\t\tIMGU_VMEM1_ELEMS_PER_VEC / 2;\n\t\tscaler->out_buf_uv_buffer_stride = IMGU_VMEM1_BUF_SIZE;\n\t\tscaler->out_buf_nr_buffers = IMGU_OSYS_NUM_INTERM_BUFFERS;\n\n\t\t \n\t\tscaler->int_buf_y_st_addr = IMGU_VMEM2_BUF_Y_ADDR;\n\t\tscaler->int_buf_y_line_stride = IMGU_VMEM2_BUF_Y_STRIDE;\n\t\tscaler->int_buf_u_st_addr = IMGU_VMEM2_BUF_U_ADDR;\n\t\tscaler->int_buf_v_st_addr = IMGU_VMEM2_BUF_V_ADDR;\n\t\tscaler->int_buf_uv_line_stride = IMGU_VMEM2_BUF_UV_STRIDE;\n\t\tscaler->int_buf_height = IMGU_VMEM2_LINES_PER_BLOCK;\n\t\tscaler->int_buf_chunk_width = stripe_params[s].chunk_height;\n\t\tscaler->int_buf_chunk_height = stripe_params[s].block_width;\n\n\t\t \n\t\tscaler->ctx_buf_hor_y_st_addr = IMGU_VMEM3_HOR_Y_ADDR;\n\t\tscaler->ctx_buf_hor_u_st_addr = IMGU_VMEM3_HOR_U_ADDR;\n\t\tscaler->ctx_buf_hor_v_st_addr = IMGU_VMEM3_HOR_V_ADDR;\n\t\tscaler->ctx_buf_ver_y_st_addr = IMGU_VMEM3_VER_Y_ADDR;\n\t\tscaler->ctx_buf_ver_u_st_addr = IMGU_VMEM3_VER_U_ADDR;\n\t\tscaler->ctx_buf_ver_v_st_addr = IMGU_VMEM3_VER_V_ADDR;\n\n\t\t \n\t\tscaler->release_inp_buf_addr = fifo_addr_ack;\n\t\tscaler->release_inp_buf_en = 1;\n\t\tscaler->release_out_buf_en = 1;\n\t\tscaler->process_out_buf_addr = fifo_addr_fmt;\n\n\t\t \n\t\tscaler->input_image_y_width = stripe_params[s].input_width;\n\t\tscaler->input_image_y_height = stripe_params[s].input_height;\n\t\tscaler->input_image_y_start_column =\n\t\t\t\t\tstripe_params[s].start_column_y;\n\t\tscaler->input_image_uv_start_column =\n\t\t\t\t\tstripe_params[s].start_column_uv;\n\t\tscaler->input_image_y_left_pad = stripe_params[s].pad_left_y;\n\t\tscaler->input_image_uv_left_pad = stripe_params[s].pad_left_uv;\n\t\tscaler->input_image_y_right_pad = stripe_params[s].pad_right_y;\n\t\tscaler->input_image_uv_right_pad =\n\t\t\t\t\tstripe_params[s].pad_right_uv;\n\t\tscaler->input_image_y_top_pad = stripe_params[s].pad_top_y;\n\t\tscaler->input_image_uv_top_pad = stripe_params[s].pad_top_uv;\n\t\tscaler->input_image_y_bottom_pad =\n\t\t\t\t\tstripe_params[s].pad_bottom_y;\n\t\tscaler->input_image_uv_bottom_pad =\n\t\t\t\t\tstripe_params[s].pad_bottom_uv;\n\t\tscaler->processing_mode = stripe_params[s].processing_mode;\n\t\tscaler->scaling_ratio = stripe_params[s].phase_step;\n\t\tscaler->y_left_phase_init = stripe_params[s].phase_init_left_y;\n\t\tscaler->uv_left_phase_init =\n\t\t\t\t\tstripe_params[s].phase_init_left_uv;\n\t\tscaler->y_top_phase_init = stripe_params[s].phase_init_top_y;\n\t\tscaler->uv_top_phase_init = stripe_params[s].phase_init_top_uv;\n\t\tscaler->coeffs_exp_shift = stripe_params[s].exp_shift;\n\t\tscaler->out_y_left_crop = stripe_params[s].crop_left_y;\n\t\tscaler->out_uv_left_crop = stripe_params[s].crop_left_uv;\n\t\tscaler->out_y_top_crop = stripe_params[s].crop_top_y;\n\t\tscaler->out_uv_top_crop = stripe_params[s].crop_top_uv;\n\n\t\tfor (pin = 0; pin < IMGU_ABI_OSYS_PINS; pin++) {\n\t\t\tint in_fifo_addr;\n\t\t\tint out_fifo_addr;\n\t\t\tint block_width_vecs;\n\t\t\tint input_width_s;\n\t\t\tint input_width_vecs;\n\t\t\tint input_buf_y_st_addr;\n\t\t\tint input_buf_u_st_addr;\n\t\t\tint input_buf_v_st_addr;\n\t\t\tint input_buf_y_line_stride;\n\t\t\tint input_buf_uv_line_stride;\n\t\t\tint output_buf_y_line_stride;\n\t\t\tint output_buf_uv_line_stride;\n\t\t\tint output_buf_nr_y_lines;\n\t\t\tint block_height;\n\t\t\tint block_width;\n\t\t\tstruct imgu_abi_osys_frame_params *fr_pr;\n\n\t\t\tfr_pr = &osys->frame[pin].param;\n\n\t\t\t \n\t\t\tfr_pr->enable = frame_params[pin].enable;\n\t\t\tfr_pr->format = frame_params[pin].format;\n\t\t\tfr_pr->mirror = frame_params[pin].mirror;\n\t\t\tfr_pr->flip = frame_params[pin].flip;\n\t\t\tfr_pr->tiling = frame_params[pin].tiling;\n\t\t\tfr_pr->width = frame_params[pin].width;\n\t\t\tfr_pr->height = frame_params[pin].height;\n\t\t\tfr_pr->stride = frame_params[pin].stride;\n\t\t\tfr_pr->scaled = frame_params[pin].scaled;\n\n\t\t\t \n\t\t\tosys->stripe[s].crop_top[pin] =\n\t\t\t\tframe_params[pin].crop_top;\n\t\t\tosys->stripe[s].input_width =\n\t\t\t\tstripe_params[s].input_width;\n\t\t\tosys->stripe[s].input_height =\n\t\t\t\tstripe_params[s].input_height;\n\t\t\tosys->stripe[s].block_height =\n\t\t\t\tstripe_params[s].block_height;\n\t\t\tosys->stripe[s].block_width =\n\t\t\t\tstripe_params[s].block_width;\n\t\t\tosys->stripe[s].output_width[pin] =\n\t\t\t\tstripe_params[s].output_width[pin];\n\t\t\tosys->stripe[s].output_height[pin] =\n\t\t\t\tstripe_params[s].output_height[pin];\n\n\t\t\tif (s == 0) {\n\t\t\t\t \n\t\t\t\tosys->stripe[s].crop_left[pin] =\n\t\t\t\t\tframe_params[pin].crop_left;\n\t\t\t\tosys->stripe[s].output_offset[pin] =\n\t\t\t\t\tstripe_params[s].output_offset[pin];\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tosys->stripe[s].crop_left[pin] = 0;\n\t\t\t\tosys->stripe[s].output_offset[pin] =\n\t\t\t\t\t(stripe_params[s].output_offset[pin] -\n\t\t\t\t\t osys->stripe[0].crop_left[pin]);\n\t\t\t}\n\n\t\t\tif (!frame_params[pin].enable)\n\t\t\t\tcontinue;\n\n\t\t\t \n\n\t\t\t \n\t\t\tif (frame_params[pin].scaled) {\n\t\t\t\tblock_height = stripe_params[s].block_height;\n\t\t\t\tblock_width = stripe_params[s].block_width;\n\t\t\t} else {\n\t\t\t\tblock_height = IMGU_OSYS_BLOCK_HEIGHT;\n\t\t\t\tblock_width = IMGU_OSYS_BLOCK_WIDTH;\n\t\t\t}\n\t\t\tblock_width_vecs =\n\t\t\t\t\tblock_width / IMGU_VMEM1_ELEMS_PER_VEC;\n\t\t\t \n\t\t\tinput_buf_y_line_stride = block_width_vecs;\n\t\t\tinput_buf_uv_line_stride = block_width_vecs / 2;\n\t\t\toutput_buf_y_line_stride = block_width_vecs;\n\t\t\toutput_buf_uv_line_stride = block_width_vecs / 2;\n\t\t\toutput_buf_nr_y_lines = block_height;\n\t\t\tif (frame_params[pin].format ==\n\t\t\t    IMGU_ABI_OSYS_FORMAT_NV12 ||\n\t\t\t    frame_params[pin].format ==\n\t\t\t    IMGU_ABI_OSYS_FORMAT_NV21)\n\t\t\t\toutput_buf_uv_line_stride =\n\t\t\t\t\toutput_buf_y_line_stride;\n\n\t\t\t \n\t\t\tif (frame_params[pin].tiling) {\n\t\t\t\toutput_buf_nr_y_lines = 8;\n\t\t\t\toutput_buf_y_line_stride = 512 /\n\t\t\t\t\tIMGU_VMEM1_ELEMS_PER_VEC;\n\t\t\t\toutput_buf_uv_line_stride = 256 /\n\t\t\t\t\tIMGU_VMEM1_ELEMS_PER_VEC;\n\t\t\t}\n\n\t\t\t \n\t\t\tosys->stripe[s].buf_stride[pin] =\n\t\t\t\toutput_buf_y_line_stride *\n\t\t\t\tIMGU_HIVE_OF_SYS_OF_SYSTEM_NWAYS;\n\t\t\tif (frame_params[pin].scaled) {\n\t\t\t\t \n\t\t\t\tinput_buf_y_st_addr = IMGU_VMEM1_INT_BUF_ADDR;\n\t\t\t\tinput_buf_u_st_addr = IMGU_VMEM1_INT_BUF_ADDR +\n\t\t\t\t\t\t\tIMGU_VMEM1_U_OFFSET;\n\t\t\t\tinput_buf_v_st_addr = IMGU_VMEM1_INT_BUF_ADDR +\n\t\t\t\t\t\t\tIMGU_VMEM1_V_OFFSET;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tinput_buf_y_st_addr = IMGU_VMEM1_INP_BUF_ADDR;\n\t\t\t\tinput_buf_u_st_addr = IMGU_VMEM1_INP_BUF_ADDR +\n\t\t\t\t\t\t\tIMGU_VMEM1_U_OFFSET;\n\t\t\t\tinput_buf_v_st_addr = IMGU_VMEM1_INP_BUF_ADDR +\n\t\t\t\t\t\t\tIMGU_VMEM1_V_OFFSET;\n\t\t\t}\n\n\t\t\t \n\t\t\tinput_width_s =\n\t\t\t\troundup(stripe_params[s].output_width[pin],\n\t\t\t\t\tblock_width);\n\t\t\tinput_width_vecs = input_width_s /\n\t\t\t\t\tIMGU_VMEM1_ELEMS_PER_VEC;\n\t\t\tout_fifo_addr = IMGU_FIFO_ADDR_FMT_TO_SP;\n\t\t\t \n\t\t\tif (frame_params[pin].scaled)\n\t\t\t\tin_fifo_addr = IMGU_FIFO_ADDR_FMT_TO_SCALER;\n\t\t\telse\n\t\t\t\tin_fifo_addr = IMGU_FIFO_ADDR_FMT_TO_SP;\n\n\t\t\t \n\t\t\tparam = &osys->formatter[s][pin].param;\n\n\t\t\tparam->format = frame_params[pin].format;\n\t\t\tparam->flip = frame_params[pin].flip;\n\t\t\tparam->mirror = frame_params[pin].mirror;\n\t\t\tparam->tiling = frame_params[pin].tiling;\n\t\t\tparam->reduce_range = frame_params[pin].reduce_range;\n\t\t\tparam->alpha_blending = 0;\n\t\t\tparam->release_inp_addr = in_fifo_addr;\n\t\t\tparam->release_inp_en = 1;\n\t\t\tparam->process_out_buf_addr = out_fifo_addr;\n\t\t\tparam->image_width_vecs = input_width_vecs;\n\t\t\tparam->image_height_lines =\n\t\t\t\tstripe_params[s].output_height[pin];\n\t\t\tparam->inp_buff_y_st_addr = input_buf_y_st_addr;\n\t\t\tparam->inp_buff_y_line_stride = input_buf_y_line_stride;\n\t\t\tparam->inp_buff_y_buffer_stride = IMGU_VMEM1_BUF_SIZE;\n\t\t\tparam->int_buff_u_st_addr = input_buf_u_st_addr;\n\t\t\tparam->int_buff_v_st_addr = input_buf_v_st_addr;\n\t\t\tparam->inp_buff_uv_line_stride =\n\t\t\t\tinput_buf_uv_line_stride;\n\t\t\tparam->inp_buff_uv_buffer_stride = IMGU_VMEM1_BUF_SIZE;\n\t\t\tparam->out_buff_level = 0;\n\t\t\tparam->out_buff_nr_y_lines = output_buf_nr_y_lines;\n\t\t\tparam->out_buff_u_st_offset = IMGU_VMEM1_U_OFFSET;\n\t\t\tparam->out_buff_v_st_offset = IMGU_VMEM1_V_OFFSET;\n\t\t\tparam->out_buff_y_line_stride =\n\t\t\t\toutput_buf_y_line_stride;\n\t\t\tparam->out_buff_uv_line_stride =\n\t\t\t\toutput_buf_uv_line_stride;\n\t\t\tparam->hist_buff_st_addr = IMGU_VMEM1_HST_BUF_ADDR;\n\t\t\tparam->hist_buff_line_stride =\n\t\t\t\tIMGU_VMEM1_HST_BUF_STRIDE;\n\t\t\tparam->hist_buff_nr_lines = IMGU_VMEM1_HST_BUF_NLINES;\n\t\t}\n\t}\n\n\tblock_stripes[0].offset = 0;\n\tif (stripes <= 1) {\n\t\tblock_stripes[0].width = stripe_params[0].input_width;\n\t\tblock_stripes[0].height = stripe_params[0].input_height;\n\t} else {\n\t\tstruct imgu_fw_info *bi =\n\t\t\t&css->fwp->binary_header[css_pipe->bindex];\n\t\tunsigned int sp_block_width =\n\t\t\t\tbi->info.isp.sp.block.block_width *\n\t\t\t\tIPU3_UAPI_ISP_VEC_ELEMS;\n\n\t\tblock_stripes[0].width = roundup(stripe_params[0].input_width,\n\t\t\t\t\t\t sp_block_width);\n\t\tblock_stripes[1].offset =\n\t\t\trounddown(css_pipe->rect[IPU3_CSS_RECT_GDC].width -\n\t\t\t\t  stripe_params[1].input_width, sp_block_width);\n\t\tblock_stripes[1].width =\n\t\t\troundup(css_pipe->rect[IPU3_CSS_RECT_GDC].width -\n\t\t\t\tblock_stripes[1].offset, sp_block_width);\n\t\tblock_stripes[0].height = css_pipe->rect[IPU3_CSS_RECT_GDC].height;\n\t\tblock_stripes[1].height = block_stripes[0].height;\n\t}\n\n\treturn 0;\n}\n\n \n\n \n\nstatic int\nimgu_css_shd_ops_calc(struct imgu_abi_shd_intra_frame_operations_data *ops,\n\t\t      const struct ipu3_uapi_shd_grid_config *grid,\n\t\t      unsigned int image_height)\n{\n\tunsigned int block_height = 1 << grid->block_height_log2;\n\tunsigned int grid_height_per_slice = grid->grid_height_per_slice;\n\tunsigned int set_height = grid_height_per_slice * block_height;\n\n\t \n\tunsigned int positive_y_start = (unsigned int)-grid->y_start;\n\tunsigned int first_process_lines =\n\t\t\t\tset_height - (positive_y_start % set_height);\n\tunsigned int last_set_height;\n\tunsigned int num_of_sets;\n\n\tstruct imgu_abi_acc_operation *p_op;\n\tstruct imgu_abi_acc_process_lines_cmd_data *p_pl;\n\tstruct imgu_abi_shd_transfer_luts_set_data *p_tr;\n\n\tunsigned int op_idx, pl_idx, tr_idx;\n\tunsigned char tr_set_num, pl_cfg_set;\n\n\t \n\tunsigned char last_tr = 0;\n\n\t \n\tbool add_pl;\n\t \n\tbool add_tr;\n\n\t \n\tif (image_height > first_process_lines) {\n\t\tlast_set_height =\n\t\t\t(image_height - first_process_lines) % set_height;\n\t\tnum_of_sets = last_set_height > 0 ?\n\t\t\t(image_height - first_process_lines) / set_height + 2 :\n\t\t\t(image_height - first_process_lines) / set_height + 1;\n\t\tlast_tr = (set_height - last_set_height <= block_height ||\n\t\t\t   last_set_height == 0) ? 1 : 0;\n\t} else {  \n\t\tlast_set_height = 0;\n\t\tnum_of_sets = 1;\n\t\tfirst_process_lines = image_height;\n\t\tlast_tr = set_height - image_height <= block_height ? 1 : 0;\n\t}\n\n\t \n\tp_op = ops->operation_list;\n\top_idx = 0;\n\tp_pl = ops->process_lines_data;\n\tpl_idx = 0;\n\tp_tr = ops->transfer_data;\n\ttr_idx = 0;\n\n\tmemset(ops, 0, sizeof(*ops));\n\n\t \n\ttr_set_num = 0;\n\tpl_cfg_set = 0;\n\n\t \n\tadd_pl = false;\n\tadd_tr = true;\n\n\twhile (add_pl || add_tr) {\n\t\t \n\t\tif (add_tr) {\n\t\t\tif (op_idx >= IMGU_ABI_SHD_MAX_OPERATIONS ||\n\t\t\t    tr_idx >= IMGU_ABI_SHD_MAX_TRANSFERS)\n\t\t\t\treturn -EINVAL;\n\t\t\tp_op[op_idx].op_type =\n\t\t\t\tIMGU_ABI_ACC_OPTYPE_TRANSFER_DATA;\n\t\t\tp_op[op_idx].op_indicator = IMGU_ABI_ACC_OP_IDLE;\n\t\t\top_idx++;\n\t\t\tp_tr[tr_idx].set_number = tr_set_num;\n\t\t\ttr_idx++;\n\t\t\ttr_set_num = (tr_set_num + 1) % IMGU_SHD_SETS;\n\t\t}\n\n\t\t \n\t\tif (add_pl) {\n\t\t\tif (op_idx >= IMGU_ABI_SHD_MAX_OPERATIONS ||\n\t\t\t    pl_idx >= IMGU_ABI_SHD_MAX_PROCESS_LINES)\n\t\t\t\treturn -EINVAL;\n\t\t\tp_op[op_idx].op_type =\n\t\t\t\tIMGU_ABI_ACC_OPTYPE_PROCESS_LINES;\n\n\t\t\t \n\t\t\tif (pl_idx == 0 && num_of_sets != 1)\n\t\t\t\tp_op[op_idx].op_indicator =\n\t\t\t\t\tIMGU_ABI_ACC_OP_IDLE;\n\t\t\t \n\t\t\telse if (pl_idx == num_of_sets - 1)\n\t\t\t\tp_op[op_idx].op_indicator =\n\t\t\t\t\tIMGU_ABI_ACC_OP_END_OF_OPS;\n\t\t\t \n\t\t\telse\n\t\t\t\tp_op[op_idx].op_indicator =\n\t\t\t\t\tIMGU_ABI_ACC_OP_END_OF_ACK;\n\n\t\t\top_idx++;\n\n\t\t\t \n\t\t\tif (pl_idx == 0)\n\t\t\t\tp_pl[pl_idx].lines = first_process_lines;\n\t\t\t \n\t\t\telse if (pl_idx == num_of_sets - 1 &&\n\t\t\t\t last_set_height > 0)\n\t\t\t\tp_pl[pl_idx].lines = last_set_height;\n\t\t\telse\t \n\t\t\t\tp_pl[pl_idx].lines = set_height;\n\n\t\t\tp_pl[pl_idx].cfg_set = pl_cfg_set;\n\t\t\tpl_idx++;\n\t\t\tpl_cfg_set = (pl_cfg_set + 1) % IMGU_SHD_SETS;\n\t\t}\n\n\t\t \n\t\tif (tr_idx == IMGU_SHD_SETS ||\n\t\t    tr_idx == num_of_sets + last_tr) {\n\t\t\tadd_tr = false;\n\t\t\tadd_pl = true;\n\t\t}\n\n\t\t \n\t\tif (pl_idx == 2) {\n\t\t\tadd_tr = true;\n\t\t\tadd_pl = true;\n\t\t}\n\n\t\t \n\t\tif (tr_idx == num_of_sets + last_tr)\n\t\t\tadd_tr = false;\n\t\tif (pl_idx == num_of_sets)\n\t\t\tadd_pl = false;\n\t}\n\n\treturn 0;\n}\n\n \nstruct process_lines {\n\tunsigned int image_height;\n\tunsigned short grid_height;\n\tunsigned short block_height;\n\tunsigned short y_start;\n\tunsigned char grid_height_per_slice;\n\n\tunsigned short max_op;  \n\tunsigned short max_tr;  \n\tunsigned char acc_enable;\n};\n\n \nstatic int\nimgu_css_acc_process_lines(const struct process_lines *pl,\n\t\t\t   struct imgu_abi_acc_operation *p_op,\n\t\t\t   struct imgu_abi_acc_process_lines_cmd_data *p_pl,\n\t\t\t   struct imgu_abi_acc_transfer_op_data *p_tr)\n{\n\tunsigned short op_idx = 0, pl_idx = 0, tr_idx = 0;\n\tunsigned char tr_set_num = 0, pl_cfg_set = 0;\n\tconst unsigned short grid_last_line =\n\t\t\tpl->y_start + pl->grid_height * pl->block_height;\n\tconst unsigned short process_lines =\n\t\t\tpl->grid_height_per_slice * pl->block_height;\n\n\tunsigned int process_lines_after_grid;\n\tunsigned short first_process_lines;\n\tunsigned short last_process_lines_in_grid;\n\n\tunsigned short num_of_process_lines;\n\tunsigned short num_of_sets;\n\n\tif (pl->grid_height_per_slice == 0)\n\t\treturn -EINVAL;\n\n\tif (pl->acc_enable && grid_last_line > pl->image_height)\n\t\treturn -EINVAL;\n\n\tnum_of_sets = pl->grid_height / pl->grid_height_per_slice;\n\tif (num_of_sets * pl->grid_height_per_slice < pl->grid_height)\n\t\tnum_of_sets++;\n\n\t \n\tif (pl->max_op == IMGU_ABI_AF_MAX_OPERATIONS) {\n\t\tfirst_process_lines = process_lines + pl->y_start + 2;\n\t\tlast_process_lines_in_grid =\n\t\t\t(grid_last_line - first_process_lines) -\n\t\t\t((num_of_sets - 2) * process_lines) + 4;\n\t\tprocess_lines_after_grid =\n\t\t\tpl->image_height - grid_last_line - 4;\n\t} else {\n\t\tfirst_process_lines = process_lines + pl->y_start;\n\t\tlast_process_lines_in_grid =\n\t\t\t(grid_last_line - first_process_lines) -\n\t\t\t((num_of_sets - 2) * process_lines);\n\t\tprocess_lines_after_grid = pl->image_height - grid_last_line;\n\t}\n\n\tnum_of_process_lines = num_of_sets;\n\tif (process_lines_after_grid > 0)\n\t\tnum_of_process_lines++;\n\n\twhile (tr_idx < num_of_sets || pl_idx < num_of_process_lines) {\n\t\t \n\t\tif (pl_idx >= 2 || (pl_idx == 1 && num_of_sets == 1)) {\n\t\t\tif (op_idx >= pl->max_op || tr_idx >= pl->max_tr)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tp_op[op_idx].op_type =\n\t\t\t\tIMGU_ABI_ACC_OPTYPE_TRANSFER_DATA;\n\n\t\t\tif (tr_idx == num_of_sets - 1)\n\t\t\t\t \n\t\t\t\tp_op[op_idx].op_indicator =\n\t\t\t\t\tIMGU_ABI_ACC_OP_END_OF_OPS;\n\t\t\telse if (tr_idx == num_of_sets - 2)\n\t\t\t\tif (process_lines_after_grid == 0)\n\t\t\t\t\t \n\t\t\t\t\tp_op[op_idx].op_indicator =\n\t\t\t\t\t\tIMGU_ABI_ACC_OP_END_OF_ACK;\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tp_op[op_idx].op_indicator =\n\t\t\t\t\t\tIMGU_ABI_ACC_OP_IDLE;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tp_op[op_idx].op_indicator =\n\t\t\t\t\tIMGU_ABI_ACC_OP_IDLE;\n\n\t\t\top_idx++;\n\t\t\tif (p_tr) {\n\t\t\t\tp_tr[tr_idx].set_number = tr_set_num;\n\t\t\t\ttr_set_num = 1 - tr_set_num;\n\t\t\t}\n\t\t\ttr_idx++;\n\t\t}\n\n\t\t \n\t\tif (pl_idx < num_of_process_lines) {\n\t\t\tif (op_idx >= pl->max_op || pl_idx >= pl->max_tr)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tp_op[op_idx].op_type =\n\t\t\t\tIMGU_ABI_ACC_OPTYPE_PROCESS_LINES;\n\t\t\tif (pl_idx == 0)\n\t\t\t\tif (num_of_process_lines == 1)\n\t\t\t\t\t \n\t\t\t\t\tp_op[op_idx].op_indicator =\n\t\t\t\t\t\tIMGU_ABI_ACC_OP_END_OF_ACK;\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tp_op[op_idx].op_indicator =\n\t\t\t\t\t\tIMGU_ABI_ACC_OP_IDLE;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tp_op[op_idx].op_indicator =\n\t\t\t\t\tIMGU_ABI_ACC_OP_END_OF_ACK;\n\n\t\t\top_idx++;\n\n\t\t\tif (pl_idx == 0)\n\t\t\t\t \n\t\t\t\tp_pl[pl_idx].lines = first_process_lines;\n\t\t\telse if (pl_idx == num_of_sets - 1)\n\t\t\t\t \n\t\t\t\tp_pl[pl_idx].lines = last_process_lines_in_grid;\n\t\t\telse if (pl_idx == num_of_process_lines - 1)\n\t\t\t\t \n\t\t\t\tp_pl[pl_idx].lines = process_lines_after_grid;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tp_pl[pl_idx].lines = process_lines;\n\n\t\t\tif (p_tr) {\n\t\t\t\tp_pl[pl_idx].cfg_set = pl_cfg_set;\n\t\t\t\tpl_cfg_set = 1 - pl_cfg_set;\n\t\t\t}\n\t\t\tpl_idx++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int imgu_css_af_ops_calc(struct imgu_css *css, unsigned int pipe,\n\t\t\t\tstruct imgu_abi_af_config *af_config)\n{\n\tstruct imgu_abi_af_intra_frame_operations_data *to =\n\t\t&af_config->operations_data;\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\tstruct imgu_fw_info *bi =\n\t\t&css->fwp->binary_header[css_pipe->bindex];\n\n\tstruct process_lines pl = {\n\t\t.image_height = css_pipe->rect[IPU3_CSS_RECT_BDS].height,\n\t\t.grid_height = af_config->config.grid_cfg.height,\n\t\t.block_height =\n\t\t\t1 << af_config->config.grid_cfg.block_height_log2,\n\t\t.y_start = af_config->config.grid_cfg.y_start &\n\t\t\tIPU3_UAPI_GRID_START_MASK,\n\t\t.grid_height_per_slice =\n\t\t\taf_config->stripes[0].grid_cfg.height_per_slice,\n\t\t.max_op = IMGU_ABI_AF_MAX_OPERATIONS,\n\t\t.max_tr = IMGU_ABI_AF_MAX_TRANSFERS,\n\t\t.acc_enable = bi->info.isp.sp.enable.af,\n\t};\n\n\treturn imgu_css_acc_process_lines(&pl, to->ops, to->process_lines_data,\n\t\t\t\t\t  NULL);\n}\n\nstatic int\nimgu_css_awb_fr_ops_calc(struct imgu_css *css, unsigned int pipe,\n\t\t\t struct imgu_abi_awb_fr_config *awb_fr_config)\n{\n\tstruct imgu_abi_awb_fr_intra_frame_operations_data *to =\n\t\t&awb_fr_config->operations_data;\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\tstruct imgu_fw_info *bi =\n\t\t&css->fwp->binary_header[css_pipe->bindex];\n\tstruct process_lines pl = {\n\t\t.image_height = css_pipe->rect[IPU3_CSS_RECT_BDS].height,\n\t\t.grid_height = awb_fr_config->config.grid_cfg.height,\n\t\t.block_height =\n\t\t\t1 << awb_fr_config->config.grid_cfg.block_height_log2,\n\t\t.y_start = awb_fr_config->config.grid_cfg.y_start &\n\t\t\tIPU3_UAPI_GRID_START_MASK,\n\t\t.grid_height_per_slice =\n\t\t\tawb_fr_config->stripes[0].grid_cfg.height_per_slice,\n\t\t.max_op = IMGU_ABI_AWB_FR_MAX_OPERATIONS,\n\t\t.max_tr = IMGU_ABI_AWB_FR_MAX_PROCESS_LINES,\n\t\t.acc_enable = bi->info.isp.sp.enable.awb_fr_acc,\n\t};\n\n\treturn imgu_css_acc_process_lines(&pl, to->ops, to->process_lines_data,\n\t\t\t\t\t  NULL);\n}\n\nstatic int imgu_css_awb_ops_calc(struct imgu_css *css, unsigned int pipe,\n\t\t\t\t struct imgu_abi_awb_config *awb_config)\n{\n\tstruct imgu_abi_awb_intra_frame_operations_data *to =\n\t\t&awb_config->operations_data;\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\tstruct imgu_fw_info *bi =\n\t\t&css->fwp->binary_header[css_pipe->bindex];\n\n\tstruct process_lines pl = {\n\t\t.image_height = css_pipe->rect[IPU3_CSS_RECT_BDS].height,\n\t\t.grid_height = awb_config->config.grid.height,\n\t\t.block_height =\n\t\t\t1 << awb_config->config.grid.block_height_log2,\n\t\t.y_start = awb_config->config.grid.y_start,\n\t\t.grid_height_per_slice =\n\t\t\tawb_config->stripes[0].grid.height_per_slice,\n\t\t.max_op = IMGU_ABI_AWB_MAX_OPERATIONS,\n\t\t.max_tr = IMGU_ABI_AWB_MAX_TRANSFERS,\n\t\t.acc_enable = bi->info.isp.sp.enable.awb_acc,\n\t};\n\n\treturn imgu_css_acc_process_lines(&pl, to->ops, to->process_lines_data,\n\t\t\t\t\t  to->transfer_data);\n}\n\nstatic u16 imgu_css_grid_end(u16 start, u8 width, u8 block_width_log2)\n{\n\treturn (start & IPU3_UAPI_GRID_START_MASK) +\n\t\t(width << block_width_log2) - 1;\n}\n\nstatic void imgu_css_grid_end_calc(struct ipu3_uapi_grid_config *grid_cfg)\n{\n\tgrid_cfg->x_end = imgu_css_grid_end(grid_cfg->x_start, grid_cfg->width,\n\t\t\t\t\t    grid_cfg->block_width_log2);\n\tgrid_cfg->y_end = imgu_css_grid_end(grid_cfg->y_start, grid_cfg->height,\n\t\t\t\t\t    grid_cfg->block_height_log2);\n}\n\n \n\nstatic int imgu_css_cfg_acc_stripe(struct imgu_css *css, unsigned int pipe,\n\t\t\t\t   struct imgu_abi_acc_param *acc)\n{\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\tconst struct imgu_fw_info *bi =\n\t\t&css->fwp->binary_header[css_pipe->bindex];\n\tstruct imgu_css_scaler_info scaler_luma, scaler_chroma;\n\tconst unsigned int stripes = bi->info.isp.sp.iterator.num_stripes;\n\tconst unsigned int f = IPU3_UAPI_ISP_VEC_ELEMS * 2;\n\tunsigned int bds_ds, i;\n\n\tmemset(acc, 0, sizeof(*acc));\n\n\t \n\n\tif (imgu_css_osys_calc(css, pipe, stripes, &acc->osys, &scaler_luma,\n\t\t\t       &scaler_chroma, acc->stripe.block_stripes))\n\t\treturn -EINVAL;\n\n\t \n\n\t \n\n\tacc->stripe.num_of_stripes = stripes;\n\tacc->stripe.input_frame.width =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_IN].fmt.mpix.width;\n\tacc->stripe.input_frame.height =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_IN].fmt.mpix.height;\n\tacc->stripe.input_frame.bayer_order =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_IN].css_fmt->bayer_order;\n\n\tfor (i = 0; i < stripes; i++)\n\t\tacc->stripe.bds_out_stripes[i].height =\n\t\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].height;\n\tacc->stripe.bds_out_stripes[0].offset = 0;\n\tif (stripes <= 1) {\n\t\tacc->stripe.bds_out_stripes[0].width =\n\t\t\tALIGN(css_pipe->rect[IPU3_CSS_RECT_BDS].width, f);\n\t} else {\n\t\t \n\t\tacc->stripe.bds_out_stripes[0].width =\n\t\t\tacc->stripe.bds_out_stripes[1].width =\n\t\t\t(css_pipe->rect[IPU3_CSS_RECT_BDS].width / 2 & ~(f - 1)) + f;\n\t\t \n\t\tif ((css_pipe->rect[IPU3_CSS_RECT_BDS].width / f & 1) !=\n\t\t    !!(css_pipe->rect[IPU3_CSS_RECT_BDS].width & (f - 1)))\n\t\t\tacc->stripe.bds_out_stripes[0].width += f;\n\t\tif ((css_pipe->rect[IPU3_CSS_RECT_BDS].width / f & 1) &&\n\t\t    (css_pipe->rect[IPU3_CSS_RECT_BDS].width & (f - 1))) {\n\t\t\tacc->stripe.bds_out_stripes[0].width += f;\n\t\t\tacc->stripe.bds_out_stripes[1].width += f;\n\t\t}\n\t\t \n\t\tacc->stripe.bds_out_stripes[1].offset =\n\t\t\tacc->stripe.bds_out_stripes[0].width - 2 * f;\n\t}\n\n\tacc->stripe.effective_stripes[0].height =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_EFFECTIVE].height;\n\tacc->stripe.effective_stripes[0].offset = 0;\n\tacc->stripe.bds_out_stripes_no_overlap[0].height =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].height;\n\tacc->stripe.bds_out_stripes_no_overlap[0].offset = 0;\n\tacc->stripe.output_stripes[0].height =\n\t\t\t\tcss_pipe->queue[IPU3_CSS_QUEUE_OUT].fmt.mpix.height;\n\tacc->stripe.output_stripes[0].offset = 0;\n\tif (stripes <= 1) {\n\t\tacc->stripe.down_scaled_stripes[0].width =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].width;\n\t\tacc->stripe.down_scaled_stripes[0].height =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].height;\n\t\tacc->stripe.down_scaled_stripes[0].offset = 0;\n\n\t\tacc->stripe.effective_stripes[0].width =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_EFFECTIVE].width;\n\t\tacc->stripe.bds_out_stripes_no_overlap[0].width =\n\t\t\tALIGN(css_pipe->rect[IPU3_CSS_RECT_BDS].width, f);\n\n\t\tacc->stripe.output_stripes[0].width =\n\t\t\tcss_pipe->queue[IPU3_CSS_QUEUE_OUT].fmt.mpix.width;\n\t} else {  \n\t\tbds_ds = css_pipe->rect[IPU3_CSS_RECT_EFFECTIVE].width *\n\t\t\t\tIMGU_BDS_GRANULARITY /\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].width;\n\n\t\tacc->stripe.down_scaled_stripes[0] =\n\t\t\tacc->stripe.bds_out_stripes[0];\n\t\tacc->stripe.down_scaled_stripes[1] =\n\t\t\tacc->stripe.bds_out_stripes[1];\n\t\tif (!IS_ALIGNED(css_pipe->rect[IPU3_CSS_RECT_BDS].width, f))\n\t\t\tacc->stripe.down_scaled_stripes[1].width +=\n\t\t\t\t(css_pipe->rect[IPU3_CSS_RECT_BDS].width\n\t\t\t\t& (f - 1)) - f;\n\n\t\tacc->stripe.effective_stripes[0].width = bds_ds *\n\t\t\tacc->stripe.down_scaled_stripes[0].width /\n\t\t\tIMGU_BDS_GRANULARITY;\n\t\tacc->stripe.effective_stripes[1].width = bds_ds *\n\t\t\tacc->stripe.down_scaled_stripes[1].width /\n\t\t\tIMGU_BDS_GRANULARITY;\n\t\tacc->stripe.effective_stripes[1].height =\n\t\t\tcss_pipe->rect[IPU3_CSS_RECT_EFFECTIVE].height;\n\t\tacc->stripe.effective_stripes[1].offset = bds_ds *\n\t\t\tacc->stripe.down_scaled_stripes[1].offset /\n\t\t\tIMGU_BDS_GRANULARITY;\n\n\t\tacc->stripe.bds_out_stripes_no_overlap[0].width =\n\t\tacc->stripe.bds_out_stripes_no_overlap[1].offset =\n\t\t\tALIGN(css_pipe->rect[IPU3_CSS_RECT_BDS].width, 2 * f) / 2;\n\t\tacc->stripe.bds_out_stripes_no_overlap[1].width =\n\t\t\tDIV_ROUND_UP(css_pipe->rect[IPU3_CSS_RECT_BDS].width, f)\n\t\t\t/ 2 * f;\n\t\tacc->stripe.bds_out_stripes_no_overlap[1].height =\n\t\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].height;\n\n\t\tacc->stripe.output_stripes[0].width =\n\t\t\tacc->stripe.down_scaled_stripes[0].width - f;\n\t\tacc->stripe.output_stripes[1].width =\n\t\t\tacc->stripe.down_scaled_stripes[1].width - f;\n\t\tacc->stripe.output_stripes[1].height =\n\t\t\tcss_pipe->queue[IPU3_CSS_QUEUE_OUT].fmt.mpix.height;\n\t\tacc->stripe.output_stripes[1].offset =\n\t\t\tacc->stripe.output_stripes[0].width;\n\t}\n\n\tacc->stripe.output_system_in_frame_width =\n\t\tcss_pipe->rect[IPU3_CSS_RECT_GDC].width;\n\tacc->stripe.output_system_in_frame_height =\n\t\tcss_pipe->rect[IPU3_CSS_RECT_GDC].height;\n\n\tacc->stripe.effective_frame_width =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_EFFECTIVE].width;\n\tacc->stripe.bds_frame_width = css_pipe->rect[IPU3_CSS_RECT_BDS].width;\n\tacc->stripe.out_frame_width =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_OUT].fmt.mpix.width;\n\tacc->stripe.out_frame_height =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_OUT].fmt.mpix.height;\n\tacc->stripe.gdc_in_buffer_width =\n\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].bytesperline /\n\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].bytesperpixel;\n\tacc->stripe.gdc_in_buffer_height =\n\t\tcss_pipe->aux_frames[IPU3_CSS_AUX_FRAME_REF].height;\n\tacc->stripe.gdc_in_buffer_offset_x = IMGU_GDC_BUF_X;\n\tacc->stripe.gdc_in_buffer_offset_y = IMGU_GDC_BUF_Y;\n\tacc->stripe.display_frame_width =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_VF].fmt.mpix.width;\n\tacc->stripe.display_frame_height =\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_VF].fmt.mpix.height;\n\tacc->stripe.bds_aligned_frame_width =\n\t\troundup(css_pipe->rect[IPU3_CSS_RECT_BDS].width,\n\t\t\t2 * IPU3_UAPI_ISP_VEC_ELEMS);\n\n\tif (stripes > 1)\n\t\tacc->stripe.half_overlap_vectors =\n\t\t\tIMGU_STRIPE_FIXED_HALF_OVERLAP;\n\telse\n\t\tacc->stripe.half_overlap_vectors = 0;\n\n\treturn 0;\n}\n\nstatic void imgu_css_cfg_acc_dvs(struct imgu_css *css,\n\t\t\t\t struct imgu_abi_acc_param *acc,\n\t\t\t\t unsigned int pipe)\n{\n\tunsigned int i;\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\n\t \n\tacc->dvs_stat.operations_data.process_lines_data[0].lines =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].height;\n\tacc->dvs_stat.operations_data.process_lines_data[0].cfg_set = 0;\n\tacc->dvs_stat.operations_data.ops[0].op_type =\n\t\tIMGU_ABI_ACC_OPTYPE_PROCESS_LINES;\n\tacc->dvs_stat.operations_data.ops[0].op_indicator =\n\t\tIMGU_ABI_ACC_OP_NO_OPS;\n\tfor (i = 0; i < IMGU_ABI_DVS_STAT_LEVELS; i++)\n\t\tacc->dvs_stat.cfg.grd_config[i].enable = 0;\n}\n\nstatic void acc_bds_per_stripe_data(struct imgu_css *css,\n\t\t\t\t    struct imgu_abi_acc_param *acc,\n\t\t\t\t    const int i, unsigned int pipe)\n{\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\n\tacc->bds.per_stripe.aligned_data[i].data.crop.hor_crop_en = 0;\n\tacc->bds.per_stripe.aligned_data[i].data.crop.hor_crop_start = 0;\n\tacc->bds.per_stripe.aligned_data[i].data.crop.hor_crop_end = 0;\n\tacc->bds.per_stripe.aligned_data[i].data.hor_ctrl0 =\n\t\tacc->bds.hor.hor_ctrl0;\n\tacc->bds.per_stripe.aligned_data[i].data.hor_ctrl0.out_frame_width =\n\t\tacc->stripe.down_scaled_stripes[i].width;\n\tacc->bds.per_stripe.aligned_data[i].data.ver_ctrl1.out_frame_width =\n\t\tacc->stripe.down_scaled_stripes[i].width;\n\tacc->bds.per_stripe.aligned_data[i].data.ver_ctrl1.out_frame_height =\n\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].height;\n}\n\n \nint imgu_css_cfg_acc(struct imgu_css *css, unsigned int pipe,\n\t\t     struct ipu3_uapi_flags *use,\n\t\t     struct imgu_abi_acc_param *acc,\n\t\t     struct imgu_abi_acc_param *acc_old,\n\t\t     struct ipu3_uapi_acc_param *acc_user)\n{\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\tconst struct imgu_fw_info *bi =\n\t\t&css->fwp->binary_header[css_pipe->bindex];\n\tconst unsigned int stripes = bi->info.isp.sp.iterator.num_stripes;\n\tconst unsigned int tnr_frame_width =\n\t\tacc->stripe.bds_aligned_frame_width;\n\tconst unsigned int min_overlap = 10;\n\tconst struct v4l2_pix_format_mplane *pixm =\n\t\t&css_pipe->queue[IPU3_CSS_QUEUE_IN].fmt.mpix;\n\tconst struct imgu_css_bds_config *cfg_bds;\n\tstruct imgu_abi_input_feeder_data *feeder_data;\n\n\tunsigned int bds_ds, ofs_x, ofs_y, i, width, height;\n\tu8 b_w_log2;  \n\n\t \n\n\tif (imgu_css_cfg_acc_stripe(css, pipe, acc))\n\t\treturn -EINVAL;\n\n\t \n\n\tofs_x = ((pixm->width -\n\t\t  css_pipe->rect[IPU3_CSS_RECT_EFFECTIVE].width) >> 1) & ~1;\n\tofs_x += css_pipe->queue[IPU3_CSS_QUEUE_IN].css_fmt->bayer_order ==\n\t\tIMGU_ABI_BAYER_ORDER_RGGB ||\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_IN].css_fmt->bayer_order ==\n\t\tIMGU_ABI_BAYER_ORDER_GBRG ? 1 : 0;\n\tofs_y = ((pixm->height -\n\t\t  css_pipe->rect[IPU3_CSS_RECT_EFFECTIVE].height) >> 1) & ~1;\n\tofs_y += css_pipe->queue[IPU3_CSS_QUEUE_IN].css_fmt->bayer_order ==\n\t\tIMGU_ABI_BAYER_ORDER_BGGR ||\n\t\tcss_pipe->queue[IPU3_CSS_QUEUE_IN].css_fmt->bayer_order ==\n\t\tIMGU_ABI_BAYER_ORDER_GBRG ? 1 : 0;\n\tacc->input_feeder.data.row_stride = pixm->plane_fmt[0].bytesperline;\n\tacc->input_feeder.data.start_row_address =\n\t\tofs_x / IMGU_PIXELS_PER_WORD * IMGU_BYTES_PER_WORD +\n\t\tofs_y * acc->input_feeder.data.row_stride;\n\tacc->input_feeder.data.start_pixel = ofs_x % IMGU_PIXELS_PER_WORD;\n\n\tacc->input_feeder.data_per_stripe.input_feeder_data[0].data =\n\t\tacc->input_feeder.data;\n\n\tofs_x += acc->stripe.effective_stripes[1].offset;\n\n\tfeeder_data =\n\t\t&acc->input_feeder.data_per_stripe.input_feeder_data[1].data;\n\tfeeder_data->row_stride = acc->input_feeder.data.row_stride;\n\tfeeder_data->start_row_address =\n\t\tofs_x / IMGU_PIXELS_PER_WORD * IMGU_BYTES_PER_WORD +\n\t\tofs_y * acc->input_feeder.data.row_stride;\n\tfeeder_data->start_pixel = ofs_x % IMGU_PIXELS_PER_WORD;\n\n\t \n\n\t \n\tif (use && use->acc_bnr) {\n\t\t \n\t\tacc->bnr = acc_user->bnr;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->bnr = acc_old->bnr;\n\t} else {\n\t\t \n\t\tacc->bnr = imgu_css_bnr_defaults;\n\t}\n\n\tacc->bnr.column_size = tnr_frame_width;\n\n\t \n\n\tif (use && use->acc_green_disparity) {\n\t\t \n\t\tacc->green_disparity = acc_user->green_disparity;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->green_disparity = acc_old->green_disparity;\n\t} else {\n\t\t \n\t\tmemset(&acc->green_disparity, 0, sizeof(acc->green_disparity));\n\t}\n\n\t \n\n\tif (use && use->acc_dm) {\n\t\t \n\t\tacc->dm = acc_user->dm;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->dm = acc_old->dm;\n\t} else {\n\t\t \n\t\tacc->dm = imgu_css_dm_defaults;\n\t}\n\n\tacc->dm.frame_width = tnr_frame_width;\n\n\t \n\n\tif (use && use->acc_ccm) {\n\t\t \n\t\tacc->ccm = acc_user->ccm;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->ccm = acc_old->ccm;\n\t} else {\n\t\t \n\t\tacc->ccm = imgu_css_ccm_defaults;\n\t}\n\n\t \n\n\tif (use && use->acc_gamma) {\n\t\t \n\t\tacc->gamma = acc_user->gamma;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->gamma = acc_old->gamma;\n\t} else {\n\t\t \n\t\tacc->gamma.gc_ctrl.enable = 1;\n\t\tacc->gamma.gc_lut = imgu_css_gamma_lut;\n\t}\n\n\t \n\n\tif (use && use->acc_csc) {\n\t\t \n\t\tacc->csc = acc_user->csc;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->csc = acc_old->csc;\n\t} else {\n\t\t \n\t\tacc->csc = imgu_css_csc_defaults;\n\t}\n\n\t \n\n\tif (use && use->acc_cds) {\n\t\t \n\t\tacc->cds = acc_user->cds;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->cds = acc_old->cds;\n\t} else {\n\t\t \n\t\tacc->cds = imgu_css_cds_defaults;\n\t}\n\n\t \n\n\tif (use && use->acc_shd) {\n\t\t \n\t\tacc->shd.shd = acc_user->shd.shd;\n\t\tacc->shd.shd_lut = acc_user->shd.shd_lut;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->shd.shd = acc_old->shd.shd;\n\t\tacc->shd.shd_lut = acc_old->shd.shd_lut;\n\t} else {\n\t\t \n\t\tacc->shd.shd = imgu_css_shd_defaults;\n\t\tmemset(&acc->shd.shd_lut, 0, sizeof(acc->shd.shd_lut));\n\t}\n\n\tif (acc->shd.shd.grid.width <= 0)\n\t\treturn -EINVAL;\n\n\tacc->shd.shd.grid.grid_height_per_slice =\n\t\tIMGU_ABI_SHD_MAX_CELLS_PER_SET / acc->shd.shd.grid.width;\n\n\tif (acc->shd.shd.grid.grid_height_per_slice <= 0)\n\t\treturn -EINVAL;\n\n\tacc->shd.shd.general.init_set_vrt_offst_ul =\n\t\t\t\t(-acc->shd.shd.grid.y_start >>\n\t\t\t\t acc->shd.shd.grid.block_height_log2) %\n\t\t\t\tacc->shd.shd.grid.grid_height_per_slice;\n\n\tif (imgu_css_shd_ops_calc(&acc->shd.shd_ops, &acc->shd.shd.grid,\n\t\t\t\t  css_pipe->rect[IPU3_CSS_RECT_BDS].height))\n\t\treturn -EINVAL;\n\n\t \n\timgu_css_cfg_acc_dvs(css, acc, pipe);\n\n\t \n\n\tif (use && use->acc_iefd) {\n\t\t \n\t\tacc->iefd = acc_user->iefd;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->iefd = acc_old->iefd;\n\t} else {\n\t\t \n\t\tacc->iefd = imgu_css_iefd_defaults;\n\t}\n\n\t \n\n\tif (use && use->acc_yds_c0) {\n\t\t \n\t\tacc->yds_c0 = acc_user->yds_c0;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->yds_c0 = acc_old->yds_c0;\n\t} else {\n\t\t \n\t\tacc->yds_c0 = imgu_css_yds_defaults;\n\t}\n\n\t \n\n\tif (use && use->acc_chnr_c0) {\n\t\t \n\t\tacc->chnr_c0 = acc_user->chnr_c0;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->chnr_c0 = acc_old->chnr_c0;\n\t} else {\n\t\t \n\t\tacc->chnr_c0 = imgu_css_chnr_defaults;\n\t}\n\n\t \n\n\tif (use && use->acc_y_ee_nr) {\n\t\t \n\t\tacc->y_ee_nr = acc_user->y_ee_nr;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->y_ee_nr = acc_old->y_ee_nr;\n\t} else {\n\t\t \n\t\tacc->y_ee_nr = imgu_css_y_ee_nr_defaults;\n\t}\n\n\t \n\n\tif (use && use->acc_yds) {\n\t\t \n\t\tacc->yds = acc_user->yds;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->yds = acc_old->yds;\n\t} else {\n\t\t \n\t\tacc->yds = imgu_css_yds_defaults;\n\t}\n\n\t \n\n\tif (use && use->acc_chnr) {\n\t\t \n\t\tacc->chnr = acc_user->chnr;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->chnr = acc_old->chnr;\n\t} else {\n\t\t \n\t\tacc->chnr = imgu_css_chnr_defaults;\n\t}\n\n\t \n\n\tfor (i = 0; i < IMGU_ABI_YUVP2_YTM_LUT_ENTRIES; i++)\n\t\tacc->ytm.entries[i] = i * 32;\n\tacc->ytm.enable = 0;\t \n\n\t \n\n\tif (use && use->acc_yds2) {\n\t\t \n\t\tacc->yds2 = acc_user->yds2;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->yds2 = acc_old->yds2;\n\t} else {\n\t\t \n\t\tacc->yds2 = imgu_css_yds_defaults;\n\t}\n\n\t \n\n\tif (use && use->acc_tcc) {\n\t\t \n\t\tacc->tcc = acc_user->tcc;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->tcc = acc_old->tcc;\n\t} else {\n\t\t \n\t\tmemset(&acc->tcc, 0, sizeof(acc->tcc));\n\n\t\tacc->tcc.gen_control.en = 1;\n\t\tacc->tcc.gen_control.blend_shift = 3;\n\t\tacc->tcc.gen_control.gain_according_to_y_only = 1;\n\t\tacc->tcc.gen_control.gamma = 8;\n\t\tacc->tcc.gen_control.delta = 0;\n\n\t\tfor (i = 0; i < IPU3_UAPI_YUVP2_TCC_MACC_TABLE_ELEMENTS; i++) {\n\t\t\tacc->tcc.macc_table.entries[i].a = 1024;\n\t\t\tacc->tcc.macc_table.entries[i].b = 0;\n\t\t\tacc->tcc.macc_table.entries[i].c = 0;\n\t\t\tacc->tcc.macc_table.entries[i].d = 1024;\n\t\t}\n\n\t\tacc->tcc.inv_y_lut.entries[6] = 1023;\n\t\tfor (i = 7; i < IPU3_UAPI_YUVP2_TCC_INV_Y_LUT_ELEMENTS; i++)\n\t\t\tacc->tcc.inv_y_lut.entries[i] = 1024 >> (i - 6);\n\n\t\tacc->tcc.gain_pcwl = imgu_css_tcc_gain_pcwl_lut;\n\t\tacc->tcc.r_sqr_lut = imgu_css_tcc_r_sqr_lut;\n\t}\n\n\t \n\n\tif (use && use->acc_dpc)\n\t\treturn -EINVAL;\t \n\n\t \n\tmemset(&acc->dpc, 0, sizeof(acc->dpc));\n\n\t \n\n\tbds_ds = (css_pipe->rect[IPU3_CSS_RECT_EFFECTIVE].height *\n\t\t  IMGU_BDS_GRANULARITY) / css_pipe->rect[IPU3_CSS_RECT_BDS].height;\n\tif (bds_ds < IMGU_BDS_MIN_SF_INV ||\n\t    bds_ds - IMGU_BDS_MIN_SF_INV >= ARRAY_SIZE(imgu_css_bds_configs))\n\t\treturn -EINVAL;\n\n\tcfg_bds = &imgu_css_bds_configs[bds_ds - IMGU_BDS_MIN_SF_INV];\n\tacc->bds.hor.hor_ctrl1.hor_crop_en = 0;\n\tacc->bds.hor.hor_ctrl1.hor_crop_start = 0;\n\tacc->bds.hor.hor_ctrl1.hor_crop_end = 0;\n\tacc->bds.hor.hor_ctrl0.sample_patrn_length =\n\t\t\t\tcfg_bds->sample_patrn_length;\n\tacc->bds.hor.hor_ctrl0.hor_ds_en = cfg_bds->hor_ds_en;\n\tacc->bds.hor.hor_ctrl0.min_clip_val = IMGU_BDS_MIN_CLIP_VAL;\n\tacc->bds.hor.hor_ctrl0.max_clip_val = IMGU_BDS_MAX_CLIP_VAL;\n\tacc->bds.hor.hor_ctrl0.out_frame_width =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].width;\n\tacc->bds.hor.hor_ptrn_arr = cfg_bds->ptrn_arr;\n\tacc->bds.hor.hor_phase_arr = cfg_bds->hor_phase_arr;\n\tacc->bds.hor.hor_ctrl2.input_frame_height =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_EFFECTIVE].height;\n\tacc->bds.ver.ver_ctrl0.min_clip_val = IMGU_BDS_MIN_CLIP_VAL;\n\tacc->bds.ver.ver_ctrl0.max_clip_val = IMGU_BDS_MAX_CLIP_VAL;\n\tacc->bds.ver.ver_ctrl0.sample_patrn_length =\n\t\t\t\tcfg_bds->sample_patrn_length;\n\tacc->bds.ver.ver_ctrl0.ver_ds_en = cfg_bds->ver_ds_en;\n\tacc->bds.ver.ver_ptrn_arr = cfg_bds->ptrn_arr;\n\tacc->bds.ver.ver_phase_arr = cfg_bds->ver_phase_arr;\n\tacc->bds.ver.ver_ctrl1.out_frame_width =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].width;\n\tacc->bds.ver.ver_ctrl1.out_frame_height =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].height;\n\tfor (i = 0; i < stripes; i++)\n\t\tacc_bds_per_stripe_data(css, acc, i, pipe);\n\n\tacc->bds.enabled = cfg_bds->hor_ds_en || cfg_bds->ver_ds_en;\n\n\t \n\n\tif (use && use->acc_anr) {\n\t\t \n\t\tacc->anr.transform = acc_user->anr.transform;\n\t\tacc->anr.stitch.anr_stitch_en =\n\t\t\tacc_user->anr.stitch.anr_stitch_en;\n\t\tmemcpy(acc->anr.stitch.pyramid, acc_user->anr.stitch.pyramid,\n\t\t       sizeof(acc->anr.stitch.pyramid));\n\t} else if (acc_old) {\n\t\t \n\t\tacc->anr.transform = acc_old->anr.transform;\n\t\tacc->anr.stitch.anr_stitch_en =\n\t\t\tacc_old->anr.stitch.anr_stitch_en;\n\t\tmemcpy(acc->anr.stitch.pyramid, acc_old->anr.stitch.pyramid,\n\t\t       sizeof(acc->anr.stitch.pyramid));\n\t} else {\n\t\t \n\t\tacc->anr = imgu_css_anr_defaults;\n\t}\n\n\t \n\tacc->anr.search.enable = 1;\n\tacc->anr.transform.enable = 1;\n\tacc->anr.tile2strm.enable = 1;\n\tacc->anr.tile2strm.frame_width =\n\t\tALIGN(css_pipe->rect[IPU3_CSS_RECT_BDS].width, IMGU_ISP_VMEM_ALIGN);\n\tacc->anr.search.frame_width = acc->anr.tile2strm.frame_width;\n\tacc->anr.stitch.frame_width = acc->anr.tile2strm.frame_width;\n\tacc->anr.tile2strm.frame_height = css_pipe->rect[IPU3_CSS_RECT_BDS].height;\n\tacc->anr.search.frame_height = acc->anr.tile2strm.frame_height;\n\tacc->anr.stitch.frame_height = acc->anr.tile2strm.frame_height;\n\n\twidth = ALIGN(css_pipe->rect[IPU3_CSS_RECT_BDS].width, IMGU_ISP_VMEM_ALIGN);\n\theight = css_pipe->rect[IPU3_CSS_RECT_BDS].height;\n\n\tif (acc->anr.transform.xreset + width > IPU3_UAPI_ANR_MAX_RESET)\n\t\tacc->anr.transform.xreset = IPU3_UAPI_ANR_MAX_RESET - width;\n\tif (acc->anr.transform.xreset < IPU3_UAPI_ANR_MIN_RESET)\n\t\tacc->anr.transform.xreset = IPU3_UAPI_ANR_MIN_RESET;\n\n\tif (acc->anr.transform.yreset + height > IPU3_UAPI_ANR_MAX_RESET)\n\t\tacc->anr.transform.yreset = IPU3_UAPI_ANR_MAX_RESET - height;\n\tif (acc->anr.transform.yreset < IPU3_UAPI_ANR_MIN_RESET)\n\t\tacc->anr.transform.yreset = IPU3_UAPI_ANR_MIN_RESET;\n\n\t \n\n\tif (use && use->acc_awb_fr) {\n\t\t \n\t\tacc->awb_fr.config = acc_user->awb_fr;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->awb_fr.config = acc_old->awb_fr.config;\n\t} else {\n\t\t \n\t\tacc->awb_fr.config = imgu_css_awb_fr_defaults;\n\t}\n\n\timgu_css_grid_end_calc(&acc->awb_fr.config.grid_cfg);\n\n\tif (acc->awb_fr.config.grid_cfg.width <= 0)\n\t\treturn -EINVAL;\n\n\tacc->awb_fr.config.grid_cfg.height_per_slice =\n\t\tIMGU_ABI_AWB_FR_MAX_CELLS_PER_SET /\n\t\tacc->awb_fr.config.grid_cfg.width;\n\n\tfor (i = 0; i < stripes; i++)\n\t\tacc->awb_fr.stripes[i] = acc->awb_fr.config;\n\n\tif (acc->awb_fr.config.grid_cfg.x_start >=\n\t    acc->stripe.down_scaled_stripes[1].offset + min_overlap) {\n\t\t \n\t\tacc->awb_fr.stripes[0].grid_cfg.y_start &=\n\t\t\t\t\t~IPU3_UAPI_GRID_Y_START_EN;\n\t} else if (acc->awb_fr.config.grid_cfg.x_end <=\n\t\t   acc->stripe.bds_out_stripes[0].width - min_overlap) {\n\t\t \n\t\tacc->awb_fr.stripes[1].grid_cfg.y_start &=\n\t\t\t\t\t~IPU3_UAPI_GRID_Y_START_EN;\n\t} else {\n\t\t \n\t\tu16 end;  \n\n\t\tacc->awb_fr.stripes[0].grid_cfg.width =\n\t\t\t(acc->stripe.bds_out_stripes[0].width - min_overlap -\n\t\t\t acc->awb_fr.config.grid_cfg.x_start + 1) >>\n\t\t\tacc->awb_fr.config.grid_cfg.block_width_log2;\n\t\tacc->awb_fr.stripes[1].grid_cfg.width =\n\t\t\tacc->awb_fr.config.grid_cfg.width -\n\t\t\tacc->awb_fr.stripes[0].grid_cfg.width;\n\n\t\tb_w_log2 = acc->awb_fr.stripes[0].grid_cfg.block_width_log2;\n\t\tend = imgu_css_grid_end(acc->awb_fr.stripes[0].grid_cfg.x_start,\n\t\t\t\t\tacc->awb_fr.stripes[0].grid_cfg.width,\n\t\t\t\t\tb_w_log2);\n\t\tacc->awb_fr.stripes[0].grid_cfg.x_end = end;\n\n\t\tacc->awb_fr.stripes[1].grid_cfg.x_start =\n\t\t\t(acc->awb_fr.stripes[0].grid_cfg.x_end + 1 -\n\t\t\t acc->stripe.down_scaled_stripes[1].offset) &\n\t\t\tIPU3_UAPI_GRID_START_MASK;\n\t\tb_w_log2 = acc->awb_fr.stripes[1].grid_cfg.block_width_log2;\n\t\tend = imgu_css_grid_end(acc->awb_fr.stripes[1].grid_cfg.x_start,\n\t\t\t\t\tacc->awb_fr.stripes[1].grid_cfg.width,\n\t\t\t\t\tb_w_log2);\n\t\tacc->awb_fr.stripes[1].grid_cfg.x_end = end;\n\n\t\t \n\t\tfor (i = 0; i < stripes; i++)\n\t\t\tacc->awb_fr.stripes[i].grid_cfg.height_per_slice = 1;\n\t}\n\n\tif (imgu_css_awb_fr_ops_calc(css, pipe, &acc->awb_fr))\n\t\treturn -EINVAL;\n\n\t \n\n\tif (use && use->acc_ae) {\n\t\t \n\t\tacc->ae.grid_cfg = acc_user->ae.grid_cfg;\n\t\tacc->ae.ae_ccm = acc_user->ae.ae_ccm;\n\t\tfor (i = 0; i < IPU3_UAPI_AE_WEIGHTS; i++)\n\t\t\tacc->ae.weights[i] = acc_user->ae.weights[i];\n\t} else if (acc_old) {\n\t\t \n\t\tacc->ae.grid_cfg = acc_old->ae.grid_cfg;\n\t\tacc->ae.ae_ccm = acc_old->ae.ae_ccm;\n\t\tfor (i = 0; i < IPU3_UAPI_AE_WEIGHTS; i++)\n\t\t\tacc->ae.weights[i] = acc_old->ae.weights[i];\n\t} else {\n\t\t \n\t\tstatic const struct ipu3_uapi_ae_weight_elem\n\t\t\tweight_def = { 1, 1, 1, 1, 1, 1, 1, 1 };\n\n\t\tacc->ae.grid_cfg = imgu_css_ae_grid_defaults;\n\t\tacc->ae.ae_ccm = imgu_css_ae_ccm_defaults;\n\t\tfor (i = 0; i < IPU3_UAPI_AE_WEIGHTS; i++)\n\t\t\tacc->ae.weights[i] = weight_def;\n\t}\n\n\tb_w_log2 = acc->ae.grid_cfg.block_width_log2;\n\tacc->ae.grid_cfg.x_end = imgu_css_grid_end(acc->ae.grid_cfg.x_start,\n\t\t\t\t\t\t   acc->ae.grid_cfg.width,\n\t\t\t\t\t\t   b_w_log2);\n\tb_w_log2 = acc->ae.grid_cfg.block_height_log2;\n\tacc->ae.grid_cfg.y_end = imgu_css_grid_end(acc->ae.grid_cfg.y_start,\n\t\t\t\t\t\t   acc->ae.grid_cfg.height,\n\t\t\t\t\t\t   b_w_log2);\n\n\tfor (i = 0; i < stripes; i++)\n\t\tacc->ae.stripes[i].grid = acc->ae.grid_cfg;\n\n\tif (acc->ae.grid_cfg.x_start >=\n\t    acc->stripe.down_scaled_stripes[1].offset) {\n\t\t \n\t\tacc->ae.stripes[0].grid.ae_en = 0;\n\t} else if (acc->ae.grid_cfg.x_end <=\n\t\t   acc->stripe.bds_out_stripes[0].width) {\n\t\t \n\t\tacc->ae.stripes[1].grid.ae_en = 0;\n\t} else {\n\t\t \n\t\tu8 b_w_log2;\n\n\t\tacc->ae.stripes[0].grid.width =\n\t\t\t(acc->stripe.bds_out_stripes[0].width -\n\t\t\t acc->ae.grid_cfg.x_start + 1) >>\n\t\t\tacc->ae.grid_cfg.block_width_log2;\n\n\t\tacc->ae.stripes[1].grid.width =\n\t\t\tacc->ae.grid_cfg.width - acc->ae.stripes[0].grid.width;\n\n\t\tb_w_log2 = acc->ae.stripes[0].grid.block_width_log2;\n\t\tacc->ae.stripes[0].grid.x_end =\n\t\t\timgu_css_grid_end(acc->ae.stripes[0].grid.x_start,\n\t\t\t\t\t  acc->ae.stripes[0].grid.width,\n\t\t\t\t\t  b_w_log2);\n\n\t\tacc->ae.stripes[1].grid.x_start =\n\t\t\t(acc->ae.stripes[0].grid.x_end + 1 -\n\t\t\t acc->stripe.down_scaled_stripes[1].offset) &\n\t\t\tIPU3_UAPI_GRID_START_MASK;\n\t\tb_w_log2 = acc->ae.stripes[1].grid.block_width_log2;\n\t\tacc->ae.stripes[1].grid.x_end =\n\t\t\timgu_css_grid_end(acc->ae.stripes[1].grid.x_start,\n\t\t\t\t\t  acc->ae.stripes[1].grid.width,\n\t\t\t\t\t  b_w_log2);\n\t}\n\n\t \n\n\tif (use && use->acc_af) {\n\t\t \n\t\tacc->af.config.filter_config = acc_user->af.filter_config;\n\t\tacc->af.config.grid_cfg = acc_user->af.grid_cfg;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->af.config = acc_old->af.config;\n\t} else {\n\t\t \n\t\tacc->af.config.filter_config =\n\t\t\t\timgu_css_af_defaults.filter_config;\n\t\tacc->af.config.grid_cfg = imgu_css_af_defaults.grid_cfg;\n\t}\n\n\timgu_css_grid_end_calc(&acc->af.config.grid_cfg);\n\n\tif (acc->af.config.grid_cfg.width <= 0)\n\t\treturn -EINVAL;\n\n\tacc->af.config.grid_cfg.height_per_slice =\n\t\tIMGU_ABI_AF_MAX_CELLS_PER_SET / acc->af.config.grid_cfg.width;\n\tacc->af.config.frame_size.width =\n\t\tALIGN(css_pipe->rect[IPU3_CSS_RECT_BDS].width, IMGU_ISP_VMEM_ALIGN);\n\tacc->af.config.frame_size.height =\n\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].height;\n\n\tif (acc->stripe.bds_out_stripes[0].width <= min_overlap)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < stripes; i++) {\n\t\tacc->af.stripes[i].grid_cfg = acc->af.config.grid_cfg;\n\t\tacc->af.stripes[i].frame_size.height =\n\t\t\t\tcss_pipe->rect[IPU3_CSS_RECT_BDS].height;\n\t\tacc->af.stripes[i].frame_size.width =\n\t\t\tacc->stripe.bds_out_stripes[i].width;\n\t}\n\n\tif (acc->af.config.grid_cfg.x_start >=\n\t    acc->stripe.down_scaled_stripes[1].offset + min_overlap) {\n\t\t \n\t\tacc->af.stripes[0].grid_cfg.y_start &=\n\t\t\t~IPU3_UAPI_GRID_Y_START_EN;\n\t\tacc->af.stripes[1].grid_cfg.x_start =\n\t\t\t(acc->af.stripes[1].grid_cfg.x_start -\n\t\t\t acc->stripe.down_scaled_stripes[1].offset) &\n\t\t\tIPU3_UAPI_GRID_START_MASK;\n\t\tb_w_log2 = acc->af.stripes[1].grid_cfg.block_width_log2;\n\t\tacc->af.stripes[1].grid_cfg.x_end =\n\t\t\timgu_css_grid_end(acc->af.stripes[1].grid_cfg.x_start,\n\t\t\t\t\t  acc->af.stripes[1].grid_cfg.width,\n\t\t\t\t\t  b_w_log2);\n\t} else if (acc->af.config.grid_cfg.x_end <=\n\t\t   acc->stripe.bds_out_stripes[0].width - min_overlap) {\n\t\t \n\t\tacc->af.stripes[1].grid_cfg.y_start &=\n\t\t\t~IPU3_UAPI_GRID_Y_START_EN;\n\t} else {\n\t\t \n\n\t\tacc->af.stripes[0].grid_cfg.width =\n\t\t\t(acc->stripe.bds_out_stripes[0].width - min_overlap -\n\t\t\t acc->af.config.grid_cfg.x_start + 1) >>\n\t\t\tacc->af.config.grid_cfg.block_width_log2;\n\t\tacc->af.stripes[1].grid_cfg.width =\n\t\t\tacc->af.config.grid_cfg.width -\n\t\t\tacc->af.stripes[0].grid_cfg.width;\n\n\t\tb_w_log2 = acc->af.stripes[0].grid_cfg.block_width_log2;\n\t\tacc->af.stripes[0].grid_cfg.x_end =\n\t\t\timgu_css_grid_end(acc->af.stripes[0].grid_cfg.x_start,\n\t\t\t\t\t  acc->af.stripes[0].grid_cfg.width,\n\t\t\t\t\t  b_w_log2);\n\n\t\tacc->af.stripes[1].grid_cfg.x_start =\n\t\t\t(acc->af.stripes[0].grid_cfg.x_end + 1 -\n\t\t\t acc->stripe.down_scaled_stripes[1].offset) &\n\t\t\tIPU3_UAPI_GRID_START_MASK;\n\n\t\tb_w_log2 = acc->af.stripes[1].grid_cfg.block_width_log2;\n\t\tacc->af.stripes[1].grid_cfg.x_end =\n\t\t\timgu_css_grid_end(acc->af.stripes[1].grid_cfg.x_start,\n\t\t\t\t\t  acc->af.stripes[1].grid_cfg.width,\n\t\t\t\t\t  b_w_log2);\n\n\t\t \n\t\tfor (i = 0; i < stripes; i++)\n\t\t\tacc->af.stripes[i].grid_cfg.height_per_slice = 1;\n\t}\n\n\tif (imgu_css_af_ops_calc(css, pipe, &acc->af))\n\t\treturn -EINVAL;\n\n\t \n\n\tif (use && use->acc_awb) {\n\t\t \n\t\tacc->awb.config = acc_user->awb.config;\n\t} else if (acc_old) {\n\t\t \n\t\tacc->awb.config = acc_old->awb.config;\n\t} else {\n\t\t \n\t\tacc->awb.config = imgu_css_awb_defaults;\n\t}\n\n\tif (acc->awb.config.grid.width <= 0)\n\t\treturn -EINVAL;\n\n\tacc->awb.config.grid.height_per_slice =\n\t\tIMGU_ABI_AWB_MAX_CELLS_PER_SET / acc->awb.config.grid.width,\n\timgu_css_grid_end_calc(&acc->awb.config.grid);\n\n\tfor (i = 0; i < stripes; i++)\n\t\tacc->awb.stripes[i] = acc->awb.config;\n\n\tif (acc->awb.config.grid.x_start >=\n\t    acc->stripe.down_scaled_stripes[1].offset + min_overlap) {\n\t\t \n\t\tacc->awb.stripes[0].rgbs_thr_b &= ~IPU3_UAPI_AWB_RGBS_THR_B_EN;\n\n\t\tacc->awb.stripes[1].grid.x_start =\n\t\t\t(acc->awb.stripes[1].grid.x_start -\n\t\t\t acc->stripe.down_scaled_stripes[1].offset) &\n\t\t\tIPU3_UAPI_GRID_START_MASK;\n\n\t\tb_w_log2 = acc->awb.stripes[1].grid.block_width_log2;\n\t\tacc->awb.stripes[1].grid.x_end =\n\t\t\timgu_css_grid_end(acc->awb.stripes[1].grid.x_start,\n\t\t\t\t\t  acc->awb.stripes[1].grid.width,\n\t\t\t\t\t  b_w_log2);\n\t} else if (acc->awb.config.grid.x_end <=\n\t\t   acc->stripe.bds_out_stripes[0].width - min_overlap) {\n\t\t \n\t\tacc->awb.stripes[1].rgbs_thr_b &= ~IPU3_UAPI_AWB_RGBS_THR_B_EN;\n\t} else {\n\t\t \n\n\t\tacc->awb.stripes[0].grid.width =\n\t\t\t(acc->stripe.bds_out_stripes[0].width -\n\t\t\t acc->awb.config.grid.x_start + 1) >>\n\t\t\tacc->awb.config.grid.block_width_log2;\n\t\tacc->awb.stripes[1].grid.width = acc->awb.config.grid.width -\n\t\t\t\tacc->awb.stripes[0].grid.width;\n\n\t\tb_w_log2 = acc->awb.stripes[0].grid.block_width_log2;\n\t\tacc->awb.stripes[0].grid.x_end =\n\t\t\timgu_css_grid_end(acc->awb.stripes[0].grid.x_start,\n\t\t\t\t\t  acc->awb.stripes[0].grid.width,\n\t\t\t\t\t  b_w_log2);\n\n\t\tacc->awb.stripes[1].grid.x_start =\n\t\t\t(acc->awb.stripes[0].grid.x_end + 1 -\n\t\t\t acc->stripe.down_scaled_stripes[1].offset) &\n\t\t\tIPU3_UAPI_GRID_START_MASK;\n\n\t\tb_w_log2 = acc->awb.stripes[1].grid.block_width_log2;\n\t\tacc->awb.stripes[1].grid.x_end =\n\t\t\timgu_css_grid_end(acc->awb.stripes[1].grid.x_start,\n\t\t\t\t\t  acc->awb.stripes[1].grid.width,\n\t\t\t\t\t  b_w_log2);\n\n\t\t \n\t\tfor (i = 0; i < stripes; i++)\n\t\t\tacc->awb.stripes[i].grid.height_per_slice = 1;\n\t}\n\n\tif (imgu_css_awb_ops_calc(css, pipe, &acc->awb))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic void *imgu_css_cfg_copy(struct imgu_css *css,\n\t\t\t       unsigned int pipe, bool use_user,\n\t\t\t       void *user_setting, void *old_binary_params,\n\t\t\t       void *new_binary_params,\n\t\t\t       enum imgu_abi_memories m,\n\t\t\t       struct imgu_fw_isp_parameter *par,\n\t\t\t       size_t par_size)\n{\n\tconst enum imgu_abi_param_class c = IMGU_ABI_PARAM_CLASS_PARAM;\n\tvoid *new_setting, *old_setting;\n\n\tnew_setting = imgu_css_fw_pipeline_params(css, pipe, c, m, par,\n\t\t\t\t\t\t  par_size, new_binary_params);\n\tif (!new_setting)\n\t\treturn ERR_PTR(-EPROTO);\t \n\n\tif (use_user) {\n\t\t \n\t\tmemcpy(new_setting, user_setting, par_size);\n\t} else if (old_binary_params) {\n\t\t \n\t\told_setting = imgu_css_fw_pipeline_params(css, pipe, c, m, par,\n\t\t\t\t\t\t\t  par_size,\n\t\t\t\t\t\t\t  old_binary_params);\n\t\tif (!old_setting)\n\t\t\treturn ERR_PTR(-EPROTO);\n\t\tmemcpy(new_setting, old_setting, par_size);\n\t} else {\n\t\treturn new_setting;\t \n\t}\n\n\treturn NULL;\t\t \n}\n\n \nint imgu_css_cfg_vmem0(struct imgu_css *css, unsigned int pipe,\n\t\t       struct ipu3_uapi_flags *use,\n\t\t       void *vmem0, void *vmem0_old,\n\t\t       struct ipu3_uapi_params *user)\n{\n\tconst struct imgu_fw_info *bi =\n\t\t&css->fwp->binary_header[css->pipes[pipe].bindex];\n\tstruct imgu_fw_param_memory_offsets *pofs = (void *)css->fwp +\n\t\tbi->blob.memory_offsets.offsets[IMGU_ABI_PARAM_CLASS_PARAM];\n\tstruct ipu3_uapi_isp_lin_vmem_params *lin_vmem = NULL;\n\tstruct ipu3_uapi_isp_tnr3_vmem_params *tnr_vmem = NULL;\n\tstruct ipu3_uapi_isp_xnr3_vmem_params *xnr_vmem = NULL;\n\tconst enum imgu_abi_param_class c = IMGU_ABI_PARAM_CLASS_PARAM;\n\tconst enum imgu_abi_memories m = IMGU_ABI_MEM_ISP_VMEM0;\n\tunsigned int i;\n\n\t \n\n\tmemset(vmem0, 0, bi->info.isp.sp.mem_initializers.params[c][m].size);\n\n\t \n\n\tlin_vmem = imgu_css_cfg_copy(css, pipe, use && use->lin_vmem_params,\n\t\t\t\t     &user->lin_vmem_params, vmem0_old, vmem0,\n\t\t\t\t     m, &pofs->vmem.lin, sizeof(*lin_vmem));\n\tif (!IS_ERR_OR_NULL(lin_vmem)) {\n\t\t \n\t\tfor (i = 0; i < IPU3_UAPI_LIN_LUT_SIZE; i++) {\n\t\t\tlin_vmem->lin_lutlow_gr[i] = 32 * i;\n\t\t\tlin_vmem->lin_lutlow_r[i] = 32 * i;\n\t\t\tlin_vmem->lin_lutlow_b[i] = 32 * i;\n\t\t\tlin_vmem->lin_lutlow_gb[i] = 32 * i;\n\n\t\t\tlin_vmem->lin_lutdif_gr[i] = 32;\n\t\t\tlin_vmem->lin_lutdif_r[i] = 32;\n\t\t\tlin_vmem->lin_lutdif_b[i] = 32;\n\t\t\tlin_vmem->lin_lutdif_gb[i] = 32;\n\t\t}\n\t}\n\n\t \n\tif (css->pipes[pipe].pipe_id == IPU3_CSS_PIPE_ID_VIDEO) {\n\t\ttnr_vmem = imgu_css_cfg_copy(css, pipe,\n\t\t\t\t\t     use && use->tnr3_vmem_params,\n\t\t\t\t\t     &user->tnr3_vmem_params,\n\t\t\t\t\t     vmem0_old, vmem0, m,\n\t\t\t\t\t     &pofs->vmem.tnr3,\n\t\t\t\t\t     sizeof(*tnr_vmem));\n\t\tif (!IS_ERR_OR_NULL(tnr_vmem)) {\n\t\t\t \n\t\t\tfor (i = 0; i < IPU3_UAPI_ISP_TNR3_VMEM_LEN; i++)\n\t\t\t\ttnr_vmem->sigma[i] = 256;\n\t\t}\n\t}\n\ti = IPU3_UAPI_ISP_TNR3_VMEM_LEN;\n\n\t \n\n\txnr_vmem = imgu_css_cfg_copy(css, pipe, use && use->xnr3_vmem_params,\n\t\t\t\t     &user->xnr3_vmem_params, vmem0_old, vmem0,\n\t\t\t\t     m, &pofs->vmem.xnr3, sizeof(*xnr_vmem));\n\tif (!IS_ERR_OR_NULL(xnr_vmem)) {\n\t\txnr_vmem->x[i] = imgu_css_xnr3_vmem_defaults.x\n\t\t\t[i % IMGU_XNR3_VMEM_LUT_LEN];\n\t\txnr_vmem->a[i] = imgu_css_xnr3_vmem_defaults.a\n\t\t\t[i % IMGU_XNR3_VMEM_LUT_LEN];\n\t\txnr_vmem->b[i] = imgu_css_xnr3_vmem_defaults.b\n\t\t\t[i % IMGU_XNR3_VMEM_LUT_LEN];\n\t\txnr_vmem->c[i] = imgu_css_xnr3_vmem_defaults.c\n\t\t\t[i % IMGU_XNR3_VMEM_LUT_LEN];\n\t}\n\n\treturn IS_ERR(lin_vmem) || IS_ERR(tnr_vmem) || IS_ERR(xnr_vmem) ?\n\t\t-EPROTO : 0;\n}\n\n \nint imgu_css_cfg_dmem0(struct imgu_css *css, unsigned int pipe,\n\t\t       struct ipu3_uapi_flags *use,\n\t\t       void *dmem0, void *dmem0_old,\n\t\t       struct ipu3_uapi_params *user)\n{\n\tstruct imgu_css_pipe *css_pipe = &css->pipes[pipe];\n\tconst struct imgu_fw_info *bi =\n\t\t&css->fwp->binary_header[css_pipe->bindex];\n\tstruct imgu_fw_param_memory_offsets *pofs = (void *)css->fwp +\n\t\tbi->blob.memory_offsets.offsets[IMGU_ABI_PARAM_CLASS_PARAM];\n\n\tstruct ipu3_uapi_isp_tnr3_params *tnr_dmem = NULL;\n\tstruct ipu3_uapi_isp_xnr3_params *xnr_dmem;\n\n\tconst enum imgu_abi_param_class c = IMGU_ABI_PARAM_CLASS_PARAM;\n\tconst enum imgu_abi_memories m = IMGU_ABI_MEM_ISP_DMEM0;\n\n\t \n\n\tmemset(dmem0, 0, bi->info.isp.sp.mem_initializers.params[c][m].size);\n\n\t \n\tif (css_pipe->pipe_id == IPU3_CSS_PIPE_ID_VIDEO) {\n\t\ttnr_dmem = imgu_css_cfg_copy(css, pipe,\n\t\t\t\t\t     use && use->tnr3_dmem_params,\n\t\t\t\t\t     &user->tnr3_dmem_params,\n\t\t\t\t\t     dmem0_old, dmem0, m,\n\t\t\t\t\t     &pofs->dmem.tnr3,\n\t\t\t\t\t     sizeof(*tnr_dmem));\n\t\tif (!IS_ERR_OR_NULL(tnr_dmem)) {\n\t\t\t \n\t\t\ttnr_dmem->knee_y1 = 768;\n\t\t\ttnr_dmem->knee_y2 = 1280;\n\t\t}\n\t}\n\n\t \n\n\txnr_dmem = imgu_css_cfg_copy(css, pipe, use && use->xnr3_dmem_params,\n\t\t\t\t     &user->xnr3_dmem_params, dmem0_old, dmem0,\n\t\t\t\t     m, &pofs->dmem.xnr3, sizeof(*xnr_dmem));\n\tif (!IS_ERR_OR_NULL(xnr_dmem)) {\n\t\t \n\t\txnr_dmem->alpha.y0 = 2047;\n\t\txnr_dmem->alpha.u0 = 2047;\n\t\txnr_dmem->alpha.v0 = 2047;\n\t}\n\n\treturn IS_ERR(tnr_dmem) || IS_ERR(xnr_dmem) ? -EPROTO : 0;\n}\n\n \nvoid imgu_css_cfg_gdc_table(struct imgu_abi_gdc_warp_param *gdc,\n\t\t\t    int frame_in_x, int frame_in_y,\n\t\t\t    int frame_out_x, int frame_out_y,\n\t\t\t    int env_w, int env_h)\n{\n\tstatic const unsigned int FRAC_BITS = IMGU_ABI_GDC_FRAC_BITS;\n\tstatic const unsigned int XMEM_ALIGN = 1 << 4;\n\tconst unsigned int XMEM_ALIGN_MASK = ~(XMEM_ALIGN - 1);\n\tstatic const unsigned int BCI_ENV = 4;\n\tstatic const unsigned int BYP = 2;\t \n\tconst unsigned int OFFSET_X = 2 * IMGU_DVS_BLOCK_W + env_w + 1;\n\tconst unsigned int OFFSET_Y = IMGU_DVS_BLOCK_H + env_h + 1;\n\n\tstruct imgu_abi_gdc_warp_param gdc_luma, gdc_chroma;\n\n\tunsigned int blocks_x = ALIGN(DIV_ROUND_UP(frame_out_x,\n\t\t\t\t\t\t   IMGU_DVS_BLOCK_W), 2);\n\tunsigned int blocks_y = DIV_ROUND_UP(frame_out_y, IMGU_DVS_BLOCK_H);\n\tunsigned int y0, x0, x1, x, y;\n\n\t \n\tgdc_luma.origin_x = 0;\n\tgdc_luma.origin_y = 0;\n\tgdc_luma.p0_x = (OFFSET_X - (OFFSET_X & XMEM_ALIGN_MASK)) << FRAC_BITS;\n\tgdc_luma.p0_y = 0;\n\tgdc_luma.p1_x = gdc_luma.p0_x + (IMGU_DVS_BLOCK_W << FRAC_BITS);\n\tgdc_luma.p1_y = gdc_luma.p0_y;\n\tgdc_luma.p2_x = gdc_luma.p0_x;\n\tgdc_luma.p2_y = gdc_luma.p0_y + (IMGU_DVS_BLOCK_H << FRAC_BITS);\n\tgdc_luma.p3_x = gdc_luma.p1_x;\n\tgdc_luma.p3_y = gdc_luma.p2_y;\n\n\tgdc_luma.in_block_width = IMGU_DVS_BLOCK_W + BCI_ENV +\n\t\t\t\t\tOFFSET_X - (OFFSET_X & XMEM_ALIGN_MASK);\n\tgdc_luma.in_block_width_a = DIV_ROUND_UP(gdc_luma.in_block_width,\n\t\t\t\t\t\t IPU3_UAPI_ISP_VEC_ELEMS);\n\tgdc_luma.in_block_width_b = DIV_ROUND_UP(gdc_luma.in_block_width,\n\t\t\t\t\t\t IMGU_ABI_ISP_DDR_WORD_BYTES /\n\t\t\t\t\t\t BYP);\n\tgdc_luma.in_block_height = IMGU_DVS_BLOCK_H + BCI_ENV;\n\tgdc_luma.padding = 0;\n\n\t \n\tgdc_chroma.origin_x = 0;\n\tgdc_chroma.origin_y = 0;\n\tgdc_chroma.p0_x = (OFFSET_X / 2 - (OFFSET_X / 2 & XMEM_ALIGN_MASK)) <<\n\t\t\t   FRAC_BITS;\n\tgdc_chroma.p0_y = 0;\n\tgdc_chroma.p1_x = gdc_chroma.p0_x + (IMGU_DVS_BLOCK_W << FRAC_BITS);\n\tgdc_chroma.p1_y = gdc_chroma.p0_y;\n\tgdc_chroma.p2_x = gdc_chroma.p0_x;\n\tgdc_chroma.p2_y = gdc_chroma.p0_y + (IMGU_DVS_BLOCK_H / 2 << FRAC_BITS);\n\tgdc_chroma.p3_x = gdc_chroma.p1_x;\n\tgdc_chroma.p3_y = gdc_chroma.p2_y;\n\n\tgdc_chroma.in_block_width = IMGU_DVS_BLOCK_W + BCI_ENV;\n\tgdc_chroma.in_block_width_a = DIV_ROUND_UP(gdc_chroma.in_block_width,\n\t\t\t\t\t\t   IPU3_UAPI_ISP_VEC_ELEMS);\n\tgdc_chroma.in_block_width_b = DIV_ROUND_UP(gdc_chroma.in_block_width,\n\t\t\t\t\t\t   IMGU_ABI_ISP_DDR_WORD_BYTES /\n\t\t\t\t\t\t   BYP);\n\tgdc_chroma.in_block_height = IMGU_DVS_BLOCK_H / 2 + BCI_ENV;\n\tgdc_chroma.padding = 0;\n\n\t \n\tfor (y0 = 0; y0 < blocks_y; y0++) {\n\t\tfor (x0 = 0; x0 < blocks_x / 2; x0++) {\n\t\t\tfor (x1 = 0; x1 < 2; x1++) {\n\t\t\t\t \n\t\t\t\tx = (x0 * 2 + x1) * IMGU_DVS_BLOCK_W + OFFSET_X;\n\t\t\t\tx &= XMEM_ALIGN_MASK;\n\t\t\t\ty = y0 * IMGU_DVS_BLOCK_H + OFFSET_Y;\n\t\t\t\t*gdc = gdc_luma;\n\t\t\t\tgdc->in_addr_offset =\n\t\t\t\t\t(y * frame_in_x + x) * BYP;\n\t\t\t\tgdc++;\n\t\t\t}\n\n\t\t\t \n\t\t\tx = x0 * IMGU_DVS_BLOCK_W + OFFSET_X / 2;\n\t\t\tx &= XMEM_ALIGN_MASK;\n\t\t\ty = y0 * (IMGU_DVS_BLOCK_H / 2) + OFFSET_Y / 2;\n\t\t\t*gdc = gdc_chroma;\n\t\t\tgdc->in_addr_offset = (y * frame_in_x + x) * BYP;\n\t\t\tgdc++;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}