{
  "module_name": "cedrus_video.c",
  "hash_id": "b1a5baa9df1d00e75191dc2b9d5eed0d50c48da1d6c6e75404d8bdd5f9751dc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/sunxi/cedrus/cedrus_video.c",
  "human_readable_source": "\n \n\n#include <linux/pm_runtime.h>\n\n#include <media/videobuf2-dma-contig.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n\n#include \"cedrus.h\"\n#include \"cedrus_video.h\"\n#include \"cedrus_dec.h\"\n#include \"cedrus_hw.h\"\n\n#define CEDRUS_DECODE_SRC\tBIT(0)\n#define CEDRUS_DECODE_DST\tBIT(1)\n\n#define CEDRUS_MIN_WIDTH\t16U\n#define CEDRUS_MIN_HEIGHT\t16U\n#define CEDRUS_MAX_WIDTH\t4096U\n#define CEDRUS_MAX_HEIGHT\t2304U\n\nstatic struct cedrus_format cedrus_formats[] = {\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_MPEG2_SLICE,\n\t\t.directions\t= CEDRUS_DECODE_SRC,\n\t\t.capabilities\t= CEDRUS_CAPABILITY_MPEG2_DEC,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_H264_SLICE,\n\t\t.directions\t= CEDRUS_DECODE_SRC,\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H264_DEC,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_HEVC_SLICE,\n\t\t.directions\t= CEDRUS_DECODE_SRC,\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H265_DEC,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_VP8_FRAME,\n\t\t.directions\t= CEDRUS_DECODE_SRC,\n\t\t.capabilities\t= CEDRUS_CAPABILITY_VP8_DEC,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_NV12,\n\t\t.directions\t= CEDRUS_DECODE_DST,\n\t\t.capabilities\t= CEDRUS_CAPABILITY_UNTILED,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_NV12_32L32,\n\t\t.directions\t= CEDRUS_DECODE_DST,\n\t},\n};\n\n#define CEDRUS_FORMATS_COUNT\tARRAY_SIZE(cedrus_formats)\n\nstatic inline struct cedrus_ctx *cedrus_file2ctx(struct file *file)\n{\n\treturn container_of(file->private_data, struct cedrus_ctx, fh);\n}\n\nstatic struct cedrus_format *cedrus_find_format(struct cedrus_ctx *ctx,\n\t\t\t\t\t\tu32 pixelformat, u32 directions)\n{\n\tstruct cedrus_format *first_valid_fmt = NULL;\n\tstruct cedrus_format *fmt;\n\tunsigned int i;\n\n\tfor (i = 0; i < CEDRUS_FORMATS_COUNT; i++) {\n\t\tfmt = &cedrus_formats[i];\n\n\t\tif (!cedrus_is_capable(ctx, fmt->capabilities) ||\n\t\t    !(fmt->directions & directions))\n\t\t\tcontinue;\n\n\t\tif (fmt->pixelformat == pixelformat)\n\t\t\tbreak;\n\n\t\tif (!first_valid_fmt)\n\t\t\tfirst_valid_fmt = fmt;\n\t}\n\n\tif (i == CEDRUS_FORMATS_COUNT)\n\t\treturn first_valid_fmt;\n\n\treturn &cedrus_formats[i];\n}\n\nvoid cedrus_prepare_format(struct v4l2_pix_format *pix_fmt)\n{\n\tunsigned int width = pix_fmt->width;\n\tunsigned int height = pix_fmt->height;\n\tunsigned int sizeimage = pix_fmt->sizeimage;\n\tunsigned int bytesperline = pix_fmt->bytesperline;\n\n\tpix_fmt->field = V4L2_FIELD_NONE;\n\n\t \n\twidth = clamp(width, CEDRUS_MIN_WIDTH, CEDRUS_MAX_WIDTH);\n\theight = clamp(height, CEDRUS_MIN_HEIGHT, CEDRUS_MAX_HEIGHT);\n\n\tswitch (pix_fmt->pixelformat) {\n\tcase V4L2_PIX_FMT_MPEG2_SLICE:\n\tcase V4L2_PIX_FMT_H264_SLICE:\n\tcase V4L2_PIX_FMT_HEVC_SLICE:\n\tcase V4L2_PIX_FMT_VP8_FRAME:\n\t\t \n\t\tbytesperline = 0;\n\t\t \n\t\tsizeimage = max_t(u32, SZ_1K, sizeimage);\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_NV12_32L32:\n\t\t \n\t\tbytesperline = ALIGN(width, 32);\n\n\t\t \n\t\theight = ALIGN(height, 32);\n\n\t\t \n\t\tsizeimage = bytesperline * height;\n\n\t\t \n\t\tsizeimage += bytesperline * ALIGN(height, 64) / 2;\n\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_NV12:\n\t\t \n\t\tbytesperline = ALIGN(width, 16);\n\n\t\t \n\t\theight = ALIGN(height, 16);\n\n\t\t \n\t\tsizeimage = bytesperline * height;\n\n\t\t \n\t\tsizeimage += bytesperline * height / 2;\n\n\t\tbreak;\n\t}\n\n\tpix_fmt->width = width;\n\tpix_fmt->height = height;\n\n\tpix_fmt->bytesperline = bytesperline;\n\tpix_fmt->sizeimage = sizeimage;\n}\n\nstatic int cedrus_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, CEDRUS_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, CEDRUS_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:%s\", CEDRUS_NAME);\n\n\treturn 0;\n}\n\nstatic int cedrus_enum_fmt(struct file *file, struct v4l2_fmtdesc *f,\n\t\t\t   u32 direction)\n{\n\tstruct cedrus_ctx *ctx = cedrus_file2ctx(file);\n\tunsigned int i, index;\n\n\t \n\tindex = 0;\n\n\tfor (i = 0; i < CEDRUS_FORMATS_COUNT; i++) {\n\t\tif (!cedrus_is_capable(ctx, cedrus_formats[i].capabilities))\n\t\t\tcontinue;\n\n\t\tif (!(cedrus_formats[i].directions & direction))\n\t\t\tcontinue;\n\n\t\tif (index == f->index)\n\t\t\tbreak;\n\n\t\tindex++;\n\t}\n\n\t \n\tif (i < CEDRUS_FORMATS_COUNT) {\n\t\tf->pixelformat = cedrus_formats[i].pixelformat;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int cedrus_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn cedrus_enum_fmt(file, f, CEDRUS_DECODE_DST);\n}\n\nstatic int cedrus_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn cedrus_enum_fmt(file, f, CEDRUS_DECODE_SRC);\n}\n\nstatic int cedrus_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cedrus_ctx *ctx = cedrus_file2ctx(file);\n\n\tf->fmt.pix = ctx->dst_fmt;\n\treturn 0;\n}\n\nstatic int cedrus_g_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cedrus_ctx *ctx = cedrus_file2ctx(file);\n\n\tf->fmt.pix = ctx->src_fmt;\n\treturn 0;\n}\n\nstatic int cedrus_try_fmt_vid_cap_p(struct cedrus_ctx *ctx,\n\t\t\t\t    struct v4l2_pix_format *pix_fmt)\n{\n\tstruct cedrus_format *fmt =\n\t\tcedrus_find_format(ctx, pix_fmt->pixelformat,\n\t\t\t\t   CEDRUS_DECODE_DST);\n\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tpix_fmt->pixelformat = fmt->pixelformat;\n\tpix_fmt->width = ctx->src_fmt.width;\n\tpix_fmt->height = ctx->src_fmt.height;\n\tcedrus_prepare_format(pix_fmt);\n\n\tif (ctx->current_codec->extra_cap_size)\n\t\tpix_fmt->sizeimage +=\n\t\t\tctx->current_codec->extra_cap_size(ctx, pix_fmt);\n\n\treturn 0;\n}\n\nstatic int cedrus_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\treturn cedrus_try_fmt_vid_cap_p(cedrus_file2ctx(file), &f->fmt.pix);\n}\n\nstatic int cedrus_try_fmt_vid_out_p(struct cedrus_ctx *ctx,\n\t\t\t\t    struct v4l2_pix_format *pix_fmt)\n{\n\tstruct cedrus_format *fmt =\n\t\tcedrus_find_format(ctx, pix_fmt->pixelformat,\n\t\t\t\t   CEDRUS_DECODE_SRC);\n\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tpix_fmt->pixelformat = fmt->pixelformat;\n\tcedrus_prepare_format(pix_fmt);\n\n\treturn 0;\n}\n\nstatic int cedrus_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\treturn cedrus_try_fmt_vid_out_p(cedrus_file2ctx(file), &f->fmt.pix);\n}\n\nstatic int cedrus_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cedrus_ctx *ctx = cedrus_file2ctx(file);\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_busy(vq))\n\t\treturn -EBUSY;\n\n\tret = cedrus_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->dst_fmt = f->fmt.pix;\n\n\treturn 0;\n}\n\nvoid cedrus_reset_cap_format(struct cedrus_ctx *ctx)\n{\n\tctx->dst_fmt.pixelformat = 0;\n\tcedrus_try_fmt_vid_cap_p(ctx, &ctx->dst_fmt);\n}\n\nstatic int cedrus_s_fmt_vid_out_p(struct cedrus_ctx *ctx,\n\t\t\t\t  struct v4l2_pix_format *pix_fmt)\n{\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tret = cedrus_try_fmt_vid_out_p(ctx, pix_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->src_fmt = *pix_fmt;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\n\tswitch (ctx->src_fmt.pixelformat) {\n\tcase V4L2_PIX_FMT_H264_SLICE:\n\tcase V4L2_PIX_FMT_HEVC_SLICE:\n\t\tvq->subsystem_flags |=\n\t\t\tVB2_V4L2_FL_SUPPORTS_M2M_HOLD_CAPTURE_BUF;\n\t\tbreak;\n\tdefault:\n\t\tvq->subsystem_flags &=\n\t\t\t~VB2_V4L2_FL_SUPPORTS_M2M_HOLD_CAPTURE_BUF;\n\t\tbreak;\n\t}\n\n\tswitch (ctx->src_fmt.pixelformat) {\n\tcase V4L2_PIX_FMT_MPEG2_SLICE:\n\t\tctx->current_codec = &cedrus_dec_ops_mpeg2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_H264_SLICE:\n\t\tctx->current_codec = &cedrus_dec_ops_h264;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_HEVC_SLICE:\n\t\tctx->current_codec = &cedrus_dec_ops_h265;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VP8_FRAME:\n\t\tctx->current_codec = &cedrus_dec_ops_vp8;\n\t\tbreak;\n\t}\n\n\t \n\tctx->dst_fmt.colorspace = pix_fmt->colorspace;\n\tctx->dst_fmt.xfer_func = pix_fmt->xfer_func;\n\tctx->dst_fmt.ycbcr_enc = pix_fmt->ycbcr_enc;\n\tctx->dst_fmt.quantization = pix_fmt->quantization;\n\tcedrus_reset_cap_format(ctx);\n\n\treturn 0;\n}\n\nvoid cedrus_reset_out_format(struct cedrus_ctx *ctx)\n{\n\tctx->src_fmt.pixelformat = 0;\n\tcedrus_s_fmt_vid_out_p(ctx, &ctx->src_fmt);\n}\n\nstatic int cedrus_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cedrus_ctx *ctx = cedrus_file2ctx(file);\n\tstruct vb2_queue *vq;\n\tstruct vb2_queue *peer_vq;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\t \n\tif (vb2_is_streaming(vq) || (vb2_is_busy(vq) &&\n\t    f->fmt.pix.pixelformat != ctx->src_fmt.pixelformat))\n\t\treturn -EBUSY;\n\t \n\tpeer_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t  V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tif (vb2_is_busy(peer_vq))\n\t\treturn -EBUSY;\n\n\treturn cedrus_s_fmt_vid_out_p(cedrus_file2ctx(file), &f->fmt.pix);\n}\n\nconst struct v4l2_ioctl_ops cedrus_ioctl_ops = {\n\t.vidioc_querycap\t\t= cedrus_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= cedrus_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= cedrus_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= cedrus_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= cedrus_s_fmt_vid_cap,\n\n\t.vidioc_enum_fmt_vid_out\t= cedrus_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out\t\t= cedrus_g_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out\t\t= cedrus_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t\t= cedrus_s_fmt_vid_out,\n\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf\t\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_try_decoder_cmd\t\t= v4l2_m2m_ioctl_stateless_try_decoder_cmd,\n\t.vidioc_decoder_cmd\t\t= v4l2_m2m_ioctl_stateless_decoder_cmd,\n\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nstatic int cedrus_queue_setup(struct vb2_queue *vq, unsigned int *nbufs,\n\t\t\t      unsigned int *nplanes, unsigned int sizes[],\n\t\t\t      struct device *alloc_devs[])\n{\n\tstruct cedrus_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format *pix_fmt;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\tpix_fmt = &ctx->src_fmt;\n\telse\n\t\tpix_fmt = &ctx->dst_fmt;\n\n\tif (*nplanes) {\n\t\tif (sizes[0] < pix_fmt->sizeimage)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tsizes[0] = pix_fmt->sizeimage;\n\t\t*nplanes = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void cedrus_queue_cleanup(struct vb2_queue *vq, u32 state)\n{\n\tstruct cedrus_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tfor (;;) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\t\tif (!vbuf)\n\t\t\treturn;\n\n\t\tv4l2_ctrl_request_complete(vbuf->vb2_buf.req_obj.req,\n\t\t\t\t\t   &ctx->hdl);\n\t\tv4l2_m2m_buf_done(vbuf, state);\n\t}\n}\n\nstatic int cedrus_buf_out_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\treturn 0;\n}\n\nstatic int cedrus_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct cedrus_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format *pix_fmt;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\tpix_fmt = &ctx->src_fmt;\n\telse\n\t\tpix_fmt = &ctx->dst_fmt;\n\n\tif (vb2_plane_size(vb, 0) < pix_fmt->sizeimage)\n\t\treturn -EINVAL;\n\n\t \n\tif (V4L2_TYPE_IS_CAPTURE(vq->type))\n\t\tvb2_set_plane_payload(vb, 0, pix_fmt->sizeimage);\n\n\treturn 0;\n}\n\nstatic int cedrus_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct cedrus_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct cedrus_dev *dev = ctx->dev;\n\tint ret = 0;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\n\t\tret = pm_runtime_resume_and_get(dev->dev);\n\t\tif (ret < 0)\n\t\t\tgoto err_cleanup;\n\n\t\tif (ctx->current_codec->start) {\n\t\t\tret = ctx->current_codec->start(ctx);\n\t\t\tif (ret)\n\t\t\t\tgoto err_pm;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_pm:\n\tpm_runtime_put(dev->dev);\nerr_cleanup:\n\tcedrus_queue_cleanup(vq, VB2_BUF_STATE_QUEUED);\n\n\treturn ret;\n}\n\nstatic void cedrus_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct cedrus_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct cedrus_dev *dev = ctx->dev;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\n\t\tif (ctx->current_codec->stop)\n\t\t\tctx->current_codec->stop(ctx);\n\n\t\tpm_runtime_put(dev->dev);\n\t}\n\n\tcedrus_queue_cleanup(vq, VB2_BUF_STATE_ERROR);\n}\n\nstatic void cedrus_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cedrus_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic void cedrus_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct cedrus_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &ctx->hdl);\n}\n\nstatic const struct vb2_ops cedrus_qops = {\n\t.queue_setup\t\t= cedrus_queue_setup,\n\t.buf_prepare\t\t= cedrus_buf_prepare,\n\t.buf_queue\t\t= cedrus_buf_queue,\n\t.buf_out_validate\t= cedrus_buf_out_validate,\n\t.buf_request_complete\t= cedrus_buf_request_complete,\n\t.start_streaming\t= cedrus_start_streaming,\n\t.stop_streaming\t\t= cedrus_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nint cedrus_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t      struct vb2_queue *dst_vq)\n{\n\tstruct cedrus_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct cedrus_buffer);\n\tsrc_vq->ops = &cedrus_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->dev->dev_mutex;\n\tsrc_vq->dev = ctx->dev->dev;\n\tsrc_vq->supports_requests = true;\n\tsrc_vq->requires_requests = true;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct cedrus_buffer);\n\tdst_vq->ops = &cedrus_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->dev->dev_mutex;\n\tdst_vq->dev = ctx->dev->dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}