{
  "module_name": "cedrus.h",
  "hash_id": "ed769ec564be89c61fd034f3fa0451bf3f5127bc02f3b4bec8943c51d7b3ea03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/sunxi/cedrus/cedrus.h",
  "human_readable_source": " \n \n\n#ifndef _CEDRUS_H_\n#define _CEDRUS_H_\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include <linux/iopoll.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n\n#define CEDRUS_NAME\t\t\t\"cedrus\"\n\n#define CEDRUS_CAPABILITY_UNTILED\tBIT(0)\n#define CEDRUS_CAPABILITY_H265_DEC\tBIT(1)\n#define CEDRUS_CAPABILITY_H264_DEC\tBIT(2)\n#define CEDRUS_CAPABILITY_MPEG2_DEC\tBIT(3)\n#define CEDRUS_CAPABILITY_VP8_DEC\tBIT(4)\n#define CEDRUS_CAPABILITY_H265_10_DEC\tBIT(5)\n\nenum cedrus_irq_status {\n\tCEDRUS_IRQ_NONE,\n\tCEDRUS_IRQ_ERROR,\n\tCEDRUS_IRQ_OK,\n};\n\nenum cedrus_h264_pic_type {\n\tCEDRUS_H264_PIC_TYPE_FRAME\t= 0,\n\tCEDRUS_H264_PIC_TYPE_FIELD,\n\tCEDRUS_H264_PIC_TYPE_MBAFF,\n};\n\nstruct cedrus_control {\n\tstruct v4l2_ctrl_config cfg;\n\tunsigned int\t\tcapabilities;\n};\n\nstruct cedrus_h264_run {\n\tconst struct v4l2_ctrl_h264_decode_params\t*decode_params;\n\tconst struct v4l2_ctrl_h264_pps\t\t\t*pps;\n\tconst struct v4l2_ctrl_h264_scaling_matrix\t*scaling_matrix;\n\tconst struct v4l2_ctrl_h264_slice_params\t*slice_params;\n\tconst struct v4l2_ctrl_h264_sps\t\t\t*sps;\n\tconst struct v4l2_ctrl_h264_pred_weights\t*pred_weights;\n};\n\nstruct cedrus_mpeg2_run {\n\tconst struct v4l2_ctrl_mpeg2_sequence\t\t*sequence;\n\tconst struct v4l2_ctrl_mpeg2_picture\t\t*picture;\n\tconst struct v4l2_ctrl_mpeg2_quantisation\t*quantisation;\n};\n\nstruct cedrus_h265_run {\n\tconst struct v4l2_ctrl_hevc_sps\t\t\t*sps;\n\tconst struct v4l2_ctrl_hevc_pps\t\t\t*pps;\n\tconst struct v4l2_ctrl_hevc_slice_params\t*slice_params;\n\tconst struct v4l2_ctrl_hevc_decode_params\t*decode_params;\n\tconst struct v4l2_ctrl_hevc_scaling_matrix\t*scaling_matrix;\n\tconst u32\t\t\t\t\t*entry_points;\n\tu32\t\t\t\t\t\tentry_points_count;\n};\n\nstruct cedrus_vp8_run {\n\tconst struct v4l2_ctrl_vp8_frame\t\t*frame_params;\n};\n\nstruct cedrus_run {\n\tstruct vb2_v4l2_buffer\t*src;\n\tstruct vb2_v4l2_buffer\t*dst;\n\n\tunion {\n\t\tstruct cedrus_h264_run\th264;\n\t\tstruct cedrus_mpeg2_run\tmpeg2;\n\t\tstruct cedrus_h265_run\th265;\n\t\tstruct cedrus_vp8_run\tvp8;\n\t};\n};\n\nstruct cedrus_buffer {\n\tstruct v4l2_m2m_buffer          m2m_buf;\n\n\tunion {\n\t\tstruct {\n\t\t\tunsigned int\t\t\tposition;\n\t\t\tenum cedrus_h264_pic_type\tpic_type;\n\t\t\tvoid\t\t\t\t*mv_col_buf;\n\t\t\tdma_addr_t\t\t\tmv_col_buf_dma;\n\t\t\tssize_t\t\t\t\tmv_col_buf_size;\n\t\t} h264;\n\t\tstruct {\n\t\t\tvoid\t\t*mv_col_buf;\n\t\t\tdma_addr_t\tmv_col_buf_dma;\n\t\t\tssize_t\t\tmv_col_buf_size;\n\t\t} h265;\n\t} codec;\n};\n\nstruct cedrus_ctx {\n\tstruct v4l2_fh\t\t\tfh;\n\tstruct cedrus_dev\t\t*dev;\n\n\tstruct v4l2_pix_format\t\tsrc_fmt;\n\tstruct v4l2_pix_format\t\tdst_fmt;\n\tstruct cedrus_dec_ops\t\t*current_codec;\n\tunsigned int\t\t\tbit_depth;\n\n\tstruct v4l2_ctrl_handler\thdl;\n\tstruct v4l2_ctrl\t\t**ctrls;\n\n\tunion {\n\t\tstruct {\n\t\t\tvoid\t\t*pic_info_buf;\n\t\t\tdma_addr_t\tpic_info_buf_dma;\n\t\t\tssize_t\t\tpic_info_buf_size;\n\t\t\tvoid\t\t*neighbor_info_buf;\n\t\t\tdma_addr_t\tneighbor_info_buf_dma;\n\t\t\tvoid\t\t*deblk_buf;\n\t\t\tdma_addr_t\tdeblk_buf_dma;\n\t\t\tssize_t\t\tdeblk_buf_size;\n\t\t\tvoid\t\t*intra_pred_buf;\n\t\t\tdma_addr_t\tintra_pred_buf_dma;\n\t\t\tssize_t\t\tintra_pred_buf_size;\n\t\t} h264;\n\t\tstruct {\n\t\t\tvoid\t\t*neighbor_info_buf;\n\t\t\tdma_addr_t\tneighbor_info_buf_addr;\n\t\t\tvoid\t\t*entry_points_buf;\n\t\t\tdma_addr_t\tentry_points_buf_addr;\n\t\t} h265;\n\t\tstruct {\n\t\t\tunsigned int\tlast_frame_p_type;\n\t\t\tunsigned int\tlast_filter_type;\n\t\t\tunsigned int\tlast_sharpness_level;\n\n\t\t\tu8\t\t*entropy_probs_buf;\n\t\t\tdma_addr_t\tentropy_probs_buf_dma;\n\t\t} vp8;\n\t} codec;\n};\n\nstruct cedrus_dec_ops {\n\tvoid (*irq_clear)(struct cedrus_ctx *ctx);\n\tvoid (*irq_disable)(struct cedrus_ctx *ctx);\n\tenum cedrus_irq_status (*irq_status)(struct cedrus_ctx *ctx);\n\tint (*setup)(struct cedrus_ctx *ctx, struct cedrus_run *run);\n\tint (*start)(struct cedrus_ctx *ctx);\n\tvoid (*stop)(struct cedrus_ctx *ctx);\n\tvoid (*trigger)(struct cedrus_ctx *ctx);\n\tunsigned int (*extra_cap_size)(struct cedrus_ctx *ctx,\n\t\t\t\t       struct v4l2_pix_format *pix_fmt);\n};\n\nstruct cedrus_variant {\n\tunsigned int\tcapabilities;\n\tunsigned int\tmod_rate;\n};\n\nstruct cedrus_dev {\n\tstruct v4l2_device\tv4l2_dev;\n\tstruct video_device\tvfd;\n\tstruct media_device\tmdev;\n\tstruct media_pad\tpad[2];\n\tstruct platform_device\t*pdev;\n\tstruct device\t\t*dev;\n\tstruct v4l2_m2m_dev\t*m2m_dev;\n\n\t \n\tstruct mutex\t\tdev_mutex;\n\n\tvoid __iomem\t\t*base;\n\n\tstruct clk\t\t*mod_clk;\n\tstruct clk\t\t*ahb_clk;\n\tstruct clk\t\t*ram_clk;\n\n\tstruct reset_control\t*rstc;\n\n\tunsigned int\t\tcapabilities;\n\n\tstruct delayed_work\twatchdog_work;\n};\n\nextern struct cedrus_dec_ops cedrus_dec_ops_mpeg2;\nextern struct cedrus_dec_ops cedrus_dec_ops_h264;\nextern struct cedrus_dec_ops cedrus_dec_ops_h265;\nextern struct cedrus_dec_ops cedrus_dec_ops_vp8;\n\nstatic inline void cedrus_write(struct cedrus_dev *dev, u32 reg, u32 val)\n{\n\twritel(val, dev->base + reg);\n}\n\nstatic inline u32 cedrus_read(struct cedrus_dev *dev, u32 reg)\n{\n\treturn readl(dev->base + reg);\n}\n\nstatic inline u32 cedrus_wait_for(struct cedrus_dev *dev, u32 reg, u32 flag)\n{\n\tu32 value;\n\n\treturn readl_poll_timeout_atomic(dev->base + reg, value,\n\t\t\t(value & flag) == 0, 10, 1000);\n}\n\nstatic inline dma_addr_t cedrus_buf_addr(struct vb2_buffer *buf,\n\t\t\t\t\t struct v4l2_pix_format *pix_fmt,\n\t\t\t\t\t unsigned int plane)\n{\n\tdma_addr_t addr = vb2_dma_contig_plane_dma_addr(buf, 0);\n\n\treturn addr + (pix_fmt ? (dma_addr_t)pix_fmt->bytesperline *\n\t       pix_fmt->height * plane : 0);\n}\n\nstatic inline dma_addr_t cedrus_dst_buf_addr(struct cedrus_ctx *ctx,\n\t\t\t\t\t     struct vb2_buffer *buf,\n\t\t\t\t\t     unsigned int plane)\n{\n\treturn buf ? cedrus_buf_addr(buf, &ctx->dst_fmt, plane) : 0;\n}\n\nstatic inline void cedrus_write_ref_buf_addr(struct cedrus_ctx *ctx,\n\t\t\t\t\t     struct vb2_queue *q,\n\t\t\t\t\t     u64 timestamp,\n\t\t\t\t\t     u32 luma_reg,\n\t\t\t\t\t     u32 chroma_reg)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\tstruct vb2_buffer *buf = vb2_find_buffer(q, timestamp);\n\n\tcedrus_write(dev, luma_reg, cedrus_dst_buf_addr(ctx, buf, 0));\n\tcedrus_write(dev, chroma_reg, cedrus_dst_buf_addr(ctx, buf, 1));\n}\n\nstatic inline struct cedrus_buffer *\nvb2_v4l2_to_cedrus_buffer(const struct vb2_v4l2_buffer *p)\n{\n\treturn container_of(p, struct cedrus_buffer, m2m_buf.vb);\n}\n\nstatic inline struct cedrus_buffer *\nvb2_to_cedrus_buffer(const struct vb2_buffer *p)\n{\n\treturn vb2_v4l2_to_cedrus_buffer(to_vb2_v4l2_buffer(p));\n}\n\nstatic inline bool\ncedrus_is_capable(struct cedrus_ctx *ctx, unsigned int capabilities)\n{\n\treturn (ctx->dev->capabilities & capabilities) == capabilities;\n}\n\nvoid *cedrus_find_control_data(struct cedrus_ctx *ctx, u32 id);\nu32 cedrus_get_num_of_controls(struct cedrus_ctx *ctx, u32 id);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}