{
  "module_name": "cedrus_h265.c",
  "hash_id": "ca6f197d1340f659dbb4c92de8ace49150c331bfcd19abc2c5d795609496f5f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/sunxi/cedrus/cedrus_h265.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/types.h>\n\n#include <media/videobuf2-dma-contig.h>\n\n#include \"cedrus.h\"\n#include \"cedrus_hw.h\"\n#include \"cedrus_regs.h\"\n\n \n#define CEDRUS_H265_NEIGHBOR_INFO_BUF_SIZE\t(794 * SZ_1K)\n#define CEDRUS_H265_ENTRY_POINTS_BUF_SIZE\t(4 * SZ_1K)\n#define CEDRUS_H265_MV_COL_BUF_UNIT_CTB_SIZE\t160\n\nstruct cedrus_h265_sram_frame_info {\n\t__le32\ttop_pic_order_cnt;\n\t__le32\tbottom_pic_order_cnt;\n\t__le32\ttop_mv_col_buf_addr;\n\t__le32\tbottom_mv_col_buf_addr;\n\t__le32\tluma_addr;\n\t__le32\tchroma_addr;\n} __packed;\n\nstruct cedrus_h265_sram_pred_weight {\n\t__s8\tdelta_weight;\n\t__s8\toffset;\n} __packed;\n\nstatic unsigned int cedrus_h265_2bit_size(unsigned int width,\n\t\t\t\t\t  unsigned int height)\n{\n\t \n\treturn ALIGN(width / 4, 32) * height * 3 / 2;\n}\n\nstatic enum cedrus_irq_status cedrus_h265_irq_status(struct cedrus_ctx *ctx)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\tu32 reg;\n\n\treg = cedrus_read(dev, VE_DEC_H265_STATUS);\n\treg &= VE_DEC_H265_STATUS_CHECK_MASK;\n\n\tif (reg & VE_DEC_H265_STATUS_CHECK_ERROR ||\n\t    !(reg & VE_DEC_H265_STATUS_SUCCESS))\n\t\treturn CEDRUS_IRQ_ERROR;\n\n\treturn CEDRUS_IRQ_OK;\n}\n\nstatic void cedrus_h265_irq_clear(struct cedrus_ctx *ctx)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\n\tcedrus_write(dev, VE_DEC_H265_STATUS, VE_DEC_H265_STATUS_CHECK_MASK);\n}\n\nstatic void cedrus_h265_irq_disable(struct cedrus_ctx *ctx)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\tu32 reg = cedrus_read(dev, VE_DEC_H265_CTRL);\n\n\treg &= ~VE_DEC_H265_CTRL_IRQ_MASK;\n\n\tcedrus_write(dev, VE_DEC_H265_CTRL, reg);\n}\n\nstatic void cedrus_h265_sram_write_offset(struct cedrus_dev *dev, u32 offset)\n{\n\tcedrus_write(dev, VE_DEC_H265_SRAM_OFFSET, offset);\n}\n\nstatic void cedrus_h265_sram_write_data(struct cedrus_dev *dev, void *data,\n\t\t\t\t\tunsigned int size)\n{\n\tu32 *word = data;\n\n\twhile (size >= sizeof(u32)) {\n\t\tcedrus_write(dev, VE_DEC_H265_SRAM_DATA, *word++);\n\t\tsize -= sizeof(u32);\n\t}\n}\n\nstatic inline dma_addr_t\ncedrus_h265_frame_info_mv_col_buf_addr(struct vb2_buffer *buf,\n\t\t\t\t       unsigned int field)\n{\n\tstruct cedrus_buffer *cedrus_buf = vb2_to_cedrus_buffer(buf);\n\n\treturn cedrus_buf->codec.h265.mv_col_buf_dma +\n\t       field * cedrus_buf->codec.h265.mv_col_buf_size / 2;\n}\n\nstatic void cedrus_h265_frame_info_write_single(struct cedrus_ctx *ctx,\n\t\t\t\t\t\tunsigned int index,\n\t\t\t\t\t\tbool field_pic,\n\t\t\t\t\t\tu32 pic_order_cnt[],\n\t\t\t\t\t\tstruct vb2_buffer *buf)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\tdma_addr_t dst_luma_addr = cedrus_dst_buf_addr(ctx, buf, 0);\n\tdma_addr_t dst_chroma_addr = cedrus_dst_buf_addr(ctx, buf, 1);\n\tdma_addr_t mv_col_buf_addr[2] = {\n\t\tcedrus_h265_frame_info_mv_col_buf_addr(buf, 0),\n\t\tcedrus_h265_frame_info_mv_col_buf_addr(buf, field_pic ? 1 : 0)\n\t};\n\tu32 offset = VE_DEC_H265_SRAM_OFFSET_FRAME_INFO +\n\t\t     VE_DEC_H265_SRAM_OFFSET_FRAME_INFO_UNIT * index;\n\tstruct cedrus_h265_sram_frame_info frame_info = {\n\t\t.top_pic_order_cnt = cpu_to_le32(pic_order_cnt[0]),\n\t\t.bottom_pic_order_cnt = cpu_to_le32(field_pic ?\n\t\t\t\t\t\t    pic_order_cnt[1] :\n\t\t\t\t\t\t    pic_order_cnt[0]),\n\t\t.top_mv_col_buf_addr =\n\t\t\tcpu_to_le32(VE_DEC_H265_SRAM_DATA_ADDR_BASE(mv_col_buf_addr[0])),\n\t\t.bottom_mv_col_buf_addr = cpu_to_le32(field_pic ?\n\t\t\tVE_DEC_H265_SRAM_DATA_ADDR_BASE(mv_col_buf_addr[1]) :\n\t\t\tVE_DEC_H265_SRAM_DATA_ADDR_BASE(mv_col_buf_addr[0])),\n\t\t.luma_addr = cpu_to_le32(VE_DEC_H265_SRAM_DATA_ADDR_BASE(dst_luma_addr)),\n\t\t.chroma_addr = cpu_to_le32(VE_DEC_H265_SRAM_DATA_ADDR_BASE(dst_chroma_addr)),\n\t};\n\n\tcedrus_h265_sram_write_offset(dev, offset);\n\tcedrus_h265_sram_write_data(dev, &frame_info, sizeof(frame_info));\n}\n\nstatic void cedrus_h265_frame_info_write_dpb(struct cedrus_ctx *ctx,\n\t\t\t\t\t     const struct v4l2_hevc_dpb_entry *dpb,\n\t\t\t\t\t     u8 num_active_dpb_entries)\n{\n\tstruct vb2_queue *vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t\t       V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tunsigned int i;\n\n\tfor (i = 0; i < num_active_dpb_entries; i++) {\n\t\tstruct vb2_buffer *buf = vb2_find_buffer(vq, dpb[i].timestamp);\n\t\tu32 pic_order_cnt[2] = {\n\t\t\tdpb[i].pic_order_cnt_val,\n\t\t\tdpb[i].pic_order_cnt_val\n\t\t};\n\n\t\tif (!buf)\n\t\t\tcontinue;\n\n\t\tcedrus_h265_frame_info_write_single(ctx, i, dpb[i].field_pic,\n\t\t\t\t\t\t    pic_order_cnt,\n\t\t\t\t\t\t    buf);\n\t}\n}\n\nstatic void cedrus_h265_ref_pic_list_write(struct cedrus_dev *dev,\n\t\t\t\t\t   const struct v4l2_hevc_dpb_entry *dpb,\n\t\t\t\t\t   const u8 list[],\n\t\t\t\t\t   u8 num_ref_idx_active,\n\t\t\t\t\t   u32 sram_offset)\n{\n\tunsigned int i;\n\tu32 word = 0;\n\n\tcedrus_h265_sram_write_offset(dev, sram_offset);\n\n\tfor (i = 0; i < num_ref_idx_active; i++) {\n\t\tunsigned int shift = (i % 4) * 8;\n\t\tunsigned int index = list[i];\n\t\tu8 value = list[i];\n\n\t\tif (dpb[index].flags & V4L2_HEVC_DPB_ENTRY_LONG_TERM_REFERENCE)\n\t\t\tvalue |= VE_DEC_H265_SRAM_REF_PIC_LIST_LT_REF;\n\n\t\t \n\t\tword |= value << shift;\n\n\t\t \n\t\tif ((i % 4) == 3 || i == (num_ref_idx_active - 1)) {\n\t\t\tcedrus_h265_sram_write_data(dev, &word, sizeof(word));\n\t\t\tword = 0;\n\t\t}\n\t}\n}\n\nstatic void cedrus_h265_pred_weight_write(struct cedrus_dev *dev,\n\t\t\t\t\t  const s8 delta_luma_weight[],\n\t\t\t\t\t  const s8 luma_offset[],\n\t\t\t\t\t  const s8 delta_chroma_weight[][2],\n\t\t\t\t\t  const s8 chroma_offset[][2],\n\t\t\t\t\t  u8 num_ref_idx_active,\n\t\t\t\t\t  u32 sram_luma_offset,\n\t\t\t\t\t  u32 sram_chroma_offset)\n{\n\tstruct cedrus_h265_sram_pred_weight pred_weight[2] = { { 0 } };\n\tunsigned int i, j;\n\n\tcedrus_h265_sram_write_offset(dev, sram_luma_offset);\n\n\tfor (i = 0; i < num_ref_idx_active; i++) {\n\t\tunsigned int index = i % 2;\n\n\t\tpred_weight[index].delta_weight = delta_luma_weight[i];\n\t\tpred_weight[index].offset = luma_offset[i];\n\n\t\tif (index == 1 || i == (num_ref_idx_active - 1))\n\t\t\tcedrus_h265_sram_write_data(dev, (u32 *)&pred_weight,\n\t\t\t\t\t\t    sizeof(pred_weight));\n\t}\n\n\tcedrus_h265_sram_write_offset(dev, sram_chroma_offset);\n\n\tfor (i = 0; i < num_ref_idx_active; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tpred_weight[j].delta_weight = delta_chroma_weight[i][j];\n\t\t\tpred_weight[j].offset = chroma_offset[i][j];\n\t\t}\n\n\t\tcedrus_h265_sram_write_data(dev, &pred_weight,\n\t\t\t\t\t    sizeof(pred_weight));\n\t}\n}\n\nstatic void cedrus_h265_skip_bits(struct cedrus_dev *dev, int num)\n{\n\tint count = 0;\n\n\twhile (count < num) {\n\t\tint tmp = min(num - count, 32);\n\n\t\tcedrus_write(dev, VE_DEC_H265_TRIGGER,\n\t\t\t     VE_DEC_H265_TRIGGER_FLUSH_BITS |\n\t\t\t     VE_DEC_H265_TRIGGER_TYPE_N_BITS(tmp));\n\n\t\tif (cedrus_wait_for(dev, VE_DEC_H265_STATUS, VE_DEC_H265_STATUS_VLD_BUSY))\n\t\t\tdev_err_ratelimited(dev->dev, \"timed out waiting to skip bits\\n\");\n\n\t\tcount += tmp;\n\t}\n}\n\nstatic u32 cedrus_h265_show_bits(struct cedrus_dev *dev, int num)\n{\n\tcedrus_write(dev, VE_DEC_H265_TRIGGER,\n\t\t     VE_DEC_H265_TRIGGER_SHOW_BITS |\n\t\t     VE_DEC_H265_TRIGGER_TYPE_N_BITS(num));\n\n\tcedrus_wait_for(dev, VE_DEC_H265_STATUS,\n\t\t\tVE_DEC_H265_STATUS_VLD_BUSY);\n\n\treturn cedrus_read(dev, VE_DEC_H265_BITS_READ);\n}\n\nstatic void cedrus_h265_write_scaling_list(struct cedrus_ctx *ctx,\n\t\t\t\t\t   struct cedrus_run *run)\n{\n\tconst struct v4l2_ctrl_hevc_scaling_matrix *scaling;\n\tstruct cedrus_dev *dev = ctx->dev;\n\tu32 i, j, k, val;\n\n\tscaling = run->h265.scaling_matrix;\n\n\tcedrus_write(dev, VE_DEC_H265_SCALING_LIST_DC_COEF0,\n\t\t     (scaling->scaling_list_dc_coef_32x32[1] << 24) |\n\t\t     (scaling->scaling_list_dc_coef_32x32[0] << 16) |\n\t\t     (scaling->scaling_list_dc_coef_16x16[1] << 8) |\n\t\t     (scaling->scaling_list_dc_coef_16x16[0] << 0));\n\n\tcedrus_write(dev, VE_DEC_H265_SCALING_LIST_DC_COEF1,\n\t\t     (scaling->scaling_list_dc_coef_16x16[5] << 24) |\n\t\t     (scaling->scaling_list_dc_coef_16x16[4] << 16) |\n\t\t     (scaling->scaling_list_dc_coef_16x16[3] << 8) |\n\t\t     (scaling->scaling_list_dc_coef_16x16[2] << 0));\n\n\tcedrus_h265_sram_write_offset(dev, VE_DEC_H265_SRAM_OFFSET_SCALING_LISTS);\n\n\tfor (i = 0; i < 6; i++)\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tfor (k = 0; k < 8; k += 4) {\n\t\t\t\tval = ((u32)scaling->scaling_list_8x8[i][j + (k + 3) * 8] << 24) |\n\t\t\t\t      ((u32)scaling->scaling_list_8x8[i][j + (k + 2) * 8] << 16) |\n\t\t\t\t      ((u32)scaling->scaling_list_8x8[i][j + (k + 1) * 8] << 8) |\n\t\t\t\t      scaling->scaling_list_8x8[i][j + k * 8];\n\t\t\t\tcedrus_write(dev, VE_DEC_H265_SRAM_DATA, val);\n\t\t\t}\n\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tfor (k = 0; k < 8; k += 4) {\n\t\t\t\tval = ((u32)scaling->scaling_list_32x32[i][j + (k + 3) * 8] << 24) |\n\t\t\t\t      ((u32)scaling->scaling_list_32x32[i][j + (k + 2) * 8] << 16) |\n\t\t\t\t      ((u32)scaling->scaling_list_32x32[i][j + (k + 1) * 8] << 8) |\n\t\t\t\t      scaling->scaling_list_32x32[i][j + k * 8];\n\t\t\t\tcedrus_write(dev, VE_DEC_H265_SRAM_DATA, val);\n\t\t\t}\n\n\tfor (i = 0; i < 6; i++)\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tfor (k = 0; k < 8; k += 4) {\n\t\t\t\tval = ((u32)scaling->scaling_list_16x16[i][j + (k + 3) * 8] << 24) |\n\t\t\t\t      ((u32)scaling->scaling_list_16x16[i][j + (k + 2) * 8] << 16) |\n\t\t\t\t      ((u32)scaling->scaling_list_16x16[i][j + (k + 1) * 8] << 8) |\n\t\t\t\t      scaling->scaling_list_16x16[i][j + k * 8];\n\t\t\t\tcedrus_write(dev, VE_DEC_H265_SRAM_DATA, val);\n\t\t\t}\n\n\tfor (i = 0; i < 6; i++)\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tval = ((u32)scaling->scaling_list_4x4[i][j + 12] << 24) |\n\t\t\t      ((u32)scaling->scaling_list_4x4[i][j + 8] << 16) |\n\t\t\t      ((u32)scaling->scaling_list_4x4[i][j + 4] << 8) |\n\t\t\t      scaling->scaling_list_4x4[i][j];\n\t\t\tcedrus_write(dev, VE_DEC_H265_SRAM_DATA, val);\n\t\t}\n}\n\nstatic int cedrus_h265_is_low_delay(struct cedrus_run *run)\n{\n\tconst struct v4l2_ctrl_hevc_slice_params *slice_params;\n\tconst struct v4l2_hevc_dpb_entry *dpb;\n\ts32 poc;\n\tint i;\n\n\tslice_params = run->h265.slice_params;\n\tpoc = run->h265.decode_params->pic_order_cnt_val;\n\tdpb = run->h265.decode_params->dpb;\n\n\tfor (i = 0; i < slice_params->num_ref_idx_l0_active_minus1 + 1; i++)\n\t\tif (dpb[slice_params->ref_idx_l0[i]].pic_order_cnt_val > poc)\n\t\t\treturn 1;\n\n\tif (slice_params->slice_type != V4L2_HEVC_SLICE_TYPE_B)\n\t\treturn 0;\n\n\tfor (i = 0; i < slice_params->num_ref_idx_l1_active_minus1 + 1; i++)\n\t\tif (dpb[slice_params->ref_idx_l1[i]].pic_order_cnt_val > poc)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void cedrus_h265_write_tiles(struct cedrus_ctx *ctx,\n\t\t\t\t    struct cedrus_run *run,\n\t\t\t\t    unsigned int ctb_addr_x,\n\t\t\t\t    unsigned int ctb_addr_y)\n{\n\tconst struct v4l2_ctrl_hevc_slice_params *slice_params;\n\tconst struct v4l2_ctrl_hevc_pps *pps;\n\tstruct cedrus_dev *dev = ctx->dev;\n\tconst u32 *entry_points;\n\tu32 *entry_points_buf;\n\tint i, x, tx, y, ty;\n\n\tpps = run->h265.pps;\n\tslice_params = run->h265.slice_params;\n\tentry_points = run->h265.entry_points;\n\tentry_points_buf = ctx->codec.h265.entry_points_buf;\n\n\tfor (x = 0, tx = 0; tx < pps->num_tile_columns_minus1 + 1; tx++) {\n\t\tif (x + pps->column_width_minus1[tx] + 1 > ctb_addr_x)\n\t\t\tbreak;\n\n\t\tx += pps->column_width_minus1[tx] + 1;\n\t}\n\n\tfor (y = 0, ty = 0; ty < pps->num_tile_rows_minus1 + 1; ty++) {\n\t\tif (y + pps->row_height_minus1[ty] + 1 > ctb_addr_y)\n\t\t\tbreak;\n\n\t\ty += pps->row_height_minus1[ty] + 1;\n\t}\n\n\tcedrus_write(dev, VE_DEC_H265_TILE_START_CTB, (y << 16) | (x << 0));\n\tcedrus_write(dev, VE_DEC_H265_TILE_END_CTB,\n\t\t     ((y + pps->row_height_minus1[ty]) << 16) |\n\t\t     ((x + pps->column_width_minus1[tx]) << 0));\n\n\tif (pps->flags & V4L2_HEVC_PPS_FLAG_ENTROPY_CODING_SYNC_ENABLED) {\n\t\tfor (i = 0; i < slice_params->num_entry_point_offsets; i++)\n\t\t\tentry_points_buf[i] = entry_points[i];\n\t} else {\n\t\tfor (i = 0; i < slice_params->num_entry_point_offsets; i++) {\n\t\t\tif (tx + 1 >= pps->num_tile_columns_minus1 + 1) {\n\t\t\t\tx = 0;\n\t\t\t\ttx = 0;\n\t\t\t\ty += pps->row_height_minus1[ty++] + 1;\n\t\t\t} else {\n\t\t\t\tx += pps->column_width_minus1[tx++] + 1;\n\t\t\t}\n\n\t\t\tentry_points_buf[i * 4 + 0] = entry_points[i];\n\t\t\tentry_points_buf[i * 4 + 1] = 0x0;\n\t\t\tentry_points_buf[i * 4 + 2] = (y << 16) | (x << 0);\n\t\t\tentry_points_buf[i * 4 + 3] =\n\t\t\t\t((y + pps->row_height_minus1[ty]) << 16) |\n\t\t\t\t((x + pps->column_width_minus1[tx]) << 0);\n\t\t}\n\t}\n}\n\nstatic int cedrus_h265_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\tconst struct v4l2_ctrl_hevc_sps *sps;\n\tconst struct v4l2_ctrl_hevc_pps *pps;\n\tconst struct v4l2_ctrl_hevc_slice_params *slice_params;\n\tconst struct v4l2_ctrl_hevc_decode_params *decode_params;\n\tconst struct v4l2_hevc_pred_weight_table *pred_weight_table;\n\tunsigned int width_in_ctb_luma, ctb_size_luma;\n\tunsigned int log2_max_luma_coding_block_size;\n\tunsigned int ctb_addr_x, ctb_addr_y;\n\tstruct cedrus_buffer *cedrus_buf;\n\tdma_addr_t src_buf_addr;\n\tdma_addr_t src_buf_end_addr;\n\tu32 chroma_log2_weight_denom;\n\tu32 num_entry_point_offsets;\n\tu32 output_pic_list_index;\n\tu32 pic_order_cnt[2];\n\tu8 padding;\n\tint count;\n\tu32 reg;\n\n\tsps = run->h265.sps;\n\tpps = run->h265.pps;\n\tslice_params = run->h265.slice_params;\n\tdecode_params = run->h265.decode_params;\n\tpred_weight_table = &slice_params->pred_weight_table;\n\tnum_entry_point_offsets = slice_params->num_entry_point_offsets;\n\tcedrus_buf = vb2_to_cedrus_buffer(&run->dst->vb2_buf);\n\n\t \n\tif (num_entry_point_offsets &&\n\t    num_entry_point_offsets != run->h265.entry_points_count)\n\t\treturn -ERANGE;\n\n\tlog2_max_luma_coding_block_size =\n\t\tsps->log2_min_luma_coding_block_size_minus3 + 3 +\n\t\tsps->log2_diff_max_min_luma_coding_block_size;\n\tctb_size_luma = 1UL << log2_max_luma_coding_block_size;\n\twidth_in_ctb_luma =\n\t\tDIV_ROUND_UP(sps->pic_width_in_luma_samples, ctb_size_luma);\n\n\t \n\tif (!cedrus_buf->codec.h265.mv_col_buf_size) {\n\t\t \n\t\tcedrus_buf->codec.h265.mv_col_buf_size =\n\t\t\tDIV_ROUND_UP(ctx->src_fmt.width, ctb_size_luma) *\n\t\t\tDIV_ROUND_UP(ctx->src_fmt.height, ctb_size_luma) *\n\t\t\tCEDRUS_H265_MV_COL_BUF_UNIT_CTB_SIZE + SZ_1K;\n\n\t\t \n\t\tcedrus_buf->codec.h265.mv_col_buf =\n\t\t\tdma_alloc_attrs(dev->dev,\n\t\t\t\t\tcedrus_buf->codec.h265.mv_col_buf_size,\n\t\t\t\t\t&cedrus_buf->codec.h265.mv_col_buf_dma,\n\t\t\t\t\tGFP_KERNEL, DMA_ATTR_NO_KERNEL_MAPPING);\n\t\tif (!cedrus_buf->codec.h265.mv_col_buf) {\n\t\t\tcedrus_buf->codec.h265.mv_col_buf_size = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tcedrus_engine_enable(ctx);\n\n\t \n\n\tcedrus_write(dev, VE_DEC_H265_BITS_OFFSET, 0);\n\n\treg = slice_params->bit_size;\n\tcedrus_write(dev, VE_DEC_H265_BITS_LEN, reg);\n\n\t \n\n\tsrc_buf_addr = vb2_dma_contig_plane_dma_addr(&run->src->vb2_buf, 0);\n\n\treg = VE_DEC_H265_BITS_ADDR_BASE(src_buf_addr);\n\treg |= VE_DEC_H265_BITS_ADDR_VALID_SLICE_DATA;\n\treg |= VE_DEC_H265_BITS_ADDR_LAST_SLICE_DATA;\n\treg |= VE_DEC_H265_BITS_ADDR_FIRST_SLICE_DATA;\n\n\tcedrus_write(dev, VE_DEC_H265_BITS_ADDR, reg);\n\n\tsrc_buf_end_addr = src_buf_addr +\n\t\t\t   DIV_ROUND_UP(slice_params->bit_size, 8);\n\n\treg = VE_DEC_H265_BITS_END_ADDR_BASE(src_buf_end_addr);\n\tcedrus_write(dev, VE_DEC_H265_BITS_END_ADDR, reg);\n\n\t \n\tctb_addr_x = slice_params->slice_segment_addr % width_in_ctb_luma;\n\tctb_addr_y = slice_params->slice_segment_addr / width_in_ctb_luma;\n\treg = VE_DEC_H265_DEC_CTB_ADDR_X(ctb_addr_x);\n\treg |= VE_DEC_H265_DEC_CTB_ADDR_Y(ctb_addr_y);\n\tcedrus_write(dev, VE_DEC_H265_DEC_CTB_ADDR, reg);\n\n\tif ((pps->flags & V4L2_HEVC_PPS_FLAG_TILES_ENABLED) ||\n\t    (pps->flags & V4L2_HEVC_PPS_FLAG_ENTROPY_CODING_SYNC_ENABLED)) {\n\t\tcedrus_h265_write_tiles(ctx, run, ctb_addr_x, ctb_addr_y);\n\t} else {\n\t\tcedrus_write(dev, VE_DEC_H265_TILE_START_CTB, 0);\n\t\tcedrus_write(dev, VE_DEC_H265_TILE_END_CTB, 0);\n\t}\n\n\t \n\tif (ctx->fh.m2m_ctx->new_frame)\n\t\tcedrus_write(dev, VE_DEC_H265_DEC_CTB_NUM, 0);\n\n\t \n\tcedrus_write(dev, VE_DEC_H265_TRIGGER, VE_DEC_H265_TRIGGER_INIT_SWDEC);\n\n\t \n\n\tif (slice_params->data_byte_offset == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tcedrus_h265_skip_bits(dev, (slice_params->data_byte_offset - 1) * 8);\n\n\tpadding = cedrus_h265_show_bits(dev, 8);\n\n\t \n\tif (padding == 0)\n\t\treturn -EINVAL;\n\n\tfor (count = 0; count < 8; count++)\n\t\tif (padding & (1 << count))\n\t\t\tbreak;\n\n\t \n\tcount++;\n\n\tcedrus_h265_skip_bits(dev, 8 - count);\n\n\t \n\n\treg = VE_DEC_H265_DEC_NAL_HDR_NAL_UNIT_TYPE(slice_params->nal_unit_type) |\n\t      VE_DEC_H265_DEC_NAL_HDR_NUH_TEMPORAL_ID_PLUS1(slice_params->nuh_temporal_id_plus1);\n\n\tcedrus_write(dev, VE_DEC_H265_DEC_NAL_HDR, reg);\n\n\t \n\n\treg = VE_DEC_H265_DEC_SPS_HDR_MAX_TRANSFORM_HIERARCHY_DEPTH_INTRA(sps->max_transform_hierarchy_depth_intra) |\n\t      VE_DEC_H265_DEC_SPS_HDR_MAX_TRANSFORM_HIERARCHY_DEPTH_INTER(sps->max_transform_hierarchy_depth_inter) |\n\t      VE_DEC_H265_DEC_SPS_HDR_LOG2_DIFF_MAX_MIN_TRANSFORM_BLOCK_SIZE(sps->log2_diff_max_min_luma_transform_block_size) |\n\t      VE_DEC_H265_DEC_SPS_HDR_LOG2_MIN_TRANSFORM_BLOCK_SIZE_MINUS2(sps->log2_min_luma_transform_block_size_minus2) |\n\t      VE_DEC_H265_DEC_SPS_HDR_LOG2_DIFF_MAX_MIN_LUMA_CODING_BLOCK_SIZE(sps->log2_diff_max_min_luma_coding_block_size) |\n\t      VE_DEC_H265_DEC_SPS_HDR_LOG2_MIN_LUMA_CODING_BLOCK_SIZE_MINUS3(sps->log2_min_luma_coding_block_size_minus3) |\n\t      VE_DEC_H265_DEC_SPS_HDR_BIT_DEPTH_CHROMA_MINUS8(sps->bit_depth_chroma_minus8) |\n\t      VE_DEC_H265_DEC_SPS_HDR_BIT_DEPTH_LUMA_MINUS8(sps->bit_depth_luma_minus8) |\n\t      VE_DEC_H265_DEC_SPS_HDR_CHROMA_FORMAT_IDC(sps->chroma_format_idc);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SPS_HDR_FLAG_STRONG_INTRA_SMOOTHING_ENABLE,\n\t\t\t\tV4L2_HEVC_SPS_FLAG_STRONG_INTRA_SMOOTHING_ENABLED,\n\t\t\t\tsps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SPS_HDR_FLAG_SPS_TEMPORAL_MVP_ENABLED,\n\t\t\t\tV4L2_HEVC_SPS_FLAG_SPS_TEMPORAL_MVP_ENABLED,\n\t\t\t\tsps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SPS_HDR_FLAG_SAMPLE_ADAPTIVE_OFFSET_ENABLED,\n\t\t\t\tV4L2_HEVC_SPS_FLAG_SAMPLE_ADAPTIVE_OFFSET,\n\t\t\t\tsps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SPS_HDR_FLAG_AMP_ENABLED,\n\t\t\t\tV4L2_HEVC_SPS_FLAG_AMP_ENABLED, sps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SPS_HDR_FLAG_SEPARATE_COLOUR_PLANE,\n\t\t\t\tV4L2_HEVC_SPS_FLAG_SEPARATE_COLOUR_PLANE,\n\t\t\t\tsps->flags);\n\n\tcedrus_write(dev, VE_DEC_H265_DEC_SPS_HDR, reg);\n\n\treg = VE_DEC_H265_DEC_PCM_CTRL_LOG2_DIFF_MAX_MIN_PCM_LUMA_CODING_BLOCK_SIZE(sps->log2_diff_max_min_pcm_luma_coding_block_size) |\n\t      VE_DEC_H265_DEC_PCM_CTRL_LOG2_MIN_PCM_LUMA_CODING_BLOCK_SIZE_MINUS3(sps->log2_min_pcm_luma_coding_block_size_minus3) |\n\t      VE_DEC_H265_DEC_PCM_CTRL_PCM_SAMPLE_BIT_DEPTH_CHROMA_MINUS1(sps->pcm_sample_bit_depth_chroma_minus1) |\n\t      VE_DEC_H265_DEC_PCM_CTRL_PCM_SAMPLE_BIT_DEPTH_LUMA_MINUS1(sps->pcm_sample_bit_depth_luma_minus1);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_PCM_CTRL_FLAG_PCM_ENABLED,\n\t\t\t\tV4L2_HEVC_SPS_FLAG_PCM_ENABLED, sps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_PCM_CTRL_FLAG_PCM_LOOP_FILTER_DISABLED,\n\t\t\t\tV4L2_HEVC_SPS_FLAG_PCM_LOOP_FILTER_DISABLED,\n\t\t\t\tsps->flags);\n\n\tcedrus_write(dev, VE_DEC_H265_DEC_PCM_CTRL, reg);\n\n\t \n\n\treg = VE_DEC_H265_DEC_PPS_CTRL0_PPS_CR_QP_OFFSET(pps->pps_cr_qp_offset) |\n\t      VE_DEC_H265_DEC_PPS_CTRL0_PPS_CB_QP_OFFSET(pps->pps_cb_qp_offset) |\n\t      VE_DEC_H265_DEC_PPS_CTRL0_INIT_QP_MINUS26(pps->init_qp_minus26) |\n\t      VE_DEC_H265_DEC_PPS_CTRL0_DIFF_CU_QP_DELTA_DEPTH(pps->diff_cu_qp_delta_depth);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_PPS_CTRL0_FLAG_CU_QP_DELTA_ENABLED,\n\t\t\t\tV4L2_HEVC_PPS_FLAG_CU_QP_DELTA_ENABLED,\n\t\t\t\tpps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_PPS_CTRL0_FLAG_TRANSFORM_SKIP_ENABLED,\n\t\t\t\tV4L2_HEVC_PPS_FLAG_TRANSFORM_SKIP_ENABLED,\n\t\t\t\tpps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_PPS_CTRL0_FLAG_CONSTRAINED_INTRA_PRED,\n\t\t\t\tV4L2_HEVC_PPS_FLAG_CONSTRAINED_INTRA_PRED,\n\t\t\t\tpps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_PPS_CTRL0_FLAG_SIGN_DATA_HIDING_ENABLED,\n\t\t\t\tV4L2_HEVC_PPS_FLAG_SIGN_DATA_HIDING_ENABLED,\n\t\t\t\tpps->flags);\n\n\tcedrus_write(dev, VE_DEC_H265_DEC_PPS_CTRL0, reg);\n\n\treg = VE_DEC_H265_DEC_PPS_CTRL1_LOG2_PARALLEL_MERGE_LEVEL_MINUS2(pps->log2_parallel_merge_level_minus2);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_PPS_CTRL1_FLAG_PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED,\n\t\t\t\tV4L2_HEVC_PPS_FLAG_PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED,\n\t\t\t\tpps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_PPS_CTRL1_FLAG_LOOP_FILTER_ACROSS_TILES_ENABLED,\n\t\t\t\tV4L2_HEVC_PPS_FLAG_LOOP_FILTER_ACROSS_TILES_ENABLED,\n\t\t\t\tpps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_PPS_CTRL1_FLAG_ENTROPY_CODING_SYNC_ENABLED,\n\t\t\t\tV4L2_HEVC_PPS_FLAG_ENTROPY_CODING_SYNC_ENABLED,\n\t\t\t\tpps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_PPS_CTRL1_FLAG_TILES_ENABLED,\n\t\t\t\tV4L2_HEVC_PPS_FLAG_TILES_ENABLED,\n\t\t\t\tpps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_PPS_CTRL1_FLAG_TRANSQUANT_BYPASS_ENABLED,\n\t\t\t\tV4L2_HEVC_PPS_FLAG_TRANSQUANT_BYPASS_ENABLED,\n\t\t\t\tpps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_PPS_CTRL1_FLAG_WEIGHTED_BIPRED,\n\t\t\t\tV4L2_HEVC_PPS_FLAG_WEIGHTED_BIPRED, pps->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_PPS_CTRL1_FLAG_WEIGHTED_PRED,\n\t\t\t\tV4L2_HEVC_PPS_FLAG_WEIGHTED_PRED, pps->flags);\n\n\tcedrus_write(dev, VE_DEC_H265_DEC_PPS_CTRL1, reg);\n\n\t \n\n\treg = VE_DEC_H265_DEC_SLICE_HDR_INFO0_PICTURE_TYPE(slice_params->pic_struct) |\n\t      VE_DEC_H265_DEC_SLICE_HDR_INFO0_FIVE_MINUS_MAX_NUM_MERGE_CAND(slice_params->five_minus_max_num_merge_cand) |\n\t      VE_DEC_H265_DEC_SLICE_HDR_INFO0_NUM_REF_IDX_L1_ACTIVE_MINUS1(slice_params->num_ref_idx_l1_active_minus1) |\n\t      VE_DEC_H265_DEC_SLICE_HDR_INFO0_NUM_REF_IDX_L0_ACTIVE_MINUS1(slice_params->num_ref_idx_l0_active_minus1) |\n\t      VE_DEC_H265_DEC_SLICE_HDR_INFO0_COLLOCATED_REF_IDX(slice_params->collocated_ref_idx) |\n\t      VE_DEC_H265_DEC_SLICE_HDR_INFO0_COLOUR_PLANE_ID(slice_params->colour_plane_id) |\n\t      VE_DEC_H265_DEC_SLICE_HDR_INFO0_SLICE_TYPE(slice_params->slice_type);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SLICE_HDR_INFO0_FLAG_COLLOCATED_FROM_L0,\n\t\t\t\tV4L2_HEVC_SLICE_PARAMS_FLAG_COLLOCATED_FROM_L0,\n\t\t\t\tslice_params->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SLICE_HDR_INFO0_FLAG_CABAC_INIT,\n\t\t\t\tV4L2_HEVC_SLICE_PARAMS_FLAG_CABAC_INIT,\n\t\t\t\tslice_params->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SLICE_HDR_INFO0_FLAG_MVD_L1_ZERO,\n\t\t\t\tV4L2_HEVC_SLICE_PARAMS_FLAG_MVD_L1_ZERO,\n\t\t\t\tslice_params->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SLICE_HDR_INFO0_FLAG_SLICE_SAO_CHROMA,\n\t\t\t\tV4L2_HEVC_SLICE_PARAMS_FLAG_SLICE_SAO_CHROMA,\n\t\t\t\tslice_params->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SLICE_HDR_INFO0_FLAG_SLICE_SAO_LUMA,\n\t\t\t\tV4L2_HEVC_SLICE_PARAMS_FLAG_SLICE_SAO_LUMA,\n\t\t\t\tslice_params->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SLICE_HDR_INFO0_FLAG_SLICE_TEMPORAL_MVP_ENABLE,\n\t\t\t\tV4L2_HEVC_SLICE_PARAMS_FLAG_SLICE_TEMPORAL_MVP_ENABLED,\n\t\t\t\tslice_params->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SLICE_HDR_INFO0_FLAG_DEPENDENT_SLICE_SEGMENT,\n\t\t\t\tV4L2_HEVC_SLICE_PARAMS_FLAG_DEPENDENT_SLICE_SEGMENT,\n\t\t\t\tslice_params->flags);\n\n\tif (ctx->fh.m2m_ctx->new_frame)\n\t\treg |= VE_DEC_H265_DEC_SLICE_HDR_INFO0_FLAG_FIRST_SLICE_SEGMENT_IN_PIC;\n\n\tcedrus_write(dev, VE_DEC_H265_DEC_SLICE_HDR_INFO0, reg);\n\n\treg = VE_DEC_H265_DEC_SLICE_HDR_INFO1_SLICE_TC_OFFSET_DIV2(slice_params->slice_tc_offset_div2) |\n\t      VE_DEC_H265_DEC_SLICE_HDR_INFO1_SLICE_BETA_OFFSET_DIV2(slice_params->slice_beta_offset_div2) |\n\t      VE_DEC_H265_DEC_SLICE_HDR_INFO1_SLICE_CR_QP_OFFSET(slice_params->slice_cr_qp_offset) |\n\t      VE_DEC_H265_DEC_SLICE_HDR_INFO1_SLICE_CB_QP_OFFSET(slice_params->slice_cb_qp_offset) |\n\t      VE_DEC_H265_DEC_SLICE_HDR_INFO1_SLICE_QP_DELTA(slice_params->slice_qp_delta);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SLICE_HDR_INFO1_FLAG_SLICE_DEBLOCKING_FILTER_DISABLED,\n\t\t\t\tV4L2_HEVC_SLICE_PARAMS_FLAG_SLICE_DEBLOCKING_FILTER_DISABLED,\n\t\t\t\tslice_params->flags);\n\n\treg |= VE_DEC_H265_FLAG(VE_DEC_H265_DEC_SLICE_HDR_INFO1_FLAG_SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED,\n\t\t\t\tV4L2_HEVC_SLICE_PARAMS_FLAG_SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED,\n\t\t\t\tslice_params->flags);\n\n\tif (slice_params->slice_type != V4L2_HEVC_SLICE_TYPE_I && !cedrus_h265_is_low_delay(run))\n\t\treg |= VE_DEC_H265_DEC_SLICE_HDR_INFO1_FLAG_SLICE_NOT_LOW_DELAY;\n\n\tcedrus_write(dev, VE_DEC_H265_DEC_SLICE_HDR_INFO1, reg);\n\n\tchroma_log2_weight_denom = pred_weight_table->luma_log2_weight_denom +\n\t\t\t\t   pred_weight_table->delta_chroma_log2_weight_denom;\n\treg = VE_DEC_H265_DEC_SLICE_HDR_INFO2_NUM_ENTRY_POINT_OFFSETS(num_entry_point_offsets) |\n\t      VE_DEC_H265_DEC_SLICE_HDR_INFO2_CHROMA_LOG2_WEIGHT_DENOM(chroma_log2_weight_denom) |\n\t      VE_DEC_H265_DEC_SLICE_HDR_INFO2_LUMA_LOG2_WEIGHT_DENOM(pred_weight_table->luma_log2_weight_denom);\n\n\tcedrus_write(dev, VE_DEC_H265_DEC_SLICE_HDR_INFO2, reg);\n\n\tcedrus_write(dev, VE_DEC_H265_ENTRY_POINT_OFFSET_ADDR,\n\t\t     ctx->codec.h265.entry_points_buf_addr >> 8);\n\n\t \n\n\treg = VE_DEC_H265_DEC_PIC_SIZE_WIDTH(ctx->src_fmt.width) |\n\t      VE_DEC_H265_DEC_PIC_SIZE_HEIGHT(ctx->src_fmt.height);\n\n\tcedrus_write(dev, VE_DEC_H265_DEC_PIC_SIZE, reg);\n\n\t \n\n\tif (sps->flags & V4L2_HEVC_SPS_FLAG_SCALING_LIST_ENABLED) {\n\t\tcedrus_h265_write_scaling_list(ctx, run);\n\t\treg = VE_DEC_H265_SCALING_LIST_CTRL0_FLAG_ENABLED;\n\t} else {\n\t\treg = VE_DEC_H265_SCALING_LIST_CTRL0_DEFAULT;\n\t}\n\tcedrus_write(dev, VE_DEC_H265_SCALING_LIST_CTRL0, reg);\n\n\t \n\treg = VE_DEC_H265_NEIGHBOR_INFO_ADDR_BASE(ctx->codec.h265.neighbor_info_buf_addr);\n\tcedrus_write(dev, VE_DEC_H265_NEIGHBOR_INFO_ADDR, reg);\n\n\t \n\tcedrus_h265_frame_info_write_dpb(ctx, decode_params->dpb,\n\t\t\t\t\t decode_params->num_active_dpb_entries);\n\n\t \n\n\toutput_pic_list_index = V4L2_HEVC_DPB_ENTRIES_NUM_MAX;\n\tpic_order_cnt[0] = slice_params->slice_pic_order_cnt;\n\tpic_order_cnt[1] = slice_params->slice_pic_order_cnt;\n\n\tcedrus_h265_frame_info_write_single(ctx, output_pic_list_index,\n\t\t\t\t\t    slice_params->pic_struct != 0,\n\t\t\t\t\t    pic_order_cnt,\n\t\t\t\t\t    &run->dst->vb2_buf);\n\n\tcedrus_write(dev, VE_DEC_H265_OUTPUT_FRAME_IDX, output_pic_list_index);\n\n\t \n\tif (slice_params->slice_type != V4L2_HEVC_SLICE_TYPE_I) {\n\t\tcedrus_h265_ref_pic_list_write(dev, decode_params->dpb,\n\t\t\t\t\t       slice_params->ref_idx_l0,\n\t\t\t\t\t       slice_params->num_ref_idx_l0_active_minus1 + 1,\n\t\t\t\t\t       VE_DEC_H265_SRAM_OFFSET_REF_PIC_LIST0);\n\n\t\tif ((pps->flags & V4L2_HEVC_PPS_FLAG_WEIGHTED_PRED) ||\n\t\t    (pps->flags & V4L2_HEVC_PPS_FLAG_WEIGHTED_BIPRED))\n\t\t\tcedrus_h265_pred_weight_write(dev,\n\t\t\t\t\t\t      pred_weight_table->delta_luma_weight_l0,\n\t\t\t\t\t\t      pred_weight_table->luma_offset_l0,\n\t\t\t\t\t\t      pred_weight_table->delta_chroma_weight_l0,\n\t\t\t\t\t\t      pred_weight_table->chroma_offset_l0,\n\t\t\t\t\t\t      slice_params->num_ref_idx_l0_active_minus1 + 1,\n\t\t\t\t\t\t      VE_DEC_H265_SRAM_OFFSET_PRED_WEIGHT_LUMA_L0,\n\t\t\t\t\t\t      VE_DEC_H265_SRAM_OFFSET_PRED_WEIGHT_CHROMA_L0);\n\t}\n\n\t \n\tif (slice_params->slice_type == V4L2_HEVC_SLICE_TYPE_B) {\n\t\tcedrus_h265_ref_pic_list_write(dev, decode_params->dpb,\n\t\t\t\t\t       slice_params->ref_idx_l1,\n\t\t\t\t\t       slice_params->num_ref_idx_l1_active_minus1 + 1,\n\t\t\t\t\t       VE_DEC_H265_SRAM_OFFSET_REF_PIC_LIST1);\n\n\t\tif (pps->flags & V4L2_HEVC_PPS_FLAG_WEIGHTED_BIPRED)\n\t\t\tcedrus_h265_pred_weight_write(dev,\n\t\t\t\t\t\t      pred_weight_table->delta_luma_weight_l1,\n\t\t\t\t\t\t      pred_weight_table->luma_offset_l1,\n\t\t\t\t\t\t      pred_weight_table->delta_chroma_weight_l1,\n\t\t\t\t\t\t      pred_weight_table->chroma_offset_l1,\n\t\t\t\t\t\t      slice_params->num_ref_idx_l1_active_minus1 + 1,\n\t\t\t\t\t\t      VE_DEC_H265_SRAM_OFFSET_PRED_WEIGHT_LUMA_L1,\n\t\t\t\t\t\t      VE_DEC_H265_SRAM_OFFSET_PRED_WEIGHT_CHROMA_L1);\n\t}\n\n\tif (ctx->bit_depth > 8) {\n\t\tunsigned int stride = ALIGN(ctx->dst_fmt.width / 4, 32);\n\n\t\treg = ctx->dst_fmt.sizeimage -\n\t\t      cedrus_h265_2bit_size(ctx->dst_fmt.width,\n\t\t\t\t\t    ctx->dst_fmt.height);\n\t\tcedrus_write(dev, VE_DEC_H265_OFFSET_ADDR_FIRST_OUT, reg);\n\n\t\treg = VE_DEC_H265_10BIT_CONFIGURE_FIRST_2BIT_STRIDE(stride);\n\t\tcedrus_write(dev, VE_DEC_H265_10BIT_CONFIGURE, reg);\n\t}\n\n\t \n\tcedrus_write(dev, VE_DEC_H265_CTRL, VE_DEC_H265_CTRL_IRQ_MASK);\n\n\treturn 0;\n}\n\nstatic int cedrus_h265_start(struct cedrus_ctx *ctx)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\n\t \n\tctx->codec.h265.neighbor_info_buf =\n\t\tdma_alloc_attrs(dev->dev, CEDRUS_H265_NEIGHBOR_INFO_BUF_SIZE,\n\t\t\t\t&ctx->codec.h265.neighbor_info_buf_addr,\n\t\t\t\tGFP_KERNEL, DMA_ATTR_NO_KERNEL_MAPPING);\n\tif (!ctx->codec.h265.neighbor_info_buf)\n\t\treturn -ENOMEM;\n\n\tctx->codec.h265.entry_points_buf =\n\t\tdma_alloc_coherent(dev->dev, CEDRUS_H265_ENTRY_POINTS_BUF_SIZE,\n\t\t\t\t   &ctx->codec.h265.entry_points_buf_addr,\n\t\t\t\t   GFP_KERNEL);\n\tif (!ctx->codec.h265.entry_points_buf) {\n\t\tdma_free_attrs(dev->dev, CEDRUS_H265_NEIGHBOR_INFO_BUF_SIZE,\n\t\t\t       ctx->codec.h265.neighbor_info_buf,\n\t\t\t       ctx->codec.h265.neighbor_info_buf_addr,\n\t\t\t       DMA_ATTR_NO_KERNEL_MAPPING);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void cedrus_h265_stop(struct cedrus_ctx *ctx)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\tstruct cedrus_buffer *buf;\n\tstruct vb2_queue *vq;\n\tunsigned int i;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\tfor (i = 0; i < vq->num_buffers; i++) {\n\t\tbuf = vb2_to_cedrus_buffer(vb2_get_buffer(vq, i));\n\n\t\tif (buf->codec.h265.mv_col_buf_size > 0) {\n\t\t\tdma_free_attrs(dev->dev,\n\t\t\t\t       buf->codec.h265.mv_col_buf_size,\n\t\t\t\t       buf->codec.h265.mv_col_buf,\n\t\t\t\t       buf->codec.h265.mv_col_buf_dma,\n\t\t\t\t       DMA_ATTR_NO_KERNEL_MAPPING);\n\n\t\t\tbuf->codec.h265.mv_col_buf_size = 0;\n\t\t}\n\t}\n\n\tdma_free_attrs(dev->dev, CEDRUS_H265_NEIGHBOR_INFO_BUF_SIZE,\n\t\t       ctx->codec.h265.neighbor_info_buf,\n\t\t       ctx->codec.h265.neighbor_info_buf_addr,\n\t\t       DMA_ATTR_NO_KERNEL_MAPPING);\n\tdma_free_coherent(dev->dev, CEDRUS_H265_ENTRY_POINTS_BUF_SIZE,\n\t\t\t  ctx->codec.h265.entry_points_buf,\n\t\t\t  ctx->codec.h265.entry_points_buf_addr);\n}\n\nstatic void cedrus_h265_trigger(struct cedrus_ctx *ctx)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\n\tcedrus_write(dev, VE_DEC_H265_TRIGGER, VE_DEC_H265_TRIGGER_DEC_SLICE);\n}\n\nstatic unsigned int cedrus_h265_extra_cap_size(struct cedrus_ctx *ctx,\n\t\t\t\t\t       struct v4l2_pix_format *pix_fmt)\n{\n\tif (ctx->bit_depth > 8)\n\t\treturn cedrus_h265_2bit_size(pix_fmt->width, pix_fmt->height);\n\n\treturn 0;\n}\n\nstruct cedrus_dec_ops cedrus_dec_ops_h265 = {\n\t.irq_clear\t= cedrus_h265_irq_clear,\n\t.irq_disable\t= cedrus_h265_irq_disable,\n\t.irq_status\t= cedrus_h265_irq_status,\n\t.setup\t\t= cedrus_h265_setup,\n\t.start\t\t= cedrus_h265_start,\n\t.stop\t\t= cedrus_h265_stop,\n\t.trigger\t= cedrus_h265_trigger,\n\t.extra_cap_size\t= cedrus_h265_extra_cap_size,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}