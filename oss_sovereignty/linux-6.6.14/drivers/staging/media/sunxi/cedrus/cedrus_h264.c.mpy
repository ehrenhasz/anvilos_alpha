{
  "module_name": "cedrus_h264.c",
  "hash_id": "a2665513a78f5c474f88845af4a3a4a4bb9fd2b53bcb97d37d056b7676f1b1bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/sunxi/cedrus/cedrus_h264.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/types.h>\n\n#include <media/videobuf2-dma-contig.h>\n\n#include \"cedrus.h\"\n#include \"cedrus_hw.h\"\n#include \"cedrus_regs.h\"\n\nenum cedrus_h264_sram_off {\n\tCEDRUS_SRAM_H264_PRED_WEIGHT_TABLE\t= 0x000,\n\tCEDRUS_SRAM_H264_FRAMEBUFFER_LIST\t= 0x100,\n\tCEDRUS_SRAM_H264_REF_LIST_0\t\t= 0x190,\n\tCEDRUS_SRAM_H264_REF_LIST_1\t\t= 0x199,\n\tCEDRUS_SRAM_H264_SCALING_LIST_8x8_0\t= 0x200,\n\tCEDRUS_SRAM_H264_SCALING_LIST_8x8_1\t= 0x210,\n\tCEDRUS_SRAM_H264_SCALING_LIST_4x4\t= 0x220,\n};\n\nstruct cedrus_h264_sram_ref_pic {\n\t__le32\ttop_field_order_cnt;\n\t__le32\tbottom_field_order_cnt;\n\t__le32\tframe_info;\n\t__le32\tluma_ptr;\n\t__le32\tchroma_ptr;\n\t__le32\tmv_col_top_ptr;\n\t__le32\tmv_col_bot_ptr;\n\t__le32\treserved;\n} __packed;\n\n#define CEDRUS_H264_FRAME_NUM\t\t18\n\n#define CEDRUS_NEIGHBOR_INFO_BUF_SIZE\t(32 * SZ_1K)\n#define CEDRUS_MIN_PIC_INFO_BUF_SIZE       (130 * SZ_1K)\n\nstatic void cedrus_h264_write_sram(struct cedrus_dev *dev,\n\t\t\t\t   enum cedrus_h264_sram_off off,\n\t\t\t\t   const void *data, size_t len)\n{\n\tconst u32 *buffer = data;\n\tsize_t count = DIV_ROUND_UP(len, 4);\n\n\tcedrus_write(dev, VE_AVC_SRAM_PORT_OFFSET, off << 2);\n\n\twhile (count--)\n\t\tcedrus_write(dev, VE_AVC_SRAM_PORT_DATA, *buffer++);\n}\n\nstatic dma_addr_t cedrus_h264_mv_col_buf_addr(struct cedrus_buffer *buf,\n\t\t\t\t\t      unsigned int field)\n{\n\tdma_addr_t addr = buf->codec.h264.mv_col_buf_dma;\n\n\t \n\taddr += field * buf->codec.h264.mv_col_buf_size / 2;\n\n\treturn addr;\n}\n\nstatic void cedrus_fill_ref_pic(struct cedrus_ctx *ctx,\n\t\t\t\tstruct cedrus_buffer *buf,\n\t\t\t\tunsigned int top_field_order_cnt,\n\t\t\t\tunsigned int bottom_field_order_cnt,\n\t\t\t\tstruct cedrus_h264_sram_ref_pic *pic)\n{\n\tstruct vb2_buffer *vbuf = &buf->m2m_buf.vb.vb2_buf;\n\n\tpic->top_field_order_cnt = cpu_to_le32(top_field_order_cnt);\n\tpic->bottom_field_order_cnt = cpu_to_le32(bottom_field_order_cnt);\n\tpic->frame_info = cpu_to_le32(buf->codec.h264.pic_type << 8);\n\n\tpic->luma_ptr = cpu_to_le32(cedrus_buf_addr(vbuf, &ctx->dst_fmt, 0));\n\tpic->chroma_ptr = cpu_to_le32(cedrus_buf_addr(vbuf, &ctx->dst_fmt, 1));\n\tpic->mv_col_top_ptr = cpu_to_le32(cedrus_h264_mv_col_buf_addr(buf, 0));\n\tpic->mv_col_bot_ptr = cpu_to_le32(cedrus_h264_mv_col_buf_addr(buf, 1));\n}\n\nstatic int cedrus_write_frame_list(struct cedrus_ctx *ctx,\n\t\t\t\t   struct cedrus_run *run)\n{\n\tstruct cedrus_h264_sram_ref_pic pic_list[CEDRUS_H264_FRAME_NUM];\n\tconst struct v4l2_ctrl_h264_decode_params *decode = run->h264.decode_params;\n\tconst struct v4l2_ctrl_h264_sps *sps = run->h264.sps;\n\tstruct vb2_queue *cap_q;\n\tstruct cedrus_buffer *output_buf;\n\tstruct cedrus_dev *dev = ctx->dev;\n\tunsigned long used_dpbs = 0;\n\tunsigned int position;\n\tint output = -1;\n\tunsigned int i;\n\n\tcap_q = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\tmemset(pic_list, 0, sizeof(pic_list));\n\n\tfor (i = 0; i < ARRAY_SIZE(decode->dpb); i++) {\n\t\tconst struct v4l2_h264_dpb_entry *dpb = &decode->dpb[i];\n\t\tstruct cedrus_buffer *cedrus_buf;\n\t\tstruct vb2_buffer *buf;\n\n\t\tif (!(dpb->flags & V4L2_H264_DPB_ENTRY_FLAG_VALID))\n\t\t\tcontinue;\n\n\t\tbuf = vb2_find_buffer(cap_q, dpb->reference_ts);\n\t\tif (!buf)\n\t\t\tcontinue;\n\n\t\tcedrus_buf = vb2_to_cedrus_buffer(buf);\n\t\tposition = cedrus_buf->codec.h264.position;\n\t\tused_dpbs |= BIT(position);\n\n\t\tif (run->dst->vb2_buf.timestamp == dpb->reference_ts) {\n\t\t\toutput = position;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(dpb->flags & V4L2_H264_DPB_ENTRY_FLAG_ACTIVE))\n\t\t\tcontinue;\n\n\t\tcedrus_fill_ref_pic(ctx, cedrus_buf,\n\t\t\t\t    dpb->top_field_order_cnt,\n\t\t\t\t    dpb->bottom_field_order_cnt,\n\t\t\t\t    &pic_list[position]);\n\t}\n\n\tif (output >= 0)\n\t\tposition = output;\n\telse\n\t\tposition = find_first_zero_bit(&used_dpbs, CEDRUS_H264_FRAME_NUM);\n\n\toutput_buf = vb2_to_cedrus_buffer(&run->dst->vb2_buf);\n\toutput_buf->codec.h264.position = position;\n\n\tif (!output_buf->codec.h264.mv_col_buf_size) {\n\t\tconst struct v4l2_ctrl_h264_sps *sps = run->h264.sps;\n\t\tunsigned int field_size;\n\n\t\tfield_size = DIV_ROUND_UP(ctx->src_fmt.width, 16) *\n\t\t\tDIV_ROUND_UP(ctx->src_fmt.height, 16) * 16;\n\t\tif (!(sps->flags & V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE))\n\t\t\tfield_size = field_size * 2;\n\t\tif (!(sps->flags & V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY))\n\t\t\tfield_size = field_size * 2;\n\n\t\toutput_buf->codec.h264.mv_col_buf_size = field_size * 2;\n\t\t \n\t\toutput_buf->codec.h264.mv_col_buf =\n\t\t\tdma_alloc_attrs(dev->dev,\n\t\t\t\t\toutput_buf->codec.h264.mv_col_buf_size,\n\t\t\t\t\t&output_buf->codec.h264.mv_col_buf_dma,\n\t\t\t\t\tGFP_KERNEL, DMA_ATTR_NO_KERNEL_MAPPING);\n\n\t\tif (!output_buf->codec.h264.mv_col_buf) {\n\t\t\toutput_buf->codec.h264.mv_col_buf_size = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (decode->flags & V4L2_H264_DECODE_PARAM_FLAG_FIELD_PIC)\n\t\toutput_buf->codec.h264.pic_type = CEDRUS_H264_PIC_TYPE_FIELD;\n\telse if (sps->flags & V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD)\n\t\toutput_buf->codec.h264.pic_type = CEDRUS_H264_PIC_TYPE_MBAFF;\n\telse\n\t\toutput_buf->codec.h264.pic_type = CEDRUS_H264_PIC_TYPE_FRAME;\n\n\tcedrus_fill_ref_pic(ctx, output_buf,\n\t\t\t    decode->top_field_order_cnt,\n\t\t\t    decode->bottom_field_order_cnt,\n\t\t\t    &pic_list[position]);\n\n\tcedrus_h264_write_sram(dev, CEDRUS_SRAM_H264_FRAMEBUFFER_LIST,\n\t\t\t       pic_list, sizeof(pic_list));\n\n\tcedrus_write(dev, VE_H264_OUTPUT_FRAME_IDX, position);\n\n\treturn 0;\n}\n\n#define CEDRUS_MAX_REF_IDX\t32\n\nstatic void _cedrus_write_ref_list(struct cedrus_ctx *ctx,\n\t\t\t\t   struct cedrus_run *run,\n\t\t\t\t   const struct v4l2_h264_reference *ref_list,\n\t\t\t\t   u8 num_ref, enum cedrus_h264_sram_off sram)\n{\n\tconst struct v4l2_ctrl_h264_decode_params *decode = run->h264.decode_params;\n\tstruct vb2_queue *cap_q;\n\tstruct cedrus_dev *dev = ctx->dev;\n\tu8 sram_array[CEDRUS_MAX_REF_IDX];\n\tunsigned int i;\n\tsize_t size;\n\n\tcap_q = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\tmemset(sram_array, 0, sizeof(sram_array));\n\n\tfor (i = 0; i < num_ref; i++) {\n\t\tconst struct v4l2_h264_dpb_entry *dpb;\n\t\tconst struct cedrus_buffer *cedrus_buf;\n\t\tunsigned int position;\n\t\tstruct vb2_buffer *buf;\n\t\tu8 dpb_idx;\n\n\t\tdpb_idx = ref_list[i].index;\n\t\tdpb = &decode->dpb[dpb_idx];\n\n\t\tif (!(dpb->flags & V4L2_H264_DPB_ENTRY_FLAG_ACTIVE))\n\t\t\tcontinue;\n\n\t\tbuf = vb2_find_buffer(cap_q, dpb->reference_ts);\n\t\tif (!buf)\n\t\t\tcontinue;\n\n\t\tcedrus_buf = vb2_to_cedrus_buffer(buf);\n\t\tposition = cedrus_buf->codec.h264.position;\n\n\t\tsram_array[i] |= position << 1;\n\t\tif (ref_list[i].fields == V4L2_H264_BOTTOM_FIELD_REF)\n\t\t\tsram_array[i] |= BIT(0);\n\t}\n\n\tsize = min_t(size_t, ALIGN(num_ref, 4), sizeof(sram_array));\n\tcedrus_h264_write_sram(dev, sram, &sram_array, size);\n}\n\nstatic void cedrus_write_ref_list0(struct cedrus_ctx *ctx,\n\t\t\t\t   struct cedrus_run *run)\n{\n\tconst struct v4l2_ctrl_h264_slice_params *slice = run->h264.slice_params;\n\n\t_cedrus_write_ref_list(ctx, run,\n\t\t\t       slice->ref_pic_list0,\n\t\t\t       slice->num_ref_idx_l0_active_minus1 + 1,\n\t\t\t       CEDRUS_SRAM_H264_REF_LIST_0);\n}\n\nstatic void cedrus_write_ref_list1(struct cedrus_ctx *ctx,\n\t\t\t\t   struct cedrus_run *run)\n{\n\tconst struct v4l2_ctrl_h264_slice_params *slice = run->h264.slice_params;\n\n\t_cedrus_write_ref_list(ctx, run,\n\t\t\t       slice->ref_pic_list1,\n\t\t\t       slice->num_ref_idx_l1_active_minus1 + 1,\n\t\t\t       CEDRUS_SRAM_H264_REF_LIST_1);\n}\n\nstatic void cedrus_write_scaling_lists(struct cedrus_ctx *ctx,\n\t\t\t\t       struct cedrus_run *run)\n{\n\tconst struct v4l2_ctrl_h264_scaling_matrix *scaling =\n\t\trun->h264.scaling_matrix;\n\tconst struct v4l2_ctrl_h264_pps *pps = run->h264.pps;\n\tstruct cedrus_dev *dev = ctx->dev;\n\n\tif (!(pps->flags & V4L2_H264_PPS_FLAG_SCALING_MATRIX_PRESENT))\n\t\treturn;\n\n\tcedrus_h264_write_sram(dev, CEDRUS_SRAM_H264_SCALING_LIST_8x8_0,\n\t\t\t       scaling->scaling_list_8x8[0],\n\t\t\t       sizeof(scaling->scaling_list_8x8[0]));\n\n\tcedrus_h264_write_sram(dev, CEDRUS_SRAM_H264_SCALING_LIST_8x8_1,\n\t\t\t       scaling->scaling_list_8x8[1],\n\t\t\t       sizeof(scaling->scaling_list_8x8[1]));\n\n\tcedrus_h264_write_sram(dev, CEDRUS_SRAM_H264_SCALING_LIST_4x4,\n\t\t\t       scaling->scaling_list_4x4,\n\t\t\t       sizeof(scaling->scaling_list_4x4));\n}\n\nstatic void cedrus_write_pred_weight_table(struct cedrus_ctx *ctx,\n\t\t\t\t\t   struct cedrus_run *run)\n{\n\tconst struct v4l2_ctrl_h264_pred_weights *pred_weight =\n\t\trun->h264.pred_weights;\n\tstruct cedrus_dev *dev = ctx->dev;\n\tint i, j, k;\n\n\tcedrus_write(dev, VE_H264_SHS_WP,\n\t\t     ((pred_weight->chroma_log2_weight_denom & 0x7) << 4) |\n\t\t     ((pred_weight->luma_log2_weight_denom & 0x7) << 0));\n\n\tcedrus_write(dev, VE_AVC_SRAM_PORT_OFFSET,\n\t\t     CEDRUS_SRAM_H264_PRED_WEIGHT_TABLE << 2);\n\n\tfor (i = 0; i < ARRAY_SIZE(pred_weight->weight_factors); i++) {\n\t\tconst struct v4l2_h264_weight_factors *factors =\n\t\t\t&pred_weight->weight_factors[i];\n\n\t\tfor (j = 0; j < ARRAY_SIZE(factors->luma_weight); j++) {\n\t\t\tu32 val;\n\n\t\t\tval = (((u32)factors->luma_offset[j] & 0x1ff) << 16) |\n\t\t\t\t(factors->luma_weight[j] & 0x1ff);\n\t\t\tcedrus_write(dev, VE_AVC_SRAM_PORT_DATA, val);\n\t\t}\n\n\t\tfor (j = 0; j < ARRAY_SIZE(factors->chroma_weight); j++) {\n\t\t\tfor (k = 0; k < ARRAY_SIZE(factors->chroma_weight[0]); k++) {\n\t\t\t\tu32 val;\n\n\t\t\t\tval = (((u32)factors->chroma_offset[j][k] & 0x1ff) << 16) |\n\t\t\t\t\t(factors->chroma_weight[j][k] & 0x1ff);\n\t\t\t\tcedrus_write(dev, VE_AVC_SRAM_PORT_DATA, val);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void cedrus_skip_bits(struct cedrus_dev *dev, int num)\n{\n\tint count = 0;\n\n\twhile (count < num) {\n\t\tint tmp = min(num - count, 32);\n\n\t\tcedrus_write(dev, VE_H264_TRIGGER_TYPE,\n\t\t\t     VE_H264_TRIGGER_TYPE_FLUSH_BITS |\n\t\t\t     VE_H264_TRIGGER_TYPE_N_BITS(tmp));\n\t\twhile (cedrus_read(dev, VE_H264_STATUS) & VE_H264_STATUS_VLD_BUSY)\n\t\t\tudelay(1);\n\n\t\tcount += tmp;\n\t}\n}\n\nstatic void cedrus_set_params(struct cedrus_ctx *ctx,\n\t\t\t      struct cedrus_run *run)\n{\n\tconst struct v4l2_ctrl_h264_decode_params *decode = run->h264.decode_params;\n\tconst struct v4l2_ctrl_h264_slice_params *slice = run->h264.slice_params;\n\tconst struct v4l2_ctrl_h264_pps *pps = run->h264.pps;\n\tconst struct v4l2_ctrl_h264_sps *sps = run->h264.sps;\n\tstruct vb2_buffer *src_buf = &run->src->vb2_buf;\n\tstruct cedrus_dev *dev = ctx->dev;\n\tdma_addr_t src_buf_addr;\n\tsize_t slice_bytes = vb2_get_plane_payload(src_buf, 0);\n\tunsigned int pic_width_in_mbs;\n\tbool mbaff_pic;\n\tu32 reg;\n\n\tcedrus_write(dev, VE_H264_VLD_LEN, slice_bytes * 8);\n\tcedrus_write(dev, VE_H264_VLD_OFFSET, 0);\n\n\tsrc_buf_addr = vb2_dma_contig_plane_dma_addr(src_buf, 0);\n\tcedrus_write(dev, VE_H264_VLD_END, src_buf_addr + slice_bytes);\n\tcedrus_write(dev, VE_H264_VLD_ADDR,\n\t\t     VE_H264_VLD_ADDR_VAL(src_buf_addr) |\n\t\t     VE_H264_VLD_ADDR_FIRST | VE_H264_VLD_ADDR_VALID |\n\t\t     VE_H264_VLD_ADDR_LAST);\n\n\tif (ctx->src_fmt.width > 2048) {\n\t\tcedrus_write(dev, VE_BUF_CTRL,\n\t\t\t     VE_BUF_CTRL_INTRAPRED_MIXED_RAM |\n\t\t\t     VE_BUF_CTRL_DBLK_MIXED_RAM);\n\t\tcedrus_write(dev, VE_DBLK_DRAM_BUF_ADDR,\n\t\t\t     ctx->codec.h264.deblk_buf_dma);\n\t\tcedrus_write(dev, VE_INTRAPRED_DRAM_BUF_ADDR,\n\t\t\t     ctx->codec.h264.intra_pred_buf_dma);\n\t} else {\n\t\tcedrus_write(dev, VE_BUF_CTRL,\n\t\t\t     VE_BUF_CTRL_INTRAPRED_INT_SRAM |\n\t\t\t     VE_BUF_CTRL_DBLK_INT_SRAM);\n\t}\n\n\t \n\tcedrus_write(dev, VE_H264_TRIGGER_TYPE,\n\t\t     VE_H264_TRIGGER_TYPE_INIT_SWDEC);\n\n\tcedrus_skip_bits(dev, slice->header_bit_size);\n\n\tif (V4L2_H264_CTRL_PRED_WEIGHTS_REQUIRED(pps, slice))\n\t\tcedrus_write_pred_weight_table(ctx, run);\n\n\tif ((slice->slice_type == V4L2_H264_SLICE_TYPE_P) ||\n\t    (slice->slice_type == V4L2_H264_SLICE_TYPE_SP) ||\n\t    (slice->slice_type == V4L2_H264_SLICE_TYPE_B))\n\t\tcedrus_write_ref_list0(ctx, run);\n\n\tif (slice->slice_type == V4L2_H264_SLICE_TYPE_B)\n\t\tcedrus_write_ref_list1(ctx, run);\n\n\t \n\treg = 0;\n\t \n\treg |= (slice->num_ref_idx_l0_active_minus1 & 0x1f) << 10;\n\treg |= (slice->num_ref_idx_l1_active_minus1 & 0x1f) << 5;\n\treg |= (pps->weighted_bipred_idc & 0x3) << 2;\n\tif (pps->flags & V4L2_H264_PPS_FLAG_ENTROPY_CODING_MODE)\n\t\treg |= VE_H264_PPS_ENTROPY_CODING_MODE;\n\tif (pps->flags & V4L2_H264_PPS_FLAG_WEIGHTED_PRED)\n\t\treg |= VE_H264_PPS_WEIGHTED_PRED;\n\tif (pps->flags & V4L2_H264_PPS_FLAG_CONSTRAINED_INTRA_PRED)\n\t\treg |= VE_H264_PPS_CONSTRAINED_INTRA_PRED;\n\tif (pps->flags & V4L2_H264_PPS_FLAG_TRANSFORM_8X8_MODE)\n\t\treg |= VE_H264_PPS_TRANSFORM_8X8_MODE;\n\tcedrus_write(dev, VE_H264_PPS, reg);\n\n\t\n\treg = 0;\n\treg |= (sps->chroma_format_idc & 0x7) << 19;\n\treg |= (sps->pic_width_in_mbs_minus1 & 0xff) << 8;\n\treg |= sps->pic_height_in_map_units_minus1 & 0xff;\n\tif (sps->flags & V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY)\n\t\treg |= VE_H264_SPS_MBS_ONLY;\n\tif (sps->flags & V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD)\n\t\treg |= VE_H264_SPS_MB_ADAPTIVE_FRAME_FIELD;\n\tif (sps->flags & V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE)\n\t\treg |= VE_H264_SPS_DIRECT_8X8_INFERENCE;\n\tcedrus_write(dev, VE_H264_SPS, reg);\n\n\tmbaff_pic = !(decode->flags & V4L2_H264_DECODE_PARAM_FLAG_FIELD_PIC) &&\n\t\t    (sps->flags & V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD);\n\tpic_width_in_mbs = sps->pic_width_in_mbs_minus1 + 1;\n\n\t\n\treg = 0;\n\treg |= ((slice->first_mb_in_slice % pic_width_in_mbs) & 0xff) << 24;\n\treg |= (((slice->first_mb_in_slice / pic_width_in_mbs) *\n\t\t (mbaff_pic + 1)) & 0xff) << 16;\n\treg |= decode->nal_ref_idc ? BIT(12) : 0;\n\treg |= (slice->slice_type & 0xf) << 8;\n\treg |= slice->cabac_init_idc & 0x3;\n\tif (ctx->fh.m2m_ctx->new_frame)\n\t\treg |= VE_H264_SHS_FIRST_SLICE_IN_PIC;\n\tif (decode->flags & V4L2_H264_DECODE_PARAM_FLAG_FIELD_PIC)\n\t\treg |= VE_H264_SHS_FIELD_PIC;\n\tif (decode->flags & V4L2_H264_DECODE_PARAM_FLAG_BOTTOM_FIELD)\n\t\treg |= VE_H264_SHS_BOTTOM_FIELD;\n\tif (slice->flags & V4L2_H264_SLICE_FLAG_DIRECT_SPATIAL_MV_PRED)\n\t\treg |= VE_H264_SHS_DIRECT_SPATIAL_MV_PRED;\n\tcedrus_write(dev, VE_H264_SHS, reg);\n\n\treg = 0;\n\treg |= VE_H264_SHS2_NUM_REF_IDX_ACTIVE_OVRD;\n\treg |= (slice->num_ref_idx_l0_active_minus1 & 0x1f) << 24;\n\treg |= (slice->num_ref_idx_l1_active_minus1 & 0x1f) << 16;\n\treg |= (slice->disable_deblocking_filter_idc & 0x3) << 8;\n\treg |= (slice->slice_alpha_c0_offset_div2 & 0xf) << 4;\n\treg |= slice->slice_beta_offset_div2 & 0xf;\n\tcedrus_write(dev, VE_H264_SHS2, reg);\n\n\treg = 0;\n\treg |= (pps->second_chroma_qp_index_offset & 0x3f) << 16;\n\treg |= (pps->chroma_qp_index_offset & 0x3f) << 8;\n\treg |= (pps->pic_init_qp_minus26 + 26 + slice->slice_qp_delta) & 0x3f;\n\tif (!(pps->flags & V4L2_H264_PPS_FLAG_SCALING_MATRIX_PRESENT))\n\t\treg |= VE_H264_SHS_QP_SCALING_MATRIX_DEFAULT;\n\tcedrus_write(dev, VE_H264_SHS_QP, reg);\n\n\t\n\tcedrus_write(dev, VE_H264_STATUS, cedrus_read(dev, VE_H264_STATUS));\n\n\t\n\tcedrus_write(dev, VE_H264_CTRL,\n\t\t     VE_H264_CTRL_SLICE_DECODE_INT |\n\t\t     VE_H264_CTRL_DECODE_ERR_INT |\n\t\t     VE_H264_CTRL_VLD_DATA_REQ_INT);\n}\n\nstatic enum cedrus_irq_status\ncedrus_h264_irq_status(struct cedrus_ctx *ctx)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\tu32 reg = cedrus_read(dev, VE_H264_STATUS);\n\n\tif (reg & (VE_H264_STATUS_DECODE_ERR_INT |\n\t\t   VE_H264_STATUS_VLD_DATA_REQ_INT))\n\t\treturn CEDRUS_IRQ_ERROR;\n\n\tif (reg & VE_H264_CTRL_SLICE_DECODE_INT)\n\t\treturn CEDRUS_IRQ_OK;\n\n\treturn CEDRUS_IRQ_NONE;\n}\n\nstatic void cedrus_h264_irq_clear(struct cedrus_ctx *ctx)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\n\tcedrus_write(dev, VE_H264_STATUS,\n\t\t     VE_H264_STATUS_INT_MASK);\n}\n\nstatic void cedrus_h264_irq_disable(struct cedrus_ctx *ctx)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\tu32 reg = cedrus_read(dev, VE_H264_CTRL);\n\n\tcedrus_write(dev, VE_H264_CTRL,\n\t\t     reg & ~VE_H264_CTRL_INT_MASK);\n}\n\nstatic int cedrus_h264_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\tint ret;\n\n\tcedrus_engine_enable(ctx);\n\n\tcedrus_write(dev, VE_H264_SDROT_CTRL, 0);\n\tcedrus_write(dev, VE_H264_EXTRA_BUFFER1,\n\t\t     ctx->codec.h264.pic_info_buf_dma);\n\tcedrus_write(dev, VE_H264_EXTRA_BUFFER2,\n\t\t     ctx->codec.h264.neighbor_info_buf_dma);\n\n\tcedrus_write_scaling_lists(ctx, run);\n\tret = cedrus_write_frame_list(ctx, run);\n\tif (ret)\n\t\treturn ret;\n\n\tcedrus_set_params(ctx, run);\n\n\treturn 0;\n}\n\nstatic int cedrus_h264_start(struct cedrus_ctx *ctx)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\tunsigned int pic_info_size;\n\tint ret;\n\n\t \n\n\t \n\n\tif (ctx->src_fmt.width > 2048)\n\t\tpic_info_size = CEDRUS_H264_FRAME_NUM * 0x4000;\n\telse\n\t\tpic_info_size = CEDRUS_H264_FRAME_NUM * 0x1000;\n\n\t \n\tpic_info_size += ctx->src_fmt.height * 2 * 64;\n\n\tif (pic_info_size < CEDRUS_MIN_PIC_INFO_BUF_SIZE)\n\t\tpic_info_size = CEDRUS_MIN_PIC_INFO_BUF_SIZE;\n\n\tctx->codec.h264.pic_info_buf_size = pic_info_size;\n\tctx->codec.h264.pic_info_buf =\n\t\tdma_alloc_attrs(dev->dev, ctx->codec.h264.pic_info_buf_size,\n\t\t\t\t&ctx->codec.h264.pic_info_buf_dma,\n\t\t\t\tGFP_KERNEL, DMA_ATTR_NO_KERNEL_MAPPING);\n\tif (!ctx->codec.h264.pic_info_buf)\n\t\treturn -ENOMEM;\n\n\t \n\tctx->codec.h264.neighbor_info_buf =\n\t\tdma_alloc_attrs(dev->dev, CEDRUS_NEIGHBOR_INFO_BUF_SIZE,\n\t\t\t\t&ctx->codec.h264.neighbor_info_buf_dma,\n\t\t\t\tGFP_KERNEL, DMA_ATTR_NO_KERNEL_MAPPING);\n\tif (!ctx->codec.h264.neighbor_info_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_pic_buf;\n\t}\n\n\tif (ctx->src_fmt.width > 2048) {\n\t\t \n\n\t\tctx->codec.h264.deblk_buf_size =\n\t\t\tALIGN(ctx->src_fmt.width, 32) * 12;\n\t\tctx->codec.h264.deblk_buf =\n\t\t\tdma_alloc_attrs(dev->dev,\n\t\t\t\t\tctx->codec.h264.deblk_buf_size,\n\t\t\t\t\t&ctx->codec.h264.deblk_buf_dma,\n\t\t\t\t\tGFP_KERNEL, DMA_ATTR_NO_KERNEL_MAPPING);\n\t\tif (!ctx->codec.h264.deblk_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_neighbor_buf;\n\t\t}\n\n\t\t \n\t\tctx->codec.h264.intra_pred_buf_size =\n\t\t\tALIGN(ctx->src_fmt.width, 64) * 5 * 2;\n\t\tctx->codec.h264.intra_pred_buf =\n\t\t\tdma_alloc_attrs(dev->dev,\n\t\t\t\t\tctx->codec.h264.intra_pred_buf_size,\n\t\t\t\t\t&ctx->codec.h264.intra_pred_buf_dma,\n\t\t\t\t\tGFP_KERNEL, DMA_ATTR_NO_KERNEL_MAPPING);\n\t\tif (!ctx->codec.h264.intra_pred_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_deblk_buf;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_deblk_buf:\n\tdma_free_attrs(dev->dev, ctx->codec.h264.deblk_buf_size,\n\t\t       ctx->codec.h264.deblk_buf,\n\t\t       ctx->codec.h264.deblk_buf_dma,\n\t\t       DMA_ATTR_NO_KERNEL_MAPPING);\n\nerr_neighbor_buf:\n\tdma_free_attrs(dev->dev, CEDRUS_NEIGHBOR_INFO_BUF_SIZE,\n\t\t       ctx->codec.h264.neighbor_info_buf,\n\t\t       ctx->codec.h264.neighbor_info_buf_dma,\n\t\t       DMA_ATTR_NO_KERNEL_MAPPING);\n\nerr_pic_buf:\n\tdma_free_attrs(dev->dev, ctx->codec.h264.pic_info_buf_size,\n\t\t       ctx->codec.h264.pic_info_buf,\n\t\t       ctx->codec.h264.pic_info_buf_dma,\n\t\t       DMA_ATTR_NO_KERNEL_MAPPING);\n\treturn ret;\n}\n\nstatic void cedrus_h264_stop(struct cedrus_ctx *ctx)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\tstruct cedrus_buffer *buf;\n\tstruct vb2_queue *vq;\n\tunsigned int i;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\tfor (i = 0; i < vq->num_buffers; i++) {\n\t\tbuf = vb2_to_cedrus_buffer(vb2_get_buffer(vq, i));\n\n\t\tif (buf->codec.h264.mv_col_buf_size > 0) {\n\t\t\tdma_free_attrs(dev->dev,\n\t\t\t\t       buf->codec.h264.mv_col_buf_size,\n\t\t\t\t       buf->codec.h264.mv_col_buf,\n\t\t\t\t       buf->codec.h264.mv_col_buf_dma,\n\t\t\t\t       DMA_ATTR_NO_KERNEL_MAPPING);\n\n\t\t\tbuf->codec.h264.mv_col_buf_size = 0;\n\t\t}\n\t}\n\n\tdma_free_attrs(dev->dev, CEDRUS_NEIGHBOR_INFO_BUF_SIZE,\n\t\t       ctx->codec.h264.neighbor_info_buf,\n\t\t       ctx->codec.h264.neighbor_info_buf_dma,\n\t\t       DMA_ATTR_NO_KERNEL_MAPPING);\n\tdma_free_attrs(dev->dev, ctx->codec.h264.pic_info_buf_size,\n\t\t       ctx->codec.h264.pic_info_buf,\n\t\t       ctx->codec.h264.pic_info_buf_dma,\n\t\t       DMA_ATTR_NO_KERNEL_MAPPING);\n\tif (ctx->codec.h264.deblk_buf_size)\n\t\tdma_free_attrs(dev->dev, ctx->codec.h264.deblk_buf_size,\n\t\t\t       ctx->codec.h264.deblk_buf,\n\t\t\t       ctx->codec.h264.deblk_buf_dma,\n\t\t\t       DMA_ATTR_NO_KERNEL_MAPPING);\n\tif (ctx->codec.h264.intra_pred_buf_size)\n\t\tdma_free_attrs(dev->dev, ctx->codec.h264.intra_pred_buf_size,\n\t\t\t       ctx->codec.h264.intra_pred_buf,\n\t\t\t       ctx->codec.h264.intra_pred_buf_dma,\n\t\t\t       DMA_ATTR_NO_KERNEL_MAPPING);\n}\n\nstatic void cedrus_h264_trigger(struct cedrus_ctx *ctx)\n{\n\tstruct cedrus_dev *dev = ctx->dev;\n\n\tcedrus_write(dev, VE_H264_TRIGGER_TYPE,\n\t\t     VE_H264_TRIGGER_TYPE_AVC_SLICE_DECODE);\n}\n\nstruct cedrus_dec_ops cedrus_dec_ops_h264 = {\n\t.irq_clear\t= cedrus_h264_irq_clear,\n\t.irq_disable\t= cedrus_h264_irq_disable,\n\t.irq_status\t= cedrus_h264_irq_status,\n\t.setup\t\t= cedrus_h264_setup,\n\t.start\t\t= cedrus_h264_start,\n\t.stop\t\t= cedrus_h264_stop,\n\t.trigger\t= cedrus_h264_trigger,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}