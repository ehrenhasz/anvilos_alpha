{
  "module_name": "cedrus.c",
  "hash_id": "1712b68359c28a8b3ecb76d08174e24a5d595acdac5764c78b95682750e8ef3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/sunxi/cedrus/cedrus.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-mem2mem.h>\n\n#include \"cedrus.h\"\n#include \"cedrus_video.h\"\n#include \"cedrus_dec.h\"\n#include \"cedrus_hw.h\"\n\nstatic int cedrus_try_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tif (ctrl->id == V4L2_CID_STATELESS_H264_SPS) {\n\t\tconst struct v4l2_ctrl_h264_sps *sps = ctrl->p_new.p_h264_sps;\n\n\t\tif (sps->chroma_format_idc != 1)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\tif (sps->bit_depth_luma_minus8 != sps->bit_depth_chroma_minus8)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\tif (sps->bit_depth_luma_minus8 != 0)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t} else if (ctrl->id == V4L2_CID_STATELESS_HEVC_SPS) {\n\t\tconst struct v4l2_ctrl_hevc_sps *sps = ctrl->p_new.p_hevc_sps;\n\t\tstruct cedrus_ctx *ctx = container_of(ctrl->handler, struct cedrus_ctx, hdl);\n\t\tunsigned int bit_depth, max_depth;\n\t\tstruct vb2_queue *vq;\n\n\t\tif (sps->chroma_format_idc != 1)\n\t\t\t \n\t\t\treturn -EINVAL;\n\n\t\tbit_depth = max(sps->bit_depth_luma_minus8,\n\t\t\t\tsps->bit_depth_chroma_minus8) + 8;\n\n\t\tif (cedrus_is_capable(ctx, CEDRUS_CAPABILITY_H265_10_DEC))\n\t\t\tmax_depth = 10;\n\t\telse\n\t\t\tmax_depth = 8;\n\n\t\tif (bit_depth > max_depth)\n\t\t\treturn -EINVAL;\n\n\t\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t     V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\t\t \n\t\tif (vb2_is_busy(vq)) {\n\t\t\tif (ctx->bit_depth < bit_depth)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tctx->bit_depth = bit_depth;\n\t\t\tcedrus_reset_cap_format(ctx);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops cedrus_ctrl_ops = {\n\t.try_ctrl = cedrus_try_ctrl,\n};\n\nstatic const struct cedrus_control cedrus_controls[] = {\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_MPEG2_SEQUENCE,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_MPEG2_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_MPEG2_PICTURE,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_MPEG2_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_MPEG2_QUANTISATION,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_MPEG2_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_H264_DECODE_PARAMS,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H264_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_H264_SLICE_PARAMS,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H264_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_H264_SPS,\n\t\t\t.ops\t= &cedrus_ctrl_ops,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H264_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_H264_PPS,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H264_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_H264_SCALING_MATRIX,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H264_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_H264_PRED_WEIGHTS,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H264_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_H264_DECODE_MODE,\n\t\t\t.max\t= V4L2_STATELESS_H264_DECODE_MODE_SLICE_BASED,\n\t\t\t.def\t= V4L2_STATELESS_H264_DECODE_MODE_SLICE_BASED,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H264_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_H264_START_CODE,\n\t\t\t.max\t= V4L2_STATELESS_H264_START_CODE_NONE,\n\t\t\t.def\t= V4L2_STATELESS_H264_START_CODE_NONE,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H264_DEC,\n\t},\n\t \n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_MPEG_VIDEO_H264_PROFILE,\n\t\t\t.min\t= V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE,\n\t\t\t.def\t= V4L2_MPEG_VIDEO_H264_PROFILE_MAIN,\n\t\t\t.max\t= V4L2_MPEG_VIDEO_H264_PROFILE_HIGH,\n\t\t\t.menu_skip_mask =\n\t\t\t\tBIT(V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED),\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H264_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_HEVC_SPS,\n\t\t\t.ops\t= &cedrus_ctrl_ops,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H265_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_HEVC_PPS,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H265_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_HEVC_SLICE_PARAMS,\n\t\t\t \n\t\t\t.dims   = { 1 },\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H265_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_HEVC_SCALING_MATRIX,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H265_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_HEVC_ENTRY_POINT_OFFSETS,\n\t\t\t \n\t\t\t.dims\t= { 256 },\n\t\t\t.max = 0xffffffff,\n\t\t\t.step = 1,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H265_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_HEVC_DECODE_MODE,\n\t\t\t.max\t= V4L2_STATELESS_HEVC_DECODE_MODE_SLICE_BASED,\n\t\t\t.def\t= V4L2_STATELESS_HEVC_DECODE_MODE_SLICE_BASED,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H265_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_HEVC_START_CODE,\n\t\t\t.max\t= V4L2_STATELESS_HEVC_START_CODE_NONE,\n\t\t\t.def\t= V4L2_STATELESS_HEVC_START_CODE_NONE,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H265_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id\t= V4L2_CID_STATELESS_VP8_FRAME,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_VP8_DEC,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_HEVC_DECODE_PARAMS,\n\t\t},\n\t\t.capabilities\t= CEDRUS_CAPABILITY_H265_DEC,\n\t},\n};\n\n#define CEDRUS_CONTROLS_COUNT\tARRAY_SIZE(cedrus_controls)\n\nvoid *cedrus_find_control_data(struct cedrus_ctx *ctx, u32 id)\n{\n\tunsigned int i;\n\n\tfor (i = 0; ctx->ctrls[i]; i++)\n\t\tif (ctx->ctrls[i]->id == id)\n\t\t\treturn ctx->ctrls[i]->p_cur.p;\n\n\treturn NULL;\n}\n\nu32 cedrus_get_num_of_controls(struct cedrus_ctx *ctx, u32 id)\n{\n\tunsigned int i;\n\n\tfor (i = 0; ctx->ctrls[i]; i++)\n\t\tif (ctx->ctrls[i]->id == id)\n\t\t\treturn ctx->ctrls[i]->elems;\n\n\treturn 0;\n}\n\nstatic int cedrus_init_ctrls(struct cedrus_dev *dev, struct cedrus_ctx *ctx)\n{\n\tstruct v4l2_ctrl_handler *hdl = &ctx->hdl;\n\tstruct v4l2_ctrl *ctrl;\n\tunsigned int ctrl_size;\n\tunsigned int i, j;\n\n\tv4l2_ctrl_handler_init(hdl, CEDRUS_CONTROLS_COUNT);\n\tif (hdl->error) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Failed to initialize control handler: %d\\n\",\n\t\t\t hdl->error);\n\t\treturn hdl->error;\n\t}\n\n\tctrl_size = sizeof(ctrl) * CEDRUS_CONTROLS_COUNT + 1;\n\n\tctx->ctrls = kzalloc(ctrl_size, GFP_KERNEL);\n\tif (!ctx->ctrls)\n\t\treturn -ENOMEM;\n\n\tj = 0;\n\tfor (i = 0; i < CEDRUS_CONTROLS_COUNT; i++) {\n\t\tif (!cedrus_is_capable(ctx, cedrus_controls[i].capabilities))\n\t\t\tcontinue;\n\n\t\tctrl = v4l2_ctrl_new_custom(hdl, &cedrus_controls[i].cfg,\n\t\t\t\t\t    NULL);\n\t\tif (hdl->error) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"Failed to create %s control: %d\\n\",\n\t\t\t\t v4l2_ctrl_get_name(cedrus_controls[i].cfg.id),\n\t\t\t\t hdl->error);\n\n\t\t\tv4l2_ctrl_handler_free(hdl);\n\t\t\tkfree(ctx->ctrls);\n\t\t\tctx->ctrls = NULL;\n\t\t\treturn hdl->error;\n\t\t}\n\n\t\tctx->ctrls[j++] = ctrl;\n\t}\n\n\tctx->fh.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_setup(hdl);\n\n\treturn 0;\n}\n\nstatic int cedrus_request_validate(struct media_request *req)\n{\n\tstruct media_request_object *obj;\n\tstruct cedrus_ctx *ctx = NULL;\n\tunsigned int count;\n\n\tlist_for_each_entry(obj, &req->objects, list) {\n\t\tstruct vb2_buffer *vb;\n\n\t\tif (vb2_request_object_is_buffer(obj)) {\n\t\t\tvb = container_of(obj, struct vb2_buffer, req_obj);\n\t\t\tctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ctx)\n\t\treturn -ENOENT;\n\n\tcount = vb2_request_buffer_cnt(req);\n\tif (!count) {\n\t\tv4l2_info(&ctx->dev->v4l2_dev,\n\t\t\t  \"No buffer was provided with the request\\n\");\n\t\treturn -ENOENT;\n\t} else if (count > 1) {\n\t\tv4l2_info(&ctx->dev->v4l2_dev,\n\t\t\t  \"More than one buffer was provided with the request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn vb2_request_validate(req);\n}\n\nstatic int cedrus_open(struct file *file)\n{\n\tstruct cedrus_dev *dev = video_drvdata(file);\n\tstruct cedrus_ctx *ctx = NULL;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&dev->dev_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tmutex_unlock(&dev->dev_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tctx->dev = dev;\n\tctx->bit_depth = 8;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx,\n\t\t\t\t\t    &cedrus_queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto err_free;\n\t}\n\n\tcedrus_reset_out_format(ctx);\n\n\tret = cedrus_init_ctrls(dev, ctx);\n\tif (ret)\n\t\tgoto err_m2m_release;\n\n\tv4l2_fh_add(&ctx->fh);\n\n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn 0;\n\nerr_m2m_release:\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\nerr_free:\n\tkfree(ctx);\n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn ret;\n}\n\nstatic int cedrus_release(struct file *file)\n{\n\tstruct cedrus_dev *dev = video_drvdata(file);\n\tstruct cedrus_ctx *ctx = container_of(file->private_data,\n\t\t\t\t\t      struct cedrus_ctx, fh);\n\n\tmutex_lock(&dev->dev_mutex);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\n\tv4l2_ctrl_handler_free(&ctx->hdl);\n\tkfree(ctx->ctrls);\n\n\tv4l2_fh_exit(&ctx->fh);\n\n\tkfree(ctx);\n\n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations cedrus_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= cedrus_open,\n\t.release\t= cedrus_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct video_device cedrus_video_device = {\n\t.name\t\t= CEDRUS_NAME,\n\t.vfl_dir\t= VFL_DIR_M2M,\n\t.fops\t\t= &cedrus_fops,\n\t.ioctl_ops\t= &cedrus_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= video_device_release_empty,\n\t.device_caps\t= V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING,\n};\n\nstatic const struct v4l2_m2m_ops cedrus_m2m_ops = {\n\t.device_run\t= cedrus_device_run,\n};\n\nstatic const struct media_device_ops cedrus_m2m_media_ops = {\n\t.req_validate\t= cedrus_request_validate,\n\t.req_queue\t= v4l2_m2m_request_queue,\n};\n\nstatic int cedrus_probe(struct platform_device *pdev)\n{\n\tstruct cedrus_dev *dev;\n\tstruct video_device *vfd;\n\tint ret;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tdev->vfd = cedrus_video_device;\n\tdev->dev = &pdev->dev;\n\tdev->pdev = pdev;\n\n\tret = cedrus_hw_probe(dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to probe hardware\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_init(&dev->dev_mutex);\n\n\tINIT_DELAYED_WORK(&dev->watchdog_work, cedrus_watchdog);\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register V4L2 device\\n\");\n\t\treturn ret;\n\t}\n\n\tvfd = &dev->vfd;\n\tvfd->lock = &dev->dev_mutex;\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s\", cedrus_video_device.name);\n\tvideo_set_drvdata(vfd, dev);\n\n\tdev->m2m_dev = v4l2_m2m_init(&cedrus_m2m_ops);\n\tif (IS_ERR(dev->m2m_dev)) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Failed to initialize V4L2 M2M device\\n\");\n\t\tret = PTR_ERR(dev->m2m_dev);\n\n\t\tgoto err_v4l2;\n\t}\n\n\tdev->mdev.dev = &pdev->dev;\n\tstrscpy(dev->mdev.model, CEDRUS_NAME, sizeof(dev->mdev.model));\n\tstrscpy(dev->mdev.bus_info, \"platform:\" CEDRUS_NAME,\n\t\tsizeof(dev->mdev.bus_info));\n\n\tmedia_device_init(&dev->mdev);\n\tdev->mdev.ops = &cedrus_m2m_media_ops;\n\tdev->v4l2_dev.mdev = &dev->mdev;\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto err_m2m;\n\t}\n\n\tv4l2_info(&dev->v4l2_dev,\n\t\t  \"Device registered as /dev/video%d\\n\", vfd->num);\n\n\tret = v4l2_m2m_register_media_controller(dev->m2m_dev, vfd,\n\t\t\t\t\t\t MEDIA_ENT_F_PROC_VIDEO_DECODER);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Failed to initialize V4L2 M2M media controller\\n\");\n\t\tgoto err_video;\n\t}\n\n\tret = media_device_register(&dev->mdev);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register media device\\n\");\n\t\tgoto err_m2m_mc;\n\t}\n\n\treturn 0;\n\nerr_m2m_mc:\n\tv4l2_m2m_unregister_media_controller(dev->m2m_dev);\nerr_video:\n\tvideo_unregister_device(&dev->vfd);\nerr_m2m:\n\tv4l2_m2m_release(dev->m2m_dev);\nerr_v4l2:\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\n\treturn ret;\n}\n\nstatic void cedrus_remove(struct platform_device *pdev)\n{\n\tstruct cedrus_dev *dev = platform_get_drvdata(pdev);\n\n\tcancel_delayed_work_sync(&dev->watchdog_work);\n\tif (media_devnode_is_registered(dev->mdev.devnode)) {\n\t\tmedia_device_unregister(&dev->mdev);\n\t\tv4l2_m2m_unregister_media_controller(dev->m2m_dev);\n\t\tmedia_device_cleanup(&dev->mdev);\n\t}\n\n\tv4l2_m2m_release(dev->m2m_dev);\n\tvideo_unregister_device(&dev->vfd);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\n\tcedrus_hw_remove(dev);\n}\n\nstatic const struct cedrus_variant sun4i_a10_cedrus_variant = {\n\t.capabilities\t= CEDRUS_CAPABILITY_MPEG2_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H264_DEC |\n\t\t\t  CEDRUS_CAPABILITY_VP8_DEC,\n\t.mod_rate\t= 320000000,\n};\n\nstatic const struct cedrus_variant sun5i_a13_cedrus_variant = {\n\t.capabilities\t= CEDRUS_CAPABILITY_MPEG2_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H264_DEC |\n\t\t\t  CEDRUS_CAPABILITY_VP8_DEC,\n\t.mod_rate\t= 320000000,\n};\n\nstatic const struct cedrus_variant sun7i_a20_cedrus_variant = {\n\t.capabilities\t= CEDRUS_CAPABILITY_MPEG2_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H264_DEC |\n\t\t\t  CEDRUS_CAPABILITY_VP8_DEC,\n\t.mod_rate\t= 320000000,\n};\n\nstatic const struct cedrus_variant sun8i_a33_cedrus_variant = {\n\t.capabilities\t= CEDRUS_CAPABILITY_UNTILED |\n\t\t\t  CEDRUS_CAPABILITY_MPEG2_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H264_DEC |\n\t\t\t  CEDRUS_CAPABILITY_VP8_DEC,\n\t.mod_rate\t= 320000000,\n};\n\nstatic const struct cedrus_variant sun8i_h3_cedrus_variant = {\n\t.capabilities\t= CEDRUS_CAPABILITY_UNTILED |\n\t\t\t  CEDRUS_CAPABILITY_MPEG2_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H264_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H265_DEC |\n\t\t\t  CEDRUS_CAPABILITY_VP8_DEC,\n\t.mod_rate\t= 402000000,\n};\n\nstatic const struct cedrus_variant sun8i_v3s_cedrus_variant = {\n\t.capabilities\t= CEDRUS_CAPABILITY_UNTILED |\n\t\t\t  CEDRUS_CAPABILITY_H264_DEC,\n\t.mod_rate\t= 297000000,\n};\n\nstatic const struct cedrus_variant sun8i_r40_cedrus_variant = {\n\t.capabilities\t= CEDRUS_CAPABILITY_UNTILED |\n\t\t\t  CEDRUS_CAPABILITY_MPEG2_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H264_DEC |\n\t\t\t  CEDRUS_CAPABILITY_VP8_DEC,\n\t.mod_rate\t= 297000000,\n};\n\nstatic const struct cedrus_variant sun20i_d1_cedrus_variant = {\n\t.capabilities\t= CEDRUS_CAPABILITY_UNTILED |\n\t\t\t  CEDRUS_CAPABILITY_MPEG2_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H264_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H265_DEC,\n\t.mod_rate\t= 432000000,\n};\n\nstatic const struct cedrus_variant sun50i_a64_cedrus_variant = {\n\t.capabilities\t= CEDRUS_CAPABILITY_UNTILED |\n\t\t\t  CEDRUS_CAPABILITY_MPEG2_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H264_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H265_DEC |\n\t\t\t  CEDRUS_CAPABILITY_VP8_DEC,\n\t.mod_rate\t= 402000000,\n};\n\nstatic const struct cedrus_variant sun50i_h5_cedrus_variant = {\n\t.capabilities\t= CEDRUS_CAPABILITY_UNTILED |\n\t\t\t  CEDRUS_CAPABILITY_MPEG2_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H264_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H265_DEC |\n\t\t\t  CEDRUS_CAPABILITY_VP8_DEC,\n\t.mod_rate\t= 402000000,\n};\n\nstatic const struct cedrus_variant sun50i_h6_cedrus_variant = {\n\t.capabilities\t= CEDRUS_CAPABILITY_UNTILED |\n\t\t\t  CEDRUS_CAPABILITY_MPEG2_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H264_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H265_DEC |\n\t\t\t  CEDRUS_CAPABILITY_H265_10_DEC |\n\t\t\t  CEDRUS_CAPABILITY_VP8_DEC,\n\t.mod_rate\t= 600000000,\n};\n\nstatic const struct of_device_id cedrus_dt_match[] = {\n\t{\n\t\t.compatible = \"allwinner,sun4i-a10-video-engine\",\n\t\t.data = &sun4i_a10_cedrus_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun5i-a13-video-engine\",\n\t\t.data = &sun5i_a13_cedrus_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun7i-a20-video-engine\",\n\t\t.data = &sun7i_a20_cedrus_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun8i-a33-video-engine\",\n\t\t.data = &sun8i_a33_cedrus_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun8i-h3-video-engine\",\n\t\t.data = &sun8i_h3_cedrus_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun8i-v3s-video-engine\",\n\t\t.data = &sun8i_v3s_cedrus_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun8i-r40-video-engine\",\n\t\t.data = &sun8i_r40_cedrus_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun20i-d1-video-engine\",\n\t\t.data = &sun20i_d1_cedrus_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun50i-a64-video-engine\",\n\t\t.data = &sun50i_a64_cedrus_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun50i-h5-video-engine\",\n\t\t.data = &sun50i_h5_cedrus_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun50i-h6-video-engine\",\n\t\t.data = &sun50i_h6_cedrus_variant,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, cedrus_dt_match);\n\nstatic const struct dev_pm_ops cedrus_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(cedrus_hw_suspend,\n\t\t\t   cedrus_hw_resume, NULL)\n};\n\nstatic struct platform_driver cedrus_driver = {\n\t.probe\t\t= cedrus_probe,\n\t.remove_new\t= cedrus_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= CEDRUS_NAME,\n\t\t.of_match_table\t= of_match_ptr(cedrus_dt_match),\n\t\t.pm\t\t= &cedrus_dev_pm_ops,\n\t},\n};\nmodule_platform_driver(cedrus_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Florent Revest <florent.revest@free-electrons.com>\");\nMODULE_AUTHOR(\"Paul Kocialkowski <paul.kocialkowski@bootlin.com>\");\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@bootlin.com>\");\nMODULE_DESCRIPTION(\"Cedrus VPU driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}