{
  "module_name": "cedrus_hw.c",
  "hash_id": "bb752ad398fcffafcb9de4412250512125380fa330592b6b1a9192a257dd7474",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/sunxi/cedrus/cedrus_hw.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/soc/sunxi/sunxi_sram.h>\n\n#include <media/videobuf2-core.h>\n#include <media/v4l2-mem2mem.h>\n\n#include \"cedrus.h\"\n#include \"cedrus_hw.h\"\n#include \"cedrus_regs.h\"\n\nint cedrus_engine_enable(struct cedrus_ctx *ctx)\n{\n\tu32 reg = 0;\n\n\t \n\treg |= VE_MODE_REC_WR_MODE_2MB;\n\treg |= VE_MODE_DDR_MODE_BW_128;\n\n\tswitch (ctx->src_fmt.pixelformat) {\n\tcase V4L2_PIX_FMT_MPEG2_SLICE:\n\t\treg |= VE_MODE_DEC_MPEG;\n\t\tbreak;\n\n\t \n\tcase V4L2_PIX_FMT_H264_SLICE:\n\tcase V4L2_PIX_FMT_VP8_FRAME:\n\t\treg |= VE_MODE_DEC_H264;\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_HEVC_SLICE:\n\t\treg |= VE_MODE_DEC_H265;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->src_fmt.width == 4096)\n\t\treg |= VE_MODE_PIC_WIDTH_IS_4096;\n\tif (ctx->src_fmt.width > 2048)\n\t\treg |= VE_MODE_PIC_WIDTH_MORE_2048;\n\n\tcedrus_write(ctx->dev, VE_MODE, reg);\n\n\treturn 0;\n}\n\nvoid cedrus_engine_disable(struct cedrus_dev *dev)\n{\n\tcedrus_write(dev, VE_MODE, VE_MODE_DISABLED);\n}\n\nvoid cedrus_dst_format_set(struct cedrus_dev *dev,\n\t\t\t   struct v4l2_pix_format *fmt)\n{\n\tunsigned int width = fmt->width;\n\tunsigned int height = fmt->height;\n\tu32 chroma_size;\n\tu32 reg;\n\n\tswitch (fmt->pixelformat) {\n\tcase V4L2_PIX_FMT_NV12:\n\t\tchroma_size = ALIGN(width, 16) * ALIGN(height, 16) / 2;\n\n\t\treg = VE_PRIMARY_OUT_FMT_NV12;\n\t\tcedrus_write(dev, VE_PRIMARY_OUT_FMT, reg);\n\n\t\treg = chroma_size / 2;\n\t\tcedrus_write(dev, VE_PRIMARY_CHROMA_BUF_LEN, reg);\n\n\t\treg = VE_PRIMARY_FB_LINE_STRIDE_LUMA(ALIGN(width, 16)) |\n\t\t      VE_PRIMARY_FB_LINE_STRIDE_CHROMA(ALIGN(width, 16) / 2);\n\t\tcedrus_write(dev, VE_PRIMARY_FB_LINE_STRIDE, reg);\n\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12_32L32:\n\tdefault:\n\t\treg = VE_PRIMARY_OUT_FMT_TILED_32_NV12;\n\t\tcedrus_write(dev, VE_PRIMARY_OUT_FMT, reg);\n\n\t\treg = VE_SECONDARY_OUT_FMT_TILED_32_NV12;\n\t\tcedrus_write(dev, VE_CHROMA_BUF_LEN, reg);\n\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t cedrus_irq(int irq, void *data)\n{\n\tstruct cedrus_dev *dev = data;\n\tstruct cedrus_ctx *ctx;\n\tenum vb2_buffer_state state;\n\tenum cedrus_irq_status status;\n\n\t \n\tif (!cancel_delayed_work(&dev->watchdog_work))\n\t\treturn IRQ_HANDLED;\n\n\tctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);\n\tif (!ctx) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Instance released before the end of transaction\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tstatus = ctx->current_codec->irq_status(ctx);\n\tif (status == CEDRUS_IRQ_NONE)\n\t\treturn IRQ_NONE;\n\n\tctx->current_codec->irq_disable(ctx);\n\tctx->current_codec->irq_clear(ctx);\n\n\tif (status == CEDRUS_IRQ_ERROR)\n\t\tstate = VB2_BUF_STATE_ERROR;\n\telse\n\t\tstate = VB2_BUF_STATE_DONE;\n\n\tv4l2_m2m_buf_done_and_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx,\n\t\t\t\t\t state);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid cedrus_watchdog(struct work_struct *work)\n{\n\tstruct cedrus_dev *dev;\n\tstruct cedrus_ctx *ctx;\n\n\tdev = container_of(to_delayed_work(work),\n\t\t\t   struct cedrus_dev, watchdog_work);\n\n\tctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);\n\tif (!ctx)\n\t\treturn;\n\n\tv4l2_err(&dev->v4l2_dev, \"frame processing timed out!\\n\");\n\treset_control_reset(dev->rstc);\n\tv4l2_m2m_buf_done_and_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx,\n\t\t\t\t\t VB2_BUF_STATE_ERROR);\n}\n\nint cedrus_hw_suspend(struct device *device)\n{\n\tstruct cedrus_dev *dev = dev_get_drvdata(device);\n\n\tclk_disable_unprepare(dev->ram_clk);\n\tclk_disable_unprepare(dev->mod_clk);\n\tclk_disable_unprepare(dev->ahb_clk);\n\n\treset_control_assert(dev->rstc);\n\n\treturn 0;\n}\n\nint cedrus_hw_resume(struct device *device)\n{\n\tstruct cedrus_dev *dev = dev_get_drvdata(device);\n\tint ret;\n\n\tret = reset_control_reset(dev->rstc);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to apply reset\\n\");\n\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(dev->ahb_clk);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to enable AHB clock\\n\");\n\n\t\tgoto err_rst;\n\t}\n\n\tret = clk_prepare_enable(dev->mod_clk);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to enable MOD clock\\n\");\n\n\t\tgoto err_ahb_clk;\n\t}\n\n\tret = clk_prepare_enable(dev->ram_clk);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to enable RAM clock\\n\");\n\n\t\tgoto err_mod_clk;\n\t}\n\n\treturn 0;\n\nerr_mod_clk:\n\tclk_disable_unprepare(dev->mod_clk);\nerr_ahb_clk:\n\tclk_disable_unprepare(dev->ahb_clk);\nerr_rst:\n\treset_control_assert(dev->rstc);\n\n\treturn ret;\n}\n\nint cedrus_hw_probe(struct cedrus_dev *dev)\n{\n\tconst struct cedrus_variant *variant;\n\tint irq_dec;\n\tint ret;\n\n\tvariant = of_device_get_match_data(dev->dev);\n\tif (!variant)\n\t\treturn -EINVAL;\n\n\tdev->capabilities = variant->capabilities;\n\n\tirq_dec = platform_get_irq(dev->pdev, 0);\n\tif (irq_dec <= 0)\n\t\treturn irq_dec;\n\tret = devm_request_irq(dev->dev, irq_dec, cedrus_irq,\n\t\t\t       0, dev_name(dev->dev), dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to request IRQ\\n\");\n\n\t\treturn ret;\n\t}\n\n\tret = of_reserved_mem_device_init(dev->dev);\n\tif (ret && ret != -ENODEV) {\n\t\tdev_err(dev->dev, \"Failed to reserve memory\\n\");\n\n\t\treturn ret;\n\t}\n\n\tret = sunxi_sram_claim(dev->dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to claim SRAM\\n\");\n\n\t\tgoto err_mem;\n\t}\n\n\tdev->ahb_clk = devm_clk_get(dev->dev, \"ahb\");\n\tif (IS_ERR(dev->ahb_clk)) {\n\t\tdev_err(dev->dev, \"Failed to get AHB clock\\n\");\n\n\t\tret = PTR_ERR(dev->ahb_clk);\n\t\tgoto err_sram;\n\t}\n\n\tdev->mod_clk = devm_clk_get(dev->dev, \"mod\");\n\tif (IS_ERR(dev->mod_clk)) {\n\t\tdev_err(dev->dev, \"Failed to get MOD clock\\n\");\n\n\t\tret = PTR_ERR(dev->mod_clk);\n\t\tgoto err_sram;\n\t}\n\n\tdev->ram_clk = devm_clk_get(dev->dev, \"ram\");\n\tif (IS_ERR(dev->ram_clk)) {\n\t\tdev_err(dev->dev, \"Failed to get RAM clock\\n\");\n\n\t\tret = PTR_ERR(dev->ram_clk);\n\t\tgoto err_sram;\n\t}\n\n\tdev->rstc = devm_reset_control_get(dev->dev, NULL);\n\tif (IS_ERR(dev->rstc)) {\n\t\tdev_err(dev->dev, \"Failed to get reset control\\n\");\n\n\t\tret = PTR_ERR(dev->rstc);\n\t\tgoto err_sram;\n\t}\n\n\tdev->base = devm_platform_ioremap_resource(dev->pdev, 0);\n\tif (IS_ERR(dev->base)) {\n\t\tdev_err(dev->dev, \"Failed to map registers\\n\");\n\n\t\tret = PTR_ERR(dev->base);\n\t\tgoto err_sram;\n\t}\n\n\tret = clk_set_rate(dev->mod_clk, variant->mod_rate);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to set clock rate\\n\");\n\n\t\tgoto err_sram;\n\t}\n\n\tpm_runtime_enable(dev->dev);\n\tif (!pm_runtime_enabled(dev->dev)) {\n\t\tret = cedrus_hw_resume(dev->dev);\n\t\tif (ret)\n\t\t\tgoto err_pm;\n\t}\n\n\treturn 0;\n\nerr_pm:\n\tpm_runtime_disable(dev->dev);\nerr_sram:\n\tsunxi_sram_release(dev->dev);\nerr_mem:\n\tof_reserved_mem_device_release(dev->dev);\n\n\treturn ret;\n}\n\nvoid cedrus_hw_remove(struct cedrus_dev *dev)\n{\n\tpm_runtime_disable(dev->dev);\n\tif (!pm_runtime_status_suspended(dev->dev))\n\t\tcedrus_hw_suspend(dev->dev);\n\n\tsunxi_sram_release(dev->dev);\n\n\tof_reserved_mem_device_release(dev->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}