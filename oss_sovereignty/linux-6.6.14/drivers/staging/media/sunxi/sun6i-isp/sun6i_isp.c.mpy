{
  "module_name": "sun6i_isp.c",
  "hash_id": "e456eb92f9d1f304ab88c463e46f88be12ea4af2dcd7a0a3665dc218e546784d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/sunxi/sun6i-isp/sun6i_isp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-mc.h>\n\n#include \"sun6i_isp.h\"\n#include \"sun6i_isp_capture.h\"\n#include \"sun6i_isp_params.h\"\n#include \"sun6i_isp_proc.h\"\n#include \"sun6i_isp_reg.h\"\n\n \n\nu32 sun6i_isp_load_read(struct sun6i_isp_device *isp_dev, u32 offset)\n{\n\tu32 *data = (u32 *)(isp_dev->tables.load.data + offset);\n\n\treturn *data;\n}\n\nvoid sun6i_isp_load_write(struct sun6i_isp_device *isp_dev, u32 offset,\n\t\t\t  u32 value)\n{\n\tu32 *data = (u32 *)(isp_dev->tables.load.data + offset);\n\n\t*data = value;\n}\n\n \n\n \n\nstatic void sun6i_isp_state_ready(struct sun6i_isp_device *isp_dev)\n{\n\tstruct regmap *regmap = isp_dev->regmap;\n\tu32 value;\n\n\tregmap_read(regmap, SUN6I_ISP_FE_CTRL_REG, &value);\n\tvalue |= SUN6I_ISP_FE_CTRL_PARA_READY;\n\tregmap_write(regmap, SUN6I_ISP_FE_CTRL_REG, value);\n}\n\nstatic void sun6i_isp_state_complete(struct sun6i_isp_device *isp_dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&isp_dev->state_lock, flags);\n\n\tsun6i_isp_capture_state_complete(isp_dev);\n\tsun6i_isp_params_state_complete(isp_dev);\n\n\tspin_unlock_irqrestore(&isp_dev->state_lock, flags);\n}\n\nvoid sun6i_isp_state_update(struct sun6i_isp_device *isp_dev, bool ready_hold)\n{\n\tbool update = false;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&isp_dev->state_lock, flags);\n\n\tsun6i_isp_capture_state_update(isp_dev, &update);\n\tsun6i_isp_params_state_update(isp_dev, &update);\n\n\tif (update && !ready_hold)\n\t\tsun6i_isp_state_ready(isp_dev);\n\n\tspin_unlock_irqrestore(&isp_dev->state_lock, flags);\n}\n\n \n\nstatic int sun6i_isp_table_setup(struct sun6i_isp_device *isp_dev,\n\t\t\t\t struct sun6i_isp_table *table)\n{\n\ttable->data = dma_alloc_coherent(isp_dev->dev, table->size,\n\t\t\t\t\t &table->address, GFP_KERNEL);\n\tif (!table->data)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void sun6i_isp_table_cleanup(struct sun6i_isp_device *isp_dev,\n\t\t\t\t    struct sun6i_isp_table *table)\n{\n\tdma_free_coherent(isp_dev->dev, table->size, table->data,\n\t\t\t  table->address);\n}\n\nvoid sun6i_isp_tables_configure(struct sun6i_isp_device *isp_dev)\n{\n\tstruct regmap *regmap = isp_dev->regmap;\n\n\tregmap_write(regmap, SUN6I_ISP_REG_LOAD_ADDR_REG,\n\t\t     SUN6I_ISP_ADDR_VALUE(isp_dev->tables.load.address));\n\n\tregmap_write(regmap, SUN6I_ISP_REG_SAVE_ADDR_REG,\n\t\t     SUN6I_ISP_ADDR_VALUE(isp_dev->tables.save.address));\n\n\tregmap_write(regmap, SUN6I_ISP_LUT_TABLE_ADDR_REG,\n\t\t     SUN6I_ISP_ADDR_VALUE(isp_dev->tables.lut.address));\n\n\tregmap_write(regmap, SUN6I_ISP_DRC_TABLE_ADDR_REG,\n\t\t     SUN6I_ISP_ADDR_VALUE(isp_dev->tables.drc.address));\n\n\tregmap_write(regmap, SUN6I_ISP_STATS_ADDR_REG,\n\t\t     SUN6I_ISP_ADDR_VALUE(isp_dev->tables.stats.address));\n}\n\nstatic int sun6i_isp_tables_setup(struct sun6i_isp_device *isp_dev,\n\t\t\t\t  const struct sun6i_isp_variant *variant)\n{\n\tstruct sun6i_isp_tables *tables = &isp_dev->tables;\n\tint ret;\n\n\ttables->load.size = variant->table_load_save_size;\n\tret = sun6i_isp_table_setup(isp_dev, &tables->load);\n\tif (ret)\n\t\treturn ret;\n\n\ttables->save.size = variant->table_load_save_size;\n\tret = sun6i_isp_table_setup(isp_dev, &tables->save);\n\tif (ret)\n\t\treturn ret;\n\n\ttables->lut.size = variant->table_lut_size;\n\tret = sun6i_isp_table_setup(isp_dev, &tables->lut);\n\tif (ret)\n\t\treturn ret;\n\n\ttables->drc.size = variant->table_drc_size;\n\tret = sun6i_isp_table_setup(isp_dev, &tables->drc);\n\tif (ret)\n\t\treturn ret;\n\n\ttables->stats.size = variant->table_stats_size;\n\tret = sun6i_isp_table_setup(isp_dev, &tables->stats);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void sun6i_isp_tables_cleanup(struct sun6i_isp_device *isp_dev)\n{\n\tstruct sun6i_isp_tables *tables = &isp_dev->tables;\n\n\tsun6i_isp_table_cleanup(isp_dev, &tables->stats);\n\tsun6i_isp_table_cleanup(isp_dev, &tables->drc);\n\tsun6i_isp_table_cleanup(isp_dev, &tables->lut);\n\tsun6i_isp_table_cleanup(isp_dev, &tables->save);\n\tsun6i_isp_table_cleanup(isp_dev, &tables->load);\n}\n\n \n\nstatic const struct media_device_ops sun6i_isp_media_ops = {\n\t.link_notify = v4l2_pipeline_link_notify,\n};\n\n \n\nstatic int sun6i_isp_v4l2_setup(struct sun6i_isp_device *isp_dev)\n{\n\tstruct sun6i_isp_v4l2 *v4l2 = &isp_dev->v4l2;\n\tstruct v4l2_device *v4l2_dev = &v4l2->v4l2_dev;\n\tstruct media_device *media_dev = &v4l2->media_dev;\n\tstruct device *dev = isp_dev->dev;\n\tint ret;\n\n\t \n\n\tstrscpy(media_dev->model, SUN6I_ISP_DESCRIPTION,\n\t\tsizeof(media_dev->model));\n\tmedia_dev->ops = &sun6i_isp_media_ops;\n\tmedia_dev->hw_revision = 0;\n\tmedia_dev->dev = dev;\n\n\tmedia_device_init(media_dev);\n\n\tret = media_device_register(media_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register media device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\tv4l2_dev->mdev = media_dev;\n\n\tret = v4l2_device_register(dev, v4l2_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register v4l2 device\\n\");\n\t\tgoto error_media;\n\t}\n\n\treturn 0;\n\nerror_media:\n\tmedia_device_unregister(media_dev);\n\tmedia_device_cleanup(media_dev);\n\n\treturn ret;\n}\n\nstatic void sun6i_isp_v4l2_cleanup(struct sun6i_isp_device *isp_dev)\n{\n\tstruct sun6i_isp_v4l2 *v4l2 = &isp_dev->v4l2;\n\n\tmedia_device_unregister(&v4l2->media_dev);\n\tv4l2_device_unregister(&v4l2->v4l2_dev);\n\tmedia_device_cleanup(&v4l2->media_dev);\n}\n\n \n\nstatic irqreturn_t sun6i_isp_interrupt(int irq, void *private)\n{\n\tstruct sun6i_isp_device *isp_dev = private;\n\tstruct regmap *regmap = isp_dev->regmap;\n\tu32 status = 0, enable = 0;\n\n\tregmap_read(regmap, SUN6I_ISP_FE_INT_STA_REG, &status);\n\tregmap_read(regmap, SUN6I_ISP_FE_INT_EN_REG, &enable);\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\telse if (!(status & enable))\n\t\tgoto complete;\n\n\t \n\n\tif (status & SUN6I_ISP_FE_INT_STA_FINISH)\n\t\tsun6i_isp_capture_finish(isp_dev);\n\n\tif (status & SUN6I_ISP_FE_INT_STA_PARA_LOAD) {\n\t\tsun6i_isp_state_complete(isp_dev);\n\t\tsun6i_isp_state_update(isp_dev, false);\n\t}\n\ncomplete:\n\tregmap_write(regmap, SUN6I_ISP_FE_INT_STA_REG, status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sun6i_isp_suspend(struct device *dev)\n{\n\tstruct sun6i_isp_device *isp_dev = dev_get_drvdata(dev);\n\n\treset_control_assert(isp_dev->reset);\n\tclk_disable_unprepare(isp_dev->clock_ram);\n\tclk_disable_unprepare(isp_dev->clock_mod);\n\n\treturn 0;\n}\n\nstatic int sun6i_isp_resume(struct device *dev)\n{\n\tstruct sun6i_isp_device *isp_dev = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = reset_control_deassert(isp_dev->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to deassert reset\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(isp_dev->clock_mod);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable module clock\\n\");\n\t\tgoto error_reset;\n\t}\n\n\tret = clk_prepare_enable(isp_dev->clock_ram);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable ram clock\\n\");\n\t\tgoto error_clock_mod;\n\t}\n\n\treturn 0;\n\nerror_clock_mod:\n\tclk_disable_unprepare(isp_dev->clock_mod);\n\nerror_reset:\n\treset_control_assert(isp_dev->reset);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops sun6i_isp_pm_ops = {\n\t.runtime_suspend\t= sun6i_isp_suspend,\n\t.runtime_resume\t\t= sun6i_isp_resume,\n};\n\nstatic const struct regmap_config sun6i_isp_regmap_config = {\n\t.reg_bits       = 32,\n\t.reg_stride     = 4,\n\t.val_bits       = 32,\n\t.max_register\t= 0x400,\n};\n\nstatic int sun6i_isp_resources_setup(struct sun6i_isp_device *isp_dev,\n\t\t\t\t     struct platform_device *platform_dev)\n{\n\tstruct device *dev = isp_dev->dev;\n\tvoid __iomem *io_base;\n\tint irq;\n\tint ret;\n\n\t \n\n\tio_base = devm_platform_ioremap_resource(platform_dev, 0);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\tisp_dev->regmap = devm_regmap_init_mmio_clk(dev, \"bus\", io_base,\n\t\t\t\t\t\t    &sun6i_isp_regmap_config);\n\tif (IS_ERR(isp_dev->regmap)) {\n\t\tdev_err(dev, \"failed to init register map\\n\");\n\t\treturn PTR_ERR(isp_dev->regmap);\n\t}\n\n\t \n\n\tisp_dev->clock_mod = devm_clk_get(dev, \"mod\");\n\tif (IS_ERR(isp_dev->clock_mod)) {\n\t\tdev_err(dev, \"failed to acquire module clock\\n\");\n\t\treturn PTR_ERR(isp_dev->clock_mod);\n\t}\n\n\tisp_dev->clock_ram = devm_clk_get(dev, \"ram\");\n\tif (IS_ERR(isp_dev->clock_ram)) {\n\t\tdev_err(dev, \"failed to acquire ram clock\\n\");\n\t\treturn PTR_ERR(isp_dev->clock_ram);\n\t}\n\n\tret = clk_set_rate_exclusive(isp_dev->clock_mod, 297000000);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set mod clock rate\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\tisp_dev->reset = devm_reset_control_get_shared(dev, NULL);\n\tif (IS_ERR(isp_dev->reset)) {\n\t\tdev_err(dev, \"failed to acquire reset\\n\");\n\t\tret = PTR_ERR(isp_dev->reset);\n\t\tgoto error_clock_rate_exclusive;\n\t}\n\n\t \n\n\tirq = platform_get_irq(platform_dev, 0);\n\tif (irq < 0) {\n\t\tdev_err(dev, \"failed to get interrupt\\n\");\n\t\tret = -ENXIO;\n\t\tgoto error_clock_rate_exclusive;\n\t}\n\n\tret = devm_request_irq(dev, irq, sun6i_isp_interrupt, IRQF_SHARED,\n\t\t\t       SUN6I_ISP_NAME, isp_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request interrupt\\n\");\n\t\tgoto error_clock_rate_exclusive;\n\t}\n\n\t \n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\nerror_clock_rate_exclusive:\n\tclk_rate_exclusive_put(isp_dev->clock_mod);\n\n\treturn ret;\n}\n\nstatic void sun6i_isp_resources_cleanup(struct sun6i_isp_device *isp_dev)\n{\n\tstruct device *dev = isp_dev->dev;\n\n\tpm_runtime_disable(dev);\n\tclk_rate_exclusive_put(isp_dev->clock_mod);\n}\n\nstatic int sun6i_isp_probe(struct platform_device *platform_dev)\n{\n\tstruct sun6i_isp_device *isp_dev;\n\tstruct device *dev = &platform_dev->dev;\n\tconst struct sun6i_isp_variant *variant;\n\tint ret;\n\n\tvariant = of_device_get_match_data(dev);\n\tif (!variant)\n\t\treturn -EINVAL;\n\n\tisp_dev = devm_kzalloc(dev, sizeof(*isp_dev), GFP_KERNEL);\n\tif (!isp_dev)\n\t\treturn -ENOMEM;\n\n\tisp_dev->dev = dev;\n\tplatform_set_drvdata(platform_dev, isp_dev);\n\n\tspin_lock_init(&isp_dev->state_lock);\n\n\tret = sun6i_isp_resources_setup(isp_dev, platform_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sun6i_isp_tables_setup(isp_dev, variant);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to setup tables\\n\");\n\t\tgoto error_resources;\n\t}\n\n\tret = sun6i_isp_v4l2_setup(isp_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to setup v4l2\\n\");\n\t\tgoto error_tables;\n\t}\n\n\tret = sun6i_isp_proc_setup(isp_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to setup proc\\n\");\n\t\tgoto error_v4l2;\n\t}\n\n\tret = sun6i_isp_capture_setup(isp_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to setup capture\\n\");\n\t\tgoto error_proc;\n\t}\n\n\tret = sun6i_isp_params_setup(isp_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to setup params\\n\");\n\t\tgoto error_capture;\n\t}\n\n\treturn 0;\n\nerror_capture:\n\tsun6i_isp_capture_cleanup(isp_dev);\n\nerror_proc:\n\tsun6i_isp_proc_cleanup(isp_dev);\n\nerror_v4l2:\n\tsun6i_isp_v4l2_cleanup(isp_dev);\n\nerror_tables:\n\tsun6i_isp_tables_cleanup(isp_dev);\n\nerror_resources:\n\tsun6i_isp_resources_cleanup(isp_dev);\n\n\treturn ret;\n}\n\nstatic void sun6i_isp_remove(struct platform_device *platform_dev)\n{\n\tstruct sun6i_isp_device *isp_dev = platform_get_drvdata(platform_dev);\n\n\tsun6i_isp_params_cleanup(isp_dev);\n\tsun6i_isp_capture_cleanup(isp_dev);\n\tsun6i_isp_proc_cleanup(isp_dev);\n\tsun6i_isp_v4l2_cleanup(isp_dev);\n\tsun6i_isp_tables_cleanup(isp_dev);\n\tsun6i_isp_resources_cleanup(isp_dev);\n}\n\n \n\nstatic const struct sun6i_isp_variant sun8i_v3s_isp_variant = {\n\t.table_load_save_size\t= 0x1000,\n\t.table_lut_size\t\t= 0xe00,\n\t.table_drc_size\t\t= 0x600,\n\t.table_stats_size\t= 0x2100,\n};\n\nstatic const struct of_device_id sun6i_isp_of_match[] = {\n\t{\n\t\t.compatible\t= \"allwinner,sun8i-v3s-isp\",\n\t\t.data\t\t= &sun8i_v3s_isp_variant,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, sun6i_isp_of_match);\n\nstatic struct platform_driver sun6i_isp_platform_driver = {\n\t.probe\t= sun6i_isp_probe,\n\t.remove_new = sun6i_isp_remove,\n\t.driver\t= {\n\t\t.name\t\t= SUN6I_ISP_NAME,\n\t\t.of_match_table\t= sun6i_isp_of_match,\n\t\t.pm\t\t= &sun6i_isp_pm_ops,\n\t},\n};\n\nmodule_platform_driver(sun6i_isp_platform_driver);\n\nMODULE_DESCRIPTION(\"Allwinner A31 Image Signal Processor driver\");\nMODULE_AUTHOR(\"Paul Kocialkowski <paul.kocialkowski@bootlin.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}