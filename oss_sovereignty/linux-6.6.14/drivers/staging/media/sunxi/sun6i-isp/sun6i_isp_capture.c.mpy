{
  "module_name": "sun6i_isp_capture.c",
  "hash_id": "f51ef301fe8fe93998af07b1da62ed88ea8480a4e4bcdc6fcb01e19a2caa8e28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/sunxi/sun6i-isp/sun6i_isp_capture.c",
  "human_readable_source": "\n \n\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mc.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-v4l2.h>\n\n#include \"sun6i_isp.h\"\n#include \"sun6i_isp_capture.h\"\n#include \"sun6i_isp_proc.h\"\n#include \"sun6i_isp_reg.h\"\n\n \n\nvoid sun6i_isp_capture_dimensions(struct sun6i_isp_device *isp_dev,\n\t\t\t\t  unsigned int *width, unsigned int *height)\n{\n\tif (width)\n\t\t*width = isp_dev->capture.format.fmt.pix.width;\n\tif (height)\n\t\t*height = isp_dev->capture.format.fmt.pix.height;\n}\n\nvoid sun6i_isp_capture_format(struct sun6i_isp_device *isp_dev,\n\t\t\t      u32 *pixelformat)\n{\n\tif (pixelformat)\n\t\t*pixelformat = isp_dev->capture.format.fmt.pix.pixelformat;\n}\n\n \n\nstatic const struct sun6i_isp_capture_format sun6i_isp_capture_formats[] = {\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_NV12,\n\t\t.output_format\t\t= SUN6I_ISP_OUTPUT_FMT_YUV420SP,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_NV21,\n\t\t.output_format\t\t= SUN6I_ISP_OUTPUT_FMT_YVU420SP,\n\t},\n};\n\nconst struct sun6i_isp_capture_format *\nsun6i_isp_capture_format_find(u32 pixelformat)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sun6i_isp_capture_formats); i++)\n\t\tif (sun6i_isp_capture_formats[i].pixelformat == pixelformat)\n\t\t\treturn &sun6i_isp_capture_formats[i];\n\n\treturn NULL;\n}\n\n \n\nstatic void\nsun6i_isp_capture_buffer_configure(struct sun6i_isp_device *isp_dev,\n\t\t\t\t   struct sun6i_isp_buffer *isp_buffer)\n{\n\tconst struct v4l2_format_info *info;\n\tstruct vb2_buffer *vb2_buffer;\n\tunsigned int width, height;\n\tunsigned int width_aligned;\n\tdma_addr_t address;\n\tu32 pixelformat;\n\n\tvb2_buffer = &isp_buffer->v4l2_buffer.vb2_buf;\n\taddress = vb2_dma_contig_plane_dma_addr(vb2_buffer, 0);\n\n\tsun6i_isp_load_write(isp_dev, SUN6I_ISP_MCH_Y_ADDR0_REG,\n\t\t\t     SUN6I_ISP_ADDR_VALUE(address));\n\n\tsun6i_isp_capture_dimensions(isp_dev, &width, &height);\n\tsun6i_isp_capture_format(isp_dev, &pixelformat);\n\n\tinfo = v4l2_format_info(pixelformat);\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\t \n\twidth_aligned = ALIGN(width, 2);\n\n\tif (info->comp_planes > 1) {\n\t\taddress += info->bpp[0] * width_aligned * height;\n\n\t\tsun6i_isp_load_write(isp_dev, SUN6I_ISP_MCH_U_ADDR0_REG,\n\t\t\t\t     SUN6I_ISP_ADDR_VALUE(address));\n\t}\n\n\tif (info->comp_planes > 2) {\n\t\taddress += info->bpp[1] *\n\t\t\t   DIV_ROUND_UP(width_aligned, info->hdiv) *\n\t\t\t   DIV_ROUND_UP(height, info->vdiv);\n\n\t\tsun6i_isp_load_write(isp_dev, SUN6I_ISP_MCH_V_ADDR0_REG,\n\t\t\t\t     SUN6I_ISP_ADDR_VALUE(address));\n\t}\n}\n\nvoid sun6i_isp_capture_configure(struct sun6i_isp_device *isp_dev)\n{\n\tunsigned int width, height;\n\tunsigned int stride_luma, stride_chroma;\n\tunsigned int stride_luma_div4, stride_chroma_div4 = 0;\n\tconst struct sun6i_isp_capture_format *format;\n\tconst struct v4l2_format_info *info;\n\tu32 pixelformat;\n\n\tsun6i_isp_capture_dimensions(isp_dev, &width, &height);\n\tsun6i_isp_capture_format(isp_dev, &pixelformat);\n\n\tformat = sun6i_isp_capture_format_find(pixelformat);\n\tif (WARN_ON(!format))\n\t\treturn;\n\n\tsun6i_isp_load_write(isp_dev, SUN6I_ISP_MCH_SIZE_CFG_REG,\n\t\t\t     SUN6I_ISP_MCH_SIZE_CFG_WIDTH(width) |\n\t\t\t     SUN6I_ISP_MCH_SIZE_CFG_HEIGHT(height));\n\n\tinfo = v4l2_format_info(pixelformat);\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\tstride_luma = width * info->bpp[0];\n\tstride_luma_div4 = DIV_ROUND_UP(stride_luma, 4);\n\n\tif (info->comp_planes > 1) {\n\t\tstride_chroma = width * info->bpp[1] / info->hdiv;\n\t\tstride_chroma_div4 = DIV_ROUND_UP(stride_chroma, 4);\n\t}\n\n\tsun6i_isp_load_write(isp_dev, SUN6I_ISP_MCH_CFG_REG,\n\t\t\t     SUN6I_ISP_MCH_CFG_EN |\n\t\t\t     SUN6I_ISP_MCH_CFG_OUTPUT_FMT(format->output_format) |\n\t\t\t     SUN6I_ISP_MCH_CFG_STRIDE_Y_DIV4(stride_luma_div4) |\n\t\t\t     SUN6I_ISP_MCH_CFG_STRIDE_UV_DIV4(stride_chroma_div4));\n}\n\n \n\nstatic void sun6i_isp_capture_state_cleanup(struct sun6i_isp_device *isp_dev,\n\t\t\t\t\t    bool error)\n{\n\tstruct sun6i_isp_capture_state *state = &isp_dev->capture.state;\n\tstruct sun6i_isp_buffer **isp_buffer_states[] = {\n\t\t&state->pending, &state->current, &state->complete,\n\t};\n\tstruct sun6i_isp_buffer *isp_buffer;\n\tstruct vb2_buffer *vb2_buffer;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&state->lock, flags);\n\n\tfor (i = 0; i < ARRAY_SIZE(isp_buffer_states); i++) {\n\t\tisp_buffer = *isp_buffer_states[i];\n\t\tif (!isp_buffer)\n\t\t\tcontinue;\n\n\t\tvb2_buffer = &isp_buffer->v4l2_buffer.vb2_buf;\n\t\tvb2_buffer_done(vb2_buffer, error ? VB2_BUF_STATE_ERROR :\n\t\t\t\tVB2_BUF_STATE_QUEUED);\n\n\t\t*isp_buffer_states[i] = NULL;\n\t}\n\n\tlist_for_each_entry(isp_buffer, &state->queue, list) {\n\t\tvb2_buffer = &isp_buffer->v4l2_buffer.vb2_buf;\n\t\tvb2_buffer_done(vb2_buffer, error ? VB2_BUF_STATE_ERROR :\n\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t}\n\n\tINIT_LIST_HEAD(&state->queue);\n\n\tspin_unlock_irqrestore(&state->lock, flags);\n}\n\nvoid sun6i_isp_capture_state_update(struct sun6i_isp_device *isp_dev,\n\t\t\t\t    bool *update)\n{\n\tstruct sun6i_isp_capture_state *state = &isp_dev->capture.state;\n\tstruct sun6i_isp_buffer *isp_buffer;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&state->lock, flags);\n\n\tif (list_empty(&state->queue))\n\t\tgoto complete;\n\n\tif (state->pending)\n\t\tgoto complete;\n\n\tisp_buffer = list_first_entry(&state->queue, struct sun6i_isp_buffer,\n\t\t\t\t      list);\n\n\tsun6i_isp_capture_buffer_configure(isp_dev, isp_buffer);\n\n\tlist_del(&isp_buffer->list);\n\n\tstate->pending = isp_buffer;\n\n\tif (update)\n\t\t*update = true;\n\ncomplete:\n\tspin_unlock_irqrestore(&state->lock, flags);\n}\n\nvoid sun6i_isp_capture_state_complete(struct sun6i_isp_device *isp_dev)\n{\n\tstruct sun6i_isp_capture_state *state = &isp_dev->capture.state;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&state->lock, flags);\n\n\tif (!state->pending)\n\t\tgoto complete;\n\n\tstate->complete = state->current;\n\tstate->current = state->pending;\n\tstate->pending = NULL;\n\n\tif (state->complete) {\n\t\tstruct sun6i_isp_buffer *isp_buffer = state->complete;\n\t\tstruct vb2_buffer *vb2_buffer =\n\t\t\t&isp_buffer->v4l2_buffer.vb2_buf;\n\n\t\tvb2_buffer->timestamp = ktime_get_ns();\n\t\tisp_buffer->v4l2_buffer.sequence = state->sequence;\n\n\t\tvb2_buffer_done(vb2_buffer, VB2_BUF_STATE_DONE);\n\n\t\tstate->complete = NULL;\n\t}\n\ncomplete:\n\tspin_unlock_irqrestore(&state->lock, flags);\n}\n\nvoid sun6i_isp_capture_finish(struct sun6i_isp_device *isp_dev)\n{\n\tstruct sun6i_isp_capture_state *state = &isp_dev->capture.state;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&state->lock, flags);\n\tstate->sequence++;\n\tspin_unlock_irqrestore(&state->lock, flags);\n}\n\n \n\nstatic int sun6i_isp_capture_queue_setup(struct vb2_queue *queue,\n\t\t\t\t\t unsigned int *buffers_count,\n\t\t\t\t\t unsigned int *planes_count,\n\t\t\t\t\t unsigned int sizes[],\n\t\t\t\t\t struct device *alloc_devs[])\n{\n\tstruct sun6i_isp_device *isp_dev = vb2_get_drv_priv(queue);\n\tunsigned int size = isp_dev->capture.format.fmt.pix.sizeimage;\n\n\tif (*planes_count)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*planes_count = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic int sun6i_isp_capture_buffer_prepare(struct vb2_buffer *vb2_buffer)\n{\n\tstruct sun6i_isp_device *isp_dev =\n\t\tvb2_get_drv_priv(vb2_buffer->vb2_queue);\n\tstruct v4l2_device *v4l2_dev = &isp_dev->v4l2.v4l2_dev;\n\tunsigned int size = isp_dev->capture.format.fmt.pix.sizeimage;\n\n\tif (vb2_plane_size(vb2_buffer, 0) < size) {\n\t\tv4l2_err(v4l2_dev, \"buffer too small (%lu < %u)\\n\",\n\t\t\t vb2_plane_size(vb2_buffer, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb2_buffer, 0, size);\n\n\treturn 0;\n}\n\nstatic void sun6i_isp_capture_buffer_queue(struct vb2_buffer *vb2_buffer)\n{\n\tstruct sun6i_isp_device *isp_dev =\n\t\tvb2_get_drv_priv(vb2_buffer->vb2_queue);\n\tstruct sun6i_isp_capture_state *state = &isp_dev->capture.state;\n\tstruct vb2_v4l2_buffer *v4l2_buffer = to_vb2_v4l2_buffer(vb2_buffer);\n\tstruct sun6i_isp_buffer *isp_buffer =\n\t\tcontainer_of(v4l2_buffer, struct sun6i_isp_buffer, v4l2_buffer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&state->lock, flags);\n\tlist_add_tail(&isp_buffer->list, &state->queue);\n\tspin_unlock_irqrestore(&state->lock, flags);\n\n\t \n\tif (state->streaming)\n\t\tsun6i_isp_state_update(isp_dev, false);\n}\n\nstatic int sun6i_isp_capture_start_streaming(struct vb2_queue *queue,\n\t\t\t\t\t     unsigned int count)\n{\n\tstruct sun6i_isp_device *isp_dev = vb2_get_drv_priv(queue);\n\tstruct sun6i_isp_capture_state *state = &isp_dev->capture.state;\n\tstruct video_device *video_dev = &isp_dev->capture.video_dev;\n\tstruct v4l2_subdev *subdev = &isp_dev->proc.subdev;\n\tint ret;\n\n\tstate->sequence = 0;\n\n\tret = video_device_pipeline_alloc_start(video_dev);\n\tif (ret < 0)\n\t\tgoto error_state;\n\n\tstate->streaming = true;\n\n\tret = v4l2_subdev_call(subdev, video, s_stream, 1);\n\tif (ret && ret != -ENOIOCTLCMD)\n\t\tgoto error_streaming;\n\n\treturn 0;\n\nerror_streaming:\n\tstate->streaming = false;\n\n\tvideo_device_pipeline_stop(video_dev);\n\nerror_state:\n\tsun6i_isp_capture_state_cleanup(isp_dev, false);\n\n\treturn ret;\n}\n\nstatic void sun6i_isp_capture_stop_streaming(struct vb2_queue *queue)\n{\n\tstruct sun6i_isp_device *isp_dev = vb2_get_drv_priv(queue);\n\tstruct sun6i_isp_capture_state *state = &isp_dev->capture.state;\n\tstruct video_device *video_dev = &isp_dev->capture.video_dev;\n\tstruct v4l2_subdev *subdev = &isp_dev->proc.subdev;\n\n\tv4l2_subdev_call(subdev, video, s_stream, 0);\n\n\tstate->streaming = false;\n\n\tvideo_device_pipeline_stop(video_dev);\n\n\tsun6i_isp_capture_state_cleanup(isp_dev, true);\n}\n\nstatic const struct vb2_ops sun6i_isp_capture_queue_ops = {\n\t.queue_setup\t\t= sun6i_isp_capture_queue_setup,\n\t.buf_prepare\t\t= sun6i_isp_capture_buffer_prepare,\n\t.buf_queue\t\t= sun6i_isp_capture_buffer_queue,\n\t.start_streaming\t= sun6i_isp_capture_start_streaming,\n\t.stop_streaming\t\t= sun6i_isp_capture_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n \n\nstatic void sun6i_isp_capture_format_prepare(struct v4l2_format *format)\n{\n\tstruct v4l2_pix_format *pix_format = &format->fmt.pix;\n\tconst struct v4l2_format_info *info;\n\tunsigned int width, height;\n\tunsigned int width_aligned;\n\tunsigned int i;\n\n\tv4l_bound_align_image(&pix_format->width, SUN6I_ISP_CAPTURE_WIDTH_MIN,\n\t\t\t      SUN6I_ISP_CAPTURE_WIDTH_MAX, 1,\n\t\t\t      &pix_format->height, SUN6I_ISP_CAPTURE_HEIGHT_MIN,\n\t\t\t      SUN6I_ISP_CAPTURE_HEIGHT_MAX, 1, 0);\n\n\tif (!sun6i_isp_capture_format_find(pix_format->pixelformat))\n\t\tpix_format->pixelformat =\n\t\t\tsun6i_isp_capture_formats[0].pixelformat;\n\n\tinfo = v4l2_format_info(pix_format->pixelformat);\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\twidth = pix_format->width;\n\theight = pix_format->height;\n\n\t \n\twidth_aligned = ALIGN(width, 2);\n\n\tpix_format->bytesperline = width_aligned * info->bpp[0];\n\tpix_format->sizeimage = 0;\n\n\tfor (i = 0; i < info->comp_planes; i++) {\n\t\tunsigned int hdiv = (i == 0) ? 1 : info->hdiv;\n\t\tunsigned int vdiv = (i == 0) ? 1 : info->vdiv;\n\n\t\tpix_format->sizeimage += info->bpp[i] *\n\t\t\t\t\t DIV_ROUND_UP(width_aligned, hdiv) *\n\t\t\t\t\t DIV_ROUND_UP(height, vdiv);\n\t}\n\n\tpix_format->field = V4L2_FIELD_NONE;\n\n\tpix_format->colorspace = V4L2_COLORSPACE_RAW;\n\tpix_format->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tpix_format->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tpix_format->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n}\n\nstatic int sun6i_isp_capture_querycap(struct file *file, void *private,\n\t\t\t\t      struct v4l2_capability *capability)\n{\n\tstruct sun6i_isp_device *isp_dev = video_drvdata(file);\n\tstruct video_device *video_dev = &isp_dev->capture.video_dev;\n\n\tstrscpy(capability->driver, SUN6I_ISP_NAME, sizeof(capability->driver));\n\tstrscpy(capability->card, video_dev->name, sizeof(capability->card));\n\tsnprintf(capability->bus_info, sizeof(capability->bus_info),\n\t\t \"platform:%s\", dev_name(isp_dev->dev));\n\n\treturn 0;\n}\n\nstatic int sun6i_isp_capture_enum_fmt(struct file *file, void *private,\n\t\t\t\t      struct v4l2_fmtdesc *fmtdesc)\n{\n\tu32 index = fmtdesc->index;\n\n\tif (index >= ARRAY_SIZE(sun6i_isp_capture_formats))\n\t\treturn -EINVAL;\n\n\tfmtdesc->pixelformat = sun6i_isp_capture_formats[index].pixelformat;\n\n\treturn 0;\n}\n\nstatic int sun6i_isp_capture_g_fmt(struct file *file, void *private,\n\t\t\t\t   struct v4l2_format *format)\n{\n\tstruct sun6i_isp_device *isp_dev = video_drvdata(file);\n\n\t*format = isp_dev->capture.format;\n\n\treturn 0;\n}\n\nstatic int sun6i_isp_capture_s_fmt(struct file *file, void *private,\n\t\t\t\t   struct v4l2_format *format)\n{\n\tstruct sun6i_isp_device *isp_dev = video_drvdata(file);\n\n\tif (vb2_is_busy(&isp_dev->capture.queue))\n\t\treturn -EBUSY;\n\n\tsun6i_isp_capture_format_prepare(format);\n\n\tisp_dev->capture.format = *format;\n\n\treturn 0;\n}\n\nstatic int sun6i_isp_capture_try_fmt(struct file *file, void *private,\n\t\t\t\t     struct v4l2_format *format)\n{\n\tsun6i_isp_capture_format_prepare(format);\n\n\treturn 0;\n}\n\nstatic int sun6i_isp_capture_enum_input(struct file *file, void *private,\n\t\t\t\t\tstruct v4l2_input *input)\n{\n\tif (input->index != 0)\n\t\treturn -EINVAL;\n\n\tinput->type = V4L2_INPUT_TYPE_CAMERA;\n\tstrscpy(input->name, \"Camera\", sizeof(input->name));\n\n\treturn 0;\n}\n\nstatic int sun6i_isp_capture_g_input(struct file *file, void *private,\n\t\t\t\t     unsigned int *index)\n{\n\t*index = 0;\n\n\treturn 0;\n}\n\nstatic int sun6i_isp_capture_s_input(struct file *file, void *private,\n\t\t\t\t     unsigned int index)\n{\n\tif (index != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops sun6i_isp_capture_ioctl_ops = {\n\t.vidioc_querycap\t\t= sun6i_isp_capture_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= sun6i_isp_capture_enum_fmt,\n\t.vidioc_g_fmt_vid_cap\t\t= sun6i_isp_capture_g_fmt,\n\t.vidioc_s_fmt_vid_cap\t\t= sun6i_isp_capture_s_fmt,\n\t.vidioc_try_fmt_vid_cap\t\t= sun6i_isp_capture_try_fmt,\n\n\t.vidioc_enum_input\t\t= sun6i_isp_capture_enum_input,\n\t.vidioc_g_input\t\t\t= sun6i_isp_capture_g_input,\n\t.vidioc_s_input\t\t\t= sun6i_isp_capture_s_input,\n\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n};\n\nstatic int sun6i_isp_capture_open(struct file *file)\n{\n\tstruct sun6i_isp_device *isp_dev = video_drvdata(file);\n\tstruct video_device *video_dev = &isp_dev->capture.video_dev;\n\tstruct mutex *lock = &isp_dev->capture.lock;\n\tint ret;\n\n\tif (mutex_lock_interruptible(lock))\n\t\treturn -ERESTARTSYS;\n\n\tret = v4l2_pipeline_pm_get(&video_dev->entity);\n\tif (ret)\n\t\tgoto error_mutex;\n\n\tret = v4l2_fh_open(file);\n\tif (ret)\n\t\tgoto error_pipeline;\n\n\tmutex_unlock(lock);\n\n\treturn 0;\n\nerror_pipeline:\n\tv4l2_pipeline_pm_put(&video_dev->entity);\n\nerror_mutex:\n\tmutex_unlock(lock);\n\n\treturn ret;\n}\n\nstatic int sun6i_isp_capture_release(struct file *file)\n{\n\tstruct sun6i_isp_device *isp_dev = video_drvdata(file);\n\tstruct video_device *video_dev = &isp_dev->capture.video_dev;\n\tstruct mutex *lock = &isp_dev->capture.lock;\n\n\tmutex_lock(lock);\n\n\t_vb2_fop_release(file, NULL);\n\tv4l2_pipeline_pm_put(&video_dev->entity);\n\n\tmutex_unlock(lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations sun6i_isp_capture_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= sun6i_isp_capture_open,\n\t.release\t= sun6i_isp_capture_release,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.poll\t\t= vb2_fop_poll,\n\t.mmap\t\t= vb2_fop_mmap,\n};\n\n \n\nstatic int sun6i_isp_capture_link_validate(struct media_link *link)\n{\n\tstruct video_device *video_dev =\n\t\tmedia_entity_to_video_device(link->sink->entity);\n\tstruct sun6i_isp_device *isp_dev = video_get_drvdata(video_dev);\n\tstruct v4l2_device *v4l2_dev = &isp_dev->v4l2.v4l2_dev;\n\tunsigned int capture_width, capture_height;\n\tunsigned int proc_width, proc_height;\n\n\tsun6i_isp_capture_dimensions(isp_dev, &capture_width, &capture_height);\n\tsun6i_isp_proc_dimensions(isp_dev, &proc_width, &proc_height);\n\n\t \n\tif (capture_width != proc_width || capture_height != proc_height) {\n\t\tv4l2_err(v4l2_dev,\n\t\t\t \"invalid input/output dimensions: %ux%u/%ux%u\\n\",\n\t\t\t proc_width, proc_height, capture_width,\n\t\t\t capture_height);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct media_entity_operations sun6i_isp_capture_entity_ops = {\n\t.link_validate\t= sun6i_isp_capture_link_validate,\n};\n\n \n\nint sun6i_isp_capture_setup(struct sun6i_isp_device *isp_dev)\n{\n\tstruct sun6i_isp_capture *capture = &isp_dev->capture;\n\tstruct sun6i_isp_capture_state *state = &capture->state;\n\tstruct v4l2_device *v4l2_dev = &isp_dev->v4l2.v4l2_dev;\n\tstruct v4l2_subdev *proc_subdev = &isp_dev->proc.subdev;\n\tstruct video_device *video_dev = &capture->video_dev;\n\tstruct vb2_queue *queue = &capture->queue;\n\tstruct media_pad *pad = &capture->pad;\n\tstruct v4l2_format *format = &capture->format;\n\tstruct v4l2_pix_format *pix_format = &format->fmt.pix;\n\tint ret;\n\n\t \n\n\tINIT_LIST_HEAD(&state->queue);\n\tspin_lock_init(&state->lock);\n\n\t \n\n\tvideo_dev->entity.ops = &sun6i_isp_capture_entity_ops;\n\n\t \n\n\tpad->flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT;\n\n\tret = media_entity_pads_init(&video_dev->entity, 1, pad);\n\tif (ret)\n\t\tgoto error_mutex;\n\n\t \n\n\tmutex_init(&capture->lock);\n\n\tqueue->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tqueue->io_modes = VB2_MMAP | VB2_DMABUF;\n\tqueue->buf_struct_size = sizeof(struct sun6i_isp_buffer);\n\tqueue->ops = &sun6i_isp_capture_queue_ops;\n\tqueue->mem_ops = &vb2_dma_contig_memops;\n\tqueue->min_buffers_needed = 2;\n\tqueue->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tqueue->lock = &capture->lock;\n\tqueue->dev = isp_dev->dev;\n\tqueue->drv_priv = isp_dev;\n\n\tret = vb2_queue_init(queue);\n\tif (ret) {\n\t\tv4l2_err(v4l2_dev, \"failed to initialize vb2 queue: %d\\n\", ret);\n\t\tgoto error_media_entity;\n\t}\n\n\t \n\n\tformat->type = queue->type;\n\tpix_format->pixelformat = sun6i_isp_capture_formats[0].pixelformat;\n\tpix_format->width = 1280;\n\tpix_format->height = 720;\n\n\tsun6i_isp_capture_format_prepare(format);\n\n\t \n\n\tstrscpy(video_dev->name, SUN6I_ISP_CAPTURE_NAME,\n\t\tsizeof(video_dev->name));\n\tvideo_dev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\n\tvideo_dev->vfl_dir = VFL_DIR_RX;\n\tvideo_dev->release = video_device_release_empty;\n\tvideo_dev->fops = &sun6i_isp_capture_fops;\n\tvideo_dev->ioctl_ops = &sun6i_isp_capture_ioctl_ops;\n\tvideo_dev->v4l2_dev = v4l2_dev;\n\tvideo_dev->queue = queue;\n\tvideo_dev->lock = &capture->lock;\n\n\tvideo_set_drvdata(video_dev, isp_dev);\n\n\tret = video_register_device(video_dev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tv4l2_err(v4l2_dev, \"failed to register video device: %d\\n\",\n\t\t\t ret);\n\t\tgoto error_media_entity;\n\t}\n\n\t \n\n\tret = media_create_pad_link(&proc_subdev->entity,\n\t\t\t\t    SUN6I_ISP_PROC_PAD_SOURCE,\n\t\t\t\t    &video_dev->entity, 0,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret < 0) {\n\t\tv4l2_err(v4l2_dev, \"failed to create %s:%u -> %s:%u link\\n\",\n\t\t\t proc_subdev->entity.name, SUN6I_ISP_PROC_PAD_SOURCE,\n\t\t\t video_dev->entity.name, 0);\n\t\tgoto error_video_device;\n\t}\n\n\treturn 0;\n\nerror_video_device:\n\tvb2_video_unregister_device(video_dev);\n\nerror_media_entity:\n\tmedia_entity_cleanup(&video_dev->entity);\n\nerror_mutex:\n\tmutex_destroy(&capture->lock);\n\n\treturn ret;\n}\n\nvoid sun6i_isp_capture_cleanup(struct sun6i_isp_device *isp_dev)\n{\n\tstruct sun6i_isp_capture *capture = &isp_dev->capture;\n\tstruct video_device *video_dev = &capture->video_dev;\n\n\tvb2_video_unregister_device(video_dev);\n\tmedia_entity_cleanup(&video_dev->entity);\n\tmutex_destroy(&capture->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}