{
  "module_name": "sun6i_isp_proc.c",
  "hash_id": "83f02a573970f9cf2327049eddef9fbc2223f9ad16c2b2559ee0956178f5e910",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/sunxi/sun6i-isp/sun6i_isp_proc.c",
  "human_readable_source": "\n \n\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n\n#include \"sun6i_isp.h\"\n#include \"sun6i_isp_capture.h\"\n#include \"sun6i_isp_params.h\"\n#include \"sun6i_isp_proc.h\"\n#include \"sun6i_isp_reg.h\"\n\n \n\nvoid sun6i_isp_proc_dimensions(struct sun6i_isp_device *isp_dev,\n\t\t\t       unsigned int *width, unsigned int *height)\n{\n\tif (width)\n\t\t*width = isp_dev->proc.mbus_format.width;\n\tif (height)\n\t\t*height = isp_dev->proc.mbus_format.height;\n}\n\n \n\nstatic const struct sun6i_isp_proc_format sun6i_isp_proc_formats[] = {\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.input_format\t= SUN6I_ISP_INPUT_FMT_RAW_BGGR,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.input_format\t= SUN6I_ISP_INPUT_FMT_RAW_GBRG,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.input_format\t= SUN6I_ISP_INPUT_FMT_RAW_GRBG,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.input_format\t= SUN6I_ISP_INPUT_FMT_RAW_RGGB,\n\t},\n\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.input_format\t= SUN6I_ISP_INPUT_FMT_RAW_BGGR,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.input_format\t= SUN6I_ISP_INPUT_FMT_RAW_GBRG,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.input_format\t= SUN6I_ISP_INPUT_FMT_RAW_GRBG,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.input_format\t= SUN6I_ISP_INPUT_FMT_RAW_RGGB,\n\t},\n};\n\nconst struct sun6i_isp_proc_format *sun6i_isp_proc_format_find(u32 mbus_code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sun6i_isp_proc_formats); i++)\n\t\tif (sun6i_isp_proc_formats[i].mbus_code == mbus_code)\n\t\t\treturn &sun6i_isp_proc_formats[i];\n\n\treturn NULL;\n}\n\n \n\nstatic void sun6i_isp_proc_irq_enable(struct sun6i_isp_device *isp_dev)\n{\n\tstruct regmap *regmap = isp_dev->regmap;\n\n\tregmap_write(regmap, SUN6I_ISP_FE_INT_EN_REG,\n\t\t     SUN6I_ISP_FE_INT_EN_FINISH |\n\t\t     SUN6I_ISP_FE_INT_EN_START |\n\t\t     SUN6I_ISP_FE_INT_EN_PARA_SAVE |\n\t\t     SUN6I_ISP_FE_INT_EN_PARA_LOAD |\n\t\t     SUN6I_ISP_FE_INT_EN_SRC0_FIFO |\n\t\t     SUN6I_ISP_FE_INT_EN_ROT_FINISH);\n}\n\nstatic void sun6i_isp_proc_irq_disable(struct sun6i_isp_device *isp_dev)\n{\n\tstruct regmap *regmap = isp_dev->regmap;\n\n\tregmap_write(regmap, SUN6I_ISP_FE_INT_EN_REG, 0);\n}\n\nstatic void sun6i_isp_proc_irq_clear(struct sun6i_isp_device *isp_dev)\n{\n\tstruct regmap *regmap = isp_dev->regmap;\n\n\tregmap_write(regmap, SUN6I_ISP_FE_INT_EN_REG, 0);\n\tregmap_write(regmap, SUN6I_ISP_FE_INT_STA_REG,\n\t\t     SUN6I_ISP_FE_INT_STA_CLEAR);\n}\n\nstatic void sun6i_isp_proc_enable(struct sun6i_isp_device *isp_dev,\n\t\t\t\t  struct sun6i_isp_proc_source *source)\n{\n\tstruct sun6i_isp_proc *proc = &isp_dev->proc;\n\tstruct regmap *regmap = isp_dev->regmap;\n\tu8 mode;\n\n\t \n\n\tif (source == &proc->source_csi0)\n\t\tmode = SUN6I_ISP_SRC_MODE_CSI(0);\n\telse\n\t\tmode = SUN6I_ISP_SRC_MODE_CSI(1);\n\n\tregmap_write(regmap, SUN6I_ISP_FE_CFG_REG,\n\t\t     SUN6I_ISP_FE_CFG_EN | SUN6I_ISP_FE_CFG_SRC0_MODE(mode));\n\n\tregmap_write(regmap, SUN6I_ISP_FE_CTRL_REG,\n\t\t     SUN6I_ISP_FE_CTRL_VCAP_EN | SUN6I_ISP_FE_CTRL_PARA_READY);\n}\n\nstatic void sun6i_isp_proc_disable(struct sun6i_isp_device *isp_dev)\n{\n\tstruct regmap *regmap = isp_dev->regmap;\n\n\t \n\n\tregmap_write(regmap, SUN6I_ISP_FE_CTRL_REG, 0);\n\tregmap_write(regmap, SUN6I_ISP_FE_CFG_REG, 0);\n}\n\nstatic void sun6i_isp_proc_configure(struct sun6i_isp_device *isp_dev)\n{\n\tstruct v4l2_mbus_framefmt *mbus_format = &isp_dev->proc.mbus_format;\n\tconst struct sun6i_isp_proc_format *format;\n\tu32 value;\n\n\t \n\n\tvalue = sun6i_isp_load_read(isp_dev, SUN6I_ISP_MODULE_EN_REG);\n\tvalue |= SUN6I_ISP_MODULE_EN_SRC0;\n\tsun6i_isp_load_write(isp_dev, SUN6I_ISP_MODULE_EN_REG, value);\n\n\t \n\n\tformat = sun6i_isp_proc_format_find(mbus_format->code);\n\tif (WARN_ON(!format))\n\t\treturn;\n\n\tsun6i_isp_load_write(isp_dev, SUN6I_ISP_MODE_REG,\n\t\t\t     SUN6I_ISP_MODE_INPUT_FMT(format->input_format) |\n\t\t\t     SUN6I_ISP_MODE_INPUT_YUV_SEQ(format->input_yuv_seq) |\n\t\t\t     SUN6I_ISP_MODE_SHARP(1) |\n\t\t\t     SUN6I_ISP_MODE_HIST(2));\n}\n\n \n\nstatic int sun6i_isp_proc_s_stream(struct v4l2_subdev *subdev, int on)\n{\n\tstruct sun6i_isp_device *isp_dev = v4l2_get_subdevdata(subdev);\n\tstruct sun6i_isp_proc *proc = &isp_dev->proc;\n\tstruct media_pad *local_pad = &proc->pads[SUN6I_ISP_PROC_PAD_SINK_CSI];\n\tstruct device *dev = isp_dev->dev;\n\tstruct sun6i_isp_proc_source *source;\n\tstruct v4l2_subdev *source_subdev;\n\tstruct media_pad *remote_pad;\n\tint ret;\n\n\t \n\n\tremote_pad = media_pad_remote_pad_unique(local_pad);\n\tif (IS_ERR(remote_pad)) {\n\t\tdev_err(dev,\n\t\t\t\"zero or more than a single source connected to the bridge\\n\");\n\t\treturn PTR_ERR(remote_pad);\n\t}\n\n\tsource_subdev = media_entity_to_v4l2_subdev(remote_pad->entity);\n\n\tif (source_subdev == proc->source_csi0.subdev)\n\t\tsource = &proc->source_csi0;\n\telse\n\t\tsource = &proc->source_csi1;\n\n\tif (!on) {\n\t\tsun6i_isp_proc_irq_disable(isp_dev);\n\t\tv4l2_subdev_call(source_subdev, video, s_stream, 0);\n\t\tret = 0;\n\t\tgoto disable;\n\t}\n\n\t \n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\tsun6i_isp_proc_irq_clear(isp_dev);\n\n\t \n\n\tsun6i_isp_tables_configure(isp_dev);\n\tsun6i_isp_params_configure(isp_dev);\n\tsun6i_isp_proc_configure(isp_dev);\n\tsun6i_isp_capture_configure(isp_dev);\n\n\t \n\n\tsun6i_isp_state_update(isp_dev, true);\n\n\t \n\n\tsun6i_isp_proc_irq_enable(isp_dev);\n\tsun6i_isp_proc_enable(isp_dev, source);\n\n\tret = v4l2_subdev_call(source_subdev, video, s_stream, 1);\n\tif (ret && ret != -ENOIOCTLCMD) {\n\t\tsun6i_isp_proc_irq_disable(isp_dev);\n\t\tgoto disable;\n\t}\n\n\treturn 0;\n\ndisable:\n\tsun6i_isp_proc_disable(isp_dev);\n\n\tpm_runtime_put(dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops sun6i_isp_proc_video_ops = {\n\t.s_stream\t= sun6i_isp_proc_s_stream,\n};\n\nstatic void\nsun6i_isp_proc_mbus_format_prepare(struct v4l2_mbus_framefmt *mbus_format)\n{\n\tif (!sun6i_isp_proc_format_find(mbus_format->code))\n\t\tmbus_format->code = sun6i_isp_proc_formats[0].mbus_code;\n\n\tmbus_format->field = V4L2_FIELD_NONE;\n\tmbus_format->colorspace = V4L2_COLORSPACE_RAW;\n\tmbus_format->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tmbus_format->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n}\n\nstatic int sun6i_isp_proc_init_cfg(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_state *state)\n{\n\tstruct sun6i_isp_device *isp_dev = v4l2_get_subdevdata(subdev);\n\tunsigned int pad = SUN6I_ISP_PROC_PAD_SINK_CSI;\n\tstruct v4l2_mbus_framefmt *mbus_format =\n\t\tv4l2_subdev_get_try_format(subdev, state, pad);\n\tstruct mutex *lock = &isp_dev->proc.lock;\n\n\tmutex_lock(lock);\n\n\tmbus_format->code = sun6i_isp_proc_formats[0].mbus_code;\n\tmbus_format->width = 1280;\n\tmbus_format->height = 720;\n\n\tsun6i_isp_proc_mbus_format_prepare(mbus_format);\n\n\tmutex_unlock(lock);\n\n\treturn 0;\n}\n\nstatic int\nsun6i_isp_proc_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code_enum)\n{\n\tif (code_enum->index >= ARRAY_SIZE(sun6i_isp_proc_formats))\n\t\treturn -EINVAL;\n\n\tcode_enum->code = sun6i_isp_proc_formats[code_enum->index].mbus_code;\n\n\treturn 0;\n}\n\nstatic int sun6i_isp_proc_get_fmt(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *state,\n\t\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct sun6i_isp_device *isp_dev = v4l2_get_subdevdata(subdev);\n\tstruct v4l2_mbus_framefmt *mbus_format = &format->format;\n\tstruct mutex *lock = &isp_dev->proc.lock;\n\n\tmutex_lock(lock);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t*mbus_format = *v4l2_subdev_get_try_format(subdev, state,\n\t\t\t\t\t\t\t   format->pad);\n\telse\n\t\t*mbus_format = isp_dev->proc.mbus_format;\n\n\tmutex_unlock(lock);\n\n\treturn 0;\n}\n\nstatic int sun6i_isp_proc_set_fmt(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *state,\n\t\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct sun6i_isp_device *isp_dev = v4l2_get_subdevdata(subdev);\n\tstruct v4l2_mbus_framefmt *mbus_format = &format->format;\n\tstruct mutex *lock = &isp_dev->proc.lock;\n\n\tmutex_lock(lock);\n\n\tsun6i_isp_proc_mbus_format_prepare(mbus_format);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t*v4l2_subdev_get_try_format(subdev, state, format->pad) =\n\t\t\t*mbus_format;\n\telse\n\t\tisp_dev->proc.mbus_format = *mbus_format;\n\n\tmutex_unlock(lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops sun6i_isp_proc_pad_ops = {\n\t.init_cfg\t= sun6i_isp_proc_init_cfg,\n\t.enum_mbus_code\t= sun6i_isp_proc_enum_mbus_code,\n\t.get_fmt\t= sun6i_isp_proc_get_fmt,\n\t.set_fmt\t= sun6i_isp_proc_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops sun6i_isp_proc_subdev_ops = {\n\t.video\t= &sun6i_isp_proc_video_ops,\n\t.pad\t= &sun6i_isp_proc_pad_ops,\n};\n\n \n\nstatic const struct media_entity_operations sun6i_isp_proc_entity_ops = {\n\t.link_validate\t= v4l2_subdev_link_validate,\n};\n\n \n\nstatic int sun6i_isp_proc_link(struct sun6i_isp_device *isp_dev,\n\t\t\t       int sink_pad_index,\n\t\t\t       struct v4l2_subdev *remote_subdev, bool enabled)\n{\n\tstruct device *dev = isp_dev->dev;\n\tstruct v4l2_subdev *subdev = &isp_dev->proc.subdev;\n\tstruct media_entity *sink_entity = &subdev->entity;\n\tstruct media_entity *source_entity = &remote_subdev->entity;\n\tint source_pad_index;\n\tint ret;\n\n\t \n\tret = media_entity_get_fwnode_pad(source_entity, remote_subdev->fwnode,\n\t\t\t\t\t  MEDIA_PAD_FL_SOURCE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing source pad in external entity %s\\n\",\n\t\t\tsource_entity->name);\n\t\treturn -EINVAL;\n\t}\n\n\tsource_pad_index = ret;\n\n\tdev_dbg(dev, \"creating %s:%u -> %s:%u link\\n\", source_entity->name,\n\t\tsource_pad_index, sink_entity->name, sink_pad_index);\n\n\tret = media_create_pad_link(source_entity, source_pad_index,\n\t\t\t\t    sink_entity, sink_pad_index,\n\t\t\t\t    enabled ? MEDIA_LNK_FL_ENABLED : 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to create %s:%u -> %s:%u link\\n\",\n\t\t\tsource_entity->name, source_pad_index,\n\t\t\tsink_entity->name, sink_pad_index);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sun6i_isp_proc_notifier_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t\t struct v4l2_subdev *remote_subdev,\n\t\t\t\t\t struct v4l2_async_connection *async_subdev)\n{\n\tstruct sun6i_isp_device *isp_dev =\n\t\tcontainer_of(notifier, struct sun6i_isp_device, proc.notifier);\n\tstruct sun6i_isp_proc_async_subdev *proc_async_subdev =\n\t\tcontainer_of(async_subdev, struct sun6i_isp_proc_async_subdev,\n\t\t\t     async_subdev);\n\tstruct sun6i_isp_proc *proc = &isp_dev->proc;\n\tstruct sun6i_isp_proc_source *source = proc_async_subdev->source;\n\tbool enabled;\n\n\tswitch (source->endpoint.base.port) {\n\tcase SUN6I_ISP_PORT_CSI0:\n\t\tsource = &proc->source_csi0;\n\t\tenabled = true;\n\t\tbreak;\n\tcase SUN6I_ISP_PORT_CSI1:\n\t\tsource = &proc->source_csi1;\n\t\tenabled = !proc->source_csi0.expected;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsource->subdev = remote_subdev;\n\n\treturn sun6i_isp_proc_link(isp_dev, SUN6I_ISP_PROC_PAD_SINK_CSI,\n\t\t\t\t   remote_subdev, enabled);\n}\n\nstatic int\nsun6i_isp_proc_notifier_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct sun6i_isp_device *isp_dev =\n\t\tcontainer_of(notifier, struct sun6i_isp_device, proc.notifier);\n\tstruct v4l2_device *v4l2_dev = &isp_dev->v4l2.v4l2_dev;\n\tint ret;\n\n\tret = v4l2_device_register_subdev_nodes(v4l2_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_async_notifier_operations\nsun6i_isp_proc_notifier_ops = {\n\t.bound\t\t= sun6i_isp_proc_notifier_bound,\n\t.complete\t= sun6i_isp_proc_notifier_complete,\n};\n\n \n\nstatic int sun6i_isp_proc_source_setup(struct sun6i_isp_device *isp_dev,\n\t\t\t\t       struct sun6i_isp_proc_source *source,\n\t\t\t\t       u32 port)\n{\n\tstruct device *dev = isp_dev->dev;\n\tstruct v4l2_async_notifier *notifier = &isp_dev->proc.notifier;\n\tstruct v4l2_fwnode_endpoint *endpoint = &source->endpoint;\n\tstruct sun6i_isp_proc_async_subdev *proc_async_subdev;\n\tstruct fwnode_handle *handle = NULL;\n\tint ret;\n\n\thandle = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev), port, 0, 0);\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tret = v4l2_fwnode_endpoint_parse(handle, endpoint);\n\tif (ret)\n\t\tgoto complete;\n\n\tproc_async_subdev =\n\t\tv4l2_async_nf_add_fwnode_remote(notifier, handle,\n\t\t\t\t\t\tstruct\n\t\t\t\t\t\tsun6i_isp_proc_async_subdev);\n\tif (IS_ERR(proc_async_subdev)) {\n\t\tret = PTR_ERR(proc_async_subdev);\n\t\tgoto complete;\n\t}\n\n\tproc_async_subdev->source = source;\n\n\tsource->expected = true;\n\ncomplete:\n\tfwnode_handle_put(handle);\n\n\treturn ret;\n}\n\nint sun6i_isp_proc_setup(struct sun6i_isp_device *isp_dev)\n{\n\tstruct device *dev = isp_dev->dev;\n\tstruct sun6i_isp_proc *proc = &isp_dev->proc;\n\tstruct v4l2_device *v4l2_dev = &isp_dev->v4l2.v4l2_dev;\n\tstruct v4l2_async_notifier *notifier = &proc->notifier;\n\tstruct v4l2_subdev *subdev = &proc->subdev;\n\tstruct media_pad *pads = proc->pads;\n\tint ret;\n\n\tmutex_init(&proc->lock);\n\n\t \n\n\tv4l2_subdev_init(subdev, &sun6i_isp_proc_subdev_ops);\n\tstrscpy(subdev->name, SUN6I_ISP_PROC_NAME, sizeof(subdev->name));\n\tsubdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsubdev->owner = THIS_MODULE;\n\tsubdev->dev = dev;\n\n\tv4l2_set_subdevdata(subdev, isp_dev);\n\n\t \n\n\tsubdev->entity.function = MEDIA_ENT_F_PROC_VIDEO_ISP;\n\tsubdev->entity.ops = &sun6i_isp_proc_entity_ops;\n\n\t \n\n\tpads[SUN6I_ISP_PROC_PAD_SINK_CSI].flags = MEDIA_PAD_FL_SINK |\n\t\t\t\t\t\t  MEDIA_PAD_FL_MUST_CONNECT;\n\tpads[SUN6I_ISP_PROC_PAD_SINK_PARAMS].flags = MEDIA_PAD_FL_SINK |\n\t\t\t\t\t\t     MEDIA_PAD_FL_MUST_CONNECT;\n\tpads[SUN6I_ISP_PROC_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&subdev->entity, SUN6I_ISP_PROC_PAD_COUNT,\n\t\t\t\t     pads);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = v4l2_device_register_subdev(v4l2_dev, subdev);\n\tif (ret < 0) {\n\t\tv4l2_err(v4l2_dev, \"failed to register v4l2 subdev: %d\\n\", ret);\n\t\tgoto error_media_entity;\n\t}\n\n\t \n\n\tv4l2_async_nf_init(notifier, v4l2_dev);\n\tnotifier->ops = &sun6i_isp_proc_notifier_ops;\n\n\tsun6i_isp_proc_source_setup(isp_dev, &proc->source_csi0,\n\t\t\t\t    SUN6I_ISP_PORT_CSI0);\n\tsun6i_isp_proc_source_setup(isp_dev, &proc->source_csi1,\n\t\t\t\t    SUN6I_ISP_PORT_CSI1);\n\n\tret = v4l2_async_nf_register(notifier);\n\tif (ret) {\n\t\tv4l2_err(v4l2_dev,\n\t\t\t \"failed to register v4l2 async notifier: %d\\n\", ret);\n\t\tgoto error_v4l2_async_notifier;\n\t}\n\n\treturn 0;\n\nerror_v4l2_async_notifier:\n\tv4l2_async_nf_cleanup(notifier);\n\n\tv4l2_device_unregister_subdev(subdev);\n\nerror_media_entity:\n\tmedia_entity_cleanup(&subdev->entity);\n\n\treturn ret;\n}\n\nvoid sun6i_isp_proc_cleanup(struct sun6i_isp_device *isp_dev)\n{\n\tstruct v4l2_async_notifier *notifier = &isp_dev->proc.notifier;\n\tstruct v4l2_subdev *subdev = &isp_dev->proc.subdev;\n\n\tv4l2_async_nf_unregister(notifier);\n\tv4l2_async_nf_cleanup(notifier);\n\n\tv4l2_device_unregister_subdev(subdev);\n\tmedia_entity_cleanup(&subdev->entity);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}