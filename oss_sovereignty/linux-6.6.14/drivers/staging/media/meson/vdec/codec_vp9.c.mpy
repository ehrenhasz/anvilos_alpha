{
  "module_name": "codec_vp9.c",
  "hash_id": "342a339bfcb55325a983dd1e3e5a895e01d133205046b39964f49f31477612ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/meson/vdec/codec_vp9.c",
  "human_readable_source": "\n \n\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"dos_regs.h\"\n#include \"hevc_regs.h\"\n#include \"codec_vp9.h\"\n#include \"vdec_helpers.h\"\n#include \"codec_hevc_common.h\"\n\n \n#define VP9_DEC_STATUS_REG\tHEVC_ASSIST_SCRATCH_0\n\t#define VP9_10B_DECODE_SLICE\t5\n\t#define VP9_HEAD_PARSER_DONE\t0xf0\n#define VP9_RPM_BUFFER\t\tHEVC_ASSIST_SCRATCH_1\n#define VP9_SHORT_TERM_RPS\tHEVC_ASSIST_SCRATCH_2\n#define VP9_ADAPT_PROB_REG\tHEVC_ASSIST_SCRATCH_3\n#define VP9_MMU_MAP_BUFFER\tHEVC_ASSIST_SCRATCH_4\n#define VP9_PPS_BUFFER\t\tHEVC_ASSIST_SCRATCH_5\n#define VP9_SAO_UP\t\tHEVC_ASSIST_SCRATCH_6\n#define VP9_STREAM_SWAP_BUFFER\tHEVC_ASSIST_SCRATCH_7\n#define VP9_STREAM_SWAP_BUFFER2 HEVC_ASSIST_SCRATCH_8\n#define VP9_PROB_SWAP_BUFFER\tHEVC_ASSIST_SCRATCH_9\n#define VP9_COUNT_SWAP_BUFFER\tHEVC_ASSIST_SCRATCH_A\n#define VP9_SEG_MAP_BUFFER\tHEVC_ASSIST_SCRATCH_B\n#define VP9_SCALELUT\t\tHEVC_ASSIST_SCRATCH_D\n#define VP9_WAIT_FLAG\t\tHEVC_ASSIST_SCRATCH_E\n#define LMEM_DUMP_ADR\t\tHEVC_ASSIST_SCRATCH_F\n#define NAL_SEARCH_CTL\t\tHEVC_ASSIST_SCRATCH_I\n#define VP9_DECODE_MODE\t\tHEVC_ASSIST_SCRATCH_J\n\t#define DECODE_MODE_SINGLE 0\n#define DECODE_STOP_POS\t\tHEVC_ASSIST_SCRATCH_K\n#define HEVC_DECODE_COUNT\tHEVC_ASSIST_SCRATCH_M\n#define HEVC_DECODE_SIZE\tHEVC_ASSIST_SCRATCH_N\n\n \n#define LCU_SIZE\t\t64\n#define MAX_REF_PIC_NUM\t\t24\n#define REFS_PER_FRAME\t\t3\n#define REF_FRAMES\t\t8\n#define MV_MEM_UNIT\t\t0x240\n#define ADAPT_PROB_SIZE\t\t0xf80\n\nenum FRAME_TYPE {\n\tKEY_FRAME = 0,\n\tINTER_FRAME = 1,\n\tFRAME_TYPES,\n};\n\n \n#define MPRED_MV_BUF_SIZE 0x120000\n\n#define IPP_SIZE\t0x4000\n#define SAO_ABV_SIZE\t0x30000\n#define SAO_VB_SIZE\t0x30000\n#define SH_TM_RPS_SIZE\t0x800\n#define VPS_SIZE\t0x800\n#define SPS_SIZE\t0x800\n#define PPS_SIZE\t0x2000\n#define SAO_UP_SIZE\t0x2800\n#define SWAP_BUF_SIZE\t0x800\n#define SWAP_BUF2_SIZE\t0x800\n#define SCALELUT_SIZE\t0x8000\n#define DBLK_PARA_SIZE\t0x80000\n#define DBLK_DATA_SIZE\t0x80000\n#define SEG_MAP_SIZE\t0xd800\n#define PROB_SIZE\t0x5000\n#define COUNT_SIZE\t0x3000\n#define MMU_VBH_SIZE\t0x5000\n#define MPRED_ABV_SIZE\t0x10000\n#define MPRED_MV_SIZE\t(MPRED_MV_BUF_SIZE * MAX_REF_PIC_NUM)\n#define RPM_BUF_SIZE\t0x100\n#define LMEM_SIZE\t0x800\n\n#define IPP_OFFSET       0x00\n#define SAO_ABV_OFFSET   (IPP_OFFSET + IPP_SIZE)\n#define SAO_VB_OFFSET    (SAO_ABV_OFFSET + SAO_ABV_SIZE)\n#define SH_TM_RPS_OFFSET (SAO_VB_OFFSET + SAO_VB_SIZE)\n#define VPS_OFFSET       (SH_TM_RPS_OFFSET + SH_TM_RPS_SIZE)\n#define SPS_OFFSET       (VPS_OFFSET + VPS_SIZE)\n#define PPS_OFFSET       (SPS_OFFSET + SPS_SIZE)\n#define SAO_UP_OFFSET    (PPS_OFFSET + PPS_SIZE)\n#define SWAP_BUF_OFFSET  (SAO_UP_OFFSET + SAO_UP_SIZE)\n#define SWAP_BUF2_OFFSET (SWAP_BUF_OFFSET + SWAP_BUF_SIZE)\n#define SCALELUT_OFFSET  (SWAP_BUF2_OFFSET + SWAP_BUF2_SIZE)\n#define DBLK_PARA_OFFSET (SCALELUT_OFFSET + SCALELUT_SIZE)\n#define DBLK_DATA_OFFSET (DBLK_PARA_OFFSET + DBLK_PARA_SIZE)\n#define SEG_MAP_OFFSET   (DBLK_DATA_OFFSET + DBLK_DATA_SIZE)\n#define PROB_OFFSET      (SEG_MAP_OFFSET + SEG_MAP_SIZE)\n#define COUNT_OFFSET     (PROB_OFFSET + PROB_SIZE)\n#define MMU_VBH_OFFSET   (COUNT_OFFSET + COUNT_SIZE)\n#define MPRED_ABV_OFFSET (MMU_VBH_OFFSET + MMU_VBH_SIZE)\n#define MPRED_MV_OFFSET  (MPRED_ABV_OFFSET + MPRED_ABV_SIZE)\n#define RPM_OFFSET       (MPRED_MV_OFFSET + MPRED_MV_SIZE)\n#define LMEM_OFFSET      (RPM_OFFSET + RPM_BUF_SIZE)\n\n#define SIZE_WORKSPACE\tALIGN(LMEM_OFFSET + LMEM_SIZE, 64 * SZ_1K)\n\n#define NONE           -1\n#define INTRA_FRAME     0\n#define LAST_FRAME      1\n#define GOLDEN_FRAME    2\n#define ALTREF_FRAME    3\n#define MAX_REF_FRAMES  4\n\n \n#define MAX_LOOP_FILTER\t\t63\n#define MAX_REF_LF_DELTAS\t4\n#define MAX_MODE_LF_DELTAS\t2\n#define SEGMENT_DELTADATA\t0\n#define SEGMENT_ABSDATA\t\t1\n#define MAX_SEGMENTS\t\t8\n\n \n#define VP9_PARTITION_START      0\n#define VP9_PARTITION_SIZE_STEP  (3 * 4)\n#define VP9_PARTITION_ONE_SIZE   (4 * VP9_PARTITION_SIZE_STEP)\n#define VP9_PARTITION_KEY_START  0\n#define VP9_PARTITION_P_START    VP9_PARTITION_ONE_SIZE\n#define VP9_PARTITION_SIZE       (2 * VP9_PARTITION_ONE_SIZE)\n#define VP9_SKIP_START           (VP9_PARTITION_START + VP9_PARTITION_SIZE)\n#define VP9_SKIP_SIZE            4  \n#define VP9_TX_MODE_START        (VP9_SKIP_START + VP9_SKIP_SIZE)\n#define VP9_TX_MODE_8_0_OFFSET   0\n#define VP9_TX_MODE_8_1_OFFSET   1\n#define VP9_TX_MODE_16_0_OFFSET  2\n#define VP9_TX_MODE_16_1_OFFSET  4\n#define VP9_TX_MODE_32_0_OFFSET  6\n#define VP9_TX_MODE_32_1_OFFSET  9\n#define VP9_TX_MODE_SIZE         12\n#define VP9_COEF_START           (VP9_TX_MODE_START + VP9_TX_MODE_SIZE)\n#define VP9_COEF_BAND_0_OFFSET   0\n#define VP9_COEF_BAND_1_OFFSET   (VP9_COEF_BAND_0_OFFSET + 3 * 3 + 1)\n#define VP9_COEF_BAND_2_OFFSET   (VP9_COEF_BAND_1_OFFSET + 6 * 3)\n#define VP9_COEF_BAND_3_OFFSET   (VP9_COEF_BAND_2_OFFSET + 6 * 3)\n#define VP9_COEF_BAND_4_OFFSET   (VP9_COEF_BAND_3_OFFSET + 6 * 3)\n#define VP9_COEF_BAND_5_OFFSET   (VP9_COEF_BAND_4_OFFSET + 6 * 3)\n#define VP9_COEF_SIZE_ONE_SET    100  \n#define VP9_COEF_4X4_START       (VP9_COEF_START + 0 * VP9_COEF_SIZE_ONE_SET)\n#define VP9_COEF_8X8_START       (VP9_COEF_START + 4 * VP9_COEF_SIZE_ONE_SET)\n#define VP9_COEF_16X16_START     (VP9_COEF_START + 8 * VP9_COEF_SIZE_ONE_SET)\n#define VP9_COEF_32X32_START     (VP9_COEF_START + 12 * VP9_COEF_SIZE_ONE_SET)\n#define VP9_COEF_SIZE_PLANE      (2 * VP9_COEF_SIZE_ONE_SET)\n#define VP9_COEF_SIZE            (4 * 2 * 2 * VP9_COEF_SIZE_ONE_SET)\n#define VP9_INTER_MODE_START     (VP9_COEF_START + VP9_COEF_SIZE)\n#define VP9_INTER_MODE_SIZE      24  \n#define VP9_INTERP_START         (VP9_INTER_MODE_START + VP9_INTER_MODE_SIZE)\n#define VP9_INTERP_SIZE          8\n#define VP9_INTRA_INTER_START    (VP9_INTERP_START + VP9_INTERP_SIZE)\n#define VP9_INTRA_INTER_SIZE     4\n#define VP9_INTERP_INTRA_INTER_START  VP9_INTERP_START\n#define VP9_INTERP_INTRA_INTER_SIZE   (VP9_INTERP_SIZE + VP9_INTRA_INTER_SIZE)\n#define VP9_COMP_INTER_START     \\\n\t\t(VP9_INTERP_INTRA_INTER_START + VP9_INTERP_INTRA_INTER_SIZE)\n#define VP9_COMP_INTER_SIZE      5\n#define VP9_COMP_REF_START       (VP9_COMP_INTER_START + VP9_COMP_INTER_SIZE)\n#define VP9_COMP_REF_SIZE        5\n#define VP9_SINGLE_REF_START     (VP9_COMP_REF_START + VP9_COMP_REF_SIZE)\n#define VP9_SINGLE_REF_SIZE      10\n#define VP9_REF_MODE_START       VP9_COMP_INTER_START\n#define VP9_REF_MODE_SIZE        \\\n\t\t(VP9_COMP_INTER_SIZE + VP9_COMP_REF_SIZE + VP9_SINGLE_REF_SIZE)\n#define VP9_IF_Y_MODE_START      (VP9_REF_MODE_START + VP9_REF_MODE_SIZE)\n#define VP9_IF_Y_MODE_SIZE       36\n#define VP9_IF_UV_MODE_START     (VP9_IF_Y_MODE_START + VP9_IF_Y_MODE_SIZE)\n#define VP9_IF_UV_MODE_SIZE      92  \n#define VP9_MV_JOINTS_START      (VP9_IF_UV_MODE_START + VP9_IF_UV_MODE_SIZE)\n#define VP9_MV_JOINTS_SIZE       3\n#define VP9_MV_SIGN_0_START      (VP9_MV_JOINTS_START + VP9_MV_JOINTS_SIZE)\n#define VP9_MV_SIGN_0_SIZE       1\n#define VP9_MV_CLASSES_0_START   (VP9_MV_SIGN_0_START + VP9_MV_SIGN_0_SIZE)\n#define VP9_MV_CLASSES_0_SIZE    10\n#define VP9_MV_CLASS0_0_START    \\\n\t\t(VP9_MV_CLASSES_0_START + VP9_MV_CLASSES_0_SIZE)\n#define VP9_MV_CLASS0_0_SIZE     1\n#define VP9_MV_BITS_0_START      (VP9_MV_CLASS0_0_START + VP9_MV_CLASS0_0_SIZE)\n#define VP9_MV_BITS_0_SIZE       10\n#define VP9_MV_SIGN_1_START      (VP9_MV_BITS_0_START + VP9_MV_BITS_0_SIZE)\n#define VP9_MV_SIGN_1_SIZE       1\n#define VP9_MV_CLASSES_1_START   \\\n\t\t\t(VP9_MV_SIGN_1_START + VP9_MV_SIGN_1_SIZE)\n#define VP9_MV_CLASSES_1_SIZE    10\n#define VP9_MV_CLASS0_1_START    \\\n\t\t\t(VP9_MV_CLASSES_1_START + VP9_MV_CLASSES_1_SIZE)\n#define VP9_MV_CLASS0_1_SIZE     1\n#define VP9_MV_BITS_1_START      \\\n\t\t\t(VP9_MV_CLASS0_1_START + VP9_MV_CLASS0_1_SIZE)\n#define VP9_MV_BITS_1_SIZE       10\n#define VP9_MV_CLASS0_FP_0_START \\\n\t\t\t(VP9_MV_BITS_1_START + VP9_MV_BITS_1_SIZE)\n#define VP9_MV_CLASS0_FP_0_SIZE  9\n#define VP9_MV_CLASS0_FP_1_START \\\n\t\t\t(VP9_MV_CLASS0_FP_0_START + VP9_MV_CLASS0_FP_0_SIZE)\n#define VP9_MV_CLASS0_FP_1_SIZE  9\n#define VP9_MV_CLASS0_HP_0_START \\\n\t\t\t(VP9_MV_CLASS0_FP_1_START + VP9_MV_CLASS0_FP_1_SIZE)\n#define VP9_MV_CLASS0_HP_0_SIZE  2\n#define VP9_MV_CLASS0_HP_1_START \\\n\t\t\t(VP9_MV_CLASS0_HP_0_START + VP9_MV_CLASS0_HP_0_SIZE)\n#define VP9_MV_CLASS0_HP_1_SIZE  2\n#define VP9_MV_START             VP9_MV_JOINTS_START\n#define VP9_MV_SIZE              72  \n\n#define VP9_TOTAL_SIZE           (VP9_MV_START + VP9_MV_SIZE)\n\n \n#define VP9_COEF_COUNT_START           0\n#define VP9_COEF_COUNT_BAND_0_OFFSET   0\n#define VP9_COEF_COUNT_BAND_1_OFFSET   \\\n\t\t\t(VP9_COEF_COUNT_BAND_0_OFFSET + 3 * 5)\n#define VP9_COEF_COUNT_BAND_2_OFFSET   \\\n\t\t\t(VP9_COEF_COUNT_BAND_1_OFFSET + 6 * 5)\n#define VP9_COEF_COUNT_BAND_3_OFFSET   \\\n\t\t\t(VP9_COEF_COUNT_BAND_2_OFFSET + 6 * 5)\n#define VP9_COEF_COUNT_BAND_4_OFFSET   \\\n\t\t\t(VP9_COEF_COUNT_BAND_3_OFFSET + 6 * 5)\n#define VP9_COEF_COUNT_BAND_5_OFFSET   \\\n\t\t\t(VP9_COEF_COUNT_BAND_4_OFFSET + 6 * 5)\n#define VP9_COEF_COUNT_SIZE_ONE_SET    165  \n#define VP9_COEF_COUNT_4X4_START       \\\n\t\t(VP9_COEF_COUNT_START + 0 * VP9_COEF_COUNT_SIZE_ONE_SET)\n#define VP9_COEF_COUNT_8X8_START       \\\n\t\t(VP9_COEF_COUNT_START + 4 * VP9_COEF_COUNT_SIZE_ONE_SET)\n#define VP9_COEF_COUNT_16X16_START     \\\n\t\t(VP9_COEF_COUNT_START + 8 * VP9_COEF_COUNT_SIZE_ONE_SET)\n#define VP9_COEF_COUNT_32X32_START     \\\n\t\t(VP9_COEF_COUNT_START + 12 * VP9_COEF_COUNT_SIZE_ONE_SET)\n#define VP9_COEF_COUNT_SIZE_PLANE      (2 * VP9_COEF_COUNT_SIZE_ONE_SET)\n#define VP9_COEF_COUNT_SIZE            (4 * 2 * 2 * VP9_COEF_COUNT_SIZE_ONE_SET)\n\n#define VP9_INTRA_INTER_COUNT_START    \\\n\t\t(VP9_COEF_COUNT_START + VP9_COEF_COUNT_SIZE)\n#define VP9_INTRA_INTER_COUNT_SIZE     (4 * 2)\n#define VP9_COMP_INTER_COUNT_START     \\\n\t\t(VP9_INTRA_INTER_COUNT_START + VP9_INTRA_INTER_COUNT_SIZE)\n#define VP9_COMP_INTER_COUNT_SIZE      (5 * 2)\n#define VP9_COMP_REF_COUNT_START       \\\n\t\t(VP9_COMP_INTER_COUNT_START + VP9_COMP_INTER_COUNT_SIZE)\n#define VP9_COMP_REF_COUNT_SIZE        (5 * 2)\n#define VP9_SINGLE_REF_COUNT_START     \\\n\t\t(VP9_COMP_REF_COUNT_START + VP9_COMP_REF_COUNT_SIZE)\n#define VP9_SINGLE_REF_COUNT_SIZE      (10 * 2)\n#define VP9_TX_MODE_COUNT_START        \\\n\t\t(VP9_SINGLE_REF_COUNT_START + VP9_SINGLE_REF_COUNT_SIZE)\n#define VP9_TX_MODE_COUNT_SIZE         (12 * 2)\n#define VP9_SKIP_COUNT_START           \\\n\t\t(VP9_TX_MODE_COUNT_START + VP9_TX_MODE_COUNT_SIZE)\n#define VP9_SKIP_COUNT_SIZE            (3 * 2)\n#define VP9_MV_SIGN_0_COUNT_START      \\\n\t\t(VP9_SKIP_COUNT_START + VP9_SKIP_COUNT_SIZE)\n#define VP9_MV_SIGN_0_COUNT_SIZE       (1 * 2)\n#define VP9_MV_SIGN_1_COUNT_START      \\\n\t\t(VP9_MV_SIGN_0_COUNT_START + VP9_MV_SIGN_0_COUNT_SIZE)\n#define VP9_MV_SIGN_1_COUNT_SIZE       (1 * 2)\n#define VP9_MV_BITS_0_COUNT_START      \\\n\t\t(VP9_MV_SIGN_1_COUNT_START + VP9_MV_SIGN_1_COUNT_SIZE)\n#define VP9_MV_BITS_0_COUNT_SIZE       (10 * 2)\n#define VP9_MV_BITS_1_COUNT_START      \\\n\t\t(VP9_MV_BITS_0_COUNT_START + VP9_MV_BITS_0_COUNT_SIZE)\n#define VP9_MV_BITS_1_COUNT_SIZE       (10 * 2)\n#define VP9_MV_CLASS0_HP_0_COUNT_START \\\n\t\t(VP9_MV_BITS_1_COUNT_START + VP9_MV_BITS_1_COUNT_SIZE)\n#define VP9_MV_CLASS0_HP_0_COUNT_SIZE  (2 * 2)\n#define VP9_MV_CLASS0_HP_1_COUNT_START \\\n\t\t(VP9_MV_CLASS0_HP_0_COUNT_START + VP9_MV_CLASS0_HP_0_COUNT_SIZE)\n#define VP9_MV_CLASS0_HP_1_COUNT_SIZE  (2 * 2)\n\n \n#define VP9_INTER_MODE_COUNT_START     \\\n\t\t(VP9_MV_CLASS0_HP_1_COUNT_START + VP9_MV_CLASS0_HP_1_COUNT_SIZE)\n#define VP9_INTER_MODE_COUNT_SIZE      (7 * 4)\n#define VP9_IF_Y_MODE_COUNT_START      \\\n\t\t(VP9_INTER_MODE_COUNT_START + VP9_INTER_MODE_COUNT_SIZE)\n#define VP9_IF_Y_MODE_COUNT_SIZE       (10 * 4)\n#define VP9_IF_UV_MODE_COUNT_START     \\\n\t\t(VP9_IF_Y_MODE_COUNT_START + VP9_IF_Y_MODE_COUNT_SIZE)\n#define VP9_IF_UV_MODE_COUNT_SIZE      (10 * 10)\n#define VP9_PARTITION_P_COUNT_START    \\\n\t\t(VP9_IF_UV_MODE_COUNT_START + VP9_IF_UV_MODE_COUNT_SIZE)\n#define VP9_PARTITION_P_COUNT_SIZE     (4 * 4 * 4)\n#define VP9_INTERP_COUNT_START         \\\n\t\t(VP9_PARTITION_P_COUNT_START + VP9_PARTITION_P_COUNT_SIZE)\n#define VP9_INTERP_COUNT_SIZE          (4 * 3)\n#define VP9_MV_JOINTS_COUNT_START      \\\n\t\t(VP9_INTERP_COUNT_START + VP9_INTERP_COUNT_SIZE)\n#define VP9_MV_JOINTS_COUNT_SIZE       (1 * 4)\n#define VP9_MV_CLASSES_0_COUNT_START   \\\n\t\t(VP9_MV_JOINTS_COUNT_START + VP9_MV_JOINTS_COUNT_SIZE)\n#define VP9_MV_CLASSES_0_COUNT_SIZE    (1 * 11)\n#define VP9_MV_CLASS0_0_COUNT_START    \\\n\t\t(VP9_MV_CLASSES_0_COUNT_START + VP9_MV_CLASSES_0_COUNT_SIZE)\n#define VP9_MV_CLASS0_0_COUNT_SIZE     (1 * 2)\n#define VP9_MV_CLASSES_1_COUNT_START   \\\n\t\t(VP9_MV_CLASS0_0_COUNT_START + VP9_MV_CLASS0_0_COUNT_SIZE)\n#define VP9_MV_CLASSES_1_COUNT_SIZE    (1 * 11)\n#define VP9_MV_CLASS0_1_COUNT_START    \\\n\t\t(VP9_MV_CLASSES_1_COUNT_START + VP9_MV_CLASSES_1_COUNT_SIZE)\n#define VP9_MV_CLASS0_1_COUNT_SIZE     (1 * 2)\n#define VP9_MV_CLASS0_FP_0_COUNT_START \\\n\t\t(VP9_MV_CLASS0_1_COUNT_START + VP9_MV_CLASS0_1_COUNT_SIZE)\n#define VP9_MV_CLASS0_FP_0_COUNT_SIZE  (3 * 4)\n#define VP9_MV_CLASS0_FP_1_COUNT_START \\\n\t\t(VP9_MV_CLASS0_FP_0_COUNT_START + VP9_MV_CLASS0_FP_0_COUNT_SIZE)\n#define VP9_MV_CLASS0_FP_1_COUNT_SIZE  (3 * 4)\n\n#define DC_PRED    0\t \n#define V_PRED     1\t \n#define H_PRED     2\t \n#define D45_PRED   3\t \n#define D135_PRED  4\t \n#define D117_PRED  5\t \n#define D153_PRED  6\t \n#define D207_PRED  7\t \n#define D63_PRED   8\t \n#define TM_PRED    9\t \n\n \nstatic inline int round_power_of_two(int value, int num)\n{\n\treturn (value + (1 << (num - 1))) >> num;\n}\n\n#define MODE_MV_COUNT_SAT 20\nstatic const int count_to_update_factor[MODE_MV_COUNT_SAT + 1] = {\n\t0, 6, 12, 19, 25, 32, 38, 44, 51, 57, 64,\n\t70, 76, 83, 89, 96, 102, 108, 115, 121, 128\n};\n\nunion rpm_param {\n\tstruct {\n\t\tu16 data[RPM_BUF_SIZE];\n\t} l;\n\tstruct {\n\t\tu16 profile;\n\t\tu16 show_existing_frame;\n\t\tu16 frame_to_show_idx;\n\t\tu16 frame_type;  \n\t\tu16 show_frame;  \n\t\tu16 error_resilient_mode;  \n\t\tu16 intra_only;  \n\t\tu16 display_size_present;  \n\t\tu16 reset_frame_context;\n\t\tu16 refresh_frame_flags;\n\t\tu16 width;\n\t\tu16 height;\n\t\tu16 display_width;\n\t\tu16 display_height;\n\t\tu16 ref_info;\n\t\tu16 same_frame_size;\n\t\tu16 mode_ref_delta_enabled;\n\t\tu16 ref_deltas[4];\n\t\tu16 mode_deltas[2];\n\t\tu16 filter_level;\n\t\tu16 sharpness_level;\n\t\tu16 bit_depth;\n\t\tu16 seg_quant_info[8];\n\t\tu16 seg_enabled;\n\t\tu16 seg_abs_delta;\n\t\t \n\t\tu16 seg_lf_info[8];\n\t} p;\n};\n\nenum SEG_LVL_FEATURES {\n\tSEG_LVL_ALT_Q = 0,\t \n\tSEG_LVL_ALT_LF = 1,\t \n\tSEG_LVL_REF_FRAME = 2,\t \n\tSEG_LVL_SKIP = 3,\t \n\tSEG_LVL_MAX = 4\t\t \n};\n\nstruct segmentation {\n\tu8 enabled;\n\tu8 update_map;\n\tu8 update_data;\n\tu8 abs_delta;\n\tu8 temporal_update;\n\ts16 feature_data[MAX_SEGMENTS][SEG_LVL_MAX];\n\tunsigned int feature_mask[MAX_SEGMENTS];\n};\n\nstruct loop_filter_thresh {\n\tu8 mblim;\n\tu8 lim;\n\tu8 hev_thr;\n};\n\nstruct loop_filter_info_n {\n\tstruct loop_filter_thresh lfthr[MAX_LOOP_FILTER + 1];\n\tu8 lvl[MAX_SEGMENTS][MAX_REF_FRAMES][MAX_MODE_LF_DELTAS];\n};\n\nstruct loopfilter {\n\tint filter_level;\n\n\tint sharpness_level;\n\tint last_sharpness_level;\n\n\tu8 mode_ref_delta_enabled;\n\tu8 mode_ref_delta_update;\n\n\t \n\tsigned char ref_deltas[MAX_REF_LF_DELTAS];\n\tsigned char last_ref_deltas[MAX_REF_LF_DELTAS];\n\n\t \n\tsigned char mode_deltas[MAX_MODE_LF_DELTAS];\n\tsigned char last_mode_deltas[MAX_MODE_LF_DELTAS];\n};\n\nstruct vp9_frame {\n\tstruct list_head list;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tint index;\n\tint intra_only;\n\tint show;\n\tint type;\n\tint done;\n\tunsigned int width;\n\tunsigned int height;\n};\n\nstruct codec_vp9 {\n\t \n\tstruct mutex lock;\n\n\t \n\tstruct codec_hevc_common common;\n\n\t \n\tvoid      *workspace_vaddr;\n\tdma_addr_t workspace_paddr;\n\n\t \n\tunion rpm_param rpm_param;\n\n\t \n\tint is_10bit;\n\n\t \n\tu32 width, height;\n\n\t \n\tstruct list_head ref_frames_list;\n\tu32 frames_num;\n\n\t \n\tvoid      *fbc_buffer_vaddr[MAX_REF_PIC_NUM];\n\tdma_addr_t fbc_buffer_paddr[MAX_REF_PIC_NUM];\n\n\tint ref_frame_map[REF_FRAMES];\n\tint next_ref_frame_map[REF_FRAMES];\n\tstruct vp9_frame *frame_refs[REFS_PER_FRAME];\n\n\tu32 lcu_total;\n\n\t \n\tint default_filt_lvl;\n\tstruct loop_filter_info_n lfi;\n\tstruct loopfilter lf;\n\tstruct segmentation seg_4lf;\n\n\tstruct vp9_frame *cur_frame;\n\tstruct vp9_frame *prev_frame;\n};\n\nstatic int div_r32(s64 m, int n)\n{\n\ts64 qu = div_s64(m, n);\n\n\treturn (int)qu;\n}\n\nstatic int clip_prob(int p)\n{\n\treturn clamp_val(p, 1, 255);\n}\n\nstatic int segfeature_active(struct segmentation *seg, int segment_id,\n\t\t\t     enum SEG_LVL_FEATURES feature_id)\n{\n\treturn seg->enabled &&\n\t\t(seg->feature_mask[segment_id] & (1 << feature_id));\n}\n\nstatic int get_segdata(struct segmentation *seg, int segment_id,\n\t\t       enum SEG_LVL_FEATURES feature_id)\n{\n\treturn seg->feature_data[segment_id][feature_id];\n}\n\nstatic void vp9_update_sharpness(struct loop_filter_info_n *lfi,\n\t\t\t\t int sharpness_lvl)\n{\n\tint lvl;\n\n\t \n\tfor (lvl = 0; lvl <= MAX_LOOP_FILTER; lvl++) {\n\t\t \n\t\tint block_inside_limit = lvl >> ((sharpness_lvl > 0) +\n\t\t\t\t\t(sharpness_lvl > 4));\n\n\t\tif (sharpness_lvl > 0) {\n\t\t\tif (block_inside_limit > (9 - sharpness_lvl))\n\t\t\t\tblock_inside_limit = (9 - sharpness_lvl);\n\t\t}\n\n\t\tif (block_inside_limit < 1)\n\t\t\tblock_inside_limit = 1;\n\n\t\tlfi->lfthr[lvl].lim = (u8)block_inside_limit;\n\t\tlfi->lfthr[lvl].mblim = (u8)(2 * (lvl + 2) +\n\t\t\t\tblock_inside_limit);\n\t}\n}\n\n \nstatic void\nvp9_loop_filter_init(struct amvdec_core *core, struct codec_vp9 *vp9)\n{\n\tstruct loop_filter_info_n *lfi = &vp9->lfi;\n\tstruct loopfilter *lf = &vp9->lf;\n\tstruct segmentation *seg_4lf = &vp9->seg_4lf;\n\tint i;\n\n\tmemset(lfi, 0, sizeof(struct loop_filter_info_n));\n\tmemset(lf, 0, sizeof(struct loopfilter));\n\tmemset(seg_4lf, 0, sizeof(struct segmentation));\n\tlf->sharpness_level = 0;\n\tvp9_update_sharpness(lfi, lf->sharpness_level);\n\tlf->last_sharpness_level = lf->sharpness_level;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tunsigned int thr;\n\n\t\tthr = ((lfi->lfthr[i * 2 + 1].lim & 0x3f) << 8) |\n\t\t\t(lfi->lfthr[i * 2 + 1].mblim & 0xff);\n\t\tthr = (thr << 16) | ((lfi->lfthr[i * 2].lim & 0x3f) << 8) |\n\t\t\t(lfi->lfthr[i * 2].mblim & 0xff);\n\n\t\tamvdec_write_dos(core, HEVC_DBLK_CFG9, thr);\n\t}\n\n\tif (core->platform->revision >= VDEC_REVISION_SM1)\n\t\tamvdec_write_dos(core, HEVC_DBLK_CFGB,\n\t\t\t\t (0x3 << 14) |  \n\t\t\t\t (0x3 << 12) |  \n\t\t\t\t (0x3 << 10) |  \n\t\t\t\t BIT(0));  \n\telse if (core->platform->revision >= VDEC_REVISION_G12A)\n\t\t \n\t\tamvdec_write_dos(core, HEVC_DBLK_CFGB, (0x54 << 8) | BIT(0));\n\telse\n\t\tamvdec_write_dos(core, HEVC_DBLK_CFGB, 0x40400001);\n}\n\nstatic void\nvp9_loop_filter_frame_init(struct amvdec_core *core, struct segmentation *seg,\n\t\t\t   struct loop_filter_info_n *lfi,\n\t\t\t   struct loopfilter *lf, int default_filt_lvl)\n{\n\tint i;\n\tint seg_id;\n\n\t \n\tconst int scale = 1 << (default_filt_lvl >> 5);\n\n\t \n\tif (lf->last_sharpness_level != lf->sharpness_level) {\n\t\tvp9_update_sharpness(lfi, lf->sharpness_level);\n\t\tlf->last_sharpness_level = lf->sharpness_level;\n\n\t\t \n\t\tfor (i = 0; i < 32; i++) {\n\t\t\tunsigned int thr;\n\n\t\t\tthr = ((lfi->lfthr[i * 2 + 1].lim & 0x3f) << 8) |\n\t\t\t      (lfi->lfthr[i * 2 + 1].mblim & 0xff);\n\t\t\tthr = (thr << 16) |\n\t\t\t      ((lfi->lfthr[i * 2].lim & 0x3f) << 8) |\n\t\t\t      (lfi->lfthr[i * 2].mblim & 0xff);\n\n\t\t\tamvdec_write_dos(core, HEVC_DBLK_CFG9, thr);\n\t\t}\n\t}\n\n\tfor (seg_id = 0; seg_id < MAX_SEGMENTS; seg_id++) {\n\t\tint lvl_seg = default_filt_lvl;\n\n\t\tif (segfeature_active(seg, seg_id, SEG_LVL_ALT_LF)) {\n\t\t\tconst int data = get_segdata(seg, seg_id,\n\t\t\t\t\t\tSEG_LVL_ALT_LF);\n\t\t\tlvl_seg = clamp_t(int,\n\t\t\t\t\t  seg->abs_delta == SEGMENT_ABSDATA ?\n\t\t\t\t\t\tdata : default_filt_lvl + data,\n\t\t\t\t\t  0, MAX_LOOP_FILTER);\n\t\t}\n\n\t\tif (!lf->mode_ref_delta_enabled) {\n\t\t\t \n\t\t\tmemset(lfi->lvl[seg_id], lvl_seg,\n\t\t\t       sizeof(lfi->lvl[seg_id]));\n\t\t} else {\n\t\t\tint ref, mode;\n\t\t\tconst int intra_lvl =\n\t\t\t\tlvl_seg + lf->ref_deltas[INTRA_FRAME] * scale;\n\t\t\tlfi->lvl[seg_id][INTRA_FRAME][0] =\n\t\t\t\tclamp_val(intra_lvl, 0, MAX_LOOP_FILTER);\n\n\t\t\tfor (ref = LAST_FRAME; ref < MAX_REF_FRAMES; ++ref) {\n\t\t\t\tfor (mode = 0; mode < MAX_MODE_LF_DELTAS;\n\t\t\t\t     ++mode) {\n\t\t\t\t\tconst int inter_lvl =\n\t\t\t\t\t\tlvl_seg +\n\t\t\t\t\t\tlf->ref_deltas[ref] * scale +\n\t\t\t\t\t\tlf->mode_deltas[mode] * scale;\n\t\t\t\t\tlfi->lvl[seg_id][ref][mode] =\n\t\t\t\t\t\tclamp_val(inter_lvl, 0,\n\t\t\t\t\t\t\t  MAX_LOOP_FILTER);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < 16; i++) {\n\t\tunsigned int level;\n\n\t\tlevel = ((lfi->lvl[i >> 1][3][i & 1] & 0x3f) << 24) |\n\t\t\t((lfi->lvl[i >> 1][2][i & 1] & 0x3f) << 16) |\n\t\t\t((lfi->lvl[i >> 1][1][i & 1] & 0x3f) << 8) |\n\t\t\t(lfi->lvl[i >> 1][0][i & 1] & 0x3f);\n\t\tif (!default_filt_lvl)\n\t\t\tlevel = 0;\n\n\t\tamvdec_write_dos(core, HEVC_DBLK_CFGA, level);\n\t}\n}\n\nstatic void codec_vp9_flush_output(struct amvdec_session *sess)\n{\n\tstruct codec_vp9 *vp9 = sess->priv;\n\tstruct vp9_frame *tmp, *n;\n\n\tmutex_lock(&vp9->lock);\n\tlist_for_each_entry_safe(tmp, n, &vp9->ref_frames_list, list) {\n\t\tif (!tmp->done) {\n\t\t\tif (tmp->show)\n\t\t\t\tamvdec_dst_buf_done(sess, tmp->vbuf,\n\t\t\t\t\t\t    V4L2_FIELD_NONE);\n\t\t\telse\n\t\t\t\tv4l2_m2m_buf_queue(sess->m2m_ctx, tmp->vbuf);\n\n\t\t\tvp9->frames_num--;\n\t\t}\n\n\t\tlist_del(&tmp->list);\n\t\tkfree(tmp);\n\t}\n\tmutex_unlock(&vp9->lock);\n}\n\nstatic u32 codec_vp9_num_pending_bufs(struct amvdec_session *sess)\n{\n\tstruct codec_vp9 *vp9 = sess->priv;\n\n\tif (!vp9)\n\t\treturn 0;\n\n\treturn vp9->frames_num;\n}\n\nstatic int codec_vp9_alloc_workspace(struct amvdec_core *core,\n\t\t\t\t     struct codec_vp9 *vp9)\n{\n\t \n\tvp9->workspace_vaddr = dma_alloc_coherent(core->dev, SIZE_WORKSPACE,\n\t\t\t\t\t\t  &vp9->workspace_paddr,\n\t\t\t\t\t\t  GFP_KERNEL);\n\tif (!vp9->workspace_vaddr) {\n\t\tdev_err(core->dev, \"Failed to allocate VP9 Workspace\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void codec_vp9_setup_workspace(struct amvdec_session *sess,\n\t\t\t\t      struct codec_vp9 *vp9)\n{\n\tstruct amvdec_core *core = sess->core;\n\tu32 revision = core->platform->revision;\n\tdma_addr_t wkaddr = vp9->workspace_paddr;\n\n\tamvdec_write_dos(core, HEVCD_IPP_LINEBUFF_BASE, wkaddr + IPP_OFFSET);\n\tamvdec_write_dos(core, VP9_RPM_BUFFER, wkaddr + RPM_OFFSET);\n\tamvdec_write_dos(core, VP9_SHORT_TERM_RPS, wkaddr + SH_TM_RPS_OFFSET);\n\tamvdec_write_dos(core, VP9_PPS_BUFFER, wkaddr + PPS_OFFSET);\n\tamvdec_write_dos(core, VP9_SAO_UP, wkaddr + SAO_UP_OFFSET);\n\n\tamvdec_write_dos(core, VP9_STREAM_SWAP_BUFFER,\n\t\t\t wkaddr + SWAP_BUF_OFFSET);\n\tamvdec_write_dos(core, VP9_STREAM_SWAP_BUFFER2,\n\t\t\t wkaddr + SWAP_BUF2_OFFSET);\n\tamvdec_write_dos(core, VP9_SCALELUT, wkaddr + SCALELUT_OFFSET);\n\n\tif (core->platform->revision >= VDEC_REVISION_G12A)\n\t\tamvdec_write_dos(core, HEVC_DBLK_CFGE,\n\t\t\t\t wkaddr + DBLK_PARA_OFFSET);\n\n\tamvdec_write_dos(core, HEVC_DBLK_CFG4, wkaddr + DBLK_PARA_OFFSET);\n\tamvdec_write_dos(core, HEVC_DBLK_CFG5, wkaddr + DBLK_DATA_OFFSET);\n\tamvdec_write_dos(core, VP9_SEG_MAP_BUFFER, wkaddr + SEG_MAP_OFFSET);\n\tamvdec_write_dos(core, VP9_PROB_SWAP_BUFFER, wkaddr + PROB_OFFSET);\n\tamvdec_write_dos(core, VP9_COUNT_SWAP_BUFFER, wkaddr + COUNT_OFFSET);\n\tamvdec_write_dos(core, LMEM_DUMP_ADR, wkaddr + LMEM_OFFSET);\n\n\tif (codec_hevc_use_mmu(revision, sess->pixfmt_cap, vp9->is_10bit)) {\n\t\tamvdec_write_dos(core, HEVC_SAO_MMU_VH0_ADDR,\n\t\t\t\t wkaddr + MMU_VBH_OFFSET);\n\t\tamvdec_write_dos(core, HEVC_SAO_MMU_VH1_ADDR,\n\t\t\t\t wkaddr + MMU_VBH_OFFSET + (MMU_VBH_SIZE / 2));\n\n\t\tif (revision >= VDEC_REVISION_G12A)\n\t\t\tamvdec_write_dos(core, HEVC_ASSIST_MMU_MAP_ADDR,\n\t\t\t\t\t vp9->common.mmu_map_paddr);\n\t\telse\n\t\t\tamvdec_write_dos(core, VP9_MMU_MAP_BUFFER,\n\t\t\t\t\t vp9->common.mmu_map_paddr);\n\t}\n}\n\nstatic int codec_vp9_start(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct codec_vp9 *vp9;\n\tu32 val;\n\tint i;\n\tint ret;\n\n\tvp9 = kzalloc(sizeof(*vp9), GFP_KERNEL);\n\tif (!vp9)\n\t\treturn -ENOMEM;\n\n\tret = codec_vp9_alloc_workspace(core, vp9);\n\tif (ret)\n\t\tgoto free_vp9;\n\n\tcodec_vp9_setup_workspace(sess, vp9);\n\tamvdec_write_dos_bits(core, HEVC_STREAM_CONTROL, BIT(0));\n\t \n\tif (core->platform->revision >= VDEC_REVISION_G12A)\n\t\tamvdec_write_dos_bits(core, HEVC_STREAM_FIFO_CTL, BIT(29));\n\n\tval = amvdec_read_dos(core, HEVC_PARSER_INT_CONTROL) & 0x7fffffff;\n\tval |= (3 << 29) | BIT(24) | BIT(22) | BIT(7) | BIT(4) | BIT(0);\n\tamvdec_write_dos(core, HEVC_PARSER_INT_CONTROL, val);\n\tamvdec_write_dos_bits(core, HEVC_SHIFT_STATUS, BIT(0));\n\tamvdec_write_dos(core, HEVC_SHIFT_CONTROL, BIT(10) | BIT(9) |\n\t\t\t (3 << 6) | BIT(5) | BIT(2) | BIT(1) | BIT(0));\n\tamvdec_write_dos(core, HEVC_CABAC_CONTROL, BIT(0));\n\tamvdec_write_dos(core, HEVC_PARSER_CORE_CONTROL, BIT(0));\n\tamvdec_write_dos(core, HEVC_SHIFT_STARTCODE, 0x00000001);\n\n\tamvdec_write_dos(core, VP9_DEC_STATUS_REG, 0);\n\n\tamvdec_write_dos(core, HEVC_PARSER_CMD_WRITE, BIT(16));\n\tfor (i = 0; i < ARRAY_SIZE(vdec_hevc_parser_cmd); ++i)\n\t\tamvdec_write_dos(core, HEVC_PARSER_CMD_WRITE,\n\t\t\t\t vdec_hevc_parser_cmd[i]);\n\n\tamvdec_write_dos(core, HEVC_PARSER_CMD_SKIP_0, PARSER_CMD_SKIP_CFG_0);\n\tamvdec_write_dos(core, HEVC_PARSER_CMD_SKIP_1, PARSER_CMD_SKIP_CFG_1);\n\tamvdec_write_dos(core, HEVC_PARSER_CMD_SKIP_2, PARSER_CMD_SKIP_CFG_2);\n\tamvdec_write_dos(core, HEVC_PARSER_IF_CONTROL,\n\t\t\t BIT(5) | BIT(2) | BIT(0));\n\n\tamvdec_write_dos(core, HEVCD_IPP_TOP_CNTL, BIT(0));\n\tamvdec_write_dos(core, HEVCD_IPP_TOP_CNTL, BIT(1));\n\n\tamvdec_write_dos(core, VP9_WAIT_FLAG, 1);\n\n\t \n\tamvdec_write_dos(core, HEVC_ASSIST_MBOX1_CLR_REG, 1);\n\t \n\tamvdec_write_dos(core, HEVC_ASSIST_MBOX1_MASK, 1);\n\t \n\tamvdec_write_dos(core, HEVC_PSCALE_CTRL, 0);\n\t \n\tamvdec_write_dos(core, NAL_SEARCH_CTL, 0x8);\n\n\tamvdec_write_dos(core, DECODE_STOP_POS, 0);\n\tamvdec_write_dos(core, VP9_DECODE_MODE, DECODE_MODE_SINGLE);\n\n\tpr_debug(\"decode_count: %u; decode_size: %u\\n\",\n\t\t amvdec_read_dos(core, HEVC_DECODE_COUNT),\n\t\t amvdec_read_dos(core, HEVC_DECODE_SIZE));\n\n\tvp9_loop_filter_init(core, vp9);\n\n\tINIT_LIST_HEAD(&vp9->ref_frames_list);\n\tmutex_init(&vp9->lock);\n\tmemset(&vp9->ref_frame_map, -1, sizeof(vp9->ref_frame_map));\n\tmemset(&vp9->next_ref_frame_map, -1, sizeof(vp9->next_ref_frame_map));\n\tfor (i = 0; i < REFS_PER_FRAME; ++i)\n\t\tvp9->frame_refs[i] = NULL;\n\tsess->priv = vp9;\n\n\treturn 0;\n\nfree_vp9:\n\tkfree(vp9);\n\treturn ret;\n}\n\nstatic int codec_vp9_stop(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct codec_vp9 *vp9 = sess->priv;\n\n\tmutex_lock(&vp9->lock);\n\tif (vp9->workspace_vaddr)\n\t\tdma_free_coherent(core->dev, SIZE_WORKSPACE,\n\t\t\t\t  vp9->workspace_vaddr,\n\t\t\t\t  vp9->workspace_paddr);\n\n\tcodec_hevc_free_fbc_buffers(sess, &vp9->common);\n\tmutex_unlock(&vp9->lock);\n\n\treturn 0;\n}\n\n \nstatic void codec_vp9_set_mcrcc(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct codec_vp9 *vp9 = sess->priv;\n\tu32 val;\n\n\t \n\tamvdec_write_dos(core, HEVCD_MCRCC_CTL1, 0x2);\n\t \n\tif (vp9->cur_frame->type == KEY_FRAME || vp9->cur_frame->intra_only) {\n\t\tamvdec_write_dos(core, HEVCD_MCRCC_CTL1, 0x0);\n\t\treturn;\n\t}\n\n\tamvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, BIT(1));\n\tval = amvdec_read_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR) & 0xffff;\n\tval |= (val << 16);\n\tamvdec_write_dos(core, HEVCD_MCRCC_CTL2, val);\n\tval = amvdec_read_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR) & 0xffff;\n\tval |= (val << 16);\n\tamvdec_write_dos(core, HEVCD_MCRCC_CTL3, val);\n\n\t \n\tamvdec_write_dos(core, HEVCD_MCRCC_CTL1, 0xff0);\n}\n\nstatic void codec_vp9_set_sao(struct amvdec_session *sess,\n\t\t\t      struct vb2_buffer *vb)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct codec_vp9 *vp9 = sess->priv;\n\n\tdma_addr_t buf_y_paddr;\n\tdma_addr_t buf_u_v_paddr;\n\tu32 val;\n\n\tif (codec_hevc_use_downsample(sess->pixfmt_cap, vp9->is_10bit))\n\t\tbuf_y_paddr =\n\t\t\tvp9->common.fbc_buffer_paddr[vb->index];\n\telse\n\t\tbuf_y_paddr =\n\t\t       vb2_dma_contig_plane_dma_addr(vb, 0);\n\n\tif (codec_hevc_use_fbc(sess->pixfmt_cap, vp9->is_10bit)) {\n\t\tval = amvdec_read_dos(core, HEVC_SAO_CTRL5) & ~0xff0200;\n\t\tamvdec_write_dos(core, HEVC_SAO_CTRL5, val);\n\t\tamvdec_write_dos(core, HEVC_CM_BODY_START_ADDR, buf_y_paddr);\n\t}\n\n\tif (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M) {\n\t\tbuf_y_paddr =\n\t\t       vb2_dma_contig_plane_dma_addr(vb, 0);\n\t\tbuf_u_v_paddr =\n\t\t       vb2_dma_contig_plane_dma_addr(vb, 1);\n\t\tamvdec_write_dos(core, HEVC_SAO_Y_START_ADDR, buf_y_paddr);\n\t\tamvdec_write_dos(core, HEVC_SAO_C_START_ADDR, buf_u_v_paddr);\n\t\tamvdec_write_dos(core, HEVC_SAO_Y_WPTR, buf_y_paddr);\n\t\tamvdec_write_dos(core, HEVC_SAO_C_WPTR, buf_u_v_paddr);\n\t}\n\n\tif (codec_hevc_use_mmu(core->platform->revision, sess->pixfmt_cap,\n\t\t\t       vp9->is_10bit)) {\n\t\tamvdec_write_dos(core, HEVC_CM_HEADER_START_ADDR,\n\t\t\t\t vp9->common.mmu_header_paddr[vb->index]);\n\t\t \n\t\tamvdec_write_dos_bits(core, HEVC_SAO_CTRL5, BIT(10));\n\t}\n\n\tamvdec_write_dos(core, HEVC_SAO_Y_LENGTH,\n\t\t\t amvdec_get_output_size(sess));\n\tamvdec_write_dos(core, HEVC_SAO_C_LENGTH,\n\t\t\t (amvdec_get_output_size(sess) / 2));\n\n\tif (core->platform->revision >= VDEC_REVISION_G12A) {\n\t\tamvdec_clear_dos_bits(core, HEVC_DBLK_CFGB,\n\t\t\t\t      BIT(4) | BIT(5) | BIT(8) | BIT(9));\n\t\t \n\t\tif (codec_hevc_use_fbc(sess->pixfmt_cap, vp9->is_10bit))\n\t\t\tamvdec_write_dos_bits(core, HEVC_DBLK_CFGB, BIT(8));\n\n\t\t \n\t\tif (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M)\n\t\t\tamvdec_write_dos_bits(core, HEVC_DBLK_CFGB, BIT(9));\n\n\t\t \n\t\tif (sess->width >= 1280)\n\t\t\tamvdec_write_dos_bits(core, HEVC_DBLK_CFGB, BIT(4));\n\n\t\tpr_debug(\"HEVC_DBLK_CFGB: %08X\\n\",\n\t\t\t amvdec_read_dos(core, HEVC_DBLK_CFGB));\n\t}\n\n\tval = amvdec_read_dos(core, HEVC_SAO_CTRL1) & ~0x3ff0;\n\tval |= 0xff0;  \n\tif (core->platform->revision < VDEC_REVISION_G12A) {\n\t\tval &= ~0x3;\n\t\tif (!codec_hevc_use_fbc(sess->pixfmt_cap, vp9->is_10bit))\n\t\t\tval |= BIT(0);  \n\t\t \n\t}\n\n\tamvdec_write_dos(core, HEVC_SAO_CTRL1, val);\n\tpr_debug(\"HEVC_SAO_CTRL1: %08X\\n\", val);\n\n\t \n\tval = amvdec_read_dos(core, HEVC_SAO_CTRL5) & ~0xff0000;\n\tamvdec_write_dos(core, HEVC_SAO_CTRL5, val);\n\n\tval = amvdec_read_dos(core, HEVCD_IPP_AXIIF_CONFIG) & ~0x30;\n\tval |= 0xf;\n\tval &= ~BIT(12);  \n\tamvdec_write_dos(core, HEVCD_IPP_AXIIF_CONFIG, val);\n}\n\nstatic dma_addr_t codec_vp9_get_frame_mv_paddr(struct codec_vp9 *vp9,\n\t\t\t\t\t       struct vp9_frame *frame)\n{\n\treturn vp9->workspace_paddr + MPRED_MV_OFFSET +\n\t       (frame->index * MPRED_MV_BUF_SIZE);\n}\n\nstatic void codec_vp9_set_mpred_mv(struct amvdec_core *core,\n\t\t\t\t   struct codec_vp9 *vp9)\n{\n\tint mpred_mv_rd_end_addr;\n\tint use_prev_frame_mvs = vp9->prev_frame->width ==\n\t\t\t\t\tvp9->cur_frame->width &&\n\t\t\t\t vp9->prev_frame->height ==\n\t\t\t\t\tvp9->cur_frame->height &&\n\t\t\t\t !vp9->prev_frame->intra_only &&\n\t\t\t\t vp9->prev_frame->show &&\n\t\t\t\t vp9->prev_frame->type != KEY_FRAME;\n\n\tamvdec_write_dos(core, HEVC_MPRED_CTRL3, 0x24122412);\n\tamvdec_write_dos(core, HEVC_MPRED_ABV_START_ADDR,\n\t\t\t vp9->workspace_paddr + MPRED_ABV_OFFSET);\n\n\tamvdec_clear_dos_bits(core, HEVC_MPRED_CTRL4, BIT(6));\n\tif (use_prev_frame_mvs)\n\t\tamvdec_write_dos_bits(core, HEVC_MPRED_CTRL4, BIT(6));\n\n\tamvdec_write_dos(core, HEVC_MPRED_MV_WR_START_ADDR,\n\t\t\t codec_vp9_get_frame_mv_paddr(vp9, vp9->cur_frame));\n\tamvdec_write_dos(core, HEVC_MPRED_MV_WPTR,\n\t\t\t codec_vp9_get_frame_mv_paddr(vp9, vp9->cur_frame));\n\n\tamvdec_write_dos(core, HEVC_MPRED_MV_RD_START_ADDR,\n\t\t\t codec_vp9_get_frame_mv_paddr(vp9, vp9->prev_frame));\n\tamvdec_write_dos(core, HEVC_MPRED_MV_RPTR,\n\t\t\t codec_vp9_get_frame_mv_paddr(vp9, vp9->prev_frame));\n\n\tmpred_mv_rd_end_addr =\n\t\t\tcodec_vp9_get_frame_mv_paddr(vp9, vp9->prev_frame) +\n\t\t\t(vp9->lcu_total * MV_MEM_UNIT);\n\tamvdec_write_dos(core, HEVC_MPRED_MV_RD_END_ADDR, mpred_mv_rd_end_addr);\n}\n\nstatic void codec_vp9_update_next_ref(struct codec_vp9 *vp9)\n{\n\tunion rpm_param *param = &vp9->rpm_param;\n\tu32 buf_idx = vp9->cur_frame->index;\n\tint ref_index = 0;\n\tint refresh_frame_flags;\n\tint mask;\n\n\trefresh_frame_flags = vp9->cur_frame->type == KEY_FRAME ?\n\t\t\t\t0xff : param->p.refresh_frame_flags;\n\n\tfor (mask = refresh_frame_flags; mask; mask >>= 1) {\n\t\tpr_debug(\"mask=%08X; ref_index=%d\\n\", mask, ref_index);\n\t\tif (mask & 1)\n\t\t\tvp9->next_ref_frame_map[ref_index] = buf_idx;\n\t\telse\n\t\t\tvp9->next_ref_frame_map[ref_index] =\n\t\t\t\tvp9->ref_frame_map[ref_index];\n\n\t\t++ref_index;\n\t}\n\n\tfor (; ref_index < REF_FRAMES; ++ref_index)\n\t\tvp9->next_ref_frame_map[ref_index] =\n\t\t\tvp9->ref_frame_map[ref_index];\n}\n\nstatic void codec_vp9_save_refs(struct codec_vp9 *vp9)\n{\n\tunion rpm_param *param = &vp9->rpm_param;\n\tint i;\n\n\tfor (i = 0; i < REFS_PER_FRAME; ++i) {\n\t\tconst int ref = (param->p.ref_info >>\n\t\t\t\t (((REFS_PER_FRAME - i - 1) * 4) + 1)) & 0x7;\n\n\t\tif (vp9->ref_frame_map[ref] < 0)\n\t\t\tcontinue;\n\n\t\tpr_warn(\"%s: FIXME, would need to save ref %d\\n\",\n\t\t\t__func__, vp9->ref_frame_map[ref]);\n\t}\n}\n\nstatic void codec_vp9_update_ref(struct codec_vp9 *vp9)\n{\n\tunion rpm_param *param = &vp9->rpm_param;\n\tint ref_index = 0;\n\tint mask;\n\tint refresh_frame_flags;\n\n\tif (!vp9->cur_frame)\n\t\treturn;\n\n\trefresh_frame_flags = vp9->cur_frame->type == KEY_FRAME ?\n\t\t\t\t0xff : param->p.refresh_frame_flags;\n\n\tfor (mask = refresh_frame_flags; mask; mask >>= 1) {\n\t\tvp9->ref_frame_map[ref_index] =\n\t\t\tvp9->next_ref_frame_map[ref_index];\n\t\t++ref_index;\n\t}\n\n\tif (param->p.show_existing_frame)\n\t\treturn;\n\n\tfor (; ref_index < REF_FRAMES; ++ref_index)\n\t\tvp9->ref_frame_map[ref_index] =\n\t\t\tvp9->next_ref_frame_map[ref_index];\n}\n\nstatic struct vp9_frame *codec_vp9_get_frame_by_idx(struct codec_vp9 *vp9,\n\t\t\t\t\t\t    int idx)\n{\n\tstruct vp9_frame *frame;\n\n\tlist_for_each_entry(frame, &vp9->ref_frames_list, list) {\n\t\tif (frame->index == idx)\n\t\t\treturn frame;\n\t}\n\n\treturn NULL;\n}\n\nstatic void codec_vp9_sync_ref(struct codec_vp9 *vp9)\n{\n\tunion rpm_param *param = &vp9->rpm_param;\n\tint i;\n\n\tfor (i = 0; i < REFS_PER_FRAME; ++i) {\n\t\tconst int ref = (param->p.ref_info >>\n\t\t\t\t (((REFS_PER_FRAME - i - 1) * 4) + 1)) & 0x7;\n\t\tconst int idx = vp9->ref_frame_map[ref];\n\n\t\tvp9->frame_refs[i] = codec_vp9_get_frame_by_idx(vp9, idx);\n\t\tif (!vp9->frame_refs[i])\n\t\t\tpr_warn(\"%s: couldn't find VP9 ref %d\\n\", __func__,\n\t\t\t\tidx);\n\t}\n}\n\nstatic void codec_vp9_set_refs(struct amvdec_session *sess,\n\t\t\t       struct codec_vp9 *vp9)\n{\n\tstruct amvdec_core *core = sess->core;\n\tint i;\n\n\tfor (i = 0; i < REFS_PER_FRAME; ++i) {\n\t\tstruct vp9_frame *frame = vp9->frame_refs[i];\n\t\tint id_y;\n\t\tint id_u_v;\n\n\t\tif (!frame)\n\t\t\tcontinue;\n\n\t\tif (codec_hevc_use_fbc(sess->pixfmt_cap, vp9->is_10bit)) {\n\t\t\tid_y = frame->index;\n\t\t\tid_u_v = id_y;\n\t\t} else {\n\t\t\tid_y = frame->index * 2;\n\t\t\tid_u_v = id_y + 1;\n\t\t}\n\n\t\tamvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR,\n\t\t\t\t (id_u_v << 16) | (id_u_v << 8) | id_y);\n\t}\n}\n\nstatic void codec_vp9_set_mc(struct amvdec_session *sess,\n\t\t\t     struct codec_vp9 *vp9)\n{\n\tstruct amvdec_core *core = sess->core;\n\tu32 scale = 0;\n\tu32 sz;\n\tint i;\n\n\tamvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, 1);\n\tcodec_vp9_set_refs(sess, vp9);\n\tamvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,\n\t\t\t (16 << 8) | 1);\n\tcodec_vp9_set_refs(sess, vp9);\n\n\tamvdec_write_dos(core, VP9D_MPP_REFINFO_TBL_ACCCONFIG, BIT(2));\n\tfor (i = 0; i < REFS_PER_FRAME; ++i) {\n\t\tif (!vp9->frame_refs[i])\n\t\t\tcontinue;\n\n\t\tif (vp9->frame_refs[i]->width != vp9->width ||\n\t\t    vp9->frame_refs[i]->height != vp9->height)\n\t\t\tscale = 1;\n\n\t\tsz = amvdec_am21c_body_size(vp9->frame_refs[i]->width,\n\t\t\t\t\t    vp9->frame_refs[i]->height);\n\n\t\tamvdec_write_dos(core, VP9D_MPP_REFINFO_DATA,\n\t\t\t\t vp9->frame_refs[i]->width);\n\t\tamvdec_write_dos(core, VP9D_MPP_REFINFO_DATA,\n\t\t\t\t vp9->frame_refs[i]->height);\n\t\tamvdec_write_dos(core, VP9D_MPP_REFINFO_DATA,\n\t\t\t\t (vp9->frame_refs[i]->width << 14) /\n\t\t\t\t vp9->width);\n\t\tamvdec_write_dos(core, VP9D_MPP_REFINFO_DATA,\n\t\t\t\t (vp9->frame_refs[i]->height << 14) /\n\t\t\t\t vp9->height);\n\t\tamvdec_write_dos(core, VP9D_MPP_REFINFO_DATA, sz >> 5);\n\t}\n\n\tamvdec_write_dos(core, VP9D_MPP_REF_SCALE_ENBL, scale);\n}\n\nstatic struct vp9_frame *codec_vp9_get_new_frame(struct amvdec_session *sess)\n{\n\tstruct codec_vp9 *vp9 = sess->priv;\n\tunion rpm_param *param = &vp9->rpm_param;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct vp9_frame *new_frame;\n\n\tnew_frame = kzalloc(sizeof(*new_frame), GFP_KERNEL);\n\tif (!new_frame)\n\t\treturn NULL;\n\n\tvbuf = v4l2_m2m_dst_buf_remove(sess->m2m_ctx);\n\tif (!vbuf) {\n\t\tdev_err(sess->core->dev, \"No dst buffer available\\n\");\n\t\tkfree(new_frame);\n\t\treturn NULL;\n\t}\n\n\twhile (codec_vp9_get_frame_by_idx(vp9, vbuf->vb2_buf.index)) {\n\t\tstruct vb2_v4l2_buffer *old_vbuf = vbuf;\n\n\t\tvbuf = v4l2_m2m_dst_buf_remove(sess->m2m_ctx);\n\t\tv4l2_m2m_buf_queue(sess->m2m_ctx, old_vbuf);\n\t\tif (!vbuf) {\n\t\t\tdev_err(sess->core->dev, \"No dst buffer available\\n\");\n\t\t\tkfree(new_frame);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tnew_frame->vbuf = vbuf;\n\tnew_frame->index = vbuf->vb2_buf.index;\n\tnew_frame->intra_only = param->p.intra_only;\n\tnew_frame->show = param->p.show_frame;\n\tnew_frame->type = param->p.frame_type;\n\tnew_frame->width = vp9->width;\n\tnew_frame->height = vp9->height;\n\tlist_add_tail(&new_frame->list, &vp9->ref_frames_list);\n\tvp9->frames_num++;\n\n\treturn new_frame;\n}\n\nstatic void codec_vp9_show_existing_frame(struct codec_vp9 *vp9)\n{\n\tunion rpm_param *param = &vp9->rpm_param;\n\n\tif (!param->p.show_existing_frame)\n\t\treturn;\n\n\tpr_debug(\"showing frame %u\\n\", param->p.frame_to_show_idx);\n}\n\nstatic void codec_vp9_rm_noshow_frame(struct amvdec_session *sess)\n{\n\tstruct codec_vp9 *vp9 = sess->priv;\n\tstruct vp9_frame *tmp;\n\n\tlist_for_each_entry(tmp, &vp9->ref_frames_list, list) {\n\t\tif (tmp->show)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"rm noshow: %u\\n\", tmp->index);\n\t\tv4l2_m2m_buf_queue(sess->m2m_ctx, tmp->vbuf);\n\t\tlist_del(&tmp->list);\n\t\tkfree(tmp);\n\t\tvp9->frames_num--;\n\t\treturn;\n\t}\n}\n\nstatic void codec_vp9_process_frame(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct codec_vp9 *vp9 = sess->priv;\n\tunion rpm_param *param = &vp9->rpm_param;\n\tint intra_only;\n\n\tif (!param->p.show_frame)\n\t\tcodec_vp9_rm_noshow_frame(sess);\n\n\tvp9->cur_frame = codec_vp9_get_new_frame(sess);\n\tif (!vp9->cur_frame)\n\t\treturn;\n\n\tpr_debug(\"frame %d: type: %08X; show_exist: %u; show: %u, intra_only: %u\\n\",\n\t\t vp9->cur_frame->index,\n\t\t param->p.frame_type, param->p.show_existing_frame,\n\t\t param->p.show_frame, param->p.intra_only);\n\n\tif (param->p.frame_type != KEY_FRAME)\n\t\tcodec_vp9_sync_ref(vp9);\n\tcodec_vp9_update_next_ref(vp9);\n\tcodec_vp9_show_existing_frame(vp9);\n\n\tif (codec_hevc_use_mmu(core->platform->revision, sess->pixfmt_cap,\n\t\t\t       vp9->is_10bit))\n\t\tcodec_hevc_fill_mmu_map(sess, &vp9->common,\n\t\t\t\t\t&vp9->cur_frame->vbuf->vb2_buf);\n\n\tintra_only = param->p.show_frame ? 0 : param->p.intra_only;\n\n\t \n\tif (param->p.frame_type != KEY_FRAME && !intra_only) {\n\t\tcodec_vp9_set_mc(sess, vp9);\n\t\tcodec_vp9_set_mpred_mv(core, vp9);\n\t} else {\n\t\tamvdec_clear_dos_bits(core, HEVC_MPRED_CTRL4, BIT(6));\n\t}\n\n\tamvdec_write_dos(core, HEVC_PARSER_PICTURE_SIZE,\n\t\t\t (vp9->height << 16) | vp9->width);\n\tcodec_vp9_set_mcrcc(sess);\n\tcodec_vp9_set_sao(sess, &vp9->cur_frame->vbuf->vb2_buf);\n\n\tvp9_loop_filter_frame_init(core, &vp9->seg_4lf,\n\t\t\t\t   &vp9->lfi, &vp9->lf,\n\t\t\t\t   vp9->default_filt_lvl);\n\n\t \n\tamvdec_write_dos(core, VP9_DEC_STATUS_REG, VP9_10B_DECODE_SLICE);\n}\n\nstatic void codec_vp9_process_lf(struct codec_vp9 *vp9)\n{\n\tunion rpm_param *param = &vp9->rpm_param;\n\tint i;\n\n\tvp9->lf.mode_ref_delta_enabled = param->p.mode_ref_delta_enabled;\n\tvp9->lf.sharpness_level = param->p.sharpness_level;\n\tvp9->default_filt_lvl = param->p.filter_level;\n\tvp9->seg_4lf.enabled = param->p.seg_enabled;\n\tvp9->seg_4lf.abs_delta = param->p.seg_abs_delta;\n\n\tfor (i = 0; i < 4; i++)\n\t\tvp9->lf.ref_deltas[i] = param->p.ref_deltas[i];\n\n\tfor (i = 0; i < 2; i++)\n\t\tvp9->lf.mode_deltas[i] = param->p.mode_deltas[i];\n\n\tfor (i = 0; i < MAX_SEGMENTS; i++)\n\t\tvp9->seg_4lf.feature_mask[i] =\n\t\t\t(param->p.seg_lf_info[i] & 0x8000) ?\n\t\t\t\t(1 << SEG_LVL_ALT_LF) : 0;\n\n\tfor (i = 0; i < MAX_SEGMENTS; i++)\n\t\tvp9->seg_4lf.feature_data[i][SEG_LVL_ALT_LF] =\n\t\t\t(param->p.seg_lf_info[i] & 0x100) ?\n\t\t\t\t-(param->p.seg_lf_info[i] & 0x3f)\n\t\t\t\t: (param->p.seg_lf_info[i] & 0x3f);\n}\n\nstatic void codec_vp9_resume(struct amvdec_session *sess)\n{\n\tstruct codec_vp9 *vp9 = sess->priv;\n\n\tmutex_lock(&vp9->lock);\n\tif (codec_hevc_setup_buffers(sess, &vp9->common, vp9->is_10bit)) {\n\t\tmutex_unlock(&vp9->lock);\n\t\tamvdec_abort(sess);\n\t\treturn;\n\t}\n\n\tcodec_vp9_setup_workspace(sess, vp9);\n\tcodec_hevc_setup_decode_head(sess, vp9->is_10bit);\n\tcodec_vp9_process_lf(vp9);\n\tcodec_vp9_process_frame(sess);\n\n\tmutex_unlock(&vp9->lock);\n}\n\n \nstatic void codec_vp9_fetch_rpm(struct amvdec_session *sess)\n{\n\tstruct codec_vp9 *vp9 = sess->priv;\n\tu16 *rpm_vaddr = vp9->workspace_vaddr + RPM_OFFSET;\n\tint i, j;\n\n\tfor (i = 0; i < RPM_BUF_SIZE; i += 4)\n\t\tfor (j = 0; j < 4; j++)\n\t\t\tvp9->rpm_param.l.data[i + j] = rpm_vaddr[i + 3 - j];\n}\n\nstatic int codec_vp9_process_rpm(struct codec_vp9 *vp9)\n{\n\tunion rpm_param *param = &vp9->rpm_param;\n\tint src_changed = 0;\n\tint is_10bit = 0;\n\tint pic_width_64 = ALIGN(param->p.width, 64);\n\tint pic_height_32 = ALIGN(param->p.height, 32);\n\tint pic_width_lcu  = (pic_width_64 % LCU_SIZE) ?\n\t\t\t\tpic_width_64 / LCU_SIZE  + 1\n\t\t\t\t: pic_width_64 / LCU_SIZE;\n\tint pic_height_lcu = (pic_height_32 % LCU_SIZE) ?\n\t\t\t\tpic_height_32 / LCU_SIZE + 1\n\t\t\t\t: pic_height_32 / LCU_SIZE;\n\tvp9->lcu_total = pic_width_lcu * pic_height_lcu;\n\n\tif (param->p.bit_depth == 10)\n\t\tis_10bit = 1;\n\n\tif (vp9->width != param->p.width || vp9->height != param->p.height ||\n\t    vp9->is_10bit != is_10bit)\n\t\tsrc_changed = 1;\n\n\tvp9->width = param->p.width;\n\tvp9->height = param->p.height;\n\tvp9->is_10bit = is_10bit;\n\n\tpr_debug(\"width: %u; height: %u; is_10bit: %d; src_changed: %d\\n\",\n\t\t vp9->width, vp9->height, is_10bit, src_changed);\n\n\treturn src_changed;\n}\n\nstatic bool codec_vp9_is_ref(struct codec_vp9 *vp9, struct vp9_frame *frame)\n{\n\tint i;\n\n\tfor (i = 0; i < REF_FRAMES; ++i)\n\t\tif (vp9->ref_frame_map[i] == frame->index)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic void codec_vp9_show_frame(struct amvdec_session *sess)\n{\n\tstruct codec_vp9 *vp9 = sess->priv;\n\tstruct vp9_frame *tmp, *n;\n\n\tlist_for_each_entry_safe(tmp, n, &vp9->ref_frames_list, list) {\n\t\tif (!tmp->show || tmp == vp9->cur_frame)\n\t\t\tcontinue;\n\n\t\tif (!tmp->done) {\n\t\t\tpr_debug(\"Doning %u\\n\", tmp->index);\n\t\t\tamvdec_dst_buf_done(sess, tmp->vbuf, V4L2_FIELD_NONE);\n\t\t\ttmp->done = 1;\n\t\t\tvp9->frames_num--;\n\t\t}\n\n\t\tif (codec_vp9_is_ref(vp9, tmp) || tmp == vp9->prev_frame)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"deleting %d\\n\", tmp->index);\n\t\tlist_del(&tmp->list);\n\t\tkfree(tmp);\n\t}\n}\n\nstatic void vp9_tree_merge_probs(unsigned int *prev_prob,\n\t\t\t\t unsigned int *cur_prob,\n\t\t\t\t int coef_node_start, int tree_left,\n\t\t\t\t int tree_right,\n\t\t\t\t int tree_i, int node)\n{\n\tint prob_32, prob_res, prob_shift;\n\tint pre_prob, new_prob;\n\tint den, m_count, get_prob, factor;\n\n\tprob_32 = prev_prob[coef_node_start / 4 * 2];\n\tprob_res = coef_node_start & 3;\n\tprob_shift = prob_res * 8;\n\tpre_prob = (prob_32 >> prob_shift) & 0xff;\n\n\tden = tree_left + tree_right;\n\n\tif (den == 0) {\n\t\tnew_prob = pre_prob;\n\t} else {\n\t\tm_count = min(den, MODE_MV_COUNT_SAT);\n\t\tget_prob =\n\t\t\tclip_prob(div_r32(((int64_t)tree_left * 256 +\n\t\t\t\t\t   (den >> 1)),\n\t\t\t\t\t  den));\n\n\t\t \n\t\tfactor = count_to_update_factor[m_count];\n\t\tnew_prob = round_power_of_two(pre_prob * (256 - factor) +\n\t\t\t\t\t      get_prob * factor, 8);\n\t}\n\n\tcur_prob[coef_node_start / 4 * 2] =\n\t\t(cur_prob[coef_node_start / 4 * 2] & (~(0xff << prob_shift))) |\n\t\t(new_prob << prob_shift);\n}\n\nstatic void adapt_coef_probs_cxt(unsigned int *prev_prob,\n\t\t\t\t unsigned int *cur_prob,\n\t\t\t\t unsigned int *count,\n\t\t\t\t int update_factor,\n\t\t\t\t int cxt_num,\n\t\t\t\t int coef_cxt_start,\n\t\t\t\t int coef_count_cxt_start)\n{\n\tint prob_32, prob_res, prob_shift;\n\tint pre_prob, new_prob;\n\tint num, den, m_count, get_prob, factor;\n\tint node, coef_node_start;\n\tint count_sat = 24;\n\tint cxt;\n\n\tfor (cxt = 0; cxt < cxt_num; cxt++) {\n\t\tconst int n0 = count[coef_count_cxt_start];\n\t\tconst int n1 = count[coef_count_cxt_start + 1];\n\t\tconst int n2 = count[coef_count_cxt_start + 2];\n\t\tconst int neob = count[coef_count_cxt_start + 3];\n\t\tconst int nneob = count[coef_count_cxt_start + 4];\n\t\tconst unsigned int branch_ct[3][2] = {\n\t\t\t{ neob, nneob },\n\t\t\t{ n0, n1 + n2 },\n\t\t\t{ n1, n2 }\n\t\t};\n\n\t\tcoef_node_start = coef_cxt_start;\n\t\tfor (node = 0 ; node < 3 ; node++) {\n\t\t\tprob_32 = prev_prob[coef_node_start / 4 * 2];\n\t\t\tprob_res = coef_node_start & 3;\n\t\t\tprob_shift = prob_res * 8;\n\t\t\tpre_prob = (prob_32 >> prob_shift) & 0xff;\n\n\t\t\t \n\t\t\tnum = branch_ct[node][0];\n\t\t\tden = branch_ct[node][0] + branch_ct[node][1];\n\t\t\tm_count = min(den, count_sat);\n\n\t\t\tget_prob = (den == 0) ?\n\t\t\t\t\t128u :\n\t\t\t\t\tclip_prob(div_r32(((int64_t)num * 256 +\n\t\t\t\t\t\t\t  (den >> 1)), den));\n\n\t\t\tfactor = update_factor * m_count / count_sat;\n\t\t\tnew_prob =\n\t\t\t\tround_power_of_two(pre_prob * (256 - factor) +\n\t\t\t\t\t\t   get_prob * factor, 8);\n\n\t\t\tcur_prob[coef_node_start / 4 * 2] =\n\t\t\t\t(cur_prob[coef_node_start / 4 * 2] &\n\t\t\t\t (~(0xff << prob_shift))) |\n\t\t\t\t(new_prob << prob_shift);\n\n\t\t\tcoef_node_start += 1;\n\t\t}\n\n\t\tcoef_cxt_start = coef_cxt_start + 3;\n\t\tcoef_count_cxt_start = coef_count_cxt_start + 5;\n\t}\n}\n\nstatic void adapt_coef_probs(int prev_kf, int cur_kf, int pre_fc,\n\t\t\t     unsigned int *prev_prob, unsigned int *cur_prob,\n\t\t\t     unsigned int *count)\n{\n\tint tx_size, coef_tx_size_start, coef_count_tx_size_start;\n\tint plane, coef_plane_start, coef_count_plane_start;\n\tint type, coef_type_start, coef_count_type_start;\n\tint band, coef_band_start, coef_count_band_start;\n\tint cxt_num;\n\tint coef_cxt_start, coef_count_cxt_start;\n\tint node, coef_node_start, coef_count_node_start;\n\n\tint tree_i, tree_left, tree_right;\n\tint mvd_i;\n\n\tint update_factor = cur_kf ? 112 : (prev_kf ? 128 : 112);\n\n\tint prob_32;\n\tint prob_res;\n\tint prob_shift;\n\tint pre_prob;\n\n\tint den;\n\tint get_prob;\n\tint m_count;\n\tint factor;\n\n\tint new_prob;\n\n\tfor (tx_size = 0 ; tx_size < 4 ; tx_size++) {\n\t\tcoef_tx_size_start = VP9_COEF_START +\n\t\t\t\ttx_size * 4 * VP9_COEF_SIZE_ONE_SET;\n\t\tcoef_count_tx_size_start = VP9_COEF_COUNT_START +\n\t\t\t\ttx_size * 4 * VP9_COEF_COUNT_SIZE_ONE_SET;\n\t\tcoef_plane_start = coef_tx_size_start;\n\t\tcoef_count_plane_start = coef_count_tx_size_start;\n\n\t\tfor (plane = 0 ; plane < 2 ; plane++) {\n\t\t\tcoef_type_start = coef_plane_start;\n\t\t\tcoef_count_type_start = coef_count_plane_start;\n\n\t\t\tfor (type = 0 ; type < 2 ; type++) {\n\t\t\t\tcoef_band_start = coef_type_start;\n\t\t\t\tcoef_count_band_start = coef_count_type_start;\n\n\t\t\t\tfor (band = 0 ; band < 6 ; band++) {\n\t\t\t\t\tif (band == 0)\n\t\t\t\t\t\tcxt_num = 3;\n\t\t\t\t\telse\n\t\t\t\t\t\tcxt_num = 6;\n\t\t\t\t\tcoef_cxt_start = coef_band_start;\n\t\t\t\t\tcoef_count_cxt_start =\n\t\t\t\t\t\tcoef_count_band_start;\n\n\t\t\t\t\tadapt_coef_probs_cxt(prev_prob,\n\t\t\t\t\t\t\t     cur_prob,\n\t\t\t\t\t\t\t     count,\n\t\t\t\t\t\t\t     update_factor,\n\t\t\t\t\t\t\t     cxt_num,\n\t\t\t\t\t\t\t     coef_cxt_start,\n\t\t\t\t\t\t\tcoef_count_cxt_start);\n\n\t\t\t\t\tif (band == 0) {\n\t\t\t\t\t\tcoef_band_start += 10;\n\t\t\t\t\t\tcoef_count_band_start += 15;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcoef_band_start += 18;\n\t\t\t\t\t\tcoef_count_band_start += 30;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcoef_type_start += VP9_COEF_SIZE_ONE_SET;\n\t\t\t\tcoef_count_type_start +=\n\t\t\t\t\tVP9_COEF_COUNT_SIZE_ONE_SET;\n\t\t\t}\n\n\t\t\tcoef_plane_start += 2 * VP9_COEF_SIZE_ONE_SET;\n\t\t\tcoef_count_plane_start +=\n\t\t\t\t2 * VP9_COEF_COUNT_SIZE_ONE_SET;\n\t\t}\n\t}\n\n\tif (cur_kf == 0) {\n\t\t \n\t\tfor (coef_count_node_start = VP9_INTRA_INTER_COUNT_START;\n\t\t     coef_count_node_start < (VP9_MV_CLASS0_HP_1_COUNT_START +\n\t\t\t\t\t      VP9_MV_CLASS0_HP_1_COUNT_SIZE);\n\t\t     coef_count_node_start += 2) {\n\t\t\tif (coef_count_node_start ==\n\t\t\t\t\tVP9_INTRA_INTER_COUNT_START)\n\t\t\t\tcoef_node_start = VP9_INTRA_INTER_START;\n\t\t\telse if (coef_count_node_start ==\n\t\t\t\t\tVP9_COMP_INTER_COUNT_START)\n\t\t\t\tcoef_node_start = VP9_COMP_INTER_START;\n\t\t\telse if (coef_count_node_start ==\n\t\t\t\t\tVP9_TX_MODE_COUNT_START)\n\t\t\t\tcoef_node_start = VP9_TX_MODE_START;\n\t\t\telse if (coef_count_node_start ==\n\t\t\t\t\tVP9_SKIP_COUNT_START)\n\t\t\t\tcoef_node_start = VP9_SKIP_START;\n\t\t\telse if (coef_count_node_start ==\n\t\t\t\t\tVP9_MV_SIGN_0_COUNT_START)\n\t\t\t\tcoef_node_start = VP9_MV_SIGN_0_START;\n\t\t\telse if (coef_count_node_start ==\n\t\t\t\t\tVP9_MV_SIGN_1_COUNT_START)\n\t\t\t\tcoef_node_start = VP9_MV_SIGN_1_START;\n\t\t\telse if (coef_count_node_start ==\n\t\t\t\t\tVP9_MV_BITS_0_COUNT_START)\n\t\t\t\tcoef_node_start = VP9_MV_BITS_0_START;\n\t\t\telse if (coef_count_node_start ==\n\t\t\t\t\tVP9_MV_BITS_1_COUNT_START)\n\t\t\t\tcoef_node_start = VP9_MV_BITS_1_START;\n\t\t\telse  \n\t\t\t\tcoef_node_start = VP9_MV_CLASS0_HP_0_START;\n\n\t\t\tden = count[coef_count_node_start] +\n\t\t\t      count[coef_count_node_start + 1];\n\n\t\t\tprob_32 = prev_prob[coef_node_start / 4 * 2];\n\t\t\tprob_res = coef_node_start & 3;\n\t\t\tprob_shift = prob_res * 8;\n\t\t\tpre_prob = (prob_32 >> prob_shift) & 0xff;\n\n\t\t\tif (den == 0) {\n\t\t\t\tnew_prob = pre_prob;\n\t\t\t} else {\n\t\t\t\tm_count = min(den, MODE_MV_COUNT_SAT);\n\t\t\t\tget_prob =\n\t\t\t\tclip_prob(div_r32(((int64_t)\n\t\t\t\t\tcount[coef_count_node_start] * 256 +\n\t\t\t\t\t(den >> 1)),\n\t\t\t\t\tden));\n\n\t\t\t\t \n\t\t\t\tfactor = count_to_update_factor[m_count];\n\t\t\t\tnew_prob =\n\t\t\t\t\tround_power_of_two(pre_prob *\n\t\t\t\t\t\t\t   (256 - factor) +\n\t\t\t\t\t\t\t   get_prob * factor,\n\t\t\t\t\t\t\t   8);\n\t\t\t}\n\n\t\t\tcur_prob[coef_node_start / 4 * 2] =\n\t\t\t\t(cur_prob[coef_node_start / 4 * 2] &\n\t\t\t\t (~(0xff << prob_shift))) |\n\t\t\t\t(new_prob << prob_shift);\n\n\t\t\tcoef_node_start = coef_node_start + 1;\n\t\t}\n\n\t\tcoef_node_start = VP9_INTER_MODE_START;\n\t\tcoef_count_node_start = VP9_INTER_MODE_COUNT_START;\n\t\tfor (tree_i = 0 ; tree_i < 7 ; tree_i++) {\n\t\t\tfor (node = 0 ; node < 3 ; node++) {\n\t\t\t\tunsigned int start = coef_count_node_start;\n\n\t\t\t\tswitch (node) {\n\t\t\t\tcase 2:\n\t\t\t\t\ttree_left = count[start + 1];\n\t\t\t\t\ttree_right = count[start + 3];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\ttree_left = count[start + 0];\n\t\t\t\t\ttree_right = count[start + 1] +\n\t\t\t\t\t\t     count[start + 3];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttree_left = count[start + 2];\n\t\t\t\t\ttree_right = count[start + 0] +\n\t\t\t\t\t\t     count[start + 1] +\n\t\t\t\t\t\t     count[start + 3];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvp9_tree_merge_probs(prev_prob, cur_prob,\n\t\t\t\t\t\t     coef_node_start,\n\t\t\t\t\t\t     tree_left, tree_right,\n\t\t\t\t\t\t     tree_i, node);\n\n\t\t\t\tcoef_node_start = coef_node_start + 1;\n\t\t\t}\n\n\t\t\tcoef_count_node_start = coef_count_node_start + 4;\n\t\t}\n\n\t\tcoef_node_start = VP9_IF_Y_MODE_START;\n\t\tcoef_count_node_start = VP9_IF_Y_MODE_COUNT_START;\n\t\tfor (tree_i = 0 ; tree_i < 14 ; tree_i++) {\n\t\t\tfor (node = 0 ; node < 9 ; node++) {\n\t\t\t\tunsigned int start = coef_count_node_start;\n\n\t\t\t\tswitch (node) {\n\t\t\t\tcase 8:\n\t\t\t\t\ttree_left =\n\t\t\t\t\t\tcount[start + D153_PRED];\n\t\t\t\t\ttree_right =\n\t\t\t\t\t\tcount[start + D207_PRED];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\ttree_left =\n\t\t\t\t\t\tcount[start + D63_PRED];\n\t\t\t\t\ttree_right =\n\t\t\t\t\t\tcount[start + D207_PRED] +\n\t\t\t\t\t\tcount[start + D153_PRED];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\ttree_left =\n\t\t\t\t\t\tcount[start + D45_PRED];\n\t\t\t\t\ttree_right =\n\t\t\t\t\t\tcount[start + D207_PRED] +\n\t\t\t\t\t\tcount[start + D153_PRED] +\n\t\t\t\t\t\tcount[start + D63_PRED];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\ttree_left =\n\t\t\t\t\t\tcount[start + D135_PRED];\n\t\t\t\t\ttree_right =\n\t\t\t\t\t\tcount[start + D117_PRED];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\ttree_left =\n\t\t\t\t\t\tcount[start + H_PRED];\n\t\t\t\t\ttree_right =\n\t\t\t\t\t\tcount[start + D117_PRED] +\n\t\t\t\t\t\tcount[start + D135_PRED];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\ttree_left =\n\t\t\t\t\t\tcount[start + H_PRED] +\n\t\t\t\t\t\tcount[start + D117_PRED] +\n\t\t\t\t\t\tcount[start + D135_PRED];\n\t\t\t\t\ttree_right =\n\t\t\t\t\t\tcount[start + D45_PRED] +\n\t\t\t\t\t\tcount[start + D207_PRED] +\n\t\t\t\t\t\tcount[start + D153_PRED] +\n\t\t\t\t\t\tcount[start + D63_PRED];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\ttree_left =\n\t\t\t\t\t\tcount[start + V_PRED];\n\t\t\t\t\ttree_right =\n\t\t\t\t\t\tcount[start + H_PRED] +\n\t\t\t\t\t\tcount[start + D117_PRED] +\n\t\t\t\t\t\tcount[start + D135_PRED] +\n\t\t\t\t\t\tcount[start + D45_PRED] +\n\t\t\t\t\t\tcount[start + D207_PRED] +\n\t\t\t\t\t\tcount[start + D153_PRED] +\n\t\t\t\t\t\tcount[start + D63_PRED];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\ttree_left =\n\t\t\t\t\t\tcount[start + TM_PRED];\n\t\t\t\t\ttree_right =\n\t\t\t\t\t\tcount[start + V_PRED] +\n\t\t\t\t\t\tcount[start + H_PRED] +\n\t\t\t\t\t\tcount[start + D117_PRED] +\n\t\t\t\t\t\tcount[start + D135_PRED] +\n\t\t\t\t\t\tcount[start + D45_PRED] +\n\t\t\t\t\t\tcount[start + D207_PRED] +\n\t\t\t\t\t\tcount[start + D153_PRED] +\n\t\t\t\t\t\tcount[start + D63_PRED];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttree_left =\n\t\t\t\t\t\tcount[start + DC_PRED];\n\t\t\t\t\ttree_right =\n\t\t\t\t\t\tcount[start + TM_PRED] +\n\t\t\t\t\t\tcount[start + V_PRED] +\n\t\t\t\t\t\tcount[start + H_PRED] +\n\t\t\t\t\t\tcount[start + D117_PRED] +\n\t\t\t\t\t\tcount[start + D135_PRED] +\n\t\t\t\t\t\tcount[start + D45_PRED] +\n\t\t\t\t\t\tcount[start + D207_PRED] +\n\t\t\t\t\t\tcount[start + D153_PRED] +\n\t\t\t\t\t\tcount[start + D63_PRED];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvp9_tree_merge_probs(prev_prob, cur_prob,\n\t\t\t\t\t\t     coef_node_start,\n\t\t\t\t\t\t     tree_left, tree_right,\n\t\t\t\t\t\t     tree_i, node);\n\n\t\t\t\tcoef_node_start = coef_node_start + 1;\n\t\t\t}\n\t\t\tcoef_count_node_start = coef_count_node_start + 10;\n\t\t}\n\n\t\tcoef_node_start = VP9_PARTITION_P_START;\n\t\tcoef_count_node_start = VP9_PARTITION_P_COUNT_START;\n\t\tfor (tree_i = 0 ; tree_i < 16 ; tree_i++) {\n\t\t\tfor (node = 0 ; node < 3 ; node++) {\n\t\t\t\tunsigned int start = coef_count_node_start;\n\n\t\t\t\tswitch (node) {\n\t\t\t\tcase 2:\n\t\t\t\t\ttree_left = count[start + 2];\n\t\t\t\t\ttree_right = count[start + 3];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\ttree_left = count[start + 1];\n\t\t\t\t\ttree_right = count[start + 2] +\n\t\t\t\t\t\t     count[start + 3];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttree_left = count[start + 0];\n\t\t\t\t\ttree_right = count[start + 1] +\n\t\t\t\t\t\t     count[start + 2] +\n\t\t\t\t\t\t     count[start + 3];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvp9_tree_merge_probs(prev_prob, cur_prob,\n\t\t\t\t\t\t     coef_node_start,\n\t\t\t\t\t\t     tree_left, tree_right,\n\t\t\t\t\t\t     tree_i, node);\n\n\t\t\t\tcoef_node_start = coef_node_start + 1;\n\t\t\t}\n\n\t\t\tcoef_count_node_start = coef_count_node_start + 4;\n\t\t}\n\n\t\tcoef_node_start = VP9_INTERP_START;\n\t\tcoef_count_node_start = VP9_INTERP_COUNT_START;\n\t\tfor (tree_i = 0 ; tree_i < 4 ; tree_i++) {\n\t\t\tfor (node = 0 ; node < 2 ; node++) {\n\t\t\t\tunsigned int start = coef_count_node_start;\n\n\t\t\t\tswitch (node) {\n\t\t\t\tcase 1:\n\t\t\t\t\ttree_left = count[start + 1];\n\t\t\t\t\ttree_right = count[start + 2];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttree_left = count[start + 0];\n\t\t\t\t\ttree_right = count[start + 1] +\n\t\t\t\t\t\t     count[start + 2];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvp9_tree_merge_probs(prev_prob, cur_prob,\n\t\t\t\t\t\t     coef_node_start,\n\t\t\t\t\t\t     tree_left, tree_right,\n\t\t\t\t\t\t     tree_i, node);\n\n\t\t\t\tcoef_node_start = coef_node_start + 1;\n\t\t\t}\n\t\t\tcoef_count_node_start = coef_count_node_start + 3;\n\t\t}\n\n\t\tcoef_node_start = VP9_MV_JOINTS_START;\n\t\tcoef_count_node_start = VP9_MV_JOINTS_COUNT_START;\n\t\tfor (tree_i = 0 ; tree_i < 1 ; tree_i++) {\n\t\t\tfor (node = 0 ; node < 3 ; node++) {\n\t\t\t\tunsigned int start = coef_count_node_start;\n\n\t\t\t\tswitch (node) {\n\t\t\t\tcase 2:\n\t\t\t\t\ttree_left = count[start + 2];\n\t\t\t\t\ttree_right = count[start + 3];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\ttree_left = count[start + 1];\n\t\t\t\t\ttree_right = count[start + 2] +\n\t\t\t\t\t\t     count[start + 3];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttree_left = count[start + 0];\n\t\t\t\t\ttree_right = count[start + 1] +\n\t\t\t\t\t\t     count[start + 2] +\n\t\t\t\t\t\t     count[start + 3];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvp9_tree_merge_probs(prev_prob, cur_prob,\n\t\t\t\t\t\t     coef_node_start,\n\t\t\t\t\t\t     tree_left, tree_right,\n\t\t\t\t\t\t     tree_i, node);\n\n\t\t\t\tcoef_node_start = coef_node_start + 1;\n\t\t\t}\n\t\t\tcoef_count_node_start = coef_count_node_start + 4;\n\t\t}\n\n\t\tfor (mvd_i = 0 ; mvd_i < 2 ; mvd_i++) {\n\t\t\tcoef_node_start = mvd_i ? VP9_MV_CLASSES_1_START :\n\t\t\t\t\t\t  VP9_MV_CLASSES_0_START;\n\t\t\tcoef_count_node_start = mvd_i ?\n\t\t\t\t\tVP9_MV_CLASSES_1_COUNT_START :\n\t\t\t\t\tVP9_MV_CLASSES_0_COUNT_START;\n\t\t\ttree_i = 0;\n\t\t\tfor (node = 0; node < 10; node++) {\n\t\t\t\tunsigned int start = coef_count_node_start;\n\n\t\t\t\tswitch (node) {\n\t\t\t\tcase 9:\n\t\t\t\t\ttree_left = count[start + 9];\n\t\t\t\t\ttree_right = count[start + 10];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\ttree_left = count[start + 7];\n\t\t\t\t\ttree_right = count[start + 8];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\ttree_left = count[start + 7] +\n\t\t\t\t\t\t     count[start + 8];\n\t\t\t\t\ttree_right = count[start + 9] +\n\t\t\t\t\t\t     count[start + 10];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\ttree_left = count[start + 6];\n\t\t\t\t\ttree_right = count[start + 7] +\n\t\t\t\t\t\t     count[start + 8] +\n\t\t\t\t\t\t     count[start + 9] +\n\t\t\t\t\t\t     count[start + 10];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\ttree_left = count[start + 4];\n\t\t\t\t\ttree_right = count[start + 5];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\ttree_left = count[start + 4] +\n\t\t\t\t\t\t    count[start + 5];\n\t\t\t\t\ttree_right = count[start + 6] +\n\t\t\t\t\t\t     count[start + 7] +\n\t\t\t\t\t\t     count[start + 8] +\n\t\t\t\t\t\t     count[start + 9] +\n\t\t\t\t\t\t     count[start + 10];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\ttree_left = count[start + 2];\n\t\t\t\t\ttree_right = count[start + 3];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\ttree_left = count[start + 2] +\n\t\t\t\t\t\t    count[start + 3];\n\t\t\t\t\ttree_right = count[start + 4] +\n\t\t\t\t\t\t     count[start + 5] +\n\t\t\t\t\t\t     count[start + 6] +\n\t\t\t\t\t\t     count[start + 7] +\n\t\t\t\t\t\t     count[start + 8] +\n\t\t\t\t\t\t     count[start + 9] +\n\t\t\t\t\t\t     count[start + 10];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\ttree_left = count[start + 1];\n\t\t\t\t\ttree_right = count[start + 2] +\n\t\t\t\t\t\t     count[start + 3] +\n\t\t\t\t\t\t     count[start + 4] +\n\t\t\t\t\t\t     count[start + 5] +\n\t\t\t\t\t\t     count[start + 6] +\n\t\t\t\t\t\t     count[start + 7] +\n\t\t\t\t\t\t     count[start + 8] +\n\t\t\t\t\t\t     count[start + 9] +\n\t\t\t\t\t\t     count[start + 10];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttree_left = count[start + 0];\n\t\t\t\t\ttree_right = count[start + 1] +\n\t\t\t\t\t\t     count[start + 2] +\n\t\t\t\t\t\t     count[start + 3] +\n\t\t\t\t\t\t     count[start + 4] +\n\t\t\t\t\t\t     count[start + 5] +\n\t\t\t\t\t\t     count[start + 6] +\n\t\t\t\t\t\t     count[start + 7] +\n\t\t\t\t\t\t     count[start + 8] +\n\t\t\t\t\t\t     count[start + 9] +\n\t\t\t\t\t\t     count[start + 10];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvp9_tree_merge_probs(prev_prob, cur_prob,\n\t\t\t\t\t\t     coef_node_start,\n\t\t\t\t\t\t     tree_left, tree_right,\n\t\t\t\t\t\t     tree_i, node);\n\n\t\t\t\tcoef_node_start = coef_node_start + 1;\n\t\t\t}\n\n\t\t\tcoef_node_start = mvd_i ? VP9_MV_CLASS0_1_START :\n\t\t\t\t\t\t  VP9_MV_CLASS0_0_START;\n\t\t\tcoef_count_node_start =\tmvd_i ?\n\t\t\t\t\t\tVP9_MV_CLASS0_1_COUNT_START :\n\t\t\t\t\t\tVP9_MV_CLASS0_0_COUNT_START;\n\t\t\ttree_i = 0;\n\t\t\tnode = 0;\n\t\t\ttree_left = count[coef_count_node_start + 0];\n\t\t\ttree_right = count[coef_count_node_start + 1];\n\n\t\t\tvp9_tree_merge_probs(prev_prob, cur_prob,\n\t\t\t\t\t     coef_node_start,\n\t\t\t\t\t     tree_left, tree_right,\n\t\t\t\t\t     tree_i, node);\n\t\t\tcoef_node_start = mvd_i ? VP9_MV_CLASS0_FP_1_START :\n\t\t\t\t\t\t  VP9_MV_CLASS0_FP_0_START;\n\t\t\tcoef_count_node_start =\tmvd_i ?\n\t\t\t\t\tVP9_MV_CLASS0_FP_1_COUNT_START :\n\t\t\t\t\tVP9_MV_CLASS0_FP_0_COUNT_START;\n\n\t\t\tfor (tree_i = 0; tree_i < 3; tree_i++) {\n\t\t\t\tfor (node = 0; node < 3; node++) {\n\t\t\t\t\tunsigned int start =\n\t\t\t\t\t\tcoef_count_node_start;\n\t\t\t\t\tswitch (node) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\ttree_left = count[start + 2];\n\t\t\t\t\t\ttree_right = count[start + 3];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\ttree_left = count[start + 1];\n\t\t\t\t\t\ttree_right = count[start + 2] +\n\t\t\t\t\t\t\t     count[start + 3];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttree_left = count[start + 0];\n\t\t\t\t\t\ttree_right = count[start + 1] +\n\t\t\t\t\t\t\t     count[start + 2] +\n\t\t\t\t\t\t\t     count[start + 3];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tvp9_tree_merge_probs(prev_prob,\n\t\t\t\t\t\t\t     cur_prob,\n\t\t\t\t\t\t\t     coef_node_start,\n\t\t\t\t\t\t\t     tree_left,\n\t\t\t\t\t\t\t     tree_right,\n\t\t\t\t\t\t\t     tree_i, node);\n\n\t\t\t\t\tcoef_node_start = coef_node_start + 1;\n\t\t\t\t}\n\t\t\t\tcoef_count_node_start =\n\t\t\t\t\tcoef_count_node_start + 4;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic irqreturn_t codec_vp9_threaded_isr(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct codec_vp9 *vp9 = sess->priv;\n\tu32 dec_status = amvdec_read_dos(core, VP9_DEC_STATUS_REG);\n\tu32 prob_status = amvdec_read_dos(core, VP9_ADAPT_PROB_REG);\n\tint i;\n\n\tif (!vp9)\n\t\treturn IRQ_HANDLED;\n\n\tmutex_lock(&vp9->lock);\n\tif (dec_status != VP9_HEAD_PARSER_DONE) {\n\t\tdev_err(core->dev_dec, \"Unrecognized dec_status: %08X\\n\",\n\t\t\tdec_status);\n\t\tamvdec_abort(sess);\n\t\tgoto unlock;\n\t}\n\n\tpr_debug(\"ISR: %08X;%08X\\n\", dec_status, prob_status);\n\tsess->keyframe_found = 1;\n\n\tif ((prob_status & 0xff) == 0xfd && vp9->cur_frame) {\n\t\t \n\t\tu8 *prev_prob_b = ((u8 *)vp9->workspace_vaddr +\n\t\t\t\t\t PROB_OFFSET) +\n\t\t\t\t\t((prob_status >> 8) * 0x1000);\n\t\tu8 *cur_prob_b = ((u8 *)vp9->workspace_vaddr +\n\t\t\t\t\t PROB_OFFSET) + 0x4000;\n\t\tu8 *count_b = (u8 *)vp9->workspace_vaddr +\n\t\t\t\t   COUNT_OFFSET;\n\t\tint last_frame_type = vp9->prev_frame ?\n\t\t\t\t\t\tvp9->prev_frame->type :\n\t\t\t\t\t\tKEY_FRAME;\n\n\t\tadapt_coef_probs(last_frame_type == KEY_FRAME,\n\t\t\t\t vp9->cur_frame->type == KEY_FRAME ? 1 : 0,\n\t\t\t\t prob_status >> 8,\n\t\t\t\t (unsigned int *)prev_prob_b,\n\t\t\t\t (unsigned int *)cur_prob_b,\n\t\t\t\t (unsigned int *)count_b);\n\n\t\tmemcpy(prev_prob_b, cur_prob_b, ADAPT_PROB_SIZE);\n\t\tamvdec_write_dos(core, VP9_ADAPT_PROB_REG, 0);\n\t}\n\n\t \n\tfor (i = 0; i < REFS_PER_FRAME ; ++i)\n\t\tvp9->frame_refs[i] = NULL;\n\n\tvp9->prev_frame = vp9->cur_frame;\n\tcodec_vp9_update_ref(vp9);\n\n\tcodec_vp9_fetch_rpm(sess);\n\tif (codec_vp9_process_rpm(vp9)) {\n\t\tamvdec_src_change(sess, vp9->width, vp9->height, 16);\n\n\t\t \n\t\tvp9->cur_frame = NULL;\n\n\t\t \n\t\tcodec_vp9_show_frame(sess);\n\n\t\t \n\t\tif (vp9->frames_num)\n\t\t\tcodec_vp9_save_refs(vp9);\n\n\t\tgoto unlock;\n\t}\n\n\tcodec_vp9_process_lf(vp9);\n\tcodec_vp9_process_frame(sess);\n\tcodec_vp9_show_frame(sess);\n\nunlock:\n\tmutex_unlock(&vp9->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t codec_vp9_isr(struct amvdec_session *sess)\n{\n\treturn IRQ_WAKE_THREAD;\n}\n\nstruct amvdec_codec_ops codec_vp9_ops = {\n\t.start = codec_vp9_start,\n\t.stop = codec_vp9_stop,\n\t.isr = codec_vp9_isr,\n\t.threaded_isr = codec_vp9_threaded_isr,\n\t.num_pending_bufs = codec_vp9_num_pending_bufs,\n\t.drain = codec_vp9_flush_output,\n\t.resume = codec_vp9_resume,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}