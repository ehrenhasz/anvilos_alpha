{
  "module_name": "vdec_1.c",
  "hash_id": "a28224330a52bf904014124250191c00250eb3ee38fd20c66a10b31bce8325d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/meson/vdec/vdec_1.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/clk.h>\n\n#include \"vdec_1.h\"\n#include \"vdec_helpers.h\"\n#include \"dos_regs.h\"\n\n \n#define AO_RTI_GEN_PWR_SLEEP0\t0xe8\n#define AO_RTI_GEN_PWR_ISO0\t0xec\n\t#define GEN_PWR_VDEC_1 (BIT(3) | BIT(2))\n\t#define GEN_PWR_VDEC_1_SM1 (BIT(1))\n\n#define MC_SIZE\t\t\t(4096 * 4)\n\nstatic int\nvdec_1_load_firmware(struct amvdec_session *sess, const char *fwname)\n{\n\tconst struct firmware *fw;\n\tstruct amvdec_core *core = sess->core;\n\tstruct device *dev = core->dev_dec;\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\tstatic void *mc_addr;\n\tstatic dma_addr_t mc_addr_map;\n\tint ret;\n\tu32 i = 1000;\n\n\tret = request_firmware(&fw, fwname, dev);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tif (fw->size < MC_SIZE) {\n\t\tdev_err(dev, \"Firmware size %zu is too small. Expected %u.\\n\",\n\t\t\tfw->size, MC_SIZE);\n\t\tret = -EINVAL;\n\t\tgoto release_firmware;\n\t}\n\n\tmc_addr = dma_alloc_coherent(core->dev, MC_SIZE,\n\t\t\t\t     &mc_addr_map, GFP_KERNEL);\n\tif (!mc_addr) {\n\t\tret = -ENOMEM;\n\t\tgoto release_firmware;\n\t}\n\n\tmemcpy(mc_addr, fw->data, MC_SIZE);\n\n\tamvdec_write_dos(core, MPSR, 0);\n\tamvdec_write_dos(core, CPSR, 0);\n\n\tamvdec_clear_dos_bits(core, MDEC_PIC_DC_CTRL, BIT(31));\n\n\tamvdec_write_dos(core, IMEM_DMA_ADR, mc_addr_map);\n\tamvdec_write_dos(core, IMEM_DMA_COUNT, MC_SIZE / 4);\n\tamvdec_write_dos(core, IMEM_DMA_CTRL, (0x8000 | (7 << 16)));\n\n\twhile (--i && amvdec_read_dos(core, IMEM_DMA_CTRL) & 0x8000);\n\n\tif (i == 0) {\n\t\tdev_err(dev, \"Firmware load fail (DMA hang?)\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_mc;\n\t}\n\n\tif (codec_ops->load_extended_firmware)\n\t\tret = codec_ops->load_extended_firmware(sess,\n\t\t\t\t\t\t\tfw->data + MC_SIZE,\n\t\t\t\t\t\t\tfw->size - MC_SIZE);\n\nfree_mc:\n\tdma_free_coherent(core->dev, MC_SIZE, mc_addr, mc_addr_map);\nrelease_firmware:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic int vdec_1_stbuf_power_up(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\n\tamvdec_write_dos(core, VLD_MEM_VIFIFO_CONTROL, 0);\n\tamvdec_write_dos(core, VLD_MEM_VIFIFO_WRAP_COUNT, 0);\n\tamvdec_write_dos(core, POWER_CTL_VLD, BIT(4));\n\n\tamvdec_write_dos(core, VLD_MEM_VIFIFO_START_PTR, sess->vififo_paddr);\n\tamvdec_write_dos(core, VLD_MEM_VIFIFO_CURR_PTR, sess->vififo_paddr);\n\tamvdec_write_dos(core, VLD_MEM_VIFIFO_END_PTR,\n\t\t\t sess->vififo_paddr + sess->vififo_size - 8);\n\n\tamvdec_write_dos_bits(core, VLD_MEM_VIFIFO_CONTROL, 1);\n\tamvdec_clear_dos_bits(core, VLD_MEM_VIFIFO_CONTROL, 1);\n\n\tamvdec_write_dos(core, VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_MANUAL);\n\tamvdec_write_dos(core, VLD_MEM_VIFIFO_WP, sess->vififo_paddr);\n\n\tamvdec_write_dos_bits(core, VLD_MEM_VIFIFO_BUF_CNTL, 1);\n\tamvdec_clear_dos_bits(core, VLD_MEM_VIFIFO_BUF_CNTL, 1);\n\n\tamvdec_write_dos_bits(core, VLD_MEM_VIFIFO_CONTROL,\n\t\t\t      (0x11 << MEM_FIFO_CNT_BIT) | MEM_FILL_ON_LEVEL |\n\t\t\t      MEM_CTRL_FILL_EN | MEM_CTRL_EMPTY_EN);\n\n\treturn 0;\n}\n\nstatic void vdec_1_conf_esparser(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\n\t \n\tamvdec_write_dos(core, DOS_GEN_CTRL0, 0);\n\tamvdec_write_dos(core, VLD_MEM_VIFIFO_BUF_CNTL, 1);\n\tamvdec_clear_dos_bits(core, VLD_MEM_VIFIFO_BUF_CNTL, 1);\n}\n\nstatic u32 vdec_1_vififo_level(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\n\treturn amvdec_read_dos(core, VLD_MEM_VIFIFO_LEVEL);\n}\n\nstatic int vdec_1_stop(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\n\tamvdec_write_dos(core, MPSR, 0);\n\tamvdec_write_dos(core, CPSR, 0);\n\tamvdec_write_dos(core, ASSIST_MBOX1_MASK, 0);\n\n\tamvdec_write_dos(core, DOS_SW_RESET0, BIT(12) | BIT(11));\n\tamvdec_write_dos(core, DOS_SW_RESET0, 0);\n\tamvdec_read_dos(core, DOS_SW_RESET0);\n\n\t \n\tif (core->platform->revision == VDEC_REVISION_SM1)\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_ISO0,\n\t\t\t\t   GEN_PWR_VDEC_1_SM1, GEN_PWR_VDEC_1_SM1);\n\telse\n\t\tregmap_write(core->regmap_ao, AO_RTI_GEN_PWR_ISO0, 0xc0);\n\t \n\tamvdec_write_dos(core, DOS_MEM_PD_VDEC, 0xffffffff);\n\t \n\tif (core->platform->revision == VDEC_REVISION_SM1)\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t\t   GEN_PWR_VDEC_1_SM1, GEN_PWR_VDEC_1_SM1);\n\telse\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t\t   GEN_PWR_VDEC_1, GEN_PWR_VDEC_1);\n\n\tclk_disable_unprepare(core->vdec_1_clk);\n\n\tif (sess->priv)\n\t\tcodec_ops->stop(sess);\n\n\treturn 0;\n}\n\nstatic int vdec_1_start(struct amvdec_session *sess)\n{\n\tint ret;\n\tstruct amvdec_core *core = sess->core;\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\n\t \n\tclk_set_rate(core->vdec_1_clk, 666666666);\n\tret = clk_prepare_enable(core->vdec_1_clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (core->platform->revision == VDEC_REVISION_SM1)\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t\t   GEN_PWR_VDEC_1_SM1, 0);\n\telse\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t\t   GEN_PWR_VDEC_1, 0);\n\tusleep_range(10, 20);\n\n\t \n\tamvdec_write_dos(core, DOS_SW_RESET0, 0xfffffffc);\n\tamvdec_write_dos(core, DOS_SW_RESET0, 0x00000000);\n\n\tamvdec_write_dos(core, DOS_GCLK_EN0, 0x3ff);\n\n\t \n\tamvdec_write_dos(core, DOS_MEM_PD_VDEC, 0);\n\t \n\tif (core->platform->revision == VDEC_REVISION_SM1)\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_ISO0,\n\t\t\t\t   GEN_PWR_VDEC_1_SM1, 0);\n\telse\n\t\tregmap_write(core->regmap_ao, AO_RTI_GEN_PWR_ISO0, 0);\n\t \n\tamvdec_write_dos(core, DOS_VDEC_MCRCC_STALL_CTRL, 0);\n\n\tamvdec_write_dos(core, GCLK_EN, 0x3ff);\n\tamvdec_clear_dos_bits(core, MDEC_PIC_DC_CTRL, BIT(31));\n\n\tvdec_1_stbuf_power_up(sess);\n\n\tret = vdec_1_load_firmware(sess, sess->fmt_out->firmware_path);\n\tif (ret)\n\t\tgoto stop;\n\n\tret = codec_ops->start(sess);\n\tif (ret)\n\t\tgoto stop;\n\n\t \n\tamvdec_write_dos(core, ASSIST_MBOX1_CLR_REG, 1);\n\tamvdec_write_dos(core, ASSIST_MBOX1_MASK, 1);\n\n\t \n\tif (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M)\n\t\tamvdec_write_dos_bits(core, MDEC_PIC_DC_CTRL, BIT(17));\n\telse\n\t\tamvdec_clear_dos_bits(core, MDEC_PIC_DC_CTRL, BIT(17));\n\n\t \n\tamvdec_write_dos(core, MPSR, 1);\n\t \n\tusleep_range(10, 20);\n\n\treturn 0;\n\nstop:\n\tvdec_1_stop(sess);\n\treturn ret;\n}\n\nstruct amvdec_ops vdec_1_ops = {\n\t.start = vdec_1_start,\n\t.stop = vdec_1_stop,\n\t.conf_esparser = vdec_1_conf_esparser,\n\t.vififo_level = vdec_1_vififo_level,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}