{
  "module_name": "codec_hevc_common.c",
  "hash_id": "b7abb3c3b487d8d8abb89643ef6be505fc822f20ad38f8c21ff61bf70d8b8771",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/meson/vdec/codec_hevc_common.c",
  "human_readable_source": "\n \n\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"codec_hevc_common.h\"\n#include \"vdec_helpers.h\"\n#include \"hevc_regs.h\"\n\n#define MMU_COMPRESS_HEADER_SIZE 0x48000\n#define MMU_MAP_SIZE 0x4800\n\nconst u16 vdec_hevc_parser_cmd[] = {\n\t0x0401,\t0x8401,\t0x0800,\t0x0402,\n\t0x9002,\t0x1423,\t0x8CC3,\t0x1423,\n\t0x8804,\t0x9825,\t0x0800,\t0x04FE,\n\t0x8406,\t0x8411,\t0x1800,\t0x8408,\n\t0x8409,\t0x8C2A,\t0x9C2B,\t0x1C00,\n\t0x840F,\t0x8407,\t0x8000,\t0x8408,\n\t0x2000,\t0xA800,\t0x8410,\t0x04DE,\n\t0x840C,\t0x840D,\t0xAC00,\t0xA000,\n\t0x08C0,\t0x08E0,\t0xA40E,\t0xFC00,\n\t0x7C00\n};\n\n \nvoid codec_hevc_setup_decode_head(struct amvdec_session *sess, int is_10bit)\n{\n\tstruct amvdec_core *core = sess->core;\n\tu32 body_size = amvdec_am21c_body_size(sess->width, sess->height);\n\tu32 head_size = amvdec_am21c_head_size(sess->width, sess->height);\n\n\tif (!codec_hevc_use_fbc(sess->pixfmt_cap, is_10bit)) {\n\t\t \n\t\tamvdec_write_dos(core, HEVCD_MPP_DECOMP_CTL1, BIT(31));\n\t\treturn;\n\t}\n\n\tif (codec_hevc_use_mmu(core->platform->revision,\n\t\t\t       sess->pixfmt_cap, is_10bit))\n\t\tamvdec_write_dos(core, HEVCD_MPP_DECOMP_CTL1, BIT(4));\n\telse\n\t\tamvdec_write_dos(core, HEVCD_MPP_DECOMP_CTL1, 0);\n\n\tif (core->platform->revision < VDEC_REVISION_SM1)\n\t\tamvdec_write_dos(core, HEVCD_MPP_DECOMP_CTL2, body_size / 32);\n\tamvdec_write_dos(core, HEVC_CM_BODY_LENGTH, body_size);\n\tamvdec_write_dos(core, HEVC_CM_HEADER_OFFSET, body_size);\n\tamvdec_write_dos(core, HEVC_CM_HEADER_LENGTH, head_size);\n}\nEXPORT_SYMBOL_GPL(codec_hevc_setup_decode_head);\n\nstatic void codec_hevc_setup_buffers_gxbb(struct amvdec_session *sess,\n\t\t\t\t\t  struct codec_hevc_common *comm,\n\t\t\t\t\t  int is_10bit)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct v4l2_m2m_buffer *buf;\n\tu32 buf_num = v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);\n\tdma_addr_t buf_y_paddr = 0;\n\tdma_addr_t buf_uv_paddr = 0;\n\tu32 idx = 0;\n\tu32 val;\n\tint i;\n\n\tamvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0);\n\n\tv4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {\n\t\tstruct vb2_buffer *vb = &buf->vb.vb2_buf;\n\n\t\tidx = vb->index;\n\n\t\tif (codec_hevc_use_downsample(sess->pixfmt_cap, is_10bit))\n\t\t\tbuf_y_paddr = comm->fbc_buffer_paddr[idx];\n\t\telse\n\t\t\tbuf_y_paddr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\n\t\tif (codec_hevc_use_fbc(sess->pixfmt_cap, is_10bit)) {\n\t\t\tval = buf_y_paddr | (idx << 8) | 1;\n\t\t\tamvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR,\n\t\t\t\t\t val);\n\t\t} else {\n\t\t\tbuf_uv_paddr = vb2_dma_contig_plane_dma_addr(vb, 1);\n\t\t\tval = buf_y_paddr | ((idx * 2) << 8) | 1;\n\t\t\tamvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR,\n\t\t\t\t\t val);\n\t\t\tval = buf_uv_paddr | ((idx * 2 + 1) << 8) | 1;\n\t\t\tamvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR,\n\t\t\t\t\t val);\n\t\t}\n\t}\n\n\tif (codec_hevc_use_fbc(sess->pixfmt_cap, is_10bit))\n\t\tval = buf_y_paddr | (idx << 8) | 1;\n\telse\n\t\tval = buf_y_paddr | ((idx * 2) << 8) | 1;\n\n\t \n\tfor (i = buf_num; i < MAX_REF_PIC_NUM; ++i)\n\t\tamvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR, val);\n\n\tamvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 1);\n\tamvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, 1);\n\tfor (i = 0; i < 32; ++i)\n\t\tamvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR, 0);\n}\n\nstatic void codec_hevc_setup_buffers_gxl(struct amvdec_session *sess,\n\t\t\t\t\t struct codec_hevc_common *comm,\n\t\t\t\t\t int is_10bit)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct v4l2_m2m_buffer *buf;\n\tu32 revision = core->platform->revision;\n\tu32 pixfmt_cap = sess->pixfmt_cap;\n\tint i;\n\n\tamvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR,\n\t\t\t BIT(2) | BIT(1));\n\n\tv4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {\n\t\tstruct vb2_buffer *vb = &buf->vb.vb2_buf;\n\t\tdma_addr_t buf_y_paddr = 0;\n\t\tdma_addr_t buf_uv_paddr = 0;\n\t\tu32 idx = vb->index;\n\n\t\tif (codec_hevc_use_mmu(revision, pixfmt_cap, is_10bit))\n\t\t\tbuf_y_paddr = comm->mmu_header_paddr[idx];\n\t\telse if (codec_hevc_use_downsample(pixfmt_cap, is_10bit))\n\t\t\tbuf_y_paddr = comm->fbc_buffer_paddr[idx];\n\t\telse\n\t\t\tbuf_y_paddr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\n\t\tamvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_DATA,\n\t\t\t\t buf_y_paddr >> 5);\n\n\t\tif (!codec_hevc_use_fbc(pixfmt_cap, is_10bit)) {\n\t\t\tbuf_uv_paddr = vb2_dma_contig_plane_dma_addr(vb, 1);\n\t\t\tamvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_DATA,\n\t\t\t\t\t buf_uv_paddr >> 5);\n\t\t}\n\t}\n\n\tamvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 1);\n\tamvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, 1);\n\tfor (i = 0; i < 32; ++i)\n\t\tamvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR, 0);\n}\n\nvoid codec_hevc_free_fbc_buffers(struct amvdec_session *sess,\n\t\t\t\t struct codec_hevc_common *comm)\n{\n\tstruct device *dev = sess->core->dev;\n\tu32 am21_size = amvdec_am21c_size(sess->width, sess->height);\n\tint i;\n\n\tfor (i = 0; i < MAX_REF_PIC_NUM; ++i) {\n\t\tif (comm->fbc_buffer_vaddr[i]) {\n\t\t\tdma_free_coherent(dev, am21_size,\n\t\t\t\t\t  comm->fbc_buffer_vaddr[i],\n\t\t\t\t\t  comm->fbc_buffer_paddr[i]);\n\t\t\tcomm->fbc_buffer_vaddr[i] = NULL;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(codec_hevc_free_fbc_buffers);\n\nstatic int codec_hevc_alloc_fbc_buffers(struct amvdec_session *sess,\n\t\t\t\t\tstruct codec_hevc_common *comm)\n{\n\tstruct device *dev = sess->core->dev;\n\tstruct v4l2_m2m_buffer *buf;\n\tu32 am21_size = amvdec_am21c_size(sess->width, sess->height);\n\n\tv4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {\n\t\tu32 idx = buf->vb.vb2_buf.index;\n\t\tdma_addr_t paddr;\n\t\tvoid *vaddr = dma_alloc_coherent(dev, am21_size, &paddr,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!vaddr) {\n\t\t\tcodec_hevc_free_fbc_buffers(sess, comm);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcomm->fbc_buffer_vaddr[idx] = vaddr;\n\t\tcomm->fbc_buffer_paddr[idx] = paddr;\n\t}\n\n\treturn 0;\n}\n\nvoid codec_hevc_free_mmu_headers(struct amvdec_session *sess,\n\t\t\t\t struct codec_hevc_common *comm)\n{\n\tstruct device *dev = sess->core->dev;\n\tint i;\n\n\tfor (i = 0; i < MAX_REF_PIC_NUM; ++i) {\n\t\tif (comm->mmu_header_vaddr[i]) {\n\t\t\tdma_free_coherent(dev, MMU_COMPRESS_HEADER_SIZE,\n\t\t\t\t\t  comm->mmu_header_vaddr[i],\n\t\t\t\t\t  comm->mmu_header_paddr[i]);\n\t\t\tcomm->mmu_header_vaddr[i] = NULL;\n\t\t}\n\t}\n\n\tif (comm->mmu_map_vaddr) {\n\t\tdma_free_coherent(dev, MMU_MAP_SIZE,\n\t\t\t\t  comm->mmu_map_vaddr,\n\t\t\t\t  comm->mmu_map_paddr);\n\t\tcomm->mmu_map_vaddr = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(codec_hevc_free_mmu_headers);\n\nstatic int codec_hevc_alloc_mmu_headers(struct amvdec_session *sess,\n\t\t\t\t\tstruct codec_hevc_common *comm)\n{\n\tstruct device *dev = sess->core->dev;\n\tstruct v4l2_m2m_buffer *buf;\n\n\tcomm->mmu_map_vaddr = dma_alloc_coherent(dev, MMU_MAP_SIZE,\n\t\t\t\t\t\t &comm->mmu_map_paddr,\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!comm->mmu_map_vaddr)\n\t\treturn -ENOMEM;\n\n\tv4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {\n\t\tu32 idx = buf->vb.vb2_buf.index;\n\t\tdma_addr_t paddr;\n\t\tvoid *vaddr = dma_alloc_coherent(dev, MMU_COMPRESS_HEADER_SIZE,\n\t\t\t\t\t\t &paddr, GFP_KERNEL);\n\t\tif (!vaddr) {\n\t\t\tcodec_hevc_free_mmu_headers(sess, comm);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcomm->mmu_header_vaddr[idx] = vaddr;\n\t\tcomm->mmu_header_paddr[idx] = paddr;\n\t}\n\n\treturn 0;\n}\n\nint codec_hevc_setup_buffers(struct amvdec_session *sess,\n\t\t\t     struct codec_hevc_common *comm,\n\t\t\t     int is_10bit)\n{\n\tstruct amvdec_core *core = sess->core;\n\tint ret;\n\n\tif (codec_hevc_use_downsample(sess->pixfmt_cap, is_10bit)) {\n\t\tret = codec_hevc_alloc_fbc_buffers(sess, comm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (codec_hevc_use_mmu(core->platform->revision,\n\t\t\t       sess->pixfmt_cap, is_10bit)) {\n\t\tret = codec_hevc_alloc_mmu_headers(sess, comm);\n\t\tif (ret) {\n\t\t\tcodec_hevc_free_fbc_buffers(sess, comm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (core->platform->revision == VDEC_REVISION_GXBB)\n\t\tcodec_hevc_setup_buffers_gxbb(sess, comm, is_10bit);\n\telse\n\t\tcodec_hevc_setup_buffers_gxl(sess, comm, is_10bit);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(codec_hevc_setup_buffers);\n\nvoid codec_hevc_fill_mmu_map(struct amvdec_session *sess,\n\t\t\t     struct codec_hevc_common *comm,\n\t\t\t     struct vb2_buffer *vb)\n{\n\tu32 size = amvdec_am21c_size(sess->width, sess->height);\n\tu32 nb_pages = size / PAGE_SIZE;\n\tu32 *mmu_map = comm->mmu_map_vaddr;\n\tu32 first_page;\n\tu32 i;\n\n\tif (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M)\n\t\tfirst_page = comm->fbc_buffer_paddr[vb->index] >> PAGE_SHIFT;\n\telse\n\t\tfirst_page = vb2_dma_contig_plane_dma_addr(vb, 0) >> PAGE_SHIFT;\n\n\tfor (i = 0; i < nb_pages; ++i)\n\t\tmmu_map[i] = first_page + i;\n}\nEXPORT_SYMBOL_GPL(codec_hevc_fill_mmu_map);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}