{
  "module_name": "vdec_helpers.c",
  "hash_id": "829510259ee9e0b386636cea25b14303b76ef62531f5c8bf3aa05acd45152b76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/meson/vdec/vdec_helpers.c",
  "human_readable_source": "\n \n\n#include <linux/gcd.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"vdec_helpers.h\"\n\n#define NUM_CANVAS_NV12 2\n#define NUM_CANVAS_YUV420 3\n\nu32 amvdec_read_dos(struct amvdec_core *core, u32 reg)\n{\n\treturn readl_relaxed(core->dos_base + reg);\n}\nEXPORT_SYMBOL_GPL(amvdec_read_dos);\n\nvoid amvdec_write_dos(struct amvdec_core *core, u32 reg, u32 val)\n{\n\twritel_relaxed(val, core->dos_base + reg);\n}\nEXPORT_SYMBOL_GPL(amvdec_write_dos);\n\nvoid amvdec_write_dos_bits(struct amvdec_core *core, u32 reg, u32 val)\n{\n\tamvdec_write_dos(core, reg, amvdec_read_dos(core, reg) | val);\n}\nEXPORT_SYMBOL_GPL(amvdec_write_dos_bits);\n\nvoid amvdec_clear_dos_bits(struct amvdec_core *core, u32 reg, u32 val)\n{\n\tamvdec_write_dos(core, reg, amvdec_read_dos(core, reg) & ~val);\n}\nEXPORT_SYMBOL_GPL(amvdec_clear_dos_bits);\n\nu32 amvdec_read_parser(struct amvdec_core *core, u32 reg)\n{\n\treturn readl_relaxed(core->esparser_base + reg);\n}\nEXPORT_SYMBOL_GPL(amvdec_read_parser);\n\nvoid amvdec_write_parser(struct amvdec_core *core, u32 reg, u32 val)\n{\n\twritel_relaxed(val, core->esparser_base + reg);\n}\nEXPORT_SYMBOL_GPL(amvdec_write_parser);\n\n \nu32 amvdec_am21c_body_size(u32 width, u32 height)\n{\n\tu32 width_64 = ALIGN(width, 64) / 64;\n\tu32 height_32 = ALIGN(height, 32) / 32;\n\n\treturn SZ_4K * width_64 * height_32;\n}\nEXPORT_SYMBOL_GPL(amvdec_am21c_body_size);\n\n \nu32 amvdec_am21c_head_size(u32 width, u32 height)\n{\n\tu32 width_128 = ALIGN(width, 128) / 128;\n\tu32 height_64 = ALIGN(height, 64) / 64;\n\n\treturn 32 * width_128 * height_64;\n}\nEXPORT_SYMBOL_GPL(amvdec_am21c_head_size);\n\nu32 amvdec_am21c_size(u32 width, u32 height)\n{\n\treturn ALIGN(amvdec_am21c_body_size(width, height) +\n\t\t     amvdec_am21c_head_size(width, height), SZ_64K);\n}\nEXPORT_SYMBOL_GPL(amvdec_am21c_size);\n\nstatic int canvas_alloc(struct amvdec_session *sess, u8 *canvas_id)\n{\n\tint ret;\n\n\tif (sess->canvas_num >= MAX_CANVAS) {\n\t\tdev_err(sess->core->dev, \"Reached max number of canvas\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = meson_canvas_alloc(sess->core->canvas, canvas_id);\n\tif (ret)\n\t\treturn ret;\n\n\tsess->canvas_alloc[sess->canvas_num++] = *canvas_id;\n\treturn 0;\n}\n\nstatic int set_canvas_yuv420m(struct amvdec_session *sess,\n\t\t\t      struct vb2_buffer *vb, u32 width,\n\t\t\t      u32 height, u32 reg)\n{\n\tstruct amvdec_core *core = sess->core;\n\tu8 canvas_id[NUM_CANVAS_YUV420];  \n\tdma_addr_t buf_paddr[NUM_CANVAS_YUV420];  \n\tint ret, i;\n\n\tfor (i = 0; i < NUM_CANVAS_YUV420; ++i) {\n\t\tret = canvas_alloc(sess, &canvas_id[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbuf_paddr[i] =\n\t\t    vb2_dma_contig_plane_dma_addr(vb, i);\n\t}\n\n\t \n\tmeson_canvas_config(core->canvas, canvas_id[0], buf_paddr[0],\n\t\t\t    width, height, MESON_CANVAS_WRAP_NONE,\n\t\t\t    MESON_CANVAS_BLKMODE_LINEAR,\n\t\t\t    MESON_CANVAS_ENDIAN_SWAP64);\n\n\t \n\tmeson_canvas_config(core->canvas, canvas_id[1], buf_paddr[1],\n\t\t\t    width / 2, height / 2, MESON_CANVAS_WRAP_NONE,\n\t\t\t    MESON_CANVAS_BLKMODE_LINEAR,\n\t\t\t    MESON_CANVAS_ENDIAN_SWAP64);\n\n\t \n\tmeson_canvas_config(core->canvas, canvas_id[2], buf_paddr[2],\n\t\t\t    width / 2, height / 2, MESON_CANVAS_WRAP_NONE,\n\t\t\t    MESON_CANVAS_BLKMODE_LINEAR,\n\t\t\t    MESON_CANVAS_ENDIAN_SWAP64);\n\n\tamvdec_write_dos(core, reg,\n\t\t\t ((canvas_id[2]) << 16) |\n\t\t\t ((canvas_id[1]) << 8)  |\n\t\t\t (canvas_id[0]));\n\n\treturn 0;\n}\n\nstatic int set_canvas_nv12m(struct amvdec_session *sess,\n\t\t\t    struct vb2_buffer *vb, u32 width,\n\t\t\t    u32 height, u32 reg)\n{\n\tstruct amvdec_core *core = sess->core;\n\tu8 canvas_id[NUM_CANVAS_NV12];  \n\tdma_addr_t buf_paddr[NUM_CANVAS_NV12];  \n\tint ret, i;\n\n\tfor (i = 0; i < NUM_CANVAS_NV12; ++i) {\n\t\tret = canvas_alloc(sess, &canvas_id[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbuf_paddr[i] =\n\t\t    vb2_dma_contig_plane_dma_addr(vb, i);\n\t}\n\n\t \n\tmeson_canvas_config(core->canvas, canvas_id[0], buf_paddr[0],\n\t\t\t    width, height, MESON_CANVAS_WRAP_NONE,\n\t\t\t    MESON_CANVAS_BLKMODE_LINEAR,\n\t\t\t    MESON_CANVAS_ENDIAN_SWAP64);\n\n\t \n\tmeson_canvas_config(core->canvas, canvas_id[1], buf_paddr[1],\n\t\t\t    width, height / 2, MESON_CANVAS_WRAP_NONE,\n\t\t\t    MESON_CANVAS_BLKMODE_LINEAR,\n\t\t\t    MESON_CANVAS_ENDIAN_SWAP64);\n\n\tamvdec_write_dos(core, reg,\n\t\t\t ((canvas_id[1]) << 16) |\n\t\t\t ((canvas_id[1]) << 8)  |\n\t\t\t (canvas_id[0]));\n\n\treturn 0;\n}\n\nint amvdec_set_canvases(struct amvdec_session *sess,\n\t\t\tu32 reg_base[], u32 reg_num[])\n{\n\tstruct v4l2_m2m_buffer *buf;\n\tu32 pixfmt = sess->pixfmt_cap;\n\tu32 width = ALIGN(sess->width, 32);\n\tu32 height = ALIGN(sess->height, 32);\n\tu32 reg_cur;\n\tu32 reg_num_cur = 0;\n\tu32 reg_base_cur = 0;\n\tint i = 0;\n\tint ret;\n\n\tv4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {\n\t\tif (!reg_base[reg_base_cur])\n\t\t\treturn -EINVAL;\n\n\t\treg_cur = reg_base[reg_base_cur] + reg_num_cur * 4;\n\n\t\tswitch (pixfmt) {\n\t\tcase V4L2_PIX_FMT_NV12M:\n\t\t\tret = set_canvas_nv12m(sess, &buf->vb.vb2_buf, width,\n\t\t\t\t\t       height, reg_cur);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_YUV420M:\n\t\t\tret = set_canvas_yuv420m(sess, &buf->vb.vb2_buf, width,\n\t\t\t\t\t\t height, reg_cur);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(sess->core->dev, \"Unsupported pixfmt %08X\\n\",\n\t\t\t\tpixfmt);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treg_num_cur++;\n\t\tif (reg_num_cur >= reg_num[reg_base_cur]) {\n\t\t\treg_base_cur++;\n\t\t\treg_num_cur = 0;\n\t\t}\n\n\t\tsess->fw_idx_to_vb2_idx[i++] = buf->vb.vb2_buf.index;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(amvdec_set_canvases);\n\nint amvdec_add_ts(struct amvdec_session *sess, u64 ts,\n\t\t  struct v4l2_timecode tc, u32 offset, u32 vbuf_flags)\n{\n\tstruct amvdec_timestamp *new_ts;\n\tunsigned long flags;\n\n\tnew_ts = kzalloc(sizeof(*new_ts), GFP_KERNEL);\n\tif (!new_ts)\n\t\treturn -ENOMEM;\n\n\tnew_ts->ts = ts;\n\tnew_ts->tc = tc;\n\tnew_ts->offset = offset;\n\tnew_ts->flags = vbuf_flags;\n\n\tspin_lock_irqsave(&sess->ts_spinlock, flags);\n\tlist_add_tail(&new_ts->list, &sess->timestamps);\n\tspin_unlock_irqrestore(&sess->ts_spinlock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(amvdec_add_ts);\n\nvoid amvdec_remove_ts(struct amvdec_session *sess, u64 ts)\n{\n\tstruct amvdec_timestamp *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sess->ts_spinlock, flags);\n\tlist_for_each_entry(tmp, &sess->timestamps, list) {\n\t\tif (tmp->ts == ts) {\n\t\t\tlist_del(&tmp->list);\n\t\t\tkfree(tmp);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tdev_warn(sess->core->dev_dec,\n\t\t \"Couldn't remove buffer with timestamp %llu from list\\n\", ts);\n\nunlock:\n\tspin_unlock_irqrestore(&sess->ts_spinlock, flags);\n}\nEXPORT_SYMBOL_GPL(amvdec_remove_ts);\n\nstatic void dst_buf_done(struct amvdec_session *sess,\n\t\t\t struct vb2_v4l2_buffer *vbuf,\n\t\t\t u32 field, u64 timestamp,\n\t\t\t struct v4l2_timecode timecode, u32 flags)\n{\n\tstruct device *dev = sess->core->dev_dec;\n\tu32 output_size = amvdec_get_output_size(sess);\n\n\tswitch (sess->pixfmt_cap) {\n\tcase V4L2_PIX_FMT_NV12M:\n\t\tvb2_set_plane_payload(&vbuf->vb2_buf, 0, output_size);\n\t\tvb2_set_plane_payload(&vbuf->vb2_buf, 1, output_size / 2);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV420M:\n\t\tvb2_set_plane_payload(&vbuf->vb2_buf, 0, output_size);\n\t\tvb2_set_plane_payload(&vbuf->vb2_buf, 1, output_size / 4);\n\t\tvb2_set_plane_payload(&vbuf->vb2_buf, 2, output_size / 4);\n\t\tbreak;\n\t}\n\n\tvbuf->vb2_buf.timestamp = timestamp;\n\tvbuf->sequence = sess->sequence_cap++;\n\tvbuf->flags = flags;\n\tvbuf->timecode = timecode;\n\n\tif (sess->should_stop &&\n\t    atomic_read(&sess->esparser_queued_bufs) <= 1) {\n\t\tconst struct v4l2_event ev = { .type = V4L2_EVENT_EOS };\n\n\t\tdev_dbg(dev, \"Signaling EOS, sequence_cap = %u\\n\",\n\t\t\tsess->sequence_cap - 1);\n\t\tv4l2_event_queue_fh(&sess->fh, &ev);\n\t\tvbuf->flags |= V4L2_BUF_FLAG_LAST;\n\t} else if (sess->status == STATUS_NEEDS_RESUME) {\n\t\t \n\t\tvbuf->flags |= V4L2_BUF_FLAG_LAST;\n\t\tsess->sequence_cap = 0;\n\t} else if (sess->should_stop)\n\t\tdev_dbg(dev, \"should_stop, %u bufs remain\\n\",\n\t\t\tatomic_read(&sess->esparser_queued_bufs));\n\n\tdev_dbg(dev, \"Buffer %u done, ts = %llu, flags = %08X\\n\",\n\t\tvbuf->vb2_buf.index, timestamp, flags);\n\tvbuf->field = field;\n\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);\n\n\t \n\tschedule_work(&sess->esparser_queue_work);\n}\n\nvoid amvdec_dst_buf_done(struct amvdec_session *sess,\n\t\t\t struct vb2_v4l2_buffer *vbuf, u32 field)\n{\n\tstruct device *dev = sess->core->dev_dec;\n\tstruct amvdec_timestamp *tmp;\n\tstruct list_head *timestamps = &sess->timestamps;\n\tstruct v4l2_timecode timecode;\n\tu64 timestamp;\n\tu32 vbuf_flags;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sess->ts_spinlock, flags);\n\tif (list_empty(timestamps)) {\n\t\tdev_err(dev, \"Buffer %u done but list is empty\\n\",\n\t\t\tvbuf->vb2_buf.index);\n\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t\tspin_unlock_irqrestore(&sess->ts_spinlock, flags);\n\t\treturn;\n\t}\n\n\ttmp = list_first_entry(timestamps, struct amvdec_timestamp, list);\n\ttimestamp = tmp->ts;\n\ttimecode = tmp->tc;\n\tvbuf_flags = tmp->flags;\n\tlist_del(&tmp->list);\n\tkfree(tmp);\n\tspin_unlock_irqrestore(&sess->ts_spinlock, flags);\n\n\tdst_buf_done(sess, vbuf, field, timestamp, timecode, vbuf_flags);\n\tatomic_dec(&sess->esparser_queued_bufs);\n}\nEXPORT_SYMBOL_GPL(amvdec_dst_buf_done);\n\nvoid amvdec_dst_buf_done_offset(struct amvdec_session *sess,\n\t\t\t\tstruct vb2_v4l2_buffer *vbuf,\n\t\t\t\tu32 offset, u32 field, bool allow_drop)\n{\n\tstruct device *dev = sess->core->dev_dec;\n\tstruct amvdec_timestamp *match = NULL;\n\tstruct amvdec_timestamp *tmp, *n;\n\tstruct v4l2_timecode timecode = { 0 };\n\tu64 timestamp = 0;\n\tu32 vbuf_flags = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sess->ts_spinlock, flags);\n\n\t \n\tlist_for_each_entry_safe(tmp, n, &sess->timestamps, list) {\n\t\tif (tmp->offset > offset) {\n\t\t\t \n\t\t\tif (tmp->used_count++ >= 32) {\n\t\t\t\tlist_del(&tmp->list);\n\t\t\t\tkfree(tmp);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch = tmp;\n\t}\n\n\tif (!match) {\n\t\tdev_err(dev, \"Buffer %u done but can't match offset (%08X)\\n\",\n\t\t\tvbuf->vb2_buf.index, offset);\n\t} else {\n\t\ttimestamp = match->ts;\n\t\ttimecode = match->tc;\n\t\tvbuf_flags = match->flags;\n\t\tlist_del(&match->list);\n\t\tkfree(match);\n\t}\n\tspin_unlock_irqrestore(&sess->ts_spinlock, flags);\n\n\tdst_buf_done(sess, vbuf, field, timestamp, timecode, vbuf_flags);\n\tif (match)\n\t\tatomic_dec(&sess->esparser_queued_bufs);\n}\nEXPORT_SYMBOL_GPL(amvdec_dst_buf_done_offset);\n\nvoid amvdec_dst_buf_done_idx(struct amvdec_session *sess,\n\t\t\t     u32 buf_idx, u32 offset, u32 field)\n{\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct device *dev = sess->core->dev_dec;\n\n\tvbuf = v4l2_m2m_dst_buf_remove_by_idx(sess->m2m_ctx,\n\t\t\t\t\t      sess->fw_idx_to_vb2_idx[buf_idx]);\n\n\tif (!vbuf) {\n\t\tdev_err(dev,\n\t\t\t\"Buffer %u done but it doesn't exist in m2m_ctx\\n\",\n\t\t\tbuf_idx);\n\t\treturn;\n\t}\n\n\tif (offset != -1)\n\t\tamvdec_dst_buf_done_offset(sess, vbuf, offset, field, true);\n\telse\n\t\tamvdec_dst_buf_done(sess, vbuf, field);\n}\nEXPORT_SYMBOL_GPL(amvdec_dst_buf_done_idx);\n\nvoid amvdec_set_par_from_dar(struct amvdec_session *sess,\n\t\t\t     u32 dar_num, u32 dar_den)\n{\n\tu32 div;\n\n\tsess->pixelaspect.numerator = sess->height * dar_num;\n\tsess->pixelaspect.denominator = sess->width * dar_den;\n\tdiv = gcd(sess->pixelaspect.numerator, sess->pixelaspect.denominator);\n\tsess->pixelaspect.numerator /= div;\n\tsess->pixelaspect.denominator /= div;\n}\nEXPORT_SYMBOL_GPL(amvdec_set_par_from_dar);\n\nvoid amvdec_src_change(struct amvdec_session *sess, u32 width,\n\t\t       u32 height, u32 dpb_size)\n{\n\tstatic const struct v4l2_event ev = {\n\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION };\n\n\tv4l2_ctrl_s_ctrl(sess->ctrl_min_buf_capture, dpb_size);\n\n\t \n\tif (sess->streamon_cap &&\n\t    sess->width == width &&\n\t    sess->height == height &&\n\t    dpb_size <= sess->num_dst_bufs) {\n\t\tsess->fmt_out->codec_ops->resume(sess);\n\t\treturn;\n\t}\n\n\tsess->changed_format = 0;\n\tsess->width = width;\n\tsess->height = height;\n\tsess->status = STATUS_NEEDS_RESUME;\n\n\tdev_dbg(sess->core->dev, \"Res. changed (%ux%u), DPB size %u\\n\",\n\t\twidth, height, dpb_size);\n\tv4l2_event_queue_fh(&sess->fh, &ev);\n}\nEXPORT_SYMBOL_GPL(amvdec_src_change);\n\nvoid amvdec_abort(struct amvdec_session *sess)\n{\n\tdev_info(sess->core->dev, \"Aborting decoding session!\\n\");\n\tvb2_queue_error(&sess->m2m_ctx->cap_q_ctx.q);\n\tvb2_queue_error(&sess->m2m_ctx->out_q_ctx.q);\n}\nEXPORT_SYMBOL_GPL(amvdec_abort);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}