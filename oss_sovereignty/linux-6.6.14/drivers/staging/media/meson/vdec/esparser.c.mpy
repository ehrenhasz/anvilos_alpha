{
  "module_name": "esparser.c",
  "hash_id": "30bc6a8cb029591ec23148c6c09593edd3054f150382559a1d604a2e061495cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/meson/vdec/esparser.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/reset.h>\n#include <linux/interrupt.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/v4l2-mem2mem.h>\n\n#include \"dos_regs.h\"\n#include \"esparser.h\"\n#include \"vdec_helpers.h\"\n\n \n#define PARSER_CONTROL 0x00\n\t#define ES_PACK_SIZE_BIT\t8\n\t#define ES_WRITE\t\tBIT(5)\n\t#define ES_SEARCH\t\tBIT(1)\n\t#define ES_PARSER_START\t\tBIT(0)\n#define PARSER_FETCH_ADDR\t0x4\n#define PARSER_FETCH_CMD\t0x8\n#define PARSER_CONFIG 0x14\n\t#define PS_CFG_MAX_FETCH_CYCLE_BIT\t0\n\t#define PS_CFG_STARTCODE_WID_24_BIT\t10\n\t#define PS_CFG_MAX_ES_WR_CYCLE_BIT\t12\n\t#define PS_CFG_PFIFO_EMPTY_CNT_BIT\t16\n#define PFIFO_WR_PTR 0x18\n#define PFIFO_RD_PTR 0x1c\n#define PARSER_SEARCH_PATTERN 0x24\n\t#define ES_START_CODE_PATTERN 0x00000100\n#define PARSER_SEARCH_MASK 0x28\n\t#define ES_START_CODE_MASK\t0xffffff00\n\t#define FETCH_ENDIAN_BIT\t27\n#define PARSER_INT_ENABLE\t0x2c\n\t#define PARSER_INT_HOST_EN_BIT\t8\n#define PARSER_INT_STATUS\t0x30\n\t#define PARSER_INTSTAT_SC_FOUND\t1\n#define PARSER_ES_CONTROL\t0x5c\n#define PARSER_VIDEO_START_PTR\t0x80\n#define PARSER_VIDEO_END_PTR\t0x84\n#define PARSER_VIDEO_WP\t\t0x88\n#define PARSER_VIDEO_HOLE\t0x90\n\n#define SEARCH_PATTERN_LEN\t512\n#define VP9_HEADER_SIZE\t\t16\n\nstatic DECLARE_WAIT_QUEUE_HEAD(wq);\nstatic int search_done;\n\nstatic irqreturn_t esparser_isr(int irq, void *dev)\n{\n\tint int_status;\n\tstruct amvdec_core *core = dev;\n\n\tint_status = amvdec_read_parser(core, PARSER_INT_STATUS);\n\tamvdec_write_parser(core, PARSER_INT_STATUS, int_status);\n\n\tif (int_status & PARSER_INTSTAT_SC_FOUND) {\n\t\tamvdec_write_parser(core, PFIFO_RD_PTR, 0);\n\t\tamvdec_write_parser(core, PFIFO_WR_PTR, 0);\n\t\tsearch_done = 1;\n\t\twake_up_interruptible(&wq);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int vp9_update_header(struct amvdec_core *core, struct vb2_buffer *buf)\n{\n\tu8 *dp;\n\tu8 marker;\n\tint dsize;\n\tint num_frames, cur_frame;\n\tint cur_mag, mag, mag_ptr;\n\tint frame_size[8], tot_frame_size[8];\n\tint total_datasize = 0;\n\tint new_frame_size;\n\tunsigned char *old_header = NULL;\n\n\tdp = (uint8_t *)vb2_plane_vaddr(buf, 0);\n\tdsize = vb2_get_plane_payload(buf, 0);\n\n\tif (dsize == vb2_plane_size(buf, 0)) {\n\t\tdev_warn(core->dev, \"%s: unable to update header\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tmarker = dp[dsize - 1];\n\tif ((marker & 0xe0) == 0xc0) {\n\t\tnum_frames = (marker & 0x7) + 1;\n\t\tmag = ((marker >> 3) & 0x3) + 1;\n\t\tmag_ptr = dsize - mag * num_frames - 2;\n\t\tif (dp[mag_ptr] != marker)\n\t\t\treturn 0;\n\n\t\tmag_ptr++;\n\t\tfor (cur_frame = 0; cur_frame < num_frames; cur_frame++) {\n\t\t\tframe_size[cur_frame] = 0;\n\t\t\tfor (cur_mag = 0; cur_mag < mag; cur_mag++) {\n\t\t\t\tframe_size[cur_frame] |=\n\t\t\t\t\t(dp[mag_ptr] << (cur_mag * 8));\n\t\t\t\tmag_ptr++;\n\t\t\t}\n\t\t\tif (cur_frame == 0)\n\t\t\t\ttot_frame_size[cur_frame] =\n\t\t\t\t\tframe_size[cur_frame];\n\t\t\telse\n\t\t\t\ttot_frame_size[cur_frame] =\n\t\t\t\t\ttot_frame_size[cur_frame - 1] +\n\t\t\t\t\tframe_size[cur_frame];\n\t\t\ttotal_datasize += frame_size[cur_frame];\n\t\t}\n\t} else {\n\t\tnum_frames = 1;\n\t\tframe_size[0] = dsize;\n\t\ttot_frame_size[0] = dsize;\n\t\ttotal_datasize = dsize;\n\t}\n\n\tnew_frame_size = total_datasize + num_frames * VP9_HEADER_SIZE;\n\n\tif (new_frame_size >= vb2_plane_size(buf, 0)) {\n\t\tdev_warn(core->dev, \"%s: unable to update header\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tfor (cur_frame = num_frames - 1; cur_frame >= 0; cur_frame--) {\n\t\tint framesize = frame_size[cur_frame];\n\t\tint framesize_header = framesize + 4;\n\t\tint oldframeoff = tot_frame_size[cur_frame] - framesize;\n\t\tint outheaderoff =  oldframeoff + cur_frame * VP9_HEADER_SIZE;\n\t\tu8 *fdata = dp + outheaderoff;\n\t\tu8 *old_framedata = dp + oldframeoff;\n\n\t\tmemmove(fdata + VP9_HEADER_SIZE, old_framedata, framesize);\n\n\t\tfdata[0] = (framesize_header >> 24) & 0xff;\n\t\tfdata[1] = (framesize_header >> 16) & 0xff;\n\t\tfdata[2] = (framesize_header >> 8) & 0xff;\n\t\tfdata[3] = (framesize_header >> 0) & 0xff;\n\t\tfdata[4] = ((framesize_header >> 24) & 0xff) ^ 0xff;\n\t\tfdata[5] = ((framesize_header >> 16) & 0xff) ^ 0xff;\n\t\tfdata[6] = ((framesize_header >> 8) & 0xff) ^ 0xff;\n\t\tfdata[7] = ((framesize_header >> 0) & 0xff) ^ 0xff;\n\t\tfdata[8] = 0;\n\t\tfdata[9] = 0;\n\t\tfdata[10] = 0;\n\t\tfdata[11] = 1;\n\t\tfdata[12] = 'A';\n\t\tfdata[13] = 'M';\n\t\tfdata[14] = 'L';\n\t\tfdata[15] = 'V';\n\n\t\tif (!old_header) {\n\t\t\t \n\t\t} else if (old_header > fdata + 16 + framesize) {\n\t\t\tdev_dbg(core->dev, \"%s: data has gaps, setting to 0\\n\",\n\t\t\t\t__func__);\n\t\t\tmemset(fdata + 16 + framesize, 0,\n\t\t\t       (old_header - fdata + 16 + framesize));\n\t\t} else if (old_header < fdata + 16 + framesize) {\n\t\t\tdev_err(core->dev, \"%s: data overwritten\\n\", __func__);\n\t\t}\n\t\told_header = fdata;\n\t}\n\n\treturn new_frame_size;\n}\n\n \nstatic u32 esparser_pad_start_code(struct amvdec_core *core,\n\t\t\t\t   struct vb2_buffer *vb,\n\t\t\t\t   u32 payload_size)\n{\n\tu32 pad_size = 0;\n\tu8 *vaddr = vb2_plane_vaddr(vb, 0);\n\n\tif (payload_size < ESPARSER_MIN_PACKET_SIZE) {\n\t\tpad_size = ESPARSER_MIN_PACKET_SIZE - payload_size;\n\t\tmemset(vaddr + payload_size, 0, pad_size);\n\t}\n\n\tif ((payload_size + pad_size + SEARCH_PATTERN_LEN) >\n\t\t\t\t\t\tvb2_plane_size(vb, 0)) {\n\t\tdev_warn(core->dev, \"%s: unable to pad start code\\n\", __func__);\n\t\treturn pad_size;\n\t}\n\n\tmemset(vaddr + payload_size + pad_size, 0, SEARCH_PATTERN_LEN);\n\tvaddr[payload_size + pad_size]     = 0x00;\n\tvaddr[payload_size + pad_size + 1] = 0x00;\n\tvaddr[payload_size + pad_size + 2] = 0x01;\n\tvaddr[payload_size + pad_size + 3] = 0xff;\n\n\treturn pad_size;\n}\n\nstatic int\nesparser_write_data(struct amvdec_core *core, dma_addr_t addr, u32 size)\n{\n\tamvdec_write_parser(core, PFIFO_RD_PTR, 0);\n\tamvdec_write_parser(core, PFIFO_WR_PTR, 0);\n\tamvdec_write_parser(core, PARSER_CONTROL,\n\t\t\t    ES_WRITE |\n\t\t\t    ES_PARSER_START |\n\t\t\t    ES_SEARCH |\n\t\t\t    (size << ES_PACK_SIZE_BIT));\n\n\tamvdec_write_parser(core, PARSER_FETCH_ADDR, addr);\n\tamvdec_write_parser(core, PARSER_FETCH_CMD,\n\t\t\t    (7 << FETCH_ENDIAN_BIT) |\n\t\t\t    (size + SEARCH_PATTERN_LEN));\n\n\tsearch_done = 0;\n\treturn wait_event_interruptible_timeout(wq, search_done, (HZ / 5));\n}\n\nstatic u32 esparser_vififo_get_free_space(struct amvdec_session *sess)\n{\n\tu32 vififo_usage;\n\tstruct amvdec_ops *vdec_ops = sess->fmt_out->vdec_ops;\n\tstruct amvdec_core *core = sess->core;\n\n\tvififo_usage  = vdec_ops->vififo_level(sess);\n\tvififo_usage += amvdec_read_parser(core, PARSER_VIDEO_HOLE);\n\tvififo_usage += (6 * SZ_1K); \n\n\tif (vififo_usage > sess->vififo_size) {\n\t\tdev_warn(sess->core->dev,\n\t\t\t \"VIFIFO usage (%u) > VIFIFO size (%u)\\n\",\n\t\t\t vififo_usage, sess->vififo_size);\n\t\treturn 0;\n\t}\n\n\treturn sess->vififo_size - vififo_usage;\n}\n\nint esparser_queue_eos(struct amvdec_core *core, const u8 *data, u32 len)\n{\n\tstruct device *dev = core->dev;\n\tvoid *eos_vaddr;\n\tdma_addr_t eos_paddr;\n\tint ret;\n\n\teos_vaddr = dma_alloc_coherent(dev, len + SEARCH_PATTERN_LEN,\n\t\t\t\t       &eos_paddr, GFP_KERNEL);\n\tif (!eos_vaddr)\n\t\treturn -ENOMEM;\n\n\tmemcpy(eos_vaddr, data, len);\n\tret = esparser_write_data(core, eos_paddr, len);\n\tdma_free_coherent(dev, len + SEARCH_PATTERN_LEN,\n\t\t\t  eos_vaddr, eos_paddr);\n\n\treturn ret;\n}\n\nstatic u32 esparser_get_offset(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\tu32 offset = amvdec_read_parser(core, PARSER_VIDEO_WP) -\n\t\t     sess->vififo_paddr;\n\n\tif (offset < sess->last_offset)\n\t\tsess->wrap_count++;\n\n\tsess->last_offset = offset;\n\toffset += (sess->wrap_count * sess->vififo_size);\n\n\treturn offset;\n}\n\nstatic int\nesparser_queue(struct amvdec_session *sess, struct vb2_v4l2_buffer *vbuf)\n{\n\tint ret;\n\tstruct vb2_buffer *vb = &vbuf->vb2_buf;\n\tstruct amvdec_core *core = sess->core;\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\tu32 payload_size = vb2_get_plane_payload(vb, 0);\n\tdma_addr_t phy = vb2_dma_contig_plane_dma_addr(vb, 0);\n\tu32 num_dst_bufs = 0;\n\tu32 offset;\n\tu32 pad_size;\n\n\t \n\tif (sess->fmt_out->pixfmt == V4L2_PIX_FMT_VP9) {\n\t\tif (codec_ops->num_pending_bufs)\n\t\t\tnum_dst_bufs = codec_ops->num_pending_bufs(sess);\n\n\t\tnum_dst_bufs += v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);\n\t\tnum_dst_bufs -= 3;\n\n\t\tif (esparser_vififo_get_free_space(sess) < payload_size ||\n\t\t    atomic_read(&sess->esparser_queued_bufs) >= num_dst_bufs)\n\t\t\treturn -EAGAIN;\n\t} else if (esparser_vififo_get_free_space(sess) < payload_size) {\n\t\treturn -EAGAIN;\n\t}\n\n\tv4l2_m2m_src_buf_remove_by_buf(sess->m2m_ctx, vbuf);\n\n\toffset = esparser_get_offset(sess);\n\n\tret = amvdec_add_ts(sess, vb->timestamp, vbuf->timecode, offset, vbuf->flags);\n\tif (ret) {\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(core->dev, \"esparser: ts = %llu pld_size = %u offset = %08X flags = %08X\\n\",\n\t\tvb->timestamp, payload_size, offset, vbuf->flags);\n\n\tvbuf->flags = 0;\n\tvbuf->field = V4L2_FIELD_NONE;\n\tvbuf->sequence = sess->sequence_out++;\n\n\tif (sess->fmt_out->pixfmt == V4L2_PIX_FMT_VP9) {\n\t\tpayload_size = vp9_update_header(core, vb);\n\n\t\t \n\t\tif (payload_size == 0) {\n\t\t\tamvdec_remove_ts(sess, vb->timestamp);\n\t\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpad_size = esparser_pad_start_code(core, vb, payload_size);\n\tret = esparser_write_data(core, phy, payload_size + pad_size);\n\n\tif (ret <= 0) {\n\t\tdev_warn(core->dev, \"esparser: input parsing error\\n\");\n\t\tamvdec_remove_ts(sess, vb->timestamp);\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t\tamvdec_write_parser(core, PARSER_FETCH_CMD, 0);\n\n\t\treturn 0;\n\t}\n\n\tatomic_inc(&sess->esparser_queued_bufs);\n\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);\n\n\treturn 0;\n}\n\nvoid esparser_queue_all_src(struct work_struct *work)\n{\n\tstruct v4l2_m2m_buffer *buf, *n;\n\tstruct amvdec_session *sess =\n\t\tcontainer_of(work, struct amvdec_session, esparser_queue_work);\n\n\tmutex_lock(&sess->lock);\n\tv4l2_m2m_for_each_src_buf_safe(sess->m2m_ctx, buf, n) {\n\t\tif (sess->should_stop)\n\t\t\tbreak;\n\n\t\tif (esparser_queue(sess, &buf->vb) < 0)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&sess->lock);\n}\n\nint esparser_power_up(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct amvdec_ops *vdec_ops = sess->fmt_out->vdec_ops;\n\n\treset_control_reset(core->esparser_reset);\n\tamvdec_write_parser(core, PARSER_CONFIG,\n\t\t\t    (10 << PS_CFG_PFIFO_EMPTY_CNT_BIT) |\n\t\t\t    (1  << PS_CFG_MAX_ES_WR_CYCLE_BIT) |\n\t\t\t    (16 << PS_CFG_MAX_FETCH_CYCLE_BIT));\n\n\tamvdec_write_parser(core, PFIFO_RD_PTR, 0);\n\tamvdec_write_parser(core, PFIFO_WR_PTR, 0);\n\n\tamvdec_write_parser(core, PARSER_SEARCH_PATTERN,\n\t\t\t    ES_START_CODE_PATTERN);\n\tamvdec_write_parser(core, PARSER_SEARCH_MASK, ES_START_CODE_MASK);\n\n\tamvdec_write_parser(core, PARSER_CONFIG,\n\t\t\t    (10 << PS_CFG_PFIFO_EMPTY_CNT_BIT) |\n\t\t\t    (1  << PS_CFG_MAX_ES_WR_CYCLE_BIT) |\n\t\t\t    (16 << PS_CFG_MAX_FETCH_CYCLE_BIT) |\n\t\t\t    (2  << PS_CFG_STARTCODE_WID_24_BIT));\n\n\tamvdec_write_parser(core, PARSER_CONTROL,\n\t\t\t    (ES_SEARCH | ES_PARSER_START));\n\n\tamvdec_write_parser(core, PARSER_VIDEO_START_PTR, sess->vififo_paddr);\n\tamvdec_write_parser(core, PARSER_VIDEO_END_PTR,\n\t\t\t    sess->vififo_paddr + sess->vififo_size - 8);\n\tamvdec_write_parser(core, PARSER_ES_CONTROL,\n\t\t\t    amvdec_read_parser(core, PARSER_ES_CONTROL) & ~1);\n\n\tif (vdec_ops->conf_esparser)\n\t\tvdec_ops->conf_esparser(sess);\n\n\tamvdec_write_parser(core, PARSER_INT_STATUS, 0xffff);\n\tamvdec_write_parser(core, PARSER_INT_ENABLE,\n\t\t\t    BIT(PARSER_INT_HOST_EN_BIT));\n\n\treturn 0;\n}\n\nint esparser_init(struct platform_device *pdev, struct amvdec_core *core)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\tint irq;\n\n\tirq = platform_get_irq_byname(pdev, \"esparser\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, esparser_isr, IRQF_SHARED,\n\t\t\t       \"esparserirq\", core);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed requesting ESPARSER IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tcore->esparser_reset =\n\t\tdevm_reset_control_get_exclusive(dev, \"esparser\");\n\tif (IS_ERR(core->esparser_reset)) {\n\t\tdev_err(dev, \"Failed to get esparser_reset\\n\");\n\t\treturn PTR_ERR(core->esparser_reset);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}