{
  "module_name": "codec_h264.c",
  "hash_id": "ab1a44da4683fc8d081b5c11091697cfa6496a029f37a6a8a88f73407181652a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/meson/vdec/codec_h264.c",
  "human_readable_source": "\n \n\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"vdec_helpers.h\"\n#include \"dos_regs.h\"\n#include \"codec_h264.h\"\n\n#define SIZE_EXT_FW\t(20 * SZ_1K)\n#define SIZE_WORKSPACE\t0x1ee000\n#define SIZE_SEI\t(8 * SZ_1K)\n\n \n#define WORKSPACE_BUF_OFFSET\t0x1000000\n\n \n#define CMD_MASK\t\tGENMASK(7, 0)\n#define CMD_SRC_CHANGE\t\t1\n#define CMD_FRAMES_READY\t2\n#define CMD_FATAL_ERROR\t\t6\n#define CMD_BAD_WIDTH\t\t7\n#define CMD_BAD_HEIGHT\t\t8\n\n#define SEI_DATA_READY\tBIT(15)\n\n \n#define PIC_TOP_BOT\t5\n#define PIC_BOT_TOP\t6\n\n \n#define MB_MV_SIZE\t96\n\n \n#define PIC_STRUCT_BIT\t5\n#define PIC_STRUCT_MASK\tGENMASK(2, 0)\n#define BUF_IDX_MASK\tGENMASK(4, 0)\n#define ERROR_FLAG\tBIT(9)\n#define OFFSET_BIT\t16\n#define OFFSET_MASK\tGENMASK(15, 0)\n\n \n#define MB_TOTAL_BIT\t8\n#define MB_TOTAL_MASK\tGENMASK(15, 0)\n#define MB_WIDTH_MASK\tGENMASK(7, 0)\n#define MAX_REF_BIT\t24\n#define MAX_REF_MASK\tGENMASK(6, 0)\n#define AR_IDC_BIT\t16\n#define AR_IDC_MASK\tGENMASK(7, 0)\n#define AR_PRESENT_FLAG\tBIT(0)\n#define AR_EXTEND\t0xff\n\n \nstatic const u8 eos_sequence[SZ_4K] = {\n\t0x00, 0x00, 0x00, 0x01, 0x06, 0x05, 0xff, 0xe4, 0xdc, 0x45, 0xe9, 0xbd,\n\t0xe6, 0xd9, 0x48, 0xb7,\t0x96, 0x2c, 0xd8, 0x20, 0xd9, 0x23, 0xee, 0xef,\n\t0x78, 0x32, 0x36, 0x34, 0x20, 0x2d, 0x20, 0x63,\t0x6f, 0x72, 0x65, 0x20,\n\t0x36, 0x37, 0x20, 0x72, 0x31, 0x31, 0x33, 0x30, 0x20, 0x38, 0x34, 0x37,\n\t0x35, 0x39, 0x37, 0x37, 0x20, 0x2d, 0x20, 0x48, 0x2e, 0x32, 0x36, 0x34,\n\t0x2f, 0x4d, 0x50, 0x45,\t0x47, 0x2d, 0x34, 0x20, 0x41, 0x56, 0x43, 0x20,\n\t0x63, 0x6f, 0x64, 0x65, 0x63, 0x20, 0x2d, 0x20,\t0x43, 0x6f, 0x70, 0x79,\n\t0x6c, 0x65, 0x66, 0x74, 0x20, 0x32, 0x30, 0x30, 0x33, 0x2d, 0x32, 0x30,\n\t0x30, 0x39, 0x20, 0x2d, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f,\n\t0x77, 0x77, 0x77, 0x2e,\t0x76, 0x69, 0x64, 0x65, 0x6f, 0x6c, 0x61, 0x6e,\n\t0x2e, 0x6f, 0x72, 0x67, 0x2f, 0x78, 0x32, 0x36,\t0x34, 0x2e, 0x68, 0x74,\n\t0x6d, 0x6c, 0x20, 0x2d, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,\n\t0x3a, 0x20, 0x63, 0x61, 0x62, 0x61, 0x63, 0x3d, 0x31, 0x20, 0x72, 0x65,\n\t0x66, 0x3d, 0x31, 0x20,\t0x64, 0x65, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x3d,\n\t0x31, 0x3a, 0x30, 0x3a, 0x30, 0x20, 0x61, 0x6e,\t0x61, 0x6c, 0x79, 0x73,\n\t0x65, 0x3d, 0x30, 0x78, 0x31, 0x3a, 0x30, 0x78, 0x31, 0x31, 0x31, 0x20,\n\t0x6d, 0x65, 0x3d, 0x68, 0x65, 0x78, 0x20, 0x73, 0x75, 0x62, 0x6d, 0x65,\n\t0x3d, 0x36, 0x20, 0x70,\t0x73, 0x79, 0x5f, 0x72, 0x64, 0x3d, 0x31, 0x2e,\n\t0x30, 0x3a, 0x30, 0x2e, 0x30, 0x20, 0x6d, 0x69,\t0x78, 0x65, 0x64, 0x5f,\n\t0x72, 0x65, 0x66, 0x3d, 0x30, 0x20, 0x6d, 0x65, 0x5f, 0x72, 0x61, 0x6e,\n\t0x67, 0x65, 0x3d, 0x31, 0x36, 0x20, 0x63, 0x68, 0x72, 0x6f, 0x6d, 0x61,\n\t0x5f, 0x6d, 0x65, 0x3d,\t0x31, 0x20, 0x74, 0x72, 0x65, 0x6c, 0x6c, 0x69,\n\t0x73, 0x3d, 0x30, 0x20, 0x38, 0x78, 0x38, 0x64,\t0x63, 0x74, 0x3d, 0x30,\n\t0x20, 0x63, 0x71, 0x6d, 0x3d, 0x30, 0x20, 0x64, 0x65, 0x61, 0x64, 0x7a,\n\t0x6f, 0x6e, 0x65, 0x3d, 0x32, 0x31, 0x2c, 0x31, 0x31, 0x20, 0x63, 0x68,\n\t0x72, 0x6f, 0x6d, 0x61,\t0x5f, 0x71, 0x70, 0x5f, 0x6f, 0x66, 0x66, 0x73,\n\t0x65, 0x74, 0x3d, 0x2d, 0x32, 0x20, 0x74, 0x68,\t0x72, 0x65, 0x61, 0x64,\n\t0x73, 0x3d, 0x31, 0x20, 0x6e, 0x72, 0x3d, 0x30, 0x20, 0x64, 0x65, 0x63,\n\t0x69, 0x6d, 0x61, 0x74, 0x65, 0x3d, 0x31, 0x20, 0x6d, 0x62, 0x61, 0x66,\n\t0x66, 0x3d, 0x30, 0x20,\t0x62, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x73, 0x3d,\n\t0x30, 0x20, 0x6b, 0x65, 0x79, 0x69, 0x6e, 0x74,\t0x3d, 0x32, 0x35, 0x30,\n\t0x20, 0x6b, 0x65, 0x79, 0x69, 0x6e, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x3d,\n\t0x32, 0x35, 0x20, 0x73, 0x63, 0x65, 0x6e, 0x65, 0x63, 0x75, 0x74, 0x3d,\n\t0x34, 0x30, 0x20, 0x72,\t0x63, 0x3d, 0x61, 0x62, 0x72, 0x20, 0x62, 0x69,\n\t0x74, 0x72, 0x61, 0x74, 0x65, 0x3d, 0x31, 0x30,\t0x20, 0x72, 0x61, 0x74,\n\t0x65, 0x74, 0x6f, 0x6c, 0x3d, 0x31, 0x2e, 0x30, 0x20, 0x71, 0x63, 0x6f,\n\t0x6d, 0x70, 0x3d, 0x30, 0x2e, 0x36, 0x30, 0x20, 0x71, 0x70, 0x6d, 0x69,\n\t0x6e, 0x3d, 0x31, 0x30,\t0x20, 0x71, 0x70, 0x6d, 0x61, 0x78, 0x3d, 0x35,\n\t0x31, 0x20, 0x71, 0x70, 0x73, 0x74, 0x65, 0x70,\t0x3d, 0x34, 0x20, 0x69,\n\t0x70, 0x5f, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x3d, 0x31, 0x2e, 0x34, 0x30,\n\t0x20, 0x61, 0x71, 0x3d, 0x31, 0x3a, 0x31, 0x2e, 0x30, 0x30, 0x00, 0x80,\n\t0x00, 0x00, 0x00, 0x01,\t0x67, 0x4d, 0x40, 0x0a, 0x9a, 0x74, 0xf4, 0x20,\n\t0x00, 0x00, 0x03, 0x00, 0x20, 0x00, 0x00, 0x06,\t0x51, 0xe2, 0x44, 0xd4,\n\t0x00, 0x00, 0x00, 0x01, 0x68, 0xee, 0x32, 0xc8, 0x00, 0x00, 0x00, 0x01,\n\t0x65, 0x88, 0x80, 0x20, 0x00, 0x08, 0x7f, 0xea, 0x6a, 0xe2, 0x99, 0xb6,\n\t0x57, 0xae, 0x49, 0x30,\t0xf5, 0xfe, 0x5e, 0x46, 0x0b, 0x72, 0x44, 0xc4,\n\t0xe1, 0xfc, 0x62, 0xda, 0xf1, 0xfb, 0xa2, 0xdb,\t0xd6, 0xbe, 0x5c, 0xd7,\n\t0x24, 0xa3, 0xf5, 0xb9, 0x2f, 0x57, 0x16, 0x49, 0x75, 0x47, 0x77, 0x09,\n\t0x5c, 0xa1, 0xb4, 0xc3, 0x4f, 0x60, 0x2b, 0xb0, 0x0c, 0xc8, 0xd6, 0x66,\n\t0xba, 0x9b, 0x82, 0x29,\t0x33, 0x92, 0x26, 0x99, 0x31, 0x1c, 0x7f, 0x9b,\n\t0x00, 0x00, 0x01, 0x0ff,\n};\n\nstatic const u8 *codec_h264_eos_sequence(u32 *len)\n{\n\t*len = ARRAY_SIZE(eos_sequence);\n\treturn eos_sequence;\n}\n\nstruct codec_h264 {\n\t \n\tvoid      *ext_fw_vaddr;\n\tdma_addr_t ext_fw_paddr;\n\n\t \n\tvoid      *workspace_vaddr;\n\tdma_addr_t workspace_paddr;\n\n\t \n\tvoid      *ref_vaddr;\n\tdma_addr_t ref_paddr;\n\tu32\t   ref_size;\n\n\t \n\tvoid      *sei_vaddr;\n\tdma_addr_t sei_paddr;\n\n\tu32 mb_width;\n\tu32 mb_height;\n\tu32 max_refs;\n};\n\nstatic int codec_h264_can_recycle(struct amvdec_core *core)\n{\n\treturn !amvdec_read_dos(core, AV_SCRATCH_7) ||\n\t       !amvdec_read_dos(core, AV_SCRATCH_8);\n}\n\nstatic void codec_h264_recycle(struct amvdec_core *core, u32 buf_idx)\n{\n\t \n\tif (!amvdec_read_dos(core, AV_SCRATCH_7))\n\t\tamvdec_write_dos(core, AV_SCRATCH_7, buf_idx + 1);\n\telse\n\t\tamvdec_write_dos(core, AV_SCRATCH_8, buf_idx + 1);\n}\n\nstatic int codec_h264_start(struct amvdec_session *sess)\n{\n\tu32 workspace_offset;\n\tstruct amvdec_core *core = sess->core;\n\tstruct codec_h264 *h264 = sess->priv;\n\n\t \n\th264->workspace_vaddr =\n\t\tdma_alloc_coherent(core->dev, SIZE_WORKSPACE,\n\t\t\t\t   &h264->workspace_paddr, GFP_KERNEL);\n\tif (!h264->workspace_vaddr)\n\t\treturn -ENOMEM;\n\n\t \n\th264->sei_vaddr = dma_alloc_coherent(core->dev, SIZE_SEI,\n\t\t\t\t\t     &h264->sei_paddr, GFP_KERNEL);\n\tif (!h264->sei_vaddr)\n\t\treturn -ENOMEM;\n\n\tamvdec_write_dos_bits(core, POWER_CTL_VLD, BIT(9) | BIT(6));\n\n\tworkspace_offset = h264->workspace_paddr - WORKSPACE_BUF_OFFSET;\n\tamvdec_write_dos(core, AV_SCRATCH_1, workspace_offset);\n\tamvdec_write_dos(core, AV_SCRATCH_G, h264->ext_fw_paddr);\n\tamvdec_write_dos(core, AV_SCRATCH_I, h264->sei_paddr -\n\t\t\t\t\t     workspace_offset);\n\n\t \n\tamvdec_write_dos(core, AV_SCRATCH_F,\n\t\t\t (amvdec_read_dos(core, AV_SCRATCH_F) & 0xffffffc3) |\n\t\t\t BIT(4) | BIT(7));\n\n\tamvdec_write_dos(core, MDEC_PIC_DC_THRESH, 0x404038aa);\n\n\treturn 0;\n}\n\nstatic int codec_h264_stop(struct amvdec_session *sess)\n{\n\tstruct codec_h264 *h264 = sess->priv;\n\tstruct amvdec_core *core = sess->core;\n\n\tif (h264->ext_fw_vaddr)\n\t\tdma_free_coherent(core->dev, SIZE_EXT_FW,\n\t\t\t\t  h264->ext_fw_vaddr, h264->ext_fw_paddr);\n\n\tif (h264->workspace_vaddr)\n\t\tdma_free_coherent(core->dev, SIZE_WORKSPACE,\n\t\t\t\t  h264->workspace_vaddr, h264->workspace_paddr);\n\n\tif (h264->ref_vaddr)\n\t\tdma_free_coherent(core->dev, h264->ref_size,\n\t\t\t\t  h264->ref_vaddr, h264->ref_paddr);\n\n\tif (h264->sei_vaddr)\n\t\tdma_free_coherent(core->dev, SIZE_SEI,\n\t\t\t\t  h264->sei_vaddr, h264->sei_paddr);\n\n\treturn 0;\n}\n\nstatic int codec_h264_load_extended_firmware(struct amvdec_session *sess,\n\t\t\t\t\t     const u8 *data, u32 len)\n{\n\tstruct codec_h264 *h264;\n\tstruct amvdec_core *core = sess->core;\n\n\tif (len < SIZE_EXT_FW)\n\t\treturn -EINVAL;\n\n\th264 = kzalloc(sizeof(*h264), GFP_KERNEL);\n\tif (!h264)\n\t\treturn -ENOMEM;\n\n\th264->ext_fw_vaddr = dma_alloc_coherent(core->dev, SIZE_EXT_FW,\n\t\t\t\t\t\t&h264->ext_fw_paddr,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!h264->ext_fw_vaddr) {\n\t\tkfree(h264);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(h264->ext_fw_vaddr, data, SIZE_EXT_FW);\n\tsess->priv = h264;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_fract par_table[] = {\n\t{ 1, 1 },   { 1, 1 },    { 12, 11 }, { 10, 11 },\n\t{ 16, 11 }, { 40, 33 },  { 24, 11 }, { 20, 11 },\n\t{ 32, 11 }, { 80, 33 },  { 18, 11 }, { 15, 11 },\n\t{ 64, 33 }, { 160, 99 }, { 4, 3 },   { 3, 2 },\n\t{ 2, 1 }\n};\n\nstatic void codec_h264_set_par(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\tu32 seq_info = amvdec_read_dos(core, AV_SCRATCH_2);\n\tu32 ar_idc = (seq_info >> AR_IDC_BIT) & AR_IDC_MASK;\n\n\tif (!(seq_info & AR_PRESENT_FLAG))\n\t\treturn;\n\n\tif (ar_idc == AR_EXTEND) {\n\t\tu32 ar_info = amvdec_read_dos(core, AV_SCRATCH_3);\n\n\t\tsess->pixelaspect.numerator = ar_info & 0xffff;\n\t\tsess->pixelaspect.denominator = (ar_info >> 16) & 0xffff;\n\t\treturn;\n\t}\n\n\tif (ar_idc >= ARRAY_SIZE(par_table))\n\t\treturn;\n\n\tsess->pixelaspect = par_table[ar_idc];\n}\n\nstatic void codec_h264_resume(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct codec_h264 *h264 = sess->priv;\n\tu32 mb_width, mb_height, mb_total;\n\n\tamvdec_set_canvases(sess,\n\t\t\t    (u32[]){ ANC0_CANVAS_ADDR, 0 },\n\t\t\t    (u32[]){ 24, 0 });\n\n\tdev_dbg(core->dev, \"max_refs = %u; actual_dpb_size = %u\\n\",\n\t\th264->max_refs, sess->num_dst_bufs);\n\n\t \n\tmb_width = ALIGN(h264->mb_width, 4);\n\tmb_height = ALIGN(h264->mb_height, 4);\n\tmb_total = mb_width * mb_height;\n\n\th264->ref_size = mb_total * MB_MV_SIZE * h264->max_refs;\n\th264->ref_vaddr = dma_alloc_coherent(core->dev, h264->ref_size,\n\t\t\t\t\t     &h264->ref_paddr, GFP_KERNEL);\n\tif (!h264->ref_vaddr) {\n\t\tamvdec_abort(sess);\n\t\treturn;\n\t}\n\n\t \n\tamvdec_write_dos(core, AV_SCRATCH_1, h264->ref_paddr);\n\t \n\tamvdec_write_dos(core, AV_SCRATCH_4, h264->ref_paddr + h264->ref_size);\n\n\tamvdec_write_dos(core, AV_SCRATCH_0, (h264->max_refs << 24) |\n\t\t\t\t\t     (sess->num_dst_bufs << 16) |\n\t\t\t\t\t     ((h264->max_refs - 1) << 8));\n}\n\n \nstatic void codec_h264_src_change(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct codec_h264 *h264 = sess->priv;\n\tu32 parsed_info, mb_total;\n\tu32 crop_infor, crop_bottom, crop_right;\n\tu32 frame_width, frame_height;\n\n\tsess->keyframe_found = 1;\n\n\tparsed_info = amvdec_read_dos(core, AV_SCRATCH_1);\n\n\t \n\tmb_total = (parsed_info >> MB_TOTAL_BIT) & MB_TOTAL_MASK;\n\t \n\th264->mb_width = parsed_info & MB_WIDTH_MASK;\n\t \n\th264->mb_height = mb_total / h264->mb_width;\n\n\th264->max_refs = ((parsed_info >> MAX_REF_BIT) & MAX_REF_MASK) + 1;\n\n\tcrop_infor = amvdec_read_dos(core, AV_SCRATCH_6);\n\tcrop_bottom = (crop_infor & 0xff);\n\tcrop_right = (crop_infor >> 16) & 0xff;\n\n\tframe_width = h264->mb_width * 16 - crop_right;\n\tframe_height = h264->mb_height * 16 - crop_bottom;\n\n\tdev_dbg(core->dev, \"frame: %ux%u; crop: %u %u\\n\",\n\t\tframe_width, frame_height, crop_right, crop_bottom);\n\n\tcodec_h264_set_par(sess);\n\tamvdec_src_change(sess, frame_width, frame_height, h264->max_refs + 5);\n}\n\n \nstatic u32 get_offset_msb(struct amvdec_core *core, int frame_num)\n{\n\tint take_msb = frame_num % 2;\n\tint reg_offset = (frame_num / 2) * 4;\n\tu32 offset_msb = amvdec_read_dos(core, AV_SCRATCH_A + reg_offset);\n\n\tif (take_msb)\n\t\treturn offset_msb & 0xffff0000;\n\n\treturn (offset_msb & 0x0000ffff) << 16;\n}\n\nstatic void codec_h264_frames_ready(struct amvdec_session *sess, u32 status)\n{\n\tstruct amvdec_core *core = sess->core;\n\tint error_count;\n\tint num_frames;\n\tint i;\n\n\terror_count = amvdec_read_dos(core, AV_SCRATCH_D);\n\tnum_frames = (status >> 8) & 0xff;\n\tif (error_count) {\n\t\tdev_warn(core->dev,\n\t\t\t \"decoder error(s) happened, count %d\\n\", error_count);\n\t\tamvdec_write_dos(core, AV_SCRATCH_D, 0);\n\t}\n\n\tfor (i = 0; i < num_frames; i++) {\n\t\tu32 frame_status = amvdec_read_dos(core, AV_SCRATCH_1 + i * 4);\n\t\tu32 buffer_index = frame_status & BUF_IDX_MASK;\n\t\tu32 pic_struct = (frame_status >> PIC_STRUCT_BIT) &\n\t\t\t\t PIC_STRUCT_MASK;\n\t\tu32 offset = (frame_status >> OFFSET_BIT) & OFFSET_MASK;\n\t\tu32 field = V4L2_FIELD_NONE;\n\n\t\t \n\t\tif (frame_status & ERROR_FLAG)\n\t\t\tdev_dbg(core->dev, \"Buffer %d decode error\\n\",\n\t\t\t\tbuffer_index);\n\n\t\tif (pic_struct == PIC_TOP_BOT)\n\t\t\tfield = V4L2_FIELD_INTERLACED_TB;\n\t\telse if (pic_struct == PIC_BOT_TOP)\n\t\t\tfield = V4L2_FIELD_INTERLACED_BT;\n\n\t\toffset |= get_offset_msb(core, i);\n\t\tamvdec_dst_buf_done_idx(sess, buffer_index, offset, field);\n\t}\n}\n\nstatic irqreturn_t codec_h264_threaded_isr(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\tu32 status;\n\tu32 size;\n\tu8 cmd;\n\n\tstatus = amvdec_read_dos(core, AV_SCRATCH_0);\n\tcmd = status & CMD_MASK;\n\n\tswitch (cmd) {\n\tcase CMD_SRC_CHANGE:\n\t\tcodec_h264_src_change(sess);\n\t\tbreak;\n\tcase CMD_FRAMES_READY:\n\t\tcodec_h264_frames_ready(sess, status);\n\t\tbreak;\n\tcase CMD_FATAL_ERROR:\n\t\tdev_err(core->dev, \"H.264 decoder fatal error\\n\");\n\t\tgoto abort;\n\tcase CMD_BAD_WIDTH:\n\t\tsize = (amvdec_read_dos(core, AV_SCRATCH_1) + 1) * 16;\n\t\tdev_err(core->dev, \"Unsupported video width: %u\\n\", size);\n\t\tgoto abort;\n\tcase CMD_BAD_HEIGHT:\n\t\tsize = (amvdec_read_dos(core, AV_SCRATCH_1) + 1) * 16;\n\t\tdev_err(core->dev, \"Unsupported video height: %u\\n\", size);\n\t\tgoto abort;\n\tcase 0:  \n\tcase 9:\n\t\tbreak;\n\tdefault:\n\t\tdev_info(core->dev, \"Unexpected H264 ISR: %08X\\n\", cmd);\n\t\tbreak;\n\t}\n\n\tif (cmd && cmd != CMD_SRC_CHANGE)\n\t\tamvdec_write_dos(core, AV_SCRATCH_0, 0);\n\n\t \n\tif (amvdec_read_dos(core, AV_SCRATCH_J) & SEI_DATA_READY)\n\t\tamvdec_write_dos(core, AV_SCRATCH_J, 0);\n\n\treturn IRQ_HANDLED;\nabort:\n\tamvdec_abort(sess);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t codec_h264_isr(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\n\tamvdec_write_dos(core, ASSIST_MBOX1_CLR_REG, 1);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstruct amvdec_codec_ops codec_h264_ops = {\n\t.start = codec_h264_start,\n\t.stop = codec_h264_stop,\n\t.load_extended_firmware = codec_h264_load_extended_firmware,\n\t.isr = codec_h264_isr,\n\t.threaded_isr = codec_h264_threaded_isr,\n\t.can_recycle = codec_h264_can_recycle,\n\t.recycle = codec_h264_recycle,\n\t.eos_sequence = codec_h264_eos_sequence,\n\t.resume = codec_h264_resume,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}