{
  "module_name": "vdec.c",
  "hash_id": "9dda3da9bf0e2df5d7fdc39f7ed0c264456cede4dc2306b871fb48178f2ca862",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/meson/vdec/vdec.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/kthread.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-dev.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"vdec.h\"\n#include \"esparser.h\"\n#include \"vdec_helpers.h\"\n\nstruct dummy_buf {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\n \n#define SIZE_VIFIFO SZ_16M\n\nstatic u32 get_output_size(u32 width, u32 height)\n{\n\treturn ALIGN(width * height, SZ_64K);\n}\n\nu32 amvdec_get_output_size(struct amvdec_session *sess)\n{\n\treturn get_output_size(sess->width, sess->height);\n}\nEXPORT_SYMBOL_GPL(amvdec_get_output_size);\n\nstatic int vdec_codec_needs_recycle(struct amvdec_session *sess)\n{\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\n\treturn codec_ops->can_recycle && codec_ops->recycle;\n}\n\nstatic int vdec_recycle_thread(void *data)\n{\n\tstruct amvdec_session *sess = data;\n\tstruct amvdec_core *core = sess->core;\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\tstruct amvdec_buffer *tmp, *n;\n\n\twhile (!kthread_should_stop()) {\n\t\tmutex_lock(&sess->bufs_recycle_lock);\n\t\tlist_for_each_entry_safe(tmp, n, &sess->bufs_recycle, list) {\n\t\t\tif (!codec_ops->can_recycle(core))\n\t\t\t\tbreak;\n\n\t\t\tcodec_ops->recycle(core, tmp->vb->index);\n\t\t\tlist_del(&tmp->list);\n\t\t\tkfree(tmp);\n\t\t}\n\t\tmutex_unlock(&sess->bufs_recycle_lock);\n\n\t\tusleep_range(5000, 10000);\n\t}\n\n\treturn 0;\n}\n\nstatic int vdec_poweron(struct amvdec_session *sess)\n{\n\tint ret;\n\tstruct amvdec_ops *vdec_ops = sess->fmt_out->vdec_ops;\n\n\tret = clk_prepare_enable(sess->core->dos_parser_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(sess->core->dos_clk);\n\tif (ret)\n\t\tgoto disable_dos_parser;\n\n\tret = vdec_ops->start(sess);\n\tif (ret)\n\t\tgoto disable_dos;\n\n\tesparser_power_up(sess);\n\n\treturn 0;\n\ndisable_dos:\n\tclk_disable_unprepare(sess->core->dos_clk);\ndisable_dos_parser:\n\tclk_disable_unprepare(sess->core->dos_parser_clk);\n\n\treturn ret;\n}\n\nstatic void vdec_wait_inactive(struct amvdec_session *sess)\n{\n\t \n\twhile (time_is_after_jiffies64(sess->last_irq_jiffies +\n\t\t\t\t       msecs_to_jiffies(50)))\n\t\tmsleep(25);\n}\n\nstatic void vdec_poweroff(struct amvdec_session *sess)\n{\n\tstruct amvdec_ops *vdec_ops = sess->fmt_out->vdec_ops;\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\n\tsess->should_stop = 1;\n\tvdec_wait_inactive(sess);\n\tif (codec_ops->drain)\n\t\tcodec_ops->drain(sess);\n\n\tvdec_ops->stop(sess);\n\tclk_disable_unprepare(sess->core->dos_clk);\n\tclk_disable_unprepare(sess->core->dos_parser_clk);\n}\n\nstatic void\nvdec_queue_recycle(struct amvdec_session *sess, struct vb2_buffer *vb)\n{\n\tstruct amvdec_buffer *new_buf;\n\n\tnew_buf = kmalloc(sizeof(*new_buf), GFP_KERNEL);\n\tif (!new_buf)\n\t\treturn;\n\tnew_buf->vb = vb;\n\n\tmutex_lock(&sess->bufs_recycle_lock);\n\tlist_add_tail(&new_buf->list, &sess->bufs_recycle);\n\tmutex_unlock(&sess->bufs_recycle_lock);\n}\n\nstatic void vdec_m2m_device_run(void *priv)\n{\n\tstruct amvdec_session *sess = priv;\n\n\tschedule_work(&sess->esparser_queue_work);\n}\n\nstatic void vdec_m2m_job_abort(void *priv)\n{\n\tstruct amvdec_session *sess = priv;\n\n\tv4l2_m2m_job_finish(sess->m2m_dev, sess->m2m_ctx);\n}\n\nstatic const struct v4l2_m2m_ops vdec_m2m_ops = {\n\t.device_run = vdec_m2m_device_run,\n\t.job_abort = vdec_m2m_job_abort,\n};\n\nstatic void process_num_buffers(struct vb2_queue *q,\n\t\t\t\tstruct amvdec_session *sess,\n\t\t\t\tunsigned int *num_buffers,\n\t\t\t\tbool is_reqbufs)\n{\n\tconst struct amvdec_format *fmt_out = sess->fmt_out;\n\tunsigned int buffers_total = q->num_buffers + *num_buffers;\n\tu32 min_buf_capture = v4l2_ctrl_g_ctrl(sess->ctrl_min_buf_capture);\n\n\tif (q->num_buffers + *num_buffers < min_buf_capture)\n\t\t*num_buffers = min_buf_capture - q->num_buffers;\n\tif (is_reqbufs && buffers_total < fmt_out->min_buffers)\n\t\t*num_buffers = fmt_out->min_buffers - q->num_buffers;\n\tif (buffers_total > fmt_out->max_buffers)\n\t\t*num_buffers = fmt_out->max_buffers - q->num_buffers;\n\n\t \n\tsess->num_dst_bufs = q->num_buffers + *num_buffers;\n\tq->min_buffers_needed = max(fmt_out->min_buffers, sess->num_dst_bufs);\n}\n\nstatic int vdec_queue_setup(struct vb2_queue *q, unsigned int *num_buffers,\n\t\t\t    unsigned int *num_planes, unsigned int sizes[],\n\t\t\t    struct device *alloc_devs[])\n{\n\tstruct amvdec_session *sess = vb2_get_drv_priv(q);\n\tu32 output_size = amvdec_get_output_size(sess);\n\n\tif (*num_planes) {\n\t\tswitch (q->type) {\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\t\tif (*num_planes != 1 ||\n\t\t\t    sizes[0] < sess->src_buffer_size)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\t\tswitch (sess->pixfmt_cap) {\n\t\t\tcase V4L2_PIX_FMT_NV12M:\n\t\t\t\tif (*num_planes != 2 ||\n\t\t\t\t    sizes[0] < output_size ||\n\t\t\t\t    sizes[1] < output_size / 2)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase V4L2_PIX_FMT_YUV420M:\n\t\t\t\tif (*num_planes != 3 ||\n\t\t\t\t    sizes[0] < output_size ||\n\t\t\t\t    sizes[1] < output_size / 4 ||\n\t\t\t\t    sizes[2] < output_size / 4)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tprocess_num_buffers(q, sess, num_buffers, false);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tswitch (q->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tsizes[0] = sess->src_buffer_size;\n\t\t*num_planes = 1;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tswitch (sess->pixfmt_cap) {\n\t\tcase V4L2_PIX_FMT_NV12M:\n\t\t\tsizes[0] = output_size;\n\t\t\tsizes[1] = output_size / 2;\n\t\t\t*num_planes = 2;\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_YUV420M:\n\t\t\tsizes[0] = output_size;\n\t\t\tsizes[1] = output_size / 4;\n\t\t\tsizes[2] = output_size / 4;\n\t\t\t*num_planes = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprocess_num_buffers(q, sess, num_buffers, true);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsess->changed_format = 1;\n\treturn 0;\n}\n\nstatic void vdec_vb2_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct amvdec_session *sess = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct v4l2_m2m_ctx *m2m_ctx = sess->m2m_ctx;\n\n\tv4l2_m2m_buf_queue(m2m_ctx, vbuf);\n\n\tif (!sess->streamon_out)\n\t\treturn;\n\n\tif (sess->streamon_cap &&\n\t    vb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\n\t    vdec_codec_needs_recycle(sess))\n\t\tvdec_queue_recycle(sess, vb);\n\n\tschedule_work(&sess->esparser_queue_work);\n}\n\nstatic int vdec_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct amvdec_session *sess = vb2_get_drv_priv(q);\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\tstruct amvdec_core *core = sess->core;\n\tstruct vb2_v4l2_buffer *buf;\n\tint ret;\n\n\tif (core->cur_sess && core->cur_sess != sess) {\n\t\tret = -EBUSY;\n\t\tgoto bufs_done;\n\t}\n\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tsess->streamon_out = 1;\n\telse\n\t\tsess->streamon_cap = 1;\n\n\tif (!sess->streamon_out)\n\t\treturn 0;\n\n\tif (sess->status == STATUS_NEEDS_RESUME &&\n\t    q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\n\t    sess->changed_format) {\n\t\tcodec_ops->resume(sess);\n\t\tsess->status = STATUS_RUNNING;\n\t\treturn 0;\n\t}\n\n\tif (sess->status == STATUS_RUNNING ||\n\t    sess->status == STATUS_NEEDS_RESUME ||\n\t    sess->status == STATUS_INIT)\n\t\treturn 0;\n\n\tsess->vififo_size = SIZE_VIFIFO;\n\tsess->vififo_vaddr =\n\t\tdma_alloc_coherent(sess->core->dev, sess->vififo_size,\n\t\t\t\t   &sess->vififo_paddr, GFP_KERNEL);\n\tif (!sess->vififo_vaddr) {\n\t\tdev_err(sess->core->dev, \"Failed to request VIFIFO buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto bufs_done;\n\t}\n\n\tsess->should_stop = 0;\n\tsess->keyframe_found = 0;\n\tsess->last_offset = 0;\n\tsess->wrap_count = 0;\n\tsess->pixelaspect.numerator = 1;\n\tsess->pixelaspect.denominator = 1;\n\tatomic_set(&sess->esparser_queued_bufs, 0);\n\tv4l2_ctrl_s_ctrl(sess->ctrl_min_buf_capture, 1);\n\n\tret = vdec_poweron(sess);\n\tif (ret)\n\t\tgoto vififo_free;\n\n\tsess->sequence_cap = 0;\n\tsess->sequence_out = 0;\n\tif (vdec_codec_needs_recycle(sess))\n\t\tsess->recycle_thread = kthread_run(vdec_recycle_thread, sess,\n\t\t\t\t\t\t   \"vdec_recycle\");\n\n\tsess->status = STATUS_INIT;\n\tcore->cur_sess = sess;\n\tschedule_work(&sess->esparser_queue_work);\n\treturn 0;\n\nvififo_free:\n\tdma_free_coherent(sess->core->dev, sess->vififo_size,\n\t\t\t  sess->vififo_vaddr, sess->vififo_paddr);\nbufs_done:\n\twhile ((buf = v4l2_m2m_src_buf_remove(sess->m2m_ctx)))\n\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);\n\twhile ((buf = v4l2_m2m_dst_buf_remove(sess->m2m_ctx)))\n\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);\n\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tsess->streamon_out = 0;\n\telse\n\t\tsess->streamon_cap = 0;\n\n\treturn ret;\n}\n\nstatic void vdec_free_canvas(struct amvdec_session *sess)\n{\n\tint i;\n\n\tfor (i = 0; i < sess->canvas_num; ++i)\n\t\tmeson_canvas_free(sess->core->canvas, sess->canvas_alloc[i]);\n\n\tsess->canvas_num = 0;\n}\n\nstatic void vdec_reset_timestamps(struct amvdec_session *sess)\n{\n\tstruct amvdec_timestamp *tmp, *n;\n\n\tlist_for_each_entry_safe(tmp, n, &sess->timestamps, list) {\n\t\tlist_del(&tmp->list);\n\t\tkfree(tmp);\n\t}\n}\n\nstatic void vdec_reset_bufs_recycle(struct amvdec_session *sess)\n{\n\tstruct amvdec_buffer *tmp, *n;\n\n\tlist_for_each_entry_safe(tmp, n, &sess->bufs_recycle, list) {\n\t\tlist_del(&tmp->list);\n\t\tkfree(tmp);\n\t}\n}\n\nstatic void vdec_stop_streaming(struct vb2_queue *q)\n{\n\tstruct amvdec_session *sess = vb2_get_drv_priv(q);\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\tstruct amvdec_core *core = sess->core;\n\tstruct vb2_v4l2_buffer *buf;\n\n\tif (sess->status == STATUS_RUNNING ||\n\t    sess->status == STATUS_INIT ||\n\t    (sess->status == STATUS_NEEDS_RESUME &&\n\t     (!sess->streamon_out || !sess->streamon_cap))) {\n\t\tif (vdec_codec_needs_recycle(sess))\n\t\t\tkthread_stop(sess->recycle_thread);\n\n\t\tvdec_poweroff(sess);\n\t\tvdec_free_canvas(sess);\n\t\tdma_free_coherent(sess->core->dev, sess->vififo_size,\n\t\t\t\t  sess->vififo_vaddr, sess->vififo_paddr);\n\t\tvdec_reset_timestamps(sess);\n\t\tvdec_reset_bufs_recycle(sess);\n\t\tkfree(sess->priv);\n\t\tsess->priv = NULL;\n\t\tcore->cur_sess = NULL;\n\t\tsess->status = STATUS_STOPPED;\n\t}\n\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\twhile ((buf = v4l2_m2m_src_buf_remove(sess->m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);\n\n\t\tsess->streamon_out = 0;\n\t} else {\n\t\t \n\t\tif (sess->status >= STATUS_RUNNING && codec_ops->drain)\n\t\t\tcodec_ops->drain(sess);\n\n\t\twhile ((buf = v4l2_m2m_dst_buf_remove(sess->m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);\n\n\t\tsess->streamon_cap = 0;\n\t}\n}\n\nstatic int vdec_vb2_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\treturn 0;\n}\n\nstatic const struct vb2_ops vdec_vb2_ops = {\n\t.queue_setup = vdec_queue_setup,\n\t.start_streaming = vdec_start_streaming,\n\t.stop_streaming = vdec_stop_streaming,\n\t.buf_queue = vdec_vb2_buf_queue,\n\t.buf_prepare = vdec_vb2_buf_prepare,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n\nstatic int\nvdec_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, \"meson-vdec\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"Amlogic Video Decoder\", sizeof(cap->card));\n\tstrscpy(cap->bus_info, \"platform:meson-vdec\", sizeof(cap->bus_info));\n\n\treturn 0;\n}\n\nstatic const struct amvdec_format *\nfind_format(const struct amvdec_format *fmts, u32 size, u32 pixfmt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (fmts[i].pixfmt == pixfmt)\n\t\t\treturn &fmts[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic unsigned int\nvdec_supports_pixfmt_cap(const struct amvdec_format *fmt_out, u32 pixfmt_cap)\n{\n\tint i;\n\n\tfor (i = 0; fmt_out->pixfmts_cap[i]; i++)\n\t\tif (fmt_out->pixfmts_cap[i] == pixfmt_cap)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic const struct amvdec_format *\nvdec_try_fmt_common(struct amvdec_session *sess, u32 size,\n\t\t    struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tstruct v4l2_plane_pix_format *pfmt = pixmp->plane_fmt;\n\tconst struct amvdec_format *fmts = sess->core->platform->formats;\n\tconst struct amvdec_format *fmt_out = NULL;\n\tu32 output_size = 0;\n\n\tmemset(pfmt[0].reserved, 0, sizeof(pfmt[0].reserved));\n\tmemset(pixmp->reserved, 0, sizeof(pixmp->reserved));\n\n\tswitch (f->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tfmt_out = find_format(fmts, size, pixmp->pixelformat);\n\t\tif (!fmt_out) {\n\t\t\tpixmp->pixelformat = V4L2_PIX_FMT_MPEG2;\n\t\t\tfmt_out = find_format(fmts, size, pixmp->pixelformat);\n\t\t}\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tfmt_out = sess->fmt_out;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tpixmp->width  = clamp(pixmp->width,  (u32)256, fmt_out->max_width);\n\tpixmp->height = clamp(pixmp->height, (u32)144, fmt_out->max_height);\n\toutput_size = get_output_size(pixmp->width, pixmp->height);\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tif (!pfmt[0].sizeimage)\n\t\t\tpfmt[0].sizeimage = sess->src_buffer_size;\n\t\tpfmt[0].bytesperline = 0;\n\t\tpixmp->num_planes = 1;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tfmt_out = sess->fmt_out;\n\t\tif (!vdec_supports_pixfmt_cap(fmt_out, pixmp->pixelformat))\n\t\t\tpixmp->pixelformat = fmt_out->pixfmts_cap[0];\n\n\t\tmemset(pfmt[1].reserved, 0, sizeof(pfmt[1].reserved));\n\t\tif (pixmp->pixelformat == V4L2_PIX_FMT_NV12M) {\n\t\t\tpfmt[0].sizeimage = output_size;\n\t\t\tpfmt[0].bytesperline = ALIGN(pixmp->width, 32);\n\n\t\t\tpfmt[1].sizeimage = output_size / 2;\n\t\t\tpfmt[1].bytesperline = ALIGN(pixmp->width, 32);\n\t\t\tpixmp->num_planes = 2;\n\t\t} else if (pixmp->pixelformat == V4L2_PIX_FMT_YUV420M) {\n\t\t\tpfmt[0].sizeimage = output_size;\n\t\t\tpfmt[0].bytesperline = ALIGN(pixmp->width, 32);\n\n\t\t\tpfmt[1].sizeimage = output_size / 4;\n\t\t\tpfmt[1].bytesperline = ALIGN(pixmp->width, 32) / 2;\n\n\t\t\tpfmt[2].sizeimage = output_size / 2;\n\t\t\tpfmt[2].bytesperline = ALIGN(pixmp->width, 32) / 2;\n\t\t\tpixmp->num_planes = 3;\n\t\t}\n\t}\n\n\tif (pixmp->field == V4L2_FIELD_ANY)\n\t\tpixmp->field = V4L2_FIELD_NONE;\n\n\treturn fmt_out;\n}\n\nstatic int vdec_try_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct amvdec_session *sess =\n\t\tcontainer_of(file->private_data, struct amvdec_session, fh);\n\n\tvdec_try_fmt_common(sess, sess->core->platform->num_formats, f);\n\n\treturn 0;\n}\n\nstatic int vdec_g_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct amvdec_session *sess =\n\t\tcontainer_of(file->private_data, struct amvdec_session, fh);\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tpixmp->pixelformat = sess->pixfmt_cap;\n\telse if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tpixmp->pixelformat = sess->fmt_out->pixfmt;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tpixmp->width = sess->width;\n\t\tpixmp->height = sess->height;\n\t\tpixmp->colorspace = sess->colorspace;\n\t\tpixmp->ycbcr_enc = sess->ycbcr_enc;\n\t\tpixmp->quantization = sess->quantization;\n\t\tpixmp->xfer_func = sess->xfer_func;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tpixmp->width = sess->width;\n\t\tpixmp->height = sess->height;\n\t}\n\n\tvdec_try_fmt_common(sess, sess->core->platform->num_formats, f);\n\n\treturn 0;\n}\n\nstatic int vdec_s_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct amvdec_session *sess =\n\t\tcontainer_of(file->private_data, struct amvdec_session, fh);\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tu32 num_formats = sess->core->platform->num_formats;\n\tconst struct amvdec_format *fmt_out;\n\tstruct v4l2_pix_format_mplane orig_pixmp;\n\tstruct v4l2_format format;\n\tu32 pixfmt_out = 0, pixfmt_cap = 0;\n\n\torig_pixmp = *pixmp;\n\n\tfmt_out = vdec_try_fmt_common(sess, num_formats, f);\n\tif (!fmt_out)\n\t\treturn -EINVAL;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tpixfmt_out = pixmp->pixelformat;\n\t\tpixfmt_cap = sess->pixfmt_cap;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tpixfmt_cap = pixmp->pixelformat;\n\t\tpixfmt_out = sess->fmt_out->pixfmt;\n\t}\n\n\tmemset(&format, 0, sizeof(format));\n\n\tformat.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tformat.fmt.pix_mp.pixelformat = pixfmt_out;\n\tformat.fmt.pix_mp.width = orig_pixmp.width;\n\tformat.fmt.pix_mp.height = orig_pixmp.height;\n\tvdec_try_fmt_common(sess, num_formats, &format);\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tsess->width = format.fmt.pix_mp.width;\n\t\tsess->height = format.fmt.pix_mp.height;\n\t\tsess->colorspace = pixmp->colorspace;\n\t\tsess->ycbcr_enc = pixmp->ycbcr_enc;\n\t\tsess->quantization = pixmp->quantization;\n\t\tsess->xfer_func = pixmp->xfer_func;\n\t\tsess->src_buffer_size = pixmp->plane_fmt[0].sizeimage;\n\t}\n\n\tmemset(&format, 0, sizeof(format));\n\n\tformat.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tformat.fmt.pix_mp.pixelformat = pixfmt_cap;\n\tformat.fmt.pix_mp.width = orig_pixmp.width;\n\tformat.fmt.pix_mp.height = orig_pixmp.height;\n\tvdec_try_fmt_common(sess, num_formats, &format);\n\n\tsess->width = format.fmt.pix_mp.width;\n\tsess->height = format.fmt.pix_mp.height;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tsess->fmt_out = fmt_out;\n\telse if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tsess->pixfmt_cap = format.fmt.pix_mp.pixelformat;\n\n\treturn 0;\n}\n\nstatic int vdec_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)\n{\n\tstruct amvdec_session *sess =\n\t\tcontainer_of(file->private_data, struct amvdec_session, fh);\n\tconst struct vdec_platform *platform = sess->core->platform;\n\tconst struct amvdec_format *fmt_out;\n\n\tmemset(f->reserved, 0, sizeof(f->reserved));\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tif (f->index >= platform->num_formats)\n\t\t\treturn -EINVAL;\n\n\t\tfmt_out = &platform->formats[f->index];\n\t\tf->pixelformat = fmt_out->pixfmt;\n\t\tf->flags = fmt_out->flags;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tfmt_out = sess->fmt_out;\n\t\tif (f->index >= 4 || !fmt_out->pixfmts_cap[f->index])\n\t\t\treturn -EINVAL;\n\n\t\tf->pixelformat = fmt_out->pixfmts_cap[f->index];\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vdec_enum_framesizes(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_frmsizeenum *fsize)\n{\n\tstruct amvdec_session *sess =\n\t\tcontainer_of(file->private_data, struct amvdec_session, fh);\n\tconst struct amvdec_format *formats = sess->core->platform->formats;\n\tconst struct amvdec_format *fmt;\n\tu32 num_formats = sess->core->platform->num_formats;\n\n\tfmt = find_format(formats, num_formats, fsize->pixel_format);\n\tif (!fmt || fsize->index)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\n\tfsize->stepwise.min_width = 256;\n\tfsize->stepwise.max_width = fmt->max_width;\n\tfsize->stepwise.step_width = 1;\n\tfsize->stepwise.min_height = 144;\n\tfsize->stepwise.max_height = fmt->max_height;\n\tfsize->stepwise.step_height = 1;\n\n\treturn 0;\n}\n\nstatic int\nvdec_decoder_cmd(struct file *file, void *fh, struct v4l2_decoder_cmd *cmd)\n{\n\tstruct amvdec_session *sess =\n\t\tcontainer_of(file->private_data, struct amvdec_session, fh);\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\tstruct device *dev = sess->core->dev;\n\tint ret;\n\n\tret = v4l2_m2m_ioctl_try_decoder_cmd(file, fh, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(sess->streamon_out & sess->streamon_cap))\n\t\treturn 0;\n\n\tif (cmd->cmd == V4L2_DEC_CMD_START) {\n\t\tv4l2_m2m_clear_state(sess->m2m_ctx);\n\t\tsess->should_stop = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tif (cmd->cmd != V4L2_DEC_CMD_STOP)\n\t\treturn -EINVAL;\n\n\tdev_dbg(dev, \"Received V4L2_DEC_CMD_STOP\\n\");\n\n\tsess->should_stop = 1;\n\n\tv4l2_m2m_mark_stopped(sess->m2m_ctx);\n\n\tif (codec_ops->drain) {\n\t\tvdec_wait_inactive(sess);\n\t\tcodec_ops->drain(sess);\n\t} else if (codec_ops->eos_sequence) {\n\t\tu32 len;\n\t\tconst u8 *data = codec_ops->eos_sequence(&len);\n\n\t\tesparser_queue_eos(sess->core, data, len);\n\t\tvdec_wait_inactive(sess);\n\t}\n\n\treturn ret;\n}\n\nstatic int vdec_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\tconst struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_EOS:\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_event_subscribe(fh, sub, 0, NULL);\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vdec_g_pixelaspect(struct file *file, void *fh, int type,\n\t\t\t      struct v4l2_fract *f)\n{\n\tstruct amvdec_session *sess =\n\t\tcontainer_of(file->private_data, struct amvdec_session, fh);\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn -EINVAL;\n\n\t*f = sess->pixelaspect;\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops vdec_ioctl_ops = {\n\t.vidioc_querycap = vdec_querycap,\n\t.vidioc_enum_fmt_vid_cap = vdec_enum_fmt,\n\t.vidioc_enum_fmt_vid_out = vdec_enum_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane = vdec_s_fmt,\n\t.vidioc_s_fmt_vid_out_mplane = vdec_s_fmt,\n\t.vidioc_g_fmt_vid_cap_mplane = vdec_g_fmt,\n\t.vidioc_g_fmt_vid_out_mplane = vdec_g_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane = vdec_try_fmt,\n\t.vidioc_try_fmt_vid_out_mplane = vdec_try_fmt,\n\t.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,\n\t.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_streamon = v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,\n\t.vidioc_enum_framesizes = vdec_enum_framesizes,\n\t.vidioc_subscribe_event = vdec_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_try_decoder_cmd = v4l2_m2m_ioctl_try_decoder_cmd,\n\t.vidioc_decoder_cmd = vdec_decoder_cmd,\n\t.vidioc_g_pixelaspect = vdec_g_pixelaspect,\n};\n\nstatic int m2m_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t  struct vb2_queue *dst_vq)\n{\n\tstruct amvdec_session *sess = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->ops = &vdec_vb2_ops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->drv_priv = sess;\n\tsrc_vq->buf_struct_size = sizeof(struct dummy_buf);\n\tsrc_vq->min_buffers_needed = 1;\n\tsrc_vq->dev = sess->core->dev;\n\tsrc_vq->lock = &sess->lock;\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->ops = &vdec_vb2_ops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->drv_priv = sess;\n\tdst_vq->buf_struct_size = sizeof(struct dummy_buf);\n\tdst_vq->min_buffers_needed = 1;\n\tdst_vq->dev = sess->core->dev;\n\tdst_vq->lock = &sess->lock;\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int vdec_init_ctrls(struct amvdec_session *sess)\n{\n\tstruct v4l2_ctrl_handler *ctrl_handler = &sess->ctrl_handler;\n\tint ret;\n\n\tret = v4l2_ctrl_handler_init(ctrl_handler, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tsess->ctrl_min_buf_capture =\n\t\tv4l2_ctrl_new_std(ctrl_handler, NULL,\n\t\t\t\t  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1,\n\t\t\t\t  1);\n\n\tret = ctrl_handler->error;\n\tif (ret) {\n\t\tv4l2_ctrl_handler_free(ctrl_handler);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vdec_open(struct file *file)\n{\n\tstruct amvdec_core *core = video_drvdata(file);\n\tstruct device *dev = core->dev;\n\tconst struct amvdec_format *formats = core->platform->formats;\n\tstruct amvdec_session *sess;\n\tint ret;\n\n\tsess = kzalloc(sizeof(*sess), GFP_KERNEL);\n\tif (!sess)\n\t\treturn -ENOMEM;\n\n\tsess->core = core;\n\n\tsess->m2m_dev = v4l2_m2m_init(&vdec_m2m_ops);\n\tif (IS_ERR(sess->m2m_dev)) {\n\t\tdev_err(dev, \"Fail to v4l2_m2m_init\\n\");\n\t\tret = PTR_ERR(sess->m2m_dev);\n\t\tgoto err_free_sess;\n\t}\n\n\tsess->m2m_ctx = v4l2_m2m_ctx_init(sess->m2m_dev, sess, m2m_queue_init);\n\tif (IS_ERR(sess->m2m_ctx)) {\n\t\tdev_err(dev, \"Fail to v4l2_m2m_ctx_init\\n\");\n\t\tret = PTR_ERR(sess->m2m_ctx);\n\t\tgoto err_m2m_release;\n\t}\n\n\tret = vdec_init_ctrls(sess);\n\tif (ret)\n\t\tgoto err_m2m_release;\n\n\tsess->pixfmt_cap = formats[0].pixfmts_cap[0];\n\tsess->fmt_out = &formats[0];\n\tsess->width = 1280;\n\tsess->height = 720;\n\tsess->pixelaspect.numerator = 1;\n\tsess->pixelaspect.denominator = 1;\n\tsess->src_buffer_size = SZ_1M;\n\n\tINIT_LIST_HEAD(&sess->timestamps);\n\tINIT_LIST_HEAD(&sess->bufs_recycle);\n\tINIT_WORK(&sess->esparser_queue_work, esparser_queue_all_src);\n\tmutex_init(&sess->lock);\n\tmutex_init(&sess->bufs_recycle_lock);\n\tspin_lock_init(&sess->ts_spinlock);\n\n\tv4l2_fh_init(&sess->fh, core->vdev_dec);\n\tsess->fh.ctrl_handler = &sess->ctrl_handler;\n\tv4l2_fh_add(&sess->fh);\n\tsess->fh.m2m_ctx = sess->m2m_ctx;\n\tfile->private_data = &sess->fh;\n\n\treturn 0;\n\nerr_m2m_release:\n\tv4l2_m2m_release(sess->m2m_dev);\nerr_free_sess:\n\tkfree(sess);\n\treturn ret;\n}\n\nstatic int vdec_close(struct file *file)\n{\n\tstruct amvdec_session *sess =\n\t\tcontainer_of(file->private_data, struct amvdec_session, fh);\n\n\tv4l2_m2m_ctx_release(sess->m2m_ctx);\n\tv4l2_m2m_release(sess->m2m_dev);\n\tv4l2_fh_del(&sess->fh);\n\tv4l2_fh_exit(&sess->fh);\n\n\tmutex_destroy(&sess->lock);\n\tmutex_destroy(&sess->bufs_recycle_lock);\n\n\tkfree(sess);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations vdec_fops = {\n\t.owner = THIS_MODULE,\n\t.open = vdec_open,\n\t.release = vdec_close,\n\t.unlocked_ioctl = video_ioctl2,\n\t.poll = v4l2_m2m_fop_poll,\n\t.mmap = v4l2_m2m_fop_mmap,\n};\n\nstatic irqreturn_t vdec_isr(int irq, void *data)\n{\n\tstruct amvdec_core *core = data;\n\tstruct amvdec_session *sess = core->cur_sess;\n\n\tsess->last_irq_jiffies = get_jiffies_64();\n\n\treturn sess->fmt_out->codec_ops->isr(sess);\n}\n\nstatic irqreturn_t vdec_threaded_isr(int irq, void *data)\n{\n\tstruct amvdec_core *core = data;\n\tstruct amvdec_session *sess = core->cur_sess;\n\n\treturn sess->fmt_out->codec_ops->threaded_isr(sess);\n}\n\nstatic const struct of_device_id vdec_dt_match[] = {\n\t{ .compatible = \"amlogic,gxbb-vdec\",\n\t  .data = &vdec_platform_gxbb },\n\t{ .compatible = \"amlogic,gxm-vdec\",\n\t  .data = &vdec_platform_gxm },\n\t{ .compatible = \"amlogic,gxl-vdec\",\n\t  .data = &vdec_platform_gxl },\n\t{ .compatible = \"amlogic,g12a-vdec\",\n\t  .data = &vdec_platform_g12a },\n\t{ .compatible = \"amlogic,sm1-vdec\",\n\t  .data = &vdec_platform_sm1 },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, vdec_dt_match);\n\nstatic int vdec_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct video_device *vdev;\n\tstruct amvdec_core *core;\n\tconst struct of_device_id *of_id;\n\tint irq;\n\tint ret;\n\n\tcore = devm_kzalloc(dev, sizeof(*core), GFP_KERNEL);\n\tif (!core)\n\t\treturn -ENOMEM;\n\n\tcore->dev = dev;\n\tplatform_set_drvdata(pdev, core);\n\n\tcore->dos_base = devm_platform_ioremap_resource_byname(pdev, \"dos\");\n\tif (IS_ERR(core->dos_base))\n\t\treturn PTR_ERR(core->dos_base);\n\n\tcore->esparser_base = devm_platform_ioremap_resource_byname(pdev, \"esparser\");\n\tif (IS_ERR(core->esparser_base))\n\t\treturn PTR_ERR(core->esparser_base);\n\n\tcore->regmap_ao =\n\t\tsyscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\"amlogic,ao-sysctrl\");\n\tif (IS_ERR(core->regmap_ao)) {\n\t\tdev_err(dev, \"Couldn't regmap AO sysctrl\\n\");\n\t\treturn PTR_ERR(core->regmap_ao);\n\t}\n\n\tcore->canvas = meson_canvas_get(dev);\n\tif (IS_ERR(core->canvas))\n\t\treturn PTR_ERR(core->canvas);\n\n\tof_id = of_match_node(vdec_dt_match, dev->of_node);\n\tcore->platform = of_id->data;\n\n\tif (core->platform->revision == VDEC_REVISION_G12A ||\n\t    core->platform->revision == VDEC_REVISION_SM1) {\n\t\tcore->vdec_hevcf_clk = devm_clk_get(dev, \"vdec_hevcf\");\n\t\tif (IS_ERR(core->vdec_hevcf_clk))\n\t\t\treturn -EPROBE_DEFER;\n\t}\n\n\tcore->dos_parser_clk = devm_clk_get(dev, \"dos_parser\");\n\tif (IS_ERR(core->dos_parser_clk))\n\t\treturn -EPROBE_DEFER;\n\n\tcore->dos_clk = devm_clk_get(dev, \"dos\");\n\tif (IS_ERR(core->dos_clk))\n\t\treturn -EPROBE_DEFER;\n\n\tcore->vdec_1_clk = devm_clk_get(dev, \"vdec_1\");\n\tif (IS_ERR(core->vdec_1_clk))\n\t\treturn -EPROBE_DEFER;\n\n\tcore->vdec_hevc_clk = devm_clk_get(dev, \"vdec_hevc\");\n\tif (IS_ERR(core->vdec_hevc_clk))\n\t\treturn -EPROBE_DEFER;\n\n\tirq = platform_get_irq_byname(pdev, \"vdec\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(core->dev, irq, vdec_isr,\n\t\t\t\t\tvdec_threaded_isr, IRQF_ONESHOT,\n\t\t\t\t\t\"vdec\", core);\n\tif (ret)\n\t\treturn ret;\n\n\tret = esparser_init(pdev, core);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_device_register(dev, &core->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't register v4l2 device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tvdev = video_device_alloc();\n\tif (!vdev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_vdev_release;\n\t}\n\n\tcore->vdev_dec = vdev;\n\tcore->dev_dec = dev;\n\tmutex_init(&core->lock);\n\n\tstrscpy(vdev->name, \"meson-video-decoder\", sizeof(vdev->name));\n\tvdev->release = video_device_release;\n\tvdev->fops = &vdec_fops;\n\tvdev->ioctl_ops = &vdec_ioctl_ops;\n\tvdev->vfl_dir = VFL_DIR_M2M;\n\tvdev->v4l2_dev = &core->v4l2_dev;\n\tvdev->lock = &core->lock;\n\tvdev->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;\n\n\tvideo_set_drvdata(vdev, core);\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed registering video device\\n\");\n\t\tgoto err_vdev_release;\n\t}\n\n\treturn 0;\n\nerr_vdev_release:\n\tvideo_device_release(vdev);\n\tv4l2_device_unregister(&core->v4l2_dev);\n\treturn ret;\n}\n\nstatic void vdec_remove(struct platform_device *pdev)\n{\n\tstruct amvdec_core *core = platform_get_drvdata(pdev);\n\n\tvideo_unregister_device(core->vdev_dec);\n\tv4l2_device_unregister(&core->v4l2_dev);\n}\n\nstatic struct platform_driver meson_vdec_driver = {\n\t.probe = vdec_probe,\n\t.remove_new = vdec_remove,\n\t.driver = {\n\t\t.name = \"meson-vdec\",\n\t\t.of_match_table = vdec_dt_match,\n\t},\n};\nmodule_platform_driver(meson_vdec_driver);\n\nMODULE_DESCRIPTION(\"Meson video decoder driver for GXBB/GXL/GXM/G12/SM1\");\nMODULE_AUTHOR(\"Maxime Jourdan <mjourdan@baylibre.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}