{
  "module_name": "vdec_hevc.c",
  "hash_id": "594c4f5d4c1ab371e0812b3d28d814afede35ad1b5d3cd647a993bbf89020589",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/meson/vdec/vdec_hevc.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/clk.h>\n\n#include \"vdec_1.h\"\n#include \"vdec_helpers.h\"\n#include \"vdec_hevc.h\"\n#include \"hevc_regs.h\"\n#include \"dos_regs.h\"\n\n \n#define AO_RTI_GEN_PWR_SLEEP0\t0xe8\n#define AO_RTI_GEN_PWR_ISO0\t0xec\n\t#define GEN_PWR_VDEC_HEVC (BIT(7) | BIT(6))\n\t#define GEN_PWR_VDEC_HEVC_SM1 (BIT(2))\n\n#define MC_SIZE\t(4096 * 4)\n\nstatic int vdec_hevc_load_firmware(struct amvdec_session *sess,\n\t\t\t\t   const char *fwname)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct device *dev = core->dev_dec;\n\tconst struct firmware *fw;\n\tstatic void *mc_addr;\n\tstatic dma_addr_t mc_addr_map;\n\tint ret;\n\tu32 i = 100;\n\n\tret = request_firmware(&fw, fwname, dev);\n\tif (ret < 0)  {\n\t\tdev_err(dev, \"Unable to request firmware %s\\n\", fwname);\n\t\treturn ret;\n\t}\n\n\tif (fw->size < MC_SIZE) {\n\t\tdev_err(dev, \"Firmware size %zu is too small. Expected %u.\\n\",\n\t\t\tfw->size, MC_SIZE);\n\t\tret = -EINVAL;\n\t\tgoto release_firmware;\n\t}\n\n\tmc_addr = dma_alloc_coherent(core->dev, MC_SIZE, &mc_addr_map,\n\t\t\t\t     GFP_KERNEL);\n\tif (!mc_addr) {\n\t\tret = -ENOMEM;\n\t\tgoto release_firmware;\n\t}\n\n\tmemcpy(mc_addr, fw->data, MC_SIZE);\n\n\tamvdec_write_dos(core, HEVC_MPSR, 0);\n\tamvdec_write_dos(core, HEVC_CPSR, 0);\n\n\tamvdec_write_dos(core, HEVC_IMEM_DMA_ADR, mc_addr_map);\n\tamvdec_write_dos(core, HEVC_IMEM_DMA_COUNT, MC_SIZE / 4);\n\tamvdec_write_dos(core, HEVC_IMEM_DMA_CTRL, (0x8000 | (7 << 16)));\n\n\twhile (i && (readl(core->dos_base + HEVC_IMEM_DMA_CTRL) & 0x8000))\n\t\ti--;\n\n\tif (i == 0) {\n\t\tdev_err(dev, \"Firmware load fail (DMA hang?)\\n\");\n\t\tret = -ENODEV;\n\t}\n\n\tdma_free_coherent(core->dev, MC_SIZE, mc_addr, mc_addr_map);\nrelease_firmware:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic void vdec_hevc_stbuf_init(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\n\tamvdec_write_dos(core, HEVC_STREAM_CONTROL,\n\t\t\t amvdec_read_dos(core, HEVC_STREAM_CONTROL) & ~1);\n\tamvdec_write_dos(core, HEVC_STREAM_START_ADDR, sess->vififo_paddr);\n\tamvdec_write_dos(core, HEVC_STREAM_END_ADDR,\n\t\t\t sess->vififo_paddr + sess->vififo_size);\n\tamvdec_write_dos(core, HEVC_STREAM_RD_PTR, sess->vififo_paddr);\n\tamvdec_write_dos(core, HEVC_STREAM_WR_PTR, sess->vififo_paddr);\n}\n\n \nstatic void vdec_hevc_conf_esparser(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\n\t \n\tamvdec_write_dos(core, DOS_GEN_CTRL0, 3 << 1);\n\tamvdec_write_dos(core, HEVC_STREAM_CONTROL,\n\t\t\t amvdec_read_dos(core, HEVC_STREAM_CONTROL) | BIT(3));\n\tamvdec_write_dos(core, HEVC_STREAM_CONTROL,\n\t\t\t amvdec_read_dos(core, HEVC_STREAM_CONTROL) | 1);\n\tamvdec_write_dos(core, HEVC_STREAM_FIFO_CTL,\n\t\t\t amvdec_read_dos(core, HEVC_STREAM_FIFO_CTL) | BIT(29));\n}\n\nstatic u32 vdec_hevc_vififo_level(struct amvdec_session *sess)\n{\n\treturn readl_relaxed(sess->core->dos_base + HEVC_STREAM_LEVEL);\n}\n\nstatic int vdec_hevc_stop(struct amvdec_session *sess)\n{\n\tstruct amvdec_core *core = sess->core;\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\n\t \n\tamvdec_write_dos(core, HEVC_ASSIST_MBOX1_MASK, 0);\n\t \n\tamvdec_write_dos(core, HEVC_MPSR, 0);\n\n\tif (sess->priv)\n\t\tcodec_ops->stop(sess);\n\n\t \n\tif (core->platform->revision == VDEC_REVISION_SM1)\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_ISO0,\n\t\t\t\t   GEN_PWR_VDEC_HEVC_SM1,\n\t\t\t\t   GEN_PWR_VDEC_HEVC_SM1);\n\telse\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_ISO0,\n\t\t\t\t   0xc00, 0xc00);\n\n\t \n\tamvdec_write_dos(core, DOS_MEM_PD_HEVC, 0xffffffffUL);\n\n\tif (core->platform->revision == VDEC_REVISION_SM1)\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t\t   GEN_PWR_VDEC_HEVC_SM1,\n\t\t\t\t   GEN_PWR_VDEC_HEVC_SM1);\n\telse\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t\t   GEN_PWR_VDEC_HEVC, GEN_PWR_VDEC_HEVC);\n\n\tclk_disable_unprepare(core->vdec_hevc_clk);\n\tif (core->platform->revision == VDEC_REVISION_G12A ||\n\t    core->platform->revision == VDEC_REVISION_SM1)\n\t\tclk_disable_unprepare(core->vdec_hevcf_clk);\n\n\treturn 0;\n}\n\nstatic int vdec_hevc_start(struct amvdec_session *sess)\n{\n\tint ret;\n\tstruct amvdec_core *core = sess->core;\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\n\tif (core->platform->revision == VDEC_REVISION_G12A ||\n\t    core->platform->revision == VDEC_REVISION_SM1) {\n\t\tclk_set_rate(core->vdec_hevcf_clk, 666666666);\n\t\tret = clk_prepare_enable(core->vdec_hevcf_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tclk_set_rate(core->vdec_hevc_clk, 666666666);\n\tret = clk_prepare_enable(core->vdec_hevc_clk);\n\tif (ret) {\n\t\tif (core->platform->revision == VDEC_REVISION_G12A ||\n\t\t    core->platform->revision == VDEC_REVISION_SM1)\n\t\t\tclk_disable_unprepare(core->vdec_hevcf_clk);\n\t\treturn ret;\n\t}\n\n\tif (core->platform->revision == VDEC_REVISION_SM1)\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t\t   GEN_PWR_VDEC_HEVC_SM1, 0);\n\telse\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,\n\t\t\t\t   GEN_PWR_VDEC_HEVC, 0);\n\tusleep_range(10, 20);\n\n\t \n\tamvdec_write_dos(core, DOS_SW_RESET3, 0xffffffff);\n\tamvdec_write_dos(core, DOS_SW_RESET3, 0x00000000);\n\n\tamvdec_write_dos(core, DOS_GCLK_EN3, 0xffffffff);\n\n\t \n\tamvdec_write_dos(core, DOS_MEM_PD_HEVC, 0x00000000);\n\n\t \n\tif (core->platform->revision == VDEC_REVISION_SM1)\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_ISO0,\n\t\t\t\t   GEN_PWR_VDEC_HEVC_SM1, 0);\n\telse\n\t\tregmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_ISO0,\n\t\t\t\t   0xc00, 0);\n\n\tamvdec_write_dos(core, DOS_SW_RESET3, 0xffffffff);\n\tamvdec_write_dos(core, DOS_SW_RESET3, 0x00000000);\n\n\tvdec_hevc_stbuf_init(sess);\n\n\tret = vdec_hevc_load_firmware(sess, sess->fmt_out->firmware_path);\n\tif (ret)\n\t\tgoto stop;\n\n\tret = codec_ops->start(sess);\n\tif (ret)\n\t\tgoto stop;\n\n\tamvdec_write_dos(core, DOS_SW_RESET3, BIT(12) | BIT(11));\n\tamvdec_write_dos(core, DOS_SW_RESET3, 0);\n\tamvdec_read_dos(core, DOS_SW_RESET3);\n\n\tamvdec_write_dos(core, HEVC_MPSR, 1);\n\t \n\tusleep_range(10, 20);\n\n\treturn 0;\n\nstop:\n\tvdec_hevc_stop(sess);\n\treturn ret;\n}\n\nstruct amvdec_ops vdec_hevc_ops = {\n\t.start = vdec_hevc_start,\n\t.stop = vdec_hevc_stop,\n\t.conf_esparser = vdec_hevc_conf_esparser,\n\t.vififo_level = vdec_hevc_vififo_level,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}