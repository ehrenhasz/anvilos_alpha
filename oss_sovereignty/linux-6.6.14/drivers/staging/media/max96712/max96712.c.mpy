{
  "module_name": "max96712.c",
  "hash_id": "7d9249523480dfbd429893c7e4fc1be2261eb57aa49210a141e35bfabcab89f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/max96712/max96712.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/regmap.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define MAX96712_ID 0x20\n\n#define MAX96712_DPLL_FREQ 1000\n\nenum max96712_pattern {\n\tMAX96712_PATTERN_CHECKERBOARD = 0,\n\tMAX96712_PATTERN_GRADIENT,\n};\n\nstruct max96712_priv {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *gpiod_pwdn;\n\n\tbool cphy;\n\tstruct v4l2_mbus_config_mipi_csi2 mipi;\n\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct media_pad pads[1];\n\n\tenum max96712_pattern pattern;\n};\n\nstatic int max96712_read(struct max96712_priv *priv, int reg)\n{\n\tint ret, val;\n\n\tret = regmap_read(priv->regmap, reg, &val);\n\tif (ret) {\n\t\tdev_err(&priv->client->dev, \"read 0x%04x failed\\n\", reg);\n\t\treturn ret;\n\t}\n\n\treturn val;\n}\n\nstatic int max96712_write(struct max96712_priv *priv, unsigned int reg, u8 val)\n{\n\tint ret;\n\n\tret = regmap_write(priv->regmap, reg, val);\n\tif (ret)\n\t\tdev_err(&priv->client->dev, \"write 0x%04x failed\\n\", reg);\n\n\treturn ret;\n}\n\nstatic int max96712_update_bits(struct max96712_priv *priv, unsigned int reg,\n\t\t\t\tu8 mask, u8 val)\n{\n\tint ret;\n\n\tret = regmap_update_bits(priv->regmap, reg, mask, val);\n\tif (ret)\n\t\tdev_err(&priv->client->dev, \"update 0x%04x failed\\n\", reg);\n\n\treturn ret;\n}\n\nstatic int max96712_write_bulk(struct max96712_priv *priv, unsigned int reg,\n\t\t\t       const void *val, size_t val_count)\n{\n\tint ret;\n\n\tret = regmap_bulk_write(priv->regmap, reg, val, val_count);\n\tif (ret)\n\t\tdev_err(&priv->client->dev, \"bulk write 0x%04x failed\\n\", reg);\n\n\treturn ret;\n}\n\nstatic int max96712_write_bulk_value(struct max96712_priv *priv,\n\t\t\t\t     unsigned int reg, unsigned int val,\n\t\t\t\t     size_t val_count)\n{\n\tunsigned int i;\n\tu8 values[4];\n\n\tfor (i = 1; i <= val_count; i++)\n\t\tvalues[i - 1] = (val >> ((val_count - i) * 8)) & 0xff;\n\n\treturn max96712_write_bulk(priv, reg, &values, val_count);\n}\n\nstatic void max96712_reset(struct max96712_priv *priv)\n{\n\tmax96712_update_bits(priv, 0x13, 0x40, 0x40);\n\tmsleep(20);\n}\n\nstatic void max96712_mipi_enable(struct max96712_priv *priv, bool enable)\n{\n\tif (enable) {\n\t\tmax96712_update_bits(priv, 0x40b, 0x02, 0x02);\n\t\tmax96712_update_bits(priv, 0x8a0, 0x80, 0x80);\n\t} else {\n\t\tmax96712_update_bits(priv, 0x8a0, 0x80, 0x00);\n\t\tmax96712_update_bits(priv, 0x40b, 0x02, 0x00);\n\t}\n}\n\nstatic void max96712_mipi_configure(struct max96712_priv *priv)\n{\n\tunsigned int i;\n\tu8 phy5 = 0;\n\n\tmax96712_mipi_enable(priv, false);\n\n\t \n\tmax96712_write(priv, 0x8a0, 0x04);\n\n\t \n\tif (priv->cphy) {\n\t\t \n\t\tmax96712_write(priv, 0x94a, 0xa0);\n\n\t\t \n\t\tmax96712_write(priv, 0x8ad, 0x3f);\n\t\tmax96712_write(priv, 0x8ae, 0x7d);\n\t} else {\n\t\t \n\t\tmax96712_write(priv, 0x94a, 0xc0);\n\t}\n\n\t \n\t \n\tmax96712_write(priv, 0x8a3, 0xe4);\n\n\t \n\tfor (i = 0; i < priv->mipi.num_data_lanes + 1; i++)\n\t\tif (priv->mipi.lane_polarities[i])\n\t\t\tphy5 |= BIT(i == 0 ? 5 : i < 3 ? i - 1 : i);\n\tmax96712_write(priv, 0x8a5, phy5);\n\n\t \n\tmax96712_update_bits(priv, 0x415, 0x3f,\n\t\t\t     ((MAX96712_DPLL_FREQ / 100) & 0x1f) | BIT(5));\n\tmax96712_update_bits(priv, 0x418, 0x3f,\n\t\t\t     ((MAX96712_DPLL_FREQ / 100) & 0x1f) | BIT(5));\n\n\t \n\tmax96712_update_bits(priv, 0x8a2, 0xf0, 0x30);\n}\n\nstatic void max96712_pattern_enable(struct max96712_priv *priv, bool enable)\n{\n\tconst u32 h_active = 1920;\n\tconst u32 h_fp = 88;\n\tconst u32 h_sw = 44;\n\tconst u32 h_bp = 148;\n\tconst u32 h_tot = h_active + h_fp + h_sw + h_bp;\n\n\tconst u32 v_active = 1080;\n\tconst u32 v_fp = 4;\n\tconst u32 v_sw = 5;\n\tconst u32 v_bp = 36;\n\tconst u32 v_tot = v_active + v_fp + v_sw + v_bp;\n\n\tif (!enable) {\n\t\tmax96712_write(priv, 0x1051, 0x00);\n\t\treturn;\n\t}\n\n\t \n\tmax96712_write(priv, 0x0009, 0x01);\n\n\t \n\tmax96712_write_bulk_value(priv, 0x1052, 0, 3);\n\tmax96712_write_bulk_value(priv, 0x1055, v_sw * h_tot, 3);\n\tmax96712_write_bulk_value(priv, 0x1058,\n\t\t\t\t  (v_active + v_fp + + v_bp) * h_tot, 3);\n\tmax96712_write_bulk_value(priv, 0x105b, 0, 3);\n\tmax96712_write_bulk_value(priv, 0x105e, h_sw, 2);\n\tmax96712_write_bulk_value(priv, 0x1060, h_active + h_fp + h_bp, 2);\n\tmax96712_write_bulk_value(priv, 0x1062, v_tot, 2);\n\tmax96712_write_bulk_value(priv, 0x1064,\n\t\t\t\t  h_tot * (v_sw + v_bp) + (h_sw + h_bp), 3);\n\tmax96712_write_bulk_value(priv, 0x1067, h_active, 2);\n\tmax96712_write_bulk_value(priv, 0x1069, h_fp + h_sw + h_bp, 2);\n\tmax96712_write_bulk_value(priv, 0x106b, v_active, 2);\n\n\t \n\tmax96712_write(priv, 0x1050, 0xfb);\n\n\t \n\tif (priv->pattern == MAX96712_PATTERN_CHECKERBOARD) {\n\t\t \n\t\tmax96712_write(priv, 0x1074, 0x3c);\n\t\tmax96712_write(priv, 0x1075, 0x3c);\n\t\tmax96712_write(priv, 0x1076, 0x3c);\n\n\t\t \n\t\tmax96712_write_bulk_value(priv, 0x106e, 0xfecc00, 3);\n\t\tmax96712_write_bulk_value(priv, 0x1071, 0x006aa7, 3);\n\n\t\t \n\t\tmax96712_write(priv, 0x1051, 0x10);\n\t} else {\n\t\t \n\t\tmax96712_write(priv, 0x106d, 0x10);\n\n\t\t \n\t\tmax96712_write(priv, 0x1051, 0x20);\n\t}\n}\n\nstatic int max96712_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct max96712_priv *priv = v4l2_get_subdevdata(sd);\n\n\tif (enable) {\n\t\tmax96712_pattern_enable(priv, true);\n\t\tmax96712_mipi_enable(priv, true);\n\t} else {\n\t\tmax96712_mipi_enable(priv, false);\n\t\tmax96712_pattern_enable(priv, false);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops max96712_video_ops = {\n\t.s_stream = max96712_s_stream,\n};\n\nstatic int max96712_get_pad_format(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_format *format)\n{\n\tformat->format.width = 1920;\n\tformat->format.height = 1080;\n\tformat->format.code = MEDIA_BUS_FMT_RGB888_1X24;\n\tformat->format.field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops max96712_pad_ops = {\n\t.get_fmt = max96712_get_pad_format,\n\t.set_fmt = max96712_get_pad_format,\n};\n\nstatic const struct v4l2_subdev_ops max96712_subdev_ops = {\n\t.video = &max96712_video_ops,\n\t.pad = &max96712_pad_ops,\n};\n\nstatic const char * const max96712_test_pattern[] = {\n\t\"Checkerboard\",\n\t\"Gradient\",\n};\n\nstatic int max96712_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct max96712_priv *priv =\n\t\tcontainer_of(ctrl->handler, struct max96712_priv, ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tpriv->pattern = ctrl->val ?\n\t\t\tMAX96712_PATTERN_GRADIENT :\n\t\t\tMAX96712_PATTERN_CHECKERBOARD;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops max96712_ctrl_ops = {\n\t.s_ctrl = max96712_s_ctrl,\n};\n\nstatic int max96712_v4l2_register(struct max96712_priv *priv)\n{\n\tlong pixel_rate;\n\tint ret;\n\n\tv4l2_i2c_subdev_init(&priv->sd, priv->client, &max96712_subdev_ops);\n\tpriv->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tpriv->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\n\tv4l2_ctrl_handler_init(&priv->ctrl_handler, 2);\n\n\t \n\tpixel_rate = MAX96712_DPLL_FREQ / priv->mipi.num_data_lanes * 1000000;\n\tv4l2_ctrl_new_std(&priv->ctrl_handler, NULL, V4L2_CID_PIXEL_RATE,\n\t\t\t  pixel_rate, pixel_rate, 1, pixel_rate);\n\n\tv4l2_ctrl_new_std_menu_items(&priv->ctrl_handler, &max96712_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(max96712_test_pattern) - 1,\n\t\t\t\t     0, 0, max96712_test_pattern);\n\n\tpriv->sd.ctrl_handler = &priv->ctrl_handler;\n\tret = priv->ctrl_handler.error;\n\tif (ret)\n\t\tgoto error;\n\n\tpriv->pads[0].flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&priv->sd.entity, 1, priv->pads);\n\tif (ret)\n\t\tgoto error;\n\n\tv4l2_set_subdevdata(&priv->sd, priv);\n\n\tret = v4l2_async_register_subdev(&priv->sd);\n\tif (ret < 0) {\n\t\tdev_err(&priv->client->dev, \"Unable to register subdevice\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tv4l2_ctrl_handler_free(&priv->ctrl_handler);\n\n\treturn ret;\n}\n\nstatic int max96712_parse_dt(struct max96712_priv *priv)\n{\n\tstruct fwnode_handle *ep;\n\tstruct v4l2_fwnode_endpoint v4l2_ep = {\n\t\t.bus_type = V4L2_MBUS_UNKNOWN,\n\t};\n\tunsigned int supported_lanes;\n\tint ret;\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(&priv->client->dev), 4,\n\t\t\t\t\t     0, 0);\n\tif (!ep) {\n\t\tdev_err(&priv->client->dev, \"Not connected to subdevice\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(ep, &v4l2_ep);\n\tfwnode_handle_put(ep);\n\tif (ret) {\n\t\tdev_err(&priv->client->dev, \"Could not parse v4l2 endpoint\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (v4l2_ep.bus_type) {\n\tcase V4L2_MBUS_CSI2_DPHY:\n\t\tsupported_lanes = 4;\n\t\tpriv->cphy = false;\n\t\tbreak;\n\tcase V4L2_MBUS_CSI2_CPHY:\n\t\tsupported_lanes = 3;\n\t\tpriv->cphy = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&priv->client->dev, \"Unsupported bus-type %u\\n\",\n\t\t\tv4l2_ep.bus_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (v4l2_ep.bus.mipi_csi2.num_data_lanes != supported_lanes) {\n\t\tdev_err(&priv->client->dev, \"Only %u data lanes supported\\n\",\n\t\t\tsupported_lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->mipi = v4l2_ep.bus.mipi_csi2;\n\n\treturn 0;\n}\n\nstatic const struct regmap_config max96712_i2c_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = 0x1f00,\n};\n\nstatic int max96712_probe(struct i2c_client *client)\n{\n\tstruct max96712_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->client = client;\n\ti2c_set_clientdata(client, priv);\n\n\tpriv->regmap = devm_regmap_init_i2c(client, &max96712_i2c_regmap);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tpriv->gpiod_pwdn = devm_gpiod_get_optional(&client->dev, \"enable\",\n\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->gpiod_pwdn))\n\t\treturn PTR_ERR(priv->gpiod_pwdn);\n\n\tgpiod_set_consumer_name(priv->gpiod_pwdn, \"max96712-pwdn\");\n\tgpiod_set_value_cansleep(priv->gpiod_pwdn, 1);\n\n\tif (priv->gpiod_pwdn)\n\t\tusleep_range(4000, 5000);\n\n\tif (max96712_read(priv, 0x4a) != MAX96712_ID)\n\t\treturn -ENODEV;\n\n\tmax96712_reset(priv);\n\n\tret = max96712_parse_dt(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tmax96712_mipi_configure(priv);\n\n\treturn max96712_v4l2_register(priv);\n}\n\nstatic void max96712_remove(struct i2c_client *client)\n{\n\tstruct max96712_priv *priv = i2c_get_clientdata(client);\n\n\tv4l2_async_unregister_subdev(&priv->sd);\n\n\tgpiod_set_value_cansleep(priv->gpiod_pwdn, 0);\n}\n\nstatic const struct of_device_id max96712_of_table[] = {\n\t{ .compatible = \"maxim,max96712\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, max96712_of_table);\n\nstatic struct i2c_driver max96712_i2c_driver = {\n\t.driver\t= {\n\t\t.name = \"max96712\",\n\t\t.of_match_table\t= of_match_ptr(max96712_of_table),\n\t},\n\t.probe = max96712_probe,\n\t.remove = max96712_remove,\n};\n\nmodule_i2c_driver(max96712_i2c_driver);\n\nMODULE_DESCRIPTION(\"Maxim MAX96712 Quad GMSL2 Deserializer Driver\");\nMODULE_AUTHOR(\"Niklas S\u00f6derlund <niklas.soderlund@ragnatech.se>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}