{
  "module_name": "rkvdec-vp9.c",
  "hash_id": "2708b5cce1476eca272f5f6a2f53b8cb5735a3269314987a02a1a6a5f67ef5c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/rkvdec/rkvdec-vp9.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/vmalloc.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-vp9.h>\n\n#include \"rkvdec.h\"\n#include \"rkvdec-regs.h\"\n\n#define RKVDEC_VP9_PROBE_SIZE\t\t4864\n#define RKVDEC_VP9_COUNT_SIZE\t\t13232\n#define RKVDEC_VP9_MAX_SEGMAP_SIZE\t73728\n\nstruct rkvdec_vp9_intra_mode_probs {\n\tu8 y_mode[105];\n\tu8 uv_mode[23];\n};\n\nstruct rkvdec_vp9_intra_only_frame_probs {\n\tu8 coef_intra[4][2][128];\n\tstruct rkvdec_vp9_intra_mode_probs intra_mode[10];\n};\n\nstruct rkvdec_vp9_inter_frame_probs {\n\tu8 y_mode[4][9];\n\tu8 comp_mode[5];\n\tu8 comp_ref[5];\n\tu8 single_ref[5][2];\n\tu8 inter_mode[7][3];\n\tu8 interp_filter[4][2];\n\tu8 padding0[11];\n\tu8 coef[2][4][2][128];\n\tu8 uv_mode_0_2[3][9];\n\tu8 padding1[5];\n\tu8 uv_mode_3_5[3][9];\n\tu8 padding2[5];\n\tu8 uv_mode_6_8[3][9];\n\tu8 padding3[5];\n\tu8 uv_mode_9[9];\n\tu8 padding4[7];\n\tu8 padding5[16];\n\tstruct {\n\t\tu8 joint[3];\n\t\tu8 sign[2];\n\t\tu8 classes[2][10];\n\t\tu8 class0_bit[2];\n\t\tu8 bits[2][10];\n\t\tu8 class0_fr[2][2][3];\n\t\tu8 fr[2][3];\n\t\tu8 class0_hp[2];\n\t\tu8 hp[2];\n\t} mv;\n};\n\nstruct rkvdec_vp9_probs {\n\tu8 partition[16][3];\n\tu8 pred[3];\n\tu8 tree[7];\n\tu8 skip[3];\n\tu8 tx32[2][3];\n\tu8 tx16[2][2];\n\tu8 tx8[2][1];\n\tu8 is_inter[4];\n\t \n\tu8 padding0[3];\n\tunion {\n\t\tstruct rkvdec_vp9_inter_frame_probs inter;\n\t\tstruct rkvdec_vp9_intra_only_frame_probs intra_only;\n\t};\n\t \n\tu8 padding1[11];\n};\n\n \nstruct rkvdec_vp9_priv_tbl {\n\tstruct rkvdec_vp9_probs probs;\n\tu8 segmap[2][RKVDEC_VP9_MAX_SEGMAP_SIZE];\n};\n\nstruct rkvdec_vp9_refs_counts {\n\tu32 eob[2];\n\tu32 coeff[3];\n};\n\nstruct rkvdec_vp9_inter_frame_symbol_counts {\n\tu32 partition[16][4];\n\tu32 skip[3][2];\n\tu32 inter[4][2];\n\tu32 tx32p[2][4];\n\tu32 tx16p[2][4];\n\tu32 tx8p[2][2];\n\tu32 y_mode[4][10];\n\tu32 uv_mode[10][10];\n\tu32 comp[5][2];\n\tu32 comp_ref[5][2];\n\tu32 single_ref[5][2][2];\n\tu32 mv_mode[7][4];\n\tu32 filter[4][3];\n\tu32 mv_joint[4];\n\tu32 sign[2][2];\n\t \n\tu32 classes[2][11 + 1];\n\tu32 class0[2][2];\n\tu32 bits[2][10][2];\n\tu32 class0_fp[2][2][4];\n\tu32 fp[2][4];\n\tu32 class0_hp[2][2];\n\tu32 hp[2][2];\n\tstruct rkvdec_vp9_refs_counts ref_cnt[2][4][2][6][6];\n};\n\nstruct rkvdec_vp9_intra_frame_symbol_counts {\n\tu32 partition[4][4][4];\n\tu32 skip[3][2];\n\tu32 intra[4][2];\n\tu32 tx32p[2][4];\n\tu32 tx16p[2][4];\n\tu32 tx8p[2][2];\n\tstruct rkvdec_vp9_refs_counts ref_cnt[2][4][2][6][6];\n};\n\nstruct rkvdec_vp9_run {\n\tstruct rkvdec_run base;\n\tconst struct v4l2_ctrl_vp9_frame *decode_params;\n};\n\nstruct rkvdec_vp9_frame_info {\n\tu32 valid : 1;\n\tu32 segmapid : 1;\n\tu32 frame_context_idx : 2;\n\tu32 reference_mode : 2;\n\tu32 tx_mode : 3;\n\tu32 interpolation_filter : 3;\n\tu32 flags;\n\tu64 timestamp;\n\tstruct v4l2_vp9_segmentation seg;\n\tstruct v4l2_vp9_loop_filter lf;\n};\n\nstruct rkvdec_vp9_ctx {\n\tstruct rkvdec_aux_buf priv_tbl;\n\tstruct rkvdec_aux_buf count_tbl;\n\tstruct v4l2_vp9_frame_symbol_counts inter_cnts;\n\tstruct v4l2_vp9_frame_symbol_counts intra_cnts;\n\tstruct v4l2_vp9_frame_context probability_tables;\n\tstruct v4l2_vp9_frame_context frame_context[4];\n\tstruct rkvdec_vp9_frame_info cur;\n\tstruct rkvdec_vp9_frame_info last;\n};\n\nstatic void write_coeff_plane(const u8 coef[6][6][3], u8 *coeff_plane)\n{\n\tunsigned int idx = 0, byte_count = 0;\n\tint k, m, n;\n\tu8 p;\n\n\tfor (k = 0; k < 6; k++) {\n\t\tfor (m = 0; m < 6; m++) {\n\t\t\tfor (n = 0; n < 3; n++) {\n\t\t\t\tp = coef[k][m][n];\n\t\t\t\tcoeff_plane[idx++] = p;\n\t\t\t\tbyte_count++;\n\t\t\t\tif (byte_count == 27) {\n\t\t\t\t\tidx += 5;\n\t\t\t\t\tbyte_count = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void init_intra_only_probs(struct rkvdec_ctx *ctx,\n\t\t\t\t  const struct rkvdec_vp9_run *run)\n{\n\tstruct rkvdec_vp9_ctx *vp9_ctx = ctx->priv;\n\tstruct rkvdec_vp9_priv_tbl *tbl = vp9_ctx->priv_tbl.cpu;\n\tstruct rkvdec_vp9_intra_only_frame_probs *rkprobs;\n\tconst struct v4l2_vp9_frame_context *probs;\n\tunsigned int i, j, k;\n\n\trkprobs = &tbl->probs.intra_only;\n\tprobs = &vp9_ctx->probability_tables;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(probs->coef); i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(probs->coef[0]); j++)\n\t\t\twrite_coeff_plane(probs->coef[i][j][0],\n\t\t\t\t\t  rkprobs->coef_intra[i][j]);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(v4l2_vp9_kf_y_mode_prob); i++) {\n\t\tunsigned int byte_count = 0;\n\t\tint idx = 0;\n\n\t\t \n\t\tfor (j = 0; j < ARRAY_SIZE(v4l2_vp9_kf_y_mode_prob[0]); j++) {\n\t\t\tfor (k = 0; k < ARRAY_SIZE(v4l2_vp9_kf_y_mode_prob[0][0]);\n\t\t\t     k++) {\n\t\t\t\tu8 val = v4l2_vp9_kf_y_mode_prob[i][j][k];\n\n\t\t\t\trkprobs->intra_mode[i].y_mode[idx++] = val;\n\t\t\t\tbyte_count++;\n\t\t\t\tif (byte_count == 27) {\n\t\t\t\t\tbyte_count = 0;\n\t\t\t\t\tidx += 5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < sizeof(v4l2_vp9_kf_uv_mode_prob); ++i) {\n\t\tconst u8 *ptr = (const u8 *)v4l2_vp9_kf_uv_mode_prob;\n\n\t\trkprobs->intra_mode[i / 23].uv_mode[i % 23] = ptr[i];\n\t}\n}\n\nstatic void init_inter_probs(struct rkvdec_ctx *ctx,\n\t\t\t     const struct rkvdec_vp9_run *run)\n{\n\tstruct rkvdec_vp9_ctx *vp9_ctx = ctx->priv;\n\tstruct rkvdec_vp9_priv_tbl *tbl = vp9_ctx->priv_tbl.cpu;\n\tstruct rkvdec_vp9_inter_frame_probs *rkprobs;\n\tconst struct v4l2_vp9_frame_context *probs;\n\tunsigned int i, j, k;\n\n\trkprobs = &tbl->probs.inter;\n\tprobs = &vp9_ctx->probability_tables;\n\n\t \n\n\tmemcpy(rkprobs->y_mode, probs->y_mode, sizeof(rkprobs->y_mode));\n\tmemcpy(rkprobs->comp_mode, probs->comp_mode,\n\t       sizeof(rkprobs->comp_mode));\n\tmemcpy(rkprobs->comp_ref, probs->comp_ref,\n\t       sizeof(rkprobs->comp_ref));\n\tmemcpy(rkprobs->single_ref, probs->single_ref,\n\t       sizeof(rkprobs->single_ref));\n\tmemcpy(rkprobs->inter_mode, probs->inter_mode,\n\t       sizeof(rkprobs->inter_mode));\n\tmemcpy(rkprobs->interp_filter, probs->interp_filter,\n\t       sizeof(rkprobs->interp_filter));\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(probs->coef); i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(probs->coef[0]); j++) {\n\t\t\tfor (k = 0; k < ARRAY_SIZE(probs->coef[0][0]); k++)\n\t\t\t\twrite_coeff_plane(probs->coef[i][j][k],\n\t\t\t\t\t\t  rkprobs->coef[k][i][j]);\n\t\t}\n\t}\n\n\t \n\tmemcpy(rkprobs->uv_mode_0_2, &probs->uv_mode[0],\n\t       sizeof(rkprobs->uv_mode_0_2));\n\tmemcpy(rkprobs->uv_mode_3_5, &probs->uv_mode[3],\n\t       sizeof(rkprobs->uv_mode_3_5));\n\tmemcpy(rkprobs->uv_mode_6_8, &probs->uv_mode[6],\n\t       sizeof(rkprobs->uv_mode_6_8));\n\tmemcpy(rkprobs->uv_mode_9, &probs->uv_mode[9],\n\t       sizeof(rkprobs->uv_mode_9));\n\n\t \n\tmemcpy(rkprobs->mv.joint, probs->mv.joint,\n\t       sizeof(rkprobs->mv.joint));\n\tmemcpy(rkprobs->mv.sign, probs->mv.sign,\n\t       sizeof(rkprobs->mv.sign));\n\tmemcpy(rkprobs->mv.classes, probs->mv.classes,\n\t       sizeof(rkprobs->mv.classes));\n\tmemcpy(rkprobs->mv.class0_bit, probs->mv.class0_bit,\n\t       sizeof(rkprobs->mv.class0_bit));\n\tmemcpy(rkprobs->mv.bits, probs->mv.bits,\n\t       sizeof(rkprobs->mv.bits));\n\tmemcpy(rkprobs->mv.class0_fr, probs->mv.class0_fr,\n\t       sizeof(rkprobs->mv.class0_fr));\n\tmemcpy(rkprobs->mv.fr, probs->mv.fr,\n\t       sizeof(rkprobs->mv.fr));\n\tmemcpy(rkprobs->mv.class0_hp, probs->mv.class0_hp,\n\t       sizeof(rkprobs->mv.class0_hp));\n\tmemcpy(rkprobs->mv.hp, probs->mv.hp,\n\t       sizeof(rkprobs->mv.hp));\n}\n\nstatic void init_probs(struct rkvdec_ctx *ctx,\n\t\t       const struct rkvdec_vp9_run *run)\n{\n\tconst struct v4l2_ctrl_vp9_frame *dec_params;\n\tstruct rkvdec_vp9_ctx *vp9_ctx = ctx->priv;\n\tstruct rkvdec_vp9_priv_tbl *tbl = vp9_ctx->priv_tbl.cpu;\n\tstruct rkvdec_vp9_probs *rkprobs = &tbl->probs;\n\tconst struct v4l2_vp9_segmentation *seg;\n\tconst struct v4l2_vp9_frame_context *probs;\n\tbool intra_only;\n\n\tdec_params = run->decode_params;\n\tprobs = &vp9_ctx->probability_tables;\n\tseg = &dec_params->seg;\n\n\tmemset(rkprobs, 0, sizeof(*rkprobs));\n\n\tintra_only = !!(dec_params->flags &\n\t\t\t(V4L2_VP9_FRAME_FLAG_KEY_FRAME |\n\t\t\t V4L2_VP9_FRAME_FLAG_INTRA_ONLY));\n\n\t \n\tmemcpy(rkprobs->partition,\n\t       intra_only ? v4l2_vp9_kf_partition_probs : probs->partition,\n\t       sizeof(rkprobs->partition));\n\n\tmemcpy(rkprobs->pred, seg->pred_probs, sizeof(rkprobs->pred));\n\tmemcpy(rkprobs->tree, seg->tree_probs, sizeof(rkprobs->tree));\n\tmemcpy(rkprobs->skip, probs->skip, sizeof(rkprobs->skip));\n\tmemcpy(rkprobs->tx32, probs->tx32, sizeof(rkprobs->tx32));\n\tmemcpy(rkprobs->tx16, probs->tx16, sizeof(rkprobs->tx16));\n\tmemcpy(rkprobs->tx8, probs->tx8, sizeof(rkprobs->tx8));\n\tmemcpy(rkprobs->is_inter, probs->is_inter, sizeof(rkprobs->is_inter));\n\n\tif (intra_only)\n\t\tinit_intra_only_probs(ctx, run);\n\telse\n\t\tinit_inter_probs(ctx, run);\n}\n\nstruct rkvdec_vp9_ref_reg {\n\tu32 reg_frm_size;\n\tu32 reg_hor_stride;\n\tu32 reg_y_stride;\n\tu32 reg_yuv_stride;\n\tu32 reg_ref_base;\n};\n\nstatic struct rkvdec_vp9_ref_reg ref_regs[] = {\n\t{\n\t\t.reg_frm_size = RKVDEC_REG_VP9_FRAME_SIZE(0),\n\t\t.reg_hor_stride = RKVDEC_VP9_HOR_VIRSTRIDE(0),\n\t\t.reg_y_stride = RKVDEC_VP9_LAST_FRAME_YSTRIDE,\n\t\t.reg_yuv_stride = RKVDEC_VP9_LAST_FRAME_YUVSTRIDE,\n\t\t.reg_ref_base = RKVDEC_REG_VP9_LAST_FRAME_BASE,\n\t},\n\t{\n\t\t.reg_frm_size = RKVDEC_REG_VP9_FRAME_SIZE(1),\n\t\t.reg_hor_stride = RKVDEC_VP9_HOR_VIRSTRIDE(1),\n\t\t.reg_y_stride = RKVDEC_VP9_GOLDEN_FRAME_YSTRIDE,\n\t\t.reg_yuv_stride = 0,\n\t\t.reg_ref_base = RKVDEC_REG_VP9_GOLDEN_FRAME_BASE,\n\t},\n\t{\n\t\t.reg_frm_size = RKVDEC_REG_VP9_FRAME_SIZE(2),\n\t\t.reg_hor_stride = RKVDEC_VP9_HOR_VIRSTRIDE(2),\n\t\t.reg_y_stride = RKVDEC_VP9_ALTREF_FRAME_YSTRIDE,\n\t\t.reg_yuv_stride = 0,\n\t\t.reg_ref_base = RKVDEC_REG_VP9_ALTREF_FRAME_BASE,\n\t}\n};\n\nstatic struct rkvdec_decoded_buffer *\nget_ref_buf(struct rkvdec_ctx *ctx, struct vb2_v4l2_buffer *dst, u64 timestamp)\n{\n\tstruct v4l2_m2m_ctx *m2m_ctx = ctx->fh.m2m_ctx;\n\tstruct vb2_queue *cap_q = &m2m_ctx->cap_q_ctx.q;\n\tstruct vb2_buffer *buf;\n\n\t \n\tbuf = vb2_find_buffer(cap_q, timestamp);\n\tif (!buf)\n\t\tbuf = &dst->vb2_buf;\n\n\treturn vb2_to_rkvdec_decoded_buf(buf);\n}\n\nstatic dma_addr_t get_mv_base_addr(struct rkvdec_decoded_buffer *buf)\n{\n\tunsigned int aligned_pitch, aligned_height, yuv_len;\n\n\taligned_height = round_up(buf->vp9.height, 64);\n\taligned_pitch = round_up(buf->vp9.width * buf->vp9.bit_depth, 512) / 8;\n\tyuv_len = (aligned_height * aligned_pitch * 3) / 2;\n\n\treturn vb2_dma_contig_plane_dma_addr(&buf->base.vb.vb2_buf, 0) +\n\t       yuv_len;\n}\n\nstatic void config_ref_registers(struct rkvdec_ctx *ctx,\n\t\t\t\t const struct rkvdec_vp9_run *run,\n\t\t\t\t struct rkvdec_decoded_buffer *ref_buf,\n\t\t\t\t struct rkvdec_vp9_ref_reg *ref_reg)\n{\n\tunsigned int aligned_pitch, aligned_height, y_len, yuv_len;\n\tstruct rkvdec_dev *rkvdec = ctx->dev;\n\n\taligned_height = round_up(ref_buf->vp9.height, 64);\n\twritel_relaxed(RKVDEC_VP9_FRAMEWIDTH(ref_buf->vp9.width) |\n\t\t       RKVDEC_VP9_FRAMEHEIGHT(ref_buf->vp9.height),\n\t\t       rkvdec->regs + ref_reg->reg_frm_size);\n\n\twritel_relaxed(vb2_dma_contig_plane_dma_addr(&ref_buf->base.vb.vb2_buf, 0),\n\t\t       rkvdec->regs + ref_reg->reg_ref_base);\n\n\tif (&ref_buf->base.vb == run->base.bufs.dst)\n\t\treturn;\n\n\taligned_pitch = round_up(ref_buf->vp9.width * ref_buf->vp9.bit_depth, 512) / 8;\n\ty_len = aligned_height * aligned_pitch;\n\tyuv_len = (y_len * 3) / 2;\n\n\twritel_relaxed(RKVDEC_HOR_Y_VIRSTRIDE(aligned_pitch / 16) |\n\t\t       RKVDEC_HOR_UV_VIRSTRIDE(aligned_pitch / 16),\n\t\t       rkvdec->regs + ref_reg->reg_hor_stride);\n\twritel_relaxed(RKVDEC_VP9_REF_YSTRIDE(y_len / 16),\n\t\t       rkvdec->regs + ref_reg->reg_y_stride);\n\n\tif (!ref_reg->reg_yuv_stride)\n\t\treturn;\n\n\twritel_relaxed(RKVDEC_VP9_REF_YUVSTRIDE(yuv_len / 16),\n\t\t       rkvdec->regs + ref_reg->reg_yuv_stride);\n}\n\nstatic void config_seg_registers(struct rkvdec_ctx *ctx, unsigned int segid)\n{\n\tstruct rkvdec_vp9_ctx *vp9_ctx = ctx->priv;\n\tconst struct v4l2_vp9_segmentation *seg;\n\tstruct rkvdec_dev *rkvdec = ctx->dev;\n\ts16 feature_val;\n\tint feature_id;\n\tu32 val = 0;\n\n\tseg = vp9_ctx->last.valid ? &vp9_ctx->last.seg : &vp9_ctx->cur.seg;\n\tfeature_id = V4L2_VP9_SEG_LVL_ALT_Q;\n\tif (v4l2_vp9_seg_feat_enabled(seg->feature_enabled, feature_id, segid)) {\n\t\tfeature_val = seg->feature_data[segid][feature_id];\n\t\tval |= RKVDEC_SEGID_FRAME_QP_DELTA_EN(1) |\n\t\t       RKVDEC_SEGID_FRAME_QP_DELTA(feature_val);\n\t}\n\n\tfeature_id = V4L2_VP9_SEG_LVL_ALT_L;\n\tif (v4l2_vp9_seg_feat_enabled(seg->feature_enabled, feature_id, segid)) {\n\t\tfeature_val = seg->feature_data[segid][feature_id];\n\t\tval |= RKVDEC_SEGID_FRAME_LOOPFILTER_VALUE_EN(1) |\n\t\t       RKVDEC_SEGID_FRAME_LOOPFILTER_VALUE(feature_val);\n\t}\n\n\tfeature_id = V4L2_VP9_SEG_LVL_REF_FRAME;\n\tif (v4l2_vp9_seg_feat_enabled(seg->feature_enabled, feature_id, segid)) {\n\t\tfeature_val = seg->feature_data[segid][feature_id];\n\t\tval |= RKVDEC_SEGID_REFERINFO_EN(1) |\n\t\t       RKVDEC_SEGID_REFERINFO(feature_val);\n\t}\n\n\tfeature_id = V4L2_VP9_SEG_LVL_SKIP;\n\tif (v4l2_vp9_seg_feat_enabled(seg->feature_enabled, feature_id, segid))\n\t\tval |= RKVDEC_SEGID_FRAME_SKIP_EN(1);\n\n\tif (!segid &&\n\t    (seg->flags & V4L2_VP9_SEGMENTATION_FLAG_ABS_OR_DELTA_UPDATE))\n\t\tval |= RKVDEC_SEGID_ABS_DELTA(1);\n\n\twritel_relaxed(val, rkvdec->regs + RKVDEC_VP9_SEGID_GRP(segid));\n}\n\nstatic void update_dec_buf_info(struct rkvdec_decoded_buffer *buf,\n\t\t\t\tconst struct v4l2_ctrl_vp9_frame *dec_params)\n{\n\tbuf->vp9.width = dec_params->frame_width_minus_1 + 1;\n\tbuf->vp9.height = dec_params->frame_height_minus_1 + 1;\n\tbuf->vp9.bit_depth = dec_params->bit_depth;\n}\n\nstatic void update_ctx_cur_info(struct rkvdec_vp9_ctx *vp9_ctx,\n\t\t\t\tstruct rkvdec_decoded_buffer *buf,\n\t\t\t\tconst struct v4l2_ctrl_vp9_frame *dec_params)\n{\n\tvp9_ctx->cur.valid = true;\n\tvp9_ctx->cur.reference_mode = dec_params->reference_mode;\n\tvp9_ctx->cur.interpolation_filter = dec_params->interpolation_filter;\n\tvp9_ctx->cur.flags = dec_params->flags;\n\tvp9_ctx->cur.timestamp = buf->base.vb.vb2_buf.timestamp;\n\tvp9_ctx->cur.seg = dec_params->seg;\n\tvp9_ctx->cur.lf = dec_params->lf;\n}\n\nstatic void update_ctx_last_info(struct rkvdec_vp9_ctx *vp9_ctx)\n{\n\tvp9_ctx->last = vp9_ctx->cur;\n}\n\nstatic void config_registers(struct rkvdec_ctx *ctx,\n\t\t\t     const struct rkvdec_vp9_run *run)\n{\n\tunsigned int y_len, uv_len, yuv_len, bit_depth, aligned_height, aligned_pitch, stream_len;\n\tconst struct v4l2_ctrl_vp9_frame *dec_params;\n\tstruct rkvdec_decoded_buffer *ref_bufs[3];\n\tstruct rkvdec_decoded_buffer *dst, *last, *mv_ref;\n\tstruct rkvdec_vp9_ctx *vp9_ctx = ctx->priv;\n\tu32 val, last_frame_info = 0;\n\tconst struct v4l2_vp9_segmentation *seg;\n\tstruct rkvdec_dev *rkvdec = ctx->dev;\n\tdma_addr_t addr;\n\tbool intra_only;\n\tunsigned int i;\n\n\tdec_params = run->decode_params;\n\tdst = vb2_to_rkvdec_decoded_buf(&run->base.bufs.dst->vb2_buf);\n\tref_bufs[0] = get_ref_buf(ctx, &dst->base.vb, dec_params->last_frame_ts);\n\tref_bufs[1] = get_ref_buf(ctx, &dst->base.vb, dec_params->golden_frame_ts);\n\tref_bufs[2] = get_ref_buf(ctx, &dst->base.vb, dec_params->alt_frame_ts);\n\n\tif (vp9_ctx->last.valid)\n\t\tlast = get_ref_buf(ctx, &dst->base.vb, vp9_ctx->last.timestamp);\n\telse\n\t\tlast = dst;\n\n\tupdate_dec_buf_info(dst, dec_params);\n\tupdate_ctx_cur_info(vp9_ctx, dst, dec_params);\n\tseg = &dec_params->seg;\n\n\tintra_only = !!(dec_params->flags &\n\t\t\t(V4L2_VP9_FRAME_FLAG_KEY_FRAME |\n\t\t\t V4L2_VP9_FRAME_FLAG_INTRA_ONLY));\n\n\twritel_relaxed(RKVDEC_MODE(RKVDEC_MODE_VP9),\n\t\t       rkvdec->regs + RKVDEC_REG_SYSCTRL);\n\n\tbit_depth = dec_params->bit_depth;\n\taligned_height = round_up(ctx->decoded_fmt.fmt.pix_mp.height, 64);\n\n\taligned_pitch = round_up(ctx->decoded_fmt.fmt.pix_mp.width *\n\t\t\t\t bit_depth,\n\t\t\t\t 512) / 8;\n\ty_len = aligned_height * aligned_pitch;\n\tuv_len = y_len / 2;\n\tyuv_len = y_len + uv_len;\n\n\twritel_relaxed(RKVDEC_Y_HOR_VIRSTRIDE(aligned_pitch / 16) |\n\t\t       RKVDEC_UV_HOR_VIRSTRIDE(aligned_pitch / 16),\n\t\t       rkvdec->regs + RKVDEC_REG_PICPAR);\n\twritel_relaxed(RKVDEC_Y_VIRSTRIDE(y_len / 16),\n\t\t       rkvdec->regs + RKVDEC_REG_Y_VIRSTRIDE);\n\twritel_relaxed(RKVDEC_YUV_VIRSTRIDE(yuv_len / 16),\n\t\t       rkvdec->regs + RKVDEC_REG_YUV_VIRSTRIDE);\n\n\tstream_len = vb2_get_plane_payload(&run->base.bufs.src->vb2_buf, 0);\n\twritel_relaxed(RKVDEC_STRM_LEN(stream_len),\n\t\t       rkvdec->regs + RKVDEC_REG_STRM_LEN);\n\n\t \n\tif (intra_only)\n\t\tmemset(vp9_ctx->count_tbl.cpu, 0, vp9_ctx->count_tbl.size);\n\n\tvp9_ctx->cur.segmapid = vp9_ctx->last.segmapid;\n\tif (!intra_only &&\n\t    !(dec_params->flags & V4L2_VP9_FRAME_FLAG_ERROR_RESILIENT) &&\n\t    (!(seg->flags & V4L2_VP9_SEGMENTATION_FLAG_ENABLED) ||\n\t     (seg->flags & V4L2_VP9_SEGMENTATION_FLAG_UPDATE_MAP)))\n\t\tvp9_ctx->cur.segmapid++;\n\n\tfor (i = 0; i < ARRAY_SIZE(ref_bufs); i++)\n\t\tconfig_ref_registers(ctx, run, ref_bufs[i], &ref_regs[i]);\n\n\tfor (i = 0; i < 8; i++)\n\t\tconfig_seg_registers(ctx, i);\n\n\twritel_relaxed(RKVDEC_VP9_TX_MODE(vp9_ctx->cur.tx_mode) |\n\t\t       RKVDEC_VP9_FRAME_REF_MODE(dec_params->reference_mode),\n\t\t       rkvdec->regs + RKVDEC_VP9_CPRHEADER_CONFIG);\n\n\tif (!intra_only) {\n\t\tconst struct v4l2_vp9_loop_filter *lf;\n\t\ts8 delta;\n\n\t\tif (vp9_ctx->last.valid)\n\t\t\tlf = &vp9_ctx->last.lf;\n\t\telse\n\t\t\tlf = &vp9_ctx->cur.lf;\n\n\t\tval = 0;\n\t\tfor (i = 0; i < ARRAY_SIZE(lf->ref_deltas); i++) {\n\t\t\tdelta = lf->ref_deltas[i];\n\t\t\tval |= RKVDEC_REF_DELTAS_LASTFRAME(i, delta);\n\t\t}\n\n\t\twritel_relaxed(val,\n\t\t\t       rkvdec->regs + RKVDEC_VP9_REF_DELTAS_LASTFRAME);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(lf->mode_deltas); i++) {\n\t\t\tdelta = lf->mode_deltas[i];\n\t\t\tlast_frame_info |= RKVDEC_MODE_DELTAS_LASTFRAME(i,\n\t\t\t\t\t\t\t\t\tdelta);\n\t\t}\n\t}\n\n\tif (vp9_ctx->last.valid && !intra_only &&\n\t    vp9_ctx->last.seg.flags & V4L2_VP9_SEGMENTATION_FLAG_ENABLED)\n\t\tlast_frame_info |= RKVDEC_SEG_EN_LASTFRAME;\n\n\tif (vp9_ctx->last.valid &&\n\t    vp9_ctx->last.flags & V4L2_VP9_FRAME_FLAG_SHOW_FRAME)\n\t\tlast_frame_info |= RKVDEC_LAST_SHOW_FRAME;\n\n\tif (vp9_ctx->last.valid &&\n\t    vp9_ctx->last.flags &\n\t    (V4L2_VP9_FRAME_FLAG_KEY_FRAME | V4L2_VP9_FRAME_FLAG_INTRA_ONLY))\n\t\tlast_frame_info |= RKVDEC_LAST_INTRA_ONLY;\n\n\tif (vp9_ctx->last.valid &&\n\t    last->vp9.width == dst->vp9.width &&\n\t    last->vp9.height == dst->vp9.height)\n\t\tlast_frame_info |= RKVDEC_LAST_WIDHHEIGHT_EQCUR;\n\n\twritel_relaxed(last_frame_info,\n\t\t       rkvdec->regs + RKVDEC_VP9_INFO_LASTFRAME);\n\n\twritel_relaxed(stream_len - dec_params->compressed_header_size -\n\t\t       dec_params->uncompressed_header_size,\n\t\t       rkvdec->regs + RKVDEC_VP9_LASTTILE_SIZE);\n\n\tfor (i = 0; !intra_only && i < ARRAY_SIZE(ref_bufs); i++) {\n\t\tunsigned int refw = ref_bufs[i]->vp9.width;\n\t\tunsigned int refh = ref_bufs[i]->vp9.height;\n\t\tu32 hscale, vscale;\n\n\t\thscale = (refw << 14) /\tdst->vp9.width;\n\t\tvscale = (refh << 14) / dst->vp9.height;\n\t\twritel_relaxed(RKVDEC_VP9_REF_HOR_SCALE(hscale) |\n\t\t\t       RKVDEC_VP9_REF_VER_SCALE(vscale),\n\t\t\t       rkvdec->regs + RKVDEC_VP9_REF_SCALE(i));\n\t}\n\n\taddr = vb2_dma_contig_plane_dma_addr(&dst->base.vb.vb2_buf, 0);\n\twritel_relaxed(addr, rkvdec->regs + RKVDEC_REG_DECOUT_BASE);\n\taddr = vb2_dma_contig_plane_dma_addr(&run->base.bufs.src->vb2_buf, 0);\n\twritel_relaxed(addr, rkvdec->regs + RKVDEC_REG_STRM_RLC_BASE);\n\twritel_relaxed(vp9_ctx->priv_tbl.dma +\n\t\t       offsetof(struct rkvdec_vp9_priv_tbl, probs),\n\t\t       rkvdec->regs + RKVDEC_REG_CABACTBL_PROB_BASE);\n\twritel_relaxed(vp9_ctx->count_tbl.dma,\n\t\t       rkvdec->regs + RKVDEC_REG_VP9COUNT_BASE);\n\n\twritel_relaxed(vp9_ctx->priv_tbl.dma +\n\t\t       offsetof(struct rkvdec_vp9_priv_tbl, segmap) +\n\t\t       (RKVDEC_VP9_MAX_SEGMAP_SIZE * vp9_ctx->cur.segmapid),\n\t\t       rkvdec->regs + RKVDEC_REG_VP9_SEGIDCUR_BASE);\n\twritel_relaxed(vp9_ctx->priv_tbl.dma +\n\t\t       offsetof(struct rkvdec_vp9_priv_tbl, segmap) +\n\t\t       (RKVDEC_VP9_MAX_SEGMAP_SIZE * (!vp9_ctx->cur.segmapid)),\n\t\t       rkvdec->regs + RKVDEC_REG_VP9_SEGIDLAST_BASE);\n\n\tif (!intra_only &&\n\t    !(dec_params->flags & V4L2_VP9_FRAME_FLAG_ERROR_RESILIENT) &&\n\t    vp9_ctx->last.valid)\n\t\tmv_ref = last;\n\telse\n\t\tmv_ref = dst;\n\n\twritel_relaxed(get_mv_base_addr(mv_ref),\n\t\t       rkvdec->regs + RKVDEC_VP9_REF_COLMV_BASE);\n\n\twritel_relaxed(ctx->decoded_fmt.fmt.pix_mp.width |\n\t\t       (ctx->decoded_fmt.fmt.pix_mp.height << 16),\n\t\t       rkvdec->regs + RKVDEC_REG_PERFORMANCE_CYCLE);\n}\n\nstatic int validate_dec_params(struct rkvdec_ctx *ctx,\n\t\t\t       const struct v4l2_ctrl_vp9_frame *dec_params)\n{\n\tunsigned int aligned_width, aligned_height;\n\n\t \n\tif (dec_params->profile != 0) {\n\t\tdev_err(ctx->dev->dev, \"unsupported profile %d\\n\",\n\t\t\tdec_params->profile);\n\t\treturn -EINVAL;\n\t}\n\n\taligned_width = round_up(dec_params->frame_width_minus_1 + 1, 64);\n\taligned_height = round_up(dec_params->frame_height_minus_1 + 1, 64);\n\n\t \n\tif (aligned_width != ctx->decoded_fmt.fmt.pix_mp.width ||\n\t    aligned_height != ctx->decoded_fmt.fmt.pix_mp.height) {\n\t\tdev_err(ctx->dev->dev,\n\t\t\t\"unexpected bitstream resolution %dx%d\\n\",\n\t\t\tdec_params->frame_width_minus_1 + 1,\n\t\t\tdec_params->frame_height_minus_1 + 1);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rkvdec_vp9_run_preamble(struct rkvdec_ctx *ctx,\n\t\t\t\t   struct rkvdec_vp9_run *run)\n{\n\tconst struct v4l2_ctrl_vp9_frame *dec_params;\n\tconst struct v4l2_ctrl_vp9_compressed_hdr *prob_updates;\n\tstruct rkvdec_vp9_ctx *vp9_ctx = ctx->priv;\n\tstruct v4l2_ctrl *ctrl;\n\tunsigned int fctx_idx;\n\tint ret;\n\n\t \n\trkvdec_run_preamble(ctx, &run->base);\n\n\tctrl = v4l2_ctrl_find(&ctx->ctrl_hdl,\n\t\t\t      V4L2_CID_STATELESS_VP9_FRAME);\n\tif (WARN_ON(!ctrl))\n\t\treturn -EINVAL;\n\tdec_params = ctrl->p_cur.p;\n\n\tret = validate_dec_params(ctx, dec_params);\n\tif (ret)\n\t\treturn ret;\n\n\trun->decode_params = dec_params;\n\n\tctrl = v4l2_ctrl_find(&ctx->ctrl_hdl, V4L2_CID_STATELESS_VP9_COMPRESSED_HDR);\n\tif (WARN_ON(!ctrl))\n\t\treturn -EINVAL;\n\tprob_updates = ctrl->p_cur.p;\n\tvp9_ctx->cur.tx_mode = prob_updates->tx_mode;\n\n\t \n\tfctx_idx = v4l2_vp9_reset_frame_ctx(dec_params, vp9_ctx->frame_context);\n\tvp9_ctx->cur.frame_context_idx = fctx_idx;\n\n\t \n\tvp9_ctx->probability_tables = vp9_ctx->frame_context[fctx_idx];\n\n\t \n\tv4l2_vp9_fw_update_probs(&vp9_ctx->probability_tables, prob_updates, dec_params);\n\n\treturn 0;\n}\n\nstatic int rkvdec_vp9_run(struct rkvdec_ctx *ctx)\n{\n\tstruct rkvdec_dev *rkvdec = ctx->dev;\n\tstruct rkvdec_vp9_run run = { };\n\tint ret;\n\n\tret = rkvdec_vp9_run_preamble(ctx, &run);\n\tif (ret) {\n\t\trkvdec_run_postamble(ctx, &run.base);\n\t\treturn ret;\n\t}\n\n\t \n\tinit_probs(ctx, &run);\n\n\t \n\tconfig_registers(ctx, &run);\n\n\trkvdec_run_postamble(ctx, &run.base);\n\n\tschedule_delayed_work(&rkvdec->watchdog_work, msecs_to_jiffies(2000));\n\n\twritel(1, rkvdec->regs + RKVDEC_REG_PREF_LUMA_CACHE_COMMAND);\n\twritel(1, rkvdec->regs + RKVDEC_REG_PREF_CHR_CACHE_COMMAND);\n\n\twritel(0xe, rkvdec->regs + RKVDEC_REG_STRMD_ERR_EN);\n\t \n\twritel(RKVDEC_INTERRUPT_DEC_E | RKVDEC_CONFIG_DEC_CLK_GATE_E |\n\t       RKVDEC_TIMEOUT_E | RKVDEC_BUF_EMPTY_E,\n\t       rkvdec->regs + RKVDEC_REG_INTERRUPT);\n\n\treturn 0;\n}\n\n#define copy_tx_and_skip(p1, p2)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tmemcpy((p1)->tx8, (p2)->tx8, sizeof((p1)->tx8));\t\\\n\tmemcpy((p1)->tx16, (p2)->tx16, sizeof((p1)->tx16));\t\\\n\tmemcpy((p1)->tx32, (p2)->tx32, sizeof((p1)->tx32));\t\\\n\tmemcpy((p1)->skip, (p2)->skip, sizeof((p1)->skip));\t\\\n} while (0)\n\nstatic void rkvdec_vp9_done(struct rkvdec_ctx *ctx,\n\t\t\t    struct vb2_v4l2_buffer *src_buf,\n\t\t\t    struct vb2_v4l2_buffer *dst_buf,\n\t\t\t    enum vb2_buffer_state result)\n{\n\tstruct rkvdec_vp9_ctx *vp9_ctx = ctx->priv;\n\tunsigned int fctx_idx;\n\n\t \n\tif (result == VB2_BUF_STATE_ERROR)\n\t\tgoto out_update_last;\n\n\t \n\tif (!(vp9_ctx->cur.flags & V4L2_VP9_FRAME_FLAG_REFRESH_FRAME_CTX))\n\t\tgoto out_update_last;\n\n\tfctx_idx = vp9_ctx->cur.frame_context_idx;\n\n\tif (!(vp9_ctx->cur.flags & V4L2_VP9_FRAME_FLAG_PARALLEL_DEC_MODE)) {\n\t\t \n\t\tstruct v4l2_vp9_frame_context *probs = &vp9_ctx->probability_tables;\n\t\tbool frame_is_intra = vp9_ctx->cur.flags &\n\t\t    (V4L2_VP9_FRAME_FLAG_KEY_FRAME | V4L2_VP9_FRAME_FLAG_INTRA_ONLY);\n\t\tstruct tx_and_skip {\n\t\t\tu8 tx8[2][1];\n\t\t\tu8 tx16[2][2];\n\t\t\tu8 tx32[2][3];\n\t\t\tu8 skip[3];\n\t\t} _tx_skip, *tx_skip = &_tx_skip;\n\t\tstruct v4l2_vp9_frame_symbol_counts *counts;\n\n\t\t \n\t\tif (frame_is_intra)\n\t\t\tcopy_tx_and_skip(tx_skip, probs);\n\n\t\t \n\t\t*probs = vp9_ctx->frame_context[fctx_idx];\n\n\t\t \n\t\tif (frame_is_intra)\n\t\t\tcopy_tx_and_skip(probs, tx_skip);\n\n\t\tcounts = frame_is_intra ? &vp9_ctx->intra_cnts : &vp9_ctx->inter_cnts;\n\t\tv4l2_vp9_adapt_coef_probs(probs, counts,\n\t\t\t\t\t  !vp9_ctx->last.valid ||\n\t\t\t\t\t  vp9_ctx->last.flags & V4L2_VP9_FRAME_FLAG_KEY_FRAME,\n\t\t\t\t\t  frame_is_intra);\n\t\tif (!frame_is_intra) {\n\t\t\tconst struct rkvdec_vp9_inter_frame_symbol_counts *inter_cnts;\n\t\t\tu32 classes[2][11];\n\t\t\tint i;\n\n\t\t\tinter_cnts = vp9_ctx->count_tbl.cpu;\n\t\t\tfor (i = 0; i < ARRAY_SIZE(classes); ++i)\n\t\t\t\tmemcpy(classes[i], inter_cnts->classes[i], sizeof(classes[0]));\n\t\t\tcounts->classes = &classes;\n\n\t\t\t \n\t\t\tv4l2_vp9_adapt_noncoef_probs(&vp9_ctx->probability_tables, counts,\n\t\t\t\t\t\t     vp9_ctx->cur.reference_mode,\n\t\t\t\t\t\t     vp9_ctx->cur.interpolation_filter,\n\t\t\t\t\t\t     vp9_ctx->cur.tx_mode, vp9_ctx->cur.flags);\n\t\t}\n\t}\n\n\t \n\tvp9_ctx->frame_context[fctx_idx] = vp9_ctx->probability_tables;\n\nout_update_last:\n\tupdate_ctx_last_info(vp9_ctx);\n}\n\nstatic void rkvdec_init_v4l2_vp9_count_tbl(struct rkvdec_ctx *ctx)\n{\n\tstruct rkvdec_vp9_ctx *vp9_ctx = ctx->priv;\n\tstruct rkvdec_vp9_intra_frame_symbol_counts *intra_cnts = vp9_ctx->count_tbl.cpu;\n\tstruct rkvdec_vp9_inter_frame_symbol_counts *inter_cnts = vp9_ctx->count_tbl.cpu;\n\tint i, j, k, l, m;\n\n\tvp9_ctx->inter_cnts.partition = &inter_cnts->partition;\n\tvp9_ctx->inter_cnts.skip = &inter_cnts->skip;\n\tvp9_ctx->inter_cnts.intra_inter = &inter_cnts->inter;\n\tvp9_ctx->inter_cnts.tx32p = &inter_cnts->tx32p;\n\tvp9_ctx->inter_cnts.tx16p = &inter_cnts->tx16p;\n\tvp9_ctx->inter_cnts.tx8p = &inter_cnts->tx8p;\n\n\tvp9_ctx->intra_cnts.partition = (u32 (*)[16][4])(&intra_cnts->partition);\n\tvp9_ctx->intra_cnts.skip = &intra_cnts->skip;\n\tvp9_ctx->intra_cnts.intra_inter = &intra_cnts->intra;\n\tvp9_ctx->intra_cnts.tx32p = &intra_cnts->tx32p;\n\tvp9_ctx->intra_cnts.tx16p = &intra_cnts->tx16p;\n\tvp9_ctx->intra_cnts.tx8p = &intra_cnts->tx8p;\n\n\tvp9_ctx->inter_cnts.y_mode = &inter_cnts->y_mode;\n\tvp9_ctx->inter_cnts.uv_mode = &inter_cnts->uv_mode;\n\tvp9_ctx->inter_cnts.comp = &inter_cnts->comp;\n\tvp9_ctx->inter_cnts.comp_ref = &inter_cnts->comp_ref;\n\tvp9_ctx->inter_cnts.single_ref = &inter_cnts->single_ref;\n\tvp9_ctx->inter_cnts.mv_mode = &inter_cnts->mv_mode;\n\tvp9_ctx->inter_cnts.filter = &inter_cnts->filter;\n\tvp9_ctx->inter_cnts.mv_joint = &inter_cnts->mv_joint;\n\tvp9_ctx->inter_cnts.sign = &inter_cnts->sign;\n\t \n\tvp9_ctx->inter_cnts.class0 = &inter_cnts->class0;\n\tvp9_ctx->inter_cnts.bits = &inter_cnts->bits;\n\tvp9_ctx->inter_cnts.class0_fp = &inter_cnts->class0_fp;\n\tvp9_ctx->inter_cnts.fp = &inter_cnts->fp;\n\tvp9_ctx->inter_cnts.class0_hp = &inter_cnts->class0_hp;\n\tvp9_ctx->inter_cnts.hp = &inter_cnts->hp;\n\n#define INNERMOST_LOOP \\\n\tdo {\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (m = 0; m < ARRAY_SIZE(vp9_ctx->inter_cnts.coeff[0][0][0][0]); ++m) {\\\n\t\t\tvp9_ctx->inter_cnts.coeff[i][j][k][l][m] =\t\t\t\\\n\t\t\t\t&inter_cnts->ref_cnt[k][i][j][l][m].coeff;\t\t\\\n\t\t\tvp9_ctx->inter_cnts.eob[i][j][k][l][m][0] =\t\t\t\\\n\t\t\t\t&inter_cnts->ref_cnt[k][i][j][l][m].eob[0];\t\t\\\n\t\t\tvp9_ctx->inter_cnts.eob[i][j][k][l][m][1] =\t\t\t\\\n\t\t\t\t&inter_cnts->ref_cnt[k][i][j][l][m].eob[1];\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tvp9_ctx->intra_cnts.coeff[i][j][k][l][m] =\t\t\t\\\n\t\t\t\t&intra_cnts->ref_cnt[k][i][j][l][m].coeff;\t\t\\\n\t\t\tvp9_ctx->intra_cnts.eob[i][j][k][l][m][0] =\t\t\t\\\n\t\t\t\t&intra_cnts->ref_cnt[k][i][j][l][m].eob[0];\t\t\\\n\t\t\tvp9_ctx->intra_cnts.eob[i][j][k][l][m][1] =\t\t\t\\\n\t\t\t\t&intra_cnts->ref_cnt[k][i][j][l][m].eob[1];\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tfor (i = 0; i < ARRAY_SIZE(vp9_ctx->inter_cnts.coeff); ++i)\n\t\tfor (j = 0; j < ARRAY_SIZE(vp9_ctx->inter_cnts.coeff[0]); ++j)\n\t\t\tfor (k = 0; k < ARRAY_SIZE(vp9_ctx->inter_cnts.coeff[0][0]); ++k)\n\t\t\t\tfor (l = 0; l < ARRAY_SIZE(vp9_ctx->inter_cnts.coeff[0][0][0]); ++l)\n\t\t\t\t\tINNERMOST_LOOP;\n#undef INNERMOST_LOOP\n}\n\nstatic int rkvdec_vp9_start(struct rkvdec_ctx *ctx)\n{\n\tstruct rkvdec_dev *rkvdec = ctx->dev;\n\tstruct rkvdec_vp9_priv_tbl *priv_tbl;\n\tstruct rkvdec_vp9_ctx *vp9_ctx;\n\tunsigned char *count_tbl;\n\tint ret;\n\n\tvp9_ctx = kzalloc(sizeof(*vp9_ctx), GFP_KERNEL);\n\tif (!vp9_ctx)\n\t\treturn -ENOMEM;\n\n\tctx->priv = vp9_ctx;\n\n\tBUILD_BUG_ON(sizeof(priv_tbl->probs) % 16);  \n\tpriv_tbl = dma_alloc_coherent(rkvdec->dev, sizeof(*priv_tbl),\n\t\t\t\t      &vp9_ctx->priv_tbl.dma, GFP_KERNEL);\n\tif (!priv_tbl) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_ctx;\n\t}\n\n\tvp9_ctx->priv_tbl.size = sizeof(*priv_tbl);\n\tvp9_ctx->priv_tbl.cpu = priv_tbl;\n\n\tcount_tbl = dma_alloc_coherent(rkvdec->dev, RKVDEC_VP9_COUNT_SIZE,\n\t\t\t\t       &vp9_ctx->count_tbl.dma, GFP_KERNEL);\n\tif (!count_tbl) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_priv_tbl;\n\t}\n\n\tvp9_ctx->count_tbl.size = RKVDEC_VP9_COUNT_SIZE;\n\tvp9_ctx->count_tbl.cpu = count_tbl;\n\trkvdec_init_v4l2_vp9_count_tbl(ctx);\n\n\treturn 0;\n\nerr_free_priv_tbl:\n\tdma_free_coherent(rkvdec->dev, vp9_ctx->priv_tbl.size,\n\t\t\t  vp9_ctx->priv_tbl.cpu, vp9_ctx->priv_tbl.dma);\n\nerr_free_ctx:\n\tkfree(vp9_ctx);\n\treturn ret;\n}\n\nstatic void rkvdec_vp9_stop(struct rkvdec_ctx *ctx)\n{\n\tstruct rkvdec_vp9_ctx *vp9_ctx = ctx->priv;\n\tstruct rkvdec_dev *rkvdec = ctx->dev;\n\n\tdma_free_coherent(rkvdec->dev, vp9_ctx->count_tbl.size,\n\t\t\t  vp9_ctx->count_tbl.cpu, vp9_ctx->count_tbl.dma);\n\tdma_free_coherent(rkvdec->dev, vp9_ctx->priv_tbl.size,\n\t\t\t  vp9_ctx->priv_tbl.cpu, vp9_ctx->priv_tbl.dma);\n\tkfree(vp9_ctx);\n}\n\nstatic int rkvdec_vp9_adjust_fmt(struct rkvdec_ctx *ctx,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *fmt = &f->fmt.pix_mp;\n\n\tfmt->num_planes = 1;\n\tif (!fmt->plane_fmt[0].sizeimage)\n\t\tfmt->plane_fmt[0].sizeimage = fmt->width * fmt->height * 2;\n\treturn 0;\n}\n\nconst struct rkvdec_coded_fmt_ops rkvdec_vp9_fmt_ops = {\n\t.adjust_fmt = rkvdec_vp9_adjust_fmt,\n\t.start = rkvdec_vp9_start,\n\t.stop = rkvdec_vp9_stop,\n\t.run = rkvdec_vp9_run,\n\t.done = rkvdec_vp9_done,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}