{
  "module_name": "rkvdec.c",
  "hash_id": "0bb06a587625935339869030524fbdeff01473e0a14a3d02dad287cf4565c682",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/rkvdec/rkvdec.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/workqueue.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-core.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"rkvdec.h\"\n#include \"rkvdec-regs.h\"\n\nstatic int rkvdec_try_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct rkvdec_ctx *ctx = container_of(ctrl->handler, struct rkvdec_ctx, ctrl_hdl);\n\tconst struct rkvdec_coded_fmt_desc *desc = ctx->coded_fmt_desc;\n\n\tif (desc->ops->try_ctrl)\n\t\treturn desc->ops->try_ctrl(ctx, ctrl);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops rkvdec_ctrl_ops = {\n\t.try_ctrl = rkvdec_try_ctrl,\n};\n\nstatic const struct rkvdec_ctrl_desc rkvdec_h264_ctrl_descs[] = {\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_DECODE_PARAMS,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_SPS,\n\t\t.cfg.ops = &rkvdec_ctrl_ops,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_PPS,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_SCALING_MATRIX,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_DECODE_MODE,\n\t\t.cfg.min = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,\n\t\t.cfg.max = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,\n\t\t.cfg.def = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_H264_START_CODE,\n\t\t.cfg.min = V4L2_STATELESS_H264_START_CODE_ANNEX_B,\n\t\t.cfg.def = V4L2_STATELESS_H264_START_CODE_ANNEX_B,\n\t\t.cfg.max = V4L2_STATELESS_H264_START_CODE_ANNEX_B,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_MPEG_VIDEO_H264_PROFILE,\n\t\t.cfg.min = V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE,\n\t\t.cfg.max = V4L2_MPEG_VIDEO_H264_PROFILE_HIGH,\n\t\t.cfg.menu_skip_mask =\n\t\t\tBIT(V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED),\n\t\t.cfg.def = V4L2_MPEG_VIDEO_H264_PROFILE_MAIN,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_MPEG_VIDEO_H264_LEVEL,\n\t\t.cfg.min = V4L2_MPEG_VIDEO_H264_LEVEL_1_0,\n\t\t.cfg.max = V4L2_MPEG_VIDEO_H264_LEVEL_5_1,\n\t},\n};\n\nstatic const struct rkvdec_ctrls rkvdec_h264_ctrls = {\n\t.ctrls = rkvdec_h264_ctrl_descs,\n\t.num_ctrls = ARRAY_SIZE(rkvdec_h264_ctrl_descs),\n};\n\nstatic const u32 rkvdec_h264_vp9_decoded_fmts[] = {\n\tV4L2_PIX_FMT_NV12,\n};\n\nstatic const struct rkvdec_ctrl_desc rkvdec_vp9_ctrl_descs[] = {\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_VP9_FRAME,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_STATELESS_VP9_COMPRESSED_HDR,\n\t},\n\t{\n\t\t.cfg.id = V4L2_CID_MPEG_VIDEO_VP9_PROFILE,\n\t\t.cfg.min = V4L2_MPEG_VIDEO_VP9_PROFILE_0,\n\t\t.cfg.max = V4L2_MPEG_VIDEO_VP9_PROFILE_0,\n\t\t.cfg.def = V4L2_MPEG_VIDEO_VP9_PROFILE_0,\n\t},\n};\n\nstatic const struct rkvdec_ctrls rkvdec_vp9_ctrls = {\n\t.ctrls = rkvdec_vp9_ctrl_descs,\n\t.num_ctrls = ARRAY_SIZE(rkvdec_vp9_ctrl_descs),\n};\n\nstatic const struct rkvdec_coded_fmt_desc rkvdec_coded_fmts[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_H264_SLICE,\n\t\t.frmsize = {\n\t\t\t.min_width = 48,\n\t\t\t.max_width = 4096,\n\t\t\t.step_width = 16,\n\t\t\t.min_height = 48,\n\t\t\t.max_height = 2560,\n\t\t\t.step_height = 16,\n\t\t},\n\t\t.ctrls = &rkvdec_h264_ctrls,\n\t\t.ops = &rkvdec_h264_fmt_ops,\n\t\t.num_decoded_fmts = ARRAY_SIZE(rkvdec_h264_vp9_decoded_fmts),\n\t\t.decoded_fmts = rkvdec_h264_vp9_decoded_fmts,\n\t\t.subsystem_flags = VB2_V4L2_FL_SUPPORTS_M2M_HOLD_CAPTURE_BUF,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_VP9_FRAME,\n\t\t.frmsize = {\n\t\t\t.min_width = 64,\n\t\t\t.max_width = 4096,\n\t\t\t.step_width = 64,\n\t\t\t.min_height = 64,\n\t\t\t.max_height = 2304,\n\t\t\t.step_height = 64,\n\t\t},\n\t\t.ctrls = &rkvdec_vp9_ctrls,\n\t\t.ops = &rkvdec_vp9_fmt_ops,\n\t\t.num_decoded_fmts = ARRAY_SIZE(rkvdec_h264_vp9_decoded_fmts),\n\t\t.decoded_fmts = rkvdec_h264_vp9_decoded_fmts,\n\t}\n};\n\nstatic const struct rkvdec_coded_fmt_desc *\nrkvdec_find_coded_fmt_desc(u32 fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rkvdec_coded_fmts); i++) {\n\t\tif (rkvdec_coded_fmts[i].fourcc == fourcc)\n\t\t\treturn &rkvdec_coded_fmts[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic void rkvdec_reset_fmt(struct rkvdec_ctx *ctx, struct v4l2_format *f,\n\t\t\t     u32 fourcc)\n{\n\tmemset(f, 0, sizeof(*f));\n\tf->fmt.pix_mp.pixelformat = fourcc;\n\tf->fmt.pix_mp.field = V4L2_FIELD_NONE;\n\tf->fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709;\n\tf->fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tf->fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT;\n\tf->fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT;\n}\n\nstatic void rkvdec_reset_coded_fmt(struct rkvdec_ctx *ctx)\n{\n\tstruct v4l2_format *f = &ctx->coded_fmt;\n\n\tctx->coded_fmt_desc = &rkvdec_coded_fmts[0];\n\trkvdec_reset_fmt(ctx, f, ctx->coded_fmt_desc->fourcc);\n\n\tf->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tf->fmt.pix_mp.width = ctx->coded_fmt_desc->frmsize.min_width;\n\tf->fmt.pix_mp.height = ctx->coded_fmt_desc->frmsize.min_height;\n\n\tif (ctx->coded_fmt_desc->ops->adjust_fmt)\n\t\tctx->coded_fmt_desc->ops->adjust_fmt(ctx, f);\n}\n\nstatic void rkvdec_reset_decoded_fmt(struct rkvdec_ctx *ctx)\n{\n\tstruct v4l2_format *f = &ctx->decoded_fmt;\n\n\trkvdec_reset_fmt(ctx, f, ctx->coded_fmt_desc->decoded_fmts[0]);\n\tf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tv4l2_fill_pixfmt_mp(&f->fmt.pix_mp,\n\t\t\t    ctx->coded_fmt_desc->decoded_fmts[0],\n\t\t\t    ctx->coded_fmt.fmt.pix_mp.width,\n\t\t\t    ctx->coded_fmt.fmt.pix_mp.height);\n\tf->fmt.pix_mp.plane_fmt[0].sizeimage += 128 *\n\t\tDIV_ROUND_UP(f->fmt.pix_mp.width, 16) *\n\t\tDIV_ROUND_UP(f->fmt.pix_mp.height, 16);\n}\n\nstatic int rkvdec_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tconst struct rkvdec_coded_fmt_desc *fmt;\n\n\tif (fsize->index != 0)\n\t\treturn -EINVAL;\n\n\tfmt = rkvdec_find_coded_fmt_desc(fsize->pixel_format);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise = fmt->frmsize;\n\treturn 0;\n}\n\nstatic int rkvdec_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct rkvdec_dev *rkvdec = video_drvdata(file);\n\tstruct video_device *vdev = video_devdata(file);\n\n\tstrscpy(cap->driver, rkvdec->dev->driver->name,\n\t\tsizeof(cap->driver));\n\tstrscpy(cap->card, vdev->name, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"platform:%s\",\n\t\t rkvdec->dev->driver->name);\n\treturn 0;\n}\n\nstatic int rkvdec_try_capture_fmt(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tstruct rkvdec_ctx *ctx = fh_to_rkvdec_ctx(priv);\n\tconst struct rkvdec_coded_fmt_desc *coded_desc;\n\tunsigned int i;\n\n\t \n\tcoded_desc = ctx->coded_fmt_desc;\n\tif (WARN_ON(!coded_desc))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < coded_desc->num_decoded_fmts; i++) {\n\t\tif (coded_desc->decoded_fmts[i] == pix_mp->pixelformat)\n\t\t\tbreak;\n\t}\n\n\tif (i == coded_desc->num_decoded_fmts)\n\t\tpix_mp->pixelformat = coded_desc->decoded_fmts[0];\n\n\t \n\tpix_mp->width = max(pix_mp->width, ctx->coded_fmt.fmt.pix_mp.width);\n\tpix_mp->height = max(pix_mp->height, ctx->coded_fmt.fmt.pix_mp.height);\n\tv4l2_apply_frmsize_constraints(&pix_mp->width,\n\t\t\t\t       &pix_mp->height,\n\t\t\t\t       &coded_desc->frmsize);\n\n\tv4l2_fill_pixfmt_mp(pix_mp, pix_mp->pixelformat,\n\t\t\t    pix_mp->width, pix_mp->height);\n\tpix_mp->plane_fmt[0].sizeimage +=\n\t\t128 *\n\t\tDIV_ROUND_UP(pix_mp->width, 16) *\n\t\tDIV_ROUND_UP(pix_mp->height, 16);\n\tpix_mp->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int rkvdec_try_output_fmt(struct file *file, void *priv,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tstruct rkvdec_ctx *ctx = fh_to_rkvdec_ctx(priv);\n\tconst struct rkvdec_coded_fmt_desc *desc;\n\n\tdesc = rkvdec_find_coded_fmt_desc(pix_mp->pixelformat);\n\tif (!desc) {\n\t\tpix_mp->pixelformat = rkvdec_coded_fmts[0].fourcc;\n\t\tdesc = &rkvdec_coded_fmts[0];\n\t}\n\n\tv4l2_apply_frmsize_constraints(&pix_mp->width,\n\t\t\t\t       &pix_mp->height,\n\t\t\t\t       &desc->frmsize);\n\n\tpix_mp->field = V4L2_FIELD_NONE;\n\t \n\tpix_mp->num_planes = 1;\n\n\tif (desc->ops->adjust_fmt) {\n\t\tint ret;\n\n\t\tret = desc->ops->adjust_fmt(ctx, f);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rkvdec_s_capture_fmt(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct rkvdec_ctx *ctx = fh_to_rkvdec_ctx(priv);\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\t \n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t     V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (vb2_is_busy(vq))\n\t\treturn -EBUSY;\n\n\tret = rkvdec_try_capture_fmt(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->decoded_fmt = *f;\n\treturn 0;\n}\n\nstatic int rkvdec_s_output_fmt(struct file *file, void *priv,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct rkvdec_ctx *ctx = fh_to_rkvdec_ctx(priv);\n\tstruct v4l2_m2m_ctx *m2m_ctx = ctx->fh.m2m_ctx;\n\tconst struct rkvdec_coded_fmt_desc *desc;\n\tstruct v4l2_format *cap_fmt;\n\tstruct vb2_queue *peer_vq, *vq;\n\tint ret;\n\n\t \n\tvq = v4l2_m2m_get_vq(m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\tif (vb2_is_streaming(vq) ||\n\t    (vb2_is_busy(vq) &&\n\t     f->fmt.pix_mp.pixelformat != ctx->coded_fmt.fmt.pix_mp.pixelformat))\n\t\treturn -EBUSY;\n\n\t \n\tpeer_vq = v4l2_m2m_get_vq(m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (vb2_is_busy(peer_vq))\n\t\treturn -EBUSY;\n\n\tret = rkvdec_try_output_fmt(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tdesc = rkvdec_find_coded_fmt_desc(f->fmt.pix_mp.pixelformat);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tctx->coded_fmt_desc = desc;\n\tctx->coded_fmt = *f;\n\n\t \n\trkvdec_reset_decoded_fmt(ctx);\n\n\t \n\tcap_fmt = &ctx->decoded_fmt;\n\tcap_fmt->fmt.pix_mp.colorspace = f->fmt.pix_mp.colorspace;\n\tcap_fmt->fmt.pix_mp.xfer_func = f->fmt.pix_mp.xfer_func;\n\tcap_fmt->fmt.pix_mp.ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;\n\tcap_fmt->fmt.pix_mp.quantization = f->fmt.pix_mp.quantization;\n\n\t \n\tvq->subsystem_flags |= desc->subsystem_flags;\n\n\treturn 0;\n}\n\nstatic int rkvdec_g_output_fmt(struct file *file, void *priv,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct rkvdec_ctx *ctx = fh_to_rkvdec_ctx(priv);\n\n\t*f = ctx->coded_fmt;\n\treturn 0;\n}\n\nstatic int rkvdec_g_capture_fmt(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct rkvdec_ctx *ctx = fh_to_rkvdec_ctx(priv);\n\n\t*f = ctx->decoded_fmt;\n\treturn 0;\n}\n\nstatic int rkvdec_enum_output_fmt(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_fmtdesc *f)\n{\n\tif (f->index >= ARRAY_SIZE(rkvdec_coded_fmts))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = rkvdec_coded_fmts[f->index].fourcc;\n\treturn 0;\n}\n\nstatic int rkvdec_enum_capture_fmt(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tstruct rkvdec_ctx *ctx = fh_to_rkvdec_ctx(priv);\n\n\tif (WARN_ON(!ctx->coded_fmt_desc))\n\t\treturn -EINVAL;\n\n\tif (f->index >= ctx->coded_fmt_desc->num_decoded_fmts)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = ctx->coded_fmt_desc->decoded_fmts[f->index];\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops rkvdec_ioctl_ops = {\n\t.vidioc_querycap = rkvdec_querycap,\n\t.vidioc_enum_framesizes = rkvdec_enum_framesizes,\n\n\t.vidioc_try_fmt_vid_cap_mplane = rkvdec_try_capture_fmt,\n\t.vidioc_try_fmt_vid_out_mplane = rkvdec_try_output_fmt,\n\t.vidioc_s_fmt_vid_out_mplane = rkvdec_s_output_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane = rkvdec_s_capture_fmt,\n\t.vidioc_g_fmt_vid_out_mplane = rkvdec_g_output_fmt,\n\t.vidioc_g_fmt_vid_cap_mplane = rkvdec_g_capture_fmt,\n\t.vidioc_enum_fmt_vid_out = rkvdec_enum_output_fmt,\n\t.vidioc_enum_fmt_vid_cap = rkvdec_enum_capture_fmt,\n\n\t.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\n\t.vidioc_streamon = v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_decoder_cmd = v4l2_m2m_ioctl_stateless_decoder_cmd,\n\t.vidioc_try_decoder_cmd = v4l2_m2m_ioctl_stateless_try_decoder_cmd,\n};\n\nstatic int rkvdec_queue_setup(struct vb2_queue *vq, unsigned int *num_buffers,\n\t\t\t      unsigned int *num_planes, unsigned int sizes[],\n\t\t\t      struct device *alloc_devs[])\n{\n\tstruct rkvdec_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct v4l2_format *f;\n\tunsigned int i;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\tf = &ctx->coded_fmt;\n\telse\n\t\tf = &ctx->decoded_fmt;\n\n\tif (*num_planes) {\n\t\tif (*num_planes != f->fmt.pix_mp.num_planes)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < f->fmt.pix_mp.num_planes; i++) {\n\t\t\tif (sizes[i] < f->fmt.pix_mp.plane_fmt[i].sizeimage)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t*num_planes = f->fmt.pix_mp.num_planes;\n\t\tfor (i = 0; i < f->fmt.pix_mp.num_planes; i++)\n\t\t\tsizes[i] = f->fmt.pix_mp.plane_fmt[i].sizeimage;\n\t}\n\n\treturn 0;\n}\n\nstatic int rkvdec_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct rkvdec_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct v4l2_format *f;\n\tunsigned int i;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\tf = &ctx->coded_fmt;\n\telse\n\t\tf = &ctx->decoded_fmt;\n\n\tfor (i = 0; i < f->fmt.pix_mp.num_planes; ++i) {\n\t\tu32 sizeimage = f->fmt.pix_mp.plane_fmt[i].sizeimage;\n\n\t\tif (vb2_plane_size(vb, i) < sizeimage)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (V4L2_TYPE_IS_CAPTURE(vq->type))\n\t\tvb2_set_plane_payload(vb, 0, f->fmt.pix_mp.plane_fmt[0].sizeimage);\n\n\treturn 0;\n}\n\nstatic void rkvdec_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct rkvdec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic int rkvdec_buf_out_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\treturn 0;\n}\n\nstatic void rkvdec_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct rkvdec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &ctx->ctrl_hdl);\n}\n\nstatic int rkvdec_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct rkvdec_ctx *ctx = vb2_get_drv_priv(q);\n\tconst struct rkvdec_coded_fmt_desc *desc;\n\tint ret;\n\n\tif (V4L2_TYPE_IS_CAPTURE(q->type))\n\t\treturn 0;\n\n\tdesc = ctx->coded_fmt_desc;\n\tif (WARN_ON(!desc))\n\t\treturn -EINVAL;\n\n\tif (desc->ops->start) {\n\t\tret = desc->ops->start(ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rkvdec_queue_cleanup(struct vb2_queue *vq, u32 state)\n{\n\tstruct rkvdec_ctx *ctx = vb2_get_drv_priv(vq);\n\n\twhile (true) {\n\t\tstruct vb2_v4l2_buffer *vbuf;\n\n\t\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\t\tif (!vbuf)\n\t\t\tbreak;\n\n\t\tv4l2_ctrl_request_complete(vbuf->vb2_buf.req_obj.req,\n\t\t\t\t\t   &ctx->ctrl_hdl);\n\t\tv4l2_m2m_buf_done(vbuf, state);\n\t}\n}\n\nstatic void rkvdec_stop_streaming(struct vb2_queue *q)\n{\n\tstruct rkvdec_ctx *ctx = vb2_get_drv_priv(q);\n\n\tif (V4L2_TYPE_IS_OUTPUT(q->type)) {\n\t\tconst struct rkvdec_coded_fmt_desc *desc = ctx->coded_fmt_desc;\n\n\t\tif (WARN_ON(!desc))\n\t\t\treturn;\n\n\t\tif (desc->ops->stop)\n\t\t\tdesc->ops->stop(ctx);\n\t}\n\n\trkvdec_queue_cleanup(q, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct vb2_ops rkvdec_queue_ops = {\n\t.queue_setup = rkvdec_queue_setup,\n\t.buf_prepare = rkvdec_buf_prepare,\n\t.buf_queue = rkvdec_buf_queue,\n\t.buf_out_validate = rkvdec_buf_out_validate,\n\t.buf_request_complete = rkvdec_buf_request_complete,\n\t.start_streaming = rkvdec_start_streaming,\n\t.stop_streaming = rkvdec_stop_streaming,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n\nstatic int rkvdec_request_validate(struct media_request *req)\n{\n\tunsigned int count;\n\n\tcount = vb2_request_buffer_cnt(req);\n\tif (!count)\n\t\treturn -ENOENT;\n\telse if (count > 1)\n\t\treturn -EINVAL;\n\n\treturn vb2_request_validate(req);\n}\n\nstatic const struct media_device_ops rkvdec_media_ops = {\n\t.req_validate = rkvdec_request_validate,\n\t.req_queue = v4l2_m2m_request_queue,\n};\n\nstatic void rkvdec_job_finish_no_pm(struct rkvdec_ctx *ctx,\n\t\t\t\t    enum vb2_buffer_state result)\n{\n\tif (ctx->coded_fmt_desc->ops->done) {\n\t\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\n\t\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\t\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\t\tctx->coded_fmt_desc->ops->done(ctx, src_buf, dst_buf, result);\n\t}\n\n\tv4l2_m2m_buf_done_and_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx,\n\t\t\t\t\t result);\n}\n\nstatic void rkvdec_job_finish(struct rkvdec_ctx *ctx,\n\t\t\t      enum vb2_buffer_state result)\n{\n\tstruct rkvdec_dev *rkvdec = ctx->dev;\n\n\tpm_runtime_mark_last_busy(rkvdec->dev);\n\tpm_runtime_put_autosuspend(rkvdec->dev);\n\trkvdec_job_finish_no_pm(ctx, result);\n}\n\nvoid rkvdec_run_preamble(struct rkvdec_ctx *ctx, struct rkvdec_run *run)\n{\n\tstruct media_request *src_req;\n\n\tmemset(run, 0, sizeof(*run));\n\n\trun->bufs.src = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\trun->bufs.dst = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\t \n\tsrc_req = run->bufs.src->vb2_buf.req_obj.req;\n\tif (src_req)\n\t\tv4l2_ctrl_request_setup(src_req, &ctx->ctrl_hdl);\n\n\tv4l2_m2m_buf_copy_metadata(run->bufs.src, run->bufs.dst, true);\n}\n\nvoid rkvdec_run_postamble(struct rkvdec_ctx *ctx, struct rkvdec_run *run)\n{\n\tstruct media_request *src_req = run->bufs.src->vb2_buf.req_obj.req;\n\n\tif (src_req)\n\t\tv4l2_ctrl_request_complete(src_req, &ctx->ctrl_hdl);\n}\n\nstatic void rkvdec_device_run(void *priv)\n{\n\tstruct rkvdec_ctx *ctx = priv;\n\tstruct rkvdec_dev *rkvdec = ctx->dev;\n\tconst struct rkvdec_coded_fmt_desc *desc = ctx->coded_fmt_desc;\n\tint ret;\n\n\tif (WARN_ON(!desc))\n\t\treturn;\n\n\tret = pm_runtime_resume_and_get(rkvdec->dev);\n\tif (ret < 0) {\n\t\trkvdec_job_finish_no_pm(ctx, VB2_BUF_STATE_ERROR);\n\t\treturn;\n\t}\n\n\tret = desc->ops->run(ctx);\n\tif (ret)\n\t\trkvdec_job_finish(ctx, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct v4l2_m2m_ops rkvdec_m2m_ops = {\n\t.device_run = rkvdec_device_run,\n};\n\nstatic int rkvdec_queue_init(void *priv,\n\t\t\t     struct vb2_queue *src_vq,\n\t\t\t     struct vb2_queue *dst_vq)\n{\n\tstruct rkvdec_ctx *ctx = priv;\n\tstruct rkvdec_dev *rkvdec = ctx->dev;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->ops = &rkvdec_queue_ops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\n\t \n\tsrc_vq->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES |\n\t\t\t    DMA_ATTR_NO_KERNEL_MAPPING;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &rkvdec->vdev_lock;\n\tsrc_vq->dev = rkvdec->v4l2_dev.dev;\n\tsrc_vq->supports_requests = true;\n\tsrc_vq->requires_requests = true;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->bidirectional = true;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES |\n\t\t\t    DMA_ATTR_NO_KERNEL_MAPPING;\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->ops = &rkvdec_queue_ops;\n\tdst_vq->buf_struct_size = sizeof(struct rkvdec_decoded_buffer);\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &rkvdec->vdev_lock;\n\tdst_vq->dev = rkvdec->v4l2_dev.dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int rkvdec_add_ctrls(struct rkvdec_ctx *ctx,\n\t\t\t    const struct rkvdec_ctrls *ctrls)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ctrls->num_ctrls; i++) {\n\t\tconst struct v4l2_ctrl_config *cfg = &ctrls->ctrls[i].cfg;\n\n\t\tv4l2_ctrl_new_custom(&ctx->ctrl_hdl, cfg, ctx);\n\t\tif (ctx->ctrl_hdl.error)\n\t\t\treturn ctx->ctrl_hdl.error;\n\t}\n\n\treturn 0;\n}\n\nstatic int rkvdec_init_ctrls(struct rkvdec_ctx *ctx)\n{\n\tunsigned int i, nctrls = 0;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(rkvdec_coded_fmts); i++)\n\t\tnctrls += rkvdec_coded_fmts[i].ctrls->num_ctrls;\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_hdl, nctrls);\n\n\tfor (i = 0; i < ARRAY_SIZE(rkvdec_coded_fmts); i++) {\n\t\tret = rkvdec_add_ctrls(ctx, rkvdec_coded_fmts[i].ctrls);\n\t\tif (ret)\n\t\t\tgoto err_free_handler;\n\t}\n\n\tret = v4l2_ctrl_handler_setup(&ctx->ctrl_hdl);\n\tif (ret)\n\t\tgoto err_free_handler;\n\n\tctx->fh.ctrl_handler = &ctx->ctrl_hdl;\n\treturn 0;\n\nerr_free_handler:\n\tv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\n\treturn ret;\n}\n\nstatic int rkvdec_open(struct file *filp)\n{\n\tstruct rkvdec_dev *rkvdec = video_drvdata(filp);\n\tstruct rkvdec_ctx *ctx;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = rkvdec;\n\trkvdec_reset_coded_fmt(ctx);\n\trkvdec_reset_decoded_fmt(ctx);\n\tv4l2_fh_init(&ctx->fh, video_devdata(filp));\n\n\tret = rkvdec_init_ctrls(ctx);\n\tif (ret)\n\t\tgoto err_free_ctx;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(rkvdec->m2m_dev, ctx,\n\t\t\t\t\t    rkvdec_queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto err_cleanup_ctrls;\n\t}\n\n\tfilp->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\treturn 0;\n\nerr_cleanup_ctrls:\n\tv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\n\nerr_free_ctx:\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic int rkvdec_release(struct file *filp)\n{\n\tstruct rkvdec_ctx *ctx = fh_to_rkvdec_ctx(filp->private_data);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations rkvdec_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rkvdec_open,\n\t.release = rkvdec_release,\n\t.poll = v4l2_m2m_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap = v4l2_m2m_fop_mmap,\n};\n\nstatic int rkvdec_v4l2_init(struct rkvdec_dev *rkvdec)\n{\n\tint ret;\n\n\tret = v4l2_device_register(rkvdec->dev, &rkvdec->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(rkvdec->dev, \"Failed to register V4L2 device\\n\");\n\t\treturn ret;\n\t}\n\n\trkvdec->m2m_dev = v4l2_m2m_init(&rkvdec_m2m_ops);\n\tif (IS_ERR(rkvdec->m2m_dev)) {\n\t\tv4l2_err(&rkvdec->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(rkvdec->m2m_dev);\n\t\tgoto err_unregister_v4l2;\n\t}\n\n\trkvdec->mdev.dev = rkvdec->dev;\n\tstrscpy(rkvdec->mdev.model, \"rkvdec\", sizeof(rkvdec->mdev.model));\n\tstrscpy(rkvdec->mdev.bus_info, \"platform:rkvdec\",\n\t\tsizeof(rkvdec->mdev.bus_info));\n\tmedia_device_init(&rkvdec->mdev);\n\trkvdec->mdev.ops = &rkvdec_media_ops;\n\trkvdec->v4l2_dev.mdev = &rkvdec->mdev;\n\n\trkvdec->vdev.lock = &rkvdec->vdev_lock;\n\trkvdec->vdev.v4l2_dev = &rkvdec->v4l2_dev;\n\trkvdec->vdev.fops = &rkvdec_fops;\n\trkvdec->vdev.release = video_device_release_empty;\n\trkvdec->vdev.vfl_dir = VFL_DIR_M2M;\n\trkvdec->vdev.device_caps = V4L2_CAP_STREAMING |\n\t\t\t\t   V4L2_CAP_VIDEO_M2M_MPLANE;\n\trkvdec->vdev.ioctl_ops = &rkvdec_ioctl_ops;\n\tvideo_set_drvdata(&rkvdec->vdev, rkvdec);\n\tstrscpy(rkvdec->vdev.name, \"rkvdec\", sizeof(rkvdec->vdev.name));\n\n\tret = video_register_device(&rkvdec->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tv4l2_err(&rkvdec->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto err_cleanup_mc;\n\t}\n\n\tret = v4l2_m2m_register_media_controller(rkvdec->m2m_dev, &rkvdec->vdev,\n\t\t\t\t\t\t MEDIA_ENT_F_PROC_VIDEO_DECODER);\n\tif (ret) {\n\t\tv4l2_err(&rkvdec->v4l2_dev,\n\t\t\t \"Failed to initialize V4L2 M2M media controller\\n\");\n\t\tgoto err_unregister_vdev;\n\t}\n\n\tret = media_device_register(&rkvdec->mdev);\n\tif (ret) {\n\t\tv4l2_err(&rkvdec->v4l2_dev, \"Failed to register media device\\n\");\n\t\tgoto err_unregister_mc;\n\t}\n\n\treturn 0;\n\nerr_unregister_mc:\n\tv4l2_m2m_unregister_media_controller(rkvdec->m2m_dev);\n\nerr_unregister_vdev:\n\tvideo_unregister_device(&rkvdec->vdev);\n\nerr_cleanup_mc:\n\tmedia_device_cleanup(&rkvdec->mdev);\n\tv4l2_m2m_release(rkvdec->m2m_dev);\n\nerr_unregister_v4l2:\n\tv4l2_device_unregister(&rkvdec->v4l2_dev);\n\treturn ret;\n}\n\nstatic void rkvdec_v4l2_cleanup(struct rkvdec_dev *rkvdec)\n{\n\tmedia_device_unregister(&rkvdec->mdev);\n\tv4l2_m2m_unregister_media_controller(rkvdec->m2m_dev);\n\tvideo_unregister_device(&rkvdec->vdev);\n\tmedia_device_cleanup(&rkvdec->mdev);\n\tv4l2_m2m_release(rkvdec->m2m_dev);\n\tv4l2_device_unregister(&rkvdec->v4l2_dev);\n}\n\nstatic irqreturn_t rkvdec_irq_handler(int irq, void *priv)\n{\n\tstruct rkvdec_dev *rkvdec = priv;\n\tenum vb2_buffer_state state;\n\tu32 status;\n\n\tstatus = readl(rkvdec->regs + RKVDEC_REG_INTERRUPT);\n\tstate = (status & RKVDEC_RDY_STA) ?\n\t\tVB2_BUF_STATE_DONE : VB2_BUF_STATE_ERROR;\n\n\twritel(0, rkvdec->regs + RKVDEC_REG_INTERRUPT);\n\tif (cancel_delayed_work(&rkvdec->watchdog_work)) {\n\t\tstruct rkvdec_ctx *ctx;\n\n\t\tctx = v4l2_m2m_get_curr_priv(rkvdec->m2m_dev);\n\t\trkvdec_job_finish(ctx, state);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rkvdec_watchdog_func(struct work_struct *work)\n{\n\tstruct rkvdec_dev *rkvdec;\n\tstruct rkvdec_ctx *ctx;\n\n\trkvdec = container_of(to_delayed_work(work), struct rkvdec_dev,\n\t\t\t      watchdog_work);\n\tctx = v4l2_m2m_get_curr_priv(rkvdec->m2m_dev);\n\tif (ctx) {\n\t\tdev_err(rkvdec->dev, \"Frame processing timed out!\\n\");\n\t\twritel(RKVDEC_IRQ_DIS, rkvdec->regs + RKVDEC_REG_INTERRUPT);\n\t\twritel(0, rkvdec->regs + RKVDEC_REG_SYSCTRL);\n\t\trkvdec_job_finish(ctx, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic const struct of_device_id of_rkvdec_match[] = {\n\t{ .compatible = \"rockchip,rk3399-vdec\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_rkvdec_match);\n\nstatic const char * const rkvdec_clk_names[] = {\n\t\"axi\", \"ahb\", \"cabac\", \"core\"\n};\n\nstatic int rkvdec_probe(struct platform_device *pdev)\n{\n\tstruct rkvdec_dev *rkvdec;\n\tunsigned int i;\n\tint ret, irq;\n\n\trkvdec = devm_kzalloc(&pdev->dev, sizeof(*rkvdec), GFP_KERNEL);\n\tif (!rkvdec)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, rkvdec);\n\trkvdec->dev = &pdev->dev;\n\tmutex_init(&rkvdec->vdev_lock);\n\tINIT_DELAYED_WORK(&rkvdec->watchdog_work, rkvdec_watchdog_func);\n\n\trkvdec->clocks = devm_kcalloc(&pdev->dev, ARRAY_SIZE(rkvdec_clk_names),\n\t\t\t\t      sizeof(*rkvdec->clocks), GFP_KERNEL);\n\tif (!rkvdec->clocks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(rkvdec_clk_names); i++)\n\t\trkvdec->clocks[i].id = rkvdec_clk_names[i];\n\n\tret = devm_clk_bulk_get(&pdev->dev, ARRAY_SIZE(rkvdec_clk_names),\n\t\t\t\trkvdec->clocks);\n\tif (ret)\n\t\treturn ret;\n\n\trkvdec->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rkvdec->regs))\n\t\treturn PTR_ERR(rkvdec->regs);\n\n\tret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not set DMA coherent mask.\\n\");\n\t\treturn ret;\n\t}\n\n\tvb2_dma_contig_set_max_seg_size(&pdev->dev, DMA_BIT_MASK(32));\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq <= 0)\n\t\treturn -ENXIO;\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\trkvdec_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(&pdev->dev), rkvdec);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not request vdec IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 100);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = rkvdec_v4l2_init(rkvdec);\n\tif (ret)\n\t\tgoto err_disable_runtime_pm;\n\n\treturn 0;\n\nerr_disable_runtime_pm:\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic void rkvdec_remove(struct platform_device *pdev)\n{\n\tstruct rkvdec_dev *rkvdec = platform_get_drvdata(pdev);\n\n\tcancel_delayed_work_sync(&rkvdec->watchdog_work);\n\n\trkvdec_v4l2_cleanup(rkvdec);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n}\n\n#ifdef CONFIG_PM\nstatic int rkvdec_runtime_resume(struct device *dev)\n{\n\tstruct rkvdec_dev *rkvdec = dev_get_drvdata(dev);\n\n\treturn clk_bulk_prepare_enable(ARRAY_SIZE(rkvdec_clk_names),\n\t\t\t\t       rkvdec->clocks);\n}\n\nstatic int rkvdec_runtime_suspend(struct device *dev)\n{\n\tstruct rkvdec_dev *rkvdec = dev_get_drvdata(dev);\n\n\tclk_bulk_disable_unprepare(ARRAY_SIZE(rkvdec_clk_names),\n\t\t\t\t   rkvdec->clocks);\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops rkvdec_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(rkvdec_runtime_suspend, rkvdec_runtime_resume, NULL)\n};\n\nstatic struct platform_driver rkvdec_driver = {\n\t.probe = rkvdec_probe,\n\t.remove_new = rkvdec_remove,\n\t.driver = {\n\t\t   .name = \"rkvdec\",\n\t\t   .of_match_table = of_rkvdec_match,\n\t\t   .pm = &rkvdec_pm_ops,\n\t},\n};\nmodule_platform_driver(rkvdec_driver);\n\nMODULE_AUTHOR(\"Boris Brezillon <boris.brezillon@collabora.com>\");\nMODULE_DESCRIPTION(\"Rockchip Video Decoder driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}