{
  "module_name": "av7110_av.c",
  "hash_id": "adf43c75275fdb59ce4765a5c24ff9e5ad73feaf07783a38b95530caba23a556",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/av7110/av7110_av.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n\n#include \"av7110.h\"\n#include \"av7110_hw.h\"\n#include \"av7110_av.h\"\n#include \"av7110_ipack.h\"\n\n \n#define PROG_STREAM_MAP  0xBC\n#define PRIVATE_STREAM1  0xBD\n#define PADDING_STREAM\t 0xBE\n#define PRIVATE_STREAM2  0xBF\n#define AUDIO_STREAM_S\t 0xC0\n#define AUDIO_STREAM_E\t 0xDF\n#define VIDEO_STREAM_S\t 0xE0\n#define VIDEO_STREAM_E\t 0xEF\n#define ECM_STREAM\t 0xF0\n#define EMM_STREAM\t 0xF1\n#define DSM_CC_STREAM\t 0xF2\n#define ISO13522_STREAM  0xF3\n#define PROG_STREAM_DIR  0xFF\n\n#define PTS_DTS_FLAGS\t 0xC0\n\n\n#define PTS_ONLY\t 0x80\n#define PTS_DTS\t\t 0xC0\n#define TS_SIZE\t\t 188\n#define TRANS_ERROR\t 0x80\n#define PAY_START\t 0x40\n#define TRANS_PRIO\t 0x20\n#define PID_MASK_HI\t 0x1F\n\n#define TRANS_SCRMBL1\t 0x80\n#define TRANS_SCRMBL2\t 0x40\n#define ADAPT_FIELD\t 0x20\n#define PAYLOAD\t\t 0x10\n#define COUNT_MASK\t 0x0F\n\n\n#define DISCON_IND\t 0x80\n#define RAND_ACC_IND\t 0x40\n#define ES_PRI_IND\t 0x20\n#define PCR_FLAG\t 0x10\n#define OPCR_FLAG\t 0x08\n#define SPLICE_FLAG\t 0x04\n#define TRANS_PRIV\t 0x02\n#define ADAP_EXT_FLAG\t 0x01\n\n\n#define LTW_FLAG\t 0x80\n#define PIECE_RATE\t 0x40\n#define SEAM_SPLICE\t 0x20\n\n\nstatic void p_to_t(u8 const *buf, long int length, u16 pid,\n\t\t   u8 *counter, struct dvb_demux_feed *feed);\nstatic int write_ts_to_decoder(struct av7110 *av7110, int type, const u8 *buf, size_t len);\n\n\nint av7110_record_cb(struct dvb_filter_pes2ts *p2t, u8 *buf, size_t len)\n{\n\tstruct dvb_demux_feed *dvbdmxfeed = p2t->priv;\n\n\tif (!(dvbdmxfeed->ts_type & TS_PACKET))\n\t\treturn 0;\n\tif (buf[3] == 0xe0)\t \n\t\tbuf[4] = buf[5] = 0;\n\tif (dvbdmxfeed->ts_type & TS_PAYLOAD_ONLY)\n\t\treturn dvbdmxfeed->cb.ts(buf, len, NULL, 0,\n\t\t\t\t\t &dvbdmxfeed->feed.ts, NULL);\n\telse\n\t\treturn dvb_filter_pes2ts(p2t, buf, len, 1);\n}\n\nstatic int dvb_filter_pes2ts_cb(void *priv, unsigned char *data)\n{\n\tstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) priv;\n\n\tdvbdmxfeed->cb.ts(data, 188, NULL, 0,\n\t\t\t  &dvbdmxfeed->feed.ts, NULL);\n\treturn 0;\n}\n\nint av7110_av_start_record(struct av7110 *av7110, int av,\n\t\t\t   struct dvb_demux_feed *dvbdmxfeed)\n{\n\tint ret = 0;\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\n\tdprintk(2, \"av7110:%p, dvb_demux_feed:%p\\n\", av7110, dvbdmxfeed);\n\n\tif (av7110->playing || (av7110->rec_mode & av))\n\t\treturn -EBUSY;\n\tav7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Stop, 0);\n\tdvbdmx->recording = 1;\n\tav7110->rec_mode |= av;\n\n\tswitch (av7110->rec_mode) {\n\tcase RP_AUDIO:\n\t\tdvb_filter_pes2ts_init(&av7110->p2t[0],\n\t\t\t\t       dvbdmx->pesfilter[0]->pid,\n\t\t\t\t       dvb_filter_pes2ts_cb,\n\t\t\t\t       (void *) dvbdmx->pesfilter[0]);\n\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Record, 2, AudioPES, 0);\n\t\tbreak;\n\n\tcase RP_VIDEO:\n\t\tdvb_filter_pes2ts_init(&av7110->p2t[1],\n\t\t\t\t       dvbdmx->pesfilter[1]->pid,\n\t\t\t\t       dvb_filter_pes2ts_cb,\n\t\t\t\t       (void *) dvbdmx->pesfilter[1]);\n\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Record, 2, VideoPES, 0);\n\t\tbreak;\n\n\tcase RP_AV:\n\t\tdvb_filter_pes2ts_init(&av7110->p2t[0],\n\t\t\t\t       dvbdmx->pesfilter[0]->pid,\n\t\t\t\t       dvb_filter_pes2ts_cb,\n\t\t\t\t       (void *) dvbdmx->pesfilter[0]);\n\t\tdvb_filter_pes2ts_init(&av7110->p2t[1],\n\t\t\t\t       dvbdmx->pesfilter[1]->pid,\n\t\t\t\t       dvb_filter_pes2ts_cb,\n\t\t\t\t       (void *) dvbdmx->pesfilter[1]);\n\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Record, 2, AV_PES, 0);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint av7110_av_start_play(struct av7110 *av7110, int av)\n{\n\tint ret = 0;\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif (av7110->rec_mode)\n\t\treturn -EBUSY;\n\tif (av7110->playing & av)\n\t\treturn -EBUSY;\n\n\tav7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Stop, 0);\n\n\tif (av7110->playing == RP_NONE) {\n\t\tav7110_ipack_reset(&av7110->ipack[0]);\n\t\tav7110_ipack_reset(&av7110->ipack[1]);\n\t}\n\n\tav7110->playing |= av;\n\tswitch (av7110->playing) {\n\tcase RP_AUDIO:\n\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Play, 2, AudioPES, 0);\n\t\tbreak;\n\tcase RP_VIDEO:\n\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Play, 2, VideoPES, 0);\n\t\tav7110->sinfo = 0;\n\t\tbreak;\n\tcase RP_AV:\n\t\tav7110->sinfo = 0;\n\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Play, 2, AV_PES, 0);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint av7110_av_stop(struct av7110 *av7110, int av)\n{\n\tint ret = 0;\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif (!(av7110->playing & av) && !(av7110->rec_mode & av))\n\t\treturn 0;\n\tav7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Stop, 0);\n\tif (av7110->playing) {\n\t\tav7110->playing &= ~av;\n\t\tswitch (av7110->playing) {\n\t\tcase RP_AUDIO:\n\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Play, 2, AudioPES, 0);\n\t\t\tbreak;\n\t\tcase RP_VIDEO:\n\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Play, 2, VideoPES, 0);\n\t\t\tbreak;\n\t\tcase RP_NONE:\n\t\t\tret = av7110_set_vidmode(av7110, av7110->vidmode);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tav7110->rec_mode &= ~av;\n\t\tswitch (av7110->rec_mode) {\n\t\tcase RP_AUDIO:\n\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Record, 2, AudioPES, 0);\n\t\t\tbreak;\n\t\tcase RP_VIDEO:\n\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Record, 2, VideoPES, 0);\n\t\t\tbreak;\n\t\tcase RP_NONE:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint av7110_pes_play(void *dest, struct dvb_ringbuffer *buf, int dlen)\n{\n\tint len;\n\tu32 sync;\n\tu16 blen;\n\n\tif (!dlen) {\n\t\twake_up(&buf->queue);\n\t\treturn -1;\n\t}\n\twhile (1) {\n\t\tlen = dvb_ringbuffer_avail(buf);\n\t\tif (len < 6) {\n\t\t\twake_up(&buf->queue);\n\t\t\treturn -1;\n\t\t}\n\t\tsync =  DVB_RINGBUFFER_PEEK(buf, 0) << 24;\n\t\tsync |= DVB_RINGBUFFER_PEEK(buf, 1) << 16;\n\t\tsync |= DVB_RINGBUFFER_PEEK(buf, 2) << 8;\n\t\tsync |= DVB_RINGBUFFER_PEEK(buf, 3);\n\n\t\tif (((sync &~ 0x0f) == 0x000001e0) ||\n\t\t    ((sync &~ 0x1f) == 0x000001c0) ||\n\t\t    (sync == 0x000001bd))\n\t\t\tbreak;\n\t\tprintk(\"resync\\n\");\n\t\tDVB_RINGBUFFER_SKIP(buf, 1);\n\t}\n\tblen =  DVB_RINGBUFFER_PEEK(buf, 4) << 8;\n\tblen |= DVB_RINGBUFFER_PEEK(buf, 5);\n\tblen += 6;\n\tif (len < blen || blen > dlen) {\n\t\t\n\t\twake_up(&buf->queue);\n\t\treturn -1;\n\t}\n\n\tdvb_ringbuffer_read(buf, dest, (size_t) blen);\n\n\tdprintk(2, \"pread=0x%08lx, pwrite=0x%08lx\\n\",\n\t       (unsigned long) buf->pread, (unsigned long) buf->pwrite);\n\twake_up(&buf->queue);\n\treturn blen;\n}\n\n\nint av7110_set_volume(struct av7110 *av7110, unsigned int volleft,\n\t\t      unsigned int volright)\n{\n\tunsigned int vol, val, balance = 0;\n\tint err;\n\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tav7110->mixer.volume_left = volleft;\n\tav7110->mixer.volume_right = volright;\n\n\tswitch (av7110->adac_type) {\n\tcase DVB_ADAC_TI:\n\t\tvolleft = (volleft * 256) / 1036;\n\t\tvolright = (volright * 256) / 1036;\n\t\tif (volleft > 0x3f)\n\t\t\tvolleft = 0x3f;\n\t\tif (volright > 0x3f)\n\t\t\tvolright = 0x3f;\n\t\tif ((err = SendDAC(av7110, 3, 0x80 + volleft)))\n\t\t\treturn err;\n\t\treturn SendDAC(av7110, 4, volright);\n\n\tcase DVB_ADAC_CRYSTAL:\n\t\tvolleft = 127 - volleft / 2;\n\t\tvolright = 127 - volright / 2;\n\t\ti2c_writereg(av7110, 0x20, 0x03, volleft);\n\t\ti2c_writereg(av7110, 0x20, 0x04, volright);\n\t\treturn 0;\n\n\tcase DVB_ADAC_MSP34x0:\n\t\tvol  = (volleft > volright) ? volleft : volright;\n\t\tval\t= (vol * 0x73 / 255) << 8;\n\t\tif (vol > 0)\n\t\t       balance = ((volright - volleft) * 127) / vol;\n\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0001, balance << 8);\n\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0000, val);  \n\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0006, val);  \n\t\treturn 0;\n\n\tcase DVB_ADAC_MSP34x5:\n\t\tvol = (volleft > volright) ? volleft : volright;\n\t\tval = (vol * 0x73 / 255) << 8;\n\t\tif (vol > 0)\n\t\t\tbalance = ((volright - volleft) * 127) / vol;\n\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0001, balance << 8);\n\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0000, val);  \n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nint av7110_set_vidmode(struct av7110 *av7110, enum av7110_video_mode mode)\n{\n\tint ret;\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, LoadVidCode, 1, mode);\n\n\tif (!ret && !av7110->playing) {\n\t\tret = ChangePIDs(av7110, av7110->pids[DMX_PES_VIDEO],\n\t\t\t   av7110->pids[DMX_PES_AUDIO],\n\t\t\t   av7110->pids[DMX_PES_TELETEXT],\n\t\t\t   0, av7110->pids[DMX_PES_PCR]);\n\t\tif (!ret)\n\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_PIDFILTER, Scan, 0);\n\t}\n\treturn ret;\n}\n\n\nstatic enum av7110_video_mode sw2mode[16] = {\n\tAV7110_VIDEO_MODE_PAL, AV7110_VIDEO_MODE_NTSC,\n\tAV7110_VIDEO_MODE_NTSC, AV7110_VIDEO_MODE_PAL,\n\tAV7110_VIDEO_MODE_NTSC, AV7110_VIDEO_MODE_NTSC,\n\tAV7110_VIDEO_MODE_PAL, AV7110_VIDEO_MODE_NTSC,\n\tAV7110_VIDEO_MODE_PAL, AV7110_VIDEO_MODE_PAL,\n\tAV7110_VIDEO_MODE_PAL, AV7110_VIDEO_MODE_PAL,\n\tAV7110_VIDEO_MODE_PAL, AV7110_VIDEO_MODE_PAL,\n\tAV7110_VIDEO_MODE_PAL, AV7110_VIDEO_MODE_PAL,\n};\n\nstatic int get_video_format(struct av7110 *av7110, u8 *buf, int count)\n{\n\tint i;\n\tint hsize, vsize;\n\tint sw;\n\tu8 *p;\n\tint ret = 0;\n\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif (av7110->sinfo)\n\t\treturn 0;\n\tfor (i = 7; i < count - 10; i++) {\n\t\tp = buf + i;\n\t\tif (p[0] || p[1] || p[2] != 0x01 || p[3] != 0xb3)\n\t\t\tcontinue;\n\t\tp += 4;\n\t\thsize = ((p[1] &0xF0) >> 4) | (p[0] << 4);\n\t\tvsize = ((p[1] &0x0F) << 8) | (p[2]);\n\t\tsw = (p[3] & 0x0F);\n\t\tret = av7110_set_vidmode(av7110, sw2mode[sw]);\n\t\tif (!ret) {\n\t\t\tdprintk(2, \"playback %dx%d fr=%d\\n\", hsize, vsize, sw);\n\t\t\tav7110->sinfo = 1;\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n\n \n\nstatic inline long aux_ring_buffer_write(struct dvb_ringbuffer *rbuf,\n\t\t\t\t\t const u8 *buf, unsigned long count)\n{\n\tunsigned long todo = count;\n\tint free;\n\n\twhile (todo > 0) {\n\t\tif (dvb_ringbuffer_free(rbuf) < 2048) {\n\t\t\tif (wait_event_interruptible(rbuf->queue,\n\t\t\t\t\t\t     (dvb_ringbuffer_free(rbuf) >= 2048)))\n\t\t\t\treturn count - todo;\n\t\t}\n\t\tfree = dvb_ringbuffer_free(rbuf);\n\t\tif (free > todo)\n\t\t\tfree = todo;\n\t\tdvb_ringbuffer_write(rbuf, buf, free);\n\t\ttodo -= free;\n\t\tbuf += free;\n\t}\n\n\treturn count - todo;\n}\n\nstatic void play_video_cb(u8 *buf, int count, void *priv)\n{\n\tstruct av7110 *av7110 = (struct av7110 *) priv;\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif ((buf[3] & 0xe0) == 0xe0) {\n\t\tget_video_format(av7110, buf, count);\n\t\taux_ring_buffer_write(&av7110->avout, buf, count);\n\t} else\n\t\taux_ring_buffer_write(&av7110->aout, buf, count);\n}\n\nstatic void play_audio_cb(u8 *buf, int count, void *priv)\n{\n\tstruct av7110 *av7110 = (struct av7110 *) priv;\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\taux_ring_buffer_write(&av7110->aout, buf, count);\n}\n\n\n#define FREE_COND_TS (dvb_ringbuffer_free(rb) >= 4096)\n\nstatic ssize_t ts_play(struct av7110 *av7110, const char __user *buf,\n\t\t       unsigned long count, int nonblock, int type)\n{\n\tstruct dvb_ringbuffer *rb;\n\tu8 *kb;\n\tunsigned long todo = count;\n\n\tdprintk(2, \"%s: type %d cnt %lu\\n\", __func__, type, count);\n\n\trb = (type) ? &av7110->avout : &av7110->aout;\n\tkb = av7110->kbuf[type];\n\n\tif (!kb)\n\t\treturn -ENOBUFS;\n\n\tif (nonblock && !FREE_COND_TS)\n\t\treturn -EWOULDBLOCK;\n\n\twhile (todo >= TS_SIZE) {\n\t\tif (!FREE_COND_TS) {\n\t\t\tif (nonblock)\n\t\t\t\treturn count - todo;\n\t\t\tif (wait_event_interruptible(rb->queue, FREE_COND_TS))\n\t\t\t\treturn count - todo;\n\t\t}\n\t\tif (copy_from_user(kb, buf, TS_SIZE))\n\t\t\treturn -EFAULT;\n\t\twrite_ts_to_decoder(av7110, type, kb, TS_SIZE);\n\t\ttodo -= TS_SIZE;\n\t\tbuf += TS_SIZE;\n\t}\n\n\treturn count - todo;\n}\n\n\n#define FREE_COND (dvb_ringbuffer_free(&av7110->avout) >= 20 * 1024 && \\\n\t\t   dvb_ringbuffer_free(&av7110->aout) >= 20 * 1024)\n\nstatic ssize_t dvb_play(struct av7110 *av7110, const char __user *buf,\n\t\t\tunsigned long count, int nonblock, int type)\n{\n\tunsigned long todo = count, n;\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif (!av7110->kbuf[type])\n\t\treturn -ENOBUFS;\n\n\tif (nonblock && !FREE_COND)\n\t\treturn -EWOULDBLOCK;\n\n\twhile (todo > 0) {\n\t\tif (!FREE_COND) {\n\t\t\tif (nonblock)\n\t\t\t\treturn count - todo;\n\t\t\tif (wait_event_interruptible(av7110->avout.queue,\n\t\t\t\t\t\t     FREE_COND))\n\t\t\t\treturn count - todo;\n\t\t}\n\t\tn = todo;\n\t\tif (n > IPACKS * 2)\n\t\t\tn = IPACKS * 2;\n\t\tif (copy_from_user(av7110->kbuf[type], buf, n))\n\t\t\treturn -EFAULT;\n\t\tav7110_ipack_instant_repack(av7110->kbuf[type], n,\n\t\t\t\t\t    &av7110->ipack[type]);\n\t\ttodo -= n;\n\t\tbuf += n;\n\t}\n\treturn count - todo;\n}\n\nstatic ssize_t dvb_play_kernel(struct av7110 *av7110, const u8 *buf,\n\t\t\tunsigned long count, int nonblock, int type)\n{\n\tunsigned long todo = count, n;\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif (!av7110->kbuf[type])\n\t\treturn -ENOBUFS;\n\n\tif (nonblock && !FREE_COND)\n\t\treturn -EWOULDBLOCK;\n\n\twhile (todo > 0) {\n\t\tif (!FREE_COND) {\n\t\t\tif (nonblock)\n\t\t\t\treturn count - todo;\n\t\t\tif (wait_event_interruptible(av7110->avout.queue,\n\t\t\t\t\t\t     FREE_COND))\n\t\t\t\treturn count - todo;\n\t\t}\n\t\tn = todo;\n\t\tif (n > IPACKS * 2)\n\t\t\tn = IPACKS * 2;\n\t\tav7110_ipack_instant_repack(buf, n, &av7110->ipack[type]);\n\t\ttodo -= n;\n\t\tbuf += n;\n\t}\n\treturn count - todo;\n}\n\nstatic ssize_t dvb_aplay(struct av7110 *av7110, const char __user *buf,\n\t\t\t unsigned long count, int nonblock, int type)\n{\n\tunsigned long todo = count, n;\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif (!av7110->kbuf[type])\n\t\treturn -ENOBUFS;\n\tif (nonblock && dvb_ringbuffer_free(&av7110->aout) < 20 * 1024)\n\t\treturn -EWOULDBLOCK;\n\n\twhile (todo > 0) {\n\t\tif (dvb_ringbuffer_free(&av7110->aout) < 20 * 1024) {\n\t\t\tif (nonblock)\n\t\t\t\treturn count - todo;\n\t\t\tif (wait_event_interruptible(av7110->aout.queue,\n\t\t\t\t\t(dvb_ringbuffer_free(&av7110->aout) >= 20 * 1024)))\n\t\t\t\treturn count-todo;\n\t\t}\n\t\tn = todo;\n\t\tif (n > IPACKS * 2)\n\t\t\tn = IPACKS * 2;\n\t\tif (copy_from_user(av7110->kbuf[type], buf, n))\n\t\t\treturn -EFAULT;\n\t\tav7110_ipack_instant_repack(av7110->kbuf[type], n,\n\t\t\t\t\t    &av7110->ipack[type]);\n\t\ttodo -= n;\n\t\tbuf += n;\n\t}\n\treturn count - todo;\n}\n\nvoid av7110_p2t_init(struct av7110_p2t *p, struct dvb_demux_feed *feed)\n{\n\tmemset(p->pes, 0, TS_SIZE);\n\tp->counter = 0;\n\tp->pos = 0;\n\tp->frags = 0;\n\tif (feed)\n\t\tp->feed = feed;\n}\n\nstatic void clear_p2t(struct av7110_p2t *p)\n{\n\tmemset(p->pes, 0, TS_SIZE);\n\n\tp->pos = 0;\n\tp->frags = 0;\n}\n\n\nstatic int find_pes_header(u8 const *buf, long int length, int *frags)\n{\n\tint c = 0;\n\tint found = 0;\n\n\t*frags = 0;\n\n\twhile (c < length - 3 && !found) {\n\t\tif (buf[c] == 0x00 && buf[c + 1] == 0x00 &&\n\t\t    buf[c + 2] == 0x01) {\n\t\t\tswitch ( buf[c + 3] ) {\n\t\t\tcase PROG_STREAM_MAP:\n\t\t\tcase PRIVATE_STREAM2:\n\t\t\tcase PROG_STREAM_DIR:\n\t\t\tcase ECM_STREAM:\n\t\t\tcase EMM_STREAM:\n\t\t\tcase PADDING_STREAM:\n\t\t\tcase DSM_CC_STREAM:\n\t\t\tcase ISO13522_STREAM:\n\t\t\tcase PRIVATE_STREAM1:\n\t\t\tcase AUDIO_STREAM_S ... AUDIO_STREAM_E:\n\t\t\tcase VIDEO_STREAM_S ... VIDEO_STREAM_E:\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tc++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tc++;\n\t}\n\tif (c == length - 3 && !found) {\n\t\tif (buf[length - 1] == 0x00)\n\t\t\t*frags = 1;\n\t\tif (buf[length - 2] == 0x00 &&\n\t\t    buf[length - 1] == 0x00)\n\t\t\t*frags = 2;\n\t\tif (buf[length - 3] == 0x00 &&\n\t\t    buf[length - 2] == 0x00 &&\n\t\t    buf[length - 1] == 0x01)\n\t\t\t*frags = 3;\n\t\treturn -1;\n\t}\n\n\treturn c;\n}\n\nvoid av7110_p2t_write(u8 const *buf, long int length, u16 pid, struct av7110_p2t *p)\n{\n\tint c, c2, l, add;\n\tint check, rest;\n\n\tc = 0;\n\tc2 = 0;\n\tif (p->frags){\n\t\tcheck = 0;\n\t\tswitch(p->frags) {\n\t\tcase 1:\n\t\t\tif (buf[c] == 0x00 && buf[c + 1] == 0x01) {\n\t\t\t\tcheck = 1;\n\t\t\t\tc += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (buf[c] == 0x01) {\n\t\t\t\tcheck = 1;\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcheck = 1;\n\t\t}\n\t\tif (check) {\n\t\t\tswitch (buf[c]) {\n\t\t\tcase PROG_STREAM_MAP:\n\t\t\tcase PRIVATE_STREAM2:\n\t\t\tcase PROG_STREAM_DIR:\n\t\t\tcase ECM_STREAM:\n\t\t\tcase EMM_STREAM:\n\t\t\tcase PADDING_STREAM:\n\t\t\tcase DSM_CC_STREAM:\n\t\t\tcase ISO13522_STREAM:\n\t\t\tcase PRIVATE_STREAM1:\n\t\t\tcase AUDIO_STREAM_S ... AUDIO_STREAM_E:\n\t\t\tcase VIDEO_STREAM_S ... VIDEO_STREAM_E:\n\t\t\t\tp->pes[0] = 0x00;\n\t\t\t\tp->pes[1] = 0x00;\n\t\t\t\tp->pes[2] = 0x01;\n\t\t\t\tp->pes[3] = buf[c];\n\t\t\t\tp->pos = 4;\n\t\t\t\tmemcpy(p->pes + p->pos, buf + c, (TS_SIZE - 4) - p->pos);\n\t\t\t\tc += (TS_SIZE - 4) - p->pos;\n\t\t\t\tp_to_t(p->pes, (TS_SIZE - 4), pid, &p->counter, p->feed);\n\t\t\t\tclear_p2t(p);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tc = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp->frags = 0;\n\t}\n\n\tif (p->pos) {\n\t\tc2 = find_pes_header(buf + c, length - c, &p->frags);\n\t\tif (c2 >= 0 && c2 < (TS_SIZE - 4) - p->pos)\n\t\t\tl = c2+c;\n\t\telse\n\t\t\tl = (TS_SIZE - 4) - p->pos;\n\t\tmemcpy(p->pes + p->pos, buf, l);\n\t\tc += l;\n\t\tp->pos += l;\n\t\tp_to_t(p->pes, p->pos, pid, &p->counter, p->feed);\n\t\tclear_p2t(p);\n\t}\n\n\tadd = 0;\n\twhile (c < length) {\n\t\tc2 = find_pes_header(buf + c + add, length - c - add, &p->frags);\n\t\tif (c2 >= 0) {\n\t\t\tc2 += c + add;\n\t\t\tif (c2 > c){\n\t\t\t\tp_to_t(buf + c, c2 - c, pid, &p->counter, p->feed);\n\t\t\t\tc = c2;\n\t\t\t\tclear_p2t(p);\n\t\t\t\tadd = 0;\n\t\t\t} else\n\t\t\t\tadd = 1;\n\t\t} else {\n\t\t\tl = length - c;\n\t\t\trest = l % (TS_SIZE - 4);\n\t\t\tl -= rest;\n\t\t\tp_to_t(buf + c, l, pid, &p->counter, p->feed);\n\t\t\tmemcpy(p->pes, buf + c + l, rest);\n\t\t\tp->pos = rest;\n\t\t\tc = length;\n\t\t}\n\t}\n}\n\n\nstatic int write_ts_header2(u16 pid, u8 *counter, int pes_start, u8 *buf, u8 length)\n{\n\tint i;\n\tint c = 0;\n\tint fill;\n\tu8 tshead[4] = { 0x47, 0x00, 0x00, 0x10 };\n\n\tfill = (TS_SIZE - 4) - length;\n\tif (pes_start)\n\t\ttshead[1] = 0x40;\n\tif (fill)\n\t\ttshead[3] = 0x30;\n\ttshead[1] |= (u8)((pid & 0x1F00) >> 8);\n\ttshead[2] |= (u8)(pid & 0x00FF);\n\ttshead[3] |= ((*counter)++ & 0x0F);\n\tmemcpy(buf, tshead, 4);\n\tc += 4;\n\n\tif (fill) {\n\t\tbuf[4] = fill - 1;\n\t\tc++;\n\t\tif (fill > 1) {\n\t\t\tbuf[5] = 0x00;\n\t\t\tc++;\n\t\t}\n\t\tfor (i = 6; i < fill + 4; i++) {\n\t\t\tbuf[i] = 0xFF;\n\t\t\tc++;\n\t\t}\n\t}\n\n\treturn c;\n}\n\n\nstatic void p_to_t(u8 const *buf, long int length, u16 pid, u8 *counter,\n\t\t   struct dvb_demux_feed *feed)\n{\n\tint l, pes_start;\n\tu8 obuf[TS_SIZE];\n\tlong c = 0;\n\n\tpes_start = 0;\n\tif (length > 3 &&\n\t     buf[0] == 0x00 && buf[1] == 0x00 && buf[2] == 0x01)\n\t\tswitch (buf[3]) {\n\t\tcase PROG_STREAM_MAP:\n\t\tcase PRIVATE_STREAM2:\n\t\tcase PROG_STREAM_DIR:\n\t\tcase ECM_STREAM:\n\t\tcase EMM_STREAM:\n\t\tcase PADDING_STREAM:\n\t\tcase DSM_CC_STREAM:\n\t\tcase ISO13522_STREAM:\n\t\tcase PRIVATE_STREAM1:\n\t\tcase AUDIO_STREAM_S ... AUDIO_STREAM_E:\n\t\tcase VIDEO_STREAM_S ... VIDEO_STREAM_E:\n\t\t\tpes_start = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\twhile (c < length) {\n\t\tmemset(obuf, 0, TS_SIZE);\n\t\tif (length - c >= (TS_SIZE - 4)){\n\t\t\tl = write_ts_header2(pid, counter, pes_start,\n\t\t\t\t\t     obuf, (TS_SIZE - 4));\n\t\t\tmemcpy(obuf + l, buf + c, TS_SIZE - l);\n\t\t\tc += TS_SIZE - l;\n\t\t} else {\n\t\t\tl = write_ts_header2(pid, counter, pes_start,\n\t\t\t\t\t     obuf, length - c);\n\t\t\tmemcpy(obuf + l, buf + c, TS_SIZE - l);\n\t\t\tc = length;\n\t\t}\n\t\tfeed->cb.ts(obuf, 188, NULL, 0, &feed->feed.ts, NULL);\n\t\tpes_start = 0;\n\t}\n}\n\n\nstatic int write_ts_to_decoder(struct av7110 *av7110, int type, const u8 *buf, size_t len)\n{\n\tstruct ipack *ipack = &av7110->ipack[type];\n\n\tif (buf[1] & TRANS_ERROR) {\n\t\tav7110_ipack_reset(ipack);\n\t\treturn -1;\n\t}\n\n\tif (!(buf[3] & PAYLOAD))\n\t\treturn -1;\n\n\tif (buf[1] & PAY_START)\n\t\tav7110_ipack_flush(ipack);\n\n\tif (buf[3] & ADAPT_FIELD) {\n\t\tif (buf[4] > len - 1 - 4)\n\t\t\treturn 0;\n\t\tlen -= buf[4] + 1;\n\t\tbuf += buf[4] + 1;\n\t}\n\n\tav7110_ipack_instant_repack(buf + 4, len - 4, ipack);\n\treturn 0;\n}\n\n\nint av7110_write_to_decoder(struct dvb_demux_feed *feed, const u8 *buf, size_t len)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct av7110 *av7110 = demux->priv;\n\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif (av7110->full_ts && demux->dmx.frontend->source != DMX_MEMORY_FE)\n\t\treturn 0;\n\n\tswitch (feed->pes_type) {\n\tcase 0:\n\t\tif (av7110->audiostate.stream_source == AUDIO_SOURCE_MEMORY)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase 1:\n\t\tif (av7110->videostate.stream_source == VIDEO_SOURCE_MEMORY)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn write_ts_to_decoder(av7110, feed->pes_type, buf, len);\n}\n\n\n\n \nvoid dvb_video_add_event(struct av7110 *av7110, struct video_event *event)\n{\n\tstruct dvb_video_events *events = &av7110->video_events;\n\tint wp;\n\n\tspin_lock_bh(&events->lock);\n\n\twp = (events->eventw + 1) % MAX_VIDEO_EVENT;\n\tif (wp == events->eventr) {\n\t\tevents->overflow = 1;\n\t\tevents->eventr = (events->eventr + 1) % MAX_VIDEO_EVENT;\n\t}\n\n\t\n\tmemcpy(&events->events[events->eventw], event, sizeof(struct video_event));\n\tevents->eventw = wp;\n\n\tspin_unlock_bh(&events->lock);\n\n\twake_up_interruptible(&events->wait_queue);\n}\n\n\nstatic int dvb_video_get_event (struct av7110 *av7110, struct video_event *event, int flags)\n{\n\tstruct dvb_video_events *events = &av7110->video_events;\n\n\tif (events->overflow) {\n\t\tevents->overflow = 0;\n\t\treturn -EOVERFLOW;\n\t}\n\tif (events->eventw == events->eventr) {\n\t\tint ret;\n\n\t\tif (flags & O_NONBLOCK)\n\t\t\treturn -EWOULDBLOCK;\n\n\t\tret = wait_event_interruptible(events->wait_queue,\n\t\t\t\t\t       events->eventw != events->eventr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tspin_lock_bh(&events->lock);\n\n\tmemcpy(event, &events->events[events->eventr],\n\t       sizeof(struct video_event));\n\tevents->eventr = (events->eventr + 1) % MAX_VIDEO_EVENT;\n\n\tspin_unlock_bh(&events->lock);\n\n\treturn 0;\n}\n\n \n\nstatic __poll_t dvb_video_poll(struct file *file, poll_table *wait)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\t__poll_t mask = 0;\n\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif ((file->f_flags & O_ACCMODE) != O_RDONLY)\n\t\tpoll_wait(file, &av7110->avout.queue, wait);\n\n\tpoll_wait(file, &av7110->video_events.wait_queue, wait);\n\n\tif (av7110->video_events.eventw != av7110->video_events.eventr)\n\t\tmask = EPOLLPRI;\n\n\tif ((file->f_flags & O_ACCMODE) != O_RDONLY) {\n\t\tif (av7110->playing) {\n\t\t\tif (FREE_COND)\n\t\t\t\tmask |= (EPOLLOUT | EPOLLWRNORM);\n\t\t} else {\n\t\t\t \n\t\t\tmask |= (EPOLLOUT | EPOLLWRNORM);\n\t\t}\n\t}\n\n\treturn mask;\n}\n\nstatic ssize_t dvb_video_write(struct file *file, const char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\tunsigned char c;\n\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif ((file->f_flags & O_ACCMODE) == O_RDONLY)\n\t\treturn -EPERM;\n\n\tif (av7110->videostate.stream_source != VIDEO_SOURCE_MEMORY)\n\t\treturn -EPERM;\n\n\tif (get_user(c, buf))\n\t\treturn -EFAULT;\n\tif (c == 0x47 && count % TS_SIZE == 0)\n\t\treturn ts_play(av7110, buf, count, file->f_flags & O_NONBLOCK, 1);\n\telse\n\t\treturn dvb_play(av7110, buf, count, file->f_flags & O_NONBLOCK, 1);\n}\n\nstatic __poll_t dvb_audio_poll(struct file *file, poll_table *wait)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\t__poll_t mask = 0;\n\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tpoll_wait(file, &av7110->aout.queue, wait);\n\n\tif (av7110->playing) {\n\t\tif (dvb_ringbuffer_free(&av7110->aout) >= 20 * 1024)\n\t\t\tmask |= (EPOLLOUT | EPOLLWRNORM);\n\t} else  \n\t\tmask = (EPOLLOUT | EPOLLWRNORM);\n\n\treturn mask;\n}\n\nstatic ssize_t dvb_audio_write(struct file *file, const char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\tunsigned char c;\n\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif (av7110->audiostate.stream_source != AUDIO_SOURCE_MEMORY) {\n\t\tprintk(KERN_ERR \"not audio source memory\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (get_user(c, buf))\n\t\treturn -EFAULT;\n\tif (c == 0x47 && count % TS_SIZE == 0)\n\t\treturn ts_play(av7110, buf, count, file->f_flags & O_NONBLOCK, 0);\n\telse\n\t\treturn dvb_aplay(av7110, buf, count, file->f_flags & O_NONBLOCK, 0);\n}\n\nstatic u8 iframe_header[] = { 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x80, 0x00, 0x00 };\n\n#define MIN_IFRAME 400000\n\nstatic int play_iframe(struct av7110 *av7110, char __user *buf, unsigned int len, int nonblock)\n{\n\tunsigned i, n;\n\tint progressive = 0;\n\tint match = 0;\n\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tif (!(av7110->playing & RP_VIDEO)) {\n\t\tif (av7110_av_start_play(av7110, RP_VIDEO) < 0)\n\t\t\treturn -EBUSY;\n\t}\n\n\t \n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char c;\n\t\tif (get_user(c, buf + i))\n\t\t\treturn -EFAULT;\n\t\tif (match == 5) {\n\t\t\tprogressive = c & 0x08;\n\t\t\tmatch = 0;\n\t\t}\n\t\tif (c == 0x00) {\n\t\t\tmatch = (match == 1 || match == 2) ? 2 : 1;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (match++) {\n\t\tcase 2: if (c == 0x01)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 3: if (c == 0xb5)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 4: if ((c & 0xf0) == 0x10)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tmatch = 0;\n\t}\n\n\t \n\tn = MIN_IFRAME / len + 1;\n\n\t \n\tdvb_play_kernel(av7110, iframe_header, sizeof(iframe_header), 0, 1);\n\n\tfor (i = 0; i < n; i++)\n\t\tdvb_play(av7110, buf, len, 0, 1);\n\n\tav7110_ipack_flush(&av7110->ipack[1]);\n\n\tif (progressive)\n\t\treturn vidcom(av7110, AV_VIDEO_CMD_FREEZE, 1);\n\telse\n\t\treturn 0;\n}\n\n#ifdef CONFIG_COMPAT\nstruct compat_video_still_picture {\n\tcompat_uptr_t iFrame;\n\tint32_t size;\n};\n#define VIDEO_STILLPICTURE32 _IOW('o', 30, struct compat_video_still_picture)\n\nstruct compat_video_event {\n\t__s32 type;\n\t \n\tcompat_long_t timestamp;\n\tunion {\n\t\tvideo_size_t size;\n\t\tunsigned int frame_rate;         \n\t\tunsigned char vsync_field;       \n\t} u;\n};\n#define VIDEO_GET_EVENT32 _IOR('o', 28, struct compat_video_event)\n\nstatic int dvb_compat_video_get_event(struct av7110 *av7110,\n\t\t\t\t      struct compat_video_event *event, int flags)\n{\n\tstruct video_event ev;\n\tint ret;\n\n\tret = dvb_video_get_event(av7110, &ev, flags);\n\n\t*event = (struct compat_video_event) {\n\t\t.type = ev.type,\n\t\t.timestamp = ev.timestamp,\n\t\t.u.size = ev.u.size,\n\t};\n\n\treturn ret;\n}\n#endif\n\nstatic int dvb_video_ioctl(struct file *file,\n\t\t\t   unsigned int cmd, void *parg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\tunsigned long arg = (unsigned long) parg;\n\tint ret = 0;\n\n\tdprintk(1, \"av7110:%p, cmd=%04x\\n\", av7110,cmd);\n\n\tif ((file->f_flags & O_ACCMODE) == O_RDONLY) {\n\t\tif ( cmd != VIDEO_GET_STATUS && cmd != VIDEO_GET_EVENT &&\n\t\t     cmd != VIDEO_GET_SIZE ) {\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\tif (mutex_lock_interruptible(&av7110->ioctl_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase VIDEO_STOP:\n\t\tav7110->videostate.play_state = VIDEO_STOPPED;\n\t\tif (av7110->videostate.stream_source == VIDEO_SOURCE_MEMORY)\n\t\t\tret = av7110_av_stop(av7110, RP_VIDEO);\n\t\telse\n\t\t\tret = vidcom(av7110, AV_VIDEO_CMD_STOP,\n\t\t\t       av7110->videostate.video_blank ? 0 : 1);\n\t\tif (!ret)\n\t\t\tav7110->trickmode = TRICK_NONE;\n\t\tbreak;\n\n\tcase VIDEO_PLAY:\n\t\tav7110->trickmode = TRICK_NONE;\n\t\tif (av7110->videostate.play_state == VIDEO_FREEZED) {\n\t\t\tav7110->videostate.play_state = VIDEO_PLAYING;\n\t\t\tret = vidcom(av7110, AV_VIDEO_CMD_PLAY, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (av7110->videostate.stream_source == VIDEO_SOURCE_MEMORY) {\n\t\t\tif (av7110->playing == RP_AV) {\n\t\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Stop, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t\tav7110->playing &= ~RP_VIDEO;\n\t\t\t}\n\t\t\tret = av7110_av_start_play(av7110, RP_VIDEO);\n\t\t}\n\t\tif (!ret)\n\t\t\tret = vidcom(av7110, AV_VIDEO_CMD_PLAY, 0);\n\t\tif (!ret)\n\t\t\tav7110->videostate.play_state = VIDEO_PLAYING;\n\t\tbreak;\n\n\tcase VIDEO_FREEZE:\n\t\tav7110->videostate.play_state = VIDEO_FREEZED;\n\t\tif (av7110->playing & RP_VIDEO)\n\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Pause, 0);\n\t\telse\n\t\t\tret = vidcom(av7110, AV_VIDEO_CMD_FREEZE, 1);\n\t\tif (!ret)\n\t\t\tav7110->trickmode = TRICK_FREEZE;\n\t\tbreak;\n\n\tcase VIDEO_CONTINUE:\n\t\tif (av7110->playing & RP_VIDEO)\n\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Continue, 0);\n\t\tif (!ret)\n\t\t\tret = vidcom(av7110, AV_VIDEO_CMD_PLAY, 0);\n\t\tif (!ret) {\n\t\t\tav7110->videostate.play_state = VIDEO_PLAYING;\n\t\t\tav7110->trickmode = TRICK_NONE;\n\t\t}\n\t\tbreak;\n\n\tcase VIDEO_SELECT_SOURCE:\n\t\tav7110->videostate.stream_source = (video_stream_source_t) arg;\n\t\tbreak;\n\n\tcase VIDEO_SET_BLANK:\n\t\tav7110->videostate.video_blank = (int) arg;\n\t\tbreak;\n\n\tcase VIDEO_GET_STATUS:\n\t\tmemcpy(parg, &av7110->videostate, sizeof(struct video_status));\n\t\tbreak;\n\n#ifdef CONFIG_COMPAT\n\tcase VIDEO_GET_EVENT32:\n\t\tret = dvb_compat_video_get_event(av7110, parg, file->f_flags);\n\t\tbreak;\n#endif\n\n\tcase VIDEO_GET_EVENT:\n\t\tret = dvb_video_get_event(av7110, parg, file->f_flags);\n\t\tbreak;\n\n\tcase VIDEO_GET_SIZE:\n\t\tmemcpy(parg, &av7110->video_size, sizeof(video_size_t));\n\t\tbreak;\n\n\tcase VIDEO_SET_DISPLAY_FORMAT:\n\t{\n\t\tvideo_displayformat_t format = (video_displayformat_t) arg;\n\t\tswitch (format) {\n\t\tcase VIDEO_PAN_SCAN:\n\t\t\tav7110->display_panscan = VID_PAN_SCAN_PREF;\n\t\t\tbreak;\n\t\tcase VIDEO_LETTER_BOX:\n\t\t\tav7110->display_panscan = VID_VC_AND_PS_PREF;\n\t\t\tbreak;\n\t\tcase VIDEO_CENTER_CUT_OUT:\n\t\t\tav7110->display_panscan = VID_CENTRE_CUT_PREF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tav7110->videostate.display_format = format;\n\t\tret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetPanScanType,\n\t\t\t\t    1, av7110->display_panscan);\n\t\tbreak;\n\t}\n\n\tcase VIDEO_SET_FORMAT:\n\t\tif (arg > 1) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tav7110->display_ar = arg;\n\t\tret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetMonitorType,\n\t\t\t\t    1, (u16) arg);\n\t\tbreak;\n\n#ifdef CONFIG_COMPAT\n\tcase VIDEO_STILLPICTURE32:\n\t{\n\t\tstruct compat_video_still_picture *pic =\n\t\t\t(struct compat_video_still_picture *) parg;\n\t\tav7110->videostate.stream_source = VIDEO_SOURCE_MEMORY;\n\t\tdvb_ringbuffer_flush_spinlock_wakeup(&av7110->avout);\n\t\tret = play_iframe(av7110, compat_ptr(pic->iFrame),\n\t\t\t\t  pic->size, file->f_flags & O_NONBLOCK);\n\t\tbreak;\n\t}\n#endif\n\n\tcase VIDEO_STILLPICTURE:\n\t{\n\t\tstruct video_still_picture *pic =\n\t\t\t(struct video_still_picture *) parg;\n\t\tav7110->videostate.stream_source = VIDEO_SOURCE_MEMORY;\n\t\tdvb_ringbuffer_flush_spinlock_wakeup(&av7110->avout);\n\t\tret = play_iframe(av7110, pic->iFrame, pic->size,\n\t\t\t\t  file->f_flags & O_NONBLOCK);\n\t\tbreak;\n\t}\n\n\tcase VIDEO_FAST_FORWARD:\n\t\t\n\t\tif (av7110->playing & RP_VIDEO)\n\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY,\n\t\t\t\t\t    __Scan_I, 2, AV_PES, 0);\n\t\telse\n\t\t\tret = vidcom(av7110, AV_VIDEO_CMD_FFWD, arg);\n\t\tif (!ret) {\n\t\t\tav7110->trickmode = TRICK_FAST;\n\t\t\tav7110->videostate.play_state = VIDEO_PLAYING;\n\t\t}\n\t\tbreak;\n\n\tcase VIDEO_SLOWMOTION:\n\t\tif (av7110->playing&RP_VIDEO) {\n\t\t\tif (av7110->trickmode != TRICK_SLOW)\n\t\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Slow, 2, 0, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = vidcom(av7110, AV_VIDEO_CMD_SLOW, arg);\n\t\t} else {\n\t\t\tret = vidcom(av7110, AV_VIDEO_CMD_PLAY, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = vidcom(av7110, AV_VIDEO_CMD_STOP, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = vidcom(av7110, AV_VIDEO_CMD_SLOW, arg);\n\t\t}\n\t\tif (!ret) {\n\t\t\tav7110->trickmode = TRICK_SLOW;\n\t\t\tav7110->videostate.play_state = VIDEO_PLAYING;\n\t\t}\n\t\tbreak;\n\n\tcase VIDEO_GET_CAPABILITIES:\n\t\t*(int *)parg = VIDEO_CAP_MPEG1 | VIDEO_CAP_MPEG2 |\n\t\t\tVIDEO_CAP_SYS | VIDEO_CAP_PROG;\n\t\tbreak;\n\n\tcase VIDEO_CLEAR_BUFFER:\n\t\tdvb_ringbuffer_flush_spinlock_wakeup(&av7110->avout);\n\t\tav7110_ipack_reset(&av7110->ipack[1]);\n\t\tif (av7110->playing == RP_AV) {\n\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY,\n\t\t\t\t\t    __Play, 2, AV_PES, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (av7110->trickmode == TRICK_FAST)\n\t\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY,\n\t\t\t\t\t\t    __Scan_I, 2, AV_PES, 0);\n\t\t\tif (av7110->trickmode == TRICK_SLOW) {\n\t\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY,\n\t\t\t\t\t\t    __Slow, 2, 0, 0);\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = vidcom(av7110, AV_VIDEO_CMD_SLOW, arg);\n\t\t\t}\n\t\t\tif (av7110->trickmode == TRICK_FREEZE)\n\t\t\t\tret = vidcom(av7110, AV_VIDEO_CMD_STOP, 1);\n\t\t}\n\t\tbreak;\n\n\tcase VIDEO_SET_STREAMTYPE:\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&av7110->ioctl_mutex);\n\treturn ret;\n}\n\nstatic int dvb_audio_ioctl(struct file *file,\n\t\t\t   unsigned int cmd, void *parg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\tunsigned long arg = (unsigned long) parg;\n\tint ret = 0;\n\n\tdprintk(1, \"av7110:%p, cmd=%04x\\n\", av7110,cmd);\n\n\tif (((file->f_flags & O_ACCMODE) == O_RDONLY) &&\n\t    (cmd != AUDIO_GET_STATUS))\n\t\treturn -EPERM;\n\n\tif (mutex_lock_interruptible(&av7110->ioctl_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase AUDIO_STOP:\n\t\tif (av7110->audiostate.stream_source == AUDIO_SOURCE_MEMORY)\n\t\t\tret = av7110_av_stop(av7110, RP_AUDIO);\n\t\telse\n\t\t\tret = audcom(av7110, AUDIO_CMD_MUTE);\n\t\tif (!ret)\n\t\t\tav7110->audiostate.play_state = AUDIO_STOPPED;\n\t\tbreak;\n\n\tcase AUDIO_PLAY:\n\t\tif (av7110->audiostate.stream_source == AUDIO_SOURCE_MEMORY)\n\t\t\tret = av7110_av_start_play(av7110, RP_AUDIO);\n\t\tif (!ret)\n\t\t\tret = audcom(av7110, AUDIO_CMD_UNMUTE);\n\t\tif (!ret)\n\t\t\tav7110->audiostate.play_state = AUDIO_PLAYING;\n\t\tbreak;\n\n\tcase AUDIO_PAUSE:\n\t\tret = audcom(av7110, AUDIO_CMD_MUTE);\n\t\tif (!ret)\n\t\t\tav7110->audiostate.play_state = AUDIO_PAUSED;\n\t\tbreak;\n\n\tcase AUDIO_CONTINUE:\n\t\tif (av7110->audiostate.play_state == AUDIO_PAUSED) {\n\t\t\tav7110->audiostate.play_state = AUDIO_PLAYING;\n\t\t\tret = audcom(av7110, AUDIO_CMD_UNMUTE | AUDIO_CMD_PCM16);\n\t\t}\n\t\tbreak;\n\n\tcase AUDIO_SELECT_SOURCE:\n\t\tav7110->audiostate.stream_source = (audio_stream_source_t) arg;\n\t\tbreak;\n\n\tcase AUDIO_SET_MUTE:\n\t{\n\t\tret = audcom(av7110, arg ? AUDIO_CMD_MUTE : AUDIO_CMD_UNMUTE);\n\t\tif (!ret)\n\t\t\tav7110->audiostate.mute_state = (int) arg;\n\t\tbreak;\n\t}\n\n\tcase AUDIO_SET_AV_SYNC:\n\t\tav7110->audiostate.AV_sync_state = (int) arg;\n\t\tret = audcom(av7110, arg ? AUDIO_CMD_SYNC_ON : AUDIO_CMD_SYNC_OFF);\n\t\tbreak;\n\n\tcase AUDIO_SET_BYPASS_MODE:\n\t\tif (FW_VERSION(av7110->arm_app) < 0x2621)\n\t\t\tret = -EINVAL;\n\t\tav7110->audiostate.bypass_mode = (int)arg;\n\t\tbreak;\n\n\tcase AUDIO_CHANNEL_SELECT:\n\t\tav7110->audiostate.channel_select = (audio_channel_select_t) arg;\n\t\tswitch(av7110->audiostate.channel_select) {\n\t\tcase AUDIO_STEREO:\n\t\t\tret = audcom(av7110, AUDIO_CMD_STEREO);\n\t\t\tif (!ret) {\n\t\t\t\tif (av7110->adac_type == DVB_ADAC_CRYSTAL)\n\t\t\t\t\ti2c_writereg(av7110, 0x20, 0x02, 0x49);\n\t\t\t\telse if (av7110->adac_type == DVB_ADAC_MSP34x5)\n\t\t\t\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0008, 0x0220);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIO_MONO_LEFT:\n\t\t\tret = audcom(av7110, AUDIO_CMD_MONO_L);\n\t\t\tif (!ret) {\n\t\t\t\tif (av7110->adac_type == DVB_ADAC_CRYSTAL)\n\t\t\t\t\ti2c_writereg(av7110, 0x20, 0x02, 0x4a);\n\t\t\t\telse if (av7110->adac_type == DVB_ADAC_MSP34x5)\n\t\t\t\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0008, 0x0200);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIO_MONO_RIGHT:\n\t\t\tret = audcom(av7110, AUDIO_CMD_MONO_R);\n\t\t\tif (!ret) {\n\t\t\t\tif (av7110->adac_type == DVB_ADAC_CRYSTAL)\n\t\t\t\t\ti2c_writereg(av7110, 0x20, 0x02, 0x45);\n\t\t\t\telse if (av7110->adac_type == DVB_ADAC_MSP34x5)\n\t\t\t\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0008, 0x0210);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase AUDIO_GET_STATUS:\n\t\tmemcpy(parg, &av7110->audiostate, sizeof(struct audio_status));\n\t\tbreak;\n\n\tcase AUDIO_GET_CAPABILITIES:\n\t\tif (FW_VERSION(av7110->arm_app) < 0x2621)\n\t\t\t*(unsigned int *)parg = AUDIO_CAP_LPCM | AUDIO_CAP_MP1 | AUDIO_CAP_MP2;\n\t\telse\n\t\t\t*(unsigned int *)parg = AUDIO_CAP_LPCM | AUDIO_CAP_DTS | AUDIO_CAP_AC3 |\n\t\t\t\t\t\tAUDIO_CAP_MP1 | AUDIO_CAP_MP2;\n\t\tbreak;\n\n\tcase AUDIO_CLEAR_BUFFER:\n\t\tdvb_ringbuffer_flush_spinlock_wakeup(&av7110->aout);\n\t\tav7110_ipack_reset(&av7110->ipack[0]);\n\t\tif (av7110->playing == RP_AV)\n\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY,\n\t\t\t\t\t    __Play, 2, AV_PES, 0);\n\t\tbreak;\n\n\tcase AUDIO_SET_ID:\n\t\tbreak;\n\n\tcase AUDIO_SET_MIXER:\n\t{\n\t\tstruct audio_mixer *amix = (struct audio_mixer *)parg;\n\t\tret = av7110_set_volume(av7110, amix->volume_left, amix->volume_right);\n\t\tbreak;\n\t}\n\n\tcase AUDIO_SET_STREAMTYPE:\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t}\n\n\tmutex_unlock(&av7110->ioctl_mutex);\n\treturn ret;\n}\n\n\nstatic int dvb_video_open(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\tint err;\n\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif ((err = dvb_generic_open(inode, file)) < 0)\n\t\treturn err;\n\n\tif ((file->f_flags & O_ACCMODE) != O_RDONLY) {\n\t\tdvb_ringbuffer_flush_spinlock_wakeup(&av7110->aout);\n\t\tdvb_ringbuffer_flush_spinlock_wakeup(&av7110->avout);\n\t\tav7110->video_blank = 1;\n\t\tav7110->audiostate.AV_sync_state = 1;\n\t\tav7110->videostate.stream_source = VIDEO_SOURCE_DEMUX;\n\n\t\t \n\t\tav7110->video_events.eventr = av7110->video_events.eventw = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int dvb_video_release(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif ((file->f_flags & O_ACCMODE) != O_RDONLY) {\n\t\tav7110_av_stop(av7110, RP_VIDEO);\n\t}\n\n\treturn dvb_generic_release(inode, file);\n}\n\nstatic int dvb_audio_open(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\tint err = dvb_generic_open(inode, file);\n\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tif (err < 0)\n\t\treturn err;\n\tdvb_ringbuffer_flush_spinlock_wakeup(&av7110->aout);\n\tav7110->audiostate.stream_source = AUDIO_SOURCE_DEMUX;\n\treturn 0;\n}\n\nstatic int dvb_audio_release(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\n\tdprintk(2, \"av7110:%p, \\n\", av7110);\n\n\tav7110_av_stop(av7110, RP_AUDIO);\n\treturn dvb_generic_release(inode, file);\n}\n\n\n\n \n\nstatic const struct file_operations dvb_video_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.write\t\t= dvb_video_write,\n\t.unlocked_ioctl\t= dvb_generic_ioctl,\n\t.compat_ioctl\t= dvb_generic_ioctl,\n\t.open\t\t= dvb_video_open,\n\t.release\t= dvb_video_release,\n\t.poll\t\t= dvb_video_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct dvb_device dvbdev_video = {\n\t.priv\t\t= NULL,\n\t.users\t\t= 6,\n\t.readers\t= 5,\t \n\t.writers\t= 1,\n\t.fops\t\t= &dvb_video_fops,\n\t.kernel_ioctl\t= dvb_video_ioctl,\n};\n\nstatic const struct file_operations dvb_audio_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.write\t\t= dvb_audio_write,\n\t.unlocked_ioctl\t= dvb_generic_ioctl,\n\t.compat_ioctl\t= dvb_generic_ioctl,\n\t.open\t\t= dvb_audio_open,\n\t.release\t= dvb_audio_release,\n\t.poll\t\t= dvb_audio_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct dvb_device dvbdev_audio = {\n\t.priv\t\t= NULL,\n\t.users\t\t= 1,\n\t.writers\t= 1,\n\t.fops\t\t= &dvb_audio_fops,\n\t.kernel_ioctl\t= dvb_audio_ioctl,\n};\n\n\nint av7110_av_register(struct av7110 *av7110)\n{\n\tav7110->audiostate.AV_sync_state = 0;\n\tav7110->audiostate.mute_state = 0;\n\tav7110->audiostate.play_state = AUDIO_STOPPED;\n\tav7110->audiostate.stream_source = AUDIO_SOURCE_DEMUX;\n\tav7110->audiostate.channel_select = AUDIO_STEREO;\n\tav7110->audiostate.bypass_mode = 0;\n\n\tav7110->videostate.video_blank = 0;\n\tav7110->videostate.play_state = VIDEO_STOPPED;\n\tav7110->videostate.stream_source = VIDEO_SOURCE_DEMUX;\n\tav7110->videostate.video_format = VIDEO_FORMAT_4_3;\n\tav7110->videostate.display_format = VIDEO_LETTER_BOX;\n\tav7110->display_ar = VIDEO_FORMAT_4_3;\n\tav7110->display_panscan = VID_VC_AND_PS_PREF;\n\n\tinit_waitqueue_head(&av7110->video_events.wait_queue);\n\tspin_lock_init(&av7110->video_events.lock);\n\tav7110->video_events.eventw = av7110->video_events.eventr = 0;\n\tav7110->video_events.overflow = 0;\n\tmemset(&av7110->video_size, 0, sizeof (video_size_t));\n\n\tdvb_register_device(&av7110->dvb_adapter, &av7110->video_dev,\n\t\t\t    &dvbdev_video, av7110, DVB_DEVICE_VIDEO, 0);\n\n\tdvb_register_device(&av7110->dvb_adapter, &av7110->audio_dev,\n\t\t\t    &dvbdev_audio, av7110, DVB_DEVICE_AUDIO, 0);\n\n\treturn 0;\n}\n\nvoid av7110_av_unregister(struct av7110 *av7110)\n{\n\tdvb_unregister_device(av7110->audio_dev);\n\tdvb_unregister_device(av7110->video_dev);\n}\n\nint av7110_av_init(struct av7110 *av7110)\n{\n\tvoid (*play[])(u8 *, int, void *) = { play_audio_cb, play_video_cb };\n\tint i, ret;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct ipack *ipack = av7110->ipack + i;\n\n\t\tret = av7110_ipack_init(ipack, IPACKS, play[i]);\n\t\tif (ret < 0) {\n\t\t\tif (i)\n\t\t\t\tav7110_ipack_free(--ipack);\n\t\t\tgoto out;\n\t\t}\n\t\tipack->data = av7110;\n\t}\n\n\tdvb_ringbuffer_init(&av7110->avout, av7110->iobuf, AVOUTLEN);\n\tdvb_ringbuffer_init(&av7110->aout, av7110->iobuf + AVOUTLEN, AOUTLEN);\n\n\tav7110->kbuf[0] = (u8 *)(av7110->iobuf + AVOUTLEN + AOUTLEN + BMPLEN);\n\tav7110->kbuf[1] = av7110->kbuf[0] + 2 * IPACKS;\nout:\n\treturn ret;\n}\n\nvoid av7110_av_exit(struct av7110 *av7110)\n{\n\tav7110_ipack_free(&av7110->ipack[0]);\n\tav7110_ipack_free(&av7110->ipack[1]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}