{
  "module_name": "video_types.rst",
  "hash_id": "13f1541faf152bcf98ff6ae9beb13702897e4e5d1aea2cf721e98c8356a3b205",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/av7110/video_types.rst",
  "human_readable_source": ".. SPDX-License-Identifier: GFDL-1.1-no-invariants-or-later\n\n.. _video_types:\n\n****************\nVideo Data Types\n****************\n\n\n.. _video-format-t:\n\nvideo_format_t\n==============\n\nThe ``video_format_t`` data type defined by\n\n\n.. code-block:: c\n\n    typedef enum {\n\tVIDEO_FORMAT_4_3,     /* Select 4:3 format */\n\tVIDEO_FORMAT_16_9,    /* Select 16:9 format. */\n\tVIDEO_FORMAT_221_1    /* 2.21:1 */\n    } video_format_t;\n\nis used in the VIDEO_SET_FORMAT function (??) to tell the driver which\naspect ratio the output hardware (e.g. TV) has. It is also used in the\ndata structures video_status (??) returned by VIDEO_GET_STATUS (??)\nand video_event (??) returned by VIDEO_GET_EVENT (??) which report\nabout the display format of the current video stream.\n\n\n.. _video-displayformat-t:\n\nvideo_displayformat_t\n=====================\n\nIn case the display format of the video stream and of the display\nhardware differ the application has to specify how to handle the\ncropping of the picture. This can be done using the\nVIDEO_SET_DISPLAY_FORMAT call (??) which accepts\n\n\n.. code-block:: c\n\n    typedef enum {\n\tVIDEO_PAN_SCAN,       /* use pan and scan format */\n\tVIDEO_LETTER_BOX,     /* use letterbox format */\n\tVIDEO_CENTER_CUT_OUT  /* use center cut out format */\n    } video_displayformat_t;\n\nas argument.\n\n\n.. _video-stream-source-t:\n\nvideo_stream_source_t\n=====================\n\nThe video stream source is set through the VIDEO_SELECT_SOURCE call\nand can take the following values, depending on whether we are replaying\nfrom an internal (demuxer) or external (user write) source.\n\n\n.. code-block:: c\n\n    typedef enum {\n\tVIDEO_SOURCE_DEMUX, /* Select the demux as the main source */\n\tVIDEO_SOURCE_MEMORY /* If this source is selected, the stream\n\t\t       comes from the user through the write\n\t\t       system call */\n    } video_stream_source_t;\n\nVIDEO_SOURCE_DEMUX selects the demultiplexer (fed either by the\nfrontend or the DVR device) as the source of the video stream. If\nVIDEO_SOURCE_MEMORY is selected the stream comes from the application\nthrough the **write()** system call.\n\n\n.. _video-play-state-t:\n\nvideo_play_state_t\n==================\n\nThe following values can be returned by the VIDEO_GET_STATUS call\nrepresenting the state of video playback.\n\n\n.. code-block:: c\n\n    typedef enum {\n\tVIDEO_STOPPED, /* Video is stopped */\n\tVIDEO_PLAYING, /* Video is currently playing */\n\tVIDEO_FREEZED  /* Video is freezed */\n    } video_play_state_t;\n\n\n.. c:type:: video_command\n\nstruct video_command\n====================\n\nThe structure must be zeroed before use by the application This ensures\nit can be extended safely in the future.\n\n\n.. code-block:: c\n\n    struct video_command {\n\t__u32 cmd;\n\t__u32 flags;\n\tunion {\n\t    struct {\n\t\t__u64 pts;\n\t    } stop;\n\n\t    struct {\n\t\t/* 0 or 1000 specifies normal speed,\n\t\t   1 specifies forward single stepping,\n\t\t   -1 specifies backward single stepping,\n\t\t   >>1: playback at speed/1000 of the normal speed,\n\t\t   <-1: reverse playback at (-speed/1000) of the normal speed. */\n\t\t__s32 speed;\n\t\t__u32 format;\n\t    } play;\n\n\t    struct {\n\t\t__u32 data[16];\n\t    } raw;\n\t};\n    };\n\n\n.. _video-size-t:\n\nvideo_size_t\n============\n\n\n.. code-block:: c\n\n    typedef struct {\n\tint w;\n\tint h;\n\tvideo_format_t aspect_ratio;\n    } video_size_t;\n\n\n.. c:type:: video_event\n\nstruct video_event\n==================\n\nThe following is the structure of a video event as it is returned by the\nVIDEO_GET_EVENT call.\n\n\n.. code-block:: c\n\n    struct video_event {\n\t__s32 type;\n    #define VIDEO_EVENT_SIZE_CHANGED    1\n    #define VIDEO_EVENT_FRAME_RATE_CHANGED  2\n    #define VIDEO_EVENT_DECODER_STOPPED     3\n    #define VIDEO_EVENT_VSYNC       4\n\tlong timestamp;\n\tunion {\n\t    video_size_t size;\n\t    unsigned int frame_rate;    /* in frames per 1000sec */\n\t    unsigned char vsync_field;  /* unknown/odd/even/progressive */\n\t} u;\n    };\n\n\n.. c:type:: video_status\n\nstruct video_status\n===================\n\nThe VIDEO_GET_STATUS call returns the following structure informing\nabout various states of the playback operation.\n\n\n.. code-block:: c\n\n    struct video_status {\n\tint                   video_blank;   /* blank video on freeze? */\n\tvideo_play_state_t    play_state;    /* current state of playback */\n\tvideo_stream_source_t stream_source; /* current source (demux/memory) */\n\tvideo_format_t        video_format;  /* current aspect ratio of stream */\n\tvideo_displayformat_t display_format;/* selected cropping mode */\n    };\n\nIf video_blank is set video will be blanked out if the channel is\nchanged or if playback is stopped. Otherwise, the last picture will be\ndisplayed. play_state indicates if the video is currently frozen,\nstopped, or being played back. The stream_source corresponds to the\nselected source for the video stream. It can come either from the\ndemultiplexer or from memory. The video_format indicates the aspect\nratio (one of 4:3 or 16:9) of the currently played video stream.\nFinally, display_format corresponds to the selected cropping mode in\ncase the source video format is not the same as the format of the output\ndevice.\n\n\n.. c:type:: video_still_picture\n\nstruct video_still_picture\n==========================\n\nAn I-frame displayed via the VIDEO_STILLPICTURE call is passed on\nwithin the following structure.\n\n\n.. code-block:: c\n\n    /* pointer to and size of a single iframe in memory */\n    struct video_still_picture {\n\tchar *iFrame;        /* pointer to a single iframe in memory */\n\tint32_t size;\n    };\n\n\n.. _video_caps:\n\nvideo capabilities\n==================\n\nA call to VIDEO_GET_CAPABILITIES returns an unsigned integer with the\nfollowing bits set according to the hardwares capabilities.\n\n\n.. code-block:: c\n\n     /* bit definitions for capabilities: */\n     /* can the hardware decode MPEG1 and/or MPEG2? */\n     #define VIDEO_CAP_MPEG1   1\n     #define VIDEO_CAP_MPEG2   2\n     /* can you send a system and/or program stream to video device?\n\t(you still have to open the video and the audio device but only\n\t send the stream to the video device) */\n     #define VIDEO_CAP_SYS     4\n     #define VIDEO_CAP_PROG    8\n     /* can the driver also handle SPU, NAVI and CSS encoded data?\n\t(CSS API is not present yet) */\n     #define VIDEO_CAP_SPU    16\n     #define VIDEO_CAP_NAVI   32\n     #define VIDEO_CAP_CSS    64\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}