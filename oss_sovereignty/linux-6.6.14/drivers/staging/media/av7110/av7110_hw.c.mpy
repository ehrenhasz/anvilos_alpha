{
  "module_name": "av7110_hw.c",
  "hash_id": "8827b74f4a58267d08b9b5e5d23738143a07bd027645a55713df82ed92bc5acb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/av7110/av7110_hw.c",
  "human_readable_source": "\n \n\n \n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n\n#include \"av7110.h\"\n#include \"av7110_hw.h\"\n\n#define _NOHANDSHAKE\n\n \n#define MAX_XFER_SIZE  8\n\n \n\n \n\nint av7110_debiwrite(struct av7110 *av7110, u32 config,\n\t\t     int addr, u32 val, unsigned int count)\n{\n\tstruct saa7146_dev *dev = av7110->dev;\n\n\tif (count > 32764) {\n\t\tprintk(\"%s: invalid count %d\\n\", __func__, count);\n\t\treturn -1;\n\t}\n\tif (saa7146_wait_for_debi_done(av7110->dev, 0) < 0) {\n\t\tprintk(\"%s: wait_for_debi_done failed\\n\", __func__);\n\t\treturn -1;\n\t}\n\tsaa7146_write(dev, DEBI_CONFIG, config);\n\tif (count <= 4)\t\t \n\t\tsaa7146_write(dev, DEBI_AD, val);\n\telse\t\t\t \n\t\tsaa7146_write(dev, DEBI_AD, av7110->debi_bus);\n\tsaa7146_write(dev, DEBI_COMMAND, (count << 17) | (addr & 0xffff));\n\tsaa7146_write(dev, MC2, (2 << 16) | 2);\n\treturn 0;\n}\n\nu32 av7110_debiread(struct av7110 *av7110, u32 config, int addr, unsigned int count)\n{\n\tstruct saa7146_dev *dev = av7110->dev;\n\tu32 result = 0;\n\n\tif (count > 32764) {\n\t\tprintk(\"%s: invalid count %d\\n\", __func__, count);\n\t\treturn 0;\n\t}\n\tif (saa7146_wait_for_debi_done(av7110->dev, 0) < 0) {\n\t\tprintk(\"%s: wait_for_debi_done #1 failed\\n\", __func__);\n\t\treturn 0;\n\t}\n\tsaa7146_write(dev, DEBI_AD, av7110->debi_bus);\n\tsaa7146_write(dev, DEBI_COMMAND, (count << 17) | 0x10000 | (addr & 0xffff));\n\n\tsaa7146_write(dev, DEBI_CONFIG, config);\n\tsaa7146_write(dev, MC2, (2 << 16) | 2);\n\tif (count > 4)\n\t\treturn count;\n\tif (saa7146_wait_for_debi_done(av7110->dev, 0) < 0) {\n\t\tprintk(\"%s: wait_for_debi_done #2 failed\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tresult = saa7146_read(dev, DEBI_AD);\n\tresult &= (0xffffffffUL >> ((4 - count) * 8));\n\treturn result;\n}\n\n\n\n \n#if 0\nvoid av7110_reset_arm(struct av7110 *av7110)\n{\n\tsaa7146_setgpio(av7110->dev, RESET_LINE, SAA7146_GPIO_OUTLO);\n\n\t \n\tSAA7146_IER_DISABLE(av7110->dev, MASK_19 | MASK_03);\n\tSAA7146_ISR_CLEAR(av7110->dev, MASK_19 | MASK_03);\n\n\tsaa7146_setgpio(av7110->dev, RESET_LINE, SAA7146_GPIO_OUTHI);\n\tmsleep(30);\t \n\n\tARM_ResetMailBox(av7110);\n\n\tSAA7146_ISR_CLEAR(av7110->dev, MASK_19 | MASK_03);\n\tSAA7146_IER_ENABLE(av7110->dev, MASK_03);\n\n\tav7110->arm_ready = 1;\n\tdprintk(1, \"reset ARM\\n\");\n}\n#endif   \n\nstatic int waitdebi(struct av7110 *av7110, int adr, int state)\n{\n\tint k;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tfor (k = 0; k < 100; k++) {\n\t\tif (irdebi(av7110, DEBINOSWAP, adr, 0, 2) == state)\n\t\t\treturn 0;\n\t\tudelay(5);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int load_dram(struct av7110 *av7110, u32 *data, int len)\n{\n\tint i;\n\tint blocks, rest;\n\tu32 base, bootblock = AV7110_BOOT_BLOCK;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tblocks = len / AV7110_BOOT_MAX_SIZE;\n\trest = len % AV7110_BOOT_MAX_SIZE;\n\tbase = DRAM_START_CODE;\n\n\tfor (i = 0; i < blocks; i++) {\n\t\tif (waitdebi(av7110, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_EMPTY) < 0) {\n\t\t\tprintk(KERN_ERR \"dvb-ttpci: load_dram(): timeout at block %d\\n\", i);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tdprintk(4, \"writing DRAM block %d\\n\", i);\n\t\tmwdebi(av7110, DEBISWAB, bootblock,\n\t\t       ((u8 *)data) + i * AV7110_BOOT_MAX_SIZE, AV7110_BOOT_MAX_SIZE);\n\t\tbootblock ^= 0x1400;\n\t\tiwdebi(av7110, DEBISWAB, AV7110_BOOT_BASE, swab32(base), 4);\n\t\tiwdebi(av7110, DEBINOSWAP, AV7110_BOOT_SIZE, AV7110_BOOT_MAX_SIZE, 2);\n\t\tiwdebi(av7110, DEBINOSWAP, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);\n\t\tbase += AV7110_BOOT_MAX_SIZE;\n\t}\n\n\tif (rest > 0) {\n\t\tif (waitdebi(av7110, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_EMPTY) < 0) {\n\t\t\tprintk(KERN_ERR \"dvb-ttpci: load_dram(): timeout at last block\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tif (rest > 4)\n\t\t\tmwdebi(av7110, DEBISWAB, bootblock,\n\t\t\t       ((u8 *)data) + i * AV7110_BOOT_MAX_SIZE, rest);\n\t\telse\n\t\t\tmwdebi(av7110, DEBISWAB, bootblock,\n\t\t\t       ((u8 *)data) + i * AV7110_BOOT_MAX_SIZE - 4, rest + 4);\n\n\t\tiwdebi(av7110, DEBISWAB, AV7110_BOOT_BASE, swab32(base), 4);\n\t\tiwdebi(av7110, DEBINOSWAP, AV7110_BOOT_SIZE, rest, 2);\n\t\tiwdebi(av7110, DEBINOSWAP, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);\n\t}\n\tif (waitdebi(av7110, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_EMPTY) < 0) {\n\t\tprintk(KERN_ERR \"dvb-ttpci: load_dram(): timeout after last block\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tiwdebi(av7110, DEBINOSWAP, AV7110_BOOT_SIZE, 0, 2);\n\tiwdebi(av7110, DEBINOSWAP, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);\n\tif (waitdebi(av7110, AV7110_BOOT_STATE, BOOTSTATE_AV7110_BOOT_COMPLETE) < 0) {\n\t\tprintk(KERN_ERR \"dvb-ttpci: load_dram(): final handshake timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\n\n \nint av7110_bootarm(struct av7110 *av7110)\n{\n\tconst struct firmware *fw;\n\tconst char *fw_name = \"av7110/bootcode.bin\";\n\tstruct saa7146_dev *dev = av7110->dev;\n\tu32 ret;\n\tint i;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tav7110->arm_ready = 0;\n\n\tsaa7146_setgpio(dev, RESET_LINE, SAA7146_GPIO_OUTLO);\n\n\t \n\tSAA7146_IER_DISABLE(av7110->dev, MASK_03 | MASK_19);\n\tSAA7146_ISR_CLEAR(av7110->dev, MASK_19 | MASK_03);\n\n\t \n\tsaa7146_write(av7110->dev, MC1, 0x08800880);\n\tsaa7146_write(av7110->dev, DD1_STREAM_B, 0x00000000);\n\tsaa7146_write(av7110->dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\n\n\t \n\tiwdebi(av7110, DEBISWAP, DPRAM_BASE, 0x76543210, 4);\n\t \n\tiwdebi(av7110, DEBISWAP, DPRAM_BASE, 0x76543210, 4);\n\n\tif ((ret=irdebi(av7110, DEBINOSWAP, DPRAM_BASE, 0, 4)) != 0x10325476) {\n\t\tprintk(KERN_ERR \"dvb-ttpci: debi test in av7110_bootarm() failed: %08x != %08x (check your BIOS 'Plug&Play OS' settings)\\n\",\n\t\t       ret, 0x10325476);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < 8192; i += 4)\n\t\tiwdebi(av7110, DEBISWAP, DPRAM_BASE + i, 0x00, 4);\n\tdprintk(2, \"debi test OK\\n\");\n\n\t \n\tdprintk(1, \"load boot code\\n\");\n\tsaa7146_setgpio(dev, ARM_IRQ_LINE, SAA7146_GPIO_IRQLO);\n\t \n\t \n\n\tret = request_firmware(&fw, fw_name, &dev->pci->dev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"dvb-ttpci: Failed to load firmware \\\"%s\\\"\\n\",\n\t\t\tfw_name);\n\t\treturn ret;\n\t}\n\n\tmwdebi(av7110, DEBISWAB, DPRAM_BASE, fw->data, fw->size);\n\trelease_firmware(fw);\n\tiwdebi(av7110, DEBINOSWAP, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);\n\n\tif (saa7146_wait_for_debi_done(av7110->dev, 1)) {\n\t\tprintk(KERN_ERR \"dvb-ttpci: av7110_bootarm(): saa7146_wait_for_debi_done() timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tsaa7146_setgpio(dev, RESET_LINE, SAA7146_GPIO_OUTHI);\n\tmdelay(1);\n\n\tdprintk(1, \"load dram code\\n\");\n\tif (load_dram(av7110, (u32 *)av7110->bin_root, av7110->size_root) < 0) {\n\t\tprintk(KERN_ERR \"dvb-ttpci: av7110_bootarm(): load_dram() failed\\n\");\n\t\treturn -1;\n\t}\n\n\tsaa7146_setgpio(dev, RESET_LINE, SAA7146_GPIO_OUTLO);\n\tmdelay(1);\n\n\tdprintk(1, \"load dpram code\\n\");\n\tmwdebi(av7110, DEBISWAB, DPRAM_BASE, av7110->bin_dpram, av7110->size_dpram);\n\n\tif (saa7146_wait_for_debi_done(av7110->dev, 1)) {\n\t\tprintk(KERN_ERR \"dvb-ttpci: av7110_bootarm(): saa7146_wait_for_debi_done() timed out after loading DRAM\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tsaa7146_setgpio(dev, RESET_LINE, SAA7146_GPIO_OUTHI);\n\tmsleep(30);\t \n\n\t\n\tARM_ResetMailBox(av7110);\n\tSAA7146_ISR_CLEAR(av7110->dev, MASK_19 | MASK_03);\n\tSAA7146_IER_ENABLE(av7110->dev, MASK_03);\n\n\tav7110->arm_errors = 0;\n\tav7110->arm_ready = 1;\n\treturn 0;\n}\nMODULE_FIRMWARE(\"av7110/bootcode.bin\");\n\n \n\nint av7110_wait_msgstate(struct av7110 *av7110, u16 flags)\n{\n\tunsigned long start;\n\tu32 stat;\n\tint err;\n\n\tif (FW_VERSION(av7110->arm_app) <= 0x261c) {\n\t\t \n\t\tmsleep(50);\n\t\treturn 0;\n\t}\n\n\t \n\tstart = jiffies;\n\tfor (;;) {\n\t\terr = time_after(jiffies, start + ARM_WAIT_FREE);\n\t\tif (mutex_lock_interruptible(&av7110->dcomlock))\n\t\t\treturn -ERESTARTSYS;\n\t\tstat = rdebi(av7110, DEBINOSWAP, MSGSTATE, 0, 2);\n\t\tmutex_unlock(&av7110->dcomlock);\n\t\tif ((stat & flags) == 0)\n\t\t\tbreak;\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: timeout waiting for MSGSTATE %04x\\n\",\n\t\t\t\t__func__, stat & flags);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(1);\n\t}\n\treturn 0;\n}\n\nstatic int __av7110_send_fw_cmd(struct av7110 *av7110, u16* buf, int length)\n{\n\tint i;\n\tunsigned long start;\n\tchar *type = NULL;\n\tu16 flags[2] = {0, 0};\n\tu32 stat;\n\tint err;\n\n\n\n\tif (!av7110->arm_ready) {\n\t\tdprintk(1, \"arm not ready.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tstart = jiffies;\n\twhile (1) {\n\t\terr = time_after(jiffies, start + ARM_WAIT_FREE);\n\t\tif (rdebi(av7110, DEBINOSWAP, COMMAND, 0, 2) == 0)\n\t\t\tbreak;\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"dvb-ttpci: %s(): timeout waiting for COMMAND idle\\n\", __func__);\n\t\t\tav7110->arm_errors++;\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\tif (FW_VERSION(av7110->arm_app) <= 0x261f)\n\t\twdebi(av7110, DEBINOSWAP, COM_IF_LOCK, 0xffff, 2);\n\n#ifndef _NOHANDSHAKE\n\tstart = jiffies;\n\twhile (1) {\n\t\terr = time_after(jiffies, start + ARM_WAIT_SHAKE);\n\t\tif (rdebi(av7110, DEBINOSWAP, HANDSHAKE_REG, 0, 2) == 0)\n\t\t\tbreak;\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"dvb-ttpci: %s(): timeout waiting for HANDSHAKE_REG\\n\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(1);\n\t}\n#endif\n\n\tswitch ((buf[0] >> 8) & 0xff) {\n\tcase COMTYPE_PIDFILTER:\n\tcase COMTYPE_ENCODER:\n\tcase COMTYPE_REC_PLAY:\n\tcase COMTYPE_MPEGDECODER:\n\t\ttype = \"MSG\";\n\t\tflags[0] = GPMQOver;\n\t\tflags[1] = GPMQFull;\n\t\tbreak;\n\tcase COMTYPE_OSD:\n\t\ttype = \"OSD\";\n\t\tflags[0] = OSDQOver;\n\t\tflags[1] = OSDQFull;\n\t\tbreak;\n\tcase COMTYPE_MISC:\n\t\tif (FW_VERSION(av7110->arm_app) >= 0x261d) {\n\t\t\ttype = \"MSG\";\n\t\t\tflags[0] = GPMQOver;\n\t\t\tflags[1] = GPMQBusy;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (type != NULL) {\n\t\t \n\t\tstart = jiffies;\n\t\tfor (;;) {\n\t\t\terr = time_after(jiffies, start + ARM_WAIT_FREE);\n\t\t\tstat = rdebi(av7110, DEBINOSWAP, MSGSTATE, 0, 2);\n\t\t\tif (stat & flags[0]) {\n\t\t\t\tprintk(KERN_ERR \"%s: %s QUEUE overflow\\n\",\n\t\t\t\t\t__func__, type);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((stat & flags[1]) == 0)\n\t\t\t\tbreak;\n\t\t\tif (err) {\n\t\t\t\tprintk(KERN_ERR \"%s: timeout waiting on busy %s QUEUE\\n\",\n\t\t\t\t\t__func__, type);\n\t\t\t\tav7110->arm_errors++;\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t\tmsleep(1);\n\t\t}\n\t}\n\n\tfor (i = 2; i < length; i++)\n\t\twdebi(av7110, DEBINOSWAP, COMMAND + 2 * i, (u32) buf[i], 2);\n\n\tif (length)\n\t\twdebi(av7110, DEBINOSWAP, COMMAND + 2, (u32) buf[1], 2);\n\telse\n\t\twdebi(av7110, DEBINOSWAP, COMMAND + 2, 0, 2);\n\n\twdebi(av7110, DEBINOSWAP, COMMAND, (u32) buf[0], 2);\n\n\tif (FW_VERSION(av7110->arm_app) <= 0x261f)\n\t\twdebi(av7110, DEBINOSWAP, COM_IF_LOCK, 0x0000, 2);\n\n#ifdef COM_DEBUG\n\tstart = jiffies;\n\twhile (1) {\n\t\terr = time_after(jiffies, start + ARM_WAIT_FREE);\n\t\tif (rdebi(av7110, DEBINOSWAP, COMMAND, 0, 2) == 0)\n\t\t\tbreak;\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"dvb-ttpci: %s(): timeout waiting for COMMAND %d to complete\\n\",\n\t\t\t       __func__, (buf[0] >> 8) & 0xff);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\tstat = rdebi(av7110, DEBINOSWAP, MSGSTATE, 0, 2);\n\tif (stat & GPMQOver) {\n\t\tprintk(KERN_ERR \"dvb-ttpci: %s(): GPMQOver\\n\", __func__);\n\t\treturn -ENOSPC;\n\t}\n\telse if (stat & OSDQOver) {\n\t\tprintk(KERN_ERR \"dvb-ttpci: %s(): OSDQOver\\n\", __func__);\n\t\treturn -ENOSPC;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic int av7110_send_fw_cmd(struct av7110 *av7110, u16* buf, int length)\n{\n\tint ret;\n\n\n\n\tif (!av7110->arm_ready) {\n\t\tdprintk(1, \"arm not ready.\\n\");\n\t\treturn -1;\n\t}\n\tif (mutex_lock_interruptible(&av7110->dcomlock))\n\t\treturn -ERESTARTSYS;\n\n\tret = __av7110_send_fw_cmd(av7110, buf, length);\n\tmutex_unlock(&av7110->dcomlock);\n\tif (ret && ret!=-ERESTARTSYS)\n\t\tprintk(KERN_ERR \"dvb-ttpci: %s(): av7110_send_fw_cmd error %d\\n\",\n\t\t       __func__, ret);\n\treturn ret;\n}\n\nint av7110_fw_cmd(struct av7110 *av7110, int type, int com, int num, ...)\n{\n\tva_list args;\n\tu16 buf[MAX_XFER_SIZE];\n\tint i, ret;\n\n\n\n\tif (2 + num > ARRAY_SIZE(buf)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: %s len=%d is too big!\\n\",\n\t\t       KBUILD_MODNAME, __func__, num);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf[0] = ((type << 8) | com);\n\tbuf[1] = num;\n\n\tif (num) {\n\t\tva_start(args, num);\n\t\tfor (i = 0; i < num; i++)\n\t\t\tbuf[i + 2] = va_arg(args, u32);\n\t\tva_end(args);\n\t}\n\n\tret = av7110_send_fw_cmd(av7110, buf, num + 2);\n\tif (ret && ret != -ERESTARTSYS)\n\t\tprintk(KERN_ERR \"dvb-ttpci: av7110_fw_cmd error %d\\n\", ret);\n\treturn ret;\n}\n\n#if 0\nint av7110_send_ci_cmd(struct av7110 *av7110, u8 subcom, u8 *buf, u8 len)\n{\n\tint i, ret;\n\tu16 cmd[18] = { ((COMTYPE_COMMON_IF << 8) + subcom),\n\t\t16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tfor(i = 0; i < len && i < 32; i++)\n\t{\n\t\tif(i % 2 == 0)\n\t\t\tcmd[(i / 2) + 2] = (u16)(buf[i]) << 8;\n\t\telse\n\t\t\tcmd[(i / 2) + 2] |= buf[i];\n\t}\n\n\tret = av7110_send_fw_cmd(av7110, cmd, 18);\n\tif (ret && ret != -ERESTARTSYS)\n\t\tprintk(KERN_ERR \"dvb-ttpci: av7110_send_ci_cmd error %d\\n\", ret);\n\treturn ret;\n}\n#endif   \n\nint av7110_fw_request(struct av7110 *av7110, u16 *request_buf,\n\t\t      int request_buf_len, u16 *reply_buf, int reply_buf_len)\n{\n\tint err;\n\ts16 i;\n\tunsigned long start;\n#ifdef COM_DEBUG\n\tu32 stat;\n#endif\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (!av7110->arm_ready) {\n\t\tdprintk(1, \"arm not ready.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (mutex_lock_interruptible(&av7110->dcomlock))\n\t\treturn -ERESTARTSYS;\n\n\tif ((err = __av7110_send_fw_cmd(av7110, request_buf, request_buf_len)) < 0) {\n\t\tmutex_unlock(&av7110->dcomlock);\n\t\tprintk(KERN_ERR \"dvb-ttpci: av7110_fw_request error %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tstart = jiffies;\n\twhile (1) {\n\t\terr = time_after(jiffies, start + ARM_WAIT_FREE);\n\t\tif (rdebi(av7110, DEBINOSWAP, COMMAND, 0, 2) == 0)\n\t\t\tbreak;\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: timeout waiting for COMMAND to complete\\n\", __func__);\n\t\t\tmutex_unlock(&av7110->dcomlock);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n#ifdef _NOHANDSHAKE\n\t\tmsleep(1);\n#endif\n\t}\n\n#ifndef _NOHANDSHAKE\n\tstart = jiffies;\n\twhile (1) {\n\t\terr = time_after(jiffies, start + ARM_WAIT_SHAKE);\n\t\tif (rdebi(av7110, DEBINOSWAP, HANDSHAKE_REG, 0, 2) == 0)\n\t\t\tbreak;\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: timeout waiting for HANDSHAKE_REG\\n\", __func__);\n\t\t\tmutex_unlock(&av7110->dcomlock);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(1);\n\t}\n#endif\n\n#ifdef COM_DEBUG\n\tstat = rdebi(av7110, DEBINOSWAP, MSGSTATE, 0, 2);\n\tif (stat & GPMQOver) {\n\t\tprintk(KERN_ERR \"%s: GPMQOver\\n\", __func__);\n\t\tmutex_unlock(&av7110->dcomlock);\n\t\treturn -1;\n\t}\n\telse if (stat & OSDQOver) {\n\t\tprintk(KERN_ERR \"%s: OSDQOver\\n\", __func__);\n\t\tmutex_unlock(&av7110->dcomlock);\n\t\treturn -1;\n\t}\n#endif\n\n\tfor (i = 0; i < reply_buf_len; i++)\n\t\treply_buf[i] = rdebi(av7110, DEBINOSWAP, COM_BUFF + 2 * i, 0, 2);\n\n\tmutex_unlock(&av7110->dcomlock);\n\treturn 0;\n}\n\nstatic int av7110_fw_query(struct av7110 *av7110, u16 tag, u16* buf, s16 length)\n{\n\tint ret;\n\tret = av7110_fw_request(av7110, &tag, 0, buf, length);\n\tif (ret)\n\t\tprintk(KERN_ERR \"dvb-ttpci: av7110_fw_query error %d\\n\", ret);\n\treturn ret;\n}\n\n\n \n\n \nint av7110_firmversion(struct av7110 *av7110)\n{\n\tu16 buf[20];\n\tu16 tag = ((COMTYPE_REQUEST << 8) + ReqVersion);\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (av7110_fw_query(av7110, tag, buf, 16)) {\n\t\tprintk(\"dvb-ttpci: failed to boot firmware @ card %d\\n\",\n\t\t       av7110->dvb_adapter.num);\n\t\treturn -EIO;\n\t}\n\n\tav7110->arm_fw = (buf[0] << 16) + buf[1];\n\tav7110->arm_rtsl = (buf[2] << 16) + buf[3];\n\tav7110->arm_vid = (buf[4] << 16) + buf[5];\n\tav7110->arm_app = (buf[6] << 16) + buf[7];\n\tav7110->avtype = (buf[8] << 16) + buf[9];\n\n\tprintk(\"dvb-ttpci: info @ card %d: firm %08x, rtsl %08x, vid %08x, app %08x\\n\",\n\t       av7110->dvb_adapter.num, av7110->arm_fw,\n\t       av7110->arm_rtsl, av7110->arm_vid, av7110->arm_app);\n\n\t \n\tif (FW_CI_LL_SUPPORT(av7110->arm_app))\n\t\tprintk(\"dvb-ttpci: firmware @ card %d supports CI link layer interface\\n\",\n\t\t       av7110->dvb_adapter.num);\n\telse\n\t\tprintk(\"dvb-ttpci: no firmware support for CI link layer interface @ card %d\\n\",\n\t\t       av7110->dvb_adapter.num);\n\n\treturn 0;\n}\n\n\nint av7110_diseqc_send(struct av7110 *av7110, int len, u8 *msg, unsigned long burst)\n{\n\tint i, ret;\n\tu16 buf[18] = { ((COMTYPE_AUDIODAC << 8) + SendDiSEqC),\n\t\t\t16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (len > 10)\n\t\tlen = 10;\n\n\tbuf[1] = len + 2;\n\tbuf[2] = len;\n\n\tif (burst != -1)\n\t\tbuf[3] = burst ? 0x01 : 0x00;\n\telse\n\t\tbuf[3] = 0xffff;\n\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i + 4] = msg[i];\n\n\tret = av7110_send_fw_cmd(av7110, buf, 18);\n\tif (ret && ret!=-ERESTARTSYS)\n\t\tprintk(KERN_ERR \"dvb-ttpci: av7110_diseqc_send error %d\\n\", ret);\n\treturn ret;\n}\n\n\n#ifdef CONFIG_DVB_AV7110_OSD\n\nstatic inline int SetColorBlend(struct av7110 *av7110, u8 windownr)\n{\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, SetCBlend, 1, windownr);\n}\n\nstatic inline int SetBlend_(struct av7110 *av7110, u8 windownr,\n\t\t     enum av7110_osd_palette_type colordepth, u16 index, u8 blending)\n{\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, SetBlend, 4,\n\t\t\t     windownr, colordepth, index, blending);\n}\n\nstatic inline int SetColor_(struct av7110 *av7110, u8 windownr,\n\t\t     enum av7110_osd_palette_type colordepth, u16 index, u16 colorhi, u16 colorlo)\n{\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, SetColor, 5,\n\t\t\t     windownr, colordepth, index, colorhi, colorlo);\n}\n\nstatic inline int SetFont(struct av7110 *av7110, u8 windownr, u8 fontsize,\n\t\t\t  u16 colorfg, u16 colorbg)\n{\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, Set_Font, 4,\n\t\t\t     windownr, fontsize, colorfg, colorbg);\n}\n\nstatic int FlushText(struct av7110 *av7110)\n{\n\tunsigned long start;\n\tint err;\n\n\tif (mutex_lock_interruptible(&av7110->dcomlock))\n\t\treturn -ERESTARTSYS;\n\tstart = jiffies;\n\twhile (1) {\n\t\terr = time_after(jiffies, start + ARM_WAIT_OSD);\n\t\tif (rdebi(av7110, DEBINOSWAP, BUFF1_BASE, 0, 2) == 0)\n\t\t\tbreak;\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"dvb-ttpci: %s(): timeout waiting for BUFF1_BASE == 0\\n\",\n\t\t\t       __func__);\n\t\t\tmutex_unlock(&av7110->dcomlock);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(1);\n\t}\n\tmutex_unlock(&av7110->dcomlock);\n\treturn 0;\n}\n\nstatic int WriteText(struct av7110 *av7110, u8 win, u16 x, u16 y, char *buf)\n{\n\tint i, ret;\n\tunsigned long start;\n\tint length = strlen(buf) + 1;\n\tu16 cbuf[5] = { (COMTYPE_OSD << 8) + DText, 3, win, x, y };\n\n\tif (mutex_lock_interruptible(&av7110->dcomlock))\n\t\treturn -ERESTARTSYS;\n\n\tstart = jiffies;\n\twhile (1) {\n\t\tret = time_after(jiffies, start + ARM_WAIT_OSD);\n\t\tif (rdebi(av7110, DEBINOSWAP, BUFF1_BASE, 0, 2) == 0)\n\t\t\tbreak;\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"dvb-ttpci: %s: timeout waiting for BUFF1_BASE == 0\\n\",\n\t\t\t       __func__);\n\t\t\tmutex_unlock(&av7110->dcomlock);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(1);\n\t}\n#ifndef _NOHANDSHAKE\n\tstart = jiffies;\n\twhile (1) {\n\t\tret = time_after(jiffies, start + ARM_WAIT_SHAKE);\n\t\tif (rdebi(av7110, DEBINOSWAP, HANDSHAKE_REG, 0, 2) == 0)\n\t\t\tbreak;\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"dvb-ttpci: %s: timeout waiting for HANDSHAKE_REG\\n\",\n\t\t\t       __func__);\n\t\t\tmutex_unlock(&av7110->dcomlock);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(1);\n\t}\n#endif\n\tfor (i = 0; i < length / 2; i++)\n\t\twdebi(av7110, DEBINOSWAP, BUFF1_BASE + i * 2,\n\t\t      swab16(*(u16 *)(buf + 2 * i)), 2);\n\tif (length & 1)\n\t\twdebi(av7110, DEBINOSWAP, BUFF1_BASE + i * 2, 0, 2);\n\tret = __av7110_send_fw_cmd(av7110, cbuf, 5);\n\tmutex_unlock(&av7110->dcomlock);\n\tif (ret && ret!=-ERESTARTSYS)\n\t\tprintk(KERN_ERR \"dvb-ttpci: WriteText error %d\\n\", ret);\n\treturn ret;\n}\n\nstatic inline int DrawLine(struct av7110 *av7110, u8 windownr,\n\t\t\t   u16 x, u16 y, u16 dx, u16 dy, u16 color)\n{\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, DLine, 6,\n\t\t\t     windownr, x, y, dx, dy, color);\n}\n\nstatic inline int DrawBlock(struct av7110 *av7110, u8 windownr,\n\t\t\t    u16 x, u16 y, u16 dx, u16 dy, u16 color)\n{\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, DBox, 6,\n\t\t\t     windownr, x, y, dx, dy, color);\n}\n\nstatic inline int HideWindow(struct av7110 *av7110, u8 windownr)\n{\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, WHide, 1, windownr);\n}\n\nstatic inline int MoveWindowRel(struct av7110 *av7110, u8 windownr, u16 x, u16 y)\n{\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, WMoveD, 3, windownr, x, y);\n}\n\nstatic inline int MoveWindowAbs(struct av7110 *av7110, u8 windownr, u16 x, u16 y)\n{\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, WMoveA, 3, windownr, x, y);\n}\n\nstatic inline int DestroyOSDWindow(struct av7110 *av7110, u8 windownr)\n{\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, WDestroy, 1, windownr);\n}\n\nstatic inline int CreateOSDWindow(struct av7110 *av7110, u8 windownr,\n\t\t\t\t  osd_raw_window_t disptype,\n\t\t\t\t  u16 width, u16 height)\n{\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, WCreate, 4,\n\t\t\t     windownr, disptype, width, height);\n}\n\n\nstatic enum av7110_osd_palette_type bpp2pal[8] = {\n\tPal1Bit, Pal2Bit, 0, Pal4Bit, 0, 0, 0, Pal8Bit\n};\nstatic osd_raw_window_t bpp2bit[8] = {\n\tOSD_BITMAP1, OSD_BITMAP2, 0, OSD_BITMAP4, 0, 0, 0, OSD_BITMAP8\n};\n\nstatic inline int WaitUntilBmpLoaded(struct av7110 *av7110)\n{\n\tint ret = wait_event_timeout(av7110->bmpq,\n\t\t\t\tav7110->bmp_state != BMP_LOADING, 10*HZ);\n\tif (ret == 0) {\n\t\tprintk(\"dvb-ttpci: warning: timeout waiting in LoadBitmap: %d, %d\\n\",\n\t\t       ret, av7110->bmp_state);\n\t\tav7110->bmp_state = BMP_NONE;\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\nstatic inline int LoadBitmap(struct av7110 *av7110,\n\t\t\t     u16 dx, u16 dy, int inc, u8 __user * data)\n{\n\tu16 format;\n\tint bpp;\n\tint i;\n\tint d, delta;\n\tu8 c;\n\tint ret;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tformat = bpp2bit[av7110->osdbpp[av7110->osdwin]];\n\n\tav7110->bmp_state = BMP_LOADING;\n\tif\t(format == OSD_BITMAP8) {\n\t\tbpp=8; delta = 1;\n\t} else if (format == OSD_BITMAP4) {\n\t\tbpp=4; delta = 2;\n\t} else if (format == OSD_BITMAP2) {\n\t\tbpp=2; delta = 4;\n\t} else if (format == OSD_BITMAP1) {\n\t\tbpp=1; delta = 8;\n\t} else {\n\t\tav7110->bmp_state = BMP_NONE;\n\t\treturn -EINVAL;\n\t}\n\tav7110->bmplen = ((dx * dy * bpp + 7) & ~7) / 8;\n\tav7110->bmpp = 0;\n\tif (av7110->bmplen > 32768) {\n\t\tav7110->bmp_state = BMP_NONE;\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < dy; i++) {\n\t\tif (copy_from_user(av7110->bmpbuf + 1024 + i * dx, data + i * inc, dx)) {\n\t\t\tav7110->bmp_state = BMP_NONE;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (format != OSD_BITMAP8) {\n\t\tfor (i = 0; i < dx * dy / delta; i++) {\n\t\t\tc = ((u8 *)av7110->bmpbuf)[1024 + i * delta + delta - 1];\n\t\t\tfor (d = delta - 2; d >= 0; d--) {\n\t\t\t\tc |= (((u8 *)av7110->bmpbuf)[1024 + i * delta + d]\n\t\t\t\t      << ((delta - d - 1) * bpp));\n\t\t\t\t((u8 *)av7110->bmpbuf)[1024 + i] = c;\n\t\t\t}\n\t\t}\n\t}\n\tav7110->bmplen += 1024;\n\tdprintk(4, \"av7110_fw_cmd: LoadBmp size %d\\n\", av7110->bmplen);\n\tret = av7110_fw_cmd(av7110, COMTYPE_OSD, LoadBmp, 3, format, dx, dy);\n\tif (!ret)\n\t\tret = WaitUntilBmpLoaded(av7110);\n\treturn ret;\n}\n\nstatic int BlitBitmap(struct av7110 *av7110, u16 x, u16 y)\n{\n\tdprintk(4, \"%p\\n\", av7110);\n\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, BlitBmp, 4, av7110->osdwin, x, y, 0);\n}\n\nstatic inline int ReleaseBitmap(struct av7110 *av7110)\n{\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (av7110->bmp_state != BMP_LOADED && FW_VERSION(av7110->arm_app) < 0x261e)\n\t\treturn -1;\n\tif (av7110->bmp_state == BMP_LOADING)\n\t\tdprintk(1,\"ReleaseBitmap called while BMP_LOADING\\n\");\n\tav7110->bmp_state = BMP_NONE;\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, ReleaseBmp, 0);\n}\n\nstatic u32 RGB2YUV(u16 R, u16 G, u16 B)\n{\n\tu16 y, u, v;\n\tu16 Y, Cr, Cb;\n\n\ty = R * 77 + G * 150 + B * 29;\t \n\tu = 2048 + B * 8 -(y >> 5);\t \n\tv = 2048 + R * 8 -(y >> 5);\t \n\n\tY = y / 256;\n\tCb = u / 16;\n\tCr = v / 16;\n\n\treturn Cr | (Cb << 16) | (Y << 8);\n}\n\nstatic int OSDSetColor(struct av7110 *av7110, u8 color, u8 r, u8 g, u8 b, u8 blend)\n{\n\tint ret;\n\n\tu16 ch, cl;\n\tu32 yuv;\n\n\tyuv = blend ? RGB2YUV(r,g,b) : 0;\n\tcl = (yuv & 0xffff);\n\tch = ((yuv >> 16) & 0xffff);\n\tret = SetColor_(av7110, av7110->osdwin, bpp2pal[av7110->osdbpp[av7110->osdwin]],\n\t\t\tcolor, ch, cl);\n\tif (!ret)\n\t\tret = SetBlend_(av7110, av7110->osdwin, bpp2pal[av7110->osdbpp[av7110->osdwin]],\n\t\t\t\tcolor, ((blend >> 4) & 0x0f));\n\treturn ret;\n}\n\nstatic int OSDSetPalette(struct av7110 *av7110, u32 __user * colors, u8 first, u8 last)\n{\n\tint i;\n\tint length = last - first + 1;\n\n\tif (length * 4 > DATA_BUFF3_SIZE)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < length; i++) {\n\t\tu32 color, blend, yuv;\n\n\t\tif (get_user(color, colors + i))\n\t\t\treturn -EFAULT;\n\t\tblend = (color & 0xF0000000) >> 4;\n\t\tyuv = blend ? RGB2YUV(color & 0xFF, (color >> 8) & 0xFF,\n\t\t\t\t     (color >> 16) & 0xFF) | blend : 0;\n\t\tyuv = ((yuv & 0xFFFF0000) >> 16) | ((yuv & 0x0000FFFF) << 16);\n\t\twdebi(av7110, DEBINOSWAP, DATA_BUFF3_BASE + i * 4, yuv, 4);\n\t}\n\treturn av7110_fw_cmd(av7110, COMTYPE_OSD, Set_Palette, 4,\n\t\t\t    av7110->osdwin,\n\t\t\t    bpp2pal[av7110->osdbpp[av7110->osdwin]],\n\t\t\t    first, last);\n}\n\nstatic int OSDSetBlock(struct av7110 *av7110, int x0, int y0,\n\t\t       int x1, int y1, int inc, u8 __user * data)\n{\n\tuint w, h, bpp, bpl, size, lpb, bnum, brest;\n\tint i;\n\tint rc,release_rc;\n\n\tw = x1 - x0 + 1;\n\th = y1 - y0 + 1;\n\tif (inc <= 0)\n\t\tinc = w;\n\tif (w <= 0 || w > 720 || h <= 0 || h > 576)\n\t\treturn -EINVAL;\n\tbpp = av7110->osdbpp[av7110->osdwin] + 1;\n\tbpl = ((w * bpp + 7) & ~7) / 8;\n\tsize = h * bpl;\n\tlpb = (32 * 1024) / bpl;\n\tbnum = size / (lpb * bpl);\n\tbrest = size - bnum * lpb * bpl;\n\n\tif (av7110->bmp_state == BMP_LOADING) {\n\t\t \n\t\tif (WARN_ON(FW_VERSION(av7110->arm_app) >= 0x261e))\n\t\t\treturn -EIO;\n\t\trc = WaitUntilBmpLoaded(av7110);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t \n\t}\n\n\trc = 0;\n\tfor (i = 0; i < bnum; i++) {\n\t\trc = LoadBitmap(av7110, w, lpb, inc, data);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = BlitBitmap(av7110, x0, y0 + i * lpb);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tdata += lpb * inc;\n\t}\n\tif (!rc && brest) {\n\t\trc = LoadBitmap(av7110, w, brest / bpl, inc, data);\n\t\tif (!rc)\n\t\t\trc = BlitBitmap(av7110, x0, y0 + bnum * lpb);\n\t}\n\trelease_rc = ReleaseBitmap(av7110);\n\tif (!rc)\n\t\trc = release_rc;\n\tif (rc)\n\t\tdprintk(1,\"returns %d\\n\",rc);\n\treturn rc;\n}\n\nint av7110_osd_cmd(struct av7110 *av7110, osd_cmd_t *dc)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&av7110->osd_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (dc->cmd) {\n\tcase OSD_Close:\n\t\tret = DestroyOSDWindow(av7110, av7110->osdwin);\n\t\tbreak;\n\tcase OSD_Open:\n\t\tav7110->osdbpp[av7110->osdwin] = (dc->color - 1) & 7;\n\t\tret = CreateOSDWindow(av7110, av7110->osdwin,\n\t\t\t\tbpp2bit[av7110->osdbpp[av7110->osdwin]],\n\t\t\t\tdc->x1 - dc->x0 + 1, dc->y1 - dc->y0 + 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!dc->data) {\n\t\t\tret = MoveWindowAbs(av7110, av7110->osdwin, dc->x0, dc->y0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tret = SetColorBlend(av7110, av7110->osdwin);\n\t\t}\n\t\tbreak;\n\tcase OSD_Show:\n\t\tret = MoveWindowRel(av7110, av7110->osdwin, 0, 0);\n\t\tbreak;\n\tcase OSD_Hide:\n\t\tret = HideWindow(av7110, av7110->osdwin);\n\t\tbreak;\n\tcase OSD_Clear:\n\t\tret = DrawBlock(av7110, av7110->osdwin, 0, 0, 720, 576, 0);\n\t\tbreak;\n\tcase OSD_Fill:\n\t\tret = DrawBlock(av7110, av7110->osdwin, 0, 0, 720, 576, dc->color);\n\t\tbreak;\n\tcase OSD_SetColor:\n\t\tret = OSDSetColor(av7110, dc->color, dc->x0, dc->y0, dc->x1, dc->y1);\n\t\tbreak;\n\tcase OSD_SetPalette:\n\t\tif (FW_VERSION(av7110->arm_app) >= 0x2618)\n\t\t\tret = OSDSetPalette(av7110, dc->data, dc->color, dc->x0);\n\t\telse {\n\t\t\tint i, len = dc->x0-dc->color+1;\n\t\t\tu8 __user *colors = (u8 __user *)dc->data;\n\t\t\tu8 r, g = 0, b = 0, blend = 0;\n\t\t\tret = 0;\n\t\t\tfor (i = 0; i<len; i++) {\n\t\t\t\tif (get_user(r, colors + i * 4) ||\n\t\t\t\t    get_user(g, colors + i * 4 + 1) ||\n\t\t\t\t    get_user(b, colors + i * 4 + 2) ||\n\t\t\t\t    get_user(blend, colors + i * 4 + 3)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\tret = OSDSetColor(av7110, dc->color + i, r, g, b, blend);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OSD_SetPixel:\n\t\tret = DrawLine(av7110, av7110->osdwin,\n\t\t\t dc->x0, dc->y0, 0, 0, dc->color);\n\t\tbreak;\n\tcase OSD_SetRow:\n\t\tdc->y1 = dc->y0;\n\t\tfallthrough;\n\tcase OSD_SetBlock:\n\t\tret = OSDSetBlock(av7110, dc->x0, dc->y0, dc->x1, dc->y1, dc->color, dc->data);\n\t\tbreak;\n\tcase OSD_FillRow:\n\t\tret = DrawBlock(av7110, av7110->osdwin, dc->x0, dc->y0,\n\t\t\t  dc->x1-dc->x0+1, dc->y1, dc->color);\n\t\tbreak;\n\tcase OSD_FillBlock:\n\t\tret = DrawBlock(av7110, av7110->osdwin, dc->x0, dc->y0,\n\t\t\t  dc->x1 - dc->x0 + 1, dc->y1 - dc->y0 + 1, dc->color);\n\t\tbreak;\n\tcase OSD_Line:\n\t\tret = DrawLine(av7110, av7110->osdwin,\n\t\t\t dc->x0, dc->y0, dc->x1 - dc->x0, dc->y1 - dc->y0, dc->color);\n\t\tbreak;\n\tcase OSD_Text:\n\t{\n\t\tchar textbuf[240];\n\n\t\tif (strncpy_from_user(textbuf, dc->data, 240) < 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\ttextbuf[239] = 0;\n\t\tif (dc->x1 > 3)\n\t\t\tdc->x1 = 3;\n\t\tret = SetFont(av7110, av7110->osdwin, dc->x1,\n\t\t\t(u16) (dc->color & 0xffff), (u16) (dc->color >> 16));\n\t\tif (!ret)\n\t\t\tret = FlushText(av7110);\n\t\tif (!ret)\n\t\t\tret = WriteText(av7110, av7110->osdwin, dc->x0, dc->y0, textbuf);\n\t\tbreak;\n\t}\n\tcase OSD_SetWindow:\n\t\tif (dc->x0 < 1 || dc->x0 > 7)\n\t\t\tret = -EINVAL;\n\t\telse {\n\t\t\tav7110->osdwin = dc->x0;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\tcase OSD_MoveWindow:\n\t\tret = MoveWindowAbs(av7110, av7110->osdwin, dc->x0, dc->y0);\n\t\tif (!ret)\n\t\t\tret = SetColorBlend(av7110, av7110->osdwin);\n\t\tbreak;\n\tcase OSD_OpenRaw:\n\t\tif (dc->color < OSD_BITMAP1 || dc->color > OSD_CURSOR) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dc->color >= OSD_BITMAP1 && dc->color <= OSD_BITMAP8HR)\n\t\t\tav7110->osdbpp[av7110->osdwin] = (1 << (dc->color & 3)) - 1;\n\t\telse\n\t\t\tav7110->osdbpp[av7110->osdwin] = 0;\n\t\tret = CreateOSDWindow(av7110, av7110->osdwin, (osd_raw_window_t)dc->color,\n\t\t\t\tdc->x1 - dc->x0 + 1, dc->y1 - dc->y0 + 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!dc->data) {\n\t\t\tret = MoveWindowAbs(av7110, av7110->osdwin, dc->x0, dc->y0);\n\t\t\tif (!ret)\n\t\t\t\tret = SetColorBlend(av7110, av7110->osdwin);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&av7110->osd_mutex);\n\tif (ret==-ERESTARTSYS)\n\t\tdprintk(1, \"av7110_osd_cmd(%d) returns with -ERESTARTSYS\\n\",dc->cmd);\n\telse if (ret)\n\t\tdprintk(1, \"av7110_osd_cmd(%d) returns with %d\\n\",dc->cmd,ret);\n\n\treturn ret;\n}\n\nint av7110_osd_capability(struct av7110 *av7110, osd_cap_t *cap)\n{\n\tswitch (cap->cmd) {\n\tcase OSD_CAP_MEMSIZE:\n\t\tif (FW_4M_SDRAM(av7110->arm_app))\n\t\t\tcap->val = 1000000;\n\t\telse\n\t\t\tcap->val = 92000;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}