{
  "module_name": "av7110_ca.c",
  "hash_id": "0f91e4ab17da967a87f5f76a4d29103e9ee05fe44cbea9d91c9e3e3a793e5e81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/av7110/av7110_ca.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/timer.h>\n#include <linux/poll.h>\n#include <linux/gfp.h>\n\n#include \"av7110.h\"\n#include \"av7110_hw.h\"\n#include \"av7110_ca.h\"\n\n\nvoid CI_handle(struct av7110 *av7110, u8 *data, u16 len)\n{\n\tdprintk(8, \"av7110:%p\\n\",av7110);\n\n\tif (len < 3)\n\t\treturn;\n\tswitch (data[0]) {\n\tcase CI_MSG_CI_INFO:\n\t\tif (data[2] != 1 && data[2] != 2)\n\t\t\tbreak;\n\t\tswitch (data[1]) {\n\t\tcase 0:\n\t\t\tav7110->ci_slot[data[2] - 1].flags = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tav7110->ci_slot[data[2] - 1].flags |= CA_CI_MODULE_PRESENT;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tav7110->ci_slot[data[2] - 1].flags |= CA_CI_MODULE_READY;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CI_SWITCH_PRG_REPLY:\n\t\t\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n\nvoid ci_get_data(struct dvb_ringbuffer *cibuf, u8 *data, int len)\n{\n\tif (dvb_ringbuffer_free(cibuf) < len + 2)\n\t\treturn;\n\n\tDVB_RINGBUFFER_WRITE_BYTE(cibuf, len >> 8);\n\tDVB_RINGBUFFER_WRITE_BYTE(cibuf, len & 0xff);\n\tdvb_ringbuffer_write(cibuf, data, len);\n\twake_up_interruptible(&cibuf->queue);\n}\n\n\n \n\nstatic int ci_ll_init(struct dvb_ringbuffer *cirbuf, struct dvb_ringbuffer *ciwbuf, int size)\n{\n\tstruct dvb_ringbuffer *tab[] = { cirbuf, ciwbuf, NULL }, **p;\n\tvoid *data;\n\n\tfor (p = tab; *p; p++) {\n\t\tdata = vmalloc(size);\n\t\tif (!data) {\n\t\t\twhile (p-- != tab) {\n\t\t\t\tvfree(p[0]->data);\n\t\t\t\tp[0]->data = NULL;\n\t\t\t}\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdvb_ringbuffer_init(*p, data, size);\n\t}\n\treturn 0;\n}\n\nstatic void ci_ll_flush(struct dvb_ringbuffer *cirbuf, struct dvb_ringbuffer *ciwbuf)\n{\n\tdvb_ringbuffer_flush_spinlock_wakeup(cirbuf);\n\tdvb_ringbuffer_flush_spinlock_wakeup(ciwbuf);\n}\n\nstatic void ci_ll_release(struct dvb_ringbuffer *cirbuf, struct dvb_ringbuffer *ciwbuf)\n{\n\tvfree(cirbuf->data);\n\tcirbuf->data = NULL;\n\tvfree(ciwbuf->data);\n\tciwbuf->data = NULL;\n}\n\nstatic int ci_ll_reset(struct dvb_ringbuffer *cibuf, struct file *file,\n\t\t       int slots, struct ca_slot_info *slot)\n{\n\tint i;\n\tint len = 0;\n\tu8 msg[8] = { 0x00, 0x06, 0x00, 0x00, 0xff, 0x02, 0x00, 0x00 };\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (slots & (1 << i))\n\t\t\tlen += 8;\n\t}\n\n\tif (dvb_ringbuffer_free(cibuf) < len)\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (slots & (1 << i)) {\n\t\t\tmsg[2] = i;\n\t\t\tdvb_ringbuffer_write(cibuf, msg, 8);\n\t\t\tslot[i].flags = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t ci_ll_write(struct dvb_ringbuffer *cibuf, struct file *file,\n\t\t\t   const char __user *buf, size_t count, loff_t *ppos)\n{\n\tint free;\n\tint non_blocking = file->f_flags & O_NONBLOCK;\n\tu8 *page = (u8 *)__get_free_page(GFP_USER);\n\tint res;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tres = -EINVAL;\n\tif (count > 2048)\n\t\tgoto out;\n\n\tres = -EFAULT;\n\tif (copy_from_user(page, buf, count))\n\t\tgoto out;\n\n\tfree = dvb_ringbuffer_free(cibuf);\n\tif (count + 2 > free) {\n\t\tres = -EWOULDBLOCK;\n\t\tif (non_blocking)\n\t\t\tgoto out;\n\t\tres = -ERESTARTSYS;\n\t\tif (wait_event_interruptible(cibuf->queue,\n\t\t\t\t\t     (dvb_ringbuffer_free(cibuf) >= count + 2)))\n\t\t\tgoto out;\n\t}\n\n\tDVB_RINGBUFFER_WRITE_BYTE(cibuf, count >> 8);\n\tDVB_RINGBUFFER_WRITE_BYTE(cibuf, count & 0xff);\n\n\tres = dvb_ringbuffer_write(cibuf, page, count);\nout:\n\tfree_page((unsigned long)page);\n\treturn res;\n}\n\nstatic ssize_t ci_ll_read(struct dvb_ringbuffer *cibuf, struct file *file,\n\t\t\t  char __user *buf, size_t count, loff_t *ppos)\n{\n\tint avail;\n\tint non_blocking = file->f_flags & O_NONBLOCK;\n\tssize_t len;\n\n\tif (!cibuf->data || !count)\n\t\treturn 0;\n\tif (non_blocking && (dvb_ringbuffer_empty(cibuf)))\n\t\treturn -EWOULDBLOCK;\n\tif (wait_event_interruptible(cibuf->queue,\n\t\t\t\t     !dvb_ringbuffer_empty(cibuf)))\n\t\treturn -ERESTARTSYS;\n\tavail = dvb_ringbuffer_avail(cibuf);\n\tif (avail < 4)\n\t\treturn 0;\n\tlen = DVB_RINGBUFFER_PEEK(cibuf, 0) << 8;\n\tlen |= DVB_RINGBUFFER_PEEK(cibuf, 1);\n\tif (avail < len + 2 || count < len)\n\t\treturn -EINVAL;\n\tDVB_RINGBUFFER_SKIP(cibuf, 2);\n\n\treturn dvb_ringbuffer_read_user(cibuf, buf, len);\n}\n\nstatic int dvb_ca_open(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\tint err = dvb_generic_open(inode, file);\n\n\tdprintk(8, \"av7110:%p\\n\",av7110);\n\n\tif (err < 0)\n\t\treturn err;\n\tci_ll_flush(&av7110->ci_rbuffer, &av7110->ci_wbuffer);\n\treturn 0;\n}\n\nstatic __poll_t dvb_ca_poll (struct file *file, poll_table *wait)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\tstruct dvb_ringbuffer *rbuf = &av7110->ci_rbuffer;\n\tstruct dvb_ringbuffer *wbuf = &av7110->ci_wbuffer;\n\t__poll_t mask = 0;\n\n\tdprintk(8, \"av7110:%p\\n\",av7110);\n\n\tpoll_wait(file, &rbuf->queue, wait);\n\tpoll_wait(file, &wbuf->queue, wait);\n\n\tif (!dvb_ringbuffer_empty(rbuf))\n\t\tmask |= (EPOLLIN | EPOLLRDNORM);\n\n\tif (dvb_ringbuffer_free(wbuf) > 1024)\n\t\tmask |= (EPOLLOUT | EPOLLWRNORM);\n\n\treturn mask;\n}\n\nstatic int dvb_ca_ioctl(struct file *file, unsigned int cmd, void *parg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\tunsigned long arg = (unsigned long) parg;\n\tint ret = 0;\n\n\tdprintk(8, \"av7110:%p\\n\",av7110);\n\n\tif (mutex_lock_interruptible(&av7110->ioctl_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase CA_RESET:\n\t\tret = ci_ll_reset(&av7110->ci_wbuffer, file, arg,\n\t\t\t\t  &av7110->ci_slot[0]);\n\t\tbreak;\n\tcase CA_GET_CAP:\n\t{\n\t\tstruct ca_caps cap;\n\n\t\tcap.slot_num = 2;\n\t\tcap.slot_type = (FW_CI_LL_SUPPORT(av7110->arm_app) ?\n\t\t\t\t CA_CI_LINK : CA_CI) | CA_DESCR;\n\t\tcap.descr_num = 16;\n\t\tcap.descr_type = CA_ECD;\n\t\tmemcpy(parg, &cap, sizeof(cap));\n\t\tbreak;\n\t}\n\n\tcase CA_GET_SLOT_INFO:\n\t{\n\t\tstruct ca_slot_info *info=(struct ca_slot_info *)parg;\n\n\t\tif (info->num < 0 || info->num > 1) {\n\t\t\tmutex_unlock(&av7110->ioctl_mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tav7110->ci_slot[info->num].num = info->num;\n\t\tav7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ?\n\t\t\t\t\t\t\tCA_CI_LINK : CA_CI;\n\t\tmemcpy(info, &av7110->ci_slot[info->num], sizeof(struct ca_slot_info));\n\t\tbreak;\n\t}\n\n\tcase CA_GET_MSG:\n\t\tbreak;\n\n\tcase CA_SEND_MSG:\n\t\tbreak;\n\n\tcase CA_GET_DESCR_INFO:\n\t{\n\t\tstruct ca_descr_info info;\n\n\t\tinfo.num = 16;\n\t\tinfo.type = CA_ECD;\n\t\tmemcpy(parg, &info, sizeof (info));\n\t\tbreak;\n\t}\n\n\tcase CA_SET_DESCR:\n\t{\n\t\tstruct ca_descr *descr = (struct ca_descr*) parg;\n\n\t\tif (descr->index >= 16 || descr->parity > 1) {\n\t\t\tmutex_unlock(&av7110->ioctl_mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tav7110_fw_cmd(av7110, COMTYPE_PIDFILTER, SetDescr, 5,\n\t\t\t      (descr->index<<8)|descr->parity,\n\t\t\t      (descr->cw[0]<<8)|descr->cw[1],\n\t\t\t      (descr->cw[2]<<8)|descr->cw[3],\n\t\t\t      (descr->cw[4]<<8)|descr->cw[5],\n\t\t\t      (descr->cw[6]<<8)|descr->cw[7]);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&av7110->ioctl_mutex);\n\treturn ret;\n}\n\nstatic ssize_t dvb_ca_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\n\tdprintk(8, \"av7110:%p\\n\",av7110);\n\treturn ci_ll_write(&av7110->ci_wbuffer, file, buf, count, ppos);\n}\n\nstatic ssize_t dvb_ca_read(struct file *file, char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\n\tdprintk(8, \"av7110:%p\\n\",av7110);\n\treturn ci_ll_read(&av7110->ci_rbuffer, file, buf, count, ppos);\n}\n\nstatic const struct file_operations dvb_ca_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= dvb_ca_read,\n\t.write\t\t= dvb_ca_write,\n\t.unlocked_ioctl\t= dvb_generic_ioctl,\n\t.open\t\t= dvb_ca_open,\n\t.release\t= dvb_generic_release,\n\t.poll\t\t= dvb_ca_poll,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct dvb_device dvbdev_ca = {\n\t.priv\t\t= NULL,\n\t.users\t\t= 1,\n\t.writers\t= 1,\n\t.fops\t\t= &dvb_ca_fops,\n\t.kernel_ioctl\t= dvb_ca_ioctl,\n};\n\n\nint av7110_ca_register(struct av7110 *av7110)\n{\n\treturn dvb_register_device(&av7110->dvb_adapter, &av7110->ca_dev,\n\t\t\t\t   &dvbdev_ca, av7110, DVB_DEVICE_CA, 0);\n}\n\nvoid av7110_ca_unregister(struct av7110 *av7110)\n{\n\tdvb_unregister_device(av7110->ca_dev);\n}\n\nint av7110_ca_init(struct av7110* av7110)\n{\n\treturn ci_ll_init(&av7110->ci_rbuffer, &av7110->ci_wbuffer, 8192);\n}\n\nvoid av7110_ca_exit(struct av7110* av7110)\n{\n\tci_ll_release(&av7110->ci_rbuffer, &av7110->ci_wbuffer);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}