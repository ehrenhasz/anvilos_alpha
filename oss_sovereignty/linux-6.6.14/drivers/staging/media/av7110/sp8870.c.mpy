{
  "module_name": "sp8870.c",
  "hash_id": "e0c38f262d3521a8b63813c62bf38e5d110537202b0d021558507e7dafea549f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/av7110/sp8870.c",
  "human_readable_source": "\n \n \n#define SP8870_DEFAULT_FIRMWARE \"dvb-fe-sp8870.fw\"\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"sp8870.h\"\n\n\nstruct sp8870_state {\n\n\tstruct i2c_adapter* i2c;\n\n\tconst struct sp8870_config* config;\n\n\tstruct dvb_frontend frontend;\n\n\t \n\tu8 initialised:1;\n};\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) printk(KERN_DEBUG \"sp8870: \" args); \\\n\t} while (0)\n\n \n#define SP8870_FIRMWARE_SIZE 16382\n\n \n#define SP8870_FIRMWARE_OFFSET 0x0A\n\nstatic int sp8870_writereg (struct sp8870_state* state, u16 reg, u16 data)\n{\n\tu8 buf [] = { reg >> 8, reg & 0xff, data >> 8, data & 0xff };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 4 };\n\tint err;\n\n\tif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\n\t\tdprintk (\"%s: writereg error (err == %i, reg == 0x%02x, data == 0x%02x)\\n\", __func__, err, reg, data);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int sp8870_readreg (struct sp8870_state* state, u16 reg)\n{\n\tint ret;\n\tu8 b0 [] = { reg >> 8 , reg & 0xff };\n\tu8 b1 [] = { 0, 0 };\n\tstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 2 },\n\t\t\t   { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 2 } };\n\n\tret = i2c_transfer (state->i2c, msg, 2);\n\n\tif (ret != 2) {\n\t\tdprintk(\"%s: readreg error (ret == %i)\\n\", __func__, ret);\n\t\treturn -1;\n\t}\n\n\treturn (b1[0] << 8 | b1[1]);\n}\n\nstatic int sp8870_firmware_upload (struct sp8870_state* state, const struct firmware *fw)\n{\n\tstruct i2c_msg msg;\n\tconst char *fw_buf = fw->data;\n\tint fw_pos;\n\tu8 tx_buf[255];\n\tint tx_len;\n\tint err = 0;\n\n\tdprintk (\"%s: ...\\n\", __func__);\n\n\tif (fw->size < SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET)\n\t\treturn -EINVAL;\n\n\t\n\tsp8870_writereg(state, 0x0F00, 0x0000);\n\n\t\n\tsp8870_writereg(state, 0x8F08, ((SP8870_FIRMWARE_SIZE / 2) & 0xFFFF));\n\n\t\n\tsp8870_writereg(state, 0x8F0A, ((SP8870_FIRMWARE_SIZE / 2) >> 16));\n\n\t\n\tfw_pos = SP8870_FIRMWARE_OFFSET;\n\twhile (fw_pos < SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET){\n\t\ttx_len = (fw_pos <= SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET - 252) ? 252 : SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET - fw_pos;\n\t\t\n\t\ttx_buf[0] = 0xCF;\n\t\ttx_buf[1] = 0x0A;\n\t\tmemcpy(&tx_buf[2], fw_buf + fw_pos, tx_len);\n\t\tmsg.addr = state->config->demod_address;\n\t\tmsg.flags = 0;\n\t\tmsg.buf = tx_buf;\n\t\tmsg.len = tx_len + 2;\n\t\tif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\n\t\t\tprintk(\"%s: firmware upload failed!\\n\", __func__);\n\t\t\tprintk (\"%s: i2c error (err == %i)\\n\", __func__, err);\n\t\t\treturn err;\n\t\t}\n\t\tfw_pos += tx_len;\n\t}\n\n\tdprintk (\"%s: done!\\n\", __func__);\n\treturn 0;\n};\n\nstatic void sp8870_microcontroller_stop (struct sp8870_state* state)\n{\n\tsp8870_writereg(state, 0x0F08, 0x000);\n\tsp8870_writereg(state, 0x0F09, 0x000);\n\n\t\n\tsp8870_writereg(state, 0x0F00, 0x000);\n}\n\nstatic void sp8870_microcontroller_start (struct sp8870_state* state)\n{\n\tsp8870_writereg(state, 0x0F08, 0x000);\n\tsp8870_writereg(state, 0x0F09, 0x000);\n\n\t\n\tsp8870_writereg(state, 0x0F00, 0x001);\n\t\n\t\n\tsp8870_readreg(state, 0x0D01);\n}\n\nstatic int sp8870_read_data_valid_signal(struct sp8870_state* state)\n{\n\treturn (sp8870_readreg(state, 0x0D02) > 0);\n}\n\nstatic int configure_reg0xc05 (struct dtv_frontend_properties *p, u16 *reg0xc05)\n{\n\tint known_parameters = 1;\n\n\t*reg0xc05 = 0x000;\n\n\tswitch (p->modulation) {\n\tcase QPSK:\n\t\tbreak;\n\tcase QAM_16:\n\t\t*reg0xc05 |= (1 << 10);\n\t\tbreak;\n\tcase QAM_64:\n\t\t*reg0xc05 |= (2 << 10);\n\t\tbreak;\n\tcase QAM_AUTO:\n\t\tknown_parameters = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->hierarchy) {\n\tcase HIERARCHY_NONE:\n\t\tbreak;\n\tcase HIERARCHY_1:\n\t\t*reg0xc05 |= (1 << 7);\n\t\tbreak;\n\tcase HIERARCHY_2:\n\t\t*reg0xc05 |= (2 << 7);\n\t\tbreak;\n\tcase HIERARCHY_4:\n\t\t*reg0xc05 |= (3 << 7);\n\t\tbreak;\n\tcase HIERARCHY_AUTO:\n\t\tknown_parameters = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->code_rate_HP) {\n\tcase FEC_1_2:\n\t\tbreak;\n\tcase FEC_2_3:\n\t\t*reg0xc05 |= (1 << 3);\n\t\tbreak;\n\tcase FEC_3_4:\n\t\t*reg0xc05 |= (2 << 3);\n\t\tbreak;\n\tcase FEC_5_6:\n\t\t*reg0xc05 |= (3 << 3);\n\t\tbreak;\n\tcase FEC_7_8:\n\t\t*reg0xc05 |= (4 << 3);\n\t\tbreak;\n\tcase FEC_AUTO:\n\t\tknown_parameters = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (known_parameters)\n\t\t*reg0xc05 |= (2 << 1);\t \n\telse\n\t\t*reg0xc05 |= (1 << 1);\t \n\n\treturn 0;\n}\n\nstatic int sp8870_wake_up(struct sp8870_state* state)\n{\n\t\n\treturn sp8870_writereg(state, 0xC18, 0x00D);\n}\n\nstatic int sp8870_set_frontend_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct sp8870_state* state = fe->demodulator_priv;\n\tint  err;\n\tu16 reg0xc05;\n\n\tif ((err = configure_reg0xc05(p, &reg0xc05)))\n\t\treturn err;\n\n\t\n\tsp8870_microcontroller_stop(state);\n\n\t\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t\n\tsp8870_writereg(state, 0x0319, 0x000A);\n\n\t\n\tsp8870_writereg(state, 0x031A, 0x0AAB);\n\n\t\n\tsp8870_writereg(state, 0x0309, 0x0400);\n\n\t\n\tsp8870_writereg(state, 0x030A, 0x0000);\n\n\t\n\tif (p->bandwidth_hz == 6000000)\n\t\tsp8870_writereg(state, 0x0311, 0x0002);\n\telse if (p->bandwidth_hz == 7000000)\n\t\tsp8870_writereg(state, 0x0311, 0x0001);\n\telse\n\t\tsp8870_writereg(state, 0x0311, 0x0000);\n\n\t\n\tif (p->transmission_mode == TRANSMISSION_MODE_2K)\n\t\tsp8870_writereg(state, 0x0338, 0x0000);\n\telse\n\t\tsp8870_writereg(state, 0x0338, 0x0001);\n\n\tsp8870_writereg(state, 0xc05, reg0xc05);\n\n\t\n\terr = sp8870_readreg(state, 0x200);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\tsp8870_microcontroller_start(state);\n\n\treturn 0;\n}\n\nstatic int sp8870_init (struct dvb_frontend* fe)\n{\n\tstruct sp8870_state* state = fe->demodulator_priv;\n\tconst struct firmware *fw = NULL;\n\n\tsp8870_wake_up(state);\n\tif (state->initialised) return 0;\n\tstate->initialised = 1;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\n\t \n\tprintk(\"sp8870: waiting for firmware upload (%s)...\\n\", SP8870_DEFAULT_FIRMWARE);\n\tif (state->config->request_firmware(fe, &fw, SP8870_DEFAULT_FIRMWARE)) {\n\t\tprintk(\"sp8870: no firmware upload (timeout or file not found?)\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (sp8870_firmware_upload(state, fw)) {\n\t\tprintk(\"sp8870: writing firmware to device failed\\n\");\n\t\trelease_firmware(fw);\n\t\treturn -EIO;\n\t}\n\trelease_firmware(fw);\n\tprintk(\"sp8870: firmware upload complete\\n\");\n\n\t \n\tsp8870_writereg(state, 0xc18, 0x00d);\n\n\t\n\tsp8870_microcontroller_stop(state);\n\n\t\n\tsp8870_writereg(state, 0x0301, 0x0003);\n\n\t\n\tsp8870_writereg(state, 0x0C13, 0x0001);\n\n\t\n\tsp8870_writereg(state, 0x0C14, 0x0001);\n\n\t \n\tsp8870_writereg(state, 0x0D00, 0x010);\n\tsp8870_writereg(state, 0x0D01, 0x000);\n\n\treturn 0;\n}\n\nstatic int sp8870_read_status(struct dvb_frontend *fe,\n\t\t\t      enum fe_status *fe_status)\n{\n\tstruct sp8870_state* state = fe->demodulator_priv;\n\tint status;\n\tint signal;\n\n\t*fe_status = 0;\n\n\tstatus = sp8870_readreg (state, 0x0200);\n\tif (status < 0)\n\t\treturn -EIO;\n\n\tsignal = sp8870_readreg (state, 0x0303);\n\tif (signal < 0)\n\t\treturn -EIO;\n\n\tif (signal > 0x0F)\n\t\t*fe_status |= FE_HAS_SIGNAL;\n\tif (status & 0x08)\n\t\t*fe_status |= FE_HAS_SYNC;\n\tif (status & 0x04)\n\t\t*fe_status |= FE_HAS_LOCK | FE_HAS_CARRIER | FE_HAS_VITERBI;\n\n\treturn 0;\n}\n\nstatic int sp8870_read_ber (struct dvb_frontend* fe, u32 * ber)\n{\n\tstruct sp8870_state* state = fe->demodulator_priv;\n\tint ret;\n\tu32 tmp;\n\n\t*ber = 0;\n\n\tret = sp8870_readreg(state, 0xC08);\n\tif (ret < 0)\n\t\treturn -EIO;\n\n\ttmp = ret & 0x3F;\n\n\tret = sp8870_readreg(state, 0xC07);\n\tif (ret < 0)\n\t\treturn -EIO;\n\n\ttmp = ret << 6;\n\tif (tmp >= 0x3FFF0)\n\t\ttmp = ~0;\n\n\t*ber = tmp;\n\n\treturn 0;\n}\n\nstatic int sp8870_read_signal_strength(struct dvb_frontend* fe,  u16 * signal)\n{\n\tstruct sp8870_state* state = fe->demodulator_priv;\n\tint ret;\n\tu16 tmp;\n\n\t*signal = 0;\n\n\tret = sp8870_readreg (state, 0x306);\n\tif (ret < 0)\n\t\treturn -EIO;\n\n\ttmp = ret << 8;\n\n\tret = sp8870_readreg (state, 0x303);\n\tif (ret < 0)\n\t\treturn -EIO;\n\n\ttmp |= ret;\n\n\tif (tmp)\n\t\t*signal = 0xFFFF - tmp;\n\n\treturn 0;\n}\n\nstatic int sp8870_read_uncorrected_blocks (struct dvb_frontend* fe, u32* ublocks)\n{\n\tstruct sp8870_state* state = fe->demodulator_priv;\n\tint ret;\n\n\t*ublocks = 0;\n\n\tret = sp8870_readreg(state, 0xC0C);\n\tif (ret < 0)\n\t\treturn -EIO;\n\n\tif (ret == 0xFFFF)\n\t\tret = ~0;\n\n\t*ublocks = ret;\n\n\treturn 0;\n}\n\n \n#define MAXTRIALS 5\n \n#define MAXCHECKS 100\n\n \nstatic int lockups;\n \nstatic int switches;\n\nstatic int sp8870_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct sp8870_state* state = fe->demodulator_priv;\n\n\t \n\n\tint err = 0;\n\tint valid = 0;\n\tint trials = 0;\n\tint check_count = 0;\n\n\tdprintk(\"%s: frequency = %i\\n\", __func__, p->frequency);\n\n\tfor (trials = 1; trials <= MAXTRIALS; trials++) {\n\n\t\terr = sp8870_set_frontend_parameters(fe);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfor (check_count = 0; check_count < MAXCHECKS; check_count++) {\n\n\t\t\tvalid = sp8870_read_data_valid_signal(state);\n\t\t\tif (valid) {\n\t\t\t\tdprintk(\"%s: delay = %i usec\\n\",\n\t\t\t\t\t__func__, check_count * 10);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(10);\n\t\t}\n\t\tif (valid)\n\t\t\tbreak;\n\t}\n\n\tif (!valid) {\n\t\tprintk(\"%s: firmware crash!!!!!!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tif (debug) {\n\t\tif (valid) {\n\t\t\tif (trials > 1) {\n\t\t\t\tprintk(\"%s: firmware lockup!!!\\n\", __func__);\n\t\t\t\tprintk(\"%s: recovered after %i trial(s))\\n\",  __func__, trials - 1);\n\t\t\t\tlockups++;\n\t\t\t}\n\t\t}\n\t\tswitches++;\n\t\tprintk(\"%s: switches = %i lockups = %i\\n\", __func__, switches, lockups);\n\t}\n\n\treturn 0;\n}\n\nstatic int sp8870_sleep(struct dvb_frontend* fe)\n{\n\tstruct sp8870_state* state = fe->demodulator_priv;\n\n\t\n\treturn sp8870_writereg(state, 0xC18, 0x000);\n}\n\nstatic int sp8870_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\n{\n\tfesettings->min_delay_ms = 350;\n\tfesettings->step_size = 0;\n\tfesettings->max_drift = 0;\n\treturn 0;\n}\n\nstatic int sp8870_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\n{\n\tstruct sp8870_state* state = fe->demodulator_priv;\n\n\tif (enable) {\n\t\treturn sp8870_writereg(state, 0x206, 0x001);\n\t} else {\n\t\treturn sp8870_writereg(state, 0x206, 0x000);\n\t}\n}\n\nstatic void sp8870_release(struct dvb_frontend* fe)\n{\n\tstruct sp8870_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops sp8870_ops;\n\nstruct dvb_frontend* sp8870_attach(const struct sp8870_config* config,\n\t\t\t\t   struct i2c_adapter* i2c)\n{\n\tstruct sp8870_state* state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct sp8870_state), GFP_KERNEL);\n\tif (state == NULL) goto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->initialised = 0;\n\n\t \n\tif (sp8870_readreg(state, 0x0200) < 0) goto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &sp8870_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops sp8870_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name\t\t\t= \"Spase SP8870 DVB-T\",\n\t\t.frequency_min_hz\t= 470 * MHz,\n\t\t.frequency_max_hz\t= 860 * MHz,\n\t\t.frequency_stepsize_hz\t= 166666,\n\t\t.caps\t\t\t= FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |\n\t\t\t\t\t  FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 |\n\t\t\t\t\t  FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\t\t\t  FE_CAN_QPSK | FE_CAN_QAM_16 |\n\t\t\t\t\t  FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t\t\t\t  FE_CAN_HIERARCHY_AUTO |  FE_CAN_RECOVER\n\t},\n\n\t.release = sp8870_release,\n\n\t.init = sp8870_init,\n\t.sleep = sp8870_sleep,\n\t.i2c_gate_ctrl = sp8870_i2c_gate_ctrl,\n\n\t.set_frontend = sp8870_set_frontend,\n\t.get_tune_settings = sp8870_get_tune_settings,\n\n\t.read_status = sp8870_read_status,\n\t.read_ber = sp8870_read_ber,\n\t.read_signal_strength = sp8870_read_signal_strength,\n\t.read_ucblocks = sp8870_read_uncorrected_blocks,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"Spase SP8870 DVB-T Demodulator driver\");\nMODULE_AUTHOR(\"Juergen Peitz\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(sp8870_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}