{
  "module_name": "av7110_v4l.c",
  "hash_id": "e15681e41b401d3cc96fe2fb990d629a1c30de43658cc53f47004c4dbee1a842",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/av7110/av7110_v4l.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/timer.h>\n#include <linux/poll.h>\n\n#include \"av7110.h\"\n#include \"av7110_hw.h\"\n#include \"av7110_av.h\"\n\nint msp_writereg(struct av7110 *av7110, u8 dev, u16 reg, u16 val)\n{\n\tu8 msg[5] = { dev, reg >> 8, reg & 0xff, val >> 8 , val & 0xff };\n\tstruct i2c_msg msgs = { .flags = 0, .len = 5, .buf = msg };\n\n\tswitch (av7110->adac_type) {\n\tcase DVB_ADAC_MSP34x0:\n\t\tmsgs.addr = 0x40;\n\t\tbreak;\n\tcase DVB_ADAC_MSP34x5:\n\t\tmsgs.addr = 0x42;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (i2c_transfer(&av7110->i2c_adap, &msgs, 1) != 1) {\n\t\tdprintk(1, \"dvb-ttpci: failed @ card %d, %u = %u\\n\",\n\t\t       av7110->dvb_adapter.num, reg, val);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int msp_readreg(struct av7110 *av7110, u8 dev, u16 reg, u16 *val)\n{\n\tu8 msg1[3] = { dev, reg >> 8, reg & 0xff };\n\tu8 msg2[2];\n\tstruct i2c_msg msgs[2] = {\n\t\t{ .flags = 0\t   , .len = 3, .buf = msg1 },\n\t\t{ .flags = I2C_M_RD, .len = 2, .buf = msg2 }\n\t};\n\n\tswitch (av7110->adac_type) {\n\tcase DVB_ADAC_MSP34x0:\n\t\tmsgs[0].addr = 0x40;\n\t\tmsgs[1].addr = 0x40;\n\t\tbreak;\n\tcase DVB_ADAC_MSP34x5:\n\t\tmsgs[0].addr = 0x42;\n\t\tmsgs[1].addr = 0x42;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (i2c_transfer(&av7110->i2c_adap, &msgs[0], 2) != 2) {\n\t\tdprintk(1, \"dvb-ttpci: failed @ card %d, %u\\n\",\n\t\t       av7110->dvb_adapter.num, reg);\n\t\treturn -EIO;\n\t}\n\t*val = (msg2[0] << 8) | msg2[1];\n\treturn 0;\n}\n\nstatic struct v4l2_input inputs[4] = {\n\t{\n\t\t.index\t\t= 0,\n\t\t.name\t\t= \"DVB\",\n\t\t.type\t\t= V4L2_INPUT_TYPE_CAMERA,\n\t\t.audioset\t= 1,\n\t\t.tuner\t\t= 0,  \n\t\t.std\t\t= V4L2_STD_PAL_BG|V4L2_STD_NTSC_M,\n\t\t.status\t\t= 0,\n\t\t.capabilities\t= V4L2_IN_CAP_STD,\n\t}, {\n\t\t.index\t\t= 1,\n\t\t.name\t\t= \"Television\",\n\t\t.type\t\t= V4L2_INPUT_TYPE_TUNER,\n\t\t.audioset\t= 1,\n\t\t.tuner\t\t= 0,\n\t\t.std\t\t= V4L2_STD_PAL_BG|V4L2_STD_NTSC_M,\n\t\t.status\t\t= 0,\n\t\t.capabilities\t= V4L2_IN_CAP_STD,\n\t}, {\n\t\t.index\t\t= 2,\n\t\t.name\t\t= \"Video\",\n\t\t.type\t\t= V4L2_INPUT_TYPE_CAMERA,\n\t\t.audioset\t= 0,\n\t\t.tuner\t\t= 0,\n\t\t.std\t\t= V4L2_STD_PAL_BG|V4L2_STD_NTSC_M,\n\t\t.status\t\t= 0,\n\t\t.capabilities\t= V4L2_IN_CAP_STD,\n\t}, {\n\t\t.index\t\t= 3,\n\t\t.name\t\t= \"Y/C\",\n\t\t.type\t\t= V4L2_INPUT_TYPE_CAMERA,\n\t\t.audioset\t= 0,\n\t\t.tuner\t\t= 0,\n\t\t.std\t\t= V4L2_STD_PAL_BG|V4L2_STD_NTSC_M,\n\t\t.status\t\t= 0,\n\t\t.capabilities\t= V4L2_IN_CAP_STD,\n\t}\n};\n\nstatic int ves1820_writereg(struct saa7146_dev *dev, u8 addr, u8 reg, u8 data)\n{\n\tstruct av7110 *av7110 = dev->ext_priv;\n\tu8 buf[] = { 0x00, reg, data };\n\tstruct i2c_msg msg = { .addr = addr, .flags = 0, .buf = buf, .len = 3 };\n\n\tdprintk(4, \"dev: %p\\n\", dev);\n\n\tif (1 != i2c_transfer(&av7110->i2c_adap, &msg, 1))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int tuner_write(struct saa7146_dev *dev, u8 addr, u8 data [4])\n{\n\tstruct av7110 *av7110 = dev->ext_priv;\n\tstruct i2c_msg msg = { .addr = addr, .flags = 0, .buf = data, .len = 4 };\n\n\tdprintk(4, \"dev: %p\\n\", dev);\n\n\tif (1 != i2c_transfer(&av7110->i2c_adap, &msg, 1))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int ves1820_set_tv_freq(struct saa7146_dev *dev, u32 freq)\n{\n\tu32 div;\n\tu8 config;\n\tu8 buf[4];\n\n\tdprintk(4, \"freq: 0x%08x\\n\", freq);\n\n\t \n\tdiv = freq + 614;\n\n\tbuf[0] = (div >> 8) & 0x7f;\n\tbuf[1] = div & 0xff;\n\tbuf[2] = 0x8e;\n\n\tif (freq < 16U * 16825 / 100)\n\t\tconfig = 0xa0;\n\telse if (freq < 16U * 44725 / 100)\n\t\tconfig = 0x90;\n\telse\n\t\tconfig = 0x30;\n\tconfig &= ~0x02;\n\n\tbuf[3] = config;\n\n\treturn tuner_write(dev, 0x61, buf);\n}\n\nstatic int stv0297_set_tv_freq(struct saa7146_dev *dev, u32 freq)\n{\n\tstruct av7110 *av7110 = (struct av7110*)dev->ext_priv;\n\tu32 div;\n\tu8 data[4];\n\n\tdiv = (freq + 38900000 + 31250) / 62500;\n\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = 0xce;\n\n\tif (freq < 45000000)\n\t\treturn -EINVAL;\n\telse if (freq < 137000000)\n\t\tdata[3] = 0x01;\n\telse if (freq < 403000000)\n\t\tdata[3] = 0x02;\n\telse if (freq < 860000000)\n\t\tdata[3] = 0x04;\n\telse\n\t\treturn -EINVAL;\n\n\tif (av7110->fe->ops.i2c_gate_ctrl)\n\t\tav7110->fe->ops.i2c_gate_ctrl(av7110->fe, 1);\n\treturn tuner_write(dev, 0x63, data);\n}\n\n\n\nstatic struct saa7146_standard analog_standard[];\nstatic struct saa7146_standard dvb_standard[];\nstatic struct saa7146_standard standard[];\n\nstatic const struct v4l2_audio msp3400_v4l2_audio = {\n\t.index = 0,\n\t.name = \"Television\",\n\t.capability = V4L2_AUDCAP_STEREO\n};\n\nstatic int av7110_dvb_c_switch(struct saa7146_dev *dev)\n{\n\tstruct av7110 *av7110 = (struct av7110*)dev->ext_priv;\n\tu16 adswitch;\n\tint source, sync;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (0 != av7110->current_input) {\n\t\tdprintk(1, \"switching to analog TV:\\n\");\n\t\tadswitch = 1;\n\t\tsource = SAA7146_HPS_SOURCE_PORT_B;\n\t\tsync = SAA7146_HPS_SYNC_PORT_B;\n\t\tmemcpy(standard, analog_standard, sizeof(struct saa7146_standard) * 2);\n\n\t\tswitch (av7110->current_input) {\n\t\tcase 1:\n\t\t\tdprintk(1, \"switching SAA7113 to Analog Tuner Input\\n\");\n\t\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0008, 0x0000); \n\t\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0009, 0x0000); \n\t\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x000a, 0x0000); \n\t\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x000e, 0x3000); \n\t\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0000, 0x4f00); \n\t\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0007, 0x4f00); \n\n\t\t\tif (av7110->analog_tuner_flags & ANALOG_TUNER_VES1820) {\n\t\t\t\tif (ves1820_writereg(dev, 0x09, 0x0f, 0x60))\n\t\t\t\t\tdprintk(1, \"setting band in demodulator failed\\n\");\n\t\t\t} else if (av7110->analog_tuner_flags & ANALOG_TUNER_STV0297) {\n\t\t\t\tsaa7146_setgpio(dev, 1, SAA7146_GPIO_OUTHI); \n\t\t\t\tsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTHI); \n\t\t\t}\n\t\t\tif (i2c_writereg(av7110, 0x48, 0x02, 0xd0) != 1)\n\t\t\t\tdprintk(1, \"saa7113 write failed @ card %d\", av7110->dvb_adapter.num);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdprintk(1, \"switching SAA7113 to Video AV CVBS Input\\n\");\n\t\t\tif (i2c_writereg(av7110, 0x48, 0x02, 0xd2) != 1)\n\t\t\t\tdprintk(1, \"saa7113 write failed @ card %d\", av7110->dvb_adapter.num);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdprintk(1, \"switching SAA7113 to Video AV Y/C Input\\n\");\n\t\t\tif (i2c_writereg(av7110, 0x48, 0x02, 0xd9) != 1)\n\t\t\t\tdprintk(1, \"saa7113 write failed @ card %d\", av7110->dvb_adapter.num);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(1, \"switching SAA7113 to Input: AV7110: SAA7113: invalid input\\n\");\n\t\t}\n\t} else {\n\t\tadswitch = 0;\n\t\tsource = SAA7146_HPS_SOURCE_PORT_A;\n\t\tsync = SAA7146_HPS_SYNC_PORT_A;\n\t\tmemcpy(standard, dvb_standard, sizeof(struct saa7146_standard) * 2);\n\t\tdprintk(1, \"switching DVB mode\\n\");\n\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0008, 0x0220); \n\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0009, 0x0220); \n\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x000a, 0x0220); \n\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x000e, 0x3000); \n\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0000, 0x7f00); \n\t\tmsp_writereg(av7110, MSP_WR_DSP, 0x0007, 0x7f00); \n\n\t\tif (av7110->analog_tuner_flags & ANALOG_TUNER_VES1820) {\n\t\t\tif (ves1820_writereg(dev, 0x09, 0x0f, 0x20))\n\t\t\t\tdprintk(1, \"setting band in demodulator failed\\n\");\n\t\t} else if (av7110->analog_tuner_flags & ANALOG_TUNER_STV0297) {\n\t\t\tsaa7146_setgpio(dev, 1, SAA7146_GPIO_OUTLO); \n\t\t\tsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO); \n\t\t}\n\t}\n\n\t \n\tif (av7110_fw_cmd(av7110, COMTYPE_AUDIODAC, ADSwitch, 1, adswitch))\n\t\tdprintk(1, \"ADSwitch error\\n\");\n\n\tsaa7146_set_hps_source_and_sync(dev, source, sync);\n\n\treturn 0;\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *fh, struct v4l2_tuner *t)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\n\tu16 stereo_det;\n\ts8 stereo;\n\n\tdprintk(2, \"VIDIOC_G_TUNER: %d\\n\", t->index);\n\n\tif (!av7110->analog_tuner_flags || t->index != 0)\n\t\treturn -EINVAL;\n\n\tmemset(t, 0, sizeof(*t));\n\tstrscpy((char *)t->name, \"Television\", sizeof(t->name));\n\n\tt->type = V4L2_TUNER_ANALOG_TV;\n\tt->capability = V4L2_TUNER_CAP_NORM | V4L2_TUNER_CAP_STEREO |\n\t\tV4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2 | V4L2_TUNER_CAP_SAP;\n\tt->rangelow = 772;\t \n\tt->rangehigh = 13684;\t \n\t \n\tt->signal = 0xffff;\n\tt->afc = 0;\n\n\t \n\tmsp_readreg(av7110, MSP_RD_DEM, 0x007e, &stereo_det);\n\tdprintk(1, \"VIDIOC_G_TUNER: msp3400 TV standard detection: 0x%04x\\n\", stereo_det);\n\tmsp_readreg(av7110, MSP_RD_DSP, 0x0018, &stereo_det);\n\tdprintk(1, \"VIDIOC_G_TUNER: msp3400 stereo detection: 0x%04x\\n\", stereo_det);\n\tstereo = (s8)(stereo_det >> 8);\n\tif (stereo > 0x10) {\n\t\t \n\t\tt->rxsubchans = V4L2_TUNER_SUB_STEREO | V4L2_TUNER_SUB_MONO;\n\t\tt->audmode = V4L2_TUNER_MODE_STEREO;\n\t} else if (stereo < -0x10) {\n\t\t \n\t\tt->rxsubchans = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\n\t\tt->audmode = V4L2_TUNER_MODE_LANG1;\n\t} else  \n\t\tt->rxsubchans = V4L2_TUNER_SUB_MONO;\n\n\treturn 0;\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *fh, const struct v4l2_tuner *t)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\n\tu16 fm_matrix, src;\n\tdprintk(2, \"VIDIOC_S_TUNER: %d\\n\", t->index);\n\n\tif (!av7110->analog_tuner_flags || av7110->current_input != 1)\n\t\treturn -EINVAL;\n\n\tswitch (t->audmode) {\n\tcase V4L2_TUNER_MODE_STEREO:\n\t\tdprintk(2, \"VIDIOC_S_TUNER: V4L2_TUNER_MODE_STEREO\\n\");\n\t\tfm_matrix = 0x3001;  \n\t\tsrc = 0x0020;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\t\tdprintk(2, \"VIDIOC_S_TUNER: V4L2_TUNER_MODE_LANG1_LANG2\\n\");\n\t\tfm_matrix = 0x3000;  \n\t\tsrc = 0x0020;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG1:\n\t\tdprintk(2, \"VIDIOC_S_TUNER: V4L2_TUNER_MODE_LANG1\\n\");\n\t\tfm_matrix = 0x3000;  \n\t\tsrc = 0x0000;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG2:\n\t\tdprintk(2, \"VIDIOC_S_TUNER: V4L2_TUNER_MODE_LANG2\\n\");\n\t\tfm_matrix = 0x3000;  \n\t\tsrc = 0x0010;\n\t\tbreak;\n\tdefault:  \n\t\tdprintk(2, \"VIDIOC_S_TUNER: TDA9840_SET_MONO\\n\");\n\t\tfm_matrix = 0x3000;  \n\t\tsrc = 0x0030;\n\t\tbreak;\n\t}\n\tmsp_writereg(av7110, MSP_WR_DSP, 0x000e, fm_matrix);\n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0008, src);\n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0009, src);\n\tmsp_writereg(av7110, MSP_WR_DSP, 0x000a, src);\n\treturn 0;\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *fh, struct v4l2_frequency *f)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\n\n\tdprintk(2, \"VIDIOC_G_FREQ: freq:0x%08x\\n\", f->frequency);\n\n\tif (!av7110->analog_tuner_flags || av7110->current_input != 1)\n\t\treturn -EINVAL;\n\n\tmemset(f, 0, sizeof(*f));\n\tf->type = V4L2_TUNER_ANALOG_TV;\n\tf->frequency =\tav7110->current_freq;\n\treturn 0;\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *fh, const struct v4l2_frequency *f)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\n\n\tdprintk(2, \"VIDIOC_S_FREQUENCY: freq:0x%08x\\n\", f->frequency);\n\n\tif (!av7110->analog_tuner_flags || av7110->current_input != 1)\n\t\treturn -EINVAL;\n\n\tif (V4L2_TUNER_ANALOG_TV != f->type)\n\t\treturn -EINVAL;\n\n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0000, 0xffe0);  \n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0007, 0xffe0);\n\n\t \n\tif (av7110->analog_tuner_flags & ANALOG_TUNER_VES1820)\n\t\tves1820_set_tv_freq(dev, f->frequency);\n\telse if (av7110->analog_tuner_flags & ANALOG_TUNER_STV0297)\n\t\tstv0297_set_tv_freq(dev, f->frequency);\n\tav7110->current_freq = f->frequency;\n\n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0015, 0x003f);  \n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0015, 0x0000);\n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0000, 0x4f00);  \n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0007, 0x4f00);  \n\treturn 0;\n}\n\nstatic int vidioc_enum_input(struct file *file, void *fh, struct v4l2_input *i)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\n\n\tdprintk(2, \"VIDIOC_ENUMINPUT: %d\\n\", i->index);\n\n\tif (av7110->analog_tuner_flags) {\n\t\tif (i->index >= 4)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (i->index != 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(i, &inputs[i->index], sizeof(struct v4l2_input));\n\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *input)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\n\n\t*input = av7110->current_input;\n\tdprintk(2, \"VIDIOC_G_INPUT: %d\\n\", *input);\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int input)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\n\n\tdprintk(2, \"VIDIOC_S_INPUT: %d\\n\", input);\n\n\tif (!av7110->analog_tuner_flags)\n\t\treturn input ? -EINVAL : 0;\n\n\tif (input >= 4)\n\t\treturn -EINVAL;\n\n\tav7110->current_input = input;\n\treturn av7110_dvb_c_switch(dev);\n}\n\nstatic int vidioc_enum_output(struct file *file, void *fh, struct v4l2_output *o)\n{\n\tif (o->index)\n\t\treturn -EINVAL;\n\tstrscpy(o->name, \"Video Output\", sizeof(o->name));\n\to->type = V4L2_OUTPUT_TYPE_ANALOG;\n\to->std = V4L2_STD_NTSC_M | V4L2_STD_PAL_BG;\n\to->capabilities = V4L2_OUT_CAP_STD;\n\treturn 0;\n}\n\nstatic int vidioc_g_output(struct file *file, void *fh, unsigned int *output)\n{\n\t*output = 0;\n\treturn 0;\n}\n\nstatic int vidioc_s_output(struct file *file, void *fh, unsigned int output)\n{\n\treturn output ? -EINVAL : 0;\n}\n\nstatic int vidioc_enumaudio(struct file *file, void *fh, struct v4l2_audio *a)\n{\n\tdprintk(2, \"VIDIOC_G_AUDIO: %d\\n\", a->index);\n\tif (a->index != 0)\n\t\treturn -EINVAL;\n\t*a = msp3400_v4l2_audio;\n\treturn 0;\n}\n\nstatic int vidioc_g_audio(struct file *file, void *fh, struct v4l2_audio *a)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\n\n\tdprintk(2, \"VIDIOC_G_AUDIO: %d\\n\", a->index);\n\tif (a->index != 0)\n\t\treturn -EINVAL;\n\tif (av7110->current_input >= 2)\n\t\treturn -EINVAL;\n\t*a = msp3400_v4l2_audio;\n\treturn 0;\n}\n\nstatic int vidioc_s_audio(struct file *file, void *fh, const struct v4l2_audio *a)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\n\n\tdprintk(2, \"VIDIOC_S_AUDIO: %d\\n\", a->index);\n\tif (av7110->current_input >= 2)\n\t\treturn -EINVAL;\n\treturn a->index ? -EINVAL : 0;\n}\n\nstatic int vidioc_g_sliced_vbi_cap(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_sliced_vbi_cap *cap)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\n\n\tdprintk(2, \"VIDIOC_G_SLICED_VBI_CAP\\n\");\n\tif (cap->type != V4L2_BUF_TYPE_SLICED_VBI_OUTPUT)\n\t\treturn -EINVAL;\n\tif (FW_VERSION(av7110->arm_app) >= 0x2623) {\n\t\tcap->service_set = V4L2_SLICED_WSS_625;\n\t\tcap->service_lines[0][23] = V4L2_SLICED_WSS_625;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_sliced_vbi_out(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\n\n\tdprintk(2, \"VIDIOC_G_FMT:\\n\");\n\tif (FW_VERSION(av7110->arm_app) < 0x2623)\n\t\treturn -EINVAL;\n\tmemset(&f->fmt.sliced, 0, sizeof f->fmt.sliced);\n\tif (av7110->wssMode) {\n\t\tf->fmt.sliced.service_set = V4L2_SLICED_WSS_625;\n\t\tf->fmt.sliced.service_lines[0][23] = V4L2_SLICED_WSS_625;\n\t}\n\tf->fmt.sliced.io_size = sizeof(struct v4l2_sliced_vbi_data);\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_sliced_vbi_out(struct file *file, void *fh,\n\t\t\t\t\t struct v4l2_format *f)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\n\tbool want_wss = (f->fmt.sliced.service_set & V4L2_SLICED_WSS_625) ||\n\t\t(!f->fmt.sliced.service_set &&\n\t\t f->fmt.sliced.service_lines[0][23] == V4L2_SLICED_WSS_625);\n\n\tdprintk(2, \"VIDIOC_G_FMT:\\n\");\n\tif (FW_VERSION(av7110->arm_app) < 0x2623)\n\t\treturn -EINVAL;\n\tmemset(&f->fmt.sliced, 0, sizeof(f->fmt.sliced));\n\tif (want_wss) {\n\t\tf->fmt.sliced.service_set = V4L2_SLICED_WSS_625;\n\t\tf->fmt.sliced.service_lines[0][23] = V4L2_SLICED_WSS_625;\n\t}\n\tf->fmt.sliced.io_size = sizeof(struct v4l2_sliced_vbi_data);\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_sliced_vbi_out(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\n\n\tdprintk(2, \"VIDIOC_S_FMT\\n\");\n\tif (vidioc_try_fmt_sliced_vbi_out(file, fh, f))\n\t\treturn -EINVAL;\n\tif (f->fmt.sliced.service_set & V4L2_SLICED_WSS_625) {\n\t\t \n\t\tav7110->wssMode = 1;\n\t\tav7110->wssData = 0;\n\t} else {\n\t\t \n\t\tav7110->wssMode = 0;\n\t\tav7110->wssData = 0;\n\t\treturn av7110_fw_cmd(av7110, COMTYPE_ENCODER,\n\t\t\t\t     SetWSSConfig, 1, 0);\n\t}\n\treturn 0;\n}\n\nstatic ssize_t av7110_vbi_write(struct file *file, const char __user *data, size_t count, loff_t *ppos)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct av7110 *av7110 = (struct av7110*) dev->ext_priv;\n\tstruct v4l2_sliced_vbi_data d;\n\tint rc;\n\n\tdprintk(2, \"%s\\n\", __func__);\n\tif (FW_VERSION(av7110->arm_app) < 0x2623 || !av7110->wssMode || count != sizeof d)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&d, data, count))\n\t\treturn -EFAULT;\n\tif ((d.id != 0 && d.id != V4L2_SLICED_WSS_625) || d.field != 0 || d.line != 23)\n\t\treturn -EINVAL;\n\tif (d.id)\n\t\tav7110->wssData = ((d.data[1] << 8) & 0x3f00) | d.data[0];\n\telse\n\t\tav7110->wssData = 0x8000;\n\trc = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetWSSConfig, 2, 1, av7110->wssData);\n\treturn (rc < 0) ? rc : count;\n}\n\n \n\nstatic u8 saa7113_init_regs[] = {\n\t0x02, 0xd0,\n\t0x03, 0x23,\n\t0x04, 0x00,\n\t0x05, 0x00,\n\t0x06, 0xe9,\n\t0x07, 0x0d,\n\t0x08, 0x98,\n\t0x09, 0x02,\n\t0x0a, 0x80,\n\t0x0b, 0x40,\n\t0x0c, 0x40,\n\t0x0d, 0x00,\n\t0x0e, 0x01,\n\t0x0f, 0x7c,\n\t0x10, 0x48,\n\t0x11, 0x0c,\n\t0x12, 0x8b,\n\t0x13, 0x1a,\n\t0x14, 0x00,\n\t0x15, 0x00,\n\t0x16, 0x00,\n\t0x17, 0x00,\n\t0x18, 0x00,\n\t0x19, 0x00,\n\t0x1a, 0x00,\n\t0x1b, 0x00,\n\t0x1c, 0x00,\n\t0x1d, 0x00,\n\t0x1e, 0x00,\n\n\t0x41, 0x77,\n\t0x42, 0x77,\n\t0x43, 0x77,\n\t0x44, 0x77,\n\t0x45, 0x77,\n\t0x46, 0x77,\n\t0x47, 0x77,\n\t0x48, 0x77,\n\t0x49, 0x77,\n\t0x4a, 0x77,\n\t0x4b, 0x77,\n\t0x4c, 0x77,\n\t0x4d, 0x77,\n\t0x4e, 0x77,\n\t0x4f, 0x77,\n\t0x50, 0x77,\n\t0x51, 0x77,\n\t0x52, 0x77,\n\t0x53, 0x77,\n\t0x54, 0x77,\n\t0x55, 0x77,\n\t0x56, 0x77,\n\t0x57, 0xff,\n\n\t0xff\n};\n\n\nstatic struct saa7146_ext_vv av7110_vv_data_st;\nstatic struct saa7146_ext_vv av7110_vv_data_c;\n\nint av7110_init_analog_module(struct av7110 *av7110)\n{\n\tu16 version1, version2;\n\n\tif (i2c_writereg(av7110, 0x80, 0x0, 0x80) == 1 &&\n\t    i2c_writereg(av7110, 0x80, 0x0, 0) == 1) {\n\t\tpr_info(\"DVB-C analog module @ card %d detected, initializing MSP3400\\n\",\n\t\t\tav7110->dvb_adapter.num);\n\t\tav7110->adac_type = DVB_ADAC_MSP34x0;\n\t} else if (i2c_writereg(av7110, 0x84, 0x0, 0x80) == 1 &&\n\t\t   i2c_writereg(av7110, 0x84, 0x0, 0) == 1) {\n\t\tpr_info(\"DVB-C analog module @ card %d detected, initializing MSP3415\\n\",\n\t\t\tav7110->dvb_adapter.num);\n\t\tav7110->adac_type = DVB_ADAC_MSP34x5;\n\t} else\n\t\treturn -ENODEV;\n\n\tmsleep(100); \n\tmsp_readreg(av7110, MSP_RD_DSP, 0x001e, &version1);\n\tmsp_readreg(av7110, MSP_RD_DSP, 0x001f, &version2);\n\tdprintk(1, \"dvb-ttpci: @ card %d MSP34xx version 0x%04x 0x%04x\\n\",\n\t\tav7110->dvb_adapter.num, version1, version2);\n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0013, 0x0c00);\n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0000, 0x7f00); \n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0008, 0x0220); \n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0009, 0x0220); \n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0004, 0x7f00); \n\tmsp_writereg(av7110, MSP_WR_DSP, 0x000a, 0x0220); \n\tmsp_writereg(av7110, MSP_WR_DSP, 0x0007, 0x7f00); \n\tmsp_writereg(av7110, MSP_WR_DSP, 0x000d, 0x1900); \n\n\tif (i2c_writereg(av7110, 0x48, 0x01, 0x00)!=1) {\n\t\tpr_info(\"saa7113 not accessible\\n\");\n\t} else {\n\t\tu8 *i = saa7113_init_regs;\n\n\t\tif ((av7110->dev->pci->subsystem_vendor == 0x110a) && (av7110->dev->pci->subsystem_device == 0x0000)) {\n\t\t\t \n\t\t\tav7110->analog_tuner_flags |= ANALOG_TUNER_VES1820;\n\t\t} else if ((av7110->dev->pci->subsystem_vendor == 0x13c2) && (av7110->dev->pci->subsystem_device == 0x0002)) {\n\t\t\t \n\t\t\tav7110->analog_tuner_flags |= ANALOG_TUNER_VES1820;\n\t\t} else if ((av7110->dev->pci->subsystem_vendor == 0x13c2) && (av7110->dev->pci->subsystem_device == 0x000A)) {\n\t\t\t \n\t\t\tav7110->analog_tuner_flags |= ANALOG_TUNER_STV0297;\n\t\t}\n\n\t\t \n\t\tif (av7110->analog_tuner_flags & ANALOG_TUNER_VES1820) {\n\t\t\tif (ves1820_writereg(av7110->dev, 0x09, 0x0f, 0x20))\n\t\t\t\tdprintk(1, \"setting band in demodulator failed\\n\");\n\t\t} else if (av7110->analog_tuner_flags & ANALOG_TUNER_STV0297) {\n\t\t\tsaa7146_setgpio(av7110->dev, 1, SAA7146_GPIO_OUTLO); \n\t\t\tsaa7146_setgpio(av7110->dev, 3, SAA7146_GPIO_OUTLO); \n\t\t}\n\n\t\t \n\t\twhile (*i != 0xff) {\n\t\t\tif (i2c_writereg(av7110, 0x48, i[0], i[1]) != 1) {\n\t\t\t\tdprintk(1, \"saa7113 initialization failed @ card %d\", av7110->dvb_adapter.num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += 2;\n\t\t}\n\t\t \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x00bb, 0x02d0); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0001,  3); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0001, 18); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0001, 27); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0001, 48); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0001, 66); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0001, 72); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0005,  4); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 64); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0005,  0); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0005,  3); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 18); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 27); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 48); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 66); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 72); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0083, 0xa000); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0093, 0x00aa); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x009b, 0x04fc); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x00a3, 0x038e); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x00ab, 0x04c6); \n\t\tmsp_writereg(av7110, MSP_WR_DEM, 0x0056, 0); \n\t}\n\n\tmemcpy(standard, dvb_standard, sizeof(struct saa7146_standard) * 2);\n\t \n\tsaa7146_write(av7110->dev, DD1_STREAM_B, 0x00000000);\n\tsaa7146_write(av7110->dev, DD1_INIT, 0x03000700);\n\tsaa7146_write(av7110->dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\n\n\treturn 0;\n}\n\nint av7110_init_v4l(struct av7110 *av7110)\n{\n\tstruct saa7146_dev* dev = av7110->dev;\n\tstruct saa7146_ext_vv *vv_data;\n\tint ret;\n\n\t \n\tif (av7110->analog_tuner_flags)\n\t\tvv_data = &av7110_vv_data_c;\n\telse\n\t\tvv_data = &av7110_vv_data_st;\n\tret = saa7146_vv_init(dev, vv_data);\n\n\tif (ret) {\n\t\tERR(\"cannot init capture device. skipping\\n\");\n\t\treturn -ENODEV;\n\t}\n\tvv_data->vid_ops.vidioc_enum_input = vidioc_enum_input;\n\tvv_data->vid_ops.vidioc_g_input = vidioc_g_input;\n\tvv_data->vid_ops.vidioc_s_input = vidioc_s_input;\n\tvv_data->vid_ops.vidioc_g_tuner = vidioc_g_tuner;\n\tvv_data->vid_ops.vidioc_s_tuner = vidioc_s_tuner;\n\tvv_data->vid_ops.vidioc_g_frequency = vidioc_g_frequency;\n\tvv_data->vid_ops.vidioc_s_frequency = vidioc_s_frequency;\n\tvv_data->vid_ops.vidioc_enumaudio = vidioc_enumaudio;\n\tvv_data->vid_ops.vidioc_g_audio = vidioc_g_audio;\n\tvv_data->vid_ops.vidioc_s_audio = vidioc_s_audio;\n\tvv_data->vid_ops.vidioc_g_fmt_vbi_cap = NULL;\n\n\tvv_data->vbi_ops.vidioc_enum_output = vidioc_enum_output;\n\tvv_data->vbi_ops.vidioc_g_output = vidioc_g_output;\n\tvv_data->vbi_ops.vidioc_s_output = vidioc_s_output;\n\tvv_data->vbi_ops.vidioc_g_parm = NULL;\n\tvv_data->vbi_ops.vidioc_g_fmt_vbi_cap = NULL;\n\tvv_data->vbi_ops.vidioc_try_fmt_vbi_cap = NULL;\n\tvv_data->vbi_ops.vidioc_s_fmt_vbi_cap = NULL;\n\tvv_data->vbi_ops.vidioc_g_sliced_vbi_cap = vidioc_g_sliced_vbi_cap;\n\tvv_data->vbi_ops.vidioc_g_fmt_sliced_vbi_out = vidioc_g_fmt_sliced_vbi_out;\n\tvv_data->vbi_ops.vidioc_try_fmt_sliced_vbi_out = vidioc_try_fmt_sliced_vbi_out;\n\tvv_data->vbi_ops.vidioc_s_fmt_sliced_vbi_out = vidioc_s_fmt_sliced_vbi_out;\n\n\tif (FW_VERSION(av7110->arm_app) < 0x2623)\n\t\tvv_data->capabilities &= ~V4L2_CAP_SLICED_VBI_OUTPUT;\n\n\tif (saa7146_register_device(&av7110->v4l_dev, dev, \"av7110\", VFL_TYPE_VIDEO)) {\n\t\tERR(\"cannot register capture device. skipping\\n\");\n\t\tsaa7146_vv_release(dev);\n\t\treturn -ENODEV;\n\t}\n\tif (FW_VERSION(av7110->arm_app) >= 0x2623) {\n\t\tif (saa7146_register_device(&av7110->vbi_dev, dev, \"av7110\", VFL_TYPE_VBI))\n\t\t\tERR(\"cannot register vbi v4l2 device. skipping\\n\");\n\t}\n\treturn 0;\n}\n\nint av7110_exit_v4l(struct av7110 *av7110)\n{\n\tstruct saa7146_dev* dev = av7110->dev;\n\n\tsaa7146_unregister_device(&av7110->v4l_dev, av7110->dev);\n\tsaa7146_unregister_device(&av7110->vbi_dev, av7110->dev);\n\n\tsaa7146_vv_release(dev);\n\n\treturn 0;\n}\n\n\n\n \nstatic struct saa7146_standard standard[] = {\n\t{\n\t\t.name\t= \"PAL\",\t.id\t\t= V4L2_STD_PAL_BG,\n\t\t.v_offset\t= 0x15,\t.v_field\t= 288,\n\t\t.h_offset\t= 0x48,\t.h_pixels\t= 708,\n\t\t.v_max_out\t= 576,\t.h_max_out\t= 768,\n\t}, {\n\t\t.name\t= \"NTSC\",\t.id\t\t= V4L2_STD_NTSC_M,\n\t\t.v_offset\t= 0x10,\t.v_field\t= 244,\n\t\t.h_offset\t= 0x40,\t.h_pixels\t= 708,\n\t\t.v_max_out\t= 480,\t.h_max_out\t= 640,\n\t}\n};\n\nstatic struct saa7146_standard analog_standard[] = {\n\t{\n\t\t.name\t= \"PAL\",\t.id\t\t= V4L2_STD_PAL_BG,\n\t\t.v_offset\t= 0x1b,\t.v_field\t= 288,\n\t\t.h_offset\t= 0x08,\t.h_pixels\t= 708,\n\t\t.v_max_out\t= 576,\t.h_max_out\t= 768,\n\t}, {\n\t\t.name\t= \"NTSC\",\t.id\t\t= V4L2_STD_NTSC_M,\n\t\t.v_offset\t= 0x10,\t.v_field\t= 244,\n\t\t.h_offset\t= 0x40,\t.h_pixels\t= 708,\n\t\t.v_max_out\t= 480,\t.h_max_out\t= 640,\n\t}\n};\n\nstatic struct saa7146_standard dvb_standard[] = {\n\t{\n\t\t.name\t= \"PAL\",\t.id\t\t= V4L2_STD_PAL_BG,\n\t\t.v_offset\t= 0x14,\t.v_field\t= 288,\n\t\t.h_offset\t= 0x48,\t.h_pixels\t= 708,\n\t\t.v_max_out\t= 576,\t.h_max_out\t= 768,\n\t}, {\n\t\t.name\t= \"NTSC\",\t.id\t\t= V4L2_STD_NTSC_M,\n\t\t.v_offset\t= 0x10,\t.v_field\t= 244,\n\t\t.h_offset\t= 0x40,\t.h_pixels\t= 708,\n\t\t.v_max_out\t= 480,\t.h_max_out\t= 640,\n\t}\n};\n\nstatic int std_callback(struct saa7146_dev* dev, struct saa7146_standard *std)\n{\n\tstruct av7110 *av7110 = (struct av7110*) dev->ext_priv;\n\n\tif (std->id & V4L2_STD_PAL) {\n\t\tav7110->vidmode = AV7110_VIDEO_MODE_PAL;\n\t\tav7110_set_vidmode(av7110, av7110->vidmode);\n\t}\n\telse if (std->id & V4L2_STD_NTSC) {\n\t\tav7110->vidmode = AV7110_VIDEO_MODE_NTSC;\n\t\tav7110_set_vidmode(av7110, av7110->vidmode);\n\t}\n\telse\n\t\treturn -1;\n\n\treturn 0;\n}\n\n\nstatic struct saa7146_ext_vv av7110_vv_data_st = {\n\t.inputs\t\t= 1,\n\t.audios\t\t= 1,\n\t.capabilities\t= V4L2_CAP_SLICED_VBI_OUTPUT | V4L2_CAP_AUDIO,\n\t.flags\t\t= 0,\n\n\t.stds\t\t= &standard[0],\n\t.num_stds\t= ARRAY_SIZE(standard),\n\t.std_callback\t= &std_callback,\n\n\t.vbi_fops.write\t= av7110_vbi_write,\n};\n\nstatic struct saa7146_ext_vv av7110_vv_data_c = {\n\t.inputs\t\t= 1,\n\t.audios\t\t= 1,\n\t.capabilities\t= V4L2_CAP_TUNER | V4L2_CAP_SLICED_VBI_OUTPUT | V4L2_CAP_AUDIO,\n\t.flags\t\t= SAA7146_USE_PORT_B_FOR_VBI,\n\n\t.stds\t\t= &standard[0],\n\t.num_stds\t= ARRAY_SIZE(standard),\n\t.std_callback\t= &std_callback,\n\n\t.vbi_fops.write\t= av7110_vbi_write,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}