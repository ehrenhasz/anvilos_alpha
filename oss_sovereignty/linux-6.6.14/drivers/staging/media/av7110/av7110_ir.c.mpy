{
  "module_name": "av7110_ir.c",
  "hash_id": "d8be5839d1dc69f5a244b2fe8ac74c4623530bd02d04b421446a674664d4d41a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/av7110/av7110_ir.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <media/rc-core.h>\n\n#include \"av7110.h\"\n#include \"av7110_hw.h\"\n\n#define IR_RC5\t\t0\n#define IR_RCMM\t\t1\n#define IR_RC5_EXT\t2  \n\n \nvoid av7110_ir_handler(struct av7110 *av7110, u32 ircom)\n{\n\tstruct rc_dev *rcdev = av7110->ir.rcdev;\n\tenum rc_proto proto;\n\tu32 command, addr, scancode;\n\tu32 toggle;\n\n\tdprintk(4, \"ir command = %08x\\n\", ircom);\n\n\tif (rcdev) {\n\t\tswitch (av7110->ir.ir_config) {\n\t\tcase IR_RC5:  \n\t\t\tcommand = ircom & 0x3f;\n\t\t\taddr = (ircom >> 6) & 0x1f;\n\t\t\tscancode = RC_SCANCODE_RC5(addr, command);\n\t\t\ttoggle = ircom & 0x0800;\n\t\t\tproto = RC_PROTO_RC5;\n\t\t\tbreak;\n\n\t\tcase IR_RCMM:  \n\t\t\tscancode = ircom & ~0x8000;\n\t\t\ttoggle = ircom & 0x8000;\n\t\t\tproto = RC_PROTO_RCMM32;\n\t\t\tbreak;\n\n\t\tcase IR_RC5_EXT:\n\t\t\t \n\t\t\tcommand = ircom & 0x3f;\n\t\t\taddr = (ircom >> 6) & 0x1f;\n\t\t\tif (!(ircom & 0x1000))\n\t\t\t\tcommand |= 0x40;\n\t\t\tscancode = RC_SCANCODE_RC5(addr, command);\n\t\t\ttoggle = ircom & 0x0800;\n\t\t\tproto = RC_PROTO_RC5;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(2, \"unknown ir config %d\\n\",\n\t\t\t\tav7110->ir.ir_config);\n\t\t\treturn;\n\t\t}\n\n\t\trc_keydown(rcdev, proto, scancode, toggle != 0);\n\t}\n}\n\nint av7110_set_ir_config(struct av7110 *av7110)\n{\n\tdprintk(4, \"ir config = %08x\\n\", av7110->ir.ir_config);\n\n\treturn av7110_fw_cmd(av7110, COMTYPE_PIDFILTER, SetIR, 1,\n\t\t\t     av7110->ir.ir_config);\n}\n\nstatic int change_protocol(struct rc_dev *rcdev, u64 *rc_type)\n{\n\tstruct av7110 *av7110 = rcdev->priv;\n\tu32 ir_config;\n\n\tif (*rc_type & RC_PROTO_BIT_RCMM32) {\n\t\tir_config = IR_RCMM;\n\t\t*rc_type = RC_PROTO_BIT_RCMM32;\n\t} else if (*rc_type & RC_PROTO_BIT_RC5) {\n\t\tif (FW_VERSION(av7110->arm_app) >= 0x2620)\n\t\t\tir_config = IR_RC5_EXT;\n\t\telse\n\t\t\tir_config = IR_RC5;\n\t\t*rc_type = RC_PROTO_BIT_RC5;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (ir_config == av7110->ir.ir_config)\n\t\treturn 0;\n\n\tav7110->ir.ir_config = ir_config;\n\n\treturn av7110_set_ir_config(av7110);\n}\n\nint av7110_ir_init(struct av7110 *av7110)\n{\n\tstruct rc_dev *rcdev;\n\tstruct pci_dev *pci;\n\tint ret;\n\n\trcdev = rc_allocate_device(RC_DRIVER_SCANCODE);\n\tif (!rcdev)\n\t\treturn -ENOMEM;\n\n\tpci = av7110->dev->pci;\n\n\tsnprintf(av7110->ir.input_phys, sizeof(av7110->ir.input_phys),\n\t\t \"pci-%s/ir0\", pci_name(pci));\n\n\trcdev->device_name = av7110->card_name;\n\trcdev->driver_name = KBUILD_MODNAME;\n\trcdev->input_phys = av7110->ir.input_phys;\n\trcdev->input_id.bustype = BUS_PCI;\n\trcdev->input_id.version = 2;\n\tif (pci->subsystem_vendor) {\n\t\trcdev->input_id.vendor\t= pci->subsystem_vendor;\n\t\trcdev->input_id.product = pci->subsystem_device;\n\t} else {\n\t\trcdev->input_id.vendor\t= pci->vendor;\n\t\trcdev->input_id.product = pci->device;\n\t}\n\n\trcdev->dev.parent = &pci->dev;\n\trcdev->allowed_protocols = RC_PROTO_BIT_RC5 | RC_PROTO_BIT_RCMM32;\n\trcdev->change_protocol = change_protocol;\n\trcdev->map_name = RC_MAP_HAUPPAUGE;\n\trcdev->priv = av7110;\n\n\tav7110->ir.rcdev = rcdev;\n\tav7110->ir.ir_config = IR_RC5;\n\tav7110_set_ir_config(av7110);\n\n\tret = rc_register_device(rcdev);\n\tif (ret) {\n\t\tav7110->ir.rcdev = NULL;\n\t\trc_free_device(rcdev);\n\t}\n\n\treturn ret;\n}\n\nvoid av7110_ir_exit(struct av7110 *av7110)\n{\n\trc_unregister_device(av7110->ir.rcdev);\n}\n\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}