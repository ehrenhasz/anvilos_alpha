{
  "module_name": "av7110.c",
  "hash_id": "09a5e7de0aac8ead5175780fabef8af13c0f1aebc69a268c1e6514916b2cb230",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/av7110/av7110.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/timer.h>\n#include <linux/poll.h>\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/firmware.h>\n#include <linux/crc32.h>\n#include <linux/i2c.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n\n\n#include <linux/dvb/frontend.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"ttpci-eeprom.h\"\n#include \"av7110.h\"\n#include \"av7110_hw.h\"\n#include \"av7110_av.h\"\n#include \"av7110_ca.h\"\n#include \"av7110_ipack.h\"\n\n#include \"bsbe1.h\"\n#include \"lnbp21.h\"\n#include \"bsru6.h\"\n\n#define TS_WIDTH  376\n#define TS_HEIGHT 512\n#define TS_BUFLEN (TS_WIDTH*TS_HEIGHT)\n#define TS_MAX_PACKETS (TS_BUFLEN/TS_SIZE)\n\n\nint av7110_debug;\n\nstatic int vidmode = CVBS_RGB_OUT;\nstatic int pids_off;\nstatic int adac = DVB_ADAC_TI;\nstatic int hw_sections;\nstatic int rgb_on;\nstatic int volume = 255;\nstatic int budgetpatch;\nstatic int wss_cfg_4_3 = 0x4008;\nstatic int wss_cfg_16_9 = 0x0007;\nstatic int tv_standard;\nstatic int full_ts;\n\nmodule_param_named(debug, av7110_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"debug level (bitmask, default 0)\");\nmodule_param(vidmode, int, 0444);\nMODULE_PARM_DESC(vidmode,\"analog video out: 0 off, 1 CVBS+RGB (default), 2 CVBS+YC, 3 YC\");\nmodule_param(pids_off, int, 0444);\nMODULE_PARM_DESC(pids_off,\"clear video/audio/PCR PID filters when demux is closed\");\nmodule_param(adac, int, 0444);\nMODULE_PARM_DESC(adac,\"audio DAC type: 0 TI, 1 CRYSTAL, 2 MSP (use if autodetection fails)\");\nmodule_param(hw_sections, int, 0444);\nMODULE_PARM_DESC(hw_sections, \"0 use software section filter, 1 use hardware\");\nmodule_param(rgb_on, int, 0444);\nMODULE_PARM_DESC(rgb_on, \"For Siemens DVB-C cards only: Enable RGB control signal on SCART pin 16 to switch SCART video mode from CVBS to RGB\");\nmodule_param(volume, int, 0444);\nMODULE_PARM_DESC(volume, \"initial volume: default 255 (range 0-255)\");\nmodule_param(budgetpatch, int, 0444);\nMODULE_PARM_DESC(budgetpatch, \"use budget-patch hardware modification: default 0 (0 no, 1 autodetect, 2 always)\");\nmodule_param(full_ts, int, 0444);\nMODULE_PARM_DESC(full_ts, \"enable code for full-ts hardware modification: 0 disable (default), 1 enable\");\nmodule_param(wss_cfg_4_3, int, 0444);\nMODULE_PARM_DESC(wss_cfg_4_3, \"WSS 4:3 - default 0x4008 - bit 15: disable, 14: burst mode, 13..0: wss data\");\nmodule_param(wss_cfg_16_9, int, 0444);\nMODULE_PARM_DESC(wss_cfg_16_9, \"WSS 16:9 - default 0x0007 - bit 15: disable, 14: burst mode, 13..0: wss data\");\nmodule_param(tv_standard, int, 0444);\nMODULE_PARM_DESC(tv_standard, \"TV standard: 0 PAL (default), 1 NTSC\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic void restart_feeds(struct av7110 *av7110);\nstatic int budget_start_feed(struct dvb_demux_feed *feed);\nstatic int budget_stop_feed(struct dvb_demux_feed *feed);\n\nstatic int av7110_num;\n\n#define FE_FUNC_OVERRIDE(fe_func, av7110_copy, av7110_func) \\\n{\\\n\tif (fe_func != NULL) { \\\n\t\tav7110_copy = fe_func; \\\n\t\tfe_func = av7110_func; \\\n\t} \\\n}\n\n\nstatic void init_av7110_av(struct av7110 *av7110)\n{\n\tint ret;\n\tstruct saa7146_dev *dev = av7110->dev;\n\n\t \n\tav7110->adac_type = DVB_ADAC_TI;\n\tret = av7110_set_volume(av7110, av7110->mixer.volume_left, av7110->mixer.volume_right);\n\tif (ret < 0)\n\t\tprintk(\"dvb-ttpci:cannot set internal volume to maximum:%d\\n\",ret);\n\n\tret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetMonitorType,\n\t\t\t    1, (u16) av7110->display_ar);\n\tif (ret < 0)\n\t\tprintk(\"dvb-ttpci: unable to set aspect ratio\\n\");\n\tret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetPanScanType,\n\t\t\t    1, av7110->display_panscan);\n\tif (ret < 0)\n\t\tprintk(\"dvb-ttpci: unable to set pan scan\\n\");\n\n\tret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetWSSConfig, 2, 2, wss_cfg_4_3);\n\tif (ret < 0)\n\t\tprintk(\"dvb-ttpci: unable to configure 4:3 wss\\n\");\n\tret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetWSSConfig, 2, 3, wss_cfg_16_9);\n\tif (ret < 0)\n\t\tprintk(\"dvb-ttpci: unable to configure 16:9 wss\\n\");\n\n\tret = av7710_set_video_mode(av7110, vidmode);\n\tif (ret < 0)\n\t\tprintk(\"dvb-ttpci:cannot set video mode:%d\\n\",ret);\n\n\t \n\t \n\tav7110->analog_tuner_flags = 0;\n\tav7110->current_input = 0;\n\tif (dev->pci->subsystem_vendor == 0x13c2 && dev->pci->subsystem_device == 0x000a)\n\t\tav7110_fw_cmd(av7110, COMTYPE_AUDIODAC, ADSwitch, 1, 0); \n\tif (i2c_writereg(av7110, 0x20, 0x00, 0x00) == 1) {\n\t\tprintk (\"dvb-ttpci: Crystal audio DAC @ card %d detected\\n\",\n\t\t\tav7110->dvb_adapter.num);\n\t\tav7110->adac_type = DVB_ADAC_CRYSTAL;\n\t\ti2c_writereg(av7110, 0x20, 0x01, 0xd2);\n\t\ti2c_writereg(av7110, 0x20, 0x02, 0x49);\n\t\ti2c_writereg(av7110, 0x20, 0x03, 0x00);\n\t\ti2c_writereg(av7110, 0x20, 0x04, 0x00);\n\n\t\t \n\t} else if (0 == av7110_init_analog_module(av7110)) {\n\t\t \n\t}\n\telse if (dev->pci->subsystem_vendor == 0x110a) {\n\t\tprintk(\"dvb-ttpci: DVB-C w/o analog module @ card %d detected\\n\",\n\t\t\tav7110->dvb_adapter.num);\n\t\tav7110->adac_type = DVB_ADAC_NONE;\n\t}\n\telse {\n\t\tav7110->adac_type = adac;\n\t\tprintk(\"dvb-ttpci: adac type set to %d @ card %d\\n\",\n\t\t\tav7110->adac_type, av7110->dvb_adapter.num);\n\t}\n\n\tif (av7110->adac_type == DVB_ADAC_NONE || av7110->adac_type == DVB_ADAC_MSP34x0) {\n\t\t\n\t\tret = av7110_fw_cmd(av7110, COMTYPE_AUDIODAC, MainSwitch, 1, 0);\n\t\tif (ret < 0)\n\t\t\tprintk(\"dvb-ttpci:cannot switch on SCART(Main):%d\\n\",ret);\n\t\tret = av7110_fw_cmd(av7110, COMTYPE_AUDIODAC, ADSwitch, 1, 1);\n\t\tif (ret < 0)\n\t\t\tprintk(\"dvb-ttpci:cannot switch on SCART(AD):%d\\n\",ret);\n\t\tif (rgb_on &&\n\t\t    ((av7110->dev->pci->subsystem_vendor == 0x110a) ||\n\t\t     (av7110->dev->pci->subsystem_vendor == 0x13c2)) &&\n\t\t     (av7110->dev->pci->subsystem_device == 0x0000)) {\n\t\t\tsaa7146_setgpio(dev, 1, SAA7146_GPIO_OUTHI); \n\t\t\t\n\t\t}\n\t}\n\n\tif (dev->pci->subsystem_vendor == 0x13c2 && dev->pci->subsystem_device == 0x000e)\n\t\tav7110_fw_cmd(av7110, COMTYPE_AUDIODAC, SpdifSwitch, 1, 0); \n\n\tret = av7110_set_volume(av7110, av7110->mixer.volume_left, av7110->mixer.volume_right);\n\tif (ret < 0)\n\t\tprintk(\"dvb-ttpci:cannot set volume :%d\\n\",ret);\n}\n\nstatic void recover_arm(struct av7110 *av7110)\n{\n\tdprintk(4, \"%p\\n\",av7110);\n\n\tav7110_bootarm(av7110);\n\tmsleep(100);\n\n\tinit_av7110_av(av7110);\n\n\t \n\tif (av7110->recover)\n\t\tav7110->recover(av7110);\n\n\trestart_feeds(av7110);\n\n#if IS_ENABLED(CONFIG_DVB_AV7110_IR)\n\tav7110_set_ir_config(av7110);\n#endif\n}\n\nstatic void av7110_arm_sync(struct av7110 *av7110)\n{\n\tif (av7110->arm_thread)\n\t\tkthread_stop(av7110->arm_thread);\n\n\tav7110->arm_thread = NULL;\n}\n\nstatic int arm_thread(void *data)\n{\n\tstruct av7110 *av7110 = data;\n\tu16 newloops = 0;\n\tint timeout;\n\n\tdprintk(4, \"%p\\n\",av7110);\n\n\tfor (;;) {\n\t\ttimeout = wait_event_interruptible_timeout(av7110->arm_wait,\n\t\t\tkthread_should_stop(), 5 * HZ);\n\n\t\tif (-ERESTARTSYS == timeout || kthread_should_stop()) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tif (!av7110->arm_ready)\n\t\t\tcontinue;\n\n\t\tif (mutex_lock_interruptible(&av7110->dcomlock))\n\t\t\tbreak;\n\t\tnewloops = rdebi(av7110, DEBINOSWAP, STATUS_LOOPS, 0, 2);\n\t\tmutex_unlock(&av7110->dcomlock);\n\n\t\tif (newloops == av7110->arm_loops || av7110->arm_errors > 3) {\n\t\t\tprintk(KERN_ERR \"dvb-ttpci: ARM crashed @ card %d\\n\",\n\t\t\t       av7110->dvb_adapter.num);\n\n\t\t\trecover_arm(av7110);\n\n\t\t\tif (mutex_lock_interruptible(&av7110->dcomlock))\n\t\t\t\tbreak;\n\t\t\tnewloops = rdebi(av7110, DEBINOSWAP, STATUS_LOOPS, 0, 2) - 1;\n\t\t\tmutex_unlock(&av7110->dcomlock);\n\t\t}\n\t\tav7110->arm_loops = newloops;\n\t\tav7110->arm_errors = 0;\n\t}\n\n\treturn 0;\n}\n\n\n \n\nstatic int DvbDmxFilterCallback(u8 *buffer1, size_t buffer1_len,\n\t\t\t\tu8 *buffer2, size_t buffer2_len,\n\t\t\t\tstruct dvb_demux_filter *dvbdmxfilter,\n\t\t\t\tstruct av7110 *av7110)\n{\n\tif (!dvbdmxfilter->feed->demux->dmx.frontend)\n\t\treturn 0;\n\tif (dvbdmxfilter->feed->demux->dmx.frontend->source == DMX_MEMORY_FE)\n\t\treturn 0;\n\n\tswitch (dvbdmxfilter->type) {\n\tcase DMX_TYPE_SEC:\n\t\tif ((((buffer1[1] << 8) | buffer1[2]) & 0xfff) + 3 != buffer1_len)\n\t\t\treturn 0;\n\t\tif (dvbdmxfilter->doneq) {\n\t\t\tstruct dmx_section_filter *filter = &dvbdmxfilter->filter;\n\t\t\tint i;\n\t\t\tu8 xor, neq = 0;\n\n\t\t\tfor (i = 0; i < DVB_DEMUX_MASK_MAX; i++) {\n\t\t\t\txor = filter->filter_value[i] ^ buffer1[i];\n\t\t\t\tneq |= dvbdmxfilter->maskandnotmode[i] & xor;\n\t\t\t}\n\t\t\tif (!neq)\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn dvbdmxfilter->feed->cb.sec(buffer1, buffer1_len,\n\t\t\t\t\t\t  buffer2, buffer2_len,\n\t\t\t\t\t\t  &dvbdmxfilter->filter, NULL);\n\tcase DMX_TYPE_TS:\n\t\tif (!(dvbdmxfilter->feed->ts_type & TS_PACKET))\n\t\t\treturn 0;\n\t\tif (dvbdmxfilter->feed->ts_type & TS_PAYLOAD_ONLY)\n\t\t\treturn dvbdmxfilter->feed->cb.ts(buffer1, buffer1_len,\n\t\t\t\t\t\t\t buffer2, buffer2_len,\n\t\t\t\t\t\t\t &dvbdmxfilter->feed->feed.ts,\n\t\t\t\t\t\t\t NULL);\n\t\telse\n\t\t\tav7110_p2t_write(buffer1, buffer1_len,\n\t\t\t\t\t dvbdmxfilter->feed->pid,\n\t\t\t\t\t &av7110->p2t_filter[dvbdmxfilter->index]);\n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\n\nstatic inline void print_time(char *s)\n{\n#ifdef DEBUG_TIMING\n\tstruct timespec64 ts;\n\tktime_get_real_ts64(&ts);\n\tprintk(\"%s: %lld.%09ld\\n\", s, (s64)ts.tv_sec, ts.tv_nsec);\n#endif\n}\n\n#define DEBI_READ 0\n#define DEBI_WRITE 1\nstatic inline void start_debi_dma(struct av7110 *av7110, int dir,\n\t\t\t\t  unsigned long addr, unsigned int len)\n{\n\tdprintk(8, \"%c %08lx %u\\n\", dir == DEBI_READ ? 'R' : 'W', addr, len);\n\tif (saa7146_wait_for_debi_done(av7110->dev, 0)) {\n\t\tprintk(KERN_ERR \"%s: saa7146_wait_for_debi_done timed out\\n\", __func__);\n\t\treturn;\n\t}\n\n\tSAA7146_ISR_CLEAR(av7110->dev, MASK_19);  \n\tSAA7146_IER_ENABLE(av7110->dev, MASK_19);\n\tif (len < 5)\n\t\tlen = 5;  \n\tif (dir == DEBI_WRITE)\n\t\tiwdebi(av7110, DEBISWAB, addr, 0, (len + 3) & ~3);\n\telse\n\t\tirdebi(av7110, DEBISWAB, addr, 0, len);\n}\n\nstatic void debiirq(struct tasklet_struct *t)\n{\n\tstruct av7110 *av7110 = from_tasklet(av7110, t, debi_tasklet);\n\tint type = av7110->debitype;\n\tint handle = (type >> 8) & 0x1f;\n\tunsigned int xfer = 0;\n\n\tprint_time(\"debi\");\n\tdprintk(4, \"type 0x%04x\\n\", type);\n\n\tif (type == -1) {\n\t\tprintk(\"DEBI irq oops @ %ld, psr:0x%08x, ssr:0x%08x\\n\",\n\t\t       jiffies, saa7146_read(av7110->dev, PSR),\n\t\t       saa7146_read(av7110->dev, SSR));\n\t\tgoto debi_done;\n\t}\n\tav7110->debitype = -1;\n\n\tswitch (type & 0xff) {\n\n\tcase DATA_TS_RECORD:\n\t\tdvb_dmx_swfilter_packets(&av7110->demux,\n\t\t\t\t\t (const u8 *) av7110->debi_virt,\n\t\t\t\t\t av7110->debilen / 188);\n\t\txfer = RX_BUFF;\n\t\tbreak;\n\n\tcase DATA_PES_RECORD:\n\t\tif (av7110->demux.recording)\n\t\t\tav7110_record_cb(&av7110->p2t[handle],\n\t\t\t\t\t (u8 *) av7110->debi_virt,\n\t\t\t\t\t av7110->debilen);\n\t\txfer = RX_BUFF;\n\t\tbreak;\n\n\tcase DATA_IPMPE:\n\tcase DATA_FSECTION:\n\tcase DATA_PIPING:\n\t\tif (av7110->handle2filter[handle])\n\t\t\tDvbDmxFilterCallback((u8 *)av7110->debi_virt,\n\t\t\t\t\t     av7110->debilen, NULL, 0,\n\t\t\t\t\t     av7110->handle2filter[handle],\n\t\t\t\t\t     av7110);\n\t\txfer = RX_BUFF;\n\t\tbreak;\n\n\tcase DATA_CI_GET:\n\t{\n\t\tu8 *data = av7110->debi_virt;\n\t\tu8 data_0 = data[0];\n\n\t\tif (data_0 < 2 && data[2] == 0xff) {\n\t\t\tint flags = 0;\n\t\t\tif (data[5] > 0)\n\t\t\t\tflags |= CA_CI_MODULE_PRESENT;\n\t\t\tif (data[5] > 5)\n\t\t\t\tflags |= CA_CI_MODULE_READY;\n\t\t\tav7110->ci_slot[data_0].flags = flags;\n\t\t} else\n\t\t\tci_get_data(&av7110->ci_rbuffer,\n\t\t\t\t    av7110->debi_virt,\n\t\t\t\t    av7110->debilen);\n\t\txfer = RX_BUFF;\n\t\tbreak;\n\t}\n\n\tcase DATA_COMMON_INTERFACE:\n\t\tCI_handle(av7110, (u8 *)av7110->debi_virt, av7110->debilen);\n\t\txfer = RX_BUFF;\n\t\tbreak;\n\n\tcase DATA_DEBUG_MESSAGE:\n\t\t((s8*)av7110->debi_virt)[Reserved_SIZE - 1] = 0;\n\t\tprintk(\"%s\\n\", (s8 *) av7110->debi_virt);\n\t\txfer = RX_BUFF;\n\t\tbreak;\n\n\tcase DATA_CI_PUT:\n\t\tdprintk(4, \"debi DATA_CI_PUT\\n\");\n\t\txfer = TX_BUFF;\n\t\tbreak;\n\tcase DATA_MPEG_PLAY:\n\t\tdprintk(4, \"debi DATA_MPEG_PLAY\\n\");\n\t\txfer = TX_BUFF;\n\t\tbreak;\n\tcase DATA_BMP_LOAD:\n\t\tdprintk(4, \"debi DATA_BMP_LOAD\\n\");\n\t\txfer = TX_BUFF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\ndebi_done:\n\tspin_lock(&av7110->debilock);\n\tif (xfer)\n\t\tiwdebi(av7110, DEBINOSWAP, xfer, 0, 2);\n\tARM_ClearMailBox(av7110);\n\tspin_unlock(&av7110->debilock);\n}\n\n \nstatic void gpioirq(struct tasklet_struct *t)\n{\n\tstruct av7110 *av7110 = from_tasklet(av7110, t, gpio_tasklet);\n\tu32 rxbuf, txbuf;\n\tint len;\n\n\tif (av7110->debitype != -1)\n\t\t \n\t\tprintk(\"dvb-ttpci: GPIO0 irq oops @ %ld, psr:0x%08x, ssr:0x%08x\\n\",\n\t\t       jiffies, saa7146_read(av7110->dev, PSR),\n\t\t       saa7146_read(av7110->dev, SSR));\n\n\tif (saa7146_wait_for_debi_done(av7110->dev, 0)) {\n\t\tprintk(KERN_ERR \"%s: saa7146_wait_for_debi_done timed out\\n\", __func__);\n\t\tBUG();  \n\t}\n\n\tspin_lock(&av7110->debilock);\n\tARM_ClearIrq(av7110);\n\n\t \n\tav7110->debitype = irdebi(av7110, DEBINOSWAP, IRQ_STATE, 0, 2);\n\tav7110->debilen  = irdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\n\trxbuf = irdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);\n\ttxbuf = irdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);\n\tlen = (av7110->debilen + 3) & ~3;\n\n\tprint_time(\"gpio\");\n\tdprintk(8, \"GPIO0 irq 0x%04x %d\\n\", av7110->debitype, av7110->debilen);\n\n\tswitch (av7110->debitype & 0xff) {\n\n\tcase DATA_TS_PLAY:\n\tcase DATA_PES_PLAY:\n\t\tbreak;\n\n\tcase DATA_MPEG_VIDEO_EVENT:\n\t{\n\t\tu32 h_ar;\n\t\tstruct video_event event;\n\n\t\tav7110->video_size.w = irdebi(av7110, DEBINOSWAP, STATUS_MPEG_WIDTH, 0, 2);\n\t\th_ar = irdebi(av7110, DEBINOSWAP, STATUS_MPEG_HEIGHT_AR, 0, 2);\n\n\t\tiwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\n\t\tiwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);\n\n\t\tav7110->video_size.h = h_ar & 0xfff;\n\n\t\tevent.type = VIDEO_EVENT_SIZE_CHANGED;\n\t\tevent.u.size.w = av7110->video_size.w;\n\t\tevent.u.size.h = av7110->video_size.h;\n\t\tswitch ((h_ar >> 12) & 0xf)\n\t\t{\n\t\tcase 3:\n\t\t\tav7110->video_size.aspect_ratio = VIDEO_FORMAT_16_9;\n\t\t\tevent.u.size.aspect_ratio = VIDEO_FORMAT_16_9;\n\t\t\tav7110->videostate.video_format = VIDEO_FORMAT_16_9;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tav7110->video_size.aspect_ratio = VIDEO_FORMAT_221_1;\n\t\t\tevent.u.size.aspect_ratio = VIDEO_FORMAT_221_1;\n\t\t\tav7110->videostate.video_format = VIDEO_FORMAT_221_1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tav7110->video_size.aspect_ratio = VIDEO_FORMAT_4_3;\n\t\t\tevent.u.size.aspect_ratio = VIDEO_FORMAT_4_3;\n\t\t\tav7110->videostate.video_format = VIDEO_FORMAT_4_3;\n\t\t}\n\n\t\tdprintk(8, \"GPIO0 irq: DATA_MPEG_VIDEO_EVENT: w/h/ar = %u/%u/%u\\n\",\n\t\t\tav7110->video_size.w, av7110->video_size.h,\n\t\t\tav7110->video_size.aspect_ratio);\n\n\t\tdvb_video_add_event(av7110, &event);\n\t\tbreak;\n\t}\n\n\tcase DATA_CI_PUT:\n\t{\n\t\tint avail;\n\t\tstruct dvb_ringbuffer *cibuf = &av7110->ci_wbuffer;\n\n\t\tavail = dvb_ringbuffer_avail(cibuf);\n\t\tif (avail <= 2) {\n\t\t\tiwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\n\t\t\tiwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);\n\t\t\tiwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);\n\t\t\tbreak;\n\t\t}\n\t\tlen = DVB_RINGBUFFER_PEEK(cibuf, 0) << 8;\n\t\tlen |= DVB_RINGBUFFER_PEEK(cibuf, 1);\n\t\tif (avail < len + 2) {\n\t\t\tiwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\n\t\t\tiwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);\n\t\t\tiwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);\n\t\t\tbreak;\n\t\t}\n\t\tDVB_RINGBUFFER_SKIP(cibuf, 2);\n\n\t\tdvb_ringbuffer_read(cibuf, av7110->debi_virt, len);\n\n\t\tiwdebi(av7110, DEBINOSWAP, TX_LEN, len, 2);\n\t\tiwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, len, 2);\n\t\tdprintk(8, \"DMA: CI\\n\");\n\t\tstart_debi_dma(av7110, DEBI_WRITE, DPRAM_BASE + txbuf, len);\n\t\tspin_unlock(&av7110->debilock);\n\t\twake_up(&cibuf->queue);\n\t\treturn;\n\t}\n\n\tcase DATA_MPEG_PLAY:\n\t\tif (!av7110->playing) {\n\t\t\tiwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\n\t\t\tiwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);\n\t\t\tiwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);\n\t\t\tbreak;\n\t\t}\n\t\tlen = 0;\n\t\tif (av7110->debitype & 0x100) {\n\t\t\tspin_lock(&av7110->aout.lock);\n\t\t\tlen = av7110_pes_play(av7110->debi_virt, &av7110->aout, 2048);\n\t\t\tspin_unlock(&av7110->aout.lock);\n\t\t}\n\t\tif (len <= 0 && (av7110->debitype & 0x200)\n\t\t    &&av7110->videostate.play_state != VIDEO_FREEZED) {\n\t\t\tspin_lock(&av7110->avout.lock);\n\t\t\tlen = av7110_pes_play(av7110->debi_virt, &av7110->avout, 2048);\n\t\t\tspin_unlock(&av7110->avout.lock);\n\t\t}\n\t\tif (len <= 0) {\n\t\t\tiwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\n\t\t\tiwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);\n\t\t\tiwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);\n\t\t\tbreak;\n\t\t}\n\t\tdprintk(8, \"GPIO0 PES_PLAY len=%04x\\n\", len);\n\t\tiwdebi(av7110, DEBINOSWAP, TX_LEN, len, 2);\n\t\tiwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, len, 2);\n\t\tdprintk(8, \"DMA: MPEG_PLAY\\n\");\n\t\tstart_debi_dma(av7110, DEBI_WRITE, DPRAM_BASE + txbuf, len);\n\t\tspin_unlock(&av7110->debilock);\n\t\treturn;\n\n\tcase DATA_BMP_LOAD:\n\t\tlen = av7110->debilen;\n\t\tdprintk(8, \"gpio DATA_BMP_LOAD len %d\\n\", len);\n\t\tif (!len) {\n\t\t\tav7110->bmp_state = BMP_LOADED;\n\t\t\tiwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\n\t\t\tiwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);\n\t\t\tiwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);\n\t\t\twake_up(&av7110->bmpq);\n\t\t\tdprintk(8, \"gpio DATA_BMP_LOAD done\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (len > av7110->bmplen)\n\t\t\tlen = av7110->bmplen;\n\t\tif (len > 2 * 1024)\n\t\t\tlen = 2 * 1024;\n\t\tiwdebi(av7110, DEBINOSWAP, TX_LEN, len, 2);\n\t\tiwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, len, 2);\n\t\tmemcpy(av7110->debi_virt, av7110->bmpbuf+av7110->bmpp, len);\n\t\tav7110->bmpp += len;\n\t\tav7110->bmplen -= len;\n\t\tdprintk(8, \"gpio DATA_BMP_LOAD DMA len %d\\n\", len);\n\t\tstart_debi_dma(av7110, DEBI_WRITE, DPRAM_BASE+txbuf, len);\n\t\tspin_unlock(&av7110->debilock);\n\t\treturn;\n\n\tcase DATA_CI_GET:\n\tcase DATA_COMMON_INTERFACE:\n\tcase DATA_FSECTION:\n\tcase DATA_IPMPE:\n\tcase DATA_PIPING:\n\t\tif (!len || len > 4 * 1024) {\n\t\t\tiwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tcase DATA_TS_RECORD:\n\tcase DATA_PES_RECORD:\n\t\tdprintk(8, \"DMA: TS_REC etc.\\n\");\n\t\tstart_debi_dma(av7110, DEBI_READ, DPRAM_BASE+rxbuf, len);\n\t\tspin_unlock(&av7110->debilock);\n\t\treturn;\n\n\tcase DATA_DEBUG_MESSAGE:\n\t\tif (!len || len > 0xff) {\n\t\t\tiwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);\n\t\t\tbreak;\n\t\t}\n\t\tstart_debi_dma(av7110, DEBI_READ, Reserved, len);\n\t\tspin_unlock(&av7110->debilock);\n\t\treturn;\n\n\tcase DATA_IRCOMMAND:\n#if IS_ENABLED(CONFIG_DVB_AV7110_IR)\n\t\tav7110_ir_handler(av7110,\n\t\t\t\t  swahw32(irdebi(av7110, DEBINOSWAP, Reserved,\n\t\t\t\t\t\t 0, 4)));\n#endif\n\t\tiwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(\"dvb-ttpci: gpioirq unknown type=%d len=%d\\n\",\n\t\t       av7110->debitype, av7110->debilen);\n\t\tbreak;\n\t}\n\tav7110->debitype = -1;\n\tARM_ClearMailBox(av7110);\n\tspin_unlock(&av7110->debilock);\n}\n\n\n#ifdef CONFIG_DVB_AV7110_OSD\nstatic int dvb_osd_ioctl(struct file *file,\n\t\t\t unsigned int cmd, void *parg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct av7110 *av7110 = dvbdev->priv;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (cmd == OSD_SEND_CMD)\n\t\treturn av7110_osd_cmd(av7110, (osd_cmd_t *) parg);\n\tif (cmd == OSD_GET_CAPABILITY)\n\t\treturn av7110_osd_capability(av7110, (osd_cap_t *) parg);\n\n\treturn -EINVAL;\n}\n\n\nstatic const struct file_operations dvb_osd_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= dvb_generic_ioctl,\n\t.open\t\t= dvb_generic_open,\n\t.release\t= dvb_generic_release,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct dvb_device dvbdev_osd = {\n\t.priv\t\t= NULL,\n\t.users\t\t= 1,\n\t.writers\t= 1,\n\t.fops\t\t= &dvb_osd_fops,\n\t.kernel_ioctl\t= dvb_osd_ioctl,\n};\n#endif  \n\n\nstatic inline int SetPIDs(struct av7110 *av7110, u16 vpid, u16 apid, u16 ttpid,\n\t\t\t  u16 subpid, u16 pcrpid)\n{\n\tu16 aflags = 0;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (vpid == 0x1fff || apid == 0x1fff ||\n\t    ttpid == 0x1fff || subpid == 0x1fff || pcrpid == 0x1fff) {\n\t\tvpid = apid = ttpid = subpid = pcrpid = 0;\n\t\tav7110->pids[DMX_PES_VIDEO] = 0;\n\t\tav7110->pids[DMX_PES_AUDIO] = 0;\n\t\tav7110->pids[DMX_PES_TELETEXT] = 0;\n\t\tav7110->pids[DMX_PES_PCR] = 0;\n\t}\n\n\tif (av7110->audiostate.bypass_mode)\n\t\taflags |= 0x8000;\n\n\treturn av7110_fw_cmd(av7110, COMTYPE_PIDFILTER, MultiPID, 6,\n\t\t\t     pcrpid, vpid, apid, ttpid, subpid, aflags);\n}\n\nint ChangePIDs(struct av7110 *av7110, u16 vpid, u16 apid, u16 ttpid,\n\t\tu16 subpid, u16 pcrpid)\n{\n\tint ret = 0;\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (mutex_lock_interruptible(&av7110->pid_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (!(vpid & 0x8000))\n\t\tav7110->pids[DMX_PES_VIDEO] = vpid;\n\tif (!(apid & 0x8000))\n\t\tav7110->pids[DMX_PES_AUDIO] = apid;\n\tif (!(ttpid & 0x8000))\n\t\tav7110->pids[DMX_PES_TELETEXT] = ttpid;\n\tif (!(pcrpid & 0x8000))\n\t\tav7110->pids[DMX_PES_PCR] = pcrpid;\n\n\tav7110->pids[DMX_PES_SUBTITLE] = 0;\n\n\tif (av7110->fe_synced) {\n\t\tpcrpid = av7110->pids[DMX_PES_PCR];\n\t\tret = SetPIDs(av7110, vpid, apid, ttpid, subpid, pcrpid);\n\t}\n\n\tmutex_unlock(&av7110->pid_mutex);\n\treturn ret;\n}\n\n\n \n\nstatic int StartHWFilter(struct dvb_demux_filter *dvbdmxfilter)\n{\n\tstruct dvb_demux_feed *dvbdmxfeed = dvbdmxfilter->feed;\n\tstruct av7110 *av7110 = dvbdmxfeed->demux->priv;\n\tu16 buf[20];\n\tint ret, i;\n\tu16 handle;\n \n\tu16 mode = 0xb96a;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (av7110->full_ts)\n\t\treturn 0;\n\n\tif (dvbdmxfilter->type == DMX_TYPE_SEC) {\n\t\tif (hw_sections) {\n\t\t\tbuf[4] = (dvbdmxfilter->filter.filter_value[0] << 8) |\n\t\t\t\tdvbdmxfilter->maskandmode[0];\n\t\t\tfor (i = 3; i < 18; i++)\n\t\t\t\tbuf[i + 4 - 2] =\n\t\t\t\t\t(dvbdmxfilter->filter.filter_value[i] << 8) |\n\t\t\t\t\tdvbdmxfilter->maskandmode[i];\n\t\t\tmode = 4;\n\t\t}\n\t} else if ((dvbdmxfeed->ts_type & TS_PACKET) &&\n\t\t   !(dvbdmxfeed->ts_type & TS_PAYLOAD_ONLY)) {\n\t\tav7110_p2t_init(&av7110->p2t_filter[dvbdmxfilter->index], dvbdmxfeed);\n\t}\n\n\tbuf[0] = (COMTYPE_PID_FILTER << 8) + AddPIDFilter;\n\tbuf[1] = 16;\n\tbuf[2] = dvbdmxfeed->pid;\n\tbuf[3] = mode;\n\n\tret = av7110_fw_request(av7110, buf, 20, &handle, 1);\n\tif (ret != 0 || handle >= 32) {\n\t\tprintk(KERN_ERR \"dvb-ttpci: %s error  buf %04x %04x %04x %04x  ret %d  handle %04x\\n\",\n\t\t\t\t__func__, buf[0], buf[1], buf[2], buf[3],\n\t\t\t\tret, handle);\n\t\tdvbdmxfilter->hw_handle = 0xffff;\n\t\tif (!ret)\n\t\t\tret = -1;\n\t\treturn ret;\n\t}\n\n\tav7110->handle2filter[handle] = dvbdmxfilter;\n\tdvbdmxfilter->hw_handle = handle;\n\n\treturn ret;\n}\n\nstatic int StopHWFilter(struct dvb_demux_filter *dvbdmxfilter)\n{\n\tstruct av7110 *av7110 = dvbdmxfilter->feed->demux->priv;\n\tu16 buf[3];\n\tu16 answ[2];\n\tint ret;\n\tu16 handle;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (av7110->full_ts)\n\t\treturn 0;\n\n\thandle = dvbdmxfilter->hw_handle;\n\tif (handle >= 32) {\n\t\tprintk(\"%s tried to stop invalid filter %04x, filter type = %x\\n\",\n\t\t\t\t__func__, handle, dvbdmxfilter->type);\n\t\treturn -EINVAL;\n\t}\n\n\tav7110->handle2filter[handle] = NULL;\n\n\tbuf[0] = (COMTYPE_PID_FILTER << 8) + DelPIDFilter;\n\tbuf[1] = 1;\n\tbuf[2] = handle;\n\tret = av7110_fw_request(av7110, buf, 3, answ, 2);\n\tif (ret != 0 || answ[1] != handle) {\n\t\tprintk(KERN_ERR \"dvb-ttpci: %s error  cmd %04x %04x %04x  ret %x  resp %04x %04x  pid %d\\n\",\n\t\t\t\t__func__, buf[0], buf[1], buf[2], ret,\n\t\t\t\tansw[0], answ[1], dvbdmxfilter->feed->pid);\n\t\tif (!ret)\n\t\t\tret = -1;\n\t}\n\treturn ret;\n}\n\n\nstatic int dvb_feed_start_pid(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tstruct av7110 *av7110 = dvbdmx->priv;\n\tu16 *pid = dvbdmx->pids, npids[5];\n\tint i;\n\tint ret = 0;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tnpids[0] = npids[1] = npids[2] = npids[3] = npids[4] = 0xffff;\n\ti = dvbdmxfeed->pes_type;\n\tnpids[i] = (pid[i]&0x8000) ? 0 : pid[i];\n\tif ((i == 2) && npids[i] && (dvbdmxfeed->ts_type & TS_PACKET)) {\n\t\tnpids[i] = 0;\n\t\tret = ChangePIDs(av7110, npids[1], npids[0], npids[2], npids[3], npids[4]);\n\t\tif (!ret)\n\t\t\tret = StartHWFilter(dvbdmxfeed->filter);\n\t\treturn ret;\n\t}\n\tif (dvbdmxfeed->pes_type <= 2 || dvbdmxfeed->pes_type == 4) {\n\t\tret = ChangePIDs(av7110, npids[1], npids[0], npids[2], npids[3], npids[4]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dvbdmxfeed->pes_type < 2 && npids[0])\n\t\tif (av7110->fe_synced)\n\t\t{\n\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_PIDFILTER, Scan, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\tif ((dvbdmxfeed->ts_type & TS_PACKET) && !av7110->full_ts) {\n\t\tif (dvbdmxfeed->pes_type == 0 && !(dvbdmx->pids[0] & 0x8000))\n\t\t\tret = av7110_av_start_record(av7110, RP_AUDIO, dvbdmxfeed);\n\t\tif (dvbdmxfeed->pes_type == 1 && !(dvbdmx->pids[1] & 0x8000))\n\t\t\tret = av7110_av_start_record(av7110, RP_VIDEO, dvbdmxfeed);\n\t}\n\treturn ret;\n}\n\nstatic int dvb_feed_stop_pid(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tstruct av7110 *av7110 = dvbdmx->priv;\n\tu16 *pid = dvbdmx->pids, npids[5];\n\tint i;\n\n\tint ret = 0;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (dvbdmxfeed->pes_type <= 1) {\n\t\tret = av7110_av_stop(av7110, dvbdmxfeed->pes_type ?  RP_VIDEO : RP_AUDIO);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (!av7110->rec_mode)\n\t\t\tdvbdmx->recording = 0;\n\t\tif (!av7110->playing)\n\t\t\tdvbdmx->playing = 0;\n\t}\n\tnpids[0] = npids[1] = npids[2] = npids[3] = npids[4] = 0xffff;\n\ti = dvbdmxfeed->pes_type;\n\tswitch (i) {\n\tcase 2:  \n\t\tif (dvbdmxfeed->ts_type & TS_PACKET)\n\t\t\tret = StopHWFilter(dvbdmxfeed->filter);\n\t\tnpids[2] = 0;\n\t\tbreak;\n\tcase 0:\n\tcase 1:\n\tcase 4:\n\t\tif (!pids_off)\n\t\t\treturn 0;\n\t\tnpids[i] = (pid[i]&0x8000) ? 0 : pid[i];\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tret = ChangePIDs(av7110, npids[1], npids[0], npids[2], npids[3], npids[4]);\n\treturn ret;\n}\n\nstatic int av7110_start_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct av7110 *av7110 = demux->priv;\n\tint ret = 0;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (!demux->dmx.frontend)\n\t\treturn -EINVAL;\n\n\tif (!av7110->full_ts && feed->pid > 0x1fff)\n\t\treturn -EINVAL;\n\n\tif (feed->type == DMX_TYPE_TS) {\n\t\tif ((feed->ts_type & TS_DECODER) &&\n\t\t    (feed->pes_type <= DMX_PES_PCR)) {\n\t\t\tswitch (demux->dmx.frontend->source) {\n\t\t\tcase DMX_MEMORY_FE:\n\t\t\t\tif (feed->ts_type & TS_DECODER)\n\t\t\t\t       if (feed->pes_type < 2 &&\n\t\t\t\t\t   !(demux->pids[0] & 0x8000) &&\n\t\t\t\t\t   !(demux->pids[1] & 0x8000)) {\n\t\t\t\t\t       dvb_ringbuffer_flush_spinlock_wakeup(&av7110->avout);\n\t\t\t\t\t       dvb_ringbuffer_flush_spinlock_wakeup(&av7110->aout);\n\t\t\t\t\t       ret = av7110_av_start_play(av7110,RP_AV);\n\t\t\t\t\t       if (!ret)\n\t\t\t\t\t\t       demux->playing = 1;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = dvb_feed_start_pid(feed);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((feed->ts_type & TS_PACKET) &&\n\t\t\t   (demux->dmx.frontend->source != DMX_MEMORY_FE)) {\n\t\t\tret = StartHWFilter(feed->filter);\n\t\t}\n\t}\n\n\tif (av7110->full_ts) {\n\t\tbudget_start_feed(feed);\n\t\treturn ret;\n\t}\n\n\tif (feed->type == DMX_TYPE_SEC) {\n\t\tint i;\n\n\t\tfor (i = 0; i < demux->filternum; i++) {\n\t\t\tif (demux->filter[i].state != DMX_STATE_READY)\n\t\t\t\tcontinue;\n\t\t\tif (demux->filter[i].type != DMX_TYPE_SEC)\n\t\t\t\tcontinue;\n\t\t\tif (demux->filter[i].filter.parent != &feed->feed.sec)\n\t\t\t\tcontinue;\n\t\t\tdemux->filter[i].state = DMX_STATE_GO;\n\t\t\tif (demux->dmx.frontend->source != DMX_MEMORY_FE) {\n\t\t\t\tret = StartHWFilter(&demux->filter[i]);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nstatic int av7110_stop_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct av7110 *av7110 = demux->priv;\n\tint i, rc, ret = 0;\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (feed->type == DMX_TYPE_TS) {\n\t\tif (feed->ts_type & TS_DECODER) {\n\t\t\tif (feed->pes_type >= DMX_PES_OTHER ||\n\t\t\t    !demux->pesfilter[feed->pes_type])\n\t\t\t\treturn -EINVAL;\n\t\t\tdemux->pids[feed->pes_type] |= 0x8000;\n\t\t\tdemux->pesfilter[feed->pes_type] = NULL;\n\t\t}\n\t\tif (feed->ts_type & TS_DECODER &&\n\t\t    feed->pes_type < DMX_PES_OTHER) {\n\t\t\tret = dvb_feed_stop_pid(feed);\n\t\t} else\n\t\t\tif ((feed->ts_type & TS_PACKET) &&\n\t\t\t    (demux->dmx.frontend->source != DMX_MEMORY_FE))\n\t\t\t\tret = StopHWFilter(feed->filter);\n\t}\n\n\tif (av7110->full_ts) {\n\t\tbudget_stop_feed(feed);\n\t\treturn ret;\n\t}\n\n\tif (feed->type == DMX_TYPE_SEC) {\n\t\tfor (i = 0; i<demux->filternum; i++) {\n\t\t\tif (demux->filter[i].state == DMX_STATE_GO &&\n\t\t\t    demux->filter[i].filter.parent == &feed->feed.sec) {\n\t\t\t\tdemux->filter[i].state = DMX_STATE_READY;\n\t\t\t\tif (demux->dmx.frontend->source != DMX_MEMORY_FE) {\n\t\t\t\t\trc = StopHWFilter(&demux->filter[i]);\n\t\t\t\t\tif (!ret)\n\t\t\t\t\t\tret = rc;\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nstatic void restart_feeds(struct av7110 *av7110)\n{\n\tstruct dvb_demux *dvbdmx = &av7110->demux;\n\tstruct dvb_demux_feed *feed;\n\tint mode;\n\tint feeding;\n\tint i, j;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tmode = av7110->playing;\n\tav7110->playing = 0;\n\tav7110->rec_mode = 0;\n\n\tfeeding = av7110->feeding1;  \n\n\tfor (i = 0; i < dvbdmx->feednum; i++) {\n\t\tfeed = &dvbdmx->feed[i];\n\t\tif (feed->state == DMX_STATE_GO) {\n\t\t\tif (feed->type == DMX_TYPE_SEC) {\n\t\t\t\tfor (j = 0; j < dvbdmx->filternum; j++) {\n\t\t\t\t\tif (dvbdmx->filter[j].type != DMX_TYPE_SEC)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dvbdmx->filter[j].filter.parent != &feed->feed.sec)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dvbdmx->filter[j].state == DMX_STATE_GO)\n\t\t\t\t\t\tdvbdmx->filter[j].state = DMX_STATE_READY;\n\t\t\t\t}\n\t\t\t}\n\t\t\tav7110_start_feed(feed);\n\t\t}\n\t}\n\n\tav7110->feeding1 = feeding;  \n\n\tif (mode)\n\t\tav7110_av_start_play(av7110, mode);\n}\n\nstatic int dvb_get_stc(struct dmx_demux *demux, unsigned int num,\n\t\t       uint64_t *stc, unsigned int *base)\n{\n\tint ret;\n\tu16 fwstc[4];\n\tu16 tag = ((COMTYPE_REQUEST << 8) + ReqSTC);\n\tstruct dvb_demux *dvbdemux;\n\tstruct av7110 *av7110;\n\n\t \n\tif (WARN_ON(!demux))\n\t\treturn -EIO;\n\tdvbdemux = demux->priv;\n\tif (WARN_ON(!dvbdemux))\n\t\treturn -EIO;\n\tav7110 = dvbdemux->priv;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (num != 0)\n\t\treturn -EINVAL;\n\n\tret = av7110_fw_request(av7110, &tag, 0, fwstc, 4);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: av7110_fw_request error\\n\", __func__);\n\t\treturn ret;\n\t}\n\tdprintk(2, \"fwstc = %04hx %04hx %04hx %04hx\\n\",\n\t\tfwstc[0], fwstc[1], fwstc[2], fwstc[3]);\n\n\t*stc =\t(((uint64_t) ((fwstc[3] & 0x8000) >> 15)) << 32) |\n\t\t(((uint64_t)  fwstc[1]) << 16) | ((uint64_t) fwstc[0]);\n\t*base = 1;\n\n\tdprintk(4, \"stc = %lu\\n\", (unsigned long)*stc);\n\n\treturn 0;\n}\n\n\n \n\n\nstatic int av7110_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\n{\n\tstruct av7110* av7110 = fe->dvb->priv;\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\treturn Set22K(av7110, 1);\n\n\tcase SEC_TONE_OFF:\n\t\treturn Set22K(av7110, 0);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int av7110_diseqc_send_master_cmd(struct dvb_frontend* fe,\n\t\t\t\t\t struct dvb_diseqc_master_cmd* cmd)\n{\n\tstruct av7110* av7110 = fe->dvb->priv;\n\n\treturn av7110_diseqc_send(av7110, cmd->msg_len, cmd->msg, -1);\n}\n\nstatic int av7110_diseqc_send_burst(struct dvb_frontend* fe,\n\t\t\t\t    enum fe_sec_mini_cmd minicmd)\n{\n\tstruct av7110* av7110 = fe->dvb->priv;\n\n\treturn av7110_diseqc_send(av7110, 0, NULL, minicmd);\n}\n\n \nstatic int stop_ts_capture(struct av7110 *budget)\n{\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tif (--budget->feeding1)\n\t\treturn budget->feeding1;\n\tsaa7146_write(budget->dev, MC1, MASK_20);\t \n\tSAA7146_IER_DISABLE(budget->dev, MASK_10);\n\tSAA7146_ISR_CLEAR(budget->dev, MASK_10);\n\treturn 0;\n}\n\nstatic int start_ts_capture(struct av7110 *budget)\n{\n\tunsigned y;\n\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tif (budget->feeding1)\n\t\treturn ++budget->feeding1;\n\tfor (y = 0; y < TS_HEIGHT; y++)\n\t\tmemset(budget->grabbing + y * TS_WIDTH, 0x00, TS_WIDTH);\n\tbudget->ttbp = 0;\n\tSAA7146_ISR_CLEAR(budget->dev, MASK_10);   \n\tSAA7146_IER_ENABLE(budget->dev, MASK_10);  \n\tsaa7146_write(budget->dev, MC1, (MASK_04 | MASK_20));  \n\treturn ++budget->feeding1;\n}\n\nstatic int budget_start_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct av7110 *budget = demux->priv;\n\tint status;\n\n\tdprintk(2, \"av7110: %p\\n\", budget);\n\n\tspin_lock(&budget->feedlock1);\n\tfeed->pusi_seen = false;  \n\tstatus = start_ts_capture(budget);\n\tspin_unlock(&budget->feedlock1);\n\treturn status;\n}\n\nstatic int budget_stop_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct av7110 *budget = demux->priv;\n\tint status;\n\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tspin_lock(&budget->feedlock1);\n\tstatus = stop_ts_capture(budget);\n\tspin_unlock(&budget->feedlock1);\n\treturn status;\n}\n\nstatic void vpeirq(struct tasklet_struct *t)\n{\n\tstruct av7110 *budget = from_tasklet(budget, t, vpe_tasklet);\n\tu8 *mem = (u8 *) (budget->grabbing);\n\tu32 olddma = budget->ttbp;\n\tu32 newdma = saa7146_read(budget->dev, PCI_VDP3);\n\tstruct dvb_demux *demux = budget->full_ts ? &budget->demux : &budget->demux1;\n\n\t \n\tnewdma -= newdma % 188;\n\n\tif (newdma >= TS_BUFLEN)\n\t\treturn;\n\n\tbudget->ttbp = newdma;\n\n\tif (!budget->feeding1 || (newdma == olddma))\n\t\treturn;\n\n\t \n\tdma_sync_sg_for_cpu(&budget->dev->pci->dev, budget->pt.slist,\n\t\t\t    budget->pt.nents, DMA_FROM_DEVICE);\n\n#if 0\n\t \n\tprintk(\"vpeirq: %02x Event Counter 1 0x%04x\\n\",\n\t       mem[olddma],\n\t       saa7146_read(budget->dev, EC1R) & 0x3fff);\n#endif\n\n\tif (newdma > olddma)\n\t\t \n\t\tdvb_dmx_swfilter_packets(demux, mem + olddma, (newdma - olddma) / 188);\n\telse {\n\t\t \n\t\tdvb_dmx_swfilter_packets(demux, mem + olddma, (TS_BUFLEN - olddma) / 188);\n\t\tdvb_dmx_swfilter_packets(demux, mem, newdma / 188);\n\t}\n}\n\nstatic int av7110_register(struct av7110 *av7110)\n{\n\tint ret, i;\n\tstruct dvb_demux *dvbdemux = &av7110->demux;\n\tstruct dvb_demux *dvbdemux1 = &av7110->demux1;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (av7110->registered)\n\t\treturn -1;\n\n\tav7110->registered = 1;\n\n\tdvbdemux->priv = (void *) av7110;\n\n\tfor (i = 0; i < 32; i++)\n\t\tav7110->handle2filter[i] = NULL;\n\n\tdvbdemux->filternum = (av7110->full_ts) ? 256 : 32;\n\tdvbdemux->feednum = (av7110->full_ts) ? 256 : 32;\n\tdvbdemux->start_feed = av7110_start_feed;\n\tdvbdemux->stop_feed = av7110_stop_feed;\n\tdvbdemux->write_to_decoder = av7110_write_to_decoder;\n\tdvbdemux->dmx.capabilities = (DMX_TS_FILTERING | DMX_SECTION_FILTERING |\n\t\t\t\t      DMX_MEMORY_BASED_FILTERING);\n\n\tdvb_dmx_init(&av7110->demux);\n\tav7110->demux.dmx.get_stc = dvb_get_stc;\n\n\tav7110->dmxdev.filternum = (av7110->full_ts) ? 256 : 32;\n\tav7110->dmxdev.demux = &dvbdemux->dmx;\n\tav7110->dmxdev.capabilities = 0;\n\n\tdvb_dmxdev_init(&av7110->dmxdev, &av7110->dvb_adapter);\n\n\tav7110->hw_frontend.source = DMX_FRONTEND_0;\n\n\tret = dvbdemux->dmx.add_frontend(&dvbdemux->dmx, &av7110->hw_frontend);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tav7110->mem_frontend.source = DMX_MEMORY_FE;\n\n\tret = dvbdemux->dmx.add_frontend(&dvbdemux->dmx, &av7110->mem_frontend);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dvbdemux->dmx.connect_frontend(&dvbdemux->dmx,\n\t\t\t\t\t     &av7110->hw_frontend);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tav7110_av_register(av7110);\n\tav7110_ca_register(av7110);\n\n#ifdef CONFIG_DVB_AV7110_OSD\n\tdvb_register_device(&av7110->dvb_adapter, &av7110->osd_dev,\n\t\t\t    &dvbdev_osd, av7110, DVB_DEVICE_OSD, 0);\n#endif\n\n\tdvb_net_init(&av7110->dvb_adapter, &av7110->dvb_net, &dvbdemux->dmx);\n\n\tif (budgetpatch) {\n\t\t \n\t\tdvbdemux1->priv = (void *) av7110;\n\n\t\tdvbdemux1->filternum = 256;\n\t\tdvbdemux1->feednum = 256;\n\t\tdvbdemux1->start_feed = budget_start_feed;\n\t\tdvbdemux1->stop_feed = budget_stop_feed;\n\t\tdvbdemux1->write_to_decoder = NULL;\n\n\t\tdvbdemux1->dmx.capabilities = (DMX_TS_FILTERING | DMX_SECTION_FILTERING |\n\t\t\t\t\t       DMX_MEMORY_BASED_FILTERING);\n\n\t\tdvb_dmx_init(&av7110->demux1);\n\n\t\tav7110->dmxdev1.filternum = 256;\n\t\tav7110->dmxdev1.demux = &dvbdemux1->dmx;\n\t\tav7110->dmxdev1.capabilities = 0;\n\n\t\tdvb_dmxdev_init(&av7110->dmxdev1, &av7110->dvb_adapter);\n\n\t\tdvb_net_init(&av7110->dvb_adapter, &av7110->dvb_net1, &dvbdemux1->dmx);\n\t\tprintk(\"dvb-ttpci: additional demux1 for budget-patch registered\\n\");\n\t}\n\treturn 0;\n}\n\n\nstatic void dvb_unregister(struct av7110 *av7110)\n{\n\tstruct dvb_demux *dvbdemux = &av7110->demux;\n\tstruct dvb_demux *dvbdemux1 = &av7110->demux1;\n\n\tdprintk(4, \"%p\\n\", av7110);\n\n\tif (!av7110->registered)\n\t\treturn;\n\n\tif (budgetpatch) {\n\t\tdvb_net_release(&av7110->dvb_net1);\n\t\tdvbdemux->dmx.close(&dvbdemux1->dmx);\n\t\tdvb_dmxdev_release(&av7110->dmxdev1);\n\t\tdvb_dmx_release(&av7110->demux1);\n\t}\n\n\tdvb_net_release(&av7110->dvb_net);\n\n\tdvbdemux->dmx.close(&dvbdemux->dmx);\n\tdvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &av7110->hw_frontend);\n\tdvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &av7110->mem_frontend);\n\n\tdvb_dmxdev_release(&av7110->dmxdev);\n\tdvb_dmx_release(&av7110->demux);\n\n\tif (av7110->fe != NULL) {\n\t\tdvb_unregister_frontend(av7110->fe);\n\t\tdvb_frontend_detach(av7110->fe);\n\t}\n\tdvb_unregister_device(av7110->osd_dev);\n\tav7110_av_unregister(av7110);\n\tav7110_ca_unregister(av7110);\n}\n\n\n \n\nint i2c_writereg(struct av7110 *av7110, u8 id, u8 reg, u8 val)\n{\n\tu8 msg[2] = { reg, val };\n\tstruct i2c_msg msgs;\n\n\tmsgs.flags = 0;\n\tmsgs.addr = id / 2;\n\tmsgs.len = 2;\n\tmsgs.buf = msg;\n\treturn i2c_transfer(&av7110->i2c_adap, &msgs, 1);\n}\n\nu8 i2c_readreg(struct av7110 *av7110, u8 id, u8 reg)\n{\n\tu8 mm1[] = {0x00};\n\tu8 mm2[] = {0x00};\n\tstruct i2c_msg msgs[2];\n\n\tmsgs[0].flags = 0;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[0].addr = msgs[1].addr = id / 2;\n\tmm1[0] = reg;\n\tmsgs[0].len = 1; msgs[1].len = 1;\n\tmsgs[0].buf = mm1; msgs[1].buf = mm2;\n\ti2c_transfer(&av7110->i2c_adap, msgs, 2);\n\n\treturn mm2[0];\n}\n\n \n\n\nstatic int check_firmware(struct av7110* av7110)\n{\n\tu32 crc = 0, len = 0;\n\tunsigned char *ptr;\n\n\t \n\tptr = av7110->bin_fw;\n\tif (ptr[0] != 'A' || ptr[1] != 'V' ||\n\t    ptr[2] != 'F' || ptr[3] != 'W') {\n\t\tprintk(\"dvb-ttpci: this is not an av7110 firmware\\n\");\n\t\treturn -EINVAL;\n\t}\n\tptr += 4;\n\n\t \n\tcrc = get_unaligned_be32(ptr);\n\tptr += 4;\n\tlen = get_unaligned_be32(ptr);\n\tptr += 4;\n\tif (len >= 512) {\n\t\tprintk(\"dvb-ttpci: dpram file is way too big.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (crc != crc32_le(0, ptr, len)) {\n\t\tprintk(\"dvb-ttpci: crc32 of dpram file does not match.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tav7110->bin_dpram = ptr;\n\tav7110->size_dpram = len;\n\tptr += len;\n\n\t \n\tcrc = get_unaligned_be32(ptr);\n\tptr += 4;\n\tlen = get_unaligned_be32(ptr);\n\tptr += 4;\n\n\tif (len <= 200000 || len >= 300000 ||\n\t    len > ((av7110->bin_fw + av7110->size_fw) - ptr)) {\n\t\tprintk(\"dvb-ttpci: root file has strange size (%d). aborting.\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\tif( crc != crc32_le(0, ptr, len)) {\n\t\tprintk(\"dvb-ttpci: crc32 of root file does not match.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tav7110->bin_root = ptr;\n\tav7110->size_root = len;\n\treturn 0;\n}\n\nstatic void put_firmware(struct av7110* av7110)\n{\n\tvfree(av7110->bin_fw);\n}\n\nstatic int get_firmware(struct av7110* av7110)\n{\n\tint ret;\n\tconst struct firmware *fw;\n\n\t \n\tret = request_firmware(&fw, \"dvb-ttpci-01.fw\", &av7110->dev->pci->dev);\n\tif (ret) {\n\t\tif (ret == -ENOENT) {\n\t\t\tprintk(KERN_ERR \"dvb-ttpci: could not load firmware, file not found: dvb-ttpci-01.fw\\n\");\n\t\t\tprintk(KERN_ERR \"dvb-ttpci: usually this should be in /usr/lib/hotplug/firmware or /lib/firmware\\n\");\n\t\t\tprintk(KERN_ERR \"dvb-ttpci: and can be downloaded from https://linuxtv.org/download/dvb/firmware/\\n\");\n\t\t} else\n\t\t\tprintk(KERN_ERR \"dvb-ttpci: cannot request firmware (error %i)\\n\",\n\t\t\t       ret);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fw->size <= 200000) {\n\t\tprintk(\"dvb-ttpci: this firmware is way too small.\\n\");\n\t\trelease_firmware(fw);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tav7110->bin_fw = vmalloc(fw->size);\n\tif (NULL == av7110->bin_fw) {\n\t\tdprintk(1, \"out of memory\\n\");\n\t\trelease_firmware(fw);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(av7110->bin_fw, fw->data, fw->size);\n\tav7110->size_fw = fw->size;\n\tif ((ret = check_firmware(av7110)))\n\t\tvfree(av7110->bin_fw);\n\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic int alps_bsrv2_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct av7110* av7110 = fe->dvb->priv;\n\tu8 pwr = 0;\n\tu8 buf[4];\n\tstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = buf, .len = sizeof(buf) };\n\tu32 div = (p->frequency + 479500) / 125;\n\n\tif (p->frequency > 2000000)\n\t\tpwr = 3;\n\telse if (p->frequency > 1800000)\n\t\tpwr = 2;\n\telse if (p->frequency > 1600000)\n\t\tpwr = 1;\n\telse if (p->frequency > 1200000)\n\t\tpwr = 0;\n\telse if (p->frequency >= 1100000)\n\t\tpwr = 1;\n\telse\n\t\tpwr = 2;\n\n\tbuf[0] = (div >> 8) & 0x7f;\n\tbuf[1] = div & 0xff;\n\tbuf[2] = ((div & 0x18000) >> 10) | 0x95;\n\tbuf[3] = (pwr << 6) | 0x30;\n\n\t \n\t\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer (&av7110->i2c_adap, &msg, 1) != 1)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic struct ves1x93_config alps_bsrv2_config = {\n\t.demod_address = 0x08,\n\t.xin = 90100000UL,\n\t.invert_pwm = 0,\n};\n\nstatic int alps_tdbe2_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct av7110* av7110 = fe->dvb->priv;\n\tu32 div;\n\tu8 data[4];\n\tstruct i2c_msg msg = { .addr = 0x62, .flags = 0, .buf = data, .len = sizeof(data) };\n\n\tdiv = (p->frequency + 35937500 + 31250) / 62500;\n\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = 0x85 | ((div >> 10) & 0x60);\n\tdata[3] = (p->frequency < 174000000 ? 0x88 : p->frequency < 470000000 ? 0x84 : 0x81);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&av7110->i2c_adap, &msg, 1) != 1)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic struct ves1820_config alps_tdbe2_config = {\n\t.demod_address = 0x09,\n\t.xin = 57840000UL,\n\t.invert = 1,\n\t.selagc = VES1820_SELAGC_SIGNAMPERR,\n};\n\n\n\n\nstatic int grundig_29504_451_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct av7110* av7110 = fe->dvb->priv;\n\tu32 div;\n\tu8 data[4];\n\tstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = sizeof(data) };\n\n\tdiv = p->frequency / 125;\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = 0x8e;\n\tdata[3] = 0x00;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&av7110->i2c_adap, &msg, 1) != 1)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic struct tda8083_config grundig_29504_451_config = {\n\t.demod_address = 0x68,\n};\n\n\n\nstatic int philips_cd1516_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct av7110* av7110 = fe->dvb->priv;\n\tu32 div;\n\tu32 f = p->frequency;\n\tu8 data[4];\n\tstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = sizeof(data) };\n\n\tdiv = (f + 36125000 + 31250) / 62500;\n\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = 0x8e;\n\tdata[3] = (f < 174000000 ? 0xa1 : f < 470000000 ? 0x92 : 0x34);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&av7110->i2c_adap, &msg, 1) != 1)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic struct ves1820_config philips_cd1516_config = {\n\t.demod_address = 0x09,\n\t.xin = 57840000UL,\n\t.invert = 1,\n\t.selagc = VES1820_SELAGC_SIGNAMPERR,\n};\n\n\n\nstatic int alps_tdlb7_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct av7110* av7110 = fe->dvb->priv;\n\tu32 div, pwr;\n\tu8 data[4];\n\tstruct i2c_msg msg = { .addr = 0x60, .flags = 0, .buf = data, .len = sizeof(data) };\n\n\tdiv = (p->frequency + 36200000) / 166666;\n\n\tif (p->frequency <= 782000000)\n\t\tpwr = 1;\n\telse\n\t\tpwr = 2;\n\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = 0x85;\n\tdata[3] = pwr << 6;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&av7110->i2c_adap, &msg, 1) != 1)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int alps_tdlb7_request_firmware(struct dvb_frontend* fe, const struct firmware **fw, char* name)\n{\n#if IS_ENABLED(CONFIG_DVB_SP8870)\n\tstruct av7110* av7110 = fe->dvb->priv;\n\n\treturn request_firmware(fw, name, &av7110->dev->pci->dev);\n#else\n\treturn -EINVAL;\n#endif\n}\n\nstatic const struct sp8870_config alps_tdlb7_config = {\n\n\t.demod_address = 0x71,\n\t.request_firmware = alps_tdlb7_request_firmware,\n};\n\n\nstatic u8 nexusca_stv0297_inittab[] = {\n\t0x80, 0x01,\n\t0x80, 0x00,\n\t0x81, 0x01,\n\t0x81, 0x00,\n\t0x00, 0x09,\n\t0x01, 0x69,\n\t0x03, 0x00,\n\t0x04, 0x00,\n\t0x07, 0x00,\n\t0x08, 0x00,\n\t0x20, 0x00,\n\t0x21, 0x40,\n\t0x22, 0x00,\n\t0x23, 0x00,\n\t0x24, 0x40,\n\t0x25, 0x88,\n\t0x30, 0xff,\n\t0x31, 0x00,\n\t0x32, 0xff,\n\t0x33, 0x00,\n\t0x34, 0x50,\n\t0x35, 0x7f,\n\t0x36, 0x00,\n\t0x37, 0x20,\n\t0x38, 0x00,\n\t0x40, 0x1c,\n\t0x41, 0xff,\n\t0x42, 0x29,\n\t0x43, 0x00,\n\t0x44, 0xff,\n\t0x45, 0x00,\n\t0x46, 0x00,\n\t0x49, 0x04,\n\t0x4a, 0x00,\n\t0x4b, 0x7b,\n\t0x52, 0x30,\n\t0x55, 0xae,\n\t0x56, 0x47,\n\t0x57, 0xe1,\n\t0x58, 0x3a,\n\t0x5a, 0x1e,\n\t0x5b, 0x34,\n\t0x60, 0x00,\n\t0x63, 0x00,\n\t0x64, 0x00,\n\t0x65, 0x00,\n\t0x66, 0x00,\n\t0x67, 0x00,\n\t0x68, 0x00,\n\t0x69, 0x00,\n\t0x6a, 0x02,\n\t0x6b, 0x00,\n\t0x70, 0xff,\n\t0x71, 0x00,\n\t0x72, 0x00,\n\t0x73, 0x00,\n\t0x74, 0x0c,\n\t0x80, 0x00,\n\t0x81, 0x00,\n\t0x82, 0x00,\n\t0x83, 0x00,\n\t0x84, 0x04,\n\t0x85, 0x80,\n\t0x86, 0x24,\n\t0x87, 0x78,\n\t0x88, 0x10,\n\t0x89, 0x00,\n\t0x90, 0x01,\n\t0x91, 0x01,\n\t0xa0, 0x04,\n\t0xa1, 0x00,\n\t0xa2, 0x00,\n\t0xb0, 0x91,\n\t0xb1, 0x0b,\n\t0xc0, 0x53,\n\t0xc1, 0x70,\n\t0xc2, 0x12,\n\t0xd0, 0x00,\n\t0xd1, 0x00,\n\t0xd2, 0x00,\n\t0xd3, 0x00,\n\t0xd4, 0x00,\n\t0xd5, 0x00,\n\t0xde, 0x00,\n\t0xdf, 0x00,\n\t0x61, 0x49,\n\t0x62, 0x0b,\n\t0x53, 0x08,\n\t0x59, 0x08,\n\t0xff, 0xff,\n};\n\nstatic int nexusca_stv0297_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct av7110* av7110 = fe->dvb->priv;\n\tu32 div;\n\tu8 data[4];\n\tstruct i2c_msg msg = { .addr = 0x63, .flags = 0, .buf = data, .len = sizeof(data) };\n\tstruct i2c_msg readmsg = { .addr = 0x63, .flags = I2C_M_RD, .buf = data, .len = 1 };\n\tint i;\n\n\tdiv = (p->frequency + 36150000 + 31250) / 62500;\n\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = 0xce;\n\n\tif (p->frequency < 45000000)\n\t\treturn -EINVAL;\n\telse if (p->frequency < 137000000)\n\t\tdata[3] = 0x01;\n\telse if (p->frequency < 403000000)\n\t\tdata[3] = 0x02;\n\telse if (p->frequency < 860000000)\n\t\tdata[3] = 0x04;\n\telse\n\t\treturn -EINVAL;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&av7110->i2c_adap, &msg, 1) != 1) {\n\t\tprintk(\"nexusca: pll transfer failed!\\n\");\n\t\treturn -EIO;\n\t}\n\n\t\n\tfor(i = 0; i < 20; i++) {\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\tif (i2c_transfer(&av7110->i2c_adap, &readmsg, 1) == 1)\n\t\t\tif (data[0] & 0x40) break;\n\t\tmsleep(10);\n\t}\n\n\treturn 0;\n}\n\nstatic struct stv0297_config nexusca_stv0297_config = {\n\n\t.demod_address = 0x1C,\n\t.inittab = nexusca_stv0297_inittab,\n\t.invert = 1,\n\t.stop_during_read = 1,\n};\n\n\n\nstatic int grundig_29504_401_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct av7110* av7110 = fe->dvb->priv;\n\tu32 div;\n\tu8 cfg, cpump, band_select;\n\tu8 data[4];\n\tstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = sizeof(data) };\n\n\tdiv = (36125000 + p->frequency) / 166666;\n\n\tcfg = 0x88;\n\n\tif (p->frequency < 175000000)\n\t\tcpump = 2;\n\telse if (p->frequency < 390000000)\n\t\tcpump = 1;\n\telse if (p->frequency < 470000000)\n\t\tcpump = 2;\n\telse if (p->frequency < 750000000)\n\t\tcpump = 1;\n\telse\n\t\tcpump = 3;\n\n\tif (p->frequency < 175000000)\n\t\tband_select = 0x0e;\n\telse if (p->frequency < 470000000)\n\t\tband_select = 0x05;\n\telse\n\t\tband_select = 0x03;\n\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = ((div >> 10) & 0x60) | cfg;\n\tdata[3] = (cpump << 6) | band_select;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer (&av7110->i2c_adap, &msg, 1) != 1) return -EIO;\n\treturn 0;\n}\n\nstatic struct l64781_config grundig_29504_401_config = {\n\t.demod_address = 0x55,\n};\n\n\n\nstatic int av7110_fe_lock_fix(struct av7110 *av7110, enum fe_status status)\n{\n\tint ret = 0;\n\tint synced = (status & FE_HAS_LOCK) ? 1 : 0;\n\n\tav7110->fe_status = status;\n\n\tif (av7110->fe_synced == synced)\n\t\treturn 0;\n\n\tif (av7110->playing) {\n\t\tav7110->fe_synced = synced;\n\t\treturn 0;\n\t}\n\n\tif (mutex_lock_interruptible(&av7110->pid_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (synced) {\n\t\tret = SetPIDs(av7110, av7110->pids[DMX_PES_VIDEO],\n\t\t\tav7110->pids[DMX_PES_AUDIO],\n\t\t\tav7110->pids[DMX_PES_TELETEXT], 0,\n\t\t\tav7110->pids[DMX_PES_PCR]);\n\t\tif (!ret)\n\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_PIDFILTER, Scan, 0);\n\t} else {\n\t\tret = SetPIDs(av7110, 0, 0, 0, 0, 0);\n\t\tif (!ret) {\n\t\t\tret = av7110_fw_cmd(av7110, COMTYPE_PID_FILTER, FlushTSQueue, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = av7110_wait_msgstate(av7110, GPMQBusy);\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tav7110->fe_synced = synced;\n\n\tmutex_unlock(&av7110->pid_mutex);\n\treturn ret;\n}\n\nstatic int av7110_fe_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct av7110* av7110 = fe->dvb->priv;\n\n\tint ret = av7110_fe_lock_fix(av7110, 0);\n\tif (!ret)\n\t\tret = av7110->fe_set_frontend(fe);\n\n\treturn ret;\n}\n\nstatic int av7110_fe_init(struct dvb_frontend* fe)\n{\n\tstruct av7110* av7110 = fe->dvb->priv;\n\n\tint ret = av7110_fe_lock_fix(av7110, 0);\n\tif (!ret)\n\t\tret = av7110->fe_init(fe);\n\treturn ret;\n}\n\nstatic int av7110_fe_read_status(struct dvb_frontend *fe,\n\t\t\t\t enum fe_status *status)\n{\n\tstruct av7110* av7110 = fe->dvb->priv;\n\n\t \n\tint ret = av7110->fe_read_status(fe, status);\n\tif (!ret)\n\t\tif (((*status ^ av7110->fe_status) & FE_HAS_LOCK) && (*status & FE_HAS_LOCK))\n\t\t\tret = av7110_fe_lock_fix(av7110, *status);\n\treturn ret;\n}\n\nstatic int av7110_fe_diseqc_reset_overload(struct dvb_frontend* fe)\n{\n\tstruct av7110* av7110 = fe->dvb->priv;\n\n\tint ret = av7110_fe_lock_fix(av7110, 0);\n\tif (!ret)\n\t\tret = av7110->fe_diseqc_reset_overload(fe);\n\treturn ret;\n}\n\nstatic int av7110_fe_diseqc_send_master_cmd(struct dvb_frontend* fe,\n\t\t\t\t\t    struct dvb_diseqc_master_cmd* cmd)\n{\n\tstruct av7110* av7110 = fe->dvb->priv;\n\n\tint ret = av7110_fe_lock_fix(av7110, 0);\n\tif (!ret) {\n\t\tav7110->saved_master_cmd = *cmd;\n\t\tret = av7110->fe_diseqc_send_master_cmd(fe, cmd);\n\t}\n\treturn ret;\n}\n\nstatic int av7110_fe_diseqc_send_burst(struct dvb_frontend *fe,\n\t\t\t\t       enum fe_sec_mini_cmd minicmd)\n{\n\tstruct av7110* av7110 = fe->dvb->priv;\n\n\tint ret = av7110_fe_lock_fix(av7110, 0);\n\tif (!ret) {\n\t\tav7110->saved_minicmd = minicmd;\n\t\tret = av7110->fe_diseqc_send_burst(fe, minicmd);\n\t}\n\treturn ret;\n}\n\nstatic int av7110_fe_set_tone(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_tone_mode tone)\n{\n\tstruct av7110* av7110 = fe->dvb->priv;\n\n\tint ret = av7110_fe_lock_fix(av7110, 0);\n\tif (!ret) {\n\t\tav7110->saved_tone = tone;\n\t\tret = av7110->fe_set_tone(fe, tone);\n\t}\n\treturn ret;\n}\n\nstatic int av7110_fe_set_voltage(struct dvb_frontend *fe,\n\t\t\t\t enum fe_sec_voltage voltage)\n{\n\tstruct av7110* av7110 = fe->dvb->priv;\n\n\tint ret = av7110_fe_lock_fix(av7110, 0);\n\tif (!ret) {\n\t\tav7110->saved_voltage = voltage;\n\t\tret = av7110->fe_set_voltage(fe, voltage);\n\t}\n\treturn ret;\n}\n\nstatic int av7110_fe_dishnetwork_send_legacy_command(struct dvb_frontend* fe, unsigned long cmd)\n{\n\tstruct av7110* av7110 = fe->dvb->priv;\n\n\tint ret = av7110_fe_lock_fix(av7110, 0);\n\tif (!ret)\n\t\tret = av7110->fe_dishnetwork_send_legacy_command(fe, cmd);\n\treturn ret;\n}\n\nstatic void dvb_s_recover(struct av7110* av7110)\n{\n\tav7110_fe_init(av7110->fe);\n\n\tav7110_fe_set_voltage(av7110->fe, av7110->saved_voltage);\n\tif (av7110->saved_master_cmd.msg_len) {\n\t\tmsleep(20);\n\t\tav7110_fe_diseqc_send_master_cmd(av7110->fe, &av7110->saved_master_cmd);\n\t}\n\tmsleep(20);\n\tav7110_fe_diseqc_send_burst(av7110->fe, av7110->saved_minicmd);\n\tmsleep(20);\n\tav7110_fe_set_tone(av7110->fe, av7110->saved_tone);\n\n\tav7110_fe_set_frontend(av7110->fe);\n}\n\nstatic u8 read_pwm(struct av7110* av7110)\n{\n\tu8 b = 0xff;\n\tu8 pwm;\n\tstruct i2c_msg msg[] = { { .addr = 0x50,.flags = 0,.buf = &b,.len = 1 },\n\t\t\t\t { .addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1} };\n\n\tif ((i2c_transfer(&av7110->i2c_adap, msg, 2) != 2) || (pwm == 0xff))\n\t\tpwm = 0x48;\n\n\treturn pwm;\n}\n\nstatic int frontend_init(struct av7110 *av7110)\n{\n\tint ret;\n\n\tif (av7110->dev->pci->subsystem_vendor == 0x110a) {\n\t\tswitch(av7110->dev->pci->subsystem_device) {\n\t\tcase 0x0000: \n\t\t\tav7110->fe = dvb_attach(ves1820_attach, &philips_cd1516_config,\n\t\t\t\t\t\t    &av7110->i2c_adap, read_pwm(av7110));\n\t\t\tif (av7110->fe) {\n\t\t\t\tav7110->fe->ops.tuner_ops.set_params = philips_cd1516_tuner_set_params;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t} else if (av7110->dev->pci->subsystem_vendor == 0x13c2) {\n\t\tswitch(av7110->dev->pci->subsystem_device) {\n\t\tcase 0x0000: \n\t\tcase 0x0003: \n\t\tcase 0x1002: \n\n\t\t\t\n\t\t\tav7110->fe = dvb_attach(ves1x93_attach, &alps_bsrv2_config, &av7110->i2c_adap);\n\t\t\tif (av7110->fe) {\n\t\t\t\tav7110->fe->ops.tuner_ops.set_params = alps_bsrv2_tuner_set_params;\n\t\t\t\tav7110->fe->ops.diseqc_send_master_cmd = av7110_diseqc_send_master_cmd;\n\t\t\t\tav7110->fe->ops.diseqc_send_burst = av7110_diseqc_send_burst;\n\t\t\t\tav7110->fe->ops.set_tone = av7110_set_tone;\n\t\t\t\tav7110->recover = dvb_s_recover;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t\n\t\t\tav7110->fe = dvb_attach(stv0299_attach, &alps_bsru6_config, &av7110->i2c_adap);\n\t\t\tif (av7110->fe) {\n\t\t\t\tav7110->fe->ops.tuner_ops.set_params = alps_bsru6_tuner_set_params;\n\t\t\t\tav7110->fe->tuner_priv = &av7110->i2c_adap;\n\n\t\t\t\tav7110->fe->ops.diseqc_send_master_cmd = av7110_diseqc_send_master_cmd;\n\t\t\t\tav7110->fe->ops.diseqc_send_burst = av7110_diseqc_send_burst;\n\t\t\t\tav7110->fe->ops.set_tone = av7110_set_tone;\n\t\t\t\tav7110->recover = dvb_s_recover;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t\n\t\t\tav7110->fe = dvb_attach(tda8083_attach, &grundig_29504_451_config, &av7110->i2c_adap);\n\t\t\tif (av7110->fe) {\n\t\t\t\tav7110->fe->ops.tuner_ops.set_params = grundig_29504_451_tuner_set_params;\n\t\t\t\tav7110->fe->ops.diseqc_send_master_cmd = av7110_diseqc_send_master_cmd;\n\t\t\t\tav7110->fe->ops.diseqc_send_burst = av7110_diseqc_send_burst;\n\t\t\t\tav7110->fe->ops.set_tone = av7110_set_tone;\n\t\t\t\tav7110->recover = dvb_s_recover;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tswitch(av7110->dev->pci->subsystem_device) {\n\t\t\tcase 0x0000:\n\t\t\t\t \n\t\t\t\tav7110->fe = dvb_attach(ves1820_attach, &philips_cd1516_config, &av7110->i2c_adap,\n\t\t\t\t\t\t\tread_pwm(av7110));\n\t\t\t\tif (av7110->fe) {\n\t\t\t\t\tav7110->fe->ops.tuner_ops.set_params = philips_cd1516_tuner_set_params;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x0003:\n\t\t\t\t \n\t\t\t\tav7110->fe = dvb_attach(ves1820_attach, &alps_tdbe2_config, &av7110->i2c_adap,\n\t\t\t\t\t\t\tread_pwm(av7110));\n\t\t\t\tif (av7110->fe) {\n\t\t\t\t\tav7110->fe->ops.tuner_ops.set_params = alps_tdbe2_tuner_set_params;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x0001: \n\t\t{\n\t\t\tstruct dvb_frontend *fe;\n\n\t\t\t\n\t\t\tfe = dvb_attach(sp8870_attach, &alps_tdlb7_config, &av7110->i2c_adap);\n\t\t\tif (fe) {\n\t\t\t\tfe->ops.tuner_ops.set_params = alps_tdlb7_tuner_set_params;\n\t\t\t\tav7110->fe = fe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\tfallthrough;\n\n\t\tcase 0x0008: \n\t\t\t\n\t\t\tav7110->fe = dvb_attach(l64781_attach, &grundig_29504_401_config, &av7110->i2c_adap);\n\t\t\tif (av7110->fe)\n\t\t\t\tav7110->fe->ops.tuner_ops.set_params = grundig_29504_401_tuner_set_params;\n\t\t\tbreak;\n\n\t\tcase 0x0002: \n\n\t\t\tav7110->fe = dvb_attach(ves1820_attach, &alps_tdbe2_config, &av7110->i2c_adap, read_pwm(av7110));\n\t\t\tif (av7110->fe) {\n\t\t\t\tav7110->fe->ops.tuner_ops.set_params = alps_tdbe2_tuner_set_params;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x0004: \n\t\t\t \n\t\t\tav7110->fe = dvb_attach(ves1x93_attach, &alps_bsrv2_config, &av7110->i2c_adap);\n\t\t\tif (av7110->fe) {\n\t\t\t\tav7110->fe->ops.tuner_ops.set_params = alps_bsrv2_tuner_set_params;\n\t\t\t\tav7110->fe->ops.diseqc_send_master_cmd = av7110_diseqc_send_master_cmd;\n\t\t\t\tav7110->fe->ops.diseqc_send_burst = av7110_diseqc_send_burst;\n\t\t\t\tav7110->fe->ops.set_tone = av7110_set_tone;\n\t\t\t\tav7110->recover = dvb_s_recover;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x0006:  \n\t\t\t \n\t\t\tav7110->fe = dvb_attach(tda8083_attach, &grundig_29504_451_config, &av7110->i2c_adap);\n\t\t\tif (av7110->fe) {\n\t\t\t\tav7110->fe->ops.tuner_ops.set_params = grundig_29504_451_tuner_set_params;\n\t\t\t\tav7110->fe->ops.diseqc_send_master_cmd = av7110_diseqc_send_master_cmd;\n\t\t\t\tav7110->fe->ops.diseqc_send_burst = av7110_diseqc_send_burst;\n\t\t\t\tav7110->fe->ops.set_tone = av7110_set_tone;\n\t\t\t\tav7110->recover = dvb_s_recover;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x000A: \n\n\t\t\tav7110->fe = dvb_attach(stv0297_attach, &nexusca_stv0297_config, &av7110->i2c_adap);\n\t\t\tif (av7110->fe) {\n\t\t\t\tav7110->fe->ops.tuner_ops.set_params = nexusca_stv0297_tuner_set_params;\n\n\t\t\t\t \n\t\t\t\tsaa7146_setgpio(av7110->dev, 1, SAA7146_GPIO_OUTLO); \n\t\t\t\tsaa7146_setgpio(av7110->dev, 3, SAA7146_GPIO_OUTLO); \n\n\t\t\t\t \n\t\t\t\tav7110->dev->i2c_bitrate = SAA7146_I2C_BUS_BIT_RATE_240;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x000E:  \n\t\t\t \n\t\t\tav7110->fe = dvb_attach(stv0299_attach, &alps_bsbe1_config, &av7110->i2c_adap);\n\t\t\tif (av7110->fe) {\n\t\t\t\tav7110->fe->ops.tuner_ops.set_params = alps_bsbe1_tuner_set_params;\n\t\t\t\tav7110->fe->tuner_priv = &av7110->i2c_adap;\n\n\t\t\t\tif (dvb_attach(lnbp21_attach, av7110->fe, &av7110->i2c_adap, 0, 0) == NULL) {\n\t\t\t\t\tprintk(\"dvb-ttpci: LNBP21 not found!\\n\");\n\t\t\t\t\tif (av7110->fe->ops.release)\n\t\t\t\t\t\tav7110->fe->ops.release(av7110->fe);\n\t\t\t\t\tav7110->fe = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tav7110->fe->ops.dishnetwork_send_legacy_command = NULL;\n\t\t\t\t\tav7110->recover = dvb_s_recover;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!av7110->fe) {\n\t\t \n\t\tret = -ENOMEM;\n\t\tprintk(\"dvb-ttpci: A frontend driver was not found for device [%04x:%04x] subsystem [%04x:%04x]\\n\",\n\t\t       av7110->dev->pci->vendor,\n\t\t       av7110->dev->pci->device,\n\t\t       av7110->dev->pci->subsystem_vendor,\n\t\t       av7110->dev->pci->subsystem_device);\n\t} else {\n\t\tFE_FUNC_OVERRIDE(av7110->fe->ops.init, av7110->fe_init, av7110_fe_init);\n\t\tFE_FUNC_OVERRIDE(av7110->fe->ops.read_status, av7110->fe_read_status, av7110_fe_read_status);\n\t\tFE_FUNC_OVERRIDE(av7110->fe->ops.diseqc_reset_overload, av7110->fe_diseqc_reset_overload, av7110_fe_diseqc_reset_overload);\n\t\tFE_FUNC_OVERRIDE(av7110->fe->ops.diseqc_send_master_cmd, av7110->fe_diseqc_send_master_cmd, av7110_fe_diseqc_send_master_cmd);\n\t\tFE_FUNC_OVERRIDE(av7110->fe->ops.diseqc_send_burst, av7110->fe_diseqc_send_burst, av7110_fe_diseqc_send_burst);\n\t\tFE_FUNC_OVERRIDE(av7110->fe->ops.set_tone, av7110->fe_set_tone, av7110_fe_set_tone);\n\t\tFE_FUNC_OVERRIDE(av7110->fe->ops.set_voltage, av7110->fe_set_voltage, av7110_fe_set_voltage);\n\t\tFE_FUNC_OVERRIDE(av7110->fe->ops.dishnetwork_send_legacy_command, av7110->fe_dishnetwork_send_legacy_command, av7110_fe_dishnetwork_send_legacy_command);\n\t\tFE_FUNC_OVERRIDE(av7110->fe->ops.set_frontend, av7110->fe_set_frontend, av7110_fe_set_frontend);\n\n\t\tret = dvb_register_frontend(&av7110->dvb_adapter, av7110->fe);\n\t\tif (ret < 0) {\n\t\t\tprintk(\"av7110: Frontend registration failed!\\n\");\n\t\t\tdvb_frontend_detach(av7110->fe);\n\t\t\tav7110->fe = NULL;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstatic int av7110_attach(struct saa7146_dev* dev,\n\t\t\t struct saa7146_pci_extension_data *pci_ext)\n{\n\tconst int length = TS_WIDTH * TS_HEIGHT;\n\tstruct pci_dev *pdev = dev->pci;\n\tstruct av7110 *av7110;\n\tstruct task_struct *thread;\n\tint ret, count = 0;\n\n\tdprintk(4, \"dev: %p\\n\", dev);\n\n\t \n#define RPS_IRQ 0\n\n\tif (budgetpatch == 1) {\n\t\tbudgetpatch = 0;\n\t\t \n\n\t\t \n\t\tsaa7146_write(dev, MC1, MASK_31);\n\t\t \n\n\t\t \n\t\tsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);\n\t\t \n\t\tsaa7146_write(dev, DD1_STREAM_B, 0);\n\t\t \n\t\tsaa7146_write(dev, DD1_INIT, 0x00000200);\n\t\tsaa7146_write(dev, BRS_CTRL, 0x00000000);   \n\t\tsaa7146_write(dev, MC2,\n\t\t\t      1 * (MASK_08 | MASK_24)  |    \n\t\t\t      0 * (MASK_09 | MASK_25)  |    \n\t\t\t      1 * (MASK_10 | MASK_26)  |    \n\t\t\t      0 * (MASK_06 | MASK_22)  |    \n\t\t\t      0 * (MASK_05 | MASK_21)  |    \n\t\t\t      0 * (MASK_01 | MASK_15)       \n\t\t);\n\n\t\t \n\t\tcount = 0;\n\t\t \n\t\tsaa7146_write(dev, MC1, MASK_29);\n\t\t \n\t\tsaa7146_write(dev, RPS_TOV1, 0);\n\t\tWRITE_RPS1(CMD_PAUSE | EVT_VBI_B);\n\t\tWRITE_RPS1(CMD_WR_REG_MASK | (GPIO_CTRL>>2));\n\t\tWRITE_RPS1(GPIO3_MSK);\n\t\tWRITE_RPS1(SAA7146_GPIO_OUTLO<<24);\n#if RPS_IRQ\n\t\t \n\t\tWRITE_RPS1(CMD_INTERRUPT);\n#endif\n\t\tWRITE_RPS1(CMD_STOP);\n\t\t \n\t\tWRITE_RPS1(CMD_JUMP);\n\t\tWRITE_RPS1(dev->d_rps1.dma_handle);\n\n#if RPS_IRQ\n\t\t \n\t\tsaa7146_write(dev, EC1SSR, (0x03<<2) | 3 );\n\t\t \n\t\tsaa7146_write(dev, ECT1R,  0x3fff );\n#endif\n\t\t \n\t\tsaa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);\n\t\t \n\t\tsaa7146_write(dev, MC1, (MASK_13 | MASK_29 ));\n\n\t\tmdelay(10);\n\t\t \n\t\tsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTHI);\n\t\tmdelay(10);\n\t\t \n\t\tif ((saa7146_read(dev, GPIO_CTRL) & 0x10000000) == 0) {\n\t\t\tbudgetpatch = 1;\n\t\t\tprintk(\"dvb-ttpci: BUDGET-PATCH DETECTED.\\n\");\n\t\t}\n\t\t \n\t\tsaa7146_write(dev, MC1, ( MASK_29 ));\n#if RPS_IRQ\n\t\tprintk(\"dvb-ttpci: Event Counter 1 0x%04x\\n\", saa7146_read(dev, EC1R) & 0x3fff );\n#endif\n\t}\n\n\t \n\tav7110 = kzalloc(sizeof(struct av7110), GFP_KERNEL);\n\tif (!av7110) {\n\t\tdprintk(1, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tav7110->card_name = (char*) pci_ext->ext_priv;\n\tav7110->dev = dev;\n\tdev->ext_priv = av7110;\n\n\tret = get_firmware(av7110);\n\tif (ret < 0)\n\t\tgoto err_kfree_0;\n\n\tret = dvb_register_adapter(&av7110->dvb_adapter, av7110->card_name,\n\t\t\t\t   THIS_MODULE, &dev->pci->dev, adapter_nr);\n\tif (ret < 0)\n\t\tgoto err_put_firmware_1;\n\n\t \n\tsaa7146_write(dev, GPIO_CTRL, 0x500000);\n\n\tstrscpy(av7110->i2c_adap.name, pci_ext->ext_priv,\n\t\tsizeof(av7110->i2c_adap.name));\n\n\tsaa7146_i2c_adapter_prepare(dev, &av7110->i2c_adap, SAA7146_I2C_BUS_BIT_RATE_120);  \n\n\tret = i2c_add_adapter(&av7110->i2c_adap);\n\tif (ret < 0)\n\t\tgoto err_dvb_unregister_adapter_2;\n\n\tttpci_eeprom_parse_mac(&av7110->i2c_adap,\n\t\t\t       av7110->dvb_adapter.proposed_mac);\n\tret = -ENOMEM;\n\n\t \n\tif (full_ts)\n\t\tav7110->full_ts = true;\n\n\t \n\tif (i2c_readreg(av7110, 0xaa, 0) == 0x4f && i2c_readreg(av7110, 0xaa, 1) == 0x45) {\n\t\tu8 flags = i2c_readreg(av7110, 0xaa, 2);\n\t\tif (flags != 0xff && (flags & 0x01))\n\t\t\tav7110->full_ts = true;\n\t}\n\n\tif (av7110->full_ts) {\n\t\tprintk(KERN_INFO \"dvb-ttpci: full-ts mode enabled for saa7146 port B\\n\");\n\t\tspin_lock_init(&av7110->feedlock1);\n\t\tav7110->grabbing = saa7146_vmalloc_build_pgtable(pdev, length,\n\t\t\t\t\t\t\t\t &av7110->pt);\n\t\tif (!av7110->grabbing)\n\t\t\tgoto err_i2c_del_3;\n\n\t\tsaa7146_write(dev, DD1_STREAM_B, 0x00000000);\n\t\tsaa7146_write(dev, MC2, (MASK_10 | MASK_26));\n\n\t\tsaa7146_write(dev, DD1_INIT, 0x00000600);\n\t\tsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\n\n\t\tsaa7146_write(dev, BRS_CTRL, 0x60000000);\n\t\tsaa7146_write(dev, MC2, MASK_08 | MASK_24);\n\n\t\t \n\t\tsaa7146_write(dev, PCI_BT_V1, 0x001c0000 | (saa7146_read(dev, PCI_BT_V1) & ~0x001f0000));\n\t\tsaa7146_write(dev, BASE_ODD3, 0);\n\t\tsaa7146_write(dev, BASE_EVEN3, 0);\n\t\tsaa7146_write(dev, PROT_ADDR3, TS_WIDTH * TS_HEIGHT);\n\t\tsaa7146_write(dev, PITCH3, TS_WIDTH);\n\t\tsaa7146_write(dev, BASE_PAGE3, av7110->pt.dma | ME1 | 0x90);\n\t\tsaa7146_write(dev, NUM_LINE_BYTE3, (TS_HEIGHT << 16) | TS_WIDTH);\n\t\tsaa7146_write(dev, MC2, MASK_04 | MASK_20);\n\n\t\ttasklet_setup(&av7110->vpe_tasklet, vpeirq);\n\n\t} else if (budgetpatch) {\n\t\tspin_lock_init(&av7110->feedlock1);\n\t\tav7110->grabbing = saa7146_vmalloc_build_pgtable(pdev, length,\n\t\t\t\t\t\t\t\t &av7110->pt);\n\t\tif (!av7110->grabbing)\n\t\t\tgoto err_i2c_del_3;\n\n\t\tsaa7146_write(dev, PCI_BT_V1, 0x1c1f101f);\n\t\tsaa7146_write(dev, BCS_CTRL, 0x80400040);\n\t\t \n\t\tsaa7146_write(dev, DD1_STREAM_B, 0x00000000);\n\t\tsaa7146_write(dev, DD1_INIT, 0x03000200);\n\t\tsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\n\t\tsaa7146_write(dev, BRS_CTRL, 0x60000000);\n\t\tsaa7146_write(dev, BASE_ODD3, 0);\n\t\tsaa7146_write(dev, BASE_EVEN3, 0);\n\t\tsaa7146_write(dev, PROT_ADDR3, TS_WIDTH * TS_HEIGHT);\n\t\tsaa7146_write(dev, BASE_PAGE3, av7110->pt.dma | ME1 | 0x90);\n\n\t\tsaa7146_write(dev, PITCH3, TS_WIDTH);\n\t\tsaa7146_write(dev, NUM_LINE_BYTE3, (TS_HEIGHT << 16) | TS_WIDTH);\n\n\t\t \n\t\tsaa7146_write(dev, MC2, 0x077c077c);\n\t\tsaa7146_write(dev, GPIO_CTRL, 0x000000);\n#if RPS_IRQ\n\t\t \n\t\tsaa7146_write(dev, EC1SSR, (0x03<<2) | 3 );\n\t\t \n\t\tsaa7146_write(dev, ECT1R,  0x3fff );\n#endif\n\t\t \n\t\tcount = 0;\n\n\t\t \n\t\tWRITE_RPS1(CMD_PAUSE | EVT_HS);\n\t\t \n\t\tWRITE_RPS1(CMD_WR_REG_MASK | (GPIO_CTRL>>2));\n\t\tWRITE_RPS1(GPIO3_MSK);\n\t\tWRITE_RPS1(SAA7146_GPIO_OUTHI<<24);\n#if RPS_IRQ\n\t\t \n\t\tWRITE_RPS1(CMD_INTERRUPT);\n#endif\n\t\t \n\t\tWRITE_RPS1(CMD_PAUSE | RPS_INV | EVT_HS);\n\t\t \n\t\tWRITE_RPS1(CMD_WR_REG_MASK | (GPIO_CTRL>>2));\n\t\tWRITE_RPS1(GPIO3_MSK);\n\t\tWRITE_RPS1(SAA7146_GPIO_OUTLO<<24);\n#if RPS_IRQ\n\t\t \n\t\tWRITE_RPS1(CMD_INTERRUPT);\n#endif\n\t\t \n\t\tWRITE_RPS1(CMD_JUMP);\n\t\tWRITE_RPS1(dev->d_rps1.dma_handle);\n\n\t\t \n\t\tsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);\n\t\t \n\t\tsaa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);\n\t\t \n\t\tsaa7146_write(dev, RPS_THRESH1, (TS_HEIGHT*1) | MASK_12 );\n\n\t\t \n\t\tsaa7146_write(dev, MC1, (MASK_13 | MASK_29));\n\n\t\t \n\t\ttasklet_setup(&av7110->vpe_tasklet,  vpeirq);\n\t} else {\n\t\tsaa7146_write(dev, PCI_BT_V1, 0x1c00101f);\n\t\tsaa7146_write(dev, BCS_CTRL, 0x80400040);\n\n\t\t \n\t\tsaa7146_write(dev, DD1_STREAM_B, 0x00000000);\n\t\tsaa7146_write(dev, DD1_INIT, 0x03000000);\n\t\tsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\n\n\t\t \n\t\tsaa7146_write(dev, MC2, 0x077c077c);\n\t\tsaa7146_write(dev, GPIO_CTRL, 0x000000);\n\t}\n\n\ttasklet_setup(&av7110->debi_tasklet, debiirq);\n\ttasklet_setup(&av7110->gpio_tasklet, gpioirq);\n\n\tmutex_init(&av7110->pid_mutex);\n\n\t \n\tspin_lock_init(&av7110->debilock);\n\tmutex_init(&av7110->dcomlock);\n\tav7110->debitype = -1;\n\n\t \n\tav7110->osdwin = 1;\n\tmutex_init(&av7110->osd_mutex);\n\n\t \n\tav7110->vidmode = tv_standard == 1 ? AV7110_VIDEO_MODE_NTSC\n\t\t\t\t\t   : AV7110_VIDEO_MODE_PAL;\n\n\t \n\tinit_waitqueue_head(&av7110->arm_wait);\n\tav7110->arm_thread = NULL;\n\n\t \n\tav7110->debi_virt = dma_alloc_coherent(&pdev->dev, 8192,\n\t\t\t\t\t       &av7110->debi_bus, GFP_KERNEL);\n\tif (!av7110->debi_virt)\n\t\tgoto err_saa71466_vfree_4;\n\n\n\tav7110->iobuf = vmalloc(AVOUTLEN+AOUTLEN+BMPLEN+4*IPACKS);\n\tif (!av7110->iobuf)\n\t\tgoto err_pci_free_5;\n\n\tret = av7110_av_init(av7110);\n\tif (ret < 0)\n\t\tgoto err_iobuf_vfree_6;\n\n\t \n\tav7110->bmpbuf = av7110->iobuf+AVOUTLEN+AOUTLEN;\n\tinit_waitqueue_head(&av7110->bmpq);\n\n\tret = av7110_ca_init(av7110);\n\tif (ret < 0)\n\t\tgoto err_av7110_av_exit_7;\n\n\t \n\tret = av7110_bootarm(av7110);\n\tif (ret < 0)\n\t\tgoto err_av7110_ca_exit_8;\n\n\tret = av7110_firmversion(av7110);\n\tif (ret < 0)\n\t\tgoto err_stop_arm_9;\n\n\tif (FW_VERSION(av7110->arm_app)<0x2501)\n\t\tprintk(KERN_WARNING\n\t\t       \"dvb-ttpci: Warning, firmware version 0x%04x is too old. System might be unstable!\\n\",\n\t\t       FW_VERSION(av7110->arm_app));\n\n\tthread = kthread_run(arm_thread, (void *) av7110, \"arm_mon\");\n\tif (IS_ERR(thread)) {\n\t\tret = PTR_ERR(thread);\n\t\tgoto err_stop_arm_9;\n\t}\n\tav7110->arm_thread = thread;\n\n\t \n\tav7110->mixer.volume_left  = volume;\n\tav7110->mixer.volume_right = volume;\n\n\tret = av7110_register(av7110);\n\tif (ret < 0)\n\t\tgoto err_arm_thread_stop_10;\n\n\tinit_av7110_av(av7110);\n\n\t \n\tret = av7110_init_v4l(av7110);\n\tif (ret < 0)\n\t\tgoto err_av7110_unregister_11;\n\n\tav7110->dvb_adapter.priv = av7110;\n\tret = frontend_init(av7110);\n\tif (ret < 0)\n\t\tgoto err_av7110_exit_v4l_12;\n\n\tmutex_init(&av7110->ioctl_mutex);\n\n#if IS_ENABLED(CONFIG_DVB_AV7110_IR)\n\tav7110_ir_init(av7110);\n#endif\n\tprintk(KERN_INFO \"dvb-ttpci: found av7110-%d.\\n\", av7110_num);\n\tav7110_num++;\nout:\n\treturn ret;\n\nerr_av7110_exit_v4l_12:\n\tav7110_exit_v4l(av7110);\nerr_av7110_unregister_11:\n\tdvb_unregister(av7110);\nerr_arm_thread_stop_10:\n\tav7110_arm_sync(av7110);\nerr_stop_arm_9:\n\t \nerr_av7110_ca_exit_8:\n\tav7110_ca_exit(av7110);\nerr_av7110_av_exit_7:\n\tav7110_av_exit(av7110);\nerr_iobuf_vfree_6:\n\tvfree(av7110->iobuf);\nerr_pci_free_5:\n\tdma_free_coherent(&pdev->dev, 8192, av7110->debi_virt,\n\t\t\t  av7110->debi_bus);\nerr_saa71466_vfree_4:\n\tif (av7110->grabbing)\n\t\tsaa7146_vfree_destroy_pgtable(pdev, av7110->grabbing, &av7110->pt);\nerr_i2c_del_3:\n\ti2c_del_adapter(&av7110->i2c_adap);\nerr_dvb_unregister_adapter_2:\n\tdvb_unregister_adapter(&av7110->dvb_adapter);\nerr_put_firmware_1:\n\tput_firmware(av7110);\nerr_kfree_0:\n\tkfree(av7110);\n\tgoto out;\n}\n\nstatic int av7110_detach(struct saa7146_dev* saa)\n{\n\tstruct av7110 *av7110 = saa->ext_priv;\n\tdprintk(4, \"%p\\n\", av7110);\n\n#if IS_ENABLED(CONFIG_DVB_AV7110_IR)\n\tav7110_ir_exit(av7110);\n#endif\n\tif (budgetpatch || av7110->full_ts) {\n\t\tif (budgetpatch) {\n\t\t\t \n\t\t\tsaa7146_write(saa, MC1, MASK_29);\n\t\t\t \n\t\t\tsaa7146_setgpio(saa, 3, SAA7146_GPIO_OUTLO);\n\t\t}\n\t\tsaa7146_write(saa, MC1, MASK_20);\t \n\t\tSAA7146_IER_DISABLE(saa, MASK_10);\n\t\tSAA7146_ISR_CLEAR(saa, MASK_10);\n\t\tmsleep(50);\n\t\ttasklet_kill(&av7110->vpe_tasklet);\n\t\tsaa7146_vfree_destroy_pgtable(saa->pci, av7110->grabbing, &av7110->pt);\n\t}\n\tav7110_exit_v4l(av7110);\n\n\tav7110_arm_sync(av7110);\n\n\ttasklet_kill(&av7110->debi_tasklet);\n\ttasklet_kill(&av7110->gpio_tasklet);\n\n\tdvb_unregister(av7110);\n\n\tSAA7146_IER_DISABLE(saa, MASK_19 | MASK_03);\n\tSAA7146_ISR_CLEAR(saa, MASK_19 | MASK_03);\n\n\tav7110_ca_exit(av7110);\n\tav7110_av_exit(av7110);\n\n\tvfree(av7110->iobuf);\n\tdma_free_coherent(&saa->pci->dev, 8192, av7110->debi_virt,\n\t\t\t  av7110->debi_bus);\n\n\ti2c_del_adapter(&av7110->i2c_adap);\n\n\tdvb_unregister_adapter (&av7110->dvb_adapter);\n\n\tav7110_num--;\n\n\tput_firmware(av7110);\n\n\tkfree(av7110);\n\n\tsaa->ext_priv = NULL;\n\n\treturn 0;\n}\n\n\nstatic void av7110_irq(struct saa7146_dev* dev, u32 *isr)\n{\n\tstruct av7110 *av7110 = dev->ext_priv;\n\n\t \n\n\t \n\n\tif (*isr & MASK_19) {\n\t\t\n\t\t \n\t\tSAA7146_IER_DISABLE(av7110->dev, MASK_19);\n\t\tSAA7146_ISR_CLEAR(av7110->dev, MASK_19);\n\t\ttasklet_schedule(&av7110->debi_tasklet);\n\t}\n\n\tif (*isr & MASK_03) {\n\t\t\n\t\ttasklet_schedule(&av7110->gpio_tasklet);\n\t}\n\n\tif (*isr & MASK_10)\n\t\ttasklet_schedule(&av7110->vpe_tasklet);\n}\n\n\nstatic struct saa7146_extension av7110_extension_driver;\n\n#define MAKE_AV7110_INFO(x_var,x_name) \\\nstatic struct saa7146_pci_extension_data x_var = { \\\n\t.ext_priv = x_name, \\\n\t.ext = &av7110_extension_driver }\n\nMAKE_AV7110_INFO(tts_1_X_fsc,\"Technotrend/Hauppauge WinTV DVB-S rev1.X or Fujitsu Siemens DVB-C\");\nMAKE_AV7110_INFO(ttt_1_X,    \"Technotrend/Hauppauge WinTV DVB-T rev1.X\");\nMAKE_AV7110_INFO(ttc_1_X,    \"Technotrend/Hauppauge WinTV Nexus-CA rev1.X\");\nMAKE_AV7110_INFO(ttc_2_X,    \"Technotrend/Hauppauge WinTV DVB-C rev2.X\");\nMAKE_AV7110_INFO(tts_2_X,    \"Technotrend/Hauppauge WinTV Nexus-S rev2.X\");\nMAKE_AV7110_INFO(tts_2_3,    \"Technotrend/Hauppauge WinTV Nexus-S rev2.3\");\nMAKE_AV7110_INFO(tts_1_3se,  \"Technotrend/Hauppauge WinTV DVB-S rev1.3 SE\");\nMAKE_AV7110_INFO(ttt,        \"Technotrend/Hauppauge DVB-T\");\nMAKE_AV7110_INFO(fsc,        \"Fujitsu Siemens DVB-C\");\nMAKE_AV7110_INFO(fss,        \"Fujitsu Siemens DVB-S rev1.6\");\nMAKE_AV7110_INFO(gxs_1_3,    \"Galaxis DVB-S rev1.3\");\n\nstatic const struct pci_device_id pci_tbl[] = {\n\tMAKE_EXTENSION_PCI(fsc,         0x110a, 0x0000),\n\tMAKE_EXTENSION_PCI(tts_1_X_fsc, 0x13c2, 0x0000),\n\tMAKE_EXTENSION_PCI(ttt_1_X,     0x13c2, 0x0001),\n\tMAKE_EXTENSION_PCI(ttc_2_X,     0x13c2, 0x0002),\n\tMAKE_EXTENSION_PCI(tts_2_X,     0x13c2, 0x0003),\n\tMAKE_EXTENSION_PCI(gxs_1_3,     0x13c2, 0x0004),\n\tMAKE_EXTENSION_PCI(fss,         0x13c2, 0x0006),\n\tMAKE_EXTENSION_PCI(ttt,         0x13c2, 0x0008),\n\tMAKE_EXTENSION_PCI(ttc_1_X,     0x13c2, 0x000a),\n\tMAKE_EXTENSION_PCI(tts_2_3,     0x13c2, 0x000e),\n\tMAKE_EXTENSION_PCI(tts_1_3se,   0x13c2, 0x1002),\n\n  \n  \n\n\t{\n\t\t.vendor    = 0,\n\t}\n};\n\nMODULE_DEVICE_TABLE(pci, pci_tbl);\n\n\nstatic struct saa7146_extension av7110_extension_driver = {\n\t.name\t\t= \"av7110\",\n\t.flags\t\t= SAA7146_USE_I2C_IRQ,\n\n\t.module\t\t= THIS_MODULE,\n\t.pci_tbl\t= &pci_tbl[0],\n\t.attach\t\t= av7110_attach,\n\t.detach\t\t= av7110_detach,\n\n\t.irq_mask\t= MASK_19 | MASK_03 | MASK_10,\n\t.irq_func\t= av7110_irq,\n};\n\n\nstatic int __init av7110_init(void)\n{\n\treturn saa7146_register_extension(&av7110_extension_driver);\n}\n\n\nstatic void __exit av7110_exit(void)\n{\n\tsaa7146_unregister_extension(&av7110_extension_driver);\n}\n\nmodule_init(av7110_init);\nmodule_exit(av7110_exit);\n\nMODULE_DESCRIPTION(\"driver for the SAA7146 based AV110 PCI DVB cards by Siemens, Technotrend, Hauppauge\");\nMODULE_AUTHOR(\"Ralph Metzler, Marcus Metzler, others\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}