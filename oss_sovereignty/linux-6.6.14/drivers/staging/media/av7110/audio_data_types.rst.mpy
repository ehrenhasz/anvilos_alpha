{
  "module_name": "audio_data_types.rst",
  "hash_id": "3746f720f460c5f1924cceba7f9c27fb3c35471c3a2dd2aed16f82af03f59534",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/av7110/audio_data_types.rst",
  "human_readable_source": ".. SPDX-License-Identifier: GFDL-1.1-no-invariants-or-later\n\n.. _audio_data_types:\n\n****************\nAudio Data Types\n****************\n\nThis section describes the structures, data types and defines used when\ntalking to the audio device.\n\n.. c:type:: audio_stream_source\n\nThe audio stream source is set through the AUDIO_SELECT_SOURCE call\nand can take the following values, depending on whether we are replaying\nfrom an internal (demux) or external (user write) source.\n\n\n.. code-block:: c\n\n    typedef enum {\n\tAUDIO_SOURCE_DEMUX,\n\tAUDIO_SOURCE_MEMORY\n    } audio_stream_source_t;\n\nAUDIO_SOURCE_DEMUX selects the demultiplexer (fed either by the\nfrontend or the DVR device) as the source of the video stream. If\nAUDIO_SOURCE_MEMORY is selected the stream comes from the application\nthrough the ``write()`` system call.\n\n\n.. c:type:: audio_play_state\n\nThe following values can be returned by the AUDIO_GET_STATUS call\nrepresenting the state of audio playback.\n\n\n.. code-block:: c\n\n    typedef enum {\n\tAUDIO_STOPPED,\n\tAUDIO_PLAYING,\n\tAUDIO_PAUSED\n    } audio_play_state_t;\n\n\n.. c:type:: audio_channel_select\n\nThe audio channel selected via AUDIO_CHANNEL_SELECT is determined by\nthe following values.\n\n\n.. code-block:: c\n\n    typedef enum {\n\tAUDIO_STEREO,\n\tAUDIO_MONO_LEFT,\n\tAUDIO_MONO_RIGHT,\n\tAUDIO_MONO,\n\tAUDIO_STEREO_SWAPPED\n    } audio_channel_select_t;\n\n\n.. c:type:: audio_status\n\nThe AUDIO_GET_STATUS call returns the following structure informing\nabout various states of the playback operation.\n\n\n.. code-block:: c\n\n    typedef struct audio_status {\n\tboolean AV_sync_state;\n\tboolean mute_state;\n\taudio_play_state_t play_state;\n\taudio_stream_source_t stream_source;\n\taudio_channel_select_t channel_select;\n\tboolean bypass_mode;\n\taudio_mixer_t mixer_state;\n    } audio_status_t;\n\n\n.. c:type:: audio_mixer\n\nThe following structure is used by the AUDIO_SET_MIXER call to set the\naudio volume.\n\n\n.. code-block:: c\n\n    typedef struct audio_mixer {\n\tunsigned int volume_left;\n\tunsigned int volume_right;\n    } audio_mixer_t;\n\n\n.. _audio_encodings:\n\naudio encodings\n===============\n\nA call to AUDIO_GET_CAPABILITIES returns an unsigned integer with the\nfollowing bits set according to the hardwares capabilities.\n\n\n.. code-block:: c\n\n     #define AUDIO_CAP_DTS    1\n     #define AUDIO_CAP_LPCM   2\n     #define AUDIO_CAP_MP1    4\n     #define AUDIO_CAP_MP2    8\n     #define AUDIO_CAP_MP3   16\n     #define AUDIO_CAP_AAC   32\n     #define AUDIO_CAP_OGG   64\n     #define AUDIO_CAP_SDDS 128\n     #define AUDIO_CAP_AC3  256\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}