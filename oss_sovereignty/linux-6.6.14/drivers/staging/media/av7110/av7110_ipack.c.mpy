{
  "module_name": "av7110_ipack.c",
  "hash_id": "6b6d20d925133cc57098dc64cec9cad5d3ce527964dc2854b38b123fafc8ac60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/av7110/av7110_ipack.c",
  "human_readable_source": "\n#include \"dvb_filter.h\"\n#include \"av7110_ipack.h\"\n#include <linux/string.h>\t \n#include <linux/vmalloc.h>\n\n\nvoid av7110_ipack_reset(struct ipack *p)\n{\n\tp->found = 0;\n\tp->cid = 0;\n\tp->plength = 0;\n\tp->flag1 = 0;\n\tp->flag2 = 0;\n\tp->hlength = 0;\n\tp->mpeg = 0;\n\tp->check = 0;\n\tp->which = 0;\n\tp->done = 0;\n\tp->count = 0;\n}\n\n\nint av7110_ipack_init(struct ipack *p, int size,\n\t\t      void (*func)(u8 *buf, int size, void *priv))\n{\n\tif (!(p->buf = vmalloc(size))) {\n\t\tprintk(KERN_WARNING \"Couldn't allocate memory for ipack\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tp->size = size;\n\tp->func = func;\n\tp->repack_subids = 0;\n\tav7110_ipack_reset(p);\n\treturn 0;\n}\n\n\nvoid av7110_ipack_free(struct ipack *p)\n{\n\tvfree(p->buf);\n}\n\n\nstatic void send_ipack(struct ipack *p)\n{\n\tint off;\n\tstruct dvb_audio_info ai;\n\tint ac3_off = 0;\n\tint streamid = 0;\n\tint nframes = 0;\n\tint f = 0;\n\n\tswitch (p->mpeg) {\n\tcase 2:\n\t\tif (p->count < 10)\n\t\t\treturn;\n\t\tp->buf[3] = p->cid;\n\t\tp->buf[4] = (u8)(((p->count - 6) & 0xff00) >> 8);\n\t\tp->buf[5] = (u8)((p->count - 6) & 0x00ff);\n\t\tif (p->repack_subids && p->cid == PRIVATE_STREAM1) {\n\t\t\toff = 9 + p->buf[8];\n\t\t\tstreamid = p->buf[off];\n\t\t\tif ((streamid & 0xf8) == 0x80) {\n\t\t\t\tai.off = 0;\n\t\t\t\tac3_off = ((p->buf[off + 2] << 8)|\n\t\t\t\t\t   p->buf[off + 3]);\n\t\t\t\tif (ac3_off < p->count)\n\t\t\t\t\tf = dvb_filter_get_ac3info(p->buf + off + 3 + ac3_off,\n\t\t\t\t\t\t\t\t   p->count - ac3_off, &ai, 0);\n\t\t\t\tif (!f) {\n\t\t\t\t\tnframes = (p->count - off - 3 - ac3_off) /\n\t\t\t\t\t\tai.framesize + 1;\n\t\t\t\t\tp->buf[off + 2] = (ac3_off >> 8) & 0xff;\n\t\t\t\t\tp->buf[off + 3] = (ac3_off) & 0xff;\n\t\t\t\t\tp->buf[off + 1] = nframes;\n\t\t\t\t\tac3_off +=  nframes * ai.framesize - p->count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp->func(p->buf, p->count, p->data);\n\n\t\tp->buf[6] = 0x80;\n\t\tp->buf[7] = 0x00;\n\t\tp->buf[8] = 0x00;\n\t\tp->count = 9;\n\t\tif (p->repack_subids && p->cid == PRIVATE_STREAM1\n\t\t    && (streamid & 0xf8) == 0x80) {\n\t\t\tp->count += 4;\n\t\t\tp->buf[9] = streamid;\n\t\t\tp->buf[10] = (ac3_off >> 8) & 0xff;\n\t\t\tp->buf[11] = (ac3_off) & 0xff;\n\t\t\tp->buf[12] = 0;\n\t\t}\n\t\tbreak;\n\n\tcase 1:\n\t\tif (p->count < 8)\n\t\t\treturn;\n\t\tp->buf[3] = p->cid;\n\t\tp->buf[4] = (u8)(((p->count - 6) & 0xff00) >> 8);\n\t\tp->buf[5] = (u8)((p->count - 6) & 0x00ff);\n\t\tp->func(p->buf, p->count, p->data);\n\n\t\tp->buf[6] = 0x0f;\n\t\tp->count = 7;\n\t\tbreak;\n\t}\n}\n\n\nvoid av7110_ipack_flush(struct ipack *p)\n{\n\tif (p->plength != MMAX_PLENGTH - 6 || p->found <= 6)\n\t\treturn;\n\tp->plength = p->found - 6;\n\tp->found = 0;\n\tsend_ipack(p);\n\tav7110_ipack_reset(p);\n}\n\n\nstatic void write_ipack(struct ipack *p, const u8 *data, int count)\n{\n\tu8 headr[3] = { 0x00, 0x00, 0x01 };\n\n\tif (p->count < 6) {\n\t\tmemcpy(p->buf, headr, 3);\n\t\tp->count = 6;\n\t}\n\n\tif (p->count + count < p->size){\n\t\tmemcpy(p->buf+p->count, data, count);\n\t\tp->count += count;\n\t} else {\n\t\tint rest = p->size - p->count;\n\t\tmemcpy(p->buf+p->count, data, rest);\n\t\tp->count += rest;\n\t\tsend_ipack(p);\n\t\tif (count - rest > 0)\n\t\t\twrite_ipack(p, data + rest, count - rest);\n\t}\n}\n\n\nint av7110_ipack_instant_repack (const u8 *buf, int count, struct ipack *p)\n{\n\tint l;\n\tint c = 0;\n\n\twhile (c < count && (p->mpeg == 0 ||\n\t\t\t     (p->mpeg == 1 && p->found < 7) ||\n\t\t\t     (p->mpeg == 2 && p->found < 9))\n\t       &&  (p->found < 5 || !p->done)) {\n\t\tswitch (p->found) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\tif (buf[c] == 0x00)\n\t\t\t\tp->found++;\n\t\t\telse\n\t\t\t\tp->found = 0;\n\t\t\tc++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (buf[c] == 0x01)\n\t\t\t\tp->found++;\n\t\t\telse if (buf[c] == 0)\n\t\t\t\tp->found = 2;\n\t\t\telse\n\t\t\t\tp->found = 0;\n\t\t\tc++;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tp->cid = 0;\n\t\t\tswitch (buf[c]) {\n\t\t\tcase PROG_STREAM_MAP:\n\t\t\tcase PRIVATE_STREAM2:\n\t\t\tcase PROG_STREAM_DIR:\n\t\t\tcase ECM_STREAM     :\n\t\t\tcase EMM_STREAM     :\n\t\t\tcase PADDING_STREAM :\n\t\t\tcase DSM_CC_STREAM  :\n\t\t\tcase ISO13522_STREAM:\n\t\t\t\tp->done = 1;\n\t\t\t\tfallthrough;\n\t\t\tcase PRIVATE_STREAM1:\n\t\t\tcase VIDEO_STREAM_S ... VIDEO_STREAM_E:\n\t\t\tcase AUDIO_STREAM_S ... AUDIO_STREAM_E:\n\t\t\t\tp->found++;\n\t\t\t\tp->cid = buf[c];\n\t\t\t\tc++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tp->found = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tif (count-c > 1) {\n\t\t\t\tp->plen[0] = buf[c];\n\t\t\t\tc++;\n\t\t\t\tp->plen[1] = buf[c];\n\t\t\t\tc++;\n\t\t\t\tp->found += 2;\n\t\t\t\tp->plength = (p->plen[0] << 8) | p->plen[1];\n\t\t\t} else {\n\t\t\t\tp->plen[0] = buf[c];\n\t\t\t\tp->found++;\n\t\t\t\treturn count;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tp->plen[1] = buf[c];\n\t\t\tc++;\n\t\t\tp->found++;\n\t\t\tp->plength = (p->plen[0] << 8) | p->plen[1];\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tif (!p->done) {\n\t\t\t\tp->flag1 = buf[c];\n\t\t\t\tc++;\n\t\t\t\tp->found++;\n\t\t\t\tif ((p->flag1 & 0xc0) == 0x80)\n\t\t\t\t\tp->mpeg = 2;\n\t\t\t\telse {\n\t\t\t\t\tp->hlength = 0;\n\t\t\t\t\tp->which = 0;\n\t\t\t\t\tp->mpeg = 1;\n\t\t\t\t\tp->flag2 = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 7:\n\t\t\tif (!p->done && p->mpeg == 2) {\n\t\t\t\tp->flag2 = buf[c];\n\t\t\t\tc++;\n\t\t\t\tp->found++;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\tif (!p->done && p->mpeg == 2) {\n\t\t\t\tp->hlength = buf[c];\n\t\t\t\tc++;\n\t\t\t\tp->found++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (c == count)\n\t\treturn count;\n\n\tif (!p->plength)\n\t\tp->plength = MMAX_PLENGTH - 6;\n\n\tif (p->done || ((p->mpeg == 2 && p->found >= 9) ||\n\t\t\t(p->mpeg == 1 && p->found >= 7))) {\n\t\tswitch (p->cid) {\n\t\tcase AUDIO_STREAM_S ... AUDIO_STREAM_E:\n\t\tcase VIDEO_STREAM_S ... VIDEO_STREAM_E:\n\t\tcase PRIVATE_STREAM1:\n\t\t\tif (p->mpeg == 2 && p->found == 9) {\n\t\t\t\twrite_ipack(p, &p->flag1, 1);\n\t\t\t\twrite_ipack(p, &p->flag2, 1);\n\t\t\t\twrite_ipack(p, &p->hlength, 1);\n\t\t\t}\n\n\t\t\tif (p->mpeg == 1 && p->found == 7)\n\t\t\t\twrite_ipack(p, &p->flag1, 1);\n\n\t\t\tif (p->mpeg == 2 && (p->flag2 & PTS_ONLY) &&\n\t\t\t    p->found < 14) {\n\t\t\t\twhile (c < count && p->found < 14) {\n\t\t\t\t\tp->pts[p->found - 9] = buf[c];\n\t\t\t\t\twrite_ipack(p, buf + c, 1);\n\t\t\t\t\tc++;\n\t\t\t\t\tp->found++;\n\t\t\t\t}\n\t\t\t\tif (c == count)\n\t\t\t\t\treturn count;\n\t\t\t}\n\n\t\t\tif (p->mpeg == 1 && p->which < 2000) {\n\n\t\t\t\tif (p->found == 7) {\n\t\t\t\t\tp->check = p->flag1;\n\t\t\t\t\tp->hlength = 1;\n\t\t\t\t}\n\n\t\t\t\twhile (!p->which && c < count &&\n\t\t\t\t       p->check == 0xff){\n\t\t\t\t\tp->check = buf[c];\n\t\t\t\t\twrite_ipack(p, buf + c, 1);\n\t\t\t\t\tc++;\n\t\t\t\t\tp->found++;\n\t\t\t\t\tp->hlength++;\n\t\t\t\t}\n\n\t\t\t\tif (c == count)\n\t\t\t\t\treturn count;\n\n\t\t\t\tif ((p->check & 0xc0) == 0x40 && !p->which) {\n\t\t\t\t\tp->check = buf[c];\n\t\t\t\t\twrite_ipack(p, buf + c, 1);\n\t\t\t\t\tc++;\n\t\t\t\t\tp->found++;\n\t\t\t\t\tp->hlength++;\n\n\t\t\t\t\tp->which = 1;\n\t\t\t\t\tif (c == count)\n\t\t\t\t\t\treturn count;\n\t\t\t\t\tp->check = buf[c];\n\t\t\t\t\twrite_ipack(p, buf + c, 1);\n\t\t\t\t\tc++;\n\t\t\t\t\tp->found++;\n\t\t\t\t\tp->hlength++;\n\t\t\t\t\tp->which = 2;\n\t\t\t\t\tif (c == count)\n\t\t\t\t\t\treturn count;\n\t\t\t\t}\n\n\t\t\t\tif (p->which == 1) {\n\t\t\t\t\tp->check = buf[c];\n\t\t\t\t\twrite_ipack(p, buf + c, 1);\n\t\t\t\t\tc++;\n\t\t\t\t\tp->found++;\n\t\t\t\t\tp->hlength++;\n\t\t\t\t\tp->which = 2;\n\t\t\t\t\tif (c == count)\n\t\t\t\t\t\treturn count;\n\t\t\t\t}\n\n\t\t\t\tif ((p->check & 0x30) && p->check != 0xff) {\n\t\t\t\t\tp->flag2 = (p->check & 0xf0) << 2;\n\t\t\t\t\tp->pts[0] = p->check;\n\t\t\t\t\tp->which = 3;\n\t\t\t\t}\n\n\t\t\t\tif (c == count)\n\t\t\t\t\treturn count;\n\t\t\t\tif (p->which > 2){\n\t\t\t\t\tif ((p->flag2 & PTS_DTS_FLAGS) == PTS_ONLY) {\n\t\t\t\t\t\twhile (c < count && p->which < 7) {\n\t\t\t\t\t\t\tp->pts[p->which - 2] = buf[c];\n\t\t\t\t\t\t\twrite_ipack(p, buf + c, 1);\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\tp->found++;\n\t\t\t\t\t\t\tp->which++;\n\t\t\t\t\t\t\tp->hlength++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (c == count)\n\t\t\t\t\t\t\treturn count;\n\t\t\t\t\t} else if ((p->flag2 & PTS_DTS_FLAGS) == PTS_DTS) {\n\t\t\t\t\t\twhile (c < count && p->which < 12) {\n\t\t\t\t\t\t\tif (p->which < 7)\n\t\t\t\t\t\t\t\tp->pts[p->which - 2] = buf[c];\n\t\t\t\t\t\t\twrite_ipack(p, buf + c, 1);\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\tp->found++;\n\t\t\t\t\t\t\tp->which++;\n\t\t\t\t\t\t\tp->hlength++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (c == count)\n\t\t\t\t\t\t\treturn count;\n\t\t\t\t\t}\n\t\t\t\t\tp->which = 2000;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\twhile (c < count && p->found < p->plength + 6) {\n\t\t\t\tl = count - c;\n\t\t\t\tif (l + p->found > p->plength + 6)\n\t\t\t\t\tl = p->plength + 6 - p->found;\n\t\t\t\twrite_ipack(p, buf + c, l);\n\t\t\t\tp->found += l;\n\t\t\t\tc += l;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\n\t\tif (p->done) {\n\t\t\tif (p->found + count - c < p->plength + 6) {\n\t\t\t\tp->found += count - c;\n\t\t\t\tc = count;\n\t\t\t} else {\n\t\t\t\tc += p->plength + 6 - p->found;\n\t\t\t\tp->found = p->plength + 6;\n\t\t\t}\n\t\t}\n\n\t\tif (p->plength && p->found == p->plength + 6) {\n\t\t\tsend_ipack(p);\n\t\t\tav7110_ipack_reset(p);\n\t\t\tif (c < count)\n\t\t\t\tav7110_ipack_instant_repack(buf + c, count - c, p);\n\t\t}\n\t}\n\treturn count;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}