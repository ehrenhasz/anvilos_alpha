{
  "module_name": "tegra210.c",
  "hash_id": "5188d0e76852edc27a4d7312106fdbc3c83e1d90f61ccc526f508e194e01cc17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/tegra-video/tegra210.c",
  "human_readable_source": "\n \n\n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk/tegra.h>\n#include <linux/delay.h>\n#include <linux/host1x.h>\n#include <linux/kthread.h>\n\n#include \"csi.h\"\n#include \"vi.h\"\n\n#define TEGRA210_MIN_WIDTH\t32U\n#define TEGRA210_MAX_WIDTH\t32768U\n#define TEGRA210_MIN_HEIGHT\t32U\n#define TEGRA210_MAX_HEIGHT\t32768U\n\n#define SURFACE_ALIGN_BYTES\t64\n\n#define TEGRA_VI_SYNCPT_WAIT_TIMEOUT\t\t\tmsecs_to_jiffies(200)\n\n \n#define TEGRA_VI_CFG_VI_INCR_SYNCPT\t\t\t0x000\n#define   VI_CFG_VI_INCR_SYNCPT_COND(x)\t\t\t(((x) & 0xff) << 8)\n#define   VI_CSI_PP_FRAME_START(port)\t\t\t(5 + (port) * 4)\n#define   VI_CSI_MW_ACK_DONE(port)\t\t\t(7 + (port) * 4)\n#define TEGRA_VI_CFG_VI_INCR_SYNCPT_CNTRL\t\t0x004\n#define   VI_INCR_SYNCPT_NO_STALL\t\t\tBIT(8)\n#define TEGRA_VI_CFG_VI_INCR_SYNCPT_ERROR\t\t0x008\n#define TEGRA_VI_CFG_CG_CTRL\t\t\t\t0x0b8\n#define   VI_CG_2ND_LEVEL_EN\t\t\t\t0x1\n\n \n#define TEGRA_VI_CSI_SW_RESET\t\t\t\t0x000\n#define TEGRA_VI_CSI_SINGLE_SHOT\t\t\t0x004\n#define   SINGLE_SHOT_CAPTURE\t\t\t\t0x1\n#define TEGRA_VI_CSI_IMAGE_DEF\t\t\t\t0x00c\n#define   BYPASS_PXL_TRANSFORM_OFFSET\t\t\t24\n#define   IMAGE_DEF_FORMAT_OFFSET\t\t\t16\n#define   IMAGE_DEF_DEST_MEM\t\t\t\t0x1\n#define TEGRA_VI_CSI_IMAGE_SIZE\t\t\t\t0x018\n#define   IMAGE_SIZE_HEIGHT_OFFSET\t\t\t16\n#define TEGRA_VI_CSI_IMAGE_SIZE_WC\t\t\t0x01c\n#define TEGRA_VI_CSI_IMAGE_DT\t\t\t\t0x020\n#define TEGRA_VI_CSI_SURFACE0_OFFSET_MSB\t\t0x024\n#define TEGRA_VI_CSI_SURFACE0_OFFSET_LSB\t\t0x028\n#define TEGRA_VI_CSI_SURFACE1_OFFSET_MSB\t\t0x02c\n#define TEGRA_VI_CSI_SURFACE1_OFFSET_LSB\t\t0x030\n#define TEGRA_VI_CSI_SURFACE2_OFFSET_MSB\t\t0x034\n#define TEGRA_VI_CSI_SURFACE2_OFFSET_LSB\t\t0x038\n#define TEGRA_VI_CSI_SURFACE0_STRIDE\t\t\t0x054\n#define TEGRA_VI_CSI_SURFACE1_STRIDE\t\t\t0x058\n#define TEGRA_VI_CSI_SURFACE2_STRIDE\t\t\t0x05c\n#define TEGRA_VI_CSI_SURFACE_HEIGHT0\t\t\t0x060\n#define TEGRA_VI_CSI_ERROR_STATUS\t\t\t0x084\n\n \n#define TEGRA_CSI_INPUT_STREAM_CONTROL                  0x000\n#define   CSI_SKIP_PACKET_THRESHOLD_OFFSET\t\t16\n#define TEGRA_CSI_PIXEL_STREAM_CONTROL0\t\t\t0x004\n#define   CSI_PP_PACKET_HEADER_SENT\t\t\tBIT(4)\n#define   CSI_PP_DATA_IDENTIFIER_ENABLE\t\t\tBIT(5)\n#define   CSI_PP_WORD_COUNT_SELECT_HEADER\t\tBIT(6)\n#define   CSI_PP_CRC_CHECK_ENABLE\t\t\tBIT(7)\n#define   CSI_PP_WC_CHECK\t\t\t\tBIT(8)\n#define   CSI_PP_OUTPUT_FORMAT_STORE\t\t\t(0x3 << 16)\n#define   CSI_PPA_PAD_LINE_NOPAD\t\t\t(0x2 << 24)\n#define   CSI_PP_HEADER_EC_DISABLE\t\t\t(0x1 << 27)\n#define   CSI_PPA_PAD_FRAME_NOPAD\t\t\t(0x2 << 28)\n#define TEGRA_CSI_PIXEL_STREAM_CONTROL1                 0x008\n#define   CSI_PP_TOP_FIELD_FRAME_OFFSET\t\t\t0\n#define   CSI_PP_TOP_FIELD_FRAME_MASK_OFFSET\t\t4\n#define TEGRA_CSI_PIXEL_STREAM_GAP                      0x00c\n#define   PP_FRAME_MIN_GAP_OFFSET\t\t\t16\n#define TEGRA_CSI_PIXEL_STREAM_PP_COMMAND               0x010\n#define   CSI_PP_ENABLE\t\t\t\t\t0x1\n#define   CSI_PP_DISABLE\t\t\t\t0x2\n#define   CSI_PP_RST\t\t\t\t\t0x3\n#define   CSI_PP_SINGLE_SHOT_ENABLE\t\t\t(0x1 << 2)\n#define   CSI_PP_START_MARKER_FRAME_MAX_OFFSET\t\t12\n#define TEGRA_CSI_PIXEL_STREAM_EXPECTED_FRAME           0x014\n#define TEGRA_CSI_PIXEL_PARSER_INTERRUPT_MASK           0x018\n#define TEGRA_CSI_PIXEL_PARSER_STATUS                   0x01c\n\n \n \n#define TEGRA_CSI_PHY_CIL_COMMAND                       0x0d0\n#define   CSI_A_PHY_CIL_NOP\t\t\t\t0x0\n#define   CSI_A_PHY_CIL_ENABLE\t\t\t\t0x1\n#define   CSI_A_PHY_CIL_DISABLE\t\t\t\t0x2\n#define   CSI_A_PHY_CIL_ENABLE_MASK\t\t\t0x3\n#define   CSI_B_PHY_CIL_NOP\t\t\t\t(0x0 << 8)\n#define   CSI_B_PHY_CIL_ENABLE\t\t\t\t(0x1 << 8)\n#define   CSI_B_PHY_CIL_DISABLE\t\t\t\t(0x2 << 8)\n#define   CSI_B_PHY_CIL_ENABLE_MASK\t\t\t(0x3 << 8)\n\n#define TEGRA_CSI_CIL_PAD_CONFIG0                       0x000\n#define   BRICK_CLOCK_A_4X\t\t\t\t(0x1 << 16)\n#define   BRICK_CLOCK_B_4X\t\t\t\t(0x2 << 16)\n#define TEGRA_CSI_CIL_PAD_CONFIG1                       0x004\n#define TEGRA_CSI_CIL_PHY_CONTROL                       0x008\n#define   CLK_SETTLE_MASK\t\t\t\tGENMASK(13, 8)\n#define   THS_SETTLE_MASK\t\t\t\tGENMASK(5, 0)\n#define TEGRA_CSI_CIL_INTERRUPT_MASK                    0x00c\n#define TEGRA_CSI_CIL_STATUS                            0x010\n#define TEGRA_CSI_CILX_STATUS                           0x014\n#define TEGRA_CSI_CIL_SW_SENSOR_RESET                   0x020\n\n#define TEGRA_CSI_PATTERN_GENERATOR_CTRL\t\t0x000\n#define   PG_MODE_OFFSET\t\t\t\t2\n#define   PG_ENABLE\t\t\t\t\t0x1\n#define   PG_DISABLE\t\t\t\t\t0x0\n#define TEGRA_CSI_PG_BLANK\t\t\t\t0x004\n#define   PG_VBLANK_OFFSET\t\t\t\t16\n#define TEGRA_CSI_PG_PHASE\t\t\t\t0x008\n#define TEGRA_CSI_PG_RED_FREQ\t\t\t\t0x00c\n#define   PG_RED_VERT_INIT_FREQ_OFFSET\t\t\t16\n#define   PG_RED_HOR_INIT_FREQ_OFFSET\t\t\t0\n#define TEGRA_CSI_PG_RED_FREQ_RATE\t\t\t0x010\n#define TEGRA_CSI_PG_GREEN_FREQ\t\t\t\t0x014\n#define   PG_GREEN_VERT_INIT_FREQ_OFFSET\t\t16\n#define   PG_GREEN_HOR_INIT_FREQ_OFFSET\t\t\t0\n#define TEGRA_CSI_PG_GREEN_FREQ_RATE\t\t\t0x018\n#define TEGRA_CSI_PG_BLUE_FREQ\t\t\t\t0x01c\n#define   PG_BLUE_VERT_INIT_FREQ_OFFSET\t\t\t16\n#define   PG_BLUE_HOR_INIT_FREQ_OFFSET\t\t\t0\n#define TEGRA_CSI_PG_BLUE_FREQ_RATE\t\t\t0x020\n#define TEGRA_CSI_PG_AOHDR\t\t\t\t0x024\n#define TEGRA_CSI_CSI_SW_STATUS_RESET\t\t\t0x214\n#define TEGRA_CSI_CLKEN_OVERRIDE\t\t\t0x218\n\n#define TEGRA210_CSI_PORT_OFFSET\t\t\t0x34\n#define TEGRA210_CSI_CIL_OFFSET\t\t\t\t0x0f4\n#define TEGRA210_CSI_TPG_OFFSET\t\t\t\t0x18c\n\n#define CSI_PP_OFFSET(block)\t\t\t\t((block) * 0x800)\n#define TEGRA210_VI_CSI_BASE(x)\t\t\t\t(0x100 + (x) * 0x100)\n\n \nstatic void tegra_vi_write(struct tegra_vi_channel *chan, unsigned int addr,\n\t\t\t   u32 val)\n{\n\twritel_relaxed(val, chan->vi->iomem + addr);\n}\n\nstatic u32 tegra_vi_read(struct tegra_vi_channel *chan, unsigned int addr)\n{\n\treturn readl_relaxed(chan->vi->iomem + addr);\n}\n\n \nstatic void vi_csi_write(struct tegra_vi_channel *chan, u8 portno,\n\t\t\t unsigned int addr, u32 val)\n{\n\tvoid __iomem *vi_csi_base;\n\n\tvi_csi_base = chan->vi->iomem + TEGRA210_VI_CSI_BASE(portno);\n\n\twritel_relaxed(val, vi_csi_base + addr);\n}\n\nstatic u32 vi_csi_read(struct tegra_vi_channel *chan, u8 portno,\n\t\t       unsigned int addr)\n{\n\tvoid __iomem *vi_csi_base;\n\n\tvi_csi_base = chan->vi->iomem + TEGRA210_VI_CSI_BASE(portno);\n\n\treturn readl_relaxed(vi_csi_base + addr);\n}\n\n \n\nstatic int tegra210_channel_host1x_syncpt_init(struct tegra_vi_channel *chan)\n{\n\tstruct tegra_vi *vi = chan->vi;\n\tunsigned long flags = HOST1X_SYNCPT_CLIENT_MANAGED;\n\tstruct host1x_syncpt *fs_sp;\n\tstruct host1x_syncpt *mw_sp;\n\tint ret, i;\n\n\tfor (i = 0; i < chan->numgangports; i++) {\n\t\tfs_sp = host1x_syncpt_request(&vi->client, flags);\n\t\tif (!fs_sp) {\n\t\t\tdev_err(vi->dev, \"failed to request frame start syncpoint\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_syncpts;\n\t\t}\n\n\t\tmw_sp = host1x_syncpt_request(&vi->client, flags);\n\t\tif (!mw_sp) {\n\t\t\tdev_err(vi->dev, \"failed to request memory ack syncpoint\\n\");\n\t\t\thost1x_syncpt_put(fs_sp);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_syncpts;\n\t\t}\n\n\t\tchan->frame_start_sp[i] = fs_sp;\n\t\tchan->mw_ack_sp[i] = mw_sp;\n\t\tspin_lock_init(&chan->sp_incr_lock[i]);\n\t}\n\n\treturn 0;\n\nfree_syncpts:\n\tfor (i = 0; i < chan->numgangports; i++) {\n\t\thost1x_syncpt_put(chan->mw_ack_sp[i]);\n\t\thost1x_syncpt_put(chan->frame_start_sp[i]);\n\t}\n\treturn ret;\n}\n\nstatic void tegra210_channel_host1x_syncpt_free(struct tegra_vi_channel *chan)\n{\n\tint i;\n\n\tfor (i = 0; i < chan->numgangports; i++) {\n\t\thost1x_syncpt_put(chan->mw_ack_sp[i]);\n\t\thost1x_syncpt_put(chan->frame_start_sp[i]);\n\t}\n}\n\nstatic void tegra210_fmt_align(struct v4l2_pix_format *pix, unsigned int bpp)\n{\n\tunsigned int min_bpl;\n\tunsigned int max_bpl;\n\tunsigned int bpl;\n\n\t \n\tpix->width = clamp(pix->width, TEGRA210_MIN_WIDTH, TEGRA210_MAX_WIDTH);\n\tpix->height = clamp(pix->height, TEGRA210_MIN_HEIGHT, TEGRA210_MAX_HEIGHT);\n\n\t \n\tmin_bpl = pix->width * bpp;\n\tmax_bpl = rounddown(TEGRA210_MAX_WIDTH, SURFACE_ALIGN_BYTES);\n\tbpl = roundup(pix->bytesperline, SURFACE_ALIGN_BYTES);\n\n\tpix->bytesperline = clamp(bpl, min_bpl, max_bpl);\n\tpix->sizeimage = pix->bytesperline * pix->height;\n\tif (pix->pixelformat == V4L2_PIX_FMT_NV16)\n\t\tpix->sizeimage *= 2;\n}\n\nstatic int tegra_channel_capture_setup(struct tegra_vi_channel *chan,\n\t\t\t\t       u8 portno)\n{\n\tu32 height = chan->format.height;\n\tu32 width = chan->format.width;\n\tu32 format = chan->fmtinfo->img_fmt;\n\tu32 data_type = chan->fmtinfo->img_dt;\n\tu32 word_count = (width * chan->fmtinfo->bit_width) / 8;\n\tu32 bypass_pixel_transform = BIT(BYPASS_PXL_TRANSFORM_OFFSET);\n\n\t \n\tif (chan->pg_mode || data_type == TEGRA_IMAGE_DT_YUV422_8 ||\n\t    data_type == TEGRA_IMAGE_DT_RGB888)\n\t\tbypass_pixel_transform = 0;\n\n\t \n\tif (chan->numgangports > 1) {\n\t\twidth = width >> 1;\n\t\tword_count = (width * chan->fmtinfo->bit_width) / 8;\n\t}\n\n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_ERROR_STATUS, 0xffffffff);\n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_IMAGE_DEF,\n\t\t     bypass_pixel_transform |\n\t\t     (format << IMAGE_DEF_FORMAT_OFFSET) |\n\t\t     IMAGE_DEF_DEST_MEM);\n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_IMAGE_DT, data_type);\n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_IMAGE_SIZE_WC, word_count);\n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_IMAGE_SIZE,\n\t\t     (height << IMAGE_SIZE_HEIGHT_OFFSET) | width);\n\treturn 0;\n}\n\nstatic void tegra_channel_vi_soft_reset(struct tegra_vi_channel *chan,\n\t\t\t\t\tu8 portno)\n{\n\t \n\ttegra_vi_write(chan, TEGRA_VI_CFG_CG_CTRL, 0);\n\t \n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_SW_RESET, 0xf);\n\tusleep_range(100, 200);\n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_SW_RESET, 0x0);\n\n\t \n\ttegra_vi_write(chan, TEGRA_VI_CFG_CG_CTRL, VI_CG_2ND_LEVEL_EN);\n}\n\nstatic void tegra_channel_capture_error_recover(struct tegra_vi_channel *chan,\n\t\t\t\t\t\tu8 portno)\n{\n\tstruct v4l2_subdev *subdev;\n\tu32 val;\n\n\t \n\tval = vi_csi_read(chan, portno, TEGRA_VI_CSI_ERROR_STATUS);\n\tdev_dbg(&chan->video.dev, \"TEGRA_VI_CSI_ERROR_STATUS 0x%08x\\n\", val);\n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_ERROR_STATUS, val);\n\n\tval = tegra_vi_read(chan, TEGRA_VI_CFG_VI_INCR_SYNCPT_ERROR);\n\tdev_dbg(&chan->video.dev,\n\t\t\"TEGRA_VI_CFG_VI_INCR_SYNCPT_ERROR 0x%08x\\n\", val);\n\ttegra_vi_write(chan, TEGRA_VI_CFG_VI_INCR_SYNCPT_ERROR, val);\n\n\t \n\ttegra_channel_vi_soft_reset(chan, portno);\n\ttegra_channel_capture_setup(chan, portno);\n\n\t \n\tsubdev = tegra_channel_get_remote_csi_subdev(chan);\n\ttegra_csi_error_recover(subdev);\n}\n\nstatic struct tegra_channel_buffer *\ndequeue_buf_done(struct tegra_vi_channel *chan)\n{\n\tstruct tegra_channel_buffer *buf = NULL;\n\n\tspin_lock(&chan->done_lock);\n\tif (list_empty(&chan->done)) {\n\t\tspin_unlock(&chan->done_lock);\n\t\treturn NULL;\n\t}\n\n\tbuf = list_first_entry(&chan->done,\n\t\t\t       struct tegra_channel_buffer, queue);\n\tif (buf)\n\t\tlist_del_init(&buf->queue);\n\tspin_unlock(&chan->done_lock);\n\n\treturn buf;\n}\n\nstatic void release_buffer(struct tegra_vi_channel *chan,\n\t\t\t   struct tegra_channel_buffer *buf,\n\t\t\t   enum vb2_buffer_state state)\n{\n\tstruct vb2_v4l2_buffer *vb = &buf->buf;\n\n\tvb->sequence = chan->sequence++;\n\tvb->field = V4L2_FIELD_NONE;\n\tvb->vb2_buf.timestamp = ktime_get_ns();\n\tvb2_buffer_done(&vb->vb2_buf, state);\n}\n\nstatic void tegra_channel_vi_buffer_setup(struct tegra_vi_channel *chan,\n\t\t\t\t\t  u8 portno, u32 buf_offset,\n\t\t\t\t\t  struct tegra_channel_buffer *buf)\n{\n\tint bytesperline = chan->format.bytesperline;\n\tu32 sizeimage = chan->format.sizeimage;\n\n\t \n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_SURFACE0_OFFSET_MSB,\n\t\t     ((u64)buf->addr + buf_offset) >> 32);\n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_SURFACE0_OFFSET_LSB,\n\t\t     buf->addr + buf_offset);\n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_SURFACE0_STRIDE, bytesperline);\n\n\tif (chan->fmtinfo->fourcc != V4L2_PIX_FMT_NV16)\n\t\treturn;\n\t \n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_SURFACE1_OFFSET_MSB,\n\t\t     (((u64)buf->addr + sizeimage / 2) + buf_offset) >> 32);\n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_SURFACE1_OFFSET_LSB,\n\t\t     buf->addr + sizeimage / 2 + buf_offset);\n\tvi_csi_write(chan, portno, TEGRA_VI_CSI_SURFACE1_STRIDE, bytesperline);\n}\n\nstatic int tegra_channel_capture_frame(struct tegra_vi_channel *chan,\n\t\t\t\t       struct tegra_channel_buffer *buf)\n{\n\tu32 thresh, value, frame_start, mw_ack_done;\n\tu32 fs_thresh[GANG_PORTS_MAX];\n\tu8 *portnos = chan->portnos;\n\tint gang_bpl = (chan->format.width >> 1) * chan->fmtinfo->bpp;\n\tu32 buf_offset;\n\tbool capture_timedout = false;\n\tint err, i;\n\n\tfor (i = 0; i < chan->numgangports; i++) {\n\t\t \n\t\tbuf_offset = i * roundup(gang_bpl, SURFACE_ALIGN_BYTES);\n\t\ttegra_channel_vi_buffer_setup(chan, portnos[i], buf_offset,\n\t\t\t\t\t      buf);\n\n\t\t \n\n\t\t \n\t\tthresh = host1x_syncpt_incr_max(chan->frame_start_sp[i], 1);\n\t\tfs_thresh[i] = thresh;\n\n\t\t \n\t\tframe_start = VI_CSI_PP_FRAME_START(portnos[i]);\n\t\tvalue = VI_CFG_VI_INCR_SYNCPT_COND(frame_start) |\n\t\t\thost1x_syncpt_id(chan->frame_start_sp[i]);\n\t\ttegra_vi_write(chan, TEGRA_VI_CFG_VI_INCR_SYNCPT, value);\n\n\t\t \n\t\tthresh = host1x_syncpt_incr_max(chan->mw_ack_sp[i], 1);\n\t\tbuf->mw_ack_sp_thresh[i] = thresh;\n\n\t\t \n\t\tmw_ack_done = VI_CSI_MW_ACK_DONE(portnos[i]);\n\t\tvalue = VI_CFG_VI_INCR_SYNCPT_COND(mw_ack_done) |\n\t\t\thost1x_syncpt_id(chan->mw_ack_sp[i]);\n\t\ttegra_vi_write(chan, TEGRA_VI_CFG_VI_INCR_SYNCPT, value);\n\t}\n\n\t \n\tfor (i = 0; i < chan->numgangports; i++)\n\t\tvi_csi_write(chan, portnos[i], TEGRA_VI_CSI_SINGLE_SHOT,\n\t\t\t     SINGLE_SHOT_CAPTURE);\n\n\tfor (i = 0; i < chan->numgangports; i++) {\n\t\t \n\t\terr = host1x_syncpt_wait(chan->frame_start_sp[i], fs_thresh[i],\n\t\t\t\t\t TEGRA_VI_SYNCPT_WAIT_TIMEOUT, &value);\n\t\tif (err) {\n\t\t\tcapture_timedout = true;\n\t\t\t \n\t\t\thost1x_syncpt_incr(chan->frame_start_sp[i]);\n\t\t\tspin_lock(&chan->sp_incr_lock[i]);\n\t\t\thost1x_syncpt_incr(chan->mw_ack_sp[i]);\n\t\t\tspin_unlock(&chan->sp_incr_lock[i]);\n\t\t\t \n\t\t\ttegra_channel_capture_error_recover(chan, portnos[i]);\n\t\t}\n\t}\n\n\tif (capture_timedout) {\n\t\tdev_err_ratelimited(&chan->video.dev,\n\t\t\t\t    \"frame start syncpt timeout: %d\\n\", err);\n\t\trelease_buffer(chan, buf, VB2_BUF_STATE_ERROR);\n\t\treturn err;\n\t}\n\n\t \n\tspin_lock(&chan->done_lock);\n\tlist_add_tail(&buf->queue, &chan->done);\n\tspin_unlock(&chan->done_lock);\n\n\t \n\twake_up_interruptible(&chan->done_wait);\n\n\treturn 0;\n}\n\nstatic void tegra_channel_capture_done(struct tegra_vi_channel *chan,\n\t\t\t\t       struct tegra_channel_buffer *buf)\n{\n\tenum vb2_buffer_state state = VB2_BUF_STATE_DONE;\n\tu32 value;\n\tbool capture_timedout = false;\n\tint ret, i;\n\n\tfor (i = 0; i < chan->numgangports; i++) {\n\t\t \n\t\tret = host1x_syncpt_wait(chan->mw_ack_sp[i],\n\t\t\t\t\t buf->mw_ack_sp_thresh[i],\n\t\t\t\t\t TEGRA_VI_SYNCPT_WAIT_TIMEOUT, &value);\n\t\tif (ret) {\n\t\t\tcapture_timedout = true;\n\t\t\tstate = VB2_BUF_STATE_ERROR;\n\t\t\t \n\t\t\tspin_lock(&chan->sp_incr_lock[i]);\n\t\t\thost1x_syncpt_incr(chan->mw_ack_sp[i]);\n\t\t\tspin_unlock(&chan->sp_incr_lock[i]);\n\t\t}\n\t}\n\n\tif (capture_timedout)\n\t\tdev_err_ratelimited(&chan->video.dev,\n\t\t\t\t    \"MW_ACK_DONE syncpt timeout: %d\\n\", ret);\n\trelease_buffer(chan, buf, state);\n}\n\nstatic int chan_capture_kthread_start(void *data)\n{\n\tstruct tegra_vi_channel *chan = data;\n\tstruct tegra_channel_buffer *buf;\n\tunsigned int retries = 0;\n\tint err = 0;\n\n\twhile (1) {\n\t\t \n\t\twait_event_interruptible(chan->start_wait,\n\t\t\t\t\t kthread_should_stop() ||\n\t\t\t\t\t (!list_empty(&chan->capture) &&\n\t\t\t\t\t !err));\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\t \n\t\tspin_lock(&chan->start_lock);\n\t\tif (list_empty(&chan->capture)) {\n\t\t\tspin_unlock(&chan->start_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf = list_first_entry(&chan->capture,\n\t\t\t\t       struct tegra_channel_buffer, queue);\n\t\tlist_del_init(&buf->queue);\n\t\tspin_unlock(&chan->start_lock);\n\n\t\terr = tegra_channel_capture_frame(chan, buf);\n\t\tif (!err) {\n\t\t\tretries = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (retries++ > chan->syncpt_timeout_retry)\n\t\t\tvb2_queue_error(&chan->queue);\n\t\telse\n\t\t\terr = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int chan_capture_kthread_finish(void *data)\n{\n\tstruct tegra_vi_channel *chan = data;\n\tstruct tegra_channel_buffer *buf;\n\n\twhile (1) {\n\t\twait_event_interruptible(chan->done_wait,\n\t\t\t\t\t !list_empty(&chan->done) ||\n\t\t\t\t\t kthread_should_stop());\n\n\t\t \n\t\tbuf = dequeue_buf_done(chan);\n\t\twhile (buf) {\n\t\t\ttegra_channel_capture_done(chan, buf);\n\t\t\tbuf = dequeue_buf_done(chan);\n\t\t}\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra210_vi_start_streaming(struct vb2_queue *vq, u32 count)\n{\n\tstruct tegra_vi_channel *chan = vb2_get_drv_priv(vq);\n\tstruct media_pipeline *pipe = &chan->video.pipe;\n\tu32 val;\n\tu8 *portnos = chan->portnos;\n\tint ret, i;\n\n\ttegra_vi_write(chan, TEGRA_VI_CFG_CG_CTRL, VI_CG_2ND_LEVEL_EN);\n\n\t \n\tval = tegra_vi_read(chan, TEGRA_VI_CFG_VI_INCR_SYNCPT_ERROR);\n\ttegra_vi_write(chan, TEGRA_VI_CFG_VI_INCR_SYNCPT_ERROR, val);\n\n\t \n\ttegra_vi_write(chan, TEGRA_VI_CFG_VI_INCR_SYNCPT_CNTRL,\n\t\t       VI_INCR_SYNCPT_NO_STALL);\n\n\t \n\tret = video_device_pipeline_start(&chan->video, pipe);\n\tif (ret < 0)\n\t\tgoto error_pipeline_start;\n\n\t \n\tfor (i = 0; i < chan->numgangports; i++) {\n\t\tval = vi_csi_read(chan, portnos[i], TEGRA_VI_CSI_ERROR_STATUS);\n\t\tvi_csi_write(chan, portnos[i], TEGRA_VI_CSI_ERROR_STATUS, val);\n\n\t\ttegra_channel_capture_setup(chan, portnos[i]);\n\t}\n\n\tret = tegra_channel_set_stream(chan, true);\n\tif (ret < 0)\n\t\tgoto error_set_stream;\n\n\tchan->sequence = 0;\n\n\t \n\tchan->kthread_start_capture = kthread_run(chan_capture_kthread_start,\n\t\t\t\t\t\t  chan, \"%s:0\",\n\t\t\t\t\t\t  chan->video.name);\n\tif (IS_ERR(chan->kthread_start_capture)) {\n\t\tret = PTR_ERR(chan->kthread_start_capture);\n\t\tchan->kthread_start_capture = NULL;\n\t\tdev_err(&chan->video.dev,\n\t\t\t\"failed to run capture start kthread: %d\\n\", ret);\n\t\tgoto error_kthread_start;\n\t}\n\n\tchan->kthread_finish_capture = kthread_run(chan_capture_kthread_finish,\n\t\t\t\t\t\t   chan, \"%s:1\",\n\t\t\t\t\t\t   chan->video.name);\n\tif (IS_ERR(chan->kthread_finish_capture)) {\n\t\tret = PTR_ERR(chan->kthread_finish_capture);\n\t\tchan->kthread_finish_capture = NULL;\n\t\tdev_err(&chan->video.dev,\n\t\t\t\"failed to run capture finish kthread: %d\\n\", ret);\n\t\tgoto error_kthread_done;\n\t}\n\n\treturn 0;\n\nerror_kthread_done:\n\tkthread_stop(chan->kthread_start_capture);\nerror_kthread_start:\n\ttegra_channel_set_stream(chan, false);\nerror_set_stream:\n\tvideo_device_pipeline_stop(&chan->video);\nerror_pipeline_start:\n\ttegra_channel_release_buffers(chan, VB2_BUF_STATE_QUEUED);\n\treturn ret;\n}\n\nstatic void tegra210_vi_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct tegra_vi_channel *chan = vb2_get_drv_priv(vq);\n\n\tif (chan->kthread_start_capture) {\n\t\tkthread_stop(chan->kthread_start_capture);\n\t\tchan->kthread_start_capture = NULL;\n\t}\n\n\tif (chan->kthread_finish_capture) {\n\t\tkthread_stop(chan->kthread_finish_capture);\n\t\tchan->kthread_finish_capture = NULL;\n\t}\n\n\ttegra_channel_release_buffers(chan, VB2_BUF_STATE_ERROR);\n\ttegra_channel_set_stream(chan, false);\n\tvideo_device_pipeline_stop(&chan->video);\n}\n\n \nenum tegra210_image_format {\n\tTEGRA210_IMAGE_FORMAT_T_L8 = 16,\n\n\tTEGRA210_IMAGE_FORMAT_T_R16_I = 32,\n\tTEGRA210_IMAGE_FORMAT_T_B5G6R5,\n\tTEGRA210_IMAGE_FORMAT_T_R5G6B5,\n\tTEGRA210_IMAGE_FORMAT_T_A1B5G5R5,\n\tTEGRA210_IMAGE_FORMAT_T_A1R5G5B5,\n\tTEGRA210_IMAGE_FORMAT_T_B5G5R5A1,\n\tTEGRA210_IMAGE_FORMAT_T_R5G5B5A1,\n\tTEGRA210_IMAGE_FORMAT_T_A4B4G4R4,\n\tTEGRA210_IMAGE_FORMAT_T_A4R4G4B4,\n\tTEGRA210_IMAGE_FORMAT_T_B4G4R4A4,\n\tTEGRA210_IMAGE_FORMAT_T_R4G4B4A4,\n\n\tTEGRA210_IMAGE_FORMAT_T_A8B8G8R8 = 64,\n\tTEGRA210_IMAGE_FORMAT_T_A8R8G8B8,\n\tTEGRA210_IMAGE_FORMAT_T_B8G8R8A8,\n\tTEGRA210_IMAGE_FORMAT_T_R8G8B8A8,\n\tTEGRA210_IMAGE_FORMAT_T_A2B10G10R10,\n\tTEGRA210_IMAGE_FORMAT_T_A2R10G10B10,\n\tTEGRA210_IMAGE_FORMAT_T_B10G10R10A2,\n\tTEGRA210_IMAGE_FORMAT_T_R10G10B10A2,\n\n\tTEGRA210_IMAGE_FORMAT_T_A8Y8U8V8 = 193,\n\tTEGRA210_IMAGE_FORMAT_T_V8U8Y8A8,\n\n\tTEGRA210_IMAGE_FORMAT_T_A2Y10U10V10 = 197,\n\tTEGRA210_IMAGE_FORMAT_T_V10U10Y10A2,\n\tTEGRA210_IMAGE_FORMAT_T_Y8_U8__Y8_V8,\n\tTEGRA210_IMAGE_FORMAT_T_Y8_V8__Y8_U8,\n\tTEGRA210_IMAGE_FORMAT_T_U8_Y8__V8_Y8,\n\tTEGRA210_IMAGE_FORMAT_T_V8_Y8__U8_Y8,\n\n\tTEGRA210_IMAGE_FORMAT_T_Y8__U8__V8_N444 = 224,\n\tTEGRA210_IMAGE_FORMAT_T_Y8__U8V8_N444,\n\tTEGRA210_IMAGE_FORMAT_T_Y8__V8U8_N444,\n\tTEGRA210_IMAGE_FORMAT_T_Y8__U8__V8_N422,\n\tTEGRA210_IMAGE_FORMAT_T_Y8__U8V8_N422,\n\tTEGRA210_IMAGE_FORMAT_T_Y8__V8U8_N422,\n\tTEGRA210_IMAGE_FORMAT_T_Y8__U8__V8_N420,\n\tTEGRA210_IMAGE_FORMAT_T_Y8__U8V8_N420,\n\tTEGRA210_IMAGE_FORMAT_T_Y8__V8U8_N420,\n\tTEGRA210_IMAGE_FORMAT_T_X2LC10LB10LA10,\n\tTEGRA210_IMAGE_FORMAT_T_A2R6R6R6R6R6,\n};\n\n#define TEGRA210_VIDEO_FMT(DATA_TYPE, BIT_WIDTH, MBUS_CODE, BPP,\t\\\n\t\t\t   FORMAT, FOURCC)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tTEGRA_IMAGE_DT_##DATA_TYPE,\t\t\t\t\t\\\n\tBIT_WIDTH,\t\t\t\t\t\t\t\\\n\tMEDIA_BUS_FMT_##MBUS_CODE,\t\t\t\t\t\\\n\tBPP,\t\t\t\t\t\t\t\t\\\n\tTEGRA210_IMAGE_FORMAT_##FORMAT,\t\t\t\t\t\\\n\tV4L2_PIX_FMT_##FOURCC,\t\t\t\t\t\t\\\n}\n\n \nstatic const struct tegra_video_format tegra210_video_formats[] = {\n\t \n\tTEGRA210_VIDEO_FMT(RAW8, 8, SRGGB8_1X8, 1, T_L8, SRGGB8),\n\tTEGRA210_VIDEO_FMT(RAW8, 8, SGRBG8_1X8, 1, T_L8, SGRBG8),\n\tTEGRA210_VIDEO_FMT(RAW8, 8, SGBRG8_1X8, 1, T_L8, SGBRG8),\n\tTEGRA210_VIDEO_FMT(RAW8, 8, SBGGR8_1X8, 1, T_L8, SBGGR8),\n\t \n\tTEGRA210_VIDEO_FMT(RAW10, 10, SRGGB10_1X10, 2, T_R16_I, SRGGB10),\n\tTEGRA210_VIDEO_FMT(RAW10, 10, SGRBG10_1X10, 2, T_R16_I, SGRBG10),\n\tTEGRA210_VIDEO_FMT(RAW10, 10, SGBRG10_1X10, 2, T_R16_I, SGBRG10),\n\tTEGRA210_VIDEO_FMT(RAW10, 10, SBGGR10_1X10, 2, T_R16_I, SBGGR10),\n\t \n\tTEGRA210_VIDEO_FMT(RAW12, 12, SRGGB12_1X12, 2, T_R16_I, SRGGB12),\n\tTEGRA210_VIDEO_FMT(RAW12, 12, SGRBG12_1X12, 2, T_R16_I, SGRBG12),\n\tTEGRA210_VIDEO_FMT(RAW12, 12, SGBRG12_1X12, 2, T_R16_I, SGBRG12),\n\tTEGRA210_VIDEO_FMT(RAW12, 12, SBGGR12_1X12, 2, T_R16_I, SBGGR12),\n\t \n\tTEGRA210_VIDEO_FMT(RGB888, 24, RGB888_1X24, 4, T_A8R8G8B8, XBGR32),\n\tTEGRA210_VIDEO_FMT(RGB888, 24, RGB888_1X32_PADHI, 4, T_A8B8G8R8,\n\t\t\t   RGBX32),\n\t \n\tTEGRA210_VIDEO_FMT(YUV422_8, 16, UYVY8_1X16, 2, T_U8_Y8__V8_Y8, YVYU),\n\tTEGRA210_VIDEO_FMT(YUV422_8, 16, VYUY8_1X16, 2, T_V8_Y8__U8_Y8, YUYV),\n\tTEGRA210_VIDEO_FMT(YUV422_8, 16, YUYV8_1X16, 2, T_Y8_U8__Y8_V8, VYUY),\n\tTEGRA210_VIDEO_FMT(YUV422_8, 16, YVYU8_1X16, 2, T_Y8_V8__Y8_U8, UYVY),\n\tTEGRA210_VIDEO_FMT(YUV422_8, 16, UYVY8_1X16, 1, T_Y8__V8U8_N422, NV16),\n\tTEGRA210_VIDEO_FMT(YUV422_8, 16, UYVY8_2X8, 2, T_U8_Y8__V8_Y8, YVYU),\n\tTEGRA210_VIDEO_FMT(YUV422_8, 16, VYUY8_2X8, 2, T_V8_Y8__U8_Y8, YUYV),\n\tTEGRA210_VIDEO_FMT(YUV422_8, 16, YUYV8_2X8, 2, T_Y8_U8__Y8_V8, VYUY),\n\tTEGRA210_VIDEO_FMT(YUV422_8, 16, YVYU8_2X8, 2, T_Y8_V8__Y8_U8, UYVY),\n};\n\n \nstatic const struct tegra_vi_ops tegra210_vi_ops = {\n\t.channel_host1x_syncpt_init = tegra210_channel_host1x_syncpt_init,\n\t.channel_host1x_syncpt_free = tegra210_channel_host1x_syncpt_free,\n\t.vi_fmt_align = tegra210_fmt_align,\n\t.vi_start_streaming = tegra210_vi_start_streaming,\n\t.vi_stop_streaming = tegra210_vi_stop_streaming,\n};\n\n \nconst struct tegra_vi_soc tegra210_vi_soc = {\n\t.video_formats = tegra210_video_formats,\n\t.nformats = ARRAY_SIZE(tegra210_video_formats),\n\t.ops = &tegra210_vi_ops,\n\t.hw_revision = 3,\n\t.vi_max_channels = 6,\n#if IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG)\n\t.default_video_format = &tegra210_video_formats[0],\n\t.vi_max_clk_hz = 499200000,\n#else\n\t.default_video_format = &tegra210_video_formats[4],\n\t.vi_max_clk_hz = 998400000,\n#endif\n};\n\n \nstatic void csi_write(struct tegra_csi *csi, u8 portno, unsigned int addr,\n\t\t      u32 val)\n{\n\tvoid __iomem *csi_pp_base;\n\n\tcsi_pp_base = csi->iomem + CSI_PP_OFFSET(portno >> 1);\n\n\twritel_relaxed(val, csi_pp_base + addr);\n}\n\n \nstatic void pp_write(struct tegra_csi *csi, u8 portno, u32 addr, u32 val)\n{\n\tvoid __iomem *csi_pp_base;\n\tunsigned int offset;\n\n\tcsi_pp_base = csi->iomem + CSI_PP_OFFSET(portno >> 1);\n\toffset = (portno % CSI_PORTS_PER_BRICK) * TEGRA210_CSI_PORT_OFFSET;\n\n\twritel_relaxed(val, csi_pp_base + offset + addr);\n}\n\nstatic u32 pp_read(struct tegra_csi *csi, u8 portno, u32 addr)\n{\n\tvoid __iomem *csi_pp_base;\n\tunsigned int offset;\n\n\tcsi_pp_base = csi->iomem + CSI_PP_OFFSET(portno >> 1);\n\toffset = (portno % CSI_PORTS_PER_BRICK) * TEGRA210_CSI_PORT_OFFSET;\n\n\treturn readl_relaxed(csi_pp_base + offset + addr);\n}\n\n \nstatic void cil_write(struct tegra_csi *csi, u8 portno, u32 addr, u32 val)\n{\n\tvoid __iomem *csi_cil_base;\n\tunsigned int offset;\n\n\tcsi_cil_base = csi->iomem + CSI_PP_OFFSET(portno >> 1) +\n\t\t       TEGRA210_CSI_CIL_OFFSET;\n\toffset = (portno % CSI_PORTS_PER_BRICK) * TEGRA210_CSI_PORT_OFFSET;\n\n\twritel_relaxed(val, csi_cil_base + offset + addr);\n}\n\nstatic u32 cil_read(struct tegra_csi *csi, u8 portno, u32 addr)\n{\n\tvoid __iomem *csi_cil_base;\n\tunsigned int offset;\n\n\tcsi_cil_base = csi->iomem + CSI_PP_OFFSET(portno >> 1) +\n\t\t       TEGRA210_CSI_CIL_OFFSET;\n\toffset = (portno % CSI_PORTS_PER_BRICK) * TEGRA210_CSI_PORT_OFFSET;\n\n\treturn readl_relaxed(csi_cil_base + offset + addr);\n}\n\n \nstatic void tpg_write(struct tegra_csi *csi, u8 portno, unsigned int addr,\n\t\t      u32 val)\n{\n\tvoid __iomem *csi_pp_base;\n\tunsigned int offset;\n\n\tcsi_pp_base = csi->iomem + CSI_PP_OFFSET(portno >> 1);\n\toffset = (portno % CSI_PORTS_PER_BRICK) * TEGRA210_CSI_PORT_OFFSET +\n\t\t TEGRA210_CSI_TPG_OFFSET;\n\n\twritel_relaxed(val, csi_pp_base + offset + addr);\n}\n\n \nstatic void tegra210_csi_port_recover(struct tegra_csi_channel *csi_chan,\n\t\t\t\t      u8 portno)\n{\n\tstruct tegra_csi *csi = csi_chan->csi;\n\tu32 val;\n\n\t \n\tval = pp_read(csi, portno, TEGRA_CSI_PIXEL_PARSER_STATUS);\n\tdev_dbg(csi->dev, \"TEGRA_CSI_PIXEL_PARSER_STATUS 0x%08x\\n\", val);\n\n\tval = cil_read(csi, portno, TEGRA_CSI_CIL_STATUS);\n\tdev_dbg(csi->dev, \"TEGRA_CSI_CIL_STATUS 0x%08x\\n\", val);\n\n\tval = cil_read(csi, portno, TEGRA_CSI_CILX_STATUS);\n\tdev_dbg(csi->dev, \"TEGRA_CSI_CILX_STATUS 0x%08x\\n\", val);\n\n\tif (csi_chan->numlanes == 4) {\n\t\t \n\t\tcil_write(csi, portno, TEGRA_CSI_CIL_SW_SENSOR_RESET, 0x1);\n\t\tcil_write(csi, portno + 1, TEGRA_CSI_CIL_SW_SENSOR_RESET, 0x1);\n\t\t \n\t\tcsi_write(csi, portno, TEGRA_CSI_CSI_SW_STATUS_RESET, 0x1);\n\n\t\t \n\t\tusleep_range(10, 20);\n\n\t\tcil_write(csi, portno + 1, TEGRA_CSI_CIL_SW_SENSOR_RESET, 0x0);\n\t\tcil_write(csi, portno, TEGRA_CSI_CIL_SW_SENSOR_RESET, 0x0);\n\t\tcsi_write(csi, portno, TEGRA_CSI_CSI_SW_STATUS_RESET, 0x0);\n\t} else {\n\t\t \n\t\tcil_write(csi, portno, TEGRA_CSI_CIL_SW_SENSOR_RESET, 0x1);\n\t\tusleep_range(10, 20);\n\t\tcil_write(csi, portno, TEGRA_CSI_CIL_SW_SENSOR_RESET, 0x0);\n\n\t\t \n\t\tpp_write(csi, portno, TEGRA_CSI_PIXEL_PARSER_STATUS,\n\t\t\t 0xffffffff);\n\t\tcil_write(csi, portno, TEGRA_CSI_CIL_STATUS, 0xffffffff);\n\t\tcil_write(csi, portno, TEGRA_CSI_CILX_STATUS, 0xffffffff);\n\t}\n}\n\nstatic void tegra210_csi_error_recover(struct tegra_csi_channel *csi_chan)\n{\n\tu8 *portnos = csi_chan->csi_port_nums;\n\tint i;\n\n\tfor (i = 0; i < csi_chan->numgangports; i++)\n\t\ttegra210_csi_port_recover(csi_chan, portnos[i]);\n}\n\nstatic int\ntegra210_csi_port_start_streaming(struct tegra_csi_channel *csi_chan,\n\t\t\t\t  u8 portno)\n{\n\tstruct tegra_csi *csi = csi_chan->csi;\n\tu8 clk_settle_time = 0;\n\tu8 ths_settle_time = 10;\n\tu32 val;\n\n\tif (!csi_chan->pg_mode)\n\t\ttegra_csi_calc_settle_time(csi_chan, portno, &clk_settle_time,\n\t\t\t\t\t   &ths_settle_time);\n\n\tcsi_write(csi, portno, TEGRA_CSI_CLKEN_OVERRIDE, 0);\n\n\t \n\tpp_write(csi, portno, TEGRA_CSI_PIXEL_PARSER_STATUS, 0xffffffff);\n\tcil_write(csi, portno, TEGRA_CSI_CIL_STATUS, 0xffffffff);\n\tcil_write(csi, portno, TEGRA_CSI_CILX_STATUS, 0xffffffff);\n\tcil_write(csi, portno, TEGRA_CSI_CIL_INTERRUPT_MASK, 0x0);\n\n\t \n\tcil_write(csi, portno, TEGRA_CSI_CIL_PAD_CONFIG0, 0x0);\n\tcil_write(csi, portno, TEGRA_CSI_CIL_PHY_CONTROL,\n\t\t  FIELD_PREP(CLK_SETTLE_MASK, clk_settle_time) |\n\t\t  FIELD_PREP(THS_SETTLE_MASK, ths_settle_time));\n\n\t \n\tif (csi_chan->numlanes == 4) {\n\t\tcil_write(csi, portno + 1, TEGRA_CSI_CIL_STATUS, 0xffffffff);\n\t\tcil_write(csi, portno + 1, TEGRA_CSI_CILX_STATUS, 0xffffffff);\n\t\tcil_write(csi, portno + 1, TEGRA_CSI_CIL_INTERRUPT_MASK, 0x0);\n\n\t\tcil_write(csi, portno, TEGRA_CSI_CIL_PAD_CONFIG0,\n\t\t\t  BRICK_CLOCK_A_4X);\n\t\tcil_write(csi, portno + 1, TEGRA_CSI_CIL_PAD_CONFIG0, 0x0);\n\t\tcil_write(csi, portno + 1, TEGRA_CSI_CIL_INTERRUPT_MASK, 0x0);\n\t\tcil_write(csi, portno + 1, TEGRA_CSI_CIL_PHY_CONTROL,\n\t\t\t  FIELD_PREP(CLK_SETTLE_MASK, clk_settle_time) |\n\t\t\t  FIELD_PREP(THS_SETTLE_MASK, ths_settle_time));\n\t\tcsi_write(csi, portno, TEGRA_CSI_PHY_CIL_COMMAND,\n\t\t\t  CSI_A_PHY_CIL_ENABLE | CSI_B_PHY_CIL_ENABLE);\n\t} else {\n\t\tval = ((portno & 1) == PORT_A) ?\n\t\t      CSI_A_PHY_CIL_ENABLE | CSI_B_PHY_CIL_NOP :\n\t\t      CSI_B_PHY_CIL_ENABLE | CSI_A_PHY_CIL_NOP;\n\t\tcsi_write(csi, portno, TEGRA_CSI_PHY_CIL_COMMAND, val);\n\t}\n\n\t \n\tpp_write(csi, portno, TEGRA_CSI_PIXEL_STREAM_PP_COMMAND,\n\t\t (0xf << CSI_PP_START_MARKER_FRAME_MAX_OFFSET) |\n\t\t CSI_PP_SINGLE_SHOT_ENABLE | CSI_PP_RST);\n\tpp_write(csi, portno, TEGRA_CSI_PIXEL_PARSER_INTERRUPT_MASK, 0x0);\n\tpp_write(csi, portno, TEGRA_CSI_PIXEL_STREAM_CONTROL0,\n\t\t CSI_PP_PACKET_HEADER_SENT |\n\t\t CSI_PP_DATA_IDENTIFIER_ENABLE |\n\t\t CSI_PP_WORD_COUNT_SELECT_HEADER |\n\t\t CSI_PP_CRC_CHECK_ENABLE |  CSI_PP_WC_CHECK |\n\t\t CSI_PP_OUTPUT_FORMAT_STORE | CSI_PPA_PAD_LINE_NOPAD |\n\t\t CSI_PP_HEADER_EC_DISABLE | CSI_PPA_PAD_FRAME_NOPAD |\n\t\t (portno & 1));\n\tpp_write(csi, portno, TEGRA_CSI_PIXEL_STREAM_CONTROL1,\n\t\t (0x1 << CSI_PP_TOP_FIELD_FRAME_OFFSET) |\n\t\t (0x1 << CSI_PP_TOP_FIELD_FRAME_MASK_OFFSET));\n\tpp_write(csi, portno, TEGRA_CSI_PIXEL_STREAM_GAP,\n\t\t 0x14 << PP_FRAME_MIN_GAP_OFFSET);\n\tpp_write(csi, portno, TEGRA_CSI_PIXEL_STREAM_EXPECTED_FRAME, 0x0);\n\tpp_write(csi, portno, TEGRA_CSI_INPUT_STREAM_CONTROL,\n\t\t (0x3f << CSI_SKIP_PACKET_THRESHOLD_OFFSET) |\n\t\t (csi_chan->numlanes - 1));\n\n\t \n\tif (csi_chan->pg_mode) {\n\t\ttpg_write(csi, portno, TEGRA_CSI_PATTERN_GENERATOR_CTRL,\n\t\t\t  ((csi_chan->pg_mode - 1) << PG_MODE_OFFSET) |\n\t\t\t  PG_ENABLE);\n\t\ttpg_write(csi, portno, TEGRA_CSI_PG_BLANK,\n\t\t\t  csi_chan->v_blank << PG_VBLANK_OFFSET |\n\t\t\t  csi_chan->h_blank);\n\t\ttpg_write(csi, portno, TEGRA_CSI_PG_PHASE, 0x0);\n\t\ttpg_write(csi, portno, TEGRA_CSI_PG_RED_FREQ,\n\t\t\t  (0x10 << PG_RED_VERT_INIT_FREQ_OFFSET) |\n\t\t\t  (0x10 << PG_RED_HOR_INIT_FREQ_OFFSET));\n\t\ttpg_write(csi, portno, TEGRA_CSI_PG_RED_FREQ_RATE, 0x0);\n\t\ttpg_write(csi, portno, TEGRA_CSI_PG_GREEN_FREQ,\n\t\t\t  (0x10 << PG_GREEN_VERT_INIT_FREQ_OFFSET) |\n\t\t\t  (0x10 << PG_GREEN_HOR_INIT_FREQ_OFFSET));\n\t\ttpg_write(csi, portno, TEGRA_CSI_PG_GREEN_FREQ_RATE, 0x0);\n\t\ttpg_write(csi, portno, TEGRA_CSI_PG_BLUE_FREQ,\n\t\t\t  (0x10 << PG_BLUE_VERT_INIT_FREQ_OFFSET) |\n\t\t\t  (0x10 << PG_BLUE_HOR_INIT_FREQ_OFFSET));\n\t\ttpg_write(csi, portno, TEGRA_CSI_PG_BLUE_FREQ_RATE, 0x0);\n\t}\n\n\tpp_write(csi, portno, TEGRA_CSI_PIXEL_STREAM_PP_COMMAND,\n\t\t (0xf << CSI_PP_START_MARKER_FRAME_MAX_OFFSET) |\n\t\t CSI_PP_SINGLE_SHOT_ENABLE | CSI_PP_ENABLE);\n\n\treturn 0;\n}\n\nstatic void\ntegra210_csi_port_stop_streaming(struct tegra_csi_channel *csi_chan, u8 portno)\n{\n\tstruct tegra_csi *csi = csi_chan->csi;\n\tu32 val;\n\n\tval = pp_read(csi, portno, TEGRA_CSI_PIXEL_PARSER_STATUS);\n\n\tdev_dbg(csi->dev, \"TEGRA_CSI_PIXEL_PARSER_STATUS 0x%08x\\n\", val);\n\tpp_write(csi, portno, TEGRA_CSI_PIXEL_PARSER_STATUS, val);\n\n\tval = cil_read(csi, portno, TEGRA_CSI_CIL_STATUS);\n\tdev_dbg(csi->dev, \"TEGRA_CSI_CIL_STATUS 0x%08x\\n\", val);\n\tcil_write(csi, portno, TEGRA_CSI_CIL_STATUS, val);\n\n\tval = cil_read(csi, portno, TEGRA_CSI_CILX_STATUS);\n\tdev_dbg(csi->dev, \"TEGRA_CSI_CILX_STATUS 0x%08x\\n\", val);\n\tcil_write(csi, portno, TEGRA_CSI_CILX_STATUS, val);\n\n\tpp_write(csi, portno, TEGRA_CSI_PIXEL_STREAM_PP_COMMAND,\n\t\t (0xf << CSI_PP_START_MARKER_FRAME_MAX_OFFSET) |\n\t\t CSI_PP_DISABLE);\n\n\tif (csi_chan->pg_mode) {\n\t\ttpg_write(csi, portno, TEGRA_CSI_PATTERN_GENERATOR_CTRL,\n\t\t\t  PG_DISABLE);\n\t\treturn;\n\t}\n\n\tif (csi_chan->numlanes == 4) {\n\t\tcsi_write(csi, portno, TEGRA_CSI_PHY_CIL_COMMAND,\n\t\t\t  CSI_A_PHY_CIL_DISABLE |\n\t\t\t  CSI_B_PHY_CIL_DISABLE);\n\t} else {\n\t\tval = ((portno & 1) == PORT_A) ?\n\t\t      CSI_A_PHY_CIL_DISABLE | CSI_B_PHY_CIL_NOP :\n\t\t      CSI_B_PHY_CIL_DISABLE | CSI_A_PHY_CIL_NOP;\n\t\tcsi_write(csi, portno, TEGRA_CSI_PHY_CIL_COMMAND, val);\n\t}\n}\n\nstatic int tegra210_csi_start_streaming(struct tegra_csi_channel *csi_chan)\n{\n\tu8 *portnos = csi_chan->csi_port_nums;\n\tint ret, i;\n\n\tfor (i = 0; i < csi_chan->numgangports; i++) {\n\t\tret = tegra210_csi_port_start_streaming(csi_chan, portnos[i]);\n\t\tif (ret)\n\t\t\tgoto stream_start_fail;\n\t}\n\n\treturn 0;\n\nstream_start_fail:\n\tfor (i = i - 1; i >= 0; i--)\n\t\ttegra210_csi_port_stop_streaming(csi_chan, portnos[i]);\n\n\treturn ret;\n}\n\nstatic void tegra210_csi_stop_streaming(struct tegra_csi_channel *csi_chan)\n{\n\tu8 *portnos = csi_chan->csi_port_nums;\n\tint i;\n\n\tfor (i = 0; i < csi_chan->numgangports; i++)\n\t\ttegra210_csi_port_stop_streaming(csi_chan, portnos[i]);\n}\n\n \nstatic const struct tpg_framerate tegra210_tpg_frmrate_table[] = {\n\t{\n\t\t.frmsize = { 1280, 720 },\n\t\t.code = MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.framerate = 120,\n\t\t.h_blank = 512,\n\t\t.v_blank = 8,\n\t},\n\t{\n\t\t.frmsize = { 1920, 1080 },\n\t\t.code = MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.framerate = 60,\n\t\t.h_blank = 512,\n\t\t.v_blank = 8,\n\t},\n\t{\n\t\t.frmsize = { 3840, 2160 },\n\t\t.code = MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.framerate = 20,\n\t\t.h_blank = 8,\n\t\t.v_blank = 8,\n\t},\n\t{\n\t\t.frmsize = { 1280, 720 },\n\t\t.code = MEDIA_BUS_FMT_RGB888_1X32_PADHI,\n\t\t.framerate = 60,\n\t\t.h_blank = 512,\n\t\t.v_blank = 8,\n\t},\n\t{\n\t\t.frmsize = { 1920, 1080 },\n\t\t.code = MEDIA_BUS_FMT_RGB888_1X32_PADHI,\n\t\t.framerate = 30,\n\t\t.h_blank = 512,\n\t\t.v_blank = 8,\n\t},\n\t{\n\t\t.frmsize = { 3840, 2160 },\n\t\t.code = MEDIA_BUS_FMT_RGB888_1X32_PADHI,\n\t\t.framerate = 8,\n\t\t.h_blank = 8,\n\t\t.v_blank = 8,\n\t},\n};\n\nstatic const char * const tegra210_csi_cil_clks[] = {\n\t\"csi\",\n\t\"cilab\",\n\t\"cilcd\",\n\t\"cile\",\n#if IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG)\n\t\"csi_tpg\",\n#endif\n};\n\n \nstatic const struct tegra_csi_ops tegra210_csi_ops = {\n\t.csi_start_streaming = tegra210_csi_start_streaming,\n\t.csi_stop_streaming = tegra210_csi_stop_streaming,\n\t.csi_err_recover = tegra210_csi_error_recover,\n};\n\n \nconst struct tegra_csi_soc tegra210_csi_soc = {\n\t.ops = &tegra210_csi_ops,\n\t.csi_max_channels = 6,\n\t.clk_names = tegra210_csi_cil_clks,\n\t.num_clks = ARRAY_SIZE(tegra210_csi_cil_clks),\n\t.tpg_frmrate_table = tegra210_tpg_frmrate_table,\n\t.tpg_frmrate_table_size = ARRAY_SIZE(tegra210_tpg_frmrate_table),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}