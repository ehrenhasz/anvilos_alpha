{
  "module_name": "vip.c",
  "hash_id": "49ab01f14950ac129ed9ab7db49f92a784fccda799e704ac6204ef738eb4752c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/tegra-video/vip.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/host1x.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <media/v4l2-fwnode.h>\n\n#include \"vip.h\"\n#include \"video.h\"\n\nstatic inline struct tegra_vip *host1x_client_to_vip(struct host1x_client *client)\n{\n\treturn container_of(client, struct tegra_vip, client);\n}\n\nstatic inline struct tegra_vip_channel *subdev_to_vip_channel(struct v4l2_subdev *subdev)\n{\n\treturn container_of(subdev, struct tegra_vip_channel, subdev);\n}\n\nstatic inline struct tegra_vip *vip_channel_to_vip(struct tegra_vip_channel *chan)\n{\n\treturn container_of(chan, struct tegra_vip, chan);\n}\n\n \nstatic struct v4l2_subdev *tegra_vip_channel_get_prev_subdev(struct tegra_vip_channel *chan)\n{\n\tstruct media_pad *remote_pad;\n\n\tremote_pad = media_pad_remote_pad_first(&chan->pads[TEGRA_VIP_PAD_SINK]);\n\tif (!remote_pad)\n\t\treturn NULL;\n\n\treturn media_entity_to_v4l2_subdev(remote_pad->entity);\n}\n\nstatic int tegra_vip_enable_stream(struct v4l2_subdev *subdev)\n{\n\tstruct tegra_vip_channel *vip_chan = subdev_to_vip_channel(subdev);\n\tstruct tegra_vip *vip = vip_channel_to_vip(vip_chan);\n\tstruct v4l2_subdev *prev_subdev = tegra_vip_channel_get_prev_subdev(vip_chan);\n\tint err;\n\n\terr = pm_runtime_resume_and_get(vip->dev);\n\tif (err)\n\t\treturn dev_err_probe(vip->dev, err, \"failed to get runtime PM\\n\");\n\n\terr = vip->soc->ops->vip_start_streaming(vip_chan);\n\tif (err < 0)\n\t\tgoto err_start_streaming;\n\n\terr = v4l2_subdev_call(prev_subdev, video, s_stream, true);\n\tif (err < 0 && err != -ENOIOCTLCMD)\n\t\tgoto err_prev_subdev_start_stream;\n\n\treturn 0;\n\nerr_prev_subdev_start_stream:\nerr_start_streaming:\n\tpm_runtime_put(vip->dev);\n\treturn err;\n}\n\nstatic int tegra_vip_disable_stream(struct v4l2_subdev *subdev)\n{\n\tstruct tegra_vip_channel *vip_chan = subdev_to_vip_channel(subdev);\n\tstruct tegra_vip *vip = vip_channel_to_vip(vip_chan);\n\tstruct v4l2_subdev *prev_subdev = tegra_vip_channel_get_prev_subdev(vip_chan);\n\n\tv4l2_subdev_call(prev_subdev, video, s_stream, false);\n\n\tpm_runtime_put(vip->dev);\n\n\treturn 0;\n}\n\nstatic int tegra_vip_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tint err;\n\n\tif (enable)\n\t\terr = tegra_vip_enable_stream(subdev);\n\telse\n\t\terr = tegra_vip_disable_stream(subdev);\n\n\treturn err;\n}\n\nstatic const struct v4l2_subdev_video_ops tegra_vip_video_ops = {\n\t.s_stream = tegra_vip_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops tegra_vip_ops = {\n\t.video  = &tegra_vip_video_ops,\n};\n\nstatic int tegra_vip_channel_of_parse(struct tegra_vip *vip)\n{\n\tstruct device *dev = vip->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct v4l2_fwnode_endpoint v4l2_ep = {\n\t\t.bus_type = V4L2_MBUS_PARALLEL\n\t};\n\tstruct fwnode_handle *fwh;\n\tstruct device_node *ep;\n\tunsigned int num_pads;\n\tint err;\n\n\tdev_dbg(dev, \"Parsing %pOF\", np);\n\n\tep = of_graph_get_endpoint_by_regs(np, 0, 0);\n\tif (!ep) {\n\t\terr = -EINVAL;\n\t\tdev_err_probe(dev, err, \"%pOF: error getting endpoint node\\n\", np);\n\t\tgoto err_node_put;\n\t}\n\n\tfwh = of_fwnode_handle(ep);\n\terr = v4l2_fwnode_endpoint_parse(fwh, &v4l2_ep);\n\tof_node_put(ep);\n\tif (err) {\n\t\tdev_err_probe(dev, err, \"%pOF: failed to parse v4l2 endpoint\\n\", np);\n\t\tgoto err_node_put;\n\t}\n\n\tnum_pads = of_graph_get_endpoint_count(np);\n\tif (num_pads != TEGRA_VIP_PADS_NUM) {\n\t\terr = -EINVAL;\n\t\tdev_err_probe(dev, err, \"%pOF: need 2 pads, got %d\\n\", np, num_pads);\n\t\tgoto err_node_put;\n\t}\n\n\tvip->chan.of_node = of_node_get(np);\n\tvip->chan.pads[TEGRA_VIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tvip->chan.pads[TEGRA_VIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\n\treturn 0;\n\nerr_node_put:\n\tof_node_put(np);\n\treturn err;\n}\n\nstatic int tegra_vip_channel_init(struct tegra_vip *vip)\n{\n\tstruct v4l2_subdev *subdev;\n\tint err;\n\n\tsubdev = &vip->chan.subdev;\n\tv4l2_subdev_init(subdev, &tegra_vip_ops);\n\tsubdev->dev = vip->dev;\n\tsnprintf(subdev->name, V4L2_SUBDEV_NAME_SIZE, \"%s\",\n\t\t kbasename(vip->chan.of_node->full_name));\n\n\tv4l2_set_subdevdata(subdev, &vip->chan);\n\tsubdev->fwnode = of_fwnode_handle(vip->chan.of_node);\n\tsubdev->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\n\terr = media_entity_pads_init(&subdev->entity, TEGRA_VIP_PADS_NUM, vip->chan.pads);\n\tif (err)\n\t\treturn dev_err_probe(vip->dev, err, \"failed to initialize media entity\\n\");\n\n\terr = v4l2_async_register_subdev(subdev);\n\tif (err) {\n\t\tdev_err_probe(vip->dev, err, \"failed to register subdev\\n\");\n\t\tgoto err_register_subdev;\n\t}\n\n\treturn 0;\n\nerr_register_subdev:\n\tmedia_entity_cleanup(&subdev->entity);\n\treturn err;\n}\n\nstatic int tegra_vip_init(struct host1x_client *client)\n{\n\tstruct tegra_vip *vip = host1x_client_to_vip(client);\n\tint err;\n\n\terr = tegra_vip_channel_of_parse(vip);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_vip_channel_init(vip);\n\tif (err)\n\t\tgoto err_init;\n\n\treturn 0;\n\nerr_init:\n\tof_node_put(vip->chan.of_node);\n\treturn err;\n}\n\nstatic int tegra_vip_exit(struct host1x_client *client)\n{\n\tstruct tegra_vip *vip = host1x_client_to_vip(client);\n\tstruct v4l2_subdev *subdev = &vip->chan.subdev;\n\n\tv4l2_async_unregister_subdev(subdev);\n\tmedia_entity_cleanup(&subdev->entity);\n\tof_node_put(vip->chan.of_node);\n\n\treturn 0;\n}\n\nstatic const struct host1x_client_ops vip_client_ops = {\n\t.init = tegra_vip_init,\n\t.exit = tegra_vip_exit,\n};\n\nstatic int tegra_vip_probe(struct platform_device *pdev)\n{\n\tstruct tegra_vip *vip;\n\tint err;\n\n\tdev_dbg(&pdev->dev, \"Probing VIP \\\"%s\\\" from %pOF\\n\", pdev->name, pdev->dev.of_node);\n\n\tvip = devm_kzalloc(&pdev->dev, sizeof(*vip), GFP_KERNEL);\n\tif (!vip)\n\t\treturn -ENOMEM;\n\n\tvip->soc = of_device_get_match_data(&pdev->dev);\n\n\tvip->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, vip);\n\n\t \n\tINIT_LIST_HEAD(&vip->client.list);\n\tvip->client.ops = &vip_client_ops;\n\tvip->client.dev = &pdev->dev;\n\n\terr = host1x_client_register(&vip->client);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err, \"failed to register host1x client\\n\");\n\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic int tegra_vip_remove(struct platform_device *pdev)\n{\n\tstruct tegra_vip *vip = platform_get_drvdata(pdev);\n\n\thost1x_client_unregister(&vip->client);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\n#if defined(CONFIG_ARCH_TEGRA_2x_SOC)\nextern const struct tegra_vip_soc tegra20_vip_soc;\n#endif\n\nstatic const struct of_device_id tegra_vip_of_id_table[] = {\n#if defined(CONFIG_ARCH_TEGRA_2x_SOC)\n\t{ .compatible = \"nvidia,tegra20-vip\", .data = &tegra20_vip_soc },\n#endif\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_vip_of_id_table);\n\nstruct platform_driver tegra_vip_driver = {\n\t.driver = {\n\t\t.name\t\t= \"tegra-vip\",\n\t\t.of_match_table\t= tegra_vip_of_id_table,\n\t},\n\t.probe\t\t\t= tegra_vip_probe,\n\t.remove\t\t\t= tegra_vip_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}