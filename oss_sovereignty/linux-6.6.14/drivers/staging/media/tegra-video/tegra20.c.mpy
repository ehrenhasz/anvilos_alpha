{
  "module_name": "tegra20.c",
  "hash_id": "be13d0b34a354f7eb4a5c978d0362982b1757728b15486fd33fa9f313d71658c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/tegra-video/tegra20.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/host1x.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/v4l2-mediabus.h>\n\n#include \"vip.h\"\n#include \"vi.h\"\n\n#define TEGRA_VI_SYNCPT_WAIT_TIMEOUT\t\t\tmsecs_to_jiffies(200)\n\n \n#define TEGRA20_MIN_WIDTH\t32U\n#define TEGRA20_MIN_HEIGHT\t32U\n#define TEGRA20_MAX_WIDTH\t2048U\n#define TEGRA20_MAX_HEIGHT\t2048U\n\n \n\n#define TEGRA_VI_CONT_SYNCPT_OUT_1\t\t\t0x0060\n#define       VI_CONT_SYNCPT_OUT_1_CONTINUOUS_SYNCPT\tBIT(8)\n#define       VI_CONT_SYNCPT_OUT_1_SYNCPT_IDX_SFT\t0\n\n#define TEGRA_VI_VI_INPUT_CONTROL\t\t\t0x0088\n#define       VI_INPUT_FIELD_DETECT\t\t\tBIT(27)\n#define       VI_INPUT_BT656\t\t\t\tBIT(25)\n#define       VI_INPUT_YUV_INPUT_FORMAT_SFT\t\t8   \n#define       VI_INPUT_YUV_INPUT_FORMAT_UYVY\t\t(0 << VI_INPUT_YUV_INPUT_FORMAT_SFT)\n#define       VI_INPUT_YUV_INPUT_FORMAT_VYUY\t\t(1 << VI_INPUT_YUV_INPUT_FORMAT_SFT)\n#define       VI_INPUT_YUV_INPUT_FORMAT_YUYV\t\t(2 << VI_INPUT_YUV_INPUT_FORMAT_SFT)\n#define       VI_INPUT_YUV_INPUT_FORMAT_YVYU\t\t(3 << VI_INPUT_YUV_INPUT_FORMAT_SFT)\n#define       VI_INPUT_INPUT_FORMAT_SFT\t\t\t2   \n#define       VI_INPUT_INPUT_FORMAT_YUV422\t\t(0 << VI_INPUT_INPUT_FORMAT_SFT)\n#define       VI_INPUT_VIP_INPUT_ENABLE\t\t\tBIT(1)\n\n#define TEGRA_VI_VI_CORE_CONTROL\t\t\t0x008c\n#define       VI_VI_CORE_CONTROL_PLANAR_CONV_IN_SEL_EXT\tBIT(31)\n#define       VI_VI_CORE_CONTROL_CSC_INPUT_SEL_EXT\tBIT(30)\n#define       VI_VI_CORE_CONTROL_INPUT_TO_ALT_MUX_SFT\t27\n#define       VI_VI_CORE_CONTROL_INPUT_TO_CORE_EXT_SFT\t24\n#define       VI_VI_CORE_CONTROL_OUTPUT_TO_ISP_EXT_SFT\t21\n#define       VI_VI_CORE_CONTROL_ISP_HOST_STALL_OFF\tBIT(20)\n#define       VI_VI_CORE_CONTROL_V_DOWNSCALING\t\tBIT(19)\n#define       VI_VI_CORE_CONTROL_V_AVERAGING\t\tBIT(18)\n#define       VI_VI_CORE_CONTROL_H_DOWNSCALING\t\tBIT(17)\n#define       VI_VI_CORE_CONTROL_H_AVERAGING\t\tBIT(16)\n#define       VI_VI_CORE_CONTROL_CSC_INPUT_SEL\t\tBIT(11)\n#define       VI_VI_CORE_CONTROL_PLANAR_CONV_INPUT_SEL\tBIT(10)\n#define       VI_VI_CORE_CONTROL_INPUT_TO_CORE_SFT\t8\n#define       VI_VI_CORE_CONTROL_ISP_DOWNSAMPLE_SFT\t5\n#define       VI_VI_CORE_CONTROL_OUTPUT_TO_EPP_SFT\t2\n#define       VI_VI_CORE_CONTROL_OUTPUT_TO_ISP_SFT\t0\n\n#define TEGRA_VI_VI_FIRST_OUTPUT_CONTROL\t\t0x0090\n#define       VI_OUTPUT_FORMAT_EXT\t\t\tBIT(22)\n#define       VI_OUTPUT_V_DIRECTION\t\t\tBIT(20)\n#define       VI_OUTPUT_H_DIRECTION\t\t\tBIT(19)\n#define       VI_OUTPUT_YUV_OUTPUT_FORMAT_SFT\t\t17\n#define       VI_OUTPUT_YUV_OUTPUT_FORMAT_UYVY\t\t(0 << VI_OUTPUT_YUV_OUTPUT_FORMAT_SFT)\n#define       VI_OUTPUT_YUV_OUTPUT_FORMAT_VYUY\t\t(1 << VI_OUTPUT_YUV_OUTPUT_FORMAT_SFT)\n#define       VI_OUTPUT_YUV_OUTPUT_FORMAT_YUYV\t\t(2 << VI_OUTPUT_YUV_OUTPUT_FORMAT_SFT)\n#define       VI_OUTPUT_YUV_OUTPUT_FORMAT_YVYU\t\t(3 << VI_OUTPUT_YUV_OUTPUT_FORMAT_SFT)\n#define       VI_OUTPUT_OUTPUT_BYTE_SWAP\t\tBIT(16)\n#define       VI_OUTPUT_LAST_PIXEL_DUPLICATION\t\tBIT(8)\n#define       VI_OUTPUT_OUTPUT_FORMAT_SFT\t\t0\n#define       VI_OUTPUT_OUTPUT_FORMAT_YUV422POST\t(3 << VI_OUTPUT_OUTPUT_FORMAT_SFT)\n#define       VI_OUTPUT_OUTPUT_FORMAT_YUV420PLANAR\t(6 << VI_OUTPUT_OUTPUT_FORMAT_SFT)\n\n#define TEGRA_VI_VIP_H_ACTIVE\t\t\t\t0x00a4\n#define       VI_VIP_H_ACTIVE_PERIOD_SFT\t\t16  \n#define       VI_VIP_H_ACTIVE_START_SFT\t\t\t0\n\n#define TEGRA_VI_VIP_V_ACTIVE\t\t\t\t0x00a8\n#define       VI_VIP_V_ACTIVE_PERIOD_SFT\t\t16  \n#define       VI_VIP_V_ACTIVE_START_SFT\t\t\t0\n\n#define TEGRA_VI_VB0_START_ADDRESS_FIRST\t\t0x00c4\n#define TEGRA_VI_VB0_BASE_ADDRESS_FIRST\t\t\t0x00c8\n#define TEGRA_VI_VB0_START_ADDRESS_U\t\t\t0x00cc\n#define TEGRA_VI_VB0_BASE_ADDRESS_U\t\t\t0x00d0\n#define TEGRA_VI_VB0_START_ADDRESS_V\t\t\t0x00d4\n#define TEGRA_VI_VB0_BASE_ADDRESS_V\t\t\t0x00d8\n\n#define TEGRA_VI_FIRST_OUTPUT_FRAME_SIZE\t\t0x00e0\n#define       VI_FIRST_OUTPUT_FRAME_HEIGHT_SFT\t\t16\n#define       VI_FIRST_OUTPUT_FRAME_WIDTH_SFT\t\t0\n\n#define TEGRA_VI_VB0_COUNT_FIRST\t\t\t0x00e4\n\n#define TEGRA_VI_VB0_SIZE_FIRST\t\t\t\t0x00e8\n#define       VI_VB0_SIZE_FIRST_V_SFT\t\t\t16\n#define       VI_VB0_SIZE_FIRST_H_SFT\t\t\t0\n\n#define TEGRA_VI_VB0_BUFFER_STRIDE_FIRST\t\t0x00ec\n#define       VI_VB0_BUFFER_STRIDE_FIRST_CHROMA_SFT\t30\n#define       VI_VB0_BUFFER_STRIDE_FIRST_LUMA_SFT\t0\n\n#define TEGRA_VI_H_LPF_CONTROL\t\t\t\t0x0108\n#define       VI_H_LPF_CONTROL_CHROMA_SFT\t\t16\n#define       VI_H_LPF_CONTROL_LUMA_SFT\t\t\t0\n\n#define TEGRA_VI_H_DOWNSCALE_CONTROL\t\t\t0x010c\n#define TEGRA_VI_V_DOWNSCALE_CONTROL\t\t\t0x0110\n\n#define TEGRA_VI_VIP_INPUT_STATUS\t\t\t0x0144\n\n#define TEGRA_VI_VI_DATA_INPUT_CONTROL\t\t\t0x0168\n#define       VI_DATA_INPUT_SFT\t\t\t\t0  \n\n#define TEGRA_VI_PIN_INPUT_ENABLE\t\t\t0x016c\n#define       VI_PIN_INPUT_VSYNC\t\t\tBIT(14)\n#define       VI_PIN_INPUT_HSYNC\t\t\tBIT(13)\n#define       VI_PIN_INPUT_VD_SFT\t\t\t0  \n\n#define TEGRA_VI_PIN_INVERSION\t\t\t\t0x0174\n#define       VI_PIN_INVERSION_VSYNC_ACTIVE_HIGH\tBIT(1)\n#define       VI_PIN_INVERSION_HSYNC_ACTIVE_HIGH\tBIT(0)\n\n#define TEGRA_VI_CAMERA_CONTROL\t\t\t\t0x01a0\n#define       VI_CAMERA_CONTROL_STOP_CAPTURE\t\tBIT(2)\n#define       VI_CAMERA_CONTROL_TEST_MODE\t\tBIT(1)\n#define       VI_CAMERA_CONTROL_VIP_ENABLE\t\tBIT(0)\n\n#define TEGRA_VI_VI_ENABLE\t\t\t\t0x01a4\n#define       VI_VI_ENABLE_SW_FLOW_CONTROL_OUT1\t\tBIT(1)\n#define       VI_VI_ENABLE_FIRST_OUTPUT_TO_MEM_DISABLE\tBIT(0)\n\n#define TEGRA_VI_VI_RAISE\t\t\t\t0x01ac\n#define       VI_VI_RAISE_ON_EDGE\t\t\tBIT(0)\n\n \n\nstatic void tegra20_vi_write(struct tegra_vi_channel *chan, unsigned int addr, u32 val)\n{\n\twritel(val, chan->vi->iomem + addr);\n}\n\n \nstatic void tegra20_vi_get_input_formats(struct tegra_vi_channel *chan,\n\t\t\t\t\t unsigned int *main_input_format,\n\t\t\t\t\t unsigned int *yuv_input_format)\n{\n\tunsigned int input_mbus_code = chan->fmtinfo->code;\n\n\t(*main_input_format) = VI_INPUT_INPUT_FORMAT_YUV422;\n\n\tswitch (input_mbus_code) {\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\t(*yuv_input_format) = VI_INPUT_YUV_INPUT_FORMAT_UYVY;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\t\t(*yuv_input_format) = VI_INPUT_YUV_INPUT_FORMAT_VYUY;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\t\t(*yuv_input_format) = VI_INPUT_YUV_INPUT_FORMAT_YUYV;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\t\t(*yuv_input_format) = VI_INPUT_YUV_INPUT_FORMAT_YVYU;\n\t\tbreak;\n\t}\n}\n\n \nstatic void tegra20_vi_get_output_formats(struct tegra_vi_channel *chan,\n\t\t\t\t\t  unsigned int *main_output_format,\n\t\t\t\t\t  unsigned int *yuv_output_format)\n{\n\tu32 output_fourcc = chan->format.pixelformat;\n\n\t \n\t(*main_output_format) = VI_OUTPUT_OUTPUT_FORMAT_YUV422POST;\n\t(*yuv_output_format) = VI_OUTPUT_YUV_OUTPUT_FORMAT_UYVY;\n\n\tswitch (output_fourcc) {\n\tcase V4L2_PIX_FMT_UYVY:\n\t\t(*yuv_output_format) = VI_OUTPUT_YUV_OUTPUT_FORMAT_UYVY;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VYUY:\n\t\t(*yuv_output_format) = VI_OUTPUT_YUV_OUTPUT_FORMAT_VYUY;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\t\t(*yuv_output_format) = VI_OUTPUT_YUV_OUTPUT_FORMAT_YUYV;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YVYU:\n\t\t(*yuv_output_format) = VI_OUTPUT_YUV_OUTPUT_FORMAT_YVYU;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\t\t(*main_output_format) = VI_OUTPUT_OUTPUT_FORMAT_YUV420PLANAR;\n\t\tbreak;\n\t}\n}\n\n \nstatic int tegra20_vi_enable(struct tegra_vi *vi, bool on)\n{\n\t \n\tconst phys_addr_t TEGRA_APB_MISC_BASE = 0x70000000;\n\tconst unsigned long reg_offset = 0x42c;\n\tvoid __iomem *apb_misc;\n\tu32 val;\n\n\tapb_misc = ioremap(TEGRA_APB_MISC_BASE, PAGE_SIZE);\n\tif (!apb_misc)\n\t\tapb_misc = ERR_PTR(-ENOENT);\n\tif (IS_ERR(apb_misc))\n\t\treturn dev_err_probe(vi->dev, PTR_ERR(apb_misc), \"cannot access APB_MISC\");\n\n\tval = readl(apb_misc + reg_offset);\n\tval &= ~BIT(0);\n\tval |= on ? BIT(0) : 0;\n\twritel(val, apb_misc + reg_offset);\n\tiounmap(apb_misc);\n\n\treturn 0;\n}\n\nstatic int tegra20_channel_host1x_syncpt_init(struct tegra_vi_channel *chan)\n{\n\tstruct tegra_vi *vi = chan->vi;\n\tstruct host1x_syncpt *out_sp;\n\n\tout_sp = host1x_syncpt_request(&vi->client, HOST1X_SYNCPT_CLIENT_MANAGED);\n\tif (!out_sp)\n\t\treturn dev_err_probe(vi->dev, -ENOMEM, \"failed to request syncpoint\\n\");\n\n\tchan->mw_ack_sp[0] = out_sp;\n\n\treturn 0;\n}\n\nstatic void tegra20_channel_host1x_syncpt_free(struct tegra_vi_channel *chan)\n{\n\thost1x_syncpt_put(chan->mw_ack_sp[0]);\n}\n\nstatic void tegra20_fmt_align(struct v4l2_pix_format *pix, unsigned int bpp)\n{\n\tpix->width  = clamp(pix->width,  TEGRA20_MIN_WIDTH,  TEGRA20_MAX_WIDTH);\n\tpix->height = clamp(pix->height, TEGRA20_MIN_HEIGHT, TEGRA20_MAX_HEIGHT);\n\n\tswitch (pix->pixelformat) {\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_VYUY:\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_YVYU:\n\t\tpix->bytesperline = roundup(pix->width, 2) * 2;\n\t\tpix->sizeimage = roundup(pix->width, 2) * 2 * pix->height;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\t\tpix->bytesperline = roundup(pix->width, 8);\n\t\tpix->sizeimage = roundup(pix->width, 8) * pix->height * 3 / 2;\n\t\tbreak;\n\t}\n}\n\n \nstatic void tegra20_channel_queue_setup(struct tegra_vi_channel *chan)\n{\n\tunsigned int stride = chan->format.bytesperline;\n\tunsigned int height = chan->format.height;\n\n\tchan->start_offset = 0;\n\n\tswitch (chan->format.pixelformat) {\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_VYUY:\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_YVYU:\n\t\tif (chan->vflip)\n\t\t\tchan->start_offset += stride * (height - 1);\n\t\tif (chan->hflip)\n\t\t\tchan->start_offset += stride - 1;\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\t\tchan->addr_offset_u = stride * height;\n\t\tchan->addr_offset_v = chan->addr_offset_u + stride * height / 4;\n\n\t\t \n\t\tif (chan->format.pixelformat == V4L2_PIX_FMT_YVU420) {\n\t\t\tunsigned long temp;\n\n\t\t\ttemp = chan->addr_offset_u;\n\t\t\tchan->addr_offset_u = chan->addr_offset_v;\n\t\t\tchan->addr_offset_v = temp;\n\t\t}\n\n\t\tchan->start_offset_u = chan->addr_offset_u;\n\t\tchan->start_offset_v = chan->addr_offset_v;\n\n\t\tif (chan->vflip) {\n\t\t\tchan->start_offset   += stride * (height - 1);\n\t\t\tchan->start_offset_u += (stride / 2) * ((height / 2) - 1);\n\t\t\tchan->start_offset_v += (stride / 2) * ((height / 2) - 1);\n\t\t}\n\t\tif (chan->hflip) {\n\t\t\tchan->start_offset   += stride - 1;\n\t\t\tchan->start_offset_u += (stride / 2) - 1;\n\t\t\tchan->start_offset_v += (stride / 2) - 1;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void release_buffer(struct tegra_vi_channel *chan,\n\t\t\t   struct tegra_channel_buffer *buf,\n\t\t\t   enum vb2_buffer_state state)\n{\n\tstruct vb2_v4l2_buffer *vb = &buf->buf;\n\n\tvb->sequence = chan->sequence++;\n\tvb->field = V4L2_FIELD_NONE;\n\tvb->vb2_buf.timestamp = ktime_get_ns();\n\tvb2_buffer_done(&vb->vb2_buf, state);\n}\n\nstatic void tegra20_channel_vi_buffer_setup(struct tegra_vi_channel *chan,\n\t\t\t\t\t    struct tegra_channel_buffer *buf)\n{\n\tdma_addr_t base = buf->addr;\n\n\tswitch (chan->fmtinfo->fourcc) {\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\t\ttegra20_vi_write(chan, TEGRA_VI_VB0_BASE_ADDRESS_U,  base + chan->addr_offset_u);\n\t\ttegra20_vi_write(chan, TEGRA_VI_VB0_START_ADDRESS_U, base + chan->start_offset_u);\n\t\ttegra20_vi_write(chan, TEGRA_VI_VB0_BASE_ADDRESS_V,  base + chan->addr_offset_v);\n\t\ttegra20_vi_write(chan, TEGRA_VI_VB0_START_ADDRESS_V, base + chan->start_offset_v);\n\t\tfallthrough;\n\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_VYUY:\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_YVYU:\n\t\ttegra20_vi_write(chan, TEGRA_VI_VB0_BASE_ADDRESS_FIRST,  base);\n\t\ttegra20_vi_write(chan, TEGRA_VI_VB0_START_ADDRESS_FIRST, base + chan->start_offset);\n\t\tbreak;\n\t}\n}\n\nstatic int tegra20_channel_capture_frame(struct tegra_vi_channel *chan,\n\t\t\t\t\t struct tegra_channel_buffer *buf)\n{\n\tint err;\n\n\tchan->next_out_sp_idx++;\n\n\ttegra20_channel_vi_buffer_setup(chan, buf);\n\n\ttegra20_vi_write(chan, TEGRA_VI_CAMERA_CONTROL, VI_CAMERA_CONTROL_VIP_ENABLE);\n\n\t \n\terr = host1x_syncpt_wait(chan->mw_ack_sp[0], chan->next_out_sp_idx,\n\t\t\t\t TEGRA_VI_SYNCPT_WAIT_TIMEOUT, NULL);\n\tif (err) {\n\t\thost1x_syncpt_incr(chan->mw_ack_sp[0]);\n\t\tdev_err_ratelimited(&chan->video.dev, \"frame start syncpt timeout: %d\\n\", err);\n\t\trelease_buffer(chan, buf, VB2_BUF_STATE_ERROR);\n\t\treturn err;\n\t}\n\n\ttegra20_vi_write(chan, TEGRA_VI_CAMERA_CONTROL,\n\t\t\t VI_CAMERA_CONTROL_STOP_CAPTURE | VI_CAMERA_CONTROL_VIP_ENABLE);\n\n\trelease_buffer(chan, buf, VB2_BUF_STATE_DONE);\n\n\treturn 0;\n}\n\nstatic int tegra20_chan_capture_kthread_start(void *data)\n{\n\tstruct tegra_vi_channel *chan = data;\n\tstruct tegra_channel_buffer *buf;\n\tunsigned int retries = 0;\n\tint err = 0;\n\n\twhile (1) {\n\t\t \n\t\twait_event_interruptible(chan->start_wait,\n\t\t\t\t\t kthread_should_stop() ||\n\t\t\t\t\t (!list_empty(&chan->capture) && !err));\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\t \n\t\tspin_lock(&chan->start_lock);\n\t\tif (list_empty(&chan->capture)) {\n\t\t\tspin_unlock(&chan->start_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf = list_first_entry(&chan->capture, struct tegra_channel_buffer, queue);\n\t\tlist_del_init(&buf->queue);\n\t\tspin_unlock(&chan->start_lock);\n\n\t\terr = tegra20_channel_capture_frame(chan, buf);\n\t\tif (!err) {\n\t\t\tretries = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (retries++ > chan->syncpt_timeout_retry)\n\t\t\tvb2_queue_error(&chan->queue);\n\t\telse\n\t\t\terr = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra20_camera_capture_setup(struct tegra_vi_channel *chan)\n{\n\tu32 output_fourcc = chan->format.pixelformat;\n\tint width  = chan->format.width;\n\tint height = chan->format.height;\n\tint stride_l = chan->format.bytesperline;\n\tint stride_c = (output_fourcc == V4L2_PIX_FMT_YUV420 ||\n\t\t\toutput_fourcc == V4L2_PIX_FMT_YVU420) ? 1 : 0;\n\tint main_output_format;\n\tint yuv_output_format;\n\n\ttegra20_vi_get_output_formats(chan, &main_output_format, &yuv_output_format);\n\n\t \n\ttegra20_vi_write(chan, TEGRA_VI_H_LPF_CONTROL,\n\t\t\t 0x0240 << VI_H_LPF_CONTROL_LUMA_SFT |\n\t\t\t 0x0240 << VI_H_LPF_CONTROL_CHROMA_SFT);\n\n\t \n\ttegra20_vi_write(chan, TEGRA_VI_VI_RAISE, VI_VI_RAISE_ON_EDGE);\n\n\ttegra20_vi_write(chan, TEGRA_VI_VI_FIRST_OUTPUT_CONTROL,\n\t\t\t (chan->vflip ? VI_OUTPUT_V_DIRECTION : 0) |\n\t\t\t (chan->hflip ? VI_OUTPUT_H_DIRECTION : 0) |\n\t\t\t yuv_output_format << VI_OUTPUT_YUV_OUTPUT_FORMAT_SFT |\n\t\t\t main_output_format << VI_OUTPUT_OUTPUT_FORMAT_SFT);\n\n\t \n\ttegra20_vi_write(chan, TEGRA_VI_FIRST_OUTPUT_FRAME_SIZE,\n\t\t\t height << VI_FIRST_OUTPUT_FRAME_HEIGHT_SFT |\n\t\t\t width  << VI_FIRST_OUTPUT_FRAME_WIDTH_SFT);\n\n\t \n\ttegra20_vi_write(chan, TEGRA_VI_VI_ENABLE, 0);\n\n\t \n\ttegra20_vi_write(chan, TEGRA_VI_VB0_COUNT_FIRST, 1);\n\n\t \n\ttegra20_vi_write(chan, TEGRA_VI_VB0_SIZE_FIRST,\n\t\t\t height << VI_VB0_SIZE_FIRST_V_SFT |\n\t\t\t width  << VI_VB0_SIZE_FIRST_H_SFT);\n\n\ttegra20_vi_write(chan, TEGRA_VI_VB0_BUFFER_STRIDE_FIRST,\n\t\t\t stride_l << VI_VB0_BUFFER_STRIDE_FIRST_LUMA_SFT |\n\t\t\t stride_c << VI_VB0_BUFFER_STRIDE_FIRST_CHROMA_SFT);\n\n\ttegra20_vi_write(chan, TEGRA_VI_VI_ENABLE, 0);\n}\n\nstatic int tegra20_vi_start_streaming(struct vb2_queue *vq, u32 count)\n{\n\tstruct tegra_vi_channel *chan = vb2_get_drv_priv(vq);\n\tstruct media_pipeline *pipe = &chan->video.pipe;\n\tint err;\n\n\tchan->next_out_sp_idx = host1x_syncpt_read(chan->mw_ack_sp[0]);\n\n\terr = video_device_pipeline_start(&chan->video, pipe);\n\tif (err)\n\t\tgoto error_pipeline_start;\n\n\ttegra20_camera_capture_setup(chan);\n\n\terr = tegra_channel_set_stream(chan, true);\n\tif (err)\n\t\tgoto error_set_stream;\n\n\tchan->sequence = 0;\n\n\tchan->kthread_start_capture = kthread_run(tegra20_chan_capture_kthread_start,\n\t\t\t\t\t\t  chan, \"%s:0\", chan->video.name);\n\tif (IS_ERR(chan->kthread_start_capture)) {\n\t\terr = PTR_ERR(chan->kthread_start_capture);\n\t\tchan->kthread_start_capture = NULL;\n\t\tdev_err_probe(&chan->video.dev, err, \"failed to run capture kthread\\n\");\n\t\tgoto error_kthread_start;\n\t}\n\n\treturn 0;\n\nerror_kthread_start:\n\ttegra_channel_set_stream(chan, false);\nerror_set_stream:\n\tvideo_device_pipeline_stop(&chan->video);\nerror_pipeline_start:\n\ttegra_channel_release_buffers(chan, VB2_BUF_STATE_QUEUED);\n\n\treturn err;\n}\n\nstatic void tegra20_vi_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct tegra_vi_channel *chan = vb2_get_drv_priv(vq);\n\n\tif (chan->kthread_start_capture) {\n\t\tkthread_stop(chan->kthread_start_capture);\n\t\tchan->kthread_start_capture = NULL;\n\t}\n\n\ttegra_channel_release_buffers(chan, VB2_BUF_STATE_ERROR);\n\ttegra_channel_set_stream(chan, false);\n\tvideo_device_pipeline_stop(&chan->video);\n}\n\nstatic const struct tegra_vi_ops tegra20_vi_ops = {\n\t.vi_enable = tegra20_vi_enable,\n\t.channel_host1x_syncpt_init = tegra20_channel_host1x_syncpt_init,\n\t.channel_host1x_syncpt_free = tegra20_channel_host1x_syncpt_free,\n\t.vi_fmt_align = tegra20_fmt_align,\n\t.channel_queue_setup = tegra20_channel_queue_setup,\n\t.vi_start_streaming = tegra20_vi_start_streaming,\n\t.vi_stop_streaming = tegra20_vi_stop_streaming,\n};\n\n#define TEGRA20_VIDEO_FMT(MBUS_CODE, BPP, FOURCC)\t\\\n{\t\t\t\t\t\t\t\\\n\t.code    = MEDIA_BUS_FMT_##MBUS_CODE,\t\t\\\n\t.bpp     = BPP,\t\t\t\t\t\\\n\t.fourcc  = V4L2_PIX_FMT_##FOURCC,\t\t\\\n}\n\nstatic const struct tegra_video_format tegra20_video_formats[] = {\n\tTEGRA20_VIDEO_FMT(UYVY8_2X8, 2, UYVY),\n\tTEGRA20_VIDEO_FMT(VYUY8_2X8, 2, VYUY),\n\tTEGRA20_VIDEO_FMT(YUYV8_2X8, 2, YUYV),\n\tTEGRA20_VIDEO_FMT(YVYU8_2X8, 2, YVYU),\n\tTEGRA20_VIDEO_FMT(UYVY8_2X8, 1, YUV420),\n\tTEGRA20_VIDEO_FMT(UYVY8_2X8, 1, YVU420),\n};\n\nconst struct tegra_vi_soc tegra20_vi_soc = {\n\t.video_formats = tegra20_video_formats,\n\t.nformats = ARRAY_SIZE(tegra20_video_formats),\n\t.default_video_format = &tegra20_video_formats[0],\n\t.ops = &tegra20_vi_ops,\n\t.vi_max_channels = 1,  \n\t.vi_max_clk_hz = 150000000,\n\t.has_h_v_flip = true,\n};\n\n \n\n \nstatic int tegra20_vip_start_streaming(struct tegra_vip_channel *vip_chan)\n{\n\tstruct tegra_vi_channel *vi_chan = v4l2_get_subdev_hostdata(&vip_chan->subdev);\n\tint width  = vi_chan->format.width;\n\tint height = vi_chan->format.height;\n\n\tunsigned int main_input_format;\n\tunsigned int yuv_input_format;\n\n\ttegra20_vi_get_input_formats(vi_chan, &main_input_format, &yuv_input_format);\n\n\ttegra20_vi_write(vi_chan, TEGRA_VI_VI_CORE_CONTROL, 0);\n\n\ttegra20_vi_write(vi_chan, TEGRA_VI_VI_INPUT_CONTROL,\n\t\t\t VI_INPUT_VIP_INPUT_ENABLE | main_input_format | yuv_input_format);\n\n\ttegra20_vi_write(vi_chan, TEGRA_VI_V_DOWNSCALE_CONTROL, 0);\n\ttegra20_vi_write(vi_chan, TEGRA_VI_H_DOWNSCALE_CONTROL, 0);\n\n\ttegra20_vi_write(vi_chan, TEGRA_VI_VIP_V_ACTIVE, height << VI_VIP_V_ACTIVE_PERIOD_SFT);\n\ttegra20_vi_write(vi_chan, TEGRA_VI_VIP_H_ACTIVE,\n\t\t\t roundup(width, 2) << VI_VIP_H_ACTIVE_PERIOD_SFT);\n\n\t \n\ttegra20_vi_write(vi_chan, TEGRA_VI_PIN_INPUT_ENABLE,\n\t\t\t GENMASK(9, 2) << VI_PIN_INPUT_VD_SFT |\n\t\t\t VI_PIN_INPUT_HSYNC | VI_PIN_INPUT_VSYNC);\n\ttegra20_vi_write(vi_chan, TEGRA_VI_VI_DATA_INPUT_CONTROL,\n\t\t\t GENMASK(9, 2) << VI_DATA_INPUT_SFT);\n\ttegra20_vi_write(vi_chan, TEGRA_VI_PIN_INVERSION, 0);\n\n\ttegra20_vi_write(vi_chan, TEGRA_VI_CONT_SYNCPT_OUT_1,\n\t\t\t VI_CONT_SYNCPT_OUT_1_CONTINUOUS_SYNCPT |\n\t\t\t host1x_syncpt_id(vi_chan->mw_ack_sp[0])\n\t\t\t << VI_CONT_SYNCPT_OUT_1_SYNCPT_IDX_SFT);\n\n\ttegra20_vi_write(vi_chan, TEGRA_VI_CAMERA_CONTROL, VI_CAMERA_CONTROL_STOP_CAPTURE);\n\n\treturn 0;\n}\n\nstatic const struct tegra_vip_ops tegra20_vip_ops = {\n\t.vip_start_streaming = tegra20_vip_start_streaming,\n};\n\nconst struct tegra_vip_soc tegra20_vip_soc = {\n\t.ops = &tegra20_vip_ops,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}