{
  "module_name": "vi.c",
  "hash_id": "e7202165e3a13e82fe87472b3af82f1b71d471ffeb619a5ab90a25dc0d177b37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/tegra-video/vi.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/host1x.h>\n#include <linux/lcm.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include <soc/tegra/pmc.h>\n\n#include \"vi.h\"\n#include \"video.h\"\n\n#define MAX_CID_CONTROLS\t\t3\n\n \nstruct tegra_vi_graph_entity {\n\tstruct v4l2_async_connection asd;\n\tstruct media_entity *entity;\n\tstruct v4l2_subdev *subdev;\n};\n\nstatic inline struct tegra_vi *\nhost1x_client_to_vi(struct host1x_client *client)\n{\n\treturn container_of(client, struct tegra_vi, client);\n}\n\nstatic inline struct tegra_channel_buffer *\nto_tegra_channel_buffer(struct vb2_v4l2_buffer *vb)\n{\n\treturn container_of(vb, struct tegra_channel_buffer, buf);\n}\n\nstatic inline struct tegra_vi_graph_entity *\nto_tegra_vi_graph_entity(struct v4l2_async_connection *asd)\n{\n\treturn container_of(asd, struct tegra_vi_graph_entity, asd);\n}\n\nstatic int tegra_get_format_idx_by_code(struct tegra_vi *vi,\n\t\t\t\t\tunsigned int code,\n\t\t\t\t\tunsigned int offset)\n{\n\tunsigned int i;\n\n\tfor (i = offset; i < vi->soc->nformats; ++i) {\n\t\tif (vi->soc->video_formats[i].code == code)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nstatic u32 tegra_get_format_fourcc_by_idx(struct tegra_vi *vi,\n\t\t\t\t\t  unsigned int index)\n{\n\tif (index >= vi->soc->nformats)\n\t\treturn -EINVAL;\n\n\treturn vi->soc->video_formats[index].fourcc;\n}\n\nstatic const struct tegra_video_format *\ntegra_get_format_by_fourcc(struct tegra_vi *vi, u32 fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < vi->soc->nformats; ++i) {\n\t\tif (vi->soc->video_formats[i].fourcc == fourcc)\n\t\t\treturn &vi->soc->video_formats[i];\n\t}\n\n\treturn NULL;\n}\n\n \n\nstatic int tegra_channel_queue_setup(struct vb2_queue *vq,\n\t\t\t\t     unsigned int *nbuffers,\n\t\t\t\t     unsigned int *nplanes,\n\t\t\t\t     unsigned int sizes[],\n\t\t\t\t     struct device *alloc_devs[])\n{\n\tstruct tegra_vi_channel *chan = vb2_get_drv_priv(vq);\n\n\tif (*nplanes)\n\t\treturn sizes[0] < chan->format.sizeimage ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = chan->format.sizeimage;\n\talloc_devs[0] = chan->vi->dev;\n\n\tif (chan->vi->ops->channel_queue_setup)\n\t\tchan->vi->ops->channel_queue_setup(chan);\n\n\treturn 0;\n}\n\nstatic int tegra_channel_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct tegra_vi_channel *chan = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct tegra_channel_buffer *buf = to_tegra_channel_buffer(vbuf);\n\tunsigned long size = chan->format.sizeimage;\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tv4l2_err(chan->video.v4l2_dev,\n\t\t\t \"buffer too small (%lu < %lu)\\n\",\n\t\t\t vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, size);\n\tbuf->chan = chan;\n\tbuf->addr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\n\treturn 0;\n}\n\nstatic void tegra_channel_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct tegra_vi_channel *chan = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct tegra_channel_buffer *buf = to_tegra_channel_buffer(vbuf);\n\n\t \n\tspin_lock(&chan->start_lock);\n\tlist_add_tail(&buf->queue, &chan->capture);\n\tspin_unlock(&chan->start_lock);\n\n\t \n\twake_up_interruptible(&chan->start_wait);\n}\n\nstruct v4l2_subdev *\ntegra_channel_get_remote_csi_subdev(struct tegra_vi_channel *chan)\n{\n\tstruct media_pad *pad;\n\n\tpad = media_pad_remote_pad_first(&chan->pad);\n\tif (!pad)\n\t\treturn NULL;\n\n\treturn media_entity_to_v4l2_subdev(pad->entity);\n}\n\n \nstruct v4l2_subdev *\ntegra_channel_get_remote_source_subdev(struct tegra_vi_channel *chan)\n{\n\tstruct media_pad *pad;\n\tstruct v4l2_subdev *subdev;\n\tstruct media_entity *entity;\n\n\tsubdev = tegra_channel_get_remote_csi_subdev(chan);\n\tif (!subdev)\n\t\treturn NULL;\n\n\tpad = &subdev->entity.pads[0];\n\twhile (!(pad->flags & MEDIA_PAD_FL_SOURCE)) {\n\t\tpad = media_pad_remote_pad_first(pad);\n\t\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\t\tbreak;\n\t\tentity = pad->entity;\n\t\tpad = &entity->pads[0];\n\t\tsubdev = media_entity_to_v4l2_subdev(entity);\n\t}\n\n\treturn subdev;\n}\n\nstatic int tegra_channel_enable_stream(struct tegra_vi_channel *chan)\n{\n\tstruct v4l2_subdev *subdev;\n\tint ret;\n\n\tsubdev = tegra_channel_get_remote_csi_subdev(chan);\n\tret = v4l2_subdev_call(subdev, video, s_stream, true);\n\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tegra_channel_disable_stream(struct tegra_vi_channel *chan)\n{\n\tstruct v4l2_subdev *subdev;\n\tint ret;\n\n\tsubdev = tegra_channel_get_remote_csi_subdev(chan);\n\tret = v4l2_subdev_call(subdev, video, s_stream, false);\n\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint tegra_channel_set_stream(struct tegra_vi_channel *chan, bool on)\n{\n\tint ret;\n\n\tif (on)\n\t\tret = tegra_channel_enable_stream(chan);\n\telse\n\t\tret = tegra_channel_disable_stream(chan);\n\n\treturn ret;\n}\n\nvoid tegra_channel_release_buffers(struct tegra_vi_channel *chan,\n\t\t\t\t   enum vb2_buffer_state state)\n{\n\tstruct tegra_channel_buffer *buf, *nbuf;\n\n\tspin_lock(&chan->start_lock);\n\tlist_for_each_entry_safe(buf, nbuf, &chan->capture, queue) {\n\t\tvb2_buffer_done(&buf->buf.vb2_buf, state);\n\t\tlist_del(&buf->queue);\n\t}\n\tspin_unlock(&chan->start_lock);\n\n\tspin_lock(&chan->done_lock);\n\tlist_for_each_entry_safe(buf, nbuf, &chan->done, queue) {\n\t\tvb2_buffer_done(&buf->buf.vb2_buf, state);\n\t\tlist_del(&buf->queue);\n\t}\n\tspin_unlock(&chan->done_lock);\n}\n\nstatic int tegra_channel_start_streaming(struct vb2_queue *vq, u32 count)\n{\n\tstruct tegra_vi_channel *chan = vb2_get_drv_priv(vq);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(chan->vi->dev);\n\tif (ret < 0) {\n\t\tdev_err(chan->vi->dev, \"failed to get runtime PM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = chan->vi->ops->vi_start_streaming(vq, count);\n\tif (ret < 0)\n\t\tpm_runtime_put(chan->vi->dev);\n\n\treturn ret;\n}\n\nstatic void tegra_channel_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct tegra_vi_channel *chan = vb2_get_drv_priv(vq);\n\n\tchan->vi->ops->vi_stop_streaming(vq);\n\tpm_runtime_put(chan->vi->dev);\n}\n\nstatic const struct vb2_ops tegra_channel_queue_qops = {\n\t.queue_setup = tegra_channel_queue_setup,\n\t.buf_prepare = tegra_channel_buffer_prepare,\n\t.buf_queue = tegra_channel_buffer_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = tegra_channel_start_streaming,\n\t.stop_streaming = tegra_channel_stop_streaming,\n};\n\n \nstatic int tegra_channel_querycap(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_capability *cap)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"tegra-video\", sizeof(cap->driver));\n\tstrscpy(cap->card, chan->video.name, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"platform:%s\",\n\t\t dev_name(chan->vi->dev));\n\n\treturn 0;\n}\n\nstatic int tegra_channel_g_parm(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_streamparm *a)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\treturn v4l2_g_parm_cap(&chan->video, subdev, a);\n}\n\nstatic int tegra_channel_s_parm(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_streamparm *a)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\treturn v4l2_s_parm_cap(&chan->video, subdev, a);\n}\n\nstatic int tegra_channel_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t\t struct v4l2_frmsizeenum *sizes)\n{\n\tint ret;\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\tconst struct tegra_video_format *fmtinfo;\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.index = sizes->index,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\tfmtinfo = tegra_get_format_by_fourcc(chan->vi, sizes->pixel_format);\n\tif (!fmtinfo)\n\t\treturn -EINVAL;\n\n\tfse.code = fmtinfo->code;\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tret = v4l2_subdev_call(subdev, pad, enum_frame_size, NULL, &fse);\n\tif (ret)\n\t\treturn ret;\n\n\tsizes->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tsizes->discrete.width = fse.max_width;\n\tsizes->discrete.height = fse.max_height;\n\n\treturn 0;\n}\n\nstatic int tegra_channel_enum_frameintervals(struct file *file, void *fh,\n\t\t\t\t\t     struct v4l2_frmivalenum *ivals)\n{\n\tint ret;\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\tconst struct tegra_video_format *fmtinfo;\n\tstruct v4l2_subdev_frame_interval_enum fie = {\n\t\t.index = ivals->index,\n\t\t.width = ivals->width,\n\t\t.height = ivals->height,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\tfmtinfo = tegra_get_format_by_fourcc(chan->vi, ivals->pixel_format);\n\tif (!fmtinfo)\n\t\treturn -EINVAL;\n\n\tfie.code = fmtinfo->code;\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tret = v4l2_subdev_call(subdev, pad, enum_frame_interval, NULL, &fie);\n\tif (ret)\n\t\treturn ret;\n\n\tivals->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tivals->discrete.numerator = fie.interval.numerator;\n\tivals->discrete.denominator = fie.interval.denominator;\n\n\treturn 0;\n}\n\nstatic int tegra_channel_enum_format(struct file *file, void *fh,\n\t\t\t\t     struct v4l2_fmtdesc *f)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tunsigned int index = 0, i;\n\tunsigned long *fmts_bitmap = chan->tpg_fmts_bitmap;\n\n\tif (!IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\tfmts_bitmap = chan->fmts_bitmap;\n\n\tif (f->index >= bitmap_weight(fmts_bitmap, MAX_FORMAT_NUM))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < f->index + 1; i++, index++)\n\t\tindex = find_next_bit(fmts_bitmap, MAX_FORMAT_NUM, index);\n\n\tf->pixelformat = tegra_get_format_fourcc_by_idx(chan->vi, index - 1);\n\n\treturn 0;\n}\n\nstatic int tegra_channel_get_format(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_format *format)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\n\tformat->fmt.pix = chan->format;\n\n\treturn 0;\n}\n\nstatic int __tegra_channel_try_format(struct tegra_vi_channel *chan,\n\t\t\t\t      struct v4l2_pix_format *pix)\n{\n\tconst struct tegra_video_format *fmtinfo;\n\tstatic struct lock_class_key key;\n\tstruct v4l2_subdev *subdev;\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tstruct v4l2_subdev_state *sd_state;\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tstruct v4l2_subdev_selection sdsel = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.target = V4L2_SEL_TGT_CROP_BOUNDS,\n\t};\n\tint ret;\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tif (!subdev)\n\t\treturn -ENODEV;\n\n\t \n\tsd_state = __v4l2_subdev_state_alloc(subdev, \"tegra:state->lock\",\n\t\t\t\t\t     &key);\n\tif (IS_ERR(sd_state))\n\t\treturn PTR_ERR(sd_state);\n\t \n\tfmtinfo = tegra_get_format_by_fourcc(chan->vi, pix->pixelformat);\n\tif (!fmtinfo) {\n\t\tpix->pixelformat = chan->format.pixelformat;\n\t\tpix->colorspace = chan->format.colorspace;\n\t\tfmtinfo = tegra_get_format_by_fourcc(chan->vi,\n\t\t\t\t\t\t     pix->pixelformat);\n\t}\n\n\tpix->field = V4L2_FIELD_NONE;\n\tfmt.pad = 0;\n\tv4l2_fill_mbus_format(&fmt.format, pix, fmtinfo->code);\n\n\t \n\tfse.code = fmtinfo->code;\n\tret = v4l2_subdev_call(subdev, pad, enum_frame_size, sd_state, &fse);\n\tif (ret) {\n\t\tif (!v4l2_subdev_has_op(subdev, pad, get_selection)) {\n\t\t\tsd_state->pads->try_crop.width = 0;\n\t\t\tsd_state->pads->try_crop.height = 0;\n\t\t} else {\n\t\t\tret = v4l2_subdev_call(subdev, pad, get_selection,\n\t\t\t\t\t       NULL, &sdsel);\n\t\t\tif (ret)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsd_state->pads->try_crop.width = sdsel.r.width;\n\t\t\tsd_state->pads->try_crop.height = sdsel.r.height;\n\t\t}\n\t} else {\n\t\tsd_state->pads->try_crop.width = fse.max_width;\n\t\tsd_state->pads->try_crop.height = fse.max_height;\n\t}\n\n\tret = v4l2_subdev_call(subdev, pad, set_fmt, sd_state, &fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_fill_pix_format(pix, &fmt.format);\n\tchan->vi->ops->vi_fmt_align(pix, fmtinfo->bpp);\n\n\t__v4l2_subdev_state_free(sd_state);\n\n\treturn 0;\n}\n\nstatic int tegra_channel_try_format(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_format *format)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\n\treturn __tegra_channel_try_format(chan, &format->fmt.pix);\n}\n\nstatic void tegra_channel_update_gangports(struct tegra_vi_channel *chan)\n{\n\tif (chan->format.width <= 1920)\n\t\tchan->numgangports = 1;\n\telse\n\t\tchan->numgangports = chan->totalports;\n}\n\nstatic int tegra_channel_set_format(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_format *format)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tconst struct tegra_video_format *fmtinfo;\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_subdev *subdev;\n\tstruct v4l2_pix_format *pix = &format->fmt.pix;\n\tint ret;\n\n\tif (vb2_is_busy(&chan->queue))\n\t\treturn -EBUSY;\n\n\t \n\tret = __tegra_channel_try_format(chan, pix);\n\tif (ret)\n\t\treturn ret;\n\n\tfmtinfo = tegra_get_format_by_fourcc(chan->vi, pix->pixelformat);\n\n\tfmt.pad = 0;\n\tv4l2_fill_mbus_format(&fmt.format, pix, fmtinfo->code);\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tret = v4l2_subdev_call(subdev, pad, set_fmt, NULL, &fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_fill_pix_format(pix, &fmt.format);\n\tchan->vi->ops->vi_fmt_align(pix, fmtinfo->bpp);\n\n\tchan->format = *pix;\n\tchan->fmtinfo = fmtinfo;\n\ttegra_channel_update_gangports(chan);\n\n\treturn 0;\n}\n\nstatic int tegra_channel_set_subdev_active_fmt(struct tegra_vi_channel *chan)\n{\n\tint ret, index;\n\tstruct v4l2_subdev *subdev;\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\t \n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tindex = tegra_get_format_idx_by_code(chan->vi, fmt.format.code, 0);\n\tif (index < 0)\n\t\treturn -EINVAL;\n\n\tchan->fmtinfo = &chan->vi->soc->video_formats[index];\n\tv4l2_fill_pix_format(&chan->format, &fmt.format);\n\tchan->format.pixelformat = chan->fmtinfo->fourcc;\n\tchan->format.bytesperline = chan->format.width * chan->fmtinfo->bpp;\n\tchan->format.sizeimage = chan->format.bytesperline *\n\t\t\t\t chan->format.height;\n\tchan->vi->ops->vi_fmt_align(&chan->format, chan->fmtinfo->bpp);\n\ttegra_channel_update_gangports(chan);\n\n\treturn 0;\n}\n\nstatic int\ntegra_channel_subscribe_event(struct v4l2_fh *fh,\n\t\t\t      const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_event_subscribe(fh, sub, 4, NULL);\n\t}\n\n\treturn v4l2_ctrl_subscribe_event(fh, sub);\n}\n\nstatic int tegra_channel_g_selection(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_selection *sel)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_subdev_selection sdsel = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.target = sel->target,\n\t};\n\tint ret;\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tif (!v4l2_subdev_has_op(subdev, pad, get_selection))\n\t\treturn -ENOTTY;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\t \n\tret = v4l2_subdev_call(subdev, pad, get_selection, NULL, &sdsel);\n\tif (!ret)\n\t\tsel->r = sdsel.r;\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\tret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsel->r.left = 0;\n\tsel->r.top = 0;\n\tsel->r.width = fmt.format.width;\n\tsel->r.height = fmt.format.height;\n\n\treturn 0;\n}\n\nstatic int tegra_channel_s_selection(struct file *file, void *fh,\n\t\t\t\t     struct v4l2_selection *sel)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\tint ret;\n\tstruct v4l2_subdev_selection sdsel = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.target = sel->target,\n\t\t.flags = sel->flags,\n\t\t.r = sel->r,\n\t};\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tif (!v4l2_subdev_has_op(subdev, pad, set_selection))\n\t\treturn -ENOTTY;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(&chan->queue))\n\t\treturn -EBUSY;\n\n\tret = v4l2_subdev_call(subdev, pad, set_selection, NULL, &sdsel);\n\tif (!ret) {\n\t\tsel->r = sdsel.r;\n\t\t \n\t\treturn tegra_channel_set_subdev_active_fmt(chan);\n\t}\n\n\treturn ret;\n}\n\nstatic int tegra_channel_g_edid(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_edid *edid)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tif (!v4l2_subdev_has_op(subdev, pad, get_edid))\n\t\treturn -ENOTTY;\n\n\treturn v4l2_subdev_call(subdev, pad, get_edid, edid);\n}\n\nstatic int tegra_channel_s_edid(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_edid *edid)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tif (!v4l2_subdev_has_op(subdev, pad, set_edid))\n\t\treturn -ENOTTY;\n\n\treturn v4l2_subdev_call(subdev, pad, set_edid, edid);\n}\n\nstatic int tegra_channel_g_dv_timings(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_dv_timings *timings)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tif (!v4l2_subdev_has_op(subdev, video, g_dv_timings))\n\t\treturn -ENOTTY;\n\n\treturn v4l2_device_call_until_err(chan->video.v4l2_dev, 0,\n\t\t\t\t\t  video, g_dv_timings, timings);\n}\n\nstatic int tegra_channel_s_dv_timings(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_dv_timings *timings)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\tstruct v4l2_bt_timings *bt = &timings->bt;\n\tstruct v4l2_dv_timings curr_timings;\n\tint ret;\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tif (!v4l2_subdev_has_op(subdev, video, s_dv_timings))\n\t\treturn -ENOTTY;\n\n\tret = tegra_channel_g_dv_timings(file, fh, &curr_timings);\n\tif (ret)\n\t\treturn ret;\n\n\tif (v4l2_match_dv_timings(timings, &curr_timings, 0, false))\n\t\treturn 0;\n\n\tif (vb2_is_busy(&chan->queue))\n\t\treturn -EBUSY;\n\n\tret = v4l2_device_call_until_err(chan->video.v4l2_dev, 0,\n\t\t\t\t\t video, s_dv_timings, timings);\n\tif (ret)\n\t\treturn ret;\n\n\tchan->format.width = bt->width;\n\tchan->format.height = bt->height;\n\tchan->format.bytesperline = bt->width * chan->fmtinfo->bpp;\n\tchan->format.sizeimage = chan->format.bytesperline * bt->height;\n\tchan->vi->ops->vi_fmt_align(&chan->format, chan->fmtinfo->bpp);\n\ttegra_channel_update_gangports(chan);\n\n\treturn 0;\n}\n\nstatic int tegra_channel_query_dv_timings(struct file *file, void *fh,\n\t\t\t\t\t  struct v4l2_dv_timings *timings)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tif (!v4l2_subdev_has_op(subdev, video, query_dv_timings))\n\t\treturn -ENOTTY;\n\n\treturn v4l2_device_call_until_err(chan->video.v4l2_dev, 0,\n\t\t\t\t\t  video, query_dv_timings, timings);\n}\n\nstatic int tegra_channel_enum_dv_timings(struct file *file, void *fh,\n\t\t\t\t\t struct v4l2_enum_dv_timings *timings)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tif (!v4l2_subdev_has_op(subdev, pad, enum_dv_timings))\n\t\treturn -ENOTTY;\n\n\treturn v4l2_subdev_call(subdev, pad, enum_dv_timings, timings);\n}\n\nstatic int tegra_channel_dv_timings_cap(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_dv_timings_cap *cap)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tif (!v4l2_subdev_has_op(subdev, pad, dv_timings_cap))\n\t\treturn -ENOTTY;\n\n\treturn v4l2_subdev_call(subdev, pad, dv_timings_cap, cap);\n}\n\nstatic int tegra_channel_log_status(struct file *file, void *fh)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\n\tv4l2_device_call_all(chan->video.v4l2_dev, 0, core, log_status);\n\n\treturn 0;\n}\n\nstatic int tegra_channel_enum_input(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_input *inp)\n{\n\tstruct tegra_vi_channel *chan = video_drvdata(file);\n\tstruct v4l2_subdev *subdev;\n\n\tif (inp->index)\n\t\treturn -EINVAL;\n\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tstrscpy(inp->name, subdev->name, sizeof(inp->name));\n\tif (v4l2_subdev_has_op(subdev, pad, dv_timings_cap))\n\t\tinp->capabilities = V4L2_IN_CAP_DV_TIMINGS;\n\n\treturn 0;\n}\n\nstatic int tegra_channel_g_input(struct file *file, void *priv,\n\t\t\t\t unsigned int *i)\n{\n\t*i = 0;\n\n\treturn 0;\n}\n\nstatic int tegra_channel_s_input(struct file *file, void *priv,\n\t\t\t\t unsigned int input)\n{\n\tif (input > 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops tegra_channel_ioctl_ops = {\n\t.vidioc_querycap\t\t= tegra_channel_querycap,\n\t.vidioc_g_parm\t\t\t= tegra_channel_g_parm,\n\t.vidioc_s_parm\t\t\t= tegra_channel_s_parm,\n\t.vidioc_enum_framesizes\t\t= tegra_channel_enum_framesizes,\n\t.vidioc_enum_frameintervals\t= tegra_channel_enum_frameintervals,\n\t.vidioc_enum_fmt_vid_cap\t= tegra_channel_enum_format,\n\t.vidioc_g_fmt_vid_cap\t\t= tegra_channel_get_format,\n\t.vidioc_s_fmt_vid_cap\t\t= tegra_channel_set_format,\n\t.vidioc_try_fmt_vid_cap\t\t= tegra_channel_try_format,\n\t.vidioc_enum_input\t\t= tegra_channel_enum_input,\n\t.vidioc_g_input\t\t\t= tegra_channel_g_input,\n\t.vidioc_s_input\t\t\t= tegra_channel_s_input,\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\t.vidioc_subscribe_event\t\t= tegra_channel_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n\t.vidioc_g_selection\t\t= tegra_channel_g_selection,\n\t.vidioc_s_selection\t\t= tegra_channel_s_selection,\n\t.vidioc_g_edid\t\t\t= tegra_channel_g_edid,\n\t.vidioc_s_edid\t\t\t= tegra_channel_s_edid,\n\t.vidioc_g_dv_timings\t\t= tegra_channel_g_dv_timings,\n\t.vidioc_s_dv_timings\t\t= tegra_channel_s_dv_timings,\n\t.vidioc_query_dv_timings\t= tegra_channel_query_dv_timings,\n\t.vidioc_enum_dv_timings\t\t= tegra_channel_enum_dv_timings,\n\t.vidioc_dv_timings_cap\t\t= tegra_channel_dv_timings_cap,\n\t.vidioc_log_status\t\t= tegra_channel_log_status,\n};\n\n \nstatic const struct v4l2_file_operations tegra_channel_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.open\t\t= v4l2_fh_open,\n\t.release\t= vb2_fop_release,\n\t.read\t\t= vb2_fop_read,\n\t.poll\t\t= vb2_fop_poll,\n\t.mmap\t\t= vb2_fop_mmap,\n};\n\n \nstatic int vi_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct tegra_vi_channel *chan = container_of(ctrl->handler,\n\t\t\t\t\t\t     struct tegra_vi_channel,\n\t\t\t\t\t\t     ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_TEST_PATTERN:\n\t\t \n\t\tchan->pg_mode = ctrl->val + 1;\n\t\tbreak;\n\tcase V4L2_CID_TEGRA_SYNCPT_TIMEOUT_RETRY:\n\t\tchan->syncpt_timeout_retry = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tchan->hflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tchan->vflip = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vi_ctrl_ops = {\n\t.s_ctrl\t= vi_s_ctrl,\n};\n\n#if IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG)\nstatic const char *const vi_pattern_strings[] = {\n\t\"Black/White Direct Mode\",\n\t\"Color Patch Mode\",\n};\n#else\nstatic const struct v4l2_ctrl_config syncpt_timeout_ctrl = {\n\t.ops = &vi_ctrl_ops,\n\t.id = V4L2_CID_TEGRA_SYNCPT_TIMEOUT_RETRY,\n\t.name = \"Syncpt timeout retry\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 1,\n\t.max = 10000,\n\t.step = 1,\n\t.def = 5,\n};\n#endif\n\nstatic int tegra_channel_setup_ctrl_handler(struct tegra_vi_channel *chan)\n{\n\tint ret;\n\n#if IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG)\n\t \n\tv4l2_ctrl_new_std_menu_items(&chan->ctrl_handler, &vi_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(vi_pattern_strings) - 1,\n\t\t\t\t     0, 0, vi_pattern_strings);\n\tif (chan->ctrl_handler.error) {\n\t\tdev_err(chan->vi->dev, \"failed to add TPG ctrl handler: %d\\n\",\n\t\t\tchan->ctrl_handler.error);\n\t\tv4l2_ctrl_handler_free(&chan->ctrl_handler);\n\t\treturn chan->ctrl_handler.error;\n\t}\n#else\n\tstruct v4l2_subdev *subdev;\n\n\t \n\tv4l2_ctrl_new_custom(&chan->ctrl_handler, &syncpt_timeout_ctrl, NULL);\n\tif (chan->ctrl_handler.error) {\n\t\tdev_err(chan->vi->dev, \"failed to add %s ctrl handler: %d\\n\",\n\t\t\tsyncpt_timeout_ctrl.name,\n\t\t\tchan->ctrl_handler.error);\n\t\tv4l2_ctrl_handler_free(&chan->ctrl_handler);\n\t\treturn chan->ctrl_handler.error;\n\t}\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tif (!subdev)\n\t\treturn -ENODEV;\n\n\tret = v4l2_ctrl_add_handler(&chan->ctrl_handler, subdev->ctrl_handler,\n\t\t\t\t    NULL, true);\n\tif (ret < 0) {\n\t\tdev_err(chan->vi->dev,\n\t\t\t\"failed to add subdev %s ctrl handler: %d\\n\",\n\t\t\tsubdev->name, ret);\n\t\tv4l2_ctrl_handler_free(&chan->ctrl_handler);\n\t\treturn ret;\n\t}\n\n\tif (chan->vi->soc->has_h_v_flip) {\n\t\tv4l2_ctrl_new_std(&chan->ctrl_handler, &vi_ctrl_ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\n\t\tv4l2_ctrl_new_std(&chan->ctrl_handler, &vi_ctrl_ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\n\t}\n\n#endif\n\n\t \n\tret = v4l2_ctrl_handler_setup(&chan->ctrl_handler);\n\tif (ret < 0) {\n\t\tdev_err(chan->vi->dev,\n\t\t\t\"failed to setup v4l2 ctrl handler: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void vi_tpg_fmts_bitmap_init(struct tegra_vi_channel *chan)\n{\n\tint index;\n\n\tbitmap_zero(chan->tpg_fmts_bitmap, MAX_FORMAT_NUM);\n\n\tindex = tegra_get_format_idx_by_code(chan->vi,\n\t\t\t\t\t     MEDIA_BUS_FMT_SRGGB10_1X10, 0);\n\tbitmap_set(chan->tpg_fmts_bitmap, index, 1);\n\n\tindex = tegra_get_format_idx_by_code(chan->vi,\n\t\t\t\t\t     MEDIA_BUS_FMT_RGB888_1X32_PADHI,\n\t\t\t\t\t     0);\n\tbitmap_set(chan->tpg_fmts_bitmap, index, 1);\n}\n\nstatic int vi_fmts_bitmap_init(struct tegra_vi_channel *chan)\n{\n\tint index, ret, match_code = 0;\n\tstruct v4l2_subdev *subdev;\n\tstruct v4l2_subdev_mbus_code_enum code = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\tbitmap_zero(chan->fmts_bitmap, MAX_FORMAT_NUM);\n\n\t \n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\twhile (1) {\n\t\tret = v4l2_subdev_call(subdev, pad, enum_mbus_code,\n\t\t\t\t       NULL, &code);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tindex = tegra_get_format_idx_by_code(chan->vi, code.code, 0);\n\t\twhile (index >= 0) {\n\t\t\tbitmap_set(chan->fmts_bitmap, index, 1);\n\t\t\tif (!match_code)\n\t\t\t\tmatch_code = code.code;\n\t\t\t \n\t\t\tindex = tegra_get_format_idx_by_code(chan->vi,\n\t\t\t\t\t\t\t     code.code,\n\t\t\t\t\t\t\t     index + 1);\n\t\t}\n\n\t\tcode.index++;\n\t}\n\n\t \n\tif (!match_code) {\n\t\tmatch_code = chan->vi->soc->default_video_format->code;\n\t\tindex = tegra_get_format_idx_by_code(chan->vi, match_code, 0);\n\t\tif (WARN_ON(index < 0))\n\t\t\treturn -EINVAL;\n\n\t\tbitmap_set(chan->fmts_bitmap, index, 1);\n\t}\n\n\t \n\ttegra_channel_set_subdev_active_fmt(chan);\n\n\treturn 0;\n}\n\nstatic void tegra_channel_cleanup(struct tegra_vi_channel *chan)\n{\n\tv4l2_ctrl_handler_free(&chan->ctrl_handler);\n\tmedia_entity_cleanup(&chan->video.entity);\n\tchan->vi->ops->channel_host1x_syncpt_free(chan);\n\tmutex_destroy(&chan->video_lock);\n}\n\nvoid tegra_channels_cleanup(struct tegra_vi *vi)\n{\n\tstruct tegra_vi_channel *chan, *tmp;\n\n\tif (!vi)\n\t\treturn;\n\n\tlist_for_each_entry_safe(chan, tmp, &vi->vi_chans, list) {\n\t\ttegra_channel_cleanup(chan);\n\t\tlist_del(&chan->list);\n\t\tkfree(chan);\n\t}\n}\n\nstatic int tegra_channel_init(struct tegra_vi_channel *chan)\n{\n\tstruct tegra_vi *vi = chan->vi;\n\tstruct tegra_video_device *vid = dev_get_drvdata(vi->client.host);\n\tint ret;\n\n\tmutex_init(&chan->video_lock);\n\tINIT_LIST_HEAD(&chan->capture);\n\tINIT_LIST_HEAD(&chan->done);\n\tspin_lock_init(&chan->start_lock);\n\tspin_lock_init(&chan->done_lock);\n\tinit_waitqueue_head(&chan->start_wait);\n\tinit_waitqueue_head(&chan->done_wait);\n\n\t \n\tchan->fmtinfo = chan->vi->soc->default_video_format;\n\tchan->format.pixelformat = chan->fmtinfo->fourcc;\n\tchan->format.colorspace = V4L2_COLORSPACE_SRGB;\n\tchan->format.field = V4L2_FIELD_NONE;\n\tchan->format.width = TEGRA_DEF_WIDTH;\n\tchan->format.height = TEGRA_DEF_HEIGHT;\n\tchan->format.bytesperline = TEGRA_DEF_WIDTH * chan->fmtinfo->bpp;\n\tchan->format.sizeimage = chan->format.bytesperline * TEGRA_DEF_HEIGHT;\n\tvi->ops->vi_fmt_align(&chan->format, chan->fmtinfo->bpp);\n\n\tret = vi->ops->channel_host1x_syncpt_init(chan);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tchan->pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&chan->video.entity, 1, &chan->pad);\n\tif (ret < 0) {\n\t\tdev_err(vi->dev,\n\t\t\t\"failed to initialize media entity: %d\\n\", ret);\n\t\tgoto free_syncpts;\n\t}\n\n\tret = v4l2_ctrl_handler_init(&chan->ctrl_handler, MAX_CID_CONTROLS);\n\tif (chan->ctrl_handler.error) {\n\t\tdev_err(vi->dev,\n\t\t\t\"failed to initialize v4l2 ctrl handler: %d\\n\", ret);\n\t\tgoto cleanup_media;\n\t}\n\n\t \n\tchan->video.fops = &tegra_channel_fops;\n\tchan->video.v4l2_dev = &vid->v4l2_dev;\n\tchan->video.release = video_device_release_empty;\n\tchan->video.queue = &chan->queue;\n\tsnprintf(chan->video.name, sizeof(chan->video.name), \"%s-%s-%u\",\n\t\t dev_name(vi->dev), \"output\", chan->portnos[0]);\n\tchan->video.vfl_type = VFL_TYPE_VIDEO;\n\tchan->video.vfl_dir = VFL_DIR_RX;\n\tchan->video.ioctl_ops = &tegra_channel_ioctl_ops;\n\tchan->video.ctrl_handler = &chan->ctrl_handler;\n\tchan->video.lock = &chan->video_lock;\n\tchan->video.device_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t\t  V4L2_CAP_STREAMING |\n\t\t\t\t  V4L2_CAP_READWRITE;\n\tvideo_set_drvdata(&chan->video, chan);\n\n\tchan->queue.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tchan->queue.io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ;\n\tchan->queue.lock = &chan->video_lock;\n\tchan->queue.drv_priv = chan;\n\tchan->queue.buf_struct_size = sizeof(struct tegra_channel_buffer);\n\tchan->queue.ops = &tegra_channel_queue_qops;\n\tchan->queue.mem_ops = &vb2_dma_contig_memops;\n\tchan->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tchan->queue.min_buffers_needed = 2;\n\tchan->queue.dev = vi->dev;\n\tret = vb2_queue_init(&chan->queue);\n\tif (ret < 0) {\n\t\tdev_err(vi->dev, \"failed to initialize vb2 queue: %d\\n\", ret);\n\t\tgoto free_v4l2_ctrl_hdl;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\tv4l2_async_nf_init(&chan->notifier, &vid->v4l2_dev);\n\n\treturn 0;\n\nfree_v4l2_ctrl_hdl:\n\tv4l2_ctrl_handler_free(&chan->ctrl_handler);\ncleanup_media:\n\tmedia_entity_cleanup(&chan->video.entity);\nfree_syncpts:\n\tvi->ops->channel_host1x_syncpt_free(chan);\n\treturn ret;\n}\n\nstatic int tegra_vi_channel_alloc(struct tegra_vi *vi, unsigned int port_num,\n\t\t\t\t  struct device_node *node, unsigned int lanes)\n{\n\tstruct tegra_vi_channel *chan;\n\tunsigned int i;\n\n\t \n\tchan = kzalloc(sizeof(*chan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn -ENOMEM;\n\n\tchan->vi = vi;\n\tchan->portnos[0] = port_num;\n\t \n\tif (lanes <= CSI_LANES_PER_BRICK)\n\t\tchan->totalports = 1;\n\telse\n\t\tchan->totalports = lanes / CSI_LANES_PER_BRICK;\n\tchan->numgangports = chan->totalports;\n\n\tfor (i = 1; i < chan->totalports; i++)\n\t\tchan->portnos[i] = chan->portnos[0] + i * CSI_PORTS_PER_BRICK;\n\n\tchan->of_node = node;\n\tlist_add_tail(&chan->list, &vi->vi_chans);\n\n\treturn 0;\n}\n\nstatic int tegra_vi_tpg_channels_alloc(struct tegra_vi *vi)\n{\n\tunsigned int port_num;\n\tunsigned int nchannels = vi->soc->vi_max_channels;\n\tint ret;\n\n\tfor (port_num = 0; port_num < nchannels; port_num++) {\n\t\tret = tegra_vi_channel_alloc(vi, port_num,\n\t\t\t\t\t     vi->dev->of_node, 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_vi_channels_alloc(struct tegra_vi *vi)\n{\n\tstruct device_node *node = vi->dev->of_node;\n\tstruct device_node *ep = NULL;\n\tstruct device_node *ports;\n\tstruct device_node *port = NULL;\n\tunsigned int port_num;\n\tstruct device_node *parent;\n\tstruct v4l2_fwnode_endpoint v4l2_ep = { .bus_type = 0 };\n\tunsigned int lanes;\n\tint ret = 0;\n\n\tports = of_get_child_by_name(node, \"ports\");\n\tif (!ports)\n\t\treturn dev_err_probe(vi->dev, -ENODEV, \"%pOF: missing 'ports' node\\n\", node);\n\n\tfor_each_child_of_node(ports, port) {\n\t\tif (!of_node_name_eq(port, \"port\"))\n\t\t\tcontinue;\n\n\t\tret = of_property_read_u32(port, \"reg\", &port_num);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tif (port_num > vi->soc->vi_max_channels) {\n\t\t\tdev_err(vi->dev, \"invalid port num %d for %pOF\\n\",\n\t\t\t\tport_num, port);\n\t\t\tret = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tep = of_get_child_by_name(port, \"endpoint\");\n\t\tif (!ep)\n\t\t\tcontinue;\n\n\t\tparent = of_graph_get_remote_port_parent(ep);\n\t\tof_node_put(ep);\n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\tep = of_graph_get_endpoint_by_regs(parent, 0, 0);\n\t\tof_node_put(parent);\n\t\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep),\n\t\t\t\t\t\t &v4l2_ep);\n\t\tof_node_put(ep);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tlanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;\n\t\tret = tegra_vi_channel_alloc(vi, port_num, port, lanes);\n\t\tif (ret < 0)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tof_node_put(port);\n\tof_node_put(ports);\n\treturn ret;\n}\n\nstatic int tegra_vi_channels_init(struct tegra_vi *vi)\n{\n\tstruct tegra_vi_channel *chan;\n\tint ret;\n\n\tlist_for_each_entry(chan, &vi->vi_chans, list) {\n\t\tret = tegra_channel_init(chan);\n\t\tif (ret < 0) {\n\t\t\tdev_err(vi->dev,\n\t\t\t\t\"failed to initialize channel-%d: %d\\n\",\n\t\t\t\tchan->portnos[0], ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\treturn 0;\n\ncleanup:\n\tlist_for_each_entry_continue_reverse(chan, &vi->vi_chans, list)\n\t\ttegra_channel_cleanup(chan);\n\n\treturn ret;\n}\n\nvoid tegra_v4l2_nodes_cleanup_tpg(struct tegra_video_device *vid)\n{\n\tstruct tegra_vi *vi = vid->vi;\n\tstruct tegra_csi *csi = vid->csi;\n\tstruct tegra_csi_channel *csi_chan;\n\tstruct tegra_vi_channel *chan;\n\n\tlist_for_each_entry(chan, &vi->vi_chans, list)\n\t\tvb2_video_unregister_device(&chan->video);\n\n\tlist_for_each_entry(csi_chan, &csi->csi_chans, list)\n\t\tv4l2_device_unregister_subdev(&csi_chan->subdev);\n}\n\nint tegra_v4l2_nodes_setup_tpg(struct tegra_video_device *vid)\n{\n\tstruct tegra_vi *vi = vid->vi;\n\tstruct tegra_csi *csi = vid->csi;\n\tstruct tegra_vi_channel *vi_chan;\n\tstruct tegra_csi_channel *csi_chan;\n\tu32 link_flags = MEDIA_LNK_FL_ENABLED;\n\tint ret;\n\n\tif (!vi || !csi)\n\t\treturn -ENODEV;\n\n\tcsi_chan = list_first_entry(&csi->csi_chans,\n\t\t\t\t    struct tegra_csi_channel, list);\n\n\tlist_for_each_entry(vi_chan, &vi->vi_chans, list) {\n\t\tstruct media_entity *source = &csi_chan->subdev.entity;\n\t\tstruct media_entity *sink = &vi_chan->video.entity;\n\t\tstruct media_pad *source_pad = csi_chan->pads;\n\t\tstruct media_pad *sink_pad = &vi_chan->pad;\n\n\t\tret = v4l2_device_register_subdev(&vid->v4l2_dev,\n\t\t\t\t\t\t  &csi_chan->subdev);\n\t\tif (ret) {\n\t\t\tdev_err(vi->dev,\n\t\t\t\t\"failed to register subdev: %d\\n\", ret);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tret = video_register_device(&vi_chan->video,\n\t\t\t\t\t    VFL_TYPE_VIDEO, -1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(vi->dev,\n\t\t\t\t\"failed to register video device: %d\\n\", ret);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tdev_dbg(vi->dev, \"creating %s:%u -> %s:%u link\\n\",\n\t\t\tsource->name, source_pad->index,\n\t\t\tsink->name, sink_pad->index);\n\n\t\tret = media_create_pad_link(source, source_pad->index,\n\t\t\t\t\t    sink, sink_pad->index,\n\t\t\t\t\t    link_flags);\n\t\tif (ret < 0) {\n\t\t\tdev_err(vi->dev,\n\t\t\t\t\"failed to create %s:%u -> %s:%u link: %d\\n\",\n\t\t\t\tsource->name, source_pad->index,\n\t\t\t\tsink->name, sink_pad->index, ret);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tret = tegra_channel_setup_ctrl_handler(vi_chan);\n\t\tif (ret < 0)\n\t\t\tgoto cleanup;\n\n\t\tv4l2_set_subdev_hostdata(&csi_chan->subdev, vi_chan);\n\t\tvi_tpg_fmts_bitmap_init(vi_chan);\n\t\tcsi_chan = list_next_entry(csi_chan, list);\n\t}\n\n\treturn 0;\n\ncleanup:\n\ttegra_v4l2_nodes_cleanup_tpg(vid);\n\treturn ret;\n}\n\nstatic int __maybe_unused vi_runtime_resume(struct device *dev)\n{\n\tstruct tegra_vi *vi = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_enable(vi->vdd);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable VDD supply: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_set_rate(vi->clk, vi->soc->vi_max_clk_hz);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set vi clock rate: %d\\n\", ret);\n\t\tgoto disable_vdd;\n\t}\n\n\tret = clk_prepare_enable(vi->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable vi clock: %d\\n\", ret);\n\t\tgoto disable_vdd;\n\t}\n\n\treturn 0;\n\ndisable_vdd:\n\tregulator_disable(vi->vdd);\n\treturn ret;\n}\n\nstatic int __maybe_unused vi_runtime_suspend(struct device *dev)\n{\n\tstruct tegra_vi *vi = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(vi->clk);\n\n\tregulator_disable(vi->vdd);\n\n\treturn 0;\n}\n\n \nstatic struct tegra_vi_graph_entity *\ntegra_vi_graph_find_entity(struct list_head *list,\n\t\t\t   const struct fwnode_handle *fwnode)\n{\n\tstruct tegra_vi_graph_entity *entity;\n\tstruct v4l2_async_connection *asd;\n\n\tlist_for_each_entry(asd, list, asc_entry) {\n\t\tentity = to_tegra_vi_graph_entity(asd);\n\n\t\tif (entity->asd.match.fwnode == fwnode)\n\t\t\treturn entity;\n\t}\n\n\treturn NULL;\n}\n\nstatic int tegra_vi_graph_build(struct tegra_vi_channel *chan,\n\t\t\t\tstruct tegra_vi_graph_entity *entity)\n{\n\tstruct tegra_vi *vi = chan->vi;\n\tstruct tegra_vi_graph_entity *ent;\n\tstruct fwnode_handle *ep = NULL;\n\tstruct v4l2_fwnode_link link;\n\tstruct media_entity *local = entity->entity;\n\tstruct media_entity *remote;\n\tstruct media_pad *local_pad;\n\tstruct media_pad *remote_pad;\n\tu32 link_flags = MEDIA_LNK_FL_ENABLED;\n\tint ret = 0;\n\n\tdev_dbg(vi->dev, \"creating links for entity %s\\n\", local->name);\n\n\twhile (1) {\n\t\tep = fwnode_graph_get_next_endpoint(entity->asd.match.fwnode,\n\t\t\t\t\t\t    ep);\n\t\tif (!ep)\n\t\t\tbreak;\n\n\t\tret = v4l2_fwnode_parse_link(ep, &link);\n\t\tif (ret < 0) {\n\t\t\tdev_err(vi->dev, \"failed to parse link for %pOF: %d\\n\",\n\t\t\t\tto_of_node(ep), ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (link.local_port >= local->num_pads) {\n\t\t\tdev_err(vi->dev, \"invalid port number %u on %pOF\\n\",\n\t\t\t\tlink.local_port, to_of_node(link.local_node));\n\t\t\tv4l2_fwnode_put_link(&link);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tlocal_pad = &local->pads[link.local_port];\n\t\t \n\t\tif (link.remote_node == of_fwnode_handle(vi->dev->of_node)) {\n\t\t\tremote = &chan->video.entity;\n\t\t\tremote_pad = &chan->pad;\n\t\t\tgoto create_link;\n\t\t}\n\n\t\t \n\t\tif (local_pad->flags & MEDIA_PAD_FL_SINK) {\n\t\t\tdev_dbg(vi->dev, \"skipping sink port %pOF:%u\\n\",\n\t\t\t\tto_of_node(link.local_node), link.local_port);\n\t\t\tv4l2_fwnode_put_link(&link);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tent = tegra_vi_graph_find_entity(&chan->notifier.done_list,\n\t\t\t\t\t\t link.remote_node);\n\t\tif (!ent) {\n\t\t\tdev_err(vi->dev, \"no entity found for %pOF\\n\",\n\t\t\t\tto_of_node(link.remote_node));\n\t\t\tv4l2_fwnode_put_link(&link);\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tremote = ent->entity;\n\t\tif (link.remote_port >= remote->num_pads) {\n\t\t\tdev_err(vi->dev, \"invalid port number %u on %pOF\\n\",\n\t\t\t\tlink.remote_port,\n\t\t\t\tto_of_node(link.remote_node));\n\t\t\tv4l2_fwnode_put_link(&link);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tremote_pad = &remote->pads[link.remote_port];\n\ncreate_link:\n\t\tdev_dbg(vi->dev, \"creating %s:%u -> %s:%u link\\n\",\n\t\t\tlocal->name, local_pad->index,\n\t\t\tremote->name, remote_pad->index);\n\n\t\tret = media_create_pad_link(local, local_pad->index,\n\t\t\t\t\t    remote, remote_pad->index,\n\t\t\t\t\t    link_flags);\n\t\tv4l2_fwnode_put_link(&link);\n\t\tif (ret < 0) {\n\t\t\tdev_err(vi->dev,\n\t\t\t\t\"failed to create %s:%u -> %s:%u link: %d\\n\",\n\t\t\t\tlocal->name, local_pad->index,\n\t\t\t\tremote->name, remote_pad->index, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfwnode_handle_put(ep);\n\treturn ret;\n}\n\nstatic int tegra_vi_graph_notify_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct tegra_vi_graph_entity *entity;\n\tstruct v4l2_async_connection *asd;\n\tstruct v4l2_subdev *subdev;\n\tstruct tegra_vi_channel *chan;\n\tstruct tegra_vi *vi;\n\tint ret;\n\n\tchan = container_of(notifier, struct tegra_vi_channel, notifier);\n\tvi = chan->vi;\n\n\tdev_dbg(vi->dev, \"notify complete, all subdevs registered\\n\");\n\n\t \n\tret = video_register_device(&chan->video, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0) {\n\t\tdev_err(vi->dev,\n\t\t\t\"failed to register video device: %d\\n\", ret);\n\t\tgoto unregister_video;\n\t}\n\n\t \n\tlist_for_each_entry(asd, &chan->notifier.done_list, asc_entry) {\n\t\tentity = to_tegra_vi_graph_entity(asd);\n\t\tret = tegra_vi_graph_build(chan, entity);\n\t\tif (ret < 0)\n\t\t\tgoto unregister_video;\n\t}\n\n\tret = tegra_channel_setup_ctrl_handler(chan);\n\tif (ret < 0) {\n\t\tdev_err(vi->dev,\n\t\t\t\"failed to setup channel controls: %d\\n\", ret);\n\t\tgoto unregister_video;\n\t}\n\n\tret = vi_fmts_bitmap_init(chan);\n\tif (ret < 0) {\n\t\tdev_err(vi->dev,\n\t\t\t\"failed to initialize formats bitmap: %d\\n\", ret);\n\t\tgoto unregister_video;\n\t}\n\n\tsubdev = tegra_channel_get_remote_csi_subdev(chan);\n\tif (!subdev) {\n\t\tret = -ENODEV;\n\t\tdev_err(vi->dev,\n\t\t\t\"failed to get remote csi subdev: %d\\n\", ret);\n\t\tgoto unregister_video;\n\t}\n\n\tv4l2_set_subdev_hostdata(subdev, chan);\n\n\tsubdev = tegra_channel_get_remote_source_subdev(chan);\n\tv4l2_set_subdev_hostdata(subdev, chan);\n\n\treturn 0;\n\nunregister_video:\n\tvb2_video_unregister_device(&chan->video);\n\treturn ret;\n}\n\nstatic int tegra_vi_graph_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t       struct v4l2_subdev *subdev,\n\t\t\t\t       struct v4l2_async_connection *asd)\n{\n\tstruct tegra_vi_graph_entity *entity;\n\tstruct tegra_vi *vi;\n\tstruct tegra_vi_channel *chan;\n\n\tchan = container_of(notifier, struct tegra_vi_channel, notifier);\n\tvi = chan->vi;\n\n\t \n\tentity = tegra_vi_graph_find_entity(&chan->notifier.waiting_list,\n\t\t\t\t\t    subdev->fwnode);\n\tif (!entity) {\n\t\tdev_err(vi->dev, \"no entity for subdev %s\\n\", subdev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (entity->subdev) {\n\t\tdev_err(vi->dev, \"duplicate subdev for node %pOF\\n\",\n\t\t\tto_of_node(entity->asd.match.fwnode));\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(vi->dev, \"subdev %s bound\\n\", subdev->name);\n\tentity->entity = &subdev->entity;\n\tentity->subdev = subdev;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_async_notifier_operations tegra_vi_async_ops = {\n\t.bound = tegra_vi_graph_notify_bound,\n\t.complete = tegra_vi_graph_notify_complete,\n};\n\nstatic int tegra_vi_graph_parse_one(struct tegra_vi_channel *chan,\n\t\t\t\t    struct fwnode_handle *fwnode)\n{\n\tstruct tegra_vi *vi = chan->vi;\n\tstruct fwnode_handle *ep = NULL;\n\tstruct fwnode_handle *remote = NULL;\n\tstruct tegra_vi_graph_entity *tvge;\n\tstruct device_node *node = NULL;\n\tint ret;\n\n\tdev_dbg(vi->dev, \"parsing node %pOF\\n\", to_of_node(fwnode));\n\n\t \n\tfor_each_endpoint_of_node(to_of_node(fwnode), node) {\n\t\tep = of_fwnode_handle(node);\n\t\tremote = fwnode_graph_get_remote_port_parent(ep);\n\t\tif (!remote) {\n\t\t\tdev_err(vi->dev,\n\t\t\t\t\"remote device at %pOF not found\\n\", node);\n\t\t\tret = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\tif (device_match_fwnode(vi->dev, remote) ||\n\t\t    tegra_vi_graph_find_entity(&chan->notifier.waiting_list,\n\t\t\t\t\t       remote)) {\n\t\t\tfwnode_handle_put(remote);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttvge = v4l2_async_nf_add_fwnode(&chan->notifier, remote,\n\t\t\t\t\t\tstruct tegra_vi_graph_entity);\n\t\tif (IS_ERR(tvge)) {\n\t\t\tret = PTR_ERR(tvge);\n\t\t\tdev_err(vi->dev,\n\t\t\t\t\"failed to add subdev to notifier: %d\\n\", ret);\n\t\t\tfwnode_handle_put(remote);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tret = tegra_vi_graph_parse_one(chan, remote);\n\t\tif (ret < 0) {\n\t\t\tfwnode_handle_put(remote);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tfwnode_handle_put(remote);\n\t}\n\n\treturn 0;\n\ncleanup:\n\tdev_err(vi->dev, \"failed parsing the graph: %d\\n\", ret);\n\tv4l2_async_nf_cleanup(&chan->notifier);\n\tof_node_put(node);\n\treturn ret;\n}\n\nstatic int tegra_vi_graph_init(struct tegra_vi *vi)\n{\n\tstruct tegra_vi_channel *chan;\n\tstruct fwnode_handle *fwnode = dev_fwnode(vi->dev);\n\tint ret;\n\n\t \n\tlist_for_each_entry(chan, &vi->vi_chans, list) {\n\t\tstruct fwnode_handle *ep, *remote;\n\n\t\tep = fwnode_graph_get_endpoint_by_id(fwnode,\n\t\t\t\t\t\t     chan->portnos[0], 0, 0);\n\t\tif (!ep)\n\t\t\tcontinue;\n\n\t\tremote = fwnode_graph_get_remote_port_parent(ep);\n\t\tfwnode_handle_put(ep);\n\n\t\tret = tegra_vi_graph_parse_one(chan, remote);\n\t\tfwnode_handle_put(remote);\n\t\tif (ret < 0 || list_empty(&chan->notifier.waiting_list))\n\t\t\tcontinue;\n\n\t\tchan->notifier.ops = &tegra_vi_async_ops;\n\t\tret = v4l2_async_nf_register(&chan->notifier);\n\t\tif (ret < 0) {\n\t\t\tdev_err(vi->dev,\n\t\t\t\t\"failed to register channel %d notifier: %d\\n\",\n\t\t\t\tchan->portnos[0], ret);\n\t\t\tv4l2_async_nf_cleanup(&chan->notifier);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_vi_graph_cleanup(struct tegra_vi *vi)\n{\n\tstruct tegra_vi_channel *chan;\n\n\tlist_for_each_entry(chan, &vi->vi_chans, list) {\n\t\tvb2_video_unregister_device(&chan->video);\n\t\tv4l2_async_nf_unregister(&chan->notifier);\n\t\tv4l2_async_nf_cleanup(&chan->notifier);\n\t}\n}\n\nstatic int tegra_vi_init(struct host1x_client *client)\n{\n\tstruct tegra_video_device *vid = dev_get_drvdata(client->host);\n\tstruct tegra_vi *vi = host1x_client_to_vi(client);\n\tstruct tegra_vi_channel *chan, *tmp;\n\tint ret;\n\n\tvid->media_dev.hw_revision = vi->soc->hw_revision;\n\tsnprintf(vid->media_dev.bus_info, sizeof(vid->media_dev.bus_info),\n\t\t \"platform:%s\", dev_name(vi->dev));\n\n\tINIT_LIST_HEAD(&vi->vi_chans);\n\n\tif (IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\tret = tegra_vi_tpg_channels_alloc(vi);\n\telse\n\t\tret = tegra_vi_channels_alloc(vi);\n\tif (ret < 0)\n\t\tgoto free_chans;\n\n\tret = tegra_vi_channels_init(vi);\n\tif (ret < 0)\n\t\tgoto free_chans;\n\n\tvid->vi = vi;\n\n\tif (!IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG)) {\n\t\tret = tegra_vi_graph_init(vi);\n\t\tif (ret < 0)\n\t\t\tgoto cleanup_chans;\n\t}\n\n\treturn 0;\n\ncleanup_chans:\n\tlist_for_each_entry(chan, &vi->vi_chans, list)\n\t\ttegra_channel_cleanup(chan);\nfree_chans:\n\tlist_for_each_entry_safe(chan, tmp, &vi->vi_chans, list) {\n\t\tlist_del(&chan->list);\n\t\tkfree(chan);\n\t}\n\n\treturn ret;\n}\n\nstatic int tegra_vi_exit(struct host1x_client *client)\n{\n\tstruct tegra_vi *vi = host1x_client_to_vi(client);\n\n\t \n\n\tif (!IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\ttegra_vi_graph_cleanup(vi);\n\n\treturn 0;\n}\n\nstatic const struct host1x_client_ops vi_client_ops = {\n\t.init = tegra_vi_init,\n\t.exit = tegra_vi_exit,\n};\n\nstatic int tegra_vi_probe(struct platform_device *pdev)\n{\n\tstruct tegra_vi *vi;\n\tint ret;\n\n\tvi = devm_kzalloc(&pdev->dev, sizeof(*vi), GFP_KERNEL);\n\tif (!vi)\n\t\treturn -ENOMEM;\n\n\tvi->iomem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(vi->iomem))\n\t\treturn PTR_ERR(vi->iomem);\n\n\tvi->soc = of_device_get_match_data(&pdev->dev);\n\n\tvi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(vi->clk)) {\n\t\tret = PTR_ERR(vi->clk);\n\t\tdev_err(&pdev->dev, \"failed to get vi clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tvi->vdd = devm_regulator_get(&pdev->dev, \"avdd-dsi-csi\");\n\tif (IS_ERR(vi->vdd)) {\n\t\tret = PTR_ERR(vi->vdd);\n\t\tdev_err(&pdev->dev, \"failed to get VDD supply: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!pdev->dev.pm_domain) {\n\t\tret = -ENOENT;\n\t\tdev_warn(&pdev->dev, \"PM domain is not attached: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_of_platform_populate(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to populate vi child device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tvi->dev = &pdev->dev;\n\tvi->ops = vi->soc->ops;\n\tplatform_set_drvdata(pdev, vi);\n\tpm_runtime_enable(&pdev->dev);\n\n\t \n\tINIT_LIST_HEAD(&vi->client.list);\n\tvi->client.ops = &vi_client_ops;\n\tvi->client.dev = &pdev->dev;\n\n\tif (vi->ops->vi_enable)\n\t\tvi->ops->vi_enable(vi, true);\n\n\tret = host1x_client_register(&vi->client);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to register host1x client: %d\\n\", ret);\n\t\tgoto rpm_disable;\n\t}\n\n\treturn 0;\n\nrpm_disable:\n\tif (vi->ops->vi_enable)\n\t\tvi->ops->vi_enable(vi, false);\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic int tegra_vi_remove(struct platform_device *pdev)\n{\n\tstruct tegra_vi *vi = platform_get_drvdata(pdev);\n\n\thost1x_client_unregister(&vi->client);\n\n\tif (vi->ops->vi_enable)\n\t\tvi->ops->vi_enable(vi, false);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tegra_vi_of_id_table[] = {\n#if defined(CONFIG_ARCH_TEGRA_2x_SOC)\n\t{ .compatible = \"nvidia,tegra20-vi\",  .data = &tegra20_vi_soc },\n#endif\n#if defined(CONFIG_ARCH_TEGRA_210_SOC)\n\t{ .compatible = \"nvidia,tegra210-vi\", .data = &tegra210_vi_soc },\n#endif\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_vi_of_id_table);\n\nstatic const struct dev_pm_ops tegra_vi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(vi_runtime_suspend, vi_runtime_resume, NULL)\n};\n\nstruct platform_driver tegra_vi_driver = {\n\t.driver = {\n\t\t.name = \"tegra-vi\",\n\t\t.of_match_table = tegra_vi_of_id_table,\n\t\t.pm = &tegra_vi_pm_ops,\n\t},\n\t.probe = tegra_vi_probe,\n\t.remove = tegra_vi_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}