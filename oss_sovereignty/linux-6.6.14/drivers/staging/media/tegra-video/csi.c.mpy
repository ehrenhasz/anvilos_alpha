{
  "module_name": "csi.c",
  "hash_id": "8b821cf9ae263ad6d411337fc6229ef57e2fb417dcf1da0a1877dc807b95bf30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/media/tegra-video/csi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk/tegra.h>\n#include <linux/device.h>\n#include <linux/host1x.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <media/v4l2-fwnode.h>\n\n#include \"csi.h\"\n#include \"video.h\"\n\n#define MHZ\t\t\t1000000\n\nstatic inline struct tegra_csi *\nhost1x_client_to_csi(struct host1x_client *client)\n{\n\treturn container_of(client, struct tegra_csi, client);\n}\n\nstatic inline struct tegra_csi_channel *to_csi_chan(struct v4l2_subdev *subdev)\n{\n\treturn container_of(subdev, struct tegra_csi_channel, subdev);\n}\n\n \nstatic const struct v4l2_mbus_framefmt tegra_csi_tpg_fmts[] = {\n\t{\n\t\tTEGRA_DEF_WIDTH,\n\t\tTEGRA_DEF_HEIGHT,\n\t\tMEDIA_BUS_FMT_SRGGB10_1X10,\n\t\tV4L2_FIELD_NONE,\n\t\tV4L2_COLORSPACE_SRGB\n\t},\n\t{\n\t\tTEGRA_DEF_WIDTH,\n\t\tTEGRA_DEF_HEIGHT,\n\t\tMEDIA_BUS_FMT_RGB888_1X32_PADHI,\n\t\tV4L2_FIELD_NONE,\n\t\tV4L2_COLORSPACE_SRGB\n\t},\n};\n\nstatic const struct v4l2_frmsize_discrete tegra_csi_tpg_sizes[] = {\n\t{ 1280, 720 },\n\t{ 1920, 1080 },\n\t{ 3840, 2160 },\n};\n\n \nstatic int csi_enum_bus_code(struct v4l2_subdev *subdev,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (!IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\treturn -ENOIOCTLCMD;\n\n\tif (code->index >= ARRAY_SIZE(tegra_csi_tpg_fmts))\n\t\treturn -EINVAL;\n\n\tcode->code = tegra_csi_tpg_fmts[code->index].code;\n\n\treturn 0;\n}\n\nstatic int csi_get_format(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct tegra_csi_channel *csi_chan = to_csi_chan(subdev);\n\n\tif (!IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\treturn -ENOIOCTLCMD;\n\n\tfmt->format = csi_chan->format;\n\n\treturn 0;\n}\n\nstatic int csi_get_frmrate_table_index(struct tegra_csi *csi, u32 code,\n\t\t\t\t       u32 width, u32 height)\n{\n\tconst struct tpg_framerate *frmrate;\n\tunsigned int i;\n\n\tfrmrate = csi->soc->tpg_frmrate_table;\n\tfor (i = 0; i < csi->soc->tpg_frmrate_table_size; i++) {\n\t\tif (frmrate[i].code == code &&\n\t\t    frmrate[i].frmsize.width == width &&\n\t\t    frmrate[i].frmsize.height == height) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void csi_chan_update_blank_intervals(struct tegra_csi_channel *csi_chan,\n\t\t\t\t\t    u32 code, u32 width, u32 height)\n{\n\tstruct tegra_csi *csi = csi_chan->csi;\n\tconst struct tpg_framerate *frmrate = csi->soc->tpg_frmrate_table;\n\tint index;\n\n\tindex = csi_get_frmrate_table_index(csi_chan->csi, code,\n\t\t\t\t\t    width, height);\n\tif (index >= 0) {\n\t\tcsi_chan->h_blank = frmrate[index].h_blank;\n\t\tcsi_chan->v_blank = frmrate[index].v_blank;\n\t\tcsi_chan->framerate = frmrate[index].framerate;\n\t}\n}\n\nstatic int csi_enum_framesizes(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_frame_size_enum *fse)\n{\n\tunsigned int i;\n\n\tif (!IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\treturn -ENOIOCTLCMD;\n\n\tif (fse->index >= ARRAY_SIZE(tegra_csi_tpg_sizes))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra_csi_tpg_fmts); i++)\n\t\tif (fse->code == tegra_csi_tpg_fmts[i].code)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(tegra_csi_tpg_fmts))\n\t\treturn -EINVAL;\n\n\tfse->min_width = tegra_csi_tpg_sizes[fse->index].width;\n\tfse->max_width = tegra_csi_tpg_sizes[fse->index].width;\n\tfse->min_height = tegra_csi_tpg_sizes[fse->index].height;\n\tfse->max_height = tegra_csi_tpg_sizes[fse->index].height;\n\n\treturn 0;\n}\n\nstatic int csi_enum_frameintervals(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_interval_enum *fie)\n{\n\tstruct tegra_csi_channel *csi_chan = to_csi_chan(subdev);\n\tstruct tegra_csi *csi = csi_chan->csi;\n\tconst struct tpg_framerate *frmrate = csi->soc->tpg_frmrate_table;\n\tint index;\n\n\tif (!IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\treturn -ENOIOCTLCMD;\n\n\t \n\tif (fie->index > 0)\n\t\treturn -EINVAL;\n\n\tindex = csi_get_frmrate_table_index(csi_chan->csi, fie->code,\n\t\t\t\t\t    fie->width, fie->height);\n\tif (index < 0)\n\t\treturn -EINVAL;\n\n\tfie->interval.numerator = 1;\n\tfie->interval.denominator = frmrate[index].framerate;\n\n\treturn 0;\n}\n\nstatic int csi_set_format(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct tegra_csi_channel *csi_chan = to_csi_chan(subdev);\n\tstruct v4l2_mbus_framefmt *format = &fmt->format;\n\tconst struct v4l2_frmsize_discrete *sizes;\n\tunsigned int i;\n\n\tif (!IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\treturn -ENOIOCTLCMD;\n\n\tsizes = v4l2_find_nearest_size(tegra_csi_tpg_sizes,\n\t\t\t\t       ARRAY_SIZE(tegra_csi_tpg_sizes),\n\t\t\t\t       width, height,\n\t\t\t\t       format->width, format->width);\n\tformat->width = sizes->width;\n\tformat->height = sizes->height;\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra_csi_tpg_fmts); i++)\n\t\tif (format->code == tegra_csi_tpg_fmts[i].code)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(tegra_csi_tpg_fmts))\n\t\ti = 0;\n\n\tformat->code = tegra_csi_tpg_fmts[i].code;\n\tformat->field = V4L2_FIELD_NONE;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn 0;\n\n\t \n\tcsi_chan_update_blank_intervals(csi_chan, format->code,\n\t\t\t\t\tformat->width, format->height);\n\tcsi_chan->format = *format;\n\n\treturn 0;\n}\n\n \nstatic int tegra_csi_g_frame_interval(struct v4l2_subdev *subdev,\n\t\t\t\t      struct v4l2_subdev_frame_interval *vfi)\n{\n\tstruct tegra_csi_channel *csi_chan = to_csi_chan(subdev);\n\n\tif (!IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\treturn -ENOIOCTLCMD;\n\n\tvfi->interval.numerator = 1;\n\tvfi->interval.denominator = csi_chan->framerate;\n\n\treturn 0;\n}\n\nstatic unsigned int csi_get_pixel_rate(struct tegra_csi_channel *csi_chan)\n{\n\tstruct tegra_vi_channel *chan;\n\tstruct v4l2_subdev *src_subdev;\n\tstruct v4l2_ctrl *ctrl;\n\n\tchan = v4l2_get_subdev_hostdata(&csi_chan->subdev);\n\tsrc_subdev = tegra_channel_get_remote_source_subdev(chan);\n\tctrl = v4l2_ctrl_find(src_subdev->ctrl_handler, V4L2_CID_PIXEL_RATE);\n\tif (ctrl)\n\t\treturn v4l2_ctrl_g_ctrl_int64(ctrl);\n\n\treturn 0;\n}\n\nvoid tegra_csi_calc_settle_time(struct tegra_csi_channel *csi_chan,\n\t\t\t\tu8 csi_port_num,\n\t\t\t\tu8 *clk_settle_time,\n\t\t\t\tu8 *ths_settle_time)\n{\n\tstruct tegra_csi *csi = csi_chan->csi;\n\tunsigned int cil_clk_mhz;\n\tunsigned int pix_clk_mhz;\n\tint clk_idx = (csi_port_num >> 1) + 1;\n\n\tcil_clk_mhz = clk_get_rate(csi->clks[clk_idx].clk) / MHZ;\n\tpix_clk_mhz = csi_get_pixel_rate(csi_chan) / MHZ;\n\n\t \n\t*clk_settle_time = ((95 + 300) * cil_clk_mhz - 14000) / 2000;\n\n\t \n\tif (pix_clk_mhz)\n\t\t*ths_settle_time = (115 * cil_clk_mhz + 8000 * cil_clk_mhz\n\t\t\t\t   / (2 * pix_clk_mhz) - 5000) / 1000;\n}\n\nstatic int tegra_csi_enable_stream(struct v4l2_subdev *subdev)\n{\n\tstruct tegra_vi_channel *chan = v4l2_get_subdev_hostdata(subdev);\n\tstruct tegra_csi_channel *csi_chan = to_csi_chan(subdev);\n\tstruct tegra_csi *csi = csi_chan->csi;\n\tint ret, err;\n\n\tret = pm_runtime_resume_and_get(csi->dev);\n\tif (ret < 0) {\n\t\tdev_err(csi->dev, \"failed to get runtime PM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (csi_chan->mipi) {\n\t\tret = tegra_mipi_enable(csi_chan->mipi);\n\t\tif (ret < 0) {\n\t\t\tdev_err(csi->dev,\n\t\t\t\t\"failed to enable MIPI pads: %d\\n\", ret);\n\t\t\tgoto rpm_put;\n\t\t}\n\n\t\t \n\t\tret = tegra_mipi_start_calibration(csi_chan->mipi);\n\t\tif (ret < 0) {\n\t\t\tdev_err(csi->dev,\n\t\t\t\t\"failed to start MIPI calibration: %d\\n\", ret);\n\t\t\tgoto disable_mipi;\n\t\t}\n\t}\n\n\tcsi_chan->pg_mode = chan->pg_mode;\n\n\t \n\tret = csi->ops->csi_start_streaming(csi_chan);\n\tif (ret < 0)\n\t\tgoto finish_calibration;\n\n\tif (csi_chan->mipi) {\n\t\tstruct v4l2_subdev *src_subdev;\n\t\t \n\t\tsrc_subdev = tegra_channel_get_remote_source_subdev(chan);\n\t\tret = v4l2_subdev_call(src_subdev, video, s_stream, true);\n\n\t\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\t\tgoto disable_csi_stream;\n\n\t\terr = tegra_mipi_finish_calibration(csi_chan->mipi);\n\t\tif (err < 0)\n\t\t\tdev_warn(csi->dev, \"MIPI calibration failed: %d\\n\", err);\n\t}\n\n\treturn 0;\n\ndisable_csi_stream:\n\tcsi->ops->csi_stop_streaming(csi_chan);\nfinish_calibration:\n\tif (csi_chan->mipi)\n\t\ttegra_mipi_finish_calibration(csi_chan->mipi);\ndisable_mipi:\n\tif (csi_chan->mipi) {\n\t\terr = tegra_mipi_disable(csi_chan->mipi);\n\t\tif (err < 0)\n\t\t\tdev_err(csi->dev,\n\t\t\t\t\"failed to disable MIPI pads: %d\\n\", err);\n\t}\n\nrpm_put:\n\tpm_runtime_put(csi->dev);\n\treturn ret;\n}\n\nstatic int tegra_csi_disable_stream(struct v4l2_subdev *subdev)\n{\n\tstruct tegra_vi_channel *chan = v4l2_get_subdev_hostdata(subdev);\n\tstruct tegra_csi_channel *csi_chan = to_csi_chan(subdev);\n\tstruct tegra_csi *csi = csi_chan->csi;\n\tint err;\n\n\t \n\tif (csi_chan->mipi) {\n\t\tstruct v4l2_subdev *src_subdev;\n\n\t\tsrc_subdev = tegra_channel_get_remote_source_subdev(chan);\n\t\terr = v4l2_subdev_call(src_subdev, video, s_stream, false);\n\t\tif (err < 0 && err != -ENOIOCTLCMD)\n\t\t\tdev_err_probe(csi->dev, err, \"source subdev stream off failed\\n\");\n\t}\n\n\tcsi->ops->csi_stop_streaming(csi_chan);\n\n\tif (csi_chan->mipi) {\n\t\terr = tegra_mipi_disable(csi_chan->mipi);\n\t\tif (err < 0)\n\t\t\tdev_err(csi->dev,\n\t\t\t\t\"failed to disable MIPI pads: %d\\n\", err);\n\t}\n\n\tpm_runtime_put(csi->dev);\n\n\treturn 0;\n}\n\nstatic int tegra_csi_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tint ret;\n\n\tif (enable)\n\t\tret = tegra_csi_enable_stream(subdev);\n\telse\n\t\tret = tegra_csi_disable_stream(subdev);\n\n\treturn ret;\n}\n\n \nstatic const struct v4l2_subdev_video_ops tegra_csi_video_ops = {\n\t.s_stream = tegra_csi_s_stream,\n\t.g_frame_interval = tegra_csi_g_frame_interval,\n\t.s_frame_interval = tegra_csi_g_frame_interval,\n};\n\nstatic const struct v4l2_subdev_pad_ops tegra_csi_pad_ops = {\n\t.enum_mbus_code\t\t= csi_enum_bus_code,\n\t.enum_frame_size\t= csi_enum_framesizes,\n\t.enum_frame_interval\t= csi_enum_frameintervals,\n\t.get_fmt\t\t= csi_get_format,\n\t.set_fmt\t\t= csi_set_format,\n};\n\nstatic const struct v4l2_subdev_ops tegra_csi_ops = {\n\t.video  = &tegra_csi_video_ops,\n\t.pad    = &tegra_csi_pad_ops,\n};\n\nstatic int tegra_csi_channel_alloc(struct tegra_csi *csi,\n\t\t\t\t   struct device_node *node,\n\t\t\t\t   unsigned int port_num, unsigned int lanes,\n\t\t\t\t   unsigned int num_pads)\n{\n\tstruct tegra_csi_channel *chan;\n\tint ret = 0, i;\n\n\tchan = kzalloc(sizeof(*chan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&chan->list, &csi->csi_chans);\n\tchan->csi = csi;\n\t \n\tif (lanes <= CSI_LANES_PER_BRICK) {\n\t\tchan->numlanes = lanes;\n\t\tchan->numgangports = 1;\n\t} else {\n\t\tchan->numlanes = CSI_LANES_PER_BRICK;\n\t\tchan->numgangports = lanes / CSI_LANES_PER_BRICK;\n\t}\n\n\tfor (i = 0; i < chan->numgangports; i++)\n\t\tchan->csi_port_nums[i] = port_num + i * CSI_PORTS_PER_BRICK;\n\n\tchan->of_node = of_node_get(node);\n\tchan->numpads = num_pads;\n\tif (num_pads & 0x2) {\n\t\tchan->pads[0].flags = MEDIA_PAD_FL_SINK;\n\t\tchan->pads[1].flags = MEDIA_PAD_FL_SOURCE;\n\t} else {\n\t\tchan->pads[0].flags = MEDIA_PAD_FL_SOURCE;\n\t}\n\n\tif (IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\treturn 0;\n\n\tchan->mipi = tegra_mipi_request(csi->dev, node);\n\tif (IS_ERR(chan->mipi)) {\n\t\tret = PTR_ERR(chan->mipi);\n\t\tchan->mipi = NULL;\n\t\tdev_err(csi->dev, \"failed to get mipi device: %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int tegra_csi_tpg_channels_alloc(struct tegra_csi *csi)\n{\n\tstruct device_node *node = csi->dev->of_node;\n\tunsigned int port_num;\n\tunsigned int tpg_channels = csi->soc->csi_max_channels;\n\tint ret;\n\n\t \n\tfor (port_num = 0; port_num < tpg_channels; port_num++) {\n\t\tret = tegra_csi_channel_alloc(csi, node, port_num, 2, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_csi_channels_alloc(struct tegra_csi *csi)\n{\n\tstruct device_node *node = csi->dev->of_node;\n\tstruct v4l2_fwnode_endpoint v4l2_ep = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY\n\t};\n\tstruct fwnode_handle *fwh;\n\tstruct device_node *channel;\n\tstruct device_node *ep;\n\tunsigned int lanes, portno, num_pads;\n\tint ret;\n\n\tfor_each_child_of_node(node, channel) {\n\t\tif (!of_node_name_eq(channel, \"channel\"))\n\t\t\tcontinue;\n\n\t\tret = of_property_read_u32(channel, \"reg\", &portno);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tif (portno >= csi->soc->csi_max_channels) {\n\t\t\tdev_err(csi->dev, \"invalid port num %d for %pOF\\n\",\n\t\t\t\tportno, channel);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tep = of_graph_get_endpoint_by_regs(channel, 0, 0);\n\t\tif (!ep)\n\t\t\tcontinue;\n\n\t\tfwh = of_fwnode_handle(ep);\n\t\tret = v4l2_fwnode_endpoint_parse(fwh, &v4l2_ep);\n\t\tof_node_put(ep);\n\t\tif (ret) {\n\t\t\tdev_err(csi->dev,\n\t\t\t\t\"failed to parse v4l2 endpoint for %pOF: %d\\n\",\n\t\t\t\tchannel, ret);\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tlanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;\n\t\t \n\t\tif (!lanes || ((lanes & (lanes - 1)) != 0) ||\n\t\t    (lanes > CSI_LANES_PER_BRICK && ((portno & 1) != 0))) {\n\t\t\tdev_err(csi->dev, \"invalid data-lanes %d for %pOF\\n\",\n\t\t\t\tlanes, channel);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tnum_pads = of_graph_get_endpoint_count(channel);\n\t\tif (num_pads == TEGRA_CSI_PADS_NUM) {\n\t\t\tret = tegra_csi_channel_alloc(csi, channel, portno,\n\t\t\t\t\t\t      lanes, num_pads);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_node_put;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_node_put:\n\tof_node_put(channel);\n\treturn ret;\n}\n\nstatic int tegra_csi_channel_init(struct tegra_csi_channel *chan)\n{\n\tstruct tegra_csi *csi = chan->csi;\n\tstruct v4l2_subdev *subdev;\n\tint ret;\n\n\t \n\tchan->format.code = MEDIA_BUS_FMT_SRGGB10_1X10;\n\tchan->format.field = V4L2_FIELD_NONE;\n\tchan->format.colorspace = V4L2_COLORSPACE_SRGB;\n\tchan->format.width = TEGRA_DEF_WIDTH;\n\tchan->format.height = TEGRA_DEF_HEIGHT;\n\tcsi_chan_update_blank_intervals(chan, chan->format.code,\n\t\t\t\t\tchan->format.width,\n\t\t\t\t\tchan->format.height);\n\t \n\tsubdev = &chan->subdev;\n\tv4l2_subdev_init(subdev, &tegra_csi_ops);\n\tsubdev->dev = csi->dev;\n\tif (IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\tsnprintf(subdev->name, V4L2_SUBDEV_NAME_SIZE, \"%s-%d\", \"tpg\",\n\t\t\t chan->csi_port_nums[0]);\n\telse\n\t\tsnprintf(subdev->name, V4L2_SUBDEV_NAME_SIZE, \"%s\",\n\t\t\t kbasename(chan->of_node->full_name));\n\n\tv4l2_set_subdevdata(subdev, chan);\n\tsubdev->fwnode = of_fwnode_handle(chan->of_node);\n\tsubdev->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\n\t \n\tret = media_entity_pads_init(&subdev->entity, chan->numpads,\n\t\t\t\t     chan->pads);\n\tif (ret < 0) {\n\t\tdev_err(csi->dev,\n\t\t\t\"failed to initialize media entity: %d\\n\", ret);\n\t\tsubdev->dev = NULL;\n\t\treturn ret;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG)) {\n\t\tret = v4l2_async_register_subdev(subdev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(csi->dev,\n\t\t\t\t\"failed to register subdev: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid tegra_csi_error_recover(struct v4l2_subdev *sd)\n{\n\tstruct tegra_csi_channel *csi_chan = to_csi_chan(sd);\n\tstruct tegra_csi *csi = csi_chan->csi;\n\n\t \n\tcsi->ops->csi_stop_streaming(csi_chan);\n\tcsi->ops->csi_err_recover(csi_chan);\n\tcsi->ops->csi_start_streaming(csi_chan);\n}\n\nstatic int tegra_csi_channels_init(struct tegra_csi *csi)\n{\n\tstruct tegra_csi_channel *chan;\n\tint ret;\n\n\tlist_for_each_entry(chan, &csi->csi_chans, list) {\n\t\tret = tegra_csi_channel_init(chan);\n\t\tif (ret) {\n\t\t\tdev_err(csi->dev,\n\t\t\t\t\"failed to initialize channel-%d: %d\\n\",\n\t\t\t\tchan->csi_port_nums[0], ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_csi_channels_cleanup(struct tegra_csi *csi)\n{\n\tstruct v4l2_subdev *subdev;\n\tstruct tegra_csi_channel *chan, *tmp;\n\n\tlist_for_each_entry_safe(chan, tmp, &csi->csi_chans, list) {\n\t\tif (chan->mipi)\n\t\t\ttegra_mipi_free(chan->mipi);\n\n\t\tsubdev = &chan->subdev;\n\t\tif (subdev->dev) {\n\t\t\tif (!IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\t\t\tv4l2_async_unregister_subdev(subdev);\n\t\t\tmedia_entity_cleanup(&subdev->entity);\n\t\t}\n\n\t\tof_node_put(chan->of_node);\n\t\tlist_del(&chan->list);\n\t\tkfree(chan);\n\t}\n}\n\nstatic int __maybe_unused csi_runtime_suspend(struct device *dev)\n{\n\tstruct tegra_csi *csi = dev_get_drvdata(dev);\n\n\tclk_bulk_disable_unprepare(csi->soc->num_clks, csi->clks);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused csi_runtime_resume(struct device *dev)\n{\n\tstruct tegra_csi *csi = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(csi->soc->num_clks, csi->clks);\n\tif (ret < 0) {\n\t\tdev_err(csi->dev, \"failed to enable clocks: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_csi_init(struct host1x_client *client)\n{\n\tstruct tegra_csi *csi = host1x_client_to_csi(client);\n\tstruct tegra_video_device *vid = dev_get_drvdata(client->host);\n\tint ret;\n\n\tINIT_LIST_HEAD(&csi->csi_chans);\n\n\tif (IS_ENABLED(CONFIG_VIDEO_TEGRA_TPG))\n\t\tret = tegra_csi_tpg_channels_alloc(csi);\n\telse\n\t\tret = tegra_csi_channels_alloc(csi);\n\tif (ret < 0) {\n\t\tdev_err(csi->dev,\n\t\t\t\"failed to allocate channels: %d\\n\", ret);\n\t\tgoto cleanup;\n\t}\n\n\tret = tegra_csi_channels_init(csi);\n\tif (ret < 0)\n\t\tgoto cleanup;\n\n\tvid->csi = csi;\n\n\treturn 0;\n\ncleanup:\n\ttegra_csi_channels_cleanup(csi);\n\treturn ret;\n}\n\nstatic int tegra_csi_exit(struct host1x_client *client)\n{\n\tstruct tegra_csi *csi = host1x_client_to_csi(client);\n\n\ttegra_csi_channels_cleanup(csi);\n\n\treturn 0;\n}\n\nstatic const struct host1x_client_ops csi_client_ops = {\n\t.init = tegra_csi_init,\n\t.exit = tegra_csi_exit,\n};\n\nstatic int tegra_csi_probe(struct platform_device *pdev)\n{\n\tstruct tegra_csi *csi;\n\tunsigned int i;\n\tint ret;\n\n\tcsi = devm_kzalloc(&pdev->dev, sizeof(*csi), GFP_KERNEL);\n\tif (!csi)\n\t\treturn -ENOMEM;\n\n\tcsi->iomem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(csi->iomem))\n\t\treturn PTR_ERR(csi->iomem);\n\n\tcsi->soc = of_device_get_match_data(&pdev->dev);\n\n\tcsi->clks = devm_kcalloc(&pdev->dev, csi->soc->num_clks,\n\t\t\t\t sizeof(*csi->clks), GFP_KERNEL);\n\tif (!csi->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < csi->soc->num_clks; i++)\n\t\tcsi->clks[i].id = csi->soc->clk_names[i];\n\n\tret = devm_clk_bulk_get(&pdev->dev, csi->soc->num_clks, csi->clks);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to get the clocks: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!pdev->dev.pm_domain) {\n\t\tret = -ENOENT;\n\t\tdev_warn(&pdev->dev, \"PM domain is not attached: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcsi->dev = &pdev->dev;\n\tcsi->ops = csi->soc->ops;\n\tplatform_set_drvdata(pdev, csi);\n\tpm_runtime_enable(&pdev->dev);\n\n\t \n\tINIT_LIST_HEAD(&csi->client.list);\n\tcsi->client.ops = &csi_client_ops;\n\tcsi->client.dev = &pdev->dev;\n\n\tret = host1x_client_register(&csi->client);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to register host1x client: %d\\n\", ret);\n\t\tgoto rpm_disable;\n\t}\n\n\treturn 0;\n\nrpm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic int tegra_csi_remove(struct platform_device *pdev)\n{\n\tstruct tegra_csi *csi = platform_get_drvdata(pdev);\n\n\thost1x_client_unregister(&csi->client);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\n#if defined(CONFIG_ARCH_TEGRA_210_SOC)\nextern const struct tegra_csi_soc tegra210_csi_soc;\n#endif\n\nstatic const struct of_device_id tegra_csi_of_id_table[] = {\n#if defined(CONFIG_ARCH_TEGRA_210_SOC)\n\t{ .compatible = \"nvidia,tegra210-csi\", .data = &tegra210_csi_soc },\n#endif\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_csi_of_id_table);\n\nstatic const struct dev_pm_ops tegra_csi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(csi_runtime_suspend, csi_runtime_resume, NULL)\n};\n\nstruct platform_driver tegra_csi_driver = {\n\t.driver = {\n\t\t.name\t\t= \"tegra-csi\",\n\t\t.of_match_table\t= tegra_csi_of_id_table,\n\t\t.pm\t\t= &tegra_csi_pm_ops,\n\t},\n\t.probe\t\t\t= tegra_csi_probe,\n\t.remove\t\t\t= tegra_csi_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}