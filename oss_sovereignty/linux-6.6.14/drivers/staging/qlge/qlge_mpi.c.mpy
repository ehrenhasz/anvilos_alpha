{
  "module_name": "qlge_mpi.c",
  "hash_id": "bb6e3a837d39a2172aac282a229be25f2aa96db7a4921758847e532dbcf05e4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/qlge/qlge_mpi.c",
  "human_readable_source": "\n#include \"qlge.h\"\n\nint qlge_unpause_mpi_risc(struct qlge_adapter *qdev)\n{\n\tu32 tmp;\n\n\t \n\ttmp = qlge_read32(qdev, CSR);\n\tif (!(tmp & CSR_RP))\n\t\treturn -EIO;\n\n\tqlge_write32(qdev, CSR, CSR_CMD_CLR_PAUSE);\n\treturn 0;\n}\n\nint qlge_pause_mpi_risc(struct qlge_adapter *qdev)\n{\n\tu32 tmp;\n\tint count;\n\n\t \n\tqlge_write32(qdev, CSR, CSR_CMD_SET_PAUSE);\n\tfor (count = UDELAY_COUNT; count; count--) {\n\t\ttmp = qlge_read32(qdev, CSR);\n\t\tif (tmp & CSR_RP)\n\t\t\tbreak;\n\t\tmdelay(UDELAY_DELAY);\n\t}\n\treturn (count == 0) ? -ETIMEDOUT : 0;\n}\n\nint qlge_hard_reset_mpi_risc(struct qlge_adapter *qdev)\n{\n\tu32 tmp;\n\tint count;\n\n\t \n\tqlge_write32(qdev, CSR, CSR_CMD_SET_RST);\n\tfor (count = UDELAY_COUNT; count; count--) {\n\t\ttmp = qlge_read32(qdev, CSR);\n\t\tif (tmp & CSR_RR) {\n\t\t\tqlge_write32(qdev, CSR, CSR_CMD_CLR_RST);\n\t\t\tbreak;\n\t\t}\n\t\tmdelay(UDELAY_DELAY);\n\t}\n\treturn (count == 0) ? -ETIMEDOUT : 0;\n}\n\nint qlge_read_mpi_reg(struct qlge_adapter *qdev, u32 reg, u32 *data)\n{\n\tint status;\n\t \n\tstatus = qlge_wait_reg_rdy(qdev, PROC_ADDR, PROC_ADDR_RDY, PROC_ADDR_ERR);\n\tif (status)\n\t\tgoto exit;\n\t \n\tqlge_write32(qdev, PROC_ADDR, reg | PROC_ADDR_R);\n\t \n\tstatus = qlge_wait_reg_rdy(qdev, PROC_ADDR, PROC_ADDR_RDY, PROC_ADDR_ERR);\n\tif (status)\n\t\tgoto exit;\n\t \n\t*data = qlge_read32(qdev, PROC_DATA);\nexit:\n\treturn status;\n}\n\nint qlge_write_mpi_reg(struct qlge_adapter *qdev, u32 reg, u32 data)\n{\n\tint status = 0;\n\t \n\tstatus = qlge_wait_reg_rdy(qdev, PROC_ADDR, PROC_ADDR_RDY, PROC_ADDR_ERR);\n\tif (status)\n\t\tgoto exit;\n\t \n\tqlge_write32(qdev, PROC_DATA, data);\n\t \n\tqlge_write32(qdev, PROC_ADDR, reg);\n\t \n\tstatus = qlge_wait_reg_rdy(qdev, PROC_ADDR, PROC_ADDR_RDY, PROC_ADDR_ERR);\n\tif (status)\n\t\tgoto exit;\nexit:\n\treturn status;\n}\n\nint qlge_soft_reset_mpi_risc(struct qlge_adapter *qdev)\n{\n\treturn qlge_write_mpi_reg(qdev, 0x00001010, 1);\n}\n\n \nint qlge_own_firmware(struct qlge_adapter *qdev)\n{\n\tu32 temp;\n\n\t \n\tif (qdev->func < qdev->alt_func)\n\t\treturn 1;\n\n\t \n\ttemp =  qlge_read32(qdev, STS);\n\tif (!(temp & (1 << (8 + qdev->alt_func))))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int qlge_get_mb_sts(struct qlge_adapter *qdev, struct mbox_params *mbcp)\n{\n\tint i, status;\n\n\tstatus = qlge_sem_spinlock(qdev, SEM_PROC_REG_MASK);\n\tif (status)\n\t\treturn -EBUSY;\n\tfor (i = 0; i < mbcp->out_count; i++) {\n\t\tstatus =\n\t\t    qlge_read_mpi_reg(qdev, qdev->mailbox_out + i,\n\t\t\t\t      &mbcp->mbox_out[i]);\n\t\tif (status) {\n\t\t\tnetif_err(qdev, drv, qdev->ndev, \"Failed mailbox read.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tqlge_sem_unlock(qdev, SEM_PROC_REG_MASK);\t \n\treturn status;\n}\n\n \nstatic int qlge_wait_mbx_cmd_cmplt(struct qlge_adapter *qdev)\n{\n\tint count;\n\tu32 value;\n\n\tfor (count = 100; count; count--) {\n\t\tvalue = qlge_read32(qdev, STS);\n\t\tif (value & STS_PI)\n\t\t\treturn 0;\n\t\tmdelay(UDELAY_DELAY);  \n\t}\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int qlge_exec_mb_cmd(struct qlge_adapter *qdev, struct mbox_params *mbcp)\n{\n\tint i, status;\n\n\t \n\tif (qlge_read32(qdev, CSR) & CSR_HRI)\n\t\treturn -EIO;\n\n\tstatus = qlge_sem_spinlock(qdev, SEM_PROC_REG_MASK);\n\tif (status)\n\t\treturn status;\n\n\t \n\tfor (i = 0; i < mbcp->in_count; i++) {\n\t\tstatus = qlge_write_mpi_reg(qdev, qdev->mailbox_in + i,\n\t\t\t\t\t    mbcp->mbox_in[i]);\n\t\tif (status)\n\t\t\tgoto end;\n\t}\n\t \n\tqlge_write32(qdev, CSR, CSR_CMD_SET_H2R_INT);\nend:\n\tqlge_sem_unlock(qdev, SEM_PROC_REG_MASK);\n\treturn status;\n}\n\n \nstatic int qlge_idc_req_aen(struct qlge_adapter *qdev)\n{\n\tint status;\n\tstruct mbox_params *mbcp = &qdev->idc_mbc;\n\n\tnetif_err(qdev, drv, qdev->ndev, \"Enter!\\n\");\n\t \n\tmbcp->out_count = 4;\n\tstatus = qlge_get_mb_sts(qdev, mbcp);\n\tif (status) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Could not read MPI, resetting ASIC!\\n\");\n\t\tqlge_queue_asic_error(qdev);\n\t} else\t{\n\t\t \n\t\tqlge_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16));\n\t\tqueue_delayed_work(qdev->workqueue, &qdev->mpi_idc_work, 0);\n\t}\n\treturn status;\n}\n\n \nstatic int qlge_idc_cmplt_aen(struct qlge_adapter *qdev)\n{\n\tint status;\n\tstruct mbox_params *mbcp = &qdev->idc_mbc;\n\n\tmbcp->out_count = 4;\n\tstatus = qlge_get_mb_sts(qdev, mbcp);\n\tif (status) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Could not read MPI, resetting RISC!\\n\");\n\t\tqlge_queue_fw_error(qdev);\n\t} else {\n\t\t \n\t\tcomplete(&qdev->ide_completion);\n\t}\n\treturn status;\n}\n\nstatic void qlge_link_up(struct qlge_adapter *qdev, struct mbox_params *mbcp)\n{\n\tint status;\n\n\tmbcp->out_count = 2;\n\n\tstatus = qlge_get_mb_sts(qdev, mbcp);\n\tif (status) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"%s: Could not get mailbox status.\\n\", __func__);\n\t\treturn;\n\t}\n\n\tqdev->link_status = mbcp->mbox_out[1];\n\tnetif_err(qdev, drv, qdev->ndev, \"Link Up.\\n\");\n\n\t \n\tif (test_bit(QL_CAM_RT_SET, &qdev->flags)) {\n\t\tstatus = qlge_cam_route_initialize(qdev);\n\t\tif (status) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"Failed to init CAM/Routing tables.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tclear_bit(QL_CAM_RT_SET, &qdev->flags);\n\t}\n\n\t \n\tif (!test_bit(QL_PORT_CFG, &qdev->flags)) {\n\t\tnetif_err(qdev, drv, qdev->ndev, \"Queue Port Config Worker!\\n\");\n\t\tset_bit(QL_PORT_CFG, &qdev->flags);\n\t\t \n\t\tqlge_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16));\n\t\tqueue_delayed_work(qdev->workqueue,\n\t\t\t\t   &qdev->mpi_port_cfg_work, 0);\n\t}\n\n\tqlge_link_on(qdev);\n}\n\nstatic void qlge_link_down(struct qlge_adapter *qdev, struct mbox_params *mbcp)\n{\n\tint status;\n\n\tmbcp->out_count = 3;\n\n\tstatus = qlge_get_mb_sts(qdev, mbcp);\n\tif (status)\n\t\tnetif_err(qdev, drv, qdev->ndev, \"Link down AEN broken!\\n\");\n\n\tqlge_link_off(qdev);\n}\n\nstatic int qlge_sfp_in(struct qlge_adapter *qdev, struct mbox_params *mbcp)\n{\n\tint status;\n\n\tmbcp->out_count = 5;\n\n\tstatus = qlge_get_mb_sts(qdev, mbcp);\n\tif (status)\n\t\tnetif_err(qdev, drv, qdev->ndev, \"SFP in AEN broken!\\n\");\n\telse\n\t\tnetif_err(qdev, drv, qdev->ndev, \"SFP insertion detected.\\n\");\n\n\treturn status;\n}\n\nstatic int qlge_sfp_out(struct qlge_adapter *qdev, struct mbox_params *mbcp)\n{\n\tint status;\n\n\tmbcp->out_count = 1;\n\n\tstatus = qlge_get_mb_sts(qdev, mbcp);\n\tif (status)\n\t\tnetif_err(qdev, drv, qdev->ndev, \"SFP out AEN broken!\\n\");\n\telse\n\t\tnetif_err(qdev, drv, qdev->ndev, \"SFP removal detected.\\n\");\n\n\treturn status;\n}\n\nstatic int qlge_aen_lost(struct qlge_adapter *qdev, struct mbox_params *mbcp)\n{\n\tint status;\n\n\tmbcp->out_count = 6;\n\n\tstatus = qlge_get_mb_sts(qdev, mbcp);\n\tif (status) {\n\t\tnetif_err(qdev, drv, qdev->ndev, \"Lost AEN broken!\\n\");\n\t} else {\n\t\tint i;\n\n\t\tnetif_err(qdev, drv, qdev->ndev, \"Lost AEN detected.\\n\");\n\t\tfor (i = 0; i < mbcp->out_count; i++)\n\t\t\tnetif_err(qdev, drv, qdev->ndev, \"mbox_out[%d] = 0x%.08x.\\n\",\n\t\t\t\t  i, mbcp->mbox_out[i]);\n\t}\n\n\treturn status;\n}\n\nstatic void qlge_init_fw_done(struct qlge_adapter *qdev, struct mbox_params *mbcp)\n{\n\tint status;\n\n\tmbcp->out_count = 2;\n\n\tstatus = qlge_get_mb_sts(qdev, mbcp);\n\tif (status) {\n\t\tnetif_err(qdev, drv, qdev->ndev, \"Firmware did not initialize!\\n\");\n\t} else {\n\t\tnetif_err(qdev, drv, qdev->ndev, \"Firmware Revision  = 0x%.08x.\\n\",\n\t\t\t  mbcp->mbox_out[1]);\n\t\tqdev->fw_rev_id = mbcp->mbox_out[1];\n\t\tstatus = qlge_cam_route_initialize(qdev);\n\t\tif (status)\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"Failed to init CAM/Routing tables.\\n\");\n\t}\n}\n\n \nstatic int qlge_mpi_handler(struct qlge_adapter *qdev, struct mbox_params *mbcp)\n{\n\tint status;\n\tint orig_count = mbcp->out_count;\n\n\t \n\tmbcp->out_count = 1;\n\tstatus = qlge_get_mb_sts(qdev, mbcp);\n\tif (status) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Could not read MPI, resetting ASIC!\\n\");\n\t\tqlge_queue_asic_error(qdev);\n\t\tgoto end;\n\t}\n\n\tswitch (mbcp->mbox_out[0]) {\n\t\t \n\tcase MB_CMD_STS_INTRMDT:\n\tcase MB_CMD_STS_GOOD:\n\tcase MB_CMD_STS_INVLD_CMD:\n\tcase MB_CMD_STS_XFC_ERR:\n\tcase MB_CMD_STS_CSUM_ERR:\n\tcase MB_CMD_STS_ERR:\n\tcase MB_CMD_STS_PARAM_ERR:\n\t\t \n\t\tmbcp->out_count = orig_count;\n\t\tstatus = qlge_get_mb_sts(qdev, mbcp);\n\t\treturn status;\n\n\t\t \n\tcase AEN_IDC_REQ:\n\t\tstatus = qlge_idc_req_aen(qdev);\n\t\tbreak;\n\n\t\t \n\tcase AEN_IDC_CMPLT:\n\tcase AEN_IDC_EXT:\n\t\tstatus = qlge_idc_cmplt_aen(qdev);\n\t\tbreak;\n\n\tcase AEN_LINK_UP:\n\t\tqlge_link_up(qdev, mbcp);\n\t\tbreak;\n\n\tcase AEN_LINK_DOWN:\n\t\tqlge_link_down(qdev, mbcp);\n\t\tbreak;\n\n\tcase AEN_FW_INIT_DONE:\n\t\t \n\t\tif (mbcp->mbox_in[0] == MB_CMD_EX_FW) {\n\t\t\tmbcp->out_count = orig_count;\n\t\t\tstatus = qlge_get_mb_sts(qdev, mbcp);\n\t\t\tmbcp->mbox_out[0] = MB_CMD_STS_GOOD;\n\t\t\treturn status;\n\t\t}\n\t\tqlge_init_fw_done(qdev, mbcp);\n\t\tbreak;\n\n\tcase AEN_AEN_SFP_IN:\n\t\tqlge_sfp_in(qdev, mbcp);\n\t\tbreak;\n\n\tcase AEN_AEN_SFP_OUT:\n\t\tqlge_sfp_out(qdev, mbcp);\n\t\tbreak;\n\n\t\t \n\tcase AEN_FW_INIT_FAIL:\n\t\t \n\t\tif (mbcp->mbox_in[0] == MB_CMD_EX_FW) {\n\t\t\tmbcp->out_count = orig_count;\n\t\t\tstatus = qlge_get_mb_sts(qdev, mbcp);\n\t\t\tmbcp->mbox_out[0] = MB_CMD_STS_ERR;\n\t\t\treturn status;\n\t\t}\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Firmware initialization failed.\\n\");\n\t\tstatus = -EIO;\n\t\tqlge_queue_fw_error(qdev);\n\t\tbreak;\n\n\tcase AEN_SYS_ERR:\n\t\tnetif_err(qdev, drv, qdev->ndev, \"System Error.\\n\");\n\t\tqlge_queue_fw_error(qdev);\n\t\tstatus = -EIO;\n\t\tbreak;\n\n\tcase AEN_AEN_LOST:\n\t\tqlge_aen_lost(qdev, mbcp);\n\t\tbreak;\n\n\tcase AEN_DCBX_CHG:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Unsupported AE %.08x.\\n\", mbcp->mbox_out[0]);\n\t\t \n\t}\nend:\n\tqlge_write32(qdev, CSR, CSR_CMD_CLR_R2PCI_INT);\n\t \n\tmbcp->out_count = orig_count;\n\treturn status;\n}\n\n \nstatic int qlge_mailbox_command(struct qlge_adapter *qdev, struct mbox_params *mbcp)\n{\n\tint status;\n\tunsigned long count;\n\n\tmutex_lock(&qdev->mpi_mutex);\n\n\t \n\tqlge_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16));\n\n\t \n\tstatus = qlge_exec_mb_cmd(qdev, mbcp);\n\tif (status)\n\t\tgoto end;\n\n\t \n\tif (mbcp->mbox_in[0] == MB_CMD_MAKE_SYS_ERR)\n\t\tgoto end;\n\n\t \n\tcount = jiffies + HZ * MAILBOX_TIMEOUT;\n\tdo {\n\t\t \n\t\tstatus = qlge_wait_mbx_cmd_cmplt(qdev);\n\t\tif (status)\n\t\t\tcontinue;\n\n\t\t \n\t\tstatus = qlge_mpi_handler(qdev, mbcp);\n\t\tif (status)\n\t\t\tgoto end;\n\n\t\t \n\t\tif (((mbcp->mbox_out[0] & 0x0000f000) ==\n\t\t     MB_CMD_STS_GOOD) ||\n\t\t    ((mbcp->mbox_out[0] & 0x0000f000) ==\n\t\t     MB_CMD_STS_INTRMDT))\n\t\t\tgoto done;\n\t} while (time_before(jiffies, count));\n\n\tnetif_err(qdev, drv, qdev->ndev,\n\t\t  \"Timed out waiting for mailbox complete.\\n\");\n\tstatus = -ETIMEDOUT;\n\tgoto end;\n\ndone:\n\n\t \n\tqlge_write32(qdev, CSR, CSR_CMD_CLR_R2PCI_INT);\n\n\tif (((mbcp->mbox_out[0] & 0x0000f000) !=\n\t     MB_CMD_STS_GOOD) &&\n\t    ((mbcp->mbox_out[0] & 0x0000f000) !=\n\t     MB_CMD_STS_INTRMDT)) {\n\t\tstatus = -EIO;\n\t}\nend:\n\t \n\tqlge_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16) | INTR_MASK_PI);\n\tmutex_unlock(&qdev->mpi_mutex);\n\treturn status;\n}\n\n \nint qlge_mb_about_fw(struct qlge_adapter *qdev)\n{\n\tstruct mbox_params mbc;\n\tstruct mbox_params *mbcp = &mbc;\n\tint status = 0;\n\n\tmemset(mbcp, 0, sizeof(struct mbox_params));\n\n\tmbcp->in_count = 1;\n\tmbcp->out_count = 3;\n\n\tmbcp->mbox_in[0] = MB_CMD_ABOUT_FW;\n\n\tstatus = qlge_mailbox_command(qdev, mbcp);\n\tif (status)\n\t\treturn status;\n\n\tif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Failed about firmware command\\n\");\n\t\tstatus = -EIO;\n\t}\n\n\t \n\tqdev->fw_rev_id = mbcp->mbox_out[1];\n\n\treturn status;\n}\n\n \nint qlge_mb_get_fw_state(struct qlge_adapter *qdev)\n{\n\tstruct mbox_params mbc;\n\tstruct mbox_params *mbcp = &mbc;\n\tint status = 0;\n\n\tmemset(mbcp, 0, sizeof(struct mbox_params));\n\n\tmbcp->in_count = 1;\n\tmbcp->out_count = 2;\n\n\tmbcp->mbox_in[0] = MB_CMD_GET_FW_STATE;\n\n\tstatus = qlge_mailbox_command(qdev, mbcp);\n\tif (status)\n\t\treturn status;\n\n\tif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Failed Get Firmware State.\\n\");\n\t\tstatus = -EIO;\n\t}\n\n\t \n\tif (mbcp->mbox_out[1] & 1) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Firmware waiting for initialization.\\n\");\n\t\tstatus = -EIO;\n\t}\n\n\treturn status;\n}\n\n \nstatic int qlge_mb_idc_ack(struct qlge_adapter *qdev)\n{\n\tstruct mbox_params mbc;\n\tstruct mbox_params *mbcp = &mbc;\n\tint status = 0;\n\n\tmemset(mbcp, 0, sizeof(struct mbox_params));\n\n\tmbcp->in_count = 5;\n\tmbcp->out_count = 1;\n\n\tmbcp->mbox_in[0] = MB_CMD_IDC_ACK;\n\tmbcp->mbox_in[1] = qdev->idc_mbc.mbox_out[1];\n\tmbcp->mbox_in[2] = qdev->idc_mbc.mbox_out[2];\n\tmbcp->mbox_in[3] = qdev->idc_mbc.mbox_out[3];\n\tmbcp->mbox_in[4] = qdev->idc_mbc.mbox_out[4];\n\n\tstatus = qlge_mailbox_command(qdev, mbcp);\n\tif (status)\n\t\treturn status;\n\n\tif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\n\t\tnetif_err(qdev, drv, qdev->ndev, \"Failed IDC ACK send.\\n\");\n\t\tstatus = -EIO;\n\t}\n\treturn status;\n}\n\n \nint qlge_mb_set_port_cfg(struct qlge_adapter *qdev)\n{\n\tstruct mbox_params mbc;\n\tstruct mbox_params *mbcp = &mbc;\n\tint status = 0;\n\n\tmemset(mbcp, 0, sizeof(struct mbox_params));\n\n\tmbcp->in_count = 3;\n\tmbcp->out_count = 1;\n\n\tmbcp->mbox_in[0] = MB_CMD_SET_PORT_CFG;\n\tmbcp->mbox_in[1] = qdev->link_config;\n\tmbcp->mbox_in[2] = qdev->max_frame_size;\n\n\tstatus = qlge_mailbox_command(qdev, mbcp);\n\tif (status)\n\t\treturn status;\n\n\tif (mbcp->mbox_out[0] == MB_CMD_STS_INTRMDT) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Port Config sent, wait for IDC.\\n\");\n\t} else\tif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Failed Set Port Configuration.\\n\");\n\t\tstatus = -EIO;\n\t}\n\treturn status;\n}\n\nstatic int qlge_mb_dump_ram(struct qlge_adapter *qdev, u64 req_dma, u32 addr,\n\t\t\t    u32 size)\n{\n\tint status = 0;\n\tstruct mbox_params mbc;\n\tstruct mbox_params *mbcp = &mbc;\n\n\tmemset(mbcp, 0, sizeof(struct mbox_params));\n\n\tmbcp->in_count = 9;\n\tmbcp->out_count = 1;\n\n\tmbcp->mbox_in[0] = MB_CMD_DUMP_RISC_RAM;\n\tmbcp->mbox_in[1] = LSW(addr);\n\tmbcp->mbox_in[2] = MSW(req_dma);\n\tmbcp->mbox_in[3] = LSW(req_dma);\n\tmbcp->mbox_in[4] = MSW(size);\n\tmbcp->mbox_in[5] = LSW(size);\n\tmbcp->mbox_in[6] = MSW(MSD(req_dma));\n\tmbcp->mbox_in[7] = LSW(MSD(req_dma));\n\tmbcp->mbox_in[8] = MSW(addr);\n\n\tstatus = qlge_mailbox_command(qdev, mbcp);\n\tif (status)\n\t\treturn status;\n\n\tif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\n\t\tnetif_err(qdev, drv, qdev->ndev, \"Failed to dump risc RAM.\\n\");\n\t\tstatus = -EIO;\n\t}\n\treturn status;\n}\n\n \nint qlge_dump_risc_ram_area(struct qlge_adapter *qdev, void *buf,\n\t\t\t    u32 ram_addr, int word_count)\n{\n\tint status;\n\tchar *my_buf;\n\tdma_addr_t buf_dma;\n\n\tmy_buf = dma_alloc_coherent(&qdev->pdev->dev,\n\t\t\t\t    word_count * sizeof(u32), &buf_dma,\n\t\t\t\t    GFP_ATOMIC);\n\tif (!my_buf)\n\t\treturn -EIO;\n\n\tstatus = qlge_mb_dump_ram(qdev, buf_dma, ram_addr, word_count);\n\tif (!status)\n\t\tmemcpy(buf, my_buf, word_count * sizeof(u32));\n\n\tdma_free_coherent(&qdev->pdev->dev, word_count * sizeof(u32), my_buf,\n\t\t\t  buf_dma);\n\treturn status;\n}\n\n \nint qlge_mb_get_port_cfg(struct qlge_adapter *qdev)\n{\n\tstruct mbox_params mbc;\n\tstruct mbox_params *mbcp = &mbc;\n\tint status = 0;\n\n\tmemset(mbcp, 0, sizeof(struct mbox_params));\n\n\tmbcp->in_count = 1;\n\tmbcp->out_count = 3;\n\n\tmbcp->mbox_in[0] = MB_CMD_GET_PORT_CFG;\n\n\tstatus = qlge_mailbox_command(qdev, mbcp);\n\tif (status)\n\t\treturn status;\n\n\tif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Failed Get Port Configuration.\\n\");\n\t\tstatus = -EIO;\n\t} else\t{\n\t\tnetif_printk(qdev, drv, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"Passed Get Port Configuration.\\n\");\n\t\tqdev->link_config = mbcp->mbox_out[1];\n\t\tqdev->max_frame_size = mbcp->mbox_out[2];\n\t}\n\treturn status;\n}\n\nint qlge_mb_wol_mode(struct qlge_adapter *qdev, u32 wol)\n{\n\tstruct mbox_params mbc;\n\tstruct mbox_params *mbcp = &mbc;\n\tint status;\n\n\tmemset(mbcp, 0, sizeof(struct mbox_params));\n\n\tmbcp->in_count = 2;\n\tmbcp->out_count = 1;\n\n\tmbcp->mbox_in[0] = MB_CMD_SET_WOL_MODE;\n\tmbcp->mbox_in[1] = wol;\n\n\tstatus = qlge_mailbox_command(qdev, mbcp);\n\tif (status)\n\t\treturn status;\n\n\tif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\n\t\tnetif_err(qdev, drv, qdev->ndev, \"Failed to set WOL mode.\\n\");\n\t\tstatus = -EIO;\n\t}\n\treturn status;\n}\n\nint qlge_mb_wol_set_magic(struct qlge_adapter *qdev, u32 enable_wol)\n{\n\tstruct mbox_params mbc;\n\tstruct mbox_params *mbcp = &mbc;\n\tint status;\n\tconst u8 *addr = qdev->ndev->dev_addr;\n\n\tmemset(mbcp, 0, sizeof(struct mbox_params));\n\n\tmbcp->in_count = 8;\n\tmbcp->out_count = 1;\n\n\tmbcp->mbox_in[0] = MB_CMD_SET_WOL_MAGIC;\n\tif (enable_wol) {\n\t\tmbcp->mbox_in[1] = (u32)addr[0];\n\t\tmbcp->mbox_in[2] = (u32)addr[1];\n\t\tmbcp->mbox_in[3] = (u32)addr[2];\n\t\tmbcp->mbox_in[4] = (u32)addr[3];\n\t\tmbcp->mbox_in[5] = (u32)addr[4];\n\t\tmbcp->mbox_in[6] = (u32)addr[5];\n\t\tmbcp->mbox_in[7] = 0;\n\t} else {\n\t\tmbcp->mbox_in[1] = 0;\n\t\tmbcp->mbox_in[2] = 1;\n\t\tmbcp->mbox_in[3] = 1;\n\t\tmbcp->mbox_in[4] = 1;\n\t\tmbcp->mbox_in[5] = 1;\n\t\tmbcp->mbox_in[6] = 1;\n\t\tmbcp->mbox_in[7] = 0;\n\t}\n\n\tstatus = qlge_mailbox_command(qdev, mbcp);\n\tif (status)\n\t\treturn status;\n\n\tif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\n\t\tnetif_err(qdev, drv, qdev->ndev, \"Failed to set WOL mode.\\n\");\n\t\tstatus = -EIO;\n\t}\n\treturn status;\n}\n\n \nstatic int qlge_idc_wait(struct qlge_adapter *qdev)\n{\n\tint status = -ETIMEDOUT;\n\tstruct mbox_params *mbcp = &qdev->idc_mbc;\n\tlong wait_time;\n\n\tfor (wait_time = 1 * HZ; wait_time;) {\n\t\t \n\t\twait_time =\n\t\t\twait_for_completion_timeout(&qdev->ide_completion,\n\t\t\t\t\t\t    wait_time);\n\t\tif (!wait_time) {\n\t\t\tnetif_err(qdev, drv, qdev->ndev, \"IDC Timeout.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (mbcp->mbox_out[0] == AEN_IDC_EXT) {\n\t\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t\t  \"IDC Time Extension from function.\\n\");\n\t\t\twait_time += (mbcp->mbox_out[1] >> 8) & 0x0000000f;\n\t\t} else if (mbcp->mbox_out[0] == AEN_IDC_CMPLT) {\n\t\t\tnetif_err(qdev, drv, qdev->ndev, \"IDC Success.\\n\");\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t\t  \"IDC: Invalid State 0x%.04x.\\n\",\n\t\t\t\t  mbcp->mbox_out[0]);\n\t\t\tstatus = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nint qlge_mb_set_led_cfg(struct qlge_adapter *qdev, u32 led_config)\n{\n\tstruct mbox_params mbc;\n\tstruct mbox_params *mbcp = &mbc;\n\tint status;\n\n\tmemset(mbcp, 0, sizeof(struct mbox_params));\n\n\tmbcp->in_count = 2;\n\tmbcp->out_count = 1;\n\n\tmbcp->mbox_in[0] = MB_CMD_SET_LED_CFG;\n\tmbcp->mbox_in[1] = led_config;\n\n\tstatus = qlge_mailbox_command(qdev, mbcp);\n\tif (status)\n\t\treturn status;\n\n\tif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Failed to set LED Configuration.\\n\");\n\t\tstatus = -EIO;\n\t}\n\n\treturn status;\n}\n\nint qlge_mb_get_led_cfg(struct qlge_adapter *qdev)\n{\n\tstruct mbox_params mbc;\n\tstruct mbox_params *mbcp = &mbc;\n\tint status;\n\n\tmemset(mbcp, 0, sizeof(struct mbox_params));\n\n\tmbcp->in_count = 1;\n\tmbcp->out_count = 2;\n\n\tmbcp->mbox_in[0] = MB_CMD_GET_LED_CFG;\n\n\tstatus = qlge_mailbox_command(qdev, mbcp);\n\tif (status)\n\t\treturn status;\n\n\tif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Failed to get LED Configuration.\\n\");\n\t\tstatus = -EIO;\n\t} else {\n\t\tqdev->led_config = mbcp->mbox_out[1];\n\t}\n\treturn status;\n}\n\nint qlge_mb_set_mgmnt_traffic_ctl(struct qlge_adapter *qdev, u32 control)\n{\n\tstruct mbox_params mbc;\n\tstruct mbox_params *mbcp = &mbc;\n\tint status;\n\n\tmemset(mbcp, 0, sizeof(struct mbox_params));\n\n\tmbcp->in_count = 1;\n\tmbcp->out_count = 2;\n\n\tmbcp->mbox_in[0] = MB_CMD_SET_MGMNT_TFK_CTL;\n\tmbcp->mbox_in[1] = control;\n\n\tstatus = qlge_mailbox_command(qdev, mbcp);\n\tif (status)\n\t\treturn status;\n\n\tif (mbcp->mbox_out[0] == MB_CMD_STS_GOOD)\n\t\treturn status;\n\n\tif (mbcp->mbox_out[0] == MB_CMD_STS_INVLD_CMD) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Command not supported by firmware.\\n\");\n\t\tstatus = -EINVAL;\n\t} else if (mbcp->mbox_out[0] == MB_CMD_STS_ERR) {\n\t\t \n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Command parameters make no change.\\n\");\n\t}\n\treturn status;\n}\n\n \nstatic int qlge_mb_get_mgmnt_traffic_ctl(struct qlge_adapter *qdev, u32 *control)\n{\n\tstruct mbox_params mbc;\n\tstruct mbox_params *mbcp = &mbc;\n\tint status;\n\n\tmemset(mbcp, 0, sizeof(struct mbox_params));\n\t*control = 0;\n\n\tmbcp->in_count = 1;\n\tmbcp->out_count = 1;\n\n\tmbcp->mbox_in[0] = MB_CMD_GET_MGMNT_TFK_CTL;\n\n\tstatus = qlge_mailbox_command(qdev, mbcp);\n\tif (status)\n\t\treturn status;\n\n\tif (mbcp->mbox_out[0] == MB_CMD_STS_GOOD) {\n\t\t*control = mbcp->mbox_in[1];\n\t\treturn status;\n\t}\n\n\tif (mbcp->mbox_out[0] == MB_CMD_STS_INVLD_CMD) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Command not supported by firmware.\\n\");\n\t\tstatus = -EINVAL;\n\t} else if (mbcp->mbox_out[0] == MB_CMD_STS_ERR) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Failed to get MPI traffic control.\\n\");\n\t\tstatus = -EIO;\n\t}\n\treturn status;\n}\n\nint qlge_wait_fifo_empty(struct qlge_adapter *qdev)\n{\n\tint count;\n\tu32 mgmnt_fifo_empty;\n\tu32 nic_fifo_empty;\n\n\tfor (count = 6; count; count--) {\n\t\tnic_fifo_empty = qlge_read32(qdev, STS) & STS_NFE;\n\t\tqlge_mb_get_mgmnt_traffic_ctl(qdev, &mgmnt_fifo_empty);\n\t\tmgmnt_fifo_empty &= MB_GET_MPI_TFK_FIFO_EMPTY;\n\t\tif (nic_fifo_empty && mgmnt_fifo_empty)\n\t\t\treturn 0;\n\t\tmsleep(100);\n\t}\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int qlge_set_port_cfg(struct qlge_adapter *qdev)\n{\n\tint status;\n\n\tstatus = qlge_mb_set_port_cfg(qdev);\n\tif (status)\n\t\treturn status;\n\tstatus = qlge_idc_wait(qdev);\n\treturn status;\n}\n\n \n\n \nvoid qlge_mpi_port_cfg_work(struct work_struct *work)\n{\n\tstruct qlge_adapter *qdev =\n\t\tcontainer_of(work, struct qlge_adapter, mpi_port_cfg_work.work);\n\tint status;\n\n\tstatus = qlge_mb_get_port_cfg(qdev);\n\tif (status) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Bug: Failed to get port config data.\\n\");\n\t\tgoto err;\n\t}\n\n\tif (qdev->link_config & CFG_JUMBO_FRAME_SIZE &&\n\t    qdev->max_frame_size == CFG_DEFAULT_MAX_FRAME_SIZE)\n\t\tgoto end;\n\n\tqdev->link_config |=\tCFG_JUMBO_FRAME_SIZE;\n\tqdev->max_frame_size = CFG_DEFAULT_MAX_FRAME_SIZE;\n\tstatus = qlge_set_port_cfg(qdev);\n\tif (status) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Bug: Failed to set port config data.\\n\");\n\t\tgoto err;\n\t}\nend:\n\tclear_bit(QL_PORT_CFG, &qdev->flags);\n\treturn;\nerr:\n\tqlge_queue_fw_error(qdev);\n\tgoto end;\n}\n\n \nvoid qlge_mpi_idc_work(struct work_struct *work)\n{\n\tstruct qlge_adapter *qdev =\n\t\tcontainer_of(work, struct qlge_adapter, mpi_idc_work.work);\n\tint status;\n\tstruct mbox_params *mbcp = &qdev->idc_mbc;\n\tu32 aen;\n\tint timeout;\n\n\taen = mbcp->mbox_out[1] >> 16;\n\ttimeout = (mbcp->mbox_out[1] >> 8) & 0xf;\n\n\tswitch (aen) {\n\tdefault:\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Bug: Unhandled IDC action.\\n\");\n\t\tbreak;\n\tcase MB_CMD_PORT_RESET:\n\tcase MB_CMD_STOP_FW:\n\t\tqlge_link_off(qdev);\n\t\tfallthrough;\n\tcase MB_CMD_SET_PORT_CFG:\n\t\t \n\t\tset_bit(QL_CAM_RT_SET, &qdev->flags);\n\t\t \n\t\tif (timeout) {\n\t\t\tstatus = qlge_mb_idc_ack(qdev);\n\t\t\tif (status)\n\t\t\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t\t\t  \"Bug: No pending IDC!\\n\");\n\t\t} else {\n\t\t\tnetif_printk(qdev, drv, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"IDC ACK not required\\n\");\n\t\t\tstatus = 0;  \n\t\t}\n\t\tbreak;\n\n\t\t \n\tcase MB_CMD_IOP_RESTART_MPI:\n\tcase MB_CMD_IOP_PREP_LINK_DOWN:\n\t\t \n\t\tqlge_link_off(qdev);\n\t\tset_bit(QL_CAM_RT_SET, &qdev->flags);\n\t\tfallthrough;\n\tcase MB_CMD_IOP_DVR_START:\n\tcase MB_CMD_IOP_FLASH_ACC:\n\tcase MB_CMD_IOP_CORE_DUMP_MPI:\n\tcase MB_CMD_IOP_PREP_UPDATE_MPI:\n\tcase MB_CMD_IOP_COMP_UPDATE_MPI:\n\tcase MB_CMD_IOP_NONE:\t \n\t\t \n\t\tif (timeout) {\n\t\t\tstatus = qlge_mb_idc_ack(qdev);\n\t\t\tif (status)\n\t\t\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t\t\t  \"Bug: No pending IDC!\\n\");\n\t\t} else {\n\t\t\tnetif_printk(qdev, drv, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"IDC ACK not required\\n\");\n\t\t\tstatus = 0;  \n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid qlge_mpi_work(struct work_struct *work)\n{\n\tstruct qlge_adapter *qdev =\n\t\tcontainer_of(work, struct qlge_adapter, mpi_work.work);\n\tstruct mbox_params mbc;\n\tstruct mbox_params *mbcp = &mbc;\n\tint err = 0;\n\n\tmutex_lock(&qdev->mpi_mutex);\n\t \n\tqlge_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16));\n\n\twhile (qlge_read32(qdev, STS) & STS_PI) {\n\t\tmemset(mbcp, 0, sizeof(struct mbox_params));\n\t\tmbcp->out_count = 1;\n\t\t \n\t\terr = qlge_mpi_handler(qdev, mbcp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\t \n\tqlge_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16) | INTR_MASK_PI);\n\tmutex_unlock(&qdev->mpi_mutex);\n}\n\nvoid qlge_mpi_reset_work(struct work_struct *work)\n{\n\tstruct qlge_adapter *qdev =\n\t\tcontainer_of(work, struct qlge_adapter, mpi_reset_work.work);\n\tcancel_delayed_work_sync(&qdev->mpi_work);\n\tcancel_delayed_work_sync(&qdev->mpi_port_cfg_work);\n\tcancel_delayed_work_sync(&qdev->mpi_idc_work);\n\t \n\tif (!qlge_own_firmware(qdev)) {\n\t\tnetif_err(qdev, drv, qdev->ndev, \"Don't own firmware!\\n\");\n\t\treturn;\n\t}\n\n\tqlge_soft_reset_mpi_risc(qdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}