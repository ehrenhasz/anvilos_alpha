{
  "module_name": "qlge_main.c",
  "hash_id": "5a96bf543dc2b464bc3589854817b45990079269291aaccbae6169bc98ef8932",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/qlge/qlge_main.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/dmapool.h>\n#include <linux/mempool.h>\n#include <linux/spinlock.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <net/ipv6.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/prefetch.h>\n#include <net/ip6_checksum.h>\n\n#include \"qlge.h\"\n#include \"qlge_devlink.h\"\n\nchar qlge_driver_name[] = DRV_NAME;\nconst char qlge_driver_version[] = DRV_VERSION;\n\nMODULE_AUTHOR(\"Ron Mercer <ron.mercer@qlogic.com>\");\nMODULE_DESCRIPTION(DRV_STRING \" \");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n\nstatic const u32 default_msg =\n\tNETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK |\n\tNETIF_MSG_IFDOWN |\n\tNETIF_MSG_IFUP |\n\tNETIF_MSG_RX_ERR |\n\tNETIF_MSG_TX_ERR |\n\tNETIF_MSG_HW | NETIF_MSG_WOL | 0;\n\nstatic int debug = -1;\t \nmodule_param(debug, int, 0664);\nMODULE_PARM_DESC(debug, \"Debug level (0=none,...,16=all)\");\n\n#define MSIX_IRQ 0\n#define MSI_IRQ 1\n#define LEG_IRQ 2\nstatic int qlge_irq_type = MSIX_IRQ;\nmodule_param(qlge_irq_type, int, 0664);\nMODULE_PARM_DESC(qlge_irq_type, \"0 = MSI-X, 1 = MSI, 2 = Legacy.\");\n\nstatic int qlge_mpi_coredump;\nmodule_param(qlge_mpi_coredump, int, 0);\nMODULE_PARM_DESC(qlge_mpi_coredump,\n\t\t \"Option to enable MPI firmware dump. Default is OFF - Do Not allocate memory. \");\n\nstatic int qlge_force_coredump;\nmodule_param(qlge_force_coredump, int, 0);\nMODULE_PARM_DESC(qlge_force_coredump,\n\t\t \"Option to allow force of firmware core dump. Default is OFF - Do not allow.\");\n\nstatic const struct pci_device_id qlge_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, QLGE_DEVICE_ID_8012)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, QLGE_DEVICE_ID_8000)},\n\t \n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, qlge_pci_tbl);\n\nstatic int qlge_wol(struct qlge_adapter *);\nstatic void qlge_set_multicast_list(struct net_device *);\nstatic int qlge_adapter_down(struct qlge_adapter *);\nstatic int qlge_adapter_up(struct qlge_adapter *);\n\n \nstatic int qlge_sem_trylock(struct qlge_adapter *qdev, u32 sem_mask)\n{\n\tu32 sem_bits = 0;\n\n\tswitch (sem_mask) {\n\tcase SEM_XGMAC0_MASK:\n\t\tsem_bits = SEM_SET << SEM_XGMAC0_SHIFT;\n\t\tbreak;\n\tcase SEM_XGMAC1_MASK:\n\t\tsem_bits = SEM_SET << SEM_XGMAC1_SHIFT;\n\t\tbreak;\n\tcase SEM_ICB_MASK:\n\t\tsem_bits = SEM_SET << SEM_ICB_SHIFT;\n\t\tbreak;\n\tcase SEM_MAC_ADDR_MASK:\n\t\tsem_bits = SEM_SET << SEM_MAC_ADDR_SHIFT;\n\t\tbreak;\n\tcase SEM_FLASH_MASK:\n\t\tsem_bits = SEM_SET << SEM_FLASH_SHIFT;\n\t\tbreak;\n\tcase SEM_PROBE_MASK:\n\t\tsem_bits = SEM_SET << SEM_PROBE_SHIFT;\n\t\tbreak;\n\tcase SEM_RT_IDX_MASK:\n\t\tsem_bits = SEM_SET << SEM_RT_IDX_SHIFT;\n\t\tbreak;\n\tcase SEM_PROC_REG_MASK:\n\t\tsem_bits = SEM_SET << SEM_PROC_REG_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tnetif_alert(qdev, probe, qdev->ndev, \"bad Semaphore mask!.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tqlge_write32(qdev, SEM, sem_bits | sem_mask);\n\treturn !(qlge_read32(qdev, SEM) & sem_bits);\n}\n\nint qlge_sem_spinlock(struct qlge_adapter *qdev, u32 sem_mask)\n{\n\tunsigned int wait_count = 30;\n\n\tdo {\n\t\tif (!qlge_sem_trylock(qdev, sem_mask))\n\t\t\treturn 0;\n\t\tudelay(100);\n\t} while (--wait_count);\n\treturn -ETIMEDOUT;\n}\n\nvoid qlge_sem_unlock(struct qlge_adapter *qdev, u32 sem_mask)\n{\n\tqlge_write32(qdev, SEM, sem_mask);\n\tqlge_read32(qdev, SEM);\t \n}\n\n \nint qlge_wait_reg_rdy(struct qlge_adapter *qdev, u32 reg, u32 bit, u32 err_bit)\n{\n\tu32 temp;\n\tint count;\n\n\tfor (count = 0; count < UDELAY_COUNT; count++) {\n\t\ttemp = qlge_read32(qdev, reg);\n\n\t\t \n\t\tif (temp & err_bit) {\n\t\t\tnetif_alert(qdev, probe, qdev->ndev,\n\t\t\t\t    \"register 0x%.08x access error, value = 0x%.08x!.\\n\",\n\t\t\t\t    reg, temp);\n\t\t\treturn -EIO;\n\t\t} else if (temp & bit) {\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(UDELAY_DELAY);\n\t}\n\tnetif_alert(qdev, probe, qdev->ndev,\n\t\t    \"Timed out waiting for reg %x to come ready.\\n\", reg);\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int qlge_wait_cfg(struct qlge_adapter *qdev, u32 bit)\n{\n\tint count;\n\tu32 temp;\n\n\tfor (count = 0; count < UDELAY_COUNT; count++) {\n\t\ttemp = qlge_read32(qdev, CFG);\n\t\tif (temp & CFG_LE)\n\t\t\treturn -EIO;\n\t\tif (!(temp & bit))\n\t\t\treturn 0;\n\t\tudelay(UDELAY_DELAY);\n\t}\n\treturn -ETIMEDOUT;\n}\n\n \nint qlge_write_cfg(struct qlge_adapter *qdev, void *ptr, int size, u32 bit,\n\t\t   u16 q_id)\n{\n\tu64 map;\n\tint status = 0;\n\tint direction;\n\tu32 mask;\n\tu32 value;\n\n\tif (bit & (CFG_LRQ | CFG_LR | CFG_LCQ))\n\t\tdirection = DMA_TO_DEVICE;\n\telse\n\t\tdirection = DMA_FROM_DEVICE;\n\n\tmap = dma_map_single(&qdev->pdev->dev, ptr, size, direction);\n\tif (dma_mapping_error(&qdev->pdev->dev, map)) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Couldn't map DMA area.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tstatus = qlge_sem_spinlock(qdev, SEM_ICB_MASK);\n\tif (status)\n\t\tgoto lock_failed;\n\n\tstatus = qlge_wait_cfg(qdev, bit);\n\tif (status) {\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Timed out waiting for CFG to come ready.\\n\");\n\t\tgoto exit;\n\t}\n\n\tqlge_write32(qdev, ICB_L, (u32)map);\n\tqlge_write32(qdev, ICB_H, (u32)(map >> 32));\n\n\tmask = CFG_Q_MASK | (bit << 16);\n\tvalue = bit | (q_id << CFG_Q_SHIFT);\n\tqlge_write32(qdev, CFG, (mask | value));\n\n\t \n\tstatus = qlge_wait_cfg(qdev, bit);\nexit:\n\tqlge_sem_unlock(qdev, SEM_ICB_MASK);\t \nlock_failed:\n\tdma_unmap_single(&qdev->pdev->dev, map, size, direction);\n\treturn status;\n}\n\n \nint qlge_get_mac_addr_reg(struct qlge_adapter *qdev, u32 type, u16 index,\n\t\t\t  u32 *value)\n{\n\tu32 offset = 0;\n\tint status;\n\n\tswitch (type) {\n\tcase MAC_ADDR_TYPE_MULTI_MAC:\n\tcase MAC_ADDR_TYPE_CAM_MAC: {\n\t\tstatus = qlge_wait_reg_rdy(qdev, MAC_ADDR_IDX, MAC_ADDR_MW, 0);\n\t\tif (status)\n\t\t\tbreak;\n\t\tqlge_write32(qdev, MAC_ADDR_IDX,\n\t\t\t     (offset++) |  \n\t\t\t\t   (index << MAC_ADDR_IDX_SHIFT) |  \n\t\t\t\t   MAC_ADDR_ADR | MAC_ADDR_RS |\n\t\t\t\t   type);  \n\t\tstatus = qlge_wait_reg_rdy(qdev, MAC_ADDR_IDX, MAC_ADDR_MR, 0);\n\t\tif (status)\n\t\t\tbreak;\n\t\t*value++ = qlge_read32(qdev, MAC_ADDR_DATA);\n\t\tstatus = qlge_wait_reg_rdy(qdev, MAC_ADDR_IDX, MAC_ADDR_MW, 0);\n\t\tif (status)\n\t\t\tbreak;\n\t\tqlge_write32(qdev, MAC_ADDR_IDX,\n\t\t\t     (offset++) |  \n\t\t\t\t   (index << MAC_ADDR_IDX_SHIFT) |  \n\t\t\t\t   MAC_ADDR_ADR | MAC_ADDR_RS |\n\t\t\t\t   type);  \n\t\tstatus = qlge_wait_reg_rdy(qdev, MAC_ADDR_IDX, MAC_ADDR_MR, 0);\n\t\tif (status)\n\t\t\tbreak;\n\t\t*value++ = qlge_read32(qdev, MAC_ADDR_DATA);\n\t\tif (type == MAC_ADDR_TYPE_CAM_MAC) {\n\t\t\tstatus = qlge_wait_reg_rdy(qdev, MAC_ADDR_IDX,\n\t\t\t\t\t\t   MAC_ADDR_MW, 0);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t\tqlge_write32(qdev, MAC_ADDR_IDX,\n\t\t\t\t     (offset++) |  \n\t\t\t\t\t   (index\n\t\t\t\t\t    << MAC_ADDR_IDX_SHIFT) |  \n\t\t\t\t\t   MAC_ADDR_ADR |\n\t\t\t\t\t   MAC_ADDR_RS | type);  \n\t\t\tstatus = qlge_wait_reg_rdy(qdev, MAC_ADDR_IDX,\n\t\t\t\t\t\t   MAC_ADDR_MR, 0);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t\t*value++ = qlge_read32(qdev, MAC_ADDR_DATA);\n\t\t}\n\t\tbreak;\n\t}\n\tcase MAC_ADDR_TYPE_VLAN:\n\tcase MAC_ADDR_TYPE_MULTI_FLTR:\n\tdefault:\n\t\tnetif_crit(qdev, ifup, qdev->ndev,\n\t\t\t   \"Address type %d not yet supported.\\n\", type);\n\t\tstatus = -EPERM;\n\t}\n\treturn status;\n}\n\n \nstatic int qlge_set_mac_addr_reg(struct qlge_adapter *qdev, const u8 *addr,\n\t\t\t\t u32 type, u16 index)\n{\n\tu32 offset = 0;\n\tint status = 0;\n\n\tswitch (type) {\n\tcase MAC_ADDR_TYPE_MULTI_MAC: {\n\t\tu32 upper = (addr[0] << 8) | addr[1];\n\t\tu32 lower = (addr[2] << 24) | (addr[3] << 16) | (addr[4] << 8) |\n\t\t\t    (addr[5]);\n\n\t\tstatus = qlge_wait_reg_rdy(qdev, MAC_ADDR_IDX, MAC_ADDR_MW, 0);\n\t\tif (status)\n\t\t\tbreak;\n\t\tqlge_write32(qdev, MAC_ADDR_IDX,\n\t\t\t     (offset++) | (index << MAC_ADDR_IDX_SHIFT) | type |\n\t\t\t\t   MAC_ADDR_E);\n\t\tqlge_write32(qdev, MAC_ADDR_DATA, lower);\n\t\tstatus = qlge_wait_reg_rdy(qdev, MAC_ADDR_IDX, MAC_ADDR_MW, 0);\n\t\tif (status)\n\t\t\tbreak;\n\t\tqlge_write32(qdev, MAC_ADDR_IDX,\n\t\t\t     (offset++) | (index << MAC_ADDR_IDX_SHIFT) | type |\n\t\t\t\t   MAC_ADDR_E);\n\n\t\tqlge_write32(qdev, MAC_ADDR_DATA, upper);\n\t\tstatus = qlge_wait_reg_rdy(qdev, MAC_ADDR_IDX, MAC_ADDR_MW, 0);\n\t\tbreak;\n\t}\n\tcase MAC_ADDR_TYPE_CAM_MAC: {\n\t\tu32 cam_output;\n\t\tu32 upper = (addr[0] << 8) | addr[1];\n\t\tu32 lower = (addr[2] << 24) | (addr[3] << 16) | (addr[4] << 8) |\n\t\t\t    (addr[5]);\n\t\tstatus = qlge_wait_reg_rdy(qdev, MAC_ADDR_IDX, MAC_ADDR_MW, 0);\n\t\tif (status)\n\t\t\tbreak;\n\t\tqlge_write32(qdev, MAC_ADDR_IDX,\n\t\t\t     (offset++) |  \n\t\t\t\t   (index << MAC_ADDR_IDX_SHIFT) |  \n\t\t\t\t   type);  \n\t\tqlge_write32(qdev, MAC_ADDR_DATA, lower);\n\t\tstatus = qlge_wait_reg_rdy(qdev, MAC_ADDR_IDX, MAC_ADDR_MW, 0);\n\t\tif (status)\n\t\t\tbreak;\n\t\tqlge_write32(qdev, MAC_ADDR_IDX,\n\t\t\t     (offset++) |  \n\t\t\t\t   (index << MAC_ADDR_IDX_SHIFT) |  \n\t\t\t\t   type);  \n\t\tqlge_write32(qdev, MAC_ADDR_DATA, upper);\n\t\tstatus = qlge_wait_reg_rdy(qdev, MAC_ADDR_IDX, MAC_ADDR_MW, 0);\n\t\tif (status)\n\t\t\tbreak;\n\t\tqlge_write32(qdev, MAC_ADDR_IDX,\n\t\t\t     (offset) |  \n\t\t\t\t   (index << MAC_ADDR_IDX_SHIFT) |  \n\t\t\t\t   type);  \n\t\t \n\t\tcam_output = (CAM_OUT_ROUTE_NIC |\n\t\t\t      (qdev->func << CAM_OUT_FUNC_SHIFT) |\n\t\t\t      (0 << CAM_OUT_CQ_ID_SHIFT));\n\t\tif (qdev->ndev->features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\t\tcam_output |= CAM_OUT_RV;\n\t\t \n\t\tqlge_write32(qdev, MAC_ADDR_DATA, cam_output);\n\t\tbreak;\n\t}\n\tcase MAC_ADDR_TYPE_VLAN: {\n\t\tu32 enable_bit = *((u32 *)&addr[0]);\n\t\t \n\t\tstatus = qlge_wait_reg_rdy(qdev, MAC_ADDR_IDX, MAC_ADDR_MW, 0);\n\t\tif (status)\n\t\t\tbreak;\n\t\tqlge_write32(qdev, MAC_ADDR_IDX,\n\t\t\t     offset |  \n\t\t\t\t   (index << MAC_ADDR_IDX_SHIFT) |  \n\t\t\t\t   type |  \n\t\t\t\t   enable_bit);  \n\t\tbreak;\n\t}\n\tcase MAC_ADDR_TYPE_MULTI_FLTR:\n\tdefault:\n\t\tnetif_crit(qdev, ifup, qdev->ndev,\n\t\t\t   \"Address type %d not yet supported.\\n\", type);\n\t\tstatus = -EPERM;\n\t}\n\treturn status;\n}\n\n \nstatic int qlge_set_mac_addr(struct qlge_adapter *qdev, int set)\n{\n\tint status;\n\tchar zero_mac_addr[ETH_ALEN];\n\tchar *addr;\n\n\tif (set) {\n\t\taddr = &qdev->current_mac_addr[0];\n\t\tnetif_printk(qdev, ifup, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"Set Mac addr %pM\\n\", addr);\n\t} else {\n\t\teth_zero_addr(zero_mac_addr);\n\t\taddr = &zero_mac_addr[0];\n\t\tnetif_printk(qdev, ifup, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"Clearing MAC address\\n\");\n\t}\n\tstatus = qlge_sem_spinlock(qdev, SEM_MAC_ADDR_MASK);\n\tif (status)\n\t\treturn status;\n\tstatus = qlge_set_mac_addr_reg(qdev, (const u8 *)addr,\n\t\t\t\t       MAC_ADDR_TYPE_CAM_MAC,\n\t\t\t\t       qdev->func * MAX_CQ);\n\tqlge_sem_unlock(qdev, SEM_MAC_ADDR_MASK);\n\tif (status)\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Failed to init mac address.\\n\");\n\treturn status;\n}\n\nvoid qlge_link_on(struct qlge_adapter *qdev)\n{\n\tnetif_err(qdev, link, qdev->ndev, \"Link is up.\\n\");\n\tnetif_carrier_on(qdev->ndev);\n\tqlge_set_mac_addr(qdev, 1);\n}\n\nvoid qlge_link_off(struct qlge_adapter *qdev)\n{\n\tnetif_err(qdev, link, qdev->ndev, \"Link is down.\\n\");\n\tnetif_carrier_off(qdev->ndev);\n\tqlge_set_mac_addr(qdev, 0);\n}\n\n \nint qlge_get_routing_reg(struct qlge_adapter *qdev, u32 index, u32 *value)\n{\n\tint status = 0;\n\n\tstatus = qlge_wait_reg_rdy(qdev, RT_IDX, RT_IDX_MW, 0);\n\tif (status)\n\t\tgoto exit;\n\n\tqlge_write32(qdev, RT_IDX,\n\t\t     RT_IDX_TYPE_NICQ | RT_IDX_RS | (index << RT_IDX_IDX_SHIFT));\n\tstatus = qlge_wait_reg_rdy(qdev, RT_IDX, RT_IDX_MR, 0);\n\tif (status)\n\t\tgoto exit;\n\t*value = qlge_read32(qdev, RT_DATA);\nexit:\n\treturn status;\n}\n\n \nstatic int qlge_set_routing_reg(struct qlge_adapter *qdev, u32 index, u32 mask,\n\t\t\t\tint enable)\n{\n\tint status = -EINVAL;  \n\tu32 value = 0;\n\n\tswitch (mask) {\n\tcase RT_IDX_CAM_HIT:\n\t\t{\n\t\t\tvalue = RT_IDX_DST_CAM_Q |\t \n\t\t\t    RT_IDX_TYPE_NICQ |\t \n\t\t\t    (RT_IDX_CAM_HIT_SLOT << RT_IDX_IDX_SHIFT); \n\t\t\tbreak;\n\t\t}\n\tcase RT_IDX_VALID:\t \n\t\t{\n\t\t\tvalue = RT_IDX_DST_DFLT_Q |\t \n\t\t\t    RT_IDX_TYPE_NICQ |\t \n\t\t\t    (RT_IDX_PROMISCUOUS_SLOT << RT_IDX_IDX_SHIFT); \n\t\t\tbreak;\n\t\t}\n\tcase RT_IDX_ERR:\t \n\t\t{\n\t\t\tvalue = RT_IDX_DST_DFLT_Q |\t \n\t\t\t    RT_IDX_TYPE_NICQ |\t \n\t\t\t    (RT_IDX_ALL_ERR_SLOT << RT_IDX_IDX_SHIFT); \n\t\t\tbreak;\n\t\t}\n\tcase RT_IDX_IP_CSUM_ERR:  \n\t\t{\n\t\t\tvalue = RT_IDX_DST_DFLT_Q |  \n\t\t\t\tRT_IDX_TYPE_NICQ |  \n\t\t\t\t(RT_IDX_IP_CSUM_ERR_SLOT <<\n\t\t\t\tRT_IDX_IDX_SHIFT);  \n\t\t\tbreak;\n\t\t}\n\tcase RT_IDX_TU_CSUM_ERR:  \n\t\t{\n\t\t\tvalue = RT_IDX_DST_DFLT_Q |  \n\t\t\t\tRT_IDX_TYPE_NICQ |  \n\t\t\t\t(RT_IDX_TCP_UDP_CSUM_ERR_SLOT <<\n\t\t\t\tRT_IDX_IDX_SHIFT);  \n\t\t\tbreak;\n\t\t}\n\tcase RT_IDX_BCAST:\t \n\t\t{\n\t\t\tvalue = RT_IDX_DST_DFLT_Q |\t \n\t\t\t    RT_IDX_TYPE_NICQ |\t \n\t\t\t    (RT_IDX_BCAST_SLOT << RT_IDX_IDX_SHIFT); \n\t\t\tbreak;\n\t\t}\n\tcase RT_IDX_MCAST:\t \n\t\t{\n\t\t\tvalue = RT_IDX_DST_DFLT_Q |\t \n\t\t\t    RT_IDX_TYPE_NICQ |\t \n\t\t\t    (RT_IDX_ALLMULTI_SLOT << RT_IDX_IDX_SHIFT); \n\t\t\tbreak;\n\t\t}\n\tcase RT_IDX_MCAST_MATCH:\t \n\t\t{\n\t\t\tvalue = RT_IDX_DST_DFLT_Q |\t \n\t\t\t    RT_IDX_TYPE_NICQ |\t \n\t\t\t    (RT_IDX_MCAST_MATCH_SLOT << RT_IDX_IDX_SHIFT); \n\t\t\tbreak;\n\t\t}\n\tcase RT_IDX_RSS_MATCH:\t \n\t\t{\n\t\t\tvalue = RT_IDX_DST_RSS |\t \n\t\t\t    RT_IDX_TYPE_NICQ |\t \n\t\t\t    (RT_IDX_RSS_MATCH_SLOT << RT_IDX_IDX_SHIFT); \n\t\t\tbreak;\n\t\t}\n\tcase 0:\t\t \n\t\t{\n\t\t\tvalue = RT_IDX_DST_DFLT_Q |\t \n\t\t\t    RT_IDX_TYPE_NICQ |\t \n\t\t\t    (index << RT_IDX_IDX_SHIFT); \n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Mask type %d not yet supported.\\n\", mask);\n\t\tstatus = -EPERM;\n\t\tgoto exit;\n\t}\n\n\tif (value) {\n\t\tstatus = qlge_wait_reg_rdy(qdev, RT_IDX, RT_IDX_MW, 0);\n\t\tif (status)\n\t\t\tgoto exit;\n\t\tvalue |= (enable ? RT_IDX_E : 0);\n\t\tqlge_write32(qdev, RT_IDX, value);\n\t\tqlge_write32(qdev, RT_DATA, enable ? mask : 0);\n\t}\nexit:\n\treturn status;\n}\n\nstatic void qlge_enable_interrupts(struct qlge_adapter *qdev)\n{\n\tqlge_write32(qdev, INTR_EN, (INTR_EN_EI << 16) | INTR_EN_EI);\n}\n\nstatic void qlge_disable_interrupts(struct qlge_adapter *qdev)\n{\n\tqlge_write32(qdev, INTR_EN, (INTR_EN_EI << 16));\n}\n\nstatic void qlge_enable_completion_interrupt(struct qlge_adapter *qdev, u32 intr)\n{\n\tstruct intr_context *ctx = &qdev->intr_context[intr];\n\n\tqlge_write32(qdev, INTR_EN, ctx->intr_en_mask);\n}\n\nstatic void qlge_disable_completion_interrupt(struct qlge_adapter *qdev, u32 intr)\n{\n\tstruct intr_context *ctx = &qdev->intr_context[intr];\n\n\tqlge_write32(qdev, INTR_EN, ctx->intr_dis_mask);\n}\n\nstatic void qlge_enable_all_completion_interrupts(struct qlge_adapter *qdev)\n{\n\tint i;\n\n\tfor (i = 0; i < qdev->intr_count; i++)\n\t\tqlge_enable_completion_interrupt(qdev, i);\n}\n\nstatic int qlge_validate_flash(struct qlge_adapter *qdev, u32 size, const char *str)\n{\n\tint status, i;\n\tu16 csum = 0;\n\t__le16 *flash = (__le16 *)&qdev->flash;\n\n\tstatus = strncmp((char *)&qdev->flash, str, 4);\n\tif (status) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Invalid flash signature.\\n\");\n\t\treturn\tstatus;\n\t}\n\n\tfor (i = 0; i < size; i++)\n\t\tcsum += le16_to_cpu(*flash++);\n\n\tif (csum)\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Invalid flash checksum, csum = 0x%.04x.\\n\", csum);\n\n\treturn csum;\n}\n\nstatic int qlge_read_flash_word(struct qlge_adapter *qdev, int offset, __le32 *data)\n{\n\tint status = 0;\n\t \n\tstatus = qlge_wait_reg_rdy(qdev,\n\t\t\t\t   FLASH_ADDR, FLASH_ADDR_RDY, FLASH_ADDR_ERR);\n\tif (status)\n\t\tgoto exit;\n\t \n\tqlge_write32(qdev, FLASH_ADDR, FLASH_ADDR_R | offset);\n\t \n\tstatus = qlge_wait_reg_rdy(qdev,\n\t\t\t\t   FLASH_ADDR, FLASH_ADDR_RDY, FLASH_ADDR_ERR);\n\tif (status)\n\t\tgoto exit;\n\t \n\t*data = cpu_to_le32(qlge_read32(qdev, FLASH_DATA));\nexit:\n\treturn status;\n}\n\nstatic int qlge_get_8000_flash_params(struct qlge_adapter *qdev)\n{\n\tu32 i, size;\n\tint status;\n\t__le32 *p = (__le32 *)&qdev->flash;\n\tu32 offset;\n\tu8 mac_addr[6];\n\n\t \n\tif (!qdev->port)\n\t\toffset = FUNC0_FLASH_OFFSET / sizeof(u32);\n\telse\n\t\toffset = FUNC1_FLASH_OFFSET / sizeof(u32);\n\n\tif (qlge_sem_spinlock(qdev, SEM_FLASH_MASK))\n\t\treturn -ETIMEDOUT;\n\n\tsize = sizeof(struct flash_params_8000) / sizeof(u32);\n\tfor (i = 0; i < size; i++, p++) {\n\t\tstatus = qlge_read_flash_word(qdev, i + offset, p);\n\t\tif (status) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"Error reading flash.\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tstatus = qlge_validate_flash(qdev,\n\t\t\t\t     sizeof(struct flash_params_8000) /\n\t\t\t\t   sizeof(u16),\n\t\t\t\t   \"8000\");\n\tif (status) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Invalid flash.\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (qdev->flash.flash_params_8000.data_type1 == 2)\n\t\tmemcpy(mac_addr,\n\t\t       qdev->flash.flash_params_8000.mac_addr1,\n\t\t       qdev->ndev->addr_len);\n\telse\n\t\tmemcpy(mac_addr,\n\t\t       qdev->flash.flash_params_8000.mac_addr,\n\t\t       qdev->ndev->addr_len);\n\n\tif (!is_valid_ether_addr(mac_addr)) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Invalid MAC address.\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\teth_hw_addr_set(qdev->ndev, mac_addr);\n\nexit:\n\tqlge_sem_unlock(qdev, SEM_FLASH_MASK);\n\treturn status;\n}\n\nstatic int qlge_get_8012_flash_params(struct qlge_adapter *qdev)\n{\n\tint i;\n\tint status;\n\t__le32 *p = (__le32 *)&qdev->flash;\n\tu32 offset = 0;\n\tu32 size = sizeof(struct flash_params_8012) / sizeof(u32);\n\n\t \n\tif (qdev->port)\n\t\toffset = size;\n\n\tif (qlge_sem_spinlock(qdev, SEM_FLASH_MASK))\n\t\treturn -ETIMEDOUT;\n\n\tfor (i = 0; i < size; i++, p++) {\n\t\tstatus = qlge_read_flash_word(qdev, i + offset, p);\n\t\tif (status) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"Error reading flash.\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tstatus = qlge_validate_flash(qdev,\n\t\t\t\t     sizeof(struct flash_params_8012) /\n\t\t\t\t       sizeof(u16),\n\t\t\t\t     \"8012\");\n\tif (status) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Invalid flash.\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (!is_valid_ether_addr(qdev->flash.flash_params_8012.mac_addr)) {\n\t\tstatus = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\teth_hw_addr_set(qdev->ndev, qdev->flash.flash_params_8012.mac_addr);\n\nexit:\n\tqlge_sem_unlock(qdev, SEM_FLASH_MASK);\n\treturn status;\n}\n\n \nstatic int qlge_write_xgmac_reg(struct qlge_adapter *qdev, u32 reg, u32 data)\n{\n\tint status;\n\t \n\tstatus = qlge_wait_reg_rdy(qdev,\n\t\t\t\t   XGMAC_ADDR, XGMAC_ADDR_RDY, XGMAC_ADDR_XME);\n\tif (status)\n\t\treturn status;\n\t \n\tqlge_write32(qdev, XGMAC_DATA, data);\n\t \n\tqlge_write32(qdev, XGMAC_ADDR, reg);\n\treturn status;\n}\n\n \nint qlge_read_xgmac_reg(struct qlge_adapter *qdev, u32 reg, u32 *data)\n{\n\tint status = 0;\n\t \n\tstatus = qlge_wait_reg_rdy(qdev,\n\t\t\t\t   XGMAC_ADDR, XGMAC_ADDR_RDY, XGMAC_ADDR_XME);\n\tif (status)\n\t\tgoto exit;\n\t \n\tqlge_write32(qdev, XGMAC_ADDR, reg | XGMAC_ADDR_R);\n\t \n\tstatus = qlge_wait_reg_rdy(qdev,\n\t\t\t\t   XGMAC_ADDR, XGMAC_ADDR_RDY, XGMAC_ADDR_XME);\n\tif (status)\n\t\tgoto exit;\n\t \n\t*data = qlge_read32(qdev, XGMAC_DATA);\nexit:\n\treturn status;\n}\n\n \nint qlge_read_xgmac_reg64(struct qlge_adapter *qdev, u32 reg, u64 *data)\n{\n\tint status = 0;\n\tu32 hi = 0;\n\tu32 lo = 0;\n\n\tstatus = qlge_read_xgmac_reg(qdev, reg, &lo);\n\tif (status)\n\t\tgoto exit;\n\n\tstatus = qlge_read_xgmac_reg(qdev, reg + 4, &hi);\n\tif (status)\n\t\tgoto exit;\n\n\t*data = (u64)lo | ((u64)hi << 32);\n\nexit:\n\treturn status;\n}\n\nstatic int qlge_8000_port_initialize(struct qlge_adapter *qdev)\n{\n\tint status;\n\t \n\tstatus = qlge_mb_about_fw(qdev);\n\tif (status)\n\t\tgoto exit;\n\tstatus = qlge_mb_get_fw_state(qdev);\n\tif (status)\n\t\tgoto exit;\n\t \n\tqueue_delayed_work(qdev->workqueue, &qdev->mpi_port_cfg_work, 0);\nexit:\n\treturn status;\n}\n\n \nstatic int qlge_8012_port_initialize(struct qlge_adapter *qdev)\n{\n\tint status = 0;\n\tu32 data;\n\n\tif (qlge_sem_trylock(qdev, qdev->xg_sem_mask)) {\n\t\t \n\t\tnetif_info(qdev, link, qdev->ndev,\n\t\t\t   \"Another function has the semaphore, so wait for the port init bit to come ready.\\n\");\n\t\tstatus = qlge_wait_reg_rdy(qdev, STS, qdev->port_init, 0);\n\t\tif (status) {\n\t\t\tnetif_crit(qdev, link, qdev->ndev,\n\t\t\t\t   \"Port initialize timed out.\\n\");\n\t\t}\n\t\treturn status;\n\t}\n\n\tnetif_info(qdev, link, qdev->ndev, \"Got xgmac semaphore!.\\n\");\n\t \n\tstatus = qlge_read_xgmac_reg(qdev, GLOBAL_CFG, &data);\n\tif (status)\n\t\tgoto end;\n\tdata |= GLOBAL_CFG_RESET;\n\tstatus = qlge_write_xgmac_reg(qdev, GLOBAL_CFG, data);\n\tif (status)\n\t\tgoto end;\n\n\t \n\tdata &= ~GLOBAL_CFG_RESET;\t \n\tdata |= GLOBAL_CFG_JUMBO;\t \n\tdata |= GLOBAL_CFG_TX_STAT_EN;\n\tdata |= GLOBAL_CFG_RX_STAT_EN;\n\tstatus = qlge_write_xgmac_reg(qdev, GLOBAL_CFG, data);\n\tif (status)\n\t\tgoto end;\n\n\t \n\tstatus = qlge_read_xgmac_reg(qdev, TX_CFG, &data);\n\tif (status)\n\t\tgoto end;\n\tdata &= ~TX_CFG_RESET;\t \n\tdata |= TX_CFG_EN;\t \n\tstatus = qlge_write_xgmac_reg(qdev, TX_CFG, data);\n\tif (status)\n\t\tgoto end;\n\n\t \n\tstatus = qlge_read_xgmac_reg(qdev, RX_CFG, &data);\n\tif (status)\n\t\tgoto end;\n\tdata &= ~RX_CFG_RESET;\t \n\tdata |= RX_CFG_EN;\t \n\tstatus = qlge_write_xgmac_reg(qdev, RX_CFG, data);\n\tif (status)\n\t\tgoto end;\n\n\t \n\tstatus =\n\t    qlge_write_xgmac_reg(qdev, MAC_TX_PARAMS, MAC_TX_PARAMS_JUMBO | (0x2580 << 16));\n\tif (status)\n\t\tgoto end;\n\tstatus =\n\t    qlge_write_xgmac_reg(qdev, MAC_RX_PARAMS, 0x2580);\n\tif (status)\n\t\tgoto end;\n\n\t \n\tqlge_write32(qdev, STS, ((qdev->port_init << 16) | qdev->port_init));\nend:\n\tqlge_sem_unlock(qdev, qdev->xg_sem_mask);\n\treturn status;\n}\n\nstatic inline unsigned int qlge_lbq_block_size(struct qlge_adapter *qdev)\n{\n\treturn PAGE_SIZE << qdev->lbq_buf_order;\n}\n\nstatic struct qlge_bq_desc *qlge_get_curr_buf(struct qlge_bq *bq)\n{\n\tstruct qlge_bq_desc *bq_desc;\n\n\tbq_desc = &bq->queue[bq->next_to_clean];\n\tbq->next_to_clean = QLGE_BQ_WRAP(bq->next_to_clean + 1);\n\n\treturn bq_desc;\n}\n\nstatic struct qlge_bq_desc *qlge_get_curr_lchunk(struct qlge_adapter *qdev,\n\t\t\t\t\t\t struct rx_ring *rx_ring)\n{\n\tstruct qlge_bq_desc *lbq_desc = qlge_get_curr_buf(&rx_ring->lbq);\n\n\tdma_sync_single_for_cpu(&qdev->pdev->dev, lbq_desc->dma_addr,\n\t\t\t\tqdev->lbq_buf_size, DMA_FROM_DEVICE);\n\n\tif ((lbq_desc->p.pg_chunk.offset + qdev->lbq_buf_size) ==\n\t    qlge_lbq_block_size(qdev)) {\n\t\t \n\t\tdma_unmap_page(&qdev->pdev->dev, lbq_desc->dma_addr,\n\t\t\t       qlge_lbq_block_size(qdev), DMA_FROM_DEVICE);\n\t}\n\n\treturn lbq_desc;\n}\n\n \nstatic void qlge_update_cq(struct rx_ring *rx_ring)\n{\n\trx_ring->cnsmr_idx++;\n\trx_ring->curr_entry++;\n\tif (unlikely(rx_ring->cnsmr_idx == rx_ring->cq_len)) {\n\t\trx_ring->cnsmr_idx = 0;\n\t\trx_ring->curr_entry = rx_ring->cq_base;\n\t}\n}\n\nstatic void qlge_write_cq_idx(struct rx_ring *rx_ring)\n{\n\tqlge_write_db_reg(rx_ring->cnsmr_idx, rx_ring->cnsmr_idx_db_reg);\n}\n\nstatic const char * const bq_type_name[] = {\n\t[QLGE_SB] = \"sbq\",\n\t[QLGE_LB] = \"lbq\",\n};\n\n \nstatic int qlge_refill_sb(struct rx_ring *rx_ring,\n\t\t\t  struct qlge_bq_desc *sbq_desc, gfp_t gfp)\n{\n\tstruct qlge_adapter *qdev = rx_ring->qdev;\n\tstruct sk_buff *skb;\n\n\tif (sbq_desc->p.skb)\n\t\treturn 0;\n\n\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t     \"ring %u sbq: getting new skb for index %d.\\n\",\n\t\t     rx_ring->cq_id, sbq_desc->index);\n\n\tskb = __netdev_alloc_skb(qdev->ndev, SMALL_BUFFER_SIZE, gfp);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, QLGE_SB_PAD);\n\n\tsbq_desc->dma_addr = dma_map_single(&qdev->pdev->dev, skb->data,\n\t\t\t\t\t    SMALL_BUF_MAP_SIZE,\n\t\t\t\t\t    DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&qdev->pdev->dev, sbq_desc->dma_addr)) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"PCI mapping failed.\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EIO;\n\t}\n\t*sbq_desc->buf_ptr = cpu_to_le64(sbq_desc->dma_addr);\n\n\tsbq_desc->p.skb = skb;\n\treturn 0;\n}\n\n \nstatic int qlge_refill_lb(struct rx_ring *rx_ring,\n\t\t\t  struct qlge_bq_desc *lbq_desc, gfp_t gfp)\n{\n\tstruct qlge_adapter *qdev = rx_ring->qdev;\n\tstruct qlge_page_chunk *master_chunk = &rx_ring->master_chunk;\n\n\tif (!master_chunk->page) {\n\t\tstruct page *page;\n\t\tdma_addr_t dma_addr;\n\n\t\tpage = alloc_pages(gfp | __GFP_COMP, qdev->lbq_buf_order);\n\t\tif (unlikely(!page))\n\t\t\treturn -ENOMEM;\n\t\tdma_addr = dma_map_page(&qdev->pdev->dev, page, 0,\n\t\t\t\t\tqlge_lbq_block_size(qdev),\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&qdev->pdev->dev, dma_addr)) {\n\t\t\t__free_pages(page, qdev->lbq_buf_order);\n\t\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t\t  \"PCI mapping failed.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tmaster_chunk->page = page;\n\t\tmaster_chunk->va = page_address(page);\n\t\tmaster_chunk->offset = 0;\n\t\trx_ring->chunk_dma_addr = dma_addr;\n\t}\n\n\tlbq_desc->p.pg_chunk = *master_chunk;\n\tlbq_desc->dma_addr = rx_ring->chunk_dma_addr;\n\t*lbq_desc->buf_ptr = cpu_to_le64(lbq_desc->dma_addr +\n\t\t\t\t\t lbq_desc->p.pg_chunk.offset);\n\n\t \n\tmaster_chunk->offset += qdev->lbq_buf_size;\n\tif (master_chunk->offset == qlge_lbq_block_size(qdev)) {\n\t\tmaster_chunk->page = NULL;\n\t} else {\n\t\tmaster_chunk->va += qdev->lbq_buf_size;\n\t\tget_page(master_chunk->page);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int qlge_refill_bq(struct qlge_bq *bq, gfp_t gfp)\n{\n\tstruct rx_ring *rx_ring = QLGE_BQ_CONTAINER(bq);\n\tstruct qlge_adapter *qdev = rx_ring->qdev;\n\tstruct qlge_bq_desc *bq_desc;\n\tint refill_count;\n\tint retval;\n\tint i;\n\n\trefill_count = QLGE_BQ_WRAP(QLGE_BQ_ALIGN(bq->next_to_clean - 1) -\n\t\t\t\t    bq->next_to_use);\n\tif (!refill_count)\n\t\treturn 0;\n\n\ti = bq->next_to_use;\n\tbq_desc = &bq->queue[i];\n\ti -= QLGE_BQ_LEN;\n\tdo {\n\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"ring %u %s: try cleaning idx %d\\n\",\n\t\t\t     rx_ring->cq_id, bq_type_name[bq->type], i);\n\n\t\tif (bq->type == QLGE_SB)\n\t\t\tretval = qlge_refill_sb(rx_ring, bq_desc, gfp);\n\t\telse\n\t\t\tretval = qlge_refill_lb(rx_ring, bq_desc, gfp);\n\t\tif (retval < 0) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"ring %u %s: Could not get a page chunk, idx %d\\n\",\n\t\t\t\t  rx_ring->cq_id, bq_type_name[bq->type], i);\n\t\t\tbreak;\n\t\t}\n\n\t\tbq_desc++;\n\t\ti++;\n\t\tif (unlikely(!i)) {\n\t\t\tbq_desc = &bq->queue[0];\n\t\t\ti -= QLGE_BQ_LEN;\n\t\t}\n\t\trefill_count--;\n\t} while (refill_count);\n\ti += QLGE_BQ_LEN;\n\n\tif (bq->next_to_use != i) {\n\t\tif (QLGE_BQ_ALIGN(bq->next_to_use) != QLGE_BQ_ALIGN(i)) {\n\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"ring %u %s: updating prod idx = %d.\\n\",\n\t\t\t\t     rx_ring->cq_id, bq_type_name[bq->type],\n\t\t\t\t     i);\n\t\t\tqlge_write_db_reg(i, bq->prod_idx_db_reg);\n\t\t}\n\t\tbq->next_to_use = i;\n\t}\n\n\treturn retval;\n}\n\nstatic void qlge_update_buffer_queues(struct rx_ring *rx_ring, gfp_t gfp,\n\t\t\t\t      unsigned long delay)\n{\n\tbool sbq_fail, lbq_fail;\n\n\tsbq_fail = !!qlge_refill_bq(&rx_ring->sbq, gfp);\n\tlbq_fail = !!qlge_refill_bq(&rx_ring->lbq, gfp);\n\n\t \n\tif ((sbq_fail && QLGE_BQ_HW_OWNED(&rx_ring->sbq) < 2) ||\n\t    (lbq_fail && QLGE_BQ_HW_OWNED(&rx_ring->lbq) <\n\t     DIV_ROUND_UP(9000, LARGE_BUFFER_MAX_SIZE)))\n\t\t \n\t\tqueue_delayed_work_on(smp_processor_id(), system_long_wq,\n\t\t\t\t      &rx_ring->refill_work, delay);\n}\n\nstatic void qlge_slow_refill(struct work_struct *work)\n{\n\tstruct rx_ring *rx_ring = container_of(work, struct rx_ring,\n\t\t\t\t\t       refill_work.work);\n\tstruct napi_struct *napi = &rx_ring->napi;\n\n\tnapi_disable(napi);\n\tqlge_update_buffer_queues(rx_ring, GFP_KERNEL, HZ / 2);\n\tnapi_enable(napi);\n\n\tlocal_bh_disable();\n\t \n\tnapi_schedule(napi);\n\t \n\tlocal_bh_enable();\n}\n\n \nstatic void qlge_unmap_send(struct qlge_adapter *qdev,\n\t\t\t    struct tx_ring_desc *tx_ring_desc, int mapped)\n{\n\tint i;\n\n\tfor (i = 0; i < mapped; i++) {\n\t\tif (i == 0 || (i == 7 && mapped > 7)) {\n\t\t\t \n\t\t\tif (i == 7) {\n\t\t\t\tnetif_printk(qdev, tx_done, KERN_DEBUG,\n\t\t\t\t\t     qdev->ndev,\n\t\t\t\t\t     \"unmapping OAL area.\\n\");\n\t\t\t}\n\t\t\tdma_unmap_single(&qdev->pdev->dev,\n\t\t\t\t\t dma_unmap_addr(&tx_ring_desc->map[i],\n\t\t\t\t\t\t\tmapaddr),\n\t\t\t\t\t dma_unmap_len(&tx_ring_desc->map[i],\n\t\t\t\t\t\t       maplen),\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t} else {\n\t\t\tnetif_printk(qdev, tx_done, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"unmapping frag %d.\\n\", i);\n\t\t\tdma_unmap_page(&qdev->pdev->dev,\n\t\t\t\t       dma_unmap_addr(&tx_ring_desc->map[i],\n\t\t\t\t\t\t      mapaddr),\n\t\t\t\t       dma_unmap_len(&tx_ring_desc->map[i],\n\t\t\t\t\t\t     maplen), DMA_TO_DEVICE);\n\t\t}\n\t}\n}\n\n \nstatic int qlge_map_send(struct qlge_adapter *qdev,\n\t\t\t struct qlge_ob_mac_iocb_req *mac_iocb_ptr,\n\t\t\t struct sk_buff *skb, struct tx_ring_desc *tx_ring_desc)\n{\n\tint len = skb_headlen(skb);\n\tdma_addr_t map;\n\tint frag_idx, err, map_idx = 0;\n\tstruct tx_buf_desc *tbd = mac_iocb_ptr->tbd;\n\tint frag_cnt = skb_shinfo(skb)->nr_frags;\n\n\tif (frag_cnt) {\n\t\tnetif_printk(qdev, tx_queued, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"frag_cnt = %d.\\n\", frag_cnt);\n\t}\n\t \n\tmap = dma_map_single(&qdev->pdev->dev, skb->data, len, DMA_TO_DEVICE);\n\n\terr = dma_mapping_error(&qdev->pdev->dev, map);\n\tif (err) {\n\t\tnetif_err(qdev, tx_queued, qdev->ndev,\n\t\t\t  \"PCI mapping failed with error: %d\\n\", err);\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\ttbd->len = cpu_to_le32(len);\n\ttbd->addr = cpu_to_le64(map);\n\tdma_unmap_addr_set(&tx_ring_desc->map[map_idx], mapaddr, map);\n\tdma_unmap_len_set(&tx_ring_desc->map[map_idx], maplen, len);\n\tmap_idx++;\n\n\t \n\tfor (frag_idx = 0; frag_idx < frag_cnt; frag_idx++, map_idx++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[frag_idx];\n\n\t\ttbd++;\n\t\tif (frag_idx == 6 && frag_cnt > 7) {\n\t\t\t \n\t\t\t \n\t\t\tmap = dma_map_single(&qdev->pdev->dev, &tx_ring_desc->oal,\n\t\t\t\t\t     sizeof(struct qlge_oal),\n\t\t\t\t\t     DMA_TO_DEVICE);\n\t\t\terr = dma_mapping_error(&qdev->pdev->dev, map);\n\t\t\tif (err) {\n\t\t\t\tnetif_err(qdev, tx_queued, qdev->ndev,\n\t\t\t\t\t  \"PCI mapping outbound address list with error: %d\\n\",\n\t\t\t\t\t  err);\n\t\t\t\tgoto map_error;\n\t\t\t}\n\n\t\t\ttbd->addr = cpu_to_le64(map);\n\t\t\t \n\t\t\ttbd->len =\n\t\t\t    cpu_to_le32((sizeof(struct tx_buf_desc) *\n\t\t\t\t\t (frag_cnt - frag_idx)) | TX_DESC_C);\n\t\t\tdma_unmap_addr_set(&tx_ring_desc->map[map_idx], mapaddr,\n\t\t\t\t\t   map);\n\t\t\tdma_unmap_len_set(&tx_ring_desc->map[map_idx], maplen,\n\t\t\t\t\t  sizeof(struct qlge_oal));\n\t\t\ttbd = (struct tx_buf_desc *)&tx_ring_desc->oal;\n\t\t\tmap_idx++;\n\t\t}\n\n\t\tmap = skb_frag_dma_map(&qdev->pdev->dev, frag, 0, skb_frag_size(frag),\n\t\t\t\t       DMA_TO_DEVICE);\n\n\t\terr = dma_mapping_error(&qdev->pdev->dev, map);\n\t\tif (err) {\n\t\t\tnetif_err(qdev, tx_queued, qdev->ndev,\n\t\t\t\t  \"PCI mapping frags failed with error: %d.\\n\",\n\t\t\t\t  err);\n\t\t\tgoto map_error;\n\t\t}\n\n\t\ttbd->addr = cpu_to_le64(map);\n\t\ttbd->len = cpu_to_le32(skb_frag_size(frag));\n\t\tdma_unmap_addr_set(&tx_ring_desc->map[map_idx], mapaddr, map);\n\t\tdma_unmap_len_set(&tx_ring_desc->map[map_idx], maplen,\n\t\t\t\t  skb_frag_size(frag));\n\t}\n\t \n\ttx_ring_desc->map_cnt = map_idx;\n\t \n\ttbd->len = cpu_to_le32(le32_to_cpu(tbd->len) | TX_DESC_E);\n\treturn NETDEV_TX_OK;\n\nmap_error:\n\t \n\tqlge_unmap_send(qdev, tx_ring_desc, map_idx);\n\treturn NETDEV_TX_BUSY;\n}\n\n \nstatic void qlge_categorize_rx_err(struct qlge_adapter *qdev, u8 rx_err,\n\t\t\t\t   struct rx_ring *rx_ring)\n{\n\tstruct nic_stats *stats = &qdev->nic_stats;\n\n\tstats->rx_err_count++;\n\trx_ring->rx_errors++;\n\n\tswitch (rx_err & IB_MAC_IOCB_RSP_ERR_MASK) {\n\tcase IB_MAC_IOCB_RSP_ERR_CODE_ERR:\n\t\tstats->rx_code_err++;\n\t\tbreak;\n\tcase IB_MAC_IOCB_RSP_ERR_OVERSIZE:\n\t\tstats->rx_oversize_err++;\n\t\tbreak;\n\tcase IB_MAC_IOCB_RSP_ERR_UNDERSIZE:\n\t\tstats->rx_undersize_err++;\n\t\tbreak;\n\tcase IB_MAC_IOCB_RSP_ERR_PREAMBLE:\n\t\tstats->rx_preamble_err++;\n\t\tbreak;\n\tcase IB_MAC_IOCB_RSP_ERR_FRAME_LEN:\n\t\tstats->rx_frame_len_err++;\n\t\tbreak;\n\tcase IB_MAC_IOCB_RSP_ERR_CRC:\n\t\tstats->rx_crc_err++;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void qlge_update_mac_hdr_len(struct qlge_adapter *qdev,\n\t\t\t\t    struct qlge_ib_mac_iocb_rsp *ib_mac_rsp,\n\t\t\t\t    void *page, size_t *len)\n{\n\tu16 *tags;\n\n\tif (qdev->ndev->features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\treturn;\n\tif (ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_V) {\n\t\ttags = (u16 *)page;\n\t\t \n\t\tif (tags[6] == ETH_P_8021Q &&\n\t\t    tags[8] == ETH_P_8021Q)\n\t\t\t*len += 2 * VLAN_HLEN;\n\t\telse\n\t\t\t*len += VLAN_HLEN;\n\t}\n}\n\n \nstatic void qlge_process_mac_rx_gro_page(struct qlge_adapter *qdev,\n\t\t\t\t\t struct rx_ring *rx_ring,\n\t\t\t\t\t struct qlge_ib_mac_iocb_rsp *ib_mac_rsp,\n\t\t\t\t\t u32 length, u16 vlan_id)\n{\n\tstruct sk_buff *skb;\n\tstruct qlge_bq_desc *lbq_desc = qlge_get_curr_lchunk(qdev, rx_ring);\n\tstruct napi_struct *napi = &rx_ring->napi;\n\n\t \n\tif (ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_ERR_MASK) {\n\t\tqlge_categorize_rx_err(qdev, ib_mac_rsp->flags2, rx_ring);\n\t\tput_page(lbq_desc->p.pg_chunk.page);\n\t\treturn;\n\t}\n\tnapi->dev = qdev->ndev;\n\n\tskb = napi_get_frags(napi);\n\tif (!skb) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Couldn't get an skb, exiting.\\n\");\n\t\trx_ring->rx_dropped++;\n\t\tput_page(lbq_desc->p.pg_chunk.page);\n\t\treturn;\n\t}\n\tprefetch(lbq_desc->p.pg_chunk.va);\n\t__skb_fill_page_desc(skb, skb_shinfo(skb)->nr_frags,\n\t\t\t     lbq_desc->p.pg_chunk.page,\n\t\t\t     lbq_desc->p.pg_chunk.offset,\n\t\t\t     length);\n\n\tskb->len += length;\n\tskb->data_len += length;\n\tskb->truesize += length;\n\tskb_shinfo(skb)->nr_frags++;\n\n\trx_ring->rx_packets++;\n\trx_ring->rx_bytes += length;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb_record_rx_queue(skb, rx_ring->cq_id);\n\tif (vlan_id != 0xffff)\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_id);\n\tnapi_gro_frags(napi);\n}\n\n \nstatic void qlge_process_mac_rx_page(struct qlge_adapter *qdev,\n\t\t\t\t     struct rx_ring *rx_ring,\n\t\t\t\t     struct qlge_ib_mac_iocb_rsp *ib_mac_rsp,\n\t\t\t\t     u32 length, u16 vlan_id)\n{\n\tstruct net_device *ndev = qdev->ndev;\n\tstruct sk_buff *skb = NULL;\n\tvoid *addr;\n\tstruct qlge_bq_desc *lbq_desc = qlge_get_curr_lchunk(qdev, rx_ring);\n\tstruct napi_struct *napi = &rx_ring->napi;\n\tsize_t hlen = ETH_HLEN;\n\n\tskb = netdev_alloc_skb(ndev, length);\n\tif (!skb) {\n\t\trx_ring->rx_dropped++;\n\t\tput_page(lbq_desc->p.pg_chunk.page);\n\t\treturn;\n\t}\n\n\taddr = lbq_desc->p.pg_chunk.va;\n\tprefetch(addr);\n\n\t \n\tif (ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_ERR_MASK) {\n\t\tqlge_categorize_rx_err(qdev, ib_mac_rsp->flags2, rx_ring);\n\t\tgoto err_out;\n\t}\n\n\t \n\tqlge_update_mac_hdr_len(qdev, ib_mac_rsp, addr, &hlen);\n\n\t \n\tif (skb->len > ndev->mtu + hlen) {\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"Segment too small, dropping.\\n\");\n\t\trx_ring->rx_dropped++;\n\t\tgoto err_out;\n\t}\n\tskb_put_data(skb, addr, hlen);\n\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t     \"%d bytes of headers and data in large. Chain page to new skb and pull tail.\\n\",\n\t\t     length);\n\tskb_fill_page_desc(skb, 0, lbq_desc->p.pg_chunk.page,\n\t\t\t   lbq_desc->p.pg_chunk.offset + hlen, length - hlen);\n\tskb->len += length - hlen;\n\tskb->data_len += length - hlen;\n\tskb->truesize += length - hlen;\n\n\trx_ring->rx_packets++;\n\trx_ring->rx_bytes += skb->len;\n\tskb->protocol = eth_type_trans(skb, ndev);\n\tskb_checksum_none_assert(skb);\n\n\tif ((ndev->features & NETIF_F_RXCSUM) &&\n\t    !(ib_mac_rsp->flags1 & IB_MAC_CSUM_ERR_MASK)) {\n\t\t \n\t\tif (ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_T) {\n\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"TCP checksum done!\\n\");\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t} else if ((ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_U) &&\n\t\t\t   (ib_mac_rsp->flags3 & IB_MAC_IOCB_RSP_V4)) {\n\t\t\t \n\t\t\tstruct iphdr *iph =\n\t\t\t\t(struct iphdr *)((u8 *)addr + hlen);\n\t\t\tif (!(iph->frag_off &\n\t\t\t      htons(IP_MF | IP_OFFSET))) {\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG,\n\t\t\t\t\t     qdev->ndev,\n\t\t\t\t\t     \"UDP checksum done!\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tskb_record_rx_queue(skb, rx_ring->cq_id);\n\tif (vlan_id != 0xffff)\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_id);\n\tif (skb->ip_summed == CHECKSUM_UNNECESSARY)\n\t\tnapi_gro_receive(napi, skb);\n\telse\n\t\tnetif_receive_skb(skb);\n\treturn;\nerr_out:\n\tdev_kfree_skb_any(skb);\n\tput_page(lbq_desc->p.pg_chunk.page);\n}\n\n \nstatic void qlge_process_mac_rx_skb(struct qlge_adapter *qdev,\n\t\t\t\t    struct rx_ring *rx_ring,\n\t\t\t\t    struct qlge_ib_mac_iocb_rsp *ib_mac_rsp,\n\t\t\t\t    u32 length, u16 vlan_id)\n{\n\tstruct qlge_bq_desc *sbq_desc = qlge_get_curr_buf(&rx_ring->sbq);\n\tstruct net_device *ndev = qdev->ndev;\n\tstruct sk_buff *skb, *new_skb;\n\n\tskb = sbq_desc->p.skb;\n\t \n\tnew_skb = netdev_alloc_skb(qdev->ndev, length + NET_IP_ALIGN);\n\tif (!new_skb) {\n\t\trx_ring->rx_dropped++;\n\t\treturn;\n\t}\n\tskb_reserve(new_skb, NET_IP_ALIGN);\n\n\tdma_sync_single_for_cpu(&qdev->pdev->dev, sbq_desc->dma_addr,\n\t\t\t\tSMALL_BUF_MAP_SIZE, DMA_FROM_DEVICE);\n\n\tskb_put_data(new_skb, skb->data, length);\n\n\tskb = new_skb;\n\n\t \n\tif (ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_ERR_MASK) {\n\t\tqlge_categorize_rx_err(qdev, ib_mac_rsp->flags2, rx_ring);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\t \n\tif (test_bit(QL_SELFTEST, &qdev->flags)) {\n\t\tqlge_check_lb_frame(qdev, skb);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\t \n\tif (skb->len > ndev->mtu + ETH_HLEN) {\n\t\tdev_kfree_skb_any(skb);\n\t\trx_ring->rx_dropped++;\n\t\treturn;\n\t}\n\n\tprefetch(skb->data);\n\tif (ib_mac_rsp->flags1 & IB_MAC_IOCB_RSP_M_MASK) {\n\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"%s Multicast.\\n\",\n\t\t\t     (ib_mac_rsp->flags1 & IB_MAC_IOCB_RSP_M_MASK) ==\n\t\t\t     IB_MAC_IOCB_RSP_M_HASH ? \"Hash\" :\n\t\t\t     (ib_mac_rsp->flags1 & IB_MAC_IOCB_RSP_M_MASK) ==\n\t\t\t     IB_MAC_IOCB_RSP_M_REG ? \"Registered\" :\n\t\t\t     (ib_mac_rsp->flags1 & IB_MAC_IOCB_RSP_M_MASK) ==\n\t\t\t     IB_MAC_IOCB_RSP_M_PROM ? \"Promiscuous\" : \"\");\n\t}\n\tif (ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_P)\n\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"Promiscuous Packet.\\n\");\n\n\trx_ring->rx_packets++;\n\trx_ring->rx_bytes += skb->len;\n\tskb->protocol = eth_type_trans(skb, ndev);\n\tskb_checksum_none_assert(skb);\n\n\t \n\tif ((ndev->features & NETIF_F_RXCSUM) &&\n\t    !(ib_mac_rsp->flags1 & IB_MAC_CSUM_ERR_MASK)) {\n\t\t \n\t\tif (ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_T) {\n\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"TCP checksum done!\\n\");\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t} else if ((ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_U) &&\n\t\t\t   (ib_mac_rsp->flags3 & IB_MAC_IOCB_RSP_V4)) {\n\t\t\t \n\t\t\tstruct iphdr *iph = (struct iphdr *)skb->data;\n\n\t\t\tif (!(iph->frag_off &\n\t\t\t      htons(IP_MF | IP_OFFSET))) {\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG,\n\t\t\t\t\t     qdev->ndev,\n\t\t\t\t\t     \"UDP checksum done!\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tskb_record_rx_queue(skb, rx_ring->cq_id);\n\tif (vlan_id != 0xffff)\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_id);\n\tif (skb->ip_summed == CHECKSUM_UNNECESSARY)\n\t\tnapi_gro_receive(&rx_ring->napi, skb);\n\telse\n\t\tnetif_receive_skb(skb);\n}\n\nstatic void qlge_realign_skb(struct sk_buff *skb, int len)\n{\n\tvoid *temp_addr = skb->data;\n\n\t \n\tskb->data -= QLGE_SB_PAD - NET_IP_ALIGN;\n\tskb->tail -= QLGE_SB_PAD - NET_IP_ALIGN;\n\tmemmove(skb->data, temp_addr, len);\n}\n\n \nstatic struct sk_buff *qlge_build_rx_skb(struct qlge_adapter *qdev,\n\t\t\t\t\t struct rx_ring *rx_ring,\n\t\t\t\t\t struct qlge_ib_mac_iocb_rsp *ib_mac_rsp)\n{\n\tu32 length = le32_to_cpu(ib_mac_rsp->data_len);\n\tu32 hdr_len = le32_to_cpu(ib_mac_rsp->hdr_len);\n\tstruct qlge_bq_desc *lbq_desc, *sbq_desc;\n\tstruct sk_buff *skb = NULL;\n\tsize_t hlen = ETH_HLEN;\n\n\t \n\tif (ib_mac_rsp->flags4 & IB_MAC_IOCB_RSP_HV &&\n\t    ib_mac_rsp->flags4 & IB_MAC_IOCB_RSP_HS) {\n\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"Header of %d bytes in small buffer.\\n\", hdr_len);\n\t\t \n\t\tsbq_desc = qlge_get_curr_buf(&rx_ring->sbq);\n\t\tdma_unmap_single(&qdev->pdev->dev, sbq_desc->dma_addr,\n\t\t\t\t SMALL_BUF_MAP_SIZE, DMA_FROM_DEVICE);\n\t\tskb = sbq_desc->p.skb;\n\t\tqlge_realign_skb(skb, hdr_len);\n\t\tskb_put(skb, hdr_len);\n\t\tsbq_desc->p.skb = NULL;\n\t}\n\n\t \n\tif (unlikely(!length)) {\t \n\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"No Data buffer in this packet.\\n\");\n\t\treturn skb;\n\t}\n\n\tif (ib_mac_rsp->flags3 & IB_MAC_IOCB_RSP_DS) {\n\t\tif (ib_mac_rsp->flags4 & IB_MAC_IOCB_RSP_HS) {\n\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"Headers in small, data of %d bytes in small, combine them.\\n\",\n\t\t\t\t     length);\n\t\t\t \n\t\t\tsbq_desc = qlge_get_curr_buf(&rx_ring->sbq);\n\t\t\tdma_sync_single_for_cpu(&qdev->pdev->dev,\n\t\t\t\t\t\tsbq_desc->dma_addr,\n\t\t\t\t\t\tSMALL_BUF_MAP_SIZE,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\tskb_put_data(skb, sbq_desc->p.skb->data, length);\n\t\t} else {\n\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"%d bytes in a single small buffer.\\n\",\n\t\t\t\t     length);\n\t\t\tsbq_desc = qlge_get_curr_buf(&rx_ring->sbq);\n\t\t\tskb = sbq_desc->p.skb;\n\t\t\tqlge_realign_skb(skb, length);\n\t\t\tskb_put(skb, length);\n\t\t\tdma_unmap_single(&qdev->pdev->dev, sbq_desc->dma_addr,\n\t\t\t\t\t SMALL_BUF_MAP_SIZE,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tsbq_desc->p.skb = NULL;\n\t\t}\n\t} else if (ib_mac_rsp->flags3 & IB_MAC_IOCB_RSP_DL) {\n\t\tif (ib_mac_rsp->flags4 & IB_MAC_IOCB_RSP_HS) {\n\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"Header in small, %d bytes in large. Chain large to small!\\n\",\n\t\t\t\t     length);\n\t\t\t \n\t\t\tlbq_desc = qlge_get_curr_lchunk(qdev, rx_ring);\n\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"Chaining page at offset = %d, for %d bytes  to skb.\\n\",\n\t\t\t\t     lbq_desc->p.pg_chunk.offset, length);\n\t\t\tskb_fill_page_desc(skb, 0, lbq_desc->p.pg_chunk.page,\n\t\t\t\t\t   lbq_desc->p.pg_chunk.offset, length);\n\t\t\tskb->len += length;\n\t\t\tskb->data_len += length;\n\t\t\tskb->truesize += length;\n\t\t} else {\n\t\t\t \n\t\t\tlbq_desc = qlge_get_curr_lchunk(qdev, rx_ring);\n\t\t\tskb = netdev_alloc_skb(qdev->ndev, length);\n\t\t\tif (!skb) {\n\t\t\t\tnetif_printk(qdev, probe, KERN_DEBUG, qdev->ndev,\n\t\t\t\t\t     \"No skb available, drop the packet.\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdma_unmap_page(&qdev->pdev->dev, lbq_desc->dma_addr,\n\t\t\t\t       qdev->lbq_buf_size,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\tskb_reserve(skb, NET_IP_ALIGN);\n\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"%d bytes of headers and data in large. Chain page to new skb and pull tail.\\n\",\n\t\t\t\t     length);\n\t\t\tskb_fill_page_desc(skb, 0, lbq_desc->p.pg_chunk.page,\n\t\t\t\t\t   lbq_desc->p.pg_chunk.offset,\n\t\t\t\t\t   length);\n\t\t\tskb->len += length;\n\t\t\tskb->data_len += length;\n\t\t\tskb->truesize += length;\n\t\t\tqlge_update_mac_hdr_len(qdev, ib_mac_rsp,\n\t\t\t\t\t\tlbq_desc->p.pg_chunk.va,\n\t\t\t\t\t\t&hlen);\n\t\t\t__pskb_pull_tail(skb, hlen);\n\t\t}\n\t} else {\n\t\t \n\t\tint size, i = 0;\n\n\t\tsbq_desc = qlge_get_curr_buf(&rx_ring->sbq);\n\t\tdma_unmap_single(&qdev->pdev->dev, sbq_desc->dma_addr,\n\t\t\t\t SMALL_BUF_MAP_SIZE, DMA_FROM_DEVICE);\n\t\tif (!(ib_mac_rsp->flags4 & IB_MAC_IOCB_RSP_HS)) {\n\t\t\t \n\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"%d bytes of headers & data in chain of large.\\n\",\n\t\t\t\t     length);\n\t\t\tskb = sbq_desc->p.skb;\n\t\t\tsbq_desc->p.skb = NULL;\n\t\t\tskb_reserve(skb, NET_IP_ALIGN);\n\t\t}\n\t\tdo {\n\t\t\tlbq_desc = qlge_get_curr_lchunk(qdev, rx_ring);\n\t\t\tsize = min(length, qdev->lbq_buf_size);\n\n\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"Adding page %d to skb for %d bytes.\\n\",\n\t\t\t\t     i, size);\n\t\t\tskb_fill_page_desc(skb, i,\n\t\t\t\t\t   lbq_desc->p.pg_chunk.page,\n\t\t\t\t\t   lbq_desc->p.pg_chunk.offset, size);\n\t\t\tskb->len += size;\n\t\t\tskb->data_len += size;\n\t\t\tskb->truesize += size;\n\t\t\tlength -= size;\n\t\t\ti++;\n\t\t} while (length > 0);\n\t\tqlge_update_mac_hdr_len(qdev, ib_mac_rsp, lbq_desc->p.pg_chunk.va,\n\t\t\t\t\t&hlen);\n\t\t__pskb_pull_tail(skb, hlen);\n\t}\n\treturn skb;\n}\n\n \nstatic void qlge_process_mac_split_rx_intr(struct qlge_adapter *qdev,\n\t\t\t\t\t   struct rx_ring *rx_ring,\n\t\t\t\t\t   struct qlge_ib_mac_iocb_rsp *ib_mac_rsp,\n\t\t\t\t\t   u16 vlan_id)\n{\n\tstruct net_device *ndev = qdev->ndev;\n\tstruct sk_buff *skb = NULL;\n\n\tskb = qlge_build_rx_skb(qdev, rx_ring, ib_mac_rsp);\n\tif (unlikely(!skb)) {\n\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"No skb available, drop packet.\\n\");\n\t\trx_ring->rx_dropped++;\n\t\treturn;\n\t}\n\n\t \n\tif (ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_ERR_MASK) {\n\t\tqlge_categorize_rx_err(qdev, ib_mac_rsp->flags2, rx_ring);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\t \n\tif (skb->len > ndev->mtu + ETH_HLEN) {\n\t\tdev_kfree_skb_any(skb);\n\t\trx_ring->rx_dropped++;\n\t\treturn;\n\t}\n\n\t \n\tif (test_bit(QL_SELFTEST, &qdev->flags)) {\n\t\tqlge_check_lb_frame(qdev, skb);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\tprefetch(skb->data);\n\tif (ib_mac_rsp->flags1 & IB_MAC_IOCB_RSP_M_MASK) {\n\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev, \"%s Multicast.\\n\",\n\t\t\t     (ib_mac_rsp->flags1 & IB_MAC_IOCB_RSP_M_MASK) ==\n\t\t\t     IB_MAC_IOCB_RSP_M_HASH ? \"Hash\" :\n\t\t\t     (ib_mac_rsp->flags1 & IB_MAC_IOCB_RSP_M_MASK) ==\n\t\t\t     IB_MAC_IOCB_RSP_M_REG ? \"Registered\" :\n\t\t\t     (ib_mac_rsp->flags1 & IB_MAC_IOCB_RSP_M_MASK) ==\n\t\t\t     IB_MAC_IOCB_RSP_M_PROM ? \"Promiscuous\" : \"\");\n\t\trx_ring->rx_multicast++;\n\t}\n\tif (ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_P) {\n\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"Promiscuous Packet.\\n\");\n\t}\n\n\tskb->protocol = eth_type_trans(skb, ndev);\n\tskb_checksum_none_assert(skb);\n\n\t \n\tif ((ndev->features & NETIF_F_RXCSUM) &&\n\t    !(ib_mac_rsp->flags1 & IB_MAC_CSUM_ERR_MASK)) {\n\t\t \n\t\tif (ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_T) {\n\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"TCP checksum done!\\n\");\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t} else if ((ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_U) &&\n\t\t\t   (ib_mac_rsp->flags3 & IB_MAC_IOCB_RSP_V4)) {\n\t\t\t \n\t\t\tstruct iphdr *iph = (struct iphdr *)skb->data;\n\n\t\t\tif (!(iph->frag_off &\n\t\t\t      htons(IP_MF | IP_OFFSET))) {\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t\t     \"TCP checksum done!\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\trx_ring->rx_packets++;\n\trx_ring->rx_bytes += skb->len;\n\tskb_record_rx_queue(skb, rx_ring->cq_id);\n\tif (vlan_id != 0xffff)\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_id);\n\tif (skb->ip_summed == CHECKSUM_UNNECESSARY)\n\t\tnapi_gro_receive(&rx_ring->napi, skb);\n\telse\n\t\tnetif_receive_skb(skb);\n}\n\n \nstatic unsigned long qlge_process_mac_rx_intr(struct qlge_adapter *qdev,\n\t\t\t\t\t      struct rx_ring *rx_ring,\n\t\t\t\t\t      struct qlge_ib_mac_iocb_rsp *ib_mac_rsp)\n{\n\tu32 length = le32_to_cpu(ib_mac_rsp->data_len);\n\tu16 vlan_id = ((ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_V) &&\n\t\t       (qdev->ndev->features & NETIF_F_HW_VLAN_CTAG_RX)) ?\n\t\t((le16_to_cpu(ib_mac_rsp->vlan_id) &\n\t\t  IB_MAC_IOCB_RSP_VLAN_MASK)) : 0xffff;\n\n\tif (ib_mac_rsp->flags4 & IB_MAC_IOCB_RSP_HV) {\n\t\t \n\t\tqlge_process_mac_split_rx_intr(qdev, rx_ring, ib_mac_rsp,\n\t\t\t\t\t       vlan_id);\n\t} else if (ib_mac_rsp->flags3 & IB_MAC_IOCB_RSP_DS) {\n\t\t \n\t\tqlge_process_mac_rx_skb(qdev, rx_ring, ib_mac_rsp, length,\n\t\t\t\t\tvlan_id);\n\t} else if ((ib_mac_rsp->flags3 & IB_MAC_IOCB_RSP_DL) &&\n\t\t   !(ib_mac_rsp->flags1 & IB_MAC_CSUM_ERR_MASK) &&\n\t\t   (ib_mac_rsp->flags2 & IB_MAC_IOCB_RSP_T)) {\n\t\t \n\t\tqlge_process_mac_rx_gro_page(qdev, rx_ring, ib_mac_rsp, length,\n\t\t\t\t\t     vlan_id);\n\t} else if (ib_mac_rsp->flags3 & IB_MAC_IOCB_RSP_DL) {\n\t\t \n\t\tqlge_process_mac_rx_page(qdev, rx_ring, ib_mac_rsp, length,\n\t\t\t\t\t vlan_id);\n\t} else {\n\t\t \n\t\tqlge_process_mac_split_rx_intr(qdev, rx_ring, ib_mac_rsp,\n\t\t\t\t\t       vlan_id);\n\t}\n\n\treturn (unsigned long)length;\n}\n\n \nstatic void qlge_process_mac_tx_intr(struct qlge_adapter *qdev,\n\t\t\t\t     struct qlge_ob_mac_iocb_rsp *mac_rsp)\n{\n\tstruct tx_ring *tx_ring;\n\tstruct tx_ring_desc *tx_ring_desc;\n\n\ttx_ring = &qdev->tx_ring[mac_rsp->txq_idx];\n\ttx_ring_desc = &tx_ring->q[mac_rsp->tid];\n\tqlge_unmap_send(qdev, tx_ring_desc, tx_ring_desc->map_cnt);\n\ttx_ring->tx_bytes += (tx_ring_desc->skb)->len;\n\ttx_ring->tx_packets++;\n\tdev_kfree_skb(tx_ring_desc->skb);\n\ttx_ring_desc->skb = NULL;\n\n\tif (unlikely(mac_rsp->flags1 & (OB_MAC_IOCB_RSP_E |\n\t\t\t\t\tOB_MAC_IOCB_RSP_S |\n\t\t\t\t\tOB_MAC_IOCB_RSP_L |\n\t\t\t\t\tOB_MAC_IOCB_RSP_P | OB_MAC_IOCB_RSP_B))) {\n\t\tif (mac_rsp->flags1 & OB_MAC_IOCB_RSP_E) {\n\t\t\tnetif_warn(qdev, tx_done, qdev->ndev,\n\t\t\t\t   \"Total descriptor length did not match transfer length.\\n\");\n\t\t}\n\t\tif (mac_rsp->flags1 & OB_MAC_IOCB_RSP_S) {\n\t\t\tnetif_warn(qdev, tx_done, qdev->ndev,\n\t\t\t\t   \"Frame too short to be valid, not sent.\\n\");\n\t\t}\n\t\tif (mac_rsp->flags1 & OB_MAC_IOCB_RSP_L) {\n\t\t\tnetif_warn(qdev, tx_done, qdev->ndev,\n\t\t\t\t   \"Frame too long, but sent anyway.\\n\");\n\t\t}\n\t\tif (mac_rsp->flags1 & OB_MAC_IOCB_RSP_B) {\n\t\t\tnetif_warn(qdev, tx_done, qdev->ndev,\n\t\t\t\t   \"PCI backplane error. Frame not sent.\\n\");\n\t\t}\n\t}\n\tatomic_inc(&tx_ring->tx_count);\n}\n\n \nvoid qlge_queue_fw_error(struct qlge_adapter *qdev)\n{\n\tqlge_link_off(qdev);\n\tqueue_delayed_work(qdev->workqueue, &qdev->mpi_reset_work, 0);\n}\n\nvoid qlge_queue_asic_error(struct qlge_adapter *qdev)\n{\n\tqlge_link_off(qdev);\n\tqlge_disable_interrupts(qdev);\n\t \n\tclear_bit(QL_ADAPTER_UP, &qdev->flags);\n\t \n\tset_bit(QL_ASIC_RECOVERY, &qdev->flags);\n\tqueue_delayed_work(qdev->workqueue, &qdev->asic_reset_work, 0);\n}\n\nstatic void qlge_process_chip_ae_intr(struct qlge_adapter *qdev,\n\t\t\t\t      struct qlge_ib_ae_iocb_rsp *ib_ae_rsp)\n{\n\tswitch (ib_ae_rsp->event) {\n\tcase MGMT_ERR_EVENT:\n\t\tnetif_err(qdev, rx_err, qdev->ndev,\n\t\t\t  \"Management Processor Fatal Error.\\n\");\n\t\tqlge_queue_fw_error(qdev);\n\t\treturn;\n\n\tcase CAM_LOOKUP_ERR_EVENT:\n\t\tnetdev_err(qdev->ndev, \"Multiple CAM hits lookup occurred.\\n\");\n\t\tnetdev_err(qdev->ndev, \"This event shouldn't occur.\\n\");\n\t\tqlge_queue_asic_error(qdev);\n\t\treturn;\n\n\tcase SOFT_ECC_ERROR_EVENT:\n\t\tnetdev_err(qdev->ndev, \"Soft ECC error detected.\\n\");\n\t\tqlge_queue_asic_error(qdev);\n\t\tbreak;\n\n\tcase PCI_ERR_ANON_BUF_RD:\n\t\tnetdev_err(qdev->ndev,\n\t\t\t   \"PCI error occurred when reading anonymous buffers from rx_ring %d.\\n\",\n\t\t\t   ib_ae_rsp->q_id);\n\t\tqlge_queue_asic_error(qdev);\n\t\tbreak;\n\n\tdefault:\n\t\tnetif_err(qdev, drv, qdev->ndev, \"Unexpected event %d.\\n\",\n\t\t\t  ib_ae_rsp->event);\n\t\tqlge_queue_asic_error(qdev);\n\t\tbreak;\n\t}\n}\n\nstatic int qlge_clean_outbound_rx_ring(struct rx_ring *rx_ring)\n{\n\tstruct qlge_adapter *qdev = rx_ring->qdev;\n\tu32 prod = qlge_read_sh_reg(rx_ring->prod_idx_sh_reg);\n\tstruct qlge_ob_mac_iocb_rsp *net_rsp = NULL;\n\tint count = 0;\n\n\tstruct tx_ring *tx_ring;\n\t \n\twhile (prod != rx_ring->cnsmr_idx) {\n\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"cq_id = %d, prod = %d, cnsmr = %d\\n\",\n\t\t\t     rx_ring->cq_id, prod, rx_ring->cnsmr_idx);\n\n\t\tnet_rsp = (struct qlge_ob_mac_iocb_rsp *)rx_ring->curr_entry;\n\t\trmb();\n\t\tswitch (net_rsp->opcode) {\n\t\tcase OPCODE_OB_MAC_TSO_IOCB:\n\t\tcase OPCODE_OB_MAC_IOCB:\n\t\t\tqlge_process_mac_tx_intr(qdev, net_rsp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"Hit default case, not handled! dropping the packet, opcode = %x.\\n\",\n\t\t\t\t     net_rsp->opcode);\n\t\t}\n\t\tcount++;\n\t\tqlge_update_cq(rx_ring);\n\t\tprod = qlge_read_sh_reg(rx_ring->prod_idx_sh_reg);\n\t}\n\tif (!net_rsp)\n\t\treturn 0;\n\tqlge_write_cq_idx(rx_ring);\n\ttx_ring = &qdev->tx_ring[net_rsp->txq_idx];\n\tif (__netif_subqueue_stopped(qdev->ndev, tx_ring->wq_id)) {\n\t\tif ((atomic_read(&tx_ring->tx_count) > (tx_ring->wq_len / 4)))\n\t\t\t \n\t\t\tnetif_wake_subqueue(qdev->ndev, tx_ring->wq_id);\n\t}\n\n\treturn count;\n}\n\nstatic int qlge_clean_inbound_rx_ring(struct rx_ring *rx_ring, int budget)\n{\n\tstruct qlge_adapter *qdev = rx_ring->qdev;\n\tu32 prod = qlge_read_sh_reg(rx_ring->prod_idx_sh_reg);\n\tstruct qlge_net_rsp_iocb *net_rsp;\n\tint count = 0;\n\n\t \n\twhile (prod != rx_ring->cnsmr_idx) {\n\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"cq_id = %d, prod = %d, cnsmr = %d\\n\",\n\t\t\t     rx_ring->cq_id, prod, rx_ring->cnsmr_idx);\n\n\t\tnet_rsp = rx_ring->curr_entry;\n\t\trmb();\n\t\tswitch (net_rsp->opcode) {\n\t\tcase OPCODE_IB_MAC_IOCB:\n\t\t\tqlge_process_mac_rx_intr(qdev, rx_ring,\n\t\t\t\t\t\t (struct qlge_ib_mac_iocb_rsp *)\n\t\t\t\t\t\t net_rsp);\n\t\t\tbreak;\n\n\t\tcase OPCODE_IB_AE_IOCB:\n\t\t\tqlge_process_chip_ae_intr(qdev, (struct qlge_ib_ae_iocb_rsp *)\n\t\t\t\t\t\t  net_rsp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"Hit default case, not handled! dropping the packet, opcode = %x.\\n\",\n\t\t\t\t     net_rsp->opcode);\n\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\t\tqlge_update_cq(rx_ring);\n\t\tprod = qlge_read_sh_reg(rx_ring->prod_idx_sh_reg);\n\t\tif (count == budget)\n\t\t\tbreak;\n\t}\n\tqlge_update_buffer_queues(rx_ring, GFP_ATOMIC, 0);\n\tqlge_write_cq_idx(rx_ring);\n\treturn count;\n}\n\nstatic int qlge_napi_poll_msix(struct napi_struct *napi, int budget)\n{\n\tstruct rx_ring *rx_ring = container_of(napi, struct rx_ring, napi);\n\tstruct qlge_adapter *qdev = rx_ring->qdev;\n\tstruct rx_ring *trx_ring;\n\tint i, work_done = 0;\n\tstruct intr_context *ctx = &qdev->intr_context[rx_ring->cq_id];\n\n\tnetif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,\n\t\t     \"Enter, NAPI POLL cq_id = %d.\\n\", rx_ring->cq_id);\n\n\t \n\tfor (i = qdev->rss_ring_count; i < qdev->rx_ring_count; i++) {\n\t\ttrx_ring = &qdev->rx_ring[i];\n\t\t \n\t\tif ((ctx->irq_mask & (1 << trx_ring->cq_id)) &&\n\t\t    (qlge_read_sh_reg(trx_ring->prod_idx_sh_reg) !=\n\t\t     trx_ring->cnsmr_idx)) {\n\t\t\tnetif_printk(qdev, intr, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"%s: Servicing TX completion ring %d.\\n\",\n\t\t\t\t     __func__, trx_ring->cq_id);\n\t\t\tqlge_clean_outbound_rx_ring(trx_ring);\n\t\t}\n\t}\n\n\t \n\tif (qlge_read_sh_reg(rx_ring->prod_idx_sh_reg) !=\n\t    rx_ring->cnsmr_idx) {\n\t\tnetif_printk(qdev, intr, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"%s: Servicing RX completion ring %d.\\n\",\n\t\t\t     __func__, rx_ring->cq_id);\n\t\twork_done = qlge_clean_inbound_rx_ring(rx_ring, budget);\n\t}\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tqlge_enable_completion_interrupt(qdev, rx_ring->irq);\n\t}\n\treturn work_done;\n}\n\nstatic void qlge_vlan_mode(struct net_device *ndev, netdev_features_t features)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\n\tif (features & NETIF_F_HW_VLAN_CTAG_RX) {\n\t\tqlge_write32(qdev, NIC_RCV_CFG, NIC_RCV_CFG_VLAN_MASK |\n\t\t\t     NIC_RCV_CFG_VLAN_MATCH_AND_NON);\n\t} else {\n\t\tqlge_write32(qdev, NIC_RCV_CFG, NIC_RCV_CFG_VLAN_MASK);\n\t}\n}\n\n \nstatic int qlge_update_hw_vlan_features(struct net_device *ndev,\n\t\t\t\t\tnetdev_features_t features)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\tbool need_restart = netif_running(ndev);\n\tint status = 0;\n\n\tif (need_restart) {\n\t\tstatus = qlge_adapter_down(qdev);\n\t\tif (status) {\n\t\t\tnetif_err(qdev, link, qdev->ndev,\n\t\t\t\t  \"Failed to bring down the adapter\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t \n\tndev->features = features;\n\n\tif (need_restart) {\n\t\tstatus = qlge_adapter_up(qdev);\n\t\tif (status) {\n\t\t\tnetif_err(qdev, link, qdev->ndev,\n\t\t\t\t  \"Failed to bring up the adapter\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic int qlge_set_features(struct net_device *ndev,\n\t\t\t     netdev_features_t features)\n{\n\tnetdev_features_t changed = ndev->features ^ features;\n\tint err;\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX) {\n\t\t \n\t\terr = qlge_update_hw_vlan_features(ndev, features);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tqlge_vlan_mode(ndev, features);\n\t}\n\n\treturn 0;\n}\n\nstatic int __qlge_vlan_rx_add_vid(struct qlge_adapter *qdev, u16 vid)\n{\n\tu32 enable_bit = MAC_ADDR_E;\n\tint err;\n\n\terr = qlge_set_mac_addr_reg(qdev, (u8 *)&enable_bit,\n\t\t\t\t    MAC_ADDR_TYPE_VLAN, vid);\n\tif (err)\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Failed to init vlan address.\\n\");\n\treturn err;\n}\n\nstatic int qlge_vlan_rx_add_vid(struct net_device *ndev, __be16 proto, u16 vid)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\tint status;\n\tint err;\n\n\tstatus = qlge_sem_spinlock(qdev, SEM_MAC_ADDR_MASK);\n\tif (status)\n\t\treturn status;\n\n\terr = __qlge_vlan_rx_add_vid(qdev, vid);\n\tset_bit(vid, qdev->active_vlans);\n\n\tqlge_sem_unlock(qdev, SEM_MAC_ADDR_MASK);\n\n\treturn err;\n}\n\nstatic int __qlge_vlan_rx_kill_vid(struct qlge_adapter *qdev, u16 vid)\n{\n\tu32 enable_bit = 0;\n\tint err;\n\n\terr = qlge_set_mac_addr_reg(qdev, (u8 *)&enable_bit,\n\t\t\t\t    MAC_ADDR_TYPE_VLAN, vid);\n\tif (err)\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Failed to clear vlan address.\\n\");\n\treturn err;\n}\n\nstatic int qlge_vlan_rx_kill_vid(struct net_device *ndev, __be16 proto, u16 vid)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\tint status;\n\tint err;\n\n\tstatus = qlge_sem_spinlock(qdev, SEM_MAC_ADDR_MASK);\n\tif (status)\n\t\treturn status;\n\n\terr = __qlge_vlan_rx_kill_vid(qdev, vid);\n\tclear_bit(vid, qdev->active_vlans);\n\n\tqlge_sem_unlock(qdev, SEM_MAC_ADDR_MASK);\n\n\treturn err;\n}\n\nstatic void qlge_restore_vlan(struct qlge_adapter *qdev)\n{\n\tint status;\n\tu16 vid;\n\n\tstatus = qlge_sem_spinlock(qdev, SEM_MAC_ADDR_MASK);\n\tif (status)\n\t\treturn;\n\n\tfor_each_set_bit(vid, qdev->active_vlans, VLAN_N_VID)\n\t\t__qlge_vlan_rx_add_vid(qdev, vid);\n\n\tqlge_sem_unlock(qdev, SEM_MAC_ADDR_MASK);\n}\n\n \nstatic irqreturn_t qlge_msix_rx_isr(int irq, void *dev_id)\n{\n\tstruct rx_ring *rx_ring = dev_id;\n\n\tnapi_schedule(&rx_ring->napi);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t qlge_isr(int irq, void *dev_id)\n{\n\tstruct rx_ring *rx_ring = dev_id;\n\tstruct qlge_adapter *qdev = rx_ring->qdev;\n\tstruct intr_context *intr_context = &qdev->intr_context[0];\n\tu32 var;\n\tint work_done = 0;\n\n\t \n\tif (!test_bit(QL_MSIX_ENABLED, &qdev->flags))\n\t\tqlge_disable_completion_interrupt(qdev, 0);\n\n\tvar = qlge_read32(qdev, STS);\n\n\t \n\tif (var & STS_FE) {\n\t\tqlge_disable_completion_interrupt(qdev, 0);\n\t\tqlge_queue_asic_error(qdev);\n\t\tnetdev_err(qdev->ndev, \"Got fatal error, STS = %x.\\n\", var);\n\t\tvar = qlge_read32(qdev, ERR_STS);\n\t\tnetdev_err(qdev->ndev, \"Resetting chip. Error Status Register = 0x%x\\n\", var);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif ((var & STS_PI) &&\n\t    (qlge_read32(qdev, INTR_MASK) & INTR_MASK_PI)) {\n\t\t \n\t\tnetif_err(qdev, intr, qdev->ndev,\n\t\t\t  \"Got MPI processor interrupt.\\n\");\n\t\tqlge_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16));\n\t\tqueue_delayed_work_on(smp_processor_id(),\n\t\t\t\t      qdev->workqueue, &qdev->mpi_work, 0);\n\t\twork_done++;\n\t}\n\n\t \n\tvar = qlge_read32(qdev, ISR1);\n\tif (var & intr_context->irq_mask) {\n\t\tnetif_info(qdev, intr, qdev->ndev,\n\t\t\t   \"Waking handler for rx_ring[0].\\n\");\n\t\tnapi_schedule(&rx_ring->napi);\n\t\twork_done++;\n\t} else {\n\t\t \n\t\tqlge_enable_completion_interrupt(qdev, 0);\n\t}\n\n\treturn work_done ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int qlge_tso(struct sk_buff *skb, struct qlge_ob_mac_tso_iocb_req *mac_iocb_ptr)\n{\n\tif (skb_is_gso(skb)) {\n\t\tint err;\n\t\t__be16 l3_proto = vlan_get_protocol(skb);\n\n\t\terr = skb_cow_head(skb, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmac_iocb_ptr->opcode = OPCODE_OB_MAC_TSO_IOCB;\n\t\tmac_iocb_ptr->flags3 |= OB_MAC_TSO_IOCB_IC;\n\t\tmac_iocb_ptr->frame_len = cpu_to_le32((u32)skb->len);\n\t\tmac_iocb_ptr->total_hdrs_len =\n\t\t\tcpu_to_le16(skb_tcp_all_headers(skb));\n\t\tmac_iocb_ptr->net_trans_offset =\n\t\t\tcpu_to_le16(skb_network_offset(skb) |\n\t\t\t\t    skb_transport_offset(skb)\n\t\t\t\t    << OB_MAC_TRANSPORT_HDR_SHIFT);\n\t\tmac_iocb_ptr->mss = cpu_to_le16(skb_shinfo(skb)->gso_size);\n\t\tmac_iocb_ptr->flags2 |= OB_MAC_TSO_IOCB_LSO;\n\t\tif (likely(l3_proto == htons(ETH_P_IP))) {\n\t\t\tstruct iphdr *iph = ip_hdr(skb);\n\n\t\t\tiph->check = 0;\n\t\t\tmac_iocb_ptr->flags1 |= OB_MAC_TSO_IOCB_IP4;\n\t\t\ttcp_hdr(skb)->check = ~csum_tcpudp_magic(iph->saddr,\n\t\t\t\t\t\t\t\t iph->daddr, 0,\n\t\t\t\t\t\t\t\t IPPROTO_TCP,\n\t\t\t\t\t\t\t\t 0);\n\t\t} else if (l3_proto == htons(ETH_P_IPV6)) {\n\t\t\tmac_iocb_ptr->flags1 |= OB_MAC_TSO_IOCB_IP6;\n\t\t\ttcp_hdr(skb)->check =\n\t\t\t\t~csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\n\t\t\t\t\t\t &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t\t 0, IPPROTO_TCP, 0);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void qlge_hw_csum_setup(struct sk_buff *skb,\n\t\t\t       struct qlge_ob_mac_tso_iocb_req *mac_iocb_ptr)\n{\n\tint len;\n\tstruct iphdr *iph = ip_hdr(skb);\n\t__sum16 *check;\n\n\tmac_iocb_ptr->opcode = OPCODE_OB_MAC_TSO_IOCB;\n\tmac_iocb_ptr->frame_len = cpu_to_le32((u32)skb->len);\n\tmac_iocb_ptr->net_trans_offset =\n\t\tcpu_to_le16(skb_network_offset(skb) |\n\t\t\t    skb_transport_offset(skb) << OB_MAC_TRANSPORT_HDR_SHIFT);\n\n\tmac_iocb_ptr->flags1 |= OB_MAC_TSO_IOCB_IP4;\n\tlen = (ntohs(iph->tot_len) - (iph->ihl << 2));\n\tif (likely(iph->protocol == IPPROTO_TCP)) {\n\t\tcheck = &(tcp_hdr(skb)->check);\n\t\tmac_iocb_ptr->flags2 |= OB_MAC_TSO_IOCB_TC;\n\t\tmac_iocb_ptr->total_hdrs_len =\n\t\t\tcpu_to_le16(skb_transport_offset(skb) +\n\t\t\t\t    (tcp_hdr(skb)->doff << 2));\n\t} else {\n\t\tcheck = &(udp_hdr(skb)->check);\n\t\tmac_iocb_ptr->flags2 |= OB_MAC_TSO_IOCB_UC;\n\t\tmac_iocb_ptr->total_hdrs_len =\n\t\t\tcpu_to_le16(skb_transport_offset(skb) +\n\t\t\t\t    sizeof(struct udphdr));\n\t}\n\t*check = ~csum_tcpudp_magic(iph->saddr,\n\t\t\t\t    iph->daddr, len, iph->protocol, 0);\n}\n\nstatic netdev_tx_t qlge_send(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\tstruct qlge_ob_mac_iocb_req *mac_iocb_ptr;\n\tstruct tx_ring_desc *tx_ring_desc;\n\tint tso;\n\tstruct tx_ring *tx_ring;\n\tu32 tx_ring_idx = (u32)skb->queue_mapping;\n\n\ttx_ring = &qdev->tx_ring[tx_ring_idx];\n\n\tif (skb_padto(skb, ETH_ZLEN))\n\t\treturn NETDEV_TX_OK;\n\n\tif (unlikely(atomic_read(&tx_ring->tx_count) < 2)) {\n\t\tnetif_info(qdev, tx_queued, qdev->ndev,\n\t\t\t   \"%s: BUG! shutting down tx queue %d due to lack of resources.\\n\",\n\t\t\t   __func__, tx_ring_idx);\n\t\tnetif_stop_subqueue(ndev, tx_ring->wq_id);\n\t\ttx_ring->tx_errors++;\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\ttx_ring_desc = &tx_ring->q[tx_ring->prod_idx];\n\tmac_iocb_ptr = tx_ring_desc->queue_entry;\n\tmemset((void *)mac_iocb_ptr, 0, sizeof(*mac_iocb_ptr));\n\n\tmac_iocb_ptr->opcode = OPCODE_OB_MAC_IOCB;\n\tmac_iocb_ptr->tid = tx_ring_desc->index;\n\t \n\tmac_iocb_ptr->txq_idx = tx_ring_idx;\n\ttx_ring_desc->skb = skb;\n\n\tmac_iocb_ptr->frame_len = cpu_to_le16((u16)skb->len);\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tnetif_printk(qdev, tx_queued, KERN_DEBUG, qdev->ndev,\n\t\t\t     \"Adding a vlan tag %d.\\n\", skb_vlan_tag_get(skb));\n\t\tmac_iocb_ptr->flags3 |= OB_MAC_IOCB_V;\n\t\tmac_iocb_ptr->vlan_tci = cpu_to_le16(skb_vlan_tag_get(skb));\n\t}\n\ttso = qlge_tso(skb, (struct qlge_ob_mac_tso_iocb_req *)mac_iocb_ptr);\n\tif (tso < 0) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t} else if (unlikely(!tso) && (skb->ip_summed == CHECKSUM_PARTIAL)) {\n\t\tqlge_hw_csum_setup(skb,\n\t\t\t\t   (struct qlge_ob_mac_tso_iocb_req *)mac_iocb_ptr);\n\t}\n\tif (qlge_map_send(qdev, mac_iocb_ptr, skb, tx_ring_desc) !=\n\t    NETDEV_TX_OK) {\n\t\tnetif_err(qdev, tx_queued, qdev->ndev,\n\t\t\t  \"Could not map the segments.\\n\");\n\t\ttx_ring->tx_errors++;\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\ttx_ring->prod_idx++;\n\tif (tx_ring->prod_idx == tx_ring->wq_len)\n\t\ttx_ring->prod_idx = 0;\n\twmb();\n\n\tqlge_write_db_reg_relaxed(tx_ring->prod_idx, tx_ring->prod_idx_db_reg);\n\tnetif_printk(qdev, tx_queued, KERN_DEBUG, qdev->ndev,\n\t\t     \"tx queued, slot %d, len %d\\n\",\n\t\t     tx_ring->prod_idx, skb->len);\n\n\tatomic_dec(&tx_ring->tx_count);\n\n\tif (unlikely(atomic_read(&tx_ring->tx_count) < 2)) {\n\t\tnetif_stop_subqueue(ndev, tx_ring->wq_id);\n\t\tif ((atomic_read(&tx_ring->tx_count) > (tx_ring->wq_len / 4)))\n\t\t\t \n\t\t\tnetif_wake_subqueue(qdev->ndev, tx_ring->wq_id);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\nstatic void qlge_free_shadow_space(struct qlge_adapter *qdev)\n{\n\tif (qdev->rx_ring_shadow_reg_area) {\n\t\tdma_free_coherent(&qdev->pdev->dev,\n\t\t\t\t  PAGE_SIZE,\n\t\t\t\t  qdev->rx_ring_shadow_reg_area,\n\t\t\t\t  qdev->rx_ring_shadow_reg_dma);\n\t\tqdev->rx_ring_shadow_reg_area = NULL;\n\t}\n\tif (qdev->tx_ring_shadow_reg_area) {\n\t\tdma_free_coherent(&qdev->pdev->dev,\n\t\t\t\t  PAGE_SIZE,\n\t\t\t\t  qdev->tx_ring_shadow_reg_area,\n\t\t\t\t  qdev->tx_ring_shadow_reg_dma);\n\t\tqdev->tx_ring_shadow_reg_area = NULL;\n\t}\n}\n\nstatic int qlge_alloc_shadow_space(struct qlge_adapter *qdev)\n{\n\tqdev->rx_ring_shadow_reg_area =\n\t\tdma_alloc_coherent(&qdev->pdev->dev, PAGE_SIZE,\n\t\t\t\t   &qdev->rx_ring_shadow_reg_dma, GFP_ATOMIC);\n\tif (!qdev->rx_ring_shadow_reg_area) {\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Allocation of RX shadow space failed.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tqdev->tx_ring_shadow_reg_area =\n\t\tdma_alloc_coherent(&qdev->pdev->dev, PAGE_SIZE,\n\t\t\t\t   &qdev->tx_ring_shadow_reg_dma, GFP_ATOMIC);\n\tif (!qdev->tx_ring_shadow_reg_area) {\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Allocation of TX shadow space failed.\\n\");\n\t\tgoto err_wqp_sh_area;\n\t}\n\treturn 0;\n\nerr_wqp_sh_area:\n\tdma_free_coherent(&qdev->pdev->dev,\n\t\t\t  PAGE_SIZE,\n\t\t\t  qdev->rx_ring_shadow_reg_area,\n\t\t\t  qdev->rx_ring_shadow_reg_dma);\n\treturn -ENOMEM;\n}\n\nstatic void qlge_init_tx_ring(struct qlge_adapter *qdev, struct tx_ring *tx_ring)\n{\n\tstruct tx_ring_desc *tx_ring_desc;\n\tint i;\n\tstruct qlge_ob_mac_iocb_req *mac_iocb_ptr;\n\n\tmac_iocb_ptr = tx_ring->wq_base;\n\ttx_ring_desc = tx_ring->q;\n\tfor (i = 0; i < tx_ring->wq_len; i++) {\n\t\ttx_ring_desc->index = i;\n\t\ttx_ring_desc->skb = NULL;\n\t\ttx_ring_desc->queue_entry = mac_iocb_ptr;\n\t\tmac_iocb_ptr++;\n\t\ttx_ring_desc++;\n\t}\n\tatomic_set(&tx_ring->tx_count, tx_ring->wq_len);\n}\n\nstatic void qlge_free_tx_resources(struct qlge_adapter *qdev,\n\t\t\t\t   struct tx_ring *tx_ring)\n{\n\tif (tx_ring->wq_base) {\n\t\tdma_free_coherent(&qdev->pdev->dev, tx_ring->wq_size,\n\t\t\t\t  tx_ring->wq_base, tx_ring->wq_base_dma);\n\t\ttx_ring->wq_base = NULL;\n\t}\n\tkfree(tx_ring->q);\n\ttx_ring->q = NULL;\n}\n\nstatic int qlge_alloc_tx_resources(struct qlge_adapter *qdev,\n\t\t\t\t   struct tx_ring *tx_ring)\n{\n\ttx_ring->wq_base =\n\t\tdma_alloc_coherent(&qdev->pdev->dev, tx_ring->wq_size,\n\t\t\t\t   &tx_ring->wq_base_dma, GFP_ATOMIC);\n\n\tif (!tx_ring->wq_base ||\n\t    tx_ring->wq_base_dma & WQ_ADDR_ALIGN)\n\t\tgoto pci_alloc_err;\n\n\ttx_ring->q =\n\t\tkmalloc_array(tx_ring->wq_len, sizeof(struct tx_ring_desc),\n\t\t\t      GFP_KERNEL);\n\tif (!tx_ring->q)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdma_free_coherent(&qdev->pdev->dev, tx_ring->wq_size,\n\t\t\t  tx_ring->wq_base, tx_ring->wq_base_dma);\n\ttx_ring->wq_base = NULL;\npci_alloc_err:\n\tnetif_err(qdev, ifup, qdev->ndev, \"tx_ring alloc failed.\\n\");\n\treturn -ENOMEM;\n}\n\nstatic void qlge_free_lbq_buffers(struct qlge_adapter *qdev, struct rx_ring *rx_ring)\n{\n\tstruct qlge_bq *lbq = &rx_ring->lbq;\n\tunsigned int last_offset;\n\n\tlast_offset = qlge_lbq_block_size(qdev) - qdev->lbq_buf_size;\n\twhile (lbq->next_to_clean != lbq->next_to_use) {\n\t\tstruct qlge_bq_desc *lbq_desc =\n\t\t\t&lbq->queue[lbq->next_to_clean];\n\n\t\tif (lbq_desc->p.pg_chunk.offset == last_offset)\n\t\t\tdma_unmap_page(&qdev->pdev->dev, lbq_desc->dma_addr,\n\t\t\t\t       qlge_lbq_block_size(qdev),\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\tput_page(lbq_desc->p.pg_chunk.page);\n\n\t\tlbq->next_to_clean = QLGE_BQ_WRAP(lbq->next_to_clean + 1);\n\t}\n\n\tif (rx_ring->master_chunk.page) {\n\t\tdma_unmap_page(&qdev->pdev->dev, rx_ring->chunk_dma_addr,\n\t\t\t       qlge_lbq_block_size(qdev), DMA_FROM_DEVICE);\n\t\tput_page(rx_ring->master_chunk.page);\n\t\trx_ring->master_chunk.page = NULL;\n\t}\n}\n\nstatic void qlge_free_sbq_buffers(struct qlge_adapter *qdev, struct rx_ring *rx_ring)\n{\n\tint i;\n\n\tfor (i = 0; i < QLGE_BQ_LEN; i++) {\n\t\tstruct qlge_bq_desc *sbq_desc = &rx_ring->sbq.queue[i];\n\n\t\tif (!sbq_desc) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"sbq_desc %d is NULL.\\n\", i);\n\t\t\treturn;\n\t\t}\n\t\tif (sbq_desc->p.skb) {\n\t\t\tdma_unmap_single(&qdev->pdev->dev, sbq_desc->dma_addr,\n\t\t\t\t\t SMALL_BUF_MAP_SIZE,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(sbq_desc->p.skb);\n\t\t\tsbq_desc->p.skb = NULL;\n\t\t}\n\t}\n}\n\n \nstatic void qlge_free_rx_buffers(struct qlge_adapter *qdev)\n{\n\tint i;\n\n\tfor (i = 0; i < qdev->rx_ring_count; i++) {\n\t\tstruct rx_ring *rx_ring = &qdev->rx_ring[i];\n\n\t\tif (rx_ring->lbq.queue)\n\t\t\tqlge_free_lbq_buffers(qdev, rx_ring);\n\t\tif (rx_ring->sbq.queue)\n\t\t\tqlge_free_sbq_buffers(qdev, rx_ring);\n\t}\n}\n\nstatic void qlge_alloc_rx_buffers(struct qlge_adapter *qdev)\n{\n\tint i;\n\n\tfor (i = 0; i < qdev->rss_ring_count; i++)\n\t\tqlge_update_buffer_queues(&qdev->rx_ring[i], GFP_KERNEL,\n\t\t\t\t\t  HZ / 2);\n}\n\nstatic int qlge_init_bq(struct qlge_bq *bq)\n{\n\tstruct rx_ring *rx_ring = QLGE_BQ_CONTAINER(bq);\n\tstruct qlge_adapter *qdev = rx_ring->qdev;\n\tstruct qlge_bq_desc *bq_desc;\n\t__le64 *buf_ptr;\n\tint i;\n\n\tbq->base = dma_alloc_coherent(&qdev->pdev->dev, QLGE_BQ_SIZE,\n\t\t\t\t      &bq->base_dma, GFP_ATOMIC);\n\tif (!bq->base)\n\t\treturn -ENOMEM;\n\n\tbq->queue = kmalloc_array(QLGE_BQ_LEN, sizeof(struct qlge_bq_desc),\n\t\t\t\t  GFP_KERNEL);\n\tif (!bq->queue)\n\t\treturn -ENOMEM;\n\n\tbuf_ptr = bq->base;\n\tbq_desc = &bq->queue[0];\n\tfor (i = 0; i < QLGE_BQ_LEN; i++, buf_ptr++, bq_desc++) {\n\t\tbq_desc->p.skb = NULL;\n\t\tbq_desc->index = i;\n\t\tbq_desc->buf_ptr = buf_ptr;\n\t}\n\n\treturn 0;\n}\n\nstatic void qlge_free_rx_resources(struct qlge_adapter *qdev,\n\t\t\t\t   struct rx_ring *rx_ring)\n{\n\t \n\tif (rx_ring->sbq.base) {\n\t\tdma_free_coherent(&qdev->pdev->dev, QLGE_BQ_SIZE,\n\t\t\t\t  rx_ring->sbq.base, rx_ring->sbq.base_dma);\n\t\trx_ring->sbq.base = NULL;\n\t}\n\n\t \n\tkfree(rx_ring->sbq.queue);\n\trx_ring->sbq.queue = NULL;\n\n\t \n\tif (rx_ring->lbq.base) {\n\t\tdma_free_coherent(&qdev->pdev->dev, QLGE_BQ_SIZE,\n\t\t\t\t  rx_ring->lbq.base, rx_ring->lbq.base_dma);\n\t\trx_ring->lbq.base = NULL;\n\t}\n\n\t \n\tkfree(rx_ring->lbq.queue);\n\trx_ring->lbq.queue = NULL;\n\n\t \n\tif (rx_ring->cq_base) {\n\t\tdma_free_coherent(&qdev->pdev->dev,\n\t\t\t\t  rx_ring->cq_size,\n\t\t\t\t  rx_ring->cq_base, rx_ring->cq_base_dma);\n\t\trx_ring->cq_base = NULL;\n\t}\n}\n\n \nstatic int qlge_alloc_rx_resources(struct qlge_adapter *qdev,\n\t\t\t\t   struct rx_ring *rx_ring)\n{\n\t \n\trx_ring->cq_base =\n\t\tdma_alloc_coherent(&qdev->pdev->dev, rx_ring->cq_size,\n\t\t\t\t   &rx_ring->cq_base_dma, GFP_ATOMIC);\n\n\tif (!rx_ring->cq_base) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"rx_ring alloc failed.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (rx_ring->cq_id < qdev->rss_ring_count &&\n\t    (qlge_init_bq(&rx_ring->sbq) || qlge_init_bq(&rx_ring->lbq))) {\n\t\tqlge_free_rx_resources(qdev, rx_ring);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void qlge_tx_ring_clean(struct qlge_adapter *qdev)\n{\n\tstruct tx_ring *tx_ring;\n\tstruct tx_ring_desc *tx_ring_desc;\n\tint i, j;\n\n\t \n\tfor (j = 0; j < qdev->tx_ring_count; j++) {\n\t\ttx_ring = &qdev->tx_ring[j];\n\t\tfor (i = 0; i < tx_ring->wq_len; i++) {\n\t\t\ttx_ring_desc = &tx_ring->q[i];\n\t\t\tif (tx_ring_desc && tx_ring_desc->skb) {\n\t\t\t\tnetif_err(qdev, ifdown, qdev->ndev,\n\t\t\t\t\t  \"Freeing lost SKB %p, from queue %d, index %d.\\n\",\n\t\t\t\t\t  tx_ring_desc->skb, j,\n\t\t\t\t\t  tx_ring_desc->index);\n\t\t\t\tqlge_unmap_send(qdev, tx_ring_desc,\n\t\t\t\t\t\ttx_ring_desc->map_cnt);\n\t\t\t\tdev_kfree_skb(tx_ring_desc->skb);\n\t\t\t\ttx_ring_desc->skb = NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void qlge_free_mem_resources(struct qlge_adapter *qdev)\n{\n\tint i;\n\n\tfor (i = 0; i < qdev->tx_ring_count; i++)\n\t\tqlge_free_tx_resources(qdev, &qdev->tx_ring[i]);\n\tfor (i = 0; i < qdev->rx_ring_count; i++)\n\t\tqlge_free_rx_resources(qdev, &qdev->rx_ring[i]);\n\tqlge_free_shadow_space(qdev);\n}\n\nstatic int qlge_alloc_mem_resources(struct qlge_adapter *qdev)\n{\n\tint i;\n\n\t \n\tif (qlge_alloc_shadow_space(qdev))\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < qdev->rx_ring_count; i++) {\n\t\tif (qlge_alloc_rx_resources(qdev, &qdev->rx_ring[i]) != 0) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"RX resource allocation failed.\\n\");\n\t\t\tgoto err_mem;\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < qdev->tx_ring_count; i++) {\n\t\tif (qlge_alloc_tx_resources(qdev, &qdev->tx_ring[i]) != 0) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"TX resource allocation failed.\\n\");\n\t\t\tgoto err_mem;\n\t\t}\n\t}\n\treturn 0;\n\nerr_mem:\n\tqlge_free_mem_resources(qdev);\n\treturn -ENOMEM;\n}\n\n \nstatic int qlge_start_rx_ring(struct qlge_adapter *qdev, struct rx_ring *rx_ring)\n{\n\tstruct cqicb *cqicb = &rx_ring->cqicb;\n\tvoid *shadow_reg = qdev->rx_ring_shadow_reg_area +\n\t\t(rx_ring->cq_id * RX_RING_SHADOW_SPACE);\n\tu64 shadow_reg_dma = qdev->rx_ring_shadow_reg_dma +\n\t\t(rx_ring->cq_id * RX_RING_SHADOW_SPACE);\n\tvoid __iomem *doorbell_area =\n\t\tqdev->doorbell_area + (DB_PAGE_SIZE * (128 + rx_ring->cq_id));\n\tint err = 0;\n\tu64 dma;\n\t__le64 *base_indirect_ptr;\n\tint page_entries;\n\n\t \n\trx_ring->prod_idx_sh_reg = shadow_reg;\n\trx_ring->prod_idx_sh_reg_dma = shadow_reg_dma;\n\t*rx_ring->prod_idx_sh_reg = 0;\n\tshadow_reg += sizeof(u64);\n\tshadow_reg_dma += sizeof(u64);\n\trx_ring->lbq.base_indirect = shadow_reg;\n\trx_ring->lbq.base_indirect_dma = shadow_reg_dma;\n\tshadow_reg += (sizeof(u64) * MAX_DB_PAGES_PER_BQ(QLGE_BQ_LEN));\n\tshadow_reg_dma += (sizeof(u64) * MAX_DB_PAGES_PER_BQ(QLGE_BQ_LEN));\n\trx_ring->sbq.base_indirect = shadow_reg;\n\trx_ring->sbq.base_indirect_dma = shadow_reg_dma;\n\n\t \n\trx_ring->cnsmr_idx_db_reg = (u32 __iomem *)doorbell_area;\n\trx_ring->cnsmr_idx = 0;\n\trx_ring->curr_entry = rx_ring->cq_base;\n\n\t \n\trx_ring->valid_db_reg = doorbell_area + 0x04;\n\n\t \n\trx_ring->lbq.prod_idx_db_reg = (u32 __iomem *)(doorbell_area + 0x18);\n\n\t \n\trx_ring->sbq.prod_idx_db_reg = (u32 __iomem *)(doorbell_area + 0x1c);\n\n\tmemset((void *)cqicb, 0, sizeof(struct cqicb));\n\tcqicb->msix_vect = rx_ring->irq;\n\n\tcqicb->len = cpu_to_le16(QLGE_FIT16(rx_ring->cq_len) | LEN_V |\n\t\t\t\t LEN_CPP_CONT);\n\n\tcqicb->addr = cpu_to_le64(rx_ring->cq_base_dma);\n\n\tcqicb->prod_idx_addr = cpu_to_le64(rx_ring->prod_idx_sh_reg_dma);\n\n\t \n\tcqicb->flags = FLAGS_LC |\t \n\t\tFLAGS_LV |\t\t \n\t\tFLAGS_LI;\t\t \n\tif (rx_ring->cq_id < qdev->rss_ring_count) {\n\t\tcqicb->flags |= FLAGS_LL;\t \n\t\tdma = (u64)rx_ring->lbq.base_dma;\n\t\tbase_indirect_ptr = rx_ring->lbq.base_indirect;\n\n\t\tfor (page_entries = 0;\n\t\t     page_entries < MAX_DB_PAGES_PER_BQ(QLGE_BQ_LEN);\n\t\t     page_entries++) {\n\t\t\tbase_indirect_ptr[page_entries] = cpu_to_le64(dma);\n\t\t\tdma += DB_PAGE_SIZE;\n\t\t}\n\t\tcqicb->lbq_addr = cpu_to_le64(rx_ring->lbq.base_indirect_dma);\n\t\tcqicb->lbq_buf_size =\n\t\t\tcpu_to_le16(QLGE_FIT16(qdev->lbq_buf_size));\n\t\tcqicb->lbq_len = cpu_to_le16(QLGE_FIT16(QLGE_BQ_LEN));\n\t\trx_ring->lbq.next_to_use = 0;\n\t\trx_ring->lbq.next_to_clean = 0;\n\n\t\tcqicb->flags |= FLAGS_LS;\t \n\t\tdma = (u64)rx_ring->sbq.base_dma;\n\t\tbase_indirect_ptr = rx_ring->sbq.base_indirect;\n\n\t\tfor (page_entries = 0;\n\t\t     page_entries < MAX_DB_PAGES_PER_BQ(QLGE_BQ_LEN);\n\t\t     page_entries++) {\n\t\t\tbase_indirect_ptr[page_entries] = cpu_to_le64(dma);\n\t\t\tdma += DB_PAGE_SIZE;\n\t\t}\n\t\tcqicb->sbq_addr =\n\t\t\tcpu_to_le64(rx_ring->sbq.base_indirect_dma);\n\t\tcqicb->sbq_buf_size = cpu_to_le16(SMALL_BUFFER_SIZE);\n\t\tcqicb->sbq_len = cpu_to_le16(QLGE_FIT16(QLGE_BQ_LEN));\n\t\trx_ring->sbq.next_to_use = 0;\n\t\trx_ring->sbq.next_to_clean = 0;\n\t}\n\tif (rx_ring->cq_id < qdev->rss_ring_count) {\n\t\t \n\t\tnetif_napi_add(qdev->ndev, &rx_ring->napi,\n\t\t\t       qlge_napi_poll_msix);\n\t\tcqicb->irq_delay = cpu_to_le16(qdev->rx_coalesce_usecs);\n\t\tcqicb->pkt_delay = cpu_to_le16(qdev->rx_max_coalesced_frames);\n\t} else {\n\t\tcqicb->irq_delay = cpu_to_le16(qdev->tx_coalesce_usecs);\n\t\tcqicb->pkt_delay = cpu_to_le16(qdev->tx_max_coalesced_frames);\n\t}\n\terr = qlge_write_cfg(qdev, cqicb, sizeof(struct cqicb),\n\t\t\t     CFG_LCQ, rx_ring->cq_id);\n\tif (err) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Failed to load CQICB.\\n\");\n\t\treturn err;\n\t}\n\treturn err;\n}\n\nstatic int qlge_start_tx_ring(struct qlge_adapter *qdev, struct tx_ring *tx_ring)\n{\n\tstruct wqicb *wqicb = (struct wqicb *)tx_ring;\n\tvoid __iomem *doorbell_area =\n\t\tqdev->doorbell_area + (DB_PAGE_SIZE * tx_ring->wq_id);\n\tvoid *shadow_reg = qdev->tx_ring_shadow_reg_area +\n\t\t(tx_ring->wq_id * sizeof(u64));\n\tu64 shadow_reg_dma = qdev->tx_ring_shadow_reg_dma +\n\t\t(tx_ring->wq_id * sizeof(u64));\n\tint err = 0;\n\n\t \n\t \n\ttx_ring->prod_idx_db_reg = (u32 __iomem *)doorbell_area;\n\ttx_ring->prod_idx = 0;\n\t \n\ttx_ring->valid_db_reg = doorbell_area + 0x04;\n\n\t \n\ttx_ring->cnsmr_idx_sh_reg = shadow_reg;\n\ttx_ring->cnsmr_idx_sh_reg_dma = shadow_reg_dma;\n\n\twqicb->len = cpu_to_le16(tx_ring->wq_len | Q_LEN_V | Q_LEN_CPP_CONT);\n\twqicb->flags = cpu_to_le16(Q_FLAGS_LC |\n\t\t\t\t   Q_FLAGS_LB | Q_FLAGS_LI | Q_FLAGS_LO);\n\twqicb->cq_id_rss = cpu_to_le16(tx_ring->cq_id);\n\twqicb->rid = 0;\n\twqicb->addr = cpu_to_le64(tx_ring->wq_base_dma);\n\n\twqicb->cnsmr_idx_addr = cpu_to_le64(tx_ring->cnsmr_idx_sh_reg_dma);\n\n\tqlge_init_tx_ring(qdev, tx_ring);\n\n\terr = qlge_write_cfg(qdev, wqicb, sizeof(*wqicb), CFG_LRQ,\n\t\t\t     (u16)tx_ring->wq_id);\n\tif (err) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Failed to load tx_ring.\\n\");\n\t\treturn err;\n\t}\n\treturn err;\n}\n\nstatic void qlge_disable_msix(struct qlge_adapter *qdev)\n{\n\tif (test_bit(QL_MSIX_ENABLED, &qdev->flags)) {\n\t\tpci_disable_msix(qdev->pdev);\n\t\tclear_bit(QL_MSIX_ENABLED, &qdev->flags);\n\t\tkfree(qdev->msi_x_entry);\n\t\tqdev->msi_x_entry = NULL;\n\t} else if (test_bit(QL_MSI_ENABLED, &qdev->flags)) {\n\t\tpci_disable_msi(qdev->pdev);\n\t\tclear_bit(QL_MSI_ENABLED, &qdev->flags);\n\t}\n}\n\n \nstatic void qlge_enable_msix(struct qlge_adapter *qdev)\n{\n\tint i, err;\n\n\t \n\tif (qlge_irq_type == MSIX_IRQ) {\n\t\t \n\t\tqdev->msi_x_entry = kcalloc(qdev->intr_count,\n\t\t\t\t\t    sizeof(struct msix_entry),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!qdev->msi_x_entry) {\n\t\t\tqlge_irq_type = MSI_IRQ;\n\t\t\tgoto msi;\n\t\t}\n\n\t\tfor (i = 0; i < qdev->intr_count; i++)\n\t\t\tqdev->msi_x_entry[i].entry = i;\n\n\t\terr = pci_enable_msix_range(qdev->pdev, qdev->msi_x_entry,\n\t\t\t\t\t    1, qdev->intr_count);\n\t\tif (err < 0) {\n\t\t\tkfree(qdev->msi_x_entry);\n\t\t\tqdev->msi_x_entry = NULL;\n\t\t\tnetif_warn(qdev, ifup, qdev->ndev,\n\t\t\t\t   \"MSI-X Enable failed, trying MSI.\\n\");\n\t\t\tqlge_irq_type = MSI_IRQ;\n\t\t} else {\n\t\t\tqdev->intr_count = err;\n\t\t\tset_bit(QL_MSIX_ENABLED, &qdev->flags);\n\t\t\tnetif_info(qdev, ifup, qdev->ndev,\n\t\t\t\t   \"MSI-X Enabled, got %d vectors.\\n\",\n\t\t\t\t   qdev->intr_count);\n\t\t\treturn;\n\t\t}\n\t}\nmsi:\n\tqdev->intr_count = 1;\n\tif (qlge_irq_type == MSI_IRQ) {\n\t\tif (pci_alloc_irq_vectors(qdev->pdev, 1, 1, PCI_IRQ_MSI) >= 0) {\n\t\t\tset_bit(QL_MSI_ENABLED, &qdev->flags);\n\t\t\tnetif_info(qdev, ifup, qdev->ndev,\n\t\t\t\t   \"Running with MSI interrupts.\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tqlge_irq_type = LEG_IRQ;\n\tset_bit(QL_LEGACY_ENABLED, &qdev->flags);\n\tnetif_printk(qdev, ifup, KERN_DEBUG, qdev->ndev,\n\t\t     \"Running with legacy interrupts.\\n\");\n}\n\n \nstatic void qlge_set_tx_vect(struct qlge_adapter *qdev)\n{\n\tint i, j, vect;\n\tu32 tx_rings_per_vector = qdev->tx_ring_count / qdev->intr_count;\n\n\tif (likely(test_bit(QL_MSIX_ENABLED, &qdev->flags))) {\n\t\t \n\t\tfor (vect = 0, j = 0, i = qdev->rss_ring_count;\n\t\t     i < qdev->rx_ring_count; i++) {\n\t\t\tif (j == tx_rings_per_vector) {\n\t\t\t\tvect++;\n\t\t\t\tj = 0;\n\t\t\t}\n\t\t\tqdev->rx_ring[i].irq = vect;\n\t\t\tj++;\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < qdev->rx_ring_count; i++)\n\t\t\tqdev->rx_ring[i].irq = 0;\n\t}\n}\n\n \nstatic void qlge_set_irq_mask(struct qlge_adapter *qdev, struct intr_context *ctx)\n{\n\tint j, vect = ctx->intr;\n\tu32 tx_rings_per_vector = qdev->tx_ring_count / qdev->intr_count;\n\n\tif (likely(test_bit(QL_MSIX_ENABLED, &qdev->flags))) {\n\t\t \n\t\tctx->irq_mask = (1 << qdev->rx_ring[vect].cq_id);\n\t\t \n\t\tfor (j = 0; j < tx_rings_per_vector; j++) {\n\t\t\tctx->irq_mask |=\n\t\t\t\t(1 << qdev->rx_ring[qdev->rss_ring_count +\n\t\t\t\t (vect * tx_rings_per_vector) + j].cq_id);\n\t\t}\n\t} else {\n\t\t \n\t\tfor (j = 0; j < qdev->rx_ring_count; j++)\n\t\t\tctx->irq_mask |= (1 << qdev->rx_ring[j].cq_id);\n\t}\n}\n\n \nstatic void qlge_resolve_queues_to_irqs(struct qlge_adapter *qdev)\n{\n\tint i = 0;\n\tstruct intr_context *intr_context = &qdev->intr_context[0];\n\n\tif (likely(test_bit(QL_MSIX_ENABLED, &qdev->flags))) {\n\t\t \n\t\tfor (i = 0; i < qdev->intr_count; i++, intr_context++) {\n\t\t\tqdev->rx_ring[i].irq = i;\n\t\t\tintr_context->intr = i;\n\t\t\tintr_context->qdev = qdev;\n\t\t\t \n\t\t\tqlge_set_irq_mask(qdev, intr_context);\n\t\t\t \n\t\t\tintr_context->intr_en_mask =\n\t\t\t\tINTR_EN_TYPE_MASK | INTR_EN_INTR_MASK |\n\t\t\t\tINTR_EN_TYPE_ENABLE | INTR_EN_IHD_MASK | INTR_EN_IHD\n\t\t\t\t| i;\n\t\t\tintr_context->intr_dis_mask =\n\t\t\t\tINTR_EN_TYPE_MASK | INTR_EN_INTR_MASK |\n\t\t\t\tINTR_EN_TYPE_DISABLE | INTR_EN_IHD_MASK |\n\t\t\t\tINTR_EN_IHD | i;\n\t\t\tintr_context->intr_read_mask =\n\t\t\t\tINTR_EN_TYPE_MASK | INTR_EN_INTR_MASK |\n\t\t\t\tINTR_EN_TYPE_READ | INTR_EN_IHD_MASK | INTR_EN_IHD |\n\t\t\t\ti;\n\t\t\tif (i == 0) {\n\t\t\t\t \n\t\t\t\tintr_context->handler = qlge_isr;\n\t\t\t\tsprintf(intr_context->name, \"%s-rx-%d\",\n\t\t\t\t\tqdev->ndev->name, i);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tintr_context->handler = qlge_msix_rx_isr;\n\t\t\t\tsprintf(intr_context->name, \"%s-rx-%d\",\n\t\t\t\t\tqdev->ndev->name, i);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tintr_context->intr = 0;\n\t\tintr_context->qdev = qdev;\n\t\t \n\t\tintr_context->intr_en_mask =\n\t\t\tINTR_EN_TYPE_MASK | INTR_EN_INTR_MASK | INTR_EN_TYPE_ENABLE;\n\t\tintr_context->intr_dis_mask =\n\t\t\tINTR_EN_TYPE_MASK | INTR_EN_INTR_MASK |\n\t\t\tINTR_EN_TYPE_DISABLE;\n\t\tif (test_bit(QL_LEGACY_ENABLED, &qdev->flags)) {\n\t\t\t \n\t\t\tintr_context->intr_en_mask |= INTR_EN_EI << 16 |\n\t\t\t\tINTR_EN_EI;\n\t\t\tintr_context->intr_dis_mask |= INTR_EN_EI << 16;\n\t\t}\n\t\tintr_context->intr_read_mask =\n\t\t\tINTR_EN_TYPE_MASK | INTR_EN_INTR_MASK | INTR_EN_TYPE_READ;\n\t\t \n\t\tintr_context->handler = qlge_isr;\n\t\tsprintf(intr_context->name, \"%s-single_irq\", qdev->ndev->name);\n\t\t \n\t\tqlge_set_irq_mask(qdev, intr_context);\n\t}\n\t \n\tqlge_set_tx_vect(qdev);\n}\n\nstatic void qlge_free_irq(struct qlge_adapter *qdev)\n{\n\tint i;\n\tstruct intr_context *intr_context = &qdev->intr_context[0];\n\n\tfor (i = 0; i < qdev->intr_count; i++, intr_context++) {\n\t\tif (intr_context->hooked) {\n\t\t\tif (test_bit(QL_MSIX_ENABLED, &qdev->flags)) {\n\t\t\t\tfree_irq(qdev->msi_x_entry[i].vector,\n\t\t\t\t\t &qdev->rx_ring[i]);\n\t\t\t} else {\n\t\t\t\tfree_irq(qdev->pdev->irq, &qdev->rx_ring[0]);\n\t\t\t}\n\t\t}\n\t}\n\tqlge_disable_msix(qdev);\n}\n\nstatic int qlge_request_irq(struct qlge_adapter *qdev)\n{\n\tint i;\n\tint status = 0;\n\tstruct pci_dev *pdev = qdev->pdev;\n\tstruct intr_context *intr_context = &qdev->intr_context[0];\n\n\tqlge_resolve_queues_to_irqs(qdev);\n\n\tfor (i = 0; i < qdev->intr_count; i++, intr_context++) {\n\t\tif (test_bit(QL_MSIX_ENABLED, &qdev->flags)) {\n\t\t\tstatus = request_irq(qdev->msi_x_entry[i].vector,\n\t\t\t\t\t     intr_context->handler,\n\t\t\t\t\t     0,\n\t\t\t\t\t     intr_context->name,\n\t\t\t\t\t     &qdev->rx_ring[i]);\n\t\t\tif (status) {\n\t\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t\t  \"Failed request for MSIX interrupt %d.\\n\",\n\t\t\t\t\t  i);\n\t\t\t\tgoto err_irq;\n\t\t\t}\n\t\t} else {\n\t\t\tnetif_printk(qdev, ifup, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"trying msi or legacy interrupts.\\n\");\n\t\t\tnetif_printk(qdev, ifup, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"%s: irq = %d.\\n\", __func__, pdev->irq);\n\t\t\tnetif_printk(qdev, ifup, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"%s: context->name = %s.\\n\", __func__,\n\t\t\t\t     intr_context->name);\n\t\t\tnetif_printk(qdev, ifup, KERN_DEBUG, qdev->ndev,\n\t\t\t\t     \"%s: dev_id = 0x%p.\\n\", __func__,\n\t\t\t\t     &qdev->rx_ring[0]);\n\t\t\tstatus =\n\t\t\t\trequest_irq(pdev->irq, qlge_isr,\n\t\t\t\t\t    test_bit(QL_MSI_ENABLED, &qdev->flags)\n\t\t\t\t\t    ? 0\n\t\t\t\t\t    : IRQF_SHARED,\n\t\t\t\t\t    intr_context->name, &qdev->rx_ring[0]);\n\t\t\tif (status)\n\t\t\t\tgoto err_irq;\n\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"Hooked intr 0, queue type RX_Q, with name %s.\\n\",\n\t\t\t\t  intr_context->name);\n\t\t}\n\t\tintr_context->hooked = 1;\n\t}\n\treturn status;\nerr_irq:\n\tnetif_err(qdev, ifup, qdev->ndev, \"Failed to get the interrupts!!!\\n\");\n\tqlge_free_irq(qdev);\n\treturn status;\n}\n\nstatic int qlge_start_rss(struct qlge_adapter *qdev)\n{\n\tstatic const u8 init_hash_seed[] = {\n\t\t0x6d, 0x5a, 0x56, 0xda, 0x25, 0x5b, 0x0e, 0xc2,\n\t\t0x41, 0x67, 0x25, 0x3d, 0x43, 0xa3, 0x8f, 0xb0,\n\t\t0xd0, 0xca, 0x2b, 0xcb, 0xae, 0x7b, 0x30, 0xb4,\n\t\t0x77, 0xcb, 0x2d, 0xa3, 0x80, 0x30, 0xf2, 0x0c,\n\t\t0x6a, 0x42, 0xb7, 0x3b, 0xbe, 0xac, 0x01, 0xfa\n\t};\n\tstruct ricb *ricb = &qdev->ricb;\n\tint status = 0;\n\tint i;\n\tu8 *hash_id = (u8 *)ricb->hash_cq_id;\n\n\tmemset((void *)ricb, 0, sizeof(*ricb));\n\n\tricb->base_cq = RSS_L4K;\n\tricb->flags =\n\t\t(RSS_L6K | RSS_LI | RSS_LB | RSS_LM | RSS_RT4 | RSS_RT6);\n\tricb->mask = cpu_to_le16((u16)(0x3ff));\n\n\t \n\tfor (i = 0; i < 1024; i++)\n\t\thash_id[i] = (i & (qdev->rss_ring_count - 1));\n\n\tmemcpy((void *)&ricb->ipv6_hash_key[0], init_hash_seed, 40);\n\tmemcpy((void *)&ricb->ipv4_hash_key[0], init_hash_seed, 16);\n\n\tstatus = qlge_write_cfg(qdev, ricb, sizeof(*ricb), CFG_LR, 0);\n\tif (status) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Failed to load RICB.\\n\");\n\t\treturn status;\n\t}\n\treturn status;\n}\n\nstatic int qlge_clear_routing_entries(struct qlge_adapter *qdev)\n{\n\tint i, status = 0;\n\n\tstatus = qlge_sem_spinlock(qdev, SEM_RT_IDX_MASK);\n\tif (status)\n\t\treturn status;\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tstatus = qlge_set_routing_reg(qdev, i, 0, 0);\n\t\tif (status) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"Failed to init routing register for CAM packets.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tqlge_sem_unlock(qdev, SEM_RT_IDX_MASK);\n\treturn status;\n}\n\n \nstatic int qlge_route_initialize(struct qlge_adapter *qdev)\n{\n\tint status = 0;\n\n\t \n\tstatus = qlge_clear_routing_entries(qdev);\n\tif (status)\n\t\treturn status;\n\n\tstatus = qlge_sem_spinlock(qdev, SEM_RT_IDX_MASK);\n\tif (status)\n\t\treturn status;\n\n\tstatus = qlge_set_routing_reg(qdev, RT_IDX_IP_CSUM_ERR_SLOT,\n\t\t\t\t      RT_IDX_IP_CSUM_ERR, 1);\n\tif (status) {\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Failed to init routing register for IP CSUM error packets.\\n\");\n\t\tgoto exit;\n\t}\n\tstatus = qlge_set_routing_reg(qdev, RT_IDX_TCP_UDP_CSUM_ERR_SLOT,\n\t\t\t\t      RT_IDX_TU_CSUM_ERR, 1);\n\tif (status) {\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Failed to init routing register for TCP/UDP CSUM error packets.\\n\");\n\t\tgoto exit;\n\t}\n\tstatus = qlge_set_routing_reg(qdev, RT_IDX_BCAST_SLOT, RT_IDX_BCAST, 1);\n\tif (status) {\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Failed to init routing register for broadcast packets.\\n\");\n\t\tgoto exit;\n\t}\n\t \n\tif (qdev->rss_ring_count > 1) {\n\t\tstatus = qlge_set_routing_reg(qdev, RT_IDX_RSS_MATCH_SLOT,\n\t\t\t\t\t      RT_IDX_RSS_MATCH, 1);\n\t\tif (status) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"Failed to init routing register for MATCH RSS packets.\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tstatus = qlge_set_routing_reg(qdev, RT_IDX_CAM_HIT_SLOT,\n\t\t\t\t      RT_IDX_CAM_HIT, 1);\n\tif (status)\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Failed to init routing register for CAM packets.\\n\");\nexit:\n\tqlge_sem_unlock(qdev, SEM_RT_IDX_MASK);\n\treturn status;\n}\n\nint qlge_cam_route_initialize(struct qlge_adapter *qdev)\n{\n\tint status, set;\n\n\t \n\tset = qlge_read32(qdev, STS);\n\tset &= qdev->port_link_up;\n\tstatus = qlge_set_mac_addr(qdev, set);\n\tif (status) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Failed to init mac address.\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = qlge_route_initialize(qdev);\n\tif (status)\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Failed to init routing table.\\n\");\n\n\treturn status;\n}\n\nstatic int qlge_adapter_initialize(struct qlge_adapter *qdev)\n{\n\tu32 value, mask;\n\tint i;\n\tint status = 0;\n\n\t \n\tvalue = SYS_EFE | SYS_FAE;\n\tmask = value << 16;\n\tqlge_write32(qdev, SYS, mask | value);\n\n\t \n\tvalue = NIC_RCV_CFG_DFQ;\n\tmask = NIC_RCV_CFG_DFQ_MASK;\n\tif (qdev->ndev->features & NETIF_F_HW_VLAN_CTAG_RX) {\n\t\tvalue |= NIC_RCV_CFG_RV;\n\t\tmask |= (NIC_RCV_CFG_RV << 16);\n\t}\n\tqlge_write32(qdev, NIC_RCV_CFG, (mask | value));\n\n\t \n\tqlge_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16) | INTR_MASK_PI);\n\n\t \n\tvalue = FSC_FE | FSC_EPC_INBOUND | FSC_EPC_OUTBOUND |\n\t\tFSC_EC | FSC_VM_PAGE_4K;\n\tvalue |= SPLT_SETTING;\n\n\t \n\tmask = FSC_VM_PAGESIZE_MASK |\n\t\tFSC_DBL_MASK | FSC_DBRST_MASK | (value << 16);\n\tqlge_write32(qdev, FSC, mask | value);\n\n\tqlge_write32(qdev, SPLT_HDR, SPLT_LEN);\n\n\t \n\tqlge_write32(qdev, RST_FO, RST_FO_RR_MASK | RST_FO_RR_RCV_FUNC_CQ);\n\t \n\tvalue = qlge_read32(qdev, MGMT_RCV_CFG);\n\tvalue &= ~MGMT_RCV_CFG_RM;\n\tmask = 0xffff0000;\n\n\t \n\tqlge_write32(qdev, MGMT_RCV_CFG, mask);\n\tqlge_write32(qdev, MGMT_RCV_CFG, mask | value);\n\n\t \n\tif (qdev->pdev->subsystem_device == 0x0068 ||\n\t    qdev->pdev->subsystem_device == 0x0180)\n\t\tqdev->wol = WAKE_MAGIC;\n\n\t \n\tfor (i = 0; i < qdev->rx_ring_count; i++) {\n\t\tstatus = qlge_start_rx_ring(qdev, &qdev->rx_ring[i]);\n\t\tif (status) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"Failed to start rx ring[%d].\\n\", i);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t \n\tif (qdev->rss_ring_count > 1) {\n\t\tstatus = qlge_start_rss(qdev);\n\t\tif (status) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev, \"Failed to start RSS.\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < qdev->tx_ring_count; i++) {\n\t\tstatus = qlge_start_tx_ring(qdev, &qdev->tx_ring[i]);\n\t\tif (status) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"Failed to start tx ring[%d].\\n\", i);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t \n\tstatus = qdev->nic_ops->port_initialize(qdev);\n\tif (status)\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Failed to start port.\\n\");\n\n\t \n\tstatus = qlge_cam_route_initialize(qdev);\n\tif (status) {\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Failed to init CAM/Routing tables.\\n\");\n\t\treturn status;\n\t}\n\n\t \n\tfor (i = 0; i < qdev->rss_ring_count; i++)\n\t\tnapi_enable(&qdev->rx_ring[i].napi);\n\n\treturn status;\n}\n\n \nstatic int qlge_adapter_reset(struct qlge_adapter *qdev)\n{\n\tu32 value;\n\tint status = 0;\n\tunsigned long end_jiffies;\n\n\t \n\tstatus = qlge_clear_routing_entries(qdev);\n\tif (status) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Failed to clear routing bits.\\n\");\n\t\treturn status;\n\t}\n\n\t \n\tif (!test_bit(QL_ASIC_RECOVERY, &qdev->flags)) {\n\t\t \n\t\tqlge_mb_set_mgmnt_traffic_ctl(qdev, MB_SET_MPI_TFK_STOP);\n\n\t\t \n\t\tqlge_wait_fifo_empty(qdev);\n\t} else {\n\t\tclear_bit(QL_ASIC_RECOVERY, &qdev->flags);\n\t}\n\n\tqlge_write32(qdev, RST_FO, (RST_FO_FR << 16) | RST_FO_FR);\n\n\tend_jiffies = jiffies + usecs_to_jiffies(30);\n\tdo {\n\t\tvalue = qlge_read32(qdev, RST_FO);\n\t\tif ((value & RST_FO_FR) == 0)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t} while (time_before(jiffies, end_jiffies));\n\n\tif (value & RST_FO_FR) {\n\t\tnetif_err(qdev, ifdown, qdev->ndev,\n\t\t\t  \"ETIMEDOUT!!! errored out of resetting the chip!\\n\");\n\t\tstatus = -ETIMEDOUT;\n\t}\n\n\t \n\tqlge_mb_set_mgmnt_traffic_ctl(qdev, MB_SET_MPI_TFK_RESUME);\n\treturn status;\n}\n\nstatic void qlge_display_dev_info(struct net_device *ndev)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\n\tnetif_info(qdev, probe, qdev->ndev,\n\t\t   \"Function #%d, Port %d, NIC Roll %d, NIC Rev = %d, XG Roll = %d, XG Rev = %d.\\n\",\n\t\t   qdev->func,\n\t\t   qdev->port,\n\t\t   qdev->chip_rev_id & 0x0000000f,\n\t\t   qdev->chip_rev_id >> 4 & 0x0000000f,\n\t\t   qdev->chip_rev_id >> 8 & 0x0000000f,\n\t\t   qdev->chip_rev_id >> 12 & 0x0000000f);\n\tnetif_info(qdev, probe, qdev->ndev,\n\t\t   \"MAC address %pM\\n\", ndev->dev_addr);\n}\n\nstatic int qlge_wol(struct qlge_adapter *qdev)\n{\n\tint status = 0;\n\tu32 wol = MB_WOL_DISABLE;\n\n\t \n\n\tif (qdev->wol & (WAKE_ARP | WAKE_MAGICSECURE | WAKE_PHY | WAKE_UCAST |\n\t\t\t WAKE_MCAST | WAKE_BCAST)) {\n\t\tnetif_err(qdev, ifdown, qdev->ndev,\n\t\t\t  \"Unsupported WOL parameter. qdev->wol = 0x%x.\\n\",\n\t\t\t  qdev->wol);\n\t\treturn -EINVAL;\n\t}\n\n\tif (qdev->wol & WAKE_MAGIC) {\n\t\tstatus = qlge_mb_wol_set_magic(qdev, 1);\n\t\tif (status) {\n\t\t\tnetif_err(qdev, ifdown, qdev->ndev,\n\t\t\t\t  \"Failed to set magic packet on %s.\\n\",\n\t\t\t\t  qdev->ndev->name);\n\t\t\treturn status;\n\t\t}\n\t\tnetif_info(qdev, drv, qdev->ndev,\n\t\t\t   \"Enabled magic packet successfully on %s.\\n\",\n\t\t\t   qdev->ndev->name);\n\n\t\twol |= MB_WOL_MAGIC_PKT;\n\t}\n\n\tif (qdev->wol) {\n\t\twol |= MB_WOL_MODE_ON;\n\t\tstatus = qlge_mb_wol_mode(qdev, wol);\n\t\tnetif_err(qdev, drv, qdev->ndev,\n\t\t\t  \"WOL %s (wol code 0x%x) on %s\\n\",\n\t\t\t  (status == 0) ? \"Successfully set\" : \"Failed\",\n\t\t\t  wol, qdev->ndev->name);\n\t}\n\n\treturn status;\n}\n\nstatic void qlge_cancel_all_work_sync(struct qlge_adapter *qdev)\n{\n\t \n\tif (test_bit(QL_ADAPTER_UP, &qdev->flags))\n\t\tcancel_delayed_work_sync(&qdev->asic_reset_work);\n\tcancel_delayed_work_sync(&qdev->mpi_reset_work);\n\tcancel_delayed_work_sync(&qdev->mpi_work);\n\tcancel_delayed_work_sync(&qdev->mpi_idc_work);\n\tcancel_delayed_work_sync(&qdev->mpi_port_cfg_work);\n}\n\nstatic int qlge_adapter_down(struct qlge_adapter *qdev)\n{\n\tint i, status = 0;\n\n\tqlge_link_off(qdev);\n\n\tqlge_cancel_all_work_sync(qdev);\n\n\tfor (i = 0; i < qdev->rss_ring_count; i++)\n\t\tnapi_disable(&qdev->rx_ring[i].napi);\n\n\tclear_bit(QL_ADAPTER_UP, &qdev->flags);\n\n\tqlge_disable_interrupts(qdev);\n\n\tqlge_tx_ring_clean(qdev);\n\n\t \n\tfor (i = 0; i < qdev->rss_ring_count; i++)\n\t\tnetif_napi_del(&qdev->rx_ring[i].napi);\n\n\tstatus = qlge_adapter_reset(qdev);\n\tif (status)\n\t\tnetif_err(qdev, ifdown, qdev->ndev, \"reset(func #%d) FAILED!\\n\",\n\t\t\t  qdev->func);\n\tqlge_free_rx_buffers(qdev);\n\n\treturn status;\n}\n\nstatic int qlge_adapter_up(struct qlge_adapter *qdev)\n{\n\tint err = 0;\n\n\terr = qlge_adapter_initialize(qdev);\n\tif (err) {\n\t\tnetif_info(qdev, ifup, qdev->ndev, \"Unable to initialize adapter.\\n\");\n\t\tgoto err_init;\n\t}\n\tset_bit(QL_ADAPTER_UP, &qdev->flags);\n\tqlge_alloc_rx_buffers(qdev);\n\t \n\tif ((qlge_read32(qdev, STS) & qdev->port_init) &&\n\t    (qlge_read32(qdev, STS) & qdev->port_link_up))\n\t\tqlge_link_on(qdev);\n\t \n\tclear_bit(QL_ALLMULTI, &qdev->flags);\n\tclear_bit(QL_PROMISCUOUS, &qdev->flags);\n\tqlge_set_multicast_list(qdev->ndev);\n\n\t \n\tqlge_restore_vlan(qdev);\n\n\tqlge_enable_interrupts(qdev);\n\tqlge_enable_all_completion_interrupts(qdev);\n\tnetif_tx_start_all_queues(qdev->ndev);\n\n\treturn 0;\nerr_init:\n\tqlge_adapter_reset(qdev);\n\treturn err;\n}\n\nstatic void qlge_release_adapter_resources(struct qlge_adapter *qdev)\n{\n\tqlge_free_mem_resources(qdev);\n\tqlge_free_irq(qdev);\n}\n\nstatic int qlge_get_adapter_resources(struct qlge_adapter *qdev)\n{\n\tif (qlge_alloc_mem_resources(qdev)) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Unable to  allocate memory.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn qlge_request_irq(qdev);\n}\n\nstatic int qlge_close(struct net_device *ndev)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\tint i;\n\n\t \n\tif (test_bit(QL_EEH_FATAL, &qdev->flags)) {\n\t\tnetif_err(qdev, drv, qdev->ndev, \"EEH fatal did unload.\\n\");\n\t\tclear_bit(QL_EEH_FATAL, &qdev->flags);\n\t\treturn 0;\n\t}\n\n\t \n\twhile (!test_bit(QL_ADAPTER_UP, &qdev->flags))\n\t\tmsleep(1);\n\n\t \n\tfor (i = 0; i < qdev->rss_ring_count; i++)\n\t\tcancel_delayed_work_sync(&qdev->rx_ring[i].refill_work);\n\n\tqlge_adapter_down(qdev);\n\tqlge_release_adapter_resources(qdev);\n\treturn 0;\n}\n\nstatic void qlge_set_lb_size(struct qlge_adapter *qdev)\n{\n\tif (qdev->ndev->mtu <= 1500)\n\t\tqdev->lbq_buf_size = LARGE_BUFFER_MIN_SIZE;\n\telse\n\t\tqdev->lbq_buf_size = LARGE_BUFFER_MAX_SIZE;\n\tqdev->lbq_buf_order = get_order(qdev->lbq_buf_size);\n}\n\nstatic int qlge_configure_rings(struct qlge_adapter *qdev)\n{\n\tint i;\n\tstruct rx_ring *rx_ring;\n\tstruct tx_ring *tx_ring;\n\tint cpu_cnt = min_t(int, MAX_CPUS, num_online_cpus());\n\n\t \n\tqdev->intr_count = cpu_cnt;\n\tqlge_enable_msix(qdev);\n\t \n\tqdev->rss_ring_count = qdev->intr_count;\n\tqdev->tx_ring_count = cpu_cnt;\n\tqdev->rx_ring_count = qdev->tx_ring_count + qdev->rss_ring_count;\n\n\tfor (i = 0; i < qdev->tx_ring_count; i++) {\n\t\ttx_ring = &qdev->tx_ring[i];\n\t\tmemset((void *)tx_ring, 0, sizeof(*tx_ring));\n\t\ttx_ring->qdev = qdev;\n\t\ttx_ring->wq_id = i;\n\t\ttx_ring->wq_len = qdev->tx_ring_size;\n\t\ttx_ring->wq_size =\n\t\t\ttx_ring->wq_len * sizeof(struct qlge_ob_mac_iocb_req);\n\n\t\t \n\t\ttx_ring->cq_id = qdev->rss_ring_count + i;\n\t}\n\n\tfor (i = 0; i < qdev->rx_ring_count; i++) {\n\t\trx_ring = &qdev->rx_ring[i];\n\t\tmemset((void *)rx_ring, 0, sizeof(*rx_ring));\n\t\trx_ring->qdev = qdev;\n\t\trx_ring->cq_id = i;\n\t\trx_ring->cpu = i % cpu_cnt;\t \n\t\tif (i < qdev->rss_ring_count) {\n\t\t\t \n\t\t\trx_ring->cq_len = qdev->rx_ring_size;\n\t\t\trx_ring->cq_size =\n\t\t\t\trx_ring->cq_len * sizeof(struct qlge_net_rsp_iocb);\n\t\t\trx_ring->lbq.type = QLGE_LB;\n\t\t\trx_ring->sbq.type = QLGE_SB;\n\t\t\tINIT_DELAYED_WORK(&rx_ring->refill_work,\n\t\t\t\t\t  &qlge_slow_refill);\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\trx_ring->cq_len = qdev->tx_ring_size;\n\t\t\trx_ring->cq_size =\n\t\t\t\trx_ring->cq_len * sizeof(struct qlge_net_rsp_iocb);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int qlge_open(struct net_device *ndev)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\tint err = 0;\n\n\terr = qlge_adapter_reset(qdev);\n\tif (err)\n\t\treturn err;\n\n\tqlge_set_lb_size(qdev);\n\terr = qlge_configure_rings(qdev);\n\tif (err)\n\t\treturn err;\n\n\terr = qlge_get_adapter_resources(qdev);\n\tif (err)\n\t\tgoto error_up;\n\n\terr = qlge_adapter_up(qdev);\n\tif (err)\n\t\tgoto error_up;\n\n\treturn err;\n\nerror_up:\n\tqlge_release_adapter_resources(qdev);\n\treturn err;\n}\n\nstatic int qlge_change_rx_buffers(struct qlge_adapter *qdev)\n{\n\tint status;\n\n\t \n\tif (!test_bit(QL_ADAPTER_UP, &qdev->flags)) {\n\t\tint i = 4;\n\n\t\twhile (--i && !test_bit(QL_ADAPTER_UP, &qdev->flags)) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"Waiting for adapter UP...\\n\");\n\t\t\tssleep(1);\n\t\t}\n\n\t\tif (!i) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"Timed out waiting for adapter UP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\tstatus = qlge_adapter_down(qdev);\n\tif (status)\n\t\tgoto error;\n\n\tqlge_set_lb_size(qdev);\n\n\tstatus = qlge_adapter_up(qdev);\n\tif (status)\n\t\tgoto error;\n\n\treturn status;\nerror:\n\tnetif_alert(qdev, ifup, qdev->ndev,\n\t\t    \"Driver up/down cycle failed, closing device.\\n\");\n\tset_bit(QL_ADAPTER_UP, &qdev->flags);\n\tdev_close(qdev->ndev);\n\treturn status;\n}\n\nstatic int qlge_change_mtu(struct net_device *ndev, int new_mtu)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\tint status;\n\n\tif (ndev->mtu == 1500 && new_mtu == 9000)\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Changing to jumbo MTU.\\n\");\n\telse if (ndev->mtu == 9000 && new_mtu == 1500)\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"Changing to normal MTU.\\n\");\n\telse\n\t\treturn -EINVAL;\n\n\tqueue_delayed_work(qdev->workqueue,\n\t\t\t   &qdev->mpi_port_cfg_work, 3 * HZ);\n\n\tndev->mtu = new_mtu;\n\n\tif (!netif_running(qdev->ndev))\n\t\treturn 0;\n\n\tstatus = qlge_change_rx_buffers(qdev);\n\tif (status) {\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Changing MTU failed.\\n\");\n\t}\n\n\treturn status;\n}\n\nstatic struct net_device_stats *qlge_get_stats(struct net_device\n\t\t\t\t\t       *ndev)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\tstruct rx_ring *rx_ring = &qdev->rx_ring[0];\n\tstruct tx_ring *tx_ring = &qdev->tx_ring[0];\n\tunsigned long pkts, mcast, dropped, errors, bytes;\n\tint i;\n\n\t \n\tpkts = mcast = dropped = errors = bytes = 0;\n\tfor (i = 0; i < qdev->rss_ring_count; i++, rx_ring++) {\n\t\tpkts += rx_ring->rx_packets;\n\t\tbytes += rx_ring->rx_bytes;\n\t\tdropped += rx_ring->rx_dropped;\n\t\terrors += rx_ring->rx_errors;\n\t\tmcast += rx_ring->rx_multicast;\n\t}\n\tndev->stats.rx_packets = pkts;\n\tndev->stats.rx_bytes = bytes;\n\tndev->stats.rx_dropped = dropped;\n\tndev->stats.rx_errors = errors;\n\tndev->stats.multicast = mcast;\n\n\t \n\tpkts = errors = bytes = 0;\n\tfor (i = 0; i < qdev->tx_ring_count; i++, tx_ring++) {\n\t\tpkts += tx_ring->tx_packets;\n\t\tbytes += tx_ring->tx_bytes;\n\t\terrors += tx_ring->tx_errors;\n\t}\n\tndev->stats.tx_packets = pkts;\n\tndev->stats.tx_bytes = bytes;\n\tndev->stats.tx_errors = errors;\n\treturn &ndev->stats;\n}\n\nstatic void qlge_set_multicast_list(struct net_device *ndev)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\tstruct netdev_hw_addr *ha;\n\tint i, status;\n\n\tstatus = qlge_sem_spinlock(qdev, SEM_RT_IDX_MASK);\n\tif (status)\n\t\treturn;\n\t \n\tif (ndev->flags & IFF_PROMISC) {\n\t\tif (!test_bit(QL_PROMISCUOUS, &qdev->flags)) {\n\t\t\tif (qlge_set_routing_reg\n\t\t\t    (qdev, RT_IDX_PROMISCUOUS_SLOT, RT_IDX_VALID, 1)) {\n\t\t\t\tnetif_err(qdev, hw, qdev->ndev,\n\t\t\t\t\t  \"Failed to set promiscuous mode.\\n\");\n\t\t\t} else {\n\t\t\t\tset_bit(QL_PROMISCUOUS, &qdev->flags);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (test_bit(QL_PROMISCUOUS, &qdev->flags)) {\n\t\t\tif (qlge_set_routing_reg\n\t\t\t    (qdev, RT_IDX_PROMISCUOUS_SLOT, RT_IDX_VALID, 0)) {\n\t\t\t\tnetif_err(qdev, hw, qdev->ndev,\n\t\t\t\t\t  \"Failed to clear promiscuous mode.\\n\");\n\t\t\t} else {\n\t\t\t\tclear_bit(QL_PROMISCUOUS, &qdev->flags);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((ndev->flags & IFF_ALLMULTI) ||\n\t    (netdev_mc_count(ndev) > MAX_MULTICAST_ENTRIES)) {\n\t\tif (!test_bit(QL_ALLMULTI, &qdev->flags)) {\n\t\t\tif (qlge_set_routing_reg\n\t\t\t    (qdev, RT_IDX_ALLMULTI_SLOT, RT_IDX_MCAST, 1)) {\n\t\t\t\tnetif_err(qdev, hw, qdev->ndev,\n\t\t\t\t\t  \"Failed to set all-multi mode.\\n\");\n\t\t\t} else {\n\t\t\t\tset_bit(QL_ALLMULTI, &qdev->flags);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (test_bit(QL_ALLMULTI, &qdev->flags)) {\n\t\t\tif (qlge_set_routing_reg\n\t\t\t    (qdev, RT_IDX_ALLMULTI_SLOT, RT_IDX_MCAST, 0)) {\n\t\t\t\tnetif_err(qdev, hw, qdev->ndev,\n\t\t\t\t\t  \"Failed to clear all-multi mode.\\n\");\n\t\t\t} else {\n\t\t\t\tclear_bit(QL_ALLMULTI, &qdev->flags);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!netdev_mc_empty(ndev)) {\n\t\tstatus = qlge_sem_spinlock(qdev, SEM_MAC_ADDR_MASK);\n\t\tif (status)\n\t\t\tgoto exit;\n\t\ti = 0;\n\t\tnetdev_for_each_mc_addr(ha, ndev) {\n\t\t\tif (qlge_set_mac_addr_reg(qdev, (u8 *)ha->addr,\n\t\t\t\t\t\t  MAC_ADDR_TYPE_MULTI_MAC, i)) {\n\t\t\t\tnetif_err(qdev, hw, qdev->ndev,\n\t\t\t\t\t  \"Failed to loadmulticast address.\\n\");\n\t\t\t\tqlge_sem_unlock(qdev, SEM_MAC_ADDR_MASK);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tqlge_sem_unlock(qdev, SEM_MAC_ADDR_MASK);\n\t\tif (qlge_set_routing_reg\n\t\t    (qdev, RT_IDX_MCAST_MATCH_SLOT, RT_IDX_MCAST_MATCH, 1)) {\n\t\t\tnetif_err(qdev, hw, qdev->ndev,\n\t\t\t\t  \"Failed to set multicast match mode.\\n\");\n\t\t} else {\n\t\t\tset_bit(QL_ALLMULTI, &qdev->flags);\n\t\t}\n\t}\nexit:\n\tqlge_sem_unlock(qdev, SEM_RT_IDX_MASK);\n}\n\nstatic int qlge_set_mac_address(struct net_device *ndev, void *p)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\tstruct sockaddr *addr = p;\n\tint status;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\teth_hw_addr_set(ndev, addr->sa_data);\n\t \n\tmemcpy(qdev->current_mac_addr, ndev->dev_addr, ndev->addr_len);\n\n\tstatus = qlge_sem_spinlock(qdev, SEM_MAC_ADDR_MASK);\n\tif (status)\n\t\treturn status;\n\tstatus = qlge_set_mac_addr_reg(qdev, (const u8 *)ndev->dev_addr,\n\t\t\t\t       MAC_ADDR_TYPE_CAM_MAC,\n\t\t\t\t       qdev->func * MAX_CQ);\n\tif (status)\n\t\tnetif_err(qdev, hw, qdev->ndev, \"Failed to load MAC address.\\n\");\n\tqlge_sem_unlock(qdev, SEM_MAC_ADDR_MASK);\n\treturn status;\n}\n\nstatic void qlge_tx_timeout(struct net_device *ndev, unsigned int txqueue)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\n\tqlge_queue_asic_error(qdev);\n}\n\nstatic void qlge_asic_reset_work(struct work_struct *work)\n{\n\tstruct qlge_adapter *qdev =\n\t\tcontainer_of(work, struct qlge_adapter, asic_reset_work.work);\n\tint status;\n\n\trtnl_lock();\n\tstatus = qlge_adapter_down(qdev);\n\tif (status)\n\t\tgoto error;\n\n\tstatus = qlge_adapter_up(qdev);\n\tif (status)\n\t\tgoto error;\n\n\t \n\tclear_bit(QL_ALLMULTI, &qdev->flags);\n\tclear_bit(QL_PROMISCUOUS, &qdev->flags);\n\tqlge_set_multicast_list(qdev->ndev);\n\n\trtnl_unlock();\n\treturn;\nerror:\n\tnetif_alert(qdev, ifup, qdev->ndev,\n\t\t    \"Driver up/down cycle failed, closing device\\n\");\n\n\tset_bit(QL_ADAPTER_UP, &qdev->flags);\n\tdev_close(qdev->ndev);\n\trtnl_unlock();\n}\n\nstatic const struct nic_operations qla8012_nic_ops = {\n\t.get_flash\t\t= qlge_get_8012_flash_params,\n\t.port_initialize\t= qlge_8012_port_initialize,\n};\n\nstatic const struct nic_operations qla8000_nic_ops = {\n\t.get_flash\t\t= qlge_get_8000_flash_params,\n\t.port_initialize\t= qlge_8000_port_initialize,\n};\n\n \nstatic int qlge_get_alt_pcie_func(struct qlge_adapter *qdev)\n{\n\tint status = 0;\n\tu32 temp;\n\tu32 nic_func1, nic_func2;\n\n\tstatus = qlge_read_mpi_reg(qdev, MPI_TEST_FUNC_PORT_CFG,\n\t\t\t\t   &temp);\n\tif (status)\n\t\treturn status;\n\n\tnic_func1 = ((temp >> MPI_TEST_NIC1_FUNC_SHIFT) &\n\t\t     MPI_TEST_NIC_FUNC_MASK);\n\tnic_func2 = ((temp >> MPI_TEST_NIC2_FUNC_SHIFT) &\n\t\t     MPI_TEST_NIC_FUNC_MASK);\n\n\tif (qdev->func == nic_func1)\n\t\tqdev->alt_func = nic_func2;\n\telse if (qdev->func == nic_func2)\n\t\tqdev->alt_func = nic_func1;\n\telse\n\t\tstatus = -EIO;\n\n\treturn status;\n}\n\nstatic int qlge_get_board_info(struct qlge_adapter *qdev)\n{\n\tint status;\n\n\tqdev->func =\n\t\t(qlge_read32(qdev, STS) & STS_FUNC_ID_MASK) >> STS_FUNC_ID_SHIFT;\n\tif (qdev->func > 3)\n\t\treturn -EIO;\n\n\tstatus = qlge_get_alt_pcie_func(qdev);\n\tif (status)\n\t\treturn status;\n\n\tqdev->port = (qdev->func < qdev->alt_func) ? 0 : 1;\n\tif (qdev->port) {\n\t\tqdev->xg_sem_mask = SEM_XGMAC1_MASK;\n\t\tqdev->port_link_up = STS_PL1;\n\t\tqdev->port_init = STS_PI1;\n\t\tqdev->mailbox_in = PROC_ADDR_MPI_RISC | PROC_ADDR_FUNC2_MBI;\n\t\tqdev->mailbox_out = PROC_ADDR_MPI_RISC | PROC_ADDR_FUNC2_MBO;\n\t} else {\n\t\tqdev->xg_sem_mask = SEM_XGMAC0_MASK;\n\t\tqdev->port_link_up = STS_PL0;\n\t\tqdev->port_init = STS_PI0;\n\t\tqdev->mailbox_in = PROC_ADDR_MPI_RISC | PROC_ADDR_FUNC0_MBI;\n\t\tqdev->mailbox_out = PROC_ADDR_MPI_RISC | PROC_ADDR_FUNC0_MBO;\n\t}\n\tqdev->chip_rev_id = qlge_read32(qdev, REV_ID);\n\tqdev->device_id = qdev->pdev->device;\n\tif (qdev->device_id == QLGE_DEVICE_ID_8012)\n\t\tqdev->nic_ops = &qla8012_nic_ops;\n\telse if (qdev->device_id == QLGE_DEVICE_ID_8000)\n\t\tqdev->nic_ops = &qla8000_nic_ops;\n\treturn status;\n}\n\nstatic void qlge_release_all(struct pci_dev *pdev)\n{\n\tstruct qlge_adapter *qdev = pci_get_drvdata(pdev);\n\n\tif (qdev->workqueue) {\n\t\tdestroy_workqueue(qdev->workqueue);\n\t\tqdev->workqueue = NULL;\n\t}\n\n\tif (qdev->reg_base)\n\t\tiounmap(qdev->reg_base);\n\tif (qdev->doorbell_area)\n\t\tiounmap(qdev->doorbell_area);\n\tvfree(qdev->mpi_coredump);\n\tpci_release_regions(pdev);\n}\n\nstatic int qlge_init_device(struct pci_dev *pdev, struct qlge_adapter *qdev,\n\t\t\t    int cards_found)\n{\n\tstruct net_device *ndev = qdev->ndev;\n\tint err = 0;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"PCI device enable failed.\\n\");\n\t\treturn err;\n\t}\n\n\tqdev->pdev = pdev;\n\tpci_set_drvdata(pdev, qdev);\n\n\t \n\terr = pcie_set_readrq(pdev, 4096);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Set readrq failed.\\n\");\n\t\tgoto err_disable_pci;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"PCI region request failed.\\n\");\n\t\tgoto err_disable_pci;\n\t}\n\n\tpci_set_master(pdev);\n\tif (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(64))) {\n\t\tset_bit(QL_DMA64, &qdev->flags);\n\t\terr = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));\n\t} else {\n\t\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (!err)\n\t\t\terr = dma_set_coherent_mask(&pdev->dev,\n\t\t\t\t\t\t    DMA_BIT_MASK(32));\n\t}\n\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"No usable DMA configuration.\\n\");\n\t\tgoto err_release_pci;\n\t}\n\n\t \n\tpdev->needs_freset = 1;\n\tpci_save_state(pdev);\n\tqdev->reg_base =\n\t\tioremap(pci_resource_start(pdev, 1), pci_resource_len(pdev, 1));\n\tif (!qdev->reg_base) {\n\t\tdev_err(&pdev->dev, \"Register mapping failed.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_release_pci;\n\t}\n\n\tqdev->doorbell_area_size = pci_resource_len(pdev, 3);\n\tqdev->doorbell_area =\n\t\tioremap(pci_resource_start(pdev, 3), pci_resource_len(pdev, 3));\n\tif (!qdev->doorbell_area) {\n\t\tdev_err(&pdev->dev, \"Doorbell register mapping failed.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_iounmap_base;\n\t}\n\n\terr = qlge_get_board_info(qdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Register access failed.\\n\");\n\t\terr = -EIO;\n\t\tgoto err_iounmap_doorbell;\n\t}\n\tqdev->msg_enable = netif_msg_init(debug, default_msg);\n\tspin_lock_init(&qdev->stats_lock);\n\n\tif (qlge_mpi_coredump) {\n\t\tqdev->mpi_coredump =\n\t\t\tvmalloc(sizeof(struct qlge_mpi_coredump));\n\t\tif (!qdev->mpi_coredump) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_iounmap_doorbell;\n\t\t}\n\t\tif (qlge_force_coredump)\n\t\t\tset_bit(QL_FRC_COREDUMP, &qdev->flags);\n\t}\n\t \n\terr = qdev->nic_ops->get_flash(qdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Invalid FLASH.\\n\");\n\t\tgoto err_free_mpi_coredump;\n\t}\n\n\t \n\tmemcpy(qdev->current_mac_addr, ndev->dev_addr, ndev->addr_len);\n\n\t \n\tqdev->tx_ring_size = NUM_TX_RING_ENTRIES;\n\tqdev->rx_ring_size = NUM_RX_RING_ENTRIES;\n\n\t \n\tqdev->rx_coalesce_usecs = DFLT_COALESCE_WAIT;\n\tqdev->tx_coalesce_usecs = DFLT_COALESCE_WAIT;\n\tqdev->rx_max_coalesced_frames = DFLT_INTER_FRAME_WAIT;\n\tqdev->tx_max_coalesced_frames = DFLT_INTER_FRAME_WAIT;\n\n\t \n\tqdev->workqueue = alloc_ordered_workqueue(\"%s\", WQ_MEM_RECLAIM,\n\t\t\t\t\t\t  ndev->name);\n\tif (!qdev->workqueue) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_mpi_coredump;\n\t}\n\n\tINIT_DELAYED_WORK(&qdev->asic_reset_work, qlge_asic_reset_work);\n\tINIT_DELAYED_WORK(&qdev->mpi_reset_work, qlge_mpi_reset_work);\n\tINIT_DELAYED_WORK(&qdev->mpi_work, qlge_mpi_work);\n\tINIT_DELAYED_WORK(&qdev->mpi_port_cfg_work, qlge_mpi_port_cfg_work);\n\tINIT_DELAYED_WORK(&qdev->mpi_idc_work, qlge_mpi_idc_work);\n\tinit_completion(&qdev->ide_completion);\n\tmutex_init(&qdev->mpi_mutex);\n\n\tif (!cards_found) {\n\t\tdev_info(&pdev->dev, \"%s\\n\", DRV_STRING);\n\t\tdev_info(&pdev->dev, \"Driver name: %s, Version: %s.\\n\",\n\t\t\t DRV_NAME, DRV_VERSION);\n\t}\n\treturn 0;\n\nerr_free_mpi_coredump:\n\tvfree(qdev->mpi_coredump);\nerr_iounmap_doorbell:\n\tiounmap(qdev->doorbell_area);\nerr_iounmap_base:\n\tiounmap(qdev->reg_base);\nerr_release_pci:\n\tpci_release_regions(pdev);\nerr_disable_pci:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic const struct net_device_ops qlge_netdev_ops = {\n\t.ndo_open\t\t= qlge_open,\n\t.ndo_stop\t\t= qlge_close,\n\t.ndo_start_xmit\t\t= qlge_send,\n\t.ndo_change_mtu\t\t= qlge_change_mtu,\n\t.ndo_get_stats\t\t= qlge_get_stats,\n\t.ndo_set_rx_mode\t= qlge_set_multicast_list,\n\t.ndo_set_mac_address\t= qlge_set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_tx_timeout\t\t= qlge_tx_timeout,\n\t.ndo_set_features\t= qlge_set_features,\n\t.ndo_vlan_rx_add_vid\t= qlge_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= qlge_vlan_rx_kill_vid,\n};\n\nstatic void qlge_timer(struct timer_list *t)\n{\n\tstruct qlge_adapter *qdev = from_timer(qdev, t, timer);\n\tu32 var = 0;\n\n\tvar = qlge_read32(qdev, STS);\n\tif (pci_channel_offline(qdev->pdev)) {\n\t\tnetif_err(qdev, ifup, qdev->ndev, \"EEH STS = 0x%.08x.\\n\", var);\n\t\treturn;\n\t}\n\n\tmod_timer(&qdev->timer, jiffies + (5 * HZ));\n}\n\nstatic const struct devlink_ops qlge_devlink_ops;\n\nstatic int qlge_probe(struct pci_dev *pdev,\n\t\t      const struct pci_device_id *pci_entry)\n{\n\tstruct qlge_netdev_priv *ndev_priv;\n\tstruct qlge_adapter *qdev = NULL;\n\tstruct net_device *ndev = NULL;\n\tstruct devlink *devlink;\n\tstatic int cards_found;\n\tint err;\n\n\tdevlink = devlink_alloc(&qlge_devlink_ops, sizeof(struct qlge_adapter),\n\t\t\t\t&pdev->dev);\n\tif (!devlink)\n\t\treturn -ENOMEM;\n\n\tqdev = devlink_priv(devlink);\n\n\tndev = alloc_etherdev_mq(sizeof(struct qlge_netdev_priv),\n\t\t\t\t min(MAX_CPUS,\n\t\t\t\t     netif_get_num_default_rss_queues()));\n\tif (!ndev) {\n\t\terr = -ENOMEM;\n\t\tgoto devlink_free;\n\t}\n\n\tndev_priv = netdev_priv(ndev);\n\tndev_priv->qdev = qdev;\n\tndev_priv->ndev = ndev;\n\tqdev->ndev = ndev;\n\terr = qlge_init_device(pdev, qdev, cards_found);\n\tif (err < 0)\n\t\tgoto netdev_free;\n\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\tndev->hw_features = NETIF_F_SG |\n\t\tNETIF_F_IP_CSUM |\n\t\tNETIF_F_TSO |\n\t\tNETIF_F_TSO_ECN |\n\t\tNETIF_F_HW_VLAN_CTAG_TX |\n\t\tNETIF_F_HW_VLAN_CTAG_RX |\n\t\tNETIF_F_HW_VLAN_CTAG_FILTER |\n\t\tNETIF_F_RXCSUM;\n\tndev->features = ndev->hw_features;\n\tndev->vlan_features = ndev->hw_features;\n\t \n\tndev->vlan_features &= ~(NETIF_F_HW_VLAN_CTAG_FILTER |\n\t\t\t\t NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t NETIF_F_HW_VLAN_CTAG_RX);\n\n\tif (test_bit(QL_DMA64, &qdev->flags))\n\t\tndev->features |= NETIF_F_HIGHDMA;\n\n\t \n\tndev->tx_queue_len = qdev->tx_ring_size;\n\tndev->irq = pdev->irq;\n\n\tndev->netdev_ops = &qlge_netdev_ops;\n\tndev->ethtool_ops = &qlge_ethtool_ops;\n\tndev->watchdog_timeo = 10 * HZ;\n\n\t \n\tndev->min_mtu = ETH_DATA_LEN;\n\tndev->max_mtu = 9000;\n\n\terr = register_netdev(ndev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"net device registration failed.\\n\");\n\t\tgoto cleanup_pdev;\n\t}\n\n\terr = qlge_health_create_reporters(qdev);\n\tif (err)\n\t\tgoto unregister_netdev;\n\n\t \n\ttimer_setup(&qdev->timer, qlge_timer, TIMER_DEFERRABLE);\n\tmod_timer(&qdev->timer, jiffies + (5 * HZ));\n\tqlge_link_off(qdev);\n\tqlge_display_dev_info(ndev);\n\tatomic_set(&qdev->lb_count, 0);\n\tcards_found++;\n\tdevlink_register(devlink);\n\treturn 0;\n\nunregister_netdev:\n\tunregister_netdev(ndev);\ncleanup_pdev:\n\tqlge_release_all(pdev);\n\tpci_disable_device(pdev);\nnetdev_free:\n\tfree_netdev(ndev);\ndevlink_free:\n\tdevlink_free(devlink);\n\n\treturn err;\n}\n\nnetdev_tx_t qlge_lb_send(struct sk_buff *skb, struct net_device *ndev)\n{\n\treturn qlge_send(skb, ndev);\n}\n\nint qlge_clean_lb_rx_ring(struct rx_ring *rx_ring, int budget)\n{\n\treturn qlge_clean_inbound_rx_ring(rx_ring, budget);\n}\n\nstatic void qlge_remove(struct pci_dev *pdev)\n{\n\tstruct qlge_adapter *qdev = pci_get_drvdata(pdev);\n\tstruct net_device *ndev = qdev->ndev;\n\tstruct devlink *devlink = priv_to_devlink(qdev);\n\n\tdevlink_unregister(devlink);\n\tdel_timer_sync(&qdev->timer);\n\tqlge_cancel_all_work_sync(qdev);\n\tunregister_netdev(ndev);\n\tqlge_release_all(pdev);\n\tpci_disable_device(pdev);\n\tdevlink_health_reporter_destroy(qdev->reporter);\n\tdevlink_free(devlink);\n\tfree_netdev(ndev);\n}\n\n \nstatic void qlge_eeh_close(struct net_device *ndev)\n{\n\tstruct qlge_adapter *qdev = netdev_to_qdev(ndev);\n\tint i;\n\n\tif (netif_carrier_ok(ndev)) {\n\t\tnetif_carrier_off(ndev);\n\t\tnetif_stop_queue(ndev);\n\t}\n\n\t \n\tqlge_cancel_all_work_sync(qdev);\n\n\tfor (i = 0; i < qdev->rss_ring_count; i++)\n\t\tnetif_napi_del(&qdev->rx_ring[i].napi);\n\n\tclear_bit(QL_ADAPTER_UP, &qdev->flags);\n\tqlge_tx_ring_clean(qdev);\n\tqlge_free_rx_buffers(qdev);\n\tqlge_release_adapter_resources(qdev);\n}\n\n \nstatic pci_ers_result_t qlge_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t       pci_channel_state_t state)\n{\n\tstruct qlge_adapter *qdev = pci_get_drvdata(pdev);\n\tstruct net_device *ndev = qdev->ndev;\n\n\tswitch (state) {\n\tcase pci_channel_io_normal:\n\t\treturn PCI_ERS_RESULT_CAN_RECOVER;\n\tcase pci_channel_io_frozen:\n\t\tnetif_device_detach(ndev);\n\t\tdel_timer_sync(&qdev->timer);\n\t\tif (netif_running(ndev))\n\t\t\tqlge_eeh_close(ndev);\n\t\tpci_disable_device(pdev);\n\t\treturn PCI_ERS_RESULT_NEED_RESET;\n\tcase pci_channel_io_perm_failure:\n\t\tdev_err(&pdev->dev,\n\t\t\t\"%s: pci_channel_io_perm_failure.\\n\", __func__);\n\t\tdel_timer_sync(&qdev->timer);\n\t\tqlge_eeh_close(ndev);\n\t\tset_bit(QL_EEH_FATAL, &qdev->flags);\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\t \n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstatic pci_ers_result_t qlge_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct qlge_adapter *qdev = pci_get_drvdata(pdev);\n\n\tpdev->error_state = pci_channel_io_normal;\n\n\tpci_restore_state(pdev);\n\tif (pci_enable_device(pdev)) {\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Cannot re-enable PCI device after reset.\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\tpci_set_master(pdev);\n\n\tif (qlge_adapter_reset(qdev)) {\n\t\tnetif_err(qdev, drv, qdev->ndev, \"reset FAILED!\\n\");\n\t\tset_bit(QL_EEH_FATAL, &qdev->flags);\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic void qlge_io_resume(struct pci_dev *pdev)\n{\n\tstruct qlge_adapter *qdev = pci_get_drvdata(pdev);\n\tstruct net_device *ndev = qdev->ndev;\n\tint err = 0;\n\n\tif (netif_running(ndev)) {\n\t\terr = qlge_open(ndev);\n\t\tif (err) {\n\t\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t\t  \"Device initialization failed after reset.\\n\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tnetif_err(qdev, ifup, qdev->ndev,\n\t\t\t  \"Device was not running prior to EEH.\\n\");\n\t}\n\tmod_timer(&qdev->timer, jiffies + (5 * HZ));\n\tnetif_device_attach(ndev);\n}\n\nstatic const struct pci_error_handlers qlge_err_handler = {\n\t.error_detected = qlge_io_error_detected,\n\t.slot_reset = qlge_io_slot_reset,\n\t.resume = qlge_io_resume,\n};\n\nstatic int __maybe_unused qlge_suspend(struct device *dev_d)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_d);\n\tstruct qlge_adapter *qdev;\n\tstruct net_device *ndev;\n\tint err;\n\n\tqdev = pci_get_drvdata(pdev);\n\tndev = qdev->ndev;\n\tnetif_device_detach(ndev);\n\tdel_timer_sync(&qdev->timer);\n\n\tif (netif_running(ndev)) {\n\t\terr = qlge_adapter_down(qdev);\n\t\tif (!err)\n\t\t\treturn err;\n\t}\n\n\tqlge_wol(qdev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused qlge_resume(struct device *dev_d)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_d);\n\tstruct qlge_adapter *qdev;\n\tstruct net_device *ndev;\n\tint err;\n\n\tqdev = pci_get_drvdata(pdev);\n\tndev = qdev->ndev;\n\n\tpci_set_master(pdev);\n\n\tdevice_wakeup_disable(dev_d);\n\n\tif (netif_running(ndev)) {\n\t\terr = qlge_adapter_up(qdev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmod_timer(&qdev->timer, jiffies + (5 * HZ));\n\tnetif_device_attach(ndev);\n\n\treturn 0;\n}\n\nstatic void qlge_shutdown(struct pci_dev *pdev)\n{\n\tqlge_suspend(&pdev->dev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(qlge_pm_ops, qlge_suspend, qlge_resume);\n\nstatic struct pci_driver qlge_driver = {\n\t.name = DRV_NAME,\n\t.id_table = qlge_pci_tbl,\n\t.probe = qlge_probe,\n\t.remove = qlge_remove,\n\t.driver.pm = &qlge_pm_ops,\n\t.shutdown = qlge_shutdown,\n\t.err_handler = &qlge_err_handler\n};\n\nmodule_pci_driver(qlge_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}