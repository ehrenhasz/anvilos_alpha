{
  "module_name": "ks7010_sdio.c",
  "hash_id": "3369427296c9db2d3492c312947944e65f8e2cb84b65bedf932db3d844799438",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/ks7010/ks7010_sdio.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/firmware.h>\n#include <linux/jiffies.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/module.h>\n#include <linux/workqueue.h>\n#include \"ks_wlan.h\"\n#include \"ks_hostif.h\"\n\n#define ROM_FILE \"ks7010sd.rom\"\n\n \n#define SDIO_VENDOR_ID_KS_CODE_A\t0x005b\n#define SDIO_VENDOR_ID_KS_CODE_B\t0x0023\n\n \n#define SDIO_DEVICE_ID_KS_7010\t\t0x7910\n\n \n#define READ_STATUS_REG\t\t0x000000\n#define WRITE_STATUS_REG\t0x00000C\nenum reg_status_type {\n\tREG_STATUS_BUSY,\n\tREG_STATUS_IDLE\n};\n\n \n#define READ_INDEX_REG\t\t0x000004\n\n \n#define READ_DATA_SIZE_REG\t0x000008\n\n \n#define WRITE_INDEX_REG\t\t0x000010\n\n \n#define WSTATUS_RSIZE_REG\t0x000014\n\n \n#define WSTATUS_MASK\t\t0x80\n\n \n#define RSIZE_MASK\t\t0x7F\n\n \n#define INT_ENABLE_REG\t\t0x000020\n \n#define INT_PENDING_REG\t\t0x000024\n\n#define INT_GCR_B              BIT(7)\n#define INT_GCR_A              BIT(6)\n#define INT_WRITE_STATUS       BIT(5)\n#define INT_WRITE_INDEX        BIT(4)\n#define INT_WRITE_SIZE         BIT(3)\n#define INT_READ_STATUS        BIT(2)\n#define INT_READ_INDEX         BIT(1)\n#define INT_READ_SIZE          BIT(0)\n\n \n#define GCR_A_REG\t\t0x000028\nenum gen_com_reg_a {\n\tGCR_A_INIT,\n\tGCR_A_REMAP,\n\tGCR_A_RUN\n};\n\n \n#define GCR_B_REG\t\t0x00002C\nenum gen_com_reg_b {\n\tGCR_B_ACTIVE,\n\tGCR_B_DOZE\n};\n\n \n#define WAKEUP_REG\t\t0x008018\n#define WAKEUP_REQ\t\t0x5a\n\n \n#define DATA_WINDOW\t\t0x010000\n#define WINDOW_SIZE\t\t(64 * 1024)\n\n#define KS7010_IRAM_ADDRESS\t0x06000000\n\n#define KS7010_IO_BLOCK_SIZE 512\n\n \nstruct ks_sdio_card {\n\tstruct sdio_func *func;\n\tstruct ks_wlan_private *priv;\n};\n\nstatic struct sdio_func *ks7010_to_func(struct ks_wlan_private *priv)\n{\n\tstruct ks_sdio_card *ks_sdio = priv->if_hw;\n\n\treturn ks_sdio->func;\n}\n\n \nstatic int ks7010_sdio_readb(struct ks_wlan_private *priv,\n\t\t\t     u32 address, u8 *byte)\n{\n\tstruct sdio_func *func = ks7010_to_func(priv);\n\tint ret;\n\n\t*byte = sdio_readb(func, address, &ret);\n\n\treturn ret;\n}\n\n \nstatic int ks7010_sdio_read(struct ks_wlan_private *priv, u32 address,\n\t\t\t    u8 *buffer, unsigned int length)\n{\n\tstruct sdio_func *func = ks7010_to_func(priv);\n\n\treturn sdio_memcpy_fromio(func, buffer, address, length);\n}\n\n \nstatic int ks7010_sdio_writeb(struct ks_wlan_private *priv,\n\t\t\t      u32 address, u8 byte)\n{\n\tstruct sdio_func *func = ks7010_to_func(priv);\n\tint ret;\n\n\tsdio_writeb(func, byte, address, &ret);\n\n\treturn ret;\n}\n\n \nstatic int ks7010_sdio_write(struct ks_wlan_private *priv, u32 address,\n\t\t\t     u8 *buffer, unsigned int length)\n{\n\tstruct sdio_func *func = ks7010_to_func(priv);\n\n\treturn sdio_memcpy_toio(func, address, buffer, length);\n}\n\nstatic void ks_wlan_hw_sleep_doze_request(struct ks_wlan_private *priv)\n{\n\tint ret;\n\n\t \n\tatomic_set(&priv->sleepstatus.doze_request, 0);\n\n\tif (atomic_read(&priv->sleepstatus.status) == 0) {\n\t\tret = ks7010_sdio_writeb(priv, GCR_B_REG, GCR_B_DOZE);\n\t\tif (ret) {\n\t\t\tnetdev_err(priv->net_dev, \"write GCR_B_REG\\n\");\n\t\t\tgoto set_sleep_mode;\n\t\t}\n\t\tatomic_set(&priv->sleepstatus.status, 1);\n\t\tpriv->last_doze = jiffies;\n\t}\n\nset_sleep_mode:\n\tpriv->sleep_mode = atomic_read(&priv->sleepstatus.status);\n}\n\nstatic void ks_wlan_hw_sleep_wakeup_request(struct ks_wlan_private *priv)\n{\n\tint ret;\n\n\t \n\tatomic_set(&priv->sleepstatus.wakeup_request, 0);\n\n\tif (atomic_read(&priv->sleepstatus.status) == 1) {\n\t\tret = ks7010_sdio_writeb(priv, WAKEUP_REG, WAKEUP_REQ);\n\t\tif (ret) {\n\t\t\tnetdev_err(priv->net_dev, \"write WAKEUP_REG\\n\");\n\t\t\tgoto set_sleep_mode;\n\t\t}\n\t\tatomic_set(&priv->sleepstatus.status, 0);\n\t\tpriv->last_wakeup = jiffies;\n\t\t++priv->wakeup_count;\n\t}\n\nset_sleep_mode:\n\tpriv->sleep_mode = atomic_read(&priv->sleepstatus.status);\n}\n\nvoid ks_wlan_hw_wakeup_request(struct ks_wlan_private *priv)\n{\n\tint ret;\n\n\tif (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {\n\t\tret = ks7010_sdio_writeb(priv, WAKEUP_REG, WAKEUP_REQ);\n\t\tif (ret)\n\t\t\tnetdev_err(priv->net_dev, \"write WAKEUP_REG\\n\");\n\n\t\tpriv->last_wakeup = jiffies;\n\t\t++priv->wakeup_count;\n\t}\n}\n\nstatic void _ks_wlan_hw_power_save(struct ks_wlan_private *priv)\n{\n\tu8 byte;\n\tint ret;\n\n\tif (priv->reg.power_mgmt == POWER_MGMT_ACTIVE)\n\t\treturn;\n\n\tif (priv->reg.operation_mode != MODE_INFRASTRUCTURE)\n\t\treturn;\n\n\tif (!is_connect_status(priv->connect_status))\n\t\treturn;\n\n\tif (priv->dev_state != DEVICE_STATE_SLEEP)\n\t\treturn;\n\n\tif (atomic_read(&priv->psstatus.status) == PS_SNOOZE)\n\t\treturn;\n\n\tnetdev_dbg(priv->net_dev,\n\t\t   \"STATUS:\\n\"\n\t\t   \"- psstatus.status = %d\\n\"\n\t\t   \"- psstatus.confirm_wait = %d\\n\"\n\t\t   \"- psstatus.snooze_guard = %d\\n\"\n\t\t   \"- txq_count = %d\\n\",\n\t\t   atomic_read(&priv->psstatus.status),\n\t\t   atomic_read(&priv->psstatus.confirm_wait),\n\t\t   atomic_read(&priv->psstatus.snooze_guard),\n\t\t   txq_count(priv));\n\n\tif (atomic_read(&priv->psstatus.confirm_wait) ||\n\t    atomic_read(&priv->psstatus.snooze_guard) ||\n\t    txq_has_space(priv)) {\n\t\tqueue_delayed_work(priv->wq, &priv->rw_dwork, 0);\n\t\treturn;\n\t}\n\n\tret = ks7010_sdio_readb(priv, INT_PENDING_REG, &byte);\n\tif (ret) {\n\t\tnetdev_err(priv->net_dev, \"read INT_PENDING_REG\\n\");\n\t\tgoto queue_delayed_work;\n\t}\n\tif (byte)\n\t\tgoto queue_delayed_work;\n\n\tret = ks7010_sdio_writeb(priv, GCR_B_REG, GCR_B_DOZE);\n\tif (ret) {\n\t\tnetdev_err(priv->net_dev, \"write GCR_B_REG\\n\");\n\t\tgoto queue_delayed_work;\n\t}\n\tatomic_set(&priv->psstatus.status, PS_SNOOZE);\n\n\treturn;\n\nqueue_delayed_work:\n\tqueue_delayed_work(priv->wq, &priv->rw_dwork, 1);\n}\n\nint ks_wlan_hw_power_save(struct ks_wlan_private *priv)\n{\n\tqueue_delayed_work(priv->wq, &priv->rw_dwork, 1);\n\treturn 0;\n}\n\nstatic int enqueue_txdev(struct ks_wlan_private *priv, unsigned char *p,\n\t\t\t unsigned long size,\n\t\t\t void (*complete_handler)(struct ks_wlan_private *priv,\n\t\t\t\t\t\t  struct sk_buff *skb),\n\t\t\t struct sk_buff *skb)\n{\n\tstruct tx_device_buffer *sp;\n\tint ret;\n\n\tif (priv->dev_state < DEVICE_STATE_BOOT) {\n\t\tret = -EPERM;\n\t\tgoto err_complete;\n\t}\n\n\tif ((TX_DEVICE_BUFF_SIZE - 1) <= txq_count(priv)) {\n\t\tnetdev_err(priv->net_dev, \"tx buffer overflow\\n\");\n\t\tret = -EOVERFLOW;\n\t\tgoto err_complete;\n\t}\n\n\tsp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qtail];\n\tsp->sendp = p;\n\tsp->size = size;\n\tsp->complete_handler = complete_handler;\n\tsp->skb = skb;\n\tinc_txqtail(priv);\n\n\treturn 0;\n\nerr_complete:\n\tkfree(p);\n\tif (complete_handler)\n\t\t(*complete_handler)(priv, skb);\n\n\treturn ret;\n}\n\n \nstatic int write_to_device(struct ks_wlan_private *priv, u8 *buffer,\n\t\t\t   unsigned long size)\n{\n\tstruct hostif_hdr *hdr;\n\tint ret;\n\n\thdr = (struct hostif_hdr *)buffer;\n\n\tif (le16_to_cpu(hdr->event) < HIF_DATA_REQ ||\n\t    le16_to_cpu(hdr->event) > HIF_REQ_MAX) {\n\t\tnetdev_err(priv->net_dev, \"unknown event=%04X\\n\", hdr->event);\n\t\treturn 0;\n\t}\n\n\tret = ks7010_sdio_write(priv, DATA_WINDOW, buffer, size);\n\tif (ret) {\n\t\tnetdev_err(priv->net_dev, \"write DATA_WINDOW\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ks7010_sdio_writeb(priv, WRITE_STATUS_REG, REG_STATUS_BUSY);\n\tif (ret) {\n\t\tnetdev_err(priv->net_dev, \"write WRITE_STATUS_REG\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void tx_device_task(struct ks_wlan_private *priv)\n{\n\tstruct tx_device_buffer *sp;\n\tint ret;\n\n\tif (!txq_has_space(priv) ||\n\t    atomic_read(&priv->psstatus.status) == PS_SNOOZE)\n\t\treturn;\n\n\tsp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];\n\tif (priv->dev_state >= DEVICE_STATE_BOOT) {\n\t\tret = write_to_device(priv, sp->sendp, sp->size);\n\t\tif (ret) {\n\t\t\tnetdev_err(priv->net_dev,\n\t\t\t\t   \"write_to_device error !!(%d)\\n\", ret);\n\t\t\tqueue_delayed_work(priv->wq, &priv->rw_dwork, 1);\n\t\t\treturn;\n\t\t}\n\t}\n\tkfree(sp->sendp);\n\tif (sp->complete_handler)\t \n\t\t(*sp->complete_handler)(priv, sp->skb);\n\tinc_txqhead(priv);\n\n\tif (txq_has_space(priv))\n\t\tqueue_delayed_work(priv->wq, &priv->rw_dwork, 0);\n}\n\nint ks_wlan_hw_tx(struct ks_wlan_private *priv, void *p, unsigned long size,\n\t\t  void (*complete_handler)(struct ks_wlan_private *priv,\n\t\t\t\t\t   struct sk_buff *skb),\n\t\t  struct sk_buff *skb)\n{\n\tint result;\n\tstruct hostif_hdr *hdr;\n\n\thdr = (struct hostif_hdr *)p;\n\n\tif (le16_to_cpu(hdr->event) < HIF_DATA_REQ ||\n\t    le16_to_cpu(hdr->event) > HIF_REQ_MAX) {\n\t\tnetdev_err(priv->net_dev, \"unknown event=%04X\\n\", hdr->event);\n\t\treturn 0;\n\t}\n\n\t \n\tpriv->hostt.buff[priv->hostt.qtail] = le16_to_cpu(hdr->event);\n\tpriv->hostt.qtail = (priv->hostt.qtail + 1) % SME_EVENT_BUFF_SIZE;\n\n\tspin_lock(&priv->tx_dev.tx_dev_lock);\n\tresult = enqueue_txdev(priv, p, size, complete_handler, skb);\n\tspin_unlock(&priv->tx_dev.tx_dev_lock);\n\n\tif (txq_has_space(priv))\n\t\tqueue_delayed_work(priv->wq, &priv->rw_dwork, 0);\n\n\treturn result;\n}\n\nstatic void rx_event_task(struct tasklet_struct *t)\n{\n\tstruct ks_wlan_private *priv = from_tasklet(priv, t, rx_bh_task);\n\tstruct rx_device_buffer *rp;\n\n\tif (rxq_has_space(priv) && priv->dev_state >= DEVICE_STATE_BOOT) {\n\t\trp = &priv->rx_dev.rx_dev_buff[priv->rx_dev.qhead];\n\t\thostif_receive(priv, rp->data, rp->size);\n\t\tinc_rxqhead(priv);\n\n\t\tif (rxq_has_space(priv))\n\t\t\ttasklet_schedule(&priv->rx_bh_task);\n\t}\n}\n\nstatic void ks_wlan_hw_rx(struct ks_wlan_private *priv, size_t size)\n{\n\tint ret;\n\tstruct rx_device_buffer *rx_buffer;\n\tstruct hostif_hdr *hdr;\n\tu16 event = 0;\n\n\t \n\tif (rxq_count(priv) >= (RX_DEVICE_BUFF_SIZE - 1)) {\n\t\tnetdev_err(priv->net_dev, \"rx buffer overflow\\n\");\n\t\treturn;\n\t}\n\trx_buffer = &priv->rx_dev.rx_dev_buff[priv->rx_dev.qtail];\n\n\tret = ks7010_sdio_read(priv, DATA_WINDOW, &rx_buffer->data[0],\n\t\t\t       hif_align_size(size));\n\tif (ret)\n\t\treturn;\n\n\t \n\tif (size > 2046 || size == 0) {\n#ifdef DEBUG\n\t\tprint_hex_dump_bytes(\"INVALID DATA dump: \",\n\t\t\t\t     DUMP_PREFIX_OFFSET,\n\t\t\t\t     rx_buffer->data, 32);\n#endif\n\t\tret = ks7010_sdio_writeb(priv, READ_STATUS_REG,\n\t\t\t\t\t REG_STATUS_IDLE);\n\t\tif (ret)\n\t\t\tnetdev_err(priv->net_dev, \"write READ_STATUS_REG\\n\");\n\n\t\t \n\t\treturn;\n\t}\n\n\thdr = (struct hostif_hdr *)&rx_buffer->data[0];\n\trx_buffer->size = le16_to_cpu(hdr->size) + sizeof(hdr->size);\n\tevent = le16_to_cpu(hdr->event);\n\tinc_rxqtail(priv);\n\n\tret = ks7010_sdio_writeb(priv, READ_STATUS_REG, REG_STATUS_IDLE);\n\tif (ret)\n\t\tnetdev_err(priv->net_dev, \"write READ_STATUS_REG\\n\");\n\n\tif (atomic_read(&priv->psstatus.confirm_wait) && is_hif_conf(event)) {\n\t\tnetdev_dbg(priv->net_dev, \"IS_HIF_CONF true !!\\n\");\n\t\tatomic_dec(&priv->psstatus.confirm_wait);\n\t}\n\n\ttasklet_schedule(&priv->rx_bh_task);\n}\n\nstatic void ks7010_rw_function(struct work_struct *work)\n{\n\tstruct ks_wlan_private *priv = container_of(work,\n\t\t\t\t\t\t    struct ks_wlan_private,\n\t\t\t\t\t\t    rw_dwork.work);\n\tstruct sdio_func *func = ks7010_to_func(priv);\n\tu8 byte;\n\tint ret;\n\n\t \n\tif (time_after(priv->last_doze + msecs_to_jiffies(30), jiffies)) {\n\t\tnetdev_dbg(priv->net_dev, \"wait after DOZE\\n\");\n\t\tqueue_delayed_work(priv->wq, &priv->rw_dwork, 1);\n\t\treturn;\n\t}\n\n\t \n\twhile (time_after(priv->last_wakeup + msecs_to_jiffies(30), jiffies)) {\n\t\tnetdev_dbg(priv->net_dev, \"wait after WAKEUP\\n\");\n\t\tdev_info(&func->dev, \"wake: %lu %lu\\n\",\n\t\t\t priv->last_wakeup + msecs_to_jiffies(30), jiffies);\n\t\tmsleep(30);\n\t}\n\n\tsdio_claim_host(func);\n\n\t \n\tif (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {\n\t\tif (txq_has_space(priv)) {\n\t\t\tks_wlan_hw_wakeup_request(priv);\n\t\t\tqueue_delayed_work(priv->wq, &priv->rw_dwork, 1);\n\t\t}\n\t\tgoto release_host;\n\t}\n\n\t \n\tif (atomic_read(&priv->sleepstatus.doze_request) == 1) {\n\t\tks_wlan_hw_sleep_doze_request(priv);\n\t\tgoto release_host;\n\t}\n\t \n\tif (atomic_read(&priv->sleepstatus.wakeup_request) == 1) {\n\t\tks_wlan_hw_sleep_wakeup_request(priv);\n\t\tgoto release_host;\n\t}\n\n\t \n\tret = ks7010_sdio_readb(priv, WSTATUS_RSIZE_REG, &byte);\n\tif (ret) {\n\t\tnetdev_err(priv->net_dev, \"read WSTATUS_RSIZE_REG psstatus=%d\\n\",\n\t\t\t   atomic_read(&priv->psstatus.status));\n\t\tgoto release_host;\n\t}\n\n\tif (byte & RSIZE_MASK) {\t \n\t\tks_wlan_hw_rx(priv, (size_t)((byte & RSIZE_MASK) << 4));\n\t}\n\tif ((byte & WSTATUS_MASK))\n\t\ttx_device_task(priv);\n\n\t_ks_wlan_hw_power_save(priv);\n\nrelease_host:\n\tsdio_release_host(func);\n}\n\nstatic void ks_sdio_interrupt(struct sdio_func *func)\n{\n\tint ret;\n\tstruct ks_sdio_card *card;\n\tstruct ks_wlan_private *priv;\n\tu8 status, rsize, byte;\n\n\tcard = sdio_get_drvdata(func);\n\tpriv = card->priv;\n\n\tif (priv->dev_state < DEVICE_STATE_BOOT)\n\t\tgoto queue_delayed_work;\n\n\tret = ks7010_sdio_readb(priv, INT_PENDING_REG, &status);\n\tif (ret) {\n\t\tnetdev_err(priv->net_dev, \"read INT_PENDING_REG\\n\");\n\t\tgoto queue_delayed_work;\n\t}\n\n\t \n\t \n\t \n\t \n\t \n\tif (status & INT_GCR_B ||\n\t    atomic_read(&priv->psstatus.status) == PS_SNOOZE) {\n\t\tret = ks7010_sdio_readb(priv, GCR_B_REG, &byte);\n\t\tif (ret) {\n\t\t\tnetdev_err(priv->net_dev, \"read GCR_B_REG\\n\");\n\t\t\tgoto queue_delayed_work;\n\t\t}\n\t\tif (byte == GCR_B_ACTIVE) {\n\t\t\tif (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {\n\t\t\t\tatomic_set(&priv->psstatus.status, PS_WAKEUP);\n\t\t\t\tpriv->wakeup_count = 0;\n\t\t\t}\n\t\t\tcomplete(&priv->psstatus.wakeup_wait);\n\t\t}\n\t}\n\n\tdo {\n\t\t \n\t\tret = ks7010_sdio_readb(priv, WSTATUS_RSIZE_REG, &byte);\n\t\tif (ret) {\n\t\t\tnetdev_err(priv->net_dev, \"read WSTATUS_RSIZE_REG\\n\");\n\t\t\tgoto queue_delayed_work;\n\t\t}\n\t\trsize = byte & RSIZE_MASK;\n\t\tif (rsize != 0)\t\t \n\t\t\tks_wlan_hw_rx(priv, (size_t)(rsize << 4));\n\n\t\tif (byte & WSTATUS_MASK) {\n\t\t\tif (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {\n\t\t\t\tif (txq_has_space(priv)) {\n\t\t\t\t\tks_wlan_hw_wakeup_request(priv);\n\t\t\t\t\tqueue_delayed_work(priv->wq,\n\t\t\t\t\t\t\t   &priv->rw_dwork, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttx_device_task(priv);\n\t\t\t}\n\t\t}\n\t} while (rsize);\n\nqueue_delayed_work:\n\tqueue_delayed_work(priv->wq, &priv->rw_dwork, 0);\n}\n\nstatic int trx_device_init(struct ks_wlan_private *priv)\n{\n\tpriv->tx_dev.qhead = 0;\n\tpriv->tx_dev.qtail = 0;\n\n\tpriv->rx_dev.qhead = 0;\n\tpriv->rx_dev.qtail = 0;\n\n\tspin_lock_init(&priv->tx_dev.tx_dev_lock);\n\tspin_lock_init(&priv->rx_dev.rx_dev_lock);\n\n\ttasklet_setup(&priv->rx_bh_task, rx_event_task);\n\n\treturn 0;\n}\n\nstatic void trx_device_exit(struct ks_wlan_private *priv)\n{\n\tstruct tx_device_buffer *sp;\n\n\t \n\twhile (txq_has_space(priv)) {\n\t\tsp = &priv->tx_dev.tx_dev_buff[priv->tx_dev.qhead];\n\t\tkfree(sp->sendp);\n\t\tif (sp->complete_handler)\t \n\t\t\t(*sp->complete_handler)(priv, sp->skb);\n\t\tinc_txqhead(priv);\n\t}\n\n\ttasklet_kill(&priv->rx_bh_task);\n}\n\nstatic int ks7010_sdio_update_index(struct ks_wlan_private *priv, u32 index)\n{\n\tint ret;\n\tunsigned char *data_buf;\n\n\tdata_buf = kmemdup(&index, sizeof(u32), GFP_KERNEL);\n\tif (!data_buf)\n\t\treturn -ENOMEM;\n\n\tret = ks7010_sdio_write(priv, WRITE_INDEX_REG, data_buf, sizeof(index));\n\tif (ret)\n\t\tgoto err_free_data_buf;\n\n\tret = ks7010_sdio_write(priv, READ_INDEX_REG, data_buf, sizeof(index));\n\tif (ret)\n\t\tgoto err_free_data_buf;\n\n\treturn 0;\n\nerr_free_data_buf:\n\tkfree(data_buf);\n\n\treturn ret;\n}\n\n#define ROM_BUFF_SIZE (64 * 1024)\nstatic int ks7010_sdio_data_compare(struct ks_wlan_private *priv, u32 address,\n\t\t\t\t    u8 *data, unsigned int size)\n{\n\tint ret;\n\tu8 *read_buf;\n\n\tread_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);\n\tif (!read_buf)\n\t\treturn -ENOMEM;\n\n\tret = ks7010_sdio_read(priv, address, read_buf, size);\n\tif (ret)\n\t\tgoto err_free_read_buf;\n\n\tif (memcmp(data, read_buf, size) != 0) {\n\t\tret = -EIO;\n\t\tnetdev_err(priv->net_dev, \"data compare error (%d)\\n\", ret);\n\t\tgoto err_free_read_buf;\n\t}\n\n\treturn 0;\n\nerr_free_read_buf:\n\tkfree(read_buf);\n\n\treturn ret;\n}\n\nstatic int ks7010_copy_firmware(struct ks_wlan_private *priv,\n\t\t\t\tconst struct firmware *fw_entry)\n{\n\tunsigned int length;\n\tunsigned int size;\n\tunsigned int offset;\n\tunsigned int n = 0;\n\tu8 *rom_buf;\n\tint ret;\n\n\trom_buf = kmalloc(ROM_BUFF_SIZE, GFP_KERNEL);\n\tif (!rom_buf)\n\t\treturn -ENOMEM;\n\n\tlength = fw_entry->size;\n\n\tdo {\n\t\tif (length >= ROM_BUFF_SIZE) {\n\t\t\tsize = ROM_BUFF_SIZE;\n\t\t\tlength = length - ROM_BUFF_SIZE;\n\t\t} else {\n\t\t\tsize = length;\n\t\t\tlength = 0;\n\t\t}\n\t\tif (size == 0)\n\t\t\tbreak;\n\n\t\tmemcpy(rom_buf, fw_entry->data + n, size);\n\n\t\toffset = n;\n\t\tret = ks7010_sdio_update_index(priv,\n\t\t\t\t\t       KS7010_IRAM_ADDRESS + offset);\n\t\tif (ret)\n\t\t\tgoto free_rom_buf;\n\n\t\tret = ks7010_sdio_write(priv, DATA_WINDOW, rom_buf, size);\n\t\tif (ret)\n\t\t\tgoto free_rom_buf;\n\n\t\tret = ks7010_sdio_data_compare(priv,\n\t\t\t\t\t       DATA_WINDOW, rom_buf, size);\n\t\tif (ret)\n\t\t\tgoto free_rom_buf;\n\n\t\tn += size;\n\n\t} while (size);\n\n\tret = ks7010_sdio_writeb(priv, GCR_A_REG, GCR_A_REMAP);\n\nfree_rom_buf:\n\tkfree(rom_buf);\n\treturn ret;\n}\n\nstatic int ks7010_upload_firmware(struct ks_sdio_card *card)\n{\n\tstruct ks_wlan_private *priv = card->priv;\n\tstruct sdio_func *func = ks7010_to_func(priv);\n\tunsigned int n;\n\tu8 byte = 0;\n\tint ret;\n\tconst struct firmware *fw_entry = NULL;\n\n\tsdio_claim_host(func);\n\n\t \n\tret = ks7010_sdio_readb(priv, GCR_A_REG, &byte);\n\tif (ret)\n\t\tgoto release_host;\n\tif (byte == GCR_A_RUN) {\n\t\tnetdev_dbg(priv->net_dev, \"MAC firmware running ...\\n\");\n\t\tret = -EBUSY;\n\t\tgoto release_host;\n\t}\n\n\tret = request_firmware(&fw_entry, ROM_FILE,\n\t\t\t       &func->dev);\n\tif (ret)\n\t\tgoto release_host;\n\n\tret = ks7010_copy_firmware(priv, fw_entry);\n\tif (ret)\n\t\tgoto release_firmware;\n\n\t \n\tfor (n = 0; n < 50; ++n) {\n\t\tusleep_range(10000, 11000);\t \n\t\tret = ks7010_sdio_readb(priv, GCR_A_REG, &byte);\n\t\tif (ret)\n\t\t\tgoto release_firmware;\n\n\t\tif (byte == GCR_A_RUN)\n\t\t\tbreak;\n\t}\n\tif ((50) <= n) {\n\t\tnetdev_err(priv->net_dev, \"firmware can't start\\n\");\n\t\tret = -EIO;\n\t\tgoto release_firmware;\n\t}\n\n\tret = 0;\n\n release_firmware:\n\trelease_firmware(fw_entry);\n release_host:\n\tsdio_release_host(func);\n\n\treturn ret;\n}\n\nstatic void ks7010_sme_enqueue_events(struct ks_wlan_private *priv)\n{\n\tstatic const u16 init_events[] = {\n\t\tSME_GET_EEPROM_CKSUM, SME_STOP_REQUEST,\n\t\tSME_RTS_THRESHOLD_REQUEST, SME_FRAGMENTATION_THRESHOLD_REQUEST,\n\t\tSME_WEP_INDEX_REQUEST, SME_WEP_KEY1_REQUEST,\n\t\tSME_WEP_KEY2_REQUEST, SME_WEP_KEY3_REQUEST,\n\t\tSME_WEP_KEY4_REQUEST, SME_WEP_FLAG_REQUEST,\n\t\tSME_RSN_ENABLED_REQUEST, SME_MODE_SET_REQUEST,\n\t\tSME_START_REQUEST\n\t};\n\tint ev;\n\n\tfor (ev = 0; ev < ARRAY_SIZE(init_events); ev++)\n\t\thostif_sme_enqueue(priv, init_events[ev]);\n}\n\nstatic void ks7010_card_init(struct ks_wlan_private *priv)\n{\n\tinit_completion(&priv->confirm_wait);\n\n\t \n\thostif_sme_enqueue(priv, SME_START);\n\n\tif (!wait_for_completion_interruptible_timeout\n\t    (&priv->confirm_wait, 5 * HZ)) {\n\t\tnetdev_dbg(priv->net_dev, \"wait time out!! SME_START\\n\");\n\t}\n\n\tif (priv->mac_address_valid && priv->version_size != 0)\n\t\tpriv->dev_state = DEVICE_STATE_PREINIT;\n\n\tks7010_sme_enqueue_events(priv);\n\n\tif (!wait_for_completion_interruptible_timeout\n\t    (&priv->confirm_wait, 5 * HZ)) {\n\t\tnetdev_dbg(priv->net_dev, \"wait time out!! wireless parameter set\\n\");\n\t}\n\n\tif (priv->dev_state >= DEVICE_STATE_PREINIT) {\n\t\tnetdev_dbg(priv->net_dev, \"DEVICE READY!!\\n\");\n\t\tpriv->dev_state = DEVICE_STATE_READY;\n\t}\n}\n\nstatic void ks7010_init_defaults(struct ks_wlan_private *priv)\n{\n\tpriv->reg.tx_rate = TX_RATE_AUTO;\n\tpriv->reg.preamble = LONG_PREAMBLE;\n\tpriv->reg.power_mgmt = POWER_MGMT_ACTIVE;\n\tpriv->reg.scan_type = ACTIVE_SCAN;\n\tpriv->reg.beacon_lost_count = 20;\n\tpriv->reg.rts = 2347UL;\n\tpriv->reg.fragment = 2346UL;\n\tpriv->reg.phy_type = D_11BG_COMPATIBLE_MODE;\n\tpriv->reg.cts_mode = CTS_MODE_FALSE;\n\tpriv->reg.rate_set.body[11] = TX_RATE_54M;\n\tpriv->reg.rate_set.body[10] = TX_RATE_48M;\n\tpriv->reg.rate_set.body[9] = TX_RATE_36M;\n\tpriv->reg.rate_set.body[8] = TX_RATE_18M;\n\tpriv->reg.rate_set.body[7] = TX_RATE_9M;\n\tpriv->reg.rate_set.body[6] = TX_RATE_24M | BASIC_RATE;\n\tpriv->reg.rate_set.body[5] = TX_RATE_12M | BASIC_RATE;\n\tpriv->reg.rate_set.body[4] = TX_RATE_6M | BASIC_RATE;\n\tpriv->reg.rate_set.body[3] = TX_RATE_11M | BASIC_RATE;\n\tpriv->reg.rate_set.body[2] = TX_RATE_5M | BASIC_RATE;\n\tpriv->reg.rate_set.body[1] = TX_RATE_2M | BASIC_RATE;\n\tpriv->reg.rate_set.body[0] = TX_RATE_1M | BASIC_RATE;\n\tpriv->reg.tx_rate = TX_RATE_FULL_AUTO;\n\tpriv->reg.rate_set.size = 12;\n}\n\nstatic int ks7010_sdio_setup_irqs(struct sdio_func *func)\n{\n\tint ret;\n\n\t \n\tsdio_writeb(func, 0, INT_ENABLE_REG, &ret);\n\tif (ret)\n\t\tgoto irq_error;\n\n\tsdio_writeb(func, 0xff, INT_PENDING_REG, &ret);\n\tif (ret)\n\t\tgoto irq_error;\n\n\t \n\tret = sdio_claim_irq(func, ks_sdio_interrupt);\n\nirq_error:\n\treturn ret;\n}\n\nstatic void ks7010_sdio_init_irqs(struct sdio_func *func,\n\t\t\t\t  struct ks_wlan_private *priv)\n{\n\tu8 byte;\n\tint ret;\n\n\t \n\tsdio_claim_host(func);\n\tret = ks7010_sdio_writeb(priv, INT_PENDING_REG, 0xff);\n\tsdio_release_host(func);\n\tif (ret)\n\t\tnetdev_err(priv->net_dev, \"write INT_PENDING_REG\\n\");\n\n\t \n\tbyte = (INT_GCR_B | INT_READ_STATUS | INT_WRITE_STATUS);\n\tsdio_claim_host(func);\n\tret = ks7010_sdio_writeb(priv, INT_ENABLE_REG, byte);\n\tsdio_release_host(func);\n\tif (ret)\n\t\tnetdev_err(priv->net_dev, \"write INT_ENABLE_REG\\n\");\n}\n\nstatic void ks7010_private_init(struct ks_wlan_private *priv,\n\t\t\t\tstruct ks_sdio_card *card,\n\t\t\t\tstruct net_device *netdev)\n{\n\t \n\tpriv->if_hw = card;\n\n\tpriv->dev_state = DEVICE_STATE_PREBOOT;\n\tpriv->net_dev = netdev;\n\tpriv->firmware_version[0] = '\\0';\n\tpriv->version_size = 0;\n\tpriv->last_doze = jiffies;\n\tpriv->last_wakeup = jiffies;\n\tmemset(&priv->nstats, 0, sizeof(priv->nstats));\n\tmemset(&priv->wstats, 0, sizeof(priv->wstats));\n\n\t \n\tatomic_set(&priv->sleepstatus.status, 0);\n\tatomic_set(&priv->sleepstatus.doze_request, 0);\n\tatomic_set(&priv->sleepstatus.wakeup_request, 0);\n\n\ttrx_device_init(priv);\n\thostif_init(priv);\n\tks_wlan_net_start(netdev);\n\tks7010_init_defaults(priv);\n}\n\nstatic int ks7010_sdio_probe(struct sdio_func *func,\n\t\t\t     const struct sdio_device_id *device)\n{\n\tstruct ks_wlan_private *priv = NULL;\n\tstruct net_device *netdev = NULL;\n\tstruct ks_sdio_card *card;\n\tint ret;\n\n\tcard = kzalloc(sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tcard->func = func;\n\n\tsdio_claim_host(func);\n\n\tret = sdio_set_block_size(func, KS7010_IO_BLOCK_SIZE);\n\tif (ret)\n\t\tgoto err_free_card;\n\n\tdev_dbg(&card->func->dev, \"multi_block=%d sdio_set_block_size()=%d %d\\n\",\n\t\tfunc->card->cccr.multi_block, func->cur_blksize, ret);\n\n\tret = sdio_enable_func(func);\n\tif (ret)\n\t\tgoto err_free_card;\n\n\tret = ks7010_sdio_setup_irqs(func);\n\tif (ret)\n\t\tgoto err_disable_func;\n\n\tsdio_release_host(func);\n\n\tsdio_set_drvdata(func, card);\n\n\tdev_dbg(&card->func->dev, \"class = 0x%X, vendor = 0x%X, device = 0x%X\\n\",\n\t\tfunc->class, func->vendor, func->device);\n\n\t \n\tnetdev = alloc_etherdev(sizeof(*priv));\n\tif (!netdev) {\n\t\tdev_err(&card->func->dev, \"Unable to alloc new net device\\n\");\n\t\tgoto err_release_irq;\n\t}\n\n\tret = dev_alloc_name(netdev, \"wlan%d\");\n\tif (ret < 0) {\n\t\tdev_err(&card->func->dev, \"Couldn't get name!\\n\");\n\t\tgoto err_free_netdev;\n\t}\n\n\tpriv = netdev_priv(netdev);\n\n\tcard->priv = priv;\n\tSET_NETDEV_DEV(netdev, &card->func->dev);\n\n\tks7010_private_init(priv, card, netdev);\n\n\tret = ks7010_upload_firmware(card);\n\tif (ret) {\n\t\tnetdev_err(priv->net_dev,\n\t\t\t   \"firmware load failed !! ret = %d\\n\", ret);\n\t\tgoto err_free_netdev;\n\t}\n\n\tks7010_sdio_init_irqs(func, priv);\n\n\tpriv->dev_state = DEVICE_STATE_BOOT;\n\n\tpriv->wq = alloc_workqueue(\"wq\", WQ_MEM_RECLAIM, 1);\n\tif (!priv->wq) {\n\t\tnetdev_err(priv->net_dev, \"create_workqueue failed !!\\n\");\n\t\tgoto err_free_netdev;\n\t}\n\n\tINIT_DELAYED_WORK(&priv->rw_dwork, ks7010_rw_function);\n\tks7010_card_init(priv);\n\n\tret = register_netdev(priv->net_dev);\n\tif (ret)\n\t\tgoto err_destroy_wq;\n\n\treturn 0;\n\n err_destroy_wq:\n\tdestroy_workqueue(priv->wq);\n err_free_netdev:\n\tfree_netdev(netdev);\n err_release_irq:\n\tsdio_claim_host(func);\n\tsdio_release_irq(func);\n err_disable_func:\n\tsdio_disable_func(func);\n err_free_card:\n\tsdio_release_host(func);\n\tsdio_set_drvdata(func, NULL);\n\tkfree(card);\n\n\treturn -ENODEV;\n}\n\n \nstatic int send_stop_request(struct sdio_func *func)\n{\n\tstruct hostif_stop_request *pp;\n\tstruct ks_sdio_card *card;\n\tsize_t size;\n\n\tcard = sdio_get_drvdata(func);\n\n\tpp = kzalloc(hif_align_size(sizeof(*pp)), GFP_KERNEL);\n\tif (!pp)\n\t\treturn -ENOMEM;\n\n\tsize = sizeof(*pp) - sizeof(pp->header.size);\n\tpp->header.size = cpu_to_le16(size);\n\tpp->header.event = cpu_to_le16(HIF_STOP_REQ);\n\n\tsdio_claim_host(func);\n\twrite_to_device(card->priv, (u8 *)pp, hif_align_size(sizeof(*pp)));\n\tsdio_release_host(func);\n\n\tkfree(pp);\n\treturn 0;\n}\n\nstatic void ks7010_sdio_remove(struct sdio_func *func)\n{\n\tint ret;\n\tstruct ks_sdio_card *card;\n\tstruct ks_wlan_private *priv;\n\n\tcard = sdio_get_drvdata(func);\n\n\tif (!card)\n\t\treturn;\n\n\tpriv = card->priv;\n\tif (!priv)\n\t\tgoto err_free_card;\n\n\tks_wlan_net_stop(priv->net_dev);\n\n\t \n\tsdio_claim_host(func);\n\tsdio_writeb(func, 0, INT_ENABLE_REG, &ret);\n\tsdio_writeb(func, 0xff, INT_PENDING_REG, &ret);\n\tsdio_release_host(func);\n\n\tret = send_stop_request(func);\n\tif (ret)\t \n\t\tgoto err_free_card;\n\n\tif (priv->wq)\n\t\tdestroy_workqueue(priv->wq);\n\n\thostif_exit(priv);\n\n\tunregister_netdev(priv->net_dev);\n\n\ttrx_device_exit(priv);\n\tfree_netdev(priv->net_dev);\n\tcard->priv = NULL;\n\n\tsdio_claim_host(func);\n\tsdio_release_irq(func);\n\tsdio_disable_func(func);\n\tsdio_release_host(func);\nerr_free_card:\n\tsdio_set_drvdata(func, NULL);\n\tkfree(card);\n}\n\nstatic const struct sdio_device_id ks7010_sdio_ids[] = {\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_A, SDIO_DEVICE_ID_KS_7010)},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_KS_CODE_B, SDIO_DEVICE_ID_KS_7010)},\n\t{   }\n};\nMODULE_DEVICE_TABLE(sdio, ks7010_sdio_ids);\n\nstatic struct sdio_driver ks7010_sdio_driver = {\n\t.name = \"ks7010_sdio\",\n\t.id_table = ks7010_sdio_ids,\n\t.probe = ks7010_sdio_probe,\n\t.remove = ks7010_sdio_remove,\n};\n\nmodule_driver(ks7010_sdio_driver, sdio_register_driver, sdio_unregister_driver);\nMODULE_AUTHOR(\"Sang Engineering, Qi-Hardware, KeyStream\");\nMODULE_DESCRIPTION(\"Driver for KeyStream KS7010 based SDIO cards\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_FIRMWARE(ROM_FILE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}