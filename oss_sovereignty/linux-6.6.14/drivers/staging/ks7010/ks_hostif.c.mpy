{
  "module_name": "ks_hostif.c",
  "hash_id": "2093d9127913b08053db09ca6e980b804510bbd91edb4c595b7fb479b00cdbe2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/ks7010/ks_hostif.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <linux/circ_buf.h>\n#include <linux/if_arp.h>\n#include <net/iw_handler.h>\n#include <uapi/linux/llc.h>\n#include \"eap_packet.h\"\n#include \"ks_wlan.h\"\n#include \"ks_hostif.h\"\n\n#define MICHAEL_MIC_KEY_LEN 8\n#define MICHAEL_MIC_LEN     8\n\nstatic inline void inc_smeqhead(struct ks_wlan_private *priv)\n{\n\tpriv->sme_i.qhead = (priv->sme_i.qhead + 1) % SME_EVENT_BUFF_SIZE;\n}\n\nstatic inline void inc_smeqtail(struct ks_wlan_private *priv)\n{\n\tpriv->sme_i.qtail = (priv->sme_i.qtail + 1) % SME_EVENT_BUFF_SIZE;\n}\n\nstatic inline unsigned int cnt_smeqbody(struct ks_wlan_private *priv)\n{\n\treturn CIRC_CNT_TO_END(priv->sme_i.qhead, priv->sme_i.qtail,\n\t\t\t       SME_EVENT_BUFF_SIZE);\n}\n\nstatic inline u8 get_byte(struct ks_wlan_private *priv)\n{\n\tu8 data;\n\n\tdata = *priv->rxp++;\n\t \n\t--(priv->rx_size);\n\treturn data;\n}\n\nstatic inline u16 get_word(struct ks_wlan_private *priv)\n{\n\tu16 data;\n\n\tdata = (get_byte(priv) & 0xff);\n\tdata |= ((get_byte(priv) << 8) & 0xff00);\n\treturn data;\n}\n\nstatic inline u32 get_dword(struct ks_wlan_private *priv)\n{\n\tu32 data;\n\n\tdata = (get_byte(priv) & 0xff);\n\tdata |= ((get_byte(priv) << 8) & 0x0000ff00);\n\tdata |= ((get_byte(priv) << 16) & 0x00ff0000);\n\tdata |= ((get_byte(priv) << 24) & 0xff000000);\n\treturn data;\n}\n\nstatic void ks_wlan_hw_wakeup_task(struct work_struct *work)\n{\n\tstruct ks_wlan_private *priv;\n\tint ps_status;\n\tlong time_left;\n\n\tpriv = container_of(work, struct ks_wlan_private, wakeup_work);\n\tps_status = atomic_read(&priv->psstatus.status);\n\n\tif (ps_status == PS_SNOOZE) {\n\t\tks_wlan_hw_wakeup_request(priv);\n\t\ttime_left = wait_for_completion_interruptible_timeout(&priv->psstatus.wakeup_wait,\n\t\t\t\t\t\t\t\t      msecs_to_jiffies(20));\n\t\tif (time_left <= 0) {\n\t\t\tnetdev_dbg(priv->net_dev, \"wake up timeout or interrupted !!!\\n\");\n\t\t\tschedule_work(&priv->wakeup_work);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void ks_wlan_do_power_save(struct ks_wlan_private *priv)\n{\n\tif (is_connect_status(priv->connect_status))\n\t\thostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);\n\telse\n\t\tpriv->dev_state = DEVICE_STATE_READY;\n}\n\nstatic\nint get_current_ap(struct ks_wlan_private *priv, struct link_ap_info *ap_info)\n{\n\tstruct local_ap *ap;\n\tunion iwreq_data wrqu;\n\tstruct net_device *netdev = priv->net_dev;\n\tu8 size;\n\n\tap = &priv->current_ap;\n\n\tif (is_disconnect_status(priv->connect_status)) {\n\t\tmemset(ap, 0, sizeof(struct local_ap));\n\t\treturn -EPERM;\n\t}\n\n\tether_addr_copy(ap->bssid, ap_info->bssid);\n\tmemcpy(ap->ssid.body, priv->reg.ssid.body,\n\t       priv->reg.ssid.size);\n\tap->ssid.size = priv->reg.ssid.size;\n\tmemcpy(ap->rate_set.body, ap_info->rate_set.body,\n\t       ap_info->rate_set.size);\n\tap->rate_set.size = ap_info->rate_set.size;\n\tif (ap_info->ext_rate_set.size != 0) {\n\t\tmemcpy(&ap->rate_set.body[ap->rate_set.size],\n\t\t       ap_info->ext_rate_set.body,\n\t\t       ap_info->ext_rate_set.size);\n\t\tap->rate_set.size += ap_info->ext_rate_set.size;\n\t}\n\tap->channel = ap_info->ds_parameter.channel;\n\tap->rssi = ap_info->rssi;\n\tap->sq = ap_info->sq;\n\tap->noise = ap_info->noise;\n\tap->capability = le16_to_cpu(ap_info->capability);\n\tsize = (ap_info->rsn.size <= RSN_IE_BODY_MAX) ?\n\t\tap_info->rsn.size : RSN_IE_BODY_MAX;\n\tif ((ap_info->rsn_mode & RSN_MODE_WPA2) &&\n\t    (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2)) {\n\t\tap->rsn_ie.id = RSN_INFO_ELEM_ID;\n\t\tap->rsn_ie.size = size;\n\t\tmemcpy(ap->rsn_ie.body, ap_info->rsn.body, size);\n\t} else if ((ap_info->rsn_mode & RSN_MODE_WPA) &&\n\t\t   (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA)) {\n\t\tap->wpa_ie.id = WPA_INFO_ELEM_ID;\n\t\tap->wpa_ie.size = size;\n\t\tmemcpy(ap->wpa_ie.body, ap_info->rsn.body, size);\n\t} else {\n\t\tap->rsn_ie.id = 0;\n\t\tap->rsn_ie.size = 0;\n\t\tap->wpa_ie.id = 0;\n\t\tap->wpa_ie.size = 0;\n\t}\n\n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\tif (is_connect_status(priv->connect_status)) {\n\t\tether_addr_copy(wrqu.ap_addr.sa_data, priv->current_ap.bssid);\n\t\tnetdev_dbg(priv->net_dev,\n\t\t\t   \"IWEVENT: connect bssid=%pM\\n\",\n\t\t\t   wrqu.ap_addr.sa_data);\n\t\twireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);\n\t}\n\tnetdev_dbg(priv->net_dev, \"Link AP\\n\"\n\t\t   \"- bssid=%pM\\n\"\n\t\t   \"- essid=%s\\n\"\n\t\t   \"- rate_set=%02X,%02X,%02X,%02X,%02X,%02X,%02X,%02X\\n\"\n\t\t   \"- channel=%d\\n\"\n\t\t   \"- rssi=%d\\n\"\n\t\t   \"- sq=%d\\n\"\n\t\t   \"- capability=%04X\\n\"\n\t\t   \"- rsn.mode=%d\\n\"\n\t\t   \"- rsn.size=%d\\n\"\n\t\t   \"- ext_rate_set_size=%d\\n\"\n\t\t   \"- rate_set_size=%d\\n\",\n\t\t   ap->bssid,\n\t\t   &ap->ssid.body[0],\n\t\t   ap->rate_set.body[0], ap->rate_set.body[1],\n\t\t   ap->rate_set.body[2], ap->rate_set.body[3],\n\t\t   ap->rate_set.body[4], ap->rate_set.body[5],\n\t\t   ap->rate_set.body[6], ap->rate_set.body[7],\n\t\t   ap->channel, ap->rssi, ap->sq, ap->capability,\n\t\t   ap_info->rsn_mode, ap_info->rsn.size,\n\t\t   ap_info->ext_rate_set.size, ap_info->rate_set.size);\n\n\treturn 0;\n}\n\nstatic u8 read_ie(unsigned char *bp, u8 max, u8 *body)\n{\n\tu8 size = (*(bp + 1) <= max) ? *(bp + 1) : max;\n\n\tmemcpy(body, bp + 2, size);\n\treturn size;\n}\n\nstatic int\nmichael_mic(u8 *key, u8 *data, unsigned int len, u8 priority, u8 *result)\n{\n\tu8 pad_data[4] = { priority, 0, 0, 0 };\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint ret;\n\n\ttfm = crypto_alloc_shash(\"michael_mic\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto err;\n\t}\n\n\tret = crypto_shash_setkey(tfm, key, MICHAEL_MIC_KEY_LEN);\n\tif (ret < 0)\n\t\tgoto err_free_tfm;\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_tfm;\n\t}\n\n\tdesc->tfm = tfm;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0)\n\t\tgoto err_free_desc;\n\n\t\n\t \n\n\tret = crypto_shash_update(desc, data, 12);\n\tif (ret < 0)\n\t\tgoto err_free_desc;\n\n\tret = crypto_shash_update(desc, pad_data, 4);\n\tif (ret < 0)\n\t\tgoto err_free_desc;\n\n\tret = crypto_shash_finup(desc, data + 12, len - 12, result);\n\nerr_free_desc:\n\tkfree_sensitive(desc);\n\nerr_free_tfm:\n\tcrypto_free_shash(tfm);\n\nerr:\n\treturn ret;\n}\n\nstatic\nint get_ap_information(struct ks_wlan_private *priv, struct ap_info *ap_info,\n\t\t       struct local_ap *ap)\n{\n\tunsigned char *bp;\n\tint bsize, offset;\n\n\tmemset(ap, 0, sizeof(struct local_ap));\n\n\tether_addr_copy(ap->bssid, ap_info->bssid);\n\tap->rssi = ap_info->rssi;\n\tap->sq = ap_info->sq;\n\tap->noise = ap_info->noise;\n\tap->capability = le16_to_cpu(ap_info->capability);\n\tap->channel = ap_info->ch_info;\n\n\tbp = ap_info->body;\n\tbsize = le16_to_cpu(ap_info->body_size);\n\toffset = 0;\n\n\twhile (bsize > offset) {\n\t\tswitch (*bp) {  \n\t\tcase WLAN_EID_SSID:\n\t\t\tap->ssid.size = read_ie(bp, IEEE80211_MAX_SSID_LEN,\n\t\t\t\t\t\tap->ssid.body);\n\t\t\tbreak;\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\t\tif ((*(bp + 1) + ap->rate_set.size) <=\n\t\t\t    RATE_SET_MAX_SIZE) {\n\t\t\t\tmemcpy(&ap->rate_set.body[ap->rate_set.size],\n\t\t\t\t       bp + 2, *(bp + 1));\n\t\t\t\tap->rate_set.size += *(bp + 1);\n\t\t\t} else {\n\t\t\t\tmemcpy(&ap->rate_set.body[ap->rate_set.size],\n\t\t\t\t       bp + 2,\n\t\t\t\t       RATE_SET_MAX_SIZE - ap->rate_set.size);\n\t\t\t\tap->rate_set.size +=\n\t\t\t\t    (RATE_SET_MAX_SIZE - ap->rate_set.size);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_EID_RSN:\n\t\t\tap->rsn_ie.id = *bp;\n\t\t\tap->rsn_ie.size = read_ie(bp, RSN_IE_BODY_MAX,\n\t\t\t\t\t\t  ap->rsn_ie.body);\n\t\t\tbreak;\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:  \n\t\t\t \n\t\t\tif (memcmp(bp + 2, CIPHER_ID_WPA_WEP40, 4) == 0) {\n\t\t\t\tap->wpa_ie.id = *bp;\n\t\t\t\tap->wpa_ie.size = read_ie(bp, RSN_IE_BODY_MAX,\n\t\t\t\t\t\t\t  ap->wpa_ie.body);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_EID_DS_PARAMS:\n\t\tcase WLAN_EID_FH_PARAMS:\n\t\tcase WLAN_EID_CF_PARAMS:\n\t\tcase WLAN_EID_TIM:\n\t\tcase WLAN_EID_IBSS_PARAMS:\n\t\tcase WLAN_EID_COUNTRY:\n\t\tcase WLAN_EID_ERP_INFO:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_err(priv->net_dev,\n\t\t\t\t   \"unknown Element ID=%d\\n\", *bp);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += 2;\t \n\t\toffset += *(bp + 1);\t \n\t\tbp += (*(bp + 1) + 2);\t \n\t}\n\n\treturn 0;\n}\n\nstatic\nint hostif_data_indication_wpa(struct ks_wlan_private *priv,\n\t\t\t       unsigned short auth_type)\n{\n\tstruct ether_hdr *eth_hdr;\n\tunsigned short eth_proto;\n\tunsigned char recv_mic[MICHAEL_MIC_LEN];\n\tchar buf[128];\n\tunsigned long now;\n\tstruct mic_failure *mic_failure;\n\tu8 mic[MICHAEL_MIC_LEN];\n\tunion iwreq_data wrqu;\n\tunsigned int key_index = auth_type - 1;\n\tstruct wpa_key *key = &priv->wpa.key[key_index];\n\n\teth_hdr = (struct ether_hdr *)(priv->rxp);\n\teth_proto = ntohs(eth_hdr->h_proto);\n\n\tif (eth_hdr->h_dest_snap != eth_hdr->h_source_snap) {\n\t\tnetdev_err(priv->net_dev, \"invalid data format\\n\");\n\t\tpriv->nstats.rx_errors++;\n\t\treturn -EINVAL;\n\t}\n\tif (((auth_type == TYPE_PMK1 &&\n\t      priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) ||\n\t     (auth_type == TYPE_GMK1 &&\n\t      priv->wpa.group_suite == IW_AUTH_CIPHER_TKIP) ||\n\t     (auth_type == TYPE_GMK2 &&\n\t      priv->wpa.group_suite == IW_AUTH_CIPHER_TKIP)) &&\n\t    key->key_len) {\n\t\tint ret;\n\n\t\tnetdev_dbg(priv->net_dev, \"TKIP: protocol=%04X: size=%u\\n\",\n\t\t\t   eth_proto, priv->rx_size);\n\t\t \n\t\tmemcpy(&recv_mic[0],\n\t\t       (priv->rxp) + ((priv->rx_size) - sizeof(recv_mic)),\n\t\t       sizeof(recv_mic));\n\t\tpriv->rx_size = priv->rx_size - sizeof(recv_mic);\n\n\t\tret = michael_mic(key->rx_mic_key, priv->rxp, priv->rx_size,\n\t\t\t\t  0, mic);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (memcmp(mic, recv_mic, sizeof(mic)) != 0) {\n\t\t\tnow = jiffies;\n\t\t\tmic_failure = &priv->wpa.mic_failure;\n\t\t\t \n\t\t\tif (mic_failure->last_failure_time &&\n\t\t\t    (now - mic_failure->last_failure_time) / HZ >= 60) {\n\t\t\t\tmic_failure->failure = 0;\n\t\t\t}\n\t\t\tnetdev_err(priv->net_dev, \"MIC FAILURE\\n\");\n\t\t\tif (mic_failure->failure == 0) {\n\t\t\t\tmic_failure->failure = 1;\n\t\t\t\tmic_failure->counter = 0;\n\t\t\t} else if (mic_failure->failure == 1) {\n\t\t\t\tmic_failure->failure = 2;\n\t\t\t\tmic_failure->counter =\n\t\t\t\t\t(u16)((now - mic_failure->last_failure_time) / HZ);\n\t\t\t\t \n\t\t\t\tif (!mic_failure->counter)\n\t\t\t\t\tmic_failure->counter = 1;\n\t\t\t}\n\t\t\tpriv->wpa.mic_failure.last_failure_time = now;\n\n\t\t\t \n\t\t\tsprintf(buf,\n\t\t\t\t\"MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr=%pM)\",\n\t\t\t\tkey_index,\n\t\t\t\teth_hdr->h_dest[0] & 0x01 ? \"broad\" : \"uni\",\n\t\t\t\teth_hdr->h_source);\n\t\t\tmemset(&wrqu, 0, sizeof(wrqu));\n\t\t\twrqu.data.length = strlen(buf);\n\t\t\twireless_send_event(priv->net_dev, IWEVCUSTOM, &wrqu,\n\t\t\t\t\t    buf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic\nvoid hostif_data_indication(struct ks_wlan_private *priv)\n{\n\tunsigned int rx_ind_size;\t \n\tstruct sk_buff *skb;\n\tu16 auth_type;\n\tunsigned char temp[256];\n\tstruct ether_hdr *eth_hdr;\n\tstruct ieee802_1x_hdr *aa1x_hdr;\n\tsize_t size;\n\tint ret;\n\n\t \n\tif (priv->rx_size <= ETH_HLEN) {\n\t\tpriv->nstats.rx_errors++;\n\t\treturn;\n\t}\n\n\tauth_type = get_word(priv);\t \n\tget_word(priv);\t \n\n\teth_hdr = (struct ether_hdr *)(priv->rxp);\n\n\t \n\tif (ether_addr_equal(&priv->eth_addr[0], eth_hdr->h_source)) {\n\t\tnetdev_err(priv->net_dev, \"invalid : source is own mac address !!\\n\");\n\t\tnetdev_err(priv->net_dev, \"eth_hdrernet->h_dest=%pM\\n\", eth_hdr->h_source);\n\t\tpriv->nstats.rx_errors++;\n\t\treturn;\n\t}\n\n\t \n\tif (auth_type != TYPE_DATA && priv->wpa.rsn_enabled) {\n\t\tret = hostif_data_indication_wpa(priv, auth_type);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif ((priv->connect_status & FORCE_DISCONNECT) ||\n\t    priv->wpa.mic_failure.failure == 2) {\n\t\treturn;\n\t}\n\n\t \n\tswitch (*(priv->rxp + 12)) {\n\tcase LLC_SAP_SNAP:\n\t\trx_ind_size = priv->rx_size - 6;\n\t\tskb = dev_alloc_skb(rx_ind_size);\n\t\tif (!skb) {\n\t\t\tpriv->nstats.rx_dropped++;\n\t\t\treturn;\n\t\t}\n\t\tnetdev_dbg(priv->net_dev, \"SNAP, rx_ind_size = %d\\n\",\n\t\t\t   rx_ind_size);\n\n\t\tsize = ETH_ALEN * 2;\n\t\tskb_put_data(skb, priv->rxp, size);\n\n\t\t \n\n\t\tsize = rx_ind_size - (ETH_ALEN * 2);\n\t\tskb_put_data(skb, &eth_hdr->h_proto, size);\n\n\t\taa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + ETHER_HDR_SIZE);\n\t\tbreak;\n\tcase LLC_SAP_NETBEUI:\n\t\trx_ind_size = (priv->rx_size + 2);\n\t\tskb = dev_alloc_skb(rx_ind_size);\n\t\tif (!skb) {\n\t\t\tpriv->nstats.rx_dropped++;\n\t\t\treturn;\n\t\t}\n\t\tnetdev_dbg(priv->net_dev, \"NETBEUI/NetBIOS rx_ind_size=%d\\n\",\n\t\t\t   rx_ind_size);\n\n\t\t \n\t\tskb_put_data(skb, priv->rxp, 12);\n\n\t\t \n\t\ttemp[0] = (((rx_ind_size - 12) >> 8) & 0xff);\n\t\ttemp[1] = ((rx_ind_size - 12) & 0xff);\n\t\tskb_put_data(skb, temp, 2);\n\n\t\t \n\t\tskb_put_data(skb, priv->rxp + 12, rx_ind_size - 14);\n\n\t\taa1x_hdr = (struct ieee802_1x_hdr *)(priv->rxp + 14);\n\t\tbreak;\n\tdefault:\t \n\t\tnetdev_err(priv->net_dev, \"invalid data format\\n\");\n\t\tpriv->nstats.rx_errors++;\n\t\treturn;\n\t}\n\n\tif (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY &&\n\t    priv->wpa.rsn_enabled)\n\t\tatomic_set(&priv->psstatus.snooze_guard, 1);\n\n\t \n\tskb->dev = priv->net_dev;\n\tskb->protocol = eth_type_trans(skb, skb->dev);\n\tpriv->nstats.rx_packets++;\n\tpriv->nstats.rx_bytes += rx_ind_size;\n\tnetif_rx(skb);\n}\n\nstatic\nvoid hostif_mib_get_confirm(struct ks_wlan_private *priv)\n{\n\tstruct net_device *dev = priv->net_dev;\n\tu32 mib_status;\n\tu32 mib_attribute;\n\n\tmib_status = get_dword(priv);\n\tmib_attribute = get_dword(priv);\n\tget_word(priv);  \n\tget_word(priv);  \n\n\tif (mib_status) {\n\t\tnetdev_err(priv->net_dev, \"attribute=%08X, status=%08X\\n\",\n\t\t\t   mib_attribute, mib_status);\n\t\treturn;\n\t}\n\n\tswitch (mib_attribute) {\n\tcase DOT11_MAC_ADDRESS:\n\t\thostif_sme_enqueue(priv, SME_GET_MAC_ADDRESS);\n\t\tether_addr_copy(priv->eth_addr, priv->rxp);\n\t\tpriv->mac_address_valid = true;\n\t\teth_hw_addr_set(dev, priv->eth_addr);\n\t\tnetdev_info(dev, \"MAC ADDRESS = %pM\\n\", priv->eth_addr);\n\t\tbreak;\n\tcase DOT11_PRODUCT_VERSION:\n\t\tpriv->version_size = priv->rx_size;\n\t\tmemcpy(priv->firmware_version, priv->rxp, priv->rx_size);\n\t\tpriv->firmware_version[priv->rx_size] = '\\0';\n\t\tnetdev_info(dev, \"firmware ver. = %s\\n\",\n\t\t\t    priv->firmware_version);\n\t\thostif_sme_enqueue(priv, SME_GET_PRODUCT_VERSION);\n\t\t \n\t\tcomplete(&priv->confirm_wait);\n\t\tbreak;\n\tcase LOCAL_GAIN:\n\t\tmemcpy(&priv->gain, priv->rxp, sizeof(priv->gain));\n\t\tnetdev_dbg(priv->net_dev, \"tx_mode=%d, rx_mode=%d, tx_gain=%d, rx_gain=%d\\n\",\n\t\t\t   priv->gain.tx_mode, priv->gain.rx_mode,\n\t\t\t   priv->gain.tx_gain, priv->gain.rx_gain);\n\t\tbreak;\n\tcase LOCAL_EEPROM_SUM:\n\t\tmemcpy(&priv->eeprom_sum, priv->rxp, sizeof(priv->eeprom_sum));\n\t\tif (priv->eeprom_sum.type != 0 &&\n\t\t    priv->eeprom_sum.type != 1) {\n\t\t\tnetdev_err(dev, \"LOCAL_EEPROM_SUM error!\\n\");\n\t\t\treturn;\n\t\t}\n\t\tpriv->eeprom_checksum = (priv->eeprom_sum.type == 0) ?\n\t\t\t\t\t EEPROM_CHECKSUM_NONE :\n\t\t\t\t\t (priv->eeprom_sum.result == 0) ?\n\t\t\t\t\t EEPROM_NG : EEPROM_OK;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(priv->net_dev, \"mib_attribute=%08x\\n\",\n\t\t\t   (unsigned int)mib_attribute);\n\t\tbreak;\n\t}\n}\n\nstatic\nvoid hostif_mib_set_confirm(struct ks_wlan_private *priv)\n{\n\tu32 mib_status;\n\tu32 mib_attribute;\n\n\tmib_status = get_dword(priv);\n\tmib_attribute = get_dword(priv);\n\n\tif (mib_status) {\n\t\t \n\t\tnetdev_err(priv->net_dev, \"error :: attribute=%08X, status=%08X\\n\",\n\t\t\t   mib_attribute, mib_status);\n\t}\n\n\tswitch (mib_attribute) {\n\tcase DOT11_RTS_THRESHOLD:\n\t\thostif_sme_enqueue(priv, SME_RTS_THRESHOLD_CONFIRM);\n\t\tbreak;\n\tcase DOT11_FRAGMENTATION_THRESHOLD:\n\t\thostif_sme_enqueue(priv, SME_FRAGMENTATION_THRESHOLD_CONFIRM);\n\t\tbreak;\n\tcase DOT11_WEP_DEFAULT_KEY_ID:\n\t\tif (!priv->wpa.wpa_enabled)\n\t\t\thostif_sme_enqueue(priv, SME_WEP_INDEX_CONFIRM);\n\t\tbreak;\n\tcase DOT11_WEP_DEFAULT_KEY_VALUE1:\n\t\tif (priv->wpa.rsn_enabled)\n\t\t\thostif_sme_enqueue(priv, SME_SET_PMK_TSC);\n\t\telse\n\t\t\thostif_sme_enqueue(priv, SME_WEP_KEY1_CONFIRM);\n\t\tbreak;\n\tcase DOT11_WEP_DEFAULT_KEY_VALUE2:\n\t\tif (priv->wpa.rsn_enabled)\n\t\t\thostif_sme_enqueue(priv, SME_SET_GMK1_TSC);\n\t\telse\n\t\t\thostif_sme_enqueue(priv, SME_WEP_KEY2_CONFIRM);\n\t\tbreak;\n\tcase DOT11_WEP_DEFAULT_KEY_VALUE3:\n\t\tif (priv->wpa.rsn_enabled)\n\t\t\thostif_sme_enqueue(priv, SME_SET_GMK2_TSC);\n\t\telse\n\t\t\thostif_sme_enqueue(priv, SME_WEP_KEY3_CONFIRM);\n\t\tbreak;\n\tcase DOT11_WEP_DEFAULT_KEY_VALUE4:\n\t\tif (!priv->wpa.rsn_enabled)\n\t\t\thostif_sme_enqueue(priv, SME_WEP_KEY4_CONFIRM);\n\t\tbreak;\n\tcase DOT11_PRIVACY_INVOKED:\n\t\tif (!priv->wpa.rsn_enabled)\n\t\t\thostif_sme_enqueue(priv, SME_WEP_FLAG_CONFIRM);\n\t\tbreak;\n\tcase DOT11_RSN_ENABLED:\n\t\thostif_sme_enqueue(priv, SME_RSN_ENABLED_CONFIRM);\n\t\tbreak;\n\tcase LOCAL_RSN_MODE:\n\t\thostif_sme_enqueue(priv, SME_RSN_MODE_CONFIRM);\n\t\tbreak;\n\tcase LOCAL_MULTICAST_ADDRESS:\n\t\thostif_sme_enqueue(priv, SME_MULTICAST_REQUEST);\n\t\tbreak;\n\tcase LOCAL_MULTICAST_FILTER:\n\t\thostif_sme_enqueue(priv, SME_MULTICAST_CONFIRM);\n\t\tbreak;\n\tcase LOCAL_CURRENTADDRESS:\n\t\tpriv->mac_address_valid = true;\n\t\tbreak;\n\tcase DOT11_RSN_CONFIG_MULTICAST_CIPHER:\n\t\thostif_sme_enqueue(priv, SME_RSN_MCAST_CONFIRM);\n\t\tbreak;\n\tcase DOT11_RSN_CONFIG_UNICAST_CIPHER:\n\t\thostif_sme_enqueue(priv, SME_RSN_UCAST_CONFIRM);\n\t\tbreak;\n\tcase DOT11_RSN_CONFIG_AUTH_SUITE:\n\t\thostif_sme_enqueue(priv, SME_RSN_AUTH_CONFIRM);\n\t\tbreak;\n\tcase DOT11_GMK1_TSC:\n\t\tif (atomic_read(&priv->psstatus.snooze_guard))\n\t\t\tatomic_set(&priv->psstatus.snooze_guard, 0);\n\t\tbreak;\n\tcase DOT11_GMK2_TSC:\n\t\tif (atomic_read(&priv->psstatus.snooze_guard))\n\t\t\tatomic_set(&priv->psstatus.snooze_guard, 0);\n\t\tbreak;\n\tcase DOT11_PMK_TSC:\n\tcase LOCAL_PMK:\n\tcase LOCAL_GAIN:\n\tcase LOCAL_WPS_ENABLE:\n\tcase LOCAL_WPS_PROBE_REQ:\n\tcase LOCAL_REGION:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic\nvoid hostif_power_mgmt_confirm(struct ks_wlan_private *priv)\n{\n\tif (priv->reg.power_mgmt > POWER_MGMT_ACTIVE &&\n\t    priv->reg.operation_mode == MODE_INFRASTRUCTURE) {\n\t\tatomic_set(&priv->psstatus.confirm_wait, 0);\n\t\tpriv->dev_state = DEVICE_STATE_SLEEP;\n\t\tks_wlan_hw_power_save(priv);\n\t} else {\n\t\tpriv->dev_state = DEVICE_STATE_READY;\n\t}\n}\n\nstatic\nvoid hostif_sleep_confirm(struct ks_wlan_private *priv)\n{\n\tatomic_set(&priv->sleepstatus.doze_request, 1);\n\tqueue_delayed_work(priv->wq, &priv->rw_dwork, 1);\n}\n\nstatic\nvoid hostif_start_confirm(struct ks_wlan_private *priv)\n{\n\tunion iwreq_data wrqu;\n\n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\tif (is_connect_status(priv->connect_status)) {\n\t\teth_zero_addr(wrqu.ap_addr.sa_data);\n\t\twireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);\n\t}\n\tnetdev_dbg(priv->net_dev, \" scan_ind_count=%d\\n\", priv->scan_ind_count);\n\thostif_sme_enqueue(priv, SME_START_CONFIRM);\n}\n\nstatic\nvoid hostif_connect_indication(struct ks_wlan_private *priv)\n{\n\tu16 connect_code;\n\tunsigned int tmp = 0;\n\tunsigned int old_status = priv->connect_status;\n\tstruct net_device *netdev = priv->net_dev;\n\tunion iwreq_data wrqu0;\n\n\tconnect_code = get_word(priv);\n\n\tswitch (connect_code) {\n\tcase RESULT_CONNECT:\n\t\tif (!(priv->connect_status & FORCE_DISCONNECT))\n\t\t\tnetif_carrier_on(netdev);\n\t\ttmp = FORCE_DISCONNECT & priv->connect_status;\n\t\tpriv->connect_status = tmp + CONNECT_STATUS;\n\t\tbreak;\n\tcase RESULT_DISCONNECT:\n\t\tnetif_carrier_off(netdev);\n\t\ttmp = FORCE_DISCONNECT & priv->connect_status;\n\t\tpriv->connect_status = tmp + DISCONNECT_STATUS;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_dbg(priv->net_dev, \"unknown connect_code=%d :: scan_ind_count=%d\\n\",\n\t\t\t   connect_code, priv->scan_ind_count);\n\t\tnetif_carrier_off(netdev);\n\t\ttmp = FORCE_DISCONNECT & priv->connect_status;\n\t\tpriv->connect_status = tmp + DISCONNECT_STATUS;\n\t\tbreak;\n\t}\n\n\tget_current_ap(priv, (struct link_ap_info *)priv->rxp);\n\tif (is_connect_status(priv->connect_status) &&\n\t    is_disconnect_status(old_status)) {\n\t\t \n\t\tatomic_set(&priv->psstatus.snooze_guard, 0);\n\t\tatomic_set(&priv->psstatus.confirm_wait, 0);\n\t}\n\tks_wlan_do_power_save(priv);\n\n\twrqu0.data.length = 0;\n\twrqu0.data.flags = 0;\n\twrqu0.ap_addr.sa_family = ARPHRD_ETHER;\n\tif (is_disconnect_status(priv->connect_status) &&\n\t    is_connect_status(old_status)) {\n\t\teth_zero_addr(wrqu0.ap_addr.sa_data);\n\t\tnetdev_dbg(priv->net_dev, \"disconnect :: scan_ind_count=%d\\n\",\n\t\t\t   priv->scan_ind_count);\n\t\twireless_send_event(netdev, SIOCGIWAP, &wrqu0, NULL);\n\t}\n\tpriv->scan_ind_count = 0;\n}\n\nstatic\nvoid hostif_scan_indication(struct ks_wlan_private *priv)\n{\n\tint i;\n\tstruct ap_info *ap_info;\n\n\tnetdev_dbg(priv->net_dev,\n\t\t   \"scan_ind_count = %d\\n\", priv->scan_ind_count);\n\tap_info = (struct ap_info *)(priv->rxp);\n\n\tif (priv->scan_ind_count) {\n\t\t \n\t\tfor (i = 0; i < priv->aplist.size; i++) {\n\t\t\tu8 *bssid = priv->aplist.ap[i].bssid;\n\n\t\t\tif (ether_addr_equal(ap_info->bssid, bssid))\n\t\t\t\tcontinue;\n\n\t\t\tif (ap_info->frame_type == IEEE80211_STYPE_PROBE_RESP)\n\t\t\t\tget_ap_information(priv, ap_info,\n\t\t\t\t\t\t   &priv->aplist.ap[i]);\n\t\t\treturn;\n\t\t}\n\t}\n\tpriv->scan_ind_count++;\n\tif (priv->scan_ind_count < LOCAL_APLIST_MAX + 1) {\n\t\tnetdev_dbg(priv->net_dev, \" scan_ind_count=%d :: aplist.size=%d\\n\",\n\t\t\t   priv->scan_ind_count, priv->aplist.size);\n\t\tget_ap_information(priv, (struct ap_info *)(priv->rxp),\n\t\t\t\t   &priv->aplist.ap[priv->scan_ind_count - 1]);\n\t\tpriv->aplist.size = priv->scan_ind_count;\n\t} else {\n\t\tnetdev_dbg(priv->net_dev, \" count over :: scan_ind_count=%d\\n\",\n\t\t\t   priv->scan_ind_count);\n\t}\n}\n\nstatic\nvoid hostif_stop_confirm(struct ks_wlan_private *priv)\n{\n\tunsigned int tmp = 0;\n\tunsigned int old_status = priv->connect_status;\n\tstruct net_device *netdev = priv->net_dev;\n\tunion iwreq_data wrqu0;\n\n\tif (priv->dev_state == DEVICE_STATE_SLEEP)\n\t\tpriv->dev_state = DEVICE_STATE_READY;\n\n\t \n\tif (is_connect_status(priv->connect_status)) {\n\t\tnetif_carrier_off(netdev);\n\t\ttmp = FORCE_DISCONNECT & priv->connect_status;\n\t\tpriv->connect_status = tmp | DISCONNECT_STATUS;\n\t\tnetdev_info(netdev, \"IWEVENT: disconnect\\n\");\n\n\t\twrqu0.data.length = 0;\n\t\twrqu0.data.flags = 0;\n\t\twrqu0.ap_addr.sa_family = ARPHRD_ETHER;\n\t\tif (is_disconnect_status(priv->connect_status) &&\n\t\t    is_connect_status(old_status)) {\n\t\t\teth_zero_addr(wrqu0.ap_addr.sa_data);\n\t\t\tnetdev_info(netdev, \"IWEVENT: disconnect\\n\");\n\t\t\twireless_send_event(netdev, SIOCGIWAP, &wrqu0, NULL);\n\t\t}\n\t\tpriv->scan_ind_count = 0;\n\t}\n\n\thostif_sme_enqueue(priv, SME_STOP_CONFIRM);\n}\n\nstatic\nvoid hostif_ps_adhoc_set_confirm(struct ks_wlan_private *priv)\n{\n\tpriv->infra_status = 0;\t \n\thostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);\n}\n\nstatic\nvoid hostif_infrastructure_set_confirm(struct ks_wlan_private *priv)\n{\n\tget_word(priv);  \n\tpriv->infra_status = 1;\t \n\thostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);\n}\n\nstatic\nvoid hostif_adhoc_set_confirm(struct ks_wlan_private *priv)\n{\n\tpriv->infra_status = 1;\t \n\thostif_sme_enqueue(priv, SME_MODE_SET_CONFIRM);\n}\n\nstatic\nvoid hostif_associate_indication(struct ks_wlan_private *priv)\n{\n\tstruct association_request *assoc_req;\n\tstruct association_response *assoc_resp;\n\tunsigned char *pb;\n\tunion iwreq_data wrqu;\n\tchar buf[IW_CUSTOM_MAX];\n\tchar *pbuf = &buf[0];\n\tint i;\n\n\tstatic const char associnfo_leader0[] = \"ASSOCINFO(ReqIEs=\";\n\tstatic const char associnfo_leader1[] = \" RespIEs=\";\n\n\tassoc_req = (struct association_request *)(priv->rxp);\n\tassoc_resp = (struct association_response *)(assoc_req + 1);\n\tpb = (unsigned char *)(assoc_resp + 1);\n\n\tmemset(&wrqu, 0, sizeof(wrqu));\n\tmemcpy(pbuf, associnfo_leader0, sizeof(associnfo_leader0) - 1);\n\twrqu.data.length += sizeof(associnfo_leader0) - 1;\n\tpbuf += sizeof(associnfo_leader0) - 1;\n\n\tfor (i = 0; i < le16_to_cpu(assoc_req->req_ies_size); i++)\n\t\tpbuf += sprintf(pbuf, \"%02x\", *(pb + i));\n\twrqu.data.length += (le16_to_cpu(assoc_req->req_ies_size)) * 2;\n\n\tmemcpy(pbuf, associnfo_leader1, sizeof(associnfo_leader1) - 1);\n\twrqu.data.length += sizeof(associnfo_leader1) - 1;\n\tpbuf += sizeof(associnfo_leader1) - 1;\n\n\tpb += le16_to_cpu(assoc_req->req_ies_size);\n\tfor (i = 0; i < le16_to_cpu(assoc_resp->resp_ies_size); i++)\n\t\tpbuf += sprintf(pbuf, \"%02x\", *(pb + i));\n\twrqu.data.length += (le16_to_cpu(assoc_resp->resp_ies_size)) * 2;\n\n\tpbuf += sprintf(pbuf, \")\");\n\twrqu.data.length += 1;\n\n\twireless_send_event(priv->net_dev, IWEVCUSTOM, &wrqu, buf);\n}\n\nstatic\nvoid hostif_bss_scan_confirm(struct ks_wlan_private *priv)\n{\n\tu32 result_code;\n\tstruct net_device *dev = priv->net_dev;\n\tunion iwreq_data wrqu;\n\n\tresult_code = get_dword(priv);\n\tnetdev_dbg(priv->net_dev, \"result=%d :: scan_ind_count=%d\\n\",\n\t\t   result_code, priv->scan_ind_count);\n\n\tpriv->sme_i.sme_flag &= ~SME_AP_SCAN;\n\thostif_sme_enqueue(priv, SME_BSS_SCAN_CONFIRM);\n\n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\twireless_send_event(dev, SIOCGIWSCAN, &wrqu, NULL);\n\tpriv->scan_ind_count = 0;\n}\n\nstatic\nvoid hostif_phy_information_confirm(struct ks_wlan_private *priv)\n{\n\tstruct iw_statistics *wstats = &priv->wstats;\n\tu8 rssi, signal;\n\tu8 link_speed;\n\tu32 transmitted_frame_count, received_fragment_count;\n\tu32 failed_count, fcs_error_count;\n\n\trssi = get_byte(priv);\n\tsignal = get_byte(priv);\n\tget_byte(priv);  \n\tlink_speed = get_byte(priv);\n\ttransmitted_frame_count = get_dword(priv);\n\treceived_fragment_count = get_dword(priv);\n\tfailed_count = get_dword(priv);\n\tfcs_error_count = get_dword(priv);\n\n\tnetdev_dbg(priv->net_dev, \"phyinfo confirm rssi=%d signal=%d\\n\",\n\t\t   rssi, signal);\n\tpriv->current_rate = (link_speed & RATE_MASK);\n\twstats->qual.qual = signal;\n\twstats->qual.level = 256 - rssi;\n\twstats->qual.noise = 0;\t \n\twstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\n\n\tnetdev_dbg(priv->net_dev, \"\\n    rssi=%u\\n\"\n\t\t   \"    signal=%u\\n\"\n\t\t   \"    link_speed=%ux500Kbps\\n\"\n\t\t   \"    transmitted_frame_count=%u\\n\"\n\t\t   \"    received_fragment_count=%u\\n\"\n\t\t   \"    failed_count=%u\\n\"\n\t\t   \"    fcs_error_count=%u\\n\",\n\t\t   rssi, signal, link_speed, transmitted_frame_count,\n\t\t   received_fragment_count, failed_count, fcs_error_count);\n\t \n\tcomplete(&priv->confirm_wait);\n}\n\nstatic\nvoid hostif_mic_failure_confirm(struct ks_wlan_private *priv)\n{\n\tnetdev_dbg(priv->net_dev, \"mic_failure=%u\\n\",\n\t\t   priv->wpa.mic_failure.failure);\n\thostif_sme_enqueue(priv, SME_MIC_FAILURE_CONFIRM);\n}\n\nstatic\nvoid hostif_event_check(struct ks_wlan_private *priv)\n{\n\tu16 event;\n\n\tevent = get_word(priv);\n\tswitch (event) {\n\tcase HIF_DATA_IND:\n\t\thostif_data_indication(priv);\n\t\tbreak;\n\tcase HIF_MIB_GET_CONF:\n\t\thostif_mib_get_confirm(priv);\n\t\tbreak;\n\tcase HIF_MIB_SET_CONF:\n\t\thostif_mib_set_confirm(priv);\n\t\tbreak;\n\tcase HIF_POWER_MGMT_CONF:\n\t\thostif_power_mgmt_confirm(priv);\n\t\tbreak;\n\tcase HIF_SLEEP_CONF:\n\t\thostif_sleep_confirm(priv);\n\t\tbreak;\n\tcase HIF_START_CONF:\n\t\thostif_start_confirm(priv);\n\t\tbreak;\n\tcase HIF_CONNECT_IND:\n\t\thostif_connect_indication(priv);\n\t\tbreak;\n\tcase HIF_STOP_CONF:\n\t\thostif_stop_confirm(priv);\n\t\tbreak;\n\tcase HIF_PS_ADH_SET_CONF:\n\t\thostif_ps_adhoc_set_confirm(priv);\n\t\tbreak;\n\tcase HIF_INFRA_SET_CONF:\n\tcase HIF_INFRA_SET2_CONF:\n\t\thostif_infrastructure_set_confirm(priv);\n\t\tbreak;\n\tcase HIF_ADH_SET_CONF:\n\tcase HIF_ADH_SET2_CONF:\n\t\thostif_adhoc_set_confirm(priv);\n\t\tbreak;\n\tcase HIF_ASSOC_INFO_IND:\n\t\thostif_associate_indication(priv);\n\t\tbreak;\n\tcase HIF_MIC_FAILURE_CONF:\n\t\thostif_mic_failure_confirm(priv);\n\t\tbreak;\n\tcase HIF_SCAN_CONF:\n\t\thostif_bss_scan_confirm(priv);\n\t\tbreak;\n\tcase HIF_PHY_INFO_CONF:\n\tcase HIF_PHY_INFO_IND:\n\t\thostif_phy_information_confirm(priv);\n\t\tbreak;\n\tcase HIF_SCAN_IND:\n\t\thostif_scan_indication(priv);\n\t\tbreak;\n\tcase HIF_AP_SET_CONF:\n\tdefault:\n\t\tnetdev_err(priv->net_dev, \"undefined event[%04X]\\n\", event);\n\t\t \n\t\tcomplete(&priv->confirm_wait);\n\t\tbreak;\n\t}\n\n\t \n\tpriv->hostt.buff[priv->hostt.qtail] = event;\n\tpriv->hostt.qtail = (priv->hostt.qtail + 1) % SME_EVENT_BUFF_SIZE;\n}\n\n \nstatic void *hostif_generic_request(size_t size, int event)\n{\n\tstruct hostif_hdr *p;\n\n\tp = kzalloc(hif_align_size(size), GFP_ATOMIC);\n\tif (!p)\n\t\treturn NULL;\n\n\tp->size = cpu_to_le16(size - sizeof(p->size));\n\tp->event = cpu_to_le16(event);\n\n\treturn p;\n}\n\nint hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *skb)\n{\n\tunsigned int skb_len = 0;\n\tunsigned char *buffer = NULL;\n\tunsigned int length = 0;\n\tstruct hostif_data_request *pp;\n\tunsigned char *p;\n\tunsigned short eth_proto;\n\tstruct ether_hdr *eth_hdr;\n\tunsigned short keyinfo = 0;\n\tstruct ieee802_1x_hdr *aa1x_hdr;\n\tstruct wpa_eapol_key *eap_key;\n\tstruct ethhdr *eth;\n\tsize_t size;\n\tint ret;\n\n\tskb_len = skb->len;\n\tif (skb_len > ETH_FRAME_LEN) {\n\t\tnetdev_err(priv->net_dev, \"bad length skb_len=%d\\n\", skb_len);\n\t\tret = -EOVERFLOW;\n\t\tgoto err_kfree_skb;\n\t}\n\n\tif (is_disconnect_status(priv->connect_status) ||\n\t    (priv->connect_status & FORCE_DISCONNECT) ||\n\t    priv->wpa.mic_failure.stop) {\n\t\tif (netif_queue_stopped(priv->net_dev))\n\t\t\tnetif_wake_queue(priv->net_dev);\n\n\t\tdev_kfree_skb(skb);\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (atomic_read(&priv->psstatus.status) == PS_SNOOZE) {\n\t\tif (!netif_queue_stopped(priv->net_dev))\n\t\t\tnetif_stop_queue(priv->net_dev);\n\t}\n\n\tsize = sizeof(*pp) + 6 + skb_len + 8;\n\tpp = kmalloc(hif_align_size(size), GFP_ATOMIC);\n\tif (!pp) {\n\t\tret = -ENOMEM;\n\t\tgoto err_kfree_skb;\n\t}\n\n\tp = (unsigned char *)pp->data;\n\n\tbuffer = skb->data;\n\tlength = skb->len;\n\n\t \n\teth = (struct ethhdr *)skb->data;\n\tif (!ether_addr_equal(&priv->eth_addr[0], eth->h_source)) {\n\t\tnetdev_err(priv->net_dev,\n\t\t\t   \"Invalid mac address: ethernet->h_source=%pM\\n\",\n\t\t\t   eth->h_source);\n\t\tret = -ENXIO;\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tsize = ETH_ALEN * 2;\n\tmemcpy(p, buffer, size);\n\tp += size;\n\tbuffer += size;\n\tlength -= size;\n\n\t \n\tif (*(buffer + 1) + (*buffer << 8) > 1500) {\n\t\t \n\t\t \n\t\t*p++ = 0xAA;\t \n\t\t*p++ = 0xAA;\t \n\t\t*p++ = 0x03;\t \n\t\t*p++ = 0x00;\t \n\t\t*p++ = 0x00;\t \n\t\t*p++ = 0x00;\t \n\t\tskb_len += 6;\n\t} else {\n\t\t \n\t\tbuffer += 2;\n\t\tlength -= 2;\n\t\tskb_len -= 2;\n\t}\n\n\t \n\tmemcpy(p, buffer, length);\n\n\tp += length;\n\n\t \n\teth_hdr = (struct ether_hdr *)&pp->data[0];\n\teth_proto = ntohs(eth_hdr->h_proto);\n\n\t \n\tif (eth_proto == ETH_P_PAE &&\n\t    priv->wpa.mic_failure.failure > 0) {\n\t\taa1x_hdr = (struct ieee802_1x_hdr *)(eth_hdr + 1);\n\t\tif (aa1x_hdr->type == IEEE802_1X_TYPE_EAPOL_KEY) {\n\t\t\teap_key = (struct wpa_eapol_key *)(aa1x_hdr + 1);\n\t\t\tkeyinfo = ntohs(eap_key->key_info);\n\t\t}\n\t}\n\n\tif (priv->wpa.rsn_enabled && priv->wpa.key[0].key_len) {\n\t\t \n\t\tif (eth_proto == ETH_P_PAE &&\n\t\t    priv->wpa.key[1].key_len == 0 &&\n\t\t    priv->wpa.key[2].key_len == 0 &&\n\t\t    priv->wpa.key[3].key_len == 0) {\n\t\t\tpp->auth_type = cpu_to_le16(TYPE_AUTH);\n\t\t} else {\n\t\t\tif (priv->wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {\n\t\t\t\tu8 mic[MICHAEL_MIC_LEN];\n\n\t\t\t\tret = michael_mic(priv->wpa.key[0].tx_mic_key,\n\t\t\t\t\t\t  &pp->data[0], skb_len,\n\t\t\t\t\t\t  0, mic);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto err_kfree;\n\n\t\t\t\tmemcpy(p, mic, sizeof(mic));\n\t\t\t\tlength += sizeof(mic);\n\t\t\t\tskb_len += sizeof(mic);\n\t\t\t\tp += sizeof(mic);\n\t\t\t\tpp->auth_type =\n\t\t\t\t    cpu_to_le16(TYPE_DATA);\n\t\t\t} else if (priv->wpa.pairwise_suite ==\n\t\t\t\t   IW_AUTH_CIPHER_CCMP) {\n\t\t\t\tpp->auth_type =\n\t\t\t\t    cpu_to_le16(TYPE_DATA);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (eth_proto == ETH_P_PAE)\n\t\t\tpp->auth_type = cpu_to_le16(TYPE_AUTH);\n\t\telse\n\t\t\tpp->auth_type = cpu_to_le16(TYPE_DATA);\n\t}\n\n\t \n\tpp->header.size =\n\t    cpu_to_le16((sizeof(*pp) - sizeof(pp->header.size) + skb_len));\n\tpp->header.event = cpu_to_le16(HIF_DATA_REQ);\n\n\t \n\tret = ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp) + skb_len),\n\t\t\t    send_packet_complete, skb);\n\n\t \n\tif (eth_proto == ETH_P_PAE &&\n\t    priv->wpa.mic_failure.failure > 0) {\n\t\tif (keyinfo & WPA_KEY_INFO_ERROR &&\n\t\t    keyinfo & WPA_KEY_INFO_REQUEST) {\n\t\t\tnetdev_err(priv->net_dev,\n\t\t\t\t   \"MIC ERROR Report SET : %04X\\n\", keyinfo);\n\t\t\thostif_sme_enqueue(priv, SME_MIC_FAILURE_REQUEST);\n\t\t}\n\t\tif (priv->wpa.mic_failure.failure == 2)\n\t\t\tpriv->wpa.mic_failure.stop = 1;\n\t}\n\n\treturn ret;\n\nerr_kfree:\n\tkfree(pp);\nerr_kfree_skb:\n\tdev_kfree_skb(skb);\n\n\treturn ret;\n}\n\nstatic inline void ps_confirm_wait_inc(struct ks_wlan_private *priv)\n{\n\tif (atomic_read(&priv->psstatus.status) > PS_ACTIVE_SET)\n\t\tatomic_inc(&priv->psstatus.confirm_wait);\n}\n\nstatic inline void send_request_to_device(struct ks_wlan_private *priv,\n\t\t\t\t\t  void *data, size_t size)\n{\n\tps_confirm_wait_inc(priv);\n\tks_wlan_hw_tx(priv, data, size, NULL, NULL);\n}\n\nstatic void hostif_mib_get_request(struct ks_wlan_private *priv,\n\t\t\t\t   u32 mib_attribute)\n{\n\tstruct hostif_mib_get_request *pp;\n\n\tpp = hostif_generic_request(sizeof(*pp), HIF_MIB_GET_REQ);\n\tif (!pp)\n\t\treturn;\n\n\tpp->mib_attribute = cpu_to_le32(mib_attribute);\n\n\tsend_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));\n}\n\nstatic void hostif_mib_set_request(struct ks_wlan_private *priv,\n\t\t\t\t   enum mib_attribute attr,\n\t\t\t\t   enum mib_data_type type,\n\t\t\t\t   void *data, size_t size)\n{\n\tstruct hostif_mib_set_request_t *pp;\n\n\tif (priv->dev_state < DEVICE_STATE_BOOT)\n\t\treturn;\n\n\tpp = hostif_generic_request(sizeof(*pp), HIF_MIB_SET_REQ);\n\tif (!pp)\n\t\treturn;\n\n\tpp->mib_attribute = cpu_to_le32(attr);\n\tpp->mib_value.size = cpu_to_le16(size);\n\tpp->mib_value.type = cpu_to_le16(type);\n\tmemcpy(&pp->mib_value.body, data, size);\n\n\tsend_request_to_device(priv, pp, hif_align_size(sizeof(*pp) + size));\n}\n\nstatic inline void hostif_mib_set_request_int(struct ks_wlan_private *priv,\n\t\t\t\t\t      enum mib_attribute attr, int val)\n{\n\t__le32 v = cpu_to_le32(val);\n\tsize_t size = sizeof(v);\n\n\thostif_mib_set_request(priv, attr, MIB_VALUE_TYPE_INT, &v, size);\n}\n\nstatic inline void hostif_mib_set_request_bool(struct ks_wlan_private *priv,\n\t\t\t\t\t       enum mib_attribute attr,\n\t\t\t\t\t       bool val)\n{\n\t__le32 v = cpu_to_le32(val);\n\tsize_t size = sizeof(v);\n\n\thostif_mib_set_request(priv, attr, MIB_VALUE_TYPE_BOOL, &v, size);\n}\n\nstatic inline void hostif_mib_set_request_ostring(struct ks_wlan_private *priv,\n\t\t\t\t\t\t  enum mib_attribute attr,\n\t\t\t\t\t\t  void *data, size_t size)\n{\n\thostif_mib_set_request(priv, attr, MIB_VALUE_TYPE_OSTRING, data, size);\n}\n\nstatic\nvoid hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)\n{\n\tstruct hostif_start_request *pp;\n\n\tpp = hostif_generic_request(sizeof(*pp), HIF_START_REQ);\n\tif (!pp)\n\t\treturn;\n\n\tpp->mode = cpu_to_le16(mode);\n\n\tsend_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));\n\n\tpriv->aplist.size = 0;\n\tpriv->scan_ind_count = 0;\n}\n\nstatic __le16 ks_wlan_cap(struct ks_wlan_private *priv)\n{\n\tu16 capability = 0x0000;\n\n\tif (priv->reg.preamble == SHORT_PREAMBLE)\n\t\tcapability |= WLAN_CAPABILITY_SHORT_PREAMBLE;\n\n\tcapability &= ~(WLAN_CAPABILITY_PBCC);\t \n\n\tif (priv->reg.phy_type != D_11B_ONLY_MODE) {\n\t\tcapability |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\t\tcapability &= ~(WLAN_CAPABILITY_DSSS_OFDM);\n\t}\n\n\treturn cpu_to_le16(capability);\n}\n\nstatic void init_request(struct ks_wlan_private *priv,\n\t\t\t struct hostif_request *req)\n{\n\treq->phy_type = cpu_to_le16(priv->reg.phy_type);\n\treq->cts_mode = cpu_to_le16(priv->reg.cts_mode);\n\treq->scan_type = cpu_to_le16(priv->reg.scan_type);\n\treq->rate_set.size = priv->reg.rate_set.size;\n\treq->capability = ks_wlan_cap(priv);\n\tmemcpy(&req->rate_set.body[0], &priv->reg.rate_set.body[0],\n\t       priv->reg.rate_set.size);\n}\n\nstatic\nvoid hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)\n{\n\tstruct hostif_ps_adhoc_set_request *pp;\n\n\tpp = hostif_generic_request(sizeof(*pp), HIF_PS_ADH_SET_REQ);\n\tif (!pp)\n\t\treturn;\n\n\tinit_request(priv, &pp->request);\n\tpp->channel = cpu_to_le16(priv->reg.channel);\n\n\tsend_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));\n}\n\nstatic\nvoid hostif_infrastructure_set_request(struct ks_wlan_private *priv, int event)\n{\n\tstruct hostif_infrastructure_set_request *pp;\n\n\tpp = hostif_generic_request(sizeof(*pp), event);\n\tif (!pp)\n\t\treturn;\n\n\tinit_request(priv, &pp->request);\n\tpp->ssid.size = priv->reg.ssid.size;\n\tmemcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);\n\tpp->beacon_lost_count =\n\t    cpu_to_le16(priv->reg.beacon_lost_count);\n\tpp->auth_type = cpu_to_le16(priv->reg.authenticate_type);\n\n\tpp->channel_list.body[0] = 1;\n\tpp->channel_list.body[1] = 8;\n\tpp->channel_list.body[2] = 2;\n\tpp->channel_list.body[3] = 9;\n\tpp->channel_list.body[4] = 3;\n\tpp->channel_list.body[5] = 10;\n\tpp->channel_list.body[6] = 4;\n\tpp->channel_list.body[7] = 11;\n\tpp->channel_list.body[8] = 5;\n\tpp->channel_list.body[9] = 12;\n\tpp->channel_list.body[10] = 6;\n\tpp->channel_list.body[11] = 13;\n\tpp->channel_list.body[12] = 7;\n\tif (priv->reg.phy_type == D_11G_ONLY_MODE) {\n\t\tpp->channel_list.size = 13;\n\t} else {\n\t\tpp->channel_list.body[13] = 14;\n\t\tpp->channel_list.size = 14;\n\t}\n\n\tsend_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));\n}\n\nstatic\nvoid hostif_adhoc_set_request(struct ks_wlan_private *priv)\n{\n\tstruct hostif_adhoc_set_request *pp;\n\n\tpp = hostif_generic_request(sizeof(*pp), HIF_ADH_SET_REQ);\n\tif (!pp)\n\t\treturn;\n\n\tinit_request(priv, &pp->request);\n\tpp->channel = cpu_to_le16(priv->reg.channel);\n\tpp->ssid.size = priv->reg.ssid.size;\n\tmemcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);\n\n\tsend_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));\n}\n\nstatic\nvoid hostif_adhoc_set2_request(struct ks_wlan_private *priv)\n{\n\tstruct hostif_adhoc_set2_request *pp;\n\n\tpp = hostif_generic_request(sizeof(*pp), HIF_ADH_SET_REQ);\n\tif (!pp)\n\t\treturn;\n\n\tinit_request(priv, &pp->request);\n\tpp->ssid.size = priv->reg.ssid.size;\n\tmemcpy(&pp->ssid.body[0], &priv->reg.ssid.body[0], priv->reg.ssid.size);\n\n\tpp->channel_list.body[0] = priv->reg.channel;\n\tpp->channel_list.size = 1;\n\tmemcpy(pp->bssid, priv->reg.bssid, ETH_ALEN);\n\n\tsend_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));\n}\n\nstatic\nvoid hostif_stop_request(struct ks_wlan_private *priv)\n{\n\tstruct hostif_stop_request *pp;\n\n\tpp = hostif_generic_request(sizeof(*pp), HIF_STOP_REQ);\n\tif (!pp)\n\t\treturn;\n\n\tsend_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));\n}\n\nstatic\nvoid hostif_phy_information_request(struct ks_wlan_private *priv)\n{\n\tstruct hostif_phy_information_request *pp;\n\n\tpp = hostif_generic_request(sizeof(*pp), HIF_PHY_INFO_REQ);\n\tif (!pp)\n\t\treturn;\n\n\tif (priv->reg.phy_info_timer) {\n\t\tpp->type = cpu_to_le16(TIME_TYPE);\n\t\tpp->time = cpu_to_le16(priv->reg.phy_info_timer);\n\t} else {\n\t\tpp->type = cpu_to_le16(NORMAL_TYPE);\n\t\tpp->time = cpu_to_le16(0);\n\t}\n\n\tsend_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));\n}\n\nstatic\nvoid hostif_power_mgmt_request(struct ks_wlan_private *priv,\n\t\t\t       u32 mode, u32 wake_up, u32 receive_dtims)\n{\n\tstruct hostif_power_mgmt_request *pp;\n\n\tpp = hostif_generic_request(sizeof(*pp), HIF_POWER_MGMT_REQ);\n\tif (!pp)\n\t\treturn;\n\n\tpp->mode = cpu_to_le32(mode);\n\tpp->wake_up = cpu_to_le32(wake_up);\n\tpp->receive_dtims = cpu_to_le32(receive_dtims);\n\n\tsend_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));\n}\n\nstatic\nvoid hostif_sleep_request(struct ks_wlan_private *priv,\n\t\t\t  enum sleep_mode_type mode)\n{\n\tstruct hostif_sleep_request *pp;\n\n\tif (mode == SLP_SLEEP) {\n\t\tpp = hostif_generic_request(sizeof(*pp), HIF_SLEEP_REQ);\n\t\tif (!pp)\n\t\t\treturn;\n\n\t\tsend_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));\n\t} else if (mode == SLP_ACTIVE) {\n\t\tatomic_set(&priv->sleepstatus.wakeup_request, 1);\n\t\tqueue_delayed_work(priv->wq, &priv->rw_dwork, 1);\n\t} else {\n\t\tnetdev_err(priv->net_dev, \"invalid mode %ld\\n\", (long)mode);\n\t\treturn;\n\t}\n}\n\nstatic\nvoid hostif_bss_scan_request(struct ks_wlan_private *priv,\n\t\t\t     unsigned long scan_type, u8 *scan_ssid,\n\t\t\t     u8 scan_ssid_len)\n{\n\tstruct hostif_bss_scan_request *pp;\n\n\tpp = hostif_generic_request(sizeof(*pp), HIF_SCAN_REQ);\n\tif (!pp)\n\t\treturn;\n\n\tpp->scan_type = scan_type;\n\n\tpp->ch_time_min = cpu_to_le32(110);\t \n\tpp->ch_time_max = cpu_to_le32(130);\t \n\tpp->channel_list.body[0] = 1;\n\tpp->channel_list.body[1] = 8;\n\tpp->channel_list.body[2] = 2;\n\tpp->channel_list.body[3] = 9;\n\tpp->channel_list.body[4] = 3;\n\tpp->channel_list.body[5] = 10;\n\tpp->channel_list.body[6] = 4;\n\tpp->channel_list.body[7] = 11;\n\tpp->channel_list.body[8] = 5;\n\tpp->channel_list.body[9] = 12;\n\tpp->channel_list.body[10] = 6;\n\tpp->channel_list.body[11] = 13;\n\tpp->channel_list.body[12] = 7;\n\tif (priv->reg.phy_type == D_11G_ONLY_MODE) {\n\t\tpp->channel_list.size = 13;\n\t} else {\n\t\tpp->channel_list.body[13] = 14;\n\t\tpp->channel_list.size = 14;\n\t}\n\tpp->ssid.size = 0;\n\n\t \n\tif (scan_ssid_len > 0 && scan_ssid_len <= 32) {\n\t\tpp->ssid.size = scan_ssid_len;\n\t\tmemcpy(&pp->ssid.body[0], scan_ssid, scan_ssid_len);\n\t}\n\n\tsend_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));\n\n\tpriv->aplist.size = 0;\n\tpriv->scan_ind_count = 0;\n}\n\nstatic\nvoid hostif_mic_failure_request(struct ks_wlan_private *priv,\n\t\t\t\tu16 failure_count, u16 timer)\n{\n\tstruct hostif_mic_failure_request *pp;\n\n\tpp = hostif_generic_request(sizeof(*pp), HIF_MIC_FAILURE_REQ);\n\tif (!pp)\n\t\treturn;\n\n\tpp->failure_count = cpu_to_le16(failure_count);\n\tpp->timer = cpu_to_le16(timer);\n\n\tsend_request_to_device(priv, pp, hif_align_size(sizeof(*pp)));\n}\n\n \nstatic void devio_rec_ind(struct ks_wlan_private *priv, unsigned char *p,\n\t\t\t  unsigned int size)\n{\n\tif (!priv->is_device_open)\n\t\treturn;\n\n\tspin_lock(&priv->dev_read_lock);\n\tpriv->dev_data[atomic_read(&priv->rec_count)] = p;\n\tpriv->dev_size[atomic_read(&priv->rec_count)] = size;\n\n\tif (atomic_read(&priv->event_count) != DEVICE_STOCK_COUNT) {\n\t\t \n\t\tatomic_inc(&priv->event_count);\n\t}\n\tatomic_inc(&priv->rec_count);\n\tif (atomic_read(&priv->rec_count) == DEVICE_STOCK_COUNT)\n\t\tatomic_set(&priv->rec_count, 0);\n\n\twake_up_interruptible_all(&priv->devread_wait);\n\n\tspin_unlock(&priv->dev_read_lock);\n}\n\nvoid hostif_receive(struct ks_wlan_private *priv, unsigned char *p,\n\t\t    unsigned int size)\n{\n\tdevio_rec_ind(priv, p, size);\n\n\tpriv->rxp = p;\n\tpriv->rx_size = size;\n\n\tif (get_word(priv) == priv->rx_size)\n\t\thostif_event_check(priv);\n}\n\nstatic void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)\n{\n\tswitch (type) {\n\tcase SME_WEP_INDEX_REQUEST:\n\t\thostif_mib_set_request_int(priv, DOT11_WEP_DEFAULT_KEY_ID,\n\t\t\t\t\t   priv->reg.wep_index);\n\t\tbreak;\n\tcase SME_WEP_KEY1_REQUEST:\n\t\tif (priv->wpa.wpa_enabled)\n\t\t\treturn;\n\t\thostif_mib_set_request_ostring(priv,\n\t\t\t\t\t       DOT11_WEP_DEFAULT_KEY_VALUE1,\n\t\t\t\t\t       &priv->reg.wep_key[0].val[0],\n\t\t\t\t\t       priv->reg.wep_key[0].size);\n\t\tbreak;\n\tcase SME_WEP_KEY2_REQUEST:\n\t\tif (priv->wpa.wpa_enabled)\n\t\t\treturn;\n\t\thostif_mib_set_request_ostring(priv,\n\t\t\t\t\t       DOT11_WEP_DEFAULT_KEY_VALUE2,\n\t\t\t\t\t       &priv->reg.wep_key[1].val[0],\n\t\t\t\t\t       priv->reg.wep_key[1].size);\n\t\tbreak;\n\tcase SME_WEP_KEY3_REQUEST:\n\t\tif (priv->wpa.wpa_enabled)\n\t\t\treturn;\n\t\thostif_mib_set_request_ostring(priv,\n\t\t\t\t\t       DOT11_WEP_DEFAULT_KEY_VALUE3,\n\t\t\t\t\t       &priv->reg.wep_key[2].val[0],\n\t\t\t\t\t       priv->reg.wep_key[2].size);\n\t\tbreak;\n\tcase SME_WEP_KEY4_REQUEST:\n\t\tif (priv->wpa.wpa_enabled)\n\t\t\treturn;\n\t\thostif_mib_set_request_ostring(priv,\n\t\t\t\t\t       DOT11_WEP_DEFAULT_KEY_VALUE4,\n\t\t\t\t\t       &priv->reg.wep_key[3].val[0],\n\t\t\t\t\t       priv->reg.wep_key[3].size);\n\t\tbreak;\n\tcase SME_WEP_FLAG_REQUEST:\n\t\thostif_mib_set_request_bool(priv, DOT11_PRIVACY_INVOKED,\n\t\t\t\t\t    priv->reg.privacy_invoked);\n\t\tbreak;\n\t}\n}\n\nstruct wpa_suite {\n\t__le16 size;\n\tunsigned char suite[4][CIPHER_ID_LEN];\n} __packed;\n\nstruct rsn_mode {\n\t__le32 rsn_mode;\n\t__le16 rsn_capability;\n} __packed;\n\nstatic void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)\n{\n\tstruct wpa_suite wpa_suite;\n\tstruct rsn_mode rsn_mode;\n\tsize_t size;\n\tu32 mode;\n\tconst u8 *buf = NULL;\n\n\tmemset(&wpa_suite, 0, sizeof(wpa_suite));\n\n\tswitch (type) {\n\tcase SME_RSN_UCAST_REQUEST:\n\t\twpa_suite.size = cpu_to_le16(1);\n\t\tswitch (priv->wpa.pairwise_suite) {\n\t\tcase IW_AUTH_CIPHER_NONE:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tCIPHER_ID_WPA2_NONE : CIPHER_ID_WPA_NONE;\n\t\t\tbreak;\n\t\tcase IW_AUTH_CIPHER_WEP40:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tCIPHER_ID_WPA2_WEP40 : CIPHER_ID_WPA_WEP40;\n\t\t\tbreak;\n\t\tcase IW_AUTH_CIPHER_TKIP:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tCIPHER_ID_WPA2_TKIP : CIPHER_ID_WPA_TKIP;\n\t\t\tbreak;\n\t\tcase IW_AUTH_CIPHER_CCMP:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tCIPHER_ID_WPA2_CCMP : CIPHER_ID_WPA_CCMP;\n\t\t\tbreak;\n\t\tcase IW_AUTH_CIPHER_WEP104:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tCIPHER_ID_WPA2_WEP104 : CIPHER_ID_WPA_WEP104;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf)\n\t\t\tmemcpy(&wpa_suite.suite[0][0], buf, CIPHER_ID_LEN);\n\t\tsize = sizeof(wpa_suite.size) +\n\t\t       (CIPHER_ID_LEN * le16_to_cpu(wpa_suite.size));\n\t\thostif_mib_set_request_ostring(priv,\n\t\t\t\t\t       DOT11_RSN_CONFIG_UNICAST_CIPHER,\n\t\t\t\t\t       &wpa_suite, size);\n\t\tbreak;\n\tcase SME_RSN_MCAST_REQUEST:\n\t\tswitch (priv->wpa.group_suite) {\n\t\tcase IW_AUTH_CIPHER_NONE:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tCIPHER_ID_WPA2_NONE : CIPHER_ID_WPA_NONE;\n\t\t\tbreak;\n\t\tcase IW_AUTH_CIPHER_WEP40:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tCIPHER_ID_WPA2_WEP40 : CIPHER_ID_WPA_WEP40;\n\t\t\tbreak;\n\t\tcase IW_AUTH_CIPHER_TKIP:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tCIPHER_ID_WPA2_TKIP : CIPHER_ID_WPA_TKIP;\n\t\t\tbreak;\n\t\tcase IW_AUTH_CIPHER_CCMP:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tCIPHER_ID_WPA2_CCMP : CIPHER_ID_WPA_CCMP;\n\t\t\tbreak;\n\t\tcase IW_AUTH_CIPHER_WEP104:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tCIPHER_ID_WPA2_WEP104 : CIPHER_ID_WPA_WEP104;\n\t\t\tbreak;\n\t\t}\n\t\tif (buf)\n\t\t\tmemcpy(&wpa_suite.suite[0][0], buf, CIPHER_ID_LEN);\n\t\thostif_mib_set_request_ostring(priv,\n\t\t\t\t\t       DOT11_RSN_CONFIG_MULTICAST_CIPHER,\n\t\t\t\t\t       &wpa_suite.suite[0][0],\n\t\t\t\t\t       CIPHER_ID_LEN);\n\t\tbreak;\n\tcase SME_RSN_AUTH_REQUEST:\n\t\twpa_suite.size = cpu_to_le16(1);\n\t\tswitch (priv->wpa.key_mgmt_suite) {\n\t\tcase IW_AUTH_KEY_MGMT_802_1X:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tKEY_MGMT_ID_WPA2_1X : KEY_MGMT_ID_WPA_1X;\n\t\t\tbreak;\n\t\tcase IW_AUTH_KEY_MGMT_PSK:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tKEY_MGMT_ID_WPA2_PSK : KEY_MGMT_ID_WPA_PSK;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tKEY_MGMT_ID_WPA2_NONE : KEY_MGMT_ID_WPA_NONE;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tbuf = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\t\tKEY_MGMT_ID_WPA2_WPANONE :\n\t\t\t\tKEY_MGMT_ID_WPA_WPANONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf)\n\t\t\tmemcpy(&wpa_suite.suite[0][0], buf, KEY_MGMT_ID_LEN);\n\t\tsize = sizeof(wpa_suite.size) +\n\t\t       (KEY_MGMT_ID_LEN * le16_to_cpu(wpa_suite.size));\n\t\thostif_mib_set_request_ostring(priv,\n\t\t\t\t\t       DOT11_RSN_CONFIG_AUTH_SUITE,\n\t\t\t\t\t       &wpa_suite, size);\n\t\tbreak;\n\tcase SME_RSN_ENABLED_REQUEST:\n\t\thostif_mib_set_request_bool(priv, DOT11_RSN_ENABLED,\n\t\t\t\t\t    priv->wpa.rsn_enabled);\n\t\tbreak;\n\tcase SME_RSN_MODE_REQUEST:\n\t\tmode = (priv->wpa.version == IW_AUTH_WPA_VERSION_WPA2) ?\n\t\t\tRSN_MODE_WPA2 :\n\t\t\t(priv->wpa.version == IW_AUTH_WPA_VERSION_WPA) ?\n\t\t\t RSN_MODE_WPA : RSN_MODE_NONE;\n\t\trsn_mode.rsn_mode = cpu_to_le32(mode);\n\t\trsn_mode.rsn_capability = cpu_to_le16(0);\n\t\thostif_mib_set_request_ostring(priv, LOCAL_RSN_MODE,\n\t\t\t\t\t       &rsn_mode, sizeof(rsn_mode));\n\t\tbreak;\n\t}\n}\n\nstatic\nvoid hostif_sme_mode_setup(struct ks_wlan_private *priv)\n{\n\tunsigned char rate_size;\n\tunsigned char rate_octet[RATE_SET_MAX_SIZE];\n\tint i = 0;\n\n\t \n\tif (priv->reg.tx_rate == TX_RATE_FULL_AUTO) {\n\t\tif (priv->reg.phy_type == D_11B_ONLY_MODE) {\n\t\t\tpriv->reg.rate_set.body[3] = TX_RATE_11M;\n\t\t\tpriv->reg.rate_set.body[2] = TX_RATE_5M;\n\t\t\tpriv->reg.rate_set.body[1] = TX_RATE_2M | BASIC_RATE;\n\t\t\tpriv->reg.rate_set.body[0] = TX_RATE_1M | BASIC_RATE;\n\t\t\tpriv->reg.rate_set.size = 4;\n\t\t} else {\t \n\t\t\tpriv->reg.rate_set.body[11] = TX_RATE_54M;\n\t\t\tpriv->reg.rate_set.body[10] = TX_RATE_48M;\n\t\t\tpriv->reg.rate_set.body[9] = TX_RATE_36M;\n\t\t\tpriv->reg.rate_set.body[8] = TX_RATE_18M;\n\t\t\tpriv->reg.rate_set.body[7] = TX_RATE_9M;\n\t\t\tpriv->reg.rate_set.body[6] = TX_RATE_24M | BASIC_RATE;\n\t\t\tpriv->reg.rate_set.body[5] = TX_RATE_12M | BASIC_RATE;\n\t\t\tpriv->reg.rate_set.body[4] = TX_RATE_6M | BASIC_RATE;\n\t\t\tpriv->reg.rate_set.body[3] = TX_RATE_11M | BASIC_RATE;\n\t\t\tpriv->reg.rate_set.body[2] = TX_RATE_5M | BASIC_RATE;\n\t\t\tpriv->reg.rate_set.body[1] = TX_RATE_2M | BASIC_RATE;\n\t\t\tpriv->reg.rate_set.body[0] = TX_RATE_1M | BASIC_RATE;\n\t\t\tpriv->reg.rate_set.size = 12;\n\t\t}\n\t}\n\n\t \n\tif (priv->reg.phy_type == D_11B_ONLY_MODE) {\n\t\tfor (i = 0; i < priv->reg.rate_set.size; i++) {\n\t\t\tif (!is_11b_rate(priv->reg.rate_set.body[i]))\n\t\t\t\tbreak;\n\n\t\t\tif ((priv->reg.rate_set.body[i] & RATE_MASK) >= TX_RATE_5M) {\n\t\t\t\trate_octet[i] = priv->reg.rate_set.body[i] &\n\t\t\t\t\t\tRATE_MASK;\n\t\t\t} else {\n\t\t\t\trate_octet[i] = priv->reg.rate_set.body[i];\n\t\t\t}\n\t\t}\n\n\t} else {\t \n\t\tfor (i = 0; i < priv->reg.rate_set.size; i++) {\n\t\t\tif (!is_11bg_rate(priv->reg.rate_set.body[i]))\n\t\t\t\tbreak;\n\n\t\t\tif (is_ofdm_ext_rate(priv->reg.rate_set.body[i])) {\n\t\t\t\trate_octet[i] = priv->reg.rate_set.body[i] &\n\t\t\t\t\t\tRATE_MASK;\n\t\t\t} else {\n\t\t\t\trate_octet[i] = priv->reg.rate_set.body[i];\n\t\t\t}\n\t\t}\n\t}\n\trate_size = i;\n\tif (rate_size == 0) {\n\t\tif (priv->reg.phy_type == D_11G_ONLY_MODE)\n\t\t\trate_octet[0] = TX_RATE_6M | BASIC_RATE;\n\t\telse\n\t\t\trate_octet[0] = TX_RATE_2M | BASIC_RATE;\n\t\trate_size = 1;\n\t}\n\n\t \n\tpriv->reg.rate_set.size = rate_size;\n\tmemcpy(&priv->reg.rate_set.body[0], &rate_octet[0], rate_size);\n\n\tswitch (priv->reg.operation_mode) {\n\tcase MODE_PSEUDO_ADHOC:\n\t\thostif_ps_adhoc_set_request(priv);\n\t\tbreak;\n\tcase MODE_INFRASTRUCTURE:\n\t\tif (!is_valid_ether_addr((u8 *)priv->reg.bssid)) {\n\t\t\thostif_infrastructure_set_request(priv,\n\t\t\t\t\t\t\t  HIF_INFRA_SET_REQ);\n\t\t} else {\n\t\t\thostif_infrastructure_set_request(priv,\n\t\t\t\t\t\t\t  HIF_INFRA_SET2_REQ);\n\t\t\tnetdev_dbg(priv->net_dev,\n\t\t\t\t   \"Infra bssid = %pM\\n\", priv->reg.bssid);\n\t\t}\n\t\tbreak;\n\tcase MODE_ADHOC:\n\t\tif (!is_valid_ether_addr((u8 *)priv->reg.bssid)) {\n\t\t\thostif_adhoc_set_request(priv);\n\t\t} else {\n\t\t\thostif_adhoc_set2_request(priv);\n\t\t\tnetdev_dbg(priv->net_dev,\n\t\t\t\t   \"Adhoc bssid = %pM\\n\", priv->reg.bssid);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic\nvoid hostif_sme_multicast_set(struct ks_wlan_private *priv)\n{\n\tstruct net_device *dev = priv->net_dev;\n\tint mc_count;\n\tstruct netdev_hw_addr *ha;\n\tchar set_address[NIC_MAX_MCAST_LIST * ETH_ALEN];\n\tint i = 0;\n\n\tspin_lock(&priv->multicast_spin);\n\n\tmemset(set_address, 0, NIC_MAX_MCAST_LIST * ETH_ALEN);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\thostif_mib_set_request_int(priv, LOCAL_MULTICAST_FILTER,\n\t\t\t\t\t   MCAST_FILTER_PROMISC);\n\t\tgoto spin_unlock;\n\t}\n\n\tif ((netdev_mc_count(dev) > NIC_MAX_MCAST_LIST) ||\n\t    (dev->flags & IFF_ALLMULTI)) {\n\t\thostif_mib_set_request_int(priv, LOCAL_MULTICAST_FILTER,\n\t\t\t\t\t   MCAST_FILTER_MCASTALL);\n\t\tgoto spin_unlock;\n\t}\n\n\tif (priv->sme_i.sme_flag & SME_MULTICAST) {\n\t\tmc_count = netdev_mc_count(dev);\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tether_addr_copy(&set_address[i * ETH_ALEN], ha->addr);\n\t\t\ti++;\n\t\t}\n\t\tpriv->sme_i.sme_flag &= ~SME_MULTICAST;\n\t\thostif_mib_set_request_ostring(priv, LOCAL_MULTICAST_ADDRESS,\n\t\t\t\t\t       &set_address[0],\n\t\t\t\t\t       ETH_ALEN * mc_count);\n\t} else {\n\t\tpriv->sme_i.sme_flag |= SME_MULTICAST;\n\t\thostif_mib_set_request_int(priv, LOCAL_MULTICAST_FILTER,\n\t\t\t\t\t   MCAST_FILTER_MCAST);\n\t}\n\nspin_unlock:\n\tspin_unlock(&priv->multicast_spin);\n}\n\nstatic void hostif_sme_power_mgmt_set(struct ks_wlan_private *priv)\n{\n\tu32 mode, wake_up, receive_dtims;\n\n\tif (priv->reg.power_mgmt != POWER_MGMT_SAVE1 &&\n\t    priv->reg.power_mgmt != POWER_MGMT_SAVE2) {\n\t\tmode = POWER_ACTIVE;\n\t\twake_up = 0;\n\t\treceive_dtims = 0;\n\t} else {\n\t\tmode = (priv->reg.operation_mode == MODE_INFRASTRUCTURE) ?\n\t\t\tPOWER_SAVE : POWER_ACTIVE;\n\t\twake_up = 0;\n\t\treceive_dtims = (priv->reg.operation_mode == MODE_INFRASTRUCTURE &&\n\t\t\t\t priv->reg.power_mgmt == POWER_MGMT_SAVE2);\n\t}\n\n\thostif_power_mgmt_request(priv, mode, wake_up, receive_dtims);\n}\n\nstatic void hostif_sme_sleep_set(struct ks_wlan_private *priv)\n{\n\tif (priv->sleep_mode != SLP_SLEEP &&\n\t    priv->sleep_mode != SLP_ACTIVE)\n\t\treturn;\n\n\thostif_sleep_request(priv, priv->sleep_mode);\n}\n\nstatic\nvoid hostif_sme_set_key(struct ks_wlan_private *priv, int type)\n{\n\tswitch (type) {\n\tcase SME_SET_FLAG:\n\t\thostif_mib_set_request_bool(priv, DOT11_PRIVACY_INVOKED,\n\t\t\t\t\t    priv->reg.privacy_invoked);\n\t\tbreak;\n\tcase SME_SET_TXKEY:\n\t\thostif_mib_set_request_int(priv, DOT11_WEP_DEFAULT_KEY_ID,\n\t\t\t\t\t   priv->wpa.txkey);\n\t\tbreak;\n\tcase SME_SET_KEY1:\n\t\thostif_mib_set_request_ostring(priv,\n\t\t\t\t\t       DOT11_WEP_DEFAULT_KEY_VALUE1,\n\t\t\t\t\t       &priv->wpa.key[0].key_val[0],\n\t\t\t\t\t       priv->wpa.key[0].key_len);\n\t\tbreak;\n\tcase SME_SET_KEY2:\n\t\thostif_mib_set_request_ostring(priv,\n\t\t\t\t\t       DOT11_WEP_DEFAULT_KEY_VALUE2,\n\t\t\t\t\t       &priv->wpa.key[1].key_val[0],\n\t\t\t\t\t       priv->wpa.key[1].key_len);\n\t\tbreak;\n\tcase SME_SET_KEY3:\n\t\thostif_mib_set_request_ostring(priv,\n\t\t\t\t\t       DOT11_WEP_DEFAULT_KEY_VALUE3,\n\t\t\t\t\t       &priv->wpa.key[2].key_val[0],\n\t\t\t\t\t       priv->wpa.key[2].key_len);\n\t\tbreak;\n\tcase SME_SET_KEY4:\n\t\thostif_mib_set_request_ostring(priv,\n\t\t\t\t\t       DOT11_WEP_DEFAULT_KEY_VALUE4,\n\t\t\t\t\t       &priv->wpa.key[3].key_val[0],\n\t\t\t\t\t       priv->wpa.key[3].key_len);\n\t\tbreak;\n\tcase SME_SET_PMK_TSC:\n\t\thostif_mib_set_request_ostring(priv, DOT11_PMK_TSC,\n\t\t\t\t\t       &priv->wpa.key[0].rx_seq[0],\n\t\t\t\t\t       WPA_RX_SEQ_LEN);\n\t\tbreak;\n\tcase SME_SET_GMK1_TSC:\n\t\thostif_mib_set_request_ostring(priv, DOT11_GMK1_TSC,\n\t\t\t\t\t       &priv->wpa.key[1].rx_seq[0],\n\t\t\t\t\t       WPA_RX_SEQ_LEN);\n\t\tbreak;\n\tcase SME_SET_GMK2_TSC:\n\t\thostif_mib_set_request_ostring(priv, DOT11_GMK2_TSC,\n\t\t\t\t\t       &priv->wpa.key[2].rx_seq[0],\n\t\t\t\t\t       WPA_RX_SEQ_LEN);\n\t\tbreak;\n\t}\n}\n\nstatic\nvoid hostif_sme_set_pmksa(struct ks_wlan_private *priv)\n{\n\tstruct pmk_cache {\n\t\t__le16 size;\n\t\tstruct {\n\t\t\tu8 bssid[ETH_ALEN];\n\t\t\tu8 pmkid[IW_PMKID_LEN];\n\t\t} __packed list[PMK_LIST_MAX];\n\t} __packed pmkcache;\n\tstruct pmk *pmk;\n\tsize_t size;\n\tint i = 0;\n\n\tlist_for_each_entry(pmk, &priv->pmklist.head, list) {\n\t\tif (i >= PMK_LIST_MAX)\n\t\t\tbreak;\n\t\tether_addr_copy(pmkcache.list[i].bssid, pmk->bssid);\n\t\tmemcpy(pmkcache.list[i].pmkid, pmk->pmkid, IW_PMKID_LEN);\n\t\ti++;\n\t}\n\tpmkcache.size = cpu_to_le16(priv->pmklist.size);\n\tsize = sizeof(priv->pmklist.size) +\n\t       ((ETH_ALEN + IW_PMKID_LEN) * priv->pmklist.size);\n\thostif_mib_set_request_ostring(priv, LOCAL_PMK, &pmkcache, size);\n}\n\n \nstatic void hostif_sme_execute(struct ks_wlan_private *priv, int event)\n{\n\tu16 failure;\n\n\tswitch (event) {\n\tcase SME_START:\n\t\tif (priv->dev_state == DEVICE_STATE_BOOT)\n\t\t\thostif_mib_get_request(priv, DOT11_MAC_ADDRESS);\n\t\tbreak;\n\tcase SME_MULTICAST_REQUEST:\n\t\thostif_sme_multicast_set(priv);\n\t\tbreak;\n\tcase SME_MACADDRESS_SET_REQUEST:\n\t\thostif_mib_set_request_ostring(priv, LOCAL_CURRENTADDRESS,\n\t\t\t\t\t       &priv->eth_addr[0], ETH_ALEN);\n\t\tbreak;\n\tcase SME_BSS_SCAN_REQUEST:\n\t\thostif_bss_scan_request(priv, priv->reg.scan_type,\n\t\t\t\t\tpriv->scan_ssid, priv->scan_ssid_len);\n\t\tbreak;\n\tcase SME_POW_MNGMT_REQUEST:\n\t\thostif_sme_power_mgmt_set(priv);\n\t\tbreak;\n\tcase SME_PHY_INFO_REQUEST:\n\t\thostif_phy_information_request(priv);\n\t\tbreak;\n\tcase SME_MIC_FAILURE_REQUEST:\n\t\tfailure = priv->wpa.mic_failure.failure;\n\t\tif (failure != 1 && failure != 2) {\n\t\t\tnetdev_err(priv->net_dev,\n\t\t\t\t   \"SME_MIC_FAILURE_REQUEST: failure count=%u error?\\n\",\n\t\t\t\t   failure);\n\t\t\treturn;\n\t\t}\n\t\thostif_mic_failure_request(priv, failure - 1, (failure == 1) ?\n\t\t\t\t\t    0 : priv->wpa.mic_failure.counter);\n\t\tbreak;\n\tcase SME_MIC_FAILURE_CONFIRM:\n\t\tif (priv->wpa.mic_failure.failure == 2) {\n\t\t\tif (priv->wpa.mic_failure.stop)\n\t\t\t\tpriv->wpa.mic_failure.stop = 0;\n\t\t\tpriv->wpa.mic_failure.failure = 0;\n\t\t\thostif_start_request(priv, priv->reg.operation_mode);\n\t\t}\n\t\tbreak;\n\tcase SME_GET_MAC_ADDRESS:\n\t\tif (priv->dev_state == DEVICE_STATE_BOOT)\n\t\t\thostif_mib_get_request(priv, DOT11_PRODUCT_VERSION);\n\t\tbreak;\n\tcase SME_GET_PRODUCT_VERSION:\n\t\tif (priv->dev_state == DEVICE_STATE_BOOT)\n\t\t\tpriv->dev_state = DEVICE_STATE_PREINIT;\n\t\tbreak;\n\tcase SME_STOP_REQUEST:\n\t\thostif_stop_request(priv);\n\t\tbreak;\n\tcase SME_RTS_THRESHOLD_REQUEST:\n\t\thostif_mib_set_request_int(priv, DOT11_RTS_THRESHOLD,\n\t\t\t\t\t   priv->reg.rts);\n\t\tbreak;\n\tcase SME_FRAGMENTATION_THRESHOLD_REQUEST:\n\t\thostif_mib_set_request_int(priv, DOT11_FRAGMENTATION_THRESHOLD,\n\t\t\t\t\t   priv->reg.fragment);\n\t\tbreak;\n\tcase SME_WEP_INDEX_REQUEST:\n\tcase SME_WEP_KEY1_REQUEST:\n\tcase SME_WEP_KEY2_REQUEST:\n\tcase SME_WEP_KEY3_REQUEST:\n\tcase SME_WEP_KEY4_REQUEST:\n\tcase SME_WEP_FLAG_REQUEST:\n\t\thostif_sme_set_wep(priv, event);\n\t\tbreak;\n\tcase SME_RSN_UCAST_REQUEST:\n\tcase SME_RSN_MCAST_REQUEST:\n\tcase SME_RSN_AUTH_REQUEST:\n\tcase SME_RSN_ENABLED_REQUEST:\n\tcase SME_RSN_MODE_REQUEST:\n\t\thostif_sme_set_rsn(priv, event);\n\t\tbreak;\n\tcase SME_SET_FLAG:\n\tcase SME_SET_TXKEY:\n\tcase SME_SET_KEY1:\n\tcase SME_SET_KEY2:\n\tcase SME_SET_KEY3:\n\tcase SME_SET_KEY4:\n\tcase SME_SET_PMK_TSC:\n\tcase SME_SET_GMK1_TSC:\n\tcase SME_SET_GMK2_TSC:\n\t\thostif_sme_set_key(priv, event);\n\t\tbreak;\n\tcase SME_SET_PMKSA:\n\t\thostif_sme_set_pmksa(priv);\n\t\tbreak;\n\tcase SME_WPS_ENABLE_REQUEST:\n\t\thostif_mib_set_request_int(priv, LOCAL_WPS_ENABLE,\n\t\t\t\t\t   priv->wps.wps_enabled);\n\t\tbreak;\n\tcase SME_WPS_PROBE_REQUEST:\n\t\thostif_mib_set_request_ostring(priv, LOCAL_WPS_PROBE_REQ,\n\t\t\t\t\t       priv->wps.ie, priv->wps.ielen);\n\t\tbreak;\n\tcase SME_MODE_SET_REQUEST:\n\t\thostif_sme_mode_setup(priv);\n\t\tbreak;\n\tcase SME_SET_GAIN:\n\t\thostif_mib_set_request_ostring(priv, LOCAL_GAIN,\n\t\t\t\t\t       &priv->gain, sizeof(priv->gain));\n\t\tbreak;\n\tcase SME_GET_GAIN:\n\t\thostif_mib_get_request(priv, LOCAL_GAIN);\n\t\tbreak;\n\tcase SME_GET_EEPROM_CKSUM:\n\t\tpriv->eeprom_checksum = EEPROM_FW_NOT_SUPPORT;\t \n\t\thostif_mib_get_request(priv, LOCAL_EEPROM_SUM);\n\t\tbreak;\n\tcase SME_START_REQUEST:\n\t\thostif_start_request(priv, priv->reg.operation_mode);\n\t\tbreak;\n\tcase SME_START_CONFIRM:\n\t\t \n\t\tatomic_set(&priv->psstatus.snooze_guard, 0);\n\t\tatomic_set(&priv->psstatus.confirm_wait, 0);\n\t\tif (priv->dev_state == DEVICE_STATE_PREINIT)\n\t\t\tpriv->dev_state = DEVICE_STATE_INIT;\n\t\t \n\t\tcomplete(&priv->confirm_wait);\n\t\tbreak;\n\tcase SME_SLEEP_REQUEST:\n\t\thostif_sme_sleep_set(priv);\n\t\tbreak;\n\tcase SME_SET_REGION:\n\t\thostif_mib_set_request_int(priv, LOCAL_REGION, priv->region);\n\t\tbreak;\n\tcase SME_MULTICAST_CONFIRM:\n\tcase SME_BSS_SCAN_CONFIRM:\n\tcase SME_POW_MNGMT_CONFIRM:\n\tcase SME_PHY_INFO_CONFIRM:\n\tcase SME_STOP_CONFIRM:\n\tcase SME_RTS_THRESHOLD_CONFIRM:\n\tcase SME_FRAGMENTATION_THRESHOLD_CONFIRM:\n\tcase SME_WEP_INDEX_CONFIRM:\n\tcase SME_WEP_KEY1_CONFIRM:\n\tcase SME_WEP_KEY2_CONFIRM:\n\tcase SME_WEP_KEY3_CONFIRM:\n\tcase SME_WEP_KEY4_CONFIRM:\n\tcase SME_WEP_FLAG_CONFIRM:\n\tcase SME_RSN_UCAST_CONFIRM:\n\tcase SME_RSN_MCAST_CONFIRM:\n\tcase SME_RSN_AUTH_CONFIRM:\n\tcase SME_RSN_ENABLED_CONFIRM:\n\tcase SME_RSN_MODE_CONFIRM:\n\tcase SME_MODE_SET_CONFIRM:\n\tcase SME_TERMINATE:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void hostif_sme_work(struct work_struct *work)\n{\n\tstruct ks_wlan_private *priv;\n\n\tpriv = container_of(work, struct ks_wlan_private, sme_work);\n\n\tif (priv->dev_state < DEVICE_STATE_BOOT)\n\t\treturn;\n\n\tif (cnt_smeqbody(priv) <= 0)\n\t\treturn;\n\n\thostif_sme_execute(priv, priv->sme_i.event_buff[priv->sme_i.qhead]);\n\tinc_smeqhead(priv);\n\tif (cnt_smeqbody(priv) > 0)\n\t\tschedule_work(&priv->sme_work);\n}\n\n \nvoid hostif_sme_enqueue(struct ks_wlan_private *priv, u16 event)\n{\n\t \n\tif (cnt_smeqbody(priv) < (SME_EVENT_BUFF_SIZE - 1)) {\n\t\tpriv->sme_i.event_buff[priv->sme_i.qtail] = event;\n\t\tinc_smeqtail(priv);\n\t} else {\n\t\t \n\t\tnetdev_err(priv->net_dev, \"sme queue buffer overflow\\n\");\n\t}\n\n\tschedule_work(&priv->sme_work);\n}\n\nstatic inline void hostif_aplist_init(struct ks_wlan_private *priv)\n{\n\tsize_t size = LOCAL_APLIST_MAX * sizeof(struct local_ap);\n\n\tpriv->aplist.size = 0;\n\tmemset(&priv->aplist.ap[0], 0, size);\n}\n\nstatic inline void hostif_status_init(struct ks_wlan_private *priv)\n{\n\tpriv->infra_status = 0;\n\tpriv->current_rate = 4;\n\tpriv->connect_status = DISCONNECT_STATUS;\n}\n\nstatic inline void hostif_sme_init(struct ks_wlan_private *priv)\n{\n\tpriv->sme_i.sme_status = SME_IDLE;\n\tpriv->sme_i.qhead = 0;\n\tpriv->sme_i.qtail = 0;\n\tspin_lock_init(&priv->sme_i.sme_spin);\n\tpriv->sme_i.sme_flag = 0;\n\tINIT_WORK(&priv->sme_work, hostif_sme_work);\n}\n\nstatic inline void hostif_wpa_init(struct ks_wlan_private *priv)\n{\n\tmemset(&priv->wpa, 0, sizeof(priv->wpa));\n\tpriv->wpa.rsn_enabled = false;\n\tpriv->wpa.mic_failure.failure = 0;\n\tpriv->wpa.mic_failure.last_failure_time = 0;\n\tpriv->wpa.mic_failure.stop = 0;\n}\n\nstatic inline void hostif_power_save_init(struct ks_wlan_private *priv)\n{\n\tatomic_set(&priv->psstatus.status, PS_NONE);\n\tatomic_set(&priv->psstatus.confirm_wait, 0);\n\tatomic_set(&priv->psstatus.snooze_guard, 0);\n\tinit_completion(&priv->psstatus.wakeup_wait);\n\tINIT_WORK(&priv->wakeup_work, ks_wlan_hw_wakeup_task);\n}\n\nstatic inline void hostif_pmklist_init(struct ks_wlan_private *priv)\n{\n\tint i;\n\n\tmemset(&priv->pmklist, 0, sizeof(priv->pmklist));\n\tINIT_LIST_HEAD(&priv->pmklist.head);\n\tfor (i = 0; i < PMK_LIST_MAX; i++)\n\t\tINIT_LIST_HEAD(&priv->pmklist.pmk[i].list);\n}\n\nstatic inline void hostif_counters_init(struct ks_wlan_private *priv)\n{\n\tpriv->dev_count = 0;\n\tatomic_set(&priv->event_count, 0);\n\tatomic_set(&priv->rec_count, 0);\n}\n\nint hostif_init(struct ks_wlan_private *priv)\n{\n\thostif_aplist_init(priv);\n\thostif_status_init(priv);\n\n\tspin_lock_init(&priv->multicast_spin);\n\tspin_lock_init(&priv->dev_read_lock);\n\tinit_waitqueue_head(&priv->devread_wait);\n\n\thostif_counters_init(priv);\n\thostif_power_save_init(priv);\n\thostif_wpa_init(priv);\n\thostif_pmklist_init(priv);\n\thostif_sme_init(priv);\n\n\treturn 0;\n}\n\nvoid hostif_exit(struct ks_wlan_private *priv)\n{\n\tcancel_work_sync(&priv->sme_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}