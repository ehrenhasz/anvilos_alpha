{
  "module_name": "ks_wlan_net.c",
  "hash_id": "9f2fff67437513368d693b53a5d4ff24e7572d28938b5b25bd7533d8cd705406",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/ks7010/ks_wlan_net.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/completion.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/timer.h>\n#include <linux/uaccess.h>\n\nstatic int wep_on_off;\n#define\tWEP_OFF\t\t0\n#define\tWEP_ON_64BIT\t1\n#define\tWEP_ON_128BIT\t2\n\n#include \"ks_wlan.h\"\n#include \"ks_hostif.h\"\n#include \"ks_wlan_ioctl.h\"\n\n \n#include <linux/wireless.h>\n#define WIRELESS_SPY\t \n#include <net/iw_handler.h>\t \n\n \nstatic const long frequency_list[] = {\n\t2412, 2417, 2422, 2427, 2432, 2437, 2442,\n\t2447, 2452, 2457, 2462, 2467, 2472, 2484\n};\n\n \n#define MAX_KEY_SIZE 13\t \n#define MIN_KEY_SIZE  5\t \nstruct wep_key {\n\tu16 len;\n\tu8 key[16];\t \n};\n\n \nstatic int ks_wlan_open(struct net_device *dev);\nstatic void ks_wlan_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic netdev_tx_t ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev);\nstatic int ks_wlan_close(struct net_device *dev);\nstatic void ks_wlan_set_rx_mode(struct net_device *dev);\nstatic struct net_device_stats *ks_wlan_get_stats(struct net_device *dev);\nstatic int ks_wlan_set_mac_address(struct net_device *dev, void *addr);\nstatic int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq,\n\t\t\t\tint cmd);\n\nstatic atomic_t update_phyinfo;\nstatic struct timer_list update_phyinfo_timer;\nstatic\nint ks_wlan_update_phy_information(struct ks_wlan_private *priv)\n{\n\tstruct iw_statistics *wstats = &priv->wstats;\n\n\tnetdev_dbg(priv->net_dev, \"in_interrupt = %ld\\n\", in_interrupt());\n\n\tif (priv->dev_state < DEVICE_STATE_READY)\n\t\treturn -EBUSY;\t \n\n\tif (atomic_read(&update_phyinfo))\n\t\treturn -EPERM;\n\n\t \n\twstats->status = priv->reg.operation_mode;\t \n\n\t \n\thostif_sme_enqueue(priv, SME_PHY_INFO_REQUEST);\n\n\t \n\tif (!wait_for_completion_interruptible_timeout\n\t    (&priv->confirm_wait, HZ / 2)) {\n\t\tnetdev_dbg(priv->net_dev, \"wait time out!!\\n\");\n\t}\n\n\tatomic_inc(&update_phyinfo);\n\tupdate_phyinfo_timer.expires = jiffies + HZ;\t \n\tadd_timer(&update_phyinfo_timer);\n\n\treturn 0;\n}\n\nstatic\nvoid ks_wlan_update_phyinfo_timeout(struct timer_list *unused)\n{\n\tpr_debug(\"in_interrupt = %ld\\n\", in_interrupt());\n\tatomic_set(&update_phyinfo, 0);\n}\n\nint ks_wlan_setup_parameter(struct ks_wlan_private *priv,\n\t\t\t    unsigned int commit_flag)\n{\n\thostif_sme_enqueue(priv, SME_STOP_REQUEST);\n\n\tif (commit_flag & SME_RTS)\n\t\thostif_sme_enqueue(priv, SME_RTS_THRESHOLD_REQUEST);\n\tif (commit_flag & SME_FRAG)\n\t\thostif_sme_enqueue(priv, SME_FRAGMENTATION_THRESHOLD_REQUEST);\n\n\tif (commit_flag & SME_WEP_INDEX)\n\t\thostif_sme_enqueue(priv, SME_WEP_INDEX_REQUEST);\n\tif (commit_flag & SME_WEP_VAL1)\n\t\thostif_sme_enqueue(priv, SME_WEP_KEY1_REQUEST);\n\tif (commit_flag & SME_WEP_VAL2)\n\t\thostif_sme_enqueue(priv, SME_WEP_KEY2_REQUEST);\n\tif (commit_flag & SME_WEP_VAL3)\n\t\thostif_sme_enqueue(priv, SME_WEP_KEY3_REQUEST);\n\tif (commit_flag & SME_WEP_VAL4)\n\t\thostif_sme_enqueue(priv, SME_WEP_KEY4_REQUEST);\n\tif (commit_flag & SME_WEP_FLAG)\n\t\thostif_sme_enqueue(priv, SME_WEP_FLAG_REQUEST);\n\n\tif (commit_flag & SME_RSN) {\n\t\thostif_sme_enqueue(priv, SME_RSN_ENABLED_REQUEST);\n\t\thostif_sme_enqueue(priv, SME_RSN_MODE_REQUEST);\n\t}\n\tif (commit_flag & SME_RSN_MULTICAST)\n\t\thostif_sme_enqueue(priv, SME_RSN_MCAST_REQUEST);\n\tif (commit_flag & SME_RSN_UNICAST)\n\t\thostif_sme_enqueue(priv, SME_RSN_UCAST_REQUEST);\n\tif (commit_flag & SME_RSN_AUTH)\n\t\thostif_sme_enqueue(priv, SME_RSN_AUTH_REQUEST);\n\n\thostif_sme_enqueue(priv, SME_MODE_SET_REQUEST);\n\n\thostif_sme_enqueue(priv, SME_START_REQUEST);\n\n\treturn 0;\n}\n\n \n\nstatic int ks_wlan_get_name(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *cwrq,\n\t\t\t    char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tif (priv->dev_state < DEVICE_STATE_READY)\n\t\tstrscpy(cwrq->name, \"NOT READY!\", sizeof(cwrq->name));\n\telse if (priv->reg.phy_type == D_11B_ONLY_MODE)\n\t\tstrscpy(cwrq->name, \"IEEE 802.11b\", sizeof(cwrq->name));\n\telse if (priv->reg.phy_type == D_11G_ONLY_MODE)\n\t\tstrscpy(cwrq->name, \"IEEE 802.11g\", sizeof(cwrq->name));\n\telse\n\t\tstrscpy(cwrq->name, \"IEEE 802.11b/g\", sizeof(cwrq->name));\n\n\treturn 0;\n}\n\nstatic int ks_wlan_set_freq(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *fwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tint channel;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\t \n\tif ((fwrq->freq.e == 1) &&\n\t    (fwrq->freq.m >= 241200000) && (fwrq->freq.m <= 248700000)) {\n\t\tint f = fwrq->freq.m / 100000;\n\t\tint c = 0;\n\n\t\twhile ((c < 14) && (f != frequency_list[c]))\n\t\t\tc++;\n\t\t \n\t\tfwrq->freq.e = 0;\n\t\tfwrq->freq.m = c + 1;\n\t}\n\t \n\tif ((fwrq->freq.m > 1000) || (fwrq->freq.e > 0))\n\t\treturn -EOPNOTSUPP;\n\n\tchannel = fwrq->freq.m;\n\t \n\tif ((channel < 1) || (channel > 14)) {\n\t\tnetdev_dbg(dev, \"%s: New channel value of %d is invalid!\\n\",\n\t\t\t   dev->name, fwrq->freq.m);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpriv->reg.channel = (u8)(channel);\n\tpriv->need_commit |= SME_MODE_SET;\n\n\treturn -EINPROGRESS;\t \n}\n\nstatic int ks_wlan_get_freq(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *fwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tint f;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tif (is_connect_status(priv->connect_status))\n\t\tf = (int)priv->current_ap.channel;\n\telse\n\t\tf = (int)priv->reg.channel;\n\n\tfwrq->freq.m = frequency_list[f - 1] * 100000;\n\tfwrq->freq.e = 1;\n\n\treturn 0;\n}\n\nstatic int ks_wlan_set_essid(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tsize_t len;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\t \n\tif (!dwrq->essid.flags) {\n\t\t \n\t\tmemset(priv->reg.ssid.body, 0, sizeof(priv->reg.ssid.body));\n\t\tpriv->reg.ssid.size = 0;\n\t} else {\n\t\tlen = dwrq->essid.length;\n\t\t \n\t\tif (len > 0 && extra[len - 1] == '\\0')\n\t\t\tlen--;\n\n\t\t \n\t\tif (len > IW_ESSID_MAX_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tmemset(priv->reg.ssid.body, 0, sizeof(priv->reg.ssid.body));\n\t\tmemcpy(priv->reg.ssid.body, extra, len);\n\t\tpriv->reg.ssid.size = len;\n\t}\n\t \n\tpriv->need_commit |= SME_MODE_SET;\n\n\tks_wlan_setup_parameter(priv, priv->need_commit);\n\tpriv->need_commit = 0;\n\treturn 0;\n}\n\nstatic int ks_wlan_get_essid(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\t \n\tif (priv->reg.ssid.size != 0) {\n\t\t \n\t\tmemcpy(extra, priv->reg.ssid.body, priv->reg.ssid.size);\n\n\t\t \n\n\t\t \n\t\tdwrq->essid.length = priv->reg.ssid.size;\n\t\tdwrq->essid.flags = 1;\t \n\t} else {\n\t\tdwrq->essid.length = 0;\n\t\tdwrq->essid.flags = 0;\t \n\t}\n\n\treturn 0;\n}\n\nstatic int ks_wlan_set_wap(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *awrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tif (priv->reg.operation_mode != MODE_ADHOC &&\n\t    priv->reg.operation_mode != MODE_INFRASTRUCTURE) {\n\t\teth_zero_addr(priv->reg.bssid);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tether_addr_copy(priv->reg.bssid, awrq->ap_addr.sa_data);\n\tif (is_valid_ether_addr((u8 *)priv->reg.bssid))\n\t\tpriv->need_commit |= SME_MODE_SET;\n\n\tnetdev_dbg(dev, \"bssid = %pM\\n\", priv->reg.bssid);\n\n\t \n\tif (priv->need_commit) {\n\t\tpriv->need_commit |= SME_MODE_SET;\n\t\treturn -EINPROGRESS;\t \n\t}\n\treturn 0;\n}\n\nstatic int ks_wlan_get_wap(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *awrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tif (is_connect_status(priv->connect_status))\n\t\tether_addr_copy(awrq->ap_addr.sa_data, priv->current_ap.bssid);\n\telse\n\t\teth_zero_addr(awrq->ap_addr.sa_data);\n\n\tawrq->ap_addr.sa_family = ARPHRD_ETHER;\n\n\treturn 0;\n}\n\nstatic int ks_wlan_set_nick(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\t \n\tif (dwrq->data.length > 16 + 1)\n\t\treturn -E2BIG;\n\n\tmemset(priv->nick, 0, sizeof(priv->nick));\n\tmemcpy(priv->nick, extra, dwrq->data.length);\n\n\treturn -EINPROGRESS;\t \n}\n\nstatic int ks_wlan_get_nick(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tstrscpy(extra, priv->nick, 17);\n\tdwrq->data.length = strlen(extra) + 1;\n\n\treturn 0;\n}\n\nstatic int ks_wlan_set_rate(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *vwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tint i = 0;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tif (priv->reg.phy_type == D_11B_ONLY_MODE) {\n\t\tif (vwrq->bitrate.fixed == 1) {\n\t\t\tswitch (vwrq->bitrate.value) {\n\t\t\tcase 11000000:\n\t\t\tcase 5500000:\n\t\t\t\tpriv->reg.rate_set.body[0] =\n\t\t\t\t    (u8)(vwrq->bitrate.value / 500000);\n\t\t\t\tbreak;\n\t\t\tcase 2000000:\n\t\t\tcase 1000000:\n\t\t\t\tpriv->reg.rate_set.body[0] =\n\t\t\t\t    ((u8)(vwrq->bitrate.value / 500000)) |\n\t\t\t\t    BASIC_RATE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpriv->reg.tx_rate = TX_RATE_FIXED;\n\t\t\tpriv->reg.rate_set.size = 1;\n\t\t} else {\t \n\t\t\tif (vwrq->bitrate.value > 0) {\n\t\t\t\tswitch (vwrq->bitrate.value) {\n\t\t\t\tcase 11000000:\n\t\t\t\t\tpriv->reg.rate_set.body[3] =\n\t\t\t\t\t    TX_RATE_11M;\n\t\t\t\t\ti++;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 5500000:\n\t\t\t\t\tpriv->reg.rate_set.body[2] = TX_RATE_5M;\n\t\t\t\t\ti++;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 2000000:\n\t\t\t\t\tpriv->reg.rate_set.body[1] =\n\t\t\t\t\t    TX_RATE_2M | BASIC_RATE;\n\t\t\t\t\ti++;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 1000000:\n\t\t\t\t\tpriv->reg.rate_set.body[0] =\n\t\t\t\t\t    TX_RATE_1M | BASIC_RATE;\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tpriv->reg.tx_rate = TX_RATE_MANUAL_AUTO;\n\t\t\t\tpriv->reg.rate_set.size = i;\n\t\t\t} else {\n\t\t\t\tpriv->reg.rate_set.body[3] = TX_RATE_11M;\n\t\t\t\tpriv->reg.rate_set.body[2] = TX_RATE_5M;\n\t\t\t\tpriv->reg.rate_set.body[1] =\n\t\t\t\t    TX_RATE_2M | BASIC_RATE;\n\t\t\t\tpriv->reg.rate_set.body[0] =\n\t\t\t\t    TX_RATE_1M | BASIC_RATE;\n\t\t\t\tpriv->reg.tx_rate = TX_RATE_FULL_AUTO;\n\t\t\t\tpriv->reg.rate_set.size = 4;\n\t\t\t}\n\t\t}\n\t} else {\t \n\t\tif (vwrq->bitrate.fixed == 1) {\n\t\t\tswitch (vwrq->bitrate.value) {\n\t\t\tcase 54000000:\n\t\t\tcase 48000000:\n\t\t\tcase 36000000:\n\t\t\tcase 18000000:\n\t\t\tcase 9000000:\n\t\t\t\tpriv->reg.rate_set.body[0] =\n\t\t\t\t    (u8)(vwrq->bitrate.value / 500000);\n\t\t\t\tbreak;\n\t\t\tcase 24000000:\n\t\t\tcase 12000000:\n\t\t\tcase 11000000:\n\t\t\tcase 6000000:\n\t\t\tcase 5500000:\n\t\t\tcase 2000000:\n\t\t\tcase 1000000:\n\t\t\t\tpriv->reg.rate_set.body[0] =\n\t\t\t\t    ((u8)(vwrq->bitrate.value / 500000)) |\n\t\t\t\t    BASIC_RATE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpriv->reg.tx_rate = TX_RATE_FIXED;\n\t\t\tpriv->reg.rate_set.size = 1;\n\t\t} else {\t \n\t\t\tif (vwrq->bitrate.value > 0) {\n\t\t\t\tswitch (vwrq->bitrate.value) {\n\t\t\t\tcase 54000000:\n\t\t\t\t\tpriv->reg.rate_set.body[11] =\n\t\t\t\t\t    TX_RATE_54M;\n\t\t\t\t\ti++;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 48000000:\n\t\t\t\t\tpriv->reg.rate_set.body[10] =\n\t\t\t\t\t    TX_RATE_48M;\n\t\t\t\t\ti++;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 36000000:\n\t\t\t\t\tpriv->reg.rate_set.body[9] =\n\t\t\t\t\t    TX_RATE_36M;\n\t\t\t\t\ti++;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 24000000:\n\t\t\t\tcase 18000000:\n\t\t\t\tcase 12000000:\n\t\t\t\tcase 11000000:\n\t\t\t\tcase 9000000:\n\t\t\t\tcase 6000000:\n\t\t\t\t\tif (vwrq->bitrate.value == 24000000) {\n\t\t\t\t\t\tpriv->reg.rate_set.body[8] =\n\t\t\t\t\t\t    TX_RATE_18M;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[7] =\n\t\t\t\t\t\t    TX_RATE_9M;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[6] =\n\t\t\t\t\t\t    TX_RATE_24M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[5] =\n\t\t\t\t\t\t    TX_RATE_12M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[4] =\n\t\t\t\t\t\t    TX_RATE_6M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[3] =\n\t\t\t\t\t\t    TX_RATE_11M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (vwrq->bitrate.value == 18000000) {\n\t\t\t\t\t\tpriv->reg.rate_set.body[7] =\n\t\t\t\t\t\t    TX_RATE_18M;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[6] =\n\t\t\t\t\t\t    TX_RATE_9M;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[5] =\n\t\t\t\t\t\t    TX_RATE_12M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[4] =\n\t\t\t\t\t\t    TX_RATE_6M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[3] =\n\t\t\t\t\t\t    TX_RATE_11M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (vwrq->bitrate.value == 12000000) {\n\t\t\t\t\t\tpriv->reg.rate_set.body[6] =\n\t\t\t\t\t\t    TX_RATE_9M;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[5] =\n\t\t\t\t\t\t    TX_RATE_12M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[4] =\n\t\t\t\t\t\t    TX_RATE_6M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[3] =\n\t\t\t\t\t\t    TX_RATE_11M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (vwrq->bitrate.value == 11000000) {\n\t\t\t\t\t\tpriv->reg.rate_set.body[5] =\n\t\t\t\t\t\t    TX_RATE_9M;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[4] =\n\t\t\t\t\t\t    TX_RATE_6M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[3] =\n\t\t\t\t\t\t    TX_RATE_11M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (vwrq->bitrate.value == 9000000) {\n\t\t\t\t\t\tpriv->reg.rate_set.body[4] =\n\t\t\t\t\t\t    TX_RATE_9M;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tpriv->reg.rate_set.body[3] =\n\t\t\t\t\t\t    TX_RATE_6M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else {\t \n\t\t\t\t\t\tpriv->reg.rate_set.body[3] =\n\t\t\t\t\t\t    TX_RATE_6M | BASIC_RATE;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 5500000:\n\t\t\t\t\tpriv->reg.rate_set.body[2] =\n\t\t\t\t\t    TX_RATE_5M | BASIC_RATE;\n\t\t\t\t\ti++;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 2000000:\n\t\t\t\t\tpriv->reg.rate_set.body[1] =\n\t\t\t\t\t    TX_RATE_2M | BASIC_RATE;\n\t\t\t\t\ti++;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 1000000:\n\t\t\t\t\tpriv->reg.rate_set.body[0] =\n\t\t\t\t\t    TX_RATE_1M | BASIC_RATE;\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tpriv->reg.tx_rate = TX_RATE_MANUAL_AUTO;\n\t\t\t\tpriv->reg.rate_set.size = i;\n\t\t\t} else {\n\t\t\t\tpriv->reg.rate_set.body[11] = TX_RATE_54M;\n\t\t\t\tpriv->reg.rate_set.body[10] = TX_RATE_48M;\n\t\t\t\tpriv->reg.rate_set.body[9] = TX_RATE_36M;\n\t\t\t\tpriv->reg.rate_set.body[8] = TX_RATE_18M;\n\t\t\t\tpriv->reg.rate_set.body[7] = TX_RATE_9M;\n\t\t\t\tpriv->reg.rate_set.body[6] =\n\t\t\t\t    TX_RATE_24M | BASIC_RATE;\n\t\t\t\tpriv->reg.rate_set.body[5] =\n\t\t\t\t    TX_RATE_12M | BASIC_RATE;\n\t\t\t\tpriv->reg.rate_set.body[4] =\n\t\t\t\t    TX_RATE_6M | BASIC_RATE;\n\t\t\t\tpriv->reg.rate_set.body[3] =\n\t\t\t\t    TX_RATE_11M | BASIC_RATE;\n\t\t\t\tpriv->reg.rate_set.body[2] =\n\t\t\t\t    TX_RATE_5M | BASIC_RATE;\n\t\t\t\tpriv->reg.rate_set.body[1] =\n\t\t\t\t    TX_RATE_2M | BASIC_RATE;\n\t\t\t\tpriv->reg.rate_set.body[0] =\n\t\t\t\t    TX_RATE_1M | BASIC_RATE;\n\t\t\t\tpriv->reg.tx_rate = TX_RATE_FULL_AUTO;\n\t\t\t\tpriv->reg.rate_set.size = 12;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriv->need_commit |= SME_MODE_SET;\n\n\treturn -EINPROGRESS;\t \n}\n\nstatic int ks_wlan_get_rate(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *vwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tnetdev_dbg(dev, \"in_interrupt = %ld update_phyinfo = %d\\n\",\n\t\t   in_interrupt(), atomic_read(&update_phyinfo));\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tif (!atomic_read(&update_phyinfo))\n\t\tks_wlan_update_phy_information(priv);\n\n\tvwrq->bitrate.value = ((priv->current_rate) & RATE_MASK) * 500000;\n\tvwrq->bitrate.fixed = (priv->reg.tx_rate == TX_RATE_FIXED) ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic int ks_wlan_set_rts(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *vwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tint rthr = vwrq->rts.value;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tif (vwrq->rts.disabled)\n\t\trthr = 2347;\n\tif ((rthr < 0) || (rthr > 2347))\n\t\treturn -EINVAL;\n\n\tpriv->reg.rts = rthr;\n\tpriv->need_commit |= SME_RTS;\n\n\treturn -EINPROGRESS;\t \n}\n\nstatic int ks_wlan_get_rts(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *vwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tvwrq->rts.value = priv->reg.rts;\n\tvwrq->rts.disabled = (vwrq->rts.value >= 2347);\n\tvwrq->rts.fixed = 1;\n\n\treturn 0;\n}\n\nstatic int ks_wlan_set_frag(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *vwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tint fthr = vwrq->frag.value;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tif (vwrq->frag.disabled)\n\t\tfthr = 2346;\n\tif ((fthr < 256) || (fthr > 2346))\n\t\treturn -EINVAL;\n\n\tfthr &= ~0x1;\t \n\tpriv->reg.fragment = fthr;\n\tpriv->need_commit |= SME_FRAG;\n\n\treturn -EINPROGRESS;\t \n}\n\nstatic int ks_wlan_get_frag(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *vwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tvwrq->frag.value = priv->reg.fragment;\n\tvwrq->frag.disabled = (vwrq->frag.value >= 2346);\n\tvwrq->frag.fixed = 1;\n\n\treturn 0;\n}\n\nstatic int ks_wlan_set_mode(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\tif (uwrq->mode != IW_MODE_ADHOC &&\n\t    uwrq->mode != IW_MODE_INFRA)\n\t\treturn -EINVAL;\n\n\tpriv->reg.operation_mode = (uwrq->mode == IW_MODE_ADHOC) ?\n\t\t\t\t    MODE_ADHOC : MODE_INFRASTRUCTURE;\n\tpriv->need_commit |= SME_MODE_SET;\n\n\treturn -EINPROGRESS;\t \n}\n\nstatic int ks_wlan_get_mode(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tuwrq->mode = (priv->reg.operation_mode == MODE_INFRASTRUCTURE) ?\n\t\t      IW_MODE_INFRA : IW_MODE_ADHOC;\n\n\treturn 0;\n}\n\nstatic int ks_wlan_set_encode(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tstruct iw_point *enc = &dwrq->encoding;\n\tstruct wep_key key;\n\tint index = (enc->flags & IW_ENCODE_INDEX);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\tif (enc->length > MAX_KEY_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tif ((index < 0) || (index > 4))\n\t\treturn -EINVAL;\n\n\tindex = (index == 0) ? priv->reg.wep_index : (index - 1);\n\n\t \n\t \n\tif (enc->length > 0) {\n\t\tkey.len = (enc->length > MIN_KEY_SIZE) ?\n\t\t\t   MAX_KEY_SIZE : MIN_KEY_SIZE;\n\t\tpriv->reg.privacy_invoked = 0x01;\n\t\tpriv->need_commit |= SME_WEP_FLAG;\n\t\twep_on_off = (enc->length > MIN_KEY_SIZE) ?\n\t\t\t      WEP_ON_128BIT : WEP_ON_64BIT;\n\t\t \n\t\tif (enc->flags & IW_ENCODE_NOKEY)\n\t\t\treturn 0;\n\n\t\t \n\t\tmemset(key.key, 0, MAX_KEY_SIZE);\n\t\t \n\t\tif (copy_from_user(key.key, enc->pointer, enc->length)) {\n\t\t\tkey.len = 0;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\t \n\t\tpriv->reg.wep_key[index].size = key.len;\n\t\tmemcpy(&priv->reg.wep_key[index].val[0], &key.key[0],\n\t\t       priv->reg.wep_key[index].size);\n\t\tpriv->need_commit |= (SME_WEP_VAL1 << index);\n\t\tpriv->reg.wep_index = index;\n\t\tpriv->need_commit |= SME_WEP_INDEX;\n\t} else {\n\t\tif (enc->flags & IW_ENCODE_DISABLED) {\n\t\t\tpriv->reg.wep_key[0].size = 0;\n\t\t\tpriv->reg.wep_key[1].size = 0;\n\t\t\tpriv->reg.wep_key[2].size = 0;\n\t\t\tpriv->reg.wep_key[3].size = 0;\n\t\t\tpriv->reg.privacy_invoked = 0x00;\n\t\t\tif (priv->reg.authenticate_type == AUTH_TYPE_SHARED_KEY)\n\t\t\t\tpriv->need_commit |= SME_MODE_SET;\n\n\t\t\tpriv->reg.authenticate_type = AUTH_TYPE_OPEN_SYSTEM;\n\t\t\twep_on_off = WEP_OFF;\n\t\t\tpriv->need_commit |= SME_WEP_FLAG;\n\t\t} else {\n\t\t\t \n\t\t\tif (priv->reg.wep_key[index].size == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tpriv->reg.wep_index = index;\n\t\t\tpriv->need_commit |= SME_WEP_INDEX;\n\t\t}\n\t}\n\n\t \n\tif (enc->flags & IW_ENCODE_MODE)\n\t\tpriv->need_commit |= SME_WEP_FLAG;\n\n\tif (enc->flags & IW_ENCODE_OPEN) {\n\t\tif (priv->reg.authenticate_type == AUTH_TYPE_SHARED_KEY)\n\t\t\tpriv->need_commit |= SME_MODE_SET;\n\n\t\tpriv->reg.authenticate_type = AUTH_TYPE_OPEN_SYSTEM;\n\t} else if (enc->flags & IW_ENCODE_RESTRICTED) {\n\t\tif (priv->reg.authenticate_type == AUTH_TYPE_OPEN_SYSTEM)\n\t\t\tpriv->need_commit |= SME_MODE_SET;\n\n\t\tpriv->reg.authenticate_type = AUTH_TYPE_SHARED_KEY;\n\t}\n\tif (priv->need_commit) {\n\t\tks_wlan_setup_parameter(priv, priv->need_commit);\n\t\tpriv->need_commit = 0;\n\t}\n\treturn 0;\n}\n\nstatic int ks_wlan_get_encode(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tstruct iw_point *enc = &dwrq->encoding;\n\tint index = (enc->flags & IW_ENCODE_INDEX) - 1;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tenc->flags = IW_ENCODE_DISABLED;\n\n\t \n\tswitch (priv->reg.authenticate_type) {\n\tcase AUTH_TYPE_OPEN_SYSTEM:\n\t\tenc->flags = IW_ENCODE_OPEN;\n\t\tbreak;\n\tcase AUTH_TYPE_SHARED_KEY:\n\t\tenc->flags = IW_ENCODE_RESTRICTED;\n\t\tbreak;\n\t}\n\n\t \n\tif ((index < 0) || (index >= 4))\n\t\tindex = priv->reg.wep_index;\n\tif (priv->reg.privacy_invoked) {\n\t\tenc->flags &= ~IW_ENCODE_DISABLED;\n\t\t \n\t}\n\tenc->flags |= index + 1;\n\t \n\tif (index >= 0 && index < 4) {\n\t\tenc->length = (priv->reg.wep_key[index].size <= 16) ?\n\t\t\t\tpriv->reg.wep_key[index].size : 0;\n\t\tmemcpy(extra, priv->reg.wep_key[index].val, enc->length);\n\t}\n\n\treturn 0;\n}\n\nstatic int ks_wlan_get_range(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tstruct iw_range *range = (struct iw_range *)extra;\n\tint i, k;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tdwrq->data.length = sizeof(struct iw_range);\n\tmemset(range, 0, sizeof(*range));\n\trange->min_nwid = 0x0000;\n\trange->max_nwid = 0x0000;\n\trange->num_channels = 14;\n\t \n\tk = 0;\n\tfor (i = 0; i < 13; i++) {\t \n\t\trange->freq[k].i = i + 1;\t \n\t\trange->freq[k].m = frequency_list[i] * 100000;\n\t\trange->freq[k++].e = 1;\t \n\t}\n\trange->num_frequency = k;\n\tif (priv->reg.phy_type == D_11B_ONLY_MODE ||\n\t    priv->reg.phy_type == D_11BG_COMPATIBLE_MODE) {\t \n\t\trange->freq[13].i = 14;\t \n\t\trange->freq[13].m = frequency_list[13] * 100000;\n\t\trange->freq[13].e = 1;\t \n\t\trange->num_frequency = 14;\n\t}\n\n\t \n\trange->max_qual.qual = 100;\n\trange->max_qual.level = 256 - 128;\t \n\trange->max_qual.noise = 256 - 128;\n\trange->sensitivity = 1;\n\n\tif (priv->reg.phy_type == D_11B_ONLY_MODE) {\n\t\trange->bitrate[0] = 1e6;\n\t\trange->bitrate[1] = 2e6;\n\t\trange->bitrate[2] = 5.5e6;\n\t\trange->bitrate[3] = 11e6;\n\t\trange->num_bitrates = 4;\n\t} else {\t \n\t\trange->bitrate[0] = 1e6;\n\t\trange->bitrate[1] = 2e6;\n\t\trange->bitrate[2] = 5.5e6;\n\t\trange->bitrate[3] = 11e6;\n\n\t\trange->bitrate[4] = 6e6;\n\t\trange->bitrate[5] = 9e6;\n\t\trange->bitrate[6] = 12e6;\n\t\tif (IW_MAX_BITRATES < 9) {\n\t\t\trange->bitrate[7] = 54e6;\n\t\t\trange->num_bitrates = 8;\n\t\t} else {\n\t\t\trange->bitrate[7] = 18e6;\n\t\t\trange->bitrate[8] = 24e6;\n\t\t\trange->bitrate[9] = 36e6;\n\t\t\trange->bitrate[10] = 48e6;\n\t\t\trange->bitrate[11] = 54e6;\n\n\t\t\trange->num_bitrates = 12;\n\t\t}\n\t}\n\n\t \n\tif (i > 2)\n\t\trange->throughput = 5000 * 1000;\n\telse\n\t\trange->throughput = 1500 * 1000;\n\n\trange->min_rts = 0;\n\trange->max_rts = 2347;\n\trange->min_frag = 256;\n\trange->max_frag = 2346;\n\n\trange->encoding_size[0] = 5;\t \n\trange->encoding_size[1] = 13;\t \n\trange->num_encoding_sizes = 2;\n\trange->max_encoding_tokens = 4;\n\n\t \n\trange->pmp_flags = IW_POWER_ON;\n\trange->pmt_flags = IW_POWER_ON;\n\trange->pm_capa = 0;\n\n\t \n\trange->txpower[0] = -256;\n\trange->num_txpower = 1;\n\trange->txpower_capa = IW_TXPOW_DBM;\n\t \n\n\trange->we_version_source = 21;\n\trange->we_version_compiled = WIRELESS_EXT;\n\n\trange->retry_capa = IW_RETRY_ON;\n\trange->retry_flags = IW_RETRY_ON;\n\trange->r_time_flags = IW_RETRY_ON;\n\n\t \n\trange->avg_qual.qual = 50;\n\trange->avg_qual.level = 186;\t \n\trange->avg_qual.noise = 0;\n\n\t \n\trange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWAP) |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWSCAN));\n\trange->event_capa[1] = IW_EVENT_CAPA_K_1;\n\trange->event_capa[4] = (IW_EVENT_CAPA_MASK(IWEVCUSTOM) |\n\t\t\t\tIW_EVENT_CAPA_MASK(IWEVMICHAELMICFAILURE));\n\n\t \n\trange->enc_capa = (IW_ENC_CAPA_WPA |\n\t\t\t   IW_ENC_CAPA_WPA2 |\n\t\t\t   IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP);\n\treturn 0;\n}\n\nstatic int ks_wlan_set_power(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *vwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\tif (vwrq->power.disabled) {\n\t\tpriv->reg.power_mgmt = POWER_MGMT_ACTIVE;\n\t} else {\n\t\tif (priv->reg.operation_mode != MODE_INFRASTRUCTURE)\n\t\t\treturn -EINVAL;\n\t\tpriv->reg.power_mgmt = POWER_MGMT_SAVE1;\n\t}\n\n\thostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);\n\n\treturn 0;\n}\n\nstatic int ks_wlan_get_power(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *vwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tvwrq->power.disabled = (priv->reg.power_mgmt <= 0);\n\n\treturn 0;\n}\n\nstatic int ks_wlan_get_iwstats(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *vwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tvwrq->qual.qual = 0;\t \n\tvwrq->qual.level = priv->wstats.qual.level;\n\tvwrq->qual.noise = 0;\t \n\tvwrq->qual.updated = 0;\n\n\treturn 0;\n}\n\n \nstatic int ks_wlan_get_aplist(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tstruct sockaddr *address = (struct sockaddr *)extra;\n\tstruct iw_quality qual[LOCAL_APLIST_MAX];\n\tint i;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tfor (i = 0; i < priv->aplist.size; i++) {\n\t\tether_addr_copy(address[i].sa_data, priv->aplist.ap[i].bssid);\n\t\taddress[i].sa_family = ARPHRD_ETHER;\n\t\tqual[i].level = 256 - priv->aplist.ap[i].rssi;\n\t\tqual[i].qual = priv->aplist.ap[i].sq;\n\t\tqual[i].noise = 0;\t \n\t\tqual[i].updated = 7;\n\t}\n\tif (i) {\n\t\tdwrq->data.flags = 1;\t \n\t\tmemcpy(extra + sizeof(struct sockaddr) * i,\n\t\t       &qual, sizeof(struct iw_quality) * i);\n\t}\n\tdwrq->data.length = i;\n\n\treturn 0;\n}\n\nstatic int ks_wlan_set_scan(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tstruct iw_scan_req *req = NULL;\n\tint len;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\t \n\tif (wrqu->data.length == sizeof(struct iw_scan_req) &&\n\t    wrqu->data.flags & IW_SCAN_THIS_ESSID) {\n\t\treq = (struct iw_scan_req *)extra;\n\t\tlen = min_t(int, req->essid_len, IW_ESSID_MAX_SIZE);\n\t\tpriv->scan_ssid_len = len;\n\t\tmemcpy(priv->scan_ssid, req->essid, len);\n\t} else {\n\t\tpriv->scan_ssid_len = 0;\n\t}\n\n\tpriv->sme_i.sme_flag |= SME_AP_SCAN;\n\thostif_sme_enqueue(priv, SME_BSS_SCAN_REQUEST);\n\n\t \n\n\treturn 0;\n}\n\nstatic char *ks_wlan_add_leader_event(const char *rsn_leader, char *end_buf,\n\t\t\t\t      char *current_ev, struct rsn_ie *rsn,\n\t\t\t\t      struct iw_event *iwe,\n\t\t\t\t      struct iw_request_info *info)\n{\n\tchar buffer[RSN_IE_BODY_MAX * 2 + 30];\n\tchar *pbuf;\n\tint i;\n\n\tpbuf = &buffer[0];\n\tmemset(iwe, 0, sizeof(*iwe));\n\tiwe->cmd = IWEVCUSTOM;\n\tmemcpy(buffer, rsn_leader, sizeof(rsn_leader) - 1);\n\tiwe->u.data.length += sizeof(rsn_leader) - 1;\n\tpbuf += sizeof(rsn_leader) - 1;\n\tpbuf += sprintf(pbuf, \"%02x\", rsn->id);\n\tpbuf += sprintf(pbuf, \"%02x\", rsn->size);\n\tiwe->u.data.length += 4;\n\n\tfor (i = 0; i < rsn->size; i++)\n\t\tpbuf += sprintf(pbuf, \"%02x\", rsn->body[i]);\n\n\tiwe->u.data.length += rsn->size * 2;\n\n\treturn iwe_stream_add_point(info, current_ev, end_buf, iwe, &buffer[0]);\n}\n\n \nstatic inline char *ks_wlan_translate_scan(struct net_device *dev,\n\t\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t\t   char *current_ev, char *end_buf,\n\t\t\t\t\t   struct local_ap *ap)\n{\n\t \n\tstatic const char rsn_leader[] = \"rsn_ie=\";\n\tstatic const char wpa_leader[] = \"wpa_ie=\";\n\tstruct iw_event iwe;\t \n\tu16 capabilities;\n\tchar *current_val;\t \n\tint i;\n\n\t \n\tiwe.cmd = SIOCGIWAP;\n\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\tether_addr_copy(iwe.u.ap_addr.sa_data, ap->bssid);\n\tcurrent_ev = iwe_stream_add_event(info, current_ev,\n\t\t\t\t\t  end_buf, &iwe, IW_EV_ADDR_LEN);\n\n\t \n\n\t \n\tiwe.u.data.length = ap->ssid.size;\n\tif (iwe.u.data.length > 32)\n\t\tiwe.u.data.length = 32;\n\tiwe.cmd = SIOCGIWESSID;\n\tiwe.u.data.flags = 1;\n\tcurrent_ev = iwe_stream_add_point(info, current_ev,\n\t\t\t\t\t  end_buf, &iwe, ap->ssid.body);\n\n\t \n\tiwe.cmd = SIOCGIWMODE;\n\tcapabilities = ap->capability;\n\tif (capabilities & (WLAN_CAPABILITY_ESS | WLAN_CAPABILITY_IBSS)) {\n\t\tiwe.u.mode = (capabilities & WLAN_CAPABILITY_ESS) ?\n\t\t\t      IW_MODE_INFRA : IW_MODE_ADHOC;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev,\n\t\t\t\t\t\t  end_buf, &iwe, IW_EV_UINT_LEN);\n\t}\n\n\t \n\tiwe.cmd = SIOCGIWFREQ;\n\tiwe.u.freq.m = ap->channel;\n\tiwe.u.freq.m = frequency_list[iwe.u.freq.m - 1] * 100000;\n\tiwe.u.freq.e = 1;\n\tcurrent_ev = iwe_stream_add_event(info, current_ev,\n\t\t\t\t\t  end_buf, &iwe, IW_EV_FREQ_LEN);\n\n\t \n\tiwe.cmd = IWEVQUAL;\n\tiwe.u.qual.level = 256 - ap->rssi;\n\tiwe.u.qual.qual = ap->sq;\n\tiwe.u.qual.noise = 0;\t \n\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, IW_EV_QUAL_LEN);\n\n\t \n\tiwe.cmd = SIOCGIWENCODE;\n\tiwe.u.data.flags = (capabilities & WLAN_CAPABILITY_PRIVACY) ?\n\t\t\t    (IW_ENCODE_ENABLED | IW_ENCODE_NOKEY) :\n\t\t\t     IW_ENCODE_DISABLED;\n\tiwe.u.data.length = 0;\n\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, ap->ssid.body);\n\n\t \n\tcurrent_val = current_ev + IW_EV_LCP_LEN;\n\n\tiwe.cmd = SIOCGIWRATE;\n\n\t \n\tiwe.u.bitrate.fixed = 0;\n\tiwe.u.bitrate.disabled = 0;\n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\t \n\t\tif (i >= ap->rate_set.size)\n\t\t\tbreak;\n\t\t \n\t\tiwe.u.bitrate.value = ((ap->rate_set.body[i] & 0x7f) * 500000);\n\t\t \n\t\tcurrent_val = iwe_stream_add_value(info, current_ev,\n\t\t\t\t\t\t   current_val, end_buf, &iwe,\n\t\t\t\t\t\t   IW_EV_PARAM_LEN);\n\t}\n\t \n\tif ((current_val - current_ev) > IW_EV_LCP_LEN)\n\t\tcurrent_ev = current_val;\n\n\tif (ap->rsn_ie.id == RSN_INFO_ELEM_ID && ap->rsn_ie.size != 0)\n\t\tcurrent_ev = ks_wlan_add_leader_event(rsn_leader, end_buf,\n\t\t\t\t\t\t      current_ev, &ap->rsn_ie,\n\t\t\t\t\t\t      &iwe, info);\n\n\tif (ap->wpa_ie.id == WPA_INFO_ELEM_ID && ap->wpa_ie.size != 0)\n\t\tcurrent_ev = ks_wlan_add_leader_event(wpa_leader, end_buf,\n\t\t\t\t\t\t      current_ev, &ap->wpa_ie,\n\t\t\t\t\t\t      &iwe, info);\n\n\t \n\treturn current_ev;\n}\n\nstatic int ks_wlan_get_scan(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tint i;\n\tchar *current_ev = extra;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tif (priv->sme_i.sme_flag & SME_AP_SCAN)\n\t\treturn -EAGAIN;\n\n\tif (priv->aplist.size == 0) {\n\t\t \n\t\treturn -ENODATA;\n\t}\n\n\t \n\tfor (i = 0; i < priv->aplist.size; i++) {\n\t\tif ((extra + dwrq->data.length) - current_ev <= IW_EV_ADDR_LEN) {\n\t\t\tdwrq->data.length = 0;\n\t\t\treturn -E2BIG;\n\t\t}\n\t\t \n\t\tcurrent_ev = ks_wlan_translate_scan(dev, info, current_ev,\n\t\t\t\t\t\t    extra + dwrq->data.length,\n\t\t\t\t\t\t    &priv->aplist.ap[i]);\n\t}\n\t \n\tdwrq->data.length = (current_ev - extra);\n\tdwrq->data.flags = 0;\n\n\treturn 0;\n}\n\n \nstatic int ks_wlan_config_commit(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *zwrq,\n\t\t\t\t char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (!priv->need_commit)\n\t\treturn 0;\n\n\tks_wlan_setup_parameter(priv, priv->need_commit);\n\tpriv->need_commit = 0;\n\treturn 0;\n}\n\n \nstatic int ks_wlan_set_genie(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\treturn 0;\n\n}\n\nstatic int ks_wlan_set_auth_mode(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *vwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tstruct iw_param *param = &vwrq->param;\n\tint index = (param->flags & IW_AUTH_INDEX);\n\tint value = param->value;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tswitch (index) {\n\tcase IW_AUTH_WPA_VERSION:\t \n\t\tswitch (value) {\n\t\tcase IW_AUTH_WPA_VERSION_DISABLED:\n\t\t\tpriv->wpa.version = value;\n\t\t\tif (priv->wpa.rsn_enabled)\n\t\t\t\tpriv->wpa.rsn_enabled = false;\n\t\t\tpriv->need_commit |= SME_RSN;\n\t\t\tbreak;\n\t\tcase IW_AUTH_WPA_VERSION_WPA:\n\t\tcase IW_AUTH_WPA_VERSION_WPA2:\n\t\t\tpriv->wpa.version = value;\n\t\t\tif (!(priv->wpa.rsn_enabled))\n\t\t\t\tpriv->wpa.rsn_enabled = true;\n\t\t\tpriv->need_commit |= SME_RSN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_CIPHER_PAIRWISE:\t \n\t\tswitch (value) {\n\t\tcase IW_AUTH_CIPHER_NONE:\n\t\t\tif (priv->reg.privacy_invoked) {\n\t\t\t\tpriv->reg.privacy_invoked = 0x00;\n\t\t\t\tpriv->need_commit |= SME_WEP_FLAG;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IW_AUTH_CIPHER_WEP40:\n\t\tcase IW_AUTH_CIPHER_TKIP:\n\t\tcase IW_AUTH_CIPHER_CCMP:\n\t\tcase IW_AUTH_CIPHER_WEP104:\n\t\t\tif (!priv->reg.privacy_invoked) {\n\t\t\t\tpriv->reg.privacy_invoked = 0x01;\n\t\t\t\tpriv->need_commit |= SME_WEP_FLAG;\n\t\t\t}\n\t\t\tpriv->wpa.pairwise_suite = value;\n\t\t\tpriv->need_commit |= SME_RSN_UNICAST;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_CIPHER_GROUP:\t \n\t\tswitch (value) {\n\t\tcase IW_AUTH_CIPHER_NONE:\n\t\t\tif (priv->reg.privacy_invoked) {\n\t\t\t\tpriv->reg.privacy_invoked = 0x00;\n\t\t\t\tpriv->need_commit |= SME_WEP_FLAG;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IW_AUTH_CIPHER_WEP40:\n\t\tcase IW_AUTH_CIPHER_TKIP:\n\t\tcase IW_AUTH_CIPHER_CCMP:\n\t\tcase IW_AUTH_CIPHER_WEP104:\n\t\t\tif (!priv->reg.privacy_invoked) {\n\t\t\t\tpriv->reg.privacy_invoked = 0x01;\n\t\t\t\tpriv->need_commit |= SME_WEP_FLAG;\n\t\t\t}\n\t\t\tpriv->wpa.group_suite = value;\n\t\t\tpriv->need_commit |= SME_RSN_MULTICAST;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\t \n\t\tswitch (value) {\n\t\tcase IW_AUTH_KEY_MGMT_802_1X:\n\t\tcase IW_AUTH_KEY_MGMT_PSK:\n\t\tcase 0:\t \n\t\tcase 4:\t \n\t\t\tpriv->wpa.key_mgmt_suite = value;\n\t\t\tpriv->need_commit |= SME_RSN_AUTH;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\t \n\t\tswitch (value) {\n\t\tcase IW_AUTH_ALG_OPEN_SYSTEM:\n\t\t\tpriv->wpa.auth_alg = value;\n\t\t\tpriv->reg.authenticate_type = AUTH_TYPE_OPEN_SYSTEM;\n\t\t\tbreak;\n\t\tcase IW_AUTH_ALG_SHARED_KEY:\n\t\t\tpriv->wpa.auth_alg = value;\n\t\t\tpriv->reg.authenticate_type = AUTH_TYPE_SHARED_KEY;\n\t\t\tbreak;\n\t\tcase IW_AUTH_ALG_LEAP:\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tpriv->need_commit |= SME_MODE_SET;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\t \n\t\tpriv->wpa.wpa_enabled = value;\n\t\tbreak;\n\tcase IW_AUTH_PRIVACY_INVOKED:\t \n\t\tif ((value && !priv->reg.privacy_invoked) ||\n\t\t    (!value && priv->reg.privacy_invoked)) {\n\t\t\tpriv->reg.privacy_invoked = value ? 0x01 : 0x00;\n\t\t\tpriv->need_commit |= SME_WEP_FLAG;\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\t \n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\t \n\tcase IW_AUTH_DROP_UNENCRYPTED:\t \n\tcase IW_AUTH_ROAMING_CONTROL:\t \n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (priv->need_commit) {\n\t\tks_wlan_setup_parameter(priv, priv->need_commit);\n\t\tpriv->need_commit = 0;\n\t}\n\treturn 0;\n}\n\nstatic int ks_wlan_get_auth_mode(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *vwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tstruct iw_param *param = &vwrq->param;\n\tint index = (param->flags & IW_AUTH_INDEX);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\t \n\tswitch (index) {\n\tcase IW_AUTH_WPA_VERSION:\n\t\tparam->value = priv->wpa.version;\n\t\tbreak;\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\t\tparam->value = priv->wpa.pairwise_suite;\n\t\tbreak;\n\tcase IW_AUTH_CIPHER_GROUP:\n\t\tparam->value = priv->wpa.group_suite;\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\tparam->value = priv->wpa.key_mgmt_suite;\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tparam->value = priv->wpa.auth_alg;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tparam->value = priv->wpa.rsn_enabled;\n\t\tbreak;\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\t \n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int ks_wlan_set_encode_ext(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tstruct iw_encode_ext *enc;\n\tint index = dwrq->encoding.flags & IW_ENCODE_INDEX;\n\tunsigned int commit = 0;\n\tstruct wpa_key *key;\n\n\tenc = (struct iw_encode_ext *)extra;\n\tif (!enc)\n\t\treturn -EINVAL;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tif (index < 1 || index > 4)\n\t\treturn -EINVAL;\n\tindex--;\n\tkey = &priv->wpa.key[index];\n\n\tif (dwrq->encoding.flags & IW_ENCODE_DISABLED)\n\t\tkey->key_len = 0;\n\n\tkey->ext_flags = enc->ext_flags;\n\tif (enc->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\n\t\tpriv->wpa.txkey = index;\n\t\tcommit |= SME_WEP_INDEX;\n\t} else if (enc->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {\n\t\tmemcpy(&key->rx_seq[0], &enc->rx_seq[0], IW_ENCODE_SEQ_MAX_SIZE);\n\t}\n\n\tether_addr_copy(&key->addr.sa_data[0], &enc->addr.sa_data[0]);\n\n\tswitch (enc->alg) {\n\tcase IW_ENCODE_ALG_NONE:\n\t\tif (priv->reg.privacy_invoked) {\n\t\t\tpriv->reg.privacy_invoked = 0x00;\n\t\t\tcommit |= SME_WEP_FLAG;\n\t\t}\n\t\tkey->key_len = 0;\n\n\t\tbreak;\n\tcase IW_ENCODE_ALG_WEP:\n\tcase IW_ENCODE_ALG_CCMP:\n\t\tif (!priv->reg.privacy_invoked) {\n\t\t\tpriv->reg.privacy_invoked = 0x01;\n\t\t\tcommit |= SME_WEP_FLAG;\n\t\t}\n\t\tif (enc->key_len) {\n\t\t\tint key_len = clamp_val(enc->key_len, 0, IW_ENCODING_TOKEN_MAX);\n\n\t\t\tmemcpy(&key->key_val[0], &enc->key[0], key_len);\n\t\t\tkey->key_len = key_len;\n\t\t\tcommit |= (SME_WEP_VAL1 << index);\n\t\t}\n\t\tbreak;\n\tcase IW_ENCODE_ALG_TKIP:\n\t\tif (!priv->reg.privacy_invoked) {\n\t\t\tpriv->reg.privacy_invoked = 0x01;\n\t\t\tcommit |= SME_WEP_FLAG;\n\t\t}\n\t\tif (enc->key_len == 32) {\n\t\t\tmemcpy(&key->key_val[0], &enc->key[0], enc->key_len - 16);\n\t\t\tkey->key_len = enc->key_len - 16;\n\t\t\tif (priv->wpa.key_mgmt_suite == 4) {\t \n\t\t\t\tmemcpy(&key->tx_mic_key[0], &enc->key[16], 8);\n\t\t\t\tmemcpy(&key->rx_mic_key[0], &enc->key[16], 8);\n\t\t\t} else {\n\t\t\t\tmemcpy(&key->tx_mic_key[0], &enc->key[16], 8);\n\t\t\t\tmemcpy(&key->rx_mic_key[0], &enc->key[24], 8);\n\t\t\t}\n\t\t\tcommit |= (SME_WEP_VAL1 << index);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tkey->alg = enc->alg;\n\n\tif (commit) {\n\t\tif (commit & SME_WEP_INDEX)\n\t\t\thostif_sme_enqueue(priv, SME_SET_TXKEY);\n\t\tif (commit & SME_WEP_VAL_MASK)\n\t\t\thostif_sme_enqueue(priv, SME_SET_KEY1 + index);\n\t\tif (commit & SME_WEP_FLAG)\n\t\t\thostif_sme_enqueue(priv, SME_WEP_FLAG_REQUEST);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ks_wlan_get_encode_ext(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\t \n\treturn 0;\n}\n\nstatic int ks_wlan_set_pmksa(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tstruct iw_pmksa *pmksa;\n\tint i;\n\tstruct pmk *pmk;\n\tstruct list_head *ptr;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tif (!extra)\n\t\treturn -EINVAL;\n\n\tpmksa = (struct iw_pmksa *)extra;\n\n\tswitch (pmksa->cmd) {\n\tcase IW_PMKSA_ADD:\n\t\tif (list_empty(&priv->pmklist.head)) {\n\t\t\tfor (i = 0; i < PMK_LIST_MAX; i++) {\n\t\t\t\tpmk = &priv->pmklist.pmk[i];\n\t\t\t\tif (is_zero_ether_addr(pmk->bssid))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tether_addr_copy(pmk->bssid, pmksa->bssid.sa_data);\n\t\t\tmemcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);\n\t\t\tlist_add(&pmk->list, &priv->pmklist.head);\n\t\t\tpriv->pmklist.size++;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tlist_for_each(ptr, &priv->pmklist.head) {\n\t\t\tpmk = list_entry(ptr, struct pmk, list);\n\t\t\tif (ether_addr_equal(pmksa->bssid.sa_data, pmk->bssid)) {\n\t\t\t\tmemcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);\n\t\t\t\tlist_move(&pmk->list, &priv->pmklist.head);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (ptr != &priv->pmklist.head)\n\t\t\tbreak;\n\t\t \n\t\tif (priv->pmklist.size < PMK_LIST_MAX) {\n\t\t\tfor (i = 0; i < PMK_LIST_MAX; i++) {\n\t\t\t\tpmk = &priv->pmklist.pmk[i];\n\t\t\t\tif (is_zero_ether_addr(pmk->bssid))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tether_addr_copy(pmk->bssid, pmksa->bssid.sa_data);\n\t\t\tmemcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);\n\t\t\tlist_add(&pmk->list, &priv->pmklist.head);\n\t\t\tpriv->pmklist.size++;\n\t\t} else {  \n\t\t\tpmk = list_entry(priv->pmklist.head.prev, struct pmk,\n\t\t\t\t\t list);\n\t\t\tether_addr_copy(pmk->bssid, pmksa->bssid.sa_data);\n\t\t\tmemcpy(pmk->pmkid, pmksa->pmkid, IW_PMKID_LEN);\n\t\t\tlist_move(&pmk->list, &priv->pmklist.head);\n\t\t}\n\t\tbreak;\n\tcase IW_PMKSA_REMOVE:\n\t\tif (list_empty(&priv->pmklist.head))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tlist_for_each(ptr, &priv->pmklist.head) {\n\t\t\tpmk = list_entry(ptr, struct pmk, list);\n\t\t\tif (ether_addr_equal(pmksa->bssid.sa_data, pmk->bssid)) {\n\t\t\t\teth_zero_addr(pmk->bssid);\n\t\t\t\tmemset(pmk->pmkid, 0, IW_PMKID_LEN);\n\t\t\t\tlist_del_init(&pmk->list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (ptr == &priv->pmklist.head)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase IW_PMKSA_FLUSH:\n\t\tmemset(&priv->pmklist, 0, sizeof(priv->pmklist));\n\t\tINIT_LIST_HEAD(&priv->pmklist.head);\n\t\tfor (i = 0; i < PMK_LIST_MAX; i++)\n\t\t\tINIT_LIST_HEAD(&priv->pmklist.pmk[i].list);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\thostif_sme_enqueue(priv, SME_SET_PMKSA);\n\treturn 0;\n}\n\nstatic struct iw_statistics *ks_get_wireless_stats(struct net_device *dev)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tstruct iw_statistics *wstats = &priv->wstats;\n\n\tif (!atomic_read(&update_phyinfo))\n\t\treturn (priv->dev_state < DEVICE_STATE_READY) ? NULL : wstats;\n\n\t \n\twstats->discard.nwid = 0;\t \n\twstats->discard.code = 0;\t \n\twstats->discard.fragment = 0;\t \n\twstats->discard.retries = 0;\t \n\twstats->discard.misc = 0;\t \n\twstats->miss.beacon = 0;\t \n\n\treturn wstats;\n}\n\nstatic int ks_wlan_set_stop_request(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tif (!(uwrq->mode))\n\t\treturn -EINVAL;\n\n\thostif_sme_enqueue(priv, SME_STOP_REQUEST);\n\treturn 0;\n}\n\n#include <linux/ieee80211.h>\nstatic int ks_wlan_set_mlme(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *dwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tstruct iw_mlme *mlme = (struct iw_mlme *)extra;\n\tunion iwreq_data uwrq;\n\n\tuwrq.mode = 1;\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\tif (mlme->cmd != IW_MLME_DEAUTH &&\n\t    mlme->cmd != IW_MLME_DISASSOC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (mlme->cmd == IW_MLME_DEAUTH &&\n\t    mlme->reason_code == WLAN_REASON_MIC_FAILURE)\n\t\treturn 0;\n\n\treturn ks_wlan_set_stop_request(dev, NULL, &uwrq, NULL);\n}\n\nstatic int ks_wlan_get_firmware_version(struct net_device *dev,\n\t\t\t\t\tstruct iw_request_info *info,\n\t\t\t\t\tunion iwreq_data *uwrq, char *extra)\n{\n\tstruct iw_point *dwrq = &uwrq->data;\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tdwrq->length = priv->version_size + 1;\n\tstrscpy(extra, priv->firmware_version, dwrq->length);\n\treturn 0;\n}\n\nstatic int ks_wlan_set_preamble(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tif (uwrq->mode != LONG_PREAMBLE && uwrq->mode != SHORT_PREAMBLE)\n\t\treturn -EINVAL;\n\n\tpriv->reg.preamble = uwrq->mode;\n\tpriv->need_commit |= SME_MODE_SET;\n\treturn -EINPROGRESS;\t \n}\n\nstatic int ks_wlan_get_preamble(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tuwrq->mode = priv->reg.preamble;\n\treturn 0;\n}\n\nstatic int ks_wlan_set_power_mgmt(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\tif (uwrq->mode != POWER_MGMT_ACTIVE &&\n\t    uwrq->mode != POWER_MGMT_SAVE1 &&\n\t    uwrq->mode != POWER_MGMT_SAVE2)\n\t\treturn -EINVAL;\n\n\tif ((uwrq->mode == POWER_MGMT_SAVE1 || uwrq->mode == POWER_MGMT_SAVE2) &&\n\t    (priv->reg.operation_mode != MODE_INFRASTRUCTURE))\n\t\treturn -EINVAL;\n\n\tpriv->reg.power_mgmt = uwrq->mode;\n\thostif_sme_enqueue(priv, SME_POW_MNGMT_REQUEST);\n\n\treturn 0;\n}\n\nstatic int ks_wlan_get_power_mgmt(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tuwrq->mode = priv->reg.power_mgmt;\n\treturn 0;\n}\n\nstatic int ks_wlan_set_scan_type(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\n\tif (uwrq->mode != ACTIVE_SCAN && uwrq->mode != PASSIVE_SCAN)\n\t\treturn -EINVAL;\n\n\tpriv->reg.scan_type = uwrq->mode;\n\treturn 0;\n}\n\nstatic int ks_wlan_get_scan_type(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tuwrq->mode = priv->reg.scan_type;\n\treturn 0;\n}\n\nstatic int ks_wlan_set_beacon_lost(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tif (uwrq->mode > BEACON_LOST_COUNT_MAX)\n\t\treturn -EINVAL;\n\n\tpriv->reg.beacon_lost_count = uwrq->mode;\n\n\tif (priv->reg.operation_mode == MODE_INFRASTRUCTURE) {\n\t\tpriv->need_commit |= SME_MODE_SET;\n\t\treturn -EINPROGRESS;\t \n\t}\n\n\treturn 0;\n}\n\nstatic int ks_wlan_get_beacon_lost(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tuwrq->mode = priv->reg.beacon_lost_count;\n\treturn 0;\n}\n\nstatic int ks_wlan_set_phy_type(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\tif (uwrq->mode != D_11B_ONLY_MODE &&\n\t    uwrq->mode != D_11G_ONLY_MODE &&\n\t    uwrq->mode != D_11BG_COMPATIBLE_MODE)\n\t\treturn -EINVAL;\n\n\t \n\tpriv->reg.phy_type = uwrq->mode;\n\tpriv->need_commit |= SME_MODE_SET;\n\treturn -EINPROGRESS;\t \n}\n\nstatic int ks_wlan_get_phy_type(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tuwrq->mode = priv->reg.phy_type;\n\treturn 0;\n}\n\nstatic int ks_wlan_set_cts_mode(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tif (uwrq->mode != CTS_MODE_FALSE && uwrq->mode != CTS_MODE_TRUE)\n\t\treturn -EINVAL;\n\n\tpriv->reg.cts_mode = (uwrq->mode == CTS_MODE_FALSE) ? uwrq->mode :\n\t\t\t      (priv->reg.phy_type == D_11G_ONLY_MODE ||\n\t\t\t       priv->reg.phy_type == D_11BG_COMPATIBLE_MODE) ?\n\t\t\t       uwrq->mode : !uwrq->mode;\n\n\tpriv->need_commit |= SME_MODE_SET;\n\treturn -EINPROGRESS;\t \n}\n\nstatic int ks_wlan_get_cts_mode(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tuwrq->mode = priv->reg.cts_mode;\n\treturn 0;\n}\n\nstatic int ks_wlan_set_sleep_mode(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (uwrq->mode != SLP_SLEEP &&\n\t    uwrq->mode != SLP_ACTIVE) {\n\t\tnetdev_err(dev, \"SET_SLEEP_MODE %d error\\n\", uwrq->mode);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->sleep_mode = uwrq->mode;\n\tnetdev_info(dev, \"SET_SLEEP_MODE %d\\n\", priv->sleep_mode);\n\n\tif (uwrq->mode == SLP_SLEEP)\n\t\thostif_sme_enqueue(priv, SME_STOP_REQUEST);\n\n\thostif_sme_enqueue(priv, SME_SLEEP_REQUEST);\n\n\treturn 0;\n}\n\nstatic int ks_wlan_get_sleep_mode(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tuwrq->mode = priv->sleep_mode;\n\n\treturn 0;\n}\n\nstatic int ks_wlan_set_wps_enable(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tif (uwrq->mode != 0 && uwrq->mode != 1)\n\t\treturn -EINVAL;\n\n\tpriv->wps.wps_enabled = uwrq->mode;\n\thostif_sme_enqueue(priv, SME_WPS_ENABLE_REQUEST);\n\n\treturn 0;\n}\n\nstatic int ks_wlan_get_wps_enable(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tuwrq->mode = priv->wps.wps_enabled;\n\tnetdev_info(dev, \"return=%d\\n\", uwrq->mode);\n\n\treturn 0;\n}\n\nstatic int ks_wlan_set_wps_probe_req(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     union iwreq_data *uwrq, char *extra)\n{\n\tstruct iw_point *dwrq = &uwrq->data;\n\tu8 *p = extra;\n\tunsigned char len;\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\n\t \n\tif (p[1] + 2 != dwrq->length || dwrq->length > 256)\n\t\treturn -EINVAL;\n\n\tpriv->wps.ielen = p[1] + 2 + 1;\t \n\tlen = p[1] + 2;\t \n\n\tmemcpy(priv->wps.ie, &len, sizeof(len));\n\tp = memcpy(priv->wps.ie + 1, p, len);\n\n\tnetdev_dbg(dev, \"%d(%#x): %02X %02X %02X %02X ... %02X %02X %02X\\n\",\n\t\t   priv->wps.ielen, priv->wps.ielen, p[0], p[1], p[2], p[3],\n\t\t   p[priv->wps.ielen - 3], p[priv->wps.ielen - 2],\n\t\t   p[priv->wps.ielen - 1]);\n\n\thostif_sme_enqueue(priv, SME_WPS_PROBE_REQUEST);\n\n\treturn 0;\n}\n\nstatic int ks_wlan_set_tx_gain(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tif (uwrq->mode > 0xFF)\n\t\treturn -EINVAL;\n\n\tpriv->gain.tx_gain = (u8)uwrq->mode;\n\tpriv->gain.tx_mode = (priv->gain.tx_gain < 0xFF) ? 1 : 0;\n\thostif_sme_enqueue(priv, SME_SET_GAIN);\n\treturn 0;\n}\n\nstatic int ks_wlan_get_tx_gain(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tuwrq->mode = priv->gain.tx_gain;\n\thostif_sme_enqueue(priv, SME_GET_GAIN);\n\treturn 0;\n}\n\nstatic int ks_wlan_set_rx_gain(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tif (uwrq->mode > 0xFF)\n\t\treturn -EINVAL;\n\n\tpriv->gain.rx_gain = (u8)uwrq->mode;\n\tpriv->gain.rx_mode = (priv->gain.rx_gain < 0xFF) ? 1 : 0;\n\thostif_sme_enqueue(priv, SME_SET_GAIN);\n\treturn 0;\n}\n\nstatic int ks_wlan_get_rx_gain(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->sleep_mode == SLP_SLEEP)\n\t\treturn -EPERM;\n\t \n\tuwrq->mode = priv->gain.rx_gain;\n\thostif_sme_enqueue(priv, SME_GET_GAIN);\n\treturn 0;\n}\n\nstatic int ks_wlan_get_eeprom_cksum(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *uwrq, char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tuwrq->mode = priv->eeprom_checksum;\n\treturn 0;\n}\n\nstatic void print_hif_event(struct net_device *dev, int event)\n{\n\tswitch (event) {\n\tcase HIF_DATA_REQ:\n\t\tnetdev_info(dev, \"HIF_DATA_REQ\\n\");\n\t\tbreak;\n\tcase HIF_DATA_IND:\n\t\tnetdev_info(dev, \"HIF_DATA_IND\\n\");\n\t\tbreak;\n\tcase HIF_MIB_GET_REQ:\n\t\tnetdev_info(dev, \"HIF_MIB_GET_REQ\\n\");\n\t\tbreak;\n\tcase HIF_MIB_GET_CONF:\n\t\tnetdev_info(dev, \"HIF_MIB_GET_CONF\\n\");\n\t\tbreak;\n\tcase HIF_MIB_SET_REQ:\n\t\tnetdev_info(dev, \"HIF_MIB_SET_REQ\\n\");\n\t\tbreak;\n\tcase HIF_MIB_SET_CONF:\n\t\tnetdev_info(dev, \"HIF_MIB_SET_CONF\\n\");\n\t\tbreak;\n\tcase HIF_POWER_MGMT_REQ:\n\t\tnetdev_info(dev, \"HIF_POWER_MGMT_REQ\\n\");\n\t\tbreak;\n\tcase HIF_POWER_MGMT_CONF:\n\t\tnetdev_info(dev, \"HIF_POWER_MGMT_CONF\\n\");\n\t\tbreak;\n\tcase HIF_START_REQ:\n\t\tnetdev_info(dev, \"HIF_START_REQ\\n\");\n\t\tbreak;\n\tcase HIF_START_CONF:\n\t\tnetdev_info(dev, \"HIF_START_CONF\\n\");\n\t\tbreak;\n\tcase HIF_CONNECT_IND:\n\t\tnetdev_info(dev, \"HIF_CONNECT_IND\\n\");\n\t\tbreak;\n\tcase HIF_STOP_REQ:\n\t\tnetdev_info(dev, \"HIF_STOP_REQ\\n\");\n\t\tbreak;\n\tcase HIF_STOP_CONF:\n\t\tnetdev_info(dev, \"HIF_STOP_CONF\\n\");\n\t\tbreak;\n\tcase HIF_PS_ADH_SET_REQ:\n\t\tnetdev_info(dev, \"HIF_PS_ADH_SET_REQ\\n\");\n\t\tbreak;\n\tcase HIF_PS_ADH_SET_CONF:\n\t\tnetdev_info(dev, \"HIF_PS_ADH_SET_CONF\\n\");\n\t\tbreak;\n\tcase HIF_INFRA_SET_REQ:\n\t\tnetdev_info(dev, \"HIF_INFRA_SET_REQ\\n\");\n\t\tbreak;\n\tcase HIF_INFRA_SET_CONF:\n\t\tnetdev_info(dev, \"HIF_INFRA_SET_CONF\\n\");\n\t\tbreak;\n\tcase HIF_ADH_SET_REQ:\n\t\tnetdev_info(dev, \"HIF_ADH_SET_REQ\\n\");\n\t\tbreak;\n\tcase HIF_ADH_SET_CONF:\n\t\tnetdev_info(dev, \"HIF_ADH_SET_CONF\\n\");\n\t\tbreak;\n\tcase HIF_AP_SET_REQ:\n\t\tnetdev_info(dev, \"HIF_AP_SET_REQ\\n\");\n\t\tbreak;\n\tcase HIF_AP_SET_CONF:\n\t\tnetdev_info(dev, \"HIF_AP_SET_CONF\\n\");\n\t\tbreak;\n\tcase HIF_ASSOC_INFO_IND:\n\t\tnetdev_info(dev, \"HIF_ASSOC_INFO_IND\\n\");\n\t\tbreak;\n\tcase HIF_MIC_FAILURE_REQ:\n\t\tnetdev_info(dev, \"HIF_MIC_FAILURE_REQ\\n\");\n\t\tbreak;\n\tcase HIF_MIC_FAILURE_CONF:\n\t\tnetdev_info(dev, \"HIF_MIC_FAILURE_CONF\\n\");\n\t\tbreak;\n\tcase HIF_SCAN_REQ:\n\t\tnetdev_info(dev, \"HIF_SCAN_REQ\\n\");\n\t\tbreak;\n\tcase HIF_SCAN_CONF:\n\t\tnetdev_info(dev, \"HIF_SCAN_CONF\\n\");\n\t\tbreak;\n\tcase HIF_PHY_INFO_REQ:\n\t\tnetdev_info(dev, \"HIF_PHY_INFO_REQ\\n\");\n\t\tbreak;\n\tcase HIF_PHY_INFO_CONF:\n\t\tnetdev_info(dev, \"HIF_PHY_INFO_CONF\\n\");\n\t\tbreak;\n\tcase HIF_SLEEP_REQ:\n\t\tnetdev_info(dev, \"HIF_SLEEP_REQ\\n\");\n\t\tbreak;\n\tcase HIF_SLEEP_CONF:\n\t\tnetdev_info(dev, \"HIF_SLEEP_CONF\\n\");\n\t\tbreak;\n\tcase HIF_PHY_INFO_IND:\n\t\tnetdev_info(dev, \"HIF_PHY_INFO_IND\\n\");\n\t\tbreak;\n\tcase HIF_SCAN_IND:\n\t\tnetdev_info(dev, \"HIF_SCAN_IND\\n\");\n\t\tbreak;\n\tcase HIF_INFRA_SET2_REQ:\n\t\tnetdev_info(dev, \"HIF_INFRA_SET2_REQ\\n\");\n\t\tbreak;\n\tcase HIF_INFRA_SET2_CONF:\n\t\tnetdev_info(dev, \"HIF_INFRA_SET2_CONF\\n\");\n\t\tbreak;\n\tcase HIF_ADH_SET2_REQ:\n\t\tnetdev_info(dev, \"HIF_ADH_SET2_REQ\\n\");\n\t\tbreak;\n\tcase HIF_ADH_SET2_CONF:\n\t\tnetdev_info(dev, \"HIF_ADH_SET2_CONF\\n\");\n\t}\n}\n\n \nstatic int ks_wlan_hostt(struct net_device *dev, struct iw_request_info *info,\n\t\t\t union iwreq_data *uwrq, char *extra)\n{\n\tint i, event;\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tfor (i = 63; i >= 0; i--) {\n\t\tevent =\n\t\t    priv->hostt.buff[(priv->hostt.qtail - 1 - i) %\n\t\t\t\t     SME_EVENT_BUFF_SIZE];\n\t\tprint_hif_event(dev, event);\n\t}\n\treturn 0;\n}\n\n \n\nstatic const struct iw_priv_args ks_wlan_private_args[] = {\n \n\t{KS_WLAN_GET_FIRM_VERSION, IW_PRIV_TYPE_NONE,\n\t IW_PRIV_TYPE_CHAR | (128 + 1), \"GetFirmwareVer\"},\n\t{KS_WLAN_SET_WPS_ENABLE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t IW_PRIV_TYPE_NONE, \"SetWPSEnable\"},\n\t{KS_WLAN_GET_WPS_ENABLE, IW_PRIV_TYPE_NONE,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"GetW\"},\n\t{KS_WLAN_SET_WPS_PROBE_REQ, IW_PRIV_TYPE_BYTE | 2047, IW_PRIV_TYPE_NONE,\n\t \"SetWPSProbeReq\"},\n\t{KS_WLAN_SET_PREAMBLE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t IW_PRIV_TYPE_NONE, \"SetPreamble\"},\n\t{KS_WLAN_GET_PREAMBLE, IW_PRIV_TYPE_NONE,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"GetPreamble\"},\n\t{KS_WLAN_SET_POWER_SAVE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t IW_PRIV_TYPE_NONE, \"SetPowerSave\"},\n\t{KS_WLAN_GET_POWER_SAVE, IW_PRIV_TYPE_NONE,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"GetPowerSave\"},\n\t{KS_WLAN_SET_SCAN_TYPE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t IW_PRIV_TYPE_NONE, \"SetScanType\"},\n\t{KS_WLAN_GET_SCAN_TYPE, IW_PRIV_TYPE_NONE,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"GetScanType\"},\n\t{KS_WLAN_SET_RX_GAIN, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t IW_PRIV_TYPE_NONE, \"SetRxGain\"},\n\t{KS_WLAN_GET_RX_GAIN, IW_PRIV_TYPE_NONE,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"GetRxGain\"},\n\t{KS_WLAN_HOSTT, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | (128 + 1),\n\t \"hostt\"},\n\t{KS_WLAN_SET_BEACON_LOST, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t IW_PRIV_TYPE_NONE, \"SetBeaconLost\"},\n\t{KS_WLAN_GET_BEACON_LOST, IW_PRIV_TYPE_NONE,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"GetBeaconLost\"},\n\t{KS_WLAN_SET_SLEEP_MODE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t IW_PRIV_TYPE_NONE, \"SetSleepMode\"},\n\t{KS_WLAN_GET_SLEEP_MODE, IW_PRIV_TYPE_NONE,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"GetSleepMode\"},\n\t{KS_WLAN_SET_TX_GAIN, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t IW_PRIV_TYPE_NONE, \"SetTxGain\"},\n\t{KS_WLAN_GET_TX_GAIN, IW_PRIV_TYPE_NONE,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"GetTxGain\"},\n\t{KS_WLAN_SET_PHY_TYPE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t IW_PRIV_TYPE_NONE, \"SetPhyType\"},\n\t{KS_WLAN_GET_PHY_TYPE, IW_PRIV_TYPE_NONE,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"GetPhyType\"},\n\t{KS_WLAN_SET_CTS_MODE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t IW_PRIV_TYPE_NONE, \"SetCtsMode\"},\n\t{KS_WLAN_GET_CTS_MODE, IW_PRIV_TYPE_NONE,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"GetCtsMode\"},\n\t{KS_WLAN_GET_EEPROM_CKSUM, IW_PRIV_TYPE_NONE,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"GetChecksum\"},\n};\n\nstatic const iw_handler ks_wlan_handler[] = {\n\tIW_HANDLER(SIOCSIWCOMMIT, ks_wlan_config_commit),\n\tIW_HANDLER(SIOCGIWNAME, ks_wlan_get_name),\n\tIW_HANDLER(SIOCSIWFREQ, ks_wlan_set_freq),\n\tIW_HANDLER(SIOCGIWFREQ, ks_wlan_get_freq),\n\tIW_HANDLER(SIOCSIWMODE, ks_wlan_set_mode),\n\tIW_HANDLER(SIOCGIWMODE, ks_wlan_get_mode),\n\tIW_HANDLER(SIOCGIWRANGE, ks_wlan_get_range),\n\tIW_HANDLER(SIOCGIWSTATS, ks_wlan_get_iwstats),\n\tIW_HANDLER(SIOCSIWAP, ks_wlan_set_wap),\n\tIW_HANDLER(SIOCGIWAP, ks_wlan_get_wap),\n\tIW_HANDLER(SIOCSIWMLME, ks_wlan_set_mlme),\n\tIW_HANDLER(SIOCGIWAPLIST, ks_wlan_get_aplist),\n\tIW_HANDLER(SIOCSIWSCAN, ks_wlan_set_scan),\n\tIW_HANDLER(SIOCGIWSCAN, ks_wlan_get_scan),\n\tIW_HANDLER(SIOCSIWESSID, ks_wlan_set_essid),\n\tIW_HANDLER(SIOCGIWESSID, ks_wlan_get_essid),\n\tIW_HANDLER(SIOCSIWNICKN, ks_wlan_set_nick),\n\tIW_HANDLER(SIOCGIWNICKN, ks_wlan_get_nick),\n\tIW_HANDLER(SIOCSIWRATE, ks_wlan_set_rate),\n\tIW_HANDLER(SIOCGIWRATE, ks_wlan_get_rate),\n\tIW_HANDLER(SIOCSIWRTS, ks_wlan_set_rts),\n\tIW_HANDLER(SIOCGIWRTS, ks_wlan_get_rts),\n\tIW_HANDLER(SIOCSIWFRAG, ks_wlan_set_frag),\n\tIW_HANDLER(SIOCGIWFRAG, ks_wlan_get_frag),\n\tIW_HANDLER(SIOCSIWENCODE, ks_wlan_set_encode),\n\tIW_HANDLER(SIOCGIWENCODE, ks_wlan_get_encode),\n\tIW_HANDLER(SIOCSIWPOWER, ks_wlan_set_power),\n\tIW_HANDLER(SIOCGIWPOWER, ks_wlan_get_power),\n\tIW_HANDLER(SIOCSIWGENIE, ks_wlan_set_genie),\n\tIW_HANDLER(SIOCSIWAUTH, ks_wlan_set_auth_mode),\n\tIW_HANDLER(SIOCGIWAUTH, ks_wlan_get_auth_mode),\n\tIW_HANDLER(SIOCSIWENCODEEXT, ks_wlan_set_encode_ext),\n\tIW_HANDLER(SIOCGIWENCODEEXT, ks_wlan_get_encode_ext),\n\tIW_HANDLER(SIOCSIWPMKSA, ks_wlan_set_pmksa),\n};\n\n \nstatic const iw_handler ks_wlan_private_handler[] = {\n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tks_wlan_get_firmware_version,\t \n\tks_wlan_set_wps_enable,\t\t \n\tks_wlan_get_wps_enable,\t\t \n\tks_wlan_set_wps_probe_req,\t \n\tks_wlan_get_eeprom_cksum,\t \n\tks_wlan_set_preamble,\t\t \n\tks_wlan_get_preamble,\t\t \n\tks_wlan_set_power_mgmt,\t\t \n\tks_wlan_get_power_mgmt,\t\t \n\tks_wlan_set_scan_type,\t\t \n\tks_wlan_get_scan_type,\t\t \n\tks_wlan_set_rx_gain,\t\t \n\tks_wlan_get_rx_gain,\t\t \n\tks_wlan_hostt,\t\t\t \n\tNULL,\t\t\t\t \n\tks_wlan_set_beacon_lost,\t \n\tks_wlan_get_beacon_lost,\t \n\tks_wlan_set_tx_gain,\t\t \n\tks_wlan_get_tx_gain,\t\t \n\tks_wlan_set_phy_type,\t\t \n\tks_wlan_get_phy_type,\t\t \n\tks_wlan_set_cts_mode,\t\t \n\tks_wlan_get_cts_mode,\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tks_wlan_set_sleep_mode,\t\t \n\tks_wlan_get_sleep_mode,\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n};\n\nstatic const struct iw_handler_def ks_wlan_handler_def = {\n\t.num_standard = ARRAY_SIZE(ks_wlan_handler),\n\t.num_private = ARRAY_SIZE(ks_wlan_private_handler),\n\t.num_private_args = ARRAY_SIZE(ks_wlan_private_args),\n\t.standard = ks_wlan_handler,\n\t.private = ks_wlan_private_handler,\n\t.private_args = ks_wlan_private_args,\n\t.get_wireless_stats = ks_get_wireless_stats,\n};\n\nstatic int ks_wlan_netdev_ioctl(struct net_device *dev, struct ifreq *rq,\n\t\t\t\tint cmd)\n{\n\tint ret;\n\tstruct iwreq *wrq = (struct iwreq *)rq;\n\n\tswitch (cmd) {\n\tcase SIOCIWFIRSTPRIV + 20:\t \n\t\tret = ks_wlan_set_stop_request(dev, NULL, &wrq->u, NULL);\n\t\tbreak;\n\t\t\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic\nstruct net_device_stats *ks_wlan_get_stats(struct net_device *dev)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->dev_state < DEVICE_STATE_READY)\n\t\treturn NULL;\t \n\n\treturn &priv->nstats;\n}\n\nstatic\nint ks_wlan_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tstruct sockaddr *mac_addr = (struct sockaddr *)addr;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\teth_hw_addr_set(dev, mac_addr->sa_data);\n\tether_addr_copy(priv->eth_addr, mac_addr->sa_data);\n\n\tpriv->mac_address_valid = false;\n\thostif_sme_enqueue(priv, SME_MACADDRESS_SET_REQUEST);\n\tnetdev_info(dev, \"ks_wlan:  MAC ADDRESS = %pM\\n\", priv->eth_addr);\n\treturn 0;\n}\n\nstatic\nvoid ks_wlan_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tnetdev_dbg(dev, \"head(%d) tail(%d)!!\\n\", priv->tx_dev.qhead,\n\t\t   priv->tx_dev.qtail);\n\tif (!netif_queue_stopped(dev))\n\t\tnetif_stop_queue(dev);\n\tpriv->nstats.tx_errors++;\n\tnetif_wake_queue(dev);\n}\n\nstatic\nnetdev_tx_t ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\tint ret;\n\n\tnetdev_dbg(dev, \"in_interrupt()=%ld\\n\", in_interrupt());\n\n\tif (!skb) {\n\t\tnetdev_err(dev, \"ks_wlan:  skb == NULL!!!\\n\");\n\t\treturn 0;\n\t}\n\tif (priv->dev_state < DEVICE_STATE_READY) {\n\t\tdev_kfree_skb(skb);\n\t\treturn 0;\t \n\t}\n\n\tif (netif_running(dev))\n\t\tnetif_stop_queue(dev);\n\n\tret = hostif_data_request(priv, skb);\n\tnetif_trans_update(dev);\n\n\tif (ret)\n\t\tnetdev_err(dev, \"hostif_data_request error: =%d\\n\", ret);\n\n\treturn 0;\n}\n\nvoid send_packet_complete(struct ks_wlan_private *priv, struct sk_buff *skb)\n{\n\tpriv->nstats.tx_packets++;\n\n\tif (netif_queue_stopped(priv->net_dev))\n\t\tnetif_wake_queue(priv->net_dev);\n\n\tif (skb) {\n\t\tpriv->nstats.tx_bytes += skb->len;\n\t\tdev_kfree_skb(skb);\n\t}\n}\n\n \nstatic\nvoid ks_wlan_set_rx_mode(struct net_device *dev)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (priv->dev_state < DEVICE_STATE_READY)\n\t\treturn;\t \n\thostif_sme_enqueue(priv, SME_MULTICAST_REQUEST);\n}\n\nstatic\nint ks_wlan_open(struct net_device *dev)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tpriv->cur_rx = 0;\n\n\tif (!priv->mac_address_valid) {\n\t\tnetdev_err(dev, \"ks_wlan : %s Not READY !!\\n\", dev->name);\n\t\treturn -EBUSY;\n\t}\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic\nint ks_wlan_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\n\treturn 0;\n}\n\n \n \n#define TX_TIMEOUT  (3 * HZ)\nstatic const unsigned char dummy_addr[] = {\n\t0x00, 0x0b, 0xe3, 0x00, 0x00, 0x00\n};\n\nstatic const struct net_device_ops ks_wlan_netdev_ops = {\n\t.ndo_start_xmit = ks_wlan_start_xmit,\n\t.ndo_open = ks_wlan_open,\n\t.ndo_stop = ks_wlan_close,\n\t.ndo_do_ioctl = ks_wlan_netdev_ioctl,\n\t.ndo_set_mac_address = ks_wlan_set_mac_address,\n\t.ndo_get_stats = ks_wlan_get_stats,\n\t.ndo_tx_timeout = ks_wlan_tx_timeout,\n\t.ndo_set_rx_mode = ks_wlan_set_rx_mode,\n};\n\nint ks_wlan_net_start(struct net_device *dev)\n{\n\tstruct ks_wlan_private *priv;\n\t \n\n\tpriv = netdev_priv(dev);\n\tpriv->mac_address_valid = false;\n\tpriv->is_device_open = true;\n\tpriv->need_commit = 0;\n\t \n\tatomic_set(&update_phyinfo, 0);\n\ttimer_setup(&update_phyinfo_timer, ks_wlan_update_phyinfo_timeout, 0);\n\n\t \n\tether_addr_copy(priv->eth_addr, dummy_addr);\n\teth_hw_addr_set(dev, priv->eth_addr);\n\n\t \n\tdev->netdev_ops = &ks_wlan_netdev_ops;\n\tdev->wireless_handlers = &ks_wlan_handler_def;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\tnetif_carrier_off(dev);\n\n\treturn 0;\n}\n\nint ks_wlan_net_stop(struct net_device *dev)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tpriv->is_device_open = false;\n\tdel_timer_sync(&update_phyinfo_timer);\n\n\tif (netif_running(dev))\n\t\tnetif_stop_queue(dev);\n\n\treturn 0;\n}\n\n \nbool is_connect_status(u32 status)\n{\n\treturn (status & CONNECT_STATUS_MASK) == CONNECT_STATUS;\n}\n\n \nbool is_disconnect_status(u32 status)\n{\n\treturn (status & CONNECT_STATUS_MASK) == DISCONNECT_STATUS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}