{
  "module_name": "vme_tsi148.c",
  "hash_id": "9bed1ddc5f5623b464af979faf1f3f16524c1ac6803629538ba003902a2c9bb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vme_user/vme_tsi148.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/poll.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/byteorder/generic.h>\n\n#include \"vme.h\"\n#include \"vme_bridge.h\"\n#include \"vme_tsi148.h\"\n\nstatic int tsi148_probe(struct pci_dev *, const struct pci_device_id *);\nstatic void tsi148_remove(struct pci_dev *);\n\n \nstatic bool err_chk;\nstatic int geoid;\n\nstatic const char driver_name[] = \"vme_tsi148\";\n\nstatic const struct pci_device_id tsi148_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TUNDRA, PCI_DEVICE_ID_TUNDRA_TSI148) },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(pci, tsi148_ids);\n\nstatic struct pci_driver tsi148_driver = {\n\t.name = driver_name,\n\t.id_table = tsi148_ids,\n\t.probe = tsi148_probe,\n\t.remove = tsi148_remove,\n};\n\nstatic void reg_join(unsigned int high, unsigned int low,\n\tunsigned long long *variable)\n{\n\t*variable = (unsigned long long)high << 32;\n\t*variable |= (unsigned long long)low;\n}\n\nstatic void reg_split(unsigned long long variable, unsigned int *high,\n\tunsigned int *low)\n{\n\t*low = (unsigned int)variable & 0xFFFFFFFF;\n\t*high = (unsigned int)(variable >> 32);\n}\n\n \nstatic u32 tsi148_DMA_irqhandler(struct tsi148_driver *bridge,\n\tint channel_mask)\n{\n\tu32 serviced = 0;\n\n\tif (channel_mask & TSI148_LCSR_INTS_DMA0S) {\n\t\twake_up(&bridge->dma_queue[0]);\n\t\tserviced |= TSI148_LCSR_INTC_DMA0C;\n\t}\n\tif (channel_mask & TSI148_LCSR_INTS_DMA1S) {\n\t\twake_up(&bridge->dma_queue[1]);\n\t\tserviced |= TSI148_LCSR_INTC_DMA1C;\n\t}\n\n\treturn serviced;\n}\n\n \nstatic u32 tsi148_LM_irqhandler(struct tsi148_driver *bridge, u32 stat)\n{\n\tint i;\n\tu32 serviced = 0;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (stat & TSI148_LCSR_INTS_LMS[i]) {\n\t\t\t \n\t\t\tbridge->lm_callback[i](bridge->lm_data[i]);\n\t\t\tserviced |= TSI148_LCSR_INTC_LMC[i];\n\t\t}\n\t}\n\n\treturn serviced;\n}\n\n \nstatic u32 tsi148_MB_irqhandler(struct vme_bridge *tsi148_bridge, u32 stat)\n{\n\tint i;\n\tu32 val;\n\tu32 serviced = 0;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (stat & TSI148_LCSR_INTS_MBS[i]) {\n\t\t\tval = ioread32be(bridge->base +\tTSI148_GCSR_MBOX[i]);\n\t\t\tdev_err(tsi148_bridge->parent, \"VME Mailbox %d received: 0x%x\\n\",\n\t\t\t\ti, val);\n\t\t\tserviced |= TSI148_LCSR_INTC_MBC[i];\n\t\t}\n\t}\n\n\treturn serviced;\n}\n\n \nstatic u32 tsi148_PERR_irqhandler(struct vme_bridge *tsi148_bridge)\n{\n\tstruct tsi148_driver *bridge;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\tdev_err(tsi148_bridge->parent, \"PCI Exception at address: 0x%08x:%08x, attributes: %08x\\n\",\n\t\tioread32be(bridge->base + TSI148_LCSR_EDPAU),\n\t\tioread32be(bridge->base + TSI148_LCSR_EDPAL),\n\t\tioread32be(bridge->base + TSI148_LCSR_EDPAT));\n\n\tdev_err(tsi148_bridge->parent, \"PCI-X attribute reg: %08x, PCI-X split completion reg: %08x\\n\",\n\t\tioread32be(bridge->base + TSI148_LCSR_EDPXA),\n\t\tioread32be(bridge->base + TSI148_LCSR_EDPXS));\n\n\tiowrite32be(TSI148_LCSR_EDPAT_EDPCL, bridge->base + TSI148_LCSR_EDPAT);\n\n\treturn TSI148_LCSR_INTC_PERRC;\n}\n\n \nstatic u32 tsi148_VERR_irqhandler(struct vme_bridge *tsi148_bridge)\n{\n\tunsigned int error_addr_high, error_addr_low;\n\tunsigned long long error_addr;\n\tu32 error_attrib;\n\tint error_am;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\terror_addr_high = ioread32be(bridge->base + TSI148_LCSR_VEAU);\n\terror_addr_low = ioread32be(bridge->base + TSI148_LCSR_VEAL);\n\terror_attrib = ioread32be(bridge->base + TSI148_LCSR_VEAT);\n\terror_am = (error_attrib & TSI148_LCSR_VEAT_AM_M) >> 8;\n\n\treg_join(error_addr_high, error_addr_low, &error_addr);\n\n\t \n\tif (error_attrib & TSI148_LCSR_VEAT_VEOF)\n\t\tdev_err(tsi148_bridge->parent, \"VME Bus Exception Overflow Occurred\\n\");\n\n\tif (err_chk)\n\t\tvme_bus_error_handler(tsi148_bridge, error_addr, error_am);\n\telse\n\t\tdev_err(tsi148_bridge->parent,\n\t\t\t\"VME Bus Error at address: 0x%llx, attributes: %08x\\n\",\n\t\t\terror_addr, error_attrib);\n\n\t \n\tiowrite32be(TSI148_LCSR_VEAT_VESCL, bridge->base + TSI148_LCSR_VEAT);\n\n\treturn TSI148_LCSR_INTC_VERRC;\n}\n\n \nstatic u32 tsi148_IACK_irqhandler(struct tsi148_driver *bridge)\n{\n\twake_up(&bridge->iack_queue);\n\n\treturn TSI148_LCSR_INTC_IACKC;\n}\n\n \nstatic u32 tsi148_VIRQ_irqhandler(struct vme_bridge *tsi148_bridge,\n\tu32 stat)\n{\n\tint vec, i, serviced = 0;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\tfor (i = 7; i > 0; i--) {\n\t\tif (stat & (1 << i)) {\n\t\t\t \n\t\t\tvec = ioread8(bridge->base + TSI148_LCSR_VIACK[i] + 3);\n\n\t\t\tvme_irq_handler(tsi148_bridge, i, vec);\n\n\t\t\tserviced |= (1 << i);\n\t\t}\n\t}\n\n\treturn serviced;\n}\n\n \nstatic irqreturn_t tsi148_irqhandler(int irq, void *ptr)\n{\n\tu32 stat, enable, serviced = 0;\n\tstruct vme_bridge *tsi148_bridge;\n\tstruct tsi148_driver *bridge;\n\n\ttsi148_bridge = ptr;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\t \n\tenable = ioread32be(bridge->base + TSI148_LCSR_INTEO);\n\tstat = ioread32be(bridge->base + TSI148_LCSR_INTS);\n\n\t \n\tstat &= enable;\n\n\tif (unlikely(!stat))\n\t\treturn IRQ_NONE;\n\n\t \n\t \n\tif (stat & (TSI148_LCSR_INTS_DMA1S | TSI148_LCSR_INTS_DMA0S))\n\t\tserviced |= tsi148_DMA_irqhandler(bridge, stat);\n\n\t \n\tif (stat & (TSI148_LCSR_INTS_LM3S | TSI148_LCSR_INTS_LM2S |\n\t\t\tTSI148_LCSR_INTS_LM1S | TSI148_LCSR_INTS_LM0S))\n\t\tserviced |= tsi148_LM_irqhandler(bridge, stat);\n\n\t \n\tif (stat & (TSI148_LCSR_INTS_MB3S | TSI148_LCSR_INTS_MB2S |\n\t\t\tTSI148_LCSR_INTS_MB1S | TSI148_LCSR_INTS_MB0S))\n\t\tserviced |= tsi148_MB_irqhandler(tsi148_bridge, stat);\n\n\t \n\tif (stat & TSI148_LCSR_INTS_PERRS)\n\t\tserviced |= tsi148_PERR_irqhandler(tsi148_bridge);\n\n\t \n\tif (stat & TSI148_LCSR_INTS_VERRS)\n\t\tserviced |= tsi148_VERR_irqhandler(tsi148_bridge);\n\n\t \n\tif (stat & TSI148_LCSR_INTS_IACKS)\n\t\tserviced |= tsi148_IACK_irqhandler(bridge);\n\n\t \n\tif (stat & (TSI148_LCSR_INTS_IRQ7S | TSI148_LCSR_INTS_IRQ6S |\n\t\t\tTSI148_LCSR_INTS_IRQ5S | TSI148_LCSR_INTS_IRQ4S |\n\t\t\tTSI148_LCSR_INTS_IRQ3S | TSI148_LCSR_INTS_IRQ2S |\n\t\t\tTSI148_LCSR_INTS_IRQ1S))\n\t\tserviced |= tsi148_VIRQ_irqhandler(tsi148_bridge, stat);\n\n\t \n\tiowrite32be(serviced, bridge->base + TSI148_LCSR_INTC);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tsi148_irq_init(struct vme_bridge *tsi148_bridge)\n{\n\tint result;\n\tunsigned int tmp;\n\tstruct pci_dev *pdev;\n\tstruct tsi148_driver *bridge;\n\n\tpdev = to_pci_dev(tsi148_bridge->parent);\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\tresult = request_irq(pdev->irq,\n\t\t\t     tsi148_irqhandler,\n\t\t\t     IRQF_SHARED,\n\t\t\t     driver_name, tsi148_bridge);\n\tif (result) {\n\t\tdev_err(tsi148_bridge->parent, \"Can't get assigned pci irq vector %02X\\n\",\n\t\t\tpdev->irq);\n\t\treturn result;\n\t}\n\n\t \n\ttmp = TSI148_LCSR_INTEO_DMA1EO | TSI148_LCSR_INTEO_DMA0EO |\n\t\tTSI148_LCSR_INTEO_MB3EO | TSI148_LCSR_INTEO_MB2EO |\n\t\tTSI148_LCSR_INTEO_MB1EO | TSI148_LCSR_INTEO_MB0EO |\n\t\tTSI148_LCSR_INTEO_PERREO | TSI148_LCSR_INTEO_VERREO |\n\t\tTSI148_LCSR_INTEO_IACKEO;\n\n\t \n\n\t \n\n\t \n\n\tiowrite32be(tmp, bridge->base + TSI148_LCSR_INTEO);\n\tiowrite32be(tmp, bridge->base + TSI148_LCSR_INTEN);\n\n\treturn 0;\n}\n\nstatic void tsi148_irq_exit(struct vme_bridge *tsi148_bridge,\n\tstruct pci_dev *pdev)\n{\n\tstruct tsi148_driver *bridge = tsi148_bridge->driver_priv;\n\n\t \n\tiowrite32be(0x0, bridge->base + TSI148_LCSR_INTEO);\n\tiowrite32be(0x0, bridge->base + TSI148_LCSR_INTEN);\n\n\t \n\tiowrite32be(0xFFFFFFFF, bridge->base + TSI148_LCSR_INTC);\n\n\t \n\tfree_irq(pdev->irq, tsi148_bridge);\n}\n\n \nstatic int tsi148_iack_received(struct tsi148_driver *bridge)\n{\n\tu32 tmp;\n\n\ttmp = ioread32be(bridge->base + TSI148_LCSR_VICR);\n\n\tif (tmp & TSI148_LCSR_VICR_IRQS)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\n \nstatic void tsi148_irq_set(struct vme_bridge *tsi148_bridge, int level,\n\tint state, int sync)\n{\n\tstruct pci_dev *pdev;\n\tu32 tmp;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\t \n\tif (state == 0) {\n\t\ttmp = ioread32be(bridge->base + TSI148_LCSR_INTEN);\n\t\ttmp &= ~TSI148_LCSR_INTEN_IRQEN[level - 1];\n\t\tiowrite32be(tmp, bridge->base + TSI148_LCSR_INTEN);\n\n\t\ttmp = ioread32be(bridge->base + TSI148_LCSR_INTEO);\n\t\ttmp &= ~TSI148_LCSR_INTEO_IRQEO[level - 1];\n\t\tiowrite32be(tmp, bridge->base + TSI148_LCSR_INTEO);\n\n\t\tif (sync != 0) {\n\t\t\tpdev = to_pci_dev(tsi148_bridge->parent);\n\t\t\tsynchronize_irq(pdev->irq);\n\t\t}\n\t} else {\n\t\ttmp = ioread32be(bridge->base + TSI148_LCSR_INTEO);\n\t\ttmp |= TSI148_LCSR_INTEO_IRQEO[level - 1];\n\t\tiowrite32be(tmp, bridge->base + TSI148_LCSR_INTEO);\n\n\t\ttmp = ioread32be(bridge->base + TSI148_LCSR_INTEN);\n\t\ttmp |= TSI148_LCSR_INTEN_IRQEN[level - 1];\n\t\tiowrite32be(tmp, bridge->base + TSI148_LCSR_INTEN);\n\t}\n}\n\n \nstatic int tsi148_irq_generate(struct vme_bridge *tsi148_bridge, int level,\n\tint statid)\n{\n\tu32 tmp;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\tmutex_lock(&bridge->vme_int);\n\n\t \n\ttmp = ioread32be(bridge->base + TSI148_LCSR_VICR);\n\n\t \n\ttmp = (tmp & ~TSI148_LCSR_VICR_STID_M) |\n\t\t(statid & TSI148_LCSR_VICR_STID_M);\n\tiowrite32be(tmp, bridge->base + TSI148_LCSR_VICR);\n\n\t \n\ttmp = tmp | TSI148_LCSR_VICR_IRQL[level];\n\tiowrite32be(tmp, bridge->base + TSI148_LCSR_VICR);\n\n\t \n\twait_event_interruptible(bridge->iack_queue,\n\t\ttsi148_iack_received(bridge));\n\n\tmutex_unlock(&bridge->vme_int);\n\n\treturn 0;\n}\n\n \nstatic int tsi148_slave_set(struct vme_slave_resource *image, int enabled,\n\tunsigned long long vme_base, unsigned long long size,\n\tdma_addr_t pci_base, u32 aspace, u32 cycle)\n{\n\tunsigned int i, addr = 0, granularity = 0;\n\tunsigned int temp_ctl = 0;\n\tunsigned int vme_base_low, vme_base_high;\n\tunsigned int vme_bound_low, vme_bound_high;\n\tunsigned int pci_offset_low, pci_offset_high;\n\tunsigned long long vme_bound, pci_offset;\n\tstruct vme_bridge *tsi148_bridge;\n\tstruct tsi148_driver *bridge;\n\n\ttsi148_bridge = image->parent;\n\tbridge = tsi148_bridge->driver_priv;\n\n\ti = image->number;\n\n\tswitch (aspace) {\n\tcase VME_A16:\n\t\tgranularity = 0x10;\n\t\taddr |= TSI148_LCSR_ITAT_AS_A16;\n\t\tbreak;\n\tcase VME_A24:\n\t\tgranularity = 0x1000;\n\t\taddr |= TSI148_LCSR_ITAT_AS_A24;\n\t\tbreak;\n\tcase VME_A32:\n\t\tgranularity = 0x10000;\n\t\taddr |= TSI148_LCSR_ITAT_AS_A32;\n\t\tbreak;\n\tcase VME_A64:\n\t\tgranularity = 0x10000;\n\t\taddr |= TSI148_LCSR_ITAT_AS_A64;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tsi148_bridge->parent, \"Invalid address space\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treg_split(vme_base, &vme_base_high, &vme_base_low);\n\n\t \n\tvme_bound = vme_base + size - granularity;\n\treg_split(vme_bound, &vme_bound_high, &vme_bound_low);\n\tpci_offset = (unsigned long long)pci_base - vme_base;\n\treg_split(pci_offset, &pci_offset_high, &pci_offset_low);\n\n\tif (vme_base_low & (granularity - 1)) {\n\t\tdev_err(tsi148_bridge->parent, \"Invalid VME base alignment\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (vme_bound_low & (granularity - 1)) {\n\t\tdev_err(tsi148_bridge->parent, \"Invalid VME bound alignment\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (pci_offset_low & (granularity - 1)) {\n\t\tdev_err(tsi148_bridge->parent, \"Invalid PCI Offset alignment\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttemp_ctl = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITAT);\n\ttemp_ctl &= ~TSI148_LCSR_ITAT_EN;\n\tiowrite32be(temp_ctl, bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITAT);\n\n\t \n\tiowrite32be(vme_base_high, bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITSAU);\n\tiowrite32be(vme_base_low, bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITSAL);\n\tiowrite32be(vme_bound_high, bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITEAU);\n\tiowrite32be(vme_bound_low, bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITEAL);\n\tiowrite32be(pci_offset_high, bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITOFU);\n\tiowrite32be(pci_offset_low, bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITOFL);\n\n\t \n\ttemp_ctl &= ~TSI148_LCSR_ITAT_2eSSTM_M;\n\tswitch (cycle & (VME_2eSST160 | VME_2eSST267 | VME_2eSST320)) {\n\tcase VME_2eSST160:\n\t\ttemp_ctl |= TSI148_LCSR_ITAT_2eSSTM_160;\n\t\tbreak;\n\tcase VME_2eSST267:\n\t\ttemp_ctl |= TSI148_LCSR_ITAT_2eSSTM_267;\n\t\tbreak;\n\tcase VME_2eSST320:\n\t\ttemp_ctl |= TSI148_LCSR_ITAT_2eSSTM_320;\n\t\tbreak;\n\t}\n\n\t \n\ttemp_ctl &= ~(0x1F << 7);\n\tif (cycle & VME_BLT)\n\t\ttemp_ctl |= TSI148_LCSR_ITAT_BLT;\n\tif (cycle & VME_MBLT)\n\t\ttemp_ctl |= TSI148_LCSR_ITAT_MBLT;\n\tif (cycle & VME_2eVME)\n\t\ttemp_ctl |= TSI148_LCSR_ITAT_2eVME;\n\tif (cycle & VME_2eSST)\n\t\ttemp_ctl |= TSI148_LCSR_ITAT_2eSST;\n\tif (cycle & VME_2eSSTB)\n\t\ttemp_ctl |= TSI148_LCSR_ITAT_2eSSTB;\n\n\t \n\ttemp_ctl &= ~TSI148_LCSR_ITAT_AS_M;\n\ttemp_ctl |= addr;\n\n\ttemp_ctl &= ~0xF;\n\tif (cycle & VME_SUPER)\n\t\ttemp_ctl |= TSI148_LCSR_ITAT_SUPR;\n\tif (cycle & VME_USER)\n\t\ttemp_ctl |= TSI148_LCSR_ITAT_NPRIV;\n\tif (cycle & VME_PROG)\n\t\ttemp_ctl |= TSI148_LCSR_ITAT_PGM;\n\tif (cycle & VME_DATA)\n\t\ttemp_ctl |= TSI148_LCSR_ITAT_DATA;\n\n\t \n\tiowrite32be(temp_ctl, bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITAT);\n\n\tif (enabled)\n\t\ttemp_ctl |= TSI148_LCSR_ITAT_EN;\n\n\tiowrite32be(temp_ctl, bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITAT);\n\n\treturn 0;\n}\n\n \nstatic int tsi148_slave_get(struct vme_slave_resource *image, int *enabled,\n\tunsigned long long *vme_base, unsigned long long *size,\n\tdma_addr_t *pci_base, u32 *aspace, u32 *cycle)\n{\n\tunsigned int i, granularity = 0, ctl = 0;\n\tunsigned int vme_base_low, vme_base_high;\n\tunsigned int vme_bound_low, vme_bound_high;\n\tunsigned int pci_offset_low, pci_offset_high;\n\tunsigned long long vme_bound, pci_offset;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = image->parent->driver_priv;\n\n\ti = image->number;\n\n\t \n\tctl = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITAT);\n\n\tvme_base_high = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITSAU);\n\tvme_base_low = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITSAL);\n\tvme_bound_high = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITEAU);\n\tvme_bound_low = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITEAL);\n\tpci_offset_high = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITOFU);\n\tpci_offset_low = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\n\t\tTSI148_LCSR_OFFSET_ITOFL);\n\n\t \n\treg_join(vme_base_high, vme_base_low, vme_base);\n\treg_join(vme_bound_high, vme_bound_low, &vme_bound);\n\treg_join(pci_offset_high, pci_offset_low, &pci_offset);\n\n\t*pci_base = (dma_addr_t)(*vme_base + pci_offset);\n\n\t*enabled = 0;\n\t*aspace = 0;\n\t*cycle = 0;\n\n\tif (ctl & TSI148_LCSR_ITAT_EN)\n\t\t*enabled = 1;\n\n\tif ((ctl & TSI148_LCSR_ITAT_AS_M) == TSI148_LCSR_ITAT_AS_A16) {\n\t\tgranularity = 0x10;\n\t\t*aspace |= VME_A16;\n\t}\n\tif ((ctl & TSI148_LCSR_ITAT_AS_M) == TSI148_LCSR_ITAT_AS_A24) {\n\t\tgranularity = 0x1000;\n\t\t*aspace |= VME_A24;\n\t}\n\tif ((ctl & TSI148_LCSR_ITAT_AS_M) == TSI148_LCSR_ITAT_AS_A32) {\n\t\tgranularity = 0x10000;\n\t\t*aspace |= VME_A32;\n\t}\n\tif ((ctl & TSI148_LCSR_ITAT_AS_M) == TSI148_LCSR_ITAT_AS_A64) {\n\t\tgranularity = 0x10000;\n\t\t*aspace |= VME_A64;\n\t}\n\n\t \n\t*size = (unsigned long long)((vme_bound - *vme_base) + granularity);\n\n\tif ((ctl & TSI148_LCSR_ITAT_2eSSTM_M) == TSI148_LCSR_ITAT_2eSSTM_160)\n\t\t*cycle |= VME_2eSST160;\n\tif ((ctl & TSI148_LCSR_ITAT_2eSSTM_M) == TSI148_LCSR_ITAT_2eSSTM_267)\n\t\t*cycle |= VME_2eSST267;\n\tif ((ctl & TSI148_LCSR_ITAT_2eSSTM_M) == TSI148_LCSR_ITAT_2eSSTM_320)\n\t\t*cycle |= VME_2eSST320;\n\n\tif (ctl & TSI148_LCSR_ITAT_BLT)\n\t\t*cycle |= VME_BLT;\n\tif (ctl & TSI148_LCSR_ITAT_MBLT)\n\t\t*cycle |= VME_MBLT;\n\tif (ctl & TSI148_LCSR_ITAT_2eVME)\n\t\t*cycle |= VME_2eVME;\n\tif (ctl & TSI148_LCSR_ITAT_2eSST)\n\t\t*cycle |= VME_2eSST;\n\tif (ctl & TSI148_LCSR_ITAT_2eSSTB)\n\t\t*cycle |= VME_2eSSTB;\n\n\tif (ctl & TSI148_LCSR_ITAT_SUPR)\n\t\t*cycle |= VME_SUPER;\n\tif (ctl & TSI148_LCSR_ITAT_NPRIV)\n\t\t*cycle |= VME_USER;\n\tif (ctl & TSI148_LCSR_ITAT_PGM)\n\t\t*cycle |= VME_PROG;\n\tif (ctl & TSI148_LCSR_ITAT_DATA)\n\t\t*cycle |= VME_DATA;\n\n\treturn 0;\n}\n\n \nstatic int tsi148_alloc_resource(struct vme_master_resource *image,\n\tunsigned long long size)\n{\n\tunsigned long long existing_size;\n\tint retval = 0;\n\tstruct pci_dev *pdev;\n\tstruct vme_bridge *tsi148_bridge;\n\n\ttsi148_bridge = image->parent;\n\n\tpdev = to_pci_dev(tsi148_bridge->parent);\n\n\texisting_size = (unsigned long long)(image->bus_resource.end -\n\t\timage->bus_resource.start);\n\n\t \n\tif ((size != 0) && (existing_size == (size - 1)))\n\t\treturn 0;\n\n\tif (existing_size != 0) {\n\t\tiounmap(image->kern_base);\n\t\timage->kern_base = NULL;\n\t\tkfree(image->bus_resource.name);\n\t\trelease_resource(&image->bus_resource);\n\t\tmemset(&image->bus_resource, 0, sizeof(image->bus_resource));\n\t}\n\n\t \n\tif (size == 0)\n\t\treturn 0;\n\n\tif (!image->bus_resource.name) {\n\t\timage->bus_resource.name = kmalloc(VMENAMSIZ + 3, GFP_ATOMIC);\n\t\tif (!image->bus_resource.name) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_name;\n\t\t}\n\t}\n\n\tsprintf((char *)image->bus_resource.name, \"%s.%d\", tsi148_bridge->name,\n\t\timage->number);\n\n\timage->bus_resource.start = 0;\n\timage->bus_resource.end = (unsigned long)size;\n\timage->bus_resource.flags = IORESOURCE_MEM;\n\n\tretval = pci_bus_alloc_resource(pdev->bus,\n\t\t&image->bus_resource, size, 0x10000, PCIBIOS_MIN_MEM,\n\t\t0, NULL, NULL);\n\tif (retval) {\n\t\tdev_err(tsi148_bridge->parent, \"Failed to allocate mem resource for window %d size 0x%lx start 0x%lx\\n\",\n\t\t\timage->number, (unsigned long)size,\n\t\t\t(unsigned long)image->bus_resource.start);\n\t\tgoto err_resource;\n\t}\n\n\timage->kern_base = ioremap(\n\t\timage->bus_resource.start, size);\n\tif (!image->kern_base) {\n\t\tdev_err(tsi148_bridge->parent, \"Failed to remap resource\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto err_remap;\n\t}\n\n\treturn 0;\n\nerr_remap:\n\trelease_resource(&image->bus_resource);\nerr_resource:\n\tkfree(image->bus_resource.name);\n\tmemset(&image->bus_resource, 0, sizeof(image->bus_resource));\nerr_name:\n\treturn retval;\n}\n\n \nstatic void tsi148_free_resource(struct vme_master_resource *image)\n{\n\tiounmap(image->kern_base);\n\timage->kern_base = NULL;\n\trelease_resource(&image->bus_resource);\n\tkfree(image->bus_resource.name);\n\tmemset(&image->bus_resource, 0, sizeof(image->bus_resource));\n}\n\n \nstatic int tsi148_master_set(struct vme_master_resource *image, int enabled,\n\tunsigned long long vme_base, unsigned long long size, u32 aspace,\n\tu32 cycle, u32 dwidth)\n{\n\tint retval = 0;\n\tunsigned int i;\n\tunsigned int temp_ctl = 0;\n\tunsigned int pci_base_low, pci_base_high;\n\tunsigned int pci_bound_low, pci_bound_high;\n\tunsigned int vme_offset_low, vme_offset_high;\n\tunsigned long long pci_bound, vme_offset, pci_base;\n\tstruct vme_bridge *tsi148_bridge;\n\tstruct tsi148_driver *bridge;\n\tstruct pci_bus_region region;\n\tstruct pci_dev *pdev;\n\n\ttsi148_bridge = image->parent;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\tpdev = to_pci_dev(tsi148_bridge->parent);\n\n\t \n\tif (vme_base & 0xFFFF) {\n\t\tdev_err(tsi148_bridge->parent, \"Invalid VME Window alignment\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_window;\n\t}\n\n\tif ((size == 0) && (enabled != 0)) {\n\t\tdev_err(tsi148_bridge->parent, \"Size must be non-zero for enabled windows\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_window;\n\t}\n\n\tspin_lock(&image->lock);\n\n\t \n\tretval = tsi148_alloc_resource(image, size);\n\tif (retval) {\n\t\tspin_unlock(&image->lock);\n\t\tdev_err(tsi148_bridge->parent, \"Unable to allocate memory for resource\\n\");\n\t\tgoto err_res;\n\t}\n\n\tif (size == 0) {\n\t\tpci_base = 0;\n\t\tpci_bound = 0;\n\t\tvme_offset = 0;\n\t} else {\n\t\tpcibios_resource_to_bus(pdev->bus, &region,\n\t\t\t\t\t&image->bus_resource);\n\t\tpci_base = region.start;\n\n\t\t \n\t\tpci_bound = pci_base + (size - 0x10000);\n\t\tvme_offset = vme_base - pci_base;\n\t}\n\n\t \n\treg_split(pci_base, &pci_base_high, &pci_base_low);\n\treg_split(pci_bound, &pci_bound_high, &pci_bound_low);\n\treg_split(vme_offset, &vme_offset_high, &vme_offset_low);\n\n\tif (pci_base_low & 0xFFFF) {\n\t\tspin_unlock(&image->lock);\n\t\tdev_err(tsi148_bridge->parent, \"Invalid PCI base alignment\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_gran;\n\t}\n\tif (pci_bound_low & 0xFFFF) {\n\t\tspin_unlock(&image->lock);\n\t\tdev_err(tsi148_bridge->parent, \"Invalid PCI bound alignment\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_gran;\n\t}\n\tif (vme_offset_low & 0xFFFF) {\n\t\tspin_unlock(&image->lock);\n\t\tdev_err(tsi148_bridge->parent, \"Invalid VME Offset alignment\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_gran;\n\t}\n\n\ti = image->number;\n\n\t \n\ttemp_ctl = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTAT);\n\ttemp_ctl &= ~TSI148_LCSR_OTAT_EN;\n\tiowrite32be(temp_ctl, bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTAT);\n\n\t \n\ttemp_ctl &= ~TSI148_LCSR_OTAT_2eSSTM_M;\n\tswitch (cycle & (VME_2eSST160 | VME_2eSST267 | VME_2eSST320)) {\n\tcase VME_2eSST160:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_2eSSTM_160;\n\t\tbreak;\n\tcase VME_2eSST267:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_2eSSTM_267;\n\t\tbreak;\n\tcase VME_2eSST320:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_2eSSTM_320;\n\t\tbreak;\n\t}\n\n\t \n\tif (cycle & VME_BLT) {\n\t\ttemp_ctl &= ~TSI148_LCSR_OTAT_TM_M;\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_TM_BLT;\n\t}\n\tif (cycle & VME_MBLT) {\n\t\ttemp_ctl &= ~TSI148_LCSR_OTAT_TM_M;\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_TM_MBLT;\n\t}\n\tif (cycle & VME_2eVME) {\n\t\ttemp_ctl &= ~TSI148_LCSR_OTAT_TM_M;\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_TM_2eVME;\n\t}\n\tif (cycle & VME_2eSST) {\n\t\ttemp_ctl &= ~TSI148_LCSR_OTAT_TM_M;\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_TM_2eSST;\n\t}\n\tif (cycle & VME_2eSSTB) {\n\t\tdev_warn(tsi148_bridge->parent, \"Currently not setting Broadcast Select Registers\\n\");\n\t\ttemp_ctl &= ~TSI148_LCSR_OTAT_TM_M;\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_TM_2eSSTB;\n\t}\n\n\t \n\ttemp_ctl &= ~TSI148_LCSR_OTAT_DBW_M;\n\tswitch (dwidth) {\n\tcase VME_D16:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_DBW_16;\n\t\tbreak;\n\tcase VME_D32:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_DBW_32;\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock(&image->lock);\n\t\tdev_err(tsi148_bridge->parent, \"Invalid data width\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_dwidth;\n\t}\n\n\t \n\ttemp_ctl &= ~TSI148_LCSR_OTAT_AMODE_M;\n\tswitch (aspace) {\n\tcase VME_A16:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_AMODE_A16;\n\t\tbreak;\n\tcase VME_A24:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_AMODE_A24;\n\t\tbreak;\n\tcase VME_A32:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_AMODE_A32;\n\t\tbreak;\n\tcase VME_A64:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_AMODE_A64;\n\t\tbreak;\n\tcase VME_CRCSR:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_AMODE_CRCSR;\n\t\tbreak;\n\tcase VME_USER1:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_AMODE_USER1;\n\t\tbreak;\n\tcase VME_USER2:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_AMODE_USER2;\n\t\tbreak;\n\tcase VME_USER3:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_AMODE_USER3;\n\t\tbreak;\n\tcase VME_USER4:\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_AMODE_USER4;\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock(&image->lock);\n\t\tdev_err(tsi148_bridge->parent, \"Invalid address space\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_aspace;\n\t}\n\n\ttemp_ctl &= ~(3 << 4);\n\tif (cycle & VME_SUPER)\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_SUP;\n\tif (cycle & VME_PROG)\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_PGM;\n\n\t \n\tiowrite32be(pci_base_high, bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTSAU);\n\tiowrite32be(pci_base_low, bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTSAL);\n\tiowrite32be(pci_bound_high, bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTEAU);\n\tiowrite32be(pci_bound_low, bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTEAL);\n\tiowrite32be(vme_offset_high, bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTOFU);\n\tiowrite32be(vme_offset_low, bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTOFL);\n\n\t \n\tiowrite32be(temp_ctl, bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTAT);\n\n\tif (enabled)\n\t\ttemp_ctl |= TSI148_LCSR_OTAT_EN;\n\n\tiowrite32be(temp_ctl, bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTAT);\n\n\tspin_unlock(&image->lock);\n\treturn 0;\n\nerr_aspace:\nerr_dwidth:\nerr_gran:\n\ttsi148_free_resource(image);\nerr_res:\nerr_window:\n\treturn retval;\n}\n\n \nstatic int __tsi148_master_get(struct vme_master_resource *image, int *enabled,\n\tunsigned long long *vme_base, unsigned long long *size, u32 *aspace,\n\tu32 *cycle, u32 *dwidth)\n{\n\tunsigned int i, ctl;\n\tunsigned int pci_base_low, pci_base_high;\n\tunsigned int pci_bound_low, pci_bound_high;\n\tunsigned int vme_offset_low, vme_offset_high;\n\n\tunsigned long long pci_base, pci_bound, vme_offset;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = image->parent->driver_priv;\n\n\ti = image->number;\n\n\tctl = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTAT);\n\n\tpci_base_high = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTSAU);\n\tpci_base_low = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTSAL);\n\tpci_bound_high = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTEAU);\n\tpci_bound_low = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTEAL);\n\tvme_offset_high = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTOFU);\n\tvme_offset_low = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTOFL);\n\n\t \n\treg_join(pci_base_high, pci_base_low, &pci_base);\n\treg_join(pci_bound_high, pci_bound_low, &pci_bound);\n\treg_join(vme_offset_high, vme_offset_low, &vme_offset);\n\n\t*vme_base = pci_base + vme_offset;\n\t*size = (unsigned long long)(pci_bound - pci_base) + 0x10000;\n\n\t*enabled = 0;\n\t*aspace = 0;\n\t*cycle = 0;\n\t*dwidth = 0;\n\n\tif (ctl & TSI148_LCSR_OTAT_EN)\n\t\t*enabled = 1;\n\n\t \n\tif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_A16)\n\t\t*aspace |= VME_A16;\n\tif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_A24)\n\t\t*aspace |= VME_A24;\n\tif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_A32)\n\t\t*aspace |= VME_A32;\n\tif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_A64)\n\t\t*aspace |= VME_A64;\n\tif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_CRCSR)\n\t\t*aspace |= VME_CRCSR;\n\tif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_USER1)\n\t\t*aspace |= VME_USER1;\n\tif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_USER2)\n\t\t*aspace |= VME_USER2;\n\tif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_USER3)\n\t\t*aspace |= VME_USER3;\n\tif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_USER4)\n\t\t*aspace |= VME_USER4;\n\n\t \n\tif ((ctl & TSI148_LCSR_OTAT_2eSSTM_M) == TSI148_LCSR_OTAT_2eSSTM_160)\n\t\t*cycle |= VME_2eSST160;\n\tif ((ctl & TSI148_LCSR_OTAT_2eSSTM_M) == TSI148_LCSR_OTAT_2eSSTM_267)\n\t\t*cycle |= VME_2eSST267;\n\tif ((ctl & TSI148_LCSR_OTAT_2eSSTM_M) == TSI148_LCSR_OTAT_2eSSTM_320)\n\t\t*cycle |= VME_2eSST320;\n\n\t \n\tif ((ctl & TSI148_LCSR_OTAT_TM_M) == TSI148_LCSR_OTAT_TM_SCT)\n\t\t*cycle |= VME_SCT;\n\tif ((ctl & TSI148_LCSR_OTAT_TM_M) == TSI148_LCSR_OTAT_TM_BLT)\n\t\t*cycle |= VME_BLT;\n\tif ((ctl & TSI148_LCSR_OTAT_TM_M) == TSI148_LCSR_OTAT_TM_MBLT)\n\t\t*cycle |= VME_MBLT;\n\tif ((ctl & TSI148_LCSR_OTAT_TM_M) == TSI148_LCSR_OTAT_TM_2eVME)\n\t\t*cycle |= VME_2eVME;\n\tif ((ctl & TSI148_LCSR_OTAT_TM_M) == TSI148_LCSR_OTAT_TM_2eSST)\n\t\t*cycle |= VME_2eSST;\n\tif ((ctl & TSI148_LCSR_OTAT_TM_M) == TSI148_LCSR_OTAT_TM_2eSSTB)\n\t\t*cycle |= VME_2eSSTB;\n\n\tif (ctl & TSI148_LCSR_OTAT_SUP)\n\t\t*cycle |= VME_SUPER;\n\telse\n\t\t*cycle |= VME_USER;\n\n\tif (ctl & TSI148_LCSR_OTAT_PGM)\n\t\t*cycle |= VME_PROG;\n\telse\n\t\t*cycle |= VME_DATA;\n\n\t \n\tif ((ctl & TSI148_LCSR_OTAT_DBW_M) == TSI148_LCSR_OTAT_DBW_16)\n\t\t*dwidth = VME_D16;\n\tif ((ctl & TSI148_LCSR_OTAT_DBW_M) == TSI148_LCSR_OTAT_DBW_32)\n\t\t*dwidth = VME_D32;\n\n\treturn 0;\n}\n\nstatic int tsi148_master_get(struct vme_master_resource *image, int *enabled,\n\tunsigned long long *vme_base, unsigned long long *size, u32 *aspace,\n\tu32 *cycle, u32 *dwidth)\n{\n\tint retval;\n\n\tspin_lock(&image->lock);\n\n\tretval = __tsi148_master_get(image, enabled, vme_base, size, aspace,\n\t\tcycle, dwidth);\n\n\tspin_unlock(&image->lock);\n\n\treturn retval;\n}\n\nstatic ssize_t tsi148_master_read(struct vme_master_resource *image, void *buf,\n\tsize_t count, loff_t offset)\n{\n\tint retval, enabled;\n\tunsigned long long vme_base, size;\n\tu32 aspace, cycle, dwidth;\n\tstruct vme_error_handler *handler = NULL;\n\tstruct vme_bridge *tsi148_bridge;\n\tvoid __iomem *addr = image->kern_base + offset;\n\tunsigned int done = 0;\n\tunsigned int count32;\n\n\ttsi148_bridge = image->parent;\n\n\tspin_lock(&image->lock);\n\n\tif (err_chk) {\n\t\t__tsi148_master_get(image, &enabled, &vme_base, &size, &aspace,\n\t\t\t\t    &cycle, &dwidth);\n\t\thandler = vme_register_error_handler(tsi148_bridge, aspace,\n\t\t\t\t\t\t     vme_base + offset, count);\n\t\tif (!handler) {\n\t\t\tspin_unlock(&image->lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tif ((uintptr_t)addr & 0x1) {\n\t\t*(u8 *)buf = ioread8(addr);\n\t\tdone += 1;\n\t\tif (done == count)\n\t\t\tgoto out;\n\t}\n\tif ((uintptr_t)(addr + done) & 0x2) {\n\t\tif ((count - done) < 2) {\n\t\t\t*(u8 *)(buf + done) = ioread8(addr + done);\n\t\t\tdone += 1;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\t*(u16 *)(buf + done) = ioread16(addr + done);\n\t\t\tdone += 2;\n\t\t}\n\t}\n\n\tcount32 = (count - done) & ~0x3;\n\twhile (done < count32) {\n\t\t*(u32 *)(buf + done) = ioread32(addr + done);\n\t\tdone += 4;\n\t}\n\n\tif ((count - done) & 0x2) {\n\t\t*(u16 *)(buf + done) = ioread16(addr + done);\n\t\tdone += 2;\n\t}\n\tif ((count - done) & 0x1) {\n\t\t*(u8 *)(buf + done) = ioread8(addr + done);\n\t\tdone += 1;\n\t}\n\nout:\n\tretval = count;\n\n\tif (err_chk) {\n\t\tif (handler->num_errors) {\n\t\t\tdev_err(image->parent->parent,\n\t\t\t\t\"First VME read error detected an at address 0x%llx\\n\",\n\t\t\t\thandler->first_error);\n\t\t\tretval = handler->first_error - (vme_base + offset);\n\t\t}\n\t\tvme_unregister_error_handler(handler);\n\t}\n\n\tspin_unlock(&image->lock);\n\n\treturn retval;\n}\n\nstatic ssize_t tsi148_master_write(struct vme_master_resource *image, void *buf,\n\tsize_t count, loff_t offset)\n{\n\tint retval = 0, enabled;\n\tunsigned long long vme_base, size;\n\tu32 aspace, cycle, dwidth;\n\tvoid __iomem *addr = image->kern_base + offset;\n\tunsigned int done = 0;\n\tunsigned int count32;\n\n\tstruct vme_error_handler *handler = NULL;\n\tstruct vme_bridge *tsi148_bridge;\n\tstruct tsi148_driver *bridge;\n\n\ttsi148_bridge = image->parent;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\tspin_lock(&image->lock);\n\n\tif (err_chk) {\n\t\t__tsi148_master_get(image, &enabled, &vme_base, &size, &aspace,\n\t\t\t\t    &cycle, &dwidth);\n\t\thandler = vme_register_error_handler(tsi148_bridge, aspace,\n\t\t\t\t\t\t     vme_base + offset, count);\n\t\tif (!handler) {\n\t\t\tspin_unlock(&image->lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tif ((uintptr_t)addr & 0x1) {\n\t\tiowrite8(*(u8 *)buf, addr);\n\t\tdone += 1;\n\t\tif (done == count)\n\t\t\tgoto out;\n\t}\n\tif ((uintptr_t)(addr + done) & 0x2) {\n\t\tif ((count - done) < 2) {\n\t\t\tiowrite8(*(u8 *)(buf + done), addr + done);\n\t\t\tdone += 1;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tiowrite16(*(u16 *)(buf + done), addr + done);\n\t\t\tdone += 2;\n\t\t}\n\t}\n\n\tcount32 = (count - done) & ~0x3;\n\twhile (done < count32) {\n\t\tiowrite32(*(u32 *)(buf + done), addr + done);\n\t\tdone += 4;\n\t}\n\n\tif ((count - done) & 0x2) {\n\t\tiowrite16(*(u16 *)(buf + done), addr + done);\n\t\tdone += 2;\n\t}\n\tif ((count - done) & 0x1) {\n\t\tiowrite8(*(u8 *)(buf + done), addr + done);\n\t\tdone += 1;\n\t}\n\nout:\n\tretval = count;\n\n\t \n\n\tif (err_chk) {\n\t\tioread16(bridge->flush_image->kern_base + 0x7F000);\n\n\t\tif (handler->num_errors) {\n\t\t\tdev_warn(tsi148_bridge->parent,\n\t\t\t\t \"First VME write error detected an at address 0x%llx\\n\",\n\t\t\t\t handler->first_error);\n\t\t\tretval = handler->first_error - (vme_base + offset);\n\t\t}\n\t\tvme_unregister_error_handler(handler);\n\t}\n\n\tspin_unlock(&image->lock);\n\n\treturn retval;\n}\n\n \nstatic unsigned int tsi148_master_rmw(struct vme_master_resource *image,\n\tunsigned int mask, unsigned int compare, unsigned int swap,\n\tloff_t offset)\n{\n\tunsigned long long pci_addr;\n\tunsigned int pci_addr_high, pci_addr_low;\n\tu32 tmp, result;\n\tint i;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = image->parent->driver_priv;\n\n\t \n\ti = image->number;\n\n\t \n\tmutex_lock(&bridge->vme_rmw);\n\n\t \n\tspin_lock(&image->lock);\n\n\tpci_addr_high = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTSAU);\n\tpci_addr_low = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\n\t\tTSI148_LCSR_OFFSET_OTSAL);\n\n\treg_join(pci_addr_high, pci_addr_low, &pci_addr);\n\treg_split(pci_addr + offset, &pci_addr_high, &pci_addr_low);\n\n\t \n\tiowrite32be(mask, bridge->base + TSI148_LCSR_RMWEN);\n\tiowrite32be(compare, bridge->base + TSI148_LCSR_RMWC);\n\tiowrite32be(swap, bridge->base + TSI148_LCSR_RMWS);\n\tiowrite32be(pci_addr_high, bridge->base + TSI148_LCSR_RMWAU);\n\tiowrite32be(pci_addr_low, bridge->base + TSI148_LCSR_RMWAL);\n\n\t \n\ttmp = ioread32be(bridge->base + TSI148_LCSR_VMCTRL);\n\ttmp |= TSI148_LCSR_VMCTRL_RMWEN;\n\tiowrite32be(tmp, bridge->base + TSI148_LCSR_VMCTRL);\n\n\t \n\tresult = ioread32be(image->kern_base + offset);\n\n\t \n\ttmp = ioread32be(bridge->base + TSI148_LCSR_VMCTRL);\n\ttmp &= ~TSI148_LCSR_VMCTRL_RMWEN;\n\tiowrite32be(tmp, bridge->base + TSI148_LCSR_VMCTRL);\n\n\tspin_unlock(&image->lock);\n\n\tmutex_unlock(&bridge->vme_rmw);\n\n\treturn result;\n}\n\nstatic int tsi148_dma_set_vme_src_attributes(struct device *dev, __be32 *attr,\n\tu32 aspace, u32 cycle, u32 dwidth)\n{\n\tu32 val;\n\n\tval = be32_to_cpu(*attr);\n\n\t \n\tswitch (cycle & (VME_2eSST160 | VME_2eSST267 | VME_2eSST320)) {\n\tcase VME_2eSST160:\n\t\tval |= TSI148_LCSR_DSAT_2eSSTM_160;\n\t\tbreak;\n\tcase VME_2eSST267:\n\t\tval |= TSI148_LCSR_DSAT_2eSSTM_267;\n\t\tbreak;\n\tcase VME_2eSST320:\n\t\tval |= TSI148_LCSR_DSAT_2eSSTM_320;\n\t\tbreak;\n\t}\n\n\t \n\tif (cycle & VME_SCT)\n\t\tval |= TSI148_LCSR_DSAT_TM_SCT;\n\n\tif (cycle & VME_BLT)\n\t\tval |= TSI148_LCSR_DSAT_TM_BLT;\n\n\tif (cycle & VME_MBLT)\n\t\tval |= TSI148_LCSR_DSAT_TM_MBLT;\n\n\tif (cycle & VME_2eVME)\n\t\tval |= TSI148_LCSR_DSAT_TM_2eVME;\n\n\tif (cycle & VME_2eSST)\n\t\tval |= TSI148_LCSR_DSAT_TM_2eSST;\n\n\tif (cycle & VME_2eSSTB) {\n\t\tdev_err(dev, \"Currently not setting Broadcast Select Registers\\n\");\n\t\tval |= TSI148_LCSR_DSAT_TM_2eSSTB;\n\t}\n\n\t \n\tswitch (dwidth) {\n\tcase VME_D16:\n\t\tval |= TSI148_LCSR_DSAT_DBW_16;\n\t\tbreak;\n\tcase VME_D32:\n\t\tval |= TSI148_LCSR_DSAT_DBW_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid data width\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (aspace) {\n\tcase VME_A16:\n\t\tval |= TSI148_LCSR_DSAT_AMODE_A16;\n\t\tbreak;\n\tcase VME_A24:\n\t\tval |= TSI148_LCSR_DSAT_AMODE_A24;\n\t\tbreak;\n\tcase VME_A32:\n\t\tval |= TSI148_LCSR_DSAT_AMODE_A32;\n\t\tbreak;\n\tcase VME_A64:\n\t\tval |= TSI148_LCSR_DSAT_AMODE_A64;\n\t\tbreak;\n\tcase VME_CRCSR:\n\t\tval |= TSI148_LCSR_DSAT_AMODE_CRCSR;\n\t\tbreak;\n\tcase VME_USER1:\n\t\tval |= TSI148_LCSR_DSAT_AMODE_USER1;\n\t\tbreak;\n\tcase VME_USER2:\n\t\tval |= TSI148_LCSR_DSAT_AMODE_USER2;\n\t\tbreak;\n\tcase VME_USER3:\n\t\tval |= TSI148_LCSR_DSAT_AMODE_USER3;\n\t\tbreak;\n\tcase VME_USER4:\n\t\tval |= TSI148_LCSR_DSAT_AMODE_USER4;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid address space\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cycle & VME_SUPER)\n\t\tval |= TSI148_LCSR_DSAT_SUP;\n\tif (cycle & VME_PROG)\n\t\tval |= TSI148_LCSR_DSAT_PGM;\n\n\t*attr = cpu_to_be32(val);\n\n\treturn 0;\n}\n\nstatic int tsi148_dma_set_vme_dest_attributes(struct device *dev, __be32 *attr,\n\tu32 aspace, u32 cycle, u32 dwidth)\n{\n\tu32 val;\n\n\tval = be32_to_cpu(*attr);\n\n\t \n\tswitch (cycle & (VME_2eSST160 | VME_2eSST267 | VME_2eSST320)) {\n\tcase VME_2eSST160:\n\t\tval |= TSI148_LCSR_DDAT_2eSSTM_160;\n\t\tbreak;\n\tcase VME_2eSST267:\n\t\tval |= TSI148_LCSR_DDAT_2eSSTM_267;\n\t\tbreak;\n\tcase VME_2eSST320:\n\t\tval |= TSI148_LCSR_DDAT_2eSSTM_320;\n\t\tbreak;\n\t}\n\n\t \n\tif (cycle & VME_SCT)\n\t\tval |= TSI148_LCSR_DDAT_TM_SCT;\n\n\tif (cycle & VME_BLT)\n\t\tval |= TSI148_LCSR_DDAT_TM_BLT;\n\n\tif (cycle & VME_MBLT)\n\t\tval |= TSI148_LCSR_DDAT_TM_MBLT;\n\n\tif (cycle & VME_2eVME)\n\t\tval |= TSI148_LCSR_DDAT_TM_2eVME;\n\n\tif (cycle & VME_2eSST)\n\t\tval |= TSI148_LCSR_DDAT_TM_2eSST;\n\n\tif (cycle & VME_2eSSTB) {\n\t\tdev_err(dev, \"Currently not setting Broadcast Select Registers\\n\");\n\t\tval |= TSI148_LCSR_DDAT_TM_2eSSTB;\n\t}\n\n\t \n\tswitch (dwidth) {\n\tcase VME_D16:\n\t\tval |= TSI148_LCSR_DDAT_DBW_16;\n\t\tbreak;\n\tcase VME_D32:\n\t\tval |= TSI148_LCSR_DDAT_DBW_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid data width\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (aspace) {\n\tcase VME_A16:\n\t\tval |= TSI148_LCSR_DDAT_AMODE_A16;\n\t\tbreak;\n\tcase VME_A24:\n\t\tval |= TSI148_LCSR_DDAT_AMODE_A24;\n\t\tbreak;\n\tcase VME_A32:\n\t\tval |= TSI148_LCSR_DDAT_AMODE_A32;\n\t\tbreak;\n\tcase VME_A64:\n\t\tval |= TSI148_LCSR_DDAT_AMODE_A64;\n\t\tbreak;\n\tcase VME_CRCSR:\n\t\tval |= TSI148_LCSR_DDAT_AMODE_CRCSR;\n\t\tbreak;\n\tcase VME_USER1:\n\t\tval |= TSI148_LCSR_DDAT_AMODE_USER1;\n\t\tbreak;\n\tcase VME_USER2:\n\t\tval |= TSI148_LCSR_DDAT_AMODE_USER2;\n\t\tbreak;\n\tcase VME_USER3:\n\t\tval |= TSI148_LCSR_DDAT_AMODE_USER3;\n\t\tbreak;\n\tcase VME_USER4:\n\t\tval |= TSI148_LCSR_DDAT_AMODE_USER4;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid address space\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cycle & VME_SUPER)\n\t\tval |= TSI148_LCSR_DDAT_SUP;\n\tif (cycle & VME_PROG)\n\t\tval |= TSI148_LCSR_DDAT_PGM;\n\n\t*attr = cpu_to_be32(val);\n\n\treturn 0;\n}\n\n \nstatic int tsi148_dma_list_add(struct vme_dma_list *list,\n\tstruct vme_dma_attr *src, struct vme_dma_attr *dest, size_t count)\n{\n\tstruct tsi148_dma_entry *entry, *prev;\n\tu32 address_high, address_low, val;\n\tstruct vme_dma_pattern *pattern_attr;\n\tstruct vme_dma_pci *pci_attr;\n\tstruct vme_dma_vme *vme_attr;\n\tint retval = 0;\n\tstruct vme_bridge *tsi148_bridge;\n\n\ttsi148_bridge = list->parent->parent;\n\n\t \n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_mem;\n\t}\n\n\t \n\tif ((unsigned long)&entry->descriptor & 0x7) {\n\t\tdev_err(tsi148_bridge->parent, \"Descriptor not aligned to 8 byte boundary as required: %p\\n\",\n\t\t\t&entry->descriptor);\n\t\tretval = -EINVAL;\n\t\tgoto err_align;\n\t}\n\n\t \n\tmemset(&entry->descriptor, 0, sizeof(entry->descriptor));\n\n\t \n\tswitch (src->type) {\n\tcase VME_DMA_PATTERN:\n\t\tpattern_attr = src->private;\n\n\t\tentry->descriptor.dsal = cpu_to_be32(pattern_attr->pattern);\n\n\t\tval = TSI148_LCSR_DSAT_TYP_PAT;\n\n\t\t \n\t\tif (pattern_attr->type & VME_DMA_PATTERN_BYTE)\n\t\t\tval |= TSI148_LCSR_DSAT_PSZ;\n\n\t\t \n\t\tif ((pattern_attr->type & VME_DMA_PATTERN_INCREMENT) == 0)\n\t\t\tval |= TSI148_LCSR_DSAT_NIN;\n\t\tentry->descriptor.dsat = cpu_to_be32(val);\n\t\tbreak;\n\tcase VME_DMA_PCI:\n\t\tpci_attr = src->private;\n\n\t\treg_split((unsigned long long)pci_attr->address, &address_high,\n\t\t\t&address_low);\n\t\tentry->descriptor.dsau = cpu_to_be32(address_high);\n\t\tentry->descriptor.dsal = cpu_to_be32(address_low);\n\t\tentry->descriptor.dsat = cpu_to_be32(TSI148_LCSR_DSAT_TYP_PCI);\n\t\tbreak;\n\tcase VME_DMA_VME:\n\t\tvme_attr = src->private;\n\n\t\treg_split((unsigned long long)vme_attr->address, &address_high,\n\t\t\t&address_low);\n\t\tentry->descriptor.dsau = cpu_to_be32(address_high);\n\t\tentry->descriptor.dsal = cpu_to_be32(address_low);\n\t\tentry->descriptor.dsat = cpu_to_be32(TSI148_LCSR_DSAT_TYP_VME);\n\n\t\tretval = tsi148_dma_set_vme_src_attributes(\n\t\t\ttsi148_bridge->parent, &entry->descriptor.dsat,\n\t\t\tvme_attr->aspace, vme_attr->cycle, vme_attr->dwidth);\n\t\tif (retval < 0)\n\t\t\tgoto err_source;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tsi148_bridge->parent, \"Invalid source type\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_source;\n\t}\n\n\t \n\tentry->descriptor.dnlau = cpu_to_be32(0);\n\tentry->descriptor.dnlal = cpu_to_be32(TSI148_LCSR_DNLAL_LLA);\n\n\t \n\tswitch (dest->type) {\n\tcase VME_DMA_PCI:\n\t\tpci_attr = dest->private;\n\n\t\treg_split((unsigned long long)pci_attr->address, &address_high,\n\t\t\t&address_low);\n\t\tentry->descriptor.ddau = cpu_to_be32(address_high);\n\t\tentry->descriptor.ddal = cpu_to_be32(address_low);\n\t\tentry->descriptor.ddat = cpu_to_be32(TSI148_LCSR_DDAT_TYP_PCI);\n\t\tbreak;\n\tcase VME_DMA_VME:\n\t\tvme_attr = dest->private;\n\n\t\treg_split((unsigned long long)vme_attr->address, &address_high,\n\t\t\t&address_low);\n\t\tentry->descriptor.ddau = cpu_to_be32(address_high);\n\t\tentry->descriptor.ddal = cpu_to_be32(address_low);\n\t\tentry->descriptor.ddat = cpu_to_be32(TSI148_LCSR_DDAT_TYP_VME);\n\n\t\tretval = tsi148_dma_set_vme_dest_attributes(\n\t\t\ttsi148_bridge->parent, &entry->descriptor.ddat,\n\t\t\tvme_attr->aspace, vme_attr->cycle, vme_attr->dwidth);\n\t\tif (retval < 0)\n\t\t\tgoto err_dest;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tsi148_bridge->parent, \"Invalid destination type\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_dest;\n\t}\n\n\t \n\tentry->descriptor.dcnt = cpu_to_be32((u32)count);\n\n\t \n\tlist_add_tail(&entry->list, &list->entries);\n\n\tentry->dma_handle = dma_map_single(tsi148_bridge->parent,\n\t\t\t\t\t   &entry->descriptor,\n\t\t\t\t\t   sizeof(entry->descriptor),\n\t\t\t\t\t   DMA_TO_DEVICE);\n\tif (dma_mapping_error(tsi148_bridge->parent, entry->dma_handle)) {\n\t\tdev_err(tsi148_bridge->parent, \"DMA mapping error\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_dma;\n\t}\n\n\t \n\tif (entry->list.prev != &list->entries) {\n\t\treg_split((unsigned long long)entry->dma_handle, &address_high,\n\t\t\t&address_low);\n\t\tprev = list_entry(entry->list.prev, struct tsi148_dma_entry,\n\t\t\t\t  list);\n\t\tprev->descriptor.dnlau = cpu_to_be32(address_high);\n\t\tprev->descriptor.dnlal = cpu_to_be32(address_low);\n\t}\n\n\treturn 0;\n\nerr_dma:\n\tlist_del(&entry->list);\nerr_dest:\nerr_source:\nerr_align:\n\t\tkfree(entry);\nerr_mem:\n\treturn retval;\n}\n\n \nstatic int tsi148_dma_busy(struct vme_bridge *tsi148_bridge, int channel)\n{\n\tu32 tmp;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\ttmp = ioread32be(bridge->base + TSI148_LCSR_DMA[channel] +\n\t\tTSI148_LCSR_OFFSET_DSTA);\n\n\tif (tmp & TSI148_LCSR_DSTA_BSY)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\n \nstatic int tsi148_dma_list_exec(struct vme_dma_list *list)\n{\n\tstruct vme_dma_resource *ctrlr;\n\tint channel, retval;\n\tstruct tsi148_dma_entry *entry;\n\tu32 bus_addr_high, bus_addr_low;\n\tu32 val, dctlreg = 0;\n\tstruct vme_bridge *tsi148_bridge;\n\tstruct tsi148_driver *bridge;\n\n\tctrlr = list->parent;\n\n\ttsi148_bridge = ctrlr->parent;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\tmutex_lock(&ctrlr->mtx);\n\n\tchannel = ctrlr->number;\n\n\tif (!list_empty(&ctrlr->running)) {\n\t\t \n\t\t \n\t\tmutex_unlock(&ctrlr->mtx);\n\t\treturn -EBUSY;\n\t}\n\n\tlist_add(&list->list, &ctrlr->running);\n\n\t \n\tentry = list_first_entry(&list->entries, struct tsi148_dma_entry,\n\t\tlist);\n\n\tmutex_unlock(&ctrlr->mtx);\n\n\treg_split(entry->dma_handle, &bus_addr_high, &bus_addr_low);\n\n\tiowrite32be(bus_addr_high, bridge->base +\n\t\tTSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DNLAU);\n\tiowrite32be(bus_addr_low, bridge->base +\n\t\tTSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DNLAL);\n\n\tdctlreg = ioread32be(bridge->base + TSI148_LCSR_DMA[channel] +\n\t\tTSI148_LCSR_OFFSET_DCTL);\n\n\t \n\tiowrite32be(dctlreg | TSI148_LCSR_DCTL_DGO, bridge->base +\n\t\tTSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DCTL);\n\n\tretval = wait_event_interruptible(bridge->dma_queue[channel],\n\t\ttsi148_dma_busy(ctrlr->parent, channel));\n\n\tif (retval) {\n\t\tiowrite32be(dctlreg | TSI148_LCSR_DCTL_ABT, bridge->base +\n\t\t\tTSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DCTL);\n\t\t \n\t\twait_event(bridge->dma_queue[channel],\n\t\t\t   tsi148_dma_busy(ctrlr->parent, channel));\n\t\tretval = -EINTR;\n\t\tgoto exit;\n\t}\n\n\t \n\tval = ioread32be(bridge->base + TSI148_LCSR_DMA[channel] +\n\t\tTSI148_LCSR_OFFSET_DSTA);\n\n\tif (val & TSI148_LCSR_DSTA_VBE) {\n\t\tdev_err(tsi148_bridge->parent, \"DMA Error. DSTA=%08X\\n\", val);\n\t\tretval = -EIO;\n\t}\n\nexit:\n\t \n\tmutex_lock(&ctrlr->mtx);\n\tlist_del(&list->list);\n\tmutex_unlock(&ctrlr->mtx);\n\n\treturn retval;\n}\n\n \nstatic int tsi148_dma_list_empty(struct vme_dma_list *list)\n{\n\tstruct list_head *pos, *temp;\n\tstruct tsi148_dma_entry *entry;\n\n\tstruct vme_bridge *tsi148_bridge = list->parent->parent;\n\n\t \n\tlist_for_each_safe(pos, temp, &list->entries) {\n\t\tlist_del(pos);\n\t\tentry = list_entry(pos, struct tsi148_dma_entry, list);\n\n\t\tdma_unmap_single(tsi148_bridge->parent, entry->dma_handle,\n\t\t\tsizeof(struct tsi148_dma_descriptor), DMA_TO_DEVICE);\n\t\tkfree(entry);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int tsi148_lm_set(struct vme_lm_resource *lm, unsigned long long lm_base,\n\tu32 aspace, u32 cycle)\n{\n\tu32 lm_base_high, lm_base_low, lm_ctl = 0;\n\tint i;\n\tstruct vme_bridge *tsi148_bridge;\n\tstruct tsi148_driver *bridge;\n\n\ttsi148_bridge = lm->parent;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\tmutex_lock(&lm->mtx);\n\n\t \n\tfor (i = 0; i < lm->monitors; i++) {\n\t\tif (bridge->lm_callback[i]) {\n\t\t\tmutex_unlock(&lm->mtx);\n\t\t\tdev_err(tsi148_bridge->parent, \"Location monitor callback attached, can't reset\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tswitch (aspace) {\n\tcase VME_A16:\n\t\tlm_ctl |= TSI148_LCSR_LMAT_AS_A16;\n\t\tbreak;\n\tcase VME_A24:\n\t\tlm_ctl |= TSI148_LCSR_LMAT_AS_A24;\n\t\tbreak;\n\tcase VME_A32:\n\t\tlm_ctl |= TSI148_LCSR_LMAT_AS_A32;\n\t\tbreak;\n\tcase VME_A64:\n\t\tlm_ctl |= TSI148_LCSR_LMAT_AS_A64;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&lm->mtx);\n\t\tdev_err(tsi148_bridge->parent, \"Invalid address space\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cycle & VME_SUPER)\n\t\tlm_ctl |= TSI148_LCSR_LMAT_SUPR;\n\tif (cycle & VME_USER)\n\t\tlm_ctl |= TSI148_LCSR_LMAT_NPRIV;\n\tif (cycle & VME_PROG)\n\t\tlm_ctl |= TSI148_LCSR_LMAT_PGM;\n\tif (cycle & VME_DATA)\n\t\tlm_ctl |= TSI148_LCSR_LMAT_DATA;\n\n\treg_split(lm_base, &lm_base_high, &lm_base_low);\n\n\tiowrite32be(lm_base_high, bridge->base + TSI148_LCSR_LMBAU);\n\tiowrite32be(lm_base_low, bridge->base + TSI148_LCSR_LMBAL);\n\tiowrite32be(lm_ctl, bridge->base + TSI148_LCSR_LMAT);\n\n\tmutex_unlock(&lm->mtx);\n\n\treturn 0;\n}\n\n \nstatic int tsi148_lm_get(struct vme_lm_resource *lm,\n\tunsigned long long *lm_base, u32 *aspace, u32 *cycle)\n{\n\tu32 lm_base_high, lm_base_low, lm_ctl, enabled = 0;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = lm->parent->driver_priv;\n\n\tmutex_lock(&lm->mtx);\n\n\tlm_base_high = ioread32be(bridge->base + TSI148_LCSR_LMBAU);\n\tlm_base_low = ioread32be(bridge->base + TSI148_LCSR_LMBAL);\n\tlm_ctl = ioread32be(bridge->base + TSI148_LCSR_LMAT);\n\n\treg_join(lm_base_high, lm_base_low, lm_base);\n\n\tif (lm_ctl & TSI148_LCSR_LMAT_EN)\n\t\tenabled = 1;\n\n\tif ((lm_ctl & TSI148_LCSR_LMAT_AS_M) == TSI148_LCSR_LMAT_AS_A16)\n\t\t*aspace |= VME_A16;\n\n\tif ((lm_ctl & TSI148_LCSR_LMAT_AS_M) == TSI148_LCSR_LMAT_AS_A24)\n\t\t*aspace |= VME_A24;\n\n\tif ((lm_ctl & TSI148_LCSR_LMAT_AS_M) == TSI148_LCSR_LMAT_AS_A32)\n\t\t*aspace |= VME_A32;\n\n\tif ((lm_ctl & TSI148_LCSR_LMAT_AS_M) == TSI148_LCSR_LMAT_AS_A64)\n\t\t*aspace |= VME_A64;\n\n\tif (lm_ctl & TSI148_LCSR_LMAT_SUPR)\n\t\t*cycle |= VME_SUPER;\n\tif (lm_ctl & TSI148_LCSR_LMAT_NPRIV)\n\t\t*cycle |= VME_USER;\n\tif (lm_ctl & TSI148_LCSR_LMAT_PGM)\n\t\t*cycle |= VME_PROG;\n\tif (lm_ctl & TSI148_LCSR_LMAT_DATA)\n\t\t*cycle |= VME_DATA;\n\n\tmutex_unlock(&lm->mtx);\n\n\treturn enabled;\n}\n\n \nstatic int tsi148_lm_attach(struct vme_lm_resource *lm, int monitor,\n\tvoid (*callback)(void *), void *data)\n{\n\tu32 lm_ctl, tmp;\n\tstruct vme_bridge *tsi148_bridge;\n\tstruct tsi148_driver *bridge;\n\n\ttsi148_bridge = lm->parent;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\tmutex_lock(&lm->mtx);\n\n\t \n\tlm_ctl = ioread32be(bridge->base + TSI148_LCSR_LMAT);\n\tif ((lm_ctl & (TSI148_LCSR_LMAT_PGM | TSI148_LCSR_LMAT_DATA)) == 0) {\n\t\tmutex_unlock(&lm->mtx);\n\t\tdev_err(tsi148_bridge->parent, \"Location monitor not properly configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (bridge->lm_callback[monitor]) {\n\t\tmutex_unlock(&lm->mtx);\n\t\tdev_err(tsi148_bridge->parent, \"Existing callback attached\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tbridge->lm_callback[monitor] = callback;\n\tbridge->lm_data[monitor] = data;\n\n\t \n\ttmp = ioread32be(bridge->base + TSI148_LCSR_INTEN);\n\ttmp |= TSI148_LCSR_INTEN_LMEN[monitor];\n\tiowrite32be(tmp, bridge->base + TSI148_LCSR_INTEN);\n\n\ttmp = ioread32be(bridge->base + TSI148_LCSR_INTEO);\n\ttmp |= TSI148_LCSR_INTEO_LMEO[monitor];\n\tiowrite32be(tmp, bridge->base + TSI148_LCSR_INTEO);\n\n\t \n\tif ((lm_ctl & TSI148_LCSR_LMAT_EN) == 0) {\n\t\tlm_ctl |= TSI148_LCSR_LMAT_EN;\n\t\tiowrite32be(lm_ctl, bridge->base + TSI148_LCSR_LMAT);\n\t}\n\n\tmutex_unlock(&lm->mtx);\n\n\treturn 0;\n}\n\n \nstatic int tsi148_lm_detach(struct vme_lm_resource *lm, int monitor)\n{\n\tu32 lm_en, tmp;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = lm->parent->driver_priv;\n\n\tmutex_lock(&lm->mtx);\n\n\t \n\tlm_en = ioread32be(bridge->base + TSI148_LCSR_INTEN);\n\tlm_en &= ~TSI148_LCSR_INTEN_LMEN[monitor];\n\tiowrite32be(lm_en, bridge->base + TSI148_LCSR_INTEN);\n\n\ttmp = ioread32be(bridge->base + TSI148_LCSR_INTEO);\n\ttmp &= ~TSI148_LCSR_INTEO_LMEO[monitor];\n\tiowrite32be(tmp, bridge->base + TSI148_LCSR_INTEO);\n\n\tiowrite32be(TSI148_LCSR_INTC_LMC[monitor],\n\t\t bridge->base + TSI148_LCSR_INTC);\n\n\t \n\tbridge->lm_callback[monitor] = NULL;\n\tbridge->lm_data[monitor] = NULL;\n\n\t \n\tif ((lm_en & (TSI148_LCSR_INTS_LM0S | TSI148_LCSR_INTS_LM1S |\n\t\t\tTSI148_LCSR_INTS_LM2S | TSI148_LCSR_INTS_LM3S)) == 0) {\n\t\ttmp = ioread32be(bridge->base + TSI148_LCSR_LMAT);\n\t\ttmp &= ~TSI148_LCSR_LMAT_EN;\n\t\tiowrite32be(tmp, bridge->base + TSI148_LCSR_LMAT);\n\t}\n\n\tmutex_unlock(&lm->mtx);\n\n\treturn 0;\n}\n\n \nstatic int tsi148_slot_get(struct vme_bridge *tsi148_bridge)\n{\n\tu32 slot = 0;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\tif (!geoid) {\n\t\tslot = ioread32be(bridge->base + TSI148_LCSR_VSTAT);\n\t\tslot = slot & TSI148_LCSR_VSTAT_GA_M;\n\t} else\n\t\tslot = geoid;\n\n\treturn (int)slot;\n}\n\nstatic void *tsi148_alloc_consistent(struct device *parent, size_t size,\n\tdma_addr_t *dma)\n{\n\tstruct pci_dev *pdev;\n\n\t \n\tpdev = to_pci_dev(parent);\n\n\treturn dma_alloc_coherent(&pdev->dev, size, dma, GFP_KERNEL);\n}\n\nstatic void tsi148_free_consistent(struct device *parent, size_t size,\n\tvoid *vaddr, dma_addr_t dma)\n{\n\tstruct pci_dev *pdev;\n\n\t \n\tpdev = to_pci_dev(parent);\n\n\tdma_free_coherent(&pdev->dev, size, vaddr, dma);\n}\n\n \nstatic int tsi148_crcsr_init(struct vme_bridge *tsi148_bridge,\n\tstruct pci_dev *pdev)\n{\n\tu32 cbar, crat, vstat;\n\tu32 crcsr_bus_high, crcsr_bus_low;\n\tint retval;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\t \n\tbridge->crcsr_kernel = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t  VME_CRCSR_BUF_SIZE,\n\t\t\t\t\t\t  &bridge->crcsr_bus, GFP_KERNEL);\n\tif (!bridge->crcsr_kernel) {\n\t\tdev_err(tsi148_bridge->parent, \"Failed to allocate memory for CR/CSR image\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treg_split(bridge->crcsr_bus, &crcsr_bus_high, &crcsr_bus_low);\n\n\tiowrite32be(crcsr_bus_high, bridge->base + TSI148_LCSR_CROU);\n\tiowrite32be(crcsr_bus_low, bridge->base + TSI148_LCSR_CROL);\n\n\t \n\tcbar = ioread32be(bridge->base + TSI148_CBAR);\n\tcbar = (cbar & TSI148_CRCSR_CBAR_M) >> 3;\n\n\tvstat = tsi148_slot_get(tsi148_bridge);\n\n\tif (cbar != vstat) {\n\t\tcbar = vstat;\n\t\tdev_info(tsi148_bridge->parent, \"Setting CR/CSR offset\\n\");\n\t\tiowrite32be(cbar << 3, bridge->base + TSI148_CBAR);\n\t}\n\tdev_info(tsi148_bridge->parent, \"CR/CSR Offset: %d\\n\", cbar);\n\n\tcrat = ioread32be(bridge->base + TSI148_LCSR_CRAT);\n\tif (crat & TSI148_LCSR_CRAT_EN)\n\t\tdev_info(tsi148_bridge->parent, \"CR/CSR already enabled\\n\");\n\telse {\n\t\tdev_info(tsi148_bridge->parent, \"Enabling CR/CSR space\\n\");\n\t\tiowrite32be(crat | TSI148_LCSR_CRAT_EN,\n\t\t\tbridge->base + TSI148_LCSR_CRAT);\n\t}\n\n\t \n\tif (err_chk) {\n\t\tretval = tsi148_master_set(bridge->flush_image, 1,\n\t\t\t(vstat * 0x80000), 0x80000, VME_CRCSR, VME_SCT,\n\t\t\tVME_D16);\n\t\tif (retval)\n\t\t\tdev_err(tsi148_bridge->parent, \"Configuring flush image failed\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void tsi148_crcsr_exit(struct vme_bridge *tsi148_bridge,\n\tstruct pci_dev *pdev)\n{\n\tu32 crat;\n\tstruct tsi148_driver *bridge;\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\t \n\tcrat = ioread32be(bridge->base + TSI148_LCSR_CRAT);\n\tiowrite32be(crat & ~TSI148_LCSR_CRAT_EN,\n\t\tbridge->base + TSI148_LCSR_CRAT);\n\n\t \n\tiowrite32be(0, bridge->base + TSI148_LCSR_CROU);\n\tiowrite32be(0, bridge->base + TSI148_LCSR_CROL);\n\n\tdma_free_coherent(&pdev->dev, VME_CRCSR_BUF_SIZE,\n\t\t\t  bridge->crcsr_kernel, bridge->crcsr_bus);\n}\n\nstatic int tsi148_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint retval, i, master_num;\n\tu32 data;\n\tstruct list_head *pos = NULL, *n;\n\tstruct vme_bridge *tsi148_bridge;\n\tstruct tsi148_driver *tsi148_device;\n\tstruct vme_master_resource *master_image;\n\tstruct vme_slave_resource *slave_image;\n\tstruct vme_dma_resource *dma_ctrlr;\n\tstruct vme_lm_resource *lm;\n\n\t \n\ttsi148_bridge = kzalloc(sizeof(*tsi148_bridge), GFP_KERNEL);\n\tif (!tsi148_bridge) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_struct;\n\t}\n\tvme_init_bridge(tsi148_bridge);\n\n\ttsi148_device = kzalloc(sizeof(*tsi148_device), GFP_KERNEL);\n\tif (!tsi148_device) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_driver;\n\t}\n\n\ttsi148_bridge->driver_priv = tsi148_device;\n\n\t \n\tretval = pci_enable_device(pdev);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"Unable to enable device\\n\");\n\t\tgoto err_enable;\n\t}\n\n\t \n\tretval = pci_request_regions(pdev, driver_name);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"Unable to reserve resources\\n\");\n\t\tgoto err_resource;\n\t}\n\n\t \n\ttsi148_device->base = ioremap(pci_resource_start(pdev, 0),\n\t\t4096);\n\tif (!tsi148_device->base) {\n\t\tdev_err(&pdev->dev, \"Unable to remap CRG region\\n\");\n\t\tretval = -EIO;\n\t\tgoto err_remap;\n\t}\n\n\t \n\tdata = ioread32(tsi148_device->base + TSI148_PCFS_ID) & 0x0000FFFF;\n\tif (data != PCI_VENDOR_ID_TUNDRA) {\n\t\tdev_err(&pdev->dev, \"CRG region check failed\\n\");\n\t\tretval = -EIO;\n\t\tgoto err_test;\n\t}\n\n\t \n\tinit_waitqueue_head(&tsi148_device->dma_queue[0]);\n\tinit_waitqueue_head(&tsi148_device->dma_queue[1]);\n\tinit_waitqueue_head(&tsi148_device->iack_queue);\n\tmutex_init(&tsi148_device->vme_int);\n\tmutex_init(&tsi148_device->vme_rmw);\n\n\ttsi148_bridge->parent = &pdev->dev;\n\tstrcpy(tsi148_bridge->name, driver_name);\n\n\t \n\tretval = tsi148_irq_init(tsi148_bridge);\n\tif (retval != 0) {\n\t\tdev_err(&pdev->dev, \"Chip Initialization failed.\\n\");\n\t\tgoto err_irq;\n\t}\n\n\t \n\tmaster_num = TSI148_MAX_MASTER;\n\tif (err_chk) {\n\t\tmaster_num--;\n\n\t\ttsi148_device->flush_image =\n\t\t\tkmalloc(sizeof(*tsi148_device->flush_image),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!tsi148_device->flush_image) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_master;\n\t\t}\n\t\ttsi148_device->flush_image->parent = tsi148_bridge;\n\t\tspin_lock_init(&tsi148_device->flush_image->lock);\n\t\ttsi148_device->flush_image->locked = 1;\n\t\ttsi148_device->flush_image->number = master_num;\n\t\tmemset(&tsi148_device->flush_image->bus_resource, 0,\n\t\t       sizeof(tsi148_device->flush_image->bus_resource));\n\t\ttsi148_device->flush_image->kern_base  = NULL;\n\t}\n\n\t \n\tfor (i = 0; i < master_num; i++) {\n\t\tmaster_image = kmalloc(sizeof(*master_image), GFP_KERNEL);\n\t\tif (!master_image) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_master;\n\t\t}\n\t\tmaster_image->parent = tsi148_bridge;\n\t\tspin_lock_init(&master_image->lock);\n\t\tmaster_image->locked = 0;\n\t\tmaster_image->number = i;\n\t\tmaster_image->address_attr = VME_A16 | VME_A24 | VME_A32 |\n\t\t\tVME_A64 | VME_CRCSR | VME_USER1 | VME_USER2 |\n\t\t\tVME_USER3 | VME_USER4;\n\t\tmaster_image->cycle_attr = VME_SCT | VME_BLT | VME_MBLT |\n\t\t\tVME_2eVME | VME_2eSST | VME_2eSSTB | VME_2eSST160 |\n\t\t\tVME_2eSST267 | VME_2eSST320 | VME_SUPER | VME_USER |\n\t\t\tVME_PROG | VME_DATA;\n\t\tmaster_image->width_attr = VME_D16 | VME_D32;\n\t\tmemset(&master_image->bus_resource, 0,\n\t\t       sizeof(master_image->bus_resource));\n\t\tmaster_image->kern_base  = NULL;\n\t\tlist_add_tail(&master_image->list,\n\t\t\t&tsi148_bridge->master_resources);\n\t}\n\n\t \n\tfor (i = 0; i < TSI148_MAX_SLAVE; i++) {\n\t\tslave_image = kmalloc(sizeof(*slave_image), GFP_KERNEL);\n\t\tif (!slave_image) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_slave;\n\t\t}\n\t\tslave_image->parent = tsi148_bridge;\n\t\tmutex_init(&slave_image->mtx);\n\t\tslave_image->locked = 0;\n\t\tslave_image->number = i;\n\t\tslave_image->address_attr = VME_A16 | VME_A24 | VME_A32 |\n\t\t\tVME_A64;\n\t\tslave_image->cycle_attr = VME_SCT | VME_BLT | VME_MBLT |\n\t\t\tVME_2eVME | VME_2eSST | VME_2eSSTB | VME_2eSST160 |\n\t\t\tVME_2eSST267 | VME_2eSST320 | VME_SUPER | VME_USER |\n\t\t\tVME_PROG | VME_DATA;\n\t\tlist_add_tail(&slave_image->list,\n\t\t\t&tsi148_bridge->slave_resources);\n\t}\n\n\t \n\tfor (i = 0; i < TSI148_MAX_DMA; i++) {\n\t\tdma_ctrlr = kmalloc(sizeof(*dma_ctrlr), GFP_KERNEL);\n\t\tif (!dma_ctrlr) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_dma;\n\t\t}\n\t\tdma_ctrlr->parent = tsi148_bridge;\n\t\tmutex_init(&dma_ctrlr->mtx);\n\t\tdma_ctrlr->locked = 0;\n\t\tdma_ctrlr->number = i;\n\t\tdma_ctrlr->route_attr = VME_DMA_VME_TO_MEM |\n\t\t\tVME_DMA_MEM_TO_VME | VME_DMA_VME_TO_VME |\n\t\t\tVME_DMA_MEM_TO_MEM | VME_DMA_PATTERN_TO_VME |\n\t\t\tVME_DMA_PATTERN_TO_MEM;\n\t\tINIT_LIST_HEAD(&dma_ctrlr->pending);\n\t\tINIT_LIST_HEAD(&dma_ctrlr->running);\n\t\tlist_add_tail(&dma_ctrlr->list,\n\t\t\t&tsi148_bridge->dma_resources);\n\t}\n\n\t \n\tlm = kmalloc(sizeof(*lm), GFP_KERNEL);\n\tif (!lm) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_lm;\n\t}\n\tlm->parent = tsi148_bridge;\n\tmutex_init(&lm->mtx);\n\tlm->locked = 0;\n\tlm->number = 1;\n\tlm->monitors = 4;\n\tlist_add_tail(&lm->list, &tsi148_bridge->lm_resources);\n\n\ttsi148_bridge->slave_get = tsi148_slave_get;\n\ttsi148_bridge->slave_set = tsi148_slave_set;\n\ttsi148_bridge->master_get = tsi148_master_get;\n\ttsi148_bridge->master_set = tsi148_master_set;\n\ttsi148_bridge->master_read = tsi148_master_read;\n\ttsi148_bridge->master_write = tsi148_master_write;\n\ttsi148_bridge->master_rmw = tsi148_master_rmw;\n\ttsi148_bridge->dma_list_add = tsi148_dma_list_add;\n\ttsi148_bridge->dma_list_exec = tsi148_dma_list_exec;\n\ttsi148_bridge->dma_list_empty = tsi148_dma_list_empty;\n\ttsi148_bridge->irq_set = tsi148_irq_set;\n\ttsi148_bridge->irq_generate = tsi148_irq_generate;\n\ttsi148_bridge->lm_set = tsi148_lm_set;\n\ttsi148_bridge->lm_get = tsi148_lm_get;\n\ttsi148_bridge->lm_attach = tsi148_lm_attach;\n\ttsi148_bridge->lm_detach = tsi148_lm_detach;\n\ttsi148_bridge->slot_get = tsi148_slot_get;\n\ttsi148_bridge->alloc_consistent = tsi148_alloc_consistent;\n\ttsi148_bridge->free_consistent = tsi148_free_consistent;\n\n\tdata = ioread32be(tsi148_device->base + TSI148_LCSR_VSTAT);\n\tdev_info(&pdev->dev, \"Board is%s the VME system controller\\n\",\n\t\t(data & TSI148_LCSR_VSTAT_SCONS) ? \"\" : \" not\");\n\tif (!geoid)\n\t\tdev_info(&pdev->dev, \"VME geographical address is %d\\n\",\n\t\t\tdata & TSI148_LCSR_VSTAT_GA_M);\n\telse\n\t\tdev_info(&pdev->dev, \"VME geographical address is set to %d\\n\",\n\t\t\tgeoid);\n\n\tdev_info(&pdev->dev, \"VME Write and flush and error check is %s\\n\",\n\t\terr_chk ? \"enabled\" : \"disabled\");\n\n\tretval = tsi148_crcsr_init(tsi148_bridge, pdev);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"CR/CSR configuration failed.\\n\");\n\t\tgoto err_crcsr;\n\t}\n\n\tretval = vme_register_bridge(tsi148_bridge);\n\tif (retval != 0) {\n\t\tdev_err(&pdev->dev, \"Chip Registration failed.\\n\");\n\t\tgoto err_reg;\n\t}\n\n\tpci_set_drvdata(pdev, tsi148_bridge);\n\n\t \n\tdata = ioread32be(tsi148_device->base + TSI148_LCSR_VSTAT);\n\tdata &= ~TSI148_LCSR_VSTAT_BRDFL;\n\tdata |= TSI148_LCSR_VSTAT_CPURST;\n\tiowrite32be(data, tsi148_device->base + TSI148_LCSR_VSTAT);\n\n\treturn 0;\n\nerr_reg:\n\ttsi148_crcsr_exit(tsi148_bridge, pdev);\nerr_crcsr:\nerr_lm:\n\t \n\tlist_for_each_safe(pos, n, &tsi148_bridge->lm_resources) {\n\t\tlm = list_entry(pos, struct vme_lm_resource, list);\n\t\tlist_del(pos);\n\t\tkfree(lm);\n\t}\nerr_dma:\n\t \n\tlist_for_each_safe(pos, n, &tsi148_bridge->dma_resources) {\n\t\tdma_ctrlr = list_entry(pos, struct vme_dma_resource, list);\n\t\tlist_del(pos);\n\t\tkfree(dma_ctrlr);\n\t}\nerr_slave:\n\t \n\tlist_for_each_safe(pos, n, &tsi148_bridge->slave_resources) {\n\t\tslave_image = list_entry(pos, struct vme_slave_resource, list);\n\t\tlist_del(pos);\n\t\tkfree(slave_image);\n\t}\nerr_master:\n\t \n\tlist_for_each_safe(pos, n, &tsi148_bridge->master_resources) {\n\t\tmaster_image = list_entry(pos, struct vme_master_resource,\n\t\t\tlist);\n\t\tlist_del(pos);\n\t\tkfree(master_image);\n\t}\n\n\ttsi148_irq_exit(tsi148_bridge, pdev);\nerr_irq:\nerr_test:\n\tiounmap(tsi148_device->base);\nerr_remap:\n\tpci_release_regions(pdev);\nerr_resource:\n\tpci_disable_device(pdev);\nerr_enable:\n\tkfree(tsi148_device);\nerr_driver:\n\tkfree(tsi148_bridge);\nerr_struct:\n\treturn retval;\n}\n\nstatic void tsi148_remove(struct pci_dev *pdev)\n{\n\tstruct list_head *pos = NULL;\n\tstruct list_head *tmplist;\n\tstruct vme_master_resource *master_image;\n\tstruct vme_slave_resource *slave_image;\n\tstruct vme_dma_resource *dma_ctrlr;\n\tint i;\n\tstruct tsi148_driver *bridge;\n\tstruct vme_bridge *tsi148_bridge = pci_get_drvdata(pdev);\n\n\tbridge = tsi148_bridge->driver_priv;\n\n\tdev_dbg(&pdev->dev, \"Driver is being unloaded.\\n\");\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tiowrite32be(0, bridge->base + TSI148_LCSR_IT[i] +\n\t\t\tTSI148_LCSR_OFFSET_ITAT);\n\t\tiowrite32be(0, bridge->base + TSI148_LCSR_OT[i] +\n\t\t\tTSI148_LCSR_OFFSET_OTAT);\n\t}\n\n\t \n\tiowrite32be(0, bridge->base + TSI148_LCSR_LMAT);\n\n\t \n\tiowrite32be(0, bridge->base + TSI148_LCSR_CSRAT);\n\n\t \n\tiowrite32be(0xFFFFFFFF, bridge->base + TSI148_LCSR_EDPAT);\n\tiowrite32be(0xFFFFFFFF, bridge->base + TSI148_LCSR_VEAT);\n\tiowrite32be(0x07000700, bridge->base + TSI148_LCSR_PSTAT);\n\n\t \n\tif (ioread32be(bridge->base + TSI148_LCSR_VICR) & 0x800)\n\t\tiowrite32be(0x8000, bridge->base + TSI148_LCSR_VICR);\n\n\t \n\tiowrite32be(0x0, bridge->base + TSI148_LCSR_INTM1);\n\tiowrite32be(0x0, bridge->base + TSI148_LCSR_INTM2);\n\n\ttsi148_irq_exit(tsi148_bridge, pdev);\n\n\tvme_unregister_bridge(tsi148_bridge);\n\n\ttsi148_crcsr_exit(tsi148_bridge, pdev);\n\n\t \n\tlist_for_each_safe(pos, tmplist, &tsi148_bridge->dma_resources) {\n\t\tdma_ctrlr = list_entry(pos, struct vme_dma_resource, list);\n\t\tlist_del(pos);\n\t\tkfree(dma_ctrlr);\n\t}\n\n\t \n\tlist_for_each_safe(pos, tmplist, &tsi148_bridge->slave_resources) {\n\t\tslave_image = list_entry(pos, struct vme_slave_resource, list);\n\t\tlist_del(pos);\n\t\tkfree(slave_image);\n\t}\n\n\t \n\tlist_for_each_safe(pos, tmplist, &tsi148_bridge->master_resources) {\n\t\tmaster_image = list_entry(pos, struct vme_master_resource,\n\t\t\tlist);\n\t\tlist_del(pos);\n\t\tkfree(master_image);\n\t}\n\n\tiounmap(bridge->base);\n\n\tpci_release_regions(pdev);\n\n\tpci_disable_device(pdev);\n\n\tkfree(tsi148_bridge->driver_priv);\n\n\tkfree(tsi148_bridge);\n}\n\nmodule_pci_driver(tsi148_driver);\n\nMODULE_PARM_DESC(err_chk, \"Check for VME errors on reads and writes\");\nmodule_param(err_chk, bool, 0);\n\nMODULE_PARM_DESC(geoid, \"Override geographical addressing\");\nmodule_param(geoid, int, 0);\n\nMODULE_DESCRIPTION(\"VME driver for the Tundra Tempe VME bridge\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}