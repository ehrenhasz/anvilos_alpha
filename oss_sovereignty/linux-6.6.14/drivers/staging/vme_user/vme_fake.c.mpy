{
  "module_name": "vme_fake.c",
  "hash_id": "9b4d8215099515cadfa202a3e138936d85735806986f2dc05e4567f5881ded42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vme_user/vme_fake.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n#include \"vme.h\"\n#include \"vme_bridge.h\"\n\n \n#define FAKE_MAX_MASTER\t\t8\t \n#define FAKE_MAX_SLAVE\t\t8\t \n\n \nstruct fake_slave_window {\n\tint enabled;\n\tunsigned long long vme_base;\n\tunsigned long long size;\n\tvoid *buf_base;\n\tu32 aspace;\n\tu32 cycle;\n};\n\nstruct fake_master_window {\n\tint enabled;\n\tunsigned long long vme_base;\n\tunsigned long long size;\n\tu32 aspace;\n\tu32 cycle;\n\tu32 dwidth;\n};\n\n \nstruct fake_driver {\n\tstruct vme_bridge *parent;\n\tstruct fake_slave_window slaves[FAKE_MAX_SLAVE];\n\tstruct fake_master_window masters[FAKE_MAX_MASTER];\n\tu32 lm_enabled;\n\tunsigned long long lm_base;\n\tu32 lm_aspace;\n\tu32 lm_cycle;\n\tvoid (*lm_callback[4])(void *);\n\tvoid *lm_data[4];\n\tstruct tasklet_struct int_tasklet;\n\tint int_level;\n\tint int_statid;\n\tvoid *crcsr_kernel;\n\tdma_addr_t crcsr_bus;\n\t \n\tstruct mutex vme_int;\n};\n\n \nstatic int geoid;\n\nstatic const char driver_name[] = \"vme_fake\";\n\nstatic struct vme_bridge *exit_pointer;\n\nstatic struct device *vme_root;\n\n \nstatic void fake_VIRQ_tasklet(unsigned long data)\n{\n\tstruct vme_bridge *fake_bridge;\n\tstruct fake_driver *bridge;\n\n\tfake_bridge = (struct vme_bridge *) data;\n\tbridge = fake_bridge->driver_priv;\n\n\tvme_irq_handler(fake_bridge, bridge->int_level, bridge->int_statid);\n}\n\n \nstatic void fake_irq_set(struct vme_bridge *fake_bridge, int level,\n\t\tint state, int sync)\n{\n\t \n}\n\nstatic void *fake_pci_to_ptr(dma_addr_t addr)\n{\n\treturn (void *)(uintptr_t)addr;\n}\n\nstatic dma_addr_t fake_ptr_to_pci(void *addr)\n{\n\treturn (dma_addr_t)(uintptr_t)addr;\n}\n\n \nstatic int fake_irq_generate(struct vme_bridge *fake_bridge, int level,\n\t\tint statid)\n{\n\tstruct fake_driver *bridge;\n\n\tbridge = fake_bridge->driver_priv;\n\n\tmutex_lock(&bridge->vme_int);\n\n\tbridge->int_level = level;\n\n\tbridge->int_statid = statid;\n\n\t \n\ttasklet_schedule(&bridge->int_tasklet);\n\n\tmutex_unlock(&bridge->vme_int);\n\n\treturn 0;\n}\n\n \nstatic int fake_slave_set(struct vme_slave_resource *image, int enabled,\n\t\tunsigned long long vme_base, unsigned long long size,\n\t\tdma_addr_t buf_base, u32 aspace, u32 cycle)\n{\n\tunsigned int i, granularity = 0;\n\tunsigned long long vme_bound;\n\tstruct vme_bridge *fake_bridge;\n\tstruct fake_driver *bridge;\n\n\tfake_bridge = image->parent;\n\tbridge = fake_bridge->driver_priv;\n\n\ti = image->number;\n\n\tswitch (aspace) {\n\tcase VME_A16:\n\t\tgranularity = 0x10;\n\t\tbreak;\n\tcase VME_A24:\n\t\tgranularity = 0x1000;\n\t\tbreak;\n\tcase VME_A32:\n\t\tgranularity = 0x10000;\n\t\tbreak;\n\tcase VME_A64:\n\t\tgranularity = 0x10000;\n\t\tbreak;\n\tcase VME_CRCSR:\n\tcase VME_USER1:\n\tcase VME_USER2:\n\tcase VME_USER3:\n\tcase VME_USER4:\n\tdefault:\n\t\tpr_err(\"Invalid address space\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tvme_bound = vme_base + size - granularity;\n\n\tif (vme_base & (granularity - 1)) {\n\t\tpr_err(\"Invalid VME base alignment\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (vme_bound & (granularity - 1)) {\n\t\tpr_err(\"Invalid VME bound alignment\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&image->mtx);\n\n\tbridge->slaves[i].enabled = enabled;\n\tbridge->slaves[i].vme_base = vme_base;\n\tbridge->slaves[i].size = size;\n\tbridge->slaves[i].buf_base = fake_pci_to_ptr(buf_base);\n\tbridge->slaves[i].aspace = aspace;\n\tbridge->slaves[i].cycle = cycle;\n\n\tmutex_unlock(&image->mtx);\n\n\treturn 0;\n}\n\n \nstatic int fake_slave_get(struct vme_slave_resource *image, int *enabled,\n\t\tunsigned long long *vme_base, unsigned long long *size,\n\t\tdma_addr_t *buf_base, u32 *aspace, u32 *cycle)\n{\n\tunsigned int i;\n\tstruct fake_driver *bridge;\n\n\tbridge = image->parent->driver_priv;\n\n\ti = image->number;\n\n\tmutex_lock(&image->mtx);\n\n\t*enabled = bridge->slaves[i].enabled;\n\t*vme_base = bridge->slaves[i].vme_base;\n\t*size = bridge->slaves[i].size;\n\t*buf_base = fake_ptr_to_pci(bridge->slaves[i].buf_base);\n\t*aspace = bridge->slaves[i].aspace;\n\t*cycle = bridge->slaves[i].cycle;\n\n\tmutex_unlock(&image->mtx);\n\n\treturn 0;\n}\n\n \nstatic int fake_master_set(struct vme_master_resource *image, int enabled,\n\t\tunsigned long long vme_base, unsigned long long size,\n\t\tu32 aspace, u32 cycle, u32 dwidth)\n{\n\tint retval = 0;\n\tunsigned int i;\n\tstruct vme_bridge *fake_bridge;\n\tstruct fake_driver *bridge;\n\n\tfake_bridge = image->parent;\n\n\tbridge = fake_bridge->driver_priv;\n\n\t \n\tif (vme_base & 0xFFFF) {\n\t\tpr_err(\"Invalid VME Window alignment\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_window;\n\t}\n\n\tif (size & 0xFFFF) {\n\t\tpr_err(\"Invalid size alignment\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_window;\n\t}\n\n\tif ((size == 0) && (enabled != 0)) {\n\t\tpr_err(\"Size must be non-zero for enabled windows\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_window;\n\t}\n\n\t \n\tswitch (dwidth) {\n\tcase VME_D8:\n\tcase VME_D16:\n\tcase VME_D32:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid data width\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_dwidth;\n\t}\n\n\t \n\tswitch (aspace) {\n\tcase VME_A16:\n\tcase VME_A24:\n\tcase VME_A32:\n\tcase VME_A64:\n\tcase VME_CRCSR:\n\tcase VME_USER1:\n\tcase VME_USER2:\n\tcase VME_USER3:\n\tcase VME_USER4:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid address space\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_aspace;\n\t}\n\n\tspin_lock(&image->lock);\n\n\ti = image->number;\n\n\tbridge->masters[i].enabled = enabled;\n\tbridge->masters[i].vme_base = vme_base;\n\tbridge->masters[i].size = size;\n\tbridge->masters[i].aspace = aspace;\n\tbridge->masters[i].cycle = cycle;\n\tbridge->masters[i].dwidth = dwidth;\n\n\tspin_unlock(&image->lock);\n\n\treturn 0;\n\nerr_aspace:\nerr_dwidth:\nerr_window:\n\treturn retval;\n}\n\n \nstatic int __fake_master_get(struct vme_master_resource *image, int *enabled,\n\t\tunsigned long long *vme_base, unsigned long long *size,\n\t\tu32 *aspace, u32 *cycle, u32 *dwidth)\n{\n\tunsigned int i;\n\tstruct fake_driver *bridge;\n\n\tbridge = image->parent->driver_priv;\n\n\ti = image->number;\n\n\t*enabled = bridge->masters[i].enabled;\n\t*vme_base = bridge->masters[i].vme_base;\n\t*size = bridge->masters[i].size;\n\t*aspace = bridge->masters[i].aspace;\n\t*cycle = bridge->masters[i].cycle;\n\t*dwidth = bridge->masters[i].dwidth;\n\n\treturn 0;\n}\n\nstatic int fake_master_get(struct vme_master_resource *image, int *enabled,\n\t\tunsigned long long *vme_base, unsigned long long *size,\n\t\tu32 *aspace, u32 *cycle, u32 *dwidth)\n{\n\tint retval;\n\n\tspin_lock(&image->lock);\n\n\tretval = __fake_master_get(image, enabled, vme_base, size, aspace,\n\t\t\tcycle, dwidth);\n\n\tspin_unlock(&image->lock);\n\n\treturn retval;\n}\n\nstatic void fake_lm_check(struct fake_driver *bridge, unsigned long long addr,\n\t\t\t  u32 aspace, u32 cycle)\n{\n\tstruct vme_bridge *fake_bridge;\n\tunsigned long long lm_base;\n\tu32 lm_aspace, lm_cycle;\n\tint i;\n\tstruct vme_lm_resource *lm;\n\tstruct list_head *pos = NULL, *n;\n\n\t \n\tfake_bridge = bridge->parent;\n\n\t \n\tlist_for_each_safe(pos, n, &fake_bridge->lm_resources) {\n\t\tlm = list_entry(pos, struct vme_lm_resource, list);\n\n\t\t \n\t\tif (bridge->lm_enabled == 0)\n\t\t\treturn;\n\n\t\tlm_base = bridge->lm_base;\n\t\tlm_aspace = bridge->lm_aspace;\n\t\tlm_cycle = bridge->lm_cycle;\n\n\t\t \n\t\tif ((lm_aspace == aspace) && (lm_cycle == cycle)) {\n\t\t\tfor (i = 0; i < lm->monitors; i++) {\n\t\t\t\t \n\t\t\t\tif (((lm_base + (8 * i)) <= addr) &&\n\t\t\t\t    ((lm_base + (8 * i) + 8) > addr)) {\n\t\t\t\t\tif (bridge->lm_callback[i])\n\t\t\t\t\t\tbridge->lm_callback[i](\n\t\t\t\t\t\t\tbridge->lm_data[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic noinline_for_stack u8 fake_vmeread8(struct fake_driver *bridge,\n\t\t\t\t\t   unsigned long long addr,\n\t\t\t\t\t   u32 aspace, u32 cycle)\n{\n\tu8 retval = 0xff;\n\tint i;\n\tunsigned long long start, end, offset;\n\tu8 *loc;\n\n\tfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\n\t\tstart = bridge->slaves[i].vme_base;\n\t\tend = bridge->slaves[i].vme_base + bridge->slaves[i].size;\n\n\t\tif (aspace != bridge->slaves[i].aspace)\n\t\t\tcontinue;\n\n\t\tif (cycle != bridge->slaves[i].cycle)\n\t\t\tcontinue;\n\n\t\tif ((addr >= start) && (addr < end)) {\n\t\t\toffset = addr - bridge->slaves[i].vme_base;\n\t\t\tloc = (u8 *)(bridge->slaves[i].buf_base + offset);\n\t\t\tretval = *loc;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfake_lm_check(bridge, addr, aspace, cycle);\n\n\treturn retval;\n}\n\nstatic noinline_for_stack u16 fake_vmeread16(struct fake_driver *bridge,\n\t\t\t\t\t     unsigned long long addr,\n\t\t\t\t\t     u32 aspace, u32 cycle)\n{\n\tu16 retval = 0xffff;\n\tint i;\n\tunsigned long long start, end, offset;\n\tu16 *loc;\n\n\tfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\n\t\tif (aspace != bridge->slaves[i].aspace)\n\t\t\tcontinue;\n\n\t\tif (cycle != bridge->slaves[i].cycle)\n\t\t\tcontinue;\n\n\t\tstart = bridge->slaves[i].vme_base;\n\t\tend = bridge->slaves[i].vme_base + bridge->slaves[i].size;\n\n\t\tif ((addr >= start) && ((addr + 1) < end)) {\n\t\t\toffset = addr - bridge->slaves[i].vme_base;\n\t\t\tloc = (u16 *)(bridge->slaves[i].buf_base + offset);\n\t\t\tretval = *loc;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfake_lm_check(bridge, addr, aspace, cycle);\n\n\treturn retval;\n}\n\nstatic noinline_for_stack u32 fake_vmeread32(struct fake_driver *bridge,\n\t\t\t\t\t     unsigned long long addr,\n\t\t\t\t\t     u32 aspace, u32 cycle)\n{\n\tu32 retval = 0xffffffff;\n\tint i;\n\tunsigned long long start, end, offset;\n\tu32 *loc;\n\n\tfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\n\t\tif (aspace != bridge->slaves[i].aspace)\n\t\t\tcontinue;\n\n\t\tif (cycle != bridge->slaves[i].cycle)\n\t\t\tcontinue;\n\n\t\tstart = bridge->slaves[i].vme_base;\n\t\tend = bridge->slaves[i].vme_base + bridge->slaves[i].size;\n\n\t\tif ((addr >= start) && ((addr + 3) < end)) {\n\t\t\toffset = addr - bridge->slaves[i].vme_base;\n\t\t\tloc = (u32 *)(bridge->slaves[i].buf_base + offset);\n\t\t\tretval = *loc;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfake_lm_check(bridge, addr, aspace, cycle);\n\n\treturn retval;\n}\n\nstatic ssize_t fake_master_read(struct vme_master_resource *image, void *buf,\n\t\tsize_t count, loff_t offset)\n{\n\tint retval;\n\tu32 aspace, cycle, dwidth;\n\tstruct vme_bridge *fake_bridge;\n\tstruct fake_driver *priv;\n\tint i;\n\tunsigned long long addr;\n\tunsigned int done = 0;\n\tunsigned int count32;\n\n\tfake_bridge = image->parent;\n\n\tpriv = fake_bridge->driver_priv;\n\n\ti = image->number;\n\n\taddr = (unsigned long long)priv->masters[i].vme_base + offset;\n\taspace = priv->masters[i].aspace;\n\tcycle = priv->masters[i].cycle;\n\tdwidth = priv->masters[i].dwidth;\n\n\tspin_lock(&image->lock);\n\n\t \n\tif (addr & 0x1) {\n\t\t*(u8 *)buf = fake_vmeread8(priv, addr, aspace, cycle);\n\t\tdone += 1;\n\t\tif (done == count)\n\t\t\tgoto out;\n\t}\n\tif ((dwidth == VME_D16) || (dwidth == VME_D32)) {\n\t\tif ((addr + done) & 0x2) {\n\t\t\tif ((count - done) < 2) {\n\t\t\t\t*(u8 *)(buf + done) = fake_vmeread8(priv,\n\t\t\t\t\t\taddr + done, aspace, cycle);\n\t\t\t\tdone += 1;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t*(u16 *)(buf + done) = fake_vmeread16(priv,\n\t\t\t\t\t\taddr + done, aspace, cycle);\n\t\t\t\tdone += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dwidth == VME_D32) {\n\t\tcount32 = (count - done) & ~0x3;\n\t\twhile (done < count32) {\n\t\t\t*(u32 *)(buf + done) = fake_vmeread32(priv, addr + done,\n\t\t\t\t\taspace, cycle);\n\t\t\tdone += 4;\n\t\t}\n\t} else if (dwidth == VME_D16) {\n\t\tcount32 = (count - done) & ~0x3;\n\t\twhile (done < count32) {\n\t\t\t*(u16 *)(buf + done) = fake_vmeread16(priv, addr + done,\n\t\t\t\t\taspace, cycle);\n\t\t\tdone += 2;\n\t\t}\n\t} else if (dwidth == VME_D8) {\n\t\tcount32 = (count - done);\n\t\twhile (done < count32) {\n\t\t\t*(u8 *)(buf + done) = fake_vmeread8(priv, addr + done,\n\t\t\t\t\taspace, cycle);\n\t\t\tdone += 1;\n\t\t}\n\n\t}\n\n\tif ((dwidth == VME_D16) || (dwidth == VME_D32)) {\n\t\tif ((count - done) & 0x2) {\n\t\t\t*(u16 *)(buf + done) = fake_vmeread16(priv, addr + done,\n\t\t\t\t\taspace, cycle);\n\t\t\tdone += 2;\n\t\t}\n\t}\n\tif ((count - done) & 0x1) {\n\t\t*(u8 *)(buf + done) = fake_vmeread8(priv, addr + done, aspace,\n\t\t\t\tcycle);\n\t\tdone += 1;\n\t}\n\nout:\n\tretval = count;\n\n\tspin_unlock(&image->lock);\n\n\treturn retval;\n}\n\nstatic noinline_for_stack void fake_vmewrite8(struct fake_driver *bridge,\n\t\t\t\t\t      u8 *buf, unsigned long long addr,\n\t\t\t\t\t      u32 aspace, u32 cycle)\n{\n\tint i;\n\tunsigned long long start, end, offset;\n\tu8 *loc;\n\n\tfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\n\t\tif (aspace != bridge->slaves[i].aspace)\n\t\t\tcontinue;\n\n\t\tif (cycle != bridge->slaves[i].cycle)\n\t\t\tcontinue;\n\n\t\tstart = bridge->slaves[i].vme_base;\n\t\tend = bridge->slaves[i].vme_base + bridge->slaves[i].size;\n\n\t\tif ((addr >= start) && (addr < end)) {\n\t\t\toffset = addr - bridge->slaves[i].vme_base;\n\t\t\tloc = (u8 *)((void *)bridge->slaves[i].buf_base + offset);\n\t\t\t*loc = *buf;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfake_lm_check(bridge, addr, aspace, cycle);\n}\n\nstatic noinline_for_stack void fake_vmewrite16(struct fake_driver *bridge,\n\t\t\t\t\t       u16 *buf, unsigned long long addr,\n\t\t\t\t\t       u32 aspace, u32 cycle)\n{\n\tint i;\n\tunsigned long long start, end, offset;\n\tu16 *loc;\n\n\tfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\n\t\tif (aspace != bridge->slaves[i].aspace)\n\t\t\tcontinue;\n\n\t\tif (cycle != bridge->slaves[i].cycle)\n\t\t\tcontinue;\n\n\t\tstart = bridge->slaves[i].vme_base;\n\t\tend = bridge->slaves[i].vme_base + bridge->slaves[i].size;\n\n\t\tif ((addr >= start) && ((addr + 1) < end)) {\n\t\t\toffset = addr - bridge->slaves[i].vme_base;\n\t\t\tloc = (u16 *)((void *)bridge->slaves[i].buf_base + offset);\n\t\t\t*loc = *buf;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfake_lm_check(bridge, addr, aspace, cycle);\n}\n\nstatic noinline_for_stack void fake_vmewrite32(struct fake_driver *bridge,\n\t\t\t\t\t       u32 *buf, unsigned long long addr,\n\t\t\t\t\t       u32 aspace, u32 cycle)\n{\n\tint i;\n\tunsigned long long start, end, offset;\n\tu32 *loc;\n\n\tfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\n\t\tif (aspace != bridge->slaves[i].aspace)\n\t\t\tcontinue;\n\n\t\tif (cycle != bridge->slaves[i].cycle)\n\t\t\tcontinue;\n\n\t\tstart = bridge->slaves[i].vme_base;\n\t\tend = bridge->slaves[i].vme_base + bridge->slaves[i].size;\n\n\t\tif ((addr >= start) && ((addr + 3) < end)) {\n\t\t\toffset = addr - bridge->slaves[i].vme_base;\n\t\t\tloc = (u32 *)((void *)bridge->slaves[i].buf_base + offset);\n\t\t\t*loc = *buf;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfake_lm_check(bridge, addr, aspace, cycle);\n}\n\nstatic ssize_t fake_master_write(struct vme_master_resource *image, void *buf,\n\t\tsize_t count, loff_t offset)\n{\n\tint retval = 0;\n\tu32 aspace, cycle, dwidth;\n\tunsigned long long addr;\n\tint i;\n\tunsigned int done = 0;\n\tunsigned int count32;\n\n\tstruct vme_bridge *fake_bridge;\n\tstruct fake_driver *bridge;\n\n\tfake_bridge = image->parent;\n\n\tbridge = fake_bridge->driver_priv;\n\n\ti = image->number;\n\n\taddr = bridge->masters[i].vme_base + offset;\n\taspace = bridge->masters[i].aspace;\n\tcycle = bridge->masters[i].cycle;\n\tdwidth = bridge->masters[i].dwidth;\n\n\tspin_lock(&image->lock);\n\n\t \n\tif (addr & 0x1) {\n\t\tfake_vmewrite8(bridge, (u8 *)buf, addr, aspace, cycle);\n\t\tdone += 1;\n\t\tif (done == count)\n\t\t\tgoto out;\n\t}\n\n\tif ((dwidth == VME_D16) || (dwidth == VME_D32)) {\n\t\tif ((addr + done) & 0x2) {\n\t\t\tif ((count - done) < 2) {\n\t\t\t\tfake_vmewrite8(bridge, (u8 *)(buf + done),\n\t\t\t\t\t\taddr + done, aspace, cycle);\n\t\t\t\tdone += 1;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tfake_vmewrite16(bridge, (u16 *)(buf + done),\n\t\t\t\t\t\taddr + done, aspace, cycle);\n\t\t\t\tdone += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dwidth == VME_D32) {\n\t\tcount32 = (count - done) & ~0x3;\n\t\twhile (done < count32) {\n\t\t\tfake_vmewrite32(bridge, (u32 *)(buf + done),\n\t\t\t\t\taddr + done, aspace, cycle);\n\t\t\tdone += 4;\n\t\t}\n\t} else if (dwidth == VME_D16) {\n\t\tcount32 = (count - done) & ~0x3;\n\t\twhile (done < count32) {\n\t\t\tfake_vmewrite16(bridge, (u16 *)(buf + done),\n\t\t\t\t\taddr + done, aspace, cycle);\n\t\t\tdone += 2;\n\t\t}\n\t} else if (dwidth == VME_D8) {\n\t\tcount32 = (count - done);\n\t\twhile (done < count32) {\n\t\t\tfake_vmewrite8(bridge, (u8 *)(buf + done), addr + done,\n\t\t\t\t\taspace, cycle);\n\t\t\tdone += 1;\n\t\t}\n\n\t}\n\n\tif ((dwidth == VME_D16) || (dwidth == VME_D32)) {\n\t\tif ((count - done) & 0x2) {\n\t\t\tfake_vmewrite16(bridge, (u16 *)(buf + done),\n\t\t\t\t\taddr + done, aspace, cycle);\n\t\t\tdone += 2;\n\t\t}\n\t}\n\n\tif ((count - done) & 0x1) {\n\t\tfake_vmewrite8(bridge, (u8 *)(buf + done), addr + done, aspace,\n\t\t\t\tcycle);\n\t\tdone += 1;\n\t}\n\nout:\n\tretval = count;\n\n\tspin_unlock(&image->lock);\n\n\treturn retval;\n}\n\n \nstatic unsigned int fake_master_rmw(struct vme_master_resource *image,\n\t\tunsigned int mask, unsigned int compare, unsigned int swap,\n\t\tloff_t offset)\n{\n\tu32 tmp, base;\n\tu32 aspace, cycle;\n\tint i;\n\tstruct fake_driver *bridge;\n\n\tbridge = image->parent->driver_priv;\n\n\t \n\ti = image->number;\n\n\tbase = bridge->masters[i].vme_base;\n\taspace = bridge->masters[i].aspace;\n\tcycle = bridge->masters[i].cycle;\n\n\t \n\tspin_lock(&image->lock);\n\n\t \n\ttmp = fake_vmeread32(bridge, base + offset, aspace, cycle);\n\n\t \n\tif ((tmp && mask) == (compare && mask)) {\n\t\ttmp = tmp | (mask | swap);\n\t\ttmp = tmp & (~mask | swap);\n\n\t\t \n\t\tfake_vmewrite32(bridge, &tmp, base + offset, aspace, cycle);\n\t}\n\n\t \n\tspin_unlock(&image->lock);\n\n\treturn tmp;\n}\n\n \nstatic int fake_lm_set(struct vme_lm_resource *lm, unsigned long long lm_base,\n\t\tu32 aspace, u32 cycle)\n{\n\tint i;\n\tstruct vme_bridge *fake_bridge;\n\tstruct fake_driver *bridge;\n\n\tfake_bridge = lm->parent;\n\n\tbridge = fake_bridge->driver_priv;\n\n\tmutex_lock(&lm->mtx);\n\n\t \n\tfor (i = 0; i < lm->monitors; i++) {\n\t\tif (bridge->lm_callback[i]) {\n\t\t\tmutex_unlock(&lm->mtx);\n\t\t\tpr_err(\"Location monitor callback attached, can't reset\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tswitch (aspace) {\n\tcase VME_A16:\n\tcase VME_A24:\n\tcase VME_A32:\n\tcase VME_A64:\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&lm->mtx);\n\t\tpr_err(\"Invalid address space\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbridge->lm_base = lm_base;\n\tbridge->lm_aspace = aspace;\n\tbridge->lm_cycle = cycle;\n\n\tmutex_unlock(&lm->mtx);\n\n\treturn 0;\n}\n\n \nstatic int fake_lm_get(struct vme_lm_resource *lm,\n\t\tunsigned long long *lm_base, u32 *aspace, u32 *cycle)\n{\n\tstruct fake_driver *bridge;\n\n\tbridge = lm->parent->driver_priv;\n\n\tmutex_lock(&lm->mtx);\n\n\t*lm_base = bridge->lm_base;\n\t*aspace = bridge->lm_aspace;\n\t*cycle = bridge->lm_cycle;\n\n\tmutex_unlock(&lm->mtx);\n\n\treturn bridge->lm_enabled;\n}\n\n \nstatic int fake_lm_attach(struct vme_lm_resource *lm, int monitor,\n\t\tvoid (*callback)(void *), void *data)\n{\n\tstruct vme_bridge *fake_bridge;\n\tstruct fake_driver *bridge;\n\n\tfake_bridge = lm->parent;\n\n\tbridge = fake_bridge->driver_priv;\n\n\tmutex_lock(&lm->mtx);\n\n\t \n\tif (bridge->lm_cycle == 0) {\n\t\tmutex_unlock(&lm->mtx);\n\t\tpr_err(\"Location monitor not properly configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (bridge->lm_callback[monitor]) {\n\t\tmutex_unlock(&lm->mtx);\n\t\tpr_err(\"Existing callback attached\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tbridge->lm_callback[monitor] = callback;\n\tbridge->lm_data[monitor] = data;\n\n\t \n\tbridge->lm_enabled = 1;\n\n\tmutex_unlock(&lm->mtx);\n\n\treturn 0;\n}\n\n \nstatic int fake_lm_detach(struct vme_lm_resource *lm, int monitor)\n{\n\tu32 tmp;\n\tint i;\n\tstruct fake_driver *bridge;\n\n\tbridge = lm->parent->driver_priv;\n\n\tmutex_lock(&lm->mtx);\n\n\t \n\tbridge->lm_callback[monitor] = NULL;\n\tbridge->lm_data[monitor] = NULL;\n\n\t \n\ttmp = 0;\n\tfor (i = 0; i < lm->monitors; i++) {\n\t\tif (bridge->lm_callback[i])\n\t\t\ttmp = 1;\n\t}\n\n\tif (tmp == 0)\n\t\tbridge->lm_enabled = 0;\n\n\tmutex_unlock(&lm->mtx);\n\n\treturn 0;\n}\n\n \nstatic int fake_slot_get(struct vme_bridge *fake_bridge)\n{\n\treturn geoid;\n}\n\nstatic void *fake_alloc_consistent(struct device *parent, size_t size,\n\t\tdma_addr_t *dma)\n{\n\tvoid *alloc = kmalloc(size, GFP_KERNEL);\n\n\tif (alloc)\n\t\t*dma = fake_ptr_to_pci(alloc);\n\n\treturn alloc;\n}\n\nstatic void fake_free_consistent(struct device *parent, size_t size,\n\t\tvoid *vaddr, dma_addr_t dma)\n{\n\tkfree(vaddr);\n \n}\n\n \nstatic int fake_crcsr_init(struct vme_bridge *fake_bridge)\n{\n\tu32 vstat;\n\tstruct fake_driver *bridge;\n\n\tbridge = fake_bridge->driver_priv;\n\n\t \n\tbridge->crcsr_kernel = kzalloc(VME_CRCSR_BUF_SIZE, GFP_KERNEL);\n\tbridge->crcsr_bus = fake_ptr_to_pci(bridge->crcsr_kernel);\n\tif (!bridge->crcsr_kernel)\n\t\treturn -ENOMEM;\n\n\tvstat = fake_slot_get(fake_bridge);\n\n\tpr_info(\"CR/CSR Offset: %d\\n\", vstat);\n\n\treturn 0;\n}\n\nstatic void fake_crcsr_exit(struct vme_bridge *fake_bridge)\n{\n\tstruct fake_driver *bridge;\n\n\tbridge = fake_bridge->driver_priv;\n\n\tkfree(bridge->crcsr_kernel);\n}\n\nstatic int __init fake_init(void)\n{\n\tint retval, i;\n\tstruct list_head *pos = NULL, *n;\n\tstruct vme_bridge *fake_bridge;\n\tstruct fake_driver *fake_device;\n\tstruct vme_master_resource *master_image;\n\tstruct vme_slave_resource *slave_image;\n\tstruct vme_lm_resource *lm;\n\n\t \n\tvme_root = root_device_register(\"vme\");\n\tif (IS_ERR(vme_root))\n\t\treturn PTR_ERR(vme_root);\n\n\t \n\tfake_bridge = kzalloc(sizeof(*fake_bridge), GFP_KERNEL);\n\tif (!fake_bridge) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_struct;\n\t}\n\n\tfake_device = kzalloc(sizeof(*fake_device), GFP_KERNEL);\n\tif (!fake_device) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_driver;\n\t}\n\n\tfake_bridge->driver_priv = fake_device;\n\n\tfake_bridge->parent = vme_root;\n\n\tfake_device->parent = fake_bridge;\n\n\t \n\tmutex_init(&fake_device->vme_int);\n\tmutex_init(&fake_bridge->irq_mtx);\n\ttasklet_init(&fake_device->int_tasklet, fake_VIRQ_tasklet,\n\t\t\t(unsigned long) fake_bridge);\n\n\tstrcpy(fake_bridge->name, driver_name);\n\n\t \n\tINIT_LIST_HEAD(&fake_bridge->master_resources);\n\tfor (i = 0; i < FAKE_MAX_MASTER; i++) {\n\t\tmaster_image = kmalloc(sizeof(*master_image), GFP_KERNEL);\n\t\tif (!master_image) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_master;\n\t\t}\n\t\tmaster_image->parent = fake_bridge;\n\t\tspin_lock_init(&master_image->lock);\n\t\tmaster_image->locked = 0;\n\t\tmaster_image->number = i;\n\t\tmaster_image->address_attr = VME_A16 | VME_A24 | VME_A32 |\n\t\t\tVME_A64;\n\t\tmaster_image->cycle_attr = VME_SCT | VME_BLT | VME_MBLT |\n\t\t\tVME_2eVME | VME_2eSST | VME_2eSSTB | VME_2eSST160 |\n\t\t\tVME_2eSST267 | VME_2eSST320 | VME_SUPER | VME_USER |\n\t\t\tVME_PROG | VME_DATA;\n\t\tmaster_image->width_attr = VME_D16 | VME_D32;\n\t\tmemset(&master_image->bus_resource, 0,\n\t\t\t\tsizeof(struct resource));\n\t\tmaster_image->kern_base  = NULL;\n\t\tlist_add_tail(&master_image->list,\n\t\t\t\t&fake_bridge->master_resources);\n\t}\n\n\t \n\tINIT_LIST_HEAD(&fake_bridge->slave_resources);\n\tfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\n\t\tslave_image = kmalloc(sizeof(*slave_image), GFP_KERNEL);\n\t\tif (!slave_image) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_slave;\n\t\t}\n\t\tslave_image->parent = fake_bridge;\n\t\tmutex_init(&slave_image->mtx);\n\t\tslave_image->locked = 0;\n\t\tslave_image->number = i;\n\t\tslave_image->address_attr = VME_A16 | VME_A24 | VME_A32 |\n\t\t\tVME_A64 | VME_CRCSR | VME_USER1 | VME_USER2 |\n\t\t\tVME_USER3 | VME_USER4;\n\t\tslave_image->cycle_attr = VME_SCT | VME_BLT | VME_MBLT |\n\t\t\tVME_2eVME | VME_2eSST | VME_2eSSTB | VME_2eSST160 |\n\t\t\tVME_2eSST267 | VME_2eSST320 | VME_SUPER | VME_USER |\n\t\t\tVME_PROG | VME_DATA;\n\t\tlist_add_tail(&slave_image->list,\n\t\t\t\t&fake_bridge->slave_resources);\n\t}\n\n\t \n\tINIT_LIST_HEAD(&fake_bridge->lm_resources);\n\tlm = kmalloc(sizeof(*lm), GFP_KERNEL);\n\tif (!lm) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_lm;\n\t}\n\tlm->parent = fake_bridge;\n\tmutex_init(&lm->mtx);\n\tlm->locked = 0;\n\tlm->number = 1;\n\tlm->monitors = 4;\n\tlist_add_tail(&lm->list, &fake_bridge->lm_resources);\n\n\tfake_bridge->slave_get = fake_slave_get;\n\tfake_bridge->slave_set = fake_slave_set;\n\tfake_bridge->master_get = fake_master_get;\n\tfake_bridge->master_set = fake_master_set;\n\tfake_bridge->master_read = fake_master_read;\n\tfake_bridge->master_write = fake_master_write;\n\tfake_bridge->master_rmw = fake_master_rmw;\n\tfake_bridge->irq_set = fake_irq_set;\n\tfake_bridge->irq_generate = fake_irq_generate;\n\tfake_bridge->lm_set = fake_lm_set;\n\tfake_bridge->lm_get = fake_lm_get;\n\tfake_bridge->lm_attach = fake_lm_attach;\n\tfake_bridge->lm_detach = fake_lm_detach;\n\tfake_bridge->slot_get = fake_slot_get;\n\tfake_bridge->alloc_consistent = fake_alloc_consistent;\n\tfake_bridge->free_consistent = fake_free_consistent;\n\n\tpr_info(\"Board is%s the VME system controller\\n\",\n\t\t\t(geoid == 1) ? \"\" : \" not\");\n\n\tpr_info(\"VME geographical address is set to %d\\n\", geoid);\n\n\tretval = fake_crcsr_init(fake_bridge);\n\tif (retval) {\n\t\tpr_err(\"CR/CSR configuration failed.\\n\");\n\t\tgoto err_crcsr;\n\t}\n\n\tretval = vme_register_bridge(fake_bridge);\n\tif (retval != 0) {\n\t\tpr_err(\"Chip Registration failed.\\n\");\n\t\tgoto err_reg;\n\t}\n\n\texit_pointer = fake_bridge;\n\n\treturn 0;\n\nerr_reg:\n\tfake_crcsr_exit(fake_bridge);\nerr_crcsr:\nerr_lm:\n\t \n\tlist_for_each_safe(pos, n, &fake_bridge->lm_resources) {\n\t\tlm = list_entry(pos, struct vme_lm_resource, list);\n\t\tlist_del(pos);\n\t\tkfree(lm);\n\t}\nerr_slave:\n\t \n\tlist_for_each_safe(pos, n, &fake_bridge->slave_resources) {\n\t\tslave_image = list_entry(pos, struct vme_slave_resource, list);\n\t\tlist_del(pos);\n\t\tkfree(slave_image);\n\t}\nerr_master:\n\t \n\tlist_for_each_safe(pos, n, &fake_bridge->master_resources) {\n\t\tmaster_image = list_entry(pos, struct vme_master_resource,\n\t\t\t\tlist);\n\t\tlist_del(pos);\n\t\tkfree(master_image);\n\t}\n\n\tkfree(fake_device);\nerr_driver:\n\tkfree(fake_bridge);\nerr_struct:\n\treturn retval;\n}\n\nstatic void __exit fake_exit(void)\n{\n\tstruct list_head *pos = NULL;\n\tstruct list_head *tmplist;\n\tstruct vme_master_resource *master_image;\n\tstruct vme_slave_resource *slave_image;\n\tint i;\n\tstruct vme_bridge *fake_bridge;\n\tstruct fake_driver *bridge;\n\n\tfake_bridge = exit_pointer;\n\n\tbridge = fake_bridge->driver_priv;\n\n\tpr_debug(\"Driver is being unloaded.\\n\");\n\n\t \n\tfor (i = 0; i < FAKE_MAX_MASTER; i++)\n\t\tbridge->masters[i].enabled = 0;\n\n\tfor (i = 0; i < FAKE_MAX_SLAVE; i++)\n\t\tbridge->slaves[i].enabled = 0;\n\n\t \n\tbridge->lm_enabled = 0;\n\n\tvme_unregister_bridge(fake_bridge);\n\n\tfake_crcsr_exit(fake_bridge);\n\t \n\tlist_for_each_safe(pos, tmplist, &fake_bridge->slave_resources) {\n\t\tslave_image = list_entry(pos, struct vme_slave_resource, list);\n\t\tlist_del(pos);\n\t\tkfree(slave_image);\n\t}\n\n\t \n\tlist_for_each_safe(pos, tmplist, &fake_bridge->master_resources) {\n\t\tmaster_image = list_entry(pos, struct vme_master_resource,\n\t\t\t\tlist);\n\t\tlist_del(pos);\n\t\tkfree(master_image);\n\t}\n\n\tkfree(fake_bridge->driver_priv);\n\n\tkfree(fake_bridge);\n\n\troot_device_unregister(vme_root);\n}\n\nMODULE_PARM_DESC(geoid, \"Set geographical addressing\");\nmodule_param(geoid, int, 0);\n\nMODULE_DESCRIPTION(\"Fake VME bridge driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(fake_init);\nmodule_exit(fake_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}