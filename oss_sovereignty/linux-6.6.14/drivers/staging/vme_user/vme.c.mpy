{
  "module_name": "vme.c",
  "hash_id": "037de02592d47316488f42814bc138e084622fffc7d79621c926a66ba48c5211",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vme_user/vme.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/poll.h>\n#include <linux/highmem.h>\n#include <linux/interrupt.h>\n#include <linux/pagemap.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/syscalls.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#include \"vme.h\"\n#include \"vme_bridge.h\"\n\n \nstatic unsigned int vme_bus_numbers;\nstatic LIST_HEAD(vme_bus_list);\nstatic DEFINE_MUTEX(vme_buses_lock);\n\nstatic int __init vme_init(void);\n\nstatic struct vme_dev *dev_to_vme_dev(struct device *dev)\n{\n\treturn container_of(dev, struct vme_dev, dev);\n}\n\n \nstatic struct vme_bridge *find_bridge(struct vme_resource *resource)\n{\n\t \n\tswitch (resource->type) {\n\tcase VME_MASTER:\n\t\treturn list_entry(resource->entry, struct vme_master_resource,\n\t\t\tlist)->parent;\n\tcase VME_SLAVE:\n\t\treturn list_entry(resource->entry, struct vme_slave_resource,\n\t\t\tlist)->parent;\n\tcase VME_DMA:\n\t\treturn list_entry(resource->entry, struct vme_dma_resource,\n\t\t\tlist)->parent;\n\tcase VME_LM:\n\t\treturn list_entry(resource->entry, struct vme_lm_resource,\n\t\t\tlist)->parent;\n\tdefault:\n\t\tprintk(KERN_ERR \"Unknown resource type\\n\");\n\t\treturn NULL;\n\t}\n}\n\n \nvoid *vme_alloc_consistent(struct vme_resource *resource, size_t size,\n\t\t\t   dma_addr_t *dma)\n{\n\tstruct vme_bridge *bridge;\n\n\tif (!resource) {\n\t\tprintk(KERN_ERR \"No resource\\n\");\n\t\treturn NULL;\n\t}\n\n\tbridge = find_bridge(resource);\n\tif (!bridge) {\n\t\tprintk(KERN_ERR \"Can't find bridge\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!bridge->parent) {\n\t\tprintk(KERN_ERR \"Dev entry NULL for bridge %s\\n\", bridge->name);\n\t\treturn NULL;\n\t}\n\n\tif (!bridge->alloc_consistent) {\n\t\tprintk(KERN_ERR \"alloc_consistent not supported by bridge %s\\n\",\n\t\t       bridge->name);\n\t\treturn NULL;\n\t}\n\n\treturn bridge->alloc_consistent(bridge->parent, size, dma);\n}\nEXPORT_SYMBOL(vme_alloc_consistent);\n\n \nvoid vme_free_consistent(struct vme_resource *resource, size_t size,\n\t\t\t void *vaddr, dma_addr_t dma)\n{\n\tstruct vme_bridge *bridge;\n\n\tif (!resource) {\n\t\tprintk(KERN_ERR \"No resource\\n\");\n\t\treturn;\n\t}\n\n\tbridge = find_bridge(resource);\n\tif (!bridge) {\n\t\tprintk(KERN_ERR \"Can't find bridge\\n\");\n\t\treturn;\n\t}\n\n\tif (!bridge->parent) {\n\t\tprintk(KERN_ERR \"Dev entry NULL for bridge %s\\n\", bridge->name);\n\t\treturn;\n\t}\n\n\tif (!bridge->free_consistent) {\n\t\tprintk(KERN_ERR \"free_consistent not supported by bridge %s\\n\",\n\t\t       bridge->name);\n\t\treturn;\n\t}\n\n\tbridge->free_consistent(bridge->parent, size, vaddr, dma);\n}\nEXPORT_SYMBOL(vme_free_consistent);\n\n \nsize_t vme_get_size(struct vme_resource *resource)\n{\n\tint enabled, retval;\n\tunsigned long long base, size;\n\tdma_addr_t buf_base;\n\tu32 aspace, cycle, dwidth;\n\n\tswitch (resource->type) {\n\tcase VME_MASTER:\n\t\tretval = vme_master_get(resource, &enabled, &base, &size,\n\t\t\t\t\t&aspace, &cycle, &dwidth);\n\t\tif (retval)\n\t\t\treturn 0;\n\n\t\treturn size;\n\tcase VME_SLAVE:\n\t\tretval = vme_slave_get(resource, &enabled, &base, &size,\n\t\t\t\t       &buf_base, &aspace, &cycle);\n\t\tif (retval)\n\t\t\treturn 0;\n\n\t\treturn size;\n\tcase VME_DMA:\n\t\treturn 0;\n\tdefault:\n\t\tprintk(KERN_ERR \"Unknown resource type\\n\");\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(vme_get_size);\n\nint vme_check_window(u32 aspace, unsigned long long vme_base,\n\t\t     unsigned long long size)\n{\n\tint retval = 0;\n\n\tif (vme_base + size < size)\n\t\treturn -EINVAL;\n\n\tswitch (aspace) {\n\tcase VME_A16:\n\t\tif (vme_base + size > VME_A16_MAX)\n\t\t\tretval = -EFAULT;\n\t\tbreak;\n\tcase VME_A24:\n\t\tif (vme_base + size > VME_A24_MAX)\n\t\t\tretval = -EFAULT;\n\t\tbreak;\n\tcase VME_A32:\n\t\tif (vme_base + size > VME_A32_MAX)\n\t\t\tretval = -EFAULT;\n\t\tbreak;\n\tcase VME_A64:\n\t\t \n\t\tbreak;\n\tcase VME_CRCSR:\n\t\tif (vme_base + size > VME_CRCSR_MAX)\n\t\t\tretval = -EFAULT;\n\t\tbreak;\n\tcase VME_USER1:\n\tcase VME_USER2:\n\tcase VME_USER3:\n\tcase VME_USER4:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Invalid address space\\n\");\n\t\tretval = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\nEXPORT_SYMBOL(vme_check_window);\n\nstatic u32 vme_get_aspace(int am)\n{\n\tswitch (am) {\n\tcase 0x29:\n\tcase 0x2D:\n\t\treturn VME_A16;\n\tcase 0x38:\n\tcase 0x39:\n\tcase 0x3A:\n\tcase 0x3B:\n\tcase 0x3C:\n\tcase 0x3D:\n\tcase 0x3E:\n\tcase 0x3F:\n\t\treturn VME_A24;\n\tcase 0x8:\n\tcase 0x9:\n\tcase 0xA:\n\tcase 0xB:\n\tcase 0xC:\n\tcase 0xD:\n\tcase 0xE:\n\tcase 0xF:\n\t\treturn VME_A32;\n\tcase 0x0:\n\tcase 0x1:\n\tcase 0x3:\n\t\treturn VME_A64;\n\t}\n\n\treturn 0;\n}\n\n \nstruct vme_resource *vme_slave_request(struct vme_dev *vdev, u32 address,\n\t\t\t\t       u32 cycle)\n{\n\tstruct vme_bridge *bridge;\n\tstruct list_head *slave_pos = NULL;\n\tstruct vme_slave_resource *allocated_image = NULL;\n\tstruct vme_slave_resource *slave_image = NULL;\n\tstruct vme_resource *resource = NULL;\n\n\tbridge = vdev->bridge;\n\tif (!bridge) {\n\t\tprintk(KERN_ERR \"Can't find VME bus\\n\");\n\t\tgoto err_bus;\n\t}\n\n\t \n\tlist_for_each(slave_pos, &bridge->slave_resources) {\n\t\tslave_image = list_entry(slave_pos,\n\t\t\t\t\t struct vme_slave_resource, list);\n\n\t\tif (!slave_image) {\n\t\t\tprintk(KERN_ERR \"Registered NULL Slave resource\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmutex_lock(&slave_image->mtx);\n\t\tif (((slave_image->address_attr & address) == address) &&\n\t\t    ((slave_image->cycle_attr & cycle) == cycle) &&\n\t\t    (slave_image->locked == 0)) {\n\t\t\tslave_image->locked = 1;\n\t\t\tmutex_unlock(&slave_image->mtx);\n\t\t\tallocated_image = slave_image;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&slave_image->mtx);\n\t}\n\n\t \n\tif (!allocated_image)\n\t\tgoto err_image;\n\n\tresource = kmalloc(sizeof(*resource), GFP_KERNEL);\n\tif (!resource)\n\t\tgoto err_alloc;\n\n\tresource->type = VME_SLAVE;\n\tresource->entry = &allocated_image->list;\n\n\treturn resource;\n\nerr_alloc:\n\t \n\tmutex_lock(&slave_image->mtx);\n\tslave_image->locked = 0;\n\tmutex_unlock(&slave_image->mtx);\nerr_image:\nerr_bus:\n\treturn NULL;\n}\nEXPORT_SYMBOL(vme_slave_request);\n\n \nint vme_slave_set(struct vme_resource *resource, int enabled,\n\t\t  unsigned long long vme_base, unsigned long long size,\n\t\t  dma_addr_t buf_base, u32 aspace, u32 cycle)\n{\n\tstruct vme_bridge *bridge = find_bridge(resource);\n\tstruct vme_slave_resource *image;\n\tint retval;\n\n\tif (resource->type != VME_SLAVE) {\n\t\tprintk(KERN_ERR \"Not a slave resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\timage = list_entry(resource->entry, struct vme_slave_resource, list);\n\n\tif (!bridge->slave_set) {\n\t\tprintk(KERN_ERR \"Function not supported\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tif (!(((image->address_attr & aspace) == aspace) &&\n\t      ((image->cycle_attr & cycle) == cycle))) {\n\t\tprintk(KERN_ERR \"Invalid attributes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tretval = vme_check_window(aspace, vme_base, size);\n\tif (retval)\n\t\treturn retval;\n\n\treturn bridge->slave_set(image, enabled, vme_base, size, buf_base,\n\t\taspace, cycle);\n}\nEXPORT_SYMBOL(vme_slave_set);\n\n \nint vme_slave_get(struct vme_resource *resource, int *enabled,\n\t\t  unsigned long long *vme_base, unsigned long long *size,\n\t\t  dma_addr_t *buf_base, u32 *aspace, u32 *cycle)\n{\n\tstruct vme_bridge *bridge = find_bridge(resource);\n\tstruct vme_slave_resource *image;\n\n\tif (resource->type != VME_SLAVE) {\n\t\tprintk(KERN_ERR \"Not a slave resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\timage = list_entry(resource->entry, struct vme_slave_resource, list);\n\n\tif (!bridge->slave_get) {\n\t\tprintk(KERN_ERR \"vme_slave_get not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn bridge->slave_get(image, enabled, vme_base, size, buf_base,\n\t\taspace, cycle);\n}\nEXPORT_SYMBOL(vme_slave_get);\n\n \nvoid vme_slave_free(struct vme_resource *resource)\n{\n\tstruct vme_slave_resource *slave_image;\n\n\tif (resource->type != VME_SLAVE) {\n\t\tprintk(KERN_ERR \"Not a slave resource\\n\");\n\t\treturn;\n\t}\n\n\tslave_image = list_entry(resource->entry, struct vme_slave_resource,\n\t\t\t\t list);\n\tif (!slave_image) {\n\t\tprintk(KERN_ERR \"Can't find slave resource\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmutex_lock(&slave_image->mtx);\n\tif (slave_image->locked == 0)\n\t\tprintk(KERN_ERR \"Image is already free\\n\");\n\n\tslave_image->locked = 0;\n\tmutex_unlock(&slave_image->mtx);\n\n\t \n\tkfree(resource);\n}\nEXPORT_SYMBOL(vme_slave_free);\n\n \nstruct vme_resource *vme_master_request(struct vme_dev *vdev, u32 address,\n\t\t\t\t\tu32 cycle, u32 dwidth)\n{\n\tstruct vme_bridge *bridge;\n\tstruct list_head *master_pos = NULL;\n\tstruct vme_master_resource *allocated_image = NULL;\n\tstruct vme_master_resource *master_image = NULL;\n\tstruct vme_resource *resource = NULL;\n\n\tbridge = vdev->bridge;\n\tif (!bridge) {\n\t\tprintk(KERN_ERR \"Can't find VME bus\\n\");\n\t\tgoto err_bus;\n\t}\n\n\t \n\tlist_for_each(master_pos, &bridge->master_resources) {\n\t\tmaster_image = list_entry(master_pos,\n\t\t\t\t\t  struct vme_master_resource, list);\n\n\t\tif (!master_image) {\n\t\t\tprintk(KERN_WARNING \"Registered NULL master resource\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tspin_lock(&master_image->lock);\n\t\tif (((master_image->address_attr & address) == address) &&\n\t\t    ((master_image->cycle_attr & cycle) == cycle) &&\n\t\t    ((master_image->width_attr & dwidth) == dwidth) &&\n\t\t    (master_image->locked == 0)) {\n\t\t\tmaster_image->locked = 1;\n\t\t\tspin_unlock(&master_image->lock);\n\t\t\tallocated_image = master_image;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&master_image->lock);\n\t}\n\n\t \n\tif (!allocated_image) {\n\t\tprintk(KERN_ERR \"Can't find a suitable resource\\n\");\n\t\tgoto err_image;\n\t}\n\n\tresource = kmalloc(sizeof(*resource), GFP_KERNEL);\n\tif (!resource)\n\t\tgoto err_alloc;\n\n\tresource->type = VME_MASTER;\n\tresource->entry = &allocated_image->list;\n\n\treturn resource;\n\nerr_alloc:\n\t \n\tspin_lock(&master_image->lock);\n\tmaster_image->locked = 0;\n\tspin_unlock(&master_image->lock);\nerr_image:\nerr_bus:\n\treturn NULL;\n}\nEXPORT_SYMBOL(vme_master_request);\n\n \nint vme_master_set(struct vme_resource *resource, int enabled,\n\t\t   unsigned long long vme_base, unsigned long long size,\n\t\t   u32 aspace, u32 cycle, u32 dwidth)\n{\n\tstruct vme_bridge *bridge = find_bridge(resource);\n\tstruct vme_master_resource *image;\n\tint retval;\n\n\tif (resource->type != VME_MASTER) {\n\t\tprintk(KERN_ERR \"Not a master resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\timage = list_entry(resource->entry, struct vme_master_resource, list);\n\n\tif (!bridge->master_set) {\n\t\tprintk(KERN_WARNING \"vme_master_set not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(((image->address_attr & aspace) == aspace) &&\n\t      ((image->cycle_attr & cycle) == cycle) &&\n\t      ((image->width_attr & dwidth) == dwidth))) {\n\t\tprintk(KERN_WARNING \"Invalid attributes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tretval = vme_check_window(aspace, vme_base, size);\n\tif (retval)\n\t\treturn retval;\n\n\treturn bridge->master_set(image, enabled, vme_base, size, aspace,\n\t\tcycle, dwidth);\n}\nEXPORT_SYMBOL(vme_master_set);\n\n \nint vme_master_get(struct vme_resource *resource, int *enabled,\n\t\t   unsigned long long *vme_base, unsigned long long *size,\n\t\t   u32 *aspace, u32 *cycle, u32 *dwidth)\n{\n\tstruct vme_bridge *bridge = find_bridge(resource);\n\tstruct vme_master_resource *image;\n\n\tif (resource->type != VME_MASTER) {\n\t\tprintk(KERN_ERR \"Not a master resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\timage = list_entry(resource->entry, struct vme_master_resource, list);\n\n\tif (!bridge->master_get) {\n\t\tprintk(KERN_WARNING \"%s not supported\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn bridge->master_get(image, enabled, vme_base, size, aspace,\n\t\tcycle, dwidth);\n}\nEXPORT_SYMBOL(vme_master_get);\n\n \nssize_t vme_master_read(struct vme_resource *resource, void *buf, size_t count,\n\t\t\tloff_t offset)\n{\n\tstruct vme_bridge *bridge = find_bridge(resource);\n\tstruct vme_master_resource *image;\n\tsize_t length;\n\n\tif (!bridge->master_read) {\n\t\tprintk(KERN_WARNING \"Reading from resource not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (resource->type != VME_MASTER) {\n\t\tprintk(KERN_ERR \"Not a master resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\timage = list_entry(resource->entry, struct vme_master_resource, list);\n\n\tlength = vme_get_size(resource);\n\n\tif (offset > length) {\n\t\tprintk(KERN_WARNING \"Invalid Offset\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif ((offset + count) > length)\n\t\tcount = length - offset;\n\n\treturn bridge->master_read(image, buf, count, offset);\n}\nEXPORT_SYMBOL(vme_master_read);\n\n \nssize_t vme_master_write(struct vme_resource *resource, void *buf,\n\t\t\t size_t count, loff_t offset)\n{\n\tstruct vme_bridge *bridge = find_bridge(resource);\n\tstruct vme_master_resource *image;\n\tsize_t length;\n\n\tif (!bridge->master_write) {\n\t\tprintk(KERN_WARNING \"Writing to resource not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (resource->type != VME_MASTER) {\n\t\tprintk(KERN_ERR \"Not a master resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\timage = list_entry(resource->entry, struct vme_master_resource, list);\n\n\tlength = vme_get_size(resource);\n\n\tif (offset > length) {\n\t\tprintk(KERN_WARNING \"Invalid Offset\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif ((offset + count) > length)\n\t\tcount = length - offset;\n\n\treturn bridge->master_write(image, buf, count, offset);\n}\nEXPORT_SYMBOL(vme_master_write);\n\n \nunsigned int vme_master_rmw(struct vme_resource *resource, unsigned int mask,\n\t\t\t    unsigned int compare, unsigned int swap, loff_t offset)\n{\n\tstruct vme_bridge *bridge = find_bridge(resource);\n\tstruct vme_master_resource *image;\n\n\tif (!bridge->master_rmw) {\n\t\tprintk(KERN_WARNING \"Writing to resource not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (resource->type != VME_MASTER) {\n\t\tprintk(KERN_ERR \"Not a master resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\timage = list_entry(resource->entry, struct vme_master_resource, list);\n\n\treturn bridge->master_rmw(image, mask, compare, swap, offset);\n}\nEXPORT_SYMBOL(vme_master_rmw);\n\n \nint vme_master_mmap(struct vme_resource *resource, struct vm_area_struct *vma)\n{\n\tstruct vme_master_resource *image;\n\tphys_addr_t phys_addr;\n\tunsigned long vma_size;\n\n\tif (resource->type != VME_MASTER) {\n\t\tpr_err(\"Not a master resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\timage = list_entry(resource->entry, struct vme_master_resource, list);\n\tphys_addr = image->bus_resource.start + (vma->vm_pgoff << PAGE_SHIFT);\n\tvma_size = vma->vm_end - vma->vm_start;\n\n\tif (phys_addr + vma_size > image->bus_resource.end + 1) {\n\t\tpr_err(\"Map size cannot exceed the window size\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\treturn vm_iomap_memory(vma, phys_addr, vma->vm_end - vma->vm_start);\n}\nEXPORT_SYMBOL(vme_master_mmap);\n\n \nvoid vme_master_free(struct vme_resource *resource)\n{\n\tstruct vme_master_resource *master_image;\n\n\tif (resource->type != VME_MASTER) {\n\t\tprintk(KERN_ERR \"Not a master resource\\n\");\n\t\treturn;\n\t}\n\n\tmaster_image = list_entry(resource->entry, struct vme_master_resource,\n\t\t\t\t  list);\n\tif (!master_image) {\n\t\tprintk(KERN_ERR \"Can't find master resource\\n\");\n\t\treturn;\n\t}\n\n\t \n\tspin_lock(&master_image->lock);\n\tif (master_image->locked == 0)\n\t\tprintk(KERN_ERR \"Image is already free\\n\");\n\n\tmaster_image->locked = 0;\n\tspin_unlock(&master_image->lock);\n\n\t \n\tkfree(resource);\n}\nEXPORT_SYMBOL(vme_master_free);\n\n \nstruct vme_resource *vme_dma_request(struct vme_dev *vdev, u32 route)\n{\n\tstruct vme_bridge *bridge;\n\tstruct list_head *dma_pos = NULL;\n\tstruct vme_dma_resource *allocated_ctrlr = NULL;\n\tstruct vme_dma_resource *dma_ctrlr = NULL;\n\tstruct vme_resource *resource = NULL;\n\n\t \n\tprintk(KERN_ERR \"No VME resource Attribute tests done\\n\");\n\n\tbridge = vdev->bridge;\n\tif (!bridge) {\n\t\tprintk(KERN_ERR \"Can't find VME bus\\n\");\n\t\tgoto err_bus;\n\t}\n\n\t \n\tlist_for_each(dma_pos, &bridge->dma_resources) {\n\t\tdma_ctrlr = list_entry(dma_pos,\n\t\t\t\t       struct vme_dma_resource, list);\n\t\tif (!dma_ctrlr) {\n\t\t\tprintk(KERN_ERR \"Registered NULL DMA resource\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmutex_lock(&dma_ctrlr->mtx);\n\t\tif (((dma_ctrlr->route_attr & route) == route) &&\n\t\t    (dma_ctrlr->locked == 0)) {\n\t\t\tdma_ctrlr->locked = 1;\n\t\t\tmutex_unlock(&dma_ctrlr->mtx);\n\t\t\tallocated_ctrlr = dma_ctrlr;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&dma_ctrlr->mtx);\n\t}\n\n\t \n\tif (!allocated_ctrlr)\n\t\tgoto err_ctrlr;\n\n\tresource = kmalloc(sizeof(*resource), GFP_KERNEL);\n\tif (!resource)\n\t\tgoto err_alloc;\n\n\tresource->type = VME_DMA;\n\tresource->entry = &allocated_ctrlr->list;\n\n\treturn resource;\n\nerr_alloc:\n\t \n\tmutex_lock(&dma_ctrlr->mtx);\n\tdma_ctrlr->locked = 0;\n\tmutex_unlock(&dma_ctrlr->mtx);\nerr_ctrlr:\nerr_bus:\n\treturn NULL;\n}\nEXPORT_SYMBOL(vme_dma_request);\n\n \nstruct vme_dma_list *vme_new_dma_list(struct vme_resource *resource)\n{\n\tstruct vme_dma_list *dma_list;\n\n\tif (resource->type != VME_DMA) {\n\t\tprintk(KERN_ERR \"Not a DMA resource\\n\");\n\t\treturn NULL;\n\t}\n\n\tdma_list = kmalloc(sizeof(*dma_list), GFP_KERNEL);\n\tif (!dma_list)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&dma_list->entries);\n\tdma_list->parent = list_entry(resource->entry,\n\t\t\t\t      struct vme_dma_resource,\n\t\t\t\t      list);\n\tmutex_init(&dma_list->mtx);\n\n\treturn dma_list;\n}\nEXPORT_SYMBOL(vme_new_dma_list);\n\n \nstruct vme_dma_attr *vme_dma_pattern_attribute(u32 pattern, u32 type)\n{\n\tstruct vme_dma_attr *attributes;\n\tstruct vme_dma_pattern *pattern_attr;\n\n\tattributes = kmalloc(sizeof(*attributes), GFP_KERNEL);\n\tif (!attributes)\n\t\tgoto err_attr;\n\n\tpattern_attr = kmalloc(sizeof(*pattern_attr), GFP_KERNEL);\n\tif (!pattern_attr)\n\t\tgoto err_pat;\n\n\tattributes->type = VME_DMA_PATTERN;\n\tattributes->private = (void *)pattern_attr;\n\n\tpattern_attr->pattern = pattern;\n\tpattern_attr->type = type;\n\n\treturn attributes;\n\nerr_pat:\n\tkfree(attributes);\nerr_attr:\n\treturn NULL;\n}\nEXPORT_SYMBOL(vme_dma_pattern_attribute);\n\n \nstruct vme_dma_attr *vme_dma_pci_attribute(dma_addr_t address)\n{\n\tstruct vme_dma_attr *attributes;\n\tstruct vme_dma_pci *pci_attr;\n\n\t \n\n\tattributes = kmalloc(sizeof(*attributes), GFP_KERNEL);\n\tif (!attributes)\n\t\tgoto err_attr;\n\n\tpci_attr = kmalloc(sizeof(*pci_attr), GFP_KERNEL);\n\tif (!pci_attr)\n\t\tgoto err_pci;\n\n\tattributes->type = VME_DMA_PCI;\n\tattributes->private = (void *)pci_attr;\n\n\tpci_attr->address = address;\n\n\treturn attributes;\n\nerr_pci:\n\tkfree(attributes);\nerr_attr:\n\treturn NULL;\n}\nEXPORT_SYMBOL(vme_dma_pci_attribute);\n\n \nstruct vme_dma_attr *vme_dma_vme_attribute(unsigned long long address,\n\t\t\t\t\t   u32 aspace, u32 cycle, u32 dwidth)\n{\n\tstruct vme_dma_attr *attributes;\n\tstruct vme_dma_vme *vme_attr;\n\n\tattributes = kmalloc(sizeof(*attributes), GFP_KERNEL);\n\tif (!attributes)\n\t\tgoto err_attr;\n\n\tvme_attr = kmalloc(sizeof(*vme_attr), GFP_KERNEL);\n\tif (!vme_attr)\n\t\tgoto err_vme;\n\n\tattributes->type = VME_DMA_VME;\n\tattributes->private = (void *)vme_attr;\n\n\tvme_attr->address = address;\n\tvme_attr->aspace = aspace;\n\tvme_attr->cycle = cycle;\n\tvme_attr->dwidth = dwidth;\n\n\treturn attributes;\n\nerr_vme:\n\tkfree(attributes);\nerr_attr:\n\treturn NULL;\n}\nEXPORT_SYMBOL(vme_dma_vme_attribute);\n\n \nvoid vme_dma_free_attribute(struct vme_dma_attr *attributes)\n{\n\tkfree(attributes->private);\n\tkfree(attributes);\n}\nEXPORT_SYMBOL(vme_dma_free_attribute);\n\n \nint vme_dma_list_add(struct vme_dma_list *list, struct vme_dma_attr *src,\n\t\t     struct vme_dma_attr *dest, size_t count)\n{\n\tstruct vme_bridge *bridge = list->parent->parent;\n\tint retval;\n\n\tif (!bridge->dma_list_add) {\n\t\tprintk(KERN_WARNING \"Link List DMA generation not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!mutex_trylock(&list->mtx)) {\n\t\tprintk(KERN_ERR \"Link List already submitted\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tretval = bridge->dma_list_add(list, src, dest, count);\n\n\tmutex_unlock(&list->mtx);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(vme_dma_list_add);\n\n \nint vme_dma_list_exec(struct vme_dma_list *list)\n{\n\tstruct vme_bridge *bridge = list->parent->parent;\n\tint retval;\n\n\tif (!bridge->dma_list_exec) {\n\t\tprintk(KERN_ERR \"Link List DMA execution not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&list->mtx);\n\n\tretval = bridge->dma_list_exec(list);\n\n\tmutex_unlock(&list->mtx);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(vme_dma_list_exec);\n\n \nint vme_dma_list_free(struct vme_dma_list *list)\n{\n\tstruct vme_bridge *bridge = list->parent->parent;\n\tint retval;\n\n\tif (!bridge->dma_list_empty) {\n\t\tprintk(KERN_WARNING \"Emptying of Link Lists not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!mutex_trylock(&list->mtx)) {\n\t\tprintk(KERN_ERR \"Link List in use\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tretval = bridge->dma_list_empty(list);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"Unable to empty link-list entries\\n\");\n\t\tmutex_unlock(&list->mtx);\n\t\treturn retval;\n\t}\n\tmutex_unlock(&list->mtx);\n\tkfree(list);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(vme_dma_list_free);\n\n \nint vme_dma_free(struct vme_resource *resource)\n{\n\tstruct vme_dma_resource *ctrlr;\n\n\tif (resource->type != VME_DMA) {\n\t\tprintk(KERN_ERR \"Not a DMA resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tctrlr = list_entry(resource->entry, struct vme_dma_resource, list);\n\n\tif (!mutex_trylock(&ctrlr->mtx)) {\n\t\tprintk(KERN_ERR \"Resource busy, can't free\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!(list_empty(&ctrlr->pending) && list_empty(&ctrlr->running))) {\n\t\tprintk(KERN_WARNING \"Resource still processing transfers\\n\");\n\t\tmutex_unlock(&ctrlr->mtx);\n\t\treturn -EBUSY;\n\t}\n\n\tctrlr->locked = 0;\n\n\tmutex_unlock(&ctrlr->mtx);\n\n\tkfree(resource);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vme_dma_free);\n\nvoid vme_bus_error_handler(struct vme_bridge *bridge,\n\t\t\t   unsigned long long address, int am)\n{\n\tstruct list_head *handler_pos = NULL;\n\tstruct vme_error_handler *handler;\n\tint handler_triggered = 0;\n\tu32 aspace = vme_get_aspace(am);\n\n\tlist_for_each(handler_pos, &bridge->vme_error_handlers) {\n\t\thandler = list_entry(handler_pos, struct vme_error_handler,\n\t\t\t\t     list);\n\t\tif ((aspace == handler->aspace) &&\n\t\t    (address >= handler->start) &&\n\t\t    (address < handler->end)) {\n\t\t\tif (!handler->num_errors)\n\t\t\t\thandler->first_error = address;\n\t\t\tif (handler->num_errors != UINT_MAX)\n\t\t\t\thandler->num_errors++;\n\t\t\thandler_triggered = 1;\n\t\t}\n\t}\n\n\tif (!handler_triggered)\n\t\tdev_err(bridge->parent,\n\t\t\t\"Unhandled VME access error at address 0x%llx\\n\",\n\t\t\taddress);\n}\nEXPORT_SYMBOL(vme_bus_error_handler);\n\nstruct vme_error_handler *vme_register_error_handler(struct vme_bridge *bridge, u32 aspace,\n\t\t\t\t\t\t     unsigned long long address, size_t len)\n{\n\tstruct vme_error_handler *handler;\n\n\thandler = kmalloc(sizeof(*handler), GFP_ATOMIC);\n\tif (!handler)\n\t\treturn NULL;\n\n\thandler->aspace = aspace;\n\thandler->start = address;\n\thandler->end = address + len;\n\thandler->num_errors = 0;\n\thandler->first_error = 0;\n\tlist_add_tail(&handler->list, &bridge->vme_error_handlers);\n\n\treturn handler;\n}\nEXPORT_SYMBOL(vme_register_error_handler);\n\nvoid vme_unregister_error_handler(struct vme_error_handler *handler)\n{\n\tlist_del(&handler->list);\n\tkfree(handler);\n}\nEXPORT_SYMBOL(vme_unregister_error_handler);\n\nvoid vme_irq_handler(struct vme_bridge *bridge, int level, int statid)\n{\n\tvoid (*call)(int, int, void *);\n\tvoid *priv_data;\n\n\tcall = bridge->irq[level - 1].callback[statid].func;\n\tpriv_data = bridge->irq[level - 1].callback[statid].priv_data;\n\tif (call)\n\t\tcall(level, statid, priv_data);\n\telse\n\t\tprintk(KERN_WARNING \"Spurious VME interrupt, level:%x, vector:%x\\n\",\n\t\t       level, statid);\n}\nEXPORT_SYMBOL(vme_irq_handler);\n\n \nint vme_irq_request(struct vme_dev *vdev, int level, int statid,\n\t\t    void (*callback)(int, int, void *),\n\t\t    void *priv_data)\n{\n\tstruct vme_bridge *bridge;\n\n\tbridge = vdev->bridge;\n\tif (!bridge) {\n\t\tprintk(KERN_ERR \"Can't find VME bus\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((level < 1) || (level > 7)) {\n\t\tprintk(KERN_ERR \"Invalid interrupt level\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bridge->irq_set) {\n\t\tprintk(KERN_ERR \"Configuring interrupts not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&bridge->irq_mtx);\n\n\tif (bridge->irq[level - 1].callback[statid].func) {\n\t\tmutex_unlock(&bridge->irq_mtx);\n\t\tprintk(KERN_WARNING \"VME Interrupt already taken\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tbridge->irq[level - 1].count++;\n\tbridge->irq[level - 1].callback[statid].priv_data = priv_data;\n\tbridge->irq[level - 1].callback[statid].func = callback;\n\n\t \n\tbridge->irq_set(bridge, level, 1, 1);\n\n\tmutex_unlock(&bridge->irq_mtx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vme_irq_request);\n\n \nvoid vme_irq_free(struct vme_dev *vdev, int level, int statid)\n{\n\tstruct vme_bridge *bridge;\n\n\tbridge = vdev->bridge;\n\tif (!bridge) {\n\t\tprintk(KERN_ERR \"Can't find VME bus\\n\");\n\t\treturn;\n\t}\n\n\tif ((level < 1) || (level > 7)) {\n\t\tprintk(KERN_ERR \"Invalid interrupt level\\n\");\n\t\treturn;\n\t}\n\n\tif (!bridge->irq_set) {\n\t\tprintk(KERN_ERR \"Configuring interrupts not supported\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&bridge->irq_mtx);\n\n\tbridge->irq[level - 1].count--;\n\n\t \n\tif (bridge->irq[level - 1].count == 0)\n\t\tbridge->irq_set(bridge, level, 0, 1);\n\n\tbridge->irq[level - 1].callback[statid].func = NULL;\n\tbridge->irq[level - 1].callback[statid].priv_data = NULL;\n\n\tmutex_unlock(&bridge->irq_mtx);\n}\nEXPORT_SYMBOL(vme_irq_free);\n\n \nint vme_irq_generate(struct vme_dev *vdev, int level, int statid)\n{\n\tstruct vme_bridge *bridge;\n\n\tbridge = vdev->bridge;\n\tif (!bridge) {\n\t\tprintk(KERN_ERR \"Can't find VME bus\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((level < 1) || (level > 7)) {\n\t\tprintk(KERN_WARNING \"Invalid interrupt level\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bridge->irq_generate) {\n\t\tprintk(KERN_WARNING \"Interrupt generation not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn bridge->irq_generate(bridge, level, statid);\n}\nEXPORT_SYMBOL(vme_irq_generate);\n\n \nstruct vme_resource *vme_lm_request(struct vme_dev *vdev)\n{\n\tstruct vme_bridge *bridge;\n\tstruct list_head *lm_pos = NULL;\n\tstruct vme_lm_resource *allocated_lm = NULL;\n\tstruct vme_lm_resource *lm = NULL;\n\tstruct vme_resource *resource = NULL;\n\n\tbridge = vdev->bridge;\n\tif (!bridge) {\n\t\tprintk(KERN_ERR \"Can't find VME bus\\n\");\n\t\tgoto err_bus;\n\t}\n\n\t \n\tlist_for_each(lm_pos, &bridge->lm_resources) {\n\t\tlm = list_entry(lm_pos,\n\t\t\t\tstruct vme_lm_resource, list);\n\t\tif (!lm) {\n\t\t\tprintk(KERN_ERR \"Registered NULL Location Monitor resource\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmutex_lock(&lm->mtx);\n\t\tif (lm->locked == 0) {\n\t\t\tlm->locked = 1;\n\t\t\tmutex_unlock(&lm->mtx);\n\t\t\tallocated_lm = lm;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&lm->mtx);\n\t}\n\n\t \n\tif (!allocated_lm)\n\t\tgoto err_lm;\n\n\tresource = kmalloc(sizeof(*resource), GFP_KERNEL);\n\tif (!resource)\n\t\tgoto err_alloc;\n\n\tresource->type = VME_LM;\n\tresource->entry = &allocated_lm->list;\n\n\treturn resource;\n\nerr_alloc:\n\t \n\tmutex_lock(&lm->mtx);\n\tlm->locked = 0;\n\tmutex_unlock(&lm->mtx);\nerr_lm:\nerr_bus:\n\treturn NULL;\n}\nEXPORT_SYMBOL(vme_lm_request);\n\n \nint vme_lm_count(struct vme_resource *resource)\n{\n\tstruct vme_lm_resource *lm;\n\n\tif (resource->type != VME_LM) {\n\t\tprintk(KERN_ERR \"Not a Location Monitor resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlm = list_entry(resource->entry, struct vme_lm_resource, list);\n\n\treturn lm->monitors;\n}\nEXPORT_SYMBOL(vme_lm_count);\n\n \nint vme_lm_set(struct vme_resource *resource, unsigned long long lm_base,\n\t       u32 aspace, u32 cycle)\n{\n\tstruct vme_bridge *bridge = find_bridge(resource);\n\tstruct vme_lm_resource *lm;\n\n\tif (resource->type != VME_LM) {\n\t\tprintk(KERN_ERR \"Not a Location Monitor resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlm = list_entry(resource->entry, struct vme_lm_resource, list);\n\n\tif (!bridge->lm_set) {\n\t\tprintk(KERN_ERR \"vme_lm_set not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn bridge->lm_set(lm, lm_base, aspace, cycle);\n}\nEXPORT_SYMBOL(vme_lm_set);\n\n \nint vme_lm_get(struct vme_resource *resource, unsigned long long *lm_base,\n\t       u32 *aspace, u32 *cycle)\n{\n\tstruct vme_bridge *bridge = find_bridge(resource);\n\tstruct vme_lm_resource *lm;\n\n\tif (resource->type != VME_LM) {\n\t\tprintk(KERN_ERR \"Not a Location Monitor resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlm = list_entry(resource->entry, struct vme_lm_resource, list);\n\n\tif (!bridge->lm_get) {\n\t\tprintk(KERN_ERR \"vme_lm_get not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn bridge->lm_get(lm, lm_base, aspace, cycle);\n}\nEXPORT_SYMBOL(vme_lm_get);\n\n \nint vme_lm_attach(struct vme_resource *resource, int monitor,\n\t\t  void (*callback)(void *), void *data)\n{\n\tstruct vme_bridge *bridge = find_bridge(resource);\n\tstruct vme_lm_resource *lm;\n\n\tif (resource->type != VME_LM) {\n\t\tprintk(KERN_ERR \"Not a Location Monitor resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlm = list_entry(resource->entry, struct vme_lm_resource, list);\n\n\tif (!bridge->lm_attach) {\n\t\tprintk(KERN_ERR \"vme_lm_attach not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn bridge->lm_attach(lm, monitor, callback, data);\n}\nEXPORT_SYMBOL(vme_lm_attach);\n\n \nint vme_lm_detach(struct vme_resource *resource, int monitor)\n{\n\tstruct vme_bridge *bridge = find_bridge(resource);\n\tstruct vme_lm_resource *lm;\n\n\tif (resource->type != VME_LM) {\n\t\tprintk(KERN_ERR \"Not a Location Monitor resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlm = list_entry(resource->entry, struct vme_lm_resource, list);\n\n\tif (!bridge->lm_detach) {\n\t\tprintk(KERN_ERR \"vme_lm_detach not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn bridge->lm_detach(lm, monitor);\n}\nEXPORT_SYMBOL(vme_lm_detach);\n\n \nvoid vme_lm_free(struct vme_resource *resource)\n{\n\tstruct vme_lm_resource *lm;\n\n\tif (resource->type != VME_LM) {\n\t\tprintk(KERN_ERR \"Not a Location Monitor resource\\n\");\n\t\treturn;\n\t}\n\n\tlm = list_entry(resource->entry, struct vme_lm_resource, list);\n\n\tmutex_lock(&lm->mtx);\n\n\t \n\n\tlm->locked = 0;\n\n\tmutex_unlock(&lm->mtx);\n\n\tkfree(resource);\n}\nEXPORT_SYMBOL(vme_lm_free);\n\n \nint vme_slot_num(struct vme_dev *vdev)\n{\n\tstruct vme_bridge *bridge;\n\n\tbridge = vdev->bridge;\n\tif (!bridge) {\n\t\tprintk(KERN_ERR \"Can't find VME bus\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bridge->slot_get) {\n\t\tprintk(KERN_WARNING \"vme_slot_num not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn bridge->slot_get(bridge);\n}\nEXPORT_SYMBOL(vme_slot_num);\n\n \nint vme_bus_num(struct vme_dev *vdev)\n{\n\tstruct vme_bridge *bridge;\n\n\tbridge = vdev->bridge;\n\tif (!bridge) {\n\t\tpr_err(\"Can't find VME bus\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn bridge->num;\n}\nEXPORT_SYMBOL(vme_bus_num);\n\n \n\nstatic void vme_dev_release(struct device *dev)\n{\n\tkfree(dev_to_vme_dev(dev));\n}\n\n \nstruct vme_bridge *vme_init_bridge(struct vme_bridge *bridge)\n{\n\tINIT_LIST_HEAD(&bridge->vme_error_handlers);\n\tINIT_LIST_HEAD(&bridge->master_resources);\n\tINIT_LIST_HEAD(&bridge->slave_resources);\n\tINIT_LIST_HEAD(&bridge->dma_resources);\n\tINIT_LIST_HEAD(&bridge->lm_resources);\n\tmutex_init(&bridge->irq_mtx);\n\n\treturn bridge;\n}\nEXPORT_SYMBOL(vme_init_bridge);\n\nint vme_register_bridge(struct vme_bridge *bridge)\n{\n\tint i;\n\tint ret = -1;\n\n\tmutex_lock(&vme_buses_lock);\n\tfor (i = 0; i < sizeof(vme_bus_numbers) * 8; i++) {\n\t\tif ((vme_bus_numbers & (1 << i)) == 0) {\n\t\t\tvme_bus_numbers |= (1 << i);\n\t\t\tbridge->num = i;\n\t\t\tINIT_LIST_HEAD(&bridge->devices);\n\t\t\tlist_add_tail(&bridge->bus_list, &vme_bus_list);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vme_buses_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(vme_register_bridge);\n\nvoid vme_unregister_bridge(struct vme_bridge *bridge)\n{\n\tstruct vme_dev *vdev;\n\tstruct vme_dev *tmp;\n\n\tmutex_lock(&vme_buses_lock);\n\tvme_bus_numbers &= ~(1 << bridge->num);\n\tlist_for_each_entry_safe(vdev, tmp, &bridge->devices, bridge_list) {\n\t\tlist_del(&vdev->drv_list);\n\t\tlist_del(&vdev->bridge_list);\n\t\tdevice_unregister(&vdev->dev);\n\t}\n\tlist_del(&bridge->bus_list);\n\tmutex_unlock(&vme_buses_lock);\n}\nEXPORT_SYMBOL(vme_unregister_bridge);\n\n \n\nstatic int __vme_register_driver_bus(struct vme_driver *drv,\n\t\t\t\t     struct vme_bridge *bridge,\n\t\t\t\t     unsigned int ndevs)\n{\n\tint err;\n\tunsigned int i;\n\tstruct vme_dev *vdev;\n\tstruct vme_dev *tmp;\n\n\tfor (i = 0; i < ndevs; i++) {\n\t\tvdev = kzalloc(sizeof(*vdev), GFP_KERNEL);\n\t\tif (!vdev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_devalloc;\n\t\t}\n\t\tvdev->num = i;\n\t\tvdev->bridge = bridge;\n\t\tvdev->dev.platform_data = drv;\n\t\tvdev->dev.release = vme_dev_release;\n\t\tvdev->dev.parent = bridge->parent;\n\t\tvdev->dev.bus = &vme_bus_type;\n\t\tdev_set_name(&vdev->dev, \"%s.%u-%u\", drv->name, bridge->num,\n\t\t\t     vdev->num);\n\n\t\terr = device_register(&vdev->dev);\n\t\tif (err)\n\t\t\tgoto err_reg;\n\n\t\tif (vdev->dev.platform_data) {\n\t\t\tlist_add_tail(&vdev->drv_list, &drv->devices);\n\t\t\tlist_add_tail(&vdev->bridge_list, &bridge->devices);\n\t\t} else\n\t\t\tdevice_unregister(&vdev->dev);\n\t}\n\treturn 0;\n\nerr_reg:\n\tput_device(&vdev->dev);\nerr_devalloc:\n\tlist_for_each_entry_safe(vdev, tmp, &drv->devices, drv_list) {\n\t\tlist_del(&vdev->drv_list);\n\t\tlist_del(&vdev->bridge_list);\n\t\tdevice_unregister(&vdev->dev);\n\t}\n\treturn err;\n}\n\nstatic int __vme_register_driver(struct vme_driver *drv, unsigned int ndevs)\n{\n\tstruct vme_bridge *bridge;\n\tint err = 0;\n\n\tmutex_lock(&vme_buses_lock);\n\tlist_for_each_entry(bridge, &vme_bus_list, bus_list) {\n\t\t \n\t\terr = __vme_register_driver_bus(drv, bridge, ndevs);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&vme_buses_lock);\n\treturn err;\n}\n\n \nint vme_register_driver(struct vme_driver *drv, unsigned int ndevs)\n{\n\tint err;\n\n\tdrv->driver.name = drv->name;\n\tdrv->driver.bus = &vme_bus_type;\n\tINIT_LIST_HEAD(&drv->devices);\n\n\terr = driver_register(&drv->driver);\n\tif (err)\n\t\treturn err;\n\n\terr = __vme_register_driver(drv, ndevs);\n\tif (err)\n\t\tdriver_unregister(&drv->driver);\n\n\treturn err;\n}\nEXPORT_SYMBOL(vme_register_driver);\n\n \nvoid vme_unregister_driver(struct vme_driver *drv)\n{\n\tstruct vme_dev *dev, *dev_tmp;\n\n\tmutex_lock(&vme_buses_lock);\n\tlist_for_each_entry_safe(dev, dev_tmp, &drv->devices, drv_list) {\n\t\tlist_del(&dev->drv_list);\n\t\tlist_del(&dev->bridge_list);\n\t\tdevice_unregister(&dev->dev);\n\t}\n\tmutex_unlock(&vme_buses_lock);\n\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL(vme_unregister_driver);\n\n \n\nstatic int vme_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct vme_driver *vme_drv;\n\n\tvme_drv = container_of(drv, struct vme_driver, driver);\n\n\tif (dev->platform_data == vme_drv) {\n\t\tstruct vme_dev *vdev = dev_to_vme_dev(dev);\n\n\t\tif (vme_drv->match && vme_drv->match(vdev))\n\t\t\treturn 1;\n\n\t\tdev->platform_data = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int vme_bus_probe(struct device *dev)\n{\n\tstruct vme_driver *driver;\n\tstruct vme_dev *vdev = dev_to_vme_dev(dev);\n\n\tdriver = dev->platform_data;\n\tif (driver->probe)\n\t\treturn driver->probe(vdev);\n\n\treturn -ENODEV;\n}\n\nstatic void vme_bus_remove(struct device *dev)\n{\n\tstruct vme_driver *driver;\n\tstruct vme_dev *vdev = dev_to_vme_dev(dev);\n\n\tdriver = dev->platform_data;\n\tif (driver->remove)\n\t\tdriver->remove(vdev);\n}\n\nstruct bus_type vme_bus_type = {\n\t.name = \"vme\",\n\t.match = vme_bus_match,\n\t.probe = vme_bus_probe,\n\t.remove = vme_bus_remove,\n};\nEXPORT_SYMBOL(vme_bus_type);\n\nstatic int __init vme_init(void)\n{\n\treturn bus_register(&vme_bus_type);\n}\nsubsys_initcall(vme_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}