{
  "module_name": "vme_user.c",
  "hash_id": "5ee7a428351d4949d2c09096da7204d2e42ddb1fc949f7b4abdd5126f65bf641",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vme_user/vme_user.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/refcount.h>\n#include <linux/cdev.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/pagemap.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/types.h>\n\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#include \"vme.h\"\n#include \"vme_user.h\"\n\nstatic const char driver_name[] = \"vme_user\";\n\nstatic int bus[VME_USER_BUS_MAX];\nstatic unsigned int bus_num;\n\n \n#define VME_MAJOR\t221\t \n#define VME_DEVS\t9\t \n\n#define MASTER_MINOR\t0\n#define MASTER_MAX\t3\n#define SLAVE_MINOR\t4\n#define SLAVE_MAX\t7\n#define CONTROL_MINOR\t8\n\n#define PCI_BUF_SIZE  0x20000\t \n\n \nstruct image_desc {\n\tvoid *kern_buf;\t \n\tdma_addr_t pci_buf;\t \n\tunsigned long long size_buf;\t \n\tstruct mutex mutex;\t \n\tstruct device *device;\t \n\tstruct vme_resource *resource;\t \n\tint mmap_count;\t\t \n};\n\nstatic struct image_desc image[VME_DEVS];\n\nstatic struct cdev *vme_user_cdev;\t\t \nstatic struct class *vme_user_sysfs_class;\t \nstatic struct vme_dev *vme_user_bridge;\t\t \n\nstatic const int type[VME_DEVS] = {\tMASTER_MINOR,\tMASTER_MINOR,\n\t\t\t\t\tMASTER_MINOR,\tMASTER_MINOR,\n\t\t\t\t\tSLAVE_MINOR,\tSLAVE_MINOR,\n\t\t\t\t\tSLAVE_MINOR,\tSLAVE_MINOR,\n\t\t\t\t\tCONTROL_MINOR\n\t\t\t\t};\n\nstruct vme_user_vma_priv {\n\tunsigned int minor;\n\trefcount_t refcnt;\n};\n\nstatic ssize_t resource_to_user(int minor, char __user *buf, size_t count,\n\t\t\t\tloff_t *ppos)\n{\n\tssize_t copied = 0;\n\n\tif (count > image[minor].size_buf)\n\t\tcount = image[minor].size_buf;\n\n\tcopied = vme_master_read(image[minor].resource, image[minor].kern_buf,\n\t\t\t\t count, *ppos);\n\tif (copied < 0)\n\t\treturn (int)copied;\n\n\tif (copy_to_user(buf, image[minor].kern_buf, (unsigned long)copied))\n\t\treturn -EFAULT;\n\n\treturn copied;\n}\n\nstatic ssize_t resource_from_user(unsigned int minor, const char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tif (count > image[minor].size_buf)\n\t\tcount = image[minor].size_buf;\n\n\tif (copy_from_user(image[minor].kern_buf, buf, (unsigned long)count))\n\t\treturn -EFAULT;\n\n\treturn vme_master_write(image[minor].resource, image[minor].kern_buf,\n\t\t\t\tcount, *ppos);\n}\n\nstatic ssize_t buffer_to_user(unsigned int minor, char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tvoid *image_ptr;\n\n\timage_ptr = image[minor].kern_buf + *ppos;\n\tif (copy_to_user(buf, image_ptr, (unsigned long)count))\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\nstatic ssize_t buffer_from_user(unsigned int minor, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tvoid *image_ptr;\n\n\timage_ptr = image[minor].kern_buf + *ppos;\n\tif (copy_from_user(image_ptr, buf, (unsigned long)count))\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\nstatic ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tunsigned int minor = iminor(file_inode(file));\n\tssize_t retval;\n\tsize_t image_size;\n\n\tif (minor == CONTROL_MINOR)\n\t\treturn 0;\n\n\tmutex_lock(&image[minor].mutex);\n\n\t \n\timage_size = vme_get_size(image[minor].resource);\n\n\t \n\tif ((*ppos < 0) || (*ppos > (image_size - 1))) {\n\t\tmutex_unlock(&image[minor].mutex);\n\t\treturn 0;\n\t}\n\n\t \n\tif (*ppos + count > image_size)\n\t\tcount = image_size - *ppos;\n\n\tswitch (type[minor]) {\n\tcase MASTER_MINOR:\n\t\tretval = resource_to_user(minor, buf, count, ppos);\n\t\tbreak;\n\tcase SLAVE_MINOR:\n\t\tretval = buffer_to_user(minor, buf, count, ppos);\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t}\n\n\tmutex_unlock(&image[minor].mutex);\n\tif (retval > 0)\n\t\t*ppos += retval;\n\n\treturn retval;\n}\n\nstatic ssize_t vme_user_write(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tunsigned int minor = iminor(file_inode(file));\n\tssize_t retval;\n\tsize_t image_size;\n\n\tif (minor == CONTROL_MINOR)\n\t\treturn 0;\n\n\tmutex_lock(&image[minor].mutex);\n\n\timage_size = vme_get_size(image[minor].resource);\n\n\t \n\tif ((*ppos < 0) || (*ppos > (image_size - 1))) {\n\t\tmutex_unlock(&image[minor].mutex);\n\t\treturn 0;\n\t}\n\n\t \n\tif (*ppos + count > image_size)\n\t\tcount = image_size - *ppos;\n\n\tswitch (type[minor]) {\n\tcase MASTER_MINOR:\n\t\tretval = resource_from_user(minor, buf, count, ppos);\n\t\tbreak;\n\tcase SLAVE_MINOR:\n\t\tretval = buffer_from_user(minor, buf, count, ppos);\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t}\n\n\tmutex_unlock(&image[minor].mutex);\n\n\tif (retval > 0)\n\t\t*ppos += retval;\n\n\treturn retval;\n}\n\nstatic loff_t vme_user_llseek(struct file *file, loff_t off, int whence)\n{\n\tunsigned int minor = iminor(file_inode(file));\n\tsize_t image_size;\n\tloff_t res;\n\n\tswitch (type[minor]) {\n\tcase MASTER_MINOR:\n\tcase SLAVE_MINOR:\n\t\tmutex_lock(&image[minor].mutex);\n\t\timage_size = vme_get_size(image[minor].resource);\n\t\tres = fixed_size_llseek(file, off, whence, image_size);\n\t\tmutex_unlock(&image[minor].mutex);\n\t\treturn res;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int vme_user_ioctl(struct inode *inode, struct file *file,\n\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\tstruct vme_master master;\n\tstruct vme_slave slave;\n\tstruct vme_irq_id irq_req;\n\tunsigned long copied;\n\tunsigned int minor = iminor(inode);\n\tint retval;\n\tdma_addr_t pci_addr;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (type[minor]) {\n\tcase CONTROL_MINOR:\n\t\tswitch (cmd) {\n\t\tcase VME_IRQ_GEN:\n\t\t\tcopied = copy_from_user(&irq_req, argp,\n\t\t\t\t\t\tsizeof(irq_req));\n\t\t\tif (copied) {\n\t\t\t\tpr_warn(\"Partial copy from userspace\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\t\treturn vme_irq_generate(vme_user_bridge,\n\t\t\t\t\t\t  irq_req.level,\n\t\t\t\t\t\t  irq_req.statid);\n\t\t}\n\t\tbreak;\n\tcase MASTER_MINOR:\n\t\tswitch (cmd) {\n\t\tcase VME_GET_MASTER:\n\t\t\tmemset(&master, 0, sizeof(master));\n\n\t\t\t \n\t\t\tretval = vme_master_get(image[minor].resource,\n\t\t\t\t\t\t&master.enable,\n\t\t\t\t\t\t&master.vme_addr,\n\t\t\t\t\t\t&master.size, &master.aspace,\n\t\t\t\t\t\t&master.cycle, &master.dwidth);\n\n\t\t\tcopied = copy_to_user(argp, &master,\n\t\t\t\t\t      sizeof(master));\n\t\t\tif (copied) {\n\t\t\t\tpr_warn(\"Partial copy to userspace\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\t\treturn retval;\n\n\t\tcase VME_SET_MASTER:\n\n\t\t\tif (image[minor].mmap_count != 0) {\n\t\t\t\tpr_warn(\"Can't adjust mapped window\\n\");\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\n\t\t\tcopied = copy_from_user(&master, argp, sizeof(master));\n\t\t\tif (copied) {\n\t\t\t\tpr_warn(\"Partial copy from userspace\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\t\t \n\t\t\treturn vme_master_set(image[minor].resource,\n\t\t\t\tmaster.enable, master.vme_addr, master.size,\n\t\t\t\tmaster.aspace, master.cycle, master.dwidth);\n\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SLAVE_MINOR:\n\t\tswitch (cmd) {\n\t\tcase VME_GET_SLAVE:\n\t\t\tmemset(&slave, 0, sizeof(slave));\n\n\t\t\t \n\t\t\tretval = vme_slave_get(image[minor].resource,\n\t\t\t\t\t       &slave.enable, &slave.vme_addr,\n\t\t\t\t\t       &slave.size, &pci_addr,\n\t\t\t\t\t       &slave.aspace, &slave.cycle);\n\n\t\t\tcopied = copy_to_user(argp, &slave,\n\t\t\t\t\t      sizeof(slave));\n\t\t\tif (copied) {\n\t\t\t\tpr_warn(\"Partial copy to userspace\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\t\treturn retval;\n\n\t\tcase VME_SET_SLAVE:\n\n\t\t\tcopied = copy_from_user(&slave, argp, sizeof(slave));\n\t\t\tif (copied) {\n\t\t\t\tpr_warn(\"Partial copy from userspace\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\t\t \n\t\t\treturn vme_slave_set(image[minor].resource,\n\t\t\t\tslave.enable, slave.vme_addr, slave.size,\n\t\t\t\timage[minor].pci_buf, slave.aspace,\n\t\t\t\tslave.cycle);\n\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic long\nvme_user_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tunsigned int minor = iminor(inode);\n\n\tmutex_lock(&image[minor].mutex);\n\tret = vme_user_ioctl(inode, file, cmd, arg);\n\tmutex_unlock(&image[minor].mutex);\n\n\treturn ret;\n}\n\nstatic void vme_user_vm_open(struct vm_area_struct *vma)\n{\n\tstruct vme_user_vma_priv *vma_priv = vma->vm_private_data;\n\n\trefcount_inc(&vma_priv->refcnt);\n}\n\nstatic void vme_user_vm_close(struct vm_area_struct *vma)\n{\n\tstruct vme_user_vma_priv *vma_priv = vma->vm_private_data;\n\tunsigned int minor = vma_priv->minor;\n\n\tif (!refcount_dec_and_test(&vma_priv->refcnt))\n\t\treturn;\n\n\tmutex_lock(&image[minor].mutex);\n\timage[minor].mmap_count--;\n\tmutex_unlock(&image[minor].mutex);\n\n\tkfree(vma_priv);\n}\n\nstatic const struct vm_operations_struct vme_user_vm_ops = {\n\t.open = vme_user_vm_open,\n\t.close = vme_user_vm_close,\n};\n\nstatic int vme_user_master_mmap(unsigned int minor, struct vm_area_struct *vma)\n{\n\tint err;\n\tstruct vme_user_vma_priv *vma_priv;\n\n\tmutex_lock(&image[minor].mutex);\n\n\terr = vme_master_mmap(image[minor].resource, vma);\n\tif (err) {\n\t\tmutex_unlock(&image[minor].mutex);\n\t\treturn err;\n\t}\n\n\tvma_priv = kmalloc(sizeof(*vma_priv), GFP_KERNEL);\n\tif (!vma_priv) {\n\t\tmutex_unlock(&image[minor].mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tvma_priv->minor = minor;\n\trefcount_set(&vma_priv->refcnt, 1);\n\tvma->vm_ops = &vme_user_vm_ops;\n\tvma->vm_private_data = vma_priv;\n\n\timage[minor].mmap_count++;\n\n\tmutex_unlock(&image[minor].mutex);\n\n\treturn 0;\n}\n\nstatic int vme_user_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tunsigned int minor = iminor(file_inode(file));\n\n\tif (type[minor] == MASTER_MINOR)\n\t\treturn vme_user_master_mmap(minor, vma);\n\n\treturn -ENODEV;\n}\n\nstatic const struct file_operations vme_user_fops = {\n\t.read = vme_user_read,\n\t.write = vme_user_write,\n\t.llseek = vme_user_llseek,\n\t.unlocked_ioctl = vme_user_unlocked_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.mmap = vme_user_mmap,\n};\n\nstatic int vme_user_match(struct vme_dev *vdev)\n{\n\tint i;\n\n\tint cur_bus = vme_bus_num(vdev);\n\tint cur_slot = vme_slot_num(vdev);\n\n\tfor (i = 0; i < bus_num; i++)\n\t\tif ((cur_bus == bus[i]) && (cur_slot == vdev->num))\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic int vme_user_probe(struct vme_dev *vdev)\n{\n\tint i, err;\n\tchar *name;\n\n\t \n\tif (vme_user_bridge) {\n\t\tdev_err(&vdev->dev, \"Driver can only be loaded for 1 device\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_dev;\n\t}\n\tvme_user_bridge = vdev;\n\n\t \n\tfor (i = 0; i < VME_DEVS; i++) {\n\t\timage[i].kern_buf = NULL;\n\t\timage[i].pci_buf = 0;\n\t\tmutex_init(&image[i].mutex);\n\t\timage[i].device = NULL;\n\t\timage[i].resource = NULL;\n\t}\n\n\t \n\terr = register_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS,\n\t\t\t\t     driver_name);\n\tif (err) {\n\t\tdev_warn(&vdev->dev, \"Error getting Major Number %d for driver.\\n\",\n\t\t\t VME_MAJOR);\n\t\tgoto err_region;\n\t}\n\n\t \n\tvme_user_cdev = cdev_alloc();\n\tif (!vme_user_cdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_char;\n\t}\n\tvme_user_cdev->ops = &vme_user_fops;\n\tvme_user_cdev->owner = THIS_MODULE;\n\terr = cdev_add(vme_user_cdev, MKDEV(VME_MAJOR, 0), VME_DEVS);\n\tif (err)\n\t\tgoto err_class;\n\n\t \n\tfor (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {\n\t\t \n\t\t \n\t\timage[i].resource = vme_slave_request(vme_user_bridge,\n\t\t\t\t\t\t      VME_A24, VME_SCT);\n\t\tif (!image[i].resource) {\n\t\t\tdev_warn(&vdev->dev,\n\t\t\t\t \"Unable to allocate slave resource\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_slave;\n\t\t}\n\t\timage[i].size_buf = PCI_BUF_SIZE;\n\t\timage[i].kern_buf = vme_alloc_consistent(image[i].resource,\n\t\t\t\t\t\t\t image[i].size_buf,\n\t\t\t\t\t\t\t &image[i].pci_buf);\n\t\tif (!image[i].kern_buf) {\n\t\t\tdev_warn(&vdev->dev,\n\t\t\t\t \"Unable to allocate memory for buffer\\n\");\n\t\t\timage[i].pci_buf = 0;\n\t\t\tvme_slave_free(image[i].resource);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_slave;\n\t\t}\n\t}\n\n\t \n\tfor (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {\n\t\t \n\t\timage[i].resource = vme_master_request(vme_user_bridge,\n\t\t\t\t\t\t       VME_A32, VME_SCT,\n\t\t\t\t\t\t       VME_D32);\n\t\tif (!image[i].resource) {\n\t\t\tdev_warn(&vdev->dev,\n\t\t\t\t \"Unable to allocate master resource\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_master;\n\t\t}\n\t\timage[i].size_buf = PCI_BUF_SIZE;\n\t\timage[i].kern_buf = kmalloc(image[i].size_buf, GFP_KERNEL);\n\t\tif (!image[i].kern_buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tvme_master_free(image[i].resource);\n\t\t\tgoto err_master;\n\t\t}\n\t}\n\n\t \n\tvme_user_sysfs_class = class_create(driver_name);\n\tif (IS_ERR(vme_user_sysfs_class)) {\n\t\tdev_err(&vdev->dev, \"Error creating vme_user class.\\n\");\n\t\terr = PTR_ERR(vme_user_sysfs_class);\n\t\tgoto err_master;\n\t}\n\n\t \n\tfor (i = 0; i < VME_DEVS; i++) {\n\t\tint num;\n\n\t\tswitch (type[i]) {\n\t\tcase MASTER_MINOR:\n\t\t\tname = \"bus/vme/m%d\";\n\t\t\tbreak;\n\t\tcase CONTROL_MINOR:\n\t\t\tname = \"bus/vme/ctl\";\n\t\t\tbreak;\n\t\tcase SLAVE_MINOR:\n\t\t\tname = \"bus/vme/s%d\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_sysfs;\n\t\t}\n\n\t\tnum = (type[i] == SLAVE_MINOR) ? i - (MASTER_MAX + 1) : i;\n\t\timage[i].device = device_create(vme_user_sysfs_class, NULL,\n\t\t\t\t\t\tMKDEV(VME_MAJOR, i), NULL,\n\t\t\t\t\t\tname, num);\n\t\tif (IS_ERR(image[i].device)) {\n\t\t\tdev_info(&vdev->dev, \"Error creating sysfs device\\n\");\n\t\t\terr = PTR_ERR(image[i].device);\n\t\t\tgoto err_sysfs;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_sysfs:\n\twhile (i > 0) {\n\t\ti--;\n\t\tdevice_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));\n\t}\n\tclass_destroy(vme_user_sysfs_class);\n\n\t \n\ti = MASTER_MAX + 1;\nerr_master:\n\twhile (i > MASTER_MINOR) {\n\t\ti--;\n\t\tkfree(image[i].kern_buf);\n\t\tvme_master_free(image[i].resource);\n\t}\n\n\t \n\ti = SLAVE_MAX + 1;\nerr_slave:\n\twhile (i > SLAVE_MINOR) {\n\t\ti--;\n\t\tvme_free_consistent(image[i].resource, image[i].size_buf,\n\t\t\t\t    image[i].kern_buf, image[i].pci_buf);\n\t\tvme_slave_free(image[i].resource);\n\t}\nerr_class:\n\tcdev_del(vme_user_cdev);\nerr_char:\n\tunregister_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS);\nerr_region:\nerr_dev:\n\treturn err;\n}\n\nstatic void vme_user_remove(struct vme_dev *dev)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < VME_DEVS; i++) {\n\t\tmutex_destroy(&image[i].mutex);\n\t\tdevice_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));\n\t}\n\tclass_destroy(vme_user_sysfs_class);\n\n\tfor (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {\n\t\tkfree(image[i].kern_buf);\n\t\tvme_master_free(image[i].resource);\n\t}\n\n\tfor (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {\n\t\tvme_slave_set(image[i].resource, 0, 0, 0, 0, VME_A32, 0);\n\t\tvme_free_consistent(image[i].resource, image[i].size_buf,\n\t\t\t\t    image[i].kern_buf, image[i].pci_buf);\n\t\tvme_slave_free(image[i].resource);\n\t}\n\n\t \n\tcdev_del(vme_user_cdev);\n\n\t \n\tunregister_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS);\n}\n\nstatic struct vme_driver vme_user_driver = {\n\t.name = driver_name,\n\t.match = vme_user_match,\n\t.probe = vme_user_probe,\n\t.remove = vme_user_remove,\n};\n\nstatic int __init vme_user_init(void)\n{\n\tint retval = 0;\n\n\tpr_info(\"VME User Space Access Driver\\n\");\n\n\tif (bus_num == 0) {\n\t\tpr_err(\"No cards, skipping registration\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_nocard;\n\t}\n\n\t \n\tif (bus_num > VME_USER_BUS_MAX) {\n\t\tpr_err(\"Driver only able to handle %d buses\\n\",\n\t\t       VME_USER_BUS_MAX);\n\t\tbus_num = VME_USER_BUS_MAX;\n\t}\n\n\t \n\tretval = vme_register_driver(&vme_user_driver, VME_MAX_SLOTS);\n\tif (retval)\n\t\tgoto err_reg;\n\n\treturn retval;\n\nerr_reg:\nerr_nocard:\n\treturn retval;\n}\n\nstatic void __exit vme_user_exit(void)\n{\n\tvme_unregister_driver(&vme_user_driver);\n}\n\nMODULE_PARM_DESC(bus, \"Enumeration of VMEbus to which the driver is connected\");\nmodule_param_array(bus, int, &bus_num, 0000);\n\nMODULE_DESCRIPTION(\"VME User Space Access Driver\");\nMODULE_AUTHOR(\"Martyn Welch <martyn.welch@ge.com>\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(vme_user_init);\nmodule_exit(vme_user_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}