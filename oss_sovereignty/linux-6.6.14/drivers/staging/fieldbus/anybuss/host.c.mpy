{
  "module_name": "host.c",
  "hash_id": "5ba919c1bed39dbc2cd6d87e26c44c49a3aaa63abe9f484aed853391afc63ca7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fieldbus/anybuss/host.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/kfifo.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/regmap.h>\n#include <linux/of.h>\n#include <linux/random.h>\n#include <linux/kref.h>\n#include <linux/of_address.h>\n\n \n#include \"anybuss-client.h\"\n#include \"anybuss-controller.h\"\n\n#define DPRAM_SIZE\t\t0x800\n#define MAX_MBOX_MSG_SZ\t\t0x0FF\n#define TIMEOUT\t\t\t(HZ * 2)\n#define MAX_DATA_AREA_SZ\t0x200\n#define MAX_FBCTRL_AREA_SZ\t0x1BE\n\n#define REG_BOOTLOADER_V\t0x7C0\n#define REG_API_V\t\t0x7C2\n#define REG_FIELDBUS_V\t\t0x7C4\n#define REG_SERIAL_NO\t\t0x7C6\n#define REG_FIELDBUS_TYPE\t0x7CC\n#define REG_MODULE_SW_V\t\t0x7CE\n#define REG_IND_AB\t\t0x7FF\n#define REG_IND_AP\t\t0x7FE\n#define REG_EVENT_CAUSE\t\t0x7ED\n#define MBOX_IN_AREA\t\t0x400\n#define MBOX_OUT_AREA\t\t0x520\n#define DATA_IN_AREA\t\t0x000\n#define DATA_OUT_AREA\t\t0x200\n#define FBCTRL_AREA\t\t0x640\n\n#define EVENT_CAUSE_DC          0x01\n#define EVENT_CAUSE_FBOF        0x02\n#define EVENT_CAUSE_FBON        0x04\n\n#define IND_AB_UPDATED\t\t0x08\n#define IND_AX_MIN\t\t0x80\n#define IND_AX_MOUT\t\t0x40\n#define IND_AX_IN\t\t0x04\n#define IND_AX_OUT\t\t0x02\n#define IND_AX_FBCTRL\t\t0x01\n#define IND_AP_LOCK\t\t0x08\n#define IND_AP_ACTION\t\t0x10\n#define IND_AX_EVNT\t\t0x20\n#define IND_AP_ABITS\t\t(IND_AX_IN | IND_AX_OUT | \\\n\t\t\t\t\tIND_AX_FBCTRL | \\\n\t\t\t\t\tIND_AP_ACTION | IND_AP_LOCK)\n\n#define INFO_TYPE_FB\t\t0x0002\n#define INFO_TYPE_APP\t\t0x0001\n#define INFO_COMMAND\t\t0x4000\n\n#define OP_MODE_FBFC\t\t0x0002\n#define OP_MODE_FBS\t\t0x0004\n#define OP_MODE_CD\t\t0x0200\n\n#define CMD_START_INIT\t\t0x0001\n#define CMD_ANYBUS_INIT\t\t0x0002\n#define CMD_END_INIT\t\t0x0003\n\n \n\nstruct anybus_mbox_hdr {\n\t__be16 id;\n\t__be16 info;\n\t__be16 cmd_num;\n\t__be16 data_size;\n\t__be16 frame_count;\n\t__be16 frame_num;\n\t__be16 offset_high;\n\t__be16 offset_low;\n\t__be16 extended[8];\n};\n\nstruct msg_anybus_init {\n\t__be16 input_io_len;\n\t__be16 input_dpram_len;\n\t__be16 input_total_len;\n\t__be16 output_io_len;\n\t__be16 output_dpram_len;\n\t__be16 output_total_len;\n\t__be16 op_mode;\n\t__be16 notif_config;\n\t__be16 wd_val;\n};\n\n \n\nstruct ab_task;\ntypedef int (*ab_task_fn_t)(struct anybuss_host *cd,\n\t\t\t\t\tstruct ab_task *t);\ntypedef void (*ab_done_fn_t)(struct anybuss_host *cd);\n\nstruct area_priv {\n\tbool is_write;\n\tu16 flags;\n\tu16 addr;\n\tsize_t count;\n\tu8 buf[MAX_DATA_AREA_SZ];\n};\n\nstruct mbox_priv {\n\tstruct anybus_mbox_hdr hdr;\n\tsize_t msg_out_sz;\n\tsize_t msg_in_sz;\n\tu8 msg[MAX_MBOX_MSG_SZ];\n};\n\nstruct ab_task {\n\tstruct kmem_cache\t*cache;\n\tstruct kref\t\trefcount;\n\tab_task_fn_t\t\ttask_fn;\n\tab_done_fn_t\t\tdone_fn;\n\tint\t\t\tresult;\n\tstruct completion\tdone;\n\tunsigned long\t\tstart_jiffies;\n\tunion {\n\t\tstruct area_priv area_pd;\n\t\tstruct mbox_priv mbox_pd;\n\t};\n};\n\nstatic struct ab_task *ab_task_create_get(struct kmem_cache *cache,\n\t\t\t\t\t  ab_task_fn_t task_fn)\n{\n\tstruct ab_task *t;\n\n\tt = kmem_cache_alloc(cache, GFP_KERNEL);\n\tif (!t)\n\t\treturn NULL;\n\tt->cache = cache;\n\tkref_init(&t->refcount);\n\tt->task_fn = task_fn;\n\tt->done_fn = NULL;\n\tt->result = 0;\n\tinit_completion(&t->done);\n\treturn t;\n}\n\nstatic void __ab_task_destroy(struct kref *refcount)\n{\n\tstruct ab_task *t = container_of(refcount, struct ab_task, refcount);\n\tstruct kmem_cache *cache = t->cache;\n\n\tkmem_cache_free(cache, t);\n}\n\nstatic void ab_task_put(struct ab_task *t)\n{\n\tkref_put(&t->refcount, __ab_task_destroy);\n}\n\nstatic struct ab_task *__ab_task_get(struct ab_task *t)\n{\n\tkref_get(&t->refcount);\n\treturn t;\n}\n\nstatic void __ab_task_finish(struct ab_task *t, struct anybuss_host *cd)\n{\n\tif (t->done_fn)\n\t\tt->done_fn(cd);\n\tcomplete(&t->done);\n}\n\nstatic void\nab_task_dequeue_finish_put(struct kfifo *q, struct anybuss_host *cd)\n{\n\tint ret;\n\tstruct ab_task *t;\n\n\tret = kfifo_out(q, &t, sizeof(t));\n\tWARN_ON(!ret);\n\t__ab_task_finish(t, cd);\n\tab_task_put(t);\n}\n\nstatic int\nab_task_enqueue(struct ab_task *t, struct kfifo *q, spinlock_t *slock,\n\t\twait_queue_head_t *wq)\n{\n\tint ret;\n\n\tt->start_jiffies = jiffies;\n\t__ab_task_get(t);\n\tret = kfifo_in_spinlocked(q, &t, sizeof(t), slock);\n\tif (!ret) {\n\t\tab_task_put(t);\n\t\treturn -ENOMEM;\n\t}\n\twake_up(wq);\n\treturn 0;\n}\n\nstatic int\nab_task_enqueue_wait(struct ab_task *t, struct kfifo *q, spinlock_t *slock,\n\t\t     wait_queue_head_t *wq)\n{\n\tint ret;\n\n\tret = ab_task_enqueue(t, q, slock, wq);\n\tif (ret)\n\t\treturn ret;\n\tret = wait_for_completion_interruptible(&t->done);\n\tif (ret)\n\t\treturn ret;\n\treturn t->result;\n}\n\n \n\nstruct anybuss_host {\n\tstruct device *dev;\n\tstruct anybuss_client *client;\n\tvoid (*reset)(struct device *dev, bool assert);\n\tstruct regmap *regmap;\n\tint irq;\n\tint host_idx;\n\tstruct task_struct *qthread;\n\twait_queue_head_t wq;\n\tstruct completion card_boot;\n\tatomic_t ind_ab;\n\tspinlock_t qlock;  \n\tstruct kmem_cache *qcache;\n\tstruct kfifo qs[3];\n\tstruct kfifo *powerq;\n\tstruct kfifo *mboxq;\n\tstruct kfifo *areaq;\n\tbool power_on;\n\tbool softint_pending;\n};\n\nstatic void reset_assert(struct anybuss_host *cd)\n{\n\tcd->reset(cd->dev, true);\n}\n\nstatic void reset_deassert(struct anybuss_host *cd)\n{\n\tcd->reset(cd->dev, false);\n}\n\nstatic int test_dpram(struct regmap *regmap)\n{\n\tint i;\n\tunsigned int val;\n\n\tfor (i = 0; i < DPRAM_SIZE; i++)\n\t\tregmap_write(regmap, i, (u8)i);\n\tfor (i = 0; i < DPRAM_SIZE; i++) {\n\t\tregmap_read(regmap, i, &val);\n\t\tif ((u8)val != (u8)i)\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int read_ind_ab(struct regmap *regmap)\n{\n\tunsigned long timeout = jiffies + HZ / 2;\n\tunsigned int a, b, i = 0;\n\n\twhile (time_before_eq(jiffies, timeout)) {\n\t\tregmap_read(regmap, REG_IND_AB, &a);\n\t\tregmap_read(regmap, REG_IND_AB, &b);\n\t\tif (likely(a == b))\n\t\t\treturn (int)a;\n\t\tif (i < 10) {\n\t\t\tcpu_relax();\n\t\t\ti++;\n\t\t} else {\n\t\t\tusleep_range(500, 1000);\n\t\t}\n\t}\n\tWARN(1, \"IND_AB register not stable\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int write_ind_ap(struct regmap *regmap, unsigned int ind_ap)\n{\n\tunsigned long timeout = jiffies + HZ / 2;\n\tunsigned int v, i = 0;\n\n\twhile (time_before_eq(jiffies, timeout)) {\n\t\tregmap_write(regmap, REG_IND_AP, ind_ap);\n\t\tregmap_read(regmap, REG_IND_AP, &v);\n\t\tif (likely(ind_ap == v))\n\t\t\treturn 0;\n\t\tif (i < 10) {\n\t\t\tcpu_relax();\n\t\t\ti++;\n\t\t} else {\n\t\t\tusleep_range(500, 1000);\n\t\t}\n\t}\n\tWARN(1, \"IND_AP register not stable\");\n\treturn -ETIMEDOUT;\n}\n\nstatic irqreturn_t irq_handler(int irq, void *data)\n{\n\tstruct anybuss_host *cd = data;\n\tint ind_ab;\n\n\t \n\tind_ab = read_ind_ab(cd->regmap);\n\tif (ind_ab < 0)\n\t\treturn IRQ_NONE;\n\tatomic_set(&cd->ind_ab, ind_ab);\n\tcomplete(&cd->card_boot);\n\twake_up(&cd->wq);\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int task_fn_power_off(struct anybuss_host *cd,\n\t\t\t     struct ab_task *t)\n{\n\tstruct anybuss_client *client = cd->client;\n\n\tif (!cd->power_on)\n\t\treturn 0;\n\tdisable_irq(cd->irq);\n\treset_assert(cd);\n\tatomic_set(&cd->ind_ab, IND_AB_UPDATED);\n\tif (client->on_online_changed)\n\t\tclient->on_online_changed(client, false);\n\tcd->power_on = false;\n\treturn 0;\n}\n\nstatic int task_fn_power_on_2(struct anybuss_host *cd,\n\t\t\t      struct ab_task *t)\n{\n\tif (completion_done(&cd->card_boot)) {\n\t\tcd->power_on = true;\n\t\treturn 0;\n\t}\n\tif (time_after(jiffies, t->start_jiffies + TIMEOUT)) {\n\t\tdisable_irq(cd->irq);\n\t\treset_assert(cd);\n\t\tdev_err(cd->dev, \"power on timed out\");\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn -EINPROGRESS;\n}\n\nstatic int task_fn_power_on(struct anybuss_host *cd,\n\t\t\t    struct ab_task *t)\n{\n\tunsigned int dummy;\n\n\tif (cd->power_on)\n\t\treturn 0;\n\t \n\tregmap_read(cd->regmap, REG_IND_AB, &dummy);\n\treinit_completion(&cd->card_boot);\n\tenable_irq(cd->irq);\n\treset_deassert(cd);\n\tt->task_fn = task_fn_power_on_2;\n\treturn -EINPROGRESS;\n}\n\nint anybuss_set_power(struct anybuss_client *client, bool power_on)\n{\n\tstruct anybuss_host *cd = client->host;\n\tstruct ab_task *t;\n\tint err;\n\n\tt = ab_task_create_get(cd->qcache, power_on ?\n\t\t\t\ttask_fn_power_on : task_fn_power_off);\n\tif (!t)\n\t\treturn -ENOMEM;\n\terr = ab_task_enqueue_wait(t, cd->powerq, &cd->qlock, &cd->wq);\n\tab_task_put(t);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(anybuss_set_power);\n\n \n\nstatic int task_fn_area_3(struct anybuss_host *cd, struct ab_task *t)\n{\n\tstruct area_priv *pd = &t->area_pd;\n\n\tif (!cd->power_on)\n\t\treturn -EIO;\n\tif (atomic_read(&cd->ind_ab) & pd->flags) {\n\t\t \n\t\tif (time_after(jiffies, t->start_jiffies + TIMEOUT))\n\t\t\treturn -ETIMEDOUT;\n\t\treturn -EINPROGRESS;\n\t}\n\treturn 0;\n}\n\nstatic int task_fn_area_2(struct anybuss_host *cd, struct ab_task *t)\n{\n\tstruct area_priv *pd = &t->area_pd;\n\tunsigned int ind_ap;\n\tint ret;\n\n\tif (!cd->power_on)\n\t\treturn -EIO;\n\tregmap_read(cd->regmap, REG_IND_AP, &ind_ap);\n\tif (!(atomic_read(&cd->ind_ab) & pd->flags)) {\n\t\t \n\t\tif (time_after(jiffies, t->start_jiffies + TIMEOUT)) {\n\t\t\tdev_warn(cd->dev, \"timeout waiting for area\");\n\t\t\tdump_stack();\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\treturn -EINPROGRESS;\n\t}\n\t \n\tif (pd->is_write)\n\t\tregmap_bulk_write(cd->regmap, pd->addr, pd->buf,\n\t\t\t\t  pd->count);\n\telse\n\t\tregmap_bulk_read(cd->regmap, pd->addr, pd->buf,\n\t\t\t\t pd->count);\n\t \n\tind_ap &= ~IND_AP_ABITS;\n\tind_ap |= pd->flags;\n\tret = write_ind_ap(cd->regmap, ind_ap);\n\tif (ret)\n\t\treturn ret;\n\tt->task_fn = task_fn_area_3;\n\treturn -EINPROGRESS;\n}\n\nstatic int task_fn_area(struct anybuss_host *cd, struct ab_task *t)\n{\n\tstruct area_priv *pd = &t->area_pd;\n\tunsigned int ind_ap;\n\tint ret;\n\n\tif (!cd->power_on)\n\t\treturn -EIO;\n\tregmap_read(cd->regmap, REG_IND_AP, &ind_ap);\n\t \n\tind_ap &= ~IND_AP_ABITS;\n\tind_ap |= pd->flags | IND_AP_ACTION | IND_AP_LOCK;\n\tret = write_ind_ap(cd->regmap, ind_ap);\n\tif (ret)\n\t\treturn ret;\n\tt->task_fn = task_fn_area_2;\n\treturn -EINPROGRESS;\n}\n\nstatic struct ab_task *\ncreate_area_reader(struct kmem_cache *qcache, u16 flags, u16 addr,\n\t\t   size_t count)\n{\n\tstruct ab_task *t;\n\tstruct area_priv *ap;\n\n\tt = ab_task_create_get(qcache, task_fn_area);\n\tif (!t)\n\t\treturn NULL;\n\tap = &t->area_pd;\n\tap->flags = flags;\n\tap->addr = addr;\n\tap->is_write = false;\n\tap->count = count;\n\treturn t;\n}\n\nstatic struct ab_task *\ncreate_area_writer(struct kmem_cache *qcache, u16 flags, u16 addr,\n\t\t   const void *buf, size_t count)\n{\n\tstruct ab_task *t;\n\tstruct area_priv *ap;\n\n\tt = ab_task_create_get(qcache, task_fn_area);\n\tif (!t)\n\t\treturn NULL;\n\tap = &t->area_pd;\n\tap->flags = flags;\n\tap->addr = addr;\n\tap->is_write = true;\n\tap->count = count;\n\tmemcpy(ap->buf, buf, count);\n\treturn t;\n}\n\nstatic struct ab_task *\ncreate_area_user_writer(struct kmem_cache *qcache, u16 flags, u16 addr,\n\t\t\tconst void __user *buf, size_t count)\n{\n\tstruct ab_task *t;\n\tstruct area_priv *ap;\n\n\tt = ab_task_create_get(qcache, task_fn_area);\n\tif (!t)\n\t\treturn ERR_PTR(-ENOMEM);\n\tap = &t->area_pd;\n\tap->flags = flags;\n\tap->addr = addr;\n\tap->is_write = true;\n\tap->count = count;\n\tif (copy_from_user(ap->buf, buf, count)) {\n\t\tab_task_put(t);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\treturn t;\n}\n\nstatic bool area_range_ok(u16 addr, size_t count, u16 area_start,\n\t\t\t  size_t area_sz)\n{\n\tu16 area_end_ex = area_start + area_sz;\n\tu16 addr_end_ex;\n\n\tif (addr < area_start)\n\t\treturn false;\n\tif (addr >= area_end_ex)\n\t\treturn false;\n\taddr_end_ex = addr + count;\n\tif (addr_end_ex > area_end_ex)\n\t\treturn false;\n\treturn true;\n}\n\n \n\nstatic int task_fn_mbox_2(struct anybuss_host *cd, struct ab_task *t)\n{\n\tstruct mbox_priv *pd = &t->mbox_pd;\n\tunsigned int ind_ap;\n\n\tif (!cd->power_on)\n\t\treturn -EIO;\n\tregmap_read(cd->regmap, REG_IND_AP, &ind_ap);\n\tif (((atomic_read(&cd->ind_ab) ^ ind_ap) & IND_AX_MOUT) == 0) {\n\t\t \n\t\tif (time_after(jiffies, t->start_jiffies + TIMEOUT))\n\t\t\treturn -ETIMEDOUT;\n\t\treturn -EINPROGRESS;\n\t}\n\t \n\tregmap_bulk_read(cd->regmap, MBOX_OUT_AREA, &pd->hdr,\n\t\t\t sizeof(pd->hdr));\n\tregmap_bulk_read(cd->regmap, MBOX_OUT_AREA + sizeof(pd->hdr),\n\t\t\t pd->msg, pd->msg_in_sz);\n\t \n\tind_ap ^= IND_AX_MOUT;\n\treturn write_ind_ap(cd->regmap, ind_ap);\n}\n\nstatic int task_fn_mbox(struct anybuss_host *cd, struct ab_task *t)\n{\n\tstruct mbox_priv *pd = &t->mbox_pd;\n\tunsigned int ind_ap;\n\tint ret;\n\n\tif (!cd->power_on)\n\t\treturn -EIO;\n\tregmap_read(cd->regmap, REG_IND_AP, &ind_ap);\n\tif ((atomic_read(&cd->ind_ab) ^ ind_ap) & IND_AX_MIN) {\n\t\t \n\t\tif (time_after(jiffies, t->start_jiffies + TIMEOUT))\n\t\t\treturn -ETIMEDOUT;\n\t\treturn -EINPROGRESS;\n\t}\n\t \n\tregmap_bulk_write(cd->regmap, MBOX_IN_AREA, &pd->hdr,\n\t\t\t  sizeof(pd->hdr));\n\tregmap_bulk_write(cd->regmap, MBOX_IN_AREA + sizeof(pd->hdr),\n\t\t\t  pd->msg, pd->msg_out_sz);\n\t \n\tind_ap ^= IND_AX_MIN;\n\tret = write_ind_ap(cd->regmap, ind_ap);\n\tif (ret)\n\t\treturn ret;\n\tt->start_jiffies = jiffies;\n\tt->task_fn = task_fn_mbox_2;\n\treturn -EINPROGRESS;\n}\n\nstatic void log_invalid_other(struct device *dev,\n\t\t\t      struct anybus_mbox_hdr *hdr)\n{\n\tsize_t ext_offs = ARRAY_SIZE(hdr->extended) - 1;\n\tu16 code = be16_to_cpu(hdr->extended[ext_offs]);\n\n\tdev_err(dev, \"   Invalid other: [0x%02X]\", code);\n}\n\nstatic const char * const EMSGS[] = {\n\t\"Invalid Message ID\",\n\t\"Invalid Message Type\",\n\t\"Invalid Command\",\n\t\"Invalid Data Size\",\n\t\"Message Header Malformed (offset 008h)\",\n\t\"Message Header Malformed (offset 00Ah)\",\n\t\"Message Header Malformed (offset 00Ch - 00Dh)\",\n\t\"Invalid Address\",\n\t\"Invalid Response\",\n\t\"Flash Config Error\",\n};\n\nstatic int mbox_cmd_err(struct device *dev, struct mbox_priv *mpriv)\n{\n\tint i;\n\tu8 ecode;\n\tstruct anybus_mbox_hdr *hdr = &mpriv->hdr;\n\tu16 info = be16_to_cpu(hdr->info);\n\tu8 *phdr = (u8 *)hdr;\n\tu8 *pmsg = mpriv->msg;\n\n\tif (!(info & 0x8000))\n\t\treturn 0;\n\tecode = (info >> 8) & 0x0F;\n\tdev_err(dev, \"mailbox command failed:\");\n\tif (ecode == 0x0F)\n\t\tlog_invalid_other(dev, hdr);\n\telse if (ecode < ARRAY_SIZE(EMSGS))\n\t\tdev_err(dev, \"   Error code: %s (0x%02X)\",\n\t\t\tEMSGS[ecode], ecode);\n\telse\n\t\tdev_err(dev, \"   Error code: 0x%02X\\n\", ecode);\n\tdev_err(dev, \"Failed command:\");\n\tdev_err(dev, \"Message Header:\");\n\tfor (i = 0; i < sizeof(mpriv->hdr); i += 2)\n\t\tdev_err(dev, \"%02X%02X\", phdr[i], phdr[i + 1]);\n\tdev_err(dev, \"Message Data:\");\n\tfor (i = 0; i < mpriv->msg_in_sz; i += 2)\n\t\tdev_err(dev, \"%02X%02X\", pmsg[i], pmsg[i + 1]);\n\tdev_err(dev, \"Stack dump:\");\n\tdump_stack();\n\treturn -EIO;\n}\n\nstatic int _anybus_mbox_cmd(struct anybuss_host *cd,\n\t\t\t    u16 cmd_num, bool is_fb_cmd,\n\t\t\t\tconst void *msg_out, size_t msg_out_sz,\n\t\t\t\tvoid *msg_in, size_t msg_in_sz,\n\t\t\t\tconst void *ext, size_t ext_sz)\n{\n\tstruct ab_task *t;\n\tstruct mbox_priv *pd;\n\tstruct anybus_mbox_hdr *h;\n\tsize_t msg_sz = max(msg_in_sz, msg_out_sz);\n\tu16 info;\n\tint err;\n\n\tif (msg_sz > MAX_MBOX_MSG_SZ)\n\t\treturn -EINVAL;\n\tif (ext && ext_sz > sizeof(h->extended))\n\t\treturn -EINVAL;\n\tt = ab_task_create_get(cd->qcache, task_fn_mbox);\n\tif (!t)\n\t\treturn -ENOMEM;\n\tpd = &t->mbox_pd;\n\th = &pd->hdr;\n\tinfo = is_fb_cmd ? INFO_TYPE_FB : INFO_TYPE_APP;\n\t \n\tmemset(h, 0, sizeof(*h));\n\th->info = cpu_to_be16(info | INFO_COMMAND);\n\th->cmd_num = cpu_to_be16(cmd_num);\n\th->data_size = cpu_to_be16(msg_out_sz);\n\th->frame_count = cpu_to_be16(1);\n\th->frame_num = cpu_to_be16(1);\n\th->offset_high = cpu_to_be16(0);\n\th->offset_low = cpu_to_be16(0);\n\tif (ext)\n\t\tmemcpy(h->extended, ext, ext_sz);\n\tmemcpy(pd->msg, msg_out, msg_out_sz);\n\tpd->msg_out_sz = msg_out_sz;\n\tpd->msg_in_sz = msg_in_sz;\n\terr = ab_task_enqueue_wait(t, cd->powerq, &cd->qlock, &cd->wq);\n\tif (err)\n\t\tgoto out;\n\t \n\terr = mbox_cmd_err(cd->dev, pd);\n\tif (err)\n\t\tgoto out;\n\tmemcpy(msg_in, pd->msg, msg_in_sz);\nout:\n\tab_task_put(t);\n\treturn err;\n}\n\n \n\nstatic void process_q(struct anybuss_host *cd, struct kfifo *q)\n{\n\tstruct ab_task *t;\n\tint ret;\n\n\tret = kfifo_out_peek(q, &t, sizeof(t));\n\tif (!ret)\n\t\treturn;\n\tt->result = t->task_fn(cd, t);\n\tif (t->result != -EINPROGRESS)\n\t\tab_task_dequeue_finish_put(q, cd);\n}\n\nstatic bool qs_have_work(struct kfifo *qs, size_t num)\n{\n\tsize_t i;\n\tstruct ab_task *t;\n\tint ret;\n\n\tfor (i = 0; i < num; i++, qs++) {\n\t\tret = kfifo_out_peek(qs, &t, sizeof(t));\n\t\tif (ret && (t->result != -EINPROGRESS))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void process_qs(struct anybuss_host *cd)\n{\n\tsize_t i;\n\tstruct kfifo *qs = cd->qs;\n\tsize_t nqs = ARRAY_SIZE(cd->qs);\n\n\tfor (i = 0; i < nqs; i++, qs++)\n\t\tprocess_q(cd, qs);\n}\n\nstatic void softint_ack(struct anybuss_host *cd)\n{\n\tunsigned int ind_ap;\n\n\tcd->softint_pending = false;\n\tif (!cd->power_on)\n\t\treturn;\n\tregmap_read(cd->regmap, REG_IND_AP, &ind_ap);\n\tind_ap &= ~IND_AX_EVNT;\n\tind_ap |= atomic_read(&cd->ind_ab) & IND_AX_EVNT;\n\twrite_ind_ap(cd->regmap, ind_ap);\n}\n\nstatic void process_softint(struct anybuss_host *cd)\n{\n\tstruct anybuss_client *client = cd->client;\n\tstatic const u8 zero;\n\tint ret;\n\tunsigned int ind_ap, ev;\n\tstruct ab_task *t;\n\n\tif (!cd->power_on)\n\t\treturn;\n\tif (cd->softint_pending)\n\t\treturn;\n\tregmap_read(cd->regmap, REG_IND_AP, &ind_ap);\n\tif (!((atomic_read(&cd->ind_ab) ^ ind_ap) & IND_AX_EVNT))\n\t\treturn;\n\t \n\tregmap_read(cd->regmap, REG_EVENT_CAUSE, &ev);\n\tif (ev & EVENT_CAUSE_FBON) {\n\t\tif (client->on_online_changed)\n\t\t\tclient->on_online_changed(client, true);\n\t\tdev_dbg(cd->dev, \"Fieldbus ON\");\n\t}\n\tif (ev & EVENT_CAUSE_FBOF) {\n\t\tif (client->on_online_changed)\n\t\t\tclient->on_online_changed(client, false);\n\t\tdev_dbg(cd->dev, \"Fieldbus OFF\");\n\t}\n\tif (ev & EVENT_CAUSE_DC) {\n\t\tif (client->on_area_updated)\n\t\t\tclient->on_area_updated(client);\n\t\tdev_dbg(cd->dev, \"Fieldbus data changed\");\n\t}\n\t \n\tt = create_area_writer(cd->qcache, IND_AX_FBCTRL,\n\t\t\t       REG_EVENT_CAUSE, &zero, sizeof(zero));\n\tif (!t) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tt->done_fn = softint_ack;\n\tret = ab_task_enqueue(t, cd->powerq, &cd->qlock, &cd->wq);\n\tab_task_put(t);\n\tcd->softint_pending = true;\nout:\n\tWARN_ON(ret);\n\tif (ret)\n\t\tsoftint_ack(cd);\n}\n\nstatic int qthread_fn(void *data)\n{\n\tstruct anybuss_host *cd = data;\n\tstruct kfifo *qs = cd->qs;\n\tsize_t nqs = ARRAY_SIZE(cd->qs);\n\tunsigned int ind_ab;\n\n\t \n\n\twhile (!kthread_should_stop()) {\n\t\t \n\t\tind_ab = atomic_read(&cd->ind_ab);\n\t\tprocess_qs(cd);\n\t\tprocess_softint(cd);\n\t\twait_event_timeout(cd->wq,\n\t\t\t\t   (atomic_read(&cd->ind_ab) != ind_ab) ||\n\t\t\t\tqs_have_work(qs, nqs) ||\n\t\t\t\tkthread_should_stop(),\n\t\t\tHZ);\n\t\t \n\t}\n\n\treturn 0;\n}\n\n \n\nint anybuss_start_init(struct anybuss_client *client,\n\t\t       const struct anybuss_memcfg *cfg)\n{\n\tint ret;\n\tu16 op_mode;\n\tstruct anybuss_host *cd = client->host;\n\tstruct msg_anybus_init msg = {\n\t\t.input_io_len = cpu_to_be16(cfg->input_io),\n\t\t.input_dpram_len = cpu_to_be16(cfg->input_dpram),\n\t\t.input_total_len = cpu_to_be16(cfg->input_total),\n\t\t.output_io_len = cpu_to_be16(cfg->output_io),\n\t\t.output_dpram_len = cpu_to_be16(cfg->output_dpram),\n\t\t.output_total_len = cpu_to_be16(cfg->output_total),\n\t\t.notif_config = cpu_to_be16(0x000F),\n\t\t.wd_val = cpu_to_be16(0),\n\t};\n\n\tswitch (cfg->offl_mode) {\n\tcase FIELDBUS_DEV_OFFL_MODE_CLEAR:\n\t\top_mode = 0;\n\t\tbreak;\n\tcase FIELDBUS_DEV_OFFL_MODE_FREEZE:\n\t\top_mode = OP_MODE_FBFC;\n\t\tbreak;\n\tcase FIELDBUS_DEV_OFFL_MODE_SET:\n\t\top_mode = OP_MODE_FBS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tmsg.op_mode = cpu_to_be16(op_mode | OP_MODE_CD);\n\tret = _anybus_mbox_cmd(cd, CMD_START_INIT, false, NULL, 0,\n\t\t\t       NULL, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\treturn _anybus_mbox_cmd(cd, CMD_ANYBUS_INIT, false,\n\t\t\t&msg, sizeof(msg), NULL, 0, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(anybuss_start_init);\n\nint anybuss_finish_init(struct anybuss_client *client)\n{\n\tstruct anybuss_host *cd = client->host;\n\n\treturn _anybus_mbox_cmd(cd, CMD_END_INIT, false, NULL, 0,\n\t\t\t\t\tNULL, 0, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(anybuss_finish_init);\n\nint anybuss_read_fbctrl(struct anybuss_client *client, u16 addr,\n\t\t\tvoid *buf, size_t count)\n{\n\tstruct anybuss_host *cd = client->host;\n\tstruct ab_task *t;\n\tint ret;\n\n\tif (count == 0)\n\t\treturn 0;\n\tif (!area_range_ok(addr, count, FBCTRL_AREA,\n\t\t\t   MAX_FBCTRL_AREA_SZ))\n\t\treturn -EFAULT;\n\tt = create_area_reader(cd->qcache, IND_AX_FBCTRL, addr, count);\n\tif (!t)\n\t\treturn -ENOMEM;\n\tret = ab_task_enqueue_wait(t, cd->powerq, &cd->qlock, &cd->wq);\n\tif (ret)\n\t\tgoto out;\n\tmemcpy(buf, t->area_pd.buf, count);\nout:\n\tab_task_put(t);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(anybuss_read_fbctrl);\n\nint anybuss_write_input(struct anybuss_client *client,\n\t\t\tconst char __user *buf, size_t size,\n\t\t\t\tloff_t *offset)\n{\n\tssize_t len = min_t(loff_t, MAX_DATA_AREA_SZ - *offset, size);\n\tstruct anybuss_host *cd = client->host;\n\tstruct ab_task *t;\n\tint ret;\n\n\tif (len <= 0)\n\t\treturn 0;\n\tt = create_area_user_writer(cd->qcache, IND_AX_IN,\n\t\t\t\t    DATA_IN_AREA + *offset, buf, len);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\tret = ab_task_enqueue_wait(t, cd->powerq, &cd->qlock, &cd->wq);\n\tab_task_put(t);\n\tif (ret)\n\t\treturn ret;\n\t \n\t*offset += len;\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(anybuss_write_input);\n\nint anybuss_read_output(struct anybuss_client *client,\n\t\t\tchar __user *buf, size_t size,\n\t\t\t\tloff_t *offset)\n{\n\tssize_t len = min_t(loff_t, MAX_DATA_AREA_SZ - *offset, size);\n\tstruct anybuss_host *cd = client->host;\n\tstruct ab_task *t;\n\tint ret;\n\n\tif (len <= 0)\n\t\treturn 0;\n\tt = create_area_reader(cd->qcache, IND_AX_OUT,\n\t\t\t       DATA_OUT_AREA + *offset, len);\n\tif (!t)\n\t\treturn -ENOMEM;\n\tret = ab_task_enqueue_wait(t, cd->powerq, &cd->qlock, &cd->wq);\n\tif (ret)\n\t\tgoto out;\n\tif (copy_to_user(buf, t->area_pd.buf, len))\n\t\tret = -EFAULT;\nout:\n\tab_task_put(t);\n\tif (ret)\n\t\treturn ret;\n\t \n\t*offset += len;\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(anybuss_read_output);\n\nint anybuss_send_msg(struct anybuss_client *client, u16 cmd_num,\n\t\t     const void *buf, size_t count)\n{\n\tstruct anybuss_host *cd = client->host;\n\n\treturn _anybus_mbox_cmd(cd, cmd_num, true, buf, count, NULL, 0,\n\t\t\t\t\tNULL, 0);\n}\nEXPORT_SYMBOL_GPL(anybuss_send_msg);\n\nint anybuss_send_ext(struct anybuss_client *client, u16 cmd_num,\n\t\t     const void *buf, size_t count)\n{\n\tstruct anybuss_host *cd = client->host;\n\n\treturn _anybus_mbox_cmd(cd, cmd_num, true, NULL, 0, NULL, 0,\n\t\t\t\t\tbuf, count);\n}\nEXPORT_SYMBOL_GPL(anybuss_send_ext);\n\nint anybuss_recv_msg(struct anybuss_client *client, u16 cmd_num,\n\t\t     void *buf, size_t count)\n{\n\tstruct anybuss_host *cd = client->host;\n\n\treturn _anybus_mbox_cmd(cd, cmd_num, true, NULL, 0, buf, count,\n\t\t\t\t\tNULL, 0);\n}\nEXPORT_SYMBOL_GPL(anybuss_recv_msg);\n\n \n\nstatic int anybus_bus_match(struct device *dev,\n\t\t\t    struct device_driver *drv)\n{\n\tstruct anybuss_client_driver *adrv =\n\t\tto_anybuss_client_driver(drv);\n\tstruct anybuss_client *adev =\n\t\tto_anybuss_client(dev);\n\n\treturn adrv->anybus_id == be16_to_cpu(adev->anybus_id);\n}\n\nstatic int anybus_bus_probe(struct device *dev)\n{\n\tstruct anybuss_client_driver *adrv =\n\t\tto_anybuss_client_driver(dev->driver);\n\tstruct anybuss_client *adev =\n\t\tto_anybuss_client(dev);\n\n\treturn adrv->probe(adev);\n}\n\nstatic void anybus_bus_remove(struct device *dev)\n{\n\tstruct anybuss_client_driver *adrv =\n\t\tto_anybuss_client_driver(dev->driver);\n\n\tif (adrv->remove)\n\t\tadrv->remove(to_anybuss_client(dev));\n}\n\nstatic struct bus_type anybus_bus = {\n\t.name\t\t= \"anybuss\",\n\t.match\t\t= anybus_bus_match,\n\t.probe\t\t= anybus_bus_probe,\n\t.remove\t\t= anybus_bus_remove,\n};\n\nint anybuss_client_driver_register(struct anybuss_client_driver *drv)\n{\n\tif (!drv->probe)\n\t\treturn -ENODEV;\n\n\tdrv->driver.bus = &anybus_bus;\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(anybuss_client_driver_register);\n\nvoid anybuss_client_driver_unregister(struct anybuss_client_driver *drv)\n{\n\treturn driver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(anybuss_client_driver_unregister);\n\nstatic void client_device_release(struct device *dev)\n{\n\tkfree(to_anybuss_client(dev));\n}\n\nstatic int taskq_alloc(struct device *dev, struct kfifo *q)\n{\n\tvoid *buf;\n\tsize_t size = 64 * sizeof(struct ab_task *);\n\n\tbuf = devm_kzalloc(dev, size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -EIO;\n\treturn kfifo_init(q, buf, size);\n}\n\nstatic int anybus_of_get_host_idx(struct device_node *np)\n{\n\tconst __be32 *host_idx;\n\n\thost_idx = of_get_address(np, 0, NULL, NULL);\n\tif (!host_idx)\n\t\treturn -ENOENT;\n\treturn __be32_to_cpu(*host_idx);\n}\n\nstatic struct device_node *\nanybus_of_find_child_device(struct device *dev, int host_idx)\n{\n\tstruct device_node *node;\n\n\tif (!dev || !dev->of_node)\n\t\treturn NULL;\n\tfor_each_child_of_node(dev->of_node, node) {\n\t\tif (anybus_of_get_host_idx(node) == host_idx)\n\t\t\treturn node;\n\t}\n\treturn NULL;\n}\n\nstruct anybuss_host * __must_check\nanybuss_host_common_probe(struct device *dev,\n\t\t\t  const struct anybuss_ops *ops)\n{\n\tint ret, i;\n\tu8 val[4];\n\t__be16 fieldbus_type;\n\tstruct anybuss_host *cd;\n\n\tcd = devm_kzalloc(dev, sizeof(*cd), GFP_KERNEL);\n\tif (!cd)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcd->dev = dev;\n\tcd->host_idx = ops->host_idx;\n\tinit_completion(&cd->card_boot);\n\tinit_waitqueue_head(&cd->wq);\n\tfor (i = 0; i < ARRAY_SIZE(cd->qs); i++) {\n\t\tret = taskq_alloc(dev, &cd->qs[i]);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tif (WARN_ON(ARRAY_SIZE(cd->qs) < 3))\n\t\treturn ERR_PTR(-EINVAL);\n\tcd->powerq = &cd->qs[0];\n\tcd->mboxq = &cd->qs[1];\n\tcd->areaq = &cd->qs[2];\n\tcd->reset = ops->reset;\n\tif (!cd->reset)\n\t\treturn ERR_PTR(-EINVAL);\n\tcd->regmap = ops->regmap;\n\tif (!cd->regmap)\n\t\treturn ERR_PTR(-EINVAL);\n\tspin_lock_init(&cd->qlock);\n\tcd->qcache = kmem_cache_create(dev_name(dev),\n\t\t\t\t       sizeof(struct ab_task), 0, 0, NULL);\n\tif (!cd->qcache)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcd->irq = ops->irq;\n\tif (cd->irq <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto err_qcache;\n\t}\n\t \n\treset_assert(cd);\n\tif (test_dpram(cd->regmap)) {\n\t\tdev_err(dev, \"no Anybus-S card in slot\");\n\t\tret = -ENODEV;\n\t\tgoto err_qcache;\n\t}\n\tret = devm_request_threaded_irq(dev, cd->irq, NULL, irq_handler,\n\t\t\t\t\tIRQF_ONESHOT, dev_name(dev), cd);\n\tif (ret) {\n\t\tdev_err(dev, \"could not request irq\");\n\t\tgoto err_qcache;\n\t}\n\t \n\treset_deassert(cd);\n\tif (!wait_for_completion_timeout(&cd->card_boot, TIMEOUT)) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_reset;\n\t}\n\t \n\tdev_info(dev, \"Anybus-S card detected\");\n\tregmap_bulk_read(cd->regmap, REG_BOOTLOADER_V, val, 2);\n\tdev_info(dev, \"Bootloader version: %02X%02X\",\n\t\t val[0], val[1]);\n\tregmap_bulk_read(cd->regmap, REG_API_V, val, 2);\n\tdev_info(dev, \"API version: %02X%02X\", val[0], val[1]);\n\tregmap_bulk_read(cd->regmap, REG_FIELDBUS_V, val, 2);\n\tdev_info(dev, \"Fieldbus version: %02X%02X\", val[0], val[1]);\n\tregmap_bulk_read(cd->regmap, REG_SERIAL_NO, val, 4);\n\tdev_info(dev, \"Serial number: %02X%02X%02X%02X\",\n\t\t val[0], val[1], val[2], val[3]);\n\tadd_device_randomness(&val, 4);\n\tregmap_bulk_read(cd->regmap, REG_FIELDBUS_TYPE, &fieldbus_type,\n\t\t\t sizeof(fieldbus_type));\n\tdev_info(dev, \"Fieldbus type: %04X\", be16_to_cpu(fieldbus_type));\n\tregmap_bulk_read(cd->regmap, REG_MODULE_SW_V, val, 2);\n\tdev_info(dev, \"Module SW version: %02X%02X\",\n\t\t val[0], val[1]);\n\t \n\tdisable_irq(cd->irq);\n\treset_assert(cd);\n\tatomic_set(&cd->ind_ab, IND_AB_UPDATED);\n\t \n\tcd->qthread = kthread_run(qthread_fn, cd, dev_name(dev));\n\tif (IS_ERR(cd->qthread)) {\n\t\tdev_err(dev, \"could not create kthread\");\n\t\tret = PTR_ERR(cd->qthread);\n\t\tgoto err_reset;\n\t}\n\t \n\tcd->client = kzalloc(sizeof(*cd->client), GFP_KERNEL);\n\tif (!cd->client) {\n\t\tret = -ENOMEM;\n\t\tgoto err_kthread;\n\t}\n\tcd->client->anybus_id = fieldbus_type;\n\tcd->client->host = cd;\n\tcd->client->dev.bus = &anybus_bus;\n\tcd->client->dev.parent = dev;\n\tcd->client->dev.release = client_device_release;\n\tcd->client->dev.of_node =\n\t\tanybus_of_find_child_device(dev, cd->host_idx);\n\tdev_set_name(&cd->client->dev, \"anybuss.card%d\", cd->host_idx);\n\tret = device_register(&cd->client->dev);\n\tif (ret)\n\t\tgoto err_device;\n\treturn cd;\nerr_device:\n\tput_device(&cd->client->dev);\nerr_kthread:\n\tkthread_stop(cd->qthread);\nerr_reset:\n\treset_assert(cd);\nerr_qcache:\n\tkmem_cache_destroy(cd->qcache);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(anybuss_host_common_probe);\n\nvoid anybuss_host_common_remove(struct anybuss_host *host)\n{\n\tstruct anybuss_host *cd = host;\n\n\tdevice_unregister(&cd->client->dev);\n\tkthread_stop(cd->qthread);\n\treset_assert(cd);\n\tkmem_cache_destroy(cd->qcache);\n}\nEXPORT_SYMBOL_GPL(anybuss_host_common_remove);\n\nstatic void host_release(void *res)\n{\n\tanybuss_host_common_remove(res);\n}\n\nstruct anybuss_host * __must_check\ndevm_anybuss_host_common_probe(struct device *dev,\n\t\t\t       const struct anybuss_ops *ops)\n{\n\tstruct anybuss_host *host;\n\tint ret;\n\n\thost = anybuss_host_common_probe(dev, ops);\n\tif (IS_ERR(host))\n\t\treturn host;\n\n\tret = devm_add_action_or_reset(dev, host_release, host);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn host;\n}\nEXPORT_SYMBOL_GPL(devm_anybuss_host_common_probe);\n\nstatic int __init anybus_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&anybus_bus);\n\tif (ret)\n\t\tpr_err(\"could not register Anybus-S bus: %d\\n\", ret);\n\treturn ret;\n}\nmodule_init(anybus_init);\n\nstatic void __exit anybus_exit(void)\n{\n\tbus_unregister(&anybus_bus);\n}\nmodule_exit(anybus_exit);\n\nMODULE_DESCRIPTION(\"HMS Anybus-S Host Driver\");\nMODULE_AUTHOR(\"Sven Van Asbroeck <TheSven73@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}