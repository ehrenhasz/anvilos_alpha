{
  "module_name": "arcx-anybus.c",
  "hash_id": "33e640fdd23e450ba859bdc95ce6ef28b67763538686c44d39f583db688223e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fieldbus/anybuss/arcx-anybus.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regmap.h>\n\n \n#include \"anybuss-controller.h\"\n\n#define CPLD_STATUS1\t\t0x80\n#define CPLD_CONTROL\t\t0x80\n#define CPLD_CONTROL_CRST\t0x40\n#define CPLD_CONTROL_RST1\t0x04\n#define CPLD_CONTROL_RST2\t0x80\n#define CPLD_STATUS1_AB\t\t0x02\n#define CPLD_STATUS1_CAN_POWER\t0x01\n#define CPLD_DESIGN_LO\t\t0x81\n#define CPLD_DESIGN_HI\t\t0x82\n#define CPLD_CAP\t\t0x83\n#define CPLD_CAP_COMPAT\t\t0x01\n#define CPLD_CAP_SEP_RESETS\t0x02\n\nstruct controller_priv {\n\tstruct device *class_dev;\n\tbool common_reset;\n\tstruct gpio_desc *reset_gpiod;\n\tvoid __iomem *cpld_base;\n\tstruct mutex ctrl_lock;  \n\tu8 control_reg;\n\tchar version[3];\n\tu16 design_no;\n};\n\nstatic void do_reset(struct controller_priv *cd, u8 rst_bit, bool reset)\n{\n\tmutex_lock(&cd->ctrl_lock);\n\t \n\tif (reset)\n\t\tcd->control_reg &= ~rst_bit;\n\telse\n\t\tcd->control_reg |= rst_bit;\n\twriteb(cd->control_reg, cd->cpld_base + CPLD_CONTROL);\n\t \n\tif (reset)\n\t\tusleep_range(100, 200);\n\tmutex_unlock(&cd->ctrl_lock);\n}\n\nstatic int anybuss_reset(struct controller_priv *cd,\n\t\t\t unsigned long id, bool reset)\n{\n\tif (id >= 2)\n\t\treturn -EINVAL;\n\tif (cd->common_reset)\n\t\tdo_reset(cd, CPLD_CONTROL_CRST, reset);\n\telse\n\t\tdo_reset(cd, id ? CPLD_CONTROL_RST2 : CPLD_CONTROL_RST1, reset);\n\treturn 0;\n}\n\nstatic void export_reset_0(struct device *dev, bool assert)\n{\n\tstruct controller_priv *cd = dev_get_drvdata(dev);\n\n\tanybuss_reset(cd, 0, assert);\n}\n\nstatic void export_reset_1(struct device *dev, bool assert)\n{\n\tstruct controller_priv *cd = dev_get_drvdata(dev);\n\n\tanybuss_reset(cd, 1, assert);\n}\n\n \n\nstatic const struct regmap_config arcx_regmap_cfg = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = 0x7ff,\n\t.use_single_read = true,\n\t.use_single_write = true,\n\t \n\t.disable_locking = true,\n};\n\nstatic struct regmap *create_parallel_regmap(struct platform_device *pdev,\n\t\t\t\t\t     int idx)\n{\n\tvoid __iomem *base;\n\tstruct device *dev = &pdev->dev;\n\n\tbase = devm_platform_ioremap_resource(pdev, idx + 1);\n\tif (IS_ERR(base))\n\t\treturn ERR_CAST(base);\n\treturn devm_regmap_init_mmio(dev, base, &arcx_regmap_cfg);\n}\n\nstatic struct anybuss_host *\ncreate_anybus_host(struct platform_device *pdev, int idx)\n{\n\tstruct anybuss_ops ops = {};\n\n\tswitch (idx) {\n\tcase 0:\n\t\tops.reset = export_reset_0;\n\t\tbreak;\n\tcase 1:\n\t\tops.reset = export_reset_1;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tops.host_idx = idx;\n\tops.regmap = create_parallel_regmap(pdev, idx);\n\tif (IS_ERR(ops.regmap))\n\t\treturn ERR_CAST(ops.regmap);\n\tops.irq = platform_get_irq(pdev, idx);\n\tif (ops.irq < 0)\n\t\treturn ERR_PTR(ops.irq);\n\treturn devm_anybuss_host_common_probe(&pdev->dev, &ops);\n}\n\nstatic ssize_t version_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct controller_priv *cd = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", cd->version);\n}\nstatic DEVICE_ATTR_RO(version);\n\nstatic ssize_t design_number_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct controller_priv *cd = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", cd->design_no);\n}\nstatic DEVICE_ATTR_RO(design_number);\n\nstatic struct attribute *controller_attributes[] = {\n\t&dev_attr_version.attr,\n\t&dev_attr_design_number.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group controller_attribute_group = {\n\t.attrs = controller_attributes,\n};\n\nstatic const struct attribute_group *controller_attribute_groups[] = {\n\t&controller_attribute_group,\n\tNULL,\n};\n\nstatic void controller_device_release(struct device *dev)\n{\n\tkfree(dev);\n}\n\nstatic int can_power_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct controller_priv *cd = rdev_get_drvdata(rdev);\n\n\treturn !(readb(cd->cpld_base + CPLD_STATUS1) & CPLD_STATUS1_CAN_POWER);\n}\n\nstatic const struct regulator_ops can_power_ops = {\n\t.is_enabled = can_power_is_enabled,\n};\n\nstatic const struct regulator_desc can_power_desc = {\n\t.name = \"regulator-can-power\",\n\t.id = -1,\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n\t.ops = &can_power_ops,\n};\n\nstatic struct class *controller_class;\nstatic DEFINE_IDA(controller_index_ida);\n\nstatic int controller_probe(struct platform_device *pdev)\n{\n\tstruct controller_priv *cd;\n\tstruct device *dev = &pdev->dev;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *regulator;\n\tint err, id;\n\tstruct anybuss_host *host;\n\tu8 status1, cap;\n\n\tcd = devm_kzalloc(dev, sizeof(*cd), GFP_KERNEL);\n\tif (!cd)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, cd);\n\tmutex_init(&cd->ctrl_lock);\n\tcd->reset_gpiod = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(cd->reset_gpiod))\n\t\treturn PTR_ERR(cd->reset_gpiod);\n\n\t \n\tcd->cpld_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cd->cpld_base)) {\n\t\tdev_err(dev,\n\t\t\t\"failed to map cpld base address\\n\");\n\t\terr = PTR_ERR(cd->cpld_base);\n\t\tgoto out_reset;\n\t}\n\n\t \n\tstatus1 = readb(cd->cpld_base + CPLD_STATUS1);\n\tcd->design_no = (readb(cd->cpld_base + CPLD_DESIGN_HI) << 8) |\n\t\t\t\treadb(cd->cpld_base + CPLD_DESIGN_LO);\n\tsnprintf(cd->version, sizeof(cd->version), \"%c%d\",\n\t\t 'A' + ((status1 >> 5) & 0x7),\n\t\t (status1 >> 2) & 0x7);\n\tdev_info(dev, \"design number %d, revision %s\\n\",\n\t\t cd->design_no,\n\t\tcd->version);\n\tcap = readb(cd->cpld_base + CPLD_CAP);\n\tif (!(cap & CPLD_CAP_COMPAT)) {\n\t\tdev_err(dev, \"unsupported controller [cap=0x%02X]\", cap);\n\t\terr = -ENODEV;\n\t\tgoto out_reset;\n\t}\n\n\tif (status1 & CPLD_STATUS1_AB) {\n\t\tdev_info(dev, \"has anybus-S slot(s)\");\n\t\tcd->common_reset = !(cap & CPLD_CAP_SEP_RESETS);\n\t\tdev_info(dev, \"supports %s\", cd->common_reset ?\n\t\t\t\"a common reset\" : \"separate resets\");\n\t\tfor (id = 0; id < 2; id++) {\n\t\t\thost = create_anybus_host(pdev, id);\n\t\t\tif (!IS_ERR(host))\n\t\t\t\tcontinue;\n\t\t\terr = PTR_ERR(host);\n\t\t\t \n\t\t\tif (err != -ENODEV)\n\t\t\t\tgoto out_reset;\n\t\t}\n\t}\n\n\tid = ida_simple_get(&controller_index_ida, 0, 0, GFP_KERNEL);\n\tif (id < 0) {\n\t\terr = id;\n\t\tgoto out_reset;\n\t}\n\t \n\tconfig.dev = dev;\n\tconfig.driver_data = cd;\n\tregulator = devm_regulator_register(dev, &can_power_desc, &config);\n\tif (IS_ERR(regulator)) {\n\t\terr = PTR_ERR(regulator);\n\t\tgoto out_ida;\n\t}\n\t \n\tcd->class_dev = kzalloc(sizeof(*cd->class_dev), GFP_KERNEL);\n\tif (!cd->class_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto out_ida;\n\t}\n\tcd->class_dev->class = controller_class;\n\tcd->class_dev->groups = controller_attribute_groups;\n\tcd->class_dev->parent = dev;\n\tcd->class_dev->id = id;\n\tcd->class_dev->release = controller_device_release;\n\tdev_set_name(cd->class_dev, \"%d\", cd->class_dev->id);\n\tdev_set_drvdata(cd->class_dev, cd);\n\terr = device_register(cd->class_dev);\n\tif (err)\n\t\tgoto out_dev;\n\treturn 0;\nout_dev:\n\tput_device(cd->class_dev);\nout_ida:\n\tida_simple_remove(&controller_index_ida, id);\nout_reset:\n\tgpiod_set_value_cansleep(cd->reset_gpiod, 1);\n\treturn err;\n}\n\nstatic void controller_remove(struct platform_device *pdev)\n{\n\tstruct controller_priv *cd = platform_get_drvdata(pdev);\n\tint id = cd->class_dev->id;\n\n\tdevice_unregister(cd->class_dev);\n\tida_simple_remove(&controller_index_ida, id);\n\tgpiod_set_value_cansleep(cd->reset_gpiod, 1);\n}\n\nstatic const struct of_device_id controller_of_match[] = {\n\t{ .compatible = \"arcx,anybus-controller\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, controller_of_match);\n\nstatic struct platform_driver controller_driver = {\n\t.probe = controller_probe,\n\t.remove_new = controller_remove,\n\t.driver\t\t= {\n\t\t.name   = \"arcx-anybus-controller\",\n\t\t.of_match_table\t= controller_of_match,\n\t},\n};\n\nstatic int __init controller_init(void)\n{\n\tint err;\n\n\tcontroller_class = class_create(\"arcx_anybus_controller\");\n\tif (IS_ERR(controller_class))\n\t\treturn PTR_ERR(controller_class);\n\terr = platform_driver_register(&controller_driver);\n\tif (err)\n\t\tclass_destroy(controller_class);\n\n\treturn err;\n}\n\nstatic void __exit controller_exit(void)\n{\n\tplatform_driver_unregister(&controller_driver);\n\tclass_destroy(controller_class);\n\tida_destroy(&controller_index_ida);\n}\n\nmodule_init(controller_init);\nmodule_exit(controller_exit);\n\nMODULE_DESCRIPTION(\"Arcx Anybus-S Controller driver\");\nMODULE_AUTHOR(\"Sven Van Asbroeck <TheSven73@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}