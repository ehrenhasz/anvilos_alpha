{
  "module_name": "dev_core.c",
  "hash_id": "41472977de7d829849a05d67967c299605abc278a0cdba0aadc327a8bda1e1ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fieldbus/dev_core.c",
  "human_readable_source": "\n \n\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/idr.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n\n \n#include \"fieldbus_dev.h\"\n\n \n#define MAX_FIELDBUSES\t\t32\n\n \nstatic dev_t fieldbus_devt;\nstatic DEFINE_IDA(fieldbus_ida);\nstatic DEFINE_MUTEX(fieldbus_mtx);\n\nstatic ssize_t online_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct fieldbus_dev *fb = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!fb->online);\n}\nstatic DEVICE_ATTR_RO(online);\n\nstatic ssize_t enabled_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct fieldbus_dev *fb = dev_get_drvdata(dev);\n\n\tif (!fb->enable_get)\n\t\treturn -EINVAL;\n\treturn sysfs_emit(buf, \"%d\\n\", !!fb->enable_get(fb));\n}\n\nstatic ssize_t enabled_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t n)\n{\n\tstruct fieldbus_dev *fb = dev_get_drvdata(dev);\n\tbool value;\n\tint ret;\n\n\tif (!fb->simple_enable_set)\n\t\treturn -ENOTSUPP;\n\tret = kstrtobool(buf, &value);\n\tif (ret)\n\t\treturn ret;\n\tret = fb->simple_enable_set(fb, value);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn n;\n}\nstatic DEVICE_ATTR_RW(enabled);\n\nstatic ssize_t card_name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct fieldbus_dev *fb = dev_get_drvdata(dev);\n\n\t \n\treturn sysfs_emit(buf, \"%s\\n\", fb->card_name);\n}\nstatic DEVICE_ATTR_RO(card_name);\n\nstatic ssize_t read_area_size_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct fieldbus_dev *fb = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%zu\\n\", fb->read_area_sz);\n}\nstatic DEVICE_ATTR_RO(read_area_size);\n\nstatic ssize_t write_area_size_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct fieldbus_dev *fb = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%zu\\n\", fb->write_area_sz);\n}\nstatic DEVICE_ATTR_RO(write_area_size);\n\nstatic ssize_t fieldbus_id_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fieldbus_dev *fb = dev_get_drvdata(dev);\n\n\treturn fb->fieldbus_id_get(fb, buf, PAGE_SIZE);\n}\nstatic DEVICE_ATTR_RO(fieldbus_id);\n\nstatic ssize_t fieldbus_type_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct fieldbus_dev *fb = dev_get_drvdata(dev);\n\tconst char *t;\n\n\tswitch (fb->fieldbus_type) {\n\tcase FIELDBUS_DEV_TYPE_PROFINET:\n\t\tt = \"profinet\";\n\t\tbreak;\n\tdefault:\n\t\tt = \"unknown\";\n\t\tbreak;\n\t}\n\n\treturn sysfs_emit(buf, \"%s\\n\", t);\n}\nstatic DEVICE_ATTR_RO(fieldbus_type);\n\nstatic struct attribute *fieldbus_attrs[] = {\n\t&dev_attr_enabled.attr,\n\t&dev_attr_card_name.attr,\n\t&dev_attr_fieldbus_id.attr,\n\t&dev_attr_read_area_size.attr,\n\t&dev_attr_write_area_size.attr,\n\t&dev_attr_online.attr,\n\t&dev_attr_fieldbus_type.attr,\n\tNULL,\n};\n\nstatic umode_t fieldbus_is_visible(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t   int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct fieldbus_dev *fb = dev_get_drvdata(dev);\n\tumode_t mode = attr->mode;\n\n\tif (attr == &dev_attr_enabled.attr) {\n\t\tmode = 0;\n\t\tif (fb->enable_get)\n\t\t\tmode |= 0444;\n\t\tif (fb->simple_enable_set)\n\t\t\tmode |= 0200;\n\t}\n\n\treturn mode;\n}\n\nstatic const struct attribute_group fieldbus_group = {\n\t.attrs = fieldbus_attrs,\n\t.is_visible = fieldbus_is_visible,\n};\n__ATTRIBUTE_GROUPS(fieldbus);\n\nstatic struct class fieldbus_class = {\n\t.name =\t\t\"fieldbus_dev\",\n\t.dev_groups =\tfieldbus_groups,\n};\n\nstruct fb_open_file {\n\tstruct fieldbus_dev *fbdev;\n\tint dc_event;\n};\n\nstatic int fieldbus_open(struct inode *inode, struct file *filp)\n{\n\tstruct fb_open_file *of;\n\tstruct fieldbus_dev *fbdev = container_of(inode->i_cdev,\n\t\t\t\t\t\tstruct fieldbus_dev,\n\t\t\t\t\t\tcdev);\n\n\tof = kzalloc(sizeof(*of), GFP_KERNEL);\n\tif (!of)\n\t\treturn -ENOMEM;\n\tof->fbdev = fbdev;\n\tfilp->private_data = of;\n\treturn 0;\n}\n\nstatic int fieldbus_release(struct inode *node, struct file *filp)\n{\n\tstruct fb_open_file *of = filp->private_data;\n\n\tkfree(of);\n\treturn 0;\n}\n\nstatic ssize_t fieldbus_read(struct file *filp, char __user *buf, size_t size,\n\t\t\t     loff_t *offset)\n{\n\tstruct fb_open_file *of = filp->private_data;\n\tstruct fieldbus_dev *fbdev = of->fbdev;\n\n\tof->dc_event = fbdev->dc_event;\n\treturn fbdev->read_area(fbdev, buf, size, offset);\n}\n\nstatic ssize_t fieldbus_write(struct file *filp, const char __user *buf,\n\t\t\t      size_t size, loff_t *offset)\n{\n\tstruct fb_open_file *of = filp->private_data;\n\tstruct fieldbus_dev *fbdev = of->fbdev;\n\n\treturn fbdev->write_area(fbdev, buf, size, offset);\n}\n\nstatic __poll_t fieldbus_poll(struct file *filp, poll_table *wait)\n{\n\tstruct fb_open_file *of = filp->private_data;\n\tstruct fieldbus_dev *fbdev = of->fbdev;\n\t__poll_t mask = EPOLLIN | EPOLLRDNORM | EPOLLOUT | EPOLLWRNORM;\n\n\tpoll_wait(filp, &fbdev->dc_wq, wait);\n\t \n\tif (fbdev->dc_event != of->dc_event)\n\t\tmask |= EPOLLPRI | EPOLLERR;\n\treturn mask;\n}\n\nstatic const struct file_operations fieldbus_fops = {\n\t.open\t\t= fieldbus_open,\n\t.release\t= fieldbus_release,\n\t.read\t\t= fieldbus_read,\n\t.write\t\t= fieldbus_write,\n\t.poll\t\t= fieldbus_poll,\n\t.llseek\t\t= generic_file_llseek,\n\t.owner\t\t= THIS_MODULE,\n};\n\nvoid fieldbus_dev_area_updated(struct fieldbus_dev *fb)\n{\n\tfb->dc_event++;\n\twake_up_all(&fb->dc_wq);\n}\nEXPORT_SYMBOL_GPL(fieldbus_dev_area_updated);\n\nvoid fieldbus_dev_online_changed(struct fieldbus_dev *fb, bool online)\n{\n\tfb->online = online;\n\tkobject_uevent(&fb->dev->kobj, KOBJ_CHANGE);\n}\nEXPORT_SYMBOL_GPL(fieldbus_dev_online_changed);\n\nstatic void __fieldbus_dev_unregister(struct fieldbus_dev *fb)\n{\n\tif (!fb)\n\t\treturn;\n\tdevice_destroy(&fieldbus_class, fb->cdev.dev);\n\tcdev_del(&fb->cdev);\n\tida_simple_remove(&fieldbus_ida, fb->id);\n}\n\nvoid fieldbus_dev_unregister(struct fieldbus_dev *fb)\n{\n\tmutex_lock(&fieldbus_mtx);\n\t__fieldbus_dev_unregister(fb);\n\tmutex_unlock(&fieldbus_mtx);\n}\nEXPORT_SYMBOL_GPL(fieldbus_dev_unregister);\n\nstatic int __fieldbus_dev_register(struct fieldbus_dev *fb)\n{\n\tdev_t devno;\n\tint err;\n\n\tif (!fb)\n\t\treturn -EINVAL;\n\tif (!fb->read_area || !fb->write_area || !fb->fieldbus_id_get)\n\t\treturn -EINVAL;\n\tfb->id = ida_simple_get(&fieldbus_ida, 0, MAX_FIELDBUSES, GFP_KERNEL);\n\tif (fb->id < 0)\n\t\treturn fb->id;\n\tdevno = MKDEV(MAJOR(fieldbus_devt), fb->id);\n\tinit_waitqueue_head(&fb->dc_wq);\n\tcdev_init(&fb->cdev, &fieldbus_fops);\n\terr = cdev_add(&fb->cdev, devno, 1);\n\tif (err) {\n\t\tpr_err(\"fieldbus_dev%d unable to add device %d:%d\\n\",\n\t\t       fb->id, MAJOR(fieldbus_devt), fb->id);\n\t\tgoto err_cdev;\n\t}\n\tfb->dev = device_create(&fieldbus_class, fb->parent, devno, fb,\n\t\t\t\t\"fieldbus_dev%d\", fb->id);\n\tif (IS_ERR(fb->dev)) {\n\t\terr = PTR_ERR(fb->dev);\n\t\tgoto err_dev_create;\n\t}\n\treturn 0;\n\nerr_dev_create:\n\tcdev_del(&fb->cdev);\nerr_cdev:\n\tida_simple_remove(&fieldbus_ida, fb->id);\n\treturn err;\n}\n\nint fieldbus_dev_register(struct fieldbus_dev *fb)\n{\n\tint err;\n\n\tmutex_lock(&fieldbus_mtx);\n\terr = __fieldbus_dev_register(fb);\n\tmutex_unlock(&fieldbus_mtx);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fieldbus_dev_register);\n\nstatic int __init fieldbus_init(void)\n{\n\tint err;\n\n\terr = class_register(&fieldbus_class);\n\tif (err < 0) {\n\t\tpr_err(\"fieldbus_dev: could not register class\\n\");\n\t\treturn err;\n\t}\n\terr = alloc_chrdev_region(&fieldbus_devt, 0,\n\t\t\t\t  MAX_FIELDBUSES, \"fieldbus_dev\");\n\tif (err < 0) {\n\t\tpr_err(\"fieldbus_dev: unable to allocate char dev region\\n\");\n\t\tgoto err_alloc;\n\t}\n\treturn 0;\n\nerr_alloc:\n\tclass_unregister(&fieldbus_class);\n\treturn err;\n}\n\nstatic void __exit fieldbus_exit(void)\n{\n\tunregister_chrdev_region(fieldbus_devt, MAX_FIELDBUSES);\n\tclass_unregister(&fieldbus_class);\n\tida_destroy(&fieldbus_ida);\n}\n\nsubsys_initcall(fieldbus_init);\nmodule_exit(fieldbus_exit);\n\nMODULE_AUTHOR(\"Sven Van Asbroeck <TheSven73@gmail.com>\");\nMODULE_AUTHOR(\"Jonathan Stiles <jonathans@arcx.com>\");\nMODULE_DESCRIPTION(\"Fieldbus Device Driver Core\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}