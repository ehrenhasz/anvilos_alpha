{
  "module_name": "rxtx.c",
  "hash_id": "89f03f53d54e914aeeb8866ad585c5fccdfb4c17aaa22f02849732a4172a6cef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vt6656/rxtx.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include \"device.h\"\n#include \"rxtx.h\"\n#include \"card.h\"\n#include \"mac.h\"\n#include \"rf.h\"\n#include \"usbpipe.h\"\n\nstatic const u16 vnt_time_stampoff[2][MAX_RATE] = {\n\t \n\t{384, 288, 226, 209, 54, 43, 37, 31, 28, 25, 24, 23},\n\n\t \n\t{384, 192, 130, 113, 54, 43, 37, 31, 28, 25, 24, 23},\n};\n\n#define DATADUR_B       10\n#define DATADUR_A       11\n\nstatic const u8 vnt_phy_signal[] = {\n\t0x00,\t \n\t0x01,\t \n\t0x02,\t \n\t0x03,\t \n\t0x8b,\t \n\t0x8f,\t \n\t0x8a,\t \n\t0x8e,\t \n\t0x89,\t \n\t0x8d,\t \n\t0x88,\t \n\t0x8c\t \n};\n\nstatic struct vnt_usb_send_context\n\t*vnt_get_free_context(struct vnt_private *priv)\n{\n\tstruct vnt_usb_send_context *context = NULL;\n\tint ii;\n\n\tfor (ii = 0; ii < priv->num_tx_context; ii++) {\n\t\tif (!priv->tx_context[ii])\n\t\t\treturn NULL;\n\n\t\tcontext = priv->tx_context[ii];\n\t\tif (!context->in_use) {\n\t\t\tcontext->in_use = true;\n\t\t\treturn context;\n\t\t}\n\t}\n\n\tif (ii == priv->num_tx_context) {\n\t\tdev_dbg(&priv->usb->dev, \"%s No Free Tx Context\\n\", __func__);\n\n\t\tieee80211_stop_queues(priv->hw);\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void vnt_get_phy_field(struct vnt_private *priv, u32 frame_length,\n\t\t\t      u16 tx_rate, u8 pkt_type,\n\t\t\t      struct vnt_phy_field *phy)\n{\n\tu32 bit_count;\n\tu32 count = 0;\n\tu32 tmp;\n\tint ext_bit;\n\tint i;\n\tu8 mask = 0;\n\tu8 preamble_type = priv->preamble_type;\n\n\tbit_count = frame_length * 8;\n\text_bit = false;\n\n\tswitch (tx_rate) {\n\tcase RATE_1M:\n\t\tcount = bit_count;\n\t\tbreak;\n\tcase RATE_2M:\n\t\tcount = bit_count / 2;\n\t\tbreak;\n\tcase RATE_5M:\n\t\tcount = DIV_ROUND_UP(bit_count * 10, 55);\n\t\tbreak;\n\tcase RATE_11M:\n\t\tcount = bit_count / 11;\n\t\ttmp = count * 11;\n\n\t\tif (tmp != bit_count) {\n\t\t\tcount++;\n\n\t\t\tif ((bit_count - tmp) <= 3)\n\t\t\t\text_bit = true;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (tx_rate > RATE_11M) {\n\t\tif (pkt_type == PK_TYPE_11A)\n\t\t\tmask = BIT(4);\n\t} else if (tx_rate > RATE_1M) {\n\t\tif (preamble_type == PREAMBLE_SHORT)\n\t\t\tmask = BIT(3);\n\t}\n\n\ti = tx_rate > RATE_54M ? RATE_54M : tx_rate;\n\tphy->signal = vnt_phy_signal[i] | mask;\n\tphy->service = 0x00;\n\n\tif (pkt_type == PK_TYPE_11B) {\n\t\tif (ext_bit)\n\t\t\tphy->service |= 0x80;\n\t\tphy->len = cpu_to_le16((u16)count);\n\t} else {\n\t\tphy->len = cpu_to_le16((u16)frame_length);\n\t}\n}\n\nstatic __le16 vnt_time_stamp_off(struct vnt_private *priv, u16 rate)\n{\n\treturn cpu_to_le16(vnt_time_stampoff[priv->preamble_type % 2]\n\t\t\t\t\t\t\t[rate % MAX_RATE]);\n}\n\nstatic __le16 vnt_rxtx_rsvtime_le16(struct vnt_usb_send_context *context)\n{\n\tstruct vnt_private *priv = context->priv;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(context->skb);\n\tstruct ieee80211_rate *rate = ieee80211_get_tx_rate(priv->hw, info);\n\n\treturn ieee80211_generic_frame_duration(priv->hw,\n\t\t\t\t\t\t info->control.vif, info->band,\n\t\t\t\t\t\t context->frame_len,\n\t\t\t\t\t\t rate);\n}\n\nstatic __le16 vnt_get_rts_duration(struct vnt_usb_send_context *context)\n{\n\tstruct vnt_private *priv = context->priv;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(context->skb);\n\n\treturn ieee80211_rts_duration(priv->hw, priv->vif,\n\t\t\t\t      context->frame_len, info);\n}\n\nstatic __le16 vnt_get_cts_duration(struct vnt_usb_send_context *context)\n{\n\tstruct vnt_private *priv = context->priv;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(context->skb);\n\n\treturn ieee80211_ctstoself_duration(priv->hw, priv->vif,\n\t\t\t\t\t    context->frame_len, info);\n}\n\nstatic void vnt_rxtx_datahead_g(struct vnt_usb_send_context *tx_context,\n\t\t\t\tstruct vnt_tx_datahead_g *buf)\n{\n\tstruct vnt_private *priv = tx_context->priv;\n\tstruct ieee80211_hdr *hdr =\n\t\t\t\t(struct ieee80211_hdr *)tx_context->skb->data;\n\tu32 frame_len = tx_context->frame_len;\n\tu16 rate = tx_context->tx_rate;\n\n\t \n\tvnt_get_phy_field(priv, frame_len, rate, tx_context->pkt_type, &buf->a);\n\tvnt_get_phy_field(priv, frame_len, priv->top_cck_basic_rate,\n\t\t\t  PK_TYPE_11B, &buf->b);\n\n\t \n\tbuf->duration_a = hdr->duration_id;\n\tbuf->duration_b = hdr->duration_id;\n\tbuf->time_stamp_off_a = vnt_time_stamp_off(priv, rate);\n\tbuf->time_stamp_off_b = vnt_time_stamp_off(priv,\n\t\t\t\t\t\t   priv->top_cck_basic_rate);\n}\n\nstatic void vnt_rxtx_datahead_ab(struct vnt_usb_send_context *tx_context,\n\t\t\t\t struct vnt_tx_datahead_ab *buf)\n{\n\tstruct vnt_private *priv = tx_context->priv;\n\tstruct ieee80211_hdr *hdr =\n\t\t\t\t(struct ieee80211_hdr *)tx_context->skb->data;\n\tu32 frame_len = tx_context->frame_len;\n\tu16 rate = tx_context->tx_rate;\n\n\t \n\tvnt_get_phy_field(priv, frame_len, rate,\n\t\t\t  tx_context->pkt_type, &buf->ab);\n\n\t \n\tbuf->duration = hdr->duration_id;\n\tbuf->time_stamp_off = vnt_time_stamp_off(priv, rate);\n}\n\nstatic void vnt_fill_ieee80211_rts(struct vnt_usb_send_context *tx_context,\n\t\t\t\t   struct ieee80211_rts *rts, __le16 duration)\n{\n\tstruct ieee80211_hdr *hdr =\n\t\t\t\t(struct ieee80211_hdr *)tx_context->skb->data;\n\n\trts->duration = duration;\n\trts->frame_control =\n\t\tcpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_RTS);\n\n\tether_addr_copy(rts->ra, hdr->addr1);\n\tether_addr_copy(rts->ta, hdr->addr2);\n}\n\nstatic void vnt_rxtx_rts_g_head(struct vnt_usb_send_context *tx_context,\n\t\t\t\tstruct vnt_rts_g *buf)\n{\n\tstruct vnt_private *priv = tx_context->priv;\n\tu16 rts_frame_len = 20;\n\n\tvnt_get_phy_field(priv, rts_frame_len, priv->top_cck_basic_rate,\n\t\t\t  PK_TYPE_11B, &buf->b);\n\tvnt_get_phy_field(priv, rts_frame_len, priv->top_ofdm_basic_rate,\n\t\t\t  tx_context->pkt_type, &buf->a);\n\n\tbuf->duration_bb = vnt_get_rts_duration(tx_context);\n\tbuf->duration_aa = buf->duration_bb;\n\tbuf->duration_ba = buf->duration_bb;\n\n\tvnt_fill_ieee80211_rts(tx_context, &buf->data, buf->duration_aa);\n\n\tvnt_rxtx_datahead_g(tx_context, &buf->data_head);\n}\n\nstatic void vnt_rxtx_rts_ab_head(struct vnt_usb_send_context *tx_context,\n\t\t\t\t struct vnt_rts_ab *buf)\n{\n\tstruct vnt_private *priv = tx_context->priv;\n\tu16 rts_frame_len = 20;\n\n\tvnt_get_phy_field(priv, rts_frame_len, priv->top_ofdm_basic_rate,\n\t\t\t  tx_context->pkt_type, &buf->ab);\n\n\tbuf->duration = vnt_get_rts_duration(tx_context);\n\n\tvnt_fill_ieee80211_rts(tx_context, &buf->data, buf->duration);\n\n\tvnt_rxtx_datahead_ab(tx_context, &buf->data_head);\n}\n\nstatic void vnt_fill_cts_head(struct vnt_usb_send_context *tx_context,\n\t\t\t      union vnt_tx_data_head *head)\n{\n\tstruct vnt_private *priv = tx_context->priv;\n\tstruct vnt_cts *buf = &head->cts_g;\n\tu32 cts_frame_len = 14;\n\n\t \n\tvnt_get_phy_field(priv, cts_frame_len, priv->top_cck_basic_rate,\n\t\t\t  PK_TYPE_11B, &buf->b);\n\t \n\tbuf->duration_ba = vnt_get_cts_duration(tx_context);\n\t \n\tbuf->data.duration = buf->duration_ba;\n\tbuf->data.frame_control =\n\t\tcpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_CTS);\n\n\tether_addr_copy(buf->data.ra, priv->current_net_addr);\n\n\tvnt_rxtx_datahead_g(tx_context, &buf->data_head);\n}\n\n \nstatic bool vnt_fill_txkey(struct vnt_tx_buffer *tx_buffer, struct sk_buff *skb)\n{\n\tstruct vnt_tx_fifo_head *fifo = &tx_buffer->fifo_head;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_key_conf *tx_key = info->control.hw_key;\n\tstruct vnt_mic_hdr *mic_hdr;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tu64 pn64;\n\tu16 payload_len = skb->len;\n\tu8 *iv = ((u8 *)hdr + ieee80211_get_hdrlen_from_skb(skb));\n\n\t \n\tpayload_len -= ieee80211_get_hdrlen_from_skb(skb);\n\tpayload_len -= tx_key->icv_len;\n\n\tswitch (tx_key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tmemcpy(fifo->tx_key, iv, 3);\n\t\tmemcpy(fifo->tx_key + 3, tx_key->key, tx_key->keylen);\n\n\t\tif (tx_key->keylen == WLAN_KEY_LEN_WEP40) {\n\t\t\tmemcpy(fifo->tx_key + 8, iv, 3);\n\t\t\tmemcpy(fifo->tx_key + 11,\n\t\t\t       tx_key->key, WLAN_KEY_LEN_WEP40);\n\t\t}\n\n\t\tfifo->frag_ctl |= cpu_to_le16(FRAGCTL_LEGACY);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tieee80211_get_tkip_p2k(tx_key, skb, fifo->tx_key);\n\n\t\tfifo->frag_ctl |= cpu_to_le16(FRAGCTL_TKIP);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tif (info->control.use_cts_prot) {\n\t\t\tif (info->control.use_rts)\n\t\t\t\tmic_hdr = &tx_buffer->tx_head.tx_rts.tx.mic.hdr;\n\t\t\telse\n\t\t\t\tmic_hdr = &tx_buffer->tx_head.tx_cts.tx.mic.hdr;\n\t\t} else {\n\t\t\tmic_hdr = &tx_buffer->tx_head.tx_ab.tx.mic.hdr;\n\t\t}\n\n\t\tmic_hdr->id = 0x59;\n\t\tmic_hdr->payload_len = cpu_to_be16(payload_len);\n\t\tether_addr_copy(mic_hdr->mic_addr2, hdr->addr2);\n\n\t\tpn64 = atomic64_read(&tx_key->tx_pn);\n\t\tmic_hdr->ccmp_pn[5] = pn64;\n\t\tmic_hdr->ccmp_pn[4] = pn64 >> 8;\n\t\tmic_hdr->ccmp_pn[3] = pn64 >> 16;\n\t\tmic_hdr->ccmp_pn[2] = pn64 >> 24;\n\t\tmic_hdr->ccmp_pn[1] = pn64 >> 32;\n\t\tmic_hdr->ccmp_pn[0] = pn64 >> 40;\n\n\t\tif (ieee80211_has_a4(hdr->frame_control))\n\t\t\tmic_hdr->hlen = cpu_to_be16(28);\n\t\telse\n\t\t\tmic_hdr->hlen = cpu_to_be16(22);\n\n\t\tether_addr_copy(mic_hdr->addr1, hdr->addr1);\n\t\tether_addr_copy(mic_hdr->addr2, hdr->addr2);\n\t\tether_addr_copy(mic_hdr->addr3, hdr->addr3);\n\n\t\tmic_hdr->frame_control = cpu_to_le16(le16_to_cpu(hdr->frame_control) & 0xc78f);\n\t\tmic_hdr->seq_ctrl = cpu_to_le16(le16_to_cpu(hdr->seq_ctrl) & 0xf);\n\n\t\tif (ieee80211_has_a4(hdr->frame_control))\n\t\t\tether_addr_copy(mic_hdr->addr4, hdr->addr4);\n\n\t\tmemcpy(fifo->tx_key, tx_key->key, WLAN_KEY_LEN_CCMP);\n\n\t\tfifo->frag_ctl |= cpu_to_le16(FRAGCTL_AES);\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic void vnt_rxtx_rts(struct vnt_usb_send_context *tx_context)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_context->skb);\n\tstruct vnt_tx_buffer *tx_buffer = tx_context->tx_buffer;\n\tunion vnt_tx_head *tx_head = &tx_buffer->tx_head;\n\tstruct vnt_rrv_time_rts *buf = &tx_head->tx_rts.rts;\n\tunion vnt_tx_data_head *head = &tx_head->tx_rts.tx.head;\n\n\tbuf->rts_rrv_time_aa = vnt_get_rts_duration(tx_context);\n\tbuf->rts_rrv_time_ba = buf->rts_rrv_time_aa;\n\tbuf->rts_rrv_time_bb = buf->rts_rrv_time_aa;\n\n\tbuf->rrv_time_a = vnt_rxtx_rsvtime_le16(tx_context);\n\tbuf->rrv_time_b = buf->rrv_time_a;\n\n\tif (info->control.hw_key) {\n\t\tif (vnt_fill_txkey(tx_buffer, tx_context->skb))\n\t\t\thead = &tx_head->tx_rts.tx.mic.head;\n\t}\n\n\tvnt_rxtx_rts_g_head(tx_context, &head->rts_g);\n}\n\nstatic void vnt_rxtx_cts(struct vnt_usb_send_context *tx_context)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_context->skb);\n\tstruct vnt_tx_buffer *tx_buffer = tx_context->tx_buffer;\n\tunion vnt_tx_head *tx_head = &tx_buffer->tx_head;\n\tstruct vnt_rrv_time_cts *buf = &tx_head->tx_cts.cts;\n\tunion vnt_tx_data_head *head = &tx_head->tx_cts.tx.head;\n\n\tbuf->rrv_time_a = vnt_rxtx_rsvtime_le16(tx_context);\n\tbuf->rrv_time_b = buf->rrv_time_a;\n\n\tbuf->cts_rrv_time_ba = vnt_get_cts_duration(tx_context);\n\n\tif (info->control.hw_key) {\n\t\tif (vnt_fill_txkey(tx_buffer, tx_context->skb))\n\t\t\thead = &tx_head->tx_cts.tx.mic.head;\n\t}\n\n\tvnt_fill_cts_head(tx_context, head);\n}\n\nstatic void vnt_rxtx_ab(struct vnt_usb_send_context *tx_context)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_context->skb);\n\tstruct vnt_tx_buffer *tx_buffer = tx_context->tx_buffer;\n\tunion vnt_tx_head *tx_head = &tx_buffer->tx_head;\n\tstruct vnt_rrv_time_ab *buf = &tx_head->tx_ab.ab;\n\tunion vnt_tx_data_head *head = &tx_head->tx_ab.tx.head;\n\n\tbuf->rrv_time = vnt_rxtx_rsvtime_le16(tx_context);\n\n\tif (info->control.hw_key) {\n\t\tif (vnt_fill_txkey(tx_buffer, tx_context->skb))\n\t\t\thead = &tx_head->tx_ab.tx.mic.head;\n\t}\n\n\tif (info->control.use_rts) {\n\t\tbuf->rts_rrv_time = vnt_get_rts_duration(tx_context);\n\n\t\tvnt_rxtx_rts_ab_head(tx_context, &head->rts_ab);\n\n\t\treturn;\n\t}\n\n\tvnt_rxtx_datahead_ab(tx_context, &head->data_head_ab);\n}\n\nstatic void vnt_generate_tx_parameter(struct vnt_usb_send_context *tx_context)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_context->skb);\n\n\tif (info->control.use_cts_prot) {\n\t\tif (info->control.use_rts) {\n\t\t\tvnt_rxtx_rts(tx_context);\n\n\t\t\treturn;\n\t\t}\n\n\t\tvnt_rxtx_cts(tx_context);\n\n\t\treturn;\n\t}\n\n\tvnt_rxtx_ab(tx_context);\n}\n\nstatic u16 vnt_get_hdr_size(struct ieee80211_tx_info *info)\n{\n\tu16 size = sizeof(struct vnt_tx_datahead_ab);\n\n\tif (info->control.use_cts_prot) {\n\t\tif (info->control.use_rts)\n\t\t\tsize = sizeof(struct vnt_rts_g);\n\t\telse\n\t\t\tsize = sizeof(struct vnt_cts);\n\t} else if (info->control.use_rts) {\n\t\tsize = sizeof(struct vnt_rts_ab);\n\t}\n\n\tif (info->control.hw_key) {\n\t\tif (info->control.hw_key->cipher == WLAN_CIPHER_SUITE_CCMP)\n\t\t\tsize += sizeof(struct vnt_mic_hdr);\n\t}\n\n\t \n\tif (info->control.use_cts_prot) {\n\t\tif (info->control.use_rts)\n\t\t\tsize += sizeof(struct vnt_rrv_time_rts);\n\t\telse\n\t\t\tsize += sizeof(struct vnt_rrv_time_cts);\n\t} else {\n\t\tsize += sizeof(struct vnt_rrv_time_ab);\n\t}\n\n\tsize += sizeof(struct vnt_tx_fifo_head);\n\n\treturn size;\n}\n\nint vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_tx_rate *tx_rate = &info->control.rates[0];\n\tstruct ieee80211_rate *rate;\n\tstruct ieee80211_hdr *hdr;\n\tstruct vnt_tx_buffer *tx_buffer;\n\tstruct vnt_tx_fifo_head *tx_buffer_head;\n\tstruct vnt_usb_send_context *tx_context;\n\tunsigned long flags;\n\tu8 pkt_type;\n\n\thdr = (struct ieee80211_hdr *)(skb->data);\n\n\trate = ieee80211_get_tx_rate(priv->hw, info);\n\n\tif (rate->hw_value > RATE_11M) {\n\t\tif (info->band == NL80211_BAND_5GHZ) {\n\t\t\tpkt_type = PK_TYPE_11A;\n\t\t} else {\n\t\t\tif (tx_rate->flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\t\t\tif (priv->basic_rates & VNT_B_RATES)\n\t\t\t\t\tpkt_type = PK_TYPE_11GB;\n\t\t\t\telse\n\t\t\t\t\tpkt_type = PK_TYPE_11GA;\n\t\t\t} else {\n\t\t\t\tpkt_type = PK_TYPE_11A;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpkt_type = PK_TYPE_11B;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\ttx_context = vnt_get_free_context(priv);\n\tif (!tx_context) {\n\t\tdev_dbg(&priv->usb->dev, \"%s No free context\\n\", __func__);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\n\ttx_context->pkt_type = pkt_type;\n\ttx_context->frame_len = skb->len + 4;\n\ttx_context->tx_rate =  rate->hw_value;\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\ttx_context->skb = skb_clone(skb, GFP_ATOMIC);\n\tif (!tx_context->skb) {\n\t\ttx_context->in_use = false;\n\t\treturn -ENOMEM;\n\t}\n\n\ttx_buffer = skb_push(skb, vnt_get_hdr_size(info));\n\ttx_context->tx_buffer = tx_buffer;\n\ttx_buffer_head = &tx_buffer->fifo_head;\n\n\ttx_context->type = CONTEXT_DATA_PACKET;\n\n\t \n\tif (pkt_type == PK_TYPE_11A)\n\t\ttx_buffer_head->fifo_ctl = 0;\n\telse if (pkt_type == PK_TYPE_11B)\n\t\ttx_buffer_head->fifo_ctl = cpu_to_le16(FIFOCTL_11B);\n\telse if (pkt_type == PK_TYPE_11GB)\n\t\ttx_buffer_head->fifo_ctl = cpu_to_le16(FIFOCTL_11GB);\n\telse if (pkt_type == PK_TYPE_11GA)\n\t\ttx_buffer_head->fifo_ctl = cpu_to_le16(FIFOCTL_11GA);\n\n\tif (!ieee80211_is_data(hdr->frame_control)) {\n\t\ttx_buffer_head->fifo_ctl |= cpu_to_le16(FIFOCTL_GENINT |\n\t\t\t\t\t\t\tFIFOCTL_ISDMA0);\n\t\ttx_buffer_head->fifo_ctl |= cpu_to_le16(FIFOCTL_TMOEN);\n\n\t\ttx_buffer_head->time_stamp =\n\t\t\tcpu_to_le16(DEFAULT_MGN_LIFETIME_RES_64us);\n\t} else {\n\t\ttx_buffer_head->time_stamp =\n\t\t\tcpu_to_le16(DEFAULT_MSDU_LIFETIME_RES_64us);\n\t}\n\n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\ttx_buffer_head->fifo_ctl |= cpu_to_le16(FIFOCTL_NEEDACK);\n\n\tif (ieee80211_has_retry(hdr->frame_control))\n\t\ttx_buffer_head->fifo_ctl |= cpu_to_le16(FIFOCTL_LRETRY);\n\n\tif (info->control.use_rts)\n\t\ttx_buffer_head->fifo_ctl |= cpu_to_le16(FIFOCTL_RTS);\n\n\tif (ieee80211_has_a4(hdr->frame_control))\n\t\ttx_buffer_head->fifo_ctl |= cpu_to_le16(FIFOCTL_LHEAD);\n\n\ttx_buffer_head->frag_ctl =\n\t\t\tcpu_to_le16(ieee80211_hdrlen(hdr->frame_control) << 10);\n\n\tif (info->control.hw_key)\n\t\ttx_context->frame_len += info->control.hw_key->icv_len;\n\n\ttx_buffer_head->current_rate = cpu_to_le16(rate->hw_value);\n\n\tvnt_generate_tx_parameter(tx_context);\n\n\ttx_buffer_head->frag_ctl |= cpu_to_le16(FRAGCTL_NONFRAG);\n\n\tpriv->seq_counter = (le16_to_cpu(hdr->seq_ctrl) &\n\t\t\t\t\t\tIEEE80211_SCTL_SEQ) >> 4;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (vnt_tx_context(priv, tx_context, skb)) {\n\t\tdev_kfree_skb(tx_context->skb);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn -EIO;\n\t}\n\n\tdev_kfree_skb(skb);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int vnt_beacon_xmit(struct vnt_private *priv, struct sk_buff *skb)\n{\n\tstruct vnt_tx_short_buf_head *short_head;\n\tstruct ieee80211_tx_info *info;\n\tstruct vnt_usb_send_context *context;\n\tstruct ieee80211_mgmt *mgmt_hdr;\n\tunsigned long flags;\n\tu32 frame_size = skb->len + 4;\n\tu16 current_rate;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tcontext = vnt_get_free_context(priv);\n\tif (!context) {\n\t\tdev_dbg(&priv->usb->dev, \"%s No free context!\\n\", __func__);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\n\tcontext->skb = skb;\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tmgmt_hdr = (struct ieee80211_mgmt *)skb->data;\n\tshort_head = skb_push(skb, sizeof(*short_head));\n\n\tif (priv->bb_type == BB_TYPE_11A) {\n\t\tcurrent_rate = RATE_6M;\n\n\t\t \n\t\tvnt_get_phy_field(priv, frame_size, current_rate,\n\t\t\t\t  PK_TYPE_11A, &short_head->ab);\n\n\t\t \n\t\tshort_head->time_stamp_off =\n\t\t\t\tvnt_time_stamp_off(priv, current_rate);\n\t} else {\n\t\tcurrent_rate = RATE_1M;\n\t\tshort_head->fifo_ctl |= cpu_to_le16(FIFOCTL_11B);\n\n\t\t \n\t\tvnt_get_phy_field(priv, frame_size, current_rate,\n\t\t\t\t  PK_TYPE_11B, &short_head->ab);\n\n\t\t \n\t\tshort_head->time_stamp_off =\n\t\t\tvnt_time_stamp_off(priv, current_rate);\n\t}\n\n\t \n\tshort_head->duration = mgmt_hdr->duration;\n\n\t \n\tmgmt_hdr->u.beacon.timestamp = 0;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {\n\t\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)mgmt_hdr;\n\n\t\thdr->duration_id = 0;\n\t\thdr->seq_ctrl = cpu_to_le16(priv->seq_counter << 4);\n\t}\n\n\tpriv->seq_counter++;\n\tif (priv->seq_counter > 0x0fff)\n\t\tpriv->seq_counter = 0;\n\n\tcontext->type = CONTEXT_BEACON_PACKET;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (vnt_tx_context(priv, context, skb))\n\t\tieee80211_free_txskb(priv->hw, context->skb);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nint vnt_beacon_make(struct vnt_private *priv, struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *beacon;\n\n\tbeacon = ieee80211_beacon_get(priv->hw, vif, 0);\n\tif (!beacon)\n\t\treturn -ENOMEM;\n\n\tif (vnt_beacon_xmit(priv, beacon)) {\n\t\tieee80211_free_txskb(priv->hw, beacon);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nint vnt_beacon_enable(struct vnt_private *priv, struct ieee80211_vif *vif,\n\t\t      struct ieee80211_bss_conf *conf)\n{\n\tvnt_mac_reg_bits_off(priv, MAC_REG_TCR, TCR_AUTOBCNTX);\n\n\tvnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\n\n\tvnt_mac_set_beacon_interval(priv, conf->beacon_int);\n\n\tvnt_clear_current_tsf(priv);\n\n\tvnt_mac_reg_bits_on(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\n\n\tvnt_reset_next_tbtt(priv, conf->beacon_int);\n\n\treturn vnt_beacon_make(priv, vif);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}