{
  "module_name": "card.c",
  "hash_id": "43c9978849014540b5380aaf49b0001af450f69a9418b628a823b1316976eead",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vt6656/card.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include \"device.h\"\n#include \"card.h\"\n#include \"baseband.h\"\n#include \"mac.h\"\n#include \"desc.h\"\n#include \"rf.h\"\n#include \"power.h\"\n#include \"key.h\"\n#include \"usbpipe.h\"\n\n \n\nstatic const u16 cw_rxbcntsf_off[MAX_RATE] = {\n\t192, 96, 34, 17, 34, 23, 17, 11, 8, 5, 4, 3\n};\n\nint vnt_set_channel(struct vnt_private *priv, u32 connection_channel)\n{\n\tint ret;\n\n\tif (connection_channel > CB_MAX_CHANNEL || !connection_channel)\n\t\treturn -EINVAL;\n\n\t \n\tvnt_mac_reg_bits_on(priv, MAC_REG_MACCR, MACCR_CLRNAV);\n\n\t \n\tvnt_mac_reg_bits_off(priv, MAC_REG_CHANNEL,\n\t\t\t     (BIT(7) | BIT(5) | BIT(4)));\n\n\tret = vnt_control_out(priv, MESSAGE_TYPE_SELECT_CHANNEL,\n\t\t\t      connection_channel, 0, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vnt_control_out_u8(priv, MESSAGE_REQUEST_MACREG, MAC_REG_CHANNEL,\n\t\t\t\t  (u8)(connection_channel | 0x80));\n}\n\nstatic const u8 vnt_rspinf_b_short_table[] = {\n\t0x70, 0x00, 0x00, 0x00, 0x38, 0x00, 0x09, 0x00,\n\t0x15, 0x00, 0x0a, 0x00, 0x0b, 0x00, 0x0b, 0x80\n};\n\nstatic const u8 vnt_rspinf_b_long_table[] = {\n\t0x70, 0x00, 0x00, 0x00, 0x38, 0x00, 0x01, 0x00,\n\t0x15, 0x00, 0x02, 0x00, 0x0b, 0x00, 0x03, 0x80\n};\n\nstatic const u8 vnt_rspinf_a_table[] = {\n\t0x9b, 0x18, 0x9f, 0x10, 0x9a, 0x0a, 0x9e, 0x08, 0x99,\n\t0x08, 0x9d, 0x04, 0x98, 0x04, 0x9c, 0x04, 0x9c, 0x04\n};\n\nstatic const u8 vnt_rspinf_gb_table[] = {\n\t0x8b, 0x1e, 0x8f, 0x16, 0x8a, 0x12, 0x8e, 0x0e, 0x89,\n\t0x0e, 0x8d, 0x0a, 0x88, 0x0a, 0x8c, 0x0a, 0x8c, 0x0a\n};\n\nint vnt_set_rspinf(struct vnt_private *priv, u8 bb_type)\n{\n\tconst u8 *data;\n\tu16 len;\n\tint ret;\n\n\tif (priv->preamble_type) {\n\t\tdata = vnt_rspinf_b_short_table;\n\t\tlen = ARRAY_SIZE(vnt_rspinf_b_short_table);\n\t} else {\n\t\tdata = vnt_rspinf_b_long_table;\n\t\tlen = ARRAY_SIZE(vnt_rspinf_b_long_table);\n\t}\n\n\t  \n\tret = vnt_control_out(priv, MESSAGE_TYPE_WRITE, MAC_REG_RSPINF_B_1,\n\t\t\t      MESSAGE_REQUEST_MACREG, len, data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bb_type == BB_TYPE_11A) {\n\t\tdata = vnt_rspinf_a_table;\n\t\tlen = ARRAY_SIZE(vnt_rspinf_a_table);\n\t} else {\n\t\tdata = vnt_rspinf_gb_table;\n\t\tlen = ARRAY_SIZE(vnt_rspinf_gb_table);\n\t}\n\n\t \n\treturn vnt_control_out(priv, MESSAGE_TYPE_WRITE, MAC_REG_RSPINF_A_6,\n\t\t\t       MESSAGE_REQUEST_MACREG, len, data);\n}\n\nint vnt_update_ifs(struct vnt_private *priv)\n{\n\tu8 max_min = 0;\n\tu8 data[4];\n\tint ret;\n\n\tif (priv->packet_type == PK_TYPE_11A) {\n\t\tpriv->slot = C_SLOT_SHORT;\n\t\tpriv->sifs = C_SIFS_A;\n\t\tpriv->difs = C_SIFS_A + 2 * C_SLOT_SHORT;\n\t\tmax_min = 4;\n\t} else {\n\t\tpriv->sifs = C_SIFS_BG;\n\n\t\tif (priv->short_slot_time) {\n\t\t\tpriv->slot = C_SLOT_SHORT;\n\t\t\tmax_min = 4;\n\t\t} else {\n\t\t\tpriv->slot = C_SLOT_LONG;\n\t\t\tmax_min = 5;\n\t\t}\n\n\t\tpriv->difs = C_SIFS_BG + 2 * priv->slot;\n\t}\n\n\tpriv->eifs = C_EIFS;\n\n\tdata[0] = (u8)priv->sifs;\n\tdata[1] = (u8)priv->difs;\n\tdata[2] = (u8)priv->eifs;\n\tdata[3] = (u8)priv->slot;\n\n\tret = vnt_control_out(priv, MESSAGE_TYPE_WRITE, MAC_REG_SIFS,\n\t\t\t      MESSAGE_REQUEST_MACREG, 4, &data[0]);\n\tif (ret)\n\t\treturn ret;\n\n\tmax_min |= 0xa0;\n\n\treturn vnt_control_out(priv, MESSAGE_TYPE_WRITE, MAC_REG_CWMAXMIN0,\n\t\t\t       MESSAGE_REQUEST_MACREG, 1, &max_min);\n}\n\nvoid vnt_update_top_rates(struct vnt_private *priv)\n{\n\tint pos;\n\n\tpos = fls(priv->basic_rates & GENMASK(RATE_54M, RATE_6M));\n\tpriv->top_ofdm_basic_rate = pos ? (pos - 1) : RATE_24M;\n\n\tpos = fls(priv->basic_rates & GENMASK(RATE_11M, RATE_1M));\n\tpriv->top_cck_basic_rate = pos ? (pos - 1) : RATE_1M;\n}\n\nbool vnt_ofdm_min_rate(struct vnt_private *priv)\n{\n\treturn priv->basic_rates & GENMASK(RATE_54M, RATE_6M) ? true : false;\n}\n\nu8 vnt_get_pkt_type(struct vnt_private *priv)\n{\n\tif (priv->bb_type == BB_TYPE_11A || priv->bb_type == BB_TYPE_11B)\n\t\treturn (u8)priv->bb_type;\n\telse if (vnt_ofdm_min_rate(priv))\n\t\treturn PK_TYPE_11GA;\n\treturn PK_TYPE_11GB;\n}\n\n \nu64 vnt_get_tsf_offset(u8 rx_rate, u64 tsf1, u64 tsf2)\n{\n\treturn tsf1 - tsf2 - (u64)cw_rxbcntsf_off[rx_rate % MAX_RATE];\n}\n\nint vnt_adjust_tsf(struct vnt_private *priv, u8 rx_rate,\n\t\t   u64 time_stamp, u64 local_tsf)\n{\n\tu64 tsf_offset = 0;\n\tu8 data[8];\n\n\ttsf_offset = vnt_get_tsf_offset(rx_rate, time_stamp, local_tsf);\n\n\tdata[0] = (u8)tsf_offset;\n\tdata[1] = (u8)(tsf_offset >> 8);\n\tdata[2] = (u8)(tsf_offset >> 16);\n\tdata[3] = (u8)(tsf_offset >> 24);\n\tdata[4] = (u8)(tsf_offset >> 32);\n\tdata[5] = (u8)(tsf_offset >> 40);\n\tdata[6] = (u8)(tsf_offset >> 48);\n\tdata[7] = (u8)(tsf_offset >> 56);\n\n\treturn vnt_control_out(priv, MESSAGE_TYPE_SET_TSFTBTT,\n\t\t\t       MESSAGE_REQUEST_TSF, 0, 8, data);\n}\n\n \nbool vnt_clear_current_tsf(struct vnt_private *priv)\n{\n\tvnt_mac_reg_bits_on(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);\n\n\tpriv->current_tsf = 0;\n\n\treturn true;\n}\n\n \nu64 vnt_get_next_tbtt(u64 tsf, u16 beacon_interval)\n{\n\tu32 beacon_int;\n\n\tbeacon_int = beacon_interval * 1024;\n\n\t \n\tif (beacon_int) {\n\t\tdo_div(tsf, beacon_int);\n\t\ttsf += 1;\n\t\ttsf *= beacon_int;\n\t}\n\n\treturn tsf;\n}\n\nint vnt_reset_next_tbtt(struct vnt_private *priv, u16 beacon_interval)\n{\n\tu64 next_tbtt = 0;\n\tu8 data[8];\n\n\tvnt_clear_current_tsf(priv);\n\n\tnext_tbtt = vnt_get_next_tbtt(next_tbtt, beacon_interval);\n\n\tdata[0] = (u8)next_tbtt;\n\tdata[1] = (u8)(next_tbtt >> 8);\n\tdata[2] = (u8)(next_tbtt >> 16);\n\tdata[3] = (u8)(next_tbtt >> 24);\n\tdata[4] = (u8)(next_tbtt >> 32);\n\tdata[5] = (u8)(next_tbtt >> 40);\n\tdata[6] = (u8)(next_tbtt >> 48);\n\tdata[7] = (u8)(next_tbtt >> 56);\n\n\treturn vnt_control_out(priv, MESSAGE_TYPE_SET_TSFTBTT,\n\t\t\t       MESSAGE_REQUEST_TBTT, 0, 8, data);\n}\n\nint vnt_update_next_tbtt(struct vnt_private *priv, u64 tsf,\n\t\t\t u16 beacon_interval)\n{\n\tu8 data[8];\n\tint ret;\n\n\ttsf = vnt_get_next_tbtt(tsf, beacon_interval);\n\n\tdata[0] = (u8)tsf;\n\tdata[1] = (u8)(tsf >> 8);\n\tdata[2] = (u8)(tsf >> 16);\n\tdata[3] = (u8)(tsf >> 24);\n\tdata[4] = (u8)(tsf >> 32);\n\tdata[5] = (u8)(tsf >> 40);\n\tdata[6] = (u8)(tsf >> 48);\n\tdata[7] = (u8)(tsf >> 56);\n\n\tret = vnt_control_out(priv, MESSAGE_TYPE_SET_TSFTBTT,\n\t\t\t      MESSAGE_REQUEST_TBTT, 0, 8, data);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(&priv->usb->dev, \"%s TBTT: %8llx\\n\", __func__, tsf);\n\treturn 0;\n}\n\n \nint vnt_radio_power_off(struct vnt_private *priv)\n{\n\tint ret = 0;\n\n\tswitch (priv->rf_type) {\n\tcase RF_AL2230:\n\tcase RF_AL2230S:\n\tcase RF_VT3226:\n\tcase RF_VT3226D0:\n\t\tret = vnt_mac_reg_bits_off(priv, MAC_REG_SOFTPWRCTL,\n\t\t\t\t\t   (SOFTPWRCTL_SWPE2 |\n\t\t\t\t\t    SOFTPWRCTL_SWPE3));\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tgoto end;\n\n\tret = vnt_mac_reg_bits_off(priv, MAC_REG_HOSTCR, HOSTCR_RXON);\n\tif (ret)\n\t\tgoto end;\n\n\tret = vnt_set_deep_sleep(priv);\n\tif (ret)\n\t\tgoto end;\n\n\tret = vnt_mac_reg_bits_on(priv, MAC_REG_GPIOCTL1, GPIO3_INTMD);\n\nend:\n\treturn ret;\n}\n\n \nint vnt_radio_power_on(struct vnt_private *priv)\n{\n\tint ret = 0;\n\n\tret = vnt_exit_deep_sleep(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vnt_mac_reg_bits_on(priv, MAC_REG_HOSTCR, HOSTCR_RXON);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (priv->rf_type) {\n\tcase RF_AL2230:\n\tcase RF_AL2230S:\n\tcase RF_VT3226:\n\tcase RF_VT3226D0:\n\t\tret = vnt_mac_reg_bits_on(priv, MAC_REG_SOFTPWRCTL,\n\t\t\t\t\t  (SOFTPWRCTL_SWPE2 |\n\t\t\t\t\t   SOFTPWRCTL_SWPE3));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn vnt_mac_reg_bits_off(priv, MAC_REG_GPIOCTL1, GPIO3_INTMD);\n}\n\nint vnt_set_bss_mode(struct vnt_private *priv)\n{\n\tint ret;\n\tunsigned char type = priv->bb_type;\n\tunsigned char data = 0;\n\tunsigned char bb_vga_2_3 = 0x00;\n\n\tret = vnt_mac_set_bb_type(priv, type);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->packet_type = vnt_get_pkt_type(priv);\n\n\tif (priv->bb_type == BB_TYPE_11A) {\n\t\tdata = 0x03;\n\t\tbb_vga_2_3 = 0x10;\n\t} else if (priv->bb_type == BB_TYPE_11B) {\n\t\tdata = 0x02;\n\t} else if (priv->bb_type == BB_TYPE_11G) {\n\t\tdata = 0x08;\n\t}\n\n\tif (data) {\n\t\tret = vnt_control_out_u8(priv, MESSAGE_REQUEST_BBREG,\n\t\t\t\t\t 0x88, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = vnt_update_ifs(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vnt_set_rspinf(priv, priv->bb_type);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->bb_vga[2] = bb_vga_2_3;\n\tpriv->bb_vga[3] = bb_vga_2_3;\n\n\treturn vnt_set_vga_gain_offset(priv, priv->bb_vga[0]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}