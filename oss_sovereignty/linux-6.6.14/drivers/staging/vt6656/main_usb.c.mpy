{
  "module_name": "main_usb.c",
  "hash_id": "1118a4bf9be7411418473762b7e61452ebca8ab9aa7bb35c3d57d0e13c2a7e75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vt6656/main_usb.c",
  "human_readable_source": "\n \n#undef __NO_VERSION__\n\n#include <linux/bits.h>\n#include <linux/etherdevice.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include \"device.h\"\n#include \"card.h\"\n#include \"baseband.h\"\n#include \"mac.h\"\n#include \"power.h\"\n#include \"wcmd.h\"\n#include \"rxtx.h\"\n#include \"rf.h\"\n#include \"usbpipe.h\"\n#include \"channel.h\"\n\n \n\n \n#define DRIVER_AUTHOR \\\n\t\"VIA Networking Technologies, Inc., <lyndonchen@vntek.com.tw>\"\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(DEVICE_FULL_DRV_NAM);\n\n#define RX_DESC_DEF0 64\nstatic int vnt_rx_buffers = RX_DESC_DEF0;\nmodule_param_named(rx_buffers, vnt_rx_buffers, int, 0644);\nMODULE_PARM_DESC(rx_buffers, \"Number of receive usb rx buffers\");\n\n#define TX_DESC_DEF0 64\nstatic int vnt_tx_buffers = TX_DESC_DEF0;\nmodule_param_named(tx_buffers, vnt_tx_buffers, int, 0644);\nMODULE_PARM_DESC(tx_buffers, \"Number of receive usb tx buffers\");\n\n#define RTS_THRESH_DEF     2347\n#define FRAG_THRESH_DEF     2346\n\n \n\n#define BBP_TYPE_DEF     2\n\n \n\nstatic const struct usb_device_id vt6656_table[] = {\n\t{USB_DEVICE(VNT_USB_VENDOR_ID, VNT_USB_PRODUCT_ID)},\n\t{}\n};\n\nstatic void vnt_set_options(struct vnt_private *priv)\n{\n\t \n\tif (vnt_tx_buffers < CB_MIN_TX_DESC || vnt_tx_buffers > CB_MAX_TX_DESC)\n\t\tpriv->num_tx_context = TX_DESC_DEF0;\n\telse\n\t\tpriv->num_tx_context = vnt_tx_buffers;\n\n\t \n\tif (vnt_rx_buffers < CB_MIN_RX_DESC || vnt_rx_buffers > CB_MAX_RX_DESC)\n\t\tpriv->num_rcb = RX_DESC_DEF0;\n\telse\n\t\tpriv->num_rcb = vnt_rx_buffers;\n\n\tpriv->op_mode = NL80211_IFTYPE_UNSPECIFIED;\n\tpriv->bb_type = BBP_TYPE_DEF;\n\tpriv->packet_type = priv->bb_type;\n\tpriv->preamble_type = PREAMBLE_LONG;\n\tpriv->exist_sw_net_addr = false;\n}\n\nstatic int vnt_download_firmware(struct vnt_private *priv)\n{\n\tstruct device *dev = &priv->usb->dev;\n\tconst struct firmware *fw;\n\tu16 length;\n\tint ii;\n\tint ret = 0;\n\n\tdev_dbg(dev, \"---->Download firmware\\n\");\n\n\tret = request_firmware(&fw, FIRMWARE_NAME, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"firmware file %s request failed (%d)\\n\",\n\t\t\tFIRMWARE_NAME, ret);\n\t\tgoto end;\n\t}\n\n\tfor (ii = 0; ii < fw->size; ii += FIRMWARE_CHUNK_SIZE) {\n\t\tlength = min_t(int, fw->size - ii, FIRMWARE_CHUNK_SIZE);\n\n\t\tret = vnt_control_out(priv, 0, 0x1200 + ii, 0x0000, length,\n\t\t\t\t      fw->data + ii);\n\t\tif (ret)\n\t\t\tgoto free_fw;\n\n\t\tdev_dbg(dev, \"Download firmware...%d %zu\\n\", ii, fw->size);\n\t}\n\nfree_fw:\n\trelease_firmware(fw);\nend:\n\treturn ret;\n}\n\nstatic int vnt_firmware_branch_to_sram(struct vnt_private *priv)\n{\n\tdev_dbg(&priv->usb->dev, \"---->Branch to Sram\\n\");\n\n\treturn vnt_control_out(priv, 1, 0x1200, 0x0000, 0, NULL);\n}\n\nstatic int vnt_check_firmware_version(struct vnt_private *priv)\n{\n\tint ret = 0;\n\n\tret = vnt_control_in(priv, MESSAGE_TYPE_READ, 0,\n\t\t\t     MESSAGE_REQUEST_VERSION, 2,\n\t\t\t     (u8 *)&priv->firmware_version);\n\tif (ret) {\n\t\tdev_dbg(&priv->usb->dev,\n\t\t\t\"Could not get firmware version: %d.\\n\", ret);\n\t\tgoto end;\n\t}\n\n\tdev_dbg(&priv->usb->dev, \"Firmware Version [%04x]\\n\",\n\t\tpriv->firmware_version);\n\n\tif (priv->firmware_version == 0xFFFF) {\n\t\tdev_dbg(&priv->usb->dev, \"In Loader.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tif (priv->firmware_version < FIRMWARE_VERSION) {\n\t\t \n\t\tret = vnt_firmware_branch_to_sram(priv);\n\t\tif (ret) {\n\t\t\tdev_dbg(&priv->usb->dev,\n\t\t\t\t\"Could not branch to SRAM: %d.\\n\", ret);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\nend:\n\treturn ret;\n}\n\n \nstatic int vnt_init_registers(struct vnt_private *priv)\n{\n\tint ret;\n\tstruct vnt_cmd_card_init *init_cmd = &priv->init_command;\n\tstruct vnt_rsp_card_init *init_rsp = &priv->init_response;\n\tu8 antenna;\n\tint ii;\n\tu8 tmp;\n\tu8 calib_tx_iq = 0, calib_tx_dc = 0, calib_rx_iq = 0;\n\n\tdev_dbg(&priv->usb->dev, \"---->INIbInitAdapter. [%d][%d]\\n\",\n\t\tDEVICE_INIT_COLD, priv->packet_type);\n\n\tret = vnt_check_firmware_version(priv);\n\tif (ret) {\n\t\tret = vnt_download_firmware(priv);\n\t\tif (ret) {\n\t\t\tdev_dbg(&priv->usb->dev,\n\t\t\t\t\"Could not download firmware: %d.\\n\", ret);\n\t\t\tgoto end;\n\t\t}\n\n\t\tret = vnt_firmware_branch_to_sram(priv);\n\t\tif (ret) {\n\t\t\tdev_dbg(&priv->usb->dev,\n\t\t\t\t\"Could not branch to SRAM: %d.\\n\", ret);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tret = vnt_vt3184_init(priv);\n\tif (ret) {\n\t\tdev_dbg(&priv->usb->dev, \"vnt_vt3184_init fail\\n\");\n\t\tgoto end;\n\t}\n\n\tinit_cmd->init_class = DEVICE_INIT_COLD;\n\tinit_cmd->exist_sw_net_addr = priv->exist_sw_net_addr;\n\tfor (ii = 0; ii < ARRAY_SIZE(init_cmd->sw_net_addr); ii++)\n\t\tinit_cmd->sw_net_addr[ii] = priv->current_net_addr[ii];\n\tinit_cmd->short_retry_limit = priv->hw->wiphy->retry_short;\n\tinit_cmd->long_retry_limit = priv->hw->wiphy->retry_long;\n\n\t \n\tret = vnt_control_out(priv, MESSAGE_TYPE_CARDINIT, 0, 0,\n\t\t\t      sizeof(struct vnt_cmd_card_init),\n\t\t\t      (u8 *)init_cmd);\n\tif (ret) {\n\t\tdev_dbg(&priv->usb->dev, \"Issue Card init fail\\n\");\n\t\tgoto end;\n\t}\n\n\tret = vnt_control_in(priv, MESSAGE_TYPE_INIT_RSP, 0, 0,\n\t\t\t     sizeof(struct vnt_rsp_card_init),\n\t\t\t     (u8 *)init_rsp);\n\tif (ret) {\n\t\tdev_dbg(&priv->usb->dev, \"Cardinit request in status fail!\\n\");\n\t\tgoto end;\n\t}\n\n\t \n\tret = vnt_control_in(priv, MESSAGE_TYPE_READ, MAC_REG_LOCALID,\n\t\t\t     MESSAGE_REQUEST_MACREG, 1, &priv->local_id);\n\tif (ret)\n\t\tgoto end;\n\n\t \n\n\tpriv->top_ofdm_basic_rate = RATE_24M;\n\tpriv->top_cck_basic_rate = RATE_1M;\n\n\t \n\tpriv->power = 0xFF;\n\n\tpriv->cck_pwr = priv->eeprom[EEP_OFS_PWR_CCK];\n\tpriv->ofdm_pwr_g = priv->eeprom[EEP_OFS_PWR_OFDMG];\n\t \n\tfor (ii = 0; ii < ARRAY_SIZE(priv->cck_pwr_tbl); ii++) {\n\t\tpriv->cck_pwr_tbl[ii] =\n\t\t\tpriv->eeprom[ii + EEP_OFS_CCK_PWR_TBL];\n\t\tif (priv->cck_pwr_tbl[ii] == 0)\n\t\t\tpriv->cck_pwr_tbl[ii] = priv->cck_pwr;\n\n\t\tpriv->ofdm_pwr_tbl[ii] =\n\t\t\t\tpriv->eeprom[ii + EEP_OFS_OFDM_PWR_TBL];\n\t\tif (priv->ofdm_pwr_tbl[ii] == 0)\n\t\t\tpriv->ofdm_pwr_tbl[ii] = priv->ofdm_pwr_g;\n\t}\n\n\t \n\tfor (ii = 11; ii < ARRAY_SIZE(priv->cck_pwr_tbl); ii++) {\n\t\tpriv->cck_pwr_tbl[ii] = priv->cck_pwr_tbl[10];\n\t\tpriv->ofdm_pwr_tbl[ii] = priv->ofdm_pwr_tbl[10];\n\t}\n\n\tpriv->ofdm_pwr_a = 0x34;  \n\n\t \n\tfor (ii = 0; ii < CB_MAX_CHANNEL_5G; ii++) {\n\t\tpriv->ofdm_a_pwr_tbl[ii] =\n\t\t\tpriv->eeprom[ii + EEP_OFS_OFDMA_PWR_TBL];\n\n\t\tif (priv->ofdm_a_pwr_tbl[ii] == 0)\n\t\t\tpriv->ofdm_a_pwr_tbl[ii] = priv->ofdm_pwr_a;\n\t}\n\n\tantenna = priv->eeprom[EEP_OFS_ANTENNA];\n\n\tif (antenna & EEP_ANTINV)\n\t\tpriv->tx_rx_ant_inv = true;\n\telse\n\t\tpriv->tx_rx_ant_inv = false;\n\n\tantenna &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\n\n\tif (antenna == 0)  \n\t\tantenna = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\n\n\tif (antenna == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {\n\t\tpriv->tx_antenna_mode = ANT_B;\n\t\tpriv->rx_antenna_sel = 1;\n\n\t\tif (priv->tx_rx_ant_inv)\n\t\t\tpriv->rx_antenna_mode = ANT_A;\n\t\telse\n\t\t\tpriv->rx_antenna_mode = ANT_B;\n\t} else  {\n\t\tpriv->rx_antenna_sel = 0;\n\n\t\tif (antenna & EEP_ANTENNA_AUX) {\n\t\t\tpriv->tx_antenna_mode = ANT_A;\n\n\t\t\tif (priv->tx_rx_ant_inv)\n\t\t\t\tpriv->rx_antenna_mode = ANT_B;\n\t\t\telse\n\t\t\t\tpriv->rx_antenna_mode = ANT_A;\n\t\t} else {\n\t\t\tpriv->tx_antenna_mode = ANT_B;\n\n\t\t\tif (priv->tx_rx_ant_inv)\n\t\t\t\tpriv->rx_antenna_mode = ANT_A;\n\t\t\telse\n\t\t\t\tpriv->rx_antenna_mode = ANT_B;\n\t\t}\n\t}\n\n\t \n\tret = vnt_set_antenna_mode(priv, priv->rx_antenna_mode);\n\tif (ret)\n\t\tgoto end;\n\n\t \n\tpriv->bb_type = BB_TYPE_11G;\n\n\t \n\tpriv->rf_type = init_rsp->rf_type;\n\n\t \n\tif (priv->rf_type == RF_VT3226D0) {\n\t\tif ((priv->eeprom[EEP_OFS_MAJOR_VER] == 0x1) &&\n\t\t    (priv->eeprom[EEP_OFS_MINOR_VER] >= 0x4)) {\n\t\t\tcalib_tx_iq = priv->eeprom[EEP_OFS_CALIB_TX_IQ];\n\t\t\tcalib_tx_dc = priv->eeprom[EEP_OFS_CALIB_TX_DC];\n\t\t\tcalib_rx_iq = priv->eeprom[EEP_OFS_CALIB_RX_IQ];\n\t\t\tif (calib_tx_iq || calib_tx_dc || calib_rx_iq) {\n\t\t\t\t \n\t\t\t\tret = vnt_control_out_u8(priv,\n\t\t\t\t\t\t\t MESSAGE_REQUEST_BBREG,\n\t\t\t\t\t\t\t 0xff, 0x03);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto end;\n\n\t\t\t\t \n\t\t\t\tret = vnt_control_out_u8(priv,\n\t\t\t\t\t\t\t MESSAGE_REQUEST_BBREG,\n\t\t\t\t\t\t\t 0xfb, calib_tx_iq);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto end;\n\n\t\t\t\t \n\t\t\t\tret = vnt_control_out_u8(priv,\n\t\t\t\t\t\t\t MESSAGE_REQUEST_BBREG,\n\t\t\t\t\t\t\t 0xfC, calib_tx_dc);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto end;\n\n\t\t\t\t \n\t\t\t\tret = vnt_control_out_u8(priv,\n\t\t\t\t\t\t\t MESSAGE_REQUEST_BBREG,\n\t\t\t\t\t\t\t 0xfd, calib_rx_iq);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto end;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tret = vnt_control_out_u8(priv,\n\t\t\t\t\t\t\t MESSAGE_REQUEST_BBREG,\n\t\t\t\t\t\t\t 0xff, 0x0);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tmemcpy(priv->permanent_net_addr, init_rsp->net_addr, 6);\n\tether_addr_copy(priv->current_net_addr, priv->permanent_net_addr);\n\n\t \n\tdev_dbg(&priv->usb->dev, \"Network address = %pM\\n\",\n\t\tpriv->current_net_addr);\n\n\tpriv->radio_ctl = priv->eeprom[EEP_OFS_RADIOCTL];\n\n\tif ((priv->radio_ctl & EEP_RADIOCTL_ENABLE) != 0) {\n\t\tret = vnt_control_in(priv, MESSAGE_TYPE_READ,\n\t\t\t\t     MAC_REG_GPIOCTL1, MESSAGE_REQUEST_MACREG,\n\t\t\t\t     1, &tmp);\n\t\tif (ret)\n\t\t\tgoto end;\n\n\t\tif ((tmp & GPIO3_DATA) == 0) {\n\t\t\tret = vnt_mac_reg_bits_on(priv, MAC_REG_GPIOCTL1,\n\t\t\t\t\t\t  GPIO3_INTMD);\n\t\t} else {\n\t\t\tret = vnt_mac_reg_bits_off(priv, MAC_REG_GPIOCTL1,\n\t\t\t\t\t\t   GPIO3_INTMD);\n\t\t}\n\n\t\tif (ret)\n\t\t\tgoto end;\n\t}\n\n\tret = vnt_mac_set_led(priv, LEDSTS_TMLEN, 0x38);\n\tif (ret)\n\t\tgoto end;\n\n\tret = vnt_mac_set_led(priv, LEDSTS_STS, LEDSTS_SLOW);\n\tif (ret)\n\t\tgoto end;\n\n\tret = vnt_mac_reg_bits_on(priv, MAC_REG_GPIOCTL0, BIT(0));\n\tif (ret)\n\t\tgoto end;\n\n\tret = vnt_radio_power_on(priv);\n\tif (ret)\n\t\tgoto end;\n\n\tdev_dbg(&priv->usb->dev, \"<----INIbInitAdapter Exit\\n\");\n\nend:\n\treturn ret;\n}\n\nstatic void vnt_free_tx_bufs(struct vnt_private *priv)\n{\n\tstruct vnt_usb_send_context *tx_context;\n\tint ii;\n\n\tusb_kill_anchored_urbs(&priv->tx_submitted);\n\n\tfor (ii = 0; ii < priv->num_tx_context; ii++) {\n\t\ttx_context = priv->tx_context[ii];\n\t\tif (!tx_context)\n\t\t\tcontinue;\n\n\t\tkfree(tx_context);\n\t}\n}\n\nstatic void vnt_free_rx_bufs(struct vnt_private *priv)\n{\n\tstruct vnt_rcb *rcb;\n\tint ii;\n\n\tfor (ii = 0; ii < priv->num_rcb; ii++) {\n\t\trcb = priv->rcb[ii];\n\t\tif (!rcb)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (rcb->urb) {\n\t\t\tusb_kill_urb(rcb->urb);\n\t\t\tusb_free_urb(rcb->urb);\n\t\t}\n\n\t\t \n\t\tif (rcb->skb)\n\t\t\tdev_kfree_skb(rcb->skb);\n\n\t\tkfree(rcb);\n\t}\n}\n\nstatic void vnt_free_int_bufs(struct vnt_private *priv)\n{\n\tkfree(priv->int_buf.data_buf);\n}\n\nstatic int vnt_alloc_bufs(struct vnt_private *priv)\n{\n\tint ret;\n\tstruct vnt_usb_send_context *tx_context;\n\tstruct vnt_rcb *rcb;\n\tint ii;\n\n\tinit_usb_anchor(&priv->tx_submitted);\n\n\tfor (ii = 0; ii < priv->num_tx_context; ii++) {\n\t\ttx_context = kmalloc(sizeof(*tx_context), GFP_KERNEL);\n\t\tif (!tx_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tx;\n\t\t}\n\n\t\tpriv->tx_context[ii] = tx_context;\n\t\ttx_context->priv = priv;\n\t\ttx_context->pkt_no = ii;\n\t\ttx_context->in_use = false;\n\t}\n\n\tfor (ii = 0; ii < priv->num_rcb; ii++) {\n\t\tpriv->rcb[ii] = kzalloc(sizeof(*priv->rcb[ii]), GFP_KERNEL);\n\t\tif (!priv->rcb[ii]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_rx_tx;\n\t\t}\n\n\t\trcb = priv->rcb[ii];\n\n\t\trcb->priv = priv;\n\n\t\t \n\t\trcb->urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!rcb->urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_rx_tx;\n\t\t}\n\n\t\trcb->skb = dev_alloc_skb(priv->rx_buf_sz);\n\t\tif (!rcb->skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_rx_tx;\n\t\t}\n\t\t \n\t\tret = vnt_submit_rx_urb(priv, rcb);\n\t\tif (ret)\n\t\t\tgoto free_rx_tx;\n\t}\n\n\tpriv->interrupt_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!priv->interrupt_urb) {\n\t\tret = -ENOMEM;\n\t\tgoto free_rx_tx;\n\t}\n\n\tpriv->int_buf.data_buf = kmalloc(MAX_INTERRUPT_SIZE, GFP_KERNEL);\n\tif (!priv->int_buf.data_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto free_rx_tx_urb;\n\t}\n\n\treturn 0;\n\nfree_rx_tx_urb:\n\tusb_free_urb(priv->interrupt_urb);\nfree_rx_tx:\n\tvnt_free_rx_bufs(priv);\nfree_tx:\n\tvnt_free_tx_bufs(priv);\n\treturn ret;\n}\n\nstatic void vnt_tx_80211(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_tx_control *control,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tif (vnt_tx_packet(priv, skb))\n\t\tieee80211_free_txskb(hw, skb);\n}\n\nstatic int vnt_start(struct ieee80211_hw *hw)\n{\n\tint ret;\n\tstruct vnt_private *priv = hw->priv;\n\n\tpriv->rx_buf_sz = MAX_TOTAL_SIZE_WITH_ALL_HEADERS;\n\n\tret = vnt_alloc_bufs(priv);\n\tif (ret) {\n\t\tdev_dbg(&priv->usb->dev, \"vnt_alloc_bufs fail...\\n\");\n\t\tgoto err;\n\t}\n\n\tclear_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags);\n\n\tret = vnt_init_registers(priv);\n\tif (ret) {\n\t\tdev_dbg(&priv->usb->dev, \" init register fail\\n\");\n\t\tgoto free_all;\n\t}\n\n\tret = vnt_key_init_table(priv);\n\tif (ret)\n\t\tgoto free_all;\n\n\tpriv->int_interval = 1;   \n\n\tret = vnt_start_interrupt_urb(priv);\n\tif (ret)\n\t\tgoto free_all;\n\n\tieee80211_wake_queues(hw);\n\n\treturn 0;\n\nfree_all:\n\tvnt_free_rx_bufs(priv);\n\tvnt_free_tx_bufs(priv);\n\tvnt_free_int_bufs(priv);\n\n\tusb_kill_urb(priv->interrupt_urb);\n\tusb_free_urb(priv->interrupt_urb);\nerr:\n\treturn ret;\n}\n\nstatic void vnt_stop(struct ieee80211_hw *hw)\n{\n\tstruct vnt_private *priv = hw->priv;\n\tint i;\n\n\tif (!priv)\n\t\treturn;\n\n\tfor (i = 0; i < MAX_KEY_TABLE; i++)\n\t\tvnt_mac_disable_keyentry(priv, i);\n\n\t \n\tpriv->key_entry_inuse = 0;\n\n\tif (!test_bit(DEVICE_FLAGS_UNPLUG, &priv->flags))\n\t\tvnt_mac_shutdown(priv);\n\n\tieee80211_stop_queues(hw);\n\n\tset_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags);\n\n\tcancel_delayed_work_sync(&priv->run_command_work);\n\n\tpriv->cmd_running = false;\n\n\tvnt_free_tx_bufs(priv);\n\tvnt_free_rx_bufs(priv);\n\tvnt_free_int_bufs(priv);\n\n\tusb_kill_urb(priv->interrupt_urb);\n\tusb_free_urb(priv->interrupt_urb);\n}\n\nstatic int vnt_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tpriv->vif = vif;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tvnt_mac_reg_bits_off(priv, MAC_REG_RCR, RCR_UNICAST);\n\n\t\tvnt_mac_reg_bits_on(priv, MAC_REG_HOSTCR, HOSTCR_ADHOC);\n\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tvnt_mac_reg_bits_off(priv, MAC_REG_RCR, RCR_UNICAST);\n\n\t\tvnt_mac_reg_bits_on(priv, MAC_REG_HOSTCR, HOSTCR_AP);\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->op_mode = vif->type;\n\n\t \n\tvnt_mac_set_led(priv, LEDSTS_STS, LEDSTS_INTER);\n\n\treturn 0;\n}\n\nstatic void vnt_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tvnt_mac_reg_bits_off(priv, MAC_REG_TCR, TCR_AUTOBCNTX);\n\t\tvnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\n\t\tvnt_mac_reg_bits_off(priv, MAC_REG_HOSTCR, HOSTCR_ADHOC);\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tvnt_mac_reg_bits_off(priv, MAC_REG_TCR, TCR_AUTOBCNTX);\n\t\tvnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\n\t\tvnt_mac_reg_bits_off(priv, MAC_REG_HOSTCR, HOSTCR_AP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tvnt_radio_power_off(priv);\n\n\tpriv->op_mode = NL80211_IFTYPE_UNSPECIFIED;\n\n\t \n\tvnt_mac_set_led(priv, LEDSTS_STS, LEDSTS_SLOW);\n}\n\nstatic int vnt_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct vnt_private *priv = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\n\tif (changed & IEEE80211_CONF_CHANGE_PS) {\n\t\tif (conf->flags & IEEE80211_CONF_PS)\n\t\t\tvnt_enable_power_saving(priv, conf->listen_interval);\n\t\telse\n\t\t\tvnt_disable_power_saving(priv);\n\t}\n\n\tif ((changed & IEEE80211_CONF_CHANGE_CHANNEL) ||\n\t    (conf->flags & IEEE80211_CONF_OFFCHANNEL)) {\n\t\tvnt_set_channel(priv, conf->chandef.chan->hw_value);\n\n\t\tif (conf->chandef.chan->band == NL80211_BAND_5GHZ)\n\t\t\tpriv->bb_type = BB_TYPE_11A;\n\t\telse\n\t\t\tpriv->bb_type = BB_TYPE_11G;\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_POWER)\n\t\tvnt_rf_setpower(priv, conf->chandef.chan);\n\n\tif (conf->flags & (IEEE80211_CONF_OFFCHANNEL | IEEE80211_CONF_IDLE))\n\t\t \n\t\tvnt_update_pre_ed_threshold(priv, true);\n\telse\n\t\tvnt_update_pre_ed_threshold(priv, false);\n\n\treturn 0;\n}\n\nstatic void vnt_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *conf, u64 changed)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tpriv->current_aid = vif->cfg.aid;\n\n\tif (changed & BSS_CHANGED_BSSID && conf->bssid)\n\t\tvnt_mac_set_bssid_addr(priv, (u8 *)conf->bssid);\n\n\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\tpriv->basic_rates = conf->basic_rates;\n\n\t\tvnt_update_top_rates(priv);\n\n\t\tdev_dbg(&priv->usb->dev, \"basic rates %x\\n\", conf->basic_rates);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\tif (conf->use_short_preamble) {\n\t\t\tvnt_mac_enable_barker_preamble_mode(priv);\n\t\t\tpriv->preamble_type = PREAMBLE_SHORT;\n\t\t} else {\n\t\t\tvnt_mac_disable_barker_preamble_mode(priv);\n\t\t\tpriv->preamble_type = PREAMBLE_LONG;\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT) {\n\t\tif (conf->use_cts_prot)\n\t\t\tvnt_mac_enable_protect_mode(priv);\n\t\telse\n\t\t\tvnt_mac_disable_protect_mode(priv);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tif (conf->use_short_slot)\n\t\t\tpriv->short_slot_time = true;\n\t\telse\n\t\t\tpriv->short_slot_time = false;\n\n\t\tvnt_set_short_slot_time(priv);\n\t\tvnt_set_vga_gain_offset(priv, priv->bb_vga[0]);\n\t}\n\n\tif (changed & (BSS_CHANGED_BASIC_RATES | BSS_CHANGED_ERP_PREAMBLE |\n\t\t       BSS_CHANGED_ERP_SLOT))\n\t\tvnt_set_bss_mode(priv);\n\n\tif (changed & (BSS_CHANGED_TXPOWER | BSS_CHANGED_BANDWIDTH))\n\t\tvnt_rf_setpower(priv, conf->chandef.chan);\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED) {\n\t\tdev_dbg(&priv->usb->dev,\n\t\t\t\"Beacon enable %d\\n\", conf->enable_beacon);\n\n\t\tif (conf->enable_beacon) {\n\t\t\tvnt_beacon_enable(priv, vif, conf);\n\n\t\t\tvnt_mac_reg_bits_on(priv, MAC_REG_TCR, TCR_AUTOBCNTX);\n\t\t} else {\n\t\t\tvnt_mac_reg_bits_off(priv, MAC_REG_TCR, TCR_AUTOBCNTX);\n\t\t}\n\t}\n\n\tif (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_BEACON_INFO) &&\n\t    priv->op_mode != NL80211_IFTYPE_AP) {\n\t\tif (vif->cfg.assoc && conf->beacon_rate) {\n\t\t\tu16 ps_beacon_int = conf->beacon_int;\n\n\t\t\tif (conf->dtim_period)\n\t\t\t\tps_beacon_int *= conf->dtim_period;\n\t\t\telse if (hw->conf.listen_interval)\n\t\t\t\tps_beacon_int *= hw->conf.listen_interval;\n\n\t\t\tvnt_mac_reg_bits_on(priv, MAC_REG_TFTCTL,\n\t\t\t\t\t    TFTCTL_TSFCNTREN);\n\n\t\t\tvnt_mac_set_beacon_interval(priv, ps_beacon_int);\n\n\t\t\tvnt_reset_next_tbtt(priv, conf->beacon_int);\n\n\t\t\tvnt_adjust_tsf(priv, conf->beacon_rate->hw_value,\n\t\t\t\t       conf->sync_tsf, priv->current_tsf);\n\n\t\t\tvnt_update_next_tbtt(priv,\n\t\t\t\t\t     conf->sync_tsf, ps_beacon_int);\n\t\t} else {\n\t\t\tvnt_clear_current_tsf(priv);\n\n\t\t\tvnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL,\n\t\t\t\t\t     TFTCTL_TSFCNTREN);\n\t\t}\n\t}\n}\n\nstatic u64 vnt_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\t\t struct netdev_hw_addr_list *mc_list)\n{\n\tstruct vnt_private *priv = hw->priv;\n\tstruct netdev_hw_addr *ha;\n\tu64 mc_filter = 0;\n\tu32 bit_nr;\n\n\tnetdev_hw_addr_list_for_each(ha, mc_list) {\n\t\tbit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\t\tmc_filter |= BIT_ULL(bit_nr);\n\t}\n\n\tpriv->mc_list_count = mc_list->count;\n\n\treturn mc_filter;\n}\n\nstatic void vnt_configure(struct ieee80211_hw *hw,\n\t\t\t  unsigned int changed_flags,\n\t\t\t  unsigned int *total_flags, u64 multicast)\n{\n\tstruct vnt_private *priv = hw->priv;\n\tu8 rx_mode = 0;\n\n\t*total_flags &= FIF_ALLMULTI | FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC;\n\n\tvnt_control_in(priv, MESSAGE_TYPE_READ, MAC_REG_RCR,\n\t\t       MESSAGE_REQUEST_MACREG, sizeof(u8), &rx_mode);\n\n\tdev_dbg(&priv->usb->dev, \"rx mode in = %x\\n\", rx_mode);\n\n\tif (changed_flags & FIF_ALLMULTI) {\n\t\tif (*total_flags & FIF_ALLMULTI) {\n\t\t\tif (priv->mc_list_count > 2)\n\t\t\t\tvnt_mac_set_filter(priv, ~0);\n\t\t\telse\n\t\t\t\tvnt_mac_set_filter(priv, multicast);\n\n\t\t\trx_mode |= RCR_MULTICAST | RCR_BROADCAST;\n\t\t} else {\n\t\t\trx_mode &= ~(RCR_MULTICAST | RCR_BROADCAST);\n\t\t}\n\t}\n\n\tif (changed_flags & (FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC)) {\n\t\tif (*total_flags & (FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC))\n\t\t\trx_mode &= ~RCR_BSSID;\n\t\telse\n\t\t\trx_mode |= RCR_BSSID;\n\t}\n\n\tvnt_control_out_u8(priv, MESSAGE_REQUEST_MACREG, MAC_REG_RCR, rx_mode);\n\n\tdev_dbg(&priv->usb->dev, \"rx mode out= %x\\n\", rx_mode);\n}\n\nstatic int vnt_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t       struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t       struct ieee80211_key_conf *key)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\treturn vnt_set_keys(hw, sta, vif, key);\n\tcase DISABLE_KEY:\n\t\tif (test_bit(key->hw_key_idx, &priv->key_entry_inuse)) {\n\t\t\tclear_bit(key->hw_key_idx, &priv->key_entry_inuse);\n\n\t\t\tvnt_mac_disable_keyentry(priv, key->hw_key_idx);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int vnt_get_stats(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_low_level_stats *stats)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tmemcpy(stats, &priv->low_stats, sizeof(*stats));\n\n\treturn 0;\n}\n\nstatic u64 vnt_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\treturn priv->current_tsf;\n}\n\nstatic void vnt_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tu64 tsf)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tvnt_update_next_tbtt(priv, tsf, vif->bss_conf.beacon_int);\n}\n\nstatic void vnt_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tvnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\n\n\tvnt_clear_current_tsf(priv);\n}\n\nstatic const struct ieee80211_ops vnt_mac_ops = {\n\t.tx\t\t\t= vnt_tx_80211,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= vnt_start,\n\t.stop\t\t\t= vnt_stop,\n\t.add_interface\t\t= vnt_add_interface,\n\t.remove_interface\t= vnt_remove_interface,\n\t.config\t\t\t= vnt_config,\n\t.bss_info_changed\t= vnt_bss_info_changed,\n\t.prepare_multicast\t= vnt_prepare_multicast,\n\t.configure_filter\t= vnt_configure,\n\t.set_key\t\t= vnt_set_key,\n\t.get_stats\t\t= vnt_get_stats,\n\t.get_tsf\t\t= vnt_get_tsf,\n\t.set_tsf\t\t= vnt_set_tsf,\n\t.reset_tsf\t\t= vnt_reset_tsf,\n};\n\nint vnt_init(struct vnt_private *priv)\n{\n\tif (vnt_init_registers(priv))\n\t\treturn -EAGAIN;\n\n\tSET_IEEE80211_PERM_ADDR(priv->hw, priv->permanent_net_addr);\n\n\tvnt_init_bands(priv);\n\n\tif (ieee80211_register_hw(priv->hw))\n\t\treturn -ENODEV;\n\n\tpriv->mac_hw = true;\n\n\tvnt_radio_power_off(priv);\n\n\treturn 0;\n}\n\nstatic int\nvt6656_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev;\n\tstruct vnt_private *priv;\n\tstruct ieee80211_hw *hw;\n\tstruct wiphy *wiphy;\n\tint rc;\n\n\tudev = usb_get_dev(interface_to_usbdev(intf));\n\n\tdev_notice(&udev->dev, \"%s Ver. %s\\n\",\n\t\t   DEVICE_FULL_DRV_NAM, DEVICE_VERSION);\n\tdev_notice(&udev->dev,\n\t\t   \"Copyright (c) 2004 VIA Networking Technologies, Inc.\\n\");\n\n\thw = ieee80211_alloc_hw(sizeof(struct vnt_private), &vnt_mac_ops);\n\tif (!hw) {\n\t\tdev_err(&udev->dev, \"could not register ieee80211_hw\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_nomem;\n\t}\n\n\tpriv = hw->priv;\n\tpriv->hw = hw;\n\tpriv->usb = udev;\n\tpriv->intf = intf;\n\n\tvnt_set_options(priv);\n\n\tspin_lock_init(&priv->lock);\n\tmutex_init(&priv->usb_lock);\n\n\tINIT_DELAYED_WORK(&priv->run_command_work, vnt_run_command);\n\n\tusb_set_intfdata(intf, priv);\n\n\twiphy = priv->hw->wiphy;\n\n\twiphy->frag_threshold = FRAG_THRESH_DEF;\n\twiphy->rts_threshold = RTS_THRESH_DEF;\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_ADHOC) | BIT(NL80211_IFTYPE_AP);\n\n\tieee80211_hw_set(priv->hw, TIMING_BEACON_ONLY);\n\tieee80211_hw_set(priv->hw, SIGNAL_DBM);\n\tieee80211_hw_set(priv->hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(priv->hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(priv->hw, SUPPORTS_PS);\n\tieee80211_hw_set(priv->hw, PS_NULLFUNC_STACK);\n\n\tpriv->hw->extra_tx_headroom =\n\t\tsizeof(struct vnt_tx_buffer) + sizeof(struct vnt_tx_usb_header);\n\tpriv->hw->max_signal = 100;\n\n\tSET_IEEE80211_DEV(priv->hw, &intf->dev);\n\n\trc = usb_reset_device(priv->usb);\n\tif (rc)\n\t\tdev_warn(&priv->usb->dev,\n\t\t\t \"%s reset fail status=%d\\n\", __func__, rc);\n\n\tclear_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags);\n\tvnt_reset_command_timer(priv);\n\n\tvnt_schedule_command(priv, WLAN_CMD_INIT_MAC80211);\n\n\treturn 0;\n\nerr_nomem:\n\tusb_put_dev(udev);\n\n\treturn rc;\n}\n\nstatic void vt6656_disconnect(struct usb_interface *intf)\n{\n\tstruct vnt_private *priv = usb_get_intfdata(intf);\n\n\tif (!priv)\n\t\treturn;\n\n\tif (priv->mac_hw)\n\t\tieee80211_unregister_hw(priv->hw);\n\n\tusb_set_intfdata(intf, NULL);\n\tusb_put_dev(interface_to_usbdev(intf));\n\n\tset_bit(DEVICE_FLAGS_UNPLUG, &priv->flags);\n\n\tieee80211_free_hw(priv->hw);\n}\n\n#ifdef CONFIG_PM\n\nstatic int vt6656_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\treturn 0;\n}\n\nstatic int vt6656_resume(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\n#endif  \n\nMODULE_DEVICE_TABLE(usb, vt6656_table);\n\nstatic struct usb_driver vt6656_driver = {\n\t.name =\t\tDEVICE_NAME,\n\t.probe =\tvt6656_probe,\n\t.disconnect =\tvt6656_disconnect,\n\t.id_table =\tvt6656_table,\n#ifdef CONFIG_PM\n\t.suspend = vt6656_suspend,\n\t.resume = vt6656_resume,\n#endif  \n};\n\nmodule_usb_driver(vt6656_driver);\n\nMODULE_FIRMWARE(FIRMWARE_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}