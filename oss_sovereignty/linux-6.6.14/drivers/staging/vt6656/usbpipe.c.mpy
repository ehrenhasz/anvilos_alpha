{
  "module_name": "usbpipe.c",
  "hash_id": "4a8b3dc672a1536b92a84dd21e305d6e9682539a4b1aaf4566f842ba076c5f50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vt6656/usbpipe.c",
  "human_readable_source": "\n \n\n#include \"rxtx.h\"\n#include \"desc.h\"\n#include \"device.h\"\n#include \"usbpipe.h\"\n#include \"mac.h\"\n#include \"rf.h\"\n\n#define USB_CTL_WAIT\t500  \n\nint vnt_control_out(struct vnt_private *priv, u8 request, u16 value,\n\t\t    u16 index, u16 length, const u8 *buffer)\n{\n\tint ret = 0;\n\tu8 *usb_buffer;\n\n\tif (test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags)) {\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tmutex_lock(&priv->usb_lock);\n\n\tusb_buffer = kmemdup(buffer, length, GFP_KERNEL);\n\tif (!usb_buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto end_unlock;\n\t}\n\n\tret = usb_control_msg(priv->usb,\n\t\t\t      usb_sndctrlpipe(priv->usb, 0),\n\t\t\t      request, 0x40, value,\n\t\t\t      index, usb_buffer, length, USB_CTL_WAIT);\n\n\tkfree(usb_buffer);\n\n\tif (ret == (int)length)\n\t\tret = 0;\n\telse\n\t\tret = -EIO;\n\nend_unlock:\n\tmutex_unlock(&priv->usb_lock);\nend:\n\treturn ret;\n}\n\nint vnt_control_out_u8(struct vnt_private *priv, u8 reg, u8 reg_off, u8 data)\n{\n\treturn vnt_control_out(priv, MESSAGE_TYPE_WRITE,\n\t\t\t       reg_off, reg, sizeof(u8), &data);\n}\n\nint vnt_control_out_blocks(struct vnt_private *priv,\n\t\t\t   u16 block, u8 reg, u16 length, const u8 *data)\n{\n\tint ret = 0, i;\n\n\tfor (i = 0; i < length; i += block) {\n\t\tu16 len = min_t(int, length - i, block);\n\n\t\tret = vnt_control_out(priv, MESSAGE_TYPE_WRITE,\n\t\t\t\t      i, reg, len, data + i);\n\t\tif (ret)\n\t\t\tgoto end;\n\t}\nend:\n\treturn ret;\n}\n\nint vnt_control_in(struct vnt_private *priv, u8 request, u16 value,\n\t\t   u16 index, u16 length, u8 *buffer)\n{\n\tint ret = 0;\n\tu8 *usb_buffer;\n\n\tif (test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags)) {\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tmutex_lock(&priv->usb_lock);\n\n\tusb_buffer = kmalloc(length, GFP_KERNEL);\n\tif (!usb_buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto end_unlock;\n\t}\n\n\tret = usb_control_msg(priv->usb,\n\t\t\t      usb_rcvctrlpipe(priv->usb, 0),\n\t\t\t      request, 0xc0, value,\n\t\t\t      index, usb_buffer, length, USB_CTL_WAIT);\n\n\tif (ret == length)\n\t\tmemcpy(buffer, usb_buffer, length);\n\n\tkfree(usb_buffer);\n\n\tif (ret == (int)length)\n\t\tret = 0;\n\telse\n\t\tret = -EIO;\n\nend_unlock:\n\tmutex_unlock(&priv->usb_lock);\nend:\n\treturn ret;\n}\n\nint vnt_control_in_u8(struct vnt_private *priv, u8 reg, u8 reg_off, u8 *data)\n{\n\treturn vnt_control_in(priv, MESSAGE_TYPE_READ,\n\t\t\t      reg_off, reg, sizeof(u8), data);\n}\n\nstatic int vnt_int_report_rate(struct vnt_private *priv, u8 pkt_no, u8 tsr)\n{\n\tstruct vnt_usb_send_context *context;\n\tstruct ieee80211_tx_info *info;\n\tu8 tx_retry = (tsr & 0xf0) >> 4;\n\ts8 idx;\n\n\tif (pkt_no >= priv->num_tx_context)\n\t\treturn -EINVAL;\n\n\tcontext = priv->tx_context[pkt_no];\n\n\tif (!context->skb)\n\t\treturn -EINVAL;\n\n\tinfo = IEEE80211_SKB_CB(context->skb);\n\tidx = info->control.rates[0].idx;\n\n\tieee80211_tx_info_clear_status(info);\n\n\tinfo->status.rates[0].count = tx_retry;\n\n\tif (!(tsr & TSR_TMO)) {\n\t\tinfo->status.rates[0].idx = idx;\n\n\t\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t}\n\n\tieee80211_tx_status_irqsafe(priv->hw, context->skb);\n\n\tcontext->in_use = false;\n\n\treturn 0;\n}\n\nstatic void vnt_int_process_data(struct vnt_private *priv)\n{\n\tstruct vnt_interrupt_data *int_data;\n\tstruct ieee80211_low_level_stats *low_stats = &priv->low_stats;\n\n\tdev_dbg(&priv->usb->dev, \"---->s_nsInterruptProcessData\\n\");\n\n\tint_data = (struct vnt_interrupt_data *)priv->int_buf.data_buf;\n\n\tif (int_data->tsr0 & TSR_VALID)\n\t\tvnt_int_report_rate(priv, int_data->pkt0, int_data->tsr0);\n\n\tif (int_data->tsr1 & TSR_VALID)\n\t\tvnt_int_report_rate(priv, int_data->pkt1, int_data->tsr1);\n\n\tif (int_data->tsr2 & TSR_VALID)\n\t\tvnt_int_report_rate(priv, int_data->pkt2, int_data->tsr2);\n\n\tif (int_data->tsr3 & TSR_VALID)\n\t\tvnt_int_report_rate(priv, int_data->pkt3, int_data->tsr3);\n\n\tif (!int_data->isr0)\n\t\treturn;\n\n\tif (int_data->isr0 & ISR_BNTX && priv->op_mode == NL80211_IFTYPE_AP)\n\t\tvnt_schedule_command(priv, WLAN_CMD_BECON_SEND);\n\n\tpriv->current_tsf = le64_to_cpu(int_data->tsf);\n\n\tlow_stats->dot11RTSSuccessCount += int_data->rts_success;\n\tlow_stats->dot11RTSFailureCount += int_data->rts_fail;\n\tlow_stats->dot11ACKFailureCount += int_data->ack_fail;\n\tlow_stats->dot11FCSErrorCount += int_data->fcs_err;\n}\n\nstatic void vnt_start_interrupt_urb_complete(struct urb *urb)\n{\n\tstruct vnt_private *priv = urb->context;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\tcase -ETIMEDOUT:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (status)\n\t\tdev_dbg(&priv->usb->dev, \"%s status = %d\\n\", __func__, status);\n\telse\n\t\tvnt_int_process_data(priv);\n\n\tif (!test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags))\n\t\tstatus = usb_submit_urb(priv->interrupt_urb, GFP_ATOMIC);\n\n\tif (status)\n\t\tdev_dbg(&priv->usb->dev, \"Submit int URB failed %d\\n\", status);\n}\n\nint vnt_start_interrupt_urb(struct vnt_private *priv)\n{\n\tint ret = 0;\n\n\tdev_dbg(&priv->usb->dev, \"---->Interrupt Polling Thread\\n\");\n\n\tusb_fill_int_urb(priv->interrupt_urb,\n\t\t\t priv->usb,\n\t\t\t usb_rcvintpipe(priv->usb, 1),\n\t\t\t priv->int_buf.data_buf,\n\t\t\t MAX_INTERRUPT_SIZE,\n\t\t\t vnt_start_interrupt_urb_complete,\n\t\t\t priv,\n\t\t\t priv->int_interval);\n\n\tret = usb_submit_urb(priv->interrupt_urb, GFP_ATOMIC);\n\tif (ret)\n\t\tdev_dbg(&priv->usb->dev, \"Submit int URB failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int vnt_rx_data(struct vnt_private *priv, struct vnt_rcb *ptr_rcb,\n\t\t       unsigned long bytes_received)\n{\n\tstruct ieee80211_hw *hw = priv->hw;\n\tstruct ieee80211_supported_band *sband;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct vnt_rx_header *head;\n\tstruct vnt_rx_tail *tail;\n\tu32 frame_size;\n\tint ii;\n\tu16 rx_bitrate, pay_load_with_padding;\n\tu8 rate_idx = 0;\n\tlong rx_dbm;\n\n\tskb = ptr_rcb->skb;\n\trx_status = IEEE80211_SKB_RXCB(skb);\n\n\t \n\thead = (struct vnt_rx_header *)skb->data;\n\tframe_size = head->wbk_status >> 16;\n\tframe_size += 4;\n\n\tif (bytes_received != frame_size) {\n\t\tdev_dbg(&priv->usb->dev, \"------- WRONG Length 1\\n\");\n\t\treturn false;\n\t}\n\n\tif ((bytes_received > 2372) || (bytes_received <= 40)) {\n\t\t \n\t\tdev_dbg(&priv->usb->dev, \"------ WRONG Length 2\\n\");\n\t\treturn false;\n\t}\n\n\t \n\t \n\n\t \n\n\t \n\tif (((bytes_received - head->pay_load_len) > 27) ||\n\t    ((bytes_received - head->pay_load_len) < 24) ||\n\t    (bytes_received < head->pay_load_len)) {\n\t\tdev_dbg(&priv->usb->dev, \"Wrong PLCP Length %x\\n\",\n\t\t\thead->pay_load_len);\n\t\treturn false;\n\t}\n\n\tsband = hw->wiphy->bands[hw->conf.chandef.chan->band];\n\trx_bitrate = head->rx_rate * 5;  \n\n\tfor (ii = 0; ii < sband->n_bitrates; ii++) {\n\t\tif (sband->bitrates[ii].bitrate == rx_bitrate) {\n\t\t\trate_idx = ii;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ii == sband->n_bitrates) {\n\t\tdev_dbg(&priv->usb->dev, \"Wrong Rx Bit Rate %d\\n\", rx_bitrate);\n\t\treturn false;\n\t}\n\n\tpay_load_with_padding = ((head->pay_load_len / 4) +\n\t\t((head->pay_load_len % 4) ? 1 : 0)) * 4;\n\n\ttail = (struct vnt_rx_tail *)(skb->data +\n\t\t\t\t      sizeof(*head) + pay_load_with_padding);\n\tpriv->tsf_time = le64_to_cpu(tail->tsf_time);\n\n\tif (tail->rsr & (RSR_IVLDTYP | RSR_IVLDLEN))\n\t\treturn false;\n\n\tvnt_rf_rssi_to_dbm(priv, tail->rssi, &rx_dbm);\n\n\tpriv->bb_pre_ed_rssi = (u8)-rx_dbm + 1;\n\tpriv->current_rssi = priv->bb_pre_ed_rssi;\n\n\tskb_pull(skb, sizeof(*head));\n\tskb_trim(skb, head->pay_load_len);\n\n\trx_status->mactime = priv->tsf_time;\n\trx_status->band = hw->conf.chandef.chan->band;\n\trx_status->signal = rx_dbm;\n\trx_status->flag = 0;\n\trx_status->freq = hw->conf.chandef.chan->center_freq;\n\n\tif (!(tail->rsr & RSR_CRCOK))\n\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\n\trx_status->rate_idx = rate_idx;\n\n\tif (tail->new_rsr & NEWRSR_DECRYPTOK)\n\t\trx_status->flag |= RX_FLAG_DECRYPTED;\n\n\tieee80211_rx_irqsafe(priv->hw, skb);\n\n\treturn true;\n}\n\nstatic void vnt_submit_rx_urb_complete(struct urb *urb)\n{\n\tstruct vnt_rcb *rcb = urb->context;\n\tstruct vnt_private *priv = rcb->priv;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tcase -ETIMEDOUT:\n\tdefault:\n\t\tdev_dbg(&priv->usb->dev, \"BULK In failed %d\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\tif (urb->actual_length) {\n\t\tif (vnt_rx_data(priv, rcb, urb->actual_length)) {\n\t\t\trcb->skb = dev_alloc_skb(priv->rx_buf_sz);\n\t\t\tif (!rcb->skb)\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tskb_push(rcb->skb, skb_headroom(rcb->skb));\n\t\t\tskb_trim(rcb->skb, 0);\n\t\t}\n\n\t\turb->transfer_buffer = skb_put(rcb->skb,\n\t\t\t\t\t       skb_tailroom(rcb->skb));\n\t}\n\n\tif (usb_submit_urb(urb, GFP_ATOMIC))\n\t\tdev_dbg(&priv->usb->dev, \"Failed to re submit rx skb\\n\");\n}\n\nint vnt_submit_rx_urb(struct vnt_private *priv, struct vnt_rcb *rcb)\n{\n\tint ret = 0;\n\tstruct urb *urb = rcb->urb;\n\n\tif (!rcb->skb) {\n\t\tdev_dbg(&priv->usb->dev, \"rcb->skb is null\\n\");\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tusb_fill_bulk_urb(urb,\n\t\t\t  priv->usb,\n\t\t\t  usb_rcvbulkpipe(priv->usb, 2),\n\t\t\t  skb_put(rcb->skb, skb_tailroom(rcb->skb)),\n\t\t\t  MAX_TOTAL_SIZE_WITH_ALL_HEADERS,\n\t\t\t  vnt_submit_rx_urb_complete,\n\t\t\t  rcb);\n\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret)\n\t\tdev_dbg(&priv->usb->dev, \"Submit Rx URB failed %d\\n\", ret);\nend:\n\treturn ret;\n}\n\nstatic void vnt_tx_context_complete(struct urb *urb)\n{\n\tstruct vnt_usb_send_context *context = urb->context;\n\tstruct vnt_private *priv = context->priv;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tdev_dbg(&priv->usb->dev,\n\t\t\t\"Write %d bytes\\n\", urb->actual_length);\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tcontext->in_use = false;\n\t\treturn;\n\tcase -ETIMEDOUT:\n\tdefault:\n\t\tdev_dbg(&priv->usb->dev, \"BULK Out failed %d\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\tif (context->type == CONTEXT_DATA_PACKET)\n\t\tieee80211_wake_queues(priv->hw);\n\n\tif (urb->status || context->type == CONTEXT_BEACON_PACKET) {\n\t\tif (context->skb)\n\t\t\tieee80211_free_txskb(priv->hw, context->skb);\n\n\t\tcontext->in_use = false;\n\t}\n}\n\nint vnt_tx_context(struct vnt_private *priv,\n\t\t   struct vnt_usb_send_context *context,\n\t\t   struct sk_buff *skb)\n{\n\tstruct vnt_tx_usb_header *usb;\n\tstruct urb *urb;\n\tint status;\n\tu16 count = skb->len;\n\n\tusb = skb_push(skb, sizeof(*usb));\n\tusb->tx_byte_count = cpu_to_le16(count);\n\tusb->pkt_no = context->pkt_no;\n\tusb->type = context->type;\n\n\tif (test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags)) {\n\t\tcontext->in_use = false;\n\t\treturn -ENODEV;\n\t}\n\n\tif (skb->len > MAX_TOTAL_SIZE_WITH_ALL_HEADERS) {\n\t\tcontext->in_use = false;\n\t\treturn -E2BIG;\n\t}\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\tcontext->in_use = false;\n\t\treturn -ENOMEM;\n\t}\n\n\tusb_fill_bulk_urb(urb,\n\t\t\t  priv->usb,\n\t\t\t  usb_sndbulkpipe(priv->usb, 3),\n\t\t\t  skb->data,\n\t\t\t  skb->len,\n\t\t\t  vnt_tx_context_complete,\n\t\t\t  context);\n\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status) {\n\t\tdev_dbg(&priv->usb->dev, \"Submit Tx URB failed %d\\n\", status);\n\t\tusb_unanchor_urb(urb);\n\t\tcontext->in_use = false;\n\t}\n\n\tusb_free_urb(urb);\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}