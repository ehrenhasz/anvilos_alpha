{
  "module_name": "r8192U_wx.c",
  "hash_id": "eae3f0703cec8c9c8fd79d9fe8edbd6c2b7983bc7d2b660701c274bddd42088d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/r8192U_wx.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include \"r8192U.h\"\n#include \"r8192U_hw.h\"\n\n#include \"ieee80211/dot11d.h\"\n#include \"r8192U_wx.h\"\n\n#define RATE_COUNT 12\nstatic const u32 rtl8180_rates[] = {1000000, 2000000, 5500000, 11000000,\n\t6000000, 9000000, 12000000, 18000000, 24000000, 36000000, 48000000, 54000000};\n\n#ifndef ENETDOWN\n#define ENETDOWN 1\n#endif\n\nstatic int r8192_wx_get_freq(struct net_device *dev,\n\t\t\t     struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\treturn ieee80211_wx_get_freq(priv->ieee80211, a, wrqu, b);\n}\n\nstatic int r8192_wx_get_mode(struct net_device *dev, struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\treturn ieee80211_wx_get_mode(priv->ieee80211, a, wrqu, b);\n}\n\nstatic int r8192_wx_get_rate(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\treturn ieee80211_wx_get_rate(priv->ieee80211, info, wrqu, extra);\n}\n\nstatic int r8192_wx_set_rate(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tint ret;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = ieee80211_wx_set_rate(priv->ieee80211, info, wrqu, extra);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int r8192_wx_set_rts(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tint ret;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = ieee80211_wx_set_rts(priv->ieee80211, info, wrqu, extra);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int r8192_wx_get_rts(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\treturn ieee80211_wx_get_rts(priv->ieee80211, info, wrqu, extra);\n}\n\nstatic int r8192_wx_set_power(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tint ret;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = ieee80211_wx_set_power(priv->ieee80211, info, wrqu, extra);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int r8192_wx_get_power(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\treturn ieee80211_wx_get_power(priv->ieee80211, info, wrqu, extra);\n}\n\nstatic int r8192_wx_force_reset(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tnetdev_dbg(dev, \"%s(): force reset ! extra is %d\\n\", __func__, *extra);\n\tpriv->force_reset = *extra;\n\tmutex_unlock(&priv->wx_mutex);\n\treturn 0;\n}\n\nstatic int r8192_wx_set_rawtx(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint ret;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = ieee80211_wx_set_rawtx(priv->ieee80211, info, wrqu, extra);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int r8192_wx_set_crcmon(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint *parms = (int *)extra;\n\tint enable = (parms[0] > 0);\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tif (enable)\n\t\tpriv->crcmon = 1;\n\telse\n\t\tpriv->crcmon = 0;\n\n\tDMESG(\"bad CRC in monitor mode are %s\",\n\t      priv->crcmon ? \"accepted\" : \"rejected\");\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn 0;\n}\n\nstatic int r8192_wx_set_mode(struct net_device *dev, struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint ret;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = ieee80211_wx_set_mode(priv->ieee80211, a, wrqu, b);\n\n\trtl8192_set_rxconf(dev);\n\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstruct  iw_range_with_scan_capa {\n\t \n\t__u32           throughput;      \n\t \n\n\t \n\t__u32           min_nwid;        \n\t__u32           max_nwid;        \n\n\t \n\t__u16           old_num_channels;\n\t__u8            old_num_frequency;\n\n\t \n\t__u8            scan_capa;\n};\n\nstatic int rtl8180_wx_get_range(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_range *range = (struct iw_range *)extra;\n\tstruct iw_range_with_scan_capa *tmp = (struct iw_range_with_scan_capa *)range;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu16 val;\n\tint i;\n\n\twrqu->data.length = sizeof(*range);\n\tmemset(range, 0, sizeof(*range));\n\n\t \n\n\t \n\n\t \n\trange->throughput = 5 * 1000 * 1000;\n\n\t \n\t \t \n\t \n\t \t \n\n\t \n\t \n\t \n\t   \n\tif (priv->rf_set_sens)\n\t\trange->sensitivity = priv->max_sens;\t \n\n\trange->max_qual.qual = 100;\n\t \n\trange->max_qual.level = 0;\n\trange->max_qual.noise = 0x100 - 98;\n\trange->max_qual.updated = 7;  \n\n\trange->avg_qual.qual = 92;  \n\t \n\trange->avg_qual.level = 0x100 - 78;\n\trange->avg_qual.noise = 0;\n\trange->avg_qual.updated = 7;  \n\n\trange->num_bitrates = RATE_COUNT;\n\n\tfor (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++)\n\t\trange->bitrate[i] = rtl8180_rates[i];\n\n\trange->min_frag = MIN_FRAG_THRESHOLD;\n\trange->max_frag = MAX_FRAG_THRESHOLD;\n\n\trange->min_pmp = 0;\n\trange->max_pmp = 5000000;\n\trange->min_pmt = 0;\n\trange->max_pmt = 65535 * 1000;\n\trange->pmp_flags = IW_POWER_PERIOD;\n\trange->pmt_flags = IW_POWER_TIMEOUT;\n\trange->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT | IW_POWER_ALL_R;\n\n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->we_version_source = 16;\n\n\t \t \n\t \t \n\t \t \n\t \t\t \n\t \t\t \n\t \t \n\t \t \n\n\tfor (i = 0, val = 0; i < 14; i++) {\n\t\t \n\t\tif ((GET_DOT11D_INFO(priv->ieee80211)->channel_map)[i + 1]) {\n\t\t\trange->freq[val].i = i + 1;\n\t\t\trange->freq[val].m = ieee80211_wlan_frequencies[i] * 100000;\n\t\t\trange->freq[val].e = 1;\n\t\t\tval++;\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t}\n\n\t\tif (val == IW_MAX_FREQUENCIES)\n\t\t\tbreak;\n\t}\n\trange->num_frequency = val;\n\trange->num_channels = val;\n\trange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |\n\t\t\t  IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;\n\ttmp->scan_capa = 0x01;\n\treturn 0;\n}\n\nstatic int r8192_wx_set_scan(struct net_device *dev, struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\tint ret = 0;\n\n\tif (!priv->up)\n\t\treturn -ENETDOWN;\n\n\tif (priv->ieee80211->LinkDetectInfo.bBusyTraffic)\n\t\treturn -EAGAIN;\n\tif (wrqu->data.flags & IW_SCAN_THIS_ESSID) {\n\t\tstruct iw_scan_req *req = (struct iw_scan_req *)b;\n\n\t\tif (req->essid_len) {\n\t\t\tint len = min_t(int, req->essid_len, IW_ESSID_MAX_SIZE);\n\n\t\t\tieee->current_network.ssid_len = len;\n\t\t\tmemcpy(ieee->current_network.ssid, req->essid, len);\n\t\t}\n\t}\n\n\tmutex_lock(&priv->wx_mutex);\n\tif (priv->ieee80211->state != IEEE80211_LINKED) {\n\t\tpriv->ieee80211->scanning = 0;\n\t\tieee80211_softmac_scan_syncro(priv->ieee80211);\n\t\tret = 0;\n\t} else {\n\t\tret = ieee80211_wx_set_scan(priv->ieee80211, a, wrqu, b);\n\t}\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic int r8192_wx_get_scan(struct net_device *dev, struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tint ret;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tif (!priv->up)\n\t\treturn -ENETDOWN;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = ieee80211_wx_get_scan(priv->ieee80211, a, wrqu, b);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int r8192_wx_set_essid(struct net_device *dev,\n\t\t\t      struct iw_request_info *a,\n\t\t\t      union iwreq_data *wrqu, char *b)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint ret;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = ieee80211_wx_set_essid(priv->ieee80211, a, wrqu, b);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int r8192_wx_get_essid(struct net_device *dev,\n\t\t\t      struct iw_request_info *a,\n\t\t\t      union iwreq_data *wrqu, char *b)\n{\n\tint ret;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = ieee80211_wx_get_essid(priv->ieee80211, a, wrqu, b);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int r8192_wx_set_freq(struct net_device *dev, struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tint ret;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = ieee80211_wx_set_freq(priv->ieee80211, a, wrqu, b);\n\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic int r8192_wx_get_name(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\treturn ieee80211_wx_get_name(priv->ieee80211, info, wrqu, extra);\n}\n\nstatic int r8192_wx_set_frag(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tif (wrqu->frag.disabled) {\n\t\tpriv->ieee80211->fts = DEFAULT_FRAG_THRESHOLD;\n\t} else {\n\t\tif (wrqu->frag.value < MIN_FRAG_THRESHOLD ||\n\t\t    wrqu->frag.value > MAX_FRAG_THRESHOLD)\n\t\t\treturn -EINVAL;\n\n\t\tpriv->ieee80211->fts = wrqu->frag.value & ~0x1;\n\t}\n\n\treturn 0;\n}\n\nstatic int r8192_wx_get_frag(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\twrqu->frag.value = priv->ieee80211->fts;\n\twrqu->frag.fixed = 0;\t \n\twrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FRAG_THRESHOLD);\n\n\treturn 0;\n}\n\nstatic int r8192_wx_set_wap(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *awrq,\n\t\t\t    char *extra)\n{\n\tint ret;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\t \n\tmutex_lock(&priv->wx_mutex);\n\n\tret = ieee80211_wx_set_wap(priv->ieee80211, info, awrq, extra);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int r8192_wx_get_wap(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\treturn ieee80211_wx_get_wap(priv->ieee80211, info, wrqu, extra);\n}\n\nstatic int r8192_wx_get_enc(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *key)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\treturn ieee80211_wx_get_encode(priv->ieee80211, info, wrqu, key);\n}\n\nstatic int r8192_wx_set_enc(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *key)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\tint ret;\n\tu32 hwkey[4] = {0, 0, 0, 0};\n\tu8 mask = 0xff;\n\tu32 key_idx = 0;\n\tu8 zero_addr[4][6] = {\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\n\t\t\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\n\t\t\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x03} };\n\tint i;\n\n\tif (!priv->up)\n\t\treturn -ENETDOWN;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tRT_TRACE(COMP_SEC, \"Setting SW wep key\");\n\tret = ieee80211_wx_set_encode(priv->ieee80211, info, wrqu, key);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\t \n\tif (wrqu->encoding.length != 0) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\thwkey[i] |=  key[4 * i + 0] & mask;\n\t\t\tif (i == 1 && (4 * i + 1) == wrqu->encoding.length)\n\t\t\t\tmask = 0x00;\n\t\t\tif (i == 3 && (4 * i + 1) == wrqu->encoding.length)\n\t\t\t\tmask = 0x00;\n\t\t\thwkey[i] |= (key[4 * i + 1] & mask) << 8;\n\t\t\thwkey[i] |= (key[4 * i + 2] & mask) << 16;\n\t\t\thwkey[i] |= (key[4 * i + 3] & mask) << 24;\n\t\t}\n\n\t\t#define CONF_WEP40  0x4\n\t\t#define CONF_WEP104 0x14\n\n\t\tswitch (wrqu->encoding.flags & IW_ENCODE_INDEX) {\n\t\tcase 0:\n\t\t\tkey_idx = ieee->tx_keyidx;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tkey_idx = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tkey_idx = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tkey_idx = 2;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tkey_idx\t= 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wrqu->encoding.length == 0x5) {\n\t\t\tieee->pairwise_key_type = KEY_TYPE_WEP40;\n\t\t\tEnableHWSecurityConfig8192(dev);\n\n\t\t\tsetKey(dev,\n\t\t\t       key_idx,                 \n\t\t\t       key_idx,                 \n\t\t\t       KEY_TYPE_WEP40,          \n\t\t\t       zero_addr[key_idx],\n\t\t\t       0,                       \n\t\t\t       hwkey);                  \n\t\t} else if (wrqu->encoding.length == 0xd) {\n\t\t\tieee->pairwise_key_type = KEY_TYPE_WEP104;\n\t\t\tEnableHWSecurityConfig8192(dev);\n\n\t\t\tsetKey(dev,\n\t\t\t       key_idx,                 \n\t\t\t       key_idx,                 \n\t\t\t       KEY_TYPE_WEP104,         \n\t\t\t       zero_addr[key_idx],\n\t\t\t       0,                       \n\t\t\t       hwkey);                  \n\t\t} else {\n\t\t\tnetdev_warn(dev, \"wrong type in WEP, not WEP40 and WEP104\\n\");\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int r8192_wx_set_scan_type(struct net_device *dev, struct iw_request_info *aa,\n\t\t\t\t  union iwreq_data *wrqu, char *p)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint *parms = (int *)p;\n\tint mode = parms[0];\n\n\tpriv->ieee80211->active_scan = mode;\n\n\treturn 1;\n}\n\nstatic int r8192_wx_set_retry(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint err = 0;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tif (wrqu->retry.flags & IW_RETRY_LIFETIME ||\n\t    wrqu->retry.disabled){\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\tif (!(wrqu->retry.flags & IW_RETRY_LIMIT)) {\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (wrqu->retry.value > R8180_MAX_RETRY) {\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\tif (wrqu->retry.flags & IW_RETRY_MAX) {\n\t\tpriv->retry_rts = wrqu->retry.value;\n\t\tDMESG(\"Setting retry for RTS/CTS data to %d\", wrqu->retry.value);\n\n\t} else {\n\t\tpriv->retry_data = wrqu->retry.value;\n\t\tDMESG(\"Setting retry for non RTS/CTS data to %d\", wrqu->retry.value);\n\t}\n\n\t \n\n\trtl8192_commit(dev);\nexit:\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn err;\n}\n\nstatic int r8192_wx_get_retry(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\twrqu->retry.disabled = 0;  \n\n\tif ((wrqu->retry.flags & IW_RETRY_TYPE) ==\n\t    IW_RETRY_LIFETIME)\n\t\treturn -EINVAL;\n\n\tif (wrqu->retry.flags & IW_RETRY_MAX) {\n\t\twrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_MAX;\n\t\twrqu->retry.value = priv->retry_rts;\n\t} else {\n\t\twrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_MIN;\n\t\twrqu->retry.value = priv->retry_data;\n\t}\n\n\treturn 0;\n}\n\nstatic int r8192_wx_get_sens(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tif (!priv->rf_set_sens)\n\t\treturn -1;  \n\twrqu->sens.value = priv->sens;\n\treturn 0;\n}\n\nstatic int r8192_wx_set_sens(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tshort err = 0;\n\n\tmutex_lock(&priv->wx_mutex);\n\tif (!priv->rf_set_sens) {\n\t\terr = -1;  \n\t\tgoto exit;\n\t}\n\tif (priv->rf_set_sens(dev, wrqu->sens.value) == 0)\n\t\tpriv->sens = wrqu->sens.value;\n\telse\n\t\terr = -EINVAL;\n\nexit:\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn err;\n}\n\n \nstatic int r8192_wx_set_enc_ext(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tint ret = 0;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\n\tmutex_lock(&priv->wx_mutex);\n\tret = ieee80211_wx_set_encode_ext(priv->ieee80211, info, wrqu, extra);\n\n\t{\n\t\tu8 broadcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\t\tu8 zero[6] = {0};\n\t\tu32 key[4] = {0};\n\t\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\t\tstruct iw_point *encoding = &wrqu->encoding;\n\t\tu8 idx = 0, alg = 0, group = 0;\n\n\t\tif ((encoding->flags & IW_ENCODE_DISABLED) || ext->alg == IW_ENCODE_ALG_NONE)\n\t\t\t \n\t\t\tgoto end_hw_sec;\n\n\t\t \n\t\talg =  (ext->alg == IW_ENCODE_ALG_CCMP) ? KEY_TYPE_CCMP : ext->alg;\n\t\tidx = encoding->flags & IW_ENCODE_INDEX;\n\t\tif (idx)\n\t\t\tidx--;\n\t\tgroup = ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY;\n\n\t\tif ((!group) || (ieee->iw_mode == IW_MODE_ADHOC) || (alg ==  KEY_TYPE_WEP40)) {\n\t\t\tif ((ext->key_len == 13) && (alg == KEY_TYPE_WEP40))\n\t\t\t\talg = KEY_TYPE_WEP104;\n\t\t\tieee->pairwise_key_type = alg;\n\t\t\tEnableHWSecurityConfig8192(dev);\n\t\t}\n\t\tmemcpy((u8 *)key, ext->key, 16);  \n\n\t\tif ((alg & KEY_TYPE_WEP40) && (ieee->auth_mode != 2)) {\n\t\t\tsetKey(dev,\n\t\t\t       idx,\t \n\t\t\t       idx,\t \n\t\t\t       alg,\t \n\t\t\t       zero,\t \n\t\t\t       0,\t \n\t\t\t       key);\t \n\t\t} else if (group) {\n\t\t\tieee->group_key_type = alg;\n\t\t\tsetKey(dev,\n\t\t\t       idx,\t \n\t\t\t       idx,\t \n\t\t\t       alg,\t \n\t\t\t       broadcast_addr,\t \n\t\t\t       0,\t\t \n\t\t\t       key);\t\t \n\t\t} else {\t \n\t\t\tsetKey(dev,\n\t\t\t       4,\t \n\t\t\t       idx,\t \n\t\t\t       alg,\t \n\t\t\t       (u8 *)ieee->ap_mac_addr, \n\t\t\t       0,\t\t\t \n\t\t\t       key);\t\t\t \n\t\t}\n\t}\n\nend_hw_sec:\n\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic int r8192_wx_set_auth(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *data, char *extra)\n{\n\tint ret = 0;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tmutex_lock(&priv->wx_mutex);\n\tret = ieee80211_wx_set_auth(priv->ieee80211, info, &data->param, extra);\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic int r8192_wx_set_mlme(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tint ret = 0;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tmutex_lock(&priv->wx_mutex);\n\tret = ieee80211_wx_set_mlme(priv->ieee80211, info, wrqu, extra);\n\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic int r8192_wx_set_gen_ie(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *data, char *extra)\n{\n\tint ret = 0;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tmutex_lock(&priv->wx_mutex);\n\tret = ieee80211_wx_set_gen_ie(priv->ieee80211, extra, data->data.length);\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic int dummy(struct net_device *dev, struct iw_request_info *a,\n\t\t union iwreq_data *wrqu, char *b)\n{\n\treturn -1;\n}\n\nstatic iw_handler r8192_wx_handlers[] = {\n\tNULL,                      \n\tr8192_wx_get_name,\t   \n\tdummy,                     \n\tdummy,                     \n\tr8192_wx_set_freq,         \n\tr8192_wx_get_freq,         \n\tr8192_wx_set_mode,         \n\tr8192_wx_get_mode,         \n\tr8192_wx_set_sens,         \n\tr8192_wx_get_sens,         \n\tNULL,                      \n\trtl8180_wx_get_range,\t   \n\tNULL,                      \n\tNULL,                      \n\tNULL,                      \n\tNULL,                      \n\tdummy,                     \n\tdummy,                     \n\tNULL,                      \n\tNULL,                      \n\tr8192_wx_set_wap,\t   \n\tr8192_wx_get_wap,          \n\tr8192_wx_set_mlme,                      \n\tdummy,                      \n\tr8192_wx_set_scan,         \n\tr8192_wx_get_scan,         \n\tr8192_wx_set_essid,        \n\tr8192_wx_get_essid,        \n\tdummy,                     \n\tdummy,                     \n\tNULL,                      \n\tNULL,                      \n\tr8192_wx_set_rate,         \n\tr8192_wx_get_rate,         \n\tr8192_wx_set_rts,                     \n\tr8192_wx_get_rts,                     \n\tr8192_wx_set_frag,         \n\tr8192_wx_get_frag,         \n\tdummy,                     \n\tdummy,                     \n\tr8192_wx_set_retry,        \n\tr8192_wx_get_retry,        \n\tr8192_wx_set_enc,          \n\tr8192_wx_get_enc,          \n\tr8192_wx_set_power,                     \n\tr8192_wx_get_power,                     \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tr8192_wx_set_gen_ie,  \t\t \n\tNULL,\t\t\t \n\n\tr8192_wx_set_auth, \t\t\t \n\tNULL,   \t \n\tr8192_wx_set_enc_ext,\t\t\t \n\tNULL, \n\tNULL,\t\t\t  \n\n};\n\nstatic const struct iw_priv_args r8192_private_args[] = {\n\t{\n\t\tSIOCIWFIRSTPRIV + 0x0,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"badcrc\"\n\t},\n\t{\n\t\tSIOCIWFIRSTPRIV + 0x1,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"activescan\"\n\n\t},\n\t{\n\t\tSIOCIWFIRSTPRIV + 0x2,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"rawtx\"\n\t},\n\t{\n\t\tSIOCIWFIRSTPRIV + 0x3,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"forcereset\"\n\t}\n};\n\nstatic iw_handler r8192_private_handler[] = {\n\tr8192_wx_set_crcmon,\n\tr8192_wx_set_scan_type,\n\tr8192_wx_set_rawtx,\n\tr8192_wx_force_reset,\n};\n\nstruct iw_statistics *r8192_get_wireless_stats(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\tstruct iw_statistics *wstats = &priv->wstats;\n\tint tmp_level = 0;\n\tint tmp_qual = 0;\n\tint tmp_noise = 0;\n\n\tif (ieee->state < IEEE80211_LINKED) {\n\t\twstats->qual.qual = 0;\n\t\twstats->qual.level = 0;\n\t\twstats->qual.noise = 0;\n\t\twstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\n\t\treturn wstats;\n\t}\n\n\ttmp_level = (&ieee->current_network)->stats.rssi;\n\ttmp_qual = (&ieee->current_network)->stats.signal;\n\ttmp_noise = (&ieee->current_network)->stats.noise;\n\n\twstats->qual.level = tmp_level;\n\twstats->qual.qual = tmp_qual;\n\twstats->qual.noise = tmp_noise;\n\twstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\n\treturn wstats;\n}\n\nconst struct iw_handler_def  r8192_wx_handlers_def = {\n\t.standard = r8192_wx_handlers,\n\t.num_standard = ARRAY_SIZE(r8192_wx_handlers),\n\t.private = r8192_private_handler,\n\t.num_private = ARRAY_SIZE(r8192_private_handler),\n\t.num_private_args = sizeof(r8192_private_args) / sizeof(struct iw_priv_args),\n\t.get_wireless_stats = r8192_get_wireless_stats,\n\t.private_args = (struct iw_priv_args *)r8192_private_args,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}