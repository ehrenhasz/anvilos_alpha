{
  "module_name": "r819xU_firmware.c",
  "hash_id": "58bd26ee0b70fc31e03ff34ad5d645a520fe36377cd806da600e8d1119e38f9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/r819xU_firmware.c",
  "human_readable_source": "\n \n\n#include \"r8192U.h\"\n#include \"r8192U_hw.h\"\n#include \"r819xU_firmware_img.h\"\n#include \"r819xU_firmware.h\"\n#include <linux/firmware.h>\n\nstatic void firmware_init_param(struct net_device *dev)\n{\n\tstruct r8192_priv\t*priv = ieee80211_priv(dev);\n\trt_firmware\t\t*pfirmware = priv->pFirmware;\n\n\tpfirmware->cmdpacket_frag_threshold = GET_COMMAND_PACKET_FRAG_THRESHOLD(MAX_TRANSMIT_BUFFER_SIZE);\n}\n\n \nstatic bool fw_download_code(struct net_device *dev, u8 *code_virtual_address,\n\t\t\t     u32 buffer_len)\n{\n\tstruct r8192_priv   *priv = ieee80211_priv(dev);\n\tbool\t\t    rt_status = true;\n\tu16\t\t    frag_threshold;\n\tu16\t\t    frag_length, frag_offset = 0;\n\tint\t\t    i;\n\n\trt_firmware\t    *pfirmware = priv->pFirmware;\n\tstruct sk_buff\t    *skb;\n\tunsigned char\t    *seg_ptr;\n\tstruct cb_desc\t\t    *tcb_desc;\n\tu8                  bLastIniPkt;\n\tu8\t\t    index;\n\n\tfirmware_init_param(dev);\n\t \n\tfrag_threshold = pfirmware->cmdpacket_frag_threshold;\n\tdo {\n\t\tif ((buffer_len - frag_offset) > frag_threshold) {\n\t\t\tfrag_length = frag_threshold;\n\t\t\tbLastIniPkt = 0;\n\t\t} else {\n\t\t\tfrag_length = buffer_len - frag_offset;\n\t\t\tbLastIniPkt = 1;\n\t\t}\n\n\t\t \n\t\tskb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + frag_length + 4);\n\t\tif (!skb)\n\t\t\treturn false;\n\t\tmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\n\t\ttcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\t\ttcb_desc->queue_index = TXCMD_QUEUE;\n\t\ttcb_desc->bCmdOrInit = DESC_PACKET_TYPE_INIT;\n\t\ttcb_desc->bLastIniPkt = bLastIniPkt;\n\n\t\tskb_reserve(skb, USB_HWDESC_HEADER_LEN);\n\t\tseg_ptr = skb->data;\n\t\t \n\t\tfor (i = 0; i < frag_length; i += 4) {\n\t\t\t*seg_ptr++ = ((i+0) < frag_length)?code_virtual_address[i+3] : 0;\n\t\t\t*seg_ptr++ = ((i+1) < frag_length)?code_virtual_address[i+2] : 0;\n\t\t\t*seg_ptr++ = ((i+2) < frag_length)?code_virtual_address[i+1] : 0;\n\t\t\t*seg_ptr++ = ((i+3) < frag_length)?code_virtual_address[i+0] : 0;\n\t\t}\n\t\ttcb_desc->txbuf_size = (u16)i;\n\t\tskb_put(skb, i);\n\n\t\tindex = tcb_desc->queue_index;\n\t\tif (!priv->ieee80211->check_nic_enough_desc(dev, index) ||\n\t\t       (!skb_queue_empty(&priv->ieee80211->skb_waitQ[index])) ||\n\t\t       (priv->ieee80211->queue_stop)) {\n\t\t\tRT_TRACE(COMP_FIRMWARE, \"=====================================================> tx full!\\n\");\n\t\t\tskb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);\n\t\t} else {\n\t\t\tpriv->ieee80211->softmac_hard_start_xmit(skb, dev);\n\t\t}\n\n\t\tcode_virtual_address += frag_length;\n\t\tfrag_offset += frag_length;\n\n\t} while (frag_offset < buffer_len);\n\n\treturn rt_status;\n}\n\n \nstatic bool CPUcheck_maincodeok_turnonCPU(struct net_device *dev)\n{\n\tbool\t\trt_status = true;\n\tint\t\tcheck_putcodeOK_time = 200000, check_bootOk_time = 200000;\n\tu32\t\tCPU_status = 0;\n\n\t \n\tdo {\n\t\tread_nic_dword(dev, CPU_GEN, &CPU_status);\n\n\t\tif (CPU_status&CPU_GEN_PUT_CODE_OK)\n\t\t\tbreak;\n\n\t} while (check_putcodeOK_time--);\n\n\tif (!(CPU_status&CPU_GEN_PUT_CODE_OK)) {\n\t\tRT_TRACE(COMP_ERR, \"Download Firmware: Put code fail!\\n\");\n\t\tgoto CPUCheckMainCodeOKAndTurnOnCPU_Fail;\n\t} else {\n\t\tRT_TRACE(COMP_FIRMWARE, \"Download Firmware: Put code ok!\\n\");\n\t}\n\n\t \n\tread_nic_dword(dev, CPU_GEN, &CPU_status);\n\twrite_nic_byte(dev, CPU_GEN,\n\t\t       (u8)((CPU_status | CPU_GEN_PWR_STB_CPU) & 0xff));\n\tmdelay(1000);\n\n\t \n\tdo {\n\t\tread_nic_dword(dev, CPU_GEN, &CPU_status);\n\n\t\tif (CPU_status&CPU_GEN_BOOT_RDY)\n\t\t\tbreak;\n\t} while (check_bootOk_time--);\n\n\tif (!(CPU_status&CPU_GEN_BOOT_RDY))\n\t\tgoto CPUCheckMainCodeOKAndTurnOnCPU_Fail;\n\telse\n\t\tRT_TRACE(COMP_FIRMWARE, \"Download Firmware: Boot ready!\\n\");\n\n\treturn rt_status;\n\nCPUCheckMainCodeOKAndTurnOnCPU_Fail:\n\tRT_TRACE(COMP_ERR, \"ERR in %s()\\n\", __func__);\n\trt_status = false;\n\treturn rt_status;\n}\n\nstatic bool CPUcheck_firmware_ready(struct net_device *dev)\n{\n\tbool\t\trt_status = true;\n\tint\t\tcheck_time = 200000;\n\tu32\t\tCPU_status = 0;\n\n\t \n\tdo {\n\t\tread_nic_dword(dev, CPU_GEN, &CPU_status);\n\n\t\tif (CPU_status&CPU_GEN_FIRM_RDY)\n\t\t\tbreak;\n\n\t} while (check_time--);\n\n\tif (!(CPU_status&CPU_GEN_FIRM_RDY))\n\t\tgoto CPUCheckFirmwareReady_Fail;\n\telse\n\t\tRT_TRACE(COMP_FIRMWARE, \"Download Firmware: Firmware ready!\\n\");\n\n\treturn rt_status;\n\nCPUCheckFirmwareReady_Fail:\n\tRT_TRACE(COMP_ERR, \"ERR in %s()\\n\", __func__);\n\trt_status = false;\n\treturn rt_status;\n}\n\nbool init_firmware(struct net_device *dev)\n{\n\tstruct r8192_priv\t*priv = ieee80211_priv(dev);\n\tbool\t\t\trt_status = true;\n\n\tu32\t\t\tfile_length = 0;\n\tu8\t\t\t*mapped_file = NULL;\n\tu32\t\t\tinit_step = 0;\n\tenum opt_rst_type_e\t   rst_opt = OPT_SYSTEM_RESET;\n\tenum firmware_init_step_e  starting_state = FW_INIT_STEP0_BOOT;\n\n\trt_firmware\t\t*pfirmware = priv->pFirmware;\n\tconst struct firmware\t*fw_entry;\n\tconst char *fw_name[3] = { \"RTL8192U/boot.img\",\n\t\t\t   \"RTL8192U/main.img\",\n\t\t\t   \"RTL8192U/data.img\"};\n\tint rc;\n\n\tRT_TRACE(COMP_FIRMWARE, \" PlatformInitFirmware()==>\\n\");\n\n\tif (pfirmware->firmware_status == FW_STATUS_0_INIT) {\n\t\t \n\t\trst_opt = OPT_SYSTEM_RESET;\n\t\tstarting_state = FW_INIT_STEP0_BOOT;\n\t\t \n\n\t} else if (pfirmware->firmware_status == FW_STATUS_5_READY) {\n\t\t \n\t\trst_opt = OPT_FIRMWARE_RESET;\n\t\tstarting_state = FW_INIT_STEP2_DATA;\n\t} else {\n\t\tRT_TRACE(COMP_FIRMWARE, \"PlatformInitFirmware: undefined firmware state\\n\");\n\t}\n\n\t \n\tfor (init_step = starting_state; init_step <= FW_INIT_STEP2_DATA; init_step++) {\n\t\t \n\t\tif (rst_opt == OPT_SYSTEM_RESET) {\n\t\t\trc = request_firmware(&fw_entry, fw_name[init_step], &priv->udev->dev);\n\t\t\tif (rc < 0) {\n\t\t\t\tRT_TRACE(COMP_ERR, \"request firmware fail!\\n\");\n\t\t\t\tgoto download_firmware_fail;\n\t\t\t}\n\n\t\t\tif (fw_entry->size > sizeof(pfirmware->firmware_buf)) {\n\t\t\t\tRT_TRACE(COMP_ERR, \"img file size exceed the container buffer fail!\\n\");\n\t\t\t\tgoto download_firmware_fail;\n\t\t\t}\n\n\t\t\tif (init_step != FW_INIT_STEP1_MAIN) {\n\t\t\t\tmemcpy(pfirmware->firmware_buf, fw_entry->data, fw_entry->size);\n\t\t\t\tmapped_file = pfirmware->firmware_buf;\n\t\t\t\tfile_length = fw_entry->size;\n\t\t\t} else {\n\t\t\t\tmemset(pfirmware->firmware_buf, 0, 128);\n\t\t\t\tmemcpy(&pfirmware->firmware_buf[128], fw_entry->data, fw_entry->size);\n\t\t\t\tmapped_file = pfirmware->firmware_buf;\n\t\t\t\tfile_length = fw_entry->size + 128;\n\t\t\t}\n\t\t\tpfirmware->firmware_buf_size = file_length;\n\t\t} else if (rst_opt == OPT_FIRMWARE_RESET) {\n\t\t\t \n\t\t\tmapped_file = pfirmware->firmware_buf;\n\t\t\tfile_length = pfirmware->firmware_buf_size;\n\t\t}\n\n\t\t \n\t\t \n\t\trt_status = fw_download_code(dev, mapped_file, file_length);\n\t\tif (rst_opt == OPT_SYSTEM_RESET)\n\t\t\trelease_firmware(fw_entry);\n\n\t\tif (!rt_status)\n\t\t\tgoto download_firmware_fail;\n\n\t\tswitch (init_step) {\n\t\tcase FW_INIT_STEP0_BOOT:\n\t\t\t \n\t\t\tpfirmware->firmware_status = FW_STATUS_1_MOVE_BOOT_CODE;\n\t\t\t \n\t\t\t \n\t\t\tbreak;\n\n\t\tcase FW_INIT_STEP1_MAIN:\n\t\t\t \n\t\t\tpfirmware->firmware_status = FW_STATUS_2_MOVE_MAIN_CODE;\n\n\t\t\t \n\t\t\trt_status = CPUcheck_maincodeok_turnonCPU(dev);\n\t\t\tif (!rt_status) {\n\t\t\t\tRT_TRACE(COMP_ERR, \"CPUcheck_maincodeok_turnonCPU fail!\\n\");\n\t\t\t\tgoto download_firmware_fail;\n\t\t\t}\n\n\t\t\tpfirmware->firmware_status = FW_STATUS_3_TURNON_CPU;\n\t\t\tbreak;\n\n\t\tcase FW_INIT_STEP2_DATA:\n\t\t\t \n\t\t\tpfirmware->firmware_status = FW_STATUS_4_MOVE_DATA_CODE;\n\t\t\tmdelay(1);\n\n\t\t\trt_status = CPUcheck_firmware_ready(dev);\n\t\t\tif (!rt_status) {\n\t\t\t\tRT_TRACE(COMP_ERR, \"CPUcheck_firmware_ready fail(%d)!\\n\", rt_status);\n\t\t\t\tgoto download_firmware_fail;\n\t\t\t}\n\n\t\t\t \n\t\t\tpfirmware->firmware_status = FW_STATUS_5_READY;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tRT_TRACE(COMP_FIRMWARE, \"Firmware Download Success\\n\");\n\treturn rt_status;\n\ndownload_firmware_fail:\n\tRT_TRACE(COMP_ERR, \"ERR in %s()\\n\", __func__);\n\trt_status = false;\n\treturn rt_status;\n}\n\nMODULE_FIRMWARE(\"RTL8192U/boot.img\");\nMODULE_FIRMWARE(\"RTL8192U/main.img\");\nMODULE_FIRMWARE(\"RTL8192U/data.img\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}