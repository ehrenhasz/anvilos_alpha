{
  "module_name": "r8192U_core.c",
  "hash_id": "8944380afeef533ad4c59df589e5dada81f9ad063b34a651f91c15fe6bccbc46",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/r8192U_core.c",
  "human_readable_source": "\n \n\n#ifndef CONFIG_FORCE_HARD_FLOAT\ndouble __floatsidf(int i)\n{\n\treturn i;\n}\n\nunsigned int __fixunsdfsi(double d)\n{\n\treturn d;\n}\n\ndouble __adddf3(double a, double b)\n{\n\treturn a + b;\n}\n\ndouble __addsf3(float a, float b)\n{\n\treturn a + b;\n}\n\ndouble __subdf3(double a, double b)\n{\n\treturn a - b;\n}\n\ndouble __extendsfdf2(float a)\n{\n\treturn a;\n}\n#endif\n\n#define CONFIG_RTL8192_IO_MAP\n\n#include <linux/uaccess.h>\n#include \"r8192U_hw.h\"\n#include \"r8192U.h\"\n#include \"r8190_rtl8256.h\"  \n#include \"r8180_93cx6.h\"    \n#include \"r8192U_wx.h\"\n#include \"r819xU_phy.h\"\n#include \"r819xU_phyreg.h\"\n#include \"r819xU_cmdpkt.h\"\n#include \"r8192U_dm.h\"\n#include <linux/usb.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n \n\n#include \"ieee80211/dot11d.h\"\n \nu32 rt_global_debug_component = COMP_DOWN\t|\n\t\t\t\tCOMP_SEC\t|\n\t\t\t\tCOMP_ERR;  \n\n#define TOTAL_CAM_ENTRY 32\n#define CAM_CONTENT_COUNT 8\n\nstatic const struct usb_device_id rtl8192_usb_id_tbl[] = {\n\t \n\t{USB_DEVICE(0x0bda, 0x8709)},\n\t \n\t{USB_DEVICE(0x07aa, 0x0043)},\n\t \n\t{USB_DEVICE(0x050d, 0x805E)},\n\t \n\t{USB_DEVICE(0x0df6, 0x0031)},\n\t \n\t{USB_DEVICE(0x1740, 0x9201)},\n\t \n\t{USB_DEVICE(0x2001, 0x3301)},\n\t \n\t{USB_DEVICE(0x5a57, 0x0290)},\n\t \n\t{USB_DEVICE(0x043e, 0x7a01)},\n\t{}\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"V 1.1\");\nMODULE_DEVICE_TABLE(usb, rtl8192_usb_id_tbl);\nMODULE_DESCRIPTION(\"Linux driver for Realtek RTL8192 USB WiFi cards\");\n\nstatic char *ifname = \"wlan%d\";\nstatic int hwwep = 1;   \n\nmodule_param(ifname, charp, 0644);\nmodule_param(hwwep, int, 0644);\n\nMODULE_PARM_DESC(ifname, \" Net interface name, wlan%d=default\");\nMODULE_PARM_DESC(hwwep, \" Try to use hardware security support. \");\n\nstatic int rtl8192_usb_probe(struct usb_interface *intf,\n\t\t\t     const struct usb_device_id *id);\nstatic void rtl8192_usb_disconnect(struct usb_interface *intf);\n\nstatic struct usb_driver rtl8192_usb_driver = {\n\t.name\t\t= RTL819XU_MODULE_NAME,\t\t   \n\t.id_table\t= rtl8192_usb_id_tbl,\t\t   \n\t.probe\t\t= rtl8192_usb_probe,\t\t   \n\t.disconnect\t= rtl8192_usb_disconnect,\t   \n\t.suspend\t= NULL,\t\t\t\t   \n\t.resume\t\t= NULL,\t\t\t\t   \n};\n\nstruct CHANNEL_LIST {\n\tu8\tChannel[32];\n\tu8\tLen;\n};\n\nstatic struct CHANNEL_LIST ChannelPlan[] = {\n\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161, 165}, 24},\n\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, 11},\n\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 36, 40, 44, 48, 52, 56, 60, 64}, 21},\n\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}, 13},\n\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}, 13},\n\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 36, 40, 44, 48, 52, 56, 60, 64}, 22},\n\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 36, 40, 44, 48, 52, 56, 60, 64}, 22},\n\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}, 13},\n\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 36, 40, 44, 48, 52, 56, 60, 64}, 22},\n\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 36, 40, 44, 48, 52, 56, 60, 64}, 22},\n\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}, 14}\n};\n\nstatic void rtl819x_set_channel_map(u8 channel_plan, struct r8192_priv *priv)\n{\n\tint i, max_chan = -1, min_chan = -1;\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\n\tswitch (channel_plan) {\n\tcase COUNTRY_CODE_FCC:\n\tcase COUNTRY_CODE_IC:\n\tcase COUNTRY_CODE_ETSI:\n\tcase COUNTRY_CODE_SPAIN:\n\tcase COUNTRY_CODE_FRANCE:\n\tcase COUNTRY_CODE_MKK:\n\tcase COUNTRY_CODE_MKK1:\n\tcase COUNTRY_CODE_ISRAEL:\n\tcase COUNTRY_CODE_TELEC:\n\tcase COUNTRY_CODE_MIC:\n\t\trtl8192u_dot11d_init(ieee);\n\t\tieee->bGlobalDomain = false;\n\t\t \n\t\tif ((priv->rf_chip == RF_8225) || (priv->rf_chip == RF_8256)) {\n\t\t\tmin_chan = 1;\n\t\t\tmax_chan = 14;\n\t\t} else {\n\t\t\tRT_TRACE(COMP_ERR,\n\t\t\t\t \"unknown rf chip, can't set channel map in function:%s()\\n\",\n\t\t\t\t __func__);\n\t\t}\n\t\tif (ChannelPlan[channel_plan].Len != 0) {\n\t\t\t \n\t\t\tmemset(GET_DOT11D_INFO(ieee)->channel_map, 0,\n\t\t\t       sizeof(GET_DOT11D_INFO(ieee)->channel_map));\n\t\t\t \n\t\t\tfor (i = 0; i < ChannelPlan[channel_plan].Len; i++) {\n\t\t\t\tif (ChannelPlan[channel_plan].Channel[i] < min_chan || ChannelPlan[channel_plan].Channel[i] > max_chan)\n\t\t\t\t\tbreak;\n\t\t\t\tGET_DOT11D_INFO(ieee)->channel_map[ChannelPlan[channel_plan].Channel[i]] = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase COUNTRY_CODE_GLOBAL_DOMAIN:\n\t\t \n\t\tGET_DOT11D_INFO(ieee)->dot11d_enabled = 0;\n\t\tdot11d_reset(ieee);\n\t\tieee->bGlobalDomain = true;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void CamResetAllEntry(struct net_device *dev)\n{\n\tu32 ulcommand = 0;\n\t \n\tulcommand |= BIT(31) | BIT(30);\n\twrite_nic_dword(dev, RWCAM, ulcommand);\n}\n\nint write_nic_byte_E(struct net_device *dev, int indx, u8 data)\n{\n\tint status;\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct usb_device *udev = priv->udev;\n\tu8 *usbdata = kzalloc(sizeof(data), GFP_KERNEL);\n\n\tif (!usbdata)\n\t\treturn -ENOMEM;\n\t*usbdata = data;\n\n\tstatus = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,\n\t\t\t\t indx | 0xfe00, 0, usbdata, 1, 500);\n\tkfree(usbdata);\n\n\tif (status < 0) {\n\t\tnetdev_err(dev, \"%s TimeOut! status: %d\\n\", __func__, status);\n\t\treturn status;\n\t}\n\treturn 0;\n}\n\nint read_nic_byte_E(struct net_device *dev, int indx, u8 *data)\n{\n\tint status;\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct usb_device *udev = priv->udev;\n\tu8 *usbdata = kzalloc(sizeof(u8), GFP_KERNEL);\n\n\tif (!usbdata)\n\t\treturn -ENOMEM;\n\n\tstatus = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,\n\t\t\t\t indx | 0xfe00, 0, usbdata, 1, 500);\n\t*data = *usbdata;\n\tkfree(usbdata);\n\n\tif (status < 0) {\n\t\tnetdev_err(dev, \"%s failure status: %d\\n\", __func__, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n \nint write_nic_byte(struct net_device *dev, int indx, u8 data)\n{\n\tint status;\n\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct usb_device *udev = priv->udev;\n\tu8 *usbdata = kzalloc(sizeof(data), GFP_KERNEL);\n\n\tif (!usbdata)\n\t\treturn -ENOMEM;\n\t*usbdata = data;\n\n\tstatus = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,\n\t\t\t\t (indx & 0xff) | 0xff00, (indx >> 8) & 0x0f,\n\t\t\t\t usbdata, 1, 500);\n\tkfree(usbdata);\n\n\tif (status < 0) {\n\t\tnetdev_err(dev, \"%s TimeOut! status: %d\\n\", __func__, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nint write_nic_word(struct net_device *dev, int indx, u16 data)\n{\n\tint status;\n\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct usb_device *udev = priv->udev;\n\tu16 *usbdata = kzalloc(sizeof(data), GFP_KERNEL);\n\n\tif (!usbdata)\n\t\treturn -ENOMEM;\n\t*usbdata = data;\n\n\tstatus = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,\n\t\t\t\t (indx & 0xff) | 0xff00, (indx >> 8) & 0x0f,\n\t\t\t\t usbdata, 2, 500);\n\tkfree(usbdata);\n\n\tif (status < 0) {\n\t\tnetdev_err(dev, \"%s TimeOut! status: %d\\n\", __func__, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nint write_nic_dword(struct net_device *dev, int indx, u32 data)\n{\n\tint status;\n\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct usb_device *udev = priv->udev;\n\tu32 *usbdata = kzalloc(sizeof(data), GFP_KERNEL);\n\n\tif (!usbdata)\n\t\treturn -ENOMEM;\n\t*usbdata = data;\n\n\tstatus = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,\n\t\t\t\t (indx & 0xff) | 0xff00, (indx >> 8) & 0x0f,\n\t\t\t\t usbdata, 4, 500);\n\tkfree(usbdata);\n\n\tif (status < 0) {\n\t\tnetdev_err(dev, \"%s TimeOut! status: %d\\n\", __func__, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nint read_nic_byte(struct net_device *dev, int indx, u8 *data)\n{\n\tint status;\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct usb_device *udev = priv->udev;\n\tu8 *usbdata = kzalloc(sizeof(u8), GFP_KERNEL);\n\n\tif (!usbdata)\n\t\treturn -ENOMEM;\n\n\tstatus = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,\n\t\t\t\t (indx & 0xff) | 0xff00, (indx >> 8) & 0x0f,\n\t\t\t\t usbdata, 1, 500);\n\t*data = *usbdata;\n\tkfree(usbdata);\n\n\tif (status < 0) {\n\t\tnetdev_err(dev, \"%s failure status: %d\\n\", __func__, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nint read_nic_word(struct net_device *dev, int indx, u16 *data)\n{\n\tint status;\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct usb_device *udev = priv->udev;\n\tu16 *usbdata = kzalloc(sizeof(u16), GFP_KERNEL);\n\n\tif (!usbdata)\n\t\treturn -ENOMEM;\n\n\tstatus = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,\n\t\t\t\t (indx & 0xff) | 0xff00, (indx >> 8) & 0x0f,\n\t\t\t\t usbdata, 2, 500);\n\t*data = *usbdata;\n\tkfree(usbdata);\n\n\tif (status < 0) {\n\t\tnetdev_err(dev, \"%s failure status: %d\\n\", __func__, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_nic_word_E(struct net_device *dev, int indx, u16 *data)\n{\n\tint status;\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct usb_device *udev = priv->udev;\n\tu16 *usbdata = kzalloc(sizeof(u16), GFP_KERNEL);\n\n\tif (!usbdata)\n\t\treturn -ENOMEM;\n\n\tstatus = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,\n\t\t\t\t indx | 0xfe00, 0, usbdata, 2, 500);\n\t*data = *usbdata;\n\tkfree(usbdata);\n\n\tif (status < 0) {\n\t\tnetdev_err(dev, \"%s failure status: %d\\n\", __func__, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nint read_nic_dword(struct net_device *dev, int indx, u32 *data)\n{\n\tint status;\n\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct usb_device *udev = priv->udev;\n\tu32 *usbdata = kzalloc(sizeof(u32), GFP_KERNEL);\n\n\tif (!usbdata)\n\t\treturn -ENOMEM;\n\n\tstatus = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,\n\t\t\t\t (indx & 0xff) | 0xff00, (indx >> 8) & 0x0f,\n\t\t\t\t usbdata, 4, 500);\n\t*data = *usbdata;\n\tkfree(usbdata);\n\n\tif (status < 0) {\n\t\tnetdev_err(dev, \"%s failure status: %d\\n\", __func__, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n \n \n \ninline void force_pci_posting(struct net_device *dev)\n{\n}\n\nstatic struct net_device_stats *rtl8192_stats(struct net_device *dev);\nstatic void rtl8192_restart(struct work_struct *work);\nstatic void watch_dog_timer_callback(struct timer_list *t);\n\n \n\nshort check_nic_enough_desc(struct net_device *dev, int queue_index)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint used = atomic_read(&priv->tx_pending[queue_index]);\n\n\treturn (used < MAX_TX_URB);\n}\n\nstatic void tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tschedule_work(&priv->reset_wq);\n}\n\nvoid rtl8192_update_msr(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu8 msr;\n\n\tread_nic_byte(dev, MSR, &msr);\n\tmsr &= ~MSR_LINK_MASK;\n\n\t \n\tif (priv->ieee80211->state == IEEE80211_LINKED) {\n\t\tif (priv->ieee80211->iw_mode == IW_MODE_INFRA)\n\t\t\tmsr |= (MSR_LINK_MANAGED << MSR_LINK_SHIFT);\n\t\telse if (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\n\t\t\tmsr |= (MSR_LINK_ADHOC << MSR_LINK_SHIFT);\n\t\telse if (priv->ieee80211->iw_mode == IW_MODE_MASTER)\n\t\t\tmsr |= (MSR_LINK_MASTER << MSR_LINK_SHIFT);\n\n\t} else {\n\t\tmsr |= (MSR_LINK_NONE << MSR_LINK_SHIFT);\n\t}\n\n\twrite_nic_byte(dev, MSR, msr);\n}\n\nvoid rtl8192_set_chan(struct net_device *dev, short ch)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\n\tRT_TRACE(COMP_CH, \"=====>%s()====ch:%d\\n\", __func__, ch);\n\tpriv->chan = ch;\n\n\t \n\n\t \n\n\tif (priv->rf_set_chan)\n\t\tpriv->rf_set_chan(dev, priv->chan);\n\tmdelay(10);\n}\n\nstatic void rtl8192_rx_isr(struct urb *urb);\n\nstatic u32 get_rxpacket_shiftbytes_819xusb(struct ieee80211_rx_stats *pstats)\n{\n\treturn (sizeof(struct rx_desc_819x_usb) + pstats->RxDrvInfoSize\n\t\t+ pstats->RxBufShift);\n}\n\nvoid rtl8192_rx_enable(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct urb *entry;\n\tstruct sk_buff *skb;\n\tstruct rtl8192_rx_info *info;\n\n\t \n\twhile (skb_queue_len(&priv->rx_queue) < MAX_RX_URB) {\n\t\tskb = __dev_alloc_skb(RX_URB_SIZE, GFP_KERNEL);\n\t\tif (!skb)\n\t\t\tbreak;\n\t\tentry = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!entry) {\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\t\tusb_fill_bulk_urb(entry, priv->udev,\n\t\t\t\t  usb_rcvbulkpipe(priv->udev, 3),\n\t\t\t\t  skb_tail_pointer(skb),\n\t\t\t\t  RX_URB_SIZE, rtl8192_rx_isr, skb);\n\t\tinfo = (struct rtl8192_rx_info *)skb->cb;\n\t\tinfo->urb = entry;\n\t\tinfo->dev = dev;\n\t\tinfo->out_pipe = 3;  \n\t\tskb_queue_tail(&priv->rx_queue, skb);\n\t\tusb_submit_urb(entry, GFP_KERNEL);\n\t}\n\n\t \n\twhile (skb_queue_len(&priv->rx_queue) < MAX_RX_URB + 3) {\n\t\tskb = __dev_alloc_skb(RX_URB_SIZE, GFP_KERNEL);\n\t\tif (!skb)\n\t\t\tbreak;\n\t\tentry = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!entry) {\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\t\tusb_fill_bulk_urb(entry, priv->udev,\n\t\t\t\t  usb_rcvbulkpipe(priv->udev, 9),\n\t\t\t\t  skb_tail_pointer(skb),\n\t\t\t\t  RX_URB_SIZE, rtl8192_rx_isr, skb);\n\t\tinfo = (struct rtl8192_rx_info *)skb->cb;\n\t\tinfo->urb = entry;\n\t\tinfo->dev = dev;\n\t\tinfo->out_pipe = 9;  \n\t\tskb_queue_tail(&priv->rx_queue, skb);\n\t\tusb_submit_urb(entry, GFP_KERNEL);\n\t}\n}\n\nvoid rtl8192_set_rxconf(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tu32 rxconf;\n\n\tread_nic_dword(dev, RCR, &rxconf);\n\trxconf = rxconf & ~MAC_FILTER_MASK;\n\trxconf = rxconf | RCR_AMF;\n\trxconf = rxconf | RCR_ADF;\n\trxconf = rxconf | RCR_AB;\n\trxconf = rxconf | RCR_AM;\n\n\tif (dev->flags & IFF_PROMISC)\n\t\tDMESG(\"NIC in promisc mode\");\n\n\tif (priv->ieee80211->iw_mode == IW_MODE_MONITOR ||\n\t    dev->flags & IFF_PROMISC) {\n\t\trxconf = rxconf | RCR_AAP;\n\t} else {\n\t\trxconf = rxconf | RCR_APM;\n\t\trxconf = rxconf | RCR_CBSSID;\n\t}\n\n\tif (priv->ieee80211->iw_mode == IW_MODE_MONITOR) {\n\t\trxconf = rxconf | RCR_AICV;\n\t\trxconf = rxconf | RCR_APWRMGT;\n\t}\n\n\tif (priv->crcmon == 1 && priv->ieee80211->iw_mode == IW_MODE_MONITOR)\n\t\trxconf = rxconf | RCR_ACRC32;\n\n\trxconf = rxconf & ~RX_FIFO_THRESHOLD_MASK;\n\trxconf = rxconf | (RX_FIFO_THRESHOLD_NONE << RX_FIFO_THRESHOLD_SHIFT);\n\trxconf = rxconf & ~MAX_RX_DMA_MASK;\n\trxconf = rxconf | ((u32)7 << RCR_MXDMA_OFFSET);\n\n\trxconf = rxconf | RCR_ONLYERLPKT;\n\n\twrite_nic_dword(dev, RCR, rxconf);\n}\n\nvoid rtl8192_rtx_disable(struct net_device *dev)\n{\n\tu8 cmd;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct sk_buff *skb;\n\tstruct rtl8192_rx_info *info;\n\n\tread_nic_byte(dev, CMDR, &cmd);\n\twrite_nic_byte(dev, CMDR, cmd & ~(CR_TE | CR_RE));\n\tforce_pci_posting(dev);\n\tmdelay(10);\n\n\twhile ((skb = __skb_dequeue(&priv->rx_queue))) {\n\t\tinfo = (struct rtl8192_rx_info *)skb->cb;\n\t\tif (!info->urb)\n\t\t\tcontinue;\n\n\t\tusb_kill_urb(info->urb);\n\t\tkfree_skb(skb);\n\t}\n\n\tif (skb_queue_len(&priv->skb_queue))\n\t\tnetdev_warn(dev, \"skb_queue not empty\\n\");\n\n\tskb_queue_purge(&priv->skb_queue);\n}\n\n \nstatic void rtl8192_rx_isr(struct urb *urb)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)urb->context;\n\tstruct rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;\n\tstruct net_device *dev = info->dev;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint out_pipe = info->out_pipe;\n\tint err;\n\n\tif (!priv->up)\n\t\treturn;\n\n\tif (unlikely(urb->status)) {\n\t\tinfo->urb = NULL;\n\t\tpriv->stats.rxstaterr++;\n\t\tpriv->ieee80211->stats.rx_errors++;\n\t\tusb_free_urb(urb);\n\t\treturn;\n\t}\n\tskb_unlink(skb, &priv->rx_queue);\n\tskb_put(skb, urb->actual_length);\n\n\tskb_queue_tail(&priv->skb_queue, skb);\n\ttasklet_schedule(&priv->irq_rx_tasklet);\n\n\tskb = dev_alloc_skb(RX_URB_SIZE);\n\tif (unlikely(!skb)) {\n\t\tusb_free_urb(urb);\n\t\tnetdev_err(dev, \"%s(): can't alloc skb\\n\", __func__);\n\t\t \n\t\treturn;\n\t}\n\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_rcvbulkpipe(priv->udev, out_pipe),\n\t\t\t  skb_tail_pointer(skb),\n\t\t\t  RX_URB_SIZE, rtl8192_rx_isr, skb);\n\n\tinfo = (struct rtl8192_rx_info *)skb->cb;\n\tinfo->urb = urb;\n\tinfo->dev = dev;\n\tinfo->out_pipe = out_pipe;\n\n\turb->transfer_buffer = skb_tail_pointer(skb);\n\turb->context = skb;\n\tskb_queue_tail(&priv->rx_queue, skb);\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err && err != -EPERM)\n\t\tnetdev_err(dev,\n\t\t\t   \"can not submit rxurb, err is %x, URB status is %x\\n\",\n\t\t\t   err, urb->status);\n}\n\nstatic u32 rtl819xusb_rx_command_packet(struct net_device *dev,\n\t\t\t\t\tstruct ieee80211_rx_stats *pstats)\n{\n\tu32\tstatus;\n\n\tstatus = cmpk_message_handle_rx(dev, pstats);\n\tif (status)\n\t\tDMESG(\"rxcommandpackethandle819xusb: It is a command packet\\n\");\n\n\treturn status;\n}\n\nstatic void rtl8192_data_hard_stop(struct net_device *dev)\n{\n\t \n}\n\nstatic void rtl8192_data_hard_resume(struct net_device *dev)\n{\n\t \n}\n\n \nstatic void rtl8192_hard_data_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t   int rate)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tunsigned long flags;\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\tu8 queue_index = tcb_desc->queue_index;\n\n\t \n\tRTL8192U_ASSERT(queue_index != TXCMD_QUEUE);\n\n\tspin_lock_irqsave(&priv->tx_lock, flags);\n\n\t*(struct net_device **)(skb->cb) = dev;\n\ttcb_desc->bTxEnableFwCalcDur = 1;\n\tskb_push(skb, priv->ieee80211->tx_headroom);\n\trtl8192_tx(dev, skb);\n\n\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n}\n\n \nstatic int rtl8192_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tint ret;\n\tunsigned long flags;\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\tu8 queue_index = tcb_desc->queue_index;\n\n\tspin_lock_irqsave(&priv->tx_lock, flags);\n\n\tmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\n\tif (queue_index == TXCMD_QUEUE) {\n\t\tskb_push(skb, USB_HWDESC_HEADER_LEN);\n\t\trtl819xU_tx_cmd(dev, skb);\n\t\tret = 1;\n\t} else {\n\t\tskb_push(skb, priv->ieee80211->tx_headroom);\n\t\tret = rtl8192_tx(dev, skb);\n\t}\n\n\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\n\treturn ret;\n}\n\nstatic void rtl8192_tx_isr(struct urb *tx_urb)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)tx_urb->context;\n\tstruct net_device *dev;\n\tstruct r8192_priv *priv = NULL;\n\tstruct cb_desc *tcb_desc;\n\tu8  queue_index;\n\n\tif (!skb)\n\t\treturn;\n\n\tdev = *(struct net_device **)(skb->cb);\n\ttcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\tqueue_index = tcb_desc->queue_index;\n\n\tpriv = ieee80211_priv(dev);\n\n\tif (tcb_desc->queue_index != TXCMD_QUEUE) {\n\t\tif (tx_urb->status == 0) {\n\t\t\tnetif_trans_update(dev);\n\t\t\tpriv->stats.txoktotal++;\n\t\t\tpriv->ieee80211->LinkDetectInfo.NumTxOkInPeriod++;\n\t\t\tpriv->stats.txbytesunicast +=\n\t\t\t\t(skb->len - priv->ieee80211->tx_headroom);\n\t\t} else {\n\t\t\tpriv->ieee80211->stats.tx_errors++;\n\t\t\t \n\t\t}\n\t}\n\n\t \n\tdev_kfree_skb_any(skb);\n\tusb_free_urb(tx_urb);\n\tatomic_dec(&priv->tx_pending[queue_index]);\n\n\t \n\n\t \n\tif (queue_index != BEACON_QUEUE) {\n\t\t \n\t\tif ((skb_queue_len(&priv->ieee80211->skb_waitQ[queue_index]) != 0) &&\n\t\t    (!(priv->ieee80211->queue_stop))) {\n\t\t\tskb = skb_dequeue(&(priv->ieee80211->skb_waitQ[queue_index]));\n\t\t\tif (skb)\n\t\t\t\tpriv->ieee80211->softmac_hard_start_xmit(skb,\n\t\t\t\t\t\t\t\t\t dev);\n\n\t\t\treturn;  \n\t\t}\n\t}\n}\n\nstatic void rtl8192_config_rate(struct net_device *dev, u16 *rate_config)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct ieee80211_network *net;\n\tu8 i = 0, basic_rate = 0;\n\n\tnet = &priv->ieee80211->current_network;\n\n\tfor (i = 0; i < net->rates_len; i++) {\n\t\tbasic_rate = net->rates[i] & 0x7f;\n\t\tswitch (basic_rate) {\n\t\tcase MGN_1M:\n\t\t\t*rate_config |= RRSR_1M;\n\t\t\tbreak;\n\t\tcase MGN_2M:\n\t\t\t*rate_config |= RRSR_2M;\n\t\t\tbreak;\n\t\tcase MGN_5_5M:\n\t\t\t*rate_config |= RRSR_5_5M;\n\t\t\tbreak;\n\t\tcase MGN_11M:\n\t\t\t*rate_config |= RRSR_11M;\n\t\t\tbreak;\n\t\tcase MGN_6M:\n\t\t\t*rate_config |= RRSR_6M;\n\t\t\tbreak;\n\t\tcase MGN_9M:\n\t\t\t*rate_config |= RRSR_9M;\n\t\t\tbreak;\n\t\tcase MGN_12M:\n\t\t\t*rate_config |= RRSR_12M;\n\t\t\tbreak;\n\t\tcase MGN_18M:\n\t\t\t*rate_config |= RRSR_18M;\n\t\t\tbreak;\n\t\tcase MGN_24M:\n\t\t\t*rate_config |= RRSR_24M;\n\t\t\tbreak;\n\t\tcase MGN_36M:\n\t\t\t*rate_config |= RRSR_36M;\n\t\t\tbreak;\n\t\tcase MGN_48M:\n\t\t\t*rate_config |= RRSR_48M;\n\t\t\tbreak;\n\t\tcase MGN_54M:\n\t\t\t*rate_config |= RRSR_54M;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 0; i < net->rates_ex_len; i++) {\n\t\tbasic_rate = net->rates_ex[i] & 0x7f;\n\t\tswitch (basic_rate) {\n\t\tcase MGN_1M:\n\t\t\t*rate_config |= RRSR_1M;\n\t\t\tbreak;\n\t\tcase MGN_2M:\n\t\t\t*rate_config |= RRSR_2M;\n\t\t\tbreak;\n\t\tcase MGN_5_5M:\n\t\t\t*rate_config |= RRSR_5_5M;\n\t\t\tbreak;\n\t\tcase MGN_11M:\n\t\t\t*rate_config |= RRSR_11M;\n\t\t\tbreak;\n\t\tcase MGN_6M:\n\t\t\t*rate_config |= RRSR_6M;\n\t\t\tbreak;\n\t\tcase MGN_9M:\n\t\t\t*rate_config |= RRSR_9M;\n\t\t\tbreak;\n\t\tcase MGN_12M:\n\t\t\t*rate_config |= RRSR_12M;\n\t\t\tbreak;\n\t\tcase MGN_18M:\n\t\t\t*rate_config |= RRSR_18M;\n\t\t\tbreak;\n\t\tcase MGN_24M:\n\t\t\t*rate_config |= RRSR_24M;\n\t\t\tbreak;\n\t\tcase MGN_36M:\n\t\t\t*rate_config |= RRSR_36M;\n\t\t\tbreak;\n\t\tcase MGN_48M:\n\t\t\t*rate_config |= RRSR_48M;\n\t\t\tbreak;\n\t\tcase MGN_54M:\n\t\t\t*rate_config |= RRSR_54M;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n#define SHORT_SLOT_TIME 9\n#define NON_SHORT_SLOT_TIME 20\n\nstatic void rtl8192_update_cap(struct net_device *dev, u16 cap)\n{\n\tu32 tmp = 0;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct ieee80211_network *net = &priv->ieee80211->current_network;\n\n\tpriv->short_preamble = cap & WLAN_CAPABILITY_SHORT_PREAMBLE;\n\ttmp = priv->basic_rate;\n\tif (priv->short_preamble)\n\t\ttmp |= BRSR_AckShortPmb;\n\twrite_nic_dword(dev, RRSR, tmp);\n\n\tif (net->mode & (IEEE_G | IEEE_N_24G)) {\n\t\tu8 slot_time = 0;\n\n\t\tif ((cap & WLAN_CAPABILITY_SHORT_SLOT) &&\n\t\t    (!priv->ieee80211->pHTInfo->bCurrentRT2RTLongSlotTime))\n\t\t\t \n\t\t\tslot_time = SHORT_SLOT_TIME;\n\t\telse\t \n\t\t\tslot_time = NON_SHORT_SLOT_TIME;\n\t\tpriv->slot_time = slot_time;\n\t\twrite_nic_byte(dev, SLOT_TIME, slot_time);\n\t}\n}\n\nstatic void rtl8192_net_update(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct ieee80211_network *net;\n\tu16 BcnTimeCfg = 0, BcnCW = 6, BcnIFS = 0xf;\n\tu16 rate_config = 0;\n\n\tnet = &priv->ieee80211->current_network;\n\n\trtl8192_config_rate(dev, &rate_config);\n\tpriv->basic_rate = rate_config & 0x15f;\n\n\twrite_nic_dword(dev, BSSIDR, ((u32 *)net->bssid)[0]);\n\twrite_nic_word(dev, BSSIDR + 4, ((u16 *)net->bssid)[2]);\n\n\trtl8192_update_msr(dev);\n\tif (priv->ieee80211->iw_mode == IW_MODE_ADHOC) {\n\t\twrite_nic_word(dev, ATIMWND, 2);\n\t\twrite_nic_word(dev, BCN_DMATIME, 1023);\n\t\twrite_nic_word(dev, BCN_INTERVAL, net->beacon_interval);\n\t\twrite_nic_word(dev, BCN_DRV_EARLY_INT, 1);\n\t\twrite_nic_byte(dev, BCN_ERR_THRESH, 100);\n\t\tBcnTimeCfg |= (BcnCW << BCN_TCFG_CW_SHIFT);\n\t\t \n\t\tBcnTimeCfg |= BcnIFS << BCN_TCFG_IFS;\n\n\t\twrite_nic_word(dev, BCN_TCFG, BcnTimeCfg);\n\t}\n}\n\n \nvoid rtl819xusb_beacon_tx(struct net_device *dev, u16  tx_rate)\n{\n}\n\nshort rtl819xU_tx_cmd(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint\t\t\tstatus;\n\tstruct urb\t\t*tx_urb;\n\tunsigned int\t\tidx_pipe;\n\tstruct tx_desc_cmd_819x_usb *pdesc = (struct tx_desc_cmd_819x_usb *)skb->data;\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\tu8 queue_index = tcb_desc->queue_index;\n\n\tatomic_inc(&priv->tx_pending[queue_index]);\n\ttx_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!tx_urb) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(pdesc, 0, USB_HWDESC_HEADER_LEN);\n\t \n\tpdesc->FirstSeg = 1;\n\tpdesc->LastSeg = 1;\n\tpdesc->CmdInit = tcb_desc->bCmdOrInit;\n\tpdesc->TxBufferSize = tcb_desc->txbuf_size;\n\tpdesc->OWN = 1;\n\tpdesc->LINIP = tcb_desc->bLastIniPkt;\n\n\t \n\tidx_pipe = 0x04;\n\tusb_fill_bulk_urb(tx_urb, priv->udev,\n\t\t\t  usb_sndbulkpipe(priv->udev, idx_pipe),\n\t\t\t  skb->data, skb->len, rtl8192_tx_isr, skb);\n\n\tstatus = usb_submit_urb(tx_urb, GFP_ATOMIC);\n\n\tif (!status)\n\t\treturn 0;\n\n\tDMESGE(\"Error TX CMD URB, error %d\", status);\n\tdev_kfree_skb(skb);\n\tusb_free_urb(tx_urb);\n\treturn -1;\n}\n\n \nstatic u8 MapHwQueueToFirmwareQueue(u8 QueueID)\n{\n\tu8 QueueSelect = 0x0;        \n\n\tswitch (QueueID) {\n\tcase BE_QUEUE:\n\t\tQueueSelect = QSLT_BE;\n\t\tbreak;\n\n\tcase BK_QUEUE:\n\t\tQueueSelect = QSLT_BK;\n\t\tbreak;\n\n\tcase VO_QUEUE:\n\t\tQueueSelect = QSLT_VO;\n\t\tbreak;\n\n\tcase VI_QUEUE:\n\t\tQueueSelect = QSLT_VI;\n\t\tbreak;\n\tcase MGNT_QUEUE:\n\t\tQueueSelect = QSLT_MGNT;\n\t\tbreak;\n\n\tcase BEACON_QUEUE:\n\t\tQueueSelect = QSLT_BEACON;\n\t\tbreak;\n\n\t\t \n\t\t \n\tcase TXCMD_QUEUE:\n\t\tQueueSelect = QSLT_CMD;\n\t\tbreak;\n\tcase HIGH_QUEUE:\n\t\tQueueSelect = QSLT_HIGH;\n\t\tbreak;\n\n\tdefault:\n\t\tRT_TRACE(COMP_ERR,\n\t\t\t \"TransmitTCB(): Impossible Queue Selection: %d\\n\",\n\t\t\t QueueID);\n\t\tbreak;\n\t}\n\treturn QueueSelect;\n}\n\nstatic u8 MRateToHwRate8190Pci(u8 rate)\n{\n\tu8  ret = DESC90_RATE1M;\n\n\tswitch (rate) {\n\tcase MGN_1M:\n\t\tret = DESC90_RATE1M;\n\t\tbreak;\n\tcase MGN_2M:\n\t\tret = DESC90_RATE2M;\n\t\tbreak;\n\tcase MGN_5_5M:\n\t\tret = DESC90_RATE5_5M;\n\t\tbreak;\n\tcase MGN_11M:\n\t\tret = DESC90_RATE11M;\n\t\tbreak;\n\tcase MGN_6M:\n\t\tret = DESC90_RATE6M;\n\t\tbreak;\n\tcase MGN_9M:\n\t\tret = DESC90_RATE9M;\n\t\tbreak;\n\tcase MGN_12M:\n\t\tret = DESC90_RATE12M;\n\t\tbreak;\n\tcase MGN_18M:\n\t\tret = DESC90_RATE18M;\n\t\tbreak;\n\tcase MGN_24M:\n\t\tret = DESC90_RATE24M;\n\t\tbreak;\n\tcase MGN_36M:\n\t\tret = DESC90_RATE36M;\n\t\tbreak;\n\tcase MGN_48M:\n\t\tret = DESC90_RATE48M;\n\t\tbreak;\n\tcase MGN_54M:\n\t\tret = DESC90_RATE54M;\n\t\tbreak;\n\n\t \n\tcase MGN_MCS0:\n\t\tret = DESC90_RATEMCS0;\n\t\tbreak;\n\tcase MGN_MCS1:\n\t\tret = DESC90_RATEMCS1;\n\t\tbreak;\n\tcase MGN_MCS2:\n\t\tret = DESC90_RATEMCS2;\n\t\tbreak;\n\tcase MGN_MCS3:\n\t\tret = DESC90_RATEMCS3;\n\t\tbreak;\n\tcase MGN_MCS4:\n\t\tret = DESC90_RATEMCS4;\n\t\tbreak;\n\tcase MGN_MCS5:\n\t\tret = DESC90_RATEMCS5;\n\t\tbreak;\n\tcase MGN_MCS6:\n\t\tret = DESC90_RATEMCS6;\n\t\tbreak;\n\tcase MGN_MCS7:\n\t\tret = DESC90_RATEMCS7;\n\t\tbreak;\n\tcase MGN_MCS8:\n\t\tret = DESC90_RATEMCS8;\n\t\tbreak;\n\tcase MGN_MCS9:\n\t\tret = DESC90_RATEMCS9;\n\t\tbreak;\n\tcase MGN_MCS10:\n\t\tret = DESC90_RATEMCS10;\n\t\tbreak;\n\tcase MGN_MCS11:\n\t\tret = DESC90_RATEMCS11;\n\t\tbreak;\n\tcase MGN_MCS12:\n\t\tret = DESC90_RATEMCS12;\n\t\tbreak;\n\tcase MGN_MCS13:\n\t\tret = DESC90_RATEMCS13;\n\t\tbreak;\n\tcase MGN_MCS14:\n\t\tret = DESC90_RATEMCS14;\n\t\tbreak;\n\tcase MGN_MCS15:\n\t\tret = DESC90_RATEMCS15;\n\t\tbreak;\n\tcase (0x80 | 0x20):\n\t\tret = DESC90_RATEMCS32;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic u8 QueryIsShort(u8 TxHT, u8 TxRate, struct cb_desc *tcb_desc)\n{\n\tu8   tmp_Short;\n\n\ttmp_Short = (TxHT == 1) ?\n\t\t\t((tcb_desc->bUseShortGI) ? 1 : 0) :\n\t\t\t((tcb_desc->bUseShortPreamble) ? 1 : 0);\n\n\tif (TxHT == 1 && TxRate != DESC90_RATEMCS15)\n\t\ttmp_Short = 0;\n\n\treturn tmp_Short;\n}\n\nstatic void tx_zero_isr(struct urb *tx_urb)\n{\n}\n\n \nshort rtl8192_tx(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\tstruct tx_desc_819x_usb *tx_desc = (struct tx_desc_819x_usb *)skb->data;\n\tstruct tx_fwinfo_819x_usb *tx_fwinfo =\n\t\t(struct tx_fwinfo_819x_usb *)(skb->data + USB_HWDESC_HEADER_LEN);\n\tstruct usb_device *udev = priv->udev;\n\tint pend;\n\tint status, rt = -1;\n\tstruct urb *tx_urb = NULL, *tx_urb_zero = NULL;\n\tunsigned int idx_pipe;\n\n\tpend = atomic_read(&priv->tx_pending[tcb_desc->queue_index]);\n\t \n\tif (pend > MAX_TX_URB) {\n\t\tnetdev_dbg(dev, \"To discard skb packet!\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -1;\n\t}\n\n\ttx_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!tx_urb) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmemset(tx_fwinfo, 0, sizeof(struct tx_fwinfo_819x_usb));\n\t \n\ttx_fwinfo->TxHT = (tcb_desc->data_rate & 0x80) ? 1 : 0;\n\ttx_fwinfo->TxRate = MRateToHwRate8190Pci(tcb_desc->data_rate);\n\ttx_fwinfo->EnableCPUDur = tcb_desc->bTxEnableFwCalcDur;\n\ttx_fwinfo->Short = QueryIsShort(tx_fwinfo->TxHT, tx_fwinfo->TxRate,\n\t\t\t\t\ttcb_desc);\n\tif (tcb_desc->bAMPDUEnable) {  \n\t\ttx_fwinfo->AllowAggregation = 1;\n\t\t \n\t\ttx_fwinfo->RxMF = tcb_desc->ampdu_factor;\n\t\ttx_fwinfo->RxAMD = tcb_desc->ampdu_density & 0x07;\n\t} else {\n\t\ttx_fwinfo->AllowAggregation = 0;\n\t\t \n\t\ttx_fwinfo->RxMF = 0;\n\t\ttx_fwinfo->RxAMD = 0;\n\t}\n\n\t \n\ttx_fwinfo->RtsEnable = (tcb_desc->bRTSEnable) ? 1 : 0;\n\ttx_fwinfo->CtsEnable = (tcb_desc->bCTSEnable) ? 1 : 0;\n\ttx_fwinfo->RtsSTBC = (tcb_desc->bRTSSTBC) ? 1 : 0;\n\ttx_fwinfo->RtsHT = (tcb_desc->rts_rate & 0x80) ? 1 : 0;\n\ttx_fwinfo->RtsRate =  MRateToHwRate8190Pci((u8)tcb_desc->rts_rate);\n\ttx_fwinfo->RtsSubcarrier = (tx_fwinfo->RtsHT == 0) ? (tcb_desc->RTSSC) : 0;\n\ttx_fwinfo->RtsBandwidth = (tx_fwinfo->RtsHT == 1) ? ((tcb_desc->bRTSBW) ? 1 : 0) : 0;\n\ttx_fwinfo->RtsShort = (tx_fwinfo->RtsHT == 0) ? (tcb_desc->bRTSUseShortPreamble ? 1 : 0) :\n\t\t\t      (tcb_desc->bRTSUseShortGI ? 1 : 0);\n\n\t \n\tif (priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20_40) {\n\t\tif (tcb_desc->bPacketBW) {\n\t\t\ttx_fwinfo->TxBandwidth = 1;\n\t\t\t \n\t\t\ttx_fwinfo->TxSubCarrier = 0;\n\t\t} else {\n\t\t\ttx_fwinfo->TxBandwidth = 0;\n\t\t\ttx_fwinfo->TxSubCarrier = priv->nCur40MhzPrimeSC;\n\t\t}\n\t} else {\n\t\ttx_fwinfo->TxBandwidth = 0;\n\t\ttx_fwinfo->TxSubCarrier = 0;\n\t}\n\n\t \n\tmemset(tx_desc, 0, sizeof(struct tx_desc_819x_usb));\n\t \n\ttx_desc->LINIP = 0;\n\ttx_desc->CmdInit = 1;\n\ttx_desc->Offset =  sizeof(struct tx_fwinfo_819x_usb) + 8;\n\ttx_desc->PktSize = (skb->len - TX_PACKET_SHIFT_BYTES) & 0xffff;\n\n\t \n\ttx_desc->SecCAMID = 0;\n\ttx_desc->RATid = tcb_desc->RATRIndex;\n\ttx_desc->NoEnc = 1;\n\ttx_desc->SecType = 0x0;\n\tif (tcb_desc->bHwSec) {\n\t\tswitch (priv->ieee80211->pairwise_key_type) {\n\t\tcase KEY_TYPE_WEP40:\n\t\tcase KEY_TYPE_WEP104:\n\t\t\ttx_desc->SecType = 0x1;\n\t\t\ttx_desc->NoEnc = 0;\n\t\t\tbreak;\n\t\tcase KEY_TYPE_TKIP:\n\t\t\ttx_desc->SecType = 0x2;\n\t\t\ttx_desc->NoEnc = 0;\n\t\t\tbreak;\n\t\tcase KEY_TYPE_CCMP:\n\t\t\ttx_desc->SecType = 0x3;\n\t\t\ttx_desc->NoEnc = 0;\n\t\t\tbreak;\n\t\tcase KEY_TYPE_NA:\n\t\t\ttx_desc->SecType = 0x0;\n\t\t\ttx_desc->NoEnc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttx_desc->QueueSelect = MapHwQueueToFirmwareQueue(tcb_desc->queue_index);\n\ttx_desc->TxFWInfoSize =  sizeof(struct tx_fwinfo_819x_usb);\n\n\ttx_desc->DISFB = tcb_desc->bTxDisableRateFallBack;\n\ttx_desc->USERATE = tcb_desc->bTxUseDriverAssingedRate;\n\n\t \n\t \n\ttx_desc->FirstSeg = 1;\n\ttx_desc->LastSeg = 1;\n\ttx_desc->OWN = 1;\n\n\t \n\ttx_desc->TxBufferSize = (u32)(skb->len - USB_HWDESC_HEADER_LEN);\n\tidx_pipe = 0x5;\n\n\t \n\tusb_fill_bulk_urb(tx_urb, udev,\n\t\t\t  usb_sndbulkpipe(udev, idx_pipe), skb->data,\n\t\t\t  skb->len, rtl8192_tx_isr, skb);\n\n\tstatus = usb_submit_urb(tx_urb, GFP_ATOMIC);\n\tif (!status) {\n\t\t \n\t\tbool bSend0Byte = false;\n\t\tu8 zero = 0;\n\n\t\tif (udev->speed == USB_SPEED_HIGH) {\n\t\t\tif (skb->len > 0 && skb->len % 512 == 0)\n\t\t\t\tbSend0Byte = true;\n\t\t} else {\n\t\t\tif (skb->len > 0 && skb->len % 64 == 0)\n\t\t\t\tbSend0Byte = true;\n\t\t}\n\t\tif (bSend0Byte) {\n\t\t\ttx_urb_zero = usb_alloc_urb(0, GFP_ATOMIC);\n\t\t\tif (!tx_urb_zero) {\n\t\t\t\trt = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tusb_fill_bulk_urb(tx_urb_zero, udev,\n\t\t\t\t\t  usb_sndbulkpipe(udev, idx_pipe),\n\t\t\t\t\t  &zero, 0, tx_zero_isr, dev);\n\t\t\tstatus = usb_submit_urb(tx_urb_zero, GFP_ATOMIC);\n\t\t\tif (status) {\n\t\t\t\tRT_TRACE(COMP_ERR,\n\t\t\t\t\t \"Error TX URB for zero byte %d, error %d\",\n\t\t\t\t\t atomic_read(&priv->tx_pending[tcb_desc->queue_index]),\n\t\t\t\t\t status);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tnetif_trans_update(dev);\n\t\tatomic_inc(&priv->tx_pending[tcb_desc->queue_index]);\n\t\treturn 0;\n\t}\n\n\tRT_TRACE(COMP_ERR, \"Error TX URB %d, error %d\",\n\t\t atomic_read(&priv->tx_pending[tcb_desc->queue_index]),\n\t\t status);\n\nerror:\n\tdev_kfree_skb_any(skb);\n\tusb_free_urb(tx_urb);\n\tusb_free_urb(tx_urb_zero);\n\treturn rt;\n}\n\nstatic short rtl8192_usb_initendpoints(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tpriv->rx_urb = kmalloc_array(MAX_RX_URB + 1, sizeof(struct urb *),\n\t\t\t\t     GFP_KERNEL);\n\tif (!priv->rx_urb)\n\t\treturn -ENOMEM;\n\n#ifndef JACKSON_NEW_RX\n\tfor (i = 0; i < (MAX_RX_URB + 1); i++) {\n\t\tpriv->rx_urb[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!priv->rx_urb[i])\n\t\t\treturn -ENOMEM;\n\n\t\tpriv->rx_urb[i]->transfer_buffer =\n\t\t\tkmalloc(RX_URB_SIZE, GFP_KERNEL);\n\t\tif (!priv->rx_urb[i]->transfer_buffer)\n\t\t\treturn -ENOMEM;\n\n\t\tpriv->rx_urb[i]->transfer_buffer_length = RX_URB_SIZE;\n\t}\n#endif\n\n#ifdef THOMAS_BEACON\n\t{\n\t\tlong align = 0;\n\t\tvoid *oldaddr, *newaddr;\n\n\t\tpriv->rx_urb[16] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!priv->rx_urb[16])\n\t\t\treturn -ENOMEM;\n\t\tpriv->oldaddr = kmalloc(16, GFP_KERNEL);\n\t\tif (!priv->oldaddr)\n\t\t\treturn -ENOMEM;\n\t\toldaddr = priv->oldaddr;\n\t\talign = ((long)oldaddr) & 3;\n\t\tif (align) {\n\t\t\tnewaddr = oldaddr + 4 - align;\n\t\t\tpriv->rx_urb[16]->transfer_buffer_length = 16 - 4 + align;\n\t\t} else {\n\t\t\tnewaddr = oldaddr;\n\t\t\tpriv->rx_urb[16]->transfer_buffer_length = 16;\n\t\t}\n\t\tpriv->rx_urb[16]->transfer_buffer = newaddr;\n\t}\n#endif\n\n\tmemset(priv->rx_urb, 0, sizeof(struct urb *) * MAX_RX_URB);\n\tpriv->pp_rxskb = kcalloc(MAX_RX_URB, sizeof(struct sk_buff *),\n\t\t\t\t GFP_KERNEL);\n\tif (!priv->pp_rxskb) {\n\t\tkfree(priv->rx_urb);\n\n\t\tpriv->pp_rxskb = NULL;\n\t\tpriv->rx_urb = NULL;\n\n\t\tDMESGE(\"Endpoint Alloc Failure\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnetdev_dbg(dev, \"End of initendpoints\\n\");\n\treturn 0;\n}\n\n#ifdef THOMAS_BEACON\nstatic void rtl8192_usb_deleteendpoints(struct net_device *dev)\n{\n\tint i;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tif (priv->rx_urb) {\n\t\tfor (i = 0; i < (MAX_RX_URB + 1); i++) {\n\t\t\tusb_kill_urb(priv->rx_urb[i]);\n\t\t\tusb_free_urb(priv->rx_urb[i]);\n\t\t}\n\t\tkfree(priv->rx_urb);\n\t\tpriv->rx_urb = NULL;\n\t}\n\tkfree(priv->oldaddr);\n\tpriv->oldaddr = NULL;\n\n\tkfree(priv->pp_rxskb);\n\tpriv->pp_rxskb = NULL;\n}\n#else\nvoid rtl8192_usb_deleteendpoints(struct net_device *dev)\n{\n\tint i;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n#ifndef JACKSON_NEW_RX\n\n\tif (priv->rx_urb) {\n\t\tfor (i = 0; i < (MAX_RX_URB + 1); i++) {\n\t\t\tusb_kill_urb(priv->rx_urb[i]);\n\t\t\tkfree(priv->rx_urb[i]->transfer_buffer);\n\t\t\tusb_free_urb(priv->rx_urb[i]);\n\t\t}\n\t\tkfree(priv->rx_urb);\n\t\tpriv->rx_urb = NULL;\n\t}\n#else\n\tkfree(priv->rx_urb);\n\tpriv->rx_urb = NULL;\n\tkfree(priv->oldaddr);\n\tpriv->oldaddr = NULL;\n\n\tkfree(priv->pp_rxskb);\n\tpriv->pp_rxskb = 0;\n\n#endif\n}\n#endif\n\nstatic void rtl8192_update_ratr_table(struct net_device *dev);\nstatic void rtl8192_link_change(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\n\tif (ieee->state == IEEE80211_LINKED) {\n\t\trtl8192_net_update(dev);\n\t\trtl8192_update_ratr_table(dev);\n\t\t \n\t\tif (ieee->pairwise_key_type == KEY_TYPE_WEP40 ||\n\t\t    ieee->pairwise_key_type == KEY_TYPE_WEP104)\n\t\t\tEnableHWSecurityConfig8192(dev);\n\t}\n\t \n\tif (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC) {\n\t\tu32 reg = 0;\n\n\t\tread_nic_dword(dev, RCR, &reg);\n\t\tif (priv->ieee80211->state == IEEE80211_LINKED)\n\t\t\tpriv->ReceiveConfig = reg |= RCR_CBSSID;\n\t\telse\n\t\t\tpriv->ReceiveConfig = reg &= ~RCR_CBSSID;\n\t\twrite_nic_dword(dev, RCR, reg);\n\t}\n}\n\nstatic const struct ieee80211_qos_parameters def_qos_parameters = {\n\t{cpu_to_le16(3), cpu_to_le16(3), cpu_to_le16(3), cpu_to_le16(3)},\n\t{cpu_to_le16(7), cpu_to_le16(7), cpu_to_le16(7), cpu_to_le16(7)},\n\t{2, 2, 2, 2}, \n\t{0, 0, 0, 0}, \n\t{0, 0, 0, 0}  \n};\n\nstatic void rtl8192_update_beacon(struct work_struct *work)\n{\n\tstruct r8192_priv *priv = container_of(work, struct r8192_priv,\n\t\t\t\t\t       update_beacon_wq.work);\n\tstruct net_device *dev = priv->ieee80211->dev;\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\tstruct ieee80211_network *net = &ieee->current_network;\n\n\tif (ieee->pHTInfo->bCurrentHTSupport)\n\t\tHTUpdateSelfAndPeerSetting(ieee, net);\n\tieee->pHTInfo->bCurrentRT2RTLongSlotTime =\n\t\tnet->bssht.bdRT2RTLongSlotTime;\n\trtl8192_update_cap(dev, net->capability);\n}\n\n \nstatic int WDCAPARA_ADD[] = {EDCAPARA_BE, EDCAPARA_BK,\n\t\t\t     EDCAPARA_VI, EDCAPARA_VO};\nstatic void rtl8192_qos_activate(struct work_struct *work)\n{\n\tstruct r8192_priv *priv = container_of(work, struct r8192_priv,\n\t\t\t\t\t       qos_activate);\n\tstruct net_device *dev = priv->ieee80211->dev;\n\tstruct ieee80211_qos_parameters *qos_parameters =\n\t\t&priv->ieee80211->current_network.qos_data.parameters;\n\tu8 mode = priv->ieee80211->current_network.mode;\n\tu32  u1bAIFS;\n\tu32 u4bAcParam;\n\tu32 op_limit;\n\tu32 cw_max;\n\tu32 cw_min;\n\tint i;\n\n\tmutex_lock(&priv->mutex);\n\tif (priv->ieee80211->state != IEEE80211_LINKED)\n\t\tgoto success;\n\tRT_TRACE(COMP_QOS,\n\t\t \"qos active process with associate response received\\n\");\n\t \n\tfor (i = 0; i <  QOS_QUEUE_NUM; i++) {\n\t\t \n\t\tu1bAIFS = qos_parameters->aifs[i] * ((mode & (IEEE_G | IEEE_N_24G)) ? 9 : 20) + aSifsTime;\n\t\tu1bAIFS <<= AC_PARAM_AIFS_OFFSET;\n\t\top_limit = (u32)le16_to_cpu(qos_parameters->tx_op_limit[i]);\n\t\top_limit <<= AC_PARAM_TXOP_LIMIT_OFFSET;\n\t\tcw_max = (u32)le16_to_cpu(qos_parameters->cw_max[i]);\n\t\tcw_max <<= AC_PARAM_ECW_MAX_OFFSET;\n\t\tcw_min = (u32)le16_to_cpu(qos_parameters->cw_min[i]);\n\t\tcw_min <<= AC_PARAM_ECW_MIN_OFFSET;\n\t\tu4bAcParam = op_limit | cw_max | cw_min | u1bAIFS;\n\t\twrite_nic_dword(dev, WDCAPARA_ADD[i], u4bAcParam);\n\t}\n\nsuccess:\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int rtl8192_qos_handle_probe_response(struct r8192_priv *priv,\n\t\t\t\t\t     int active_network,\n\t\t\t\t\t     struct ieee80211_network *network)\n{\n\tint ret = 0;\n\tu32 size = sizeof(struct ieee80211_qos_parameters);\n\n\tif (priv->ieee80211->state != IEEE80211_LINKED)\n\t\treturn ret;\n\n\tif (priv->ieee80211->iw_mode != IW_MODE_INFRA)\n\t\treturn ret;\n\n\tif (network->flags & NETWORK_HAS_QOS_MASK) {\n\t\tif (active_network &&\n\t\t    (network->flags & NETWORK_HAS_QOS_PARAMETERS))\n\t\t\tnetwork->qos_data.active = network->qos_data.supported;\n\n\t\tif ((network->qos_data.active == 1) && (active_network == 1) &&\n\t\t    (network->flags & NETWORK_HAS_QOS_PARAMETERS) &&\n\t\t    (network->qos_data.old_param_count !=\n\t\t     network->qos_data.param_count)) {\n\t\t\tnetwork->qos_data.old_param_count =\n\t\t\t\tnetwork->qos_data.param_count;\n\t\t\tschedule_work(&priv->qos_activate);\n\t\t\tRT_TRACE(COMP_QOS,\n\t\t\t\t \"QoS parameters change call qos_activate\\n\");\n\t\t}\n\t} else {\n\t\tmemcpy(&priv->ieee80211->current_network.qos_data.parameters,\n\t\t       &def_qos_parameters, size);\n\n\t\tif ((network->qos_data.active == 1) && (active_network == 1)) {\n\t\t\tschedule_work(&priv->qos_activate);\n\t\t\tRT_TRACE(COMP_QOS,\n\t\t\t\t \"QoS was disabled call qos_activate\\n\");\n\t\t}\n\t\tnetwork->qos_data.active = 0;\n\t\tnetwork->qos_data.supported = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rtl8192_handle_beacon(struct net_device *dev,\n\t\t\t\t struct ieee80211_beacon *beacon,\n\t\t\t\t struct ieee80211_network *network)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\trtl8192_qos_handle_probe_response(priv, 1, network);\n\tschedule_delayed_work(&priv->update_beacon_wq, 0);\n\treturn 0;\n}\n\n \nstatic int rtl8192_qos_association_resp(struct r8192_priv *priv,\n\t\t\t\t\tstruct ieee80211_network *network)\n{\n\tunsigned long flags;\n\tu32 size = sizeof(struct ieee80211_qos_parameters);\n\tint set_qos_param = 0;\n\n\tif (!priv || !network)\n\t\treturn 0;\n\n\tif (priv->ieee80211->state != IEEE80211_LINKED)\n\t\treturn 0;\n\n\tif (priv->ieee80211->iw_mode != IW_MODE_INFRA)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&priv->ieee80211->lock, flags);\n\tif (network->flags & NETWORK_HAS_QOS_PARAMETERS) {\n\t\tmemcpy(&priv->ieee80211->current_network.qos_data.parameters,\n\t\t       &network->qos_data.parameters,\n\t\t       sizeof(struct ieee80211_qos_parameters));\n\t\tpriv->ieee80211->current_network.qos_data.active = 1;\n\t\tset_qos_param = 1;\n\t\t \n\t\tpriv->ieee80211->current_network.qos_data.old_param_count =\n\t\t\tpriv->ieee80211->current_network.qos_data.param_count;\n\t\tpriv->ieee80211->current_network.qos_data.param_count =\n\t\t\tnetwork->qos_data.param_count;\n\t} else {\n\t\tmemcpy(&priv->ieee80211->current_network.qos_data.parameters,\n\t\t       &def_qos_parameters, size);\n\t\tpriv->ieee80211->current_network.qos_data.active = 0;\n\t\tpriv->ieee80211->current_network.qos_data.supported = 0;\n\t\tset_qos_param = 1;\n\t}\n\n\tspin_unlock_irqrestore(&priv->ieee80211->lock, flags);\n\n\tRT_TRACE(COMP_QOS, \"%s: network->flags = %d,%d\\n\", __func__,\n\t\t network->flags,\n\t\t priv->ieee80211->current_network.qos_data.active);\n\tif (set_qos_param == 1)\n\t\tschedule_work(&priv->qos_activate);\n\n\treturn 0;\n}\n\nstatic int rtl8192_handle_assoc_response(struct net_device *dev,\n\t\t\t\t\t struct ieee80211_assoc_response_frame *resp,\n\t\t\t\t\t struct ieee80211_network *network)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\trtl8192_qos_association_resp(priv, network);\n\treturn 0;\n}\n\nstatic void rtl8192_update_ratr_table(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\tu8 *pMcsRate = ieee->dot11HTOperationalRateSet;\n\tu32 ratr_value = 0;\n\tu8 rate_index = 0;\n\n\trtl8192_config_rate(dev, (u16 *)(&ratr_value));\n\tratr_value |= (*(u16 *)(pMcsRate)) << 12;\n\tswitch (ieee->mode) {\n\tcase IEEE_A:\n\t\tratr_value &= 0x00000FF0;\n\t\tbreak;\n\tcase IEEE_B:\n\t\tratr_value &= 0x0000000F;\n\t\tbreak;\n\tcase IEEE_G:\n\t\tratr_value &= 0x00000FF7;\n\t\tbreak;\n\tcase IEEE_N_24G:\n\tcase IEEE_N_5G:\n\t\tif (ieee->pHTInfo->PeerMimoPs == MIMO_PS_STATIC) {\n\t\t\tratr_value &= 0x0007F007;\n\t\t} else {\n\t\t\tif (priv->rf_type == RF_1T2R)\n\t\t\t\tratr_value &= 0x000FF007;\n\t\t\telse\n\t\t\t\tratr_value &= 0x0F81F007;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tratr_value &= 0x0FFFFFFF;\n\tif (ieee->pHTInfo->bCurTxBW40MHz && ieee->pHTInfo->bCurShortGI40MHz)\n\t\tratr_value |= 0x80000000;\n\telse if (!ieee->pHTInfo->bCurTxBW40MHz &&\n\t\t ieee->pHTInfo->bCurShortGI20MHz)\n\t\tratr_value |= 0x80000000;\n\twrite_nic_dword(dev, RATR0 + rate_index * 4, ratr_value);\n\twrite_nic_byte(dev, UFWP, 1);\n}\n\nstatic u8 ccmp_ie[4] = {0x00, 0x50, 0xf2, 0x04};\nstatic u8 ccmp_rsn_ie[4] = {0x00, 0x0f, 0xac, 0x04};\nstatic bool GetNmodeSupportBySecCfg8192(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\tstruct ieee80211_network *network = &ieee->current_network;\n\tint wpa_ie_len = ieee->wpa_ie_len;\n\tstruct ieee80211_crypt_data *crypt;\n\tint encrypt;\n\n\tcrypt = ieee->crypt[ieee->tx_keyidx];\n\t \n\tencrypt = (network->capability & WLAN_CAPABILITY_PRIVACY) ||\n\t\t  (ieee->host_encrypt && crypt && crypt->ops &&\n\t\t   (strcmp(crypt->ops->name, \"WEP\") == 0));\n\n\t \n\tif (encrypt && (wpa_ie_len == 0)) {\n\t\t \n\t\treturn false;\n\t} else if ((wpa_ie_len != 0)) {\n\t\t \n\t\tif (((ieee->wpa_ie[0] == 0xdd) && (!memcmp(&(ieee->wpa_ie[14]), ccmp_ie, 4))) || ((ieee->wpa_ie[0] == 0x30) && (!memcmp(&ieee->wpa_ie[10], ccmp_rsn_ie, 4))))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n\n\treturn true;\n}\n\nstatic bool GetHalfNmodeSupportByAPs819xUsb(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\treturn priv->ieee80211->bHalfWirelessN24GMode;\n}\n\nstatic void rtl8192_refresh_supportrate(struct r8192_priv *priv)\n{\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\t \n\tif (ieee->mode == WIRELESS_MODE_N_24G ||\n\t    ieee->mode == WIRELESS_MODE_N_5G)\n\t\tmemcpy(ieee->Regdot11HTOperationalRateSet,\n\t\t       ieee->RegHTSuppRateSet, 16);\n\telse\n\t\tmemset(ieee->Regdot11HTOperationalRateSet, 0, 16);\n}\n\nstatic u8 rtl8192_getSupportedWireleeMode(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu8 ret = 0;\n\n\tswitch (priv->rf_chip) {\n\tcase RF_8225:\n\tcase RF_8256:\n\tcase RF_PSEUDO_11N:\n\t\tret = WIRELESS_MODE_N_24G | WIRELESS_MODE_G | WIRELESS_MODE_B;\n\t\tbreak;\n\tcase RF_8258:\n\t\tret = WIRELESS_MODE_A | WIRELESS_MODE_N_5G;\n\t\tbreak;\n\tdefault:\n\t\tret = WIRELESS_MODE_B;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void rtl8192_SetWirelessMode(struct net_device *dev, u8 wireless_mode)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu8 bSupportMode = rtl8192_getSupportedWireleeMode(dev);\n\n\tif (wireless_mode == WIRELESS_MODE_AUTO ||\n\t    (wireless_mode & bSupportMode) == 0) {\n\t\tif (bSupportMode & WIRELESS_MODE_N_24G) {\n\t\t\twireless_mode = WIRELESS_MODE_N_24G;\n\t\t} else if (bSupportMode & WIRELESS_MODE_N_5G) {\n\t\t\twireless_mode = WIRELESS_MODE_N_5G;\n\t\t} else if ((bSupportMode & WIRELESS_MODE_A)) {\n\t\t\twireless_mode = WIRELESS_MODE_A;\n\t\t} else if ((bSupportMode & WIRELESS_MODE_G)) {\n\t\t\twireless_mode = WIRELESS_MODE_G;\n\t\t} else if ((bSupportMode & WIRELESS_MODE_B)) {\n\t\t\twireless_mode = WIRELESS_MODE_B;\n\t\t} else {\n\t\t\tRT_TRACE(COMP_ERR,\n\t\t\t\t \"%s(), No valid wireless mode supported, SupportedWirelessMode(%x)!!!\\n\",\n\t\t\t\t __func__, bSupportMode);\n\t\t\twireless_mode = WIRELESS_MODE_B;\n\t\t}\n\t}\n\tpriv->ieee80211->mode = wireless_mode;\n\n\tif (wireless_mode == WIRELESS_MODE_N_24G ||\n\t    wireless_mode == WIRELESS_MODE_N_5G)\n\t\tpriv->ieee80211->pHTInfo->bEnableHT = 1;\n\telse\n\t\tpriv->ieee80211->pHTInfo->bEnableHT = 0;\n\tRT_TRACE(COMP_INIT, \"Current Wireless Mode is %x\\n\", wireless_mode);\n\trtl8192_refresh_supportrate(priv);\n}\n\n \nstatic int rtl8192_init_priv_variable(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu8 i;\n\n\tpriv->card_8192 = NIC_8192U;\n\tpriv->chan = 1;  \n\tpriv->ieee80211->mode = WIRELESS_MODE_AUTO;  \n\tpriv->ieee80211->iw_mode = IW_MODE_INFRA;\n\tpriv->ieee80211->ieee_up = 0;\n\tpriv->retry_rts = DEFAULT_RETRY_RTS;\n\tpriv->retry_data = DEFAULT_RETRY_DATA;\n\tpriv->ieee80211->rts = DEFAULT_RTS_THRESHOLD;\n\tpriv->ieee80211->rate = 110;  \n\tpriv->ieee80211->short_slot = 1;\n\tpriv->promisc = (dev->flags & IFF_PROMISC) ? 1 : 0;\n\tpriv->CckPwEnl = 6;\n\t \n\tpriv->IrpPendingCount = 1;\n\tpriv->ResetProgress = RESET_TYPE_NORESET;\n\tpriv->bForcedSilentReset = false;\n\tpriv->bDisableNormalResetCheck = false;\n\tpriv->force_reset = false;\n\n\t \n\tpriv->ieee80211->FwRWRF = 0;\n\tpriv->ieee80211->current_network.beacon_interval =\n\t\tDEFAULT_BEACONINTERVAL;\n\tpriv->ieee80211->softmac_features  = IEEE_SOFTMAC_SCAN |\n\t\tIEEE_SOFTMAC_ASSOCIATE | IEEE_SOFTMAC_PROBERQ |\n\t\tIEEE_SOFTMAC_PROBERS | IEEE_SOFTMAC_TX_QUEUE |\n\t\tIEEE_SOFTMAC_BEACONS;\n\n\tpriv->ieee80211->active_scan = 1;\n\tpriv->ieee80211->modulation =\n\t\tIEEE80211_CCK_MODULATION | IEEE80211_OFDM_MODULATION;\n\tpriv->ieee80211->host_encrypt = 1;\n\tpriv->ieee80211->host_decrypt = 1;\n\tpriv->ieee80211->start_send_beacons = NULL;\n\tpriv->ieee80211->stop_send_beacons = NULL;\n\tpriv->ieee80211->softmac_hard_start_xmit = rtl8192_hard_start_xmit;\n\tpriv->ieee80211->set_chan = rtl8192_set_chan;\n\tpriv->ieee80211->link_change = rtl8192_link_change;\n\tpriv->ieee80211->softmac_data_hard_start_xmit = rtl8192_hard_data_xmit;\n\tpriv->ieee80211->data_hard_stop = rtl8192_data_hard_stop;\n\tpriv->ieee80211->data_hard_resume = rtl8192_data_hard_resume;\n\tpriv->ieee80211->init_wmmparam_flag = 0;\n\tpriv->ieee80211->fts = DEFAULT_FRAG_THRESHOLD;\n\tpriv->ieee80211->check_nic_enough_desc = check_nic_enough_desc;\n\tpriv->ieee80211->tx_headroom = TX_PACKET_SHIFT_BYTES;\n\tpriv->ieee80211->qos_support = 1;\n\n\tpriv->ieee80211->SetBWModeHandler = rtl8192_SetBWMode;\n\tpriv->ieee80211->handle_assoc_response = rtl8192_handle_assoc_response;\n\tpriv->ieee80211->handle_beacon = rtl8192_handle_beacon;\n\n\tpriv->ieee80211->GetNmodeSupportBySecCfg = GetNmodeSupportBySecCfg8192;\n\tpriv->ieee80211->GetHalfNmodeSupportByAPsHandler =\n\t\tGetHalfNmodeSupportByAPs819xUsb;\n\tpriv->ieee80211->SetWirelessMode = rtl8192_SetWirelessMode;\n\n\tpriv->ieee80211->InitialGainHandler = InitialGain819xUsb;\n\tpriv->card_type = USB;\n\tpriv->ShortRetryLimit = 0x30;\n\tpriv->LongRetryLimit = 0x30;\n\tpriv->EarlyRxThreshold = 7;\n\tpriv->enable_gpio0 = 0;\n\tpriv->TransmitConfig =\n\t\t \n\t\t(TCR_MXDMA_2048 << TCR_MXDMA_OFFSET)\t  |\n\t\t \n\t\t(priv->ShortRetryLimit << TCR_SRL_OFFSET) |\n\t\t \n\t\t(priv->LongRetryLimit << TCR_LRL_OFFSET)  |\n\t\t \n\t\t(false ? TCR_SAT : 0);\n\tpriv->ReceiveConfig\t=\n\t\t \n\t\tRCR_AMF | RCR_ADF |\n\t\t \n\t\tRCR_ACF |\n\t\t \n\t\tRCR_AB | RCR_AM | RCR_APM |\n\t\t \n\t\t((u32)7 << RCR_MXDMA_OFFSET) |\n\t\t \n\t\t(priv->EarlyRxThreshold << RX_FIFO_THRESHOLD_SHIFT) |\n\t\t(priv->EarlyRxThreshold == 7 ? RCR_ONLYERLPKT : 0);\n\n\tpriv->AcmControl = 0;\n\tpriv->pFirmware = kzalloc(sizeof(rt_firmware), GFP_KERNEL);\n\tif (!priv->pFirmware)\n\t\treturn -ENOMEM;\n\n\t \n\tskb_queue_head_init(&priv->rx_queue);\n\tskb_queue_head_init(&priv->skb_queue);\n\n\t \n\tfor (i = 0; i < MAX_QUEUE_SIZE; i++)\n\t\tskb_queue_head_init(&priv->ieee80211->skb_waitQ[i]);\n\tfor (i = 0; i < MAX_QUEUE_SIZE; i++)\n\t\tskb_queue_head_init(&priv->ieee80211->skb_aggQ[i]);\n\tfor (i = 0; i < MAX_QUEUE_SIZE; i++)\n\t\tskb_queue_head_init(&priv->ieee80211->skb_drv_aggQ[i]);\n\tpriv->rf_set_chan = rtl8192_phy_SwChnl;\n\n\treturn 0;\n}\n\n \nstatic void rtl8192_init_priv_lock(struct r8192_priv *priv)\n{\n\tspin_lock_init(&priv->tx_lock);\n\tspin_lock_init(&priv->irq_lock);\n\tmutex_init(&priv->wx_mutex);\n\tmutex_init(&priv->mutex);\n}\n\nstatic void rtl819x_watchdog_wqcallback(struct work_struct *work);\n\nstatic void rtl8192_irq_rx_tasklet(struct tasklet_struct *t);\n \n#define DRV_NAME \"wlan0\"\nstatic void rtl8192_init_priv_task(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tINIT_WORK(&priv->reset_wq, rtl8192_restart);\n\n\tINIT_DELAYED_WORK(&priv->watch_dog_wq,\n\t\t\t  rtl819x_watchdog_wqcallback);\n\tINIT_DELAYED_WORK(&priv->txpower_tracking_wq,\n\t\t\t  dm_txpower_trackingcallback);\n\tINIT_DELAYED_WORK(&priv->rfpath_check_wq,\n\t\t\t  dm_rf_pathcheck_workitemcallback);\n\tINIT_DELAYED_WORK(&priv->update_beacon_wq,\n\t\t\t  rtl8192_update_beacon);\n\tINIT_DELAYED_WORK(&priv->initialgain_operate_wq,\n\t\t\t  InitialGainOperateWorkItemCallBack);\n\tINIT_WORK(&priv->qos_activate, rtl8192_qos_activate);\n\n\ttasklet_setup(&priv->irq_rx_tasklet, rtl8192_irq_rx_tasklet);\n}\n\nstatic void rtl8192_get_eeprom_size(struct net_device *dev)\n{\n\tu16 curCR = 0;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tRT_TRACE(COMP_EPROM, \"===========>%s()\\n\", __func__);\n\tread_nic_word_E(dev, EPROM_CMD, &curCR);\n\tRT_TRACE(COMP_EPROM,\n\t\t \"read from Reg EPROM_CMD(%x):%x\\n\", EPROM_CMD, curCR);\n\t \n\tpriv->epromtype =\n\t\t(curCR & Cmd9346CR_9356SEL) ? EPROM_93c56 : EPROM_93c46;\n\tRT_TRACE(COMP_EPROM,\n\t\t \"<===========%s(), epromtype:%d\\n\", __func__, priv->epromtype);\n}\n\n \nstatic inline u16 endian_swap(u16 *data)\n{\n\tu16 tmp = *data;\n\t*data = (tmp >> 8) | (tmp << 8);\n\treturn *data;\n}\n\nstatic int rtl8192_read_eeprom_info(struct net_device *dev)\n{\n\tu16 wEPROM_ID = 0;\n\tu8 bMac_Tmp_Addr[6] = {0x00, 0xe0, 0x4c, 0x00, 0x00, 0x02};\n\tu8 bLoad_From_EEPOM = false;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu16 tmpValue = 0;\n\tint i;\n\tint ret;\n\n\tRT_TRACE(COMP_EPROM, \"===========>%s()\\n\", __func__);\n\tret = eprom_read(dev, 0);  \n\tif (ret < 0)\n\t\treturn ret;\n\twEPROM_ID = (u16)ret;\n\tRT_TRACE(COMP_EPROM, \"EEPROM ID is 0x%x\\n\", wEPROM_ID);\n\n\tif (wEPROM_ID != RTL8190_EEPROM_ID)\n\t\tRT_TRACE(COMP_ERR,\n\t\t\t \"EEPROM ID is invalid(is 0x%x(should be 0x%x)\\n\",\n\t\t\t wEPROM_ID, RTL8190_EEPROM_ID);\n\telse\n\t\tbLoad_From_EEPOM = true;\n\n\tif (bLoad_From_EEPOM) {\n\t\ttmpValue = eprom_read(dev, EEPROM_VID >> 1);\n\t\tret = eprom_read(dev, EEPROM_VID >> 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ttmpValue = (u16)ret;\n\t\tpriv->eeprom_vid = endian_swap(&tmpValue);\n\t\tret = eprom_read(dev, EEPROM_PID >> 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpriv->eeprom_pid = (u16)ret;\n\t\tret = eprom_read(dev, EEPROM_CHANNEL_PLAN >> 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ttmpValue = (u16)ret;\n\t\tpriv->eeprom_ChannelPlan = (tmpValue & 0xff00) >> 8;\n\t\tpriv->btxpowerdata_readfromEEPORM = true;\n\t\tret = eprom_read(dev, (EEPROM_CUSTOMER_ID >> 1)) >> 8;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpriv->eeprom_CustomerID = (u16)ret;\n\t} else {\n\t\tpriv->eeprom_vid = 0;\n\t\tpriv->eeprom_pid = 0;\n\t\tpriv->card_8192_version = VERSION_819XU_B;\n\t\tpriv->eeprom_ChannelPlan = 0;\n\t\tpriv->eeprom_CustomerID = 0;\n\t}\n\tRT_TRACE(COMP_EPROM,\n\t\t \"vid:0x%4x, pid:0x%4x, CustomID:0x%2x, ChanPlan:0x%x\\n\",\n\t\t priv->eeprom_vid, priv->eeprom_pid, priv->eeprom_CustomerID,\n\t\t priv->eeprom_ChannelPlan);\n\t \n\tpriv->ChannelPlan = priv->eeprom_ChannelPlan;\n\tif (bLoad_From_EEPOM) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\tfor (i = 0; i < 6; i += 2) {\n\t\t\tret = eprom_read(dev, (u16)((EEPROM_NODE_ADDRESS_BYTE_0 + i) >> 1));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*(u16 *)(&addr[i]) = (u16)ret;\n\t\t}\n\t\teth_hw_addr_set(dev, addr);\n\t} else {\n\t\teth_hw_addr_set(dev, bMac_Tmp_Addr);\n\t\t \n\t}\n\tRT_TRACE(COMP_EPROM, \"MAC addr:%pM\\n\", dev->dev_addr);\n\tpriv->rf_type = RTL819X_DEFAULT_RF_TYPE;  \n\tpriv->rf_chip = RF_8256;\n\n\tif (priv->card_8192_version == VERSION_819XU_A) {\n\t\t \n\t\tif (bLoad_From_EEPOM) {\n\t\t\tret = eprom_read(dev, (EEPROM_TX_POWER_DIFF >> 1));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tpriv->EEPROMTxPowerDiff = ((u16)ret & 0xff00) >> 8;\n\t\t} else\n\t\t\tpriv->EEPROMTxPowerDiff = EEPROM_DEFAULT_TX_POWER;\n\t\tRT_TRACE(COMP_EPROM, \"TxPowerDiff:%d\\n\", priv->EEPROMTxPowerDiff);\n\t\t \n\t\tif (bLoad_From_EEPOM) {\n\t\t\tret = eprom_read(dev, (EEPROM_THERMAL_METER >> 1));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tpriv->EEPROMThermalMeter = (u8)((u16)ret & 0x00ff);\n\t\t} else\n\t\t\tpriv->EEPROMThermalMeter = EEPROM_DEFAULT_THERNAL_METER;\n\t\tRT_TRACE(COMP_EPROM, \"ThermalMeter:%d\\n\", priv->EEPROMThermalMeter);\n\t\t \n\t\tpriv->TSSI_13dBm = priv->EEPROMThermalMeter * 100;\n\t\t \n\t\tif (bLoad_From_EEPOM) {\n\t\t\tret = eprom_read(dev, (EEPROM_PW_DIFF >> 1));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tpriv->EEPROMPwDiff = ((u16)ret & 0x0f00) >> 8;\n\t\t} else\n\t\t\tpriv->EEPROMPwDiff = EEPROM_DEFAULT_PW_DIFF;\n\t\tRT_TRACE(COMP_EPROM, \"TxPwDiff:%d\\n\", priv->EEPROMPwDiff);\n\t\t \n\t\tif (bLoad_From_EEPOM) {\n\t\t\tret = eprom_read(dev, (EEPROM_CRYSTAL_CAP >> 1));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tpriv->EEPROMCrystalCap = (u16)ret & 0x0f;\n\t\t} else\n\t\t\tpriv->EEPROMCrystalCap = EEPROM_DEFAULT_CRYSTAL_CAP;\n\t\tRT_TRACE(COMP_EPROM, \"CrystalCap = %d\\n\", priv->EEPROMCrystalCap);\n\t\t \n\t\tif (bLoad_From_EEPOM) {\n\t\t\tret = eprom_read(dev, (EEPROM_TX_PW_INDEX_VER >> 1));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tpriv->EEPROM_Def_Ver = ((u16)ret & 0xff00) >> 8;\n\t\t} else\n\t\t\tpriv->EEPROM_Def_Ver = 1;\n\t\tRT_TRACE(COMP_EPROM, \"EEPROM_DEF_VER:%d\\n\", priv->EEPROM_Def_Ver);\n\t\tif (priv->EEPROM_Def_Ver == 0) {  \n\t\t\tif (bLoad_From_EEPOM) {\n\t\t\t\tret = eprom_read(dev, (EEPROM_TX_PW_INDEX_CCK >> 1));\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tpriv->EEPROMTxPowerLevelCCK = ((u16)ret & 0xff00) >> 8;\n\t\t\t} else\n\t\t\t\tpriv->EEPROMTxPowerLevelCCK = 0x10;\n\t\t\tRT_TRACE(COMP_EPROM, \"CCK Tx Power Levl: 0x%02x\\n\", priv->EEPROMTxPowerLevelCCK);\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tif (bLoad_From_EEPOM) {\n\t\t\t\t\tret = eprom_read(dev, (EEPROM_TX_PW_INDEX_OFDM_24G + i) >> 1);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\tif (((EEPROM_TX_PW_INDEX_OFDM_24G + i) % 2) == 0)\n\t\t\t\t\t\ttmpValue = (u16)ret & 0x00ff;\n\t\t\t\t\telse\n\t\t\t\t\t\ttmpValue = ((u16)ret & 0xff00) >> 8;\n\t\t\t\t} else {\n\t\t\t\t\ttmpValue = 0x10;\n\t\t\t\t}\n\t\t\t\tpriv->EEPROMTxPowerLevelOFDM24G[i] = (u8)tmpValue;\n\t\t\t\tRT_TRACE(COMP_EPROM, \"OFDM 2.4G Tx Power Level, Index %d = 0x%02x\\n\", i, priv->EEPROMTxPowerLevelCCK);\n\t\t\t}\n\t\t} else if (priv->EEPROM_Def_Ver == 1) {\n\t\t\tif (bLoad_From_EEPOM) {\n\t\t\t\tret = eprom_read(dev, EEPROM_TX_PW_INDEX_CCK_V1 >> 1);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\ttmpValue = ((u16)ret & 0xff00) >> 8;\n\t\t\t} else {\n\t\t\t\ttmpValue = 0x10;\n\t\t\t}\n\t\t\tpriv->EEPROMTxPowerLevelCCK_V1[0] = (u8)tmpValue;\n\n\t\t\tif (bLoad_From_EEPOM) {\n\t\t\t\tret = eprom_read(dev, (EEPROM_TX_PW_INDEX_CCK_V1 + 2) >> 1);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\ttmpValue = (u16)ret;\n\t\t\t} else\n\t\t\t\ttmpValue = 0x1010;\n\t\t\t*((u16 *)(&priv->EEPROMTxPowerLevelCCK_V1[1])) = tmpValue;\n\t\t\tif (bLoad_From_EEPOM)\n\t\t\t\ttmpValue = eprom_read(dev,\n\t\t\t\t\tEEPROM_TX_PW_INDEX_OFDM_24G_V1 >> 1);\n\t\t\telse\n\t\t\t\ttmpValue = 0x1010;\n\t\t\t*((u16 *)(&priv->EEPROMTxPowerLevelOFDM24G[0])) = tmpValue;\n\t\t\tif (bLoad_From_EEPOM)\n\t\t\t\ttmpValue = eprom_read(dev, (EEPROM_TX_PW_INDEX_OFDM_24G_V1 + 2) >> 1);\n\t\t\telse\n\t\t\t\ttmpValue = 0x10;\n\t\t\tpriv->EEPROMTxPowerLevelOFDM24G[2] = (u8)tmpValue;\n\t\t}  \n\n\t\t \n\t\tfor (i = 0; i < 14; i++) {\n\t\t\tif (i <= 3)\n\t\t\t\tpriv->TxPowerLevelOFDM24G[i] = priv->EEPROMTxPowerLevelOFDM24G[0];\n\t\t\telse if (i >= 4 && i <= 9)\n\t\t\t\tpriv->TxPowerLevelOFDM24G[i] = priv->EEPROMTxPowerLevelOFDM24G[1];\n\t\t\telse\n\t\t\t\tpriv->TxPowerLevelOFDM24G[i] = priv->EEPROMTxPowerLevelOFDM24G[2];\n\t\t}\n\n\t\tfor (i = 0; i < 14; i++) {\n\t\t\tif (priv->EEPROM_Def_Ver == 0) {\n\t\t\t\tif (i <= 3)\n\t\t\t\t\tpriv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelOFDM24G[0] + (priv->EEPROMTxPowerLevelCCK - priv->EEPROMTxPowerLevelOFDM24G[1]);\n\t\t\t\telse if (i >= 4 && i <= 9)\n\t\t\t\t\tpriv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelCCK;\n\t\t\t\telse\n\t\t\t\t\tpriv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelOFDM24G[2] + (priv->EEPROMTxPowerLevelCCK - priv->EEPROMTxPowerLevelOFDM24G[1]);\n\t\t\t} else if (priv->EEPROM_Def_Ver == 1) {\n\t\t\t\tif (i <= 3)\n\t\t\t\t\tpriv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelCCK_V1[0];\n\t\t\t\telse if (i >= 4 && i <= 9)\n\t\t\t\t\tpriv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelCCK_V1[1];\n\t\t\t\telse\n\t\t\t\t\tpriv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelCCK_V1[2];\n\t\t\t}\n\t\t}\n\t\tpriv->TxPowerDiff = priv->EEPROMPwDiff;\n\t\t \n\t\tpriv->AntennaTxPwDiff[0] = (priv->EEPROMTxPowerDiff & 0xf);\n\t\t \n\t\tpriv->AntennaTxPwDiff[1] =\n\t\t\t(priv->EEPROMTxPowerDiff & 0xf0) >> 4;\n\t\t \n\t\tpriv->CrystalCap = priv->EEPROMCrystalCap;\n\t\t \n\t\tpriv->ThermalMeter[0] = priv->EEPROMThermalMeter;\n\t}  \n\n\t \n\tswitch (priv->eeprom_CustomerID) {\n\tcase EEPROM_CID_RUNTOP:\n\t\tpriv->CustomerID = RT_CID_819x_RUNTOP;\n\t\tbreak;\n\n\tcase EEPROM_CID_DLINK:\n\t\tpriv->CustomerID = RT_CID_DLINK;\n\t\tbreak;\n\n\tdefault:\n\t\tpriv->CustomerID = RT_CID_DEFAULT;\n\t\tbreak;\n\t}\n\n\tswitch (priv->CustomerID) {\n\tcase RT_CID_819x_RUNTOP:\n\t\tpriv->LedStrategy = SW_LED_MODE2;\n\t\tbreak;\n\n\tcase RT_CID_DLINK:\n\t\tpriv->LedStrategy = SW_LED_MODE4;\n\t\tbreak;\n\n\tdefault:\n\t\tpriv->LedStrategy = SW_LED_MODE0;\n\t\tbreak;\n\t}\n\n\tif (priv->rf_type == RF_1T2R)\n\t\tRT_TRACE(COMP_EPROM, \"\\n1T2R config\\n\");\n\telse\n\t\tRT_TRACE(COMP_EPROM, \"\\n2T4R config\\n\");\n\n\t \n\tinit_rate_adaptive(dev);\n\n\tRT_TRACE(COMP_EPROM, \"<===========%s()\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic short rtl8192_get_channel_map(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tif (priv->ChannelPlan > COUNTRY_CODE_GLOBAL_DOMAIN) {\n\t\tnetdev_err(dev,\n\t\t\t   \"rtl8180_init: Error channel plan! Set to default.\\n\");\n\t\tpriv->ChannelPlan = 0;\n\t}\n\tRT_TRACE(COMP_INIT, \"Channel plan is %d\\n\", priv->ChannelPlan);\n\n\trtl819x_set_channel_map(priv->ChannelPlan, priv);\n\treturn 0;\n}\n\nstatic short rtl8192_init(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint err;\n\n\tmemset(&(priv->stats), 0, sizeof(struct Stats));\n\tmemset(priv->txqueue_to_outpipemap, 0, 9);\n#ifdef PIPE12\n\t{\n\t\tint i = 0;\n\t\tstatic const u8 queuetopipe[] = {3, 2, 1, 0, 4, 8, 7, 6, 5};\n\n\t\tmemcpy(priv->txqueue_to_outpipemap, queuetopipe, 9);\n\t}\n#else\n\t{\n\t\tstatic const u8 queuetopipe[] = {3, 2, 1, 0, 4, 4, 0, 4, 4};\n\n\t\tmemcpy(priv->txqueue_to_outpipemap, queuetopipe, 9);\n\t}\n#endif\n\terr = rtl8192_init_priv_variable(dev);\n\tif (err)\n\t\treturn err;\n\n\trtl8192_init_priv_lock(priv);\n\trtl8192_init_priv_task(dev);\n\trtl8192_get_eeprom_size(dev);\n\terr = rtl8192_read_eeprom_info(dev);\n\tif (err) {\n\t\tDMESG(\"Reading EEPROM info failed\");\n\t\treturn err;\n\t}\n\trtl8192_get_channel_map(dev);\n\tinit_hal_dm(dev);\n\ttimer_setup(&priv->watch_dog_timer, watch_dog_timer_callback, 0);\n\tif (rtl8192_usb_initendpoints(dev) != 0) {\n\t\tDMESG(\"Endopoints initialization failed\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void rtl8192_hwconfig(struct net_device *dev)\n{\n\tu32 regRATR = 0, regRRSR = 0;\n\tu8 regBwOpMode = 0, regTmp = 0;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu32 ratr_value = 0;\n\n\t \n\tswitch (priv->ieee80211->mode) {\n\tcase WIRELESS_MODE_B:\n\t\tregBwOpMode = BW_OPMODE_20MHZ;\n\t\tregRATR = RATE_ALL_CCK;\n\t\tregRRSR = RATE_ALL_CCK;\n\t\tbreak;\n\tcase WIRELESS_MODE_A:\n\t\tregBwOpMode = BW_OPMODE_5G | BW_OPMODE_20MHZ;\n\t\tregRATR = RATE_ALL_OFDM_AG;\n\t\tregRRSR = RATE_ALL_OFDM_AG;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\t\tregBwOpMode = BW_OPMODE_20MHZ;\n\t\tregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\n\t\tregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\n\t\tbreak;\n\tcase WIRELESS_MODE_AUTO:\n\t\tregBwOpMode = BW_OPMODE_20MHZ;\n\t\tregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG |\n\t\t\t  RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;\n\t\tregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\n\t\tbreak;\n\tcase WIRELESS_MODE_N_24G:\n\t\t \n\t\tregBwOpMode = BW_OPMODE_20MHZ;\n\t\tregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG |\n\t\t\t  RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;\n\t\tregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\n\t\tbreak;\n\tcase WIRELESS_MODE_N_5G:\n\t\tregBwOpMode = BW_OPMODE_5G;\n\t\tregRATR = RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS |\n\t\t\t  RATE_ALL_OFDM_2SS;\n\t\tregRRSR = RATE_ALL_OFDM_AG;\n\t\tbreak;\n\t}\n\n\twrite_nic_byte(dev, BW_OPMODE, regBwOpMode);\n\tratr_value = regRATR;\n\tif (priv->rf_type == RF_1T2R)\n\t\tratr_value &= ~(RATE_ALL_OFDM_2SS);\n\twrite_nic_dword(dev, RATR0, ratr_value);\n\twrite_nic_byte(dev, UFWP, 1);\n\tread_nic_byte(dev, 0x313, &regTmp);\n\tregRRSR = ((regTmp) << 24) | (regRRSR & 0x00ffffff);\n\twrite_nic_dword(dev, RRSR, regRRSR);\n\n\t \n\twrite_nic_word(dev, RETRY_LIMIT,\n\t\t       priv->ShortRetryLimit << RETRY_LIMIT_SHORT_SHIFT |\n\t\t       priv->LongRetryLimit << RETRY_LIMIT_LONG_SHIFT);\n\t \n\n\t \n\n\t \n\n\t \n}\n\n \nstatic bool rtl8192_adapter_start(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu32 dwRegRead = 0;\n\tbool init_status = true;\n\tu8 SECR_value = 0x0;\n\tu8 tmp;\n\n\tRT_TRACE(COMP_INIT, \"====>%s()\\n\", __func__);\n\tpriv->Rf_Mode = RF_OP_By_SW_3wire;\n\t \n\twrite_nic_byte_E(dev, 0x5f, 0x80);\n\tmdelay(50);\n\twrite_nic_byte_E(dev, 0x5f, 0xf0);\n\twrite_nic_byte_E(dev, 0x5d, 0x00);\n\twrite_nic_byte_E(dev, 0x5e, 0x80);\n\twrite_nic_byte(dev, 0x17, 0x37);\n\tmdelay(10);\n\tpriv->pFirmware->firmware_status = FW_STATUS_0_INIT;\n\t \n\t \n\tread_nic_dword(dev, CPU_GEN, &dwRegRead);\n\tdwRegRead |= CPU_GEN_SYSTEM_RESET;  \n\n\twrite_nic_dword(dev, CPU_GEN, dwRegRead);\n\t \n\trtl8192_BBConfig(dev);\n\n\t \n\tpriv->LoopbackMode = RTL819xU_NO_LOOPBACK;\n\n\tread_nic_dword(dev, CPU_GEN, &dwRegRead);\n\tif (priv->LoopbackMode == RTL819xU_NO_LOOPBACK)\n\t\tdwRegRead = (dwRegRead & CPU_GEN_NO_LOOPBACK_MSK) |\n\t\t\t    CPU_GEN_NO_LOOPBACK_SET;\n\telse if (priv->LoopbackMode == RTL819xU_MAC_LOOPBACK)\n\t\tdwRegRead |= CPU_CCK_LOOPBACK;\n\telse\n\t\tRT_TRACE(COMP_ERR,\n\t\t\t \"Serious error in %s(): wrong loopback mode setting(%d)\\n\",\n\t\t\t __func__,  priv->LoopbackMode);\n\n\twrite_nic_dword(dev, CPU_GEN, dwRegRead);\n\n\t \n\tudelay(500);\n\n\t \n\tread_nic_byte_E(dev, 0x5f, &tmp);\n\twrite_nic_byte_E(dev, 0x5f, tmp | 0x20);\n\n\t \n\trtl8192_hwconfig(dev);\n\n\t \n\twrite_nic_byte(dev, CMDR, CR_RE | CR_TE);\n\n\t \n\twrite_nic_dword(dev, MAC0, ((u32 *)dev->dev_addr)[0]);\n\twrite_nic_word(dev, MAC4, ((u16 *)(dev->dev_addr + 4))[0]);\n\n\t \n\twrite_nic_dword(dev, RCR, priv->ReceiveConfig);\n\n\t \n\twrite_nic_dword(dev, RQPN1,\n\t\tNUM_OF_PAGE_IN_FW_QUEUE_BK << RSVD_FW_QUEUE_PAGE_BK_SHIFT |\n\t\tNUM_OF_PAGE_IN_FW_QUEUE_BE << RSVD_FW_QUEUE_PAGE_BE_SHIFT |\n\t\tNUM_OF_PAGE_IN_FW_QUEUE_VI << RSVD_FW_QUEUE_PAGE_VI_SHIFT |\n\t\tNUM_OF_PAGE_IN_FW_QUEUE_VO << RSVD_FW_QUEUE_PAGE_VO_SHIFT);\n\twrite_nic_dword(dev, RQPN2,\n\t\tNUM_OF_PAGE_IN_FW_QUEUE_MGNT << RSVD_FW_QUEUE_PAGE_MGNT_SHIFT |\n\t\tNUM_OF_PAGE_IN_FW_QUEUE_CMD << RSVD_FW_QUEUE_PAGE_CMD_SHIFT);\n\twrite_nic_dword(dev, RQPN3,\n\t\tAPPLIED_RESERVED_QUEUE_IN_FW |\n\t\tNUM_OF_PAGE_IN_FW_QUEUE_BCN << RSVD_FW_QUEUE_PAGE_BCN_SHIFT);\n\twrite_nic_dword(dev, RATR0 + 4 * 7, (RATE_ALL_OFDM_AG | RATE_ALL_CCK));\n\n\t \n\t \n\twrite_nic_byte(dev, ACK_TIMEOUT, 0x30);\n\n\tif (priv->ResetProgress == RESET_TYPE_NORESET)\n\t\trtl8192_SetWirelessMode(dev, priv->ieee80211->mode);\n\tif (priv->ResetProgress == RESET_TYPE_NORESET) {\n\t\tCamResetAllEntry(dev);\n\t\tSECR_value |= SCR_TxEncEnable;\n\t\tSECR_value |= SCR_RxDecEnable;\n\t\tSECR_value |= SCR_NoSKMC;\n\t\twrite_nic_byte(dev, SECR, SECR_value);\n\t}\n\n\t \n\twrite_nic_word(dev, ATIMWND, 2);\n\twrite_nic_word(dev, BCN_INTERVAL, 100);\n\n#define DEFAULT_EDCA 0x005e4332\n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < QOS_QUEUE_NUM; i++)\n\t\t\twrite_nic_dword(dev, WDCAPARA_ADD[i], DEFAULT_EDCA);\n\t}\n\n\trtl8192_phy_configmac(dev);\n\n\tif (priv->card_8192_version == VERSION_819XU_A) {\n\t\trtl8192_phy_getTxPower(dev);\n\t\trtl8192_phy_setTxPower(dev, priv->chan);\n\t}\n\n\t \n\tinit_status = init_firmware(dev);\n\tif (!init_status) {\n\t\tRT_TRACE(COMP_ERR, \"ERR!!! %s(): Firmware download is failed\\n\",\n\t\t\t __func__);\n\t\treturn init_status;\n\t}\n\tRT_TRACE(COMP_INIT, \"%s():after firmware download\\n\", __func__);\n\n\t \n\tif (priv->ResetProgress == RESET_TYPE_NORESET) {\n\t\trtl8192_phy_RFConfig(dev);\n\t\tRT_TRACE(COMP_INIT, \"%s():after phy RF config\\n\", __func__);\n\t}\n\n\tif (priv->ieee80211->FwRWRF)\n\t\t \n\t\tpriv->Rf_Mode = RF_OP_By_FW;\n\telse\n\t\tpriv->Rf_Mode = RF_OP_By_SW_3wire;\n\n\trtl8192_phy_updateInitGain(dev);\n\t \n\trtl8192_setBBreg(dev, rFPGA0_RFMOD, bCCKEn, 0x1);\n\trtl8192_setBBreg(dev, rFPGA0_RFMOD, bOFDMEn, 0x1);\n\n\tif (priv->ResetProgress == RESET_TYPE_NORESET) {\n\t\t \n\t\tu8 tmpvalue;\n\n\t\tread_nic_byte(dev, 0x301, &tmpvalue);\n\t\tif (tmpvalue == 0x03) {\n\t\t\tpriv->bDcut = true;\n\t\t\tRT_TRACE(COMP_POWER_TRACKING, \"D-cut\\n\");\n\t\t} else {\n\t\t\tpriv->bDcut = false;\n\t\t\tRT_TRACE(COMP_POWER_TRACKING, \"C-cut\\n\");\n\t\t}\n\t\tdm_initialize_txpower_tracking(dev);\n\n\t\tif (priv->bDcut) {\n\t\t\tu32 i, TempCCk;\n\t\t\tu32 tmpRegA = rtl8192_QueryBBReg(dev,\n\t\t\t\t\t\t\t rOFDM0_XATxIQImbalance,\n\t\t\t\t\t\t\t bMaskDWord);\n\n\t\t\tfor (i = 0; i < TxBBGainTableLength; i++) {\n\t\t\t\tif (tmpRegA == priv->txbbgain_table[i].txbbgain_value) {\n\t\t\t\t\tpriv->rfa_txpowertrackingindex = (u8)i;\n\t\t\t\t\tpriv->rfa_txpowertrackingindex_real =\n\t\t\t\t\t\t(u8)i;\n\t\t\t\t\tpriv->rfa_txpowertracking_default =\n\t\t\t\t\t\tpriv->rfa_txpowertrackingindex;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTempCCk = rtl8192_QueryBBReg(dev,\n\t\t\t\t\t\t     rCCK0_TxFilter1,\n\t\t\t\t\t\t     bMaskByte2);\n\n\t\t\tfor (i = 0; i < CCKTxBBGainTableLength; i++) {\n\t\t\t\tif (TempCCk == priv->cck_txbbgain_table[i].ccktxbb_valuearray[0]) {\n\t\t\t\t\tpriv->cck_present_attenuation_20Mdefault = (u8)i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriv->cck_present_attenuation_40Mdefault = 0;\n\t\t\tpriv->cck_present_attenuation_difference = 0;\n\t\t\tpriv->cck_present_attenuation =\n\t\t\t\tpriv->cck_present_attenuation_20Mdefault;\n\t\t}\n\t}\n\twrite_nic_byte(dev, 0x87, 0x0);\n\n\treturn init_status;\n}\n\n \n \n\nstatic struct net_device_stats *rtl8192_stats(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\treturn &priv->ieee80211->stats;\n}\n\nstatic bool HalTxCheckStuck819xUsb(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu16\t\tRegTxCounter;\n\tbool\t\tbStuck = false;\n\n\tread_nic_word(dev, 0x128, &RegTxCounter);\n\tRT_TRACE(COMP_RESET,\n\t\t \"%s():RegTxCounter is %d,TxCounter is %d\\n\", __func__,\n\t\t RegTxCounter, priv->TxCounter);\n\tif (priv->TxCounter == RegTxCounter)\n\t\tbStuck = true;\n\n\tpriv->TxCounter = RegTxCounter;\n\n\treturn bStuck;\n}\n\n \nstatic RESET_TYPE TxCheckStuck(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu8\t\t\tQueueID;\n\tbool\t\t\tbCheckFwTxCnt = false;\n\n\t \n\n\tfor (QueueID = 0; QueueID <= BEACON_QUEUE; QueueID++) {\n\t\tif (QueueID == TXCMD_QUEUE)\n\t\t\tcontinue;\n\t\tif ((skb_queue_len(&priv->ieee80211->skb_waitQ[QueueID]) == 0)  && (skb_queue_len(&priv->ieee80211->skb_aggQ[QueueID]) == 0))\n\t\t\tcontinue;\n\n\t\tbCheckFwTxCnt = true;\n\t}\n\tif (bCheckFwTxCnt) {\n\t\tif (HalTxCheckStuck819xUsb(dev)) {\n\t\t\tRT_TRACE(COMP_RESET,\n\t\t\t\t \"%s: Fw indicates no Tx condition!\\n\",\n\t\t\t\t __func__);\n\t\t\treturn RESET_TYPE_SILENT;\n\t\t}\n\t}\n\treturn RESET_TYPE_NORESET;\n}\n\nstatic bool HalRxCheckStuck819xUsb(struct net_device *dev)\n{\n\tu16\tRegRxCounter;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tbool bStuck = false;\n\tstatic u8\trx_chk_cnt;\n\n\tread_nic_word(dev, 0x130, &RegRxCounter);\n\tRT_TRACE(COMP_RESET,\n\t\t \"%s(): RegRxCounter is %d,RxCounter is %d\\n\", __func__,\n\t\t RegRxCounter, priv->RxCounter);\n\t \n\trx_chk_cnt++;\n\tif (priv->undecorated_smoothed_pwdb >= (RATE_ADAPTIVE_TH_HIGH + 5)) {\n\t\trx_chk_cnt = 0;\t \n\t} else if (priv->undecorated_smoothed_pwdb < (RATE_ADAPTIVE_TH_HIGH + 5) &&\n\t\t   ((priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20 && priv->undecorated_smoothed_pwdb >= RATE_ADAPTIVE_TH_LOW_40M) ||\n\t\t    (priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20 && priv->undecorated_smoothed_pwdb >= RATE_ADAPTIVE_TH_LOW_20M))) {\n\t\tif (rx_chk_cnt < 2)\n\t\t\treturn bStuck;\n\n\t\trx_chk_cnt = 0;\n\t} else if (((priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20 && priv->undecorated_smoothed_pwdb < RATE_ADAPTIVE_TH_LOW_40M) ||\n\t\t    (priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20 && priv->undecorated_smoothed_pwdb < RATE_ADAPTIVE_TH_LOW_20M)) &&\n\t\t     priv->undecorated_smoothed_pwdb >= VERY_LOW_RSSI) {\n\t\tif (rx_chk_cnt < 4)\n\t\t\treturn bStuck;\n\n\t\trx_chk_cnt = 0;\n\t} else {\n\t\tif (rx_chk_cnt < 8)\n\t\t\treturn bStuck;\n\n\t\trx_chk_cnt = 0;\n\t}\n\n\tif (priv->RxCounter == RegRxCounter)\n\t\tbStuck = true;\n\n\tpriv->RxCounter = RegRxCounter;\n\n\treturn bStuck;\n}\n\nstatic RESET_TYPE RxCheckStuck(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tbool        bRxCheck = false;\n\n\tif (priv->IrpPendingCount > 1)\n\t\tbRxCheck = true;\n\n\tif (bRxCheck) {\n\t\tif (HalRxCheckStuck819xUsb(dev)) {\n\t\t\tRT_TRACE(COMP_RESET, \"RxStuck Condition\\n\");\n\t\t\treturn RESET_TYPE_SILENT;\n\t\t}\n\t}\n\treturn RESET_TYPE_NORESET;\n}\n\n \nstatic RESET_TYPE rtl819x_ifcheck_resetornot(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tRESET_TYPE\tTxResetType = RESET_TYPE_NORESET;\n\tRESET_TYPE\tRxResetType = RESET_TYPE_NORESET;\n\tRT_RF_POWER_STATE\trfState;\n\n\trfState = priv->ieee80211->eRFPowerState;\n\n\tTxResetType = TxCheckStuck(dev);\n\tif (rfState != eRfOff ||\n\t    (priv->ieee80211->iw_mode != IW_MODE_ADHOC)) {\n\t\t \n\t\tRxResetType = RxCheckStuck(dev);\n\t}\n\tif (TxResetType == RESET_TYPE_NORMAL ||\n\t    RxResetType == RESET_TYPE_NORMAL) {\n\t\treturn RESET_TYPE_NORMAL;\n\t} else if (TxResetType == RESET_TYPE_SILENT ||\n\t\t   RxResetType == RESET_TYPE_SILENT) {\n\t\tRT_TRACE(COMP_RESET, \"%s():silent reset\\n\", __func__);\n\t\treturn RESET_TYPE_SILENT;\n\t} else {\n\t\treturn RESET_TYPE_NORESET;\n\t}\n}\n\nstatic void rtl8192_cancel_deferred_work(struct r8192_priv *priv);\nstatic int _rtl8192_up(struct net_device *dev);\nstatic int rtl8192_close(struct net_device *dev);\n\nstatic void CamRestoreAllEntry(struct net_device *dev)\n{\n\tu8 EntryId = 0;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu8\t*MacAddr = priv->ieee80211->current_network.bssid;\n\n\tstatic u8\tCAM_CONST_ADDR[4][6] = {\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x03} };\n\tstatic u8\tCAM_CONST_BROAD[] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n\tRT_TRACE(COMP_SEC, \"%s:\\n\", __func__);\n\n\tif ((priv->ieee80211->pairwise_key_type == KEY_TYPE_WEP40) ||\n\t    (priv->ieee80211->pairwise_key_type == KEY_TYPE_WEP104)) {\n\t\tfor (EntryId = 0; EntryId < 4; EntryId++) {\n\t\t\tMacAddr = CAM_CONST_ADDR[EntryId];\n\t\t\tsetKey(dev, EntryId, EntryId,\n\t\t\t       priv->ieee80211->pairwise_key_type,\n\t\t\t       MacAddr, 0, NULL);\n\t\t}\n\n\t} else if (priv->ieee80211->pairwise_key_type == KEY_TYPE_TKIP) {\n\t\tif (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\n\t\t\tsetKey(dev, 4, 0, priv->ieee80211->pairwise_key_type,\n\t\t\t       (const u8 *)dev->dev_addr, 0, NULL);\n\t\telse\n\t\t\tsetKey(dev, 4, 0, priv->ieee80211->pairwise_key_type,\n\t\t\t       MacAddr, 0, NULL);\n\t} else if (priv->ieee80211->pairwise_key_type == KEY_TYPE_CCMP) {\n\t\tif (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\n\t\t\tsetKey(dev, 4, 0, priv->ieee80211->pairwise_key_type,\n\t\t\t       (const u8 *)dev->dev_addr, 0, NULL);\n\t\telse\n\t\t\tsetKey(dev, 4, 0, priv->ieee80211->pairwise_key_type,\n\t\t\t       MacAddr, 0, NULL);\n\t}\n\n\tif (priv->ieee80211->group_key_type == KEY_TYPE_TKIP) {\n\t\tMacAddr = CAM_CONST_BROAD;\n\t\tfor (EntryId = 1; EntryId < 4; EntryId++) {\n\t\t\tsetKey(dev, EntryId, EntryId,\n\t\t\t       priv->ieee80211->group_key_type,\n\t\t\t       MacAddr, 0, NULL);\n\t\t}\n\t\tif (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\n\t\t\tsetKey(dev, 0, 0, priv->ieee80211->group_key_type,\n\t\t\t       CAM_CONST_ADDR[0], 0, NULL);\n\t} else if (priv->ieee80211->group_key_type == KEY_TYPE_CCMP) {\n\t\tMacAddr = CAM_CONST_BROAD;\n\t\tfor (EntryId = 1; EntryId < 4; EntryId++) {\n\t\t\tsetKey(dev, EntryId, EntryId,\n\t\t\t       priv->ieee80211->group_key_type,\n\t\t\t       MacAddr, 0, NULL);\n\t\t}\n\n\t\tif (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\n\t\t\tsetKey(dev, 0, 0, priv->ieee80211->group_key_type,\n\t\t\t       CAM_CONST_ADDR[0], 0, NULL);\n\t}\n}\n\n \nstatic void rtl819x_ifsilentreset(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu8\treset_times = 0;\n\tint reset_status = 0;\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\n\t \n\t \n\n\tif (priv->ResetProgress == RESET_TYPE_NORESET) {\nRESET_START:\n\n\t\tRT_TRACE(COMP_RESET, \"=========>Reset progress!!\\n\");\n\n\t\t \n\t\tpriv->ResetProgress = RESET_TYPE_SILENT;\n\t\tmutex_lock(&priv->wx_mutex);\n\t\tif (priv->up == 0) {\n\t\t\tRT_TRACE(COMP_ERR,\n\t\t\t\t \"%s():the driver is not up! return\\n\",\n\t\t\t\t __func__);\n\t\t\tmutex_unlock(&priv->wx_mutex);\n\t\t\treturn;\n\t\t}\n\t\tpriv->up = 0;\n\t\tRT_TRACE(COMP_RESET,\n\t\t\t \"%s():======>start to down the driver\\n\",\n\t\t\t __func__);\n\n\t\trtl8192_rtx_disable(dev);\n\t\trtl8192_cancel_deferred_work(priv);\n\t\tdeinit_hal_dm(dev);\n\t\tdel_timer_sync(&priv->watch_dog_timer);\n\n\t\tieee->sync_scan_hurryup = 1;\n\t\tif (ieee->state == IEEE80211_LINKED) {\n\t\t\tmutex_lock(&ieee->wx_mutex);\n\t\t\tnetdev_dbg(dev, \"ieee->state is IEEE80211_LINKED\\n\");\n\t\t\tieee80211_stop_send_beacons(priv->ieee80211);\n\t\t\tdel_timer_sync(&ieee->associate_timer);\n\t\t\tcancel_delayed_work(&ieee->associate_retry_wq);\n\t\t\tieee80211_stop_scan(ieee);\n\t\t\tnetif_carrier_off(dev);\n\t\t\tmutex_unlock(&ieee->wx_mutex);\n\t\t} else {\n\t\t\tnetdev_dbg(dev, \"ieee->state is NOT LINKED\\n\");\n\t\t\tieee80211_softmac_stop_protocol(priv->ieee80211);\n\t\t}\n\t\tmutex_unlock(&priv->wx_mutex);\n\t\tRT_TRACE(COMP_RESET,\n\t\t\t \"%s():<==========down process is finished\\n\",\n\t\t\t __func__);\n\t\tRT_TRACE(COMP_RESET,\n\t\t\t \"%s():===========>start up the driver\\n\",\n\t\t\t __func__);\n\t\treset_status = _rtl8192_up(dev);\n\n\t\tRT_TRACE(COMP_RESET,\n\t\t\t \"%s():<===========up process is finished\\n\",\n\t\t\t __func__);\n\t\tif (reset_status == -EAGAIN) {\n\t\t\tif (reset_times < 3) {\n\t\t\t\treset_times++;\n\t\t\t\tgoto RESET_START;\n\t\t\t} else {\n\t\t\t\tRT_TRACE(COMP_ERR,\n\t\t\t\t\t \" ERR!!! %s():  Reset Failed!!\\n\",\n\t\t\t\t\t __func__);\n\t\t\t}\n\t\t}\n\t\tieee->is_silent_reset = 1;\n\t\tEnableHWSecurityConfig8192(dev);\n\t\tif (ieee->state == IEEE80211_LINKED &&\n\t\t    ieee->iw_mode == IW_MODE_INFRA) {\n\t\t\tieee->set_chan(ieee->dev,\n\t\t\t\t       ieee->current_network.channel);\n\n\t\t\tqueue_work(ieee->wq, &ieee->associate_complete_wq);\n\n\t\t} else if (ieee->state == IEEE80211_LINKED &&\n\t\t\t   ieee->iw_mode == IW_MODE_ADHOC) {\n\t\t\tieee->set_chan(ieee->dev,\n\t\t\t\t       ieee->current_network.channel);\n\t\t\tieee->link_change(ieee->dev);\n\n\t\t\tieee80211_start_send_beacons(ieee);\n\n\t\t\tif (ieee->data_hard_resume)\n\t\t\t\tieee->data_hard_resume(ieee->dev);\n\t\t\tnetif_carrier_on(ieee->dev);\n\t\t}\n\n\t\tCamRestoreAllEntry(dev);\n\n\t\tpriv->ResetProgress = RESET_TYPE_NORESET;\n\t\tpriv->reset_count++;\n\n\t\tpriv->bForcedSilentReset = false;\n\t\tpriv->bResetInProgress = false;\n\n\t\t \n\t\twrite_nic_byte(dev, UFWP, 1);\n\t\tRT_TRACE(COMP_RESET,\n\t\t\t \"Reset finished!! ====>[%d]\\n\",\n\t\t\t priv->reset_count);\n\t}\n}\n\nstatic void rtl819x_update_rxcounts(struct r8192_priv *priv, u32 *TotalRxBcnNum,\n\t\t\t     u32 *TotalRxDataNum)\n{\n\tu16\t\t\tSlotIndex;\n\tu16\t\t\ti;\n\n\t*TotalRxBcnNum = 0;\n\t*TotalRxDataNum = 0;\n\n\tSlotIndex = (priv->ieee80211->LinkDetectInfo.SlotIndex++) %\n\t\t    (priv->ieee80211->LinkDetectInfo.SlotNum);\n\tpriv->ieee80211->LinkDetectInfo.RxBcnNum[SlotIndex] =\n\t\tpriv->ieee80211->LinkDetectInfo.NumRecvBcnInPeriod;\n\tpriv->ieee80211->LinkDetectInfo.RxDataNum[SlotIndex] =\n\t\tpriv->ieee80211->LinkDetectInfo.NumRecvDataInPeriod;\n\tfor (i = 0; i < priv->ieee80211->LinkDetectInfo.SlotNum; i++) {\n\t\t*TotalRxBcnNum += priv->ieee80211->LinkDetectInfo.RxBcnNum[i];\n\t\t*TotalRxDataNum += priv->ieee80211->LinkDetectInfo.RxDataNum[i];\n\t}\n}\n\nstatic void rtl819x_watchdog_wqcallback(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct r8192_priv *priv = container_of(dwork,\n\t\t\t\t\t       struct r8192_priv, watch_dog_wq);\n\tstruct net_device *dev = priv->ieee80211->dev;\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\tRESET_TYPE\tResetType = RESET_TYPE_NORESET;\n\tstatic u8\tcheck_reset_cnt;\n\tbool bBusyTraffic = false;\n\tu32\tTotalRxBcnNum = 0;\n\tu32\tTotalRxDataNum = 0;\n\n\tif (!priv->up)\n\t\treturn;\n\thal_dm_watchdog(dev);\n\n\t \n\tif (ieee->state == IEEE80211_LINKED) {\n\t\tif (ieee->LinkDetectInfo.NumRxOkInPeriod > 666 ||\n\t\t    ieee->LinkDetectInfo.NumTxOkInPeriod > 666) {\n\t\t\tbBusyTraffic = true;\n\t\t}\n\t\tieee->LinkDetectInfo.NumRxOkInPeriod = 0;\n\t\tieee->LinkDetectInfo.NumTxOkInPeriod = 0;\n\t\tieee->LinkDetectInfo.bBusyTraffic = bBusyTraffic;\n\t}\n\t \n\tif (priv->ieee80211->state == IEEE80211_LINKED &&\n\t    priv->ieee80211->iw_mode == IW_MODE_INFRA) {\n\t\trtl819x_update_rxcounts(priv, &TotalRxBcnNum, &TotalRxDataNum);\n\t\tif ((TotalRxBcnNum + TotalRxDataNum) == 0) {\n#ifdef TODO\n\t\t\tif (rfState == eRfOff)\n\t\t\t\tRT_TRACE(COMP_ERR, \"========>%s()\\n\", __func__);\n#endif\n\t\t\tnetdev_dbg(dev,\n\t\t\t\t   \"===>%s(): AP is power off, connect another one\\n\",\n\t\t\t\t   __func__);\n\t\t\tpriv->ieee80211->state = IEEE80211_ASSOCIATING;\n\t\t\tnotify_wx_assoc_event(priv->ieee80211);\n\t\t\tRemovePeerTS(priv->ieee80211,\n\t\t\t\t     priv->ieee80211->current_network.bssid);\n\t\t\tpriv->ieee80211->link_change(dev);\n\t\t\tqueue_work(priv->ieee80211->wq,\n\t\t\t\t   &priv->ieee80211->associate_procedure_wq);\n\t\t}\n\t}\n\tpriv->ieee80211->LinkDetectInfo.NumRecvBcnInPeriod = 0;\n\tpriv->ieee80211->LinkDetectInfo.NumRecvDataInPeriod = 0;\n\t \n\tif (check_reset_cnt++ >= 3) {\n\t\tResetType = rtl819x_ifcheck_resetornot(dev);\n\t\tcheck_reset_cnt = 3;\n\t}\n\t \n\tif ((priv->force_reset) || (priv->ResetProgress == RESET_TYPE_NORESET &&\n\t    (priv->bForcedSilentReset ||\n\t    (!priv->bDisableNormalResetCheck && ResetType == RESET_TYPE_SILENT)))) {\n\t\tRT_TRACE(COMP_RESET,\n\t\t\t \"%s():priv->force_reset is %d,priv->ResetProgress is %d, priv->bForcedSilentReset is %d,priv->bDisableNormalResetCheck is %d,ResetType is %d\\n\",\n\t\t\t __func__, priv->force_reset, priv->ResetProgress,\n\t\t\t priv->bForcedSilentReset,\n\t\t\t priv->bDisableNormalResetCheck, ResetType);\n\t\trtl819x_ifsilentreset(dev);\n\t}\n\tpriv->force_reset = false;\n\tpriv->bForcedSilentReset = false;\n\tpriv->bResetInProgress = false;\n\tRT_TRACE(COMP_TRACE, \" <==RtUsbCheckForHangWorkItemCallback()\\n\");\n}\n\nstatic void watch_dog_timer_callback(struct timer_list *t)\n{\n\tstruct r8192_priv *priv = from_timer(priv, t, watch_dog_timer);\n\n\tschedule_delayed_work(&priv->watch_dog_wq, 0);\n\tmod_timer(&priv->watch_dog_timer,\n\t\t  jiffies + msecs_to_jiffies(IEEE80211_WATCH_DOG_TIME));\n}\n\nstatic int _rtl8192_up(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint init_status = 0;\n\n\tpriv->up = 1;\n\tpriv->ieee80211->ieee_up = 1;\n\tRT_TRACE(COMP_INIT, \"Bringing up iface\");\n\tinit_status = rtl8192_adapter_start(dev);\n\tif (!init_status) {\n\t\tRT_TRACE(COMP_ERR, \"ERR!!! %s(): initialization failed!\\n\",\n\t\t\t __func__);\n\t\tpriv->up = priv->ieee80211->ieee_up = 0;\n\t\treturn -EAGAIN;\n\t}\n\tRT_TRACE(COMP_INIT, \"start adapter finished\\n\");\n\trtl8192_rx_enable(dev);\n\tif (priv->ieee80211->state != IEEE80211_LINKED)\n\t\tieee80211_softmac_start_protocol(priv->ieee80211);\n\tieee80211_reset_queue(priv->ieee80211);\n\twatch_dog_timer_callback(&priv->watch_dog_timer);\n\tif (!netif_queue_stopped(dev))\n\t\tnetif_start_queue(dev);\n\telse\n\t\tnetif_wake_queue(dev);\n\n\treturn 0;\n}\n\nstatic int rtl8192_open(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint ret;\n\n\tmutex_lock(&priv->wx_mutex);\n\tret = rtl8192_up(dev);\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nint rtl8192_up(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tif (priv->up == 1)\n\t\treturn -1;\n\n\treturn _rtl8192_up(dev);\n}\n\nstatic int rtl8192_close(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint ret;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = rtl8192_down(dev);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nint rtl8192_down(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tint i;\n\n\tif (priv->up == 0)\n\t\treturn -1;\n\n\tpriv->up = 0;\n\tpriv->ieee80211->ieee_up = 0;\n\tRT_TRACE(COMP_DOWN, \"==========>%s()\\n\", __func__);\n\t \n\tif (!netif_queue_stopped(dev))\n\t\tnetif_stop_queue(dev);\n\n\trtl8192_rtx_disable(dev);\n\n\t \n\tfor (i = 0; i < MAX_QUEUE_SIZE; i++)\n\t\tskb_queue_purge(&priv->ieee80211->skb_waitQ[i]);\n\tfor (i = 0; i < MAX_QUEUE_SIZE; i++)\n\t\tskb_queue_purge(&priv->ieee80211->skb_aggQ[i]);\n\n\tfor (i = 0; i < MAX_QUEUE_SIZE; i++)\n\t\tskb_queue_purge(&priv->ieee80211->skb_drv_aggQ[i]);\n\n\t \n\trtl8192_cancel_deferred_work(priv);\n\tdeinit_hal_dm(dev);\n\tdel_timer_sync(&priv->watch_dog_timer);\n\n\tieee80211_softmac_stop_protocol(priv->ieee80211);\n\tmemset(&priv->ieee80211->current_network, 0,\n\t       offsetof(struct ieee80211_network, list));\n\tRT_TRACE(COMP_DOWN, \"<==========%s()\\n\", __func__);\n\n\treturn 0;\n}\n\nvoid rtl8192_commit(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tif (priv->up == 0)\n\t\treturn;\n\tpriv->up = 0;\n\n\trtl8192_cancel_deferred_work(priv);\n\tdel_timer_sync(&priv->watch_dog_timer);\n\n\tieee80211_softmac_stop_protocol(priv->ieee80211);\n\n\trtl8192_rtx_disable(dev);\n\t_rtl8192_up(dev);\n}\n\nstatic void rtl8192_restart(struct work_struct *work)\n{\n\tstruct r8192_priv *priv = container_of(work, struct r8192_priv,\n\t\t\t\t\t       reset_wq);\n\tstruct net_device *dev = priv->ieee80211->dev;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\trtl8192_commit(dev);\n\n\tmutex_unlock(&priv->wx_mutex);\n}\n\nstatic void r8192_set_multicast(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tshort promisc;\n\n\t \n\n\tpromisc = (dev->flags & IFF_PROMISC) ? 1 : 0;\n\n\tif (promisc != priv->promisc)\n\n\t\tpriv->promisc = promisc;\n}\n\nstatic int r8192_set_mac_adr(struct net_device *dev, void *mac)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct sockaddr *addr = mac;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\tschedule_work(&priv->reset_wq);\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn 0;\n}\n\n \nstatic int rtl8192_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct iwreq *wrq = (struct iwreq *)rq;\n\tint ret = -1;\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\tu32 key[4];\n\tu8 broadcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tstruct iw_point *p = &wrq->u.data;\n\tstruct ieee_param *ipw = NULL;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tif (p->length < sizeof(struct ieee_param) || !p->pointer) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tipw = memdup_user(p->pointer, p->length);\n\tif (IS_ERR(ipw)) {\n\t\tret = PTR_ERR(ipw);\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase RTL_IOCTL_WPA_SUPPLICANT:\n\t\t \n\t\tif (ipw->cmd == IEEE_CMD_SET_ENCRYPTION) {\n\t\t\tif (ipw->u.crypt.set_tx) {\n\t\t\t\tif (strcmp(ipw->u.crypt.alg, \"CCMP\") == 0) {\n\t\t\t\t\tieee->pairwise_key_type = KEY_TYPE_CCMP;\n\t\t\t\t} else if (strcmp(ipw->u.crypt.alg, \"TKIP\") == 0) {\n\t\t\t\t\tieee->pairwise_key_type = KEY_TYPE_TKIP;\n\t\t\t\t} else if (strcmp(ipw->u.crypt.alg, \"WEP\") == 0) {\n\t\t\t\t\tif (ipw->u.crypt.key_len == 13)\n\t\t\t\t\t\tieee->pairwise_key_type = KEY_TYPE_WEP104;\n\t\t\t\t\telse if (ipw->u.crypt.key_len == 5)\n\t\t\t\t\t\tieee->pairwise_key_type = KEY_TYPE_WEP40;\n\t\t\t\t} else {\n\t\t\t\t\tieee->pairwise_key_type = KEY_TYPE_NA;\n\t\t\t\t}\n\n\t\t\t\tif (ieee->pairwise_key_type) {\n\t\t\t\t\tmemcpy((u8 *)key, ipw->u.crypt.key, 16);\n\t\t\t\t\tEnableHWSecurityConfig8192(dev);\n\t\t\t\t\t \n\t\t\t\t\tsetKey(dev, 4, ipw->u.crypt.idx,\n\t\t\t\t\t       ieee->pairwise_key_type,\n\t\t\t\t\t       (u8 *)ieee->ap_mac_addr,\n\t\t\t\t\t       0, key);\n\t\t\t\t\tif (ieee->auth_mode != 2)\n\t\t\t\t\t\tsetKey(dev, ipw->u.crypt.idx,\n\t\t\t\t\t\t       ipw->u.crypt.idx,\n\t\t\t\t\t\t       ieee->pairwise_key_type,\n\t\t\t\t\t\t       (u8 *)ieee->ap_mac_addr,\n\t\t\t\t\t\t       0, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmemcpy((u8 *)key, ipw->u.crypt.key, 16);\n\t\t\t\tif (strcmp(ipw->u.crypt.alg, \"CCMP\") == 0) {\n\t\t\t\t\tieee->group_key_type = KEY_TYPE_CCMP;\n\t\t\t\t} else if (strcmp(ipw->u.crypt.alg, \"TKIP\") == 0) {\n\t\t\t\t\tieee->group_key_type = KEY_TYPE_TKIP;\n\t\t\t\t} else if (strcmp(ipw->u.crypt.alg, \"WEP\") == 0) {\n\t\t\t\t\tif (ipw->u.crypt.key_len == 13)\n\t\t\t\t\t\tieee->group_key_type = KEY_TYPE_WEP104;\n\t\t\t\t\telse if (ipw->u.crypt.key_len == 5)\n\t\t\t\t\t\tieee->group_key_type = KEY_TYPE_WEP40;\n\t\t\t\t} else {\n\t\t\t\t\tieee->group_key_type = KEY_TYPE_NA;\n\t\t\t\t}\n\n\t\t\t\tif (ieee->group_key_type) {\n\t\t\t\t\tsetKey(dev, ipw->u.crypt.idx,\n\t\t\t\t\t        \n\t\t\t\t\t       ipw->u.crypt.idx,\n\t\t\t\t\t        \n\t\t\t\t\t       ieee->group_key_type,\n\t\t\t\t\t        \n\t\t\t\t\t       broadcast_addr,\n\t\t\t\t\t        \n\t\t\t\t\t       0,\n\t\t\t\t\t        \n\t\t\t\t\t       key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = ieee80211_wpa_supplicant_ioctl(priv->ieee80211,\n\t\t\t\t\t\t     &wrq->u.data);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tkfree(ipw);\n\tipw = NULL;\nout:\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic u8 HwRateToMRate90(bool bIsHT, u8 rate)\n{\n\tu8  ret_rate = 0xff;\n\n\tif (!bIsHT) {\n\t\tswitch (rate) {\n\t\tcase DESC90_RATE1M:\n\t\t\tret_rate = MGN_1M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE2M:\n\t\t\tret_rate = MGN_2M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE5_5M:\n\t\t\tret_rate = MGN_5_5M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE11M:\n\t\t\tret_rate = MGN_11M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE6M:\n\t\t\tret_rate = MGN_6M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE9M:\n\t\t\tret_rate = MGN_9M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE12M:\n\t\t\tret_rate = MGN_12M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE18M:\n\t\t\tret_rate = MGN_18M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE24M:\n\t\t\tret_rate = MGN_24M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE36M:\n\t\t\tret_rate = MGN_36M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE48M:\n\t\t\tret_rate = MGN_48M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE54M:\n\t\t\tret_rate = MGN_54M;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret_rate = 0xff;\n\t\t\tRT_TRACE(COMP_RECV,\n\t\t\t\t \"%s: Non supported Rate [%x], bIsHT = %d!!!\\n\",\n\t\t\t\t __func__, rate, bIsHT);\n\t\t\tbreak;\n\t\t}\n\n\t} else {\n\t\tswitch (rate) {\n\t\tcase DESC90_RATEMCS0:\n\t\t\tret_rate = MGN_MCS0;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS1:\n\t\t\tret_rate = MGN_MCS1;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS2:\n\t\t\tret_rate = MGN_MCS2;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS3:\n\t\t\tret_rate = MGN_MCS3;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS4:\n\t\t\tret_rate = MGN_MCS4;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS5:\n\t\t\tret_rate = MGN_MCS5;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS6:\n\t\t\tret_rate = MGN_MCS6;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS7:\n\t\t\tret_rate = MGN_MCS7;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS8:\n\t\t\tret_rate = MGN_MCS8;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS9:\n\t\t\tret_rate = MGN_MCS9;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS10:\n\t\t\tret_rate = MGN_MCS10;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS11:\n\t\t\tret_rate = MGN_MCS11;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS12:\n\t\t\tret_rate = MGN_MCS12;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS13:\n\t\t\tret_rate = MGN_MCS13;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS14:\n\t\t\tret_rate = MGN_MCS14;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS15:\n\t\t\tret_rate = MGN_MCS15;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS32:\n\t\t\tret_rate = 0x80 | 0x20;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret_rate = 0xff;\n\t\t\tRT_TRACE(COMP_RECV,\n\t\t\t\t \"%s: Non supported Rate [%x], bIsHT = %d!!!\\n\",\n\t\t\t\t __func__, rate, bIsHT);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret_rate;\n}\n\n \nstatic void UpdateRxPktTimeStamp8190(struct net_device *dev,\n\t\t\t\t     struct ieee80211_rx_stats *stats)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\n\tif (stats->bIsAMPDU && !stats->bFirstMPDU) {\n\t\tstats->mac_time[0] = priv->LastRxDescTSFLow;\n\t\tstats->mac_time[1] = priv->LastRxDescTSFHigh;\n\t} else {\n\t\tpriv->LastRxDescTSFLow = stats->mac_time[0];\n\t\tpriv->LastRxDescTSFHigh = stats->mac_time[1];\n\t}\n}\n\n \nstatic long rtl819x_translate_todbm(u8 signal_strength_index)\n{\n\tlong\tsignal_power;  \n\n\t \n\tsignal_power = (long)((signal_strength_index + 1) >> 1);\n\tsignal_power -= 95;\n\n\treturn signal_power;\n}\n\n \nstatic void rtl8192_process_phyinfo(struct r8192_priv *priv, u8 *buffer,\n\t\t\t\t    struct ieee80211_rx_stats *pprevious_stats,\n\t\t\t\t    struct ieee80211_rx_stats *pcurrent_stats)\n{\n\tbool bcheck = false;\n\tu8\trfpath;\n\tu32\tnspatial_stream, tmp_val;\n\tstatic u32 slide_rssi_index, slide_rssi_statistics;\n\tstatic u32 slide_evm_index, slide_evm_statistics;\n\tstatic u32 last_rssi, last_evm;\n\n\tstatic u32 slide_beacon_adc_pwdb_index;\n\tstatic u32 slide_beacon_adc_pwdb_statistics;\n\tstatic u32 last_beacon_adc_pwdb;\n\n\tstruct rtl_80211_hdr_3addr *hdr;\n\tu16 sc;\n\tunsigned int seq;\n\n\thdr = (struct rtl_80211_hdr_3addr *)buffer;\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\tseq = WLAN_GET_SEQ_SEQ(sc);\n\t \n\tpcurrent_stats->Seq_Num = seq;\n\n\t \n\tif (!pprevious_stats->bIsAMPDU) {\n\t\t \n\t\tbcheck = true;\n\t}\n\n\tif (slide_rssi_statistics++ >= PHY_RSSI_SLID_WIN_MAX) {\n\t\tslide_rssi_statistics = PHY_RSSI_SLID_WIN_MAX;\n\t\tlast_rssi = priv->stats.slide_signal_strength[slide_rssi_index];\n\t\tpriv->stats.slide_rssi_total -= last_rssi;\n\t}\n\tpriv->stats.slide_rssi_total += pprevious_stats->SignalStrength;\n\n\tpriv->stats.slide_signal_strength[slide_rssi_index++] =\n\t\tpprevious_stats->SignalStrength;\n\tif (slide_rssi_index >= PHY_RSSI_SLID_WIN_MAX)\n\t\tslide_rssi_index = 0;\n\n\t \n\ttmp_val = priv->stats.slide_rssi_total / slide_rssi_statistics;\n\tpriv->stats.signal_strength = rtl819x_translate_todbm((u8)tmp_val);\n\tpcurrent_stats->rssi = priv->stats.signal_strength;\n\n\t \n\tif (!pprevious_stats->bPacketMatchBSSID) {\n\t\tif (!pprevious_stats->bToSelfBA)\n\t\t\treturn;\n\t}\n\n\tif (!bcheck)\n\t\treturn;\n\n\t \n\n\t \n\tpriv->stats.num_process_phyinfo++;\n\n\t \n\n\t \n\tif (!pprevious_stats->bIsCCK &&\n\t    (pprevious_stats->bPacketToSelf || pprevious_stats->bToSelfBA)) {\n\t\tfor (rfpath = RF90_PATH_A; rfpath < priv->NumTotalRFPath; rfpath++) {\n\t\t\tif (!rtl8192_phy_CheckIsLegalRFPath(priv->ieee80211->dev,\n\t\t\t\t\t\t\t    rfpath))\n\t\t\t\tcontinue;\n\t\t\tif (priv->stats.rx_rssi_percentage[rfpath] == 0)\n\t\t\t\tpriv->stats.rx_rssi_percentage[rfpath] =\n\t\t\t\t\tpprevious_stats->RxMIMOSignalStrength[rfpath];\n\t\t\tif (pprevious_stats->RxMIMOSignalStrength[rfpath]  > priv->stats.rx_rssi_percentage[rfpath]) {\n\t\t\t\tpriv->stats.rx_rssi_percentage[rfpath] =\n\t\t\t\t\t((priv->stats.rx_rssi_percentage[rfpath] * (RX_SMOOTH_FACTOR - 1)) +\n\t\t\t\t\t (pprevious_stats->RxMIMOSignalStrength[rfpath])) / (RX_SMOOTH_FACTOR);\n\t\t\t\tpriv->stats.rx_rssi_percentage[rfpath] = priv->stats.rx_rssi_percentage[rfpath]  + 1;\n\t\t\t} else {\n\t\t\t\tpriv->stats.rx_rssi_percentage[rfpath] =\n\t\t\t\t\t((priv->stats.rx_rssi_percentage[rfpath] * (RX_SMOOTH_FACTOR - 1)) +\n\t\t\t\t\t (pprevious_stats->RxMIMOSignalStrength[rfpath])) / (RX_SMOOTH_FACTOR);\n\t\t\t}\n\t\t\tRT_TRACE(COMP_DBG,\n\t\t\t\t \"priv->stats.rx_rssi_percentage[rfPath]  = %d\\n\",\n\t\t\t\t priv->stats.rx_rssi_percentage[rfpath]);\n\t\t}\n\t}\n\n\t \n\tRT_TRACE(COMP_RXDESC, \"Smooth %s PWDB = %d\\n\",\n\t\t pprevious_stats->bIsCCK ? \"CCK\" : \"OFDM\",\n\t\t pprevious_stats->RxPWDBAll);\n\n\tif (pprevious_stats->bPacketBeacon) {\n\t\t \n\t\tif (slide_beacon_adc_pwdb_statistics++ >= PHY_Beacon_RSSI_SLID_WIN_MAX) {\n\t\t\tslide_beacon_adc_pwdb_statistics = PHY_Beacon_RSSI_SLID_WIN_MAX;\n\t\t\tlast_beacon_adc_pwdb = priv->stats.Slide_Beacon_pwdb[slide_beacon_adc_pwdb_index];\n\t\t\tpriv->stats.Slide_Beacon_Total -= last_beacon_adc_pwdb;\n\t\t}\n\t\tpriv->stats.Slide_Beacon_Total += pprevious_stats->RxPWDBAll;\n\t\tpriv->stats.Slide_Beacon_pwdb[slide_beacon_adc_pwdb_index] = pprevious_stats->RxPWDBAll;\n\t\tslide_beacon_adc_pwdb_index++;\n\t\tif (slide_beacon_adc_pwdb_index >= PHY_Beacon_RSSI_SLID_WIN_MAX)\n\t\t\tslide_beacon_adc_pwdb_index = 0;\n\t\tpprevious_stats->RxPWDBAll = priv->stats.Slide_Beacon_Total / slide_beacon_adc_pwdb_statistics;\n\t\tif (pprevious_stats->RxPWDBAll >= 3)\n\t\t\tpprevious_stats->RxPWDBAll -= 3;\n\t}\n\n\tRT_TRACE(COMP_RXDESC, \"Smooth %s PWDB = %d\\n\",\n\t\t pprevious_stats->bIsCCK ? \"CCK\" : \"OFDM\",\n\t\t pprevious_stats->RxPWDBAll);\n\n\tif (pprevious_stats->bPacketToSelf ||\n\t    pprevious_stats->bPacketBeacon ||\n\t    pprevious_stats->bToSelfBA) {\n\t\tif (priv->undecorated_smoothed_pwdb < 0)\n\t\t\t \n\t\t\tpriv->undecorated_smoothed_pwdb =\n\t\t\t\tpprevious_stats->RxPWDBAll;\n\t\tif (pprevious_stats->RxPWDBAll > (u32)priv->undecorated_smoothed_pwdb) {\n\t\t\tpriv->undecorated_smoothed_pwdb =\n\t\t\t\t(((priv->undecorated_smoothed_pwdb) * (RX_SMOOTH_FACTOR - 1)) +\n\t\t\t\t (pprevious_stats->RxPWDBAll)) / (RX_SMOOTH_FACTOR);\n\t\t\tpriv->undecorated_smoothed_pwdb = priv->undecorated_smoothed_pwdb + 1;\n\t\t} else {\n\t\t\tpriv->undecorated_smoothed_pwdb =\n\t\t\t\t(((priv->undecorated_smoothed_pwdb) * (RX_SMOOTH_FACTOR - 1)) +\n\t\t\t\t (pprevious_stats->RxPWDBAll)) / (RX_SMOOTH_FACTOR);\n\t\t}\n\t}\n\n\t \n\t \n\tif (pprevious_stats->SignalQuality) {\n\t\tif (pprevious_stats->bPacketToSelf ||\n\t\t    pprevious_stats->bPacketBeacon ||\n\t\t    pprevious_stats->bToSelfBA) {\n\t\t\tif (slide_evm_statistics++ >= PHY_RSSI_SLID_WIN_MAX) {\n\t\t\t\tslide_evm_statistics = PHY_RSSI_SLID_WIN_MAX;\n\t\t\t\tlast_evm = priv->stats.slide_evm[slide_evm_index];\n\t\t\t\tpriv->stats.slide_evm_total -= last_evm;\n\t\t\t}\n\n\t\t\tpriv->stats.slide_evm_total +=\n\t\t\t\tpprevious_stats->SignalQuality;\n\n\t\t\tpriv->stats.slide_evm[slide_evm_index++] =\n\t\t\t\tpprevious_stats->SignalQuality;\n\t\t\tif (slide_evm_index >= PHY_RSSI_SLID_WIN_MAX)\n\t\t\t\tslide_evm_index = 0;\n\n\t\t\t \n\t\t\ttmp_val = priv->stats.slide_evm_total /\n\t\t\t\t  slide_evm_statistics;\n\t\t\tpriv->stats.signal_quality = tmp_val;\n\t\t\t \n\t\t\tpriv->stats.last_signal_strength_inpercent = tmp_val;\n\t\t}\n\n\t\t \n\t\tif (pprevious_stats->bPacketToSelf ||\n\t\t    pprevious_stats->bPacketBeacon ||\n\t\t    pprevious_stats->bToSelfBA) {\n\t\t\tfor (nspatial_stream = 0; nspatial_stream < 2; nspatial_stream++) {  \n\t\t\t\tif (pprevious_stats->RxMIMOSignalQuality[nspatial_stream] != -1) {\n\t\t\t\t\tif (priv->stats.rx_evm_percentage[nspatial_stream] == 0)  \n\t\t\t\t\t\tpriv->stats.rx_evm_percentage[nspatial_stream] = pprevious_stats->RxMIMOSignalQuality[nspatial_stream];\n\t\t\t\t\tpriv->stats.rx_evm_percentage[nspatial_stream] =\n\t\t\t\t\t\t((priv->stats.rx_evm_percentage[nspatial_stream] * (RX_SMOOTH_FACTOR - 1)) +\n\t\t\t\t\t\t (pprevious_stats->RxMIMOSignalQuality[nspatial_stream] * 1)) / (RX_SMOOTH_FACTOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic u8 rtl819x_query_rxpwrpercentage(s8 antpower)\n{\n\tif ((antpower <= -100) || (antpower >= 20))\n\t\treturn\t0;\n\telse if (antpower >= 0)\n\t\treturn\t100;\n\telse\n\t\treturn\t100 + antpower;\n\n}\t \n\nstatic u8 rtl819x_evm_dbtopercentage(s8 value)\n{\n\ts8 ret_val = clamp(-value, 0, 33) * 3;\n\n\tif (ret_val == 99)\n\t\tret_val = 100;\n\n\treturn ret_val;\n}\n\n \nstatic long rtl819x_signal_scale_mapping(long currsig)\n{\n\tlong retsig;\n\n\t \n\tif (currsig >= 61 && currsig <= 100)\n\t\tretsig = 90 + ((currsig - 60) / 4);\n\telse if (currsig >= 41 && currsig <= 60)\n\t\tretsig = 78 + ((currsig - 40) / 2);\n\telse if (currsig >= 31 && currsig <= 40)\n\t\tretsig = 66 + (currsig - 30);\n\telse if (currsig >= 21 && currsig <= 30)\n\t\tretsig = 54 + (currsig - 20);\n\telse if (currsig >= 5 && currsig <= 20)\n\t\tretsig = 42 + (((currsig - 5) * 2) / 3);\n\telse if (currsig == 4)\n\t\tretsig = 36;\n\telse if (currsig == 3)\n\t\tretsig = 27;\n\telse if (currsig == 2)\n\t\tretsig = 18;\n\telse if (currsig == 1)\n\t\tretsig = 9;\n\telse\n\t\tretsig = currsig;\n\n\treturn retsig;\n}\n\nstatic inline bool rx_hal_is_cck_rate(struct rx_drvinfo_819x_usb *pdrvinfo)\n{\n\tif (pdrvinfo->RxHT)\n\t\treturn false;\n\n\tswitch (pdrvinfo->RxRate) {\n\tcase DESC90_RATE1M:\n\tcase DESC90_RATE2M:\n\tcase DESC90_RATE5_5M:\n\tcase DESC90_RATE11M:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void rtl8192_query_rxphystatus(struct r8192_priv *priv,\n\t\t\t\t      struct ieee80211_rx_stats *pstats,\n\t\t\t\t      struct rx_drvinfo_819x_usb  *pdrvinfo,\n\t\t\t\t      struct ieee80211_rx_stats *precord_stats,\n\t\t\t\t      bool bpacket_match_bssid,\n\t\t\t\t      bool bpacket_toself,\n\t\t\t\t      bool bPacketBeacon,\n\t\t\t\t      bool bToSelfBA)\n{\n\tphy_sts_ofdm_819xusb_t *pofdm_buf;\n\tphy_sts_cck_819xusb_t\t*pcck_buf;\n\tstruct phy_ofdm_rx_status_rxsc_sgien_exintfflag *prxsc;\n\tu8\t*prxpkt;\n\tu8\ti, max_spatial_stream, tmp_rxsnr, tmp_rxevm, rxsc_sgien_exflg;\n\ts8\trx_pwr[4], rx_pwr_all = 0;\n\ts8\trx_snrX, rx_evmX;\n\tu8\tevm, pwdb_all;\n\tu32\tRSSI, total_rssi = 0;\n\tu8\tis_cck_rate = 0;\n\tu8\trf_rx_num = 0;\n\tu8\tsq;\n\n\tpriv->stats.numqry_phystatus++;\n\n\tis_cck_rate = rx_hal_is_cck_rate(pdrvinfo);\n\n\t \n\tmemset(precord_stats, 0, sizeof(struct ieee80211_rx_stats));\n\tpstats->bPacketMatchBSSID =\n\t\tprecord_stats->bPacketMatchBSSID = bpacket_match_bssid;\n\tpstats->bPacketToSelf = precord_stats->bPacketToSelf = bpacket_toself;\n\tpstats->bIsCCK = precord_stats->bIsCCK = is_cck_rate;\n\tpstats->bPacketBeacon = precord_stats->bPacketBeacon = bPacketBeacon;\n\tpstats->bToSelfBA = precord_stats->bToSelfBA = bToSelfBA;\n\n\tprxpkt = (u8 *)pdrvinfo;\n\n\t \n\tprxpkt += sizeof(struct rx_drvinfo_819x_usb);\n\n\t \n\tpcck_buf = (phy_sts_cck_819xusb_t *)prxpkt;\n\tpofdm_buf = (phy_sts_ofdm_819xusb_t *)prxpkt;\n\n\tpstats->RxMIMOSignalQuality[0] = -1;\n\tpstats->RxMIMOSignalQuality[1] = -1;\n\tprecord_stats->RxMIMOSignalQuality[0] = -1;\n\tprecord_stats->RxMIMOSignalQuality[1] = -1;\n\n\tif (is_cck_rate) {\n\t\t \n\n\t\t \n\t\tu8 report;\n\n\t\tpriv->stats.numqry_phystatusCCK++;\n\n\t\tif (!priv->bCckHighPower) {\n\t\t\treport = pcck_buf->cck_agc_rpt & 0xc0;\n\t\t\treport >>= 6;\n\t\t\tswitch (report) {\n\t\t\tcase 0x3:\n\t\t\t\trx_pwr_all = -35 - (pcck_buf->cck_agc_rpt & 0x3e);\n\t\t\t\tbreak;\n\t\t\tcase 0x2:\n\t\t\t\trx_pwr_all = -23 - (pcck_buf->cck_agc_rpt & 0x3e);\n\t\t\t\tbreak;\n\t\t\tcase 0x1:\n\t\t\t\trx_pwr_all = -11 - (pcck_buf->cck_agc_rpt & 0x3e);\n\t\t\t\tbreak;\n\t\t\tcase 0x0:\n\t\t\t\trx_pwr_all = 6 - (pcck_buf->cck_agc_rpt & 0x3e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\treport = pcck_buf->cck_agc_rpt & 0x60;\n\t\t\treport >>= 5;\n\t\t\tswitch (report) {\n\t\t\tcase 0x3:\n\t\t\t\trx_pwr_all = -35 - ((pcck_buf->cck_agc_rpt & 0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\tcase 0x2:\n\t\t\t\trx_pwr_all = -23 - ((pcck_buf->cck_agc_rpt & 0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\tcase 0x1:\n\t\t\t\trx_pwr_all = -11 - ((pcck_buf->cck_agc_rpt & 0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\tcase 0x0:\n\t\t\t\trx_pwr_all = 6 - ((pcck_buf->cck_agc_rpt & 0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpwdb_all = rtl819x_query_rxpwrpercentage(rx_pwr_all);\n\t\tpstats->RxPWDBAll = precord_stats->RxPWDBAll = pwdb_all;\n\t\tpstats->RecvSignalPower = pwdb_all;\n\n\t\t \n\n\t\tif (pstats->RxPWDBAll > 40) {\n\t\t\tsq = 100;\n\t\t} else {\n\t\t\tsq = pcck_buf->sq_rpt;\n\n\t\t\tif (pcck_buf->sq_rpt > 64)\n\t\t\t\tsq = 0;\n\t\t\telse if (pcck_buf->sq_rpt < 20)\n\t\t\t\tsq = 100;\n\t\t\telse\n\t\t\t\tsq = ((64 - sq) * 100) / 44;\n\t\t}\n\t\tpstats->SignalQuality = precord_stats->SignalQuality = sq;\n\t\tpstats->RxMIMOSignalQuality[0] =\n\t\t\tprecord_stats->RxMIMOSignalQuality[0] = sq;\n\t\tpstats->RxMIMOSignalQuality[1] =\n\t\t\tprecord_stats->RxMIMOSignalQuality[1] = -1;\n\n\t} else {\n\t\tpriv->stats.numqry_phystatusHT++;\n\n\t\t \n\t\tfor (i = RF90_PATH_A; i < priv->NumTotalRFPath; i++) {\n\t\t\t \n\t\t\tif (priv->brfpath_rxenable[i])\n\t\t\t\trf_rx_num++;\n\t\t\telse\n\t\t\t\tcontinue;\n\n\t\t\tif (!rtl8192_phy_CheckIsLegalRFPath(priv->ieee80211->dev, i))\n\t\t\t\tcontinue;\n\n\t\t\trx_pwr[i] =\n\t\t\t\t((pofdm_buf->trsw_gain_X[i] & 0x3F) * 2) - 106;\n\n\t\t\t \n\t\t\ttmp_rxsnr =\tpofdm_buf->rxsnr_X[i];\n\t\t\trx_snrX = (s8)(tmp_rxsnr);\n\t\t\trx_snrX /= 2;\n\t\t\tpriv->stats.rxSNRdB[i] = (long)rx_snrX;\n\n\t\t\t \n\t\t\tRSSI = rtl819x_query_rxpwrpercentage(rx_pwr[i]);\n\t\t\ttotal_rssi += RSSI;\n\n\t\t\t \n\t\t\tpstats->RxMIMOSignalStrength[i] = (u8)RSSI;\n\t\t\tprecord_stats->RxMIMOSignalStrength[i] = (u8)RSSI;\n\t\t}\n\n\t\t \n\t\trx_pwr_all = (((pofdm_buf->pwdb_all) >> 1) & 0x7f) - 106;\n\t\tpwdb_all = rtl819x_query_rxpwrpercentage(rx_pwr_all);\n\n\t\tpstats->RxPWDBAll = precord_stats->RxPWDBAll = pwdb_all;\n\t\tpstats->RxPower = precord_stats->RxPower =  rx_pwr_all;\n\n\t\t \n\t\tif (pdrvinfo->RxHT && pdrvinfo->RxRate >= DESC90_RATEMCS8 &&\n\t\t    pdrvinfo->RxRate <= DESC90_RATEMCS15)\n\t\t\t \n\t\t\tmax_spatial_stream = 2;\n\t\telse\n\t\t\t \n\t\t\tmax_spatial_stream = 1;\n\n\t\tfor (i = 0; i < max_spatial_stream; i++) {\n\t\t\ttmp_rxevm =\tpofdm_buf->rxevm_X[i];\n\t\t\trx_evmX = (s8)(tmp_rxevm);\n\n\t\t\t \n\t\t\trx_evmX /= 2;\t \n\n\t\t\tevm = rtl819x_evm_dbtopercentage(rx_evmX);\n\t\t\tif (i == 0)\n\t\t\t\t \n\t\t\t\tpstats->SignalQuality =\n\t\t\t\t\tprecord_stats->SignalQuality =\n\t\t\t\t\tevm & 0xff;\n\t\t\tpstats->RxMIMOSignalQuality[i] =\n\t\t\t\tprecord_stats->RxMIMOSignalQuality[i] =\n\t\t\t\tevm & 0xff;\n\t\t}\n\n\t\t \n\t\trxsc_sgien_exflg = pofdm_buf->rxsc_sgien_exflg;\n\t\tprxsc =\t(struct phy_ofdm_rx_status_rxsc_sgien_exintfflag *)\n\t\t\t&rxsc_sgien_exflg;\n\t\tif (pdrvinfo->BW)\t \n\t\t\tpriv->stats.received_bwtype[1 + prxsc->rxsc]++;\n\t\telse\t\t\t \n\t\t\tpriv->stats.received_bwtype[0]++;\n\t}\n\n\t \n\tif (is_cck_rate) {\n\t\tpstats->SignalStrength =\n\t\t\tprecord_stats->SignalStrength =\n\t\t\t(u8)(rtl819x_signal_scale_mapping((long)pwdb_all));\n\t} else {\n\t\t \n\t\tif (rf_rx_num != 0) {\n\t\t\tpstats->SignalStrength =\n\t\t\t\tprecord_stats->SignalStrength =\n\t\t\t\t(u8)(rtl819x_signal_scale_mapping((long)(total_rssi /= rf_rx_num)));\n\t\t}\n\t}\n}\t \n\nstatic void rtl8192_record_rxdesc_forlateruse(struct ieee80211_rx_stats *psrc_stats,\n\t\t\t\t\t      struct ieee80211_rx_stats *ptarget_stats)\n{\n\tptarget_stats->bIsAMPDU = psrc_stats->bIsAMPDU;\n\tptarget_stats->bFirstMPDU = psrc_stats->bFirstMPDU;\n\tptarget_stats->Seq_Num = psrc_stats->Seq_Num;\n}\n\nstatic void TranslateRxSignalStuff819xUsb(struct sk_buff *skb,\n\t\t\t\t\t  struct ieee80211_rx_stats *pstats,\n\t\t\t\t\t  struct rx_drvinfo_819x_usb  *pdrvinfo)\n{\n\t \n\tstruct rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;\n\tstruct net_device *dev = info->dev;\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tbool bpacket_match_bssid, bpacket_toself;\n\tbool bPacketBeacon = false, bToSelfBA = false;\n\tstatic struct ieee80211_rx_stats  previous_stats;\n\tstruct rtl_80211_hdr_3addr *hdr;\n\tu16 fc, type;\n\n\t \n\n\tu8 *tmp_buf;\n\tu8  *praddr;\n\n\t \n\ttmp_buf = (u8 *)skb->data;\n\n\thdr = (struct rtl_80211_hdr_3addr *)tmp_buf;\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tpraddr = hdr->addr1;\n\n\t \n\tbpacket_match_bssid = (type != IEEE80211_FTYPE_CTL) &&\n\t\t\t       (ether_addr_equal(priv->ieee80211->current_network.bssid,  (fc & IEEE80211_FCTL_TODS) ? hdr->addr1 : (fc & IEEE80211_FCTL_FROMDS) ? hdr->addr2 : hdr->addr3))\n\t\t\t       && (!pstats->bHwError) && (!pstats->bCRC) && (!pstats->bICV);\n\tbpacket_toself =  bpacket_match_bssid &&\n\t\t\t  (ether_addr_equal(praddr, priv->ieee80211->dev->dev_addr));\n\n\tif (WLAN_FC_GET_FRAMETYPE(fc) == IEEE80211_STYPE_BEACON)\n\t\tbPacketBeacon = true;\n\tif (WLAN_FC_GET_FRAMETYPE(fc) == IEEE80211_STYPE_BLOCKACK) {\n\t\tif ((ether_addr_equal(praddr, dev->dev_addr)))\n\t\t\tbToSelfBA = true;\n\t}\n\n\tif (bpacket_match_bssid)\n\t\tpriv->stats.numpacket_matchbssid++;\n\tif (bpacket_toself)\n\t\tpriv->stats.numpacket_toself++;\n\t \n\trtl8192_process_phyinfo(priv, tmp_buf, &previous_stats, pstats);\n\trtl8192_query_rxphystatus(priv, pstats, pdrvinfo, &previous_stats,\n\t\t\t\t  bpacket_match_bssid, bpacket_toself,\n\t\t\t\t  bPacketBeacon, bToSelfBA);\n\trtl8192_record_rxdesc_forlateruse(pstats, &previous_stats);\n}\n\n \nstatic void\nUpdateReceivedRateHistogramStatistics8190(struct net_device *dev,\n\t\t\t\t\t  struct ieee80211_rx_stats *stats)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\t \n\tu32 rcvType = 1;\n\tu32 rateIndex;\n\t \n\tu32 preamble_guardinterval;\n\n\tif (stats->bCRC)\n\t\trcvType = 2;\n\telse if (stats->bICV)\n\t\trcvType = 3;\n\n\tif (stats->bShortPreamble)\n\t\tpreamble_guardinterval = 1;  \n\telse\n\t\tpreamble_guardinterval = 0;  \n\n\tswitch (stats->rate) {\n\t \n\tcase MGN_1M:\n\t\trateIndex = 0;\n\t\tbreak;\n\tcase MGN_2M:\n\t\trateIndex = 1;\n\t\tbreak;\n\tcase MGN_5_5M:\n\t\trateIndex = 2;\n\t\tbreak;\n\tcase MGN_11M:\n\t\trateIndex = 3;\n\t\tbreak;\n\t \n\tcase MGN_6M:\n\t\trateIndex = 4;\n\t\tbreak;\n\tcase MGN_9M:\n\t\trateIndex = 5;\n\t\tbreak;\n\tcase MGN_12M:\n\t\trateIndex = 6;\n\t\tbreak;\n\tcase MGN_18M:\n\t\trateIndex = 7;\n\t\tbreak;\n\tcase MGN_24M:\n\t\trateIndex = 8;\n\t\tbreak;\n\tcase MGN_36M:\n\t\trateIndex = 9;\n\t\tbreak;\n\tcase MGN_48M:\n\t\trateIndex = 10;\n\t\tbreak;\n\tcase MGN_54M:\n\t\trateIndex = 11;\n\t\tbreak;\n\t \n\tcase MGN_MCS0:\n\t\trateIndex = 12;\n\t\tbreak;\n\tcase MGN_MCS1:\n\t\trateIndex = 13;\n\t\tbreak;\n\tcase MGN_MCS2:\n\t\trateIndex = 14;\n\t\tbreak;\n\tcase MGN_MCS3:\n\t\trateIndex = 15;\n\t\tbreak;\n\tcase MGN_MCS4:\n\t\trateIndex = 16;\n\t\tbreak;\n\tcase MGN_MCS5:\n\t\trateIndex = 17;\n\t\tbreak;\n\tcase MGN_MCS6:\n\t\trateIndex = 18;\n\t\tbreak;\n\tcase MGN_MCS7:\n\t\trateIndex = 19;\n\t\tbreak;\n\tcase MGN_MCS8:\n\t\trateIndex = 20;\n\t\tbreak;\n\tcase MGN_MCS9:\n\t\trateIndex = 21;\n\t\tbreak;\n\tcase MGN_MCS10:\n\t\trateIndex = 22;\n\t\tbreak;\n\tcase MGN_MCS11:\n\t\trateIndex = 23;\n\t\tbreak;\n\tcase MGN_MCS12:\n\t\trateIndex = 24;\n\t\tbreak;\n\tcase MGN_MCS13:\n\t\trateIndex = 25;\n\t\tbreak;\n\tcase MGN_MCS14:\n\t\trateIndex = 26;\n\t\tbreak;\n\tcase MGN_MCS15:\n\t\trateIndex = 27;\n\t\tbreak;\n\tdefault:\n\t\trateIndex = 28;\n\t\tbreak;\n\t}\n\tpriv->stats.received_preamble_GI[preamble_guardinterval][rateIndex]++;\n\tpriv->stats.received_rate_histogram[0][rateIndex]++;  \n\tpriv->stats.received_rate_histogram[rcvType][rateIndex]++;\n}\n\nstatic void query_rxdesc_status(struct sk_buff *skb,\n\t\t\t\tstruct ieee80211_rx_stats *stats,\n\t\t\t\tbool bIsRxAggrSubframe)\n{\n\tstruct rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;\n\tstruct net_device *dev = info->dev;\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct rx_drvinfo_819x_usb  *driver_info = NULL;\n\n\t \n\tstruct rx_desc_819x_usb *desc = (struct rx_desc_819x_usb *)skb->data;\n\n\tstats->Length = desc->Length;\n\tstats->RxDrvInfoSize = desc->RxDrvInfoSize;\n\tstats->RxBufShift = 0;\n\tstats->bICV = desc->ICV;\n\tstats->bCRC = desc->CRC32;\n\tstats->bHwError = stats->bCRC | stats->bICV;\n\t \n\tstats->Decrypted = !desc->SWDec;\n\n\tif ((priv->ieee80211->pHTInfo->bCurrentHTSupport) &&\n\t    (priv->ieee80211->pairwise_key_type == KEY_TYPE_CCMP))\n\t\tstats->bHwError = false;\n\telse\n\t\tstats->bHwError = stats->bCRC | stats->bICV;\n\n\tif (stats->Length < 24 || stats->Length > MAX_8192U_RX_SIZE)\n\t\tstats->bHwError |= 1;\n\t \n\t \n\tif (stats->RxDrvInfoSize != 0) {\n\t\tdriver_info = (struct rx_drvinfo_819x_usb *)(skb->data\n\t\t\t\t+ sizeof(struct rx_desc_819x_usb)\n\t\t\t\t+ stats->RxBufShift\n\t\t\t      );\n\t\t \n\t\t \n\t\tif (!stats->bHwError) {\n\t\t\tu8\tret_rate;\n\n\t\t\tret_rate = HwRateToMRate90(driver_info->RxHT,\n\t\t\t\t\t\t   driver_info->RxRate);\n\t\t\tif (ret_rate == 0xff) {\n\t\t\t\t \n\n\t\t\t\tstats->bHwError = 1;\n\t\t\t\t \n\t\t\t\tstats->rate = MGN_1M;\n\t\t\t} else {\n\t\t\t\tstats->rate = ret_rate;\n\t\t\t}\n\t\t} else {\n\t\t\tstats->rate = 0x02;\n\t\t}\n\n\t\tstats->bShortPreamble = driver_info->SPLCP;\n\n\t\tUpdateReceivedRateHistogramStatistics8190(dev, stats);\n\n\t\tstats->bIsAMPDU = (driver_info->PartAggr == 1);\n\t\tstats->bFirstMPDU = (driver_info->PartAggr == 1) &&\n\t\t\t\t    (driver_info->FirstAGGR == 1);\n\t\tstats->TimeStampLow = driver_info->TSFL;\n\n\t\tUpdateRxPktTimeStamp8190(dev, stats);\n\n\t\t \n\t\tif (driver_info->FirstAGGR == 1 || driver_info->PartAggr == 1)\n\t\t\tRT_TRACE(COMP_RXDESC,\n\t\t\t\t \"driver_info->FirstAGGR = %d, driver_info->PartAggr = %d\\n\",\n\t\t\t\t driver_info->FirstAGGR, driver_info->PartAggr);\n\t}\n\n\tskb_pull(skb, sizeof(struct rx_desc_819x_usb));\n\t \n\tif ((stats->RxBufShift + stats->RxDrvInfoSize) > 0) {\n\t\tstats->bShift = 1;\n\t\tskb_pull(skb, stats->RxBufShift + stats->RxDrvInfoSize);\n\t}\n\n\tif (driver_info) {\n\t\tstats->RxIs40MHzPacket = driver_info->BW;\n\t\tTranslateRxSignalStuff819xUsb(skb, stats, driver_info);\n\t}\n}\n\nstatic void rtl8192_rx_nomal(struct sk_buff *skb)\n{\n\tstruct rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;\n\tstruct net_device *dev = info->dev;\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct ieee80211_rx_stats stats = {\n\t\t.signal = 0,\n\t\t.noise = 0x100 - 98,\n\t\t.rate = 0,\n\t\t.freq = IEEE80211_24GHZ_BAND,\n\t};\n\tu32 rx_pkt_len = 0;\n\tstruct rtl_80211_hdr_1addr *ieee80211_hdr = NULL;\n\tbool unicast_packet = false;\n\n\t \n\tif ((skb->len >= (20 + sizeof(struct rx_desc_819x_usb))) && (skb->len < RX_URB_SIZE)) {\n\t\t \n\t\tquery_rxdesc_status(skb, &stats, false);\n\t\t \n\t\t \n\t\t \n\t\tskb_trim(skb, skb->len - 4 );\n\n\t\trx_pkt_len = skb->len;\n\t\tieee80211_hdr = (struct rtl_80211_hdr_1addr *)skb->data;\n\t\tunicast_packet = false;\n\t\tif (is_broadcast_ether_addr(ieee80211_hdr->addr1)) {\n\t\t\t \n\t\t} else if (is_multicast_ether_addr(ieee80211_hdr->addr1)) {\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tunicast_packet = true;\n\t\t}\n\n\t\tif (!ieee80211_rx(priv->ieee80211, skb, &stats)) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t} else {\n\t\t\tpriv->stats.rxoktotal++;\n\t\t\tif (unicast_packet)\n\t\t\t\tpriv->stats.rxbytesunicast += rx_pkt_len;\n\t\t}\n\t} else {\n\t\tpriv->stats.rxurberr++;\n\t\tnetdev_dbg(dev, \"actual_length: %d\\n\", skb->len);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void rtl819xusb_process_received_packet(struct net_device *dev,\n\t\t\t\t\t       struct ieee80211_rx_stats *pstats)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\t \n\tpstats->virtual_address += get_rxpacket_shiftbytes_819xusb(pstats);\n#ifdef TODO\t \n\tif (!Adapter->bInHctTest)\n\t\tCountRxErrStatistics(Adapter, pRfd);\n#endif\n#ifdef ENABLE_PS   \n\tRT_RF_POWER_STATE rtState;\n\t \n\tAdapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE,\n\t\t\t\t\t (u8 *)(&rtState));\n\tif (rtState == eRfOff)\n\t\treturn;\n#endif\n\tpriv->stats.rxframgment++;\n\n#ifdef TODO\n\tRmMonitorSignalStrength(Adapter, pRfd);\n#endif\n\t \n\tif (rtl819xusb_rx_command_packet(dev, pstats))\n\t\treturn;\n\n#ifdef SW_CRC_CHECK\n\tSwCrcCheck();\n#endif\n}\n\nstatic void query_rx_cmdpkt_desc_status(struct sk_buff *skb,\n\t\t\t\t\tstruct ieee80211_rx_stats *stats)\n{\n\tstruct rx_desc_819x_usb *desc = (struct rx_desc_819x_usb *)skb->data;\n\n\t \n\tstats->virtual_address = (u8 *)skb->data;\n\tstats->Length = desc->Length;\n\tstats->RxDrvInfoSize = 0;\n\tstats->RxBufShift = 0;\n\tstats->packetlength = stats->Length - scrclng;\n\tstats->fraglength = stats->packetlength;\n\tstats->fragoffset = 0;\n\tstats->ntotalfrag = 1;\n}\n\nstatic void rtl8192_rx_cmd(struct sk_buff *skb)\n{\n\tstruct rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;\n\tstruct net_device *dev = info->dev;\n\t \n\tstruct ieee80211_rx_stats stats = {\n\t\t.signal = 0,\n\t\t.noise = 0x100 - 98,\n\t\t.rate = 0,\n\t\t.freq = IEEE80211_24GHZ_BAND,\n\t};\n\n\tif ((skb->len >= (20 + sizeof(struct rx_desc_819x_usb))) && (skb->len < RX_URB_SIZE)) {\n\t\tquery_rx_cmdpkt_desc_status(skb, &stats);\n\t\t \n\n\t\t \n\n\t\trtl819xusb_process_received_packet(dev, &stats);\n\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void rtl8192_irq_rx_tasklet(struct tasklet_struct *t)\n{\n\tstruct r8192_priv *priv = from_tasklet(priv, t, irq_rx_tasklet);\n\tstruct sk_buff *skb;\n\tstruct rtl8192_rx_info *info;\n\n\twhile (NULL != (skb = skb_dequeue(&priv->skb_queue))) {\n\t\tinfo = (struct rtl8192_rx_info *)skb->cb;\n\t\tswitch (info->out_pipe) {\n\t\t \n\t\tcase 3:\n\t\t\tpriv->IrpPendingCount--;\n\t\t\trtl8192_rx_nomal(skb);\n\t\t\tbreak;\n\n\t\t \n\t\tcase 9:\n\t\t\tRT_TRACE(COMP_RECV, \"command in-pipe index(%d)\\n\",\n\t\t\t\t info->out_pipe);\n\n\t\t\trtl8192_rx_cmd(skb);\n\t\t\tbreak;\n\n\t\tdefault:  \n\t\t\tRT_TRACE(COMP_ERR, \"Unknown in-pipe index(%d)\\n\",\n\t\t\t\t info->out_pipe);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic const struct net_device_ops rtl8192_netdev_ops = {\n\t.ndo_open               = rtl8192_open,\n\t.ndo_stop               = rtl8192_close,\n\t.ndo_get_stats          = rtl8192_stats,\n\t.ndo_tx_timeout         = tx_timeout,\n\t.ndo_do_ioctl           = rtl8192_ioctl,\n\t.ndo_set_rx_mode\t= r8192_set_multicast,\n\t.ndo_set_mac_address    = r8192_set_mac_adr,\n\t.ndo_validate_addr      = eth_validate_addr,\n\t.ndo_start_xmit         = ieee80211_xmit,\n};\n\n \n\nstatic int rtl8192_usb_probe(struct usb_interface *intf,\n\t\t\t     const struct usb_device_id *id)\n{\n\tstruct net_device *dev = NULL;\n\tstruct r8192_priv *priv = NULL;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tint ret;\n\n\tRT_TRACE(COMP_INIT, \"Oops: i'm coming\\n\");\n\n\tdev = alloc_ieee80211(sizeof(struct r8192_priv));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tusb_set_intfdata(intf, dev);\n\tSET_NETDEV_DEV(dev, &intf->dev);\n\tpriv = ieee80211_priv(dev);\n\tpriv->ieee80211 = netdev_priv(dev);\n\tpriv->udev = udev;\n\n\tdev->netdev_ops = &rtl8192_netdev_ops;\n\n\tdev->wireless_handlers = &r8192_wx_handlers_def;\n\n\tdev->type = ARPHRD_ETHER;\n\n\tdev->watchdog_timeo = HZ * 3;\n\n\tif (dev_alloc_name(dev, ifname) < 0) {\n\t\tRT_TRACE(COMP_INIT,\n\t\t\t \"Oops: devname already taken! Trying wlan%%d...\\n\");\n\t\tifname = \"wlan%d\";\n\t\tdev_alloc_name(dev, ifname);\n\t}\n\n\tRT_TRACE(COMP_INIT, \"Driver probe completed1\\n\");\n\tif (rtl8192_init(dev) != 0) {\n\t\tRT_TRACE(COMP_ERR, \"Initialization failed\");\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\tnetif_carrier_off(dev);\n\tnetif_stop_queue(dev);\n\n\tret = register_netdev(dev);\n\tif (ret)\n\t\tgoto fail2;\n\n\tRT_TRACE(COMP_INIT, \"dev name=======> %s\\n\", dev->name);\n\trtl8192_debugfs_init_one(dev);\n\n\tRT_TRACE(COMP_INIT, \"Driver probe completed\\n\");\n\treturn 0;\n\nfail2:\n\trtl8192_down(dev);\nfail:\n\tkfree(priv->pFirmware);\n\tpriv->pFirmware = NULL;\n\trtl8192_usb_deleteendpoints(dev);\n\tmsleep(10);\n\tfree_ieee80211(dev);\n\n\tRT_TRACE(COMP_ERR, \"wlan driver load failed\\n\");\n\treturn ret;\n}\n\n \nstatic void rtl8192_cancel_deferred_work(struct r8192_priv *priv)\n{\n\tcancel_work_sync(&priv->reset_wq);\n\tcancel_delayed_work(&priv->watch_dog_wq);\n\tcancel_delayed_work(&priv->update_beacon_wq);\n\tcancel_work_sync(&priv->qos_activate);\n}\n\nstatic void rtl8192_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct net_device *dev = usb_get_intfdata(intf);\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\n\tRT_TRACE(COMP_DOWN, \"=============>wlan driver to be removed\\n\");\n\trtl8192_debugfs_exit_one(dev);\n\n\tunregister_netdev(dev);\n\n\trtl8192_down(dev);\n\tkfree(priv->pFirmware);\n\tpriv->pFirmware = NULL;\n\trtl8192_usb_deleteendpoints(dev);\n\tusleep_range(10000, 11000);\n\tfree_ieee80211(dev);\n\n\tRT_TRACE(COMP_DOWN, \"wlan driver removed\\n\");\n}\n\nstatic int rtl8192_usb_netdev_event(struct notifier_block *nb, unsigned long event,\n\t\t\t\t    void *data)\n{\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(data);\n\n\tif (netdev->netdev_ops != &rtl8192_netdev_ops)\n\t\tgoto out;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGENAME:\n\t\trtl8192_debugfs_rename_one(netdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block rtl8192_usb_netdev_notifier = {\n\t.notifier_call = rtl8192_usb_netdev_event,\n};\n\nstatic int __init rtl8192_usb_module_init(void)\n{\n\tint ret;\n\n\tpr_info(\"\\nLinux kernel driver for RTL8192 based WLAN cards\\n\");\n\tpr_info(\"Copyright (c) 2007-2008, Realsil Wlan\\n\");\n\tRT_TRACE(COMP_INIT, \"Initializing module\");\n\tRT_TRACE(COMP_INIT, \"Wireless extensions version %d\", WIRELESS_EXT);\n\n\tret = register_netdevice_notifier(&rtl8192_usb_netdev_notifier);\n\tif (ret) {\n\t\tpr_err(\"register_netdevice_notifier failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trtl8192_debugfs_init();\n\tret = ieee80211_debug_init();\n\tif (ret) {\n\t\tpr_err(\"ieee80211_debug_init() failed %d\\n\", ret);\n\t\tgoto debugfs_exit;\n\t}\n\n\tret = ieee80211_crypto_init();\n\tif (ret) {\n\t\tpr_err(\"ieee80211_crypto_init() failed %d\\n\", ret);\n\t\tgoto debug_exit;\n\t}\n\n\tret = ieee80211_crypto_tkip_init();\n\tif (ret) {\n\t\tpr_err(\"ieee80211_crypto_tkip_init() failed %d\\n\", ret);\n\t\tgoto crypto_exit;\n\t}\n\n\tret = ieee80211_crypto_ccmp_init();\n\tif (ret) {\n\t\tpr_err(\"ieee80211_crypto_ccmp_init() failed %d\\n\", ret);\n\t\tgoto crypto_tkip_exit;\n\t}\n\n\tret = ieee80211_crypto_wep_init();\n\tif (ret) {\n\t\tpr_err(\"ieee80211_crypto_wep_init() failed %d\\n\", ret);\n\t\tgoto crypto_ccmp_exit;\n\t}\n\n\tret = usb_register(&rtl8192_usb_driver);\n\tif (ret)\n\t\tgoto crypto_wep_exit;\n\treturn ret;\n\ncrypto_wep_exit:\n\tieee80211_crypto_wep_exit();\ncrypto_ccmp_exit:\n\tieee80211_crypto_ccmp_exit();\ncrypto_tkip_exit:\n\tieee80211_crypto_tkip_exit();\ncrypto_exit:\n\tieee80211_crypto_deinit();\ndebug_exit:\n\tieee80211_debug_exit();\ndebugfs_exit:\n\trtl8192_debugfs_exit();\n\tunregister_netdevice_notifier(&rtl8192_usb_netdev_notifier);\n\treturn ret;\n}\n\nstatic void __exit rtl8192_usb_module_exit(void)\n{\n\tusb_deregister(&rtl8192_usb_driver);\n\tieee80211_crypto_wep_exit();\n\tieee80211_crypto_ccmp_exit();\n\tieee80211_crypto_tkip_exit();\n\tieee80211_crypto_deinit();\n\tieee80211_debug_exit();\n\trtl8192_debugfs_exit();\n\tunregister_netdevice_notifier(&rtl8192_usb_netdev_notifier);\n\tRT_TRACE(COMP_DOWN, \"Exiting\");\n}\n\nvoid EnableHWSecurityConfig8192(struct net_device *dev)\n{\n\tu8 SECR_value = 0x0;\n\tstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\n\tstruct ieee80211_device *ieee = priv->ieee80211;\n\n\tSECR_value = SCR_TxEncEnable | SCR_RxDecEnable;\n\tif (((ieee->pairwise_key_type == KEY_TYPE_WEP40) || (ieee->pairwise_key_type == KEY_TYPE_WEP104)) && (priv->ieee80211->auth_mode != 2)) {\n\t\tSECR_value |= SCR_RxUseDK;\n\t\tSECR_value |= SCR_TxUseDK;\n\t} else if ((ieee->iw_mode == IW_MODE_ADHOC) && (ieee->pairwise_key_type & (KEY_TYPE_CCMP | KEY_TYPE_TKIP))) {\n\t\tSECR_value |= SCR_RxUseDK;\n\t\tSECR_value |= SCR_TxUseDK;\n\t}\n\t \n\n\tieee->hwsec_active = 1;\n\n\t \n\tif ((ieee->pHTInfo->IOTAction & HT_IOT_ACT_PURE_N_MODE) || !hwwep) {\n\t\tieee->hwsec_active = 0;\n\t\tSECR_value &= ~SCR_RxDecEnable;\n\t}\n\tRT_TRACE(COMP_SEC, \"%s:, hwsec:%d, pairwise_key:%d, SECR_value:%x\\n\",\n\t\t __func__, ieee->hwsec_active, ieee->pairwise_key_type,\n\t\t SECR_value);\n\twrite_nic_byte(dev, SECR,  SECR_value);\n}\n\nvoid setKey(struct net_device *dev, u8 entryno, u8 keyindex, u16 keytype,\n\t    const u8 *macaddr, u8 defaultkey, u32 *keycontent)\n{\n\tu32 target_command = 0;\n\tu32 target_content = 0;\n\tu16 us_config = 0;\n\tu8 i;\n\n\tif (entryno >= TOTAL_CAM_ENTRY)\n\t\tRT_TRACE(COMP_ERR, \"cam entry exceeds in %s\\n\", __func__);\n\n\tRT_TRACE(COMP_SEC,\n\t\t \"====>to %s, dev:%p, EntryNo:%d, KeyIndex:%d, KeyType:%d, MacAddr%pM\\n\",\n\t\t __func__, dev, entryno, keyindex, keytype, macaddr);\n\n\tif (defaultkey)\n\t\tus_config |= BIT(15) | (keytype << 2);\n\telse\n\t\tus_config |= BIT(15) | (keytype << 2) | keyindex;\n\n\tfor (i = 0; i < CAM_CONTENT_COUNT; i++) {\n\t\ttarget_command  = i + CAM_CONTENT_COUNT * entryno;\n\t\ttarget_command |= BIT(31) | BIT(16);\n\n\t\tif (i == 0) {  \n\t\t\ttarget_content = (u32)(*(macaddr + 0)) << 16 |\n\t\t\t\t\t(u32)(*(macaddr + 1)) << 24 |\n\t\t\t\t\t(u32)us_config;\n\n\t\t\twrite_nic_dword(dev, WCAMI, target_content);\n\t\t\twrite_nic_dword(dev, RWCAM, target_command);\n\t\t} else if (i == 1) {  \n\t\t\ttarget_content = (u32)(*(macaddr + 2))\t |\n\t\t\t\t\t(u32)(*(macaddr + 3)) <<  8 |\n\t\t\t\t\t(u32)(*(macaddr + 4)) << 16 |\n\t\t\t\t\t(u32)(*(macaddr + 5)) << 24;\n\t\t\twrite_nic_dword(dev, WCAMI, target_content);\n\t\t\twrite_nic_dword(dev, RWCAM, target_command);\n\t\t} else {\n\t\t\t \n\t\t\tif (keycontent) {\n\t\t\t\twrite_nic_dword(dev, WCAMI,\n\t\t\t\t\t\t*(keycontent + i - 2));\n\t\t\t\twrite_nic_dword(dev, RWCAM, target_command);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nmodule_init(rtl8192_usb_module_init);\nmodule_exit(rtl8192_usb_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}