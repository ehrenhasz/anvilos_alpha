{
  "module_name": "r8190_rtl8256.c",
  "hash_id": "c0a24d1d0531e0e41f739753beb33ec7d858aeb351c4cd7c69356b814aecdd19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/r8190_rtl8256.c",
  "human_readable_source": "\n \n\n#include \"r8192U.h\"\n#include \"r8192U_hw.h\"\n#include \"r819xU_phyreg.h\"\n#include \"r819xU_phy.h\"\n#include \"r8190_rtl8256.h\"\n\n \nstatic void phy_rf8256_config_para_file(struct net_device *dev);\n\n \nvoid phy_set_rf8256_bandwidth(struct net_device *dev, enum ht_channel_width Bandwidth)\n{\n\tu8\teRFPath;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\t \n\tfor (eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {\n\t\tif (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))\n\t\t\tcontinue;\n\n\t\tswitch (Bandwidth) {\n\t\tcase HT_CHANNEL_WIDTH_20:\n\t\t\t\tif (priv->card_8192_version == VERSION_819XU_A ||\n\t\t\t\t    priv->card_8192_version == VERSION_819XU_B) {\n\t\t\t\t\t \n\t\t\t\t\trtl8192_phy_SetRFReg(dev,\n\t\t\t\t\t\t(enum rf90_radio_path_e)eRFPath,\n\t\t\t\t\t\t0x0b, bMask12Bits, 0x100);  \n\t\t\t\t\trtl8192_phy_SetRFReg(dev,\n\t\t\t\t\t\t(enum rf90_radio_path_e)eRFPath,\n\t\t\t\t\t\t0x2c, bMask12Bits, 0x3d7);\n\t\t\t\t\trtl8192_phy_SetRFReg(dev,\n\t\t\t\t\t\t(enum rf90_radio_path_e)eRFPath,\n\t\t\t\t\t\t0x0e, bMask12Bits, 0x021);\n\t\t\t\t\trtl8192_phy_SetRFReg(dev,\n\t\t\t\t\t\t(enum rf90_radio_path_e)eRFPath,\n\t\t\t\t\t\t0x14, bMask12Bits, 0x5ab);\n\t\t\t\t} else {\n\t\t\t\t\tRT_TRACE(COMP_ERR, \"%s(): unknown hardware version\\n\", __func__);\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\tcase HT_CHANNEL_WIDTH_20_40:\n\t\t\t\tif (priv->card_8192_version == VERSION_819XU_A || priv->card_8192_version == VERSION_819XU_B) {  \n\t\t\t\t\trtl8192_phy_SetRFReg(dev, (enum rf90_radio_path_e)eRFPath, 0x0b, bMask12Bits, 0x300);  \n\t\t\t\t\trtl8192_phy_SetRFReg(dev, (enum rf90_radio_path_e)eRFPath, 0x2c, bMask12Bits, 0x3df);\n\t\t\t\t\trtl8192_phy_SetRFReg(dev, (enum rf90_radio_path_e)eRFPath, 0x0e, bMask12Bits, 0x0a1);\n\n\t\t\t\t\tif (priv->chan == 3 || priv->chan == 9)\n\t\t\t\t\t\t \n\t\t\t\t\t\trtl8192_phy_SetRFReg(dev, (enum rf90_radio_path_e)eRFPath, 0x14, bMask12Bits, 0x59b);\n\t\t\t\t\telse\n\t\t\t\t\t\trtl8192_phy_SetRFReg(dev, (enum rf90_radio_path_e)eRFPath, 0x14, bMask12Bits, 0x5ab);\n\t\t\t\t} else {\n\t\t\t\t\tRT_TRACE(COMP_ERR, \"%s(): unknown hardware version\\n\", __func__);\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\t\tRT_TRACE(COMP_ERR, \"%s(): unknown Bandwidth: %#X\\n\", __func__, Bandwidth);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nvoid phy_rf8256_config(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\t \n\tpriv->NumTotalRFPath = RTL819X_TOTAL_RF_PATH;\n\t \n\tphy_rf8256_config_para_file(dev);\n}\n\n \nstatic void phy_rf8256_config_para_file(struct net_device *dev)\n{\n\tu32\tu4RegValue = 0;\n\tu8\teRFPath;\n\tBB_REGISTER_DEFINITION_T\t*pPhyReg;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu32\tRegOffSetToBeCheck = 0x3;\n\tu32\tRegValueToBeCheck = 0x7f1;\n\tu32\tRF3_Final_Value = 0;\n\tu8\tConstRetryTimes = 5, RetryTimes = 5;\n\tu8 ret = 0;\n\t \n\tfor (eRFPath = (enum rf90_radio_path_e)RF90_PATH_A; eRFPath < priv->NumTotalRFPath; eRFPath++) {\n\t\tif (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))\n\t\t\tcontinue;\n\n\t\tpPhyReg = &priv->PHYRegDef[eRFPath];\n\n\t\t \n\t\tswitch (eRFPath) {\n\t\tcase RF90_PATH_A:\n\t\tcase RF90_PATH_C:\n\t\t\tu4RegValue = rtl8192_QueryBBReg(dev, pPhyReg->rfintfs, bRFSI_RFENV);\n\t\t\tbreak;\n\t\tcase RF90_PATH_B:\n\t\tcase RF90_PATH_D:\n\t\t\tu4RegValue = rtl8192_QueryBBReg(dev, pPhyReg->rfintfs, bRFSI_RFENV << 16);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trtl8192_setBBreg(dev, pPhyReg->rfintfe, bRFSI_RFENV << 16, 0x1);\n\n\t\t \n\t\trtl8192_setBBreg(dev, pPhyReg->rfintfo, bRFSI_RFENV, 0x1);\n\n\t\t \n\t\trtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, b3WireAddressLength, 0x0);\t \n\t\trtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, b3WireDataLength, 0x0);\t \n\n\t\trtl8192_phy_SetRFReg(dev, (enum rf90_radio_path_e)eRFPath, 0x0, bMask12Bits, 0xbf);\n\n\t\t \n\t\tif (rtl8192_phy_checkBBAndRF(dev, HW90_BLOCK_RF, (enum rf90_radio_path_e)eRFPath)) {\n\t\t\tRT_TRACE(COMP_ERR, \"phy_rf8256_config():Check Radio[%d] Fail!!\\n\", eRFPath);\n\t\t\tgoto phy_RF8256_Config_ParaFile_Fail;\n\t\t}\n\n\t\tRetryTimes = ConstRetryTimes;\n\t\tRF3_Final_Value = 0;\n\t\t \n\t\tswitch (eRFPath) {\n\t\tcase RF90_PATH_A:\n\t\t\twhile (RF3_Final_Value != RegValueToBeCheck && RetryTimes != 0) {\n\t\t\t\tret = rtl8192_phy_ConfigRFWithHeaderFile(dev, (enum rf90_radio_path_e)eRFPath);\n\t\t\t\tRF3_Final_Value = rtl8192_phy_QueryRFReg(dev, (enum rf90_radio_path_e)eRFPath, RegOffSetToBeCheck, bMask12Bits);\n\t\t\t\tRT_TRACE(COMP_RF, \"RF %d %d register final value: %x\\n\", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);\n\t\t\t\tRetryTimes--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RF90_PATH_B:\n\t\t\twhile (RF3_Final_Value != RegValueToBeCheck && RetryTimes != 0) {\n\t\t\t\tret = rtl8192_phy_ConfigRFWithHeaderFile(dev, (enum rf90_radio_path_e)eRFPath);\n\t\t\t\tRF3_Final_Value = rtl8192_phy_QueryRFReg(dev, (enum rf90_radio_path_e)eRFPath, RegOffSetToBeCheck, bMask12Bits);\n\t\t\t\tRT_TRACE(COMP_RF, \"RF %d %d register final value: %x\\n\", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);\n\t\t\t\tRetryTimes--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RF90_PATH_C:\n\t\t\twhile (RF3_Final_Value != RegValueToBeCheck && RetryTimes != 0) {\n\t\t\t\tret = rtl8192_phy_ConfigRFWithHeaderFile(dev, (enum rf90_radio_path_e)eRFPath);\n\t\t\t\tRF3_Final_Value = rtl8192_phy_QueryRFReg(dev, (enum rf90_radio_path_e)eRFPath, RegOffSetToBeCheck, bMask12Bits);\n\t\t\t\tRT_TRACE(COMP_RF, \"RF %d %d register final value: %x\\n\", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);\n\t\t\t\tRetryTimes--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RF90_PATH_D:\n\t\t\twhile (RF3_Final_Value != RegValueToBeCheck && RetryTimes != 0) {\n\t\t\t\tret = rtl8192_phy_ConfigRFWithHeaderFile(dev, (enum rf90_radio_path_e)eRFPath);\n\t\t\t\tRF3_Final_Value = rtl8192_phy_QueryRFReg(dev, (enum rf90_radio_path_e)eRFPath, RegOffSetToBeCheck, bMask12Bits);\n\t\t\t\tRT_TRACE(COMP_RF, \"RF %d %d register final value: %x\\n\", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);\n\t\t\t\tRetryTimes--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tswitch (eRFPath) {\n\t\tcase RF90_PATH_A:\n\t\tcase RF90_PATH_C:\n\t\t\trtl8192_setBBreg(dev, pPhyReg->rfintfs, bRFSI_RFENV, u4RegValue);\n\t\t\tbreak;\n\t\tcase RF90_PATH_B:\n\t\tcase RF90_PATH_D:\n\t\t\trtl8192_setBBreg(dev, pPhyReg->rfintfs, bRFSI_RFENV << 16, u4RegValue);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tRT_TRACE(COMP_ERR, \"%s():Radio[%d] Fail!!\", __func__, eRFPath);\n\t\t\tgoto phy_RF8256_Config_ParaFile_Fail;\n\t\t}\n\t}\n\n\tRT_TRACE(COMP_PHY, \"PHY Initialization Success\\n\");\n\treturn;\n\nphy_RF8256_Config_ParaFile_Fail:\n\tRT_TRACE(COMP_ERR, \"PHY Initialization failed\\n\");\n}\n\nvoid phy_set_rf8256_cck_tx_power(struct net_device *dev, u8 powerlevel)\n{\n\tu32\tTxAGC = 0;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tTxAGC = powerlevel;\n\n\tif (priv->bDynamicTxLowPower) {\n\t\tif (priv->CustomerID == RT_CID_819x_Netcore)\n\t\t\tTxAGC = 0x22;\n\t\telse\n\t\t\tTxAGC += priv->CckPwEnl;\n\t}\n\n\tif (TxAGC > 0x24)\n\t\tTxAGC = 0x24;\n\trtl8192_setBBreg(dev, rTxAGC_CCK_Mcs32, bTxAGCRateCCK, TxAGC);\n}\n\nvoid phy_set_rf8256_ofdm_tx_power(struct net_device *dev, u8 powerlevel)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\t \n\tu32 writeVal, powerBase0, powerBase1, writeVal_tmp;\n\tu8 index = 0;\n\tu16 RegOffset[6] = {0xe00, 0xe04, 0xe10, 0xe14, 0xe18, 0xe1c};\n\tu8 byte0, byte1, byte2, byte3;\n\n\tpowerBase0 = powerlevel + priv->TxPowerDiff;\t \n\tpowerBase0 = (powerBase0 << 24) | (powerBase0 << 16) | (powerBase0 << 8) | powerBase0;\n\tpowerBase1 = powerlevel;\t\t\t\t\t\t\t \n\tpowerBase1 = (powerBase1 << 24) | (powerBase1 << 16) | (powerBase1 << 8) | powerBase1;\n\n\tfor (index = 0; index < 6; index++) {\n\t\twriteVal = priv->MCSTxPowerLevelOriginalOffset[index] + ((index < 2) ? powerBase0 : powerBase1);\n\t\tbyte0 = (u8)(writeVal & 0x7f);\n\t\tbyte1 = (u8)((writeVal & 0x7f00) >> 8);\n\t\tbyte2 = (u8)((writeVal & 0x7f0000) >> 16);\n\t\tbyte3 = (u8)((writeVal & 0x7f000000) >> 24);\n\n\t\tif (byte0 > 0x24)\n\t\t\t \n\t\t\tbyte0 = 0x24;\n\t\tif (byte1 > 0x24)\n\t\t\tbyte1 = 0x24;\n\t\tif (byte2 > 0x24)\n\t\t\tbyte2 = 0x24;\n\t\tif (byte3 > 0x24)\n\t\t\tbyte3 = 0x24;\n\n\t\t \n\t\tif (index == 3) {\n\t\t\twriteVal_tmp = (byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0;\n\t\t\tpriv->Pwr_Track = writeVal_tmp;\n\t\t}\n\n\t\tif (priv->bDynamicTxHighPower) {\n\t\t\t \n\t\t\twriteVal = 0x03030303;\n\t\t} else {\n\t\t\twriteVal = (byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0;\n\t\t}\n\t\trtl8192_setBBreg(dev, RegOffset[index], 0x7f7f7f7f, writeVal);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}