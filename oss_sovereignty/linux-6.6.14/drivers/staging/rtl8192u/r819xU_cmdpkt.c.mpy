{
  "module_name": "r819xU_cmdpkt.c",
  "hash_id": "d7d2459b8750fcb61d14ab34190b6c1452600bbb52d1b1def0b407d6cdb40f5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/r819xU_cmdpkt.c",
  "human_readable_source": "\n \n#include \"r8192U.h\"\n#include \"r819xU_cmdpkt.h\"\n\nrt_status SendTxCommandPacket(struct net_device *dev, void *pData, u32 DataLen)\n{\n\tstruct r8192_priv   *priv = ieee80211_priv(dev);\n\tstruct sk_buff\t    *skb;\n\tstruct cb_desc\t    *tcb_desc;\n\n\t \n\tskb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + DataLen + 4);\n\tif (!skb)\n\t\treturn RT_STATUS_FAILURE;\n\tmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\n\ttcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\ttcb_desc->queue_index = TXCMD_QUEUE;\n\ttcb_desc->bCmdOrInit = DESC_PACKET_TYPE_NORMAL;\n\ttcb_desc->bLastIniPkt = 0;\n\tskb_reserve(skb, USB_HWDESC_HEADER_LEN);\n\tskb_put_data(skb, pData, DataLen);\n\ttcb_desc->txbuf_size = (u16)DataLen;\n\n\tif (!priv->ieee80211->check_nic_enough_desc(dev, tcb_desc->queue_index) ||\n\t    (!skb_queue_empty(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index])) ||\n\t    (priv->ieee80211->queue_stop)) {\n\t\tRT_TRACE(COMP_FIRMWARE, \"=== NULL packet ======> tx full!\\n\");\n\t\tskb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);\n\t} else {\n\t\tpriv->ieee80211->softmac_hard_start_xmit(skb, dev);\n\t}\n\n\treturn RT_STATUS_SUCCESS;\n}\n\nstatic void cmpk_count_txstatistic(struct net_device *dev, struct cmd_pkt_tx_feedback *pstx_fb)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n#ifdef ENABLE_PS\n\tRT_RF_POWER_STATE\trtState;\n\n\tpAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE,\n\t\t\t\t\t  (pu1Byte)(&rtState));\n\n\t \n\tif (rtState == eRfOff)\n\t\treturn;\n#endif\n\n#ifdef TODO\n\tif (pAdapter->bInHctTest)\n\t\treturn;\n#endif\n\t \n\tif (pstx_fb->tok) {\n\t\tpriv->stats.txfeedbackok++;\n\t\tpriv->stats.txoktotal++;\n\t\tpriv->stats.txokbytestotal += pstx_fb->pkt_length;\n\t\tpriv->stats.txokinperiod++;\n\n\t\t \n\t\tif (pstx_fb->pkt_type == PACKET_MULTICAST) {\n\t\t\tpriv->stats.txmulticast++;\n\t\t\tpriv->stats.txbytesmulticast += pstx_fb->pkt_length;\n\t\t} else if (pstx_fb->pkt_type == PACKET_BROADCAST) {\n\t\t\tpriv->stats.txbroadcast++;\n\t\t\tpriv->stats.txbytesbroadcast += pstx_fb->pkt_length;\n\t\t} else {\n\t\t\tpriv->stats.txunicast++;\n\t\t\tpriv->stats.txbytesunicast += pstx_fb->pkt_length;\n\t\t}\n\t} else {\n\t\tpriv->stats.txfeedbackfail++;\n\t\tpriv->stats.txerrtotal++;\n\t\tpriv->stats.txerrbytestotal += pstx_fb->pkt_length;\n\n\t\t \n\t\tif (pstx_fb->pkt_type == PACKET_MULTICAST)\n\t\t\tpriv->stats.txerrmulticast++;\n\t\telse if (pstx_fb->pkt_type == PACKET_BROADCAST)\n\t\t\tpriv->stats.txerrbroadcast++;\n\t\telse\n\t\t\tpriv->stats.txerrunicast++;\n\t}\n\n\tpriv->stats.txretrycount += pstx_fb->retry_cnt;\n\tpriv->stats.txfeedbackretry += pstx_fb->retry_cnt;\n}\n\n \nstatic void cmpk_handle_tx_feedback(struct net_device *dev, u8 *pmsg)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct cmd_pkt_tx_feedback rx_tx_fb;\n\n\tpriv->stats.txfeedback++;\n\n\t \n\t \n\t \n\tmemcpy((u8 *)&rx_tx_fb, pmsg, sizeof(struct cmd_pkt_tx_feedback));\n\t \n\tcmpk_count_txstatistic(dev, &rx_tx_fb);\n\t \n\t \n\t \n}\n\nstatic void cmdpkt_beacontimerinterrupt_819xusb(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu16 tx_rate;\n\n\t \n\tif (priv->ieee80211->current_network.mode == IEEE_A ||\n\t    priv->ieee80211->current_network.mode == IEEE_N_5G ||\n\t    (priv->ieee80211->current_network.mode == IEEE_N_24G &&\n\t     (!priv->ieee80211->pHTInfo->bCurSuppCCK))) {\n\t\ttx_rate = 60;\n\t\tDMESG(\"send beacon frame  tx rate is 6Mbpm\\n\");\n\t} else {\n\t\ttx_rate = 10;\n\t\tDMESG(\"send beacon frame  tx rate is 1Mbpm\\n\");\n\t}\n\n\trtl819xusb_beacon_tx(dev, tx_rate);  \n}\n\n \nstatic void cmpk_handle_interrupt_status(struct net_device *dev, u8 *pmsg)\n{\n\tstruct cmd_pkt_interrupt_status\t rx_intr_status;\t \n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tDMESG(\"---> cmpk_Handle_Interrupt_Status()\\n\");\n\n\t \n\t \n\trx_intr_status.length = pmsg[1];\n\tif (rx_intr_status.length != (sizeof(struct cmd_pkt_interrupt_status) - 2)) {\n\t\tDMESG(\"cmpk_Handle_Interrupt_Status: wrong length!\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (priv->ieee80211->iw_mode == IW_MODE_ADHOC) {\n\t\t \n\t\trx_intr_status.interrupt_status = *((u32 *)(pmsg + 4));\n\n\t\tDMESG(\"interrupt status = 0x%x\\n\",\n\t\t      rx_intr_status.interrupt_status);\n\n\t\tif (rx_intr_status.interrupt_status & ISR_TX_BCN_OK) {\n\t\t\tpriv->ieee80211->bibsscoordinator = true;\n\t\t\tpriv->stats.txbeaconokint++;\n\t\t} else if (rx_intr_status.interrupt_status & ISR_TX_BCN_ERR) {\n\t\t\tpriv->ieee80211->bibsscoordinator = false;\n\t\t\tpriv->stats.txbeaconerr++;\n\t\t}\n\n\t\tif (rx_intr_status.interrupt_status & ISR_BCN_TIMER_INTR)\n\t\t\tcmdpkt_beacontimerinterrupt_819xusb(dev);\n\t}\n\n\t \n\n\tDMESG(\"<---- cmpk_handle_interrupt_status()\\n\");\n}\n\n \nstatic void cmpk_count_tx_status(struct net_device *dev,\n\t\t\t\t cmpk_tx_status_t *pstx_status)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n#ifdef ENABLE_PS\n\n\tRT_RF_POWER_STATE\trtstate;\n\n\tpAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE,\n\t\t\t\t\t  (pu1Byte)(&rtState));\n\n\t \n\tif (rtState == eRfOff)\n\t\treturn;\n#endif\n\n\tpriv->stats.txfeedbackok\t+= pstx_status->txok;\n\tpriv->stats.txoktotal\t\t+= pstx_status->txok;\n\n\tpriv->stats.txfeedbackfail\t+= pstx_status->txfail;\n\tpriv->stats.txerrtotal\t\t+= pstx_status->txfail;\n\n\tpriv->stats.txretrycount\t+= pstx_status->txretry;\n\tpriv->stats.txfeedbackretry\t+= pstx_status->txretry;\n\n\tpriv->stats.txmulticast\t\t+= pstx_status->txmcok;\n\tpriv->stats.txbroadcast\t\t+= pstx_status->txbcok;\n\tpriv->stats.txunicast\t\t+= pstx_status->txucok;\n\n\tpriv->stats.txerrmulticast\t+= pstx_status->txmcfail;\n\tpriv->stats.txerrbroadcast\t+= pstx_status->txbcfail;\n\tpriv->stats.txerrunicast\t+= pstx_status->txucfail;\n\n\tpriv->stats.txbytesmulticast\t+= pstx_status->txmclength;\n\tpriv->stats.txbytesbroadcast\t+= pstx_status->txbclength;\n\tpriv->stats.txbytesunicast\t+= pstx_status->txuclength;\n\n\tpriv->stats.last_packet_rate\t= pstx_status->rate;\n}\n\n \nstatic void cmpk_handle_tx_status(struct net_device *dev, u8 *pmsg)\n{\n\tcmpk_tx_status_t\trx_tx_sts;\n\n\tmemcpy((void *)&rx_tx_sts, (void *)pmsg, sizeof(cmpk_tx_status_t));\n\t \n\tcmpk_count_tx_status(dev, &rx_tx_sts);\n}\n\n \nstatic void cmpk_handle_tx_rate_history(struct net_device *dev, u8 *pmsg)\n{\n\tcmpk_tx_rahis_t\t*ptxrate;\n\tu8\t\ti, j;\n\tu16\t\tlength = sizeof(cmpk_tx_rahis_t);\n\tu32\t\t*ptemp;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n#ifdef ENABLE_PS\n\tpAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE,\n\t\t\t\t\t  (pu1Byte)(&rtState));\n\n\t \n\tif (rtState == eRfOff)\n\t\treturn;\n#endif\n\n\tptemp = (u32 *)pmsg;\n\n\t \n\tfor (i = 0; i < (length/4); i++) {\n\t\tu16\t temp1, temp2;\n\n\t\ttemp1 = ptemp[i] & 0x0000FFFF;\n\t\ttemp2 = ptemp[i] >> 16;\n\t\tptemp[i] = (temp1 << 16) | temp2;\n\t}\n\n\tptxrate = (cmpk_tx_rahis_t *)pmsg;\n\n\tif (!ptxrate)\n\t\treturn;\n\n\tfor (i = 0; i < 16; i++) {\n\t\t \n\t\tif (i < 4)\n\t\t\tpriv->stats.txrate.cck[i] += ptxrate->cck[i];\n\n\t\t \n\t\tif (i < 8)\n\t\t\tpriv->stats.txrate.ofdm[i] += ptxrate->ofdm[i];\n\n\t\tfor (j = 0; j < 4; j++)\n\t\t\tpriv->stats.txrate.ht_mcs[j][i] += ptxrate->ht_mcs[j][i];\n\t}\n}\n\n \nu32 cmpk_message_handle_rx(struct net_device *dev,\n\t\t\t   struct ieee80211_rx_stats *pstats)\n{\n\tint\t\t\ttotal_length;\n\tu8\t\t\tcmd_length, exe_cnt = 0;\n\tu8\t\t\telement_id;\n\tu8\t\t\t*pcmd_buff;\n\n\t \n\tif (!pstats)\n\t\treturn 0;\t \n\n\t \n\ttotal_length = pstats->Length;\n\n\t \n\tpcmd_buff = pstats->virtual_address;\n\n\t \n\telement_id = pcmd_buff[0];\n\n\t \n\t \n\twhile (total_length > 0 && exe_cnt++ < 100) {\n\t\t \n\t\telement_id = pcmd_buff[0];\n\n\t\tswitch (element_id) {\n\t\tcase RX_TX_FEEDBACK:\n\t\t\tcmpk_handle_tx_feedback(dev, pcmd_buff);\n\t\t\tcmd_length = CMPK_RX_TX_FB_SIZE;\n\t\t\tbreak;\n\n\t\tcase RX_INTERRUPT_STATUS:\n\t\t\tcmpk_handle_interrupt_status(dev, pcmd_buff);\n\t\t\tcmd_length = sizeof(struct cmd_pkt_interrupt_status);\n\t\t\tbreak;\n\n\t\tcase BOTH_QUERY_CONFIG:\n\t\t\tcmd_length = CMPK_BOTH_QUERY_CONFIG_SIZE;\n\t\t\tbreak;\n\n\t\tcase RX_TX_STATUS:\n\t\t\tcmpk_handle_tx_status(dev, pcmd_buff);\n\t\t\tcmd_length = CMPK_RX_TX_STS_SIZE;\n\t\t\tbreak;\n\n\t\tcase RX_TX_PER_PKT_FEEDBACK:\n\t\t\t \n\t\t\tcmd_length = CMPK_RX_TX_FB_SIZE;\n\t\t\tbreak;\n\n\t\tcase RX_TX_RATE_HISTORY:\n\t\t\tcmpk_handle_tx_rate_history(dev, pcmd_buff);\n\t\t\tcmd_length = CMPK_TX_RAHIS_SIZE;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tRT_TRACE(COMP_ERR, \"---->%s():unknown CMD Element\\n\",\n\t\t\t\t __func__);\n\t\t\treturn 1;\t \n\t\t}\n\n\t\ttotal_length -= cmd_length;\n\t\tpcmd_buff    += cmd_length;\n\t}\n\treturn\t1;\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}