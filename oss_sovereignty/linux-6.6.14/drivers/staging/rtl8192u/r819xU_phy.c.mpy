{
  "module_name": "r819xU_phy.c",
  "hash_id": "6b56485f300282abdcc048bb4e23c2b7c4a5b32f45b8e7b53463036b25145c6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/r819xU_phy.c",
  "human_readable_source": "\n#include \"r8192U.h\"\n#include \"r8192U_hw.h\"\n#include \"r819xU_phy.h\"\n#include \"r819xU_phyreg.h\"\n#include \"r8190_rtl8256.h\"\n#include \"r8192U_dm.h\"\n#include \"r819xU_firmware_img.h\"\n\n#include \"ieee80211/dot11d.h\"\n#include <linux/bitops.h>\n\nstatic u32 RF_CHANNEL_TABLE_ZEBRA[] = {\n\t0,\n\t0x085c,  \n\t0x08dc,  \n\t0x095c,  \n\t0x09dc,  \n\t0x0a5c,  \n\t0x0adc,  \n\t0x0b5c,  \n\t0x0bdc,  \n\t0x0c5c,  \n\t0x0cdc,  \n\t0x0d5c,  \n\t0x0ddc,  \n\t0x0e5c,  \n\t0x0f72,  \n};\n\n#define rtl819XMACPHY_Array Rtl8192UsbMACPHY_Array\n\n \nu8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 e_rfpath)\n{\n\tu8 ret = 1;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tif (priv->rf_type == RF_2T4R) {\n\t\tret = 0;\n\t} else if (priv->rf_type == RF_1T2R) {\n\t\tif (e_rfpath == RF90_PATH_A || e_rfpath == RF90_PATH_B)\n\t\t\tret = 1;\n\t\telse if (e_rfpath == RF90_PATH_C || e_rfpath == RF90_PATH_D)\n\t\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n \nvoid rtl8192_setBBreg(struct net_device *dev, u32 reg_addr, u32 bitmask,\n\t\t      u32 data)\n{\n\tu32 reg, bitshift;\n\n\tif (bitmask != bMaskDWord) {\n\t\tread_nic_dword(dev, reg_addr, &reg);\n\t\tbitshift = ffs(bitmask) - 1;\n\t\treg &= ~bitmask;\n\t\treg |= data << bitshift;\n\t\twrite_nic_dword(dev, reg_addr, reg);\n\t} else {\n\t\twrite_nic_dword(dev, reg_addr, data);\n\t}\n}\n\n \nu32 rtl8192_QueryBBReg(struct net_device *dev, u32 reg_addr, u32 bitmask)\n{\n\tu32 reg, bitshift;\n\n\tread_nic_dword(dev, reg_addr, &reg);\n\tbitshift = ffs(bitmask) - 1;\n\n\treturn (reg & bitmask) >> bitshift;\n}\n\nstatic u32 phy_FwRFSerialRead(struct net_device *dev,\n\t\t\t      enum rf90_radio_path_e e_rfpath,\n\t\t\t      u32 offset);\n\nstatic void phy_FwRFSerialWrite(struct net_device *dev,\n\t\t\t\tenum rf90_radio_path_e e_rfpath,\n\t\t\t\tu32  offset,\n\t\t\t\tu32  data);\n\n \nstatic u32 rtl8192_phy_RFSerialRead(struct net_device *dev,\n\t\t\t\t    enum rf90_radio_path_e e_rfpath, u32 offset)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu32 ret = 0;\n\tu32 new_offset = 0;\n\tBB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[e_rfpath];\n\n\trtl8192_setBBreg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData, 0);\n\t \n\toffset &= 0x3f;\n\n\t \n\tif (priv->rf_chip == RF_8256) {\n\t\tif (offset >= 31) {\n\t\t\tpriv->RfReg0Value[e_rfpath] |= 0x140;\n\t\t\t \n\t\t\trtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\n\t\t\t\t\t bMaskDWord,\n\t\t\t\t\t priv->RfReg0Value[e_rfpath]<<16);\n\t\t\t \n\t\t\tnew_offset = offset - 30;\n\t\t} else if (offset >= 16) {\n\t\t\tpriv->RfReg0Value[e_rfpath] |= 0x100;\n\t\t\tpriv->RfReg0Value[e_rfpath] &= (~0x40);\n\t\t\t \n\t\t\trtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\n\t\t\t\t\t bMaskDWord,\n\t\t\t\t\t priv->RfReg0Value[e_rfpath]<<16);\n\n\t\t\tnew_offset = offset - 15;\n\t\t} else {\n\t\t\tnew_offset = offset;\n\t\t}\n\t} else {\n\t\tRT_TRACE((COMP_PHY|COMP_ERR),\n\t\t\t \"check RF type here, need to be 8256\\n\");\n\t\tnew_offset = offset;\n\t}\n\t \n\trtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadAddress,\n\t\t\t new_offset);\n\t \n\trtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x0);\n\trtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x1);\n\n\t \n\tusleep_range(1000, 1000);\n\n\tret = rtl8192_QueryBBReg(dev, pPhyReg->rfLSSIReadBack,\n\t\t\t\t bLSSIReadBackData);\n\n\t \n\tif (priv->rf_chip == RF_8256) {\n\t\tpriv->RfReg0Value[e_rfpath] &= 0xebf;\n\n\t\trtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord,\n\t\t\t\t priv->RfReg0Value[e_rfpath] << 16);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void rtl8192_phy_RFSerialWrite(struct net_device *dev,\n\t\t\t\t      enum rf90_radio_path_e e_rfpath,\n\t\t\t\t      u32 offset,\n\t\t\t\t      u32 data)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu32 DataAndAddr = 0, new_offset = 0;\n\tBB_REGISTER_DEFINITION_T\t*pPhyReg = &priv->PHYRegDef[e_rfpath];\n\n\toffset &= 0x3f;\n\tif (priv->rf_chip == RF_8256) {\n\t\tif (offset >= 31) {\n\t\t\tpriv->RfReg0Value[e_rfpath] |= 0x140;\n\t\t\trtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\n\t\t\t\t\t bMaskDWord,\n\t\t\t\t\t priv->RfReg0Value[e_rfpath] << 16);\n\t\t\tnew_offset = offset - 30;\n\t\t} else if (offset >= 16) {\n\t\t\tpriv->RfReg0Value[e_rfpath] |= 0x100;\n\t\t\tpriv->RfReg0Value[e_rfpath] &= (~0x40);\n\t\t\trtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\n\t\t\t\t\t bMaskDWord,\n\t\t\t\t\t priv->RfReg0Value[e_rfpath]<<16);\n\t\t\tnew_offset = offset - 15;\n\t\t} else {\n\t\t\tnew_offset = offset;\n\t\t}\n\t} else {\n\t\tRT_TRACE((COMP_PHY|COMP_ERR),\n\t\t\t \"check RF type here, need to be 8256\\n\");\n\t\tnew_offset = offset;\n\t}\n\n\t \n\tDataAndAddr = (data<<16) | (new_offset&0x3f);\n\n\t \n\trtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);\n\n\tif (offset == 0x0)\n\t\tpriv->RfReg0Value[e_rfpath] = data;\n\n\t \n\tif (priv->rf_chip == RF_8256) {\n\t\tif (offset != 0) {\n\t\t\tpriv->RfReg0Value[e_rfpath] &= 0xebf;\n\t\t\trtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\n\t\t\t\t\t bMaskDWord,\n\t\t\t\t\t priv->RfReg0Value[e_rfpath] << 16);\n\t\t}\n\t}\n}\n\n \nvoid rtl8192_phy_SetRFReg(struct net_device *dev,\n\t\t\t  enum rf90_radio_path_e e_rfpath,\n\t\t\t  u32 reg_addr, u32 bitmask, u32 data)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu32 reg, bitshift;\n\n\tif (!rtl8192_phy_CheckIsLegalRFPath(dev, e_rfpath))\n\t\treturn;\n\n\tif (priv->Rf_Mode == RF_OP_By_FW) {\n\t\tif (bitmask != bMask12Bits) {\n\t\t\t \n\t\t\treg = phy_FwRFSerialRead(dev, e_rfpath, reg_addr);\n\t\t\tbitshift =  ffs(bitmask) - 1;\n\t\t\treg &= ~bitmask;\n\t\t\treg |= data << bitshift;\n\n\t\t\tphy_FwRFSerialWrite(dev, e_rfpath, reg_addr, reg);\n\t\t} else {\n\t\t\tphy_FwRFSerialWrite(dev, e_rfpath, reg_addr, data);\n\t\t}\n\n\t\tudelay(200);\n\n\t} else {\n\t\tif (bitmask != bMask12Bits) {\n\t\t\t \n\t\t\treg = rtl8192_phy_RFSerialRead(dev, e_rfpath, reg_addr);\n\t\t\tbitshift =  ffs(bitmask) - 1;\n\t\t\treg &= ~bitmask;\n\t\t\treg |= data << bitshift;\n\n\t\t\trtl8192_phy_RFSerialWrite(dev, e_rfpath, reg_addr, reg);\n\t\t} else {\n\t\t\trtl8192_phy_RFSerialWrite(dev, e_rfpath, reg_addr, data);\n\t\t}\n\t}\n}\n\n \nu32 rtl8192_phy_QueryRFReg(struct net_device *dev,\n\t\t\t   enum rf90_radio_path_e e_rfpath,\n\t\t\t   u32 reg_addr, u32 bitmask)\n{\n\tu32 reg, bitshift;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tif (!rtl8192_phy_CheckIsLegalRFPath(dev, e_rfpath))\n\t\treturn 0;\n\tif (priv->Rf_Mode == RF_OP_By_FW) {\n\t\treg = phy_FwRFSerialRead(dev, e_rfpath, reg_addr);\n\t\tudelay(200);\n\t} else {\n\t\treg = rtl8192_phy_RFSerialRead(dev, e_rfpath, reg_addr);\n\t}\n\tbitshift =  ffs(bitmask) - 1;\n\treg = (reg & bitmask) >> bitshift;\n\treturn reg;\n}\n\n \nstatic u32 phy_FwRFSerialRead(struct net_device *dev,\n\t\t\t      enum rf90_radio_path_e e_rfpath,\n\t\t\t      u32 offset)\n{\n\tu32\t\treg = 0;\n\tu32\t\tdata = 0;\n\tu8\t\ttime = 0;\n\tu32\t\ttmp;\n\n\t \n\t \n\t \n\tdata |= ((offset&0xFF)<<12);\n\t \n\tdata |= ((e_rfpath&0x3)<<20);\n\t \n\t \n\tdata |= 0x80000000;\n\t \n\tread_nic_dword(dev, QPNR, &tmp);\n\twhile (tmp & 0x80000000) {\n\t\t \n\t\tif (time++ < 100) {\n\t\t\tudelay(10);\n\t\t\tread_nic_dword(dev, QPNR, &tmp);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\twrite_nic_dword(dev, QPNR, data);\n\t \n\tread_nic_dword(dev, QPNR, &tmp);\n\twhile (tmp & 0x80000000) {\n\t\t \n\t\tif (time++ < 100) {\n\t\t\tudelay(10);\n\t\t\tread_nic_dword(dev, QPNR, &tmp);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_nic_dword(dev, RF_DATA, &reg);\n\n\treturn reg;\n}\n\n \nstatic void phy_FwRFSerialWrite(struct net_device *dev,\n\t\t\t\tenum rf90_radio_path_e e_rfpath,\n\t\t\t\tu32 offset, u32 data)\n{\n\tu8\ttime = 0;\n\tu32\ttmp;\n\n\t \n\n\t \n\t \n\tdata |= ((offset&0xFF)<<12);\n\t \n\tdata |= ((e_rfpath&0x3)<<20);\n\t \n\tdata |= 0x400000;\n\t \n\tdata |= 0x80000000;\n\n\t \n\tread_nic_dword(dev, QPNR, &tmp);\n\twhile (tmp & 0x80000000) {\n\t\t \n\t\tif (time++ < 100) {\n\t\t\tudelay(10);\n\t\t\tread_nic_dword(dev, QPNR, &tmp);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\twrite_nic_dword(dev, QPNR, data);\n\t \n\t \n}\n\n \nvoid rtl8192_phy_configmac(struct net_device *dev)\n{\n\tu32 dwArrayLen = 0, i;\n\tu32 *pdwArray = NULL;\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tif (priv->btxpowerdata_readfromEEPORM) {\n\t\tRT_TRACE(COMP_PHY, \"Rtl819XMACPHY_Array_PG\\n\");\n\t\tdwArrayLen = MACPHY_Array_PGLength;\n\t\tpdwArray = Rtl8192UsbMACPHY_Array_PG;\n\n\t} else {\n\t\tRT_TRACE(COMP_PHY, \"Rtl819XMACPHY_Array\\n\");\n\t\tdwArrayLen = MACPHY_ArrayLength;\n\t\tpdwArray = rtl819XMACPHY_Array;\n\t}\n\tfor (i = 0; i < dwArrayLen; i = i+3) {\n\t\tif (pdwArray[i] == 0x318)\n\t\t\tpdwArray[i+2] = 0x00000800;\n\n\t\tRT_TRACE(COMP_DBG,\n\t\t\t \"Rtl8190MACPHY_Array[0]=%x Rtl8190MACPHY_Array[1]=%x Rtl8190MACPHY_Array[2]=%x\\n\",\n\t\t\t pdwArray[i], pdwArray[i+1], pdwArray[i+2]);\n\t\trtl8192_setBBreg(dev, pdwArray[i], pdwArray[i+1],\n\t\t\t\t pdwArray[i+2]);\n\t}\n}\n\n \nstatic void rtl8192_phyConfigBB(struct net_device *dev,\n\t\t\t\tenum baseband_config_type ConfigType)\n{\n\tu32 i;\n\n\tif (ConfigType == BASEBAND_CONFIG_PHY_REG) {\n\t\tfor (i = 0; i < PHY_REG_1T2RArrayLength; i += 2) {\n\t\t\trtl8192_setBBreg(dev, Rtl8192UsbPHY_REG_1T2RArray[i],\n\t\t\t\t\t bMaskDWord,\n\t\t\t\t\t Rtl8192UsbPHY_REG_1T2RArray[i+1]);\n\t\t\tRT_TRACE(COMP_DBG,\n\t\t\t\t \"i: %x, Rtl819xUsbPHY_REGArray[0]=%x Rtl819xUsbPHY_REGArray[1]=%x\\n\",\n\t\t\t\t i, Rtl8192UsbPHY_REG_1T2RArray[i],\n\t\t\t\t Rtl8192UsbPHY_REG_1T2RArray[i+1]);\n\t\t}\n\t} else if (ConfigType == BASEBAND_CONFIG_AGC_TAB) {\n\t\tfor (i = 0; i < AGCTAB_ArrayLength; i += 2) {\n\t\t\trtl8192_setBBreg(dev, Rtl8192UsbAGCTAB_Array[i],\n\t\t\t\t\t bMaskDWord, Rtl8192UsbAGCTAB_Array[i+1]);\n\t\t\tRT_TRACE(COMP_DBG,\n\t\t\t\t \"i: %x, Rtl8192UsbAGCTAB_Array[0]=%x Rtl8192UsbAGCTAB_Array[1]=%x\\n\",\n\t\t\t\t i, Rtl8192UsbAGCTAB_Array[i],\n\t\t\t\t Rtl8192UsbAGCTAB_Array[i+1]);\n\t\t}\n\t}\n}\n\n \nstatic void rtl8192_InitBBRFRegDef(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\t \n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW;\n\t \n\tpriv->PHYRegDef[RF90_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW;\n\t \n\tpriv->PHYRegDef[RF90_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;\n\t \n\tpriv->PHYRegDef[RF90_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;\n\n\t \n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB;\n\t \n\tpriv->PHYRegDef[RF90_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;\n\t \n\tpriv->PHYRegDef[RF90_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;\n\t \n\tpriv->PHYRegDef[RF90_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;\n\n\t \n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE;\n\t \n\tpriv->PHYRegDef[RF90_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE;\n\t \n\tpriv->PHYRegDef[RF90_PATH_C].rfintfo = rFPGA0_XC_RFInterfaceOE;\n\t \n\tpriv->PHYRegDef[RF90_PATH_D].rfintfo = rFPGA0_XD_RFInterfaceOE;\n\n\t \n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE;\n\t \n\tpriv->PHYRegDef[RF90_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE;\n\t \n\tpriv->PHYRegDef[RF90_PATH_C].rfintfe = rFPGA0_XC_RFInterfaceOE;\n\t \n\tpriv->PHYRegDef[RF90_PATH_D].rfintfe = rFPGA0_XD_RFInterfaceOE;\n\n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter;\n\tpriv->PHYRegDef[RF90_PATH_B].rf3wireOffset = rFPGA0_XB_LSSIParameter;\n\tpriv->PHYRegDef[RF90_PATH_C].rf3wireOffset = rFPGA0_XC_LSSIParameter;\n\tpriv->PHYRegDef[RF90_PATH_D].rf3wireOffset = rFPGA0_XD_LSSIParameter;\n\n\t \n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfLSSI_Select = rFPGA0_XAB_RFParameter;\n\tpriv->PHYRegDef[RF90_PATH_B].rfLSSI_Select = rFPGA0_XAB_RFParameter;\n\tpriv->PHYRegDef[RF90_PATH_C].rfLSSI_Select = rFPGA0_XCD_RFParameter;\n\tpriv->PHYRegDef[RF90_PATH_D].rfLSSI_Select = rFPGA0_XCD_RFParameter;\n\n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfTxGainStage = rFPGA0_TxGainStage;\n\tpriv->PHYRegDef[RF90_PATH_B].rfTxGainStage = rFPGA0_TxGainStage;\n\tpriv->PHYRegDef[RF90_PATH_C].rfTxGainStage = rFPGA0_TxGainStage;\n\tpriv->PHYRegDef[RF90_PATH_D].rfTxGainStage = rFPGA0_TxGainStage;\n\n\t \n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;\n\tpriv->PHYRegDef[RF90_PATH_B].rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;\n\tpriv->PHYRegDef[RF90_PATH_C].rfHSSIPara1 = rFPGA0_XC_HSSIParameter1;\n\tpriv->PHYRegDef[RF90_PATH_D].rfHSSIPara1 = rFPGA0_XD_HSSIParameter1;\n\n\t \n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;\n\tpriv->PHYRegDef[RF90_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;\n\tpriv->PHYRegDef[RF90_PATH_C].rfHSSIPara2 = rFPGA0_XC_HSSIParameter2;\n\tpriv->PHYRegDef[RF90_PATH_D].rfHSSIPara2 = rFPGA0_XD_HSSIParameter2;\n\n\t \n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfSwitchControl = rFPGA0_XAB_SwitchControl;\n\tpriv->PHYRegDef[RF90_PATH_B].rfSwitchControl = rFPGA0_XAB_SwitchControl;\n\tpriv->PHYRegDef[RF90_PATH_C].rfSwitchControl = rFPGA0_XCD_SwitchControl;\n\tpriv->PHYRegDef[RF90_PATH_D].rfSwitchControl = rFPGA0_XCD_SwitchControl;\n\n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfAGCControl1 = rOFDM0_XAAGCCore1;\n\tpriv->PHYRegDef[RF90_PATH_B].rfAGCControl1 = rOFDM0_XBAGCCore1;\n\tpriv->PHYRegDef[RF90_PATH_C].rfAGCControl1 = rOFDM0_XCAGCCore1;\n\tpriv->PHYRegDef[RF90_PATH_D].rfAGCControl1 = rOFDM0_XDAGCCore1;\n\n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfAGCControl2 = rOFDM0_XAAGCCore2;\n\tpriv->PHYRegDef[RF90_PATH_B].rfAGCControl2 = rOFDM0_XBAGCCore2;\n\tpriv->PHYRegDef[RF90_PATH_C].rfAGCControl2 = rOFDM0_XCAGCCore2;\n\tpriv->PHYRegDef[RF90_PATH_D].rfAGCControl2 = rOFDM0_XDAGCCore2;\n\n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfRxIQImbalance = rOFDM0_XARxIQImbalance;\n\tpriv->PHYRegDef[RF90_PATH_B].rfRxIQImbalance = rOFDM0_XBRxIQImbalance;\n\tpriv->PHYRegDef[RF90_PATH_C].rfRxIQImbalance = rOFDM0_XCRxIQImbalance;\n\tpriv->PHYRegDef[RF90_PATH_D].rfRxIQImbalance = rOFDM0_XDRxIQImbalance;\n\n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfRxAFE = rOFDM0_XARxAFE;\n\tpriv->PHYRegDef[RF90_PATH_B].rfRxAFE = rOFDM0_XBRxAFE;\n\tpriv->PHYRegDef[RF90_PATH_C].rfRxAFE = rOFDM0_XCRxAFE;\n\tpriv->PHYRegDef[RF90_PATH_D].rfRxAFE = rOFDM0_XDRxAFE;\n\n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfTxIQImbalance = rOFDM0_XATxIQImbalance;\n\tpriv->PHYRegDef[RF90_PATH_B].rfTxIQImbalance = rOFDM0_XBTxIQImbalance;\n\tpriv->PHYRegDef[RF90_PATH_C].rfTxIQImbalance = rOFDM0_XCTxIQImbalance;\n\tpriv->PHYRegDef[RF90_PATH_D].rfTxIQImbalance = rOFDM0_XDTxIQImbalance;\n\n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfTxAFE = rOFDM0_XATxAFE;\n\tpriv->PHYRegDef[RF90_PATH_B].rfTxAFE = rOFDM0_XBTxAFE;\n\tpriv->PHYRegDef[RF90_PATH_C].rfTxAFE = rOFDM0_XCTxAFE;\n\tpriv->PHYRegDef[RF90_PATH_D].rfTxAFE = rOFDM0_XDTxAFE;\n\n\t \n\tpriv->PHYRegDef[RF90_PATH_A].rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;\n\tpriv->PHYRegDef[RF90_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;\n\tpriv->PHYRegDef[RF90_PATH_C].rfLSSIReadBack = rFPGA0_XC_LSSIReadBack;\n\tpriv->PHYRegDef[RF90_PATH_D].rfLSSIReadBack = rFPGA0_XD_LSSIReadBack;\n}\n\n \nu8 rtl8192_phy_checkBBAndRF(struct net_device *dev, enum hw90_block_e CheckBlock,\n\t\t\t    enum rf90_radio_path_e e_rfpath)\n{\n\tu8 ret = 0;\n\tu32 i, CheckTimes = 4, reg = 0;\n\tu32 WriteAddr[4];\n\tu32 WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};\n\n\t \n\tWriteAddr[HW90_BLOCK_MAC] = 0x100;\n\tWriteAddr[HW90_BLOCK_PHY0] = 0x900;\n\tWriteAddr[HW90_BLOCK_PHY1] = 0x800;\n\tWriteAddr[HW90_BLOCK_RF] = 0x3;\n\tRT_TRACE(COMP_PHY, \"%s(), CheckBlock: %d\\n\", __func__, CheckBlock);\n\tfor (i = 0; i < CheckTimes; i++) {\n\t\t \n\t\tswitch (CheckBlock) {\n\t\tcase HW90_BLOCK_MAC:\n\t\t\tRT_TRACE(COMP_ERR,\n\t\t\t\t \"PHY_CheckBBRFOK(): Never Write 0x100 here!\\n\");\n\t\t\tbreak;\n\n\t\tcase HW90_BLOCK_PHY0:\n\t\tcase HW90_BLOCK_PHY1:\n\t\t\twrite_nic_dword(dev, WriteAddr[CheckBlock],\n\t\t\t\t\tWriteData[i]);\n\t\t\tread_nic_dword(dev, WriteAddr[CheckBlock], &reg);\n\t\t\tbreak;\n\n\t\tcase HW90_BLOCK_RF:\n\t\t\tWriteData[i] &= 0xfff;\n\t\t\trtl8192_phy_SetRFReg(dev, e_rfpath,\n\t\t\t\t\t     WriteAddr[HW90_BLOCK_RF],\n\t\t\t\t\t     bMask12Bits, WriteData[i]);\n\t\t\t \n\t\t\tusleep_range(1000, 1000);\n\t\t\treg = rtl8192_phy_QueryRFReg(dev, e_rfpath,\n\t\t\t\t\t\t     WriteAddr[HW90_BLOCK_RF],\n\t\t\t\t\t\t     bMask12Bits);\n\t\t\tusleep_range(1000, 1000);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (reg != WriteData[i]) {\n\t\t\tRT_TRACE((COMP_PHY|COMP_ERR),\n\t\t\t\t \"error reg: %x, WriteData: %x\\n\",\n\t\t\t\t reg, WriteData[i]);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic void rtl8192_BB_Config_ParaFile(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu8 reg_u8 = 0, eCheckItem = 0, status = 0;\n\tu32 reg_u32 = 0;\n\n\t \n\n\t \n\tread_nic_byte(dev, BB_GLOBAL_RESET, &reg_u8);\n\twrite_nic_byte(dev, BB_GLOBAL_RESET, (reg_u8|BB_GLOBAL_RESET_BIT));\n\tmdelay(50);\n\t \n\tread_nic_dword(dev, CPU_GEN, &reg_u32);\n\twrite_nic_dword(dev, CPU_GEN, (reg_u32&(~CPU_GEN_BB_RST)));\n\n\t \n\t \n\tfor (eCheckItem = (enum hw90_block_e)HW90_BLOCK_PHY0;\n\t     eCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {\n\t\t \n\t\tstatus = rtl8192_phy_checkBBAndRF(dev, (enum hw90_block_e)eCheckItem,\n\t\t\t\t\t\t  (enum rf90_radio_path_e)0);\n\t\tif (status != 0) {\n\t\t\tRT_TRACE((COMP_ERR | COMP_PHY),\n\t\t\t\t \"phy_rf8256_config(): Check PHY%d Fail!!\\n\",\n\t\t\t\t eCheckItem-1);\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\trtl8192_setBBreg(dev, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x0);\n\t \n\t \n\trtl8192_phyConfigBB(dev, BASEBAND_CONFIG_PHY_REG);\n\n\t \n\tread_nic_dword(dev, CPU_GEN, &reg_u32);\n\twrite_nic_dword(dev, CPU_GEN, (reg_u32|CPU_GEN_BB_RST));\n\n\t \n\t \n\trtl8192_phyConfigBB(dev, BASEBAND_CONFIG_AGC_TAB);\n\n\t \n\twrite_nic_byte_E(dev, 0x5e, 0x00);\n\tif (priv->card_8192_version == VERSION_819XU_A) {\n\t\t \n\t\treg_u32 = priv->AntennaTxPwDiff[1]<<4 |\n\t\t\t   priv->AntennaTxPwDiff[0];\n\t\trtl8192_setBBreg(dev, rFPGA0_TxGainStage, (bXBTxAGC|bXCTxAGC),\n\t\t\t\t reg_u32);\n\n\t\t \n\t\treg_u32 = priv->CrystalCap & 0xf;\n\t\trtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, bXtalCap,\n\t\t\t\t reg_u32);\n\t}\n\n\t \n\tpriv->bCckHighPower = (u8)rtl8192_QueryBBReg(dev,\n\t\t\t\t\t\t     rFPGA0_XA_HSSIParameter2,\n\t\t\t\t\t\t     0x200);\n}\n\n \nvoid rtl8192_BBConfig(struct net_device *dev)\n{\n\trtl8192_InitBBRFRegDef(dev);\n\t \n\trtl8192_BB_Config_ParaFile(dev);\n}\n\n \nvoid rtl8192_phy_getTxPower(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu8 tmp;\n\n\tread_nic_dword(dev, rTxAGC_Rate18_06,\n\t\t       &priv->MCSTxPowerLevelOriginalOffset[0]);\n\tread_nic_dword(dev, rTxAGC_Rate54_24,\n\t\t       &priv->MCSTxPowerLevelOriginalOffset[1]);\n\tread_nic_dword(dev, rTxAGC_Mcs03_Mcs00,\n\t\t       &priv->MCSTxPowerLevelOriginalOffset[2]);\n\tread_nic_dword(dev, rTxAGC_Mcs07_Mcs04,\n\t\t       &priv->MCSTxPowerLevelOriginalOffset[3]);\n\tread_nic_dword(dev, rTxAGC_Mcs11_Mcs08,\n\t\t       &priv->MCSTxPowerLevelOriginalOffset[4]);\n\tread_nic_dword(dev, rTxAGC_Mcs15_Mcs12,\n\t\t       &priv->MCSTxPowerLevelOriginalOffset[5]);\n\n\t \n\tread_nic_byte(dev, rOFDM0_XAAGCCore1, &priv->DefaultInitialGain[0]);\n\tread_nic_byte(dev, rOFDM0_XBAGCCore1, &priv->DefaultInitialGain[1]);\n\tread_nic_byte(dev, rOFDM0_XCAGCCore1, &priv->DefaultInitialGain[2]);\n\tread_nic_byte(dev, rOFDM0_XDAGCCore1, &priv->DefaultInitialGain[3]);\n\tRT_TRACE(COMP_INIT,\n\t\t \"Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x)\\n\",\n\t\t priv->DefaultInitialGain[0], priv->DefaultInitialGain[1],\n\t\t priv->DefaultInitialGain[2], priv->DefaultInitialGain[3]);\n\n\t \n\tread_nic_byte(dev, rOFDM0_RxDetector3, &priv->framesync);\n\tread_nic_byte(dev, rOFDM0_RxDetector2, &tmp);\n\tpriv->framesyncC34 = tmp;\n\tRT_TRACE(COMP_INIT, \"Default framesync (0x%x) = 0x%x\\n\",\n\t\trOFDM0_RxDetector3, priv->framesync);\n\n\t \n\tread_nic_word(dev, SIFS, &priv->SifsTime);\n}\n\n \nvoid rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu8\tpowerlevel = priv->TxPowerLevelCCK[channel-1];\n\tu8\tpowerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];\n\n\tswitch (priv->rf_chip) {\n\tcase RF_8256:\n\t\t \n\t\tphy_set_rf8256_cck_tx_power(dev, powerlevel);\n\t\tphy_set_rf8256_ofdm_tx_power(dev, powerlevelOFDM24G);\n\t\tbreak;\n\tdefault:\n\t\tRT_TRACE((COMP_PHY|COMP_ERR),\n\t\t\t \"error RF chipID(8225 or 8258) in function %s()\\n\",\n\t\t\t __func__);\n\t\tbreak;\n\t}\n}\n\n \nvoid rtl8192_phy_RFConfig(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tswitch (priv->rf_chip) {\n\tcase RF_8256:\n\t\tphy_rf8256_config(dev);\n\t\tbreak;\n\tdefault:\n\t\tRT_TRACE(COMP_ERR, \"error chip id\\n\");\n\t\tbreak;\n\t}\n}\n\n \nvoid rtl8192_phy_updateInitGain(struct net_device *dev)\n{\n}\n\n \nu8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,\n\t\t\t\t      enum rf90_radio_path_e\te_rfpath)\n{\n\tint i;\n\n\tswitch (e_rfpath) {\n\tcase RF90_PATH_A:\n\t\tfor (i = 0; i < RadioA_ArrayLength; i = i+2) {\n\t\t\tif (Rtl8192UsbRadioA_Array[i] == 0xfe) {\n\t\t\t\tmdelay(100);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trtl8192_phy_SetRFReg(dev, e_rfpath,\n\t\t\t\t\t     Rtl8192UsbRadioA_Array[i],\n\t\t\t\t\t     bMask12Bits,\n\t\t\t\t\t     Rtl8192UsbRadioA_Array[i+1]);\n\t\t\tmdelay(1);\n\t\t}\n\t\tbreak;\n\tcase RF90_PATH_B:\n\t\tfor (i = 0; i < RadioB_ArrayLength; i = i+2) {\n\t\t\tif (Rtl8192UsbRadioB_Array[i] == 0xfe) {\n\t\t\t\tmdelay(100);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trtl8192_phy_SetRFReg(dev, e_rfpath,\n\t\t\t\t\t     Rtl8192UsbRadioB_Array[i],\n\t\t\t\t\t     bMask12Bits,\n\t\t\t\t\t     Rtl8192UsbRadioB_Array[i+1]);\n\t\t\tmdelay(1);\n\t\t}\n\t\tbreak;\n\tcase RF90_PATH_C:\n\t\tfor (i = 0; i < RadioC_ArrayLength; i = i+2) {\n\t\t\tif (Rtl8192UsbRadioC_Array[i] == 0xfe) {\n\t\t\t\tmdelay(100);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trtl8192_phy_SetRFReg(dev, e_rfpath,\n\t\t\t\t\t     Rtl8192UsbRadioC_Array[i],\n\t\t\t\t\t     bMask12Bits,\n\t\t\t\t\t     Rtl8192UsbRadioC_Array[i+1]);\n\t\t\tmdelay(1);\n\t\t}\n\t\tbreak;\n\tcase RF90_PATH_D:\n\t\tfor (i = 0; i < RadioD_ArrayLength; i = i+2) {\n\t\t\tif (Rtl8192UsbRadioD_Array[i] == 0xfe) {\n\t\t\t\tmdelay(100);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trtl8192_phy_SetRFReg(dev, e_rfpath,\n\t\t\t\t\t     Rtl8192UsbRadioD_Array[i],\n\t\t\t\t\t     bMask12Bits,\n\t\t\t\t\t     Rtl8192UsbRadioD_Array[i+1]);\n\t\t\tmdelay(1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu8\tpowerlevel = priv->TxPowerLevelCCK[channel-1];\n\tu8\tpowerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];\n\n\tswitch (priv->rf_chip) {\n\tcase RF_8225:\n\t\tbreak;\n\n\tcase RF_8256:\n\t\tphy_set_rf8256_cck_tx_power(dev, powerlevel);\n\t\tphy_set_rf8256_ofdm_tx_power(dev, powerlevelOFDM24G);\n\t\tbreak;\n\n\tcase RF_8258:\n\t\tbreak;\n\tdefault:\n\t\tRT_TRACE(COMP_ERR, \"unknown rf chip ID in %s()\\n\", __func__);\n\t\tbreak;\n\t}\n}\n\n \nstatic u8 rtl8192_phy_SetSwChnlCmdArray(struct sw_chnl_cmd *CmdTable, u32 CmdTableIdx,\n\t\t\t\t\tu32 CmdTableSz, enum switch_chan_cmd_id CmdID,\n\t\t\t\t\tu32 Para1, u32 Para2, u32 msDelay)\n{\n\tstruct sw_chnl_cmd *pCmd;\n\n\tif (!CmdTable) {\n\t\tRT_TRACE(COMP_ERR, \"%s(): CmdTable cannot be NULL\\n\", __func__);\n\t\treturn false;\n\t}\n\tif (CmdTableIdx >= CmdTableSz) {\n\t\tRT_TRACE(COMP_ERR, \"%s(): Access invalid index, please check size of the table, CmdTableIdx:%d, CmdTableSz:%d\\n\",\n\t\t\t __func__, CmdTableIdx, CmdTableSz);\n\t\treturn false;\n\t}\n\n\tpCmd = CmdTable + CmdTableIdx;\n\tpCmd->cmd_id = CmdID;\n\tpCmd->para_1 = Para1;\n\tpCmd->para_2 = Para2;\n\tpCmd->ms_delay = msDelay;\n\n\treturn true;\n}\n\n \nstatic u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,\n\t\t\t\t       u8 *stage, u8 *step, u32 *delay)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tstruct sw_chnl_cmd *pre_cmd;\n\tu32 pre_cmd_cnt = 0;\n\tstruct sw_chnl_cmd *post_cmd;\n\tu32 post_cmd_cnt = 0;\n\tstruct sw_chnl_cmd *rf_cmd;\n\tu32 rf_cmd_cnt = 0;\n\tstruct sw_chnl_cmd *current_cmd = NULL;\n\tu8 e_rfpath;\n\tbool ret;\n\n\tpre_cmd = kcalloc(MAX_PRECMD_CNT, sizeof(*pre_cmd), GFP_KERNEL);\n\tif (!pre_cmd)\n\t\treturn false;\n\n\tpost_cmd = kcalloc(MAX_POSTCMD_CNT, sizeof(*post_cmd), GFP_KERNEL);\n\tif (!post_cmd) {\n\t\tkfree(pre_cmd);\n\t\treturn false;\n\t}\n\n\trf_cmd = kcalloc(MAX_RFDEPENDCMD_CNT, sizeof(*rf_cmd), GFP_KERNEL);\n\tif (!rf_cmd) {\n\t\tkfree(pre_cmd);\n\t\tkfree(post_cmd);\n\t\treturn false;\n\t}\n\n\tRT_TRACE(COMP_CH, \"%s() stage: %d, step: %d, channel: %d\\n\",\n\t\t __func__, *stage, *step, channel);\n\tif (!is_legal_channel(priv->ieee80211, channel)) {\n\t\tRT_TRACE(COMP_ERR, \"set to illegal channel: %d\\n\", channel);\n\t\t \n\t\tret = true;\n\t\tgoto out;\n\t}\n\t \n\n\t \n\trtl8192_phy_SetSwChnlCmdArray(pre_cmd, pre_cmd_cnt++,\n\t\t\t\t      MAX_PRECMD_CNT, CMD_ID_SET_TX_PWR_LEVEL,\n\t\t\t\t      0, 0, 0);\n\trtl8192_phy_SetSwChnlCmdArray(pre_cmd, pre_cmd_cnt++,\n\t\t\t\t      MAX_PRECMD_CNT, CMD_ID_END, 0, 0, 0);\n\n\t \n\trtl8192_phy_SetSwChnlCmdArray(post_cmd, post_cmd_cnt++,\n\t\t\t\t      MAX_POSTCMD_CNT, CMD_ID_END, 0, 0, 0);\n\n\t \n\tswitch (priv->rf_chip) {\n\tcase RF_8225:\n\t\tif (!(channel >= 1 && channel <= 14)) {\n\t\t\tRT_TRACE(COMP_ERR,\n\t\t\t\t \"illegal channel for Zebra 8225: %d\\n\",\n\t\t\t\t channel);\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t\trtl8192_phy_SetSwChnlCmdArray(rf_cmd, rf_cmd_cnt++,\n\t\t\t\t\t      MAX_RFDEPENDCMD_CNT,\n\t\t\t\t\t      CMD_ID_RF_WRITE_REG,\n\t\t\t\t\t      rZebra1_Channel,\n\t\t\t\t\t      RF_CHANNEL_TABLE_ZEBRA[channel],\n\t\t\t\t\t      10);\n\t\trtl8192_phy_SetSwChnlCmdArray(rf_cmd, rf_cmd_cnt++,\n\t\t\t\t\t      MAX_RFDEPENDCMD_CNT,\n\t\t\t\t\t      CMD_ID_END, 0, 0, 0);\n\t\tbreak;\n\n\tcase RF_8256:\n\t\t \n\t\tif (!(channel >= 1 && channel <= 14)) {\n\t\t\tRT_TRACE(COMP_ERR,\n\t\t\t\t \"illegal channel for Zebra 8256: %d\\n\",\n\t\t\t\t channel);\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t\trtl8192_phy_SetSwChnlCmdArray(rf_cmd, rf_cmd_cnt++,\n\t\t\t\t\t      MAX_RFDEPENDCMD_CNT,\n\t\t\t\t\t      CMD_ID_RF_WRITE_REG,\n\t\t\t\t\t      rZebra1_Channel, channel, 10);\n\t\trtl8192_phy_SetSwChnlCmdArray(rf_cmd, rf_cmd_cnt++,\n\t\t\t\t\t      MAX_RFDEPENDCMD_CNT,\n\t\t\t\t\t      CMD_ID_END, 0, 0, 0);\n\t\tbreak;\n\n\tcase RF_8258:\n\t\tbreak;\n\n\tdefault:\n\t\tRT_TRACE(COMP_ERR, \"Unknown RFChipID: %d\\n\", priv->rf_chip);\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tswitch (*stage) {\n\t\tcase 0:\n\t\t\tcurrent_cmd = &pre_cmd[*step];\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcurrent_cmd = &rf_cmd[*step];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcurrent_cmd = &post_cmd[*step];\n\t\t\tbreak;\n\t\t}\n\n\t\tif (current_cmd->cmd_id == CMD_ID_END) {\n\t\t\tif ((*stage) == 2) {\n\t\t\t\t*delay = current_cmd->ms_delay;\n\t\t\t\tret = true;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t(*stage)++;\n\t\t\t(*step) = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (current_cmd->cmd_id) {\n\t\tcase CMD_ID_SET_TX_PWR_LEVEL:\n\t\t\tif (priv->card_8192_version == VERSION_819XU_A)\n\t\t\t\t \n\t\t\t\trtl8192_SetTxPowerLevel(dev, channel);\n\t\t\tbreak;\n\t\tcase CMD_ID_WRITE_PORT_ULONG:\n\t\t\twrite_nic_dword(dev, current_cmd->para_1,\n\t\t\t\t\tcurrent_cmd->para_2);\n\t\t\tbreak;\n\t\tcase CMD_ID_WRITE_PORT_USHORT:\n\t\t\twrite_nic_word(dev, current_cmd->para_1,\n\t\t\t\t       (u16)current_cmd->para_2);\n\t\t\tbreak;\n\t\tcase CMD_ID_WRITE_PORT_UCHAR:\n\t\t\twrite_nic_byte(dev, current_cmd->para_1,\n\t\t\t\t       (u8)current_cmd->para_2);\n\t\t\tbreak;\n\t\tcase CMD_ID_RF_WRITE_REG:\n\t\t\tfor (e_rfpath = 0; e_rfpath < RF90_PATH_MAX; e_rfpath++) {\n\t\t\t\trtl8192_phy_SetRFReg(dev,\n\t\t\t\t\t\t     (enum rf90_radio_path_e)e_rfpath,\n\t\t\t\t\t\t     current_cmd->para_1,\n\t\t\t\t\t\t     bZebra1_ChannelNum,\n\t\t\t\t\t\t     current_cmd->para_2);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t} while (true);\n\n\t*delay = current_cmd->ms_delay;\n\t(*step)++;\n\tret = false;\n\nout:\n\tkfree(pre_cmd);\n\tkfree(post_cmd);\n\tkfree(rf_cmd);\n\n\treturn ret;\n}\n\n \nstatic void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu32\tdelay = 0;\n\n\twhile (!rtl8192_phy_SwChnlStepByStep(dev, channel, &priv->SwChnlStage,\n\t\t\t\t\t     &priv->SwChnlStep, &delay)) {\n\t\tif (!priv->up)\n\t\t\tbreak;\n\t}\n}\n\n \nvoid rtl8192_SwChnl_WorkItem(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tRT_TRACE(COMP_CH, \"==> SwChnlCallback819xUsbWorkItem(), chan:%d\\n\",\n\t\t priv->chan);\n\n\trtl8192_phy_FinishSwChnlNow(dev, priv->chan);\n\n\tRT_TRACE(COMP_CH, \"<== SwChnlCallback819xUsbWorkItem()\\n\");\n}\n\n \nu8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tRT_TRACE(COMP_CH, \"%s(), SwChnlInProgress: %d\\n\", __func__,\n\t\t priv->SwChnlInProgress);\n\tif (!priv->up)\n\t\treturn false;\n\tif (priv->SwChnlInProgress)\n\t\treturn false;\n\n\t \n\tswitch (priv->ieee80211->mode) {\n\tcase WIRELESS_MODE_A:\n\tcase WIRELESS_MODE_N_5G:\n\t\tif (channel <= 14) {\n\t\t\tRT_TRACE(COMP_ERR, \"WIRELESS_MODE_A but channel<=14\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase WIRELESS_MODE_B:\n\t\tif (channel > 14) {\n\t\t\tRT_TRACE(COMP_ERR, \"WIRELESS_MODE_B but channel>14\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\tcase WIRELESS_MODE_N_24G:\n\t\tif (channel > 14) {\n\t\t\tRT_TRACE(COMP_ERR, \"WIRELESS_MODE_G but channel>14\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n\t \n\n\tpriv->SwChnlInProgress = true;\n\tif (channel == 0)\n\t\tchannel = 1;\n\n\tpriv->chan = channel;\n\n\tpriv->SwChnlStage = 0;\n\tpriv->SwChnlStep = 0;\n\tif (priv->up)\n\t\trtl8192_SwChnl_WorkItem(dev);\n\n\tpriv->SwChnlInProgress = false;\n\treturn true;\n}\n\n \nvoid rtl8192_SetBWModeWorkItem(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\tu8 regBwOpMode;\n\n\tRT_TRACE(COMP_SWBW, \"%s()  Switch to %s bandwidth\\n\", __func__,\n\t\t priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20?\"20MHz\":\"40MHz\");\n\n\tif (priv->rf_chip == RF_PSEUDO_11N) {\n\t\tpriv->SetBWModeInProgress = false;\n\t\treturn;\n\t}\n\n\t \n\tread_nic_byte(dev, BW_OPMODE, &regBwOpMode);\n\n\tswitch (priv->CurrentChannelBW) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\tregBwOpMode |= BW_OPMODE_20MHZ;\n\t\t \n\t\twrite_nic_byte(dev, BW_OPMODE, regBwOpMode);\n\t\tbreak;\n\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\tregBwOpMode &= ~BW_OPMODE_20MHZ;\n\t\t \n\t\twrite_nic_byte(dev, BW_OPMODE, regBwOpMode);\n\t\tbreak;\n\n\tdefault:\n\t\tRT_TRACE(COMP_ERR,\n\t\t\t \"SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\\n\",\n\t\t\t priv->CurrentChannelBW);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (priv->CurrentChannelBW) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\trtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x0);\n\t\trtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x0);\n\t\trtl8192_setBBreg(dev, rFPGA0_AnalogParameter1,\n\t\t\t\t 0x00100000, 1);\n\n\t\t \n\t\tpriv->cck_present_attenuation =\n\t\t\tpriv->cck_present_attenuation_20Mdefault +\n\t\t\tpriv->cck_present_attenuation_difference;\n\n\t\tif (priv->cck_present_attenuation > 22)\n\t\t\tpriv->cck_present_attenuation = 22;\n\t\tif (priv->cck_present_attenuation < 0)\n\t\t\tpriv->cck_present_attenuation = 0;\n\t\tRT_TRACE(COMP_INIT,\n\t\t\t \"20M, pHalData->CCKPresentAttentuation = %d\\n\",\n\t\t\t priv->cck_present_attenuation);\n\n\t\tif (priv->chan == 14 && !priv->bcck_in_ch14) {\n\t\t\tpriv->bcck_in_ch14 = true;\n\t\t\tdm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t} else if (priv->chan != 14 && priv->bcck_in_ch14) {\n\t\t\tpriv->bcck_in_ch14 = false;\n\t\t\tdm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t} else {\n\t\t\tdm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t}\n\n\t\tbreak;\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\trtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x1);\n\t\trtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x1);\n\t\trtl8192_setBBreg(dev, rCCK0_System, bCCKSideBand,\n\t\t\t\t priv->nCur40MhzPrimeSC >> 1);\n\t\trtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);\n\t\trtl8192_setBBreg(dev, rOFDM1_LSTF, 0xC00,\n\t\t\t\t priv->nCur40MhzPrimeSC);\n\t\tpriv->cck_present_attenuation =\n\t\t\tpriv->cck_present_attenuation_40Mdefault +\n\t\t\tpriv->cck_present_attenuation_difference;\n\n\t\tif (priv->cck_present_attenuation > 22)\n\t\t\tpriv->cck_present_attenuation = 22;\n\t\tif (priv->cck_present_attenuation < 0)\n\t\t\tpriv->cck_present_attenuation = 0;\n\n\t\tRT_TRACE(COMP_INIT,\n\t\t\t \"40M, pHalData->CCKPresentAttentuation = %d\\n\",\n\t\t\t priv->cck_present_attenuation);\n\t\tif (priv->chan == 14 && !priv->bcck_in_ch14) {\n\t\t\tpriv->bcck_in_ch14 = true;\n\t\t\tdm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t} else if (priv->chan != 14 && priv->bcck_in_ch14) {\n\t\t\tpriv->bcck_in_ch14 = false;\n\t\t\tdm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t} else {\n\t\t\tdm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tRT_TRACE(COMP_ERR,\n\t\t\t \"SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\\n\",\n\t\t\t priv->CurrentChannelBW);\n\t\tbreak;\n\t}\n\t \n\n\t \n\tswitch (priv->rf_chip) {\n\tcase RF_8225:\n\t\tbreak;\n\n\tcase RF_8256:\n\t\tphy_set_rf8256_bandwidth(dev, priv->CurrentChannelBW);\n\t\tbreak;\n\n\tcase RF_8258:\n\t\tbreak;\n\n\tcase RF_PSEUDO_11N:\n\t\tbreak;\n\n\tdefault:\n\t\tRT_TRACE(COMP_ERR, \"Unknown RFChipID: %d\\n\", priv->rf_chip);\n\t\tbreak;\n\t}\n\tpriv->SetBWModeInProgress = false;\n\n\tRT_TRACE(COMP_SWBW, \"<==SetBWMode819xUsb(), %d\\n\",\n\t\t atomic_read(&priv->ieee80211->atm_swbw));\n}\n\n \nvoid rtl8192_SetBWMode(struct net_device *dev,\n\t\t       enum ht_channel_width bandwidth,\n\t\t       enum ht_extension_chan_offset offset)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tif (priv->SetBWModeInProgress)\n\t\treturn;\n\tpriv->SetBWModeInProgress = true;\n\n\tpriv->CurrentChannelBW = bandwidth;\n\n\tif (offset == HT_EXTCHNL_OFFSET_LOWER)\n\t\tpriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_UPPER;\n\telse if (offset == HT_EXTCHNL_OFFSET_UPPER)\n\t\tpriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_LOWER;\n\telse\n\t\tpriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\n\trtl8192_SetBWModeWorkItem(dev);\n}\n\nvoid InitialGain819xUsb(struct net_device *dev,\tu8 Operation)\n{\n\tstruct r8192_priv *priv = ieee80211_priv(dev);\n\n\tpriv->InitialGainOperateType = Operation;\n\n\tif (priv->up)\n\t\tqueue_delayed_work(priv->priv_wq, &priv->initialgain_operate_wq, 0);\n}\n\nvoid InitialGainOperateWorkItemCallBack(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct r8192_priv *priv = container_of(dwork, struct r8192_priv,\n\t\t\t\t\t       initialgain_operate_wq);\n\tstruct net_device *dev = priv->ieee80211->dev;\n#define SCAN_RX_INITIAL_GAIN\t0x17\n#define POWER_DETECTION_TH\t0x08\n\tu32\tbitmask;\n\tu8\tinitial_gain;\n\tu8\tOperation;\n\n\tOperation = priv->InitialGainOperateType;\n\n\tswitch (Operation) {\n\tcase IG_Backup:\n\t\tRT_TRACE(COMP_SCAN, \"IG_Backup, backup the initial gain.\\n\");\n\t\tinitial_gain = SCAN_RX_INITIAL_GAIN;\n\t\tbitmask = bMaskByte0;\n\t\tif (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\n\t\t\t \n\t\t\trtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);\n\t\tpriv->initgain_backup.xaagccore1 =\n\t\t\t(u8)rtl8192_QueryBBReg(dev, rOFDM0_XAAGCCore1, bitmask);\n\t\tpriv->initgain_backup.xbagccore1 =\n\t\t\t(u8)rtl8192_QueryBBReg(dev, rOFDM0_XBAGCCore1, bitmask);\n\t\tpriv->initgain_backup.xcagccore1 =\n\t\t\t(u8)rtl8192_QueryBBReg(dev, rOFDM0_XCAGCCore1, bitmask);\n\t\tpriv->initgain_backup.xdagccore1 =\n\t\t\t(u8)rtl8192_QueryBBReg(dev, rOFDM0_XDAGCCore1, bitmask);\n\t\tbitmask = bMaskByte2;\n\t\tpriv->initgain_backup.cca =\n\t\t\t(u8)rtl8192_QueryBBReg(dev, rCCK0_CCA, bitmask);\n\n\t\tRT_TRACE(COMP_SCAN, \"Scan InitialGainBackup 0xc50 is %x\\n\",\n\t\t\t priv->initgain_backup.xaagccore1);\n\t\tRT_TRACE(COMP_SCAN, \"Scan InitialGainBackup 0xc58 is %x\\n\",\n\t\t\t priv->initgain_backup.xbagccore1);\n\t\tRT_TRACE(COMP_SCAN, \"Scan InitialGainBackup 0xc60 is %x\\n\",\n\t\t\t priv->initgain_backup.xcagccore1);\n\t\tRT_TRACE(COMP_SCAN, \"Scan InitialGainBackup 0xc68 is %x\\n\",\n\t\t\t priv->initgain_backup.xdagccore1);\n\t\tRT_TRACE(COMP_SCAN, \"Scan InitialGainBackup 0xa0a is %x\\n\",\n\t\t\t priv->initgain_backup.cca);\n\n\t\tRT_TRACE(COMP_SCAN, \"Write scan initial gain = 0x%x\\n\",\n\t\t\t initial_gain);\n\t\twrite_nic_byte(dev, rOFDM0_XAAGCCore1, initial_gain);\n\t\twrite_nic_byte(dev, rOFDM0_XBAGCCore1, initial_gain);\n\t\twrite_nic_byte(dev, rOFDM0_XCAGCCore1, initial_gain);\n\t\twrite_nic_byte(dev, rOFDM0_XDAGCCore1, initial_gain);\n\t\tRT_TRACE(COMP_SCAN, \"Write scan 0xa0a = 0x%x\\n\",\n\t\t\t POWER_DETECTION_TH);\n\t\twrite_nic_byte(dev, 0xa0a, POWER_DETECTION_TH);\n\t\tbreak;\n\tcase IG_Restore:\n\t\tRT_TRACE(COMP_SCAN, \"IG_Restore, restore the initial gain.\\n\");\n\t\tbitmask = 0x7f;  \n\t\tif (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\n\t\t\t \n\t\t\trtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);\n\n\t\trtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, bitmask,\n\t\t\t\t (u32)priv->initgain_backup.xaagccore1);\n\t\trtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, bitmask,\n\t\t\t\t (u32)priv->initgain_backup.xbagccore1);\n\t\trtl8192_setBBreg(dev, rOFDM0_XCAGCCore1, bitmask,\n\t\t\t\t (u32)priv->initgain_backup.xcagccore1);\n\t\trtl8192_setBBreg(dev, rOFDM0_XDAGCCore1, bitmask,\n\t\t\t\t (u32)priv->initgain_backup.xdagccore1);\n\t\tbitmask  = bMaskByte2;\n\t\trtl8192_setBBreg(dev, rCCK0_CCA, bitmask,\n\t\t\t\t (u32)priv->initgain_backup.cca);\n\n\t\tRT_TRACE(COMP_SCAN, \"Scan BBInitialGainRestore 0xc50 is %x\\n\",\n\t\t\t priv->initgain_backup.xaagccore1);\n\t\tRT_TRACE(COMP_SCAN, \"Scan BBInitialGainRestore 0xc58 is %x\\n\",\n\t\t\t priv->initgain_backup.xbagccore1);\n\t\tRT_TRACE(COMP_SCAN, \"Scan BBInitialGainRestore 0xc60 is %x\\n\",\n\t\t\t priv->initgain_backup.xcagccore1);\n\t\tRT_TRACE(COMP_SCAN, \"Scan BBInitialGainRestore 0xc68 is %x\\n\",\n\t\t\t priv->initgain_backup.xdagccore1);\n\t\tRT_TRACE(COMP_SCAN, \"Scan BBInitialGainRestore 0xa0a is %x\\n\",\n\t\t\t priv->initgain_backup.cca);\n\n\t\trtl8192_phy_setTxPower(dev, priv->ieee80211->current_network.channel);\n\n\t\tif (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\n\t\t\t \n\t\t\trtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);\n\t\tbreak;\n\tdefault:\n\t\tRT_TRACE(COMP_SCAN, \"Unknown IG Operation.\\n\");\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}