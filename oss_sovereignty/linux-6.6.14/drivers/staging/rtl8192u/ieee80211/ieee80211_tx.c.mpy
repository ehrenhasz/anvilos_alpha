{
  "module_name": "ieee80211_tx.c",
  "hash_id": "d2e65834ca63513c25401540db9948508b43cdc60ca7418b1ebae25f04941843",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n#include <linux/wireless.h>\n#include <linux/etherdevice.h>\n#include <linux/uaccess.h>\n#include <linux/if_vlan.h>\n\n#include \"ieee80211.h\"\n\n\n \n\nstatic u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };\nstatic u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };\n\nstatic inline int ieee80211_put_snap(u8 *data, u16 h_proto)\n{\n\tstruct ieee80211_snap_hdr *snap;\n\tu8 *oui;\n\n\tsnap = (struct ieee80211_snap_hdr *)data;\n\tsnap->dsap = 0xaa;\n\tsnap->ssap = 0xaa;\n\tsnap->ctrl = 0x03;\n\n\tif (h_proto == 0x8137 || h_proto == 0x80f3)\n\t\toui = P802_1H_OUI;\n\telse\n\t\toui = RFC1042_OUI;\n\tsnap->oui[0] = oui[0];\n\tsnap->oui[1] = oui[1];\n\tsnap->oui[2] = oui[2];\n\n\t*(__be16 *)(data + SNAP_SIZE) = htons(h_proto);\n\n\treturn SNAP_SIZE + sizeof(u16);\n}\n\nint ieee80211_encrypt_fragment(\n\tstruct ieee80211_device *ieee,\n\tstruct sk_buff *frag,\n\tint hdr_len)\n{\n\tstruct ieee80211_crypt_data *crypt = ieee->crypt[ieee->tx_keyidx];\n\tint res;\n\n\tif (!(crypt && crypt->ops)) {\n\t\tprintk(\"=========>%s(), crypt is null\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tif (ieee->tkip_countermeasures &&\n\t    crypt && crypt->ops && strcmp(crypt->ops->name, \"TKIP\") == 0) {\n\t\tif (net_ratelimit()) {\n\t\t\tstruct rtl_80211_hdr_3addrqos *header;\n\n\t\t\theader = (struct rtl_80211_hdr_3addrqos *)frag->data;\n\t\t\tnetdev_dbg(ieee->dev, \"TKIP countermeasures: dropped \"\n\t\t\t       \"TX packet to %pM\\n\", header->addr1);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t \n\n\t \n\t \n\tatomic_inc(&crypt->refcnt);\n\tres = 0;\n\tif (crypt->ops->encrypt_msdu)\n\t\tres = crypt->ops->encrypt_msdu(frag, hdr_len, crypt->priv);\n\tif (res == 0 && crypt->ops->encrypt_mpdu)\n\t\tres = crypt->ops->encrypt_mpdu(frag, hdr_len, crypt->priv);\n\n\tatomic_dec(&crypt->refcnt);\n\tif (res < 0) {\n\t\tnetdev_info(ieee->dev, \"Encryption failed: len=%d.\\n\",\n\t\t\t    frag->len);\n\t\tieee->ieee_stats.tx_discards++;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\nvoid ieee80211_txb_free(struct ieee80211_txb *txb)\n{\n\t \n\tif (unlikely(!txb))\n\t\treturn;\n\tkfree(txb);\n}\nEXPORT_SYMBOL(ieee80211_txb_free);\n\nstatic struct ieee80211_txb *ieee80211_alloc_txb(int nr_frags, int txb_size,\n\t\t\t\t\t\t gfp_t gfp_mask)\n{\n\tstruct ieee80211_txb *txb;\n\tint i;\n\ttxb = kmalloc(\n\t\tsizeof(struct ieee80211_txb) + (sizeof(u8 *) * nr_frags),\n\t\tgfp_mask);\n\tif (!txb)\n\t\treturn NULL;\n\n\tmemset(txb, 0, sizeof(struct ieee80211_txb));\n\ttxb->nr_frags = nr_frags;\n\ttxb->frag_size = __cpu_to_le16(txb_size);\n\n\tfor (i = 0; i < nr_frags; i++) {\n\t\ttxb->fragments[i] = dev_alloc_skb(txb_size);\n\t\tif (unlikely(!txb->fragments[i])) {\n\t\t\ti--;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(txb->fragments[i]->cb, 0, sizeof(txb->fragments[i]->cb));\n\t}\n\tif (unlikely(i != nr_frags)) {\n\t\twhile (i >= 0)\n\t\t\tdev_kfree_skb_any(txb->fragments[i--]);\n\t\tkfree(txb);\n\t\treturn NULL;\n\t}\n\treturn txb;\n}\n\n \n \nstatic int\nieee80211_classify(struct sk_buff *skb, struct ieee80211_network *network)\n{\n\tstruct ethhdr *eth;\n\tstruct iphdr *ip;\n\teth = (struct ethhdr *)skb->data;\n\tif (eth->h_proto != htons(ETH_P_IP))\n\t\treturn 0;\n\n\tip = ip_hdr(skb);\n\tswitch (ip->tos & 0xfc) {\n\tcase 0x20:\n\t\treturn 2;\n\tcase 0x40:\n\t\treturn 1;\n\tcase 0x60:\n\t\treturn 3;\n\tcase 0x80:\n\t\treturn 4;\n\tcase 0xa0:\n\t\treturn 5;\n\tcase 0xc0:\n\t\treturn 6;\n\tcase 0xe0:\n\t\treturn 7;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void ieee80211_tx_query_agg_cap(struct ieee80211_device *ieee,\n\t\t\t\t       struct sk_buff *skb, struct cb_desc *tcb_desc)\n{\n\tPRT_HIGH_THROUGHPUT\tpHTInfo = ieee->pHTInfo;\n\tstruct tx_ts_record        *pTxTs = NULL;\n\tstruct rtl_80211_hdr_1addr *hdr = (struct rtl_80211_hdr_1addr *)skb->data;\n\n\tif (!pHTInfo->bCurrentHTSupport || !pHTInfo->bEnableHT)\n\t\treturn;\n\tif (!IsQoSDataFrame(skb->data))\n\t\treturn;\n\n\tif (is_multicast_ether_addr(hdr->addr1))\n\t\treturn;\n\t \n\tif (!ieee->GetNmodeSupportBySecCfg(ieee->dev))\n\t\treturn;\n\n\tif (pHTInfo->bCurrentAMPDUEnable) {\n\t\tif (!GetTs(ieee, (struct ts_common_info **)(&pTxTs), hdr->addr1, skb->priority, TX_DIR, true)) {\n\t\t\tprintk(\"===>can't get TS\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (!pTxTs->tx_admitted_ba_record.valid) {\n\t\t\tTsStartAddBaProcess(ieee, pTxTs);\n\t\t\tgoto FORCED_AGG_SETTING;\n\t\t} else if (!pTxTs->using_ba) {\n\t\t\tif (SN_LESS(pTxTs->tx_admitted_ba_record.start_seq_ctrl.field.seq_num, (pTxTs->tx_cur_seq + 1) % 4096))\n\t\t\t\tpTxTs->using_ba = true;\n\t\t\telse\n\t\t\t\tgoto FORCED_AGG_SETTING;\n\t\t}\n\n\t\tif (ieee->iw_mode == IW_MODE_INFRA) {\n\t\t\ttcb_desc->bAMPDUEnable = true;\n\t\t\ttcb_desc->ampdu_factor = pHTInfo->CurrentAMPDUFactor;\n\t\t\ttcb_desc->ampdu_density = pHTInfo->CurrentMPDUDensity;\n\t\t}\n\t}\nFORCED_AGG_SETTING:\n\tswitch (pHTInfo->ForcedAMPDUMode) {\n\tcase HT_AGG_AUTO:\n\t\tbreak;\n\n\tcase HT_AGG_FORCE_ENABLE:\n\t\ttcb_desc->bAMPDUEnable = true;\n\t\ttcb_desc->ampdu_density = pHTInfo->ForcedMPDUDensity;\n\t\ttcb_desc->ampdu_factor = pHTInfo->ForcedAMPDUFactor;\n\t\tbreak;\n\n\tcase HT_AGG_FORCE_DISABLE:\n\t\ttcb_desc->bAMPDUEnable = false;\n\t\ttcb_desc->ampdu_density = 0;\n\t\ttcb_desc->ampdu_factor = 0;\n\t\tbreak;\n\n\t}\n\t\treturn;\n}\n\nstatic void ieee80211_qurey_ShortPreambleMode(struct ieee80211_device *ieee,\n\t\t\t\t\t      struct cb_desc *tcb_desc)\n{\n\ttcb_desc->bUseShortPreamble = false;\n\tif (tcb_desc->data_rate == 2) { \n\t\treturn;\n\t} else if (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE) {\n\t\ttcb_desc->bUseShortPreamble = true;\n\t}\n\treturn;\n}\nstatic void\nieee80211_query_HTCapShortGI(struct ieee80211_device *ieee, struct cb_desc *tcb_desc)\n{\n\tPRT_HIGH_THROUGHPUT\t\tpHTInfo = ieee->pHTInfo;\n\n\ttcb_desc->bUseShortGI\t\t= false;\n\n\tif (!pHTInfo->bCurrentHTSupport || !pHTInfo->bEnableHT)\n\t\treturn;\n\n\tif (pHTInfo->bForcedShortGI) {\n\t\ttcb_desc->bUseShortGI = true;\n\t\treturn;\n\t}\n\n\tif (pHTInfo->bCurBW40MHz && pHTInfo->bCurShortGI40MHz)\n\t\ttcb_desc->bUseShortGI = true;\n\telse if (!pHTInfo->bCurBW40MHz && pHTInfo->bCurShortGI20MHz)\n\t\ttcb_desc->bUseShortGI = true;\n}\n\nstatic void ieee80211_query_BandwidthMode(struct ieee80211_device *ieee,\n\t\t\t\t\t  struct cb_desc *tcb_desc)\n{\n\tPRT_HIGH_THROUGHPUT\tpHTInfo = ieee->pHTInfo;\n\n\ttcb_desc->bPacketBW = false;\n\n\tif (!pHTInfo->bCurrentHTSupport || !pHTInfo->bEnableHT)\n\t\treturn;\n\n\tif (tcb_desc->bMulticast || tcb_desc->bBroadcast)\n\t\treturn;\n\n\tif ((tcb_desc->data_rate & 0x80) == 0)  \n\t\treturn;\n\t \n\tif (pHTInfo->bCurBW40MHz && pHTInfo->bCurTxBW40MHz && !ieee->bandwidth_auto_switch.bforced_tx20Mhz)\n\t\ttcb_desc->bPacketBW = true;\n\treturn;\n}\n\nstatic void ieee80211_query_protectionmode(struct ieee80211_device *ieee,\n\t\t\t\t\t   struct cb_desc *tcb_desc,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\t \n\ttcb_desc->bRTSSTBC\t\t\t= false;\n\ttcb_desc->bRTSUseShortGI\t\t= false;  \n\ttcb_desc->bCTSEnable\t\t\t= false;  \n\ttcb_desc->RTSSC\t\t\t\t= 0;\t\t \n\ttcb_desc->bRTSBW\t\t\t= false;  \n\n\tif (tcb_desc->bBroadcast || tcb_desc->bMulticast)  \n\t\treturn;\n\n\tif (is_broadcast_ether_addr(skb->data + 16))   \n\t\treturn;\n\n\tif (ieee->mode < IEEE_N_24G)   {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\tif (skb->len > ieee->rts) {\n\t\t\ttcb_desc->bRTSEnable = true;\n\t\t\ttcb_desc->rts_rate = MGN_24M;\n\t\t} else if (ieee->current_network.buseprotection) {\n\t\t\t \n\t\t\ttcb_desc->bRTSEnable = true;\n\t\t\ttcb_desc->bCTSEnable = true;\n\t\t\ttcb_desc->rts_rate = MGN_24M;\n\t\t}\n\t\t \n\t\treturn;\n\t} else {  \n\t\tPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\n\t\twhile (true) {\n\t\t\t \n\t\t\tif (ieee->current_network.buseprotection) { \n\t\t\t\ttcb_desc->bRTSEnable = true;\n\t\t\t\ttcb_desc->bCTSEnable = true;\n\t\t\t\ttcb_desc->rts_rate = MGN_24M;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (pHTInfo->bCurrentHTSupport && pHTInfo->bEnableHT) {\n\t\t\t\tu8 HTOpMode = pHTInfo->CurrentOpMode;\n\t\t\t\tif ((pHTInfo->bCurBW40MHz && (HTOpMode == 2 || HTOpMode == 3)) ||\n\t\t\t\t\t\t\t(!pHTInfo->bCurBW40MHz && HTOpMode == 3)) {\n\t\t\t\t\ttcb_desc->rts_rate = MGN_24M;  \n\t\t\t\t\ttcb_desc->bRTSEnable = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (skb->len > ieee->rts) {\n\t\t\t\ttcb_desc->rts_rate = MGN_24M;  \n\t\t\t\ttcb_desc->bRTSEnable = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\t \n\t\t\tif (tcb_desc->bAMPDUEnable) {\n\t\t\t\ttcb_desc->rts_rate = MGN_24M;  \n\t\t\t\t \n\t\t\t\t \n\t\t\t\ttcb_desc->bRTSEnable = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (pHTInfo->IOTAction & HT_IOT_ACT_FORCED_CTS2SELF) {\n\t\t\t\ttcb_desc->bCTSEnable\t= true;\n\t\t\t\ttcb_desc->rts_rate  =\tMGN_24M;\n\t\t\t\ttcb_desc->bRTSEnable = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tgoto NO_PROTECTION;\n\t\t}\n\t\t}\n\t \n\tif (0) {\n\t\ttcb_desc->bCTSEnable\t= true;\n\t\ttcb_desc->rts_rate = MGN_24M;\n\t\ttcb_desc->bRTSEnable\t= true;\n\t}\n\tif (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\n\t\ttcb_desc->bUseShortPreamble = true;\n\tif (ieee->mode == IW_MODE_MASTER)\n\t\tgoto NO_PROTECTION;\n\treturn;\nNO_PROTECTION:\n\ttcb_desc->bRTSEnable\t= false;\n\ttcb_desc->bCTSEnable\t= false;\n\ttcb_desc->rts_rate\t\t= 0;\n\ttcb_desc->RTSSC\t\t= 0;\n\ttcb_desc->bRTSBW\t\t= false;\n}\n\n\nstatic void ieee80211_txrate_selectmode(struct ieee80211_device *ieee,\n\t\t\t\t\tstruct cb_desc *tcb_desc)\n{\n\tif (ieee->bTxDisableRateFallBack)\n\t\ttcb_desc->bTxDisableRateFallBack = true;\n\n\tif (ieee->bTxUseDriverAssingedRate)\n\t\ttcb_desc->bTxUseDriverAssingedRate = true;\n\tif (!tcb_desc->bTxDisableRateFallBack || !tcb_desc->bTxUseDriverAssingedRate) {\n\t\tif (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC)\n\t\t\ttcb_desc->RATRIndex = 0;\n\t}\n}\n\nstatic void ieee80211_query_seqnum(struct ieee80211_device *ieee,\n\t\t\t\t   struct sk_buff *skb, u8 *dst)\n{\n\tif (is_multicast_ether_addr(dst))\n\t\treturn;\n\tif (IsQoSDataFrame(skb->data))   {\n\t\tstruct tx_ts_record *pTS = NULL;\n\t\tif (!GetTs(ieee, (struct ts_common_info **)(&pTS), dst, skb->priority, TX_DIR, true)) {\n\t\t\treturn;\n\t\t}\n\t\tpTS->tx_cur_seq = (pTS->tx_cur_seq + 1) % 4096;\n\t}\n}\n\nnetdev_tx_t ieee80211_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ieee80211_device *ieee = netdev_priv(dev);\n\tstruct ieee80211_txb *txb = NULL;\n\tstruct rtl_80211_hdr_3addrqos *frag_hdr;\n\tint i, bytes_per_frag, nr_frags, bytes_last_frag, frag_size;\n\tunsigned long flags;\n\tstruct net_device_stats *stats = &ieee->stats;\n\tint ether_type = 0, encrypt;\n\tint bytes, fc, qos_ctl = 0, hdr_len;\n\tstruct sk_buff *skb_frag;\n\tstruct rtl_80211_hdr_3addrqos header = {  \n\t\t.duration_id = 0,\n\t\t.seq_ctl = 0,\n\t\t.qos_ctl = 0\n\t};\n\tu8 dest[ETH_ALEN], src[ETH_ALEN];\n\tint qos_actived = ieee->current_network.qos_data.active;\n\n\tstruct ieee80211_crypt_data *crypt;\n\n\tstruct cb_desc *tcb_desc;\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\t \n\tif ((!ieee->hard_start_xmit && !(ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)) ||\n\t   ((!ieee->softmac_data_hard_start_xmit && (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)))) {\n\t\tnetdev_warn(ieee->dev, \"No xmit handler.\\n\");\n\t\tgoto success;\n\t}\n\n\n\tif (likely(ieee->raw_tx == 0)) {\n\t\tif (unlikely(skb->len < SNAP_SIZE + sizeof(u16))) {\n\t\t\tnetdev_warn(ieee->dev, \"skb too small (%d).\\n\",\n\t\t\t\t    skb->len);\n\t\t\tgoto success;\n\t\t}\n\n\t\tmemset(skb->cb, 0, sizeof(skb->cb));\n\t\tether_type = ntohs(((struct ethhdr *)skb->data)->h_proto);\n\n\t\tcrypt = ieee->crypt[ieee->tx_keyidx];\n\n\t\tencrypt = !(ether_type == ETH_P_PAE && ieee->ieee802_1x) &&\n\t\t\tieee->host_encrypt && crypt && crypt->ops;\n\n\t\tif (!encrypt && ieee->ieee802_1x &&\n\t\tieee->drop_unencrypted && ether_type != ETH_P_PAE) {\n\t\t\tstats->tx_dropped++;\n\t\t\tgoto success;\n\t\t}\n\t#ifdef CONFIG_IEEE80211_DEBUG\n\t\tif (crypt && !encrypt && ether_type == ETH_P_PAE) {\n\t\t\tstruct eapol *eap = (struct eapol *)(skb->data +\n\t\t\t\tsizeof(struct ethhdr) - SNAP_SIZE - sizeof(u16));\n\t\t\tIEEE80211_DEBUG_EAP(\"TX: IEEE 802.11 EAPOL frame: %s\\n\",\n\t\t\t\teap_get_type(eap->type));\n\t\t}\n\t#endif\n\n\t\t \n\t\tmemcpy(&dest, skb->data, ETH_ALEN);\n\t\tmemcpy(&src, skb->data + ETH_ALEN, ETH_ALEN);\n\n\t\t \n\t\tskb_pull(skb, sizeof(struct ethhdr));\n\n\t\t \n\t\tbytes = skb->len + SNAP_SIZE + sizeof(u16);\n\n\t\tif (encrypt)\n\t\t\tfc = IEEE80211_FTYPE_DATA | IEEE80211_FCTL_WEP;\n\t\telse\n\n\t\t\tfc = IEEE80211_FTYPE_DATA;\n\n\t\t \n\t\tif (qos_actived)\n\t\t\tfc |= IEEE80211_STYPE_QOS_DATA;\n\t\telse\n\t\t\tfc |= IEEE80211_STYPE_DATA;\n\n\t\tif (ieee->iw_mode == IW_MODE_INFRA) {\n\t\t\tfc |= IEEE80211_FCTL_TODS;\n\t\t\t \n\t\t\tmemcpy(&header.addr1, ieee->current_network.bssid, ETH_ALEN);\n\t\t\tmemcpy(&header.addr2, &src, ETH_ALEN);\n\t\t\tmemcpy(&header.addr3, &dest, ETH_ALEN);\n\t\t} else if (ieee->iw_mode == IW_MODE_ADHOC) {\n\t\t\t \n\t\t\tmemcpy(&header.addr1, dest, ETH_ALEN);\n\t\t\tmemcpy(&header.addr2, src, ETH_ALEN);\n\t\t\tmemcpy(&header.addr3, ieee->current_network.bssid, ETH_ALEN);\n\t\t}\n\n\t\theader.frame_ctl = cpu_to_le16(fc);\n\n\t\t \n\t\tif (is_multicast_ether_addr(header.addr1)) {\n\t\t\tfrag_size = MAX_FRAG_THRESHOLD;\n\t\t\tqos_ctl |= QOS_CTL_NOTCONTAIN_ACK;\n\t\t} else {\n\t\t\tfrag_size = ieee->fts; \n\t\t\tqos_ctl = 0;\n\t\t}\n\n\t\t \n\t\tif (qos_actived) {\n\t\t\thdr_len = IEEE80211_3ADDR_LEN + 2;\n\n\t\t\tskb->priority = ieee80211_classify(skb, &ieee->current_network);\n\t\t\tqos_ctl |= skb->priority;  \n\t\t\theader.qos_ctl = cpu_to_le16(qos_ctl & IEEE80211_QOS_TID);\n\t\t} else {\n\t\t\thdr_len = IEEE80211_3ADDR_LEN;\n\t\t}\n\t\t \n\t\tbytes_per_frag = frag_size - hdr_len;\n\t\tif (ieee->config &\n\t\t(CFG_IEEE80211_COMPUTE_FCS | CFG_IEEE80211_RESERVE_FCS))\n\t\t\tbytes_per_frag -= IEEE80211_FCS_LEN;\n\n\t\t \n\t\tif (encrypt)\n\t\t\tbytes_per_frag -= crypt->ops->extra_prefix_len +\n\t\t\t\tcrypt->ops->extra_postfix_len;\n\n\t\t \n\t\tnr_frags = bytes / bytes_per_frag;\n\t\tbytes_last_frag = bytes % bytes_per_frag;\n\t\tif (bytes_last_frag)\n\t\t\tnr_frags++;\n\t\telse\n\t\t\tbytes_last_frag = bytes_per_frag;\n\n\t\t \n\t\ttxb = ieee80211_alloc_txb(nr_frags, frag_size + ieee->tx_headroom, GFP_ATOMIC);\n\t\tif (unlikely(!txb)) {\n\t\t\tnetdev_warn(ieee->dev, \"Could not allocate TXB\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t\ttxb->encrypted = encrypt;\n\t\ttxb->payload_size = __cpu_to_le16(bytes);\n\n\t\t \n\t\tif (qos_actived)\n\t\t\ttxb->queue_index = UP2AC(skb->priority);\n\t\telse\n\t\t\ttxb->queue_index = WME_AC_BK;\n\n\n\n\t\tfor (i = 0; i < nr_frags; i++) {\n\t\t\tskb_frag = txb->fragments[i];\n\t\t\ttcb_desc = (struct cb_desc *)(skb_frag->cb + MAX_DEV_ADDR_SIZE);\n\t\t\tif (qos_actived) {\n\t\t\t\tskb_frag->priority = skb->priority; \n\t\t\t\ttcb_desc->queue_index =  UP2AC(skb->priority);\n\t\t\t} else {\n\t\t\t\tskb_frag->priority = WME_AC_BK;\n\t\t\t\ttcb_desc->queue_index = WME_AC_BK;\n\t\t\t}\n\t\t\tskb_reserve(skb_frag, ieee->tx_headroom);\n\n\t\t\tif (encrypt) {\n\t\t\t\tif (ieee->hwsec_active)\n\t\t\t\t\ttcb_desc->bHwSec = 1;\n\t\t\t\telse\n\t\t\t\t\ttcb_desc->bHwSec = 0;\n\t\t\t\tskb_reserve(skb_frag, crypt->ops->extra_prefix_len);\n\t\t\t} else {\n\t\t\t\ttcb_desc->bHwSec = 0;\n\t\t\t}\n\t\t\tfrag_hdr = skb_put_data(skb_frag, &header, hdr_len);\n\n\t\t\t \n\t\t\tif (i != nr_frags - 1) {\n\t\t\t\tfrag_hdr->frame_ctl = cpu_to_le16(\n\t\t\t\t\tfc | IEEE80211_FCTL_MOREFRAGS);\n\t\t\t\tbytes = bytes_per_frag;\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbytes = bytes_last_frag;\n\t\t\t}\n\t\t\t \n\t\t\tif (qos_actived) {\n\t\t\t\t \n\t\t\t\tfrag_hdr->seq_ctl = cpu_to_le16(ieee->seq_ctrl[UP2AC(skb->priority) + 1] << 4 | i);\n\t\t\t} else {\n\t\t\t\tfrag_hdr->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4 | i);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (i == 0) {\n\t\t\t\tieee80211_put_snap(\n\t\t\t\t\tskb_put(skb_frag, SNAP_SIZE + sizeof(u16)),\n\t\t\t\t\tether_type);\n\t\t\t\tbytes -= SNAP_SIZE + sizeof(u16);\n\t\t\t}\n\n\t\t\tskb_put_data(skb_frag, skb->data, bytes);\n\n\t\t\t \n\t\t\tskb_pull(skb, bytes);\n\n\t\t\t \n\t\t\tif (encrypt)\n\t\t\t\tieee80211_encrypt_fragment(ieee, skb_frag, hdr_len);\n\t\t\tif (ieee->config &\n\t\t\t(CFG_IEEE80211_COMPUTE_FCS | CFG_IEEE80211_RESERVE_FCS))\n\t\t\t\tskb_put(skb_frag, 4);\n\t\t}\n\n\t\tif (qos_actived) {\n\t\t\tif (ieee->seq_ctrl[UP2AC(skb->priority) + 1] == 0xFFF)\n\t\t\t\tieee->seq_ctrl[UP2AC(skb->priority) + 1] = 0;\n\t\t\telse\n\t\t\t\tieee->seq_ctrl[UP2AC(skb->priority) + 1]++;\n\t\t} else {\n\t\t\tif (ieee->seq_ctrl[0] == 0xFFF)\n\t\t\t\tieee->seq_ctrl[0] = 0;\n\t\t\telse\n\t\t\t\tieee->seq_ctrl[0]++;\n\t\t}\n\t} else {\n\t\tif (unlikely(skb->len < sizeof(struct rtl_80211_hdr_3addr))) {\n\t\t\tnetdev_warn(ieee->dev, \"skb too small (%d).\\n\",\n\t\t\t\t    skb->len);\n\t\t\tgoto success;\n\t\t}\n\n\t\ttxb = ieee80211_alloc_txb(1, skb->len, GFP_ATOMIC);\n\t\tif (!txb) {\n\t\t\tnetdev_warn(ieee->dev, \"Could not allocate TXB\\n\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\ttxb->encrypted = 0;\n\t\ttxb->payload_size = __cpu_to_le16(skb->len);\n\t\tskb_put_data(txb->fragments[0], skb->data, skb->len);\n\t}\n\n success:\n\n\tif (txb) {\n\t\ttcb_desc = (struct cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);\n\t\ttcb_desc->bTxEnableFwCalcDur = 1;\n\t\tif (is_multicast_ether_addr(header.addr1))\n\t\t\ttcb_desc->bMulticast = 1;\n\t\tif (is_broadcast_ether_addr(header.addr1))\n\t\t\ttcb_desc->bBroadcast = 1;\n\t\tieee80211_txrate_selectmode(ieee, tcb_desc);\n\t\tif (tcb_desc->bMulticast ||  tcb_desc->bBroadcast)\n\t\t\ttcb_desc->data_rate = ieee->basic_rate;\n\t\telse\n\t\t\ttcb_desc->data_rate = CURRENT_RATE(ieee->mode, ieee->rate, ieee->HTCurrentOperaRate);\n\t\tieee80211_qurey_ShortPreambleMode(ieee, tcb_desc);\n\t\tieee80211_tx_query_agg_cap(ieee, txb->fragments[0], tcb_desc);\n\t\tieee80211_query_HTCapShortGI(ieee, tcb_desc);\n\t\tieee80211_query_BandwidthMode(ieee, tcb_desc);\n\t\tieee80211_query_protectionmode(ieee, tcb_desc, txb->fragments[0]);\n\t\tieee80211_query_seqnum(ieee, txb->fragments[0], header.addr1);\n\t}\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\tdev_kfree_skb_any(skb);\n\tif (txb) {\n\t\tif (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE) {\n\t\t\tieee80211_softmac_xmit(txb, ieee);\n\t\t} else {\n\t\t\tif ((*ieee->hard_start_xmit)(txb, dev) == 0) {\n\t\t\t\tstats->tx_packets++;\n\t\t\t\tstats->tx_bytes += __le16_to_cpu(txb->payload_size);\n\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t}\n\t\t\tieee80211_txb_free(txb);\n\t\t}\n\t}\n\n\treturn NETDEV_TX_OK;\n\n failed:\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\tnetif_stop_queue(dev);\n\tstats->tx_errors++;\n\treturn 1;\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}