{
  "module_name": "ieee80211_softmac.c",
  "hash_id": "0d9ec7d996f66228e9d3bd58e59905aff67a7fac2b5f842d355c55303ec65961",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c",
  "human_readable_source": "\n \n#include \"ieee80211.h\"\n\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/etherdevice.h>\n\n#include \"dot11d.h\"\n\nshort ieee80211_is_54g(const struct ieee80211_network *net)\n{\n\treturn (net->rates_ex_len > 0) || (net->rates_len > 4);\n}\nEXPORT_SYMBOL(ieee80211_is_54g);\n\nshort ieee80211_is_shortslot(const struct ieee80211_network *net)\n{\n\treturn net->capability & WLAN_CAPABILITY_SHORT_SLOT;\n}\nEXPORT_SYMBOL(ieee80211_is_shortslot);\n\n \nstatic unsigned int ieee80211_MFIE_rate_len(struct ieee80211_device *ieee)\n{\n\tunsigned int rate_len = 0;\n\n\tif (ieee->modulation & IEEE80211_CCK_MODULATION)\n\t\trate_len = IEEE80211_CCK_RATE_LEN + 2;\n\n\tif (ieee->modulation & IEEE80211_OFDM_MODULATION)\n\t\trate_len += IEEE80211_OFDM_RATE_LEN + 2;\n\n\treturn rate_len;\n}\n\n \nstatic void ieee80211_MFIE_Brate(struct ieee80211_device *ieee, u8 **tag_p)\n{\n\tu8 *tag = *tag_p;\n\n\tif (ieee->modulation & IEEE80211_CCK_MODULATION) {\n\t\t*tag++ = MFIE_TYPE_RATES;\n\t\t*tag++ = 4;\n\t\t*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_1MB;\n\t\t*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_2MB;\n\t\t*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_5MB;\n\t\t*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_11MB;\n\t}\n\n\t \n\t*tag_p = tag;\n}\n\nstatic void ieee80211_MFIE_Grate(struct ieee80211_device *ieee, u8 **tag_p)\n{\n\tu8 *tag = *tag_p;\n\n\tif (ieee->modulation & IEEE80211_OFDM_MODULATION) {\n\t\t*tag++ = MFIE_TYPE_RATES_EX;\n\t\t*tag++ = 8;\n\t\t*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_6MB;\n\t\t*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_9MB;\n\t\t*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_12MB;\n\t\t*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_18MB;\n\t\t*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_24MB;\n\t\t*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_36MB;\n\t\t*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_48MB;\n\t\t*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_54MB;\n\t}\n\n\t \n\t*tag_p = tag;\n}\n\nstatic void ieee80211_WMM_Info(struct ieee80211_device *ieee, u8 **tag_p)\n{\n\tu8 *tag = *tag_p;\n\n\t*tag++ = MFIE_TYPE_GENERIC;  \n\t*tag++ = 7;\n\t*tag++ = 0x00;\n\t*tag++ = 0x50;\n\t*tag++ = 0xf2;\n\t*tag++ = 0x02;\t \n\t*tag++ = 0x00;\n\t*tag++ = 0x01;\n#ifdef SUPPORT_USPD\n\tif (ieee->current_network.wmm_info & 0x80)\n\t\t*tag++ = 0x0f | MAX_SP_Len;\n\telse\n\t\t*tag++ = MAX_SP_Len;\n#else\n\t*tag++ = MAX_SP_Len;\n#endif\n\t*tag_p = tag;\n}\n\n#ifdef THOMAS_TURBO\nstatic void ieee80211_TURBO_Info(struct ieee80211_device *ieee, u8 **tag_p)\n{\n\tu8 *tag = *tag_p;\n\n\t*tag++ = MFIE_TYPE_GENERIC;  \n\t*tag++ = 7;\n\t*tag++ = 0x00;\n\t*tag++ = 0xe0;\n\t*tag++ = 0x4c;\n\t*tag++ = 0x01;\t \n\t*tag++ = 0x02;\n\t*tag++ = 0x11;\n\t*tag++ = 0x00;\n\n\t*tag_p = tag;\n\tnetdev_alert(ieee->dev, \"This is enable turbo mode IE process\\n\");\n}\n#endif\n\nstatic void enqueue_mgmt(struct ieee80211_device *ieee, struct sk_buff *skb)\n{\n\tint nh;\n\n\tnh = (ieee->mgmt_queue_head + 1) % MGMT_QUEUE_NUM;\n\n \n\tieee->mgmt_queue_head = nh;\n\tieee->mgmt_queue_ring[nh] = skb;\n\n\t\n}\n\nstatic struct sk_buff *dequeue_mgmt(struct ieee80211_device *ieee)\n{\n\tstruct sk_buff *ret;\n\n\tif (ieee->mgmt_queue_tail == ieee->mgmt_queue_head)\n\t\treturn NULL;\n\n\tret = ieee->mgmt_queue_ring[ieee->mgmt_queue_tail];\n\n\tieee->mgmt_queue_tail =\n\t\t(ieee->mgmt_queue_tail + 1) % MGMT_QUEUE_NUM;\n\n\treturn ret;\n}\n\nstatic void init_mgmt_queue(struct ieee80211_device *ieee)\n{\n\tieee->mgmt_queue_tail = ieee->mgmt_queue_head = 0;\n}\n\nstatic u8 MgntQuery_MgntFrameTxRate(struct ieee80211_device *ieee)\n{\n\tPRT_HIGH_THROUGHPUT      pHTInfo = ieee->pHTInfo;\n\tu8 rate;\n\n\t \n\tif (pHTInfo->IOTAction & HT_IOT_ACT_MGNT_USE_CCK_6M)\n\t\trate = 0x0c;\n\telse\n\t\trate = ieee->basic_rate & 0x7f;\n\n\tif (rate == 0) {\n\t\t \n\t\tif (ieee->mode == IEEE_A ||\n\t\t    ieee->mode == IEEE_N_5G ||\n\t\t    (ieee->mode == IEEE_N_24G && !pHTInfo->bCurSuppCCK))\n\t\t\trate = 0x0c;\n\t\telse\n\t\t\trate = 0x02;\n\t}\n\n\t \n\treturn rate;\n}\n\nvoid ieee80211_sta_wakeup(struct ieee80211_device *ieee, short nl);\n\ninline void softmac_mgmt_xmit(struct sk_buff *skb, struct ieee80211_device *ieee)\n{\n\tunsigned long flags;\n\tshort single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;\n\tstruct rtl_80211_hdr_3addr  *header =\n\t\t(struct rtl_80211_hdr_3addr  *)skb->data;\n\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\t \n\tieee80211_sta_wakeup(ieee, 0);\n\n\ttcb_desc->queue_index = MGNT_QUEUE;\n\ttcb_desc->data_rate = MgntQuery_MgntFrameTxRate(ieee);\n\ttcb_desc->RATRIndex = 7;\n\ttcb_desc->bTxDisableRateFallBack = 1;\n\ttcb_desc->bTxUseDriverAssingedRate = 1;\n\n\tif (single) {\n\t\tif (ieee->queue_stop) {\n\t\t\tenqueue_mgmt(ieee, skb);\n\t\t} else {\n\t\t\theader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\n\n\t\t\tif (ieee->seq_ctrl[0] == 0xFFF)\n\t\t\t\tieee->seq_ctrl[0] = 0;\n\t\t\telse\n\t\t\t\tieee->seq_ctrl[0]++;\n\n\t\t\t \n\t\t\tnetif_trans_update(ieee->dev);\n\t\t\tieee->softmac_data_hard_start_xmit(skb, ieee->dev, ieee->basic_rate);\n\t\t\t\n\t\t}\n\n\t\tspin_unlock_irqrestore(&ieee->lock, flags);\n\t} else {\n\t\tspin_unlock_irqrestore(&ieee->lock, flags);\n\t\tspin_lock_irqsave(&ieee->mgmt_tx_lock, flags);\n\n\t\theader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\n\n\t\tif (ieee->seq_ctrl[0] == 0xFFF)\n\t\t\tieee->seq_ctrl[0] = 0;\n\t\telse\n\t\t\tieee->seq_ctrl[0]++;\n\n\t\t \n\t\tif (!ieee->check_nic_enough_desc(ieee->dev, tcb_desc->queue_index) || \\\n\t\t    (skb_queue_len(&ieee->skb_waitQ[tcb_desc->queue_index]) != 0) || \\\n\t\t    (ieee->queue_stop)) {\n\t\t\t \n\t\t\t \n\t\t\tprintk(\"%s():insert to waitqueue!\\n\", __func__);\n\t\t\tskb_queue_tail(&ieee->skb_waitQ[tcb_desc->queue_index], skb);\n\t\t} else {\n\t\t\tieee->softmac_hard_start_xmit(skb, ieee->dev);\n\t\t\t\n\t\t}\n\t\tspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags);\n\t}\n}\n\nstatic inline void\nsoftmac_ps_mgmt_xmit(struct sk_buff *skb, struct ieee80211_device *ieee)\n{\n\tshort single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;\n\tstruct rtl_80211_hdr_3addr  *header =\n\t\t(struct rtl_80211_hdr_3addr  *)skb->data;\n\n\tif (single) {\n\t\theader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\n\n\t\tif (ieee->seq_ctrl[0] == 0xFFF)\n\t\t\tieee->seq_ctrl[0] = 0;\n\t\telse\n\t\t\tieee->seq_ctrl[0]++;\n\n\t\t \n\t\tnetif_trans_update(ieee->dev);\n\t\tieee->softmac_data_hard_start_xmit(skb, ieee->dev, ieee->basic_rate);\n\t} else {\n\t\theader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\n\n\t\tif (ieee->seq_ctrl[0] == 0xFFF)\n\t\t\tieee->seq_ctrl[0] = 0;\n\t\telse\n\t\t\tieee->seq_ctrl[0]++;\n\n\t\tieee->softmac_hard_start_xmit(skb, ieee->dev);\n\t}\n\t\n}\n\nstatic inline struct sk_buff *ieee80211_probe_req(struct ieee80211_device *ieee)\n{\n\tunsigned int len, rate_len;\n\tu8 *tag;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_probe_request *req;\n\n\tlen = ieee->current_network.ssid_len;\n\n\trate_len = ieee80211_MFIE_rate_len(ieee);\n\n\tskb = dev_alloc_skb(sizeof(struct ieee80211_probe_request) +\n\t\t\t    2 + len + rate_len + ieee->tx_headroom);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\treq = skb_put(skb, sizeof(struct ieee80211_probe_request));\n\treq->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_REQ);\n\treq->header.duration_id = 0;  \n\n\teth_broadcast_addr(req->header.addr1);\n\tmemcpy(req->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\n\teth_broadcast_addr(req->header.addr3);\n\n\ttag = skb_put(skb, len + 2 + rate_len);\n\n\t*tag++ = MFIE_TYPE_SSID;\n\t*tag++ = len;\n\tmemcpy(tag, ieee->current_network.ssid, len);\n\ttag += len;\n\n\tieee80211_MFIE_Brate(ieee, &tag);\n\tieee80211_MFIE_Grate(ieee, &tag);\n\treturn skb;\n}\n\nstruct sk_buff *ieee80211_get_beacon_(struct ieee80211_device *ieee);\n\nstatic void ieee80211_send_beacon(struct ieee80211_device *ieee)\n{\n\tstruct sk_buff *skb;\n\n\tif (!ieee->ieee_up)\n\t\treturn;\n\t\n\tskb = ieee80211_get_beacon_(ieee);\n\n\tif (skb) {\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\tieee->softmac_stats.tx_beacons++;\n\t\t\n\t}\n\n\n\n\t\n\tif (ieee->beacon_txing && ieee->ieee_up) {\n\n\n\t\tmod_timer(&ieee->beacon_timer,\n\t\t\t  jiffies + msecs_to_jiffies(ieee->current_network.beacon_interval - 5));\n\t}\n\t\n}\n\nstatic void ieee80211_send_beacon_cb(struct timer_list *t)\n{\n\tstruct ieee80211_device *ieee =\n\t\tfrom_timer(ieee, t, beacon_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ieee->beacon_lock, flags);\n\tieee80211_send_beacon(ieee);\n\tspin_unlock_irqrestore(&ieee->beacon_lock, flags);\n}\n\nstatic void ieee80211_send_probe(struct ieee80211_device *ieee)\n{\n\tstruct sk_buff *skb;\n\n\tskb = ieee80211_probe_req(ieee);\n\tif (skb) {\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\tieee->softmac_stats.tx_probe_rq++;\n\t\t\n\t}\n}\n\nstatic void ieee80211_send_probe_requests(struct ieee80211_device *ieee)\n{\n\tif (ieee->active_scan && (ieee->softmac_features & IEEE_SOFTMAC_PROBERQ)) {\n\t\tieee80211_send_probe(ieee);\n\t\tieee80211_send_probe(ieee);\n\t}\n}\n\n \nvoid ieee80211_softmac_scan_syncro(struct ieee80211_device *ieee)\n{\n\tshort ch = 0;\n\tu8 channel_map[MAX_CHANNEL_NUMBER + 1];\n\n\tmemcpy(channel_map, GET_DOT11D_INFO(ieee)->channel_map, MAX_CHANNEL_NUMBER + 1);\n\tmutex_lock(&ieee->scan_mutex);\n\n\twhile (1) {\n\t\tdo {\n\t\t\tch++;\n\t\t\tif (ch > MAX_CHANNEL_NUMBER)\n\t\t\t\tgoto out;  \n\t\t} while (!channel_map[ch]);\n\n\t\t \n\n\t\tif (ieee->state == IEEE80211_LINKED)\n\t\t\tgoto out;\n\t\tieee->set_chan(ieee->dev, ch);\n\t\tif (channel_map[ch] == 1)\n\t\t\tieee80211_send_probe_requests(ieee);\n\n\t\t \n\t\tif (ieee->state >= IEEE80211_LINKED && ieee->sync_scan_hurryup)\n\t\t\tgoto out;\n\n\t\tmsleep_interruptible(IEEE80211_SOFTMAC_SCAN_TIME);\n\t}\nout:\n\tif (ieee->state < IEEE80211_LINKED) {\n\t\tieee->actscanning = false;\n\t\tmutex_unlock(&ieee->scan_mutex);\n\t} else {\n\t\tieee->sync_scan_hurryup = 0;\n\t\tif (IS_DOT11D_ENABLE(ieee))\n\t\t\tdot11d_scan_complete(ieee);\n\t\tmutex_unlock(&ieee->scan_mutex);\n\t}\n}\nEXPORT_SYMBOL(ieee80211_softmac_scan_syncro);\n\nstatic void ieee80211_softmac_scan_wq(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, softmac_scan_wq);\n\tstatic short watchdog;\n\tu8 channel_map[MAX_CHANNEL_NUMBER + 1];\n\n\tmemcpy(channel_map, GET_DOT11D_INFO(ieee)->channel_map, MAX_CHANNEL_NUMBER + 1);\n\tif (!ieee->ieee_up)\n\t\treturn;\n\tmutex_lock(&ieee->scan_mutex);\n\tdo {\n\t\tieee->current_network.channel =\n\t\t\t(ieee->current_network.channel + 1) % MAX_CHANNEL_NUMBER;\n\t\tif (watchdog++ > MAX_CHANNEL_NUMBER) {\n\t\t\n\t\t\tif (!channel_map[ieee->current_network.channel]) {\n\t\t\t\tieee->current_network.channel = 6;\n\t\t\t\tgoto out;  \n\t\t\t}\n\t\t}\n\t} while (!channel_map[ieee->current_network.channel]);\n\tif (ieee->scanning == 0)\n\t\tgoto out;\n\tieee->set_chan(ieee->dev, ieee->current_network.channel);\n\tif (channel_map[ieee->current_network.channel] == 1)\n\t\tieee80211_send_probe_requests(ieee);\n\n\tschedule_delayed_work(&ieee->softmac_scan_wq, IEEE80211_SOFTMAC_SCAN_TIME);\n\n\tmutex_unlock(&ieee->scan_mutex);\n\treturn;\nout:\n\tif (IS_DOT11D_ENABLE(ieee))\n\t\tdot11d_scan_complete(ieee);\n\tieee->actscanning = false;\n\twatchdog = 0;\n\tieee->scanning = 0;\n\tmutex_unlock(&ieee->scan_mutex);\n}\n\nstatic void ieee80211_beacons_start(struct ieee80211_device *ieee)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&ieee->beacon_lock, flags);\n\n\tieee->beacon_txing = 1;\n\tieee80211_send_beacon(ieee);\n\n\tspin_unlock_irqrestore(&ieee->beacon_lock, flags);\n}\n\nstatic void ieee80211_beacons_stop(struct ieee80211_device *ieee)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ieee->beacon_lock, flags);\n\n\tieee->beacon_txing = 0;\n\n\tspin_unlock_irqrestore(&ieee->beacon_lock, flags);\n\tdel_timer_sync(&ieee->beacon_timer);\n}\n\nvoid ieee80211_stop_send_beacons(struct ieee80211_device *ieee)\n{\n\tif (ieee->stop_send_beacons)\n\t\tieee->stop_send_beacons(ieee->dev);\n\tif (ieee->softmac_features & IEEE_SOFTMAC_BEACONS)\n\t\tieee80211_beacons_stop(ieee);\n}\nEXPORT_SYMBOL(ieee80211_stop_send_beacons);\n\nvoid ieee80211_start_send_beacons(struct ieee80211_device *ieee)\n{\n\tif (ieee->start_send_beacons)\n\t\tieee->start_send_beacons(ieee->dev, ieee->basic_rate);\n\tif (ieee->softmac_features & IEEE_SOFTMAC_BEACONS)\n\t\tieee80211_beacons_start(ieee);\n}\nEXPORT_SYMBOL(ieee80211_start_send_beacons);\n\nstatic void ieee80211_softmac_stop_scan(struct ieee80211_device *ieee)\n{\n\n\n\t\n\n\tmutex_lock(&ieee->scan_mutex);\n\n\n\tif (ieee->scanning == 1) {\n\t\tieee->scanning = 0;\n\n\t\tcancel_delayed_work(&ieee->softmac_scan_wq);\n\t}\n\n\n\tmutex_unlock(&ieee->scan_mutex);\n}\n\nvoid ieee80211_stop_scan(struct ieee80211_device *ieee)\n{\n\tif (ieee->softmac_features & IEEE_SOFTMAC_SCAN)\n\t\tieee80211_softmac_stop_scan(ieee);\n\telse\n\t\tieee->stop_scan(ieee->dev);\n}\nEXPORT_SYMBOL(ieee80211_stop_scan);\n\n \nstatic void ieee80211_start_scan(struct ieee80211_device *ieee)\n{\n\tif (IS_DOT11D_ENABLE(ieee)) {\n\t\tif (IS_COUNTRY_IE_VALID(ieee))\n\t\t\tRESET_CIE_WATCHDOG(ieee);\n\t}\n\tif (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {\n\t\tif (ieee->scanning == 0) {\n\t\t\tieee->scanning = 1;\n\t\t\tschedule_delayed_work(&ieee->softmac_scan_wq, 0);\n\t\t}\n\t} else {\n\t\tieee->start_scan(ieee->dev);\n\t}\n}\n\n \nvoid ieee80211_start_scan_syncro(struct ieee80211_device *ieee)\n{\n\tif (IS_DOT11D_ENABLE(ieee)) {\n\t\tif (IS_COUNTRY_IE_VALID(ieee))\n\t\t\tRESET_CIE_WATCHDOG(ieee);\n\t}\n\tieee->sync_scan_hurryup = 0;\n\tif (ieee->softmac_features & IEEE_SOFTMAC_SCAN)\n\t\tieee80211_softmac_scan_syncro(ieee);\n\telse\n\t\tieee->scan_syncro(ieee->dev);\n}\nEXPORT_SYMBOL(ieee80211_start_scan_syncro);\n\nstatic inline struct sk_buff *\nieee80211_authentication_req(struct ieee80211_network *beacon,\n\t\t\t     struct ieee80211_device *ieee, int challengelen)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_authentication *auth;\n\tint len = sizeof(struct ieee80211_authentication) + challengelen + ieee->tx_headroom;\n\n\tskb = dev_alloc_skb(len);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\tauth = skb_put(skb, sizeof(struct ieee80211_authentication));\n\n\tif (challengelen)\n\t\tauth->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_AUTH\n\t\t\t\t\t\t     | IEEE80211_FCTL_WEP);\n\telse\n\t\tauth->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_AUTH);\n\n\tauth->header.duration_id = cpu_to_le16(0x013a);\n\n\tmemcpy(auth->header.addr1, beacon->bssid, ETH_ALEN);\n\tmemcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\n\tmemcpy(auth->header.addr3, beacon->bssid, ETH_ALEN);\n\n\t\n\tif (ieee->auth_mode == 0)\n\t\tauth->algorithm = WLAN_AUTH_OPEN;\n\telse if (ieee->auth_mode == 1)\n\t\tauth->algorithm = cpu_to_le16(WLAN_AUTH_SHARED_KEY);\n\telse if (ieee->auth_mode == 2)\n\t\tauth->algorithm = WLAN_AUTH_OPEN;  \n\tprintk(\"=================>%s():auth->algorithm is %d\\n\", __func__, auth->algorithm);\n\tauth->transaction = cpu_to_le16(ieee->associate_seq);\n\tieee->associate_seq++;\n\n\tauth->status = cpu_to_le16(WLAN_STATUS_SUCCESS);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *ieee80211_probe_resp(struct ieee80211_device *ieee, u8 *dest)\n{\n\tu8 *tag;\n\tint beacon_size;\n\tstruct ieee80211_probe_response *beacon_buf;\n\tstruct sk_buff *skb = NULL;\n\tint encrypt;\n\tint atim_len, erp_len;\n\tstruct ieee80211_crypt_data *crypt;\n\n\tchar *ssid = ieee->current_network.ssid;\n\tint ssid_len = ieee->current_network.ssid_len;\n\tint rate_len = ieee->current_network.rates_len + 2;\n\tint rate_ex_len = ieee->current_network.rates_ex_len;\n\tint wpa_ie_len = ieee->wpa_ie_len;\n\tu8 erpinfo_content = 0;\n\n\tu8 *tmp_ht_cap_buf;\n\tu8 tmp_ht_cap_len = 0;\n\tu8 *tmp_ht_info_buf;\n\tu8 tmp_ht_info_len = 0;\n\tPRT_HIGH_THROUGHPUT\tpHTInfo = ieee->pHTInfo;\n\tu8 *tmp_generic_ie_buf = NULL;\n\tu8 tmp_generic_ie_len = 0;\n\n\tif (rate_ex_len > 0)\n\t\trate_ex_len += 2;\n\n\tif (ieee->current_network.capability & WLAN_CAPABILITY_IBSS)\n\t\tatim_len = 4;\n\telse\n\t\tatim_len = 0;\n\n\tif (ieee80211_is_54g(&ieee->current_network))\n\t\terp_len = 3;\n\telse\n\t\terp_len = 0;\n\n\tcrypt = ieee->crypt[ieee->tx_keyidx];\n\n\tencrypt = ieee->host_encrypt && crypt && crypt->ops &&\n\t\t((0 == strcmp(crypt->ops->name, \"WEP\") || wpa_ie_len));\n\t \n\ttmp_ht_cap_buf = (u8 *)&ieee->pHTInfo->SelfHTCap;\n\ttmp_ht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);\n\ttmp_ht_info_buf = (u8 *)&ieee->pHTInfo->SelfHTInfo;\n\ttmp_ht_info_len = sizeof(ieee->pHTInfo->SelfHTInfo);\n\tHTConstructCapabilityElement(ieee, tmp_ht_cap_buf, &tmp_ht_cap_len, encrypt);\n\tHTConstructInfoElement(ieee, tmp_ht_info_buf, &tmp_ht_info_len, encrypt);\n\n\tif (pHTInfo->bRegRT2RTAggregation) {\n\t\ttmp_generic_ie_buf = ieee->pHTInfo->szRT2RTAggBuffer;\n\t\ttmp_generic_ie_len = sizeof(ieee->pHTInfo->szRT2RTAggBuffer);\n\t\tHTConstructRT2RTAggElement(ieee, tmp_generic_ie_buf, &tmp_generic_ie_len);\n\t}\n\n\tbeacon_size = sizeof(struct ieee80211_probe_response) + 2\n\t\t+ ssid_len\n\t\t+ 3 \n\t\t+ rate_len\n\t\t+ rate_ex_len\n\t\t+ atim_len\n\t\t+ erp_len\n\t\t+ wpa_ie_len\n\t\n\t\n\t\n\n\t\t+ ieee->tx_headroom;\n\tskb = dev_alloc_skb(beacon_size);\n\tif (!skb)\n\t\treturn NULL;\n\tskb_reserve(skb, ieee->tx_headroom);\n\tbeacon_buf = skb_put(skb, (beacon_size - ieee->tx_headroom));\n\tmemcpy(beacon_buf->header.addr1, dest, ETH_ALEN);\n\tmemcpy(beacon_buf->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\n\tmemcpy(beacon_buf->header.addr3, ieee->current_network.bssid, ETH_ALEN);\n\n\tbeacon_buf->header.duration_id = 0;  \n\tbeacon_buf->beacon_interval =\n\t\tcpu_to_le16(ieee->current_network.beacon_interval);\n\tbeacon_buf->capability =\n\t\tcpu_to_le16(ieee->current_network.capability & WLAN_CAPABILITY_IBSS);\n\tbeacon_buf->capability |=\n\t\tcpu_to_le16(ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE);  \n\n\tif (ieee->short_slot && (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_SLOT))\n\t\tbeacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);\n\n\tif (encrypt)\n\t\tbeacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\n\n\tbeacon_buf->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_RESP);\n\tbeacon_buf->info_element[0].id = MFIE_TYPE_SSID;\n\tbeacon_buf->info_element[0].len = ssid_len;\n\n\ttag = (u8 *)beacon_buf->info_element[0].data;\n\n\tmemcpy(tag, ssid, ssid_len);\n\n\ttag += ssid_len;\n\n\t*(tag++) = MFIE_TYPE_RATES;\n\t*(tag++) = rate_len - 2;\n\tmemcpy(tag, ieee->current_network.rates, rate_len - 2);\n\ttag += rate_len - 2;\n\n\t*(tag++) = MFIE_TYPE_DS_SET;\n\t*(tag++) = 1;\n\t*(tag++) = ieee->current_network.channel;\n\n\tif (atim_len) {\n\t\t*(tag++) = MFIE_TYPE_IBSS_SET;\n\t\t*(tag++) = 2;\n\n\t\tput_unaligned_le16(ieee->current_network.atim_window,\n\t\t\t\t   tag);\n\t\ttag += 2;\n\t}\n\n\tif (erp_len) {\n\t\t*(tag++) = MFIE_TYPE_ERP;\n\t\t*(tag++) = 1;\n\t\t*(tag++) = erpinfo_content;\n\t}\n\tif (rate_ex_len) {\n\t\t*(tag++) = MFIE_TYPE_RATES_EX;\n\t\t*(tag++) = rate_ex_len - 2;\n\t\tmemcpy(tag, ieee->current_network.rates_ex, rate_ex_len - 2);\n\t\ttag += rate_ex_len - 2;\n\t}\n\n\tif (wpa_ie_len) {\n\t\tif (ieee->iw_mode == IW_MODE_ADHOC) {\n\t\t\t\n\t\t\tmemcpy(&ieee->wpa_ie[14], &ieee->wpa_ie[8], 4);\n\t\t}\n\t\tmemcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);\n\t\ttag += wpa_ie_len;\n\t}\n\n\t\n\treturn skb;\n}\n\nstatic struct sk_buff *ieee80211_assoc_resp(struct ieee80211_device *ieee,\n\t\t\t\t\t    u8 *dest)\n{\n\tstruct sk_buff *skb;\n\tu8 *tag;\n\n\tstruct ieee80211_crypt_data *crypt;\n\tstruct ieee80211_assoc_response_frame *assoc;\n\tshort encrypt;\n\n\tunsigned int rate_len = ieee80211_MFIE_rate_len(ieee);\n\tint len = sizeof(struct ieee80211_assoc_response_frame) + rate_len + ieee->tx_headroom;\n\n\tskb = dev_alloc_skb(len);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\tassoc = skb_put(skb, sizeof(struct ieee80211_assoc_response_frame));\n\n\tassoc->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_ASSOC_RESP);\n\tmemcpy(assoc->header.addr1, dest, ETH_ALEN);\n\tmemcpy(assoc->header.addr3, ieee->dev->dev_addr, ETH_ALEN);\n\tmemcpy(assoc->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\n\tassoc->capability = cpu_to_le16(ieee->iw_mode == IW_MODE_MASTER ?\n\t\tWLAN_CAPABILITY_BSS : WLAN_CAPABILITY_IBSS);\n\n\tif (ieee->short_slot)\n\t\tassoc->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);\n\n\tif (ieee->host_encrypt)\n\t\tcrypt = ieee->crypt[ieee->tx_keyidx];\n\telse\n\t\tcrypt = NULL;\n\n\tencrypt = crypt && crypt->ops;\n\n\tif (encrypt)\n\t\tassoc->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\n\n\tassoc->status = 0;\n\tassoc->aid = cpu_to_le16(ieee->assoc_id);\n\tif (ieee->assoc_id == 0x2007)\n\t\tieee->assoc_id = 0;\n\telse\n\t\tieee->assoc_id++;\n\n\ttag = skb_put(skb, rate_len);\n\n\tieee80211_MFIE_Brate(ieee, &tag);\n\tieee80211_MFIE_Grate(ieee, &tag);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *ieee80211_auth_resp(struct ieee80211_device *ieee,\n\t\t\t\t\t   int status, u8 *dest)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_authentication *auth;\n\tint len = ieee->tx_headroom + sizeof(struct ieee80211_authentication) + 1;\n\n\tskb = dev_alloc_skb(len);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb->len = sizeof(struct ieee80211_authentication);\n\n\tauth = (struct ieee80211_authentication *)skb->data;\n\n\tauth->status = cpu_to_le16(status);\n\tauth->transaction = cpu_to_le16(2);\n\tauth->algorithm = cpu_to_le16(WLAN_AUTH_OPEN);\n\n\tmemcpy(auth->header.addr3, ieee->dev->dev_addr, ETH_ALEN);\n\tmemcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\n\tmemcpy(auth->header.addr1, dest, ETH_ALEN);\n\tauth->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_AUTH);\n\treturn skb;\n}\n\nstatic struct sk_buff *ieee80211_null_func(struct ieee80211_device *ieee,\n\t\t\t\t\t   short pwr)\n{\n\tstruct sk_buff *skb;\n\tstruct rtl_80211_hdr_3addr *hdr;\n\n\tskb = dev_alloc_skb(sizeof(struct rtl_80211_hdr_3addr));\n\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = skb_put(skb, sizeof(struct rtl_80211_hdr_3addr));\n\n\tmemcpy(hdr->addr1, ieee->current_network.bssid, ETH_ALEN);\n\tmemcpy(hdr->addr2, ieee->dev->dev_addr, ETH_ALEN);\n\tmemcpy(hdr->addr3, ieee->current_network.bssid, ETH_ALEN);\n\n\thdr->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t     IEEE80211_STYPE_NULLFUNC | IEEE80211_FCTL_TODS |\n\t\t\t\t     (pwr ? IEEE80211_FCTL_PM : 0));\n\n\treturn skb;\n}\n\nstatic void ieee80211_resp_to_assoc_rq(struct ieee80211_device *ieee, u8 *dest)\n{\n\tstruct sk_buff *buf = ieee80211_assoc_resp(ieee, dest);\n\n\tif (buf)\n\t\tsoftmac_mgmt_xmit(buf, ieee);\n}\n\nstatic void ieee80211_resp_to_auth(struct ieee80211_device *ieee, int s,\n\t\t\t\t   u8 *dest)\n{\n\tstruct sk_buff *buf = ieee80211_auth_resp(ieee, s, dest);\n\n\tif (buf)\n\t\tsoftmac_mgmt_xmit(buf, ieee);\n}\n\nstatic void ieee80211_resp_to_probe(struct ieee80211_device *ieee, u8 *dest)\n{\n\tstruct sk_buff *buf = ieee80211_probe_resp(ieee, dest);\n\tif (buf)\n\t\tsoftmac_mgmt_xmit(buf, ieee);\n}\n\nstatic inline struct sk_buff *\nieee80211_association_req(struct ieee80211_network *beacon,\n\t\t\t  struct ieee80211_device *ieee)\n{\n\tstruct sk_buff *skb;\n\t\n\n\tstruct ieee80211_assoc_request_frame *hdr;\n\tu8 *tag;\n\t\n\t\n\t\n\t\n\t\n\t\n\tu8 *ht_cap_buf = NULL;\n\tu8 ht_cap_len = 0;\n\tu8 *realtek_ie_buf = NULL;\n\tu8 realtek_ie_len = 0;\n\tint wpa_ie_len = ieee->wpa_ie_len;\n\tunsigned int ckip_ie_len = 0;\n\tunsigned int ccxrm_ie_len = 0;\n\tunsigned int cxvernum_ie_len = 0;\n\tstruct ieee80211_crypt_data *crypt;\n\tint encrypt;\n\n\tunsigned int rate_len = ieee80211_MFIE_rate_len(ieee);\n\tunsigned int wmm_info_len = beacon->qos_data.supported ? 9 : 0;\n#ifdef THOMAS_TURBO\n\tunsigned int turbo_info_len = beacon->Turbo_Enable ? 9 : 0;\n#endif\n\n\tint len = 0;\n\n\tcrypt = ieee->crypt[ieee->tx_keyidx];\n\tencrypt = ieee->host_encrypt && crypt && crypt->ops && ((0 == strcmp(crypt->ops->name, \"WEP\") || wpa_ie_len));\n\n\t \n\tif (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {\n\t\tht_cap_buf = (u8 *)&ieee->pHTInfo->SelfHTCap;\n\t\tht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);\n\t\tHTConstructCapabilityElement(ieee, ht_cap_buf, &ht_cap_len, encrypt);\n\t\tif (ieee->pHTInfo->bCurrentRT2RTAggregation) {\n\t\t\trealtek_ie_buf = ieee->pHTInfo->szRT2RTAggBuffer;\n\t\t\trealtek_ie_len = sizeof(ieee->pHTInfo->szRT2RTAggBuffer);\n\t\t\tHTConstructRT2RTAggElement(ieee, realtek_ie_buf, &realtek_ie_len);\n\t\t}\n\t}\n\tif (ieee->qos_support)\n\t\twmm_info_len = beacon->qos_data.supported ? 9 : 0;\n\n\tif (beacon->bCkipSupported)\n\t\tckip_ie_len = 30 + 2;\n\n\tif (beacon->bCcxRmEnable)\n\t\tccxrm_ie_len = 6 + 2;\n\n\tif (beacon->BssCcxVerNumber >= 2)\n\t\tcxvernum_ie_len = 5 + 2;\n\n#ifdef THOMAS_TURBO\n\tlen = sizeof(struct ieee80211_assoc_request_frame) + 2\n\t\t+ beacon->ssid_len\t \n\t\t+ rate_len\t \n\t\t+ wpa_ie_len\n\t\t+ wmm_info_len\n\t\t+ turbo_info_len\n\t\t+ ht_cap_len\n\t\t+ realtek_ie_len\n\t\t+ ckip_ie_len\n\t\t+ ccxrm_ie_len\n\t\t+ cxvernum_ie_len\n\t\t+ ieee->tx_headroom;\n#else\n\tlen = sizeof(struct ieee80211_assoc_request_frame) + 2\n\t\t+ beacon->ssid_len\t \n\t\t+ rate_len\t \n\t\t+ wpa_ie_len\n\t\t+ wmm_info_len\n\t\t+ ht_cap_len\n\t\t+ realtek_ie_len\n\t\t+ ckip_ie_len\n\t\t+ ccxrm_ie_len\n\t\t+ cxvernum_ie_len\n\t\t+ ieee->tx_headroom;\n#endif\n\tskb = dev_alloc_skb(len);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\thdr = skb_put(skb, sizeof(struct ieee80211_assoc_request_frame) + 2);\n\n\thdr->header.frame_ctl = IEEE80211_STYPE_ASSOC_REQ;\n\thdr->header.duration_id = cpu_to_le16(37);\n\tmemcpy(hdr->header.addr1, beacon->bssid, ETH_ALEN);\n\tmemcpy(hdr->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\n\tmemcpy(hdr->header.addr3, beacon->bssid, ETH_ALEN);\n\n\tmemcpy(ieee->ap_mac_addr, beacon->bssid, ETH_ALEN);\n\n\thdr->capability = cpu_to_le16(WLAN_CAPABILITY_BSS);\n\tif (beacon->capability & WLAN_CAPABILITY_PRIVACY)\n\t\thdr->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\n\n\tif (beacon->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\n\t\thdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE); \n\n\tif (ieee->short_slot)\n\t\thdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);\n\tif (wmm_info_len) \n\t\thdr->capability |= cpu_to_le16(WLAN_CAPABILITY_QOS);\n\n\thdr->listen_interval = cpu_to_le16(0xa);\n\n\thdr->info_element[0].id = MFIE_TYPE_SSID;\n\n\thdr->info_element[0].len = beacon->ssid_len;\n\tskb_put_data(skb, beacon->ssid, beacon->ssid_len);\n\n\ttag = skb_put(skb, rate_len);\n\n\tieee80211_MFIE_Brate(ieee, &tag);\n\tieee80211_MFIE_Grate(ieee, &tag);\n\t\n\tif (beacon->bCkipSupported) {\n\t\tstatic u8\tAironetIeOui[] = {0x00, 0x01, 0x66}; \n\t\tu8\tCcxAironetBuf[30];\n\t\tstruct octet_string\tosCcxAironetIE;\n\n\t\tmemset(CcxAironetBuf, 0, 30);\n\t\tosCcxAironetIE.octet = CcxAironetBuf;\n\t\tosCcxAironetIE.length = sizeof(CcxAironetBuf);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tmemcpy(osCcxAironetIE.octet, AironetIeOui, sizeof(AironetIeOui));\n\n\t\t\n\t\t\n\t\t\n\t\tosCcxAironetIE.octet[IE_CISCO_FLAG_POSITION] |= (SUPPORT_CKIP_PK | SUPPORT_CKIP_MIC);\n\t\ttag = skb_put(skb, ckip_ie_len);\n\t\t*tag++ = MFIE_TYPE_AIRONET;\n\t\t*tag++ = osCcxAironetIE.length;\n\t\tmemcpy(tag, osCcxAironetIE.octet, osCcxAironetIE.length);\n\t\ttag += osCcxAironetIE.length;\n\t}\n\n\tif (beacon->bCcxRmEnable) {\n\t\tstatic u8 CcxRmCapBuf[] = {0x00, 0x40, 0x96, 0x01, 0x01, 0x00};\n\t\tstruct octet_string osCcxRmCap;\n\n\t\tosCcxRmCap.octet = CcxRmCapBuf;\n\t\tosCcxRmCap.length = sizeof(CcxRmCapBuf);\n\t\ttag = skb_put(skb, ccxrm_ie_len);\n\t\t*tag++ = MFIE_TYPE_GENERIC;\n\t\t*tag++ = osCcxRmCap.length;\n\t\tmemcpy(tag, osCcxRmCap.octet, osCcxRmCap.length);\n\t\ttag += osCcxRmCap.length;\n\t}\n\n\tif (beacon->BssCcxVerNumber >= 2) {\n\t\tu8\t\t\tCcxVerNumBuf[] = {0x00, 0x40, 0x96, 0x03, 0x00};\n\t\tstruct octet_string\tosCcxVerNum;\n\t\tCcxVerNumBuf[4] = beacon->BssCcxVerNumber;\n\t\tosCcxVerNum.octet = CcxVerNumBuf;\n\t\tosCcxVerNum.length = sizeof(CcxVerNumBuf);\n\t\ttag = skb_put(skb, cxvernum_ie_len);\n\t\t*tag++ = MFIE_TYPE_GENERIC;\n\t\t*tag++ = osCcxVerNum.length;\n\t\tmemcpy(tag, osCcxVerNum.octet, osCcxVerNum.length);\n\t\ttag += osCcxVerNum.length;\n\t}\n\t\n\tif (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {\n\t\tif (ieee->pHTInfo->ePeerHTSpecVer != HT_SPEC_VER_EWC) {\n\t\t\ttag = skb_put(skb, ht_cap_len);\n\t\t\t*tag++ = MFIE_TYPE_HT_CAP;\n\t\t\t*tag++ = ht_cap_len - 2;\n\t\t\tmemcpy(tag, ht_cap_buf, ht_cap_len - 2);\n\t\t\ttag += ht_cap_len - 2;\n\t\t}\n\t}\n\n\t\n\tif (wpa_ie_len)\n\t\tskb_put_data(skb, ieee->wpa_ie, wpa_ie_len);\n\n\tif (wmm_info_len) {\n\t\ttag = skb_put(skb, wmm_info_len);\n\t\tieee80211_WMM_Info(ieee, &tag);\n\t}\n#ifdef THOMAS_TURBO\n\tif (turbo_info_len) {\n\t\ttag = skb_put(skb, turbo_info_len);\n\t\tieee80211_TURBO_Info(ieee, &tag);\n\t}\n#endif\n\n\tif (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {\n\t\tif (ieee->pHTInfo->ePeerHTSpecVer == HT_SPEC_VER_EWC) {\n\t\t\ttag = skb_put(skb, ht_cap_len);\n\t\t\t*tag++ = MFIE_TYPE_GENERIC;\n\t\t\t*tag++ = ht_cap_len - 2;\n\t\t\tmemcpy(tag, ht_cap_buf, ht_cap_len - 2);\n\t\t\ttag += ht_cap_len - 2;\n\t\t}\n\n\t\tif (ieee->pHTInfo->bCurrentRT2RTAggregation) {\n\t\t\ttag = skb_put(skb, realtek_ie_len);\n\t\t\t*tag++ = MFIE_TYPE_GENERIC;\n\t\t\t*tag++ = realtek_ie_len - 2;\n\t\t\tmemcpy(tag, realtek_ie_buf, realtek_ie_len - 2);\n\t\t}\n\t}\n\n\n\treturn skb;\n}\n\nvoid ieee80211_associate_abort(struct ieee80211_device *ieee)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tieee->associate_seq++;\n\n\t \n\tif (ieee->state == IEEE80211_ASSOCIATING_AUTHENTICATING) {\n\t\tIEEE80211_DEBUG_MGMT(\"Authentication failed\\n\");\n\t\tieee->softmac_stats.no_auth_rs++;\n\t} else {\n\t\tIEEE80211_DEBUG_MGMT(\"Association failed\\n\");\n\t\tieee->softmac_stats.no_ass_rs++;\n\t}\n\n\tieee->state = IEEE80211_ASSOCIATING_RETRY;\n\n\tschedule_delayed_work(&ieee->associate_retry_wq, \\\n\t\t\t      IEEE80211_SOFTMAC_ASSOC_RETRY_TIME);\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\n\nstatic void ieee80211_associate_abort_cb(struct timer_list *t)\n{\n\tstruct ieee80211_device *dev = from_timer(dev, t, associate_timer);\n\n\tieee80211_associate_abort(dev);\n}\n\nstatic void ieee80211_associate_step1(struct ieee80211_device *ieee)\n{\n\tstruct ieee80211_network *beacon = &ieee->current_network;\n\tstruct sk_buff *skb;\n\n\tIEEE80211_DEBUG_MGMT(\"Stopping scan\\n\");\n\n\tieee->softmac_stats.tx_auth_rq++;\n\tskb = ieee80211_authentication_req(beacon, ieee, 0);\n\n\tif (!skb) {\n\t\tieee80211_associate_abort(ieee);\n\t} else {\n\t\tieee->state = IEEE80211_ASSOCIATING_AUTHENTICATING;\n\t\tIEEE80211_DEBUG_MGMT(\"Sending authentication request\\n\");\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\t\n\t\tif (!timer_pending(&ieee->associate_timer)) {\n\t\t\tieee->associate_timer.expires = jiffies + (HZ / 2);\n\t\t\tadd_timer(&ieee->associate_timer);\n\t\t}\n\t\t\n\t}\n}\n\nstatic void ieee80211_auth_challenge(struct ieee80211_device *ieee,\n\t\t\t\t     u8 *challenge,\n\t\t\t\t     int chlen)\n{\n\tu8 *c;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_network *beacon = &ieee->current_network;\n\n\n\tieee->associate_seq++;\n\tieee->softmac_stats.tx_auth_rq++;\n\n\tskb = ieee80211_authentication_req(beacon, ieee, chlen + 2);\n\tif (!skb) {\n\t\tieee80211_associate_abort(ieee);\n\t} else {\n\t\tc = skb_put(skb, chlen + 2);\n\t\t*(c++) = MFIE_TYPE_CHALLENGE;\n\t\t*(c++) = chlen;\n\t\tmemcpy(c, challenge, chlen);\n\n\t\tIEEE80211_DEBUG_MGMT(\"Sending authentication challenge response\\n\");\n\n\t\tieee80211_encrypt_fragment(ieee, skb, sizeof(struct rtl_80211_hdr_3addr));\n\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\tmod_timer(&ieee->associate_timer, jiffies + (HZ / 2));\n\t\t\n\t}\n\tkfree(challenge);\n}\n\nstatic void ieee80211_associate_step2(struct ieee80211_device *ieee)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_network *beacon = &ieee->current_network;\n\n\tdel_timer_sync(&ieee->associate_timer);\n\n\tIEEE80211_DEBUG_MGMT(\"Sending association request\\n\");\n\n\tieee->softmac_stats.tx_ass_rq++;\n\tskb = ieee80211_association_req(beacon, ieee);\n\tif (!skb) {\n\t\tieee80211_associate_abort(ieee);\n\t} else {\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\tmod_timer(&ieee->associate_timer, jiffies + (HZ / 2));\n\t\t\n\t}\n}\nstatic void ieee80211_associate_complete_wq(struct work_struct *work)\n{\n\tstruct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_complete_wq);\n\n\tnetdev_info(ieee->dev, \"Associated successfully\\n\");\n\tif (ieee80211_is_54g(&ieee->current_network) &&\n\t    (ieee->modulation & IEEE80211_OFDM_MODULATION)) {\n\t\tieee->rate = 108;\n\t\tnetdev_info(ieee->dev, \"Using G rates:%d\\n\", ieee->rate);\n\t} else {\n\t\tieee->rate = 22;\n\t\tnetdev_info(ieee->dev, \"Using B rates:%d\\n\", ieee->rate);\n\t}\n\tif (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {\n\t\tprintk(\"Successfully associated, ht enabled\\n\");\n\t\tHTOnAssocRsp(ieee);\n\t} else {\n\t\tprintk(\"Successfully associated, ht not enabled(%d, %d)\\n\", ieee->pHTInfo->bCurrentHTSupport, ieee->pHTInfo->bEnableHT);\n\t\tmemset(ieee->dot11HTOperationalRateSet, 0, 16);\n\t\t\n\t}\n\tieee->LinkDetectInfo.SlotNum = 2 * (1 + ieee->current_network.beacon_interval / 500);\n\t\n\tif (ieee->LinkDetectInfo.NumRecvBcnInPeriod == 0 || ieee->LinkDetectInfo.NumRecvDataInPeriod == 0) {\n\t\tieee->LinkDetectInfo.NumRecvBcnInPeriod = 1;\n\t\tieee->LinkDetectInfo.NumRecvDataInPeriod = 1;\n\t}\n\tieee->link_change(ieee->dev);\n\tif (!ieee->is_silent_reset) {\n\t\tprintk(\"============>normal associate\\n\");\n\t\tnotify_wx_assoc_event(ieee);\n\t} else {\n\t\tprintk(\"==================>silent reset associate\\n\");\n\t\tieee->is_silent_reset = false;\n\t}\n\n\tif (ieee->data_hard_resume)\n\t\tieee->data_hard_resume(ieee->dev);\n\tnetif_carrier_on(ieee->dev);\n}\n\nstatic void ieee80211_associate_complete(struct ieee80211_device *ieee)\n{\n\n\n\tdel_timer_sync(&ieee->associate_timer);\n\n\tieee->state = IEEE80211_LINKED;\n\t\n\tschedule_work(&ieee->associate_complete_wq);\n}\n\nstatic void ieee80211_associate_procedure_wq(struct work_struct *work)\n{\n\tstruct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_procedure_wq);\n\tieee->sync_scan_hurryup = 1;\n\tmutex_lock(&ieee->wx_mutex);\n\n\tif (ieee->data_hard_stop)\n\t\tieee->data_hard_stop(ieee->dev);\n\n\tieee80211_stop_scan(ieee);\n\tprintk(\"===>%s(), chan:%d\\n\", __func__, ieee->current_network.channel);\n\t\n\tHTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);\n\n\tieee->associate_seq = 1;\n\tieee80211_associate_step1(ieee);\n\n\tmutex_unlock(&ieee->wx_mutex);\n}\n\ninline void ieee80211_softmac_new_net(struct ieee80211_device *ieee, struct ieee80211_network *net)\n{\n\tu8 tmp_ssid[IW_ESSID_MAX_SIZE + 1];\n\tint tmp_ssid_len = 0;\n\n\tshort apset, ssidset, ssidbroad, apmatch, ssidmatch;\n\n\t \n\tif (ieee->state != IEEE80211_NOLINK)\n\t\treturn;\n\n\tif ((ieee->iw_mode == IW_MODE_INFRA) && !(net->capability & WLAN_CAPABILITY_BSS))\n\t\treturn;\n\n\tif ((ieee->iw_mode == IW_MODE_ADHOC) && !(net->capability & WLAN_CAPABILITY_IBSS))\n\t\treturn;\n\n\tif (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC) {\n\t\t \n\t\tapset = ieee->wap_set;\n\t\tssidset = ieee->ssid_set;\n\t\tssidbroad =  !(net->ssid_len == 0 || net->ssid[0] == '\\0');\n\t\tapmatch = (memcmp(ieee->current_network.bssid, net->bssid, ETH_ALEN) == 0);\n\t\tssidmatch = (ieee->current_network.ssid_len == net->ssid_len) &&\n\t\t\t(!strncmp(ieee->current_network.ssid, net->ssid, net->ssid_len));\n\n\t\t \n\t\tif ((apset && apmatch &&\n\t\t     ((ssidset && ssidbroad && ssidmatch) || (ssidbroad && !ssidset) || (!ssidbroad && ssidset))) ||\n\t\t     \n\t\t    (!apset && ssidset && ssidbroad && ssidmatch)) {\n\t\t\t \n\t\t\tif (!ssidbroad) {\n\t\t\t\tstrncpy(tmp_ssid, ieee->current_network.ssid, IW_ESSID_MAX_SIZE);\n\t\t\t\ttmp_ssid_len = ieee->current_network.ssid_len;\n\t\t\t}\n\t\t\tmemcpy(&ieee->current_network, net, sizeof(struct ieee80211_network));\n\n\t\t\tstrncpy(ieee->current_network.ssid, tmp_ssid, IW_ESSID_MAX_SIZE);\n\t\t\tieee->current_network.ssid_len = tmp_ssid_len;\n\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t    \"Linking with %s,channel:%d, qos:%d, myHT:%d, networkHT:%d\\n\",\n\t\t\t\t    ieee->current_network.ssid,\n\t\t\t\t    ieee->current_network.channel,\n\t\t\t\t    ieee->current_network.qos_data.supported,\n\t\t\t\t    ieee->pHTInfo->bEnableHT,\n\t\t\t\t    ieee->current_network.bssht.bdSupportHT);\n\n\t\t\t\n\t\t\tHTResetIOTSetting(ieee->pHTInfo);\n\t\t\tif (ieee->iw_mode == IW_MODE_INFRA) {\n\t\t\t\t \n\t\t\t\tieee->AsocRetryCount = 0;\n\t\t\t\t\n\t\t\t\tif ((ieee->current_network.qos_data.supported == 1) &&\n\t\t\t\t    \n\t\t\t\t    ieee->current_network.bssht.bdSupportHT) {\n \n\t\t\t\t\t\n\t\t\t\t\tHTResetSelfAndSavePeerSetting(ieee, &ieee->current_network);\n\t\t\t\t} else {\n\t\t\t\t\tieee->pHTInfo->bCurrentHTSupport = false;\n\t\t\t\t}\n\n\t\t\t\tieee->state = IEEE80211_ASSOCIATING;\n\t\t\t\tschedule_work(&ieee->associate_procedure_wq);\n\t\t\t} else {\n\t\t\t\tif (ieee80211_is_54g(&ieee->current_network) &&\n\t\t\t\t    (ieee->modulation & IEEE80211_OFDM_MODULATION)) {\n\t\t\t\t\tieee->rate = 108;\n\t\t\t\t\tieee->SetWirelessMode(ieee->dev, IEEE_G);\n\t\t\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t\t\t    \"Using G rates\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tieee->rate = 22;\n\t\t\t\t\tieee->SetWirelessMode(ieee->dev, IEEE_B);\n\t\t\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t\t\t    \"Using B rates\\n\");\n\t\t\t\t}\n\t\t\t\tmemset(ieee->dot11HTOperationalRateSet, 0, 16);\n\t\t\t\t\n\t\t\t\tieee->state = IEEE80211_LINKED;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ieee80211_softmac_check_all_nets(struct ieee80211_device *ieee)\n{\n\tunsigned long flags;\n\tstruct ieee80211_network *target;\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tlist_for_each_entry(target, &ieee->network_list, list) {\n\t\t \n\n\t\tif (ieee->state != IEEE80211_NOLINK)\n\t\t\tbreak;\n\n\t\tif (ieee->scan_age == 0 || time_after(target->last_scanned + ieee->scan_age, jiffies))\n\t\t\tieee80211_softmac_new_net(ieee, target);\n\t}\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\n\nstatic inline int auth_parse(struct sk_buff *skb, u8 **challenge, int *chlen)\n{\n\tstruct ieee80211_authentication *a;\n\tu8 *t;\n\tif (skb->len < (sizeof(struct ieee80211_authentication) - sizeof(struct ieee80211_info_element))) {\n\t\tIEEE80211_DEBUG_MGMT(\"invalid len in auth resp: %d\\n\", skb->len);\n\t\treturn -EINVAL;\n\t}\n\t*challenge = NULL;\n\ta = (struct ieee80211_authentication *)skb->data;\n\tif (skb->len > (sizeof(struct ieee80211_authentication) + 3)) {\n\t\tt = skb->data + sizeof(struct ieee80211_authentication);\n\n\t\tif (*(t++) == MFIE_TYPE_CHALLENGE) {\n\t\t\t*chlen = *(t++);\n\t\t\t*challenge = kmemdup(t, *chlen, GFP_ATOMIC);\n\t\t\tif (!*challenge)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (a->status) {\n\t\tIEEE80211_DEBUG_MGMT(\"auth_parse() failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int auth_rq_parse(struct sk_buff *skb, u8 *dest)\n{\n\tstruct ieee80211_authentication *a;\n\n\tif (skb->len < (sizeof(struct ieee80211_authentication) - sizeof(struct ieee80211_info_element))) {\n\t\tIEEE80211_DEBUG_MGMT(\"invalid len in auth request: %d\\n\", skb->len);\n\t\treturn -1;\n\t}\n\ta = (struct ieee80211_authentication *)skb->data;\n\n\tmemcpy(dest, a->header.addr2, ETH_ALEN);\n\n\tif (le16_to_cpu(a->algorithm) != WLAN_AUTH_OPEN)\n\t\treturn  WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG;\n\n\treturn WLAN_STATUS_SUCCESS;\n}\n\nstatic short probe_rq_parse(struct ieee80211_device *ieee, struct sk_buff *skb, u8 *src)\n{\n\tu8 *tag;\n\tu8 *skbend;\n\tu8 *ssid = NULL;\n\tu8 ssidlen = 0;\n\n\tstruct rtl_80211_hdr_3addr   *header =\n\t\t(struct rtl_80211_hdr_3addr   *)skb->data;\n\n\tif (skb->len < sizeof(struct rtl_80211_hdr_3addr))\n\t\treturn -1;  \n\n\tmemcpy(src, header->addr2, ETH_ALEN);\n\n\tskbend = (u8 *)skb->data + skb->len;\n\n\ttag = skb->data + sizeof(struct rtl_80211_hdr_3addr);\n\n\twhile (tag + 1 < skbend) {\n\t\tif (*tag == 0) {\n\t\t\tssid = tag + 2;\n\t\t\tssidlen = *(tag + 1);\n\t\t\tbreak;\n\t\t}\n\t\ttag++;  \n\t\ttag = tag + *(tag);  \n\t\ttag++;  \n\t}\n\n\t\n\tif (ssidlen == 0)\n\t\treturn 1;\n\n\tif (!ssid)\n\t\treturn 1;  \n\n\treturn (!strncmp(ssid, ieee->current_network.ssid, ssidlen));\n}\n\nstatic int assoc_rq_parse(struct sk_buff *skb, u8 *dest)\n{\n\tstruct ieee80211_assoc_request_frame *a;\n\n\tif (skb->len < (sizeof(struct ieee80211_assoc_request_frame) -\n\t\tsizeof(struct ieee80211_info_element))) {\n\t\tIEEE80211_DEBUG_MGMT(\"invalid len in auth request:%d \\n\", skb->len);\n\t\treturn -1;\n\t}\n\n\ta = (struct ieee80211_assoc_request_frame *)skb->data;\n\n\tmemcpy(dest, a->header.addr2, ETH_ALEN);\n\n\treturn 0;\n}\n\nstatic inline u16 assoc_parse(struct ieee80211_device *ieee, struct sk_buff *skb, int *aid)\n{\n\tstruct ieee80211_assoc_response_frame *response_head;\n\tu16 status_code;\n\n\tif (skb->len < sizeof(struct ieee80211_assoc_response_frame)) {\n\t\tIEEE80211_DEBUG_MGMT(\"invalid len in auth resp: %d\\n\", skb->len);\n\t\treturn 0xcafe;\n\t}\n\n\tresponse_head = (struct ieee80211_assoc_response_frame *)skb->data;\n\t*aid = le16_to_cpu(response_head->aid) & 0x3fff;\n\n\tstatus_code = le16_to_cpu(response_head->status);\n\tif ((status_code == WLAN_STATUS_ASSOC_DENIED_RATES ||\n\t     status_code == WLAN_STATUS_CAPS_UNSUPPORTED) &&\n\t    ((ieee->mode == IEEE_G) &&\n\t     (ieee->current_network.mode == IEEE_N_24G) &&\n\t     (ieee->AsocRetryCount++ < (RT_ASOC_RETRY_LIMIT - 1)))) {\n\t\tieee->pHTInfo->IOTAction |= HT_IOT_ACT_PURE_N_MODE;\n\t} else {\n\t\tieee->AsocRetryCount = 0;\n\t}\n\n\treturn le16_to_cpu(response_head->status);\n}\n\nstatic inline void\nieee80211_rx_probe_rq(struct ieee80211_device *ieee, struct sk_buff *skb)\n{\n\tu8 dest[ETH_ALEN];\n\n\t\n\tieee->softmac_stats.rx_probe_rq++;\n\t\n\tif (probe_rq_parse(ieee, skb, dest)) {\n\t\t\n\t\tieee->softmac_stats.tx_probe_rs++;\n\t\tieee80211_resp_to_probe(ieee, dest);\n\t}\n}\n\nstatic inline void\nieee80211_rx_auth_rq(struct ieee80211_device *ieee, struct sk_buff *skb)\n{\n\tu8 dest[ETH_ALEN];\n\tint status;\n\t\n\tieee->softmac_stats.rx_auth_rq++;\n\n\tstatus = auth_rq_parse(skb, dest);\n\tif (status != -1)\n\t\tieee80211_resp_to_auth(ieee, status, dest);\n\t\n}\n\nstatic inline void\nieee80211_rx_assoc_rq(struct ieee80211_device *ieee, struct sk_buff *skb)\n{\n\tu8 dest[ETH_ALEN];\n\t\n\n\tieee->softmac_stats.rx_ass_rq++;\n\tif (assoc_rq_parse(skb, dest) != -1)\n\t\tieee80211_resp_to_assoc_rq(ieee, dest);\n\n\tnetdev_info(ieee->dev, \"New client associated: %pM\\n\", dest);\n\t\n}\n\nstatic void ieee80211_sta_ps_send_null_frame(struct ieee80211_device *ieee,\n\t\t\t\t\t     short pwr)\n{\n\tstruct sk_buff *buf = ieee80211_null_func(ieee, pwr);\n\n\tif (buf)\n\t\tsoftmac_ps_mgmt_xmit(buf, ieee);\n}\n \n\nstatic short ieee80211_sta_ps_sleep(struct ieee80211_device *ieee, u32 *time_h,\n\t\t\t\t    u32 *time_l)\n{\n\tint timeout;\n\tu8 dtim;\n\t \n\tdtim = ieee->current_network.dtim_data;\n\tif (!(dtim & IEEE80211_DTIM_VALID))\n\t\treturn 0;\n\ttimeout = ieee->current_network.beacon_interval; \n\tieee->current_network.dtim_data = IEEE80211_DTIM_INVALID;\n\n\tif (dtim & ((IEEE80211_DTIM_UCAST | IEEE80211_DTIM_MBCAST) & ieee->ps))\n\t\treturn 2;\n\n\tif (!time_after(jiffies,\n\t\t\tdev_trans_start(ieee->dev) + msecs_to_jiffies(timeout)))\n\t\treturn 0;\n\n\tif (!time_after(jiffies,\n\t\t\tieee->last_rx_ps_time + msecs_to_jiffies(timeout)))\n\t\treturn 0;\n\n\tif ((ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE) &&\n\t    (ieee->mgmt_queue_tail != ieee->mgmt_queue_head))\n\t\treturn 0;\n\n\tif (time_l) {\n\t\t*time_l = ieee->current_network.last_dtim_sta_time[0]\n\t\t\t+ (ieee->current_network.beacon_interval\n\t\t\t   * ieee->current_network.dtim_period) * 1000;\n\t}\n\n\tif (time_h) {\n\t\t*time_h = ieee->current_network.last_dtim_sta_time[1];\n\t\tif (time_l && *time_l < ieee->current_network.last_dtim_sta_time[0])\n\t\t\t*time_h += 1;\n\t}\n\n\treturn 1;\n}\n\nstatic inline void ieee80211_sta_ps(struct work_struct *work)\n{\n\tstruct ieee80211_device *ieee;\n\tu32 th, tl;\n\tshort sleep;\n\tunsigned long flags, flags2;\n\n\tieee = container_of(work, struct ieee80211_device, ps_task);\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif ((ieee->ps == IEEE80211_PS_DISABLED ||\n\t     ieee->iw_mode != IW_MODE_INFRA ||\n\t     ieee->state != IEEE80211_LINKED)) {\n\t\t\n\t\tspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\n\n\t\tieee80211_sta_wakeup(ieee, 1);\n\n\t\tspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\n\t}\n\n\tsleep = ieee80211_sta_ps_sleep(ieee, &th, &tl);\n\t \n\tif (sleep == 0)\n\t\tgoto out;\n\n\tif (sleep == 1) {\n\t\tif (ieee->sta_sleep == 1) {\n\t\t\tieee->enter_sleep_state(ieee->dev, th, tl);\n\t\t} else if (ieee->sta_sleep == 0) {\n\t\t\n\t\t\tspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\n\n\t\t\tif (ieee->ps_is_queue_empty(ieee->dev)) {\n\t\t\t\tieee->sta_sleep = 2;\n\n\t\t\t\tieee->ps_request_tx_ack(ieee->dev);\n\n\t\t\t\tieee80211_sta_ps_send_null_frame(ieee, 1);\n\n\t\t\t\tieee->ps_th = th;\n\t\t\t\tieee->ps_tl = tl;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\n\t\t}\n\t} else if (sleep == 2) {\n\n\t\tspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\n\n\t\tieee80211_sta_wakeup(ieee, 1);\n\n\t\tspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\n\t}\nout:\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\n\nvoid ieee80211_sta_wakeup(struct ieee80211_device *ieee, short nl)\n{\n\tif (ieee->sta_sleep == 0) {\n\t\tif (nl) {\n\t\t\tprintk(\"Warning: driver is probably failing to report TX ps error\\n\");\n\t\t\tieee->ps_request_tx_ack(ieee->dev);\n\t\t\tieee80211_sta_ps_send_null_frame(ieee, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ieee->sta_sleep == 1)\n\t\tieee->sta_wake_up(ieee->dev);\n\n\tieee->sta_sleep = 0;\n\n\tif (nl) {\n\t\tieee->ps_request_tx_ack(ieee->dev);\n\t\tieee80211_sta_ps_send_null_frame(ieee, 0);\n\t}\n}\n\nvoid ieee80211_ps_tx_ack(struct ieee80211_device *ieee, short success)\n{\n\tunsigned long flags, flags2;\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif (ieee->sta_sleep == 2) {\n\t\t \n\t\tif (success) {\n\t\t\tieee->sta_sleep = 1;\n\t\t\tieee->enter_sleep_state(ieee->dev, ieee->ps_th, ieee->ps_tl);\n\t\t}\n\t\t \n\t} else {\n\t\t \n\t\tif ((ieee->sta_sleep == 0) && !success) {\n\t\t\tspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\n\t\t\tieee80211_sta_ps_send_null_frame(ieee, 0);\n\t\t\tspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\nEXPORT_SYMBOL(ieee80211_ps_tx_ack);\n\nstatic void ieee80211_process_action(struct ieee80211_device *ieee,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct rtl_80211_hdr *header = (struct rtl_80211_hdr *)skb->data;\n\tu8 *act = ieee80211_get_payload(header);\n\tu8 tmp = 0;\n\n\tif (!act) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"error to get payload of action frame\\n\");\n\t\treturn;\n\t}\n\ttmp = *act;\n\tact++;\n\tswitch (tmp) {\n\tcase ACT_CAT_BA:\n\t\tif (*act == ACT_ADDBAREQ)\n\t\t\tieee80211_rx_ADDBAReq(ieee, skb);\n\t\telse if (*act == ACT_ADDBARSP)\n\t\t\tieee80211_rx_ADDBARsp(ieee, skb);\n\t\telse if (*act == ACT_DELBA)\n\t\t\tieee80211_rx_DELBA(ieee, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn;\n}\n\nstatic void ieee80211_check_auth_response(struct ieee80211_device *ieee,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\t \n\tbool bSupportNmode = true, bHalfSupportNmode = false;\n\tint errcode;\n\tu8 *challenge;\n\tint chlen = 0;\n\tu32 iotAction;\n\n\terrcode = auth_parse(skb, &challenge, &chlen);\n\tif (!errcode) {\n\t\tif (ieee->open_wep || !challenge) {\n\t\t\tieee->state = IEEE80211_ASSOCIATING_AUTHENTICATED;\n\t\t\tieee->softmac_stats.rx_auth_rs_ok++;\n\t\t\tiotAction = ieee->pHTInfo->IOTAction;\n\t\t\tif (!(iotAction & HT_IOT_ACT_PURE_N_MODE)) {\n\t\t\t\tif (!ieee->GetNmodeSupportBySecCfg(ieee->dev)) {\n\t\t\t\t\t \n\t\t\t\t\tif (IsHTHalfNmodeAPs(ieee)) {\n\t\t\t\t\t\tbSupportNmode = true;\n\t\t\t\t\t\tbHalfSupportNmode = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbSupportNmode = false;\n\t\t\t\t\t\tbHalfSupportNmode = false;\n\t\t\t\t\t}\n\t\t\t\t\tnetdev_dbg(ieee->dev, \"SEC(%d, %d)\\n\",\n\t\t\t\t\t\t\tbSupportNmode,\n\t\t\t\t\t\t\tbHalfSupportNmode);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (bSupportNmode) {\n\t\t\t\t \n\t\t\t\tieee->SetWirelessMode(ieee->dev,\n\t\t\t\t\t\tieee->current_network.mode);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tieee->SetWirelessMode(ieee->dev, IEEE_G);\n\t\t\t}\n\n\t\t\tif (ieee->current_network.mode == IEEE_N_24G &&\n\t\t\t\t\tbHalfSupportNmode) {\n\t\t\t\tnetdev_dbg(ieee->dev, \"enter half N mode\\n\");\n\t\t\t\tieee->bHalfWirelessN24GMode = true;\n\t\t\t} else {\n\t\t\t\tieee->bHalfWirelessN24GMode = false;\n\t\t\t}\n\t\t\tieee80211_associate_step2(ieee);\n\t\t} else {\n\t\t\tieee80211_auth_challenge(ieee, challenge, chlen);\n\t\t}\n\t} else {\n\t\tieee->softmac_stats.rx_auth_rs_err++;\n\t\tIEEE80211_DEBUG_MGMT(\"Auth response status code %d\\n\", errcode);\n\t\tieee80211_associate_abort(ieee);\n\t}\n}\n\ninline int\nieee80211_rx_frame_softmac(struct ieee80211_device *ieee, struct sk_buff *skb,\n\t\t\t   struct ieee80211_rx_stats *rx_stats, u16 type,\n\t\t\t   u16 stype)\n{\n\tstruct rtl_80211_hdr_3addr *header = (struct rtl_80211_hdr_3addr *)skb->data;\n\tu16 errcode;\n\tint aid;\n\tstruct ieee80211_assoc_response_frame *assoc_resp;\n\n\n\tif (!ieee->proto_started)\n\t\treturn 0;\n\n\tif (ieee->sta_sleep || (ieee->ps != IEEE80211_PS_DISABLED &&\n\t\t\t\tieee->iw_mode == IW_MODE_INFRA &&\n\t\t\t\tieee->state == IEEE80211_LINKED))\n\t\tschedule_work(&ieee->ps_task);\n\n\tif (WLAN_FC_GET_STYPE(header->frame_ctl) != IEEE80211_STYPE_PROBE_RESP &&\n\t    WLAN_FC_GET_STYPE(header->frame_ctl) != IEEE80211_STYPE_BEACON)\n\t\tieee->last_rx_ps_time = jiffies;\n\n\tswitch (WLAN_FC_GET_STYPE(header->frame_ctl)) {\n\tcase IEEE80211_STYPE_ASSOC_RESP:\n\tcase IEEE80211_STYPE_REASSOC_RESP:\n\t\tIEEE80211_DEBUG_MGMT(\"received [RE]ASSOCIATION RESPONSE (%d)\\n\",\n\t\t\t\tWLAN_FC_GET_STYPE(header->frame_ctl));\n\t\tif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\n\t\t    ieee->state == IEEE80211_ASSOCIATING_AUTHENTICATED &&\n\t\t    ieee->iw_mode == IW_MODE_INFRA) {\n\t\t\tstruct ieee80211_network *network;\n\n\t\t\tnetwork = kzalloc(sizeof(*network), GFP_KERNEL);\n\t\t\tif (!network)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\terrcode = assoc_parse(ieee, skb, &aid);\n\t\t\tif (!errcode) {\n\t\t\t\tieee->state = IEEE80211_LINKED;\n\t\t\t\tieee->assoc_id = aid;\n\t\t\t\tieee->softmac_stats.rx_ass_ok++;\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (ieee->qos_support) {\n\t\t\t\t\tassoc_resp = (struct ieee80211_assoc_response_frame *)skb->data;\n\t\t\t\t\tif (ieee80211_parse_info_param(ieee, assoc_resp->info_element,\\\n\t\t\t\t\t\t\t\t       rx_stats->len - sizeof(*assoc_resp), \\\n\t\t\t\t\t\t\t\t       network, rx_stats)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemcpy(ieee->pHTInfo->PeerHTCapBuf, network->bssht.bdHTCapBuf, network->bssht.bdHTCapLen);\n\t\t\t\t\t\tmemcpy(ieee->pHTInfo->PeerHTInfoBuf, network->bssht.bdHTInfoBuf, network->bssht.bdHTInfoLen);\n\t\t\t\t\t}\n\t\t\t\t\tif (ieee->handle_assoc_response)\n\t\t\t\t\t\tieee->handle_assoc_response(ieee->dev, (struct ieee80211_assoc_response_frame *)header, network);\n\t\t\t\t}\n\t\t\t\tieee80211_associate_complete(ieee);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tieee->softmac_stats.rx_ass_err++;\n\t\t\t\tprintk(\"Association response status code 0x%x\\n\",\n\t\t\t\t       errcode);\n\t\t\t\tIEEE80211_DEBUG_MGMT(\"Association response status code 0x%x\\n\",\n\t\t\t\t\t\t     errcode);\n\t\t\t\tif (ieee->AsocRetryCount < RT_ASOC_RETRY_LIMIT)\n\t\t\t\t\tschedule_work(&ieee->associate_procedure_wq);\n\t\t\t\telse\n\t\t\t\t\tieee80211_associate_abort(ieee);\n\t\t\t}\n\t\t\tkfree(network);\n\t\t}\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_ASSOC_REQ:\n\tcase IEEE80211_STYPE_REASSOC_REQ:\n\t\tif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\n\t\t    ieee->iw_mode == IW_MODE_MASTER)\n\t\t\tieee80211_rx_assoc_rq(ieee, skb);\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_AUTH:\n\t\tif (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) {\n\t\t\tif (ieee->state == IEEE80211_ASSOCIATING_AUTHENTICATING\n\t\t\t    && ieee->iw_mode == IW_MODE_INFRA) {\n\t\t\t\tIEEE80211_DEBUG_MGMT(\"Received auth response\");\n\t\t\t\tieee80211_check_auth_response(ieee, skb);\n\t\t\t} else if (ieee->iw_mode == IW_MODE_MASTER) {\n\t\t\t\tieee80211_rx_auth_rq(ieee, skb);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_PROBE_REQ:\n\t\tif ((ieee->softmac_features & IEEE_SOFTMAC_PROBERS) &&\n\t\t    ((ieee->iw_mode == IW_MODE_ADHOC ||\n\t\t      ieee->iw_mode == IW_MODE_MASTER) &&\n\t\t     ieee->state == IEEE80211_LINKED)) {\n\t\t\tieee80211_rx_probe_rq(ieee, skb);\n\t\t}\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_DISASSOC:\n\tcase IEEE80211_STYPE_DEAUTH:\n\t\t \n\t\tif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\n\t\t    ieee->state == IEEE80211_LINKED &&\n\t\t    ieee->iw_mode == IW_MODE_INFRA) {\n\t\t\tieee->state = IEEE80211_ASSOCIATING;\n\t\t\tieee->softmac_stats.reassoc++;\n\n\t\t\tnotify_wx_assoc_event(ieee);\n\t\t\t\n\t\t\tRemovePeerTS(ieee, header->addr2);\n\t\t\tschedule_work(&ieee->associate_procedure_wq);\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_STYPE_MANAGE_ACT:\n\t\tieee80211_process_action(ieee, skb);\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\t\n\treturn 0;\n}\n\n \nvoid ieee80211_softmac_xmit(struct ieee80211_txb *txb, struct ieee80211_device *ieee)\n{\n\tunsigned int queue_index = txb->queue_index;\n\tunsigned long flags;\n\tint  i;\n\tstruct cb_desc *tcb_desc = NULL;\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\t \n\tieee80211_sta_wakeup(ieee, 0);\n\n\t \n\tieee->stats.tx_bytes += le16_to_cpu(txb->payload_size);\n\tieee->stats.tx_packets++;\n\ttcb_desc = (struct cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);\n\tif (tcb_desc->bMulticast)\n\t\tieee->stats.multicast++;\n\n\t \n\tfor (i = 0; i < txb->nr_frags; i++) {\n#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE\n\t\tif ((skb_queue_len(&ieee->skb_drv_aggQ[queue_index]) != 0) ||\n#else\n\t\tif ((skb_queue_len(&ieee->skb_waitQ[queue_index]) != 0) ||\n#endif\n\t\t    (!ieee->check_nic_enough_desc(ieee->dev, queue_index)) ||\n\t\t    (ieee->queue_stop)) {\n\t\t\t \n\t\t\t \n\t\t\t\n\t\t\t\n#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE\n\t\t\tskb_queue_tail(&ieee->skb_drv_aggQ[queue_index], txb->fragments[i]);\n#else\n\t\t\tskb_queue_tail(&ieee->skb_waitQ[queue_index], txb->fragments[i]);\n#endif\n\t\t} else {\n\t\t\tieee->softmac_data_hard_start_xmit(txb->fragments[i],\n\t\t\t\t\t\t\t   ieee->dev, ieee->rate);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\tieee80211_txb_free(txb);\n\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\nEXPORT_SYMBOL(ieee80211_softmac_xmit);\n\n \nstatic void ieee80211_resume_tx(struct ieee80211_device *ieee)\n{\n\tint i;\n\tfor (i = ieee->tx_pending.frag; i < ieee->tx_pending.txb->nr_frags; i++) {\n\t\tif (ieee->queue_stop) {\n\t\t\tieee->tx_pending.frag = i;\n\t\t\treturn;\n\t\t} else {\n\t\t\tieee->softmac_data_hard_start_xmit(ieee->tx_pending.txb->fragments[i],\n\t\t\t\t\t\t\t   ieee->dev, ieee->rate);\n\t\t\t\n\t\t\tieee->stats.tx_packets++;\n\t\t\tnetif_trans_update(ieee->dev);\n\t\t}\n\t}\n\n\tieee80211_txb_free(ieee->tx_pending.txb);\n\tieee->tx_pending.txb = NULL;\n}\n\nvoid ieee80211_reset_queue(struct ieee80211_device *ieee)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\tinit_mgmt_queue(ieee);\n\tif (ieee->tx_pending.txb) {\n\t\tieee80211_txb_free(ieee->tx_pending.txb);\n\t\tieee->tx_pending.txb = NULL;\n\t}\n\tieee->queue_stop = 0;\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\nEXPORT_SYMBOL(ieee80211_reset_queue);\n\nvoid ieee80211_wake_queue(struct ieee80211_device *ieee)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct rtl_80211_hdr_3addr  *header;\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\tif (!ieee->queue_stop)\n\t\tgoto exit;\n\n\tieee->queue_stop = 0;\n\n\tif (ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE) {\n\t\twhile (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))) {\n\t\t\theader = (struct rtl_80211_hdr_3addr  *)skb->data;\n\n\t\t\theader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\n\n\t\t\tif (ieee->seq_ctrl[0] == 0xFFF)\n\t\t\t\tieee->seq_ctrl[0] = 0;\n\t\t\telse\n\t\t\t\tieee->seq_ctrl[0]++;\n\n\t\t\tieee->softmac_data_hard_start_xmit(skb, ieee->dev, ieee->basic_rate);\n\t\t\t\n\t\t}\n\t}\n\tif (!ieee->queue_stop && ieee->tx_pending.txb)\n\t\tieee80211_resume_tx(ieee);\n\n\tif (!ieee->queue_stop && netif_queue_stopped(ieee->dev)) {\n\t\tieee->softmac_stats.swtxawake++;\n\t\tnetif_wake_queue(ieee->dev);\n\t}\nexit:\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\nEXPORT_SYMBOL(ieee80211_wake_queue);\n\nvoid ieee80211_stop_queue(struct ieee80211_device *ieee)\n{\n\t\n\t\n\n\tif (!netif_queue_stopped(ieee->dev)) {\n\t\tnetif_stop_queue(ieee->dev);\n\t\tieee->softmac_stats.swtxstop++;\n\t}\n\tieee->queue_stop = 1;\n\t\n}\nEXPORT_SYMBOL(ieee80211_stop_queue);\n\n \nvoid ieee80211_start_master_bss(struct ieee80211_device *ieee)\n{\n\tieee->assoc_id = 1;\n\n\tif (ieee->current_network.ssid_len == 0) {\n\t\tstrncpy(ieee->current_network.ssid,\n\t\t\tIEEE80211_DEFAULT_TX_ESSID,\n\t\t\tIW_ESSID_MAX_SIZE);\n\n\t\tieee->current_network.ssid_len = strlen(IEEE80211_DEFAULT_TX_ESSID);\n\t\tieee->ssid_set = 1;\n\t}\n\n\tmemcpy(ieee->current_network.bssid, ieee->dev->dev_addr, ETH_ALEN);\n\n\tieee->set_chan(ieee->dev, ieee->current_network.channel);\n\tieee->state = IEEE80211_LINKED;\n\tieee->link_change(ieee->dev);\n\tnotify_wx_assoc_event(ieee);\n\n\tif (ieee->data_hard_resume)\n\t\tieee->data_hard_resume(ieee->dev);\n\n\tnetif_carrier_on(ieee->dev);\n}\n\nstatic void ieee80211_start_monitor_mode(struct ieee80211_device *ieee)\n{\n\tif (ieee->raw_tx) {\n\t\tif (ieee->data_hard_resume)\n\t\t\tieee->data_hard_resume(ieee->dev);\n\n\t\tnetif_carrier_on(ieee->dev);\n\t}\n}\nstatic void ieee80211_start_ibss_wq(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, start_ibss_wq);\n\t \n\tif (!ieee->proto_started) {\n\t\tprintk(\"==========oh driver down return\\n\");\n\t\treturn;\n\t}\n\tmutex_lock(&ieee->wx_mutex);\n\n\tif (ieee->current_network.ssid_len == 0) {\n\t\tstrscpy(ieee->current_network.ssid, IEEE80211_DEFAULT_TX_ESSID,\n\t\t\tsizeof(ieee->current_network.ssid));\n\t\tieee->current_network.ssid_len = strlen(IEEE80211_DEFAULT_TX_ESSID);\n\t\tieee->ssid_set = 1;\n\t}\n\n\t \n\tieee80211_softmac_check_all_nets(ieee);\n\n\n\tif (ieee->state == IEEE80211_NOLINK)\n\t\tieee->current_network.channel = 6;\n\t \n\tif (ieee->state == IEEE80211_NOLINK)\n\t\tieee80211_start_scan_syncro(ieee);\n\n\t \n\tif (ieee->state == IEEE80211_NOLINK) {\n\t\tprintk(\"creating new IBSS cell\\n\");\n\t\tif (!ieee->wap_set)\n\t\t\teth_random_addr(ieee->current_network.bssid);\n\n\t\tif (ieee->modulation & IEEE80211_CCK_MODULATION) {\n\t\t\tieee->current_network.rates_len = 4;\n\n\t\t\tieee->current_network.rates[0] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_1MB;\n\t\t\tieee->current_network.rates[1] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_2MB;\n\t\t\tieee->current_network.rates[2] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_5MB;\n\t\t\tieee->current_network.rates[3] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_11MB;\n\t\t} else {\n\t\t\tieee->current_network.rates_len = 0;\n\t\t}\n\t\tif (ieee->modulation & IEEE80211_OFDM_MODULATION) {\n\t\t\tieee->current_network.rates_ex_len = 8;\n\n\t\t\tieee->current_network.rates_ex[0] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_6MB;\n\t\t\tieee->current_network.rates_ex[1] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_9MB;\n\t\t\tieee->current_network.rates_ex[2] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_12MB;\n\t\t\tieee->current_network.rates_ex[3] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_18MB;\n\t\t\tieee->current_network.rates_ex[4] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_24MB;\n\t\t\tieee->current_network.rates_ex[5] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_36MB;\n\t\t\tieee->current_network.rates_ex[6] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_48MB;\n\t\t\tieee->current_network.rates_ex[7] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_54MB;\n\n\t\t\tieee->rate = 108;\n\t\t} else {\n\t\t\tieee->current_network.rates_ex_len = 0;\n\t\t\tieee->rate = 22;\n\t\t}\n\n\t\t\n\t\tieee->current_network.QoS_Enable = 0;\n\t\tieee->SetWirelessMode(ieee->dev, IEEE_G);\n\t\tieee->current_network.atim_window = 0;\n\t\tieee->current_network.capability = WLAN_CAPABILITY_IBSS;\n\t\tif (ieee->short_slot)\n\t\t\tieee->current_network.capability |= WLAN_CAPABILITY_SHORT_SLOT;\n\t}\n\n\tieee->state = IEEE80211_LINKED;\n\n\tieee->set_chan(ieee->dev, ieee->current_network.channel);\n\tieee->link_change(ieee->dev);\n\n\tnotify_wx_assoc_event(ieee);\n\n\tieee80211_start_send_beacons(ieee);\n\n\tif (ieee->data_hard_resume)\n\t\tieee->data_hard_resume(ieee->dev);\n\tnetif_carrier_on(ieee->dev);\n\n\tmutex_unlock(&ieee->wx_mutex);\n}\n\ninline void ieee80211_start_ibss(struct ieee80211_device *ieee)\n{\n\tschedule_delayed_work(&ieee->start_ibss_wq, 150);\n}\n\n \nvoid ieee80211_start_bss(struct ieee80211_device *ieee)\n{\n\tunsigned long flags;\n\t\n\t\n\t\n\t\n\tif (IS_DOT11D_ENABLE(ieee) && !IS_COUNTRY_IE_VALID(ieee)) {\n\t\tif (!ieee->bGlobalDomain)\n\t\t\treturn;\n\t}\n\t \n\tieee80211_softmac_check_all_nets(ieee);\n\n\t \n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif (ieee->state == IEEE80211_NOLINK) {\n\t\tieee->actscanning = true;\n\t\tieee80211_start_scan(ieee);\n\t}\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\n\n \nvoid ieee80211_disassociate(struct ieee80211_device *ieee)\n{\n\tnetif_carrier_off(ieee->dev);\n\tif (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)\n\t\tieee80211_reset_queue(ieee);\n\n\tif (ieee->data_hard_stop)\n\t\tieee->data_hard_stop(ieee->dev);\n\tif (IS_DOT11D_ENABLE(ieee))\n\t\tdot11d_reset(ieee);\n\tieee->state = IEEE80211_NOLINK;\n\tieee->is_set_key = false;\n\tieee->link_change(ieee->dev);\n\t\n\tnotify_wx_assoc_event(ieee);\n}\nEXPORT_SYMBOL(ieee80211_disassociate);\n\nstatic void ieee80211_associate_retry_wq(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, associate_retry_wq);\n\tunsigned long flags;\n\n\tmutex_lock(&ieee->wx_mutex);\n\tif (!ieee->proto_started)\n\t\tgoto exit;\n\n\tif (ieee->state != IEEE80211_ASSOCIATING_RETRY)\n\t\tgoto exit;\n\n\t \n\tieee->state = IEEE80211_NOLINK;\n\n\tieee80211_softmac_check_all_nets(ieee);\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif (ieee->state == IEEE80211_NOLINK)\n\t\tieee80211_start_scan(ieee);\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\nexit:\n\tmutex_unlock(&ieee->wx_mutex);\n}\n\nstruct sk_buff *ieee80211_get_beacon_(struct ieee80211_device *ieee)\n{\n\tu8 broadcast_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n\tstruct sk_buff *skb;\n\tstruct ieee80211_probe_response *b;\n\n\tskb = ieee80211_probe_resp(ieee, broadcast_addr);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tb = (struct ieee80211_probe_response *)skb->data;\n\tb->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_BEACON);\n\n\treturn skb;\n}\n\nstruct sk_buff *ieee80211_get_beacon(struct ieee80211_device *ieee)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_probe_response *b;\n\n\tskb = ieee80211_get_beacon_(ieee);\n\tif (!skb)\n\t\treturn NULL;\n\n\tb = (struct ieee80211_probe_response *)skb->data;\n\tb->header.seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\n\n\tif (ieee->seq_ctrl[0] == 0xFFF)\n\t\tieee->seq_ctrl[0] = 0;\n\telse\n\t\tieee->seq_ctrl[0]++;\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_get_beacon);\n\nvoid ieee80211_softmac_stop_protocol(struct ieee80211_device *ieee)\n{\n\tieee->sync_scan_hurryup = 1;\n\tmutex_lock(&ieee->wx_mutex);\n\tieee80211_stop_protocol(ieee);\n\tmutex_unlock(&ieee->wx_mutex);\n}\nEXPORT_SYMBOL(ieee80211_softmac_stop_protocol);\n\nvoid ieee80211_stop_protocol(struct ieee80211_device *ieee)\n{\n\tif (!ieee->proto_started)\n\t\treturn;\n\n\tieee->proto_started = 0;\n\n\tieee80211_stop_send_beacons(ieee);\n\tdel_timer_sync(&ieee->associate_timer);\n\tcancel_delayed_work(&ieee->associate_retry_wq);\n\tcancel_delayed_work(&ieee->start_ibss_wq);\n\tieee80211_stop_scan(ieee);\n\n\tieee80211_disassociate(ieee);\n\tRemoveAllTS(ieee); \n}\n\nvoid ieee80211_softmac_start_protocol(struct ieee80211_device *ieee)\n{\n\tieee->sync_scan_hurryup = 0;\n\tmutex_lock(&ieee->wx_mutex);\n\tieee80211_start_protocol(ieee);\n\tmutex_unlock(&ieee->wx_mutex);\n}\nEXPORT_SYMBOL(ieee80211_softmac_start_protocol);\n\nvoid ieee80211_start_protocol(struct ieee80211_device *ieee)\n{\n\tshort ch = 0;\n\tint i = 0;\n\n\tif (ieee->proto_started)\n\t\treturn;\n\n\tieee->proto_started = 1;\n\n\tif (ieee->current_network.channel == 0) {\n\t\tdo {\n\t\t\tch++;\n\t\t\tif (ch > MAX_CHANNEL_NUMBER)\n\t\t\t\treturn;  \n\t\t} while (!GET_DOT11D_INFO(ieee)->channel_map[ch]);\n\t\tieee->current_network.channel = ch;\n\t}\n\n\tif (ieee->current_network.beacon_interval == 0)\n\t\tieee->current_network.beacon_interval = 100;\n\n\n\n\tfor (i = 0; i < 17; i++) {\n\t\tieee->last_rxseq_num[i] = -1;\n\t\tieee->last_rxfrag_num[i] = -1;\n\t\tieee->last_packet_time[i] = 0;\n\t}\n\n\tieee->init_wmmparam_flag = 0;\n\n\t \n\tif (ieee->iw_mode == IW_MODE_INFRA)\n\t\tieee80211_start_bss(ieee);\n\n\telse if (ieee->iw_mode == IW_MODE_ADHOC)\n\t\tieee80211_start_ibss(ieee);\n\n\telse if (ieee->iw_mode == IW_MODE_MASTER)\n\t\tieee80211_start_master_bss(ieee);\n\n\telse if (ieee->iw_mode == IW_MODE_MONITOR)\n\t\tieee80211_start_monitor_mode(ieee);\n}\n\n#define DRV_NAME  \"Ieee80211\"\nvoid ieee80211_softmac_init(struct ieee80211_device *ieee)\n{\n\tint i;\n\tmemset(&ieee->current_network, 0, sizeof(struct ieee80211_network));\n\n\tieee->state = IEEE80211_NOLINK;\n\tieee->sync_scan_hurryup = 0;\n\tfor (i = 0; i < 5; i++)\n\t\tieee->seq_ctrl[i] = 0;\n\n\tieee->dot11d_info = kzalloc(sizeof(struct rt_dot11d_info), GFP_KERNEL);\n\tif (!ieee->dot11d_info)\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"can't alloc memory for DOT11D\\n\");\n\t\n\tieee->LinkDetectInfo.SlotNum = 2;\n\tieee->LinkDetectInfo.NumRecvBcnInPeriod = 0;\n\tieee->LinkDetectInfo.NumRecvDataInPeriod = 0;\n\n\tieee->assoc_id = 0;\n\tieee->queue_stop = 0;\n\tieee->scanning = 0;\n\tieee->softmac_features = 0; \n\tieee->wap_set = 0;\n\tieee->ssid_set = 0;\n\tieee->proto_started = 0;\n\tieee->basic_rate = IEEE80211_DEFAULT_BASIC_RATE;\n\tieee->rate = 22;\n\tieee->ps = IEEE80211_PS_DISABLED;\n\tieee->sta_sleep = 0;\n\tieee->Regdot11HTOperationalRateSet[0] = 0xff;\n\tieee->Regdot11HTOperationalRateSet[1] = 0xff;\n\tieee->Regdot11HTOperationalRateSet[4] = 0x01;\n\t\n\tieee->actscanning = false;\n\tieee->beinretry = false;\n\tieee->is_set_key = false;\n\tinit_mgmt_queue(ieee);\n\n\tieee->sta_edca_param[0] = 0x0000A403;\n\tieee->sta_edca_param[1] = 0x0000A427;\n\tieee->sta_edca_param[2] = 0x005E4342;\n\tieee->sta_edca_param[3] = 0x002F3262;\n\tieee->aggregation = true;\n\tieee->enable_rx_imm_BA = true;\n\tieee->tx_pending.txb = NULL;\n\n\ttimer_setup(&ieee->associate_timer, ieee80211_associate_abort_cb, 0);\n\n\ttimer_setup(&ieee->beacon_timer, ieee80211_send_beacon_cb, 0);\n\n\tINIT_DELAYED_WORK(&ieee->start_ibss_wq, ieee80211_start_ibss_wq);\n\tINIT_WORK(&ieee->associate_complete_wq, ieee80211_associate_complete_wq);\n\tINIT_WORK(&ieee->associate_procedure_wq, ieee80211_associate_procedure_wq);\n\tINIT_DELAYED_WORK(&ieee->softmac_scan_wq, ieee80211_softmac_scan_wq);\n\tINIT_DELAYED_WORK(&ieee->associate_retry_wq, ieee80211_associate_retry_wq);\n\tINIT_WORK(&ieee->wx_sync_scan_wq, ieee80211_wx_sync_scan_wq);\n\n\tmutex_init(&ieee->wx_mutex);\n\tmutex_init(&ieee->scan_mutex);\n\n\tspin_lock_init(&ieee->mgmt_tx_lock);\n\tspin_lock_init(&ieee->beacon_lock);\n\n\tINIT_WORK(&ieee->ps_task, ieee80211_sta_ps);\n}\n\nvoid ieee80211_softmac_free(struct ieee80211_device *ieee)\n{\n\tmutex_lock(&ieee->wx_mutex);\n\tkfree(ieee->dot11d_info);\n\tieee->dot11d_info = NULL;\n\tdel_timer_sync(&ieee->associate_timer);\n\n\tcancel_delayed_work(&ieee->associate_retry_wq);\n\tcancel_work_sync(&ieee->ps_task);\n\tmutex_unlock(&ieee->wx_mutex);\n}\n\n \nstatic int ieee80211_wpa_enable(struct ieee80211_device *ieee, int value)\n{\n\t \n\tprintk(\"%s WPA\\n\", value ? \"enabling\" : \"disabling\");\n\tieee->wpa_enabled = value;\n\treturn 0;\n}\n\nstatic void ieee80211_wpa_assoc_frame(struct ieee80211_device *ieee,\n\t\t\t\t      char *wpa_ie, int wpa_ie_len)\n{\n\t \n\tieee80211_wpa_enable(ieee, 1);\n\n\tieee80211_disassociate(ieee);\n}\n\nstatic int ieee80211_wpa_mlme(struct ieee80211_device *ieee, int command, int reason)\n{\n\tint ret = 0;\n\n\tswitch (command) {\n\tcase IEEE_MLME_STA_DEAUTH:\n\t\t\n\t\tbreak;\n\n\tcase IEEE_MLME_STA_DISASSOC:\n\t\tieee80211_disassociate(ieee);\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(\"Unknown MLME request: %d\\n\", command);\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int ieee80211_wpa_set_wpa_ie(struct ieee80211_device *ieee,\n\t\t\t      struct ieee_param *param, int plen)\n{\n\tu8 *buf;\n\n\tif (param->u.wpa_ie.len > MAX_WPA_IE_LEN)\n\t\treturn -EINVAL;\n\n\tif (param->u.wpa_ie.len) {\n\t\tbuf = kmemdup(param->u.wpa_ie.data, param->u.wpa_ie.len,\n\t\t\t      GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = buf;\n\t\tieee->wpa_ie_len = param->u.wpa_ie.len;\n\t} else {\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = NULL;\n\t\tieee->wpa_ie_len = 0;\n\t}\n\n\tieee80211_wpa_assoc_frame(ieee, ieee->wpa_ie, ieee->wpa_ie_len);\n\treturn 0;\n}\n\n#define AUTH_ALG_OPEN_SYSTEM\t\t\t0x1\n#define AUTH_ALG_SHARED_KEY\t\t\t0x2\n\nstatic int ieee80211_wpa_set_auth_algs(struct ieee80211_device *ieee, int value)\n{\n\tstruct ieee80211_security sec = {\n\t\t.flags = SEC_AUTH_MODE,\n\t};\n\n\tif (value & AUTH_ALG_SHARED_KEY) {\n\t\tsec.auth_mode = WLAN_AUTH_SHARED_KEY;\n\t\tieee->open_wep = 0;\n\t\tieee->auth_mode = 1;\n\t} else if (value & AUTH_ALG_OPEN_SYSTEM) {\n\t\tsec.auth_mode = WLAN_AUTH_OPEN;\n\t\tieee->open_wep = 1;\n\t\tieee->auth_mode = 0;\n\t} else if (value & IW_AUTH_ALG_LEAP) {\n\t\tsec.auth_mode = WLAN_AUTH_LEAP;\n\t\tieee->open_wep = 1;\n\t\tieee->auth_mode = 2;\n\t}\n\n\tif (ieee->set_security)\n\t\tieee->set_security(ieee->dev, &sec);\n\t\n\t\n\n\treturn 0;\n}\n\nstatic int ieee80211_wpa_set_param(struct ieee80211_device *ieee, u8 name, u32 value)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tswitch (name) {\n\tcase IEEE_PARAM_WPA_ENABLED:\n\t\tret = ieee80211_wpa_enable(ieee, value);\n\t\tbreak;\n\n\tcase IEEE_PARAM_TKIP_COUNTERMEASURES:\n\t\tieee->tkip_countermeasures = value;\n\t\tbreak;\n\n\tcase IEEE_PARAM_DROP_UNENCRYPTED: {\n\t\t \n\t\tstruct ieee80211_security sec = {\n\t\t\t.flags = SEC_ENABLED,\n\t\t\t.enabled = value,\n\t\t};\n\t\tieee->drop_unencrypted = value;\n\t\t \n\t\tif (!value) {\n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\tsec.level = SEC_LEVEL_0;\n\t\t} else {\n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\tsec.level = SEC_LEVEL_1;\n\t\t}\n\t\tif (ieee->set_security)\n\t\t\tieee->set_security(ieee->dev, &sec);\n\t\tbreak;\n\t}\n\n\tcase IEEE_PARAM_PRIVACY_INVOKED:\n\t\tieee->privacy_invoked = value;\n\t\tbreak;\n\n\tcase IEEE_PARAM_AUTH_ALGS:\n\t\tret = ieee80211_wpa_set_auth_algs(ieee, value);\n\t\tbreak;\n\n\tcase IEEE_PARAM_IEEE_802_1X:\n\t\tieee->ieee802_1x = value;\n\t\tbreak;\n\tcase IEEE_PARAM_WPAX_SELECT:\n\t\t\n\t\tspin_lock_irqsave(&ieee->wpax_suitlist_lock, flags);\n\t\tieee->wpax_type_set = 1;\n\t\tieee->wpax_type_notify = value;\n\t\tspin_unlock_irqrestore(&ieee->wpax_suitlist_lock, flags);\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(\"Unknown WPA param: %d\\n\", name);\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ieee80211_wpa_set_encryption(struct ieee80211_device *ieee,\n\t\t\t\t  struct ieee_param *param, int param_len)\n{\n\tint ret = 0;\n\tconst char *module = NULL;\n\n\tstruct ieee80211_crypto_ops *ops = NULL;\n\tstruct ieee80211_crypt_data **crypt;\n\n\tstruct ieee80211_security sec = {\n\t\t.flags = 0,\n\t};\n\n\tparam->u.crypt.err = 0;\n\tparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\\0';\n\n\tif (param_len !=\n\t    (int)((char *)param->u.crypt.key - (char *)param) +\n\t    param->u.crypt.key_len) {\n\t\tprintk(\"Len mismatch %d, %d\\n\", param_len,\n\t\t\t       param->u.crypt.key_len);\n\t\treturn -EINVAL;\n\t}\n\tif (is_broadcast_ether_addr(param->sta_addr)) {\n\t\tif (param->u.crypt.idx >= WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tcrypt = &ieee->crypt[param->u.crypt.idx];\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (strcmp(param->u.crypt.alg, \"none\") == 0) {\n\t\tif (crypt) {\n\t\t\tsec.enabled = 0;\n\t\t\t\n\t\t\t\n\t\t\tsec.level = SEC_LEVEL_0;\n\t\t\tsec.flags |= SEC_ENABLED | SEC_LEVEL;\n\t\t\tieee80211_crypt_delayed_deinit(ieee, crypt);\n\t\t}\n\t\tgoto done;\n\t}\n\tsec.enabled = 1;\n\n\n\tsec.flags |= SEC_ENABLED;\n\n\t \n\tif (!(ieee->host_encrypt || ieee->host_decrypt) &&\n\t    strcmp(param->u.crypt.alg, \"TKIP\"))\n\t\tgoto skip_host_crypt;\n\n\t\n\tif (!strcmp(param->u.crypt.alg, \"WEP\"))\n\t\tmodule = \"ieee80211_crypt_wep\";\n\telse if (!strcmp(param->u.crypt.alg, \"TKIP\"))\n\t\tmodule = \"ieee80211_crypt_tkip\";\n\telse if (!strcmp(param->u.crypt.alg, \"CCMP\"))\n\t\tmodule = \"ieee80211_crypt_ccmp\";\n\tif (module)\n\t\tops = try_then_request_module(ieee80211_get_crypto_ops(param->u.crypt.alg),\n\t\t\t\t\t      module);\n\tif (!ops) {\n\t\tprintk(\"unknown crypto alg '%s'\\n\", param->u.crypt.alg);\n\t\tparam->u.crypt.err = IEEE_CRYPT_ERR_UNKNOWN_ALG;\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (!*crypt || (*crypt)->ops != ops) {\n\t\tstruct ieee80211_crypt_data *new_crypt;\n\n\t\tieee80211_crypt_delayed_deinit(ieee, crypt);\n\n\t\tnew_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);\n\t\tif (!new_crypt) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tnew_crypt->ops = ops;\n\t\tif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\n\t\t\tnew_crypt->priv =\n\t\t\t\tnew_crypt->ops->init(param->u.crypt.idx);\n\n\t\tif (!new_crypt->priv) {\n\t\t\tkfree(new_crypt);\n\t\t\tparam->u.crypt.err = IEEE_CRYPT_ERR_CRYPT_INIT_FAILED;\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\t*crypt = new_crypt;\n\t}\n\n\tif (param->u.crypt.key_len > 0 && (*crypt)->ops->set_key &&\n\t    (*crypt)->ops->set_key(param->u.crypt.key,\n\t\t\t\t   param->u.crypt.key_len, param->u.crypt.seq,\n\t\t\t\t   (*crypt)->priv) < 0) {\n\t\tprintk(\"key setting failed\\n\");\n\t\tparam->u.crypt.err = IEEE_CRYPT_ERR_KEY_SET_FAILED;\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n skip_host_crypt:\n\tif (param->u.crypt.set_tx) {\n\t\tieee->tx_keyidx = param->u.crypt.idx;\n\t\tsec.active_key = param->u.crypt.idx;\n\t\tsec.flags |= SEC_ACTIVE_KEY;\n\t} else {\n\t\tsec.flags &= ~SEC_ACTIVE_KEY;\n\t}\n\tmemcpy(sec.keys[param->u.crypt.idx],\n\t       param->u.crypt.key,\n\t       param->u.crypt.key_len);\n\tsec.key_sizes[param->u.crypt.idx] = param->u.crypt.key_len;\n\tsec.flags |= (1 << param->u.crypt.idx);\n\n\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0) {\n\t\tsec.flags |= SEC_LEVEL;\n\t\tsec.level = SEC_LEVEL_1;\n\t} else if (strcmp(param->u.crypt.alg, \"TKIP\") == 0) {\n\t\tsec.flags |= SEC_LEVEL;\n\t\tsec.level = SEC_LEVEL_2;\n\t} else if (strcmp(param->u.crypt.alg, \"CCMP\") == 0) {\n\t\tsec.flags |= SEC_LEVEL;\n\t\tsec.level = SEC_LEVEL_3;\n\t}\n done:\n\tif (ieee->set_security)\n\t\tieee->set_security(ieee->dev, &sec);\n\n\t \n\tif (ieee->reset_on_keychange &&\n\t    ieee->iw_mode != IW_MODE_INFRA &&\n\t    ieee->reset_port &&\n\t    ieee->reset_port(ieee->dev)) {\n\t\tprintk(\"reset_port failed\\n\");\n\t\tparam->u.crypt.err = IEEE_CRYPT_ERR_CARD_CONF_FAILED;\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic inline struct sk_buff *ieee80211_disassociate_skb(struct ieee80211_network *beacon,\n\t\t\t\t\t\t\t struct ieee80211_device *ieee,\n\t\t\t\t\t\t\t u8\tasRsn)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_disassoc *disass;\n\n\tskb = dev_alloc_skb(sizeof(struct ieee80211_disassoc));\n\tif (!skb)\n\t\treturn NULL;\n\n\tdisass = skb_put(skb, sizeof(struct ieee80211_disassoc));\n\tdisass->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_DISASSOC);\n\tdisass->header.duration_id = 0;\n\n\tmemcpy(disass->header.addr1, beacon->bssid, ETH_ALEN);\n\tmemcpy(disass->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\n\tmemcpy(disass->header.addr3, beacon->bssid, ETH_ALEN);\n\n\tdisass->reason = cpu_to_le16(asRsn);\n\treturn skb;\n}\n\nvoid\nSendDisassociation(struct ieee80211_device *ieee,\n\t\t   u8\t\t\t   *asSta,\n\t\t   u8\t\t\t    asRsn\n)\n{\n\tstruct ieee80211_network *beacon = &ieee->current_network;\n\tstruct sk_buff *skb;\n\n\tskb = ieee80211_disassociate_skb(beacon, ieee, asRsn);\n\tif (skb) {\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\t\n\t}\n}\nEXPORT_SYMBOL(SendDisassociation);\n\nint ieee80211_wpa_supplicant_ioctl(struct ieee80211_device *ieee, struct iw_point *p)\n{\n\tstruct ieee_param *param;\n\tint ret = 0;\n\n\tmutex_lock(&ieee->wx_mutex);\n\t\n\n\tif (p->length < sizeof(struct ieee_param) || !p->pointer) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparam = memdup_user(p->pointer, p->length);\n\tif (IS_ERR(param)) {\n\t\tret = PTR_ERR(param);\n\t\tgoto out;\n\t}\n\n\tswitch (param->cmd) {\n\tcase IEEE_CMD_SET_WPA_PARAM:\n\t\tret = ieee80211_wpa_set_param(ieee, param->u.wpa_param.name,\n\t\t\t\t\tparam->u.wpa_param.value);\n\t\tbreak;\n\n\tcase IEEE_CMD_SET_WPA_IE:\n\t\tret = ieee80211_wpa_set_wpa_ie(ieee, param, p->length);\n\t\tbreak;\n\n\tcase IEEE_CMD_SET_ENCRYPTION:\n\t\tret = ieee80211_wpa_set_encryption(ieee, param, p->length);\n\t\tbreak;\n\n\tcase IEEE_CMD_MLME:\n\t\tret = ieee80211_wpa_mlme(ieee, param->u.mlme.command,\n\t\t\t\t   param->u.mlme.reason_code);\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(\"Unknown WPA supplicant request: %d\\n\", param->cmd);\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (ret == 0 && copy_to_user(p->pointer, param, p->length))\n\t\tret = -EFAULT;\n\n\tkfree(param);\nout:\n\tmutex_unlock(&ieee->wx_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_wpa_supplicant_ioctl);\n\nvoid notify_wx_assoc_event(struct ieee80211_device *ieee)\n{\n\tunion iwreq_data wrqu;\n\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\tif (ieee->state == IEEE80211_LINKED)\n\t\tmemcpy(wrqu.ap_addr.sa_data, ieee->current_network.bssid, ETH_ALEN);\n\telse\n\t\teth_zero_addr(wrqu.ap_addr.sa_data);\n\twireless_send_event(ieee->dev, SIOCGIWAP, &wrqu, NULL);\n}\nEXPORT_SYMBOL(notify_wx_assoc_event);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}