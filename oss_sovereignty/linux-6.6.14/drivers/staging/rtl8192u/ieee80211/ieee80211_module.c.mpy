{
  "module_name": "ieee80211_module.c",
  "hash_id": "6d1e19c846da5785e255a4c28298090dacb1abe5dfdb1c23252ac0666495d2e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/ieee80211/ieee80211_module.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n#include <linux/wireless.h>\n#include <linux/etherdevice.h>\n#include <linux/uaccess.h>\n#include <net/arp.h>\n\n#include \"ieee80211.h\"\n\nMODULE_DESCRIPTION(\"802.11 data/management/control stack\");\nMODULE_AUTHOR(\"Copyright (C) 2004 Intel Corporation <jketreno@linux.intel.com>\");\nMODULE_LICENSE(\"GPL\");\n\n#define DRV_NAME \"ieee80211\"\n\nstatic inline int ieee80211_networks_allocate(struct ieee80211_device *ieee)\n{\n\tif (ieee->networks)\n\t\treturn 0;\n\n\tieee->networks = kcalloc(MAX_NETWORK_COUNT,\n\t\t\t\t sizeof(struct ieee80211_network),\n\t\t\t\t GFP_KERNEL);\n\tif (!ieee->networks) {\n\t\tnetdev_warn(ieee->dev, \"Out of memory allocating beacons\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void ieee80211_networks_free(struct ieee80211_device *ieee)\n{\n\tif (!ieee->networks)\n\t\treturn;\n\tkfree(ieee->networks);\n\tieee->networks = NULL;\n}\n\nstatic inline void ieee80211_networks_initialize(struct ieee80211_device *ieee)\n{\n\tint i;\n\n\tINIT_LIST_HEAD(&ieee->network_free_list);\n\tINIT_LIST_HEAD(&ieee->network_list);\n\tfor (i = 0; i < MAX_NETWORK_COUNT; i++)\n\t\tlist_add_tail(&ieee->networks[i].list, &ieee->network_free_list);\n}\n\nstruct net_device *alloc_ieee80211(int sizeof_priv)\n{\n\tstruct ieee80211_device *ieee;\n\tstruct net_device *dev;\n\tint i, err;\n\n\tIEEE80211_DEBUG_INFO(\"Initializing...\\n\");\n\n\tdev = alloc_etherdev(sizeof(struct ieee80211_device) + sizeof_priv);\n\tif (!dev) {\n\t\tIEEE80211_ERROR(\"Unable to network device.\\n\");\n\t\tgoto failed;\n\t}\n\n\tieee = netdev_priv(dev);\n\tieee->dev = dev;\n\n\terr = ieee80211_networks_allocate(ieee);\n\tif (err) {\n\t\tIEEE80211_ERROR(\"Unable to allocate beacon storage: %d\\n\",\n\t\t\t\terr);\n\t\tgoto failed;\n\t}\n\tieee80211_networks_initialize(ieee);\n\n\t \n\tieee->fts = DEFAULT_FTS;\n\tieee->scan_age = DEFAULT_MAX_SCAN_AGE;\n\tieee->open_wep = 1;\n\n\t \n\tieee->host_encrypt = 1;\n\tieee->host_decrypt = 1;\n\tieee->ieee802_1x = 1;  \n\n\tINIT_LIST_HEAD(&ieee->crypt_deinit_list);\n\ttimer_setup(&ieee->crypt_deinit_timer, ieee80211_crypt_deinit_handler,\n\t\t    0);\n\n\tspin_lock_init(&ieee->lock);\n\tspin_lock_init(&ieee->wpax_suitlist_lock);\n\tspin_lock_init(&ieee->bw_spinlock);\n\tspin_lock_init(&ieee->reorder_spinlock);\n\t \n\tatomic_set(&ieee->atm_chnlop, 0);\n\tatomic_set(&ieee->atm_swbw, 0);\n\n\tieee->wpax_type_set = 0;\n\tieee->wpa_enabled = 0;\n\tieee->tkip_countermeasures = 0;\n\tieee->drop_unencrypted = 0;\n\tieee->privacy_invoked = 0;\n\tieee->ieee802_1x = 1;\n\tieee->raw_tx = 0;\n\t\n\tieee->hwsec_active = 0;  \n\n\tieee80211_softmac_init(ieee);\n\n\tieee->pHTInfo = kzalloc(sizeof(RT_HIGH_THROUGHPUT), GFP_KERNEL);\n\tif (!ieee->pHTInfo) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"can't alloc memory for HTInfo\\n\");\n\n\t\t \n\t\tieee80211_networks_free(ieee);\n\t\tgoto failed;\n\t}\n\tHTUpdateDefaultSetting(ieee);\n\tHTInitializeHTInfo(ieee);  \n\tTSInitialize(ieee);\n\n\tfor (i = 0; i < IEEE_IBSS_MAC_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&ieee->ibss_mac_hash[i]);\n\n\tfor (i = 0; i < 17; i++) {\n\t\tieee->last_rxseq_num[i] = -1;\n\t\tieee->last_rxfrag_num[i] = -1;\n\t\tieee->last_packet_time[i] = 0;\n\t}\n\n\treturn dev;\n\n failed:\n\tif (dev)\n\t\tfree_netdev(dev);\n\n\treturn NULL;\n}\n\nvoid free_ieee80211(struct net_device *dev)\n{\n\tstruct ieee80211_device *ieee = netdev_priv(dev);\n\tint i;\n\t \n\n\tkfree(ieee->pHTInfo);\n\tieee->pHTInfo = NULL;\n\tRemoveAllTS(ieee);\n\tieee80211_softmac_free(ieee);\n\tdel_timer_sync(&ieee->crypt_deinit_timer);\n\tieee80211_crypt_deinit_entries(ieee, 1);\n\n\tfor (i = 0; i < WEP_KEYS; i++) {\n\t\tstruct ieee80211_crypt_data *crypt = ieee->crypt[i];\n\n\t\tif (crypt) {\n\t\t\tif (crypt->ops)\n\t\t\t\tcrypt->ops->deinit(crypt->priv);\n\t\t\tkfree(crypt);\n\t\t\tieee->crypt[i] = NULL;\n\t\t}\n\t}\n\n\tieee80211_networks_free(ieee);\n\tfree_netdev(dev);\n}\n\n#ifdef CONFIG_IEEE80211_DEBUG\n\nu32 ieee80211_debug_level;\nstatic int debug = \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\t\t    \n\t\n\t\n\n\t\n\n\t\t\t    \n\t\t\t    IEEE80211_DL_ERR\t   \n\t\t\t    ;\nstatic struct proc_dir_entry *ieee80211_proc;\n\nstatic int show_debug_level(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"0x%08X\\n\", ieee80211_debug_level);\n\n\treturn 0;\n}\n\nstatic ssize_t write_debug_level(struct file *file, const char __user *buffer,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tunsigned long val;\n\tint err = kstrtoul_from_user(buffer, count, 0, &val);\n\n\tif (err)\n\t\treturn err;\n\tieee80211_debug_level = val;\n\treturn count;\n}\n\nstatic int open_debug_level(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, show_debug_level, NULL);\n}\n\nstatic const struct proc_ops debug_level_proc_ops = {\n\t.proc_open\t= open_debug_level,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= write_debug_level,\n\t.proc_release\t= single_release,\n};\n\nint __init ieee80211_debug_init(void)\n{\n\tstruct proc_dir_entry *e;\n\n\tieee80211_debug_level = debug;\n\n\tieee80211_proc = proc_mkdir(DRV_NAME, init_net.proc_net);\n\tif (!ieee80211_proc) {\n\t\tIEEE80211_ERROR(\"Unable to create \" DRV_NAME\n\t\t\t\t\" proc directory\\n\");\n\t\treturn -EIO;\n\t}\n\te = proc_create(\"debug_level\", 0644, ieee80211_proc, &debug_level_proc_ops);\n\tif (!e) {\n\t\tremove_proc_entry(DRV_NAME, init_net.proc_net);\n\t\tieee80211_proc = NULL;\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nvoid ieee80211_debug_exit(void)\n{\n\tif (ieee80211_proc) {\n\t\tremove_proc_entry(\"debug_level\", ieee80211_proc);\n\t\tremove_proc_entry(DRV_NAME, init_net.proc_net);\n\t\tieee80211_proc = NULL;\n\t}\n}\n\nmodule_param(debug, int, 0444);\nMODULE_PARM_DESC(debug, \"debug output mask\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}