{
  "module_name": "rtl819x_TSProc.c",
  "hash_id": "1afaad8697470be30dccf08364189b9d45a27e193a54eca50d3344780e1c6801",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/ieee80211/rtl819x_TSProc.c",
  "human_readable_source": "\n#include \"ieee80211.h\"\n#include <linux/etherdevice.h>\n#include <linux/slab.h>\n#include \"rtl819x_TS.h\"\n\nstatic void TsSetupTimeOut(struct timer_list *unused)\n{\n\t\n\t\n}\n\nstatic void TsInactTimeout(struct timer_list *unused)\n{\n\t\n\t\n\t\n}\n\n \nstatic void RxPktPendingTimeout(struct timer_list *t)\n{\n\tstruct rx_ts_record     *pRxTs = from_timer(pRxTs, t, rx_pkt_pending_timer);\n\tstruct ieee80211_device *ieee = container_of(pRxTs, struct ieee80211_device, RxTsRecord[pRxTs->num]);\n\n\tstruct rx_reorder_entry\t*pReorderEntry = NULL;\n\n\t\n\tunsigned long flags = 0;\n\tu8 index = 0;\n\tbool bPktInBuf = false;\n\n\tspin_lock_irqsave(&(ieee->reorder_spinlock), flags);\n\tIEEE80211_DEBUG(IEEE80211_DL_REORDER, \"==================>%s()\\n\", __func__);\n\tif (pRxTs->rx_timeout_indicate_seq != 0xffff) {\n\t\t\n\t\twhile (!list_empty(&pRxTs->rx_pending_pkt_list)) {\n\t\t\tpReorderEntry = list_entry(pRxTs->rx_pending_pkt_list.prev, struct rx_reorder_entry, List);\n\t\t\tif (index == 0)\n\t\t\t\tpRxTs->rx_indicate_seq = pReorderEntry->SeqNum;\n\n\t\t\tif (SN_LESS(pReorderEntry->SeqNum, pRxTs->rx_indicate_seq) ||\n\t\t\t\tSN_EQUAL(pReorderEntry->SeqNum, pRxTs->rx_indicate_seq)) {\n\t\t\t\tlist_del_init(&pReorderEntry->List);\n\n\t\t\t\tif (SN_EQUAL(pReorderEntry->SeqNum, pRxTs->rx_indicate_seq))\n\t\t\t\t\tpRxTs->rx_indicate_seq = (pRxTs->rx_indicate_seq + 1) % 4096;\n\n\t\t\t\tIEEE80211_DEBUG(IEEE80211_DL_REORDER, \"%s: IndicateSeq: %d\\n\", __func__, pReorderEntry->SeqNum);\n\t\t\t\tieee->stats_IndicateArray[index] = pReorderEntry->prxb;\n\t\t\t\tindex++;\n\n\t\t\t\tlist_add_tail(&pReorderEntry->List, &ieee->RxReorder_Unused_List);\n\t\t\t} else {\n\t\t\t\tbPktInBuf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (index > 0) {\n\t\t\n\t\tpRxTs->rx_timeout_indicate_seq = 0xffff;\n\n\t\t\n\t\tif (index > REORDER_WIN_SIZE) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"RxReorderIndicatePacket(): Rx Reorder buffer full!! \\n\");\n\t\t\tspin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);\n\t\t\treturn;\n\t\t}\n\t\tieee80211_indicate_packets(ieee, ieee->stats_IndicateArray, index);\n\t}\n\n\tif (bPktInBuf && (pRxTs->rx_timeout_indicate_seq == 0xffff)) {\n\t\tpRxTs->rx_timeout_indicate_seq = pRxTs->rx_indicate_seq;\n\t\tmod_timer(&pRxTs->rx_pkt_pending_timer,\n\t\t\t  jiffies + msecs_to_jiffies(ieee->pHTInfo->RxReorderPendingTime));\n\t}\n\tspin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);\n}\n\n \nstatic void TsAddBaProcess(struct timer_list *t)\n{\n\tstruct tx_ts_record *pTxTs = from_timer(pTxTs, t, ts_add_ba_timer);\n\tu8 num = pTxTs->num;\n\tstruct ieee80211_device *ieee = container_of(pTxTs, struct ieee80211_device, TxTsRecord[num]);\n\n\tTsInitAddBA(ieee, pTxTs, BA_POLICY_IMMEDIATE, false);\n\tIEEE80211_DEBUG(IEEE80211_DL_BA, \"%s: ADDBA Req is started!! \\n\", __func__);\n}\n\n\nstatic void ResetTsCommonInfo(struct ts_common_info *pTsCommonInfo)\n{\n\teth_zero_addr(pTsCommonInfo->addr);\n\tmemset(&pTsCommonInfo->t_spec, 0, sizeof(struct tspec_body));\n\tmemset(&pTsCommonInfo->t_class, 0, sizeof(union qos_tclas) * TCLAS_NUM);\n\tpTsCommonInfo->t_clas_proc = 0;\n\tpTsCommonInfo->t_clas_num = 0;\n}\n\nstatic void ResetTxTsEntry(struct tx_ts_record *pTS)\n{\n\tResetTsCommonInfo(&pTS->ts_common_info);\n\tpTS->tx_cur_seq = 0;\n\tpTS->add_ba_req_in_progress = false;\n\tpTS->add_ba_req_delayed = false;\n\tpTS->using_ba = false;\n\tResetBaEntry(&pTS->tx_admitted_ba_record); \n\tResetBaEntry(&pTS->tx_pending_ba_record);\n}\n\nstatic void ResetRxTsEntry(struct rx_ts_record *pTS)\n{\n\tResetTsCommonInfo(&pTS->ts_common_info);\n\tpTS->rx_indicate_seq = 0xffff; \n\tpTS->rx_timeout_indicate_seq = 0xffff; \n\tResetBaEntry(&pTS->rx_admitted_ba_record);\t  \n}\n\nvoid TSInitialize(struct ieee80211_device *ieee)\n{\n\tstruct tx_ts_record     *pTxTS  = ieee->TxTsRecord;\n\tstruct rx_ts_record     *pRxTS  = ieee->RxTsRecord;\n\tstruct rx_reorder_entry\t*pRxReorderEntry = ieee->RxReorderEntry;\n\tu8\t\t\t\tcount = 0;\n\tIEEE80211_DEBUG(IEEE80211_DL_TS, \"==========>%s()\\n\", __func__);\n\t\n\tINIT_LIST_HEAD(&ieee->Tx_TS_Admit_List);\n\tINIT_LIST_HEAD(&ieee->Tx_TS_Pending_List);\n\tINIT_LIST_HEAD(&ieee->Tx_TS_Unused_List);\n\n\tfor (count = 0; count < TOTAL_TS_NUM; count++) {\n\t\t\n\t\tpTxTS->num = count;\n\t\t\n\t\t\n\t\ttimer_setup(&pTxTS->ts_common_info.setup_timer, TsSetupTimeOut,\n\t\t\t    0);\n\t\ttimer_setup(&pTxTS->ts_common_info.inact_timer, TsInactTimeout,\n\t\t\t    0);\n\t\ttimer_setup(&pTxTS->ts_add_ba_timer, TsAddBaProcess, 0);\n\t\ttimer_setup(&pTxTS->tx_pending_ba_record.timer, BaSetupTimeOut,\n\t\t\t    0);\n\t\ttimer_setup(&pTxTS->tx_admitted_ba_record.timer,\n\t\t\t    TxBaInactTimeout, 0);\n\t\tResetTxTsEntry(pTxTS);\n\t\tlist_add_tail(&pTxTS->ts_common_info.list, &ieee->Tx_TS_Unused_List);\n\t\tpTxTS++;\n\t}\n\n\t\n\tINIT_LIST_HEAD(&ieee->Rx_TS_Admit_List);\n\tINIT_LIST_HEAD(&ieee->Rx_TS_Pending_List);\n\tINIT_LIST_HEAD(&ieee->Rx_TS_Unused_List);\n\tfor (count = 0; count < TOTAL_TS_NUM; count++) {\n\t\tpRxTS->num = count;\n\t\tINIT_LIST_HEAD(&pRxTS->rx_pending_pkt_list);\n\t\ttimer_setup(&pRxTS->ts_common_info.setup_timer, TsSetupTimeOut,\n\t\t\t    0);\n\t\ttimer_setup(&pRxTS->ts_common_info.inact_timer, TsInactTimeout,\n\t\t\t    0);\n\t\ttimer_setup(&pRxTS->rx_admitted_ba_record.timer,\n\t\t\t    RxBaInactTimeout, 0);\n\t\ttimer_setup(&pRxTS->rx_pkt_pending_timer, RxPktPendingTimeout, 0);\n\t\tResetRxTsEntry(pRxTS);\n\t\tlist_add_tail(&pRxTS->ts_common_info.list, &ieee->Rx_TS_Unused_List);\n\t\tpRxTS++;\n\t}\n\t\n\tINIT_LIST_HEAD(&ieee->RxReorder_Unused_List);\n\tfor (count = 0; count < REORDER_ENTRY_NUM; count++) {\n\t\tlist_add_tail(&pRxReorderEntry->List, &ieee->RxReorder_Unused_List);\n\t\tif (count == (REORDER_ENTRY_NUM - 1))\n\t\t\tbreak;\n\t\tpRxReorderEntry = &ieee->RxReorderEntry[count + 1];\n\t}\n}\n\nstatic void AdmitTS(struct ieee80211_device *ieee,\n\t\t    struct ts_common_info *pTsCommonInfo, u32 InactTime)\n{\n\tdel_timer_sync(&pTsCommonInfo->setup_timer);\n\tdel_timer_sync(&pTsCommonInfo->inact_timer);\n\n\tif (InactTime != 0)\n\t\tmod_timer(&pTsCommonInfo->inact_timer,\n\t\t\t  jiffies + msecs_to_jiffies(InactTime));\n}\n\n\nstatic struct ts_common_info *SearchAdmitTRStream(struct ieee80211_device *ieee,\n\t\t\t\t\t\t  u8 *Addr, u8 TID,\n\t\t\t\t\t\t  enum tr_select TxRxSelect)\n{\n\t\n\tu8\tdir;\n\tbool\t\t\t\tsearch_dir[4] = {0};\n\tstruct list_head\t\t*psearch_list; \n\tstruct ts_common_info\t*pRet = NULL;\n\tif (ieee->iw_mode == IW_MODE_MASTER) { \n\t\tif (TxRxSelect == TX_DIR) {\n\t\t\tsearch_dir[DIR_DOWN] = true;\n\t\t\tsearch_dir[DIR_BI_DIR] = true;\n\t\t} else {\n\t\t\tsearch_dir[DIR_UP]\t= true;\n\t\t\tsearch_dir[DIR_BI_DIR] = true;\n\t\t}\n\t} else if (ieee->iw_mode == IW_MODE_ADHOC) {\n\t\tif (TxRxSelect == TX_DIR)\n\t\t\tsearch_dir[DIR_UP]\t= true;\n\t\telse\n\t\t\tsearch_dir[DIR_DOWN] = true;\n\t} else {\n\t\tif (TxRxSelect == TX_DIR) {\n\t\t\tsearch_dir[DIR_UP]\t= true;\n\t\t\tsearch_dir[DIR_BI_DIR] = true;\n\t\t\tsearch_dir[DIR_DIRECT] = true;\n\t\t} else {\n\t\t\tsearch_dir[DIR_DOWN] = true;\n\t\t\tsearch_dir[DIR_BI_DIR] = true;\n\t\t\tsearch_dir[DIR_DIRECT] = true;\n\t\t}\n\t}\n\n\tif (TxRxSelect == TX_DIR)\n\t\tpsearch_list = &ieee->Tx_TS_Admit_List;\n\telse\n\t\tpsearch_list = &ieee->Rx_TS_Admit_List;\n\n\t\n\tfor (dir = 0; dir <= DIR_BI_DIR; dir++) {\n\t\tif (!search_dir[dir])\n\t\t\tcontinue;\n\t\tlist_for_each_entry(pRet, psearch_list, list) {\n\t\n\t\t\tif (memcmp(pRet->addr, Addr, 6) == 0)\n\t\t\t\tif (pRet->t_spec.ts_info.uc_tsid == TID)\n\t\t\t\t\tif (pRet->t_spec.ts_info.uc_direction == dir) {\n\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t}\n\t\tif (&pRet->list  != psearch_list)\n\t\t\tbreak;\n\t}\n\n\tif (&pRet->list  != psearch_list)\n\t\treturn pRet;\n\telse\n\t\treturn NULL;\n}\n\nstatic void MakeTSEntry(struct ts_common_info *pTsCommonInfo, u8 *Addr,\n\t\t\tstruct tspec_body *pTSPEC, union qos_tclas *pTCLAS, u8 TCLAS_Num,\n\t\t\tu8 TCLAS_Proc)\n{\n\tu8\tcount;\n\n\tif (pTsCommonInfo == NULL)\n\t\treturn;\n\n\tmemcpy(pTsCommonInfo->addr, Addr, 6);\n\n\tif (pTSPEC != NULL)\n\t\tmemcpy((u8 *)(&(pTsCommonInfo->t_spec)), (u8 *)pTSPEC, sizeof(struct tspec_body));\n\n\tfor (count = 0; count < TCLAS_Num; count++)\n\t\tmemcpy((u8 *)(&(pTsCommonInfo->t_class[count])), (u8 *)pTCLAS, sizeof(union qos_tclas));\n\n\tpTsCommonInfo->t_clas_proc = TCLAS_Proc;\n\tpTsCommonInfo->t_clas_num = TCLAS_Num;\n}\n\n\nbool GetTs(\n\tstruct ieee80211_device\t\t*ieee,\n\tstruct ts_common_info\t\t**ppTS,\n\tu8\t\t\t\t*Addr,\n\tu8\t\t\t\tTID,\n\tenum tr_select\t\t\tTxRxSelect,  \n\tbool\t\t\t\tbAddNewTs\n\t)\n{\n\tu8\tUP = 0;\n\t\n\t\n\t\n\t\n\tif (is_multicast_ether_addr(Addr)) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"get TS for Broadcast or Multicast\\n\");\n\t\treturn false;\n\t}\n\n\tif (ieee->current_network.qos_data.supported == 0) {\n\t\tUP = 0;\n\t} else {\n\t\t\n\t\tif (!is_ac_valid(TID)) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \" in %s(), TID(%d) is not valid\\n\", __func__, TID);\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch (TID) {\n\t\tcase 0:\n\t\tcase 3:\n\t\t\tUP = 0;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tUP = 2;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\tcase 5:\n\t\t\tUP = 5;\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\tcase 7:\n\t\t\tUP = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*ppTS = SearchAdmitTRStream(\n\t\t\tieee,\n\t\t\tAddr,\n\t\t\tUP,\n\t\t\tTxRxSelect);\n\tif (*ppTS != NULL) {\n\t\treturn true;\n\t} else {\n\t\tif (!bAddNewTs) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_TS, \"add new TS failed(tid:%d)\\n\", UP);\n\t\t\treturn false;\n\t\t} else {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tstruct tspec_body\tTSpec;\n\t\t\tstruct qos_tsinfo\t*pTSInfo = &TSpec.ts_info;\n\t\t\tstruct list_head\t*pUnusedList =\n\t\t\t\t\t\t\t\t(TxRxSelect == TX_DIR) ?\n\t\t\t\t\t\t\t\t(&ieee->Tx_TS_Unused_List) :\n\t\t\t\t\t\t\t\t(&ieee->Rx_TS_Unused_List);\n\n\t\t\tstruct list_head\t*pAddmitList =\n\t\t\t\t\t\t\t\t(TxRxSelect == TX_DIR) ?\n\t\t\t\t\t\t\t\t(&ieee->Tx_TS_Admit_List) :\n\t\t\t\t\t\t\t\t(&ieee->Rx_TS_Admit_List);\n\n\t\t\tenum direction_value\tDir =\t\t(ieee->iw_mode == IW_MODE_MASTER) ?\n\t\t\t\t\t\t\t\t((TxRxSelect == TX_DIR) ? DIR_DOWN : DIR_UP) :\n\t\t\t\t\t\t\t\t((TxRxSelect == TX_DIR) ? DIR_UP : DIR_DOWN);\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_TS, \"to add Ts\\n\");\n\t\t\tif (!list_empty(pUnusedList)) {\n\t\t\t\t(*ppTS) = list_entry(pUnusedList->next, struct ts_common_info, list);\n\t\t\t\tlist_del_init(&(*ppTS)->list);\n\t\t\t\tif (TxRxSelect == TX_DIR) {\n\t\t\t\t\tstruct tx_ts_record *tmp = container_of(*ppTS, struct tx_ts_record, ts_common_info);\n\t\t\t\t\tResetTxTsEntry(tmp);\n\t\t\t\t} else {\n\t\t\t\t\tstruct rx_ts_record *tmp = container_of(*ppTS, struct rx_ts_record, ts_common_info);\n\t\t\t\t\tResetRxTsEntry(tmp);\n\t\t\t\t}\n\n\t\t\t\tIEEE80211_DEBUG(IEEE80211_DL_TS, \"to init current TS, UP:%d, Dir:%d, addr:%pM\\n\", UP, Dir, Addr);\n\t\t\t\t\n\t\t\t\tpTSInfo->uc_traffic_type = 0;\t\t\n\t\t\t\tpTSInfo->uc_tsid = UP;\t\t\t\n\t\t\t\tpTSInfo->uc_direction = Dir;\t\t\n\t\t\t\tpTSInfo->uc_access_policy = 1;\t\t\n\t\t\t\tpTSInfo->uc_aggregation = 0;\t\t\n\t\t\t\tpTSInfo->uc_psb = 0;\t\t\t\n\t\t\t\tpTSInfo->uc_up = UP;\t\t\t\n\t\t\t\tpTSInfo->uc_ts_info_ack_policy = 0;\t\n\t\t\t\tpTSInfo->uc_schedule = 0;\t\t\n\n\t\t\t\tMakeTSEntry(*ppTS, Addr, &TSpec, NULL, 0, 0);\n\t\t\t\tAdmitTS(ieee, *ppTS, 0);\n\t\t\t\tlist_add_tail(&((*ppTS)->list), pAddmitList);\n\t\t\t\t\n\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"in function %s() There is not enough TS record to be used!!\", __func__);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void RemoveTsEntry(struct ieee80211_device *ieee, struct ts_common_info *pTs,\n\t\t\t  enum tr_select TxRxSelect)\n{\n\t\n\tunsigned long flags = 0;\n\tdel_timer_sync(&pTs->setup_timer);\n\tdel_timer_sync(&pTs->inact_timer);\n\tTsInitDelBA(ieee, pTs, TxRxSelect);\n\n\tif (TxRxSelect == RX_DIR) {\n\t\tstruct rx_reorder_entry\t*pRxReorderEntry;\n\t\tstruct rx_ts_record     *pRxTS = (struct rx_ts_record *)pTs;\n\t\tif (timer_pending(&pRxTS->rx_pkt_pending_timer))\n\t\t\tdel_timer_sync(&pRxTS->rx_pkt_pending_timer);\n\n\t\twhile (!list_empty(&pRxTS->rx_pending_pkt_list)) {\n\t\t\tspin_lock_irqsave(&(ieee->reorder_spinlock), flags);\n\t\t\t\n\t\t\tpRxReorderEntry = list_entry(pRxTS->rx_pending_pkt_list.prev, struct rx_reorder_entry, List);\n\t\t\tlist_del_init(&pRxReorderEntry->List);\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\tstruct ieee80211_rxb *prxb = pRxReorderEntry->prxb;\n\t\t\t\tif (unlikely(!prxb)) {\n\t\t\t\t\tspin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (i =  0; i < prxb->nr_subframes; i++)\n\t\t\t\t\tdev_kfree_skb(prxb->subframes[i]);\n\n\t\t\t\tkfree(prxb);\n\t\t\t\tprxb = NULL;\n\t\t\t}\n\t\t\tlist_add_tail(&pRxReorderEntry->List, &ieee->RxReorder_Unused_List);\n\t\t\tspin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);\n\t\t}\n\n\t} else {\n\t\tstruct tx_ts_record *pTxTS = (struct tx_ts_record *)pTs;\n\t\tdel_timer_sync(&pTxTS->ts_add_ba_timer);\n\t}\n}\n\nvoid RemovePeerTS(struct ieee80211_device *ieee, u8 *Addr)\n{\n\tstruct ts_common_info\t*pTS, *pTmpTS;\n\n\tprintk(\"===========>%s,%pM\\n\", __func__, Addr);\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Pending_List, list) {\n\t\tif (memcmp(pTS->addr, Addr, 6) == 0) {\n\t\t\tRemoveTsEntry(ieee, pTS, TX_DIR);\n\t\t\tlist_del_init(&pTS->list);\n\t\t\tlist_add_tail(&pTS->list, &ieee->Tx_TS_Unused_List);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Admit_List, list) {\n\t\tif (memcmp(pTS->addr, Addr, 6) == 0) {\n\t\t\tprintk(\"====>remove Tx_TS_admin_list\\n\");\n\t\t\tRemoveTsEntry(ieee, pTS, TX_DIR);\n\t\t\tlist_del_init(&pTS->list);\n\t\t\tlist_add_tail(&pTS->list, &ieee->Tx_TS_Unused_List);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Rx_TS_Pending_List, list) {\n\t\tif (memcmp(pTS->addr, Addr, 6) == 0) {\n\t\t\tRemoveTsEntry(ieee, pTS, RX_DIR);\n\t\t\tlist_del_init(&pTS->list);\n\t\t\tlist_add_tail(&pTS->list, &ieee->Rx_TS_Unused_List);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Rx_TS_Admit_List, list) {\n\t\tif (memcmp(pTS->addr, Addr, 6) == 0) {\n\t\t\tRemoveTsEntry(ieee, pTS, RX_DIR);\n\t\t\tlist_del_init(&pTS->list);\n\t\t\tlist_add_tail(&pTS->list, &ieee->Rx_TS_Unused_List);\n\t\t}\n\t}\n}\n\nvoid RemoveAllTS(struct ieee80211_device *ieee)\n{\n\tstruct ts_common_info *pTS, *pTmpTS;\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Pending_List, list) {\n\t\tRemoveTsEntry(ieee, pTS, TX_DIR);\n\t\tlist_del_init(&pTS->list);\n\t\tlist_add_tail(&pTS->list, &ieee->Tx_TS_Unused_List);\n\t}\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Admit_List, list) {\n\t\tRemoveTsEntry(ieee, pTS, TX_DIR);\n\t\tlist_del_init(&pTS->list);\n\t\tlist_add_tail(&pTS->list, &ieee->Tx_TS_Unused_List);\n\t}\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Rx_TS_Pending_List, list) {\n\t\tRemoveTsEntry(ieee, pTS, RX_DIR);\n\t\tlist_del_init(&pTS->list);\n\t\tlist_add_tail(&pTS->list, &ieee->Rx_TS_Unused_List);\n\t}\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Rx_TS_Admit_List, list) {\n\t\tRemoveTsEntry(ieee, pTS, RX_DIR);\n\t\tlist_del_init(&pTS->list);\n\t\tlist_add_tail(&pTS->list, &ieee->Rx_TS_Unused_List);\n\t}\n}\n\nvoid TsStartAddBaProcess(struct ieee80211_device *ieee, struct tx_ts_record *pTxTS)\n{\n\tif (!pTxTS->add_ba_req_in_progress) {\n\t\tpTxTS->add_ba_req_in_progress = true;\n\t\tif (pTxTS->add_ba_req_delayed)\t{\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_BA, \"%s: Delayed Start ADDBA after 60 sec!!\\n\", __func__);\n\t\t\tmod_timer(&pTxTS->ts_add_ba_timer,\n\t\t\t\t  jiffies + msecs_to_jiffies(TS_ADDBA_DELAY));\n\t\t} else {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_BA, \"%s: Immediately Start ADDBA now!!\\n\", __func__);\n\t\t\tmod_timer(&pTxTS->ts_add_ba_timer, jiffies + 10); \n\t\t}\n\t} else {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"%s()==>BA timer is already added\\n\", __func__);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}