{
  "module_name": "rtl819x_BAProc.c",
  "hash_id": "a8d7ddd978ce6d3960e868297eba0d17dcb08b93905a9583d3bd3c99da138b58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/ieee80211/rtl819x_BAProc.c",
  "human_readable_source": "\n \n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include \"ieee80211.h\"\n#include \"rtl819x_BA.h\"\n\n \nstatic void ActivateBAEntry(struct ieee80211_device *ieee, struct ba_record *pBA, u16 Time)\n{\n\tpBA->valid = true;\n\tif (Time != 0)\n\t\tmod_timer(&pBA->timer, jiffies + msecs_to_jiffies(Time));\n}\n\n \nstatic void DeActivateBAEntry(struct ieee80211_device *ieee, struct ba_record *pBA)\n{\n\tpBA->valid = false;\n\tdel_timer_sync(&pBA->timer);\n}\n \nstatic u8 TxTsDeleteBA(struct ieee80211_device *ieee, struct tx_ts_record *pTxTs)\n{\n\tstruct ba_record *pAdmittedBa = &pTxTs->tx_admitted_ba_record;  \n\tstruct ba_record *pPendingBa = &pTxTs->tx_pending_ba_record;\n\tu8\t\t\tbSendDELBA = false;\n\n\t\n\tif (pPendingBa->valid) {\n\t\tDeActivateBAEntry(ieee, pPendingBa);\n\t\tbSendDELBA = true;\n\t}\n\n\t\n\tif (pAdmittedBa->valid) {\n\t\tDeActivateBAEntry(ieee, pAdmittedBa);\n\t\tbSendDELBA = true;\n\t}\n\n\treturn bSendDELBA;\n}\n\n \nstatic u8 RxTsDeleteBA(struct ieee80211_device *ieee, struct rx_ts_record *pRxTs)\n{\n\tstruct ba_record       *pBa = &pRxTs->rx_admitted_ba_record;\n\tu8\t\t\tbSendDELBA = false;\n\n\tif (pBa->valid) {\n\t\tDeActivateBAEntry(ieee, pBa);\n\t\tbSendDELBA = true;\n\t}\n\n\treturn bSendDELBA;\n}\n\n \nvoid ResetBaEntry(struct ba_record *pBA)\n{\n\tpBA->valid\t\t\t= false;\n\tpBA->param_set.short_data\t= 0;\n\tpBA->timeout_value\t\t= 0;\n\tpBA->dialog_token\t\t= 0;\n\tpBA->start_seq_ctrl.short_data\t= 0;\n}\n\n \nstatic struct sk_buff *ieee80211_ADDBA(struct ieee80211_device *ieee, u8 *Dst, struct ba_record *pBA, u16 StatusCode, u8 type)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct rtl_80211_hdr_3addr *BAReq = NULL;\n\tu8 *tag = NULL;\n\tu16 len = ieee->tx_headroom + 9;\n\t\n\tIEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, \"========>%s(), frame(%d) sentd to:%pM, ieee->dev:%p\\n\", __func__, type, Dst, ieee->dev);\n\tif (pBA == NULL) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"pBA is NULL\\n\");\n\t\treturn NULL;\n\t}\n\tskb = dev_alloc_skb(len + sizeof(struct rtl_80211_hdr_3addr)); \n\tif (!skb)\n\t\treturn NULL;\n\n\tmemset(skb->data, 0, sizeof(struct rtl_80211_hdr_3addr));\t\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\tBAReq = skb_put(skb, sizeof(struct rtl_80211_hdr_3addr));\n\n\tmemcpy(BAReq->addr1, Dst, ETH_ALEN);\n\tmemcpy(BAReq->addr2, ieee->dev->dev_addr, ETH_ALEN);\n\n\tmemcpy(BAReq->addr3, ieee->current_network.bssid, ETH_ALEN);\n\n\tBAReq->frame_ctl = cpu_to_le16(IEEE80211_STYPE_MANAGE_ACT); \n\n\t\n\ttag = skb_put(skb, 9);\n\t*tag++ = ACT_CAT_BA;\n\t*tag++ = type;\n\t\n\t*tag++ = pBA->dialog_token;\n\n\tif (type == ACT_ADDBARSP) {\n\t\t\n\t\tnetdev_info(ieee->dev, \"=====>to send ADDBARSP\\n\");\n\n\t\tput_unaligned_le16(StatusCode, tag);\n\t\ttag += 2;\n\t}\n\t\n\n\tput_unaligned_le16(pBA->param_set.short_data, tag);\n\ttag += 2;\n\t\n\n\tput_unaligned_le16(pBA->timeout_value, tag);\n\ttag += 2;\n\n\tif (type == ACT_ADDBAREQ) {\n\t\n\t\tmemcpy(tag, (u8 *)&(pBA->start_seq_ctrl), 2);\n\t\ttag += 2;\n\t}\n\n\tIEEE80211_DEBUG_DATA(IEEE80211_DL_DATA | IEEE80211_DL_BA, skb->data, skb->len);\n\treturn skb;\n\t\n}\n\n\n \nstatic struct sk_buff *ieee80211_DELBA(\n\tstruct ieee80211_device  *ieee,\n\tu8\t\t         *dst,\n\tstruct ba_record         *pBA,\n\tenum tr_select\t\t TxRxSelect,\n\tu16\t\t\t ReasonCode\n\t)\n{\n\tunion delba_param_set\tDelbaParamSet;\n\tstruct sk_buff *skb = NULL;\n\tstruct rtl_80211_hdr_3addr *Delba = NULL;\n\tu8 *tag = NULL;\n\t\n\tu16 len = 6 + ieee->tx_headroom;\n\n\tif (net_ratelimit())\n\t\tIEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA,\n\t\t\t\t\"========>%s(), ReasonCode(%d) sentd to:%pM\\n\",\n\t\t\t\t__func__, ReasonCode, dst);\n\n\tmemset(&DelbaParamSet, 0, 2);\n\n\tDelbaParamSet.field.initiator\t= (TxRxSelect == TX_DIR) ? 1 : 0;\n\tDelbaParamSet.field.tid\t= pBA->param_set.field.tid;\n\n\tskb = dev_alloc_skb(len + sizeof(struct rtl_80211_hdr_3addr)); \n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\tDelba = skb_put(skb, sizeof(struct rtl_80211_hdr_3addr));\n\n\tmemcpy(Delba->addr1, dst, ETH_ALEN);\n\tmemcpy(Delba->addr2, ieee->dev->dev_addr, ETH_ALEN);\n\tmemcpy(Delba->addr3, ieee->current_network.bssid, ETH_ALEN);\n\tDelba->frame_ctl = cpu_to_le16(IEEE80211_STYPE_MANAGE_ACT); \n\n\ttag = skb_put(skb, 6);\n\n\t*tag++ = ACT_CAT_BA;\n\t*tag++ = ACT_DELBA;\n\n\t\n\n\tput_unaligned_le16(DelbaParamSet.short_data, tag);\n\ttag += 2;\n\t\n\n\tput_unaligned_le16(ReasonCode, tag);\n\ttag += 2;\n\n\tIEEE80211_DEBUG_DATA(IEEE80211_DL_DATA | IEEE80211_DL_BA, skb->data, skb->len);\n\tif (net_ratelimit())\n\t\tIEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA,\n\t\t\t\t\"<=====%s()\\n\", __func__);\n\treturn skb;\n}\n\n \nstatic void ieee80211_send_ADDBAReq(struct ieee80211_device *ieee,\n\t\t\t\t    u8 *dst, struct ba_record *pBA)\n{\n\tstruct sk_buff *skb;\n\tskb = ieee80211_ADDBA(ieee, dst, pBA, 0, ACT_ADDBAREQ); \n\n\tif (skb) {\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\t\n\t\t\n\t\t\n\t} else {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"alloc skb error in function %s()\\n\", __func__);\n\t}\n}\n\n \nstatic void ieee80211_send_ADDBARsp(struct ieee80211_device *ieee, u8 *dst,\n\t\t\t\t    struct ba_record *pBA, u16 StatusCode)\n{\n\tstruct sk_buff *skb;\n\tskb = ieee80211_ADDBA(ieee, dst, pBA, StatusCode, ACT_ADDBARSP); \n\tif (skb) {\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\t\n\t} else {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"alloc skb error in function %s()\\n\", __func__);\n\t}\n\n\treturn;\n\n}\n \n\nstatic void ieee80211_send_DELBA(struct ieee80211_device *ieee, u8 *dst,\n\t\t\t\t struct ba_record *pBA, enum tr_select TxRxSelect,\n\t\t\t\t u16 ReasonCode)\n{\n\tstruct sk_buff *skb;\n\tskb = ieee80211_DELBA(ieee, dst, pBA, TxRxSelect, ReasonCode); \n\tif (skb) {\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\t\n\t} else {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"alloc skb error in function %s()\\n\", __func__);\n\t}\n}\n\n \nint ieee80211_rx_ADDBAReq(struct ieee80211_device *ieee, struct sk_buff *skb)\n{\n\tstruct rtl_80211_hdr_3addr *req = NULL;\n\tu16 rc = 0;\n\tu8 *dst = NULL, *pDialogToken = NULL, *tag = NULL;\n\tstruct ba_record *pBA = NULL;\n\tunion ba_param_set     *pBaParamSet = NULL;\n\tu16 *pBaTimeoutVal = NULL;\n\tunion sequence_control *pBaStartSeqCtrl = NULL;\n\tstruct rx_ts_record  *pTS = NULL;\n\n\tif (skb->len < sizeof(struct rtl_80211_hdr_3addr) + 9) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR,\n\t\t\t\t\" Invalid skb len in BAREQ(%d / %zu)\\n\",\n\t\t\t\tskb->len,\n\t\t\t\t(sizeof(struct rtl_80211_hdr_3addr) + 9));\n\t\treturn -1;\n\t}\n\n\tIEEE80211_DEBUG_DATA(IEEE80211_DL_DATA | IEEE80211_DL_BA, skb->data, skb->len);\n\n\treq = (struct rtl_80211_hdr_3addr *)skb->data;\n\ttag = (u8 *)req;\n\tdst = &req->addr2[0];\n\ttag += sizeof(struct rtl_80211_hdr_3addr);\n\tpDialogToken = tag + 2;  \n\tpBaParamSet = (union ba_param_set *)(tag + 3);   \n\tpBaTimeoutVal = (u16 *)(tag + 5);\n\tpBaStartSeqCtrl = (union sequence_control *)(req + 7);\n\n\tnetdev_info(ieee->dev, \"====================>rx ADDBAREQ from :%pM\\n\", dst);\n\n\tif ((ieee->current_network.qos_data.active == 0) ||\n\t\t(!ieee->pHTInfo->bCurrentHTSupport)) \n\t\n\t{\n\t\trc = ADDBA_STATUS_REFUSED;\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"Failed to reply on ADDBA_REQ as some capability is not ready(%d, %d)\\n\", ieee->current_network.qos_data.active, ieee->pHTInfo->bCurrentHTSupport);\n\t\tgoto OnADDBAReq_Fail;\n\t}\n\t\n\t\n\tif (!GetTs(\n\t\t\tieee,\n\t\t\t(struct ts_common_info **)(&pTS),\n\t\t\tdst,\n\t\t\t(u8)(pBaParamSet->field.tid),\n\t\t\tRX_DIR,\n\t\t\ttrue)) {\n\t\trc = ADDBA_STATUS_REFUSED;\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"can't get TS in %s()\\n\", __func__);\n\t\tgoto OnADDBAReq_Fail;\n\t}\n\tpBA = &pTS->rx_admitted_ba_record;\n\t\n\t\n\t\n\t\n\tif (pBaParamSet->field.ba_policy == BA_POLICY_DELAYED) {\n\t\trc = ADDBA_STATUS_INVALID_PARAM;\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"BA Policy is not correct in %s()\\n\", __func__);\n\t\tgoto OnADDBAReq_Fail;\n\t}\n\t\t\n\t\n\tDeActivateBAEntry(ieee, pBA);\n\tpBA->dialog_token = *pDialogToken;\n\tpBA->param_set = *pBaParamSet;\n\tpBA->timeout_value = *pBaTimeoutVal;\n\tpBA->start_seq_ctrl = *pBaStartSeqCtrl;\n\t\n\tif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))\n\t\tpBA->param_set.field.buffer_size = 1;\n\telse\n\t\tpBA->param_set.field.buffer_size = 32;\n\tActivateBAEntry(ieee, pBA, pBA->timeout_value);\n\tieee80211_send_ADDBARsp(ieee, dst, pBA, ADDBA_STATUS_SUCCESS);\n\n\t\n\treturn 0;\n\nOnADDBAReq_Fail:\n\t{\n\t\tstruct ba_record\tBA;\n\t\tBA.param_set = *pBaParamSet;\n\t\tBA.timeout_value = *pBaTimeoutVal;\n\t\tBA.dialog_token = *pDialogToken;\n\t\tBA.param_set.field.ba_policy = BA_POLICY_IMMEDIATE;\n\t\tieee80211_send_ADDBARsp(ieee, dst, &BA, rc);\n\t\treturn 0; \n\t}\n\n}\n\n \nint ieee80211_rx_ADDBARsp(struct ieee80211_device *ieee, struct sk_buff *skb)\n{\n\tstruct rtl_80211_hdr_3addr *rsp = NULL;\n\tstruct ba_record        *pPendingBA, *pAdmittedBA;\n\tstruct tx_ts_record     *pTS = NULL;\n\tu8 *dst = NULL, *pDialogToken = NULL, *tag = NULL;\n\tu16 *pStatusCode = NULL, *pBaTimeoutVal = NULL;\n\tunion ba_param_set       *pBaParamSet = NULL;\n\tu16\t\t\tReasonCode;\n\n\tif (skb->len < sizeof(struct rtl_80211_hdr_3addr) + 9) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR,\n\t\t\t\t\" Invalid skb len in BARSP(%d / %zu)\\n\",\n\t\t\t\tskb->len,\n\t\t\t\t(sizeof(struct rtl_80211_hdr_3addr) + 9));\n\t\treturn -1;\n\t}\n\trsp = (struct rtl_80211_hdr_3addr *)skb->data;\n\ttag = (u8 *)rsp;\n\tdst = &rsp->addr2[0];\n\ttag += sizeof(struct rtl_80211_hdr_3addr);\n\tpDialogToken = tag + 2;\n\tpStatusCode = (u16 *)(tag + 3);\n\tpBaParamSet = (union ba_param_set *)(tag + 5);\n\tpBaTimeoutVal = (u16 *)(tag + 7);\n\n\t\n\t\n\tif (ieee->current_network.qos_data.active == 0  ||\n\t    !ieee->pHTInfo->bCurrentHTSupport ||\n\t    !ieee->pHTInfo->bCurrentAMPDUEnable) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"reject to ADDBA_RSP as some capability is not ready(%d, %d, %d)\\n\", ieee->current_network.qos_data.active, ieee->pHTInfo->bCurrentHTSupport, ieee->pHTInfo->bCurrentAMPDUEnable);\n\t\tReasonCode = DELBA_REASON_UNKNOWN_BA;\n\t\tgoto OnADDBARsp_Reject;\n\t}\n\n\n\t\n\t\n\t\n\t\n\tif (!GetTs(\n\t\t\tieee,\n\t\t\t(struct ts_common_info **)(&pTS),\n\t\t\tdst,\n\t\t\t(u8)(pBaParamSet->field.tid),\n\t\t\tTX_DIR,\n\t\t\tfalse)) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"can't get TS in %s()\\n\", __func__);\n\t\tReasonCode = DELBA_REASON_UNKNOWN_BA;\n\t\tgoto OnADDBARsp_Reject;\n\t}\n\n\tpTS->add_ba_req_in_progress = false;\n\tpPendingBA = &pTS->tx_pending_ba_record;\n\tpAdmittedBA = &pTS->tx_admitted_ba_record;\n\n\n\t\n\t\n\t\n\t\n\tif (pAdmittedBA->valid) {\n\t\t\n\t\tIEEE80211_DEBUG(IEEE80211_DL_BA, \"OnADDBARsp(): Recv ADDBA Rsp. Drop because already admit it! \\n\");\n\t\treturn -1;\n\t} else if ((!pPendingBA->valid) || (*pDialogToken != pPendingBA->dialog_token)) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR,  \"OnADDBARsp(): Recv ADDBA Rsp. BA invalid, DELBA! \\n\");\n\t\tReasonCode = DELBA_REASON_UNKNOWN_BA;\n\t\tgoto OnADDBARsp_Reject;\n\t} else {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_BA, \"OnADDBARsp(): Recv ADDBA Rsp. BA is admitted! Status code:%X\\n\", *pStatusCode);\n\t\tDeActivateBAEntry(ieee, pPendingBA);\n\t}\n\n\n\tif (*pStatusCode == ADDBA_STATUS_SUCCESS) {\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif (pBaParamSet->field.ba_policy == BA_POLICY_DELAYED) {\n\t\t\t\n\t\t\tpTS->add_ba_req_delayed = true;\n\t\t\tDeActivateBAEntry(ieee, pAdmittedBA);\n\t\t\tReasonCode = DELBA_REASON_END_BA;\n\t\t\tgoto OnADDBARsp_Reject;\n\t\t}\n\n\n\t\t\n\t\t\n\t\t\n\t\tpAdmittedBA->dialog_token = *pDialogToken;\n\t\tpAdmittedBA->timeout_value = *pBaTimeoutVal;\n\t\tpAdmittedBA->start_seq_ctrl = pPendingBA->start_seq_ctrl;\n\t\tpAdmittedBA->param_set = *pBaParamSet;\n\t\tDeActivateBAEntry(ieee, pAdmittedBA);\n\t\tActivateBAEntry(ieee, pAdmittedBA, *pBaTimeoutVal);\n\t} else {\n\t\t\n\t\tpTS->add_ba_req_delayed = true;\n\t}\n\n\t\n\treturn 0;\n\nOnADDBARsp_Reject:\n\t{\n\t\tstruct ba_record\tBA;\n\t\tBA.param_set = *pBaParamSet;\n\t\tieee80211_send_DELBA(ieee, dst, &BA, TX_DIR, ReasonCode);\n\t\treturn 0;\n\t}\n\n}\n\n \nint ieee80211_rx_DELBA(struct ieee80211_device *ieee, struct sk_buff *skb)\n{\n\tstruct rtl_80211_hdr_3addr *delba = NULL;\n\tunion delba_param_set   *pDelBaParamSet = NULL;\n\tu8\t\t\t*dst = NULL;\n\n\tif (skb->len < sizeof(struct rtl_80211_hdr_3addr) + 6) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR,\n\t\t\t\t\" Invalid skb len in DELBA(%d / %zu)\\n\",\n\t\t\t\tskb->len,\n\t\t\t\t(sizeof(struct rtl_80211_hdr_3addr) + 6));\n\t\treturn -1;\n\t}\n\n\tif (ieee->current_network.qos_data.active == 0 ||\n\t    !ieee->pHTInfo->bCurrentHTSupport) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"received DELBA while QOS or HT is not supported(%d, %d)\\n\", ieee->current_network.qos_data.active, ieee->pHTInfo->bCurrentHTSupport);\n\t\treturn -1;\n\t}\n\n\tIEEE80211_DEBUG_DATA(IEEE80211_DL_DATA | IEEE80211_DL_BA, skb->data, skb->len);\n\tdelba = (struct rtl_80211_hdr_3addr *)skb->data;\n\tdst = &delba->addr2[0];\n\tpDelBaParamSet = (union delba_param_set *)&delba->payload[2];\n\n\tif (pDelBaParamSet->field.initiator == 1) {\n\t\tstruct rx_ts_record *pRxTs;\n\n\t\tif (!GetTs(\n\t\t\t\tieee,\n\t\t\t\t(struct ts_common_info **)&pRxTs,\n\t\t\t\tdst,\n\t\t\t\t(u8)pDelBaParamSet->field.tid,\n\t\t\t\tRX_DIR,\n\t\t\t\tfalse)) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR,  \"can't get TS for RXTS in %s()\\n\", __func__);\n\t\t\treturn -1;\n\t\t}\n\n\t\tRxTsDeleteBA(ieee, pRxTs);\n\t} else {\n\t\tstruct tx_ts_record *pTxTs;\n\n\t\tif (!GetTs(\n\t\t\tieee,\n\t\t\t(struct ts_common_info **)&pTxTs,\n\t\t\tdst,\n\t\t\t(u8)pDelBaParamSet->field.tid,\n\t\t\tTX_DIR,\n\t\t\tfalse)) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR,  \"can't get TS for TXTS in %s()\\n\", __func__);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpTxTs->using_ba = false;\n\t\tpTxTs->add_ba_req_in_progress = false;\n\t\tpTxTs->add_ba_req_delayed = false;\n\t\tdel_timer_sync(&pTxTs->ts_add_ba_timer);\n\t\t\n\t\tTxTsDeleteBA(ieee, pTxTs);\n\t}\n\treturn 0;\n}\n\n\n\n\nvoid\nTsInitAddBA(\n\tstruct ieee80211_device *ieee,\n\tstruct tx_ts_record     *pTS,\n\tu8\t\tPolicy,\n\tu8\t\tbOverwritePending\n\t)\n{\n\tstruct ba_record *pBA = &pTS->tx_pending_ba_record;\n\n\tif (pBA->valid && !bOverwritePending)\n\t\treturn;\n\n\t\n\tDeActivateBAEntry(ieee, pBA);\n\n\tpBA->dialog_token++;\t\t\t\t\t\t\n\tpBA->param_set.field.amsdu_support = 0;\t\n\tpBA->param_set.field.ba_policy = Policy;\t\n\tpBA->param_set.field.tid = pTS->ts_common_info.t_spec.ts_info.uc_tsid;\t\n\t\n\tpBA->param_set.field.buffer_size = 32;\t\t\n\tpBA->timeout_value = 0;\t\t\t\t\t\n\tpBA->start_seq_ctrl.field.seq_num = (pTS->tx_cur_seq + 3) % 4096;\t\n\n\tActivateBAEntry(ieee, pBA, BA_SETUP_TIMEOUT);\n\n\tieee80211_send_ADDBAReq(ieee, pTS->ts_common_info.addr, pBA);\n}\n\nvoid\nTsInitDelBA(struct ieee80211_device *ieee, struct ts_common_info *pTsCommonInfo, enum tr_select TxRxSelect)\n{\n\tif (TxRxSelect == TX_DIR) {\n\t\tstruct tx_ts_record *pTxTs = (struct tx_ts_record *)pTsCommonInfo;\n\n\t\tif (TxTsDeleteBA(ieee, pTxTs))\n\t\t\tieee80211_send_DELBA(\n\t\t\t\tieee,\n\t\t\t\tpTsCommonInfo->addr,\n\t\t\t\t(pTxTs->tx_admitted_ba_record.valid) ? (&pTxTs->tx_admitted_ba_record) : (&pTxTs->tx_pending_ba_record),\n\t\t\t\tTxRxSelect,\n\t\t\t\tDELBA_REASON_END_BA);\n\t} else if (TxRxSelect == RX_DIR) {\n\t\tstruct rx_ts_record *pRxTs = (struct rx_ts_record *)pTsCommonInfo;\n\t\tif (RxTsDeleteBA(ieee, pRxTs))\n\t\t\tieee80211_send_DELBA(\n\t\t\t\tieee,\n\t\t\t\tpTsCommonInfo->addr,\n\t\t\t\t&pRxTs->rx_admitted_ba_record,\n\t\t\t\tTxRxSelect,\n\t\t\t\tDELBA_REASON_END_BA);\n\t}\n}\n \nvoid BaSetupTimeOut(struct timer_list *t)\n{\n\tstruct tx_ts_record *pTxTs = from_timer(pTxTs, t, tx_pending_ba_record.timer);\n\n\tpTxTs->add_ba_req_in_progress = false;\n\tpTxTs->add_ba_req_delayed = true;\n\tpTxTs->tx_pending_ba_record.valid = false;\n}\n\nvoid TxBaInactTimeout(struct timer_list *t)\n{\n\tstruct tx_ts_record *pTxTs = from_timer(pTxTs, t, tx_admitted_ba_record.timer);\n\tstruct ieee80211_device *ieee = container_of(pTxTs, struct ieee80211_device, TxTsRecord[pTxTs->num]);\n\tTxTsDeleteBA(ieee, pTxTs);\n\tieee80211_send_DELBA(\n\t\tieee,\n\t\tpTxTs->ts_common_info.addr,\n\t\t&pTxTs->tx_admitted_ba_record,\n\t\tTX_DIR,\n\t\tDELBA_REASON_TIMEOUT);\n}\n\nvoid RxBaInactTimeout(struct timer_list *t)\n{\n\tstruct rx_ts_record *pRxTs = from_timer(pRxTs, t, rx_admitted_ba_record.timer);\n\tstruct ieee80211_device *ieee = container_of(pRxTs, struct ieee80211_device, RxTsRecord[pRxTs->num]);\n\n\tRxTsDeleteBA(ieee, pRxTs);\n\tieee80211_send_DELBA(\n\t\tieee,\n\t\tpRxTs->ts_common_info.addr,\n\t\t&pRxTs->rx_admitted_ba_record,\n\t\tRX_DIR,\n\t\tDELBA_REASON_TIMEOUT);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}