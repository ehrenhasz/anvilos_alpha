{
  "module_name": "ieee80211_rx.c",
  "hash_id": "572ef8e3aea5e6668fd49cb6d8419c45ab7766452b2447450d802430950a0ec4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c",
  "human_readable_source": "\n \n\n\n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n#include <linux/wireless.h>\n#include <linux/etherdevice.h>\n#include <linux/uaccess.h>\n#include <linux/ctype.h>\n\n#include \"ieee80211.h\"\n#include \"dot11d.h\"\nstatic inline void ieee80211_monitor_rx(struct ieee80211_device *ieee,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tstruct ieee80211_rx_stats *rx_stats)\n{\n\tstruct rtl_80211_hdr_4addr *hdr = (struct rtl_80211_hdr_4addr *)skb->data;\n\tu16 fc = le16_to_cpu(hdr->frame_ctl);\n\n\tskb->dev = ieee->dev;\n\tskb_reset_mac_header(skb);\n\n\tskb_pull(skb, ieee80211_get_hdrlen(fc));\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_80211_RAW);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tnetif_rx(skb);\n}\n\n\n \nstatic struct ieee80211_frag_entry *\nieee80211_frag_cache_find(struct ieee80211_device *ieee, unsigned int seq,\n\t\t\t  unsigned int frag, u8 tid, u8 *src, u8 *dst)\n{\n\tstruct ieee80211_frag_entry *entry;\n\tint i;\n\n\tfor (i = 0; i < IEEE80211_FRAG_CACHE_LEN; i++) {\n\t\tentry = &ieee->frag_cache[tid][i];\n\t\tif (entry->skb &&\n\t\t    time_after(jiffies, entry->first_frag_time + 2 * HZ)) {\n\t\t\tIEEE80211_DEBUG_FRAG(\n\t\t\t\t\"expiring fragment cache entry \"\n\t\t\t\t\"seq=%u last_frag=%u\\n\",\n\t\t\t\tentry->seq, entry->last_frag);\n\t\t\tdev_kfree_skb_any(entry->skb);\n\t\t\tentry->skb = NULL;\n\t\t}\n\n\t\tif (entry->skb && entry->seq == seq &&\n\t\t    (entry->last_frag + 1 == frag || frag == -1) &&\n\t\t    memcmp(entry->src_addr, src, ETH_ALEN) == 0 &&\n\t\t    memcmp(entry->dst_addr, dst, ETH_ALEN) == 0)\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct sk_buff *\nieee80211_frag_cache_get(struct ieee80211_device *ieee,\n\t\t\t struct rtl_80211_hdr_4addr *hdr)\n{\n\tstruct sk_buff *skb = NULL;\n\tu16 fc = le16_to_cpu(hdr->frame_ctl);\n\tu16 sc = le16_to_cpu(hdr->seq_ctl);\n\tunsigned int frag = WLAN_GET_SEQ_FRAG(sc);\n\tunsigned int seq = WLAN_GET_SEQ_SEQ(sc);\n\tstruct ieee80211_frag_entry *entry;\n\tstruct rtl_80211_hdr_3addrqos *hdr_3addrqos;\n\tstruct rtl_80211_hdr_4addrqos *hdr_4addrqos;\n\tu8 tid;\n\n\tif (((fc & IEEE80211_FCTL_DSTODS) == IEEE80211_FCTL_DSTODS) && IEEE80211_QOS_HAS_SEQ(fc)) {\n\t\thdr_4addrqos = (struct rtl_80211_hdr_4addrqos *)hdr;\n\t\ttid = le16_to_cpu(hdr_4addrqos->qos_ctl) & IEEE80211_QCTL_TID;\n\t\ttid = UP2AC(tid);\n\t\ttid++;\n\t} else if (IEEE80211_QOS_HAS_SEQ(fc)) {\n\t\thdr_3addrqos = (struct rtl_80211_hdr_3addrqos *)hdr;\n\t\ttid = le16_to_cpu(hdr_3addrqos->qos_ctl) & IEEE80211_QCTL_TID;\n\t\ttid = UP2AC(tid);\n\t\ttid++;\n\t} else {\n\t\ttid = 0;\n\t}\n\n\tif (frag == 0) {\n\t\t \n\t\tskb = dev_alloc_skb(ieee->dev->mtu +\n\t\t\t\t    sizeof(struct rtl_80211_hdr_4addr) +\n\t\t\t\t    8   +\n\t\t\t\t    2   +\n\t\t\t\t    8   +\n\t\t\t\t    ETH_ALEN   +\n\t\t\t\t    (IEEE80211_QOS_HAS_SEQ(fc) ? 2 : 0)  );\n\t\tif (!skb)\n\t\t\treturn NULL;\n\n\t\tentry = &ieee->frag_cache[tid][ieee->frag_next_idx[tid]];\n\t\tieee->frag_next_idx[tid]++;\n\t\tif (ieee->frag_next_idx[tid] >= IEEE80211_FRAG_CACHE_LEN)\n\t\t\tieee->frag_next_idx[tid] = 0;\n\n\t\tif (entry->skb)\n\t\t\tdev_kfree_skb_any(entry->skb);\n\n\t\tentry->first_frag_time = jiffies;\n\t\tentry->seq = seq;\n\t\tentry->last_frag = frag;\n\t\tentry->skb = skb;\n\t\tmemcpy(entry->src_addr, hdr->addr2, ETH_ALEN);\n\t\tmemcpy(entry->dst_addr, hdr->addr1, ETH_ALEN);\n\t} else {\n\t\t \n\t\tentry = ieee80211_frag_cache_find(ieee, seq, frag, tid, hdr->addr2,\n\t\t\t\t\t\t  hdr->addr1);\n\t\tif (entry) {\n\t\t\tentry->last_frag = frag;\n\t\t\tskb = entry->skb;\n\t\t}\n\t}\n\n\treturn skb;\n}\n\n\n \nstatic int ieee80211_frag_cache_invalidate(struct ieee80211_device *ieee,\n\t\t\t\t\t   struct rtl_80211_hdr_4addr *hdr)\n{\n\tu16 fc = le16_to_cpu(hdr->frame_ctl);\n\tu16 sc = le16_to_cpu(hdr->seq_ctl);\n\tunsigned int seq = WLAN_GET_SEQ_SEQ(sc);\n\tstruct ieee80211_frag_entry *entry;\n\tstruct rtl_80211_hdr_3addrqos *hdr_3addrqos;\n\tstruct rtl_80211_hdr_4addrqos *hdr_4addrqos;\n\tu8 tid;\n\n\tif (((fc & IEEE80211_FCTL_DSTODS) == IEEE80211_FCTL_DSTODS) && IEEE80211_QOS_HAS_SEQ(fc)) {\n\t\thdr_4addrqos = (struct rtl_80211_hdr_4addrqos *)hdr;\n\t\ttid = le16_to_cpu(hdr_4addrqos->qos_ctl) & IEEE80211_QCTL_TID;\n\t\ttid = UP2AC(tid);\n\t\ttid++;\n\t} else if (IEEE80211_QOS_HAS_SEQ(fc)) {\n\t\thdr_3addrqos = (struct rtl_80211_hdr_3addrqos *)hdr;\n\t\ttid = le16_to_cpu(hdr_3addrqos->qos_ctl) & IEEE80211_QCTL_TID;\n\t\ttid = UP2AC(tid);\n\t\ttid++;\n\t} else {\n\t\ttid = 0;\n\t}\n\n\tentry = ieee80211_frag_cache_find(ieee, seq, -1, tid, hdr->addr2,\n\t\t\t\t\t  hdr->addr1);\n\n\tif (!entry) {\n\t\tIEEE80211_DEBUG_FRAG(\n\t\t\t\"could not invalidate fragment cache \"\n\t\t\t\"entry (seq=%u)\\n\", seq);\n\t\treturn -1;\n\t}\n\n\tentry->skb = NULL;\n\treturn 0;\n}\n\n\n\n \nstatic inline int\nieee80211_rx_frame_mgmt(struct ieee80211_device *ieee, struct sk_buff *skb,\n\t\t\tstruct ieee80211_rx_stats *rx_stats, u16 type,\n\t\t\tu16 stype)\n{\n\t \n\tstruct rtl_80211_hdr_3addr *hdr = (struct rtl_80211_hdr_3addr *)skb->data;\n\n\trx_stats->len = skb->len;\n\tieee80211_rx_mgt(ieee, (struct rtl_80211_hdr_4addr *)skb->data, rx_stats);\n\t \n\tif ((memcmp(hdr->addr1, ieee->dev->dev_addr, ETH_ALEN))) {\n\t\t \n\t\tdev_kfree_skb_any(skb);\n\t\treturn 0;\n\t}\n\n\tieee80211_rx_frame_softmac(ieee, skb, rx_stats, type, stype);\n\n\tdev_kfree_skb_any(skb);\n\n\treturn 0;\n\n\t#ifdef NOT_YET\n\tif (ieee->iw_mode == IW_MODE_MASTER) {\n\t\tnetdev_dbg(ieee->dev, \"Master mode not yet supported.\\n\");\n\t\treturn 0;\n \n\t}\n\n\tif (ieee->hostapd && type == IEEE80211_TYPE_MGMT) {\n\t\tif (stype == WLAN_FC_STYPE_BEACON &&\n\t\t    ieee->iw_mode == IW_MODE_MASTER) {\n\t\t\tstruct sk_buff *skb2;\n\t\t\t \n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (skb2)\n\t\t\t\thostap_rx(skb2->dev, skb2, rx_stats);\n\t\t}\n\n\t\t \n\t\tieee->apdevstats.rx_packets++;\n\t\tieee->apdevstats.rx_bytes += skb->len;\n\t\tprism2_rx_80211(ieee->apdev, skb, rx_stats, PRISM2_RX_MGMT);\n\t\treturn 0;\n\t}\n\n\t    if (ieee->iw_mode == IW_MODE_MASTER) {\n\t\tif (type != WLAN_FC_TYPE_MGMT && type != WLAN_FC_TYPE_CTRL) {\n\t\t\tnetdev_dbg(skb->dev, \"unknown management frame \"\n\t\t\t       \"(type=0x%02x, stype=0x%02x) dropped\\n\",\n\t\t\t       type, stype);\n\t\t\treturn -1;\n\t\t}\n\n\t\thostap_rx(skb->dev, skb, rx_stats);\n\t\treturn 0;\n\t}\n\n\tnetdev_dbg(skb->dev, \"hostap_rx_frame_mgmt: management frame \"\n\t       \"received in non-Host AP mode\\n\");\n\treturn -1;\n\t#endif\n}\n\n\n\n \n \nstatic unsigned char rfc1042_header[] = {\n\t0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };\n \nstatic unsigned char bridge_tunnel_header[] = {\n\t0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };\n \n\n \nstatic int ieee80211_is_eapol_frame(struct ieee80211_device *ieee,\n\t\t\t\t    struct sk_buff *skb, size_t hdrlen)\n{\n\tstruct net_device *dev = ieee->dev;\n\tu16 fc, ethertype;\n\tstruct rtl_80211_hdr_4addr *hdr;\n\tu8 *pos;\n\n\tif (skb->len < 24)\n\t\treturn 0;\n\n\thdr = (struct rtl_80211_hdr_4addr *)skb->data;\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\n\t \n\tif ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t    IEEE80211_FCTL_TODS &&\n\t    memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0 &&\n\t    memcmp(hdr->addr3, dev->dev_addr, ETH_ALEN) == 0) {\n\t\t \n\t} else if ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t\t   IEEE80211_FCTL_FROMDS &&\n\t\t   memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0) {\n\t\t \n\t} else\n\t\treturn 0;\n\n\tif (skb->len < 24 + 8)\n\t\treturn 0;\n\n\t \n\n\tpos = skb->data + hdrlen;\n\tethertype = (pos[6] << 8) | pos[7];\n\tif (ethertype == ETH_P_PAE)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic inline int\nieee80211_rx_frame_decrypt(struct ieee80211_device *ieee, struct sk_buff *skb,\n\t\t\t   struct ieee80211_crypt_data *crypt)\n{\n\tstruct rtl_80211_hdr_4addr *hdr;\n\tint res, hdrlen;\n\n\tif (!crypt || !crypt->ops->decrypt_mpdu)\n\t\treturn 0;\n\tif (ieee->hwsec_active) {\n\t\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\t\ttcb_desc->bHwSec = 1;\n\t}\n\thdr = (struct rtl_80211_hdr_4addr *)skb->data;\n\thdrlen = ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\n\n\tif (ieee->tkip_countermeasures &&\n\t    strcmp(crypt->ops->name, \"TKIP\") == 0) {\n\t\tif (net_ratelimit()) {\n\t\t\tnetdev_dbg(ieee->dev, \"TKIP countermeasures: dropped \"\n\t\t\t       \"received packet from %pM\\n\",\n\t\t\t       hdr->addr2);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tatomic_inc(&crypt->refcnt);\n\tres = crypt->ops->decrypt_mpdu(skb, hdrlen, crypt->priv);\n\tatomic_dec(&crypt->refcnt);\n\tif (res < 0) {\n\t\tIEEE80211_DEBUG_DROP(\n\t\t\t\"decryption failed (SA=%pM\"\n\t\t\t\") res=%d\\n\", hdr->addr2, res);\n\t\tif (res == -2)\n\t\t\tIEEE80211_DEBUG_DROP(\"Decryption failed ICV \"\n\t\t\t\t\t     \"mismatch (key %d)\\n\",\n\t\t\t\t\t     skb->data[hdrlen + 3] >> 6);\n\t\tieee->ieee_stats.rx_discards_undecryptable++;\n\t\treturn -1;\n\t}\n\n\treturn res;\n}\n\n\n \nstatic inline int\nieee80211_rx_frame_decrypt_msdu(struct ieee80211_device *ieee, struct sk_buff *skb,\n\t\t\t     int keyidx, struct ieee80211_crypt_data *crypt)\n{\n\tstruct rtl_80211_hdr_4addr *hdr;\n\tint res, hdrlen;\n\n\tif (!crypt || !crypt->ops->decrypt_msdu)\n\t\treturn 0;\n\tif (ieee->hwsec_active) {\n\t\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\t\ttcb_desc->bHwSec = 1;\n\t}\n\n\thdr = (struct rtl_80211_hdr_4addr *)skb->data;\n\thdrlen = ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\n\n\tatomic_inc(&crypt->refcnt);\n\tres = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv);\n\tatomic_dec(&crypt->refcnt);\n\tif (res < 0) {\n\t\tnetdev_dbg(ieee->dev, \"MSDU decryption/MIC verification failed\"\n\t\t       \" (SA=%pM keyidx=%d)\\n\",\n\t\t       hdr->addr2, keyidx);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\n \n#define IEEE_PACKET_RETRY_TIME (5 * HZ)\nstatic int is_duplicate_packet(struct ieee80211_device *ieee,\n\t\t\t\t      struct rtl_80211_hdr_4addr *header)\n{\n\tu16 fc = le16_to_cpu(header->frame_ctl);\n\tu16 sc = le16_to_cpu(header->seq_ctl);\n\tu16 seq = WLAN_GET_SEQ_SEQ(sc);\n\tu16 frag = WLAN_GET_SEQ_FRAG(sc);\n\tu16 *last_seq, *last_frag;\n\tunsigned long *last_time;\n\tstruct rtl_80211_hdr_3addrqos *hdr_3addrqos;\n\tstruct rtl_80211_hdr_4addrqos *hdr_4addrqos;\n\tu8 tid;\n\n\n\t\n\tif (((fc & IEEE80211_FCTL_DSTODS) == IEEE80211_FCTL_DSTODS) && IEEE80211_QOS_HAS_SEQ(fc)) {\n\t\thdr_4addrqos = (struct rtl_80211_hdr_4addrqos *)header;\n\t\ttid = le16_to_cpu(hdr_4addrqos->qos_ctl) & IEEE80211_QCTL_TID;\n\t\ttid = UP2AC(tid);\n\t\ttid++;\n\t} else if (IEEE80211_QOS_HAS_SEQ(fc)) { \n\t\thdr_3addrqos = (struct rtl_80211_hdr_3addrqos *)header;\n\t\ttid = le16_to_cpu(hdr_3addrqos->qos_ctl) & IEEE80211_QCTL_TID;\n\t\ttid = UP2AC(tid);\n\t\ttid++;\n\t} else { \n\t\ttid = 0;\n\t}\n\n\tswitch (ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\t{\n\t\tstruct list_head *p;\n\t\tstruct ieee_ibss_seq *entry = NULL;\n\t\tu8 *mac = header->addr2;\n\t\tint index = mac[5] % IEEE_IBSS_MAC_HASH_SIZE;\n\n\t\tlist_for_each(p, &ieee->ibss_mac_hash[index]) {\n\t\t\tentry = list_entry(p, struct ieee_ibss_seq, list);\n\t\t\tif (!memcmp(entry->mac, mac, ETH_ALEN))\n\t\t\t\tbreak;\n\t\t}\n\t\n\t\tif (p == &ieee->ibss_mac_hash[index]) {\n\t\t\tentry = kmalloc(sizeof(struct ieee_ibss_seq), GFP_ATOMIC);\n\t\t\tif (!entry)\n\t\t\t\treturn 0;\n\t\t\tmemcpy(entry->mac, mac, ETH_ALEN);\n\t\t\tentry->seq_num[tid] = seq;\n\t\t\tentry->frag_num[tid] = frag;\n\t\t\tentry->packet_time[tid] = jiffies;\n\t\t\tlist_add(&entry->list, &ieee->ibss_mac_hash[index]);\n\t\t\treturn 0;\n\t\t}\n\t\tlast_seq = &entry->seq_num[tid];\n\t\tlast_frag = &entry->frag_num[tid];\n\t\tlast_time = &entry->packet_time[tid];\n\t\tbreak;\n\t}\n\n\tcase IW_MODE_INFRA:\n\t\tlast_seq = &ieee->last_rxseq_num[tid];\n\t\tlast_frag = &ieee->last_rxfrag_num[tid];\n\t\tlast_time = &ieee->last_packet_time[tid];\n\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\n\n\n\tif ((*last_seq == seq) &&\n\t    time_after(*last_time + IEEE_PACKET_RETRY_TIME, jiffies)) {\n\t\tif (*last_frag == frag)\n\t\t\tgoto drop;\n\t\tif (*last_frag + 1 != frag)\n\t\t\t \n\t\t\tgoto drop;\n\t} else\n\t\t*last_seq = seq;\n\n\t*last_frag = frag;\n\t*last_time = jiffies;\n\treturn 0;\n\ndrop:\n\n\n\treturn 1;\n}\n\nstatic bool AddReorderEntry(struct rx_ts_record *pTS, struct rx_reorder_entry *pReorderEntry)\n{\n\tstruct list_head *pList = &pTS->rx_pending_pkt_list;\n\twhile (pList->next != &pTS->rx_pending_pkt_list) {\n\t\tif (SN_LESS(pReorderEntry->SeqNum, list_entry(pList->next, struct rx_reorder_entry, List)->SeqNum))\n\t\t\tpList = pList->next;\n\t\telse if (SN_EQUAL(pReorderEntry->SeqNum, list_entry(pList->next, struct rx_reorder_entry, List)->SeqNum))\n\t\t\treturn false;\n\t\telse\n\t\t\tbreak;\n\t}\n\tpReorderEntry->List.next = pList->next;\n\tpReorderEntry->List.next->prev = &pReorderEntry->List;\n\tpReorderEntry->List.prev = pList;\n\tpList->next = &pReorderEntry->List;\n\n\treturn true;\n}\n\nstatic void indicate_packets(struct ieee80211_device *ieee,\n\t\t\t     struct ieee80211_rxb *rxb)\n{\n\tstruct net_device_stats *stats = &ieee->stats;\n\tstruct net_device *dev = ieee->dev;\n\tu16 ethertype;\n\tu8 i;\n\n\tfor (i = 0; i < rxb->nr_subframes; i++) {\n\t\tstruct sk_buff *sub_skb = rxb->subframes[i];\n\n\t\tif (!sub_skb)\n\t\t\tcontinue;\n\n\t\t \n\t\tethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];\n\t\tif (sub_skb->len >= 8 &&\n\t\t    ((!memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) &&\n\t\t\tethertype != ETH_P_AARP &&\n\t\t\tethertype != ETH_P_IPX) ||\n\t\t     !memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE))) {\n\t\t\t \n\t\t\tskb_pull(sub_skb, SNAP_SIZE);\n\t\t} else {\n\t\t\t \n\t\t\tput_unaligned_be16(sub_skb->len, skb_push(sub_skb, 2));\n\t\t}\n\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), rxb->src, ETH_ALEN);\n\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), rxb->dst, ETH_ALEN);\n\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += sub_skb->len;\n\t\tif (is_multicast_ether_addr(rxb->dst))\n\t\t\tstats->multicast++;\n\n\t\t \n\t\tsub_skb->protocol = eth_type_trans(sub_skb, dev);\n\t\tmemset(sub_skb->cb, 0, sizeof(sub_skb->cb));\n\t\tsub_skb->dev = dev;\n\t\t \n\t\tsub_skb->ip_summed = CHECKSUM_NONE;\n\t\tieee->last_rx_ps_time = jiffies;\n\t\tnetif_rx(sub_skb);\n\t}\n}\n\nvoid ieee80211_indicate_packets(struct ieee80211_device *ieee,\n\t\t\t\tstruct ieee80211_rxb **prxbIndicateArray,\n\t\t\t\tu8 index)\n{\n\tu8 i;\n\n\tfor (i = 0; i < index; i++) {\n\t\tstruct ieee80211_rxb *prxb = prxbIndicateArray[i];\n\n\t\tindicate_packets(ieee, prxb);\n\t\tkfree(prxb);\n\t\tprxb = NULL;\n\t}\n}\n\nstatic void RxReorderIndicatePacket(struct ieee80211_device *ieee,\n\t\t\t\t    struct ieee80211_rxb *prxb,\n\t\t\t\t    struct rx_ts_record *pTS, u16 SeqNum)\n{\n\tPRT_HIGH_THROUGHPUT\tpHTInfo = ieee->pHTInfo;\n\tstruct rx_reorder_entry *pReorderEntry = NULL;\n\tstruct ieee80211_rxb **prxbIndicateArray;\n\tu8\t\t\tWinSize = pHTInfo->RxReorderWinSize;\n\tu16\t\t\tWinEnd = (pTS->rx_indicate_seq + WinSize - 1) % 4096;\n\tu8\t\t\tindex = 0;\n\tbool\t\t\tbMatchWinStart = false, bPktInBuf = false;\n\tIEEE80211_DEBUG(IEEE80211_DL_REORDER, \"%s(): Seq is %d,pTS->rx_indicate_seq is %d, WinSize is %d\\n\", __func__, SeqNum, pTS->rx_indicate_seq, WinSize);\n\n\tprxbIndicateArray = kmalloc_array(REORDER_WIN_SIZE,\n\t\t\t\t\t  sizeof(struct ieee80211_rxb *),\n\t\t\t\t\t  GFP_ATOMIC);\n\tif (!prxbIndicateArray)\n\t\treturn;\n\n\t \n\tif (pTS->rx_indicate_seq == 0xffff)\n\t\tpTS->rx_indicate_seq = SeqNum;\n\n\t \n\tif (SN_LESS(SeqNum, pTS->rx_indicate_seq)) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_REORDER, \"Packet Drop! IndicateSeq: %d, NewSeq: %d\\n\",\n\t\t\t\t pTS->rx_indicate_seq, SeqNum);\n\t\tpHTInfo->RxReorderDropCounter++;\n\t\t{\n\t\t\tint i;\n\t\t\tfor (i = 0; i < prxb->nr_subframes; i++)\n\t\t\t\tdev_kfree_skb(prxb->subframes[i]);\n\n\t\t\tkfree(prxb);\n\t\t\tprxb = NULL;\n\t\t}\n\n\t\tkfree(prxbIndicateArray);\n\t\treturn;\n\t}\n\n\t \n\tif (SN_EQUAL(SeqNum, pTS->rx_indicate_seq)) {\n\t\tpTS->rx_indicate_seq = (pTS->rx_indicate_seq + 1) % 4096;\n\t\tbMatchWinStart = true;\n\t} else if (SN_LESS(WinEnd, SeqNum)) {\n\t\tif (SeqNum >= (WinSize - 1))\n\t\t\tpTS->rx_indicate_seq = SeqNum + 1 - WinSize;\n\t\telse\n\t\t\tpTS->rx_indicate_seq = 4095 - (WinSize - (SeqNum + 1)) + 1;\n\n\t\tIEEE80211_DEBUG(IEEE80211_DL_REORDER, \"Window Shift! IndicateSeq: %d, NewSeq: %d\\n\", pTS->rx_indicate_seq, SeqNum);\n\t}\n\n\t \n\t \n\tif (bMatchWinStart) {\n\t\t \n\t\tIEEE80211_DEBUG(IEEE80211_DL_REORDER, \"Packets indication!! IndicateSeq: %d, NewSeq: %d\\n\",\\\n\t\t\t\tpTS->rx_indicate_seq, SeqNum);\n\t\tprxbIndicateArray[0] = prxb;\n\n\t\tindex = 1;\n\t} else {\n\t\t \n\t\t\n\t\tif (!list_empty(&ieee->RxReorder_Unused_List)) {\n\t\t\tpReorderEntry = list_entry(ieee->RxReorder_Unused_List.next, struct rx_reorder_entry, List);\n\t\t\tlist_del_init(&pReorderEntry->List);\n\n\t\t\t \n\t\t\tpReorderEntry->SeqNum = SeqNum;\n\t\t\tpReorderEntry->prxb = prxb;\n\t\n\n\t\t\tif (!AddReorderEntry(pTS, pReorderEntry)) {\n\t\t\t\tIEEE80211_DEBUG(IEEE80211_DL_REORDER, \"%s(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\\n\",\n\t\t\t\t\t__func__, pTS->rx_indicate_seq, SeqNum);\n\t\t\t\tlist_add_tail(&pReorderEntry->List, &ieee->RxReorder_Unused_List);\n\t\t\t\t{\n\t\t\t\t\tint i;\n\t\t\t\t\tfor (i = 0; i < prxb->nr_subframes; i++)\n\t\t\t\t\t\tdev_kfree_skb(prxb->subframes[i]);\n\n\t\t\t\t\tkfree(prxb);\n\t\t\t\t\tprxb = NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tIEEE80211_DEBUG(IEEE80211_DL_REORDER,\n\t\t\t\t\t \"Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\\n\", pTS->rx_indicate_seq, SeqNum);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"RxReorderIndicatePacket(): There is no reorder entry!! Packet is dropped!!\\n\");\n\t\t\t{\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < prxb->nr_subframes; i++)\n\t\t\t\t\tdev_kfree_skb(prxb->subframes[i]);\n\n\t\t\t\tkfree(prxb);\n\t\t\t\tprxb = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\twhile (!list_empty(&pTS->rx_pending_pkt_list)) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_REORDER, \"%s(): start RREORDER indicate\\n\", __func__);\n\t\tpReorderEntry = list_entry(pTS->rx_pending_pkt_list.prev, struct rx_reorder_entry, List);\n\t\tif (SN_LESS(pReorderEntry->SeqNum, pTS->rx_indicate_seq) ||\n\t\t    SN_EQUAL(pReorderEntry->SeqNum, pTS->rx_indicate_seq)) {\n\t\t\t \n\t\t\tif (index >= REORDER_WIN_SIZE) {\n\t\t\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"RxReorderIndicatePacket(): Buffer overflow!! \\n\");\n\t\t\t\tbPktInBuf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlist_del_init(&pReorderEntry->List);\n\n\t\t\tif (SN_EQUAL(pReorderEntry->SeqNum, pTS->rx_indicate_seq))\n\t\t\t\tpTS->rx_indicate_seq = (pTS->rx_indicate_seq + 1) % 4096;\n\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_REORDER, \"Packets indication!! IndicateSeq: %d, NewSeq: %d\\n\", pTS->rx_indicate_seq, SeqNum);\n\t\t\tprxbIndicateArray[index] = pReorderEntry->prxb;\n\t\t\n\t\t\tindex++;\n\n\t\t\tlist_add_tail(&pReorderEntry->List, &ieee->RxReorder_Unused_List);\n\t\t} else {\n\t\t\tbPktInBuf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (index > 0) {\n\t\t\n\t\n\t\tpTS->rx_timeout_indicate_seq = 0xffff;\n\n\t\t\n\t\tif (index > REORDER_WIN_SIZE) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"RxReorderIndicatePacket(): Rx Reorder buffer full!! \\n\");\n\t\t\tkfree(prxbIndicateArray);\n\t\t\treturn;\n\t\t}\n\t\tieee80211_indicate_packets(ieee, prxbIndicateArray, index);\n\t}\n\n\tif (bPktInBuf && pTS->rx_timeout_indicate_seq == 0xffff) {\n\t\t\n\t\tIEEE80211_DEBUG(IEEE80211_DL_REORDER, \"%s(): SET rx timeout timer\\n\", __func__);\n\t\tpTS->rx_timeout_indicate_seq = pTS->rx_indicate_seq;\n\t\tif (timer_pending(&pTS->rx_pkt_pending_timer))\n\t\t\tdel_timer_sync(&pTS->rx_pkt_pending_timer);\n\t\tpTS->rx_pkt_pending_timer.expires = jiffies +\n\t\t\t\tmsecs_to_jiffies(pHTInfo->RxReorderPendingTime);\n\t\tadd_timer(&pTS->rx_pkt_pending_timer);\n\t}\n\n\tkfree(prxbIndicateArray);\n}\n\nstatic u8 parse_subframe(struct ieee80211_device *ieee,\n\t\t\t struct sk_buff *skb,\n\t\t\t struct ieee80211_rx_stats *rx_stats,\n\t\t\t struct ieee80211_rxb *rxb, u8 *src, u8 *dst)\n{\n\tstruct rtl_80211_hdr_3addr  *hdr = (struct rtl_80211_hdr_3addr *)skb->data;\n\tu16\t\tfc = le16_to_cpu(hdr->frame_ctl);\n\n\tu16\t\tLLCOffset = sizeof(struct rtl_80211_hdr_3addr);\n\tu16\t\tChkLength;\n\tbool\t\tbIsAggregateFrame = false;\n\tu16\t\tnSubframe_Length;\n\tu8\t\tnPadding_Length = 0;\n\tu16\t\tSeqNum = 0;\n\n\tstruct sk_buff *sub_skb;\n\t \n\tSeqNum = WLAN_GET_SEQ_SEQ(le16_to_cpu(hdr->seq_ctl));\n\n\tif ((IEEE80211_QOS_HAS_SEQ(fc)) && \\\n\t\t\t(((frameqos *)(skb->data + IEEE80211_3ADDR_LEN))->field.reserved)) {\n\t\tbIsAggregateFrame = true;\n\t}\n\n\tif (IEEE80211_QOS_HAS_SEQ(fc))\n\t\tLLCOffset += 2;\n\n\tif (rx_stats->bContainHTC)\n\t\tLLCOffset += HTCLNG;\n\n\t\n\tChkLength = LLCOffset; \n\n\tif (skb->len <= ChkLength)\n\t\treturn 0;\n\n\tskb_pull(skb, LLCOffset);\n\n\tif (!bIsAggregateFrame) {\n\t\trxb->nr_subframes = 1;\n#ifdef JOHN_NOCPY\n\t\trxb->subframes[0] = skb;\n#else\n\t\trxb->subframes[0] = skb_copy(skb, GFP_ATOMIC);\n#endif\n\n\t\tmemcpy(rxb->src, src, ETH_ALEN);\n\t\tmemcpy(rxb->dst, dst, ETH_ALEN);\n\t\t\n\t\treturn 1;\n\t} else {\n\t\trxb->nr_subframes = 0;\n\t\tmemcpy(rxb->src, src, ETH_ALEN);\n\t\tmemcpy(rxb->dst, dst, ETH_ALEN);\n\t\twhile (skb->len > ETHERNET_HEADER_SIZE) {\n\t\t\t \n\t\t\tnSubframe_Length = *((u16 *)(skb->data + 12));\n\t\t\t\n\t\t\tnSubframe_Length = (nSubframe_Length >> 8) + (nSubframe_Length << 8);\n\n\t\t\tif (skb->len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {\n\t\t\t\tnetdev_dbg(ieee->dev, \"A-MSDU parse error!! pRfd->nTotalSubframe : %d\\n\",\n\t\t\t\t\t   rxb->nr_subframes);\n\t\t\t\tnetdev_dbg(ieee->dev, \"A-MSDU parse error!! Subframe Length: %d\\n\", nSubframe_Length);\n\t\t\t\tnetdev_dbg(ieee->dev, \"nRemain_Length is %d and nSubframe_Length is : %d\\n\", skb->len, nSubframe_Length);\n\t\t\t\tnetdev_dbg(ieee->dev, \"The Packet SeqNum is %d\\n\", SeqNum);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tskb_pull(skb, ETHERNET_HEADER_SIZE);\n\n#ifdef JOHN_NOCPY\n\t\t\tsub_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\tsub_skb->len = nSubframe_Length;\n\t\t\tsub_skb->tail = sub_skb->data + nSubframe_Length;\n#else\n\t\t\t \n\t\t\tsub_skb = dev_alloc_skb(nSubframe_Length + 12);\n\t\t\tif (!sub_skb)\n\t\t\t\treturn 0;\n\t\t\tskb_reserve(sub_skb, 12);\n\t\t\tskb_put_data(sub_skb, skb->data, nSubframe_Length);\n#endif\n\t\t\trxb->subframes[rxb->nr_subframes++] = sub_skb;\n\t\t\tif (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {\n\t\t\t\tIEEE80211_DEBUG_RX(\"ParseSubframe(): Too many Subframes! Packets dropped!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tskb_pull(skb, nSubframe_Length);\n\n\t\t\tif (skb->len != 0) {\n\t\t\t\tnPadding_Length = 4 - ((nSubframe_Length + ETHERNET_HEADER_SIZE) % 4);\n\t\t\t\tif (nPadding_Length == 4)\n\t\t\t\t\tnPadding_Length = 0;\n\n\t\t\t\tif (skb->len < nPadding_Length)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tskb_pull(skb, nPadding_Length);\n\t\t\t}\n\t\t}\n#ifdef JOHN_NOCPY\n\t\tdev_kfree_skb(skb);\n#endif\n\t\t\n\t\t\n\t\t\n\t\treturn rxb->nr_subframes;\n\t}\n}\n\n \nint ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,\n\t\t struct ieee80211_rx_stats *rx_stats)\n{\n\tstruct net_device *dev = ieee->dev;\n\tstruct rtl_80211_hdr_4addr *hdr;\n\t\n\n\tsize_t hdrlen;\n\tu16 fc, type, stype, sc;\n\tstruct net_device_stats *stats;\n\tunsigned int frag;\n\t\n\tu8\tTID = 0;\n\tu16\tSeqNum = 0;\n\tstruct rx_ts_record *pTS = NULL;\n\t\n\t\n#ifdef NOT_YET\n\tstruct net_device *wds = NULL;\n\tstruct net_device *wds = NULL;\n\tint from_assoc_ap = 0;\n\tvoid *sta = NULL;\n#endif\n\n\tu8 dst[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n\tu8 bssid[ETH_ALEN];\n\tstruct ieee80211_crypt_data *crypt = NULL;\n\tint keyidx = 0;\n\n\tint i;\n\tstruct ieee80211_rxb *rxb = NULL;\n\t\n\thdr = (struct rtl_80211_hdr_4addr *)skb->data;\n\tstats = &ieee->stats;\n\n\tif (skb->len < 10) {\n\t\tnetdev_info(dev, \"SKB length < 10\\n\");\n\t\tgoto rx_dropped;\n\t}\n\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tstype = WLAN_FC_GET_STYPE(fc);\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\n\tfrag = WLAN_GET_SEQ_FRAG(sc);\n\thdrlen = ieee80211_get_hdrlen(fc);\n\n\tif (HTCCheck(ieee, skb->data)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_warn(dev, \"find HTCControl\\n\");\n\t\thdrlen += 4;\n\t\trx_stats->bContainHTC = true;\n\t}\n\n\t\n#ifdef NOT_YET\n\t \n#ifdef IW_WIRELESS_SPY\t\t \n\t \n\tif (iface->spy_data.spy_number > 0) {\n\t\tstruct iw_quality wstats;\n\t\twstats.level = rx_stats->rssi;\n\t\twstats.noise = rx_stats->noise;\n\t\twstats.updated = 6;\t \n\t\t \n\t\twireless_spy_update(dev, hdr->addr2, &wstats);\n\t}\n#endif  \n\thostap_update_rx_stats(local->ap, hdr, rx_stats);\n#endif\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tunsigned int len = skb->len;\n\n\t\tieee80211_monitor_rx(ieee, skb, rx_stats);\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += len;\n\t\treturn 1;\n\t}\n\n\tif (ieee->host_decrypt) {\n\t\tint idx = 0;\n\t\tif (skb->len >= hdrlen + 3)\n\t\t\tidx = skb->data[hdrlen + 3] >> 6;\n\t\tcrypt = ieee->crypt[idx];\n#ifdef NOT_YET\n\t\tsta = NULL;\n\n\t\t \n\n\t\tif (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)\n\t\t\t(void)hostap_handle_sta_crypto(local, hdr, &crypt,\n\t\t\t\t\t\t\t&sta);\n#endif\n\n\t\t \n\t\tif (crypt && (!crypt->ops || !crypt->ops->decrypt_mpdu))\n\t\t\tcrypt = NULL;\n\n\t\tif (!crypt && (fc & IEEE80211_FCTL_WEP)) {\n\t\t\t \n\t\t\tIEEE80211_DEBUG_DROP(\"Decryption failed (not set)\"\n\t\t\t\t\t     \" (SA=%pM)\\n\",\n\t\t\t\t\t     hdr->addr2);\n\t\t\tieee->ieee_stats.rx_discards_undecryptable++;\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n\tif (skb->len < IEEE80211_DATA_HDR3_LEN)\n\t\tgoto rx_dropped;\n\n\t\n\tif ((!ieee->pHTInfo->bCurRxReorderEnable) || !ieee->current_network.qos_data.active || !IsDataFrame(skb->data) || IsLegacyDataFrame(skb->data)) {\n\t\tif (is_duplicate_packet(ieee, hdr))\n\t\t\tgoto rx_dropped;\n\n\t} else {\n\t\tstruct rx_ts_record *pRxTS = NULL;\n\t\t\t\n\t\tif (GetTs(\n\t\t\t\tieee,\n\t\t\t\t(struct ts_common_info **)&pRxTS,\n\t\t\t\thdr->addr2,\n\t\t\t\tFrame_QoSTID((u8 *)(skb->data)),\n\t\t\t\tRX_DIR,\n\t\t\t\ttrue)) {\n\n\t\t\n\t\t\tif ((fc & (1 << 11)) &&\n\t\t\t    (frag == pRxTS->rx_last_frag_num) &&\n\t\t\t    (WLAN_GET_SEQ_SEQ(sc) == pRxTS->rx_last_seq_num)) {\n\t\t\t\tgoto rx_dropped;\n\t\t\t} else {\n\t\t\t\tpRxTS->rx_last_frag_num = frag;\n\t\t\t\tpRxTS->rx_last_seq_num = WLAN_GET_SEQ_SEQ(sc);\n\t\t\t}\n\t\t} else {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR, \"%s(): No TS!! Skip the check!!\\n\", __func__);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\tif (type == IEEE80211_FTYPE_MGMT) {\n\n\n\t\n\t\tif (ieee80211_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))\n\t\t\tgoto rx_dropped;\n\t\telse\n\t\t\tgoto rx_exit;\n\t}\n\n\t \n\tswitch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\n\tcase IEEE80211_FCTL_FROMDS:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(bssid, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS:\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tmemcpy(bssid, hdr->addr1, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\n\t\tif (skb->len < IEEE80211_DATA_HDR4_LEN)\n\t\t\tgoto rx_dropped;\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr4, ETH_ALEN);\n\t\tmemcpy(bssid, ieee->current_network.bssid, ETH_ALEN);\n\t\tbreak;\n\tdefault:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tmemcpy(bssid, hdr->addr3, ETH_ALEN);\n\t\tbreak;\n\t}\n\n#ifdef NOT_YET\n\tif (hostap_rx_frame_wds(ieee, hdr, fc, &wds))\n\t\tgoto rx_dropped;\n\tif (wds) {\n\t\tskb->dev = dev = wds;\n\t\tstats = hostap_get_stats(dev);\n\t}\n\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds &&\n\t    (fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) == IEEE80211_FCTL_FROMDS &&\n\t    ieee->stadev &&\n\t    memcmp(hdr->addr2, ieee->assoc_ap_addr, ETH_ALEN) == 0) {\n\t\t \n\t\tskb->dev = dev = ieee->stadev;\n\t\tstats = hostap_get_stats(dev);\n\t\tfrom_assoc_ap = 1;\n\t}\n\n\tif ((ieee->iw_mode == IW_MODE_MASTER ||\n\t     ieee->iw_mode == IW_MODE_REPEAT) &&\n\t    !from_assoc_ap) {\n\t\tswitch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,\n\t\t\t\t\t     wds)) {\n\t\tcase AP_RX_CONTINUE_NOT_AUTHORIZED:\n\t\tcase AP_RX_CONTINUE:\n\t\t\tbreak;\n\t\tcase AP_RX_DROP:\n\t\t\tgoto rx_dropped;\n\t\tcase AP_RX_EXIT:\n\t\t\tgoto rx_exit;\n\t\t}\n\t}\n#endif\n\t\n\t \n\tif (stype != IEEE80211_STYPE_DATA &&\n\t    stype != IEEE80211_STYPE_DATA_CFACK &&\n\t    stype != IEEE80211_STYPE_DATA_CFPOLL &&\n\t    stype != IEEE80211_STYPE_DATA_CFACKPOLL &&\n\t    stype != IEEE80211_STYPE_QOS_DATA\n\t    ) {\n\t\tif (stype != IEEE80211_STYPE_NULLFUNC)\n\t\t\tIEEE80211_DEBUG_DROP(\n\t\t\t\t\"RX: dropped data frame \"\n\t\t\t\t\"with no data (type=0x%02x, \"\n\t\t\t\t\"subtype=0x%02x, len=%d)\\n\",\n\t\t\t\ttype, stype, skb->len);\n\t\tgoto rx_dropped;\n\t}\n\tif (memcmp(bssid, ieee->current_network.bssid, ETH_ALEN))\n\t\tgoto rx_dropped;\n\n\t \n\n\tif (ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP)) {\n\t\tkeyidx = ieee80211_rx_frame_decrypt(ieee, skb, crypt);\n\t\tif (keyidx < 0) {\n\t\t\tnetdev_dbg(ieee->dev, \"decrypt frame error\\n\");\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n\n\thdr = (struct rtl_80211_hdr_4addr *)skb->data;\n\n\t \n\t\n\t\n\tif ((frag != 0 || (fc & IEEE80211_FCTL_MOREFRAGS))) {\n\t\tint flen;\n\t\tstruct sk_buff *frag_skb = ieee80211_frag_cache_get(ieee, hdr);\n\t\tIEEE80211_DEBUG_FRAG(\"Rx Fragment received (%u)\\n\", frag);\n\n\t\tif (!frag_skb) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_RX | IEEE80211_DL_FRAG,\n\t\t\t\t\t\"Rx cannot get skb from fragment \"\n\t\t\t\t\t\"cache (morefrag=%d seq=%u frag=%u)\\n\",\n\t\t\t\t\t(fc & IEEE80211_FCTL_MOREFRAGS) != 0,\n\t\t\t\t\tWLAN_GET_SEQ_SEQ(sc), frag);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t\tflen = skb->len;\n\t\tif (frag != 0)\n\t\t\tflen -= hdrlen;\n\n\t\tif (frag_skb->tail + flen > frag_skb->end) {\n\t\t\tnetdev_warn(dev, \"host decrypted and \"\n\t\t\t       \"reassembled frame did not fit skb\\n\");\n\t\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (frag == 0) {\n\t\t\t \n\t\t\tskb_put_data(frag_skb, skb->data, flen);\n\t\t} else {\n\t\t\t \n\t\t\tskb_put_data(frag_skb, skb->data + hdrlen, flen);\n\t\t}\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = NULL;\n\n\t\tif (fc & IEEE80211_FCTL_MOREFRAGS) {\n\t\t\t \n\t\t\tgoto rx_exit;\n\t\t}\n\n\t\t \n\t\tskb = frag_skb;\n\t\thdr = (struct rtl_80211_hdr_4addr *)skb->data;\n\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t}\n\n\t \n\tif (ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP) &&\n\t    ieee80211_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt)) {\n\t\tnetdev_dbg(ieee->dev, \"==>decrypt msdu error\\n\");\n\t\tgoto rx_dropped;\n\t}\n\n\t\n\tieee->LinkDetectInfo.NumRecvDataInPeriod++;\n\tieee->LinkDetectInfo.NumRxOkInPeriod++;\n\n\thdr = (struct rtl_80211_hdr_4addr *)skb->data;\n\tif (crypt && !(fc & IEEE80211_FCTL_WEP) && !ieee->open_wep) {\n\t\tif ( \n\t\t    ieee80211_is_eapol_frame(ieee, skb, hdrlen)) {\n\n#ifdef CONFIG_IEEE80211_DEBUG\n\t\t\t \n\t\t\tstruct eapol *eap = (struct eapol *)(skb->data +\n\t\t\t\t24);\n\t\t\tIEEE80211_DEBUG_EAP(\"RX: IEEE 802.1X EAPOL frame: %s\\n\",\n\t\t\t\t\t\teap_get_type(eap->type));\n#endif\n\t\t} else {\n\t\t\tIEEE80211_DEBUG_DROP(\n\t\t\t\t\"encryption configured, but RX \"\n\t\t\t\t\"frame not encrypted (SA=%pM)\\n\",\n\t\t\t\thdr->addr2);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n#ifdef CONFIG_IEEE80211_DEBUG\n\tif (crypt && !(fc & IEEE80211_FCTL_WEP) &&\n\t    ieee80211_is_eapol_frame(ieee, skb, hdrlen)) {\n\t\tstruct eapol *eap = (struct eapol *)(skb->data +\n\t\t\t24);\n\t\tIEEE80211_DEBUG_EAP(\"RX: IEEE 802.1X EAPOL frame: %s\\n\",\n\t\t\t\t\teap_get_type(eap->type));\n\t}\n#endif\n\n\tif (crypt && !(fc & IEEE80211_FCTL_WEP) && !ieee->open_wep &&\n\t    !ieee80211_is_eapol_frame(ieee, skb, hdrlen)) {\n\t\tIEEE80211_DEBUG_DROP(\n\t\t\t\"dropped unencrypted RX data \"\n\t\t\t\"frame from %pM\"\n\t\t\t\" (drop_unencrypted=1)\\n\",\n\t\t\thdr->addr2);\n\t\tgoto rx_dropped;\n\t}\n \n\n\tif (ieee->current_network.qos_data.active && IsQoSDataFrame(skb->data)\n\t\t&& !is_multicast_ether_addr(hdr->addr1)) {\n\t\tTID = Frame_QoSTID(skb->data);\n\t\tSeqNum = WLAN_GET_SEQ_SEQ(sc);\n\t\tGetTs(ieee, (struct ts_common_info **)&pTS, hdr->addr2, TID, RX_DIR, true);\n\t\tif (TID != 0 && TID != 3)\n\t\t\tieee->bis_any_nonbepkts = true;\n\t}\n\n\t \n\t\n\trxb = kmalloc(sizeof(struct ieee80211_rxb), GFP_ATOMIC);\n\tif (!rxb)\n\t\tgoto rx_dropped;\n\t \n\t \n\tif (parse_subframe(ieee, skb, rx_stats, rxb, src, dst) == 0) {\n\t\t \n\t\tfor (i = 0; i < rxb->nr_subframes; i++)\n\t\t\tdev_kfree_skb(rxb->subframes[i]);\n\n\t\tkfree(rxb);\n\t\trxb = NULL;\n\t\tgoto rx_dropped;\n\t}\n\n\n\tif (!ieee->pHTInfo->bCurRxReorderEnable || !pTS) {\n\t\tindicate_packets(ieee, rxb);\n\t\tkfree(rxb);\n\t\trxb = NULL;\n\n\t} else {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_REORDER, \"%s(): REORDER ENABLE AND PTS not NULL, and we will enter RxReorderIndicatePacket()\\n\", __func__);\n\t\tRxReorderIndicatePacket(ieee, rxb, pTS, SeqNum);\n\t}\n#ifndef JOHN_NOCPY\n\tdev_kfree_skb(skb);\n#endif\n\n rx_exit:\n#ifdef NOT_YET\n\tif (sta)\n\t\thostap_handle_sta_release(sta);\n#endif\n\treturn 1;\n\n rx_dropped:\n\tkfree(rxb);\n\trxb = NULL;\n\tstats->rx_dropped++;\n\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_rx);\n\n#define MGMT_FRAME_FIXED_PART_LENGTH            0x24\n\nstatic u8 qos_oui[QOS_OUI_LEN] = { 0x00, 0x50, 0xF2 };\n\n \nstatic int ieee80211_verify_qos_info(struct ieee80211_qos_information_element\n\t\t\t\t     *info_element, int sub_type)\n{\n\tif (info_element->elementID != QOS_ELEMENT_ID)\n\t\treturn -1;\n\tif (info_element->qui_subtype != sub_type)\n\t\treturn -1;\n\tif (memcmp(info_element->qui, qos_oui, QOS_OUI_LEN))\n\t\treturn -1;\n\tif (info_element->qui_type != QOS_OUI_TYPE)\n\t\treturn -1;\n\tif (info_element->version != QOS_VERSION_1)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n\n \nstatic int ieee80211_read_qos_param_element(\n\t\tstruct ieee80211_qos_parameter_info *element_param,\n\t\tstruct ieee80211_info_element *info_element)\n{\n\tsize_t size = sizeof(*element_param);\n\n\tif (!element_param || !info_element || info_element->len != size - 2)\n\t\treturn -1;\n\n\tmemcpy(element_param, info_element, size);\n\treturn ieee80211_verify_qos_info(&element_param->info_element,\n\t\t\t\t\t QOS_OUI_PARAM_SUB_TYPE);\n}\n\n \nstatic int ieee80211_read_qos_info_element(\n\t\tstruct ieee80211_qos_information_element *element_info,\n\t\tstruct ieee80211_info_element *info_element)\n{\n\tsize_t size = sizeof(*element_info);\n\n\tif (!element_info || !info_element || info_element->len != size - 2)\n\t\treturn -1;\n\n\tmemcpy(element_info, info_element, size);\n\treturn ieee80211_verify_qos_info(element_info, QOS_OUI_INFO_SUB_TYPE);\n}\n\n\n \nstatic int ieee80211_qos_convert_ac_to_parameters(\n\t\tstruct ieee80211_qos_parameter_info *param_elm,\n\t\tstruct ieee80211_qos_parameters *qos_param)\n{\n\tint i;\n\tstruct ieee80211_qos_ac_parameter *ac_params;\n\tu8 aci;\n\t\n\t\n\n\tfor (i = 0; i < QOS_QUEUE_NUM; i++) {\n\t\tac_params = &(param_elm->ac_params_record[i]);\n\n\t\taci = (ac_params->aci_aifsn & 0x60) >> 5;\n\n\t\tif (aci >= QOS_QUEUE_NUM)\n\t\t\tcontinue;\n\t\tqos_param->aifs[aci] = (ac_params->aci_aifsn) & 0x0f;\n\n\t\t \n\t\tqos_param->aifs[aci] = (qos_param->aifs[aci] < 2) ? 2 : qos_param->aifs[aci];\n\n\t\tqos_param->cw_min[aci] =\n\t\t    cpu_to_le16(ac_params->ecw_min_max & 0x0F);\n\n\t\tqos_param->cw_max[aci] =\n\t\t    cpu_to_le16((ac_params->ecw_min_max & 0xF0) >> 4);\n\n\t\tqos_param->flag[aci] =\n\t\t    (ac_params->aci_aifsn & 0x10) ? 0x01 : 0x00;\n\t\tqos_param->tx_op_limit[aci] = ac_params->tx_op_limit;\n\t}\n\treturn 0;\n}\n\n \nstatic int ieee80211_parse_qos_info_param_IE(struct ieee80211_info_element\n\t\t\t\t\t     *info_element,\n\t\t\t\t\t     struct ieee80211_network *network)\n{\n\tint rc = 0;\n\tstruct ieee80211_qos_parameters *qos_param = NULL;\n\tstruct ieee80211_qos_information_element qos_info_element;\n\n\trc = ieee80211_read_qos_info_element(&qos_info_element, info_element);\n\n\tif (rc == 0) {\n\t\tnetwork->qos_data.param_count = qos_info_element.ac_info & 0x0F;\n\t\tnetwork->flags |= NETWORK_HAS_QOS_INFORMATION;\n\t} else {\n\t\tstruct ieee80211_qos_parameter_info param_element;\n\n\t\trc = ieee80211_read_qos_param_element(&param_element,\n\t\t\t\t\t\t      info_element);\n\t\tif (rc == 0) {\n\t\t\tqos_param = &(network->qos_data.parameters);\n\t\t\tieee80211_qos_convert_ac_to_parameters(&param_element,\n\t\t\t\t\t\t\t       qos_param);\n\t\t\tnetwork->flags |= NETWORK_HAS_QOS_PARAMETERS;\n\t\t\tnetwork->qos_data.param_count =\n\t\t\t    param_element.info_element.ac_info & 0x0F;\n\t\t}\n\t}\n\n\tif (rc == 0) {\n\t\tIEEE80211_DEBUG_QOS(\"QoS is supported\\n\");\n\t\tnetwork->qos_data.supported = 1;\n\t}\n\treturn rc;\n}\n\n#ifdef CONFIG_IEEE80211_DEBUG\n#define MFIE_STRING(x) case MFIE_TYPE_ ##x: return #x\n\nstatic const char *get_info_element_string(u16 id)\n{\n\tswitch (id) {\n\t\tMFIE_STRING(SSID);\n\t\tMFIE_STRING(RATES);\n\t\tMFIE_STRING(FH_SET);\n\t\tMFIE_STRING(DS_SET);\n\t\tMFIE_STRING(CF_SET);\n\t\tMFIE_STRING(TIM);\n\t\tMFIE_STRING(IBSS_SET);\n\t\tMFIE_STRING(COUNTRY);\n\t\tMFIE_STRING(HOP_PARAMS);\n\t\tMFIE_STRING(HOP_TABLE);\n\t\tMFIE_STRING(REQUEST);\n\t\tMFIE_STRING(CHALLENGE);\n\t\tMFIE_STRING(POWER_CONSTRAINT);\n\t\tMFIE_STRING(POWER_CAPABILITY);\n\t\tMFIE_STRING(TPC_REQUEST);\n\t\tMFIE_STRING(TPC_REPORT);\n\t\tMFIE_STRING(SUPP_CHANNELS);\n\t\tMFIE_STRING(CSA);\n\t\tMFIE_STRING(MEASURE_REQUEST);\n\t\tMFIE_STRING(MEASURE_REPORT);\n\t\tMFIE_STRING(QUIET);\n\t\tMFIE_STRING(IBSS_DFS);\n\t       \n\t\tMFIE_STRING(RSN);\n\t\tMFIE_STRING(RATES_EX);\n\t\tMFIE_STRING(GENERIC);\n\t\tMFIE_STRING(QOS_PARAMETER);\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n#endif\n\nstatic inline void ieee80211_extract_country_ie(\n\tstruct ieee80211_device *ieee,\n\tstruct ieee80211_info_element *info_element,\n\tstruct ieee80211_network *network,\n\tu8 *addr2\n)\n{\n\tif (IS_DOT11D_ENABLE(ieee)) {\n\t\tif (info_element->len != 0) {\n\t\t\tmemcpy(network->CountryIeBuf, info_element->data, info_element->len);\n\t\t\tnetwork->CountryIeLen = info_element->len;\n\n\t\t\tif (!IS_COUNTRY_IE_VALID(ieee)) {\n\t\t\t\tdot11d_update_country_ie(ieee, addr2, info_element->len, info_element->data);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif (IS_EQUAL_CIE_SRC(ieee, addr2))\n\t\t\tUPDATE_CIE_WATCHDOG(ieee);\n\t}\n}\n\nint ieee80211_parse_info_param(struct ieee80211_device *ieee,\n\t\tstruct ieee80211_info_element *info_element,\n\t\tu16 length,\n\t\tstruct ieee80211_network *network,\n\t\tstruct ieee80211_rx_stats *stats)\n{\n\tu8 i;\n\tshort offset;\n\tu16\ttmp_htcap_len = 0;\n\tu16\ttmp_htinfo_len = 0;\n\tu16 ht_realtek_agg_len = 0;\n\tu8  ht_realtek_agg_buf[MAX_IE_LEN];\n\n#ifdef CONFIG_IEEE80211_DEBUG\n\tchar rates_str[64];\n\tchar *p;\n#endif\n\n\twhile (length >= sizeof(*info_element)) {\n\t\tif (sizeof(*info_element) + info_element->len > length) {\n\t\t\tIEEE80211_DEBUG_MGMT(\"Info elem: parse failed: \"\n\t\t\t\t\t     \"info_element->len + 2 > left : \"\n\t\t\t\t\t     \"info_element->len+2=%zd left=%d, id=%d.\\n\",\n\t\t\t\t\t     info_element->len +\n\t\t\t\t\t     sizeof(*info_element),\n\t\t\t\t\t     length, info_element->id);\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (info_element->id) {\n\t\tcase MFIE_TYPE_SSID:\n\t\t\tif (ieee80211_is_empty_essid(info_element->data,\n\t\t\t\t\t\t     info_element->len)) {\n\t\t\t\tnetwork->flags |= NETWORK_EMPTY_ESSID;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnetwork->ssid_len = min(info_element->len,\n\t\t\t\t\t\t(u8)IW_ESSID_MAX_SIZE);\n\t\t\tmemcpy(network->ssid, info_element->data, network->ssid_len);\n\t\t\tif (network->ssid_len < IW_ESSID_MAX_SIZE)\n\t\t\t\tmemset(network->ssid + network->ssid_len, 0,\n\t\t\t\t       IW_ESSID_MAX_SIZE - network->ssid_len);\n\n\t\t\tIEEE80211_DEBUG_MGMT(\"MFIE_TYPE_SSID: '%s' len=%d.\\n\",\n\t\t\t\t\t     network->ssid, network->ssid_len);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_RATES:\n#ifdef CONFIG_IEEE80211_DEBUG\n\t\t\tp = rates_str;\n#endif\n\t\t\tnetwork->rates_len = min(info_element->len,\n\t\t\t\t\t\t MAX_RATES_LENGTH);\n\t\t\tfor (i = 0; i < network->rates_len; i++) {\n\t\t\t\tnetwork->rates[i] = info_element->data[i];\n#ifdef CONFIG_IEEE80211_DEBUG\n\t\t\t\tp += scnprintf(p, sizeof(rates_str) -\n\t\t\t\t\t      (p - rates_str), \"%02X \",\n\t\t\t\t\t      network->rates[i]);\n#endif\n\t\t\t\tif (ieee80211_is_ofdm_rate\n\t\t\t\t    (info_element->data[i])) {\n\t\t\t\t\tnetwork->flags |= NETWORK_HAS_OFDM;\n\t\t\t\t\tif (info_element->data[i] &\n\t\t\t\t\t    IEEE80211_BASIC_RATE_MASK)\n\t\t\t\t\t\tnetwork->flags &=\n\t\t\t\t\t\t    ~NETWORK_HAS_CCK;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIEEE80211_DEBUG_MGMT(\"MFIE_TYPE_RATES: '%s' (%d)\\n\",\n\t\t\t\t\t     rates_str, network->rates_len);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_RATES_EX:\n#ifdef CONFIG_IEEE80211_DEBUG\n\t\t\tp = rates_str;\n#endif\n\t\t\tnetwork->rates_ex_len = min(info_element->len,\n\t\t\t\t\t\t    MAX_RATES_EX_LENGTH);\n\t\t\tfor (i = 0; i < network->rates_ex_len; i++) {\n\t\t\t\tnetwork->rates_ex[i] = info_element->data[i];\n#ifdef CONFIG_IEEE80211_DEBUG\n\t\t\t\tp += scnprintf(p, sizeof(rates_str) -\n\t\t\t\t\t      (p - rates_str), \"%02X \",\n\t\t\t\t\t      network->rates_ex[i]);\n#endif\n\t\t\t\tif (ieee80211_is_ofdm_rate\n\t\t\t\t    (info_element->data[i])) {\n\t\t\t\t\tnetwork->flags |= NETWORK_HAS_OFDM;\n\t\t\t\t\tif (info_element->data[i] &\n\t\t\t\t\t    IEEE80211_BASIC_RATE_MASK)\n\t\t\t\t\t\tnetwork->flags &=\n\t\t\t\t\t\t    ~NETWORK_HAS_CCK;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIEEE80211_DEBUG_MGMT(\"MFIE_TYPE_RATES_EX: '%s' (%d)\\n\",\n\t\t\t\t\t     rates_str, network->rates_ex_len);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_DS_SET:\n\t\t\tIEEE80211_DEBUG_MGMT(\"MFIE_TYPE_DS_SET: %d\\n\",\n\t\t\t\t\t     info_element->data[0]);\n\t\t\tnetwork->channel = info_element->data[0];\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_FH_SET:\n\t\t\tIEEE80211_DEBUG_MGMT(\"MFIE_TYPE_FH_SET: ignored\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_CF_SET:\n\t\t\tIEEE80211_DEBUG_MGMT(\"MFIE_TYPE_CF_SET: ignored\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_TIM:\n\t\t\tif (info_element->len < 4)\n\t\t\t\tbreak;\n\n\t\t\tnetwork->tim.tim_count = info_element->data[0];\n\t\t\tnetwork->tim.tim_period = info_element->data[1];\n\n\t\t\tnetwork->dtim_period = info_element->data[1];\n\t\t\tif (ieee->state != IEEE80211_LINKED)\n\t\t\t\tbreak;\n\n\t\t\tnetwork->last_dtim_sta_time[0] = stats->mac_time[0];\n\t\t\tnetwork->last_dtim_sta_time[1] = stats->mac_time[1];\n\n\t\t\tnetwork->dtim_data = IEEE80211_DTIM_VALID;\n\n\t\t\tif (info_element->data[0] != 0)\n\t\t\t\tbreak;\n\n\t\t\tif (info_element->data[2] & 1)\n\t\t\t\tnetwork->dtim_data |= IEEE80211_DTIM_MBCAST;\n\n\t\t\toffset = (info_element->data[2] >> 1) * 2;\n\n\t\t\tif (ieee->assoc_id < 8 * offset ||\n\t\t\t\tieee->assoc_id > 8 * (offset + info_element->len - 3))\n\n\t\t\t\tbreak;\n\n\t\t\toffset = (ieee->assoc_id / 8) - offset; \n\n\t\t\tif (info_element->data[3 + offset] & (1 << (ieee->assoc_id % 8)))\n\t\t\t\tnetwork->dtim_data |= IEEE80211_DTIM_UCAST;\n\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_ERP:\n\t\t\tnetwork->erp_value = info_element->data[0];\n\t\t\tnetwork->flags |= NETWORK_HAS_ERP_VALUE;\n\t\t\tIEEE80211_DEBUG_MGMT(\"MFIE_TYPE_ERP_SET: %d\\n\",\n\t\t\t\t\t     network->erp_value);\n\t\t\tbreak;\n\t\tcase MFIE_TYPE_IBSS_SET:\n\t\t\tnetwork->atim_window = info_element->data[0];\n\t\t\tIEEE80211_DEBUG_MGMT(\"MFIE_TYPE_IBSS_SET: %d\\n\",\n\t\t\t\t\t     network->atim_window);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_CHALLENGE:\n\t\t\tIEEE80211_DEBUG_MGMT(\"MFIE_TYPE_CHALLENGE: ignored\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_GENERIC:\n\t\t\tIEEE80211_DEBUG_MGMT(\"MFIE_TYPE_GENERIC: %d bytes\\n\",\n\t\t\t\t\t     info_element->len);\n\t\t\tif (!ieee80211_parse_qos_info_param_IE(info_element,\n\t\t\t\t\t\t\t       network))\n\t\t\t\tbreak;\n\n\t\t\tif (info_element->len >= 4 &&\n\t\t\t    info_element->data[0] == 0x00 &&\n\t\t\t    info_element->data[1] == 0x50 &&\n\t\t\t    info_element->data[2] == 0xf2 &&\n\t\t\t    info_element->data[3] == 0x01) {\n\t\t\t\tnetwork->wpa_ie_len = min(info_element->len + 2,\n\t\t\t\t\t\t\t  MAX_WPA_IE_LEN);\n\t\t\t\tmemcpy(network->wpa_ie, info_element,\n\t\t\t\t       network->wpa_ie_len);\n\t\t\t\tbreak;\n\t\t\t}\n\n#ifdef THOMAS_TURBO\n\t\t\tif (info_element->len == 7 &&\n\t\t\t    info_element->data[0] == 0x00 &&\n\t\t\t    info_element->data[1] == 0xe0 &&\n\t\t\t    info_element->data[2] == 0x4c &&\n\t\t\t    info_element->data[3] == 0x01 &&\n\t\t\t    info_element->data[4] == 0x02) {\n\t\t\t\tnetwork->Turbo_Enable = 1;\n\t\t\t}\n#endif\n\n\t\t\t\n\t\t\tif (tmp_htcap_len == 0) {\n\t\t\t\tif (info_element->len >= 4 &&\n\t\t\t\t   info_element->data[0] == 0x00 &&\n\t\t\t\t   info_element->data[1] == 0x90 &&\n\t\t\t\t   info_element->data[2] == 0x4c &&\n\t\t\t\t   info_element->data[3] == 0x033){\n\n\t\t\t\t\ttmp_htcap_len = min(info_element->len, (u8)MAX_IE_LEN);\n\t\t\t\t\tif (tmp_htcap_len != 0) {\n\t\t\t\t\t\tnetwork->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;\n\t\t\t\t\t\tnetwork->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf) ? \\\n\t\t\t\t\t\t\tsizeof(network->bssht.bdHTCapBuf) : tmp_htcap_len;\n\t\t\t\t\t\tmemcpy(network->bssht.bdHTCapBuf, info_element->data, network->bssht.bdHTCapLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (tmp_htcap_len != 0)\n\t\t\t\t\tnetwork->bssht.bdSupportHT = true;\n\t\t\t\telse\n\t\t\t\t\tnetwork->bssht.bdSupportHT = false;\n\t\t\t}\n\n\n\t\t\tif (tmp_htinfo_len == 0) {\n\t\t\t\tif (info_element->len >= 4 &&\n\t\t\t\t\tinfo_element->data[0] == 0x00 &&\n\t\t\t\t\tinfo_element->data[1] == 0x90 &&\n\t\t\t\t\tinfo_element->data[2] == 0x4c &&\n\t\t\t\t\tinfo_element->data[3] == 0x034){\n\n\t\t\t\t\ttmp_htinfo_len = min(info_element->len, (u8)MAX_IE_LEN);\n\t\t\t\t\tif (tmp_htinfo_len != 0) {\n\t\t\t\t\t\tnetwork->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;\n\t\t\t\t\t\tif (tmp_htinfo_len) {\n\t\t\t\t\t\t\tnetwork->bssht.bdHTInfoLen = tmp_htinfo_len > sizeof(network->bssht.bdHTInfoBuf) ? \\\n\t\t\t\t\t\t\t\tsizeof(network->bssht.bdHTInfoBuf) : tmp_htinfo_len;\n\t\t\t\t\t\t\tmemcpy(network->bssht.bdHTInfoBuf, info_element->data, network->bssht.bdHTInfoLen);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ieee->aggregation) {\n\t\t\t\tif (network->bssht.bdSupportHT) {\n\t\t\t\t\tif (info_element->len >= 4 &&\n\t\t\t\t\t\tinfo_element->data[0] == 0x00 &&\n\t\t\t\t\t\tinfo_element->data[1] == 0xe0 &&\n\t\t\t\t\t\tinfo_element->data[2] == 0x4c &&\n\t\t\t\t\t\tinfo_element->data[3] == 0x02){\n\n\t\t\t\t\t\tht_realtek_agg_len = min(info_element->len, (u8)MAX_IE_LEN);\n\t\t\t\t\t\tmemcpy(ht_realtek_agg_buf, info_element->data, info_element->len);\n\n\t\t\t\t\t}\n\t\t\t\t\tif (ht_realtek_agg_len >= 5) {\n\t\t\t\t\t\tnetwork->bssht.bdRT2RTAggregation = true;\n\n\t\t\t\t\t\tif ((ht_realtek_agg_buf[4] == 1) && (ht_realtek_agg_buf[5] & 0x02))\n\t\t\t\t\t\t\tnetwork->bssht.bdRT2RTLongSlotTime = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t\n\t\t\t{\n\t\t\t\tif ((info_element->len >= 3 &&\n\t\t\t\t\t info_element->data[0] == 0x00 &&\n\t\t\t\t\t info_element->data[1] == 0x05 &&\n\t\t\t\t\t info_element->data[2] == 0xb5) ||\n\t\t\t\t\t (info_element->len >= 3 &&\n\t\t\t\t\t info_element->data[0] == 0x00 &&\n\t\t\t\t\t info_element->data[1] == 0x0a &&\n\t\t\t\t\t info_element->data[2] == 0xf7) ||\n\t\t\t\t\t (info_element->len >= 3 &&\n\t\t\t\t\t info_element->data[0] == 0x00 &&\n\t\t\t\t\t info_element->data[1] == 0x10 &&\n\t\t\t\t\t info_element->data[2] == 0x18)){\n\n\t\t\t\t\tnetwork->broadcom_cap_exist = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (info_element->len >= 3 &&\n\t\t\t\tinfo_element->data[0] == 0x00 &&\n\t\t\t\tinfo_element->data[1] == 0x0c &&\n\t\t\t\tinfo_element->data[2] == 0x43) {\n\t\t\t\tnetwork->ralink_cap_exist = true;\n\t\t\t} else\n\t\t\t\tnetwork->ralink_cap_exist = false;\n\t\t\t\n\t\t\tif ((info_element->len >= 3 &&\n\t\t\t\tinfo_element->data[0] == 0x00 &&\n\t\t\t\tinfo_element->data[1] == 0x03 &&\n\t\t\t\tinfo_element->data[2] == 0x7f) ||\n\t\t\t\t(info_element->len >= 3 &&\n\t\t\t\tinfo_element->data[0] == 0x00 &&\n\t\t\t\tinfo_element->data[1] == 0x13 &&\n\t\t\t\tinfo_element->data[2] == 0x74)) {\n\t\t\t\tnetdev_dbg(ieee->dev, \"========> Atheros AP exists\\n\");\n\t\t\t\tnetwork->atheros_cap_exist = true;\n\t\t\t} else\n\t\t\t\tnetwork->atheros_cap_exist = false;\n\n\t\t\tif (info_element->len >= 3 &&\n\t\t\t\tinfo_element->data[0] == 0x00 &&\n\t\t\t\tinfo_element->data[1] == 0x40 &&\n\t\t\t\tinfo_element->data[2] == 0x96) {\n\t\t\t\tnetwork->cisco_cap_exist = true;\n\t\t\t} else\n\t\t\t\tnetwork->cisco_cap_exist = false;\n\t\t\t\n\t\t\tif (info_element->len > 4 &&\n\t\t\t\tinfo_element->data[0] == 0x00 &&\n\t\t\t\tinfo_element->data[1] == 0x40 &&\n\t\t\t\tinfo_element->data[2] == 0x96 &&\n\t\t\t\tinfo_element->data[3] == 0x01) {\n\t\t\t\tif (info_element->len == 6) {\n\t\t\t\t\tmemcpy(network->CcxRmState, &info_element[4], 2);\n\t\t\t\t\tif (network->CcxRmState[0] != 0)\n\t\t\t\t\t\tnetwork->bCcxRmEnable = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tnetwork->bCcxRmEnable = false;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tnetwork->MBssidMask = network->CcxRmState[1] & 0x07;\n\t\t\t\t\tif (network->MBssidMask != 0) {\n\t\t\t\t\t\tnetwork->bMBssidValid = true;\n\t\t\t\t\t\tnetwork->MBssidMask = 0xff << (network->MBssidMask);\n\t\t\t\t\t\tether_addr_copy(network->MBssid, network->bssid);\n\t\t\t\t\t\tnetwork->MBssid[5] &= network->MBssidMask;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnetwork->bMBssidValid = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnetwork->bCcxRmEnable = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (info_element->len > 4  &&\n\t\t\t\tinfo_element->data[0] == 0x00 &&\n\t\t\t\tinfo_element->data[1] == 0x40 &&\n\t\t\t\tinfo_element->data[2] == 0x96 &&\n\t\t\t\tinfo_element->data[3] == 0x03) {\n\t\t\t\tif (info_element->len == 5) {\n\t\t\t\t\tnetwork->bWithCcxVerNum = true;\n\t\t\t\t\tnetwork->BssCcxVerNumber = info_element->data[4];\n\t\t\t\t} else {\n\t\t\t\t\tnetwork->bWithCcxVerNum = false;\n\t\t\t\t\tnetwork->BssCcxVerNumber = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_RSN:\n\t\t\tIEEE80211_DEBUG_MGMT(\"MFIE_TYPE_RSN: %d bytes\\n\",\n\t\t\t\t\t     info_element->len);\n\t\t\tnetwork->rsn_ie_len = min(info_element->len + 2,\n\t\t\t\t\t\t  MAX_WPA_IE_LEN);\n\t\t\tmemcpy(network->rsn_ie, info_element,\n\t\t\t       network->rsn_ie_len);\n\t\t\tbreak;\n\n\t\t\t\n\t\tcase MFIE_TYPE_HT_CAP:\n\t\t\tIEEE80211_DEBUG_SCAN(\"MFIE_TYPE_HT_CAP: %d bytes\\n\",\n\t\t\t\t\t     info_element->len);\n\t\t\ttmp_htcap_len = min(info_element->len, (u8)MAX_IE_LEN);\n\t\t\tif (tmp_htcap_len != 0) {\n\t\t\t\tnetwork->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;\n\t\t\t\tnetwork->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf) ? \\\n\t\t\t\t\tsizeof(network->bssht.bdHTCapBuf) : tmp_htcap_len;\n\t\t\t\tmemcpy(network->bssht.bdHTCapBuf, info_element->data, network->bssht.bdHTCapLen);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tnetwork->bssht.bdSupportHT = true;\n\t\t\t} else\n\t\t\t\tnetwork->bssht.bdSupportHT = false;\n\t\t\tbreak;\n\n\n\t\tcase MFIE_TYPE_HT_INFO:\n\t\t\tIEEE80211_DEBUG_SCAN(\"MFIE_TYPE_HT_INFO: %d bytes\\n\",\n\t\t\t\t\t     info_element->len);\n\t\t\ttmp_htinfo_len = min(info_element->len, (u8)MAX_IE_LEN);\n\t\t\tif (tmp_htinfo_len) {\n\t\t\t\tnetwork->bssht.bdHTSpecVer = HT_SPEC_VER_IEEE;\n\t\t\t\tnetwork->bssht.bdHTInfoLen = tmp_htinfo_len > sizeof(network->bssht.bdHTInfoBuf) ? \\\n\t\t\t\t\tsizeof(network->bssht.bdHTInfoBuf) : tmp_htinfo_len;\n\t\t\t\tmemcpy(network->bssht.bdHTInfoBuf, info_element->data, network->bssht.bdHTInfoLen);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_AIRONET:\n\t\t\tIEEE80211_DEBUG_SCAN(\"MFIE_TYPE_AIRONET: %d bytes\\n\",\n\t\t\t\t\t     info_element->len);\n\t\t\tif (info_element->len > IE_CISCO_FLAG_POSITION) {\n\t\t\t\tnetwork->bWithAironetIE = true;\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif ((info_element->data[IE_CISCO_FLAG_POSITION] & SUPPORT_CKIP_MIC)\t||\n\t\t\t\t\t(info_element->data[IE_CISCO_FLAG_POSITION] & SUPPORT_CKIP_PK)) {\n\t\t\t\t\tnetwork->bCkipSupported = true;\n\t\t\t\t} else {\n\t\t\t\t\tnetwork->bCkipSupported = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnetwork->bWithAironetIE = false;\n\t\t\t\tnetwork->bCkipSupported = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MFIE_TYPE_QOS_PARAMETER:\n\t\t\tnetdev_err(ieee->dev,\n\t\t\t\t   \"QoS Error need to parse QOS_PARAMETER IE\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_COUNTRY:\n\t\t\tIEEE80211_DEBUG_SCAN(\"MFIE_TYPE_COUNTRY: %d bytes\\n\",\n\t\t\t\t\t     info_element->len);\n\t\t\tieee80211_extract_country_ie(ieee, info_element, network, network->bssid);\n\t\t\tbreak;\n \n\t\tdefault:\n\t\t\tIEEE80211_DEBUG_MGMT\n\t\t\t    (\"Unsupported info element: %s (%d)\\n\",\n\t\t\t     get_info_element_string(info_element->id),\n\t\t\t     info_element->id);\n\t\t\tbreak;\n\t\t}\n\n\t\tlength -= sizeof(*info_element) + info_element->len;\n\t\tinfo_element =\n\t\t    (struct ieee80211_info_element *)&info_element->\n\t\t    data[info_element->len];\n\t}\n\n\tif (!network->atheros_cap_exist && !network->broadcom_cap_exist &&\n\t\t!network->cisco_cap_exist && !network->ralink_cap_exist && !network->bssht.bdRT2RTAggregation) {\n\t\tnetwork->unknown_cap_exist = true;\n\t} else {\n\t\tnetwork->unknown_cap_exist = false;\n\t}\n\treturn 0;\n}\n\n \nstatic long ieee80211_translate_todbm(u8 signal_strength_index)\n{\n\tlong\tsignal_power; \n\n\t\n\tsignal_power = (long)((signal_strength_index + 1) >> 1);\n\tsignal_power -= 95;\n\n\treturn signal_power;\n}\n\nstatic inline int ieee80211_network_init(\n\tstruct ieee80211_device *ieee,\n\tstruct ieee80211_probe_response *beacon,\n\tstruct ieee80211_network *network,\n\tstruct ieee80211_rx_stats *stats)\n{\n#ifdef CONFIG_IEEE80211_DEBUG\n\t\n\t\n#endif\n\n\tnetwork->qos_data.active = 0;\n\tnetwork->qos_data.supported = 0;\n\tnetwork->qos_data.param_count = 0;\n\tnetwork->qos_data.old_param_count = 0;\n\n\t \n\tmemcpy(network->bssid, beacon->header.addr3, ETH_ALEN);\n\tnetwork->capability = le16_to_cpu(beacon->capability);\n\tnetwork->last_scanned = jiffies;\n\tnetwork->time_stamp[0] = le32_to_cpu(beacon->time_stamp[0]);\n\tnetwork->time_stamp[1] = le32_to_cpu(beacon->time_stamp[1]);\n\tnetwork->beacon_interval = le16_to_cpu(beacon->beacon_interval);\n\t \n\tnetwork->listen_interval = 0x0A;\n\tnetwork->rates_len = network->rates_ex_len = 0;\n\tnetwork->last_associate = 0;\n\tnetwork->ssid_len = 0;\n\tnetwork->flags = 0;\n\tnetwork->atim_window = 0;\n\tnetwork->erp_value = (network->capability & WLAN_CAPABILITY_IBSS) ?\n\t    0x3 : 0x0;\n\tnetwork->berp_info_valid = false;\n\tnetwork->broadcom_cap_exist = false;\n\tnetwork->ralink_cap_exist = false;\n\tnetwork->atheros_cap_exist = false;\n\tnetwork->cisco_cap_exist = false;\n\tnetwork->unknown_cap_exist = false;\n#ifdef THOMAS_TURBO\n\tnetwork->Turbo_Enable = 0;\n#endif\n\tnetwork->CountryIeLen = 0;\n\tmemset(network->CountryIeBuf, 0, MAX_IE_LEN);\n\n\t\n\tHTInitializeBssDesc(&network->bssht);\n\tif (stats->freq == IEEE80211_52GHZ_BAND) {\n\t\t \n\t\tnetwork->channel = stats->received_channel;\n\t} else\n\t\tnetwork->flags |= NETWORK_HAS_CCK;\n\n\tnetwork->wpa_ie_len = 0;\n\tnetwork->rsn_ie_len = 0;\n\n\tif (ieee80211_parse_info_param\n\t    (ieee, beacon->info_element, stats->len - sizeof(*beacon), network, stats))\n\t\treturn 1;\n\n\tnetwork->mode = 0;\n\tif (stats->freq == IEEE80211_52GHZ_BAND)\n\t\tnetwork->mode = IEEE_A;\n\telse {\n\t\tif (network->flags & NETWORK_HAS_OFDM)\n\t\t\tnetwork->mode |= IEEE_G;\n\t\tif (network->flags & NETWORK_HAS_CCK)\n\t\t\tnetwork->mode |= IEEE_B;\n\t}\n\n\tif (network->mode == 0) {\n\t\tIEEE80211_DEBUG_SCAN(\"Filtered out '%s (%pM)' \"\n\t\t\t\t     \"network.\\n\",\n\t\t\t\t     escape_essid(network->ssid,\n\t\t\t\t\t\t  network->ssid_len),\n\t\t\t\t     network->bssid);\n\t\treturn 1;\n\t}\n\n\tif (network->bssht.bdSupportHT) {\n\t\tif (network->mode == IEEE_A)\n\t\t\tnetwork->mode = IEEE_N_5G;\n\t\telse if (network->mode & (IEEE_G | IEEE_B))\n\t\t\tnetwork->mode = IEEE_N_24G;\n\t}\n\tif (ieee80211_is_empty_essid(network->ssid, network->ssid_len))\n\t\tnetwork->flags |= NETWORK_EMPTY_ESSID;\n\n\tstats->signal = 30 + (stats->SignalStrength * 70) / 100;\n\tstats->noise = ieee80211_translate_todbm((u8)(100 - stats->signal)) - 25;\n\n\tmemcpy(&network->stats, stats, sizeof(network->stats));\n\n\treturn 0;\n}\n\nstatic inline int is_same_network(struct ieee80211_network *src,\n\t\t\t\t  struct ieee80211_network *dst, struct ieee80211_device *ieee)\n{\n\t \n\treturn \n\t\t(((src->ssid_len == dst->ssid_len) || (ieee->iw_mode == IW_MODE_INFRA)) &&\n\t\t(src->channel == dst->channel) &&\n\t\t!memcmp(src->bssid, dst->bssid, ETH_ALEN) &&\n\t\t\n\t\t(!memcmp(src->ssid, dst->ssid, src->ssid_len) || (ieee->iw_mode == IW_MODE_INFRA)) &&\n\t\t((src->capability & WLAN_CAPABILITY_IBSS) ==\n\t\t(dst->capability & WLAN_CAPABILITY_IBSS)) &&\n\t\t((src->capability & WLAN_CAPABILITY_BSS) ==\n\t\t(dst->capability & WLAN_CAPABILITY_BSS)));\n}\n\nstatic inline void update_network(struct ieee80211_network *dst,\n\t\t\t\t  struct ieee80211_network *src)\n{\n\tint qos_active;\n\tu8 old_param;\n\n\tmemcpy(&dst->stats, &src->stats, sizeof(struct ieee80211_rx_stats));\n\tdst->capability = src->capability;\n\tmemcpy(dst->rates, src->rates, src->rates_len);\n\tdst->rates_len = src->rates_len;\n\tmemcpy(dst->rates_ex, src->rates_ex, src->rates_ex_len);\n\tdst->rates_ex_len = src->rates_ex_len;\n\tif (src->ssid_len > 0) {\n\t\tmemset(dst->ssid, 0, dst->ssid_len);\n\t\tdst->ssid_len = src->ssid_len;\n\t\tmemcpy(dst->ssid, src->ssid, src->ssid_len);\n\t}\n\tdst->mode = src->mode;\n\tdst->flags = src->flags;\n\tdst->time_stamp[0] = src->time_stamp[0];\n\tdst->time_stamp[1] = src->time_stamp[1];\n\tif (src->flags & NETWORK_HAS_ERP_VALUE) {\n\t\tdst->erp_value = src->erp_value;\n\t\tdst->berp_info_valid = src->berp_info_valid = true;\n\t}\n\tdst->beacon_interval = src->beacon_interval;\n\tdst->listen_interval = src->listen_interval;\n\tdst->atim_window = src->atim_window;\n\tdst->dtim_period = src->dtim_period;\n\tdst->dtim_data = src->dtim_data;\n\tdst->last_dtim_sta_time[0] = src->last_dtim_sta_time[0];\n\tdst->last_dtim_sta_time[1] = src->last_dtim_sta_time[1];\n\tmemcpy(&dst->tim, &src->tim, sizeof(struct ieee80211_tim_parameters));\n\n\tdst->bssht.bdSupportHT = src->bssht.bdSupportHT;\n\tdst->bssht.bdRT2RTAggregation = src->bssht.bdRT2RTAggregation;\n\tdst->bssht.bdHTCapLen = src->bssht.bdHTCapLen;\n\tmemcpy(dst->bssht.bdHTCapBuf, src->bssht.bdHTCapBuf, src->bssht.bdHTCapLen);\n\tdst->bssht.bdHTInfoLen = src->bssht.bdHTInfoLen;\n\tmemcpy(dst->bssht.bdHTInfoBuf, src->bssht.bdHTInfoBuf, src->bssht.bdHTInfoLen);\n\tdst->bssht.bdHTSpecVer = src->bssht.bdHTSpecVer;\n\tdst->bssht.bdRT2RTLongSlotTime = src->bssht.bdRT2RTLongSlotTime;\n\tdst->broadcom_cap_exist = src->broadcom_cap_exist;\n\tdst->ralink_cap_exist = src->ralink_cap_exist;\n\tdst->atheros_cap_exist = src->atheros_cap_exist;\n\tdst->cisco_cap_exist = src->cisco_cap_exist;\n\tdst->unknown_cap_exist = src->unknown_cap_exist;\n\tmemcpy(dst->wpa_ie, src->wpa_ie, src->wpa_ie_len);\n\tdst->wpa_ie_len = src->wpa_ie_len;\n\tmemcpy(dst->rsn_ie, src->rsn_ie, src->rsn_ie_len);\n\tdst->rsn_ie_len = src->rsn_ie_len;\n\n\tdst->last_scanned = jiffies;\n\t \n\t\n\tqos_active = dst->qos_data.active;\n\t\n\told_param = dst->qos_data.param_count;\n\tif (dst->flags & NETWORK_HAS_QOS_MASK)\n\t\tmemcpy(&dst->qos_data, &src->qos_data,\n\t\t\tsizeof(struct ieee80211_qos_data));\n\telse {\n\t\tdst->qos_data.supported = src->qos_data.supported;\n\t\tdst->qos_data.param_count = src->qos_data.param_count;\n\t}\n\n\tif (dst->qos_data.supported == 1) {\n\t\tdst->QoS_Enable = 1;\n\t\tif (dst->ssid_len)\n\t\t\tIEEE80211_DEBUG_QOS\n\t\t\t\t(\"QoS the network %s is QoS supported\\n\",\n\t\t\t\tdst->ssid);\n\t\telse\n\t\t\tIEEE80211_DEBUG_QOS\n\t\t\t\t(\"QoS the network is QoS supported\\n\");\n\t}\n\tdst->qos_data.active = qos_active;\n\tdst->qos_data.old_param_count = old_param;\n\n\t \n\tdst->wmm_info = src->wmm_info; \n\tif (src->wmm_param[0].aci_aifsn || \\\n\t   src->wmm_param[1].aci_aifsn || \\\n\t   src->wmm_param[2].aci_aifsn || \\\n\t   src->wmm_param[3].aci_aifsn) {\n\t\tmemcpy(dst->wmm_param, src->wmm_param, WME_AC_PRAM_LEN);\n\t}\n\t\n#ifdef THOMAS_TURBO\n\tdst->Turbo_Enable = src->Turbo_Enable;\n#endif\n\n\tdst->CountryIeLen = src->CountryIeLen;\n\tmemcpy(dst->CountryIeBuf, src->CountryIeBuf, src->CountryIeLen);\n\n\t\n\tdst->bWithAironetIE = src->bWithAironetIE;\n\tdst->bCkipSupported = src->bCkipSupported;\n\tmemcpy(dst->CcxRmState, src->CcxRmState, 2);\n\tdst->bCcxRmEnable = src->bCcxRmEnable;\n\tdst->MBssidMask = src->MBssidMask;\n\tdst->bMBssidValid = src->bMBssidValid;\n\tmemcpy(dst->MBssid, src->MBssid, 6);\n\tdst->bWithCcxVerNum = src->bWithCcxVerNum;\n\tdst->BssCcxVerNumber = src->BssCcxVerNumber;\n\n}\n\nstatic inline int is_beacon(__le16 fc)\n{\n\treturn (WLAN_FC_GET_STYPE(le16_to_cpu(fc)) == IEEE80211_STYPE_BEACON);\n}\n\nstatic inline void ieee80211_process_probe_response(\n\tstruct ieee80211_device *ieee,\n\tstruct ieee80211_probe_response *beacon,\n\tstruct ieee80211_rx_stats *stats)\n{\n\tstruct ieee80211_network *network;\n\tstruct ieee80211_network *target;\n\tstruct ieee80211_network *oldest = NULL;\n#ifdef CONFIG_IEEE80211_DEBUG\n\tstruct ieee80211_info_element *info_element = &beacon->info_element[0];\n#endif\n\tint fc = WLAN_FC_GET_STYPE(le16_to_cpu(beacon->header.frame_ctl));\n\tunsigned long flags;\n\tshort renew;\n\tu16 capability;\n\t\n\n\tnetwork = kzalloc(sizeof(*network), GFP_ATOMIC);\n\tif (!network)\n\t\tgoto out;\n\n\tcapability = le16_to_cpu(beacon->capability);\n\tIEEE80211_DEBUG_SCAN(\n\t\t\"'%s' (%pM): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\\n\",\n\t\tescape_essid(info_element->data, info_element->len),\n\t\tbeacon->header.addr3,\n\t\t(capability & BIT(0xf)) ? '1' : '0',\n\t\t(capability & BIT(0xe)) ? '1' : '0',\n\t\t(capability & BIT(0xd)) ? '1' : '0',\n\t\t(capability & BIT(0xc)) ? '1' : '0',\n\t\t(capability & BIT(0xb)) ? '1' : '0',\n\t\t(capability & BIT(0xa)) ? '1' : '0',\n\t\t(capability & BIT(0x9)) ? '1' : '0',\n\t\t(capability & BIT(0x8)) ? '1' : '0',\n\t\t(capability & BIT(0x7)) ? '1' : '0',\n\t\t(capability & BIT(0x6)) ? '1' : '0',\n\t\t(capability & BIT(0x5)) ? '1' : '0',\n\t\t(capability & BIT(0x4)) ? '1' : '0',\n\t\t(capability & BIT(0x3)) ? '1' : '0',\n\t\t(capability & BIT(0x2)) ? '1' : '0',\n\t\t(capability & BIT(0x1)) ? '1' : '0',\n\t\t(capability & BIT(0x0)) ? '1' : '0');\n\n\tif (ieee80211_network_init(ieee, beacon, network, stats)) {\n\t\tIEEE80211_DEBUG_SCAN(\"Dropped '%s' (%pM) via %s.\\n\",\n\t\t\t\t     escape_essid(info_element->data,\n\t\t\t\t\t\t  info_element->len),\n\t\t\t\t     beacon->header.addr3,\n\t\t\t\t     fc == IEEE80211_STYPE_PROBE_RESP ?\n\t\t\t\t     \"PROBE RESPONSE\" : \"BEACON\");\n\t\tgoto out;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\n\tif (!is_legal_channel(ieee, network->channel))\n\t\tgoto out;\n\tif (ieee->bGlobalDomain) {\n\t\tif (fc == IEEE80211_STYPE_PROBE_RESP) {\n\t\t\tif (IS_COUNTRY_IE_VALID(ieee)) {\n\t\t\t\t\n\t\t\t\tif (!is_legal_channel(ieee, network->channel)) {\n\t\t\t\t\tnetdev_warn(ieee->dev, \"GetScanInfo(): For Country code, filter probe response at channel(%d).\\n\", network->channel);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (network->channel > 11) {\n\t\t\t\t\tnetdev_warn(ieee->dev, \"GetScanInfo(): For Global Domain, filter probe response at channel(%d).\\n\", network->channel);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (IS_COUNTRY_IE_VALID(ieee)) {\n\t\t\t\t\n\t\t\t\tif (!is_legal_channel(ieee, network->channel)) {\n\t\t\t\t\tnetdev_warn(ieee->dev, \"GetScanInfo(): For Country code, filter beacon at channel(%d).\\n\", network->channel);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (network->channel > 14) {\n\t\t\t\t\tnetdev_warn(ieee->dev, \"GetScanInfo(): For Global Domain, filter beacon at channel(%d).\\n\", network->channel);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\t \n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif (is_same_network(&ieee->current_network, network, ieee)) {\n\t\tupdate_network(&ieee->current_network, network);\n\t\tif ((ieee->current_network.mode == IEEE_N_24G || ieee->current_network.mode == IEEE_G)\n\t\t    && ieee->current_network.berp_info_valid){\n\t\t\tif (ieee->current_network.erp_value & ERP_UseProtection)\n\t\t\t\tieee->current_network.buseprotection = true;\n\t\t\telse\n\t\t\t\tieee->current_network.buseprotection = false;\n\t\t}\n\t\tif (is_beacon(beacon->header.frame_ctl)) {\n\t\t\tif (ieee->state == IEEE80211_LINKED)\n\t\t\t\tieee->LinkDetectInfo.NumRecvBcnInPeriod++;\n\t\t} else  \n\t\t\tnetwork->flags = (~NETWORK_EMPTY_ESSID & network->flags) | (NETWORK_EMPTY_ESSID & ieee->current_network.flags);\n\t}\n\n\tlist_for_each_entry(target, &ieee->network_list, list) {\n\t\tif (is_same_network(target, network, ieee))\n\t\t\tbreak;\n\t\tif (!oldest ||\n\t\t    (target->last_scanned < oldest->last_scanned))\n\t\t\toldest = target;\n\t}\n\n\t \n\tif (&target->list == &ieee->network_list) {\n\t\tif (list_empty(&ieee->network_free_list)) {\n\t\t\t \n\t\t\tlist_del(&oldest->list);\n\t\t\ttarget = oldest;\n\t\t\tIEEE80211_DEBUG_SCAN(\"Expired '%s' (%pM) from \"\n\t\t\t\t\t     \"network list.\\n\",\n\t\t\t\t\t     escape_essid(target->ssid,\n\t\t\t\t\t\t\t  target->ssid_len),\n\t\t\t\t\t     target->bssid);\n\t\t} else {\n\t\t\t \n\t\t\ttarget = list_entry(ieee->network_free_list.next,\n\t\t\t\t\t    struct ieee80211_network, list);\n\t\t\tlist_del(ieee->network_free_list.next);\n\t\t}\n\n\n#ifdef CONFIG_IEEE80211_DEBUG\n\t\tIEEE80211_DEBUG_SCAN(\"Adding '%s' (%pM) via %s.\\n\",\n\t\t\t\t     escape_essid(network->ssid,\n\t\t\t\t\t\t  network->ssid_len),\n\t\t\t\t     network->bssid,\n\t\t\t\t     fc == IEEE80211_STYPE_PROBE_RESP ?\n\t\t\t\t     \"PROBE RESPONSE\" : \"BEACON\");\n#endif\n\t\tmemcpy(target, network, sizeof(*target));\n\t\tlist_add_tail(&target->list, &ieee->network_list);\n\t\tif (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE)\n\t\t\tieee80211_softmac_new_net(ieee, network);\n\t} else {\n\t\tIEEE80211_DEBUG_SCAN(\"Updating '%s' (%pM) via %s.\\n\",\n\t\t\t\t     escape_essid(target->ssid,\n\t\t\t\t\t\t  target->ssid_len),\n\t\t\t\t     target->bssid,\n\t\t\t\t     fc == IEEE80211_STYPE_PROBE_RESP ?\n\t\t\t\t     \"PROBE RESPONSE\" : \"BEACON\");\n\n\t\t \n\t\trenew = !time_after(target->last_scanned + ieee->scan_age, jiffies);\n\t\t \n\t\tif (is_beacon(beacon->header.frame_ctl) == 0)\n\t\t\tnetwork->flags = (~NETWORK_EMPTY_ESSID & network->flags) | (NETWORK_EMPTY_ESSID & target->flags);\n\t\t \n\t\t \n\t\tif (((network->flags & NETWORK_EMPTY_ESSID) == NETWORK_EMPTY_ESSID) \\\n\t\t    && (((network->ssid_len > 0) && (strncmp(target->ssid, network->ssid, network->ssid_len)))\\\n || ((ieee->current_network.ssid_len == network->ssid_len) && (strncmp(ieee->current_network.ssid, network->ssid, network->ssid_len) == 0) && (ieee->state == IEEE80211_NOLINK))))\n\t\t\trenew = 1;\n\t\t\n\n\t\tupdate_network(target, network);\n\t\tif (renew && (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE))\n\t\t\tieee80211_softmac_new_net(ieee, network);\n\t}\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\tif (is_beacon(beacon->header.frame_ctl) && is_same_network(&ieee->current_network, network, ieee) && \\\n\t\t(ieee->state == IEEE80211_LINKED)) {\n\t\tif (ieee->handle_beacon)\n\t\t\tieee->handle_beacon(ieee->dev, beacon, &ieee->current_network);\n\t}\n\nout:\n\tkfree(network);\n}\n\nvoid ieee80211_rx_mgt(struct ieee80211_device *ieee,\n\t\t      struct rtl_80211_hdr_4addr *header,\n\t\t      struct ieee80211_rx_stats *stats)\n{\n\tswitch (WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl))) {\n\n\tcase IEEE80211_STYPE_BEACON:\n\t\tIEEE80211_DEBUG_MGMT(\"received BEACON (%d)\\n\",\n\t\t\tWLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));\n\t\tIEEE80211_DEBUG_SCAN(\"Beacon\\n\");\n\t\tieee80211_process_probe_response(\n\t\t\tieee, (struct ieee80211_probe_response *)header, stats);\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_PROBE_RESP:\n\t\tIEEE80211_DEBUG_MGMT(\"received PROBE RESPONSE (%d)\\n\",\n\t\t\tWLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));\n\t\tIEEE80211_DEBUG_SCAN(\"Probe response\\n\");\n\t\tieee80211_process_probe_response(\n\t\t\tieee, (struct ieee80211_probe_response *)header, stats);\n\t\tbreak;\n\n\t}\n}\nEXPORT_SYMBOL(ieee80211_rx_mgt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}