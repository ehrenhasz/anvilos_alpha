{
  "module_name": "ieee80211_crypt.c",
  "hash_id": "0fbbcbd0fa42de08d7492dc913a08a0fcd9396cf463db551b58c226bc7532cb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n\n#include \"ieee80211.h\"\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"HostAP crypto\");\nMODULE_LICENSE(\"GPL\");\n\nstruct ieee80211_crypto_alg {\n\tstruct list_head list;\n\tstruct ieee80211_crypto_ops *ops;\n};\n\n\nstruct ieee80211_crypto {\n\tstruct list_head algs;\n\tspinlock_t lock;\n};\n\nstatic struct ieee80211_crypto *hcrypt;\n\nvoid ieee80211_crypt_deinit_entries(struct ieee80211_device *ieee,\n\t\t\t\t\t   int force)\n{\n\tstruct list_head *ptr, *n;\n\tstruct ieee80211_crypt_data *entry;\n\n\tfor (ptr = ieee->crypt_deinit_list.next, n = ptr->next;\n\t     ptr != &ieee->crypt_deinit_list; ptr = n, n = ptr->next) {\n\t\tentry = list_entry(ptr, struct ieee80211_crypt_data, list);\n\n\t\tif (atomic_read(&entry->refcnt) != 0 && !force)\n\t\t\tcontinue;\n\n\t\tlist_del(ptr);\n\n\t\tif (entry->ops)\n\t\t\tentry->ops->deinit(entry->priv);\n\t\tkfree(entry);\n\t}\n}\n\nvoid ieee80211_crypt_deinit_handler(struct timer_list *t)\n{\n\tstruct ieee80211_device *ieee = from_timer(ieee, t, crypt_deinit_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\tieee80211_crypt_deinit_entries(ieee, 0);\n\tif (!list_empty(&ieee->crypt_deinit_list)) {\n\t\tnetdev_dbg(ieee->dev, \"%s: entries remaining in delayed crypt deletion list\\n\",\n\t\t\t\tieee->dev->name);\n\t\tieee->crypt_deinit_timer.expires = jiffies + HZ;\n\t\tadd_timer(&ieee->crypt_deinit_timer);\n\t}\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\n}\n\nvoid ieee80211_crypt_delayed_deinit(struct ieee80211_device *ieee,\n\t\t\t\t    struct ieee80211_crypt_data **crypt)\n{\n\tstruct ieee80211_crypt_data *tmp;\n\tunsigned long flags;\n\n\tif (!(*crypt))\n\t\treturn;\n\n\ttmp = *crypt;\n\t*crypt = NULL;\n\n\t \n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\tlist_add(&tmp->list, &ieee->crypt_deinit_list);\n\tif (!timer_pending(&ieee->crypt_deinit_timer)) {\n\t\tieee->crypt_deinit_timer.expires = jiffies + HZ;\n\t\tadd_timer(&ieee->crypt_deinit_timer);\n\t}\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\n\nint ieee80211_register_crypto_ops(struct ieee80211_crypto_ops *ops)\n{\n\tunsigned long flags;\n\tstruct ieee80211_crypto_alg *alg;\n\n\tif (!hcrypt)\n\t\treturn -1;\n\n\talg = kzalloc(sizeof(*alg), GFP_KERNEL);\n\tif (!alg)\n\t\treturn -ENOMEM;\n\n\talg->ops = ops;\n\n\tspin_lock_irqsave(&hcrypt->lock, flags);\n\tlist_add(&alg->list, &hcrypt->algs);\n\tspin_unlock_irqrestore(&hcrypt->lock, flags);\n\n\tpr_debug(\"ieee80211_crypt: registered algorithm '%s'\\n\",\n\t       ops->name);\n\n\treturn 0;\n}\n\nint ieee80211_unregister_crypto_ops(struct ieee80211_crypto_ops *ops)\n{\n\tunsigned long flags;\n\tstruct list_head *ptr;\n\tstruct ieee80211_crypto_alg *del_alg = NULL;\n\n\tif (!hcrypt)\n\t\treturn -1;\n\n\tspin_lock_irqsave(&hcrypt->lock, flags);\n\tfor (ptr = hcrypt->algs.next; ptr != &hcrypt->algs; ptr = ptr->next) {\n\t\tstruct ieee80211_crypto_alg *alg =\n\t\t\t(struct ieee80211_crypto_alg *)ptr;\n\t\tif (alg->ops == ops) {\n\t\t\tlist_del(&alg->list);\n\t\t\tdel_alg = alg;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&hcrypt->lock, flags);\n\n\tif (del_alg) {\n\t\tpr_debug(\"ieee80211_crypt: unregistered algorithm '%s'\\n\",\n\t\t\t\tops->name);\n\t\tkfree(del_alg);\n\t}\n\n\treturn del_alg ? 0 : -1;\n}\n\n\nstruct ieee80211_crypto_ops *ieee80211_get_crypto_ops(const char *name)\n{\n\tunsigned long flags;\n\tstruct list_head *ptr;\n\tstruct ieee80211_crypto_alg *found_alg = NULL;\n\n\tif (!hcrypt)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&hcrypt->lock, flags);\n\tfor (ptr = hcrypt->algs.next; ptr != &hcrypt->algs; ptr = ptr->next) {\n\t\tstruct ieee80211_crypto_alg *alg =\n\t\t\t(struct ieee80211_crypto_alg *)ptr;\n\t\tif (strcmp(alg->ops->name, name) == 0) {\n\t\t\tfound_alg = alg;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&hcrypt->lock, flags);\n\n\tif (found_alg)\n\t\treturn found_alg->ops;\n\treturn NULL;\n}\n\n\nstatic void *ieee80211_crypt_null_init(int keyidx) { return (void *)1; }\nstatic void ieee80211_crypt_null_deinit(void *priv) {}\n\nstatic struct ieee80211_crypto_ops ieee80211_crypt_null = {\n\t.name\t\t\t= \"NULL\",\n\t.init\t\t\t= ieee80211_crypt_null_init,\n\t.deinit\t\t\t= ieee80211_crypt_null_deinit,\n\t.encrypt_mpdu\t\t= NULL,\n\t.decrypt_mpdu\t\t= NULL,\n\t.encrypt_msdu\t\t= NULL,\n\t.decrypt_msdu\t\t= NULL,\n\t.set_key\t\t= NULL,\n\t.get_key\t\t= NULL,\n\t.extra_prefix_len\t= 0,\n\t.extra_postfix_len\t= 0,\n\t.owner\t\t\t= THIS_MODULE,\n};\n\nint __init ieee80211_crypto_init(void)\n{\n\tint ret = -ENOMEM;\n\n\thcrypt = kzalloc(sizeof(*hcrypt), GFP_KERNEL);\n\tif (!hcrypt)\n\t\tgoto out;\n\n\tINIT_LIST_HEAD(&hcrypt->algs);\n\tspin_lock_init(&hcrypt->lock);\n\n\tret = ieee80211_register_crypto_ops(&ieee80211_crypt_null);\n\tif (ret < 0) {\n\t\tkfree(hcrypt);\n\t\thcrypt = NULL;\n\t}\nout:\n\treturn ret;\n}\n\nvoid ieee80211_crypto_deinit(void)\n{\n\tstruct list_head *ptr, *n;\n\n\tif (!hcrypt)\n\t\treturn;\n\n\tfor (ptr = hcrypt->algs.next, n = ptr->next; ptr != &hcrypt->algs;\n\t     ptr = n, n = ptr->next) {\n\t\tstruct ieee80211_crypto_alg *alg =\n\t\t\t(struct ieee80211_crypto_alg *)ptr;\n\t\tlist_del(ptr);\n\t\tpr_debug(\"ieee80211_crypt: unregistered algorithm '%s' (deinit)\\n\",\n\t\t\t\talg->ops->name);\n\t\tkfree(alg);\n\t}\n\n\tkfree(hcrypt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}