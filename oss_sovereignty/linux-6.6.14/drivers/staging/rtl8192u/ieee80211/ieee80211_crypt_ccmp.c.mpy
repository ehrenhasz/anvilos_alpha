{
  "module_name": "ieee80211_crypt_ccmp.c",
  "hash_id": "c99152b4da219d3b39d7a265f5de9f9a637748465ac40f27318723cd8f1bdb2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_ccmp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/if_ether.h>\n#include <linux/if_arp.h>\n#include <linux/string.h>\n#include <linux/wireless.h>\n\n#include \"ieee80211.h\"\n\n#include <linux/crypto.h>\n#include <crypto/aead.h>\n    #include <linux/scatterlist.h>\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"Host AP crypt: CCMP\");\nMODULE_LICENSE(\"GPL\");\n\n#define AES_BLOCK_LEN 16\n#define CCMP_HDR_LEN 8\n#define CCMP_MIC_LEN 8\n#define CCMP_TK_LEN 16\n#define CCMP_PN_LEN 6\n\nstruct ieee80211_ccmp_data {\n\tu8 key[CCMP_TK_LEN];\n\tint key_set;\n\n\tu8 tx_pn[CCMP_PN_LEN];\n\tu8 rx_pn[CCMP_PN_LEN];\n\n\tu32 dot11RSNAStatsCCMPFormatErrors;\n\tu32 dot11RSNAStatsCCMPReplays;\n\tu32 dot11RSNAStatsCCMPDecryptErrors;\n\n\tint key_idx;\n\n\tstruct crypto_aead *tfm;\n\n\t \n\tu8 tx_aad[2 * AES_BLOCK_LEN];\n\tu8 rx_aad[2 * AES_BLOCK_LEN];\n};\n\nstatic void *ieee80211_ccmp_init(int key_idx)\n{\n\tstruct ieee80211_ccmp_data *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\tgoto fail;\n\tpriv->key_idx = key_idx;\n\n\tpriv->tfm = crypto_alloc_aead(\"ccm(aes)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(priv->tfm)) {\n\t\tpr_debug(\"ieee80211_crypt_ccmp: could not allocate crypto API aes\\n\");\n\t\tpriv->tfm = NULL;\n\t\tgoto fail;\n\t}\n\n\treturn priv;\n\nfail:\n\tif (priv) {\n\t\tif (priv->tfm)\n\t\t\tcrypto_free_aead(priv->tfm);\n\t\tkfree(priv);\n\t}\n\n\treturn NULL;\n}\n\nstatic void ieee80211_ccmp_deinit(void *priv)\n{\n\tstruct ieee80211_ccmp_data *_priv = priv;\n\n\tif (_priv && _priv->tfm)\n\t\tcrypto_free_aead(_priv->tfm);\n\tkfree(priv);\n}\n\nstatic int ccmp_init_iv_and_aad(struct rtl_80211_hdr_4addr *hdr,\n\t\t\t     u8 *pn, u8 *iv, u8 *aad)\n{\n\tu8 *pos, qc = 0;\n\tsize_t aad_len;\n\tu16 fc;\n\tint a4_included, qc_included;\n\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\ta4_included = ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t\t       (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS));\n\t \n\t \n\tqc_included = (WLAN_FC_GET_TYPE(fc) == IEEE80211_FTYPE_DATA) &&\n\t\t       (WLAN_FC_GET_STYPE(fc) & 0x80);\n\taad_len = 22;\n\tif (a4_included)\n\t\taad_len += 6;\n\tif (qc_included) {\n\t\tpos = (u8 *)&hdr->addr4;\n\t\tif (a4_included)\n\t\t\tpos += 6;\n\t\tqc = *pos & 0x0f;\n\t\taad_len += 2;\n\t}\n\n\t \n\tiv[0] = 0x1;\n\n\t \n\tiv[1] = qc;\n\tmemcpy(iv + 2, hdr->addr2, ETH_ALEN);\n\tmemcpy(iv + 8, pn, CCMP_PN_LEN);\n\n\t \n\tpos = (u8 *)hdr;\n\taad[0] = pos[0] & 0x8f;\n\taad[1] = pos[1] & 0xc7;\n\tmemcpy(&aad[2], &hdr->addr1, ETH_ALEN);\n\tmemcpy(&aad[8], &hdr->addr2, ETH_ALEN);\n\tmemcpy(&aad[14], &hdr->addr3, ETH_ALEN);\n\tpos = (u8 *)&hdr->seq_ctl;\n\taad[20] = pos[0] & 0x0f;\n\taad[21] = 0;  \n\tmemset(aad + 22, 0, 8);\n\tif (a4_included)\n\t\tmemcpy(aad + 22, hdr->addr4, ETH_ALEN);\n\tif (qc_included) {\n\t\taad[a4_included ? 28 : 22] = qc;\n\t\t \n\t}\n\n\treturn aad_len;\n}\n\nstatic int ieee80211_ccmp_encrypt(struct sk_buff *skb, int hdr_len, void *priv)\n{\n\tstruct ieee80211_ccmp_data *key = priv;\n\tint i;\n\tu8 *pos;\n\tstruct rtl_80211_hdr_4addr *hdr;\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\n\tif (skb_headroom(skb) < CCMP_HDR_LEN ||\n\t    skb_tailroom(skb) < CCMP_MIC_LEN ||\n\t    skb->len < hdr_len)\n\t\treturn -1;\n\n\tpos = skb_push(skb, CCMP_HDR_LEN);\n\tmemmove(pos, pos + CCMP_HDR_LEN, hdr_len);\n\tpos += hdr_len;\n\t \n\n\ti = CCMP_PN_LEN - 1;\n\twhile (i >= 0) {\n\t\tkey->tx_pn[i]++;\n\t\tif (key->tx_pn[i] != 0)\n\t\t\tbreak;\n\t\ti--;\n\t}\n\n\t*pos++ = key->tx_pn[5];\n\t*pos++ = key->tx_pn[4];\n\t*pos++ = 0;\n\t*pos++ = (key->key_idx << 6) | BIT(5)  ;\n\t*pos++ = key->tx_pn[3];\n\t*pos++ = key->tx_pn[2];\n\t*pos++ = key->tx_pn[1];\n\t*pos++ = key->tx_pn[0];\n\n\thdr = (struct rtl_80211_hdr_4addr *)skb->data;\n\tif (!tcb_desc->bHwSec) {\n\t\tstruct aead_request *req;\n\t\tstruct scatterlist sg[2];\n\t\tu8 *aad = key->tx_aad;\n\t\tu8 iv[AES_BLOCK_LEN];\n\t\tint aad_len, ret;\n\t\tsize_t data_len = skb->len - hdr_len - CCMP_HDR_LEN;\n\n\t\treq = aead_request_alloc(key->tfm, GFP_ATOMIC);\n\t\tif (!req)\n\t\t\treturn -ENOMEM;\n\n\t\taad_len = ccmp_init_iv_and_aad(hdr, key->tx_pn, iv, aad);\n\n\t\tskb_put(skb, CCMP_MIC_LEN);\n\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], aad, aad_len);\n\t\tsg_set_buf(&sg[1], skb->data + hdr_len + CCMP_HDR_LEN,\n\t\t\t   data_len + CCMP_MIC_LEN);\n\n\t\taead_request_set_callback(req, 0, NULL, NULL);\n\t\taead_request_set_ad(req, aad_len);\n\t\taead_request_set_crypt(req, sg, sg, data_len, iv);\n\n\t\tret = crypto_aead_encrypt(req);\n\t\taead_request_free(req);\n\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int ieee80211_ccmp_decrypt(struct sk_buff *skb, int hdr_len, void *priv)\n{\n\tstruct ieee80211_ccmp_data *key = priv;\n\tu8 keyidx, *pos;\n\tstruct rtl_80211_hdr_4addr *hdr;\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\tu8 pn[6];\n\n\tif (skb->len < hdr_len + CCMP_HDR_LEN + CCMP_MIC_LEN) {\n\t\tkey->dot11RSNAStatsCCMPFormatErrors++;\n\t\treturn -1;\n\t}\n\n\thdr = (struct rtl_80211_hdr_4addr *)skb->data;\n\tpos = skb->data + hdr_len;\n\tkeyidx = pos[3];\n\tif (!(keyidx & BIT(5))) {\n\t\tif (net_ratelimit()) {\n\t\t\tnetdev_dbg(skb->dev, \"CCMP: received packet without ExtIV flag from %pM\\n\",\n\t\t\t\t   hdr->addr2);\n\t\t}\n\t\tkey->dot11RSNAStatsCCMPFormatErrors++;\n\t\treturn -2;\n\t}\n\tkeyidx >>= 6;\n\tif (key->key_idx != keyidx) {\n\t\tnetdev_dbg(skb->dev, \"CCMP: RX tkey->key_idx=%d frame keyidx=%d priv=%p\\n\",\n\t\t\t   key->key_idx, keyidx, priv);\n\t\treturn -6;\n\t}\n\tif (!key->key_set) {\n\t\tif (net_ratelimit()) {\n\t\t\tnetdev_dbg(skb->dev, \"CCMP: received packet from %pM with keyid=%d that does not have a configured key\\n\",\n\t\t\t\t   hdr->addr2, keyidx);\n\t\t}\n\t\treturn -3;\n\t}\n\n\tpn[0] = pos[7];\n\tpn[1] = pos[6];\n\tpn[2] = pos[5];\n\tpn[3] = pos[4];\n\tpn[4] = pos[1];\n\tpn[5] = pos[0];\n\tpos += 8;\n\n\tif (memcmp(pn, key->rx_pn, CCMP_PN_LEN) <= 0) {\n\t\tif (net_ratelimit()) {\n\t\t\tnetdev_dbg(skb->dev, \"CCMP: replay detected: STA=%pM previous PN %pm received PN %pm\\n\",\n\t\t\t\t   hdr->addr2, key->rx_pn, pn);\n\t\t}\n\t\tkey->dot11RSNAStatsCCMPReplays++;\n\t\treturn -4;\n\t}\n\tif (!tcb_desc->bHwSec) {\n\t\tstruct aead_request *req;\n\t\tstruct scatterlist sg[2];\n\t\tu8 *aad = key->rx_aad;\n\t\tu8 iv[AES_BLOCK_LEN];\n\t\tint aad_len, ret;\n\t\tsize_t data_len = skb->len - hdr_len - CCMP_HDR_LEN;\n\n\t\treq = aead_request_alloc(key->tfm, GFP_ATOMIC);\n\t\tif (!req)\n\t\t\treturn -ENOMEM;\n\n\t\taad_len = ccmp_init_iv_and_aad(hdr, pn, iv, aad);\n\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], aad, aad_len);\n\t\tsg_set_buf(&sg[1], pos, data_len);\n\n\t\taead_request_set_callback(req, 0, NULL, NULL);\n\t\taead_request_set_ad(req, aad_len);\n\t\taead_request_set_crypt(req, sg, sg, data_len, iv);\n\n\t\tret = crypto_aead_decrypt(req);\n\t\taead_request_free(req);\n\n\t\tif (ret) {\n\t\t\tif (net_ratelimit()) {\n\t\t\t\tnetdev_dbg(skb->dev, \"CCMP: decrypt failed: STA=%pM\\n\",\n\t\t\t\t\t   hdr->addr2);\n\t\t\t}\n\t\t\tkey->dot11RSNAStatsCCMPDecryptErrors++;\n\t\t\treturn -5;\n\t\t}\n\n\t\tmemcpy(key->rx_pn, pn, CCMP_PN_LEN);\n\t}\n\t \n\tmemmove(skb->data + CCMP_HDR_LEN, skb->data, hdr_len);\n\tskb_pull(skb, CCMP_HDR_LEN);\n\tskb_trim(skb, skb->len - CCMP_MIC_LEN);\n\n\treturn keyidx;\n}\n\nstatic int ieee80211_ccmp_set_key(void *key, int len, u8 *seq, void *priv)\n{\n\tstruct ieee80211_ccmp_data *data = priv;\n\tint keyidx;\n\tstruct crypto_aead *tfm = data->tfm;\n\n\tkeyidx = data->key_idx;\n\tmemset(data, 0, sizeof(*data));\n\tdata->key_idx = keyidx;\n\tif (len == CCMP_TK_LEN) {\n\t\tmemcpy(data->key, key, CCMP_TK_LEN);\n\t\tdata->key_set = 1;\n\t\tif (seq) {\n\t\t\tdata->rx_pn[0] = seq[5];\n\t\t\tdata->rx_pn[1] = seq[4];\n\t\t\tdata->rx_pn[2] = seq[3];\n\t\t\tdata->rx_pn[3] = seq[2];\n\t\t\tdata->rx_pn[4] = seq[1];\n\t\t\tdata->rx_pn[5] = seq[0];\n\t\t}\n\t\tif (crypto_aead_setauthsize(tfm, CCMP_MIC_LEN) ||\n\t\t    crypto_aead_setkey(tfm, data->key, CCMP_TK_LEN))\n\t\t\treturn -1;\n\t} else if (len == 0) {\n\t\tdata->key_set = 0;\n\t} else {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ieee80211_ccmp_get_key(void *key, int len, u8 *seq, void *priv)\n{\n\tstruct ieee80211_ccmp_data *data = priv;\n\n\tif (len < CCMP_TK_LEN)\n\t\treturn 0;\n\n\tif (!data->key_set)\n\t\treturn 0;\n\tmemcpy(key, data->key, CCMP_TK_LEN);\n\n\tif (seq) {\n\t\tseq[0] = data->tx_pn[5];\n\t\tseq[1] = data->tx_pn[4];\n\t\tseq[2] = data->tx_pn[3];\n\t\tseq[3] = data->tx_pn[2];\n\t\tseq[4] = data->tx_pn[1];\n\t\tseq[5] = data->tx_pn[0];\n\t}\n\n\treturn CCMP_TK_LEN;\n}\n\nstatic char *ieee80211_ccmp_print_stats(char *p, void *priv)\n{\n\tstruct ieee80211_ccmp_data *ccmp = priv;\n\n\tp += sprintf(p, \"key[%d] alg=CCMP key_set=%d tx_pn=%pm rx_pn=%pm format_errors=%d replays=%d decrypt_errors=%d\\n\",\n\t\t     ccmp->key_idx, ccmp->key_set,\n\t\t     ccmp->tx_pn, ccmp->rx_pn,\n\t\t     ccmp->dot11RSNAStatsCCMPFormatErrors,\n\t\t     ccmp->dot11RSNAStatsCCMPReplays,\n\t\t     ccmp->dot11RSNAStatsCCMPDecryptErrors);\n\n\treturn p;\n}\n\nstatic struct ieee80211_crypto_ops ieee80211_crypt_ccmp = {\n\t.name\t\t\t= \"CCMP\",\n\t.init\t\t\t= ieee80211_ccmp_init,\n\t.deinit\t\t\t= ieee80211_ccmp_deinit,\n\t.encrypt_mpdu\t\t= ieee80211_ccmp_encrypt,\n\t.decrypt_mpdu\t\t= ieee80211_ccmp_decrypt,\n\t.encrypt_msdu\t\t= NULL,\n\t.decrypt_msdu\t\t= NULL,\n\t.set_key\t\t= ieee80211_ccmp_set_key,\n\t.get_key\t\t= ieee80211_ccmp_get_key,\n\t.print_stats\t\t= ieee80211_ccmp_print_stats,\n\t.extra_prefix_len\t= CCMP_HDR_LEN,\n\t.extra_postfix_len\t= CCMP_MIC_LEN,\n\t.owner\t\t\t= THIS_MODULE,\n};\n\nint __init ieee80211_crypto_ccmp_init(void)\n{\n\treturn ieee80211_register_crypto_ops(&ieee80211_crypt_ccmp);\n}\n\nvoid ieee80211_crypto_ccmp_exit(void)\n{\n\tieee80211_unregister_crypto_ops(&ieee80211_crypt_ccmp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}