{
  "module_name": "ieee80211_wx.c",
  "hash_id": "f1ca6b8a93407560dd6dc811e6019413b933a49740ccec6675806fae361268cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c",
  "human_readable_source": "\n \n#include <linux/wireless.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include \"ieee80211.h\"\nstruct modes_unit {\n\tchar *mode_string;\n\tint mode_size;\n};\nstatic struct modes_unit ieee80211_modes[] = {\n\t{\"a\", 1},\n\t{\"b\", 1},\n\t{\"g\", 1},\n\t{\"?\", 1},\n\t{\"N-24G\", 5},\n\t{\"N-5G\", 4},\n};\n\n#define iwe_stream_add_event_rsl iwe_stream_add_event\n\n#define MAX_CUSTOM_LEN 64\nstatic inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,\n\t\t\t\t\t   char *start, char *stop,\n\t\t\t\t\t   struct ieee80211_network *network,\n\t\t\t\t\t   struct iw_request_info *info)\n{\n\tchar custom[MAX_CUSTOM_LEN];\n\tchar proto_name[IFNAMSIZ];\n\tchar *pname = proto_name;\n\tchar *p;\n\tstruct iw_event iwe;\n\tint i, j;\n\tu16 max_rate, rate;\n\tstatic u8\tEWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};\n\n\t \n\tiwe.cmd = SIOCGIWAP;\n\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\tmemcpy(iwe.u.ap_addr.sa_data, network->bssid, ETH_ALEN);\n\tstart = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_ADDR_LEN);\n\t \n\n\t \n\tiwe.cmd = SIOCGIWESSID;\n\tiwe.u.data.flags = 1;\n\n\tif (network->ssid_len == 0) {\n\t\tiwe.u.data.length = sizeof(\"<hidden>\");\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, \"<hidden>\");\n\t} else {\n\t\tiwe.u.data.length = min(network->ssid_len, (u8)32);\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, network->ssid);\n\t}\n\t \n\tiwe.cmd = SIOCGIWNAME;\n\tfor (i = 0; i < ARRAY_SIZE(ieee80211_modes); i++) {\n\t\tif (network->mode & BIT(i)) {\n\t\t\tsprintf(pname, ieee80211_modes[i].mode_string, ieee80211_modes[i].mode_size);\n\t\t\tpname += ieee80211_modes[i].mode_size;\n\t\t}\n\t}\n\t*pname = '\\0';\n\tsnprintf(iwe.u.name, IFNAMSIZ, \"IEEE802.11%s\", proto_name);\n\tstart = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_CHAR_LEN);\n\t \n\tiwe.cmd = SIOCGIWMODE;\n\tif (network->capability &\n\t    (WLAN_CAPABILITY_BSS | WLAN_CAPABILITY_IBSS)) {\n\t\tif (network->capability & WLAN_CAPABILITY_BSS)\n\t\t\tiwe.u.mode = IW_MODE_MASTER;\n\t\telse\n\t\t\tiwe.u.mode = IW_MODE_ADHOC;\n\t\tstart = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_UINT_LEN);\n\t}\n\n\t \n\tiwe.cmd = SIOCGIWFREQ;\n \n\tiwe.u.freq.m = network->channel;\n\tiwe.u.freq.e = 0;\n\tiwe.u.freq.i = 0;\n\tstart = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_FREQ_LEN);\n\t \n\tiwe.cmd = SIOCGIWENCODE;\n\tif (network->capability & WLAN_CAPABILITY_PRIVACY)\n\t\tiwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\n\telse\n\t\tiwe.u.data.flags = IW_ENCODE_DISABLED;\n\tiwe.u.data.length = 0;\n\tstart = iwe_stream_add_point(info, start, stop, &iwe, network->ssid);\n\t \n\tmax_rate = 0;\n\tp = custom;\n\tp += scnprintf(p, MAX_CUSTOM_LEN - (p - custom), \" Rates (Mb/s): \");\n\tfor (i = 0, j = 0; i < network->rates_len; ) {\n\t\tif (j < network->rates_ex_len &&\n\t\t    ((network->rates_ex[j] & 0x7F) <\n\t\t     (network->rates[i] & 0x7F)))\n\t\t\trate = network->rates_ex[j++] & 0x7F;\n\t\telse\n\t\t\trate = network->rates[i++] & 0x7F;\n\t\tif (rate > max_rate)\n\t\t\tmax_rate = rate;\n\t\tp += scnprintf(p, MAX_CUSTOM_LEN - (p - custom),\n\t\t\t      \"%d%s \", rate >> 1, (rate & 1) ? \".5\" : \"\");\n\t}\n\tfor (; j < network->rates_ex_len; j++) {\n\t\trate = network->rates_ex[j] & 0x7F;\n\t\tp += scnprintf(p, MAX_CUSTOM_LEN - (p - custom),\n\t\t\t      \"%d%s \", rate >> 1, (rate & 1) ? \".5\" : \"\");\n\t\tif (rate > max_rate)\n\t\t\tmax_rate = rate;\n\t}\n\n\tif (network->mode >= IEEE_N_24G)   {\n\t\tstruct ht_capability_ele *ht_cap = NULL;\n\t\tbool is40M = false, isShortGI = false;\n\t\tu8 max_mcs = 0;\n\t\tif (!memcmp(network->bssht.bdHTCapBuf, EWC11NHTCap, 4))\n\t\t\tht_cap = (struct ht_capability_ele *)&network->bssht.bdHTCapBuf[4];\n\t\telse\n\t\t\tht_cap = (struct ht_capability_ele *)&network->bssht.bdHTCapBuf[0];\n\t\tis40M = (ht_cap->ChlWidth) ? 1 : 0;\n\t\tisShortGI = (ht_cap->ChlWidth) ?\n\t\t\t\t\t((ht_cap->ShortGI40Mhz) ? 1 : 0) :\n\t\t\t\t\t((ht_cap->ShortGI20Mhz) ? 1 : 0);\n\n\t\tmax_mcs = HTGetHighestMCSRate(ieee, ht_cap->MCS, MCS_FILTER_ALL);\n\t\trate = MCS_DATA_RATE[is40M][isShortGI][max_mcs & 0x7f];\n\t\tif (rate > max_rate)\n\t\t\tmax_rate = rate;\n\t}\n\tiwe.cmd = SIOCGIWRATE;\n\tiwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\n\tiwe.u.bitrate.value = max_rate * 500000;\n\tstart = iwe_stream_add_event_rsl(info, start, stop, &iwe,\n\t\t\t\t     IW_EV_PARAM_LEN);\n\tiwe.cmd = IWEVCUSTOM;\n\tiwe.u.data.length = p - custom;\n\tif (iwe.u.data.length)\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\n\t \n\t \n\tiwe.cmd = IWEVQUAL;\n\tiwe.u.qual.qual = network->stats.signal;\n\tiwe.u.qual.level = network->stats.rssi;\n\tiwe.u.qual.noise = network->stats.noise;\n\tiwe.u.qual.updated = network->stats.mask & IEEE80211_STATMASK_WEMASK;\n\tif (!(network->stats.mask & IEEE80211_STATMASK_RSSI))\n\t\tiwe.u.qual.updated |= IW_QUAL_LEVEL_INVALID;\n\tif (!(network->stats.mask & IEEE80211_STATMASK_NOISE))\n\t\tiwe.u.qual.updated |= IW_QUAL_NOISE_INVALID;\n\tif (!(network->stats.mask & IEEE80211_STATMASK_SIGNAL))\n\t\tiwe.u.qual.updated |= IW_QUAL_QUAL_INVALID;\n\tiwe.u.qual.updated = 7;\n\tstart = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_QUAL_LEN);\n\tiwe.cmd = IWEVCUSTOM;\n\tp = custom;\n\n\tiwe.u.data.length = p - custom;\n\tif (iwe.u.data.length)\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\n\n\tif (ieee->wpa_enabled && network->wpa_ie_len) {\n\t\tchar buf[MAX_WPA_IE_LEN * 2 + 30];\n\t\n\t\tu8 *p = buf;\n\t\tp += sprintf(p, \"wpa_ie=\");\n\t\tfor (i = 0; i < network->wpa_ie_len; i++)\n\t\t\tp += sprintf(p, \"%02x\", network->wpa_ie[i]);\n\n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = IWEVCUSTOM;\n\t\tiwe.u.data.length = strlen(buf);\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, buf);\n\t}\n\n\tif (ieee->wpa_enabled && network->rsn_ie_len) {\n\t\tchar buf[MAX_WPA_IE_LEN * 2 + 30];\n\n\t\tu8 *p = buf;\n\t\tp += sprintf(p, \"rsn_ie=\");\n\t\tfor (i = 0; i < network->rsn_ie_len; i++)\n\t\t\tp += sprintf(p, \"%02x\", network->rsn_ie[i]);\n\n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = IWEVCUSTOM;\n\t\tiwe.u.data.length = strlen(buf);\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, buf);\n\t}\n\n\n\t \n\tiwe.cmd = IWEVCUSTOM;\n\tp = custom;\n\tp += scnprintf(p, MAX_CUSTOM_LEN - (p - custom),\n\t\t      \" Last beacon: %lums ago\", (jiffies - network->last_scanned) / (HZ / 100));\n\tiwe.u.data.length = p - custom;\n\tif (iwe.u.data.length)\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\n\n\treturn start;\n}\n\nint ieee80211_wx_get_scan(struct ieee80211_device *ieee,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct ieee80211_network *network;\n\tunsigned long flags;\n\n\tchar *ev = extra;\n\n\tchar *stop = ev + wrqu->data.length;\n\t\n\tint i = 0;\n\tint err = 0;\n\tIEEE80211_DEBUG_WX(\"Getting scan\\n\");\n\tmutex_lock(&ieee->wx_mutex);\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tlist_for_each_entry(network, &ieee->network_list, list) {\n\t\ti++;\n\t\tif ((stop - ev) < 200) {\n\t\t\terr = -E2BIG;\n\t\t\tbreak;\n\t\t}\n\t\tif (ieee->scan_age == 0 ||\n\t\t    time_after(network->last_scanned + ieee->scan_age, jiffies))\n\t\t\tev = rtl819x_translate_scan(ieee, ev, stop, network, info);\n\t\telse\n\t\t\tIEEE80211_DEBUG_SCAN(\n\t\t\t\t\"Not showing network '%s (\"\n\t\t\t\t\"%pM)' due to age (%lums).\\n\",\n\t\t\t\tescape_essid(network->ssid,\n\t\t\t\t\t     network->ssid_len),\n\t\t\t\tnetwork->bssid,\n\t\t\t\t(jiffies - network->last_scanned) / (HZ / 100));\n\t}\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\tmutex_unlock(&ieee->wx_mutex);\n\twrqu->data.length = ev -  extra;\n\twrqu->data.flags = 0;\n\n\tIEEE80211_DEBUG_WX(\"exit: %d networks returned.\\n\", i);\n\n\treturn err;\n}\nEXPORT_SYMBOL(ieee80211_wx_get_scan);\n\nint ieee80211_wx_set_encode(struct ieee80211_device *ieee,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *keybuf)\n{\n\tstruct iw_point *erq = &(wrqu->encoding);\n\tstruct net_device *dev = ieee->dev;\n\tstruct ieee80211_security sec = {\n\t\t.flags = 0\n\t};\n\tint i, key, key_provided, len;\n\tstruct ieee80211_crypt_data **crypt;\n\n\tIEEE80211_DEBUG_WX(\"SET_ENCODE\\n\");\n\n\tkey = erq->flags & IW_ENCODE_INDEX;\n\tif (key) {\n\t\tif (key > WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tkey--;\n\t\tkey_provided = 1;\n\t} else {\n\t\tkey_provided = 0;\n\t\tkey = ieee->tx_keyidx;\n\t}\n\n\tIEEE80211_DEBUG_WX(\"Key: %d [%s]\\n\", key, key_provided ?\n\t\t\t   \"provided\" : \"default\");\n\tcrypt = &ieee->crypt[key];\n\n\tif (erq->flags & IW_ENCODE_DISABLED) {\n\t\tif (key_provided && *crypt) {\n\t\t\tIEEE80211_DEBUG_WX(\"Disabling encryption on key %d.\\n\",\n\t\t\t\t\t   key);\n\t\t\tieee80211_crypt_delayed_deinit(ieee, crypt);\n\t\t} else\n\t\t\tIEEE80211_DEBUG_WX(\"Disabling encryption.\\n\");\n\n\t\t \n\t\tfor (i = 0; i < WEP_KEYS; i++) {\n\t\t\tif (ieee->crypt[i]) {\n\t\t\t\tif (key_provided)\n\t\t\t\t\tbreak;\n\t\t\t\tieee80211_crypt_delayed_deinit(\n\t\t\t\t\tieee, &ieee->crypt[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (i == WEP_KEYS) {\n\t\t\tsec.enabled = 0;\n\t\t\tsec.level = SEC_LEVEL_0;\n\t\t\tsec.flags |= SEC_ENABLED | SEC_LEVEL;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\n\n\tsec.enabled = 1;\n\tsec.flags |= SEC_ENABLED;\n\n\tif (*crypt && (*crypt)->ops &&\n\t    strcmp((*crypt)->ops->name, \"WEP\") != 0) {\n\t\t \n\t\tieee80211_crypt_delayed_deinit(ieee, crypt);\n\t}\n\n\tif (!*crypt) {\n\t\tstruct ieee80211_crypt_data *new_crypt;\n\n\t\t \n\t\tnew_crypt = kzalloc(sizeof(struct ieee80211_crypt_data),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!new_crypt)\n\t\t\treturn -ENOMEM;\n\t\tnew_crypt->ops = try_then_request_module(ieee80211_get_crypto_ops(\"WEP\"),\n\t\t\t\t\t\t\t \"ieee80211_crypt_wep\");\n\t\tif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\n\t\t\tnew_crypt->priv = new_crypt->ops->init(key);\n\n\t\tif (!new_crypt->ops || !new_crypt->priv) {\n\t\t\tkfree(new_crypt);\n\t\t\tnew_crypt = NULL;\n\n\t\t\tnetdev_warn(dev, \"could not initialize WEP: \"\n\t\t\t\t    \"load module ieee80211_crypt_wep\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t*crypt = new_crypt;\n\t}\n\n\t \n\tif (erq->length > 0) {\n\t\tlen = erq->length <= 5 ? 5 : 13;\n\t\tmemcpy(sec.keys[key], keybuf, erq->length);\n\t\tif (len > erq->length)\n\t\t\tmemset(sec.keys[key] + erq->length, 0,\n\t\t\t       len - erq->length);\n\t\tIEEE80211_DEBUG_WX(\"Setting key %d to '%s' (%d:%d bytes)\\n\",\n\t\t\t\t   key, escape_essid(sec.keys[key], len),\n\t\t\t\t   erq->length, len);\n\t\tsec.key_sizes[key] = len;\n\t\t(*crypt)->ops->set_key(sec.keys[key], len, NULL,\n\t\t\t\t       (*crypt)->priv);\n\t\tsec.flags |= BIT(key);\n\t\t \n\t\tif (key == sec.active_key)\n\t\t\tsec.flags |= SEC_ACTIVE_KEY;\n\t\tieee->tx_keyidx = key;\n\n\t} else {\n\t\tlen = (*crypt)->ops->get_key(sec.keys[key], WEP_KEY_LEN,\n\t\t\t\t\t     NULL, (*crypt)->priv);\n\t\tif (len == 0) {\n\t\t\t \n\t\t\tprintk(\"Setting key %d to all zero.\\n\",\n\t\t\t\t\t   key);\n\n\t\t\tIEEE80211_DEBUG_WX(\"Setting key %d to all zero.\\n\",\n\t\t\t\t\t   key);\n\t\t\tmemset(sec.keys[key], 0, 13);\n\t\t\t(*crypt)->ops->set_key(sec.keys[key], 13, NULL,\n\t\t\t\t\t       (*crypt)->priv);\n\t\t\tsec.key_sizes[key] = 13;\n\t\t\tsec.flags |= BIT(key);\n\t\t}\n\n\t\t \n\t\tif (key_provided) {\n\t\t\tIEEE80211_DEBUG_WX(\n\t\t\t\t\"Setting key %d to default Tx key.\\n\", key);\n\t\t\tieee->tx_keyidx = key;\n\t\t\tsec.active_key = key;\n\t\t\tsec.flags |= SEC_ACTIVE_KEY;\n\t\t}\n\t}\n\n done:\n\tieee->open_wep = !(erq->flags & IW_ENCODE_RESTRICTED);\n\tieee->auth_mode = ieee->open_wep ? WLAN_AUTH_OPEN : WLAN_AUTH_SHARED_KEY;\n\tsec.auth_mode = ieee->open_wep ? WLAN_AUTH_OPEN : WLAN_AUTH_SHARED_KEY;\n\tsec.flags |= SEC_AUTH_MODE;\n\tIEEE80211_DEBUG_WX(\"Auth: %s\\n\", sec.auth_mode == WLAN_AUTH_OPEN ?\n\t\t\t   \"OPEN\" : \"SHARED KEY\");\n\n\t \n\tsec.flags |= SEC_LEVEL;\n\tsec.level = SEC_LEVEL_1;  \n\n\tif (ieee->set_security)\n\t\tieee->set_security(dev, &sec);\n\n\t \n\tif (ieee->reset_on_keychange &&\n\t    ieee->iw_mode != IW_MODE_INFRA &&\n\t    ieee->reset_port && ieee->reset_port(dev)) {\n\t\tnetdev_dbg(ieee->dev, \"reset_port failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_set_encode);\n\nint ieee80211_wx_get_encode(struct ieee80211_device *ieee,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *keybuf)\n{\n\tstruct iw_point *erq = &(wrqu->encoding);\n\tint len, key;\n\tstruct ieee80211_crypt_data *crypt;\n\n\tIEEE80211_DEBUG_WX(\"GET_ENCODE\\n\");\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR)\n\t\treturn -1;\n\n\tkey = erq->flags & IW_ENCODE_INDEX;\n\tif (key) {\n\t\tif (key > WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tkey--;\n\t} else\n\t\tkey = ieee->tx_keyidx;\n\n\tcrypt = ieee->crypt[key];\n\terq->flags = key + 1;\n\n\tif (!crypt || !crypt->ops) {\n\t\terq->length = 0;\n\t\terq->flags |= IW_ENCODE_DISABLED;\n\t\treturn 0;\n\t}\n\tlen = crypt->ops->get_key(keybuf, SCM_KEY_LEN, NULL, crypt->priv);\n\tif (len < 0)\n\t\tlen = 0;\n\terq->length = len;\n\n\terq->flags |= IW_ENCODE_ENABLED;\n\n\tif (ieee->open_wep)\n\t\terq->flags |= IW_ENCODE_OPEN;\n\telse\n\t\terq->flags |= IW_ENCODE_RESTRICTED;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_get_encode);\n\nint ieee80211_wx_set_encode_ext(struct ieee80211_device *ieee,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tint ret = 0;\n\tstruct net_device *dev = ieee->dev;\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint i, idx;\n\tint group_key = 0;\n\tconst char *alg, *module;\n\tstruct ieee80211_crypto_ops *ops;\n\tstruct ieee80211_crypt_data **crypt;\n\n\tstruct ieee80211_security sec = {\n\t\t.flags = 0,\n\t};\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif (idx < 1 || idx > WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tidx--;\n\t} else\n\t\tidx = ieee->tx_keyidx;\n\n\tif (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {\n\n\t\tcrypt = &ieee->crypt[idx];\n\n\t\tgroup_key = 1;\n\t} else {\n\t\t \n\t\tif (idx != 0 && ext->alg != IW_ENCODE_ALG_WEP)\n\t\t\treturn -EINVAL;\n\t\tif (ieee->iw_mode == IW_MODE_INFRA)\n\n\t\t\tcrypt = &ieee->crypt[idx];\n\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tsec.flags |= SEC_ENABLED;\n\tif ((encoding->flags & IW_ENCODE_DISABLED) ||\n\t    ext->alg == IW_ENCODE_ALG_NONE) {\n\t\tif (*crypt)\n\t\t\tieee80211_crypt_delayed_deinit(ieee, crypt);\n\n\t\tfor (i = 0; i < WEP_KEYS; i++)\n\n\t\t\tif (ieee->crypt[i])\n\n\t\t\t\tbreak;\n\n\t\tif (i == WEP_KEYS) {\n\t\t\tsec.enabled = 0;\n\t\t      \n\t\t\tsec.level = SEC_LEVEL_0;\n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t}\n\t\tgoto done;\n\t}\n\n\tsec.enabled = 1;\n    \n\tswitch (ext->alg) {\n\tcase IW_ENCODE_ALG_WEP:\n\t\talg = \"WEP\";\n\t\tmodule = \"ieee80211_crypt_wep\";\n\t\tbreak;\n\tcase IW_ENCODE_ALG_TKIP:\n\t\talg = \"TKIP\";\n\t\tmodule = \"ieee80211_crypt_tkip\";\n\t\tbreak;\n\tcase IW_ENCODE_ALG_CCMP:\n\t\talg = \"CCMP\";\n\t\tmodule = \"ieee80211_crypt_ccmp\";\n\t\tbreak;\n\tdefault:\n\t\tIEEE80211_DEBUG_WX(\"%s: unknown crypto alg %d\\n\",\n\t\t\t\t   dev->name, ext->alg);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tprintk(\"alg name:%s\\n\", alg);\n\n\tops = try_then_request_module(ieee80211_get_crypto_ops(alg), module);\n\tif (!ops) {\n\t\tIEEE80211_DEBUG_WX(\"%s: unknown crypto alg %d\\n\",\n\t\t\t\t   dev->name, ext->alg);\n\t\tprintk(\"========>unknown crypto alg %d\\n\", ext->alg);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (!*crypt || (*crypt)->ops != ops) {\n\t\tstruct ieee80211_crypt_data *new_crypt;\n\n\t\tieee80211_crypt_delayed_deinit(ieee, crypt);\n\n\t\tnew_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);\n\t\tif (!new_crypt) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tnew_crypt->ops = ops;\n\t\tif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\n\t\t\tnew_crypt->priv = new_crypt->ops->init(idx);\n\t\tif (!new_crypt->priv) {\n\t\t\tkfree(new_crypt);\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\t*crypt = new_crypt;\n\t}\n\n\tif (ext->key_len > 0 && (*crypt)->ops->set_key &&\n\t    (*crypt)->ops->set_key(ext->key, ext->key_len, ext->rx_seq,\n\t\t\t\t   (*crypt)->priv) < 0) {\n\t\tIEEE80211_DEBUG_WX(\"%s: key setting failed\\n\", dev->name);\n\t\tprintk(\"key setting failed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n \n\tif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\n\t\tieee->tx_keyidx = idx;\n\t\tsec.active_key = idx;\n\t\tsec.flags |= SEC_ACTIVE_KEY;\n\t}\n\n\tif (ext->alg != IW_ENCODE_ALG_NONE) {\n\t\t\n\t\tsec.key_sizes[idx] = ext->key_len;\n\t\tsec.flags |= BIT(idx);\n\t\tif (ext->alg == IW_ENCODE_ALG_WEP) {\n\t\t      \n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\tsec.level = SEC_LEVEL_1;\n\t\t} else if (ext->alg == IW_ENCODE_ALG_TKIP) {\n\t\t      \n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\tsec.level = SEC_LEVEL_2;\n\t\t} else if (ext->alg == IW_ENCODE_ALG_CCMP) {\n\t\t       \n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\tsec.level = SEC_LEVEL_3;\n\t\t}\n\t\t \n\t\tif (group_key)\n\t\t\tsec.flags &= ~SEC_LEVEL;\n\t}\ndone:\n\tif (ieee->set_security)\n\t\tieee->set_security(ieee->dev, &sec);\n\n\tif (ieee->reset_on_keychange &&\n\t    ieee->iw_mode != IW_MODE_INFRA &&\n\t    ieee->reset_port && ieee->reset_port(dev)) {\n\t\tIEEE80211_DEBUG_WX(\"%s: reset_port failed\\n\", dev->name);\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_wx_set_encode_ext);\n\nint ieee80211_wx_get_encode_ext(struct ieee80211_device *ieee,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tstruct ieee80211_crypt_data *crypt;\n\tint idx, max_key_len;\n\n\tmax_key_len = encoding->length - sizeof(*ext);\n\tif (max_key_len < 0)\n\t\treturn -EINVAL;\n\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif (idx < 1 || idx > WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tidx--;\n\t} else\n\t\tidx = ieee->tx_keyidx;\n\n\tif (!(ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) &&\n\t    ext->alg != IW_ENCODE_ALG_WEP)\n\t\tif (idx != 0 || ieee->iw_mode != IW_MODE_INFRA)\n\t\t\treturn -EINVAL;\n\n\tcrypt = ieee->crypt[idx];\n\tencoding->flags = idx + 1;\n\tmemset(ext, 0, sizeof(*ext));\n\n\tif (!crypt || !crypt->ops) {\n\t\text->alg = IW_ENCODE_ALG_NONE;\n\t\text->key_len = 0;\n\t\tencoding->flags |= IW_ENCODE_DISABLED;\n\t} else {\n\t\tif (strcmp(crypt->ops->name, \"WEP\") == 0)\n\t\t\text->alg = IW_ENCODE_ALG_WEP;\n\t\telse if (strcmp(crypt->ops->name, \"TKIP\") == 0)\n\t\t\text->alg = IW_ENCODE_ALG_TKIP;\n\t\telse if (strcmp(crypt->ops->name, \"CCMP\") == 0)\n\t\t\text->alg = IW_ENCODE_ALG_CCMP;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\text->key_len = crypt->ops->get_key(ext->key, SCM_KEY_LEN, NULL, crypt->priv);\n\t\tencoding->flags |= IW_ENCODE_ENABLED;\n\t\tif (ext->key_len &&\n\t\t    (ext->alg == IW_ENCODE_ALG_TKIP ||\n\t\t     ext->alg == IW_ENCODE_ALG_CCMP))\n\t\t\text->ext_flags |= IW_ENCODE_EXT_TX_SEQ_VALID;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_get_encode_ext);\n\nint ieee80211_wx_set_mlme(struct ieee80211_device *ieee,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_mlme *mlme = (struct iw_mlme *)extra;\n\tswitch (mlme->cmd) {\n\tcase IW_MLME_DEAUTH:\n\tcase IW_MLME_DISASSOC:\n\t\tieee80211_disassociate(ieee);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_set_mlme);\n\nint ieee80211_wx_set_auth(struct ieee80211_device *ieee,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_param *data, char *extra)\n{\n\tswitch (data->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\t      \n\t\tbreak;\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\t\t \n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tieee->tkip_countermeasures = data->value;\n\t\tbreak;\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tieee->drop_unencrypted = data->value;\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\t\n\t\n\t\tif (data->value & IW_AUTH_ALG_SHARED_KEY) {\n\t\t\tieee->open_wep = 0;\n\t\t\tieee->auth_mode = 1;\n\t\t} else if (data->value & IW_AUTH_ALG_OPEN_SYSTEM) {\n\t\t\tieee->open_wep = 1;\n\t\t\tieee->auth_mode = 0;\n\t\t} else if (data->value & IW_AUTH_ALG_LEAP) {\n\t\t\tieee->open_wep = 1;\n\t\t\tieee->auth_mode = 2;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tieee->wpa_enabled = (data->value) ? 1 : 0;\n\t\tbreak;\n\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\t\tieee->ieee802_1x = data->value;\n\t\tbreak;\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\tieee->privacy_invoked = data->value;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_set_auth);\n\nint ieee80211_wx_set_gen_ie(struct ieee80211_device *ieee, u8 *ie, size_t len)\n{\n\tu8 *buf;\n\n\tif (len > MAX_WPA_IE_LEN || (len && !ie)) {\n\t\t\n\t\treturn -EINVAL;\n\t}\n\n\n\tif (len) {\n\t\tif (len != ie[1] + 2) {\n\t\t\tprintk(\"len:%zu, ie:%d\\n\", len, ie[1]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbuf = kmemdup(ie, len, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = buf;\n\t\tieee->wpa_ie_len = len;\n\t} else {\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = NULL;\n\t\tieee->wpa_ie_len = 0;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_set_gen_ie);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}