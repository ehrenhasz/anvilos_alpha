{
  "module_name": "ieee80211_crypt_wep.c",
  "hash_id": "bca68e4ebf6d8afe32a0e16259c9f1e398d4a28a86e1fe74d12e6a7b81726a97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_wep.c",
  "human_readable_source": "\n \n\n#include <linux/fips.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/skbuff.h>\n#include <linux/string.h>\n\n#include \"ieee80211.h\"\n\n#include <crypto/arc4.h>\n#include <linux/crc32.h>\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"Host AP crypt: WEP\");\nMODULE_LICENSE(\"GPL\");\n\nstruct prism2_wep_data {\n\tu32 iv;\n#define WEP_KEY_LEN 13\n\tu8 key[WEP_KEY_LEN + 1];\n\tu8 key_len;\n\tu8 key_idx;\n\tstruct arc4_ctx rx_ctx_arc4;\n\tstruct arc4_ctx tx_ctx_arc4;\n};\n\n\nstatic void *prism2_wep_init(int keyidx)\n{\n\tstruct prism2_wep_data *priv;\n\n\tif (fips_enabled)\n\t\treturn NULL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn NULL;\n\tpriv->key_idx = keyidx;\n\n\t \n\tget_random_bytes(&priv->iv, 4);\n\n\treturn priv;\n}\n\n\nstatic void prism2_wep_deinit(void *priv)\n{\n\tkfree_sensitive(priv);\n}\n\n \nstatic int prism2_wep_encrypt(struct sk_buff *skb, int hdr_len, void *priv)\n{\n\tstruct prism2_wep_data *wep = priv;\n\tu32 klen, len;\n\tu8 key[WEP_KEY_LEN + 3];\n\tu8 *pos;\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\tu32 crc;\n\tu8 *icv;\n\n\tif (skb_headroom(skb) < 4 || skb_tailroom(skb) < 4 ||\n\t    skb->len < hdr_len)\n\t\treturn -1;\n\n\tlen = skb->len - hdr_len;\n\tpos = skb_push(skb, 4);\n\tmemmove(pos, pos + 4, hdr_len);\n\tpos += hdr_len;\n\n\tklen = 3 + wep->key_len;\n\n\twep->iv++;\n\n\t \n\tif ((wep->iv & 0xff00) == 0xff00) {\n\t\tu8 B = (wep->iv >> 16) & 0xff;\n\n\t\tif (B >= 3 && B < klen)\n\t\t\twep->iv += 0x0100;\n\t}\n\n\t \n\t*pos++ = key[0] = (wep->iv >> 16) & 0xff;\n\t*pos++ = key[1] = (wep->iv >> 8) & 0xff;\n\t*pos++ = key[2] = wep->iv & 0xff;\n\t*pos++ = wep->key_idx << 6;\n\n\t \n\tmemcpy(key + 3, wep->key, wep->key_len);\n\n\tif (!tcb_desc->bHwSec) {\n\t\t \n\t\tcrc = ~crc32_le(~0, pos, len);\n\t\ticv = skb_put(skb, 4);\n\t\ticv[0] = crc;\n\t\ticv[1] = crc >> 8;\n\t\ticv[2] = crc >> 16;\n\t\ticv[3] = crc >> 24;\n\n\t\tarc4_setkey(&wep->tx_ctx_arc4, key, klen);\n\t\tarc4_crypt(&wep->tx_ctx_arc4, pos, pos, len + 4);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int prism2_wep_decrypt(struct sk_buff *skb, int hdr_len, void *priv)\n{\n\tstruct prism2_wep_data *wep = priv;\n\tu32  klen, plen;\n\tu8 key[WEP_KEY_LEN + 3];\n\tu8 keyidx, *pos;\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\tu32 crc;\n\tu8 icv[4];\n\n\tif (skb->len < hdr_len + 8)\n\t\treturn -1;\n\n\tpos = skb->data + hdr_len;\n\tkey[0] = *pos++;\n\tkey[1] = *pos++;\n\tkey[2] = *pos++;\n\tkeyidx = *pos++ >> 6;\n\tif (keyidx != wep->key_idx)\n\t\treturn -1;\n\n\tklen = 3 + wep->key_len;\n\n\t \n\tmemcpy(key + 3, wep->key, wep->key_len);\n\n\t \n\tplen = skb->len - hdr_len - 8;\n\n\tif (!tcb_desc->bHwSec) {\n\t\tarc4_setkey(&wep->rx_ctx_arc4, key, klen);\n\t\tarc4_crypt(&wep->rx_ctx_arc4, pos, pos, plen + 4);\n\n\t\tcrc = ~crc32_le(~0, pos, plen);\n\t\ticv[0] = crc;\n\t\ticv[1] = crc >> 8;\n\t\ticv[2] = crc >> 16;\n\t\ticv[3] = crc >> 24;\n\t\tif (memcmp(icv, pos + plen, 4) != 0) {\n\t\t\t \n\t\t\treturn -2;\n\t\t}\n\t}\n\t \n\tmemmove(skb->data + 4, skb->data, hdr_len);\n\tskb_pull(skb, 4);\n\tskb_trim(skb, skb->len - 4);\n\n\treturn 0;\n}\n\n\nstatic int prism2_wep_set_key(void *key, int len, u8 *seq, void *priv)\n{\n\tstruct prism2_wep_data *wep = priv;\n\n\tif (len < 0 || len > WEP_KEY_LEN)\n\t\treturn -1;\n\n\tmemcpy(wep->key, key, len);\n\twep->key_len = len;\n\n\treturn 0;\n}\n\n\nstatic int prism2_wep_get_key(void *key, int len, u8 *seq, void *priv)\n{\n\tstruct prism2_wep_data *wep = priv;\n\n\tif (len < wep->key_len)\n\t\treturn 0;\n\n\tmemcpy(key, wep->key, wep->key_len);\n\n\treturn wep->key_len;\n}\n\n\nstatic char *prism2_wep_print_stats(char *p, void *priv)\n{\n\tstruct prism2_wep_data *wep = priv;\n\n\tp += sprintf(p, \"key[%d] alg=WEP len=%d\\n\",\n\t\t     wep->key_idx, wep->key_len);\n\treturn p;\n}\n\n\nstatic struct ieee80211_crypto_ops ieee80211_crypt_wep = {\n\t.name\t\t\t= \"WEP\",\n\t.init\t\t\t= prism2_wep_init,\n\t.deinit\t\t\t= prism2_wep_deinit,\n\t.encrypt_mpdu\t\t= prism2_wep_encrypt,\n\t.decrypt_mpdu\t\t= prism2_wep_decrypt,\n\t.encrypt_msdu\t\t= NULL,\n\t.decrypt_msdu\t\t= NULL,\n\t.set_key\t\t= prism2_wep_set_key,\n\t.get_key\t\t= prism2_wep_get_key,\n\t.print_stats\t\t= prism2_wep_print_stats,\n\t.extra_prefix_len\t= 4,  \n\t.extra_postfix_len\t= 4,  \n\t.owner\t\t\t= THIS_MODULE,\n};\n\nint __init ieee80211_crypto_wep_init(void)\n{\n\treturn ieee80211_register_crypto_ops(&ieee80211_crypt_wep);\n}\n\nvoid ieee80211_crypto_wep_exit(void)\n{\n\tieee80211_unregister_crypto_ops(&ieee80211_crypt_wep);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}