{
  "module_name": "ieee80211_softmac_wx.c",
  "hash_id": "56932ad6e664f2f25ac278de34024b84deb7d2d45b3a59b0a8ad258e61d6f622",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac_wx.c",
  "human_readable_source": "\n \n\n\n#include <linux/etherdevice.h>\n\n#include \"ieee80211.h\"\n#include \"dot11d.h\"\n \n\nconst long ieee80211_wlan_frequencies[] = {\n\t2412, 2417, 2422, 2427,\n\t2432, 2437, 2442, 2447,\n\t2452, 2457, 2462, 2467,\n\t2472, 2484\n};\nEXPORT_SYMBOL(ieee80211_wlan_frequencies);\n\nint ieee80211_wx_set_freq(struct ieee80211_device *ieee, struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tint ret;\n\tstruct iw_freq *fwrq = &wrqu->freq;\n\n\tmutex_lock(&ieee->wx_mutex);\n\n\tif (ieee->iw_mode == IW_MODE_INFRA) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (fwrq->e == 1) {\n\t\tif ((fwrq->m >= (int)2.412e8 &&\n\t\t     fwrq->m <= (int)2.487e8)) {\n\t\t\tint f = fwrq->m / 100000;\n\t\t\tint c = 0;\n\n\t\t\twhile ((c < 14) && (f != ieee80211_wlan_frequencies[c]))\n\t\t\t\tc++;\n\n\t\t\t \n\t\t\tfwrq->e = 0;\n\t\t\tfwrq->m = c + 1;\n\t\t}\n\t}\n\n\tif (fwrq->e > 0 || fwrq->m > 14 || fwrq->m < 1) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\n\t} else {  \n\n\t\tif (!(GET_DOT11D_INFO(ieee)->channel_map)[fwrq->m]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tieee->current_network.channel = fwrq->m;\n\t\tieee->set_chan(ieee->dev, ieee->current_network.channel);\n\n\t\tif (ieee->iw_mode == IW_MODE_ADHOC || ieee->iw_mode == IW_MODE_MASTER)\n\t\t\tif (ieee->state == IEEE80211_LINKED) {\n\t\t\t\tieee80211_stop_send_beacons(ieee);\n\t\t\t\tieee80211_start_send_beacons(ieee);\n\t\t\t}\n\t}\n\n\tret = 0;\nout:\n\tmutex_unlock(&ieee->wx_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_wx_set_freq);\n\nint ieee80211_wx_get_freq(struct ieee80211_device *ieee,\n\t\t\t     struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tstruct iw_freq *fwrq = &wrqu->freq;\n\n\tif (ieee->current_network.channel == 0)\n\t\treturn -1;\n\t \n\tfwrq->m = ieee80211_wlan_frequencies[ieee->current_network.channel - 1] * 100000;\n\tfwrq->e = 1;\n\t \n\t \n\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_get_freq);\n\nint ieee80211_wx_get_wap(struct ieee80211_device *ieee,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tunsigned long flags;\n\n\twrqu->ap_addr.sa_family = ARPHRD_ETHER;\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR)\n\t\treturn -1;\n\n\t \n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif (ieee->state != IEEE80211_LINKED &&\n\t\tieee->state != IEEE80211_LINKED_SCANNING &&\n\t\tieee->wap_set == 0)\n\n\t\teth_zero_addr(wrqu->ap_addr.sa_data);\n\telse\n\t\tmemcpy(wrqu->ap_addr.sa_data,\n\t\t       ieee->current_network.bssid, ETH_ALEN);\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_get_wap);\n\nint ieee80211_wx_set_wap(struct ieee80211_device *ieee,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *awrq,\n\t\t\t char *extra)\n{\n\n\tint ret = 0;\n\tunsigned long flags;\n\n\tshort ifup = ieee->proto_started;  \n\tstruct sockaddr *temp = (struct sockaddr *)awrq;\n\n\tieee->sync_scan_hurryup = 1;\n\n\tmutex_lock(&ieee->wx_mutex);\n\t \n\tif (ieee->iw_mode == IW_MODE_MASTER) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (temp->sa_family != ARPHRD_ETHER) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ifup)\n\t\tieee80211_stop_protocol(ieee);\n\n\t \n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tmemcpy(ieee->current_network.bssid, temp->sa_data, ETH_ALEN);\n\tieee->wap_set = !is_zero_ether_addr(temp->sa_data);\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\n\tif (ifup)\n\t\tieee80211_start_protocol(ieee);\nout:\n\tmutex_unlock(&ieee->wx_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_wx_set_wap);\n\nint ieee80211_wx_get_essid(struct ieee80211_device *ieee, struct iw_request_info *a, union iwreq_data *wrqu, char *b)\n{\n\tint len, ret = 0;\n\tunsigned long flags;\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR)\n\t\treturn -1;\n\n\t \n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif (ieee->current_network.ssid[0] == '\\0' ||\n\t\tieee->current_network.ssid_len == 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (ieee->state != IEEE80211_LINKED &&\n\t\tieee->state != IEEE80211_LINKED_SCANNING &&\n\t\tieee->ssid_set == 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tlen = ieee->current_network.ssid_len;\n\twrqu->essid.length = len;\n\tstrncpy(b, ieee->current_network.ssid, len);\n\twrqu->essid.flags = 1;\n\nout:\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\n\treturn ret;\n\n}\nEXPORT_SYMBOL(ieee80211_wx_get_essid);\n\nint ieee80211_wx_set_rate(struct ieee80211_device *ieee,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\n\tu32 target_rate = wrqu->bitrate.value;\n\n\tieee->rate = target_rate / 100000;\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_set_rate);\n\nint ieee80211_wx_get_rate(struct ieee80211_device *ieee,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tu32 tmp_rate;\n\n\ttmp_rate = TxCountToDataRate(ieee, ieee->softmac_stats.CurrentShowTxate);\n\n\twrqu->bitrate.value = tmp_rate * 500000;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_get_rate);\n\nint ieee80211_wx_set_rts(struct ieee80211_device *ieee,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tif (wrqu->rts.disabled || !wrqu->rts.fixed) {\n\t\tieee->rts = DEFAULT_RTS_THRESHOLD;\n\t} else {\n\t\tif (wrqu->rts.value < MIN_RTS_THRESHOLD ||\n\t\t\t\twrqu->rts.value > MAX_RTS_THRESHOLD)\n\t\t\treturn -EINVAL;\n\t\tieee->rts = wrqu->rts.value;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_set_rts);\n\nint ieee80211_wx_get_rts(struct ieee80211_device *ieee,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\twrqu->rts.value = ieee->rts;\n\twrqu->rts.fixed = 0;\t \n\twrqu->rts.disabled = (wrqu->rts.value == DEFAULT_RTS_THRESHOLD);\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_get_rts);\n\nint ieee80211_wx_set_mode(struct ieee80211_device *ieee, struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\n\tieee->sync_scan_hurryup = 1;\n\n\tmutex_lock(&ieee->wx_mutex);\n\n\tif (wrqu->mode == ieee->iw_mode)\n\t\tgoto out;\n\n\tif (wrqu->mode == IW_MODE_MONITOR)\n\t\tieee->dev->type = ARPHRD_IEEE80211;\n\telse\n\t\tieee->dev->type = ARPHRD_ETHER;\n\n\tif (!ieee->proto_started) {\n\t\tieee->iw_mode = wrqu->mode;\n\t} else {\n\t\tieee80211_stop_protocol(ieee);\n\t\tieee->iw_mode = wrqu->mode;\n\t\tieee80211_start_protocol(ieee);\n\t}\n\nout:\n\tmutex_unlock(&ieee->wx_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_set_mode);\n\nvoid ieee80211_wx_sync_scan_wq(struct work_struct *work)\n{\n\tstruct ieee80211_device *ieee = container_of(work, struct ieee80211_device, wx_sync_scan_wq);\n\tshort chan;\n\tenum ht_extension_chan_offset chan_offset = 0;\n\tenum ht_channel_width bandwidth = 0;\n\tint b40M = 0;\n\n\tchan = ieee->current_network.channel;\n\tnetif_carrier_off(ieee->dev);\n\n\tif (ieee->data_hard_stop)\n\t\tieee->data_hard_stop(ieee->dev);\n\n\tieee80211_stop_send_beacons(ieee);\n\n\tieee->state = IEEE80211_LINKED_SCANNING;\n\tieee->link_change(ieee->dev);\n\tieee->InitialGainHandler(ieee->dev, IG_Backup);\n\tif (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT && ieee->pHTInfo->bCurBW40MHz) {\n\t\tb40M = 1;\n\t\tchan_offset = ieee->pHTInfo->CurSTAExtChnlOffset;\n\t\tbandwidth = (enum ht_channel_width)ieee->pHTInfo->bCurBW40MHz;\n\t\tprintk(\"Scan in 40M, force to 20M first:%d, %d\\n\", chan_offset, bandwidth);\n\t\tieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);\n\t\t}\n\tieee80211_start_scan_syncro(ieee);\n\tif (b40M) {\n\t\tprintk(\"Scan in 20M, back to 40M\\n\");\n\t\tif (chan_offset == HT_EXTCHNL_OFFSET_UPPER)\n\t\t\tieee->set_chan(ieee->dev, chan + 2);\n\t\telse if (chan_offset == HT_EXTCHNL_OFFSET_LOWER)\n\t\t\tieee->set_chan(ieee->dev, chan - 2);\n\t\telse\n\t\t\tieee->set_chan(ieee->dev, chan);\n\t\tieee->SetBWModeHandler(ieee->dev, bandwidth, chan_offset);\n\t} else {\n\t\tieee->set_chan(ieee->dev, chan);\n\t}\n\n\tieee->InitialGainHandler(ieee->dev, IG_Restore);\n\tieee->state = IEEE80211_LINKED;\n\tieee->link_change(ieee->dev);\n\t \n\tif (ieee->LinkDetectInfo.NumRecvBcnInPeriod == 0 || ieee->LinkDetectInfo.NumRecvDataInPeriod == 0) {\n\t\tieee->LinkDetectInfo.NumRecvBcnInPeriod = 1;\n\t\tieee->LinkDetectInfo.NumRecvDataInPeriod = 1;\n\t}\n\tif (ieee->data_hard_resume)\n\t\tieee->data_hard_resume(ieee->dev);\n\n\tif (ieee->iw_mode == IW_MODE_ADHOC || ieee->iw_mode == IW_MODE_MASTER)\n\t\tieee80211_start_send_beacons(ieee);\n\n\tnetif_carrier_on(ieee->dev);\n\tmutex_unlock(&ieee->wx_mutex);\n\n}\n\nint ieee80211_wx_set_scan(struct ieee80211_device *ieee, struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ieee->wx_mutex);\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR || !(ieee->proto_started)) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (ieee->state == IEEE80211_LINKED) {\n\t\tqueue_work(ieee->wq, &ieee->wx_sync_scan_wq);\n\t\t \n\t\treturn 0;\n\t}\n\nout:\n\tmutex_unlock(&ieee->wx_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_wx_set_scan);\n\nint ieee80211_wx_set_essid(struct ieee80211_device *ieee,\n\t\t\t      struct iw_request_info *a,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\n\tint ret = 0, len;\n\tshort proto_started;\n\tunsigned long flags;\n\n\tieee->sync_scan_hurryup = 1;\n\tmutex_lock(&ieee->wx_mutex);\n\n\tproto_started = ieee->proto_started;\n\n\tif (wrqu->essid.length > IW_ESSID_MAX_SIZE) {\n\t\tret = -E2BIG;\n\t\tgoto out;\n\t}\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (proto_started)\n\t\tieee80211_stop_protocol(ieee);\n\n\n\t \n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif (wrqu->essid.flags && wrqu->essid.length) {\n\t\t \n\t\tlen = ((wrqu->essid.length - 1) < IW_ESSID_MAX_SIZE) ? (wrqu->essid.length - 1) : IW_ESSID_MAX_SIZE;\n\t\tstrncpy(ieee->current_network.ssid, extra, len + 1);\n\t\tieee->current_network.ssid_len = len + 1;\n\t\tieee->ssid_set = 1;\n\t} else {\n\t\tieee->ssid_set = 0;\n\t\tieee->current_network.ssid[0] = '\\0';\n\t\tieee->current_network.ssid_len = 0;\n\t}\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\n\tif (proto_started)\n\t\tieee80211_start_protocol(ieee);\nout:\n\tmutex_unlock(&ieee->wx_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_wx_set_essid);\n\nint ieee80211_wx_get_mode(struct ieee80211_device *ieee, struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\n\twrqu->mode = ieee->iw_mode;\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_get_mode);\n\nint ieee80211_wx_set_rawtx(struct ieee80211_device *ieee,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\n\tint *parms = (int *)extra;\n\tint enable = (parms[0] > 0);\n\tshort prev = ieee->raw_tx;\n\n\tmutex_lock(&ieee->wx_mutex);\n\n\tif (enable)\n\t\tieee->raw_tx = 1;\n\telse\n\t\tieee->raw_tx = 0;\n\n\tnetdev_info(ieee->dev, \"raw TX is %s\\n\",\n\t\t    ieee->raw_tx ? \"enabled\" : \"disabled\");\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tif (prev == 0 && ieee->raw_tx) {\n\t\t\tif (ieee->data_hard_resume)\n\t\t\t\tieee->data_hard_resume(ieee->dev);\n\n\t\t\tnetif_carrier_on(ieee->dev);\n\t\t}\n\n\t\tif (prev && ieee->raw_tx == 1)\n\t\t\tnetif_carrier_off(ieee->dev);\n\t}\n\n\tmutex_unlock(&ieee->wx_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_set_rawtx);\n\nint ieee80211_wx_get_name(struct ieee80211_device *ieee,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstrscpy(wrqu->name, \"802.11\", IFNAMSIZ);\n\tif (ieee->modulation & IEEE80211_CCK_MODULATION) {\n\t\tstrlcat(wrqu->name, \"b\", IFNAMSIZ);\n\t\tif (ieee->modulation & IEEE80211_OFDM_MODULATION)\n\t\t\tstrlcat(wrqu->name, \"/g\", IFNAMSIZ);\n\t} else if (ieee->modulation & IEEE80211_OFDM_MODULATION) {\n\t\tstrlcat(wrqu->name, \"g\", IFNAMSIZ);\n\t}\n\n\tif (ieee->mode & (IEEE_N_24G | IEEE_N_5G))\n\t\tstrlcat(wrqu->name, \"/n\", IFNAMSIZ);\n\n\tif ((ieee->state == IEEE80211_LINKED) ||\n\t    (ieee->state == IEEE80211_LINKED_SCANNING))\n\t\tstrlcat(wrqu->name, \" linked\", IFNAMSIZ);\n\telse if (ieee->state != IEEE80211_NOLINK)\n\t\tstrlcat(wrqu->name, \" link..\", IFNAMSIZ);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_wx_get_name);\n\n \nint ieee80211_wx_set_power(struct ieee80211_device *ieee,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ieee->wx_mutex);\n\n\tif (wrqu->power.disabled) {\n\t\tieee->ps = IEEE80211_PS_DISABLED;\n\t\tgoto exit;\n\t}\n\tif (wrqu->power.flags & IW_POWER_TIMEOUT) {\n\t\t \n\t\tieee->ps_timeout = wrqu->power.value / 1000;\n\t}\n\n\tif (wrqu->power.flags & IW_POWER_PERIOD) {\n\n\t\t \n\t\tieee->ps_period = wrqu->power.value / 1000;\n\t\t \n\n\t}\n\tswitch (wrqu->power.flags & IW_POWER_MODE) {\n\tcase IW_POWER_UNICAST_R:\n\t\tieee->ps = IEEE80211_PS_UNICAST;\n\t\tbreak;\n\tcase IW_POWER_MULTICAST_R:\n\t\tieee->ps = IEEE80211_PS_MBCAST;\n\t\tbreak;\n\tcase IW_POWER_ALL_R:\n\t\tieee->ps = IEEE80211_PS_UNICAST | IEEE80211_PS_MBCAST;\n\t\tbreak;\n\n\tcase IW_POWER_ON:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\n\t}\nexit:\n\tmutex_unlock(&ieee->wx_mutex);\n\treturn ret;\n\n}\nEXPORT_SYMBOL(ieee80211_wx_set_power);\n\n \nint ieee80211_wx_get_power(struct ieee80211_device *ieee,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tmutex_lock(&ieee->wx_mutex);\n\n\tif (ieee->ps == IEEE80211_PS_DISABLED) {\n\t\twrqu->power.disabled = 1;\n\t\tgoto exit;\n\t}\n\n\twrqu->power.disabled = 0;\n\n\tif ((wrqu->power.flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\n\t\twrqu->power.flags = IW_POWER_TIMEOUT;\n\t\twrqu->power.value = ieee->ps_timeout * 1000;\n\t} else {\n\t\t \n\t\t \n\t\twrqu->power.flags = IW_POWER_PERIOD;\n\t\twrqu->power.value = ieee->ps_period * 1000;\n\t\t \n\t}\n\n\tif ((ieee->ps & (IEEE80211_PS_MBCAST | IEEE80211_PS_UNICAST)) == (IEEE80211_PS_MBCAST | IEEE80211_PS_UNICAST))\n\t\twrqu->power.flags |= IW_POWER_ALL_R;\n\telse if (ieee->ps & IEEE80211_PS_MBCAST)\n\t\twrqu->power.flags |= IW_POWER_MULTICAST_R;\n\telse\n\t\twrqu->power.flags |= IW_POWER_UNICAST_R;\n\nexit:\n\tmutex_unlock(&ieee->wx_mutex);\n\treturn 0;\n\n}\nEXPORT_SYMBOL(ieee80211_wx_get_power);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}