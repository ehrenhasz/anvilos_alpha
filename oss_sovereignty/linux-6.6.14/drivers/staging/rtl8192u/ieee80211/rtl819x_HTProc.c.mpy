{
  "module_name": "rtl819x_HTProc.c",
  "hash_id": "435735cf3bbd4a194898d45d899257596b37bee06892080991b8fdf3700dbbf4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c",
  "human_readable_source": "\n\n \n#include \"ieee80211.h\"\n\nu8 MCS_FILTER_ALL[16] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\nu8 MCS_FILTER_1SS[16] = {0xff, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\nu16 MCS_DATA_RATE[2][2][77] = {\n\t{\t{13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78, 104, 156, 208, 234, 260,\n\t\t 39, 78, 117, 234, 312, 351, 390, 52, 104, 156, 208, 312, 416, 468, 520,\n\t\t 0, 78, 104, 130, 117, 156, 195, 104, 130, 130, 156, 182, 182, 208, 156, 195,\n\t\t 195, 234, 273, 273, 312, 130, 156, 181, 156, 181, 208, 234, 208, 234, 260, 260,\n\t\t 286, 195, 234, 273, 234, 273, 312, 351, 312, 351, 390, 390, 429},\t\t\t\n\t\t{14, 29, 43, 58, 87, 116, 130, 144, 29, 58, 87, 116, 173, 231, 260, 289,\n\t\t 43, 87, 130, 173, 260, 347, 390, 433, 58, 116, 173, 231, 347, 462, 520, 578,\n\t\t 0, 87, 116, 144, 130, 173, 217, 116, 144, 144, 173, 202, 202, 231, 173, 217,\n\t\t 217, 260, 303, 303, 347, 144, 173, 202, 173, 202, 231, 260, 231, 260, 289, 289,\n\t\t 318, 217, 260, 303, 260, 303, 347, 390, 347, 390, 433, 433, 477}\t},\t\t\n\t{\t{27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540,\n\t\t 81, 162, 243, 324, 486, 648, 729, 810, 108, 216, 324, 432, 648, 864, 972, 1080,\n\t\t 12, 162, 216, 270, 243, 324, 405, 216, 270, 270, 324, 378, 378, 432, 324, 405,\n\t\t 405, 486, 567, 567, 648, 270, 324, 378, 324, 378, 432, 486, 432, 486, 540, 540,\n\t\t 594, 405, 486, 567, 486, 567, 648, 729, 648, 729, 810, 810, 891},\t\n\t\t{30, 60, 90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600,\n\t\t 90, 180, 270, 360, 540, 720, 810, 900, 120, 240, 360, 480, 720, 960, 1080, 1200,\n\t\t 13, 180, 240, 300, 270, 360, 450, 240, 300, 300, 360, 420, 420, 480, 360, 450,\n\t\t 450, 540, 630, 630, 720, 300, 360, 420, 360, 420, 480, 540, 480, 540, 600, 600,\n\t\t 660, 450, 540, 630, 540, 630, 720, 810, 720, 810, 900, 900, 990}\t}\t\n};\n\nstatic u8 UNKNOWN_BORADCOM[3] = {0x00, 0x14, 0xbf};\nstatic u8 LINKSYSWRT330_LINKSYSWRT300_BROADCOM[3] = {0x00, 0x1a, 0x70};\nstatic u8 LINKSYSWRT350_LINKSYSWRT150_BROADCOM[3] = {0x00, 0x1d, 0x7e};\nstatic u8 NETGEAR834Bv2_BROADCOM[3] = {0x00, 0x1b, 0x2f};\nstatic u8 BELKINF5D8233V1_RALINK[3] = {0x00, 0x17, 0x3f};\t\nstatic u8 BELKINF5D82334V3_RALINK[3] = {0x00, 0x1c, 0xdf};\nstatic u8 PCI_RALINK[3] = {0x00, 0x90, 0xcc};\nstatic u8 EDIMAX_RALINK[3] = {0x00, 0x0e, 0x2e};\nstatic u8 AIRLINK_RALINK[3] = {0x00, 0x18, 0x02};\n\nstatic u8 CISCO_BROADCOM[3] = {0x00, 0x17, 0x94};\n \n \nvoid HTUpdateDefaultSetting(struct ieee80211_device *ieee)\n{\n\tPRT_HIGH_THROUGHPUT\tpHTInfo = ieee->pHTInfo;\n\t\n\n\t\n\t\n\t\n\tpHTInfo->bRegShortGI20MHz = 1;\n\tpHTInfo->bRegShortGI40MHz = 1;\n\n\t\n\tpHTInfo->bRegBW40MHz = 1;\n\n\t\n\tif (pHTInfo->bRegBW40MHz)\n\t\tpHTInfo->bRegSuppCCK = 1;\n\telse\n\t\tpHTInfo->bRegSuppCCK = true;\n\n\t\n\tpHTInfo->nAMSDU_MaxSize = 7935UL;\n\tpHTInfo->bAMSDU_Support = 0;\n\n\t\n\tpHTInfo->bAMPDUEnable = 1;\n\tpHTInfo->AMPDU_Factor = 2; \n\tpHTInfo->MPDU_Density = 0;\n\n\t\n\tpHTInfo->SelfMimoPs = 3;\n\tif (pHTInfo->SelfMimoPs == 2)\n\t\tpHTInfo->SelfMimoPs = 3;\n\t\n\tieee->bTxDisableRateFallBack = 0;\n\tieee->bTxUseDriverAssingedRate = 0;\n\n\t \n\tpHTInfo->bRegRT2RTAggregation = 1;\n\n\t\n\tpHTInfo->bRegRxReorderEnable = 1;\n\tpHTInfo->RxReorderWinSize = 64;\n\tpHTInfo->RxReorderPendingTime = 30;\n\n#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE\n\tpHTInfo->UsbTxAggrNum = 4;\n#endif\n#ifdef USB_RX_AGGREGATION_SUPPORT\n\tpHTInfo->UsbRxFwAggrEn = 1;\n\tpHTInfo->UsbRxFwAggrPageNum = 24;\n\tpHTInfo->UsbRxFwAggrPacketNum = 8;\n\tpHTInfo->UsbRxFwAggrTimeout = 16; \n#endif\n}\n\n \nvoid HTDebugHTCapability(u8 *CapIE, u8 *TitleString)\n{\n\tstatic u8\t          EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};\t\n\tstruct ht_capability_ele *pCapELE;\n\n\tif (!memcmp(CapIE, EWC11NHTCap, sizeof(EWC11NHTCap))) {\n\t\t\n\t\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"EWC IE in %s()\\n\", __func__);\n\t\tpCapELE = (struct ht_capability_ele *)(&CapIE[4]);\n\t} else {\n\t\tpCapELE = (struct ht_capability_ele *)(&CapIE[0]);\n\t}\n\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"<Log HT Capability>. Called by %s\\n\", TitleString);\n\n\tIEEE80211_DEBUG(IEEE80211_DL_HT,  \"\\tSupported Channel Width = %s\\n\", (pCapELE->ChlWidth) ? \"20MHz\" : \"20/40MHz\");\n\tIEEE80211_DEBUG(IEEE80211_DL_HT,  \"\\tSupport Short GI for 20M = %s\\n\", (pCapELE->ShortGI20Mhz) ? \"YES\" : \"NO\");\n\tIEEE80211_DEBUG(IEEE80211_DL_HT,  \"\\tSupport Short GI for 40M = %s\\n\", (pCapELE->ShortGI40Mhz) ? \"YES\" : \"NO\");\n\tIEEE80211_DEBUG(IEEE80211_DL_HT,  \"\\tSupport TX STBC = %s\\n\", (pCapELE->TxSTBC) ? \"YES\" : \"NO\");\n\tIEEE80211_DEBUG(IEEE80211_DL_HT,  \"\\tMax AMSDU Size = %s\\n\", (pCapELE->MaxAMSDUSize) ? \"3839\" : \"7935\");\n\tIEEE80211_DEBUG(IEEE80211_DL_HT,  \"\\tSupport CCK in 20/40 mode = %s\\n\", (pCapELE->DssCCk) ? \"YES\" : \"NO\");\n\tIEEE80211_DEBUG(IEEE80211_DL_HT,  \"\\tMax AMPDU Factor = %d\\n\", pCapELE->MaxRxAMPDUFactor);\n\tIEEE80211_DEBUG(IEEE80211_DL_HT,  \"\\tMPDU Density = %d\\n\", pCapELE->MPDUDensity);\n\tIEEE80211_DEBUG(IEEE80211_DL_HT,  \"\\tMCS Rate Set = [%x][%x][%x][%x][%x]\\n\", pCapELE->MCS[0],\\\n\t\t\t\tpCapELE->MCS[1], pCapELE->MCS[2], pCapELE->MCS[3], pCapELE->MCS[4]);\n}\n\n \nvoid HTDebugHTInfo(u8 *InfoIE, u8 *TitleString)\n{\n\tstatic u8\tEWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};\t\n\tPHT_INFORMATION_ELE\t\tpHTInfoEle;\n\n\tif (!memcmp(InfoIE, EWC11NHTInfo, sizeof(EWC11NHTInfo))) {\n\t\t\n\t\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"EWC IE in %s()\\n\", __func__);\n\t\tpHTInfoEle = (PHT_INFORMATION_ELE)(&InfoIE[4]);\n\t} else {\n\t\tpHTInfoEle = (PHT_INFORMATION_ELE)(&InfoIE[0]);\n\t}\n\n\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"<Log HT Information Element>. Called by %s\\n\", TitleString);\n\n\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"\\tPrimary channel = %d\\n\", pHTInfoEle->ControlChl);\n\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"\\tSecondary channel =\");\n\tswitch (pHTInfoEle->ExtChlOffset) {\n\tcase 0:\n\t\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"Not Present\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"Upper channel\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"Reserved. Eooro!!!\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"Lower Channel\\n\");\n\t\tbreak;\n\t}\n\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"\\tRecommended channel width = %s\\n\", (pHTInfoEle->RecommemdedTxWidth) ? \"20Mhz\" : \"40Mhz\");\n\n\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"\\tOperation mode for protection = \");\n\tswitch (pHTInfoEle->OptMode) {\n\tcase 0:\n\t\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"No Protection\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"HT non-member protection mode\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"Suggest to open protection\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"HT mixed mode\\n\");\n\t\tbreak;\n\t}\n\n\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"\\tBasic MCS Rate Set = [%x][%x][%x][%x][%x]\\n\", pHTInfoEle->BasicMSC[0],\\\n\t\t\t\tpHTInfoEle->BasicMSC[1], pHTInfoEle->BasicMSC[2], pHTInfoEle->BasicMSC[3], pHTInfoEle->BasicMSC[4]);\n}\n\nstatic u16 HTMcsToDataRate(struct ieee80211_device *ieee, u8 nMcsRate)\n{\n\tPRT_HIGH_THROUGHPUT\tpHTInfo = ieee->pHTInfo;\n\n\tu8\tis40MHz = (pHTInfo->bCurBW40MHz) ? 1 : 0;\n\tu8\tisShortGI = (pHTInfo->bCurBW40MHz) ?\n\t\t\t\t\t\t((pHTInfo->bCurShortGI40MHz) ? 1 : 0) :\n\t\t\t\t\t\t((pHTInfo->bCurShortGI20MHz) ? 1 : 0);\n\treturn MCS_DATA_RATE[is40MHz][isShortGI][(nMcsRate & 0x7f)];\n}\n\n \nu16  TxCountToDataRate(struct ieee80211_device *ieee, u8 nDataRate)\n{\n\t\n\tu16\t\tCCKOFDMRate[12] = {0x02, 0x04, 0x0b, 0x16, 0x0c, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6c};\n\tu8\tis40MHz = 0;\n\tu8\tisShortGI = 0;\n\n\tif (nDataRate < 12) {\n\t\treturn CCKOFDMRate[nDataRate];\n\t} else {\n\t\tif (nDataRate >= 0x10 && nDataRate <= 0x1f) { \n\t\t\tis40MHz = 0;\n\t\t\tisShortGI = 0;\n\n\t\t      \n\t\t} else if (nDataRate >= 0x20  && nDataRate <= 0x2f) { \n\t\t\tis40MHz = 1;\n\t\t\tisShortGI = 0;\n\n\t\t\t\n\t\t} else if (nDataRate >= 0x30  && nDataRate <= 0x3f) { \n\t\t\tis40MHz = 0;\n\t\t\tisShortGI = 1;\n\n\t\t\t\n\t\t} else if (nDataRate >= 0x40  && nDataRate <= 0x4f) { \n\t\t\tis40MHz = 1;\n\t\t\tisShortGI = 1;\n\n\t\t\t\n\t\t}\n\t\treturn MCS_DATA_RATE[is40MHz][isShortGI][nDataRate & 0xf];\n\t}\n}\n\nbool IsHTHalfNmodeAPs(struct ieee80211_device *ieee)\n{\n\tbool\t\t\tretValue = false;\n\tstruct ieee80211_network *net = &ieee->current_network;\n\n\tif ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3) == 0) ||\n\t    (memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3) == 0) ||\n\t    (memcmp(net->bssid, PCI_RALINK, 3) == 0) ||\n\t    (memcmp(net->bssid, EDIMAX_RALINK, 3) == 0) ||\n\t    (memcmp(net->bssid, AIRLINK_RALINK, 3) == 0) ||\n\t    (net->ralink_cap_exist))\n\t\tretValue = true;\n\telse if ((memcmp(net->bssid, UNKNOWN_BORADCOM, 3) == 0) ||\n\t\t (memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3) == 0) ||\n\t\t (memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3) == 0) ||\n\t\t (memcmp(net->bssid, NETGEAR834Bv2_BROADCOM, 3) == 0) ||\n\t\t (net->broadcom_cap_exist))\n\t\tretValue = true;\n\telse if (net->bssht.bdRT2RTAggregation)\n\t\tretValue = true;\n\telse\n\t\tretValue = false;\n\n\treturn retValue;\n}\n\n \nstatic void HTIOTPeerDetermine(struct ieee80211_device *ieee)\n{\n\tPRT_HIGH_THROUGHPUT\tpHTInfo = ieee->pHTInfo;\n\tstruct ieee80211_network *net = &ieee->current_network;\n\n\tif (net->bssht.bdRT2RTAggregation)\n\t\tpHTInfo->IOTPeer = HT_IOT_PEER_REALTEK;\n\telse if (net->broadcom_cap_exist)\n\t\tpHTInfo->IOTPeer = HT_IOT_PEER_BROADCOM;\n\telse if ((memcmp(net->bssid, UNKNOWN_BORADCOM, 3) == 0) ||\n\t\t (memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3) == 0) ||\n\t\t (memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3) == 0) ||\n\t\t (memcmp(net->bssid, NETGEAR834Bv2_BROADCOM, 3) == 0))\n\t\tpHTInfo->IOTPeer = HT_IOT_PEER_BROADCOM;\n\telse if ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3) == 0) ||\n\t\t (memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3) == 0) ||\n\t\t (memcmp(net->bssid, PCI_RALINK, 3) == 0) ||\n\t\t (memcmp(net->bssid, EDIMAX_RALINK, 3) == 0) ||\n\t\t (memcmp(net->bssid, AIRLINK_RALINK, 3) == 0) ||\n\t\t net->ralink_cap_exist)\n\t\tpHTInfo->IOTPeer = HT_IOT_PEER_RALINK;\n\telse if (net->atheros_cap_exist)\n\t\tpHTInfo->IOTPeer = HT_IOT_PEER_ATHEROS;\n\telse if (memcmp(net->bssid, CISCO_BROADCOM, 3) == 0)\n\t\tpHTInfo->IOTPeer = HT_IOT_PEER_CISCO;\n\telse\n\t\tpHTInfo->IOTPeer = HT_IOT_PEER_UNKNOWN;\n\n\tIEEE80211_DEBUG(IEEE80211_DL_IOT, \"Joseph debug!! IOTPEER: %x\\n\", pHTInfo->IOTPeer);\n}\n\n \nstatic u8 HTIOTActIsDisableMCS14(struct ieee80211_device *ieee, u8 *PeerMacAddr)\n{\n\treturn 0;\n}\n\n \nstatic bool HTIOTActIsDisableMCS15(struct ieee80211_device *ieee)\n{\n\tbool retValue = false;\n\n#ifdef TODO\n\t\n#if (HAL_CODE_BASE == RTL8192)\n\n#if (DEV_BUS_TYPE == USB_INTERFACE)\n\t\n\tretValue = true;\n#elif (DEV_BUS_TYPE == PCI_INTERFACE)\n\t\n\n\n\n\t\tretValue = false;\n#endif\n#endif\n#endif\n\t\n\n\treturn retValue;\n}\n\n \nstatic bool HTIOTActIsDisableMCSTwoSpatialStream(struct ieee80211_device *ieee,\n\t\t\t\t\t\t u8 *PeerMacAddr)\n{\n#ifdef TODO\n\t\n#endif\n\treturn false;\n}\n\n \nstatic u8 HTIOTActIsDisableEDCATurbo(struct ieee80211_device *ieee,\n\t\t\t\t     u8 *PeerMacAddr)\n{\t \n\treturn false;\n}\n\n \nstatic u8 HTIOTActIsMgntUseCCK6M(struct ieee80211_network *network)\n{\n\tu8\tretValue = 0;\n\n\t\n\t\n\n\tif (network->broadcom_cap_exist)\n\t\tretValue = 1;\n\n\treturn retValue;\n}\n\nstatic u8 HTIOTActIsCCDFsync(u8 *PeerMacAddr)\n{\n\tu8\tretValue = 0;\n\n\tif ((memcmp(PeerMacAddr, UNKNOWN_BORADCOM, 3) == 0) ||\n\t    (memcmp(PeerMacAddr, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3) == 0) ||\n\t    (memcmp(PeerMacAddr, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3) == 0))\n\t\tretValue = 1;\n\n\treturn retValue;\n}\n\nvoid HTResetIOTSetting(PRT_HIGH_THROUGHPUT pHTInfo)\n{\n\tpHTInfo->IOTAction = 0;\n\tpHTInfo->IOTPeer = HT_IOT_PEER_UNKNOWN;\n}\n\n \nvoid HTConstructCapabilityElement(struct ieee80211_device *ieee, u8 *posHTCap, u8 *len, u8 IsEncrypt)\n{\n\tPRT_HIGH_THROUGHPUT\tpHT = ieee->pHTInfo;\n\tstruct ht_capability_ele   *pCapELE = NULL;\n\t \n\n\tif (!posHTCap || !pHT) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR,\n\t\t\t\t\"posHTCap or pHTInfo can't be null in %s\\n\",\n\t\t\t\t__func__);\n\t\treturn;\n\t}\n\tmemset(posHTCap, 0, *len);\n\tif (pHT->ePeerHTSpecVer == HT_SPEC_VER_EWC) {\n\t\tstatic const u8\tEWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};\n\n\t\tmemcpy(posHTCap, EWC11NHTCap, sizeof(EWC11NHTCap));\n\t\tpCapELE = (struct ht_capability_ele *)&posHTCap[4];\n\t} else {\n\t\tpCapELE = (struct ht_capability_ele *)posHTCap;\n\t}\n\n\t \n\tpCapELE->AdvCoding\t\t= 0;  \n\tif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))\n\t\tpCapELE->ChlWidth = 0;\n\telse\n\t\tpCapELE->ChlWidth = (pHT->bRegBW40MHz ? 1 : 0);\n\n \n\tpCapELE->MimoPwrSave\t\t= pHT->SelfMimoPs;\n\tpCapELE->GreenField\t\t= 0;  \n\tpCapELE->ShortGI20Mhz\t\t= 1;  \n\tpCapELE->ShortGI40Mhz\t\t= 1;  \n\t \n\t \n\tpCapELE->TxSTBC\t\t\t= 1;\n\tpCapELE->RxSTBC\t\t\t= 0;\n\tpCapELE->DelayBA\t\t= 0;\t \n\tpCapELE->MaxAMSDUSize\t        = (MAX_RECEIVE_BUFFER_SIZE >= 7935) ? 1 : 0;\n\tpCapELE->DssCCk\t\t\t= ((pHT->bRegBW40MHz) ? (pHT->bRegSuppCCK ? 1 : 0) : 0);\n\tpCapELE->PSMP\t\t\t= 0;  \n\tpCapELE->LSigTxopProtect\t= 0;  \n\n\t \n\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"TX HT cap/info ele BW=%d MaxAMSDUSize:%d DssCCk:%d\\n\", pCapELE->ChlWidth, pCapELE->MaxAMSDUSize, pCapELE->DssCCk);\n\n\tif (IsEncrypt) {\n\t\tpCapELE->MPDUDensity\t= 7;  \n\t\tpCapELE->MaxRxAMPDUFactor = 2;  \n\t} else {\n\t\tpCapELE->MaxRxAMPDUFactor = 3;  \n\t\tpCapELE->MPDUDensity\t= 0;  \n\t}\n\n\t \n\tmemcpy(pCapELE->MCS, ieee->Regdot11HTOperationalRateSet, 16);\n\tif (pHT->IOTAction & HT_IOT_ACT_DISABLE_MCS15)\n\t\tpCapELE->MCS[1] &= 0x7f;\n\n\tif (pHT->IOTAction & HT_IOT_ACT_DISABLE_MCS14)\n\t\tpCapELE->MCS[1] &= 0xbf;\n\n\tif (pHT->IOTAction & HT_IOT_ACT_DISABLE_ALL_2SS)\n\t\tpCapELE->MCS[1] &= 0x00;\n\n\t \n\tif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev)) {\n\t\tint i;\n\n\t\tfor (i = 1; i < 16; i++)\n\t\t\tpCapELE->MCS[i] = 0;\n\t}\n\n\t \n\tmemset(&pCapELE->ExtHTCapInfo, 0, 2);\n\n\t \n\tmemset(pCapELE->TxBFCap, 0, 4);\n\n\t \n\tpCapELE->ASCap = 0;\n \n\tif (pHT->ePeerHTSpecVer == HT_SPEC_VER_EWC)\n\t\t*len = 30 + 2;\n\telse\n\t\t*len = 26 + 2;\n\n \n\n\t \n \n}\n\n \nvoid HTConstructInfoElement(struct ieee80211_device *ieee, u8 *posHTInfo, u8 *len, u8 IsEncrypt)\n{\n\tPRT_HIGH_THROUGHPUT\tpHT = ieee->pHTInfo;\n\tPHT_INFORMATION_ELE\t\tpHTInfoEle = (PHT_INFORMATION_ELE)posHTInfo;\n\n\tif (!posHTInfo || !pHTInfoEle) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR,\n\t\t\t\t\"posHTInfo or pHTInfoEle can't be null in %s\\n\",\n\t\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tmemset(posHTInfo, 0, *len);\n\tif ((ieee->iw_mode == IW_MODE_ADHOC) || (ieee->iw_mode == IW_MODE_MASTER)) {  \n\t\tpHTInfoEle->ControlChl\t\t\t= ieee->current_network.channel;\n\t\tpHTInfoEle->ExtChlOffset\t\t= ((!pHT->bRegBW40MHz) ? HT_EXTCHNL_OFFSET_NO_EXT :\n\t\t\t\t\t\t\t\t\t\t\t(ieee->current_network.channel <= 6) ?\n\t\t\t\t\t\t\t\t\t\t\t\tHT_EXTCHNL_OFFSET_UPPER : HT_EXTCHNL_OFFSET_LOWER);\n\t\tpHTInfoEle->RecommemdedTxWidth\t= pHT->bRegBW40MHz;\n\t\tpHTInfoEle->RIFS\t\t\t\t\t= 0;\n\t\tpHTInfoEle->PSMPAccessOnly\t\t= 0;\n\t\tpHTInfoEle->SrvIntGranularity\t\t= 0;\n\t\tpHTInfoEle->OptMode\t\t\t\t= pHT->CurrentOpMode;\n\t\tpHTInfoEle->NonGFDevPresent\t\t= 0;\n\t\tpHTInfoEle->DualBeacon\t\t\t= 0;\n\t\tpHTInfoEle->SecondaryBeacon\t\t= 0;\n\t\tpHTInfoEle->LSigTxopProtectFull\t\t= 0;\n\t\tpHTInfoEle->PcoActive\t\t\t\t= 0;\n\t\tpHTInfoEle->PcoPhase\t\t\t\t= 0;\n\n\t\tmemset(pHTInfoEle->BasicMSC, 0, 16);\n\n\t\t*len = 22 + 2;  \n\t} else {\n\t\t \n\t\t*len = 0;\n\t}\n\t \n\t \n}\n\n \n \nvoid HTConstructRT2RTAggElement(struct ieee80211_device *ieee, u8 *posRT2RTAgg, u8 *len)\n{\n\tif (!posRT2RTAgg) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR,\n\t\t\t\t\"posRT2RTAgg can't be null in %s\\n\",\n\t\t\t\t__func__);\n\t\treturn;\n\t}\n\tmemset(posRT2RTAgg, 0, *len);\n\t*posRT2RTAgg++ = 0x00;\n\t*posRT2RTAgg++ = 0xe0;\n\t*posRT2RTAgg++ = 0x4c;\n\t*posRT2RTAgg++ = 0x02;\n\t*posRT2RTAgg++ = 0x01;\n\t*posRT2RTAgg = 0x10; \n\n\tif (ieee->bSupportRemoteWakeUp)\n\t\t*posRT2RTAgg |= 0x08; \n\n\t*len = 6 + 2;\n\treturn;\n#ifdef TODO\n#if (HAL_CODE_BASE == RTL8192 && DEV_BUS_TYPE == USB_INTERFACE)\n\t \n#else\n\t \n#endif\n\n\tposRT2RTAgg->Length = 6;\n#endif\n}\n\n \nstatic u8 HT_PickMCSRate(struct ieee80211_device *ieee, u8 *pOperateMCS)\n{\n\tif (!pOperateMCS) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR,\n\t\t\t\t\"pOperateMCS can't be null in %s\\n\",\n\t\t\t\t__func__);\n\t\treturn false;\n\t}\n\n\tswitch (ieee->mode) {\n\tcase IEEE_A:\n\tcase IEEE_B:\n\tcase IEEE_G:\n\t\t \n\n\t\t \n\t\tmemset(pOperateMCS, 0, 16);\n\t\tbreak;\n\n\tcase IEEE_N_24G:\t \n\tcase IEEE_N_5G:\n\t\t \n\t\t \n\n\t\t \n\t\t \n\t\tpOperateMCS[0] &= RATE_ADPT_1SS_MASK;\t \n\t\tpOperateMCS[1] &= RATE_ADPT_2SS_MASK;\n\t\tpOperateMCS[3] &= RATE_ADPT_MCS32_MASK;\n\t\tbreak;\n\n\t \n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\n \n \nu8 HTGetHighestMCSRate(struct ieee80211_device *ieee, u8 *pMCSRateSet, u8 *pMCSFilter)\n{\n\tu8\t\ti, j;\n\tu8\t\tbitMap;\n\tu8\t\tmcsRate = 0;\n\tu8\t\tavailableMcsRate[16];\n\n\tif (!pMCSRateSet || !pMCSFilter) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR,\n\t\t\t\t\"pMCSRateSet or pMCSFilter can't be null in %s\\n\",\n\t\t\t\t__func__);\n\t\treturn false;\n\t}\n\tfor (i = 0; i < 16; i++)\n\t\tavailableMcsRate[i] = pMCSRateSet[i] & pMCSFilter[i];\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (availableMcsRate[i] != 0)\n\t\t\tbreak;\n\t}\n\tif (i == 16)\n\t\treturn false;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (availableMcsRate[i] != 0) {\n\t\t\tbitMap = availableMcsRate[i];\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tif ((bitMap % 2) != 0) {\n\t\t\t\t\tif (HTMcsToDataRate(ieee, (8 * i + j)) > HTMcsToDataRate(ieee, mcsRate))\n\t\t\t\t\t\tmcsRate = (8 * i + j);\n\t\t\t\t}\n\t\t\t\tbitMap >>= 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn (mcsRate | 0x80);\n}\n\n \nstatic u8 HTFilterMCSRate(struct ieee80211_device *ieee, u8 *pSupportMCS,\n\t\t\t  u8 *pOperateMCS)\n{\n\tu8 i = 0;\n\n\t \n\tfor (i = 0; i <= 15; i++)\n\t\tpOperateMCS[i] = ieee->Regdot11HTOperationalRateSet[i] & pSupportMCS[i];\n\n\t \n\t \n\tHT_PickMCSRate(ieee, pOperateMCS);\n\n\t \n\tif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))\n\t\tpOperateMCS[1] = 0;\n\n\t \n\tfor (i = 2; i <= 15; i++)\n\t\tpOperateMCS[i] = 0;\n\n\treturn true;\n}\n\nvoid HTOnAssocRsp(struct ieee80211_device *ieee)\n{\n\tPRT_HIGH_THROUGHPUT\tpHTInfo = ieee->pHTInfo;\n\tstruct ht_capability_ele       *pPeerHTCap = NULL;\n\tPHT_INFORMATION_ELE\t\tpPeerHTInfo = NULL;\n\tu16\tnMaxAMSDUSize = 0;\n\tu8\t*pMcsFilter = NULL;\n\n\tstatic u8\t\t\t\tEWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};\t\t \n\tstatic u8\t\t\t\tEWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};\t \n\n\tif (!pHTInfo->bCurrentHTSupport) {\n\t\tIEEE80211_DEBUG(IEEE80211_DL_ERR,\n\t\t\t\t\"<=== %s: HT_DISABLE\\n\",\n\t\t\t\t__func__);\n\t\treturn;\n\t}\n\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"===> HTOnAssocRsp_wq(): HT_ENABLE\\n\");\n \n \n\n \n \n\t \n\tif (!memcmp(pHTInfo->PeerHTCapBuf, EWC11NHTCap, sizeof(EWC11NHTCap)))\n\t\tpPeerHTCap = (struct ht_capability_ele *)(&pHTInfo->PeerHTCapBuf[4]);\n\telse\n\t\tpPeerHTCap = (struct ht_capability_ele *)(pHTInfo->PeerHTCapBuf);\n\n\tif (!memcmp(pHTInfo->PeerHTInfoBuf, EWC11NHTInfo, sizeof(EWC11NHTInfo)))\n\t\tpPeerHTInfo = (PHT_INFORMATION_ELE)(&pHTInfo->PeerHTInfoBuf[4]);\n\telse\n\t\tpPeerHTInfo = (PHT_INFORMATION_ELE)(pHTInfo->PeerHTInfoBuf);\n\n\t \n\t \n\t \n\tIEEE80211_DEBUG_DATA(IEEE80211_DL_DATA | IEEE80211_DL_HT, pPeerHTCap, sizeof(struct ht_capability_ele));\n \n\t \n\t \n\tHTSetConnectBwMode(ieee, (enum ht_channel_width)(pPeerHTCap->ChlWidth), (enum ht_extension_chan_offset)(pPeerHTInfo->ExtChlOffset));\n\n\tpHTInfo->bCurTxBW40MHz = (pPeerHTInfo->RecommemdedTxWidth == 1);\n\n\t \n\tpHTInfo->bCurShortGI20MHz = pHTInfo->bRegShortGI20MHz &&\n\t\t\t\t    (pPeerHTCap->ShortGI20Mhz == 1);\n\tpHTInfo->bCurShortGI40MHz = pHTInfo->bRegShortGI40MHz &&\n\t\t\t\t   (pPeerHTCap->ShortGI40Mhz == 1);\n\n\t \n\n\t \n\tpHTInfo->bCurSuppCCK = pHTInfo->bRegSuppCCK &&\n\t\t\t       (pPeerHTCap->DssCCk == 1);\n\n\t \n\tpHTInfo->bCurrent_AMSDU_Support = pHTInfo->bAMSDU_Support;\n\n\tnMaxAMSDUSize = (pPeerHTCap->MaxAMSDUSize == 0) ? 3839 : 7935;\n\n\tif (pHTInfo->nAMSDU_MaxSize > nMaxAMSDUSize)\n\t\tpHTInfo->nCurrent_AMSDU_MaxSize = nMaxAMSDUSize;\n\telse\n\t\tpHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;\n\t \n\tpHTInfo->bCurrentAMPDUEnable = pHTInfo->bAMPDUEnable;\n\n\t \n\tif (!pHTInfo->bRegRT2RTAggregation) {\n\t\t \n\t\tif (pHTInfo->AMPDU_Factor > pPeerHTCap->MaxRxAMPDUFactor)\n\t\t\tpHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;\n\t\telse\n\t\t\tpHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;\n\t} else {\n\t\t \n\t\tif (ieee->current_network.bssht.bdRT2RTAggregation) {\n\t\t\tif (ieee->pairwise_key_type != KEY_TYPE_NA)\n\t\t\t\t \n\t\t\t\tpHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;\n\t\t\telse\n\t\t\t\tpHTInfo->CurrentAMPDUFactor = HT_AGG_SIZE_64K;\n\t\t} else {\n\t\t\tpHTInfo->CurrentAMPDUFactor = min_t(u32, pPeerHTCap->MaxRxAMPDUFactor,\n\t\t\t\t\t\t\t    HT_AGG_SIZE_32K);\n\t\t}\n\t}\n\n\t \n\tpHTInfo->CurrentMPDUDensity = max_t(u32, pHTInfo->MPDU_Density,\n\t\t\t\t\t    pPeerHTCap->MPDUDensity);\n\n\tif (ieee->pairwise_key_type != KEY_TYPE_NA)\n\t\tpHTInfo->CurrentMPDUDensity\t= 7;  \n\t \n\n\t \n\t \n\tif (0) {\n\t\tpHTInfo->bCurrentAMPDUEnable = false;\n\t\tpHTInfo->ForcedAMSDUMode = HT_AGG_FORCE_ENABLE;\n\t\tpHTInfo->ForcedAMSDUMaxSize = 7935;\n\n\t\tpHTInfo->IOTAction |=  HT_IOT_ACT_TX_USE_AMSDU_8K;\n\t}\n\n\t \n\tpHTInfo->bCurRxReorderEnable = pHTInfo->bRegRxReorderEnable;\n\n\t \n\n\t \n\tif (pPeerHTCap->MCS[0] == 0)\n\t\tpPeerHTCap->MCS[0] = 0xff;\n\n\tHTFilterMCSRate(ieee, pPeerHTCap->MCS, ieee->dot11HTOperationalRateSet);\n\n\t \n\tpHTInfo->PeerMimoPs = pPeerHTCap->MimoPwrSave;\n\tif (pHTInfo->PeerMimoPs == MIMO_PS_STATIC)\n\t\tpMcsFilter = MCS_FILTER_1SS;\n\telse\n\t\tpMcsFilter = MCS_FILTER_ALL;\n\t \n \n\tieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee, ieee->dot11HTOperationalRateSet, pMcsFilter);\n\tieee->HTCurrentOperaRate = ieee->HTHighestOperaRate;\n\n\t \n\tpHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;\n}\n\n \n \nvoid HTInitializeHTInfo(struct ieee80211_device *ieee)\n{\n\tPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\n\n\t \n\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"===========>%s()\\n\", __func__);\n\tpHTInfo->bCurrentHTSupport = false;\n\n\t \n\tpHTInfo->bCurBW40MHz = false;\n\tpHTInfo->bCurTxBW40MHz = false;\n\n\t \n\tpHTInfo->bCurShortGI20MHz = false;\n\tpHTInfo->bCurShortGI40MHz = false;\n\tpHTInfo->bForcedShortGI = false;\n\n\t \n\tpHTInfo->bCurSuppCCK = true;\n\n\t \n\tpHTInfo->bCurrent_AMSDU_Support = false;\n\tpHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;\n\n\t \n\tpHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;\n\tpHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;\n\n\t \n\tmemset(&pHTInfo->SelfHTCap, 0, sizeof(pHTInfo->SelfHTCap));\n\tmemset(&pHTInfo->SelfHTInfo, 0, sizeof(pHTInfo->SelfHTInfo));\n\tmemset(&pHTInfo->PeerHTCapBuf, 0, sizeof(pHTInfo->PeerHTCapBuf));\n\tmemset(&pHTInfo->PeerHTInfoBuf, 0, sizeof(pHTInfo->PeerHTInfoBuf));\n\n\tpHTInfo->bSwBwInProgress = false;\n\n\t \n\tpHTInfo->ePeerHTSpecVer = HT_SPEC_VER_IEEE;\n\n\t \n\tpHTInfo->bCurrentRT2RTAggregation = false;\n\tpHTInfo->bCurrentRT2RTLongSlotTime = false;\n\tpHTInfo->IOTPeer = 0;\n\tpHTInfo->IOTAction = 0;\n\n\t \n\t{\n\t\tu8 *RegHTSuppRateSets = &ieee->RegHTSuppRateSet[0];\n\n\t\tRegHTSuppRateSets[0] = 0xFF;\t \n\t\tRegHTSuppRateSets[1] = 0xFF;\t \n\t\tRegHTSuppRateSets[4] = 0x01;\t \n\t}\n}\n\n \nvoid HTInitializeBssDesc(PBSS_HT pBssHT)\n{\n\tpBssHT->bdSupportHT = false;\n\tmemset(pBssHT->bdHTCapBuf, 0, sizeof(pBssHT->bdHTCapBuf));\n\tpBssHT->bdHTCapLen = 0;\n\tmemset(pBssHT->bdHTInfoBuf, 0, sizeof(pBssHT->bdHTInfoBuf));\n\tpBssHT->bdHTInfoLen = 0;\n\n\tpBssHT->bdHTSpecVer = HT_SPEC_VER_IEEE;\n\n\tpBssHT->bdRT2RTAggregation = false;\n\tpBssHT->bdRT2RTLongSlotTime = false;\n}\n\n \nvoid HTResetSelfAndSavePeerSetting(struct ieee80211_device *ieee,\tstruct ieee80211_network *pNetwork)\n{\n\tPRT_HIGH_THROUGHPUT\t\tpHTInfo = ieee->pHTInfo;\n \n \n \n \n\tu8\tbIOTAction = 0;\n\n\t \n\t \n\t \n\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"==============>%s()\\n\", __func__);\n\t \n \n\tif (pNetwork->bssht.bdSupportHT) {\n\t\tpHTInfo->bCurrentHTSupport = true;\n\t\tpHTInfo->ePeerHTSpecVer = pNetwork->bssht.bdHTSpecVer;\n\n\t\t \n\t\tif (pNetwork->bssht.bdHTCapLen > 0 &&\tpNetwork->bssht.bdHTCapLen <= sizeof(pHTInfo->PeerHTCapBuf))\n\t\t\tmemcpy(pHTInfo->PeerHTCapBuf, pNetwork->bssht.bdHTCapBuf, pNetwork->bssht.bdHTCapLen);\n\n\t\tif (pNetwork->bssht.bdHTInfoLen > 0 && pNetwork->bssht.bdHTInfoLen <= sizeof(pHTInfo->PeerHTInfoBuf))\n\t\t\tmemcpy(pHTInfo->PeerHTInfoBuf, pNetwork->bssht.bdHTInfoBuf, pNetwork->bssht.bdHTInfoLen);\n\n\t\t \n\t\tif (pHTInfo->bRegRT2RTAggregation) {\n\t\t\tpHTInfo->bCurrentRT2RTAggregation = pNetwork->bssht.bdRT2RTAggregation;\n\t\t\tpHTInfo->bCurrentRT2RTLongSlotTime = pNetwork->bssht.bdRT2RTLongSlotTime;\n\t\t} else {\n\t\t\tpHTInfo->bCurrentRT2RTAggregation = false;\n\t\t\tpHTInfo->bCurrentRT2RTLongSlotTime = false;\n\t\t}\n\n\t\t \n\t\tHTIOTPeerDetermine(ieee);\n\n\t\t \n\t\tpHTInfo->IOTAction = 0;\n\t\tbIOTAction = HTIOTActIsDisableMCS14(ieee, pNetwork->bssid);\n\t\tif (bIOTAction)\n\t\t\tpHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_MCS14;\n\n\t\tbIOTAction = HTIOTActIsDisableMCS15(ieee);\n\t\tif (bIOTAction)\n\t\t\tpHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_MCS15;\n\n\t\tbIOTAction = HTIOTActIsDisableMCSTwoSpatialStream(ieee, pNetwork->bssid);\n\t\tif (bIOTAction)\n\t\t\tpHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_ALL_2SS;\n\n\t\tbIOTAction = HTIOTActIsDisableEDCATurbo(ieee, pNetwork->bssid);\n\t\tif (bIOTAction)\n\t\t\tpHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_EDCA_TURBO;\n\n\t\tbIOTAction = HTIOTActIsMgntUseCCK6M(pNetwork);\n\t\tif (bIOTAction)\n\t\t\tpHTInfo->IOTAction |= HT_IOT_ACT_MGNT_USE_CCK_6M;\n\n\t\tbIOTAction = HTIOTActIsCCDFsync(pNetwork->bssid);\n\t\tif (bIOTAction)\n\t\t\tpHTInfo->IOTAction |= HT_IOT_ACT_CDD_FSYNC;\n\t} else {\n\t\tpHTInfo->bCurrentHTSupport = false;\n\t\tpHTInfo->bCurrentRT2RTAggregation = false;\n\t\tpHTInfo->bCurrentRT2RTLongSlotTime = false;\n\n\t\tpHTInfo->IOTAction = 0;\n\t}\n}\n\nvoid HTUpdateSelfAndPeerSetting(struct ieee80211_device *ieee,\tstruct ieee80211_network *pNetwork)\n{\n\tPRT_HIGH_THROUGHPUT\t        pHTInfo = ieee->pHTInfo;\n \n\tPHT_INFORMATION_ELE\t\tpPeerHTInfo = (PHT_INFORMATION_ELE)pNetwork->bssht.bdHTInfoBuf;\n\n\tif (pHTInfo->bCurrentHTSupport) {\n\t\t \n\t\tif (pNetwork->bssht.bdHTInfoLen != 0)\n\t\t\tpHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;\n\n\t\t \n\t}\n}\nEXPORT_SYMBOL(HTUpdateSelfAndPeerSetting);\n\n \nu8 HTCCheck(struct ieee80211_device *ieee, u8 *pFrame)\n{\n\tif (ieee->pHTInfo->bCurrentHTSupport) {\n\t\tif ((IsQoSDataFrame(pFrame) && Frame_Order(pFrame)) == 1) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"HT CONTROL FILED EXIST!!\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void HTSetConnectBwModeCallback(struct ieee80211_device *ieee)\n{\n\tPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\n\n\tIEEE80211_DEBUG(IEEE80211_DL_HT, \"======>%s()\\n\", __func__);\n\n\tif (pHTInfo->bCurBW40MHz) {\n\t\tif (pHTInfo->CurSTAExtChnlOffset == HT_EXTCHNL_OFFSET_UPPER)\n\t\t\tieee->set_chan(ieee->dev, ieee->current_network.channel + 2);\n\t\telse if (pHTInfo->CurSTAExtChnlOffset == HT_EXTCHNL_OFFSET_LOWER)\n\t\t\tieee->set_chan(ieee->dev, ieee->current_network.channel - 2);\n\t\telse\n\t\t\tieee->set_chan(ieee->dev, ieee->current_network.channel);\n\n\t\tieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20_40, pHTInfo->CurSTAExtChnlOffset);\n\t} else {\n\t\tieee->set_chan(ieee->dev, ieee->current_network.channel);\n\t\tieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);\n\t}\n\n\tpHTInfo->bSwBwInProgress = false;\n}\n\n \nvoid HTSetConnectBwMode(struct ieee80211_device *ieee, enum ht_channel_width Bandwidth, enum ht_extension_chan_offset Offset)\n{\n\tPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\n\n\n\tif (!pHTInfo->bRegBW40MHz)\n\t\treturn;\n\n\t\n\n\n\n\n\n\tif (pHTInfo->bSwBwInProgress) {\n\n\t\treturn;\n\t}\n\t\n\tif (Bandwidth == HT_CHANNEL_WIDTH_20_40 && (!ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))) {\n\t\t\t\n\t\tif (ieee->current_network.channel < 2 && Offset == HT_EXTCHNL_OFFSET_LOWER)\n\t\t\tOffset = HT_EXTCHNL_OFFSET_NO_EXT;\n\t\tif (Offset == HT_EXTCHNL_OFFSET_UPPER || Offset == HT_EXTCHNL_OFFSET_LOWER) {\n\t\t\tpHTInfo->bCurBW40MHz = true;\n\t\t\tpHTInfo->CurSTAExtChnlOffset = Offset;\n\t\t} else {\n\t\t\tpHTInfo->bCurBW40MHz = false;\n\t\t\tpHTInfo->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;\n\t\t}\n\t} else {\n\t\tpHTInfo->bCurBW40MHz = false;\n\t\tpHTInfo->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;\n\t}\n\n\tpHTInfo->bSwBwInProgress = true;\n\n\t \n\tHTSetConnectBwModeCallback(ieee);\n\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}