{
  "module_name": "uart.c",
  "hash_id": "2b028a8e18a87da7a6bd574b42bfb2c0c96fdaa879db3e9915d5b6deb390af80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/uart.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/sched/signal.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/tty.h>\n#include <linux/serial.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/idr.h>\n#include <linux/fs.h>\n#include <linux/kdev_t.h>\n#include <linux/kfifo.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/greybus.h>\n\n#include \"gbphy.h\"\n\n#define GB_NUM_MINORS\t16\t \n#define GB_NAME\t\t\"ttyGB\"\n\n#define GB_UART_WRITE_FIFO_SIZE\t\tPAGE_SIZE\n#define GB_UART_WRITE_ROOM_MARGIN\t1\t \n#define GB_UART_FIRMWARE_CREDITS\t4096\n#define GB_UART_CREDIT_WAIT_TIMEOUT_MSEC\t10000\n\nstruct gb_tty {\n\tstruct gbphy_device *gbphy_dev;\n\tstruct tty_port port;\n\tvoid *buffer;\n\tsize_t buffer_payload_max;\n\tstruct gb_connection *connection;\n\tu16 cport_id;\n\tunsigned int minor;\n\tunsigned char clocal;\n\tbool disconnected;\n\tspinlock_t read_lock;\n\tspinlock_t write_lock;\n\tstruct async_icount iocount;\n\tstruct async_icount oldcount;\n\twait_queue_head_t wioctl;\n\tstruct mutex mutex;\n\tu8 ctrlin;\t \n\tu8 ctrlout;\t \n\tstruct gb_uart_set_line_coding_request line_coding;\n\tstruct work_struct tx_work;\n\tstruct kfifo write_fifo;\n\tbool close_pending;\n\tunsigned int credits;\n\tstruct completion credits_complete;\n};\n\nstatic struct tty_driver *gb_tty_driver;\nstatic DEFINE_IDR(tty_minors);\nstatic DEFINE_MUTEX(table_lock);\n\nstatic int gb_uart_receive_data_handler(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct gb_tty *gb_tty = gb_connection_get_data(connection);\n\tstruct tty_port *port = &gb_tty->port;\n\tstruct gb_message *request = op->request;\n\tstruct gb_uart_recv_data_request *receive_data;\n\tu16 recv_data_size;\n\tint count;\n\tunsigned long tty_flags = TTY_NORMAL;\n\n\tif (request->payload_size < sizeof(*receive_data)) {\n\t\tdev_err(&gb_tty->gbphy_dev->dev,\n\t\t\t\"short receive-data request received (%zu < %zu)\\n\",\n\t\t\trequest->payload_size, sizeof(*receive_data));\n\t\treturn -EINVAL;\n\t}\n\n\treceive_data = op->request->payload;\n\trecv_data_size = le16_to_cpu(receive_data->size);\n\n\tif (recv_data_size != request->payload_size - sizeof(*receive_data)) {\n\t\tdev_err(&gb_tty->gbphy_dev->dev,\n\t\t\t\"malformed receive-data request received (%u != %zu)\\n\",\n\t\t\trecv_data_size,\n\t\t\trequest->payload_size - sizeof(*receive_data));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!recv_data_size)\n\t\treturn -EINVAL;\n\n\tif (receive_data->flags) {\n\t\tif (receive_data->flags & GB_UART_RECV_FLAG_BREAK)\n\t\t\ttty_flags = TTY_BREAK;\n\t\telse if (receive_data->flags & GB_UART_RECV_FLAG_PARITY)\n\t\t\ttty_flags = TTY_PARITY;\n\t\telse if (receive_data->flags & GB_UART_RECV_FLAG_FRAMING)\n\t\t\ttty_flags = TTY_FRAME;\n\n\t\t \n\t\tif (receive_data->flags & GB_UART_RECV_FLAG_OVERRUN)\n\t\t\ttty_insert_flip_char(port, 0, TTY_OVERRUN);\n\t}\n\tcount = tty_insert_flip_string_fixed_flag(port, receive_data->data,\n\t\t\t\t\t\t  tty_flags, recv_data_size);\n\tif (count != recv_data_size) {\n\t\tdev_err(&gb_tty->gbphy_dev->dev,\n\t\t\t\"UART: RX 0x%08x bytes only wrote 0x%08x\\n\",\n\t\t\trecv_data_size, count);\n\t}\n\tif (count)\n\t\ttty_flip_buffer_push(port);\n\treturn 0;\n}\n\nstatic int gb_uart_serial_state_handler(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct gb_tty *gb_tty = gb_connection_get_data(connection);\n\tstruct gb_message *request = op->request;\n\tstruct gb_uart_serial_state_request *serial_state;\n\n\tif (request->payload_size < sizeof(*serial_state)) {\n\t\tdev_err(&gb_tty->gbphy_dev->dev,\n\t\t\t\"short serial-state event received (%zu < %zu)\\n\",\n\t\t\trequest->payload_size, sizeof(*serial_state));\n\t\treturn -EINVAL;\n\t}\n\n\tserial_state = request->payload;\n\tgb_tty->ctrlin = serial_state->control;\n\n\treturn 0;\n}\n\nstatic int gb_uart_receive_credits_handler(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct gb_tty *gb_tty = gb_connection_get_data(connection);\n\tstruct gb_message *request = op->request;\n\tstruct gb_uart_receive_credits_request *credit_request;\n\tunsigned long flags;\n\tunsigned int incoming_credits;\n\tint ret = 0;\n\n\tif (request->payload_size < sizeof(*credit_request)) {\n\t\tdev_err(&gb_tty->gbphy_dev->dev,\n\t\t\t\"short receive_credits event received (%zu < %zu)\\n\",\n\t\t\trequest->payload_size,\n\t\t\tsizeof(*credit_request));\n\t\treturn -EINVAL;\n\t}\n\n\tcredit_request = request->payload;\n\tincoming_credits = le16_to_cpu(credit_request->count);\n\n\tspin_lock_irqsave(&gb_tty->write_lock, flags);\n\tgb_tty->credits += incoming_credits;\n\tif (gb_tty->credits > GB_UART_FIRMWARE_CREDITS) {\n\t\tgb_tty->credits -= incoming_credits;\n\t\tret = -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&gb_tty->write_lock, flags);\n\n\tif (ret) {\n\t\tdev_err(&gb_tty->gbphy_dev->dev,\n\t\t\t\"invalid number of incoming credits: %d\\n\",\n\t\t\tincoming_credits);\n\t\treturn ret;\n\t}\n\n\tif (!gb_tty->close_pending)\n\t\tschedule_work(&gb_tty->tx_work);\n\n\t \n\ttty_port_tty_wakeup(&gb_tty->port);\n\n\tif (gb_tty->credits == GB_UART_FIRMWARE_CREDITS)\n\t\tcomplete(&gb_tty->credits_complete);\n\n\treturn ret;\n}\n\nstatic int gb_uart_request_handler(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct gb_tty *gb_tty = gb_connection_get_data(connection);\n\tint type = op->type;\n\tint ret;\n\n\tswitch (type) {\n\tcase GB_UART_TYPE_RECEIVE_DATA:\n\t\tret = gb_uart_receive_data_handler(op);\n\t\tbreak;\n\tcase GB_UART_TYPE_SERIAL_STATE:\n\t\tret = gb_uart_serial_state_handler(op);\n\t\tbreak;\n\tcase GB_UART_TYPE_RECEIVE_CREDITS:\n\t\tret = gb_uart_receive_credits_handler(op);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&gb_tty->gbphy_dev->dev,\n\t\t\t\"unsupported unsolicited request: 0x%02x\\n\", type);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void  gb_uart_tx_write_work(struct work_struct *work)\n{\n\tstruct gb_uart_send_data_request *request;\n\tstruct gb_tty *gb_tty;\n\tunsigned long flags;\n\tunsigned int send_size;\n\tint ret;\n\n\tgb_tty = container_of(work, struct gb_tty, tx_work);\n\trequest = gb_tty->buffer;\n\n\twhile (1) {\n\t\tif (gb_tty->close_pending)\n\t\t\tbreak;\n\n\t\tspin_lock_irqsave(&gb_tty->write_lock, flags);\n\t\tsend_size = gb_tty->buffer_payload_max;\n\t\tif (send_size > gb_tty->credits)\n\t\t\tsend_size = gb_tty->credits;\n\n\t\tsend_size = kfifo_out_peek(&gb_tty->write_fifo,\n\t\t\t\t\t   &request->data[0],\n\t\t\t\t\t   send_size);\n\t\tif (!send_size) {\n\t\t\tspin_unlock_irqrestore(&gb_tty->write_lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tgb_tty->credits -= send_size;\n\t\tspin_unlock_irqrestore(&gb_tty->write_lock, flags);\n\n\t\trequest->size = cpu_to_le16(send_size);\n\t\tret = gb_operation_sync(gb_tty->connection,\n\t\t\t\t\tGB_UART_TYPE_SEND_DATA,\n\t\t\t\t\trequest, sizeof(*request) + send_size,\n\t\t\t\t\tNULL, 0);\n\t\tif (ret) {\n\t\t\tdev_err(&gb_tty->gbphy_dev->dev,\n\t\t\t\t\"send data error: %d\\n\", ret);\n\t\t\tspin_lock_irqsave(&gb_tty->write_lock, flags);\n\t\t\tgb_tty->credits += send_size;\n\t\t\tspin_unlock_irqrestore(&gb_tty->write_lock, flags);\n\t\t\tif (!gb_tty->close_pending)\n\t\t\t\tschedule_work(work);\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock_irqsave(&gb_tty->write_lock, flags);\n\t\tret = kfifo_out(&gb_tty->write_fifo, &request->data[0],\n\t\t\t\tsend_size);\n\t\tspin_unlock_irqrestore(&gb_tty->write_lock, flags);\n\n\t\ttty_port_tty_wakeup(&gb_tty->port);\n\t}\n}\n\nstatic int send_line_coding(struct gb_tty *tty)\n{\n\treturn gb_operation_sync(tty->connection, GB_UART_TYPE_SET_LINE_CODING,\n\t\t\t\t &tty->line_coding, sizeof(tty->line_coding),\n\t\t\t\t NULL, 0);\n}\n\nstatic int send_control(struct gb_tty *gb_tty, u8 control)\n{\n\tstruct gb_uart_set_control_line_state_request request;\n\n\trequest.control = control;\n\treturn gb_operation_sync(gb_tty->connection,\n\t\t\t\t GB_UART_TYPE_SET_CONTROL_LINE_STATE,\n\t\t\t\t &request, sizeof(request), NULL, 0);\n}\n\nstatic int send_break(struct gb_tty *gb_tty, u8 state)\n{\n\tstruct gb_uart_set_break_request request;\n\n\tif ((state != 0) && (state != 1)) {\n\t\tdev_err(&gb_tty->gbphy_dev->dev,\n\t\t\t\"invalid break state of %d\\n\", state);\n\t\treturn -EINVAL;\n\t}\n\n\trequest.state = state;\n\treturn gb_operation_sync(gb_tty->connection, GB_UART_TYPE_SEND_BREAK,\n\t\t\t\t &request, sizeof(request), NULL, 0);\n}\n\nstatic int gb_uart_wait_for_all_credits(struct gb_tty *gb_tty)\n{\n\tint ret;\n\n\tif (gb_tty->credits == GB_UART_FIRMWARE_CREDITS)\n\t\treturn 0;\n\n\tret = wait_for_completion_timeout(&gb_tty->credits_complete,\n\t\t\tmsecs_to_jiffies(GB_UART_CREDIT_WAIT_TIMEOUT_MSEC));\n\tif (!ret) {\n\t\tdev_err(&gb_tty->gbphy_dev->dev,\n\t\t\t\"time out waiting for credits\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_uart_flush(struct gb_tty *gb_tty, u8 flags)\n{\n\tstruct gb_uart_serial_flush_request request;\n\n\trequest.flags = flags;\n\treturn gb_operation_sync(gb_tty->connection, GB_UART_TYPE_FLUSH_FIFOS,\n\t\t\t\t &request, sizeof(request), NULL, 0);\n}\n\nstatic struct gb_tty *get_gb_by_minor(unsigned int minor)\n{\n\tstruct gb_tty *gb_tty;\n\n\tmutex_lock(&table_lock);\n\tgb_tty = idr_find(&tty_minors, minor);\n\tif (gb_tty) {\n\t\tmutex_lock(&gb_tty->mutex);\n\t\tif (gb_tty->disconnected) {\n\t\t\tmutex_unlock(&gb_tty->mutex);\n\t\t\tgb_tty = NULL;\n\t\t} else {\n\t\t\ttty_port_get(&gb_tty->port);\n\t\t\tmutex_unlock(&gb_tty->mutex);\n\t\t}\n\t}\n\tmutex_unlock(&table_lock);\n\treturn gb_tty;\n}\n\nstatic int alloc_minor(struct gb_tty *gb_tty)\n{\n\tint minor;\n\n\tmutex_lock(&table_lock);\n\tminor = idr_alloc(&tty_minors, gb_tty, 0, GB_NUM_MINORS, GFP_KERNEL);\n\tmutex_unlock(&table_lock);\n\tif (minor >= 0)\n\t\tgb_tty->minor = minor;\n\treturn minor;\n}\n\nstatic void release_minor(struct gb_tty *gb_tty)\n{\n\tint minor = gb_tty->minor;\n\n\tgb_tty->minor = 0;\t \n\tmutex_lock(&table_lock);\n\tidr_remove(&tty_minors, minor);\n\tmutex_unlock(&table_lock);\n}\n\nstatic int gb_tty_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct gb_tty *gb_tty;\n\tint retval;\n\n\tgb_tty = get_gb_by_minor(tty->index);\n\tif (!gb_tty)\n\t\treturn -ENODEV;\n\n\tretval = tty_standard_install(driver, tty);\n\tif (retval)\n\t\tgoto error;\n\n\ttty->driver_data = gb_tty;\n\treturn 0;\nerror:\n\ttty_port_put(&gb_tty->port);\n\treturn retval;\n}\n\nstatic int gb_tty_open(struct tty_struct *tty, struct file *file)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\n\treturn tty_port_open(&gb_tty->port, tty, file);\n}\n\nstatic void gb_tty_close(struct tty_struct *tty, struct file *file)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\n\ttty_port_close(&gb_tty->port, tty, file);\n}\n\nstatic void gb_tty_cleanup(struct tty_struct *tty)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\n\ttty_port_put(&gb_tty->port);\n}\n\nstatic void gb_tty_hangup(struct tty_struct *tty)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\n\ttty_port_hangup(&gb_tty->port);\n}\n\nstatic ssize_t gb_tty_write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\n\tcount =  kfifo_in_spinlocked(&gb_tty->write_fifo, buf, count,\n\t\t\t\t     &gb_tty->write_lock);\n\tif (count && !gb_tty->close_pending)\n\t\tschedule_work(&gb_tty->tx_work);\n\n\treturn count;\n}\n\nstatic unsigned int gb_tty_write_room(struct tty_struct *tty)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\tunsigned long flags;\n\tint room;\n\n\tspin_lock_irqsave(&gb_tty->write_lock, flags);\n\troom = kfifo_avail(&gb_tty->write_fifo);\n\tspin_unlock_irqrestore(&gb_tty->write_lock, flags);\n\n\troom -= GB_UART_WRITE_ROOM_MARGIN;\n\tif (room < 0)\n\t\treturn 0;\n\n\treturn room;\n}\n\nstatic unsigned int gb_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\tunsigned long flags;\n\tunsigned int chars;\n\n\tspin_lock_irqsave(&gb_tty->write_lock, flags);\n\tchars = kfifo_len(&gb_tty->write_fifo);\n\tif (gb_tty->credits < GB_UART_FIRMWARE_CREDITS)\n\t\tchars += GB_UART_FIRMWARE_CREDITS - gb_tty->credits;\n\tspin_unlock_irqrestore(&gb_tty->write_lock, flags);\n\n\treturn chars;\n}\n\nstatic int gb_tty_break_ctl(struct tty_struct *tty, int state)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\n\treturn send_break(gb_tty, state ? 1 : 0);\n}\n\nstatic void gb_tty_set_termios(struct tty_struct *tty,\n\t\t\t       const struct ktermios *termios_old)\n{\n\tstruct gb_uart_set_line_coding_request newline;\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\tstruct ktermios *termios = &tty->termios;\n\tu8 newctrl = gb_tty->ctrlout;\n\n\tnewline.rate = cpu_to_le32(tty_get_baud_rate(tty));\n\tnewline.format = termios->c_cflag & CSTOPB ?\n\t\t\t\tGB_SERIAL_2_STOP_BITS : GB_SERIAL_1_STOP_BITS;\n\tnewline.parity = termios->c_cflag & PARENB ?\n\t\t\t\t(termios->c_cflag & PARODD ? 1 : 2) +\n\t\t\t\t(termios->c_cflag & CMSPAR ? 2 : 0) : 0;\n\n\tnewline.data_bits = tty_get_char_size(termios->c_cflag);\n\n\t \n\tgb_tty->clocal = ((termios->c_cflag & CLOCAL) != 0);\n\n\tif (C_BAUD(tty) == B0) {\n\t\tnewline.rate = gb_tty->line_coding.rate;\n\t\tnewctrl &= ~(GB_UART_CTRL_DTR | GB_UART_CTRL_RTS);\n\t} else if (termios_old && (termios_old->c_cflag & CBAUD) == B0) {\n\t\tnewctrl |= (GB_UART_CTRL_DTR | GB_UART_CTRL_RTS);\n\t}\n\n\tif (newctrl != gb_tty->ctrlout) {\n\t\tgb_tty->ctrlout = newctrl;\n\t\tsend_control(gb_tty, newctrl);\n\t}\n\n\tif (C_CRTSCTS(tty) && C_BAUD(tty) != B0)\n\t\tnewline.flow_control = GB_SERIAL_AUTO_RTSCTS_EN;\n\telse\n\t\tnewline.flow_control = 0;\n\n\tif (memcmp(&gb_tty->line_coding, &newline, sizeof(newline))) {\n\t\tmemcpy(&gb_tty->line_coding, &newline, sizeof(newline));\n\t\tsend_line_coding(gb_tty);\n\t}\n}\n\nstatic int gb_tty_tiocmget(struct tty_struct *tty)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\n\treturn (gb_tty->ctrlout & GB_UART_CTRL_DTR ? TIOCM_DTR : 0) |\n\t       (gb_tty->ctrlout & GB_UART_CTRL_RTS ? TIOCM_RTS : 0) |\n\t       (gb_tty->ctrlin  & GB_UART_CTRL_DSR ? TIOCM_DSR : 0) |\n\t       (gb_tty->ctrlin  & GB_UART_CTRL_RI  ? TIOCM_RI  : 0) |\n\t       (gb_tty->ctrlin  & GB_UART_CTRL_DCD ? TIOCM_CD  : 0) |\n\t       TIOCM_CTS;\n}\n\nstatic int gb_tty_tiocmset(struct tty_struct *tty, unsigned int set,\n\t\t\t   unsigned int clear)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\tu8 newctrl = gb_tty->ctrlout;\n\n\tset = (set & TIOCM_DTR ? GB_UART_CTRL_DTR : 0) |\n\t      (set & TIOCM_RTS ? GB_UART_CTRL_RTS : 0);\n\tclear = (clear & TIOCM_DTR ? GB_UART_CTRL_DTR : 0) |\n\t\t(clear & TIOCM_RTS ? GB_UART_CTRL_RTS : 0);\n\n\tnewctrl = (newctrl & ~clear) | set;\n\tif (gb_tty->ctrlout == newctrl)\n\t\treturn 0;\n\n\tgb_tty->ctrlout = newctrl;\n\treturn send_control(gb_tty, newctrl);\n}\n\nstatic void gb_tty_throttle(struct tty_struct *tty)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\tunsigned char stop_char;\n\tint retval;\n\n\tif (I_IXOFF(tty)) {\n\t\tstop_char = STOP_CHAR(tty);\n\t\tretval = gb_tty_write(tty, &stop_char, 1);\n\t\tif (retval <= 0)\n\t\t\treturn;\n\t}\n\n\tif (tty->termios.c_cflag & CRTSCTS) {\n\t\tgb_tty->ctrlout &= ~GB_UART_CTRL_RTS;\n\t\tretval = send_control(gb_tty, gb_tty->ctrlout);\n\t}\n}\n\nstatic void gb_tty_unthrottle(struct tty_struct *tty)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\tunsigned char start_char;\n\tint retval;\n\n\tif (I_IXOFF(tty)) {\n\t\tstart_char = START_CHAR(tty);\n\t\tretval = gb_tty_write(tty, &start_char, 1);\n\t\tif (retval <= 0)\n\t\t\treturn;\n\t}\n\n\tif (tty->termios.c_cflag & CRTSCTS) {\n\t\tgb_tty->ctrlout |= GB_UART_CTRL_RTS;\n\t\tretval = send_control(gb_tty, gb_tty->ctrlout);\n\t}\n}\n\nstatic int get_serial_info(struct tty_struct *tty,\n\t\t\t   struct serial_struct *ss)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\n\tss->line = gb_tty->minor;\n\tss->close_delay = jiffies_to_msecs(gb_tty->port.close_delay) / 10;\n\tss->closing_wait =\n\t\tgb_tty->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?\n\t\tASYNC_CLOSING_WAIT_NONE :\n\t\tjiffies_to_msecs(gb_tty->port.closing_wait) / 10;\n\n\treturn 0;\n}\n\nstatic int set_serial_info(struct tty_struct *tty,\n\t\t\t   struct serial_struct *ss)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\tunsigned int closing_wait;\n\tunsigned int close_delay;\n\tint retval = 0;\n\n\tclose_delay = msecs_to_jiffies(ss->close_delay * 10);\n\tclosing_wait = ss->closing_wait == ASYNC_CLOSING_WAIT_NONE ?\n\t\t\tASYNC_CLOSING_WAIT_NONE :\n\t\t\tmsecs_to_jiffies(ss->closing_wait * 10);\n\n\tmutex_lock(&gb_tty->port.mutex);\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tif ((close_delay != gb_tty->port.close_delay) ||\n\t\t    (closing_wait != gb_tty->port.closing_wait))\n\t\t\tretval = -EPERM;\n\t} else {\n\t\tgb_tty->port.close_delay = close_delay;\n\t\tgb_tty->port.closing_wait = closing_wait;\n\t}\n\tmutex_unlock(&gb_tty->port.mutex);\n\treturn retval;\n}\n\nstatic int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)\n{\n\tint retval = 0;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct async_icount old;\n\tstruct async_icount new;\n\n\tif (!(arg & (TIOCM_DSR | TIOCM_RI | TIOCM_CD)))\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tspin_lock_irq(&gb_tty->read_lock);\n\t\told = gb_tty->oldcount;\n\t\tnew = gb_tty->iocount;\n\t\tgb_tty->oldcount = new;\n\t\tspin_unlock_irq(&gb_tty->read_lock);\n\n\t\tif ((arg & TIOCM_DSR) && (old.dsr != new.dsr))\n\t\t\tbreak;\n\t\tif ((arg & TIOCM_CD) && (old.dcd != new.dcd))\n\t\t\tbreak;\n\t\tif ((arg & TIOCM_RI) && (old.rng != new.rng))\n\t\t\tbreak;\n\n\t\tadd_wait_queue(&gb_tty->wioctl, &wait);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t\tremove_wait_queue(&gb_tty->wioctl, &wait);\n\t\tif (gb_tty->disconnected) {\n\t\t\tif (arg & TIOCM_CD)\n\t\t\t\tbreak;\n\t\t\tretval = -ENODEV;\n\t\t} else if (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t}\n\t} while (!retval);\n\n\treturn retval;\n}\n\nstatic int gb_tty_get_icount(struct tty_struct *tty,\n\t\t\t     struct serial_icounter_struct *icount)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\n\ticount->dsr = gb_tty->iocount.dsr;\n\ticount->rng = gb_tty->iocount.rng;\n\ticount->dcd = gb_tty->iocount.dcd;\n\ticount->frame = gb_tty->iocount.frame;\n\ticount->overrun = gb_tty->iocount.overrun;\n\ticount->parity = gb_tty->iocount.parity;\n\ticount->brk = gb_tty->iocount.brk;\n\n\treturn 0;\n}\n\nstatic int gb_tty_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct gb_tty *gb_tty = tty->driver_data;\n\n\tswitch (cmd) {\n\tcase TIOCMIWAIT:\n\t\treturn wait_serial_change(gb_tty, arg);\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nstatic void gb_tty_dtr_rts(struct tty_port *port, bool active)\n{\n\tstruct gb_tty *gb_tty;\n\tu8 newctrl;\n\n\tgb_tty = container_of(port, struct gb_tty, port);\n\tnewctrl = gb_tty->ctrlout;\n\n\tif (active)\n\t\tnewctrl |= (GB_UART_CTRL_DTR | GB_UART_CTRL_RTS);\n\telse\n\t\tnewctrl &= ~(GB_UART_CTRL_DTR | GB_UART_CTRL_RTS);\n\n\tgb_tty->ctrlout = newctrl;\n\tsend_control(gb_tty, newctrl);\n}\n\nstatic int gb_tty_port_activate(struct tty_port *port,\n\t\t\t\tstruct tty_struct *tty)\n{\n\tstruct gb_tty *gb_tty;\n\n\tgb_tty = container_of(port, struct gb_tty, port);\n\n\treturn gbphy_runtime_get_sync(gb_tty->gbphy_dev);\n}\n\nstatic void gb_tty_port_shutdown(struct tty_port *port)\n{\n\tstruct gb_tty *gb_tty;\n\tunsigned long flags;\n\tint ret;\n\n\tgb_tty = container_of(port, struct gb_tty, port);\n\n\tgb_tty->close_pending = true;\n\n\tcancel_work_sync(&gb_tty->tx_work);\n\n\tspin_lock_irqsave(&gb_tty->write_lock, flags);\n\tkfifo_reset_out(&gb_tty->write_fifo);\n\tspin_unlock_irqrestore(&gb_tty->write_lock, flags);\n\n\tif (gb_tty->credits == GB_UART_FIRMWARE_CREDITS)\n\t\tgoto out;\n\n\tret = gb_uart_flush(gb_tty, GB_SERIAL_FLAG_FLUSH_TRANSMITTER);\n\tif (ret) {\n\t\tdev_err(&gb_tty->gbphy_dev->dev,\n\t\t\t\"error flushing transmitter: %d\\n\", ret);\n\t}\n\n\tgb_uart_wait_for_all_credits(gb_tty);\n\nout:\n\tgb_tty->close_pending = false;\n\n\tgbphy_runtime_put_autosuspend(gb_tty->gbphy_dev);\n}\n\nstatic void gb_tty_port_destruct(struct tty_port *port)\n{\n\tstruct gb_tty *gb_tty = container_of(port, struct gb_tty, port);\n\n\tif (gb_tty->minor != GB_NUM_MINORS)\n\t\trelease_minor(gb_tty);\n\tkfifo_free(&gb_tty->write_fifo);\n\tkfree(gb_tty->buffer);\n\tkfree(gb_tty);\n}\n\nstatic const struct tty_operations gb_ops = {\n\t.install =\t\tgb_tty_install,\n\t.open =\t\t\tgb_tty_open,\n\t.close =\t\tgb_tty_close,\n\t.cleanup =\t\tgb_tty_cleanup,\n\t.hangup =\t\tgb_tty_hangup,\n\t.write =\t\tgb_tty_write,\n\t.write_room =\t\tgb_tty_write_room,\n\t.ioctl =\t\tgb_tty_ioctl,\n\t.throttle =\t\tgb_tty_throttle,\n\t.unthrottle =\t\tgb_tty_unthrottle,\n\t.chars_in_buffer =\tgb_tty_chars_in_buffer,\n\t.break_ctl =\t\tgb_tty_break_ctl,\n\t.set_termios =\t\tgb_tty_set_termios,\n\t.tiocmget =\t\tgb_tty_tiocmget,\n\t.tiocmset =\t\tgb_tty_tiocmset,\n\t.get_icount =\t\tgb_tty_get_icount,\n\t.set_serial =\t\tset_serial_info,\n\t.get_serial =\t\tget_serial_info,\n};\n\nstatic const struct tty_port_operations gb_port_ops = {\n\t.dtr_rts =\t\tgb_tty_dtr_rts,\n\t.activate =\t\tgb_tty_port_activate,\n\t.shutdown =\t\tgb_tty_port_shutdown,\n\t.destruct =\t\tgb_tty_port_destruct,\n};\n\nstatic int gb_uart_probe(struct gbphy_device *gbphy_dev,\n\t\t\t const struct gbphy_device_id *id)\n{\n\tstruct gb_connection *connection;\n\tsize_t max_payload;\n\tstruct gb_tty *gb_tty;\n\tstruct device *tty_dev;\n\tint retval;\n\tint minor;\n\n\tconnection = gb_connection_create(gbphy_dev->bundle,\n\t\t\t\t\t  le16_to_cpu(gbphy_dev->cport_desc->id),\n\t\t\t\t\t  gb_uart_request_handler);\n\tif (IS_ERR(connection))\n\t\treturn PTR_ERR(connection);\n\n\tmax_payload = gb_operation_get_payload_size_max(connection);\n\tif (max_payload < sizeof(struct gb_uart_send_data_request)) {\n\t\tretval = -EINVAL;\n\t\tgoto exit_connection_destroy;\n\t}\n\n\tgb_tty = kzalloc(sizeof(*gb_tty), GFP_KERNEL);\n\tif (!gb_tty) {\n\t\tretval = -ENOMEM;\n\t\tgoto exit_connection_destroy;\n\t}\n\n\ttty_port_init(&gb_tty->port);\n\tgb_tty->port.ops = &gb_port_ops;\n\tgb_tty->minor = GB_NUM_MINORS;\n\n\tgb_tty->buffer_payload_max = max_payload -\n\t\t\tsizeof(struct gb_uart_send_data_request);\n\n\tgb_tty->buffer = kzalloc(gb_tty->buffer_payload_max, GFP_KERNEL);\n\tif (!gb_tty->buffer) {\n\t\tretval = -ENOMEM;\n\t\tgoto exit_put_port;\n\t}\n\n\tINIT_WORK(&gb_tty->tx_work, gb_uart_tx_write_work);\n\n\tretval = kfifo_alloc(&gb_tty->write_fifo, GB_UART_WRITE_FIFO_SIZE,\n\t\t\t     GFP_KERNEL);\n\tif (retval)\n\t\tgoto exit_put_port;\n\n\tgb_tty->credits = GB_UART_FIRMWARE_CREDITS;\n\tinit_completion(&gb_tty->credits_complete);\n\n\tminor = alloc_minor(gb_tty);\n\tif (minor < 0) {\n\t\tif (minor == -ENOSPC) {\n\t\t\tdev_err(&gbphy_dev->dev,\n\t\t\t\t\"no more free minor numbers\\n\");\n\t\t\tretval = -ENODEV;\n\t\t} else {\n\t\t\tretval = minor;\n\t\t}\n\t\tgoto exit_put_port;\n\t}\n\n\tgb_tty->minor = minor;\n\tspin_lock_init(&gb_tty->write_lock);\n\tspin_lock_init(&gb_tty->read_lock);\n\tinit_waitqueue_head(&gb_tty->wioctl);\n\tmutex_init(&gb_tty->mutex);\n\n\tgb_tty->connection = connection;\n\tgb_tty->gbphy_dev = gbphy_dev;\n\tgb_connection_set_data(connection, gb_tty);\n\tgb_gbphy_set_data(gbphy_dev, gb_tty);\n\n\tretval = gb_connection_enable_tx(connection);\n\tif (retval)\n\t\tgoto exit_put_port;\n\n\tsend_control(gb_tty, gb_tty->ctrlout);\n\n\t \n\tgb_tty->line_coding.rate = cpu_to_le32(9600);\n\tgb_tty->line_coding.format = GB_SERIAL_1_STOP_BITS;\n\tgb_tty->line_coding.parity = GB_SERIAL_NO_PARITY;\n\tgb_tty->line_coding.data_bits = 8;\n\tsend_line_coding(gb_tty);\n\n\tretval = gb_connection_enable(connection);\n\tif (retval)\n\t\tgoto exit_connection_disable;\n\n\ttty_dev = tty_port_register_device(&gb_tty->port, gb_tty_driver, minor,\n\t\t\t\t\t   &gbphy_dev->dev);\n\tif (IS_ERR(tty_dev)) {\n\t\tretval = PTR_ERR(tty_dev);\n\t\tgoto exit_connection_disable;\n\t}\n\n\tgbphy_runtime_put_autosuspend(gbphy_dev);\n\treturn 0;\n\nexit_connection_disable:\n\tgb_connection_disable(connection);\nexit_put_port:\n\ttty_port_put(&gb_tty->port);\nexit_connection_destroy:\n\tgb_connection_destroy(connection);\n\n\treturn retval;\n}\n\nstatic void gb_uart_remove(struct gbphy_device *gbphy_dev)\n{\n\tstruct gb_tty *gb_tty = gb_gbphy_get_data(gbphy_dev);\n\tstruct gb_connection *connection = gb_tty->connection;\n\tstruct tty_struct *tty;\n\tint ret;\n\n\tret = gbphy_runtime_get_sync(gbphy_dev);\n\tif (ret)\n\t\tgbphy_runtime_get_noresume(gbphy_dev);\n\n\tmutex_lock(&gb_tty->mutex);\n\tgb_tty->disconnected = true;\n\n\twake_up_all(&gb_tty->wioctl);\n\tmutex_unlock(&gb_tty->mutex);\n\n\ttty = tty_port_tty_get(&gb_tty->port);\n\tif (tty) {\n\t\ttty_vhangup(tty);\n\t\ttty_kref_put(tty);\n\t}\n\n\tgb_connection_disable_rx(connection);\n\ttty_unregister_device(gb_tty_driver, gb_tty->minor);\n\n\tgb_connection_disable(connection);\n\tgb_connection_destroy(connection);\n\n\ttty_port_put(&gb_tty->port);\n}\n\nstatic int gb_tty_init(void)\n{\n\tint retval = 0;\n\n\tgb_tty_driver = tty_alloc_driver(GB_NUM_MINORS, 0);\n\tif (IS_ERR(gb_tty_driver)) {\n\t\tpr_err(\"Can not allocate tty driver\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto fail_unregister_dev;\n\t}\n\n\tgb_tty_driver->driver_name = \"gb\";\n\tgb_tty_driver->name = GB_NAME;\n\tgb_tty_driver->major = 0;\n\tgb_tty_driver->minor_start = 0;\n\tgb_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;\n\tgb_tty_driver->subtype = SERIAL_TYPE_NORMAL;\n\tgb_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\n\tgb_tty_driver->init_termios = tty_std_termios;\n\tgb_tty_driver->init_termios.c_cflag = B9600 | CS8 |\n\t\tCREAD | HUPCL | CLOCAL;\n\ttty_set_operations(gb_tty_driver, &gb_ops);\n\n\tretval = tty_register_driver(gb_tty_driver);\n\tif (retval) {\n\t\tpr_err(\"Can not register tty driver: %d\\n\", retval);\n\t\tgoto fail_put_gb_tty;\n\t}\n\n\treturn 0;\n\nfail_put_gb_tty:\n\ttty_driver_kref_put(gb_tty_driver);\nfail_unregister_dev:\n\treturn retval;\n}\n\nstatic void gb_tty_exit(void)\n{\n\ttty_unregister_driver(gb_tty_driver);\n\ttty_driver_kref_put(gb_tty_driver);\n\tidr_destroy(&tty_minors);\n}\n\nstatic const struct gbphy_device_id gb_uart_id_table[] = {\n\t{ GBPHY_PROTOCOL(GREYBUS_PROTOCOL_UART) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(gbphy, gb_uart_id_table);\n\nstatic struct gbphy_driver uart_driver = {\n\t.name\t\t= \"uart\",\n\t.probe\t\t= gb_uart_probe,\n\t.remove\t\t= gb_uart_remove,\n\t.id_table\t= gb_uart_id_table,\n};\n\nstatic int gb_uart_driver_init(void)\n{\n\tint ret;\n\n\tret = gb_tty_init();\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_gbphy_register(&uart_driver);\n\tif (ret) {\n\t\tgb_tty_exit();\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(gb_uart_driver_init);\n\nstatic void gb_uart_driver_exit(void)\n{\n\tgb_gbphy_deregister(&uart_driver);\n\tgb_tty_exit();\n}\n\nmodule_exit(gb_uart_driver_exit);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}