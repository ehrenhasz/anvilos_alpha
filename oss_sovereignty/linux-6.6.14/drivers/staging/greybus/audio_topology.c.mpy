{
  "module_name": "audio_topology.c",
  "hash_id": "5173e7ada01089240c4c7b49897dd60a01402786c34dd3922fb92e3ff1861843",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/audio_topology.c",
  "human_readable_source": "\n \n\n#include <linux/greybus.h>\n#include \"audio_codec.h\"\n\n#define GBAUDIO_INVALID_ID\t0xFF\n\n \nstruct gb_mixer_control {\n\tint min, max;\n\tunsigned int reg, rreg, shift, rshift, invert;\n};\n\nstruct gbaudio_ctl_pvt {\n\tunsigned int ctl_id;\n\tunsigned int data_cport;\n\tunsigned int access;\n\tunsigned int vcount;\n\tstruct gb_audio_ctl_elem_info *info;\n};\n\nstatic struct gbaudio_module_info *find_gb_module(struct gbaudio_codec_info *codec,\n\t\t\t\t\t\t  char const *name)\n{\n\tint dev_id;\n\tchar begin[NAME_SIZE];\n\tstruct gbaudio_module_info *module;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tif (sscanf(name, \"%s %d\", begin, &dev_id) != 2)\n\t\treturn NULL;\n\n\tdev_dbg(codec->dev, \"%s:Find module#%d\\n\", __func__, dev_id);\n\n\tmutex_lock(&codec->lock);\n\tlist_for_each_entry(module, &codec->module_list, list) {\n\t\tif (module->dev_id == dev_id) {\n\t\t\tmutex_unlock(&codec->lock);\n\t\t\treturn module;\n\t\t}\n\t}\n\tmutex_unlock(&codec->lock);\n\tdev_warn(codec->dev, \"%s: module#%d missing in codec list\\n\", name,\n\t\t dev_id);\n\treturn NULL;\n}\n\nstatic const char *gbaudio_map_controlid(struct gbaudio_module_info *module,\n\t\t\t\t\t __u8 control_id, __u8 index)\n{\n\tstruct gbaudio_control *control;\n\n\tif (control_id == GBAUDIO_INVALID_ID)\n\t\treturn NULL;\n\n\tlist_for_each_entry(control, &module->ctl_list, list) {\n\t\tif (control->id == control_id) {\n\t\t\tif (index == GBAUDIO_INVALID_ID)\n\t\t\t\treturn control->name;\n\t\t\tif (index >= control->items)\n\t\t\t\treturn NULL;\n\t\t\treturn control->texts[index];\n\t\t}\n\t}\n\tlist_for_each_entry(control, &module->widget_ctl_list, list) {\n\t\tif (control->id == control_id) {\n\t\t\tif (index == GBAUDIO_INVALID_ID)\n\t\t\t\treturn control->name;\n\t\t\tif (index >= control->items)\n\t\t\t\treturn NULL;\n\t\t\treturn control->texts[index];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int gbaudio_map_controlname(struct gbaudio_module_info *module,\n\t\t\t\t   const char *name)\n{\n\tstruct gbaudio_control *control;\n\n\tlist_for_each_entry(control, &module->ctl_list, list) {\n\t\tif (!strncmp(control->name, name, NAME_SIZE))\n\t\t\treturn control->id;\n\t}\n\n\tdev_warn(module->dev, \"%s: missing in modules controls list\\n\", name);\n\n\treturn -EINVAL;\n}\n\nstatic int gbaudio_map_wcontrolname(struct gbaudio_module_info *module,\n\t\t\t\t    const char *name)\n{\n\tstruct gbaudio_control *control;\n\n\tlist_for_each_entry(control, &module->widget_ctl_list, list) {\n\t\tif (!strncmp(control->wname, name, NAME_SIZE))\n\t\t\treturn control->id;\n\t}\n\tdev_warn(module->dev, \"%s: missing in modules controls list\\n\", name);\n\n\treturn -EINVAL;\n}\n\nstatic int gbaudio_map_widgetname(struct gbaudio_module_info *module,\n\t\t\t\t  const char *name)\n{\n\tstruct gbaudio_widget *widget;\n\n\tlist_for_each_entry(widget, &module->widget_list, list) {\n\t\tif (!strncmp(widget->name, name, NAME_SIZE))\n\t\t\treturn widget->id;\n\t}\n\tdev_warn(module->dev, \"%s: missing in modules widgets list\\n\", name);\n\n\treturn -EINVAL;\n}\n\nstatic const char *gbaudio_map_widgetid(struct gbaudio_module_info *module,\n\t\t\t\t\t__u8 widget_id)\n{\n\tstruct gbaudio_widget *widget;\n\n\tlist_for_each_entry(widget, &module->widget_list, list) {\n\t\tif (widget->id == widget_id)\n\t\t\treturn widget->name;\n\t}\n\treturn NULL;\n}\n\nstatic const char **gb_generate_enum_strings(struct gbaudio_module_info *gb,\n\t\t\t\t\t     struct gb_audio_enumerated *gbenum)\n{\n\tconst char **strings;\n\tint i;\n\tunsigned int items;\n\t__u8 *data;\n\n\titems = le32_to_cpu(gbenum->items);\n\tstrings = devm_kcalloc(gb->dev, items, sizeof(char *), GFP_KERNEL);\n\tif (!strings)\n\t\treturn NULL;\n\n\tdata = gbenum->names;\n\n\tfor (i = 0; i < items; i++) {\n\t\tstrings[i] = (const char *)data;\n\t\twhile (*data != '\\0')\n\t\t\tdata++;\n\t\tdata++;\n\t}\n\n\treturn strings;\n}\n\nstatic int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tunsigned int max;\n\tconst char *name;\n\tstruct gbaudio_ctl_pvt *data;\n\tstruct gb_audio_ctl_elem_info *info;\n\tstruct gbaudio_module_info *module;\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct gbaudio_codec_info *gbcodec = snd_soc_component_get_drvdata(comp);\n\n\tdev_dbg(comp->dev, \"Entered %s:%s\\n\", __func__, kcontrol->id.name);\n\tdata = (struct gbaudio_ctl_pvt *)kcontrol->private_value;\n\tinfo = (struct gb_audio_ctl_elem_info *)data->info;\n\n\tif (!info) {\n\t\tdev_err(comp->dev, \"NULL info for %s\\n\", uinfo->id.name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tuinfo->access = data->access;\n\tuinfo->count = data->vcount;\n\tuinfo->type = (__force snd_ctl_elem_type_t)info->type;\n\n\tswitch (info->type) {\n\tcase GB_AUDIO_CTL_ELEM_TYPE_BOOLEAN:\n\tcase GB_AUDIO_CTL_ELEM_TYPE_INTEGER:\n\t\tuinfo->value.integer.min = le32_to_cpu(info->value.integer.min);\n\t\tuinfo->value.integer.max = le32_to_cpu(info->value.integer.max);\n\t\tbreak;\n\tcase GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:\n\t\tmax = le32_to_cpu(info->value.enumerated.items);\n\t\tuinfo->value.enumerated.items = max;\n\t\tif (uinfo->value.enumerated.item > max - 1)\n\t\t\tuinfo->value.enumerated.item = max - 1;\n\t\tmodule = find_gb_module(gbcodec, kcontrol->id.name);\n\t\tif (!module)\n\t\t\treturn -EINVAL;\n\t\tname = gbaudio_map_controlid(module, data->ctl_id,\n\t\t\t\t\t     uinfo->value.enumerated.item);\n\t\tstrscpy(uinfo->value.enumerated.name, name, sizeof(uinfo->value.enumerated.name));\n\t\tbreak;\n\tdefault:\n\t\tdev_err(comp->dev, \"Invalid type: %d for %s:kcontrol\\n\",\n\t\t\tinfo->type, kcontrol->id.name);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint ret;\n\tstruct gb_audio_ctl_elem_info *info;\n\tstruct gbaudio_ctl_pvt *data;\n\tstruct gb_audio_ctl_elem_value gbvalue;\n\tstruct gbaudio_module_info *module;\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct gbaudio_codec_info *gb = snd_soc_component_get_drvdata(comp);\n\tstruct gb_bundle *bundle;\n\n\tdev_dbg(comp->dev, \"Entered %s:%s\\n\", __func__, kcontrol->id.name);\n\tmodule = find_gb_module(gb, kcontrol->id.name);\n\tif (!module)\n\t\treturn -EINVAL;\n\n\tdata = (struct gbaudio_ctl_pvt *)kcontrol->private_value;\n\tinfo = (struct gb_audio_ctl_elem_info *)data->info;\n\tbundle = to_gb_bundle(module->dev);\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_audio_gb_get_control(module->mgmt_connection, data->ctl_id,\n\t\t\t\t      GB_AUDIO_INVALID_INDEX, &gbvalue);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\tif (ret) {\n\t\tdev_err_ratelimited(comp->dev, \"%d:Error in %s for %s\\n\", ret,\n\t\t\t\t    __func__, kcontrol->id.name);\n\t\treturn ret;\n\t}\n\n\t \n\tswitch (info->type) {\n\tcase GB_AUDIO_CTL_ELEM_TYPE_BOOLEAN:\n\tcase GB_AUDIO_CTL_ELEM_TYPE_INTEGER:\n\t\tucontrol->value.integer.value[0] =\n\t\t\tle32_to_cpu(gbvalue.value.integer_value[0]);\n\t\tif (data->vcount == 2)\n\t\t\tucontrol->value.integer.value[1] =\n\t\t\t\tle32_to_cpu(gbvalue.value.integer_value[1]);\n\t\tbreak;\n\tcase GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:\n\t\tucontrol->value.enumerated.item[0] =\n\t\t\tle32_to_cpu(gbvalue.value.enumerated_item[0]);\n\t\tif (data->vcount == 2)\n\t\t\tucontrol->value.enumerated.item[1] =\n\t\t\t\tle32_to_cpu(gbvalue.value.enumerated_item[1]);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(comp->dev, \"Invalid type: %d for %s:kcontrol\\n\",\n\t\t\tinfo->type, kcontrol->id.name);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint ret = 0;\n\tstruct gb_audio_ctl_elem_info *info;\n\tstruct gbaudio_ctl_pvt *data;\n\tstruct gb_audio_ctl_elem_value gbvalue;\n\tstruct gbaudio_module_info *module;\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct gbaudio_codec_info *gb = snd_soc_component_get_drvdata(comp);\n\tstruct gb_bundle *bundle;\n\n\tdev_dbg(comp->dev, \"Entered %s:%s\\n\", __func__, kcontrol->id.name);\n\tmodule = find_gb_module(gb, kcontrol->id.name);\n\tif (!module)\n\t\treturn -EINVAL;\n\n\tdata = (struct gbaudio_ctl_pvt *)kcontrol->private_value;\n\tinfo = (struct gb_audio_ctl_elem_info *)data->info;\n\tbundle = to_gb_bundle(module->dev);\n\n\t \n\tswitch (info->type) {\n\tcase GB_AUDIO_CTL_ELEM_TYPE_BOOLEAN:\n\tcase GB_AUDIO_CTL_ELEM_TYPE_INTEGER:\n\t\tgbvalue.value.integer_value[0] =\n\t\t\tcpu_to_le32(ucontrol->value.integer.value[0]);\n\t\tif (data->vcount == 2)\n\t\t\tgbvalue.value.integer_value[1] =\n\t\t\t\tcpu_to_le32(ucontrol->value.integer.value[1]);\n\t\tbreak;\n\tcase GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:\n\t\tgbvalue.value.enumerated_item[0] =\n\t\t\tcpu_to_le32(ucontrol->value.enumerated.item[0]);\n\t\tif (data->vcount == 2)\n\t\t\tgbvalue.value.enumerated_item[1] =\n\t\t\t\tcpu_to_le32(ucontrol->value.enumerated.item[1]);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(comp->dev, \"Invalid type: %d for %s:kcontrol\\n\",\n\t\t\tinfo->type, kcontrol->id.name);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_audio_gb_set_control(module->mgmt_connection, data->ctl_id,\n\t\t\t\t      GB_AUDIO_INVALID_INDEX, &gbvalue);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\tif (ret) {\n\t\tdev_err_ratelimited(comp->dev, \"%d:Error in %s for %s\\n\", ret,\n\t\t\t\t    __func__, kcontrol->id.name);\n\t}\n\n\treturn ret;\n}\n\n#define SOC_MIXER_GB(xname, kcount, data) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.count = kcount, .info = gbcodec_mixer_ctl_info, \\\n\t.get = gbcodec_mixer_ctl_get, .put = gbcodec_mixer_ctl_put, \\\n\t.private_value = (unsigned long)data }\n\n \nstatic int gbcodec_mixer_dapm_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tint platform_max, platform_min;\n\tstruct gbaudio_ctl_pvt *data;\n\tstruct gb_audio_ctl_elem_info *info;\n\n\tdata = (struct gbaudio_ctl_pvt *)kcontrol->private_value;\n\tinfo = (struct gb_audio_ctl_elem_info *)data->info;\n\n\t \n\tplatform_max = le32_to_cpu(info->value.integer.max);\n\tplatform_min = le32_to_cpu(info->value.integer.min);\n\n\tif (platform_max == 1 &&\n\t    !strnstr(kcontrol->id.name, \" Volume\", sizeof(kcontrol->id.name)))\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\telse\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\n\tuinfo->count = data->vcount;\n\tuinfo->value.integer.min = platform_min;\n\tuinfo->value.integer.max = platform_max;\n\n\treturn 0;\n}\n\nstatic int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tint ret;\n\tstruct gbaudio_ctl_pvt *data;\n\tstruct gb_audio_ctl_elem_value gbvalue;\n\tstruct gbaudio_module_info *module;\n\tstruct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);\n\tstruct snd_soc_dapm_widget *widget = wlist->widgets[0];\n\tstruct device *codec_dev = widget->dapm->dev;\n\tstruct gbaudio_codec_info *gb = dev_get_drvdata(codec_dev);\n\tstruct gb_bundle *bundle;\n\n\tdev_dbg(codec_dev, \"Entered %s:%s\\n\", __func__, kcontrol->id.name);\n\tmodule = find_gb_module(gb, kcontrol->id.name);\n\tif (!module)\n\t\treturn -EINVAL;\n\n\tdata = (struct gbaudio_ctl_pvt *)kcontrol->private_value;\n\tbundle = to_gb_bundle(module->dev);\n\n\tif (data->vcount == 2)\n\t\tdev_warn(widget->dapm->dev,\n\t\t\t \"GB: Control '%s' is stereo, which is not supported\\n\",\n\t\t\t kcontrol->id.name);\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_audio_gb_get_control(module->mgmt_connection, data->ctl_id,\n\t\t\t\t      GB_AUDIO_INVALID_INDEX, &gbvalue);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\tif (ret) {\n\t\tdev_err_ratelimited(codec_dev, \"%d:Error in %s for %s\\n\", ret,\n\t\t\t\t    __func__, kcontrol->id.name);\n\t\treturn ret;\n\t}\n\t \n\tucontrol->value.integer.value[0] =\n\t\tle32_to_cpu(gbvalue.value.integer_value[0]);\n\n\treturn ret;\n}\n\nstatic int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tint ret, wi, max, connect;\n\tunsigned int mask, val;\n\tstruct gb_audio_ctl_elem_info *info;\n\tstruct gbaudio_ctl_pvt *data;\n\tstruct gb_audio_ctl_elem_value gbvalue;\n\tstruct gbaudio_module_info *module;\n\tstruct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);\n\tstruct snd_soc_dapm_widget *widget = wlist->widgets[0];\n\tstruct device *codec_dev = widget->dapm->dev;\n\tstruct gbaudio_codec_info *gb = dev_get_drvdata(codec_dev);\n\tstruct gb_bundle *bundle;\n\n\tdev_dbg(codec_dev, \"Entered %s:%s\\n\", __func__, kcontrol->id.name);\n\tmodule = find_gb_module(gb, kcontrol->id.name);\n\tif (!module)\n\t\treturn -EINVAL;\n\n\tdata = (struct gbaudio_ctl_pvt *)kcontrol->private_value;\n\tinfo = (struct gb_audio_ctl_elem_info *)data->info;\n\tbundle = to_gb_bundle(module->dev);\n\n\tif (data->vcount == 2)\n\t\tdev_warn(widget->dapm->dev,\n\t\t\t \"GB: Control '%s' is stereo, which is not supported\\n\",\n\t\t\t kcontrol->id.name);\n\n\tmax = le32_to_cpu(info->value.integer.max);\n\tmask = (1 << fls(max)) - 1;\n\tval = ucontrol->value.integer.value[0] & mask;\n\tconnect = !!val;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_audio_gb_get_control(module->mgmt_connection, data->ctl_id,\n\t\t\t\t      GB_AUDIO_INVALID_INDEX, &gbvalue);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tif (le32_to_cpu(gbvalue.value.integer_value[0]) != val) {\n\t\tfor (wi = 0; wi < wlist->num_widgets; wi++) {\n\t\t\twidget = wlist->widgets[wi];\n\t\t\tsnd_soc_dapm_mixer_update_power(widget->dapm, kcontrol,\n\t\t\t\t\t\t\tconnect, NULL);\n\t\t}\n\t\tgbvalue.value.integer_value[0] =\n\t\t\tcpu_to_le32(ucontrol->value.integer.value[0]);\n\n\t\tret = gb_audio_gb_set_control(module->mgmt_connection,\n\t\t\t\t\t      data->ctl_id,\n\t\t\t\t\t      GB_AUDIO_INVALID_INDEX, &gbvalue);\n\t}\n\nexit:\n\tgb_pm_runtime_put_autosuspend(bundle);\n\tif (ret)\n\t\tdev_err_ratelimited(codec_dev, \"%d:Error in %s for %s\\n\", ret,\n\t\t\t\t    __func__, kcontrol->id.name);\n\treturn ret;\n}\n\n#define SOC_DAPM_MIXER_GB(xname, kcount, data) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.count = kcount, .info = gbcodec_mixer_dapm_ctl_info, \\\n\t.get = gbcodec_mixer_dapm_ctl_get, .put = gbcodec_mixer_dapm_ctl_put, \\\n\t.private_value = (unsigned long)data}\n\nstatic int gbcodec_event_spk(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *k, int event)\n{\n\t \n\n\treturn 0;\n}\n\nstatic int gbcodec_event_hp(struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_kcontrol *k, int event)\n{\n\t \n\n\treturn 0;\n}\n\nstatic int gbcodec_event_int_mic(struct snd_soc_dapm_widget *w,\n\t\t\t\t struct snd_kcontrol *k, int event)\n{\n\t \n\n\treturn 0;\n}\n\nstatic int gbaudio_validate_kcontrol_count(struct gb_audio_widget *w)\n{\n\tint ret = 0;\n\n\tswitch (w->type) {\n\tcase snd_soc_dapm_spk:\n\tcase snd_soc_dapm_hp:\n\tcase snd_soc_dapm_mic:\n\tcase snd_soc_dapm_output:\n\tcase snd_soc_dapm_input:\n\t\tif (w->ncontrols)\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase snd_soc_dapm_switch:\n\tcase snd_soc_dapm_mux:\n\t\tif (w->ncontrols != 1)\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int gbcodec_enum_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint ret, ctl_id;\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct gbaudio_codec_info *gb = snd_soc_component_get_drvdata(comp);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tstruct gb_audio_ctl_elem_value gbvalue;\n\tstruct gbaudio_module_info *module;\n\tstruct gb_bundle *bundle;\n\n\tmodule = find_gb_module(gb, kcontrol->id.name);\n\tif (!module)\n\t\treturn -EINVAL;\n\n\tctl_id = gbaudio_map_controlname(module, kcontrol->id.name);\n\tif (ctl_id < 0)\n\t\treturn -EINVAL;\n\n\tbundle = to_gb_bundle(module->dev);\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_audio_gb_get_control(module->mgmt_connection, ctl_id,\n\t\t\t\t      GB_AUDIO_INVALID_INDEX, &gbvalue);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\tif (ret) {\n\t\tdev_err_ratelimited(comp->dev, \"%d:Error in %s for %s\\n\", ret,\n\t\t\t\t    __func__, kcontrol->id.name);\n\t\treturn ret;\n\t}\n\n\tucontrol->value.enumerated.item[0] =\n\t\tle32_to_cpu(gbvalue.value.enumerated_item[0]);\n\tif (e->shift_l != e->shift_r)\n\t\tucontrol->value.enumerated.item[1] =\n\t\t\tle32_to_cpu(gbvalue.value.enumerated_item[1]);\n\n\treturn 0;\n}\n\nstatic int gbcodec_enum_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint ret, ctl_id;\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct gbaudio_codec_info *gb = snd_soc_component_get_drvdata(comp);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tstruct gb_audio_ctl_elem_value gbvalue;\n\tstruct gbaudio_module_info *module;\n\tstruct gb_bundle *bundle;\n\n\tmodule = find_gb_module(gb, kcontrol->id.name);\n\tif (!module)\n\t\treturn -EINVAL;\n\n\tctl_id = gbaudio_map_controlname(module, kcontrol->id.name);\n\tif (ctl_id < 0)\n\t\treturn -EINVAL;\n\n\tif (ucontrol->value.enumerated.item[0] > e->items - 1)\n\t\treturn -EINVAL;\n\tgbvalue.value.enumerated_item[0] =\n\t\tcpu_to_le32(ucontrol->value.enumerated.item[0]);\n\n\tif (e->shift_l != e->shift_r) {\n\t\tif (ucontrol->value.enumerated.item[1] > e->items - 1)\n\t\t\treturn -EINVAL;\n\t\tgbvalue.value.enumerated_item[1] =\n\t\t\tcpu_to_le32(ucontrol->value.enumerated.item[1]);\n\t}\n\n\tbundle = to_gb_bundle(module->dev);\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_audio_gb_set_control(module->mgmt_connection, ctl_id,\n\t\t\t\t      GB_AUDIO_INVALID_INDEX, &gbvalue);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\tif (ret) {\n\t\tdev_err_ratelimited(comp->dev, \"%d:Error in %s for %s\\n\",\n\t\t\t\t    ret, __func__, kcontrol->id.name);\n\t}\n\n\treturn ret;\n}\n\nstatic int gbaudio_tplg_create_enum_kctl(struct gbaudio_module_info *gb,\n\t\t\t\t\t struct snd_kcontrol_new *kctl,\n\t\t\t\t\t struct gb_audio_control *ctl)\n{\n\tstruct soc_enum *gbe;\n\tstruct gb_audio_enumerated *gb_enum;\n\tint i;\n\n\tgbe = devm_kzalloc(gb->dev, sizeof(*gbe), GFP_KERNEL);\n\tif (!gbe)\n\t\treturn -ENOMEM;\n\n\tgb_enum = &ctl->info.value.enumerated;\n\n\t \n\tgbe->items = le32_to_cpu(gb_enum->items);\n\tgbe->texts = gb_generate_enum_strings(gb, gb_enum);\n\tif (!gbe->texts)\n\t\treturn -ENOMEM;\n\n\t \n\tdev_dbg(gb->dev, \"Max:%d, name_length:%d\\n\", gbe->items,\n\t\tle16_to_cpu(gb_enum->names_length));\n\tfor (i = 0; i < gbe->items; i++)\n\t\tdev_dbg(gb->dev, \"src[%d]: %s\\n\", i, gbe->texts[i]);\n\n\t*kctl = (struct snd_kcontrol_new)\n\t\tSOC_ENUM_EXT(ctl->name, *gbe, gbcodec_enum_ctl_get,\n\t\t\t     gbcodec_enum_ctl_put);\n\treturn 0;\n}\n\nstatic int gbaudio_tplg_create_kcontrol(struct gbaudio_module_info *gb,\n\t\t\t\t\tstruct snd_kcontrol_new *kctl,\n\t\t\t\t\tstruct gb_audio_control *ctl)\n{\n\tint ret = 0;\n\tstruct gbaudio_ctl_pvt *ctldata;\n\n\tswitch (ctl->iface) {\n\tcase (__force int)SNDRV_CTL_ELEM_IFACE_MIXER:\n\t\tswitch (ctl->info.type) {\n\t\tcase GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:\n\t\t\tret = gbaudio_tplg_create_enum_kctl(gb, kctl, ctl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tctldata = devm_kzalloc(gb->dev,\n\t\t\t\t\t       sizeof(struct gbaudio_ctl_pvt),\n\t\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!ctldata)\n\t\t\t\treturn -ENOMEM;\n\t\t\tctldata->ctl_id = ctl->id;\n\t\t\tctldata->data_cport = le16_to_cpu(ctl->data_cport);\n\t\t\tctldata->access = le32_to_cpu(ctl->access);\n\t\t\tctldata->vcount = ctl->count_values;\n\t\t\tctldata->info = &ctl->info;\n\t\t\t*kctl = (struct snd_kcontrol_new)\n\t\t\t\tSOC_MIXER_GB(ctl->name, ctl->count, ctldata);\n\t\t\tctldata = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(gb->dev, \"%s:%d control created\\n\", ctl->name, ctl->id);\n\treturn ret;\n}\n\nstatic int gbcodec_enum_dapm_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tint ret, ctl_id;\n\tstruct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);\n\tstruct snd_soc_dapm_widget *widget = wlist->widgets[0];\n\tstruct gbaudio_module_info *module;\n\tstruct gb_audio_ctl_elem_value gbvalue;\n\tstruct device *codec_dev = widget->dapm->dev;\n\tstruct gbaudio_codec_info *gb = dev_get_drvdata(codec_dev);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tstruct gb_bundle *bundle;\n\n\tmodule = find_gb_module(gb, kcontrol->id.name);\n\tif (!module)\n\t\treturn -EINVAL;\n\n\tctl_id = gbaudio_map_wcontrolname(module, kcontrol->id.name);\n\tif (ctl_id < 0)\n\t\treturn -EINVAL;\n\n\tbundle = to_gb_bundle(module->dev);\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_audio_gb_get_control(module->mgmt_connection, ctl_id,\n\t\t\t\t      GB_AUDIO_INVALID_INDEX, &gbvalue);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\tif (ret) {\n\t\tdev_err_ratelimited(codec_dev, \"%d:Error in %s for %s\\n\", ret,\n\t\t\t\t    __func__, kcontrol->id.name);\n\t\treturn ret;\n\t}\n\n\tucontrol->value.enumerated.item[0] = le32_to_cpu(gbvalue.value.enumerated_item[0]);\n\tif (e->shift_l != e->shift_r)\n\t\tucontrol->value.enumerated.item[1] =\n\t\t\tle32_to_cpu(gbvalue.value.enumerated_item[1]);\n\n\treturn 0;\n}\n\nstatic int gbcodec_enum_dapm_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tint ret, wi, ctl_id;\n\tunsigned int val, mux, change;\n\tunsigned int mask;\n\tstruct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);\n\tstruct snd_soc_dapm_widget *widget = wlist->widgets[0];\n\tstruct gb_audio_ctl_elem_value gbvalue;\n\tstruct gbaudio_module_info *module;\n\tstruct device *codec_dev = widget->dapm->dev;\n\tstruct gbaudio_codec_info *gb = dev_get_drvdata(codec_dev);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tstruct gb_bundle *bundle;\n\n\tif (ucontrol->value.enumerated.item[0] > e->items - 1)\n\t\treturn -EINVAL;\n\n\tmodule = find_gb_module(gb, kcontrol->id.name);\n\tif (!module)\n\t\treturn -EINVAL;\n\n\tctl_id = gbaudio_map_wcontrolname(module, kcontrol->id.name);\n\tif (ctl_id < 0)\n\t\treturn -EINVAL;\n\n\tchange = 0;\n\tbundle = to_gb_bundle(module->dev);\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_audio_gb_get_control(module->mgmt_connection, ctl_id,\n\t\t\t\t      GB_AUDIO_INVALID_INDEX, &gbvalue);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\tif (ret) {\n\t\tdev_err_ratelimited(codec_dev, \"%d:Error in %s for %s\\n\", ret,\n\t\t\t\t    __func__, kcontrol->id.name);\n\t\treturn ret;\n\t}\n\n\tmux = ucontrol->value.enumerated.item[0];\n\tval = mux << e->shift_l;\n\tmask = e->mask << e->shift_l;\n\n\tif (le32_to_cpu(gbvalue.value.enumerated_item[0]) !=\n\t    ucontrol->value.enumerated.item[0]) {\n\t\tchange = 1;\n\t\tgbvalue.value.enumerated_item[0] =\n\t\t\tcpu_to_le32(ucontrol->value.enumerated.item[0]);\n\t}\n\n\tif (e->shift_l != e->shift_r) {\n\t\tif (ucontrol->value.enumerated.item[1] > e->items - 1)\n\t\t\treturn -EINVAL;\n\t\tval |= ucontrol->value.enumerated.item[1] << e->shift_r;\n\t\tmask |= e->mask << e->shift_r;\n\t\tif (le32_to_cpu(gbvalue.value.enumerated_item[1]) !=\n\t\t    ucontrol->value.enumerated.item[1]) {\n\t\t\tchange = 1;\n\t\t\tgbvalue.value.enumerated_item[1] =\n\t\t\t\tcpu_to_le32(ucontrol->value.enumerated.item[1]);\n\t\t}\n\t}\n\n\tif (change) {\n\t\tret = gb_pm_runtime_get_sync(bundle);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = gb_audio_gb_set_control(module->mgmt_connection, ctl_id,\n\t\t\t\t\t      GB_AUDIO_INVALID_INDEX, &gbvalue);\n\n\t\tgb_pm_runtime_put_autosuspend(bundle);\n\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(codec_dev,\n\t\t\t\t\t    \"%d:Error in %s for %s\\n\", ret,\n\t\t\t\t\t    __func__, kcontrol->id.name);\n\t\t}\n\t\tfor (wi = 0; wi < wlist->num_widgets; wi++) {\n\t\t\twidget = wlist->widgets[wi];\n\t\t\tsnd_soc_dapm_mux_update_power(widget->dapm, kcontrol,\n\t\t\t\t\t\t      val, e, NULL);\n\t\t}\n\t}\n\n\treturn change;\n}\n\nstatic int gbaudio_tplg_create_enum_ctl(struct gbaudio_module_info *gb,\n\t\t\t\t\tstruct snd_kcontrol_new *kctl,\n\t\t\t\t\tstruct gb_audio_control *ctl)\n{\n\tstruct soc_enum *gbe;\n\tstruct gb_audio_enumerated *gb_enum;\n\tint i;\n\n\tgbe = devm_kzalloc(gb->dev, sizeof(*gbe), GFP_KERNEL);\n\tif (!gbe)\n\t\treturn -ENOMEM;\n\n\tgb_enum = &ctl->info.value.enumerated;\n\n\t \n\tgbe->items = le32_to_cpu(gb_enum->items);\n\tgbe->texts = gb_generate_enum_strings(gb, gb_enum);\n\tif (!gbe->texts)\n\t\treturn -ENOMEM;\n\n\t \n\tdev_dbg(gb->dev, \"Max:%d, name_length:%d\\n\", gbe->items,\n\t\tle16_to_cpu(gb_enum->names_length));\n\tfor (i = 0; i < gbe->items; i++)\n\t\tdev_dbg(gb->dev, \"src[%d]: %s\\n\", i, gbe->texts[i]);\n\n\t*kctl = (struct snd_kcontrol_new)\n\t\tSOC_DAPM_ENUM_EXT(ctl->name, *gbe, gbcodec_enum_dapm_ctl_get,\n\t\t\t\t  gbcodec_enum_dapm_ctl_put);\n\treturn 0;\n}\n\nstatic int gbaudio_tplg_create_mixer_ctl(struct gbaudio_module_info *gb,\n\t\t\t\t\t struct snd_kcontrol_new *kctl,\n\t\t\t\t\t struct gb_audio_control *ctl)\n{\n\tstruct gbaudio_ctl_pvt *ctldata;\n\n\tctldata = devm_kzalloc(gb->dev, sizeof(struct gbaudio_ctl_pvt),\n\t\t\t       GFP_KERNEL);\n\tif (!ctldata)\n\t\treturn -ENOMEM;\n\tctldata->ctl_id = ctl->id;\n\tctldata->data_cport = le16_to_cpu(ctl->data_cport);\n\tctldata->access = le32_to_cpu(ctl->access);\n\tctldata->vcount = ctl->count_values;\n\tctldata->info = &ctl->info;\n\t*kctl = (struct snd_kcontrol_new)\n\t\tSOC_DAPM_MIXER_GB(ctl->name, ctl->count, ctldata);\n\n\treturn 0;\n}\n\nstatic int gbaudio_tplg_create_wcontrol(struct gbaudio_module_info *gb,\n\t\t\t\t\tstruct snd_kcontrol_new *kctl,\n\t\t\t\t\tstruct gb_audio_control *ctl)\n{\n\tint ret;\n\n\tswitch (ctl->iface) {\n\tcase (__force int)SNDRV_CTL_ELEM_IFACE_MIXER:\n\t\tswitch (ctl->info.type) {\n\t\tcase GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:\n\t\t\tret = gbaudio_tplg_create_enum_ctl(gb, kctl, ctl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = gbaudio_tplg_create_mixer_ctl(gb, kctl, ctl);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(gb->dev, \"%s:%d DAPM control created, ret:%d\\n\", ctl->name,\n\t\tctl->id, ret);\n\treturn ret;\n}\n\nstatic int gbaudio_widget_event(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tint wid;\n\tint ret;\n\tstruct device *codec_dev = w->dapm->dev;\n\tstruct gbaudio_codec_info *gbcodec = dev_get_drvdata(codec_dev);\n\tstruct gbaudio_module_info *module;\n\tstruct gb_bundle *bundle;\n\n\tdev_dbg(codec_dev, \"%s %s %d\\n\", __func__, w->name, event);\n\n\t \n\tmodule = find_gb_module(gbcodec, w->name);\n\tif (!module)\n\t\treturn -EINVAL;\n\n\t \n\twid = gbaudio_map_widgetname(module, w->name);\n\tif (wid < 0) {\n\t\tdev_err(codec_dev, \"Invalid widget name:%s\\n\", w->name);\n\t\treturn -EINVAL;\n\t}\n\n\tbundle = to_gb_bundle(module->dev);\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tret = gb_audio_gb_enable_widget(module->mgmt_connection, wid);\n\t\tif (!ret)\n\t\t\tret = gbaudio_module_update(gbcodec, w, module, 1);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tret = gb_audio_gb_disable_widget(module->mgmt_connection, wid);\n\t\tif (!ret)\n\t\t\tret = gbaudio_module_update(gbcodec, w, module, 0);\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tdev_err_ratelimited(codec_dev,\n\t\t\t\t    \"%d: widget, event:%d failed:%d\\n\", wid,\n\t\t\t\t    event, ret);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dapm_widget gbaudio_widgets[] = {\n\t[snd_soc_dapm_spk]\t= SND_SOC_DAPM_SPK(NULL, gbcodec_event_spk),\n\t[snd_soc_dapm_hp]\t= SND_SOC_DAPM_HP(NULL, gbcodec_event_hp),\n\t[snd_soc_dapm_mic]\t= SND_SOC_DAPM_MIC(NULL, gbcodec_event_int_mic),\n\t[snd_soc_dapm_output]\t= SND_SOC_DAPM_OUTPUT(NULL),\n\t[snd_soc_dapm_input]\t= SND_SOC_DAPM_INPUT(NULL),\n\t[snd_soc_dapm_switch]\t= SND_SOC_DAPM_SWITCH_E(NULL, SND_SOC_NOPM,\n\t\t\t\t\t0, 0, NULL,\n\t\t\t\t\tgbaudio_widget_event,\n\t\t\t\t\tSND_SOC_DAPM_PRE_PMU |\n\t\t\t\t\tSND_SOC_DAPM_POST_PMD),\n\t[snd_soc_dapm_pga]\t= SND_SOC_DAPM_PGA_E(NULL, SND_SOC_NOPM,\n\t\t\t\t\t0, 0, NULL, 0,\n\t\t\t\t\tgbaudio_widget_event,\n\t\t\t\t\tSND_SOC_DAPM_PRE_PMU |\n\t\t\t\t\tSND_SOC_DAPM_POST_PMD),\n\t[snd_soc_dapm_mixer]\t= SND_SOC_DAPM_MIXER_E(NULL, SND_SOC_NOPM,\n\t\t\t\t\t0, 0, NULL, 0,\n\t\t\t\t\tgbaudio_widget_event,\n\t\t\t\t\tSND_SOC_DAPM_PRE_PMU |\n\t\t\t\t\tSND_SOC_DAPM_POST_PMD),\n\t[snd_soc_dapm_mux]\t= SND_SOC_DAPM_MUX_E(NULL, SND_SOC_NOPM,\n\t\t\t\t\t0, 0, NULL,\n\t\t\t\t\tgbaudio_widget_event,\n\t\t\t\t\tSND_SOC_DAPM_PRE_PMU |\n\t\t\t\t\tSND_SOC_DAPM_POST_PMD),\n\t[snd_soc_dapm_aif_in]\t= SND_SOC_DAPM_AIF_IN_E(NULL, NULL, 0,\n\t\t\t\t\tSND_SOC_NOPM, 0, 0,\n\t\t\t\t\tgbaudio_widget_event,\n\t\t\t\t\tSND_SOC_DAPM_PRE_PMU |\n\t\t\t\t\tSND_SOC_DAPM_POST_PMD),\n\t[snd_soc_dapm_aif_out]\t= SND_SOC_DAPM_AIF_OUT_E(NULL, NULL, 0,\n\t\t\t\t\tSND_SOC_NOPM, 0, 0,\n\t\t\t\t\tgbaudio_widget_event,\n\t\t\t\t\tSND_SOC_DAPM_PRE_PMU |\n\t\t\t\t\tSND_SOC_DAPM_POST_PMD),\n};\n\nstatic int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,\n\t\t\t\t      struct snd_soc_dapm_widget *dw,\n\t\t\t\t      struct gb_audio_widget *w, int *w_size)\n{\n\tint i, ret, csize;\n\tstruct snd_kcontrol_new *widget_kctls;\n\tstruct gb_audio_control *curr;\n\tstruct gbaudio_control *control, *_control;\n\tsize_t size;\n\tchar temp_name[NAME_SIZE];\n\n\tret = gbaudio_validate_kcontrol_count(w);\n\tif (ret) {\n\t\tdev_err(module->dev, \"Invalid kcontrol count=%d for %s\\n\",\n\t\t\tw->ncontrols, w->name);\n\t\treturn ret;\n\t}\n\n\t \n\tif (w->ncontrols) {\n\t\tsize = sizeof(struct snd_kcontrol_new) * w->ncontrols;\n\t\twidget_kctls = devm_kzalloc(module->dev, size, GFP_KERNEL);\n\t\tif (!widget_kctls)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t*w_size = sizeof(struct gb_audio_widget);\n\n\t \n\tcurr = w->ctl;\n\tfor (i = 0; i < w->ncontrols; i++) {\n\t\tret = gbaudio_tplg_create_wcontrol(module, &widget_kctls[i],\n\t\t\t\t\t\t   curr);\n\t\tif (ret) {\n\t\t\tdev_err(module->dev,\n\t\t\t\t\"%s:%d type widget_ctl not supported\\n\",\n\t\t\t\tcurr->name, curr->iface);\n\t\t\tgoto error;\n\t\t}\n\t\tcontrol = devm_kzalloc(module->dev,\n\t\t\t\t       sizeof(struct gbaudio_control),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!control) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tcontrol->id = curr->id;\n\t\tcontrol->name = curr->name;\n\t\tcontrol->wname = w->name;\n\n\t\tif (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED) {\n\t\t\tstruct gb_audio_enumerated *gbenum =\n\t\t\t\t&curr->info.value.enumerated;\n\n\t\t\tcsize = offsetof(struct gb_audio_control, info);\n\t\t\tcsize += offsetof(struct gb_audio_ctl_elem_info, value);\n\t\t\tcsize += offsetof(struct gb_audio_enumerated, names);\n\t\t\tcsize += le16_to_cpu(gbenum->names_length);\n\t\t\tcontrol->texts = (const char * const *)\n\t\t\t\tgb_generate_enum_strings(module, gbenum);\n\t\t\tif (!control->texts) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tcontrol->items = le32_to_cpu(gbenum->items);\n\t\t} else {\n\t\t\tcsize = sizeof(struct gb_audio_control);\n\t\t}\n\n\t\t*w_size += csize;\n\t\tcurr = (void *)curr + csize;\n\t\tlist_add(&control->list, &module->widget_ctl_list);\n\t\tdev_dbg(module->dev, \"%s: control of type %d created\\n\",\n\t\t\twidget_kctls[i].name, widget_kctls[i].iface);\n\t}\n\n\t \n\tstrscpy(temp_name, w->name, sizeof(temp_name));\n\tsnprintf(w->name, sizeof(w->name), \"GB %d %s\", module->dev_id, temp_name);\n\n\tswitch (w->type) {\n\tcase snd_soc_dapm_spk:\n\t\t*dw = gbaudio_widgets[w->type];\n\t\tmodule->op_devices |= GBAUDIO_DEVICE_OUT_SPEAKER;\n\t\tbreak;\n\tcase snd_soc_dapm_hp:\n\t\t*dw = gbaudio_widgets[w->type];\n\t\tmodule->op_devices |= (GBAUDIO_DEVICE_OUT_WIRED_HEADSET\n\t\t\t\t\t| GBAUDIO_DEVICE_OUT_WIRED_HEADPHONE);\n\t\tmodule->ip_devices |= GBAUDIO_DEVICE_IN_WIRED_HEADSET;\n\t\tbreak;\n\tcase snd_soc_dapm_mic:\n\t\t*dw = gbaudio_widgets[w->type];\n\t\tmodule->ip_devices |= GBAUDIO_DEVICE_IN_BUILTIN_MIC;\n\t\tbreak;\n\tcase snd_soc_dapm_output:\n\tcase snd_soc_dapm_input:\n\tcase snd_soc_dapm_switch:\n\tcase snd_soc_dapm_pga:\n\tcase snd_soc_dapm_mixer:\n\tcase snd_soc_dapm_mux:\n\t\t*dw = gbaudio_widgets[w->type];\n\t\tbreak;\n\tcase snd_soc_dapm_aif_in:\n\tcase snd_soc_dapm_aif_out:\n\t\t*dw = gbaudio_widgets[w->type];\n\t\tdw->sname = w->sname;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tdw->name = w->name;\n\n\tdev_dbg(module->dev, \"%s: widget of type %d created\\n\", dw->name,\n\t\tdw->id);\n\treturn 0;\nerror:\n\tlist_for_each_entry_safe(control, _control, &module->widget_ctl_list,\n\t\t\t\t list) {\n\t\tlist_del(&control->list);\n\t\tdevm_kfree(module->dev, control);\n\t}\n\treturn ret;\n}\n\nstatic int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,\n\t\t\t\t\t  struct gb_audio_control *controls)\n{\n\tint i, csize, ret;\n\tstruct snd_kcontrol_new *dapm_kctls;\n\tstruct gb_audio_control *curr;\n\tstruct gbaudio_control *control, *_control;\n\tsize_t size;\n\tchar temp_name[NAME_SIZE];\n\n\tsize = sizeof(struct snd_kcontrol_new) * module->num_controls;\n\tdapm_kctls = devm_kzalloc(module->dev, size, GFP_KERNEL);\n\tif (!dapm_kctls)\n\t\treturn -ENOMEM;\n\n\tcurr = controls;\n\tfor (i = 0; i < module->num_controls; i++) {\n\t\tret = gbaudio_tplg_create_kcontrol(module, &dapm_kctls[i],\n\t\t\t\t\t\t   curr);\n\t\tif (ret) {\n\t\t\tdev_err(module->dev, \"%s:%d type not supported\\n\",\n\t\t\t\tcurr->name, curr->iface);\n\t\t\tgoto error;\n\t\t}\n\t\tcontrol = devm_kzalloc(module->dev, sizeof(struct\n\t\t\t\t\t\t\t   gbaudio_control),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!control) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tcontrol->id = curr->id;\n\t\t \n\t\tstrscpy(temp_name, curr->name, sizeof(temp_name));\n\t\tsnprintf(curr->name, sizeof(curr->name), \"GB %d %s\", module->dev_id,\n\t\t\t temp_name);\n\t\tcontrol->name = curr->name;\n\t\tif (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED) {\n\t\t\tstruct gb_audio_enumerated *gbenum =\n\t\t\t\t&curr->info.value.enumerated;\n\n\t\t\tcsize = offsetof(struct gb_audio_control, info);\n\t\t\tcsize += offsetof(struct gb_audio_ctl_elem_info, value);\n\t\t\tcsize += offsetof(struct gb_audio_enumerated, names);\n\t\t\tcsize += le16_to_cpu(gbenum->names_length);\n\t\t\tcontrol->texts = (const char * const *)\n\t\t\t\tgb_generate_enum_strings(module, gbenum);\n\t\t\tif (!control->texts) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tcontrol->items = le32_to_cpu(gbenum->items);\n\t\t} else {\n\t\t\tcsize = sizeof(struct gb_audio_control);\n\t\t}\n\n\t\tlist_add(&control->list, &module->ctl_list);\n\t\tdev_dbg(module->dev, \"%d:%s created of type %d\\n\", curr->id,\n\t\t\tcurr->name, curr->info.type);\n\t\tcurr = (void *)curr + csize;\n\t}\n\tmodule->controls = dapm_kctls;\n\n\treturn 0;\nerror:\n\tlist_for_each_entry_safe(control, _control, &module->ctl_list,\n\t\t\t\t list) {\n\t\tlist_del(&control->list);\n\t\tdevm_kfree(module->dev, control);\n\t}\n\tdevm_kfree(module->dev, dapm_kctls);\n\treturn ret;\n}\n\nstatic int gbaudio_tplg_process_widgets(struct gbaudio_module_info *module,\n\t\t\t\t\tstruct gb_audio_widget *widgets)\n{\n\tint i, ret, w_size;\n\tstruct snd_soc_dapm_widget *dapm_widgets;\n\tstruct gb_audio_widget *curr;\n\tstruct gbaudio_widget *widget, *_widget;\n\tsize_t size;\n\n\tsize = sizeof(struct snd_soc_dapm_widget) * module->num_dapm_widgets;\n\tdapm_widgets = devm_kzalloc(module->dev, size, GFP_KERNEL);\n\tif (!dapm_widgets)\n\t\treturn -ENOMEM;\n\n\tcurr = widgets;\n\tfor (i = 0; i < module->num_dapm_widgets; i++) {\n\t\tret = gbaudio_tplg_create_widget(module, &dapm_widgets[i],\n\t\t\t\t\t\t curr, &w_size);\n\t\tif (ret) {\n\t\t\tdev_err(module->dev, \"%s:%d type not supported\\n\",\n\t\t\t\tcurr->name, curr->type);\n\t\t\tgoto error;\n\t\t}\n\t\twidget = devm_kzalloc(module->dev, sizeof(struct\n\t\t\t\t\t\t\t   gbaudio_widget),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!widget) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\twidget->id = curr->id;\n\t\twidget->name = curr->name;\n\t\tlist_add(&widget->list, &module->widget_list);\n\t\tcurr = (void *)curr + w_size;\n\t}\n\tmodule->dapm_widgets = dapm_widgets;\n\n\treturn 0;\n\nerror:\n\tlist_for_each_entry_safe(widget, _widget, &module->widget_list,\n\t\t\t\t list) {\n\t\tlist_del(&widget->list);\n\t\tdevm_kfree(module->dev, widget);\n\t}\n\tdevm_kfree(module->dev, dapm_widgets);\n\treturn ret;\n}\n\nstatic int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,\n\t\t\t\t       struct gb_audio_route *routes)\n{\n\tint i, ret;\n\tstruct snd_soc_dapm_route *dapm_routes;\n\tstruct gb_audio_route *curr;\n\tsize_t size;\n\n\tsize = sizeof(struct snd_soc_dapm_route) * module->num_dapm_routes;\n\tdapm_routes = devm_kzalloc(module->dev, size, GFP_KERNEL);\n\tif (!dapm_routes)\n\t\treturn -ENOMEM;\n\n\tmodule->dapm_routes = dapm_routes;\n\tcurr = routes;\n\n\tfor (i = 0; i < module->num_dapm_routes; i++) {\n\t\tdapm_routes->sink =\n\t\t\tgbaudio_map_widgetid(module, curr->destination_id);\n\t\tif (!dapm_routes->sink) {\n\t\t\tdev_err(module->dev, \"%d:%d:%d:%d - Invalid sink\\n\",\n\t\t\t\tcurr->source_id, curr->destination_id,\n\t\t\t\tcurr->control_id, curr->index);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tdapm_routes->source =\n\t\t\tgbaudio_map_widgetid(module, curr->source_id);\n\t\tif (!dapm_routes->source) {\n\t\t\tdev_err(module->dev, \"%d:%d:%d:%d - Invalid source\\n\",\n\t\t\t\tcurr->source_id, curr->destination_id,\n\t\t\t\tcurr->control_id, curr->index);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tdapm_routes->control =\n\t\t\tgbaudio_map_controlid(module,\n\t\t\t\t\t      curr->control_id,\n\t\t\t\t\t      curr->index);\n\t\tif ((curr->control_id !=  GBAUDIO_INVALID_ID) &&\n\t\t    !dapm_routes->control) {\n\t\t\tdev_err(module->dev, \"%d:%d:%d:%d - Invalid control\\n\",\n\t\t\t\tcurr->source_id, curr->destination_id,\n\t\t\t\tcurr->control_id, curr->index);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tdev_dbg(module->dev, \"Route {%s, %s, %s}\\n\", dapm_routes->sink,\n\t\t\t(dapm_routes->control) ? dapm_routes->control : \"NULL\",\n\t\t\tdapm_routes->source);\n\t\tdapm_routes++;\n\t\tcurr++;\n\t}\n\n\treturn 0;\n\nerror:\n\tdevm_kfree(module->dev, module->dapm_routes);\n\treturn ret;\n}\n\nstatic int gbaudio_tplg_process_header(struct gbaudio_module_info *module,\n\t\t\t\t       struct gb_audio_topology *tplg_data)\n{\n\t \n\tmodule->num_controls = tplg_data->num_controls;\n\tmodule->num_dapm_widgets = tplg_data->num_widgets;\n\tmodule->num_dapm_routes = tplg_data->num_routes;\n\n\t \n\tmodule->dai_offset = (unsigned long)&tplg_data->data;\n\tmodule->control_offset = module->dai_offset +\n\t\t\t\t\tle32_to_cpu(tplg_data->size_dais);\n\tmodule->widget_offset = module->control_offset +\n\t\t\t\t\tle32_to_cpu(tplg_data->size_controls);\n\tmodule->route_offset = module->widget_offset +\n\t\t\t\t\tle32_to_cpu(tplg_data->size_widgets);\n\n\tdev_dbg(module->dev, \"DAI offset is 0x%lx\\n\", module->dai_offset);\n\tdev_dbg(module->dev, \"control offset is %lx\\n\",\n\t\tmodule->control_offset);\n\tdev_dbg(module->dev, \"widget offset is %lx\\n\", module->widget_offset);\n\tdev_dbg(module->dev, \"route offset is %lx\\n\", module->route_offset);\n\n\treturn 0;\n}\n\nint gbaudio_tplg_parse_data(struct gbaudio_module_info *module,\n\t\t\t    struct gb_audio_topology *tplg_data)\n{\n\tint ret;\n\tstruct gb_audio_control *controls;\n\tstruct gb_audio_widget *widgets;\n\tstruct gb_audio_route *routes;\n\tunsigned int jack_type;\n\n\tif (!tplg_data)\n\t\treturn -EINVAL;\n\n\tret = gbaudio_tplg_process_header(module, tplg_data);\n\tif (ret) {\n\t\tdev_err(module->dev, \"%d: Error in parsing topology header\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tcontrols = (struct gb_audio_control *)module->control_offset;\n\tret = gbaudio_tplg_process_kcontrols(module, controls);\n\tif (ret) {\n\t\tdev_err(module->dev,\n\t\t\t\"%d: Error in parsing controls data\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_dbg(module->dev, \"Control parsing finished\\n\");\n\n\t \n\twidgets = (struct gb_audio_widget *)module->widget_offset;\n\tret = gbaudio_tplg_process_widgets(module, widgets);\n\tif (ret) {\n\t\tdev_err(module->dev,\n\t\t\t\"%d: Error in parsing widgets data\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_dbg(module->dev, \"Widget parsing finished\\n\");\n\n\t \n\troutes = (struct gb_audio_route *)module->route_offset;\n\tret = gbaudio_tplg_process_routes(module, routes);\n\tif (ret) {\n\t\tdev_err(module->dev,\n\t\t\t\"%d: Error in parsing routes data\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_dbg(module->dev, \"Route parsing finished\\n\");\n\n\t \n\tjack_type = le32_to_cpu(tplg_data->jack_type);\n\tif (jack_type) {\n\t\tmodule->jack_mask = jack_type & GBCODEC_JACK_MASK;\n\t\tmodule->button_mask = jack_type & GBCODEC_JACK_BUTTON_MASK;\n\t}\n\n\treturn ret;\n}\n\nvoid gbaudio_tplg_release(struct gbaudio_module_info *module)\n{\n\tstruct gbaudio_control *control, *_control;\n\tstruct gbaudio_widget *widget, *_widget;\n\n\tif (!module->topology)\n\t\treturn;\n\n\t \n\tlist_for_each_entry_safe(control, _control, &module->ctl_list,\n\t\t\t\t list) {\n\t\tlist_del(&control->list);\n\t\tdevm_kfree(module->dev, control);\n\t}\n\tif (module->controls)\n\t\tdevm_kfree(module->dev, module->controls);\n\n\t \n\tlist_for_each_entry_safe(control, _control, &module->widget_ctl_list,\n\t\t\t\t list) {\n\t\tlist_del(&control->list);\n\t\tdevm_kfree(module->dev, control);\n\t}\n\n\t \n\tlist_for_each_entry_safe(widget, _widget, &module->widget_list,\n\t\t\t\t list) {\n\t\tlist_del(&widget->list);\n\t\tdevm_kfree(module->dev, widget);\n\t}\n\tif (module->dapm_widgets)\n\t\tdevm_kfree(module->dev, module->dapm_widgets);\n\n\t \n\tif (module->dapm_routes)\n\t\tdevm_kfree(module->dev, module->dapm_routes);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}