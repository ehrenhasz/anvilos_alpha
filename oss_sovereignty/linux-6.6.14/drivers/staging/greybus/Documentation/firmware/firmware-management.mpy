{
  "module_name": "firmware-management",
  "hash_id": "bf5273432cde42cbcdeb0d336abdc706ee468293c66020ee81054709fcf29e12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/Documentation/firmware/firmware-management",
  "human_readable_source": "\nFirmware Management\n-------------------\n Copyright 2016 Google Inc.\n Copyright 2016 Linaro Ltd.\n\nInterface-Manifest\n------------------\n\nAll firmware packages on the Modules or Interfaces are managed by a special\nFirmware Management Protocol. To support Firmware Management by the AP, the\nInterface Manifest shall at least contain the Firmware Management Bundle and a\nFirmware Management Protocol CPort within it.\n\nThe bundle may contain additional CPorts based on the extra functionality\nrequired to manage firmware packages.\n\nFor example, this is how the Firmware Management part of the Interface Manifest\nmay look like:\n\n\t; Firmware Management Bundle (Bundle 1):\n\t[bundle-descriptor 1]\n\tclass = 0x16\n\n\t; (Mandatory) Firmware Management Protocol on CPort 1\n\t[cport-descriptor 2]\n\tbundle = 1\n\tprotocol = 0x18\n\n\t; (Optional) Firmware Download Protocol on CPort 2\n\t[cport-descriptor 1]\n\tbundle = 1\n\tprotocol = 0x17\n\n\t; (Optional) SPI protocol on CPort 3\n\t[cport-descriptor 3]\n\tbundle = 1\n\tprotocol = 0x0b\n\n\t; (Optional) Component Authentication Protocol (CAP) on CPort 4\n\t[cport-descriptor 4]\n\tbundle = 1\n\tprotocol = 0x19\n\n\nSysfs Interfaces - Firmware Management\n--------------------------------------\n\nThe Firmware Management Protocol interacts with Userspace using the character\ndevice interface. The character device will be present in /dev/ directory\nand will be named gb-fw-mgmt-<N>. The number <N> is assigned at runtime.\n\nIdentifying the Character Device\n================================\n\nThere can be multiple devices present in /dev/ directory with name gb-fw-mgmt-N\nand user first needs to identify the character device used for\nfirmware-management for a particular interface.\n\nThe Firmware Management core creates a device of class 'gb_fw_mgmt', which shall\nbe used by the user to identify the right character device for it. The class\ndevice is created within the Bundle directory for a particular Interface.\n\nFor example this is how the class-device can be present:\n\n/sys/bus/greybus/devices/1-1/1-1.1/1-1.1.1/gb_fw_mgmt/gb-fw-mgmt-0\n\nThe last name in this path: gb-fw-mgmt-0 is precisely the name of the char\ndevice and so the device in this case will be:\n\n/dev/gb-fw-mgmt-0.\n\nOperations on the Char device\n=============================\n\nThe Character device (gb-fw-mgmt-0 in example) can be opened by the userspace\napplication and it can perform various 'ioctl' operations on the device. The\ndevice doesn't support any read/write operations.\n\nFollowing are the IOCTLs and their data structures available to the user:\n\n/* IOCTL support */\n#define GB_FW_LOAD_METHOD_UNIPRO\t\t0x01\n#define GB_FW_LOAD_METHOD_INTERNAL\t\t0x02\n\n#define GB_FW_LOAD_STATUS_FAILED\t\t0x00\n#define GB_FW_LOAD_STATUS_UNVALIDATED\t\t0x01\n#define GB_FW_LOAD_STATUS_VALIDATED\t\t0x02\n#define GB_FW_LOAD_STATUS_VALIDATION_FAILED\t0x03\n\n#define GB_FW_BACKEND_FW_STATUS_SUCCESS\t\t0x01\n#define GB_FW_BACKEND_FW_STATUS_FAIL_FIND\t0x02\n#define GB_FW_BACKEND_FW_STATUS_FAIL_FETCH\t0x03\n#define GB_FW_BACKEND_FW_STATUS_FAIL_WRITE\t0x04\n#define GB_FW_BACKEND_FW_STATUS_INT\t\t0x05\n#define GB_FW_BACKEND_FW_STATUS_RETRY\t\t0x06\n#define GB_FW_BACKEND_FW_STATUS_NOT_SUPPORTED\t0x07\n\n#define GB_FW_BACKEND_VERSION_STATUS_SUCCESS\t\t0x01\n#define GB_FW_BACKEND_VERSION_STATUS_NOT_AVAILABLE\t0x02\n#define GB_FW_BACKEND_VERSION_STATUS_NOT_SUPPORTED\t0x03\n#define GB_FW_BACKEND_VERSION_STATUS_RETRY\t\t0x04\n#define GB_FW_BACKEND_VERSION_STATUS_FAIL_INT\t\t0x05\n\n\nstruct fw_mgmt_ioc_get_intf_version {\n\t__u8 firmware_tag[GB_FIRMWARE_U_TAG_MAX_SIZE];\n\t__u16 major;\n\t__u16 minor;\n} __attribute__ ((__packed__));\n\nstruct fw_mgmt_ioc_get_backend_version {\n\t__u8 firmware_tag[GB_FIRMWARE_U_TAG_MAX_SIZE];\n\t__u16 major;\n\t__u16 minor;\n\t__u8 status;\n} __attribute__ ((__packed__));\n\nstruct fw_mgmt_ioc_intf_load_and_validate {\n\t__u8\t\t\tfirmware_tag[GB_FIRMWARE_TAG_MAX_SIZE];\n\t__u8\t\t\tload_method;\n\t__u8\t\t\tstatus;\n\t__u16\t\t\tmajor;\n\t__u16\t\t\tminor;\n} __packed;\n\nstruct fw_mgmt_ioc_backend_fw_update {\n\t__u8\t\t\tfirmware_tag[GB_FIRMWARE_TAG_MAX_SIZE];\n\t__u8\t\t\tstatus;\n} __packed;\n\n#define FW_MGMT_IOCTL_BASE\t\t\t'S'\n#define FW_MGMT_IOC_GET_INTF_FW\t\t\t_IOR(FW_MGMT_IOCTL_BASE, 0, struct fw_mgmt_ioc_get_intf_version)\n#define FW_MGMT_IOC_GET_BACKEND_FW\t\t_IOWR(FW_MGMT_IOCTL_BASE, 1, struct fw_mgmt_ioc_get_backend_version)\n#define FW_MGMT_IOC_INTF_LOAD_AND_VALIDATE\t_IOWR(FW_MGMT_IOCTL_BASE, 2, struct fw_mgmt_ioc_intf_load_and_validate)\n#define FW_MGMT_IOC_INTF_BACKEND_FW_UPDATE\t_IOWR(FW_MGMT_IOCTL_BASE, 3, struct fw_mgmt_ioc_backend_fw_update)\n#define FW_MGMT_IOC_SET_TIMEOUT_MS\t\t_IOW(FW_MGMT_IOCTL_BASE, 4, unsigned int)\n#define FW_MGMT_IOC_MODE_SWITCH\t\t\t_IO(FW_MGMT_IOCTL_BASE, 5)\n\n1. FW_MGMT_IOC_GET_INTF_FW:\n\n   This ioctl shall be used by the user to get the version and firmware-tag of\n   the currently running Interface Firmware. All the fields of the 'struct\n   fw_mgmt_ioc_get_fw' are filled by the kernel.\n\n2. FW_MGMT_IOC_GET_BACKEND_FW:\n\n   This ioctl shall be used by the user to get the version of a currently\n   running Backend Interface Firmware identified by a firmware-tag. The user is\n   required to fill the 'firmware_tag' field of the 'struct fw_mgmt_ioc_get_fw'\n   in this case. The 'major' and 'minor' fields are set by the kernel in\n   response.\n\n3. FW_MGMT_IOC_INTF_LOAD_AND_VALIDATE:\n\n   This ioctl shall be used by the user to load an Interface Firmware package on\n   an Interface. The user needs to fill the 'firmware_tag' and 'load_method'\n   fields of the 'struct fw_mgmt_ioc_intf_load_and_validate'. The 'status',\n   'major' and 'minor' fields are set by the kernel in response.\n\n4. FW_MGMT_IOC_INTF_BACKEND_FW_UPDATE:\n\n   This ioctl shall be used by the user to request an Interface to update a\n   Backend Interface Firmware.  The user is required to fill the 'firmware_tag'\n   field of the 'struct fw_mgmt_ioc_get_fw' in this case. The 'status' field is\n   set by the kernel in response.\n\n5. FW_MGMT_IOC_SET_TIMEOUT_MS:\n\n   This ioctl shall be used by the user to increase the timeout interval within\n   which the firmware must get loaded by the Module. The default timeout is 1\n   second. The user needs to pass the timeout in milliseconds.\n\n6. FW_MGMT_IOC_MODE_SWITCH:\n\n   This ioctl shall be used by the user to mode-switch the module to the\n   previously loaded interface firmware. If the interface firmware isn't loaded\n   previously, or if another unsuccessful FW_MGMT_IOC_INTF_LOAD_AND_VALIDATE\n   operation is started after loading interface firmware, then the firmware core\n   wouldn't allow mode-switch.\n\n\nSysfs Interfaces - Authentication\n---------------------------------\n\nThe Component Authentication Protocol interacts with Userspace using the\ncharacter device interface. The character device will be present in /dev/\ndirectory and will be named gb-authenticate-<N>. The number <N> is assigned at\nruntime.\n\nIdentifying the Character Device\n================================\n\nThere can be multiple devices present in /dev/ directory with name\ngb-authenticate-N and user first needs to identify the character device used for\nauthentication a of particular interface.\n\nThe Authentication core creates a device of class 'gb_authenticate', which shall\nbe used by the user to identify the right character device for it. The class\ndevice is created within the Bundle directory for a particular Interface.\n\nFor example this is how the class-device can be present:\n\n/sys/bus/greybus/devices/1-1/1-1.1/1-1.1.1/gb_authenticate/gb-authenticate-0\n\nThe last name in this path: gb-authenticate-0 is precisely the name of the char\ndevice and so the device in this case will be:\n\n/dev/gb-authenticate-0.\n\nOperations on the Char device\n=============================\n\nThe Character device (/dev/gb-authenticate-0 in above example) can be opened by\nthe userspace application and it can perform various 'ioctl' operations on the\ndevice. The device doesn't support any read/write operations.\n\nFollowing are the IOCTLs and their data structures available to the user:\n\n#define CAP_CERTIFICATE_MAX_SIZE\t1600\n#define CAP_SIGNATURE_MAX_SIZE\t\t320\n\n/* Certificate class types */\n#define CAP_CERT_IMS_EAPC\t\t0x00000001\n#define CAP_CERT_IMS_EASC\t\t0x00000002\n#define CAP_CERT_IMS_EARC\t\t0x00000003\n#define CAP_CERT_IMS_IAPC\t\t0x00000004\n#define CAP_CERT_IMS_IASC\t\t0x00000005\n#define CAP_CERT_IMS_IARC\t\t0x00000006\n\n/* IMS Certificate response result codes */\n#define CAP_IMS_RESULT_CERT_FOUND\t0x00\n#define CAP_IMS_RESULT_CERT_CLASS_INVAL\t0x01\n#define CAP_IMS_RESULT_CERT_CORRUPT\t0x02\n#define CAP_IMS_RESULT_CERT_NOT_FOUND\t0x03\n\n/* Authentication types */\n#define CAP_AUTH_IMS_PRI\t\t0x00000001\n#define CAP_AUTH_IMS_SEC\t\t0x00000002\n#define CAP_AUTH_IMS_RSA\t\t0x00000003\n\n/* Authenticate response result codes */\n#define CAP_AUTH_RESULT_CR_SUCCESS\t0x00\n#define CAP_AUTH_RESULT_CR_BAD_TYPE\t0x01\n#define CAP_AUTH_RESULT_CR_WRONG_EP\t0x02\n#define CAP_AUTH_RESULT_CR_NO_KEY\t0x03\n#define CAP_AUTH_RESULT_CR_SIG_FAIL\t0x04\n\n\n/* IOCTL support */\nstruct cap_ioc_get_endpoint_uid {\n\t__u8\t\t\tuid[8];\n} __attribute__ ((__packed__));\n\nstruct cap_ioc_get_ims_certificate {\n\t__u32\t\t\tcertificate_class;\n\t__u32\t\t\tcertificate_id;\n\n\t__u8\t\t\tresult_code;\n\t__u32\t\t\tcert_size;\n\t__u8\t\t\tcertificate[CAP_CERTIFICATE_MAX_SIZE];\n} __attribute__ ((__packed__));\n\nstruct cap_ioc_authenticate {\n\t__u32\t\t\tauth_type;\n\t__u8\t\t\tuid[8];\n\t__u8\t\t\tchallenge[32];\n\n\t__u8\t\t\tresult_code;\n\t__u8\t\t\tresponse[64];\n\t__u32\t\t\tsignature_size;\n\t__u8\t\t\tsignature[CAP_SIGNATURE_MAX_SIZE];\n} __attribute__ ((__packed__));\n\n#define CAP_IOCTL_BASE\t\t\t'C'\n#define CAP_IOC_GET_ENDPOINT_UID\t_IOR(CAP_IOCTL_BASE, 0, struct cap_ioc_get_endpoint_uid)\n#define CAP_IOC_GET_IMS_CERTIFICATE\t_IOWR(CAP_IOCTL_BASE, 1, struct cap_ioc_get_ims_certificate)\n#define CAP_IOC_AUTHENTICATE\t\t_IOWR(CAP_IOCTL_BASE, 2, struct cap_ioc_authenticate)\n\n\n1. CAP_IOC_GET_ENDPOINT_UID:\n\n   This ioctl shall be used by the user to get the endpoint UID associated with\n   the Interface.  All the fields of the 'struct cap_ioc_get_endpoint_uid' are\n   filled by the kernel.\n\n2. CAP_IOC_GET_IMS_CERTIFICATE:\n\n   This ioctl shall be used by the user to retrieve one of the available\n   cryptographic certificates held by the Interface for use in Component\n   Authentication. The user is required to fill the 'certificate_class' and\n   'certificate_id' field of the 'struct cap_ioc_get_ims_certificate' in this\n   case. The other fields will be set by the kernel in response. The first\n   'cert_size' bytes of the 'certificate' shall be read by the user and others\n   must be discarded.\n\n3. CAP_IOC_AUTHENTICATE:\n\n   This ioctl shall be used by the user to authenticate the Module attached to\n   an Interface.  The user needs to fill the 'auth_type', 'uid', and 'challenge'\n   fields of the 'struct cap_ioc_authenticate'. The other fields will be set by\n   the kernel in response.  The first 'signature_size' bytes of the 'signature'\n   shall be read by the user and others must be discarded.\n\n\nSysfs Interfaces - Firmware Download\n------------------------------------\n\nThe Firmware Download Protocol uses the existing Linux Kernel's Firmware class\nand the interface provided to userspace are described in:\nDocumentation/firmware_class/.\n\n\nSysfs Interfaces - SPI Flash\n----------------------------\n\nThe SPI flash is exposed in userspace as a MTD device and is created\nwithin the Bundle directory. For example, this is how the path may look like:\n\n$ ls /sys/bus/greybus/devices/1-1/1-1.1/1-1.1.1/spi_master/spi32766/spi32766.0/mtd\nmtd0    mtd0ro\n\n\nSample Applications\n-------------------\n\nThe current directory also provides a firmware.c test application, which can be\nreferenced while developing userspace application to talk to firmware-management\nprotocol.\n\nThe current directory also provides a authenticate.c test application, which can\nbe referenced while developing userspace application to talk to\ncomponent authentication protocol.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}