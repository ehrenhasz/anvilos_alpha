{
  "module_name": "arche-apb-ctrl.c",
  "hash_id": "acb65693141115900b975b426432e89efebff0b414d5d888443bff14d6f76cee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/arche-apb-ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/of_irq.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spinlock.h>\n#include \"arche_platform.h\"\n\nstatic void apb_bootret_deassert(struct device *dev);\n\nstruct arche_apb_ctrl_drvdata {\n\t \n\tstruct gpio_desc *resetn;\n\tstruct gpio_desc *boot_ret;\n\tstruct gpio_desc *pwroff;\n\tstruct gpio_desc *wake_in;\n\tstruct gpio_desc *wake_out;\n\tstruct gpio_desc *pwrdn;\n\n\tenum arche_platform_state state;\n\tbool init_disabled;\n\n\tstruct regulator *vcore;\n\tstruct regulator *vio;\n\n\tstruct gpio_desc *clk_en;\n\tstruct clk *clk;\n\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pin_default;\n\n\t \n\tstruct gpio_desc *spi_en;\n\tbool spi_en_polarity_high;\n};\n\n \nstatic inline void deassert_reset(struct gpio_desc *gpio)\n{\n\tgpiod_set_raw_value(gpio, 1);\n}\n\nstatic inline void assert_reset(struct gpio_desc *gpio)\n{\n\tgpiod_set_raw_value(gpio, 0);\n}\n\n \nstatic int coldboot_seq(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);\n\tint ret;\n\n\tif (apb->init_disabled ||\n\t    apb->state == ARCHE_PLATFORM_STATE_ACTIVE)\n\t\treturn 0;\n\n\t \n\tassert_reset(apb->resetn);\n\n\tif (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING && apb->spi_en)\n\t\tdevm_gpiod_put(dev, apb->spi_en);\n\n\t \n\tif (!IS_ERR(apb->vcore)) {\n\t\tret = regulator_enable(apb->vcore);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable core regulator\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!IS_ERR(apb->vio)) {\n\t\tret = regulator_enable(apb->vio);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable IO regulator\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tapb_bootret_deassert(dev);\n\n\t \n\tif (apb->clk_en)\n\t\tgpiod_set_value(apb->clk_en, 1);\n\n\tusleep_range(100, 200);\n\n\t \n\tdeassert_reset(apb->resetn);\n\n\tapb->state = ARCHE_PLATFORM_STATE_ACTIVE;\n\n\treturn 0;\n}\n\nstatic int fw_flashing_seq(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);\n\tint ret;\n\n\tif (apb->init_disabled ||\n\t    apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING)\n\t\treturn 0;\n\n\tret = regulator_enable(apb->vcore);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable core regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_enable(apb->vio);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable IO regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tif (apb->spi_en) {\n\t\tunsigned long flags;\n\n\t\tif (apb->spi_en_polarity_high)\n\t\t\tflags = GPIOD_OUT_HIGH;\n\t\telse\n\t\t\tflags = GPIOD_OUT_LOW;\n\n\t\tapb->spi_en = devm_gpiod_get(dev, \"spi-en\", flags);\n\t\tif (IS_ERR(apb->spi_en)) {\n\t\t\tret = PTR_ERR(apb->spi_en);\n\t\t\tdev_err(dev, \"Failed requesting SPI bus en GPIO: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tassert_reset(apb->resetn);\n\tapb->state = ARCHE_PLATFORM_STATE_FW_FLASHING;\n\n\treturn 0;\n}\n\nstatic int standby_boot_seq(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);\n\n\tif (apb->init_disabled)\n\t\treturn 0;\n\n\t \n\tif (apb->state == ARCHE_PLATFORM_STATE_STANDBY ||\n\t    apb->state == ARCHE_PLATFORM_STATE_OFF)\n\t\treturn 0;\n\n\tif (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING && apb->spi_en)\n\t\tdevm_gpiod_put(dev, apb->spi_en);\n\n\t \n\n\t \n\tapb->state = ARCHE_PLATFORM_STATE_STANDBY;\n\treturn 0;\n}\n\nstatic void poweroff_seq(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);\n\n\tif (apb->init_disabled || apb->state == ARCHE_PLATFORM_STATE_OFF)\n\t\treturn;\n\n\tif (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING && apb->spi_en)\n\t\tdevm_gpiod_put(dev, apb->spi_en);\n\n\t \n\tif (apb->clk_en)\n\t\tgpiod_set_value(apb->clk_en, 0);\n\n\tif (!IS_ERR(apb->vcore) && regulator_is_enabled(apb->vcore) > 0)\n\t\tregulator_disable(apb->vcore);\n\n\tif (!IS_ERR(apb->vio) && regulator_is_enabled(apb->vio) > 0)\n\t\tregulator_disable(apb->vio);\n\n\t \n\tassert_reset(apb->resetn);\n\tapb->state = ARCHE_PLATFORM_STATE_OFF;\n\n\t \n}\n\nstatic void apb_bootret_deassert(struct device *dev)\n{\n\tstruct arche_apb_ctrl_drvdata *apb = dev_get_drvdata(dev);\n\n\tgpiod_set_value(apb->boot_ret, 0);\n}\n\nint apb_ctrl_coldboot(struct device *dev)\n{\n\treturn coldboot_seq(to_platform_device(dev));\n}\n\nint apb_ctrl_fw_flashing(struct device *dev)\n{\n\treturn fw_flashing_seq(to_platform_device(dev));\n}\n\nint apb_ctrl_standby_boot(struct device *dev)\n{\n\treturn standby_boot_seq(to_platform_device(dev));\n}\n\nvoid apb_ctrl_poweroff(struct device *dev)\n{\n\tpoweroff_seq(to_platform_device(dev));\n}\n\nstatic ssize_t state_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);\n\tint ret = 0;\n\tbool is_disabled;\n\n\tif (sysfs_streq(buf, \"off\")) {\n\t\tif (apb->state == ARCHE_PLATFORM_STATE_OFF)\n\t\t\treturn count;\n\n\t\tpoweroff_seq(pdev);\n\t} else if (sysfs_streq(buf, \"active\")) {\n\t\tif (apb->state == ARCHE_PLATFORM_STATE_ACTIVE)\n\t\t\treturn count;\n\n\t\tpoweroff_seq(pdev);\n\t\tis_disabled = apb->init_disabled;\n\t\tapb->init_disabled = false;\n\t\tret = coldboot_seq(pdev);\n\t\tif (ret)\n\t\t\tapb->init_disabled = is_disabled;\n\t} else if (sysfs_streq(buf, \"standby\")) {\n\t\tif (apb->state == ARCHE_PLATFORM_STATE_STANDBY)\n\t\t\treturn count;\n\n\t\tret = standby_boot_seq(pdev);\n\t} else if (sysfs_streq(buf, \"fw_flashing\")) {\n\t\tif (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING)\n\t\t\treturn count;\n\n\t\t \n\t\tpoweroff_seq(pdev);\n\t\tret = fw_flashing_seq(pdev);\n\t} else {\n\t\tdev_err(dev, \"unknown state\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t state_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct arche_apb_ctrl_drvdata *apb = dev_get_drvdata(dev);\n\n\tswitch (apb->state) {\n\tcase ARCHE_PLATFORM_STATE_OFF:\n\t\treturn sprintf(buf, \"off%s\\n\",\n\t\t\t\tapb->init_disabled ? \",disabled\" : \"\");\n\tcase ARCHE_PLATFORM_STATE_ACTIVE:\n\t\treturn sprintf(buf, \"active\\n\");\n\tcase ARCHE_PLATFORM_STATE_STANDBY:\n\t\treturn sprintf(buf, \"standby\\n\");\n\tcase ARCHE_PLATFORM_STATE_FW_FLASHING:\n\t\treturn sprintf(buf, \"fw_flashing\\n\");\n\tdefault:\n\t\treturn sprintf(buf, \"unknown state\\n\");\n\t}\n}\n\nstatic DEVICE_ATTR_RW(state);\n\nstatic int apb_ctrl_get_devtree_data(struct platform_device *pdev,\n\t\t\t\t     struct arche_apb_ctrl_drvdata *apb)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tapb->resetn = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(apb->resetn)) {\n\t\tret = PTR_ERR(apb->resetn);\n\t\tdev_err(dev, \"Failed requesting reset GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tapb->boot_ret = devm_gpiod_get(dev, \"boot-ret\", GPIOD_OUT_LOW);\n\tif (IS_ERR(apb->boot_ret)) {\n\t\tret = PTR_ERR(apb->boot_ret);\n\t\tdev_err(dev, \"Failed requesting bootret GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tapb->pwroff = devm_gpiod_get_optional(dev, \"pwr-off\", GPIOD_IN);\n\tif (IS_ERR(apb->pwroff)) {\n\t\tret = PTR_ERR(apb->pwroff);\n\t\tdev_err(dev, \"Failed requesting pwroff_n GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tapb->clk_en = devm_gpiod_get_optional(dev, \"clock-en\", GPIOD_OUT_LOW);\n\tif (IS_ERR(apb->clk_en)) {\n\t\tret = PTR_ERR(apb->clk_en);\n\t\tdev_err(dev, \"Failed requesting APB clock en GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tapb->pwrdn = devm_gpiod_get(dev, \"pwr-down\", GPIOD_OUT_LOW);\n\tif (IS_ERR(apb->pwrdn)) {\n\t\tret = PTR_ERR(apb->pwrdn);\n\t\tdev_warn(dev, \"Failed requesting power down GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tapb->vcore = devm_regulator_get(dev, \"vcore\");\n\tif (IS_ERR(apb->vcore))\n\t\tdev_warn(dev, \"no core regulator found\\n\");\n\n\tapb->vio = devm_regulator_get(dev, \"vio\");\n\tif (IS_ERR(apb->vio))\n\t\tdev_warn(dev, \"no IO regulator found\\n\");\n\n\tapb->pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (IS_ERR(apb->pinctrl)) {\n\t\tdev_err(&pdev->dev, \"could not get pinctrl handle\\n\");\n\t\treturn PTR_ERR(apb->pinctrl);\n\t}\n\tapb->pin_default = pinctrl_lookup_state(apb->pinctrl, \"default\");\n\tif (IS_ERR(apb->pin_default)) {\n\t\tdev_err(&pdev->dev, \"could not get default pin state\\n\");\n\t\treturn PTR_ERR(apb->pin_default);\n\t}\n\n\t \n\tif (of_property_read_bool(pdev->dev.of_node, \"gb,spi-en-active-high\"))\n\t\tapb->spi_en_polarity_high = true;\n\n\treturn 0;\n}\n\nstatic int arche_apb_ctrl_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct arche_apb_ctrl_drvdata *apb;\n\tstruct device *dev = &pdev->dev;\n\n\tapb = devm_kzalloc(&pdev->dev, sizeof(*apb), GFP_KERNEL);\n\tif (!apb)\n\t\treturn -ENOMEM;\n\n\tret = apb_ctrl_get_devtree_data(pdev, apb);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get apb devicetree data %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tapb->state = ARCHE_PLATFORM_STATE_OFF;\n\t \n\tif (of_property_read_bool(pdev->dev.of_node, \"arche,init-disable\"))\n\t\tapb->init_disabled = true;\n\n\tplatform_set_drvdata(pdev, apb);\n\n\t \n\tret = device_create_file(dev, &dev_attr_state);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to create state file in sysfs\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"Device registered successfully\\n\");\n\treturn 0;\n}\n\nstatic void arche_apb_ctrl_remove(struct platform_device *pdev)\n{\n\tdevice_remove_file(&pdev->dev, &dev_attr_state);\n\tpoweroff_seq(pdev);\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic int __maybe_unused arche_apb_ctrl_suspend(struct device *dev)\n{\n\t \n\treturn 0;\n}\n\nstatic int __maybe_unused arche_apb_ctrl_resume(struct device *dev)\n{\n\t \n\treturn 0;\n}\n\nstatic void arche_apb_ctrl_shutdown(struct platform_device *pdev)\n{\n\tapb_ctrl_poweroff(&pdev->dev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(arche_apb_ctrl_pm_ops, arche_apb_ctrl_suspend,\n\t\t\t arche_apb_ctrl_resume);\n\nstatic const struct of_device_id arche_apb_ctrl_of_match[] = {\n\t{ .compatible = \"usbffff,2\", },\n\t{ },\n};\n\nstatic struct platform_driver arche_apb_ctrl_device_driver = {\n\t.probe\t\t= arche_apb_ctrl_probe,\n\t.remove_new\t= arche_apb_ctrl_remove,\n\t.shutdown\t= arche_apb_ctrl_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"arche-apb-ctrl\",\n\t\t.pm\t= &arche_apb_ctrl_pm_ops,\n\t\t.of_match_table = arche_apb_ctrl_of_match,\n\t}\n};\n\nint __init arche_apb_init(void)\n{\n\treturn platform_driver_register(&arche_apb_ctrl_device_driver);\n}\n\nvoid __exit arche_apb_exit(void)\n{\n\tplatform_driver_unregister(&arche_apb_ctrl_device_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}