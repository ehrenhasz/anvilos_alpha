{
  "module_name": "loopback.c",
  "hash_id": "094ac6563682e327df38d02ed24158c0b42fd44959cfac09ef718fb8fc6e581e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/loopback.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/sizes.h>\n#include <linux/cdev.h>\n#include <linux/fs.h>\n#include <linux/kfifo.h>\n#include <linux/debugfs.h>\n#include <linux/list_sort.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/atomic.h>\n#include <linux/pm_runtime.h>\n#include <linux/greybus.h>\n#include <asm/div64.h>\n\n#define NSEC_PER_DAY 86400000000000ULL\n\nstruct gb_loopback_stats {\n\tu32 min;\n\tu32 max;\n\tu64 sum;\n\tu32 count;\n};\n\nstruct gb_loopback_device {\n\tstruct dentry *root;\n\tu32 count;\n\tsize_t size_max;\n\n\t \n\tspinlock_t lock;\n\twait_queue_head_t wq;\n};\n\nstatic struct gb_loopback_device gb_dev;\n\nstruct gb_loopback_async_operation {\n\tstruct gb_loopback *gb;\n\tstruct gb_operation *operation;\n\tktime_t ts;\n\tint (*completion)(struct gb_loopback_async_operation *op_async);\n};\n\nstruct gb_loopback {\n\tstruct gb_connection *connection;\n\n\tstruct dentry *file;\n\tstruct kfifo kfifo_lat;\n\tstruct mutex mutex;\n\tstruct task_struct *task;\n\tstruct device *dev;\n\twait_queue_head_t wq;\n\twait_queue_head_t wq_completion;\n\tatomic_t outstanding_operations;\n\n\t \n\tktime_t ts;\n\tstruct gb_loopback_stats latency;\n\tstruct gb_loopback_stats throughput;\n\tstruct gb_loopback_stats requests_per_second;\n\tstruct gb_loopback_stats apbridge_unipro_latency;\n\tstruct gb_loopback_stats gbphy_firmware_latency;\n\n\tint type;\n\tint async;\n\tint id;\n\tu32 size;\n\tu32 iteration_max;\n\tu32 iteration_count;\n\tint us_wait;\n\tu32 error;\n\tu32 requests_completed;\n\tu32 requests_timedout;\n\tu32 timeout;\n\tu32 jiffy_timeout;\n\tu32 timeout_min;\n\tu32 timeout_max;\n\tu32 outstanding_operations_max;\n\tu64 elapsed_nsecs;\n\tu32 apbridge_latency_ts;\n\tu32 gbphy_latency_ts;\n\n\tu32 send_count;\n};\n\nstatic struct class loopback_class = {\n\t.name\t\t= \"gb_loopback\",\n};\nstatic DEFINE_IDA(loopback_ida);\n\n \n#define GB_LOOPBACK_TIMEOUT_MIN\t\t\t\t1\n#define GB_LOOPBACK_TIMEOUT_MAX\t\t\t\t10000\n\n#define GB_LOOPBACK_FIFO_DEFAULT\t\t\t8192\n\nstatic unsigned int kfifo_depth = GB_LOOPBACK_FIFO_DEFAULT;\nmodule_param(kfifo_depth, uint, 0444);\n\n \n#define MAX_PACKET_SIZE (PAGE_SIZE * 2)\n\n#define GB_LOOPBACK_US_WAIT_MAX\t\t\t\t1000000\n\n \n#define gb_loopback_ro_attr(field)\t\t\t\t\\\nstatic ssize_t field##_show(struct device *dev,\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gb_loopback *gb = dev_get_drvdata(dev);\t\t\t\\\n\treturn sprintf(buf, \"%u\\n\", gb->field);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(field)\n\n#define gb_loopback_ro_stats_attr(name, field, type)\t\t\\\nstatic ssize_t name##_##field##_show(struct device *dev,\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gb_loopback *gb = dev_get_drvdata(dev);\t\t\t\\\n\t \t\t\\\n\tif (!gb->requests_completed)\t\t\t\t\t\\\n\t\treturn sprintf(buf, \"0\\n\");\t\t\t\t\\\n\treturn sprintf(buf, \"%\" #type \"\\n\", gb->name.field);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name##_##field)\n\n#define gb_loopback_ro_avg_attr(name)\t\t\t\\\nstatic ssize_t name##_avg_show(struct device *dev,\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gb_loopback_stats *stats;\t\t\t\t\\\n\tstruct gb_loopback *gb;\t\t\t\t\t\t\\\n\tu64 avg, rem;\t\t\t\t\t\t\t\\\n\tu32 count;\t\t\t\t\t\t\t\\\n\tgb = dev_get_drvdata(dev);\t\t\t\\\n\tstats = &gb->name;\t\t\t\t\t\\\n\tcount = stats->count ? stats->count : 1;\t\t\t\\\n\tavg = stats->sum + count / 2000000;  \t\t\\\n\trem = do_div(avg, count);\t\t\t\t\t\\\n\trem *= 1000000;\t\t\t\t\t\t\t\\\n\tdo_div(rem, count);\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%llu.%06u\\n\", avg, (u32)rem);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name##_avg)\n\n#define gb_loopback_stats_attrs(field)\t\t\t\t\\\n\tgb_loopback_ro_stats_attr(field, min, u);\t\t\\\n\tgb_loopback_ro_stats_attr(field, max, u);\t\t\\\n\tgb_loopback_ro_avg_attr(field)\n\n#define gb_loopback_attr(field, type)\t\t\t\t\t\\\nstatic ssize_t field##_show(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gb_loopback *gb = dev_get_drvdata(dev);\t\t\t\\\n\treturn sprintf(buf, \"%\" #type \"\\n\", gb->field);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t field##_store(struct device *dev,\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    const char *buf,\t\t\t\t\\\n\t\t\t    size_t len)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tstruct gb_loopback *gb = dev_get_drvdata(dev);\t\t\t\\\n\tmutex_lock(&gb->mutex);\t\t\t\t\t\t\\\n\tret = sscanf(buf, \"%\"#type, &gb->field);\t\t\t\\\n\tif (ret != 1)\t\t\t\t\t\t\t\\\n\t\tlen = -EINVAL;\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tgb_loopback_check_attr(gb, bundle);\t\t\t\\\n\tmutex_unlock(&gb->mutex);\t\t\t\t\t\\\n\treturn len;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RW(field)\n\n#define gb_dev_loopback_ro_attr(field, conn)\t\t\t\t\\\nstatic ssize_t field##_show(struct device *dev,\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gb_loopback *gb = dev_get_drvdata(dev);\t\t\t\\\n\treturn sprintf(buf, \"%u\\n\", gb->field);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(field)\n\n#define gb_dev_loopback_rw_attr(field, type)\t\t\t\t\\\nstatic ssize_t field##_show(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gb_loopback *gb = dev_get_drvdata(dev);\t\t\t\\\n\treturn sprintf(buf, \"%\" #type \"\\n\", gb->field);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t field##_store(struct device *dev,\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    const char *buf,\t\t\t\t\\\n\t\t\t    size_t len)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tstruct gb_loopback *gb = dev_get_drvdata(dev);\t\t\t\\\n\tmutex_lock(&gb->mutex);\t\t\t\t\t\t\\\n\tret = sscanf(buf, \"%\"#type, &gb->field);\t\t\t\\\n\tif (ret != 1)\t\t\t\t\t\t\t\\\n\t\tlen = -EINVAL;\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tgb_loopback_check_attr(gb);\t\t\\\n\tmutex_unlock(&gb->mutex);\t\t\t\t\t\\\n\treturn len;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RW(field)\n\nstatic void gb_loopback_reset_stats(struct gb_loopback *gb);\nstatic void gb_loopback_check_attr(struct gb_loopback *gb)\n{\n\tif (gb->us_wait > GB_LOOPBACK_US_WAIT_MAX)\n\t\tgb->us_wait = GB_LOOPBACK_US_WAIT_MAX;\n\tif (gb->size > gb_dev.size_max)\n\t\tgb->size = gb_dev.size_max;\n\tgb->requests_timedout = 0;\n\tgb->requests_completed = 0;\n\tgb->iteration_count = 0;\n\tgb->send_count = 0;\n\tgb->error = 0;\n\n\tif (kfifo_depth < gb->iteration_max) {\n\t\tdev_warn(gb->dev,\n\t\t\t \"cannot log bytes %u kfifo_depth %u\\n\",\n\t\t\t gb->iteration_max, kfifo_depth);\n\t}\n\tkfifo_reset_out(&gb->kfifo_lat);\n\n\tswitch (gb->type) {\n\tcase GB_LOOPBACK_TYPE_PING:\n\tcase GB_LOOPBACK_TYPE_TRANSFER:\n\tcase GB_LOOPBACK_TYPE_SINK:\n\t\tgb->jiffy_timeout = usecs_to_jiffies(gb->timeout);\n\t\tif (!gb->jiffy_timeout)\n\t\t\tgb->jiffy_timeout = GB_LOOPBACK_TIMEOUT_MIN;\n\t\telse if (gb->jiffy_timeout > GB_LOOPBACK_TIMEOUT_MAX)\n\t\t\tgb->jiffy_timeout = GB_LOOPBACK_TIMEOUT_MAX;\n\t\tgb_loopback_reset_stats(gb);\n\t\twake_up(&gb->wq);\n\t\tbreak;\n\tdefault:\n\t\tgb->type = 0;\n\t\tbreak;\n\t}\n}\n\n \ngb_loopback_stats_attrs(latency);\n \ngb_loopback_stats_attrs(requests_per_second);\n \ngb_loopback_stats_attrs(throughput);\n \ngb_loopback_stats_attrs(apbridge_unipro_latency);\n \ngb_loopback_stats_attrs(gbphy_firmware_latency);\n\n \ngb_loopback_ro_attr(error);\n \ngb_loopback_ro_attr(requests_completed);\n \ngb_loopback_ro_attr(requests_timedout);\n \ngb_loopback_ro_attr(timeout_min);\n \ngb_loopback_ro_attr(timeout_max);\n\n \ngb_dev_loopback_rw_attr(type, d);\n \ngb_dev_loopback_rw_attr(size, u);\n \ngb_dev_loopback_rw_attr(us_wait, d);\n \ngb_dev_loopback_rw_attr(iteration_max, u);\n \ngb_dev_loopback_ro_attr(iteration_count, false);\n \ngb_dev_loopback_rw_attr(async, u);\n \ngb_dev_loopback_rw_attr(timeout, u);\n \ngb_dev_loopback_rw_attr(outstanding_operations_max, u);\n\nstatic struct attribute *loopback_attrs[] = {\n\t&dev_attr_latency_min.attr,\n\t&dev_attr_latency_max.attr,\n\t&dev_attr_latency_avg.attr,\n\t&dev_attr_requests_per_second_min.attr,\n\t&dev_attr_requests_per_second_max.attr,\n\t&dev_attr_requests_per_second_avg.attr,\n\t&dev_attr_throughput_min.attr,\n\t&dev_attr_throughput_max.attr,\n\t&dev_attr_throughput_avg.attr,\n\t&dev_attr_apbridge_unipro_latency_min.attr,\n\t&dev_attr_apbridge_unipro_latency_max.attr,\n\t&dev_attr_apbridge_unipro_latency_avg.attr,\n\t&dev_attr_gbphy_firmware_latency_min.attr,\n\t&dev_attr_gbphy_firmware_latency_max.attr,\n\t&dev_attr_gbphy_firmware_latency_avg.attr,\n\t&dev_attr_type.attr,\n\t&dev_attr_size.attr,\n\t&dev_attr_us_wait.attr,\n\t&dev_attr_iteration_count.attr,\n\t&dev_attr_iteration_max.attr,\n\t&dev_attr_async.attr,\n\t&dev_attr_error.attr,\n\t&dev_attr_requests_completed.attr,\n\t&dev_attr_requests_timedout.attr,\n\t&dev_attr_timeout.attr,\n\t&dev_attr_outstanding_operations_max.attr,\n\t&dev_attr_timeout_min.attr,\n\t&dev_attr_timeout_max.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(loopback);\n\nstatic void gb_loopback_calculate_stats(struct gb_loopback *gb, bool error);\n\nstatic u32 gb_loopback_nsec_to_usec_latency(u64 elapsed_nsecs)\n{\n\tdo_div(elapsed_nsecs, NSEC_PER_USEC);\n\treturn elapsed_nsecs;\n}\n\nstatic u64 __gb_loopback_calc_latency(u64 t1, u64 t2)\n{\n\tif (t2 > t1)\n\t\treturn t2 - t1;\n\telse\n\t\treturn NSEC_PER_DAY - t2 + t1;\n}\n\nstatic u64 gb_loopback_calc_latency(ktime_t ts, ktime_t te)\n{\n\treturn __gb_loopback_calc_latency(ktime_to_ns(ts), ktime_to_ns(te));\n}\n\nstatic int gb_loopback_operation_sync(struct gb_loopback *gb, int type,\n\t\t\t\t      void *request, int request_size,\n\t\t\t\t      void *response, int response_size)\n{\n\tstruct gb_operation *operation;\n\tktime_t ts, te;\n\tint ret;\n\n\tts = ktime_get();\n\toperation = gb_operation_create(gb->connection, type, request_size,\n\t\t\t\t\tresponse_size, GFP_KERNEL);\n\tif (!operation)\n\t\treturn -ENOMEM;\n\n\tif (request_size)\n\t\tmemcpy(operation->request->payload, request, request_size);\n\n\tret = gb_operation_request_send_sync(operation);\n\tif (ret) {\n\t\tdev_err(&gb->connection->bundle->dev,\n\t\t\t\"synchronous operation failed: %d\\n\", ret);\n\t\tgoto out_put_operation;\n\t} else {\n\t\tif (response_size == operation->response->payload_size) {\n\t\t\tmemcpy(response, operation->response->payload,\n\t\t\t       response_size);\n\t\t} else {\n\t\t\tdev_err(&gb->connection->bundle->dev,\n\t\t\t\t\"response size %zu expected %d\\n\",\n\t\t\t\toperation->response->payload_size,\n\t\t\t\tresponse_size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_put_operation;\n\t\t}\n\t}\n\n\tte = ktime_get();\n\n\t \n\tgb->elapsed_nsecs = gb_loopback_calc_latency(ts, te);\n\nout_put_operation:\n\tgb_operation_put(operation);\n\n\treturn ret;\n}\n\nstatic void gb_loopback_async_wait_all(struct gb_loopback *gb)\n{\n\twait_event(gb->wq_completion,\n\t\t   !atomic_read(&gb->outstanding_operations));\n}\n\nstatic void gb_loopback_async_operation_callback(struct gb_operation *operation)\n{\n\tstruct gb_loopback_async_operation *op_async;\n\tstruct gb_loopback *gb;\n\tktime_t te;\n\tint result;\n\n\tte = ktime_get();\n\tresult = gb_operation_result(operation);\n\top_async = gb_operation_get_data(operation);\n\tgb = op_async->gb;\n\n\tmutex_lock(&gb->mutex);\n\n\tif (!result && op_async->completion)\n\t\tresult = op_async->completion(op_async);\n\n\tif (!result) {\n\t\tgb->elapsed_nsecs = gb_loopback_calc_latency(op_async->ts, te);\n\t} else {\n\t\tgb->error++;\n\t\tif (result == -ETIMEDOUT)\n\t\t\tgb->requests_timedout++;\n\t}\n\n\tgb->iteration_count++;\n\tgb_loopback_calculate_stats(gb, result);\n\n\tmutex_unlock(&gb->mutex);\n\n\tdev_dbg(&gb->connection->bundle->dev, \"complete operation %d\\n\",\n\t\toperation->id);\n\n\t \n\tatomic_dec(&op_async->gb->outstanding_operations);\n\twake_up(&gb->wq_completion);\n\n\t \n\tgb_operation_put(operation);\n\tkfree(op_async);\n}\n\nstatic int gb_loopback_async_operation(struct gb_loopback *gb, int type,\n\t\t\t\t       void *request, int request_size,\n\t\t\t\t       int response_size,\n\t\t\t\t       void *completion)\n{\n\tstruct gb_loopback_async_operation *op_async;\n\tstruct gb_operation *operation;\n\tint ret;\n\n\top_async = kzalloc(sizeof(*op_async), GFP_KERNEL);\n\tif (!op_async)\n\t\treturn -ENOMEM;\n\n\toperation = gb_operation_create(gb->connection, type, request_size,\n\t\t\t\t\tresponse_size, GFP_KERNEL);\n\tif (!operation) {\n\t\tkfree(op_async);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (request_size)\n\t\tmemcpy(operation->request->payload, request, request_size);\n\n\tgb_operation_set_data(operation, op_async);\n\n\top_async->gb = gb;\n\top_async->operation = operation;\n\top_async->completion = completion;\n\n\top_async->ts = ktime_get();\n\n\tatomic_inc(&gb->outstanding_operations);\n\tret = gb_operation_request_send(operation,\n\t\t\t\t\tgb_loopback_async_operation_callback,\n\t\t\t\t\tjiffies_to_msecs(gb->jiffy_timeout),\n\t\t\t\t\tGFP_KERNEL);\n\tif (ret) {\n\t\tatomic_dec(&gb->outstanding_operations);\n\t\tgb_operation_put(operation);\n\t\tkfree(op_async);\n\t}\n\treturn ret;\n}\n\nstatic int gb_loopback_sync_sink(struct gb_loopback *gb, u32 len)\n{\n\tstruct gb_loopback_transfer_request *request;\n\tint retval;\n\n\trequest = kmalloc(len + sizeof(*request), GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\trequest->len = cpu_to_le32(len);\n\tretval = gb_loopback_operation_sync(gb, GB_LOOPBACK_TYPE_SINK,\n\t\t\t\t\t    request, len + sizeof(*request),\n\t\t\t\t\t    NULL, 0);\n\tkfree(request);\n\treturn retval;\n}\n\nstatic int gb_loopback_sync_transfer(struct gb_loopback *gb, u32 len)\n{\n\tstruct gb_loopback_transfer_request *request;\n\tstruct gb_loopback_transfer_response *response;\n\tint retval;\n\n\tgb->apbridge_latency_ts = 0;\n\tgb->gbphy_latency_ts = 0;\n\n\trequest = kmalloc(len + sizeof(*request), GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\tresponse = kmalloc(len + sizeof(*response), GFP_KERNEL);\n\tif (!response) {\n\t\tkfree(request);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(request->data, 0x5A, len);\n\n\trequest->len = cpu_to_le32(len);\n\tretval = gb_loopback_operation_sync(gb, GB_LOOPBACK_TYPE_TRANSFER,\n\t\t\t\t\t    request, len + sizeof(*request),\n\t\t\t\t\t    response, len + sizeof(*response));\n\tif (retval)\n\t\tgoto gb_error;\n\n\tif (memcmp(request->data, response->data, len)) {\n\t\tdev_err(&gb->connection->bundle->dev,\n\t\t\t\"Loopback Data doesn't match\\n\");\n\t\tretval = -EREMOTEIO;\n\t}\n\tgb->apbridge_latency_ts = (u32)__le32_to_cpu(response->reserved0);\n\tgb->gbphy_latency_ts = (u32)__le32_to_cpu(response->reserved1);\n\ngb_error:\n\tkfree(request);\n\tkfree(response);\n\n\treturn retval;\n}\n\nstatic int gb_loopback_sync_ping(struct gb_loopback *gb)\n{\n\treturn gb_loopback_operation_sync(gb, GB_LOOPBACK_TYPE_PING,\n\t\t\t\t\t  NULL, 0, NULL, 0);\n}\n\nstatic int gb_loopback_async_sink(struct gb_loopback *gb, u32 len)\n{\n\tstruct gb_loopback_transfer_request *request;\n\tint retval;\n\n\trequest = kmalloc(len + sizeof(*request), GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\trequest->len = cpu_to_le32(len);\n\tretval = gb_loopback_async_operation(gb, GB_LOOPBACK_TYPE_SINK,\n\t\t\t\t\t     request, len + sizeof(*request),\n\t\t\t\t\t     0, NULL);\n\tkfree(request);\n\treturn retval;\n}\n\nstatic int gb_loopback_async_transfer_complete(\n\t\t\t\tstruct gb_loopback_async_operation *op_async)\n{\n\tstruct gb_loopback *gb;\n\tstruct gb_operation *operation;\n\tstruct gb_loopback_transfer_request *request;\n\tstruct gb_loopback_transfer_response *response;\n\tsize_t len;\n\tint retval = 0;\n\n\tgb = op_async->gb;\n\toperation = op_async->operation;\n\trequest = operation->request->payload;\n\tresponse = operation->response->payload;\n\tlen = le32_to_cpu(request->len);\n\n\tif (memcmp(request->data, response->data, len)) {\n\t\tdev_err(&gb->connection->bundle->dev,\n\t\t\t\"Loopback Data doesn't match operation id %d\\n\",\n\t\t\toperation->id);\n\t\tretval = -EREMOTEIO;\n\t} else {\n\t\tgb->apbridge_latency_ts =\n\t\t\t(u32)__le32_to_cpu(response->reserved0);\n\t\tgb->gbphy_latency_ts =\n\t\t\t(u32)__le32_to_cpu(response->reserved1);\n\t}\n\n\treturn retval;\n}\n\nstatic int gb_loopback_async_transfer(struct gb_loopback *gb, u32 len)\n{\n\tstruct gb_loopback_transfer_request *request;\n\tint retval, response_len;\n\n\trequest = kmalloc(len + sizeof(*request), GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tmemset(request->data, 0x5A, len);\n\n\trequest->len = cpu_to_le32(len);\n\tresponse_len = sizeof(struct gb_loopback_transfer_response);\n\tretval = gb_loopback_async_operation(gb, GB_LOOPBACK_TYPE_TRANSFER,\n\t\t\t\t\t     request, len + sizeof(*request),\n\t\t\t\t\t     len + response_len,\n\t\t\t\t\t     gb_loopback_async_transfer_complete);\n\tif (retval)\n\t\tgoto gb_error;\n\ngb_error:\n\tkfree(request);\n\treturn retval;\n}\n\nstatic int gb_loopback_async_ping(struct gb_loopback *gb)\n{\n\treturn gb_loopback_async_operation(gb, GB_LOOPBACK_TYPE_PING,\n\t\t\t\t\t   NULL, 0, 0, NULL);\n}\n\nstatic int gb_loopback_request_handler(struct gb_operation *operation)\n{\n\tstruct gb_connection *connection = operation->connection;\n\tstruct gb_loopback_transfer_request *request;\n\tstruct gb_loopback_transfer_response *response;\n\tstruct device *dev = &connection->bundle->dev;\n\tsize_t len;\n\n\t \n\tswitch (operation->type) {\n\tcase GB_LOOPBACK_TYPE_PING:\n\tcase GB_LOOPBACK_TYPE_SINK:\n\t\treturn 0;\n\tcase GB_LOOPBACK_TYPE_TRANSFER:\n\t\tif (operation->request->payload_size < sizeof(*request)) {\n\t\t\tdev_err(dev, \"transfer request too small (%zu < %zu)\\n\",\n\t\t\t\toperation->request->payload_size,\n\t\t\t\tsizeof(*request));\n\t\t\treturn -EINVAL;\t \n\t\t}\n\t\trequest = operation->request->payload;\n\t\tlen = le32_to_cpu(request->len);\n\t\tif (len > gb_dev.size_max) {\n\t\t\tdev_err(dev, \"transfer request too large (%zu > %zu)\\n\",\n\t\t\t\tlen, gb_dev.size_max);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!gb_operation_response_alloc(operation,\n\t\t\t\tlen + sizeof(*response), GFP_KERNEL)) {\n\t\t\tdev_err(dev, \"error allocating response\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tresponse = operation->response->payload;\n\t\tresponse->len = cpu_to_le32(len);\n\t\tif (len)\n\t\t\tmemcpy(response->data, request->data, len);\n\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(dev, \"unsupported request: %u\\n\", operation->type);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void gb_loopback_reset_stats(struct gb_loopback *gb)\n{\n\tstruct gb_loopback_stats reset = {\n\t\t.min = U32_MAX,\n\t};\n\n\t \n\tmemcpy(&gb->latency, &reset,\n\t       sizeof(struct gb_loopback_stats));\n\tmemcpy(&gb->throughput, &reset,\n\t       sizeof(struct gb_loopback_stats));\n\tmemcpy(&gb->requests_per_second, &reset,\n\t       sizeof(struct gb_loopback_stats));\n\tmemcpy(&gb->apbridge_unipro_latency, &reset,\n\t       sizeof(struct gb_loopback_stats));\n\tmemcpy(&gb->gbphy_firmware_latency, &reset,\n\t       sizeof(struct gb_loopback_stats));\n\n\t \n\tgb->apbridge_latency_ts = 0;\n\tgb->gbphy_latency_ts = 0;\n\tgb->ts = ktime_set(0, 0);\n}\n\nstatic void gb_loopback_update_stats(struct gb_loopback_stats *stats, u32 val)\n{\n\tif (stats->min > val)\n\t\tstats->min = val;\n\tif (stats->max < val)\n\t\tstats->max = val;\n\tstats->sum += val;\n\tstats->count++;\n}\n\nstatic void gb_loopback_update_stats_window(struct gb_loopback_stats *stats,\n\t\t\t\t\t    u64 val, u32 count)\n{\n\tstats->sum += val;\n\tstats->count += count;\n\n\tdo_div(val, count);\n\tif (stats->min > val)\n\t\tstats->min = val;\n\tif (stats->max < val)\n\t\tstats->max = val;\n}\n\nstatic void gb_loopback_requests_update(struct gb_loopback *gb, u32 latency)\n{\n\tu64 req = gb->requests_completed * USEC_PER_SEC;\n\n\tgb_loopback_update_stats_window(&gb->requests_per_second, req, latency);\n}\n\nstatic void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)\n{\n\tu64 aggregate_size = sizeof(struct gb_operation_msg_hdr) * 2;\n\n\tswitch (gb->type) {\n\tcase GB_LOOPBACK_TYPE_PING:\n\t\tbreak;\n\tcase GB_LOOPBACK_TYPE_SINK:\n\t\taggregate_size += sizeof(struct gb_loopback_transfer_request) +\n\t\t\t\t  gb->size;\n\t\tbreak;\n\tcase GB_LOOPBACK_TYPE_TRANSFER:\n\t\taggregate_size += sizeof(struct gb_loopback_transfer_request) +\n\t\t\t\t  sizeof(struct gb_loopback_transfer_response) +\n\t\t\t\t  gb->size * 2;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\taggregate_size *= gb->requests_completed;\n\taggregate_size *= USEC_PER_SEC;\n\tgb_loopback_update_stats_window(&gb->throughput, aggregate_size,\n\t\t\t\t\tlatency);\n}\n\nstatic void gb_loopback_calculate_latency_stats(struct gb_loopback *gb)\n{\n\tu32 lat;\n\n\t \n\tlat = gb_loopback_nsec_to_usec_latency(gb->elapsed_nsecs);\n\n\t \n\tgb_loopback_update_stats(&gb->latency, lat);\n\n\t \n\tkfifo_in(&gb->kfifo_lat, (unsigned char *)&lat, sizeof(lat));\n\n\t \n\tgb_loopback_update_stats(&gb->apbridge_unipro_latency,\n\t\t\t\t gb->apbridge_latency_ts);\n\tgb_loopback_update_stats(&gb->gbphy_firmware_latency,\n\t\t\t\t gb->gbphy_latency_ts);\n}\n\nstatic void gb_loopback_calculate_stats(struct gb_loopback *gb, bool error)\n{\n\tu64 nlat;\n\tu32 lat;\n\tktime_t te;\n\n\tif (!error) {\n\t\tgb->requests_completed++;\n\t\tgb_loopback_calculate_latency_stats(gb);\n\t}\n\n\tte = ktime_get();\n\tnlat = gb_loopback_calc_latency(gb->ts, te);\n\tif (nlat >= NSEC_PER_SEC || gb->iteration_count == gb->iteration_max) {\n\t\tlat = gb_loopback_nsec_to_usec_latency(nlat);\n\n\t\tgb_loopback_throughput_update(gb, lat);\n\t\tgb_loopback_requests_update(gb, lat);\n\n\t\tif (gb->iteration_count != gb->iteration_max) {\n\t\t\tgb->ts = te;\n\t\t\tgb->requests_completed = 0;\n\t\t}\n\t}\n}\n\nstatic void gb_loopback_async_wait_to_send(struct gb_loopback *gb)\n{\n\tif (!(gb->async && gb->outstanding_operations_max))\n\t\treturn;\n\twait_event_interruptible(gb->wq_completion,\n\t\t\t\t (atomic_read(&gb->outstanding_operations) <\n\t\t\t\t  gb->outstanding_operations_max) ||\n\t\t\t\t  kthread_should_stop());\n}\n\nstatic int gb_loopback_fn(void *data)\n{\n\tint error = 0;\n\tint us_wait = 0;\n\tint type;\n\tint ret;\n\tu32 size;\n\n\tstruct gb_loopback *gb = data;\n\tstruct gb_bundle *bundle = gb->connection->bundle;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (1) {\n\t\tif (!gb->type) {\n\t\t\tgb_pm_runtime_put_autosuspend(bundle);\n\t\t\twait_event_interruptible(gb->wq, gb->type ||\n\t\t\t\t\t\t kthread_should_stop());\n\t\t\tret = gb_pm_runtime_get_sync(bundle);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\t \n\t\tgb_loopback_async_wait_to_send(gb);\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tmutex_lock(&gb->mutex);\n\n\t\t \n\t\tif (gb->send_count == gb->iteration_max) {\n\t\t\tmutex_unlock(&gb->mutex);\n\n\t\t\t \n\t\t\tgb_loopback_async_wait_all(gb);\n\n\t\t\t \n\t\t\tmutex_lock(&gb->mutex);\n\t\t\tif (gb->iteration_count == gb->iteration_max) {\n\t\t\t\tgb->type = 0;\n\t\t\t\tgb->send_count = 0;\n\t\t\t\tsysfs_notify(&gb->dev->kobj,  NULL,\n\t\t\t\t\t     \"iteration_count\");\n\t\t\t\tdev_dbg(&bundle->dev, \"load test complete\\n\");\n\t\t\t} else {\n\t\t\t\tdev_dbg(&bundle->dev,\n\t\t\t\t\t\"continuing on with new test set\\n\");\n\t\t\t}\n\t\t\tmutex_unlock(&gb->mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tsize = gb->size;\n\t\tus_wait = gb->us_wait;\n\t\ttype = gb->type;\n\t\tif (ktime_to_ns(gb->ts) == 0)\n\t\t\tgb->ts = ktime_get();\n\n\t\t \n\t\tif (gb->async) {\n\t\t\tif (type == GB_LOOPBACK_TYPE_PING)\n\t\t\t\terror = gb_loopback_async_ping(gb);\n\t\t\telse if (type == GB_LOOPBACK_TYPE_TRANSFER)\n\t\t\t\terror = gb_loopback_async_transfer(gb, size);\n\t\t\telse if (type == GB_LOOPBACK_TYPE_SINK)\n\t\t\t\terror = gb_loopback_async_sink(gb, size);\n\n\t\t\tif (error) {\n\t\t\t\tgb->error++;\n\t\t\t\tgb->iteration_count++;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (type == GB_LOOPBACK_TYPE_PING)\n\t\t\t\terror = gb_loopback_sync_ping(gb);\n\t\t\telse if (type == GB_LOOPBACK_TYPE_TRANSFER)\n\t\t\t\terror = gb_loopback_sync_transfer(gb, size);\n\t\t\telse if (type == GB_LOOPBACK_TYPE_SINK)\n\t\t\t\terror = gb_loopback_sync_sink(gb, size);\n\n\t\t\tif (error)\n\t\t\t\tgb->error++;\n\t\t\tgb->iteration_count++;\n\t\t\tgb_loopback_calculate_stats(gb, !!error);\n\t\t}\n\t\tgb->send_count++;\n\t\tmutex_unlock(&gb->mutex);\n\n\t\tif (us_wait) {\n\t\t\tif (us_wait < 20000)\n\t\t\t\tusleep_range(us_wait, us_wait + 100);\n\t\t\telse\n\t\t\t\tmsleep(us_wait / 1000);\n\t\t}\n\t}\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn 0;\n}\n\nstatic int gb_loopback_dbgfs_latency_show_common(struct seq_file *s,\n\t\t\t\t\t\t struct kfifo *kfifo,\n\t\t\t\t\t\t struct mutex *mutex)\n{\n\tu32 latency;\n\tint retval;\n\n\tif (kfifo_len(kfifo) == 0) {\n\t\tretval = -EAGAIN;\n\t\tgoto done;\n\t}\n\n\tmutex_lock(mutex);\n\tretval = kfifo_out(kfifo, &latency, sizeof(latency));\n\tif (retval > 0) {\n\t\tseq_printf(s, \"%u\", latency);\n\t\tretval = 0;\n\t}\n\tmutex_unlock(mutex);\ndone:\n\treturn retval;\n}\n\nstatic int gb_loopback_dbgfs_latency_show(struct seq_file *s, void *unused)\n{\n\tstruct gb_loopback *gb = s->private;\n\n\treturn gb_loopback_dbgfs_latency_show_common(s, &gb->kfifo_lat,\n\t\t\t\t\t\t     &gb->mutex);\n}\nDEFINE_SHOW_ATTRIBUTE(gb_loopback_dbgfs_latency);\n\n#define DEBUGFS_NAMELEN 32\n\nstatic int gb_loopback_probe(struct gb_bundle *bundle,\n\t\t\t     const struct greybus_bundle_id *id)\n{\n\tstruct greybus_descriptor_cport *cport_desc;\n\tstruct gb_connection *connection;\n\tstruct gb_loopback *gb;\n\tstruct device *dev;\n\tint retval;\n\tchar name[DEBUGFS_NAMELEN];\n\tunsigned long flags;\n\n\tif (bundle->num_cports != 1)\n\t\treturn -ENODEV;\n\n\tcport_desc = &bundle->cport_desc[0];\n\tif (cport_desc->protocol_id != GREYBUS_PROTOCOL_LOOPBACK)\n\t\treturn -ENODEV;\n\n\tgb = kzalloc(sizeof(*gb), GFP_KERNEL);\n\tif (!gb)\n\t\treturn -ENOMEM;\n\n\tconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\n\t\t\t\t\t  gb_loopback_request_handler);\n\tif (IS_ERR(connection)) {\n\t\tretval = PTR_ERR(connection);\n\t\tgoto out_kzalloc;\n\t}\n\n\tgb->connection = connection;\n\tgreybus_set_drvdata(bundle, gb);\n\n\tinit_waitqueue_head(&gb->wq);\n\tinit_waitqueue_head(&gb->wq_completion);\n\tatomic_set(&gb->outstanding_operations, 0);\n\tgb_loopback_reset_stats(gb);\n\n\t \n\tgb->timeout_min = jiffies_to_usecs(GB_LOOPBACK_TIMEOUT_MIN);\n\tgb->timeout_max = jiffies_to_usecs(GB_LOOPBACK_TIMEOUT_MAX);\n\n\tif (!gb_dev.count) {\n\t\t \n\t\tgb_dev.size_max = gb_operation_get_payload_size_max(connection);\n\t\tif (gb_dev.size_max <=\n\t\t\tsizeof(struct gb_loopback_transfer_request)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_connection_destroy;\n\t\t}\n\t\tgb_dev.size_max -= sizeof(struct gb_loopback_transfer_request);\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"raw_latency_%s\",\n\t\t dev_name(&connection->bundle->dev));\n\tgb->file = debugfs_create_file(name, S_IFREG | 0444, gb_dev.root, gb,\n\t\t\t\t       &gb_loopback_dbgfs_latency_fops);\n\n\tgb->id = ida_simple_get(&loopback_ida, 0, 0, GFP_KERNEL);\n\tif (gb->id < 0) {\n\t\tretval = gb->id;\n\t\tgoto out_debugfs_remove;\n\t}\n\n\tretval = gb_connection_enable(connection);\n\tif (retval)\n\t\tgoto out_ida_remove;\n\n\tdev = device_create_with_groups(&loopback_class,\n\t\t\t\t\t&connection->bundle->dev,\n\t\t\t\t\tMKDEV(0, 0), gb, loopback_groups,\n\t\t\t\t\t\"gb_loopback%d\", gb->id);\n\tif (IS_ERR(dev)) {\n\t\tretval = PTR_ERR(dev);\n\t\tgoto out_connection_disable;\n\t}\n\tgb->dev = dev;\n\n\t \n\tif (kfifo_alloc(&gb->kfifo_lat, kfifo_depth * sizeof(u32),\n\t\t\tGFP_KERNEL)) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_conn;\n\t}\n\t \n\tmutex_init(&gb->mutex);\n\tgb->task = kthread_run(gb_loopback_fn, gb, \"gb_loopback\");\n\tif (IS_ERR(gb->task)) {\n\t\tretval = PTR_ERR(gb->task);\n\t\tgoto out_kfifo;\n\t}\n\n\tspin_lock_irqsave(&gb_dev.lock, flags);\n\tgb_dev.count++;\n\tspin_unlock_irqrestore(&gb_dev.lock, flags);\n\n\tgb_connection_latency_tag_enable(connection);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn 0;\n\nout_kfifo:\n\tkfifo_free(&gb->kfifo_lat);\nout_conn:\n\tdevice_unregister(dev);\nout_connection_disable:\n\tgb_connection_disable(connection);\nout_ida_remove:\n\tida_simple_remove(&loopback_ida, gb->id);\nout_debugfs_remove:\n\tdebugfs_remove(gb->file);\nout_connection_destroy:\n\tgb_connection_destroy(connection);\nout_kzalloc:\n\tkfree(gb);\n\n\treturn retval;\n}\n\nstatic void gb_loopback_disconnect(struct gb_bundle *bundle)\n{\n\tstruct gb_loopback *gb = greybus_get_drvdata(bundle);\n\tunsigned long flags;\n\tint ret;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\tgb_pm_runtime_get_noresume(bundle);\n\n\tgb_connection_disable(gb->connection);\n\n\tif (!IS_ERR_OR_NULL(gb->task))\n\t\tkthread_stop(gb->task);\n\n\tkfifo_free(&gb->kfifo_lat);\n\tgb_connection_latency_tag_disable(gb->connection);\n\tdebugfs_remove(gb->file);\n\n\t \n\tgb_loopback_async_wait_all(gb);\n\n\tspin_lock_irqsave(&gb_dev.lock, flags);\n\tgb_dev.count--;\n\tspin_unlock_irqrestore(&gb_dev.lock, flags);\n\n\tdevice_unregister(gb->dev);\n\tida_simple_remove(&loopback_ida, gb->id);\n\n\tgb_connection_destroy(gb->connection);\n\tkfree(gb);\n}\n\nstatic const struct greybus_bundle_id gb_loopback_id_table[] = {\n\t{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_LOOPBACK) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(greybus, gb_loopback_id_table);\n\nstatic struct greybus_driver gb_loopback_driver = {\n\t.name\t\t= \"loopback\",\n\t.probe\t\t= gb_loopback_probe,\n\t.disconnect\t= gb_loopback_disconnect,\n\t.id_table\t= gb_loopback_id_table,\n};\n\nstatic int loopback_init(void)\n{\n\tint retval;\n\n\tspin_lock_init(&gb_dev.lock);\n\tgb_dev.root = debugfs_create_dir(\"gb_loopback\", NULL);\n\n\tretval = class_register(&loopback_class);\n\tif (retval)\n\t\tgoto err;\n\n\tretval = greybus_register(&gb_loopback_driver);\n\tif (retval)\n\t\tgoto err_unregister;\n\n\treturn 0;\n\nerr_unregister:\n\tclass_unregister(&loopback_class);\nerr:\n\tdebugfs_remove_recursive(gb_dev.root);\n\treturn retval;\n}\nmodule_init(loopback_init);\n\nstatic void __exit loopback_exit(void)\n{\n\tdebugfs_remove_recursive(gb_dev.root);\n\tgreybus_deregister(&gb_loopback_driver);\n\tclass_unregister(&loopback_class);\n\tida_destroy(&loopback_ida);\n}\nmodule_exit(loopback_exit);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}