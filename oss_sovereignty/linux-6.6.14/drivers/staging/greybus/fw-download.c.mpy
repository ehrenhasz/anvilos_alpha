{
  "module_name": "fw-download.c",
  "hash_id": "dc23a2d7c79c3d18b676af03d9bbfdda0203e3f26d12e34b8ce6705737cd8252",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/fw-download.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/greybus.h>\n#include \"firmware.h\"\n\n \n#define MIN_FETCH_SIZE\t\t512\n \n#define NEXT_REQ_TIMEOUT_J\tmsecs_to_jiffies(1000)\n\nstruct fw_request {\n\tu8\t\t\tfirmware_id;\n\tbool\t\t\tdisabled;\n\tbool\t\t\ttimedout;\n\tchar\t\t\tname[FW_NAME_SIZE];\n\tconst struct firmware\t*fw;\n\tstruct list_head\tnode;\n\n\tstruct delayed_work\tdwork;\n\t \n\tunsigned long\t\trelease_timeout_j;\n\tstruct kref\t\tkref;\n\tstruct fw_download\t*fw_download;\n};\n\nstruct fw_download {\n\tstruct device\t\t*parent;\n\tstruct gb_connection\t*connection;\n\tstruct list_head\tfw_requests;\n\tstruct ida\t\tid_map;\n\tstruct mutex\t\tmutex;\n};\n\nstatic void fw_req_release(struct kref *kref)\n{\n\tstruct fw_request *fw_req = container_of(kref, struct fw_request, kref);\n\n\tdev_dbg(fw_req->fw_download->parent, \"firmware %s released\\n\",\n\t\tfw_req->name);\n\n\trelease_firmware(fw_req->fw);\n\n\t \n\tif (!fw_req->timedout)\n\t\tida_simple_remove(&fw_req->fw_download->id_map,\n\t\t\t\t  fw_req->firmware_id);\n\n\tkfree(fw_req);\n}\n\n \nstatic void put_fw_req(struct fw_request *fw_req)\n{\n\tkref_put(&fw_req->kref, fw_req_release);\n}\n\n \nstatic struct fw_request *get_fw_req(struct fw_download *fw_download,\n\t\t\t\t     u8 firmware_id)\n{\n\tstruct fw_request *fw_req;\n\n\tmutex_lock(&fw_download->mutex);\n\n\tlist_for_each_entry(fw_req, &fw_download->fw_requests, node) {\n\t\tif (fw_req->firmware_id == firmware_id) {\n\t\t\tkref_get(&fw_req->kref);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tfw_req = NULL;\n\nunlock:\n\tmutex_unlock(&fw_download->mutex);\n\n\treturn fw_req;\n}\n\nstatic void free_firmware(struct fw_download *fw_download,\n\t\t\t  struct fw_request *fw_req)\n{\n\t \n\tif (fw_req->disabled)\n\t\treturn;\n\n\tmutex_lock(&fw_download->mutex);\n\tlist_del(&fw_req->node);\n\tmutex_unlock(&fw_download->mutex);\n\n\tfw_req->disabled = true;\n\tput_fw_req(fw_req);\n}\n\nstatic void fw_request_timedout(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct fw_request *fw_req = container_of(dwork,\n\t\t\t\t\t\t struct fw_request, dwork);\n\tstruct fw_download *fw_download = fw_req->fw_download;\n\n\tdev_err(fw_download->parent,\n\t\t\"Timed out waiting for fetch / release firmware requests: %u\\n\",\n\t\tfw_req->firmware_id);\n\n\tfw_req->timedout = true;\n\tfree_firmware(fw_download, fw_req);\n}\n\nstatic int exceeds_release_timeout(struct fw_request *fw_req)\n{\n\tstruct fw_download *fw_download = fw_req->fw_download;\n\n\tif (time_before(jiffies, fw_req->release_timeout_j))\n\t\treturn 0;\n\n\tdev_err(fw_download->parent,\n\t\t\"Firmware download didn't finish in time, abort: %d\\n\",\n\t\tfw_req->firmware_id);\n\n\tfw_req->timedout = true;\n\tfree_firmware(fw_download, fw_req);\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic struct fw_request *find_firmware(struct fw_download *fw_download,\n\t\t\t\t\tconst char *tag)\n{\n\tstruct gb_interface *intf = fw_download->connection->bundle->intf;\n\tstruct fw_request *fw_req;\n\tint ret, req_count;\n\n\tfw_req = kzalloc(sizeof(*fw_req), GFP_KERNEL);\n\tif (!fw_req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tret = ida_simple_get(&fw_download->id_map, 1, 256, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tdev_err(fw_download->parent,\n\t\t\t\"failed to allocate firmware id (%d)\\n\", ret);\n\t\tgoto err_free_req;\n\t}\n\tfw_req->firmware_id = ret;\n\n\tsnprintf(fw_req->name, sizeof(fw_req->name),\n\t\t FW_NAME_PREFIX \"%08x_%08x_%08x_%08x_%s.tftf\",\n\t\t intf->ddbl1_manufacturer_id, intf->ddbl1_product_id,\n\t\t intf->vendor_id, intf->product_id, tag);\n\n\tdev_info(fw_download->parent, \"Requested firmware package '%s'\\n\",\n\t\t fw_req->name);\n\n\tret = request_firmware(&fw_req->fw, fw_req->name, fw_download->parent);\n\tif (ret) {\n\t\tdev_err(fw_download->parent,\n\t\t\t\"firmware request failed for %s (%d)\\n\", fw_req->name,\n\t\t\tret);\n\t\tgoto err_free_id;\n\t}\n\n\tfw_req->fw_download = fw_download;\n\tkref_init(&fw_req->kref);\n\n\tmutex_lock(&fw_download->mutex);\n\tlist_add(&fw_req->node, &fw_download->fw_requests);\n\tmutex_unlock(&fw_download->mutex);\n\n\t \n\treq_count = DIV_ROUND_UP(fw_req->fw->size, MIN_FETCH_SIZE);\n\tfw_req->release_timeout_j = jiffies + req_count * NEXT_REQ_TIMEOUT_J;\n\n\tINIT_DELAYED_WORK(&fw_req->dwork, fw_request_timedout);\n\tschedule_delayed_work(&fw_req->dwork, NEXT_REQ_TIMEOUT_J);\n\n\treturn fw_req;\n\nerr_free_id:\n\tida_simple_remove(&fw_download->id_map, fw_req->firmware_id);\nerr_free_req:\n\tkfree(fw_req);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic int fw_download_find_firmware(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct fw_download *fw_download = gb_connection_get_data(connection);\n\tstruct gb_fw_download_find_firmware_request *request;\n\tstruct gb_fw_download_find_firmware_response *response;\n\tstruct fw_request *fw_req;\n\tconst char *tag;\n\n\tif (op->request->payload_size != sizeof(*request)) {\n\t\tdev_err(fw_download->parent,\n\t\t\t\"illegal size of find firmware request (%zu != %zu)\\n\",\n\t\t\top->request->payload_size, sizeof(*request));\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request->payload;\n\ttag = (const char *)request->firmware_tag;\n\n\t \n\tif (strnlen(tag, GB_FIRMWARE_TAG_MAX_SIZE) ==\n\t    GB_FIRMWARE_TAG_MAX_SIZE) {\n\t\tdev_err(fw_download->parent,\n\t\t\t\"firmware-tag is not null-terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfw_req = find_firmware(fw_download, tag);\n\tif (IS_ERR(fw_req))\n\t\treturn PTR_ERR(fw_req);\n\n\tif (!gb_operation_response_alloc(op, sizeof(*response), GFP_KERNEL)) {\n\t\tdev_err(fw_download->parent, \"error allocating response\\n\");\n\t\tfree_firmware(fw_download, fw_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tresponse = op->response->payload;\n\tresponse->firmware_id = fw_req->firmware_id;\n\tresponse->size = cpu_to_le32(fw_req->fw->size);\n\n\tdev_dbg(fw_download->parent,\n\t\t\"firmware size is %zu bytes\\n\", fw_req->fw->size);\n\n\treturn 0;\n}\n\nstatic int fw_download_fetch_firmware(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct fw_download *fw_download = gb_connection_get_data(connection);\n\tstruct gb_fw_download_fetch_firmware_request *request;\n\tstruct gb_fw_download_fetch_firmware_response *response;\n\tstruct fw_request *fw_req;\n\tconst struct firmware *fw;\n\tunsigned int offset, size;\n\tu8 firmware_id;\n\tint ret = 0;\n\n\tif (op->request->payload_size != sizeof(*request)) {\n\t\tdev_err(fw_download->parent,\n\t\t\t\"Illegal size of fetch firmware request (%zu %zu)\\n\",\n\t\t\top->request->payload_size, sizeof(*request));\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request->payload;\n\toffset = le32_to_cpu(request->offset);\n\tsize = le32_to_cpu(request->size);\n\tfirmware_id = request->firmware_id;\n\n\tfw_req = get_fw_req(fw_download, firmware_id);\n\tif (!fw_req) {\n\t\tdev_err(fw_download->parent,\n\t\t\t\"firmware not available for id: %02u\\n\", firmware_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcancel_delayed_work_sync(&fw_req->dwork);\n\n\t \n\tif (fw_req->disabled) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto put_fw;\n\t}\n\n\t \n\tret = exceeds_release_timeout(fw_req);\n\tif (ret)\n\t\tgoto put_fw;\n\n\tfw = fw_req->fw;\n\n\tif (offset >= fw->size || size > fw->size - offset) {\n\t\tdev_err(fw_download->parent,\n\t\t\t\"bad fetch firmware request (offs = %u, size = %u)\\n\",\n\t\t\toffset, size);\n\t\tret = -EINVAL;\n\t\tgoto put_fw;\n\t}\n\n\tif (!gb_operation_response_alloc(op, sizeof(*response) + size,\n\t\t\t\t\t GFP_KERNEL)) {\n\t\tdev_err(fw_download->parent,\n\t\t\t\"error allocating fetch firmware response\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto put_fw;\n\t}\n\n\tresponse = op->response->payload;\n\tmemcpy(response->data, fw->data + offset, size);\n\n\tdev_dbg(fw_download->parent,\n\t\t\"responding with firmware (offs = %u, size = %u)\\n\", offset,\n\t\tsize);\n\n\t \n\tschedule_delayed_work(&fw_req->dwork, NEXT_REQ_TIMEOUT_J);\n\nput_fw:\n\tput_fw_req(fw_req);\n\n\treturn ret;\n}\n\nstatic int fw_download_release_firmware(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct fw_download *fw_download = gb_connection_get_data(connection);\n\tstruct gb_fw_download_release_firmware_request *request;\n\tstruct fw_request *fw_req;\n\tu8 firmware_id;\n\n\tif (op->request->payload_size != sizeof(*request)) {\n\t\tdev_err(fw_download->parent,\n\t\t\t\"Illegal size of release firmware request (%zu %zu)\\n\",\n\t\t\top->request->payload_size, sizeof(*request));\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request->payload;\n\tfirmware_id = request->firmware_id;\n\n\tfw_req = get_fw_req(fw_download, firmware_id);\n\tif (!fw_req) {\n\t\tdev_err(fw_download->parent,\n\t\t\t\"firmware not available for id: %02u\\n\", firmware_id);\n\t\treturn -EINVAL;\n\t}\n\n\tcancel_delayed_work_sync(&fw_req->dwork);\n\n\tfree_firmware(fw_download, fw_req);\n\tput_fw_req(fw_req);\n\n\tdev_dbg(fw_download->parent, \"release firmware\\n\");\n\n\treturn 0;\n}\n\nint gb_fw_download_request_handler(struct gb_operation *op)\n{\n\tu8 type = op->type;\n\n\tswitch (type) {\n\tcase GB_FW_DOWNLOAD_TYPE_FIND_FIRMWARE:\n\t\treturn fw_download_find_firmware(op);\n\tcase GB_FW_DOWNLOAD_TYPE_FETCH_FIRMWARE:\n\t\treturn fw_download_fetch_firmware(op);\n\tcase GB_FW_DOWNLOAD_TYPE_RELEASE_FIRMWARE:\n\t\treturn fw_download_release_firmware(op);\n\tdefault:\n\t\tdev_err(&op->connection->bundle->dev,\n\t\t\t\"unsupported request: %u\\n\", type);\n\t\treturn -EINVAL;\n\t}\n}\n\nint gb_fw_download_connection_init(struct gb_connection *connection)\n{\n\tstruct fw_download *fw_download;\n\tint ret;\n\n\tif (!connection)\n\t\treturn 0;\n\n\tfw_download = kzalloc(sizeof(*fw_download), GFP_KERNEL);\n\tif (!fw_download)\n\t\treturn -ENOMEM;\n\n\tfw_download->parent = &connection->bundle->dev;\n\tINIT_LIST_HEAD(&fw_download->fw_requests);\n\tida_init(&fw_download->id_map);\n\tgb_connection_set_data(connection, fw_download);\n\tfw_download->connection = connection;\n\tmutex_init(&fw_download->mutex);\n\n\tret = gb_connection_enable(connection);\n\tif (ret)\n\t\tgoto err_destroy_id_map;\n\n\treturn 0;\n\nerr_destroy_id_map:\n\tida_destroy(&fw_download->id_map);\n\tkfree(fw_download);\n\n\treturn ret;\n}\n\nvoid gb_fw_download_connection_exit(struct gb_connection *connection)\n{\n\tstruct fw_download *fw_download;\n\tstruct fw_request *fw_req, *tmp;\n\n\tif (!connection)\n\t\treturn;\n\n\tfw_download = gb_connection_get_data(connection);\n\tgb_connection_disable(fw_download->connection);\n\n\t \n\tmutex_lock(&fw_download->mutex);\n\tlist_for_each_entry(fw_req, &fw_download->fw_requests, node)\n\t\tkref_get(&fw_req->kref);\n\tmutex_unlock(&fw_download->mutex);\n\n\t \n\tlist_for_each_entry_safe(fw_req, tmp, &fw_download->fw_requests, node) {\n\t\tcancel_delayed_work_sync(&fw_req->dwork);\n\t\tfree_firmware(fw_download, fw_req);\n\t\tput_fw_req(fw_req);\n\t}\n\n\tida_destroy(&fw_download->id_map);\n\tkfree(fw_download);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}