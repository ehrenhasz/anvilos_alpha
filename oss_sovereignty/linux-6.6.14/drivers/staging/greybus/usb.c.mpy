{
  "module_name": "usb.c",
  "hash_id": "0b4f1247829d64040bc2cb83bdd23a9272165c79235a14a158095e1a8bdbabbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/usb.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/greybus.h>\n\n#include \"gbphy.h\"\n\n \n#define GB_USB_TYPE_HCD_START\t\t0x02\n#define GB_USB_TYPE_HCD_STOP\t\t0x03\n#define GB_USB_TYPE_HUB_CONTROL\t\t0x04\n\nstruct gb_usb_hub_control_request {\n\t__le16 typeReq;\n\t__le16 wValue;\n\t__le16 wIndex;\n\t__le16 wLength;\n};\n\nstruct gb_usb_hub_control_response {\n\tDECLARE_FLEX_ARRAY(u8, buf);\n};\n\nstruct gb_usb_device {\n\tstruct gb_connection *connection;\n\tstruct gbphy_device *gbphy_dev;\n};\n\nstatic inline struct gb_usb_device *to_gb_usb_device(struct usb_hcd *hcd)\n{\n\treturn (struct gb_usb_device *)hcd->hcd_priv;\n}\n\nstatic inline struct usb_hcd *gb_usb_device_to_hcd(struct gb_usb_device *dev)\n{\n\treturn container_of((void *)dev, struct usb_hcd, hcd_priv);\n}\n\nstatic void hcd_stop(struct usb_hcd *hcd)\n{\n\tstruct gb_usb_device *dev = to_gb_usb_device(hcd);\n\tint ret;\n\n\tret = gb_operation_sync(dev->connection, GB_USB_TYPE_HCD_STOP,\n\t\t\t\tNULL, 0, NULL, 0);\n\tif (ret)\n\t\tdev_err(&dev->gbphy_dev->dev, \"HCD stop failed '%d'\\n\", ret);\n}\n\nstatic int hcd_start(struct usb_hcd *hcd)\n{\n\tstruct usb_bus *bus = hcd_to_bus(hcd);\n\tstruct gb_usb_device *dev = to_gb_usb_device(hcd);\n\tint ret;\n\n\tret = gb_operation_sync(dev->connection, GB_USB_TYPE_HCD_START,\n\t\t\t\tNULL, 0, NULL, 0);\n\tif (ret) {\n\t\tdev_err(&dev->gbphy_dev->dev, \"HCD start failed '%d'\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thcd->state = HC_STATE_RUNNING;\n\tif (bus->root_hub)\n\t\tusb_hcd_resume_root_hub(hcd);\n\treturn 0;\n}\n\nstatic int urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)\n{\n\treturn -ENXIO;\n}\n\nstatic int urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\treturn -ENXIO;\n}\n\nstatic int get_frame_number(struct usb_hcd *hcd)\n{\n\treturn 0;\n}\n\nstatic int hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\treturn 0;\n}\n\nstatic int hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,\n\t\t       char *buf, u16 wLength)\n{\n\tstruct gb_usb_device *dev = to_gb_usb_device(hcd);\n\tstruct gb_operation *operation;\n\tstruct gb_usb_hub_control_request *request;\n\tstruct gb_usb_hub_control_response *response;\n\tsize_t response_size;\n\tint ret;\n\n\t \n\tresponse_size = sizeof(*response) + wLength;\n\n\toperation = gb_operation_create(dev->connection,\n\t\t\t\t\tGB_USB_TYPE_HUB_CONTROL,\n\t\t\t\t\tsizeof(*request),\n\t\t\t\t\tresponse_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!operation)\n\t\treturn -ENOMEM;\n\n\trequest = operation->request->payload;\n\trequest->typeReq = cpu_to_le16(typeReq);\n\trequest->wValue = cpu_to_le16(wValue);\n\trequest->wIndex = cpu_to_le16(wIndex);\n\trequest->wLength = cpu_to_le16(wLength);\n\n\tret = gb_operation_request_send_sync(operation);\n\tif (ret)\n\t\tgoto out;\n\n\tif (wLength) {\n\t\t \n\t\tresponse = operation->response->payload;\n\t\tmemcpy(buf, response->buf, wLength);\n\t}\nout:\n\tgb_operation_put(operation);\n\n\treturn ret;\n}\n\nstatic const struct hc_driver usb_gb_hc_driver = {\n\t.description = \"greybus-hcd\",\n\t.product_desc = \"Greybus USB Host Controller\",\n\t.hcd_priv_size = sizeof(struct gb_usb_device),\n\n\t.flags = HCD_USB2,\n\n\t.start = hcd_start,\n\t.stop = hcd_stop,\n\n\t.urb_enqueue = urb_enqueue,\n\t.urb_dequeue = urb_dequeue,\n\n\t.get_frame_number = get_frame_number,\n\t.hub_status_data = hub_status_data,\n\t.hub_control = hub_control,\n};\n\nstatic int gb_usb_probe(struct gbphy_device *gbphy_dev,\n\t\t\tconst struct gbphy_device_id *id)\n{\n\tstruct gb_connection *connection;\n\tstruct device *dev = &gbphy_dev->dev;\n\tstruct gb_usb_device *gb_usb_dev;\n\tstruct usb_hcd *hcd;\n\tint retval;\n\n\thcd = usb_create_hcd(&usb_gb_hc_driver, dev, dev_name(dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tconnection = gb_connection_create(gbphy_dev->bundle,\n\t\t\t\t\t  le16_to_cpu(gbphy_dev->cport_desc->id),\n\t\t\t\t\t  NULL);\n\tif (IS_ERR(connection)) {\n\t\tretval = PTR_ERR(connection);\n\t\tgoto exit_usb_put;\n\t}\n\n\tgb_usb_dev = to_gb_usb_device(hcd);\n\tgb_usb_dev->connection = connection;\n\tgb_connection_set_data(connection, gb_usb_dev);\n\tgb_usb_dev->gbphy_dev = gbphy_dev;\n\tgb_gbphy_set_data(gbphy_dev, gb_usb_dev);\n\n\thcd->has_tt = 1;\n\n\tretval = gb_connection_enable(connection);\n\tif (retval)\n\t\tgoto exit_connection_destroy;\n\n\t \n\tif (1) {\n\t\tdev_warn(dev, \"USB protocol disabled\\n\");\n\t\tretval = -EPROTONOSUPPORT;\n\t\tgoto exit_connection_disable;\n\t}\n\n\tretval = usb_add_hcd(hcd, 0, 0);\n\tif (retval)\n\t\tgoto exit_connection_disable;\n\n\treturn 0;\n\nexit_connection_disable:\n\tgb_connection_disable(connection);\nexit_connection_destroy:\n\tgb_connection_destroy(connection);\nexit_usb_put:\n\tusb_put_hcd(hcd);\n\n\treturn retval;\n}\n\nstatic void gb_usb_remove(struct gbphy_device *gbphy_dev)\n{\n\tstruct gb_usb_device *gb_usb_dev = gb_gbphy_get_data(gbphy_dev);\n\tstruct gb_connection *connection = gb_usb_dev->connection;\n\tstruct usb_hcd *hcd = gb_usb_device_to_hcd(gb_usb_dev);\n\n\tusb_remove_hcd(hcd);\n\tgb_connection_disable(connection);\n\tgb_connection_destroy(connection);\n\tusb_put_hcd(hcd);\n}\n\nstatic const struct gbphy_device_id gb_usb_id_table[] = {\n\t{ GBPHY_PROTOCOL(GREYBUS_PROTOCOL_USB) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(gbphy, gb_usb_id_table);\n\nstatic struct gbphy_driver usb_driver = {\n\t.name\t\t= \"usb\",\n\t.probe\t\t= gb_usb_probe,\n\t.remove\t\t= gb_usb_remove,\n\t.id_table\t= gb_usb_id_table,\n};\n\nmodule_gbphy_driver(usb_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}