{
  "module_name": "bootrom.c",
  "hash_id": "edbd3bc61f489efac764315759d4dbe59c4f28df3ffe819a976573b445fcf2f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/bootrom.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/greybus.h>\n\n#include \"firmware.h\"\n\n \n#define NEXT_REQ_TIMEOUT_MS\t1000\n\n \n#define MODE_SWITCH_TIMEOUT_MS\t10000\n\nenum next_request_type {\n\tNEXT_REQ_FIRMWARE_SIZE,\n\tNEXT_REQ_GET_FIRMWARE,\n\tNEXT_REQ_READY_TO_BOOT,\n\tNEXT_REQ_MODE_SWITCH,\n};\n\nstruct gb_bootrom {\n\tstruct gb_connection\t*connection;\n\tconst struct firmware\t*fw;\n\tu8\t\t\tprotocol_major;\n\tu8\t\t\tprotocol_minor;\n\tenum next_request_type\tnext_request;\n\tstruct delayed_work\tdwork;\n\tstruct mutex\t\tmutex;  \n};\n\nstatic void free_firmware(struct gb_bootrom *bootrom)\n{\n\tif (!bootrom->fw)\n\t\treturn;\n\n\trelease_firmware(bootrom->fw);\n\tbootrom->fw = NULL;\n}\n\nstatic void gb_bootrom_timedout(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct gb_bootrom *bootrom = container_of(dwork,\n\t\t\t\t\t\t  struct gb_bootrom, dwork);\n\tstruct device *dev = &bootrom->connection->bundle->dev;\n\tconst char *reason;\n\n\tswitch (bootrom->next_request) {\n\tcase NEXT_REQ_FIRMWARE_SIZE:\n\t\treason = \"Firmware Size Request\";\n\t\tbreak;\n\tcase NEXT_REQ_GET_FIRMWARE:\n\t\treason = \"Get Firmware Request\";\n\t\tbreak;\n\tcase NEXT_REQ_READY_TO_BOOT:\n\t\treason = \"Ready to Boot Request\";\n\t\tbreak;\n\tcase NEXT_REQ_MODE_SWITCH:\n\t\treason = \"Interface Mode Switch\";\n\t\tbreak;\n\tdefault:\n\t\treason = NULL;\n\t\tdev_err(dev, \"Invalid next-request: %u\", bootrom->next_request);\n\t\tbreak;\n\t}\n\n\tdev_err(dev, \"Timed out waiting for %s from the Module\\n\", reason);\n\n\tmutex_lock(&bootrom->mutex);\n\tfree_firmware(bootrom);\n\tmutex_unlock(&bootrom->mutex);\n\n\t \n}\n\nstatic void gb_bootrom_set_timeout(struct gb_bootrom *bootrom,\n\t\t\t\t   enum next_request_type next,\n\t\t\t\t   unsigned long timeout)\n{\n\tbootrom->next_request = next;\n\tschedule_delayed_work(&bootrom->dwork, msecs_to_jiffies(timeout));\n}\n\nstatic void gb_bootrom_cancel_timeout(struct gb_bootrom *bootrom)\n{\n\tcancel_delayed_work_sync(&bootrom->dwork);\n}\n\n \nstatic void bootrom_es2_fixup_vid_pid(struct gb_bootrom *bootrom)\n{\n\tstruct gb_bootrom_get_vid_pid_response response;\n\tstruct gb_connection *connection = bootrom->connection;\n\tstruct gb_interface *intf = connection->bundle->intf;\n\tint ret;\n\n\tif (!(intf->quirks & GB_INTERFACE_QUIRK_NO_GMP_IDS))\n\t\treturn;\n\n\tret = gb_operation_sync(connection, GB_BOOTROM_TYPE_GET_VID_PID,\n\t\t\t\tNULL, 0, &response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&connection->bundle->dev,\n\t\t\t\"Bootrom get vid/pid operation failed (%d)\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tintf->vendor_id = le32_to_cpu(response.vendor_id);\n\tintf->product_id = le32_to_cpu(response.product_id);\n\n\tdev_dbg(&connection->bundle->dev, \"Bootrom got vid (0x%x)/pid (0x%x)\\n\",\n\t\tintf->vendor_id, intf->product_id);\n}\n\n \nstatic int find_firmware(struct gb_bootrom *bootrom, u8 stage)\n{\n\tstruct gb_connection *connection = bootrom->connection;\n\tstruct gb_interface *intf = connection->bundle->intf;\n\tchar firmware_name[49];\n\tint rc;\n\n\t \n\tfree_firmware(bootrom);\n\n\t \n\tif (stage != 2) {\n\t\tdev_err(&connection->bundle->dev, \"Invalid boot stage: %u\\n\",\n\t\t\tstage);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnprintf(firmware_name, sizeof(firmware_name),\n\t\t FW_NAME_PREFIX \"%08x_%08x_%08x_%08x_s2l.tftf\",\n\t\t intf->ddbl1_manufacturer_id, intf->ddbl1_product_id,\n\t\t intf->vendor_id, intf->product_id);\n\n\t \n\t \n\t \n\t \n\tdev_info(&connection->bundle->dev, \"Firmware file '%s' requested\\n\",\n\t\t firmware_name);\n\n\trc = request_firmware(&bootrom->fw, firmware_name,\n\t\t\t      &connection->bundle->dev);\n\tif (rc) {\n\t\tdev_err(&connection->bundle->dev,\n\t\t\t\"failed to find %s firmware (%d)\\n\", firmware_name, rc);\n\t}\n\n\treturn rc;\n}\n\nstatic int gb_bootrom_firmware_size_request(struct gb_operation *op)\n{\n\tstruct gb_bootrom *bootrom = gb_connection_get_data(op->connection);\n\tstruct gb_bootrom_firmware_size_request *size_request =\n\t\top->request->payload;\n\tstruct gb_bootrom_firmware_size_response *size_response;\n\tstruct device *dev = &op->connection->bundle->dev;\n\tint ret;\n\n\t \n\tgb_bootrom_cancel_timeout(bootrom);\n\n\tif (op->request->payload_size != sizeof(*size_request)) {\n\t\tdev_err(dev, \"%s: illegal size of firmware size request (%zu != %zu)\\n\",\n\t\t\t__func__, op->request->payload_size,\n\t\t\tsizeof(*size_request));\n\t\tret = -EINVAL;\n\t\tgoto queue_work;\n\t}\n\n\tmutex_lock(&bootrom->mutex);\n\n\tret = find_firmware(bootrom, size_request->stage);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (!gb_operation_response_alloc(op, sizeof(*size_response),\n\t\t\t\t\t GFP_KERNEL)) {\n\t\tdev_err(dev, \"%s: error allocating response\\n\", __func__);\n\t\tfree_firmware(bootrom);\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tsize_response = op->response->payload;\n\tsize_response->size = cpu_to_le32(bootrom->fw->size);\n\n\tdev_dbg(dev, \"%s: firmware size %d bytes\\n\",\n\t\t__func__, size_response->size);\n\nunlock:\n\tmutex_unlock(&bootrom->mutex);\n\nqueue_work:\n\tif (!ret) {\n\t\t \n\t\tgb_bootrom_set_timeout(bootrom, NEXT_REQ_GET_FIRMWARE,\n\t\t\t\t       NEXT_REQ_TIMEOUT_MS);\n\t}\n\n\treturn ret;\n}\n\nstatic int gb_bootrom_get_firmware(struct gb_operation *op)\n{\n\tstruct gb_bootrom *bootrom = gb_connection_get_data(op->connection);\n\tconst struct firmware *fw;\n\tstruct gb_bootrom_get_firmware_request *firmware_request;\n\tstruct gb_bootrom_get_firmware_response *firmware_response;\n\tstruct device *dev = &op->connection->bundle->dev;\n\tunsigned int offset, size;\n\tenum next_request_type next_request;\n\tint ret = 0;\n\n\t \n\tgb_bootrom_cancel_timeout(bootrom);\n\n\tif (op->request->payload_size != sizeof(*firmware_request)) {\n\t\tdev_err(dev, \"%s: Illegal size of get firmware request (%zu %zu)\\n\",\n\t\t\t__func__, op->request->payload_size,\n\t\t\tsizeof(*firmware_request));\n\t\tret = -EINVAL;\n\t\tgoto queue_work;\n\t}\n\n\tmutex_lock(&bootrom->mutex);\n\n\tfw = bootrom->fw;\n\tif (!fw) {\n\t\tdev_err(dev, \"%s: firmware not available\\n\", __func__);\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tfirmware_request = op->request->payload;\n\toffset = le32_to_cpu(firmware_request->offset);\n\tsize = le32_to_cpu(firmware_request->size);\n\n\tif (offset >= fw->size || size > fw->size - offset) {\n\t\tdev_warn(dev, \"bad firmware request (offs = %u, size = %u)\\n\",\n\t\t\t offset, size);\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (!gb_operation_response_alloc(op, sizeof(*firmware_response) + size,\n\t\t\t\t\t GFP_KERNEL)) {\n\t\tdev_err(dev, \"%s: error allocating response\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tfirmware_response = op->response->payload;\n\tmemcpy(firmware_response->data, fw->data + offset, size);\n\n\tdev_dbg(dev, \"responding with firmware (offs = %u, size = %u)\\n\",\n\t\toffset, size);\n\nunlock:\n\tmutex_unlock(&bootrom->mutex);\n\nqueue_work:\n\t \n\tif (!ret && (offset + size == fw->size))\n\t\tnext_request = NEXT_REQ_READY_TO_BOOT;\n\telse\n\t\tnext_request = NEXT_REQ_GET_FIRMWARE;\n\n\tgb_bootrom_set_timeout(bootrom, next_request, NEXT_REQ_TIMEOUT_MS);\n\n\treturn ret;\n}\n\nstatic int gb_bootrom_ready_to_boot(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct gb_bootrom *bootrom = gb_connection_get_data(connection);\n\tstruct gb_bootrom_ready_to_boot_request *rtb_request;\n\tstruct device *dev = &connection->bundle->dev;\n\tu8 status;\n\tint ret = 0;\n\n\t \n\tgb_bootrom_cancel_timeout(bootrom);\n\n\tif (op->request->payload_size != sizeof(*rtb_request)) {\n\t\tdev_err(dev, \"%s: Illegal size of ready to boot request (%zu %zu)\\n\",\n\t\t\t__func__, op->request->payload_size,\n\t\t\tsizeof(*rtb_request));\n\t\tret = -EINVAL;\n\t\tgoto queue_work;\n\t}\n\n\trtb_request = op->request->payload;\n\tstatus = rtb_request->status;\n\n\t \n\tif (status == GB_BOOTROM_BOOT_STATUS_INVALID) {\n\t\tret = -EINVAL;\n\t\tgoto queue_work;\n\t}\n\n\t \n\tdev_dbg(dev, \"ready to boot: 0x%x, 0\\n\", status);\n\nqueue_work:\n\t \n\tgb_bootrom_set_timeout(bootrom, NEXT_REQ_MODE_SWITCH,\n\t\t\t       MODE_SWITCH_TIMEOUT_MS);\n\n\treturn ret;\n}\n\nstatic int gb_bootrom_request_handler(struct gb_operation *op)\n{\n\tu8 type = op->type;\n\n\tswitch (type) {\n\tcase GB_BOOTROM_TYPE_FIRMWARE_SIZE:\n\t\treturn gb_bootrom_firmware_size_request(op);\n\tcase GB_BOOTROM_TYPE_GET_FIRMWARE:\n\t\treturn gb_bootrom_get_firmware(op);\n\tcase GB_BOOTROM_TYPE_READY_TO_BOOT:\n\t\treturn gb_bootrom_ready_to_boot(op);\n\tdefault:\n\t\tdev_err(&op->connection->bundle->dev,\n\t\t\t\"unsupported request: %u\\n\", type);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int gb_bootrom_get_version(struct gb_bootrom *bootrom)\n{\n\tstruct gb_bundle *bundle = bootrom->connection->bundle;\n\tstruct gb_bootrom_version_request request;\n\tstruct gb_bootrom_version_response response;\n\tint ret;\n\n\trequest.major = GB_BOOTROM_VERSION_MAJOR;\n\trequest.minor = GB_BOOTROM_VERSION_MINOR;\n\n\tret = gb_operation_sync(bootrom->connection,\n\t\t\t\tGB_BOOTROM_TYPE_VERSION,\n\t\t\t\t&request, sizeof(request), &response,\n\t\t\t\tsizeof(response));\n\tif (ret) {\n\t\tdev_err(&bundle->dev,\n\t\t\t\"failed to get protocol version: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (response.major > request.major) {\n\t\tdev_err(&bundle->dev,\n\t\t\t\"unsupported major protocol version (%u > %u)\\n\",\n\t\t\tresponse.major, request.major);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tbootrom->protocol_major = response.major;\n\tbootrom->protocol_minor = response.minor;\n\n\tdev_dbg(&bundle->dev, \"%s - %u.%u\\n\", __func__, response.major,\n\t\tresponse.minor);\n\n\treturn 0;\n}\n\nstatic int gb_bootrom_probe(struct gb_bundle *bundle,\n\t\t\t    const struct greybus_bundle_id *id)\n{\n\tstruct greybus_descriptor_cport *cport_desc;\n\tstruct gb_connection *connection;\n\tstruct gb_bootrom *bootrom;\n\tint ret;\n\n\tif (bundle->num_cports != 1)\n\t\treturn -ENODEV;\n\n\tcport_desc = &bundle->cport_desc[0];\n\tif (cport_desc->protocol_id != GREYBUS_PROTOCOL_BOOTROM)\n\t\treturn -ENODEV;\n\n\tbootrom = kzalloc(sizeof(*bootrom), GFP_KERNEL);\n\tif (!bootrom)\n\t\treturn -ENOMEM;\n\n\tconnection = gb_connection_create(bundle,\n\t\t\t\t\t  le16_to_cpu(cport_desc->id),\n\t\t\t\t\t  gb_bootrom_request_handler);\n\tif (IS_ERR(connection)) {\n\t\tret = PTR_ERR(connection);\n\t\tgoto err_free_bootrom;\n\t}\n\n\tgb_connection_set_data(connection, bootrom);\n\n\tbootrom->connection = connection;\n\n\tmutex_init(&bootrom->mutex);\n\tINIT_DELAYED_WORK(&bootrom->dwork, gb_bootrom_timedout);\n\tgreybus_set_drvdata(bundle, bootrom);\n\n\tret = gb_connection_enable_tx(connection);\n\tif (ret)\n\t\tgoto err_connection_destroy;\n\n\tret = gb_bootrom_get_version(bootrom);\n\tif (ret)\n\t\tgoto err_connection_disable;\n\n\tbootrom_es2_fixup_vid_pid(bootrom);\n\n\tret = gb_connection_enable(connection);\n\tif (ret)\n\t\tgoto err_connection_disable;\n\n\t \n\tgb_bootrom_set_timeout(bootrom, NEXT_REQ_FIRMWARE_SIZE,\n\t\t\t       NEXT_REQ_TIMEOUT_MS);\n\n\t \n\tret = gb_operation_sync(connection, GB_BOOTROM_TYPE_AP_READY, NULL, 0,\n\t\t\t\tNULL, 0);\n\tif (ret) {\n\t\tdev_err(&connection->bundle->dev,\n\t\t\t\"failed to send AP READY: %d\\n\", ret);\n\t\tgoto err_cancel_timeout;\n\t}\n\n\tdev_dbg(&bundle->dev, \"AP_READY sent\\n\");\n\n\treturn 0;\n\nerr_cancel_timeout:\n\tgb_bootrom_cancel_timeout(bootrom);\nerr_connection_disable:\n\tgb_connection_disable(connection);\nerr_connection_destroy:\n\tgb_connection_destroy(connection);\nerr_free_bootrom:\n\tkfree(bootrom);\n\n\treturn ret;\n}\n\nstatic void gb_bootrom_disconnect(struct gb_bundle *bundle)\n{\n\tstruct gb_bootrom *bootrom = greybus_get_drvdata(bundle);\n\n\tdev_dbg(&bundle->dev, \"%s\\n\", __func__);\n\n\tgb_connection_disable(bootrom->connection);\n\n\t \n\tgb_bootrom_cancel_timeout(bootrom);\n\n\t \n\tfree_firmware(bootrom);\n\n\tgb_connection_destroy(bootrom->connection);\n\tkfree(bootrom);\n}\n\nstatic const struct greybus_bundle_id gb_bootrom_id_table[] = {\n\t{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_BOOTROM) },\n\t{ }\n};\n\nstatic struct greybus_driver gb_bootrom_driver = {\n\t.name\t\t= \"bootrom\",\n\t.probe\t\t= gb_bootrom_probe,\n\t.disconnect\t= gb_bootrom_disconnect,\n\t.id_table\t= gb_bootrom_id_table,\n};\n\nmodule_greybus_driver(gb_bootrom_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}