{
  "module_name": "camera.c",
  "hash_id": "36a828ead10254c46d6263a9f8ceed4cb6b38b6e109f64ac4aa5480848d8a155",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/camera.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/greybus.h>\n\n#include \"gb-camera.h\"\n#include \"greybus_protocols.h\"\n\nenum gb_camera_debugs_buffer_id {\n\tGB_CAMERA_DEBUGFS_BUFFER_CAPABILITIES,\n\tGB_CAMERA_DEBUGFS_BUFFER_STREAMS,\n\tGB_CAMERA_DEBUGFS_BUFFER_CAPTURE,\n\tGB_CAMERA_DEBUGFS_BUFFER_FLUSH,\n\tGB_CAMERA_DEBUGFS_BUFFER_MAX,\n};\n\nstruct gb_camera_debugfs_buffer {\n\tchar data[PAGE_SIZE];\n\tsize_t length;\n};\n\nenum gb_camera_state {\n\tGB_CAMERA_STATE_UNCONFIGURED,\n\tGB_CAMERA_STATE_CONFIGURED,\n};\n\n \nstruct gb_camera {\n\tstruct gb_bundle *bundle;\n\tstruct gb_connection *connection;\n\tstruct gb_connection *data_connection;\n\tu16 data_cport_id;\n\n\tstruct mutex mutex;\n\tenum gb_camera_state state;\n\n\tstruct {\n\t\tstruct dentry *root;\n\t\tstruct gb_camera_debugfs_buffer *buffers;\n\t} debugfs;\n\n\tstruct gb_camera_module module;\n};\n\nstruct gb_camera_stream_config {\n\tunsigned int width;\n\tunsigned int height;\n\tunsigned int format;\n\tunsigned int vc;\n\tunsigned int dt[2];\n\tunsigned int max_size;\n};\n\nstruct gb_camera_fmt_info {\n\tenum v4l2_mbus_pixelcode mbus_code;\n\tunsigned int gb_format;\n\tunsigned int bpp;\n};\n\n \nstatic const struct gb_camera_fmt_info gb_fmt_info[] = {\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_UYVY8_1X16,\n\t\t.gb_format = 0x01,\n\t\t.bpp\t   = 16,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_NV12_1x8,\n\t\t.gb_format = 0x12,\n\t\t.bpp\t   = 12,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_NV21_1x8,\n\t\t.gb_format = 0x13,\n\t\t.bpp\t   = 12,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_YU12_1x8,\n\t\t.gb_format = 0x16,\n\t\t.bpp\t   = 12,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_YV12_1x8,\n\t\t.gb_format = 0x17,\n\t\t.bpp\t   = 12,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_JPEG_1X8,\n\t\t.gb_format = 0x40,\n\t\t.bpp\t   = 0,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_GB_CAM_METADATA_1X8,\n\t\t.gb_format = 0x41,\n\t\t.bpp\t   = 0,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_GB_CAM_DEBUG_DATA_1X8,\n\t\t.gb_format = 0x42,\n\t\t.bpp\t   = 0,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_SBGGR10_1X10,\n\t\t.gb_format = 0x80,\n\t\t.bpp\t   = 10,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_SGBRG10_1X10,\n\t\t.gb_format = 0x81,\n\t\t.bpp\t   = 10,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_SGRBG10_1X10,\n\t\t.gb_format = 0x82,\n\t\t.bpp\t   = 10,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_SRGGB10_1X10,\n\t\t.gb_format = 0x83,\n\t\t.bpp\t   = 10,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_SBGGR12_1X12,\n\t\t.gb_format = 0x84,\n\t\t.bpp\t   = 12,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_SGBRG12_1X12,\n\t\t.gb_format = 0x85,\n\t\t.bpp\t   = 12,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_SGRBG12_1X12,\n\t\t.gb_format = 0x86,\n\t\t.bpp\t   = 12,\n\t},\n\t{\n\t\t.mbus_code = V4L2_MBUS_FMT_SRGGB12_1X12,\n\t\t.gb_format = 0x87,\n\t\t.bpp\t   = 12,\n\t},\n};\n\nstatic const struct gb_camera_fmt_info *gb_camera_get_format_info(u16 gb_fmt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(gb_fmt_info); i++) {\n\t\tif (gb_fmt_info[i].gb_format == gb_fmt)\n\t\t\treturn &gb_fmt_info[i];\n\t}\n\n\treturn NULL;\n}\n\n#define ES2_APB_CDSI0_CPORT\t\t16\n#define ES2_APB_CDSI1_CPORT\t\t17\n\n#define GB_CAMERA_MAX_SETTINGS_SIZE\t8192\n\n#define gcam_dbg(gcam, format...)\tdev_dbg(&gcam->bundle->dev, format)\n#define gcam_info(gcam, format...)\tdev_info(&gcam->bundle->dev, format)\n#define gcam_err(gcam, format...)\tdev_err(&gcam->bundle->dev, format)\n\nstatic int gb_camera_operation_sync_flags(struct gb_connection *connection,\n\t\t\t\t\t  int type, unsigned int flags,\n\t\t\t\t\t  void *request, size_t request_size,\n\t\t\t\t\t  void *response, size_t *response_size)\n{\n\tstruct gb_operation *operation;\n\tint ret;\n\n\toperation = gb_operation_create_flags(connection, type, request_size,\n\t\t\t\t\t      *response_size, flags,\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!operation)\n\t\treturn  -ENOMEM;\n\n\tif (request_size)\n\t\tmemcpy(operation->request->payload, request, request_size);\n\n\tret = gb_operation_request_send_sync(operation);\n\tif (ret) {\n\t\tdev_err(&connection->hd->dev,\n\t\t\t\"%s: synchronous operation of type 0x%02x failed: %d\\n\",\n\t\t\tconnection->name, type, ret);\n\t} else {\n\t\t*response_size = operation->response->payload_size;\n\n\t\tif (operation->response->payload_size)\n\t\t\tmemcpy(response, operation->response->payload,\n\t\t\t       operation->response->payload_size);\n\t}\n\n\tgb_operation_put(operation);\n\n\treturn ret;\n}\n\nstatic int gb_camera_get_max_pkt_size(struct gb_camera *gcam,\n\t\tstruct gb_camera_configure_streams_response *resp)\n{\n\tunsigned int max_pkt_size = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < resp->num_streams; i++) {\n\t\tstruct gb_camera_stream_config_response *cfg = &resp->config[i];\n\t\tconst struct gb_camera_fmt_info *fmt_info;\n\t\tunsigned int pkt_size;\n\n\t\tfmt_info = gb_camera_get_format_info(cfg->format);\n\t\tif (!fmt_info) {\n\t\t\tgcam_err(gcam, \"unsupported greybus image format: %d\\n\",\n\t\t\t\t cfg->format);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (fmt_info->bpp == 0) {\n\t\t\tpkt_size = le32_to_cpu(cfg->max_pkt_size);\n\n\t\t\tif (pkt_size == 0) {\n\t\t\t\tgcam_err(gcam,\n\t\t\t\t\t \"Stream %u: invalid zero maximum packet size\\n\",\n\t\t\t\t\t i);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t} else {\n\t\t\tpkt_size = le16_to_cpu(cfg->width) * fmt_info->bpp / 8;\n\n\t\t\tif (pkt_size != le32_to_cpu(cfg->max_pkt_size)) {\n\t\t\t\tgcam_err(gcam,\n\t\t\t\t\t \"Stream %u: maximum packet size mismatch (%u/%u)\\n\",\n\t\t\t\t\t i, pkt_size, cfg->max_pkt_size);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\tmax_pkt_size = max(pkt_size, max_pkt_size);\n\t}\n\n\treturn max_pkt_size;\n}\n\n \nstatic const int gb_camera_configure_streams_validate_response(\n\t\tstruct gb_camera *gcam,\n\t\tstruct gb_camera_configure_streams_response *resp,\n\t\tunsigned int nstreams)\n{\n\tunsigned int i;\n\n\t \n\tif (resp->padding[0] || resp->padding[1]) {\n\t\tgcam_err(gcam, \"response padding != 0\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (resp->num_streams > nstreams) {\n\t\tgcam_err(gcam, \"got #streams %u > request %u\\n\",\n\t\t\t resp->num_streams, nstreams);\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < resp->num_streams; i++) {\n\t\tstruct gb_camera_stream_config_response *cfg = &resp->config[i];\n\n\t\tif (cfg->padding) {\n\t\t\tgcam_err(gcam, \"stream #%u padding != 0\\n\", i);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int gb_camera_set_intf_power_mode(struct gb_camera *gcam, u8 intf_id,\n\t\t\t\t\t bool hs)\n{\n\tstruct gb_svc *svc = gcam->connection->hd->svc;\n\tint ret;\n\n\tif (hs)\n\t\tret = gb_svc_intf_set_power_mode(svc, intf_id,\n\t\t\t\t\t\t GB_SVC_UNIPRO_HS_SERIES_A,\n\t\t\t\t\t\t GB_SVC_UNIPRO_FAST_MODE, 2, 2,\n\t\t\t\t\t\t GB_SVC_SMALL_AMPLITUDE,\n\t\t\t\t\t\t GB_SVC_NO_DE_EMPHASIS,\n\t\t\t\t\t\t GB_SVC_UNIPRO_FAST_MODE, 2, 2,\n\t\t\t\t\t\t GB_SVC_PWRM_RXTERMINATION |\n\t\t\t\t\t\t GB_SVC_PWRM_TXTERMINATION, 0,\n\t\t\t\t\t\t NULL, NULL);\n\telse\n\t\tret = gb_svc_intf_set_power_mode(svc, intf_id,\n\t\t\t\t\t\t GB_SVC_UNIPRO_HS_SERIES_A,\n\t\t\t\t\t\t GB_SVC_UNIPRO_SLOW_AUTO_MODE,\n\t\t\t\t\t\t 2, 1,\n\t\t\t\t\t\t GB_SVC_SMALL_AMPLITUDE,\n\t\t\t\t\t\t GB_SVC_NO_DE_EMPHASIS,\n\t\t\t\t\t\t GB_SVC_UNIPRO_SLOW_AUTO_MODE,\n\t\t\t\t\t\t 2, 1,\n\t\t\t\t\t\t 0, 0,\n\t\t\t\t\t\t NULL, NULL);\n\n\treturn ret;\n}\n\nstatic int gb_camera_set_power_mode(struct gb_camera *gcam, bool hs)\n{\n\tstruct gb_interface *intf = gcam->connection->intf;\n\tstruct gb_svc *svc = gcam->connection->hd->svc;\n\tint ret;\n\n\tret = gb_camera_set_intf_power_mode(gcam, intf->interface_id, hs);\n\tif (ret < 0) {\n\t\tgcam_err(gcam, \"failed to set module interface to %s (%d)\\n\",\n\t\t\t hs ? \"HS\" : \"PWM\", ret);\n\t\treturn ret;\n\t}\n\n\tret = gb_camera_set_intf_power_mode(gcam, svc->ap_intf_id, hs);\n\tif (ret < 0) {\n\t\tgb_camera_set_intf_power_mode(gcam, intf->interface_id, !hs);\n\t\tgcam_err(gcam, \"failed to set AP interface to %s (%d)\\n\",\n\t\t\t hs ? \"HS\" : \"PWM\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstruct ap_csi_config_request {\n\t__u8 csi_id;\n\t__u8 flags;\n#define GB_CAMERA_CSI_FLAG_CLOCK_CONTINUOUS 0x01\n\t__u8 num_lanes;\n\t__u8 padding;\n\t__le32 csi_clk_freq;\n\t__le32 max_pkt_size;\n} __packed;\n\n \n#define GB_CAMERA_CSI_NUM_DATA_LANES\t\t4\n\n#define GB_CAMERA_CSI_CLK_FREQ_MAX\t\t999000000U\n#define GB_CAMERA_CSI_CLK_FREQ_MIN\t\t100000000U\n#define GB_CAMERA_CSI_CLK_FREQ_MARGIN\t\t150000000U\n\nstatic int gb_camera_setup_data_connection(struct gb_camera *gcam,\n\t\tstruct gb_camera_configure_streams_response *resp,\n\t\tstruct gb_camera_csi_params *csi_params)\n{\n\tstruct ap_csi_config_request csi_cfg;\n\tstruct gb_connection *conn;\n\tunsigned int clk_freq;\n\tint ret;\n\n\t \n\tconn = gb_connection_create_offloaded(gcam->bundle, gcam->data_cport_id,\n\t\t\t\t\t      GB_CONNECTION_FLAG_NO_FLOWCTRL |\n\t\t\t\t\t      GB_CONNECTION_FLAG_CDSI1);\n\tif (IS_ERR(conn))\n\t\treturn PTR_ERR(conn);\n\n\tgcam->data_connection = conn;\n\tgb_connection_set_data(conn, gcam);\n\n\tret = gb_connection_enable(conn);\n\tif (ret)\n\t\tgoto error_conn_destroy;\n\n\t \n\tret = gb_camera_set_power_mode(gcam, true);\n\tif (ret < 0)\n\t\tgoto error_conn_disable;\n\n\t \n\tmemset(&csi_cfg, 0, sizeof(csi_cfg));\n\tcsi_cfg.csi_id = 1;\n\tcsi_cfg.flags = 0;\n\tcsi_cfg.num_lanes = GB_CAMERA_CSI_NUM_DATA_LANES;\n\n\tclk_freq = resp->data_rate / 2 / GB_CAMERA_CSI_NUM_DATA_LANES;\n\tclk_freq = clamp(clk_freq + GB_CAMERA_CSI_CLK_FREQ_MARGIN,\n\t\t\t GB_CAMERA_CSI_CLK_FREQ_MIN,\n\t\t\t GB_CAMERA_CSI_CLK_FREQ_MAX);\n\tcsi_cfg.csi_clk_freq = clk_freq;\n\n\tret = gb_camera_get_max_pkt_size(gcam, resp);\n\tif (ret < 0) {\n\t\tret = -EIO;\n\t\tgoto error_power;\n\t}\n\tcsi_cfg.max_pkt_size = ret;\n\n\tret = gb_hd_output(gcam->connection->hd, &csi_cfg,\n\t\t\t   sizeof(csi_cfg),\n\t\t\t   GB_APB_REQUEST_CSI_TX_CONTROL, false);\n\tif (ret < 0) {\n\t\tgcam_err(gcam, \"failed to start the CSI transmitter\\n\");\n\t\tgoto error_power;\n\t}\n\n\tif (csi_params) {\n\t\tcsi_params->clk_freq = csi_cfg.csi_clk_freq;\n\t\tcsi_params->num_lanes = csi_cfg.num_lanes;\n\t}\n\n\treturn 0;\n\nerror_power:\n\tgb_camera_set_power_mode(gcam, false);\nerror_conn_disable:\n\tgb_connection_disable(gcam->data_connection);\nerror_conn_destroy:\n\tgb_connection_destroy(gcam->data_connection);\n\tgcam->data_connection = NULL;\n\treturn ret;\n}\n\nstatic void gb_camera_teardown_data_connection(struct gb_camera *gcam)\n{\n\tstruct ap_csi_config_request csi_cfg;\n\tint ret;\n\n\t \n\tmemset(&csi_cfg, 0, sizeof(csi_cfg));\n\tcsi_cfg.csi_id = 1;\n\n\tret = gb_hd_output(gcam->connection->hd, &csi_cfg,\n\t\t\t   sizeof(csi_cfg),\n\t\t\t   GB_APB_REQUEST_CSI_TX_CONTROL, false);\n\n\tif (ret < 0)\n\t\tgcam_err(gcam, \"failed to stop the CSI transmitter\\n\");\n\n\t \n\tgb_camera_set_power_mode(gcam, false);\n\n\t \n\tgb_connection_disable(gcam->data_connection);\n\tgb_connection_destroy(gcam->data_connection);\n\tgcam->data_connection = NULL;\n}\n\n \n\nstatic int gb_camera_capabilities(struct gb_camera *gcam,\n\t\t\t\t  u8 *capabilities, size_t *size)\n{\n\tint ret;\n\n\tret = gb_pm_runtime_get_sync(gcam->bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&gcam->mutex);\n\n\tif (!gcam->connection) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tret = gb_camera_operation_sync_flags(gcam->connection,\n\t\t\t\t\t     GB_CAMERA_TYPE_CAPABILITIES,\n\t\t\t\t\t     GB_OPERATION_FLAG_SHORT_RESPONSE,\n\t\t\t\t\t     NULL, 0,\n\t\t\t\t\t     (void *)capabilities, size);\n\tif (ret)\n\t\tgcam_err(gcam, \"failed to retrieve capabilities: %d\\n\", ret);\n\ndone:\n\tmutex_unlock(&gcam->mutex);\n\n\tgb_pm_runtime_put_autosuspend(gcam->bundle);\n\n\treturn ret;\n}\n\nstatic int gb_camera_configure_streams(struct gb_camera *gcam,\n\t\t\t\t       unsigned int *num_streams,\n\t\t\t\t       unsigned int *flags,\n\t\t\t\t       struct gb_camera_stream_config *streams,\n\t\t\t\t       struct gb_camera_csi_params *csi_params)\n{\n\tstruct gb_camera_configure_streams_request *req;\n\tstruct gb_camera_configure_streams_response *resp;\n\tunsigned int nstreams = *num_streams;\n\tunsigned int i;\n\tsize_t req_size;\n\tsize_t resp_size;\n\tint ret;\n\n\tif (nstreams > GB_CAMERA_MAX_STREAMS)\n\t\treturn -EINVAL;\n\n\treq_size = sizeof(*req) + nstreams * sizeof(req->config[0]);\n\tresp_size = sizeof(*resp) + nstreams * sizeof(resp->config[0]);\n\n\treq = kmalloc(req_size, GFP_KERNEL);\n\tresp = kmalloc(resp_size, GFP_KERNEL);\n\tif (!req || !resp) {\n\t\tkfree(req);\n\t\tkfree(resp);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->num_streams = nstreams;\n\treq->flags = *flags;\n\treq->padding = 0;\n\n\tfor (i = 0; i < nstreams; ++i) {\n\t\tstruct gb_camera_stream_config_request *cfg = &req->config[i];\n\n\t\tcfg->width = cpu_to_le16(streams[i].width);\n\t\tcfg->height = cpu_to_le16(streams[i].height);\n\t\tcfg->format = cpu_to_le16(streams[i].format);\n\t\tcfg->padding = 0;\n\t}\n\n\tmutex_lock(&gcam->mutex);\n\n\tret = gb_pm_runtime_get_sync(gcam->bundle);\n\tif (ret)\n\t\tgoto done_skip_pm_put;\n\n\tif (!gcam->connection) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tret = gb_camera_operation_sync_flags(gcam->connection,\n\t\t\t\t\t     GB_CAMERA_TYPE_CONFIGURE_STREAMS,\n\t\t\t\t\t     GB_OPERATION_FLAG_SHORT_RESPONSE,\n\t\t\t\t\t     req, req_size,\n\t\t\t\t\t     resp, &resp_size);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = gb_camera_configure_streams_validate_response(gcam, resp,\n\t\t\t\t\t\t\t    nstreams);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t*flags = resp->flags;\n\t*num_streams = resp->num_streams;\n\n\tfor (i = 0; i < resp->num_streams; ++i) {\n\t\tstruct gb_camera_stream_config_response *cfg = &resp->config[i];\n\n\t\tstreams[i].width = le16_to_cpu(cfg->width);\n\t\tstreams[i].height = le16_to_cpu(cfg->height);\n\t\tstreams[i].format = le16_to_cpu(cfg->format);\n\t\tstreams[i].vc = cfg->virtual_channel;\n\t\tstreams[i].dt[0] = cfg->data_type[0];\n\t\tstreams[i].dt[1] = cfg->data_type[1];\n\t\tstreams[i].max_size = le32_to_cpu(cfg->max_size);\n\t}\n\n\tif ((resp->flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED) ||\n\t    (req->flags & GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY))\n\t\tgoto done;\n\n\tif (gcam->state == GB_CAMERA_STATE_CONFIGURED) {\n\t\tgb_camera_teardown_data_connection(gcam);\n\t\tgcam->state = GB_CAMERA_STATE_UNCONFIGURED;\n\n\t\t \n\t\tgb_pm_runtime_put_noidle(gcam->bundle);\n\t}\n\n\tif (resp->num_streams == 0)\n\t\tgoto done;\n\n\t \n\tgb_pm_runtime_get_noresume(gcam->bundle);\n\n\t \n\tret = gb_camera_setup_data_connection(gcam, resp, csi_params);\n\tif (ret < 0) {\n\t\tmemset(req, 0, sizeof(*req));\n\t\tgb_operation_sync(gcam->connection,\n\t\t\t\t  GB_CAMERA_TYPE_CONFIGURE_STREAMS,\n\t\t\t\t  req, sizeof(*req),\n\t\t\t\t  resp, sizeof(*resp));\n\t\t*flags = 0;\n\t\t*num_streams = 0;\n\t\tgb_pm_runtime_put_noidle(gcam->bundle);\n\t\tgoto done;\n\t}\n\n\tgcam->state = GB_CAMERA_STATE_CONFIGURED;\n\ndone:\n\tgb_pm_runtime_put_autosuspend(gcam->bundle);\n\ndone_skip_pm_put:\n\tmutex_unlock(&gcam->mutex);\n\tkfree(req);\n\tkfree(resp);\n\treturn ret;\n}\n\nstatic int gb_camera_capture(struct gb_camera *gcam, u32 request_id,\n\t\t\t     unsigned int streams, unsigned int num_frames,\n\t\t\t     size_t settings_size, const void *settings)\n{\n\tstruct gb_camera_capture_request *req;\n\tsize_t req_size;\n\tint ret;\n\n\tif (settings_size > GB_CAMERA_MAX_SETTINGS_SIZE)\n\t\treturn -EINVAL;\n\n\treq_size = sizeof(*req) + settings_size;\n\treq = kmalloc(req_size, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->request_id = cpu_to_le32(request_id);\n\treq->streams = streams;\n\treq->padding = 0;\n\treq->num_frames = cpu_to_le16(num_frames);\n\tmemcpy(req->settings, settings, settings_size);\n\n\tmutex_lock(&gcam->mutex);\n\n\tif (!gcam->connection) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tret = gb_operation_sync(gcam->connection, GB_CAMERA_TYPE_CAPTURE,\n\t\t\t\treq, req_size, NULL, 0);\ndone:\n\tmutex_unlock(&gcam->mutex);\n\n\tkfree(req);\n\n\treturn ret;\n}\n\nstatic int gb_camera_flush(struct gb_camera *gcam, u32 *request_id)\n{\n\tstruct gb_camera_flush_response resp;\n\tint ret;\n\n\tmutex_lock(&gcam->mutex);\n\n\tif (!gcam->connection) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tret = gb_operation_sync(gcam->connection, GB_CAMERA_TYPE_FLUSH, NULL, 0,\n\t\t\t\t&resp, sizeof(resp));\n\n\tif (ret < 0)\n\t\tgoto done;\n\n\tif (request_id)\n\t\t*request_id = le32_to_cpu(resp.request_id);\n\ndone:\n\tmutex_unlock(&gcam->mutex);\n\n\treturn ret;\n}\n\nstatic int gb_camera_request_handler(struct gb_operation *op)\n{\n\tstruct gb_camera *gcam = gb_connection_get_data(op->connection);\n\tstruct gb_camera_metadata_request *payload;\n\tstruct gb_message *request;\n\n\tif (op->type != GB_CAMERA_TYPE_METADATA) {\n\t\tgcam_err(gcam, \"Unsupported unsolicited event: %u\\n\", op->type);\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request;\n\n\tif (request->payload_size < sizeof(*payload)) {\n\t\tgcam_err(gcam, \"Wrong event size received (%zu < %zu)\\n\",\n\t\t\t request->payload_size, sizeof(*payload));\n\t\treturn -EINVAL;\n\t}\n\n\tpayload = request->payload;\n\n\tgcam_dbg(gcam, \"received metadata for request %u, frame %u, stream %u\\n\",\n\t\t payload->request_id, payload->frame_number, payload->stream);\n\n\treturn 0;\n}\n\n \nstatic unsigned int gb_camera_mbus_to_gb(enum v4l2_mbus_pixelcode mbus_code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(gb_fmt_info); i++) {\n\t\tif (gb_fmt_info[i].mbus_code == mbus_code)\n\t\t\treturn gb_fmt_info[i].gb_format;\n\t}\n\treturn gb_fmt_info[0].gb_format;\n}\n\nstatic enum v4l2_mbus_pixelcode gb_camera_gb_to_mbus(u16 gb_fmt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(gb_fmt_info); i++) {\n\t\tif (gb_fmt_info[i].gb_format == gb_fmt)\n\t\t\treturn gb_fmt_info[i].mbus_code;\n\t}\n\treturn gb_fmt_info[0].mbus_code;\n}\n\nstatic ssize_t gb_camera_op_capabilities(void *priv, char *data, size_t len)\n{\n\tstruct gb_camera *gcam = priv;\n\tsize_t capabilities_len = len;\n\tint ret;\n\n\tret = gb_camera_capabilities(gcam, data, &capabilities_len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn capabilities_len;\n}\n\nstatic int gb_camera_op_configure_streams(void *priv, unsigned int *nstreams,\n\t\tunsigned int *flags, struct gb_camera_stream *streams,\n\t\tstruct gb_camera_csi_params *csi_params)\n{\n\tstruct gb_camera *gcam = priv;\n\tstruct gb_camera_stream_config *gb_streams;\n\tunsigned int gb_flags = 0;\n\tunsigned int gb_nstreams = *nstreams;\n\tunsigned int i;\n\tint ret;\n\n\tif (gb_nstreams > GB_CAMERA_MAX_STREAMS)\n\t\treturn -EINVAL;\n\n\tgb_streams = kcalloc(gb_nstreams, sizeof(*gb_streams), GFP_KERNEL);\n\tif (!gb_streams)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < gb_nstreams; i++) {\n\t\tgb_streams[i].width = streams[i].width;\n\t\tgb_streams[i].height = streams[i].height;\n\t\tgb_streams[i].format =\n\t\t\tgb_camera_mbus_to_gb(streams[i].pixel_code);\n\t}\n\n\tif (*flags & GB_CAMERA_IN_FLAG_TEST)\n\t\tgb_flags |= GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY;\n\n\tret = gb_camera_configure_streams(gcam, &gb_nstreams,\n\t\t\t\t\t  &gb_flags, gb_streams, csi_params);\n\tif (ret < 0)\n\t\tgoto done;\n\tif (gb_nstreams > *nstreams) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t*flags = 0;\n\tif (gb_flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED)\n\t\t*flags |= GB_CAMERA_OUT_FLAG_ADJUSTED;\n\n\tfor (i = 0; i < gb_nstreams; i++) {\n\t\tstreams[i].width = gb_streams[i].width;\n\t\tstreams[i].height = gb_streams[i].height;\n\t\tstreams[i].vc = gb_streams[i].vc;\n\t\tstreams[i].dt[0] = gb_streams[i].dt[0];\n\t\tstreams[i].dt[1] = gb_streams[i].dt[1];\n\t\tstreams[i].max_size = gb_streams[i].max_size;\n\t\tstreams[i].pixel_code =\n\t\t\tgb_camera_gb_to_mbus(gb_streams[i].format);\n\t}\n\t*nstreams = gb_nstreams;\n\ndone:\n\tkfree(gb_streams);\n\treturn ret;\n}\n\nstatic int gb_camera_op_capture(void *priv, u32 request_id,\n\t\t\t\tunsigned int streams, unsigned int num_frames,\n\t\t\t\tsize_t settings_size, const void *settings)\n{\n\tstruct gb_camera *gcam = priv;\n\n\treturn gb_camera_capture(gcam, request_id, streams, num_frames,\n\t\t\t\t settings_size, settings);\n}\n\nstatic int gb_camera_op_flush(void *priv, u32 *request_id)\n{\n\tstruct gb_camera *gcam = priv;\n\n\treturn gb_camera_flush(gcam, request_id);\n}\n\nstatic const struct gb_camera_ops gb_cam_ops = {\n\t.capabilities = gb_camera_op_capabilities,\n\t.configure_streams = gb_camera_op_configure_streams,\n\t.capture = gb_camera_op_capture,\n\t.flush = gb_camera_op_flush,\n};\n\n \n\nstatic ssize_t gb_camera_debugfs_capabilities(struct gb_camera *gcam,\n\t\t\t\t\t      char *buf, size_t len)\n{\n\tstruct gb_camera_debugfs_buffer *buffer =\n\t\t&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_CAPABILITIES];\n\tsize_t size = 1024;\n\tunsigned int i;\n\tu8 *caps;\n\tint ret;\n\n\tcaps = kmalloc(size, GFP_KERNEL);\n\tif (!caps)\n\t\treturn -ENOMEM;\n\n\tret = gb_camera_capabilities(gcam, caps, &size);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t \n\tbuffer->length = 0;\n\n\tfor (i = 0; i < size; i += 16) {\n\t\tunsigned int nbytes = min_t(unsigned int, size - i, 16);\n\n\t\tbuffer->length += sprintf(buffer->data + buffer->length,\n\t\t\t\t\t  \"%*ph\\n\", nbytes, caps + i);\n\t}\n\ndone:\n\tkfree(caps);\n\treturn ret;\n}\n\nstatic ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,\n\t\t\t\t\t\t   char *buf, size_t len)\n{\n\tstruct gb_camera_debugfs_buffer *buffer =\n\t\t&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_STREAMS];\n\tstruct gb_camera_stream_config *streams;\n\tunsigned int nstreams;\n\tunsigned int flags;\n\tunsigned int i;\n\tchar *token;\n\tint ret;\n\n\t \n\ttoken = strsep(&buf, \";\");\n\tif (!token)\n\t\treturn -EINVAL;\n\n\tret = kstrtouint(token, 10, &nstreams);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (nstreams > GB_CAMERA_MAX_STREAMS)\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&buf, \";\");\n\tif (!token)\n\t\treturn -EINVAL;\n\n\tret = kstrtouint(token, 10, &flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tstreams = kcalloc(nstreams, sizeof(*streams), GFP_KERNEL);\n\tif (!streams)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nstreams; ++i) {\n\t\tstruct gb_camera_stream_config *stream = &streams[i];\n\n\t\t \n\t\ttoken = strsep(&buf, \";\");\n\t\tif (!token) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tret = kstrtouint(token, 10, &stream->width);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\t \n\t\ttoken = strsep(&buf, \";\");\n\t\tif (!token)\n\t\t\tgoto done;\n\n\t\tret = kstrtouint(token, 10, &stream->height);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\t \n\t\ttoken = strsep(&buf, \";\");\n\t\tif (!token)\n\t\t\tgoto done;\n\n\t\tret = kstrtouint(token, 16, &stream->format);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tret = gb_camera_configure_streams(gcam, &nstreams, &flags, streams,\n\t\t\t\t\t  NULL);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tbuffer->length = sprintf(buffer->data, \"%u;%u;\", nstreams, flags);\n\n\tfor (i = 0; i < nstreams; ++i) {\n\t\tstruct gb_camera_stream_config *stream = &streams[i];\n\n\t\tbuffer->length += sprintf(buffer->data + buffer->length,\n\t\t\t\t\t  \"%u;%u;%u;%u;%u;%u;%u;\",\n\t\t\t\t\t  stream->width, stream->height,\n\t\t\t\t\t  stream->format, stream->vc,\n\t\t\t\t\t  stream->dt[0], stream->dt[1],\n\t\t\t\t\t  stream->max_size);\n\t}\n\n\tret = len;\n\ndone:\n\tkfree(streams);\n\treturn ret;\n};\n\nstatic ssize_t gb_camera_debugfs_capture(struct gb_camera *gcam,\n\t\t\t\t\t char *buf, size_t len)\n{\n\tunsigned int request_id;\n\tunsigned int streams_mask;\n\tunsigned int num_frames;\n\tchar *token;\n\tint ret;\n\n\t \n\ttoken = strsep(&buf, \";\");\n\tif (!token)\n\t\treturn -EINVAL;\n\tret = kstrtouint(token, 10, &request_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ttoken = strsep(&buf, \";\");\n\tif (!token)\n\t\treturn -EINVAL;\n\tret = kstrtouint(token, 16, &streams_mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ttoken = strsep(&buf, \";\");\n\tif (!token)\n\t\treturn -EINVAL;\n\tret = kstrtouint(token, 10, &num_frames);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = gb_camera_capture(gcam, request_id, streams_mask, num_frames, 0,\n\t\t\t\tNULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t gb_camera_debugfs_flush(struct gb_camera *gcam,\n\t\t\t\t       char *buf, size_t len)\n{\n\tstruct gb_camera_debugfs_buffer *buffer =\n\t\t&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_FLUSH];\n\tunsigned int req_id;\n\tint ret;\n\n\tret = gb_camera_flush(gcam, &req_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbuffer->length = sprintf(buffer->data, \"%u\", req_id);\n\n\treturn len;\n}\n\nstruct gb_camera_debugfs_entry {\n\tconst char *name;\n\tunsigned int mask;\n\tunsigned int buffer;\n\tssize_t (*execute)(struct gb_camera *gcam, char *buf, size_t len);\n};\n\nstatic const struct gb_camera_debugfs_entry gb_camera_debugfs_entries[] = {\n\t{\n\t\t.name = \"capabilities\",\n\t\t.mask = S_IFREG | 0444,\n\t\t.buffer = GB_CAMERA_DEBUGFS_BUFFER_CAPABILITIES,\n\t\t.execute = gb_camera_debugfs_capabilities,\n\t}, {\n\t\t.name = \"configure_streams\",\n\t\t.mask = S_IFREG | 0666,\n\t\t.buffer = GB_CAMERA_DEBUGFS_BUFFER_STREAMS,\n\t\t.execute = gb_camera_debugfs_configure_streams,\n\t}, {\n\t\t.name = \"capture\",\n\t\t.mask = S_IFREG | 0666,\n\t\t.buffer = GB_CAMERA_DEBUGFS_BUFFER_CAPTURE,\n\t\t.execute = gb_camera_debugfs_capture,\n\t}, {\n\t\t.name = \"flush\",\n\t\t.mask = S_IFREG | 0666,\n\t\t.buffer = GB_CAMERA_DEBUGFS_BUFFER_FLUSH,\n\t\t.execute = gb_camera_debugfs_flush,\n\t},\n};\n\nstatic ssize_t gb_camera_debugfs_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t len, loff_t *offset)\n{\n\tconst struct gb_camera_debugfs_entry *op = file->private_data;\n\tstruct gb_camera *gcam = file_inode(file)->i_private;\n\tstruct gb_camera_debugfs_buffer *buffer;\n\tssize_t ret;\n\n\t \n\tif (!(op->mask & 0222)) {\n\t\tret = op->execute(gcam, NULL, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tbuffer = &gcam->debugfs.buffers[op->buffer];\n\n\treturn simple_read_from_buffer(buf, len, offset, buffer->data,\n\t\t\t\t       buffer->length);\n}\n\nstatic ssize_t gb_camera_debugfs_write(struct file *file,\n\t\t\t\t       const char __user *buf, size_t len,\n\t\t\t\t       loff_t *offset)\n{\n\tconst struct gb_camera_debugfs_entry *op = file->private_data;\n\tstruct gb_camera *gcam = file_inode(file)->i_private;\n\tssize_t ret;\n\tchar *kbuf;\n\n\tif (len > 1024)\n\t\treturn -EINVAL;\n\n\tkbuf = memdup_user_nul(buf, len);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tret = op->execute(gcam, kbuf, len);\n\ndone:\n\tkfree(kbuf);\n\treturn ret;\n}\n\nstatic int gb_camera_debugfs_open(struct inode *inode, struct file *file)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(gb_camera_debugfs_entries); ++i) {\n\t\tconst struct gb_camera_debugfs_entry *entry =\n\t\t\t&gb_camera_debugfs_entries[i];\n\n\t\tif (!strcmp(file->f_path.dentry->d_iname, entry->name)) {\n\t\t\tfile->private_data = (void *)entry;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct file_operations gb_camera_debugfs_ops = {\n\t.open = gb_camera_debugfs_open,\n\t.read = gb_camera_debugfs_read,\n\t.write = gb_camera_debugfs_write,\n};\n\nstatic int gb_camera_debugfs_init(struct gb_camera *gcam)\n{\n\tstruct gb_connection *connection = gcam->connection;\n\tchar dirname[27];\n\tunsigned int i;\n\n\t \n\tsnprintf(dirname, 27, \"camera-%u.%u\", connection->intf->interface_id,\n\t\t gcam->bundle->id);\n\n\tgcam->debugfs.root = debugfs_create_dir(dirname, gb_debugfs_get());\n\n\tgcam->debugfs.buffers =\n\t\tvmalloc(array_size(GB_CAMERA_DEBUGFS_BUFFER_MAX,\n\t\t\t\t   sizeof(*gcam->debugfs.buffers)));\n\tif (!gcam->debugfs.buffers)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(gb_camera_debugfs_entries); ++i) {\n\t\tconst struct gb_camera_debugfs_entry *entry =\n\t\t\t&gb_camera_debugfs_entries[i];\n\n\t\tgcam->debugfs.buffers[i].length = 0;\n\n\t\tdebugfs_create_file(entry->name, entry->mask,\n\t\t\t\t    gcam->debugfs.root, gcam,\n\t\t\t\t    &gb_camera_debugfs_ops);\n\t}\n\n\treturn 0;\n}\n\nstatic void gb_camera_debugfs_cleanup(struct gb_camera *gcam)\n{\n\tdebugfs_remove_recursive(gcam->debugfs.root);\n\n\tvfree(gcam->debugfs.buffers);\n}\n\n \n\nstatic void gb_camera_cleanup(struct gb_camera *gcam)\n{\n\tgb_camera_debugfs_cleanup(gcam);\n\n\tmutex_lock(&gcam->mutex);\n\tif (gcam->data_connection) {\n\t\tgb_connection_disable(gcam->data_connection);\n\t\tgb_connection_destroy(gcam->data_connection);\n\t\tgcam->data_connection = NULL;\n\t}\n\n\tif (gcam->connection) {\n\t\tgb_connection_disable(gcam->connection);\n\t\tgb_connection_destroy(gcam->connection);\n\t\tgcam->connection = NULL;\n\t}\n\tmutex_unlock(&gcam->mutex);\n}\n\nstatic void gb_camera_release_module(struct kref *ref)\n{\n\tstruct gb_camera_module *cam_mod =\n\t\tcontainer_of(ref, struct gb_camera_module, refcount);\n\tkfree(cam_mod->priv);\n}\n\nstatic int gb_camera_probe(struct gb_bundle *bundle,\n\t\t\t   const struct greybus_bundle_id *id)\n{\n\tstruct gb_connection *conn;\n\tstruct gb_camera *gcam;\n\tu16 mgmt_cport_id = 0;\n\tu16 data_cport_id = 0;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tif (bundle->num_cports != 2)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < bundle->num_cports; ++i) {\n\t\tstruct greybus_descriptor_cport *desc = &bundle->cport_desc[i];\n\n\t\tswitch (desc->protocol_id) {\n\t\tcase GREYBUS_PROTOCOL_CAMERA_MGMT:\n\t\t\tmgmt_cport_id = le16_to_cpu(desc->id);\n\t\t\tbreak;\n\t\tcase GREYBUS_PROTOCOL_CAMERA_DATA:\n\t\t\tdata_cport_id = le16_to_cpu(desc->id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (!mgmt_cport_id || !data_cport_id)\n\t\treturn -ENODEV;\n\n\tgcam = kzalloc(sizeof(*gcam), GFP_KERNEL);\n\tif (!gcam)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&gcam->mutex);\n\n\tgcam->bundle = bundle;\n\tgcam->state = GB_CAMERA_STATE_UNCONFIGURED;\n\tgcam->data_cport_id = data_cport_id;\n\n\tconn = gb_connection_create(bundle, mgmt_cport_id,\n\t\t\t\t    gb_camera_request_handler);\n\tif (IS_ERR(conn)) {\n\t\tret = PTR_ERR(conn);\n\t\tgoto error;\n\t}\n\n\tgcam->connection = conn;\n\tgb_connection_set_data(conn, gcam);\n\n\tret = gb_connection_enable(conn);\n\tif (ret)\n\t\tgoto error;\n\n\tret = gb_camera_debugfs_init(gcam);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tgcam->module.priv = gcam;\n\tgcam->module.ops = &gb_cam_ops;\n\tgcam->module.interface_id = gcam->connection->intf->interface_id;\n\tgcam->module.release = gb_camera_release_module;\n\tret = gb_camera_register(&gcam->module);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tgreybus_set_drvdata(bundle, gcam);\n\n\tgb_pm_runtime_put_autosuspend(gcam->bundle);\n\n\treturn 0;\n\nerror:\n\tgb_camera_cleanup(gcam);\n\tkfree(gcam);\n\treturn ret;\n}\n\nstatic void gb_camera_disconnect(struct gb_bundle *bundle)\n{\n\tstruct gb_camera *gcam = greybus_get_drvdata(bundle);\n\tint ret;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\tgb_pm_runtime_get_noresume(bundle);\n\n\tgb_camera_cleanup(gcam);\n\tgb_camera_unregister(&gcam->module);\n}\n\nstatic const struct greybus_bundle_id gb_camera_id_table[] = {\n\t{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_CAMERA) },\n\t{ },\n};\n\n#ifdef CONFIG_PM\nstatic int gb_camera_suspend(struct device *dev)\n{\n\tstruct gb_bundle *bundle = to_gb_bundle(dev);\n\tstruct gb_camera *gcam = greybus_get_drvdata(bundle);\n\n\tif (gcam->data_connection)\n\t\tgb_connection_disable(gcam->data_connection);\n\n\tgb_connection_disable(gcam->connection);\n\n\treturn 0;\n}\n\nstatic int gb_camera_resume(struct device *dev)\n{\n\tstruct gb_bundle *bundle = to_gb_bundle(dev);\n\tstruct gb_camera *gcam = greybus_get_drvdata(bundle);\n\tint ret;\n\n\tret = gb_connection_enable(gcam->connection);\n\tif (ret) {\n\t\tgcam_err(gcam, \"failed to enable connection: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (gcam->data_connection) {\n\t\tret = gb_connection_enable(gcam->data_connection);\n\t\tif (ret) {\n\t\t\tgcam_err(gcam,\n\t\t\t\t \"failed to enable data connection: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops gb_camera_pm_ops = {\n\tSET_RUNTIME_PM_OPS(gb_camera_suspend, gb_camera_resume, NULL)\n};\n\nstatic struct greybus_driver gb_camera_driver = {\n\t.name\t\t= \"camera\",\n\t.probe\t\t= gb_camera_probe,\n\t.disconnect\t= gb_camera_disconnect,\n\t.id_table\t= gb_camera_id_table,\n\t.driver.pm\t= &gb_camera_pm_ops,\n};\n\nmodule_greybus_driver(gb_camera_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}