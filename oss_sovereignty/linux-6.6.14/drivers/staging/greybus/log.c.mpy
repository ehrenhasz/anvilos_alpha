{
  "module_name": "log.c",
  "hash_id": "7e2e28233197a4f621563d2e49e3868499a4952631fed3b8d1a4d46edc90b611",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/log.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/uaccess.h>\n#include <linux/greybus.h>\n\nstruct gb_log {\n\tstruct gb_connection *connection;\n};\n\nstatic int gb_log_request_handler(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct device *dev = &connection->bundle->dev;\n\tstruct gb_log_send_log_request *receive;\n\tu16 len;\n\n\tif (op->type != GB_LOG_TYPE_SEND_LOG) {\n\t\tdev_err(dev, \"unknown request type 0x%02x\\n\", op->type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (op->request->payload_size < sizeof(*receive)) {\n\t\tdev_err(dev, \"log request too small (%zu < %zu)\\n\",\n\t\t\top->request->payload_size, sizeof(*receive));\n\t\treturn -EINVAL;\n\t}\n\treceive = op->request->payload;\n\tlen = le16_to_cpu(receive->len);\n\tif (len != (op->request->payload_size - sizeof(*receive))) {\n\t\tdev_err(dev, \"log request wrong size %d vs %zu\\n\", len,\n\t\t\t(op->request->payload_size - sizeof(*receive)));\n\t\treturn -EINVAL;\n\t}\n\tif (len == 0) {\n\t\tdev_err(dev, \"log request of 0 bytes?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (len > GB_LOG_MAX_LEN) {\n\t\tdev_err(dev, \"log request too big: %d\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treceive->msg[len - 1] = '\\0';\n\n\t \n\tdev_dbg(dev, \"%s\", receive->msg);\n\n\treturn 0;\n}\n\nstatic int gb_log_probe(struct gb_bundle *bundle,\n\t\t\tconst struct greybus_bundle_id *id)\n{\n\tstruct greybus_descriptor_cport *cport_desc;\n\tstruct gb_connection *connection;\n\tstruct gb_log *log;\n\tint retval;\n\n\tif (bundle->num_cports != 1)\n\t\treturn -ENODEV;\n\n\tcport_desc = &bundle->cport_desc[0];\n\tif (cport_desc->protocol_id != GREYBUS_PROTOCOL_LOG)\n\t\treturn -ENODEV;\n\n\tlog = kzalloc(sizeof(*log), GFP_KERNEL);\n\tif (!log)\n\t\treturn -ENOMEM;\n\n\tconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\n\t\t\t\t\t  gb_log_request_handler);\n\tif (IS_ERR(connection)) {\n\t\tretval = PTR_ERR(connection);\n\t\tgoto error_free;\n\t}\n\n\tlog->connection = connection;\n\tgreybus_set_drvdata(bundle, log);\n\n\tretval = gb_connection_enable(connection);\n\tif (retval)\n\t\tgoto error_connection_destroy;\n\n\treturn 0;\n\nerror_connection_destroy:\n\tgb_connection_destroy(connection);\nerror_free:\n\tkfree(log);\n\treturn retval;\n}\n\nstatic void gb_log_disconnect(struct gb_bundle *bundle)\n{\n\tstruct gb_log *log = greybus_get_drvdata(bundle);\n\tstruct gb_connection *connection = log->connection;\n\n\tgb_connection_disable(connection);\n\tgb_connection_destroy(connection);\n\n\tkfree(log);\n}\n\nstatic const struct greybus_bundle_id gb_log_id_table[] = {\n\t{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_LOG) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(greybus, gb_log_id_table);\n\nstatic struct greybus_driver gb_log_driver = {\n\t.name           = \"log\",\n\t.probe          = gb_log_probe,\n\t.disconnect     = gb_log_disconnect,\n\t.id_table       = gb_log_id_table,\n};\nmodule_greybus_driver(gb_log_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}