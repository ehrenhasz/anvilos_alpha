{
  "module_name": "raw.c",
  "hash_id": "e7287bfb57b0dbae1810a2f08e7b9b3b4e0aa28418161d26a0773b7290bd13d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/raw.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/cdev.h>\n#include <linux/fs.h>\n#include <linux/idr.h>\n#include <linux/uaccess.h>\n#include <linux/greybus.h>\n\nstruct gb_raw {\n\tstruct gb_connection *connection;\n\n\tstruct list_head list;\n\tint list_data;\n\tstruct mutex list_lock;\n\tdev_t dev;\n\tstruct cdev cdev;\n\tstruct device *device;\n};\n\nstruct raw_data {\n\tstruct list_head entry;\n\tu32 len;\n\tu8 data[];\n};\n\nstatic struct class *raw_class;\nstatic int raw_major;\nstatic const struct file_operations raw_fops;\nstatic DEFINE_IDA(minors);\n\n \n#define NUM_MINORS\t256\n\n \n#define MAX_PACKET_SIZE\t(PAGE_SIZE * 2)\n\n \n#define MAX_DATA_SIZE\t(MAX_PACKET_SIZE * 8)\n\n \nstatic int receive_data(struct gb_raw *raw, u32 len, u8 *data)\n{\n\tstruct raw_data *raw_data;\n\tstruct device *dev = &raw->connection->bundle->dev;\n\tint retval = 0;\n\n\tif (len > MAX_PACKET_SIZE) {\n\t\tdev_err(dev, \"Too big of a data packet, rejected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&raw->list_lock);\n\tif ((raw->list_data + len) > MAX_DATA_SIZE) {\n\t\tdev_err(dev, \"Too much data in receive buffer, now dropping packets\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\traw_data = kmalloc(sizeof(*raw_data) + len, GFP_KERNEL);\n\tif (!raw_data) {\n\t\tretval = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\traw->list_data += len;\n\traw_data->len = len;\n\tmemcpy(&raw_data->data[0], data, len);\n\n\tlist_add_tail(&raw_data->entry, &raw->list);\nexit:\n\tmutex_unlock(&raw->list_lock);\n\treturn retval;\n}\n\nstatic int gb_raw_request_handler(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct device *dev = &connection->bundle->dev;\n\tstruct gb_raw *raw = greybus_get_drvdata(connection->bundle);\n\tstruct gb_raw_send_request *receive;\n\tu32 len;\n\n\tif (op->type != GB_RAW_TYPE_SEND) {\n\t\tdev_err(dev, \"unknown request type 0x%02x\\n\", op->type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (op->request->payload_size < sizeof(*receive)) {\n\t\tdev_err(dev, \"raw receive request too small (%zu < %zu)\\n\",\n\t\t\top->request->payload_size, sizeof(*receive));\n\t\treturn -EINVAL;\n\t}\n\treceive = op->request->payload;\n\tlen = le32_to_cpu(receive->len);\n\tif (len != (int)(op->request->payload_size - sizeof(__le32))) {\n\t\tdev_err(dev, \"raw receive request wrong size %d vs %d\\n\", len,\n\t\t\t(int)(op->request->payload_size - sizeof(__le32)));\n\t\treturn -EINVAL;\n\t}\n\tif (len == 0) {\n\t\tdev_err(dev, \"raw receive request of 0 bytes?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn receive_data(raw, len, receive->data);\n}\n\nstatic int gb_raw_send(struct gb_raw *raw, u32 len, const char __user *data)\n{\n\tstruct gb_connection *connection = raw->connection;\n\tstruct gb_raw_send_request *request;\n\tint retval;\n\n\trequest = kmalloc(len + sizeof(*request), GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(&request->data[0], data, len)) {\n\t\tkfree(request);\n\t\treturn -EFAULT;\n\t}\n\n\trequest->len = cpu_to_le32(len);\n\n\tretval = gb_operation_sync(connection, GB_RAW_TYPE_SEND,\n\t\t\t\t   request, len + sizeof(*request),\n\t\t\t\t   NULL, 0);\n\n\tkfree(request);\n\treturn retval;\n}\n\nstatic int gb_raw_probe(struct gb_bundle *bundle,\n\t\t\tconst struct greybus_bundle_id *id)\n{\n\tstruct greybus_descriptor_cport *cport_desc;\n\tstruct gb_connection *connection;\n\tstruct gb_raw *raw;\n\tint retval;\n\tint minor;\n\n\tif (bundle->num_cports != 1)\n\t\treturn -ENODEV;\n\n\tcport_desc = &bundle->cport_desc[0];\n\tif (cport_desc->protocol_id != GREYBUS_PROTOCOL_RAW)\n\t\treturn -ENODEV;\n\n\traw = kzalloc(sizeof(*raw), GFP_KERNEL);\n\tif (!raw)\n\t\treturn -ENOMEM;\n\n\tconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\n\t\t\t\t\t  gb_raw_request_handler);\n\tif (IS_ERR(connection)) {\n\t\tretval = PTR_ERR(connection);\n\t\tgoto error_free;\n\t}\n\n\tINIT_LIST_HEAD(&raw->list);\n\tmutex_init(&raw->list_lock);\n\n\traw->connection = connection;\n\tgreybus_set_drvdata(bundle, raw);\n\n\tminor = ida_simple_get(&minors, 0, 0, GFP_KERNEL);\n\tif (minor < 0) {\n\t\tretval = minor;\n\t\tgoto error_connection_destroy;\n\t}\n\n\traw->dev = MKDEV(raw_major, minor);\n\tcdev_init(&raw->cdev, &raw_fops);\n\n\tretval = gb_connection_enable(connection);\n\tif (retval)\n\t\tgoto error_remove_ida;\n\n\tretval = cdev_add(&raw->cdev, raw->dev, 1);\n\tif (retval)\n\t\tgoto error_connection_disable;\n\n\traw->device = device_create(raw_class, &connection->bundle->dev,\n\t\t\t\t    raw->dev, raw, \"gb!raw%d\", minor);\n\tif (IS_ERR(raw->device)) {\n\t\tretval = PTR_ERR(raw->device);\n\t\tgoto error_del_cdev;\n\t}\n\n\treturn 0;\n\nerror_del_cdev:\n\tcdev_del(&raw->cdev);\n\nerror_connection_disable:\n\tgb_connection_disable(connection);\n\nerror_remove_ida:\n\tida_simple_remove(&minors, minor);\n\nerror_connection_destroy:\n\tgb_connection_destroy(connection);\n\nerror_free:\n\tkfree(raw);\n\treturn retval;\n}\n\nstatic void gb_raw_disconnect(struct gb_bundle *bundle)\n{\n\tstruct gb_raw *raw = greybus_get_drvdata(bundle);\n\tstruct gb_connection *connection = raw->connection;\n\tstruct raw_data *raw_data;\n\tstruct raw_data *temp;\n\n\t\n\tdevice_destroy(raw_class, raw->dev);\n\tcdev_del(&raw->cdev);\n\tgb_connection_disable(connection);\n\tida_simple_remove(&minors, MINOR(raw->dev));\n\tgb_connection_destroy(connection);\n\n\tmutex_lock(&raw->list_lock);\n\tlist_for_each_entry_safe(raw_data, temp, &raw->list, entry) {\n\t\tlist_del(&raw_data->entry);\n\t\tkfree(raw_data);\n\t}\n\tmutex_unlock(&raw->list_lock);\n\n\tkfree(raw);\n}\n\n \n\nstatic int raw_open(struct inode *inode, struct file *file)\n{\n\tstruct cdev *cdev = inode->i_cdev;\n\tstruct gb_raw *raw = container_of(cdev, struct gb_raw, cdev);\n\n\tfile->private_data = raw;\n\treturn 0;\n}\n\nstatic ssize_t raw_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct gb_raw *raw = file->private_data;\n\tint retval;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (count > MAX_PACKET_SIZE)\n\t\treturn -E2BIG;\n\n\tretval = gb_raw_send(raw, count, buf);\n\tif (retval)\n\t\treturn retval;\n\n\treturn count;\n}\n\nstatic ssize_t raw_read(struct file *file, char __user *buf, size_t count,\n\t\t\tloff_t *ppos)\n{\n\tstruct gb_raw *raw = file->private_data;\n\tint retval = 0;\n\tstruct raw_data *raw_data;\n\n\tmutex_lock(&raw->list_lock);\n\tif (list_empty(&raw->list))\n\t\tgoto exit;\n\n\traw_data = list_first_entry(&raw->list, struct raw_data, entry);\n\tif (raw_data->len > count) {\n\t\tretval = -ENOSPC;\n\t\tgoto exit;\n\t}\n\n\tif (copy_to_user(buf, &raw_data->data[0], raw_data->len)) {\n\t\tretval = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\tlist_del(&raw_data->entry);\n\traw->list_data -= raw_data->len;\n\tretval = raw_data->len;\n\tkfree(raw_data);\n\nexit:\n\tmutex_unlock(&raw->list_lock);\n\treturn retval;\n}\n\nstatic const struct file_operations raw_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.write\t\t= raw_write,\n\t.read\t\t= raw_read,\n\t.open\t\t= raw_open,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic const struct greybus_bundle_id gb_raw_id_table[] = {\n\t{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_RAW) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(greybus, gb_raw_id_table);\n\nstatic struct greybus_driver gb_raw_driver = {\n\t.name\t\t= \"raw\",\n\t.probe\t\t= gb_raw_probe,\n\t.disconnect\t= gb_raw_disconnect,\n\t.id_table\t= gb_raw_id_table,\n};\n\nstatic int raw_init(void)\n{\n\tdev_t dev;\n\tint retval;\n\n\traw_class = class_create(\"gb_raw\");\n\tif (IS_ERR(raw_class)) {\n\t\tretval = PTR_ERR(raw_class);\n\t\tgoto error_class;\n\t}\n\n\tretval = alloc_chrdev_region(&dev, 0, NUM_MINORS, \"gb_raw\");\n\tif (retval < 0)\n\t\tgoto error_chrdev;\n\n\traw_major = MAJOR(dev);\n\n\tretval = greybus_register(&gb_raw_driver);\n\tif (retval)\n\t\tgoto error_gb;\n\n\treturn 0;\n\nerror_gb:\n\tunregister_chrdev_region(dev, NUM_MINORS);\nerror_chrdev:\n\tclass_destroy(raw_class);\nerror_class:\n\treturn retval;\n}\nmodule_init(raw_init);\n\nstatic void __exit raw_exit(void)\n{\n\tgreybus_deregister(&gb_raw_driver);\n\tunregister_chrdev_region(MKDEV(raw_major, 0), NUM_MINORS);\n\tclass_destroy(raw_class);\n\tida_destroy(&minors);\n}\nmodule_exit(raw_exit);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}