{
  "module_name": "power_supply.c",
  "hash_id": "a6223188ec29e48f90d4f176c96b40c0b426c681aa5312ad7c9071e5c58d594b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/power_supply.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n#include <linux/greybus.h>\n\n#define PROP_MAX 32\n\nstruct gb_power_supply_prop {\n\tenum power_supply_property\tprop;\n\tu8\t\t\t\tgb_prop;\n\tint\t\t\t\tval;\n\tint\t\t\t\tprevious_val;\n\tbool\t\t\t\tis_writeable;\n};\n\nstruct gb_power_supply {\n\tu8\t\t\t\tid;\n\tbool\t\t\t\tregistered;\n\tstruct power_supply\t\t*psy;\n\tstruct power_supply_desc\tdesc;\n\tchar\t\t\t\tname[64];\n\tstruct gb_power_supplies\t*supplies;\n\tstruct delayed_work\t\twork;\n\tchar\t\t\t\t*manufacturer;\n\tchar\t\t\t\t*model_name;\n\tchar\t\t\t\t*serial_number;\n\tu8\t\t\t\ttype;\n\tu8\t\t\t\tproperties_count;\n\tu8\t\t\t\tproperties_count_str;\n\tunsigned long\t\t\tlast_update;\n\tu8\t\t\t\tcache_invalid;\n\tunsigned int\t\t\tupdate_interval;\n\tbool\t\t\t\tchanged;\n\tstruct gb_power_supply_prop\t*props;\n\tenum power_supply_property\t*props_raw;\n\tbool\t\t\t\tpm_acquired;\n\tstruct mutex\t\t\tsupply_lock;\n};\n\nstruct gb_power_supplies {\n\tstruct gb_connection\t*connection;\n\tu8\t\t\tsupplies_count;\n\tstruct gb_power_supply\t*supply;\n\tstruct mutex\t\tsupplies_lock;\n};\n\n#define to_gb_power_supply(x) power_supply_get_drvdata(x)\n\n \n#ifndef POWER_SUPPLY_PROP_VOLTAGE_BOOT\n\t#define POWER_SUPPLY_PROP_VOLTAGE_BOOT\t-1\n#endif\n#ifndef POWER_SUPPLY_PROP_CURRENT_BOOT\n\t#define POWER_SUPPLY_PROP_CURRENT_BOOT\t-1\n#endif\n#ifndef POWER_SUPPLY_PROP_CALIBRATE\n\t#define POWER_SUPPLY_PROP_CALIBRATE\t-1\n#endif\n\n \nstatic unsigned int cache_time = 1000;\n \nstatic unsigned int update_interval_init = 1 * HZ;\nstatic unsigned int update_interval_max = 30 * HZ;\n\nstruct gb_power_supply_changes {\n\tenum power_supply_property\tprop;\n\tu32\t\t\t\ttolerance_change;\n\tvoid (*prop_changed)(struct gb_power_supply *gbpsy,\n\t\t\t     struct gb_power_supply_prop *prop);\n};\n\nstatic void gb_power_supply_state_change(struct gb_power_supply *gbpsy,\n\t\t\t\t\t struct gb_power_supply_prop *prop);\n\nstatic const struct gb_power_supply_changes psy_props_changes[] = {\n\t{\t.prop\t\t\t= GB_POWER_SUPPLY_PROP_STATUS,\n\t\t.tolerance_change\t= 0,\n\t\t.prop_changed\t\t= gb_power_supply_state_change,\n\t},\n\t{\t.prop\t\t\t= GB_POWER_SUPPLY_PROP_TEMP,\n\t\t.tolerance_change\t= 500,\n\t\t.prop_changed\t\t= NULL,\n\t},\n\t{\t.prop\t\t\t= GB_POWER_SUPPLY_PROP_ONLINE,\n\t\t.tolerance_change\t= 0,\n\t\t.prop_changed\t\t= NULL,\n\t},\n};\n\nstatic int get_psp_from_gb_prop(int gb_prop, enum power_supply_property *psp)\n{\n\tint prop;\n\n\tswitch (gb_prop) {\n\tcase GB_POWER_SUPPLY_PROP_STATUS:\n\t\tprop = POWER_SUPPLY_PROP_STATUS;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tprop = POWER_SUPPLY_PROP_CHARGE_TYPE;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_HEALTH:\n\t\tprop = POWER_SUPPLY_PROP_HEALTH;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_PRESENT:\n\t\tprop = POWER_SUPPLY_PROP_PRESENT;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_ONLINE:\n\t\tprop = POWER_SUPPLY_PROP_ONLINE;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_AUTHENTIC:\n\t\tprop = POWER_SUPPLY_PROP_AUTHENTIC;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tprop = POWER_SUPPLY_PROP_TECHNOLOGY;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CYCLE_COUNT:\n\t\tprop = POWER_SUPPLY_PROP_CYCLE_COUNT;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\tprop = POWER_SUPPLY_PROP_VOLTAGE_MAX;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\t\tprop = POWER_SUPPLY_PROP_VOLTAGE_MIN;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\tprop = POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\tprop = POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tprop = POWER_SUPPLY_PROP_VOLTAGE_NOW;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\tprop = POWER_SUPPLY_PROP_VOLTAGE_AVG;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_VOLTAGE_OCV:\n\t\tprop = POWER_SUPPLY_PROP_VOLTAGE_OCV;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_VOLTAGE_BOOT:\n\t\tprop = POWER_SUPPLY_PROP_VOLTAGE_BOOT;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tprop = POWER_SUPPLY_PROP_CURRENT_MAX;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tprop = POWER_SUPPLY_PROP_CURRENT_NOW;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\tprop = POWER_SUPPLY_PROP_CURRENT_AVG;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CURRENT_BOOT:\n\t\tprop = POWER_SUPPLY_PROP_CURRENT_BOOT;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_POWER_NOW:\n\t\tprop = POWER_SUPPLY_PROP_POWER_NOW;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_POWER_AVG:\n\t\tprop = POWER_SUPPLY_PROP_POWER_AVG;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\tprop = POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN:\n\t\tprop = POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\tprop = POWER_SUPPLY_PROP_CHARGE_FULL;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CHARGE_EMPTY:\n\t\tprop = POWER_SUPPLY_PROP_CHARGE_EMPTY;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tprop = POWER_SUPPLY_PROP_CHARGE_NOW;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CHARGE_AVG:\n\t\tprop = POWER_SUPPLY_PROP_CHARGE_AVG;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CHARGE_COUNTER:\n\t\tprop = POWER_SUPPLY_PROP_CHARGE_COUNTER;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tprop = POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\tprop = POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tprop = POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\tprop = POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\n\t\tprop = POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:\n\t\tprop = POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tprop = POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\n\t\tprop = POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN:\n\t\tprop = POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_ENERGY_FULL:\n\t\tprop = POWER_SUPPLY_PROP_ENERGY_FULL;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_ENERGY_EMPTY:\n\t\tprop = POWER_SUPPLY_PROP_ENERGY_EMPTY;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_ENERGY_NOW:\n\t\tprop = POWER_SUPPLY_PROP_ENERGY_NOW;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_ENERGY_AVG:\n\t\tprop = POWER_SUPPLY_PROP_ENERGY_AVG;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CAPACITY:\n\t\tprop = POWER_SUPPLY_PROP_CAPACITY;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\n\t\tprop = POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX:\n\t\tprop = POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CAPACITY_LEVEL:\n\t\tprop = POWER_SUPPLY_PROP_CAPACITY_LEVEL;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TEMP:\n\t\tprop = POWER_SUPPLY_PROP_TEMP;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TEMP_MAX:\n\t\tprop = POWER_SUPPLY_PROP_TEMP_MAX;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TEMP_MIN:\n\t\tprop = POWER_SUPPLY_PROP_TEMP_MIN;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TEMP_ALERT_MIN:\n\t\tprop = POWER_SUPPLY_PROP_TEMP_ALERT_MIN;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tprop = POWER_SUPPLY_PROP_TEMP_ALERT_MAX;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TEMP_AMBIENT:\n\t\tprop = POWER_SUPPLY_PROP_TEMP_AMBIENT;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN:\n\t\tprop = POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX:\n\t\tprop = POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:\n\t\tprop = POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\n\t\tprop = POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:\n\t\tprop = POWER_SUPPLY_PROP_TIME_TO_FULL_NOW;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:\n\t\tprop = POWER_SUPPLY_PROP_TIME_TO_FULL_AVG;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_TYPE:\n\t\tprop = POWER_SUPPLY_PROP_TYPE;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_SCOPE:\n\t\tprop = POWER_SUPPLY_PROP_SCOPE;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\tprop = POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT;\n\t\tbreak;\n\tcase GB_POWER_SUPPLY_PROP_CALIBRATE:\n\t\tprop = POWER_SUPPLY_PROP_CALIBRATE;\n\t\tbreak;\n\tdefault:\n\t\tprop = -1;\n\t\tbreak;\n\t}\n\n\tif (prop < 0)\n\t\treturn prop;\n\n\t*psp = (enum power_supply_property)prop;\n\n\treturn 0;\n}\n\nstatic struct gb_connection *get_conn_from_psy(struct gb_power_supply *gbpsy)\n{\n\treturn gbpsy->supplies->connection;\n}\n\nstatic struct gb_power_supply_prop *get_psy_prop(struct gb_power_supply *gbpsy,\n\t\t\t\t\t\t enum power_supply_property psp)\n{\n\tint i;\n\n\tfor (i = 0; i < gbpsy->properties_count; i++)\n\t\tif (gbpsy->props[i].prop == psp)\n\t\t\treturn &gbpsy->props[i];\n\treturn NULL;\n}\n\nstatic int is_psy_prop_writeable(struct gb_power_supply *gbpsy,\n\t\t\t\t     enum power_supply_property psp)\n{\n\tstruct gb_power_supply_prop *prop;\n\n\tprop = get_psy_prop(gbpsy, psp);\n\tif (!prop)\n\t\treturn -ENOENT;\n\treturn prop->is_writeable ? 1 : 0;\n}\n\nstatic int is_prop_valint(enum power_supply_property psp)\n{\n\treturn ((psp < POWER_SUPPLY_PROP_MODEL_NAME) ? 1 : 0);\n}\n\nstatic void next_interval(struct gb_power_supply *gbpsy)\n{\n\tif (gbpsy->update_interval == update_interval_max)\n\t\treturn;\n\n\t \n\tgbpsy->update_interval *= 2;\n\tif (gbpsy->update_interval > update_interval_max)\n\t\tgbpsy->update_interval = update_interval_max;\n}\n\nstatic void __gb_power_supply_changed(struct gb_power_supply *gbpsy)\n{\n\tpower_supply_changed(gbpsy->psy);\n}\n\nstatic void gb_power_supply_state_change(struct gb_power_supply *gbpsy,\n\t\t\t\t\t struct gb_power_supply_prop *prop)\n{\n\tstruct gb_connection *connection = get_conn_from_psy(gbpsy);\n\tint ret;\n\n\t \n\tmutex_lock(&gbpsy->supply_lock);\n\n\tif ((prop->val == GB_POWER_SUPPLY_STATUS_CHARGING) &&\n\t    !gbpsy->pm_acquired) {\n\t\tret = gb_pm_runtime_get_sync(connection->bundle);\n\t\tif (ret)\n\t\t\tdev_err(&connection->bundle->dev,\n\t\t\t\t\"Fail to set wake lock for charging state\\n\");\n\t\telse\n\t\t\tgbpsy->pm_acquired = true;\n\t} else {\n\t\tif (gbpsy->pm_acquired) {\n\t\t\tret = gb_pm_runtime_put_autosuspend(connection->bundle);\n\t\t\tif (ret)\n\t\t\t\tdev_err(&connection->bundle->dev,\n\t\t\t\t\t\"Fail to set wake unlock for none charging\\n\");\n\t\t\telse\n\t\t\t\tgbpsy->pm_acquired = false;\n\t\t}\n\t}\n\n\tmutex_unlock(&gbpsy->supply_lock);\n}\n\nstatic void check_changed(struct gb_power_supply *gbpsy,\n\t\t\t  struct gb_power_supply_prop *prop)\n{\n\tconst struct gb_power_supply_changes *psyc;\n\tint val = prop->val;\n\tint prev_val = prop->previous_val;\n\tbool changed = false;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(psy_props_changes); i++) {\n\t\tpsyc = &psy_props_changes[i];\n\t\tif (prop->prop == psyc->prop) {\n\t\t\tif (!psyc->tolerance_change)\n\t\t\t\tchanged = true;\n\t\t\telse if (val < prev_val &&\n\t\t\t\t prev_val - val > psyc->tolerance_change)\n\t\t\t\tchanged = true;\n\t\t\telse if (val > prev_val &&\n\t\t\t\t val - prev_val > psyc->tolerance_change)\n\t\t\t\tchanged = true;\n\n\t\t\tif (changed && psyc->prop_changed)\n\t\t\t\tpsyc->prop_changed(gbpsy, prop);\n\n\t\t\tif (changed)\n\t\t\t\tgbpsy->changed = true;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int total_props(struct gb_power_supply *gbpsy)\n{\n\t \n\treturn (gbpsy->properties_count + gbpsy->properties_count_str);\n}\n\nstatic void prop_append(struct gb_power_supply *gbpsy,\n\t\t\tenum power_supply_property prop)\n{\n\tenum power_supply_property *new_props_raw;\n\n\tgbpsy->properties_count_str++;\n\tnew_props_raw = krealloc(gbpsy->props_raw, total_props(gbpsy) *\n\t\t\t\t sizeof(enum power_supply_property),\n\t\t\t\t GFP_KERNEL);\n\tif (!new_props_raw)\n\t\treturn;\n\tgbpsy->props_raw = new_props_raw;\n\tgbpsy->props_raw[total_props(gbpsy) - 1] = prop;\n}\n\nstatic int __gb_power_supply_set_name(char *init_name, char *name, size_t len)\n{\n\tunsigned int i = 0;\n\tint ret = 0;\n\tstruct power_supply *psy;\n\n\tif (!strlen(init_name))\n\t\tinit_name = \"gb_power_supply\";\n\tstrscpy(name, init_name, len);\n\n\twhile ((ret < len) && (psy = power_supply_get_by_name(name))) {\n\t\tpower_supply_put(psy);\n\n\t\tret = snprintf(name, len, \"%s_%u\", init_name, ++i);\n\t}\n\tif (ret >= len)\n\t\treturn -ENOMEM;\n\treturn i;\n}\n\nstatic void _gb_power_supply_append_props(struct gb_power_supply *gbpsy)\n{\n\tif (strlen(gbpsy->manufacturer))\n\t\tprop_append(gbpsy, POWER_SUPPLY_PROP_MANUFACTURER);\n\tif (strlen(gbpsy->model_name))\n\t\tprop_append(gbpsy, POWER_SUPPLY_PROP_MODEL_NAME);\n\tif (strlen(gbpsy->serial_number))\n\t\tprop_append(gbpsy, POWER_SUPPLY_PROP_SERIAL_NUMBER);\n}\n\nstatic int gb_power_supply_description_get(struct gb_power_supply *gbpsy)\n{\n\tstruct gb_connection *connection = get_conn_from_psy(gbpsy);\n\tstruct gb_power_supply_get_description_request req;\n\tstruct gb_power_supply_get_description_response resp;\n\tint ret;\n\n\treq.psy_id = gbpsy->id;\n\n\tret = gb_operation_sync(connection,\n\t\t\t\tGB_POWER_SUPPLY_TYPE_GET_DESCRIPTION,\n\t\t\t\t&req, sizeof(req), &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgbpsy->manufacturer = kstrndup(resp.manufacturer, PROP_MAX, GFP_KERNEL);\n\tif (!gbpsy->manufacturer)\n\t\treturn -ENOMEM;\n\tgbpsy->model_name = kstrndup(resp.model, PROP_MAX, GFP_KERNEL);\n\tif (!gbpsy->model_name)\n\t\treturn -ENOMEM;\n\tgbpsy->serial_number = kstrndup(resp.serial_number, PROP_MAX,\n\t\t\t\t       GFP_KERNEL);\n\tif (!gbpsy->serial_number)\n\t\treturn -ENOMEM;\n\n\tgbpsy->type = le16_to_cpu(resp.type);\n\tgbpsy->properties_count = resp.properties_count;\n\n\treturn 0;\n}\n\nstatic int gb_power_supply_prop_descriptors_get(struct gb_power_supply *gbpsy)\n{\n\tstruct gb_connection *connection = get_conn_from_psy(gbpsy);\n\tstruct gb_power_supply_get_property_descriptors_request *req;\n\tstruct gb_power_supply_get_property_descriptors_response *resp;\n\tstruct gb_operation *op;\n\tu8 props_count = gbpsy->properties_count;\n\tenum power_supply_property psp;\n\tint ret;\n\tint i, r = 0;\n\n\tif (props_count == 0)\n\t\treturn 0;\n\n\top = gb_operation_create(connection,\n\t\t\t\t GB_POWER_SUPPLY_TYPE_GET_PROP_DESCRIPTORS,\n\t\t\t\t sizeof(*req),\n\t\t\t\t struct_size(resp, props, props_count),\n\t\t\t\t GFP_KERNEL);\n\tif (!op)\n\t\treturn -ENOMEM;\n\n\treq = op->request->payload;\n\treq->psy_id = gbpsy->id;\n\n\tret = gb_operation_request_send_sync(op);\n\tif (ret < 0)\n\t\tgoto out_put_operation;\n\n\tresp = op->response->payload;\n\n\t \n\tfor (i = 0; i < props_count; i++) {\n\t\tret = get_psp_from_gb_prop(resp->props[i].property, &psp);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&connection->bundle->dev,\n\t\t\t\t \"greybus property %u it is not supported by this kernel, dropped\\n\",\n\t\t\t\t resp->props[i].property);\n\t\t\tgbpsy->properties_count--;\n\t\t}\n\t}\n\n\tgbpsy->props = kcalloc(gbpsy->properties_count, sizeof(*gbpsy->props),\n\t\t\t      GFP_KERNEL);\n\tif (!gbpsy->props) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put_operation;\n\t}\n\n\tgbpsy->props_raw = kcalloc(gbpsy->properties_count,\n\t\t\t\t   sizeof(*gbpsy->props_raw), GFP_KERNEL);\n\tif (!gbpsy->props_raw) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put_operation;\n\t}\n\n\t \n\tfor (i = 0; i < props_count; i++) {\n\t\tret = get_psp_from_gb_prop(resp->props[i].property, &psp);\n\t\tif (ret < 0) {\n\t\t\tr++;\n\t\t\tcontinue;\n\t\t}\n\t\tgbpsy->props[i - r].prop = psp;\n\t\tgbpsy->props[i - r].gb_prop = resp->props[i].property;\n\t\tgbpsy->props_raw[i - r] = psp;\n\t\tif (resp->props[i].is_writeable)\n\t\t\tgbpsy->props[i - r].is_writeable = true;\n\t}\n\n\t \n\t_gb_power_supply_append_props(gbpsy);\n\n\tret = 0;\nout_put_operation:\n\tgb_operation_put(op);\n\n\treturn ret;\n}\n\nstatic int __gb_power_supply_property_update(struct gb_power_supply *gbpsy,\n\t\t\t\t\t     enum power_supply_property psp)\n{\n\tstruct gb_connection *connection = get_conn_from_psy(gbpsy);\n\tstruct gb_power_supply_prop *prop;\n\tstruct gb_power_supply_get_property_request req;\n\tstruct gb_power_supply_get_property_response resp;\n\tint val;\n\tint ret;\n\n\tprop = get_psy_prop(gbpsy, psp);\n\tif (!prop)\n\t\treturn -EINVAL;\n\treq.psy_id = gbpsy->id;\n\treq.property = prop->gb_prop;\n\n\tret = gb_operation_sync(connection, GB_POWER_SUPPLY_TYPE_GET_PROPERTY,\n\t\t\t\t&req, sizeof(req), &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = le32_to_cpu(resp.prop_val);\n\tif (val == prop->val)\n\t\treturn 0;\n\n\tprop->previous_val = prop->val;\n\tprop->val = val;\n\n\tcheck_changed(gbpsy, prop);\n\n\treturn 0;\n}\n\nstatic int __gb_power_supply_property_get(struct gb_power_supply *gbpsy,\n\t\t\t\t\t  enum power_supply_property psp,\n\t\t\t\t\t  union power_supply_propval *val)\n{\n\tstruct gb_power_supply_prop *prop;\n\n\tprop = get_psy_prop(gbpsy, psp);\n\tif (!prop)\n\t\treturn -EINVAL;\n\n\tval->intval = prop->val;\n\treturn 0;\n}\n\nstatic int __gb_power_supply_property_strval_get(struct gb_power_supply *gbpsy,\n\t\t\t\t\t\tenum power_supply_property psp,\n\t\t\t\t\t\tunion power_supply_propval *val)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = gbpsy->model_name;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = gbpsy->manufacturer;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SERIAL_NUMBER:\n\t\tval->strval = gbpsy->serial_number;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int _gb_power_supply_property_get(struct gb_power_supply *gbpsy,\n\t\t\t\t\t enum power_supply_property psp,\n\t\t\t\t\t union power_supply_propval *val)\n{\n\tstruct gb_connection *connection = get_conn_from_psy(gbpsy);\n\tint ret;\n\n\t \n\tif (is_prop_valint(psp))\n\t\tret = __gb_power_supply_property_get(gbpsy, psp, val);\n\telse\n\t\tret = __gb_power_supply_property_strval_get(gbpsy, psp, val);\n\n\tif (ret < 0)\n\t\tdev_err(&connection->bundle->dev, \"get property %u\\n\", psp);\n\n\treturn 0;\n}\n\nstatic int is_cache_valid(struct gb_power_supply *gbpsy)\n{\n\t \n\tif (gbpsy->cache_invalid) {\n\t\tgbpsy->cache_invalid = 0;\n\t\treturn 0;\n\t}\n\n\tif (gbpsy->last_update &&\n\t    time_is_after_jiffies(gbpsy->last_update +\n\t\t\t\t  msecs_to_jiffies(cache_time)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int gb_power_supply_status_get(struct gb_power_supply *gbpsy)\n{\n\tstruct gb_connection *connection = get_conn_from_psy(gbpsy);\n\tint ret = 0;\n\tint i;\n\n\tif (is_cache_valid(gbpsy))\n\t\treturn 0;\n\n\tret = gb_pm_runtime_get_sync(connection->bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < gbpsy->properties_count; i++) {\n\t\tret = __gb_power_supply_property_update(gbpsy,\n\t\t\t\t\t\t\tgbpsy->props[i].prop);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (ret == 0)\n\t\tgbpsy->last_update = jiffies;\n\n\tgb_pm_runtime_put_autosuspend(connection->bundle);\n\treturn ret;\n}\n\nstatic void gb_power_supply_status_update(struct gb_power_supply *gbpsy)\n{\n\t \n\tgb_power_supply_status_get(gbpsy);\n\n\tif (!gbpsy->changed)\n\t\treturn;\n\n\tgbpsy->update_interval = update_interval_init;\n\t__gb_power_supply_changed(gbpsy);\n\tgbpsy->changed = false;\n}\n\nstatic void gb_power_supply_work(struct work_struct *work)\n{\n\tstruct gb_power_supply *gbpsy = container_of(work,\n\t\t\t\t\t\t     struct gb_power_supply,\n\t\t\t\t\t\t     work.work);\n\n\t \n\tif (!gbpsy->update_interval)\n\t\treturn;\n\n\tgb_power_supply_status_update(gbpsy);\n\tnext_interval(gbpsy);\n\tschedule_delayed_work(&gbpsy->work, gbpsy->update_interval);\n}\n\nstatic int get_property(struct power_supply *b,\n\t\t\tenum power_supply_property psp,\n\t\t\tunion power_supply_propval *val)\n{\n\tstruct gb_power_supply *gbpsy = to_gb_power_supply(b);\n\n\tgb_power_supply_status_get(gbpsy);\n\n\treturn _gb_power_supply_property_get(gbpsy, psp, val);\n}\n\nstatic int gb_power_supply_property_set(struct gb_power_supply *gbpsy,\n\t\t\t\t\tenum power_supply_property psp,\n\t\t\t\t\tint val)\n{\n\tstruct gb_connection *connection = get_conn_from_psy(gbpsy);\n\tstruct gb_power_supply_prop *prop;\n\tstruct gb_power_supply_set_property_request req;\n\tint ret;\n\n\tret = gb_pm_runtime_get_sync(connection->bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tprop = get_psy_prop(gbpsy, psp);\n\tif (!prop) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treq.psy_id = gbpsy->id;\n\treq.property = prop->gb_prop;\n\treq.prop_val = cpu_to_le32((s32)val);\n\n\tret = gb_operation_sync(connection, GB_POWER_SUPPLY_TYPE_SET_PROPERTY,\n\t\t\t\t&req, sizeof(req), NULL, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tprop->val = val;\n\nout:\n\tgb_pm_runtime_put_autosuspend(connection->bundle);\n\treturn ret;\n}\n\nstatic int set_property(struct power_supply *b,\n\t\t\tenum power_supply_property psp,\n\t\t\tconst union power_supply_propval *val)\n{\n\tstruct gb_power_supply *gbpsy = to_gb_power_supply(b);\n\n\treturn gb_power_supply_property_set(gbpsy, psp, val->intval);\n}\n\nstatic int property_is_writeable(struct power_supply *b,\n\t\t\t\t enum power_supply_property psp)\n{\n\tstruct gb_power_supply *gbpsy = to_gb_power_supply(b);\n\n\treturn is_psy_prop_writeable(gbpsy, psp);\n}\n\nstatic int gb_power_supply_register(struct gb_power_supply *gbpsy)\n{\n\tstruct gb_connection *connection = get_conn_from_psy(gbpsy);\n\tstruct power_supply_config cfg = {};\n\n\tcfg.drv_data = gbpsy;\n\n\tgbpsy->desc.name\t\t= gbpsy->name;\n\tgbpsy->desc.type\t\t= gbpsy->type;\n\tgbpsy->desc.properties\t\t= gbpsy->props_raw;\n\tgbpsy->desc.num_properties\t= total_props(gbpsy);\n\tgbpsy->desc.get_property\t= get_property;\n\tgbpsy->desc.set_property\t= set_property;\n\tgbpsy->desc.property_is_writeable = property_is_writeable;\n\n\tgbpsy->psy = power_supply_register(&connection->bundle->dev,\n\t\t\t\t\t   &gbpsy->desc, &cfg);\n\treturn PTR_ERR_OR_ZERO(gbpsy->psy);\n}\n\nstatic void _gb_power_supply_free(struct gb_power_supply *gbpsy)\n{\n\tkfree(gbpsy->serial_number);\n\tkfree(gbpsy->model_name);\n\tkfree(gbpsy->manufacturer);\n\tkfree(gbpsy->props_raw);\n\tkfree(gbpsy->props);\n}\n\nstatic void _gb_power_supply_release(struct gb_power_supply *gbpsy)\n{\n\tgbpsy->update_interval = 0;\n\n\tcancel_delayed_work_sync(&gbpsy->work);\n\n\tif (gbpsy->registered)\n\t\tpower_supply_unregister(gbpsy->psy);\n\n\t_gb_power_supply_free(gbpsy);\n}\n\nstatic void _gb_power_supplies_release(struct gb_power_supplies *supplies)\n{\n\tint i;\n\n\tif (!supplies->supply)\n\t\treturn;\n\n\tmutex_lock(&supplies->supplies_lock);\n\tfor (i = 0; i < supplies->supplies_count; i++)\n\t\t_gb_power_supply_release(&supplies->supply[i]);\n\tkfree(supplies->supply);\n\tmutex_unlock(&supplies->supplies_lock);\n\tkfree(supplies);\n}\n\nstatic int gb_power_supplies_get_count(struct gb_power_supplies *supplies)\n{\n\tstruct gb_power_supply_get_supplies_response resp;\n\tint ret;\n\n\tret = gb_operation_sync(supplies->connection,\n\t\t\t\tGB_POWER_SUPPLY_TYPE_GET_SUPPLIES,\n\t\t\t\tNULL, 0, &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif  (!resp.supplies_count)\n\t\treturn -EINVAL;\n\n\tsupplies->supplies_count = resp.supplies_count;\n\n\treturn ret;\n}\n\nstatic int gb_power_supply_config(struct gb_power_supplies *supplies, int id)\n{\n\tstruct gb_power_supply *gbpsy = &supplies->supply[id];\n\tint ret;\n\n\tgbpsy->supplies = supplies;\n\tgbpsy->id = id;\n\n\tret = gb_power_supply_description_get(gbpsy);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn gb_power_supply_prop_descriptors_get(gbpsy);\n}\n\nstatic int gb_power_supply_enable(struct gb_power_supply *gbpsy)\n{\n\tint ret;\n\n\t \n\tret =  __gb_power_supply_set_name(gbpsy->model_name, gbpsy->name,\n\t\t\t\t\t  sizeof(gbpsy->name));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_init(&gbpsy->supply_lock);\n\n\tret = gb_power_supply_register(gbpsy);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgbpsy->update_interval = update_interval_init;\n\tINIT_DELAYED_WORK(&gbpsy->work, gb_power_supply_work);\n\tschedule_delayed_work(&gbpsy->work, 0);\n\n\t \n\tgbpsy->registered = true;\n\n\treturn 0;\n}\n\nstatic int gb_power_supplies_setup(struct gb_power_supplies *supplies)\n{\n\tstruct gb_connection *connection = supplies->connection;\n\tint ret;\n\tint i;\n\n\tmutex_lock(&supplies->supplies_lock);\n\n\tret = gb_power_supplies_get_count(supplies);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsupplies->supply = kcalloc(supplies->supplies_count,\n\t\t\t\t     sizeof(struct gb_power_supply),\n\t\t\t\t     GFP_KERNEL);\n\n\tif (!supplies->supply) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < supplies->supplies_count; i++) {\n\t\tret = gb_power_supply_config(supplies, i);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&connection->bundle->dev,\n\t\t\t\t\"Fail to configure supplies devices\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&supplies->supplies_lock);\n\treturn ret;\n}\n\nstatic int gb_power_supplies_register(struct gb_power_supplies *supplies)\n{\n\tstruct gb_connection *connection = supplies->connection;\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&supplies->supplies_lock);\n\n\tfor (i = 0; i < supplies->supplies_count; i++) {\n\t\tret = gb_power_supply_enable(&supplies->supply[i]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&connection->bundle->dev,\n\t\t\t\t\"Fail to enable supplies devices\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&supplies->supplies_lock);\n\treturn ret;\n}\n\nstatic int gb_supplies_request_handler(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct gb_power_supplies *supplies = gb_connection_get_data(connection);\n\tstruct gb_power_supply *gbpsy;\n\tstruct gb_message *request;\n\tstruct gb_power_supply_event_request *payload;\n\tu8 psy_id;\n\tu8 event;\n\tint ret = 0;\n\n\tif (op->type != GB_POWER_SUPPLY_TYPE_EVENT) {\n\t\tdev_err(&connection->bundle->dev,\n\t\t\t\"Unsupported unsolicited event: %u\\n\", op->type);\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request;\n\n\tif (request->payload_size < sizeof(*payload)) {\n\t\tdev_err(&connection->bundle->dev,\n\t\t\t\"Wrong event size received (%zu < %zu)\\n\",\n\t\t\trequest->payload_size, sizeof(*payload));\n\t\treturn -EINVAL;\n\t}\n\n\tpayload = request->payload;\n\tpsy_id = payload->psy_id;\n\tmutex_lock(&supplies->supplies_lock);\n\tif (psy_id >= supplies->supplies_count ||\n\t    !supplies->supply[psy_id].registered) {\n\t\tdev_err(&connection->bundle->dev,\n\t\t\t\"Event received for unconfigured power_supply id: %d\\n\",\n\t\t\tpsy_id);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tevent = payload->event;\n\t \n\tgbpsy = &supplies->supply[psy_id];\n\tif (!gbpsy->update_interval) {\n\t\tret = -ESHUTDOWN;\n\t\tgoto out_unlock;\n\t}\n\n\tif (event & GB_POWER_SUPPLY_UPDATE) {\n\t\t \n\t\tgbpsy->cache_invalid = 1;\n\t\tgb_power_supply_status_update(gbpsy);\n\t}\n\nout_unlock:\n\tmutex_unlock(&supplies->supplies_lock);\n\treturn ret;\n}\n\nstatic int gb_power_supply_probe(struct gb_bundle *bundle,\n\t\t\t\t const struct greybus_bundle_id *id)\n{\n\tstruct greybus_descriptor_cport *cport_desc;\n\tstruct gb_connection *connection;\n\tstruct gb_power_supplies *supplies;\n\tint ret;\n\n\tif (bundle->num_cports != 1)\n\t\treturn -ENODEV;\n\n\tcport_desc = &bundle->cport_desc[0];\n\tif (cport_desc->protocol_id != GREYBUS_PROTOCOL_POWER_SUPPLY)\n\t\treturn -ENODEV;\n\n\tsupplies = kzalloc(sizeof(*supplies), GFP_KERNEL);\n\tif (!supplies)\n\t\treturn -ENOMEM;\n\n\tconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\n\t\t\t\t\t  gb_supplies_request_handler);\n\tif (IS_ERR(connection)) {\n\t\tret = PTR_ERR(connection);\n\t\tgoto out;\n\t}\n\n\tsupplies->connection = connection;\n\tgb_connection_set_data(connection, supplies);\n\n\tmutex_init(&supplies->supplies_lock);\n\n\tgreybus_set_drvdata(bundle, supplies);\n\n\t \n\tret = gb_connection_enable_tx(connection);\n\tif (ret)\n\t\tgoto error_connection_destroy;\n\n\tret = gb_power_supplies_setup(supplies);\n\tif (ret < 0)\n\t\tgoto error_connection_disable;\n\n\t \n\tret = gb_connection_enable(connection);\n\tif (ret)\n\t\tgoto error_connection_disable;\n\n\tret = gb_power_supplies_register(supplies);\n\tif (ret < 0)\n\t\tgoto error_connection_disable;\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\treturn 0;\n\nerror_connection_disable:\n\tgb_connection_disable(connection);\nerror_connection_destroy:\n\tgb_connection_destroy(connection);\nout:\n\t_gb_power_supplies_release(supplies);\n\treturn ret;\n}\n\nstatic void gb_power_supply_disconnect(struct gb_bundle *bundle)\n{\n\tstruct gb_power_supplies *supplies = greybus_get_drvdata(bundle);\n\n\tgb_connection_disable(supplies->connection);\n\tgb_connection_destroy(supplies->connection);\n\n\t_gb_power_supplies_release(supplies);\n}\n\nstatic const struct greybus_bundle_id gb_power_supply_id_table[] = {\n\t{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_POWER_SUPPLY) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(greybus, gb_power_supply_id_table);\n\nstatic struct greybus_driver gb_power_supply_driver = {\n\t.name\t\t= \"power_supply\",\n\t.probe\t\t= gb_power_supply_probe,\n\t.disconnect\t= gb_power_supply_disconnect,\n\t.id_table\t= gb_power_supply_id_table,\n};\nmodule_greybus_driver(gb_power_supply_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}