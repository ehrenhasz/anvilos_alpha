{
  "module_name": "arche-platform.c",
  "hash_id": "08f043f41f816a24c4d2b98e7340f4f61ff1d26a4aacfeb56e95352d47191dea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/arche-platform.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/suspend.h>\n#include <linux/time.h>\n#include <linux/greybus.h>\n#include <linux/of.h>\n#include \"arche_platform.h\"\n\n#if IS_ENABLED(CONFIG_USB_HSIC_USB3613)\n#include <linux/usb/usb3613.h>\n#else\nstatic inline int usb3613_hub_mode_ctrl(bool unused)\n{\n\treturn 0;\n}\n#endif\n\n#define WD_COLDBOOT_PULSE_WIDTH_MS\t30\n\nenum svc_wakedetect_state {\n\tWD_STATE_IDLE,\t\t\t \n\tWD_STATE_BOOT_INIT,\t\t \n\tWD_STATE_COLDBOOT_TRIG,\t\t \n\tWD_STATE_STANDBYBOOT_TRIG,\t \n\tWD_STATE_COLDBOOT_START,\t \n\tWD_STATE_STANDBYBOOT_START,\t \n};\n\nstruct arche_platform_drvdata {\n\t \n\tstruct gpio_desc *svc_reset;\n\tbool is_reset_act_hi;\n\tstruct gpio_desc *svc_sysboot;\n\tstruct gpio_desc *wake_detect;  \n\n\tenum arche_platform_state state;\n\n\tstruct gpio_desc *svc_refclk_req;\n\tstruct clk *svc_ref_clk;\n\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pin_default;\n\n\tint num_apbs;\n\n\tenum svc_wakedetect_state wake_detect_state;\n\tint wake_detect_irq;\n\tspinlock_t wake_lock;\t\t\t \n\tstruct mutex platform_state_mutex;\t \n\tunsigned long wake_detect_start;\n\tstruct notifier_block pm_notifier;\n\n\tstruct device *dev;\n};\n\n \nstatic void arche_platform_set_state(struct arche_platform_drvdata *arche_pdata,\n\t\t\t\t     enum arche_platform_state state)\n{\n\tarche_pdata->state = state;\n}\n\n \nstatic void arche_platform_set_wake_detect_state(struct arche_platform_drvdata *arche_pdata,\n\t\t\t\t\t\t enum svc_wakedetect_state state)\n{\n\tarche_pdata->wake_detect_state = state;\n}\n\nstatic inline void svc_reset_onoff(struct gpio_desc *gpio, bool onoff)\n{\n\tgpiod_set_raw_value(gpio, onoff);\n}\n\nstatic int apb_cold_boot(struct device *dev, void *data)\n{\n\tint ret;\n\n\tret = apb_ctrl_coldboot(dev);\n\tif (ret)\n\t\tdev_warn(dev, \"failed to coldboot\\n\");\n\n\t \n\treturn 0;\n}\n\nstatic int apb_poweroff(struct device *dev, void *data)\n{\n\tapb_ctrl_poweroff(dev);\n\n\t \n\tif (usb3613_hub_mode_ctrl(false))\n\t\tdev_warn(dev, \"failed to control hub device\\n\");\n\n\treturn 0;\n}\n\nstatic void arche_platform_wd_irq_en(struct arche_platform_drvdata *arche_pdata)\n{\n\t \n\tenable_irq(arche_pdata->wake_detect_irq);\n}\n\nstatic irqreturn_t arche_platform_wd_irq_thread(int irq, void *devid)\n{\n\tstruct arche_platform_drvdata *arche_pdata = devid;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&arche_pdata->wake_lock, flags);\n\tif (arche_pdata->wake_detect_state != WD_STATE_COLDBOOT_TRIG) {\n\t\t \n\t\tspin_unlock_irqrestore(&arche_pdata->wake_lock, flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tarche_platform_set_wake_detect_state(arche_pdata,\n\t\t\t\t\t     WD_STATE_COLDBOOT_START);\n\tspin_unlock_irqrestore(&arche_pdata->wake_lock, flags);\n\n\t \n\tdevice_for_each_child(arche_pdata->dev, NULL, apb_poweroff);\n\n\t \n\tdevice_for_each_child(arche_pdata->dev, NULL, apb_cold_boot);\n\n\t \n\tif (usb3613_hub_mode_ctrl(true))\n\t\tdev_warn(arche_pdata->dev, \"failed to control hub device\\n\");\n\n\tspin_lock_irqsave(&arche_pdata->wake_lock, flags);\n\tarche_platform_set_wake_detect_state(arche_pdata, WD_STATE_IDLE);\n\tspin_unlock_irqrestore(&arche_pdata->wake_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t arche_platform_wd_irq(int irq, void *devid)\n{\n\tstruct arche_platform_drvdata *arche_pdata = devid;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&arche_pdata->wake_lock, flags);\n\n\tif (gpiod_get_value(arche_pdata->wake_detect)) {\n\t\t \n\n\t\t \n\t\tif (arche_pdata->wake_detect_state == WD_STATE_BOOT_INIT) {\n\t\t\tif (time_before(jiffies,\n\t\t\t\t\tarche_pdata->wake_detect_start +\n\t\t\t\t\tmsecs_to_jiffies(WD_COLDBOOT_PULSE_WIDTH_MS))) {\n\t\t\t\tarche_platform_set_wake_detect_state(arche_pdata,\n\t\t\t\t\t\t\t\t     WD_STATE_IDLE);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (arche_pdata->wake_detect_state !=\n\t\t\t\t\t\tWD_STATE_COLDBOOT_START) {\n\t\t\t\t\tarche_platform_set_wake_detect_state(arche_pdata,\n\t\t\t\t\t\t\t\t\t     WD_STATE_COLDBOOT_TRIG);\n\t\t\t\t\tspin_unlock_irqrestore(&arche_pdata->wake_lock,\n\t\t\t\t\t\t\t       flags);\n\t\t\t\t\treturn IRQ_WAKE_THREAD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (arche_pdata->wake_detect_state == WD_STATE_IDLE) {\n\t\t\tarche_pdata->wake_detect_start = jiffies;\n\t\t\t \n\t\t\tarche_platform_set_wake_detect_state(arche_pdata,\n\t\t\t\t\t\t\t     WD_STATE_BOOT_INIT);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&arche_pdata->wake_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int\narche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdata)\n{\n\tint ret;\n\n\tif (arche_pdata->state == ARCHE_PLATFORM_STATE_ACTIVE)\n\t\treturn 0;\n\n\tdev_info(arche_pdata->dev, \"Booting from cold boot state\\n\");\n\n\tsvc_reset_onoff(arche_pdata->svc_reset, arche_pdata->is_reset_act_hi);\n\n\tgpiod_set_value(arche_pdata->svc_sysboot, 0);\n\tusleep_range(100, 200);\n\n\tret = clk_prepare_enable(arche_pdata->svc_ref_clk);\n\tif (ret) {\n\t\tdev_err(arche_pdata->dev, \"failed to enable svc_ref_clk: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tsvc_reset_onoff(arche_pdata->svc_reset, !arche_pdata->is_reset_act_hi);\n\n\tarche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_ACTIVE);\n\n\treturn 0;\n}\n\n \nstatic int\narche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_pdata)\n{\n\tint ret;\n\n\tif (arche_pdata->state == ARCHE_PLATFORM_STATE_FW_FLASHING)\n\t\treturn 0;\n\n\tdev_info(arche_pdata->dev, \"Switching to FW flashing state\\n\");\n\n\tsvc_reset_onoff(arche_pdata->svc_reset, arche_pdata->is_reset_act_hi);\n\n\tgpiod_set_value(arche_pdata->svc_sysboot, 1);\n\n\tusleep_range(100, 200);\n\n\tret = clk_prepare_enable(arche_pdata->svc_ref_clk);\n\tif (ret) {\n\t\tdev_err(arche_pdata->dev, \"failed to enable svc_ref_clk: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tsvc_reset_onoff(arche_pdata->svc_reset,\t!arche_pdata->is_reset_act_hi);\n\n\tarche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_FW_FLASHING);\n\n\treturn 0;\n}\n\n \nstatic void\narche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pdata)\n{\n\tunsigned long flags;\n\n\tif (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF)\n\t\treturn;\n\n\t \n\tif (arche_pdata->state != ARCHE_PLATFORM_STATE_FW_FLASHING) {\n\t\tdisable_irq(arche_pdata->wake_detect_irq);\n\n\t\tspin_lock_irqsave(&arche_pdata->wake_lock, flags);\n\t\tarche_platform_set_wake_detect_state(arche_pdata,\n\t\t\t\t\t\t     WD_STATE_IDLE);\n\t\tspin_unlock_irqrestore(&arche_pdata->wake_lock, flags);\n\t}\n\n\tclk_disable_unprepare(arche_pdata->svc_ref_clk);\n\n\t \n\tsvc_reset_onoff(arche_pdata->svc_reset,\tarche_pdata->is_reset_act_hi);\n\n\tarche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_OFF);\n}\n\nstatic ssize_t state_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct arche_platform_drvdata *arche_pdata = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tmutex_lock(&arche_pdata->platform_state_mutex);\n\n\tif (sysfs_streq(buf, \"off\")) {\n\t\tif (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF)\n\t\t\tgoto exit;\n\n\t\t \n\t\tdevice_for_each_child(arche_pdata->dev, NULL, apb_poweroff);\n\n\t\tarche_platform_poweroff_seq(arche_pdata);\n\n\t} else if (sysfs_streq(buf, \"active\")) {\n\t\tif (arche_pdata->state == ARCHE_PLATFORM_STATE_ACTIVE)\n\t\t\tgoto exit;\n\n\t\t \n\t\tdevice_for_each_child(arche_pdata->dev, NULL, apb_poweroff);\n\t\tarche_platform_poweroff_seq(arche_pdata);\n\n\t\tarche_platform_wd_irq_en(arche_pdata);\n\t\tret = arche_platform_coldboot_seq(arche_pdata);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t} else if (sysfs_streq(buf, \"standby\")) {\n\t\tif (arche_pdata->state == ARCHE_PLATFORM_STATE_STANDBY)\n\t\t\tgoto exit;\n\n\t\tdev_warn(arche_pdata->dev, \"standby state not supported\\n\");\n\t} else if (sysfs_streq(buf, \"fw_flashing\")) {\n\t\tif (arche_pdata->state == ARCHE_PLATFORM_STATE_FW_FLASHING)\n\t\t\tgoto exit;\n\n\t\t \n\t\tarche_platform_poweroff_seq(arche_pdata);\n\n\t\tret = arche_platform_fw_flashing_seq(arche_pdata);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t} else {\n\t\tdev_err(arche_pdata->dev, \"unknown state\\n\");\n\t\tret = -EINVAL;\n\t}\n\nexit:\n\tmutex_unlock(&arche_pdata->platform_state_mutex);\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t state_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct arche_platform_drvdata *arche_pdata = dev_get_drvdata(dev);\n\n\tswitch (arche_pdata->state) {\n\tcase ARCHE_PLATFORM_STATE_OFF:\n\t\treturn sprintf(buf, \"off\\n\");\n\tcase ARCHE_PLATFORM_STATE_ACTIVE:\n\t\treturn sprintf(buf, \"active\\n\");\n\tcase ARCHE_PLATFORM_STATE_STANDBY:\n\t\treturn sprintf(buf, \"standby\\n\");\n\tcase ARCHE_PLATFORM_STATE_FW_FLASHING:\n\t\treturn sprintf(buf, \"fw_flashing\\n\");\n\tdefault:\n\t\treturn sprintf(buf, \"unknown state\\n\");\n\t}\n}\n\nstatic DEVICE_ATTR_RW(state);\n\nstatic int arche_platform_pm_notifier(struct notifier_block *notifier,\n\t\t\t\t      unsigned long pm_event, void *unused)\n{\n\tstruct arche_platform_drvdata *arche_pdata =\n\t\tcontainer_of(notifier, struct arche_platform_drvdata,\n\t\t\t     pm_notifier);\n\tint ret = NOTIFY_DONE;\n\n\tmutex_lock(&arche_pdata->platform_state_mutex);\n\tswitch (pm_event) {\n\tcase PM_SUSPEND_PREPARE:\n\t\tif (arche_pdata->state != ARCHE_PLATFORM_STATE_ACTIVE) {\n\t\t\tret = NOTIFY_STOP;\n\t\t\tbreak;\n\t\t}\n\t\tdevice_for_each_child(arche_pdata->dev, NULL, apb_poweroff);\n\t\tarche_platform_poweroff_seq(arche_pdata);\n\t\tbreak;\n\tcase PM_POST_SUSPEND:\n\t\tif (arche_pdata->state != ARCHE_PLATFORM_STATE_OFF)\n\t\t\tbreak;\n\n\t\tarche_platform_wd_irq_en(arche_pdata);\n\t\tarche_platform_coldboot_seq(arche_pdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&arche_pdata->platform_state_mutex);\n\n\treturn ret;\n}\n\nstatic int arche_platform_probe(struct platform_device *pdev)\n{\n\tstruct arche_platform_drvdata *arche_pdata;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\tunsigned int flags;\n\n\tarche_pdata = devm_kzalloc(&pdev->dev, sizeof(*arche_pdata),\n\t\t\t\t   GFP_KERNEL);\n\tif (!arche_pdata)\n\t\treturn -ENOMEM;\n\n\t \n\tarche_pdata->is_reset_act_hi = of_property_read_bool(np,\n\t\t\t\t\t\t\t     \"svc,reset-active-high\");\n\tif (arche_pdata->is_reset_act_hi)\n\t\tflags = GPIOD_OUT_HIGH;\n\telse\n\t\tflags = GPIOD_OUT_LOW;\n\n\tarche_pdata->svc_reset = devm_gpiod_get(dev, \"svc,reset\", flags);\n\tif (IS_ERR(arche_pdata->svc_reset)) {\n\t\tret = PTR_ERR(arche_pdata->svc_reset);\n\t\tdev_err(dev, \"failed to request svc-reset GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tarche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_OFF);\n\n\tarche_pdata->svc_sysboot = devm_gpiod_get(dev, \"svc,sysboot\",\n\t\t\t\t\t\t  GPIOD_OUT_LOW);\n\tif (IS_ERR(arche_pdata->svc_sysboot)) {\n\t\tret = PTR_ERR(arche_pdata->svc_sysboot);\n\t\tdev_err(dev, \"failed to request sysboot0 GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tarche_pdata->svc_refclk_req = devm_gpiod_get(dev, \"svc,refclk-req\",\n\t\t\t\t\t\t     GPIOD_IN);\n\tif (IS_ERR(arche_pdata->svc_refclk_req)) {\n\t\tret = PTR_ERR(arche_pdata->svc_refclk_req);\n\t\tdev_err(dev, \"failed to request svc-clk-req GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tarche_pdata->svc_ref_clk = devm_clk_get(dev, \"svc_ref_clk\");\n\tif (IS_ERR(arche_pdata->svc_ref_clk)) {\n\t\tret = PTR_ERR(arche_pdata->svc_ref_clk);\n\t\tdev_err(dev, \"failed to get svc_ref_clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, arche_pdata);\n\n\tarche_pdata->num_apbs = of_get_child_count(np);\n\tdev_dbg(dev, \"Number of APB's available - %d\\n\", arche_pdata->num_apbs);\n\n\tarche_pdata->wake_detect = devm_gpiod_get(dev, \"svc,wake-detect\",\n\t\t\t\t\t\t  GPIOD_IN);\n\tif (IS_ERR(arche_pdata->wake_detect)) {\n\t\tret = PTR_ERR(arche_pdata->wake_detect);\n\t\tdev_err(dev, \"Failed requesting wake_detect GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tarche_platform_set_wake_detect_state(arche_pdata, WD_STATE_IDLE);\n\n\tarche_pdata->dev = &pdev->dev;\n\n\tspin_lock_init(&arche_pdata->wake_lock);\n\tmutex_init(&arche_pdata->platform_state_mutex);\n\tarche_pdata->wake_detect_irq =\n\t\tgpiod_to_irq(arche_pdata->wake_detect);\n\n\tret = devm_request_threaded_irq(dev, arche_pdata->wake_detect_irq,\n\t\t\t\t\tarche_platform_wd_irq,\n\t\t\t\t\tarche_platform_wd_irq_thread,\n\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), arche_pdata);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request wake detect IRQ %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdisable_irq(arche_pdata->wake_detect_irq);\n\n\tret = device_create_file(dev, &dev_attr_state);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to create state file in sysfs\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_platform_populate(np, NULL, NULL, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to populate child nodes %d\\n\", ret);\n\t\tgoto err_device_remove;\n\t}\n\n\tarche_pdata->pm_notifier.notifier_call = arche_platform_pm_notifier;\n\tret = register_pm_notifier(&arche_pdata->pm_notifier);\n\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register pm notifier %d\\n\", ret);\n\t\tgoto err_device_remove;\n\t}\n\n\t \n\tif (!of_property_read_bool(pdev->dev.of_node, \"arche,init-off\")) {\n\t\tmutex_lock(&arche_pdata->platform_state_mutex);\n\t\tret = arche_platform_coldboot_seq(arche_pdata);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to cold boot svc %d\\n\", ret);\n\t\t\tgoto err_coldboot;\n\t\t}\n\t\tarche_platform_wd_irq_en(arche_pdata);\n\t\tmutex_unlock(&arche_pdata->platform_state_mutex);\n\t}\n\n\tdev_info(dev, \"Device registered successfully\\n\");\n\treturn 0;\n\nerr_coldboot:\n\tmutex_unlock(&arche_pdata->platform_state_mutex);\nerr_device_remove:\n\tdevice_remove_file(&pdev->dev, &dev_attr_state);\n\treturn ret;\n}\n\nstatic int arche_remove_child(struct device *dev, void *unused)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tplatform_device_unregister(pdev);\n\n\treturn 0;\n}\n\nstatic void arche_platform_remove(struct platform_device *pdev)\n{\n\tstruct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);\n\n\tunregister_pm_notifier(&arche_pdata->pm_notifier);\n\tdevice_remove_file(&pdev->dev, &dev_attr_state);\n\tdevice_for_each_child(&pdev->dev, NULL, arche_remove_child);\n\tarche_platform_poweroff_seq(arche_pdata);\n\n\tif (usb3613_hub_mode_ctrl(false))\n\t\tdev_warn(arche_pdata->dev, \"failed to control hub device\\n\");\n}\n\nstatic __maybe_unused int arche_platform_suspend(struct device *dev)\n{\n\t \n\treturn 0;\n}\n\nstatic __maybe_unused int arche_platform_resume(struct device *dev)\n{\n\t \n\treturn 0;\n}\n\nstatic void arche_platform_shutdown(struct platform_device *pdev)\n{\n\tstruct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);\n\n\tarche_platform_poweroff_seq(arche_pdata);\n\n\tusb3613_hub_mode_ctrl(false);\n}\n\nstatic SIMPLE_DEV_PM_OPS(arche_platform_pm_ops,\n\t\t\tarche_platform_suspend,\n\t\t\tarche_platform_resume);\n\nstatic const struct of_device_id arche_platform_of_match[] = {\n\t \n\t{ .compatible = \"google,arche-platform\", },\n\t{ },\n};\n\nstatic const struct of_device_id arche_combined_id[] = {\n\t \n\t{ .compatible = \"google,arche-platform\", },\n\t{ .compatible = \"usbffff,2\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, arche_combined_id);\n\nstatic struct platform_driver arche_platform_device_driver = {\n\t.probe\t\t= arche_platform_probe,\n\t.remove_new\t= arche_platform_remove,\n\t.shutdown\t= arche_platform_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"arche-platform-ctrl\",\n\t\t.pm\t= &arche_platform_pm_ops,\n\t\t.of_match_table = arche_platform_of_match,\n\t}\n};\n\nstatic int __init arche_init(void)\n{\n\tint retval;\n\n\tretval = platform_driver_register(&arche_platform_device_driver);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = arche_apb_init();\n\tif (retval)\n\t\tplatform_driver_unregister(&arche_platform_device_driver);\n\n\treturn retval;\n}\nmodule_init(arche_init);\n\nstatic void __exit arche_exit(void)\n{\n\tarche_apb_exit();\n\tplatform_driver_unregister(&arche_platform_device_driver);\n}\nmodule_exit(arche_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Vaibhav Hiremath <vaibhav.hiremath@linaro.org>\");\nMODULE_DESCRIPTION(\"Arche Platform Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}