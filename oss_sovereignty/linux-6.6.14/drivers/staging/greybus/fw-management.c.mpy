{
  "module_name": "fw-management.c",
  "hash_id": "396890b4b7585532ccf22f38df18e7a7af25a0aea25d2188a036819d6cc842d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/fw-management.c",
  "human_readable_source": "\n \n\n#include <linux/cdev.h>\n#include <linux/completion.h>\n#include <linux/firmware.h>\n#include <linux/fs.h>\n#include <linux/idr.h>\n#include <linux/ioctl.h>\n#include <linux/uaccess.h>\n#include <linux/greybus.h>\n\n#include \"firmware.h\"\n#include \"greybus_firmware.h\"\n\n#define FW_MGMT_TIMEOUT_MS\t\t1000\n\nstruct fw_mgmt {\n\tstruct device\t\t*parent;\n\tstruct gb_connection\t*connection;\n\tstruct kref\t\tkref;\n\tstruct list_head\tnode;\n\n\t \n\tstruct ida\t\tid_map;\n\tstruct mutex\t\tmutex;\n\tstruct completion\tcompletion;\n\tstruct cdev\t\tcdev;\n\tstruct device\t\t*class_device;\n\tdev_t\t\t\tdev_num;\n\tunsigned int\t\ttimeout_jiffies;\n\tbool\t\t\tdisabled;  \n\n\t \n\tbool\t\t\tmode_switch_started;\n\tbool\t\t\tintf_fw_loaded;\n\tu8\t\t\tintf_fw_request_id;\n\tu8\t\t\tintf_fw_status;\n\tu16\t\t\tintf_fw_major;\n\tu16\t\t\tintf_fw_minor;\n\n\t \n\tu8\t\t\tbackend_fw_request_id;\n\tu8\t\t\tbackend_fw_status;\n};\n\n \n#define NUM_MINORS\t\tU8_MAX\n\nstatic struct class *fw_mgmt_class;\nstatic dev_t fw_mgmt_dev_num;\nstatic DEFINE_IDA(fw_mgmt_minors_map);\nstatic LIST_HEAD(fw_mgmt_list);\nstatic DEFINE_MUTEX(list_mutex);\n\nstatic void fw_mgmt_kref_release(struct kref *kref)\n{\n\tstruct fw_mgmt *fw_mgmt = container_of(kref, struct fw_mgmt, kref);\n\n\tida_destroy(&fw_mgmt->id_map);\n\tkfree(fw_mgmt);\n}\n\n \nstatic void put_fw_mgmt(struct fw_mgmt *fw_mgmt)\n{\n\tkref_put(&fw_mgmt->kref, fw_mgmt_kref_release);\n}\n\n \nstatic struct fw_mgmt *get_fw_mgmt(struct cdev *cdev)\n{\n\tstruct fw_mgmt *fw_mgmt;\n\n\tmutex_lock(&list_mutex);\n\n\tlist_for_each_entry(fw_mgmt, &fw_mgmt_list, node) {\n\t\tif (&fw_mgmt->cdev == cdev) {\n\t\t\tkref_get(&fw_mgmt->kref);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tfw_mgmt = NULL;\n\nunlock:\n\tmutex_unlock(&list_mutex);\n\n\treturn fw_mgmt;\n}\n\nstatic int fw_mgmt_interface_fw_version_operation(struct fw_mgmt *fw_mgmt,\n\t\t\t\t\t\t  struct fw_mgmt_ioc_get_intf_version *fw_info)\n{\n\tstruct gb_connection *connection = fw_mgmt->connection;\n\tstruct gb_fw_mgmt_interface_fw_version_response response;\n\tint ret;\n\n\tret = gb_operation_sync(connection,\n\t\t\t\tGB_FW_MGMT_TYPE_INTERFACE_FW_VERSION, NULL, 0,\n\t\t\t\t&response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(fw_mgmt->parent,\n\t\t\t\"failed to get interface firmware version (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfw_info->major = le16_to_cpu(response.major);\n\tfw_info->minor = le16_to_cpu(response.minor);\n\n\tstrncpy(fw_info->firmware_tag, response.firmware_tag,\n\t\tGB_FIRMWARE_TAG_MAX_SIZE);\n\n\t \n\tif (fw_info->firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] != '\\0') {\n\t\tdev_err(fw_mgmt->parent,\n\t\t\t\"fw-version: firmware-tag is not NULL terminated\\n\");\n\t\tfw_info->firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] = '\\0';\n\t}\n\n\treturn 0;\n}\n\nstatic int fw_mgmt_load_and_validate_operation(struct fw_mgmt *fw_mgmt,\n\t\t\t\t\t       u8 load_method, const char *tag)\n{\n\tstruct gb_fw_mgmt_load_and_validate_fw_request request;\n\tint ret;\n\n\tif (load_method != GB_FW_LOAD_METHOD_UNIPRO &&\n\t    load_method != GB_FW_LOAD_METHOD_INTERNAL) {\n\t\tdev_err(fw_mgmt->parent,\n\t\t\t\"invalid load-method (%d)\\n\", load_method);\n\t\treturn -EINVAL;\n\t}\n\n\trequest.load_method = load_method;\n\tstrncpy(request.firmware_tag, tag, GB_FIRMWARE_TAG_MAX_SIZE);\n\n\t \n\tif (request.firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] != '\\0') {\n\t\tdev_err(fw_mgmt->parent, \"load-and-validate: firmware-tag is not NULL terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = ida_simple_get(&fw_mgmt->id_map, 1, 256, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tdev_err(fw_mgmt->parent, \"failed to allocate request id (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tfw_mgmt->intf_fw_request_id = ret;\n\tfw_mgmt->intf_fw_loaded = false;\n\trequest.request_id = ret;\n\n\tret = gb_operation_sync(fw_mgmt->connection,\n\t\t\t\tGB_FW_MGMT_TYPE_LOAD_AND_VALIDATE_FW, &request,\n\t\t\t\tsizeof(request), NULL, 0);\n\tif (ret) {\n\t\tida_simple_remove(&fw_mgmt->id_map,\n\t\t\t\t  fw_mgmt->intf_fw_request_id);\n\t\tfw_mgmt->intf_fw_request_id = 0;\n\t\tdev_err(fw_mgmt->parent,\n\t\t\t\"load and validate firmware request failed (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fw_mgmt_interface_fw_loaded_operation(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct fw_mgmt *fw_mgmt = gb_connection_get_data(connection);\n\tstruct gb_fw_mgmt_loaded_fw_request *request;\n\n\t \n\tif (!fw_mgmt->intf_fw_request_id) {\n\t\tdev_err(fw_mgmt->parent,\n\t\t\t\"unexpected firmware loaded request received\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (op->request->payload_size != sizeof(*request)) {\n\t\tdev_err(fw_mgmt->parent, \"illegal size of firmware loaded request (%zu != %zu)\\n\",\n\t\t\top->request->payload_size, sizeof(*request));\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request->payload;\n\n\t \n\tif (request->request_id != fw_mgmt->intf_fw_request_id) {\n\t\tdev_err(fw_mgmt->parent, \"invalid request id for firmware loaded request (%02u != %02u)\\n\",\n\t\t\tfw_mgmt->intf_fw_request_id, request->request_id);\n\t\treturn -ENODEV;\n\t}\n\n\tida_simple_remove(&fw_mgmt->id_map, fw_mgmt->intf_fw_request_id);\n\tfw_mgmt->intf_fw_request_id = 0;\n\tfw_mgmt->intf_fw_status = request->status;\n\tfw_mgmt->intf_fw_major = le16_to_cpu(request->major);\n\tfw_mgmt->intf_fw_minor = le16_to_cpu(request->minor);\n\n\tif (fw_mgmt->intf_fw_status == GB_FW_LOAD_STATUS_FAILED)\n\t\tdev_err(fw_mgmt->parent,\n\t\t\t\"failed to load interface firmware, status:%02x\\n\",\n\t\t\tfw_mgmt->intf_fw_status);\n\telse if (fw_mgmt->intf_fw_status == GB_FW_LOAD_STATUS_VALIDATION_FAILED)\n\t\tdev_err(fw_mgmt->parent,\n\t\t\t\"failed to validate interface firmware, status:%02x\\n\",\n\t\t\tfw_mgmt->intf_fw_status);\n\telse\n\t\tfw_mgmt->intf_fw_loaded = true;\n\n\tcomplete(&fw_mgmt->completion);\n\n\treturn 0;\n}\n\nstatic int fw_mgmt_backend_fw_version_operation(struct fw_mgmt *fw_mgmt,\n\t\t\t\t\t\tstruct fw_mgmt_ioc_get_backend_version *fw_info)\n{\n\tstruct gb_connection *connection = fw_mgmt->connection;\n\tstruct gb_fw_mgmt_backend_fw_version_request request;\n\tstruct gb_fw_mgmt_backend_fw_version_response response;\n\tint ret;\n\n\tstrncpy(request.firmware_tag, fw_info->firmware_tag,\n\t\tGB_FIRMWARE_TAG_MAX_SIZE);\n\n\t \n\tif (request.firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] != '\\0') {\n\t\tdev_err(fw_mgmt->parent, \"backend-version: firmware-tag is not NULL terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = gb_operation_sync(connection,\n\t\t\t\tGB_FW_MGMT_TYPE_BACKEND_FW_VERSION, &request,\n\t\t\t\tsizeof(request), &response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(fw_mgmt->parent, \"failed to get version of %s backend firmware (%d)\\n\",\n\t\t\tfw_info->firmware_tag, ret);\n\t\treturn ret;\n\t}\n\n\tfw_info->status = response.status;\n\n\t \n\tfw_info->major = 0;\n\tfw_info->minor = 0;\n\n\tswitch (fw_info->status) {\n\tcase GB_FW_BACKEND_VERSION_STATUS_SUCCESS:\n\t\tfw_info->major = le16_to_cpu(response.major);\n\t\tfw_info->minor = le16_to_cpu(response.minor);\n\t\tbreak;\n\tcase GB_FW_BACKEND_VERSION_STATUS_NOT_AVAILABLE:\n\tcase GB_FW_BACKEND_VERSION_STATUS_RETRY:\n\t\tbreak;\n\tcase GB_FW_BACKEND_VERSION_STATUS_NOT_SUPPORTED:\n\t\tdev_err(fw_mgmt->parent,\n\t\t\t\"Firmware with tag %s is not supported by Interface\\n\",\n\t\t\tfw_info->firmware_tag);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(fw_mgmt->parent, \"Invalid status received: %u\\n\",\n\t\t\tfw_info->status);\n\t}\n\n\treturn 0;\n}\n\nstatic int fw_mgmt_backend_fw_update_operation(struct fw_mgmt *fw_mgmt,\n\t\t\t\t\t       char *tag)\n{\n\tstruct gb_fw_mgmt_backend_fw_update_request request;\n\tint ret;\n\n\tstrncpy(request.firmware_tag, tag, GB_FIRMWARE_TAG_MAX_SIZE);\n\n\t \n\tif (request.firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] != '\\0') {\n\t\tdev_err(fw_mgmt->parent, \"backend-update: firmware-tag is not NULL terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = ida_simple_get(&fw_mgmt->id_map, 1, 256, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tdev_err(fw_mgmt->parent, \"failed to allocate request id (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tfw_mgmt->backend_fw_request_id = ret;\n\trequest.request_id = ret;\n\n\tret = gb_operation_sync(fw_mgmt->connection,\n\t\t\t\tGB_FW_MGMT_TYPE_BACKEND_FW_UPDATE, &request,\n\t\t\t\tsizeof(request), NULL, 0);\n\tif (ret) {\n\t\tida_simple_remove(&fw_mgmt->id_map,\n\t\t\t\t  fw_mgmt->backend_fw_request_id);\n\t\tfw_mgmt->backend_fw_request_id = 0;\n\t\tdev_err(fw_mgmt->parent,\n\t\t\t\"backend %s firmware update request failed (%d)\\n\", tag,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fw_mgmt_backend_fw_updated_operation(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct fw_mgmt *fw_mgmt = gb_connection_get_data(connection);\n\tstruct gb_fw_mgmt_backend_fw_updated_request *request;\n\n\t \n\tif (!fw_mgmt->backend_fw_request_id) {\n\t\tdev_err(fw_mgmt->parent, \"unexpected backend firmware updated request received\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (op->request->payload_size != sizeof(*request)) {\n\t\tdev_err(fw_mgmt->parent, \"illegal size of backend firmware updated request (%zu != %zu)\\n\",\n\t\t\top->request->payload_size, sizeof(*request));\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request->payload;\n\n\t \n\tif (request->request_id != fw_mgmt->backend_fw_request_id) {\n\t\tdev_err(fw_mgmt->parent, \"invalid request id for backend firmware updated request (%02u != %02u)\\n\",\n\t\t\tfw_mgmt->backend_fw_request_id, request->request_id);\n\t\treturn -ENODEV;\n\t}\n\n\tida_simple_remove(&fw_mgmt->id_map, fw_mgmt->backend_fw_request_id);\n\tfw_mgmt->backend_fw_request_id = 0;\n\tfw_mgmt->backend_fw_status = request->status;\n\n\tif ((fw_mgmt->backend_fw_status != GB_FW_BACKEND_FW_STATUS_SUCCESS) &&\n\t    (fw_mgmt->backend_fw_status != GB_FW_BACKEND_FW_STATUS_RETRY))\n\t\tdev_err(fw_mgmt->parent,\n\t\t\t\"failed to load backend firmware: %02x\\n\",\n\t\t\tfw_mgmt->backend_fw_status);\n\n\tcomplete(&fw_mgmt->completion);\n\n\treturn 0;\n}\n\n \n\nstatic int fw_mgmt_open(struct inode *inode, struct file *file)\n{\n\tstruct fw_mgmt *fw_mgmt = get_fw_mgmt(inode->i_cdev);\n\n\t \n\tif (fw_mgmt) {\n\t\tfile->private_data = fw_mgmt;\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int fw_mgmt_release(struct inode *inode, struct file *file)\n{\n\tstruct fw_mgmt *fw_mgmt = file->private_data;\n\n\tput_fw_mgmt(fw_mgmt);\n\treturn 0;\n}\n\nstatic int fw_mgmt_ioctl(struct fw_mgmt *fw_mgmt, unsigned int cmd,\n\t\t\t void __user *buf)\n{\n\tstruct fw_mgmt_ioc_get_intf_version intf_fw_info;\n\tstruct fw_mgmt_ioc_get_backend_version backend_fw_info;\n\tstruct fw_mgmt_ioc_intf_load_and_validate intf_load;\n\tstruct fw_mgmt_ioc_backend_fw_update backend_update;\n\tunsigned int timeout;\n\tint ret;\n\n\t \n\tif (fw_mgmt->mode_switch_started)\n\t\treturn -EBUSY;\n\n\tswitch (cmd) {\n\tcase FW_MGMT_IOC_GET_INTF_FW:\n\t\tret = fw_mgmt_interface_fw_version_operation(fw_mgmt,\n\t\t\t\t\t\t\t     &intf_fw_info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user(buf, &intf_fw_info, sizeof(intf_fw_info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\tcase FW_MGMT_IOC_GET_BACKEND_FW:\n\t\tif (copy_from_user(&backend_fw_info, buf,\n\t\t\t\t   sizeof(backend_fw_info)))\n\t\t\treturn -EFAULT;\n\n\t\tret = fw_mgmt_backend_fw_version_operation(fw_mgmt,\n\t\t\t\t\t\t\t   &backend_fw_info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user(buf, &backend_fw_info,\n\t\t\t\t sizeof(backend_fw_info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\tcase FW_MGMT_IOC_INTF_LOAD_AND_VALIDATE:\n\t\tif (copy_from_user(&intf_load, buf, sizeof(intf_load)))\n\t\t\treturn -EFAULT;\n\n\t\tret = fw_mgmt_load_and_validate_operation(fw_mgmt,\n\t\t\t\tintf_load.load_method, intf_load.firmware_tag);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!wait_for_completion_timeout(&fw_mgmt->completion,\n\t\t\t\t\t\t fw_mgmt->timeout_jiffies)) {\n\t\t\tdev_err(fw_mgmt->parent, \"timed out waiting for firmware load and validation to finish\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tintf_load.status = fw_mgmt->intf_fw_status;\n\t\tintf_load.major = fw_mgmt->intf_fw_major;\n\t\tintf_load.minor = fw_mgmt->intf_fw_minor;\n\n\t\tif (copy_to_user(buf, &intf_load, sizeof(intf_load)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\tcase FW_MGMT_IOC_INTF_BACKEND_FW_UPDATE:\n\t\tif (copy_from_user(&backend_update, buf,\n\t\t\t\t   sizeof(backend_update)))\n\t\t\treturn -EFAULT;\n\n\t\tret = fw_mgmt_backend_fw_update_operation(fw_mgmt,\n\t\t\t\t\t\t\t  backend_update.firmware_tag);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!wait_for_completion_timeout(&fw_mgmt->completion,\n\t\t\t\t\t\t fw_mgmt->timeout_jiffies)) {\n\t\t\tdev_err(fw_mgmt->parent, \"timed out waiting for backend firmware update to finish\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tbackend_update.status = fw_mgmt->backend_fw_status;\n\n\t\tif (copy_to_user(buf, &backend_update, sizeof(backend_update)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\tcase FW_MGMT_IOC_SET_TIMEOUT_MS:\n\t\tif (get_user(timeout, (unsigned int __user *)buf))\n\t\t\treturn -EFAULT;\n\n\t\tif (!timeout) {\n\t\t\tdev_err(fw_mgmt->parent, \"timeout can't be zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfw_mgmt->timeout_jiffies = msecs_to_jiffies(timeout);\n\n\t\treturn 0;\n\tcase FW_MGMT_IOC_MODE_SWITCH:\n\t\tif (!fw_mgmt->intf_fw_loaded) {\n\t\t\tdev_err(fw_mgmt->parent,\n\t\t\t\t\"Firmware not loaded for mode-switch\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\t \n\t\tfw_mgmt->mode_switch_started = true;\n\n\t\tret = gb_interface_request_mode_switch(fw_mgmt->connection->intf);\n\t\tif (ret) {\n\t\t\tdev_err(fw_mgmt->parent, \"Mode-switch failed: %d\\n\",\n\t\t\t\tret);\n\t\t\tfw_mgmt->mode_switch_started = false;\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic long fw_mgmt_ioctl_unlocked(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct fw_mgmt *fw_mgmt = file->private_data;\n\tstruct gb_bundle *bundle = fw_mgmt->connection->bundle;\n\tint ret = -ENODEV;\n\n\t \n\tmutex_lock(&fw_mgmt->mutex);\n\tif (!fw_mgmt->disabled) {\n\t\tret = gb_pm_runtime_get_sync(bundle);\n\t\tif (!ret) {\n\t\t\tret = fw_mgmt_ioctl(fw_mgmt, cmd, (void __user *)arg);\n\t\t\tgb_pm_runtime_put_autosuspend(bundle);\n\t\t}\n\t}\n\tmutex_unlock(&fw_mgmt->mutex);\n\n\treturn ret;\n}\n\nstatic const struct file_operations fw_mgmt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= fw_mgmt_open,\n\t.release\t= fw_mgmt_release,\n\t.unlocked_ioctl\t= fw_mgmt_ioctl_unlocked,\n};\n\nint gb_fw_mgmt_request_handler(struct gb_operation *op)\n{\n\tu8 type = op->type;\n\n\tswitch (type) {\n\tcase GB_FW_MGMT_TYPE_LOADED_FW:\n\t\treturn fw_mgmt_interface_fw_loaded_operation(op);\n\tcase GB_FW_MGMT_TYPE_BACKEND_FW_UPDATED:\n\t\treturn fw_mgmt_backend_fw_updated_operation(op);\n\tdefault:\n\t\tdev_err(&op->connection->bundle->dev,\n\t\t\t\"unsupported request: %u\\n\", type);\n\t\treturn -EINVAL;\n\t}\n}\n\nint gb_fw_mgmt_connection_init(struct gb_connection *connection)\n{\n\tstruct fw_mgmt *fw_mgmt;\n\tint ret, minor;\n\n\tif (!connection)\n\t\treturn 0;\n\n\tfw_mgmt = kzalloc(sizeof(*fw_mgmt), GFP_KERNEL);\n\tif (!fw_mgmt)\n\t\treturn -ENOMEM;\n\n\tfw_mgmt->parent = &connection->bundle->dev;\n\tfw_mgmt->timeout_jiffies = msecs_to_jiffies(FW_MGMT_TIMEOUT_MS);\n\tfw_mgmt->connection = connection;\n\n\tgb_connection_set_data(connection, fw_mgmt);\n\tinit_completion(&fw_mgmt->completion);\n\tida_init(&fw_mgmt->id_map);\n\tmutex_init(&fw_mgmt->mutex);\n\tkref_init(&fw_mgmt->kref);\n\n\tmutex_lock(&list_mutex);\n\tlist_add(&fw_mgmt->node, &fw_mgmt_list);\n\tmutex_unlock(&list_mutex);\n\n\tret = gb_connection_enable(connection);\n\tif (ret)\n\t\tgoto err_list_del;\n\n\tminor = ida_simple_get(&fw_mgmt_minors_map, 0, NUM_MINORS, GFP_KERNEL);\n\tif (minor < 0) {\n\t\tret = minor;\n\t\tgoto err_connection_disable;\n\t}\n\n\t \n\tfw_mgmt->dev_num = MKDEV(MAJOR(fw_mgmt_dev_num), minor);\n\tcdev_init(&fw_mgmt->cdev, &fw_mgmt_fops);\n\n\tret = cdev_add(&fw_mgmt->cdev, fw_mgmt->dev_num, 1);\n\tif (ret)\n\t\tgoto err_remove_ida;\n\n\t \n\tfw_mgmt->class_device = device_create(fw_mgmt_class, fw_mgmt->parent,\n\t\t\t\t\t      fw_mgmt->dev_num, NULL,\n\t\t\t\t\t      \"gb-fw-mgmt-%d\", minor);\n\tif (IS_ERR(fw_mgmt->class_device)) {\n\t\tret = PTR_ERR(fw_mgmt->class_device);\n\t\tgoto err_del_cdev;\n\t}\n\n\treturn 0;\n\nerr_del_cdev:\n\tcdev_del(&fw_mgmt->cdev);\nerr_remove_ida:\n\tida_simple_remove(&fw_mgmt_minors_map, minor);\nerr_connection_disable:\n\tgb_connection_disable(connection);\nerr_list_del:\n\tmutex_lock(&list_mutex);\n\tlist_del(&fw_mgmt->node);\n\tmutex_unlock(&list_mutex);\n\n\tput_fw_mgmt(fw_mgmt);\n\n\treturn ret;\n}\n\nvoid gb_fw_mgmt_connection_exit(struct gb_connection *connection)\n{\n\tstruct fw_mgmt *fw_mgmt;\n\n\tif (!connection)\n\t\treturn;\n\n\tfw_mgmt = gb_connection_get_data(connection);\n\n\tdevice_destroy(fw_mgmt_class, fw_mgmt->dev_num);\n\tcdev_del(&fw_mgmt->cdev);\n\tida_simple_remove(&fw_mgmt_minors_map, MINOR(fw_mgmt->dev_num));\n\n\t \n\tmutex_lock(&fw_mgmt->mutex);\n\tfw_mgmt->disabled = true;\n\tmutex_unlock(&fw_mgmt->mutex);\n\n\t \n\tgb_connection_disable(fw_mgmt->connection);\n\n\t \n\tmutex_lock(&list_mutex);\n\tlist_del(&fw_mgmt->node);\n\tmutex_unlock(&list_mutex);\n\n\t \n\tput_fw_mgmt(fw_mgmt);\n}\n\nint fw_mgmt_init(void)\n{\n\tint ret;\n\n\tfw_mgmt_class = class_create(\"gb_fw_mgmt\");\n\tif (IS_ERR(fw_mgmt_class))\n\t\treturn PTR_ERR(fw_mgmt_class);\n\n\tret = alloc_chrdev_region(&fw_mgmt_dev_num, 0, NUM_MINORS,\n\t\t\t\t  \"gb_fw_mgmt\");\n\tif (ret)\n\t\tgoto err_remove_class;\n\n\treturn 0;\n\nerr_remove_class:\n\tclass_destroy(fw_mgmt_class);\n\treturn ret;\n}\n\nvoid fw_mgmt_exit(void)\n{\n\tunregister_chrdev_region(fw_mgmt_dev_num, NUM_MINORS);\n\tclass_destroy(fw_mgmt_class);\n\tida_destroy(&fw_mgmt_minors_map);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}