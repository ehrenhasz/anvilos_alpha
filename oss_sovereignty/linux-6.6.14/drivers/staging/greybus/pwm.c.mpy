{
  "module_name": "pwm.c",
  "hash_id": "969c8b93123c8f2cfca45f9a6dd15755857839da9df3eb0c8cf50cecf9c6ab72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/pwm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pwm.h>\n#include <linux/greybus.h>\n\n#include \"gbphy.h\"\n\nstruct gb_pwm_chip {\n\tstruct gb_connection\t*connection;\n\tu8\t\t\tpwm_max;\t \n\n\tstruct pwm_chip\t\tchip;\n};\n\nstatic inline struct gb_pwm_chip *pwm_chip_to_gb_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct gb_pwm_chip, chip);\n}\n\nstatic int gb_pwm_count_operation(struct gb_pwm_chip *pwmc)\n{\n\tstruct gb_pwm_count_response response;\n\tint ret;\n\n\tret = gb_operation_sync(pwmc->connection, GB_PWM_TYPE_PWM_COUNT,\n\t\t\t\tNULL, 0, &response, sizeof(response));\n\tif (ret)\n\t\treturn ret;\n\tpwmc->pwm_max = response.count;\n\treturn 0;\n}\n\nstatic int gb_pwm_activate_operation(struct gb_pwm_chip *pwmc,\n\t\t\t\t     u8 which)\n{\n\tstruct gb_pwm_activate_request request;\n\tstruct gbphy_device *gbphy_dev;\n\tint ret;\n\n\tif (which > pwmc->pwm_max)\n\t\treturn -EINVAL;\n\n\trequest.which = which;\n\n\tgbphy_dev = to_gbphy_dev(pwmc->chip.dev);\n\tret = gbphy_runtime_get_sync(gbphy_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_operation_sync(pwmc->connection, GB_PWM_TYPE_ACTIVATE,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\n\tgbphy_runtime_put_autosuspend(gbphy_dev);\n\n\treturn ret;\n}\n\nstatic int gb_pwm_deactivate_operation(struct gb_pwm_chip *pwmc,\n\t\t\t\t       u8 which)\n{\n\tstruct gb_pwm_deactivate_request request;\n\tstruct gbphy_device *gbphy_dev;\n\tint ret;\n\n\tif (which > pwmc->pwm_max)\n\t\treturn -EINVAL;\n\n\trequest.which = which;\n\n\tgbphy_dev = to_gbphy_dev(pwmc->chip.dev);\n\tret = gbphy_runtime_get_sync(gbphy_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_operation_sync(pwmc->connection, GB_PWM_TYPE_DEACTIVATE,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\n\tgbphy_runtime_put_autosuspend(gbphy_dev);\n\n\treturn ret;\n}\n\nstatic int gb_pwm_config_operation(struct gb_pwm_chip *pwmc,\n\t\t\t\t   u8 which, u32 duty, u32 period)\n{\n\tstruct gb_pwm_config_request request;\n\tstruct gbphy_device *gbphy_dev;\n\tint ret;\n\n\tif (which > pwmc->pwm_max)\n\t\treturn -EINVAL;\n\n\trequest.which = which;\n\trequest.duty = cpu_to_le32(duty);\n\trequest.period = cpu_to_le32(period);\n\n\tgbphy_dev = to_gbphy_dev(pwmc->chip.dev);\n\tret = gbphy_runtime_get_sync(gbphy_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_operation_sync(pwmc->connection, GB_PWM_TYPE_CONFIG,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\n\tgbphy_runtime_put_autosuspend(gbphy_dev);\n\n\treturn ret;\n}\n\nstatic int gb_pwm_set_polarity_operation(struct gb_pwm_chip *pwmc,\n\t\t\t\t\t u8 which, u8 polarity)\n{\n\tstruct gb_pwm_polarity_request request;\n\tstruct gbphy_device *gbphy_dev;\n\tint ret;\n\n\tif (which > pwmc->pwm_max)\n\t\treturn -EINVAL;\n\n\trequest.which = which;\n\trequest.polarity = polarity;\n\n\tgbphy_dev = to_gbphy_dev(pwmc->chip.dev);\n\tret = gbphy_runtime_get_sync(gbphy_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_operation_sync(pwmc->connection, GB_PWM_TYPE_POLARITY,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\n\tgbphy_runtime_put_autosuspend(gbphy_dev);\n\n\treturn ret;\n}\n\nstatic int gb_pwm_enable_operation(struct gb_pwm_chip *pwmc,\n\t\t\t\t   u8 which)\n{\n\tstruct gb_pwm_enable_request request;\n\tstruct gbphy_device *gbphy_dev;\n\tint ret;\n\n\tif (which > pwmc->pwm_max)\n\t\treturn -EINVAL;\n\n\trequest.which = which;\n\n\tgbphy_dev = to_gbphy_dev(pwmc->chip.dev);\n\tret = gbphy_runtime_get_sync(gbphy_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_operation_sync(pwmc->connection, GB_PWM_TYPE_ENABLE,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\tif (ret)\n\t\tgbphy_runtime_put_autosuspend(gbphy_dev);\n\n\treturn ret;\n}\n\nstatic int gb_pwm_disable_operation(struct gb_pwm_chip *pwmc,\n\t\t\t\t    u8 which)\n{\n\tstruct gb_pwm_disable_request request;\n\tstruct gbphy_device *gbphy_dev;\n\tint ret;\n\n\tif (which > pwmc->pwm_max)\n\t\treturn -EINVAL;\n\n\trequest.which = which;\n\n\tret = gb_operation_sync(pwmc->connection, GB_PWM_TYPE_DISABLE,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\n\tgbphy_dev = to_gbphy_dev(pwmc->chip.dev);\n\tgbphy_runtime_put_autosuspend(gbphy_dev);\n\n\treturn ret;\n}\n\nstatic int gb_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct gb_pwm_chip *pwmc = pwm_chip_to_gb_pwm_chip(chip);\n\n\treturn gb_pwm_activate_operation(pwmc, pwm->hwpwm);\n};\n\nstatic void gb_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct gb_pwm_chip *pwmc = pwm_chip_to_gb_pwm_chip(chip);\n\n\tif (pwm_is_enabled(pwm))\n\t\tdev_warn(chip->dev, \"freeing PWM device without disabling\\n\");\n\n\tgb_pwm_deactivate_operation(pwmc, pwm->hwpwm);\n}\n\nstatic int gb_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\tconst struct pwm_state *state)\n{\n\tint err;\n\tbool enabled = pwm->state.enabled;\n\tu64 period = state->period;\n\tu64 duty_cycle = state->duty_cycle;\n\tstruct gb_pwm_chip *pwmc = pwm_chip_to_gb_pwm_chip(chip);\n\n\t \n\tif (state->polarity != pwm->state.polarity) {\n\t\tif (enabled) {\n\t\t\tgb_pwm_disable_operation(pwmc, pwm->hwpwm);\n\t\t\tenabled = false;\n\t\t}\n\t\terr = gb_pwm_set_polarity_operation(pwmc, pwm->hwpwm, state->polarity);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!state->enabled) {\n\t\tif (enabled)\n\t\t\tgb_pwm_disable_operation(pwmc, pwm->hwpwm);\n\t\treturn 0;\n\t}\n\n\t \n\tif (period > U32_MAX)\n\t\tperiod = U32_MAX;\n\n\tif (duty_cycle > period)\n\t\tduty_cycle = period;\n\n\terr = gb_pwm_config_operation(pwmc, pwm->hwpwm, duty_cycle, period);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!enabled)\n\t\treturn gb_pwm_enable_operation(pwmc, pwm->hwpwm);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops gb_pwm_ops = {\n\t.request = gb_pwm_request,\n\t.free = gb_pwm_free,\n\t.apply = gb_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int gb_pwm_probe(struct gbphy_device *gbphy_dev,\n\t\t\tconst struct gbphy_device_id *id)\n{\n\tstruct gb_connection *connection;\n\tstruct gb_pwm_chip *pwmc;\n\tstruct pwm_chip *chip;\n\tint ret;\n\n\tpwmc = kzalloc(sizeof(*pwmc), GFP_KERNEL);\n\tif (!pwmc)\n\t\treturn -ENOMEM;\n\n\tconnection = gb_connection_create(gbphy_dev->bundle,\n\t\t\t\t\t  le16_to_cpu(gbphy_dev->cport_desc->id),\n\t\t\t\t\t  NULL);\n\tif (IS_ERR(connection)) {\n\t\tret = PTR_ERR(connection);\n\t\tgoto exit_pwmc_free;\n\t}\n\n\tpwmc->connection = connection;\n\tgb_connection_set_data(connection, pwmc);\n\tgb_gbphy_set_data(gbphy_dev, pwmc);\n\n\tret = gb_connection_enable(connection);\n\tif (ret)\n\t\tgoto exit_connection_destroy;\n\n\t \n\tret = gb_pwm_count_operation(pwmc);\n\tif (ret)\n\t\tgoto exit_connection_disable;\n\n\tchip = &pwmc->chip;\n\n\tchip->dev = &gbphy_dev->dev;\n\tchip->ops = &gb_pwm_ops;\n\tchip->npwm = pwmc->pwm_max + 1;\n\n\tret = pwmchip_add(chip);\n\tif (ret) {\n\t\tdev_err(&gbphy_dev->dev,\n\t\t\t\"failed to register PWM: %d\\n\", ret);\n\t\tgoto exit_connection_disable;\n\t}\n\n\tgbphy_runtime_put_autosuspend(gbphy_dev);\n\treturn 0;\n\nexit_connection_disable:\n\tgb_connection_disable(connection);\nexit_connection_destroy:\n\tgb_connection_destroy(connection);\nexit_pwmc_free:\n\tkfree(pwmc);\n\treturn ret;\n}\n\nstatic void gb_pwm_remove(struct gbphy_device *gbphy_dev)\n{\n\tstruct gb_pwm_chip *pwmc = gb_gbphy_get_data(gbphy_dev);\n\tstruct gb_connection *connection = pwmc->connection;\n\tint ret;\n\n\tret = gbphy_runtime_get_sync(gbphy_dev);\n\tif (ret)\n\t\tgbphy_runtime_get_noresume(gbphy_dev);\n\n\tpwmchip_remove(&pwmc->chip);\n\tgb_connection_disable(connection);\n\tgb_connection_destroy(connection);\n\tkfree(pwmc);\n}\n\nstatic const struct gbphy_device_id gb_pwm_id_table[] = {\n\t{ GBPHY_PROTOCOL(GREYBUS_PROTOCOL_PWM) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(gbphy, gb_pwm_id_table);\n\nstatic struct gbphy_driver pwm_driver = {\n\t.name\t\t= \"pwm\",\n\t.probe\t\t= gb_pwm_probe,\n\t.remove\t\t= gb_pwm_remove,\n\t.id_table\t= gb_pwm_id_table,\n};\n\nmodule_gbphy_driver(pwm_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}