{
  "module_name": "gpio.c",
  "hash_id": "f7d2a6e0facf5d808e272bad771e364d61c9b7d22dbf00302f28a5e4962c9d28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/gpio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/gpio/driver.h>\n#include <linux/mutex.h>\n#include <linux/greybus.h>\n\n#include \"gbphy.h\"\n\nstruct gb_gpio_line {\n\t \n\t \n\tu8\t\t\tactive:    1,\n\t\t\t\tdirection: 1,\t \n\t\t\t\tvalue:     1;\t \n\tu16\t\t\tdebounce_usec;\n\n\tu8\t\t\tirq_type;\n\tbool\t\t\tirq_type_pending;\n\tbool\t\t\tmasked;\n\tbool\t\t\tmasked_pending;\n};\n\nstruct gb_gpio_controller {\n\tstruct gbphy_device\t*gbphy_dev;\n\tstruct gb_connection\t*connection;\n\tu8\t\t\tline_max;\t \n\tstruct gb_gpio_line\t*lines;\n\n\tstruct gpio_chip\tchip;\n\tstruct irq_chip\t\tirqc;\n\tstruct mutex\t\tirq_lock;\n};\n\nstatic inline struct gb_gpio_controller *gpio_chip_to_gb_gpio_controller(struct gpio_chip *chip)\n{\n\treturn container_of(chip, struct gb_gpio_controller, chip);\n}\n\nstatic struct gpio_chip *irq_data_to_gpio_chip(struct irq_data *d)\n{\n\treturn d->domain->host_data;\n}\n\nstatic int gb_gpio_line_count_operation(struct gb_gpio_controller *ggc)\n{\n\tstruct gb_gpio_line_count_response response;\n\tint ret;\n\n\tret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_LINE_COUNT,\n\t\t\t\tNULL, 0, &response, sizeof(response));\n\tif (!ret)\n\t\tggc->line_max = response.count;\n\treturn ret;\n}\n\nstatic int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)\n{\n\tstruct gb_gpio_activate_request request;\n\tstruct gbphy_device *gbphy_dev = ggc->gbphy_dev;\n\tint ret;\n\n\tret = gbphy_runtime_get_sync(gbphy_dev);\n\tif (ret)\n\t\treturn ret;\n\n\trequest.which = which;\n\tret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_ACTIVATE,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\tif (ret) {\n\t\tgbphy_runtime_put_autosuspend(gbphy_dev);\n\t\treturn ret;\n\t}\n\n\tggc->lines[which].active = true;\n\n\treturn 0;\n}\n\nstatic void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,\n\t\t\t\t\t u8 which)\n{\n\tstruct gbphy_device *gbphy_dev = ggc->gbphy_dev;\n\tstruct device *dev = &gbphy_dev->dev;\n\tstruct gb_gpio_deactivate_request request;\n\tint ret;\n\n\trequest.which = which;\n\tret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DEACTIVATE,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to deactivate gpio %u\\n\", which);\n\t\tgoto out_pm_put;\n\t}\n\n\tggc->lines[which].active = false;\n\nout_pm_put:\n\tgbphy_runtime_put_autosuspend(gbphy_dev);\n}\n\nstatic int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,\n\t\t\t\t\t   u8 which)\n{\n\tstruct device *dev = &ggc->gbphy_dev->dev;\n\tstruct gb_gpio_get_direction_request request;\n\tstruct gb_gpio_get_direction_response response;\n\tint ret;\n\tu8 direction;\n\n\trequest.which = which;\n\tret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_GET_DIRECTION,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret)\n\t\treturn ret;\n\n\tdirection = response.direction;\n\tif (direction && direction != 1) {\n\t\tdev_warn(dev, \"gpio %u direction was %u (should be 0 or 1)\\n\",\n\t\t\t which, direction);\n\t}\n\tggc->lines[which].direction = direction ? 1 : 0;\n\treturn 0;\n}\n\nstatic int gb_gpio_direction_in_operation(struct gb_gpio_controller *ggc,\n\t\t\t\t\t  u8 which)\n{\n\tstruct gb_gpio_direction_in_request request;\n\tint ret;\n\n\trequest.which = which;\n\tret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DIRECTION_IN,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\tif (!ret)\n\t\tggc->lines[which].direction = 1;\n\treturn ret;\n}\n\nstatic int gb_gpio_direction_out_operation(struct gb_gpio_controller *ggc,\n\t\t\t\t\t   u8 which, bool value_high)\n{\n\tstruct gb_gpio_direction_out_request request;\n\tint ret;\n\n\trequest.which = which;\n\trequest.value = value_high ? 1 : 0;\n\tret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DIRECTION_OUT,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\tif (!ret)\n\t\tggc->lines[which].direction = 0;\n\treturn ret;\n}\n\nstatic int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,\n\t\t\t\t       u8 which)\n{\n\tstruct device *dev = &ggc->gbphy_dev->dev;\n\tstruct gb_gpio_get_value_request request;\n\tstruct gb_gpio_get_value_response response;\n\tint ret;\n\tu8 value;\n\n\trequest.which = which;\n\tret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_GET_VALUE,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get value of gpio %u\\n\", which);\n\t\treturn ret;\n\t}\n\n\tvalue = response.value;\n\tif (value && value != 1) {\n\t\tdev_warn(dev, \"gpio %u value was %u (should be 0 or 1)\\n\",\n\t\t\t which, value);\n\t}\n\tggc->lines[which].value = value ? 1 : 0;\n\treturn 0;\n}\n\nstatic void gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,\n\t\t\t\t\tu8 which, bool value_high)\n{\n\tstruct device *dev = &ggc->gbphy_dev->dev;\n\tstruct gb_gpio_set_value_request request;\n\tint ret;\n\n\tif (ggc->lines[which].direction == 1) {\n\t\tdev_warn(dev, \"refusing to set value of input gpio %u\\n\",\n\t\t\t which);\n\t\treturn;\n\t}\n\n\trequest.which = which;\n\trequest.value = value_high ? 1 : 0;\n\tret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_SET_VALUE,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set value of gpio %u\\n\", which);\n\t\treturn;\n\t}\n\n\tggc->lines[which].value = request.value;\n}\n\nstatic int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,\n\t\t\t\t\t  u8 which, u16 debounce_usec)\n{\n\tstruct gb_gpio_set_debounce_request request;\n\tint ret;\n\n\trequest.which = which;\n\trequest.usec = cpu_to_le16(debounce_usec);\n\tret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_SET_DEBOUNCE,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\tif (!ret)\n\t\tggc->lines[which].debounce_usec = debounce_usec;\n\treturn ret;\n}\n\nstatic void _gb_gpio_irq_mask(struct gb_gpio_controller *ggc, u8 hwirq)\n{\n\tstruct device *dev = &ggc->gbphy_dev->dev;\n\tstruct gb_gpio_irq_mask_request request;\n\tint ret;\n\n\trequest.which = hwirq;\n\tret = gb_operation_sync(ggc->connection,\n\t\t\t\tGB_GPIO_TYPE_IRQ_MASK,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\tif (ret)\n\t\tdev_err(dev, \"failed to mask irq: %d\\n\", ret);\n}\n\nstatic void _gb_gpio_irq_unmask(struct gb_gpio_controller *ggc, u8 hwirq)\n{\n\tstruct device *dev = &ggc->gbphy_dev->dev;\n\tstruct gb_gpio_irq_unmask_request request;\n\tint ret;\n\n\trequest.which = hwirq;\n\tret = gb_operation_sync(ggc->connection,\n\t\t\t\tGB_GPIO_TYPE_IRQ_UNMASK,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\tif (ret)\n\t\tdev_err(dev, \"failed to unmask irq: %d\\n\", ret);\n}\n\nstatic void _gb_gpio_irq_set_type(struct gb_gpio_controller *ggc,\n\t\t\t\t  u8 hwirq, u8 type)\n{\n\tstruct device *dev = &ggc->gbphy_dev->dev;\n\tstruct gb_gpio_irq_type_request request;\n\tint ret;\n\n\trequest.which = hwirq;\n\trequest.type = type;\n\n\tret = gb_operation_sync(ggc->connection,\n\t\t\t\tGB_GPIO_TYPE_IRQ_TYPE,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\tif (ret)\n\t\tdev_err(dev, \"failed to set irq type: %d\\n\", ret);\n}\n\nstatic void gb_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_to_gpio_chip(d);\n\tstruct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);\n\tstruct gb_gpio_line *line = &ggc->lines[d->hwirq];\n\n\tline->masked = true;\n\tline->masked_pending = true;\n}\n\nstatic void gb_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_to_gpio_chip(d);\n\tstruct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);\n\tstruct gb_gpio_line *line = &ggc->lines[d->hwirq];\n\n\tline->masked = false;\n\tline->masked_pending = true;\n}\n\nstatic int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *chip = irq_data_to_gpio_chip(d);\n\tstruct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);\n\tstruct gb_gpio_line *line = &ggc->lines[d->hwirq];\n\tstruct device *dev = &ggc->gbphy_dev->dev;\n\tu8 irq_type;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_NONE:\n\t\tirq_type = GB_GPIO_IRQ_TYPE_NONE;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tirq_type = GB_GPIO_IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tirq_type = GB_GPIO_IRQ_TYPE_EDGE_FALLING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tirq_type = GB_GPIO_IRQ_TYPE_EDGE_BOTH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tirq_type = GB_GPIO_IRQ_TYPE_LEVEL_LOW;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tirq_type = GB_GPIO_IRQ_TYPE_LEVEL_HIGH;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported irq type: %u\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tline->irq_type = irq_type;\n\tline->irq_type_pending = true;\n\n\treturn 0;\n}\n\nstatic void gb_gpio_irq_bus_lock(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_to_gpio_chip(d);\n\tstruct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);\n\n\tmutex_lock(&ggc->irq_lock);\n}\n\nstatic void gb_gpio_irq_bus_sync_unlock(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_to_gpio_chip(d);\n\tstruct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);\n\tstruct gb_gpio_line *line = &ggc->lines[d->hwirq];\n\n\tif (line->irq_type_pending) {\n\t\t_gb_gpio_irq_set_type(ggc, d->hwirq, line->irq_type);\n\t\tline->irq_type_pending = false;\n\t}\n\n\tif (line->masked_pending) {\n\t\tif (line->masked)\n\t\t\t_gb_gpio_irq_mask(ggc, d->hwirq);\n\t\telse\n\t\t\t_gb_gpio_irq_unmask(ggc, d->hwirq);\n\t\tline->masked_pending = false;\n\t}\n\n\tmutex_unlock(&ggc->irq_lock);\n}\n\nstatic int gb_gpio_request_handler(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct gb_gpio_controller *ggc = gb_connection_get_data(connection);\n\tstruct device *dev = &ggc->gbphy_dev->dev;\n\tstruct gb_message *request;\n\tstruct gb_gpio_irq_event_request *event;\n\tu8 type = op->type;\n\tint irq, ret;\n\n\tif (type != GB_GPIO_TYPE_IRQ_EVENT) {\n\t\tdev_err(dev, \"unsupported unsolicited request: %u\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request;\n\n\tif (request->payload_size < sizeof(*event)) {\n\t\tdev_err(dev, \"short event received (%zu < %zu)\\n\",\n\t\t\trequest->payload_size, sizeof(*event));\n\t\treturn -EINVAL;\n\t}\n\n\tevent = request->payload;\n\tif (event->which > ggc->line_max) {\n\t\tdev_err(dev, \"invalid hw irq: %d\\n\", event->which);\n\t\treturn -EINVAL;\n\t}\n\n\tirq = irq_find_mapping(ggc->chip.irq.domain, event->which);\n\tif (!irq) {\n\t\tdev_err(dev, \"failed to find IRQ\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = generic_handle_irq_safe(irq);\n\tif (ret)\n\t\tdev_err(dev, \"failed to invoke irq handler\\n\");\n\n\treturn ret;\n}\n\nstatic int gb_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);\n\n\treturn gb_gpio_activate_operation(ggc, (u8)offset);\n}\n\nstatic void gb_gpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);\n\n\tgb_gpio_deactivate_operation(ggc, (u8)offset);\n}\n\nstatic int gb_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);\n\tu8 which;\n\tint ret;\n\n\twhich = (u8)offset;\n\tret = gb_gpio_get_direction_operation(ggc, which);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ggc->lines[which].direction ? 1 : 0;\n}\n\nstatic int gb_gpio_direction_input(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);\n\n\treturn gb_gpio_direction_in_operation(ggc, (u8)offset);\n}\n\nstatic int gb_gpio_direction_output(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t    int value)\n{\n\tstruct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);\n\n\treturn gb_gpio_direction_out_operation(ggc, (u8)offset, !!value);\n}\n\nstatic int gb_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);\n\tu8 which;\n\tint ret;\n\n\twhich = (u8)offset;\n\tret = gb_gpio_get_value_operation(ggc, which);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ggc->lines[which].value;\n}\n\nstatic void gb_gpio_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);\n\n\tgb_gpio_set_value_operation(ggc, (u8)offset, !!value);\n}\n\nstatic int gb_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t      unsigned long config)\n{\n\tstruct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);\n\tu32 debounce;\n\n\tif (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)\n\t\treturn -ENOTSUPP;\n\n\tdebounce = pinconf_to_config_argument(config);\n\tif (debounce > U16_MAX)\n\t\treturn -EINVAL;\n\n\treturn gb_gpio_set_debounce_operation(ggc, (u8)offset, (u16)debounce);\n}\n\nstatic int gb_gpio_controller_setup(struct gb_gpio_controller *ggc)\n{\n\tint ret;\n\n\t \n\tret = gb_gpio_line_count_operation(ggc);\n\tif (ret)\n\t\treturn ret;\n\n\tggc->lines = kcalloc(ggc->line_max + 1, sizeof(*ggc->lines),\n\t\t\t     GFP_KERNEL);\n\tif (!ggc->lines)\n\t\treturn -ENOMEM;\n\n\treturn ret;\n}\n\nstatic int gb_gpio_probe(struct gbphy_device *gbphy_dev,\n\t\t\t const struct gbphy_device_id *id)\n{\n\tstruct gb_connection *connection;\n\tstruct gb_gpio_controller *ggc;\n\tstruct gpio_chip *gpio;\n\tstruct gpio_irq_chip *girq;\n\tstruct irq_chip *irqc;\n\tint ret;\n\n\tggc = kzalloc(sizeof(*ggc), GFP_KERNEL);\n\tif (!ggc)\n\t\treturn -ENOMEM;\n\n\tconnection =\n\t\tgb_connection_create(gbphy_dev->bundle,\n\t\t\t\t     le16_to_cpu(gbphy_dev->cport_desc->id),\n\t\t\t\t     gb_gpio_request_handler);\n\tif (IS_ERR(connection)) {\n\t\tret = PTR_ERR(connection);\n\t\tgoto exit_ggc_free;\n\t}\n\n\tggc->connection = connection;\n\tgb_connection_set_data(connection, ggc);\n\tggc->gbphy_dev = gbphy_dev;\n\tgb_gbphy_set_data(gbphy_dev, ggc);\n\n\tret = gb_connection_enable_tx(connection);\n\tif (ret)\n\t\tgoto exit_connection_destroy;\n\n\tret = gb_gpio_controller_setup(ggc);\n\tif (ret)\n\t\tgoto exit_connection_disable;\n\n\tirqc = &ggc->irqc;\n\tirqc->irq_mask = gb_gpio_irq_mask;\n\tirqc->irq_unmask = gb_gpio_irq_unmask;\n\tirqc->irq_set_type = gb_gpio_irq_set_type;\n\tirqc->irq_bus_lock = gb_gpio_irq_bus_lock;\n\tirqc->irq_bus_sync_unlock = gb_gpio_irq_bus_sync_unlock;\n\tirqc->name = \"greybus_gpio\";\n\n\tmutex_init(&ggc->irq_lock);\n\n\tgpio = &ggc->chip;\n\n\tgpio->label = \"greybus_gpio\";\n\tgpio->parent = &gbphy_dev->dev;\n\tgpio->owner = THIS_MODULE;\n\n\tgpio->request = gb_gpio_request;\n\tgpio->free = gb_gpio_free;\n\tgpio->get_direction = gb_gpio_get_direction;\n\tgpio->direction_input = gb_gpio_direction_input;\n\tgpio->direction_output = gb_gpio_direction_output;\n\tgpio->get = gb_gpio_get;\n\tgpio->set = gb_gpio_set;\n\tgpio->set_config = gb_gpio_set_config;\n\tgpio->base = -1;\t\t \n\tgpio->ngpio = ggc->line_max + 1;\n\tgpio->can_sleep = true;\n\n\tgirq = &gpio->irq;\n\tgirq->chip = irqc;\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_level_irq;\n\n\tret = gb_connection_enable(connection);\n\tif (ret)\n\t\tgoto exit_line_free;\n\n\tret = gpiochip_add(gpio);\n\tif (ret) {\n\t\tdev_err(&gbphy_dev->dev, \"failed to add gpio chip: %d\\n\", ret);\n\t\tgoto exit_line_free;\n\t}\n\n\tgbphy_runtime_put_autosuspend(gbphy_dev);\n\treturn 0;\n\nexit_line_free:\n\tkfree(ggc->lines);\nexit_connection_disable:\n\tgb_connection_disable(connection);\nexit_connection_destroy:\n\tgb_connection_destroy(connection);\nexit_ggc_free:\n\tkfree(ggc);\n\treturn ret;\n}\n\nstatic void gb_gpio_remove(struct gbphy_device *gbphy_dev)\n{\n\tstruct gb_gpio_controller *ggc = gb_gbphy_get_data(gbphy_dev);\n\tstruct gb_connection *connection = ggc->connection;\n\tint ret;\n\n\tret = gbphy_runtime_get_sync(gbphy_dev);\n\tif (ret)\n\t\tgbphy_runtime_get_noresume(gbphy_dev);\n\n\tgb_connection_disable_rx(connection);\n\tgpiochip_remove(&ggc->chip);\n\tgb_connection_disable(connection);\n\tgb_connection_destroy(connection);\n\tkfree(ggc->lines);\n\tkfree(ggc);\n}\n\nstatic const struct gbphy_device_id gb_gpio_id_table[] = {\n\t{ GBPHY_PROTOCOL(GREYBUS_PROTOCOL_GPIO) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(gbphy, gb_gpio_id_table);\n\nstatic struct gbphy_driver gpio_driver = {\n\t.name\t\t= \"gpio\",\n\t.probe\t\t= gb_gpio_probe,\n\t.remove\t\t= gb_gpio_remove,\n\t.id_table\t= gb_gpio_id_table,\n};\n\nmodule_gbphy_driver(gpio_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}