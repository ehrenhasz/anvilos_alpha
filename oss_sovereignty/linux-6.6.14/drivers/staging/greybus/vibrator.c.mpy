{
  "module_name": "vibrator.c",
  "hash_id": "f68db8a4c71916b561a4a562502c4043a5bfff4c61bc4d6d92f4a03e2c0dc5a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/vibrator.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/kdev_t.h>\n#include <linux/idr.h>\n#include <linux/pm_runtime.h>\n#include <linux/greybus.h>\n\nstruct gb_vibrator_device {\n\tstruct gb_connection\t*connection;\n\tstruct device\t\t*dev;\n\tint\t\t\tminor;\t\t \n\tstruct delayed_work     delayed_work;\n};\n\n \n#define\tGB_VIBRATOR_TYPE_ON\t\t\t0x02\n#define\tGB_VIBRATOR_TYPE_OFF\t\t\t0x03\n\nstatic int turn_off(struct gb_vibrator_device *vib)\n{\n\tstruct gb_bundle *bundle = vib->connection->bundle;\n\tint ret;\n\n\tret = gb_operation_sync(vib->connection, GB_VIBRATOR_TYPE_OFF,\n\t\t\t\tNULL, 0, NULL, 0);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn ret;\n}\n\nstatic int turn_on(struct gb_vibrator_device *vib, u16 timeout_ms)\n{\n\tstruct gb_bundle *bundle = vib->connection->bundle;\n\tint ret;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (cancel_delayed_work_sync(&vib->delayed_work))\n\t\tturn_off(vib);\n\n\tret = gb_operation_sync(vib->connection, GB_VIBRATOR_TYPE_ON,\n\t\t\t\tNULL, 0, NULL, 0);\n\tif (ret) {\n\t\tgb_pm_runtime_put_autosuspend(bundle);\n\t\treturn ret;\n\t}\n\n\tschedule_delayed_work(&vib->delayed_work, msecs_to_jiffies(timeout_ms));\n\n\treturn 0;\n}\n\nstatic void gb_vibrator_worker(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct gb_vibrator_device *vib =\n\t\tcontainer_of(delayed_work,\n\t\t\t     struct gb_vibrator_device,\n\t\t\t     delayed_work);\n\n\tturn_off(vib);\n}\n\nstatic ssize_t timeout_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct gb_vibrator_device *vib = dev_get_drvdata(dev);\n\tunsigned long val;\n\tint retval;\n\n\tretval = kstrtoul(buf, 10, &val);\n\tif (retval < 0) {\n\t\tdev_err(dev, \"could not parse timeout value %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\tif (val)\n\t\tretval = turn_on(vib, (u16)val);\n\telse\n\t\tretval = turn_off(vib);\n\tif (retval)\n\t\treturn retval;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(timeout);\n\nstatic struct attribute *vibrator_attrs[] = {\n\t&dev_attr_timeout.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(vibrator);\n\nstatic struct class vibrator_class = {\n\t.name\t\t= \"vibrator\",\n\t.dev_groups\t= vibrator_groups,\n};\n\nstatic DEFINE_IDA(minors);\n\nstatic int gb_vibrator_probe(struct gb_bundle *bundle,\n\t\t\t     const struct greybus_bundle_id *id)\n{\n\tstruct greybus_descriptor_cport *cport_desc;\n\tstruct gb_connection *connection;\n\tstruct gb_vibrator_device *vib;\n\tstruct device *dev;\n\tint retval;\n\n\tif (bundle->num_cports != 1)\n\t\treturn -ENODEV;\n\n\tcport_desc = &bundle->cport_desc[0];\n\tif (cport_desc->protocol_id != GREYBUS_PROTOCOL_VIBRATOR)\n\t\treturn -ENODEV;\n\n\tvib = kzalloc(sizeof(*vib), GFP_KERNEL);\n\tif (!vib)\n\t\treturn -ENOMEM;\n\n\tconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\n\t\t\t\t\t  NULL);\n\tif (IS_ERR(connection)) {\n\t\tretval = PTR_ERR(connection);\n\t\tgoto err_free_vib;\n\t}\n\tgb_connection_set_data(connection, vib);\n\n\tvib->connection = connection;\n\n\tgreybus_set_drvdata(bundle, vib);\n\n\tretval = gb_connection_enable(connection);\n\tif (retval)\n\t\tgoto err_connection_destroy;\n\n\t \n\tvib->minor = ida_simple_get(&minors, 0, 0, GFP_KERNEL);\n\tif (vib->minor < 0) {\n\t\tretval = vib->minor;\n\t\tgoto err_connection_disable;\n\t}\n\tdev = device_create(&vibrator_class, &bundle->dev,\n\t\t\t    MKDEV(0, 0), vib, \"vibrator%d\", vib->minor);\n\tif (IS_ERR(dev)) {\n\t\tretval = -EINVAL;\n\t\tgoto err_ida_remove;\n\t}\n\tvib->dev = dev;\n\n\tINIT_DELAYED_WORK(&vib->delayed_work, gb_vibrator_worker);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn 0;\n\nerr_ida_remove:\n\tida_simple_remove(&minors, vib->minor);\nerr_connection_disable:\n\tgb_connection_disable(connection);\nerr_connection_destroy:\n\tgb_connection_destroy(connection);\nerr_free_vib:\n\tkfree(vib);\n\n\treturn retval;\n}\n\nstatic void gb_vibrator_disconnect(struct gb_bundle *bundle)\n{\n\tstruct gb_vibrator_device *vib = greybus_get_drvdata(bundle);\n\tint ret;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret)\n\t\tgb_pm_runtime_get_noresume(bundle);\n\n\tif (cancel_delayed_work_sync(&vib->delayed_work))\n\t\tturn_off(vib);\n\n\tdevice_unregister(vib->dev);\n\tida_simple_remove(&minors, vib->minor);\n\tgb_connection_disable(vib->connection);\n\tgb_connection_destroy(vib->connection);\n\tkfree(vib);\n}\n\nstatic const struct greybus_bundle_id gb_vibrator_id_table[] = {\n\t{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_VIBRATOR) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(greybus, gb_vibrator_id_table);\n\nstatic struct greybus_driver gb_vibrator_driver = {\n\t.name\t\t= \"vibrator\",\n\t.probe\t\t= gb_vibrator_probe,\n\t.disconnect\t= gb_vibrator_disconnect,\n\t.id_table\t= gb_vibrator_id_table,\n};\n\nstatic __init int gb_vibrator_init(void)\n{\n\tint retval;\n\n\tretval = class_register(&vibrator_class);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = greybus_register(&gb_vibrator_driver);\n\tif (retval)\n\t\tgoto err_class_unregister;\n\n\treturn 0;\n\nerr_class_unregister:\n\tclass_unregister(&vibrator_class);\n\n\treturn retval;\n}\nmodule_init(gb_vibrator_init);\n\nstatic __exit void gb_vibrator_exit(void)\n{\n\tgreybus_deregister(&gb_vibrator_driver);\n\tclass_unregister(&vibrator_class);\n\tida_destroy(&minors);\n}\nmodule_exit(gb_vibrator_exit);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}