{
  "module_name": "gbphy.c",
  "hash_id": "fe99668a312efa56d4f4f0aba89fa6a458c508cf70552a43b750469b716d3bb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/gbphy.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/greybus.h>\n\n#include \"gbphy.h\"\n\n#define GB_GBPHY_AUTOSUSPEND_MS\t3000\n\nstruct gbphy_host {\n\tstruct gb_bundle *bundle;\n\tstruct list_head devices;\n};\n\nstatic DEFINE_IDA(gbphy_id);\n\nstatic ssize_t protocol_id_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gbphy_device *gbphy_dev = to_gbphy_dev(dev);\n\n\treturn sprintf(buf, \"0x%02x\\n\", gbphy_dev->cport_desc->protocol_id);\n}\nstatic DEVICE_ATTR_RO(protocol_id);\n\nstatic struct attribute *gbphy_dev_attrs[] = {\n\t&dev_attr_protocol_id.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(gbphy_dev);\n\nstatic void gbphy_dev_release(struct device *dev)\n{\n\tstruct gbphy_device *gbphy_dev = to_gbphy_dev(dev);\n\n\tida_simple_remove(&gbphy_id, gbphy_dev->id);\n\tkfree(gbphy_dev);\n}\n\n#ifdef CONFIG_PM\nstatic int gb_gbphy_idle(struct device *dev)\n{\n\tpm_runtime_mark_last_busy(dev);\n\tpm_request_autosuspend(dev);\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops gb_gbphy_pm_ops = {\n\tSET_RUNTIME_PM_OPS(pm_generic_runtime_suspend,\n\t\t\t   pm_generic_runtime_resume,\n\t\t\t   gb_gbphy_idle)\n};\n\nstatic const struct device_type greybus_gbphy_dev_type = {\n\t.name\t =\t\"gbphy_device\",\n\t.release =\tgbphy_dev_release,\n\t.pm\t=\t&gb_gbphy_pm_ops,\n};\n\nstatic int gbphy_dev_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct gbphy_device *gbphy_dev = to_gbphy_dev(dev);\n\tconst struct greybus_descriptor_cport *cport_desc = gbphy_dev->cport_desc;\n\tconst struct gb_bundle *bundle = gbphy_dev->bundle;\n\tconst struct gb_interface *intf = bundle->intf;\n\tconst struct gb_module *module = intf->module;\n\tconst struct gb_host_device *hd = intf->hd;\n\n\tif (add_uevent_var(env, \"BUS=%u\", hd->bus_id))\n\t\treturn -ENOMEM;\n\tif (add_uevent_var(env, \"MODULE=%u\", module->module_id))\n\t\treturn -ENOMEM;\n\tif (add_uevent_var(env, \"INTERFACE=%u\", intf->interface_id))\n\t\treturn -ENOMEM;\n\tif (add_uevent_var(env, \"GREYBUS_ID=%08x/%08x\",\n\t\t\t   intf->vendor_id, intf->product_id))\n\t\treturn -ENOMEM;\n\tif (add_uevent_var(env, \"BUNDLE=%u\", gbphy_dev->bundle->id))\n\t\treturn -ENOMEM;\n\tif (add_uevent_var(env, \"BUNDLE_CLASS=%02x\", bundle->class))\n\t\treturn -ENOMEM;\n\tif (add_uevent_var(env, \"GBPHY=%u\", gbphy_dev->id))\n\t\treturn -ENOMEM;\n\tif (add_uevent_var(env, \"PROTOCOL_ID=%02x\", cport_desc->protocol_id))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic const struct gbphy_device_id *\ngbphy_dev_match_id(struct gbphy_device *gbphy_dev,\n\t\t   struct gbphy_driver *gbphy_drv)\n{\n\tconst struct gbphy_device_id *id = gbphy_drv->id_table;\n\n\tif (!id)\n\t\treturn NULL;\n\n\tfor (; id->protocol_id; id++)\n\t\tif (id->protocol_id == gbphy_dev->cport_desc->protocol_id)\n\t\t\treturn id;\n\n\treturn NULL;\n}\n\nstatic int gbphy_dev_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct gbphy_driver *gbphy_drv = to_gbphy_driver(drv);\n\tstruct gbphy_device *gbphy_dev = to_gbphy_dev(dev);\n\tconst struct gbphy_device_id *id;\n\n\tid = gbphy_dev_match_id(gbphy_dev, gbphy_drv);\n\tif (id)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int gbphy_dev_probe(struct device *dev)\n{\n\tstruct gbphy_driver *gbphy_drv = to_gbphy_driver(dev->driver);\n\tstruct gbphy_device *gbphy_dev = to_gbphy_dev(dev);\n\tconst struct gbphy_device_id *id;\n\tint ret;\n\n\tid = gbphy_dev_match_id(gbphy_dev, gbphy_drv);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\t \n\tret = gb_pm_runtime_get_sync(gbphy_dev->bundle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpm_runtime_set_autosuspend_delay(dev, GB_GBPHY_AUTOSUSPEND_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\t \n\tret = gbphy_drv->probe(gbphy_dev, id);\n\tif (ret) {\n\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_set_suspended(dev);\n\t\tpm_runtime_put_noidle(dev);\n\t\tpm_runtime_dont_use_autosuspend(dev);\n\t}\n\n\tgb_pm_runtime_put_autosuspend(gbphy_dev->bundle);\n\n\treturn ret;\n}\n\nstatic void gbphy_dev_remove(struct device *dev)\n{\n\tstruct gbphy_driver *gbphy_drv = to_gbphy_driver(dev->driver);\n\tstruct gbphy_device *gbphy_dev = to_gbphy_dev(dev);\n\n\tgbphy_drv->remove(gbphy_dev);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_dont_use_autosuspend(dev);\n}\n\nstatic struct bus_type gbphy_bus_type = {\n\t.name =\t\t\"gbphy\",\n\t.match =\tgbphy_dev_match,\n\t.probe =\tgbphy_dev_probe,\n\t.remove =\tgbphy_dev_remove,\n\t.uevent =\tgbphy_dev_uevent,\n};\n\nint gb_gbphy_register_driver(struct gbphy_driver *driver,\n\t\t\t     struct module *owner, const char *mod_name)\n{\n\tint retval;\n\n\tif (greybus_disabled())\n\t\treturn -ENODEV;\n\n\tdriver->driver.bus = &gbphy_bus_type;\n\tdriver->driver.name = driver->name;\n\tdriver->driver.owner = owner;\n\tdriver->driver.mod_name = mod_name;\n\n\tretval = driver_register(&driver->driver);\n\tif (retval)\n\t\treturn retval;\n\n\tpr_info(\"registered new driver %s\\n\", driver->name);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gb_gbphy_register_driver);\n\nvoid gb_gbphy_deregister_driver(struct gbphy_driver *driver)\n{\n\tdriver_unregister(&driver->driver);\n}\nEXPORT_SYMBOL_GPL(gb_gbphy_deregister_driver);\n\nstatic struct gbphy_device *gb_gbphy_create_dev(struct gb_bundle *bundle,\n\t\t\t\t\t\tstruct greybus_descriptor_cport *cport_desc)\n{\n\tstruct gbphy_device *gbphy_dev;\n\tint retval;\n\tint id;\n\n\tid = ida_simple_get(&gbphy_id, 1, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn ERR_PTR(id);\n\n\tgbphy_dev = kzalloc(sizeof(*gbphy_dev), GFP_KERNEL);\n\tif (!gbphy_dev) {\n\t\tida_simple_remove(&gbphy_id, id);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tgbphy_dev->id = id;\n\tgbphy_dev->bundle = bundle;\n\tgbphy_dev->cport_desc = cport_desc;\n\tgbphy_dev->dev.parent = &bundle->dev;\n\tgbphy_dev->dev.bus = &gbphy_bus_type;\n\tgbphy_dev->dev.type = &greybus_gbphy_dev_type;\n\tgbphy_dev->dev.groups = gbphy_dev_groups;\n\tgbphy_dev->dev.dma_mask = bundle->dev.dma_mask;\n\tdev_set_name(&gbphy_dev->dev, \"gbphy%d\", id);\n\n\tretval = device_register(&gbphy_dev->dev);\n\tif (retval) {\n\t\tput_device(&gbphy_dev->dev);\n\t\treturn ERR_PTR(retval);\n\t}\n\n\treturn gbphy_dev;\n}\n\nstatic void gb_gbphy_disconnect(struct gb_bundle *bundle)\n{\n\tstruct gbphy_host *gbphy_host = greybus_get_drvdata(bundle);\n\tstruct gbphy_device *gbphy_dev, *temp;\n\tint ret;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret < 0)\n\t\tgb_pm_runtime_get_noresume(bundle);\n\n\tlist_for_each_entry_safe(gbphy_dev, temp, &gbphy_host->devices, list) {\n\t\tlist_del(&gbphy_dev->list);\n\t\tdevice_unregister(&gbphy_dev->dev);\n\t}\n\n\tkfree(gbphy_host);\n}\n\nstatic int gb_gbphy_probe(struct gb_bundle *bundle,\n\t\t\t  const struct greybus_bundle_id *id)\n{\n\tstruct gbphy_host *gbphy_host;\n\tstruct gbphy_device *gbphy_dev;\n\tint i;\n\n\tif (bundle->num_cports == 0)\n\t\treturn -ENODEV;\n\n\tgbphy_host = kzalloc(sizeof(*gbphy_host), GFP_KERNEL);\n\tif (!gbphy_host)\n\t\treturn -ENOMEM;\n\n\tgbphy_host->bundle = bundle;\n\tINIT_LIST_HEAD(&gbphy_host->devices);\n\tgreybus_set_drvdata(bundle, gbphy_host);\n\n\t \n\tfor (i = 0; i < bundle->num_cports; ++i) {\n\t\tgbphy_dev = gb_gbphy_create_dev(bundle, &bundle->cport_desc[i]);\n\t\tif (IS_ERR(gbphy_dev)) {\n\t\t\tgb_gbphy_disconnect(bundle);\n\t\t\treturn PTR_ERR(gbphy_dev);\n\t\t}\n\t\tlist_add(&gbphy_dev->list, &gbphy_host->devices);\n\t}\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn 0;\n}\n\nstatic const struct greybus_bundle_id gb_gbphy_id_table[] = {\n\t{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_BRIDGED_PHY) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(greybus, gb_gbphy_id_table);\n\nstatic struct greybus_driver gb_gbphy_driver = {\n\t.name\t\t= \"gbphy\",\n\t.probe\t\t= gb_gbphy_probe,\n\t.disconnect\t= gb_gbphy_disconnect,\n\t.id_table\t= gb_gbphy_id_table,\n};\n\nstatic int __init gbphy_init(void)\n{\n\tint retval;\n\n\tretval = bus_register(&gbphy_bus_type);\n\tif (retval) {\n\t\tpr_err(\"gbphy bus register failed (%d)\\n\", retval);\n\t\treturn retval;\n\t}\n\n\tretval = greybus_register(&gb_gbphy_driver);\n\tif (retval) {\n\t\tpr_err(\"error registering greybus driver\\n\");\n\t\tgoto error_gbphy;\n\t}\n\n\treturn 0;\n\nerror_gbphy:\n\tbus_unregister(&gbphy_bus_type);\n\tida_destroy(&gbphy_id);\n\treturn retval;\n}\nmodule_init(gbphy_init);\n\nstatic void __exit gbphy_exit(void)\n{\n\tgreybus_deregister(&gb_gbphy_driver);\n\tbus_unregister(&gbphy_bus_type);\n\tida_destroy(&gbphy_id);\n}\nmodule_exit(gbphy_exit);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}