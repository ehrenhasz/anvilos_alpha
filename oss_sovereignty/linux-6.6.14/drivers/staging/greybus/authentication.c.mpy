{
  "module_name": "authentication.c",
  "hash_id": "0ed20e9b82e3c73181f9b44ae761dd16333f12214102003b1e7aca5068899d75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/authentication.c",
  "human_readable_source": "\n \n\n#include <linux/greybus.h>\n#include <linux/cdev.h>\n#include <linux/fs.h>\n#include <linux/ioctl.h>\n#include <linux/uaccess.h>\n\n#include \"greybus_authentication.h\"\n#include \"firmware.h\"\n\n#define CAP_TIMEOUT_MS\t\t1000\n\n \n#define NUM_MINORS\t\tU8_MAX\n\nstruct gb_cap {\n\tstruct device\t\t*parent;\n\tstruct gb_connection\t*connection;\n\tstruct kref\t\tkref;\n\tstruct list_head\tnode;\n\tbool\t\t\tdisabled;  \n\n\tstruct mutex\t\tmutex;\n\tstruct cdev\t\tcdev;\n\tstruct device\t\t*class_device;\n\tdev_t\t\t\tdev_num;\n};\n\nstatic struct class *cap_class;\nstatic dev_t cap_dev_num;\nstatic DEFINE_IDA(cap_minors_map);\nstatic LIST_HEAD(cap_list);\nstatic DEFINE_MUTEX(list_mutex);\n\nstatic void cap_kref_release(struct kref *kref)\n{\n\tstruct gb_cap *cap = container_of(kref, struct gb_cap, kref);\n\n\tkfree(cap);\n}\n\n \nstatic void put_cap(struct gb_cap *cap)\n{\n\tkref_put(&cap->kref, cap_kref_release);\n}\n\n \nstatic struct gb_cap *get_cap(struct cdev *cdev)\n{\n\tstruct gb_cap *cap;\n\n\tmutex_lock(&list_mutex);\n\n\tlist_for_each_entry(cap, &cap_list, node) {\n\t\tif (&cap->cdev == cdev) {\n\t\t\tkref_get(&cap->kref);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tcap = NULL;\n\nunlock:\n\tmutex_unlock(&list_mutex);\n\n\treturn cap;\n}\n\nstatic int cap_get_endpoint_uid(struct gb_cap *cap, u8 *euid)\n{\n\tstruct gb_connection *connection = cap->connection;\n\tstruct gb_cap_get_endpoint_uid_response response;\n\tint ret;\n\n\tret = gb_operation_sync(connection, GB_CAP_TYPE_GET_ENDPOINT_UID, NULL,\n\t\t\t\t0, &response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(cap->parent, \"failed to get endpoint uid (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmemcpy(euid, response.uid, sizeof(response.uid));\n\n\treturn 0;\n}\n\nstatic int cap_get_ims_certificate(struct gb_cap *cap, u32 class, u32 id,\n\t\t\t\t   u8 *certificate, u32 *size, u8 *result)\n{\n\tstruct gb_connection *connection = cap->connection;\n\tstruct gb_cap_get_ims_certificate_request *request;\n\tstruct gb_cap_get_ims_certificate_response *response;\n\tsize_t max_size = gb_operation_get_payload_size_max(connection);\n\tstruct gb_operation *op;\n\tint ret;\n\n\top = gb_operation_create_flags(connection,\n\t\t\t\t       GB_CAP_TYPE_GET_IMS_CERTIFICATE,\n\t\t\t\t       sizeof(*request), max_size,\n\t\t\t\t       GB_OPERATION_FLAG_SHORT_RESPONSE,\n\t\t\t\t       GFP_KERNEL);\n\tif (!op)\n\t\treturn -ENOMEM;\n\n\trequest = op->request->payload;\n\trequest->certificate_class = cpu_to_le32(class);\n\trequest->certificate_id = cpu_to_le32(id);\n\n\tret = gb_operation_request_send_sync(op);\n\tif (ret) {\n\t\tdev_err(cap->parent, \"failed to get certificate (%d)\\n\", ret);\n\t\tgoto done;\n\t}\n\n\tresponse = op->response->payload;\n\t*result = response->result_code;\n\t*size = op->response->payload_size - sizeof(*response);\n\tmemcpy(certificate, response->certificate, *size);\n\ndone:\n\tgb_operation_put(op);\n\treturn ret;\n}\n\nstatic int cap_authenticate(struct gb_cap *cap, u32 auth_type, u8 *uid,\n\t\t\t    u8 *challenge, u8 *result, u8 *auth_response,\n\t\t\t    u32 *signature_size, u8 *signature)\n{\n\tstruct gb_connection *connection = cap->connection;\n\tstruct gb_cap_authenticate_request *request;\n\tstruct gb_cap_authenticate_response *response;\n\tsize_t max_size = gb_operation_get_payload_size_max(connection);\n\tstruct gb_operation *op;\n\tint ret;\n\n\top = gb_operation_create_flags(connection, GB_CAP_TYPE_AUTHENTICATE,\n\t\t\t\t       sizeof(*request), max_size,\n\t\t\t\t       GB_OPERATION_FLAG_SHORT_RESPONSE,\n\t\t\t\t       GFP_KERNEL);\n\tif (!op)\n\t\treturn -ENOMEM;\n\n\trequest = op->request->payload;\n\trequest->auth_type = cpu_to_le32(auth_type);\n\tmemcpy(request->uid, uid, sizeof(request->uid));\n\tmemcpy(request->challenge, challenge, sizeof(request->challenge));\n\n\tret = gb_operation_request_send_sync(op);\n\tif (ret) {\n\t\tdev_err(cap->parent, \"failed to authenticate (%d)\\n\", ret);\n\t\tgoto done;\n\t}\n\n\tresponse = op->response->payload;\n\t*result = response->result_code;\n\t*signature_size = op->response->payload_size - sizeof(*response);\n\tmemcpy(auth_response, response->response, sizeof(response->response));\n\tmemcpy(signature, response->signature, *signature_size);\n\ndone:\n\tgb_operation_put(op);\n\treturn ret;\n}\n\n \n\nstatic int cap_open(struct inode *inode, struct file *file)\n{\n\tstruct gb_cap *cap = get_cap(inode->i_cdev);\n\n\t \n\tif (cap) {\n\t\tfile->private_data = cap;\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int cap_release(struct inode *inode, struct file *file)\n{\n\tstruct gb_cap *cap = file->private_data;\n\n\tput_cap(cap);\n\treturn 0;\n}\n\nstatic int cap_ioctl(struct gb_cap *cap, unsigned int cmd,\n\t\t     void __user *buf)\n{\n\tstruct cap_ioc_get_endpoint_uid endpoint_uid;\n\tstruct cap_ioc_get_ims_certificate *ims_cert;\n\tstruct cap_ioc_authenticate *authenticate;\n\tsize_t size;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase CAP_IOC_GET_ENDPOINT_UID:\n\t\tret = cap_get_endpoint_uid(cap, endpoint_uid.uid);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user(buf, &endpoint_uid, sizeof(endpoint_uid)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\tcase CAP_IOC_GET_IMS_CERTIFICATE:\n\t\tsize = sizeof(*ims_cert);\n\t\tims_cert = memdup_user(buf, size);\n\t\tif (IS_ERR(ims_cert))\n\t\t\treturn PTR_ERR(ims_cert);\n\n\t\tret = cap_get_ims_certificate(cap, ims_cert->certificate_class,\n\t\t\t\t\t      ims_cert->certificate_id,\n\t\t\t\t\t      ims_cert->certificate,\n\t\t\t\t\t      &ims_cert->cert_size,\n\t\t\t\t\t      &ims_cert->result_code);\n\t\tif (!ret && copy_to_user(buf, ims_cert, size))\n\t\t\tret = -EFAULT;\n\t\tkfree(ims_cert);\n\n\t\treturn ret;\n\tcase CAP_IOC_AUTHENTICATE:\n\t\tsize = sizeof(*authenticate);\n\t\tauthenticate = memdup_user(buf, size);\n\t\tif (IS_ERR(authenticate))\n\t\t\treturn PTR_ERR(authenticate);\n\n\t\tret = cap_authenticate(cap, authenticate->auth_type,\n\t\t\t\t       authenticate->uid,\n\t\t\t\t       authenticate->challenge,\n\t\t\t\t       &authenticate->result_code,\n\t\t\t\t       authenticate->response,\n\t\t\t\t       &authenticate->signature_size,\n\t\t\t\t       authenticate->signature);\n\t\tif (!ret && copy_to_user(buf, authenticate, size))\n\t\t\tret = -EFAULT;\n\t\tkfree(authenticate);\n\n\t\treturn ret;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic long cap_ioctl_unlocked(struct file *file, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tstruct gb_cap *cap = file->private_data;\n\tstruct gb_bundle *bundle = cap->connection->bundle;\n\tint ret = -ENODEV;\n\n\t \n\tmutex_lock(&cap->mutex);\n\tif (!cap->disabled) {\n\t\tret = gb_pm_runtime_get_sync(bundle);\n\t\tif (!ret) {\n\t\t\tret = cap_ioctl(cap, cmd, (void __user *)arg);\n\t\t\tgb_pm_runtime_put_autosuspend(bundle);\n\t\t}\n\t}\n\tmutex_unlock(&cap->mutex);\n\n\treturn ret;\n}\n\nstatic const struct file_operations cap_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= cap_open,\n\t.release\t= cap_release,\n\t.unlocked_ioctl\t= cap_ioctl_unlocked,\n};\n\nint gb_cap_connection_init(struct gb_connection *connection)\n{\n\tstruct gb_cap *cap;\n\tint ret, minor;\n\n\tif (!connection)\n\t\treturn 0;\n\n\tcap = kzalloc(sizeof(*cap), GFP_KERNEL);\n\tif (!cap)\n\t\treturn -ENOMEM;\n\n\tcap->parent = &connection->bundle->dev;\n\tcap->connection = connection;\n\tmutex_init(&cap->mutex);\n\tgb_connection_set_data(connection, cap);\n\tkref_init(&cap->kref);\n\n\tmutex_lock(&list_mutex);\n\tlist_add(&cap->node, &cap_list);\n\tmutex_unlock(&list_mutex);\n\n\tret = gb_connection_enable(connection);\n\tif (ret)\n\t\tgoto err_list_del;\n\n\tminor = ida_simple_get(&cap_minors_map, 0, NUM_MINORS, GFP_KERNEL);\n\tif (minor < 0) {\n\t\tret = minor;\n\t\tgoto err_connection_disable;\n\t}\n\n\t \n\tcap->dev_num = MKDEV(MAJOR(cap_dev_num), minor);\n\tcdev_init(&cap->cdev, &cap_fops);\n\n\tret = cdev_add(&cap->cdev, cap->dev_num, 1);\n\tif (ret)\n\t\tgoto err_remove_ida;\n\n\t \n\tcap->class_device = device_create(cap_class, cap->parent, cap->dev_num,\n\t\t\t\t\t  NULL, \"gb-authenticate-%d\", minor);\n\tif (IS_ERR(cap->class_device)) {\n\t\tret = PTR_ERR(cap->class_device);\n\t\tgoto err_del_cdev;\n\t}\n\n\treturn 0;\n\nerr_del_cdev:\n\tcdev_del(&cap->cdev);\nerr_remove_ida:\n\tida_simple_remove(&cap_minors_map, minor);\nerr_connection_disable:\n\tgb_connection_disable(connection);\nerr_list_del:\n\tmutex_lock(&list_mutex);\n\tlist_del(&cap->node);\n\tmutex_unlock(&list_mutex);\n\n\tput_cap(cap);\n\n\treturn ret;\n}\n\nvoid gb_cap_connection_exit(struct gb_connection *connection)\n{\n\tstruct gb_cap *cap;\n\n\tif (!connection)\n\t\treturn;\n\n\tcap = gb_connection_get_data(connection);\n\n\tdevice_destroy(cap_class, cap->dev_num);\n\tcdev_del(&cap->cdev);\n\tida_simple_remove(&cap_minors_map, MINOR(cap->dev_num));\n\n\t \n\tmutex_lock(&cap->mutex);\n\tcap->disabled = true;\n\tmutex_unlock(&cap->mutex);\n\n\t \n\tgb_connection_disable(cap->connection);\n\n\t \n\tmutex_lock(&list_mutex);\n\tlist_del(&cap->node);\n\tmutex_unlock(&list_mutex);\n\n\t \n\tput_cap(cap);\n}\n\nint cap_init(void)\n{\n\tint ret;\n\n\tcap_class = class_create(\"gb_authenticate\");\n\tif (IS_ERR(cap_class))\n\t\treturn PTR_ERR(cap_class);\n\n\tret = alloc_chrdev_region(&cap_dev_num, 0, NUM_MINORS,\n\t\t\t\t  \"gb_authenticate\");\n\tif (ret)\n\t\tgoto err_remove_class;\n\n\treturn 0;\n\nerr_remove_class:\n\tclass_destroy(cap_class);\n\treturn ret;\n}\n\nvoid cap_exit(void)\n{\n\tunregister_chrdev_region(cap_dev_num, NUM_MINORS);\n\tclass_destroy(cap_class);\n\tida_destroy(&cap_minors_map);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}