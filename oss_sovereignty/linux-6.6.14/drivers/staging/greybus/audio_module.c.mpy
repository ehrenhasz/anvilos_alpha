{
  "module_name": "audio_module.c",
  "hash_id": "14f498d8a162650bc3ff5bf5bd8ebb38a3ef68b69f44f403fb104237523b288b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/audio_module.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n\n#include \"audio_codec.h\"\n#include \"audio_apbridgea.h\"\n#include \"audio_manager.h\"\n\n \n\nstatic int gbaudio_request_jack(struct gbaudio_module_info *module,\n\t\t\t\tstruct gb_audio_jack_event_request *req)\n{\n\tint report;\n\tstruct snd_jack *jack = module->headset.jack.jack;\n\tstruct snd_jack *btn_jack = module->button.jack.jack;\n\n\tif (!jack) {\n\t\tdev_err_ratelimited(module->dev,\n\t\t\t\t    \"Invalid jack event received:type: %u, event: %u\\n\",\n\t\t\t\t    req->jack_attribute, req->event);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_warn_ratelimited(module->dev,\n\t\t\t     \"Jack Event received: type: %u, event: %u\\n\",\n\t\t\t     req->jack_attribute, req->event);\n\n\tif (req->event == GB_AUDIO_JACK_EVENT_REMOVAL) {\n\t\tmodule->jack_type = 0;\n\t\tif (btn_jack && module->button_status) {\n\t\t\tsnd_soc_jack_report(&module->button.jack, 0,\n\t\t\t\t\t    module->button_mask);\n\t\t\tmodule->button_status = 0;\n\t\t}\n\t\tsnd_soc_jack_report(&module->headset.jack, 0,\n\t\t\t\t    module->jack_mask);\n\t\treturn 0;\n\t}\n\n\treport = req->jack_attribute & module->jack_mask;\n\tif (!report) {\n\t\tdev_err_ratelimited(module->dev,\n\t\t\t\t    \"Invalid jack event received:type: %u, event: %u\\n\",\n\t\t\t\t    req->jack_attribute, req->event);\n\t\treturn -EINVAL;\n\t}\n\n\tif (module->jack_type)\n\t\tdev_warn_ratelimited(module->dev,\n\t\t\t\t     \"Modifying jack from %d to %d\\n\",\n\t\t\t\t     module->jack_type, report);\n\n\tmodule->jack_type = report;\n\tsnd_soc_jack_report(&module->headset.jack, report, module->jack_mask);\n\n\treturn 0;\n}\n\nstatic int gbaudio_request_button(struct gbaudio_module_info *module,\n\t\t\t\t  struct gb_audio_button_event_request *req)\n{\n\tint soc_button_id, report;\n\tstruct snd_jack *btn_jack = module->button.jack.jack;\n\n\tif (!btn_jack) {\n\t\tdev_err_ratelimited(module->dev,\n\t\t\t\t    \"Invalid button event received:type: %u, event: %u\\n\",\n\t\t\t\t    req->button_id, req->event);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_warn_ratelimited(module->dev,\n\t\t\t     \"Button Event received: id: %u, event: %u\\n\",\n\t\t\t     req->button_id, req->event);\n\n\t \n\tif (!module->jack_type) {\n\t\tdev_err_ratelimited(module->dev,\n\t\t\t\t    \"Jack not present. Bogus event!!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treport = module->button_status & module->button_mask;\n\tsoc_button_id = 0;\n\n\tswitch (req->button_id) {\n\tcase 1:\n\t\tsoc_button_id = SND_JACK_BTN_0 & module->button_mask;\n\t\tbreak;\n\n\tcase 2:\n\t\tsoc_button_id = SND_JACK_BTN_1 & module->button_mask;\n\t\tbreak;\n\n\tcase 3:\n\t\tsoc_button_id = SND_JACK_BTN_2 & module->button_mask;\n\t\tbreak;\n\n\tcase 4:\n\t\tsoc_button_id = SND_JACK_BTN_3 & module->button_mask;\n\t\tbreak;\n\t}\n\n\tif (!soc_button_id) {\n\t\tdev_err_ratelimited(module->dev,\n\t\t\t\t    \"Invalid button request received\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (req->event == GB_AUDIO_BUTTON_EVENT_PRESS)\n\t\treport = report | soc_button_id;\n\telse\n\t\treport = report & ~soc_button_id;\n\n\tmodule->button_status = report;\n\n\tsnd_soc_jack_report(&module->button.jack, report, module->button_mask);\n\n\treturn 0;\n}\n\nstatic int gbaudio_request_stream(struct gbaudio_module_info *module,\n\t\t\t\t  struct gb_audio_streaming_event_request *req)\n{\n\tdev_warn(module->dev, \"Audio Event received: cport: %u, event: %u\\n\",\n\t\t le16_to_cpu(req->data_cport), req->event);\n\n\treturn 0;\n}\n\nstatic int gbaudio_codec_request_handler(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct gbaudio_module_info *module =\n\t\tgreybus_get_drvdata(connection->bundle);\n\tstruct gb_operation_msg_hdr *header = op->request->header;\n\tstruct gb_audio_streaming_event_request *stream_req;\n\tstruct gb_audio_jack_event_request *jack_req;\n\tstruct gb_audio_button_event_request *button_req;\n\tint ret;\n\n\tswitch (header->type) {\n\tcase GB_AUDIO_TYPE_STREAMING_EVENT:\n\t\tstream_req = op->request->payload;\n\t\tret = gbaudio_request_stream(module, stream_req);\n\t\tbreak;\n\n\tcase GB_AUDIO_TYPE_JACK_EVENT:\n\t\tjack_req = op->request->payload;\n\t\tret = gbaudio_request_jack(module, jack_req);\n\t\tbreak;\n\n\tcase GB_AUDIO_TYPE_BUTTON_EVENT:\n\t\tbutton_req = op->request->payload;\n\t\tret = gbaudio_request_button(module, button_req);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err_ratelimited(&connection->bundle->dev,\n\t\t\t\t    \"Invalid Audio Event received\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int gb_audio_add_mgmt_connection(struct gbaudio_module_info *gbmodule,\n\t\t\t\t\tstruct greybus_descriptor_cport *cport_desc,\n\t\t\t\t\tstruct gb_bundle *bundle)\n{\n\tstruct gb_connection *connection;\n\n\t \n\tif (gbmodule->mgmt_connection) {\n\t\tdev_err(&bundle->dev,\n\t\t\t\"Can't have multiple Management connections\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\n\t\t\t\t\t  gbaudio_codec_request_handler);\n\tif (IS_ERR(connection))\n\t\treturn PTR_ERR(connection);\n\n\tgreybus_set_drvdata(bundle, gbmodule);\n\tgbmodule->mgmt_connection = connection;\n\n\treturn 0;\n}\n\nstatic int gb_audio_add_data_connection(struct gbaudio_module_info *gbmodule,\n\t\t\t\t\tstruct greybus_descriptor_cport *cport_desc,\n\t\t\t\t\tstruct gb_bundle *bundle)\n{\n\tstruct gb_connection *connection;\n\tstruct gbaudio_data_connection *dai;\n\n\tdai = devm_kzalloc(gbmodule->dev, sizeof(*dai), GFP_KERNEL);\n\tif (!dai)\n\t\treturn -ENOMEM;\n\n\tconnection = gb_connection_create_offloaded(bundle,\n\t\t\t\t\t\t    le16_to_cpu(cport_desc->id),\n\t\t\t\t\t\t    GB_CONNECTION_FLAG_CSD);\n\tif (IS_ERR(connection)) {\n\t\tdevm_kfree(gbmodule->dev, dai);\n\t\treturn PTR_ERR(connection);\n\t}\n\n\tgreybus_set_drvdata(bundle, gbmodule);\n\tdai->id = 0;\n\tdai->data_cport = cpu_to_le16(connection->intf_cport_id);\n\tdai->connection = connection;\n\tlist_add(&dai->list, &gbmodule->data_list);\n\n\treturn 0;\n}\n\n \n\nstatic int gb_audio_probe(struct gb_bundle *bundle,\n\t\t\t  const struct greybus_bundle_id *id)\n{\n\tstruct device *dev = &bundle->dev;\n\tstruct gbaudio_module_info *gbmodule;\n\tstruct greybus_descriptor_cport *cport_desc;\n\tstruct gb_audio_manager_module_descriptor desc;\n\tstruct gbaudio_data_connection *dai, *_dai;\n\tint ret, i;\n\tstruct gb_audio_topology *topology;\n\n\t \n\tif (bundle->num_cports < 2)\n\t\treturn -ENODEV;\n\n\t \n\tgbmodule = devm_kzalloc(dev, sizeof(*gbmodule), GFP_KERNEL);\n\tif (!gbmodule)\n\t\treturn -ENOMEM;\n\n\tgbmodule->num_data_connections = bundle->num_cports - 1;\n\tINIT_LIST_HEAD(&gbmodule->data_list);\n\tINIT_LIST_HEAD(&gbmodule->widget_list);\n\tINIT_LIST_HEAD(&gbmodule->ctl_list);\n\tINIT_LIST_HEAD(&gbmodule->widget_ctl_list);\n\tINIT_LIST_HEAD(&gbmodule->jack_list);\n\tgbmodule->dev = dev;\n\tsnprintf(gbmodule->name, sizeof(gbmodule->name), \"%s.%s\", dev->driver->name,\n\t\t dev_name(dev));\n\tgreybus_set_drvdata(bundle, gbmodule);\n\n\t \n\tfor (i = 0; i < bundle->num_cports; i++) {\n\t\tcport_desc = &bundle->cport_desc[i];\n\n\t\tswitch (cport_desc->protocol_id) {\n\t\tcase GREYBUS_PROTOCOL_AUDIO_MGMT:\n\t\t\tret = gb_audio_add_mgmt_connection(gbmodule, cport_desc,\n\t\t\t\t\t\t\t   bundle);\n\t\t\tif (ret)\n\t\t\t\tgoto destroy_connections;\n\t\t\tbreak;\n\t\tcase GREYBUS_PROTOCOL_AUDIO_DATA:\n\t\t\tret = gb_audio_add_data_connection(gbmodule, cport_desc,\n\t\t\t\t\t\t\t   bundle);\n\t\t\tif (ret)\n\t\t\t\tgoto destroy_connections;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Unsupported protocol: 0x%02x\\n\",\n\t\t\t\tcport_desc->protocol_id);\n\t\t\tret = -ENODEV;\n\t\t\tgoto destroy_connections;\n\t\t}\n\t}\n\n\t \n\tif (!gbmodule->mgmt_connection) {\n\t\tret = -EINVAL;\n\t\tdev_err(dev, \"Missing management connection\\n\");\n\t\tgoto destroy_connections;\n\t}\n\n\t \n\tret = gb_connection_enable(gbmodule->mgmt_connection);\n\tif (ret) {\n\t\tdev_err(dev, \"%d: Error while enabling mgmt connection\\n\", ret);\n\t\tgoto destroy_connections;\n\t}\n\tgbmodule->dev_id = gbmodule->mgmt_connection->intf->interface_id;\n\n\t \n\tret = gb_audio_gb_get_topology(gbmodule->mgmt_connection, &topology);\n\tif (ret) {\n\t\tdev_err(dev, \"%d:Error while fetching topology\\n\", ret);\n\t\tgoto disable_connection;\n\t}\n\n\t \n\tret = gbaudio_tplg_parse_data(gbmodule, topology);\n\tif (ret) {\n\t\tdev_err(dev, \"%d:Error while parsing topology data\\n\",\n\t\t\tret);\n\t\tgoto free_topology;\n\t}\n\tgbmodule->topology = topology;\n\n\t \n\tlist_for_each_entry(dai, &gbmodule->data_list, list) {\n\t\tret = gb_connection_enable(dai->connection);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%d:Error while enabling %d:data connection\\n\",\n\t\t\t\tret, le16_to_cpu(dai->data_cport));\n\t\t\tgoto disable_data_connection;\n\t\t}\n\t}\n\n\t \n\tret = gbaudio_register_module(gbmodule);\n\tif (ret)\n\t\tgoto disable_data_connection;\n\n\t \n\tdev_dbg(dev, \"Inform set_event:%d to above layer\\n\", 1);\n\t \n\tstrscpy(desc.name, gbmodule->name, sizeof(desc.name));\n\tdesc.vid = 2;  \n\tdesc.pid = 3;  \n\tdesc.intf_id = gbmodule->dev_id;\n\tdesc.op_devices = gbmodule->op_devices;\n\tdesc.ip_devices = gbmodule->ip_devices;\n\tgbmodule->manager_id = gb_audio_manager_add(&desc);\n\n\tdev_dbg(dev, \"Add GB Audio device:%s\\n\", gbmodule->name);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn 0;\n\ndisable_data_connection:\n\tlist_for_each_entry_safe(dai, _dai, &gbmodule->data_list, list)\n\t\tgb_connection_disable(dai->connection);\n\tgbaudio_tplg_release(gbmodule);\n\tgbmodule->topology = NULL;\n\nfree_topology:\n\tkfree(topology);\n\ndisable_connection:\n\tgb_connection_disable(gbmodule->mgmt_connection);\n\ndestroy_connections:\n\tlist_for_each_entry_safe(dai, _dai, &gbmodule->data_list, list) {\n\t\tgb_connection_destroy(dai->connection);\n\t\tlist_del(&dai->list);\n\t\tdevm_kfree(dev, dai);\n\t}\n\n\tif (gbmodule->mgmt_connection)\n\t\tgb_connection_destroy(gbmodule->mgmt_connection);\n\n\tdevm_kfree(dev, gbmodule);\n\n\treturn ret;\n}\n\nstatic void gb_audio_disconnect(struct gb_bundle *bundle)\n{\n\tstruct gbaudio_module_info *gbmodule = greybus_get_drvdata(bundle);\n\tstruct gbaudio_data_connection *dai, *_dai;\n\n\tgb_pm_runtime_get_sync(bundle);\n\n\t \n\tgbaudio_unregister_module(gbmodule);\n\n\t \n\tgb_audio_manager_remove(gbmodule->manager_id);\n\n\tgbaudio_tplg_release(gbmodule);\n\tkfree(gbmodule->topology);\n\tgbmodule->topology = NULL;\n\tgb_connection_disable(gbmodule->mgmt_connection);\n\tlist_for_each_entry_safe(dai, _dai, &gbmodule->data_list, list) {\n\t\tgb_connection_disable(dai->connection);\n\t\tgb_connection_destroy(dai->connection);\n\t\tlist_del(&dai->list);\n\t\tdevm_kfree(gbmodule->dev, dai);\n\t}\n\tgb_connection_destroy(gbmodule->mgmt_connection);\n\tgbmodule->mgmt_connection = NULL;\n\n\tdevm_kfree(&bundle->dev, gbmodule);\n}\n\nstatic const struct greybus_bundle_id gb_audio_id_table[] = {\n\t{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_AUDIO) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(greybus, gb_audio_id_table);\n\n#ifdef CONFIG_PM\nstatic int gb_audio_suspend(struct device *dev)\n{\n\tstruct gb_bundle *bundle = to_gb_bundle(dev);\n\tstruct gbaudio_module_info *gbmodule = greybus_get_drvdata(bundle);\n\tstruct gbaudio_data_connection *dai;\n\n\tlist_for_each_entry(dai, &gbmodule->data_list, list)\n\t\tgb_connection_disable(dai->connection);\n\n\tgb_connection_disable(gbmodule->mgmt_connection);\n\n\treturn 0;\n}\n\nstatic int gb_audio_resume(struct device *dev)\n{\n\tstruct gb_bundle *bundle = to_gb_bundle(dev);\n\tstruct gbaudio_module_info *gbmodule = greybus_get_drvdata(bundle);\n\tstruct gbaudio_data_connection *dai;\n\tint ret;\n\n\tret = gb_connection_enable(gbmodule->mgmt_connection);\n\tif (ret) {\n\t\tdev_err(dev, \"%d:Error while enabling mgmt connection\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tlist_for_each_entry(dai, &gbmodule->data_list, list) {\n\t\tret = gb_connection_enable(dai->connection);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%d:Error while enabling %d:data connection\\n\",\n\t\t\t\tret, le16_to_cpu(dai->data_cport));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops gb_audio_pm_ops = {\n\tSET_RUNTIME_PM_OPS(gb_audio_suspend, gb_audio_resume, NULL)\n};\n\nstatic struct greybus_driver gb_audio_driver = {\n\t.name\t\t= \"gb-audio\",\n\t.probe\t\t= gb_audio_probe,\n\t.disconnect\t= gb_audio_disconnect,\n\t.id_table\t= gb_audio_id_table,\n\t.driver.pm\t= &gb_audio_pm_ops,\n};\nmodule_greybus_driver(gb_audio_driver);\n\nMODULE_DESCRIPTION(\"Greybus Audio module driver\");\nMODULE_AUTHOR(\"Vaibhav Agarwal <vaibhav.agarwal@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:gbaudio-module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}