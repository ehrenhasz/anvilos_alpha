{
  "module_name": "light.c",
  "hash_id": "0950e78f0645f1547ed7c88c2db4db4642fd134037611c596f6fb046e35a191d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/light.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/led-class-flash.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/greybus.h>\n#include <media/v4l2-flash-led-class.h>\n\n#define NAMES_MAX\t32\n\nstruct gb_channel {\n\tu8\t\t\t\tid;\n\tu32\t\t\t\tflags;\n\tu32\t\t\t\tcolor;\n\tchar\t\t\t\t*color_name;\n\tu8\t\t\t\tfade_in;\n\tu8\t\t\t\tfade_out;\n\tu32\t\t\t\tmode;\n\tchar\t\t\t\t*mode_name;\n\tstruct attribute\t\t**attrs;\n\tstruct attribute_group\t\t*attr_group;\n\tconst struct attribute_group\t**attr_groups;\n\tstruct led_classdev\t\t*led;\n#if IS_REACHABLE(CONFIG_LEDS_CLASS_FLASH)\n\tstruct led_classdev_flash\tfled;\n\tstruct led_flash_setting\tintensity_uA;\n\tstruct led_flash_setting\ttimeout_us;\n#else\n\tstruct led_classdev\t\tcled;\n#endif\n\tstruct gb_light\t\t\t*light;\n\tbool\t\t\t\tis_registered;\n\tbool\t\t\t\treleasing;\n\tbool\t\t\t\tstrobe_state;\n\tbool\t\t\t\tactive;\n\tstruct mutex\t\t\tlock;\n};\n\nstruct gb_light {\n\tu8\t\t\tid;\n\tchar\t\t\t*name;\n\tstruct gb_lights\t*glights;\n\tu32\t\t\tflags;\n\tu8\t\t\tchannels_count;\n\tstruct gb_channel\t*channels;\n\tbool\t\t\thas_flash;\n\tbool\t\t\tready;\n#if IS_REACHABLE(CONFIG_V4L2_FLASH_LED_CLASS)\n\tstruct v4l2_flash\t*v4l2_flash;\n\tstruct v4l2_flash\t*v4l2_flash_ind;\n#endif\n};\n\nstruct gb_lights {\n\tstruct gb_connection\t*connection;\n\tu8\t\t\tlights_count;\n\tstruct gb_light\t\t*lights;\n\tstruct mutex\t\tlights_lock;\n};\n\nstatic void gb_lights_channel_free(struct gb_channel *channel);\n\nstatic struct gb_connection *get_conn_from_channel(struct gb_channel *channel)\n{\n\treturn channel->light->glights->connection;\n}\n\nstatic struct gb_connection *get_conn_from_light(struct gb_light *light)\n{\n\treturn light->glights->connection;\n}\n\nstatic bool is_channel_flash(struct gb_channel *channel)\n{\n\treturn !!(channel->mode & (GB_CHANNEL_MODE_FLASH | GB_CHANNEL_MODE_TORCH\n\t\t\t\t   | GB_CHANNEL_MODE_INDICATOR));\n}\n\n#if IS_REACHABLE(CONFIG_LEDS_CLASS_FLASH)\nstatic struct gb_channel *get_channel_from_cdev(struct led_classdev *cdev)\n{\n\tstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(cdev);\n\n\treturn container_of(fled_cdev, struct gb_channel, fled);\n}\n\nstatic struct led_classdev *get_channel_cdev(struct gb_channel *channel)\n{\n\treturn &channel->fled.led_cdev;\n}\n\nstatic struct gb_channel *get_channel_from_mode(struct gb_light *light,\n\t\t\t\t\t\tu32 mode)\n{\n\tstruct gb_channel *channel = NULL;\n\tint i;\n\n\tfor (i = 0; i < light->channels_count; i++) {\n\t\tchannel = &light->channels[i];\n\t\tif (channel && channel->mode == mode)\n\t\t\tbreak;\n\t}\n\treturn channel;\n}\n\nstatic int __gb_lights_flash_intensity_set(struct gb_channel *channel,\n\t\t\t\t\t   u32 intensity)\n{\n\tstruct gb_connection *connection = get_conn_from_channel(channel);\n\tstruct gb_bundle *bundle = connection->bundle;\n\tstruct gb_lights_set_flash_intensity_request req;\n\tint ret;\n\n\tif (channel->releasing)\n\t\treturn -ESHUTDOWN;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treq.light_id = channel->light->id;\n\treq.channel_id = channel->id;\n\treq.intensity_uA = cpu_to_le32(intensity);\n\n\tret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FLASH_INTENSITY,\n\t\t\t\t&req, sizeof(req), NULL, 0);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn ret;\n}\n\nstatic int __gb_lights_flash_brightness_set(struct gb_channel *channel)\n{\n\tu32 intensity;\n\n\t \n\tif (channel->mode & GB_CHANNEL_MODE_FLASH)\n\t\tchannel = get_channel_from_mode(channel->light,\n\t\t\t\t\t\tGB_CHANNEL_MODE_TORCH);\n\n\t \n\tintensity = channel->intensity_uA.min +\n\t\t\t(channel->intensity_uA.step * channel->led->brightness);\n\n\treturn __gb_lights_flash_intensity_set(channel, intensity);\n}\n#else\nstatic struct gb_channel *get_channel_from_cdev(struct led_classdev *cdev)\n{\n\treturn container_of(cdev, struct gb_channel, cled);\n}\n\nstatic struct led_classdev *get_channel_cdev(struct gb_channel *channel)\n{\n\treturn &channel->cled;\n}\n\nstatic int __gb_lights_flash_brightness_set(struct gb_channel *channel)\n{\n\treturn 0;\n}\n#endif\n\nstatic int gb_lights_color_set(struct gb_channel *channel, u32 color);\nstatic int gb_lights_fade_set(struct gb_channel *channel);\n\nstatic void led_lock(struct led_classdev *cdev)\n{\n\tmutex_lock(&cdev->led_access);\n}\n\nstatic void led_unlock(struct led_classdev *cdev)\n{\n\tmutex_unlock(&cdev->led_access);\n}\n\n#define gb_lights_fade_attr(__dir)\t\t\t\t\t\\\nstatic ssize_t fade_##__dir##_show(struct device *dev,\t\t\t\\\n\t\t\t\t   struct device_attribute *attr,\t\\\n\t\t\t\t   char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct led_classdev *cdev = dev_get_drvdata(dev);\t\t\\\n\tstruct gb_channel *channel = get_channel_from_cdev(cdev);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%u\\n\", channel->fade_##__dir);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t fade_##__dir##_store(struct device *dev,\t\t\t\\\n\t\t\t\t    struct device_attribute *attr,\t\\\n\t\t\t\t    const char *buf, size_t size)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct led_classdev *cdev = dev_get_drvdata(dev);\t\t\\\n\tstruct gb_channel *channel = get_channel_from_cdev(cdev);\t\\\n\tu8 fade;\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tled_lock(cdev);\t\t\t\t\t\t\t\\\n\tif (led_sysfs_is_disabled(cdev)) {\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto unlock;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou8(buf, 0, &fade);\t\t\t\t\t\\\n\tif (ret < 0) {\t\t\t\t\t\t\t\\\n\t\tdev_err(dev, \"could not parse fade value %d\\n\", ret);\t\\\n\t\tgoto unlock;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (channel->fade_##__dir == fade)\t\t\t\t\\\n\t\tgoto unlock;\t\t\t\t\t\t\\\n\tchannel->fade_##__dir = fade;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = gb_lights_fade_set(channel);\t\t\t\t\\\n\tif (ret < 0)\t\t\t\t\t\t\t\\\n\t\tgoto unlock;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = size;\t\t\t\t\t\t\t\\\nunlock:\t\t\t\t\t\t\t\t\t\\\n\tled_unlock(cdev);\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RW(fade_##__dir)\n\ngb_lights_fade_attr(in);\ngb_lights_fade_attr(out);\n\nstatic ssize_t color_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct led_classdev *cdev = dev_get_drvdata(dev);\n\tstruct gb_channel *channel = get_channel_from_cdev(cdev);\n\n\treturn sprintf(buf, \"0x%08x\\n\", channel->color);\n}\n\nstatic ssize_t color_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t size)\n{\n\tstruct led_classdev *cdev = dev_get_drvdata(dev);\n\tstruct gb_channel *channel = get_channel_from_cdev(cdev);\n\tu32 color;\n\tint ret;\n\n\tled_lock(cdev);\n\tif (led_sysfs_is_disabled(cdev)) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tret = kstrtou32(buf, 0, &color);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not parse color value %d\\n\", ret);\n\t\tgoto unlock;\n\t}\n\n\tret = gb_lights_color_set(channel, color);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tchannel->color = color;\n\tret = size;\nunlock:\n\tled_unlock(cdev);\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(color);\n\nstatic int channel_attr_groups_set(struct gb_channel *channel,\n\t\t\t\t   struct led_classdev *cdev)\n{\n\tint attr = 0;\n\tint size = 0;\n\n\tif (channel->flags & GB_LIGHT_CHANNEL_MULTICOLOR)\n\t\tsize++;\n\tif (channel->flags & GB_LIGHT_CHANNEL_FADER)\n\t\tsize += 2;\n\n\tif (!size)\n\t\treturn 0;\n\n\t \n\tchannel->attrs = kcalloc(size + 1, sizeof(*channel->attrs), GFP_KERNEL);\n\tif (!channel->attrs)\n\t\treturn -ENOMEM;\n\tchannel->attr_group = kzalloc(sizeof(*channel->attr_group), GFP_KERNEL);\n\tif (!channel->attr_group)\n\t\treturn -ENOMEM;\n\tchannel->attr_groups = kcalloc(2, sizeof(*channel->attr_groups),\n\t\t\t\t       GFP_KERNEL);\n\tif (!channel->attr_groups)\n\t\treturn -ENOMEM;\n\n\tif (channel->flags & GB_LIGHT_CHANNEL_MULTICOLOR)\n\t\tchannel->attrs[attr++] = &dev_attr_color.attr;\n\tif (channel->flags & GB_LIGHT_CHANNEL_FADER) {\n\t\tchannel->attrs[attr++] = &dev_attr_fade_in.attr;\n\t\tchannel->attrs[attr++] = &dev_attr_fade_out.attr;\n\t}\n\n\tchannel->attr_group->attrs = channel->attrs;\n\n\tchannel->attr_groups[0] = channel->attr_group;\n\n\tcdev->groups = channel->attr_groups;\n\n\treturn 0;\n}\n\nstatic int gb_lights_fade_set(struct gb_channel *channel)\n{\n\tstruct gb_connection *connection = get_conn_from_channel(channel);\n\tstruct gb_bundle *bundle = connection->bundle;\n\tstruct gb_lights_set_fade_request req;\n\tint ret;\n\n\tif (channel->releasing)\n\t\treturn -ESHUTDOWN;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treq.light_id = channel->light->id;\n\treq.channel_id = channel->id;\n\treq.fade_in = channel->fade_in;\n\treq.fade_out = channel->fade_out;\n\tret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FADE,\n\t\t\t\t&req, sizeof(req), NULL, 0);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn ret;\n}\n\nstatic int gb_lights_color_set(struct gb_channel *channel, u32 color)\n{\n\tstruct gb_connection *connection = get_conn_from_channel(channel);\n\tstruct gb_bundle *bundle = connection->bundle;\n\tstruct gb_lights_set_color_request req;\n\tint ret;\n\n\tif (channel->releasing)\n\t\treturn -ESHUTDOWN;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treq.light_id = channel->light->id;\n\treq.channel_id = channel->id;\n\treq.color = cpu_to_le32(color);\n\tret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_COLOR,\n\t\t\t\t&req, sizeof(req), NULL, 0);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn ret;\n}\n\nstatic int __gb_lights_led_brightness_set(struct gb_channel *channel)\n{\n\tstruct gb_lights_set_brightness_request req;\n\tstruct gb_connection *connection = get_conn_from_channel(channel);\n\tstruct gb_bundle *bundle = connection->bundle;\n\tbool old_active;\n\tint ret;\n\n\tmutex_lock(&channel->lock);\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\told_active = channel->active;\n\n\treq.light_id = channel->light->id;\n\treq.channel_id = channel->id;\n\treq.brightness = (u8)channel->led->brightness;\n\n\tret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_BRIGHTNESS,\n\t\t\t\t&req, sizeof(req), NULL, 0);\n\tif (ret < 0)\n\t\tgoto out_pm_put;\n\n\tif (channel->led->brightness)\n\t\tchannel->active = true;\n\telse\n\t\tchannel->active = false;\n\n\t \n\tif (!old_active && channel->active)\n\t\tgoto out_unlock;\n\n\t \n\tif (old_active && !channel->active)\n\t\tgb_pm_runtime_put_autosuspend(bundle);\n\nout_pm_put:\n\tgb_pm_runtime_put_autosuspend(bundle);\nout_unlock:\n\tmutex_unlock(&channel->lock);\n\n\treturn ret;\n}\n\nstatic int __gb_lights_brightness_set(struct gb_channel *channel)\n{\n\tint ret;\n\n\tif (channel->releasing)\n\t\treturn 0;\n\n\tif (is_channel_flash(channel))\n\t\tret = __gb_lights_flash_brightness_set(channel);\n\telse\n\t\tret = __gb_lights_led_brightness_set(channel);\n\n\treturn ret;\n}\n\nstatic int gb_brightness_set(struct led_classdev *cdev,\n\t\t\t     enum led_brightness value)\n{\n\tstruct gb_channel *channel = get_channel_from_cdev(cdev);\n\n\tchannel->led->brightness = value;\n\n\treturn __gb_lights_brightness_set(channel);\n}\n\nstatic enum led_brightness gb_brightness_get(struct led_classdev *cdev)\n\n{\n\tstruct gb_channel *channel = get_channel_from_cdev(cdev);\n\n\treturn channel->led->brightness;\n}\n\nstatic int gb_blink_set(struct led_classdev *cdev, unsigned long *delay_on,\n\t\t\tunsigned long *delay_off)\n{\n\tstruct gb_channel *channel = get_channel_from_cdev(cdev);\n\tstruct gb_connection *connection = get_conn_from_channel(channel);\n\tstruct gb_bundle *bundle = connection->bundle;\n\tstruct gb_lights_blink_request req;\n\tbool old_active;\n\tint ret;\n\n\tif (channel->releasing)\n\t\treturn -ESHUTDOWN;\n\n\tif (!delay_on || !delay_off)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&channel->lock);\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\told_active = channel->active;\n\n\treq.light_id = channel->light->id;\n\treq.channel_id = channel->id;\n\treq.time_on_ms = cpu_to_le16(*delay_on);\n\treq.time_off_ms = cpu_to_le16(*delay_off);\n\n\tret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_BLINK, &req,\n\t\t\t\tsizeof(req), NULL, 0);\n\tif (ret < 0)\n\t\tgoto out_pm_put;\n\n\tif (*delay_on)\n\t\tchannel->active = true;\n\telse\n\t\tchannel->active = false;\n\n\t \n\tif (!old_active && channel->active)\n\t\tgoto out_unlock;\n\n\t \n\tif (old_active && !channel->active)\n\t\tgb_pm_runtime_put_autosuspend(bundle);\n\nout_pm_put:\n\tgb_pm_runtime_put_autosuspend(bundle);\nout_unlock:\n\tmutex_unlock(&channel->lock);\n\n\treturn ret;\n}\n\nstatic void gb_lights_led_operations_set(struct gb_channel *channel,\n\t\t\t\t\t struct led_classdev *cdev)\n{\n\tcdev->brightness_get = gb_brightness_get;\n\tcdev->brightness_set_blocking = gb_brightness_set;\n\n\tif (channel->flags & GB_LIGHT_CHANNEL_BLINK)\n\t\tcdev->blink_set = gb_blink_set;\n}\n\n#if IS_REACHABLE(CONFIG_V4L2_FLASH_LED_CLASS)\n \nstatic const struct v4l2_flash_ops v4l2_flash_ops;\n\nstatic void __gb_lights_channel_v4l2_config(struct led_flash_setting *channel_s,\n\t\t\t\t\t    struct led_flash_setting *v4l2_s)\n{\n\tv4l2_s->min = channel_s->min;\n\tv4l2_s->max = channel_s->max;\n\tv4l2_s->step = channel_s->step;\n\t \n\tv4l2_s->val = channel_s->max;\n}\n\nstatic int gb_lights_light_v4l2_register(struct gb_light *light)\n{\n\tstruct gb_connection *connection = get_conn_from_light(light);\n\tstruct device *dev = &connection->bundle->dev;\n\tstruct v4l2_flash_config sd_cfg = { {0} }, sd_cfg_ind = { {0} };\n\tstruct led_classdev_flash *fled;\n\tstruct led_classdev *iled = NULL;\n\tstruct gb_channel *channel_torch, *channel_ind, *channel_flash;\n\n\tchannel_torch = get_channel_from_mode(light, GB_CHANNEL_MODE_TORCH);\n\tif (channel_torch)\n\t\t__gb_lights_channel_v4l2_config(&channel_torch->intensity_uA,\n\t\t\t\t\t\t&sd_cfg.intensity);\n\n\tchannel_ind = get_channel_from_mode(light, GB_CHANNEL_MODE_INDICATOR);\n\tif (channel_ind) {\n\t\t__gb_lights_channel_v4l2_config(&channel_ind->intensity_uA,\n\t\t\t\t\t\t&sd_cfg_ind.intensity);\n\t\tiled = &channel_ind->fled.led_cdev;\n\t}\n\n\tchannel_flash = get_channel_from_mode(light, GB_CHANNEL_MODE_FLASH);\n\tWARN_ON(!channel_flash);\n\n\tfled = &channel_flash->fled;\n\n\tsnprintf(sd_cfg.dev_name, sizeof(sd_cfg.dev_name), \"%s\", light->name);\n\tsnprintf(sd_cfg_ind.dev_name, sizeof(sd_cfg_ind.dev_name),\n\t\t \"%s indicator\", light->name);\n\n\t \n\tsd_cfg.flash_faults = LED_FAULT_OVER_VOLTAGE | LED_FAULT_TIMEOUT |\n\t\tLED_FAULT_OVER_TEMPERATURE | LED_FAULT_SHORT_CIRCUIT |\n\t\tLED_FAULT_OVER_CURRENT | LED_FAULT_INDICATOR |\n\t\tLED_FAULT_UNDER_VOLTAGE | LED_FAULT_INPUT_VOLTAGE |\n\t\tLED_FAULT_LED_OVER_TEMPERATURE;\n\n\tlight->v4l2_flash = v4l2_flash_init(dev, NULL, fled, &v4l2_flash_ops,\n\t\t\t\t\t    &sd_cfg);\n\tif (IS_ERR(light->v4l2_flash))\n\t\treturn PTR_ERR(light->v4l2_flash);\n\n\tif (channel_ind) {\n\t\tlight->v4l2_flash_ind =\n\t\t\tv4l2_flash_indicator_init(dev, NULL, iled, &sd_cfg_ind);\n\t\tif (IS_ERR(light->v4l2_flash_ind)) {\n\t\t\tv4l2_flash_release(light->v4l2_flash);\n\t\t\treturn PTR_ERR(light->v4l2_flash_ind);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void gb_lights_light_v4l2_unregister(struct gb_light *light)\n{\n\tv4l2_flash_release(light->v4l2_flash_ind);\n\tv4l2_flash_release(light->v4l2_flash);\n}\n#else\nstatic int gb_lights_light_v4l2_register(struct gb_light *light)\n{\n\tstruct gb_connection *connection = get_conn_from_light(light);\n\n\tdev_err(&connection->bundle->dev, \"no support for v4l2 subdevices\\n\");\n\treturn 0;\n}\n\nstatic void gb_lights_light_v4l2_unregister(struct gb_light *light)\n{\n}\n#endif\n\n#if IS_REACHABLE(CONFIG_LEDS_CLASS_FLASH)\n \nstatic int gb_lights_flash_intensity_set(struct led_classdev_flash *fcdev,\n\t\t\t\t\t u32 brightness)\n{\n\tstruct gb_channel *channel = container_of(fcdev, struct gb_channel,\n\t\t\t\t\t\t  fled);\n\tint ret;\n\n\tret = __gb_lights_flash_intensity_set(channel, brightness);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfcdev->brightness.val = brightness;\n\n\treturn 0;\n}\n\nstatic int gb_lights_flash_intensity_get(struct led_classdev_flash *fcdev,\n\t\t\t\t\t u32 *brightness)\n{\n\t*brightness = fcdev->brightness.val;\n\n\treturn 0;\n}\n\nstatic int gb_lights_flash_strobe_set(struct led_classdev_flash *fcdev,\n\t\t\t\t      bool state)\n{\n\tstruct gb_channel *channel = container_of(fcdev, struct gb_channel,\n\t\t\t\t\t\t  fled);\n\tstruct gb_connection *connection = get_conn_from_channel(channel);\n\tstruct gb_bundle *bundle = connection->bundle;\n\tstruct gb_lights_set_flash_strobe_request req;\n\tint ret;\n\n\tif (channel->releasing)\n\t\treturn -ESHUTDOWN;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treq.light_id = channel->light->id;\n\treq.channel_id = channel->id;\n\treq.state = state ? 1 : 0;\n\n\tret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FLASH_STROBE,\n\t\t\t\t&req, sizeof(req), NULL, 0);\n\tif (!ret)\n\t\tchannel->strobe_state = state;\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn ret;\n}\n\nstatic int gb_lights_flash_strobe_get(struct led_classdev_flash *fcdev,\n\t\t\t\t      bool *state)\n{\n\tstruct gb_channel *channel = container_of(fcdev, struct gb_channel,\n\t\t\t\t\t\t  fled);\n\n\t*state = channel->strobe_state;\n\treturn 0;\n}\n\nstatic int gb_lights_flash_timeout_set(struct led_classdev_flash *fcdev,\n\t\t\t\t       u32 timeout)\n{\n\tstruct gb_channel *channel = container_of(fcdev, struct gb_channel,\n\t\t\t\t\t\t  fled);\n\tstruct gb_connection *connection = get_conn_from_channel(channel);\n\tstruct gb_bundle *bundle = connection->bundle;\n\tstruct gb_lights_set_flash_timeout_request req;\n\tint ret;\n\n\tif (channel->releasing)\n\t\treturn -ESHUTDOWN;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treq.light_id = channel->light->id;\n\treq.channel_id = channel->id;\n\treq.timeout_us = cpu_to_le32(timeout);\n\n\tret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FLASH_TIMEOUT,\n\t\t\t\t&req, sizeof(req), NULL, 0);\n\tif (!ret)\n\t\tfcdev->timeout.val = timeout;\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn ret;\n}\n\nstatic int gb_lights_flash_fault_get(struct led_classdev_flash *fcdev,\n\t\t\t\t     u32 *fault)\n{\n\tstruct gb_channel *channel = container_of(fcdev, struct gb_channel,\n\t\t\t\t\t\t  fled);\n\tstruct gb_connection *connection = get_conn_from_channel(channel);\n\tstruct gb_bundle *bundle = connection->bundle;\n\tstruct gb_lights_get_flash_fault_request req;\n\tstruct gb_lights_get_flash_fault_response resp;\n\tint ret;\n\n\tif (channel->releasing)\n\t\treturn -ESHUTDOWN;\n\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treq.light_id = channel->light->id;\n\treq.channel_id = channel->id;\n\n\tret = gb_operation_sync(connection, GB_LIGHTS_TYPE_GET_FLASH_FAULT,\n\t\t\t\t&req, sizeof(req), &resp, sizeof(resp));\n\tif (!ret)\n\t\t*fault = le32_to_cpu(resp.fault);\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn ret;\n}\n\nstatic const struct led_flash_ops gb_lights_flash_ops = {\n\t.flash_brightness_set\t= gb_lights_flash_intensity_set,\n\t.flash_brightness_get\t= gb_lights_flash_intensity_get,\n\t.strobe_set\t\t= gb_lights_flash_strobe_set,\n\t.strobe_get\t\t= gb_lights_flash_strobe_get,\n\t.timeout_set\t\t= gb_lights_flash_timeout_set,\n\t.fault_get\t\t= gb_lights_flash_fault_get,\n};\n\nstatic int __gb_lights_channel_torch_attach(struct gb_channel *channel,\n\t\t\t\t\t    struct gb_channel *channel_torch)\n{\n\tchar *name;\n\n\t \n\tif (!(channel->mode & GB_CHANNEL_MODE_FLASH))\n\t\treturn 0;\n\n\t \n\tchannel->led->max_brightness = channel_torch->led->max_brightness;\n\n\t \n\tname = kasprintf(GFP_KERNEL, \"%s_%s\", channel->led->name,\n\t\t\t channel_torch->mode_name);\n\tif (!name)\n\t\treturn -ENOMEM;\n\tkfree(channel->led->name);\n\tchannel->led->name = name;\n\n\tchannel_torch->led = channel->led;\n\n\treturn 0;\n}\n\nstatic int __gb_lights_flash_led_register(struct gb_channel *channel)\n{\n\tstruct gb_connection *connection = get_conn_from_channel(channel);\n\tstruct led_classdev_flash *fled = &channel->fled;\n\tstruct led_flash_setting *fset;\n\tstruct gb_channel *channel_torch;\n\tint ret;\n\n\tfled->ops = &gb_lights_flash_ops;\n\n\tfled->led_cdev.flags |= LED_DEV_CAP_FLASH;\n\n\tfset = &fled->brightness;\n\tfset->min = channel->intensity_uA.min;\n\tfset->max = channel->intensity_uA.max;\n\tfset->step = channel->intensity_uA.step;\n\tfset->val = channel->intensity_uA.max;\n\n\t \n\tif (channel->mode & GB_CHANNEL_MODE_FLASH) {\n\t\tfset = &fled->timeout;\n\t\tfset->min = channel->timeout_us.min;\n\t\tfset->max = channel->timeout_us.max;\n\t\tfset->step = channel->timeout_us.step;\n\t\tfset->val = channel->timeout_us.max;\n\t}\n\n\t \n\tchannel_torch = get_channel_from_mode(channel->light,\n\t\t\t\t\t      GB_CHANNEL_MODE_TORCH);\n\tif (channel_torch) {\n\t\tret = __gb_lights_channel_torch_attach(channel, channel_torch);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\tret = led_classdev_flash_register(&connection->bundle->dev, fled);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tchannel->is_registered = true;\n\treturn 0;\nfail:\n\tchannel->led = NULL;\n\treturn ret;\n}\n\nstatic void __gb_lights_flash_led_unregister(struct gb_channel *channel)\n{\n\tif (!channel->is_registered)\n\t\treturn;\n\n\tled_classdev_flash_unregister(&channel->fled);\n}\n\nstatic int gb_lights_channel_flash_config(struct gb_channel *channel)\n{\n\tstruct gb_connection *connection = get_conn_from_channel(channel);\n\tstruct gb_lights_get_channel_flash_config_request req;\n\tstruct gb_lights_get_channel_flash_config_response conf;\n\tstruct led_flash_setting *fset;\n\tint ret;\n\n\treq.light_id = channel->light->id;\n\treq.channel_id = channel->id;\n\n\tret = gb_operation_sync(connection,\n\t\t\t\tGB_LIGHTS_TYPE_GET_CHANNEL_FLASH_CONFIG,\n\t\t\t\t&req, sizeof(req), &conf, sizeof(conf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfset = &channel->intensity_uA;\n\tfset->min = le32_to_cpu(conf.intensity_min_uA);\n\tfset->max = le32_to_cpu(conf.intensity_max_uA);\n\tfset->step = le32_to_cpu(conf.intensity_step_uA);\n\n\t \n\tchannel->led->max_brightness = (fset->max - fset->min) / fset->step;\n\n\t \n\tif (channel->mode & GB_CHANNEL_MODE_FLASH) {\n\t\tfset = &channel->timeout_us;\n\t\tfset->min = le32_to_cpu(conf.timeout_min_us);\n\t\tfset->max = le32_to_cpu(conf.timeout_max_us);\n\t\tfset->step = le32_to_cpu(conf.timeout_step_us);\n\t}\n\n\treturn 0;\n}\n#else\nstatic int gb_lights_channel_flash_config(struct gb_channel *channel)\n{\n\tstruct gb_connection *connection = get_conn_from_channel(channel);\n\n\tdev_err(&connection->bundle->dev, \"no support for flash devices\\n\");\n\treturn 0;\n}\n\nstatic int __gb_lights_flash_led_register(struct gb_channel *channel)\n{\n\treturn 0;\n}\n\nstatic void __gb_lights_flash_led_unregister(struct gb_channel *channel)\n{\n}\n\n#endif\n\nstatic int __gb_lights_led_register(struct gb_channel *channel)\n{\n\tstruct gb_connection *connection = get_conn_from_channel(channel);\n\tstruct led_classdev *cdev = get_channel_cdev(channel);\n\tint ret;\n\n\tret = led_classdev_register(&connection->bundle->dev, cdev);\n\tif (ret < 0)\n\t\tchannel->led = NULL;\n\telse\n\t\tchannel->is_registered = true;\n\treturn ret;\n}\n\nstatic int gb_lights_channel_register(struct gb_channel *channel)\n{\n\t \n\tif (!is_channel_flash(channel))\n\t\treturn __gb_lights_led_register(channel);\n\n\t \n\tif (!(channel->mode & GB_CHANNEL_MODE_TORCH))\n\t\treturn __gb_lights_flash_led_register(channel);\n\n\treturn 0;\n}\n\nstatic void __gb_lights_led_unregister(struct gb_channel *channel)\n{\n\tstruct led_classdev *cdev = get_channel_cdev(channel);\n\n\tif (!channel->is_registered)\n\t\treturn;\n\n\tled_classdev_unregister(cdev);\n\tkfree(cdev->name);\n\tcdev->name = NULL;\n\tchannel->led = NULL;\n}\n\nstatic void gb_lights_channel_unregister(struct gb_channel *channel)\n{\n\t \n\tif (!is_channel_flash(channel)) {\n\t\t__gb_lights_led_unregister(channel);\n\t\treturn;\n\t}\n\n\tif (channel->mode & GB_CHANNEL_MODE_TORCH)\n\t\t__gb_lights_led_unregister(channel);\n\telse\n\t\t__gb_lights_flash_led_unregister(channel);\n}\n\nstatic int gb_lights_channel_config(struct gb_light *light,\n\t\t\t\t    struct gb_channel *channel)\n{\n\tstruct gb_lights_get_channel_config_response conf;\n\tstruct gb_lights_get_channel_config_request req;\n\tstruct gb_connection *connection = get_conn_from_light(light);\n\tstruct led_classdev *cdev = get_channel_cdev(channel);\n\tchar *name;\n\tint ret;\n\n\treq.light_id = light->id;\n\treq.channel_id = channel->id;\n\n\tret = gb_operation_sync(connection, GB_LIGHTS_TYPE_GET_CHANNEL_CONFIG,\n\t\t\t\t&req, sizeof(req), &conf, sizeof(conf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchannel->light = light;\n\tchannel->mode = le32_to_cpu(conf.mode);\n\tchannel->flags = le32_to_cpu(conf.flags);\n\tchannel->color = le32_to_cpu(conf.color);\n\tchannel->color_name = kstrndup(conf.color_name, NAMES_MAX, GFP_KERNEL);\n\tif (!channel->color_name)\n\t\treturn -ENOMEM;\n\tchannel->mode_name = kstrndup(conf.mode_name, NAMES_MAX, GFP_KERNEL);\n\tif (!channel->mode_name)\n\t\treturn -ENOMEM;\n\n\tchannel->led = cdev;\n\n\tname = kasprintf(GFP_KERNEL, \"%s:%s:%s\", light->name,\n\t\t\t channel->color_name, channel->mode_name);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tcdev->name = name;\n\n\tcdev->max_brightness = conf.max_brightness;\n\n\tret = channel_attr_groups_set(channel, cdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgb_lights_led_operations_set(channel, cdev);\n\n\t \n\tif (!is_channel_flash(channel))\n\t\treturn ret;\n\n\tlight->has_flash = true;\n\n\treturn gb_lights_channel_flash_config(channel);\n}\n\nstatic int gb_lights_light_config(struct gb_lights *glights, u8 id)\n{\n\tstruct gb_light *light = &glights->lights[id];\n\tstruct gb_lights_get_light_config_request req;\n\tstruct gb_lights_get_light_config_response conf;\n\tint ret;\n\tint i;\n\n\tlight->glights = glights;\n\tlight->id = id;\n\n\treq.id = id;\n\n\tret = gb_operation_sync(glights->connection,\n\t\t\t\tGB_LIGHTS_TYPE_GET_LIGHT_CONFIG,\n\t\t\t\t&req, sizeof(req), &conf, sizeof(conf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!conf.channel_count)\n\t\treturn -EINVAL;\n\tif (!strlen(conf.name))\n\t\treturn -EINVAL;\n\n\tlight->channels_count = conf.channel_count;\n\tlight->name = kstrndup(conf.name, NAMES_MAX, GFP_KERNEL);\n\tif (!light->name)\n\t\treturn -ENOMEM;\n\tlight->channels = kcalloc(light->channels_count,\n\t\t\t\t  sizeof(struct gb_channel), GFP_KERNEL);\n\tif (!light->channels)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < light->channels_count; i++) {\n\t\tlight->channels[i].id = i;\n\t\tret = gb_lights_channel_config(light, &light->channels[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_lights_light_register(struct gb_light *light)\n{\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < light->channels_count; i++) {\n\t\tret = gb_lights_channel_register(&light->channels[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmutex_init(&light->channels[i].lock);\n\t}\n\n\tlight->ready = true;\n\n\tif (light->has_flash) {\n\t\tret = gb_lights_light_v4l2_register(light);\n\t\tif (ret < 0) {\n\t\t\tlight->has_flash = false;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void gb_lights_channel_free(struct gb_channel *channel)\n{\n\tkfree(channel->attrs);\n\tkfree(channel->attr_group);\n\tkfree(channel->attr_groups);\n\tkfree(channel->color_name);\n\tkfree(channel->mode_name);\n\tmutex_destroy(&channel->lock);\n}\n\nstatic void gb_lights_channel_release(struct gb_channel *channel)\n{\n\tchannel->releasing = true;\n\n\tgb_lights_channel_unregister(channel);\n\n\tgb_lights_channel_free(channel);\n}\n\nstatic void gb_lights_light_release(struct gb_light *light)\n{\n\tint i;\n\n\tlight->ready = false;\n\n\tif (light->has_flash)\n\t\tgb_lights_light_v4l2_unregister(light);\n\tlight->has_flash = false;\n\n\tfor (i = 0; i < light->channels_count; i++)\n\t\tgb_lights_channel_release(&light->channels[i]);\n\tlight->channels_count = 0;\n\n\tkfree(light->channels);\n\tlight->channels = NULL;\n\tkfree(light->name);\n\tlight->name = NULL;\n}\n\nstatic void gb_lights_release(struct gb_lights *glights)\n{\n\tint i;\n\n\tif (!glights)\n\t\treturn;\n\n\tmutex_lock(&glights->lights_lock);\n\tif (!glights->lights)\n\t\tgoto free_glights;\n\n\tfor (i = 0; i < glights->lights_count; i++)\n\t\tgb_lights_light_release(&glights->lights[i]);\n\n\tkfree(glights->lights);\n\nfree_glights:\n\tmutex_unlock(&glights->lights_lock);\n\tmutex_destroy(&glights->lights_lock);\n\tkfree(glights);\n}\n\nstatic int gb_lights_get_count(struct gb_lights *glights)\n{\n\tstruct gb_lights_get_lights_response resp;\n\tint ret;\n\n\tret = gb_operation_sync(glights->connection, GB_LIGHTS_TYPE_GET_LIGHTS,\n\t\t\t\tNULL, 0, &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!resp.lights_count)\n\t\treturn -EINVAL;\n\n\tglights->lights_count = resp.lights_count;\n\n\treturn 0;\n}\n\nstatic int gb_lights_create_all(struct gb_lights *glights)\n{\n\tstruct gb_connection *connection = glights->connection;\n\tint ret;\n\tint i;\n\n\tmutex_lock(&glights->lights_lock);\n\tret = gb_lights_get_count(glights);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tglights->lights = kcalloc(glights->lights_count,\n\t\t\t\t  sizeof(struct gb_light), GFP_KERNEL);\n\tif (!glights->lights) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < glights->lights_count; i++) {\n\t\tret = gb_lights_light_config(glights, i);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&connection->bundle->dev,\n\t\t\t\t\"Fail to configure lights device\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&glights->lights_lock);\n\treturn ret;\n}\n\nstatic int gb_lights_register_all(struct gb_lights *glights)\n{\n\tstruct gb_connection *connection = glights->connection;\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&glights->lights_lock);\n\tfor (i = 0; i < glights->lights_count; i++) {\n\t\tret = gb_lights_light_register(&glights->lights[i]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&connection->bundle->dev,\n\t\t\t\t\"Fail to enable lights device\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&glights->lights_lock);\n\treturn ret;\n}\n\nstatic int gb_lights_request_handler(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct device *dev = &connection->bundle->dev;\n\tstruct gb_lights *glights = gb_connection_get_data(connection);\n\tstruct gb_light *light;\n\tstruct gb_message *request;\n\tstruct gb_lights_event_request *payload;\n\tint ret =  0;\n\tu8 light_id;\n\tu8 event;\n\n\tif (op->type != GB_LIGHTS_TYPE_EVENT) {\n\t\tdev_err(dev, \"Unsupported unsolicited event: %u\\n\", op->type);\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request;\n\n\tif (request->payload_size < sizeof(*payload)) {\n\t\tdev_err(dev, \"Wrong event size received (%zu < %zu)\\n\",\n\t\t\trequest->payload_size, sizeof(*payload));\n\t\treturn -EINVAL;\n\t}\n\n\tpayload = request->payload;\n\tlight_id = payload->light_id;\n\n\tif (light_id >= glights->lights_count ||\n\t    !glights->lights[light_id].ready) {\n\t\tdev_err(dev, \"Event received for unconfigured light id: %d\\n\",\n\t\t\tlight_id);\n\t\treturn -EINVAL;\n\t}\n\n\tevent = payload->event;\n\n\tif (event & GB_LIGHTS_LIGHT_CONFIG) {\n\t\tlight = &glights->lights[light_id];\n\n\t\tmutex_lock(&glights->lights_lock);\n\t\tgb_lights_light_release(light);\n\t\tret = gb_lights_light_config(glights, light_id);\n\t\tif (!ret)\n\t\t\tret = gb_lights_light_register(light);\n\t\tif (ret < 0)\n\t\t\tgb_lights_light_release(light);\n\t\tmutex_unlock(&glights->lights_lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int gb_lights_probe(struct gb_bundle *bundle,\n\t\t\t   const struct greybus_bundle_id *id)\n{\n\tstruct greybus_descriptor_cport *cport_desc;\n\tstruct gb_connection *connection;\n\tstruct gb_lights *glights;\n\tint ret;\n\n\tif (bundle->num_cports != 1)\n\t\treturn -ENODEV;\n\n\tcport_desc = &bundle->cport_desc[0];\n\tif (cport_desc->protocol_id != GREYBUS_PROTOCOL_LIGHTS)\n\t\treturn -ENODEV;\n\n\tglights = kzalloc(sizeof(*glights), GFP_KERNEL);\n\tif (!glights)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&glights->lights_lock);\n\n\tconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\n\t\t\t\t\t  gb_lights_request_handler);\n\tif (IS_ERR(connection)) {\n\t\tret = PTR_ERR(connection);\n\t\tgoto out;\n\t}\n\n\tglights->connection = connection;\n\tgb_connection_set_data(connection, glights);\n\n\tgreybus_set_drvdata(bundle, glights);\n\n\t \n\tret = gb_connection_enable_tx(connection);\n\tif (ret)\n\t\tgoto error_connection_destroy;\n\n\t \n\tret = gb_lights_create_all(glights);\n\tif (ret < 0)\n\t\tgoto error_connection_disable;\n\n\t \n\tret = gb_connection_enable(connection);\n\tif (ret)\n\t\tgoto error_connection_disable;\n\n\t \n\tret = gb_lights_register_all(glights);\n\tif (ret < 0)\n\t\tgoto error_connection_disable;\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn 0;\n\nerror_connection_disable:\n\tgb_connection_disable(connection);\nerror_connection_destroy:\n\tgb_connection_destroy(connection);\nout:\n\tgb_lights_release(glights);\n\treturn ret;\n}\n\nstatic void gb_lights_disconnect(struct gb_bundle *bundle)\n{\n\tstruct gb_lights *glights = greybus_get_drvdata(bundle);\n\n\tif (gb_pm_runtime_get_sync(bundle))\n\t\tgb_pm_runtime_get_noresume(bundle);\n\n\tgb_connection_disable(glights->connection);\n\tgb_connection_destroy(glights->connection);\n\n\tgb_lights_release(glights);\n}\n\nstatic const struct greybus_bundle_id gb_lights_id_table[] = {\n\t{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_LIGHTS) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(greybus, gb_lights_id_table);\n\nstatic struct greybus_driver gb_lights_driver = {\n\t.name\t\t= \"lights\",\n\t.probe\t\t= gb_lights_probe,\n\t.disconnect\t= gb_lights_disconnect,\n\t.id_table\t= gb_lights_id_table,\n};\nmodule_greybus_driver(gb_lights_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}