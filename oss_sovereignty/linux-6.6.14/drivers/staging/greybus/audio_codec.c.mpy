{
  "module_name": "audio_codec.c",
  "hash_id": "ef0bcdbfa4198e4257c325c059df48b8a59c70de3eb551e815a9258eda0a11d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/audio_codec.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n#include <uapi/linux/input.h>\n\n#include \"audio_codec.h\"\n#include \"audio_apbridgea.h\"\n#include \"audio_manager.h\"\n#include \"audio_helper.h\"\n\nstatic struct gbaudio_codec_info *gbcodec;\n\nstatic struct gbaudio_data_connection *\nfind_data(struct gbaudio_module_info *module, int id)\n{\n\tstruct gbaudio_data_connection *data;\n\n\tlist_for_each_entry(data, &module->data_list, list) {\n\t\tif (id == data->id)\n\t\t\treturn data;\n\t}\n\treturn NULL;\n}\n\nstatic struct gbaudio_stream_params *\nfind_dai_stream_params(struct gbaudio_codec_info *codec, int id, int stream)\n{\n\tstruct gbaudio_codec_dai *dai;\n\n\tlist_for_each_entry(dai, &codec->dai_list, list) {\n\t\tif (dai->id == id)\n\t\t\treturn &dai->params[stream];\n\t}\n\treturn NULL;\n}\n\nstatic int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,\n\t\t\t\t    struct gbaudio_module_info *module, int id)\n{\n\tint module_state, ret = 0;\n\tu16 data_cport, i2s_port, cportid;\n\tu8 sig_bits, channels;\n\tu32 format, rate;\n\tstruct gbaudio_data_connection *data;\n\tstruct gbaudio_stream_params *params;\n\n\t \n\tdata = find_data(module, id);\n\tif (!data) {\n\t\tdev_err(module->dev, \"%d:DATA connection missing\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\tmodule_state = data->state[SNDRV_PCM_STREAM_PLAYBACK];\n\n\tparams = find_dai_stream_params(codec, id, SNDRV_PCM_STREAM_PLAYBACK);\n\tif (!params) {\n\t\tdev_err(codec->dev, \"Failed to fetch dai_stream pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (module_state < GBAUDIO_CODEC_STARTUP) {\n\t\ti2s_port = 0;\t \n\t\tcportid = data->connection->hd_cport_id;\n\t\tret = gb_audio_apbridgea_register_cport(data->connection,\n\t\t\t\t\t\t\ti2s_port, cportid,\n\t\t\t\t\t\t\tAUDIO_APBRIDGEA_DIRECTION_TX);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(module->dev, \"reg_cport failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state[SNDRV_PCM_STREAM_PLAYBACK] = GBAUDIO_CODEC_STARTUP;\n\t\tdev_dbg(module->dev, \"Dynamic Register %d DAI\\n\", cportid);\n\t}\n\n\t \n\tif (module_state < GBAUDIO_CODEC_HWPARAMS) {\n\t\tformat = params->format;\n\t\tchannels = params->channels;\n\t\trate = params->rate;\n\t\tsig_bits = params->sig_bits;\n\t\tdata_cport = data->connection->intf_cport_id;\n\t\tret = gb_audio_gb_set_pcm(module->mgmt_connection, data_cport,\n\t\t\t\t\t  format, rate, channels, sig_bits);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(module->dev, \"set_pcm failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state[SNDRV_PCM_STREAM_PLAYBACK] = GBAUDIO_CODEC_HWPARAMS;\n\t\tdev_dbg(module->dev, \"Dynamic hw_params %d DAI\\n\", data_cport);\n\t}\n\n\t \n\tif (module_state < GBAUDIO_CODEC_PREPARE) {\n\t\tdata_cport = data->connection->intf_cport_id;\n\t\tret = gb_audio_gb_set_tx_data_size(module->mgmt_connection,\n\t\t\t\t\t\t   data_cport, 192);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(module->dev,\n\t\t\t\t\t    \"set_tx_data_size failed:%d\\n\",\n\t\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t\tret = gb_audio_gb_activate_tx(module->mgmt_connection, data_cport);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(module->dev,\n\t\t\t\t\t    \"activate_tx failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state[SNDRV_PCM_STREAM_PLAYBACK] = GBAUDIO_CODEC_PREPARE;\n\t\tdev_dbg(module->dev, \"Dynamic prepare %d DAI\\n\", data_cport);\n\t}\n\n\treturn 0;\n}\n\nstatic int gbaudio_module_disable_tx(struct gbaudio_module_info *module, int id)\n{\n\tint ret;\n\tu16 data_cport, cportid, i2s_port;\n\tint module_state;\n\tstruct gbaudio_data_connection *data;\n\n\t \n\tdata = find_data(module, id);\n\tif (!data) {\n\t\tdev_err(module->dev, \"%d:DATA connection missing\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\tmodule_state = data->state[SNDRV_PCM_STREAM_PLAYBACK];\n\n\tif (module_state > GBAUDIO_CODEC_HWPARAMS) {\n\t\tdata_cport = data->connection->intf_cport_id;\n\t\tret = gb_audio_gb_deactivate_tx(module->mgmt_connection,\n\t\t\t\t\t\tdata_cport);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(module->dev,\n\t\t\t\t\t    \"deactivate_tx failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(module->dev, \"Dynamic deactivate %d DAI\\n\", data_cport);\n\t\tdata->state[SNDRV_PCM_STREAM_PLAYBACK] = GBAUDIO_CODEC_HWPARAMS;\n\t}\n\n\tif (module_state > GBAUDIO_CODEC_SHUTDOWN) {\n\t\ti2s_port = 0;\t \n\t\tcportid = data->connection->hd_cport_id;\n\t\tret = gb_audio_apbridgea_unregister_cport(data->connection,\n\t\t\t\t\t\t\t  i2s_port, cportid,\n\t\t\t\t\t\t\t  AUDIO_APBRIDGEA_DIRECTION_TX);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(module->dev,\n\t\t\t\t\t    \"unregister_cport failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(module->dev, \"Dynamic Unregister %d DAI\\n\", cportid);\n\t\tdata->state[SNDRV_PCM_STREAM_PLAYBACK] = GBAUDIO_CODEC_SHUTDOWN;\n\t}\n\n\treturn 0;\n}\n\nstatic int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,\n\t\t\t\t    struct gbaudio_module_info *module, int id)\n{\n\tint module_state, ret = 0;\n\tu16 data_cport, i2s_port, cportid;\n\tu8 sig_bits, channels;\n\tu32 format, rate;\n\tstruct gbaudio_data_connection *data;\n\tstruct gbaudio_stream_params *params;\n\n\t \n\tdata = find_data(module, id);\n\tif (!data) {\n\t\tdev_err(module->dev, \"%d:DATA connection missing\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\tmodule_state = data->state[SNDRV_PCM_STREAM_CAPTURE];\n\n\tparams = find_dai_stream_params(codec, id, SNDRV_PCM_STREAM_CAPTURE);\n\tif (!params) {\n\t\tdev_err(codec->dev, \"Failed to fetch dai_stream pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (module_state < GBAUDIO_CODEC_STARTUP) {\n\t\ti2s_port = 0;\t \n\t\tcportid = data->connection->hd_cport_id;\n\t\tret = gb_audio_apbridgea_register_cport(data->connection,\n\t\t\t\t\t\t\ti2s_port, cportid,\n\t\t\t\t\t\t\tAUDIO_APBRIDGEA_DIRECTION_RX);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(module->dev, \"reg_cport failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state[SNDRV_PCM_STREAM_CAPTURE] = GBAUDIO_CODEC_STARTUP;\n\t\tdev_dbg(module->dev, \"Dynamic Register %d DAI\\n\", cportid);\n\t}\n\n\t \n\tif (module_state < GBAUDIO_CODEC_HWPARAMS) {\n\t\tformat = params->format;\n\t\tchannels = params->channels;\n\t\trate = params->rate;\n\t\tsig_bits = params->sig_bits;\n\t\tdata_cport = data->connection->intf_cport_id;\n\t\tret = gb_audio_gb_set_pcm(module->mgmt_connection, data_cport,\n\t\t\t\t\t  format, rate, channels, sig_bits);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(module->dev, \"set_pcm failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state[SNDRV_PCM_STREAM_CAPTURE] = GBAUDIO_CODEC_HWPARAMS;\n\t\tdev_dbg(module->dev, \"Dynamic hw_params %d DAI\\n\", data_cport);\n\t}\n\n\t \n\tif (module_state < GBAUDIO_CODEC_PREPARE) {\n\t\tdata_cport = data->connection->intf_cport_id;\n\t\tret = gb_audio_gb_set_rx_data_size(module->mgmt_connection,\n\t\t\t\t\t\t   data_cport, 192);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(module->dev,\n\t\t\t\t\t    \"set_rx_data_size failed:%d\\n\",\n\t\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t\tret = gb_audio_gb_activate_rx(module->mgmt_connection,\n\t\t\t\t\t      data_cport);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(module->dev,\n\t\t\t\t\t    \"activate_rx failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state[SNDRV_PCM_STREAM_CAPTURE] = GBAUDIO_CODEC_PREPARE;\n\t\tdev_dbg(module->dev, \"Dynamic prepare %d DAI\\n\", data_cport);\n\t}\n\n\treturn 0;\n}\n\nstatic int gbaudio_module_disable_rx(struct gbaudio_module_info *module, int id)\n{\n\tint ret;\n\tu16 data_cport, cportid, i2s_port;\n\tint module_state;\n\tstruct gbaudio_data_connection *data;\n\n\t \n\tdata = find_data(module, id);\n\tif (!data) {\n\t\tdev_err(module->dev, \"%d:DATA connection missing\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\tmodule_state = data->state[SNDRV_PCM_STREAM_CAPTURE];\n\n\tif (module_state > GBAUDIO_CODEC_HWPARAMS) {\n\t\tdata_cport = data->connection->intf_cport_id;\n\t\tret = gb_audio_gb_deactivate_rx(module->mgmt_connection,\n\t\t\t\t\t\tdata_cport);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(module->dev,\n\t\t\t\t\t    \"deactivate_rx failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(module->dev, \"Dynamic deactivate %d DAI\\n\", data_cport);\n\t\tdata->state[SNDRV_PCM_STREAM_CAPTURE] = GBAUDIO_CODEC_HWPARAMS;\n\t}\n\n\tif (module_state > GBAUDIO_CODEC_SHUTDOWN) {\n\t\ti2s_port = 0;\t \n\t\tcportid = data->connection->hd_cport_id;\n\t\tret = gb_audio_apbridgea_unregister_cport(data->connection,\n\t\t\t\t\t\t\t  i2s_port, cportid,\n\t\t\t\t\t\t\t  AUDIO_APBRIDGEA_DIRECTION_RX);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(module->dev,\n\t\t\t\t\t    \"unregister_cport failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(module->dev, \"Dynamic Unregister %d DAI\\n\", cportid);\n\t\tdata->state[SNDRV_PCM_STREAM_CAPTURE] = GBAUDIO_CODEC_SHUTDOWN;\n\t}\n\n\treturn 0;\n}\n\nint gbaudio_module_update(struct gbaudio_codec_info *codec,\n\t\t\t  struct snd_soc_dapm_widget *w,\n\t\t\t  struct gbaudio_module_info *module, int enable)\n{\n\tint dai_id, ret;\n\tchar intf_name[NAME_SIZE], dir[NAME_SIZE];\n\n\tdev_dbg(module->dev, \"%s:Module update %s sequence\\n\", w->name,\n\t\tenable ? \"Enable\" : \"Disable\");\n\n\tif ((w->id != snd_soc_dapm_aif_in) && (w->id != snd_soc_dapm_aif_out)) {\n\t\tdev_dbg(codec->dev, \"No action required for %s\\n\", w->name);\n\t\treturn 0;\n\t}\n\n\t \n\tret = sscanf(w->sname, \"%s %d %s\", intf_name, &dai_id, dir);\n\tif (ret < 3) {\n\t\tdev_err(codec->dev, \"Error while parsing dai_id for %s\\n\", w->name);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&codec->lock);\n\tif (w->id == snd_soc_dapm_aif_in) {\n\t\tif (enable)\n\t\t\tret = gbaudio_module_enable_tx(codec, module, dai_id);\n\t\telse\n\t\t\tret = gbaudio_module_disable_tx(module, dai_id);\n\t} else if (w->id == snd_soc_dapm_aif_out) {\n\t\tif (enable)\n\t\t\tret = gbaudio_module_enable_rx(codec, module, dai_id);\n\t\telse\n\t\t\tret = gbaudio_module_disable_rx(module, dai_id);\n\t}\n\n\tmutex_unlock(&codec->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(gbaudio_module_update);\n\n \nstatic int gbcodec_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);\n\tstruct gbaudio_stream_params *params;\n\n\tmutex_lock(&codec->lock);\n\n\tif (list_empty(&codec->module_list)) {\n\t\tdev_err(codec->dev, \"No codec module available\\n\");\n\t\tmutex_unlock(&codec->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tparams = find_dai_stream_params(codec, dai->id, substream->stream);\n\tif (!params) {\n\t\tdev_err(codec->dev, \"Failed to fetch dai_stream pointer\\n\");\n\t\tmutex_unlock(&codec->lock);\n\t\treturn -EINVAL;\n\t}\n\tparams->state = GBAUDIO_CODEC_STARTUP;\n\tmutex_unlock(&codec->lock);\n\t \n\tpm_stay_awake(dai->dev);\n\n\treturn 0;\n}\n\nstatic void gbcodec_shutdown(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);\n\tstruct gbaudio_stream_params *params;\n\n\tmutex_lock(&codec->lock);\n\n\tif (list_empty(&codec->module_list))\n\t\tdev_info(codec->dev, \"No codec module available during shutdown\\n\");\n\n\tparams = find_dai_stream_params(codec, dai->id, substream->stream);\n\tif (!params) {\n\t\tdev_err(codec->dev, \"Failed to fetch dai_stream pointer\\n\");\n\t\tmutex_unlock(&codec->lock);\n\t\treturn;\n\t}\n\tparams->state = GBAUDIO_CODEC_SHUTDOWN;\n\tmutex_unlock(&codec->lock);\n\tpm_relax(dai->dev);\n}\n\nstatic int gbcodec_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *hwparams,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tint ret;\n\tu8 sig_bits, channels;\n\tu32 format, rate;\n\tstruct gbaudio_module_info *module;\n\tstruct gbaudio_data_connection *data;\n\tstruct gb_bundle *bundle;\n\tstruct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);\n\tstruct gbaudio_stream_params *params;\n\n\tmutex_lock(&codec->lock);\n\n\tif (list_empty(&codec->module_list)) {\n\t\tdev_err(codec->dev, \"No codec module available\\n\");\n\t\tmutex_unlock(&codec->lock);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (params_channels(hwparams) != 2) {\n\t\tdev_err(dai->dev, \"Invalid channel count:%d\\n\",\n\t\t\tparams_channels(hwparams));\n\t\tmutex_unlock(&codec->lock);\n\t\treturn -EINVAL;\n\t}\n\tchannels = params_channels(hwparams);\n\n\tif (params_rate(hwparams) != 48000) {\n\t\tdev_err(dai->dev, \"Invalid sampling rate:%d\\n\",\n\t\t\tparams_rate(hwparams));\n\t\tmutex_unlock(&codec->lock);\n\t\treturn -EINVAL;\n\t}\n\trate = GB_AUDIO_PCM_RATE_48000;\n\n\tif (params_format(hwparams) != SNDRV_PCM_FORMAT_S16_LE) {\n\t\tdev_err(dai->dev, \"Invalid format:%d\\n\", params_format(hwparams));\n\t\tmutex_unlock(&codec->lock);\n\t\treturn -EINVAL;\n\t}\n\tformat = GB_AUDIO_PCM_FMT_S16_LE;\n\n\t \n\tlist_for_each_entry(module, &codec->module_list, list) {\n\t\tdata = find_data(module, dai->id);\n\t\tif (data)\n\t\t\tbreak;\n\t}\n\n\tif (!data) {\n\t\tdev_err(dai->dev, \"DATA connection missing\\n\");\n\t\tmutex_unlock(&codec->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tparams = find_dai_stream_params(codec, dai->id, substream->stream);\n\tif (!params) {\n\t\tdev_err(codec->dev, \"Failed to fetch dai_stream pointer\\n\");\n\t\tmutex_unlock(&codec->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tbundle = to_gb_bundle(module->dev);\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret) {\n\t\tmutex_unlock(&codec->lock);\n\t\treturn ret;\n\t}\n\n\tret = gb_audio_apbridgea_set_config(data->connection, 0,\n\t\t\t\t\t    AUDIO_APBRIDGEA_PCM_FMT_16,\n\t\t\t\t\t    AUDIO_APBRIDGEA_PCM_RATE_48000,\n\t\t\t\t\t    6144000);\n\tif (ret) {\n\t\tdev_err_ratelimited(dai->dev, \"%d: Error during set_config\\n\",\n\t\t\t\t    ret);\n\t\tgb_pm_runtime_put_noidle(bundle);\n\t\tmutex_unlock(&codec->lock);\n\t\treturn ret;\n\t}\n\n\tgb_pm_runtime_put_noidle(bundle);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsig_bits = dai->driver->playback.sig_bits;\n\telse\n\t\tsig_bits = dai->driver->capture.sig_bits;\n\n\tparams->state = GBAUDIO_CODEC_HWPARAMS;\n\tparams->format = format;\n\tparams->rate = rate;\n\tparams->channels = channels;\n\tparams->sig_bits = sig_bits;\n\n\tmutex_unlock(&codec->lock);\n\treturn 0;\n}\n\nstatic int gbcodec_prepare(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tint ret;\n\tstruct gbaudio_module_info *module = NULL, *iter;\n\tstruct gbaudio_data_connection *data;\n\tstruct gb_bundle *bundle;\n\tstruct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);\n\tstruct gbaudio_stream_params *params;\n\n\tmutex_lock(&codec->lock);\n\n\tif (list_empty(&codec->module_list)) {\n\t\tdev_err(codec->dev, \"No codec module available\\n\");\n\t\tmutex_unlock(&codec->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tlist_for_each_entry(iter, &codec->module_list, list) {\n\t\t \n\t\tdata = find_data(iter, dai->id);\n\t\tif (data) {\n\t\t\tmodule = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!data) {\n\t\tdev_err(dai->dev, \"DATA connection missing\\n\");\n\t\tmutex_unlock(&codec->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tparams = find_dai_stream_params(codec, dai->id, substream->stream);\n\tif (!params) {\n\t\tdev_err(codec->dev, \"Failed to fetch dai_stream pointer\\n\");\n\t\tmutex_unlock(&codec->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tbundle = to_gb_bundle(module->dev);\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret) {\n\t\tmutex_unlock(&codec->lock);\n\t\treturn ret;\n\t}\n\n\tswitch (substream->stream) {\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\tret = gb_audio_apbridgea_set_tx_data_size(data->connection, 0, 192);\n\t\tbreak;\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\tret = gb_audio_apbridgea_set_rx_data_size(data->connection, 0, 192);\n\t\tbreak;\n\t}\n\tif (ret) {\n\t\tgb_pm_runtime_put_noidle(bundle);\n\t\tmutex_unlock(&codec->lock);\n\t\tdev_err_ratelimited(dai->dev, \"set_data_size failed:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgb_pm_runtime_put_noidle(bundle);\n\n\tparams->state = GBAUDIO_CODEC_PREPARE;\n\tmutex_unlock(&codec->lock);\n\treturn 0;\n}\n\nstatic int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tint ret;\n\tstruct gbaudio_data_connection *data;\n\tstruct gbaudio_module_info *module = NULL, *iter;\n\tstruct gb_bundle *bundle;\n\tstruct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);\n\tstruct gbaudio_stream_params *params;\n\n\tdev_dbg(dai->dev, \"Mute:%d, Direction:%s\\n\", mute,\n\t\tstream ? \"CAPTURE\" : \"PLAYBACK\");\n\n\tmutex_lock(&codec->lock);\n\n\tparams = find_dai_stream_params(codec, dai->id, stream);\n\tif (!params) {\n\t\tdev_err(codec->dev, \"Failed to fetch dai_stream pointer\\n\");\n\t\tmutex_unlock(&codec->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (list_empty(&codec->module_list)) {\n\t\tdev_err(codec->dev, \"No codec module available\\n\");\n\t\tif (mute) {\n\t\t\tparams->state = GBAUDIO_CODEC_STOP;\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = -ENODEV;\n\t\t}\n\t\tmutex_unlock(&codec->lock);\n\t\treturn ret;\n\t}\n\n\tlist_for_each_entry(iter, &codec->module_list, list) {\n\t\t \n\t\tdata = find_data(iter, dai->id);\n\t\tif (data) {\n\t\t\tmodule = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!data) {\n\t\tdev_err(dai->dev, \"%s DATA connection missing\\n\",\n\t\t\tdai->name);\n\t\tmutex_unlock(&codec->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tbundle = to_gb_bundle(module->dev);\n\tret = gb_pm_runtime_get_sync(bundle);\n\tif (ret) {\n\t\tmutex_unlock(&codec->lock);\n\t\treturn ret;\n\t}\n\n\tif (!mute && !stream) { \n\t\tret = gb_audio_apbridgea_prepare_tx(data->connection, 0);\n\t\tif (!ret)\n\t\t\tret = gb_audio_apbridgea_start_tx(data->connection, 0, 0);\n\t\tparams->state = GBAUDIO_CODEC_START;\n\t} else if (!mute && stream) { \n\t\tret = gb_audio_apbridgea_prepare_rx(data->connection, 0);\n\t\tif (!ret)\n\t\t\tret = gb_audio_apbridgea_start_rx(data->connection, 0);\n\t\tparams->state = GBAUDIO_CODEC_START;\n\t} else if (mute && !stream) { \n\t\tret = gb_audio_apbridgea_stop_tx(data->connection, 0);\n\t\tif (!ret)\n\t\t\tret = gb_audio_apbridgea_shutdown_tx(data->connection, 0);\n\t\tparams->state = GBAUDIO_CODEC_STOP;\n\t} else if (mute && stream) { \n\t\tret = gb_audio_apbridgea_stop_rx(data->connection, 0);\n\t\tif (!ret)\n\t\t\tret = gb_audio_apbridgea_shutdown_rx(data->connection, 0);\n\t\tparams->state = GBAUDIO_CODEC_STOP;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tdev_err_ratelimited(dai->dev,\n\t\t\t\t    \"%s:Error during %s %s stream:%d\\n\",\n\t\t\t\t    module->name, mute ? \"Mute\" : \"Unmute\",\n\t\t\t\t    stream ? \"Capture\" : \"Playback\", ret);\n\n\tgb_pm_runtime_put_noidle(bundle);\n\tmutex_unlock(&codec->lock);\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops gbcodec_dai_ops = {\n\t.startup = gbcodec_startup,\n\t.shutdown = gbcodec_shutdown,\n\t.hw_params = gbcodec_hw_params,\n\t.prepare = gbcodec_prepare,\n\t.mute_stream = gbcodec_mute_stream,\n};\n\nstatic struct snd_soc_dai_driver gbaudio_dai[] = {\n\t{\n\t\t.name = \"apb-i2s0\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"I2S 0 Playback\",\n\t\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t\t.rate_max = 48000,\n\t\t\t.rate_min = 48000,\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.sig_bits = 16,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"I2S 0 Capture\",\n\t\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t\t.rate_max = 48000,\n\t\t\t.rate_min = 48000,\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.sig_bits = 16,\n\t\t},\n\t\t.ops = &gbcodec_dai_ops,\n\t},\n};\n\nstatic int gbaudio_init_jack(struct gbaudio_module_info *module,\n\t\t\t     struct snd_soc_card *card)\n{\n\tint ret;\n\tstruct gbaudio_jack *jack, *n;\n\tstruct snd_soc_jack_pin *headset, *button;\n\n\tif (!module->jack_mask)\n\t\treturn 0;\n\n\tsnprintf(module->jack_name, NAME_SIZE, \"GB %d Headset Jack\",\n\t\t module->dev_id);\n\n\theadset = devm_kzalloc(module->dev, sizeof(*headset), GFP_KERNEL);\n\tif (!headset)\n\t\treturn -ENOMEM;\n\n\theadset->pin = module->jack_name;\n\theadset->mask = module->jack_mask;\n\tret = snd_soc_card_jack_new_pins(card, module->jack_name,\n\t\t\t\t\t module->jack_mask,\n\t\t\t\t\t &module->headset.jack, headset, 1);\n\tif (ret) {\n\t\tdev_err(module->dev, \"Failed to create new jack\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tlist_add(&module->headset.list, &module->jack_list);\n\n\tif (!module->button_mask)\n\t\treturn 0;\n\n\tsnprintf(module->button_name, NAME_SIZE, \"GB %d Button Jack\",\n\t\t module->dev_id);\n\tbutton = devm_kzalloc(module->dev, sizeof(*button), GFP_KERNEL);\n\tif (!button) {\n\t\tret = -ENOMEM;\n\t\tgoto free_jacks;\n\t}\n\n\tbutton->pin = module->button_name;\n\tbutton->mask = module->button_mask;\n\tret = snd_soc_card_jack_new_pins(card, module->button_name,\n\t\t\t\t\t module->button_mask,\n\t\t\t\t\t &module->button.jack,\n\t\t\t\t\t button, 1);\n\tif (ret) {\n\t\tdev_err(module->dev, \"Failed to create button jack\\n\");\n\t\tgoto free_jacks;\n\t}\n\n\t \n\tlist_add(&module->button.list, &module->jack_list);\n\n\t \n\n\tif (module->button_mask & SND_JACK_BTN_0) {\n\t\tret = snd_jack_set_key(module->button.jack.jack, SND_JACK_BTN_0,\n\t\t\t\t       KEY_MEDIA);\n\t\tif (ret) {\n\t\t\tdev_err(module->dev, \"Failed to set BTN_0\\n\");\n\t\t\tgoto free_jacks;\n\t\t}\n\t}\n\n\tif (module->button_mask & SND_JACK_BTN_1) {\n\t\tret = snd_jack_set_key(module->button.jack.jack, SND_JACK_BTN_1,\n\t\t\t\t       KEY_VOICECOMMAND);\n\t\tif (ret) {\n\t\t\tdev_err(module->dev, \"Failed to set BTN_1\\n\");\n\t\t\tgoto free_jacks;\n\t\t}\n\t}\n\n\tif (module->button_mask & SND_JACK_BTN_2) {\n\t\tret = snd_jack_set_key(module->button.jack.jack, SND_JACK_BTN_2,\n\t\t\t\t       KEY_VOLUMEUP);\n\t\tif (ret) {\n\t\t\tdev_err(module->dev, \"Failed to set BTN_2\\n\");\n\t\t\tgoto free_jacks;\n\t\t}\n\t}\n\n\tif (module->button_mask & SND_JACK_BTN_3) {\n\t\tret = snd_jack_set_key(module->button.jack.jack, SND_JACK_BTN_3,\n\t\t\t\t       KEY_VOLUMEDOWN);\n\t\tif (ret) {\n\t\t\tdev_err(module->dev, \"Failed to set BTN_0\\n\");\n\t\t\tgoto free_jacks;\n\t\t}\n\t}\n\n\t \n\n\treturn 0;\n\nfree_jacks:\n\tlist_for_each_entry_safe(jack, n, &module->jack_list, list) {\n\t\tsnd_device_free(card->snd_card, jack->jack.jack);\n\t\tlist_del(&jack->list);\n\t}\n\n\treturn ret;\n}\n\nint gbaudio_register_module(struct gbaudio_module_info *module)\n{\n\tint ret;\n\tstruct snd_soc_component *comp;\n\tstruct gbaudio_jack *jack = NULL;\n\n\tif (!gbcodec) {\n\t\tdev_err(module->dev, \"GB Codec not yet probed\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tcomp = gbcodec->component;\n\n\tmutex_lock(&gbcodec->register_mutex);\n\n\tif (module->num_dais) {\n\t\tdev_err(gbcodec->dev,\n\t\t\t\"%d:DAIs not supported via gbcodec driver\\n\",\n\t\t\tmodule->num_dais);\n\t\tmutex_unlock(&gbcodec->register_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tret = gbaudio_init_jack(module, comp->card);\n\tif (ret) {\n\t\tmutex_unlock(&gbcodec->register_mutex);\n\t\treturn ret;\n\t}\n\n\tif (module->dapm_widgets)\n\t\tsnd_soc_dapm_new_controls(&comp->dapm, module->dapm_widgets,\n\t\t\t\t\t  module->num_dapm_widgets);\n\tif (module->controls)\n\t\tsnd_soc_add_component_controls(comp, module->controls,\n\t\t\t\t\t       module->num_controls);\n\tif (module->dapm_routes)\n\t\tsnd_soc_dapm_add_routes(&comp->dapm, module->dapm_routes,\n\t\t\t\t\tmodule->num_dapm_routes);\n\n\t \n\tif (comp->card->instantiated) {\n\t\tgbaudio_dapm_link_component_dai_widgets(comp->card, &comp->dapm);\n#ifdef CONFIG_SND_JACK\n\t\t \n\t\tlist_for_each_entry(jack, &module->jack_list, list) {\n\t\t\tsnd_device_register(comp->card->snd_card,\n\t\t\t\t\t    jack->jack.jack);\n\t\t}\n#endif\n\t}\n\n\tmutex_lock(&gbcodec->lock);\n\tlist_add(&module->list, &gbcodec->module_list);\n\tmutex_unlock(&gbcodec->lock);\n\n\tif (comp->card->instantiated)\n\t\tret = snd_soc_dapm_new_widgets(comp->card);\n\tdev_dbg(comp->dev, \"Registered %s module\\n\", module->name);\n\n\tmutex_unlock(&gbcodec->register_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(gbaudio_register_module);\n\nstatic void gbaudio_codec_clean_data_tx(struct gbaudio_data_connection *data)\n{\n\tu16 i2s_port, cportid;\n\tint ret;\n\n\tif (list_is_singular(&gbcodec->module_list)) {\n\t\tret = gb_audio_apbridgea_stop_tx(data->connection, 0);\n\t\tif (ret)\n\t\t\treturn;\n\t\tret = gb_audio_apbridgea_shutdown_tx(data->connection, 0);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\ti2s_port = 0;\t \n\tcportid = data->connection->hd_cport_id;\n\tret = gb_audio_apbridgea_unregister_cport(data->connection,\n\t\t\t\t\t\t  i2s_port, cportid,\n\t\t\t\t\t\t  AUDIO_APBRIDGEA_DIRECTION_TX);\n\tdata->state[0] = GBAUDIO_CODEC_SHUTDOWN;\n}\n\nstatic void gbaudio_codec_clean_data_rx(struct gbaudio_data_connection *data)\n{\n\tu16 i2s_port, cportid;\n\tint ret;\n\n\tif (list_is_singular(&gbcodec->module_list)) {\n\t\tret = gb_audio_apbridgea_stop_rx(data->connection, 0);\n\t\tif (ret)\n\t\t\treturn;\n\t\tret = gb_audio_apbridgea_shutdown_rx(data->connection, 0);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\ti2s_port = 0;\t \n\tcportid = data->connection->hd_cport_id;\n\tret = gb_audio_apbridgea_unregister_cport(data->connection,\n\t\t\t\t\t\t  i2s_port, cportid,\n\t\t\t\t\t\t  AUDIO_APBRIDGEA_DIRECTION_RX);\n\tdata->state[1] = GBAUDIO_CODEC_SHUTDOWN;\n}\n\nstatic void gbaudio_codec_cleanup(struct gbaudio_module_info *module)\n{\n\tstruct gbaudio_data_connection *data;\n\tint pb_state, cap_state;\n\n\tdev_dbg(gbcodec->dev, \"%s: removed, cleanup APBridge\\n\", module->name);\n\tlist_for_each_entry(data, &module->data_list, list) {\n\t\tpb_state = data->state[0];\n\t\tcap_state = data->state[1];\n\n\t\tif (pb_state > GBAUDIO_CODEC_SHUTDOWN)\n\t\t\tgbaudio_codec_clean_data_tx(data);\n\n\t\tif (cap_state > GBAUDIO_CODEC_SHUTDOWN)\n\t\t\tgbaudio_codec_clean_data_rx(data);\n\t}\n}\n\nvoid gbaudio_unregister_module(struct gbaudio_module_info *module)\n{\n\tstruct snd_soc_component *comp = gbcodec->component;\n\tstruct gbaudio_jack *jack, *n;\n\tint mask;\n\n\tdev_dbg(comp->dev, \"Unregister %s module\\n\", module->name);\n\n\tmutex_lock(&gbcodec->register_mutex);\n\tmutex_lock(&gbcodec->lock);\n\tgbaudio_codec_cleanup(module);\n\tlist_del(&module->list);\n\tdev_dbg(comp->dev, \"Process Unregister %s module\\n\", module->name);\n\tmutex_unlock(&gbcodec->lock);\n\n#ifdef CONFIG_SND_JACK\n\t \n\tlist_for_each_entry_safe(jack, n, &module->jack_list, list) {\n\t\tif (jack == &module->headset)\n\t\t\tmask = GBCODEC_JACK_MASK;\n\t\telse if (jack == &module->button)\n\t\t\tmask = GBCODEC_JACK_BUTTON_MASK;\n\t\telse\n\t\t\tmask = 0;\n\t\tif (mask) {\n\t\t\tdev_dbg(module->dev, \"Report %s removal\\n\",\n\t\t\t\tjack->jack.jack->id);\n\t\t\tsnd_soc_jack_report(&jack->jack, 0, mask);\n\t\t\tsnd_device_free(comp->card->snd_card,\n\t\t\t\t\tjack->jack.jack);\n\t\t\tlist_del(&jack->list);\n\t\t}\n\t}\n#endif\n\n\tif (module->dapm_routes) {\n\t\tdev_dbg(comp->dev, \"Removing %d routes\\n\",\n\t\t\tmodule->num_dapm_routes);\n\t\tsnd_soc_dapm_del_routes(&comp->dapm, module->dapm_routes,\n\t\t\t\t\tmodule->num_dapm_routes);\n\t}\n\tif (module->controls) {\n\t\tdev_dbg(comp->dev, \"Removing %d controls\\n\",\n\t\t\tmodule->num_controls);\n\t\t \n\t\tgbaudio_remove_component_controls(comp, module->controls,\n\t\t\t\t\t\t  module->num_controls);\n\t}\n\tif (module->dapm_widgets) {\n\t\tdev_dbg(comp->dev, \"Removing %d widgets\\n\",\n\t\t\tmodule->num_dapm_widgets);\n\t\tgbaudio_dapm_free_controls(&comp->dapm, module->dapm_widgets,\n\t\t\t\t\t   module->num_dapm_widgets);\n\t}\n\n\tdev_dbg(comp->dev, \"Unregistered %s module\\n\", module->name);\n\n\tmutex_unlock(&gbcodec->register_mutex);\n}\nEXPORT_SYMBOL(gbaudio_unregister_module);\n\n \nstatic int gbcodec_probe(struct snd_soc_component *comp)\n{\n\tint i;\n\tstruct gbaudio_codec_info *info;\n\tstruct gbaudio_codec_dai *dai;\n\n\tinfo = devm_kzalloc(comp->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = comp->dev;\n\tINIT_LIST_HEAD(&info->module_list);\n\tmutex_init(&info->lock);\n\tmutex_init(&info->register_mutex);\n\tINIT_LIST_HEAD(&info->dai_list);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(gbaudio_dai); i++) {\n\t\tdai = devm_kzalloc(comp->dev, sizeof(*dai), GFP_KERNEL);\n\t\tif (!dai)\n\t\t\treturn -ENOMEM;\n\t\tdai->id = gbaudio_dai[i].id;\n\t\tlist_add(&dai->list, &info->dai_list);\n\t}\n\n\tinfo->component = comp;\n\tsnd_soc_component_set_drvdata(comp, info);\n\tgbcodec = info;\n\n\tdevice_init_wakeup(comp->dev, 1);\n\treturn 0;\n}\n\nstatic int gbcodec_write(struct snd_soc_component *comp, unsigned int reg,\n\t\t\t unsigned int value)\n{\n\treturn 0;\n}\n\nstatic unsigned int gbcodec_read(struct snd_soc_component *comp,\n\t\t\t\t unsigned int reg)\n{\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_codec_dev_gbaudio = {\n\t.probe\t= gbcodec_probe,\n\t.read = gbcodec_read,\n\t.write = gbcodec_write,\n};\n\n#ifdef CONFIG_PM\nstatic int gbaudio_codec_suspend(struct device *dev)\n{\n\tdev_dbg(dev, \"%s: suspend\\n\", __func__);\n\treturn 0;\n}\n\nstatic int gbaudio_codec_resume(struct device *dev)\n{\n\tdev_dbg(dev, \"%s: resume\\n\", __func__);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops gbaudio_codec_pm_ops = {\n\t.suspend\t= gbaudio_codec_suspend,\n\t.resume\t\t= gbaudio_codec_resume,\n};\n#endif\n\nstatic int gbaudio_codec_probe(struct platform_device *pdev)\n{\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t&soc_codec_dev_gbaudio,\n\t\t\tgbaudio_dai, ARRAY_SIZE(gbaudio_dai));\n}\n\nstatic const struct of_device_id greybus_asoc_machine_of_match[]  = {\n\t{ .compatible = \"toshiba,apb-dummy-codec\", },\n\t{},\n};\n\nstatic struct platform_driver gbaudio_codec_driver = {\n\t.driver = {\n\t\t.name = \"apb-dummy-codec\",\n#ifdef CONFIG_PM\n\t\t.pm = &gbaudio_codec_pm_ops,\n#endif\n\t\t.of_match_table = greybus_asoc_machine_of_match,\n\t},\n\t.probe = gbaudio_codec_probe,\n};\nmodule_platform_driver(gbaudio_codec_driver);\n\nMODULE_DESCRIPTION(\"APBridge ALSA SoC dummy codec driver\");\nMODULE_AUTHOR(\"Vaibhav Agarwal <vaibhav.agarwal@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:apb-dummy-codec\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}