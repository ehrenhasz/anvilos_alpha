{
  "module_name": "i2c.c",
  "hash_id": "3628505463933a153661d20f49f9cf8db46b6390e14d5bcd758a84d3e53f4616",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/i2c.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/greybus.h>\n\n#include \"gbphy.h\"\n\nstruct gb_i2c_device {\n\tstruct gb_connection\t*connection;\n\tstruct gbphy_device\t*gbphy_dev;\n\n\tu32\t\t\tfunctionality;\n\n\tstruct i2c_adapter\tadapter;\n};\n\n \nstatic u32 gb_i2c_functionality_map(u32 gb_i2c_functionality)\n{\n\treturn gb_i2c_functionality;\t \n}\n\n \nstatic int gb_i2c_device_setup(struct gb_i2c_device *gb_i2c_dev)\n{\n\tstruct gb_i2c_functionality_response response;\n\tu32 functionality;\n\tint ret;\n\n\tret = gb_operation_sync(gb_i2c_dev->connection,\n\t\t\t\tGB_I2C_TYPE_FUNCTIONALITY,\n\t\t\t\tNULL, 0, &response, sizeof(response));\n\tif (ret)\n\t\treturn ret;\n\n\tfunctionality = le32_to_cpu(response.functionality);\n\tgb_i2c_dev->functionality = gb_i2c_functionality_map(functionality);\n\n\treturn 0;\n}\n\n \nstatic u16 gb_i2c_transfer_op_flags_map(u16 flags)\n{\n\treturn flags;\t \n}\n\nstatic void\ngb_i2c_fill_transfer_op(struct gb_i2c_transfer_op *op, struct i2c_msg *msg)\n{\n\tu16 flags = gb_i2c_transfer_op_flags_map(msg->flags);\n\n\top->addr = cpu_to_le16(msg->addr);\n\top->flags = cpu_to_le16(flags);\n\top->size = cpu_to_le16(msg->len);\n}\n\nstatic struct gb_operation *\ngb_i2c_operation_create(struct gb_connection *connection,\n\t\t\tstruct i2c_msg *msgs, u32 msg_count)\n{\n\tstruct gb_i2c_device *gb_i2c_dev = gb_connection_get_data(connection);\n\tstruct gb_i2c_transfer_request *request;\n\tstruct gb_operation *operation;\n\tstruct gb_i2c_transfer_op *op;\n\tstruct i2c_msg *msg;\n\tu32 data_out_size = 0;\n\tu32 data_in_size = 0;\n\tsize_t request_size;\n\tvoid *data;\n\tu16 op_count;\n\tu32 i;\n\n\tif (msg_count > (u32)U16_MAX) {\n\t\tdev_err(&gb_i2c_dev->gbphy_dev->dev, \"msg_count (%u) too big\\n\",\n\t\t\tmsg_count);\n\t\treturn NULL;\n\t}\n\top_count = (u16)msg_count;\n\n\t \n\tmsg = msgs;\n\tfor (i = 0; i < msg_count; i++, msg++)\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\tdata_in_size += (u32)msg->len;\n\t\telse\n\t\t\tdata_out_size += (u32)msg->len;\n\n\trequest_size = sizeof(*request);\n\trequest_size += msg_count * sizeof(*op);\n\trequest_size += data_out_size;\n\n\t \n\toperation = gb_operation_create(connection, GB_I2C_TYPE_TRANSFER,\n\t\t\t\t\trequest_size, data_in_size, GFP_KERNEL);\n\tif (!operation)\n\t\treturn NULL;\n\n\trequest = operation->request->payload;\n\trequest->op_count = cpu_to_le16(op_count);\n\t \n\top = &request->ops[0];\n\tmsg = msgs;\n\tfor (i = 0; i < msg_count; i++)\n\t\tgb_i2c_fill_transfer_op(op++, msg++);\n\n\tif (!data_out_size)\n\t\treturn operation;\n\n\t \n\tdata = op;\n\tmsg = msgs;\n\tfor (i = 0; i < msg_count; i++) {\n\t\tif (!(msg->flags & I2C_M_RD)) {\n\t\t\tmemcpy(data, msg->buf, msg->len);\n\t\t\tdata += msg->len;\n\t\t}\n\t\tmsg++;\n\t}\n\n\treturn operation;\n}\n\nstatic void gb_i2c_decode_response(struct i2c_msg *msgs, u32 msg_count,\n\t\t\t\t   struct gb_i2c_transfer_response *response)\n{\n\tstruct i2c_msg *msg = msgs;\n\tu8 *data;\n\tu32 i;\n\n\tif (!response)\n\t\treturn;\n\tdata = response->data;\n\tfor (i = 0; i < msg_count; i++) {\n\t\tif (msg->flags & I2C_M_RD) {\n\t\t\tmemcpy(msg->buf, data, msg->len);\n\t\t\tdata += msg->len;\n\t\t}\n\t\tmsg++;\n\t}\n}\n\n \nstatic bool gb_i2c_expected_transfer_error(int errno)\n{\n\treturn errno == -EAGAIN || errno == -ENODEV;\n}\n\nstatic int gb_i2c_transfer_operation(struct gb_i2c_device *gb_i2c_dev,\n\t\t\t\t     struct i2c_msg *msgs, u32 msg_count)\n{\n\tstruct gb_connection *connection = gb_i2c_dev->connection;\n\tstruct device *dev = &gb_i2c_dev->gbphy_dev->dev;\n\tstruct gb_operation *operation;\n\tint ret;\n\n\toperation = gb_i2c_operation_create(connection, msgs, msg_count);\n\tif (!operation)\n\t\treturn -ENOMEM;\n\n\tret = gbphy_runtime_get_sync(gb_i2c_dev->gbphy_dev);\n\tif (ret)\n\t\tgoto exit_operation_put;\n\n\tret = gb_operation_request_send_sync(operation);\n\tif (!ret) {\n\t\tstruct gb_i2c_transfer_response *response;\n\n\t\tresponse = operation->response->payload;\n\t\tgb_i2c_decode_response(msgs, msg_count, response);\n\t\tret = msg_count;\n\t} else if (!gb_i2c_expected_transfer_error(ret)) {\n\t\tdev_err(dev, \"transfer operation failed (%d)\\n\", ret);\n\t}\n\n\tgbphy_runtime_put_autosuspend(gb_i2c_dev->gbphy_dev);\n\nexit_operation_put:\n\tgb_operation_put(operation);\n\n\treturn ret;\n}\n\nstatic int gb_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t      int msg_count)\n{\n\tstruct gb_i2c_device *gb_i2c_dev;\n\n\tgb_i2c_dev = i2c_get_adapdata(adap);\n\n\treturn gb_i2c_transfer_operation(gb_i2c_dev, msgs, msg_count);\n}\n\nstatic u32 gb_i2c_functionality(struct i2c_adapter *adap)\n{\n\tstruct gb_i2c_device *gb_i2c_dev = i2c_get_adapdata(adap);\n\n\treturn gb_i2c_dev->functionality;\n}\n\nstatic const struct i2c_algorithm gb_i2c_algorithm = {\n\t.master_xfer\t= gb_i2c_master_xfer,\n\t.functionality\t= gb_i2c_functionality,\n};\n\nstatic int gb_i2c_probe(struct gbphy_device *gbphy_dev,\n\t\t\tconst struct gbphy_device_id *id)\n{\n\tstruct gb_connection *connection;\n\tstruct gb_i2c_device *gb_i2c_dev;\n\tstruct i2c_adapter *adapter;\n\tint ret;\n\n\tgb_i2c_dev = kzalloc(sizeof(*gb_i2c_dev), GFP_KERNEL);\n\tif (!gb_i2c_dev)\n\t\treturn -ENOMEM;\n\n\tconnection =\n\t\tgb_connection_create(gbphy_dev->bundle,\n\t\t\t\t     le16_to_cpu(gbphy_dev->cport_desc->id),\n\t\t\t\t     NULL);\n\tif (IS_ERR(connection)) {\n\t\tret = PTR_ERR(connection);\n\t\tgoto exit_i2cdev_free;\n\t}\n\n\tgb_i2c_dev->connection = connection;\n\tgb_connection_set_data(connection, gb_i2c_dev);\n\tgb_i2c_dev->gbphy_dev = gbphy_dev;\n\tgb_gbphy_set_data(gbphy_dev, gb_i2c_dev);\n\n\tret = gb_connection_enable(connection);\n\tif (ret)\n\t\tgoto exit_connection_destroy;\n\n\tret = gb_i2c_device_setup(gb_i2c_dev);\n\tif (ret)\n\t\tgoto exit_connection_disable;\n\n\t \n\tadapter = &gb_i2c_dev->adapter;\n\tadapter->owner = THIS_MODULE;\n\tadapter->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\n\tadapter->algo = &gb_i2c_algorithm;\n\n\tadapter->dev.parent = &gbphy_dev->dev;\n\tsnprintf(adapter->name, sizeof(adapter->name), \"Greybus i2c adapter\");\n\ti2c_set_adapdata(adapter, gb_i2c_dev);\n\n\tret = i2c_add_adapter(adapter);\n\tif (ret)\n\t\tgoto exit_connection_disable;\n\n\tgbphy_runtime_put_autosuspend(gbphy_dev);\n\treturn 0;\n\nexit_connection_disable:\n\tgb_connection_disable(connection);\nexit_connection_destroy:\n\tgb_connection_destroy(connection);\nexit_i2cdev_free:\n\tkfree(gb_i2c_dev);\n\n\treturn ret;\n}\n\nstatic void gb_i2c_remove(struct gbphy_device *gbphy_dev)\n{\n\tstruct gb_i2c_device *gb_i2c_dev = gb_gbphy_get_data(gbphy_dev);\n\tstruct gb_connection *connection = gb_i2c_dev->connection;\n\tint ret;\n\n\tret = gbphy_runtime_get_sync(gbphy_dev);\n\tif (ret)\n\t\tgbphy_runtime_get_noresume(gbphy_dev);\n\n\ti2c_del_adapter(&gb_i2c_dev->adapter);\n\tgb_connection_disable(connection);\n\tgb_connection_destroy(connection);\n\tkfree(gb_i2c_dev);\n}\n\nstatic const struct gbphy_device_id gb_i2c_id_table[] = {\n\t{ GBPHY_PROTOCOL(GREYBUS_PROTOCOL_I2C) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(gbphy, gb_i2c_id_table);\n\nstatic struct gbphy_driver i2c_driver = {\n\t.name\t\t= \"i2c\",\n\t.probe\t\t= gb_i2c_probe,\n\t.remove\t\t= gb_i2c_remove,\n\t.id_table\t= gb_i2c_id_table,\n};\n\nmodule_gbphy_driver(i2c_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}