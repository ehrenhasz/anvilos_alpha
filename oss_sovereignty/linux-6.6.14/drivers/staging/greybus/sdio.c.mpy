{
  "module_name": "sdio.c",
  "hash_id": "a247d506001ad73cc1fd94e9cae10ad89f9bac0bd3bee669b0ca83e3bf6c7174",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/sdio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/mmc/core.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/scatterlist.h>\n#include <linux/workqueue.h>\n#include <linux/greybus.h>\n\n#include \"gbphy.h\"\n\nstruct gb_sdio_host {\n\tstruct gb_connection\t*connection;\n\tstruct gbphy_device\t*gbphy_dev;\n\tstruct mmc_host\t\t*mmc;\n\tstruct mmc_request\t*mrq;\n\tstruct mutex\t\tlock;\t \n\tsize_t\t\t\tdata_max;\n\tspinlock_t\t\txfer;\t \n\tbool\t\t\txfer_stop;\n\tstruct workqueue_struct\t*mrq_workqueue;\n\tstruct work_struct\tmrqwork;\n\tu8\t\t\tqueued_events;\n\tbool\t\t\tremoved;\n\tbool\t\t\tcard_present;\n\tbool\t\t\tread_only;\n};\n\n#define GB_SDIO_RSP_R1_R5_R6_R7\t(GB_SDIO_RSP_PRESENT | GB_SDIO_RSP_CRC | \\\n\t\t\t\t GB_SDIO_RSP_OPCODE)\n#define GB_SDIO_RSP_R3_R4\t(GB_SDIO_RSP_PRESENT)\n#define GB_SDIO_RSP_R2\t\t(GB_SDIO_RSP_PRESENT | GB_SDIO_RSP_CRC | \\\n\t\t\t\t GB_SDIO_RSP_136)\n#define GB_SDIO_RSP_R1B\t\t(GB_SDIO_RSP_PRESENT | GB_SDIO_RSP_CRC | \\\n\t\t\t\t GB_SDIO_RSP_OPCODE | GB_SDIO_RSP_BUSY)\n\n \n#define GB_SDIO_VDD_SHIFT\t8\n\n#ifndef MMC_CAP2_CORE_RUNTIME_PM\n#define MMC_CAP2_CORE_RUNTIME_PM\t0\n#endif\n\nstatic inline bool single_op(struct mmc_command *cmd)\n{\n\tu32 opcode = cmd->opcode;\n\n\treturn opcode == MMC_WRITE_BLOCK ||\n\t       opcode == MMC_READ_SINGLE_BLOCK;\n}\n\nstatic void _gb_sdio_set_host_caps(struct gb_sdio_host *host, u32 r)\n{\n\tu32 caps = 0;\n\tu32 caps2 = 0;\n\n\tcaps = ((r & GB_SDIO_CAP_NONREMOVABLE) ? MMC_CAP_NONREMOVABLE : 0) |\n\t\t((r & GB_SDIO_CAP_4_BIT_DATA) ? MMC_CAP_4_BIT_DATA : 0) |\n\t\t((r & GB_SDIO_CAP_8_BIT_DATA) ? MMC_CAP_8_BIT_DATA : 0) |\n\t\t((r & GB_SDIO_CAP_MMC_HS) ? MMC_CAP_MMC_HIGHSPEED : 0) |\n\t\t((r & GB_SDIO_CAP_SD_HS) ? MMC_CAP_SD_HIGHSPEED : 0) |\n\t\t((r & GB_SDIO_CAP_1_2V_DDR) ? MMC_CAP_1_2V_DDR : 0) |\n\t\t((r & GB_SDIO_CAP_1_8V_DDR) ? MMC_CAP_1_8V_DDR : 0) |\n\t\t((r & GB_SDIO_CAP_POWER_OFF_CARD) ? MMC_CAP_POWER_OFF_CARD : 0) |\n\t\t((r & GB_SDIO_CAP_UHS_SDR12) ? MMC_CAP_UHS_SDR12 : 0) |\n\t\t((r & GB_SDIO_CAP_UHS_SDR25) ? MMC_CAP_UHS_SDR25 : 0) |\n\t\t((r & GB_SDIO_CAP_UHS_SDR50) ? MMC_CAP_UHS_SDR50 : 0) |\n\t\t((r & GB_SDIO_CAP_UHS_SDR104) ? MMC_CAP_UHS_SDR104 : 0) |\n\t\t((r & GB_SDIO_CAP_UHS_DDR50) ? MMC_CAP_UHS_DDR50 : 0) |\n\t\t((r & GB_SDIO_CAP_DRIVER_TYPE_A) ? MMC_CAP_DRIVER_TYPE_A : 0) |\n\t\t((r & GB_SDIO_CAP_DRIVER_TYPE_C) ? MMC_CAP_DRIVER_TYPE_C : 0) |\n\t\t((r & GB_SDIO_CAP_DRIVER_TYPE_D) ? MMC_CAP_DRIVER_TYPE_D : 0);\n\n\tcaps2 = ((r & GB_SDIO_CAP_HS200_1_2V) ? MMC_CAP2_HS200_1_2V_SDR : 0) |\n\t\t((r & GB_SDIO_CAP_HS400_1_2V) ? MMC_CAP2_HS400_1_2V : 0) |\n\t\t((r & GB_SDIO_CAP_HS400_1_8V) ? MMC_CAP2_HS400_1_8V : 0) |\n\t\t((r & GB_SDIO_CAP_HS200_1_8V) ? MMC_CAP2_HS200_1_8V_SDR : 0);\n\n\thost->mmc->caps = caps;\n\thost->mmc->caps2 = caps2 | MMC_CAP2_CORE_RUNTIME_PM;\n\n\tif (caps & MMC_CAP_NONREMOVABLE)\n\t\thost->card_present = true;\n}\n\nstatic u32 _gb_sdio_get_host_ocr(u32 ocr)\n{\n\treturn (((ocr & GB_SDIO_VDD_165_195) ? MMC_VDD_165_195 : 0) |\n\t\t((ocr & GB_SDIO_VDD_20_21) ? MMC_VDD_20_21 : 0) |\n\t\t((ocr & GB_SDIO_VDD_21_22) ? MMC_VDD_21_22 : 0) |\n\t\t((ocr & GB_SDIO_VDD_22_23) ? MMC_VDD_22_23 : 0) |\n\t\t((ocr & GB_SDIO_VDD_23_24) ? MMC_VDD_23_24 : 0) |\n\t\t((ocr & GB_SDIO_VDD_24_25) ? MMC_VDD_24_25 : 0) |\n\t\t((ocr & GB_SDIO_VDD_25_26) ? MMC_VDD_25_26 : 0) |\n\t\t((ocr & GB_SDIO_VDD_26_27) ? MMC_VDD_26_27 : 0) |\n\t\t((ocr & GB_SDIO_VDD_27_28) ? MMC_VDD_27_28 : 0) |\n\t\t((ocr & GB_SDIO_VDD_28_29) ? MMC_VDD_28_29 : 0) |\n\t\t((ocr & GB_SDIO_VDD_29_30) ? MMC_VDD_29_30 : 0) |\n\t\t((ocr & GB_SDIO_VDD_30_31) ? MMC_VDD_30_31 : 0) |\n\t\t((ocr & GB_SDIO_VDD_31_32) ? MMC_VDD_31_32 : 0) |\n\t\t((ocr & GB_SDIO_VDD_32_33) ? MMC_VDD_32_33 : 0) |\n\t\t((ocr & GB_SDIO_VDD_33_34) ? MMC_VDD_33_34 : 0) |\n\t\t((ocr & GB_SDIO_VDD_34_35) ? MMC_VDD_34_35 : 0) |\n\t\t((ocr & GB_SDIO_VDD_35_36) ? MMC_VDD_35_36 : 0)\n\t\t);\n}\n\nstatic int gb_sdio_get_caps(struct gb_sdio_host *host)\n{\n\tstruct gb_sdio_get_caps_response response;\n\tstruct mmc_host *mmc = host->mmc;\n\tu16 data_max;\n\tu32 blksz;\n\tu32 ocr;\n\tu32 r;\n\tint ret;\n\n\tret = gb_operation_sync(host->connection, GB_SDIO_TYPE_GET_CAPABILITIES,\n\t\t\t\tNULL, 0, &response, sizeof(response));\n\tif (ret < 0)\n\t\treturn ret;\n\tr = le32_to_cpu(response.caps);\n\n\t_gb_sdio_set_host_caps(host, r);\n\n\t \n\tdata_max = gb_operation_get_payload_size_max(host->connection);\n\tdata_max = min(data_max - sizeof(struct gb_sdio_transfer_request),\n\t\t       data_max - sizeof(struct gb_sdio_transfer_response));\n\n\tblksz = min_t(u16, le16_to_cpu(response.max_blk_size), data_max);\n\tblksz = max_t(u32, 512, blksz);\n\n\tmmc->max_blk_size = rounddown_pow_of_two(blksz);\n\tmmc->max_blk_count = le16_to_cpu(response.max_blk_count);\n\thost->data_max = data_max;\n\n\t \n\tocr = _gb_sdio_get_host_ocr(le32_to_cpu(response.ocr));\n\tmmc->ocr_avail = ocr;\n\tmmc->ocr_avail_sdio = mmc->ocr_avail;\n\tmmc->ocr_avail_sd = mmc->ocr_avail;\n\tmmc->ocr_avail_mmc = mmc->ocr_avail;\n\n\t \n\tmmc->f_min = le32_to_cpu(response.f_min);\n\tmmc->f_max = le32_to_cpu(response.f_max);\n\n\treturn 0;\n}\n\nstatic void _gb_queue_event(struct gb_sdio_host *host, u8 event)\n{\n\tif (event & GB_SDIO_CARD_INSERTED)\n\t\thost->queued_events &= ~GB_SDIO_CARD_REMOVED;\n\telse if (event & GB_SDIO_CARD_REMOVED)\n\t\thost->queued_events &= ~GB_SDIO_CARD_INSERTED;\n\n\thost->queued_events |= event;\n}\n\nstatic int _gb_sdio_process_events(struct gb_sdio_host *host, u8 event)\n{\n\tu8 state_changed = 0;\n\n\tif (event & GB_SDIO_CARD_INSERTED) {\n\t\tif (host->mmc->caps & MMC_CAP_NONREMOVABLE)\n\t\t\treturn 0;\n\t\tif (host->card_present)\n\t\t\treturn 0;\n\t\thost->card_present = true;\n\t\tstate_changed = 1;\n\t}\n\n\tif (event & GB_SDIO_CARD_REMOVED) {\n\t\tif (host->mmc->caps & MMC_CAP_NONREMOVABLE)\n\t\t\treturn 0;\n\t\tif (!(host->card_present))\n\t\t\treturn 0;\n\t\thost->card_present = false;\n\t\tstate_changed = 1;\n\t}\n\n\tif (event & GB_SDIO_WP)\n\t\thost->read_only = true;\n\n\tif (state_changed) {\n\t\tdev_info(mmc_dev(host->mmc), \"card %s now event\\n\",\n\t\t\t (host->card_present ?  \"inserted\" : \"removed\"));\n\t\tmmc_detect_change(host->mmc, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_sdio_request_handler(struct gb_operation *op)\n{\n\tstruct gb_sdio_host *host = gb_connection_get_data(op->connection);\n\tstruct gb_message *request;\n\tstruct gb_sdio_event_request *payload;\n\tu8 type = op->type;\n\tint ret =  0;\n\tu8 event;\n\n\tif (type != GB_SDIO_TYPE_EVENT) {\n\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\"unsupported unsolicited event: %u\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request;\n\n\tif (request->payload_size < sizeof(*payload)) {\n\t\tdev_err(mmc_dev(host->mmc), \"wrong event size received (%zu < %zu)\\n\",\n\t\t\trequest->payload_size, sizeof(*payload));\n\t\treturn -EINVAL;\n\t}\n\n\tpayload = request->payload;\n\tevent = payload->event;\n\n\tif (host->removed)\n\t\t_gb_queue_event(host, event);\n\telse\n\t\tret = _gb_sdio_process_events(host, event);\n\n\treturn ret;\n}\n\nstatic int gb_sdio_set_ios(struct gb_sdio_host *host,\n\t\t\t   struct gb_sdio_set_ios_request *request)\n{\n\tint ret;\n\n\tret = gbphy_runtime_get_sync(host->gbphy_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_operation_sync(host->connection, GB_SDIO_TYPE_SET_IOS, request,\n\t\t\t\tsizeof(*request), NULL, 0);\n\n\tgbphy_runtime_put_autosuspend(host->gbphy_dev);\n\n\treturn ret;\n}\n\nstatic int _gb_sdio_send(struct gb_sdio_host *host, struct mmc_data *data,\n\t\t\t size_t len, u16 nblocks, off_t skip)\n{\n\tstruct gb_sdio_transfer_request *request;\n\tstruct gb_sdio_transfer_response *response;\n\tstruct gb_operation *operation;\n\tstruct scatterlist *sg = data->sg;\n\tunsigned int sg_len = data->sg_len;\n\tsize_t copied;\n\tu16 send_blksz;\n\tu16 send_blocks;\n\tint ret;\n\n\tWARN_ON(len > host->data_max);\n\n\toperation = gb_operation_create(host->connection, GB_SDIO_TYPE_TRANSFER,\n\t\t\t\t\tlen + sizeof(*request),\n\t\t\t\t\tsizeof(*response), GFP_KERNEL);\n\tif (!operation)\n\t\treturn -ENOMEM;\n\n\trequest = operation->request->payload;\n\trequest->data_flags = data->flags >> 8;\n\trequest->data_blocks = cpu_to_le16(nblocks);\n\trequest->data_blksz = cpu_to_le16(data->blksz);\n\n\tcopied = sg_pcopy_to_buffer(sg, sg_len, &request->data[0], len, skip);\n\n\tif (copied != len) {\n\t\tret = -EINVAL;\n\t\tgoto err_put_operation;\n\t}\n\n\tret = gb_operation_request_send_sync(operation);\n\tif (ret < 0)\n\t\tgoto err_put_operation;\n\n\tresponse = operation->response->payload;\n\n\tsend_blocks = le16_to_cpu(response->data_blocks);\n\tsend_blksz = le16_to_cpu(response->data_blksz);\n\n\tif (len != send_blksz * send_blocks) {\n\t\tdev_err(mmc_dev(host->mmc), \"send: size received: %zu != %d\\n\",\n\t\t\tlen, send_blksz * send_blocks);\n\t\tret = -EINVAL;\n\t}\n\nerr_put_operation:\n\tgb_operation_put(operation);\n\n\treturn ret;\n}\n\nstatic int _gb_sdio_recv(struct gb_sdio_host *host, struct mmc_data *data,\n\t\t\t size_t len, u16 nblocks, off_t skip)\n{\n\tstruct gb_sdio_transfer_request *request;\n\tstruct gb_sdio_transfer_response *response;\n\tstruct gb_operation *operation;\n\tstruct scatterlist *sg = data->sg;\n\tunsigned int sg_len = data->sg_len;\n\tsize_t copied;\n\tu16 recv_blksz;\n\tu16 recv_blocks;\n\tint ret;\n\n\tWARN_ON(len > host->data_max);\n\n\toperation = gb_operation_create(host->connection, GB_SDIO_TYPE_TRANSFER,\n\t\t\t\t\tsizeof(*request),\n\t\t\t\t\tlen + sizeof(*response), GFP_KERNEL);\n\tif (!operation)\n\t\treturn -ENOMEM;\n\n\trequest = operation->request->payload;\n\trequest->data_flags = data->flags >> 8;\n\trequest->data_blocks = cpu_to_le16(nblocks);\n\trequest->data_blksz = cpu_to_le16(data->blksz);\n\n\tret = gb_operation_request_send_sync(operation);\n\tif (ret < 0)\n\t\tgoto err_put_operation;\n\n\tresponse = operation->response->payload;\n\trecv_blocks = le16_to_cpu(response->data_blocks);\n\trecv_blksz = le16_to_cpu(response->data_blksz);\n\n\tif (len != recv_blksz * recv_blocks) {\n\t\tdev_err(mmc_dev(host->mmc), \"recv: size received: %d != %zu\\n\",\n\t\t\trecv_blksz * recv_blocks, len);\n\t\tret = -EINVAL;\n\t\tgoto err_put_operation;\n\t}\n\n\tcopied = sg_pcopy_from_buffer(sg, sg_len, &response->data[0], len,\n\t\t\t\t      skip);\n\tif (copied != len)\n\t\tret = -EINVAL;\n\nerr_put_operation:\n\tgb_operation_put(operation);\n\n\treturn ret;\n}\n\nstatic int gb_sdio_transfer(struct gb_sdio_host *host, struct mmc_data *data)\n{\n\tsize_t left, len;\n\toff_t skip = 0;\n\tint ret = 0;\n\tu16 nblocks;\n\n\tif (single_op(data->mrq->cmd) && data->blocks > 1) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tleft = data->blksz * data->blocks;\n\n\twhile (left) {\n\t\t \n\t\tspin_lock(&host->xfer);\n\t\tif (host->xfer_stop) {\n\t\t\thost->xfer_stop = false;\n\t\t\tspin_unlock(&host->xfer);\n\t\t\tret = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&host->xfer);\n\t\tlen = min(left, host->data_max);\n\t\tnblocks = len / data->blksz;\n\t\tlen = nblocks * data->blksz;\n\n\t\tif (data->flags & MMC_DATA_READ) {\n\t\t\tret = _gb_sdio_recv(host, data, len, nblocks, skip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tret = _gb_sdio_send(host, data, len, nblocks, skip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdata->bytes_xfered += len;\n\t\tleft -= len;\n\t\tskip += len;\n\t}\n\nout:\n\tdata->error = ret;\n\treturn ret;\n}\n\nstatic int gb_sdio_command(struct gb_sdio_host *host, struct mmc_command *cmd)\n{\n\tstruct gb_sdio_command_request request = {0};\n\tstruct gb_sdio_command_response response;\n\tstruct mmc_data *data = host->mrq->data;\n\tunsigned int timeout_ms;\n\tu8 cmd_flags;\n\tu8 cmd_type;\n\tint i;\n\tint ret;\n\n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_NONE:\n\t\tcmd_flags = GB_SDIO_RSP_NONE;\n\t\tbreak;\n\tcase MMC_RSP_R1:\n\t\tcmd_flags = GB_SDIO_RSP_R1_R5_R6_R7;\n\t\tbreak;\n\tcase MMC_RSP_R1B:\n\t\tcmd_flags = GB_SDIO_RSP_R1B;\n\t\tbreak;\n\tcase MMC_RSP_R2:\n\t\tcmd_flags = GB_SDIO_RSP_R2;\n\t\tbreak;\n\tcase MMC_RSP_R3:\n\t\tcmd_flags = GB_SDIO_RSP_R3_R4;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mmc_dev(host->mmc), \"cmd flag invalid 0x%04x\\n\",\n\t\t\tmmc_resp_type(cmd));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (mmc_cmd_type(cmd)) {\n\tcase MMC_CMD_BC:\n\t\tcmd_type = GB_SDIO_CMD_BC;\n\t\tbreak;\n\tcase MMC_CMD_BCR:\n\t\tcmd_type = GB_SDIO_CMD_BCR;\n\t\tbreak;\n\tcase MMC_CMD_AC:\n\t\tcmd_type = GB_SDIO_CMD_AC;\n\t\tbreak;\n\tcase MMC_CMD_ADTC:\n\t\tcmd_type = GB_SDIO_CMD_ADTC;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mmc_dev(host->mmc), \"cmd type invalid 0x%04x\\n\",\n\t\t\tmmc_cmd_type(cmd));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trequest.cmd = cmd->opcode;\n\trequest.cmd_flags = cmd_flags;\n\trequest.cmd_type = cmd_type;\n\trequest.cmd_arg = cpu_to_le32(cmd->arg);\n\t \n\tif (data) {\n\t\trequest.data_blocks = cpu_to_le16(data->blocks);\n\t\trequest.data_blksz = cpu_to_le16(data->blksz);\n\t}\n\n\ttimeout_ms = cmd->busy_timeout ? cmd->busy_timeout :\n\t\tGB_OPERATION_TIMEOUT_DEFAULT;\n\n\tret = gb_operation_sync_timeout(host->connection, GB_SDIO_TYPE_COMMAND,\n\t\t\t\t\t&request, sizeof(request), &response,\n\t\t\t\t\tsizeof(response), timeout_ms);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (cmd_flags == GB_SDIO_RSP_NONE)\n\t\tgoto out;\n\n\t \n\tif (cmd_flags & GB_SDIO_RSP_R2)\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tcmd->resp[i] = le32_to_cpu(response.resp[i]);\n\telse\n\t\tcmd->resp[0] = le32_to_cpu(response.resp[0]);\n\nout:\n\tcmd->error = ret;\n\treturn ret;\n}\n\nstatic void gb_sdio_mrq_work(struct work_struct *work)\n{\n\tstruct gb_sdio_host *host;\n\tstruct mmc_request *mrq;\n\tint ret;\n\n\thost = container_of(work, struct gb_sdio_host, mrqwork);\n\n\tret = gbphy_runtime_get_sync(host->gbphy_dev);\n\tif (ret)\n\t\treturn;\n\n\tmutex_lock(&host->lock);\n\tmrq = host->mrq;\n\tif (!mrq) {\n\t\tmutex_unlock(&host->lock);\n\t\tgbphy_runtime_put_autosuspend(host->gbphy_dev);\n\t\tdev_err(mmc_dev(host->mmc), \"mmc request is NULL\");\n\t\treturn;\n\t}\n\n\tif (host->removed) {\n\t\tmrq->cmd->error = -ESHUTDOWN;\n\t\tgoto done;\n\t}\n\n\tif (mrq->sbc) {\n\t\tret = gb_sdio_command(host, mrq->sbc);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tret = gb_sdio_command(host, mrq->cmd);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tif (mrq->data) {\n\t\tret = gb_sdio_transfer(host, mrq->data);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (mrq->stop) {\n\t\tret = gb_sdio_command(host, mrq->stop);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\ndone:\n\thost->mrq = NULL;\n\tmutex_unlock(&host->lock);\n\tmmc_request_done(host->mmc, mrq);\n\tgbphy_runtime_put_autosuspend(host->gbphy_dev);\n}\n\nstatic void gb_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct gb_sdio_host *host = mmc_priv(mmc);\n\tstruct mmc_command *cmd = mrq->cmd;\n\n\t \n\tif (cmd->opcode == MMC_STOP_TRANSMISSION) {\n\t\tspin_lock(&host->xfer);\n\t\thost->xfer_stop = true;\n\t\tspin_unlock(&host->xfer);\n\t}\n\n\tmutex_lock(&host->lock);\n\n\tWARN_ON(host->mrq);\n\thost->mrq = mrq;\n\n\tif (host->removed) {\n\t\tmrq->cmd->error = -ESHUTDOWN;\n\t\tgoto out;\n\t}\n\tif (!host->card_present) {\n\t\tmrq->cmd->error = -ENOMEDIUM;\n\t\tgoto out;\n\t}\n\n\tqueue_work(host->mrq_workqueue, &host->mrqwork);\n\n\tmutex_unlock(&host->lock);\n\treturn;\n\nout:\n\thost->mrq = NULL;\n\tmutex_unlock(&host->lock);\n\tmmc_request_done(mmc, mrq);\n}\n\nstatic void gb_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct gb_sdio_host *host = mmc_priv(mmc);\n\tstruct gb_sdio_set_ios_request request;\n\tint ret;\n\tu8 power_mode;\n\tu8 bus_width;\n\tu8 timing;\n\tu8 signal_voltage;\n\tu8 drv_type;\n\tu32 vdd = 0;\n\n\tmutex_lock(&host->lock);\n\trequest.clock = cpu_to_le32(ios->clock);\n\n\tif (ios->vdd)\n\t\tvdd = 1 << (ios->vdd - GB_SDIO_VDD_SHIFT);\n\trequest.vdd = cpu_to_le32(vdd);\n\n\trequest.bus_mode = ios->bus_mode == MMC_BUSMODE_OPENDRAIN ?\n\t\t\t    GB_SDIO_BUSMODE_OPENDRAIN :\n\t\t\t    GB_SDIO_BUSMODE_PUSHPULL;\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_OFF:\n\tdefault:\n\t\tpower_mode = GB_SDIO_POWER_OFF;\n\t\tbreak;\n\tcase MMC_POWER_UP:\n\t\tpower_mode = GB_SDIO_POWER_UP;\n\t\tbreak;\n\tcase MMC_POWER_ON:\n\t\tpower_mode = GB_SDIO_POWER_ON;\n\t\tbreak;\n\tcase MMC_POWER_UNDEFINED:\n\t\tpower_mode = GB_SDIO_POWER_UNDEFINED;\n\t\tbreak;\n\t}\n\trequest.power_mode = power_mode;\n\n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_1:\n\t\tbus_width = GB_SDIO_BUS_WIDTH_1;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\tdefault:\n\t\tbus_width = GB_SDIO_BUS_WIDTH_4;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_8:\n\t\tbus_width = GB_SDIO_BUS_WIDTH_8;\n\t\tbreak;\n\t}\n\trequest.bus_width = bus_width;\n\n\tswitch (ios->timing) {\n\tcase MMC_TIMING_LEGACY:\n\tdefault:\n\t\ttiming = GB_SDIO_TIMING_LEGACY;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS:\n\t\ttiming = GB_SDIO_TIMING_MMC_HS;\n\t\tbreak;\n\tcase MMC_TIMING_SD_HS:\n\t\ttiming = GB_SDIO_TIMING_SD_HS;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR12:\n\t\ttiming = GB_SDIO_TIMING_UHS_SDR12;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR25:\n\t\ttiming = GB_SDIO_TIMING_UHS_SDR25;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR50:\n\t\ttiming = GB_SDIO_TIMING_UHS_SDR50;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR104:\n\t\ttiming = GB_SDIO_TIMING_UHS_SDR104;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_DDR50:\n\t\ttiming = GB_SDIO_TIMING_UHS_DDR50;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_DDR52:\n\t\ttiming = GB_SDIO_TIMING_MMC_DDR52;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS200:\n\t\ttiming = GB_SDIO_TIMING_MMC_HS200;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS400:\n\t\ttiming = GB_SDIO_TIMING_MMC_HS400;\n\t\tbreak;\n\t}\n\trequest.timing = timing;\n\n\tswitch (ios->signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\t\tsignal_voltage = GB_SDIO_SIGNAL_VOLTAGE_330;\n\t\tbreak;\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\tdefault:\n\t\tsignal_voltage = GB_SDIO_SIGNAL_VOLTAGE_180;\n\t\tbreak;\n\tcase MMC_SIGNAL_VOLTAGE_120:\n\t\tsignal_voltage = GB_SDIO_SIGNAL_VOLTAGE_120;\n\t\tbreak;\n\t}\n\trequest.signal_voltage = signal_voltage;\n\n\tswitch (ios->drv_type) {\n\tcase MMC_SET_DRIVER_TYPE_A:\n\t\tdrv_type = GB_SDIO_SET_DRIVER_TYPE_A;\n\t\tbreak;\n\tcase MMC_SET_DRIVER_TYPE_C:\n\t\tdrv_type = GB_SDIO_SET_DRIVER_TYPE_C;\n\t\tbreak;\n\tcase MMC_SET_DRIVER_TYPE_D:\n\t\tdrv_type = GB_SDIO_SET_DRIVER_TYPE_D;\n\t\tbreak;\n\tcase MMC_SET_DRIVER_TYPE_B:\n\tdefault:\n\t\tdrv_type = GB_SDIO_SET_DRIVER_TYPE_B;\n\t\tbreak;\n\t}\n\trequest.drv_type = drv_type;\n\n\tret = gb_sdio_set_ios(host, &request);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmemcpy(&mmc->ios, ios, sizeof(mmc->ios));\n\nout:\n\tmutex_unlock(&host->lock);\n}\n\nstatic int gb_mmc_get_ro(struct mmc_host *mmc)\n{\n\tstruct gb_sdio_host *host = mmc_priv(mmc);\n\n\tmutex_lock(&host->lock);\n\tif (host->removed) {\n\t\tmutex_unlock(&host->lock);\n\t\treturn -ESHUTDOWN;\n\t}\n\tmutex_unlock(&host->lock);\n\n\treturn host->read_only;\n}\n\nstatic int gb_mmc_get_cd(struct mmc_host *mmc)\n{\n\tstruct gb_sdio_host *host = mmc_priv(mmc);\n\n\tmutex_lock(&host->lock);\n\tif (host->removed) {\n\t\tmutex_unlock(&host->lock);\n\t\treturn -ESHUTDOWN;\n\t}\n\tmutex_unlock(&host->lock);\n\n\treturn host->card_present;\n}\n\nstatic int gb_mmc_switch_voltage(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\treturn 0;\n}\n\nstatic const struct mmc_host_ops gb_sdio_ops = {\n\t.request\t= gb_mmc_request,\n\t.set_ios\t= gb_mmc_set_ios,\n\t.get_ro\t\t= gb_mmc_get_ro,\n\t.get_cd\t\t= gb_mmc_get_cd,\n\t.start_signal_voltage_switch\t= gb_mmc_switch_voltage,\n};\n\nstatic int gb_sdio_probe(struct gbphy_device *gbphy_dev,\n\t\t\t const struct gbphy_device_id *id)\n{\n\tstruct gb_connection *connection;\n\tstruct mmc_host *mmc;\n\tstruct gb_sdio_host *host;\n\tint ret = 0;\n\n\tmmc = mmc_alloc_host(sizeof(*host), &gbphy_dev->dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\tconnection = gb_connection_create(gbphy_dev->bundle,\n\t\t\t\t\t  le16_to_cpu(gbphy_dev->cport_desc->id),\n\t\t\t\t\t  gb_sdio_request_handler);\n\tif (IS_ERR(connection)) {\n\t\tret = PTR_ERR(connection);\n\t\tgoto exit_mmc_free;\n\t}\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\thost->removed = true;\n\n\thost->connection = connection;\n\tgb_connection_set_data(connection, host);\n\thost->gbphy_dev = gbphy_dev;\n\tgb_gbphy_set_data(gbphy_dev, host);\n\n\tret = gb_connection_enable_tx(connection);\n\tif (ret)\n\t\tgoto exit_connection_destroy;\n\n\tret = gb_sdio_get_caps(host);\n\tif (ret < 0)\n\t\tgoto exit_connection_disable;\n\n\tmmc->ops = &gb_sdio_ops;\n\n\tmmc->max_segs = host->mmc->max_blk_count;\n\n\t \n\tmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\n\tmmc->max_seg_size = mmc->max_req_size;\n\n\tmutex_init(&host->lock);\n\tspin_lock_init(&host->xfer);\n\thost->mrq_workqueue = alloc_workqueue(\"mmc-%s\", 0, 1,\n\t\t\t\t\t      dev_name(&gbphy_dev->dev));\n\tif (!host->mrq_workqueue) {\n\t\tret = -ENOMEM;\n\t\tgoto exit_connection_disable;\n\t}\n\tINIT_WORK(&host->mrqwork, gb_sdio_mrq_work);\n\n\tret = gb_connection_enable(connection);\n\tif (ret)\n\t\tgoto exit_wq_destroy;\n\n\tret = mmc_add_host(mmc);\n\tif (ret < 0)\n\t\tgoto exit_wq_destroy;\n\thost->removed = false;\n\tret = _gb_sdio_process_events(host, host->queued_events);\n\thost->queued_events = 0;\n\n\tgbphy_runtime_put_autosuspend(gbphy_dev);\n\n\treturn ret;\n\nexit_wq_destroy:\n\tdestroy_workqueue(host->mrq_workqueue);\nexit_connection_disable:\n\tgb_connection_disable(connection);\nexit_connection_destroy:\n\tgb_connection_destroy(connection);\nexit_mmc_free:\n\tmmc_free_host(mmc);\n\n\treturn ret;\n}\n\nstatic void gb_sdio_remove(struct gbphy_device *gbphy_dev)\n{\n\tstruct gb_sdio_host *host = gb_gbphy_get_data(gbphy_dev);\n\tstruct gb_connection *connection = host->connection;\n\tstruct mmc_host *mmc;\n\tint ret;\n\n\tret = gbphy_runtime_get_sync(gbphy_dev);\n\tif (ret)\n\t\tgbphy_runtime_get_noresume(gbphy_dev);\n\n\tmutex_lock(&host->lock);\n\thost->removed = true;\n\tmmc = host->mmc;\n\tgb_connection_set_data(connection, NULL);\n\tmutex_unlock(&host->lock);\n\n\tdestroy_workqueue(host->mrq_workqueue);\n\tgb_connection_disable_rx(connection);\n\tmmc_remove_host(mmc);\n\tgb_connection_disable(connection);\n\tgb_connection_destroy(connection);\n\tmmc_free_host(mmc);\n}\n\nstatic const struct gbphy_device_id gb_sdio_id_table[] = {\n\t{ GBPHY_PROTOCOL(GREYBUS_PROTOCOL_SDIO) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(gbphy, gb_sdio_id_table);\n\nstatic struct gbphy_driver sdio_driver = {\n\t.name\t\t= \"sdio\",\n\t.probe\t\t= gb_sdio_probe,\n\t.remove\t\t= gb_sdio_remove,\n\t.id_table\t= gb_sdio_id_table,\n};\n\nmodule_gbphy_driver(sdio_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}