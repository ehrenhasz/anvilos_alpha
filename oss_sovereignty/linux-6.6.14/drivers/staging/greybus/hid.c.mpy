{
  "module_name": "hid.c",
  "hash_id": "48f73da2c7ca75d974167aa3ae1e8b8828aa8572f5fae2b77d066639f35de520",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/hid.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/hid.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/greybus.h>\n\n \nstruct gb_hid {\n\tstruct gb_bundle *bundle;\n\tstruct gb_connection\t\t*connection;\n\n\tstruct hid_device\t\t*hid;\n\tstruct gb_hid_desc_response\thdesc;\n\n\tunsigned long\t\t\tflags;\n#define GB_HID_STARTED\t\t\t0x01\n#define GB_HID_READ_PENDING\t\t0x04\n\n\tunsigned int\t\t\tbufsize;\n\tchar\t\t\t\t*inbuf;\n};\n\n \n\n \nstatic int gb_hid_get_desc(struct gb_hid *ghid)\n{\n\treturn gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_DESC, NULL,\n\t\t\t\t 0, &ghid->hdesc, sizeof(ghid->hdesc));\n}\n\nstatic int gb_hid_get_report_desc(struct gb_hid *ghid, char *rdesc)\n{\n\tint ret;\n\n\tret = gb_pm_runtime_get_sync(ghid->bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT_DESC,\n\t\t\t\tNULL, 0, rdesc,\n\t\t\t\tle16_to_cpu(ghid->hdesc.wReportDescLength));\n\n\tgb_pm_runtime_put_autosuspend(ghid->bundle);\n\n\treturn ret;\n}\n\nstatic int gb_hid_set_power(struct gb_hid *ghid, int type)\n{\n\tint ret;\n\n\tret = gb_pm_runtime_get_sync(ghid->bundle);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_operation_sync(ghid->connection, type, NULL, 0, NULL, 0);\n\n\tgb_pm_runtime_put_autosuspend(ghid->bundle);\n\n\treturn ret;\n}\n\nstatic int gb_hid_get_report(struct gb_hid *ghid, u8 report_type, u8 report_id,\n\t\t\t     unsigned char *buf, int len)\n{\n\tstruct gb_hid_get_report_request request;\n\tint ret;\n\n\tret = gb_pm_runtime_get_sync(ghid->bundle);\n\tif (ret)\n\t\treturn ret;\n\n\trequest.report_type = report_type;\n\trequest.report_id = report_id;\n\n\tret = gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT,\n\t\t\t\t&request, sizeof(request), buf, len);\n\n\tgb_pm_runtime_put_autosuspend(ghid->bundle);\n\n\treturn ret;\n}\n\nstatic int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,\n\t\t\t     unsigned char *buf, int len)\n{\n\tstruct gb_hid_set_report_request *request;\n\tstruct gb_operation *operation;\n\tint ret, size = sizeof(*request) + len - 1;\n\n\tret = gb_pm_runtime_get_sync(ghid->bundle);\n\tif (ret)\n\t\treturn ret;\n\n\toperation = gb_operation_create(ghid->connection,\n\t\t\t\t\tGB_HID_TYPE_SET_REPORT, size, 0,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!operation) {\n\t\tgb_pm_runtime_put_autosuspend(ghid->bundle);\n\t\treturn -ENOMEM;\n\t}\n\n\trequest = operation->request->payload;\n\trequest->report_type = report_type;\n\trequest->report_id = report_id;\n\tmemcpy(request->report, buf, len);\n\n\tret = gb_operation_request_send_sync(operation);\n\tif (ret) {\n\t\tdev_err(&operation->connection->bundle->dev,\n\t\t\t\"failed to set report: %d\\n\", ret);\n\t} else {\n\t\tret = len;\n\t}\n\n\tgb_operation_put(operation);\n\tgb_pm_runtime_put_autosuspend(ghid->bundle);\n\n\treturn ret;\n}\n\nstatic int gb_hid_request_handler(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct gb_hid *ghid = gb_connection_get_data(connection);\n\tstruct gb_hid_input_report_request *request = op->request->payload;\n\n\tif (op->type != GB_HID_TYPE_IRQ_EVENT) {\n\t\tdev_err(&connection->bundle->dev,\n\t\t\t\"unsupported unsolicited request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_bit(GB_HID_STARTED, &ghid->flags))\n\t\thid_input_report(ghid->hid, HID_INPUT_REPORT,\n\t\t\t\t request->report, op->request->payload_size, 1);\n\n\treturn 0;\n}\n\nstatic int gb_hid_report_len(struct hid_report *report)\n{\n\treturn ((report->size - 1) >> 3) + 1 +\n\t\treport->device->report_enum[report->type].numbered;\n}\n\nstatic void gb_hid_find_max_report(struct hid_device *hid, unsigned int type,\n\t\t\t\t   unsigned int *max)\n{\n\tstruct hid_report *report;\n\tunsigned int size;\n\n\tlist_for_each_entry(report, &hid->report_enum[type].report_list, list) {\n\t\tsize = gb_hid_report_len(report);\n\t\tif (*max < size)\n\t\t\t*max = size;\n\t}\n}\n\nstatic void gb_hid_free_buffers(struct gb_hid *ghid)\n{\n\tkfree(ghid->inbuf);\n\tghid->inbuf = NULL;\n\tghid->bufsize = 0;\n}\n\nstatic int gb_hid_alloc_buffers(struct gb_hid *ghid, size_t bufsize)\n{\n\tghid->inbuf = kzalloc(bufsize, GFP_KERNEL);\n\tif (!ghid->inbuf)\n\t\treturn -ENOMEM;\n\n\tghid->bufsize = bufsize;\n\n\treturn 0;\n}\n\n \nstatic void gb_hid_init_report(struct gb_hid *ghid, struct hid_report *report)\n{\n\tunsigned int size;\n\n\tsize = gb_hid_report_len(report);\n\tif (gb_hid_get_report(ghid, report->type, report->id, ghid->inbuf,\n\t\t\t      size))\n\t\treturn;\n\n\t \n\thid_report_raw_event(ghid->hid, report->type, ghid->inbuf, size, 1);\n}\n\nstatic void gb_hid_init_reports(struct gb_hid *ghid)\n{\n\tstruct hid_device *hid = ghid->hid;\n\tstruct hid_report *report;\n\n\tlist_for_each_entry(report,\n\t\t\t    &hid->report_enum[HID_INPUT_REPORT].report_list,\n\t\t\t    list)\n\t\tgb_hid_init_report(ghid, report);\n\n\tlist_for_each_entry(report,\n\t\t\t    &hid->report_enum[HID_FEATURE_REPORT].report_list,\n\t\t\t    list)\n\t\tgb_hid_init_report(ghid, report);\n}\n\nstatic int __gb_hid_get_raw_report(struct hid_device *hid,\n\t\t\t\t   unsigned char report_number, __u8 *buf, size_t count,\n\t\t\t\t   unsigned char report_type)\n{\n\tstruct gb_hid *ghid = hid->driver_data;\n\tint ret;\n\n\tif (report_type == HID_OUTPUT_REPORT)\n\t\treturn -EINVAL;\n\n\tret = gb_hid_get_report(ghid, report_type, report_number, buf, count);\n\tif (!ret)\n\t\tret = count;\n\n\treturn ret;\n}\n\nstatic int __gb_hid_output_raw_report(struct hid_device *hid, __u8 *buf,\n\t\t\t\t      size_t len, unsigned char report_type)\n{\n\tstruct gb_hid *ghid = hid->driver_data;\n\tint report_id = buf[0];\n\tint ret;\n\n\tif (report_type == HID_INPUT_REPORT)\n\t\treturn -EINVAL;\n\n\tif (report_id) {\n\t\tbuf++;\n\t\tlen--;\n\t}\n\n\tret = gb_hid_set_report(ghid, report_type, report_id, buf, len);\n\tif (report_id && ret >= 0)\n\t\tret++;  \n\n\treturn 0;\n}\n\nstatic int gb_hid_raw_request(struct hid_device *hid, unsigned char reportnum,\n\t\t\t      __u8 *buf, size_t len, unsigned char rtype,\n\t\t\t      int reqtype)\n{\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\t\treturn __gb_hid_get_raw_report(hid, reportnum, buf, len, rtype);\n\tcase HID_REQ_SET_REPORT:\n\t\tif (buf[0] != reportnum)\n\t\t\treturn -EINVAL;\n\t\treturn __gb_hid_output_raw_report(hid, buf, len, rtype);\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\n \nstatic int gb_hid_parse(struct hid_device *hid)\n{\n\tstruct gb_hid *ghid = hid->driver_data;\n\tunsigned int rsize;\n\tchar *rdesc;\n\tint ret;\n\n\trsize = le16_to_cpu(ghid->hdesc.wReportDescLength);\n\tif (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {\n\t\tdbg_hid(\"weird size of report descriptor (%u)\\n\", rsize);\n\t\treturn -EINVAL;\n\t}\n\n\trdesc = kzalloc(rsize, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\n\tret = gb_hid_get_report_desc(ghid, rdesc);\n\tif (ret) {\n\t\thid_err(hid, \"reading report descriptor failed\\n\");\n\t\tgoto free_rdesc;\n\t}\n\n\tret = hid_parse_report(hid, rdesc, rsize);\n\tif (ret)\n\t\tdbg_hid(\"parsing report descriptor failed\\n\");\n\nfree_rdesc:\n\tkfree(rdesc);\n\n\treturn ret;\n}\n\nstatic int gb_hid_start(struct hid_device *hid)\n{\n\tstruct gb_hid *ghid = hid->driver_data;\n\tunsigned int bufsize = HID_MIN_BUFFER_SIZE;\n\tint ret;\n\n\tgb_hid_find_max_report(hid, HID_INPUT_REPORT, &bufsize);\n\tgb_hid_find_max_report(hid, HID_OUTPUT_REPORT, &bufsize);\n\tgb_hid_find_max_report(hid, HID_FEATURE_REPORT, &bufsize);\n\n\tif (bufsize > HID_MAX_BUFFER_SIZE)\n\t\tbufsize = HID_MAX_BUFFER_SIZE;\n\n\tret = gb_hid_alloc_buffers(ghid, bufsize);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(hid->quirks & HID_QUIRK_NO_INIT_REPORTS))\n\t\tgb_hid_init_reports(ghid);\n\n\treturn 0;\n}\n\nstatic void gb_hid_stop(struct hid_device *hid)\n{\n\tstruct gb_hid *ghid = hid->driver_data;\n\n\tgb_hid_free_buffers(ghid);\n}\n\nstatic int gb_hid_open(struct hid_device *hid)\n{\n\tstruct gb_hid *ghid = hid->driver_data;\n\tint ret;\n\n\tret = gb_hid_set_power(ghid, GB_HID_TYPE_PWR_ON);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tset_bit(GB_HID_STARTED, &ghid->flags);\n\treturn 0;\n}\n\nstatic void gb_hid_close(struct hid_device *hid)\n{\n\tstruct gb_hid *ghid = hid->driver_data;\n\tint ret;\n\n\tclear_bit(GB_HID_STARTED, &ghid->flags);\n\n\t \n\tret = gb_hid_set_power(ghid, GB_HID_TYPE_PWR_OFF);\n\tif (ret)\n\t\tdev_err(&ghid->connection->bundle->dev,\n\t\t\t\"failed to power off (%d)\\n\", ret);\n}\n\nstatic int gb_hid_power(struct hid_device *hid, int lvl)\n{\n\tstruct gb_hid *ghid = hid->driver_data;\n\n\tswitch (lvl) {\n\tcase PM_HINT_FULLON:\n\t\treturn gb_hid_set_power(ghid, GB_HID_TYPE_PWR_ON);\n\tcase PM_HINT_NORMAL:\n\t\treturn gb_hid_set_power(ghid, GB_HID_TYPE_PWR_OFF);\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct hid_ll_driver gb_hid_ll_driver = {\n\t.parse = gb_hid_parse,\n\t.start = gb_hid_start,\n\t.stop = gb_hid_stop,\n\t.open = gb_hid_open,\n\t.close = gb_hid_close,\n\t.power = gb_hid_power,\n\t.raw_request = gb_hid_raw_request,\n};\n\nstatic int gb_hid_init(struct gb_hid *ghid)\n{\n\tstruct hid_device *hid = ghid->hid;\n\tint ret;\n\n\tret = gb_hid_get_desc(ghid);\n\tif (ret)\n\t\treturn ret;\n\n\thid->version = le16_to_cpu(ghid->hdesc.bcdHID);\n\thid->vendor = le16_to_cpu(ghid->hdesc.wVendorID);\n\thid->product = le16_to_cpu(ghid->hdesc.wProductID);\n\thid->country = ghid->hdesc.bCountryCode;\n\n\thid->driver_data = ghid;\n\thid->ll_driver = &gb_hid_ll_driver;\n\thid->dev.parent = &ghid->connection->bundle->dev;\n\n\n\t \n\tsnprintf(hid->name, sizeof(hid->name), \"%s %04X:%04X\",\n\t\t dev_name(&ghid->connection->bundle->dev),\n\t\t hid->vendor, hid->product);\n\n\treturn 0;\n}\n\nstatic int gb_hid_probe(struct gb_bundle *bundle,\n\t\t\tconst struct greybus_bundle_id *id)\n{\n\tstruct greybus_descriptor_cport *cport_desc;\n\tstruct gb_connection *connection;\n\tstruct hid_device *hid;\n\tstruct gb_hid *ghid;\n\tint ret;\n\n\tif (bundle->num_cports != 1)\n\t\treturn -ENODEV;\n\n\tcport_desc = &bundle->cport_desc[0];\n\tif (cport_desc->protocol_id != GREYBUS_PROTOCOL_HID)\n\t\treturn -ENODEV;\n\n\tghid = kzalloc(sizeof(*ghid), GFP_KERNEL);\n\tif (!ghid)\n\t\treturn -ENOMEM;\n\n\tconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\n\t\t\t\t\t  gb_hid_request_handler);\n\tif (IS_ERR(connection)) {\n\t\tret = PTR_ERR(connection);\n\t\tgoto err_free_ghid;\n\t}\n\n\tgb_connection_set_data(connection, ghid);\n\tghid->connection = connection;\n\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid)) {\n\t\tret = PTR_ERR(hid);\n\t\tgoto err_connection_destroy;\n\t}\n\n\tghid->hid = hid;\n\tghid->bundle = bundle;\n\n\tgreybus_set_drvdata(bundle, ghid);\n\n\tret = gb_connection_enable(connection);\n\tif (ret)\n\t\tgoto err_destroy_hid;\n\n\tret = gb_hid_init(ghid);\n\tif (ret)\n\t\tgoto err_connection_disable;\n\n\tret = hid_add_device(hid);\n\tif (ret) {\n\t\thid_err(hid, \"can't add hid device: %d\\n\", ret);\n\t\tgoto err_connection_disable;\n\t}\n\n\tgb_pm_runtime_put_autosuspend(bundle);\n\n\treturn 0;\n\nerr_connection_disable:\n\tgb_connection_disable(connection);\nerr_destroy_hid:\n\thid_destroy_device(hid);\nerr_connection_destroy:\n\tgb_connection_destroy(connection);\nerr_free_ghid:\n\tkfree(ghid);\n\n\treturn ret;\n}\n\nstatic void gb_hid_disconnect(struct gb_bundle *bundle)\n{\n\tstruct gb_hid *ghid = greybus_get_drvdata(bundle);\n\n\tif (gb_pm_runtime_get_sync(bundle))\n\t\tgb_pm_runtime_get_noresume(bundle);\n\n\thid_destroy_device(ghid->hid);\n\tgb_connection_disable(ghid->connection);\n\tgb_connection_destroy(ghid->connection);\n\tkfree(ghid);\n}\n\nstatic const struct greybus_bundle_id gb_hid_id_table[] = {\n\t{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_HID) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(greybus, gb_hid_id_table);\n\nstatic struct greybus_driver gb_hid_driver = {\n\t.name\t\t= \"hid\",\n\t.probe\t\t= gb_hid_probe,\n\t.disconnect\t= gb_hid_disconnect,\n\t.id_table\t= gb_hid_id_table,\n};\nmodule_greybus_driver(gb_hid_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}