{
  "module_name": "spilib.c",
  "hash_id": "a39b4f7e826f65b7685e890ad371b4de45346b40bf1e5bfd46e7fb05465a885d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/greybus/spilib.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/greybus.h>\n#include <linux/spi/spi.h>\n\n#include \"spilib.h\"\n\nstruct gb_spilib {\n\tstruct gb_connection\t*connection;\n\tstruct device\t\t*parent;\n\tstruct spi_transfer\t*first_xfer;\n\tstruct spi_transfer\t*last_xfer;\n\tstruct spilib_ops\t*ops;\n\tu32\t\t\trx_xfer_offset;\n\tu32\t\t\ttx_xfer_offset;\n\tu32\t\t\tlast_xfer_size;\n\tunsigned int\t\top_timeout;\n\tu16\t\t\tmode;\n\tu16\t\t\tflags;\n\tu32\t\t\tbits_per_word_mask;\n\tu8\t\t\tnum_chipselect;\n\tu32\t\t\tmin_speed_hz;\n\tu32\t\t\tmax_speed_hz;\n};\n\n#define GB_SPI_STATE_MSG_DONE\t\t((void *)0)\n#define GB_SPI_STATE_MSG_IDLE\t\t((void *)1)\n#define GB_SPI_STATE_MSG_RUNNING\t((void *)2)\n#define GB_SPI_STATE_OP_READY\t\t((void *)3)\n#define GB_SPI_STATE_OP_DONE\t\t((void *)4)\n#define GB_SPI_STATE_MSG_ERROR\t\t((void *)-1)\n\n#define XFER_TIMEOUT_TOLERANCE\t\t200\n\nstatic struct spi_master *get_master_from_spi(struct gb_spilib *spi)\n{\n\treturn gb_connection_get_data(spi->connection);\n}\n\nstatic int tx_header_fit_operation(u32 tx_size, u32 count, size_t data_max)\n{\n\tsize_t headers_size;\n\n\tdata_max -= sizeof(struct gb_spi_transfer_request);\n\theaders_size = (count + 1) * sizeof(struct gb_spi_transfer);\n\n\treturn tx_size + headers_size > data_max ? 0 : 1;\n}\n\nstatic size_t calc_rx_xfer_size(u32 rx_size, u32 *tx_xfer_size, u32 len,\n\t\t\t\tsize_t data_max)\n{\n\tsize_t rx_xfer_size;\n\n\tdata_max -= sizeof(struct gb_spi_transfer_response);\n\n\tif (rx_size + len > data_max)\n\t\trx_xfer_size = data_max - rx_size;\n\telse\n\t\trx_xfer_size = len;\n\n\t \n\tif (*tx_xfer_size && rx_xfer_size > *tx_xfer_size)\n\t\trx_xfer_size = *tx_xfer_size;\n\tif (*tx_xfer_size && rx_xfer_size < *tx_xfer_size)\n\t\t*tx_xfer_size = rx_xfer_size;\n\n\treturn rx_xfer_size;\n}\n\nstatic size_t calc_tx_xfer_size(u32 tx_size, u32 count, size_t len,\n\t\t\t\tsize_t data_max)\n{\n\tsize_t headers_size;\n\n\tdata_max -= sizeof(struct gb_spi_transfer_request);\n\theaders_size = (count + 1) * sizeof(struct gb_spi_transfer);\n\n\tif (tx_size + headers_size + len > data_max)\n\t\treturn data_max - (tx_size + sizeof(struct gb_spi_transfer));\n\n\treturn len;\n}\n\nstatic void clean_xfer_state(struct gb_spilib *spi)\n{\n\tspi->first_xfer = NULL;\n\tspi->last_xfer = NULL;\n\tspi->rx_xfer_offset = 0;\n\tspi->tx_xfer_offset = 0;\n\tspi->last_xfer_size = 0;\n\tspi->op_timeout = 0;\n}\n\nstatic bool is_last_xfer_done(struct gb_spilib *spi)\n{\n\tstruct spi_transfer *last_xfer = spi->last_xfer;\n\n\tif ((spi->tx_xfer_offset + spi->last_xfer_size == last_xfer->len) ||\n\t    (spi->rx_xfer_offset + spi->last_xfer_size == last_xfer->len))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int setup_next_xfer(struct gb_spilib *spi, struct spi_message *msg)\n{\n\tstruct spi_transfer *last_xfer = spi->last_xfer;\n\n\tif (msg->state != GB_SPI_STATE_OP_DONE)\n\t\treturn 0;\n\n\t \n\tif (is_last_xfer_done(spi)) {\n\t\tspi->tx_xfer_offset = 0;\n\t\tspi->rx_xfer_offset = 0;\n\t\tspi->op_timeout = 0;\n\t\tif (last_xfer == list_last_entry(&msg->transfers,\n\t\t\t\t\t\t struct spi_transfer,\n\t\t\t\t\t\t transfer_list))\n\t\t\tmsg->state = GB_SPI_STATE_MSG_DONE;\n\t\telse\n\t\t\tspi->first_xfer = list_next_entry(last_xfer,\n\t\t\t\t\t\t\t  transfer_list);\n\t\treturn 0;\n\t}\n\n\tspi->first_xfer = last_xfer;\n\tif (last_xfer->tx_buf)\n\t\tspi->tx_xfer_offset += spi->last_xfer_size;\n\n\tif (last_xfer->rx_buf)\n\t\tspi->rx_xfer_offset += spi->last_xfer_size;\n\n\treturn 0;\n}\n\nstatic struct spi_transfer *get_next_xfer(struct spi_transfer *xfer,\n\t\t\t\t\t  struct spi_message *msg)\n{\n\tif (xfer == list_last_entry(&msg->transfers, struct spi_transfer,\n\t\t\t\t    transfer_list))\n\t\treturn NULL;\n\n\treturn list_next_entry(xfer, transfer_list);\n}\n\n \nstatic struct gb_operation *gb_spi_operation_create(struct gb_spilib *spi,\n\t\tstruct gb_connection *connection, struct spi_message *msg)\n{\n\tstruct gb_spi_transfer_request *request;\n\tstruct spi_device *dev = msg->spi;\n\tstruct spi_transfer *xfer;\n\tstruct gb_spi_transfer *gb_xfer;\n\tstruct gb_operation *operation;\n\tu32 tx_size = 0, rx_size = 0, count = 0, xfer_len = 0, request_size;\n\tu32 tx_xfer_size = 0, rx_xfer_size = 0, len;\n\tu32 total_len = 0;\n\tunsigned int xfer_timeout;\n\tsize_t data_max;\n\tvoid *tx_data;\n\n\tdata_max = gb_operation_get_payload_size_max(connection);\n\txfer = spi->first_xfer;\n\n\t \n\n\twhile (msg->state != GB_SPI_STATE_OP_READY) {\n\t\tmsg->state = GB_SPI_STATE_MSG_RUNNING;\n\t\tspi->last_xfer = xfer;\n\n\t\tif (!xfer->tx_buf && !xfer->rx_buf) {\n\t\t\tdev_err(spi->parent,\n\t\t\t\t\"bufferless transfer, length %u\\n\", xfer->len);\n\t\t\tmsg->state = GB_SPI_STATE_MSG_ERROR;\n\t\t\treturn NULL;\n\t\t}\n\n\t\ttx_xfer_size = 0;\n\t\trx_xfer_size = 0;\n\n\t\tif (xfer->tx_buf) {\n\t\t\tlen = xfer->len - spi->tx_xfer_offset;\n\t\t\tif (!tx_header_fit_operation(tx_size, count, data_max))\n\t\t\t\tbreak;\n\t\t\ttx_xfer_size = calc_tx_xfer_size(tx_size, count,\n\t\t\t\t\t\t\t len, data_max);\n\t\t\tspi->last_xfer_size = tx_xfer_size;\n\t\t}\n\n\t\tif (xfer->rx_buf) {\n\t\t\tlen = xfer->len - spi->rx_xfer_offset;\n\t\t\trx_xfer_size = calc_rx_xfer_size(rx_size, &tx_xfer_size,\n\t\t\t\t\t\t\t len, data_max);\n\t\t\tspi->last_xfer_size = rx_xfer_size;\n\t\t}\n\n\t\ttx_size += tx_xfer_size;\n\t\trx_size += rx_xfer_size;\n\n\t\ttotal_len += spi->last_xfer_size;\n\t\tcount++;\n\n\t\txfer = get_next_xfer(xfer, msg);\n\t\tif (!xfer || total_len >= data_max)\n\t\t\tmsg->state = GB_SPI_STATE_OP_READY;\n\t}\n\n\t \n\trequest_size = sizeof(*request);\n\trequest_size += count * sizeof(*gb_xfer);\n\trequest_size += tx_size;\n\n\t \n\toperation = gb_operation_create(connection, GB_SPI_TYPE_TRANSFER,\n\t\t\t\t\trequest_size, rx_size, GFP_KERNEL);\n\tif (!operation)\n\t\treturn NULL;\n\n\trequest = operation->request->payload;\n\trequest->count = cpu_to_le16(count);\n\trequest->mode = dev->mode;\n\trequest->chip_select = spi_get_chipselect(dev, 0);\n\n\tgb_xfer = &request->transfers[0];\n\ttx_data = gb_xfer + count;\t \n\n\t \n\txfer = spi->first_xfer;\n\twhile (msg->state != GB_SPI_STATE_OP_DONE) {\n\t\tint xfer_delay;\n\n\t\tif (xfer == spi->last_xfer)\n\t\t\txfer_len = spi->last_xfer_size;\n\t\telse\n\t\t\txfer_len = xfer->len;\n\n\t\t \n\t\txfer_timeout = xfer_len * 8 * MSEC_PER_SEC / xfer->speed_hz;\n\t\txfer_timeout += GB_OPERATION_TIMEOUT_DEFAULT;\n\n\t\tif (xfer_timeout > spi->op_timeout)\n\t\t\tspi->op_timeout = xfer_timeout;\n\n\t\tgb_xfer->speed_hz = cpu_to_le32(xfer->speed_hz);\n\t\tgb_xfer->len = cpu_to_le32(xfer_len);\n\t\txfer_delay = spi_delay_to_ns(&xfer->delay, xfer) / 1000;\n\t\txfer_delay = clamp_t(u16, xfer_delay, 0, U16_MAX);\n\t\tgb_xfer->delay_usecs = cpu_to_le16(xfer_delay);\n\t\tgb_xfer->cs_change = xfer->cs_change;\n\t\tgb_xfer->bits_per_word = xfer->bits_per_word;\n\n\t\t \n\t\tif (xfer->tx_buf) {\n\t\t\tgb_xfer->xfer_flags |= GB_SPI_XFER_WRITE;\n\t\t\tmemcpy(tx_data, xfer->tx_buf + spi->tx_xfer_offset,\n\t\t\t       xfer_len);\n\t\t\ttx_data += xfer_len;\n\t\t}\n\n\t\tif (xfer->rx_buf)\n\t\t\tgb_xfer->xfer_flags |= GB_SPI_XFER_READ;\n\n\t\tif (xfer == spi->last_xfer) {\n\t\t\tif (!is_last_xfer_done(spi))\n\t\t\t\tgb_xfer->xfer_flags |= GB_SPI_XFER_INPROGRESS;\n\t\t\tmsg->state = GB_SPI_STATE_OP_DONE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tgb_xfer++;\n\t\txfer = get_next_xfer(xfer, msg);\n\t}\n\n\tmsg->actual_length += total_len;\n\n\treturn operation;\n}\n\nstatic void gb_spi_decode_response(struct gb_spilib *spi,\n\t\t\t\t   struct spi_message *msg,\n\t\t\t\t   struct gb_spi_transfer_response *response)\n{\n\tstruct spi_transfer *xfer = spi->first_xfer;\n\tvoid *rx_data = response->data;\n\tu32 xfer_len;\n\n\twhile (xfer) {\n\t\t \n\t\tif (xfer->rx_buf) {\n\t\t\tif (xfer == spi->first_xfer)\n\t\t\t\txfer_len = xfer->len - spi->rx_xfer_offset;\n\t\t\telse if (xfer == spi->last_xfer)\n\t\t\t\txfer_len = spi->last_xfer_size;\n\t\t\telse\n\t\t\t\txfer_len = xfer->len;\n\n\t\t\tmemcpy(xfer->rx_buf + spi->rx_xfer_offset, rx_data,\n\t\t\t       xfer_len);\n\t\t\trx_data += xfer_len;\n\t\t}\n\n\t\tif (xfer == spi->last_xfer)\n\t\t\tbreak;\n\n\t\txfer = list_next_entry(xfer, transfer_list);\n\t}\n}\n\nstatic int gb_spi_transfer_one_message(struct spi_master *master,\n\t\t\t\t       struct spi_message *msg)\n{\n\tstruct gb_spilib *spi = spi_master_get_devdata(master);\n\tstruct gb_connection *connection = spi->connection;\n\tstruct gb_spi_transfer_response *response;\n\tstruct gb_operation *operation;\n\tint ret = 0;\n\n\tspi->first_xfer = list_first_entry_or_null(&msg->transfers,\n\t\t\t\t\t\t   struct spi_transfer,\n\t\t\t\t\t\t   transfer_list);\n\tif (!spi->first_xfer) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg->state = GB_SPI_STATE_MSG_IDLE;\n\n\twhile (msg->state != GB_SPI_STATE_MSG_DONE &&\n\t       msg->state != GB_SPI_STATE_MSG_ERROR) {\n\t\toperation = gb_spi_operation_create(spi, connection, msg);\n\t\tif (!operation) {\n\t\t\tmsg->state = GB_SPI_STATE_MSG_ERROR;\n\t\t\tret = -EINVAL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = gb_operation_request_send_sync_timeout(operation,\n\t\t\t\t\t\t\t     spi->op_timeout);\n\t\tif (!ret) {\n\t\t\tresponse = operation->response->payload;\n\t\t\tif (response)\n\t\t\t\tgb_spi_decode_response(spi, msg, response);\n\t\t} else {\n\t\t\tdev_err(spi->parent,\n\t\t\t\t\"transfer operation failed: %d\\n\", ret);\n\t\t\tmsg->state = GB_SPI_STATE_MSG_ERROR;\n\t\t}\n\n\t\tgb_operation_put(operation);\n\t\tsetup_next_xfer(spi, msg);\n\t}\n\nout:\n\tmsg->status = ret;\n\tclean_xfer_state(spi);\n\tspi_finalize_current_message(master);\n\n\treturn ret;\n}\n\nstatic int gb_spi_prepare_transfer_hardware(struct spi_master *master)\n{\n\tstruct gb_spilib *spi = spi_master_get_devdata(master);\n\n\treturn spi->ops->prepare_transfer_hardware(spi->parent);\n}\n\nstatic int gb_spi_unprepare_transfer_hardware(struct spi_master *master)\n{\n\tstruct gb_spilib *spi = spi_master_get_devdata(master);\n\n\tspi->ops->unprepare_transfer_hardware(spi->parent);\n\n\treturn 0;\n}\n\nstatic int gb_spi_setup(struct spi_device *spi)\n{\n\t \n\treturn 0;\n}\n\nstatic void gb_spi_cleanup(struct spi_device *spi)\n{\n\t \n}\n\n \n\n \n#define gb_spi_mode_map(mode) mode\n#define gb_spi_flags_map(flags) flags\n\nstatic int gb_spi_get_master_config(struct gb_spilib *spi)\n{\n\tstruct gb_spi_master_config_response response;\n\tu16 mode, flags;\n\tint ret;\n\n\tret = gb_operation_sync(spi->connection, GB_SPI_TYPE_MASTER_CONFIG,\n\t\t\t\tNULL, 0, &response, sizeof(response));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmode = le16_to_cpu(response.mode);\n\tspi->mode = gb_spi_mode_map(mode);\n\n\tflags = le16_to_cpu(response.flags);\n\tspi->flags = gb_spi_flags_map(flags);\n\n\tspi->bits_per_word_mask = le32_to_cpu(response.bits_per_word_mask);\n\tspi->num_chipselect = response.num_chipselect;\n\n\tspi->min_speed_hz = le32_to_cpu(response.min_speed_hz);\n\tspi->max_speed_hz = le32_to_cpu(response.max_speed_hz);\n\n\treturn 0;\n}\n\nstatic int gb_spi_setup_device(struct gb_spilib *spi, u8 cs)\n{\n\tstruct spi_master *master = get_master_from_spi(spi);\n\tstruct gb_spi_device_config_request request;\n\tstruct gb_spi_device_config_response response;\n\tstruct spi_board_info spi_board = { {0} };\n\tstruct spi_device *spidev;\n\tint ret;\n\tu8 dev_type;\n\n\trequest.chip_select = cs;\n\n\tret = gb_operation_sync(spi->connection, GB_SPI_TYPE_DEVICE_CONFIG,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_type = response.device_type;\n\n\tif (dev_type == GB_SPI_SPI_DEV)\n\t\tstrscpy(spi_board.modalias, \"spidev\",\n\t\t\tsizeof(spi_board.modalias));\n\telse if (dev_type == GB_SPI_SPI_NOR)\n\t\tstrscpy(spi_board.modalias, \"spi-nor\",\n\t\t\tsizeof(spi_board.modalias));\n\telse if (dev_type == GB_SPI_SPI_MODALIAS)\n\t\tmemcpy(spi_board.modalias, response.name,\n\t\t       sizeof(spi_board.modalias));\n\telse\n\t\treturn -EINVAL;\n\n\tspi_board.mode\t\t= le16_to_cpu(response.mode);\n\tspi_board.bus_num\t= master->bus_num;\n\tspi_board.chip_select\t= cs;\n\tspi_board.max_speed_hz\t= le32_to_cpu(response.max_speed_hz);\n\n\tspidev = spi_new_device(master, &spi_board);\n\tif (!spidev)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint gb_spilib_master_init(struct gb_connection *connection, struct device *dev,\n\t\t\t  struct spilib_ops *ops)\n{\n\tstruct gb_spilib *spi;\n\tstruct spi_master *master;\n\tint ret;\n\tu8 i;\n\n\t \n\tmaster = spi_alloc_master(dev, sizeof(*spi));\n\tif (!master) {\n\t\tdev_err(dev, \"cannot alloc SPI master\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspi = spi_master_get_devdata(master);\n\tspi->connection = connection;\n\tgb_connection_set_data(connection, master);\n\tspi->parent = dev;\n\tspi->ops = ops;\n\n\t \n\tret = gb_spi_get_master_config(spi);\n\tif (ret)\n\t\tgoto exit_spi_put;\n\n\tmaster->bus_num = -1;  \n\tmaster->num_chipselect = spi->num_chipselect;\n\tmaster->mode_bits = spi->mode;\n\tmaster->flags = spi->flags;\n\tmaster->bits_per_word_mask = spi->bits_per_word_mask;\n\n\t \n\tmaster->cleanup = gb_spi_cleanup;\n\tmaster->setup = gb_spi_setup;\n\tmaster->transfer_one_message = gb_spi_transfer_one_message;\n\n\tif (ops && ops->prepare_transfer_hardware) {\n\t\tmaster->prepare_transfer_hardware =\n\t\t\tgb_spi_prepare_transfer_hardware;\n\t}\n\n\tif (ops && ops->unprepare_transfer_hardware) {\n\t\tmaster->unprepare_transfer_hardware =\n\t\t\tgb_spi_unprepare_transfer_hardware;\n\t}\n\n\tmaster->auto_runtime_pm = true;\n\n\tret = spi_register_master(master);\n\tif (ret < 0)\n\t\tgoto exit_spi_put;\n\n\t \n\tfor (i = 0; i < spi->num_chipselect; i++) {\n\t\tret = gb_spi_setup_device(spi, i);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to allocate spi device %d: %d\\n\",\n\t\t\t\ti, ret);\n\t\t\tgoto exit_spi_unregister;\n\t\t}\n\t}\n\n\treturn 0;\n\nexit_spi_put:\n\tspi_master_put(master);\n\n\treturn ret;\n\nexit_spi_unregister:\n\tspi_unregister_master(master);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gb_spilib_master_init);\n\nvoid gb_spilib_master_exit(struct gb_connection *connection)\n{\n\tstruct spi_master *master = gb_connection_get_data(connection);\n\n\tspi_unregister_master(master);\n}\nEXPORT_SYMBOL_GPL(gb_spilib_master_exit);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}