{
  "module_name": "prism2sta.c",
  "hash_id": "5276d6dcecc4edd10f79281f3786a58499d2949aa45ca4ae2e92b77b9e9baa91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/wlan-ng/prism2sta.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/wireless.h>\n#include <linux/netdevice.h>\n#include <linux/workqueue.h>\n#include <linux/byteorder/generic.h>\n#include <linux/etherdevice.h>\n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <asm/byteorder.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/bitops.h>\n\n#include \"p80211types.h\"\n#include \"p80211hdr.h\"\n#include \"p80211mgmt.h\"\n#include \"p80211conv.h\"\n#include \"p80211msg.h\"\n#include \"p80211netdev.h\"\n#include \"p80211req.h\"\n#include \"p80211metadef.h\"\n#include \"p80211metastruct.h\"\n#include \"hfa384x.h\"\n#include \"prism2mgmt.h\"\n\nstatic char *dev_info = \"prism2_usb\";\nstatic struct wlandevice *create_wlan(void);\n\nint prism2_reset_holdtime = 30;\t \nint prism2_reset_settletime = 100;\t \n\nstatic int prism2_doreset;\t \n\nmodule_param(prism2_doreset, int, 0644);\nMODULE_PARM_DESC(prism2_doreset, \"Issue a reset on initialization\");\n\nmodule_param(prism2_reset_holdtime, int, 0644);\nMODULE_PARM_DESC(prism2_reset_holdtime, \"reset hold time in ms\");\nmodule_param(prism2_reset_settletime, int, 0644);\nMODULE_PARM_DESC(prism2_reset_settletime, \"reset settle time in ms\");\n\nMODULE_LICENSE(\"Dual MPL/GPL\");\n\nstatic int prism2sta_open(struct wlandevice *wlandev);\nstatic int prism2sta_close(struct wlandevice *wlandev);\nstatic void prism2sta_reset(struct wlandevice *wlandev);\nstatic int prism2sta_txframe(struct wlandevice *wlandev, struct sk_buff *skb,\n\t\t\t     struct p80211_hdr *p80211_hdr,\n\t\t\t     struct p80211_metawep *p80211_wep);\nstatic int prism2sta_mlmerequest(struct wlandevice *wlandev,\n\t\t\t\t struct p80211msg *msg);\nstatic int prism2sta_getcardinfo(struct wlandevice *wlandev);\nstatic int prism2sta_globalsetup(struct wlandevice *wlandev);\nstatic int prism2sta_setmulticast(struct wlandevice *wlandev,\n\t\t\t\t  struct net_device *dev);\n\nstatic void prism2sta_inf_handover(struct wlandevice *wlandev,\n\t\t\t\t   struct hfa384x_inf_frame *inf);\nstatic void prism2sta_inf_tallies(struct wlandevice *wlandev,\n\t\t\t\t  struct hfa384x_inf_frame *inf);\nstatic void prism2sta_inf_hostscanresults(struct wlandevice *wlandev,\n\t\t\t\t\t  struct hfa384x_inf_frame *inf);\nstatic void prism2sta_inf_scanresults(struct wlandevice *wlandev,\n\t\t\t\t      struct hfa384x_inf_frame *inf);\nstatic void prism2sta_inf_chinforesults(struct wlandevice *wlandev,\n\t\t\t\t\tstruct hfa384x_inf_frame *inf);\nstatic void prism2sta_inf_linkstatus(struct wlandevice *wlandev,\n\t\t\t\t     struct hfa384x_inf_frame *inf);\nstatic void prism2sta_inf_assocstatus(struct wlandevice *wlandev,\n\t\t\t\t      struct hfa384x_inf_frame *inf);\nstatic void prism2sta_inf_authreq(struct wlandevice *wlandev,\n\t\t\t\t  struct hfa384x_inf_frame *inf);\nstatic void prism2sta_inf_authreq_defer(struct wlandevice *wlandev,\n\t\t\t\t\tstruct hfa384x_inf_frame *inf);\nstatic void prism2sta_inf_psusercnt(struct wlandevice *wlandev,\n\t\t\t\t    struct hfa384x_inf_frame *inf);\n\n \nstatic int prism2sta_open(struct wlandevice *wlandev)\n{\n\t \n\n\treturn 0;\n}\n\n \nstatic int prism2sta_close(struct wlandevice *wlandev)\n{\n\t \n\n\treturn 0;\n}\n\n \nstatic void prism2sta_reset(struct wlandevice *wlandev)\n{\n}\n\n \nstatic int prism2sta_txframe(struct wlandevice *wlandev, struct sk_buff *skb,\n\t\t\t     struct p80211_hdr *p80211_hdr,\n\t\t\t     struct p80211_metawep *p80211_wep)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\n\t \n\tif ((wlandev->hostwep & (HOSTWEP_PRIVACYINVOKED | HOSTWEP_ENCRYPT)) ==\n\t    HOSTWEP_PRIVACYINVOKED) {\n\t\tp80211_hdr->frame_control |= cpu_to_le16(WLAN_SET_FC_ISWEP(1));\n\t}\n\n\treturn hfa384x_drvr_txframe(hw, skb, p80211_hdr, p80211_wep);\n}\n\n \nstatic int prism2sta_mlmerequest(struct wlandevice *wlandev,\n\t\t\t\t struct p80211msg *msg)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\n\tint result = 0;\n\n\tswitch (msg->msgcode) {\n\tcase DIDMSG_DOT11REQ_MIBGET:\n\t\tpr_debug(\"Received mibget request\\n\");\n\t\tresult = prism2mgmt_mibset_mibget(wlandev, msg);\n\t\tbreak;\n\tcase DIDMSG_DOT11REQ_MIBSET:\n\t\tpr_debug(\"Received mibset request\\n\");\n\t\tresult = prism2mgmt_mibset_mibget(wlandev, msg);\n\t\tbreak;\n\tcase DIDMSG_DOT11REQ_SCAN:\n\t\tpr_debug(\"Received scan request\\n\");\n\t\tresult = prism2mgmt_scan(wlandev, msg);\n\t\tbreak;\n\tcase DIDMSG_DOT11REQ_SCAN_RESULTS:\n\t\tpr_debug(\"Received scan_results request\\n\");\n\t\tresult = prism2mgmt_scan_results(wlandev, msg);\n\t\tbreak;\n\tcase DIDMSG_DOT11REQ_START:\n\t\tpr_debug(\"Received mlme start request\\n\");\n\t\tresult = prism2mgmt_start(wlandev, msg);\n\t\tbreak;\n\t\t \n\tcase DIDMSG_P2REQ_READPDA:\n\t\tpr_debug(\"Received mlme readpda request\\n\");\n\t\tresult = prism2mgmt_readpda(wlandev, msg);\n\t\tbreak;\n\tcase DIDMSG_P2REQ_RAMDL_STATE:\n\t\tpr_debug(\"Received mlme ramdl_state request\\n\");\n\t\tresult = prism2mgmt_ramdl_state(wlandev, msg);\n\t\tbreak;\n\tcase DIDMSG_P2REQ_RAMDL_WRITE:\n\t\tpr_debug(\"Received mlme ramdl_write request\\n\");\n\t\tresult = prism2mgmt_ramdl_write(wlandev, msg);\n\t\tbreak;\n\tcase DIDMSG_P2REQ_FLASHDL_STATE:\n\t\tpr_debug(\"Received mlme flashdl_state request\\n\");\n\t\tresult = prism2mgmt_flashdl_state(wlandev, msg);\n\t\tbreak;\n\tcase DIDMSG_P2REQ_FLASHDL_WRITE:\n\t\tpr_debug(\"Received mlme flashdl_write request\\n\");\n\t\tresult = prism2mgmt_flashdl_write(wlandev, msg);\n\t\tbreak;\n\t\t \n\tcase DIDMSG_LNXREQ_HOSTWEP:\n\t\tbreak;\t\t \n\tcase DIDMSG_LNXREQ_IFSTATE: {\n\t\tstruct p80211msg_lnxreq_ifstate *ifstatemsg;\n\n\t\tpr_debug(\"Received mlme ifstate request\\n\");\n\t\tifstatemsg = (struct p80211msg_lnxreq_ifstate *)msg;\n\t\tresult = prism2sta_ifstate(wlandev,\n\t\t\t\t\t   ifstatemsg->ifstate.data);\n\t\tifstatemsg->resultcode.status =\n\t\t\tP80211ENUM_msgitem_status_data_ok;\n\t\tifstatemsg->resultcode.data = result;\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\tcase DIDMSG_LNXREQ_WLANSNIFF:\n\t\tpr_debug(\"Received mlme wlansniff request\\n\");\n\t\tresult = prism2mgmt_wlansniff(wlandev, msg);\n\t\tbreak;\n\tcase DIDMSG_LNXREQ_AUTOJOIN:\n\t\tpr_debug(\"Received mlme autojoin request\\n\");\n\t\tresult = prism2mgmt_autojoin(wlandev, msg);\n\t\tbreak;\n\tcase DIDMSG_LNXREQ_COMMSQUALITY: {\n\t\tstruct p80211msg_lnxreq_commsquality *qualmsg;\n\n\t\tpr_debug(\"Received commsquality request\\n\");\n\n\t\tqualmsg = (struct p80211msg_lnxreq_commsquality *)msg;\n\n\t\tqualmsg->link.status = P80211ENUM_msgitem_status_data_ok;\n\t\tqualmsg->level.status = P80211ENUM_msgitem_status_data_ok;\n\t\tqualmsg->noise.status = P80211ENUM_msgitem_status_data_ok;\n\n\t\tqualmsg->link.data = le16_to_cpu(hw->qual.cq_curr_bss);\n\t\tqualmsg->level.data = le16_to_cpu(hw->qual.asl_curr_bss);\n\t\tqualmsg->noise.data = le16_to_cpu(hw->qual.anl_curr_fc);\n\t\tqualmsg->txrate.data = hw->txrate;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tnetdev_warn(wlandev->netdev,\n\t\t\t    \"Unknown mgmt request message 0x%08x\",\n\t\t\t    msg->msgcode);\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\n \nu32 prism2sta_ifstate(struct wlandevice *wlandev, u32 ifstate)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\tu32 result;\n\n\tresult = P80211ENUM_resultcode_implementation_failure;\n\n\tpr_debug(\"Current MSD state(%d), requesting(%d)\\n\",\n\t\t wlandev->msdstate, ifstate);\n\tswitch (ifstate) {\n\tcase P80211ENUM_ifstate_fwload:\n\t\tswitch (wlandev->msdstate) {\n\t\tcase WLAN_MSD_HWPRESENT:\n\t\t\twlandev->msdstate = WLAN_MSD_FWLOAD_PENDING;\n\t\t\t \n\t\t\tresult = hfa384x_drvr_start(hw);\n\t\t\tif (result) {\n\t\t\t\tnetdev_err(wlandev->netdev,\n\t\t\t\t\t   \"hfa384x_drvr_start() failed,result=%d\\n\",\n\t\t\t\t\t   (int)result);\n\t\t\t\tresult =\n\t\t\t\t P80211ENUM_resultcode_implementation_failure;\n\t\t\t\twlandev->msdstate = WLAN_MSD_HWPRESENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twlandev->msdstate = WLAN_MSD_FWLOAD;\n\t\t\tresult = P80211ENUM_resultcode_success;\n\t\t\tbreak;\n\t\tcase WLAN_MSD_FWLOAD:\n\t\t\thfa384x_cmd_initialize(hw);\n\t\t\tresult = P80211ENUM_resultcode_success;\n\t\t\tbreak;\n\t\tcase WLAN_MSD_RUNNING:\n\t\t\tnetdev_warn(wlandev->netdev,\n\t\t\t\t    \"Cannot enter fwload state from enable state, you must disable first.\\n\");\n\t\t\tresult = P80211ENUM_resultcode_invalid_parameters;\n\t\t\tbreak;\n\t\tcase WLAN_MSD_HWFAIL:\n\t\tdefault:\n\t\t\t \n\t\t\tresult = P80211ENUM_resultcode_implementation_failure;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase P80211ENUM_ifstate_enable:\n\t\tswitch (wlandev->msdstate) {\n\t\tcase WLAN_MSD_HWPRESENT:\n\t\tcase WLAN_MSD_FWLOAD:\n\t\t\twlandev->msdstate = WLAN_MSD_RUNNING_PENDING;\n\t\t\t \n\t\t\tresult = hfa384x_drvr_start(hw);\n\t\t\tif (result) {\n\t\t\t\tnetdev_err(wlandev->netdev,\n\t\t\t\t\t   \"hfa384x_drvr_start() failed,result=%d\\n\",\n\t\t\t\t\t   (int)result);\n\t\t\t\tresult =\n\t\t\t\t  P80211ENUM_resultcode_implementation_failure;\n\t\t\t\twlandev->msdstate = WLAN_MSD_HWPRESENT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = prism2sta_getcardinfo(wlandev);\n\t\t\tif (result) {\n\t\t\t\tnetdev_err(wlandev->netdev,\n\t\t\t\t\t   \"prism2sta_getcardinfo() failed,result=%d\\n\",\n\t\t\t\t\t   (int)result);\n\t\t\t\tresult =\n\t\t\t\t  P80211ENUM_resultcode_implementation_failure;\n\t\t\t\thfa384x_drvr_stop(hw);\n\t\t\t\twlandev->msdstate = WLAN_MSD_HWPRESENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = prism2sta_globalsetup(wlandev);\n\t\t\tif (result) {\n\t\t\t\tnetdev_err(wlandev->netdev,\n\t\t\t\t\t   \"prism2sta_globalsetup() failed,result=%d\\n\",\n\t\t\t\t\t   (int)result);\n\t\t\t\tresult =\n\t\t\t\t  P80211ENUM_resultcode_implementation_failure;\n\t\t\t\thfa384x_drvr_stop(hw);\n\t\t\t\twlandev->msdstate = WLAN_MSD_HWPRESENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twlandev->msdstate = WLAN_MSD_RUNNING;\n\t\t\thw->join_ap = 0;\n\t\t\thw->join_retries = 60;\n\t\t\tresult = P80211ENUM_resultcode_success;\n\t\t\tbreak;\n\t\tcase WLAN_MSD_RUNNING:\n\t\t\t \n\t\t\tresult = P80211ENUM_resultcode_success;\n\t\t\tbreak;\n\t\tcase WLAN_MSD_HWFAIL:\n\t\tdefault:\n\t\t\t \n\t\t\tresult = P80211ENUM_resultcode_implementation_failure;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase P80211ENUM_ifstate_disable:\n\t\tswitch (wlandev->msdstate) {\n\t\tcase WLAN_MSD_HWPRESENT:\n\t\t\t \n\t\t\tresult = P80211ENUM_resultcode_success;\n\t\t\tbreak;\n\t\tcase WLAN_MSD_FWLOAD:\n\t\tcase WLAN_MSD_RUNNING:\n\t\t\twlandev->msdstate = WLAN_MSD_HWPRESENT_PENDING;\n\t\t\t \n\t\t\tif (!wlandev->hwremoved)\n\t\t\t\tnetif_carrier_off(wlandev->netdev);\n\n\t\t\thfa384x_drvr_stop(hw);\n\n\t\t\twlandev->macmode = WLAN_MACMODE_NONE;\n\t\t\twlandev->msdstate = WLAN_MSD_HWPRESENT;\n\t\t\tresult = P80211ENUM_resultcode_success;\n\t\t\tbreak;\n\t\tcase WLAN_MSD_HWFAIL:\n\t\tdefault:\n\t\t\t \n\t\t\tresult = P80211ENUM_resultcode_implementation_failure;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tresult = P80211ENUM_resultcode_invalid_parameters;\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\n \nstatic int prism2sta_getcardinfo(struct wlandevice *wlandev)\n{\n\tint result = 0;\n\tstruct hfa384x *hw = wlandev->priv;\n\tu16 temp;\n\tu8 snum[HFA384x_RID_NICSERIALNUMBER_LEN];\n\tu8 addr[ETH_ALEN];\n\n\t \n\t \n\t \n\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_NICIDENTITY,\n\t\t\t\t\t&hw->ident_nic,\n\t\t\t\t\tsizeof(struct hfa384x_compident));\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to retrieve NICIDENTITY\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\tle16_to_cpus(&hw->ident_nic.id);\n\tle16_to_cpus(&hw->ident_nic.variant);\n\tle16_to_cpus(&hw->ident_nic.major);\n\tle16_to_cpus(&hw->ident_nic.minor);\n\n\tnetdev_info(wlandev->netdev, \"ident: nic h/w: id=0x%02x %d.%d.%d\\n\",\n\t\t    hw->ident_nic.id, hw->ident_nic.major,\n\t\t    hw->ident_nic.minor, hw->ident_nic.variant);\n\n\t \n\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_PRIIDENTITY,\n\t\t\t\t\t&hw->ident_pri_fw,\n\t\t\t\t\tsizeof(struct hfa384x_compident));\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to retrieve PRIIDENTITY\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\tle16_to_cpus(&hw->ident_pri_fw.id);\n\tle16_to_cpus(&hw->ident_pri_fw.variant);\n\tle16_to_cpus(&hw->ident_pri_fw.major);\n\tle16_to_cpus(&hw->ident_pri_fw.minor);\n\n\tnetdev_info(wlandev->netdev, \"ident: pri f/w: id=0x%02x %d.%d.%d\\n\",\n\t\t    hw->ident_pri_fw.id, hw->ident_pri_fw.major,\n\t\t    hw->ident_pri_fw.minor, hw->ident_pri_fw.variant);\n\n\t \n\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_STAIDENTITY,\n\t\t\t\t\t&hw->ident_sta_fw,\n\t\t\t\t\tsizeof(struct hfa384x_compident));\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to retrieve STAIDENTITY\\n\");\n\t\tgoto failed;\n\t}\n\n\tif (hw->ident_nic.id < 0x8000) {\n\t\tnetdev_err(wlandev->netdev,\n\t\t\t   \"FATAL: Card is not an Intersil Prism2/2.5/3\\n\");\n\t\tresult = -1;\n\t\tgoto failed;\n\t}\n\n\t \n\tle16_to_cpus(&hw->ident_sta_fw.id);\n\tle16_to_cpus(&hw->ident_sta_fw.variant);\n\tle16_to_cpus(&hw->ident_sta_fw.major);\n\tle16_to_cpus(&hw->ident_sta_fw.minor);\n\n\t \n\thw->mm_mods = hw->ident_sta_fw.variant & GENMASK(15, 14);\n\thw->ident_sta_fw.variant &= ~((u16)GENMASK(15, 14));\n\n\tif (hw->ident_sta_fw.id == 0x1f) {\n\t\tnetdev_info(wlandev->netdev,\n\t\t\t    \"ident: sta f/w: id=0x%02x %d.%d.%d\\n\",\n\t\t\t    hw->ident_sta_fw.id, hw->ident_sta_fw.major,\n\t\t\t    hw->ident_sta_fw.minor, hw->ident_sta_fw.variant);\n\t} else {\n\t\tnetdev_info(wlandev->netdev,\n\t\t\t    \"ident:  ap f/w: id=0x%02x %d.%d.%d\\n\",\n\t\t\t    hw->ident_sta_fw.id, hw->ident_sta_fw.major,\n\t\t\t    hw->ident_sta_fw.minor, hw->ident_sta_fw.variant);\n\t\tnetdev_err(wlandev->netdev, \"Unsupported Tertiary AP firmware loaded!\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_MFISUPRANGE,\n\t\t\t\t\t&hw->cap_sup_mfi,\n\t\t\t\t\tsizeof(struct hfa384x_caplevel));\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to retrieve MFISUPRANGE\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\tle16_to_cpus(&hw->cap_sup_mfi.role);\n\tle16_to_cpus(&hw->cap_sup_mfi.id);\n\tle16_to_cpus(&hw->cap_sup_mfi.variant);\n\tle16_to_cpus(&hw->cap_sup_mfi.bottom);\n\tle16_to_cpus(&hw->cap_sup_mfi.top);\n\n\tnetdev_info(wlandev->netdev,\n\t\t    \"MFI:SUP:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\\n\",\n\t\t    hw->cap_sup_mfi.role, hw->cap_sup_mfi.id,\n\t\t    hw->cap_sup_mfi.variant, hw->cap_sup_mfi.bottom,\n\t\t    hw->cap_sup_mfi.top);\n\n\t \n\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_CFISUPRANGE,\n\t\t\t\t\t&hw->cap_sup_cfi,\n\t\t\t\t\tsizeof(struct hfa384x_caplevel));\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to retrieve CFISUPRANGE\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\tle16_to_cpus(&hw->cap_sup_cfi.role);\n\tle16_to_cpus(&hw->cap_sup_cfi.id);\n\tle16_to_cpus(&hw->cap_sup_cfi.variant);\n\tle16_to_cpus(&hw->cap_sup_cfi.bottom);\n\tle16_to_cpus(&hw->cap_sup_cfi.top);\n\n\tnetdev_info(wlandev->netdev,\n\t\t    \"CFI:SUP:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\\n\",\n\t\t    hw->cap_sup_cfi.role, hw->cap_sup_cfi.id,\n\t\t    hw->cap_sup_cfi.variant, hw->cap_sup_cfi.bottom,\n\t\t    hw->cap_sup_cfi.top);\n\n\t \n\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_PRISUPRANGE,\n\t\t\t\t\t&hw->cap_sup_pri,\n\t\t\t\t\tsizeof(struct hfa384x_caplevel));\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to retrieve PRISUPRANGE\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\tle16_to_cpus(&hw->cap_sup_pri.role);\n\tle16_to_cpus(&hw->cap_sup_pri.id);\n\tle16_to_cpus(&hw->cap_sup_pri.variant);\n\tle16_to_cpus(&hw->cap_sup_pri.bottom);\n\tle16_to_cpus(&hw->cap_sup_pri.top);\n\n\tnetdev_info(wlandev->netdev,\n\t\t    \"PRI:SUP:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\\n\",\n\t\t    hw->cap_sup_pri.role, hw->cap_sup_pri.id,\n\t\t    hw->cap_sup_pri.variant, hw->cap_sup_pri.bottom,\n\t\t    hw->cap_sup_pri.top);\n\n\t \n\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_STASUPRANGE,\n\t\t\t\t\t&hw->cap_sup_sta,\n\t\t\t\t\tsizeof(struct hfa384x_caplevel));\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to retrieve STASUPRANGE\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\tle16_to_cpus(&hw->cap_sup_sta.role);\n\tle16_to_cpus(&hw->cap_sup_sta.id);\n\tle16_to_cpus(&hw->cap_sup_sta.variant);\n\tle16_to_cpus(&hw->cap_sup_sta.bottom);\n\tle16_to_cpus(&hw->cap_sup_sta.top);\n\n\tif (hw->cap_sup_sta.id == 0x04) {\n\t\tnetdev_info(wlandev->netdev,\n\t\t\t    \"STA:SUP:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\\n\",\n\t\t\t    hw->cap_sup_sta.role, hw->cap_sup_sta.id,\n\t\t\t    hw->cap_sup_sta.variant, hw->cap_sup_sta.bottom,\n\t\t\t    hw->cap_sup_sta.top);\n\t} else {\n\t\tnetdev_info(wlandev->netdev,\n\t\t\t    \"AP:SUP:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\\n\",\n\t\t\t    hw->cap_sup_sta.role, hw->cap_sup_sta.id,\n\t\t\t    hw->cap_sup_sta.variant, hw->cap_sup_sta.bottom,\n\t\t\t    hw->cap_sup_sta.top);\n\t}\n\n\t \n\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_PRI_CFIACTRANGES,\n\t\t\t\t\t&hw->cap_act_pri_cfi,\n\t\t\t\t\tsizeof(struct hfa384x_caplevel));\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to retrieve PRI_CFIACTRANGES\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\tle16_to_cpus(&hw->cap_act_pri_cfi.role);\n\tle16_to_cpus(&hw->cap_act_pri_cfi.id);\n\tle16_to_cpus(&hw->cap_act_pri_cfi.variant);\n\tle16_to_cpus(&hw->cap_act_pri_cfi.bottom);\n\tle16_to_cpus(&hw->cap_act_pri_cfi.top);\n\n\tnetdev_info(wlandev->netdev,\n\t\t    \"PRI-CFI:ACT:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\\n\",\n\t\t    hw->cap_act_pri_cfi.role, hw->cap_act_pri_cfi.id,\n\t\t    hw->cap_act_pri_cfi.variant, hw->cap_act_pri_cfi.bottom,\n\t\t    hw->cap_act_pri_cfi.top);\n\n\t \n\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_STA_CFIACTRANGES,\n\t\t\t\t\t&hw->cap_act_sta_cfi,\n\t\t\t\t\tsizeof(struct hfa384x_caplevel));\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to retrieve STA_CFIACTRANGES\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\tle16_to_cpus(&hw->cap_act_sta_cfi.role);\n\tle16_to_cpus(&hw->cap_act_sta_cfi.id);\n\tle16_to_cpus(&hw->cap_act_sta_cfi.variant);\n\tle16_to_cpus(&hw->cap_act_sta_cfi.bottom);\n\tle16_to_cpus(&hw->cap_act_sta_cfi.top);\n\n\tnetdev_info(wlandev->netdev,\n\t\t    \"STA-CFI:ACT:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\\n\",\n\t\t    hw->cap_act_sta_cfi.role, hw->cap_act_sta_cfi.id,\n\t\t    hw->cap_act_sta_cfi.variant, hw->cap_act_sta_cfi.bottom,\n\t\t    hw->cap_act_sta_cfi.top);\n\n\t \n\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_STA_MFIACTRANGES,\n\t\t\t\t\t&hw->cap_act_sta_mfi,\n\t\t\t\t\tsizeof(struct hfa384x_caplevel));\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to retrieve STA_MFIACTRANGES\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\tle16_to_cpus(&hw->cap_act_sta_mfi.role);\n\tle16_to_cpus(&hw->cap_act_sta_mfi.id);\n\tle16_to_cpus(&hw->cap_act_sta_mfi.variant);\n\tle16_to_cpus(&hw->cap_act_sta_mfi.bottom);\n\tle16_to_cpus(&hw->cap_act_sta_mfi.top);\n\n\tnetdev_info(wlandev->netdev,\n\t\t    \"STA-MFI:ACT:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\\n\",\n\t\t    hw->cap_act_sta_mfi.role, hw->cap_act_sta_mfi.id,\n\t\t    hw->cap_act_sta_mfi.variant, hw->cap_act_sta_mfi.bottom,\n\t\t    hw->cap_act_sta_mfi.top);\n\n\t \n\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_NICSERIALNUMBER,\n\t\t\t\t\tsnum, HFA384x_RID_NICSERIALNUMBER_LEN);\n\tif (!result) {\n\t\tnetdev_info(wlandev->netdev, \"Prism2 card SN: %*pE\\n\",\n\t\t\t    HFA384x_RID_NICSERIALNUMBER_LEN, snum);\n\t} else {\n\t\tnetdev_err(wlandev->netdev, \"Failed to retrieve Prism2 Card SN\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_CNFOWNMACADDR,\n\t\t\t\t\taddr, ETH_ALEN);\n\tif (result != 0) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to retrieve mac address\\n\");\n\t\tgoto failed;\n\t}\n\teth_hw_addr_set(wlandev->netdev, addr);\n\n\t \n\twlandev->nsdcaps |= P80211_NSDCAP_SHORT_PREAMBLE;\n\n\t \n\thfa384x_drvr_getconfig16(hw, HFA384x_RID_PRIVACYOPTIMP, &temp);\n\tif (temp)\n\t\twlandev->nsdcaps |= P80211_NSDCAP_HARDWAREWEP;\n\n\t \n\thfa384x_drvr_getconfig16(hw, HFA384x_RID_CNFDBMADJUST, &temp);\n\thw->dbmadjust = temp;\n\n\t \n\tif (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,\n\t\t\t\t     hw->ident_sta_fw.minor,\n\t\t\t\t     hw->ident_sta_fw.variant) <\n\t    HFA384x_FIRMWARE_VERSION(1, 5, 5)) {\n\t\twlandev->nsdcaps |= P80211_NSDCAP_NOSCAN;\n\t}\n\n\t \n\n\tgoto done;\nfailed:\n\tnetdev_err(wlandev->netdev, \"Failed, result=%d\\n\", result);\ndone:\n\treturn result;\n}\n\n \nstatic int prism2sta_globalsetup(struct wlandevice *wlandev)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\n\t \n\treturn hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFMAXDATALEN,\n\t\t\t\t\tWLAN_DATA_MAXLEN);\n}\n\nstatic int prism2sta_setmulticast(struct wlandevice *wlandev,\n\t\t\t\t  struct net_device *dev)\n{\n\tint result = 0;\n\tstruct hfa384x *hw = wlandev->priv;\n\n\tu16 promisc;\n\n\t \n\tif (hw->state != HFA384x_STATE_RUNNING)\n\t\tgoto exit;\n\n\tif ((dev->flags & (IFF_PROMISC | IFF_ALLMULTI)) != 0)\n\t\tpromisc = P80211ENUM_truth_true;\n\telse\n\t\tpromisc = P80211ENUM_truth_false;\n\n\tresult =\n\t    hfa384x_drvr_setconfig16_async(hw, HFA384x_RID_PROMISCMODE,\n\t\t\t\t\t   promisc);\nexit:\n\treturn result;\n}\n\n \nstatic void prism2sta_inf_handover(struct wlandevice *wlandev,\n\t\t\t\t   struct hfa384x_inf_frame *inf)\n{\n\tpr_debug(\"received infoframe:HANDOVER (unhandled)\\n\");\n}\n\n \nstatic void prism2sta_inf_tallies(struct wlandevice *wlandev,\n\t\t\t\t  struct hfa384x_inf_frame *inf)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\t__le16 *src16;\n\tu32 *dst;\n\t__le32 *src32;\n\tint i;\n\tint cnt;\n\n\t \n\n\tcnt = sizeof(struct hfa384x_comm_tallies_32) / sizeof(u32);\n\tif (inf->framelen > 22) {\n\t\tdst = (u32 *)&hw->tallies;\n\t\tsrc32 = (__le32 *)&inf->info.commtallies32;\n\t\tfor (i = 0; i < cnt; i++, dst++, src32++)\n\t\t\t*dst += le32_to_cpu(*src32);\n\t} else {\n\t\tdst = (u32 *)&hw->tallies;\n\t\tsrc16 = (__le16 *)&inf->info.commtallies16;\n\t\tfor (i = 0; i < cnt; i++, dst++, src16++)\n\t\t\t*dst += le16_to_cpu(*src16);\n\t}\n}\n\n \nstatic void prism2sta_inf_scanresults(struct wlandevice *wlandev,\n\t\t\t\t      struct hfa384x_inf_frame *inf)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\tint nbss;\n\tstruct hfa384x_scan_result *sr = &inf->info.scanresult;\n\tint i;\n\tstruct hfa384x_join_request_data joinreq;\n\tint result;\n\n\t \n\tnbss = (inf->framelen * sizeof(u16)) -\n\t    sizeof(inf->infotype) - sizeof(inf->info.scanresult.scanreason);\n\tnbss /= sizeof(struct hfa384x_scan_result_sub);\n\n\t \n\tpr_debug(\"rx scanresults, reason=%d, nbss=%d:\\n\",\n\t\t inf->info.scanresult.scanreason, nbss);\n\tfor (i = 0; i < nbss; i++) {\n\t\tpr_debug(\"chid=%d anl=%d sl=%d bcnint=%d\\n\",\n\t\t\t sr->result[i].chid,\n\t\t\t sr->result[i].anl,\n\t\t\t sr->result[i].sl, sr->result[i].bcnint);\n\t\tpr_debug(\"  capinfo=0x%04x proberesp_rate=%d\\n\",\n\t\t\t sr->result[i].capinfo, sr->result[i].proberesp_rate);\n\t}\n\t \n\tjoinreq.channel = sr->result[0].chid;\n\tmemcpy(joinreq.bssid, sr->result[0].bssid, WLAN_BSSID_LEN);\n\tresult = hfa384x_drvr_setconfig(hw,\n\t\t\t\t\tHFA384x_RID_JOINREQUEST,\n\t\t\t\t\t&joinreq, HFA384x_RID_JOINREQUEST_LEN);\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"setconfig(joinreq) failed, result=%d\\n\",\n\t\t\t   result);\n\t}\n}\n\n \nstatic void prism2sta_inf_hostscanresults(struct wlandevice *wlandev,\n\t\t\t\t\t  struct hfa384x_inf_frame *inf)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\tint nbss;\n\n\tnbss = (inf->framelen - 3) / 32;\n\tpr_debug(\"Received %d hostscan results\\n\", nbss);\n\n\tif (nbss > 32)\n\t\tnbss = 32;\n\n\tkfree(hw->scanresults);\n\n\thw->scanresults = kmemdup(inf, sizeof(*inf), GFP_ATOMIC);\n\n\tif (nbss == 0)\n\t\tnbss = -1;\n\n\t \n\thw->scanflag = nbss;\n\twake_up_interruptible(&hw->cmdq);\n};\n\n \nstatic void prism2sta_inf_chinforesults(struct wlandevice *wlandev,\n\t\t\t\t\tstruct hfa384x_inf_frame *inf)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\tunsigned int i, n;\n\n\thw->channel_info.results.scanchannels =\n\t    inf->info.chinforesult.scanchannels;\n\n\tfor (i = 0, n = 0; i < HFA384x_CHINFORESULT_MAX; i++) {\n\t\tstruct hfa384x_ch_info_result_sub *result;\n\t\tstruct hfa384x_ch_info_result_sub *chinforesult;\n\t\tint chan;\n\n\t\tif (!(hw->channel_info.results.scanchannels & (1 << i)))\n\t\t\tcontinue;\n\n\t\tresult = &inf->info.chinforesult.result[n];\n\t\tchan = result->chid - 1;\n\n\t\tif (chan < 0 || chan >= HFA384x_CHINFORESULT_MAX)\n\t\t\tcontinue;\n\n\t\tchinforesult = &hw->channel_info.results.result[chan];\n\t\tchinforesult->chid = chan;\n\t\tchinforesult->anl = result->anl;\n\t\tchinforesult->pnl = result->pnl;\n\t\tchinforesult->active = result->active;\n\n\t\tpr_debug(\"chinfo: channel %d, %s level (avg/peak)=%d/%d dB, pcf %d\\n\",\n\t\t\t chan + 1,\n\t\t\t (chinforesult->active & HFA384x_CHINFORESULT_BSSACTIVE)\n\t\t\t\t? \"signal\" : \"noise\",\n\t\t\t chinforesult->anl, chinforesult->pnl,\n\t\t\t (chinforesult->active & HFA384x_CHINFORESULT_PCFACTIVE)\n\t\t\t\t? 1 : 0);\n\t\tn++;\n\t}\n\tatomic_set(&hw->channel_info.done, 2);\n\n\thw->channel_info.count = n;\n}\n\nvoid prism2sta_processing_defer(struct work_struct *data)\n{\n\tstruct hfa384x *hw = container_of(data, struct hfa384x, link_bh);\n\tstruct wlandevice *wlandev = hw->wlandev;\n\tstruct hfa384x_bytestr32 ssid;\n\tint result;\n\n\t \n\t{\n\t\tstruct sk_buff *skb;\n\t\tstruct hfa384x_inf_frame *inf;\n\n\t\twhile ((skb = skb_dequeue(&hw->authq))) {\n\t\t\tinf = (struct hfa384x_inf_frame *)skb->data;\n\t\t\tprism2sta_inf_authreq_defer(wlandev, inf);\n\t\t}\n\t}\n\n\t \n\tif (hw->link_status == hw->link_status_new)\n\t\treturn;\n\n\thw->link_status = hw->link_status_new;\n\n\tswitch (hw->link_status) {\n\tcase HFA384x_LINK_NOTCONNECTED:\n\t\t \n\t\tnetif_carrier_off(wlandev->netdev);\n\n\t\tnetdev_info(wlandev->netdev, \"linkstatus=NOTCONNECTED (unhandled)\\n\");\n\t\tbreak;\n\n\tcase HFA384x_LINK_CONNECTED:\n\t\t \n\n\t\tnetif_carrier_on(wlandev->netdev);\n\n\t\t \n\t\tif (hw->join_ap == 1)\n\t\t\thw->join_ap = 2;\n\t\thw->join_retries = 60;\n\n\t\t \n\t\tif (wlandev->netdev->type == ARPHRD_ETHER) {\n\t\t\tu16 portstatus;\n\n\t\t\tnetdev_info(wlandev->netdev, \"linkstatus=CONNECTED\\n\");\n\n\t\t\t \n\t\t\t \n\n\t\t\tresult = hfa384x_drvr_getconfig(hw,\n\t\t\t\t\t\t\tHFA384x_RID_CURRENTBSSID,\n\t\t\t\t\t\t\twlandev->bssid,\n\t\t\t\t\t\t\tWLAN_BSSID_LEN);\n\t\t\tif (result) {\n\t\t\t\tpr_debug\n\t\t\t\t    (\"getconfig(0x%02x) failed, result = %d\\n\",\n\t\t\t\t     HFA384x_RID_CURRENTBSSID, result);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresult = hfa384x_drvr_getconfig(hw,\n\t\t\t\t\t\t\tHFA384x_RID_CURRENTSSID,\n\t\t\t\t\t\t\t&ssid, sizeof(ssid));\n\t\t\tif (result) {\n\t\t\t\tpr_debug\n\t\t\t\t    (\"getconfig(0x%02x) failed, result = %d\\n\",\n\t\t\t\t     HFA384x_RID_CURRENTSSID, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprism2mgmt_bytestr2pstr((struct hfa384x_bytestr *)&ssid,\n\t\t\t\t\t\t(struct p80211pstrd *)&wlandev->ssid);\n\n\t\t\t \n\t\t\tresult = hfa384x_drvr_getconfig16(hw,\n\t\t\t\t\t\t\t  HFA384x_RID_PORTSTATUS,\n\t\t\t\t\t\t\t  &portstatus);\n\t\t\tif (result) {\n\t\t\t\tpr_debug\n\t\t\t\t    (\"getconfig(0x%02x) failed, result = %d\\n\",\n\t\t\t\t     HFA384x_RID_PORTSTATUS, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twlandev->macmode =\n\t\t\t    (portstatus == HFA384x_PSTATUS_CONN_IBSS) ?\n\t\t\t    WLAN_MACMODE_IBSS_STA : WLAN_MACMODE_ESS_STA;\n\n\t\t\t \n\t\t\tprism2_connect_result(wlandev, P80211ENUM_truth_false);\n\n\t\t\t \n\t\t\tprism2sta_commsqual_defer(&hw->commsqual_bh);\n\t\t}\n\t\tbreak;\n\n\tcase HFA384x_LINK_DISCONNECTED:\n\t\t \n\t\tif (wlandev->netdev->type == ARPHRD_ETHER)\n\t\t\tnetdev_info(wlandev->netdev,\n\t\t\t\t    \"linkstatus=DISCONNECTED (unhandled)\\n\");\n\t\twlandev->macmode = WLAN_MACMODE_NONE;\n\n\t\tnetif_carrier_off(wlandev->netdev);\n\n\t\t \n\t\tprism2_disconnected(wlandev);\n\n\t\tbreak;\n\n\tcase HFA384x_LINK_AP_CHANGE:\n\t\t \n\t\tnetdev_info(wlandev->netdev, \"linkstatus=AP_CHANGE\\n\");\n\n\t\tresult = hfa384x_drvr_getconfig(hw,\n\t\t\t\t\t\tHFA384x_RID_CURRENTBSSID,\n\t\t\t\t\t\twlandev->bssid, WLAN_BSSID_LEN);\n\t\tif (result) {\n\t\t\tpr_debug(\"getconfig(0x%02x) failed, result = %d\\n\",\n\t\t\t\t HFA384x_RID_CURRENTBSSID, result);\n\t\t\treturn;\n\t\t}\n\n\t\tresult = hfa384x_drvr_getconfig(hw,\n\t\t\t\t\t\tHFA384x_RID_CURRENTSSID,\n\t\t\t\t\t\t&ssid, sizeof(ssid));\n\t\tif (result) {\n\t\t\tpr_debug(\"getconfig(0x%02x) failed, result = %d\\n\",\n\t\t\t\t HFA384x_RID_CURRENTSSID, result);\n\t\t\treturn;\n\t\t}\n\t\tprism2mgmt_bytestr2pstr((struct hfa384x_bytestr *)&ssid,\n\t\t\t\t\t(struct p80211pstrd *)&wlandev->ssid);\n\n\t\thw->link_status = HFA384x_LINK_CONNECTED;\n\t\tnetif_carrier_on(wlandev->netdev);\n\n\t\t \n\t\tprism2_roamed(wlandev);\n\n\t\tbreak;\n\n\tcase HFA384x_LINK_AP_OUTOFRANGE:\n\t\t \n\t\tnetdev_info(wlandev->netdev, \"linkstatus=AP_OUTOFRANGE (unhandled)\\n\");\n\n\t\tnetif_carrier_off(wlandev->netdev);\n\n\t\tbreak;\n\n\tcase HFA384x_LINK_AP_INRANGE:\n\t\t \n\t\tnetdev_info(wlandev->netdev, \"linkstatus=AP_INRANGE\\n\");\n\n\t\thw->link_status = HFA384x_LINK_CONNECTED;\n\t\tnetif_carrier_on(wlandev->netdev);\n\n\t\tbreak;\n\n\tcase HFA384x_LINK_ASSOCFAIL:\n\t\t \n\t\tif (hw->join_ap && --hw->join_retries > 0) {\n\t\t\tstruct hfa384x_join_request_data joinreq;\n\n\t\t\tjoinreq = hw->joinreq;\n\t\t\t \n\t\t\thfa384x_drvr_setconfig(hw,\n\t\t\t\t\t       HFA384x_RID_JOINREQUEST,\n\t\t\t\t\t       &joinreq,\n\t\t\t\t\t       HFA384x_RID_JOINREQUEST_LEN);\n\t\t\tnetdev_info(wlandev->netdev,\n\t\t\t\t    \"linkstatus=ASSOCFAIL (re-submitting join)\\n\");\n\t\t} else {\n\t\t\tnetdev_info(wlandev->netdev, \"linkstatus=ASSOCFAIL (unhandled)\\n\");\n\t\t}\n\n\t\tnetif_carrier_off(wlandev->netdev);\n\n\t\t \n\t\tprism2_connect_result(wlandev, P80211ENUM_truth_true);\n\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tnetdev_warn(wlandev->netdev,\n\t\t\t    \"unknown linkstatus=0x%02x\\n\", hw->link_status);\n\t\treturn;\n\t}\n\n\twlandev->linkstatus = (hw->link_status == HFA384x_LINK_CONNECTED);\n}\n\n \nstatic void prism2sta_inf_linkstatus(struct wlandevice *wlandev,\n\t\t\t\t     struct hfa384x_inf_frame *inf)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\n\thw->link_status_new = le16_to_cpu(inf->info.linkstatus.linkstatus);\n\n\tschedule_work(&hw->link_bh);\n}\n\n \nstatic void prism2sta_inf_assocstatus(struct wlandevice *wlandev,\n\t\t\t\t      struct hfa384x_inf_frame *inf)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\tstruct hfa384x_assoc_status rec;\n\tint i;\n\n\tmemcpy(&rec, &inf->info.assocstatus, sizeof(rec));\n\tle16_to_cpus(&rec.assocstatus);\n\tle16_to_cpus(&rec.reason);\n\n\t \n\n\tfor (i = 0; i < hw->authlist.cnt; i++)\n\t\tif (ether_addr_equal(rec.sta_addr, hw->authlist.addr[i]))\n\t\t\tbreak;\n\n\tif (i >= hw->authlist.cnt) {\n\t\tif (rec.assocstatus != HFA384x_ASSOCSTATUS_AUTHFAIL)\n\t\t\tnetdev_warn(wlandev->netdev,\n\t\t\t\t    \"assocstatus info frame received for non-authenticated station.\\n\");\n\t} else {\n\t\thw->authlist.assoc[i] =\n\t\t    (rec.assocstatus == HFA384x_ASSOCSTATUS_STAASSOC ||\n\t\t     rec.assocstatus == HFA384x_ASSOCSTATUS_REASSOC);\n\n\t\tif (rec.assocstatus == HFA384x_ASSOCSTATUS_AUTHFAIL)\n\t\t\tnetdev_warn(wlandev->netdev,\n\t\t\t\t    \"authfail assocstatus info frame received for authenticated station.\\n\");\n\t}\n}\n\n \nstatic void prism2sta_inf_authreq(struct wlandevice *wlandev,\n\t\t\t\t  struct hfa384x_inf_frame *inf)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(sizeof(*inf));\n\tif (skb) {\n\t\tskb_put(skb, sizeof(*inf));\n\t\tmemcpy(skb->data, inf, sizeof(*inf));\n\t\tskb_queue_tail(&hw->authq, skb);\n\t\tschedule_work(&hw->link_bh);\n\t}\n}\n\nstatic void prism2sta_inf_authreq_defer(struct wlandevice *wlandev,\n\t\t\t\t\tstruct hfa384x_inf_frame *inf)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\tstruct hfa384x_authenticate_station_data rec;\n\n\tint i, added, result, cnt;\n\tu8 *addr;\n\n\t \n\n\tether_addr_copy(rec.address, inf->info.authreq.sta_addr);\n\trec.status = cpu_to_le16(P80211ENUM_status_unspec_failure);\n\n\t \n\n\tswitch (hw->accessmode) {\n\tcase WLAN_ACCESS_NONE:\n\n\t\t \n\n\t\tfor (i = 0; i < hw->authlist.cnt; i++)\n\t\t\tif (ether_addr_equal(rec.address,\n\t\t\t\t\t     hw->authlist.addr[i])) {\n\t\t\t\trec.status = cpu_to_le16(P80211ENUM_status_successful);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tbreak;\n\n\tcase WLAN_ACCESS_ALL:\n\n\t\t \n\n\t\trec.status = cpu_to_le16(P80211ENUM_status_successful);\n\t\tbreak;\n\n\tcase WLAN_ACCESS_ALLOW:\n\n\t\t \n\n\t\tif (hw->allow.modify == 0) {\n\t\t\tcnt = hw->allow.cnt;\n\t\t\taddr = hw->allow.addr[0];\n\t\t} else {\n\t\t\tcnt = hw->allow.cnt1;\n\t\t\taddr = hw->allow.addr1[0];\n\t\t}\n\n\t\tfor (i = 0; i < cnt; i++, addr += ETH_ALEN)\n\t\t\tif (ether_addr_equal(rec.address, addr)) {\n\t\t\t\trec.status = cpu_to_le16(P80211ENUM_status_successful);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tbreak;\n\n\tcase WLAN_ACCESS_DENY:\n\n\t\t \n\n\t\tif (hw->deny.modify == 0) {\n\t\t\tcnt = hw->deny.cnt;\n\t\t\taddr = hw->deny.addr[0];\n\t\t} else {\n\t\t\tcnt = hw->deny.cnt1;\n\t\t\taddr = hw->deny.addr1[0];\n\t\t}\n\n\t\trec.status = cpu_to_le16(P80211ENUM_status_successful);\n\n\t\tfor (i = 0; i < cnt; i++, addr += ETH_ALEN)\n\t\t\tif (ether_addr_equal(rec.address, addr)) {\n\t\t\t\trec.status = cpu_to_le16(P80211ENUM_status_unspec_failure);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tbreak;\n\t}\n\n\t \n\n\tadded = 0;\n\n\tif (rec.status == cpu_to_le16(P80211ENUM_status_successful)) {\n\t\tfor (i = 0; i < hw->authlist.cnt; i++)\n\t\t\tif (ether_addr_equal(rec.address,\n\t\t\t\t\t     hw->authlist.addr[i]))\n\t\t\t\tbreak;\n\n\t\tif (i >= hw->authlist.cnt) {\n\t\t\tif (hw->authlist.cnt >= WLAN_AUTH_MAX) {\n\t\t\t\trec.status = cpu_to_le16(P80211ENUM_status_ap_full);\n\t\t\t} else {\n\t\t\t\tether_addr_copy(hw->authlist.addr[hw->authlist.cnt],\n\t\t\t\t\t\trec.address);\n\t\t\t\thw->authlist.cnt++;\n\t\t\t\tadded = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\trec.algorithm = inf->info.authreq.algorithm;\n\n\tresult = hfa384x_drvr_setconfig(hw, HFA384x_RID_AUTHENTICATESTA,\n\t\t\t\t\t&rec, sizeof(rec));\n\tif (result) {\n\t\tif (added)\n\t\t\thw->authlist.cnt--;\n\t\tnetdev_err(wlandev->netdev,\n\t\t\t   \"setconfig(authenticatestation) failed, result=%d\\n\",\n\t\t\t   result);\n\t}\n}\n\n \nstatic void prism2sta_inf_psusercnt(struct wlandevice *wlandev,\n\t\t\t\t    struct hfa384x_inf_frame *inf)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\n\thw->psusercount = le16_to_cpu(inf->info.psusercnt.usercnt);\n}\n\n \nvoid prism2sta_ev_info(struct wlandevice *wlandev,\n\t\t       struct hfa384x_inf_frame *inf)\n{\n\tle16_to_cpus(&inf->infotype);\n\t \n\tswitch (inf->infotype) {\n\tcase HFA384x_IT_HANDOVERADDR:\n\t\tprism2sta_inf_handover(wlandev, inf);\n\t\tbreak;\n\tcase HFA384x_IT_COMMTALLIES:\n\t\tprism2sta_inf_tallies(wlandev, inf);\n\t\tbreak;\n\tcase HFA384x_IT_HOSTSCANRESULTS:\n\t\tprism2sta_inf_hostscanresults(wlandev, inf);\n\t\tbreak;\n\tcase HFA384x_IT_SCANRESULTS:\n\t\tprism2sta_inf_scanresults(wlandev, inf);\n\t\tbreak;\n\tcase HFA384x_IT_CHINFORESULTS:\n\t\tprism2sta_inf_chinforesults(wlandev, inf);\n\t\tbreak;\n\tcase HFA384x_IT_LINKSTATUS:\n\t\tprism2sta_inf_linkstatus(wlandev, inf);\n\t\tbreak;\n\tcase HFA384x_IT_ASSOCSTATUS:\n\t\tprism2sta_inf_assocstatus(wlandev, inf);\n\t\tbreak;\n\tcase HFA384x_IT_AUTHREQ:\n\t\tprism2sta_inf_authreq(wlandev, inf);\n\t\tbreak;\n\tcase HFA384x_IT_PSUSERCNT:\n\t\tprism2sta_inf_psusercnt(wlandev, inf);\n\t\tbreak;\n\tcase HFA384x_IT_KEYIDCHANGED:\n\t\tnetdev_warn(wlandev->netdev, \"Unhandled IT_KEYIDCHANGED\\n\");\n\t\tbreak;\n\tcase HFA384x_IT_ASSOCREQ:\n\t\tnetdev_warn(wlandev->netdev, \"Unhandled IT_ASSOCREQ\\n\");\n\t\tbreak;\n\tcase HFA384x_IT_MICFAILURE:\n\t\tnetdev_warn(wlandev->netdev, \"Unhandled IT_MICFAILURE\\n\");\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(wlandev->netdev,\n\t\t\t    \"Unknown info type=0x%02x\\n\", inf->infotype);\n\t\tbreak;\n\t}\n}\n\n \nvoid prism2sta_ev_txexc(struct wlandevice *wlandev, u16 status)\n{\n\tpr_debug(\"TxExc status=0x%x.\\n\", status);\n}\n\n \nvoid prism2sta_ev_tx(struct wlandevice *wlandev, u16 status)\n{\n\tpr_debug(\"Tx Complete, status=0x%04x\\n\", status);\n\t \n\twlandev->netdev->stats.tx_packets++;\n}\n\n \nvoid prism2sta_ev_alloc(struct wlandevice *wlandev)\n{\n\tnetif_wake_queue(wlandev->netdev);\n}\n\n \nstatic struct wlandevice *create_wlan(void)\n{\n\tstruct wlandevice *wlandev = NULL;\n\tstruct hfa384x *hw = NULL;\n\n\t \n\twlandev = kzalloc(sizeof(*wlandev), GFP_KERNEL);\n\thw = kzalloc(sizeof(*hw), GFP_KERNEL);\n\n\tif (!wlandev || !hw) {\n\t\tkfree(wlandev);\n\t\tkfree(hw);\n\t\treturn NULL;\n\t}\n\n\t \n\twlandev->nsdname = dev_info;\n\twlandev->msdstate = WLAN_MSD_HWPRESENT_PENDING;\n\twlandev->priv = hw;\n\twlandev->open = prism2sta_open;\n\twlandev->close = prism2sta_close;\n\twlandev->reset = prism2sta_reset;\n\twlandev->txframe = prism2sta_txframe;\n\twlandev->mlmerequest = prism2sta_mlmerequest;\n\twlandev->set_multicast_list = prism2sta_setmulticast;\n\twlandev->tx_timeout = hfa384x_tx_timeout;\n\n\twlandev->nsdcaps = P80211_NSDCAP_HWFRAGMENT | P80211_NSDCAP_AUTOJOIN;\n\n\t \n\thw->dot11_desired_bss_type = 1;\n\n\treturn wlandev;\n}\n\nvoid prism2sta_commsqual_defer(struct work_struct *data)\n{\n\tstruct hfa384x *hw = container_of(data, struct hfa384x, commsqual_bh);\n\tstruct wlandevice *wlandev = hw->wlandev;\n\tstruct hfa384x_bytestr32 ssid;\n\tstruct p80211msg_dot11req_mibget msg;\n\tstruct p80211item_uint32 *mibitem = (struct p80211item_uint32 *)\n\t\t\t\t\t\t&msg.mibattribute.data;\n\tint result = 0;\n\n\tif (hw->wlandev->hwremoved)\n\t\treturn;\n\n\t \n\tif ((wlandev->macmode == WLAN_MACMODE_NONE) ||\n\t    (wlandev->macmode == WLAN_MACMODE_ESS_AP)) {\n\t\treturn;\n\t}\n\n\t \n\tif (wlandev->macmode != WLAN_MACMODE_IBSS_STA) {\n\t\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_DBMCOMMSQUALITY,\n\t\t\t\t\t\t&hw->qual, HFA384x_RID_DBMCOMMSQUALITY_LEN);\n\n\t\tif (result) {\n\t\t\tnetdev_err(wlandev->netdev, \"error fetching commsqual\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tpr_debug(\"commsqual %d %d %d\\n\",\n\t\t\t le16_to_cpu(hw->qual.cq_curr_bss),\n\t\t\t le16_to_cpu(hw->qual.asl_curr_bss),\n\t\t\t le16_to_cpu(hw->qual.anl_curr_fc));\n\t}\n\n\t \n\tmsg.msgcode = DIDMSG_DOT11REQ_MIBGET;\n\tmibitem->did = DIDMIB_P2_MAC_CURRENTTXRATE;\n\tresult = p80211req_dorequest(wlandev, (u8 *)&msg);\n\n\tif (result) {\n\t\tpr_debug(\"get signal rate failed, result = %d\\n\",\n\t\t\t result);\n\t\treturn;\n\t}\n\n\tswitch (mibitem->data) {\n\tcase HFA384x_RATEBIT_1:\n\t\thw->txrate = 10;\n\t\tbreak;\n\tcase HFA384x_RATEBIT_2:\n\t\thw->txrate = 20;\n\t\tbreak;\n\tcase HFA384x_RATEBIT_5dot5:\n\t\thw->txrate = 55;\n\t\tbreak;\n\tcase HFA384x_RATEBIT_11:\n\t\thw->txrate = 110;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Bad ratebit (%d)\\n\", mibitem->data);\n\t}\n\n\t \n\tresult = hfa384x_drvr_getconfig(hw,\n\t\t\t\t\tHFA384x_RID_CURRENTBSSID,\n\t\t\t\t\twlandev->bssid, WLAN_BSSID_LEN);\n\tif (result) {\n\t\tpr_debug(\"getconfig(0x%02x) failed, result = %d\\n\",\n\t\t\t HFA384x_RID_CURRENTBSSID, result);\n\t\treturn;\n\t}\n\n\tresult = hfa384x_drvr_getconfig(hw,\n\t\t\t\t\tHFA384x_RID_CURRENTSSID,\n\t\t\t\t\t&ssid, sizeof(ssid));\n\tif (result) {\n\t\tpr_debug(\"getconfig(0x%02x) failed, result = %d\\n\",\n\t\t\t HFA384x_RID_CURRENTSSID, result);\n\t\treturn;\n\t}\n\tprism2mgmt_bytestr2pstr((struct hfa384x_bytestr *)&ssid,\n\t\t\t\t(struct p80211pstrd *)&wlandev->ssid);\n\n\t \n\tmod_timer(&hw->commsqual_timer, jiffies + HZ);\n}\n\nvoid prism2sta_commsqual_timer(struct timer_list *t)\n{\n\tstruct hfa384x *hw = from_timer(hw, t, commsqual_timer);\n\n\tschedule_work(&hw->commsqual_bh);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}