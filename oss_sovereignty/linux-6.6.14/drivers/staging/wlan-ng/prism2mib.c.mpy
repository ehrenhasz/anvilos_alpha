{
  "module_name": "prism2mib.c",
  "hash_id": "d8d621fcd7bb7c91894e167aa01605ff2e8a7de6c6eb9608e7fbe3af6d83db00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/wlan-ng/prism2mib.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/wireless.h>\n#include <linux/netdevice.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <asm/byteorder.h>\n#include <linux/usb.h>\n#include <linux/bitops.h>\n\n#include \"p80211types.h\"\n#include \"p80211hdr.h\"\n#include \"p80211mgmt.h\"\n#include \"p80211conv.h\"\n#include \"p80211msg.h\"\n#include \"p80211netdev.h\"\n#include \"p80211metadef.h\"\n#include \"p80211metastruct.h\"\n#include \"hfa384x.h\"\n#include \"prism2mgmt.h\"\n\n#define MIB_TMP_MAXLEN    200\t \n\n#define  F_STA        0x1\t \n#define  F_READ       0x2\t \n#define  F_WRITE      0x4\t \n\nstruct mibrec {\n\tu32 did;\n\tu16 flag;\n\tu16 parm1;\n\tu16 parm2;\n\tu16 parm3;\n\tint (*func)(struct mibrec *mib,\n\t\t    int isget,\n\t\t    struct wlandevice *wlandev,\n\t\t    struct hfa384x *hw,\n\t\t    struct p80211msg_dot11req_mibset *msg, void *data);\n};\n\nstatic int prism2mib_bytearea2pstr(struct mibrec *mib,\n\t\t\t\t   int isget,\n\t\t\t\t   struct wlandevice *wlandev,\n\t\t\t\t   struct hfa384x *hw,\n\t\t\t\t   struct p80211msg_dot11req_mibset *msg,\n\t\t\t\t   void *data);\n\nstatic int prism2mib_uint32(struct mibrec *mib,\n\t\t\t    int isget,\n\t\t\t    struct wlandevice *wlandev,\n\t\t\t    struct hfa384x *hw,\n\t\t\t    struct p80211msg_dot11req_mibset *msg, void *data);\n\nstatic int prism2mib_flag(struct mibrec *mib,\n\t\t\t  int isget,\n\t\t\t  struct wlandevice *wlandev,\n\t\t\t  struct hfa384x *hw,\n\t\t\t  struct p80211msg_dot11req_mibset *msg, void *data);\n\nstatic int prism2mib_wepdefaultkey(struct mibrec *mib,\n\t\t\t\t   int isget,\n\t\t\t\t   struct wlandevice *wlandev,\n\t\t\t\t   struct hfa384x *hw,\n\t\t\t\t   struct p80211msg_dot11req_mibset *msg,\n\t\t\t\t   void *data);\n\nstatic int prism2mib_privacyinvoked(struct mibrec *mib,\n\t\t\t\t    int isget,\n\t\t\t\t    struct wlandevice *wlandev,\n\t\t\t\t    struct hfa384x *hw,\n\t\t\t\t    struct p80211msg_dot11req_mibset *msg,\n\t\t\t\t    void *data);\n\nstatic int\nprism2mib_fragmentationthreshold(struct mibrec *mib,\n\t\t\t\t int isget,\n\t\t\t\t struct wlandevice *wlandev,\n\t\t\t\t struct hfa384x *hw,\n\t\t\t\t struct p80211msg_dot11req_mibset *msg,\n\t\t\t\t void *data);\n\nstatic int prism2mib_priv(struct mibrec *mib,\n\t\t\t  int isget,\n\t\t\t  struct wlandevice *wlandev,\n\t\t\t  struct hfa384x *hw,\n\t\t\t  struct p80211msg_dot11req_mibset *msg, void *data);\n\nstatic struct mibrec mibtab[] = {\n\t \n\t{didmib_dot11smt_wepdefaultkeystable_key(1),\n\t F_STA | F_WRITE,\n\t HFA384x_RID_CNFWEPDEFAULTKEY0, 0, 0,\n\t prism2mib_wepdefaultkey},\n\t{didmib_dot11smt_wepdefaultkeystable_key(2),\n\t F_STA | F_WRITE,\n\t HFA384x_RID_CNFWEPDEFAULTKEY1, 0, 0,\n\t prism2mib_wepdefaultkey},\n\t{didmib_dot11smt_wepdefaultkeystable_key(3),\n\t F_STA | F_WRITE,\n\t HFA384x_RID_CNFWEPDEFAULTKEY2, 0, 0,\n\t prism2mib_wepdefaultkey},\n\t{didmib_dot11smt_wepdefaultkeystable_key(4),\n\t F_STA | F_WRITE,\n\t HFA384x_RID_CNFWEPDEFAULTKEY3, 0, 0,\n\t prism2mib_wepdefaultkey},\n\t{DIDMIB_DOT11SMT_PRIVACYTABLE_PRIVACYINVOKED,\n\t F_STA | F_READ | F_WRITE,\n\t HFA384x_RID_CNFWEPFLAGS, HFA384x_WEPFLAGS_PRIVINVOKED, 0,\n\t prism2mib_privacyinvoked},\n\t{DIDMIB_DOT11SMT_PRIVACYTABLE_WEPDEFAULTKEYID,\n\t F_STA | F_READ | F_WRITE,\n\t HFA384x_RID_CNFWEPDEFAULTKEYID, 0, 0,\n\t prism2mib_uint32},\n\t{DIDMIB_DOT11SMT_PRIVACYTABLE_EXCLUDEUNENCRYPTED,\n\t F_STA | F_READ | F_WRITE,\n\t HFA384x_RID_CNFWEPFLAGS, HFA384x_WEPFLAGS_EXCLUDE, 0,\n\t prism2mib_flag},\n\n\t \n\n\t{DIDMIB_DOT11MAC_OPERATIONTABLE_MACADDRESS,\n\t F_STA | F_READ | F_WRITE,\n\t HFA384x_RID_CNFOWNMACADDR, HFA384x_RID_CNFOWNMACADDR_LEN, 0,\n\t prism2mib_bytearea2pstr},\n\t{DIDMIB_DOT11MAC_OPERATIONTABLE_RTSTHRESHOLD,\n\t F_STA | F_READ | F_WRITE,\n\t HFA384x_RID_RTSTHRESH, 0, 0,\n\t prism2mib_uint32},\n\t{DIDMIB_DOT11MAC_OPERATIONTABLE_SHORTRETRYLIMIT,\n\t F_STA | F_READ,\n\t HFA384x_RID_SHORTRETRYLIMIT, 0, 0,\n\t prism2mib_uint32},\n\t{DIDMIB_DOT11MAC_OPERATIONTABLE_LONGRETRYLIMIT,\n\t F_STA | F_READ,\n\t HFA384x_RID_LONGRETRYLIMIT, 0, 0,\n\t prism2mib_uint32},\n\t{DIDMIB_DOT11MAC_OPERATIONTABLE_FRAGMENTATIONTHRESHOLD,\n\t F_STA | F_READ | F_WRITE,\n\t HFA384x_RID_FRAGTHRESH, 0, 0,\n\t prism2mib_fragmentationthreshold},\n\t{DIDMIB_DOT11MAC_OPERATIONTABLE_MAXTRANSMITMSDULIFETIME,\n\t F_STA | F_READ,\n\t HFA384x_RID_MAXTXLIFETIME, 0, 0,\n\t prism2mib_uint32},\n\n\t \n\n\t{DIDMIB_DOT11PHY_DSSSTABLE_CURRENTCHANNEL,\n\t F_STA | F_READ,\n\t HFA384x_RID_CURRENTCHANNEL, 0, 0,\n\t prism2mib_uint32},\n\t{DIDMIB_DOT11PHY_TXPOWERTABLE_CURRENTTXPOWERLEVEL,\n\t F_STA | F_READ | F_WRITE,\n\t HFA384x_RID_TXPOWERMAX, 0, 0,\n\t prism2mib_uint32},\n\n\t \n\n\t{DIDMIB_P2_STATIC_CNFPORTTYPE,\n\t F_STA | F_READ | F_WRITE,\n\t HFA384x_RID_CNFPORTTYPE, 0, 0,\n\t prism2mib_uint32},\n\n\t \n\n\t{DIDMIB_P2_MAC_CURRENTTXRATE,\n\t F_STA | F_READ,\n\t HFA384x_RID_CURRENTTXRATE, 0, 0,\n\t prism2mib_uint32},\n\n\t \n\t{DIDMIB_LNX_CONFIGTABLE_RSNAIE,\n\t F_STA | F_READ | F_WRITE,\n\t HFA384x_RID_CNFWPADATA, 0, 0,\n\t prism2mib_priv},\n\t{0, 0, 0, 0, 0, NULL}\n};\n\n \n\nint prism2mgmt_mibset_mibget(struct wlandevice *wlandev, void *msgp)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\tint result, isget;\n\tstruct mibrec *mib;\n\n\tu16 which;\n\n\tstruct p80211msg_dot11req_mibset *msg = msgp;\n\tstruct p80211itemd *mibitem;\n\n\tmsg->resultcode.status = P80211ENUM_msgitem_status_data_ok;\n\tmsg->resultcode.data = P80211ENUM_resultcode_success;\n\n\t \n\n\twhich = F_STA;\n\n\t \n\n\tmibitem = (struct p80211itemd *)msg->mibattribute.data;\n\n\tfor (mib = mibtab; mib->did != 0; mib++)\n\t\tif (mib->did == mibitem->did && (mib->flag & which))\n\t\t\tbreak;\n\n\tif (mib->did == 0) {\n\t\tmsg->resultcode.data = P80211ENUM_resultcode_not_supported;\n\t\tgoto done;\n\t}\n\n\t \n\n\tisget = (msg->msgcode == DIDMSG_DOT11REQ_MIBGET);\n\n\tif (isget) {\n\t\tif (!(mib->flag & F_READ)) {\n\t\t\tmsg->resultcode.data =\n\t\t\t    P80211ENUM_resultcode_cant_get_writeonly_mib;\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tif (!(mib->flag & F_WRITE)) {\n\t\t\tmsg->resultcode.data =\n\t\t\t    P80211ENUM_resultcode_cant_set_readonly_mib;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\n\tresult = mib->func(mib, isget, wlandev, hw, msg, (void *)mibitem->data);\n\n\tif (msg->resultcode.data == P80211ENUM_resultcode_success) {\n\t\tif (result != 0) {\n\t\t\tpr_debug(\"get/set failure, result=%d\\n\", result);\n\t\t\tmsg->resultcode.data =\n\t\t\t    P80211ENUM_resultcode_implementation_failure;\n\t\t} else {\n\t\t\tif (isget) {\n\t\t\t\tmsg->mibattribute.status =\n\t\t\t\t    P80211ENUM_msgitem_status_data_ok;\n\t\t\t\tmibitem->status =\n\t\t\t\t    P80211ENUM_msgitem_status_data_ok;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\treturn 0;\n}\n\n \n\nstatic int prism2mib_bytearea2pstr(struct mibrec *mib,\n\t\t\t\t   int isget,\n\t\t\t\t   struct wlandevice *wlandev,\n\t\t\t\t   struct hfa384x *hw,\n\t\t\t\t   struct p80211msg_dot11req_mibset *msg,\n\t\t\t\t   void *data)\n{\n\tint result;\n\tstruct p80211pstrd *pstr = data;\n\tu8 bytebuf[MIB_TMP_MAXLEN];\n\n\tif (isget) {\n\t\tresult =\n\t\t    hfa384x_drvr_getconfig(hw, mib->parm1, bytebuf, mib->parm2);\n\t\tprism2mgmt_bytearea2pstr(bytebuf, pstr, mib->parm2);\n\t} else {\n\t\tmemset(bytebuf, 0, mib->parm2);\n\t\tmemcpy(bytebuf, pstr->data, pstr->len);\n\t\tresult =\n\t\t    hfa384x_drvr_setconfig(hw, mib->parm1, bytebuf, mib->parm2);\n\t}\n\n\treturn result;\n}\n\n \n\nstatic int prism2mib_uint32(struct mibrec *mib,\n\t\t\t    int isget,\n\t\t\t    struct wlandevice *wlandev,\n\t\t\t    struct hfa384x *hw,\n\t\t\t    struct p80211msg_dot11req_mibset *msg, void *data)\n{\n\tint result;\n\tu32 *uint32 = data;\n\tu8 bytebuf[MIB_TMP_MAXLEN];\n\tu16 *wordbuf = (u16 *)bytebuf;\n\n\tif (isget) {\n\t\tresult = hfa384x_drvr_getconfig16(hw, mib->parm1, wordbuf);\n\t\t*uint32 = *wordbuf;\n\t} else {\n\t\t*wordbuf = *uint32;\n\t\tresult = hfa384x_drvr_setconfig16(hw, mib->parm1, *wordbuf);\n\t}\n\n\treturn result;\n}\n\n \n\nstatic int prism2mib_flag(struct mibrec *mib,\n\t\t\t  int isget,\n\t\t\t  struct wlandevice *wlandev,\n\t\t\t  struct hfa384x *hw,\n\t\t\t  struct p80211msg_dot11req_mibset *msg, void *data)\n{\n\tint result;\n\tu32 *uint32 = data;\n\tu8 bytebuf[MIB_TMP_MAXLEN];\n\tu16 *wordbuf = (u16 *)bytebuf;\n\tu32 flags;\n\n\tresult = hfa384x_drvr_getconfig16(hw, mib->parm1, wordbuf);\n\tif (result == 0) {\n\t\tflags = *wordbuf;\n\t\tif (isget) {\n\t\t\t*uint32 = (flags & mib->parm2) ?\n\t\t\t    P80211ENUM_truth_true : P80211ENUM_truth_false;\n\t\t} else {\n\t\t\tif ((*uint32) == P80211ENUM_truth_true)\n\t\t\t\tflags |= mib->parm2;\n\t\t\telse\n\t\t\t\tflags &= ~mib->parm2;\n\t\t\t*wordbuf = flags;\n\t\t\tresult =\n\t\t\t    hfa384x_drvr_setconfig16(hw, mib->parm1, *wordbuf);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n \n\nstatic int prism2mib_wepdefaultkey(struct mibrec *mib,\n\t\t\t\t   int isget,\n\t\t\t\t   struct wlandevice *wlandev,\n\t\t\t\t   struct hfa384x *hw,\n\t\t\t\t   struct p80211msg_dot11req_mibset *msg,\n\t\t\t\t   void *data)\n{\n\tint result;\n\tstruct p80211pstrd *pstr = data;\n\tu8 bytebuf[MIB_TMP_MAXLEN];\n\tu16 len;\n\n\tif (isget) {\n\t\tresult = 0;\t \n\t} else {\n\t\tlen = (pstr->len > 5) ? HFA384x_RID_CNFWEP128DEFAULTKEY_LEN :\n\t\t    HFA384x_RID_CNFWEPDEFAULTKEY_LEN;\n\t\tmemset(bytebuf, 0, len);\n\t\tmemcpy(bytebuf, pstr->data, pstr->len);\n\t\tresult = hfa384x_drvr_setconfig(hw, mib->parm1, bytebuf, len);\n\t}\n\n\treturn result;\n}\n\n \n\nstatic int prism2mib_privacyinvoked(struct mibrec *mib,\n\t\t\t\t    int isget,\n\t\t\t\t    struct wlandevice *wlandev,\n\t\t\t\t    struct hfa384x *hw,\n\t\t\t\t    struct p80211msg_dot11req_mibset *msg,\n\t\t\t\t    void *data)\n{\n\tif (wlandev->hostwep & HOSTWEP_DECRYPT) {\n\t\tif (wlandev->hostwep & HOSTWEP_DECRYPT)\n\t\t\tmib->parm2 |= HFA384x_WEPFLAGS_DISABLE_RXCRYPT;\n\t\tif (wlandev->hostwep & HOSTWEP_ENCRYPT)\n\t\t\tmib->parm2 |= HFA384x_WEPFLAGS_DISABLE_TXCRYPT;\n\t}\n\n\treturn prism2mib_flag(mib, isget, wlandev, hw, msg, data);\n}\n\n \n\nstatic int\nprism2mib_fragmentationthreshold(struct mibrec *mib,\n\t\t\t\t int isget,\n\t\t\t\t struct wlandevice *wlandev,\n\t\t\t\t struct hfa384x *hw,\n\t\t\t\t struct p80211msg_dot11req_mibset *msg,\n\t\t\t\t void *data)\n{\n\tu32 *uint32 = data;\n\n\tif (!isget)\n\t\tif ((*uint32) % 2) {\n\t\t\tnetdev_warn(wlandev->netdev,\n\t\t\t\t    \"Attempt to set odd number FragmentationThreshold\\n\");\n\t\t\tmsg->resultcode.data =\n\t\t\t    P80211ENUM_resultcode_not_supported;\n\t\t\treturn 0;\n\t\t}\n\n\treturn prism2mib_uint32(mib, isget, wlandev, hw, msg, data);\n}\n\n \n\nstatic int prism2mib_priv(struct mibrec *mib,\n\t\t\t  int isget,\n\t\t\t  struct wlandevice *wlandev,\n\t\t\t  struct hfa384x *hw,\n\t\t\t  struct p80211msg_dot11req_mibset *msg, void *data)\n{\n\tstruct p80211pstrd *pstr = data;\n\n\tswitch (mib->did) {\n\tcase DIDMIB_LNX_CONFIGTABLE_RSNAIE: {\n\t\t \n\t\tstruct hfa384x_wpa_data wpa;\n\n\t\tif (isget) {\n\t\t\thfa384x_drvr_getconfig(hw,\n\t\t\t\t\t       HFA384x_RID_CNFWPADATA,\n\t\t\t\t\t       (u8 *)&wpa,\n\t\t\t\t\t       sizeof(wpa));\n\t\t\tpstr->len = 0;\n\t\t} else {\n\t\t\twpa.datalen = 0;\n\n\t\t\thfa384x_drvr_setconfig(hw,\n\t\t\t\t\t       HFA384x_RID_CNFWPADATA,\n\t\t\t\t\t       (u8 *)&wpa,\n\t\t\t\t\t       sizeof(wpa));\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tnetdev_err(wlandev->netdev, \"Unhandled DID 0x%08x\\n\", mib->did);\n\t}\n\n\treturn 0;\n}\n\n \n\nvoid prism2mgmt_pstr2bytestr(struct hfa384x_bytestr *bytestr,\n\t\t\t     struct p80211pstrd *pstr)\n{\n\tbytestr->len = cpu_to_le16((u16)(pstr->len));\n\tmemcpy(bytestr->data, pstr->data, pstr->len);\n}\n\n \n\nvoid prism2mgmt_bytestr2pstr(struct hfa384x_bytestr *bytestr,\n\t\t\t     struct p80211pstrd *pstr)\n{\n\tpstr->len = (u8)(le16_to_cpu(bytestr->len));\n\tmemcpy(pstr->data, bytestr->data, pstr->len);\n}\n\n \n\nvoid prism2mgmt_bytearea2pstr(u8 *bytearea, struct p80211pstrd *pstr, int len)\n{\n\tpstr->len = (u8)len;\n\tmemcpy(pstr->data, bytearea, len);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}