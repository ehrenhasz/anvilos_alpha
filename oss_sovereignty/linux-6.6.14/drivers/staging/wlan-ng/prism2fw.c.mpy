{
  "module_name": "prism2fw.c",
  "hash_id": "8ba5d77582c6619ba5bac491333e9d4736a239235e084c8f9cbf6f8551f586db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/wlan-ng/prism2fw.c",
  "human_readable_source": "\n \n\n \n \n#include <linux/ihex.h>\n#include <linux/slab.h>\n\n \n \n\n#define PRISM2_USB_FWFILE\t\"prism2_ru.fw\"\nMODULE_FIRMWARE(PRISM2_USB_FWFILE);\n\n#define S3DATA_MAX\t\t5000\n#define S3PLUG_MAX\t\t200\n#define S3CRC_MAX\t\t200\n#define S3INFO_MAX\t\t50\n\n#define S3ADDR_PLUG\t\t(0xff000000UL)\n#define S3ADDR_CRC\t\t(0xff100000UL)\n#define S3ADDR_INFO\t\t(0xff200000UL)\n#define S3ADDR_START\t\t(0xff400000UL)\n\n#define CHUNKS_MAX\t\t100\n\n#define WRITESIZE_MAX\t\t4096\n\n \n \n\nstruct s3datarec {\n\tu32 len;\n\tu32 addr;\n\tu8 checksum;\n\tu8 *data;\n};\n\nstruct s3plugrec {\n\tu32 itemcode;\n\tu32 addr;\n\tu32 len;\n};\n\nstruct s3crcrec {\n\tu32 addr;\n\tu32 len;\n\tunsigned int dowrite;\n};\n\nstruct s3inforec {\n\tu16 len;\n\tu16 type;\n\tunion {\n\t\tstruct hfa384x_compident version;\n\t\tstruct hfa384x_caplevel compat;\n\t\tu16 buildseq;\n\t\tstruct hfa384x_compident platform;\n\t} info;\n};\n\nstruct pda {\n\tu8 buf[HFA384x_PDA_LEN_MAX];\n\tstruct hfa384x_pdrec *rec[HFA384x_PDA_RECS_MAX];\n\tunsigned int nrec;\n};\n\nstruct imgchunk {\n\tu32 addr;\t \n\tu32 len;\t \n\tu16 crc;\t \n\tu8 *data;\n};\n\n \n \n\n \n \n\n \nstatic unsigned int ns3data;\nstatic struct s3datarec *s3data;\n\n \nstatic unsigned int ns3plug;\nstatic struct s3plugrec s3plug[S3PLUG_MAX];\n\n \nstatic unsigned int ns3crc;\nstatic struct s3crcrec s3crc[S3CRC_MAX];\n\n \nstatic unsigned int ns3info;\nstatic struct s3inforec s3info[S3INFO_MAX];\n\n \nstatic u32 startaddr;\n\n \nstatic unsigned int nfchunks;\nstatic struct imgchunk fchunk[CHUNKS_MAX];\n\n \n \n \n \n \n\nstatic struct pda pda;\nstatic struct hfa384x_compident nicid;\nstatic struct hfa384x_caplevel rfid;\nstatic struct hfa384x_caplevel macid;\nstatic struct hfa384x_caplevel priid;\n\n \n \n\nstatic int prism2_fwapply(const struct ihex_binrec *rfptr,\n\t\t\t  struct wlandevice *wlandev);\n\nstatic int read_fwfile(const struct ihex_binrec *rfptr);\n\nstatic int mkimage(struct imgchunk *clist, unsigned int *ccnt);\n\nstatic int read_cardpda(struct pda *pda, struct wlandevice *wlandev);\n\nstatic int mkpdrlist(struct pda *pda);\n\nstatic int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,\n\t\t     struct s3plugrec *s3plug, unsigned int ns3plug,\n\t\t     struct pda *pda);\n\nstatic int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,\n\t\t    struct s3crcrec *s3crc, unsigned int ns3crc);\n\nstatic int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,\n\t\t      unsigned int nfchunks);\n\nstatic void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks);\n\nstatic void free_srecs(void);\n\nstatic int validate_identity(void);\n\n \n \n\n \nstatic int prism2_fwtry(struct usb_device *udev, struct wlandevice *wlandev)\n{\n\tconst struct firmware *fw_entry = NULL;\n\n\tnetdev_info(wlandev->netdev, \"prism2_usb: Checking for firmware %s\\n\",\n\t\t    PRISM2_USB_FWFILE);\n\tif (request_ihex_firmware(&fw_entry,\n\t\t\t\t  PRISM2_USB_FWFILE, &udev->dev) != 0) {\n\t\tnetdev_info(wlandev->netdev,\n\t\t\t    \"prism2_usb: Firmware not available, but not essential\\n\");\n\t\tnetdev_info(wlandev->netdev,\n\t\t\t    \"prism2_usb: can continue to use card anyway.\\n\");\n\t\treturn 1;\n\t}\n\n\tnetdev_info(wlandev->netdev,\n\t\t    \"prism2_usb: %s will be processed, size %zu\\n\",\n\t\t    PRISM2_USB_FWFILE, fw_entry->size);\n\tprism2_fwapply((const struct ihex_binrec *)fw_entry->data, wlandev);\n\n\trelease_firmware(fw_entry);\n\treturn 0;\n}\n\n \nstatic int prism2_fwapply(const struct ihex_binrec *rfptr,\n\t\t\t  struct wlandevice *wlandev)\n{\n\tsigned int result = 0;\n\tstruct p80211msg_dot11req_mibget getmsg;\n\tstruct p80211itemd *item;\n\tu32 *data;\n\n\t \n\tns3data = 0;\n\ts3data = kcalloc(S3DATA_MAX, sizeof(*s3data), GFP_KERNEL);\n\tif (!s3data) {\n\t\tresult = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tns3plug = 0;\n\tmemset(s3plug, 0, sizeof(s3plug));\n\tns3crc = 0;\n\tmemset(s3crc, 0, sizeof(s3crc));\n\tns3info = 0;\n\tmemset(s3info, 0, sizeof(s3info));\n\tstartaddr = 0;\n\n\tnfchunks = 0;\n\tmemset(fchunk, 0, sizeof(fchunk));\n\tmemset(&nicid, 0, sizeof(nicid));\n\tmemset(&rfid, 0, sizeof(rfid));\n\tmemset(&macid, 0, sizeof(macid));\n\tmemset(&priid, 0, sizeof(priid));\n\n\t \n\tmemset(&pda, 0, sizeof(pda));\n\tpda.rec[0] = (struct hfa384x_pdrec *)pda.buf;\n\tpda.rec[0]->len = cpu_to_le16(2);\t \n\tpda.rec[0]->code = cpu_to_le16(HFA384x_PDR_END_OF_PDA);\n\tpda.nrec = 1;\n\n\t \n\t \n\tprism2sta_ifstate(wlandev, P80211ENUM_ifstate_fwload);\n\n\t \n\tif (read_cardpda(&pda, wlandev)) {\n\t\tnetdev_err(wlandev->netdev, \"load_cardpda failed, exiting.\\n\");\n\t\tresult = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tmemset(&getmsg, 0, sizeof(getmsg));\n\tgetmsg.msgcode = DIDMSG_DOT11REQ_MIBGET;\n\tgetmsg.msglen = sizeof(getmsg);\n\tstrscpy(getmsg.devname, wlandev->name, sizeof(getmsg.devname));\n\n\tgetmsg.mibattribute.did = DIDMSG_DOT11REQ_MIBGET_MIBATTRIBUTE;\n\tgetmsg.mibattribute.status = P80211ENUM_msgitem_status_data_ok;\n\tgetmsg.resultcode.did = DIDMSG_DOT11REQ_MIBGET_RESULTCODE;\n\tgetmsg.resultcode.status = P80211ENUM_msgitem_status_no_value;\n\n\titem = (struct p80211itemd *)getmsg.mibattribute.data;\n\titem->did = DIDMIB_P2_NIC_PRISUPRANGE;\n\titem->status = P80211ENUM_msgitem_status_no_value;\n\n\tdata = (u32 *)item->data;\n\n\t \n\tprism2mgmt_mibset_mibget(wlandev, &getmsg);\n\tif (getmsg.resultcode.data != P80211ENUM_resultcode_success)\n\t\tnetdev_err(wlandev->netdev, \"Couldn't fetch PRI-SUP info\\n\");\n\n\t \n\tpriid.role = *data++;\n\tpriid.id = *data++;\n\tpriid.variant = *data++;\n\tpriid.bottom = *data++;\n\tpriid.top = *data++;\n\n\t \n\tresult = read_fwfile(rfptr);\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev,\n\t\t\t   \"Failed to read the data exiting.\\n\");\n\t\tgoto out;\n\t}\n\n\tresult = validate_identity();\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Incompatible firmware image.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (startaddr == 0x00000000) {\n\t\tnetdev_err(wlandev->netdev,\n\t\t\t   \"Can't RAM download a Flash image!\\n\");\n\t\tresult = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tresult = mkimage(fchunk, &nfchunks);\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to make image chunk.\\n\");\n\t\tgoto free_chunks;\n\t}\n\n\t \n\tresult = plugimage(fchunk, nfchunks, s3plug, ns3plug, &pda);\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to plug data.\\n\");\n\t\tgoto free_chunks;\n\t}\n\n\t \n\tresult = crcimage(fchunk, nfchunks, s3crc, ns3crc);\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to insert all CRCs\\n\");\n\t\tgoto free_chunks;\n\t}\n\n\t \n\tresult = writeimage(wlandev, fchunk, nfchunks);\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev, \"Failed to ramwrite image data.\\n\");\n\t\tgoto free_chunks;\n\t}\n\n\tnetdev_info(wlandev->netdev, \"prism2_usb: firmware loading finished.\\n\");\n\nfree_chunks:\n\t \n\tfree_chunks(fchunk, &nfchunks);\n\tfree_srecs();\n\nout:\n\treturn result;\n}\n\n \nstatic int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,\n\t\t    struct s3crcrec *s3crc, unsigned int ns3crc)\n{\n\tint result = 0;\n\tint i;\n\tint c;\n\tu32 crcstart;\n\tu32 cstart = 0;\n\tu32 cend;\n\tu8 *dest;\n\tu32 chunkoff;\n\n\tfor (i = 0; i < ns3crc; i++) {\n\t\tif (!s3crc[i].dowrite)\n\t\t\tcontinue;\n\t\tcrcstart = s3crc[i].addr;\n\t\t \n\t\tfor (c = 0; c < nfchunks; c++) {\n\t\t\tcstart = fchunk[c].addr;\n\t\t\tcend = fchunk[c].addr + fchunk[c].len;\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\n\t\t\t \n\t\t\t \n\t\t\tif (crcstart - 2 >= cstart && crcstart < cend)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (c >= nfchunks) {\n\t\t\tpr_err(\"Failed to find chunk for crcrec[%d], addr=0x%06x len=%d , aborting crc.\\n\",\n\t\t\t       i, s3crc[i].addr, s3crc[i].len);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tpr_debug(\"Adding crc @ 0x%06x\\n\", s3crc[i].addr - 2);\n\t\tchunkoff = crcstart - cstart - 2;\n\t\tdest = fchunk[c].data + chunkoff;\n\t\t*dest = 0xde;\n\t\t*(dest + 1) = 0xc0;\n\t}\n\treturn result;\n}\n\n \nstatic void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks)\n{\n\tint i;\n\n\tfor (i = 0; i < *nfchunks; i++)\n\t\tkfree(fchunk[i].data);\n\n\t*nfchunks = 0;\n\tmemset(fchunk, 0, sizeof(*fchunk));\n}\n\n \nstatic void free_srecs(void)\n{\n\tns3data = 0;\n\tkfree(s3data);\n\tns3plug = 0;\n\tmemset(s3plug, 0, sizeof(s3plug));\n\tns3crc = 0;\n\tmemset(s3crc, 0, sizeof(s3crc));\n\tns3info = 0;\n\tmemset(s3info, 0, sizeof(s3info));\n\tstartaddr = 0;\n}\n\n \nstatic int mkimage(struct imgchunk *clist, unsigned int *ccnt)\n{\n\tint result = 0;\n\tint i;\n\tint j;\n\tint currchunk = 0;\n\tu32 nextaddr = 0;\n\tu32 s3start;\n\tu32 s3end;\n\tu32 cstart = 0;\n\tu32 cend;\n\tu32 coffset;\n\n\t \n\t*ccnt = 0;\n\n\t \n\tfor (i = 0; i < ns3data; i++) {\n\t\tif (s3data[i].addr == nextaddr) {\n\t\t\t \n\t\t\tclist[currchunk].len += s3data[i].len;\n\t\t\tnextaddr += s3data[i].len;\n\t\t} else {\n\t\t\t \n\t\t\t(*ccnt)++;\n\t\t\tcurrchunk = *ccnt - 1;\n\t\t\tclist[currchunk].addr = s3data[i].addr;\n\t\t\tclist[currchunk].len = s3data[i].len;\n\t\t\tnextaddr = s3data[i].addr + s3data[i].len;\n\t\t\t \n\t\t\t \n\t\t\tfor (j = 0; j < ns3crc; j++) {\n\t\t\t\tif (s3crc[j].dowrite &&\n\t\t\t\t    s3crc[j].addr == clist[currchunk].addr) {\n\t\t\t\t\tclist[currchunk].addr -= 2;\n\t\t\t\t\tclist[currchunk].len += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\t \n\n\t \n\tfor (i = 0; i < *ccnt; i++) {\n\t\tclist[i].data = kzalloc(clist[i].len, GFP_KERNEL);\n\t\tif (!clist[i].data)\n\t\t\treturn 1;\n\n\t\tpr_debug(\"chunk[%d]: addr=0x%06x len=%d\\n\",\n\t\t\t i, clist[i].addr, clist[i].len);\n\t}\n\n\t \n\tfor (i = 0; i < ns3data; i++) {\n\t\ts3start = s3data[i].addr;\n\t\ts3end = s3start + s3data[i].len - 1;\n\t\tfor (j = 0; j < *ccnt; j++) {\n\t\t\tcstart = clist[j].addr;\n\t\t\tcend = cstart + clist[j].len - 1;\n\t\t\tif (s3start >= cstart && s3end <= cend)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (((unsigned int)j) >= (*ccnt)) {\n\t\t\tpr_err(\"s3rec(a=0x%06x,l=%d), no chunk match, exiting.\\n\",\n\t\t\t       s3start, s3data[i].len);\n\t\t\treturn 1;\n\t\t}\n\t\tcoffset = s3start - cstart;\n\t\tmemcpy(clist[j].data + coffset, s3data[i].data, s3data[i].len);\n\t}\n\n\treturn result;\n}\n\n \nstatic int mkpdrlist(struct pda *pda)\n{\n\t__le16 *pda16 = (__le16 *)pda->buf;\n\tint curroff;\t\t \n\n\tpda->nrec = 0;\n\tcurroff = 0;\n\twhile (curroff < (HFA384x_PDA_LEN_MAX / 2 - 1) &&\n\t       le16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {\n\t\tpda->rec[pda->nrec] = (struct hfa384x_pdrec *)&pda16[curroff];\n\n\t\tif (le16_to_cpu(pda->rec[pda->nrec]->code) ==\n\t\t    HFA384x_PDR_NICID) {\n\t\t\tmemcpy(&nicid, &pda->rec[pda->nrec]->data.nicid,\n\t\t\t       sizeof(nicid));\n\t\t\tle16_to_cpus(&nicid.id);\n\t\t\tle16_to_cpus(&nicid.variant);\n\t\t\tle16_to_cpus(&nicid.major);\n\t\t\tle16_to_cpus(&nicid.minor);\n\t\t}\n\t\tif (le16_to_cpu(pda->rec[pda->nrec]->code) ==\n\t\t    HFA384x_PDR_MFISUPRANGE) {\n\t\t\tmemcpy(&rfid, &pda->rec[pda->nrec]->data.mfisuprange,\n\t\t\t       sizeof(rfid));\n\t\t\tle16_to_cpus(&rfid.id);\n\t\t\tle16_to_cpus(&rfid.variant);\n\t\t\tle16_to_cpus(&rfid.bottom);\n\t\t\tle16_to_cpus(&rfid.top);\n\t\t}\n\t\tif (le16_to_cpu(pda->rec[pda->nrec]->code) ==\n\t\t    HFA384x_PDR_CFISUPRANGE) {\n\t\t\tmemcpy(&macid, &pda->rec[pda->nrec]->data.cfisuprange,\n\t\t\t       sizeof(macid));\n\t\t\tle16_to_cpus(&macid.id);\n\t\t\tle16_to_cpus(&macid.variant);\n\t\t\tle16_to_cpus(&macid.bottom);\n\t\t\tle16_to_cpus(&macid.top);\n\t\t}\n\n\t\t(pda->nrec)++;\n\t\tcurroff += le16_to_cpu(pda16[curroff]) + 1;\n\t}\n\tif (curroff >= (HFA384x_PDA_LEN_MAX / 2 - 1)) {\n\t\tpr_err(\"no end record found or invalid lengths in PDR data, exiting. %x %d\\n\",\n\t\t       curroff, pda->nrec);\n\t\treturn 1;\n\t}\n\tpda->rec[pda->nrec] = (struct hfa384x_pdrec *)&pda16[curroff];\n\t(pda->nrec)++;\n\treturn 0;\n}\n\n \nstatic int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,\n\t\t     struct s3plugrec *s3plug, unsigned int ns3plug,\n\t\t     struct pda *pda)\n{\n\tint result = 0;\n\tint i;\t\t\t \n\tint j;\t\t\t \n\tint c;\t\t\t \n\tu32 pstart;\n\tu32 pend;\n\tu32 cstart = 0;\n\tu32 cend;\n\tu32 chunkoff;\n\tu8 *dest;\n\n\t \n\tfor (i = 0; i < ns3plug; i++) {\n\t\tpstart = s3plug[i].addr;\n\t\tpend = s3plug[i].addr + s3plug[i].len;\n\t\tj = -1;\n\t\t \n\t\tif (s3plug[i].itemcode != 0xffffffffUL) {  \n\t\t\tfor (j = 0; j < pda->nrec; j++) {\n\t\t\t\tif (s3plug[i].itemcode ==\n\t\t\t\t    le16_to_cpu(pda->rec[j]->code))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= pda->nrec && j != -1) {  \n\t\t\tpr_warn(\"warning: Failed to find PDR for plugrec 0x%04x.\\n\",\n\t\t\t\ts3plug[i].itemcode);\n\t\t\tcontinue;\t \n\n\t\t\t \n\t\t}\n\n\t\t \n\t\tif (j != -1 && s3plug[i].len < le16_to_cpu(pda->rec[j]->len)) {\n\t\t\tpr_err(\"error: Plug vs. PDR len mismatch for plugrec 0x%04x, abort plugging.\\n\",\n\t\t\t       s3plug[i].itemcode);\n\t\t\tresult = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (c = 0; c < nfchunks; c++) {\n\t\t\tcstart = fchunk[c].addr;\n\t\t\tcend = fchunk[c].addr + fchunk[c].len;\n\t\t\tif (pstart >= cstart && pend <= cend)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (c >= nfchunks) {\n\t\t\tpr_err(\"error: Failed to find image chunk for plugrec 0x%04x.\\n\",\n\t\t\t       s3plug[i].itemcode);\n\t\t\tresult = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tchunkoff = pstart - cstart;\n\t\tdest = fchunk[c].data + chunkoff;\n\t\tpr_debug(\"Plugging item 0x%04x @ 0x%06x, len=%d, cnum=%d coff=0x%06x\\n\",\n\t\t\t s3plug[i].itemcode, pstart, s3plug[i].len,\n\t\t\t c, chunkoff);\n\n\t\tif (j == -1) {\t \n\t\t\tmemset(dest, 0, s3plug[i].len);\n\t\t\tstrncpy(dest, PRISM2_USB_FWFILE, s3plug[i].len - 1);\n\t\t} else {\t \n\t\t\tmemcpy(dest, &pda->rec[j]->data, s3plug[i].len);\n\t\t}\n\t}\n\treturn result;\n}\n\n \nstatic int read_cardpda(struct pda *pda, struct wlandevice *wlandev)\n{\n\tint result = 0;\n\tstruct p80211msg_p2req_readpda *msg;\n\n\tmsg = kzalloc(sizeof(*msg), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\t \n\tmsg->msgcode = DIDMSG_P2REQ_READPDA;\n\tmsg->msglen = sizeof(msg);\n\tstrscpy(msg->devname, wlandev->name, sizeof(msg->devname));\n\tmsg->pda.did = DIDMSG_P2REQ_READPDA_PDA;\n\tmsg->pda.len = HFA384x_PDA_LEN_MAX;\n\tmsg->pda.status = P80211ENUM_msgitem_status_no_value;\n\tmsg->resultcode.did = DIDMSG_P2REQ_READPDA_RESULTCODE;\n\tmsg->resultcode.len = sizeof(u32);\n\tmsg->resultcode.status = P80211ENUM_msgitem_status_no_value;\n\n\tif (prism2mgmt_readpda(wlandev, msg) != 0) {\n\t\t \n\t\tresult = -1;\n\t} else if (msg->resultcode.data == P80211ENUM_resultcode_success) {\n\t\tmemcpy(pda->buf, msg->pda.data, HFA384x_PDA_LEN_MAX);\n\t\tresult = mkpdrlist(pda);\n\t} else {\n\t\t \n\t\tresult = -1;\n\t}\n\n\tkfree(msg);\n\treturn result;\n}\n\n \nstatic int read_fwfile(const struct ihex_binrec *record)\n{\n\tint\t\ti;\n\tint\t\trcnt = 0;\n\tu16\t\t*tmpinfo;\n\tu16\t\t*ptr16;\n\tu32\t\t*ptr32, len, addr;\n\n\tpr_debug(\"Reading fw file ...\\n\");\n\n\twhile (record) {\n\t\trcnt++;\n\n\t\tlen = be16_to_cpu(record->len);\n\t\taddr = be32_to_cpu(record->addr);\n\n\t\t \n\t\tptr32 = (u32 *)record->data;\n\t\tptr16 = (u16 *)record->data;\n\n\t\t \n\t\tswitch (addr) {\n\t\tcase S3ADDR_START:\n\t\t\tstartaddr = *ptr32;\n\t\t\tpr_debug(\"  S7 start addr, record=%d addr=0x%08x\\n\",\n\t\t\t\t rcnt,\n\t\t\t\t startaddr);\n\t\t\tbreak;\n\t\tcase S3ADDR_PLUG:\n\t\t\ts3plug[ns3plug].itemcode = *ptr32;\n\t\t\ts3plug[ns3plug].addr = *(ptr32 + 1);\n\t\t\ts3plug[ns3plug].len = *(ptr32 + 2);\n\n\t\t\tpr_debug(\"  S3 plugrec, record=%d itemcode=0x%08x addr=0x%08x len=%d\\n\",\n\t\t\t\t rcnt,\n\t\t\t\t s3plug[ns3plug].itemcode,\n\t\t\t\t s3plug[ns3plug].addr,\n\t\t\t\t s3plug[ns3plug].len);\n\n\t\t\tns3plug++;\n\t\t\tif (ns3plug == S3PLUG_MAX) {\n\t\t\t\tpr_err(\"S3 plugrec limit reached - aborting\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase S3ADDR_CRC:\n\t\t\ts3crc[ns3crc].addr = *ptr32;\n\t\t\ts3crc[ns3crc].len = *(ptr32 + 1);\n\t\t\ts3crc[ns3crc].dowrite = *(ptr32 + 2);\n\n\t\t\tpr_debug(\"  S3 crcrec, record=%d addr=0x%08x len=%d write=0x%08x\\n\",\n\t\t\t\t rcnt,\n\t\t\t\t s3crc[ns3crc].addr,\n\t\t\t\t s3crc[ns3crc].len,\n\t\t\t\t s3crc[ns3crc].dowrite);\n\t\t\tns3crc++;\n\t\t\tif (ns3crc == S3CRC_MAX) {\n\t\t\t\tpr_err(\"S3 crcrec limit reached - aborting\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase S3ADDR_INFO:\n\t\t\ts3info[ns3info].len = *ptr16;\n\t\t\ts3info[ns3info].type = *(ptr16 + 1);\n\n\t\t\tpr_debug(\"  S3 inforec, record=%d len=0x%04x type=0x%04x\\n\",\n\t\t\t\t rcnt,\n\t\t\t\t s3info[ns3info].len,\n\t\t\t\t s3info[ns3info].type);\n\t\t\tif (((s3info[ns3info].len - 1) * sizeof(u16)) >\n\t\t\t   sizeof(s3info[ns3info].info)) {\n\t\t\t\tpr_err(\"S3 inforec length too long - aborting\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\ttmpinfo = (u16 *)&s3info[ns3info].info.version;\n\t\t\tpr_debug(\"            info=\");\n\t\t\tfor (i = 0; i < s3info[ns3info].len - 1; i++) {\n\t\t\t\ttmpinfo[i] = *(ptr16 + 2 + i);\n\t\t\t\tpr_debug(\"%04x \", tmpinfo[i]);\n\t\t\t}\n\t\t\tpr_debug(\"\\n\");\n\n\t\t\tns3info++;\n\t\t\tif (ns3info == S3INFO_MAX) {\n\t\t\t\tpr_err(\"S3 inforec limit reached - aborting\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\t \n\t\t\ts3data[ns3data].addr = addr;\n\t\t\ts3data[ns3data].len = len;\n\t\t\ts3data[ns3data].data = (uint8_t *)record->data;\n\t\t\tns3data++;\n\t\t\tif (ns3data == S3DATA_MAX) {\n\t\t\t\tpr_err(\"S3 datarec limit reached - aborting\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\trecord = ihex_next_binrec(record);\n\t}\n\treturn 0;\n}\n\n \nstatic int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,\n\t\t      unsigned int nfchunks)\n{\n\tint result = 0;\n\tstruct p80211msg_p2req_ramdl_state *rstmsg;\n\tstruct p80211msg_p2req_ramdl_write *rwrmsg;\n\tu32 resultcode;\n\tint i;\n\tint j;\n\tunsigned int nwrites;\n\tu32 curroff;\n\tu32 currlen;\n\tu32 currdaddr;\n\n\trstmsg = kzalloc(sizeof(*rstmsg), GFP_KERNEL);\n\trwrmsg = kzalloc(sizeof(*rwrmsg), GFP_KERNEL);\n\tif (!rstmsg || !rwrmsg) {\n\t\tnetdev_err(wlandev->netdev,\n\t\t\t   \"%s: no memory for firmware download, aborting download\\n\",\n\t\t\t   __func__);\n\t\tresult = -ENOMEM;\n\t\tgoto free_result;\n\t}\n\n\t \n\tstrscpy(rstmsg->devname, wlandev->name, sizeof(rstmsg->devname));\n\trstmsg->msgcode = DIDMSG_P2REQ_RAMDL_STATE;\n\trstmsg->msglen = sizeof(*rstmsg);\n\trstmsg->enable.did = DIDMSG_P2REQ_RAMDL_STATE_ENABLE;\n\trstmsg->exeaddr.did = DIDMSG_P2REQ_RAMDL_STATE_EXEADDR;\n\trstmsg->resultcode.did = DIDMSG_P2REQ_RAMDL_STATE_RESULTCODE;\n\trstmsg->enable.status = P80211ENUM_msgitem_status_data_ok;\n\trstmsg->exeaddr.status = P80211ENUM_msgitem_status_data_ok;\n\trstmsg->resultcode.status = P80211ENUM_msgitem_status_no_value;\n\trstmsg->enable.len = sizeof(u32);\n\trstmsg->exeaddr.len = sizeof(u32);\n\trstmsg->resultcode.len = sizeof(u32);\n\n\tstrscpy(rwrmsg->devname, wlandev->name, sizeof(rwrmsg->devname));\n\trwrmsg->msgcode = DIDMSG_P2REQ_RAMDL_WRITE;\n\trwrmsg->msglen = sizeof(*rwrmsg);\n\trwrmsg->addr.did = DIDMSG_P2REQ_RAMDL_WRITE_ADDR;\n\trwrmsg->len.did = DIDMSG_P2REQ_RAMDL_WRITE_LEN;\n\trwrmsg->data.did = DIDMSG_P2REQ_RAMDL_WRITE_DATA;\n\trwrmsg->resultcode.did = DIDMSG_P2REQ_RAMDL_WRITE_RESULTCODE;\n\trwrmsg->addr.status = P80211ENUM_msgitem_status_data_ok;\n\trwrmsg->len.status = P80211ENUM_msgitem_status_data_ok;\n\trwrmsg->data.status = P80211ENUM_msgitem_status_data_ok;\n\trwrmsg->resultcode.status = P80211ENUM_msgitem_status_no_value;\n\trwrmsg->addr.len = sizeof(u32);\n\trwrmsg->len.len = sizeof(u32);\n\trwrmsg->data.len = WRITESIZE_MAX;\n\trwrmsg->resultcode.len = sizeof(u32);\n\n\t \n\tpr_debug(\"Sending dl_state(enable) message.\\n\");\n\trstmsg->enable.data = P80211ENUM_truth_true;\n\trstmsg->exeaddr.data = startaddr;\n\n\tresult = prism2mgmt_ramdl_state(wlandev, rstmsg);\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev,\n\t\t\t   \"%s state enable failed w/ result=%d, aborting download\\n\",\n\t\t\t   __func__, result);\n\t\tgoto free_result;\n\t}\n\tresultcode = rstmsg->resultcode.data;\n\tif (resultcode != P80211ENUM_resultcode_success) {\n\t\tnetdev_err(wlandev->netdev,\n\t\t\t   \"%s()->xxxdl_state msg indicates failure, w/ resultcode=%d, aborting download.\\n\",\n\t\t\t   __func__, resultcode);\n\t\tresult = 1;\n\t\tgoto free_result;\n\t}\n\n\t \n\tfor (i = 0; i < nfchunks; i++) {\n\t\tnwrites = fchunk[i].len / WRITESIZE_MAX;\n\t\tnwrites += (fchunk[i].len % WRITESIZE_MAX) ? 1 : 0;\n\t\tcurroff = 0;\n\t\tfor (j = 0; j < nwrites; j++) {\n\t\t\t \n\t\t\tint lenleft = fchunk[i].len - (WRITESIZE_MAX * j);\n\n\t\t\tif (fchunk[i].len > WRITESIZE_MAX)\n\t\t\t\tcurrlen = WRITESIZE_MAX;\n\t\t\telse\n\t\t\t\tcurrlen = lenleft;\n\t\t\tcurroff = j * WRITESIZE_MAX;\n\t\t\tcurrdaddr = fchunk[i].addr + curroff;\n\t\t\t \n\t\t\trwrmsg->addr.data = currdaddr;\n\t\t\trwrmsg->len.data = currlen;\n\t\t\tmemcpy(rwrmsg->data.data,\n\t\t\t       fchunk[i].data + curroff, currlen);\n\n\t\t\t \n\t\t\tpr_debug\n\t\t\t    (\"Sending xxxdl_write message addr=%06x len=%d.\\n\",\n\t\t\t     currdaddr, currlen);\n\n\t\t\tresult = prism2mgmt_ramdl_write(wlandev, rwrmsg);\n\n\t\t\t \n\t\t\tif (result) {\n\t\t\t\tnetdev_err(wlandev->netdev,\n\t\t\t\t\t   \"%s chunk write failed w/ result=%d, aborting download\\n\",\n\t\t\t\t\t   __func__, result);\n\t\t\t\tgoto free_result;\n\t\t\t}\n\t\t\tresultcode = rstmsg->resultcode.data;\n\t\t\tif (resultcode != P80211ENUM_resultcode_success) {\n\t\t\t\tpr_err(\"%s()->xxxdl_write msg indicates failure, w/ resultcode=%d, aborting download.\\n\",\n\t\t\t\t       __func__, resultcode);\n\t\t\t\tresult = 1;\n\t\t\t\tgoto free_result;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tpr_debug(\"Sending dl_state(disable) message.\\n\");\n\trstmsg->enable.data = P80211ENUM_truth_false;\n\trstmsg->exeaddr.data = 0;\n\n\tresult = prism2mgmt_ramdl_state(wlandev, rstmsg);\n\tif (result) {\n\t\tnetdev_err(wlandev->netdev,\n\t\t\t   \"%s state disable failed w/ result=%d, aborting download\\n\",\n\t\t\t   __func__, result);\n\t\tgoto free_result;\n\t}\n\tresultcode = rstmsg->resultcode.data;\n\tif (resultcode != P80211ENUM_resultcode_success) {\n\t\tnetdev_err(wlandev->netdev,\n\t\t\t   \"%s()->xxxdl_state msg indicates failure, w/ resultcode=%d, aborting download.\\n\",\n\t\t\t   __func__, resultcode);\n\t\tresult = 1;\n\t\tgoto free_result;\n\t}\n\nfree_result:\n\tkfree(rstmsg);\n\tkfree(rwrmsg);\n\treturn result;\n}\n\nstatic int validate_identity(void)\n{\n\tint i;\n\tint result = 1;\n\tint trump = 0;\n\n\tpr_debug(\"NIC ID: %#x v%d.%d.%d\\n\",\n\t\t nicid.id, nicid.major, nicid.minor, nicid.variant);\n\tpr_debug(\"MFI ID: %#x v%d %d->%d\\n\",\n\t\t rfid.id, rfid.variant, rfid.bottom, rfid.top);\n\tpr_debug(\"CFI ID: %#x v%d %d->%d\\n\",\n\t\t macid.id, macid.variant, macid.bottom, macid.top);\n\tpr_debug(\"PRI ID: %#x v%d %d->%d\\n\",\n\t\t priid.id, priid.variant, priid.bottom, priid.top);\n\n\tfor (i = 0; i < ns3info; i++) {\n\t\tswitch (s3info[i].type) {\n\t\tcase 1:\n\t\t\tpr_debug(\"Version:  ID %#x %d.%d.%d\\n\",\n\t\t\t\t s3info[i].info.version.id,\n\t\t\t\t s3info[i].info.version.major,\n\t\t\t\t s3info[i].info.version.minor,\n\t\t\t\t s3info[i].info.version.variant);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpr_debug(\"Compat: Role %#x Id %#x v%d %d->%d\\n\",\n\t\t\t\t s3info[i].info.compat.role,\n\t\t\t\t s3info[i].info.compat.id,\n\t\t\t\t s3info[i].info.compat.variant,\n\t\t\t\t s3info[i].info.compat.bottom,\n\t\t\t\t s3info[i].info.compat.top);\n\n\t\t\t \n\t\t\tif ((s3info[i].info.compat.role == 1) &&\n\t\t\t    (s3info[i].info.compat.id == 2)) {\n\t\t\t\tif (s3info[i].info.compat.variant !=\n\t\t\t\t    macid.variant) {\n\t\t\t\t\tresult = 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((s3info[i].info.compat.role == 1) &&\n\t\t\t    (s3info[i].info.compat.id == 3)) {\n\t\t\t\tif ((s3info[i].info.compat.bottom >\n\t\t\t\t     priid.top) ||\n\t\t\t\t    (s3info[i].info.compat.top <\n\t\t\t\t     priid.bottom)) {\n\t\t\t\t\tresult = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif ((s3info[i].info.compat.role == 1) &&\n\t\t\t    (s3info[i].info.compat.id == 4)) {\n\t\t\t\t \n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpr_debug(\"Seq: %#x\\n\", s3info[i].info.buildseq);\n\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpr_debug(\"Platform:  ID %#x %d.%d.%d\\n\",\n\t\t\t\t s3info[i].info.version.id,\n\t\t\t\t s3info[i].info.version.major,\n\t\t\t\t s3info[i].info.version.minor,\n\t\t\t\t s3info[i].info.version.variant);\n\n\t\t\tif (nicid.id != s3info[i].info.version.id)\n\t\t\t\tcontinue;\n\t\t\tif (nicid.major != s3info[i].info.version.major)\n\t\t\t\tcontinue;\n\t\t\tif (nicid.minor != s3info[i].info.version.minor)\n\t\t\t\tcontinue;\n\t\t\tif ((nicid.variant != s3info[i].info.version.variant) &&\n\t\t\t    (nicid.id != 0x8008))\n\t\t\t\tcontinue;\n\n\t\t\ttrump = 1;\n\t\t\tbreak;\n\t\tcase 0x8001:\n\t\t\tpr_debug(\"name inforec len %d\\n\", s3info[i].len);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug(\"Unknown inforec type %d\\n\", s3info[i].type);\n\t\t}\n\t}\n\t \n\n\tif (trump && (result != 2))\n\t\tresult = 0;\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}