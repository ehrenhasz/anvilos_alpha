{
  "module_name": "p80211netdev.c",
  "hash_id": "3db74f80ac9bcf9e4e2196cd2969d05305b651bc3cd59a6246a89f31340dfc39",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/wlan-ng/p80211netdev.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/kmod.h>\n#include <linux/if_arp.h>\n#include <linux/wireless.h>\n#include <linux/sockios.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/byteorder/generic.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n\n#ifdef SIOCETHTOOL\n#include <linux/ethtool.h>\n#endif\n\n#include <net/iw_handler.h>\n#include <net/net_namespace.h>\n#include <net/cfg80211.h>\n\n#include \"p80211types.h\"\n#include \"p80211hdr.h\"\n#include \"p80211conv.h\"\n#include \"p80211mgmt.h\"\n#include \"p80211msg.h\"\n#include \"p80211netdev.h\"\n#include \"p80211ioctl.h\"\n#include \"p80211req.h\"\n#include \"p80211metastruct.h\"\n#include \"p80211metadef.h\"\n\n#include \"cfg80211.c\"\n\n \nstatic int p80211knetdev_init(struct net_device *netdev);\nstatic int p80211knetdev_open(struct net_device *netdev);\nstatic int p80211knetdev_stop(struct net_device *netdev);\nstatic netdev_tx_t p80211knetdev_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t\t struct net_device *netdev);\nstatic void p80211knetdev_set_multicast_list(struct net_device *dev);\nstatic int p80211knetdev_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t\t\tvoid __user *data, int cmd);\nstatic int p80211knetdev_set_mac_address(struct net_device *dev, void *addr);\nstatic void p80211knetdev_tx_timeout(struct net_device *netdev, unsigned int txqueue);\nstatic int p80211_rx_typedrop(struct wlandevice *wlandev, u16 fc);\n\nint wlan_watchdog = 5000;\nmodule_param(wlan_watchdog, int, 0644);\nMODULE_PARM_DESC(wlan_watchdog, \"transmit timeout in milliseconds\");\n\nint wlan_wext_write = 1;\nmodule_param(wlan_wext_write, int, 0644);\nMODULE_PARM_DESC(wlan_wext_write, \"enable write wireless extensions\");\n\n \nstatic int p80211knetdev_init(struct net_device *netdev)\n{\n\t \n\t \n\t \n\t \n\treturn 0;\n}\n\n \nstatic int p80211knetdev_open(struct net_device *netdev)\n{\n\tint result = 0;\t\t \n\tstruct wlandevice *wlandev = netdev->ml_priv;\n\n\t \n\tif (wlandev->msdstate != WLAN_MSD_RUNNING)\n\t\treturn -ENODEV;\n\n\t \n\tif (wlandev->open) {\n\t\tresult = wlandev->open(wlandev);\n\t\tif (result == 0) {\n\t\t\tnetif_start_queue(wlandev->netdev);\n\t\t\twlandev->state = WLAN_DEVICE_OPEN;\n\t\t}\n\t} else {\n\t\tresult = -EAGAIN;\n\t}\n\n\treturn result;\n}\n\n \nstatic int p80211knetdev_stop(struct net_device *netdev)\n{\n\tint result = 0;\n\tstruct wlandevice *wlandev = netdev->ml_priv;\n\n\tif (wlandev->close)\n\t\tresult = wlandev->close(wlandev);\n\n\tnetif_stop_queue(wlandev->netdev);\n\twlandev->state = WLAN_DEVICE_CLOSED;\n\n\treturn result;\n}\n\n \nvoid p80211netdev_rx(struct wlandevice *wlandev, struct sk_buff *skb)\n{\n\t \n\tskb_queue_tail(&wlandev->nsd_rxq, skb);\n\ttasklet_schedule(&wlandev->rx_bh);\n}\n\n#define CONV_TO_ETHER_SKIPPED\t0x01\n#define CONV_TO_ETHER_FAILED\t0x02\n\n \nstatic int p80211_convert_to_ether(struct wlandevice *wlandev,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct p80211_hdr *hdr;\n\n\thdr = (struct p80211_hdr *)skb->data;\n\tif (p80211_rx_typedrop(wlandev, le16_to_cpu(hdr->frame_control)))\n\t\treturn CONV_TO_ETHER_SKIPPED;\n\n\t \n\tif (wlandev->netdev->flags & IFF_ALLMULTI) {\n\t\tif (!ether_addr_equal_unaligned(wlandev->netdev->dev_addr,\n\t\t\t\t\t\thdr->address1)) {\n\t\t\tif (!is_multicast_ether_addr(hdr->address1))\n\t\t\t\treturn CONV_TO_ETHER_SKIPPED;\n\t\t}\n\t}\n\n\tif (skb_p80211_to_ether(wlandev, wlandev->ethconv, skb) == 0) {\n\t\twlandev->netdev->stats.rx_packets++;\n\t\twlandev->netdev->stats.rx_bytes += skb->len;\n\t\tnetif_rx(skb);\n\t\treturn 0;\n\t}\n\n\tnetdev_dbg(wlandev->netdev, \"%s failed.\\n\", __func__);\n\treturn CONV_TO_ETHER_FAILED;\n}\n\n \nstatic void p80211netdev_rx_bh(struct tasklet_struct *t)\n{\n\tstruct wlandevice *wlandev = from_tasklet(wlandev, t, rx_bh);\n\tstruct sk_buff *skb = NULL;\n\tstruct net_device *dev = wlandev->netdev;\n\n\t \n\twhile ((skb = skb_dequeue(&wlandev->nsd_rxq))) {\n\t\tif (wlandev->state == WLAN_DEVICE_OPEN) {\n\t\t\tif (dev->type != ARPHRD_ETHER) {\n\t\t\t\t \n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tskb->dev = dev;\n\t\t\t\tskb_reset_mac_header(skb);\n\t\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t\t\tskb->protocol = htons(ETH_P_80211_RAW);\n\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += skb->len;\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!p80211_convert_to_ether(wlandev, skb))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tdev_kfree_skb(skb);\n\t}\n}\n\n \nstatic netdev_tx_t p80211knetdev_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t\t struct net_device *netdev)\n{\n\tint result = 0;\n\tint txresult;\n\tstruct wlandevice *wlandev = netdev->ml_priv;\n\tstruct p80211_hdr p80211_hdr;\n\tstruct p80211_metawep p80211_wep;\n\n\tp80211_wep.data = NULL;\n\n\tif (!skb)\n\t\treturn NETDEV_TX_OK;\n\n\tif (wlandev->state != WLAN_DEVICE_OPEN) {\n\t\tresult = 1;\n\t\tgoto failed;\n\t}\n\n\tmemset(&p80211_hdr, 0, sizeof(p80211_hdr));\n\tmemset(&p80211_wep, 0, sizeof(p80211_wep));\n\n\tif (netif_queue_stopped(netdev)) {\n\t\tnetdev_dbg(netdev, \"called when queue stopped.\\n\");\n\t\tresult = 1;\n\t\tgoto failed;\n\t}\n\n\tnetif_stop_queue(netdev);\n\n\t \n\tswitch (wlandev->macmode) {\n\tcase WLAN_MACMODE_IBSS_STA:\n\tcase WLAN_MACMODE_ESS_STA:\n\tcase WLAN_MACMODE_ESS_AP:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (be16_to_cpu(skb->protocol) != ETH_P_80211_RAW) {\n\t\t\tnetif_start_queue(wlandev->netdev);\n\t\t\tnetdev_notice(netdev, \"Tx attempt prior to association, frame dropped.\\n\");\n\t\t\tnetdev->stats.tx_dropped++;\n\t\t\tresult = 0;\n\t\t\tgoto failed;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (be16_to_cpu(skb->protocol) == ETH_P_80211_RAW) {\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tresult = 1;\n\t\t\tgoto failed;\n\t\t}\n\t\t \n\t\tmemcpy(&p80211_hdr, skb->data, sizeof(p80211_hdr));\n\t\tskb_pull(skb, sizeof(p80211_hdr));\n\t} else {\n\t\tif (skb_ether_to_p80211\n\t\t    (wlandev, wlandev->ethconv, skb, &p80211_hdr,\n\t\t     &p80211_wep) != 0) {\n\t\t\t \n\t\t\tnetdev_dbg(netdev, \"ether_to_80211(%d) failed.\\n\",\n\t\t\t\t   wlandev->ethconv);\n\t\t\tresult = 1;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tif (!wlandev->txframe) {\n\t\tresult = 1;\n\t\tgoto failed;\n\t}\n\n\tnetif_trans_update(netdev);\n\n\tnetdev->stats.tx_packets++;\n\t \n\tnetdev->stats.tx_bytes += skb->len;\n\n\ttxresult = wlandev->txframe(wlandev, skb, &p80211_hdr, &p80211_wep);\n\n\tif (txresult == 0) {\n\t\t \n\t\t \n\t\tnetif_wake_queue(wlandev->netdev);\n\t\tresult = NETDEV_TX_OK;\n\t} else if (txresult == 1) {\n\t\t \n\t\tnetdev_dbg(netdev, \"txframe success, no more bufs\\n\");\n\t\t \n\t\t \n\t\tresult = NETDEV_TX_OK;\n\t} else if (txresult == 2) {\n\t\t \n\t\tnetdev_dbg(netdev, \"txframe returned alloc_fail\\n\");\n\t\tresult = NETDEV_TX_BUSY;\n\t} else {\n\t\t \n\t\tnetdev_dbg(netdev, \"txframe returned full or busy\\n\");\n\t\tresult = NETDEV_TX_BUSY;\n\t}\n\nfailed:\n\t \n\tif ((p80211_wep.data) && (p80211_wep.data != skb->data))\n\t\tkfree_sensitive(p80211_wep.data);\n\n\t \n\tif (!result)\n\t\tdev_kfree_skb(skb);\n\n\treturn result;\n}\n\n \nstatic void p80211knetdev_set_multicast_list(struct net_device *dev)\n{\n\tstruct wlandevice *wlandev = dev->ml_priv;\n\n\t \n\n\tif (wlandev->set_multicast_list)\n\t\twlandev->set_multicast_list(wlandev, dev);\n}\n\n \nstatic int p80211knetdev_siocdevprivate(struct net_device *dev,\n\t\t\t\t\tstruct ifreq *ifr,\n\t\t\t\t\tvoid __user *data, int cmd)\n{\n\tint result = 0;\n\tstruct p80211ioctl_req *req = (struct p80211ioctl_req *)ifr;\n\tstruct wlandevice *wlandev = dev->ml_priv;\n\tu8 *msgbuf;\n\n\tnetdev_dbg(dev, \"rx'd ioctl, cmd=%d, len=%d\\n\", cmd, req->len);\n\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (req->magic != P80211_IOCTL_MAGIC) {\n\t\tresult = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (cmd == P80211_IFTEST) {\n\t\tresult = 0;\n\t\tgoto bail;\n\t} else if (cmd != P80211_IFREQ) {\n\t\tresult = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tmsgbuf = memdup_user(data, req->len);\n\tif (IS_ERR(msgbuf)) {\n\t\tresult = PTR_ERR(msgbuf);\n\t\tgoto bail;\n\t}\n\n\tresult = p80211req_dorequest(wlandev, msgbuf);\n\n\tif (result == 0) {\n\t\tif (copy_to_user(data, msgbuf, req->len))\n\t\t\tresult = -EFAULT;\n\t}\n\tkfree(msgbuf);\n\nbail:\n\t \n\treturn result;\n}\n\n \nstatic int p80211knetdev_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *new_addr = addr;\n\tstruct p80211msg_dot11req_mibset dot11req;\n\tstruct p80211item_unk392 *mibattr;\n\tstruct p80211item_pstr6 *macaddr;\n\tstruct p80211item_uint32 *resultcode;\n\tint result;\n\n\t \n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\t \n\tmibattr = &dot11req.mibattribute;\n\tmacaddr = (struct p80211item_pstr6 *)&mibattr->data;\n\tresultcode = &dot11req.resultcode;\n\n\t \n\tmemset(&dot11req, 0, sizeof(dot11req));\n\tdot11req.msgcode = DIDMSG_DOT11REQ_MIBSET;\n\tdot11req.msglen = sizeof(dot11req);\n\tmemcpy(dot11req.devname,\n\t       ((struct wlandevice *)dev->ml_priv)->name,\n\t       WLAN_DEVNAMELEN_MAX - 1);\n\n\t \n\tmibattr->did = DIDMSG_DOT11REQ_MIBSET_MIBATTRIBUTE;\n\tmibattr->status = P80211ENUM_msgitem_status_data_ok;\n\tmibattr->len = sizeof(mibattr->data);\n\n\tmacaddr->did = DIDMIB_DOT11MAC_OPERATIONTABLE_MACADDRESS;\n\tmacaddr->status = P80211ENUM_msgitem_status_data_ok;\n\tmacaddr->len = sizeof(macaddr->data);\n\tmacaddr->data.len = ETH_ALEN;\n\tmemcpy(&macaddr->data.data, new_addr->sa_data, ETH_ALEN);\n\n\t \n\tresultcode->did = DIDMSG_DOT11REQ_MIBSET_RESULTCODE;\n\tresultcode->status = P80211ENUM_msgitem_status_no_value;\n\tresultcode->len = sizeof(resultcode->data);\n\tresultcode->data = 0;\n\n\t \n\tresult = p80211req_dorequest(dev->ml_priv, (u8 *)&dot11req);\n\n\t \n\tif (result != 0 || resultcode->data != P80211ENUM_resultcode_success) {\n\t\tnetdev_err(dev, \"Low-level driver failed dot11req_mibset(dot11MACAddress).\\n\");\n\t\tresult = -EADDRNOTAVAIL;\n\t} else {\n\t\t \n\t\teth_hw_addr_set(dev, new_addr->sa_data);\n\t}\n\n\treturn result;\n}\n\nstatic const struct net_device_ops p80211_netdev_ops = {\n\t.ndo_init = p80211knetdev_init,\n\t.ndo_open = p80211knetdev_open,\n\t.ndo_stop = p80211knetdev_stop,\n\t.ndo_start_xmit = p80211knetdev_hard_start_xmit,\n\t.ndo_set_rx_mode = p80211knetdev_set_multicast_list,\n\t.ndo_siocdevprivate = p80211knetdev_siocdevprivate,\n\t.ndo_set_mac_address = p80211knetdev_set_mac_address,\n\t.ndo_tx_timeout = p80211knetdev_tx_timeout,\n\t.ndo_validate_addr = eth_validate_addr,\n};\n\n \nint wlan_setup(struct wlandevice *wlandev, struct device *physdev)\n{\n\tint result = 0;\n\tstruct net_device *netdev;\n\tstruct wiphy *wiphy;\n\tstruct wireless_dev *wdev;\n\n\t \n\twlandev->state = WLAN_DEVICE_CLOSED;\n\twlandev->ethconv = WLAN_ETHCONV_8021h;\n\twlandev->macmode = WLAN_MACMODE_NONE;\n\n\t \n\tskb_queue_head_init(&wlandev->nsd_rxq);\n\ttasklet_setup(&wlandev->rx_bh, p80211netdev_rx_bh);\n\n\t \n\twiphy = wlan_create_wiphy(physdev, wlandev);\n\tif (!wiphy) {\n\t\tdev_err(physdev, \"Failed to alloc wiphy.\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tnetdev = alloc_netdev(sizeof(struct wireless_dev), \"wlan%d\",\n\t\t\t      NET_NAME_UNKNOWN, ether_setup);\n\tif (!netdev) {\n\t\tdev_err(physdev, \"Failed to alloc netdev.\\n\");\n\t\twlan_free_wiphy(wiphy);\n\t\tresult = 1;\n\t} else {\n\t\twlandev->netdev = netdev;\n\t\tnetdev->ml_priv = wlandev;\n\t\tnetdev->netdev_ops = &p80211_netdev_ops;\n\t\twdev = netdev_priv(netdev);\n\t\twdev->wiphy = wiphy;\n\t\twdev->iftype = NL80211_IFTYPE_STATION;\n\t\tnetdev->ieee80211_ptr = wdev;\n\t\tnetdev->min_mtu = 68;\n\t\t \n\t\tnetdev->max_mtu = (2312 - 20 - 8);\n\n\t\tnetif_stop_queue(netdev);\n\t\tnetif_carrier_off(netdev);\n\t}\n\n\treturn result;\n}\n\n \nvoid wlan_unsetup(struct wlandevice *wlandev)\n{\n\tstruct wireless_dev *wdev;\n\n\ttasklet_kill(&wlandev->rx_bh);\n\n\tif (wlandev->netdev) {\n\t\twdev = netdev_priv(wlandev->netdev);\n\t\tif (wdev->wiphy)\n\t\t\twlan_free_wiphy(wdev->wiphy);\n\t\tfree_netdev(wlandev->netdev);\n\t\twlandev->netdev = NULL;\n\t}\n}\n\n \nint register_wlandev(struct wlandevice *wlandev)\n{\n\treturn register_netdev(wlandev->netdev);\n}\n\n \nint unregister_wlandev(struct wlandevice *wlandev)\n{\n\tstruct sk_buff *skb;\n\n\tunregister_netdev(wlandev->netdev);\n\n\t \n\twhile ((skb = skb_dequeue(&wlandev->nsd_rxq)))\n\t\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\n \nvoid p80211netdev_hwremoved(struct wlandevice *wlandev)\n{\n\twlandev->hwremoved = 1;\n\tif (wlandev->state == WLAN_DEVICE_OPEN)\n\t\tnetif_stop_queue(wlandev->netdev);\n\n\tnetif_device_detach(wlandev->netdev);\n}\n\n \nstatic int p80211_rx_typedrop(struct wlandevice *wlandev, u16 fc)\n{\n\tu16 ftype;\n\tu16 fstype;\n\tint drop = 0;\n\t \n\tftype = WLAN_GET_FC_FTYPE(fc);\n\tfstype = WLAN_GET_FC_FSTYPE(fc);\n\tswitch (ftype) {\n\tcase WLAN_FTYPE_MGMT:\n\t\tif ((wlandev->netdev->flags & IFF_PROMISC) ||\n\t\t    (wlandev->netdev->flags & IFF_ALLMULTI)) {\n\t\t\tdrop = 1;\n\t\t\tbreak;\n\t\t}\n\t\tnetdev_dbg(wlandev->netdev, \"rx'd mgmt:\\n\");\n\t\twlandev->rx.mgmt++;\n\t\tswitch (fstype) {\n\t\tcase WLAN_FSTYPE_ASSOCREQ:\n\t\t\twlandev->rx.assocreq++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_ASSOCRESP:\n\t\t\twlandev->rx.assocresp++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_REASSOCREQ:\n\t\t\twlandev->rx.reassocreq++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_REASSOCRESP:\n\t\t\twlandev->rx.reassocresp++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_PROBEREQ:\n\t\t\twlandev->rx.probereq++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_PROBERESP:\n\t\t\twlandev->rx.proberesp++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_BEACON:\n\t\t\twlandev->rx.beacon++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_ATIM:\n\t\t\twlandev->rx.atim++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_DISASSOC:\n\t\t\twlandev->rx.disassoc++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_AUTHEN:\n\t\t\twlandev->rx.authen++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_DEAUTHEN:\n\t\t\twlandev->rx.deauthen++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twlandev->rx.mgmt_unknown++;\n\t\t\tbreak;\n\t\t}\n\t\tdrop = 2;\n\t\tbreak;\n\n\tcase WLAN_FTYPE_CTL:\n\t\tif ((wlandev->netdev->flags & IFF_PROMISC) ||\n\t\t    (wlandev->netdev->flags & IFF_ALLMULTI)) {\n\t\t\tdrop = 1;\n\t\t\tbreak;\n\t\t}\n\t\tnetdev_dbg(wlandev->netdev, \"rx'd ctl:\\n\");\n\t\twlandev->rx.ctl++;\n\t\tswitch (fstype) {\n\t\tcase WLAN_FSTYPE_PSPOLL:\n\t\t\twlandev->rx.pspoll++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_RTS:\n\t\t\twlandev->rx.rts++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_CTS:\n\t\t\twlandev->rx.cts++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_ACK:\n\t\t\twlandev->rx.ack++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_CFEND:\n\t\t\twlandev->rx.cfend++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_CFENDCFACK:\n\t\t\twlandev->rx.cfendcfack++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twlandev->rx.ctl_unknown++;\n\t\t\tbreak;\n\t\t}\n\t\tdrop = 2;\n\t\tbreak;\n\n\tcase WLAN_FTYPE_DATA:\n\t\twlandev->rx.data++;\n\t\tswitch (fstype) {\n\t\tcase WLAN_FSTYPE_DATAONLY:\n\t\t\twlandev->rx.dataonly++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_DATA_CFACK:\n\t\t\twlandev->rx.data_cfack++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_DATA_CFPOLL:\n\t\t\twlandev->rx.data_cfpoll++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_DATA_CFACK_CFPOLL:\n\t\t\twlandev->rx.data__cfack_cfpoll++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_NULL:\n\t\t\tnetdev_dbg(wlandev->netdev, \"rx'd data:null\\n\");\n\t\t\twlandev->rx.null++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_CFACK:\n\t\t\tnetdev_dbg(wlandev->netdev, \"rx'd data:cfack\\n\");\n\t\t\twlandev->rx.cfack++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_CFPOLL:\n\t\t\tnetdev_dbg(wlandev->netdev, \"rx'd data:cfpoll\\n\");\n\t\t\twlandev->rx.cfpoll++;\n\t\t\tbreak;\n\t\tcase WLAN_FSTYPE_CFACK_CFPOLL:\n\t\t\tnetdev_dbg(wlandev->netdev, \"rx'd data:cfack_cfpoll\\n\");\n\t\t\twlandev->rx.cfack_cfpoll++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twlandev->rx.data_unknown++;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\treturn drop;\n}\n\nstatic void p80211knetdev_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct wlandevice *wlandev = netdev->ml_priv;\n\n\tif (wlandev->tx_timeout) {\n\t\twlandev->tx_timeout(wlandev);\n\t} else {\n\t\tnetdev_warn(netdev, \"Implement tx_timeout for %s\\n\",\n\t\t\t    wlandev->nsdname);\n\t\tnetif_wake_queue(wlandev->netdev);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}