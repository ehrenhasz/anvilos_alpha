{
  "module_name": "hfa384x_usb.c",
  "hash_id": "f85156ccf0209496056650e8761fe995cd3190bdbbb3df2274a8d2ddba093dd9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/wlan-ng/hfa384x_usb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/wireless.h>\n#include <linux/netdevice.h>\n#include <linux/timer.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/byteorder/generic.h>\n\n#include \"p80211types.h\"\n#include \"p80211hdr.h\"\n#include \"p80211mgmt.h\"\n#include \"p80211conv.h\"\n#include \"p80211msg.h\"\n#include \"p80211netdev.h\"\n#include \"p80211req.h\"\n#include \"p80211metadef.h\"\n#include \"p80211metastruct.h\"\n#include \"hfa384x.h\"\n#include \"prism2mgmt.h\"\n\nenum cmd_mode {\n\tDOWAIT = 0,\n\tDOASYNC\n};\n\n#define THROTTLE_JIFFIES\t(HZ / 8)\n#define URB_ASYNC_UNLINK 0\n#define USB_QUEUE_BULK 0\n\n#define ROUNDUP64(a) (((a) + 63) & ~63)\n\n#ifdef DEBUG_USB\nstatic void dbprint_urb(struct urb *urb);\n#endif\n\nstatic void hfa384x_int_rxmonitor(struct wlandevice *wlandev,\n\t\t\t\t  struct hfa384x_usb_rxfrm *rxfrm);\n\nstatic void hfa384x_usb_defer(struct work_struct *data);\n\nstatic int submit_rx_urb(struct hfa384x *hw, gfp_t flags);\n\nstatic int submit_tx_urb(struct hfa384x *hw, struct urb *tx_urb, gfp_t flags);\n\n \n \nstatic void hfa384x_usbout_callback(struct urb *urb);\nstatic void hfa384x_ctlxout_callback(struct urb *urb);\nstatic void hfa384x_usbin_callback(struct urb *urb);\n\nstatic void\nhfa384x_usbin_txcompl(struct wlandevice *wlandev, union hfa384x_usbin *usbin);\n\nstatic void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb);\n\nstatic void hfa384x_usbin_info(struct wlandevice *wlandev,\n\t\t\t       union hfa384x_usbin *usbin);\n\nstatic void hfa384x_usbin_ctlx(struct hfa384x *hw, union hfa384x_usbin *usbin,\n\t\t\t       int urb_status);\n\n \n \n\nstatic void hfa384x_usbctlxq_run(struct hfa384x *hw);\n\nstatic void hfa384x_usbctlx_reqtimerfn(struct timer_list *t);\n\nstatic void hfa384x_usbctlx_resptimerfn(struct timer_list *t);\n\nstatic void hfa384x_usb_throttlefn(struct timer_list *t);\n\nstatic void hfa384x_usbctlx_completion_task(struct work_struct *work);\n\nstatic void hfa384x_usbctlx_reaper_task(struct work_struct *work);\n\nstatic int hfa384x_usbctlx_submit(struct hfa384x *hw,\n\t\t\t\t  struct hfa384x_usbctlx *ctlx);\n\nstatic void unlocked_usbctlx_complete(struct hfa384x *hw,\n\t\t\t\t      struct hfa384x_usbctlx *ctlx);\n\nstruct usbctlx_completor {\n\tint (*complete)(struct usbctlx_completor *completor);\n};\n\nstatic int\nhfa384x_usbctlx_complete_sync(struct hfa384x *hw,\n\t\t\t      struct hfa384x_usbctlx *ctlx,\n\t\t\t      struct usbctlx_completor *completor);\n\nstatic int\nunlocked_usbctlx_cancel_async(struct hfa384x *hw, struct hfa384x_usbctlx *ctlx);\n\nstatic void hfa384x_cb_status(struct hfa384x *hw,\n\t\t\t      const struct hfa384x_usbctlx *ctlx);\n\nstatic int\nusbctlx_get_status(const struct hfa384x_usb_statusresp *cmdresp,\n\t\t   struct hfa384x_cmdresult *result);\n\nstatic void\nusbctlx_get_rridresult(const struct hfa384x_usb_rridresp *rridresp,\n\t\t       struct hfa384x_rridresult *result);\n\n \n \nstatic inline int\nhfa384x_docmd(struct hfa384x *hw,\n\t      struct hfa384x_metacmd *cmd);\n\nstatic int\nhfa384x_dorrid(struct hfa384x *hw,\n\t       enum cmd_mode mode,\n\t       u16 rid,\n\t       void *riddata,\n\t       unsigned int riddatalen,\n\t       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);\n\nstatic int\nhfa384x_dowrid(struct hfa384x *hw,\n\t       enum cmd_mode mode,\n\t       u16 rid,\n\t       void *riddata,\n\t       unsigned int riddatalen,\n\t       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);\n\nstatic int\nhfa384x_dormem(struct hfa384x *hw,\n\t       u16 page,\n\t       u16 offset,\n\t       void *data,\n\t       unsigned int len);\n\nstatic int\nhfa384x_dowmem(struct hfa384x *hw,\n\t       u16 page,\n\t       u16 offset,\n\t       void *data,\n\t       unsigned int len);\n\nstatic int hfa384x_isgood_pdrcode(u16 pdrcode);\n\nstatic inline const char *ctlxstr(enum ctlx_state s)\n{\n\tstatic const char * const ctlx_str[] = {\n\t\t\"Initial state\",\n\t\t\"Complete\",\n\t\t\"Request failed\",\n\t\t\"Request pending\",\n\t\t\"Request packet submitted\",\n\t\t\"Request packet completed\",\n\t\t\"Response packet completed\"\n\t};\n\n\treturn ctlx_str[s];\n};\n\nstatic inline struct hfa384x_usbctlx *get_active_ctlx(struct hfa384x *hw)\n{\n\treturn list_entry(hw->ctlxq.active.next, struct hfa384x_usbctlx, list);\n}\n\n#ifdef DEBUG_USB\nvoid dbprint_urb(struct urb *urb)\n{\n\tpr_debug(\"urb->pipe=0x%08x\\n\", urb->pipe);\n\tpr_debug(\"urb->status=0x%08x\\n\", urb->status);\n\tpr_debug(\"urb->transfer_flags=0x%08x\\n\", urb->transfer_flags);\n\tpr_debug(\"urb->transfer_buffer=0x%08x\\n\",\n\t\t (unsigned int)urb->transfer_buffer);\n\tpr_debug(\"urb->transfer_buffer_length=0x%08x\\n\",\n\t\t urb->transfer_buffer_length);\n\tpr_debug(\"urb->actual_length=0x%08x\\n\", urb->actual_length);\n\tpr_debug(\"urb->setup_packet(ctl)=0x%08x\\n\",\n\t\t (unsigned int)urb->setup_packet);\n\tpr_debug(\"urb->start_frame(iso/irq)=0x%08x\\n\", urb->start_frame);\n\tpr_debug(\"urb->interval(irq)=0x%08x\\n\", urb->interval);\n\tpr_debug(\"urb->error_count(iso)=0x%08x\\n\", urb->error_count);\n\tpr_debug(\"urb->context=0x%08x\\n\", (unsigned int)urb->context);\n\tpr_debug(\"urb->complete=0x%08x\\n\", (unsigned int)urb->complete);\n}\n#endif\n\n \nstatic int submit_rx_urb(struct hfa384x *hw, gfp_t memflags)\n{\n\tstruct sk_buff *skb;\n\tint result;\n\n\tskb = dev_alloc_skb(sizeof(union hfa384x_usbin));\n\tif (!skb) {\n\t\tresult = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tusb_fill_bulk_urb(&hw->rx_urb, hw->usb,\n\t\t\t  hw->endp_in,\n\t\t\t  skb->data, sizeof(union hfa384x_usbin),\n\t\t\t  hfa384x_usbin_callback, hw->wlandev);\n\n\thw->rx_urb_skb = skb;\n\n\tresult = -ENOLINK;\n\tif (!hw->wlandev->hwremoved &&\n\t    !test_bit(WORK_RX_HALT, &hw->usb_flags)) {\n\t\tresult = usb_submit_urb(&hw->rx_urb, memflags);\n\n\t\t \n\t\tif (result == -EPIPE) {\n\t\t\tnetdev_warn(hw->wlandev->netdev,\n\t\t\t\t    \"%s rx pipe stalled: requesting reset\\n\",\n\t\t\t\t    hw->wlandev->netdev->name);\n\t\t\tif (!test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))\n\t\t\t\tschedule_work(&hw->usb_work);\n\t\t}\n\t}\n\n\t \n\tif (result != 0) {\n\t\tdev_kfree_skb(skb);\n\t\thw->rx_urb_skb = NULL;\n\t}\n\ndone:\n\treturn result;\n}\n\n \nstatic int submit_tx_urb(struct hfa384x *hw, struct urb *tx_urb, gfp_t memflags)\n{\n\tstruct net_device *netdev = hw->wlandev->netdev;\n\tint result;\n\n\tresult = -ENOLINK;\n\tif (netif_running(netdev)) {\n\t\tif (!hw->wlandev->hwremoved &&\n\t\t    !test_bit(WORK_TX_HALT, &hw->usb_flags)) {\n\t\t\tresult = usb_submit_urb(tx_urb, memflags);\n\n\t\t\t \n\t\t\tif (result == -EPIPE) {\n\t\t\t\tnetdev_warn(hw->wlandev->netdev,\n\t\t\t\t\t    \"%s tx pipe stalled: requesting reset\\n\",\n\t\t\t\t\t    netdev->name);\n\t\t\t\tset_bit(WORK_TX_HALT, &hw->usb_flags);\n\t\t\t\tschedule_work(&hw->usb_work);\n\t\t\t} else if (result == 0) {\n\t\t\t\tnetif_stop_queue(netdev);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n \nstatic void hfa384x_usb_defer(struct work_struct *data)\n{\n\tstruct hfa384x *hw = container_of(data, struct hfa384x, usb_work);\n\tstruct net_device *netdev = hw->wlandev->netdev;\n\n\t \n\tif (hw->wlandev->hwremoved)\n\t\treturn;\n\n\t \n\tif (test_bit(WORK_RX_HALT, &hw->usb_flags)) {\n\t\tint ret;\n\n\t\tusb_kill_urb(&hw->rx_urb);  \n\n\t\tret = usb_clear_halt(hw->usb, hw->endp_in);\n\t\tif (ret != 0) {\n\t\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t\t   \"Failed to clear rx pipe for %s: err=%d\\n\",\n\t\t\t\t   netdev->name, ret);\n\t\t} else {\n\t\t\tnetdev_info(hw->wlandev->netdev, \"%s rx pipe reset complete.\\n\",\n\t\t\t\t    netdev->name);\n\t\t\tclear_bit(WORK_RX_HALT, &hw->usb_flags);\n\t\t\tset_bit(WORK_RX_RESUME, &hw->usb_flags);\n\t\t}\n\t}\n\n\t \n\tif (test_bit(WORK_RX_RESUME, &hw->usb_flags)) {\n\t\tint ret;\n\n\t\tret = submit_rx_urb(hw, GFP_KERNEL);\n\t\tif (ret != 0) {\n\t\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t\t   \"Failed to resume %s rx pipe.\\n\",\n\t\t\t\t   netdev->name);\n\t\t} else {\n\t\t\tclear_bit(WORK_RX_RESUME, &hw->usb_flags);\n\t\t}\n\t}\n\n\t \n\tif (test_bit(WORK_TX_HALT, &hw->usb_flags)) {\n\t\tint ret;\n\n\t\tusb_kill_urb(&hw->tx_urb);\n\t\tret = usb_clear_halt(hw->usb, hw->endp_out);\n\t\tif (ret != 0) {\n\t\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t\t   \"Failed to clear tx pipe for %s: err=%d\\n\",\n\t\t\t\t   netdev->name, ret);\n\t\t} else {\n\t\t\tnetdev_info(hw->wlandev->netdev, \"%s tx pipe reset complete.\\n\",\n\t\t\t\t    netdev->name);\n\t\t\tclear_bit(WORK_TX_HALT, &hw->usb_flags);\n\t\t\tset_bit(WORK_TX_RESUME, &hw->usb_flags);\n\n\t\t\t \n\t\t\thfa384x_usbctlxq_run(hw);\n\t\t}\n\t}\n\n\t \n\tif (test_and_clear_bit(WORK_TX_RESUME, &hw->usb_flags))\n\t\tnetif_wake_queue(hw->wlandev->netdev);\n}\n\n \nvoid hfa384x_create(struct hfa384x *hw, struct usb_device *usb)\n{\n\thw->usb = usb;\n\n\t \n\tinit_waitqueue_head(&hw->cmdq);\n\n\t \n\tspin_lock_init(&hw->ctlxq.lock);\n\tINIT_LIST_HEAD(&hw->ctlxq.pending);\n\tINIT_LIST_HEAD(&hw->ctlxq.active);\n\tINIT_LIST_HEAD(&hw->ctlxq.completing);\n\tINIT_LIST_HEAD(&hw->ctlxq.reapable);\n\n\t \n\tskb_queue_head_init(&hw->authq);\n\n\tINIT_WORK(&hw->reaper_bh, hfa384x_usbctlx_reaper_task);\n\tINIT_WORK(&hw->completion_bh, hfa384x_usbctlx_completion_task);\n\tINIT_WORK(&hw->link_bh, prism2sta_processing_defer);\n\tINIT_WORK(&hw->usb_work, hfa384x_usb_defer);\n\n\ttimer_setup(&hw->throttle, hfa384x_usb_throttlefn, 0);\n\n\ttimer_setup(&hw->resptimer, hfa384x_usbctlx_resptimerfn, 0);\n\n\ttimer_setup(&hw->reqtimer, hfa384x_usbctlx_reqtimerfn, 0);\n\n\tusb_init_urb(&hw->rx_urb);\n\tusb_init_urb(&hw->tx_urb);\n\tusb_init_urb(&hw->ctlx_urb);\n\n\thw->link_status = HFA384x_LINK_NOTCONNECTED;\n\thw->state = HFA384x_STATE_INIT;\n\n\tINIT_WORK(&hw->commsqual_bh, prism2sta_commsqual_defer);\n\ttimer_setup(&hw->commsqual_timer, prism2sta_commsqual_timer, 0);\n}\n\n \nvoid hfa384x_destroy(struct hfa384x *hw)\n{\n\tstruct sk_buff *skb;\n\n\tif (hw->state == HFA384x_STATE_RUNNING)\n\t\thfa384x_drvr_stop(hw);\n\thw->state = HFA384x_STATE_PREINIT;\n\n\tkfree(hw->scanresults);\n\thw->scanresults = NULL;\n\n\t \n\twhile ((skb = skb_dequeue(&hw->authq)))\n\t\tdev_kfree_skb(skb);\n}\n\nstatic struct hfa384x_usbctlx *usbctlx_alloc(void)\n{\n\tstruct hfa384x_usbctlx *ctlx;\n\n\tctlx = kzalloc(sizeof(*ctlx),\n\t\t       in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);\n\tif (ctlx)\n\t\tinit_completion(&ctlx->done);\n\n\treturn ctlx;\n}\n\nstatic int\nusbctlx_get_status(const struct hfa384x_usb_statusresp *cmdresp,\n\t\t   struct hfa384x_cmdresult *result)\n{\n\tresult->status = le16_to_cpu(cmdresp->status);\n\tresult->resp0 = le16_to_cpu(cmdresp->resp0);\n\tresult->resp1 = le16_to_cpu(cmdresp->resp1);\n\tresult->resp2 = le16_to_cpu(cmdresp->resp2);\n\n\tpr_debug(\"cmdresult:status=0x%04x resp0=0x%04x resp1=0x%04x resp2=0x%04x\\n\",\n\t\t result->status, result->resp0, result->resp1, result->resp2);\n\n\treturn result->status & HFA384x_STATUS_RESULT;\n}\n\nstatic void\nusbctlx_get_rridresult(const struct hfa384x_usb_rridresp *rridresp,\n\t\t       struct hfa384x_rridresult *result)\n{\n\tresult->rid = le16_to_cpu(rridresp->rid);\n\tresult->riddata = rridresp->data;\n\tresult->riddata_len = ((le16_to_cpu(rridresp->frmlen) - 1) * 2);\n}\n\n \nstruct usbctlx_cmd_completor {\n\tstruct usbctlx_completor head;\n\n\tconst struct hfa384x_usb_statusresp *cmdresp;\n\tstruct hfa384x_cmdresult *result;\n};\n\nstatic inline int usbctlx_cmd_completor_fn(struct usbctlx_completor *head)\n{\n\tstruct usbctlx_cmd_completor *complete;\n\n\tcomplete = (struct usbctlx_cmd_completor *)head;\n\treturn usbctlx_get_status(complete->cmdresp, complete->result);\n}\n\nstatic inline struct usbctlx_completor *\ninit_cmd_completor(struct usbctlx_cmd_completor *completor,\n\t\t   const struct hfa384x_usb_statusresp *cmdresp,\n\t\t   struct hfa384x_cmdresult *result)\n{\n\tcompletor->head.complete = usbctlx_cmd_completor_fn;\n\tcompletor->cmdresp = cmdresp;\n\tcompletor->result = result;\n\treturn &completor->head;\n}\n\n \nstruct usbctlx_rrid_completor {\n\tstruct usbctlx_completor head;\n\n\tconst struct hfa384x_usb_rridresp *rridresp;\n\tvoid *riddata;\n\tunsigned int riddatalen;\n};\n\nstatic int usbctlx_rrid_completor_fn(struct usbctlx_completor *head)\n{\n\tstruct usbctlx_rrid_completor *complete;\n\tstruct hfa384x_rridresult rridresult;\n\n\tcomplete = (struct usbctlx_rrid_completor *)head;\n\tusbctlx_get_rridresult(complete->rridresp, &rridresult);\n\n\t \n\tif (rridresult.riddata_len != complete->riddatalen) {\n\t\tpr_warn(\"RID len mismatch, rid=0x%04x hlen=%d fwlen=%d\\n\",\n\t\t\trridresult.rid,\n\t\t\tcomplete->riddatalen, rridresult.riddata_len);\n\t\treturn -ENODATA;\n\t}\n\n\tmemcpy(complete->riddata, rridresult.riddata, complete->riddatalen);\n\treturn 0;\n}\n\nstatic inline struct usbctlx_completor *\ninit_rrid_completor(struct usbctlx_rrid_completor *completor,\n\t\t    const struct hfa384x_usb_rridresp *rridresp,\n\t\t    void *riddata,\n\t\t    unsigned int riddatalen)\n{\n\tcompletor->head.complete = usbctlx_rrid_completor_fn;\n\tcompletor->rridresp = rridresp;\n\tcompletor->riddata = riddata;\n\tcompletor->riddatalen = riddatalen;\n\treturn &completor->head;\n}\n\n \n#define init_wrid_completor  init_cmd_completor\n\n \n#define init_wmem_completor  init_cmd_completor\n\n \nstruct usbctlx_rmem_completor {\n\tstruct usbctlx_completor head;\n\n\tconst struct hfa384x_usb_rmemresp *rmemresp;\n\tvoid *data;\n\tunsigned int len;\n};\n\nstatic int usbctlx_rmem_completor_fn(struct usbctlx_completor *head)\n{\n\tstruct usbctlx_rmem_completor *complete =\n\t\t(struct usbctlx_rmem_completor *)head;\n\n\tpr_debug(\"rmemresp:len=%d\\n\", complete->rmemresp->frmlen);\n\tmemcpy(complete->data, complete->rmemresp->data, complete->len);\n\treturn 0;\n}\n\nstatic inline struct usbctlx_completor *\ninit_rmem_completor(struct usbctlx_rmem_completor *completor,\n\t\t    struct hfa384x_usb_rmemresp *rmemresp,\n\t\t    void *data,\n\t\t    unsigned int len)\n{\n\tcompletor->head.complete = usbctlx_rmem_completor_fn;\n\tcompletor->rmemresp = rmemresp;\n\tcompletor->data = data;\n\tcompletor->len = len;\n\treturn &completor->head;\n}\n\n \nstatic void hfa384x_cb_status(struct hfa384x *hw,\n\t\t\t      const struct hfa384x_usbctlx *ctlx)\n{\n\tif (ctlx->usercb) {\n\t\tstruct hfa384x_cmdresult cmdresult;\n\n\t\tif (ctlx->state != CTLX_COMPLETE) {\n\t\t\tmemset(&cmdresult, 0, sizeof(cmdresult));\n\t\t\tcmdresult.status =\n\t\t\t    HFA384x_STATUS_RESULT_SET(HFA384x_CMD_ERR);\n\t\t} else {\n\t\t\tusbctlx_get_status(&ctlx->inbuf.cmdresp, &cmdresult);\n\t\t}\n\n\t\tctlx->usercb(hw, &cmdresult, ctlx->usercb_data);\n\t}\n}\n\n \nint hfa384x_cmd_initialize(struct hfa384x *hw)\n{\n\tint result = 0;\n\tint i;\n\tstruct hfa384x_metacmd cmd;\n\n\tcmd.cmd = HFA384x_CMDCODE_INIT;\n\tcmd.parm0 = 0;\n\tcmd.parm1 = 0;\n\tcmd.parm2 = 0;\n\n\tresult = hfa384x_docmd(hw, &cmd);\n\n\tpr_debug(\"cmdresp.init: status=0x%04x, resp0=0x%04x, resp1=0x%04x, resp2=0x%04x\\n\",\n\t\t cmd.result.status,\n\t\t cmd.result.resp0, cmd.result.resp1, cmd.result.resp2);\n\tif (result == 0) {\n\t\tfor (i = 0; i < HFA384x_NUMPORTS_MAX; i++)\n\t\t\thw->port_enabled[i] = 0;\n\t}\n\n\thw->link_status = HFA384x_LINK_NOTCONNECTED;\n\n\treturn result;\n}\n\n \nint hfa384x_cmd_disable(struct hfa384x *hw, u16 macport)\n{\n\tstruct hfa384x_metacmd cmd;\n\n\tcmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DISABLE) |\n\t    HFA384x_CMD_MACPORT_SET(macport);\n\tcmd.parm0 = 0;\n\tcmd.parm1 = 0;\n\tcmd.parm2 = 0;\n\n\treturn hfa384x_docmd(hw, &cmd);\n}\n\n \nint hfa384x_cmd_enable(struct hfa384x *hw, u16 macport)\n{\n\tstruct hfa384x_metacmd cmd;\n\n\tcmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_ENABLE) |\n\t    HFA384x_CMD_MACPORT_SET(macport);\n\tcmd.parm0 = 0;\n\tcmd.parm1 = 0;\n\tcmd.parm2 = 0;\n\n\treturn hfa384x_docmd(hw, &cmd);\n}\n\n \nint hfa384x_cmd_monitor(struct hfa384x *hw, u16 enable)\n{\n\tstruct hfa384x_metacmd cmd;\n\n\tcmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_MONITOR) |\n\t    HFA384x_CMD_AINFO_SET(enable);\n\tcmd.parm0 = 0;\n\tcmd.parm1 = 0;\n\tcmd.parm2 = 0;\n\n\treturn hfa384x_docmd(hw, &cmd);\n}\n\n \nint hfa384x_cmd_download(struct hfa384x *hw, u16 mode, u16 lowaddr,\n\t\t\t u16 highaddr, u16 codelen)\n{\n\tstruct hfa384x_metacmd cmd;\n\n\tpr_debug(\"mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\\n\",\n\t\t mode, lowaddr, highaddr, codelen);\n\n\tcmd.cmd = (HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DOWNLD) |\n\t\t   HFA384x_CMD_PROGMODE_SET(mode));\n\n\tcmd.parm0 = lowaddr;\n\tcmd.parm1 = highaddr;\n\tcmd.parm2 = codelen;\n\n\treturn hfa384x_docmd(hw, &cmd);\n}\n\n \nint hfa384x_corereset(struct hfa384x *hw, int holdtime,\n\t\t      int settletime, int genesis)\n{\n\tint result;\n\n\tresult = usb_reset_device(hw->usb);\n\tif (result < 0) {\n\t\tnetdev_err(hw->wlandev->netdev, \"usb_reset_device() failed, result=%d.\\n\",\n\t\t\t   result);\n\t}\n\n\treturn result;\n}\n\n \nstatic int hfa384x_usbctlx_complete_sync(struct hfa384x *hw,\n\t\t\t\t\t struct hfa384x_usbctlx *ctlx,\n\t\t\t\t\t struct usbctlx_completor *completor)\n{\n\tunsigned long flags;\n\tint result;\n\n\tresult = wait_for_completion_interruptible(&ctlx->done);\n\n\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\t \ncleanup:\n\tif (hw->wlandev->hwremoved) {\n\t\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\t\tresult = -ENODEV;\n\t} else if (result != 0) {\n\t\tint runqueue = 0;\n\n\t\t \n\t\tif (ctlx == get_active_ctlx(hw)) {\n\t\t\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\n\t\t\tdel_timer_sync(&hw->reqtimer);\n\t\t\tdel_timer_sync(&hw->resptimer);\n\t\t\thw->req_timer_done = 1;\n\t\t\thw->resp_timer_done = 1;\n\t\t\tusb_kill_urb(&hw->ctlx_urb);\n\n\t\t\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\t\t\trunqueue = 1;\n\n\t\t\t \n\t\t\tif (hw->wlandev->hwremoved)\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\tctlx->reapable = 1;\n\t\tctlx->state = CTLX_REQ_FAILED;\n\t\tlist_move_tail(&ctlx->list, &hw->ctlxq.completing);\n\n\t\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\n\t\tif (runqueue)\n\t\t\thfa384x_usbctlxq_run(hw);\n\t} else {\n\t\tif (ctlx->state == CTLX_COMPLETE) {\n\t\t\tresult = completor->complete(completor);\n\t\t} else {\n\t\t\tnetdev_warn(hw->wlandev->netdev, \"CTLX[%d] error: state(%s)\\n\",\n\t\t\t\t    le16_to_cpu(ctlx->outbuf.type),\n\t\t\t\t    ctlxstr(ctlx->state));\n\t\t\tresult = -EIO;\n\t\t}\n\n\t\tlist_del(&ctlx->list);\n\t\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\t\tkfree(ctlx);\n\t}\n\n\treturn result;\n}\n\n \nstatic inline int\nhfa384x_docmd(struct hfa384x *hw,\n\t      struct hfa384x_metacmd *cmd)\n{\n\tint result;\n\tstruct hfa384x_usbctlx *ctlx;\n\n\tctlx = usbctlx_alloc();\n\tif (!ctlx) {\n\t\tresult = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tctlx->outbuf.cmdreq.type = cpu_to_le16(HFA384x_USB_CMDREQ);\n\tctlx->outbuf.cmdreq.cmd = cpu_to_le16(cmd->cmd);\n\tctlx->outbuf.cmdreq.parm0 = cpu_to_le16(cmd->parm0);\n\tctlx->outbuf.cmdreq.parm1 = cpu_to_le16(cmd->parm1);\n\tctlx->outbuf.cmdreq.parm2 = cpu_to_le16(cmd->parm2);\n\n\tctlx->outbufsize = sizeof(ctlx->outbuf.cmdreq);\n\n\tpr_debug(\"cmdreq: cmd=0x%04x parm0=0x%04x parm1=0x%04x parm2=0x%04x\\n\",\n\t\t cmd->cmd, cmd->parm0, cmd->parm1, cmd->parm2);\n\n\tctlx->reapable = DOWAIT;\n\tctlx->cmdcb = NULL;\n\tctlx->usercb = NULL;\n\tctlx->usercb_data = NULL;\n\n\tresult = hfa384x_usbctlx_submit(hw, ctlx);\n\tif (result != 0) {\n\t\tkfree(ctlx);\n\t} else {\n\t\tstruct usbctlx_cmd_completor cmd_completor;\n\t\tstruct usbctlx_completor *completor;\n\n\t\tcompletor = init_cmd_completor(&cmd_completor,\n\t\t\t\t\t       &ctlx->inbuf.cmdresp,\n\t\t\t\t\t       &cmd->result);\n\n\t\tresult = hfa384x_usbctlx_complete_sync(hw, ctlx, completor);\n\t}\n\ndone:\n\treturn result;\n}\n\n \nstatic int\nhfa384x_dorrid(struct hfa384x *hw,\n\t       enum cmd_mode mode,\n\t       u16 rid,\n\t       void *riddata,\n\t       unsigned int riddatalen,\n\t       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)\n{\n\tint result;\n\tstruct hfa384x_usbctlx *ctlx;\n\n\tctlx = usbctlx_alloc();\n\tif (!ctlx) {\n\t\tresult = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tctlx->outbuf.rridreq.type = cpu_to_le16(HFA384x_USB_RRIDREQ);\n\tctlx->outbuf.rridreq.frmlen =\n\t    cpu_to_le16(sizeof(ctlx->outbuf.rridreq.rid));\n\tctlx->outbuf.rridreq.rid = cpu_to_le16(rid);\n\n\tctlx->outbufsize = sizeof(ctlx->outbuf.rridreq);\n\n\tctlx->reapable = mode;\n\tctlx->cmdcb = cmdcb;\n\tctlx->usercb = usercb;\n\tctlx->usercb_data = usercb_data;\n\n\t \n\tresult = hfa384x_usbctlx_submit(hw, ctlx);\n\tif (result != 0) {\n\t\tkfree(ctlx);\n\t} else if (mode == DOWAIT) {\n\t\tstruct usbctlx_rrid_completor completor;\n\n\t\tresult =\n\t\t    hfa384x_usbctlx_complete_sync(hw, ctlx,\n\t\t\t\t\t\t  init_rrid_completor\n\t\t\t\t\t\t  (&completor,\n\t\t\t\t\t\t   &ctlx->inbuf.rridresp,\n\t\t\t\t\t\t   riddata, riddatalen));\n\t}\n\ndone:\n\treturn result;\n}\n\n \nstatic int\nhfa384x_dowrid(struct hfa384x *hw,\n\t       enum cmd_mode mode,\n\t       u16 rid,\n\t       void *riddata,\n\t       unsigned int riddatalen,\n\t       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)\n{\n\tint result;\n\tstruct hfa384x_usbctlx *ctlx;\n\n\tctlx = usbctlx_alloc();\n\tif (!ctlx) {\n\t\tresult = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tctlx->outbuf.wridreq.type = cpu_to_le16(HFA384x_USB_WRIDREQ);\n\tctlx->outbuf.wridreq.frmlen = cpu_to_le16((sizeof\n\t\t\t\t\t\t   (ctlx->outbuf.wridreq.rid) +\n\t\t\t\t\t\t   riddatalen + 1) / 2);\n\tctlx->outbuf.wridreq.rid = cpu_to_le16(rid);\n\tmemcpy(ctlx->outbuf.wridreq.data, riddata, riddatalen);\n\n\tctlx->outbufsize = sizeof(ctlx->outbuf.wridreq.type) +\n\t    sizeof(ctlx->outbuf.wridreq.frmlen) +\n\t    sizeof(ctlx->outbuf.wridreq.rid) + riddatalen;\n\n\tctlx->reapable = mode;\n\tctlx->cmdcb = cmdcb;\n\tctlx->usercb = usercb;\n\tctlx->usercb_data = usercb_data;\n\n\t \n\tresult = hfa384x_usbctlx_submit(hw, ctlx);\n\tif (result != 0) {\n\t\tkfree(ctlx);\n\t} else if (mode == DOWAIT) {\n\t\tstruct usbctlx_cmd_completor completor;\n\t\tstruct hfa384x_cmdresult wridresult;\n\n\t\tresult = hfa384x_usbctlx_complete_sync(hw,\n\t\t\t\t\t\t       ctlx,\n\t\t\t\t\t\t       init_wrid_completor\n\t\t\t\t\t\t       (&completor,\n\t\t\t\t\t\t\t&ctlx->inbuf.wridresp,\n\t\t\t\t\t\t\t&wridresult));\n\t}\n\ndone:\n\treturn result;\n}\n\n \nstatic int\nhfa384x_dormem(struct hfa384x *hw,\n\t       u16 page,\n\t       u16 offset,\n\t       void *data,\n\t       unsigned int len)\n{\n\tint result;\n\tstruct hfa384x_usbctlx *ctlx;\n\n\tctlx = usbctlx_alloc();\n\tif (!ctlx) {\n\t\tresult = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tctlx->outbuf.rmemreq.type = cpu_to_le16(HFA384x_USB_RMEMREQ);\n\tctlx->outbuf.rmemreq.frmlen =\n\t    cpu_to_le16(sizeof(ctlx->outbuf.rmemreq.offset) +\n\t\t\tsizeof(ctlx->outbuf.rmemreq.page) + len);\n\tctlx->outbuf.rmemreq.offset = cpu_to_le16(offset);\n\tctlx->outbuf.rmemreq.page = cpu_to_le16(page);\n\n\tctlx->outbufsize = sizeof(ctlx->outbuf.rmemreq);\n\n\tpr_debug(\"type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\\n\",\n\t\t ctlx->outbuf.rmemreq.type,\n\t\t ctlx->outbuf.rmemreq.frmlen,\n\t\t ctlx->outbuf.rmemreq.offset, ctlx->outbuf.rmemreq.page);\n\n\tpr_debug(\"pktsize=%zd\\n\", ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));\n\n\tctlx->reapable = DOWAIT;\n\tctlx->cmdcb = NULL;\n\tctlx->usercb = NULL;\n\tctlx->usercb_data = NULL;\n\n\tresult = hfa384x_usbctlx_submit(hw, ctlx);\n\tif (result != 0) {\n\t\tkfree(ctlx);\n\t} else {\n\t\tstruct usbctlx_rmem_completor completor;\n\n\t\tresult =\n\t\t    hfa384x_usbctlx_complete_sync(hw, ctlx,\n\t\t\t\t\t\t  init_rmem_completor\n\t\t\t\t\t\t  (&completor,\n\t\t\t\t\t\t   &ctlx->inbuf.rmemresp, data,\n\t\t\t\t\t\t   len));\n\t}\n\ndone:\n\treturn result;\n}\n\n \nstatic int\nhfa384x_dowmem(struct hfa384x *hw,\n\t       u16 page,\n\t       u16 offset,\n\t       void *data,\n\t       unsigned int len)\n{\n\tint result;\n\tstruct hfa384x_usbctlx *ctlx;\n\n\tpr_debug(\"page=0x%04x offset=0x%04x len=%d\\n\", page, offset, len);\n\n\tctlx = usbctlx_alloc();\n\tif (!ctlx) {\n\t\tresult = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tctlx->outbuf.wmemreq.type = cpu_to_le16(HFA384x_USB_WMEMREQ);\n\tctlx->outbuf.wmemreq.frmlen =\n\t    cpu_to_le16(sizeof(ctlx->outbuf.wmemreq.offset) +\n\t\t\tsizeof(ctlx->outbuf.wmemreq.page) + len);\n\tctlx->outbuf.wmemreq.offset = cpu_to_le16(offset);\n\tctlx->outbuf.wmemreq.page = cpu_to_le16(page);\n\tmemcpy(ctlx->outbuf.wmemreq.data, data, len);\n\n\tctlx->outbufsize = sizeof(ctlx->outbuf.wmemreq.type) +\n\t    sizeof(ctlx->outbuf.wmemreq.frmlen) +\n\t    sizeof(ctlx->outbuf.wmemreq.offset) +\n\t    sizeof(ctlx->outbuf.wmemreq.page) + len;\n\n\tctlx->reapable = DOWAIT;\n\tctlx->cmdcb = NULL;\n\tctlx->usercb = NULL;\n\tctlx->usercb_data = NULL;\n\n\tresult = hfa384x_usbctlx_submit(hw, ctlx);\n\tif (result != 0) {\n\t\tkfree(ctlx);\n\t} else {\n\t\tstruct usbctlx_cmd_completor completor;\n\t\tstruct hfa384x_cmdresult wmemresult;\n\n\t\tresult = hfa384x_usbctlx_complete_sync(hw,\n\t\t\t\t\t\t       ctlx,\n\t\t\t\t\t\t       init_wmem_completor\n\t\t\t\t\t\t       (&completor,\n\t\t\t\t\t\t\t&ctlx->inbuf.wmemresp,\n\t\t\t\t\t\t\t&wmemresult));\n\t}\n\ndone:\n\treturn result;\n}\n\n \nint hfa384x_drvr_disable(struct hfa384x *hw, u16 macport)\n{\n\tint result = 0;\n\n\tif ((!hw->isap && macport != 0) ||\n\t    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||\n\t    !(hw->port_enabled[macport])) {\n\t\tresult = -EINVAL;\n\t} else {\n\t\tresult = hfa384x_cmd_disable(hw, macport);\n\t\tif (result == 0)\n\t\t\thw->port_enabled[macport] = 0;\n\t}\n\treturn result;\n}\n\n \nint hfa384x_drvr_enable(struct hfa384x *hw, u16 macport)\n{\n\tint result = 0;\n\n\tif ((!hw->isap && macport != 0) ||\n\t    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||\n\t    (hw->port_enabled[macport])) {\n\t\tresult = -EINVAL;\n\t} else {\n\t\tresult = hfa384x_cmd_enable(hw, macport);\n\t\tif (result == 0)\n\t\t\thw->port_enabled[macport] = 1;\n\t}\n\treturn result;\n}\n\n \nint hfa384x_drvr_flashdl_enable(struct hfa384x *hw)\n{\n\tint result = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < HFA384x_PORTID_MAX; i++) {\n\t\tif (hw->port_enabled[i]) {\n\t\t\tpr_debug(\"called when port enabled.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (hw->dlstate != HFA384x_DLSTATE_DISABLED)\n\t\treturn -EINVAL;\n\n\t \n\tresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER,\n\t\t\t\t\t&hw->bufinfo, sizeof(hw->bufinfo));\n\tif (result)\n\t\treturn result;\n\n\tle16_to_cpus(&hw->bufinfo.page);\n\tle16_to_cpus(&hw->bufinfo.offset);\n\tle16_to_cpus(&hw->bufinfo.len);\n\tresult = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,\n\t\t\t\t\t  &hw->dltimeout);\n\tif (result)\n\t\treturn result;\n\n\tle16_to_cpus(&hw->dltimeout);\n\n\tpr_debug(\"flashdl_enable\\n\");\n\n\thw->dlstate = HFA384x_DLSTATE_FLASHENABLED;\n\n\treturn result;\n}\n\n \nint hfa384x_drvr_flashdl_disable(struct hfa384x *hw)\n{\n\t \n\tif (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"flashdl_enable\\n\");\n\n\t \n\t \n\thfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0, 0);\n\thw->dlstate = HFA384x_DLSTATE_DISABLED;\n\n\treturn 0;\n}\n\n \nint hfa384x_drvr_flashdl_write(struct hfa384x *hw, u32 daddr,\n\t\t\t       void *buf, u32 len)\n{\n\tint result = 0;\n\tu32 dlbufaddr;\n\tint nburns;\n\tu32 burnlen;\n\tu32 burndaddr;\n\tu16 burnlo;\n\tu16 burnhi;\n\tint nwrites;\n\tu8 *writebuf;\n\tu16 writepage;\n\tu16 writeoffset;\n\tu32 writelen;\n\tint i;\n\tint j;\n\n\tpr_debug(\"daddr=0x%08x len=%d\\n\", daddr, len);\n\n\t \n\tif (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)\n\t\treturn -EINVAL;\n\n\tnetdev_info(hw->wlandev->netdev,\n\t\t    \"Download %d bytes to flash @0x%06x\\n\", len, daddr);\n\n\t \n\t \n\tdlbufaddr =\n\t    HFA384x_ADDR_AUX_MKFLAT(hw->bufinfo.page, hw->bufinfo.offset);\n\tpr_debug(\"dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\\n\",\n\t\t hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);\n\t \n\n\t \n\tnburns = len / hw->bufinfo.len;\n\tnburns += (len % hw->bufinfo.len) ? 1 : 0;\n\n\t \n\tnwrites = hw->bufinfo.len / HFA384x_USB_RWMEM_MAXLEN;\n\tnwrites += (hw->bufinfo.len % HFA384x_USB_RWMEM_MAXLEN) ? 1 : 0;\n\n\t \n\tfor (i = 0; i < nburns; i++) {\n\t\t \n\t\tburnlen = (len - (hw->bufinfo.len * i)) > hw->bufinfo.len ?\n\t\t    hw->bufinfo.len : (len - (hw->bufinfo.len * i));\n\t\tburndaddr = daddr + (hw->bufinfo.len * i);\n\t\tburnlo = HFA384x_ADDR_CMD_MKOFF(burndaddr);\n\t\tburnhi = HFA384x_ADDR_CMD_MKPAGE(burndaddr);\n\n\t\tnetdev_info(hw->wlandev->netdev, \"Writing %d bytes to flash @0x%06x\\n\",\n\t\t\t    burnlen, burndaddr);\n\n\t\t \n\t\tresult = hfa384x_cmd_download(hw, HFA384x_PROGMODE_NV,\n\t\t\t\t\t      burnlo, burnhi, burnlen);\n\t\tif (result) {\n\t\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t\t   \"download(NV,lo=%x,hi=%x,len=%x) cmd failed, result=%d. Aborting d/l\\n\",\n\t\t\t\t   burnlo, burnhi, burnlen, result);\n\t\t\tgoto exit_proc;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < nwrites; j++) {\n\t\t\twritebuf = buf +\n\t\t\t    (i * hw->bufinfo.len) +\n\t\t\t    (j * HFA384x_USB_RWMEM_MAXLEN);\n\n\t\t\twritepage = HFA384x_ADDR_CMD_MKPAGE(dlbufaddr +\n\t\t\t\t\t\t(j * HFA384x_USB_RWMEM_MAXLEN));\n\t\t\twriteoffset = HFA384x_ADDR_CMD_MKOFF(dlbufaddr +\n\t\t\t\t\t\t(j * HFA384x_USB_RWMEM_MAXLEN));\n\n\t\t\twritelen = burnlen - (j * HFA384x_USB_RWMEM_MAXLEN);\n\t\t\twritelen = writelen > HFA384x_USB_RWMEM_MAXLEN ?\n\t\t\t    HFA384x_USB_RWMEM_MAXLEN : writelen;\n\n\t\t\tresult = hfa384x_dowmem(hw,\n\t\t\t\t\t\twritepage,\n\t\t\t\t\t\twriteoffset,\n\t\t\t\t\t\twritebuf, writelen);\n\t\t}\n\n\t\t \n\t\tresult = hfa384x_cmd_download(hw,\n\t\t\t\t\t      HFA384x_PROGMODE_NVWRITE,\n\t\t\t\t\t      0, 0, 0);\n\t\tif (result) {\n\t\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t\t   \"download(NVWRITE,lo=%x,hi=%x,len=%x) cmd failed, result=%d. Aborting d/l\\n\",\n\t\t\t\t   burnlo, burnhi, burnlen, result);\n\t\t\tgoto exit_proc;\n\t\t}\n\n\t\t \n\t}\n\nexit_proc:\n\n\t \n\t \n\t \n\n\treturn result;\n}\n\n \nint hfa384x_drvr_getconfig(struct hfa384x *hw, u16 rid, void *buf, u16 len)\n{\n\treturn hfa384x_dorrid(hw, DOWAIT, rid, buf, len, NULL, NULL, NULL);\n}\n\n \nint\nhfa384x_drvr_setconfig_async(struct hfa384x *hw,\n\t\t\t     u16 rid,\n\t\t\t     void *buf,\n\t\t\t     u16 len, ctlx_usercb_t usercb, void *usercb_data)\n{\n\treturn hfa384x_dowrid(hw, DOASYNC, rid, buf, len, hfa384x_cb_status,\n\t\t\t      usercb, usercb_data);\n}\n\n \nint hfa384x_drvr_ramdl_disable(struct hfa384x *hw)\n{\n\t \n\tif (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"ramdl_disable()\\n\");\n\n\t \n\t \n\thfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0, 0);\n\thw->dlstate = HFA384x_DLSTATE_DISABLED;\n\n\treturn 0;\n}\n\n \nint hfa384x_drvr_ramdl_enable(struct hfa384x *hw, u32 exeaddr)\n{\n\tint result = 0;\n\tu16 lowaddr;\n\tu16 hiaddr;\n\tint i;\n\n\t \n\tfor (i = 0; i < HFA384x_PORTID_MAX; i++) {\n\t\tif (hw->port_enabled[i]) {\n\t\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t\t   \"Can't download with a macport enabled.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (hw->dlstate != HFA384x_DLSTATE_DISABLED) {\n\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t   \"Download state not disabled.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"ramdl_enable, exeaddr=0x%08x\\n\", exeaddr);\n\n\t \n\tlowaddr = HFA384x_ADDR_CMD_MKOFF(exeaddr);\n\thiaddr = HFA384x_ADDR_CMD_MKPAGE(exeaddr);\n\n\tresult = hfa384x_cmd_download(hw, HFA384x_PROGMODE_RAM,\n\t\t\t\t      lowaddr, hiaddr, 0);\n\n\tif (result == 0) {\n\t\t \n\t\thw->dlstate = HFA384x_DLSTATE_RAMENABLED;\n\t} else {\n\t\tpr_debug(\"cmd_download(0x%04x, 0x%04x) failed, result=%d.\\n\",\n\t\t\t lowaddr, hiaddr, result);\n\t}\n\n\treturn result;\n}\n\n \nint hfa384x_drvr_ramdl_write(struct hfa384x *hw, u32 daddr, void *buf, u32 len)\n{\n\tint result = 0;\n\tint nwrites;\n\tu8 *data = buf;\n\tint i;\n\tu32 curraddr;\n\tu16 currpage;\n\tu16 curroffset;\n\tu16 currlen;\n\n\t \n\tif (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)\n\t\treturn -EINVAL;\n\n\tnetdev_info(hw->wlandev->netdev, \"Writing %d bytes to ram @0x%06x\\n\",\n\t\t    len, daddr);\n\n\t \n\tnwrites = len / HFA384x_USB_RWMEM_MAXLEN;\n\tnwrites += len % HFA384x_USB_RWMEM_MAXLEN ? 1 : 0;\n\n\t \n\tfor (i = 0; i < nwrites; i++) {\n\t\t \n\t\tcurraddr = daddr + (i * HFA384x_USB_RWMEM_MAXLEN);\n\t\tcurrpage = HFA384x_ADDR_CMD_MKPAGE(curraddr);\n\t\tcurroffset = HFA384x_ADDR_CMD_MKOFF(curraddr);\n\t\tcurrlen = len - (i * HFA384x_USB_RWMEM_MAXLEN);\n\t\tif (currlen > HFA384x_USB_RWMEM_MAXLEN)\n\t\t\tcurrlen = HFA384x_USB_RWMEM_MAXLEN;\n\n\t\t \n\t\tresult = hfa384x_dowmem(hw,\n\t\t\t\t\tcurrpage,\n\t\t\t\t\tcurroffset,\n\t\t\t\t\tdata + (i * HFA384x_USB_RWMEM_MAXLEN),\n\t\t\t\t\tcurrlen);\n\n\t\tif (result)\n\t\t\tbreak;\n\n\t\t \n\t}\n\n\treturn result;\n}\n\n \nint hfa384x_drvr_readpda(struct hfa384x *hw, void *buf, unsigned int len)\n{\n\tint result = 0;\n\t__le16 *pda = buf;\n\tint pdaok = 0;\n\tint morepdrs = 1;\n\tint currpdr = 0;\t \n\tsize_t i;\n\tu16 pdrlen;\t\t \n\tu16 pdrcode;\t\t \n\tu16 currpage;\n\tu16 curroffset;\n\tstruct pdaloc {\n\t\tu32 cardaddr;\n\t\tu16 auxctl;\n\t} pdaloc[] = {\n\t\t{\n\t\tHFA3842_PDA_BASE, 0}, {\n\t\tHFA3841_PDA_BASE, 0}, {\n\t\tHFA3841_PDA_BOGUS_BASE, 0}\n\t};\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pdaloc); i++) {\n\t\t \n\t\tcurrpage = HFA384x_ADDR_CMD_MKPAGE(pdaloc[i].cardaddr);\n\t\tcurroffset = HFA384x_ADDR_CMD_MKOFF(pdaloc[i].cardaddr);\n\n\t\t \n\t\tresult = hfa384x_dormem(hw, currpage, curroffset, buf,\n\t\t\t\t\tlen);\n\n\t\tif (result) {\n\t\t\tnetdev_warn(hw->wlandev->netdev,\n\t\t\t\t    \"Read from index %zd failed, continuing\\n\",\n\t\t\t\t    i);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tpdaok = 1;\t \n\t\tmorepdrs = 1;\n\t\twhile (pdaok && morepdrs) {\n\t\t\tpdrlen = le16_to_cpu(pda[currpdr]) * 2;\n\t\t\tpdrcode = le16_to_cpu(pda[currpdr + 1]);\n\t\t\t \n\t\t\tif (pdrlen > HFA384x_PDR_LEN_MAX || pdrlen == 0) {\n\t\t\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t\t\t   \"pdrlen invalid=%d\\n\", pdrlen);\n\t\t\t\tpdaok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (!hfa384x_isgood_pdrcode(pdrcode)) {\n\t\t\t\tnetdev_err(hw->wlandev->netdev, \"pdrcode invalid=%d\\n\",\n\t\t\t\t\t   pdrcode);\n\t\t\t\tpdaok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (pdrcode == HFA384x_PDR_END_OF_PDA)\n\t\t\t\tmorepdrs = 0;\n\n\t\t\t \n\t\t\tif (morepdrs) {\n\t\t\t\t \n\t\t\t\tcurrpdr += le16_to_cpu(pda[currpdr]) + 1;\n\t\t\t}\n\t\t}\n\t\tif (pdaok) {\n\t\t\tnetdev_info(hw->wlandev->netdev,\n\t\t\t\t    \"PDA Read from 0x%08x in %s space.\\n\",\n\t\t\t\t    pdaloc[i].cardaddr,\n\t\t\t\t    pdaloc[i].auxctl == 0 ? \"EXTDS\" :\n\t\t\t\t    pdaloc[i].auxctl == 1 ? \"NV\" :\n\t\t\t\t    pdaloc[i].auxctl == 2 ? \"PHY\" :\n\t\t\t\t    pdaloc[i].auxctl == 3 ? \"ICSRAM\" :\n\t\t\t\t    \"<bogus auxctl>\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tresult = pdaok ? 0 : -ENODATA;\n\n\tif (result)\n\t\tpr_debug(\"Failure: pda is not okay\\n\");\n\n\treturn result;\n}\n\n \nint hfa384x_drvr_setconfig(struct hfa384x *hw, u16 rid, void *buf, u16 len)\n{\n\treturn hfa384x_dowrid(hw, DOWAIT, rid, buf, len, NULL, NULL, NULL);\n}\n\n \nint hfa384x_drvr_start(struct hfa384x *hw)\n{\n\tint result, result1, result2;\n\tu16 status;\n\n\tmight_sleep();\n\n\t \n\tresult =\n\t    usb_get_std_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_in,\n\t\t\t       &status);\n\tif (result < 0) {\n\t\tnetdev_err(hw->wlandev->netdev, \"Cannot get bulk in endpoint status.\\n\");\n\t\tgoto done;\n\t}\n\tif ((status == 1) && usb_clear_halt(hw->usb, hw->endp_in))\n\t\tnetdev_err(hw->wlandev->netdev, \"Failed to reset bulk in endpoint.\\n\");\n\n\tresult =\n\t    usb_get_std_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_out,\n\t\t\t       &status);\n\tif (result < 0) {\n\t\tnetdev_err(hw->wlandev->netdev, \"Cannot get bulk out endpoint status.\\n\");\n\t\tgoto done;\n\t}\n\tif ((status == 1) && usb_clear_halt(hw->usb, hw->endp_out))\n\t\tnetdev_err(hw->wlandev->netdev, \"Failed to reset bulk out endpoint.\\n\");\n\n\t \n\tusb_kill_urb(&hw->rx_urb);\n\n\t \n\tresult = submit_rx_urb(hw, GFP_KERNEL);\n\tif (result != 0) {\n\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t   \"Fatal, failed to submit RX URB, result=%d\\n\",\n\t\t\t   result);\n\t\tgoto done;\n\t}\n\n\t \n\tresult1 = hfa384x_cmd_initialize(hw);\n\tmsleep(1000);\n\tresult = hfa384x_cmd_initialize(hw);\n\tresult2 = result;\n\tif (result1 != 0) {\n\t\tif (result2 != 0) {\n\t\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t\t   \"cmd_initialize() failed on two attempts, results %d and %d\\n\",\n\t\t\t\t   result1, result2);\n\t\t\tusb_kill_urb(&hw->rx_urb);\n\t\t\tgoto done;\n\t\t} else {\n\t\t\tpr_debug(\"First cmd_initialize() failed (result %d),\\n\",\n\t\t\t\t result1);\n\t\t\tpr_debug(\"but second attempt succeeded. All should be ok\\n\");\n\t\t}\n\t} else if (result2 != 0) {\n\t\tnetdev_warn(hw->wlandev->netdev, \"First cmd_initialize() succeeded, but second attempt failed (result=%d)\\n\",\n\t\t\t    result2);\n\t\tnetdev_warn(hw->wlandev->netdev,\n\t\t\t    \"Most likely the card will be functional\\n\");\n\t\tgoto done;\n\t}\n\n\thw->state = HFA384x_STATE_RUNNING;\n\ndone:\n\treturn result;\n}\n\n \nint hfa384x_drvr_stop(struct hfa384x *hw)\n{\n\tint i;\n\n\tmight_sleep();\n\n\t \n\tif (!hw->wlandev->hwremoved) {\n\t\t \n\t\thfa384x_cmd_initialize(hw);\n\n\t\t \n\t\tusb_kill_urb(&hw->rx_urb);\n\t}\n\n\thw->link_status = HFA384x_LINK_NOTCONNECTED;\n\thw->state = HFA384x_STATE_INIT;\n\n\tdel_timer_sync(&hw->commsqual_timer);\n\n\t \n\tfor (i = 0; i < HFA384x_NUMPORTS_MAX; i++)\n\t\thw->port_enabled[i] = 0;\n\n\treturn 0;\n}\n\n \nint hfa384x_drvr_txframe(struct hfa384x *hw, struct sk_buff *skb,\n\t\t\t struct p80211_hdr *p80211_hdr,\n\t\t\t struct p80211_metawep *p80211_wep)\n{\n\tint usbpktlen = sizeof(struct hfa384x_tx_frame);\n\tint result;\n\tint ret;\n\tchar *ptr;\n\n\tif (hw->tx_urb.status == -EINPROGRESS) {\n\t\tnetdev_warn(hw->wlandev->netdev, \"TX URB already in use\\n\");\n\t\tresult = 3;\n\t\tgoto exit;\n\t}\n\n\t \n\t \n\tmemset(&hw->txbuff.txfrm.desc, 0, sizeof(hw->txbuff.txfrm.desc));\n\n\t \n\thw->txbuff.type = cpu_to_le16(HFA384x_USB_TXFRM);\n\n\t \n\thw->txbuff.txfrm.desc.sw_support = 0x0123;\n\n \n \n#if defined(DOBOTH)\n\thw->txbuff.txfrm.desc.tx_control =\n\t    HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |\n\t    HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(1);\n#elif defined(DOEXC)\n\thw->txbuff.txfrm.desc.tx_control =\n\t    HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |\n\t    HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(0);\n#else\n\thw->txbuff.txfrm.desc.tx_control =\n\t    HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |\n\t    HFA384x_TX_TXEX_SET(0) | HFA384x_TX_TXOK_SET(0);\n#endif\n\tcpu_to_le16s(&hw->txbuff.txfrm.desc.tx_control);\n\n\t \n\thw->txbuff.txfrm.desc.hdr = *p80211_hdr;\n\n\t \n\tif (p80211_wep->data) {\n\t\thw->txbuff.txfrm.desc.data_len = cpu_to_le16(skb->len + 8);\n\t\tusbpktlen += 8;\n\t} else {\n\t\thw->txbuff.txfrm.desc.data_len = cpu_to_le16(skb->len);\n\t}\n\n\tusbpktlen += skb->len;\n\n\t \n\tptr = hw->txbuff.txfrm.data;\n\tif (p80211_wep->data) {\n\t\tmemcpy(ptr, p80211_wep->iv, sizeof(p80211_wep->iv));\n\t\tptr += sizeof(p80211_wep->iv);\n\t\tmemcpy(ptr, p80211_wep->data, skb->len);\n\t} else {\n\t\tmemcpy(ptr, skb->data, skb->len);\n\t}\n\t \n\tptr += skb->len;\n\n\t \n\tif (p80211_wep->data)\n\t\tmemcpy(ptr, p80211_wep->icv, sizeof(p80211_wep->icv));\n\n\t \n\tusb_fill_bulk_urb(&hw->tx_urb, hw->usb,\n\t\t\t  hw->endp_out,\n\t\t\t  &hw->txbuff, ROUNDUP64(usbpktlen),\n\t\t\t  hfa384x_usbout_callback, hw->wlandev);\n\thw->tx_urb.transfer_flags |= USB_QUEUE_BULK;\n\n\tresult = 1;\n\tret = submit_tx_urb(hw, &hw->tx_urb, GFP_ATOMIC);\n\tif (ret != 0) {\n\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t   \"submit_tx_urb() failed, error=%d\\n\", ret);\n\t\tresult = 3;\n\t}\n\nexit:\n\treturn result;\n}\n\nvoid hfa384x_tx_timeout(struct wlandevice *wlandev)\n{\n\tstruct hfa384x *hw = wlandev->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\tif (!hw->wlandev->hwremoved) {\n\t\tint sched;\n\n\t\tsched = !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags);\n\t\tsched |= !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags);\n\t\tif (sched)\n\t\t\tschedule_work(&hw->usb_work);\n\t}\n\n\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n}\n\n \nstatic void hfa384x_usbctlx_reaper_task(struct work_struct *work)\n{\n\tstruct hfa384x *hw = container_of(work, struct hfa384x, reaper_bh);\n\tstruct hfa384x_usbctlx *ctlx, *temp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\t \n\tlist_for_each_entry_safe(ctlx, temp, &hw->ctlxq.reapable, list) {\n\t\tlist_del(&ctlx->list);\n\t\tkfree(ctlx);\n\t}\n\n\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n}\n\n \nstatic void hfa384x_usbctlx_completion_task(struct work_struct *work)\n{\n\tstruct hfa384x *hw = container_of(work, struct hfa384x, completion_bh);\n\tstruct hfa384x_usbctlx *ctlx, *temp;\n\tunsigned long flags;\n\n\tint reap = 0;\n\n\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\t \n\tlist_for_each_entry_safe(ctlx, temp, &hw->ctlxq.completing, list) {\n\t\t \n\t\tif (ctlx->cmdcb) {\n\t\t\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\t\t\tctlx->cmdcb(hw, ctlx);\n\t\t\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\t\t\t \n\t\t\tctlx->cmdcb = NULL;\n\n\t\t\t \n\t\t\tif (hw->wlandev->hwremoved) {\n\t\t\t\treap = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (ctlx->reapable) {\n\t\t\t \n\t\t\tlist_move_tail(&ctlx->list, &hw->ctlxq.reapable);\n\t\t\treap = 1;\n\t\t}\n\n\t\tcomplete(&ctlx->done);\n\t}\n\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\n\tif (reap)\n\t\tschedule_work(&hw->reaper_bh);\n}\n\n \nstatic int unlocked_usbctlx_cancel_async(struct hfa384x *hw,\n\t\t\t\t\t struct hfa384x_usbctlx *ctlx)\n{\n\tint ret;\n\n\t \n\thw->ctlx_urb.transfer_flags |= URB_ASYNC_UNLINK;\n\tret = usb_unlink_urb(&hw->ctlx_urb);\n\n\tif (ret != -EINPROGRESS) {\n\t\t \n\t\tctlx->state = CTLX_REQ_FAILED;\n\t\tunlocked_usbctlx_complete(hw, ctlx);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void unlocked_usbctlx_complete(struct hfa384x *hw,\n\t\t\t\t      struct hfa384x_usbctlx *ctlx)\n{\n\t \n\tlist_move_tail(&ctlx->list, &hw->ctlxq.completing);\n\tschedule_work(&hw->completion_bh);\n\n\tswitch (ctlx->state) {\n\tcase CTLX_COMPLETE:\n\tcase CTLX_REQ_FAILED:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_err(hw->wlandev->netdev, \"CTLX[%d] not in a terminating state(%s)\\n\",\n\t\t\t   le16_to_cpu(ctlx->outbuf.type),\n\t\t\t   ctlxstr(ctlx->state));\n\t\tbreak;\n\t}\t\t\t \n}\n\n \nstatic void hfa384x_usbctlxq_run(struct hfa384x *hw)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\t \n\tif (!list_empty(&hw->ctlxq.active) ||\n\t    test_bit(WORK_TX_HALT, &hw->usb_flags) || hw->wlandev->hwremoved)\n\t\tgoto unlock;\n\n\twhile (!list_empty(&hw->ctlxq.pending)) {\n\t\tstruct hfa384x_usbctlx *head;\n\t\tint result;\n\n\t\t \n\t\thead = list_entry(hw->ctlxq.pending.next,\n\t\t\t\t  struct hfa384x_usbctlx, list);\n\n\t\t \n\t\tlist_move_tail(&head->list, &hw->ctlxq.active);\n\n\t\t \n\t\tusb_fill_bulk_urb(&hw->ctlx_urb, hw->usb,\n\t\t\t\t  hw->endp_out,\n\t\t\t\t  &head->outbuf, ROUNDUP64(head->outbufsize),\n\t\t\t\t  hfa384x_ctlxout_callback, hw);\n\t\thw->ctlx_urb.transfer_flags |= USB_QUEUE_BULK;\n\n\t\t \n\t\tresult = usb_submit_urb(&hw->ctlx_urb, GFP_ATOMIC);\n\t\tif (result == 0) {\n\t\t\t \n\t\t\thead->state = CTLX_REQ_SUBMITTED;\n\n\t\t\t \n\t\t\thw->req_timer_done = 0;\n\t\t\thw->reqtimer.expires = jiffies + HZ;\n\t\t\tadd_timer(&hw->reqtimer);\n\n\t\t\t \n\t\t\thw->resp_timer_done = 0;\n\t\t\thw->resptimer.expires = jiffies + 2 * HZ;\n\t\t\tadd_timer(&hw->resptimer);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result == -EPIPE) {\n\t\t\t \n\t\t\tnetdev_warn(hw->wlandev->netdev,\n\t\t\t\t    \"%s tx pipe stalled: requesting reset\\n\",\n\t\t\t\t    hw->wlandev->netdev->name);\n\t\t\tlist_move(&head->list, &hw->ctlxq.pending);\n\t\t\tset_bit(WORK_TX_HALT, &hw->usb_flags);\n\t\t\tschedule_work(&hw->usb_work);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result == -ESHUTDOWN) {\n\t\t\tnetdev_warn(hw->wlandev->netdev, \"%s urb shutdown!\\n\",\n\t\t\t\t    hw->wlandev->netdev->name);\n\t\t\tbreak;\n\t\t}\n\n\t\tnetdev_err(hw->wlandev->netdev, \"Failed to submit CTLX[%d]: error=%d\\n\",\n\t\t\t   le16_to_cpu(head->outbuf.type), result);\n\t\tunlocked_usbctlx_complete(hw, head);\n\t}\t\t\t \n\nunlock:\n\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n}\n\n \nstatic void hfa384x_usbin_callback(struct urb *urb)\n{\n\tstruct wlandevice *wlandev = urb->context;\n\tstruct hfa384x *hw;\n\tunion hfa384x_usbin *usbin;\n\tstruct sk_buff *skb = NULL;\n\tint result;\n\tint urb_status;\n\tu16 type;\n\n\tenum USBIN_ACTION {\n\t\tHANDLE,\n\t\tRESUBMIT,\n\t\tABORT\n\t} action;\n\n\tif (!wlandev || !wlandev->netdev || wlandev->hwremoved)\n\t\tgoto exit;\n\n\thw = wlandev->priv;\n\tif (!hw)\n\t\tgoto exit;\n\n\tskb = hw->rx_urb_skb;\n\tif (!skb || (skb->data != urb->transfer_buffer)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\thw->rx_urb_skb = NULL;\n\n\t \n\tswitch (urb->status) {\n\tcase 0:\n\t\taction = HANDLE;\n\n\t\t \n\t\tif (urb->actual_length == 0) {\n\t\t\twlandev->netdev->stats.rx_errors++;\n\t\t\twlandev->netdev->stats.rx_length_errors++;\n\t\t\taction = RESUBMIT;\n\t\t}\n\t\tbreak;\n\n\tcase -EPIPE:\n\t\tnetdev_warn(hw->wlandev->netdev, \"%s rx pipe stalled: requesting reset\\n\",\n\t\t\t    wlandev->netdev->name);\n\t\tif (!test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))\n\t\t\tschedule_work(&hw->usb_work);\n\t\twlandev->netdev->stats.rx_errors++;\n\t\taction = ABORT;\n\t\tbreak;\n\n\tcase -EILSEQ:\n\tcase -ETIMEDOUT:\n\tcase -EPROTO:\n\t\tif (!test_and_set_bit(THROTTLE_RX, &hw->usb_flags) &&\n\t\t    !timer_pending(&hw->throttle)) {\n\t\t\tmod_timer(&hw->throttle, jiffies + THROTTLE_JIFFIES);\n\t\t}\n\t\twlandev->netdev->stats.rx_errors++;\n\t\taction = ABORT;\n\t\tbreak;\n\n\tcase -EOVERFLOW:\n\t\twlandev->netdev->stats.rx_over_errors++;\n\t\taction = RESUBMIT;\n\t\tbreak;\n\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\tpr_debug(\"status=%d, device removed.\\n\", urb->status);\n\t\taction = ABORT;\n\t\tbreak;\n\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\t\tpr_debug(\"status=%d, urb explicitly unlinked.\\n\", urb->status);\n\t\taction = ABORT;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"urb status=%d, transfer flags=0x%x\\n\",\n\t\t\t urb->status, urb->transfer_flags);\n\t\twlandev->netdev->stats.rx_errors++;\n\t\taction = RESUBMIT;\n\t\tbreak;\n\t}\n\n\t \n\turb_status = urb->status;\n\tusbin = (union hfa384x_usbin *)urb->transfer_buffer;\n\n\tif (action != ABORT) {\n\t\t \n\t\tresult = submit_rx_urb(hw, GFP_ATOMIC);\n\n\t\tif (result != 0) {\n\t\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t\t   \"Fatal, failed to resubmit rx_urb. error=%d\\n\",\n\t\t\t\t   result);\n\t\t}\n\t}\n\n\t \n\t \n\ttype = le16_to_cpu(usbin->type);\n\tif (HFA384x_USB_ISRXFRM(type)) {\n\t\tif (action == HANDLE) {\n\t\t\tif (usbin->txfrm.desc.sw_support == 0x0123) {\n\t\t\t\thfa384x_usbin_txcompl(wlandev, usbin);\n\t\t\t} else {\n\t\t\t\tskb_put(skb, sizeof(*usbin));\n\t\t\t\thfa384x_usbin_rx(wlandev, skb);\n\t\t\t\tskb = NULL;\n\t\t\t}\n\t\t}\n\t\tgoto exit;\n\t}\n\tif (HFA384x_USB_ISTXFRM(type)) {\n\t\tif (action == HANDLE)\n\t\t\thfa384x_usbin_txcompl(wlandev, usbin);\n\t\tgoto exit;\n\t}\n\tswitch (type) {\n\tcase HFA384x_USB_INFOFRM:\n\t\tif (action == ABORT)\n\t\t\tgoto exit;\n\t\tif (action == HANDLE)\n\t\t\thfa384x_usbin_info(wlandev, usbin);\n\t\tbreak;\n\n\tcase HFA384x_USB_CMDRESP:\n\tcase HFA384x_USB_WRIDRESP:\n\tcase HFA384x_USB_RRIDRESP:\n\tcase HFA384x_USB_WMEMRESP:\n\tcase HFA384x_USB_RMEMRESP:\n\t\t \n\t\thfa384x_usbin_ctlx(hw, usbin, urb_status);\n\t\tbreak;\n\n\tcase HFA384x_USB_BUFAVAIL:\n\t\tpr_debug(\"Received BUFAVAIL packet, frmlen=%d\\n\",\n\t\t\t usbin->bufavail.frmlen);\n\t\tbreak;\n\n\tcase HFA384x_USB_ERROR:\n\t\tpr_debug(\"Received USB_ERROR packet, errortype=%d\\n\",\n\t\t\t usbin->usberror.errortype);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"Unrecognized USBIN packet, type=%x, status=%d\\n\",\n\t\t\t usbin->type, urb_status);\n\t\tbreak;\n\t}\t\t\t \n\nexit:\n\n\tif (skb)\n\t\tdev_kfree_skb(skb);\n}\n\n \nstatic void hfa384x_usbin_ctlx(struct hfa384x *hw, union hfa384x_usbin *usbin,\n\t\t\t       int urb_status)\n{\n\tstruct hfa384x_usbctlx *ctlx;\n\tint run_queue = 0;\n\tunsigned long flags;\n\nretry:\n\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\t \n\tif (list_empty(&hw->ctlxq.active))\n\t\tgoto unlock;\n\n\t \n\tif (del_timer(&hw->resptimer) == 0) {\n\t\tif (hw->resp_timer_done == 0) {\n\t\t\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\thw->resp_timer_done = 1;\n\t}\n\n\tctlx = get_active_ctlx(hw);\n\n\tif (urb_status != 0) {\n\t\t \n\t\tif (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)\n\t\t\trun_queue = 1;\n\t} else {\n\t\tconst __le16 intype = (usbin->type & ~cpu_to_le16(0x8000));\n\n\t\t \n\t\tif (ctlx->outbuf.type != intype) {\n\t\t\tnetdev_warn(hw->wlandev->netdev,\n\t\t\t\t    \"Expected IN[%d], received IN[%d] - ignored.\\n\",\n\t\t\t\t    le16_to_cpu(ctlx->outbuf.type),\n\t\t\t\t    le16_to_cpu(intype));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t \n\t\tmemcpy(&ctlx->inbuf, usbin, sizeof(ctlx->inbuf));\n\n\t\tswitch (ctlx->state) {\n\t\tcase CTLX_REQ_SUBMITTED:\n\t\t\t \n\t\t\tpr_debug(\"Causality violation: please reboot Universe\\n\");\n\t\t\tctlx->state = CTLX_RESP_COMPLETE;\n\t\t\tbreak;\n\n\t\tcase CTLX_REQ_COMPLETE:\n\t\t\t \n\t\t\tctlx->state = CTLX_COMPLETE;\n\t\t\tunlocked_usbctlx_complete(hw, ctlx);\n\t\t\trun_queue = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t\t   \"Matched IN URB, CTLX[%d] in invalid state(%s). Discarded.\\n\",\n\t\t\t\t   le16_to_cpu(ctlx->outbuf.type),\n\t\t\t\t   ctlxstr(ctlx->state));\n\t\t\tif (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)\n\t\t\t\trun_queue = 1;\n\t\t\tbreak;\n\t\t}\t\t \n\t}\n\nunlock:\n\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\n\tif (run_queue)\n\t\thfa384x_usbctlxq_run(hw);\n}\n\n \nstatic void hfa384x_usbin_txcompl(struct wlandevice *wlandev,\n\t\t\t\t  union hfa384x_usbin *usbin)\n{\n\tu16 status;\n\n\tstatus = le16_to_cpu(usbin->type);  \n\n\t \n\tif (HFA384x_TXSTATUS_ISERROR(status))\n\t\tprism2sta_ev_txexc(wlandev, status);\n\telse\n\t\tprism2sta_ev_tx(wlandev, status);\n}\n\n \nstatic void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)\n{\n\tunion hfa384x_usbin *usbin = (union hfa384x_usbin *)skb->data;\n\tstruct hfa384x *hw = wlandev->priv;\n\tint hdrlen;\n\tstruct p80211_rxmeta *rxmeta;\n\tu16 data_len;\n\tu16 fc;\n\tu16 status;\n\n\t \n\tle16_to_cpus(&usbin->rxfrm.desc.status);\n\tle32_to_cpus(&usbin->rxfrm.desc.time);\n\n\t \n\tstatus = HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status);\n\n\tswitch (status) {\n\tcase 0:\n\t\tfc = le16_to_cpu(usbin->rxfrm.desc.hdr.frame_control);\n\n\t\t \n\t\tif ((wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED) &&\n\t\t    !WLAN_GET_FC_ISWEP(fc)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tdata_len = le16_to_cpu(usbin->rxfrm.desc.data_len);\n\n\t\t \n\t\thdrlen = p80211_headerlen(fc);\n\n\t\t \n\t\tskb_pull(skb, sizeof(struct hfa384x_rx_frame));\n\n\t\t \n\t\tmemmove(skb_push(skb, hdrlen),\n\t\t\t&usbin->rxfrm.desc.hdr, hdrlen);\n\n\t\tskb->dev = wlandev->netdev;\n\n\t\t \n\t\tskb_trim(skb, data_len + hdrlen);\n\n\t\t \n\t\tmemset(skb_put(skb, WLAN_CRC_LEN), 0xff, WLAN_CRC_LEN);\n\n\t\tskb_reset_mac_header(skb);\n\n\t\t \n\t\tp80211skb_rxmeta_attach(wlandev, skb);\n\t\trxmeta = p80211skb_rxmeta(skb);\n\t\trxmeta->mactime = usbin->rxfrm.desc.time;\n\t\trxmeta->rxrate = usbin->rxfrm.desc.rate;\n\t\trxmeta->signal = usbin->rxfrm.desc.signal - hw->dbmadjust;\n\t\trxmeta->noise = usbin->rxfrm.desc.silence - hw->dbmadjust;\n\n\t\tp80211netdev_rx(wlandev, skb);\n\n\t\tbreak;\n\n\tcase 7:\n\t\tif (!HFA384x_RXSTATUS_ISFCSERR(usbin->rxfrm.desc.status)) {\n\t\t\t \n\t\t\thfa384x_int_rxmonitor(wlandev, &usbin->rxfrm);\n\t\t\tdev_kfree_skb(skb);\n\t\t} else {\n\t\t\tpr_debug(\"Received monitor frame: FCSerr set\\n\");\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_warn(hw->wlandev->netdev,\n\t\t\t    \"Received frame on unsupported port=%d\\n\",\n\t\t\t    status);\n\t\tbreak;\n\t}\n}\n\n \nstatic void hfa384x_int_rxmonitor(struct wlandevice *wlandev,\n\t\t\t\t  struct hfa384x_usb_rxfrm *rxfrm)\n{\n\tstruct hfa384x_rx_frame *rxdesc = &rxfrm->desc;\n\tunsigned int hdrlen = 0;\n\tunsigned int datalen = 0;\n\tunsigned int skblen = 0;\n\tu8 *datap;\n\tu16 fc;\n\tstruct sk_buff *skb;\n\tstruct hfa384x *hw = wlandev->priv;\n\n\t \n\t \n\tfc = le16_to_cpu(rxdesc->hdr.frame_control);\n\thdrlen = p80211_headerlen(fc);\n\tdatalen = le16_to_cpu(rxdesc->data_len);\n\n\t \n\tskblen = sizeof(struct p80211_caphdr) + hdrlen + datalen + WLAN_CRC_LEN;\n\n\t \n\tif (skblen >\n\t    (sizeof(struct p80211_caphdr) +\n\t     WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN)) {\n\t\tpr_debug(\"overlen frm: len=%zd\\n\",\n\t\t\t skblen - sizeof(struct p80211_caphdr));\n\n\t\treturn;\n\t}\n\n\tskb = dev_alloc_skb(skblen);\n\tif (!skb)\n\t\treturn;\n\n\t \n\tif ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&\n\t    (hw->sniffhdr != 0)) {\n\t\tstruct p80211_caphdr *caphdr;\n\t\t \n\t\tdatap = skb_put(skb, sizeof(struct p80211_caphdr));\n\t\tcaphdr = (struct p80211_caphdr *)datap;\n\n\t\tcaphdr->version = htonl(P80211CAPTURE_VERSION);\n\t\tcaphdr->length = htonl(sizeof(struct p80211_caphdr));\n\t\tcaphdr->mactime = __cpu_to_be64(rxdesc->time * 1000);\n\t\tcaphdr->hosttime = __cpu_to_be64(jiffies);\n\t\tcaphdr->phytype = htonl(4);\t \n\t\tcaphdr->channel = htonl(hw->sniff_channel);\n\t\tcaphdr->datarate = htonl(rxdesc->rate);\n\t\tcaphdr->antenna = htonl(0);\t \n\t\tcaphdr->priority = htonl(0);\t \n\t\tcaphdr->ssi_type = htonl(3);\t \n\t\tcaphdr->ssi_signal = htonl(rxdesc->signal);\n\t\tcaphdr->ssi_noise = htonl(rxdesc->silence);\n\t\tcaphdr->preamble = htonl(0);\t \n\t\tcaphdr->encoding = htonl(1);\t \n\t}\n\n\t \n\tskb_put_data(skb, &rxdesc->hdr.frame_control, hdrlen);\n\n\t \n\tif (datalen > 0) {\n\t\tdatap = skb_put_data(skb, rxfrm->data, datalen);\n\n\t\t \n\t\tif (*(datap - hdrlen + 1) & 0x40)\t \n\t\t\tif ((*(datap) == 0xaa) && (*(datap + 1) == 0xaa))\n\t\t\t\t \n\t\t\t\t*(datap - hdrlen + 1) &= 0xbf;\n\t}\n\n\tif (hw->sniff_fcs) {\n\t\t \n\t\tdatap = skb_put(skb, WLAN_CRC_LEN);\n\t\tmemset(datap, 0xff, WLAN_CRC_LEN);\n\t}\n\n\t \n\tp80211netdev_rx(wlandev, skb);\n}\n\n \nstatic void hfa384x_usbin_info(struct wlandevice *wlandev,\n\t\t\t       union hfa384x_usbin *usbin)\n{\n\tle16_to_cpus(&usbin->infofrm.info.framelen);\n\tprism2sta_ev_info(wlandev, &usbin->infofrm.info);\n}\n\n \nstatic void hfa384x_usbout_callback(struct urb *urb)\n{\n\tstruct wlandevice *wlandev = urb->context;\n\n#ifdef DEBUG_USB\n\tdbprint_urb(urb);\n#endif\n\n\tif (wlandev && wlandev->netdev) {\n\t\tswitch (urb->status) {\n\t\tcase 0:\n\t\t\tprism2sta_ev_alloc(wlandev);\n\t\t\tbreak;\n\n\t\tcase -EPIPE: {\n\t\t\tstruct hfa384x *hw = wlandev->priv;\n\n\t\t\tnetdev_warn(hw->wlandev->netdev,\n\t\t\t\t    \"%s tx pipe stalled: requesting reset\\n\",\n\t\t\t\t    wlandev->netdev->name);\n\t\t\tif (!test_and_set_bit(WORK_TX_HALT, &hw->usb_flags))\n\t\t\t\tschedule_work(&hw->usb_work);\n\t\t\twlandev->netdev->stats.tx_errors++;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase -EPROTO:\n\t\tcase -ETIMEDOUT:\n\t\tcase -EILSEQ: {\n\t\t\tstruct hfa384x *hw = wlandev->priv;\n\n\t\t\tif (!test_and_set_bit(THROTTLE_TX, &hw->usb_flags) &&\n\t\t\t    !timer_pending(&hw->throttle)) {\n\t\t\t\tmod_timer(&hw->throttle,\n\t\t\t\t\t  jiffies + THROTTLE_JIFFIES);\n\t\t\t}\n\t\t\twlandev->netdev->stats.tx_errors++;\n\t\t\tnetif_stop_queue(wlandev->netdev);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase -ENOENT:\n\t\tcase -ESHUTDOWN:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnetdev_info(wlandev->netdev, \"unknown urb->status=%d\\n\",\n\t\t\t\t    urb->status);\n\t\t\twlandev->netdev->stats.tx_errors++;\n\t\t\tbreak;\n\t\t}\t\t \n\t}\n}\n\n \nstatic void hfa384x_ctlxout_callback(struct urb *urb)\n{\n\tstruct hfa384x *hw = urb->context;\n\tint delete_resptimer = 0;\n\tint timer_ok = 1;\n\tint run_queue = 0;\n\tstruct hfa384x_usbctlx *ctlx;\n\tunsigned long flags;\n\n\tpr_debug(\"urb->status=%d\\n\", urb->status);\n#ifdef DEBUG_USB\n\tdbprint_urb(urb);\n#endif\n\tif ((urb->status == -ESHUTDOWN) ||\n\t    (urb->status == -ENODEV) || !hw)\n\t\treturn;\n\nretry:\n\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\t \n\tif (list_empty(&hw->ctlxq.active)) {\n\t\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tif (del_timer(&hw->reqtimer) == 0) {\n\t\tif (hw->req_timer_done == 0) {\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\thw->req_timer_done = 1;\n\t}\n\n\tctlx = get_active_ctlx(hw);\n\n\tif (urb->status == 0) {\n\t\t \n\t\tswitch (ctlx->state) {\n\t\tcase CTLX_REQ_SUBMITTED:\n\t\t\t \n\t\t\tctlx->state = CTLX_REQ_COMPLETE;\n\t\t\tbreak;\n\n\t\tcase CTLX_RESP_COMPLETE:\n\t\t\t \n\t\t\tctlx->state = CTLX_COMPLETE;\n\t\t\tunlocked_usbctlx_complete(hw, ctlx);\n\t\t\trun_queue = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tnetdev_err(hw->wlandev->netdev,\n\t\t\t\t   \"Illegal CTLX[%d] success state(%s, %d) in OUT URB\\n\",\n\t\t\t\t   le16_to_cpu(ctlx->outbuf.type),\n\t\t\t\t   ctlxstr(ctlx->state), urb->status);\n\t\t\tbreak;\n\t\t}\t\t \n\t} else {\n\t\t \n\t\tif ((urb->status == -EPIPE) &&\n\t\t    !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags)) {\n\t\t\tnetdev_warn(hw->wlandev->netdev,\n\t\t\t\t    \"%s tx pipe stalled: requesting reset\\n\",\n\t\t\t\t    hw->wlandev->netdev->name);\n\t\t\tschedule_work(&hw->usb_work);\n\t\t}\n\n\t\t \n\t\tctlx->state = CTLX_REQ_FAILED;\n\t\tunlocked_usbctlx_complete(hw, ctlx);\n\t\tdelete_resptimer = 1;\n\t\trun_queue = 1;\n\t}\n\ndelresp:\n\tif (delete_resptimer) {\n\t\ttimer_ok = del_timer(&hw->resptimer);\n\t\tif (timer_ok != 0)\n\t\t\thw->resp_timer_done = 1;\n\t}\n\n\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\n\tif (!timer_ok && (hw->resp_timer_done == 0)) {\n\t\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\t\tgoto delresp;\n\t}\n\n\tif (run_queue)\n\t\thfa384x_usbctlxq_run(hw);\n}\n\n \nstatic void hfa384x_usbctlx_reqtimerfn(struct timer_list *t)\n{\n\tstruct hfa384x *hw = from_timer(hw, t, reqtimer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\thw->req_timer_done = 1;\n\n\t \n\tif (!list_empty(&hw->ctlxq.active)) {\n\t\t \n\t\thw->ctlx_urb.transfer_flags |= URB_ASYNC_UNLINK;\n\t\tif (usb_unlink_urb(&hw->ctlx_urb) == -EINPROGRESS) {\n\t\t\tstruct hfa384x_usbctlx *ctlx = get_active_ctlx(hw);\n\n\t\t\tctlx->state = CTLX_REQ_FAILED;\n\n\t\t\t \n\t\t\tif (del_timer(&hw->resptimer) != 0)\n\t\t\t\thw->resp_timer_done = 1;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n}\n\n \nstatic void hfa384x_usbctlx_resptimerfn(struct timer_list *t)\n{\n\tstruct hfa384x *hw = from_timer(hw, t, resptimer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\thw->resp_timer_done = 1;\n\n\t \n\tif (!list_empty(&hw->ctlxq.active)) {\n\t\tstruct hfa384x_usbctlx *ctlx = get_active_ctlx(hw);\n\n\t\tif (unlocked_usbctlx_cancel_async(hw, ctlx) == 0) {\n\t\t\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\t\t\thfa384x_usbctlxq_run(hw);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n}\n\n \nstatic void hfa384x_usb_throttlefn(struct timer_list *t)\n{\n\tstruct hfa384x *hw = from_timer(hw, t, throttle);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\tpr_debug(\"flags=0x%lx\\n\", hw->usb_flags);\n\tif (!hw->wlandev->hwremoved) {\n\t\tbool rx_throttle = test_and_clear_bit(THROTTLE_RX, &hw->usb_flags) &&\n\t\t\t\t   !test_and_set_bit(WORK_RX_RESUME, &hw->usb_flags);\n\t\tbool tx_throttle = test_and_clear_bit(THROTTLE_TX, &hw->usb_flags) &&\n\t\t\t\t   !test_and_set_bit(WORK_TX_RESUME, &hw->usb_flags);\n\t\t \n\t\tif (rx_throttle | tx_throttle)\n\t\t\tschedule_work(&hw->usb_work);\n\t}\n\n\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n}\n\n \nstatic int hfa384x_usbctlx_submit(struct hfa384x *hw,\n\t\t\t\t  struct hfa384x_usbctlx *ctlx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->ctlxq.lock, flags);\n\n\tif (hw->wlandev->hwremoved) {\n\t\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tctlx->state = CTLX_PENDING;\n\tlist_add_tail(&ctlx->list, &hw->ctlxq.pending);\n\tspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\n\thfa384x_usbctlxq_run(hw);\n\n\treturn 0;\n}\n\n \nstatic int hfa384x_isgood_pdrcode(u16 pdrcode)\n{\n\tswitch (pdrcode) {\n\tcase HFA384x_PDR_END_OF_PDA:\n\tcase HFA384x_PDR_PCB_PARTNUM:\n\tcase HFA384x_PDR_PDAVER:\n\tcase HFA384x_PDR_NIC_SERIAL:\n\tcase HFA384x_PDR_MKK_MEASUREMENTS:\n\tcase HFA384x_PDR_NIC_RAMSIZE:\n\tcase HFA384x_PDR_MFISUPRANGE:\n\tcase HFA384x_PDR_CFISUPRANGE:\n\tcase HFA384x_PDR_NICID:\n\tcase HFA384x_PDR_MAC_ADDRESS:\n\tcase HFA384x_PDR_REGDOMAIN:\n\tcase HFA384x_PDR_ALLOWED_CHANNEL:\n\tcase HFA384x_PDR_DEFAULT_CHANNEL:\n\tcase HFA384x_PDR_TEMPTYPE:\n\tcase HFA384x_PDR_IFR_SETTING:\n\tcase HFA384x_PDR_RFR_SETTING:\n\tcase HFA384x_PDR_HFA3861_BASELINE:\n\tcase HFA384x_PDR_HFA3861_SHADOW:\n\tcase HFA384x_PDR_HFA3861_IFRF:\n\tcase HFA384x_PDR_HFA3861_CHCALSP:\n\tcase HFA384x_PDR_HFA3861_CHCALI:\n\tcase HFA384x_PDR_3842_NIC_CONFIG:\n\tcase HFA384x_PDR_USB_ID:\n\tcase HFA384x_PDR_PCI_ID:\n\tcase HFA384x_PDR_PCI_IFCONF:\n\tcase HFA384x_PDR_PCI_PMCONF:\n\tcase HFA384x_PDR_RFENRGY:\n\tcase HFA384x_PDR_HFA3861_MANF_TESTSP:\n\tcase HFA384x_PDR_HFA3861_MANF_TESTI:\n\t\t \n\t\treturn 1;\n\tdefault:\n\t\tif (pdrcode < 0x1000) {\n\t\t\t \n\t\t\tpr_debug(\"Encountered unknown PDR#=0x%04x, assuming it's ok.\\n\",\n\t\t\t\t pdrcode);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\t}\n\t \n\tpr_debug(\"Encountered unknown PDR#=0x%04x, (>=0x1000), assuming it's bad.\\n\",\n\t\t pdrcode);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}