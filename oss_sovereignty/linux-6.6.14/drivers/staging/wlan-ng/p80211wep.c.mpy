{
  "module_name": "p80211wep.c",
  "hash_id": "80c36c80afc983a0899d59da97c1bf7372bfc2d07d49839b1b4e061e1b48f5ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/wlan-ng/p80211wep.c",
  "human_readable_source": "\n \n\n \n \n\n#include <linux/crc32.h>\n#include <linux/netdevice.h>\n#include <linux/wireless.h>\n#include <linux/random.h>\n#include <linux/kernel.h>\n#include \"p80211hdr.h\"\n#include \"p80211types.h\"\n#include \"p80211msg.h\"\n#include \"p80211conv.h\"\n#include \"p80211netdev.h\"\n\n#define WEP_KEY(x)       (((x) & 0xC0) >> 6)\n\n \n\nint wep_change_key(struct wlandevice *wlandev, int keynum, u8 *key, int keylen)\n{\n\tif (keylen < 0)\n\t\treturn -1;\n\tif (keylen >= MAX_KEYLEN)\n\t\treturn -1;\n\tif (!key)\n\t\treturn -1;\n\tif (keynum < 0)\n\t\treturn -1;\n\tif (keynum >= NUM_WEPKEYS)\n\t\treturn -1;\n\n\twlandev->wep_keylens[keynum] = keylen;\n\tmemcpy(wlandev->wep_keys[keynum], key, keylen);\n\n\treturn 0;\n}\n\n \nint wep_decrypt(struct wlandevice *wlandev, u8 *buf, u32 len, int key_override,\n\t\tu8 *iv, u8 *icv)\n{\n\tu32 i, j, k, crc, keylen;\n\tu8 s[256], key[64], c_crc[4];\n\tu8 keyidx;\n\n\t \n\tif (len <= 0)\n\t\treturn -1;\n\n\t \n\tkey[0] = iv[0];\n\tkey[1] = iv[1];\n\tkey[2] = iv[2];\n\tkeyidx = WEP_KEY(iv[3]);\n\n\tif (key_override >= 0)\n\t\tkeyidx = key_override;\n\n\tif (keyidx >= NUM_WEPKEYS)\n\t\treturn -2;\n\n\tkeylen = wlandev->wep_keylens[keyidx];\n\n\tif (keylen == 0)\n\t\treturn -3;\n\n\t \n\tmemcpy(key + 3, wlandev->wep_keys[keyidx], keylen);\n\n\tkeylen += 3;\t\t \n\n\t \n\tfor (i = 0; i < 256; i++)\n\t\ts[i] = i;\n\tj = 0;\n\tfor (i = 0; i < 256; i++) {\n\t\tj = (j + s[i] + key[i % keylen]) & 0xff;\n\t\tswap(i, j);\n\t}\n\n\t \n\ti = 0;\n\tj = 0;\n\tfor (k = 0; k < len; k++) {\n\t\ti = (i + 1) & 0xff;\n\t\tj = (j + s[i]) & 0xff;\n\t\tswap(i, j);\n\t\tbuf[k] ^= s[(s[i] + s[j]) & 0xff];\n\t}\n\tcrc = ~crc32_le(~0, buf, len);\n\n\t \n\tc_crc[0] = crc;\n\tc_crc[1] = crc >> 8;\n\tc_crc[2] = crc >> 16;\n\tc_crc[3] = crc >> 24;\n\n\tfor (k = 0; k < 4; k++) {\n\t\ti = (i + 1) & 0xff;\n\t\tj = (j + s[i]) & 0xff;\n\t\tswap(i, j);\n\t\tif ((c_crc[k] ^ s[(s[i] + s[j]) & 0xff]) != icv[k])\n\t\t\treturn -(4 | (k << 4));\t \n\t}\n\n\treturn 0;\n}\n\n \nint wep_encrypt(struct wlandevice *wlandev, u8 *buf,\n\t\tu8 *dst, u32 len, int keynum, u8 *iv, u8 *icv)\n{\n\tu32 i, j, k, crc, keylen;\n\tu8 s[256], key[64];\n\n\t \n\tif (len <= 0)\n\t\treturn -1;\n\n\t \n\tif (keynum >= NUM_WEPKEYS)\n\t\treturn -2;\n\tkeylen = wlandev->wep_keylens[keynum];\n\tif (keylen <= 0)\n\t\treturn -3;\n\n\t \n\tget_random_bytes(iv, 3);\n\twhile ((iv[1] == 0xff) && (iv[0] >= 3) && (iv[0] < keylen))\n\t\tget_random_bytes(iv, 3);\n\n\tiv[3] = (keynum & 0x03) << 6;\n\n\tkey[0] = iv[0];\n\tkey[1] = iv[1];\n\tkey[2] = iv[2];\n\n\t \n\tmemcpy(key + 3, wlandev->wep_keys[keynum], keylen);\n\n\tkeylen += 3;\t\t \n\n\t \n\tfor (i = 0; i < 256; i++)\n\t\ts[i] = i;\n\tj = 0;\n\tfor (i = 0; i < 256; i++) {\n\t\tj = (j + s[i] + key[i % keylen]) & 0xff;\n\t\tswap(i, j);\n\t}\n\n\t \n\ti = 0;\n\tj = 0;\n\tfor (k = 0; k < len; k++) {\n\t\ti = (i + 1) & 0xff;\n\t\tj = (j + s[i]) & 0xff;\n\t\tswap(i, j);\n\t\tdst[k] = buf[k] ^ s[(s[i] + s[j]) & 0xff];\n\t}\n\tcrc = ~crc32_le(~0, buf, len);\n\n\t \n\ticv[0] = crc;\n\ticv[1] = crc >> 8;\n\ticv[2] = crc >> 16;\n\ticv[3] = crc >> 24;\n\n\tfor (k = 0; k < 4; k++) {\n\t\ti = (i + 1) & 0xff;\n\t\tj = (j + s[i]) & 0xff;\n\t\tswap(i, j);\n\t\ticv[k] ^= s[(s[i] + s[j]) & 0xff];\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}