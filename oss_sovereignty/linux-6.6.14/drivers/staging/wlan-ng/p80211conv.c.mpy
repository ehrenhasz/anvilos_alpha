{
  "module_name": "p80211conv.c",
  "hash_id": "4ba4623c9f4400e8825e49b3d52ae0368aed6240ffedf164b508a1603d570de5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/wlan-ng/p80211conv.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/wireless.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/byteorder/generic.h>\n\n#include <asm/byteorder.h>\n\n#include \"p80211types.h\"\n#include \"p80211hdr.h\"\n#include \"p80211conv.h\"\n#include \"p80211mgmt.h\"\n#include \"p80211msg.h\"\n#include \"p80211netdev.h\"\n#include \"p80211ioctl.h\"\n#include \"p80211req.h\"\n\nstatic const u8 oui_rfc1042[] = { 0x00, 0x00, 0x00 };\nstatic const u8 oui_8021h[] = { 0x00, 0x00, 0xf8 };\n\n \nint skb_ether_to_p80211(struct wlandevice *wlandev, u32 ethconv,\n\t\t\tstruct sk_buff *skb, struct p80211_hdr *p80211_hdr,\n\t\t\tstruct p80211_metawep *p80211_wep)\n{\n\t__le16 fc;\n\tu16 proto;\n\tstruct wlan_ethhdr e_hdr;\n\tstruct wlan_llc *e_llc;\n\tstruct wlan_snap *e_snap;\n\tint foo;\n\n\tmemcpy(&e_hdr, skb->data, sizeof(e_hdr));\n\n\tif (skb->len <= 0) {\n\t\tpr_debug(\"zero-length skb!\\n\");\n\t\treturn 1;\n\t}\n\n\tif (ethconv == WLAN_ETHCONV_ENCAP) {\t \n\t\tpr_debug(\"ENCAP len: %d\\n\", skb->len);\n\t\t \n\t\t \n\t\t \n\t} else {\n\t\t \n\t\tproto = ntohs(e_hdr.type);\n\t\tif (proto <= ETH_DATA_LEN) {\n\t\t\tpr_debug(\"802.3 len: %d\\n\", skb->len);\n\t\t\t \n\t\t\t \n\n\t\t\t \n\t\t\tskb_pull(skb, ETH_HLEN);\n\n\t\t\t \n\t\t\tskb_trim(skb, proto);\n\t\t} else {\n\t\t\tpr_debug(\"DIXII len: %d\\n\", skb->len);\n\t\t\t \n\n\t\t\t \n\t\t\tskb_pull(skb, ETH_HLEN);\n\n\t\t\t \n\t\t\te_snap = skb_push(skb, sizeof(struct wlan_snap));\n\t\t\te_snap->type = htons(proto);\n\t\t\tif (ethconv == WLAN_ETHCONV_8021h &&\n\t\t\t    p80211_stt_findproto(proto)) {\n\t\t\t\tmemcpy(e_snap->oui, oui_8021h,\n\t\t\t\t       WLAN_IEEE_OUI_LEN);\n\t\t\t} else {\n\t\t\t\tmemcpy(e_snap->oui, oui_rfc1042,\n\t\t\t\t       WLAN_IEEE_OUI_LEN);\n\t\t\t}\n\n\t\t\t \n\t\t\te_llc = skb_push(skb, sizeof(struct wlan_llc));\n\t\t\te_llc->dsap = 0xAA;\t \n\t\t\te_llc->ssap = 0xAA;\n\t\t\te_llc->ctl = 0x03;\n\t\t}\n\t}\n\n\t \n\t \n\tfc = cpu_to_le16(WLAN_SET_FC_FTYPE(WLAN_FTYPE_DATA) |\n\t\t\t WLAN_SET_FC_FSTYPE(WLAN_FSTYPE_DATAONLY));\n\n\tswitch (wlandev->macmode) {\n\tcase WLAN_MACMODE_IBSS_STA:\n\t\tmemcpy(p80211_hdr->address1, &e_hdr.daddr, ETH_ALEN);\n\t\tmemcpy(p80211_hdr->address2, wlandev->netdev->dev_addr, ETH_ALEN);\n\t\tmemcpy(p80211_hdr->address3, wlandev->bssid, ETH_ALEN);\n\t\tbreak;\n\tcase WLAN_MACMODE_ESS_STA:\n\t\tfc |= cpu_to_le16(WLAN_SET_FC_TODS(1));\n\t\tmemcpy(p80211_hdr->address1, wlandev->bssid, ETH_ALEN);\n\t\tmemcpy(p80211_hdr->address2, wlandev->netdev->dev_addr, ETH_ALEN);\n\t\tmemcpy(p80211_hdr->address3, &e_hdr.daddr, ETH_ALEN);\n\t\tbreak;\n\tcase WLAN_MACMODE_ESS_AP:\n\t\tfc |= cpu_to_le16(WLAN_SET_FC_FROMDS(1));\n\t\tmemcpy(p80211_hdr->address1, &e_hdr.daddr, ETH_ALEN);\n\t\tmemcpy(p80211_hdr->address2, wlandev->bssid, ETH_ALEN);\n\t\tmemcpy(p80211_hdr->address3, &e_hdr.saddr, ETH_ALEN);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(wlandev->netdev,\n\t\t\t   \"Error: Converting eth to wlan in unknown mode.\\n\");\n\t\treturn 1;\n\t}\n\n\tp80211_wep->data = NULL;\n\n\tif ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) &&\n\t    (wlandev->hostwep & HOSTWEP_ENCRYPT)) {\n\t\t \n\n\t\tp80211_wep->data = kmalloc(skb->len, GFP_ATOMIC);\n\t\tif (!p80211_wep->data)\n\t\t\treturn -ENOMEM;\n\t\tfoo = wep_encrypt(wlandev, skb->data, p80211_wep->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK,\n\t\t\t\t  p80211_wep->iv, p80211_wep->icv);\n\t\tif (foo) {\n\t\t\tnetdev_warn(wlandev->netdev,\n\t\t\t\t    \"Host en-WEP failed, dropping frame (%d).\\n\",\n\t\t\t\t    foo);\n\t\t\tkfree(p80211_wep->data);\n\t\t\treturn 2;\n\t\t}\n\t\tfc |= cpu_to_le16(WLAN_SET_FC_ISWEP(1));\n\t}\n\n\t \n\n\tp80211_hdr->frame_control = fc;\n\tp80211_hdr->duration_id = 0;\n\tp80211_hdr->sequence_control = 0;\n\n\treturn 0;\n}\n\n \nstatic void orinoco_spy_gather(struct wlandevice *wlandev, char *mac,\n\t\t\t       struct p80211_rxmeta *rxmeta)\n{\n\tint i;\n\n\t \n\n\tfor (i = 0; i < wlandev->spy_number; i++) {\n\t\tif (!memcmp(wlandev->spy_address[i], mac, ETH_ALEN)) {\n\t\t\twlandev->spy_stat[i].level = rxmeta->signal;\n\t\t\twlandev->spy_stat[i].noise = rxmeta->noise;\n\t\t\twlandev->spy_stat[i].qual =\n\t\t\t    (rxmeta->signal >\n\t\t\t     rxmeta->noise) ? (rxmeta->signal -\n\t\t\t\t\t       rxmeta->noise) : 0;\n\t\t\twlandev->spy_stat[i].updated = 0x7;\n\t\t}\n\t}\n}\n\n \nint skb_p80211_to_ether(struct wlandevice *wlandev, u32 ethconv,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct net_device *netdev = wlandev->netdev;\n\tu16 fc;\n\tunsigned int payload_length;\n\tunsigned int payload_offset;\n\tu8 daddr[ETH_ALEN];\n\tu8 saddr[ETH_ALEN];\n\tstruct p80211_hdr *w_hdr;\n\tstruct wlan_ethhdr *e_hdr;\n\tstruct wlan_llc *e_llc;\n\tstruct wlan_snap *e_snap;\n\n\tint foo;\n\n\tpayload_length = skb->len - WLAN_HDR_A3_LEN - WLAN_CRC_LEN;\n\tpayload_offset = WLAN_HDR_A3_LEN;\n\n\tw_hdr = (struct p80211_hdr *)skb->data;\n\n\t \n\tfc = le16_to_cpu(w_hdr->frame_control);\n\tif ((WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 0)) {\n\t\tether_addr_copy(daddr, w_hdr->address1);\n\t\tether_addr_copy(saddr, w_hdr->address2);\n\t} else if ((WLAN_GET_FC_TODS(fc) == 0) &&\n\t\t   (WLAN_GET_FC_FROMDS(fc) == 1)) {\n\t\tether_addr_copy(daddr, w_hdr->address1);\n\t\tether_addr_copy(saddr, w_hdr->address3);\n\t} else if ((WLAN_GET_FC_TODS(fc) == 1) &&\n\t\t   (WLAN_GET_FC_FROMDS(fc) == 0)) {\n\t\tether_addr_copy(daddr, w_hdr->address3);\n\t\tether_addr_copy(saddr, w_hdr->address2);\n\t} else {\n\t\tpayload_offset = WLAN_HDR_A4_LEN;\n\t\tif (payload_length < WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN) {\n\t\t\tnetdev_err(netdev, \"A4 frame too short!\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tpayload_length -= (WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN);\n\t\tether_addr_copy(daddr, w_hdr->address3);\n\t\tether_addr_copy(saddr, w_hdr->address4);\n\t}\n\n\t \n\tif ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) &&\n\t    WLAN_GET_FC_ISWEP(fc) &&\n\t    (wlandev->hostwep & HOSTWEP_DECRYPT)) {\n\t\tif (payload_length <= 8) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"WEP frame too short (%u).\\n\", skb->len);\n\t\t\treturn 1;\n\t\t}\n\t\tfoo = wep_decrypt(wlandev, skb->data + payload_offset + 4,\n\t\t\t\t  payload_length - 8, -1,\n\t\t\t\t  skb->data + payload_offset,\n\t\t\t\t  skb->data + payload_offset +\n\t\t\t\t  payload_length - 4);\n\t\tif (foo) {\n\t\t\t \n\t\t\tpr_debug(\"Host de-WEP failed, dropping frame (%d).\\n\",\n\t\t\t\t foo);\n\t\t\twlandev->rx.decrypt_err++;\n\t\t\treturn 2;\n\t\t}\n\n\t\t \n\t\tpayload_length -= 8;\n\t\t \n\t\tskb_pull(skb, 4);\n\t\t \n\t\tskb_trim(skb, skb->len - 4);\n\n\t\twlandev->rx.decrypt++;\n\t}\n\n\te_hdr = (struct wlan_ethhdr *)(skb->data + payload_offset);\n\n\te_llc = (struct wlan_llc *)(skb->data + payload_offset);\n\te_snap =\n\t    (struct wlan_snap *)(skb->data + payload_offset +\n\t\tsizeof(struct wlan_llc));\n\n\t \n\tif ((payload_length >= sizeof(struct wlan_ethhdr)) &&\n\t    (e_llc->dsap != 0xaa || e_llc->ssap != 0xaa) &&\n\t    ((!ether_addr_equal_unaligned(daddr, e_hdr->daddr)) ||\n\t     (!ether_addr_equal_unaligned(saddr, e_hdr->saddr)))) {\n\t\tpr_debug(\"802.3 ENCAP len: %d\\n\", payload_length);\n\t\t \n\t\t \n\t\tif (payload_length > (netdev->mtu + ETH_HLEN)) {\n\t\t\t \n\t\t\t \n\t\t\tnetdev_err(netdev, \"ENCAP frame too large (%d > %d)\\n\",\n\t\t\t\t   payload_length, netdev->mtu + ETH_HLEN);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tskb_pull(skb, payload_offset);\n\t\t \n\t\tskb_trim(skb, skb->len - WLAN_CRC_LEN);\n\n\t} else if ((payload_length >= sizeof(struct wlan_llc) +\n\t\tsizeof(struct wlan_snap)) &&\n\t\t(e_llc->dsap == 0xaa) &&\n\t\t(e_llc->ssap == 0xaa) &&\n\t\t(e_llc->ctl == 0x03) &&\n\t\t   (((memcmp(e_snap->oui, oui_rfc1042,\n\t\t   WLAN_IEEE_OUI_LEN) == 0) &&\n\t\t   (ethconv == WLAN_ETHCONV_8021h) &&\n\t\t   (p80211_stt_findproto(be16_to_cpu(e_snap->type)))) ||\n\t\t   (memcmp(e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN) !=\n\t\t\t0))) {\n\t\tpr_debug(\"SNAP+RFC1042 len: %d\\n\", payload_length);\n\t\t \n\t\t \n\n\t\t \n\t\tif (payload_length > netdev->mtu) {\n\t\t\t \n\t\t\t \n\t\t\tnetdev_err(netdev, \"SNAP frame too large (%d > %d)\\n\",\n\t\t\t\t   payload_length, netdev->mtu);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tskb_pull(skb, payload_offset);\n\n\t\t \n\t\te_hdr = skb_push(skb, ETH_HLEN);\n\t\tether_addr_copy(e_hdr->daddr, daddr);\n\t\tether_addr_copy(e_hdr->saddr, saddr);\n\t\te_hdr->type = htons(payload_length);\n\n\t\t \n\t\tskb_trim(skb, skb->len - WLAN_CRC_LEN);\n\n\t} else if ((payload_length >= sizeof(struct wlan_llc) +\n\t\tsizeof(struct wlan_snap)) &&\n\t\t(e_llc->dsap == 0xaa) &&\n\t\t(e_llc->ssap == 0xaa) &&\n\t\t(e_llc->ctl == 0x03)) {\n\t\tpr_debug(\"802.1h/RFC1042 len: %d\\n\", payload_length);\n\t\t \n\n\t\t \n\t\tif ((payload_length - sizeof(struct wlan_llc) -\n\t\t\tsizeof(struct wlan_snap))\n\t\t\t> netdev->mtu) {\n\t\t\t \n\t\t\t \n\t\t\tnetdev_err(netdev, \"DIXII frame too large (%ld > %d)\\n\",\n\t\t\t\t   (long)(payload_length -\n\t\t\t\t   sizeof(struct wlan_llc) -\n\t\t\t\t   sizeof(struct wlan_snap)), netdev->mtu);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tskb_pull(skb, payload_offset);\n\n\t\t \n\t\tskb_pull(skb, sizeof(struct wlan_llc));\n\n\t\t \n\t\tskb_pull(skb, sizeof(struct wlan_snap));\n\n\t\t \n\t\te_hdr = skb_push(skb, ETH_HLEN);\n\t\te_hdr->type = e_snap->type;\n\t\tether_addr_copy(e_hdr->daddr, daddr);\n\t\tether_addr_copy(e_hdr->saddr, saddr);\n\n\t\t \n\t\tskb_trim(skb, skb->len - WLAN_CRC_LEN);\n\t} else {\n\t\tpr_debug(\"NON-ENCAP len: %d\\n\", payload_length);\n\t\t \n\t\t \n\t\t \n\t\t \n\n\t\t \n\t\tif (payload_length > netdev->mtu) {\n\t\t\t \n\t\t\t \n\t\t\tnetdev_err(netdev, \"OTHER frame too large (%d > %d)\\n\",\n\t\t\t\t   payload_length, netdev->mtu);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tskb_pull(skb, payload_offset);\n\n\t\t \n\t\te_hdr = skb_push(skb, ETH_HLEN);\n\t\tether_addr_copy(e_hdr->daddr, daddr);\n\t\tether_addr_copy(e_hdr->saddr, saddr);\n\t\te_hdr->type = htons(payload_length);\n\n\t\t \n\t\tskb_trim(skb, skb->len - WLAN_CRC_LEN);\n\t}\n\n\t \n\tskb->protocol = eth_type_trans(skb, netdev);\n\n\t \n\t \n\tif (wlandev->spy_number)\n\t\torinoco_spy_gather(wlandev, eth_hdr(skb)->h_source,\n\t\t\t\t   p80211skb_rxmeta(skb));\n\n\t \n\tp80211skb_rxmeta_detach(skb);\n\n\treturn 0;\n}\n\n \nint p80211_stt_findproto(u16 proto)\n{\n\t \n\t \n\t \n\n\tif (proto == ETH_P_AARP)\t \n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nvoid p80211skb_rxmeta_detach(struct sk_buff *skb)\n{\n\tstruct p80211_rxmeta *rxmeta;\n\tstruct p80211_frmmeta *frmmeta;\n\n\t \n\tif (!skb) {\t \n\t\tpr_debug(\"Called w/ null skb.\\n\");\n\t\treturn;\n\t}\n\tfrmmeta = p80211skb_frmmeta(skb);\n\tif (!frmmeta) {\t \n\t\tpr_debug(\"Called w/ bad frmmeta magic.\\n\");\n\t\treturn;\n\t}\n\trxmeta = frmmeta->rx;\n\tif (!rxmeta) {\t \n\t\tpr_debug(\"Called w/ bad rxmeta ptr.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tkfree(rxmeta);\n\n\t \n\tmemset(skb->cb, 0, sizeof(skb->cb));\n}\n\n \nint p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)\n{\n\tint result = 0;\n\tstruct p80211_rxmeta *rxmeta;\n\tstruct p80211_frmmeta *frmmeta;\n\n\t \n\tif (p80211skb_rxmeta(skb)) {\n\t\tnetdev_err(wlandev->netdev,\n\t\t\t   \"%s: RXmeta already attached!\\n\", wlandev->name);\n\t\tresult = 0;\n\t\tgoto exit;\n\t}\n\n\t \n\trxmeta = kzalloc(sizeof(*rxmeta), GFP_ATOMIC);\n\n\tif (!rxmeta) {\n\t\tresult = 1;\n\t\tgoto exit;\n\t}\n\n\t \n\trxmeta->wlandev = wlandev;\n\trxmeta->hosttime = jiffies;\n\n\t \n\tmemset(skb->cb, 0, sizeof(struct p80211_frmmeta));\n\tfrmmeta = (struct p80211_frmmeta *)(skb->cb);\n\tfrmmeta->magic = P80211_FRMMETA_MAGIC;\n\tfrmmeta->rx = rxmeta;\nexit:\n\treturn result;\n}\n\n \nvoid p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)\n{\n\tstruct p80211_frmmeta *meta;\n\n\tmeta = p80211skb_frmmeta(skb);\n\tif (meta && meta->rx)\n\t\tp80211skb_rxmeta_detach(skb);\n\telse\n\t\tnetdev_err(wlandev->netdev,\n\t\t\t   \"Freeing an skb (%p) w/ no frmmeta.\\n\", skb);\n\tdev_kfree_skb(skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}