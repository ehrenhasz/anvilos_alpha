{
  "module_name": "cfg80211.c",
  "hash_id": "03a8af69637a535c43c0d630251f1f0a570374646a3b53990fee36b6d029c68a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/wlan-ng/cfg80211.c",
  "human_readable_source": "\n \n#include \"hfa384x.h\"\n#include \"prism2mgmt.h\"\n\n \nstatic const struct ieee80211_channel prism2_channels[] = {\n\t{ .center_freq = 2412 },\n\t{ .center_freq = 2417 },\n\t{ .center_freq = 2422 },\n\t{ .center_freq = 2427 },\n\t{ .center_freq = 2432 },\n\t{ .center_freq = 2437 },\n\t{ .center_freq = 2442 },\n\t{ .center_freq = 2447 },\n\t{ .center_freq = 2452 },\n\t{ .center_freq = 2457 },\n\t{ .center_freq = 2462 },\n\t{ .center_freq = 2467 },\n\t{ .center_freq = 2472 },\n\t{ .center_freq = 2484 },\n};\n\nstatic const struct ieee80211_rate prism2_rates[] = {\n\t{ .bitrate = 10 },\n\t{ .bitrate = 20 },\n\t{ .bitrate = 55 },\n\t{ .bitrate = 110 }\n};\n\n#define PRISM2_NUM_CIPHER_SUITES 2\nstatic const u32 prism2_cipher_suites[PRISM2_NUM_CIPHER_SUITES] = {\n\tWLAN_CIPHER_SUITE_WEP40,\n\tWLAN_CIPHER_SUITE_WEP104\n};\n\n \nstruct prism2_wiphy_private {\n\tstruct wlandevice *wlandev;\n\n\tstruct ieee80211_supported_band band;\n\tstruct ieee80211_channel channels[ARRAY_SIZE(prism2_channels)];\n\tstruct ieee80211_rate rates[ARRAY_SIZE(prism2_rates)];\n\n\tstruct cfg80211_scan_request *scan_request;\n};\n\nstatic const void * const prism2_wiphy_privid = &prism2_wiphy_privid;\n\n \nstatic int prism2_result2err(int prism2_result)\n{\n\tint err = 0;\n\n\tswitch (prism2_result) {\n\tcase P80211ENUM_resultcode_invalid_parameters:\n\t\terr = -EINVAL;\n\t\tbreak;\n\tcase P80211ENUM_resultcode_implementation_failure:\n\t\terr = -EIO;\n\t\tbreak;\n\tcase P80211ENUM_resultcode_not_supported:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int prism2_domibset_uint32(struct wlandevice *wlandev,\n\t\t\t\t  u32 did, u32 data)\n{\n\tstruct p80211msg_dot11req_mibset msg;\n\tstruct p80211item_uint32 *mibitem =\n\t\t\t(struct p80211item_uint32 *)&msg.mibattribute.data;\n\n\tmsg.msgcode = DIDMSG_DOT11REQ_MIBSET;\n\tmibitem->did = did;\n\tmibitem->data = data;\n\n\treturn p80211req_dorequest(wlandev, (u8 *)&msg);\n}\n\nstatic int prism2_domibset_pstr32(struct wlandevice *wlandev,\n\t\t\t\t  u32 did, u8 len, const u8 *data)\n{\n\tstruct p80211msg_dot11req_mibset msg;\n\tstruct p80211item_pstr32 *mibitem =\n\t\t\t(struct p80211item_pstr32 *)&msg.mibattribute.data;\n\n\tmsg.msgcode = DIDMSG_DOT11REQ_MIBSET;\n\tmibitem->did = did;\n\tmibitem->data.len = len;\n\tmemcpy(mibitem->data.data, data, len);\n\n\treturn p80211req_dorequest(wlandev, (u8 *)&msg);\n}\n\n \nstatic int prism2_change_virtual_intf(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      enum nl80211_iftype type,\n\t\t\t\t      struct vif_params *params)\n{\n\tstruct wlandevice *wlandev = dev->ml_priv;\n\tu32 data;\n\tint result;\n\tint err = 0;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (wlandev->macmode == WLAN_MACMODE_IBSS_STA)\n\t\t\tgoto exit;\n\t\twlandev->macmode = WLAN_MACMODE_IBSS_STA;\n\t\tdata = 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (wlandev->macmode == WLAN_MACMODE_ESS_STA)\n\t\t\tgoto exit;\n\t\twlandev->macmode = WLAN_MACMODE_ESS_STA;\n\t\tdata = 1;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(dev, \"Operation mode: %d not support\\n\", type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tresult = prism2_domibset_uint32(wlandev,\n\t\t\t\t\tDIDMIB_P2_STATIC_CNFPORTTYPE,\n\t\t\t\t\tdata);\n\n\tif (result)\n\t\terr = -EFAULT;\n\n\tdev->ieee80211_ptr->iftype = type;\n\nexit:\n\treturn err;\n}\n\nstatic int prism2_add_key(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  int link_id, u8 key_index, bool pairwise,\n\t\t\t  const u8 *mac_addr, struct key_params *params)\n{\n\tstruct wlandevice *wlandev = dev->ml_priv;\n\tu32 did;\n\n\tif (key_index >= NUM_WEPKEYS)\n\t\treturn -EINVAL;\n\n\tif (params->cipher != WLAN_CIPHER_SUITE_WEP40 &&\n\t    params->cipher != WLAN_CIPHER_SUITE_WEP104) {\n\t\tpr_debug(\"Unsupported cipher suite\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (prism2_domibset_uint32(wlandev,\n\t\t\t\t   DIDMIB_DOT11SMT_PRIVACYTABLE_WEPDEFAULTKEYID,\n\t\t\t\t   key_index))\n\t\treturn -EFAULT;\n\n\t \n\tdid = didmib_dot11smt_wepdefaultkeystable_key(key_index + 1);\n\n\tif (prism2_domibset_pstr32(wlandev, did, params->key_len, params->key))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int prism2_get_key(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  int link_id, u8 key_index, bool pairwise,\n\t\t\t  const u8 *mac_addr, void *cookie,\n\t\t\t  void (*callback)(void *cookie, struct key_params*))\n{\n\tstruct wlandevice *wlandev = dev->ml_priv;\n\tstruct key_params params;\n\tint len;\n\n\tif (key_index >= NUM_WEPKEYS)\n\t\treturn -EINVAL;\n\n\tlen = wlandev->wep_keylens[key_index];\n\tmemset(&params, 0, sizeof(params));\n\n\tif (len == 13)\n\t\tparams.cipher = WLAN_CIPHER_SUITE_WEP104;\n\telse if (len == 5)\n\t\tparams.cipher = WLAN_CIPHER_SUITE_WEP104;\n\telse\n\t\treturn -ENOENT;\n\tparams.key_len = len;\n\tparams.key = wlandev->wep_keys[key_index];\n\tparams.seq_len = 0;\n\n\tcallback(cookie, &params);\n\n\treturn 0;\n}\n\nstatic int prism2_del_key(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  int link_id, u8 key_index, bool pairwise,\n\t\t\t  const u8 *mac_addr)\n{\n\tstruct wlandevice *wlandev = dev->ml_priv;\n\tu32 did;\n\tint err = 0;\n\tint result = 0;\n\n\t \n\n\tif (key_index >= NUM_WEPKEYS)\n\t\treturn -EINVAL;\n\n\t \n\tdid = didmib_dot11smt_wepdefaultkeystable_key(key_index + 1);\n\tresult = prism2_domibset_pstr32(wlandev, did, 13, \"0000000000000\");\n\n\tif (result)\n\t\terr = -EFAULT;\n\n\treturn err;\n}\n\nstatic int prism2_set_default_key(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  int link_id, u8 key_index, bool unicast,\n\t\t\t\t  bool multicast)\n{\n\tstruct wlandevice *wlandev = dev->ml_priv;\n\n\treturn  prism2_domibset_uint32(wlandev,\n\t\t\t\t       DIDMIB_DOT11SMT_PRIVACYTABLE_WEPDEFAULTKEYID,\n\t\t\t\t       key_index);\n}\n\nstatic int prism2_get_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *mac, struct station_info *sinfo)\n{\n\tstruct wlandevice *wlandev = dev->ml_priv;\n\tstruct p80211msg_lnxreq_commsquality quality;\n\tint result;\n\n\tmemset(sinfo, 0, sizeof(*sinfo));\n\n\tif (!wlandev || (wlandev->msdstate != WLAN_MSD_RUNNING))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tquality.msgcode = DIDMSG_LNXREQ_COMMSQUALITY;\n\tquality.dbm.data = P80211ENUM_truth_true;\n\tquality.dbm.status = P80211ENUM_msgitem_status_data_ok;\n\n\t \n\tif (!wlandev->mlmerequest)\n\t\treturn -EOPNOTSUPP;\n\n\tresult = wlandev->mlmerequest(wlandev, (struct p80211msg *)&quality);\n\n\tif (result == 0) {\n\t\tsinfo->txrate.legacy = quality.txrate.data;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t\tsinfo->signal = quality.level.data;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\t}\n\n\treturn result;\n}\n\nstatic int prism2_scan(struct wiphy *wiphy,\n\t\t       struct cfg80211_scan_request *request)\n{\n\tstruct net_device *dev;\n\tstruct prism2_wiphy_private *priv = wiphy_priv(wiphy);\n\tstruct wlandevice *wlandev;\n\tstruct p80211msg_dot11req_scan msg1;\n\tstruct p80211msg_dot11req_scan_results *msg2;\n\tstruct cfg80211_bss *bss;\n\tstruct cfg80211_scan_info info = {};\n\n\tint result;\n\tint err = 0;\n\tint numbss = 0;\n\tint i = 0;\n\tu8 ie_buf[46];\n\tint ie_len;\n\n\tif (!request)\n\t\treturn -EINVAL;\n\n\tdev = request->wdev->netdev;\n\twlandev = dev->ml_priv;\n\n\tif (priv->scan_request && priv->scan_request != request)\n\t\treturn -EBUSY;\n\n\tif (wlandev->macmode == WLAN_MACMODE_ESS_AP) {\n\t\tnetdev_err(dev, \"Can't scan in AP mode\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmsg2 = kzalloc(sizeof(*msg2), GFP_KERNEL);\n\tif (!msg2)\n\t\treturn -ENOMEM;\n\n\tpriv->scan_request = request;\n\n\tmemset(&msg1, 0x00, sizeof(msg1));\n\tmsg1.msgcode = DIDMSG_DOT11REQ_SCAN;\n\tmsg1.bsstype.data = P80211ENUM_bsstype_any;\n\n\tmemset(&msg1.bssid.data.data, 0xFF, sizeof(msg1.bssid.data.data));\n\tmsg1.bssid.data.len = 6;\n\n\tif (request->n_ssids > 0) {\n\t\tmsg1.scantype.data = P80211ENUM_scantype_active;\n\t\tmsg1.ssid.data.len = request->ssids->ssid_len;\n\t\tmemcpy(msg1.ssid.data.data,\n\t\t       request->ssids->ssid, request->ssids->ssid_len);\n\t} else {\n\t\tmsg1.scantype.data = 0;\n\t}\n\tmsg1.probedelay.data = 0;\n\n\tfor (i = 0;\n\t\t(i < request->n_channels) && i < ARRAY_SIZE(prism2_channels);\n\t\ti++)\n\t\tmsg1.channellist.data.data[i] =\n\t\t\tieee80211_frequency_to_channel(request->channels[i]->center_freq);\n\tmsg1.channellist.data.len = request->n_channels;\n\n\tmsg1.maxchanneltime.data = 250;\n\tmsg1.minchanneltime.data = 200;\n\n\tresult = p80211req_dorequest(wlandev, (u8 *)&msg1);\n\tif (result) {\n\t\terr = prism2_result2err(msg1.resultcode.data);\n\t\tgoto exit;\n\t}\n\t \n\tnumbss = msg1.numbss.data;\n\n\tfor (i = 0; i < numbss; i++) {\n\t\tint freq;\n\n\t\tmsg2->msgcode = DIDMSG_DOT11REQ_SCAN_RESULTS;\n\t\tmsg2->bssindex.data = i;\n\n\t\tresult = p80211req_dorequest(wlandev, (u8 *)&msg2);\n\t\tif ((result != 0) ||\n\t\t    (msg2->resultcode.data != P80211ENUM_resultcode_success)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tie_buf[0] = WLAN_EID_SSID;\n\t\tie_buf[1] = msg2->ssid.data.len;\n\t\tie_len = ie_buf[1] + 2;\n\t\tmemcpy(&ie_buf[2], &msg2->ssid.data.data, msg2->ssid.data.len);\n\t\tfreq = ieee80211_channel_to_frequency(msg2->dschannel.data,\n\t\t\t\t\t\t      NL80211_BAND_2GHZ);\n\t\tbss = cfg80211_inform_bss(wiphy,\n\t\t\t\t\t  ieee80211_get_channel(wiphy, freq),\n\t\t\t\t\t  CFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t\t  (const u8 *)&msg2->bssid.data.data,\n\t\t\t\t\t  msg2->timestamp.data, msg2->capinfo.data,\n\t\t\t\t\t  msg2->beaconperiod.data,\n\t\t\t\t\t  ie_buf,\n\t\t\t\t\t  ie_len,\n\t\t\t\t\t  (msg2->signal.data - 65536) * 100,  \n\t\t\t\t\t  GFP_KERNEL);\n\n\t\tif (!bss) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tcfg80211_put_bss(wiphy, bss);\n\t}\n\n\tif (result)\n\t\terr = prism2_result2err(msg2->resultcode.data);\n\nexit:\n\tinfo.aborted = !!(err);\n\tcfg80211_scan_done(request, &info);\n\tpriv->scan_request = NULL;\n\tkfree(msg2);\n\treturn err;\n}\n\nstatic int prism2_set_wiphy_params(struct wiphy *wiphy, u32 changed)\n{\n\tstruct prism2_wiphy_private *priv = wiphy_priv(wiphy);\n\tstruct wlandevice *wlandev = priv->wlandev;\n\tu32 data;\n\tint result;\n\tint err = 0;\n\n\tif (changed & WIPHY_PARAM_RTS_THRESHOLD) {\n\t\tif (wiphy->rts_threshold == -1)\n\t\t\tdata = 2347;\n\t\telse\n\t\t\tdata = wiphy->rts_threshold;\n\n\t\tresult = prism2_domibset_uint32(wlandev,\n\t\t\t\t\t\tDIDMIB_DOT11MAC_OPERATIONTABLE_RTSTHRESHOLD,\n\t\t\t\t\t\tdata);\n\t\tif (result) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD) {\n\t\tif (wiphy->frag_threshold == -1)\n\t\t\tdata = 2346;\n\t\telse\n\t\t\tdata = wiphy->frag_threshold;\n\n\t\tresult = prism2_domibset_uint32(wlandev,\n\t\t\t\t\t\tDIDMIB_DOT11MAC_OPERATIONTABLE_FRAGMENTATIONTHRESHOLD,\n\t\t\t\t\t\tdata);\n\t\tif (result) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\treturn err;\n}\n\nstatic int prism2_connect(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  struct cfg80211_connect_params *sme)\n{\n\tstruct wlandevice *wlandev = dev->ml_priv;\n\tstruct ieee80211_channel *channel = sme->channel;\n\tstruct p80211msg_lnxreq_autojoin msg_join;\n\tu32 did;\n\tint length = sme->ssid_len;\n\tint chan = -1;\n\tint is_wep = (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40) ||\n\t    (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104);\n\tint result;\n\tint err = 0;\n\n\t \n\tif (channel) {\n\t\tchan = ieee80211_frequency_to_channel(channel->center_freq);\n\t\tresult = prism2_domibset_uint32(wlandev,\n\t\t\t\t\t\tDIDMIB_DOT11PHY_DSSSTABLE_CURRENTCHANNEL,\n\t\t\t\t\t\tchan);\n\t\tif (result)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tif ((sme->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM) ||\n\t    ((sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) && !is_wep))\n\t\tmsg_join.authtype.data = P80211ENUM_authalg_opensystem;\n\telse if ((sme->auth_type == NL80211_AUTHTYPE_SHARED_KEY) ||\n\t\t ((sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) && is_wep))\n\t\tmsg_join.authtype.data = P80211ENUM_authalg_sharedkey;\n\telse\n\t\tnetdev_warn(dev,\n\t\t\t    \"Unhandled authorisation type for connect (%d)\\n\",\n\t\t\t    sme->auth_type);\n\n\t \n\tif (is_wep) {\n\t\tif (sme->key) {\n\t\t\tif (sme->key_idx >= NUM_WEPKEYS)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tresult = prism2_domibset_uint32(wlandev,\n\t\t\t\t\t\t\tDIDMIB_DOT11SMT_PRIVACYTABLE_WEPDEFAULTKEYID,\n\t\t\t\tsme->key_idx);\n\t\t\tif (result)\n\t\t\t\tgoto exit;\n\n\t\t\t \n\t\t\tdid = didmib_dot11smt_wepdefaultkeystable_key(sme->key_idx + 1);\n\t\t\tresult = prism2_domibset_pstr32(wlandev,\n\t\t\t\t\t\t\tdid, sme->key_len,\n\t\t\t\t\t\t\t(u8 *)sme->key);\n\t\t\tif (result)\n\t\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tresult = prism2_domibset_uint32(wlandev,\n\t\t\t\t\t\tDIDMIB_DOT11SMT_PRIVACYTABLE_PRIVACYINVOKED,\n\t\t\t\t\t\tP80211ENUM_truth_true);\n\t\tif (result)\n\t\t\tgoto exit;\n\n\t\tresult = prism2_domibset_uint32(wlandev,\n\t\t\t\t\t\tDIDMIB_DOT11SMT_PRIVACYTABLE_EXCLUDEUNENCRYPTED,\n\t\t\t\t\t\tP80211ENUM_truth_true);\n\t\tif (result)\n\t\t\tgoto exit;\n\n\t} else {\n\t\t \n\t\tresult = prism2_domibset_uint32(wlandev,\n\t\t\t\t\t\tDIDMIB_DOT11SMT_PRIVACYTABLE_PRIVACYINVOKED,\n\t\t\t\t\t\tP80211ENUM_truth_false);\n\t\tif (result)\n\t\t\tgoto exit;\n\n\t\tresult = prism2_domibset_uint32(wlandev,\n\t\t\t\t\t\tDIDMIB_DOT11SMT_PRIVACYTABLE_EXCLUDEUNENCRYPTED,\n\t\t\t\t\t\tP80211ENUM_truth_false);\n\t\tif (result)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tmsg_join.msgcode = DIDMSG_LNXREQ_AUTOJOIN;\n\n\tmemcpy(msg_join.ssid.data.data, sme->ssid, length);\n\tmsg_join.ssid.data.len = length;\n\n\tresult = p80211req_dorequest(wlandev, (u8 *)&msg_join);\n\nexit:\n\tif (result)\n\t\terr = -EFAULT;\n\n\treturn err;\n}\n\nstatic int prism2_disconnect(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     u16 reason_code)\n{\n\tstruct wlandevice *wlandev = dev->ml_priv;\n\tstruct p80211msg_lnxreq_autojoin msg_join;\n\tint result;\n\tint err = 0;\n\n\t \n\tmsg_join.msgcode = DIDMSG_LNXREQ_AUTOJOIN;\n\n\tmemcpy(msg_join.ssid.data.data, \"---\", 3);\n\tmsg_join.ssid.data.len = 3;\n\n\tresult = p80211req_dorequest(wlandev, (u8 *)&msg_join);\n\n\tif (result)\n\t\terr = -EFAULT;\n\n\treturn err;\n}\n\nstatic int prism2_join_ibss(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t    struct cfg80211_ibss_params *params)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int prism2_leave_ibss(struct wiphy *wiphy, struct net_device *dev)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int prism2_set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t       enum nl80211_tx_power_setting type, int mbm)\n{\n\tstruct prism2_wiphy_private *priv = wiphy_priv(wiphy);\n\tstruct wlandevice *wlandev = priv->wlandev;\n\tu32 data;\n\tint result;\n\tint err = 0;\n\n\tif (type == NL80211_TX_POWER_AUTOMATIC)\n\t\tdata = 30;\n\telse\n\t\tdata = MBM_TO_DBM(mbm);\n\n\tresult = prism2_domibset_uint32(wlandev,\n\t\t\t\t\tDIDMIB_DOT11PHY_TXPOWERTABLE_CURRENTTXPOWERLEVEL,\n\t\tdata);\n\n\tif (result) {\n\t\terr = -EFAULT;\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn err;\n}\n\nstatic int prism2_get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t       int *dbm)\n{\n\tstruct prism2_wiphy_private *priv = wiphy_priv(wiphy);\n\tstruct wlandevice *wlandev = priv->wlandev;\n\tstruct p80211msg_dot11req_mibget msg;\n\tstruct p80211item_uint32 *mibitem;\n\tint result;\n\tint err = 0;\n\n\tmibitem = (struct p80211item_uint32 *)&msg.mibattribute.data;\n\tmsg.msgcode = DIDMSG_DOT11REQ_MIBGET;\n\tmibitem->did = DIDMIB_DOT11PHY_TXPOWERTABLE_CURRENTTXPOWERLEVEL;\n\n\tresult = p80211req_dorequest(wlandev, (u8 *)&msg);\n\n\tif (result) {\n\t\terr = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\t*dbm = mibitem->data;\n\nexit:\n\treturn err;\n}\n\n \nvoid prism2_connect_result(struct wlandevice *wlandev, u8 failed)\n{\n\tu16 status = failed ?\n\t\t     WLAN_STATUS_UNSPECIFIED_FAILURE : WLAN_STATUS_SUCCESS;\n\n\tcfg80211_connect_result(wlandev->netdev, wlandev->bssid,\n\t\t\t\tNULL, 0, NULL, 0, status, GFP_KERNEL);\n}\n\nvoid prism2_disconnected(struct wlandevice *wlandev)\n{\n\tcfg80211_disconnected(wlandev->netdev, 0, NULL,\n\t\t\t      0, false, GFP_KERNEL);\n}\n\nvoid prism2_roamed(struct wlandevice *wlandev)\n{\n\tstruct cfg80211_roam_info roam_info = {\n\t\t.links[0].bssid = wlandev->bssid,\n\t};\n\n\tcfg80211_roamed(wlandev->netdev, &roam_info, GFP_KERNEL);\n}\n\n \nstatic const struct cfg80211_ops prism2_usb_cfg_ops = {\n\t.change_virtual_intf = prism2_change_virtual_intf,\n\t.add_key = prism2_add_key,\n\t.get_key = prism2_get_key,\n\t.del_key = prism2_del_key,\n\t.set_default_key = prism2_set_default_key,\n\t.get_station = prism2_get_station,\n\t.scan = prism2_scan,\n\t.set_wiphy_params = prism2_set_wiphy_params,\n\t.connect = prism2_connect,\n\t.disconnect = prism2_disconnect,\n\t.join_ibss = prism2_join_ibss,\n\t.leave_ibss = prism2_leave_ibss,\n\t.set_tx_power = prism2_set_tx_power,\n\t.get_tx_power = prism2_get_tx_power,\n};\n\n \nstatic struct wiphy *wlan_create_wiphy(struct device *dev,\n\t\t\t\t       struct wlandevice *wlandev)\n{\n\tstruct wiphy *wiphy;\n\tstruct prism2_wiphy_private *priv;\n\n\twiphy = wiphy_new(&prism2_usb_cfg_ops, sizeof(*priv));\n\tif (!wiphy)\n\t\treturn NULL;\n\n\tpriv = wiphy_priv(wiphy);\n\tpriv->wlandev = wlandev;\n\tmemcpy(priv->channels, prism2_channels, sizeof(prism2_channels));\n\tmemcpy(priv->rates, prism2_rates, sizeof(prism2_rates));\n\tpriv->band.channels = priv->channels;\n\tpriv->band.n_channels = ARRAY_SIZE(prism2_channels);\n\tpriv->band.bitrates = priv->rates;\n\tpriv->band.n_bitrates = ARRAY_SIZE(prism2_rates);\n\tpriv->band.band = NL80211_BAND_2GHZ;\n\tpriv->band.ht_cap.ht_supported = false;\n\twiphy->bands[NL80211_BAND_2GHZ] = &priv->band;\n\n\tset_wiphy_dev(wiphy, dev);\n\twiphy->privid = prism2_wiphy_privid;\n\twiphy->max_scan_ssids = 1;\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION)\n\t\t\t\t | BIT(NL80211_IFTYPE_ADHOC);\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\twiphy->n_cipher_suites = PRISM2_NUM_CIPHER_SUITES;\n\twiphy->cipher_suites = prism2_cipher_suites;\n\n\tif (wiphy_register(wiphy) < 0) {\n\t\twiphy_free(wiphy);\n\t\treturn NULL;\n\t}\n\n\treturn wiphy;\n}\n\nstatic void wlan_free_wiphy(struct wiphy *wiphy)\n{\n\twiphy_unregister(wiphy);\n\twiphy_free(wiphy);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}