{
  "module_name": "rtl8723bs_recv.c",
  "hash_id": "e45cf868ab88c7f67e70755192268e5c88677554522042220b10027480060970",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/hal/rtl8723bs_recv.c",
  "human_readable_source": "\n \n\n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <rtl8723b_hal.h>\n\nstatic void initrecvbuf(struct recv_buf *precvbuf, struct adapter *padapter)\n{\n\tINIT_LIST_HEAD(&precvbuf->list);\n\tspin_lock_init(&precvbuf->recvbuf_lock);\n\n\tprecvbuf->adapter = padapter;\n}\n\nstatic void update_recvframe_attrib(struct adapter *padapter,\n\t\t\t\t    union recv_frame *precvframe,\n\t\t\t\t    struct recv_stat *prxstat)\n{\n\tstruct rx_pkt_attrib *pattrib;\n\tstruct recv_stat report;\n\tstruct rxreport_8723b *prxreport = (struct rxreport_8723b *)&report;\n\n\treport.rxdw0 = prxstat->rxdw0;\n\treport.rxdw1 = prxstat->rxdw1;\n\treport.rxdw2 = prxstat->rxdw2;\n\treport.rxdw3 = prxstat->rxdw3;\n\treport.rxdw4 = prxstat->rxdw4;\n\treport.rxdw5 = prxstat->rxdw5;\n\n\tpattrib = &precvframe->u.hdr.attrib;\n\tmemset(pattrib, 0, sizeof(struct rx_pkt_attrib));\n\n\t \n\tpattrib->pkt_rpt_type = prxreport->c2h_ind ? C2H_PACKET : NORMAL_RX;\n\n\tif (pattrib->pkt_rpt_type == NORMAL_RX) {\n\t\t \n\t\t \n\t\tpattrib->pkt_len = (u16)prxreport->pktlen;\n\t\tpattrib->drvinfo_sz = (u8)(prxreport->drvinfosize << 3);\n\t\tpattrib->physt = (u8)prxreport->physt;\n\n\t\tpattrib->crc_err = (u8)prxreport->crc32;\n\t\tpattrib->icv_err = (u8)prxreport->icverr;\n\n\t\tpattrib->bdecrypted = (u8)(prxreport->swdec ? 0 : 1);\n\t\tpattrib->encrypt = (u8)prxreport->security;\n\n\t\tpattrib->qos = (u8)prxreport->qos;\n\t\tpattrib->priority = (u8)prxreport->tid;\n\n\t\tpattrib->amsdu = (u8)prxreport->amsdu;\n\n\t\tpattrib->seq_num = (u16)prxreport->seq;\n\t\tpattrib->frag_num = (u8)prxreport->frag;\n\t\tpattrib->mfrag = (u8)prxreport->mf;\n\t\tpattrib->mdata = (u8)prxreport->md;\n\n\t\tpattrib->data_rate = (u8)prxreport->rx_rate;\n\t} else {\n\t\tpattrib->pkt_len = (u16)prxreport->pktlen;\n\t}\n}\n\n \nstatic void update_recvframe_phyinfo(union recv_frame *precvframe,\n\t\t\t\t     struct phy_stat *pphy_status)\n{\n\tstruct adapter *padapter = precvframe->u.hdr.adapter;\n\tstruct rx_pkt_attrib *pattrib = &precvframe->u.hdr.attrib;\n\tstruct hal_com_data *p_hal_data = GET_HAL_DATA(padapter);\n\tstruct odm_phy_info *p_phy_info =\n\t\t(struct odm_phy_info *)(&pattrib->phy_info);\n\n\tu8 *wlanhdr = precvframe->u.hdr.rx_data;\n\tu8 *my_bssid;\n\tu8 *rx_bssid;\n\tu8 *rx_ra;\n\tu8 *my_hwaddr;\n\tu8 *sa = NULL;\n\n\tstruct odm_packet_info pkt_info = {\n\t\t.data_rate   = 0x00,\n\t\t.station_id  = 0x00,\n\t\t.bssid_match = false,\n\t\t.to_self     = false,\n\t\t.is_beacon   = false,\n\t};\n\n\t \n\tstruct sta_priv *pstapriv;\n\tstruct sta_info *psta;\n\n\tmy_bssid = get_bssid(&padapter->mlmepriv);\n\trx_bssid = get_hdr_bssid(wlanhdr);\n\tpkt_info.bssid_match = ((!IsFrameTypeCtrl(wlanhdr)) &&\n\t\t\t\t!pattrib->icv_err && !pattrib->crc_err &&\n\t\t\t\tether_addr_equal(rx_bssid, my_bssid));\n\n\trx_ra = rtl8723bs_get_ra(wlanhdr);\n\tmy_hwaddr = myid(&padapter->eeprompriv);\n\tpkt_info.to_self = pkt_info.bssid_match &&\n\t\tether_addr_equal(rx_ra, my_hwaddr);\n\n\n\tpkt_info.is_beacon = pkt_info.bssid_match &&\n\t\t(GetFrameSubType(wlanhdr) == WIFI_BEACON);\n\n\tsa = get_ta(wlanhdr);\n\n\tpkt_info.station_id = 0xFF;\n\n\tpstapriv = &padapter->stapriv;\n\tpsta = rtw_get_stainfo(pstapriv, sa);\n\tif (psta)\n\t\tpkt_info.station_id = psta->mac_id;\n\n\tpkt_info.data_rate = pattrib->data_rate;\n\n\t \n\t \n\todm_phy_status_query(&p_hal_data->odmpriv, p_phy_info,\n\t\t\t   (u8 *)pphy_status, &(pkt_info));\n\tif (psta)\n\t\tpsta->rssi = pattrib->phy_info.RecvSignalPower;\n\t \n\tprecvframe->u.hdr.psta = NULL;\n\tif (\n\t\tpkt_info.bssid_match &&\n\t\t(check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == true)\n\t) {\n\t\tif (psta) {\n\t\t\tprecvframe->u.hdr.psta = psta;\n\t\t\trtl8723b_process_phy_info(padapter, precvframe);\n\t\t}\n\t} else if (pkt_info.to_self || pkt_info.is_beacon) {\n\t\tu32 adhoc_state = WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE;\n\t\tif (check_fwstate(&padapter->mlmepriv, adhoc_state))\n\t\t\tif (psta)\n\t\t\t\tprecvframe->u.hdr.psta = psta;\n\t\trtl8723b_process_phy_info(padapter, precvframe);\n\t}\n}\n\nstatic void rtl8723bs_c2h_packet_handler(struct adapter *padapter,\n\t\t\t\t\t u8 *pbuf, u16 length)\n{\n\tu8 *tmp = NULL;\n\tu8 res = false;\n\n\tif (length == 0)\n\t\treturn;\n\n\ttmp = rtw_zmalloc(length);\n\tif (!tmp)\n\t\treturn;\n\n\tmemcpy(tmp, pbuf, length);\n\n\tres = rtw_c2h_packet_wk_cmd(padapter, tmp, length);\n\n\tif (!res)\n\t\tkfree(tmp);\n}\n\nstatic inline union recv_frame *try_alloc_recvframe(struct recv_priv *precvpriv,\n\t\t\t\t\t\t    struct recv_buf *precvbuf)\n{\n\tunion recv_frame *precvframe;\n\n\tprecvframe = rtw_alloc_recvframe(&precvpriv->free_recv_queue);\n\tif (!precvframe) {\n\t\trtw_enqueue_recvbuf_to_head(precvbuf,\n\t\t\t\t\t    &precvpriv->recv_buf_pending_queue);\n\n\t\t \n\t\t \n\t\ttasklet_schedule(&precvpriv->recv_tasklet);\n\t}\n\n\treturn precvframe;\n}\n\nstatic inline bool rx_crc_err(struct recv_priv *precvpriv,\n\t\t\t      struct hal_com_data *p_hal_data,\n\t\t\t      struct rx_pkt_attrib *pattrib,\n\t\t\t      union recv_frame *precvframe)\n{\n\t \n\tif ((!(p_hal_data->ReceiveConfig & RCR_ACRC32)) && pattrib->crc_err) {\n\t\trtw_free_recvframe(precvframe, &precvpriv->free_recv_queue);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline bool pkt_exceeds_tail(struct recv_priv *precvpriv,\n\t\t\t\t    u8 *end, u8 *tail,\n\t\t\t\t    union recv_frame *precvframe)\n{\n\tif (end > tail) {\n\t\trtw_free_recvframe(precvframe, &precvpriv->free_recv_queue);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void rtl8723bs_recv_tasklet(struct tasklet_struct *t)\n{\n\tstruct adapter *padapter = from_tasklet(padapter, t,\n\t\t\t\t\t\trecvpriv.recv_tasklet);\n\tstruct hal_com_data *p_hal_data;\n\tstruct recv_priv *precvpriv;\n\tstruct recv_buf *precvbuf;\n\tunion recv_frame *precvframe;\n\tstruct rx_pkt_attrib *pattrib;\n\tstruct __queue *recv_buf_queue;\n\tu8 *ptr;\n\tu32 pkt_offset, skb_len, alloc_sz;\n\tstruct sk_buff *pkt_copy = NULL;\n\tu8 shift_sz = 0, rx_report_sz = 0;\n\n\tp_hal_data = GET_HAL_DATA(padapter);\n\tprecvpriv = &padapter->recvpriv;\n\trecv_buf_queue = &precvpriv->recv_buf_pending_queue;\n\n\tdo {\n\t\tprecvbuf = rtw_dequeue_recvbuf(recv_buf_queue);\n\t\tif (!precvbuf)\n\t\t\tbreak;\n\n\t\tptr = precvbuf->pdata;\n\n\t\twhile (ptr < precvbuf->ptail) {\n\t\t\tprecvframe = try_alloc_recvframe(precvpriv, precvbuf);\n\t\t\tif (!precvframe)\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tupdate_recvframe_attrib(padapter, precvframe,\n\t\t\t\t\t\t(struct recv_stat *)ptr);\n\n\t\t\tpattrib = &precvframe->u.hdr.attrib;\n\n\t\t\tif (rx_crc_err(precvpriv, p_hal_data,\n\t\t\t\t       pattrib, precvframe))\n\t\t\t\tbreak;\n\n\t\t\trx_report_sz = RXDESC_SIZE + pattrib->drvinfo_sz;\n\t\t\tpkt_offset = rx_report_sz +\n\t\t\t\tpattrib->shift_sz +\n\t\t\t\tpattrib->pkt_len;\n\n\t\t\tif (pkt_exceeds_tail(precvpriv, ptr + pkt_offset,\n\t\t\t\t\t     precvbuf->ptail, precvframe))\n\t\t\t\tbreak;\n\n\t\t\tif ((pattrib->crc_err) || (pattrib->icv_err)) {\n\t\t\t\trtw_free_recvframe(precvframe,\n\t\t\t\t\t\t   &precvpriv->free_recv_queue);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (pattrib->qos)\t \n\t\t\t\t\tshift_sz = 6;\n\t\t\t\telse\n\t\t\t\t\tshift_sz = 0;\n\n\t\t\t\tskb_len = pattrib->pkt_len;\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif ((pattrib->mfrag == 1) && (pattrib->frag_num == 0)) {\n\t\t\t\t\tif (skb_len <= 1650)\n\t\t\t\t\t\talloc_sz = 1664;\n\t\t\t\t\telse\n\t\t\t\t\t\talloc_sz = skb_len + 14;\n\t\t\t\t} else {\n\t\t\t\t\talloc_sz = skb_len;\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\talloc_sz += 14;\n\t\t\t\t}\n\n\t\t\t\tpkt_copy = rtw_skb_alloc(alloc_sz);\n\t\t\t\tif (!pkt_copy) {\n\t\t\t\t\trtw_free_recvframe(precvframe, &precvpriv->free_recv_queue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tpkt_copy->dev = padapter->pnetdev;\n\t\t\t\tprecvframe->u.hdr.pkt = pkt_copy;\n\t\t\t\tskb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7)); \n\t\t\t\tskb_reserve(pkt_copy, shift_sz); \n\t\t\t\tmemcpy(pkt_copy->data, (ptr + rx_report_sz + pattrib->shift_sz), skb_len);\n\t\t\t\tprecvframe->u.hdr.rx_head = pkt_copy->head;\n\t\t\t\tprecvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;\n\t\t\t\tprecvframe->u.hdr.rx_end = skb_end_pointer(pkt_copy);\n\n\t\t\t\trecvframe_put(precvframe, skb_len);\n\t\t\t\t \n\n\t\t\t\tif (p_hal_data->ReceiveConfig & RCR_APPFCS)\n\t\t\t\t\trecvframe_pull_tail(precvframe, IEEE80211_FCS_LEN);\n\n\t\t\t\t \n\t\t\t\tptr += RXDESC_SIZE;\n\n\t\t\t\t \n\t\t\t\tif (p_hal_data->ReceiveConfig & RCR_APP_BA_SSN) {\n\t\t\t\t\t \n\t\t\t\t\tptr += 4;\n\t\t\t\t}\n\n\t\t\t\tif (pattrib->pkt_rpt_type == NORMAL_RX) {  \n\t\t\t\t\tif (pattrib->physt)\n\t\t\t\t\t\tupdate_recvframe_phyinfo(precvframe, (struct phy_stat *)ptr);\n\n\t\t\t\t\trtw_recv_entry(precvframe);\n\t\t\t\t} else if (pattrib->pkt_rpt_type == C2H_PACKET) {\n\t\t\t\t\tstruct c2h_evt_hdr_t\tC2hEvent;\n\n\t\t\t\t\tu16 len_c2h = pattrib->pkt_len;\n\t\t\t\t\tu8 *pbuf_c2h = precvframe->u.hdr.rx_data;\n\t\t\t\t\tu8 *pdata_c2h;\n\n\t\t\t\t\tC2hEvent.CmdID = pbuf_c2h[0];\n\t\t\t\t\tC2hEvent.CmdSeq = pbuf_c2h[1];\n\t\t\t\t\tC2hEvent.CmdLen = (len_c2h-2);\n\t\t\t\t\tpdata_c2h = pbuf_c2h+2;\n\n\t\t\t\t\tif (C2hEvent.CmdID == C2H_CCX_TX_RPT)\n\t\t\t\t\t\tCCX_FwC2HTxRpt_8723b(padapter, pdata_c2h, C2hEvent.CmdLen);\n\t\t\t\t\telse\n\t\t\t\t\t\trtl8723bs_c2h_packet_handler(padapter, precvframe->u.hdr.rx_data, pattrib->pkt_len);\n\n\t\t\t\t\trtw_free_recvframe(precvframe, &precvpriv->free_recv_queue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpkt_offset = round_up(pkt_offset, 8);\n\t\t\tprecvbuf->pdata += pkt_offset;\n\t\t\tptr = precvbuf->pdata;\n\t\t\tprecvframe = NULL;\n\t\t\tpkt_copy = NULL;\n\t\t}\n\n\t\trtw_enqueue_recvbuf(precvbuf, &precvpriv->free_recv_buf_queue);\n\t} while (1);\n}\n\n \ns32 rtl8723bs_init_recv_priv(struct adapter *padapter)\n{\n\ts32 res;\n\tu32 i, n;\n\tstruct recv_priv *precvpriv;\n\tstruct recv_buf *precvbuf;\n\n\tres = _SUCCESS;\n\tprecvpriv = &padapter->recvpriv;\n\n\t \n\tINIT_LIST_HEAD(&precvpriv->free_recv_buf_queue.queue);\n\tspin_lock_init(&precvpriv->free_recv_buf_queue.lock);\n\tINIT_LIST_HEAD(&precvpriv->recv_buf_pending_queue.queue);\n\tspin_lock_init(&precvpriv->recv_buf_pending_queue.lock);\n\n\tn = NR_RECVBUFF * sizeof(struct recv_buf) + 4;\n\tprecvpriv->pallocated_recv_buf = rtw_zmalloc(n);\n\tif (!precvpriv->pallocated_recv_buf) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tprecvpriv->precv_buf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(precvpriv->pallocated_recv_buf), 4);\n\n\t \n\tprecvbuf = (struct recv_buf *)precvpriv->precv_buf;\n\tfor (i = 0; i < NR_RECVBUFF; i++) {\n\t\tinitrecvbuf(precvbuf, padapter);\n\n\t\tif (!precvbuf->pskb) {\n\t\t\tSIZE_PTR tmpaddr = 0;\n\t\t\tSIZE_PTR alignment = 0;\n\n\t\t\tprecvbuf->pskb = rtw_skb_alloc(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);\n\n\t\t\tif (precvbuf->pskb) {\n\t\t\t\tprecvbuf->pskb->dev = padapter->pnetdev;\n\n\t\t\t\ttmpaddr = (SIZE_PTR)precvbuf->pskb->data;\n\t\t\t\talignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);\n\t\t\t\tskb_reserve(precvbuf->pskb, (RECVBUFF_ALIGN_SZ - alignment));\n\t\t\t}\n\t\t}\n\n\t\tlist_add_tail(&precvbuf->list, &precvpriv->free_recv_buf_queue.queue);\n\n\t\tprecvbuf++;\n\t}\n\tprecvpriv->free_recv_buf_queue_cnt = i;\n\n\tif (res == _FAIL)\n\t\tgoto initbuferror;\n\n\t \n\ttasklet_setup(&precvpriv->recv_tasklet, rtl8723bs_recv_tasklet);\n\n\tgoto exit;\n\ninitbuferror:\n\tprecvbuf = (struct recv_buf *)precvpriv->precv_buf;\n\tif (precvbuf) {\n\t\tn = precvpriv->free_recv_buf_queue_cnt;\n\t\tprecvpriv->free_recv_buf_queue_cnt = 0;\n\t\tfor (i = 0; i < n ; i++) {\n\t\t\tlist_del_init(&precvbuf->list);\n\t\t\trtw_os_recvbuf_resource_free(padapter, precvbuf);\n\t\t\tprecvbuf++;\n\t\t}\n\t\tprecvpriv->precv_buf = NULL;\n\t}\n\n\tkfree(precvpriv->pallocated_recv_buf);\n\tprecvpriv->pallocated_recv_buf = NULL;\n\nexit:\n\treturn res;\n}\n\n \nvoid rtl8723bs_free_recv_priv(struct adapter *padapter)\n{\n\tu32 i;\n\tstruct recv_priv *precvpriv;\n\tstruct recv_buf *precvbuf;\n\n\tprecvpriv = &padapter->recvpriv;\n\n\t \n\ttasklet_kill(&precvpriv->recv_tasklet);\n\n\t \n\tprecvbuf = (struct recv_buf *)precvpriv->precv_buf;\n\tif (precvbuf) {\n\t\tprecvpriv->free_recv_buf_queue_cnt = 0;\n\t\tfor (i = 0; i < NR_RECVBUFF; i++) {\n\t\t\tlist_del_init(&precvbuf->list);\n\t\t\trtw_os_recvbuf_resource_free(padapter, precvbuf);\n\t\t\tprecvbuf++;\n\t\t}\n\t\tprecvpriv->precv_buf = NULL;\n\t}\n\n\tkfree(precvpriv->pallocated_recv_buf);\n\tprecvpriv->pallocated_recv_buf = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}