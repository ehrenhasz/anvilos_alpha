{
  "module_name": "hal_com_phycfg.c",
  "hash_id": "8efdc15f0b9d20d739c1f84b8d96b00bb3ce82cfe6069c193082e7b7635b5306",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/hal/hal_com_phycfg.c",
  "human_readable_source": "\n \n\n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <hal_data.h>\n#include <linux/kernel.h>\n\nu8 PHY_GetTxPowerByRateBase(struct adapter *Adapter, u8 RfPath,\n\t\t\t    enum rate_section RateSection)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(Adapter);\n\tu8\tvalue = 0;\n\n\tif (RfPath >= RF_PATH_MAX)\n\t\treturn 0;\n\n\tswitch (RateSection) {\n\tcase CCK:\n\t\tvalue = pHalData->TxPwrByRateBase2_4G[RfPath][0];\n\t\tbreak;\n\tcase OFDM:\n\t\tvalue = pHalData->TxPwrByRateBase2_4G[RfPath][1];\n\t\tbreak;\n\tcase HT_MCS0_MCS7:\n\t\tvalue = pHalData->TxPwrByRateBase2_4G[RfPath][2];\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn value;\n}\n\nstatic void\nphy_SetTxPowerByRateBase(struct adapter *Adapter, u8 RfPath,\n\t\t\t enum rate_section RateSection, u8 Value)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(Adapter);\n\n\tif (RfPath >= RF_PATH_MAX)\n\t\treturn;\n\n\tswitch (RateSection) {\n\tcase CCK:\n\t\tpHalData->TxPwrByRateBase2_4G[RfPath][0] = Value;\n\t\tbreak;\n\tcase OFDM:\n\t\tpHalData->TxPwrByRateBase2_4G[RfPath][1] = Value;\n\t\tbreak;\n\tcase HT_MCS0_MCS7:\n\t\tpHalData->TxPwrByRateBase2_4G[RfPath][2] = Value;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nphy_StoreTxPowerByRateBase(\nstruct adapter *padapter\n\t)\n{\n\tu8 path, base;\n\n\tfor (path = RF_PATH_A; path <= RF_PATH_B; ++path) {\n\t\tbase = PHY_GetTxPowerByRate(padapter, path, MGN_11M);\n\t\tphy_SetTxPowerByRateBase(padapter, path, CCK, base);\n\n\t\tbase = PHY_GetTxPowerByRate(padapter, path, MGN_54M);\n\t\tphy_SetTxPowerByRateBase(padapter, path, OFDM, base);\n\n\t\tbase = PHY_GetTxPowerByRate(padapter, path, MGN_MCS7);\n\t\tphy_SetTxPowerByRateBase(padapter, path, HT_MCS0_MCS7, base);\n\t}\n}\n\nu8 PHY_GetRateSectionIndexOfTxPowerByRate(\n\tstruct adapter *padapter, u32 RegAddr, u32 BitMask\n)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\tstruct dm_odm_t *pDM_Odm = &pHalData->odmpriv;\n\tu8\tindex = 0;\n\n\tif (pDM_Odm->PhyRegPgVersion == 0) {\n\t\tswitch (RegAddr) {\n\t\tcase rTxAGC_A_Rate18_06:\n\t\t\tindex = 0;\n\t\t\tbreak;\n\t\tcase rTxAGC_A_Rate54_24:\n\t\t\tindex = 1;\n\t\t\tbreak;\n\t\tcase rTxAGC_A_CCK1_Mcs32:\n\t\t\tindex = 6;\n\t\t\tbreak;\n\t\tcase rTxAGC_B_CCK11_A_CCK2_11:\n\t\t\tif (BitMask == bMaskH3Bytes)\n\t\t\t\tindex = 7;\n\t\t\telse if (BitMask == 0x000000ff)\n\t\t\t\tindex = 15;\n\t\t\tbreak;\n\n\t\tcase rTxAGC_A_Mcs03_Mcs00:\n\t\t\tindex = 2;\n\t\t\tbreak;\n\t\tcase rTxAGC_A_Mcs07_Mcs04:\n\t\t\tindex = 3;\n\t\t\tbreak;\n\t\tcase rTxAGC_B_Rate18_06:\n\t\t\tindex = 8;\n\t\t\tbreak;\n\t\tcase rTxAGC_B_Rate54_24:\n\t\t\tindex = 9;\n\t\t\tbreak;\n\t\tcase rTxAGC_B_CCK1_55_Mcs32:\n\t\t\tindex = 14;\n\t\t\tbreak;\n\t\tcase rTxAGC_B_Mcs03_Mcs00:\n\t\t\tindex = 10;\n\t\t\tbreak;\n\t\tcase rTxAGC_B_Mcs07_Mcs04:\n\t\t\tindex = 11;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn index;\n}\n\nvoid\nPHY_GetRateValuesOfTxPowerByRate(\n\tstruct adapter *padapter,\n\tu32\tRegAddr,\n\tu32\tBitMask,\n\tu32\tValue,\n\tu8 *RateIndex,\n\ts8 *PwrByRateVal,\n\tu8 *RateNum\n)\n{\n\tu8 i = 0;\n\n\tswitch (RegAddr) {\n\tcase rTxAGC_A_Rate18_06:\n\tcase rTxAGC_B_Rate18_06:\n\t\tRateIndex[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_6M);\n\t\tRateIndex[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_9M);\n\t\tRateIndex[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_12M);\n\t\tRateIndex[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_18M);\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tPwrByRateVal[i] = (s8) ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +\n\t\t\t\t\t\t\t\t\t\t\t((Value >> (i * 8)) & 0xF));\n\t\t}\n\t\t*RateNum = 4;\n\t\tbreak;\n\n\tcase rTxAGC_A_Rate54_24:\n\tcase rTxAGC_B_Rate54_24:\n\t\tRateIndex[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_24M);\n\t\tRateIndex[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_36M);\n\t\tRateIndex[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_48M);\n\t\tRateIndex[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_54M);\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tPwrByRateVal[i] = (s8) ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +\n\t\t\t\t\t\t\t\t\t\t\t((Value >> (i * 8)) & 0xF));\n\t\t}\n\t\t*RateNum = 4;\n\t\tbreak;\n\n\tcase rTxAGC_A_CCK1_Mcs32:\n\t\tRateIndex[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_1M);\n\t\tPwrByRateVal[0] = (s8) ((((Value >> (8 + 4)) & 0xF)) * 10 +\n\t\t\t\t\t\t\t\t\t\t((Value >> 8) & 0xF));\n\t\t*RateNum = 1;\n\t\tbreak;\n\n\tcase rTxAGC_B_CCK11_A_CCK2_11:\n\t\tif (BitMask == 0xffffff00) {\n\t\t\tRateIndex[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_2M);\n\t\t\tRateIndex[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_5_5M);\n\t\t\tRateIndex[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_11M);\n\t\t\tfor (i = 1; i < 4; ++i) {\n\t\t\t\tPwrByRateVal[i - 1] = (s8) ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +\n\t\t\t\t\t\t\t\t\t\t\t\t((Value >> (i * 8)) & 0xF));\n\t\t\t}\n\t\t\t*RateNum = 3;\n\t\t} else if (BitMask == 0x000000ff) {\n\t\t\tRateIndex[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_11M);\n\t\t\tPwrByRateVal[0] = (s8) ((((Value >> 4) & 0xF)) * 10 + (Value & 0xF));\n\t\t\t*RateNum = 1;\n\t\t}\n\t\tbreak;\n\n\tcase rTxAGC_A_Mcs03_Mcs00:\n\tcase rTxAGC_B_Mcs03_Mcs00:\n\t\tRateIndex[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS0);\n\t\tRateIndex[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS1);\n\t\tRateIndex[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS2);\n\t\tRateIndex[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS3);\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tPwrByRateVal[i] = (s8) ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +\n\t\t\t\t\t\t\t\t\t\t\t((Value >> (i * 8)) & 0xF));\n\t\t}\n\t\t*RateNum = 4;\n\t\tbreak;\n\n\tcase rTxAGC_A_Mcs07_Mcs04:\n\tcase rTxAGC_B_Mcs07_Mcs04:\n\t\tRateIndex[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS4);\n\t\tRateIndex[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS5);\n\t\tRateIndex[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS6);\n\t\tRateIndex[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS7);\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tPwrByRateVal[i] = (s8) ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +\n\t\t\t\t\t\t\t\t\t\t\t((Value >> (i * 8)) & 0xF));\n\t\t}\n\t\t*RateNum = 4;\n\t\tbreak;\n\n\tcase rTxAGC_B_CCK1_55_Mcs32:\n\t\tRateIndex[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_1M);\n\t\tRateIndex[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_2M);\n\t\tRateIndex[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_5_5M);\n\t\tfor (i = 1; i < 4; ++i) {\n\t\t\tPwrByRateVal[i - 1] = (s8) ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +\n\t\t\t\t\t\t\t\t\t\t\t((Value >> (i * 8)) & 0xF));\n\t\t}\n\t\t*RateNum = 3;\n\t\tbreak;\n\n\tcase 0xC20:\n\tcase 0xE20:\n\tcase 0x1820:\n\tcase 0x1a20:\n\t\tRateIndex[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_1M);\n\t\tRateIndex[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_2M);\n\t\tRateIndex[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_5_5M);\n\t\tRateIndex[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_11M);\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tPwrByRateVal[i] = (s8) ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +\n\t\t\t\t\t\t\t\t\t\t\t((Value >> (i * 8)) & 0xF));\n\t\t}\n\t\t*RateNum = 4;\n\t\tbreak;\n\n\tcase 0xC24:\n\tcase 0xE24:\n\tcase 0x1824:\n\tcase 0x1a24:\n\t\tRateIndex[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_6M);\n\t\tRateIndex[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_9M);\n\t\tRateIndex[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_12M);\n\t\tRateIndex[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_18M);\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tPwrByRateVal[i] = (s8) ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +\n\t\t\t\t\t\t\t\t\t\t\t((Value >> (i * 8)) & 0xF));\n\t\t}\n\t\t*RateNum = 4;\n\t\tbreak;\n\n\tcase 0xC28:\n\tcase 0xE28:\n\tcase 0x1828:\n\tcase 0x1a28:\n\t\tRateIndex[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_24M);\n\t\tRateIndex[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_36M);\n\t\tRateIndex[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_48M);\n\t\tRateIndex[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_54M);\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tPwrByRateVal[i] = (s8) ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +\n\t\t\t\t\t\t\t\t\t\t\t((Value >> (i * 8)) & 0xF));\n\t\t}\n\t\t*RateNum = 4;\n\t\tbreak;\n\n\tcase 0xC2C:\n\tcase 0xE2C:\n\tcase 0x182C:\n\tcase 0x1a2C:\n\t\tRateIndex[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS0);\n\t\tRateIndex[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS1);\n\t\tRateIndex[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS2);\n\t\tRateIndex[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS3);\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tPwrByRateVal[i] = (s8) ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +\n\t\t\t\t\t\t\t\t\t\t\t((Value >> (i * 8)) & 0xF));\n\t\t}\n\t\t*RateNum = 4;\n\t\tbreak;\n\n\tcase 0xC30:\n\tcase 0xE30:\n\tcase 0x1830:\n\tcase 0x1a30:\n\t\tRateIndex[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS4);\n\t\tRateIndex[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS5);\n\t\tRateIndex[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS6);\n\t\tRateIndex[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS7);\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tPwrByRateVal[i] = (s8) ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +\n\t\t\t\t\t\t\t\t\t\t\t((Value >> (i * 8)) & 0xF));\n\t\t}\n\t\t*RateNum = 4;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void PHY_StoreTxPowerByRateNew(struct adapter *padapter,\tu32 RfPath,\n\t\t\t\t      u32 RegAddr, u32 BitMask, u32 Data)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\tu8 i = 0, rateIndex[4] = {0}, rateNum = 0;\n\ts8\tPwrByRateVal[4] = {0};\n\n\tPHY_GetRateValuesOfTxPowerByRate(padapter, RegAddr, BitMask, Data, rateIndex, PwrByRateVal, &rateNum);\n\n\tif (RfPath >= RF_PATH_MAX)\n\t\treturn;\n\n\tfor (i = 0; i < rateNum; ++i) {\n\t\tpHalData->TxPwrByRateOffset[RfPath][rateIndex[i]] = PwrByRateVal[i];\n\t}\n}\n\nstatic void PHY_StoreTxPowerByRateOld(\n\tstruct adapter *padapter, u32\tRegAddr, u32 BitMask, u32 Data\n)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\tu8\tindex = PHY_GetRateSectionIndexOfTxPowerByRate(padapter, RegAddr, BitMask);\n\n\tpHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][index] = Data;\n}\n\nvoid PHY_InitTxPowerByRate(struct adapter *padapter)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\tu8 rfPath, rate;\n\n\tfor (rfPath = RF_PATH_A; rfPath < MAX_RF_PATH_NUM; ++rfPath)\n\t\tfor (rate = 0; rate < TX_PWR_BY_RATE_NUM_RATE; ++rate)\n\t\t\tpHalData->TxPwrByRateOffset[rfPath][rate] = 0;\n}\n\nvoid PHY_StoreTxPowerByRate(\n\tstruct adapter *padapter,\n\tu32\tRfPath,\n\tu32\tRegAddr,\n\tu32\tBitMask,\n\tu32\tData\n)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\tstruct dm_odm_t *pDM_Odm = &pHalData->odmpriv;\n\n\tif (pDM_Odm->PhyRegPgVersion > 0)\n\t\tPHY_StoreTxPowerByRateNew(padapter, RfPath, RegAddr, BitMask, Data);\n\telse if (pDM_Odm->PhyRegPgVersion == 0) {\n\t\tPHY_StoreTxPowerByRateOld(padapter, RegAddr, BitMask, Data);\n\t}\n}\n\nstatic void\nphy_ConvertTxPowerByRateInDbmToRelativeValues(\nstruct adapter *padapter\n\t)\n{\n\tu8\tbase = 0, i = 0, value = 0, path = 0;\n\tu8\tcckRates[4] = {\n\t\tMGN_1M, MGN_2M, MGN_5_5M, MGN_11M\n\t};\n\tu8\tofdmRates[8] = {\n\t\tMGN_6M, MGN_9M, MGN_12M, MGN_18M, MGN_24M, MGN_36M, MGN_48M, MGN_54M\n\t};\n\tu8 mcs0_7Rates[8] = {\n\t\tMGN_MCS0, MGN_MCS1, MGN_MCS2, MGN_MCS3, MGN_MCS4, MGN_MCS5, MGN_MCS6, MGN_MCS7\n\t};\n\tfor (path = RF_PATH_A; path < RF_PATH_MAX; ++path) {\n\t\t \n\t\tbase = PHY_GetTxPowerByRate(padapter, path, MGN_11M);\n\t\tfor (i = 0; i < ARRAY_SIZE(cckRates); ++i) {\n\t\t\tvalue = PHY_GetTxPowerByRate(padapter, path, cckRates[i]);\n\t\t\tPHY_SetTxPowerByRate(padapter, path, cckRates[i], value - base);\n\t\t}\n\n\t\t \n\t\tbase = PHY_GetTxPowerByRate(padapter, path, MGN_54M);\n\t\tfor (i = 0; i < sizeof(ofdmRates); ++i) {\n\t\t\tvalue = PHY_GetTxPowerByRate(padapter, path, ofdmRates[i]);\n\t\t\tPHY_SetTxPowerByRate(padapter, path, ofdmRates[i], value - base);\n\t\t}\n\n\t\t \n\t\tbase = PHY_GetTxPowerByRate(padapter, path, MGN_MCS7);\n\t\tfor (i = 0; i < sizeof(mcs0_7Rates); ++i) {\n\t\t\tvalue = PHY_GetTxPowerByRate(padapter, path, mcs0_7Rates[i]);\n\t\t\tPHY_SetTxPowerByRate(padapter, path, mcs0_7Rates[i], value - base);\n\t\t}\n\t}\n}\n\n \nvoid PHY_TxPowerByRateConfiguration(struct adapter *padapter)\n{\n\tphy_StoreTxPowerByRateBase(padapter);\n\tphy_ConvertTxPowerByRateInDbmToRelativeValues(padapter);\n}\n\nvoid PHY_SetTxPowerIndexByRateSection(\n\tstruct adapter *padapter, u8 RFPath, u8 Channel, u8 RateSection\n)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\n\tif (RateSection == CCK) {\n\t\tu8 cckRates[]   = {MGN_1M, MGN_2M, MGN_5_5M, MGN_11M};\n\t\tPHY_SetTxPowerIndexByRateArray(padapter, RFPath,\n\t\t\t\t\t     pHalData->CurrentChannelBW,\n\t\t\t\t\t     Channel, cckRates,\n\t\t\t\t\t     ARRAY_SIZE(cckRates));\n\n\t} else if (RateSection == OFDM) {\n\t\tu8 ofdmRates[]  = {MGN_6M, MGN_9M, MGN_12M, MGN_18M, MGN_24M, MGN_36M, MGN_48M, MGN_54M};\n\t\tPHY_SetTxPowerIndexByRateArray(padapter, RFPath,\n\t\t\t\t\t       pHalData->CurrentChannelBW,\n\t\t\t\t\t       Channel, ofdmRates,\n\t\t\t\t\t       ARRAY_SIZE(ofdmRates));\n\n\t} else if (RateSection == HT_MCS0_MCS7) {\n\t\tu8 htRates1T[]  = {MGN_MCS0, MGN_MCS1, MGN_MCS2, MGN_MCS3, MGN_MCS4, MGN_MCS5, MGN_MCS6, MGN_MCS7};\n\t\tPHY_SetTxPowerIndexByRateArray(padapter, RFPath,\n\t\t\t\t\t       pHalData->CurrentChannelBW,\n\t\t\t\t\t       Channel, htRates1T,\n\t\t\t\t\t       ARRAY_SIZE(htRates1T));\n\n\t}\n}\n\nu8 PHY_GetTxPowerIndexBase(\n\tstruct adapter *padapter,\n\tu8 RFPath,\n\tu8 Rate,\n\tenum channel_width\tBandWidth,\n\tu8 Channel\n)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tu8 txPower = 0;\n\tu8 chnlIdx = (Channel-1);\n\n\tif (HAL_IsLegalChannel(padapter, Channel) == false)\n\t\tchnlIdx = 0;\n\n\tif (IS_CCK_RATE(Rate))\n\t\ttxPower = pHalData->Index24G_CCK_Base[RFPath][chnlIdx];\n\telse if (MGN_6M <= Rate)\n\t\ttxPower = pHalData->Index24G_BW40_Base[RFPath][chnlIdx];\n\n\t \n\tif ((MGN_6M <= Rate && Rate <= MGN_54M) && !IS_CCK_RATE(Rate))\n\t\ttxPower += pHalData->OFDM_24G_Diff[RFPath][TX_1S];\n\n\tif (BandWidth == CHANNEL_WIDTH_20) {  \n\t\tif (MGN_MCS0 <= Rate && Rate <= MGN_MCS7)\n\t\t\ttxPower += pHalData->BW20_24G_Diff[RFPath][TX_1S];\n\t} else if (BandWidth == CHANNEL_WIDTH_40) {  \n\t\tif (MGN_MCS0 <= Rate && Rate <= MGN_MCS7)\n\t\t\ttxPower += pHalData->BW40_24G_Diff[RFPath][TX_1S];\n\t}\n\n\treturn txPower;\n}\n\ns8 PHY_GetTxPowerTrackingOffset(struct adapter *padapter, u8 RFPath, u8 Rate)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tstruct dm_odm_t *pDM_Odm = &pHalData->odmpriv;\n\ts8 offset = 0;\n\n\tif (pDM_Odm->RFCalibrateInfo.TxPowerTrackControl  == false)\n\t\treturn offset;\n\n\tif ((Rate == MGN_1M) || (Rate == MGN_2M) || (Rate == MGN_5_5M) || (Rate == MGN_11M))\n\t\toffset = pDM_Odm->Remnant_CCKSwingIdx;\n\telse\n\t\toffset = pDM_Odm->Remnant_OFDMSwingIdx[RFPath];\n\n\treturn offset;\n}\n\nu8 PHY_GetRateIndexOfTxPowerByRate(u8 Rate)\n{\n\tu8 index = 0;\n\tswitch (Rate) {\n\tcase MGN_1M:\n\t\tindex = 0;\n\t\tbreak;\n\tcase MGN_2M:\n\t\tindex = 1;\n\t\tbreak;\n\tcase MGN_5_5M:\n\t\tindex = 2;\n\t\tbreak;\n\tcase MGN_11M:\n\t\tindex = 3;\n\t\tbreak;\n\tcase MGN_6M:\n\t\tindex = 4;\n\t\tbreak;\n\tcase MGN_9M:\n\t\tindex = 5;\n\t\tbreak;\n\tcase MGN_12M:\n\t\tindex = 6;\n\t\tbreak;\n\tcase MGN_18M:\n\t\tindex = 7;\n\t\tbreak;\n\tcase MGN_24M:\n\t\tindex = 8;\n\t\tbreak;\n\tcase MGN_36M:\n\t\tindex = 9;\n\t\tbreak;\n\tcase MGN_48M:\n\t\tindex = 10;\n\t\tbreak;\n\tcase MGN_54M:\n\t\tindex = 11;\n\t\tbreak;\n\tcase MGN_MCS0:\n\t\tindex = 12;\n\t\tbreak;\n\tcase MGN_MCS1:\n\t\tindex = 13;\n\t\tbreak;\n\tcase MGN_MCS2:\n\t\tindex = 14;\n\t\tbreak;\n\tcase MGN_MCS3:\n\t\tindex = 15;\n\t\tbreak;\n\tcase MGN_MCS4:\n\t\tindex = 16;\n\t\tbreak;\n\tcase MGN_MCS5:\n\t\tindex = 17;\n\t\tbreak;\n\tcase MGN_MCS6:\n\t\tindex = 18;\n\t\tbreak;\n\tcase MGN_MCS7:\n\t\tindex = 19;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn index;\n}\n\ns8 PHY_GetTxPowerByRate(struct adapter *padapter, u8 RFPath, u8 Rate)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\ts8 value = 0;\n\tu8 rateIndex = PHY_GetRateIndexOfTxPowerByRate(Rate);\n\n\tif ((padapter->registrypriv.RegEnableTxPowerByRate == 2 && pHalData->EEPROMRegulatory == 2) ||\n\t\t   padapter->registrypriv.RegEnableTxPowerByRate == 0)\n\t\treturn 0;\n\n\tif (RFPath >= RF_PATH_MAX)\n\t\treturn value;\n\n\tif (rateIndex >= TX_PWR_BY_RATE_NUM_RATE)\n\t\treturn value;\n\n\treturn pHalData->TxPwrByRateOffset[RFPath][rateIndex];\n\n}\n\nvoid PHY_SetTxPowerByRate(\n\tstruct adapter *padapter,\n\tu8 RFPath,\n\tu8 Rate,\n\ts8 Value\n)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\tu8 rateIndex = PHY_GetRateIndexOfTxPowerByRate(Rate);\n\n\tif (RFPath >= RF_PATH_MAX)\n\t\treturn;\n\n\tif (rateIndex >= TX_PWR_BY_RATE_NUM_RATE)\n\t\treturn;\n\n\tpHalData->TxPwrByRateOffset[RFPath][rateIndex] = Value;\n}\n\nvoid PHY_SetTxPowerLevelByPath(struct adapter *Adapter, u8 channel, u8 path)\n{\n\tPHY_SetTxPowerIndexByRateSection(Adapter, path, channel, CCK);\n\n\tPHY_SetTxPowerIndexByRateSection(Adapter, path, channel, OFDM);\n\tPHY_SetTxPowerIndexByRateSection(Adapter, path, channel, HT_MCS0_MCS7);\n}\n\nvoid PHY_SetTxPowerIndexByRateArray(\n\tstruct adapter *padapter,\n\tu8 RFPath,\n\tenum channel_width BandWidth,\n\tu8 Channel,\n\tu8 *Rates,\n\tu8 RateArraySize\n)\n{\n\tu32 powerIndex = 0;\n\tint\ti = 0;\n\n\tfor (i = 0; i < RateArraySize; ++i) {\n\t\tpowerIndex = PHY_GetTxPowerIndex(padapter, RFPath, Rates[i], BandWidth, Channel);\n\t\tPHY_SetTxPowerIndex(padapter, powerIndex, RFPath, Rates[i]);\n\t}\n}\n\nstatic s8 phy_GetWorldWideLimit(s8 *LimitTable)\n{\n\ts8\tmin = LimitTable[0];\n\tu8 i = 0;\n\n\tfor (i = 0; i < MAX_REGULATION_NUM; ++i) {\n\t\tif (LimitTable[i] < min)\n\t\t\tmin = LimitTable[i];\n\t}\n\n\treturn min;\n}\n\nstatic s8 phy_GetChannelIndexOfTxPowerLimit(u8 Channel)\n{\n\treturn Channel - 1;\n}\n\nstatic s16 get_bandwidth_idx(const enum channel_width bandwidth)\n{\n\tswitch (bandwidth) {\n\tcase CHANNEL_WIDTH_20:\n\t\treturn 0;\n\tcase CHANNEL_WIDTH_40:\n\t\treturn 1;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic s16 get_rate_sctn_idx(const u8 rate)\n{\n\tswitch (rate) {\n\tcase MGN_1M: case MGN_2M: case MGN_5_5M: case MGN_11M:\n\t\treturn 0;\n\tcase MGN_6M: case MGN_9M: case MGN_12M: case MGN_18M:\n\tcase MGN_24M: case MGN_36M: case MGN_48M: case MGN_54M:\n\t\treturn 1;\n\tcase MGN_MCS0: case MGN_MCS1: case MGN_MCS2: case MGN_MCS3:\n\tcase MGN_MCS4: case MGN_MCS5: case MGN_MCS6: case MGN_MCS7:\n\t\treturn 2;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\ns8 phy_get_tx_pwr_lmt(struct adapter *adapter, u32 reg_pwr_tbl_sel,\n\t\t      enum channel_width bandwidth,\n\t\t      u8 rf_path, u8 data_rate, u8 channel)\n{\n\ts16 idx_regulation = -1;\n\ts16 idx_bandwidth  = -1;\n\ts16 idx_rate_sctn  = -1;\n\ts16 idx_channel    = -1;\n\ts8 pwr_lmt = MAX_POWER_INDEX;\n\tstruct hal_com_data *hal_data = GET_HAL_DATA(adapter);\n\ts8 limits[10] = {0}; u8 i = 0;\n\n\tif (((adapter->registrypriv.RegEnableTxPowerLimit == 2) &&\n\t     (hal_data->EEPROMRegulatory != 1)) ||\n\t    (adapter->registrypriv.RegEnableTxPowerLimit == 0))\n\t\treturn MAX_POWER_INDEX;\n\n\tswitch (adapter->registrypriv.RegPwrTblSel) {\n\tcase 1:\n\t\tidx_regulation = TXPWR_LMT_ETSI;\n\t\tbreak;\n\tcase 2:\n\t\tidx_regulation = TXPWR_LMT_MKK;\n\t\tbreak;\n\tcase 3:\n\t\tidx_regulation = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase 4:\n\t\tidx_regulation = TXPWR_LMT_WW;\n\t\tbreak;\n\tdefault:\n\t\tidx_regulation = hal_data->Regulation2_4G;\n\t\tbreak;\n\t}\n\n\tidx_bandwidth = get_bandwidth_idx(bandwidth);\n\tidx_rate_sctn = get_rate_sctn_idx(data_rate);\n\n\t \n\t \n\t \n\t \n\tif (idx_rate_sctn == 0 || idx_rate_sctn == 1)\n\t\tidx_bandwidth = 0;\n\n\tchannel = phy_GetChannelIndexOfTxPowerLimit(channel);\n\n\tif (idx_regulation == -1 || idx_bandwidth == -1 ||\n\t    idx_rate_sctn == -1 || idx_channel == -1)\n\t\treturn MAX_POWER_INDEX;\n\n\n\tfor (i = 0; i < MAX_REGULATION_NUM; i++)\n\t\tlimits[i] = hal_data->TxPwrLimit_2_4G[i]\n\t\t\t\t\t\t     [idx_bandwidth]\n\t\t\t\t\t\t     [idx_rate_sctn]\n\t\t\t\t\t\t     [idx_channel]\n\t\t\t\t\t\t     [rf_path];\n\n\tpwr_lmt = (idx_regulation == TXPWR_LMT_WW) ?\n\t\tphy_GetWorldWideLimit(limits) :\n\t\thal_data->TxPwrLimit_2_4G[idx_regulation]\n\t\t\t\t\t [idx_bandwidth]\n\t\t\t\t\t [idx_rate_sctn]\n\t\t\t\t\t [idx_channel]\n\t\t\t\t\t [rf_path];\n\n\treturn pwr_lmt;\n}\n\nvoid PHY_ConvertTxPowerLimitToPowerIndex(struct adapter *Adapter)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(Adapter);\n\tu8 BW40PwrBasedBm2_4G = 0x2E;\n\tu8 regulation, bw, channel, rateSection;\n\ts8 tempValue = 0, tempPwrLmt = 0;\n\tu8 rfPath = 0;\n\n\tfor (regulation = 0; regulation < MAX_REGULATION_NUM; ++regulation) {\n\t\tfor (bw = 0; bw < MAX_2_4G_BANDWIDTH_NUM; ++bw) {\n\t\t\tfor (channel = 0; channel < CHANNEL_MAX_NUMBER_2G; ++channel) {\n\t\t\t\tfor (rateSection = 0; rateSection < MAX_RATE_SECTION_NUM; ++rateSection) {\n\t\t\t\t\ttempPwrLmt = pHalData->TxPwrLimit_2_4G[regulation][bw][rateSection][channel][RF_PATH_A];\n\n\t\t\t\t\tfor (rfPath = RF_PATH_A; rfPath < MAX_RF_PATH_NUM; ++rfPath) {\n\t\t\t\t\t\tif (pHalData->odmpriv.PhyRegPgValueType == PHY_REG_PG_EXACT_VALUE) {\n\t\t\t\t\t\t\tif (rateSection == 2)  \n\t\t\t\t\t\t\t\tBW40PwrBasedBm2_4G = PHY_GetTxPowerByRateBase(Adapter, rfPath, HT_MCS0_MCS7);\n\t\t\t\t\t\t\telse if (rateSection == 1)  \n\t\t\t\t\t\t\t\tBW40PwrBasedBm2_4G = PHY_GetTxPowerByRateBase(Adapter, rfPath, OFDM);\n\t\t\t\t\t\t\telse if (rateSection == 0)  \n\t\t\t\t\t\t\t\tBW40PwrBasedBm2_4G = PHY_GetTxPowerByRateBase(Adapter, rfPath, CCK);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tBW40PwrBasedBm2_4G = Adapter->registrypriv.RegPowerBase * 2;\n\n\t\t\t\t\t\tif (tempPwrLmt != MAX_POWER_INDEX) {\n\t\t\t\t\t\t\ttempValue = tempPwrLmt - BW40PwrBasedBm2_4G;\n\t\t\t\t\t\t\tpHalData->TxPwrLimit_2_4G[regulation][bw][rateSection][channel][rfPath] = tempValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid PHY_InitTxPowerLimit(struct adapter *Adapter)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(Adapter);\n\tu8 i, j, k, l, m;\n\n\tfor (i = 0; i < MAX_REGULATION_NUM; ++i) {\n\t\tfor (j = 0; j < MAX_2_4G_BANDWIDTH_NUM; ++j)\n\t\t\tfor (k = 0; k < MAX_RATE_SECTION_NUM; ++k)\n\t\t\t\tfor (m = 0; m < CHANNEL_MAX_NUMBER_2G; ++m)\n\t\t\t\t\tfor (l = 0; l < MAX_RF_PATH_NUM; ++l)\n\t\t\t\t\t\tpHalData->TxPwrLimit_2_4G[i][j][k][m][l] = MAX_POWER_INDEX;\n\t}\n}\n\nvoid PHY_SetTxPowerLimit(\n\tstruct adapter *Adapter,\n\tu8 *Regulation,\n\tu8 *Bandwidth,\n\tu8 *RateSection,\n\tu8 *RfPath,\n\tu8 *Channel,\n\tu8 *PowerLimit\n)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(Adapter);\n\tu8 regulation = 0, bandwidth = 0, rateSection = 0, channel;\n\ts8 powerLimit = 0, prevPowerLimit, channelIndex;\n\n\tGetU1ByteIntegerFromStringInDecimal((s8 *)Channel, &channel);\n\tGetU1ByteIntegerFromStringInDecimal((s8 *)PowerLimit, &powerLimit);\n\n\tpowerLimit = powerLimit > MAX_POWER_INDEX ? MAX_POWER_INDEX : powerLimit;\n\n\tif (eqNByte(Regulation, (u8 *)(\"FCC\"), 3))\n\t\tregulation = 0;\n\telse if (eqNByte(Regulation, (u8 *)(\"MKK\"), 3))\n\t\tregulation = 1;\n\telse if (eqNByte(Regulation, (u8 *)(\"ETSI\"), 4))\n\t\tregulation = 2;\n\telse if (eqNByte(Regulation, (u8 *)(\"WW13\"), 4))\n\t\tregulation = 3;\n\n\tif (eqNByte(RateSection, (u8 *)(\"CCK\"), 3) && eqNByte(RfPath, (u8 *)(\"1T\"), 2))\n\t\trateSection = 0;\n\telse if (eqNByte(RateSection, (u8 *)(\"OFDM\"), 4) && eqNByte(RfPath, (u8 *)(\"1T\"), 2))\n\t\trateSection = 1;\n\telse if (eqNByte(RateSection, (u8 *)(\"HT\"), 2) && eqNByte(RfPath, (u8 *)(\"1T\"), 2))\n\t\trateSection = 2;\n\telse\n\t\treturn;\n\n\tif (eqNByte(Bandwidth, (u8 *)(\"20M\"), 3))\n\t\tbandwidth = 0;\n\telse if (eqNByte(Bandwidth, (u8 *)(\"40M\"), 3))\n\t\tbandwidth = 1;\n\n\tchannelIndex = phy_GetChannelIndexOfTxPowerLimit(channel);\n\n\tif (channelIndex == -1)\n\t\treturn;\n\n\tprevPowerLimit = pHalData->TxPwrLimit_2_4G[regulation][bandwidth][rateSection][channelIndex][RF_PATH_A];\n\n\tif (powerLimit < prevPowerLimit)\n\t\tpHalData->TxPwrLimit_2_4G[regulation][bandwidth][rateSection][channelIndex][RF_PATH_A] = powerLimit;\n}\n\nvoid Hal_ChannelPlanToRegulation(struct adapter *Adapter, u16 ChannelPlan)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\n\tpHalData->Regulation2_4G = TXPWR_LMT_WW;\n\n\tswitch (ChannelPlan) {\n\tcase RT_CHANNEL_DOMAIN_WORLD_NULL:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_WW;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_ETSI1_NULL:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_ETSI;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_FCC1_NULL:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_MKK1_NULL:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_MKK;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_ETSI2_NULL:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_ETSI;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_FCC1_FCC1:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_ETSI1:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_MKK1_MKK1:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_MKK;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_KCC1:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_FCC2:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_FCC3:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_FCC4:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_FCC5:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_FCC6:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_FCC1_FCC7:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_ETSI2:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_ETSI3:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_MKK1_MKK2:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_MKK;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_MKK1_MKK3:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_MKK;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_FCC1_NCC1:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_FCC1_NCC2:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_GLOBAL_NULL:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_WW;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_ETSI1_ETSI4:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_ETSI;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_FCC1_FCC2:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_FCC1_NCC3:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_ETSI5:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_ETSI;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_FCC1_FCC8:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_ETSI6:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_ETSI;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_ETSI7:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_ETSI;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_ETSI8:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_ETSI;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_ETSI9:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_ETSI;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_ETSI10:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_ETSI;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_ETSI11:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_ETSI;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_FCC1_NCC4:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_ETSI12:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_ETSI;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_FCC1_FCC9:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_WORLD_ETSI13:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_ETSI;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_FCC1_FCC10:\n\t\tpHalData->Regulation2_4G = TXPWR_LMT_FCC;\n\t\tbreak;\n\tcase RT_CHANNEL_DOMAIN_REALTEK_DEFINE:  \n\t\tpHalData->Regulation2_4G = TXPWR_LMT_WW;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}