{
  "module_name": "sdio_halinit.c",
  "hash_id": "baae3c3c64ed85a0b3e23419572b34ccad23c54357179cfd1e6042b08a39e81e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/hal/sdio_halinit.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <rtl8723b_hal.h>\n\n#include \"hal_com_h2c.h\"\n \nstatic u8 CardEnable(struct adapter *padapter)\n{\n\tu8 bMacPwrCtrlOn;\n\tu8 ret = _FAIL;\n\n\n\trtw_hal_get_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);\n\tif (!bMacPwrCtrlOn) {\n\t\t \n\t\t \n\t\trtw_write8(padapter, REG_RSV_CTRL, 0x0);\n\n\t\tret = HalPwrSeqCmdParsing(padapter, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, rtl8723B_card_enable_flow);\n\t\tif (ret == _SUCCESS) {\n\t\t\tu8 bMacPwrCtrlOn = true;\n\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);\n\t\t}\n\t} else\n\t\tret = _SUCCESS;\n\n\treturn ret;\n}\n\nstatic\nu8 _InitPowerOn_8723BS(struct adapter *padapter)\n{\n\tu8 value8;\n\tu16 value16;\n\tu32 value32;\n\tu8 ret;\n \n\n\n\t \n\n\t \n\tret = CardEnable(padapter);\n\tif (!ret)\n\t\treturn _FAIL;\n\n\t \n\tvalue8 = rtw_read8(padapter, REG_GPIO_INTM + 1);\n\tvalue8 |= BIT(1);  \n\trtw_write8(padapter, REG_GPIO_INTM + 1, value8);\n\tvalue8 = rtw_read8(padapter, REG_GPIO_IO_SEL_2 + 1);\n\tvalue8 |= BIT(1);\n\trtw_write8(padapter, REG_GPIO_IO_SEL_2 + 1, value8);\n\n\t \n\tvalue16 = rtw_read16(padapter, REG_APS_FSMCO);\n\tvalue16 |= EnPDN;  \n\trtw_write16(padapter, REG_APS_FSMCO, value16);\n\n\t \n \n \n\n\trtw_write8(padapter, REG_CR, 0x00);\n\t \n\tvalue16 = rtw_read16(padapter, REG_CR);\n\tvalue16 |= (\n\t\tHCI_TXDMA_EN |\n\t\tHCI_RXDMA_EN |\n\t\tTXDMA_EN |\n\t\tRXDMA_EN |\n\t\tPROTOCOL_EN |\n\t\tSCHEDULE_EN |\n\t\tENSEC |\n\t\tCALTMR_EN\n\t);\n\trtw_write16(padapter, REG_CR, value16);\n\n\thal_btcoex_PowerOnSetting(padapter);\n\n\t \n\t \n\t \n\t \n\tvalue16 = rtw_read16(padapter, REG_PWR_DATA);\n\t \n\tvalue16 |= BIT(11);  \n\trtw_write16(padapter, REG_PWR_DATA, value16);\n\n\tvalue32 = rtw_read32(padapter, REG_LEDCFG0);\n\tvalue32 |= BIT(23);  \n\trtw_write32(padapter, REG_LEDCFG0, value32);\n\n\tvalue8 = rtw_read8(padapter, REG_PAD_CTRL1_8723B);\n\tvalue8 &= ~BIT(0);  \n\trtw_write8(padapter, REG_PAD_CTRL1_8723B, value8);\n\n\treturn _SUCCESS;\n}\n\n \nstatic void _init_available_page_threshold(struct adapter *padapter, u8 numHQ, u8 numNQ, u8 numLQ, u8 numPubQ)\n{\n\tu16 HQ_threshold, NQ_threshold, LQ_threshold;\n\n\tHQ_threshold = (numPubQ + numHQ + 1) >> 1;\n\tHQ_threshold |= (HQ_threshold << 8);\n\n\tNQ_threshold = (numPubQ + numNQ + 1) >> 1;\n\tNQ_threshold |= (NQ_threshold << 8);\n\n\tLQ_threshold = (numPubQ + numLQ + 1) >> 1;\n\tLQ_threshold |= (LQ_threshold << 8);\n\n\trtw_write16(padapter, 0x218, HQ_threshold);\n\trtw_write16(padapter, 0x21A, NQ_threshold);\n\trtw_write16(padapter, 0x21C, LQ_threshold);\n}\n\nstatic void _InitQueueReservedPage(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\tu32 numHQ = 0;\n\tu32 numLQ = 0;\n\tu32 numNQ = 0;\n\tu32 numPubQ;\n\tu32 value32;\n\tu8 value8;\n\tbool bWiFiConfig\t= pregistrypriv->wifi_spec;\n\n\tif (pHalData->OutEpQueueSel & TX_SELE_HQ)\n\t\tnumHQ = bWiFiConfig ? WMM_NORMAL_PAGE_NUM_HPQ_8723B : NORMAL_PAGE_NUM_HPQ_8723B;\n\n\tif (pHalData->OutEpQueueSel & TX_SELE_LQ)\n\t\tnumLQ = bWiFiConfig ? WMM_NORMAL_PAGE_NUM_LPQ_8723B : NORMAL_PAGE_NUM_LPQ_8723B;\n\n\t \n\tif (pHalData->OutEpQueueSel & TX_SELE_NQ)\n\t\tnumNQ = bWiFiConfig ? WMM_NORMAL_PAGE_NUM_NPQ_8723B : NORMAL_PAGE_NUM_NPQ_8723B;\n\n\tnumPubQ = TX_TOTAL_PAGE_NUMBER_8723B - numHQ - numLQ - numNQ;\n\n\tvalue8 = (u8)_NPQ(numNQ);\n\trtw_write8(padapter, REG_RQPN_NPQ, value8);\n\n\t \n\tvalue32 = _HPQ(numHQ) | _LPQ(numLQ) | _PUBQ(numPubQ) | LD_RQPN;\n\trtw_write32(padapter, REG_RQPN, value32);\n\n\trtw_hal_set_sdio_tx_max_length(padapter, numHQ, numNQ, numLQ, numPubQ);\n\n\t_init_available_page_threshold(padapter, numHQ, numNQ, numLQ, numPubQ);\n}\n\nstatic void _InitTxBufferBoundary(struct adapter *padapter)\n{\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\n\t \n\tu8 txpktbuf_bndy;\n\n\tif (!pregistrypriv->wifi_spec) {\n\t\ttxpktbuf_bndy = TX_PAGE_BOUNDARY_8723B;\n\t} else {\n\t\t \n\t\ttxpktbuf_bndy = WMM_NORMAL_TX_PAGE_BOUNDARY_8723B;\n\t}\n\n\trtw_write8(padapter, REG_TXPKTBUF_BCNQ_BDNY_8723B, txpktbuf_bndy);\n\trtw_write8(padapter, REG_TXPKTBUF_MGQ_BDNY_8723B, txpktbuf_bndy);\n\trtw_write8(padapter, REG_TXPKTBUF_WMAC_LBK_BF_HD_8723B, txpktbuf_bndy);\n\trtw_write8(padapter, REG_TRXFF_BNDY, txpktbuf_bndy);\n\trtw_write8(padapter, REG_TDECTRL + 1, txpktbuf_bndy);\n}\n\nstatic void _InitNormalChipRegPriority(\n\tstruct adapter *Adapter,\n\tu16 beQ,\n\tu16 bkQ,\n\tu16 viQ,\n\tu16 voQ,\n\tu16 mgtQ,\n\tu16 hiQ\n)\n{\n\tu16 value16 = (rtw_read16(Adapter, REG_TRXDMA_CTRL) & 0x7);\n\n\tvalue16 |=\n\t\t_TXDMA_BEQ_MAP(beQ)  |\n\t\t_TXDMA_BKQ_MAP(bkQ)  |\n\t\t_TXDMA_VIQ_MAP(viQ)  |\n\t\t_TXDMA_VOQ_MAP(voQ)  |\n\t\t_TXDMA_MGQ_MAP(mgtQ) |\n\t\t_TXDMA_HIQ_MAP(hiQ);\n\n\trtw_write16(Adapter, REG_TRXDMA_CTRL, value16);\n}\n\nstatic void _InitNormalChipOneOutEpPriority(struct adapter *Adapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\n\n\tu16 value = 0;\n\tswitch (pHalData->OutEpQueueSel) {\n\tcase TX_SELE_HQ:\n\t\tvalue = QUEUE_HIGH;\n\t\tbreak;\n\tcase TX_SELE_LQ:\n\t\tvalue = QUEUE_LOW;\n\t\tbreak;\n\tcase TX_SELE_NQ:\n\t\tvalue = QUEUE_NORMAL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t_InitNormalChipRegPriority(\n\t\tAdapter, value, value, value, value, value, value\n\t);\n\n}\n\nstatic void _InitNormalChipTwoOutEpPriority(struct adapter *Adapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\n\tstruct registry_priv *pregistrypriv = &Adapter->registrypriv;\n\tu16 beQ, bkQ, viQ, voQ, mgtQ, hiQ;\n\n\n\tu16 valueHi = 0;\n\tu16 valueLow = 0;\n\n\tswitch (pHalData->OutEpQueueSel) {\n\tcase (TX_SELE_HQ | TX_SELE_LQ):\n\t\tvalueHi = QUEUE_HIGH;\n\t\tvalueLow = QUEUE_LOW;\n\t\tbreak;\n\tcase (TX_SELE_NQ | TX_SELE_LQ):\n\t\tvalueHi = QUEUE_NORMAL;\n\t\tvalueLow = QUEUE_LOW;\n\t\tbreak;\n\tcase (TX_SELE_HQ | TX_SELE_NQ):\n\t\tvalueHi = QUEUE_HIGH;\n\t\tvalueLow = QUEUE_NORMAL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!pregistrypriv->wifi_spec) {\n\t\tbeQ = valueLow;\n\t\tbkQ = valueLow;\n\t\tviQ = valueHi;\n\t\tvoQ = valueHi;\n\t\tmgtQ = valueHi;\n\t\thiQ = valueHi;\n\t} else {\n\t\t \n\t\tbeQ = valueLow;\n\t\tbkQ = valueHi;\n\t\tviQ = valueHi;\n\t\tvoQ = valueLow;\n\t\tmgtQ = valueHi;\n\t\thiQ = valueHi;\n\t}\n\n\t_InitNormalChipRegPriority(Adapter, beQ, bkQ, viQ, voQ, mgtQ, hiQ);\n\n}\n\nstatic void _InitNormalChipThreeOutEpPriority(struct adapter *padapter)\n{\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\tu16 beQ, bkQ, viQ, voQ, mgtQ, hiQ;\n\n\tif (!pregistrypriv->wifi_spec) {\n\t\t \n\t\tbeQ = QUEUE_LOW;\n\t\tbkQ = QUEUE_LOW;\n\t\tviQ = QUEUE_NORMAL;\n\t\tvoQ = QUEUE_HIGH;\n\t\tmgtQ = QUEUE_HIGH;\n\t\thiQ = QUEUE_HIGH;\n\t} else {\n\t\t \n\t\tbeQ = QUEUE_LOW;\n\t\tbkQ = QUEUE_NORMAL;\n\t\tviQ = QUEUE_NORMAL;\n\t\tvoQ = QUEUE_HIGH;\n\t\tmgtQ = QUEUE_HIGH;\n\t\thiQ = QUEUE_HIGH;\n\t}\n\t_InitNormalChipRegPriority(padapter, beQ, bkQ, viQ, voQ, mgtQ, hiQ);\n}\n\nstatic void _InitQueuePriority(struct adapter *Adapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\n\n\tswitch (pHalData->OutEpNumber) {\n\tcase 1:\n\t\t_InitNormalChipOneOutEpPriority(Adapter);\n\t\tbreak;\n\tcase 2:\n\t\t_InitNormalChipTwoOutEpPriority(Adapter);\n\t\tbreak;\n\tcase 3:\n\t\t_InitNormalChipThreeOutEpPriority(Adapter);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\n}\n\nstatic void _InitPageBoundary(struct adapter *padapter)\n{\n\t \n\tu16 rxff_bndy = RX_DMA_BOUNDARY_8723B;\n\n\trtw_write16(padapter, (REG_TRXFF_BNDY + 2), rxff_bndy);\n}\n\nstatic void _InitTransferPageSize(struct adapter *padapter)\n{\n\t \n\n\tu8 value8;\n\tvalue8 = _PSRX(PBP_128) | _PSTX(PBP_128);\n\trtw_write8(padapter, REG_PBP, value8);\n}\n\nstatic void _InitDriverInfoSize(struct adapter *padapter, u8 drvInfoSize)\n{\n\trtw_write8(padapter, REG_RX_DRVINFO_SZ, drvInfoSize);\n}\n\nstatic void _InitNetworkType(struct adapter *padapter)\n{\n\tu32 value32;\n\n\tvalue32 = rtw_read32(padapter, REG_CR);\n\n\t \n \n\tvalue32 = (value32 & ~MASK_NETTYPE) | _NETTYPE(NT_LINK_AP);\n\n\trtw_write32(padapter, REG_CR, value32);\n}\n\nstatic void _InitWMACSetting(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData;\n\tu16 value16;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\n\tpHalData->ReceiveConfig = 0;\n\tpHalData->ReceiveConfig |= RCR_APM | RCR_AM | RCR_AB;\n\tpHalData->ReceiveConfig |= RCR_CBSSID_DATA | RCR_CBSSID_BCN | RCR_AMF;\n\tpHalData->ReceiveConfig |= RCR_HTC_LOC_CTRL;\n\tpHalData->ReceiveConfig |= RCR_APP_PHYST_RXFF | RCR_APP_ICV | RCR_APP_MIC;\n\trtw_write32(padapter, REG_RCR, pHalData->ReceiveConfig);\n\n\t \n\trtw_write32(padapter, REG_MAR, 0xFFFFFFFF);\n\trtw_write32(padapter, REG_MAR + 4, 0xFFFFFFFF);\n\n\t \n\tvalue16 = 0xFFFF;\n\trtw_write16(padapter, REG_RXFLTMAP2, value16);\n\n\t \n\t \n\t \n\tvalue16 = 0x400;\n\trtw_write16(padapter, REG_RXFLTMAP1, value16);\n\n\t \n\tvalue16 = 0xFFFF;\n\trtw_write16(padapter, REG_RXFLTMAP0, value16);\n}\n\nstatic void _InitAdaptiveCtrl(struct adapter *padapter)\n{\n\tu16 value16;\n\tu32 value32;\n\n\t \n\tvalue32 = rtw_read32(padapter, REG_RRSR);\n\tvalue32 &= ~RATE_BITMAP_ALL;\n\tvalue32 |= RATE_RRSR_CCK_ONLY_1M;\n\trtw_write32(padapter, REG_RRSR, value32);\n\n\t \n\t \n\n\t \n\tvalue16 = _SPEC_SIFS_CCK(0x10) | _SPEC_SIFS_OFDM(0x10);\n\trtw_write16(padapter, REG_SPEC_SIFS, value16);\n\n\t \n\tvalue16 = _LRL(0x30) | _SRL(0x30);\n\trtw_write16(padapter, REG_RL, value16);\n}\n\nstatic void _InitEDCA(struct adapter *padapter)\n{\n\t \n\trtw_write16(padapter, REG_SPEC_SIFS, 0x100a);\n\trtw_write16(padapter, REG_MAC_SPEC_SIFS, 0x100a);\n\n\t \n\trtw_write16(padapter, REG_SIFS_CTX, 0x100a);\n\n\t \n\trtw_write16(padapter, REG_SIFS_TRX, 0x100a);\n\n\t \n\trtw_write32(padapter, REG_EDCA_BE_PARAM, 0x005EA42B);\n\trtw_write32(padapter, REG_EDCA_BK_PARAM, 0x0000A44F);\n\trtw_write32(padapter, REG_EDCA_VI_PARAM, 0x005EA324);\n\trtw_write32(padapter, REG_EDCA_VO_PARAM, 0x002FA226);\n}\n\nstatic void _InitRetryFunction(struct adapter *padapter)\n{\n\tu8 value8;\n\n\tvalue8 = rtw_read8(padapter, REG_FWHW_TXQ_CTRL);\n\tvalue8 |= EN_AMPDU_RTY_NEW;\n\trtw_write8(padapter, REG_FWHW_TXQ_CTRL, value8);\n\n\t \n\trtw_write8(padapter, REG_ACKTO, 0x40);\n}\n\nstatic void HalRxAggr8723BSdio(struct adapter *padapter)\n{\n\tu8 valueDMATimeout;\n\tu8 valueDMAPageCount;\n\n\tvalueDMATimeout = 0x06;\n\tvalueDMAPageCount = 0x06;\n\n\trtw_write8(padapter, REG_RXDMA_AGG_PG_TH + 1, valueDMATimeout);\n\trtw_write8(padapter, REG_RXDMA_AGG_PG_TH, valueDMAPageCount);\n}\n\nstatic void sdio_AggSettingRxUpdate(struct adapter *padapter)\n{\n\tu8 valueDMA;\n\tu8 valueRxAggCtrl = 0;\n\tu8 aggBurstNum = 3;   \n\tu8 aggBurstSize = 0;   \n\n\tvalueDMA = rtw_read8(padapter, REG_TRXDMA_CTRL);\n\tvalueDMA |= RXDMA_AGG_EN;\n\trtw_write8(padapter, REG_TRXDMA_CTRL, valueDMA);\n\n\tvalueRxAggCtrl |= RXDMA_AGG_MODE_EN;\n\tvalueRxAggCtrl |= ((aggBurstNum << 2) & 0x0C);\n\tvalueRxAggCtrl |= ((aggBurstSize << 4) & 0x30);\n\trtw_write8(padapter, REG_RXDMA_MODE_CTRL_8723B, valueRxAggCtrl); \n}\n\nstatic void _initSdioAggregationSetting(struct adapter *padapter)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\n\t \n \n\n\t \n\tHalRxAggr8723BSdio(padapter);\n\n\tsdio_AggSettingRxUpdate(padapter);\n\n\t \n\tpHalData->UsbRxHighSpeedMode = false;\n}\n\nstatic void _InitOperationMode(struct adapter *padapter)\n{\n\tstruct mlme_ext_priv *pmlmeext;\n\tu8 regBwOpMode = 0;\n\n\tpmlmeext = &padapter->mlmeextpriv;\n\n\t \n\t \n\t \n\t \n\tswitch (pmlmeext->cur_wireless_mode) {\n\tcase WIRELESS_MODE_B:\n\t\tregBwOpMode = BW_OPMODE_20MHZ;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\t\tregBwOpMode = BW_OPMODE_20MHZ;\n\t\tbreak;\n\tcase WIRELESS_MODE_AUTO:\n\t\tregBwOpMode = BW_OPMODE_20MHZ;\n\t\tbreak;\n\tcase WIRELESS_MODE_N_24G:\n\t\t \n\t\t \n\t\tregBwOpMode = BW_OPMODE_20MHZ;\n\t\tbreak;\n\n\tdefault:  \n\t\tbreak;\n\t}\n\n\trtw_write8(padapter, REG_BWOPMODE, regBwOpMode);\n\n}\n\nstatic void _InitInterrupt(struct adapter *padapter)\n{\n\t \n\trtw_write32(padapter, REG_HISR, 0);\n\n\t \n\trtw_write32(padapter, REG_HIMR, 0);\n\n\t \n\t \n\t \n\tInitInterrupt8723BSdio(padapter);\n\n\t \n\t \n\t \n\tInitSysInterrupt8723BSdio(padapter);\n}\n\nstatic void _InitRFType(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\n\tpHalData->rf_chip\t= RF_6052;\n}\n\nstatic void _RfPowerSave(struct adapter *padapter)\n{\n \n}\n\n \n \n \nstatic bool HalDetectPwrDownMode(struct adapter *Adapter)\n{\n\tu8 tmpvalue;\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\n\tstruct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(Adapter);\n\n\n\tEFUSE_ShadowRead(Adapter, 1, 0x7B , (u32 *)&tmpvalue);\n\n\t \n\tif (tmpvalue & BIT4 && pwrctrlpriv->reg_pdnmode)\n\t\tpHalData->pwrdown = true;\n\telse\n\t\tpHalData->pwrdown = false;\n\n\treturn pHalData->pwrdown;\n}\t \n\nstatic u32 rtl8723bs_hal_init(struct adapter *padapter)\n{\n\ts32 ret;\n\tstruct hal_com_data *pHalData;\n\tstruct pwrctrl_priv *pwrctrlpriv;\n\tu32 NavUpper = WiFiNavUpperUs;\n\tu8 u1bTmp;\n\n\tpHalData = GET_HAL_DATA(padapter);\n\tpwrctrlpriv = adapter_to_pwrctl(padapter);\n\n\tif (\n\t\tadapter_to_pwrctl(padapter)->bips_processing == true &&\n\t\tadapter_to_pwrctl(padapter)->pre_ips_type == 0\n\t) {\n\t\tunsigned long start_time;\n\t\tu8 cpwm_orig, cpwm_now;\n\t\tu8 val8, bMacPwrCtrlOn = true;\n\n\t\t \n\t\tcpwm_orig = 0;\n\t\trtw_hal_get_hwreg(padapter, HW_VAR_CPWM, &cpwm_orig);\n\n\t\t \n\t\tval8 = rtw_read8(padapter, SDIO_LOCAL_BASE | SDIO_REG_HRPWM1);\n\t\tval8 &= 0x80;\n\t\tval8 += 0x80;\n\t\tval8 |= BIT(6);\n\t\trtw_write8(padapter, SDIO_LOCAL_BASE | SDIO_REG_HRPWM1, val8);\n\t\tadapter_to_pwrctl(padapter)->tog = (val8 + 0x80) & 0x80;\n\n\t\t \n\t\tstart_time = jiffies;\n\t\tdo {\n\n\t\t\tmdelay(1);\n\n\t\t\trtw_hal_get_hwreg(padapter, HW_VAR_CPWM, &cpwm_now);\n\t\t\tif ((cpwm_orig ^ cpwm_now) & 0x80)\n\t\t\t\tbreak;\n\n\t\t\tif (jiffies_to_msecs(jiffies - start_time) > 100)\n\t\t\t\tbreak;\n\n\t\t} while (1);\n\n\t\trtl8723b_set_FwPwrModeInIPS_cmd(padapter, 0);\n\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);\n\n\t\thal_btcoex_InitHwConfig(padapter, false);\n\n\t\treturn _SUCCESS;\n\t}\n\n\t \n \n\n\tret = _InitPowerOn_8723BS(padapter);\n\tif (ret == _FAIL)\n\t\treturn _FAIL;\n\n\trtw_write8(padapter, REG_EARLY_MODE_CONTROL, 0);\n\n\tret = rtl8723b_FirmwareDownload(padapter, false);\n\tif (ret != _SUCCESS) {\n\t\tpadapter->bFWReady = false;\n\t\tpHalData->fw_ractrl = false;\n\t\treturn ret;\n\t} else {\n\t\tpadapter->bFWReady = true;\n\t\tpHalData->fw_ractrl = true;\n\t}\n\n\trtl8723b_InitializeFirmwareVars(padapter);\n\n \n\n\tif (pwrctrlpriv->reg_rfoff)\n\t\tpwrctrlpriv->rf_pwrstate = rf_off;\n\n\t \n\t \n\tHalDetectPwrDownMode(padapter);\n\n\t \n\t_InitRFType(padapter);\n\n\t \n\t \n\tpHalData->CurrentChannel = 6;\n\n\tret = PHY_MACConfig8723B(padapter);\n\tif (ret != _SUCCESS)\n\t\treturn ret;\n\t \n\t \n\t \n\tret = PHY_BBConfig8723B(padapter);\n\tif (ret != _SUCCESS)\n\t\treturn ret;\n\n\t \n\t \n\t \n\t{\n\t\tret = PHY_RFConfig8723B(padapter);\n\t\tif (ret != _SUCCESS)\n\t\t\treturn ret;\n\t}\n\n\t \n\t \n\t \n\tpHalData->RfRegChnlVal[0] =\n\t\tPHY_QueryRFReg(padapter, (enum rf_path)0, RF_CHNLBW, bRFRegOffsetMask);\n\tpHalData->RfRegChnlVal[1] =\n\t\tPHY_QueryRFReg(padapter, (enum rf_path)1, RF_CHNLBW, bRFRegOffsetMask);\n\n\n\t \n\t_InitQueueReservedPage(padapter);\n\t_InitTxBufferBoundary(padapter);\n\n\t \n\tret = rtl8723b_InitLLTTable(padapter);\n\tif (ret != _SUCCESS)\n\t\treturn _FAIL;\n\n\t \n\t_InitQueuePriority(padapter);\n\t_InitPageBoundary(padapter);\n\t_InitTransferPageSize(padapter);\n\n\t \n\t_InitDriverInfoSize(padapter, DRVINFO_SZ);\n\thal_init_macaddr(padapter);\n\t_InitNetworkType(padapter);\n\t_InitWMACSetting(padapter);\n\t_InitAdaptiveCtrl(padapter);\n\t_InitEDCA(padapter);\n\t_InitRetryFunction(padapter);\n\t_initSdioAggregationSetting(padapter);\n\t_InitOperationMode(padapter);\n\trtl8723b_InitBeaconParameters(padapter);\n\t_InitInterrupt(padapter);\n\t_InitBurstPktLen_8723BS(padapter);\n\n\t \n\trtw_write8(padapter, REG_SECONDARY_CCA_CTRL_8723B, 0x3);\t \n\trtw_write8(padapter, 0x976, 0);\t \n\n\trtw_write16(padapter, REG_PKT_VO_VI_LIFE_TIME, 0x0400);\t \n\trtw_write16(padapter, REG_PKT_BE_BK_LIFE_TIME, 0x0400);\t \n\n\tinvalidate_cam_all(padapter);\n\n\trtw_hal_set_chnl_bw(padapter, padapter->registrypriv.channel,\n\t\tCHANNEL_WIDTH_20, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HAL_PRIME_CHNL_OFFSET_DONT_CARE);\n\n\t \n\t \n \n \n\n\trtl8723b_InitAntenna_Selection(padapter);\n\n\t \n\t \n\t \n\t \n\trtw_write32(padapter, REG_BAR_MODE_CTRL, 0x0201ffff);\n\n\t \n\t \n\trtw_write8(padapter, REG_HWSEQ_CTRL, 0xFF);\n\n\n\t \n\t \n\t \n\t \n\trtw_write32(padapter, SDIO_LOCAL_BASE | SDIO_REG_TX_CTRL, 0);\n\n\t_RfPowerSave(padapter);\n\n\n\trtl8723b_InitHalDm(padapter);\n\n\t \n\t \n\t \n\tHalQueryTxBufferStatus8723BSdio(padapter);\n\tHalQueryTxOQTBufferStatus8723BSdio(padapter);\n\tpHalData->SdioTxOQTMaxFreeSpace = pHalData->SdioTxOQTFreeSpace;\n\n\t \n\tu1bTmp = rtw_read8(padapter, REG_CR);\n\tu1bTmp |= (MACTXEN | MACRXEN);\n\trtw_write8(padapter, REG_CR, u1bTmp);\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_NAV_UPPER, (u8 *)&NavUpper);\n\n\t \n\trtw_write32(padapter, REG_FWHW_TXQ_CTRL, rtw_read32(padapter, REG_FWHW_TXQ_CTRL) | BIT(12));\n\n \n\n\t{\n\t\tpwrctrlpriv->rf_pwrstate = rf_on;\n\n\t\tif (pwrctrlpriv->rf_pwrstate == rf_on) {\n\t\t\tstruct pwrctrl_priv *pwrpriv;\n\t\t\tunsigned long start_time;\n\t\t\tu8 restore_iqk_rst;\n\t\t\tu8 b2Ant;\n\t\t\tu8 h2cCmdBuf;\n\n\t\t\tpwrpriv = adapter_to_pwrctl(padapter);\n\n\t\t\tPHY_LCCalibrate_8723B(&pHalData->odmpriv);\n\n\t\t\t \n\t\t\th2cCmdBuf = 1;\n\t\t\tFillH2CCmd8723B(padapter, H2C_8723B_BT_WLAN_CALIBRATION, 1, &h2cCmdBuf);\n\n\t\t\tstart_time = jiffies;\n\t\t\tdo {\n\t\t\t\tif (rtw_read8(padapter, 0x1e7) & 0x01)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmsleep(50);\n\t\t\t} while (jiffies_to_msecs(jiffies - start_time) <= 400);\n\n\t\t\thal_btcoex_IQKNotify(padapter, true);\n\n\t\t\trestore_iqk_rst = pwrpriv->bips_processing;\n\t\t\tb2Ant = pHalData->EEPROMBluetoothAntNum == Ant_x2;\n\t\t\tPHY_IQCalibrate_8723B(padapter, false, restore_iqk_rst, b2Ant, pHalData->ant_path);\n\t\t\tpHalData->odmpriv.RFCalibrateInfo.bIQKInitialized = true;\n\n\t\t\thal_btcoex_IQKNotify(padapter, false);\n\n\t\t\t \n\t\t\th2cCmdBuf = 0;\n\t\t\tFillH2CCmd8723B(padapter, H2C_8723B_BT_WLAN_CALIBRATION, 1, &h2cCmdBuf);\n\n\t\t\tODM_TXPowerTrackingCheck(&pHalData->odmpriv);\n\t\t}\n\t}\n\n\t \n\thal_btcoex_InitHwConfig(padapter, false);\n\n\treturn _SUCCESS;\n}\n\n \n \n \n \n \n \nstatic void CardDisableRTL8723BSdio(struct adapter *padapter)\n{\n\tu8 u1bTmp;\n\tu8 bMacPwrCtrlOn;\n\n\t \n\tHalPwrSeqCmdParsing(padapter, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, rtl8723B_enter_lps_flow);\n\n\t \n\n\tu1bTmp = rtw_read8(padapter, REG_MCUFWDL);\n\tif ((u1bTmp & RAM_DL_SEL) && padapter->bFWReady)  \n\t\trtl8723b_FirmwareSelfReset(padapter);\n\n\t \n\tu1bTmp = rtw_read8(padapter, REG_SYS_FUNC_EN + 1);\n\tu1bTmp &= ~BIT(2);\t \n\trtw_write8(padapter, REG_SYS_FUNC_EN + 1, u1bTmp);\n\n\t \n\t \n\trtw_write8(padapter, REG_MCUFWDL, 0);\n\n\t \n\tu1bTmp = rtw_read8(padapter, REG_RSV_CTRL + 1);\n\tu1bTmp &= ~BIT(0);\n\trtw_write8(padapter, REG_RSV_CTRL + 1, u1bTmp);\n\tu1bTmp = rtw_read8(padapter, REG_RSV_CTRL + 1);\n\tu1bTmp |= BIT(0);\n\trtw_write8(padapter, REG_RSV_CTRL+1, u1bTmp);\n\n\t \n\n\tbMacPwrCtrlOn = false;\t \n\trtw_hal_set_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);\n\tHalPwrSeqCmdParsing(padapter, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, rtl8723B_card_disable_flow);\n}\n\nstatic u32 rtl8723bs_hal_deinit(struct adapter *padapter)\n{\n\tstruct dvobj_priv *psdpriv = padapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\n\tif (padapter->hw_init_completed) {\n\t\tif (adapter_to_pwrctl(padapter)->bips_processing) {\n\t\t\tif (padapter->netif_up) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tu8 val8 = 0;\n\n\t\t\t\trtl8723b_set_FwPwrModeInIPS_cmd(padapter, 0x3);\n\t\t\t\t \n\t\t\t\tdo {\n\t\t\t\t\tval8 = rtw_read8(padapter, REG_HMETFR);\n\t\t\t\t\tcnt++;\n\t\t\t\t\tmdelay(10);\n\t\t\t\t} while (cnt < 100 && (val8 != 0));\n\t\t\t\t \n\t\t\t\tif (val8 == 0) {\n\t\t\t\t\t \n\t\t\t\t\tval8 = rtw_read8(padapter, SDIO_LOCAL_BASE | SDIO_REG_HRPWM1);\n\t\t\t\t\tval8 += 0x80;\n\t\t\t\t\tval8 |= BIT(0);\n\t\t\t\t\trtw_write8(padapter, SDIO_LOCAL_BASE | SDIO_REG_HRPWM1, val8);\n\t\t\t\t\tadapter_to_pwrctl(padapter)->tog = (val8 + 0x80) & 0x80;\n\t\t\t\t\tcnt = val8 = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tval8 = rtw_read8(padapter, REG_CR);\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tmdelay(10);\n\t\t\t\t\t} while (cnt < 100 && (val8 != 0xEA));\n\t\t\t\t}\n\n\t\t\t\tadapter_to_pwrctl(padapter)->pre_ips_type = 0;\n\n\t\t\t} else {\n\t\t\t\tpdbgpriv->dbg_carddisable_cnt++;\n\t\t\t\tCardDisableRTL8723BSdio(padapter);\n\n\t\t\t\tadapter_to_pwrctl(padapter)->pre_ips_type = 1;\n\t\t\t}\n\n\t\t} else {\n\t\t\tpdbgpriv->dbg_carddisable_cnt++;\n\t\t\tCardDisableRTL8723BSdio(padapter);\n\t\t}\n\t} else\n\t\tpdbgpriv->dbg_deinit_fail_cnt++;\n\n\treturn _SUCCESS;\n}\n\nstatic u32 rtl8723bs_inirp_init(struct adapter *padapter)\n{\n\treturn _SUCCESS;\n}\n\nstatic u32 rtl8723bs_inirp_deinit(struct adapter *padapter)\n{\n\treturn _SUCCESS;\n}\n\nstatic void rtl8723bs_init_default_value(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\n\trtl8723b_init_default_value(padapter);\n\n\t \n\tpHalData->SdioRxFIFOCnt = 0;\n}\n\nstatic void rtl8723bs_interface_configure(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tstruct dvobj_priv *pdvobjpriv = adapter_to_dvobj(padapter);\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\tbool bWiFiConfig = pregistrypriv->wifi_spec;\n\n\n\tpdvobjpriv->RtOutPipe[0] = WLAN_TX_HIQ_DEVICE_ID;\n\tpdvobjpriv->RtOutPipe[1] = WLAN_TX_MIQ_DEVICE_ID;\n\tpdvobjpriv->RtOutPipe[2] = WLAN_TX_LOQ_DEVICE_ID;\n\n\tif (bWiFiConfig)\n\t\tpHalData->OutEpNumber = 2;\n\telse\n\t\tpHalData->OutEpNumber = SDIO_MAX_TX_QUEUE;\n\n\tswitch (pHalData->OutEpNumber) {\n\tcase 3:\n\t\tpHalData->OutEpQueueSel = TX_SELE_HQ | TX_SELE_LQ | TX_SELE_NQ;\n\t\tbreak;\n\tcase 2:\n\t\tpHalData->OutEpQueueSel = TX_SELE_HQ | TX_SELE_NQ;\n\t\tbreak;\n\tcase 1:\n\t\tpHalData->OutEpQueueSel = TX_SELE_HQ;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tHal_MappingOutPipe(padapter, pHalData->OutEpNumber);\n}\n\n \n \n \n \n \n \n \n \n \nstatic void _EfuseCellSel(struct adapter *padapter)\n{\n\tu32 value32;\n\n\tvalue32 = rtw_read32(padapter, EFUSE_TEST);\n\tvalue32 = (value32 & ~EFUSE_SEL_MASK) | EFUSE_SEL(EFUSE_WIFI_SEL_0);\n\trtw_write32(padapter, EFUSE_TEST, value32);\n}\n\nstatic void _ReadRFType(struct adapter *Adapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\n\n\tpHalData->rf_chip = RF_6052;\n}\n\n\nstatic void Hal_EfuseParseMACAddr_8723BS(\n\tstruct adapter *padapter, u8 *hwinfo, bool AutoLoadFail\n)\n{\n\tu16 i;\n\tu8 sMacAddr[6] = {0x00, 0xE0, 0x4C, 0xb7, 0x23, 0x00};\n\tstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\n\n\tif (AutoLoadFail) {\n \n\t\tfor (i = 0; i < 6; i++)\n\t\t\tpEEPROM->mac_addr[i] = sMacAddr[i];\n\t} else {\n\t\t \n\t\tmemcpy(pEEPROM->mac_addr, &hwinfo[EEPROM_MAC_ADDR_8723BS], ETH_ALEN);\n\t}\n}\n\nstatic void Hal_EfuseParseBoardType_8723BS(\n\tstruct adapter *padapter, u8 *hwinfo, bool AutoLoadFail\n)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\n\tif (!AutoLoadFail) {\n\t\tpHalData->BoardType = (hwinfo[EEPROM_RF_BOARD_OPTION_8723B] & 0xE0) >> 5;\n\t\tif (pHalData->BoardType == 0xFF)\n\t\t\tpHalData->BoardType = (EEPROM_DEFAULT_BOARD_OPTION & 0xE0) >> 5;\n\t} else\n\t\tpHalData->BoardType = 0;\n}\n\nstatic void _ReadEfuseInfo8723BS(struct adapter *padapter)\n{\n\tstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\n\tu8 *hwinfo = NULL;\n\n\t \n\t \n\t \n\n\thwinfo = pEEPROM->efuse_eeprom_data;\n\n\tHal_InitPGData(padapter, hwinfo);\n\n\tHal_EfuseParseIDCode(padapter, hwinfo);\n\tHal_EfuseParseEEPROMVer_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\n\n\tHal_EfuseParseMACAddr_8723BS(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\n\n\tHal_EfuseParseTxPowerInfo_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\n\tHal_EfuseParseBoardType_8723BS(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\n\n\t \n\t \n\t \n\tHal_EfuseParsePackageType_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\n\tHal_EfuseParseBTCoexistInfo_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\n\tHal_EfuseParseChnlPlan_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\n\tHal_EfuseParseXtal_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\n\tHal_EfuseParseThermalMeter_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\n\tHal_EfuseParseAntennaDiversity_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\n\tHal_EfuseParseCustomerID_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\n\n\tHal_EfuseParseVoltage_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\n\n\tHal_ReadRFGainOffset(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\n}\n\nstatic void _ReadPROMContent(struct adapter *padapter)\n{\n\tstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\n\tu8 \teeValue;\n\n\teeValue = rtw_read8(padapter, REG_9346CR);\n\t \n\tpEEPROM->EepromOrEfuse = (eeValue & BOOT_FROM_EEPROM) ? true : false;\n\tpEEPROM->bautoload_fail_flag = (eeValue & EEPROM_EN) ? false : true;\n\n \n\n\t_ReadEfuseInfo8723BS(padapter);\n}\n\nstatic void _InitOtherVariable(struct adapter *Adapter)\n{\n}\n\n \n \n \n \n \n \n \n \nstatic s32 _ReadAdapterInfo8723BS(struct adapter *padapter)\n{\n\tu8 val8;\n\n\t \n\tif (!padapter->hw_init_completed)\n\t\t_InitPowerOn_8723BS(padapter);\n\n\n\tval8 = rtw_read8(padapter, 0x4e);\n\tval8 |= BIT(6);\n\trtw_write8(padapter, 0x4e, val8);\n\n\t_EfuseCellSel(padapter);\n\t_ReadRFType(padapter);\n\t_ReadPROMContent(padapter);\n\t_InitOtherVariable(padapter);\n\n\tif (!padapter->hw_init_completed) {\n\t\trtw_write8(padapter, 0x67, 0x00);  \n\t\tCardDisableRTL8723BSdio(padapter); \n\t}\n\n\treturn _SUCCESS;\n}\n\nstatic void ReadAdapterInfo8723BS(struct adapter *padapter)\n{\n\t \n\tpadapter->EepromAddressSize = GetEEPROMSize8723B(padapter);\n\n\t_ReadAdapterInfo8723BS(padapter);\n}\n\n \nstatic void SetHwReg8723BS(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tu8 val8;\n\n\tswitch (variable) {\n\tcase HW_VAR_SET_RPWM:\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t{\n\t\t\tval8 = *val;\n\t\t\tval8 &= 0xC1;\n\t\t\trtw_write8(padapter, SDIO_LOCAL_BASE | SDIO_REG_HRPWM1, val8);\n\t\t}\n\t\tbreak;\n\tcase HW_VAR_SET_REQ_FW_PS:\n\t\t{\n\t\t\tu8 req_fw_ps = 0;\n\t\t\treq_fw_ps = rtw_read8(padapter, 0x8f);\n\t\t\treq_fw_ps |= 0x10;\n\t\t\trtw_write8(padapter, 0x8f, req_fw_ps);\n\t\t}\n\t\tbreak;\n\tcase HW_VAR_RXDMA_AGG_PG_TH:\n\t\tval8 = *val;\n\t\tbreak;\n\n\tcase HW_VAR_DM_IN_LPS:\n\t\trtl8723b_hal_dm_in_lps(padapter);\n\t\tbreak;\n\tdefault:\n\t\tSetHwReg8723B(padapter, variable, val);\n\t\tbreak;\n\t}\n}\n\n \nstatic void GetHwReg8723BS(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tswitch (variable) {\n\tcase HW_VAR_CPWM:\n\t\t*val = rtw_read8(padapter, SDIO_LOCAL_BASE | SDIO_REG_HCPWM1_8723B);\n\t\tbreak;\n\n\tcase HW_VAR_FW_PS_STATE:\n\t\t{\n\t\t\t \n\t\t\t*((u16 *)val) = rtw_read16(padapter, 0x88);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tGetHwReg8723B(padapter, variable, val);\n\t\tbreak;\n\t}\n}\n\nstatic void SetHwRegWithBuf8723B(struct adapter *padapter, u8 variable, u8 *pbuf, int len)\n{\n\tswitch (variable) {\n\tcase HW_VAR_C2H_HANDLE:\n\t\tC2HPacketHandler_8723B(padapter, pbuf, len);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \n \n \n \nstatic u8 GetHalDefVar8723BSDIO(\n\tstruct adapter *Adapter, enum hal_def_variable eVariable, void *pValue\n)\n{\n\tu8 \tbResult = _SUCCESS;\n\n\tswitch (eVariable) {\n\tcase HAL_DEF_IS_SUPPORT_ANT_DIV:\n\t\tbreak;\n\tcase HAL_DEF_CURRENT_ANTENNA:\n\t\tbreak;\n\tcase HW_VAR_MAX_RX_AMPDU_FACTOR:\n\t\t \n\t\t \n\t\t*(u32 *)pValue = IEEE80211_HT_MAX_AMPDU_16K;\n\t\tbreak;\n\tdefault:\n\t\tbResult = GetHalDefVar8723B(Adapter, eVariable, pValue);\n\t\tbreak;\n\t}\n\n\treturn bResult;\n}\n\n \n \n \n \nstatic u8 SetHalDefVar8723BSDIO(struct adapter *Adapter,\n\t\t\t\tenum hal_def_variable eVariable, void *pValue)\n{\n\treturn SetHalDefVar8723B(Adapter, eVariable, pValue);\n}\n\nvoid rtl8723bs_set_hal_ops(struct adapter *padapter)\n{\n\tstruct hal_ops *pHalFunc = &padapter->HalFunc;\n\n\trtl8723b_set_hal_ops(pHalFunc);\n\n\tpHalFunc->hal_init = &rtl8723bs_hal_init;\n\tpHalFunc->hal_deinit = &rtl8723bs_hal_deinit;\n\n\tpHalFunc->inirp_init = &rtl8723bs_inirp_init;\n\tpHalFunc->inirp_deinit = &rtl8723bs_inirp_deinit;\n\n\tpHalFunc->init_xmit_priv = &rtl8723bs_init_xmit_priv;\n\tpHalFunc->free_xmit_priv = &rtl8723bs_free_xmit_priv;\n\n\tpHalFunc->init_recv_priv = &rtl8723bs_init_recv_priv;\n\tpHalFunc->free_recv_priv = &rtl8723bs_free_recv_priv;\n\n\tpHalFunc->init_default_value = &rtl8723bs_init_default_value;\n\tpHalFunc->intf_chip_configure = &rtl8723bs_interface_configure;\n\tpHalFunc->read_adapter_info = &ReadAdapterInfo8723BS;\n\n\tpHalFunc->enable_interrupt = &EnableInterrupt8723BSdio;\n\tpHalFunc->disable_interrupt = &DisableInterrupt8723BSdio;\n\tpHalFunc->check_ips_status = &CheckIPSStatus;\n\tpHalFunc->SetHwRegHandler = &SetHwReg8723BS;\n\tpHalFunc->GetHwRegHandler = &GetHwReg8723BS;\n\tpHalFunc->SetHwRegHandlerWithBuf = &SetHwRegWithBuf8723B;\n\tpHalFunc->GetHalDefVarHandler = &GetHalDefVar8723BSDIO;\n\tpHalFunc->SetHalDefVarHandler = &SetHalDefVar8723BSDIO;\n\n\tpHalFunc->hal_xmit = &rtl8723bs_hal_xmit;\n\tpHalFunc->mgnt_xmit = &rtl8723bs_mgnt_xmit;\n\tpHalFunc->hal_xmitframe_enqueue = &rtl8723bs_hal_xmitframe_enqueue;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}