{
  "module_name": "odm_DIG.c",
  "hash_id": "a13827af8ecda35d5ba0348b100d12efd22012a0b4ed45f644f53e61512427f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/hal/odm_DIG.c",
  "human_readable_source": "\n \n\n#include \"odm_precomp.h\"\n\nvoid odm_NHMCounterStatisticsInit(void *pDM_VOID)\n{\n\tstruct dm_odm_t\t*pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\n\t \n\trtw_write16(pDM_Odm->Adapter, ODM_REG_NHM_TIMER_11N+2, 0x2710);\t \n\t \n\trtw_write16(pDM_Odm->Adapter, ODM_REG_NHM_TH9_TH10_11N+2, 0xffff);\t \n\t \n\trtw_write32(pDM_Odm->Adapter, ODM_REG_NHM_TH3_TO_TH0_11N, 0xffffff52);\t \n\trtw_write32(pDM_Odm->Adapter, ODM_REG_NHM_TH7_TO_TH4_11N, 0xffffffff);\t \n\tPHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_FPGA0_IQK_11N, bMaskByte0, 0xff);\t\t \n\tPHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_NHM_TH9_TH10_11N, BIT10|BIT9|BIT8, 0x7);\t \n\tPHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_OFDM_FA_RSTC_11N, BIT7, 0x1);\t\t \n}\n\nvoid odm_NHMCounterStatistics(void *pDM_VOID)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\n\t \n\todm_GetNHMCounterStatistics(pDM_Odm);\n\n\t \n\todm_NHMCounterStatisticsReset(pDM_Odm);\n}\n\nvoid odm_GetNHMCounterStatistics(void *pDM_VOID)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\tu32 value32 = 0;\n\n\tvalue32 = PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG_NHM_CNT_11N, bMaskDWord);\n\n\tpDM_Odm->NHM_cnt_0 = (u8)(value32 & bMaskByte0);\n}\n\nvoid odm_NHMCounterStatisticsReset(void *pDM_VOID)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\n\tPHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_NHM_TH9_TH10_11N, BIT1, 0);\n\tPHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_NHM_TH9_TH10_11N, BIT1, 1);\n}\n\nvoid odm_NHMBBInit(void *pDM_VOID)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\n\tpDM_Odm->adaptivity_flag = 0;\n\tpDM_Odm->tolerance_cnt = 3;\n\tpDM_Odm->NHMLastTxOkcnt = 0;\n\tpDM_Odm->NHMLastRxOkcnt = 0;\n\tpDM_Odm->NHMCurTxOkcnt = 0;\n\tpDM_Odm->NHMCurRxOkcnt = 0;\n}\n\n \nvoid odm_NHMBB(void *pDM_VOID)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\t \n\t \n\n\tpDM_Odm->NHMCurTxOkcnt =\n\t\t*(pDM_Odm->pNumTxBytesUnicast)-pDM_Odm->NHMLastTxOkcnt;\n\tpDM_Odm->NHMCurRxOkcnt =\n\t\t*(pDM_Odm->pNumRxBytesUnicast)-pDM_Odm->NHMLastRxOkcnt;\n\tpDM_Odm->NHMLastTxOkcnt =\n\t\t*(pDM_Odm->pNumTxBytesUnicast);\n\tpDM_Odm->NHMLastRxOkcnt =\n\t\t*(pDM_Odm->pNumRxBytesUnicast);\n\n\n\tif ((pDM_Odm->NHMCurTxOkcnt) + 1 > (u64)(pDM_Odm->NHMCurRxOkcnt<<2) + 1) {  \n\t\tif (pDM_Odm->NHM_cnt_0 >= 190 || pDM_Odm->adaptivity_flag == true) {\n\t\t\t \n\t\t\t \n\t\t\tpDM_Odm->adaptivity_flag = true;\n\t\t\tpDM_Odm->tolerance_cnt = 0;\n\t\t} else {\n\t\t\tif (pDM_Odm->tolerance_cnt < 3)\n\t\t\t\tpDM_Odm->tolerance_cnt = pDM_Odm->tolerance_cnt + 1;\n\t\t\telse\n\t\t\t\tpDM_Odm->tolerance_cnt = 4;\n\t\t\t \n\t\t\tif (pDM_Odm->tolerance_cnt > 3) {\n\t\t\t\t \n\t\t\t\tpDM_Odm->adaptivity_flag = false;\n\t\t\t}\n\t\t}\n\t} else {  \n\t\tif (pDM_Odm->adaptivity_flag == true && pDM_Odm->NHM_cnt_0 <= 200) {\n\t\t\t \n\t\t\tpDM_Odm->tolerance_cnt = 0;\n\t\t} else {\n\t\t\tif (pDM_Odm->tolerance_cnt < 3)\n\t\t\t\tpDM_Odm->tolerance_cnt = pDM_Odm->tolerance_cnt + 1;\n\t\t\telse\n\t\t\t\tpDM_Odm->tolerance_cnt = 4;\n\t\t\t \n\t\t\tif (pDM_Odm->tolerance_cnt > 3) {\n\t\t\t\t \n\t\t\t\tpDM_Odm->adaptivity_flag = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid odm_SearchPwdBLowerBound(void *pDM_VOID, u8 IGI_target)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\tu32 value32 = 0;\n\tu8 cnt, IGI;\n\tbool bAdjust = true;\n\ts8 TH_L2H_dmc, TH_H2L_dmc;\n\ts8 Diff;\n\n\tIGI = 0x50;  \n\tODM_Write_DIG(pDM_Odm, IGI);\n\n\n\tDiff = IGI_target-(s8)IGI;\n\tTH_L2H_dmc = pDM_Odm->TH_L2H_ini + Diff;\n\tif (TH_L2H_dmc > 10)\n\t\tTH_L2H_dmc = 10;\n\tTH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;\n\tPHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, bMaskByte0, (u8)TH_L2H_dmc);\n\tPHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, bMaskByte2, (u8)TH_H2L_dmc);\n\n\tmdelay(5);\n\n\twhile (bAdjust) {\n\t\tfor (cnt = 0; cnt < 20; cnt++) {\n\t\t\tvalue32 = PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG_RPT_11N, bMaskDWord);\n\n\t\t\tif (value32 & BIT30)\n\t\t\t\tpDM_Odm->txEdcca1 = pDM_Odm->txEdcca1 + 1;\n\t\t\telse if (value32 & BIT29)\n\t\t\t\tpDM_Odm->txEdcca1 = pDM_Odm->txEdcca1 + 1;\n\t\t\telse\n\t\t\t\tpDM_Odm->txEdcca0 = pDM_Odm->txEdcca0 + 1;\n\t\t}\n\n\t\tif (pDM_Odm->txEdcca1 > 5) {\n\t\t\tIGI = IGI-1;\n\t\t\tTH_L2H_dmc = TH_L2H_dmc + 1;\n\t\t\tif (TH_L2H_dmc > 10)\n\t\t\t\tTH_L2H_dmc = 10;\n\t\t\tTH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;\n\t\t\tPHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, bMaskByte0, (u8)TH_L2H_dmc);\n\t\t\tPHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, bMaskByte2, (u8)TH_H2L_dmc);\n\n\t\t\tpDM_Odm->TxHangFlg = true;\n\t\t\tpDM_Odm->txEdcca1 = 0;\n\t\t\tpDM_Odm->txEdcca0 = 0;\n\n\t\t\tif (TH_L2H_dmc == 10) {\n\t\t\t\tbAdjust = false;\n\t\t\t\tpDM_Odm->TxHangFlg = false;\n\t\t\t\tpDM_Odm->txEdcca1 = 0;\n\t\t\t\tpDM_Odm->txEdcca0 = 0;\n\t\t\t\tpDM_Odm->H2L_lb = TH_H2L_dmc;\n\t\t\t\tpDM_Odm->L2H_lb = TH_L2H_dmc;\n\t\t\t\tpDM_Odm->Adaptivity_IGI_upper = IGI;\n\t\t\t}\n\t\t} else {\n\t\t\tbAdjust = false;\n\t\t\tpDM_Odm->TxHangFlg = false;\n\t\t\tpDM_Odm->txEdcca1 = 0;\n\t\t\tpDM_Odm->txEdcca0 = 0;\n\t\t\tpDM_Odm->H2L_lb = TH_H2L_dmc;\n\t\t\tpDM_Odm->L2H_lb = TH_L2H_dmc;\n\t\t\tpDM_Odm->Adaptivity_IGI_upper = IGI;\n\t\t}\n\t}\n}\n\nvoid odm_AdaptivityInit(void *pDM_VOID)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\n\tif (pDM_Odm->Carrier_Sense_enable == false)\n\t\tpDM_Odm->TH_L2H_ini = 0xf7;  \n\telse\n\t\tpDM_Odm->TH_L2H_ini = 0xa;\n\n\tpDM_Odm->AdapEn_RSSI = 20;\n\tpDM_Odm->TH_EDCCA_HL_diff = 7;\n\n\tpDM_Odm->IGI_Base = 0x32;\n\tpDM_Odm->IGI_target = 0x1c;\n\tpDM_Odm->ForceEDCCA = 0;\n\tpDM_Odm->NHM_disable = false;\n\tpDM_Odm->TxHangFlg = true;\n\tpDM_Odm->txEdcca0 = 0;\n\tpDM_Odm->txEdcca1 = 0;\n\tpDM_Odm->H2L_lb = 0;\n\tpDM_Odm->L2H_lb = 0;\n\tpDM_Odm->Adaptivity_IGI_upper = 0;\n\todm_NHMBBInit(pDM_Odm);\n\n\tPHY_SetBBReg(pDM_Odm->Adapter, REG_RD_CTRL, BIT11, 1);  \n}\n\n\nvoid odm_Adaptivity(void *pDM_VOID, u8 IGI)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\ts8 TH_L2H_dmc, TH_H2L_dmc;\n\ts8 Diff, IGI_target;\n\tbool EDCCA_State = false;\n\n\tif (!(pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY)) {\n\t\treturn;\n\t}\n\n\tif (*pDM_Odm->pBandWidth == ODM_BW20M)  \n\t\tIGI_target = pDM_Odm->IGI_Base;\n\telse if (*pDM_Odm->pBandWidth == ODM_BW40M)\n\t\tIGI_target = pDM_Odm->IGI_Base + 2;\n\telse\n\t\tIGI_target = pDM_Odm->IGI_Base;\n\tpDM_Odm->IGI_target = (u8) IGI_target;\n\n\t \n\tif (pDM_Odm->TxHangFlg == true) {\n\t\tPHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_DBG_RPT_11N, bMaskDWord, 0x208);\n\t\todm_SearchPwdBLowerBound(pDM_Odm, pDM_Odm->IGI_target);\n\t}\n\n\tif ((!pDM_Odm->bLinked) || (*pDM_Odm->pChannel > 149)) {  \n\t\tPHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, bMaskByte0, 0x7f);\n\t\tPHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, bMaskByte2, 0x7f);\n\t\treturn;\n\t}\n\n\tif (!pDM_Odm->ForceEDCCA) {\n\t\tif (pDM_Odm->RSSI_Min > pDM_Odm->AdapEn_RSSI)\n\t\t\tEDCCA_State = true;\n\t\telse if (pDM_Odm->RSSI_Min < (pDM_Odm->AdapEn_RSSI - 5))\n\t\t\tEDCCA_State = false;\n\t} else\n\t\tEDCCA_State = true;\n\n\tif (\n\t\tpDM_Odm->bLinked &&\n\t\tpDM_Odm->Carrier_Sense_enable == false &&\n\t\tpDM_Odm->NHM_disable == false &&\n\t\tpDM_Odm->TxHangFlg == false\n\t)\n\t\todm_NHMBB(pDM_Odm);\n\n\tif (EDCCA_State) {\n\t\tDiff = IGI_target-(s8)IGI;\n\t\tTH_L2H_dmc = pDM_Odm->TH_L2H_ini + Diff;\n\t\tif (TH_L2H_dmc > 10)\n\t\t\tTH_L2H_dmc = 10;\n\n\t\tTH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;\n\n\t\t \n\t\tif (TH_H2L_dmc < pDM_Odm->H2L_lb)\n\t\t\tTH_H2L_dmc = pDM_Odm->H2L_lb;\n\t\tif (TH_L2H_dmc < pDM_Odm->L2H_lb)\n\t\t\tTH_L2H_dmc = pDM_Odm->L2H_lb;\n\t} else {\n\t\tTH_L2H_dmc = 0x7f;\n\t\tTH_H2L_dmc = 0x7f;\n\t}\n\tPHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, bMaskByte0, (u8)TH_L2H_dmc);\n\tPHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, bMaskByte2, (u8)TH_H2L_dmc);\n}\n\nvoid ODM_Write_DIG(void *pDM_VOID, u8 CurrentIGI)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\tstruct dig_t *pDM_DigTable = &pDM_Odm->DM_DigTable;\n\n\tif (pDM_DigTable->bStopDIG) {\n\t\treturn;\n\t}\n\n\tif (pDM_DigTable->CurIGValue != CurrentIGI) {\n\t\t \n\t\tif (!pDM_DigTable->bPSDInProgress) {\n\t\t\tif (CurrentIGI > pDM_DigTable->rx_gain_range_max) {\n\t\t\t\tCurrentIGI = pDM_DigTable->rx_gain_range_max;\n\t\t\t}\n\n\t\t}\n\n\t\t \n\t\tPHY_SetBBReg(pDM_Odm->Adapter, ODM_REG(IGI_A, pDM_Odm), ODM_BIT(IGI, pDM_Odm), CurrentIGI);\n\n\t\tPHY_SetBBReg(pDM_Odm->Adapter, ODM_REG(IGI_B, pDM_Odm), ODM_BIT(IGI, pDM_Odm), CurrentIGI);\n\n\t\tpDM_DigTable->CurIGValue = CurrentIGI;\n\t}\n\n}\n\nbool odm_DigAbort(void *pDM_VOID)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\n\t \n\tif (!(pDM_Odm->SupportAbility & ODM_BB_FA_CNT)) {\n\t\treturn\ttrue;\n\t}\n\n\t \n\tif (!(pDM_Odm->SupportAbility & ODM_BB_DIG)) {\n\t\treturn\ttrue;\n\t}\n\n\t \n\tif (*(pDM_Odm->pbScanInProcess)) {\n\t\treturn\ttrue;\n\t}\n\n\t \n\tif (pDM_Odm->bDMInitialGainEnable == false) {\n\t\treturn\ttrue;\n\t}\n\n\treturn\tfalse;\n}\n\nvoid odm_DIGInit(void *pDM_VOID)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\tstruct dig_t *pDM_DigTable = &pDM_Odm->DM_DigTable;\n\n\tpDM_DigTable->bStopDIG = false;\n\tpDM_DigTable->bPSDInProgress = false;\n\tpDM_DigTable->CurIGValue = (u8) PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG(IGI_A, pDM_Odm), ODM_BIT(IGI, pDM_Odm));\n\tpDM_DigTable->RssiLowThresh\t= DM_DIG_THRESH_LOW;\n\tpDM_DigTable->RssiHighThresh\t= DM_DIG_THRESH_HIGH;\n\tpDM_DigTable->FALowThresh\t= DMfalseALARM_THRESH_LOW;\n\tpDM_DigTable->FAHighThresh\t= DMfalseALARM_THRESH_HIGH;\n\tpDM_DigTable->BackoffVal = DM_DIG_BACKOFF_DEFAULT;\n\tpDM_DigTable->BackoffVal_range_max = DM_DIG_BACKOFF_MAX;\n\tpDM_DigTable->BackoffVal_range_min = DM_DIG_BACKOFF_MIN;\n\tpDM_DigTable->PreCCK_CCAThres = 0xFF;\n\tpDM_DigTable->CurCCK_CCAThres = 0x83;\n\tpDM_DigTable->ForbiddenIGI = DM_DIG_MIN_NIC;\n\tpDM_DigTable->LargeFAHit = 0;\n\tpDM_DigTable->Recover_cnt = 0;\n\tpDM_DigTable->bMediaConnect_0 = false;\n\tpDM_DigTable->bMediaConnect_1 = false;\n\n\t \n\tpDM_Odm->bDMInitialGainEnable = true;\n\n\tpDM_DigTable->DIG_Dynamic_MIN_0 = DM_DIG_MIN_NIC;\n\tpDM_DigTable->DIG_Dynamic_MIN_1 = DM_DIG_MIN_NIC;\n\n\t \n\tpDM_DigTable->BT30_CurIGI = 0x32;\n\n\tpDM_DigTable->rx_gain_range_max = DM_DIG_MAX_NIC;\n\tpDM_DigTable->rx_gain_range_min = DM_DIG_MIN_NIC;\n\n}\n\n\nvoid odm_DIG(void *pDM_VOID)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\n\t \n\tstruct dig_t *pDM_DigTable = &pDM_Odm->DM_DigTable;\n\tstruct false_ALARM_STATISTICS *pFalseAlmCnt = &pDM_Odm->FalseAlmCnt;\n\tbool FirstConnect, FirstDisConnect;\n\tu8 DIG_MaxOfMin, DIG_Dynamic_MIN;\n\tu8 dm_dig_max, dm_dig_min;\n\tu8 CurrentIGI = pDM_DigTable->CurIGValue;\n\tu8 offset;\n\tu32 dm_FA_thres[3];\n\tu8 Adap_IGI_Upper = 0;\n\tu32 TxTp = 0, RxTp = 0;\n\tbool bDFSBand = false;\n\tbool bPerformance = true, bFirstTpTarget = false, bFirstCoverage = false;\n\n\tif (odm_DigAbort(pDM_Odm))\n\t\treturn;\n\n\tif (pDM_Odm->adaptivity_flag == true)\n\t\tAdap_IGI_Upper = pDM_Odm->Adaptivity_IGI_upper;\n\n\n\t \n\tDIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;\n\tFirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == false);\n\tFirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == true);\n\n\t \n\t \n\tdm_dig_max = 0x5A;\n\tdm_dig_min = DM_DIG_MIN_NIC;\n\tDIG_MaxOfMin = DM_DIG_MAX_AP;\n\n\t \n\tif (pDM_Odm->bLinked && bPerformance) {\n\t\t \n\t\t \n\t\tif (pDM_Odm->bBtLimitedDig == 1) {\n\t\t\toffset = 10;\n\t\t} else\n\t\t\toffset = 15;\n\n\t\tif ((pDM_Odm->RSSI_Min + offset) > dm_dig_max)\n\t\t\tpDM_DigTable->rx_gain_range_max = dm_dig_max;\n\t\telse if ((pDM_Odm->RSSI_Min + offset) < dm_dig_min)\n\t\t\tpDM_DigTable->rx_gain_range_max = dm_dig_min;\n\t\telse\n\t\t\tpDM_DigTable->rx_gain_range_max = pDM_Odm->RSSI_Min + offset;\n\n\t\t \n\t\t \n\t\t{\n\t\t\tif (pDM_Odm->RSSI_Min < dm_dig_min)\n\t\t\t\tDIG_Dynamic_MIN = dm_dig_min;\n\t\t\telse if (pDM_Odm->RSSI_Min > DIG_MaxOfMin)\n\t\t\t\tDIG_Dynamic_MIN = DIG_MaxOfMin;\n\t\t\telse\n\t\t\t\tDIG_Dynamic_MIN = pDM_Odm->RSSI_Min;\n\t\t}\n\t} else {\n\t\tpDM_DigTable->rx_gain_range_max = dm_dig_max;\n\t\tDIG_Dynamic_MIN = dm_dig_min;\n\t}\n\n\t \n\tif (pDM_Odm->bLinked && !pDM_Odm->bOneEntryOnly) {\n\t\tif (pDM_Odm->SupportAbility & ODM_BB_ANT_DIV) {\n\t\t\tif (\n\t\t\t\tpDM_Odm->AntDivType == CG_TRX_HW_ANTDIV ||\n\t\t\t\tpDM_Odm->AntDivType == CG_TRX_SMART_ANTDIV ||\n\t\t\t\tpDM_Odm->AntDivType == S0S1_SW_ANTDIV\n\t\t\t) {\n\t\t\t\tif (pDM_DigTable->AntDiv_RSSI_max > DIG_MaxOfMin)\n\t\t\t\t\tDIG_Dynamic_MIN = DIG_MaxOfMin;\n\t\t\t\telse\n\t\t\t\t\tDIG_Dynamic_MIN = (u8) pDM_DigTable->AntDiv_RSSI_max;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\t \n\tif (FirstDisConnect) {\n\t\tpDM_DigTable->rx_gain_range_min = DIG_Dynamic_MIN;\n\t\tpDM_DigTable->ForbiddenIGI = DIG_Dynamic_MIN;\n\t} else\n\t\tpDM_DigTable->rx_gain_range_min =\n\t\t\todm_ForbiddenIGICheck(pDM_Odm, DIG_Dynamic_MIN, CurrentIGI);\n\n\tif (pDM_Odm->bLinked && !FirstConnect) {\n\t\tif (\n\t\t\t(pDM_Odm->PhyDbgInfo.NumQryBeaconPkt < 5) &&\n\t\t\tpDM_Odm->bsta_state\n\t\t) {\n\t\t\tpDM_DigTable->rx_gain_range_min = dm_dig_min;\n\t\t}\n\t}\n\n\t \n\tif (pDM_DigTable->rx_gain_range_min > pDM_DigTable->rx_gain_range_max) {\n\t\tpDM_DigTable->rx_gain_range_min = pDM_DigTable->rx_gain_range_max;\n\t}\n\n\n\t \n\todm_FAThresholdCheck(pDM_Odm, bDFSBand, bPerformance, RxTp, TxTp, dm_FA_thres);\n\n\t \n\tif (pDM_Odm->bLinked && bPerformance) {\n\n\t\tif (bFirstTpTarget || FirstConnect) {\n\t\t\tpDM_DigTable->LargeFAHit = 0;\n\n\t\t\tif (pDM_Odm->RSSI_Min < DIG_MaxOfMin) {\n\t\t\t\tif (CurrentIGI < pDM_Odm->RSSI_Min)\n\t\t\t\t\tCurrentIGI = pDM_Odm->RSSI_Min;\n\t\t\t} else {\n\t\t\t\tif (CurrentIGI < DIG_MaxOfMin)\n\t\t\t\t\tCurrentIGI = DIG_MaxOfMin;\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (pFalseAlmCnt->Cnt_all > dm_FA_thres[2])\n\t\t\t\tCurrentIGI = CurrentIGI + 4;\n\t\t\telse if (pFalseAlmCnt->Cnt_all > dm_FA_thres[1])\n\t\t\t\tCurrentIGI = CurrentIGI + 2;\n\t\t\telse if (pFalseAlmCnt->Cnt_all < dm_FA_thres[0])\n\t\t\t\tCurrentIGI = CurrentIGI - 2;\n\n\t\t\tif (\n\t\t\t\t(pDM_Odm->PhyDbgInfo.NumQryBeaconPkt < 5) &&\n\t\t\t\t(pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH1) &&\n\t\t\t\t(pDM_Odm->bsta_state)\n\t\t\t) {\n\t\t\t\tCurrentIGI = pDM_DigTable->rx_gain_range_min;\n\t\t\t}\n\t\t}\n\t} else {\n\n\t\tif (FirstDisConnect || bFirstCoverage) {\n\t\t\tCurrentIGI = dm_dig_min;\n\t\t} else {\n\t\t\tif (pFalseAlmCnt->Cnt_all > dm_FA_thres[2])\n\t\t\t\tCurrentIGI = CurrentIGI + 4;\n\t\t\telse if (pFalseAlmCnt->Cnt_all > dm_FA_thres[1])\n\t\t\t\tCurrentIGI = CurrentIGI + 2;\n\t\t\telse if (pFalseAlmCnt->Cnt_all < dm_FA_thres[0])\n\t\t\t\tCurrentIGI = CurrentIGI - 2;\n\t\t}\n\t}\n\n\t \n\tif (CurrentIGI < pDM_DigTable->rx_gain_range_min)\n\t\tCurrentIGI = pDM_DigTable->rx_gain_range_min;\n\n\tif (CurrentIGI > pDM_DigTable->rx_gain_range_max)\n\t\tCurrentIGI = pDM_DigTable->rx_gain_range_max;\n\n\t \n\tif (\n\t\tpDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY &&\n\t\tpDM_Odm->adaptivity_flag == true\n\t) {\n\t\tif (CurrentIGI > Adap_IGI_Upper)\n\t\t\tCurrentIGI = Adap_IGI_Upper;\n\n\t\tif (pDM_Odm->IGI_LowerBound != 0) {\n\t\t\tif (CurrentIGI < pDM_Odm->IGI_LowerBound)\n\t\t\t\tCurrentIGI = pDM_Odm->IGI_LowerBound;\n\t\t}\n\t}\n\n\n\t \n\tif (pDM_Odm->bBtHsOperation) {\n\t\tif (pDM_Odm->bLinked) {\n\t\t\tif (pDM_DigTable->BT30_CurIGI > (CurrentIGI))\n\t\t\t\tODM_Write_DIG(pDM_Odm, CurrentIGI);\n\t\t\telse\n\t\t\t\tODM_Write_DIG(pDM_Odm, pDM_DigTable->BT30_CurIGI);\n\n\t\t\tpDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;\n\t\t\tpDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;\n\t\t} else {\n\t\t\tif (pDM_Odm->bLinkInProcess)\n\t\t\t\tODM_Write_DIG(pDM_Odm, 0x1c);\n\t\t\telse if (pDM_Odm->bBtConnectProcess)\n\t\t\t\tODM_Write_DIG(pDM_Odm, 0x28);\n\t\t\telse\n\t\t\t\tODM_Write_DIG(pDM_Odm, pDM_DigTable->BT30_CurIGI); \n\t\t}\n\t} else {  \n\t\tODM_Write_DIG(pDM_Odm, CurrentIGI); \n\t\tpDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;\n\t\tpDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;\n\t}\n}\n\nvoid odm_DIGbyRSSI_LPS(void *pDM_VOID)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\tstruct false_ALARM_STATISTICS *pFalseAlmCnt = &pDM_Odm->FalseAlmCnt;\n\n\tu8 RSSI_Lower = DM_DIG_MIN_NIC;    \n\tu8 CurrentIGI = pDM_Odm->RSSI_Min;\n\n\tCurrentIGI = CurrentIGI+RSSI_OFFSET_DIG;\n\n\t \n\t \n\tif (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH2_LPS)\n\t\tCurrentIGI = CurrentIGI+4;\n\telse if (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH1_LPS)\n\t\tCurrentIGI = CurrentIGI+2;\n\telse if (pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH0_LPS)\n\t\tCurrentIGI = CurrentIGI-2;\n\n\n\t \n\n\t \n\tRSSI_Lower = max(pDM_Odm->RSSI_Min - 10, DM_DIG_MIN_NIC);\n\n\t \n\tif (CurrentIGI > DM_DIG_MAX_NIC)\n\t\tCurrentIGI = DM_DIG_MAX_NIC;\n\telse if (CurrentIGI < RSSI_Lower)\n\t\tCurrentIGI = RSSI_Lower;\n\n\tODM_Write_DIG(pDM_Odm, CurrentIGI);\n\t \n}\n\n \n \n \n\nvoid odm_FalseAlarmCounterStatistics(void *pDM_VOID)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\tstruct false_ALARM_STATISTICS *FalseAlmCnt = &pDM_Odm->FalseAlmCnt;\n\tu32 ret_value;\n\n\tif (!(pDM_Odm->SupportAbility & ODM_BB_FA_CNT))\n\t\treturn;\n\n\t \n\t \n\tPHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_OFDM_FA_HOLDC_11N, BIT31, 1);\n\t \n\tPHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_OFDM_FA_RSTD_11N, BIT31, 1);\n\n\tret_value = PHY_QueryBBReg(\n\t\tpDM_Odm->Adapter, ODM_REG_OFDM_FA_TYPE1_11N, bMaskDWord\n\t);\n\tFalseAlmCnt->Cnt_Fast_Fsync = (ret_value&0xffff);\n\tFalseAlmCnt->Cnt_SB_Search_fail = ((ret_value&0xffff0000)>>16);\n\n\tret_value = PHY_QueryBBReg(\n\t\tpDM_Odm->Adapter, ODM_REG_OFDM_FA_TYPE2_11N, bMaskDWord\n\t);\n\tFalseAlmCnt->Cnt_OFDM_CCA = (ret_value&0xffff);\n\tFalseAlmCnt->Cnt_Parity_Fail = ((ret_value&0xffff0000)>>16);\n\n\tret_value = PHY_QueryBBReg(\n\t\tpDM_Odm->Adapter, ODM_REG_OFDM_FA_TYPE3_11N, bMaskDWord\n\t);\n\tFalseAlmCnt->Cnt_Rate_Illegal = (ret_value&0xffff);\n\tFalseAlmCnt->Cnt_Crc8_fail = ((ret_value&0xffff0000)>>16);\n\n\tret_value = PHY_QueryBBReg(\n\t\tpDM_Odm->Adapter, ODM_REG_OFDM_FA_TYPE4_11N, bMaskDWord\n\t);\n\tFalseAlmCnt->Cnt_Mcs_fail = (ret_value&0xffff);\n\n\tFalseAlmCnt->Cnt_Ofdm_fail =\n\t\tFalseAlmCnt->Cnt_Parity_Fail +\n\t\tFalseAlmCnt->Cnt_Rate_Illegal +\n\t\tFalseAlmCnt->Cnt_Crc8_fail +\n\t\tFalseAlmCnt->Cnt_Mcs_fail +\n\t\tFalseAlmCnt->Cnt_Fast_Fsync +\n\t\tFalseAlmCnt->Cnt_SB_Search_fail;\n\n\t{\n\t\t \n\t\tPHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_CCK_FA_RST_11N, BIT12, 1);\n\t\tPHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_CCK_FA_RST_11N, BIT14, 1);\n\n\t\tret_value = PHY_QueryBBReg(\n\t\t\tpDM_Odm->Adapter, ODM_REG_CCK_FA_LSB_11N, bMaskByte0\n\t\t);\n\t\tFalseAlmCnt->Cnt_Cck_fail = ret_value;\n\n\t\tret_value = PHY_QueryBBReg(\n\t\t\tpDM_Odm->Adapter, ODM_REG_CCK_FA_MSB_11N, bMaskByte3\n\t\t);\n\t\tFalseAlmCnt->Cnt_Cck_fail += (ret_value&0xff)<<8;\n\n\t\tret_value = PHY_QueryBBReg(\n\t\t\tpDM_Odm->Adapter, ODM_REG_CCK_CCA_CNT_11N, bMaskDWord\n\t\t);\n\t\tFalseAlmCnt->Cnt_CCK_CCA =\n\t\t\t((ret_value&0xFF)<<8) | ((ret_value&0xFF00)>>8);\n\t}\n\n\tFalseAlmCnt->Cnt_all = (\n\t\tFalseAlmCnt->Cnt_Fast_Fsync +\n\t\tFalseAlmCnt->Cnt_SB_Search_fail +\n\t\tFalseAlmCnt->Cnt_Parity_Fail +\n\t\tFalseAlmCnt->Cnt_Rate_Illegal +\n\t\tFalseAlmCnt->Cnt_Crc8_fail +\n\t\tFalseAlmCnt->Cnt_Mcs_fail +\n\t\tFalseAlmCnt->Cnt_Cck_fail\n\t);\n\n\tFalseAlmCnt->Cnt_CCA_all =\n\t\tFalseAlmCnt->Cnt_OFDM_CCA + FalseAlmCnt->Cnt_CCK_CCA;\n}\n\n\nvoid odm_FAThresholdCheck(\n\tvoid *pDM_VOID,\n\tbool bDFSBand,\n\tbool bPerformance,\n\tu32 RxTp,\n\tu32 TxTp,\n\tu32 *dm_FA_thres\n)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\n\tif (pDM_Odm->bLinked && (bPerformance || bDFSBand)) {\n\t\t \n\t\tdm_FA_thres[0] = DM_DIG_FA_TH0;\n\t\tdm_FA_thres[1] = DM_DIG_FA_TH1;\n\t\tdm_FA_thres[2] = DM_DIG_FA_TH2;\n\t} else {\n\t\tdm_FA_thres[0] = 2000;\n\t\tdm_FA_thres[1] = 4000;\n\t\tdm_FA_thres[2] = 5000;\n\t}\n}\n\nu8 odm_ForbiddenIGICheck(void *pDM_VOID, u8 DIG_Dynamic_MIN, u8 CurrentIGI)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\tstruct dig_t *pDM_DigTable = &pDM_Odm->DM_DigTable;\n\tstruct false_ALARM_STATISTICS *pFalseAlmCnt = &pDM_Odm->FalseAlmCnt;\n\tu8 rx_gain_range_min = pDM_DigTable->rx_gain_range_min;\n\n\tif (pFalseAlmCnt->Cnt_all > 10000) {\n\t\tif (pDM_DigTable->LargeFAHit != 3)\n\t\t\tpDM_DigTable->LargeFAHit++;\n\n\t\t \n\t\tif (pDM_DigTable->ForbiddenIGI < CurrentIGI) {\n\t\t\tpDM_DigTable->ForbiddenIGI = CurrentIGI;\n\t\t\t \n\t\t\tpDM_DigTable->LargeFAHit = 1;\n\t\t}\n\n\t\tif (pDM_DigTable->LargeFAHit >= 3) {\n\t\t\tif ((pDM_DigTable->ForbiddenIGI + 2) > pDM_DigTable->rx_gain_range_max)\n\t\t\t\trx_gain_range_min = pDM_DigTable->rx_gain_range_max;\n\t\t\telse\n\t\t\t\trx_gain_range_min = (pDM_DigTable->ForbiddenIGI + 2);\n\t\t\tpDM_DigTable->Recover_cnt = 1800;\n\t\t}\n\t} else {\n\t\tif (pDM_DigTable->Recover_cnt != 0) {\n\t\t\tpDM_DigTable->Recover_cnt--;\n\t\t} else {\n\t\t\tif (pDM_DigTable->LargeFAHit < 3) {\n\t\t\t\tif ((pDM_DigTable->ForbiddenIGI - 2) < DIG_Dynamic_MIN) {  \n\t\t\t\t\tpDM_DigTable->ForbiddenIGI = DIG_Dynamic_MIN;  \n\t\t\t\t\trx_gain_range_min = DIG_Dynamic_MIN;  \n\t\t\t\t} else {\n\t\t\t\t\tpDM_DigTable->ForbiddenIGI -= 2;\n\t\t\t\t\trx_gain_range_min = (pDM_DigTable->ForbiddenIGI + 2);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tpDM_DigTable->LargeFAHit = 0;\n\t\t}\n\t}\n\n\treturn rx_gain_range_min;\n\n}\n\n \n \n \n\nvoid odm_CCKPacketDetectionThresh(void *pDM_VOID)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\tstruct false_ALARM_STATISTICS *FalseAlmCnt = &pDM_Odm->FalseAlmCnt;\n\tu8 CurCCK_CCAThres;\n\n\n\tif (\n\t\t!(pDM_Odm->SupportAbility & ODM_BB_CCK_PD) ||\n\t\t!(pDM_Odm->SupportAbility & ODM_BB_FA_CNT)\n\t) {\n\t\treturn;\n\t}\n\n\tif (pDM_Odm->ExtLNA)\n\t\treturn;\n\n\tif (pDM_Odm->bLinked) {\n\t\tif (pDM_Odm->RSSI_Min > 25)\n\t\t\tCurCCK_CCAThres = 0xcd;\n\t\telse if ((pDM_Odm->RSSI_Min <= 25) && (pDM_Odm->RSSI_Min > 10))\n\t\t\tCurCCK_CCAThres = 0x83;\n\t\telse {\n\t\t\tif (FalseAlmCnt->Cnt_Cck_fail > 1000)\n\t\t\t\tCurCCK_CCAThres = 0x83;\n\t\t\telse\n\t\t\t\tCurCCK_CCAThres = 0x40;\n\t\t}\n\t} else {\n\t\tif (FalseAlmCnt->Cnt_Cck_fail > 1000)\n\t\t\tCurCCK_CCAThres = 0x83;\n\t\telse\n\t\t\tCurCCK_CCAThres = 0x40;\n\t}\n\n\tODM_Write_CCK_CCA_Thres(pDM_Odm, CurCCK_CCAThres);\n}\n\nvoid ODM_Write_CCK_CCA_Thres(void *pDM_VOID, u8 CurCCK_CCAThres)\n{\n\tstruct dm_odm_t *pDM_Odm = (struct dm_odm_t *)pDM_VOID;\n\tstruct dig_t *pDM_DigTable = &pDM_Odm->DM_DigTable;\n\n\t \n\tif (pDM_DigTable->CurCCK_CCAThres != CurCCK_CCAThres)\n\t\trtw_write8(pDM_Odm->Adapter, ODM_REG(CCK_CCA, pDM_Odm), CurCCK_CCAThres);\n\n\tpDM_DigTable->PreCCK_CCAThres = pDM_DigTable->CurCCK_CCAThres;\n\tpDM_DigTable->CurCCK_CCAThres = CurCCK_CCAThres;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}