{
  "module_name": "sdio_ops.c",
  "hash_id": "76cfde42ed4359b15805b1cb08ada5231e55857e9a90da365b2057a701fc3401",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/hal/sdio_ops.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <rtl8723b_hal.h>\n\n \n \n \n \n \n \nstatic void hal_sdio_get_cmd_addr_8723b(\n\tstruct adapter *adapter,\n\tu8 device_id,\n\tu32 addr,\n\tu32 *cmdaddr\n)\n{\n\tswitch (device_id) {\n\tcase SDIO_LOCAL_DEVICE_ID:\n\t\t*cmdaddr = ((SDIO_LOCAL_DEVICE_ID << 13) | (addr & SDIO_LOCAL_MSK));\n\t\tbreak;\n\n\tcase WLAN_IOREG_DEVICE_ID:\n\t\t*cmdaddr = ((WLAN_IOREG_DEVICE_ID << 13) | (addr & WLAN_IOREG_MSK));\n\t\tbreak;\n\n\tcase WLAN_TX_HIQ_DEVICE_ID:\n\t\t*cmdaddr = ((WLAN_TX_HIQ_DEVICE_ID << 13) | (addr & WLAN_FIFO_MSK));\n\t\tbreak;\n\n\tcase WLAN_TX_MIQ_DEVICE_ID:\n\t\t*cmdaddr = ((WLAN_TX_MIQ_DEVICE_ID << 13) | (addr & WLAN_FIFO_MSK));\n\t\tbreak;\n\n\tcase WLAN_TX_LOQ_DEVICE_ID:\n\t\t*cmdaddr = ((WLAN_TX_LOQ_DEVICE_ID << 13) | (addr & WLAN_FIFO_MSK));\n\t\tbreak;\n\n\tcase WLAN_RX0FF_DEVICE_ID:\n\t\t*cmdaddr = ((WLAN_RX0FF_DEVICE_ID << 13) | (addr & WLAN_RX0FF_MSK));\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic u8 get_deviceid(u32 addr)\n{\n\tu8 devide_id;\n\tu16 pseudo_id;\n\n\tpseudo_id = (u16)(addr >> 16);\n\tswitch (pseudo_id) {\n\tcase 0x1025:\n\t\tdevide_id = SDIO_LOCAL_DEVICE_ID;\n\t\tbreak;\n\n\tcase 0x1026:\n\t\tdevide_id = WLAN_IOREG_DEVICE_ID;\n\t\tbreak;\n\n\tcase 0x1031:\n\t\tdevide_id = WLAN_TX_HIQ_DEVICE_ID;\n\t\tbreak;\n\n\tcase 0x1032:\n\t\tdevide_id = WLAN_TX_MIQ_DEVICE_ID;\n\t\tbreak;\n\n\tcase 0x1033:\n\t\tdevide_id = WLAN_TX_LOQ_DEVICE_ID;\n\t\tbreak;\n\n\tcase 0x1034:\n\t\tdevide_id = WLAN_RX0FF_DEVICE_ID;\n\t\tbreak;\n\n\tdefault:\n\t\tdevide_id = WLAN_IOREG_DEVICE_ID;\n\t\tbreak;\n\t}\n\n\treturn devide_id;\n}\n\nstatic u32 _cvrt2ftaddr(const u32 addr, u8 *pdevice_id, u16 *poffset)\n{\n\tu8 device_id;\n\tu16 offset;\n\tu32 ftaddr;\n\n\tdevice_id = get_deviceid(addr);\n\toffset = 0;\n\n\tswitch (device_id) {\n\tcase SDIO_LOCAL_DEVICE_ID:\n\t\toffset = addr & SDIO_LOCAL_MSK;\n\t\tbreak;\n\n\tcase WLAN_TX_HIQ_DEVICE_ID:\n\tcase WLAN_TX_MIQ_DEVICE_ID:\n\tcase WLAN_TX_LOQ_DEVICE_ID:\n\t\toffset = addr & WLAN_FIFO_MSK;\n\t\tbreak;\n\n\tcase WLAN_RX0FF_DEVICE_ID:\n\t\toffset = addr & WLAN_RX0FF_MSK;\n\t\tbreak;\n\n\tcase WLAN_IOREG_DEVICE_ID:\n\tdefault:\n\t\tdevice_id = WLAN_IOREG_DEVICE_ID;\n\t\toffset = addr & WLAN_IOREG_MSK;\n\t\tbreak;\n\t}\n\tftaddr = (device_id << 13) | offset;\n\n\tif (pdevice_id)\n\t\t*pdevice_id = device_id;\n\tif (poffset)\n\t\t*poffset = offset;\n\n\treturn ftaddr;\n}\n\nstatic u8 sdio_read8(struct intf_hdl *intfhdl, u32 addr)\n{\n\tu32 ftaddr;\n\tftaddr = _cvrt2ftaddr(addr, NULL, NULL);\n\n\treturn sd_read8(intfhdl, ftaddr, NULL);\n}\n\nstatic u16 sdio_read16(struct intf_hdl *intfhdl, u32 addr)\n{\n\tu32 ftaddr;\n\t__le16 le_tmp;\n\n\tftaddr = _cvrt2ftaddr(addr, NULL, NULL);\n\tsd_cmd52_read(intfhdl, ftaddr, 2, (u8 *)&le_tmp);\n\n\treturn le16_to_cpu(le_tmp);\n}\n\nstatic u32 sdio_read32(struct intf_hdl *intfhdl, u32 addr)\n{\n\tstruct adapter *adapter;\n\tu8 mac_pwr_ctrl_on;\n\tu8 device_id;\n\tu16 offset;\n\tu32 ftaddr;\n\tu8 shift;\n\tu32 val;\n\ts32 __maybe_unused err;\n\t__le32 le_tmp;\n\n\tadapter = intfhdl->padapter;\n\tftaddr = _cvrt2ftaddr(addr, &device_id, &offset);\n\n\trtw_hal_get_hwreg(adapter, HW_VAR_APFM_ON_MAC, &mac_pwr_ctrl_on);\n\tif (\n\t\t((device_id == WLAN_IOREG_DEVICE_ID) && (offset < 0x100)) ||\n\t\t(!mac_pwr_ctrl_on) ||\n\t\t(adapter_to_pwrctl(adapter)->fw_current_in_ps_mode)\n\t) {\n\t\terr = sd_cmd52_read(intfhdl, ftaddr, 4, (u8 *)&le_tmp);\n\t\treturn le32_to_cpu(le_tmp);\n\t}\n\n\t \n\tshift = ftaddr & 0x3;\n\tif (shift == 0) {\n\t\tval = sd_read32(intfhdl, ftaddr, NULL);\n\t} else {\n\t\tu8 *tmpbuf;\n\n\t\ttmpbuf = rtw_malloc(8);\n\t\tif (!tmpbuf)\n\t\t\treturn SDIO_ERR_VAL32;\n\n\t\tftaddr &= ~(u16)0x3;\n\t\tsd_read(intfhdl, ftaddr, 8, tmpbuf);\n\t\tmemcpy(&le_tmp, tmpbuf + shift, 4);\n\t\tval = le32_to_cpu(le_tmp);\n\n\t\tkfree(tmpbuf);\n\t}\n\treturn val;\n}\n\nstatic s32 sdio_readN(struct intf_hdl *intfhdl, u32 addr, u32 cnt, u8 *buf)\n{\n\tstruct adapter *adapter;\n\tu8 mac_pwr_ctrl_on;\n\tu8 device_id;\n\tu16 offset;\n\tu32 ftaddr;\n\tu8 shift;\n\ts32 err;\n\n\tadapter = intfhdl->padapter;\n\terr = 0;\n\n\tftaddr = _cvrt2ftaddr(addr, &device_id, &offset);\n\n\trtw_hal_get_hwreg(adapter, HW_VAR_APFM_ON_MAC, &mac_pwr_ctrl_on);\n\tif (\n\t\t((device_id == WLAN_IOREG_DEVICE_ID) && (offset < 0x100)) ||\n\t\t(!mac_pwr_ctrl_on) ||\n\t\t(adapter_to_pwrctl(adapter)->fw_current_in_ps_mode)\n\t)\n\t\treturn sd_cmd52_read(intfhdl, ftaddr, cnt, buf);\n\n\t \n\tshift = ftaddr & 0x3;\n\tif (shift == 0) {\n\t\terr = sd_read(intfhdl, ftaddr, cnt, buf);\n\t} else {\n\t\tu8 *tmpbuf;\n\t\tu32 n;\n\n\t\tftaddr &= ~(u16)0x3;\n\t\tn = cnt + shift;\n\t\ttmpbuf = rtw_malloc(n);\n\t\tif (!tmpbuf)\n\t\t\treturn -1;\n\n\t\terr = sd_read(intfhdl, ftaddr, n, tmpbuf);\n\t\tif (!err)\n\t\t\tmemcpy(buf, tmpbuf + shift, cnt);\n\t\tkfree(tmpbuf);\n\t}\n\treturn err;\n}\n\nstatic s32 sdio_write8(struct intf_hdl *intfhdl, u32 addr, u8 val)\n{\n\tu32 ftaddr;\n\ts32 err;\n\n\tftaddr = _cvrt2ftaddr(addr, NULL, NULL);\n\tsd_write8(intfhdl, ftaddr, val, &err);\n\n\treturn err;\n}\n\nstatic s32 sdio_write16(struct intf_hdl *intfhdl, u32 addr, u16 val)\n{\n\tu32 ftaddr;\n\t__le16 le_tmp;\n\n\tftaddr = _cvrt2ftaddr(addr, NULL, NULL);\n\tle_tmp = cpu_to_le16(val);\n\treturn sd_cmd52_write(intfhdl, ftaddr, 2, (u8 *)&le_tmp);\n}\n\nstatic s32 sdio_write32(struct intf_hdl *intfhdl, u32 addr, u32 val)\n{\n\tstruct adapter *adapter;\n\tu8 mac_pwr_ctrl_on;\n\tu8 device_id;\n\tu16 offset;\n\tu32 ftaddr;\n\tu8 shift;\n\ts32 err;\n\t__le32 le_tmp;\n\n\tadapter = intfhdl->padapter;\n\terr = 0;\n\n\tftaddr = _cvrt2ftaddr(addr, &device_id, &offset);\n\n\trtw_hal_get_hwreg(adapter, HW_VAR_APFM_ON_MAC, &mac_pwr_ctrl_on);\n\tif (\n\t\t((device_id == WLAN_IOREG_DEVICE_ID) && (offset < 0x100)) ||\n\t\t(!mac_pwr_ctrl_on) ||\n\t\t(adapter_to_pwrctl(adapter)->fw_current_in_ps_mode)\n\t) {\n\t\tle_tmp = cpu_to_le32(val);\n\n\t\treturn sd_cmd52_write(intfhdl, ftaddr, 4, (u8 *)&le_tmp);\n\t}\n\n\t \n\tshift = ftaddr & 0x3;\n\tif (shift == 0) {\n\t\tsd_write32(intfhdl, ftaddr, val, &err);\n\t} else {\n\t\tle_tmp = cpu_to_le32(val);\n\t\terr = sd_cmd52_write(intfhdl, ftaddr, 4, (u8 *)&le_tmp);\n\t}\n\treturn err;\n}\n\nstatic s32 sdio_writeN(struct intf_hdl *intfhdl, u32 addr, u32 cnt, u8 *buf)\n{\n\tstruct adapter *adapter;\n\tu8 mac_pwr_ctrl_on;\n\tu8 device_id;\n\tu16 offset;\n\tu32 ftaddr;\n\tu8 shift;\n\ts32 err;\n\n\tadapter = intfhdl->padapter;\n\terr = 0;\n\n\tftaddr = _cvrt2ftaddr(addr, &device_id, &offset);\n\n\trtw_hal_get_hwreg(adapter, HW_VAR_APFM_ON_MAC, &mac_pwr_ctrl_on);\n\tif (\n\t\t((device_id == WLAN_IOREG_DEVICE_ID) && (offset < 0x100)) ||\n\t\t(!mac_pwr_ctrl_on) ||\n\t\t(adapter_to_pwrctl(adapter)->fw_current_in_ps_mode)\n\t)\n\t\treturn sd_cmd52_write(intfhdl, ftaddr, cnt, buf);\n\n\tshift = ftaddr & 0x3;\n\tif (shift == 0) {\n\t\terr = sd_write(intfhdl, ftaddr, cnt, buf);\n\t} else {\n\t\tu8 *tmpbuf;\n\t\tu32 n;\n\n\t\tftaddr &= ~(u16)0x3;\n\t\tn = cnt + shift;\n\t\ttmpbuf = rtw_malloc(n);\n\t\tif (!tmpbuf)\n\t\t\treturn -1;\n\t\terr = sd_read(intfhdl, ftaddr, 4, tmpbuf);\n\t\tif (err) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn err;\n\t\t}\n\t\tmemcpy(tmpbuf + shift, buf, cnt);\n\t\terr = sd_write(intfhdl, ftaddr, n, tmpbuf);\n\t\tkfree(tmpbuf);\n\t}\n\treturn err;\n}\n\nstatic void sdio_read_mem(\n\tstruct intf_hdl *intfhdl,\n\tu32 addr,\n\tu32 cnt,\n\tu8 *rmem\n)\n{\n\tsdio_readN(intfhdl, addr, cnt, rmem);\n}\n\nstatic void sdio_write_mem(\n\tstruct intf_hdl *intfhdl,\n\tu32 addr,\n\tu32 cnt,\n\tu8 *wmem\n)\n{\n\tsdio_writeN(intfhdl, addr, cnt, wmem);\n}\n\n \nstatic u32 sdio_read_port(\n\tstruct intf_hdl *intfhdl,\n\tu32 addr,\n\tu32 cnt,\n\tu8 *mem\n)\n{\n\tstruct adapter *adapter;\n\tstruct sdio_data *psdio;\n\tstruct hal_com_data *hal;\n\ts32 err;\n\n\tadapter = intfhdl->padapter;\n\tpsdio = &adapter_to_dvobj(adapter)->intf_data;\n\thal = GET_HAL_DATA(adapter);\n\n\thal_sdio_get_cmd_addr_8723b(adapter, addr, hal->SdioRxFIFOCnt++, &addr);\n\n\tif (cnt > psdio->block_transfer_len)\n\t\tcnt = _RND(cnt, psdio->block_transfer_len);\n\n\terr = _sd_read(intfhdl, addr, cnt, mem);\n\n\tif (err)\n\t\treturn _FAIL;\n\treturn _SUCCESS;\n}\n\n \nstatic u32 sdio_write_port(\n\tstruct intf_hdl *intfhdl,\n\tu32 addr,\n\tu32 cnt,\n\tu8 *mem\n)\n{\n\tstruct adapter *adapter;\n\tstruct sdio_data *psdio;\n\ts32 err;\n\tstruct xmit_buf *xmitbuf = (struct xmit_buf *)mem;\n\n\tadapter = intfhdl->padapter;\n\tpsdio = &adapter_to_dvobj(adapter)->intf_data;\n\n\tif (!adapter->hw_init_completed)\n\t\treturn _FAIL;\n\n\tcnt = round_up(cnt, 4);\n\thal_sdio_get_cmd_addr_8723b(adapter, addr, cnt >> 2, &addr);\n\n\tif (cnt > psdio->block_transfer_len)\n\t\tcnt = _RND(cnt, psdio->block_transfer_len);\n\n\terr = sd_write(intfhdl, addr, cnt, xmitbuf->pdata);\n\n\trtw_sctx_done_err(\n\t\t&xmitbuf->sctx,\n\t\terr ? RTW_SCTX_DONE_WRITE_PORT_ERR : RTW_SCTX_DONE_SUCCESS\n\t);\n\n\tif (err)\n\t\treturn _FAIL;\n\treturn _SUCCESS;\n}\n\nvoid sdio_set_intf_ops(struct adapter *adapter, struct _io_ops *ops)\n{\n\tops->_read8 = &sdio_read8;\n\tops->_read16 = &sdio_read16;\n\tops->_read32 = &sdio_read32;\n\tops->_read_mem = &sdio_read_mem;\n\tops->_read_port = &sdio_read_port;\n\n\tops->_write8 = &sdio_write8;\n\tops->_write16 = &sdio_write16;\n\tops->_write32 = &sdio_write32;\n\tops->_writeN = &sdio_writeN;\n\tops->_write_mem = &sdio_write_mem;\n\tops->_write_port = &sdio_write_port;\n}\n\n \nstatic s32 _sdio_local_read(\n\tstruct adapter *adapter,\n\tu32 addr,\n\tu32 cnt,\n\tu8 *buf\n)\n{\n\tstruct intf_hdl *intfhdl;\n\tu8 mac_pwr_ctrl_on;\n\ts32 err;\n\tu8 *tmpbuf;\n\tu32 n;\n\n\tintfhdl = &adapter->iopriv.intf;\n\n\thal_sdio_get_cmd_addr_8723b(adapter, SDIO_LOCAL_DEVICE_ID, addr, &addr);\n\n\trtw_hal_get_hwreg(adapter, HW_VAR_APFM_ON_MAC, &mac_pwr_ctrl_on);\n\tif (!mac_pwr_ctrl_on)\n\t\treturn _sd_cmd52_read(intfhdl, addr, cnt, buf);\n\n\tn = round_up(cnt, 4);\n\ttmpbuf = rtw_malloc(n);\n\tif (!tmpbuf)\n\t\treturn -1;\n\n\terr = _sd_read(intfhdl, addr, n, tmpbuf);\n\tif (!err)\n\t\tmemcpy(buf, tmpbuf, cnt);\n\n\tkfree(tmpbuf);\n\n\treturn err;\n}\n\n \ns32 sdio_local_read(\n\tstruct adapter *adapter,\n\tu32 addr,\n\tu32 cnt,\n\tu8 *buf\n)\n{\n\tstruct intf_hdl *intfhdl;\n\tu8 mac_pwr_ctrl_on;\n\ts32 err;\n\tu8 *tmpbuf;\n\tu32 n;\n\n\tintfhdl = &adapter->iopriv.intf;\n\n\thal_sdio_get_cmd_addr_8723b(adapter, SDIO_LOCAL_DEVICE_ID, addr, &addr);\n\n\trtw_hal_get_hwreg(adapter, HW_VAR_APFM_ON_MAC, &mac_pwr_ctrl_on);\n\tif (\n\t\t(!mac_pwr_ctrl_on) ||\n\t\t(adapter_to_pwrctl(adapter)->fw_current_in_ps_mode)\n\t)\n\t\treturn sd_cmd52_read(intfhdl, addr, cnt, buf);\n\n\tn = round_up(cnt, 4);\n\ttmpbuf = rtw_malloc(n);\n\tif (!tmpbuf)\n\t\treturn -1;\n\n\terr = sd_read(intfhdl, addr, n, tmpbuf);\n\tif (!err)\n\t\tmemcpy(buf, tmpbuf, cnt);\n\n\tkfree(tmpbuf);\n\n\treturn err;\n}\n\n \ns32 sdio_local_write(\n\tstruct adapter *adapter,\n\tu32 addr,\n\tu32 cnt,\n\tu8 *buf\n)\n{\n\tstruct intf_hdl *intfhdl;\n\tu8 mac_pwr_ctrl_on;\n\ts32 err;\n\tu8 *tmpbuf;\n\n\tintfhdl = &adapter->iopriv.intf;\n\n\thal_sdio_get_cmd_addr_8723b(adapter, SDIO_LOCAL_DEVICE_ID, addr, &addr);\n\n\trtw_hal_get_hwreg(adapter, HW_VAR_APFM_ON_MAC, &mac_pwr_ctrl_on);\n\tif (\n\t\t(!mac_pwr_ctrl_on) ||\n\t\t(adapter_to_pwrctl(adapter)->fw_current_in_ps_mode)\n\t)\n\t\treturn sd_cmd52_write(intfhdl, addr, cnt, buf);\n\n\ttmpbuf = rtw_malloc(cnt);\n\tif (!tmpbuf)\n\t\treturn -1;\n\n\tmemcpy(tmpbuf, buf, cnt);\n\n\terr = sd_write(intfhdl, addr, cnt, tmpbuf);\n\n\tkfree(tmpbuf);\n\n\treturn err;\n}\n\nu8 SdioLocalCmd52Read1Byte(struct adapter *adapter, u32 addr)\n{\n\tu8 val = 0;\n\tstruct intf_hdl *intfhdl = &adapter->iopriv.intf;\n\n\thal_sdio_get_cmd_addr_8723b(adapter, SDIO_LOCAL_DEVICE_ID, addr, &addr);\n\tsd_cmd52_read(intfhdl, addr, 1, &val);\n\n\treturn val;\n}\n\nstatic u16 sdio_local_cmd52_read2byte(struct adapter *adapter, u32 addr)\n{\n\t__le16 val = 0;\n\tstruct intf_hdl *intfhdl = &adapter->iopriv.intf;\n\n\thal_sdio_get_cmd_addr_8723b(adapter, SDIO_LOCAL_DEVICE_ID, addr, &addr);\n\tsd_cmd52_read(intfhdl, addr, 2, (u8 *)&val);\n\n\treturn le16_to_cpu(val);\n}\n\nstatic u32 sdio_local_cmd53_read4byte(struct adapter *adapter, u32 addr)\n{\n\n\tu8 mac_pwr_ctrl_on;\n\tu32 val = 0;\n\tstruct intf_hdl *intfhdl = &adapter->iopriv.intf;\n\t__le32 le_tmp;\n\n\thal_sdio_get_cmd_addr_8723b(adapter, SDIO_LOCAL_DEVICE_ID, addr, &addr);\n\trtw_hal_get_hwreg(adapter, HW_VAR_APFM_ON_MAC, &mac_pwr_ctrl_on);\n\tif (!mac_pwr_ctrl_on || adapter_to_pwrctl(adapter)->fw_current_in_ps_mode) {\n\t\tsd_cmd52_read(intfhdl, addr, 4, (u8 *)&le_tmp);\n\t\tval = le32_to_cpu(le_tmp);\n\t} else {\n\t\tval = sd_read32(intfhdl, addr, NULL);\n\t}\n\treturn val;\n}\n\nvoid SdioLocalCmd52Write1Byte(struct adapter *adapter, u32 addr, u8 v)\n{\n\tstruct intf_hdl *intfhdl = &adapter->iopriv.intf;\n\n\thal_sdio_get_cmd_addr_8723b(adapter, SDIO_LOCAL_DEVICE_ID, addr, &addr);\n\tsd_cmd52_write(intfhdl, addr, 1, &v);\n}\n\nstatic void sdio_local_cmd52_write4byte(struct adapter *adapter, u32 addr, u32 v)\n{\n\tstruct intf_hdl *intfhdl = &adapter->iopriv.intf;\n\t__le32 le_tmp;\n\n\thal_sdio_get_cmd_addr_8723b(adapter, SDIO_LOCAL_DEVICE_ID, addr, &addr);\n\tle_tmp = cpu_to_le32(v);\n\tsd_cmd52_write(intfhdl, addr, 4, (u8 *)&le_tmp);\n}\n\nstatic s32 read_interrupt_8723b_sdio(struct adapter *adapter, u32 *phisr)\n{\n\tu32 hisr, himr;\n\tu8 val8, hisr_len;\n\n\tif (!phisr)\n\t\treturn false;\n\n\thimr = GET_HAL_DATA(adapter)->sdio_himr;\n\n\t \n\thisr_len = 0;\n\twhile (himr) {\n\t\thisr_len++;\n\t\thimr >>= 8;\n\t}\n\n\thisr = 0;\n\twhile (hisr_len != 0) {\n\t\thisr_len--;\n\t\tval8 = SdioLocalCmd52Read1Byte(adapter, SDIO_REG_HISR + hisr_len);\n\t\thisr |= (val8 << (8 * hisr_len));\n\t}\n\n\t*phisr = hisr;\n\n\treturn true;\n}\n\n \n \n \n \n \n \n \n \n \nvoid InitInterrupt8723BSdio(struct adapter *adapter)\n{\n\tstruct hal_com_data *haldata;\n\n\thaldata = GET_HAL_DATA(adapter);\n\thaldata->sdio_himr = (u32)(SDIO_HIMR_RX_REQUEST_MSK\t|\n\t\t\t\t   SDIO_HIMR_AVAL_MSK\t\t|\n\t\t\t\t   0);\n}\n\n \n \n \n \n \n \nvoid InitSysInterrupt8723BSdio(struct adapter *adapter)\n{\n\tstruct hal_com_data *haldata;\n\n\thaldata = GET_HAL_DATA(adapter);\n\n\thaldata->SysIntrMask = (0);\n}\n\n \n \n \n \n \n \n \n \n \n \nvoid EnableInterrupt8723BSdio(struct adapter *adapter)\n{\n\tstruct hal_com_data *haldata;\n\t__le32 himr;\n\tu32 tmp;\n\n\thaldata = GET_HAL_DATA(adapter);\n\n\thimr = cpu_to_le32(haldata->sdio_himr);\n\tsdio_local_write(adapter, SDIO_REG_HIMR, 4, (u8 *)&himr);\n\n\t \n\ttmp = rtw_read32(adapter, REG_HSIMR);\n\trtw_write32(adapter, REG_HSIMR, tmp | haldata->SysIntrMask);\n\n\t \n\t \n\t \n\t \n\t \n\trtw_write8(adapter, REG_C2HEVT_CLEAR, C2H_EVT_HOST_CLOSE);\n}\n\n \n \n \n \n \n \n \n \n \nvoid DisableInterrupt8723BSdio(struct adapter *adapter)\n{\n\t__le32 himr;\n\n\thimr = cpu_to_le32(SDIO_HIMR_DISABLED);\n\tsdio_local_write(adapter, SDIO_REG_HIMR, 4, (u8 *)&himr);\n}\n\n \n \n \n \n \n \n \n \n \nu8 CheckIPSStatus(struct adapter *adapter)\n{\n\tif (rtw_read8(adapter, 0x100) == 0xEA)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic struct recv_buf *sd_recv_rxfifo(struct adapter *adapter, u32 size)\n{\n\tu32 readsize, ret;\n\tu8 *readbuf;\n\tstruct recv_priv *recv_priv;\n\tstruct recv_buf\t*recvbuf;\n\n\t \n\t \n\treadsize = round_up(size, 4);\n\n\t \n\trecv_priv = &adapter->recvpriv;\n\trecvbuf = rtw_dequeue_recvbuf(&recv_priv->free_recv_buf_queue);\n\tif (!recvbuf) {\n\t\tnetdev_err(adapter->pnetdev, \"%s: alloc recvbuf FAIL!\\n\",\n\t\t\t   __func__);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (!recvbuf->pskb) {\n\t\tSIZE_PTR tmpaddr = 0;\n\t\tSIZE_PTR alignment = 0;\n\n\t\trecvbuf->pskb = rtw_skb_alloc(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);\n\t\tif (!recvbuf->pskb)\n\t\t\treturn NULL;\n\n\t\trecvbuf->pskb->dev = adapter->pnetdev;\n\n\t\ttmpaddr = (SIZE_PTR)recvbuf->pskb->data;\n\t\talignment = tmpaddr & (RECVBUFF_ALIGN_SZ - 1);\n\t\tskb_reserve(recvbuf->pskb, (RECVBUFF_ALIGN_SZ - alignment));\n\t}\n\n\t \n\treadbuf = recvbuf->pskb->data;\n\tret = sdio_read_port(&adapter->iopriv.intf, WLAN_RX0FF_DEVICE_ID, readsize, readbuf);\n\tif (ret == _FAIL)\n\t\treturn NULL;\n\n\t \n\trecvbuf->len = size;\n\trecvbuf->phead = recvbuf->pskb->head;\n\trecvbuf->pdata = recvbuf->pskb->data;\n\tskb_set_tail_pointer(recvbuf->pskb, size);\n\trecvbuf->ptail = skb_tail_pointer(recvbuf->pskb);\n\trecvbuf->pend = skb_end_pointer(recvbuf->pskb);\n\n\treturn recvbuf;\n}\n\nstatic void sd_rxhandler(struct adapter *adapter, struct recv_buf *recvbuf)\n{\n\tstruct recv_priv *recv_priv;\n\tstruct __queue *pending_queue;\n\n\trecv_priv = &adapter->recvpriv;\n\tpending_queue = &recv_priv->recv_buf_pending_queue;\n\n\t \n\trtw_enqueue_recvbuf(recvbuf, pending_queue);\n\n\t \n\ttasklet_schedule(&recv_priv->recv_tasklet);\n}\n\nvoid sd_int_dpc(struct adapter *adapter)\n{\n\tstruct hal_com_data *hal;\n\tstruct dvobj_priv *dvobj;\n\tstruct intf_hdl *intfhdl = &adapter->iopriv.intf;\n\tstruct pwrctrl_priv *pwrctl;\n\n\thal = GET_HAL_DATA(adapter);\n\tdvobj = adapter_to_dvobj(adapter);\n\tpwrctl = dvobj_to_pwrctl(dvobj);\n\n\tif (hal->sdio_hisr & SDIO_HISR_AVAL) {\n\t\tu8 freepage[4];\n\n\t\t_sdio_local_read(adapter, SDIO_REG_FREE_TXPG, 4, freepage);\n\t\tcomplete(&(adapter->xmitpriv.xmit_comp));\n\t}\n\n\tif (hal->sdio_hisr & SDIO_HISR_CPWM1) {\n\t\tdel_timer_sync(&(pwrctl->pwr_rpwm_timer));\n\n\t\tSdioLocalCmd52Read1Byte(adapter, SDIO_REG_HCPWM1_8723B);\n\n\t\t_set_workitem(&(pwrctl->cpwm_event));\n\t}\n\n\tif (hal->sdio_hisr & SDIO_HISR_TXERR) {\n\t\tu8 *status;\n\t\tu32 addr;\n\n\t\tstatus = rtw_malloc(4);\n\t\tif (status) {\n\t\t\taddr = REG_TXDMA_STATUS;\n\t\t\thal_sdio_get_cmd_addr_8723b(adapter, WLAN_IOREG_DEVICE_ID, addr, &addr);\n\t\t\t_sd_read(intfhdl, addr, 4, status);\n\t\t\t_sd_write(intfhdl, addr, 4, status);\n\t\t\tkfree(status);\n\t\t}\n\t}\n\n\tif (hal->sdio_hisr & SDIO_HISR_C2HCMD) {\n\t\tstruct c2h_evt_hdr_88xx *c2h_evt;\n\n\t\tc2h_evt = rtw_zmalloc(16);\n\t\tif (c2h_evt) {\n\t\t\tif (c2h_evt_read_88xx(adapter, (u8 *)c2h_evt) == _SUCCESS) {\n\t\t\t\tif (c2h_id_filter_ccx_8723b((u8 *)c2h_evt)) {\n\t\t\t\t\t \n\t\t\t\t\trtw_hal_c2h_handler(adapter, (u8 *)c2h_evt);\n\t\t\t\t\tkfree(c2h_evt);\n\t\t\t\t} else {\n\t\t\t\t\trtw_c2h_wk_cmd(adapter, (u8 *)c2h_evt);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkfree(c2h_evt);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\trtw_cbuf_push(adapter->evtpriv.c2h_queue, NULL);\n\t\t\t_set_workitem(&adapter->evtpriv.c2h_wk);\n\t\t}\n\t}\n\n\tif (hal->sdio_hisr & SDIO_HISR_RX_REQUEST) {\n\t\tstruct recv_buf *recvbuf;\n\t\tint alloc_fail_time = 0;\n\t\tu32 hisr;\n\n\t\thal->sdio_hisr ^= SDIO_HISR_RX_REQUEST;\n\t\tdo {\n\t\t\thal->SdioRxFIFOSize = sdio_local_cmd52_read2byte(adapter, SDIO_REG_RX0_REQ_LEN);\n\t\t\tif (hal->SdioRxFIFOSize != 0) {\n\t\t\t\trecvbuf = sd_recv_rxfifo(adapter, hal->SdioRxFIFOSize);\n\t\t\t\tif (recvbuf)\n\t\t\t\t\tsd_rxhandler(adapter, recvbuf);\n\t\t\t\telse {\n\t\t\t\t\talloc_fail_time++;\n\t\t\t\t\tif (alloc_fail_time >= 10)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\thal->SdioRxFIFOSize = 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\n\t\t\thisr = 0;\n\t\t\tread_interrupt_8723b_sdio(adapter, &hisr);\n\t\t\thisr &= SDIO_HISR_RX_REQUEST;\n\t\t\tif (!hisr)\n\t\t\t\tbreak;\n\t\t} while (1);\n\t}\n}\n\nvoid sd_int_hdl(struct adapter *adapter)\n{\n\tstruct hal_com_data *hal;\n\n\tif (\n\t\t(adapter->bDriverStopped) || (adapter->bSurpriseRemoved)\n\t)\n\t\treturn;\n\n\thal = GET_HAL_DATA(adapter);\n\n\thal->sdio_hisr = 0;\n\tread_interrupt_8723b_sdio(adapter, &hal->sdio_hisr);\n\n\tif (hal->sdio_hisr & hal->sdio_himr) {\n\t\tu32 v32;\n\n\t\thal->sdio_hisr &= hal->sdio_himr;\n\n\t\t \n\t\tv32 = hal->sdio_hisr & MASK_SDIO_HISR_CLEAR;\n\t\tif (v32)\n\t\t\tsdio_local_cmd52_write4byte(adapter, SDIO_REG_HISR, v32);\n\n\t\tsd_int_dpc(adapter);\n\t}\n}\n\n \n \n \n \n \n \n \n \n \n \nu8 HalQueryTxBufferStatus8723BSdio(struct adapter *adapter)\n{\n\tstruct hal_com_data *hal;\n\tu32 numof_free_page;\n\n\thal = GET_HAL_DATA(adapter);\n\n\tnumof_free_page = sdio_local_cmd53_read4byte(adapter, SDIO_REG_FREE_TXPG);\n\n\tmemcpy(hal->SdioTxFIFOFreePage, &numof_free_page, 4);\n\n\treturn true;\n}\n\n \n \n \n \nvoid HalQueryTxOQTBufferStatus8723BSdio(struct adapter *adapter)\n{\n\tstruct hal_com_data *haldata = GET_HAL_DATA(adapter);\n\n\thaldata->SdioTxOQTFreeSpace = SdioLocalCmd52Read1Byte(adapter, SDIO_REG_OQT_FREE_PG);\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}