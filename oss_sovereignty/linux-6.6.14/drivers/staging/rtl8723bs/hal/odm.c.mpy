{
  "module_name": "odm.c",
  "hash_id": "99455dc1edae643c37020cc18103f0bab60e4f3ac14a312848e3d739e5caf39a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/hal/odm.c",
  "human_readable_source": "\n \n\n#include \"odm_precomp.h\"\n\n \n\nu32 OFDMSwingTable[OFDM_TABLE_SIZE] = {\n\t0x7f8001fe,  \n\t0x788001e2,  \n\t0x71c001c7,  \n\t0x6b8001ae,  \n\t0x65400195,  \n\t0x5fc0017f,  \n\t0x5a400169,  \n\t0x55400155,  \n\t0x50800142,  \n\t0x4c000130,  \n\t0x47c0011f,  \n\t0x43c0010f,  \n\t0x40000100,  \n\t0x3c8000f2,  \n\t0x390000e4,  \n\t0x35c000d7,  \n\t0x32c000cb,  \n\t0x300000c0,  \n\t0x2d4000b5,  \n\t0x2ac000ab,  \n\t0x288000a2,  \n\t0x26000098,  \n\t0x24000090,  \n\t0x22000088,  \n\t0x20000080,  \n\t0x1e400079,  \n\t0x1c800072,  \n\t0x1b00006c,  \n\t0x19800066,  \n\t0x18000060,  \n\t0x16c0005b,  \n\t0x15800056,  \n\t0x14400051,  \n\t0x1300004c,  \n\t0x12000048,  \n\t0x11000044,  \n\t0x10000040,  \n};\n\nu8 CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8] = {\n\t{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},  \n\t{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},  \n\t{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},  \n\t{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},  \n\t{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},  \n\t{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},  \n\t{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},  \n\t{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},  \n\t{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},  \n\t{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},  \n\t{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},  \n\t{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},  \n\t{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},  \n\t{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},  \n\t{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},  \n\t{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},  \n\t{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},  \n\t{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},  \n\t{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},  \n\t{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},  \n\t{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},  \n\t{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},  \n\t{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},  \n\t{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},  \n\t{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},  \n\t{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},  \n\t{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},  \n\t{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},  \n\t{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},  \n\t{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},  \n\t{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},  \n\t{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},  \n\t{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01}\t \n};\n\nu8 CCKSwingTable_Ch14[CCK_TABLE_SIZE][8] = {\n\t{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},  \n\t{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},  \n\t{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},  \n\t{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},  \n\t{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},  \n\t{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},  \n\t{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},  \n\t{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},  \n\t{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},  \n\t{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},  \n\t{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},  \n\t{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},  \n\t{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},  \n\t{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},  \n\t{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},  \n\t{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},  \n\t{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},  \n\t{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},  \n\t{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},  \n\t{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},  \n\t{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},  \n\t{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},  \n\t{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},  \n\t{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00}\t \n};\n\nu32 OFDMSwingTable_New[OFDM_TABLE_SIZE] = {\n\t0x0b40002d,  \n\t0x0c000030,  \n\t0x0cc00033,  \n\t0x0d800036,  \n\t0x0e400039,  \n\t0x0f00003c,  \n\t0x10000040,  \n\t0x11000044,  \n\t0x12000048,  \n\t0x1300004c,  \n\t0x14400051,  \n\t0x15800056,  \n\t0x16c0005b,  \n\t0x18000060,  \n\t0x19800066,  \n\t0x1b00006c,  \n\t0x1c800072,  \n\t0x1e400079,  \n\t0x20000080,  \n\t0x22000088,  \n\t0x24000090,  \n\t0x26000098,  \n\t0x288000a2,  \n\t0x2ac000ab,  \n\t0x2d4000b5,  \n\t0x300000c0,  \n\t0x32c000cb,  \n\t0x35c000d7,  \n\t0x390000e4,  \n\t0x3c8000f2,  \n\t0x40000100,  \n\t0x43c0010f,  \n\t0x47c0011f,  \n\t0x4c000130,  \n\t0x50800142,  \n\t0x55400155,  \n\t0x5a400169,  \n\t0x5fc0017f,  \n\t0x65400195,  \n\t0x6b8001ae,  \n\t0x71c001c7,  \n\t0x788001e2,  \n\t0x7f8001fe   \n};\n\nu8 CCKSwingTable_Ch1_Ch13_New[CCK_TABLE_SIZE][8] = {\n\t{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01},  \n\t{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},  \n\t{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},  \n\t{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},  \n\t{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},  \n\t{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},  \n\t{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},  \n\t{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},  \n\t{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},  \n\t{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},  \n\t{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},  \n\t{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},  \n\t{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},  \n\t{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},  \n\t{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},  \n\t{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},  \n\t{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},  \n\t{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},  \n\t{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},  \n\t{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},  \n\t{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},  \n\t{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},  \n\t{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},  \n\t{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},  \n\t{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},  \n\t{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},  \n\t{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},  \n\t{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},  \n\t{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},  \n\t{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},  \n\t{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},  \n\t{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},  \n\t{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04}\t \n};\n\nu8 CCKSwingTable_Ch14_New[CCK_TABLE_SIZE][8] = {\n\t{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00},  \n\t{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},  \n\t{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},  \n\t{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},  \n\t{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},  \n\t{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},  \n\t{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},  \n\t{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},  \n\t{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},  \n\t{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},  \n\t{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},  \n\t{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},  \n\t{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},  \n\t{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},  \n\t{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},  \n\t{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},  \n\t{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},  \n\t{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},  \n\t{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},  \n\t{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},  \n\t{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},  \n\t{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},  \n\t{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},  \n\t{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00}\t \n};\n\nu32 TxScalingTable_Jaguar[TXSCALE_TABLE_SIZE] = {\n\t0x081,  \n\t0x088,  \n\t0x090,  \n\t0x099,  \n\t0x0A2,  \n\t0x0AC,  \n\t0x0B6,  \n\t0x0C0,  \n\t0x0CC,  \n\t0x0D8,  \n\t0x0E5,  \n\t0x0F2,  \n\t0x101,  \n\t0x110,  \n\t0x120,  \n\t0x131,  \n\t0x143,  \n\t0x156,  \n\t0x16A,  \n\t0x180,  \n\t0x197,  \n\t0x1AF,  \n\t0x1C8,  \n\t0x1E3,  \n\t0x200,  \n\t0x21E,  \n\t0x23E,  \n\t0x261,  \n\t0x285,  \n\t0x2AB,  \n\t0x2D3,  \n\t0x2FE,  \n\t0x32B,  \n\t0x35C,  \n\t0x38E,  \n\t0x3C4,  \n\t0x3FE   \n};\n\n \n\nstatic void odm_CommonInfoSelfInit(struct dm_odm_t *pDM_Odm)\n{\n\tpDM_Odm->bCckHighPower = (bool) PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG(CCK_RPT_FORMAT, pDM_Odm), ODM_BIT(CCK_RPT_FORMAT, pDM_Odm));\n\tpDM_Odm->RFPathRxEnable = (u8) PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG(BB_RX_PATH, pDM_Odm), ODM_BIT(BB_RX_PATH, pDM_Odm));\n\n\tpDM_Odm->TxRate = 0xFF;\n}\n\nstatic void odm_CommonInfoSelfUpdate(struct dm_odm_t *pDM_Odm)\n{\n\tu8 EntryCnt = 0;\n\tu8 i;\n\tPSTA_INFO_T\tpEntry;\n\n\tif (*(pDM_Odm->pBandWidth) == ODM_BW40M) {\n\t\tif (*(pDM_Odm->pSecChOffset) == 1)\n\t\t\tpDM_Odm->ControlChannel = *(pDM_Odm->pChannel)-2;\n\t\telse if (*(pDM_Odm->pSecChOffset) == 2)\n\t\t\tpDM_Odm->ControlChannel = *(pDM_Odm->pChannel)+2;\n\t} else\n\t\tpDM_Odm->ControlChannel = *(pDM_Odm->pChannel);\n\n\tfor (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {\n\t\tpEntry = pDM_Odm->pODM_StaInfo[i];\n\t\tif (IS_STA_VALID(pEntry))\n\t\t\tEntryCnt++;\n\t}\n\n\tif (EntryCnt == 1)\n\t\tpDM_Odm->bOneEntryOnly = true;\n\telse\n\t\tpDM_Odm->bOneEntryOnly = false;\n}\n\nstatic void odm_CmnInfoInit_Debug(struct dm_odm_t *pDM_Odm)\n{\n}\n\nstatic void odm_BasicDbgMessage(struct dm_odm_t *pDM_Odm)\n{\n}\n\n \n \n \n \n \n \n\nstatic void odm_RateAdaptiveMaskInit(struct dm_odm_t *pDM_Odm)\n{\n\tstruct odm_rate_adaptive *pOdmRA = &pDM_Odm->RateAdaptive;\n\n\tpOdmRA->Type = DM_Type_ByDriver;\n\tif (pOdmRA->Type == DM_Type_ByDriver)\n\t\tpDM_Odm->bUseRAMask = true;\n\telse\n\t\tpDM_Odm->bUseRAMask = false;\n\n\tpOdmRA->RATRState = DM_RATR_STA_INIT;\n\tpOdmRA->LdpcThres = 35;\n\tpOdmRA->bUseLdpc = false;\n\tpOdmRA->HighRSSIThresh = 50;\n\tpOdmRA->LowRSSIThresh = 20;\n}\n\nu32 ODM_Get_Rate_Bitmap(\n\tstruct dm_odm_t *pDM_Odm,\n\tu32 macid,\n\tu32 ra_mask,\n\tu8 rssi_level\n)\n{\n\tPSTA_INFO_T\tpEntry;\n\tu32 rate_bitmap = 0;\n\tu8 WirelessMode;\n\n\tpEntry = pDM_Odm->pODM_StaInfo[macid];\n\tif (!IS_STA_VALID(pEntry))\n\t\treturn ra_mask;\n\n\tWirelessMode = pEntry->wireless_mode;\n\n\tswitch (WirelessMode) {\n\tcase ODM_WM_B:\n\t\tif (ra_mask & 0x0000000c)\t\t \n\t\t\trate_bitmap = 0x0000000d;\n\t\telse\n\t\t\trate_bitmap = 0x0000000f;\n\t\tbreak;\n\n\tcase (ODM_WM_G):\n\t\tif (rssi_level == DM_RATR_STA_HIGH)\n\t\t\trate_bitmap = 0x00000f00;\n\t\telse\n\t\t\trate_bitmap = 0x00000ff0;\n\t\tbreak;\n\n\tcase (ODM_WM_B|ODM_WM_G):\n\t\tif (rssi_level == DM_RATR_STA_HIGH)\n\t\t\trate_bitmap = 0x00000f00;\n\t\telse if (rssi_level == DM_RATR_STA_MIDDLE)\n\t\t\trate_bitmap = 0x00000ff0;\n\t\telse\n\t\t\trate_bitmap = 0x00000ff5;\n\t\tbreak;\n\n\tcase (ODM_WM_B|ODM_WM_G|ODM_WM_N24G):\n\tcase (ODM_WM_B|ODM_WM_N24G):\n\tcase (ODM_WM_G|ODM_WM_N24G):\n\t\tif (rssi_level == DM_RATR_STA_HIGH)\n\t\t\trate_bitmap = 0x000f0000;\n\t\telse if (rssi_level == DM_RATR_STA_MIDDLE)\n\t\t\trate_bitmap = 0x000ff000;\n\t\telse {\n\t\t\tif (*(pDM_Odm->pBandWidth) == ODM_BW40M)\n\t\t\t\trate_bitmap = 0x000ff015;\n\t\t\telse\n\t\t\t\trate_bitmap = 0x000ff005;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trate_bitmap = 0x0fffffff;\n\t\tbreak;\n\t}\n\n\treturn ra_mask & rate_bitmap;\n\n}\n\nstatic void odm_RefreshRateAdaptiveMaskCE(struct dm_odm_t *pDM_Odm)\n{\n\tu8 i;\n\tstruct adapter *padapter =  pDM_Odm->Adapter;\n\n\tif (padapter->bDriverStopped) {\n\t\treturn;\n\t}\n\n\tif (!pDM_Odm->bUseRAMask) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {\n\t\tPSTA_INFO_T pstat = pDM_Odm->pODM_StaInfo[i];\n\n\t\tif (IS_STA_VALID(pstat)) {\n\t\t\tif (is_multicast_ether_addr(pstat->hwaddr))   \n\t\t\t\tcontinue;\n\n\t\t\tif (true == ODM_RAStateCheck(pDM_Odm, pstat->rssi_stat.UndecoratedSmoothedPWDB, false, &pstat->rssi_level)) {\n\t\t\t\t \n\t\t\t\trtw_hal_update_ra_mask(pstat, pstat->rssi_level);\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n \nstatic void odm_RefreshRateAdaptiveMask(struct dm_odm_t *pDM_Odm)\n{\n\n\tif (!(pDM_Odm->SupportAbility & ODM_BB_RA_MASK)) {\n\t\treturn;\n\t}\n\todm_RefreshRateAdaptiveMaskCE(pDM_Odm);\n}\n\n \n \nbool ODM_RAStateCheck(\n\tstruct dm_odm_t *pDM_Odm,\n\ts32 RSSI,\n\tbool bForceUpdate,\n\tu8 *pRATRState\n)\n{\n\tstruct odm_rate_adaptive *pRA = &pDM_Odm->RateAdaptive;\n\tconst u8 GoUpGap = 5;\n\tu8 HighRSSIThreshForRA = pRA->HighRSSIThresh;\n\tu8 LowRSSIThreshForRA = pRA->LowRSSIThresh;\n\tu8 RATRState;\n\n\t \n\t \n\t \n\tswitch (*pRATRState) {\n\tcase DM_RATR_STA_INIT:\n\tcase DM_RATR_STA_HIGH:\n\t\tbreak;\n\n\tcase DM_RATR_STA_MIDDLE:\n\t\tHighRSSIThreshForRA += GoUpGap;\n\t\tbreak;\n\n\tcase DM_RATR_STA_LOW:\n\t\tHighRSSIThreshForRA += GoUpGap;\n\t\tLowRSSIThreshForRA += GoUpGap;\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_dbg(pDM_Odm->Adapter->pnetdev,\n\t\t\t   \"wrong rssi level setting %d !\", *pRATRState);\n\t\tbreak;\n\t}\n\n\t \n\tif (RSSI > HighRSSIThreshForRA)\n\t\tRATRState = DM_RATR_STA_HIGH;\n\telse if (RSSI > LowRSSIThreshForRA)\n\t\tRATRState = DM_RATR_STA_MIDDLE;\n\telse\n\t\tRATRState = DM_RATR_STA_LOW;\n\t \n\n\tif (*pRATRState != RATRState || bForceUpdate) {\n\t\t*pRATRState = RATRState;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \n\n \n \n \n\nstatic void odm_RSSIMonitorInit(struct dm_odm_t *pDM_Odm)\n{\n\tstruct ra_t *pRA_Table = &pDM_Odm->DM_RA_Table;\n\n\tpRA_Table->firstconnect = false;\n\n}\n\nstatic void FindMinimumRSSI(struct adapter *padapter)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\tstruct dm_priv *pdmpriv = &pHalData->dmpriv;\n\tstruct dm_odm_t *pDM_Odm = &pHalData->odmpriv;\n\n\t \n\n\tif (\n\t\t(pDM_Odm->bLinked != true) &&\n\t\t(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0)\n\t) {\n\t\tpdmpriv->MinUndecoratedPWDBForDM = 0;\n\t} else\n\t\tpdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;\n}\n\nstatic void odm_RSSIMonitorCheckCE(struct dm_odm_t *pDM_Odm)\n{\n\tstruct adapter *Adapter = pDM_Odm->Adapter;\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(Adapter);\n\tstruct dm_priv *pdmpriv = &pHalData->dmpriv;\n\tint i;\n\tint tmpEntryMaxPWDB = 0, tmpEntryMinPWDB = 0xff;\n\tu8 sta_cnt = 0;\n\tu32 PWDB_rssi[NUM_STA] = {0}; \n\tstruct ra_t *pRA_Table = &pDM_Odm->DM_RA_Table;\n\n\tif (pDM_Odm->bLinked != true)\n\t\treturn;\n\n\tpRA_Table->firstconnect = pDM_Odm->bLinked;\n\n\t \n\t{\n\t\tstruct sta_info *psta;\n\n\t\tfor (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {\n\t\t\tpsta = pDM_Odm->pODM_StaInfo[i];\n\t\t\tif (IS_STA_VALID(psta)) {\n\t\t\t\tif (is_multicast_ether_addr(psta->hwaddr))   \n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (psta->rssi_stat.UndecoratedSmoothedPWDB == (-1))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)\n\t\t\t\t\ttmpEntryMinPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;\n\n\t\t\t\tif (psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)\n\t\t\t\t\ttmpEntryMaxPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;\n\n\t\t\t\tif (psta->rssi_stat.UndecoratedSmoothedPWDB != (-1))\n\t\t\t\t\tPWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16));\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tfor (i = 0; i < sta_cnt; i++) {\n\t\t\tif (PWDB_rssi[i] != (0)) {\n\t\t\t\tif (pHalData->fw_ractrl == true) \n\t\t\t\t\trtl8723b_set_rssi_cmd(Adapter, (u8 *)(&PWDB_rssi[i]));\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tif (tmpEntryMaxPWDB != 0)\t \n\t\tpdmpriv->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;\n\telse\n\t\tpdmpriv->EntryMaxUndecoratedSmoothedPWDB = 0;\n\n\tif (tmpEntryMinPWDB != 0xff)  \n\t\tpdmpriv->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;\n\telse\n\t\tpdmpriv->EntryMinUndecoratedSmoothedPWDB = 0;\n\n\tFindMinimumRSSI(Adapter); \n\n\tpDM_Odm->RSSI_Min = pdmpriv->MinUndecoratedPWDBForDM;\n\t \n}\n\nstatic void odm_RSSIMonitorCheck(struct dm_odm_t *pDM_Odm)\n{\n\tif (!(pDM_Odm->SupportAbility & ODM_BB_RSSI_MONITOR))\n\t\treturn;\n\n\todm_RSSIMonitorCheckCE(pDM_Odm);\n\n}\t \n\n \n \n \nstatic void odm_SwAntDetectInit(struct dm_odm_t *pDM_Odm)\n{\n\tstruct swat_t *pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;\n\n\tpDM_SWAT_Table->SWAS_NoLink_BK_Reg92c = rtw_read32(pDM_Odm->Adapter, rDPDT_control);\n\tpDM_SWAT_Table->PreAntenna = MAIN_ANT;\n\tpDM_SWAT_Table->CurAntenna = MAIN_ANT;\n\tpDM_SWAT_Table->SWAS_NoLink_State = 0;\n}\n\n \n \n \n\nstatic u8 getSwingIndex(struct dm_odm_t *pDM_Odm)\n{\n\tstruct adapter *Adapter = pDM_Odm->Adapter;\n\tu8 i = 0;\n\tu32 bbSwing;\n\tu32 swingTableSize;\n\tu32 *pSwingTable;\n\n\tbbSwing = PHY_QueryBBReg(Adapter, rOFDM0_XATxIQImbalance, 0xFFC00000);\n\n\tpSwingTable = OFDMSwingTable_New;\n\tswingTableSize = OFDM_TABLE_SIZE;\n\n\tfor (i = 0; i < swingTableSize; ++i) {\n\t\tu32 tableValue = pSwingTable[i];\n\n\t\tif (tableValue >= 0x100000)\n\t\t\ttableValue >>= 22;\n\t\tif (bbSwing == tableValue)\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nvoid odm_TXPowerTrackingInit(struct dm_odm_t *pDM_Odm)\n{\n\tu8 defaultSwingIndex = getSwingIndex(pDM_Odm);\n\tu8 p = 0;\n\tstruct adapter *Adapter = pDM_Odm->Adapter;\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\n\n\n\tstruct dm_priv *pdmpriv = &pHalData->dmpriv;\n\n\tpdmpriv->bTXPowerTracking = true;\n\tpdmpriv->TXPowercount = 0;\n\tpdmpriv->bTXPowerTrackingInit = false;\n\n\tif (*(pDM_Odm->mp_mode) != 1)\n\t\tpdmpriv->TxPowerTrackControl = true;\n\telse\n\t\tpdmpriv->TxPowerTrackControl = false;\n\n\t \n\tpDM_Odm->RFCalibrateInfo.ThermalValue = pHalData->EEPROMThermalMeter;\n\tpDM_Odm->RFCalibrateInfo.ThermalValue_IQK = pHalData->EEPROMThermalMeter;\n\tpDM_Odm->RFCalibrateInfo.ThermalValue_LCK = pHalData->EEPROMThermalMeter;\n\n\t \n\tpDM_Odm->DefaultOfdmIndex = (defaultSwingIndex >= OFDM_TABLE_SIZE) ? 30 : defaultSwingIndex;\n\tpDM_Odm->DefaultCckIndex = 20;\n\n\tpDM_Odm->BbSwingIdxCckBase = pDM_Odm->DefaultCckIndex;\n\tpDM_Odm->RFCalibrateInfo.CCK_index = pDM_Odm->DefaultCckIndex;\n\n\tfor (p = RF_PATH_A; p < MAX_RF_PATH; ++p) {\n\t\tpDM_Odm->BbSwingIdxOfdmBase[p] = pDM_Odm->DefaultOfdmIndex;\n\t\tpDM_Odm->RFCalibrateInfo.OFDM_index[p] = pDM_Odm->DefaultOfdmIndex;\n\t\tpDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p] = 0;\n\t\tpDM_Odm->RFCalibrateInfo.DeltaPowerIndexLast[p] = 0;\n\t\tpDM_Odm->RFCalibrateInfo.PowerIndexOffset[p] = 0;\n\t}\n\n}\n\nvoid ODM_TXPowerTrackingCheck(struct dm_odm_t *pDM_Odm)\n{\n\tstruct adapter *Adapter = pDM_Odm->Adapter;\n\n\tif (!(pDM_Odm->SupportAbility & ODM_RF_TX_PWR_TRACK))\n\t\treturn;\n\n\tif (!pDM_Odm->RFCalibrateInfo.TM_Trigger) {  \n\t\tPHY_SetRFReg(pDM_Odm->Adapter, RF_PATH_A, RF_T_METER_NEW, (BIT17 | BIT16), 0x03);\n\n\t\tpDM_Odm->RFCalibrateInfo.TM_Trigger = 1;\n\t\treturn;\n\t} else {\n\t\tODM_TXPowerTrackingCallback_ThermalMeter(Adapter);\n\t\tpDM_Odm->RFCalibrateInfo.TM_Trigger = 0;\n\t}\n}\n\n \n \n \n\n \n \n \nvoid ODM_DMInit(struct dm_odm_t *pDM_Odm)\n{\n\n\todm_CommonInfoSelfInit(pDM_Odm);\n\todm_CmnInfoInit_Debug(pDM_Odm);\n\todm_DIGInit(pDM_Odm);\n\todm_NHMCounterStatisticsInit(pDM_Odm);\n\todm_AdaptivityInit(pDM_Odm);\n\todm_RateAdaptiveMaskInit(pDM_Odm);\n\tODM_CfoTrackingInit(pDM_Odm);\n\tODM_EdcaTurboInit(pDM_Odm);\n\todm_RSSIMonitorInit(pDM_Odm);\n\todm_TXPowerTrackingInit(pDM_Odm);\n\n\tODM_ClearTxPowerTrackingState(pDM_Odm);\n\n\todm_DynamicBBPowerSavingInit(pDM_Odm);\n\todm_DynamicTxPowerInit(pDM_Odm);\n\n\todm_SwAntDetectInit(pDM_Odm);\n}\n\n \n \n \n \n \nvoid ODM_DMWatchdog(struct dm_odm_t *pDM_Odm)\n{\n\todm_CommonInfoSelfUpdate(pDM_Odm);\n\todm_BasicDbgMessage(pDM_Odm);\n\todm_FalseAlarmCounterStatistics(pDM_Odm);\n\todm_NHMCounterStatistics(pDM_Odm);\n\n\todm_RSSIMonitorCheck(pDM_Odm);\n\n\t \n\t \n\t \n\t \n\tif ((adapter_to_pwrctl(pDM_Odm->Adapter)->pwr_mode != PS_MODE_ACTIVE)  \n\t\t \n\t\t \n\t\t \n\t\t \n\t) {\n\t\t\todm_DIGbyRSSI_LPS(pDM_Odm);\n\t} else\n\t\todm_DIG(pDM_Odm);\n\n\t{\n\t\tstruct dig_t *pDM_DigTable = &pDM_Odm->DM_DigTable;\n\n\t\todm_Adaptivity(pDM_Odm, pDM_DigTable->CurIGValue);\n\t}\n\todm_CCKPacketDetectionThresh(pDM_Odm);\n\n\tif (*(pDM_Odm->pbPowerSaving) == true)\n\t\treturn;\n\n\n\todm_RefreshRateAdaptiveMask(pDM_Odm);\n\todm_EdcaTurboCheck(pDM_Odm);\n\tODM_CfoTracking(pDM_Odm);\n\n\tODM_TXPowerTrackingCheck(pDM_Odm);\n\n\t \n\n\t \n\t \n\tpDM_Odm->PhyDbgInfo.NumQryBeaconPkt = 0;\n}\n\n\n \n \n \nvoid ODM_CmnInfoInit(struct dm_odm_t *pDM_Odm, enum odm_cmninfo_e CmnInfo, u32 Value)\n{\n\t \n\t \n\t \n\tswitch (CmnInfo) {\n\t \n\t \n\t \n\tcase ODM_CMNINFO_ABILITY:\n\t\tpDM_Odm->SupportAbility = (u32)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_PLATFORM:\n\t\tpDM_Odm->SupportPlatform = (u8)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_INTERFACE:\n\t\tpDM_Odm->SupportInterface = (u8)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_IC_TYPE:\n\t\tpDM_Odm->SupportICType = Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_CUT_VER:\n\t\tpDM_Odm->CutVersion = (u8)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_FAB_VER:\n\t\tpDM_Odm->FabVersion = (u8)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_RFE_TYPE:\n\t\tpDM_Odm->RFEType = (u8)Value;\n\t\tbreak;\n\n\tcase    ODM_CMNINFO_RF_ANTENNA_TYPE:\n\t\tpDM_Odm->AntDivType = (u8)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_PACKAGE_TYPE:\n\t\tpDM_Odm->PackageType = (u8)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_EXT_LNA:\n\t\tpDM_Odm->ExtLNA = (u8)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_EXT_PA:\n\t\tpDM_Odm->ExtPA = (u8)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_GPA:\n\t\tpDM_Odm->TypeGPA = (enum odm_type_gpa_e)Value;\n\t\tbreak;\n\tcase ODM_CMNINFO_APA:\n\t\tpDM_Odm->TypeAPA = (enum odm_type_apa_e)Value;\n\t\tbreak;\n\tcase ODM_CMNINFO_GLNA:\n\t\tpDM_Odm->TypeGLNA = (enum odm_type_glna_e)Value;\n\t\tbreak;\n\tcase ODM_CMNINFO_ALNA:\n\t\tpDM_Odm->TypeALNA = (enum odm_type_alna_e)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_EXT_TRSW:\n\t\tpDM_Odm->ExtTRSW = (u8)Value;\n\t\tbreak;\n\tcase ODM_CMNINFO_PATCH_ID:\n\t\tpDM_Odm->PatchID = (u8)Value;\n\t\tbreak;\n\tcase ODM_CMNINFO_BINHCT_TEST:\n\t\tpDM_Odm->bInHctTest = (bool)Value;\n\t\tbreak;\n\tcase ODM_CMNINFO_BWIFI_TEST:\n\t\tpDM_Odm->bWIFITest = (bool)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_SMART_CONCURRENT:\n\t\tpDM_Odm->bDualMacSmartConcurrent = (bool)Value;\n\t\tbreak;\n\n\t \n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n}\n\n\nvoid ODM_CmnInfoHook(struct dm_odm_t *pDM_Odm, enum odm_cmninfo_e CmnInfo, void *pValue)\n{\n\t \n\t \n\t \n\tswitch (CmnInfo) {\n\t \n\t \n\t \n\tcase ODM_CMNINFO_MAC_PHY_MODE:\n\t\tpDM_Odm->pMacPhyMode = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_TX_UNI:\n\t\tpDM_Odm->pNumTxBytesUnicast = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_RX_UNI:\n\t\tpDM_Odm->pNumRxBytesUnicast = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_WM_MODE:\n\t\tpDM_Odm->pwirelessmode = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_SEC_CHNL_OFFSET:\n\t\tpDM_Odm->pSecChOffset = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_SEC_MODE:\n\t\tpDM_Odm->pSecurity = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_BW:\n\t\tpDM_Odm->pBandWidth = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_CHNL:\n\t\tpDM_Odm->pChannel = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_DMSP_GET_VALUE:\n\t\tpDM_Odm->pbGetValueFromOtherMac = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_BUDDY_ADAPTOR:\n\t\tpDM_Odm->pBuddyAdapter = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_DMSP_IS_MASTER:\n\t\tpDM_Odm->pbMasterOfDMSP = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_SCAN:\n\t\tpDM_Odm->pbScanInProcess = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_POWER_SAVING:\n\t\tpDM_Odm->pbPowerSaving = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_ONE_PATH_CCA:\n\t\tpDM_Odm->pOnePathCCA = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_DRV_STOP:\n\t\tpDM_Odm->pbDriverStopped =  pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_PNP_IN:\n\t\tpDM_Odm->pbDriverIsGoingToPnpSetPowerSleep =  pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_INIT_ON:\n\t\tpDM_Odm->pinit_adpt_in_progress =  pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_ANT_TEST:\n\t\tpDM_Odm->pAntennaTest =  pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_NET_CLOSED:\n\t\tpDM_Odm->pbNet_closed = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_FORCED_RATE:\n\t\tpDM_Odm->pForcedDataRate = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_FORCED_IGI_LB:\n\t\tpDM_Odm->pu1ForcedIgiLb = pValue;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_MP_MODE:\n\t\tpDM_Odm->mp_mode = pValue;\n\t\tbreak;\n\n\t \n\t \n\t \n\n\t \n\t \n\n\t \n\t \n\t \n\n\t \n\t \n\t \n\n\t \n\t \n\t \n\t \n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n}\n\n\nvoid ODM_CmnInfoPtrArrayHook(\n\tstruct dm_odm_t *pDM_Odm,\n\tenum odm_cmninfo_e CmnInfo,\n\tu16 Index,\n\tvoid *pValue\n)\n{\n\t \n\t \n\t \n\tswitch (CmnInfo) {\n\t \n\t \n\t \n\tcase ODM_CMNINFO_STA_STATUS:\n\t\tpDM_Odm->pODM_StaInfo[Index] = (PSTA_INFO_T)pValue;\n\t\tbreak;\n\t \n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n}\n\n\n \n \n \nvoid ODM_CmnInfoUpdate(struct dm_odm_t *pDM_Odm, u32 CmnInfo, u64 Value)\n{\n\t \n\t \n\t \n\tswitch (CmnInfo) {\n\tcase ODM_CMNINFO_LINK_IN_PROGRESS:\n\t\tpDM_Odm->bLinkInProcess = (bool)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_ABILITY:\n\t\tpDM_Odm->SupportAbility = (u32)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_WIFI_DIRECT:\n\t\tpDM_Odm->bWIFI_Direct = (bool)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_WIFI_DISPLAY:\n\t\tpDM_Odm->bWIFI_Display = (bool)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_LINK:\n\t\tpDM_Odm->bLinked = (bool)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_STATION_STATE:\n\t\tpDM_Odm->bsta_state = (bool)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_RSSI_MIN:\n\t\tpDM_Odm->RSSI_Min = (u8)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_RA_THRESHOLD_HIGH:\n\t\tpDM_Odm->RateAdaptive.HighRSSIThresh = (u8)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_RA_THRESHOLD_LOW:\n\t\tpDM_Odm->RateAdaptive.LowRSSIThresh = (u8)Value;\n\t\tbreak;\n\t \n\tcase ODM_CMNINFO_BT_ENABLED:\n\t\tpDM_Odm->bBtEnabled = (bool)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_BT_HS_CONNECT_PROCESS:\n\t\tpDM_Odm->bBtConnectProcess = (bool)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_BT_HS_RSSI:\n\t\tpDM_Odm->btHsRssi = (u8)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_BT_OPERATION:\n\t\tpDM_Odm->bBtHsOperation = (bool)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_BT_LIMITED_DIG:\n\t\tpDM_Odm->bBtLimitedDig = (bool)Value;\n\t\tbreak;\n\n\tcase ODM_CMNINFO_BT_DISABLE_EDCA:\n\t\tpDM_Odm->bBtDisableEdcaTurbo = (bool)Value;\n\t\tbreak;\n\n \n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\n}\n\n \n \n \n \n\n \n\n \n\n \n \n \n\n \n\n \n \n \n\n \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}