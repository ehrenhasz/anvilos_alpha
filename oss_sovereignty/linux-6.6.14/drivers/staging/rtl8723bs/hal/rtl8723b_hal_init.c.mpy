{
  "module_name": "rtl8723b_hal_init.c",
  "hash_id": "7d8c2340eab2d6711a6bad67167f32b42c2152ffe5e46e8800413f048a8ec4b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/hal/rtl8723b_hal_init.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <rtl8723b_hal.h>\n#include \"hal_com_h2c.h\"\n\nstatic void _FWDownloadEnable(struct adapter *padapter, bool enable)\n{\n\tu8 tmp, count = 0;\n\n\tif (enable) {\n\t\t \n\t\ttmp = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\n\t\trtw_write8(padapter, REG_SYS_FUNC_EN+1, tmp|0x04);\n\n\t\ttmp = rtw_read8(padapter, REG_MCUFWDL);\n\t\trtw_write8(padapter, REG_MCUFWDL, tmp|0x01);\n\n\t\tdo {\n\t\t\ttmp = rtw_read8(padapter, REG_MCUFWDL);\n\t\t\tif (tmp & 0x01)\n\t\t\t\tbreak;\n\t\t\trtw_write8(padapter, REG_MCUFWDL, tmp|0x01);\n\t\t\tmsleep(1);\n\t\t} while (count++ < 100);\n\n\t\t \n\t\ttmp = rtw_read8(padapter, REG_MCUFWDL+2);\n\t\trtw_write8(padapter, REG_MCUFWDL+2, tmp&0xf7);\n\t} else {\n\t\t \n\t\ttmp = rtw_read8(padapter, REG_MCUFWDL);\n\t\trtw_write8(padapter, REG_MCUFWDL, tmp&0xfe);\n\t}\n}\n\nstatic int _BlockWrite(struct adapter *padapter, void *buffer, u32 buffSize)\n{\n\tint ret = _SUCCESS;\n\n\tu32 blockSize_p1 = 4;  \n\tu32 blockSize_p2 = 8;  \n\tu32 blockSize_p3 = 1;  \n\tu32 blockCount_p1 = 0, blockCount_p2 = 0, blockCount_p3 = 0;\n\tu32 remainSize_p1 = 0, remainSize_p2 = 0;\n\tu8 *bufferPtr = buffer;\n\tu32 i = 0, offset = 0;\n\n \n\n\t \n\tblockCount_p1 = buffSize / blockSize_p1;\n\tremainSize_p1 = buffSize % blockSize_p1;\n\n\tfor (i = 0; i < blockCount_p1; i++) {\n\t\tret = rtw_write32(padapter, (FW_8723B_START_ADDRESS + i * blockSize_p1), *((u32 *)(bufferPtr + i * blockSize_p1)));\n\t\tif (ret == _FAIL) {\n\t\t\tprintk(\"====>%s %d i:%d\\n\", __func__, __LINE__, i);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\tif (remainSize_p1) {\n\t\toffset = blockCount_p1 * blockSize_p1;\n\n\t\tblockCount_p2 = remainSize_p1/blockSize_p2;\n\t\tremainSize_p2 = remainSize_p1%blockSize_p2;\n\t}\n\n\t \n\tif (remainSize_p2) {\n\t\toffset = (blockCount_p1 * blockSize_p1) + (blockCount_p2 * blockSize_p2);\n\n\t\tblockCount_p3 = remainSize_p2 / blockSize_p3;\n\n\t\tfor (i = 0; i < blockCount_p3; i++) {\n\t\t\tret = rtw_write8(padapter, (FW_8723B_START_ADDRESS + offset + i), *(bufferPtr + offset + i));\n\n\t\t\tif (ret == _FAIL) {\n\t\t\t\tprintk(\"====>%s %d i:%d\\n\", __func__, __LINE__, i);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\nexit:\n\treturn ret;\n}\n\nstatic int _PageWrite(\n\tstruct adapter *padapter,\n\tu32 page,\n\tvoid *buffer,\n\tu32 size\n)\n{\n\tu8 value8;\n\tu8 u8Page = (u8) (page & 0x07);\n\n\tvalue8 = (rtw_read8(padapter, REG_MCUFWDL+2) & 0xF8) | u8Page;\n\trtw_write8(padapter, REG_MCUFWDL+2, value8);\n\n\treturn _BlockWrite(padapter, buffer, size);\n}\n\nstatic int _WriteFW(struct adapter *padapter, void *buffer, u32 size)\n{\n\t \n\t \n\tint ret = _SUCCESS;\n\tu32 pageNums, remainSize;\n\tu32 page, offset;\n\tu8 *bufferPtr = buffer;\n\n\tpageNums = size / MAX_DLFW_PAGE_SIZE;\n\tremainSize = size % MAX_DLFW_PAGE_SIZE;\n\n\tfor (page = 0; page < pageNums; page++) {\n\t\toffset = page * MAX_DLFW_PAGE_SIZE;\n\t\tret = _PageWrite(padapter, page, bufferPtr+offset, MAX_DLFW_PAGE_SIZE);\n\n\t\tif (ret == _FAIL) {\n\t\t\tprintk(\"====>%s %d\\n\", __func__, __LINE__);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (remainSize) {\n\t\toffset = pageNums * MAX_DLFW_PAGE_SIZE;\n\t\tpage = pageNums;\n\t\tret = _PageWrite(padapter, page, bufferPtr+offset, remainSize);\n\n\t\tif (ret == _FAIL) {\n\t\t\tprintk(\"====>%s %d\\n\", __func__, __LINE__);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\treturn ret;\n}\n\nvoid _8051Reset8723(struct adapter *padapter)\n{\n\tu8 cpu_rst;\n\tu8 io_rst;\n\n\n\t \n\t \n\t \n\tio_rst = rtw_read8(padapter, REG_RSV_CTRL+1);\n\tio_rst &= ~BIT(0);\n\trtw_write8(padapter, REG_RSV_CTRL+1, io_rst);\n\n\tcpu_rst = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\n\tcpu_rst &= ~BIT(2);\n\trtw_write8(padapter, REG_SYS_FUNC_EN+1, cpu_rst);\n\n\t \n\t \n\tio_rst = rtw_read8(padapter, REG_RSV_CTRL+1);\n\tio_rst |= BIT(0);\n\trtw_write8(padapter, REG_RSV_CTRL+1, io_rst);\n\n\tcpu_rst = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\n\tcpu_rst |= BIT(2);\n\trtw_write8(padapter, REG_SYS_FUNC_EN+1, cpu_rst);\n}\n\nu8 g_fwdl_chksum_fail;\n\nstatic s32 polling_fwdl_chksum(\n\tstruct adapter *adapter, u32 min_cnt, u32 timeout_ms\n)\n{\n\ts32 ret = _FAIL;\n\tu32 value32;\n\tunsigned long start = jiffies;\n\tu32 cnt = 0;\n\n\t \n\tdo {\n\t\tcnt++;\n\t\tvalue32 = rtw_read32(adapter, REG_MCUFWDL);\n\t\tif (value32 & FWDL_ChkSum_rpt || adapter->bSurpriseRemoved || adapter->bDriverStopped)\n\t\t\tbreak;\n\t\tyield();\n\t} while (jiffies_to_msecs(jiffies-start) < timeout_ms || cnt < min_cnt);\n\n\tif (!(value32 & FWDL_ChkSum_rpt)) {\n\t\tgoto exit;\n\t}\n\n\tif (g_fwdl_chksum_fail) {\n\t\tg_fwdl_chksum_fail--;\n\t\tgoto exit;\n\t}\n\n\tret = _SUCCESS;\n\nexit:\n\n\treturn ret;\n}\n\nu8 g_fwdl_wintint_rdy_fail;\n\nstatic s32 _FWFreeToGo(struct adapter *adapter, u32 min_cnt, u32 timeout_ms)\n{\n\ts32 ret = _FAIL;\n\tu32 value32;\n\tunsigned long start = jiffies;\n\tu32 cnt = 0;\n\n\tvalue32 = rtw_read32(adapter, REG_MCUFWDL);\n\tvalue32 |= MCUFWDL_RDY;\n\tvalue32 &= ~WINTINI_RDY;\n\trtw_write32(adapter, REG_MCUFWDL, value32);\n\n\t_8051Reset8723(adapter);\n\n\t \n\tdo {\n\t\tcnt++;\n\t\tvalue32 = rtw_read32(adapter, REG_MCUFWDL);\n\t\tif (value32 & WINTINI_RDY || adapter->bSurpriseRemoved || adapter->bDriverStopped)\n\t\t\tbreak;\n\t\tyield();\n\t} while (jiffies_to_msecs(jiffies - start) < timeout_ms || cnt < min_cnt);\n\n\tif (!(value32 & WINTINI_RDY)) {\n\t\tgoto exit;\n\t}\n\n\tif (g_fwdl_wintint_rdy_fail) {\n\t\tg_fwdl_wintint_rdy_fail--;\n\t\tgoto exit;\n\t}\n\n\tret = _SUCCESS;\n\nexit:\n\n\treturn ret;\n}\n\n#define IS_FW_81xxC(padapter)\t(((GET_HAL_DATA(padapter))->FirmwareSignature & 0xFFF0) == 0x88C0)\n\nvoid rtl8723b_FirmwareSelfReset(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tu8 u1bTmp;\n\tu8 Delay = 100;\n\n\tif (\n\t\t!(IS_FW_81xxC(padapter) && ((pHalData->FirmwareVersion < 0x21) || (pHalData->FirmwareVersion == 0x21 && pHalData->FirmwareSubVersion < 0x01)))\n\t) {  \n\t\t \n\t\trtw_write8(padapter, REG_HMETFR+3, 0x20);\n\n\t\tu1bTmp = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\n\t\twhile (u1bTmp & BIT2) {\n\t\t\tDelay--;\n\t\t\tif (Delay == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(50);\n\t\t\tu1bTmp = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\n\t\t}\n\n\t\tif (Delay == 0) {\n\t\t\t \n\t\t\tu1bTmp = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\n\t\t\trtw_write8(padapter, REG_SYS_FUNC_EN+1, u1bTmp&(~BIT2));\n\t\t}\n\t}\n}\n\n \n \n \n \n \ns32 rtl8723b_FirmwareDownload(struct adapter *padapter, bool  bUsedWoWLANFw)\n{\n\ts32 rtStatus = _SUCCESS;\n\tu8 write_fw = 0;\n\tunsigned long fwdl_start_time;\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tstruct rt_firmware *pFirmware;\n\tstruct rt_firmware *pBTFirmware;\n\tstruct rt_firmware_hdr *pFwHdr = NULL;\n\tu8 *pFirmwareBuf;\n\tu32 FirmwareLen;\n\tconst struct firmware *fw;\n\tstruct device *device = dvobj_to_dev(padapter->dvobj);\n\tu8 *fwfilepath;\n\tstruct dvobj_priv *psdpriv = padapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\tu8 tmp_ps;\n\n\tpFirmware = kzalloc(sizeof(struct rt_firmware), GFP_KERNEL);\n\tif (!pFirmware)\n\t\treturn _FAIL;\n\tpBTFirmware = kzalloc(sizeof(struct rt_firmware), GFP_KERNEL);\n\tif (!pBTFirmware) {\n\t\tkfree(pFirmware);\n\t\treturn _FAIL;\n\t}\n\ttmp_ps = rtw_read8(padapter, 0xa3);\n\ttmp_ps &= 0xf8;\n\ttmp_ps |= 0x02;\n\t \n\trtw_write8(padapter, 0xa3, tmp_ps);\n\t \n\ttmp_ps = rtw_read8(padapter, 0xa0);\n\ttmp_ps &= 0x03;\n\tif (tmp_ps != 0x01)\n\t\tpdbgpriv->dbg_downloadfw_pwr_state_cnt++;\n\n\tfwfilepath = \"rtlwifi/rtl8723bs_nic.bin\";\n\n\tpr_info(\"rtl8723bs: acquire FW from file:%s\\n\", fwfilepath);\n\n\trtStatus = request_firmware(&fw, fwfilepath, device);\n\tif (rtStatus) {\n\t\tpr_err(\"Request firmware failed with error 0x%x\\n\", rtStatus);\n\t\trtStatus = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tif (!fw) {\n\t\tpr_err(\"Firmware %s not available\\n\", fwfilepath);\n\t\trtStatus = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tif (fw->size > FW_8723B_SIZE) {\n\t\trtStatus = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpFirmware->fw_buffer_sz = kmemdup(fw->data, fw->size, GFP_KERNEL);\n\tif (!pFirmware->fw_buffer_sz) {\n\t\trtStatus = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpFirmware->fw_length = fw->size;\n\trelease_firmware(fw);\n\tif (pFirmware->fw_length > FW_8723B_SIZE) {\n\t\trtStatus = _FAIL;\n\t\tnetdev_emerg(padapter->pnetdev,\n\t\t\t     \"Firmware size:%u exceed %u\\n\",\n\t\t\t     pFirmware->fw_length, FW_8723B_SIZE);\n\t\tgoto release_fw1;\n\t}\n\n\tpFirmwareBuf = pFirmware->fw_buffer_sz;\n\tFirmwareLen = pFirmware->fw_length;\n\n\t \n\tpFwHdr = (struct rt_firmware_hdr *)pFirmwareBuf;\n\n\tpHalData->FirmwareVersion =  le16_to_cpu(pFwHdr->version);\n\tpHalData->FirmwareSubVersion = le16_to_cpu(pFwHdr->subversion);\n\tpHalData->FirmwareSignature = le16_to_cpu(pFwHdr->signature);\n\n\tif (IS_FW_HEADER_EXIST_8723B(pFwHdr)) {\n\t\t \n\t\tpFirmwareBuf = pFirmwareBuf + 32;\n\t\tFirmwareLen = FirmwareLen - 32;\n\t}\n\n\t \n\t \n\tif (rtw_read8(padapter, REG_MCUFWDL) & RAM_DL_SEL) {  \n\t\trtw_write8(padapter, REG_MCUFWDL, 0x00);\n\t\trtl8723b_FirmwareSelfReset(padapter);\n\t}\n\n\t_FWDownloadEnable(padapter, true);\n\tfwdl_start_time = jiffies;\n\twhile (\n\t\t!padapter->bDriverStopped &&\n\t\t!padapter->bSurpriseRemoved &&\n\t\t(write_fw++ < 3 || jiffies_to_msecs(jiffies - fwdl_start_time) < 500)\n\t) {\n\t\t \n\t\trtw_write8(padapter, REG_MCUFWDL, rtw_read8(padapter, REG_MCUFWDL)|FWDL_ChkSum_rpt);\n\n\t\trtStatus = _WriteFW(padapter, pFirmwareBuf, FirmwareLen);\n\t\tif (rtStatus != _SUCCESS)\n\t\t\tcontinue;\n\n\t\trtStatus = polling_fwdl_chksum(padapter, 5, 50);\n\t\tif (rtStatus == _SUCCESS)\n\t\t\tbreak;\n\t}\n\t_FWDownloadEnable(padapter, false);\n\tif (_SUCCESS != rtStatus)\n\t\tgoto fwdl_stat;\n\n\trtStatus = _FWFreeToGo(padapter, 10, 200);\n\tif (_SUCCESS != rtStatus)\n\t\tgoto fwdl_stat;\n\nfwdl_stat:\n\nexit:\n\tkfree(pFirmware->fw_buffer_sz);\n\tkfree(pFirmware);\nrelease_fw1:\n\tkfree(pBTFirmware);\n\treturn rtStatus;\n}\n\nvoid rtl8723b_InitializeFirmwareVars(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\n\t \n\tadapter_to_pwrctl(padapter)->fw_current_in_ps_mode = false;\n\n\t \n\trtw_write8(padapter, REG_HMETFR, 0x0f);\n\n\t \n\tpHalData->LastHMEBoxNum = 0;\n \n \n \n}\n\nstatic void rtl8723b_free_hal_data(struct adapter *padapter)\n{\n}\n\n \n \n \nstatic u8 hal_EfuseSwitchToBank(\n\tstruct adapter *padapter, u8 bank, bool bPseudoTest\n)\n{\n\tu8 bRet = false;\n\tu32 value32 = 0;\n#ifdef HAL_EFUSE_MEMORY\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tstruct efuse_hal *pEfuseHal = &pHalData->EfuseHal;\n#endif\n\n\n\tif (bPseudoTest) {\n#ifdef HAL_EFUSE_MEMORY\n\t\tpEfuseHal->fakeEfuseBank = bank;\n#else\n\t\tfakeEfuseBank = bank;\n#endif\n\t\tbRet = true;\n\t} else {\n\t\tvalue32 = rtw_read32(padapter, EFUSE_TEST);\n\t\tbRet = true;\n\t\tswitch (bank) {\n\t\tcase 0:\n\t\t\tvalue32 = (value32 & ~EFUSE_SEL_MASK) | EFUSE_SEL(EFUSE_WIFI_SEL_0);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tvalue32 = (value32 & ~EFUSE_SEL_MASK) | EFUSE_SEL(EFUSE_BT_SEL_0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue32 = (value32 & ~EFUSE_SEL_MASK) | EFUSE_SEL(EFUSE_BT_SEL_1);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tvalue32 = (value32 & ~EFUSE_SEL_MASK) | EFUSE_SEL(EFUSE_BT_SEL_2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvalue32 = (value32 & ~EFUSE_SEL_MASK) | EFUSE_SEL(EFUSE_WIFI_SEL_0);\n\t\t\tbRet = false;\n\t\t\tbreak;\n\t\t}\n\t\trtw_write32(padapter, EFUSE_TEST, value32);\n\t}\n\n\treturn bRet;\n}\n\nstatic void Hal_GetEfuseDefinition(\n\tstruct adapter *padapter,\n\tu8 efuseType,\n\tu8 type,\n\tvoid *pOut,\n\tbool bPseudoTest\n)\n{\n\tswitch (type) {\n\tcase TYPE_EFUSE_MAX_SECTION:\n\t\t{\n\t\t\tu8 *pMax_section;\n\t\t\tpMax_section = pOut;\n\n\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t*pMax_section = EFUSE_MAX_SECTION_8723B;\n\t\t\telse\n\t\t\t\t*pMax_section = EFUSE_BT_MAX_SECTION;\n\t\t}\n\t\tbreak;\n\n\tcase TYPE_EFUSE_REAL_CONTENT_LEN:\n\t\t{\n\t\t\tu16 *pu2Tmp;\n\t\t\tpu2Tmp = pOut;\n\n\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t*pu2Tmp = EFUSE_REAL_CONTENT_LEN_8723B;\n\t\t\telse\n\t\t\t\t*pu2Tmp = EFUSE_BT_REAL_CONTENT_LEN;\n\t\t}\n\t\tbreak;\n\n\tcase TYPE_AVAILABLE_EFUSE_BYTES_BANK:\n\t\t{\n\t\t\tu16 *pu2Tmp;\n\t\t\tpu2Tmp = pOut;\n\n\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t*pu2Tmp = (EFUSE_REAL_CONTENT_LEN_8723B-EFUSE_OOB_PROTECT_BYTES);\n\t\t\telse\n\t\t\t\t*pu2Tmp = (EFUSE_BT_REAL_BANK_CONTENT_LEN-EFUSE_PROTECT_BYTES_BANK);\n\t\t}\n\t\tbreak;\n\n\tcase TYPE_AVAILABLE_EFUSE_BYTES_TOTAL:\n\t\t{\n\t\t\tu16 *pu2Tmp;\n\t\t\tpu2Tmp = pOut;\n\n\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t*pu2Tmp = (EFUSE_REAL_CONTENT_LEN_8723B-EFUSE_OOB_PROTECT_BYTES);\n\t\t\telse\n\t\t\t\t*pu2Tmp = (EFUSE_BT_REAL_CONTENT_LEN-(EFUSE_PROTECT_BYTES_BANK*3));\n\t\t}\n\t\tbreak;\n\n\tcase TYPE_EFUSE_MAP_LEN:\n\t\t{\n\t\t\tu16 *pu2Tmp;\n\t\t\tpu2Tmp = pOut;\n\n\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t*pu2Tmp = EFUSE_MAX_MAP_LEN;\n\t\t\telse\n\t\t\t\t*pu2Tmp = EFUSE_BT_MAP_LEN;\n\t\t}\n\t\tbreak;\n\n\tcase TYPE_EFUSE_PROTECT_BYTES_BANK:\n\t\t{\n\t\t\tu8 *pu1Tmp;\n\t\t\tpu1Tmp = pOut;\n\n\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t*pu1Tmp = EFUSE_OOB_PROTECT_BYTES;\n\t\t\telse\n\t\t\t\t*pu1Tmp = EFUSE_PROTECT_BYTES_BANK;\n\t\t}\n\t\tbreak;\n\n\tcase TYPE_EFUSE_CONTENT_LEN_BANK:\n\t\t{\n\t\t\tu16 *pu2Tmp;\n\t\t\tpu2Tmp = pOut;\n\n\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t*pu2Tmp = EFUSE_REAL_CONTENT_LEN_8723B;\n\t\t\telse\n\t\t\t\t*pu2Tmp = EFUSE_BT_REAL_BANK_CONTENT_LEN;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu8 *pu1Tmp;\n\t\t\tpu1Tmp = pOut;\n\t\t\t*pu1Tmp = 0;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n#define VOLTAGE_V25\t\t0x03\n\n \n \n \n \n#define EFUSE_ACCESS_ON_8723\t\t\t0x69\t \n#define REG_EFUSE_ACCESS_8723\t\t\t0x00CF\t \n\n \nstatic void Hal_BT_EfusePowerSwitch(\n\tstruct adapter *padapter, u8 bWrite, u8 PwrState\n)\n{\n\tu8 tempval;\n\tif (PwrState) {\n\t\t \n\t\t \n\t\ttempval = rtw_read8(padapter, 0x6B);\n\t\ttempval |= BIT(6);\n\t\trtw_write8(padapter, 0x6B, tempval);\n\n\t\t \n\t\t \n\t\tmsleep(1);\n\t\t \n\t\t \n\t\ttempval = rtw_read8(padapter, 0x6B);\n\t\ttempval &= ~BIT(7);\n\t\trtw_write8(padapter, 0x6B, tempval);\n\t} else {\n\t\t \n\t\t \n\t\ttempval = rtw_read8(padapter, 0x6B);\n\t\ttempval |= BIT(7);\n\t\trtw_write8(padapter, 0x6B, tempval);\n\n\t\t \n\t\t \n\n\t\t \n\t\t \n\t\ttempval = rtw_read8(padapter, 0x6B);\n\t\ttempval &= ~BIT(6);\n\t\trtw_write8(padapter, 0x6B, tempval);\n\t}\n\n}\nstatic void Hal_EfusePowerSwitch(\n\tstruct adapter *padapter, u8 bWrite, u8 PwrState\n)\n{\n\tu8 tempval;\n\tu16 tmpV16;\n\n\n\tif (PwrState) {\n\t\t \n\t\t \n\t\ttempval = rtw_read8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HSUS_CTRL);\n\t\tif (tempval & BIT(0)) {  \n\t\t\tu8 count = 0;\n\n\n\t\t\ttempval &= ~BIT(0);\n\t\t\trtw_write8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HSUS_CTRL, tempval);\n\n\t\t\t \n\t\t\tdo {\n\t\t\t\ttempval = rtw_read8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HSUS_CTRL);\n\t\t\t\ttempval &= 0x3;\n\t\t\t\tif (tempval == 0x02)\n\t\t\t\t\tbreak;\n\n\t\t\t\tcount++;\n\t\t\t\tif (count >= 100)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmdelay(10);\n\t\t\t} while (1);\n\t\t}\n\n\t\trtw_write8(padapter, REG_EFUSE_ACCESS_8723, EFUSE_ACCESS_ON_8723);\n\n\t\t \n\t\ttmpV16 =  rtw_read16(padapter, REG_SYS_FUNC_EN);\n\t\tif (!(tmpV16 & FEN_ELDR)) {\n\t\t\ttmpV16 |= FEN_ELDR;\n\t\t\trtw_write16(padapter, REG_SYS_FUNC_EN, tmpV16);\n\t\t}\n\n\t\t \n\t\ttmpV16 = rtw_read16(padapter, REG_SYS_CLKR);\n\t\tif ((!(tmpV16 & LOADER_CLK_EN))  || (!(tmpV16 & ANA8M))) {\n\t\t\ttmpV16 |= (LOADER_CLK_EN | ANA8M);\n\t\t\trtw_write16(padapter, REG_SYS_CLKR, tmpV16);\n\t\t}\n\n\t\tif (bWrite) {\n\t\t\t \n\t\t\ttempval = rtw_read8(padapter, EFUSE_TEST+3);\n\t\t\ttempval &= 0x0F;\n\t\t\ttempval |= (VOLTAGE_V25 << 4);\n\t\t\trtw_write8(padapter, EFUSE_TEST+3, (tempval | 0x80));\n\n\t\t\t \n\t\t}\n\t} else {\n\t\trtw_write8(padapter, REG_EFUSE_ACCESS, EFUSE_ACCESS_OFF);\n\n\t\tif (bWrite) {\n\t\t\t \n\t\t\ttempval = rtw_read8(padapter, EFUSE_TEST+3);\n\t\t\trtw_write8(padapter, EFUSE_TEST+3, (tempval & 0x7F));\n\t\t}\n\n\t}\n}\n\nstatic void hal_ReadEFuse_WiFi(\n\tstruct adapter *padapter,\n\tu16 _offset,\n\tu16 _size_byte,\n\tu8 *pbuf,\n\tbool bPseudoTest\n)\n{\n#ifdef HAL_EFUSE_MEMORY\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tstruct efuse_hal *pEfuseHal = &pHalData->EfuseHal;\n#endif\n\tu8 *efuseTbl = NULL;\n\tu16 eFuse_Addr = 0;\n\tu8 offset, wden;\n\tu8 efuseHeader, efuseExtHdr, efuseData;\n\tu16 i, total, used;\n\tu8 efuse_usage = 0;\n\n\t \n\t \n\t \n\tif ((_offset + _size_byte) > EFUSE_MAX_MAP_LEN)\n\t\treturn;\n\n\tefuseTbl = rtw_malloc(EFUSE_MAX_MAP_LEN);\n\tif (!efuseTbl)\n\t\treturn;\n\n\t \n\tmemset(efuseTbl, 0xFF, EFUSE_MAX_MAP_LEN);\n\n\t \n\thal_EfuseSwitchToBank(padapter, 0, bPseudoTest);\n\n\twhile (AVAILABLE_EFUSE_ADDR(eFuse_Addr)) {\n\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseHeader, bPseudoTest);\n\t\tif (efuseHeader == 0xFF)\n\t\t\tbreak;\n\n\t\t \n\t\tif (EXT_HEADER(efuseHeader)) {  \n\t\t\toffset = GET_HDR_OFFSET_2_0(efuseHeader);\n\n\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseExtHdr, bPseudoTest);\n\t\t\tif (ALL_WORDS_DISABLED(efuseExtHdr))\n\t\t\t\tcontinue;\n\n\t\t\toffset |= ((efuseExtHdr & 0xF0) >> 1);\n\t\t\twden = (efuseExtHdr & 0x0F);\n\t\t} else {\n\t\t\toffset = ((efuseHeader >> 4) & 0x0f);\n\t\t\twden = (efuseHeader & 0x0f);\n\t\t}\n\n\t\tif (offset < EFUSE_MAX_SECTION_8723B) {\n\t\t\tu16 addr;\n\t\t\t \n\n\t\t\taddr = offset * PGPKT_DATA_SIZE;\n\t\t\tfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\n\t\t\t\t \n\t\t\t\tif (!(wden & (0x01<<i))) {\n\t\t\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseData, bPseudoTest);\n\t\t\t\t\tefuseTbl[addr] = efuseData;\n\n\t\t\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseData, bPseudoTest);\n\t\t\t\t\tefuseTbl[addr+1] = efuseData;\n\t\t\t\t}\n\t\t\t\taddr += 2;\n\t\t\t}\n\t\t} else {\n\t\t\teFuse_Addr += Efuse_CalculateWordCnts(wden)*2;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < _size_byte; i++)\n\t\tpbuf[i] = efuseTbl[_offset+i];\n\n\t \n\tEFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, &total, bPseudoTest);\n\tused = eFuse_Addr - 1;\n\tefuse_usage = (u8)((used*100)/total);\n\tif (bPseudoTest) {\n#ifdef HAL_EFUSE_MEMORY\n\t\tpEfuseHal->fakeEfuseUsedBytes = used;\n#else\n\t\tfakeEfuseUsedBytes = used;\n#endif\n\t} else {\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_EFUSE_BYTES, (u8 *)&used);\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_EFUSE_USAGE, (u8 *)&efuse_usage);\n\t}\n\n\tkfree(efuseTbl);\n}\n\nstatic void hal_ReadEFuse_BT(\n\tstruct adapter *padapter,\n\tu16 _offset,\n\tu16 _size_byte,\n\tu8 *pbuf,\n\tbool bPseudoTest\n)\n{\n#ifdef HAL_EFUSE_MEMORY\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tstruct efuse_hal *pEfuseHal = &pHalData->EfuseHal;\n#endif\n\tu8 *efuseTbl;\n\tu8 bank;\n\tu16 eFuse_Addr;\n\tu8 efuseHeader, efuseExtHdr, efuseData;\n\tu8 offset, wden;\n\tu16 i, total, used;\n\tu8 efuse_usage;\n\n\n\t \n\t \n\t \n\tif ((_offset + _size_byte) > EFUSE_BT_MAP_LEN)\n\t\treturn;\n\n\tefuseTbl = rtw_malloc(EFUSE_BT_MAP_LEN);\n\tif (!efuseTbl)\n\t\treturn;\n\n\t \n\tmemset(efuseTbl, 0xFF, EFUSE_BT_MAP_LEN);\n\n\tEFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_AVAILABLE_EFUSE_BYTES_BANK, &total, bPseudoTest);\n\n\tfor (bank = 1; bank < 3; bank++) {  \n\t\tif (hal_EfuseSwitchToBank(padapter, bank, bPseudoTest) == false)\n\t\t\tgoto exit;\n\n\t\teFuse_Addr = 0;\n\n\t\twhile (AVAILABLE_EFUSE_ADDR(eFuse_Addr)) {\n\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseHeader, bPseudoTest);\n\t\t\tif (efuseHeader == 0xFF)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (EXT_HEADER(efuseHeader)) {  \n\t\t\t\toffset = GET_HDR_OFFSET_2_0(efuseHeader);\n\n\t\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseExtHdr, bPseudoTest);\n\t\t\t\tif (ALL_WORDS_DISABLED(efuseExtHdr))\n\t\t\t\t\tcontinue;\n\n\n\t\t\t\toffset |= ((efuseExtHdr & 0xF0) >> 1);\n\t\t\t\twden = (efuseExtHdr & 0x0F);\n\t\t\t} else {\n\t\t\t\toffset = ((efuseHeader >> 4) & 0x0f);\n\t\t\t\twden = (efuseHeader & 0x0f);\n\t\t\t}\n\n\t\t\tif (offset < EFUSE_BT_MAX_SECTION) {\n\t\t\t\tu16 addr;\n\n\t\t\t\taddr = offset * PGPKT_DATA_SIZE;\n\t\t\t\tfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\n\t\t\t\t\t \n\t\t\t\t\tif (!(wden & (0x01<<i))) {\n\t\t\t\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseData, bPseudoTest);\n\t\t\t\t\t\tefuseTbl[addr] = efuseData;\n\n\t\t\t\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseData, bPseudoTest);\n\t\t\t\t\t\tefuseTbl[addr+1] = efuseData;\n\t\t\t\t\t}\n\t\t\t\t\taddr += 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teFuse_Addr += Efuse_CalculateWordCnts(wden)*2;\n\t\t\t}\n\t\t}\n\n\t\tif ((eFuse_Addr - 1) < total)\n\t\t\tbreak;\n\n\t}\n\n\t \n\thal_EfuseSwitchToBank(padapter, 0, bPseudoTest);\n\n\t \n\tfor (i = 0; i < _size_byte; i++)\n\t\tpbuf[i] = efuseTbl[_offset+i];\n\n\t \n\t \n\t \n\tEFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, &total, bPseudoTest);\n\tused = (EFUSE_BT_REAL_BANK_CONTENT_LEN*(bank-1)) + eFuse_Addr - 1;\n\tefuse_usage = (u8)((used*100)/total);\n\tif (bPseudoTest) {\n#ifdef HAL_EFUSE_MEMORY\n\t\tpEfuseHal->fakeBTEfuseUsedBytes = used;\n#else\n\t\tfakeBTEfuseUsedBytes = used;\n#endif\n\t} else {\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_EFUSE_BT_BYTES, (u8 *)&used);\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_EFUSE_BT_USAGE, (u8 *)&efuse_usage);\n\t}\n\nexit:\n\tkfree(efuseTbl);\n}\n\nstatic void Hal_ReadEFuse(\n\tstruct adapter *padapter,\n\tu8 efuseType,\n\tu16 _offset,\n\tu16 _size_byte,\n\tu8 *pbuf,\n\tbool bPseudoTest\n)\n{\n\tif (efuseType == EFUSE_WIFI)\n\t\thal_ReadEFuse_WiFi(padapter, _offset, _size_byte, pbuf, bPseudoTest);\n\telse\n\t\thal_ReadEFuse_BT(padapter, _offset, _size_byte, pbuf, bPseudoTest);\n}\n\nstatic u16 hal_EfuseGetCurrentSize_WiFi(\n\tstruct adapter *padapter, bool bPseudoTest\n)\n{\n#ifdef HAL_EFUSE_MEMORY\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tstruct efuse_hal *pEfuseHal = &pHalData->EfuseHal;\n#endif\n\tu16 efuse_addr = 0;\n\tu16 start_addr = 0;  \n\tu8 hoffset = 0, hworden = 0;\n\tu8 efuse_data, word_cnts = 0;\n\tu32 count = 0;  \n\n\n\tif (bPseudoTest) {\n#ifdef HAL_EFUSE_MEMORY\n\t\tefuse_addr = (u16)pEfuseHal->fakeEfuseUsedBytes;\n#else\n\t\tefuse_addr = (u16)fakeEfuseUsedBytes;\n#endif\n\t} else\n\t\trtw_hal_get_hwreg(padapter, HW_VAR_EFUSE_BYTES, (u8 *)&efuse_addr);\n\n\tstart_addr = efuse_addr;\n\n\t \n\thal_EfuseSwitchToBank(padapter, 0, bPseudoTest);\n\n\tcount = 0;\n\twhile (AVAILABLE_EFUSE_ADDR(efuse_addr)) {\n\t\tif (efuse_OneByteRead(padapter, efuse_addr, &efuse_data, bPseudoTest) == false)\n\t\t\tgoto error;\n\n\t\tif (efuse_data == 0xFF)\n\t\t\tbreak;\n\n\t\tif ((start_addr != 0) && (efuse_addr == start_addr)) {\n\t\t\tcount++;\n\n\t\t\tefuse_data = 0xFF;\n\t\t\tif (count < 4) {\n\t\t\t\t \n\n\t\t\t\tif (count > 2) {\n\t\t\t\t\t \n\t\t\t\t\tefuse_addr = 0;\n\t\t\t\t\tstart_addr = 0;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (EXT_HEADER(efuse_data)) {\n\t\t\thoffset = GET_HDR_OFFSET_2_0(efuse_data);\n\t\t\tefuse_addr++;\n\t\t\tefuse_OneByteRead(padapter, efuse_addr, &efuse_data, bPseudoTest);\n\t\t\tif (ALL_WORDS_DISABLED(efuse_data))\n\t\t\t\tcontinue;\n\n\t\t\thoffset |= ((efuse_data & 0xF0) >> 1);\n\t\t\thworden = efuse_data & 0x0F;\n\t\t} else {\n\t\t\thoffset = (efuse_data>>4) & 0x0F;\n\t\t\thworden = efuse_data & 0x0F;\n\t\t}\n\n\t\tword_cnts = Efuse_CalculateWordCnts(hworden);\n\t\tefuse_addr += (word_cnts*2)+1;\n\t}\n\n\tif (bPseudoTest) {\n#ifdef HAL_EFUSE_MEMORY\n\t\tpEfuseHal->fakeEfuseUsedBytes = efuse_addr;\n#else\n\t\tfakeEfuseUsedBytes = efuse_addr;\n#endif\n\t} else\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_EFUSE_BYTES, (u8 *)&efuse_addr);\n\n\tgoto exit;\n\nerror:\n\t \n\tEFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, &efuse_addr, bPseudoTest);\n\nexit:\n\n\treturn efuse_addr;\n}\n\nstatic u16 hal_EfuseGetCurrentSize_BT(struct adapter *padapter, u8 bPseudoTest)\n{\n#ifdef HAL_EFUSE_MEMORY\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tstruct efuse_hal *pEfuseHal = &pHalData->EfuseHal;\n#endif\n\tu16 btusedbytes;\n\tu16 efuse_addr;\n\tu8 bank, startBank;\n\tu8 hoffset = 0, hworden = 0;\n\tu8 efuse_data, word_cnts = 0;\n\tu16 retU2 = 0;\n\n\tif (bPseudoTest) {\n#ifdef HAL_EFUSE_MEMORY\n\t\tbtusedbytes = pEfuseHal->fakeBTEfuseUsedBytes;\n#else\n\t\tbtusedbytes = fakeBTEfuseUsedBytes;\n#endif\n\t} else\n\t\trtw_hal_get_hwreg(padapter, HW_VAR_EFUSE_BT_BYTES, (u8 *)&btusedbytes);\n\n\tefuse_addr = (u16)((btusedbytes%EFUSE_BT_REAL_BANK_CONTENT_LEN));\n\tstartBank = (u8)(1+(btusedbytes/EFUSE_BT_REAL_BANK_CONTENT_LEN));\n\n\tEFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_AVAILABLE_EFUSE_BYTES_BANK, &retU2, bPseudoTest);\n\n\tfor (bank = startBank; bank < 3; bank++) {\n\t\tif (hal_EfuseSwitchToBank(padapter, bank, bPseudoTest) == false)\n\t\t\t \n\t\t\tbreak;\n\n\t\t \n\t\tif (bank != startBank)\n\t\t\tefuse_addr = 0;\n#if 1\n\n\t\twhile (AVAILABLE_EFUSE_ADDR(efuse_addr)) {\n\t\t\tif (efuse_OneByteRead(padapter, efuse_addr,\n\t\t\t\t\t      &efuse_data, bPseudoTest) == false)\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\tif (efuse_data == 0xFF)\n\t\t\t\tbreak;\n\n\t\t\tif (EXT_HEADER(efuse_data)) {\n\t\t\t\thoffset = GET_HDR_OFFSET_2_0(efuse_data);\n\t\t\t\tefuse_addr++;\n\t\t\t\tefuse_OneByteRead(padapter, efuse_addr, &efuse_data, bPseudoTest);\n\n\t\t\t\tif (ALL_WORDS_DISABLED(efuse_data)) {\n\t\t\t\t\tefuse_addr++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n \n\t\t\t\thoffset |= ((efuse_data & 0xF0) >> 1);\n\t\t\t\thworden = efuse_data & 0x0F;\n\t\t\t} else {\n\t\t\t\thoffset = (efuse_data>>4) & 0x0F;\n\t\t\t\thworden =  efuse_data & 0x0F;\n\t\t\t}\n\n\t\t\tword_cnts = Efuse_CalculateWordCnts(hworden);\n\t\t\t \n\t\t\tefuse_addr += (word_cnts*2)+1;\n\t\t}\n#else\n\twhile (\n\t\tbContinual &&\n\t\tefuse_OneByteRead(padapter, efuse_addr, &efuse_data, bPseudoTest) &&\n\t\tAVAILABLE_EFUSE_ADDR(efuse_addr)\n\t) {\n\t\t\tif (efuse_data != 0xFF) {\n\t\t\t\tif ((efuse_data&0x1F) == 0x0F) {  \n\t\t\t\t\thoffset = efuse_data;\n\t\t\t\t\tefuse_addr++;\n\t\t\t\t\tefuse_OneByteRead(padapter, efuse_addr, &efuse_data, bPseudoTest);\n\t\t\t\t\tif ((efuse_data & 0x0F) == 0x0F) {\n\t\t\t\t\t\tefuse_addr++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thoffset = ((hoffset & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);\n\t\t\t\t\t\thworden = efuse_data & 0x0F;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thoffset = (efuse_data>>4) & 0x0F;\n\t\t\t\t\thworden =  efuse_data & 0x0F;\n\t\t\t\t}\n\t\t\t\tword_cnts = Efuse_CalculateWordCnts(hworden);\n\t\t\t\t \n\t\t\t\tefuse_addr = efuse_addr + (word_cnts*2)+1;\n\t\t\t} else\n\t\t\t\tbContinual = false;\n\t\t}\n#endif\n\n\n\t\t \n\t\tif (efuse_addr < retU2)\n\t\t\tbreak;  \n\t}\n\n\tretU2 = ((bank-1)*EFUSE_BT_REAL_BANK_CONTENT_LEN)+efuse_addr;\n\tif (bPseudoTest) {\n\t\tpEfuseHal->fakeBTEfuseUsedBytes = retU2;\n\t} else {\n\t\tpEfuseHal->BTEfuseUsedBytes = retU2;\n\t}\n\n\treturn retU2;\n}\n\nstatic u16 Hal_EfuseGetCurrentSize(\n\tstruct adapter *padapter, u8 efuseType, bool bPseudoTest\n)\n{\n\tu16 ret = 0;\n\n\tif (efuseType == EFUSE_WIFI)\n\t\tret = hal_EfuseGetCurrentSize_WiFi(padapter, bPseudoTest);\n\telse\n\t\tret = hal_EfuseGetCurrentSize_BT(padapter, bPseudoTest);\n\n\treturn ret;\n}\n\nstatic u8 Hal_EfuseWordEnableDataWrite(\n\tstruct adapter *padapter,\n\tu16 efuse_addr,\n\tu8 word_en,\n\tu8 *data,\n\tbool bPseudoTest\n)\n{\n\tu16 tmpaddr = 0;\n\tu16 start_addr = efuse_addr;\n\tu8 badworden = 0x0F;\n\tu8 tmpdata[PGPKT_DATA_SIZE];\n\n\tmemset(tmpdata, 0xFF, PGPKT_DATA_SIZE);\n\n\tif (!(word_en & BIT(0))) {\n\t\ttmpaddr = start_addr;\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[0], bPseudoTest);\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[1], bPseudoTest);\n\n\t\tefuse_OneByteRead(padapter, tmpaddr, &tmpdata[0], bPseudoTest);\n\t\tefuse_OneByteRead(padapter, tmpaddr+1, &tmpdata[1], bPseudoTest);\n\t\tif ((data[0] != tmpdata[0]) || (data[1] != tmpdata[1])) {\n\t\t\tbadworden &= (~BIT(0));\n\t\t}\n\t}\n\tif (!(word_en & BIT(1))) {\n\t\ttmpaddr = start_addr;\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[2], bPseudoTest);\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[3], bPseudoTest);\n\n\t\tefuse_OneByteRead(padapter, tmpaddr, &tmpdata[2], bPseudoTest);\n\t\tefuse_OneByteRead(padapter, tmpaddr+1, &tmpdata[3], bPseudoTest);\n\t\tif ((data[2] != tmpdata[2]) || (data[3] != tmpdata[3])) {\n\t\t\tbadworden &= (~BIT(1));\n\t\t}\n\t}\n\n\tif (!(word_en & BIT(2))) {\n\t\ttmpaddr = start_addr;\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[4], bPseudoTest);\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[5], bPseudoTest);\n\n\t\tefuse_OneByteRead(padapter, tmpaddr, &tmpdata[4], bPseudoTest);\n\t\tefuse_OneByteRead(padapter, tmpaddr+1, &tmpdata[5], bPseudoTest);\n\t\tif ((data[4] != tmpdata[4]) || (data[5] != tmpdata[5])) {\n\t\t\tbadworden &= (~BIT(2));\n\t\t}\n\t}\n\n\tif (!(word_en & BIT(3))) {\n\t\ttmpaddr = start_addr;\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[6], bPseudoTest);\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[7], bPseudoTest);\n\n\t\tefuse_OneByteRead(padapter, tmpaddr, &tmpdata[6], bPseudoTest);\n\t\tefuse_OneByteRead(padapter, tmpaddr+1, &tmpdata[7], bPseudoTest);\n\t\tif ((data[6] != tmpdata[6]) || (data[7] != tmpdata[7])) {\n\t\t\tbadworden &= (~BIT(3));\n\t\t}\n\t}\n\n\treturn badworden;\n}\n\nstatic s32 Hal_EfusePgPacketRead(\n\tstruct adapter *padapter,\n\tu8 offset,\n\tu8 *data,\n\tbool bPseudoTest\n)\n{\n\tu8 efuse_data, word_cnts = 0;\n\tu16 efuse_addr = 0;\n\tu8 hoffset = 0, hworden = 0;\n\tu8 i;\n\tu8 max_section = 0;\n\ts32\tret;\n\n\n\tif (!data)\n\t\treturn false;\n\n\tEFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAX_SECTION, &max_section, bPseudoTest);\n\tif (offset > max_section)\n\t\treturn false;\n\n\tmemset(data, 0xFF, PGPKT_DATA_SIZE);\n\tret = true;\n\n\t \n\t \n\t \n\t \n\t \n\twhile (AVAILABLE_EFUSE_ADDR(efuse_addr)) {\n\t\tif (efuse_OneByteRead(padapter, efuse_addr++, &efuse_data, bPseudoTest) == false) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (efuse_data == 0xFF)\n\t\t\tbreak;\n\n\t\tif (EXT_HEADER(efuse_data)) {\n\t\t\thoffset = GET_HDR_OFFSET_2_0(efuse_data);\n\t\t\tefuse_OneByteRead(padapter, efuse_addr++, &efuse_data, bPseudoTest);\n\t\t\tif (ALL_WORDS_DISABLED(efuse_data))\n\t\t\t\tcontinue;\n\n\t\t\thoffset |= ((efuse_data & 0xF0) >> 1);\n\t\t\thworden = efuse_data & 0x0F;\n\t\t} else {\n\t\t\thoffset = (efuse_data>>4) & 0x0F;\n\t\t\thworden =  efuse_data & 0x0F;\n\t\t}\n\n\t\tif (hoffset == offset) {\n\t\t\tfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\n\t\t\t\t \n\t\t\t\tif (!(hworden & (0x01<<i))) {\n\t\t\t\t\tefuse_OneByteRead(padapter, efuse_addr++, &efuse_data, bPseudoTest);\n\t\t\t\t\tdata[i*2] = efuse_data;\n\n\t\t\t\t\tefuse_OneByteRead(padapter, efuse_addr++, &efuse_data, bPseudoTest);\n\t\t\t\t\tdata[(i*2)+1] = efuse_data;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tword_cnts = Efuse_CalculateWordCnts(hworden);\n\t\t\tefuse_addr += word_cnts*2;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic u8 hal_EfusePgCheckAvailableAddr(\n\tstruct adapter *padapter, u8 efuseType, u8 bPseudoTest\n)\n{\n\tu16 max_available = 0;\n\tu16 current_size;\n\n\n\tEFUSE_GetEfuseDefinition(padapter, efuseType, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, &max_available, bPseudoTest);\n\n\tcurrent_size = Efuse_GetCurrentSize(padapter, efuseType, bPseudoTest);\n\tif (current_size >= max_available)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void hal_EfuseConstructPGPkt(\n\tu8 offset,\n\tu8 word_en,\n\tu8 *pData,\n\tstruct pgpkt_struct *pTargetPkt\n)\n{\n\tmemset(pTargetPkt->data, 0xFF, PGPKT_DATA_SIZE);\n\tpTargetPkt->offset = offset;\n\tpTargetPkt->word_en = word_en;\n\tefuse_WordEnableDataRead(word_en, pData, pTargetPkt->data);\n\tpTargetPkt->word_cnts = Efuse_CalculateWordCnts(pTargetPkt->word_en);\n}\n\nstatic u8 hal_EfusePartialWriteCheck(\n\tstruct adapter *padapter,\n\tu8 efuseType,\n\tu16 *pAddr,\n\tstruct pgpkt_struct *pTargetPkt,\n\tu8 bPseudoTest\n)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tstruct efuse_hal *pEfuseHal = &pHalData->EfuseHal;\n\tu8 bRet = false;\n\tu16 startAddr = 0, efuse_max_available_len = 0, efuse_max = 0;\n\tu8 efuse_data = 0;\n\n\tEFUSE_GetEfuseDefinition(padapter, efuseType, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, &efuse_max_available_len, bPseudoTest);\n\tEFUSE_GetEfuseDefinition(padapter, efuseType, TYPE_EFUSE_CONTENT_LEN_BANK, &efuse_max, bPseudoTest);\n\n\tif (efuseType == EFUSE_WIFI) {\n\t\tif (bPseudoTest) {\n#ifdef HAL_EFUSE_MEMORY\n\t\t\tstartAddr = (u16)pEfuseHal->fakeEfuseUsedBytes;\n#else\n\t\t\tstartAddr = (u16)fakeEfuseUsedBytes;\n#endif\n\t\t} else\n\t\t\trtw_hal_get_hwreg(padapter, HW_VAR_EFUSE_BYTES, (u8 *)&startAddr);\n\t} else {\n\t\tif (bPseudoTest) {\n#ifdef HAL_EFUSE_MEMORY\n\t\t\tstartAddr = (u16)pEfuseHal->fakeBTEfuseUsedBytes;\n#else\n\t\t\tstartAddr = (u16)fakeBTEfuseUsedBytes;\n#endif\n\t\t} else\n\t\t\trtw_hal_get_hwreg(padapter, HW_VAR_EFUSE_BT_BYTES, (u8 *)&startAddr);\n\t}\n\tstartAddr %= efuse_max;\n\n\twhile (1) {\n\t\tif (startAddr >= efuse_max_available_len) {\n\t\t\tbRet = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (efuse_OneByteRead(padapter, startAddr, &efuse_data, bPseudoTest) && (efuse_data != 0xFF)) {\n#if 1\n\t\t\tbRet = false;\n\t\t\tbreak;\n#else\n\t\t\tif (EXT_HEADER(efuse_data)) {\n\t\t\t\tcur_header = efuse_data;\n\t\t\t\tstartAddr++;\n\t\t\t\tefuse_OneByteRead(padapter, startAddr, &efuse_data, bPseudoTest);\n\t\t\t\tif (ALL_WORDS_DISABLED(efuse_data)) {\n\t\t\t\t\tbRet = false;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tcurPkt.offset = ((cur_header & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);\n\t\t\t\t\tcurPkt.word_en = efuse_data & 0x0F;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcur_header  =  efuse_data;\n\t\t\t\tcurPkt.offset = (cur_header>>4) & 0x0F;\n\t\t\t\tcurPkt.word_en = cur_header & 0x0F;\n\t\t\t}\n\n\t\t\tcurPkt.word_cnts = Efuse_CalculateWordCnts(curPkt.word_en);\n\t\t\t \n\t\t\t \n\t\t\tif (\n\t\t\t\t(curPkt.offset == pTargetPkt->offset) &&\n\t\t\t\t(hal_EfuseCheckIfDatafollowed(padapter, curPkt.word_cnts, startAddr+1, bPseudoTest) == false) &&\n\t\t\t\twordEnMatched(pTargetPkt, &curPkt, &matched_wden) == true\n\t\t\t) {\n\t\t\t\t \n\t\t\t\tbadworden = Efuse_WordEnableDataWrite(padapter, startAddr+1, matched_wden, pTargetPkt->data, bPseudoTest);\n\t\t\t\tif (badworden != 0x0F) {\n\t\t\t\t\tu32 PgWriteSuccess = 0;\n\t\t\t\t\t \n\t\t\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t\t\tPgWriteSuccess = Efuse_PgPacketWrite(padapter, pTargetPkt->offset, badworden, pTargetPkt->data, bPseudoTest);\n\t\t\t\t\telse\n\t\t\t\t\t\tPgWriteSuccess = Efuse_PgPacketWrite_BT(padapter, pTargetPkt->offset, badworden, pTargetPkt->data, bPseudoTest);\n\n\t\t\t\t\tif (!PgWriteSuccess) {\n\t\t\t\t\t\tbRet = false;\t \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\tif ((matched_wden & (0x1<<i)) == 0) {  \n\t\t\t\t\t\tpTargetPkt->word_en |= (0x1<<i);\t \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpTargetPkt->word_cnts = Efuse_CalculateWordCnts(pTargetPkt->word_en);\n\t\t\t}\n\t\t\t \n\t\t\tstartAddr = startAddr + (curPkt.word_cnts*2) + 1;\n#endif\n\t\t} else {\n\t\t\t \n\t\t\t*pAddr = startAddr;\n\t\t\tbRet = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bRet;\n}\n\nstatic u8 hal_EfusePgPacketWrite1ByteHeader(\n\tstruct adapter *padapter,\n\tu8 efuseType,\n\tu16 *pAddr,\n\tstruct pgpkt_struct *pTargetPkt,\n\tu8 bPseudoTest\n)\n{\n\tu8 pg_header = 0, tmp_header = 0;\n\tu16 efuse_addr = *pAddr;\n\tu8 repeatcnt = 0;\n\n\tpg_header = ((pTargetPkt->offset << 4) & 0xf0) | pTargetPkt->word_en;\n\n\tdo {\n\t\tefuse_OneByteWrite(padapter, efuse_addr, pg_header, bPseudoTest);\n\t\tefuse_OneByteRead(padapter, efuse_addr, &tmp_header, bPseudoTest);\n\t\tif (tmp_header != 0xFF)\n\t\t\tbreak;\n\t\tif (repeatcnt++ > EFUSE_REPEAT_THRESHOLD_)\n\t\t\treturn false;\n\n\t} while (1);\n\n\tif (tmp_header != pg_header)\n\t\treturn false;\n\n\t*pAddr = efuse_addr;\n\n\treturn true;\n}\n\nstatic u8 hal_EfusePgPacketWrite2ByteHeader(\n\tstruct adapter *padapter,\n\tu8 efuseType,\n\tu16 *pAddr,\n\tstruct pgpkt_struct *pTargetPkt,\n\tu8 bPseudoTest\n)\n{\n\tu16 efuse_addr, efuse_max_available_len = 0;\n\tu8 pg_header = 0, tmp_header = 0;\n\tu8 repeatcnt = 0;\n\n\tEFUSE_GetEfuseDefinition(padapter, efuseType, TYPE_AVAILABLE_EFUSE_BYTES_BANK, &efuse_max_available_len, bPseudoTest);\n\n\tefuse_addr = *pAddr;\n\tif (efuse_addr >= efuse_max_available_len)\n\t\treturn false;\n\n\tpg_header = ((pTargetPkt->offset & 0x07) << 5) | 0x0F;\n\n\tdo {\n\t\tefuse_OneByteWrite(padapter, efuse_addr, pg_header, bPseudoTest);\n\t\tefuse_OneByteRead(padapter, efuse_addr, &tmp_header, bPseudoTest);\n\t\tif (tmp_header != 0xFF)\n\t\t\tbreak;\n\t\tif (repeatcnt++ > EFUSE_REPEAT_THRESHOLD_)\n\t\t\treturn false;\n\n\t} while (1);\n\n\tif (tmp_header != pg_header)\n\t\treturn false;\n\n\t \n\tefuse_addr++;\n\tpg_header = ((pTargetPkt->offset & 0x78) << 1) | pTargetPkt->word_en;\n\n\tdo {\n\t\tefuse_OneByteWrite(padapter, efuse_addr, pg_header, bPseudoTest);\n\t\tefuse_OneByteRead(padapter, efuse_addr, &tmp_header, bPseudoTest);\n\t\tif (tmp_header != 0xFF)\n\t\t\tbreak;\n\t\tif (repeatcnt++ > EFUSE_REPEAT_THRESHOLD_)\n\t\t\treturn false;\n\n\t} while (1);\n\n\tif (tmp_header != pg_header)  \n\t\treturn false;\n\n\t*pAddr = efuse_addr;\n\n\treturn true;\n}\n\nstatic u8 hal_EfusePgPacketWriteHeader(\n\tstruct adapter *padapter,\n\tu8 efuseType,\n\tu16 *pAddr,\n\tstruct pgpkt_struct *pTargetPkt,\n\tu8 bPseudoTest\n)\n{\n\tu8 bRet = false;\n\n\tif (pTargetPkt->offset >= EFUSE_MAX_SECTION_BASE)\n\t\tbRet = hal_EfusePgPacketWrite2ByteHeader(padapter, efuseType, pAddr, pTargetPkt, bPseudoTest);\n\telse\n\t\tbRet = hal_EfusePgPacketWrite1ByteHeader(padapter, efuseType, pAddr, pTargetPkt, bPseudoTest);\n\n\treturn bRet;\n}\n\nstatic u8 hal_EfusePgPacketWriteData(\n\tstruct adapter *padapter,\n\tu8 efuseType,\n\tu16 *pAddr,\n\tstruct pgpkt_struct *pTargetPkt,\n\tu8 bPseudoTest\n)\n{\n\tu16 efuse_addr;\n\tu8 badworden;\n\n\n\tefuse_addr = *pAddr;\n\tbadworden = Efuse_WordEnableDataWrite(padapter, efuse_addr+1, pTargetPkt->word_en, pTargetPkt->data, bPseudoTest);\n\tif (badworden != 0x0F)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic s32 Hal_EfusePgPacketWrite(\n\tstruct adapter *padapter,\n\tu8 offset,\n\tu8 word_en,\n\tu8 *pData,\n\tbool bPseudoTest\n)\n{\n\tstruct pgpkt_struct targetPkt;\n\tu16 startAddr = 0;\n\tu8 efuseType = EFUSE_WIFI;\n\n\tif (!hal_EfusePgCheckAvailableAddr(padapter, efuseType, bPseudoTest))\n\t\treturn false;\n\n\thal_EfuseConstructPGPkt(offset, word_en, pData, &targetPkt);\n\n\tif (!hal_EfusePartialWriteCheck(padapter, efuseType, &startAddr, &targetPkt, bPseudoTest))\n\t\treturn false;\n\n\tif (!hal_EfusePgPacketWriteHeader(padapter, efuseType, &startAddr, &targetPkt, bPseudoTest))\n\t\treturn false;\n\n\tif (!hal_EfusePgPacketWriteData(padapter, efuseType, &startAddr, &targetPkt, bPseudoTest))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool Hal_EfusePgPacketWrite_BT(\n\tstruct adapter *padapter,\n\tu8 offset,\n\tu8 word_en,\n\tu8 *pData,\n\tbool bPseudoTest\n)\n{\n\tstruct pgpkt_struct targetPkt;\n\tu16 startAddr = 0;\n\tu8 efuseType = EFUSE_BT;\n\n\tif (!hal_EfusePgCheckAvailableAddr(padapter, efuseType, bPseudoTest))\n\t\treturn false;\n\n\thal_EfuseConstructPGPkt(offset, word_en, pData, &targetPkt);\n\n\tif (!hal_EfusePartialWriteCheck(padapter, efuseType, &startAddr, &targetPkt, bPseudoTest))\n\t\treturn false;\n\n\tif (!hal_EfusePgPacketWriteHeader(padapter, efuseType, &startAddr, &targetPkt, bPseudoTest))\n\t\treturn false;\n\n\tif (!hal_EfusePgPacketWriteData(padapter, efuseType, &startAddr, &targetPkt, bPseudoTest))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct hal_version ReadChipVersion8723B(struct adapter *padapter)\n{\n\tu32 value32;\n\tstruct hal_version ChipVersion;\n\tstruct hal_com_data *pHalData;\n\n \n\tpHalData = GET_HAL_DATA(padapter);\n\n\tvalue32 = rtw_read32(padapter, REG_SYS_CFG);\n\tChipVersion.ICType = CHIP_8723B;\n\tChipVersion.ChipType = ((value32 & RTL_ID) ? TEST_CHIP : NORMAL_CHIP);\n\tChipVersion.VendorType = ((value32 & VENDOR_ID) ? CHIP_VENDOR_UMC : CHIP_VENDOR_TSMC);\n\tChipVersion.CUTVersion = (value32 & CHIP_VER_RTL_MASK)>>CHIP_VER_RTL_SHIFT;  \n\n\t \n\tpHalData->RegulatorMode = ((value32 & SPS_SEL) ? RT_LDO_REGULATOR : RT_SWITCHING_REGULATOR);\n\n\tvalue32 = rtw_read32(padapter, REG_GPIO_OUTSTS);\n\tChipVersion.ROMVer = ((value32 & RF_RL_ID) >> 20);\t \n\n\t \n\tpHalData->MultiFunc = RT_MULTI_FUNC_NONE;\n\tvalue32 = rtw_read32(padapter, REG_MULTI_FUNC_CTRL);\n\tpHalData->MultiFunc |= ((value32 & WL_FUNC_EN) ? RT_MULTI_FUNC_WIFI : 0);\n\tpHalData->MultiFunc |= ((value32 & BT_FUNC_EN) ? RT_MULTI_FUNC_BT : 0);\n\tpHalData->MultiFunc |= ((value32 & GPS_FUNC_EN) ? RT_MULTI_FUNC_GPS : 0);\n\tpHalData->PolarityCtl = ((value32 & WL_HWPDN_SL) ? RT_POLARITY_HIGH_ACT : RT_POLARITY_LOW_ACT);\n#if 1\n\tdump_chip_info(ChipVersion);\n#endif\n\tpHalData->VersionID = ChipVersion;\n\n\treturn ChipVersion;\n}\n\nstatic void rtl8723b_read_chip_version(struct adapter *padapter)\n{\n\tReadChipVersion8723B(padapter);\n}\n\nvoid rtl8723b_InitBeaconParameters(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tu16 val16;\n\tu8 val8;\n\n\n\tval8 = DIS_TSF_UDT;\n\tval16 = val8 | (val8 << 8);  \n\n\t \n\tval16 |= EN_BCN_FUNCTION;\n\n\trtw_write16(padapter, REG_BCN_CTRL, val16);\n\n\t \n\trtw_write16(padapter, REG_TBTT_PROHIBIT, 0x6404); \n\t \n\t \n\tif (check_fwstate(&padapter->mlmepriv, WIFI_STATION_STATE) == false)\n\t\trtw_write8(padapter, REG_DRVERLYINT, DRIVER_EARLY_INT_TIME_8723B);  \n\trtw_write8(padapter, REG_BCNDMATIM, BCN_DMA_ATIME_INT_TIME_8723B);  \n\n\t \n\t \n\trtw_write16(padapter, REG_BCNTCFG, 0x660F);\n\n\tpHalData->RegBcnCtrlVal = rtw_read8(padapter, REG_BCN_CTRL);\n\tpHalData->RegTxPause = rtw_read8(padapter, REG_TXPAUSE);\n\tpHalData->RegFwHwTxQCtrl = rtw_read8(padapter, REG_FWHW_TXQ_CTRL+2);\n\tpHalData->RegReg542 = rtw_read8(padapter, REG_TBTT_PROHIBIT+2);\n\tpHalData->RegCR_1 = rtw_read8(padapter, REG_CR+1);\n}\n\nvoid _InitBurstPktLen_8723BS(struct adapter *Adapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\n\n\trtw_write8(Adapter, 0x4c7, rtw_read8(Adapter, 0x4c7)|BIT(7));  \n\trtw_write8(Adapter, REG_RX_PKT_LIMIT_8723B, 0x18);\t\t \n\trtw_write8(Adapter, REG_MAX_AGGR_NUM_8723B, 0x1F);\n\trtw_write8(Adapter, REG_PIFS_8723B, 0x00);\n\trtw_write8(Adapter, REG_FWHW_TXQ_CTRL_8723B, rtw_read8(Adapter, REG_FWHW_TXQ_CTRL)&(~BIT(7)));\n\tif (pHalData->AMPDUBurstMode)\n\t\trtw_write8(Adapter, REG_AMPDU_BURST_MODE_8723B,  0x5F);\n\trtw_write8(Adapter, REG_AMPDU_MAX_TIME_8723B, 0x70);\n\n\t \n\trtw_write32(Adapter, REG_ARFR0_8723B, 0x00000010);\n\tif (IS_NORMAL_CHIP(pHalData->VersionID))\n\t\trtw_write32(Adapter, REG_ARFR0_8723B+4, 0xfffff000);\n\telse\n\t\trtw_write32(Adapter, REG_ARFR0_8723B+4, 0x3e0ff000);\n\n\t \n\trtw_write32(Adapter, REG_ARFR1_8723B, 0x00000010);\n\trtw_write32(Adapter, REG_ARFR1_8723B+4, 0x003ff000);\n}\n\nstatic void ResumeTxBeacon(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\n\tpHalData->RegFwHwTxQCtrl |= BIT(6);\n\trtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, pHalData->RegFwHwTxQCtrl);\n\trtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0xff);\n\tpHalData->RegReg542 |= BIT(0);\n\trtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);\n}\n\nstatic void StopTxBeacon(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\n\tpHalData->RegFwHwTxQCtrl &= ~BIT(6);\n\trtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, pHalData->RegFwHwTxQCtrl);\n\trtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0x64);\n\tpHalData->RegReg542 &= ~BIT(0);\n\trtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);\n\n\tCheckFwRsvdPageContent(padapter);   \n}\n\nstatic void _BeaconFunctionEnable(struct adapter *padapter, u8 Enable, u8 Linked)\n{\n\trtw_write8(padapter, REG_BCN_CTRL, DIS_TSF_UDT | EN_BCN_FUNCTION | DIS_BCNQ_SUB);\n\trtw_write8(padapter, REG_RD_CTRL+1, 0x6F);\n}\n\nstatic void rtl8723b_SetBeaconRelatedRegisters(struct adapter *padapter)\n{\n\tu8 val8;\n\tu32 value32;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\n\tu32 bcn_ctrl_reg;\n\n\t \n\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\n\n\tbcn_ctrl_reg = REG_BCN_CTRL;\n\n\t \n\t \n\t \n\trtw_write16(padapter, REG_ATIMWND, 2);\n\n\t \n\t \n\t \n\trtw_write16(padapter, REG_BCN_INTERVAL, pmlmeinfo->bcn_interval);\n\n\trtl8723b_InitBeaconParameters(padapter);\n\n\trtw_write8(padapter, REG_SLOT, 0x09);\n\n\t \n\t \n\t \n\tvalue32 = rtw_read32(padapter, REG_TCR);\n\tvalue32 &= ~TSFRST;\n\trtw_write32(padapter, REG_TCR, value32);\n\n\tvalue32 |= TSFRST;\n\trtw_write32(padapter, REG_TCR, value32);\n\n\t \n\tif (check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE) == true) {\n\t\trtw_write8(padapter, REG_RXTSF_OFFSET_CCK, 0x50);\n\t\trtw_write8(padapter, REG_RXTSF_OFFSET_OFDM, 0x50);\n\t}\n\n\t_BeaconFunctionEnable(padapter, true, true);\n\n\tResumeTxBeacon(padapter);\n\tval8 = rtw_read8(padapter, bcn_ctrl_reg);\n\tval8 |= DIS_BCNQ_SUB;\n\trtw_write8(padapter, bcn_ctrl_reg, val8);\n}\n\nstatic void rtl8723b_GetHalODMVar(\n\tstruct adapter *Adapter,\n\tenum hal_odm_variable eVariable,\n\tvoid *pValue1,\n\tvoid *pValue2\n)\n{\n\tGetHalODMVar(Adapter, eVariable, pValue1, pValue2);\n}\n\nstatic void rtl8723b_SetHalODMVar(\n\tstruct adapter *Adapter,\n\tenum hal_odm_variable eVariable,\n\tvoid *pValue1,\n\tbool bSet\n)\n{\n\tSetHalODMVar(Adapter, eVariable, pValue1, bSet);\n}\n\nstatic void hal_notch_filter_8723b(struct adapter *adapter, bool enable)\n{\n\tif (enable)\n\t\trtw_write8(adapter, rOFDM0_RxDSP+1, rtw_read8(adapter, rOFDM0_RxDSP+1) | BIT1);\n\telse\n\t\trtw_write8(adapter, rOFDM0_RxDSP+1, rtw_read8(adapter, rOFDM0_RxDSP+1) & ~BIT1);\n}\n\nstatic void UpdateHalRAMask8723B(struct adapter *padapter, u32 mac_id, u8 rssi_level)\n{\n\tu32 mask, rate_bitmap;\n\tu8 shortGIrate = false;\n\tstruct sta_info *psta;\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\tstruct dm_priv *pdmpriv = &pHalData->dmpriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tif (mac_id >= NUM_STA)  \n\t\treturn;\n\n\tpsta = pmlmeinfo->FW_sta_info[mac_id].psta;\n\tif (!psta)\n\t\treturn;\n\n\tshortGIrate = query_ra_short_GI(psta);\n\n\tmask = psta->ra_mask;\n\n\trate_bitmap = 0xffffffff;\n\trate_bitmap = ODM_Get_Rate_Bitmap(&pHalData->odmpriv, mac_id, mask, rssi_level);\n\n\tmask &= rate_bitmap;\n\n\trate_bitmap = hal_btcoex_GetRaMask(padapter);\n\tmask &= ~rate_bitmap;\n\n\tif (pHalData->fw_ractrl) {\n\t\trtl8723b_set_FwMacIdConfig_cmd(padapter, mac_id, psta->raid, psta->bw_mode, shortGIrate, mask);\n\t}\n\n\t \n\tpdmpriv->INIDATA_RATE[mac_id] = psta->init_rate;\n}\n\n\nvoid rtl8723b_set_hal_ops(struct hal_ops *pHalFunc)\n{\n\tpHalFunc->free_hal_data = &rtl8723b_free_hal_data;\n\n\tpHalFunc->dm_init = &rtl8723b_init_dm_priv;\n\n\tpHalFunc->read_chip_version = &rtl8723b_read_chip_version;\n\n\tpHalFunc->UpdateRAMaskHandler = &UpdateHalRAMask8723B;\n\n\tpHalFunc->set_bwmode_handler = &PHY_SetBWMode8723B;\n\tpHalFunc->set_channel_handler = &PHY_SwChnl8723B;\n\tpHalFunc->set_chnl_bw_handler = &PHY_SetSwChnlBWMode8723B;\n\n\tpHalFunc->set_tx_power_level_handler = &PHY_SetTxPowerLevel8723B;\n\tpHalFunc->get_tx_power_level_handler = &PHY_GetTxPowerLevel8723B;\n\n\tpHalFunc->hal_dm_watchdog = &rtl8723b_HalDmWatchDog;\n\tpHalFunc->hal_dm_watchdog_in_lps = &rtl8723b_HalDmWatchDog_in_LPS;\n\n\n\tpHalFunc->SetBeaconRelatedRegistersHandler = &rtl8723b_SetBeaconRelatedRegisters;\n\n\tpHalFunc->Add_RateATid = &rtl8723b_Add_RateATid;\n\n\tpHalFunc->run_thread = &rtl8723b_start_thread;\n\tpHalFunc->cancel_thread = &rtl8723b_stop_thread;\n\n\tpHalFunc->read_bbreg = &PHY_QueryBBReg_8723B;\n\tpHalFunc->write_bbreg = &PHY_SetBBReg_8723B;\n\tpHalFunc->read_rfreg = &PHY_QueryRFReg_8723B;\n\tpHalFunc->write_rfreg = &PHY_SetRFReg_8723B;\n\n\t \n\tpHalFunc->BTEfusePowerSwitch = &Hal_BT_EfusePowerSwitch;\n\tpHalFunc->EfusePowerSwitch = &Hal_EfusePowerSwitch;\n\tpHalFunc->ReadEFuse = &Hal_ReadEFuse;\n\tpHalFunc->EFUSEGetEfuseDefinition = &Hal_GetEfuseDefinition;\n\tpHalFunc->EfuseGetCurrentSize = &Hal_EfuseGetCurrentSize;\n\tpHalFunc->Efuse_PgPacketRead = &Hal_EfusePgPacketRead;\n\tpHalFunc->Efuse_PgPacketWrite = &Hal_EfusePgPacketWrite;\n\tpHalFunc->Efuse_WordEnableDataWrite = &Hal_EfuseWordEnableDataWrite;\n\tpHalFunc->Efuse_PgPacketWrite_BT = &Hal_EfusePgPacketWrite_BT;\n\n\tpHalFunc->GetHalODMVarHandler = &rtl8723b_GetHalODMVar;\n\tpHalFunc->SetHalODMVarHandler = &rtl8723b_SetHalODMVar;\n\n\tpHalFunc->xmit_thread_handler = &hal_xmit_handler;\n\tpHalFunc->hal_notch_filter = &hal_notch_filter_8723b;\n\n\tpHalFunc->c2h_handler = c2h_handler_8723b;\n\tpHalFunc->c2h_id_filter_ccx = c2h_id_filter_ccx_8723b;\n\n\tpHalFunc->fill_h2c_cmd = &FillH2CCmd8723B;\n}\n\nvoid rtl8723b_InitAntenna_Selection(struct adapter *padapter)\n{\n\tu8 val;\n\n\tval = rtw_read8(padapter, REG_LEDCFG2);\n\t \n\tval |= BIT(7);  \n\trtw_write8(padapter, REG_LEDCFG2, val);\n}\n\nvoid rtl8723b_init_default_value(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData;\n\tstruct dm_priv *pdmpriv;\n\tu8 i;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\tpdmpriv = &pHalData->dmpriv;\n\n\tpadapter->registrypriv.wireless_mode = WIRELESS_11BG_24N;\n\n\t \n\tpHalData->fw_ractrl = false;\n\tpHalData->bIQKInitialized = false;\n\tif (!adapter_to_pwrctl(padapter)->bkeepfwalive)\n\t\tpHalData->LastHMEBoxNum = 0;\n\n\tpHalData->bIQKInitialized = false;\n\n\t \n\tpdmpriv->TM_Trigger = 0; \n \n \n \n\n\tpdmpriv->ThermalValue_HP_index = 0;\n\tfor (i = 0; i < HP_THERMAL_NUM; i++)\n\t\tpdmpriv->ThermalValue_HP[i] = 0;\n\n\t \n\tpHalData->EfuseUsedBytes = 0;\n\tpHalData->EfuseUsedPercentage = 0;\n#ifdef HAL_EFUSE_MEMORY\n\tpHalData->EfuseHal.fakeEfuseBank = 0;\n\tpHalData->EfuseHal.fakeEfuseUsedBytes = 0;\n\tmemset(pHalData->EfuseHal.fakeEfuseContent, 0xFF, EFUSE_MAX_HW_SIZE);\n\tmemset(pHalData->EfuseHal.fakeEfuseInitMap, 0xFF, EFUSE_MAX_MAP_LEN);\n\tmemset(pHalData->EfuseHal.fakeEfuseModifiedMap, 0xFF, EFUSE_MAX_MAP_LEN);\n\tpHalData->EfuseHal.BTEfuseUsedBytes = 0;\n\tpHalData->EfuseHal.BTEfuseUsedPercentage = 0;\n\tmemset(pHalData->EfuseHal.BTEfuseContent, 0xFF, EFUSE_MAX_BT_BANK*EFUSE_MAX_HW_SIZE);\n\tmemset(pHalData->EfuseHal.BTEfuseInitMap, 0xFF, EFUSE_BT_MAX_MAP_LEN);\n\tmemset(pHalData->EfuseHal.BTEfuseModifiedMap, 0xFF, EFUSE_BT_MAX_MAP_LEN);\n\tpHalData->EfuseHal.fakeBTEfuseUsedBytes = 0;\n\tmemset(pHalData->EfuseHal.fakeBTEfuseContent, 0xFF, EFUSE_MAX_BT_BANK*EFUSE_MAX_HW_SIZE);\n\tmemset(pHalData->EfuseHal.fakeBTEfuseInitMap, 0xFF, EFUSE_BT_MAX_MAP_LEN);\n\tmemset(pHalData->EfuseHal.fakeBTEfuseModifiedMap, 0xFF, EFUSE_BT_MAX_MAP_LEN);\n#endif\n}\n\nu8 GetEEPROMSize8723B(struct adapter *padapter)\n{\n\tu8 size = 0;\n\tu32 cr;\n\n\tcr = rtw_read16(padapter, REG_9346CR);\n\t \n\tsize = (cr & BOOT_FROM_EEPROM) ? 6 : 4;\n\n\treturn size;\n}\n\n \n \n \n \n \ns32 rtl8723b_InitLLTTable(struct adapter *padapter)\n{\n\tunsigned long start, passing_time;\n\tu32 val32;\n\ts32 ret;\n\n\n\tret = _FAIL;\n\n\tval32 = rtw_read32(padapter, REG_AUTO_LLT);\n\tval32 |= BIT_AUTO_INIT_LLT;\n\trtw_write32(padapter, REG_AUTO_LLT, val32);\n\n\tstart = jiffies;\n\n\tdo {\n\t\tval32 = rtw_read32(padapter, REG_AUTO_LLT);\n\t\tif (!(val32 & BIT_AUTO_INIT_LLT)) {\n\t\t\tret = _SUCCESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tpassing_time = jiffies_to_msecs(jiffies - start);\n\t\tif (passing_time > 1000)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t} while (1);\n\n\treturn ret;\n}\n\nstatic void hal_get_chnl_group_8723b(u8 channel, u8 *group)\n{\n\tif (1  <= channel && channel <= 2)\n\t\t*group = 0;\n\telse if (3  <= channel && channel <= 5)\n\t\t*group = 1;\n\telse if (6  <= channel && channel <= 8)\n\t\t*group = 2;\n\telse if (9  <= channel && channel <= 11)\n\t\t*group = 3;\n\telse if (12 <= channel && channel <= 14)\n\t\t*group = 4;\n}\n\nvoid Hal_InitPGData(struct adapter *padapter, u8 *PROMContent)\n{\n\tstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\n\n\tif (!pEEPROM->bautoload_fail_flag) {  \n\t\tif (!pEEPROM->EepromOrEfuse) {\n\t\t\t \n\t\t\tEFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI, false);\n\t\t\tmemcpy((void *)PROMContent, (void *)pEEPROM->efuse_eeprom_data, HWSET_MAX_SIZE_8723B);\n\t\t}\n\t} else { \n\t\tif (!pEEPROM->EepromOrEfuse)\n\t\t\tEFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI, false);\n\t\tmemcpy((void *)PROMContent, (void *)pEEPROM->efuse_eeprom_data, HWSET_MAX_SIZE_8723B);\n\t}\n}\n\nvoid Hal_EfuseParseIDCode(struct adapter *padapter, u8 *hwinfo)\n{\n\tstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\n \n\tu16 EEPROMId;\n\n\n\t \n\tEEPROMId = le16_to_cpu(*((__le16 *)hwinfo));\n\tif (EEPROMId != RTL_EEPROM_ID) {\n\t\tpEEPROM->bautoload_fail_flag = true;\n\t} else\n\t\tpEEPROM->bautoload_fail_flag = false;\n}\n\nstatic void Hal_ReadPowerValueFromPROM_8723B(\n\tstruct adapter *Adapter,\n\tstruct TxPowerInfo24G *pwrInfo24G,\n\tu8 *PROMContent,\n\tbool AutoLoadFail\n)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\n\tu32 rfPath, eeAddr = EEPROM_TX_PWR_INX_8723B, group, TxCount = 0;\n\n\tmemset(pwrInfo24G, 0, sizeof(struct TxPowerInfo24G));\n\n\tif (0xFF == PROMContent[eeAddr+1])\n\t\tAutoLoadFail = true;\n\n\tif (AutoLoadFail) {\n\t\tfor (rfPath = 0; rfPath < MAX_RF_PATH; rfPath++) {\n\t\t\t \n\t\t\tfor (group = 0; group < MAX_CHNL_GROUP_24G; group++) {\n\t\t\t\tpwrInfo24G->IndexCCK_Base[rfPath][group] = EEPROM_DEFAULT_24G_INDEX;\n\t\t\t\tpwrInfo24G->IndexBW40_Base[rfPath][group] = EEPROM_DEFAULT_24G_INDEX;\n\t\t\t}\n\n\t\t\tfor (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {\n\t\t\t\tif (TxCount == 0) {\n\t\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][0] = EEPROM_DEFAULT_24G_HT20_DIFF;\n\t\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][0] = EEPROM_DEFAULT_24G_OFDM_DIFF;\n\t\t\t\t} else {\n\t\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\n\t\t\t\t\tpwrInfo24G->BW40_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\n\t\t\t\t\tpwrInfo24G->CCK_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\n\t\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tpHalData->bTXPowerDataReadFromEEPORM = true;\t\t \n\n\tfor (rfPath = 0; rfPath < MAX_RF_PATH; rfPath++) {\n\t\t \n\t\tfor (group = 0; group < MAX_CHNL_GROUP_24G; group++) {\n\t\t\tpwrInfo24G->IndexCCK_Base[rfPath][group] =\tPROMContent[eeAddr++];\n\t\t\tif (pwrInfo24G->IndexCCK_Base[rfPath][group] == 0xFF)\n\t\t\t\tpwrInfo24G->IndexCCK_Base[rfPath][group] = EEPROM_DEFAULT_24G_INDEX;\n\t\t}\n\n\t\tfor (group = 0; group < MAX_CHNL_GROUP_24G-1; group++) {\n\t\t\tpwrInfo24G->IndexBW40_Base[rfPath][group] =\tPROMContent[eeAddr++];\n\t\t\tif (pwrInfo24G->IndexBW40_Base[rfPath][group] == 0xFF)\n\t\t\t\tpwrInfo24G->IndexBW40_Base[rfPath][group] =\tEEPROM_DEFAULT_24G_INDEX;\n\t\t}\n\n\t\tfor (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {\n\t\t\tif (TxCount == 0) {\n\t\t\t\tpwrInfo24G->BW40_Diff[rfPath][TxCount] = 0;\n\t\t\t\tif (PROMContent[eeAddr] == 0xFF)\n\t\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][TxCount] =\tEEPROM_DEFAULT_24G_HT20_DIFF;\n\t\t\t\telse {\n\t\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][TxCount] =\t(PROMContent[eeAddr]&0xf0)>>4;\n\t\t\t\t\tif (pwrInfo24G->BW20_Diff[rfPath][TxCount] & BIT3)\t\t \n\t\t\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][TxCount] |= 0xF0;\n\t\t\t\t}\n\n\t\t\t\tif (PROMContent[eeAddr] == 0xFF)\n\t\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][TxCount] = EEPROM_DEFAULT_24G_OFDM_DIFF;\n\t\t\t\telse {\n\t\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&0x0f);\n\t\t\t\t\tif (pwrInfo24G->OFDM_Diff[rfPath][TxCount] & BIT3)\t\t \n\t\t\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][TxCount] |= 0xF0;\n\t\t\t\t}\n\t\t\t\tpwrInfo24G->CCK_Diff[rfPath][TxCount] = 0;\n\t\t\t\teeAddr++;\n\t\t\t} else {\n\t\t\t\tif (PROMContent[eeAddr] == 0xFF)\n\t\t\t\t\tpwrInfo24G->BW40_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\n\t\t\t\telse {\n\t\t\t\t\tpwrInfo24G->BW40_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&0xf0)>>4;\n\t\t\t\t\tif (pwrInfo24G->BW40_Diff[rfPath][TxCount] & BIT3)\t\t \n\t\t\t\t\t\tpwrInfo24G->BW40_Diff[rfPath][TxCount] |= 0xF0;\n\t\t\t\t}\n\n\t\t\t\tif (PROMContent[eeAddr] == 0xFF)\n\t\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\n\t\t\t\telse {\n\t\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&0x0f);\n\t\t\t\t\tif (pwrInfo24G->BW20_Diff[rfPath][TxCount] & BIT3)\t\t \n\t\t\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][TxCount] |= 0xF0;\n\t\t\t\t}\n\t\t\t\teeAddr++;\n\n\t\t\t\tif (PROMContent[eeAddr] == 0xFF)\n\t\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\n\t\t\t\telse {\n\t\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&0xf0)>>4;\n\t\t\t\t\tif (pwrInfo24G->OFDM_Diff[rfPath][TxCount] & BIT3)\t\t \n\t\t\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][TxCount] |= 0xF0;\n\t\t\t\t}\n\n\t\t\t\tif (PROMContent[eeAddr] == 0xFF)\n\t\t\t\t\tpwrInfo24G->CCK_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\n\t\t\t\telse {\n\t\t\t\t\tpwrInfo24G->CCK_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&0x0f);\n\t\t\t\t\tif (pwrInfo24G->CCK_Diff[rfPath][TxCount] & BIT3)\t\t \n\t\t\t\t\t\tpwrInfo24G->CCK_Diff[rfPath][TxCount] |= 0xF0;\n\t\t\t\t}\n\t\t\t\teeAddr++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid Hal_EfuseParseTxPowerInfo_8723B(\n\tstruct adapter *padapter, u8 *PROMContent, bool AutoLoadFail\n)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\tstruct TxPowerInfo24G\tpwrInfo24G;\n\tu8 \trfPath, ch, TxCount = 1;\n\n\tHal_ReadPowerValueFromPROM_8723B(padapter, &pwrInfo24G, PROMContent, AutoLoadFail);\n\tfor (rfPath = 0 ; rfPath < MAX_RF_PATH ; rfPath++) {\n\t\tfor (ch = 0 ; ch < CHANNEL_MAX_NUMBER; ch++) {\n\t\t\tu8 group = 0;\n\n\t\t\thal_get_chnl_group_8723b(ch + 1, &group);\n\n\t\t\tif (ch == 14-1) {\n\t\t\t\tpHalData->Index24G_CCK_Base[rfPath][ch] = pwrInfo24G.IndexCCK_Base[rfPath][5];\n\t\t\t\tpHalData->Index24G_BW40_Base[rfPath][ch] = pwrInfo24G.IndexBW40_Base[rfPath][group];\n\t\t\t} else {\n\t\t\t\tpHalData->Index24G_CCK_Base[rfPath][ch] = pwrInfo24G.IndexCCK_Base[rfPath][group];\n\t\t\t\tpHalData->Index24G_BW40_Base[rfPath][ch] = pwrInfo24G.IndexBW40_Base[rfPath][group];\n\t\t\t}\n\t\t}\n\n\t\tfor (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {\n\t\t\tpHalData->CCK_24G_Diff[rfPath][TxCount] = pwrInfo24G.CCK_Diff[rfPath][TxCount];\n\t\t\tpHalData->OFDM_24G_Diff[rfPath][TxCount] = pwrInfo24G.OFDM_Diff[rfPath][TxCount];\n\t\t\tpHalData->BW20_24G_Diff[rfPath][TxCount] = pwrInfo24G.BW20_Diff[rfPath][TxCount];\n\t\t\tpHalData->BW40_24G_Diff[rfPath][TxCount] = pwrInfo24G.BW40_Diff[rfPath][TxCount];\n\t\t}\n\t}\n\n\t \n\tif (!AutoLoadFail) {\n\t\tpHalData->EEPROMRegulatory = (PROMContent[EEPROM_RF_BOARD_OPTION_8723B]&0x7);\t \n\t\tif (PROMContent[EEPROM_RF_BOARD_OPTION_8723B] == 0xFF)\n\t\t\tpHalData->EEPROMRegulatory = (EEPROM_DEFAULT_BOARD_OPTION&0x7);\t \n\t} else\n\t\tpHalData->EEPROMRegulatory = 0;\n}\n\nvoid Hal_EfuseParseBTCoexistInfo_8723B(\n\tstruct adapter *padapter, u8 *hwinfo, bool AutoLoadFail\n)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tu8 tempval;\n\tu32 tmpu4;\n\n\tif (!AutoLoadFail) {\n\t\ttmpu4 = rtw_read32(padapter, REG_MULTI_FUNC_CTRL);\n\t\tif (tmpu4 & BT_FUNC_EN)\n\t\t\tpHalData->EEPROMBluetoothCoexist = true;\n\t\telse\n\t\t\tpHalData->EEPROMBluetoothCoexist = false;\n\n\t\tpHalData->EEPROMBluetoothType = BT_RTL8723B;\n\n\t\ttempval = hwinfo[EEPROM_RF_BT_SETTING_8723B];\n\t\tif (tempval != 0xFF) {\n\t\t\tpHalData->EEPROMBluetoothAntNum = tempval & BIT(0);\n\t\t\t \n\t\t\t \n\t\t\tif (tempval & BIT(6))\n\t\t\t\tpHalData->ant_path = RF_PATH_B;\n\t\t\telse\n\t\t\t\tpHalData->ant_path = RF_PATH_A;\n\t\t} else {\n\t\t\tpHalData->EEPROMBluetoothAntNum = Ant_x1;\n\t\t\tif (pHalData->PackageType == PACKAGE_QFN68)\n\t\t\t\tpHalData->ant_path = RF_PATH_B;\n\t\t\telse\n\t\t\t\tpHalData->ant_path = RF_PATH_A;\n\t\t}\n\t} else {\n\t\tpHalData->EEPROMBluetoothCoexist = false;\n\t\tpHalData->EEPROMBluetoothType = BT_RTL8723B;\n\t\tpHalData->EEPROMBluetoothAntNum = Ant_x1;\n\t\tpHalData->ant_path = RF_PATH_A;\n\t}\n\n\tif (padapter->registrypriv.ant_num > 0) {\n\t\tswitch (padapter->registrypriv.ant_num) {\n\t\tcase 1:\n\t\t\tpHalData->EEPROMBluetoothAntNum = Ant_x1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpHalData->EEPROMBluetoothAntNum = Ant_x2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thal_btcoex_SetBTCoexist(padapter, pHalData->EEPROMBluetoothCoexist);\n\thal_btcoex_SetPgAntNum(padapter, pHalData->EEPROMBluetoothAntNum == Ant_x2 ? 2 : 1);\n\tif (pHalData->EEPROMBluetoothAntNum == Ant_x1)\n\t\thal_btcoex_SetSingleAntPath(padapter, pHalData->ant_path);\n}\n\nvoid Hal_EfuseParseEEPROMVer_8723B(\n\tstruct adapter *padapter, u8 *hwinfo, bool AutoLoadFail\n)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\n\tif (!AutoLoadFail)\n\t\tpHalData->EEPROMVersion = hwinfo[EEPROM_VERSION_8723B];\n\telse\n\t\tpHalData->EEPROMVersion = 1;\n}\n\n\n\nvoid Hal_EfuseParsePackageType_8723B(\n\tstruct adapter *padapter, u8 *hwinfo, bool AutoLoadFail\n)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tu8 package;\n\tu8 efuseContent;\n\n\tEfuse_PowerSwitch(padapter, false, true);\n\tefuse_OneByteRead(padapter, 0x1FB, &efuseContent, false);\n\tEfuse_PowerSwitch(padapter, false, false);\n\n\tpackage = efuseContent & 0x7;\n\tswitch (package) {\n\tcase 0x4:\n\t\tpHalData->PackageType = PACKAGE_TFBGA79;\n\t\tbreak;\n\tcase 0x5:\n\t\tpHalData->PackageType = PACKAGE_TFBGA90;\n\t\tbreak;\n\tcase 0x6:\n\t\tpHalData->PackageType = PACKAGE_QFN68;\n\t\tbreak;\n\tcase 0x7:\n\t\tpHalData->PackageType = PACKAGE_TFBGA80;\n\t\tbreak;\n\n\tdefault:\n\t\tpHalData->PackageType = PACKAGE_DEFAULT;\n\t\tbreak;\n\t}\n}\n\n\nvoid Hal_EfuseParseVoltage_8723B(\n\tstruct adapter *padapter, u8 *hwinfo, bool AutoLoadFail\n)\n{\n\tstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\n\n\t \n\tpEEPROM->adjuseVoltageVal = (hwinfo[EEPROM_Voltage_ADDR_8723B] & 0xf0) >> 4;\n}\n\nvoid Hal_EfuseParseChnlPlan_8723B(\n\tstruct adapter *padapter, u8 *hwinfo, bool AutoLoadFail\n)\n{\n\tpadapter->mlmepriv.ChannelPlan = hal_com_config_channel_plan(\n\t\tpadapter,\n\t\thwinfo ? hwinfo[EEPROM_ChannelPlan_8723B] : 0xFF,\n\t\tpadapter->registrypriv.channel_plan,\n\t\tRT_CHANNEL_DOMAIN_WORLD_NULL,\n\t\tAutoLoadFail\n\t);\n\n\tHal_ChannelPlanToRegulation(padapter, padapter->mlmepriv.ChannelPlan);\n}\n\nvoid Hal_EfuseParseCustomerID_8723B(\n\tstruct adapter *padapter, u8 *hwinfo, bool AutoLoadFail\n)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\n\tif (!AutoLoadFail)\n\t\tpHalData->EEPROMCustomerID = hwinfo[EEPROM_CustomID_8723B];\n\telse\n\t\tpHalData->EEPROMCustomerID = 0;\n}\n\nvoid Hal_EfuseParseAntennaDiversity_8723B(\n\tstruct adapter *padapter,\n\tu8 *hwinfo,\n\tbool AutoLoadFail\n)\n{\n}\n\nvoid Hal_EfuseParseXtal_8723B(\n\tstruct adapter *padapter, u8 *hwinfo, bool AutoLoadFail\n)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\n\tif (!AutoLoadFail) {\n\t\tpHalData->CrystalCap = hwinfo[EEPROM_XTAL_8723B];\n\t\tif (pHalData->CrystalCap == 0xFF)\n\t\t\tpHalData->CrystalCap = EEPROM_Default_CrystalCap_8723B;\t    \n\t} else\n\t\tpHalData->CrystalCap = EEPROM_Default_CrystalCap_8723B;\n}\n\n\nvoid Hal_EfuseParseThermalMeter_8723B(\n\tstruct adapter *padapter, u8 *PROMContent, u8 AutoLoadFail\n)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\n\t \n\t \n\t \n\tif (!AutoLoadFail)\n\t\tpHalData->EEPROMThermalMeter = PROMContent[EEPROM_THERMAL_METER_8723B];\n\telse\n\t\tpHalData->EEPROMThermalMeter = EEPROM_Default_ThermalMeter_8723B;\n\n\tif ((pHalData->EEPROMThermalMeter == 0xff) || AutoLoadFail) {\n\t\tpHalData->bAPKThermalMeterIgnore = true;\n\t\tpHalData->EEPROMThermalMeter = EEPROM_Default_ThermalMeter_8723B;\n\t}\n}\n\n\nvoid Hal_ReadRFGainOffset(\n\tstruct adapter *Adapter, u8 *PROMContent, bool AutoloadFail\n)\n{\n\t \n\t \n\t \n\n\tif (!AutoloadFail) {\n\t\tAdapter->eeprompriv.EEPROMRFGainOffset = PROMContent[EEPROM_RF_GAIN_OFFSET];\n\t\tAdapter->eeprompriv.EEPROMRFGainVal = EFUSE_Read1Byte(Adapter, EEPROM_RF_GAIN_VAL);\n\t} else {\n\t\tAdapter->eeprompriv.EEPROMRFGainOffset = 0;\n\t\tAdapter->eeprompriv.EEPROMRFGainVal = 0xFF;\n\t}\n}\n\nu8 BWMapping_8723B(struct adapter *Adapter, struct pkt_attrib *pattrib)\n{\n\tu8 BWSettingOfDesc = 0;\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\n\n\tif (pHalData->CurrentChannelBW == CHANNEL_WIDTH_40) {\n\t\tif (pattrib->bwmode == CHANNEL_WIDTH_40)\n\t\t\tBWSettingOfDesc = 1;\n\t\telse\n\t\t\tBWSettingOfDesc = 0;\n\t} else\n\t\tBWSettingOfDesc = 0;\n\n\t \n\t \n\n\treturn BWSettingOfDesc;\n}\n\nu8 SCMapping_8723B(struct adapter *Adapter, struct pkt_attrib *pattrib)\n{\n\tu8 SCSettingOfDesc = 0;\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\n\n\tif (pHalData->CurrentChannelBW == CHANNEL_WIDTH_40) {\n\t\tif (pattrib->bwmode == CHANNEL_WIDTH_40) {\n\t\t\tSCSettingOfDesc = HT_DATA_SC_DONOT_CARE;\n\t\t} else if (pattrib->bwmode == CHANNEL_WIDTH_20) {\n\t\t\tif (pHalData->nCur40MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_UPPER) {\n\t\t\t\tSCSettingOfDesc = HT_DATA_SC_20_UPPER_OF_40MHZ;\n\t\t\t} else if (pHalData->nCur40MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_LOWER) {\n\t\t\t\tSCSettingOfDesc = HT_DATA_SC_20_LOWER_OF_40MHZ;\n\t\t\t} else {\n\t\t\t\tSCSettingOfDesc = HT_DATA_SC_DONOT_CARE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tSCSettingOfDesc = HT_DATA_SC_DONOT_CARE;\n\t}\n\n\treturn SCSettingOfDesc;\n}\n\nstatic void rtl8723b_cal_txdesc_chksum(struct tx_desc *ptxdesc)\n{\n\tu16 *usPtr = (u16 *)ptxdesc;\n\tu32 count;\n\tu32 index;\n\tu16 checksum = 0;\n\n\n\t \n\tptxdesc->txdw7 &= cpu_to_le32(0xffff0000);\n\n\t \n\t \n\t \n\tcount = 16;\n\n\tfor (index = 0; index < count; index++) {\n\t\tchecksum |= le16_to_cpu(*(__le16 *)(usPtr + index));\n\t}\n\n\tptxdesc->txdw7 |= cpu_to_le32(checksum & 0x0000ffff);\n}\n\nstatic u8 fill_txdesc_sectype(struct pkt_attrib *pattrib)\n{\n\tu8 sectype = 0;\n\tif ((pattrib->encrypt > 0) && !pattrib->bswenc) {\n\t\tswitch (pattrib->encrypt) {\n\t\t \n\t\tcase _WEP40_:\n\t\tcase _WEP104_:\n\t\tcase _TKIP_:\n\t\tcase _TKIP_WTMIC_:\n\t\t\tsectype = 1;\n\t\t\tbreak;\n\n\t\tcase _AES_:\n\t\t\tsectype = 3;\n\t\t\tbreak;\n\n\t\tcase _NO_PRIVACY_:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn sectype;\n}\n\nstatic void fill_txdesc_vcs_8723b(struct adapter *padapter, struct pkt_attrib *pattrib, struct txdesc_8723b *ptxdesc)\n{\n\tif (pattrib->vcs_mode) {\n\t\tswitch (pattrib->vcs_mode) {\n\t\tcase RTS_CTS:\n\t\t\tptxdesc->rtsen = 1;\n\t\t\t \n\t\t\tptxdesc->hw_rts_en = 1;\n\t\t\tbreak;\n\n\t\tcase CTS_TO_SELF:\n\t\t\tptxdesc->cts2self = 1;\n\t\t\tbreak;\n\n\t\tcase NONE_VCS:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tptxdesc->rtsrate = 8;  \n\t\tptxdesc->rts_ratefb_lmt = 0xF;\n\n\t\tif (padapter->mlmeextpriv.mlmext_info.preamble_mode == PREAMBLE_SHORT)\n\t\t\tptxdesc->rts_short = 1;\n\n\t\t \n\t\tif (pattrib->ht_en)\n\t\t\tptxdesc->rts_sc = SCMapping_8723B(padapter, pattrib);\n\t}\n}\n\nstatic void fill_txdesc_phy_8723b(struct adapter *padapter, struct pkt_attrib *pattrib, struct txdesc_8723b *ptxdesc)\n{\n\tif (pattrib->ht_en) {\n\t\tptxdesc->data_bw = BWMapping_8723B(padapter, pattrib);\n\n\t\tptxdesc->data_sc = SCMapping_8723B(padapter, pattrib);\n\t}\n}\n\nstatic void rtl8723b_fill_default_txdesc(\n\tstruct xmit_frame *pxmitframe, u8 *pbuf\n)\n{\n\tstruct adapter *padapter;\n\tstruct hal_com_data *pHalData;\n\tstruct mlme_ext_priv *pmlmeext;\n\tstruct mlme_ext_info *pmlmeinfo;\n\tstruct pkt_attrib *pattrib;\n\tstruct txdesc_8723b *ptxdesc;\n\ts32 bmcst;\n\n\tmemset(pbuf, 0, TXDESC_SIZE);\n\n\tpadapter = pxmitframe->padapter;\n\tpHalData = GET_HAL_DATA(padapter);\n\tpmlmeext = &padapter->mlmeextpriv;\n\tpmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tpattrib = &pxmitframe->attrib;\n\tbmcst = is_multicast_ether_addr(pattrib->ra);\n\n\tptxdesc = (struct txdesc_8723b *)pbuf;\n\n\tif (pxmitframe->frame_tag == DATA_FRAMETAG) {\n\t\tu8 drv_userate = 0;\n\n\t\tptxdesc->macid = pattrib->mac_id;  \n\t\tptxdesc->rate_id = pattrib->raid;\n\t\tptxdesc->qsel = pattrib->qsel;\n\t\tptxdesc->seq = pattrib->seqnum;\n\n\t\tptxdesc->sectype = fill_txdesc_sectype(pattrib);\n\t\tfill_txdesc_vcs_8723b(padapter, pattrib, ptxdesc);\n\n\t\tif (pattrib->icmp_pkt == 1 && padapter->registrypriv.wifi_spec == 1)\n\t\t\tdrv_userate = 1;\n\n\t\tif (\n\t\t\t(pattrib->ether_type != 0x888e) &&\n\t\t\t(pattrib->ether_type != 0x0806) &&\n\t\t\t(pattrib->ether_type != 0x88B4) &&\n\t\t\t(pattrib->dhcp_pkt != 1) &&\n\t\t\t(drv_userate != 1)\n\t\t) {\n\t\t\t \n\n\t\t\tif (pattrib->ampdu_en) {\n\t\t\t\tptxdesc->agg_en = 1;  \n\t\t\t\tptxdesc->max_agg_num = 0x1f;\n\t\t\t\tptxdesc->ampdu_density = pattrib->ampdu_spacing;\n\t\t\t} else\n\t\t\t\tptxdesc->bk = 1;  \n\n\t\t\tfill_txdesc_phy_8723b(padapter, pattrib, ptxdesc);\n\n\t\t\tptxdesc->data_ratefb_lmt = 0x1F;\n\n\t\t\tif (!pHalData->fw_ractrl) {\n\t\t\t\tptxdesc->userate = 1;\n\n\t\t\t\tif (pHalData->dmpriv.INIDATA_RATE[pattrib->mac_id] & BIT(7))\n\t\t\t\t\tptxdesc->data_short = 1;\n\n\t\t\t\tptxdesc->datarate = pHalData->dmpriv.INIDATA_RATE[pattrib->mac_id] & 0x7F;\n\t\t\t}\n\n\t\t\tif (padapter->fix_rate != 0xFF) {  \n\t\t\t\tptxdesc->userate = 1;\n\t\t\t\tif (padapter->fix_rate & BIT(7))\n\t\t\t\t\tptxdesc->data_short = 1;\n\n\t\t\t\tptxdesc->datarate = (padapter->fix_rate & 0x7F);\n\t\t\t\tptxdesc->disdatafb = 1;\n\t\t\t}\n\n\t\t\tif (pattrib->ldpc)\n\t\t\t\tptxdesc->data_ldpc = 1;\n\t\t\tif (pattrib->stbc)\n\t\t\t\tptxdesc->data_stbc = 1;\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\t \n\n\t\t\tptxdesc->bk = 1;  \n\t\t\tptxdesc->userate = 1;  \n\t\t\tif (pmlmeinfo->preamble_mode == PREAMBLE_SHORT)\n\t\t\t\tptxdesc->data_short = 1; \n\t\t\tptxdesc->datarate = MRateToHwRate(pmlmeext->tx_rate);\n\t\t}\n\n\t\tptxdesc->usb_txagg_num = pxmitframe->agg_num;\n\t} else if (pxmitframe->frame_tag == MGNT_FRAMETAG) {\n\t\tptxdesc->macid = pattrib->mac_id;  \n\t\tptxdesc->qsel = pattrib->qsel;\n\t\tptxdesc->rate_id = pattrib->raid;  \n\t\tptxdesc->seq = pattrib->seqnum;\n\t\tptxdesc->userate = 1;  \n\n\t\tptxdesc->mbssid = pattrib->mbssid & 0xF;\n\n\t\tptxdesc->rty_lmt_en = 1;  \n\t\tif (pattrib->retry_ctrl) {\n\t\t\tptxdesc->data_rt_lmt = 6;\n\t\t} else {\n\t\t\tptxdesc->data_rt_lmt = 12;\n\t\t}\n\n\t\tptxdesc->datarate = MRateToHwRate(pmlmeext->tx_rate);\n\n\t\t \n\t\tif (pxmitframe->ack_report) {\n\t\t\tptxdesc->spe_rpt = 1;\n\t\t\tptxdesc->sw_define = (u8)(GET_PRIMARY_ADAPTER(padapter)->xmitpriv.seq_no);\n\t\t}\n\t} else {\n\t\tptxdesc->macid = pattrib->mac_id;  \n\t\tptxdesc->rate_id = pattrib->raid;  \n\t\tptxdesc->qsel = pattrib->qsel;\n\t\tptxdesc->seq = pattrib->seqnum;\n\t\tptxdesc->userate = 1;  \n\t\tptxdesc->datarate = MRateToHwRate(pmlmeext->tx_rate);\n\t}\n\n\tptxdesc->pktlen = pattrib->last_txcmdsz;\n\tptxdesc->offset = TXDESC_SIZE + OFFSET_SZ;\n\n\tif (bmcst)\n\t\tptxdesc->bmc = 1;\n\n\t \n\tif (!pattrib->qos_en)  \n\t\tptxdesc->en_hwseq = 1;  \n}\n\n \nvoid rtl8723b_update_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf)\n{\n\tstruct tx_desc *pdesc;\n\n\trtl8723b_fill_default_txdesc(pxmitframe, pbuf);\n\tpdesc = (struct tx_desc *)pbuf;\n\trtl8723b_cal_txdesc_chksum(pdesc);\n}\n\n \n \n \n \n \n \n \nvoid rtl8723b_fill_fake_txdesc(\n\tstruct adapter *padapter,\n\tu8 *pDesc,\n\tu32 BufferLen,\n\tu8 IsPsPoll,\n\tu8 IsBTQosNull,\n\tu8 bDataFrame\n)\n{\n\t \n\tmemset(pDesc, 0, TXDESC_SIZE);\n\n\tSET_TX_DESC_FIRST_SEG_8723B(pDesc, 1);  \n\tSET_TX_DESC_LAST_SEG_8723B(pDesc, 1);  \n\n\tSET_TX_DESC_OFFSET_8723B(pDesc, 0x28);  \n\n\tSET_TX_DESC_PKT_SIZE_8723B(pDesc, BufferLen);  \n\tSET_TX_DESC_QUEUE_SEL_8723B(pDesc, QSLT_MGNT);  \n\n\t \n\tif (IsPsPoll) {\n\t\tSET_TX_DESC_NAV_USE_HDR_8723B(pDesc, 1);\n\t} else {\n\t\tSET_TX_DESC_HWSEQ_EN_8723B(pDesc, 1);  \n\t\tSET_TX_DESC_HWSEQ_SEL_8723B(pDesc, 0);\n\t}\n\n\tif (IsBTQosNull) {\n\t\tSET_TX_DESC_BT_INT_8723B(pDesc, 1);\n\t}\n\n\tSET_TX_DESC_USE_RATE_8723B(pDesc, 1);  \n\tSET_TX_DESC_OWN_8723B((u8 *)pDesc, 1);\n\n\tSET_TX_DESC_TX_RATE_8723B(pDesc, DESC8723B_RATE1M);\n\n\t \n\t \n\t \n\tif (bDataFrame) {\n\t\tu32 EncAlg;\n\n\t\tEncAlg = padapter->securitypriv.dot11PrivacyAlgrthm;\n\t\tswitch (EncAlg) {\n\t\tcase _NO_PRIVACY_:\n\t\t\tSET_TX_DESC_SEC_TYPE_8723B(pDesc, 0x0);\n\t\t\tbreak;\n\t\tcase _WEP40_:\n\t\tcase _WEP104_:\n\t\tcase _TKIP_:\n\t\t\tSET_TX_DESC_SEC_TYPE_8723B(pDesc, 0x1);\n\t\t\tbreak;\n\t\tcase _SMS4_:\n\t\t\tSET_TX_DESC_SEC_TYPE_8723B(pDesc, 0x2);\n\t\t\tbreak;\n\t\tcase _AES_:\n\t\t\tSET_TX_DESC_SEC_TYPE_8723B(pDesc, 0x3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSET_TX_DESC_SEC_TYPE_8723B(pDesc, 0x0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\t \n\trtl8723b_cal_txdesc_chksum((struct tx_desc *)pDesc);\n}\n\nstatic void hw_var_set_opmode(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tu8 val8;\n\tu8 mode = *((u8 *)val);\n\n\t{\n\t\t \n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\tval8 |= DIS_TSF_UDT;\n\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\n\t\t \n\t\tSet_MSR(padapter, mode);\n\n\t\tif ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_)) {\n\t\t\t{\n\t\t\t\tStopTxBeacon(padapter);\n\t\t\t}\n\n\t\t\t \n\t\t\trtw_write8(padapter, REG_BCN_CTRL, DIS_TSF_UDT|EN_BCN_FUNCTION|DIS_ATIM);\n\t\t\t \n\t\t} else if (mode == _HW_STATE_ADHOC_) {\n\t\t\tResumeTxBeacon(padapter);\n\t\t\trtw_write8(padapter, REG_BCN_CTRL, DIS_TSF_UDT|EN_BCN_FUNCTION|DIS_BCNQ_SUB);\n\t\t} else if (mode == _HW_STATE_AP_) {\n\n\t\t\tResumeTxBeacon(padapter);\n\n\t\t\trtw_write8(padapter, REG_BCN_CTRL, DIS_TSF_UDT|DIS_BCNQ_SUB);\n\n\t\t\t \n\t\t\trtw_write32(padapter, REG_RCR, 0x7000208e); \n\t\t\t \n\t\t\trtw_write16(padapter, REG_RXFLTMAP2, 0xFFFF);\n\t\t\t \n\t\t\trtw_write16(padapter, REG_RXFLTMAP1, 0x0400);\n\n\t\t\t \n\t\t\trtw_write8(padapter, REG_BCNDMATIM, 0x02);  \n\n\t\t\t \n\t\t\trtw_write8(padapter, REG_ATIMWND, 0x0a);  \n\t\t\trtw_write16(padapter, REG_BCNTCFG, 0x00);\n\t\t\trtw_write16(padapter, REG_TBTT_PROHIBIT, 0xff04);\n\t\t\trtw_write16(padapter, REG_TSFTR_SYN_OFFSET, 0x7fff); \n\n\t\t\t \n\t\t\trtw_write8(padapter, REG_DUAL_TSF_RST, BIT(0));\n\n\t\t\t \n\t\t\t \n\t\t\trtw_write8(padapter, REG_BCN_CTRL, (DIS_TSF_UDT|EN_BCN_FUNCTION|EN_TXBCN_RPT|DIS_BCNQ_SUB));\n\n\t\t\t \n\t\t\t \n\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_DL_BCN_SEL, NULL);\n\n\t\t\t \n\t\t\trtw_write8(\n\t\t\t\tpadapter,\n\t\t\t\tREG_CCK_CHECK_8723B,\n\t\t\t\t(rtw_read8(padapter, REG_CCK_CHECK_8723B)&~BIT_BCN_PORT_SEL)\n\t\t\t);\n\n\t\t\t \n\t\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL_1);\n\t\t\tval8 |= DIS_ATIM;\n\t\t\trtw_write8(padapter, REG_BCN_CTRL_1, val8);\n\t\t}\n\t}\n}\n\nstatic void hw_var_set_macaddr(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tu8 idx = 0;\n\tu32 reg_macid;\n\n\treg_macid = REG_MACID;\n\n\tfor (idx = 0 ; idx < 6; idx++)\n\t\trtw_write8(GET_PRIMARY_ADAPTER(padapter), (reg_macid+idx), val[idx]);\n}\n\nstatic void hw_var_set_bssid(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tu8 idx = 0;\n\tu32 reg_bssid;\n\n\treg_bssid = REG_BSSID;\n\n\tfor (idx = 0 ; idx < 6; idx++)\n\t\trtw_write8(padapter, (reg_bssid+idx), val[idx]);\n}\n\nstatic void hw_var_set_bcn_func(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tu32 bcn_ctrl_reg;\n\n\tbcn_ctrl_reg = REG_BCN_CTRL;\n\n\tif (*(u8 *)val)\n\t\trtw_write8(padapter, bcn_ctrl_reg, (EN_BCN_FUNCTION | EN_TXBCN_RPT));\n\telse {\n\t\tu8 val8;\n\t\tval8 = rtw_read8(padapter, bcn_ctrl_reg);\n\t\tval8 &= ~(EN_BCN_FUNCTION | EN_TXBCN_RPT);\n\n\t\t \n\t\tif (REG_BCN_CTRL == bcn_ctrl_reg)\n\t\t\tval8 |= EN_BCN_FUNCTION;\n\n\t\trtw_write8(padapter, bcn_ctrl_reg, val8);\n\t}\n}\n\nstatic void hw_var_set_correct_tsf(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tu8 val8;\n\tu64 tsf;\n\tstruct mlme_ext_priv *pmlmeext;\n\tstruct mlme_ext_info *pmlmeinfo;\n\n\n\tpmlmeext = &padapter->mlmeextpriv;\n\tpmlmeinfo = &pmlmeext->mlmext_info;\n\n\ttsf = pmlmeext->TSFValue-do_div(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024))-1024;  \n\n\tif (\n\t\t((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) ||\n\t\t((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)\n\t)\n\t\tStopTxBeacon(padapter);\n\n\t{\n\t\t \n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\tval8 &= ~EN_BCN_FUNCTION;\n\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\n\t\trtw_write32(padapter, REG_TSFTR, tsf);\n\t\trtw_write32(padapter, REG_TSFTR+4, tsf>>32);\n\n\t\t \n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\tval8 |= EN_BCN_FUNCTION;\n\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\t}\n\n\tif (\n\t\t((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) ||\n\t\t((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)\n\t)\n\t\tResumeTxBeacon(padapter);\n}\n\nstatic void hw_var_set_mlme_disconnect(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tu8 val8;\n\n\t \n\t \n\t \n\trtw_write16(padapter, REG_RXFLTMAP2, 0);\n\n\t \n\trtw_write8(padapter, REG_DUAL_TSF_RST, BIT(0));\n\n\t \n\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\tval8 |= DIS_TSF_UDT;\n\trtw_write8(padapter, REG_BCN_CTRL, val8);\n}\n\nstatic void hw_var_set_mlme_sitesurvey(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tu32 value_rcr, rcr_clear_bit, reg_bcn_ctl;\n\tu16 value_rxfltmap2;\n\tu8 val8;\n\tstruct hal_com_data *pHalData;\n\tstruct mlme_priv *pmlmepriv;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\tpmlmepriv = &padapter->mlmepriv;\n\n\treg_bcn_ctl = REG_BCN_CTRL;\n\n\trcr_clear_bit = RCR_CBSSID_BCN;\n\n\t \n\tvalue_rxfltmap2 = 0;\n\n\tif ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true))\n\t\trcr_clear_bit = RCR_CBSSID_BCN;\n\n\tvalue_rcr = rtw_read32(padapter, REG_RCR);\n\n\tif (*((u8 *)val)) {\n\t\t \n\t\tvalue_rcr &= ~(rcr_clear_bit);\n\t\trtw_write32(padapter, REG_RCR, value_rcr);\n\n\t\trtw_write16(padapter, REG_RXFLTMAP2, value_rxfltmap2);\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE)) {\n\t\t\t \n\t\t\tval8 = rtw_read8(padapter, reg_bcn_ctl);\n\t\t\tval8 |= DIS_TSF_UDT;\n\t\t\trtw_write8(padapter, reg_bcn_ctl, val8);\n\t\t}\n\n\t\t \n\t\tpHalData->RegRRSR = rtw_read16(padapter, REG_RRSR);\n\t} else {\n\t\t \n\t\tif (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)))\n\t\t\t \n\t\t\trtw_write16(padapter, REG_RXFLTMAP2, 0xFFFF);\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE)) {\n\t\t\t \n\t\t\tval8 = rtw_read8(padapter, reg_bcn_ctl);\n\t\t\tval8 &= ~DIS_TSF_UDT;\n\t\t\trtw_write8(padapter, reg_bcn_ctl, val8);\n\t\t}\n\n\t\tvalue_rcr |= rcr_clear_bit;\n\t\trtw_write32(padapter, REG_RCR, value_rcr);\n\n\t\t \n\t\trtw_write16(padapter, REG_RRSR, pHalData->RegRRSR);\n\t}\n}\n\nstatic void hw_var_set_mlme_join(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\tu8 RetryLimit;\n\tu8 type;\n\tstruct mlme_priv *pmlmepriv;\n\tstruct eeprom_priv *pEEPROM;\n\n\n\tRetryLimit = 0x30;\n\ttype = *(u8 *)val;\n\tpmlmepriv = &padapter->mlmepriv;\n\tpEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\n\n\tif (type == 0) {  \n\t\t \n\t\t \n\t\trtw_write16(padapter, REG_RXFLTMAP2, 0xFFFF);\n\n\t\tval32 = rtw_read32(padapter, REG_RCR);\n\t\tif (padapter->in_cta_test)\n\t\t\tval32 &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN); \n\t\telse\n\t\t\tval32 |= RCR_CBSSID_DATA|RCR_CBSSID_BCN;\n\t\trtw_write32(padapter, REG_RCR, val32);\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)\n\t\t\tRetryLimit = (pEEPROM->CustomerID == RT_CID_CCX) ? 7 : 48;\n\t\telse  \n\t\t\tRetryLimit = 0x7;\n\t} else if (type == 1)  \n\t\trtw_write16(padapter, REG_RXFLTMAP2, 0x00);\n\telse if (type == 2) {  \n\t\t \n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\tval8 &= ~DIS_TSF_UDT;\n\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))\n\t\t\tRetryLimit = 0x7;\n\t}\n\n\tval16 = (RetryLimit << RETRY_LIMIT_SHORT_SHIFT) | (RetryLimit << RETRY_LIMIT_LONG_SHIFT);\n\trtw_write16(padapter, REG_RL, val16);\n}\n\nvoid CCX_FwC2HTxRpt_8723b(struct adapter *padapter, u8 *pdata, u8 len)\n{\n\n#define\tGET_8723B_C2H_TX_RPT_LIFE_TIME_OVER(_Header)\tLE_BITS_TO_1BYTE((_Header + 0), 6, 1)\n#define\tGET_8723B_C2H_TX_RPT_RETRY_OVER(_Header)\tLE_BITS_TO_1BYTE((_Header + 0), 7, 1)\n\n\tif (GET_8723B_C2H_TX_RPT_RETRY_OVER(pdata) | GET_8723B_C2H_TX_RPT_LIFE_TIME_OVER(pdata)) {\n\t\trtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_CCX_PKT_FAIL);\n\t}\n \n\telse\n\t\trtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_SUCCESS);\n}\n\ns32 c2h_id_filter_ccx_8723b(u8 *buf)\n{\n\tstruct c2h_evt_hdr_88xx *c2h_evt = (struct c2h_evt_hdr_88xx *)buf;\n\ts32 ret = false;\n\tif (c2h_evt->id == C2H_CCX_TX_RPT)\n\t\tret = true;\n\n\treturn ret;\n}\n\n\ns32 c2h_handler_8723b(struct adapter *padapter, u8 *buf)\n{\n\tstruct c2h_evt_hdr_88xx *pC2hEvent = (struct c2h_evt_hdr_88xx *)buf;\n\ts32 ret = _SUCCESS;\n\n\tif (!pC2hEvent) {\n\t\tret = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tswitch (pC2hEvent->id) {\n\tcase C2H_AP_RPT_RSP:\n\t\tbreak;\n\tcase C2H_DBG:\n\t\t{\n\t\t}\n\t\tbreak;\n\n\tcase C2H_CCX_TX_RPT:\n \n\t\tbreak;\n\n\tcase C2H_EXT_RA_RPT:\n \n\t\tbreak;\n\n\tcase C2H_HW_INFO_EXCH:\n\t\tbreak;\n\n\tcase C2H_8723B_BT_INFO:\n\t\thal_btcoex_BtInfoNotify(padapter, pC2hEvent->plen, pC2hEvent->payload);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\t \n\t \n \nexit:\n\treturn ret;\n}\n\nstatic void process_c2h_event(struct adapter *padapter, struct c2h_evt_hdr_t *pC2hEvent, u8 *c2hBuf)\n{\n\tif (!c2hBuf)\n\t\treturn;\n\n\tswitch (pC2hEvent->CmdID) {\n\tcase C2H_AP_RPT_RSP:\n\t\tbreak;\n\tcase C2H_DBG:\n\t\t{\n\t\t}\n\t\tbreak;\n\n\tcase C2H_CCX_TX_RPT:\n \n\t\tbreak;\n\n\tcase C2H_EXT_RA_RPT:\n \n\t\tbreak;\n\n\tcase C2H_HW_INFO_EXCH:\n\t\tbreak;\n\n\tcase C2H_8723B_BT_INFO:\n\t\thal_btcoex_BtInfoNotify(padapter, pC2hEvent->CmdLen, c2hBuf);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid C2HPacketHandler_8723B(struct adapter *padapter, u8 *pbuffer, u16 length)\n{\n\tstruct c2h_evt_hdr_t\tC2hEvent;\n\tu8 *tmpBuf = NULL;\n\tC2hEvent.CmdID = pbuffer[0];\n\tC2hEvent.CmdSeq = pbuffer[1];\n\tC2hEvent.CmdLen = length-2;\n\ttmpBuf = pbuffer+2;\n\n\tprocess_c2h_event(padapter, &C2hEvent, tmpBuf);\n\t \n}\n\nvoid SetHwReg8723B(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tu8 val8;\n\tu32 val32;\n\n\tswitch (variable) {\n\tcase HW_VAR_MEDIA_STATUS:\n\t\tval8 = rtw_read8(padapter, MSR) & 0x0c;\n\t\tval8 |= *val;\n\t\trtw_write8(padapter, MSR, val8);\n\t\tbreak;\n\n\tcase HW_VAR_MEDIA_STATUS1:\n\t\tval8 = rtw_read8(padapter, MSR) & 0x03;\n\t\tval8 |= *val << 2;\n\t\trtw_write8(padapter, MSR, val8);\n\t\tbreak;\n\n\tcase HW_VAR_SET_OPMODE:\n\t\thw_var_set_opmode(padapter, variable, val);\n\t\tbreak;\n\n\tcase HW_VAR_MAC_ADDR:\n\t\thw_var_set_macaddr(padapter, variable, val);\n\t\tbreak;\n\n\tcase HW_VAR_BSSID:\n\t\thw_var_set_bssid(padapter, variable, val);\n\t\tbreak;\n\n\tcase HW_VAR_BASIC_RATE:\n\t{\n\t\tstruct mlme_ext_info *mlmext_info = &padapter->mlmeextpriv.mlmext_info;\n\t\tu16 BrateCfg = 0;\n\t\tu16 rrsr_2g_force_mask = (RRSR_11M|RRSR_5_5M|RRSR_1M);\n\t\tu16 rrsr_2g_allow_mask = (RRSR_24M|RRSR_12M|RRSR_6M|RRSR_CCK_RATES);\n\n\t\tHalSetBrateCfg(padapter, val, &BrateCfg);\n\n\t\t \n\t\tBrateCfg |= rrsr_2g_force_mask;\n\t\tBrateCfg &= rrsr_2g_allow_mask;\n\n\t\t \n\t\tif (mlmext_info->assoc_AP_vendor == HT_IOT_PEER_CISCO) {\n\t\t\t \n\t\t\tif ((BrateCfg & (RRSR_24M|RRSR_12M|RRSR_6M)) == 0)\n\t\t\t\tBrateCfg |= RRSR_6M;\n\t\t}\n\n\t\tpHalData->BasicRateSet = BrateCfg;\n\n\t\t \n\t\trtw_write16(padapter, REG_RRSR, BrateCfg);\n\t\trtw_write8(padapter, REG_RRSR+2, rtw_read8(padapter, REG_RRSR+2)&0xf0);\n\t}\n\t\tbreak;\n\n\tcase HW_VAR_TXPAUSE:\n\t\trtw_write8(padapter, REG_TXPAUSE, *val);\n\t\tbreak;\n\n\tcase HW_VAR_BCN_FUNC:\n\t\thw_var_set_bcn_func(padapter, variable, val);\n\t\tbreak;\n\n\tcase HW_VAR_CORRECT_TSF:\n\t\thw_var_set_correct_tsf(padapter, variable, val);\n\t\tbreak;\n\n\tcase HW_VAR_CHECK_BSSID:\n\t\t{\n\t\t\tu32 val32;\n\t\t\tval32 = rtw_read32(padapter, REG_RCR);\n\t\t\tif (*val)\n\t\t\t\tval32 |= RCR_CBSSID_DATA|RCR_CBSSID_BCN;\n\t\t\telse\n\t\t\t\tval32 &= ~(RCR_CBSSID_DATA|RCR_CBSSID_BCN);\n\t\t\trtw_write32(padapter, REG_RCR, val32);\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_MLME_DISCONNECT:\n\t\thw_var_set_mlme_disconnect(padapter, variable, val);\n\t\tbreak;\n\n\tcase HW_VAR_MLME_SITESURVEY:\n\t\thw_var_set_mlme_sitesurvey(padapter, variable,  val);\n\n\t\thal_btcoex_ScanNotify(padapter, *val?true:false);\n\t\tbreak;\n\n\tcase HW_VAR_MLME_JOIN:\n\t\thw_var_set_mlme_join(padapter, variable, val);\n\n\t\tswitch (*val) {\n\t\tcase 0:\n\t\t\t \n\t\t\thal_btcoex_ConnectNotify(padapter, true);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\thal_btcoex_ConnectNotify(padapter, false);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n \n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_ON_RCR_AM:\n\t\tval32 = rtw_read32(padapter, REG_RCR);\n\t\tval32 |= RCR_AM;\n\t\trtw_write32(padapter, REG_RCR, val32);\n\t\tbreak;\n\n\tcase HW_VAR_OFF_RCR_AM:\n\t\tval32 = rtw_read32(padapter, REG_RCR);\n\t\tval32 &= ~RCR_AM;\n\t\trtw_write32(padapter, REG_RCR, val32);\n\t\tbreak;\n\n\tcase HW_VAR_BEACON_INTERVAL:\n\t\trtw_write16(padapter, REG_BCN_INTERVAL, *((u16 *)val));\n\t\tbreak;\n\n\tcase HW_VAR_SLOT_TIME:\n\t\trtw_write8(padapter, REG_SLOT, *val);\n\t\tbreak;\n\n\tcase HW_VAR_RESP_SIFS:\n\t\t \n\t\t \n\t\trtw_write8(padapter, REG_RESP_SIFS_CCK, val[0]);  \n\t\trtw_write8(padapter, REG_RESP_SIFS_CCK+1, val[1]);  \n\t\t \n\t\trtw_write8(padapter, REG_RESP_SIFS_OFDM, val[2]);  \n\t\trtw_write8(padapter, REG_RESP_SIFS_OFDM+1, val[3]);  \n\t\tbreak;\n\n\tcase HW_VAR_ACK_PREAMBLE:\n\t\t{\n\t\t\tu8 regTmp;\n\t\t\tu8 bShortPreamble = *val;\n\n\t\t\t \n\t\t\t \n\t\t\tregTmp = 0;\n\t\t\tif (bShortPreamble)\n\t\t\t\tregTmp |= 0x80;\n\t\t\trtw_write8(padapter, REG_RRSR+2, regTmp);\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_CAM_EMPTY_ENTRY:\n\t\t{\n\t\t\tu8 ucIndex = *val;\n\t\t\tu8 i;\n\t\t\tu32 ulCommand = 0;\n\t\t\tu32 ulContent = 0;\n\t\t\tu32 ulEncAlgo = CAM_AES;\n\n\t\t\tfor (i = 0; i < CAM_CONTENT_COUNT; i++) {\n\t\t\t\t \n\t\t\t\tif (i == 0) {\n\t\t\t\t\tulContent |= (ucIndex & 0x03) | ((u16)(ulEncAlgo)<<2);\n\t\t\t\t\t \n\t\t\t\t} else\n\t\t\t\t\tulContent = 0;\n\n\t\t\t\t \n\t\t\t\tulCommand = CAM_CONTENT_COUNT*ucIndex+i;\n\t\t\t\tulCommand = ulCommand | CAM_POLLINIG | CAM_WRITE;\n\t\t\t\t \n\t\t\t\trtw_write32(padapter, WCAMI, ulContent);   \n\t\t\t\trtw_write32(padapter, RWCAM, ulCommand);   \n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_CAM_INVALID_ALL:\n\t\trtw_write32(padapter, RWCAM, BIT(31)|BIT(30));\n\t\tbreak;\n\n\tcase HW_VAR_CAM_WRITE:\n\t\t{\n\t\t\tu32 cmd;\n\t\t\tu32 *cam_val = (u32 *)val;\n\n\t\t\trtw_write32(padapter, WCAMI, cam_val[0]);\n\n\t\t\tcmd = CAM_POLLINIG | CAM_WRITE | cam_val[1];\n\t\t\trtw_write32(padapter, RWCAM, cmd);\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_AC_PARAM_VO:\n\t\trtw_write32(padapter, REG_EDCA_VO_PARAM, *((u32 *)val));\n\t\tbreak;\n\n\tcase HW_VAR_AC_PARAM_VI:\n\t\trtw_write32(padapter, REG_EDCA_VI_PARAM, *((u32 *)val));\n\t\tbreak;\n\n\tcase HW_VAR_AC_PARAM_BE:\n\t\tpHalData->AcParam_BE = ((u32 *)(val))[0];\n\t\trtw_write32(padapter, REG_EDCA_BE_PARAM, *((u32 *)val));\n\t\tbreak;\n\n\tcase HW_VAR_AC_PARAM_BK:\n\t\trtw_write32(padapter, REG_EDCA_BK_PARAM, *((u32 *)val));\n\t\tbreak;\n\n\tcase HW_VAR_ACM_CTRL:\n\t\t{\n\t\t\tu8 ctrl = *((u8 *)val);\n\t\t\tu8 hwctrl = 0;\n\n\t\t\tif (ctrl != 0) {\n\t\t\t\thwctrl |= AcmHw_HwEn;\n\n\t\t\t\tif (ctrl & BIT(1))  \n\t\t\t\t\thwctrl |= AcmHw_BeqEn;\n\n\t\t\t\tif (ctrl & BIT(2))  \n\t\t\t\t\thwctrl |= AcmHw_ViqEn;\n\n\t\t\t\tif (ctrl & BIT(3))  \n\t\t\t\t\thwctrl |= AcmHw_VoqEn;\n\t\t\t}\n\n\t\t\trtw_write8(padapter, REG_ACMHWCTRL, hwctrl);\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_AMPDU_FACTOR:\n\t\t{\n\t\t\tu32 AMPDULen =  (*((u8 *)val));\n\n\t\t\tif (AMPDULen < HT_AGG_SIZE_32K)\n\t\t\t\tAMPDULen = (0x2000 << (*((u8 *)val)))-1;\n\t\t\telse\n\t\t\t\tAMPDULen = 0x7fff;\n\n\t\t\trtw_write32(padapter, REG_AMPDU_MAX_LENGTH_8723B, AMPDULen);\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_H2C_FW_PWRMODE:\n\t\t{\n\t\t\tu8 psmode = *val;\n\n\t\t\t \n\t\t\t \n\t\t\tif (psmode != PS_MODE_ACTIVE) {\n\t\t\t\tODM_RF_Saving(&pHalData->odmpriv, true);\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\trtl8723b_set_FwPwrMode_cmd(padapter, psmode);\n\t\t}\n\t\tbreak;\n\tcase HW_VAR_H2C_PS_TUNE_PARAM:\n\t\trtl8723b_set_FwPsTuneParam_cmd(padapter);\n\t\tbreak;\n\n\tcase HW_VAR_H2C_FW_JOINBSSRPT:\n\t\trtl8723b_set_FwJoinBssRpt_cmd(padapter, *val);\n\t\tbreak;\n\n\tcase HW_VAR_INITIAL_GAIN:\n\t\t{\n\t\t\tstruct dig_t *pDigTable = &pHalData->odmpriv.DM_DigTable;\n\t\t\tu32 rx_gain = *(u32 *)val;\n\n\t\t\tif (rx_gain == 0xff) { \n\t\t\t\tODM_Write_DIG(&pHalData->odmpriv, pDigTable->BackupIGValue);\n\t\t\t} else {\n\t\t\t\tpDigTable->BackupIGValue = pDigTable->CurIGValue;\n\t\t\t\tODM_Write_DIG(&pHalData->odmpriv, rx_gain);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_EFUSE_USAGE:\n\t\tpHalData->EfuseUsedPercentage = *val;\n\t\tbreak;\n\n\tcase HW_VAR_EFUSE_BYTES:\n\t\tpHalData->EfuseUsedBytes = *((u16 *)val);\n\t\tbreak;\n\n\tcase HW_VAR_EFUSE_BT_USAGE:\n#ifdef HAL_EFUSE_MEMORY\n\t\tpHalData->EfuseHal.BTEfuseUsedPercentage = *val;\n#endif\n\t\tbreak;\n\n\tcase HW_VAR_EFUSE_BT_BYTES:\n#ifdef HAL_EFUSE_MEMORY\n\t\tpHalData->EfuseHal.BTEfuseUsedBytes = *((u16 *)val);\n#else\n\t\tBTEfuseUsedBytes = *((u16 *)val);\n#endif\n\t\tbreak;\n\n\tcase HW_VAR_FIFO_CLEARN_UP:\n\t\t{\n\t\t\t#define RW_RELEASE_EN\t\tBIT(18)\n\t\t\t#define RXDMA_IDLE\t\t\tBIT(17)\n\n\t\t\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\t\t\tu8 trycnt = 100;\n\n\t\t\t \n\t\t\trtw_write8(padapter, REG_TXPAUSE, 0xff);\n\n\t\t\t \n\t\t\tpadapter->xmitpriv.nqos_ssn = rtw_read16(padapter, REG_NQOS_SEQ);\n\n\t\t\tif (!pwrpriv->bkeepfwalive) {\n\t\t\t\t \n\t\t\t\tval32 = rtw_read32(padapter, REG_RXPKT_NUM);\n\t\t\t\tval32 |= RW_RELEASE_EN;\n\t\t\t\trtw_write32(padapter, REG_RXPKT_NUM, val32);\n\t\t\t\tdo {\n\t\t\t\t\tval32 = rtw_read32(padapter, REG_RXPKT_NUM);\n\t\t\t\t\tval32 &= RXDMA_IDLE;\n\t\t\t\t\tif (val32)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} while (--trycnt);\n\n\t\t\t\t \n\t\t\t\trtw_write16(padapter, REG_RQPN_NPQ, 0);\n\t\t\t\trtw_write32(padapter, REG_RQPN, 0x80000000);\n\t\t\t\tmdelay(2);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_APFM_ON_MAC:\n\t\tpHalData->bMacPwrCtrlOn = *val;\n\t\tbreak;\n\n\tcase HW_VAR_NAV_UPPER:\n\t\t{\n\t\t\tu32 usNavUpper = *((u32 *)val);\n\n\t\t\tif (usNavUpper > HAL_NAV_UPPER_UNIT_8723B * 0xFF)\n\t\t\t\tbreak;\n\n\t\t\tusNavUpper = DIV_ROUND_UP(usNavUpper,\n\t\t\t\t\t\t  HAL_NAV_UPPER_UNIT_8723B);\n\t\t\trtw_write8(padapter, REG_NAV_UPPER, (u8)usNavUpper);\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_H2C_MEDIA_STATUS_RPT:\n\t\t{\n\t\t\tu16 mstatus_rpt = (*(u16 *)val);\n\t\t\tu8 mstatus, macId;\n\n\t\t\tmstatus = (u8) (mstatus_rpt & 0xFF);\n\t\t\tmacId = (u8)(mstatus_rpt >> 8);\n\t\t\trtl8723b_set_FwMediaStatusRpt_cmd(padapter, mstatus, macId);\n\t\t}\n\t\tbreak;\n\tcase HW_VAR_BCN_VALID:\n\t\t{\n\t\t\t \n\t\t\tval8 = rtw_read8(padapter, REG_TDECTRL+2);\n\t\t\tval8 |= BIT(0);\n\t\t\trtw_write8(padapter, REG_TDECTRL+2, val8);\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_DL_BCN_SEL:\n\t\t{\n\t\t\t \n\t\t\tval8 = rtw_read8(padapter, REG_DWBCN1_CTRL_8723B+2);\n\t\t\tval8 &= ~BIT(4);\n\t\t\trtw_write8(padapter, REG_DWBCN1_CTRL_8723B+2, val8);\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_DO_IQK:\n\t\tpHalData->bNeedIQK = true;\n\t\tbreak;\n\n\tcase HW_VAR_DL_RSVD_PAGE:\n\t\tif (check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == true)\n\t\t\trtl8723b_download_BTCoex_AP_mode_rsvd_page(padapter);\n\t\telse\n\t\t\trtl8723b_download_rsvd_page(padapter, RT_MEDIA_CONNECT);\n\t\tbreak;\n\n\tcase HW_VAR_MACID_SLEEP:\n\t\t \n\t\tval32 = *(u32 *)val;\n\t\tif (val32 > 31)\n\t\t\tbreak;\n\n\t\tval8 = (u8)val32;  \n\n\t\tval32 = rtw_read32(padapter, REG_MACID_SLEEP);\n\t\tif (val32 & BIT(val8))\n\t\t\tbreak;\n\t\tval32 |= BIT(val8);\n\t\trtw_write32(padapter, REG_MACID_SLEEP, val32);\n\t\tbreak;\n\n\tcase HW_VAR_MACID_WAKEUP:\n\t\t \n\t\tval32 = *(u32 *)val;\n\t\tif (val32 > 31)\n\t\t\tbreak;\n\n\t\tval8 = (u8)val32;  \n\n\t\tval32 = rtw_read32(padapter, REG_MACID_SLEEP);\n\t\tif (!(val32 & BIT(val8)))\n\t\t\tbreak;\n\t\tval32 &= ~BIT(val8);\n\t\trtw_write32(padapter, REG_MACID_SLEEP, val32);\n\t\tbreak;\n\n\tdefault:\n\t\tSetHwReg(padapter, variable, val);\n\t\tbreak;\n\t}\n}\n\nvoid GetHwReg8723B(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\tu8 val8;\n\tu16 val16;\n\n\tswitch (variable) {\n\tcase HW_VAR_TXPAUSE:\n\t\t*val = rtw_read8(padapter, REG_TXPAUSE);\n\t\tbreak;\n\n\tcase HW_VAR_BCN_VALID:\n\t\t{\n\t\t\t \n\t\t\tval8 = rtw_read8(padapter, REG_TDECTRL+2);\n\t\t\t*val = (BIT(0) & val8) ? true : false;\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_FWLPS_RF_ON:\n\t\t{\n\t\t\t \n\t\t\tu32 valRCR;\n\n\t\t\tif (\n\t\t\t\tpadapter->bSurpriseRemoved  ||\n\t\t\t\t(adapter_to_pwrctl(padapter)->rf_pwrstate == rf_off)\n\t\t\t) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t*val = true;\n\t\t\t} else {\n\t\t\t\tvalRCR = rtw_read32(padapter, REG_RCR);\n\t\t\t\tvalRCR &= 0x00070000;\n\t\t\t\tif (valRCR)\n\t\t\t\t\t*val = false;\n\t\t\t\telse\n\t\t\t\t\t*val = true;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase HW_VAR_EFUSE_USAGE:\n\t\t*val = pHalData->EfuseUsedPercentage;\n\t\tbreak;\n\n\tcase HW_VAR_EFUSE_BYTES:\n\t\t*((u16 *)val) = pHalData->EfuseUsedBytes;\n\t\tbreak;\n\n\tcase HW_VAR_EFUSE_BT_USAGE:\n#ifdef HAL_EFUSE_MEMORY\n\t\t*val = pHalData->EfuseHal.BTEfuseUsedPercentage;\n#endif\n\t\tbreak;\n\n\tcase HW_VAR_EFUSE_BT_BYTES:\n#ifdef HAL_EFUSE_MEMORY\n\t\t*((u16 *)val) = pHalData->EfuseHal.BTEfuseUsedBytes;\n#else\n\t\t*((u16 *)val) = BTEfuseUsedBytes;\n#endif\n\t\tbreak;\n\n\tcase HW_VAR_APFM_ON_MAC:\n\t\t*val = pHalData->bMacPwrCtrlOn;\n\t\tbreak;\n\tcase HW_VAR_CHK_HI_QUEUE_EMPTY:\n\t\tval16 = rtw_read16(padapter, REG_TXPKT_EMPTY);\n\t\t*val = (val16 & BIT(10)) ? true:false;\n\t\tbreak;\n\tdefault:\n\t\tGetHwReg(padapter, variable, val);\n\t\tbreak;\n\t}\n}\n\n \nu8 SetHalDefVar8723B(struct adapter *padapter, enum hal_def_variable variable, void *pval)\n{\n\tu8 bResult;\n\n\tbResult = _SUCCESS;\n\n\tswitch (variable) {\n\tdefault:\n\t\tbResult = SetHalDefVar(padapter, variable, pval);\n\t\tbreak;\n\t}\n\n\treturn bResult;\n}\n\n \nu8 GetHalDefVar8723B(struct adapter *padapter, enum hal_def_variable variable, void *pval)\n{\n\tu8 bResult;\n\n\tbResult = _SUCCESS;\n\n\tswitch (variable) {\n\tcase HAL_DEF_MAX_RECVBUF_SZ:\n\t\t*((u32 *)pval) = MAX_RECVBUF_SZ;\n\t\tbreak;\n\n\tcase HAL_DEF_RX_PACKET_OFFSET:\n\t\t*((u32 *)pval) = RXDESC_SIZE + DRVINFO_SZ*8;\n\t\tbreak;\n\n\tcase HW_VAR_MAX_RX_AMPDU_FACTOR:\n\t\t \n\t\t \n\t\t \n\t\t*(u32 *)pval = IEEE80211_HT_MAX_AMPDU_16K;\n\t\tbreak;\n\tcase HAL_DEF_TX_LDPC:\n\tcase HAL_DEF_RX_LDPC:\n\t\t*((u8 *)pval) = false;\n\t\tbreak;\n\tcase HAL_DEF_TX_STBC:\n\t\t*((u8 *)pval) = 0;\n\t\tbreak;\n\tcase HAL_DEF_RX_STBC:\n\t\t*((u8 *)pval) = 1;\n\t\tbreak;\n\tcase HAL_DEF_EXPLICIT_BEAMFORMER:\n\tcase HAL_DEF_EXPLICIT_BEAMFORMEE:\n\t\t*((u8 *)pval) = false;\n\t\tbreak;\n\n\tcase HW_DEF_RA_INFO_DUMP:\n\t\t{\n\t\t\tu8 mac_id = *(u8 *)pval;\n\t\t\tu32 cmd;\n\n\t\t\tcmd = 0x40000100 | mac_id;\n\t\t\trtw_write32(padapter, REG_HMEBOX_DBG_2_8723B, cmd);\n\t\t\tmsleep(10);\n\t\t\trtw_read32(padapter, 0x2F0);\t\n\n\t\t\tcmd = 0x40000400 | mac_id;\n\t\t\trtw_write32(padapter, REG_HMEBOX_DBG_2_8723B, cmd);\n\t\t\tmsleep(10);\n\t\t\trtw_read32(padapter, 0x2F0);\t\n\t\t\trtw_read32(padapter, 0x2F4);\t\n\t\t\trtw_read32(padapter, 0x2F8);\t\n\t\t\trtw_read32(padapter, 0x2FC);\t\n\t\t}\n\t\tbreak;\n\n\tcase HAL_DEF_TX_PAGE_BOUNDARY:\n\t\tif (!padapter->registrypriv.wifi_spec) {\n\t\t\t*(u8 *)pval = TX_PAGE_BOUNDARY_8723B;\n\t\t} else {\n\t\t\t*(u8 *)pval = WMM_NORMAL_TX_PAGE_BOUNDARY_8723B;\n\t\t}\n\t\tbreak;\n\n\tcase HAL_DEF_MACID_SLEEP:\n\t\t*(u8 *)pval = true;  \n\t\tbreak;\n\n\tdefault:\n\t\tbResult = GetHalDefVar(padapter, variable, pval);\n\t\tbreak;\n\t}\n\n\treturn bResult;\n}\n\nvoid rtl8723b_start_thread(struct adapter *padapter)\n{\n\tstruct xmit_priv *xmitpriv = &padapter->xmitpriv;\n\n\txmitpriv->SdioXmitThread = kthread_run(rtl8723bs_xmit_thread, padapter, \"RTWHALXT\");\n}\n\nvoid rtl8723b_stop_thread(struct adapter *padapter)\n{\n\tstruct xmit_priv *xmitpriv = &padapter->xmitpriv;\n\n\t \n\tif (xmitpriv->SdioXmitThread) {\n\t\tcomplete(&xmitpriv->SdioXmitStart);\n\t\twait_for_completion(&xmitpriv->SdioXmitTerminate);\n\t\txmitpriv->SdioXmitThread = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}