{
  "module_name": "hal_com.c",
  "hash_id": "3fa21616daa083197ce9519fce0282b9895639f386a5784404186db197ab3073",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/hal/hal_com.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <drv_types.h>\n#include <rtw_debug.h>\n#include \"hal_com_h2c.h\"\n\n#include \"odm_precomp.h\"\n\nu8 rtw_hal_data_init(struct adapter *padapter)\n{\n\tif (is_primary_adapter(padapter)) {\t \n\t\tpadapter->hal_data_sz = sizeof(struct hal_com_data);\n\t\tpadapter->HalData = vzalloc(padapter->hal_data_sz);\n\t\tif (!padapter->HalData)\n\t\t\treturn _FAIL;\n\t}\n\treturn _SUCCESS;\n}\n\nvoid rtw_hal_data_deinit(struct adapter *padapter)\n{\n\tif (is_primary_adapter(padapter)) {\t \n\t\tif (padapter->HalData) {\n\t\t\tvfree(padapter->HalData);\n\t\t\tpadapter->HalData = NULL;\n\t\t\tpadapter->hal_data_sz = 0;\n\t\t}\n\t}\n}\n\n\nvoid dump_chip_info(struct hal_version\tChipVersion)\n{\n\tchar buf[128];\n\tsize_t cnt = 0;\n\n\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"Chip Version Info: CHIP_8723B_%s_\",\n\t\t\tIS_NORMAL_CHIP(ChipVersion) ? \"Normal_Chip\" : \"Test_Chip\");\n\n\tif (IS_CHIP_VENDOR_TSMC(ChipVersion))\n\t\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"TSMC_\");\n\telse if (IS_CHIP_VENDOR_UMC(ChipVersion))\n\t\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"UMC_\");\n\telse if (IS_CHIP_VENDOR_SMIC(ChipVersion))\n\t\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"SMIC_\");\n\n\tif (IS_A_CUT(ChipVersion))\n\t\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"A_CUT_\");\n\telse if (IS_B_CUT(ChipVersion))\n\t\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"B_CUT_\");\n\telse if (IS_C_CUT(ChipVersion))\n\t\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"C_CUT_\");\n\telse if (IS_D_CUT(ChipVersion))\n\t\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"D_CUT_\");\n\telse if (IS_E_CUT(ChipVersion))\n\t\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"E_CUT_\");\n\telse if (IS_I_CUT(ChipVersion))\n\t\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"I_CUT_\");\n\telse if (IS_J_CUT(ChipVersion))\n\t\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"J_CUT_\");\n\telse if (IS_K_CUT(ChipVersion))\n\t\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"K_CUT_\");\n\telse\n\t\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt,\n\t\t\t\t\"UNKNOWN_CUT(%d)_\", ChipVersion.CUTVersion);\n\n\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"1T1R_\");\n\n\tcnt += scnprintf(buf + cnt, sizeof(buf) - cnt, \"RomVer(%d)\\n\", ChipVersion.ROMVer);\n}\n\n\n#define\tEEPROM_CHANNEL_PLAN_BY_HW_MASK\t0x80\n\n \nu8 hal_com_config_channel_plan(\n\tstruct adapter *padapter,\n\tu8 hw_channel_plan,\n\tu8 sw_channel_plan,\n\tu8 def_channel_plan,\n\tbool AutoLoadFail\n)\n{\n\tstruct hal_com_data *pHalData;\n\tu8 chnlPlan;\n\n\tpHalData = GET_HAL_DATA(padapter);\n\tpHalData->bDisableSWChannelPlan = false;\n\tchnlPlan = def_channel_plan;\n\n\tif (0xFF == hw_channel_plan)\n\t\tAutoLoadFail = true;\n\n\tif (!AutoLoadFail) {\n\t\tu8 hw_chnlPlan;\n\n\t\thw_chnlPlan = hw_channel_plan & (~EEPROM_CHANNEL_PLAN_BY_HW_MASK);\n\t\tif (rtw_is_channel_plan_valid(hw_chnlPlan)) {\n\t\t\tif (hw_channel_plan & EEPROM_CHANNEL_PLAN_BY_HW_MASK)\n\t\t\t\tpHalData->bDisableSWChannelPlan = true;\n\n\t\t\tchnlPlan = hw_chnlPlan;\n\t\t}\n\t}\n\n\tif (\n\t\t(false == pHalData->bDisableSWChannelPlan) &&\n\t\trtw_is_channel_plan_valid(sw_channel_plan)\n\t)\n\t\tchnlPlan = sw_channel_plan;\n\n\treturn chnlPlan;\n}\n\nbool HAL_IsLegalChannel(struct adapter *adapter, u32 Channel)\n{\n\tbool bLegalChannel = true;\n\n\tif ((Channel <= 14) && (Channel >= 1)) {\n\t\tif (is_supported_24g(adapter->registrypriv.wireless_mode) == false)\n\t\t\tbLegalChannel = false;\n\t} else {\n\t\tbLegalChannel = false;\n\t}\n\n\treturn bLegalChannel;\n}\n\nu8 MRateToHwRate(u8 rate)\n{\n\tu8 ret = DESC_RATE1M;\n\n\tswitch (rate) {\n\tcase MGN_1M:\n\t\tret = DESC_RATE1M;\n\t\tbreak;\n\tcase MGN_2M:\n\t\tret = DESC_RATE2M;\n\t\tbreak;\n\tcase MGN_5_5M:\n\t\tret = DESC_RATE5_5M;\n\t\tbreak;\n\tcase MGN_11M:\n\t\tret = DESC_RATE11M;\n\t\tbreak;\n\tcase MGN_6M:\n\t\tret = DESC_RATE6M;\n\t\tbreak;\n\tcase MGN_9M:\n\t\tret = DESC_RATE9M;\n\t\tbreak;\n\tcase MGN_12M:\n\t\tret = DESC_RATE12M;\n\t\tbreak;\n\tcase MGN_18M:\n\t\tret = DESC_RATE18M;\n\t\tbreak;\n\tcase MGN_24M:\n\t\tret = DESC_RATE24M;\n\t\tbreak;\n\tcase MGN_36M:\n\t\tret = DESC_RATE36M;\n\t\tbreak;\n\tcase MGN_48M:\n\t\tret = DESC_RATE48M;\n\t\tbreak;\n\tcase MGN_54M:\n\t\tret = DESC_RATE54M;\n\t\tbreak;\n\tcase MGN_MCS0:\n\t\tret = DESC_RATEMCS0;\n\t\tbreak;\n\tcase MGN_MCS1:\n\t\tret = DESC_RATEMCS1;\n\t\tbreak;\n\tcase MGN_MCS2:\n\t\tret = DESC_RATEMCS2;\n\t\tbreak;\n\tcase MGN_MCS3:\n\t\tret = DESC_RATEMCS3;\n\t\tbreak;\n\tcase MGN_MCS4:\n\t\tret = DESC_RATEMCS4;\n\t\tbreak;\n\tcase MGN_MCS5:\n\t\tret = DESC_RATEMCS5;\n\t\tbreak;\n\tcase MGN_MCS6:\n\t\tret = DESC_RATEMCS6;\n\t\tbreak;\n\tcase MGN_MCS7:\n\t\tret = DESC_RATEMCS7;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nu8 HwRateToMRate(u8 rate)\n{\n\tu8 ret_rate = MGN_1M;\n\n\tswitch (rate) {\n\tcase DESC_RATE1M:\n\t\tret_rate = MGN_1M;\n\t\tbreak;\n\tcase DESC_RATE2M:\n\t\tret_rate = MGN_2M;\n\t\tbreak;\n\tcase DESC_RATE5_5M:\n\t\tret_rate = MGN_5_5M;\n\t\tbreak;\n\tcase DESC_RATE11M:\n\t\tret_rate = MGN_11M;\n\t\tbreak;\n\tcase DESC_RATE6M:\n\t\tret_rate = MGN_6M;\n\t\tbreak;\n\tcase DESC_RATE9M:\n\t\tret_rate = MGN_9M;\n\t\tbreak;\n\tcase DESC_RATE12M:\n\t\tret_rate = MGN_12M;\n\t\tbreak;\n\tcase DESC_RATE18M:\n\t\tret_rate = MGN_18M;\n\t\tbreak;\n\tcase DESC_RATE24M:\n\t\tret_rate = MGN_24M;\n\t\tbreak;\n\tcase DESC_RATE36M:\n\t\tret_rate = MGN_36M;\n\t\tbreak;\n\tcase DESC_RATE48M:\n\t\tret_rate = MGN_48M;\n\t\tbreak;\n\tcase DESC_RATE54M:\n\t\tret_rate = MGN_54M;\n\t\tbreak;\n\tcase DESC_RATEMCS0:\n\t\tret_rate = MGN_MCS0;\n\t\tbreak;\n\tcase DESC_RATEMCS1:\n\t\tret_rate = MGN_MCS1;\n\t\tbreak;\n\tcase DESC_RATEMCS2:\n\t\tret_rate = MGN_MCS2;\n\t\tbreak;\n\tcase DESC_RATEMCS3:\n\t\tret_rate = MGN_MCS3;\n\t\tbreak;\n\tcase DESC_RATEMCS4:\n\t\tret_rate = MGN_MCS4;\n\t\tbreak;\n\tcase DESC_RATEMCS5:\n\t\tret_rate = MGN_MCS5;\n\t\tbreak;\n\tcase DESC_RATEMCS6:\n\t\tret_rate = MGN_MCS6;\n\t\tbreak;\n\tcase DESC_RATEMCS7:\n\t\tret_rate = MGN_MCS7;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret_rate;\n}\n\nvoid HalSetBrateCfg(struct adapter *Adapter, u8 *mBratesOS, u16 *pBrateCfg)\n{\n\tu8 i, is_brate, brate;\n\n\tfor (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {\n\n\t\tis_brate = mBratesOS[i] & IEEE80211_BASIC_RATE_MASK;\n\t\tbrate = mBratesOS[i] & 0x7f;\n\n\t\tif (is_brate) {\n\t\t\tswitch (brate) {\n\t\t\tcase IEEE80211_CCK_RATE_1MB:\n\t\t\t\t*pBrateCfg |= RATE_1M;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_CCK_RATE_2MB:\n\t\t\t\t*pBrateCfg |= RATE_2M;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_CCK_RATE_5MB:\n\t\t\t\t*pBrateCfg |= RATE_5_5M;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_CCK_RATE_11MB:\n\t\t\t\t*pBrateCfg |= RATE_11M;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_OFDM_RATE_6MB:\n\t\t\t\t*pBrateCfg |= RATE_6M;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_OFDM_RATE_9MB:\n\t\t\t\t*pBrateCfg |= RATE_9M;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_OFDM_RATE_12MB:\n\t\t\t\t*pBrateCfg |= RATE_12M;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_OFDM_RATE_18MB:\n\t\t\t\t*pBrateCfg |= RATE_18M;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_OFDM_RATE_24MB:\n\t\t\t\t*pBrateCfg |= RATE_24M;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_OFDM_RATE_36MB:\n\t\t\t\t*pBrateCfg |= RATE_36M;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_OFDM_RATE_48MB:\n\t\t\t\t*pBrateCfg |= RATE_48M;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_OFDM_RATE_54MB:\n\t\t\t\t*pBrateCfg |= RATE_54M;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void _OneOutPipeMapping(struct adapter *padapter)\n{\n\tstruct dvobj_priv *pdvobjpriv = adapter_to_dvobj(padapter);\n\n\tpdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[0]; \n\tpdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[0]; \n\tpdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[0]; \n\tpdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[0]; \n\n\tpdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0]; \n\tpdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0]; \n\tpdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0]; \n\tpdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0]; \n}\n\nstatic void _TwoOutPipeMapping(struct adapter *padapter, bool bWIFICfg)\n{\n\tstruct dvobj_priv *pdvobjpriv = adapter_to_dvobj(padapter);\n\n\tif (bWIFICfg) {  \n\n\t\t \n\t\t \n\t\t \n\n\t\tpdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[1]; \n\t\tpdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[1]; \n\t\tpdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[0]; \n\n\t\tpdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0]; \n\n\t} else {  \n\n\n\t\t \n\t\t \n\t\t \n\n\t\tpdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[1]; \n\t\tpdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[1]; \n\n\t\tpdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0]; \n\n\t}\n\n}\n\nstatic void _ThreeOutPipeMapping(struct adapter *padapter, bool bWIFICfg)\n{\n\tstruct dvobj_priv *pdvobjpriv = adapter_to_dvobj(padapter);\n\n\tif (bWIFICfg) {  \n\n\t\t \n\t\t \n\t\t \n\n\t\tpdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[1]; \n\t\tpdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[2]; \n\t\tpdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[1]; \n\n\t\tpdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0]; \n\n\t} else {  \n\n\n\t\t \n\t\t \n\t\t \n\n\t\tpdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[1]; \n\t\tpdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[2]; \n\t\tpdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[2]; \n\n\t\tpdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0]; \n\t\tpdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0]; \n\t}\n\n}\n\nbool Hal_MappingOutPipe(struct adapter *padapter, u8 NumOutPipe)\n{\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\n\tbool bWIFICfg = (pregistrypriv->wifi_spec) ? true : false;\n\n\tbool result = true;\n\n\tswitch (NumOutPipe) {\n\tcase 2:\n\t\t_TwoOutPipeMapping(padapter, bWIFICfg);\n\t\tbreak;\n\tcase 3:\n\tcase 4:\n\t\t_ThreeOutPipeMapping(padapter, bWIFICfg);\n\t\tbreak;\n\tcase 1:\n\t\t_OneOutPipeMapping(padapter);\n\t\tbreak;\n\tdefault:\n\t\tresult = false;\n\t\tbreak;\n\t}\n\n\treturn result;\n\n}\n\nvoid hal_init_macaddr(struct adapter *adapter)\n{\n\trtw_hal_set_hwreg(adapter, HW_VAR_MAC_ADDR, adapter->eeprompriv.mac_addr);\n}\n\nvoid rtw_init_hal_com_default_value(struct adapter *Adapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\n\n\tpHalData->AntDetection = 1;\n}\n\n \n\nvoid c2h_evt_clear(struct adapter *adapter)\n{\n\trtw_write8(adapter, REG_C2HEVT_CLEAR, C2H_EVT_HOST_CLOSE);\n}\n\n \ns32 c2h_evt_read_88xx(struct adapter *adapter, u8 *buf)\n{\n\ts32 ret = _FAIL;\n\tstruct c2h_evt_hdr_88xx *c2h_evt;\n\tint i;\n\tu8 trigger;\n\n\tif (!buf)\n\t\tgoto exit;\n\n\ttrigger = rtw_read8(adapter, REG_C2HEVT_CLEAR);\n\n\tif (trigger == C2H_EVT_HOST_CLOSE)\n\t\tgoto exit;  \n\telse if (trigger != C2H_EVT_FW_CLOSE)\n\t\tgoto clear_evt;  \n\n\tc2h_evt = (struct c2h_evt_hdr_88xx *)buf;\n\n\tmemset(c2h_evt, 0, 16);\n\n\tc2h_evt->id = rtw_read8(adapter, REG_C2HEVT_MSG_NORMAL);\n\tc2h_evt->seq = rtw_read8(adapter, REG_C2HEVT_CMD_SEQ_88XX);\n\tc2h_evt->plen = rtw_read8(adapter, REG_C2HEVT_CMD_LEN_88XX);\n\n\t \n\tfor (i = 0; i < c2h_evt->plen; i++)\n\t\tc2h_evt->payload[i] = rtw_read8(adapter, REG_C2HEVT_MSG_NORMAL + 2 + i);\n\n\tret = _SUCCESS;\n\nclear_evt:\n\t \n\tc2h_evt_clear(adapter);\nexit:\n\treturn ret;\n}\n\nu8 rtw_get_mgntframe_raid(struct adapter *adapter, unsigned char network_type)\n{\n\treturn (network_type & WIRELESS_11B) ? RATEID_IDX_B : RATEID_IDX_G;\n}\n\nvoid rtw_hal_update_sta_rate_mask(struct adapter *padapter, struct sta_info *psta)\n{\n\tu8 i, limit;\n\tu32 tx_ra_bitmap;\n\n\tif (!psta)\n\t\treturn;\n\n\ttx_ra_bitmap = 0;\n\n\t \n\tfor (i = 0; i < sizeof(psta->bssrateset); i++) {\n\t\tif (psta->bssrateset[i])\n\t\t\ttx_ra_bitmap |= rtw_get_bit_value_from_ieee_value(psta->bssrateset[i]&0x7f);\n\t}\n\n\t \n\tif (psta->htpriv.ht_option) {\n\t\tlimit = 8;  \n\n\t\tfor (i = 0; i < limit; i++) {\n\t\t\tif (psta->htpriv.ht_cap.mcs.rx_mask[i/8] & BIT(i%8))\n\t\t\t\ttx_ra_bitmap |= BIT(i+12);\n\t\t}\n\t}\n\n\tpsta->ra_mask = tx_ra_bitmap;\n\tpsta->init_rate = get_highest_rate_idx(tx_ra_bitmap)&0x3f;\n}\n\nvoid hw_var_port_switch(struct adapter *adapter)\n{\n}\n\nvoid SetHwReg(struct adapter *adapter, u8 variable, u8 *val)\n{\n\tstruct hal_com_data *hal_data = GET_HAL_DATA(adapter);\n\tstruct dm_odm_t *odm = &(hal_data->odmpriv);\n\n\tswitch (variable) {\n\tcase HW_VAR_PORT_SWITCH:\n\t\thw_var_port_switch(adapter);\n\t\tbreak;\n\tcase HW_VAR_INIT_RTS_RATE:\n\t\trtw_warn_on(1);\n\t\tbreak;\n\tcase HW_VAR_SEC_CFG:\n\t{\n\t\tu16 reg_scr;\n\n\t\treg_scr = rtw_read16(adapter, REG_SECCFG);\n\t\trtw_write16(adapter, REG_SECCFG, reg_scr|SCR_CHK_KEYID|SCR_RxDecEnable|SCR_TxEncEnable);\n\t}\n\t\tbreak;\n\tcase HW_VAR_SEC_DK_CFG:\n\t{\n\t\tstruct security_priv *sec = &adapter->securitypriv;\n\t\tu8 reg_scr = rtw_read8(adapter, REG_SECCFG);\n\n\t\tif (val) {  \n\t\t\treg_scr |= SCR_TXBCUSEDK;\n\t\t\tif (sec->dot11AuthAlgrthm != dot11AuthAlgrthm_8021X)\n\t\t\t\treg_scr |= (SCR_RxUseDK|SCR_TxUseDK);\n\t\t} else  \n\t\t\treg_scr &= ~(SCR_RXBCUSEDK|SCR_TXBCUSEDK|SCR_RxUseDK|SCR_TxUseDK);\n\n\t\trtw_write8(adapter, REG_SECCFG, reg_scr);\n\t}\n\t\tbreak;\n\tcase HW_VAR_DM_FLAG:\n\t\todm->SupportAbility = *((u32 *)val);\n\t\tbreak;\n\tcase HW_VAR_DM_FUNC_OP:\n\t\tif (*((u8 *)val) == true) {\n\t\t\t \n\t\t\todm->BK_SupportAbility = odm->SupportAbility;\n\t\t} else {\n\t\t\t \n\t\t\todm->SupportAbility = odm->BK_SupportAbility;\n\t\t}\n\t\tbreak;\n\tcase HW_VAR_DM_FUNC_SET:\n\t\tif (*((u32 *)val) == DYNAMIC_ALL_FUNC_ENABLE) {\n\t\t\tstruct dm_priv *dm = &hal_data->dmpriv;\n\t\t\tdm->DMFlag = dm->InitDMFlag;\n\t\t\todm->SupportAbility = dm->InitODMFlag;\n\t\t} else {\n\t\t\todm->SupportAbility |= *((u32 *)val);\n\t\t}\n\t\tbreak;\n\tcase HW_VAR_DM_FUNC_CLR:\n\t\t \n\t\todm->SupportAbility &= *((u32 *)val);\n\t\tbreak;\n\tcase HW_VAR_AMPDU_MIN_SPACE:\n\t\t \n\t\tbreak;\n\tcase HW_VAR_WIRELESS_MODE:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tnetdev_dbg(adapter->pnetdev,\n\t\t\t   FUNC_ADPT_FMT \" variable(%d) not defined!\\n\",\n\t\t\t   FUNC_ADPT_ARG(adapter), variable);\n\t\tbreak;\n\t}\n}\n\nvoid GetHwReg(struct adapter *adapter, u8 variable, u8 *val)\n{\n\tstruct hal_com_data *hal_data = GET_HAL_DATA(adapter);\n\tstruct dm_odm_t *odm = &(hal_data->odmpriv);\n\n\tswitch (variable) {\n\tcase HW_VAR_BASIC_RATE:\n\t\t*((u16 *)val) = hal_data->BasicRateSet;\n\t\tbreak;\n\tcase HW_VAR_DM_FLAG:\n\t\t*((u32 *)val) = odm->SupportAbility;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_dbg(adapter->pnetdev,\n\t\t\t   FUNC_ADPT_FMT \" variable(%d) not defined!\\n\",\n\t\t\t   FUNC_ADPT_ARG(adapter), variable);\n\t\tbreak;\n\t}\n}\n\n\n\n\nu8 SetHalDefVar(\n\tstruct adapter *adapter, enum hal_def_variable variable, void *value\n)\n{\n\tstruct hal_com_data *hal_data = GET_HAL_DATA(adapter);\n\tstruct dm_odm_t *odm = &(hal_data->odmpriv);\n\tu8 bResult = _SUCCESS;\n\n\tswitch (variable) {\n\tcase HAL_DEF_DBG_RX_INFO_DUMP:\n\n\t\tif (odm->bLinked) {\n\t\t\t#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA\n\t\t\trtw_dump_raw_rssi_info(adapter);\n\t\t\t#endif\n\t\t}\n\t\tbreak;\n\tcase HW_DEF_ODM_DBG_FLAG:\n\t\tODM_CmnInfoUpdate(odm, ODM_CMNINFO_DBG_COMP, *((u64 *)value));\n\t\tbreak;\n\tcase HW_DEF_ODM_DBG_LEVEL:\n\t\tODM_CmnInfoUpdate(odm, ODM_CMNINFO_DBG_LEVEL, *((u32 *)value));\n\t\tbreak;\n\tcase HAL_DEF_DBG_DM_FUNC:\n\t{\n\t\tu8 dm_func = *((u8 *)value);\n\t\tstruct dm_priv *dm = &hal_data->dmpriv;\n\n\t\tif (dm_func == 0) {  \n\t\t\todm->SupportAbility = DYNAMIC_FUNC_DISABLE;\n\t\t} else if (dm_func == 1) { \n\t\t\todm->SupportAbility  &= (~DYNAMIC_BB_DIG);\n\t\t} else if (dm_func == 2) { \n\t\t\todm->SupportAbility  &= (~DYNAMIC_BB_DYNAMIC_TXPWR);\n\t\t} else if (dm_func == 3) { \n\t\t\todm->SupportAbility  &= (~DYNAMIC_RF_CALIBRATION);\n\t\t} else if (dm_func == 4) { \n\t\t\tdm->DMFlag &= (~DYNAMIC_FUNC_BT);\n\t\t} else if (dm_func == 5) { \n\t\t\todm->SupportAbility  &= (~DYNAMIC_BB_ANT_DIV);\n\t\t} else if (dm_func == 6) { \n\t\t\tif (!(odm->SupportAbility  & DYNAMIC_BB_DIG)) {\n\t\t\t\tstruct dig_t\t*pDigTable = &odm->DM_DigTable;\n\t\t\t\tpDigTable->CurIGValue = rtw_read8(adapter, 0xc50);\n\t\t\t}\n\t\t\tdm->DMFlag |= DYNAMIC_FUNC_BT;\n\t\t\todm->SupportAbility = DYNAMIC_ALL_FUNC_ENABLE;\n\t\t}\n\t}\n\t\tbreak;\n\tcase HAL_DEF_DBG_DUMP_RXPKT:\n\t\thal_data->bDumpRxPkt = *((u8 *)value);\n\t\tbreak;\n\tcase HAL_DEF_DBG_DUMP_TXPKT:\n\t\thal_data->bDumpTxPkt = *((u8 *)value);\n\t\tbreak;\n\tcase HAL_DEF_ANT_DETECT:\n\t\thal_data->AntDetection = *((u8 *)value);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_dbg(adapter->pnetdev,\n\t\t\t   \"%s: [WARNING] HAL_DEF_VARIABLE(%d) not defined!\\n\",\n\t\t\t   __func__, variable);\n\t\tbResult = _FAIL;\n\t\tbreak;\n\t}\n\n\treturn bResult;\n}\n\nu8 GetHalDefVar(\n\tstruct adapter *adapter, enum hal_def_variable variable, void *value\n)\n{\n\tstruct hal_com_data *hal_data = GET_HAL_DATA(adapter);\n\tu8 bResult = _SUCCESS;\n\n\tswitch (variable) {\n\tcase HAL_DEF_UNDERCORATEDSMOOTHEDPWDB:\n\t\t{\n\t\t\tstruct mlme_priv *pmlmepriv;\n\t\t\tstruct sta_priv *pstapriv;\n\t\t\tstruct sta_info *psta;\n\n\t\t\tpmlmepriv = &adapter->mlmepriv;\n\t\t\tpstapriv = &adapter->stapriv;\n\t\t\tpsta = rtw_get_stainfo(pstapriv, pmlmepriv->cur_network.network.mac_address);\n\t\t\tif (psta)\n\t\t\t\t*((int *)value) = psta->rssi_stat.UndecoratedSmoothedPWDB;\n\t\t}\n\t\tbreak;\n\tcase HAL_DEF_DBG_DM_FUNC:\n\t\t*((u32 *)value) = hal_data->odmpriv.SupportAbility;\n\t\tbreak;\n\tcase HAL_DEF_DBG_DUMP_RXPKT:\n\t\t*((u8 *)value) = hal_data->bDumpRxPkt;\n\t\tbreak;\n\tcase HAL_DEF_DBG_DUMP_TXPKT:\n\t\t*((u8 *)value) = hal_data->bDumpTxPkt;\n\t\tbreak;\n\tcase HAL_DEF_ANT_DETECT:\n\t\t*((u8 *)value) = hal_data->AntDetection;\n\t\tbreak;\n\tcase HAL_DEF_MACID_SLEEP:\n\t\t*(u8 *)value = false;\n\t\tbreak;\n\tcase HAL_DEF_TX_PAGE_SIZE:\n\t\t*((u32 *)value) = PAGE_SIZE_128;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_dbg(adapter->pnetdev,\n\t\t\t   \"%s: [WARNING] HAL_DEF_VARIABLE(%d) not defined!\\n\",\n\t\t\t   __func__, variable);\n\t\tbResult = _FAIL;\n\t\tbreak;\n\t}\n\n\treturn bResult;\n}\n\nvoid GetHalODMVar(\n\tstruct adapter *Adapter,\n\tenum hal_odm_variable eVariable,\n\tvoid *pValue1,\n\tvoid *pValue2\n)\n{\n\tswitch (eVariable) {\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid SetHalODMVar(\n\tstruct adapter *Adapter,\n\tenum hal_odm_variable eVariable,\n\tvoid *pValue1,\n\tbool bSet\n)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(Adapter);\n\tstruct dm_odm_t *podmpriv = &pHalData->odmpriv;\n\t \n\tswitch (eVariable) {\n\tcase HAL_ODM_STA_INFO:\n\t\t{\n\t\t\tstruct sta_info *psta = pValue1;\n\t\t\tif (bSet) {\n\t\t\t\tODM_CmnInfoPtrArrayHook(podmpriv, ODM_CMNINFO_STA_STATUS, psta->mac_id, psta);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tODM_CmnInfoPtrArrayHook(podmpriv, ODM_CMNINFO_STA_STATUS, psta->mac_id, NULL);\n\n\t\t\t\t \n\t\t    }\n\t\t}\n\t\tbreak;\n\tcase HAL_ODM_P2P_STATE:\n\t\t\tODM_CmnInfoUpdate(podmpriv, ODM_CMNINFO_WIFI_DIRECT, bSet);\n\t\tbreak;\n\tcase HAL_ODM_WIFI_DISPLAY_STATE:\n\t\t\tODM_CmnInfoUpdate(podmpriv, ODM_CMNINFO_WIFI_DISPLAY, bSet);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n\nbool eqNByte(u8 *str1, u8 *str2, u32 num)\n{\n\tif (num == 0)\n\t\treturn false;\n\twhile (num > 0) {\n\t\tnum--;\n\t\tif (str1[num] != str2[num])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool GetU1ByteIntegerFromStringInDecimal(char *Str, u8 *pInt)\n{\n\tu16 i = 0;\n\t*pInt = 0;\n\n\twhile (Str[i] != '\\0') {\n\t\tif (Str[i] >= '0' && Str[i] <= '9') {\n\t\t\t*pInt *= 10;\n\t\t\t*pInt += (Str[i] - '0');\n\t\t} else\n\t\t\treturn false;\n\n\t\t++i;\n\t}\n\n\treturn true;\n}\n\nvoid rtw_hal_check_rxfifo_full(struct adapter *adapter)\n{\n\tstruct dvobj_priv *psdpriv = adapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\tint save_cnt = false;\n\n\t \n\t \n\trtw_write8(adapter, REG_RXERR_RPT+3, rtw_read8(adapter, REG_RXERR_RPT+3)|0xf0);\n\tsave_cnt = true;\n\t \n\n\tif (save_cnt) {\n\t\t \n\t\tpdbgpriv->dbg_rx_fifo_last_overflow = pdbgpriv->dbg_rx_fifo_curr_overflow;\n\t\tpdbgpriv->dbg_rx_fifo_curr_overflow = rtw_read16(adapter, REG_RXERR_RPT);\n\t\tpdbgpriv->dbg_rx_fifo_diff_overflow = pdbgpriv->dbg_rx_fifo_curr_overflow-pdbgpriv->dbg_rx_fifo_last_overflow;\n\t}\n}\n\n#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA\nvoid rtw_dump_raw_rssi_info(struct adapter *padapter)\n{\n\tu8 isCCKrate, rf_path;\n\tstruct hal_com_data *pHalData =  GET_HAL_DATA(padapter);\n\tstruct rx_raw_rssi *psample_pkt_rssi = &padapter->recvpriv.raw_rssi_info;\n\n\tisCCKrate = psample_pkt_rssi->data_rate <= DESC_RATE11M;\n\n\tif (isCCKrate)\n\t\tpsample_pkt_rssi->mimo_signal_strength[0] = psample_pkt_rssi->pwdball;\n\n\tfor (rf_path = 0; rf_path < pHalData->NumTotalRFPath; rf_path++) {\n\t\tif (!isCCKrate) {\n\t\t\tprintk(\", rx_ofdm_pwr:%d(dBm), rx_ofdm_snr:%d(dB)\\n\",\n\t\t\tpsample_pkt_rssi->ofdm_pwr[rf_path], psample_pkt_rssi->ofdm_snr[rf_path]);\n\t\t} else {\n\t\t\tprintk(\"\\n\");\n\t\t}\n\t}\n}\n\nvoid rtw_store_phy_info(struct adapter *padapter, union recv_frame *prframe)\n{\n\tu8 isCCKrate, rf_path;\n\tstruct hal_com_data *pHalData =  GET_HAL_DATA(padapter);\n\tstruct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;\n\n\tstruct odm_phy_info *pPhyInfo  = (PODM_PHY_INFO_T)(&pattrib->phy_info);\n\tstruct rx_raw_rssi *psample_pkt_rssi = &padapter->recvpriv.raw_rssi_info;\n\n\tpsample_pkt_rssi->data_rate = pattrib->data_rate;\n\tisCCKrate = pattrib->data_rate <= DESC_RATE11M;\n\n\tpsample_pkt_rssi->pwdball = pPhyInfo->rx_pwd_ba11;\n\tpsample_pkt_rssi->pwr_all = pPhyInfo->recv_signal_power;\n\n\tfor (rf_path = 0; rf_path < pHalData->NumTotalRFPath; rf_path++) {\n\t\tpsample_pkt_rssi->mimo_signal_strength[rf_path] = pPhyInfo->rx_mimo_signal_strength[rf_path];\n\t\tpsample_pkt_rssi->mimo_signal_quality[rf_path] = pPhyInfo->rx_mimo_signal_quality[rf_path];\n\t\tif (!isCCKrate) {\n\t\t\tpsample_pkt_rssi->ofdm_pwr[rf_path] = pPhyInfo->RxPwr[rf_path];\n\t\t\tpsample_pkt_rssi->ofdm_snr[rf_path] = pPhyInfo->RxSNR[rf_path];\n\t\t}\n\t}\n}\n#endif\n\nstatic u32 Array_kfreemap[] = {\n\t0xf8, 0xe,\n\t0xf6, 0xc,\n\t0xf4, 0xa,\n\t0xf2, 0x8,\n\t0xf0, 0x6,\n\t0xf3, 0x4,\n\t0xf5, 0x2,\n\t0xf7, 0x0,\n\t0xf9, 0x0,\n\t0xfc, 0x0,\n};\n\nvoid rtw_bb_rf_gain_offset(struct adapter *padapter)\n{\n\tu8 value = padapter->eeprompriv.EEPROMRFGainOffset;\n\tu32 res, i = 0;\n\tu32 *Array = Array_kfreemap;\n\tu32 v1 = 0, v2 = 0, target = 0;\n\n\tif (value & BIT4) {\n\t\tif (padapter->eeprompriv.EEPROMRFGainVal != 0xff) {\n\t\t\tres = rtw_hal_read_rfreg(padapter, RF_PATH_A, 0x7f, 0xffffffff);\n\t\t\tres &= 0xfff87fff;\n\t\t\t \n\t\t\tfor (i = 0; i < ARRAY_SIZE(Array_kfreemap); i += 2) {\n\t\t\t\tv1 = Array[i];\n\t\t\t\tv2 = Array[i+1];\n\t\t\t\tif (v1 == padapter->eeprompriv.EEPROMRFGainVal) {\n\t\t\t\t\ttarget = v2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPHY_SetRFReg(padapter, RF_PATH_A, REG_RF_BB_GAIN_OFFSET, BIT18|BIT17|BIT16|BIT15, target);\n\n\t\t\t \n\t\t\t \n\t\t\tres = rtw_hal_read_rfreg(padapter, RF_PATH_A, 0x7f, 0xffffffff);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}