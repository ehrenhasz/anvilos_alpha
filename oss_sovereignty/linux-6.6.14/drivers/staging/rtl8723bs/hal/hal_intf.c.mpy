{
  "module_name": "hal_intf.c",
  "hash_id": "d51ddd9891377d1a0ca5d007cbba09ad9c6f1fad660e24852eb5a0759793aab8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/hal/hal_intf.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <hal_data.h>\n\nvoid rtw_hal_chip_configure(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.intf_chip_configure)\n\t\tpadapter->HalFunc.intf_chip_configure(padapter);\n}\n\nvoid rtw_hal_read_chip_info(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.read_adapter_info)\n\t\tpadapter->HalFunc.read_adapter_info(padapter);\n}\n\nvoid rtw_hal_read_chip_version(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.read_chip_version)\n\t\tpadapter->HalFunc.read_chip_version(padapter);\n}\n\nvoid rtw_hal_def_value_init(struct adapter *padapter)\n{\n\tif (is_primary_adapter(padapter))\n\t\tif (padapter->HalFunc.init_default_value)\n\t\t\tpadapter->HalFunc.init_default_value(padapter);\n}\n\nvoid rtw_hal_free_data(struct adapter *padapter)\n{\n\t \n\trtw_hal_data_deinit(padapter);\n\n\tif (is_primary_adapter(padapter))\n\t\tif (padapter->HalFunc.free_hal_data)\n\t\t\tpadapter->HalFunc.free_hal_data(padapter);\n}\n\nvoid rtw_hal_dm_init(struct adapter *padapter)\n{\n\tif (is_primary_adapter(padapter))\n\t\tif (padapter->HalFunc.dm_init)\n\t\t\tpadapter->HalFunc.dm_init(padapter);\n}\n\nvoid rtw_hal_dm_deinit(struct adapter *padapter)\n{\n\t \n\tif (is_primary_adapter(padapter))\n\t\tif (padapter->HalFunc.dm_deinit)\n\t\t\tpadapter->HalFunc.dm_deinit(padapter);\n}\n\nstatic void rtw_hal_init_opmode(struct adapter *padapter)\n{\n\tenum ndis_802_11_network_infrastructure networkType = Ndis802_11InfrastructureMax;\n\tstruct  mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tsigned int fw_state;\n\n\tfw_state = get_fwstate(pmlmepriv);\n\n\tif (fw_state & WIFI_ADHOC_STATE)\n\t\tnetworkType = Ndis802_11IBSS;\n\telse if (fw_state & WIFI_STATION_STATE)\n\t\tnetworkType = Ndis802_11Infrastructure;\n\telse if (fw_state & WIFI_AP_STATE)\n\t\tnetworkType = Ndis802_11APMode;\n\telse\n\t\treturn;\n\n\trtw_setopmode_cmd(padapter, networkType, false);\n}\n\nuint rtw_hal_init(struct adapter *padapter)\n{\n\tuint status;\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(padapter);\n\n\tstatus = padapter->HalFunc.hal_init(padapter);\n\n\tif (status == _SUCCESS) {\n\t\trtw_hal_init_opmode(padapter);\n\n\t\tdvobj->padapters->hw_init_completed = true;\n\n\t\tif (padapter->registrypriv.notch_filter == 1)\n\t\t\trtw_hal_notch_filter(padapter, 1);\n\n\t\trtw_hal_reset_security_engine(padapter);\n\n\t\trtw_sec_restore_wep_key(dvobj->padapters);\n\n\t\tinit_hw_mlme_ext(padapter);\n\n\t\trtw_bb_rf_gain_offset(padapter);\n\t} else {\n\t\tdvobj->padapters->hw_init_completed = false;\n\t}\n\n\treturn status;\n}\n\nuint rtw_hal_deinit(struct adapter *padapter)\n{\n\tuint status = _SUCCESS;\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(padapter);\n\n\tstatus = padapter->HalFunc.hal_deinit(padapter);\n\n\tif (status == _SUCCESS) {\n\t\tpadapter = dvobj->padapters;\n\t\tpadapter->hw_init_completed = false;\n\t}\n\n\treturn status;\n}\n\nvoid rtw_hal_set_hwreg(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tif (padapter->HalFunc.SetHwRegHandler)\n\t\tpadapter->HalFunc.SetHwRegHandler(padapter, variable, val);\n}\n\nvoid rtw_hal_get_hwreg(struct adapter *padapter, u8 variable, u8 *val)\n{\n\tif (padapter->HalFunc.GetHwRegHandler)\n\t\tpadapter->HalFunc.GetHwRegHandler(padapter, variable, val);\n}\n\nvoid rtw_hal_set_hwreg_with_buf(struct adapter *padapter, u8 variable, u8 *pbuf, int len)\n{\n\tif (padapter->HalFunc.SetHwRegHandlerWithBuf)\n\t\tpadapter->HalFunc.SetHwRegHandlerWithBuf(padapter, variable, pbuf, len);\n}\n\nu8 rtw_hal_set_def_var(struct adapter *padapter, enum hal_def_variable eVariable, void *pValue)\n{\n\tif (padapter->HalFunc.SetHalDefVarHandler)\n\t\treturn padapter->HalFunc.SetHalDefVarHandler(padapter, eVariable, pValue);\n\treturn _FAIL;\n}\n\nu8 rtw_hal_get_def_var(struct adapter *padapter, enum hal_def_variable eVariable, void *pValue)\n{\n\tif (padapter->HalFunc.GetHalDefVarHandler)\n\t\treturn padapter->HalFunc.GetHalDefVarHandler(padapter, eVariable, pValue);\n\treturn _FAIL;\n}\n\nvoid rtw_hal_set_odm_var(struct adapter *padapter, enum hal_odm_variable eVariable, void *pValue1, bool bSet)\n{\n\tif (padapter->HalFunc.SetHalODMVarHandler)\n\t\tpadapter->HalFunc.SetHalODMVarHandler(padapter, eVariable, pValue1, bSet);\n}\n\nvoid rtw_hal_get_odm_var(struct adapter *padapter, enum hal_odm_variable eVariable, void *pValue1, void *pValue2)\n{\n\tif (padapter->HalFunc.GetHalODMVarHandler)\n\t\tpadapter->HalFunc.GetHalODMVarHandler(padapter, eVariable, pValue1, pValue2);\n}\n\nvoid rtw_hal_enable_interrupt(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.enable_interrupt)\n\t\tpadapter->HalFunc.enable_interrupt(padapter);\n}\n\nvoid rtw_hal_disable_interrupt(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.disable_interrupt)\n\t\tpadapter->HalFunc.disable_interrupt(padapter);\n}\n\nu8 rtw_hal_check_ips_status(struct adapter *padapter)\n{\n\tu8 val = false;\n\n\tif (padapter->HalFunc.check_ips_status)\n\t\tval = padapter->HalFunc.check_ips_status(padapter);\n\n\treturn val;\n}\n\ns32\trtw_hal_xmitframe_enqueue(struct adapter *padapter, struct xmit_frame *pxmitframe)\n{\n\tif (padapter->HalFunc.hal_xmitframe_enqueue)\n\t\treturn padapter->HalFunc.hal_xmitframe_enqueue(padapter, pxmitframe);\n\n\treturn false;\n}\n\ns32\trtw_hal_xmit(struct adapter *padapter, struct xmit_frame *pxmitframe)\n{\n\tif (padapter->HalFunc.hal_xmit)\n\t\treturn padapter->HalFunc.hal_xmit(padapter, pxmitframe);\n\n\treturn false;\n}\n\n \ns32\trtw_hal_mgnt_xmit(struct adapter *padapter, struct xmit_frame *pmgntframe)\n{\n\ts32 ret = _FAIL;\n\n\tupdate_mgntframe_attrib_addr(padapter, pmgntframe);\n\t \n\t \n\t \n\n\tif (padapter->securitypriv.binstallBIPkey == true) {\n\t\tif (is_multicast_ether_addr(pmgntframe->attrib.ra)) {\n\t\t\tpmgntframe->attrib.encrypt = _BIP_;\n\t\t\t \n\t\t} else {\n\t\t\tpmgntframe->attrib.encrypt = _AES_;\n\t\t\tpmgntframe->attrib.bswenc = true;\n\t\t}\n\t\trtw_mgmt_xmitframe_coalesce(padapter, pmgntframe->pkt, pmgntframe);\n\t}\n\n\tif (padapter->HalFunc.mgnt_xmit)\n\t\tret = padapter->HalFunc.mgnt_xmit(padapter, pmgntframe);\n\treturn ret;\n}\n\ns32\trtw_hal_init_xmit_priv(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.init_xmit_priv)\n\t\treturn padapter->HalFunc.init_xmit_priv(padapter);\n\treturn _FAIL;\n}\n\nvoid rtw_hal_free_xmit_priv(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.free_xmit_priv)\n\t\tpadapter->HalFunc.free_xmit_priv(padapter);\n}\n\ns32\trtw_hal_init_recv_priv(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.init_recv_priv)\n\t\treturn padapter->HalFunc.init_recv_priv(padapter);\n\n\treturn _FAIL;\n}\n\nvoid rtw_hal_free_recv_priv(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.free_recv_priv)\n\t\tpadapter->HalFunc.free_recv_priv(padapter);\n}\n\nvoid rtw_hal_update_ra_mask(struct sta_info *psta, u8 rssi_level)\n{\n\tstruct adapter *padapter;\n\tstruct mlme_priv *pmlmepriv;\n\n\tif (!psta)\n\t\treturn;\n\n\tpadapter = psta->padapter;\n\n\tpmlmepriv = &(padapter->mlmepriv);\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)\n\t\tadd_RATid(padapter, psta, rssi_level);\n\telse {\n\t\tif (padapter->HalFunc.UpdateRAMaskHandler)\n\t\t\tpadapter->HalFunc.UpdateRAMaskHandler(padapter, psta->mac_id, rssi_level);\n\t}\n}\n\nvoid rtw_hal_add_ra_tid(struct adapter *padapter, u32 bitmap, u8 *arg, u8 rssi_level)\n{\n\tif (padapter->HalFunc.Add_RateATid)\n\t\tpadapter->HalFunc.Add_RateATid(padapter, bitmap, arg, rssi_level);\n}\n\n \nvoid rtw_hal_start_thread(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.run_thread)\n\t\tpadapter->HalFunc.run_thread(padapter);\n}\n \nvoid rtw_hal_stop_thread(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.cancel_thread)\n\t\tpadapter->HalFunc.cancel_thread(padapter);\n}\n\nu32 rtw_hal_read_bbreg(struct adapter *padapter, u32 RegAddr, u32 BitMask)\n{\n\tu32 data = 0;\n\n\tif (padapter->HalFunc.read_bbreg)\n\t\t data = padapter->HalFunc.read_bbreg(padapter, RegAddr, BitMask);\n\treturn data;\n}\nvoid rtw_hal_write_bbreg(struct adapter *padapter, u32 RegAddr, u32 BitMask, u32 Data)\n{\n\tif (padapter->HalFunc.write_bbreg)\n\t\tpadapter->HalFunc.write_bbreg(padapter, RegAddr, BitMask, Data);\n}\n\nu32 rtw_hal_read_rfreg(struct adapter *padapter, u32 eRFPath, u32 RegAddr, u32 BitMask)\n{\n\tu32 data = 0;\n\n\tif (padapter->HalFunc.read_rfreg)\n\t\tdata = padapter->HalFunc.read_rfreg(padapter, eRFPath, RegAddr, BitMask);\n\treturn data;\n}\nvoid rtw_hal_write_rfreg(struct adapter *padapter, u32 eRFPath, u32 RegAddr, u32 BitMask, u32 Data)\n{\n\tif (padapter->HalFunc.write_rfreg)\n\t\tpadapter->HalFunc.write_rfreg(padapter, eRFPath, RegAddr, BitMask, Data);\n}\n\nvoid rtw_hal_set_chan(struct adapter *padapter, u8 channel)\n{\n\tif (padapter->HalFunc.set_channel_handler)\n\t\tpadapter->HalFunc.set_channel_handler(padapter, channel);\n}\n\nvoid rtw_hal_set_chnl_bw(struct adapter *padapter, u8 channel,\n\t\t\t enum channel_width Bandwidth, u8 Offset40, u8 Offset80)\n{\n\tif (padapter->HalFunc.set_chnl_bw_handler)\n\t\tpadapter->HalFunc.set_chnl_bw_handler(padapter, channel,\n\t\t\t\t\t\t      Bandwidth, Offset40,\n\t\t\t\t\t\t      Offset80);\n}\n\nvoid rtw_hal_dm_watchdog(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.hal_dm_watchdog)\n\t\tpadapter->HalFunc.hal_dm_watchdog(padapter);\n}\n\nvoid rtw_hal_dm_watchdog_in_lps(struct adapter *padapter)\n{\n\tif (adapter_to_pwrctl(padapter)->fw_current_in_ps_mode) {\n\t\tif (padapter->HalFunc.hal_dm_watchdog_in_lps)\n\t\t\tpadapter->HalFunc.hal_dm_watchdog_in_lps(padapter);  \n\t}\n}\n\nvoid beacon_timing_control(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.SetBeaconRelatedRegistersHandler)\n\t\tpadapter->HalFunc.SetBeaconRelatedRegistersHandler(padapter);\n}\n\n\ns32 rtw_hal_xmit_thread_handler(struct adapter *padapter)\n{\n\tif (padapter->HalFunc.xmit_thread_handler)\n\t\treturn padapter->HalFunc.xmit_thread_handler(padapter);\n\treturn _FAIL;\n}\n\nvoid rtw_hal_notch_filter(struct adapter *adapter, bool enable)\n{\n\tif (adapter->HalFunc.hal_notch_filter)\n\t\tadapter->HalFunc.hal_notch_filter(adapter, enable);\n}\n\nvoid rtw_hal_reset_security_engine(struct adapter *adapter)\n{\n\tif (adapter->HalFunc.hal_reset_security_engine)\n\t\tadapter->HalFunc.hal_reset_security_engine(adapter);\n}\n\nbool rtw_hal_c2h_valid(struct adapter *adapter, u8 *buf)\n{\n\treturn c2h_evt_valid((struct c2h_evt_hdr_88xx *)buf);\n}\n\ns32 rtw_hal_c2h_handler(struct adapter *adapter, u8 *c2h_evt)\n{\n\ts32 ret = _FAIL;\n\n\tif (adapter->HalFunc.c2h_handler)\n\t\tret = adapter->HalFunc.c2h_handler(adapter, c2h_evt);\n\treturn ret;\n}\n\nc2h_id_filter rtw_hal_c2h_id_filter_ccx(struct adapter *adapter)\n{\n\treturn adapter->HalFunc.c2h_id_filter_ccx;\n}\n\ns32 rtw_hal_macid_sleep(struct adapter *padapter, u32 macid)\n{\n\tu8 support;\n\n\tsupport = false;\n\trtw_hal_get_def_var(padapter, HAL_DEF_MACID_SLEEP, &support);\n\tif (false == support)\n\t\treturn _FAIL;\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_MACID_SLEEP, (u8 *)&macid);\n\n\treturn _SUCCESS;\n}\n\ns32 rtw_hal_macid_wakeup(struct adapter *padapter, u32 macid)\n{\n\tu8 support;\n\n\tsupport = false;\n\trtw_hal_get_def_var(padapter, HAL_DEF_MACID_SLEEP, &support);\n\tif (false == support)\n\t\treturn _FAIL;\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_MACID_WAKEUP, (u8 *)&macid);\n\n\treturn _SUCCESS;\n}\n\ns32 rtw_hal_fill_h2c_cmd(struct adapter *padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer)\n{\n\ts32 ret = _FAIL;\n\n\tif (padapter->HalFunc.fill_h2c_cmd)\n\t\tret = padapter->HalFunc.fill_h2c_cmd(padapter, ElementID, CmdLen, pCmdBuffer);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}