{
  "module_name": "rtl8723bs_xmit.c",
  "hash_id": "a3e515f9e1620801f33a0e1f02ad5391109c8f1f2cfe2c00db50ee4f9df1d334",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/hal/rtl8723bs_xmit.c",
  "human_readable_source": "\n \n\n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <rtl8723b_hal.h>\n\nstatic u8 rtw_sdio_wait_enough_TxOQT_space(struct adapter *padapter, u8 agg_num)\n{\n\tu32 n = 0;\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\n\twhile (pHalData->SdioTxOQTFreeSpace < agg_num) {\n\t\tif (\n\t\t\t(padapter->bSurpriseRemoved) ||\n\t\t\t(padapter->bDriverStopped)\n\t\t)\n\t\t\treturn false;\n\n\t\tHalQueryTxOQTBufferStatus8723BSdio(padapter);\n\n\t\tif ((++n % 60) == 0) {\n\t\t\tmsleep(1);\n\t\t\t \n\t\t}\n\t}\n\n\tpHalData->SdioTxOQTFreeSpace -= agg_num;\n\n\treturn true;\n}\n\nstatic s32 rtl8723_dequeue_writeport(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct dvobj_priv *pdvobjpriv = adapter_to_dvobj(padapter);\n\tstruct xmit_buf *pxmitbuf;\n\tstruct adapter *pri_padapter = padapter;\n\ts32 ret = 0;\n\tu8 PageIdx = 0;\n\tu32 deviceId;\n\tu8 bUpdatePageNum = false;\n\n\tret = ret || check_fwstate(pmlmepriv, _FW_UNDER_SURVEY);\n\n\tif (ret)\n\t\tpxmitbuf = dequeue_pending_xmitbuf_under_survey(pxmitpriv);\n\telse\n\t\tpxmitbuf = dequeue_pending_xmitbuf(pxmitpriv);\n\n\tif (!pxmitbuf)\n\t\treturn true;\n\n\tdeviceId = ffaddr2deviceId(pdvobjpriv, pxmitbuf->ff_hwaddr);\n\n\t \n\tswitch (deviceId) {\n\tcase WLAN_TX_HIQ_DEVICE_ID:\n\t\tPageIdx = HI_QUEUE_IDX;\n\t\tbreak;\n\n\tcase WLAN_TX_MIQ_DEVICE_ID:\n\t\tPageIdx = MID_QUEUE_IDX;\n\t\tbreak;\n\n\tcase WLAN_TX_LOQ_DEVICE_ID:\n\t\tPageIdx = LOW_QUEUE_IDX;\n\t\tbreak;\n\t}\n\nquery_free_page:\n\t \n\tif (!rtw_hal_sdio_query_tx_freepage(pri_padapter, PageIdx, pxmitbuf->pg_num)) {\n\t\tif (!bUpdatePageNum) {\n\t\t\t \n\t\t\tHalQueryTxBufferStatus8723BSdio(padapter);\n\t\t\tbUpdatePageNum = true;\n\t\t\tgoto query_free_page;\n\t\t} else {\n\t\t\tbUpdatePageNum = false;\n\t\t\tenqueue_pending_xmitbuf_to_head(pxmitpriv, pxmitbuf);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (\n\t\t(padapter->bSurpriseRemoved) ||\n\t\t(padapter->bDriverStopped)\n\t)\n\t\tgoto free_xmitbuf;\n\n\tif (rtw_sdio_wait_enough_TxOQT_space(padapter, pxmitbuf->agg_num) == false)\n\t\tgoto free_xmitbuf;\n\n\ttraffic_check_for_leave_lps(padapter, true, pxmitbuf->agg_num);\n\n\trtw_write_port(padapter, deviceId, pxmitbuf->len, (u8 *)pxmitbuf);\n\n\trtw_hal_sdio_update_tx_freepage(pri_padapter, PageIdx, pxmitbuf->pg_num);\n\nfree_xmitbuf:\n\t \n\t \n\trtw_free_xmitbuf(pxmitpriv, pxmitbuf);\n\n\treturn _FAIL;\n}\n\n \ns32 rtl8723bs_xmit_buf_handler(struct adapter *padapter)\n{\n\tstruct xmit_priv *pxmitpriv;\n\tu8 queue_empty, queue_pending;\n\ts32 ret;\n\n\n\tpxmitpriv = &padapter->xmitpriv;\n\n\tif (wait_for_completion_interruptible(&pxmitpriv->xmit_comp)) {\n\t\tnetdev_emerg(padapter->pnetdev,\n\t\t\t     \"%s: down SdioXmitBufSema fail!\\n\", __func__);\n\t\treturn _FAIL;\n\t}\n\n\tret = (padapter->bDriverStopped) || (padapter->bSurpriseRemoved);\n\tif (ret)\n\t\treturn _FAIL;\n\n\tqueue_pending = check_pending_xmitbuf(pxmitpriv);\n\n\tif (!queue_pending)\n\t\treturn _SUCCESS;\n\n\tret = rtw_register_tx_alive(padapter);\n\tif (ret != _SUCCESS) {\n\t\treturn _SUCCESS;\n\t}\n\n\tdo {\n\t\tqueue_empty = rtl8723_dequeue_writeport(padapter);\n \n\t} while (!queue_empty);\n\n\trtw_unregister_tx_alive(padapter);\n\n\treturn _SUCCESS;\n}\n\n \nstatic s32 xmit_xmitframes(struct adapter *padapter, struct xmit_priv *pxmitpriv)\n{\n\ts32 err, ret;\n\tu32 k = 0;\n\tstruct hw_xmit *hwxmits, *phwxmit;\n\tu8 idx, hwentry;\n\tstruct tx_servq *ptxservq;\n\tstruct list_head *sta_plist, *sta_phead, *frame_plist, *frame_phead, *tmp;\n\tstruct xmit_frame *pxmitframe;\n\tstruct __queue *pframe_queue;\n\tstruct xmit_buf *pxmitbuf;\n\tu32 txlen, max_xmit_len;\n\tu8 txdesc_size = TXDESC_SIZE;\n\tint inx[4];\n\n\terr = 0;\n\thwxmits = pxmitpriv->hwxmits;\n\thwentry = pxmitpriv->hwxmit_entry;\n\tptxservq = NULL;\n\tpxmitframe = NULL;\n\tpframe_queue = NULL;\n\tpxmitbuf = NULL;\n\n\tif (padapter->registrypriv.wifi_spec == 1) {\n\t\tfor (idx = 0; idx < 4; idx++)\n\t\t\tinx[idx] = pxmitpriv->wmm_para_seq[idx];\n\t} else {\n\t\tinx[0] = 0;\n\t\tinx[1] = 1;\n\t\tinx[2] = 2;\n\t\tinx[3] = 3;\n\t}\n\n\t \n\tfor (idx = 0; idx < hwentry; idx++) {\n\t\tphwxmit = hwxmits + inx[idx];\n\n\t\tif (\n\t\t\t(check_pending_xmitbuf(pxmitpriv)) &&\n\t\t\t(padapter->mlmepriv.LinkDetectInfo.bHigherBusyTxTraffic)\n\t\t) {\n\t\t\tif ((phwxmit->accnt > 0) && (phwxmit->accnt < 5)) {\n\t\t\t\terr = -2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmax_xmit_len = rtw_hal_get_sdio_tx_max_length(padapter, inx[idx]);\n\n\t\tspin_lock_bh(&pxmitpriv->lock);\n\n\t\tsta_phead = get_list_head(phwxmit->sta_queue);\n\t\t \n\t\t \n\t\tlist_for_each_safe(sta_plist, tmp, sta_phead) {\n\t\t\tptxservq = list_entry(sta_plist, struct tx_servq,\n\t\t\t\t\t      tx_pending);\n\n\t\t\tpframe_queue = &ptxservq->sta_pending;\n\n\t\t\tframe_phead = get_list_head(pframe_queue);\n\n\t\t\twhile (list_empty(frame_phead) == false) {\n\t\t\t\tframe_plist = get_next(frame_phead);\n\t\t\t\tpxmitframe = container_of(frame_plist, struct xmit_frame, list);\n\n\t\t\t\t \n\t\t\t\ttxlen = txdesc_size + rtw_wlan_pkt_size(pxmitframe);\n\t\t\t\tif (!pxmitbuf ||\n\t\t\t\t\t((_RND(pxmitbuf->len, 8) + txlen) > max_xmit_len) ||\n\t\t\t\t\t(k >= (rtw_hal_sdio_max_txoqt_free_space(padapter) - 1))\n\t\t\t\t) {\n\t\t\t\t\tif (pxmitbuf) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (pxmitbuf->len > 0 &&\n\t\t\t\t\t\t    pxmitbuf->priv_data) {\n\t\t\t\t\t\t\tstruct xmit_frame *pframe;\n\t\t\t\t\t\t\tpframe = (struct xmit_frame *)pxmitbuf->priv_data;\n\t\t\t\t\t\t\tpframe->agg_num = k;\n\t\t\t\t\t\t\tpxmitbuf->agg_num = k;\n\t\t\t\t\t\t\trtl8723b_update_txdesc(pframe, pframe->buf_addr);\n\t\t\t\t\t\t\trtw_free_xmitframe(pxmitpriv, pframe);\n\t\t\t\t\t\t\tpxmitbuf->priv_data = NULL;\n\t\t\t\t\t\t\tenqueue_pending_xmitbuf(pxmitpriv, pxmitbuf);\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\trtw_free_xmitbuf(pxmitpriv, pxmitbuf);\n\t\t\t\t\t}\n\n\t\t\t\t\tpxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);\n\t\t\t\t\tif (!pxmitbuf) {\n#ifdef DBG_XMIT_BUF\n\t\t\t\t\t\tnetdev_err(padapter->pnetdev,\n\t\t\t\t\t\t\t   \"%s: xmit_buf is not enough!\\n\",\n\t\t\t\t\t\t\t   __func__);\n#endif\n\t\t\t\t\t\terr = -2;\n\t\t\t\t\t\tcomplete(&(pxmitpriv->xmit_comp));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk = 0;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == true)\n\t\t\t\t\tif (\n\t\t\t\t\t\t(pxmitframe->attrib.psta->state & WIFI_SLEEP_STATE) &&\n\t\t\t\t\t\t(pxmitframe->attrib.triggered == 0)\n\t\t\t\t\t)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tlist_del_init(&pxmitframe->list);\n\t\t\t\tptxservq->qcnt--;\n\t\t\t\tphwxmit->accnt--;\n\n\t\t\t\tif (k == 0) {\n\t\t\t\t\tpxmitbuf->ff_hwaddr = rtw_get_ff_hwaddr(pxmitframe);\n\t\t\t\t\tpxmitbuf->priv_data = (u8 *)pxmitframe;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tpxmitframe->pxmitbuf = pxmitbuf;\n\t\t\t\tpxmitframe->buf_addr = pxmitbuf->ptail;\n\n\t\t\t\tret = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);\n\t\t\t\tif (ret == _FAIL) {\n\t\t\t\t\tnetdev_err(padapter->pnetdev,\n\t\t\t\t\t\t   \"%s: coalesce FAIL!\",\n\t\t\t\t\t\t   __func__);\n\t\t\t\t\t \n\t\t\t\t} else {\n\t\t\t\t\tk++;\n\t\t\t\t\tif (k != 1)\n\t\t\t\t\t\trtl8723b_update_txdesc(pxmitframe, pxmitframe->buf_addr);\n\t\t\t\t\trtw_count_tx_stats(padapter, pxmitframe, pxmitframe->attrib.last_txcmdsz);\n\n\t\t\t\t\ttxlen = txdesc_size + pxmitframe->attrib.last_txcmdsz;\n\t\t\t\t\tpxmitframe->pg_num = (txlen + 127) / 128;\n\t\t\t\t\tpxmitbuf->pg_num += (txlen + 127) / 128;\n\t\t\t\t\tpxmitbuf->ptail += _RND(txlen, 8);  \n\t\t\t\t\tpxmitbuf->len = _RND(pxmitbuf->len, 8) + txlen;\n\t\t\t\t}\n\n\t\t\t\tif (k != 1)\n\t\t\t\t\trtw_free_xmitframe(pxmitpriv, pxmitframe);\n\t\t\t\tpxmitframe = NULL;\n\t\t\t}\n\n\t\t\tif (list_empty(&pframe_queue->queue))\n\t\t\t\tlist_del_init(&ptxservq->tx_pending);\n\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_bh(&pxmitpriv->lock);\n\n\t\t \n\t\tif (pxmitbuf) {\n\t\t\tif (pxmitbuf->len > 0) {\n\t\t\t\tstruct xmit_frame *pframe;\n\t\t\t\tpframe = (struct xmit_frame *)pxmitbuf->priv_data;\n\t\t\t\tpframe->agg_num = k;\n\t\t\t\tpxmitbuf->agg_num = k;\n\t\t\t\trtl8723b_update_txdesc(pframe, pframe->buf_addr);\n\t\t\t\trtw_free_xmitframe(pxmitpriv, pframe);\n\t\t\t\tpxmitbuf->priv_data = NULL;\n\t\t\t\tenqueue_pending_xmitbuf(pxmitpriv, pxmitbuf);\n\t\t\t\tyield();\n\t\t\t} else\n\t\t\t\trtw_free_xmitbuf(pxmitpriv, pxmitbuf);\n\t\t\tpxmitbuf = NULL;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic s32 rtl8723bs_xmit_handler(struct adapter *padapter)\n{\n\tstruct xmit_priv *pxmitpriv;\n\ts32 ret;\n\n\n\tpxmitpriv = &padapter->xmitpriv;\n\n\tif (wait_for_completion_interruptible(&pxmitpriv->SdioXmitStart)) {\n\t\tnetdev_emerg(padapter->pnetdev, \"%s: SdioXmitStart fail!\\n\",\n\t\t\t     __func__);\n\t\treturn _FAIL;\n\t}\n\nnext:\n\tif (\n\t\t(padapter->bDriverStopped) ||\n\t\t(padapter->bSurpriseRemoved)\n\t)\n\t\treturn _FAIL;\n\n\tspin_lock_bh(&pxmitpriv->lock);\n\tret = rtw_txframes_pending(padapter);\n\tspin_unlock_bh(&pxmitpriv->lock);\n\tif (ret == 0) {\n\t\treturn _SUCCESS;\n\t}\n\n\t \n\n\tret = xmit_xmitframes(padapter, pxmitpriv);\n\tif (ret == -2) {\n\t\t \n\t\t \n\t\tif (padapter->registrypriv.wifi_spec)\n\t\t\tmsleep(1);\n\t\telse\n\t\t\tyield();\n\t\tgoto next;\n\t}\n\n\tspin_lock_bh(&pxmitpriv->lock);\n\tret = rtw_txframes_pending(padapter);\n\tspin_unlock_bh(&pxmitpriv->lock);\n\tif (ret == 1) {\n\t\tgoto next;\n\t}\n\n\treturn _SUCCESS;\n}\n\nint rtl8723bs_xmit_thread(void *context)\n{\n\ts32 ret;\n\tstruct adapter *padapter;\n\tstruct xmit_priv *pxmitpriv;\n\tu8 thread_name[20];\n\n\tret = _SUCCESS;\n\tpadapter = context;\n\tpxmitpriv = &padapter->xmitpriv;\n\n\trtw_sprintf(thread_name, 20, \"RTWHALXT-%s\", ADPT_ARG(padapter));\n\tthread_enter(thread_name);\n\n\tdo {\n\t\tret = rtl8723bs_xmit_handler(padapter);\n\t\tif (signal_pending(current)) {\n\t\t\tflush_signals(current);\n\t\t}\n\t} while (_SUCCESS == ret);\n\n\tcomplete(&pxmitpriv->SdioXmitTerminate);\n\n\treturn 0;\n}\n\ns32 rtl8723bs_mgnt_xmit(\n\tstruct adapter *padapter, struct xmit_frame *pmgntframe\n)\n{\n\ts32 ret = _SUCCESS;\n\tstruct pkt_attrib *pattrib;\n\tstruct xmit_buf *pxmitbuf;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct dvobj_priv *pdvobjpriv = adapter_to_dvobj(padapter);\n\tu8 *pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\tu8 txdesc_size = TXDESC_SIZE;\n\n\tpattrib = &pmgntframe->attrib;\n\tpxmitbuf = pmgntframe->pxmitbuf;\n\n\trtl8723b_update_txdesc(pmgntframe, pmgntframe->buf_addr);\n\n\tpxmitbuf->len = txdesc_size + pattrib->last_txcmdsz;\n\tpxmitbuf->pg_num = (pxmitbuf->len + 127) / 128;  \n\tpxmitbuf->ptail = pmgntframe->buf_addr + pxmitbuf->len;\n\tpxmitbuf->ff_hwaddr = rtw_get_ff_hwaddr(pmgntframe);\n\n\trtw_count_tx_stats(padapter, pmgntframe, pattrib->last_txcmdsz);\n\n\trtw_free_xmitframe(pxmitpriv, pmgntframe);\n\n\tpxmitbuf->priv_data = NULL;\n\n\tif (GetFrameSubType(pframe) == WIFI_BEACON) {  \n\t\tret = rtw_write_port(padapter, pdvobjpriv->Queue2Pipe[pxmitbuf->ff_hwaddr], pxmitbuf->len, (u8 *)pxmitbuf);\n\t\tif (ret != _SUCCESS)\n\t\t\trtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_WRITE_PORT_ERR);\n\n\t\trtw_free_xmitbuf(pxmitpriv, pxmitbuf);\n\t} else\n\t\tenqueue_pending_xmitbuf(pxmitpriv, pxmitbuf);\n\n\treturn ret;\n}\n\n \ns32 rtl8723bs_hal_xmit(\n\tstruct adapter *padapter, struct xmit_frame *pxmitframe\n)\n{\n\tstruct xmit_priv *pxmitpriv;\n\ts32 err;\n\n\n\tpxmitframe->attrib.qsel = pxmitframe->attrib.priority;\n\tpxmitpriv = &padapter->xmitpriv;\n\n\tif (\n\t\t(pxmitframe->frame_tag == DATA_FRAMETAG) &&\n\t\t(pxmitframe->attrib.ether_type != 0x0806) &&\n\t\t(pxmitframe->attrib.ether_type != 0x888e) &&\n\t\t(pxmitframe->attrib.dhcp_pkt != 1)\n\t) {\n\t\tif (padapter->mlmepriv.LinkDetectInfo.bBusyTraffic)\n\t\t\trtw_issue_addbareq_cmd(padapter, pxmitframe);\n\t}\n\n\tspin_lock_bh(&pxmitpriv->lock);\n\terr = rtw_xmitframe_enqueue(padapter, pxmitframe);\n\tspin_unlock_bh(&pxmitpriv->lock);\n\tif (err != _SUCCESS) {\n\t\trtw_free_xmitframe(pxmitpriv, pxmitframe);\n\n\t\tpxmitpriv->tx_drop++;\n\t\treturn true;\n\t}\n\n\tcomplete(&pxmitpriv->SdioXmitStart);\n\n\treturn false;\n}\n\ns32\trtl8723bs_hal_xmitframe_enqueue(\n\tstruct adapter *padapter, struct xmit_frame *pxmitframe\n)\n{\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\ts32 err;\n\n\terr = rtw_xmitframe_enqueue(padapter, pxmitframe);\n\tif (err != _SUCCESS) {\n\t\trtw_free_xmitframe(pxmitpriv, pxmitframe);\n\n\t\tpxmitpriv->tx_drop++;\n\t} else {\n\t\tcomplete(&pxmitpriv->SdioXmitStart);\n\t}\n\n\treturn err;\n\n}\n\n \ns32 rtl8723bs_init_xmit_priv(struct adapter *padapter)\n{\n\tstruct xmit_priv *xmitpriv = &padapter->xmitpriv;\n\tstruct hal_com_data *phal;\n\n\n\tphal = GET_HAL_DATA(padapter);\n\n\tspin_lock_init(&phal->SdioTxFIFOFreePageLock);\n\tinit_completion(&xmitpriv->SdioXmitStart);\n\tinit_completion(&xmitpriv->SdioXmitTerminate);\n\n\treturn _SUCCESS;\n}\n\nvoid rtl8723bs_free_xmit_priv(struct adapter *padapter)\n{\n\tstruct xmit_priv *pxmitpriv;\n\tstruct xmit_buf *pxmitbuf;\n\tstruct __queue *pqueue;\n\tstruct list_head *plist, *phead;\n\tstruct list_head tmplist;\n\n\n\tpxmitpriv = &padapter->xmitpriv;\n\tpqueue = &pxmitpriv->pending_xmitbuf_queue;\n\tphead = get_list_head(pqueue);\n\tINIT_LIST_HEAD(&tmplist);\n\n\tspin_lock_bh(&pqueue->lock);\n\tif (!list_empty(&pqueue->queue)) {\n\t\t \n\t\t \n\t\tlist_add_tail(&tmplist, phead);\n\t\tlist_del_init(phead);\n\t}\n\tspin_unlock_bh(&pqueue->lock);\n\n\tphead = &tmplist;\n\twhile (list_empty(phead) == false) {\n\t\tplist = get_next(phead);\n\t\tlist_del_init(plist);\n\n\t\tpxmitbuf = container_of(plist, struct xmit_buf, list);\n\t\trtw_free_xmitframe(pxmitpriv, (struct xmit_frame *)pxmitbuf->priv_data);\n\t\tpxmitbuf->priv_data = NULL;\n\t\trtw_free_xmitbuf(pxmitpriv, pxmitbuf);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}