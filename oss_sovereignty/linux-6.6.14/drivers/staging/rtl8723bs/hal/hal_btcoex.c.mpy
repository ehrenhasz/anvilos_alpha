{
  "module_name": "hal_btcoex.c",
  "hash_id": "e5f7a0d011b90a10b42d0f3d17441e2c4b076bef41480121fcdc70ad7be0ab32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/hal/hal_btcoex.c",
  "human_readable_source": "\n \n\n#include <hal_data.h>\n#include <rtw_debug.h>\n#include <hal_btcoex.h>\n#include <Mp_Precomp.h>\n\n \n\nstruct btc_coexist GLBtCoexist;\nstatic u8 GLBtcWiFiInScanState;\nstatic u8 GLBtcWiFiInIQKState;\n\n \n \n \nstatic u8 halbtcoutsrc_IsBtCoexistAvailable(struct btc_coexist *pBtCoexist)\n{\n\tif (!pBtCoexist->bBinded || !pBtCoexist->Adapter)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void halbtcoutsrc_LeaveLps(struct btc_coexist *pBtCoexist)\n{\n\tstruct adapter *padapter;\n\n\n\tpadapter = pBtCoexist->Adapter;\n\n\tpBtCoexist->btInfo.bBtCtrlLps = true;\n\tpBtCoexist->btInfo.bBtLpsOn = false;\n\n\trtw_btcoex_LPS_Leave(padapter);\n}\n\nstatic void halbtcoutsrc_EnterLps(struct btc_coexist *pBtCoexist)\n{\n\tstruct adapter *padapter;\n\n\n\tpadapter = pBtCoexist->Adapter;\n\n\tpBtCoexist->btInfo.bBtCtrlLps = true;\n\tpBtCoexist->btInfo.bBtLpsOn = true;\n\n\trtw_btcoex_LPS_Enter(padapter);\n}\n\nstatic void halbtcoutsrc_NormalLps(struct btc_coexist *pBtCoexist)\n{\n\tstruct adapter *padapter;\n\n\tpadapter = pBtCoexist->Adapter;\n\n\tif (pBtCoexist->btInfo.bBtCtrlLps) {\n\t\tpBtCoexist->btInfo.bBtLpsOn = false;\n\t\trtw_btcoex_LPS_Leave(padapter);\n\t\tpBtCoexist->btInfo.bBtCtrlLps = false;\n\n\t\t \n\t}\n}\n\n \nstatic void halbtcoutsrc_LeaveLowPower(struct btc_coexist *pBtCoexist)\n{\n\tstruct adapter *padapter;\n\ts32 ready;\n\tunsigned long stime;\n\tunsigned long utime;\n\tu32 timeout;  \n\n\n\tpadapter = pBtCoexist->Adapter;\n\tready = _FAIL;\n#ifdef LPS_RPWM_WAIT_MS\n\ttimeout = LPS_RPWM_WAIT_MS;\n#else  \n\ttimeout = 30;\n#endif  \n\n\tstime = jiffies;\n\tdo {\n\t\tready = rtw_register_task_alive(padapter, BTCOEX_ALIVE);\n\t\tif (_SUCCESS == ready)\n\t\t\tbreak;\n\n\t\tutime = jiffies_to_msecs(jiffies - stime);\n\t\tif (utime > timeout)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t} while (1);\n}\n\n \nstatic void halbtcoutsrc_NormalLowPower(struct btc_coexist *pBtCoexist)\n{\n\tstruct adapter *padapter;\n\n\n\tpadapter = pBtCoexist->Adapter;\n\trtw_unregister_task_alive(padapter, BTCOEX_ALIVE);\n}\n\nstatic void halbtcoutsrc_DisableLowPower(struct btc_coexist *pBtCoexist, u8 bLowPwrDisable)\n{\n\tpBtCoexist->btInfo.bBtDisableLowPwr = bLowPwrDisable;\n\tif (bLowPwrDisable)\n\t\thalbtcoutsrc_LeaveLowPower(pBtCoexist);\t\t \n\telse\n\t\thalbtcoutsrc_NormalLowPower(pBtCoexist);\t \n}\n\nstatic void halbtcoutsrc_AggregationCheck(struct btc_coexist *pBtCoexist)\n{\n\tstruct adapter *padapter;\n\tbool bNeedToAct;\n\n\n\tpadapter = pBtCoexist->Adapter;\n\tbNeedToAct = false;\n\n\tif (pBtCoexist->btInfo.bRejectAggPkt) {\n\t\trtw_btcoex_RejectApAggregatedPacket(padapter, true);\n\t} else {\n\t\tif (pBtCoexist->btInfo.bPreBtCtrlAggBufSize !=\n\t\t\tpBtCoexist->btInfo.bBtCtrlAggBufSize) {\n\t\t\tbNeedToAct = true;\n\t\t\tpBtCoexist->btInfo.bPreBtCtrlAggBufSize = pBtCoexist->btInfo.bBtCtrlAggBufSize;\n\t\t}\n\n\t\tif (pBtCoexist->btInfo.bBtCtrlAggBufSize) {\n\t\t\tif (pBtCoexist->btInfo.preAggBufSize !=\n\t\t\t\tpBtCoexist->btInfo.aggBufSize){\n\t\t\t\tbNeedToAct = true;\n\t\t\t}\n\t\t\tpBtCoexist->btInfo.preAggBufSize = pBtCoexist->btInfo.aggBufSize;\n\t\t}\n\n\t\tif (bNeedToAct) {\n\t\t\trtw_btcoex_RejectApAggregatedPacket(padapter, true);\n\t\t\trtw_btcoex_RejectApAggregatedPacket(padapter, false);\n\t\t}\n\t}\n}\n\nstatic u8 halbtcoutsrc_IsWifiBusy(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv;\n\n\n\tpmlmepriv = &padapter->mlmepriv;\n\n\tif (check_fwstate(pmlmepriv, WIFI_ASOC_STATE) == true) {\n\t\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)\n\t\t\treturn true;\n\t\tif (pmlmepriv->LinkDetectInfo.bBusyTraffic)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u32 _halbtcoutsrc_GetWifiLinkStatus(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv;\n\tu8 bp2p;\n\tu32 portConnectedStatus;\n\n\n\tpmlmepriv = &padapter->mlmepriv;\n\tbp2p = false;\n\tportConnectedStatus = 0;\n\n\tif (check_fwstate(pmlmepriv, WIFI_ASOC_STATE) == true) {\n\t\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {\n\t\t\tif (bp2p)\n\t\t\t\tportConnectedStatus |= WIFI_P2P_GO_CONNECTED;\n\t\t\telse\n\t\t\t\tportConnectedStatus |= WIFI_AP_CONNECTED;\n\t\t} else {\n\t\t\tif (bp2p)\n\t\t\t\tportConnectedStatus |= WIFI_P2P_GC_CONNECTED;\n\t\t\telse\n\t\t\t\tportConnectedStatus |= WIFI_STA_CONNECTED;\n\t\t}\n\t}\n\n\treturn portConnectedStatus;\n}\n\nstatic u32 halbtcoutsrc_GetWifiLinkStatus(struct btc_coexist *pBtCoexist)\n{\n\t \n\t \n\t \n\t \n\t \n\n\tstruct adapter *padapter;\n\tu32 retVal;\n\tu32 portConnectedStatus, numOfConnectedPort;\n\n\n\tpadapter = pBtCoexist->Adapter;\n\tportConnectedStatus = 0;\n\tnumOfConnectedPort = 0;\n\n\tretVal = _halbtcoutsrc_GetWifiLinkStatus(padapter);\n\tif (retVal) {\n\t\tportConnectedStatus |= retVal;\n\t\tnumOfConnectedPort++;\n\t}\n\n\tretVal = (numOfConnectedPort << 16) | portConnectedStatus;\n\n\treturn retVal;\n}\n\nstatic u32 halbtcoutsrc_GetBtPatchVer(struct btc_coexist *pBtCoexist)\n{\n\treturn pBtCoexist->btInfo.btRealFwVer;\n}\n\nstatic s32 halbtcoutsrc_GetWifiRssi(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\n\n\treturn pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB;\n}\n\nstatic u8 halbtcoutsrc_GetWifiScanAPNum(struct adapter *padapter)\n{\n\tstruct mlme_ext_priv *pmlmeext;\n\tstatic u8 scan_AP_num;\n\n\tpmlmeext = &padapter->mlmeextpriv;\n\n\tif (!GLBtcWiFiInScanState) {\n\t\tif (pmlmeext->sitesurvey_res.bss_cnt > 0xFF)\n\t\t\tscan_AP_num = 0xFF;\n\t\telse\n\t\t\tscan_AP_num = (u8)pmlmeext->sitesurvey_res.bss_cnt;\n\t}\n\n\treturn scan_AP_num;\n}\n\nstatic u8 halbtcoutsrc_Get(void *pBtcContext, u8 getType, void *pOutBuf)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\tstruct hal_com_data *pHalData;\n\tstruct mlme_ext_priv *mlmeext;\n\tu8 *pu8;\n\ts32 *pS4Tmp;\n\tu32 *pU4Tmp;\n\tu8 ret;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn false;\n\n\tpadapter = pBtCoexist->Adapter;\n\tpHalData = GET_HAL_DATA(padapter);\n\tmlmeext = &padapter->mlmeextpriv;\n\tpu8 = pOutBuf;\n\tpS4Tmp = pOutBuf;\n\tpU4Tmp = pOutBuf;\n\tret = true;\n\n\tswitch (getType) {\n\tcase BTC_GET_BL_HS_OPERATION:\n\t\t*pu8 = false;\n\t\tret = false;\n\t\tbreak;\n\n\tcase BTC_GET_BL_HS_CONNECTING:\n\t\t*pu8 = false;\n\t\tret = false;\n\t\tbreak;\n\n\tcase BTC_GET_BL_WIFI_CONNECTED:\n\t\t*pu8 = check_fwstate(&padapter->mlmepriv, WIFI_ASOC_STATE);\n\t\tbreak;\n\n\tcase BTC_GET_BL_WIFI_BUSY:\n\t\t*pu8 = halbtcoutsrc_IsWifiBusy(padapter);\n\t\tbreak;\n\n\tcase BTC_GET_BL_WIFI_SCAN:\n\t\t \n\t\t*pu8 = GLBtcWiFiInScanState;\n\t\tbreak;\n\n\tcase BTC_GET_BL_WIFI_LINK:\n\t\t*pu8 = check_fwstate(&padapter->mlmepriv, WIFI_UNDER_LINKING);\n\t\tbreak;\n\n\tcase BTC_GET_BL_WIFI_ROAM:\n\t\t*pu8 = check_fwstate(&padapter->mlmepriv, WIFI_UNDER_LINKING);\n\t\tbreak;\n\n\tcase BTC_GET_BL_WIFI_4_WAY_PROGRESS:\n\t\t*pu8 = false;\n\t\tbreak;\n\n\tcase BTC_GET_BL_WIFI_AP_MODE_ENABLE:\n\t\t*pu8 = check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE);\n\t\tbreak;\n\n\tcase BTC_GET_BL_WIFI_ENABLE_ENCRYPTION:\n\t\t*pu8 = padapter->securitypriv.dot11PrivacyAlgrthm != 0;\n\t\tbreak;\n\n\tcase BTC_GET_BL_WIFI_UNDER_B_MODE:\n\t\tif (mlmeext->cur_wireless_mode == WIRELESS_11B)\n\t\t\t*pu8 = true;\n\t\telse\n\t\t\t*pu8 = false;\n\t\tbreak;\n\n\tcase BTC_GET_BL_WIFI_IS_IN_MP_MODE:\n\t\t*pu8 = false;\n\t\tbreak;\n\n\tcase BTC_GET_BL_EXT_SWITCH:\n\t\t*pu8 = false;\n\t\tbreak;\n\n\tcase BTC_GET_S4_WIFI_RSSI:\n\t\t*pS4Tmp = halbtcoutsrc_GetWifiRssi(padapter);\n\t\tbreak;\n\n\tcase BTC_GET_S4_HS_RSSI:\n\t\t*pS4Tmp = 0;\n\t\tret = false;\n\t\tbreak;\n\n\tcase BTC_GET_U4_WIFI_BW:\n\t\tif (is_legacy_only(mlmeext->cur_wireless_mode))\n\t\t\t*pU4Tmp = BTC_WIFI_BW_LEGACY;\n\t\telse if (pHalData->CurrentChannelBW == CHANNEL_WIDTH_20)\n\t\t\t*pU4Tmp = BTC_WIFI_BW_HT20;\n\t\telse\n\t\t\t*pU4Tmp = BTC_WIFI_BW_HT40;\n\t\tbreak;\n\n\tcase BTC_GET_U4_WIFI_TRAFFIC_DIRECTION:\n\t\t{\n\t\t\tstruct rt_link_detect_t *plinkinfo;\n\t\t\tplinkinfo = &padapter->mlmepriv.LinkDetectInfo;\n\n\t\t\tif (plinkinfo->NumTxOkInPeriod > plinkinfo->NumRxOkInPeriod)\n\t\t\t\t*pU4Tmp = BTC_WIFI_TRAFFIC_TX;\n\t\t\telse\n\t\t\t\t*pU4Tmp = BTC_WIFI_TRAFFIC_RX;\n\t\t}\n\t\tbreak;\n\n\tcase BTC_GET_U4_WIFI_FW_VER:\n\t\t*pU4Tmp = pHalData->FirmwareVersion << 16;\n\t\t*pU4Tmp |= pHalData->FirmwareSubVersion;\n\t\tbreak;\n\n\tcase BTC_GET_U4_WIFI_LINK_STATUS:\n\t\t*pU4Tmp = halbtcoutsrc_GetWifiLinkStatus(pBtCoexist);\n\t\tbreak;\n\n\tcase BTC_GET_U4_BT_PATCH_VER:\n\t\t*pU4Tmp = halbtcoutsrc_GetBtPatchVer(pBtCoexist);\n\t\tbreak;\n\n\tcase BTC_GET_U1_WIFI_DOT11_CHNL:\n\t\t*pu8 = padapter->mlmeextpriv.cur_channel;\n\t\tbreak;\n\n\tcase BTC_GET_U1_WIFI_CENTRAL_CHNL:\n\t\t*pu8 = pHalData->CurrentChannel;\n\t\tbreak;\n\n\tcase BTC_GET_U1_WIFI_HS_CHNL:\n\t\t*pu8 = 0;\n\t\tret = false;\n\t\tbreak;\n\n\tcase BTC_GET_U1_MAC_PHY_MODE:\n\t\t*pu8 = BTC_SMSP;\n \n \n \n\t\tbreak;\n\n\tcase BTC_GET_U1_AP_NUM:\n\t\t*pu8 = halbtcoutsrc_GetWifiScanAPNum(padapter);\n\t\tbreak;\n\n\t \n\tcase BTC_GET_U1_LPS_MODE:\n\t\t*pu8 = padapter->dvobj->pwrctl_priv.pwr_mode;\n\t\tbreak;\n\n\tdefault:\n\t\tret = false;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic u8 halbtcoutsrc_Set(void *pBtcContext, u8 setType, void *pInBuf)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\tu8 *pu8;\n\tu32 *pU4Tmp;\n\tu8 ret;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\tpu8 = pInBuf;\n\tpU4Tmp = pInBuf;\n\tret = true;\n\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn false;\n\n\tswitch (setType) {\n\t \n\tcase BTC_SET_BL_BT_DISABLE:\n\t\tpBtCoexist->btInfo.bBtDisabled = *pu8;\n\t\tbreak;\n\n\tcase BTC_SET_BL_BT_TRAFFIC_BUSY:\n\t\tpBtCoexist->btInfo.bBtBusy = *pu8;\n\t\tbreak;\n\n\tcase BTC_SET_BL_BT_LIMITED_DIG:\n\t\tpBtCoexist->btInfo.bLimitedDig = *pu8;\n\t\tbreak;\n\n\tcase BTC_SET_BL_FORCE_TO_ROAM:\n\t\tpBtCoexist->btInfo.bForceToRoam = *pu8;\n\t\tbreak;\n\n\tcase BTC_SET_BL_TO_REJ_AP_AGG_PKT:\n\t\tpBtCoexist->btInfo.bRejectAggPkt = *pu8;\n\t\tbreak;\n\n\tcase BTC_SET_BL_BT_CTRL_AGG_SIZE:\n\t\tpBtCoexist->btInfo.bBtCtrlAggBufSize = *pu8;\n\t\tbreak;\n\n\tcase BTC_SET_BL_INC_SCAN_DEV_NUM:\n\t\tpBtCoexist->btInfo.bIncreaseScanDevNum = *pu8;\n\t\tbreak;\n\n\tcase BTC_SET_BL_BT_TX_RX_MASK:\n\t\tpBtCoexist->btInfo.bBtTxRxMask = *pu8;\n\t\tbreak;\n\n\t \n\tcase BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON:\n\t\tpBtCoexist->btInfo.rssiAdjustForAgcTableOn = *pu8;\n\t\tbreak;\n\n\tcase BTC_SET_U1_AGG_BUF_SIZE:\n\t\tpBtCoexist->btInfo.aggBufSize = *pu8;\n\t\tbreak;\n\n\t \n\tcase BTC_SET_ACT_GET_BT_RSSI:\n\t\tret = false;\n\t\tbreak;\n\n\tcase BTC_SET_ACT_AGGREGATE_CTRL:\n\t\thalbtcoutsrc_AggregationCheck(pBtCoexist);\n\t\tbreak;\n\n\t \n\t \n\tcase BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE:\n\t\tpBtCoexist->btInfo.rssiAdjustFor1AntCoexType = *pu8;\n\t\tbreak;\n\n\tcase BTC_SET_U1_LPS_VAL:\n\t\tpBtCoexist->btInfo.lpsVal = *pu8;\n\t\tbreak;\n\n\tcase BTC_SET_U1_RPWM_VAL:\n\t\tpBtCoexist->btInfo.rpwmVal = *pu8;\n\t\tbreak;\n\n\t \n\tcase BTC_SET_ACT_LEAVE_LPS:\n\t\thalbtcoutsrc_LeaveLps(pBtCoexist);\n\t\tbreak;\n\n\tcase BTC_SET_ACT_ENTER_LPS:\n\t\thalbtcoutsrc_EnterLps(pBtCoexist);\n\t\tbreak;\n\n\tcase BTC_SET_ACT_NORMAL_LPS:\n\t\thalbtcoutsrc_NormalLps(pBtCoexist);\n\t\tbreak;\n\n\tcase BTC_SET_ACT_DISABLE_LOW_POWER:\n\t\thalbtcoutsrc_DisableLowPower(pBtCoexist, *pu8);\n\t\tbreak;\n\n\tcase BTC_SET_ACT_UPDATE_RAMASK:\n\t\tpBtCoexist->btInfo.raMask = *pU4Tmp;\n\n\t\tif (check_fwstate(&padapter->mlmepriv, WIFI_ASOC_STATE) == true) {\n\t\t\tstruct sta_info *psta;\n\t\t\tstruct wlan_bssid_ex *cur_network;\n\n\t\t\tcur_network = &padapter->mlmeextpriv.mlmext_info.network;\n\t\t\tpsta = rtw_get_stainfo(&padapter->stapriv, cur_network->mac_address);\n\t\t\trtw_hal_update_ra_mask(psta, 0);\n\t\t}\n\t\tbreak;\n\n\tcase BTC_SET_ACT_SEND_MIMO_PS:\n\t\tret = false;\n\t\tbreak;\n\n\tcase BTC_SET_ACT_CTRL_BT_INFO:\n\t\tret = false;\n\t\tbreak;\n\n\tcase BTC_SET_ACT_CTRL_BT_COEX:\n\t\tret = false;\n\t\tbreak;\n\tcase BTC_SET_ACT_CTRL_8723B_ANT:\n\t\tret = false;\n\t\tbreak;\n\t \n\tdefault:\n\t\tret = false;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \n \n \nstatic u8 halbtcoutsrc_Read1Byte(void *pBtcContext, u32 RegAddr)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\n\treturn rtw_read8(padapter, RegAddr);\n}\n\nstatic u16 halbtcoutsrc_Read2Byte(void *pBtcContext, u32 RegAddr)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\n\treturn\trtw_read16(padapter, RegAddr);\n}\n\nstatic u32 halbtcoutsrc_Read4Byte(void *pBtcContext, u32 RegAddr)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\n\treturn\trtw_read32(padapter, RegAddr);\n}\n\nstatic void halbtcoutsrc_Write1Byte(void *pBtcContext, u32 RegAddr, u8 Data)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\n\trtw_write8(padapter, RegAddr, Data);\n}\n\nstatic void halbtcoutsrc_BitMaskWrite1Byte(void *pBtcContext, u32 regAddr, u8 bitMask, u8 data1b)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\tu8 originalValue, bitShift;\n\tu8 i;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\toriginalValue = 0;\n\tbitShift = 0;\n\n\tif (bitMask != 0xFF) {\n\t\toriginalValue = rtw_read8(padapter, regAddr);\n\n\t\tfor (i = 0; i <= 7; i++) {\n\t\t\tif ((bitMask >> i) & 0x1)\n\t\t\t\tbreak;\n\t\t}\n\t\tbitShift = i;\n\n\t\tdata1b = (originalValue & ~bitMask) | ((data1b << bitShift) & bitMask);\n\t}\n\n\trtw_write8(padapter, regAddr, data1b);\n}\n\nstatic void halbtcoutsrc_Write2Byte(void *pBtcContext, u32 RegAddr, u16 Data)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\n\trtw_write16(padapter, RegAddr, Data);\n}\n\nstatic void halbtcoutsrc_Write4Byte(void *pBtcContext, u32 RegAddr, u32 Data)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\n\trtw_write32(padapter, RegAddr, Data);\n}\n\nstatic void halbtcoutsrc_WriteLocalReg1Byte(void *pBtcContext, u32 RegAddr, u8 Data)\n{\n\tstruct btc_coexist *pBtCoexist = (struct btc_coexist *)pBtcContext;\n\tstruct adapter *Adapter = pBtCoexist->Adapter;\n\n\tif (BTC_INTF_SDIO == pBtCoexist->chipInterface)\n\t\trtw_write8(Adapter, SDIO_LOCAL_BASE | RegAddr, Data);\n\telse\n\t\trtw_write8(Adapter, RegAddr, Data);\n}\n\nstatic void halbtcoutsrc_SetBbReg(void *pBtcContext, u32 RegAddr, u32 BitMask, u32 Data)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\n\tPHY_SetBBReg(padapter, RegAddr, BitMask, Data);\n}\n\n\nstatic u32 halbtcoutsrc_GetBbReg(void *pBtcContext, u32 RegAddr, u32 BitMask)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\n\treturn PHY_QueryBBReg(padapter, RegAddr, BitMask);\n}\n\nstatic void halbtcoutsrc_SetRfReg(void *pBtcContext, u8 eRFPath, u32 RegAddr, u32 BitMask, u32 Data)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\n\tPHY_SetRFReg(padapter, eRFPath, RegAddr, BitMask, Data);\n}\n\nstatic u32 halbtcoutsrc_GetRfReg(void *pBtcContext, u8 eRFPath, u32 RegAddr, u32 BitMask)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\n\treturn PHY_QueryRFReg(padapter, eRFPath, RegAddr, BitMask);\n}\n\nstatic void halbtcoutsrc_SetBtReg(void *pBtcContext, u8 RegType, u32 RegAddr, u32 Data)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\tu8 CmdBuffer1[4] = {0};\n\tu8 CmdBuffer2[4] = {0};\n\tu8 *AddrToSet = (u8 *)&RegAddr;\n\tu8 *ValueToSet = (u8 *)&Data;\n\tu8 OperVer = 0;\n\tu8 ReqNum = 0;\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\n\tCmdBuffer1[0] |= (OperVer & 0x0f);\t\t\t\t\t\t \n\tCmdBuffer1[0] |= ((ReqNum << 4) & 0xf0);\t\t\t\t \n\tCmdBuffer1[1] = 0x0d;\t\t\t\t\t\t\t\t\t \n\tCmdBuffer1[2] = ValueToSet[0];\t\t\t\t\t\t\t \n\trtw_hal_fill_h2c_cmd(padapter, 0x67, 4, &(CmdBuffer1[0]));\n\n\tmsleep(200);\n\tReqNum++;\n\n\tCmdBuffer2[0] |= (OperVer & 0x0f);\t\t\t\t\t\t \n\tCmdBuffer2[0] |= ((ReqNum << 4) & 0xf0);\t\t\t\t \n\tCmdBuffer2[1] = 0x0c;\t\t\t\t\t\t\t\t\t \n\tCmdBuffer2[3] = AddrToSet[0];\t\t\t\t\t\t\t \n\trtw_hal_fill_h2c_cmd(padapter, 0x67, 4, &(CmdBuffer2[0]));\n}\n\nstatic u32 halbtcoutsrc_GetBtReg(void *pBtcContext, u8 RegType, u32 RegAddr)\n{\n\t \n\treturn 0;\n}\n\nstatic void halbtcoutsrc_FillH2cCmd(void *pBtcContext, u8 elementId, u32 cmdLen, u8 *pCmdBuffer)\n{\n\tstruct btc_coexist *pBtCoexist;\n\tstruct adapter *padapter;\n\n\n\tpBtCoexist = (struct btc_coexist *)pBtcContext;\n\tpadapter = pBtCoexist->Adapter;\n\n\trtw_hal_fill_h2c_cmd(padapter, elementId, cmdLen, pCmdBuffer);\n}\n\n \n \n \nstatic u8 EXhalbtcoutsrc_BindBtCoexWithAdapter(void *padapter)\n{\n\tstruct btc_coexist *pBtCoexist = &GLBtCoexist;\n\n\tif (pBtCoexist->bBinded)\n\t\treturn false;\n\telse\n\t\tpBtCoexist->bBinded = true;\n\n\tpBtCoexist->statistics.cntBind++;\n\n\tpBtCoexist->Adapter = padapter;\n\n\tpBtCoexist->stackInfo.bProfileNotified = false;\n\n\tpBtCoexist->btInfo.bBtCtrlAggBufSize = false;\n\tpBtCoexist->btInfo.aggBufSize = 5;\n\n\tpBtCoexist->btInfo.bIncreaseScanDevNum = false;\n\n\t \n\tpBtCoexist->boardInfo.btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT;\n\n\treturn true;\n}\n\nvoid hal_btcoex_Initialize(void *padapter)\n{\n\tstruct btc_coexist *pBtCoexist;\n\n\tmemset(&GLBtCoexist, 0, sizeof(GLBtCoexist));\n\n\tpBtCoexist = &GLBtCoexist;\n\n\t \n\n\tpBtCoexist->chipInterface = BTC_INTF_SDIO;\n\n\tEXhalbtcoutsrc_BindBtCoexWithAdapter(padapter);\n\n\tpBtCoexist->fBtcRead1Byte = halbtcoutsrc_Read1Byte;\n\tpBtCoexist->fBtcWrite1Byte = halbtcoutsrc_Write1Byte;\n\tpBtCoexist->fBtcWrite1ByteBitMask = halbtcoutsrc_BitMaskWrite1Byte;\n\tpBtCoexist->fBtcRead2Byte = halbtcoutsrc_Read2Byte;\n\tpBtCoexist->fBtcWrite2Byte = halbtcoutsrc_Write2Byte;\n\tpBtCoexist->fBtcRead4Byte = halbtcoutsrc_Read4Byte;\n\tpBtCoexist->fBtcWrite4Byte = halbtcoutsrc_Write4Byte;\n\tpBtCoexist->fBtcWriteLocalReg1Byte = halbtcoutsrc_WriteLocalReg1Byte;\n\n\tpBtCoexist->fBtcSetBbReg = halbtcoutsrc_SetBbReg;\n\tpBtCoexist->fBtcGetBbReg = halbtcoutsrc_GetBbReg;\n\n\tpBtCoexist->fBtcSetRfReg = halbtcoutsrc_SetRfReg;\n\tpBtCoexist->fBtcGetRfReg = halbtcoutsrc_GetRfReg;\n\n\tpBtCoexist->fBtcFillH2c = halbtcoutsrc_FillH2cCmd;\n\n\tpBtCoexist->fBtcGet = halbtcoutsrc_Get;\n\tpBtCoexist->fBtcSet = halbtcoutsrc_Set;\n\tpBtCoexist->fBtcGetBtReg = halbtcoutsrc_GetBtReg;\n\tpBtCoexist->fBtcSetBtReg = halbtcoutsrc_SetBtReg;\n\n\tpBtCoexist->boardInfo.singleAntPath = 0;\n\n\tGLBtcWiFiInScanState = false;\n\n\tGLBtcWiFiInIQKState = false;\n}\n\nvoid EXhalbtcoutsrc_PowerOnSetting(struct btc_coexist *pBtCoexist)\n{\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn;\n\n\t \n\tif (pBtCoexist->boardInfo.btdmAntNum == 2)\n\t\tEXhalbtc8723b2ant_PowerOnSetting(pBtCoexist);\n\telse if (pBtCoexist->boardInfo.btdmAntNum == 1)\n\t\tEXhalbtc8723b1ant_PowerOnSetting(pBtCoexist);\n}\n\nvoid EXhalbtcoutsrc_InitHwConfig(struct btc_coexist *pBtCoexist, u8 bWifiOnly)\n{\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn;\n\n\tpBtCoexist->statistics.cntInitHwConfig++;\n\n\tif (pBtCoexist->boardInfo.btdmAntNum == 2)\n\t\tEXhalbtc8723b2ant_InitHwConfig(pBtCoexist, bWifiOnly);\n\telse if (pBtCoexist->boardInfo.btdmAntNum == 1)\n\t\tEXhalbtc8723b1ant_InitHwConfig(pBtCoexist, bWifiOnly);\n}\n\nvoid EXhalbtcoutsrc_InitCoexDm(struct btc_coexist *pBtCoexist)\n{\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn;\n\n\tpBtCoexist->statistics.cntInitCoexDm++;\n\n\tif (pBtCoexist->boardInfo.btdmAntNum == 2)\n\t\tEXhalbtc8723b2ant_InitCoexDm(pBtCoexist);\n\telse if (pBtCoexist->boardInfo.btdmAntNum == 1)\n\t\tEXhalbtc8723b1ant_InitCoexDm(pBtCoexist);\n\n\tpBtCoexist->bInitilized = true;\n}\n\nvoid EXhalbtcoutsrc_IpsNotify(struct btc_coexist *pBtCoexist, u8 type)\n{\n\tu8 ipsType;\n\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn;\n\n\tpBtCoexist->statistics.cntIpsNotify++;\n\tif (pBtCoexist->bManualControl)\n\t\treturn;\n\n\tif (IPS_NONE == type)\n\t\tipsType = BTC_IPS_LEAVE;\n\telse\n\t\tipsType = BTC_IPS_ENTER;\n\n\t \n \n\n\tif (pBtCoexist->boardInfo.btdmAntNum == 2)\n\t\tEXhalbtc8723b2ant_IpsNotify(pBtCoexist, ipsType);\n\telse if (pBtCoexist->boardInfo.btdmAntNum == 1)\n\t\tEXhalbtc8723b1ant_IpsNotify(pBtCoexist, ipsType);\n\n \n}\n\nvoid EXhalbtcoutsrc_LpsNotify(struct btc_coexist *pBtCoexist, u8 type)\n{\n\tu8 lpsType;\n\n\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn;\n\n\tpBtCoexist->statistics.cntLpsNotify++;\n\tif (pBtCoexist->bManualControl)\n\t\treturn;\n\n\tif (PS_MODE_ACTIVE == type)\n\t\tlpsType = BTC_LPS_DISABLE;\n\telse\n\t\tlpsType = BTC_LPS_ENABLE;\n\n\tif (pBtCoexist->boardInfo.btdmAntNum == 2)\n\t\tEXhalbtc8723b2ant_LpsNotify(pBtCoexist, lpsType);\n\telse if (pBtCoexist->boardInfo.btdmAntNum == 1)\n\t\tEXhalbtc8723b1ant_LpsNotify(pBtCoexist, lpsType);\n}\n\nvoid EXhalbtcoutsrc_ScanNotify(struct btc_coexist *pBtCoexist, u8 type)\n{\n\tu8 scanType;\n\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn;\n\tpBtCoexist->statistics.cntScanNotify++;\n\tif (pBtCoexist->bManualControl)\n\t\treturn;\n\n\tif (type) {\n\t\tscanType = BTC_SCAN_START;\n\t\tGLBtcWiFiInScanState = true;\n\t} else {\n\t\tscanType = BTC_SCAN_FINISH;\n\t\tGLBtcWiFiInScanState = false;\n\t}\n\n\t \n \n\n\tif (pBtCoexist->boardInfo.btdmAntNum == 2)\n\t\tEXhalbtc8723b2ant_ScanNotify(pBtCoexist, scanType);\n\telse if (pBtCoexist->boardInfo.btdmAntNum == 1)\n\t\tEXhalbtc8723b1ant_ScanNotify(pBtCoexist, scanType);\n\n \n}\n\nvoid EXhalbtcoutsrc_ConnectNotify(struct btc_coexist *pBtCoexist, u8 action)\n{\n\tu8 assoType;\n\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn;\n\tpBtCoexist->statistics.cntConnectNotify++;\n\tif (pBtCoexist->bManualControl)\n\t\treturn;\n\n\tif (action)\n\t\tassoType = BTC_ASSOCIATE_START;\n\telse\n\t\tassoType = BTC_ASSOCIATE_FINISH;\n\n\t \n \n\n\tif (pBtCoexist->boardInfo.btdmAntNum == 2)\n\t\tEXhalbtc8723b2ant_ConnectNotify(pBtCoexist, assoType);\n\telse if (pBtCoexist->boardInfo.btdmAntNum == 1)\n\t\tEXhalbtc8723b1ant_ConnectNotify(pBtCoexist, assoType);\n\n \n}\n\nvoid EXhalbtcoutsrc_MediaStatusNotify(struct btc_coexist *pBtCoexist, enum\n\trt_media_status mediaStatus)\n{\n\tu8 mStatus;\n\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn;\n\n\tpBtCoexist->statistics.cntMediaStatusNotify++;\n\tif (pBtCoexist->bManualControl)\n\t\treturn;\n\n\tif (RT_MEDIA_CONNECT == mediaStatus)\n\t\tmStatus = BTC_MEDIA_CONNECT;\n\telse\n\t\tmStatus = BTC_MEDIA_DISCONNECT;\n\n\t \n \n\n\tif (pBtCoexist->boardInfo.btdmAntNum == 2)\n\t\tEXhalbtc8723b2ant_MediaStatusNotify(pBtCoexist, mStatus);\n\telse if (pBtCoexist->boardInfo.btdmAntNum == 1)\n\t\tEXhalbtc8723b1ant_MediaStatusNotify(pBtCoexist, mStatus);\n\n \n}\n\nvoid EXhalbtcoutsrc_SpecialPacketNotify(struct btc_coexist *pBtCoexist, u8 pktType)\n{\n\tu8 packetType;\n\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn;\n\tpBtCoexist->statistics.cntSpecialPacketNotify++;\n\tif (pBtCoexist->bManualControl)\n\t\treturn;\n\n\tif (PACKET_DHCP == pktType) {\n\t\tpacketType = BTC_PACKET_DHCP;\n\t} else if (PACKET_EAPOL == pktType) {\n\t\tpacketType = BTC_PACKET_EAPOL;\n\t} else if (PACKET_ARP == pktType) {\n\t\tpacketType = BTC_PACKET_ARP;\n\t} else {\n\t\treturn;\n\t}\n\n\t \n \n\n\tif (pBtCoexist->boardInfo.btdmAntNum == 2)\n\t\tEXhalbtc8723b2ant_SpecialPacketNotify(pBtCoexist, packetType);\n\telse if (pBtCoexist->boardInfo.btdmAntNum == 1)\n\t\tEXhalbtc8723b1ant_SpecialPacketNotify(pBtCoexist, packetType);\n\n \n}\n\nvoid EXhalbtcoutsrc_BtInfoNotify(struct btc_coexist *pBtCoexist, u8 *tmpBuf, u8 length)\n{\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn;\n\n\tpBtCoexist->statistics.cntBtInfoNotify++;\n\n\t \n \n\n\tif (pBtCoexist->boardInfo.btdmAntNum == 2)\n\t\tEXhalbtc8723b2ant_BtInfoNotify(pBtCoexist, tmpBuf, length);\n\telse if (pBtCoexist->boardInfo.btdmAntNum == 1)\n\t\tEXhalbtc8723b1ant_BtInfoNotify(pBtCoexist, tmpBuf, length);\n\n \n}\n\nvoid EXhalbtcoutsrc_HaltNotify(struct btc_coexist *pBtCoexist)\n{\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn;\n\n\tif (pBtCoexist->boardInfo.btdmAntNum == 2)\n\t\tEXhalbtc8723b2ant_HaltNotify(pBtCoexist);\n\telse if (pBtCoexist->boardInfo.btdmAntNum == 1)\n\t\tEXhalbtc8723b1ant_HaltNotify(pBtCoexist);\n\n\tpBtCoexist->bBinded = false;\n}\n\nvoid EXhalbtcoutsrc_PnpNotify(struct btc_coexist *pBtCoexist, u8 pnpState)\n{\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn;\n\n\t \n\t \n\t \n\t \n\n\tif (pBtCoexist->boardInfo.btdmAntNum == 1)\n\t\tEXhalbtc8723b1ant_PnpNotify(pBtCoexist, pnpState);\n\telse if (pBtCoexist->boardInfo.btdmAntNum == 2)\n\t\tEXhalbtc8723b2ant_PnpNotify(pBtCoexist, pnpState);\n}\n\nvoid EXhalbtcoutsrc_Periodical(struct btc_coexist *pBtCoexist)\n{\n\tif (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))\n\t\treturn;\n\tpBtCoexist->statistics.cntPeriodical++;\n\n\t \n\t \n \n\n\tif (pBtCoexist->boardInfo.btdmAntNum == 2)\n\t\tEXhalbtc8723b2ant_Periodical(pBtCoexist);\n\telse if (pBtCoexist->boardInfo.btdmAntNum == 1)\n\t\tEXhalbtc8723b1ant_Periodical(pBtCoexist);\n\n \n}\n\nvoid EXhalbtcoutsrc_SetAntNum(u8 type, u8 antNum)\n{\n\tif (BT_COEX_ANT_TYPE_PG == type) {\n\t\tGLBtCoexist.boardInfo.pgAntNum = antNum;\n\t\tGLBtCoexist.boardInfo.btdmAntNum = antNum;\n\t} else if (BT_COEX_ANT_TYPE_ANTDIV == type) {\n\t\tGLBtCoexist.boardInfo.btdmAntNum = antNum;\n\t\t \n\t} else if (BT_COEX_ANT_TYPE_DETECTED == type) {\n\t\tGLBtCoexist.boardInfo.btdmAntNum = antNum;\n\t\t \n\t}\n}\n\n \n \n \nvoid EXhalbtcoutsrc_SetSingleAntPath(u8 singleAntPath)\n{\n\tGLBtCoexist.boardInfo.singleAntPath = singleAntPath;\n}\n\n \nvoid hal_btcoex_SetBTCoexist(struct adapter *padapter, u8 bBtExist)\n{\n\tstruct hal_com_data *pHalData;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\tpHalData->bt_coexist.bBtExist = bBtExist;\n}\n\n \nbool hal_btcoex_IsBtExist(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\treturn pHalData->bt_coexist.bBtExist;\n}\n\nbool hal_btcoex_IsBtDisabled(struct adapter *padapter)\n{\n\tif (!hal_btcoex_IsBtExist(padapter))\n\t\treturn true;\n\n\tif (GLBtCoexist.btInfo.bBtDisabled)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nvoid hal_btcoex_SetPgAntNum(struct adapter *padapter, u8 antNum)\n{\n\tstruct hal_com_data *pHalData;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\n\tpHalData->bt_coexist.btTotalAntNum = antNum;\n\tEXhalbtcoutsrc_SetAntNum(BT_COEX_ANT_TYPE_PG, antNum);\n}\n\nvoid hal_btcoex_SetSingleAntPath(struct adapter *padapter, u8 singleAntPath)\n{\n\tEXhalbtcoutsrc_SetSingleAntPath(singleAntPath);\n}\n\nvoid hal_btcoex_PowerOnSetting(struct adapter *padapter)\n{\n\tEXhalbtcoutsrc_PowerOnSetting(&GLBtCoexist);\n}\n\nvoid hal_btcoex_InitHwConfig(struct adapter *padapter, u8 bWifiOnly)\n{\n\tif (!hal_btcoex_IsBtExist(padapter))\n\t\treturn;\n\n\tEXhalbtcoutsrc_InitHwConfig(&GLBtCoexist, bWifiOnly);\n\tEXhalbtcoutsrc_InitCoexDm(&GLBtCoexist);\n}\n\nvoid hal_btcoex_IpsNotify(struct adapter *padapter, u8 type)\n{\n\tEXhalbtcoutsrc_IpsNotify(&GLBtCoexist, type);\n}\n\nvoid hal_btcoex_LpsNotify(struct adapter *padapter, u8 type)\n{\n\tEXhalbtcoutsrc_LpsNotify(&GLBtCoexist, type);\n}\n\nvoid hal_btcoex_ScanNotify(struct adapter *padapter, u8 type)\n{\n\tEXhalbtcoutsrc_ScanNotify(&GLBtCoexist, type);\n}\n\nvoid hal_btcoex_ConnectNotify(struct adapter *padapter, u8 action)\n{\n\tEXhalbtcoutsrc_ConnectNotify(&GLBtCoexist, action);\n}\n\nvoid hal_btcoex_MediaStatusNotify(struct adapter *padapter, u8 mediaStatus)\n{\n\tEXhalbtcoutsrc_MediaStatusNotify(&GLBtCoexist, mediaStatus);\n}\n\nvoid hal_btcoex_SpecialPacketNotify(struct adapter *padapter, u8 pktType)\n{\n\tEXhalbtcoutsrc_SpecialPacketNotify(&GLBtCoexist, pktType);\n}\n\nvoid hal_btcoex_IQKNotify(struct adapter *padapter, u8 state)\n{\n\tGLBtcWiFiInIQKState = state;\n}\n\nvoid hal_btcoex_BtInfoNotify(struct adapter *padapter, u8 length, u8 *tmpBuf)\n{\n\tif (GLBtcWiFiInIQKState)\n\t\treturn;\n\n\tEXhalbtcoutsrc_BtInfoNotify(&GLBtCoexist, tmpBuf, length);\n}\n\nvoid hal_btcoex_SuspendNotify(struct adapter *padapter, u8 state)\n{\n\tif (state == 1)\n\t\tstate = BTC_WIFI_PNP_SLEEP;\n\telse\n\t\tstate = BTC_WIFI_PNP_WAKE_UP;\n\n\tEXhalbtcoutsrc_PnpNotify(&GLBtCoexist, state);\n}\n\nvoid hal_btcoex_HaltNotify(struct adapter *padapter)\n{\n\tEXhalbtcoutsrc_HaltNotify(&GLBtCoexist);\n}\n\nvoid hal_btcoex_Handler(struct adapter *padapter)\n{\n\tEXhalbtcoutsrc_Periodical(&GLBtCoexist);\n}\n\ns32 hal_btcoex_IsBTCoexCtrlAMPDUSize(struct adapter *padapter)\n{\n\treturn (s32)GLBtCoexist.btInfo.bBtCtrlAggBufSize;\n}\n\nbool hal_btcoex_IsBtControlLps(struct adapter *padapter)\n{\n\tif (!hal_btcoex_IsBtExist(padapter))\n\t\treturn false;\n\n\tif (GLBtCoexist.btInfo.bBtDisabled)\n\t\treturn false;\n\n\tif (GLBtCoexist.btInfo.bBtCtrlLps)\n\t\treturn true;\n\n\treturn false;\n}\n\nbool hal_btcoex_IsLpsOn(struct adapter *padapter)\n{\n\tif (!hal_btcoex_IsBtExist(padapter))\n\t\treturn false;\n\n\tif (GLBtCoexist.btInfo.bBtDisabled)\n\t\treturn false;\n\n\tif (GLBtCoexist.btInfo.bBtLpsOn)\n\t\treturn true;\n\n\treturn false;\n}\n\nu8 hal_btcoex_RpwmVal(struct adapter *padapter)\n{\n\treturn GLBtCoexist.btInfo.rpwmVal;\n}\n\nu8 hal_btcoex_LpsVal(struct adapter *padapter)\n{\n\treturn GLBtCoexist.btInfo.lpsVal;\n}\n\nu32 hal_btcoex_GetRaMask(struct adapter *padapter)\n{\n\tif (!hal_btcoex_IsBtExist(padapter))\n\t\treturn 0;\n\n\tif (GLBtCoexist.btInfo.bBtDisabled)\n\t\treturn 0;\n\n\tif (GLBtCoexist.boardInfo.btdmAntNum != 1)\n\t\treturn 0;\n\n\treturn GLBtCoexist.btInfo.raMask;\n}\n\nvoid hal_btcoex_RecordPwrMode(struct adapter *padapter, u8 *pCmdBuf, u8 cmdLen)\n{\n\tmemcpy(GLBtCoexist.pwrModeVal, pCmdBuf, cmdLen);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}