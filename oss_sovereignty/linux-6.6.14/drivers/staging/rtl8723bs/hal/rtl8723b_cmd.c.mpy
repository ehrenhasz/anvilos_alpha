{
  "module_name": "rtl8723b_cmd.c",
  "hash_id": "379bdda3e27a208c52f9fae36dc23d10c7a07ef835c69f279c989cbbaf948b31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/hal/rtl8723b_cmd.c",
  "human_readable_source": "\n \n\n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <rtl8723b_hal.h>\n#include \"hal_com_h2c.h\"\n\n#define MAX_H2C_BOX_NUMS\t4\n#define MESSAGE_BOX_SIZE\t4\n\n#define RTL8723B_MAX_CMD_LEN\t7\n#define RTL8723B_EX_MESSAGE_BOX_SIZE\t4\n\nstatic u8 _is_fw_read_cmd_down(struct adapter *padapter, u8 msgbox_num)\n{\n\tu8 read_down = false;\n\tint retry_cnts = 100;\n\n\tu8 valid;\n\n\tdo {\n\t\tvalid = rtw_read8(padapter, REG_HMETFR) & BIT(msgbox_num);\n\t\tif (0 == valid) {\n\t\t\tread_down = true;\n\t\t}\n\t} while ((!read_down) && (retry_cnts--));\n\n\treturn read_down;\n\n}\n\n\n \ns32 FillH2CCmd8723B(struct adapter *padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer)\n{\n\tu8 h2c_box_num;\n\tu32 msgbox_addr;\n\tu32 msgbox_ex_addr = 0;\n\tstruct hal_com_data *pHalData;\n\tu32 h2c_cmd = 0;\n\tu32 h2c_cmd_ex = 0;\n\ts32 ret = _FAIL;\n\n\tpadapter = GET_PRIMARY_ADAPTER(padapter);\n\tpHalData = GET_HAL_DATA(padapter);\n\tif (mutex_lock_interruptible(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex)))\n\t\treturn ret;\n\n\tif (!pCmdBuffer) {\n\t\tgoto exit;\n\t}\n\n\tif (CmdLen > RTL8723B_MAX_CMD_LEN) {\n\t\tgoto exit;\n\t}\n\n\tif (padapter->bSurpriseRemoved)\n\t\tgoto exit;\n\n\t \n\tdo {\n\t\th2c_box_num = pHalData->LastHMEBoxNum;\n\n\t\tif (!_is_fw_read_cmd_down(padapter, h2c_box_num))\n\t\t\tgoto exit;\n\n\t\tif (CmdLen <= 3)\n\t\t\tmemcpy((u8 *)(&h2c_cmd)+1, pCmdBuffer, CmdLen);\n\t\telse {\n\t\t\tmemcpy((u8 *)(&h2c_cmd)+1, pCmdBuffer, 3);\n\t\t\tmemcpy((u8 *)(&h2c_cmd_ex), pCmdBuffer+3, CmdLen-3);\n \n\t\t}\n\n\t\t*(u8 *)(&h2c_cmd) |= ElementID;\n\n\t\tif (CmdLen > 3) {\n\t\t\tmsgbox_ex_addr = REG_HMEBOX_EXT0_8723B + (h2c_box_num*RTL8723B_EX_MESSAGE_BOX_SIZE);\n\t\t\trtw_write32(padapter, msgbox_ex_addr, h2c_cmd_ex);\n\t\t}\n\t\tmsgbox_addr = REG_HMEBOX_0 + (h2c_box_num*MESSAGE_BOX_SIZE);\n\t\trtw_write32(padapter, msgbox_addr, h2c_cmd);\n\n\t\tpHalData->LastHMEBoxNum = (h2c_box_num+1) % MAX_H2C_BOX_NUMS;\n\n\t} while (0);\n\n\tret = _SUCCESS;\n\nexit:\n\n\tmutex_unlock(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex));\n\treturn ret;\n}\n\nstatic void ConstructBeacon(struct adapter *padapter, u8 *pframe, u32 *pLength)\n{\n\tstruct ieee80211_hdr *pwlanhdr;\n\t__le16 *fctrl;\n\tu32 rate_len, pktlen;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\n\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\n\teth_broadcast_addr(pwlanhdr->addr1);\n\tmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\tmemcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);\n\n\tSetSeqNum(pwlanhdr, 0 );\n\t \n\tSetFrameSubType(pframe, WIFI_BEACON);\n\n\tpframe += sizeof(struct ieee80211_hdr_3addr);\n\tpktlen = sizeof(struct ieee80211_hdr_3addr);\n\n\t \n\tpframe += 8;\n\tpktlen += 8;\n\n\t \n\tmemcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->ies)), 2);\n\n\tpframe += 2;\n\tpktlen += 2;\n\n\t \n\tmemcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->ies)), 2);\n\n\tpframe += 2;\n\tpktlen += 2;\n\n\tif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {\n\t\tpktlen += cur_network->ie_length - sizeof(struct ndis_802_11_fix_ie);\n\t\tmemcpy(pframe, cur_network->ies+sizeof(struct ndis_802_11_fix_ie), pktlen);\n\n\t\tgoto _ConstructBeacon;\n\t}\n\n\t \n\n\t \n\tpframe = rtw_set_ie(pframe, WLAN_EID_SSID, cur_network->ssid.ssid_length, cur_network->ssid.ssid, &pktlen);\n\n\t \n\trate_len = rtw_get_rateset_len(cur_network->supported_rates);\n\tpframe = rtw_set_ie(pframe, WLAN_EID_SUPP_RATES, ((rate_len > 8) ? 8 : rate_len), cur_network->supported_rates, &pktlen);\n\n\t \n\tpframe = rtw_set_ie(pframe, WLAN_EID_DS_PARAMS, 1, (unsigned char *)&(cur_network->configuration.ds_config), &pktlen);\n\n\tif ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {\n\t\tu32 ATIMWindow;\n\t\t \n\t\t \n\t\tATIMWindow = 0;\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_IBSS_PARAMS, 2, (unsigned char *)(&ATIMWindow), &pktlen);\n\t}\n\n\n\t \n\n\n\t \n\tif (rate_len > 8)\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_EXT_SUPP_RATES, (rate_len - 8), (cur_network->supported_rates + 8), &pktlen);\n\n\n\t \n\n_ConstructBeacon:\n\n\tif ((pktlen + TXDESC_SIZE) > 512)\n\t\treturn;\n\n\t*pLength = pktlen;\n\n}\n\nstatic void ConstructPSPoll(struct adapter *padapter, u8 *pframe, u32 *pLength)\n{\n\tstruct ieee80211_hdr *pwlanhdr;\n\t__le16 *fctrl;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\t \n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\tSetPwrMgt(fctrl);\n\tSetFrameSubType(pframe, WIFI_PSPOLL);\n\n\t \n\tSetDuration(pframe, (pmlmeinfo->aid | 0xc000));\n\n\t \n\tmemcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\n\t \n\tmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\n\t*pLength = 16;\n}\n\nstatic void ConstructNullFunctionData(\n\tstruct adapter *padapter,\n\tu8 *pframe,\n\tu32 *pLength,\n\tu8 *StaAddr,\n\tu8 bQoS,\n\tu8 AC,\n\tu8 bEosp,\n\tu8 bForcePowerSave\n)\n{\n\tstruct ieee80211_hdr *pwlanhdr;\n\t__le16 *fctrl;\n\tu32 pktlen;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct wlan_network *cur_network = &pmlmepriv->cur_network;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tfctrl = &pwlanhdr->frame_control;\n\t*(fctrl) = 0;\n\tif (bForcePowerSave)\n\t\tSetPwrMgt(fctrl);\n\n\tswitch (cur_network->network.infrastructure_mode) {\n\tcase Ndis802_11Infrastructure:\n\t\tSetToDs(fctrl);\n\t\tmemcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\t\tmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\t\tmemcpy(pwlanhdr->addr3, StaAddr, ETH_ALEN);\n\t\tbreak;\n\tcase Ndis802_11APMode:\n\t\tSetFrDs(fctrl);\n\t\tmemcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);\n\t\tmemcpy(pwlanhdr->addr2, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\t\tmemcpy(pwlanhdr->addr3, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\t\tbreak;\n\tcase Ndis802_11IBSS:\n\tdefault:\n\t\tmemcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);\n\t\tmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\t\tmemcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\t\tbreak;\n\t}\n\n\tSetSeqNum(pwlanhdr, 0);\n\n\tif (bQoS) {\n\t\tstruct ieee80211_qos_hdr *pwlanqoshdr;\n\n\t\tSetFrameSubType(pframe, WIFI_QOS_DATA_NULL);\n\n\t\tpwlanqoshdr = (struct ieee80211_qos_hdr *)pframe;\n\t\tSetPriority(&pwlanqoshdr->qos_ctrl, AC);\n\t\tSetEOSP(&pwlanqoshdr->qos_ctrl, bEosp);\n\n\t\tpktlen = sizeof(struct ieee80211_qos_hdr);\n\t} else {\n\t\tSetFrameSubType(pframe, WIFI_DATA_NULL);\n\n\t\tpktlen = sizeof(struct ieee80211_hdr_3addr);\n\t}\n\n\t*pLength = pktlen;\n}\n\n \n \nvoid CheckFwRsvdPageContent(struct adapter *Adapter)\n{\n}\n\nstatic void rtl8723b_set_FwRsvdPage_cmd(struct adapter *padapter, struct rsvdpage_loc *rsvdpageloc)\n{\n\tu8 u1H2CRsvdPageParm[H2C_RSVDPAGE_LOC_LEN] = {0};\n\n\tSET_8723B_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(u1H2CRsvdPageParm, rsvdpageloc->LocProbeRsp);\n\tSET_8723B_H2CCMD_RSVDPAGE_LOC_PSPOLL(u1H2CRsvdPageParm, rsvdpageloc->LocPsPoll);\n\tSET_8723B_H2CCMD_RSVDPAGE_LOC_NULL_DATA(u1H2CRsvdPageParm, rsvdpageloc->LocNullData);\n\tSET_8723B_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(u1H2CRsvdPageParm, rsvdpageloc->LocQosNull);\n\tSET_8723B_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(u1H2CRsvdPageParm, rsvdpageloc->LocBTQosNull);\n\n\tFillH2CCmd8723B(padapter, H2C_8723B_RSVD_PAGE, H2C_RSVDPAGE_LOC_LEN, u1H2CRsvdPageParm);\n}\n\nstatic void rtl8723b_set_FwAoacRsvdPage_cmd(struct adapter *padapter, struct rsvdpage_loc *rsvdpageloc)\n{\n}\n\nvoid rtl8723b_set_FwMediaStatusRpt_cmd(struct adapter *padapter, u8 mstatus, u8 macid)\n{\n\tu8 u1H2CMediaStatusRptParm[H2C_MEDIA_STATUS_RPT_LEN] = {0};\n\tu8 macid_end = 0;\n\n\tSET_8723B_H2CCMD_MSRRPT_PARM_OPMODE(u1H2CMediaStatusRptParm, mstatus);\n\tSET_8723B_H2CCMD_MSRRPT_PARM_MACID_IND(u1H2CMediaStatusRptParm, 0);\n\tSET_8723B_H2CCMD_MSRRPT_PARM_MACID(u1H2CMediaStatusRptParm, macid);\n\tSET_8723B_H2CCMD_MSRRPT_PARM_MACID_END(u1H2CMediaStatusRptParm, macid_end);\n\n\tFillH2CCmd8723B(padapter, H2C_8723B_MEDIA_STATUS_RPT, H2C_MEDIA_STATUS_RPT_LEN, u1H2CMediaStatusRptParm);\n}\n\nvoid rtl8723b_set_FwMacIdConfig_cmd(struct adapter *padapter, u8 mac_id, u8 raid, u8 bw, u8 sgi, u32 mask)\n{\n\tu8 u1H2CMacIdConfigParm[H2C_MACID_CFG_LEN] = {0};\n\n\tSET_8723B_H2CCMD_MACID_CFG_MACID(u1H2CMacIdConfigParm, mac_id);\n\tSET_8723B_H2CCMD_MACID_CFG_RAID(u1H2CMacIdConfigParm, raid);\n\tSET_8723B_H2CCMD_MACID_CFG_SGI_EN(u1H2CMacIdConfigParm, sgi ? 1 : 0);\n\tSET_8723B_H2CCMD_MACID_CFG_BW(u1H2CMacIdConfigParm, bw);\n\tSET_8723B_H2CCMD_MACID_CFG_RATE_MASK0(u1H2CMacIdConfigParm, (u8)(mask & 0x000000ff));\n\tSET_8723B_H2CCMD_MACID_CFG_RATE_MASK1(u1H2CMacIdConfigParm, (u8)((mask & 0x0000ff00) >> 8));\n\tSET_8723B_H2CCMD_MACID_CFG_RATE_MASK2(u1H2CMacIdConfigParm, (u8)((mask & 0x00ff0000) >> 16));\n\tSET_8723B_H2CCMD_MACID_CFG_RATE_MASK3(u1H2CMacIdConfigParm, (u8)((mask & 0xff000000) >> 24));\n\n\tFillH2CCmd8723B(padapter, H2C_8723B_MACID_CFG, H2C_MACID_CFG_LEN, u1H2CMacIdConfigParm);\n}\n\nvoid rtl8723b_set_rssi_cmd(struct adapter *padapter, u8 *param)\n{\n\tu8 u1H2CRssiSettingParm[H2C_RSSI_SETTING_LEN] = {0};\n\tu8 mac_id = *param;\n\tu8 rssi = *(param+2);\n\tu8 uldl_state = 0;\n\n\tSET_8723B_H2CCMD_RSSI_SETTING_MACID(u1H2CRssiSettingParm, mac_id);\n\tSET_8723B_H2CCMD_RSSI_SETTING_RSSI(u1H2CRssiSettingParm, rssi);\n\tSET_8723B_H2CCMD_RSSI_SETTING_ULDL_STATE(u1H2CRssiSettingParm, uldl_state);\n\n\tFillH2CCmd8723B(padapter, H2C_8723B_RSSI_SETTING, H2C_RSSI_SETTING_LEN, u1H2CRssiSettingParm);\n}\n\nvoid rtl8723b_set_FwPwrMode_cmd(struct adapter *padapter, u8 psmode)\n{\n\tint i;\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tu8 u1H2CPwrModeParm[H2C_PWRMODE_LEN] = {0};\n\tu8 PowerState = 0, awake_intvl = 1, byte5 = 0, rlbm = 0;\n\n\tif (pwrpriv->dtim > 0 && pwrpriv->dtim < 16)\n\t\tawake_intvl = pwrpriv->dtim+1; \n\telse\n\t\tawake_intvl = 3; \n\n\trlbm = 2;\n\n\tif (padapter->registrypriv.wifi_spec == 1) {\n\t\tawake_intvl = 2;\n\t\trlbm = 2;\n\t}\n\n\tif (psmode > 0) {\n\t\tif (hal_btcoex_IsBtControlLps(padapter) == true) {\n\t\t\tPowerState = hal_btcoex_RpwmVal(padapter);\n\t\t\tbyte5 = hal_btcoex_LpsVal(padapter);\n\n\t\t\tif ((rlbm == 2) && (byte5 & BIT(4))) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tawake_intvl = 2;\n\t\t\t\trlbm = 2;\n\t\t\t}\n\t\t} else {\n\t\t\tPowerState = 0x00; \n\t\t\tbyte5 = 0x40;\n\t\t}\n\t} else {\n\t\tPowerState = 0x0C; \n\t\tbyte5 = 0x40;\n\t}\n\n\tSET_8723B_H2CCMD_PWRMODE_PARM_MODE(u1H2CPwrModeParm, (psmode > 0) ? 1 : 0);\n\tSET_8723B_H2CCMD_PWRMODE_PARM_SMART_PS(u1H2CPwrModeParm, pwrpriv->smart_ps);\n\tSET_8723B_H2CCMD_PWRMODE_PARM_RLBM(u1H2CPwrModeParm, rlbm);\n\tSET_8723B_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(u1H2CPwrModeParm, awake_intvl);\n\tSET_8723B_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(u1H2CPwrModeParm, padapter->registrypriv.uapsd_enable);\n\tSET_8723B_H2CCMD_PWRMODE_PARM_PWR_STATE(u1H2CPwrModeParm, PowerState);\n\tSET_8723B_H2CCMD_PWRMODE_PARM_BYTE5(u1H2CPwrModeParm, byte5);\n\tif (psmode != PS_MODE_ACTIVE) {\n\t\tif (!pmlmeext->adaptive_tsf_done && pmlmeext->bcn_cnt > 0) {\n\t\t\tu8 ratio_20_delay, ratio_80_delay;\n\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tratio_20_delay = 0;\n\t\t\tratio_80_delay = 0;\n\t\t\tpmlmeext->DrvBcnEarly = 0xff;\n\t\t\tpmlmeext->DrvBcnTimeOut = 0xff;\n\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tpmlmeext->bcn_delay_ratio[i] = (pmlmeext->bcn_delay_cnt[i]*100)/pmlmeext->bcn_cnt;\n\n\t\t\t\tratio_20_delay += pmlmeext->bcn_delay_ratio[i];\n\t\t\t\tratio_80_delay += pmlmeext->bcn_delay_ratio[i];\n\n\t\t\t\tif (ratio_20_delay > 20 && pmlmeext->DrvBcnEarly == 0xff)\n\t\t\t\t\tpmlmeext->DrvBcnEarly = i;\n\n\t\t\t\tif (ratio_80_delay > 80 && pmlmeext->DrvBcnTimeOut == 0xff)\n\t\t\t\t\tpmlmeext->DrvBcnTimeOut = i;\n\n\t\t\t\t \n\t\t\t\tpmlmeext->bcn_delay_cnt[i] = 0;\n\t\t\t\tpmlmeext->bcn_delay_ratio[i] = 0;\n\n\t\t\t}\n\n\t\t\tpmlmeext->bcn_cnt = 0;\n\t\t\tpmlmeext->adaptive_tsf_done = true;\n\n\t\t}\n\n \n\n\t}\n\n\thal_btcoex_RecordPwrMode(padapter, u1H2CPwrModeParm, H2C_PWRMODE_LEN);\n\n\tFillH2CCmd8723B(padapter, H2C_8723B_SET_PWR_MODE, H2C_PWRMODE_LEN, u1H2CPwrModeParm);\n}\n\nvoid rtl8723b_set_FwPsTuneParam_cmd(struct adapter *padapter)\n{\n\tu8 u1H2CPsTuneParm[H2C_PSTUNEPARAM_LEN] = {0};\n\tu8 bcn_to_limit = 10;  \n\tu8 dtim_timeout = 5;  \n\tu8 ps_timeout = 20;   \n\tu8 dtim_period = 3;\n\n\tSET_8723B_H2CCMD_PSTUNE_PARM_BCN_TO_LIMIT(u1H2CPsTuneParm, bcn_to_limit);\n\tSET_8723B_H2CCMD_PSTUNE_PARM_DTIM_TIMEOUT(u1H2CPsTuneParm, dtim_timeout);\n\tSET_8723B_H2CCMD_PSTUNE_PARM_PS_TIMEOUT(u1H2CPsTuneParm, ps_timeout);\n\tSET_8723B_H2CCMD_PSTUNE_PARM_ADOPT(u1H2CPsTuneParm, 1);\n\tSET_8723B_H2CCMD_PSTUNE_PARM_DTIM_PERIOD(u1H2CPsTuneParm, dtim_period);\n\n\tFillH2CCmd8723B(padapter, H2C_8723B_PS_TUNING_PARA, H2C_PSTUNEPARAM_LEN, u1H2CPsTuneParm);\n}\n\nvoid rtl8723b_set_FwPwrModeInIPS_cmd(struct adapter *padapter, u8 cmd_param)\n{\n\n\tFillH2CCmd8723B(padapter, H2C_8723B_FWLPS_IN_IPS_, 1, &cmd_param);\n}\n\n \n \nstatic void rtl8723b_set_FwRsvdPagePkt(\n\tstruct adapter *padapter, bool bDLFinished\n)\n{\n\tstruct xmit_frame *pcmdframe;\n\tstruct pkt_attrib *pattrib;\n\tstruct xmit_priv *pxmitpriv;\n\tstruct mlme_ext_priv *pmlmeext;\n\tstruct mlme_ext_info *pmlmeinfo;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tu32 BeaconLength = 0, PSPollLength = 0;\n\tu32 NullDataLength = 0, QosNullLength = 0, BTQosNullLength = 0;\n\tu8 *ReservedPagePacket;\n\tu8 TxDescLen = TXDESC_SIZE, TxDescOffset = TXDESC_OFFSET;\n\tu8 TotalPageNum = 0, CurtPktPageNum = 0, RsvdPageNum = 0;\n\tu16 BufIndex, PageSize = 128;\n\tu32 TotalPacketLen, MaxRsvdPageBufSize = 0;\n\n\tstruct rsvdpage_loc RsvdPageLoc;\n\n\tpxmitpriv = &padapter->xmitpriv;\n\tpmlmeext = &padapter->mlmeextpriv;\n\tpmlmeinfo = &pmlmeext->mlmext_info;\n\n\tRsvdPageNum = BCNQ_PAGE_NUM_8723B + WOWLAN_PAGE_NUM_8723B;\n\tMaxRsvdPageBufSize = RsvdPageNum*PageSize;\n\n\tpcmdframe = rtw_alloc_cmdxmitframe(pxmitpriv);\n\tif (!pcmdframe)\n\t\treturn;\n\n\tReservedPagePacket = pcmdframe->buf_addr;\n\tmemset(&RsvdPageLoc, 0, sizeof(struct rsvdpage_loc));\n\n\t \n\tBufIndex = TxDescOffset;\n\tConstructBeacon(padapter, &ReservedPagePacket[BufIndex], &BeaconLength);\n\n\t \n\t \n\tCurtPktPageNum = (u8)PageNum_128(TxDescLen + BeaconLength);\n\t \n\tif (CurtPktPageNum == 1)\n\t\tCurtPktPageNum += 1;\n\n\tTotalPageNum += CurtPktPageNum;\n\n\tBufIndex += (CurtPktPageNum*PageSize);\n\n\t \n\tRsvdPageLoc.LocPsPoll = TotalPageNum;\n\tConstructPSPoll(padapter, &ReservedPagePacket[BufIndex], &PSPollLength);\n\trtl8723b_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], PSPollLength, true, false, false);\n\n\tCurtPktPageNum = (u8)PageNum_128(TxDescLen + PSPollLength);\n\n\tTotalPageNum += CurtPktPageNum;\n\n\tBufIndex += (CurtPktPageNum*PageSize);\n\n\t \n\tRsvdPageLoc.LocNullData = TotalPageNum;\n\tConstructNullFunctionData(\n\t\tpadapter,\n\t\t&ReservedPagePacket[BufIndex],\n\t\t&NullDataLength,\n\t\tget_my_bssid(&pmlmeinfo->network),\n\t\tfalse, 0, 0, false\n\t);\n\trtl8723b_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], NullDataLength, false, false, false);\n\n\tCurtPktPageNum = (u8)PageNum_128(TxDescLen + NullDataLength);\n\n\tTotalPageNum += CurtPktPageNum;\n\n\tBufIndex += (CurtPktPageNum*PageSize);\n\n\t \n\tRsvdPageLoc.LocQosNull = TotalPageNum;\n\tConstructNullFunctionData(\n\t\tpadapter,\n\t\t&ReservedPagePacket[BufIndex],\n\t\t&QosNullLength,\n\t\tget_my_bssid(&pmlmeinfo->network),\n\t\ttrue, 0, 0, false\n\t);\n\trtl8723b_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], QosNullLength, false, false, false);\n\n\tCurtPktPageNum = (u8)PageNum_128(TxDescLen + QosNullLength);\n\n\tTotalPageNum += CurtPktPageNum;\n\n\tBufIndex += (CurtPktPageNum*PageSize);\n\n\t \n\tRsvdPageLoc.LocBTQosNull = TotalPageNum;\n\tConstructNullFunctionData(\n\t\tpadapter,\n\t\t&ReservedPagePacket[BufIndex],\n\t\t&BTQosNullLength,\n\t\tget_my_bssid(&pmlmeinfo->network),\n\t\ttrue, 0, 0, false\n\t);\n\trtl8723b_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], BTQosNullLength, false, true, false);\n\n\tCurtPktPageNum = (u8)PageNum_128(TxDescLen + BTQosNullLength);\n\n\tTotalPageNum += CurtPktPageNum;\n\n\tBufIndex += (CurtPktPageNum*PageSize);\n\n\tTotalPacketLen = BufIndex + BTQosNullLength;\n\n\tif (TotalPacketLen > MaxRsvdPageBufSize) {\n\t\tgoto error;\n\t} else {\n\t\t \n\t\tpattrib = &pcmdframe->attrib;\n\t\tupdate_mgntframe_attrib(padapter, pattrib);\n\t\tpattrib->qsel = 0x10;\n\t\tpattrib->pktlen = pattrib->last_txcmdsz = TotalPacketLen - TxDescOffset;\n\t\tdump_mgntframe_and_wait(padapter, pcmdframe, 100);\n\t}\n\n\tif (check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\trtl8723b_set_FwRsvdPage_cmd(padapter, &RsvdPageLoc);\n\t\trtl8723b_set_FwAoacRsvdPage_cmd(padapter, &RsvdPageLoc);\n\t} else {\n\t\trtl8723b_set_FwAoacRsvdPage_cmd(padapter, &RsvdPageLoc);\n\t}\n\treturn;\n\nerror:\n\n\trtw_free_xmitframe(pxmitpriv, pcmdframe);\n}\n\nvoid rtl8723b_download_rsvd_page(struct adapter *padapter, u8 mstatus)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tbool bcn_valid = false;\n\tu8 DLBcnCount = 0;\n\tu32 poll = 0;\n\tu8 val8;\n\n\tif (mstatus == RT_MEDIA_CONNECT) {\n\t\tbool bRecover = false;\n\t\tu8 v8;\n\n\t\t \n\t\t \n\t\trtw_write16(padapter, REG_BCN_PSR_RPT, (0xC000|pmlmeinfo->aid));\n\n\t\t \n\t\tv8 = rtw_read8(padapter, REG_CR+1);\n\t\tv8 |= BIT(0);  \n\t\trtw_write8(padapter, REG_CR+1, v8);\n\n\t\t \n\t\t \n\t\t \n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\tval8 &= ~EN_BCN_FUNCTION;\n\t\tval8 |= DIS_TSF_UDT;\n\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\n\t\t \n\t\tif (pHalData->RegFwHwTxQCtrl & BIT(6))\n\t\t\tbRecover = true;\n\n\t\t \n\t\trtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, pHalData->RegFwHwTxQCtrl & ~BIT(6));\n\t\tpHalData->RegFwHwTxQCtrl &= ~BIT(6);\n\n\t\t \n\t\trtw_hal_set_hwreg(padapter, HW_VAR_BCN_VALID, NULL);\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_DL_BCN_SEL, NULL);\n\n\t\tDLBcnCount = 0;\n\t\tpoll = 0;\n\t\tdo {\n\t\t\t \n\t\t\trtl8723b_set_FwRsvdPagePkt(padapter, 0);\n\t\t\tDLBcnCount++;\n\t\t\tdo {\n\t\t\t\tyield();\n\t\t\t\t \n\t\t\t\t \n\t\t\t\trtw_hal_get_hwreg(padapter, HW_VAR_BCN_VALID, (u8 *)(&bcn_valid));\n\t\t\t\tpoll++;\n\t\t\t} while (!bcn_valid && (poll%10) != 0 && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);\n\n\t\t} while (!bcn_valid && DLBcnCount <= 100 && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);\n\n\t\tif (padapter->bSurpriseRemoved || padapter->bDriverStopped) {\n\t\t} else {\n\t\t\tstruct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);\n\t\t\tpwrctl->fw_psmode_iface_id = padapter->iface_id;\n\t\t}\n\n\t\t \n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\tval8 |= EN_BCN_FUNCTION;\n\t\tval8 &= ~DIS_TSF_UDT;\n\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tif (bRecover) {\n\t\t\trtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, pHalData->RegFwHwTxQCtrl | BIT(6));\n\t\t\tpHalData->RegFwHwTxQCtrl |= BIT(6);\n\t\t}\n\n\t\t \n\t\tv8 = rtw_read8(padapter, REG_CR+1);\n\t\tv8 &= ~BIT(0);  \n\t\trtw_write8(padapter, REG_CR+1, v8);\n\t}\n}\n\nvoid rtl8723b_set_FwJoinBssRpt_cmd(struct adapter *padapter, u8 mstatus)\n{\n\tif (mstatus == 1)\n\t\trtl8723b_download_rsvd_page(padapter, RT_MEDIA_CONNECT);\n}\n\n \n \n \n \nvoid rtl8723b_Add_RateATid(\n\tstruct adapter *padapter,\n\tu32 bitmap,\n\tu8 *arg,\n\tu8 rssi_level\n)\n{\n\tstruct hal_com_data\t*pHalData = GET_HAL_DATA(padapter);\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct sta_info *psta;\n\tu8 mac_id = arg[0];\n\tu8 raid = arg[1];\n\tu8 shortGI = arg[2];\n\tu8 bw;\n\tu32 mask = bitmap&0x0FFFFFFF;\n\n\tpsta = pmlmeinfo->FW_sta_info[mac_id].psta;\n\tif (!psta)\n\t\treturn;\n\n\tbw = psta->bw_mode;\n\n\tif (rssi_level != DM_RATR_STA_INIT)\n\t\tmask = ODM_Get_Rate_Bitmap(&pHalData->odmpriv, mac_id, mask, rssi_level);\n\n\trtl8723b_set_FwMacIdConfig_cmd(padapter, mac_id, raid, bw, shortGI, mask);\n}\n\nstatic void ConstructBtNullFunctionData(\n\tstruct adapter *padapter,\n\tu8 *pframe,\n\tu32 *pLength,\n\tu8 *StaAddr,\n\tu8 bQoS,\n\tu8 AC,\n\tu8 bEosp,\n\tu8 bForcePowerSave\n)\n{\n\tstruct ieee80211_hdr *pwlanhdr;\n\t__le16 *fctrl;\n\tu32 pktlen;\n\tu8 bssid[ETH_ALEN];\n\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tif (!StaAddr) {\n\t\tmemcpy(bssid, myid(&padapter->eeprompriv), ETH_ALEN);\n\t\tStaAddr = bssid;\n\t}\n\n\tfctrl = &pwlanhdr->frame_control;\n\t*fctrl = 0;\n\tif (bForcePowerSave)\n\t\tSetPwrMgt(fctrl);\n\n\tSetFrDs(fctrl);\n\tmemcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);\n\tmemcpy(pwlanhdr->addr2, myid(&padapter->eeprompriv), ETH_ALEN);\n\tmemcpy(pwlanhdr->addr3, myid(&padapter->eeprompriv), ETH_ALEN);\n\n\tSetDuration(pwlanhdr, 0);\n\tSetSeqNum(pwlanhdr, 0);\n\n\tif (bQoS) {\n\t\tstruct ieee80211_qos_hdr *pwlanqoshdr;\n\n\t\tSetFrameSubType(pframe, WIFI_QOS_DATA_NULL);\n\n\t\tpwlanqoshdr = (struct ieee80211_qos_hdr *)pframe;\n\t\tSetPriority(&pwlanqoshdr->qos_ctrl, AC);\n\t\tSetEOSP(&pwlanqoshdr->qos_ctrl, bEosp);\n\n\t\tpktlen = sizeof(struct ieee80211_qos_hdr);\n\t} else {\n\t\tSetFrameSubType(pframe, WIFI_DATA_NULL);\n\n\t\tpktlen = sizeof(struct ieee80211_hdr_3addr);\n\t}\n\n\t*pLength = pktlen;\n}\n\nstatic void SetFwRsvdPagePkt_BTCoex(struct adapter *padapter)\n{\n\tstruct xmit_frame *pcmdframe;\n\tstruct pkt_attrib *pattrib;\n\tstruct xmit_priv *pxmitpriv;\n\tu32 BeaconLength = 0;\n\tu32 BTQosNullLength = 0;\n\tu8 *ReservedPagePacket;\n\tu8 TxDescLen, TxDescOffset;\n\tu8 TotalPageNum = 0, CurtPktPageNum = 0, RsvdPageNum = 0;\n\tu16 BufIndex, PageSize;\n\tu32 TotalPacketLen, MaxRsvdPageBufSize = 0;\n\tstruct rsvdpage_loc RsvdPageLoc;\n\n\tpxmitpriv = &padapter->xmitpriv;\n\tTxDescLen = TXDESC_SIZE;\n\tTxDescOffset = TXDESC_OFFSET;\n\tPageSize = PAGE_SIZE_TX_8723B;\n\n\tRsvdPageNum = BCNQ_PAGE_NUM_8723B;\n\tMaxRsvdPageBufSize = RsvdPageNum*PageSize;\n\n\tpcmdframe = rtw_alloc_cmdxmitframe(pxmitpriv);\n\tif (!pcmdframe)\n\t\treturn;\n\n\tReservedPagePacket = pcmdframe->buf_addr;\n\tmemset(&RsvdPageLoc, 0, sizeof(struct rsvdpage_loc));\n\n\t \n\tBufIndex = TxDescOffset;\n\tConstructBeacon(padapter, &ReservedPagePacket[BufIndex], &BeaconLength);\n\n\t \n\t \n\tCurtPktPageNum = (u8)PageNum_128(TxDescLen + BeaconLength);\n\t \n\tif (CurtPktPageNum == 1)\n\t\tCurtPktPageNum += 1;\n\tTotalPageNum += CurtPktPageNum;\n\n\tBufIndex += (CurtPktPageNum*PageSize);\n\n\t \n\tif (BufIndex < (MaxRsvdPageBufSize - PageSize)) {\n\t\tBufIndex = TxDescOffset + (MaxRsvdPageBufSize - PageSize);\n\t\tTotalPageNum = BCNQ_PAGE_NUM_8723B - 1;\n\t}\n\n\t \n\tRsvdPageLoc.LocBTQosNull = TotalPageNum;\n\tConstructBtNullFunctionData(\n\t\tpadapter,\n\t\t&ReservedPagePacket[BufIndex],\n\t\t&BTQosNullLength,\n\t\tNULL,\n\t\ttrue, 0, 0, false\n\t);\n\trtl8723b_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], BTQosNullLength, false, true, false);\n\n\tCurtPktPageNum = (u8)PageNum_128(TxDescLen + BTQosNullLength);\n\n\tTotalPageNum += CurtPktPageNum;\n\n\tTotalPacketLen = BufIndex + BTQosNullLength;\n\tif (TotalPacketLen > MaxRsvdPageBufSize)\n\t\tgoto error;\n\n\t \n\tpattrib = &pcmdframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\tpattrib->qsel = 0x10;\n\tpattrib->pktlen = pattrib->last_txcmdsz = TotalPacketLen - TxDescOffset;\n\tdump_mgntframe_and_wait(padapter, pcmdframe, 100);\n\n\trtl8723b_set_FwRsvdPage_cmd(padapter, &RsvdPageLoc);\n\trtl8723b_set_FwAoacRsvdPage_cmd(padapter, &RsvdPageLoc);\n\n\treturn;\n\nerror:\n\trtw_free_xmitframe(pxmitpriv, pcmdframe);\n}\n\nvoid rtl8723b_download_BTCoex_AP_mode_rsvd_page(struct adapter *padapter)\n{\n\tstruct hal_com_data *pHalData;\n\tstruct mlme_ext_priv *pmlmeext;\n\tstruct mlme_ext_info *pmlmeinfo;\n\tu8 bRecover = false;\n\tu8 bcn_valid = false;\n\tu8 DLBcnCount = 0;\n\tu32 poll = 0;\n\tu8 val8;\n\n\tpHalData = GET_HAL_DATA(padapter);\n\tpmlmeext = &padapter->mlmeextpriv;\n\tpmlmeinfo = &pmlmeext->mlmext_info;\n\n\t \n\t \n\trtw_write16(padapter, REG_BCN_PSR_RPT, (0xC000|pmlmeinfo->aid));\n\n\t \n\tval8 = rtw_read8(padapter, REG_CR+1);\n\tval8 |= BIT(0);  \n\trtw_write8(padapter,  REG_CR+1, val8);\n\n\t \n\t \n\t \n\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\tval8 &= ~EN_BCN_FUNCTION;\n\tval8 |= DIS_TSF_UDT;\n\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\n\t \n\tif (pHalData->RegFwHwTxQCtrl & BIT(6))\n\t\tbRecover = true;\n\n\t \n\tpHalData->RegFwHwTxQCtrl &= ~BIT(6);\n\trtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, pHalData->RegFwHwTxQCtrl);\n\n\t \n\trtw_hal_set_hwreg(padapter, HW_VAR_BCN_VALID, NULL);\n\trtw_hal_set_hwreg(padapter, HW_VAR_DL_BCN_SEL, NULL);\n\n\tDLBcnCount = 0;\n\tpoll = 0;\n\tdo {\n\t\tSetFwRsvdPagePkt_BTCoex(padapter);\n\t\tDLBcnCount++;\n\t\tdo {\n\t\t\tyield();\n \n\t\t\t \n\t\t\trtw_hal_get_hwreg(padapter, HW_VAR_BCN_VALID, &bcn_valid);\n\t\t\tpoll++;\n\t\t} while (!bcn_valid && (poll%10) != 0 && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);\n\t} while (!bcn_valid && (DLBcnCount <= 100) && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);\n\n\tif (bcn_valid) {\n\t\tstruct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);\n\t\tpwrctl->fw_psmode_iface_id = padapter->iface_id;\n\t}\n\n\t \n\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\tval8 |= EN_BCN_FUNCTION;\n\tval8 &= ~DIS_TSF_UDT;\n\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\n\t \n\t \n\t \n\t \n\t \n\tif (bRecover) {\n\t\tpHalData->RegFwHwTxQCtrl |= BIT(6);\n\t\trtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, pHalData->RegFwHwTxQCtrl);\n\t}\n\n\t \n\tval8 = rtw_read8(padapter, REG_CR+1);\n\tval8 &= ~BIT(0);  \n\trtw_write8(padapter, REG_CR+1, val8);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}