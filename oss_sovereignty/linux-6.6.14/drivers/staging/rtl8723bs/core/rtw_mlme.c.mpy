{
  "module_name": "rtw_mlme.c",
  "hash_id": "600985cbdf7728dc557ee03d6b2544a1106e98a722154c55a2526f6c19e28442",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/core/rtw_mlme.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <hal_btcoex.h>\n#include <linux/jiffies.h>\n\nint\trtw_init_mlme_priv(struct adapter *padapter)\n{\n\tint\ti;\n\tu8 *pbuf;\n\tstruct wlan_network\t*pnetwork;\n\tstruct mlme_priv\t*pmlmepriv = &padapter->mlmepriv;\n\tint\tres = _SUCCESS;\n\n\tpmlmepriv->nic_hdl = (u8 *)padapter;\n\n\tpmlmepriv->pscanned = NULL;\n\tpmlmepriv->fw_state = WIFI_STATION_STATE;  \n\t \n\tpmlmepriv->cur_network.network.infrastructure_mode = Ndis802_11AutoUnknown;\n\tpmlmepriv->scan_mode = SCAN_ACTIVE; \n\n\tspin_lock_init(&pmlmepriv->lock);\n\tINIT_LIST_HEAD(&pmlmepriv->free_bss_pool.queue);\n\tspin_lock_init(&pmlmepriv->free_bss_pool.lock);\n\tINIT_LIST_HEAD(&pmlmepriv->scanned_queue.queue);\n\tspin_lock_init(&pmlmepriv->scanned_queue.lock);\n\n\tmemset(&pmlmepriv->assoc_ssid, 0, sizeof(struct ndis_802_11_ssid));\n\n\tpbuf = vzalloc(array_size(MAX_BSS_CNT, sizeof(struct wlan_network)));\n\n\tif (!pbuf) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\tpmlmepriv->free_bss_buf = pbuf;\n\n\tpnetwork = (struct wlan_network *)pbuf;\n\n\tfor (i = 0; i < MAX_BSS_CNT; i++) {\n\t\tINIT_LIST_HEAD(&pnetwork->list);\n\n\t\tlist_add_tail(&pnetwork->list, &pmlmepriv->free_bss_pool.queue);\n\n\t\tpnetwork++;\n\t}\n\n\t \n\n\trtw_clear_scan_deny(padapter);\n\n\t#define RTW_ROAM_SCAN_RESULT_EXP_MS 5000\n\t#define RTW_ROAM_RSSI_DIFF_TH 10\n\t#define RTW_ROAM_SCAN_INTERVAL_MS 10000\n\n\tpmlmepriv->roam_flags = 0\n\t\t| RTW_ROAM_ON_EXPIRED\n\t\t| RTW_ROAM_ON_RESUME\n\t\t;\n\n\tpmlmepriv->roam_scanr_exp_ms = RTW_ROAM_SCAN_RESULT_EXP_MS;\n\tpmlmepriv->roam_rssi_diff_th = RTW_ROAM_RSSI_DIFF_TH;\n\tpmlmepriv->roam_scan_int_ms = RTW_ROAM_SCAN_INTERVAL_MS;\n\n\trtw_init_mlme_timer(padapter);\n\nexit:\n\n\treturn res;\n}\n\nstatic void rtw_free_mlme_ie_data(u8 **ppie, u32 *plen)\n{\n\tif (*ppie) {\n\t\tkfree(*ppie);\n\t\t*plen = 0;\n\t\t*ppie = NULL;\n\t}\n}\n\nvoid rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv)\n{\n\trtw_buf_free(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len);\n\trtw_buf_free(&pmlmepriv->assoc_rsp, &pmlmepriv->assoc_rsp_len);\n\trtw_free_mlme_ie_data(&pmlmepriv->wps_beacon_ie, &pmlmepriv->wps_beacon_ie_len);\n\trtw_free_mlme_ie_data(&pmlmepriv->wps_probe_req_ie, &pmlmepriv->wps_probe_req_ie_len);\n\trtw_free_mlme_ie_data(&pmlmepriv->wps_probe_resp_ie, &pmlmepriv->wps_probe_resp_ie_len);\n\trtw_free_mlme_ie_data(&pmlmepriv->wps_assoc_resp_ie, &pmlmepriv->wps_assoc_resp_ie_len);\n\n\trtw_free_mlme_ie_data(&pmlmepriv->p2p_beacon_ie, &pmlmepriv->p2p_beacon_ie_len);\n\trtw_free_mlme_ie_data(&pmlmepriv->p2p_probe_req_ie, &pmlmepriv->p2p_probe_req_ie_len);\n\trtw_free_mlme_ie_data(&pmlmepriv->p2p_probe_resp_ie, &pmlmepriv->p2p_probe_resp_ie_len);\n\trtw_free_mlme_ie_data(&pmlmepriv->p2p_go_probe_resp_ie, &pmlmepriv->p2p_go_probe_resp_ie_len);\n\trtw_free_mlme_ie_data(&pmlmepriv->p2p_assoc_req_ie, &pmlmepriv->p2p_assoc_req_ie_len);\n}\n\nvoid _rtw_free_mlme_priv(struct mlme_priv *pmlmepriv)\n{\n\tif (pmlmepriv) {\n\t\trtw_free_mlme_priv_ie_data(pmlmepriv);\n\t\tvfree(pmlmepriv->free_bss_buf);\n\t}\n}\n\n \n\nstruct\twlan_network *rtw_alloc_network(struct\tmlme_priv *pmlmepriv)\n{\n\tstruct\twlan_network\t*pnetwork;\n\tstruct __queue *free_queue = &pmlmepriv->free_bss_pool;\n\tstruct list_head *plist = NULL;\n\n\tspin_lock_bh(&free_queue->lock);\n\n\tif (list_empty(&free_queue->queue)) {\n\t\tpnetwork = NULL;\n\t\tgoto exit;\n\t}\n\tplist = get_next(&(free_queue->queue));\n\n\tpnetwork = container_of(plist, struct wlan_network, list);\n\n\tlist_del_init(&pnetwork->list);\n\n\tpnetwork->network_type = 0;\n\tpnetwork->fixed = false;\n\tpnetwork->last_scanned = jiffies;\n\tpnetwork->aid = 0;\n\tpnetwork->join_res = 0;\n\nexit:\n\tspin_unlock_bh(&free_queue->lock);\n\n\treturn pnetwork;\n}\n\nvoid _rtw_free_network(struct\tmlme_priv *pmlmepriv, struct wlan_network *pnetwork, u8 isfreeall)\n{\n\tunsigned int delta_time;\n\tu32 lifetime = SCANQUEUE_LIFETIME;\n \n\tstruct __queue *free_queue = &(pmlmepriv->free_bss_pool);\n\n\tif (!pnetwork)\n\t\treturn;\n\n\tif (pnetwork->fixed)\n\t\treturn;\n\n\tif ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||\n\t\t(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))\n\t\tlifetime = 1;\n\n\tif (!isfreeall) {\n\t\tdelta_time = jiffies_to_msecs(jiffies - pnetwork->last_scanned);\n\t\tif (delta_time < lifetime) \n\t\t\treturn;\n\t}\n\n\tspin_lock_bh(&free_queue->lock);\n\n\tlist_del_init(&(pnetwork->list));\n\n\tlist_add_tail(&(pnetwork->list), &(free_queue->queue));\n\n\tspin_unlock_bh(&free_queue->lock);\n}\n\nvoid _rtw_free_network_nolock(struct\tmlme_priv *pmlmepriv, struct wlan_network *pnetwork)\n{\n\n\tstruct __queue *free_queue = &(pmlmepriv->free_bss_pool);\n\n\tif (!pnetwork)\n\t\treturn;\n\n\tif (pnetwork->fixed)\n\t\treturn;\n\n\t \n\n\tlist_del_init(&(pnetwork->list));\n\n\tlist_add_tail(&(pnetwork->list), get_list_head(free_queue));\n\n\t \n}\n\n \nstruct wlan_network *_rtw_find_network(struct __queue *scanned_queue, u8 *addr)\n{\n\tstruct list_head\t*phead, *plist;\n\tstruct\twlan_network *pnetwork = NULL;\n\n\tif (is_zero_ether_addr(addr)) {\n\t\tpnetwork = NULL;\n\t\tgoto exit;\n\t}\n\n\t \n\n\tphead = get_list_head(scanned_queue);\n\tlist_for_each(plist, phead) {\n\t\tpnetwork = list_entry(plist, struct wlan_network, list);\n\n\t\tif (!memcmp(addr, pnetwork->network.mac_address, ETH_ALEN))\n\t\t\tbreak;\n\t}\n\n\tif (plist == phead)\n\t\tpnetwork = NULL;\n\n\t \n\nexit:\n\treturn pnetwork;\n}\n\nvoid rtw_free_network_queue(struct adapter *padapter, u8 isfreeall)\n{\n\tstruct list_head *phead, *plist, *tmp;\n\tstruct wlan_network *pnetwork;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct __queue *scanned_queue = &pmlmepriv->scanned_queue;\n\n\tspin_lock_bh(&scanned_queue->lock);\n\n\tphead = get_list_head(scanned_queue);\n\tlist_for_each_safe(plist, tmp, phead) {\n\n\t\tpnetwork = list_entry(plist, struct wlan_network, list);\n\n\t\t_rtw_free_network(pmlmepriv, pnetwork, isfreeall);\n\n\t}\n\n\tspin_unlock_bh(&scanned_queue->lock);\n}\n\nsigned int rtw_if_up(struct adapter *padapter)\n{\n\tsigned int res;\n\n\tif (padapter->bDriverStopped || padapter->bSurpriseRemoved ||\n\t\t(check_fwstate(&padapter->mlmepriv, _FW_LINKED) == false))\n\t\tres = false;\n\telse\n\t\tres =  true;\n\n\treturn res;\n}\n\nvoid rtw_generate_random_ibss(u8 *pibss)\n{\n\tunsigned long curtime = jiffies;\n\n\tpibss[0] = 0x02;   \n\tpibss[1] = 0x11;\n\tpibss[2] = 0x87;\n\tpibss[3] = (u8)(curtime & 0xff) ; \n\tpibss[4] = (u8)((curtime>>8) & 0xff) ; \n\tpibss[5] = (u8)((curtime>>16) & 0xff) ; \n}\n\nu8 *rtw_get_capability_from_ie(u8 *ie)\n{\n\treturn ie + 8 + 2;\n}\n\nu16 rtw_get_capability(struct wlan_bssid_ex *bss)\n{\n\t__le16\tval;\n\n\tmemcpy((u8 *)&val, rtw_get_capability_from_ie(bss->ies), 2);\n\n\treturn le16_to_cpu(val);\n}\n\nu8 *rtw_get_beacon_interval_from_ie(u8 *ie)\n{\n\treturn ie + 8;\n}\n\nvoid rtw_free_mlme_priv(struct mlme_priv *pmlmepriv)\n{\n\t_rtw_free_mlme_priv(pmlmepriv);\n}\n\n \n\nvoid rtw_free_network_nolock(struct adapter *padapter, struct wlan_network *pnetwork);\nvoid rtw_free_network_nolock(struct adapter *padapter, struct wlan_network *pnetwork)\n{\n\t_rtw_free_network_nolock(&(padapter->mlmepriv), pnetwork);\n\trtw_cfg80211_unlink_bss(padapter, pnetwork);\n}\n\n \nstruct\twlan_network *rtw_find_network(struct __queue *scanned_queue, u8 *addr)\n{\n\tstruct\twlan_network *pnetwork = _rtw_find_network(scanned_queue, addr);\n\n\treturn pnetwork;\n}\n\nint rtw_is_same_ibss(struct adapter *adapter, struct wlan_network *pnetwork)\n{\n\tint ret = true;\n\tstruct security_priv *psecuritypriv = &adapter->securitypriv;\n\n\tif ((psecuritypriv->dot11PrivacyAlgrthm != _NO_PRIVACY_) &&\n\t\t    (pnetwork->network.privacy == 0))\n\t\tret = false;\n\telse if ((psecuritypriv->dot11PrivacyAlgrthm == _NO_PRIVACY_) &&\n\t\t (pnetwork->network.privacy == 1))\n\t\tret = false;\n\telse\n\t\tret = true;\n\n\treturn ret;\n\n}\n\ninline int is_same_ess(struct wlan_bssid_ex *a, struct wlan_bssid_ex *b)\n{\n\treturn (a->ssid.ssid_length == b->ssid.ssid_length)\n\t\t&&  !memcmp(a->ssid.ssid, b->ssid.ssid, a->ssid.ssid_length);\n}\n\nint is_same_network(struct wlan_bssid_ex *src, struct wlan_bssid_ex *dst, u8 feature)\n{\n\tu16 s_cap, d_cap;\n\t__le16 tmps, tmpd;\n\n\tif (rtw_bug_check(dst, src, &s_cap, &d_cap) == false)\n\t\treturn false;\n\n\tmemcpy((u8 *)&tmps, rtw_get_capability_from_ie(src->ies), 2);\n\tmemcpy((u8 *)&tmpd, rtw_get_capability_from_ie(dst->ies), 2);\n\n\ts_cap = le16_to_cpu(tmps);\n\td_cap = le16_to_cpu(tmpd);\n\n\treturn (src->ssid.ssid_length == dst->ssid.ssid_length) &&\n\t\t \n\t\t\t((!memcmp(src->mac_address, dst->mac_address, ETH_ALEN))) &&\n\t\t\t((!memcmp(src->ssid.ssid, dst->ssid.ssid, src->ssid.ssid_length))) &&\n\t\t\t((s_cap & WLAN_CAPABILITY_IBSS) ==\n\t\t\t(d_cap & WLAN_CAPABILITY_IBSS)) &&\n\t\t\t((s_cap & WLAN_CAPABILITY_ESS) ==\n\t\t\t(d_cap & WLAN_CAPABILITY_ESS));\n\n}\n\nstruct wlan_network *_rtw_find_same_network(struct __queue *scanned_queue, struct wlan_network *network)\n{\n\tstruct list_head *phead, *plist;\n\tstruct wlan_network *found = NULL;\n\n\tphead = get_list_head(scanned_queue);\n\tlist_for_each(plist, phead) {\n\t\tfound = list_entry(plist, struct wlan_network, list);\n\n\t\tif (is_same_network(&network->network, &found->network, 0))\n\t\t\tbreak;\n\t}\n\n\tif (plist == phead)\n\t\tfound = NULL;\n\n\treturn found;\n}\n\nstruct\twlan_network\t*rtw_get_oldest_wlan_network(struct __queue *scanned_queue)\n{\n\tstruct list_head\t*plist, *phead;\n\n\tstruct\twlan_network\t*pwlan = NULL;\n\tstruct\twlan_network\t*oldest = NULL;\n\n\tphead = get_list_head(scanned_queue);\n\n\tlist_for_each(plist, phead) {\n\n\t\tpwlan = list_entry(plist, struct wlan_network, list);\n\n\t\tif (!pwlan->fixed) {\n\t\t\tif (!oldest || time_after(oldest->last_scanned, pwlan->last_scanned))\n\t\t\t\toldest = pwlan;\n\t\t}\n\t}\n\treturn oldest;\n\n}\n\nvoid update_network(struct wlan_bssid_ex *dst, struct wlan_bssid_ex *src,\n\tstruct adapter *padapter, bool update_ie)\n{\n\tlong rssi_ori = dst->rssi;\n\n\tu8 sq_smp = src->phy_info.signal_quality;\n\n\tu8 ss_final;\n\tu8 sq_final;\n\tlong rssi_final;\n\n\t \n\tif (check_fwstate(&padapter->mlmepriv, _FW_LINKED) && is_same_network(&(padapter->mlmepriv.cur_network.network), src, 0)) {\n\t\t \n\t\tss_final = padapter->recvpriv.signal_strength;\n\t\tsq_final = padapter->recvpriv.signal_qual;\n\t\t \n\t\tif (sq_smp != 101)  \n\t\t\trssi_final = (src->rssi+dst->rssi*4)/5;\n\t\telse\n\t\t\trssi_final = rssi_ori;\n\t} else {\n\t\tif (sq_smp != 101) {  \n\t\t\tss_final = ((u32)(src->phy_info.signal_strength)+(u32)(dst->phy_info.signal_strength)*4)/5;\n\t\t\tsq_final = ((u32)(src->phy_info.signal_quality)+(u32)(dst->phy_info.signal_quality)*4)/5;\n\t\t\trssi_final = (src->rssi+dst->rssi*4)/5;\n\t\t} else {\n\t\t\t \n\t\t\tss_final = dst->phy_info.signal_strength;\n\t\t\tsq_final = dst->phy_info.signal_quality;\n\t\t\trssi_final = dst->rssi;\n\t\t}\n\n\t}\n\n\tif (update_ie) {\n\t\tdst->reserved[0] = src->reserved[0];\n\t\tdst->reserved[1] = src->reserved[1];\n\t\tmemcpy((u8 *)dst, (u8 *)src, get_wlan_bssid_ex_sz(src));\n\t}\n\n\tdst->phy_info.signal_strength = ss_final;\n\tdst->phy_info.signal_quality = sq_final;\n\tdst->rssi = rssi_final;\n}\n\nstatic void update_current_network(struct adapter *adapter, struct wlan_bssid_ex *pnetwork)\n{\n\tstruct\tmlme_priv *pmlmepriv = &(adapter->mlmepriv);\n\n\trtw_bug_check(&(pmlmepriv->cur_network.network),\n\t\t&(pmlmepriv->cur_network.network),\n\t\t&(pmlmepriv->cur_network.network),\n\t\t&(pmlmepriv->cur_network.network));\n\n\tif ((check_fwstate(pmlmepriv, _FW_LINKED) == true) && (is_same_network(&(pmlmepriv->cur_network.network), pnetwork, 0))) {\n\t\t \n\t\t{\n\t\t\tupdate_network(&(pmlmepriv->cur_network.network), pnetwork, adapter, true);\n\t\t\trtw_update_protection(adapter, (pmlmepriv->cur_network.network.ies) + sizeof(struct ndis_802_11_fix_ie),\n\t\t\t\t\t\t\t\t\tpmlmepriv->cur_network.network.ie_length);\n\t\t}\n\t}\n}\n\n \nvoid rtw_update_scanned_network(struct adapter *adapter, struct wlan_bssid_ex *target)\n{\n\tstruct list_head\t*plist, *phead;\n\tu32 bssid_ex_sz;\n\tstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\n\tstruct __queue\t*queue\t= &(pmlmepriv->scanned_queue);\n\tstruct wlan_network\t*pnetwork = NULL;\n\tstruct wlan_network\t*oldest = NULL;\n\tint target_find = 0;\n\tu8 feature = 0;\n\n\tspin_lock_bh(&queue->lock);\n\tphead = get_list_head(queue);\n\tlist_for_each(plist, phead) {\n\t\tpnetwork = list_entry(plist, struct wlan_network, list);\n\n\t\trtw_bug_check(pnetwork, pnetwork, pnetwork, pnetwork);\n\n\t\tif (is_same_network(&(pnetwork->network), target, feature)) {\n\t\t\ttarget_find = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rtw_roam_flags(adapter)) {\n\t\t\t \n\t\t}\n\n\t\tif (!oldest || time_after(oldest->last_scanned, pnetwork->last_scanned))\n\t\t\toldest = pnetwork;\n\n\t}\n\n\t \n\t \n\tif (!target_find) {\n\t\tif (list_empty(&pmlmepriv->free_bss_pool.queue)) {\n\t\t\t \n\t\t\t \n\t\t\tpnetwork = oldest;\n\t\t\tif (!pnetwork)\n\t\t\t\tgoto exit;\n\n\t\t\tmemcpy(&(pnetwork->network), target,  get_wlan_bssid_ex_sz(target));\n\t\t\t \n\t\t\tpnetwork->fixed = false;\n\t\t\tpnetwork->last_scanned = jiffies;\n\n\t\t\tpnetwork->network_type = 0;\n\t\t\tpnetwork->aid = 0;\n\t\t\tpnetwork->join_res = 0;\n\n\t\t\t \n\t\t\tif (pnetwork->network.phy_info.signal_quality == 101)\n\t\t\t\tpnetwork->network.phy_info.signal_quality = 0;\n\t\t} else {\n\t\t\t \n\n\t\t\tpnetwork = rtw_alloc_network(pmlmepriv);  \n\n\t\t\tif (!pnetwork)\n\t\t\t\tgoto exit;\n\n\t\t\tbssid_ex_sz = get_wlan_bssid_ex_sz(target);\n\t\t\ttarget->length = bssid_ex_sz;\n\t\t\tmemcpy(&(pnetwork->network), target, bssid_ex_sz);\n\n\t\t\tpnetwork->last_scanned = jiffies;\n\n\t\t\t \n\t\t\tif (pnetwork->network.phy_info.signal_quality == 101)\n\t\t\t\tpnetwork->network.phy_info.signal_quality = 0;\n\n\t\t\tlist_add_tail(&(pnetwork->list), &(queue->queue));\n\n\t\t}\n\t} else {\n\t\t \n\t\tbool update_ie = true;\n\n\t\tpnetwork->last_scanned = jiffies;\n\n\t\t \n\t\tif (pnetwork->network.ie_length > target->ie_length && target->reserved[0] == 1)\n\t\t\tupdate_ie = false;\n\n\t\t \n\t\tif (target->reserved[0] != 2 &&\n\t\t    target->reserved[0] >= pnetwork->network.reserved[0]) {\n\t\t\tupdate_ie = true;\n\t\t} else {\n\t\t\tupdate_ie = false;\n\t\t}\n\n\t\tupdate_network(&(pnetwork->network), target, adapter, update_ie);\n\t}\n\nexit:\n\tspin_unlock_bh(&queue->lock);\n}\n\nvoid rtw_add_network(struct adapter *adapter, struct wlan_bssid_ex *pnetwork);\nvoid rtw_add_network(struct adapter *adapter, struct wlan_bssid_ex *pnetwork)\n{\n\t \n\n\t \n\n\tupdate_current_network(adapter, pnetwork);\n\n\trtw_update_scanned_network(adapter, pnetwork);\n\n\t \n}\n\n \n \n \n \n \n \nint rtw_is_desired_network(struct adapter *adapter, struct wlan_network *pnetwork);\nint rtw_is_desired_network(struct adapter *adapter, struct wlan_network *pnetwork)\n{\n\tstruct security_priv *psecuritypriv = &adapter->securitypriv;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tu32 desired_encmode;\n\tu32 privacy;\n\n\t \n\tuint wps_ielen;\n\n\tint bselected = true;\n\n\tdesired_encmode = psecuritypriv->ndisencryptstatus;\n\tprivacy = pnetwork->network.privacy;\n\n\tif (check_fwstate(pmlmepriv, WIFI_UNDER_WPS)) {\n\t\tif (rtw_get_wps_ie(pnetwork->network.ies+_FIXED_IE_LENGTH_, pnetwork->network.ie_length-_FIXED_IE_LENGTH_, NULL, &wps_ielen))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\n\t}\n\tif (adapter->registrypriv.wifi_spec == 1) {  \n\t\tu8 *p = NULL;\n\t\tuint ie_len = 0;\n\n\t\tif ((desired_encmode == Ndis802_11EncryptionDisabled) && (privacy != 0))\n\t\t\tbselected = false;\n\n\t\tif (psecuritypriv->ndisauthtype == Ndis802_11AuthModeWPA2PSK) {\n\t\t\tp = rtw_get_ie(pnetwork->network.ies + _BEACON_IE_OFFSET_, WLAN_EID_RSN, &ie_len, (pnetwork->network.ie_length - _BEACON_IE_OFFSET_));\n\t\t\tif (p && ie_len > 0)\n\t\t\t\tbselected = true;\n\t\t\telse\n\t\t\t\tbselected = false;\n\t\t}\n\t}\n\n\tif ((desired_encmode != Ndis802_11EncryptionDisabled) && (privacy == 0))\n\t\tbselected = false;\n\n\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) {\n\t\tif (pnetwork->network.infrastructure_mode != pmlmepriv->cur_network.network.infrastructure_mode)\n\t\t\tbselected = false;\n\t}\n\n\treturn bselected;\n}\n\n \nvoid rtw_atimdone_event_callback(struct adapter\t*adapter, u8 *pbuf)\n{\n}\n\nvoid rtw_survey_event_callback(struct adapter\t*adapter, u8 *pbuf)\n{\n\tu32 len;\n\tstruct wlan_bssid_ex *pnetwork;\n\tstruct\tmlme_priv *pmlmepriv = &(adapter->mlmepriv);\n\n\tpnetwork = (struct wlan_bssid_ex *)pbuf;\n\n\tlen = get_wlan_bssid_ex_sz(pnetwork);\n\tif (len > (sizeof(struct wlan_bssid_ex)))\n\t\treturn;\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\n\t \n\tif ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true) {\n\t\tif (!memcmp(&(pmlmepriv->cur_network.network.mac_address), pnetwork->mac_address, ETH_ALEN)) {\n\t\t\tstruct wlan_network *ibss_wlan = NULL;\n\n\t\t\tmemcpy(pmlmepriv->cur_network.network.ies, pnetwork->ies, 8);\n\t\t\tspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\t\tibss_wlan = rtw_find_network(&pmlmepriv->scanned_queue,  pnetwork->mac_address);\n\t\t\tif (ibss_wlan) {\n\t\t\t\tmemcpy(ibss_wlan->network.ies, pnetwork->ies, 8);\n\t\t\t\tspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\t}\n\t}\n\n\t \n\tif ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == false) {\n\t\tif (pnetwork->ssid.ssid[0] == 0)\n\t\t\tpnetwork->ssid.ssid_length = 0;\n\t\trtw_add_network(adapter, pnetwork);\n\t}\n\nexit:\n\n\tspin_unlock_bh(&pmlmepriv->lock);\n}\n\nvoid rtw_surveydone_event_callback(struct adapter\t*adapter, u8 *pbuf)\n{\n\tstruct\tmlme_priv *pmlmepriv = &(adapter->mlmepriv);\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\tif (pmlmepriv->wps_probe_req_ie) {\n\t\tpmlmepriv->wps_probe_req_ie_len = 0;\n\t\tkfree(pmlmepriv->wps_probe_req_ie);\n\t\tpmlmepriv->wps_probe_req_ie = NULL;\n\t}\n\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {\n\t\tspin_unlock_bh(&pmlmepriv->lock);\n\t\tdel_timer_sync(&pmlmepriv->scan_to_timer);\n\t\tspin_lock_bh(&pmlmepriv->lock);\n\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);\n\t}\n\n\trtw_set_signal_stat_timer(&adapter->recvpriv);\n\n\tif (pmlmepriv->to_join) {\n\t\tif ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)) {\n\t\t\tif (check_fwstate(pmlmepriv, _FW_LINKED) == false) {\n\t\t\t\tset_fwstate(pmlmepriv, _FW_UNDER_LINKING);\n\n\t\t\t\tif (rtw_select_and_join_from_scanned_queue(pmlmepriv) == _SUCCESS) {\n\t\t\t\t\t_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);\n\t\t\t\t} else {\n\t\t\t\t\tu8 ret = _SUCCESS;\n\t\t\t\t\tstruct wlan_bssid_ex    *pdev_network = &(adapter->registrypriv.dev_network);\n\t\t\t\t\tu8 *pibss = adapter->registrypriv.dev_network.mac_address;\n\n\t\t\t\t\t \n\t\t\t\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);\n\n\t\t\t\t\tmemcpy(&pdev_network->ssid, &pmlmepriv->assoc_ssid, sizeof(struct ndis_802_11_ssid));\n\n\t\t\t\t\trtw_update_registrypriv_dev_network(adapter);\n\t\t\t\t\trtw_generate_random_ibss(pibss);\n\n\t\t\t\t\tpmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;\n\n\t\t\t\t\tpmlmepriv->to_join = false;\n\n\t\t\t\t\tret = rtw_createbss_cmd(adapter);\n\t\t\t\t\tif (ret != _SUCCESS)\n\t\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint s_ret;\n\n\t\t\tset_fwstate(pmlmepriv, _FW_UNDER_LINKING);\n\t\t\tpmlmepriv->to_join = false;\n\t\t\ts_ret = rtw_select_and_join_from_scanned_queue(pmlmepriv);\n\t\t\tif (s_ret == _SUCCESS) {\n\t\t\t\t_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);\n\t\t\t} else if (s_ret == 2) { \n\t\t\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\n\t\t\t\trtw_indicate_connect(adapter);\n\t\t\t} else {\n\t\t\t\tif (rtw_to_roam(adapter) != 0) {\n\t\t\t\t\tif (rtw_dec_to_roam(adapter) == 0\n\t\t\t\t\t\t|| _SUCCESS != rtw_sitesurvey_cmd(adapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)\n\t\t\t\t\t) {\n\t\t\t\t\t\trtw_set_to_roam(adapter, 0);\n\t\t\t\t\t\trtw_free_assoc_resources(adapter, 1);\n\t\t\t\t\t\trtw_indicate_disconnect(adapter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpmlmepriv->to_join = true;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\trtw_indicate_disconnect(adapter);\n\n\t\t\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (rtw_chk_roam_flags(adapter, RTW_ROAM_ACTIVE)) {\n\t\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)\n\t\t\t\t&& check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\t\t\tif (rtw_select_roaming_candidate(pmlmepriv) == _SUCCESS) {\n\t\t\t\t\treceive_disconnect(adapter, pmlmepriv->cur_network.network.mac_address\n\t\t\t\t\t\t, WLAN_REASON_ACTIVE_ROAM);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nunlock:\n\tspin_unlock_bh(&pmlmepriv->lock);\n\n\trtw_os_xmit_schedule(adapter);\n\n\trtw_cfg80211_surveydone_event_callback(adapter);\n\n\trtw_indicate_scan_done(adapter, false);\n}\n\nvoid rtw_dummy_event_callback(struct adapter *adapter, u8 *pbuf)\n{\n}\n\nvoid rtw_fwdbg_event_callback(struct adapter *adapter, u8 *pbuf)\n{\n}\n\nstatic void free_scanqueue(struct\tmlme_priv *pmlmepriv)\n{\n\tstruct __queue *free_queue = &pmlmepriv->free_bss_pool;\n\tstruct __queue *scan_queue = &pmlmepriv->scanned_queue;\n\tstruct list_head\t*plist, *phead, *ptemp;\n\n\tspin_lock_bh(&scan_queue->lock);\n\tspin_lock_bh(&free_queue->lock);\n\n\tphead = get_list_head(scan_queue);\n\tplist = get_next(phead);\n\n\twhile (plist != phead) {\n\t\tptemp = get_next(plist);\n\t\tlist_del_init(plist);\n\t\tlist_add_tail(plist, &free_queue->queue);\n\t\tplist = ptemp;\n\t}\n\n\tspin_unlock_bh(&free_queue->lock);\n\tspin_unlock_bh(&scan_queue->lock);\n}\n\nstatic void rtw_reset_rx_info(struct debug_priv *pdbgpriv)\n{\n\tpdbgpriv->dbg_rx_ampdu_drop_count = 0;\n\tpdbgpriv->dbg_rx_ampdu_forced_indicate_count = 0;\n\tpdbgpriv->dbg_rx_ampdu_loss_count = 0;\n\tpdbgpriv->dbg_rx_dup_mgt_frame_drop_count = 0;\n\tpdbgpriv->dbg_rx_ampdu_window_shift_cnt = 0;\n}\n\nstatic void find_network(struct adapter *adapter)\n{\n\tstruct wlan_network *pwlan = NULL;\n\tstruct\tmlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tstruct wlan_network *tgt_network = &pmlmepriv->cur_network;\n\n\tpwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.mac_address);\n\tif (pwlan)\n\t\tpwlan->fixed = false;\n\n\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) &&\n\t    (adapter->stapriv.asoc_sta_count == 1))\n\t\trtw_free_network_nolock(adapter, pwlan);\n}\n\n \nvoid rtw_free_assoc_resources(struct adapter *adapter, int lock_scanned_queue)\n{\n\tstruct\tmlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tstruct wlan_network *tgt_network = &pmlmepriv->cur_network;\n\tstruct dvobj_priv *psdpriv = adapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_AP_STATE)) {\n\t\tstruct sta_info *psta;\n\n\t\tpsta = rtw_get_stainfo(&adapter->stapriv, tgt_network->network.mac_address);\n\t\trtw_free_stainfo(adapter,  psta);\n\t}\n\n\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE)) {\n\t\tstruct sta_info *psta;\n\n\t\trtw_free_all_stainfo(adapter);\n\n\t\tpsta = rtw_get_bcmc_stainfo(adapter);\n\t\trtw_free_stainfo(adapter, psta);\n\n\t\trtw_init_bcmc_stainfo(adapter);\n\t}\n\n\tfind_network(adapter);\n\n\tif (lock_scanned_queue)\n\t\tadapter->securitypriv.key_mask = 0;\n\n\trtw_reset_rx_info(pdbgpriv);\n}\n\n \nvoid rtw_indicate_connect(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tpmlmepriv->to_join = false;\n\n\tif (!check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {\n\n\t\tset_fwstate(pmlmepriv, _FW_LINKED);\n\n\t\trtw_os_indicate_connect(padapter);\n\t}\n\n\trtw_set_to_roam(padapter, 0);\n\trtw_set_scan_deny(padapter, 3000);\n\n}\n\n \nvoid rtw_indicate_disconnect(struct adapter *padapter)\n{\n\tstruct\tmlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\t_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING|WIFI_UNDER_WPS);\n\n\tif (rtw_to_roam(padapter) > 0)\n\t\t_clr_fwstate_(pmlmepriv, _FW_LINKED);\n\n\tif (check_fwstate(&padapter->mlmepriv, _FW_LINKED)\n\t\t|| (rtw_to_roam(padapter) <= 0)\n\t) {\n\t\trtw_os_indicate_disconnect(padapter);\n\n\t\t \n\t\trtw_set_ips_deny(padapter, 3000);\n\n\t\t_clr_fwstate_(pmlmepriv, _FW_LINKED);\n\n\t\trtw_clear_scan_deny(padapter);\n\t}\n\n\trtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_DISCONNECT, 1);\n}\n\ninline void rtw_indicate_scan_done(struct adapter *padapter, bool aborted)\n{\n\trtw_os_indicate_scan_done(padapter, aborted);\n\n\tif (is_primary_adapter(padapter) &&\n\t    (!adapter_to_pwrctl(padapter)->bInSuspend) &&\n\t    (!check_fwstate(&padapter->mlmepriv,\n\t\t\t    WIFI_ASOC_STATE|WIFI_UNDER_LINKING))) {\n\t\trtw_set_ips_deny(padapter, 0);\n\t\t_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 1);\n\t}\n}\n\nvoid rtw_scan_abort(struct adapter *adapter)\n{\n\tunsigned long start;\n\tstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);\n\n\tstart = jiffies;\n\tpmlmeext->scan_abort = true;\n\twhile (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)\n\t\t&& jiffies_to_msecs(start) <= 200) {\n\n\t\tif (adapter->bDriverStopped || adapter->bSurpriseRemoved)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t}\n\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))\n\t\trtw_indicate_scan_done(adapter, true);\n\n\tpmlmeext->scan_abort = false;\n}\n\nstatic struct sta_info *rtw_joinbss_update_stainfo(struct adapter *padapter, struct wlan_network *pnetwork)\n{\n\tint i;\n\tstruct sta_info *bmc_sta, *psta = NULL;\n\tstruct recv_reorder_ctrl *preorder_ctrl;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\n\tpsta = rtw_get_stainfo(pstapriv, pnetwork->network.mac_address);\n\tif (!psta)\n\t\tpsta = rtw_alloc_stainfo(pstapriv, pnetwork->network.mac_address);\n\n\tif (psta) {  \n\n\t\tpsta->aid  = pnetwork->join_res;\n\n\t\tupdate_sta_info(padapter, psta);\n\n\t\t \n\t\tpsta->bssratelen = rtw_get_rateset_len(pnetwork->network.supported_rates);\n\t\tmemcpy(psta->bssrateset, pnetwork->network.supported_rates, psta->bssratelen);\n\t\trtw_hal_update_sta_rate_mask(padapter, psta);\n\n\t\tpsta->wireless_mode = pmlmeext->cur_wireless_mode;\n\t\tpsta->raid = networktype_to_raid_ex(padapter, psta);\n\n\t\t \n\t\trtw_hal_set_odm_var(padapter, HAL_ODM_STA_INFO, psta, true);\n\n\t\t \n\t\tif (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) {\n\t\t\tpadapter->securitypriv.binstallGrpkey = false;\n\t\t\tpadapter->securitypriv.busetkipkey = false;\n\t\t\tpadapter->securitypriv.bgrpkey_handshake = false;\n\n\t\t\tpsta->ieee8021x_blocked = true;\n\t\t\tpsta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;\n\n\t\t\tmemset((u8 *)&psta->dot118021x_UncstKey, 0, sizeof(union Keytype));\n\n\t\t\tmemset((u8 *)&psta->dot11tkiprxmickey, 0, sizeof(union Keytype));\n\t\t\tmemset((u8 *)&psta->dot11tkiptxmickey, 0, sizeof(union Keytype));\n\n\t\t\tmemset((u8 *)&psta->dot11txpn, 0, sizeof(union pn48));\n\t\t\tpsta->dot11txpn.val = psta->dot11txpn.val + 1;\n\t\t\tmemset((u8 *)&psta->dot11wtxpn, 0, sizeof(union pn48));\n\t\t\tmemset((u8 *)&psta->dot11rxpn, 0, sizeof(union pn48));\n\t\t}\n\n\t\t \n\t\t \n\t\t \n\t\tif (padapter->securitypriv.wps_ie_len != 0) {\n\t\t\tpsta->ieee8021x_blocked = true;\n\t\t\tpadapter->securitypriv.wps_ie_len = 0;\n\t\t}\n\n\t\t \n\t\t \n\t\t \n\t\tfor (i = 0; i < 16 ; i++) {\n\t\t\t \n\t\t\tpreorder_ctrl = &psta->recvreorder_ctrl[i];\n\t\t\tpreorder_ctrl->enable = false;\n\t\t\tpreorder_ctrl->indicate_seq = 0xffff;\n\t\t\tpreorder_ctrl->wend_b = 0xffff;\n\t\t\tpreorder_ctrl->wsize_b = 64; \n\t\t}\n\n\t\tbmc_sta = rtw_get_bcmc_stainfo(padapter);\n\t\tif (bmc_sta) {\n\t\t\tfor (i = 0; i < 16 ; i++) {\n\t\t\t\t \n\t\t\t\tpreorder_ctrl = &bmc_sta->recvreorder_ctrl[i];\n\t\t\t\tpreorder_ctrl->enable = false;\n\t\t\t\tpreorder_ctrl->indicate_seq = 0xffff;\n\t\t\t\tpreorder_ctrl->wend_b = 0xffff;\n\t\t\t\tpreorder_ctrl->wsize_b = 64; \n\t\t\t}\n\t\t}\n\t}\n\n\treturn psta;\n\n}\n\n \n \nstatic void rtw_joinbss_update_network(struct adapter *padapter, struct wlan_network *ptarget_wlan, struct wlan_network  *pnetwork)\n{\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct wlan_network  *cur_network = &(pmlmepriv->cur_network);\n\n\t \n\tmemcpy(&cur_network->network, &pnetwork->network, pnetwork->network.length);\n\t \n\tcur_network->network.ie_length = ptarget_wlan->network.ie_length;\n\tmemcpy(&cur_network->network.ies[0], &ptarget_wlan->network.ies[0], MAX_IE_SZ);\n\n\tcur_network->aid = pnetwork->join_res;\n\n\trtw_set_signal_stat_timer(&padapter->recvpriv);\n\n\tpadapter->recvpriv.signal_strength = ptarget_wlan->network.phy_info.signal_strength;\n\tpadapter->recvpriv.signal_qual = ptarget_wlan->network.phy_info.signal_quality;\n\t \n\tpadapter->recvpriv.rssi = translate_percentage_to_dbm(ptarget_wlan->network.phy_info.signal_strength);\n\n\trtw_set_signal_stat_timer(&padapter->recvpriv);\n\n\t \n\tswitch (pnetwork->network.infrastructure_mode) {\n\tcase Ndis802_11Infrastructure:\n\n\t\t\tif (pmlmepriv->fw_state&WIFI_UNDER_WPS)\n\t\t\t\tpmlmepriv->fw_state = WIFI_STATION_STATE|WIFI_UNDER_WPS;\n\t\t\telse\n\t\t\t\tpmlmepriv->fw_state = WIFI_STATION_STATE;\n\n\t\t\tbreak;\n\tcase Ndis802_11IBSS:\n\t\t\tpmlmepriv->fw_state = WIFI_ADHOC_STATE;\n\t\t\tbreak;\n\tdefault:\n\t\t\tpmlmepriv->fw_state = WIFI_NULL_STATE;\n\t\t\tbreak;\n\t}\n\n\trtw_update_protection(padapter, (cur_network->network.ies) + sizeof(struct ndis_802_11_fix_ie),\n\t\t\t\t\t\t\t\t\t(cur_network->network.ie_length));\n\n\trtw_update_ht_cap(padapter, cur_network->network.ies, cur_network->network.ie_length, (u8) cur_network->network.configuration.ds_config);\n}\n\n \n \n \n \n \n \n \n \nvoid rtw_joinbss_event_prehandle(struct adapter *adapter, u8 *pbuf)\n{\n\tstatic u8 __maybe_unused retry;\n\tstruct sta_info *ptarget_sta = NULL, *pcur_sta = NULL;\n\tstruct\tsta_priv *pstapriv = &adapter->stapriv;\n\tstruct\tmlme_priv *pmlmepriv = &(adapter->mlmepriv);\n\tstruct wlan_network\t*pnetwork\t= (struct wlan_network *)pbuf;\n\tstruct wlan_network\t*cur_network = &(pmlmepriv->cur_network);\n\tstruct wlan_network\t*pcur_wlan = NULL, *ptarget_wlan = NULL;\n\tunsigned int\t\tthe_same_macaddr = false;\n\n\trtw_get_encrypt_decrypt_from_registrypriv(adapter);\n\n\tthe_same_macaddr = !memcmp(pnetwork->network.mac_address, cur_network->network.mac_address, ETH_ALEN);\n\n\tpnetwork->network.length = get_wlan_bssid_ex_sz(&pnetwork->network);\n\tif (pnetwork->network.length > sizeof(struct wlan_bssid_ex))\n\t\treturn;\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\n\tpmlmepriv->LinkDetectInfo.TrafficTransitionCount = 0;\n\tpmlmepriv->LinkDetectInfo.LowPowerTransitionCount = 0;\n\n\tif (pnetwork->join_res > 0) {\n\t\tspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\tretry = 0;\n\t\tif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) {\n\t\t\t \n\t\t\tif (check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\t\t\tif (the_same_macaddr) {\n\t\t\t\t\tptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.mac_address);\n\t\t\t\t} else {\n\t\t\t\t\tpcur_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.mac_address);\n\t\t\t\t\tif (pcur_wlan)\n\t\t\t\t\t\tpcur_wlan->fixed = false;\n\n\t\t\t\t\tpcur_sta = rtw_get_stainfo(pstapriv, cur_network->network.mac_address);\n\t\t\t\t\tif (pcur_sta)\n\t\t\t\t\t\trtw_free_stainfo(adapter,  pcur_sta);\n\n\t\t\t\t\tptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.mac_address);\n\t\t\t\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {\n\t\t\t\t\t\tif (ptarget_wlan)\n\t\t\t\t\t\t\tptarget_wlan->fixed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tptarget_wlan = _rtw_find_same_network(&pmlmepriv->scanned_queue, pnetwork);\n\t\t\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {\n\t\t\t\t\tif (ptarget_wlan)\n\t\t\t\t\t\tptarget_wlan->fixed = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ptarget_wlan) {\n\t\t\t\trtw_joinbss_update_network(adapter, ptarget_wlan, pnetwork);\n\t\t\t} else {\n\t\t\t\tnetdev_dbg(adapter->pnetdev,\n\t\t\t\t\t   \"Can't find ptarget_wlan when joinbss_event callback\\n\");\n\t\t\t\tspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\t\t\tgoto ignore_joinbss_callback;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {\n\t\t\t\tptarget_sta = rtw_joinbss_update_stainfo(adapter, pnetwork);\n\t\t\t\tif (!ptarget_sta) {\n\t\t\t\t\tspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\t\t\t\tgoto ignore_joinbss_callback;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {\n\t\t\t\tpmlmepriv->cur_network_scanned = ptarget_wlan;\n\t\t\t\trtw_indicate_connect(adapter);\n\t\t\t}\n\n\t\t\tspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\n\n\t\t\tspin_unlock_bh(&pmlmepriv->lock);\n\t\t\t \n\t\t\tdel_timer_sync(&pmlmepriv->assoc_timer);\n\t\t\tspin_lock_bh(&pmlmepriv->lock);\n\t\t} else {\n\t\t\tspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\t}\n\t} else if (pnetwork->join_res == -4) {\n\t\trtw_reset_securitypriv(adapter);\n\t\t_set_timer(&pmlmepriv->assoc_timer, 1);\n\n\t\t \n\n\t\tif ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == true)\n\t\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\n\n\t} else { \n\n\t\t#ifdef REJOIN\n\t\tres = _FAIL;\n\t\tif (retry < 2)\n\t\t\tres = rtw_select_and_join_from_scanned_queue(pmlmepriv);\n\n\t\tif (res == _SUCCESS) {\n\t\t\t \n\t\t\t_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);\n\t\t\tretry++;\n\t\t} else if (res == 2) { \n\t\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\n\t\t\trtw_indicate_connect(adapter);\n\t\t} else {\n\t\t#endif\n\n\t\t\t_set_timer(&pmlmepriv->assoc_timer, 1);\n\t\t\t \n\t\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\n\n\t\t#ifdef REJOIN\n\t\t\tretry = 0;\n\t\t}\n\t\t#endif\n\t}\n\nignore_joinbss_callback:\n\n\tspin_unlock_bh(&pmlmepriv->lock);\n}\n\nvoid rtw_joinbss_event_callback(struct adapter *adapter, u8 *pbuf)\n{\n\tstruct wlan_network\t*pnetwork\t= (struct wlan_network *)pbuf;\n\n\tmlmeext_joinbss_event_callback(adapter, pnetwork->join_res);\n\n\trtw_os_xmit_schedule(adapter);\n}\n\n \nvoid rtw_sta_media_status_rpt(struct adapter *adapter, struct sta_info *psta, u32 mstatus)\n{\n\tu16 media_status_rpt;\n\n\tif (!psta)\n\t\treturn;\n\n\tmedia_status_rpt = (u16)((psta->mac_id<<8)|mstatus);  \n\trtw_hal_set_hwreg(adapter, HW_VAR_H2C_MEDIA_STATUS_RPT, (u8 *)&media_status_rpt);\n}\n\nvoid rtw_stassoc_event_callback(struct adapter *adapter, u8 *pbuf)\n{\n\tstruct sta_info *psta;\n\tstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\n\tstruct stassoc_event\t*pstassoc\t= (struct stassoc_event *)pbuf;\n\tstruct wlan_network\t*cur_network = &(pmlmepriv->cur_network);\n\tstruct wlan_network\t*ptarget_wlan = NULL;\n\n\tif (rtw_access_ctrl(adapter, pstassoc->macaddr) == false)\n\t\treturn;\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\tpsta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);\n\t\tif (psta) {\n\t\t\tu8 *passoc_req = NULL;\n\t\t\tu32 assoc_req_len = 0;\n\n\t\t\trtw_sta_media_status_rpt(adapter, psta, 1);\n\n\t\t\tap_sta_info_defer_update(adapter, psta);\n\n\t\t\t \n\t\t\tspin_lock_bh(&psta->lock);\n\t\t\tif (psta->passoc_req && psta->assoc_req_len > 0) {\n\t\t\t\tpassoc_req = rtw_zmalloc(psta->assoc_req_len);\n\t\t\t\tif (passoc_req) {\n\t\t\t\t\tassoc_req_len = psta->assoc_req_len;\n\t\t\t\t\tmemcpy(passoc_req, psta->passoc_req, assoc_req_len);\n\n\t\t\t\t\tkfree(psta->passoc_req);\n\t\t\t\t\tpsta->passoc_req = NULL;\n\t\t\t\t\tpsta->assoc_req_len = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_bh(&psta->lock);\n\n\t\t\tif (passoc_req && assoc_req_len > 0) {\n\t\t\t\trtw_cfg80211_indicate_sta_assoc(adapter, passoc_req, assoc_req_len);\n\n\t\t\t\tkfree(passoc_req);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tpsta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);\n\tif (psta) {\n\t\t \n\n\t\treturn;  \n\t}\n\n\tpsta = rtw_alloc_stainfo(&adapter->stapriv, pstassoc->macaddr);\n\tif (!psta)\n\t\treturn;\n\n\t \n\tpsta->qos_option = 0;\n\tpsta->mac_id = (uint)pstassoc->cam_id;\n\t \n\n\t \n\trtw_hal_set_odm_var(adapter, HAL_ODM_STA_INFO, psta, true);\n\n\trtw_sta_media_status_rpt(adapter, psta, 1);\n\n\tif (adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)\n\t\tpsta->dot118021XPrivacy = adapter->securitypriv.dot11PrivacyAlgrthm;\n\n\tpsta->ieee8021x_blocked = false;\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\n\tif ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||\n\t\t(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)) {\n\t\tif (adapter->stapriv.asoc_sta_count == 2) {\n\t\t\tspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\t\tptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.mac_address);\n\t\t\tpmlmepriv->cur_network_scanned = ptarget_wlan;\n\t\t\tif (ptarget_wlan)\n\t\t\t\tptarget_wlan->fixed = true;\n\t\t\tspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\t\t \n\t\t\trtw_indicate_connect(adapter);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&pmlmepriv->lock);\n\n\tmlmeext_sta_add_event_callback(adapter, psta);\n}\n\nvoid rtw_stadel_event_callback(struct adapter *adapter, u8 *pbuf)\n{\n\tint mac_id = (-1);\n\tstruct sta_info *psta;\n\tstruct wlan_network *pwlan = NULL;\n\tstruct wlan_bssid_ex    *pdev_network = NULL;\n\tu8 *pibss = NULL;\n\tstruct\tmlme_priv *pmlmepriv = &(adapter->mlmepriv);\n\tstruct\tstadel_event *pstadel\t= (struct stadel_event *)pbuf;\n\tstruct wlan_network *tgt_network = &(pmlmepriv->cur_network);\n\tstruct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tpsta = rtw_get_stainfo(&adapter->stapriv, pstadel->macaddr);\n\tif (psta)\n\t\tmac_id = psta->mac_id;\n\telse\n\t\tmac_id = pstadel->mac_id;\n\n\tif (mac_id >= 0) {\n\t\tu16 media_status;\n\n\t\tmedia_status = (mac_id<<8)|0;  \n\t\t \n\t\trtw_hal_set_hwreg(adapter, HW_VAR_H2C_MEDIA_STATUS_RPT, (u8 *)&media_status);\n\t}\n\n\t \n\tif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)\n\t\treturn;\n\n\tmlmeext_sta_del_event_callback(adapter);\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\n\t\tu16 reason = *((unsigned short *)(pstadel->rsvd));\n\t\tbool roam = false;\n\t\tstruct wlan_network *roam_target = NULL;\n\n\t\tif (adapter->registrypriv.wifi_spec == 1) {\n\t\t\troam = false;\n\t\t} else if (reason == WLAN_REASON_EXPIRATION_CHK && rtw_chk_roam_flags(adapter, RTW_ROAM_ON_EXPIRED)) {\n\t\t\troam = true;\n\t\t} else if (reason == WLAN_REASON_ACTIVE_ROAM && rtw_chk_roam_flags(adapter, RTW_ROAM_ACTIVE)) {\n\t\t\troam = true;\n\t\t\troam_target = pmlmepriv->roam_network;\n\t\t}\n\n\t\tif (roam) {\n\t\t\tif (rtw_to_roam(adapter) > 0)\n\t\t\t\trtw_dec_to_roam(adapter);  \n\t\t\telse if (rtw_to_roam(adapter) == 0)\n\t\t\t\trtw_set_to_roam(adapter, adapter->registrypriv.max_roaming_times);\n\t\t} else {\n\t\t\trtw_set_to_roam(adapter, 0);\n\t\t}\n\n\t\trtw_free_uc_swdec_pending_queue(adapter);\n\n\t\trtw_free_assoc_resources(adapter, 1);\n\t\trtw_indicate_disconnect(adapter);\n\n\t\tspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\t \n\t\tpwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.mac_address);\n\t\tif (pwlan) {\n\t\t\tpwlan->fixed = false;\n\t\t\trtw_free_network_nolock(adapter, pwlan);\n\t\t}\n\t\tspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\n\n\t\t_rtw_roaming(adapter, roam_target);\n\t}\n\n\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) ||\n\t      check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {\n\n\t\trtw_free_stainfo(adapter,  psta);\n\n\t\tif (adapter->stapriv.asoc_sta_count == 1) { \n\t\t\tu8 ret = _SUCCESS;\n\t\t\t \n\t\t\tspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\t\t \n\t\t\t \n\t\t\tpwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.mac_address);\n\t\t\tif (pwlan) {\n\t\t\t\tpwlan->fixed = false;\n\t\t\t\trtw_free_network_nolock(adapter, pwlan);\n\t\t\t}\n\t\t\tspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\t\t \n\t\t\tpdev_network = &(adapter->registrypriv.dev_network);\n\t\t\tpibss = adapter->registrypriv.dev_network.mac_address;\n\n\t\t\tmemcpy(pdev_network, &tgt_network->network, get_wlan_bssid_ex_sz(&tgt_network->network));\n\n\t\t\tmemcpy(&pdev_network->ssid, &pmlmepriv->assoc_ssid, sizeof(struct ndis_802_11_ssid));\n\n\t\t\trtw_update_registrypriv_dev_network(adapter);\n\n\t\t\trtw_generate_random_ibss(pibss);\n\n\t\t\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {\n\t\t\t\tset_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);\n\t\t\t\t_clr_fwstate_(pmlmepriv, WIFI_ADHOC_STATE);\n\t\t\t}\n\n\t\t\tret = rtw_createbss_cmd(adapter);\n\t\t\tif (ret != _SUCCESS)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t}\n\nunlock:\n\tspin_unlock_bh(&pmlmepriv->lock);\n}\n\nvoid rtw_cpwm_event_callback(struct adapter *padapter, u8 *pbuf)\n{\n\tstruct reportpwrstate_parm *preportpwrstate;\n\n\tpreportpwrstate = (struct reportpwrstate_parm *)pbuf;\n\tpreportpwrstate->state |= (u8)(adapter_to_pwrctl(padapter)->cpwm_tog + 0x80);\n\tcpwm_int_hdl(padapter, preportpwrstate);\n}\n\nvoid rtw_wmm_event_callback(struct adapter *padapter, u8 *pbuf)\n{\n\tWMMOnAssocRsp(padapter);\n}\n\n \nvoid _rtw_join_timeout_handler(struct timer_list *t)\n{\n\tstruct adapter *adapter = from_timer(adapter, t,\n\t\t\t\t\t\t  mlmepriv.assoc_timer);\n\tstruct\tmlme_priv *pmlmepriv = &adapter->mlmepriv;\n\n\tif (adapter->bDriverStopped || adapter->bSurpriseRemoved)\n\t\treturn;\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\n\tif (rtw_to_roam(adapter) > 0) {  \n\t\twhile (1) {\n\t\t\trtw_dec_to_roam(adapter);\n\t\t\tif (rtw_to_roam(adapter) != 0) {  \n\t\t\t\tint do_join_r;\n\n\t\t\t\tdo_join_r = rtw_do_join(adapter);\n\t\t\t\tif (do_join_r != _SUCCESS) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\trtw_indicate_disconnect(adapter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\trtw_indicate_disconnect(adapter);\n\t\tfree_scanqueue(pmlmepriv); \n\n\t\t \n\t\trtw_cfg80211_indicate_disconnect(adapter);\n\n\t}\n\n\tspin_unlock_bh(&pmlmepriv->lock);\n}\n\n \nvoid rtw_scan_timeout_handler(struct timer_list *t)\n{\n\tstruct adapter *adapter = from_timer(adapter, t,\n\t\t\t\t\t\t  mlmepriv.scan_to_timer);\n\tstruct\tmlme_priv *pmlmepriv = &adapter->mlmepriv;\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\n\t_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);\n\n\tspin_unlock_bh(&pmlmepriv->lock);\n\n\trtw_indicate_scan_done(adapter, true);\n}\n\nvoid rtw_mlme_reset_auto_scan_int(struct adapter *adapter)\n{\n\tstruct mlme_priv *mlme = &adapter->mlmepriv;\n\tstruct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tif (pmlmeinfo->VHT_enable)  \n\t\tmlme->auto_scan_int_ms = 0;\n\telse if (adapter->registrypriv.wifi_spec && is_client_associated_to_ap(adapter) == true)\n\t\tmlme->auto_scan_int_ms = 60*1000;\n\telse if (rtw_chk_roam_flags(adapter, RTW_ROAM_ACTIVE)) {\n\t\tif (check_fwstate(mlme, WIFI_STATION_STATE) && check_fwstate(mlme, _FW_LINKED))\n\t\t\tmlme->auto_scan_int_ms = mlme->roam_scan_int_ms;\n\t} else\n\t\tmlme->auto_scan_int_ms = 0;  \n}\n\nstatic void rtw_auto_scan_handler(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\trtw_mlme_reset_auto_scan_int(padapter);\n\n\tif (pmlmepriv->auto_scan_int_ms != 0\n\t\t&& jiffies_to_msecs(jiffies - pmlmepriv->scan_start_time) > pmlmepriv->auto_scan_int_ms) {\n\n\t\tif (!padapter->registrypriv.wifi_spec) {\n\t\t\tif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY | _FW_UNDER_LINKING) == true)\n\t\t\t\tgoto exit;\n\n\t\t\tif (pmlmepriv->LinkDetectInfo.bBusyTraffic)\n\t\t\t\tgoto exit;\n\t\t}\n\n\t\trtw_set_802_11_bssid_list_scan(padapter, NULL, 0);\n\t}\n\nexit:\n\treturn;\n}\n\nvoid rtw_dynamic_check_timer_handler(struct adapter *adapter)\n{\n\tif (!adapter)\n\t\treturn;\n\n\tif (!adapter->hw_init_completed)\n\t\treturn;\n\n\tif (adapter->bDriverStopped || adapter->bSurpriseRemoved)\n\t\treturn;\n\n\tif (adapter->net_closed)\n\t\treturn;\n\n\tif ((adapter_to_pwrctl(adapter)->fw_current_in_ps_mode)\n\t\t&& !(hal_btcoex_IsBtControlLps(adapter))\n\t\t) {\n\t\tu8 bEnterPS;\n\n\t\tlinked_status_chk(adapter);\n\n\t\tbEnterPS = traffic_status_watchdog(adapter, 1);\n\t\tif (bEnterPS) {\n\t\t\t \n\t\t\trtw_hal_dm_watchdog_in_lps(adapter);\n\t\t} else {\n\t\t\t \n\t\t}\n\n\t} else {\n\t\tif (is_primary_adapter(adapter))\n\t\t\trtw_dynamic_chk_wk_cmd(adapter);\n\t}\n\n\t \n\trtw_auto_scan_handler(adapter);\n}\n\ninline bool rtw_is_scan_deny(struct adapter *adapter)\n{\n\tstruct mlme_priv *mlmepriv = &adapter->mlmepriv;\n\n\treturn (atomic_read(&mlmepriv->set_scan_deny) != 0) ? true : false;\n}\n\ninline void rtw_clear_scan_deny(struct adapter *adapter)\n{\n\tstruct mlme_priv *mlmepriv = &adapter->mlmepriv;\n\n\tatomic_set(&mlmepriv->set_scan_deny, 0);\n}\n\nvoid rtw_set_scan_deny(struct adapter *adapter, u32 ms)\n{\n\tstruct mlme_priv *mlmepriv = &adapter->mlmepriv;\n\n\tatomic_set(&mlmepriv->set_scan_deny, 1);\n\t_set_timer(&mlmepriv->set_scan_deny_timer, ms);\n}\n\n \nstatic int rtw_check_roaming_candidate(struct mlme_priv *mlme\n\t, struct wlan_network **candidate, struct wlan_network *competitor)\n{\n\tint updated = false;\n\tstruct adapter *adapter = container_of(mlme, struct adapter, mlmepriv);\n\n\tif (is_same_ess(&competitor->network, &mlme->cur_network.network) == false)\n\t\tgoto exit;\n\n\tif (rtw_is_desired_network(adapter, competitor) == false)\n\t\tgoto exit;\n\n\t \n\tif (!is_zero_mac_addr(mlme->roam_tgt_addr)) {\n\t\tif (!memcmp(mlme->roam_tgt_addr, competitor->network.mac_address, ETH_ALEN))\n\t\t\tgoto update;\n\t\telse\n\t\t\tgoto exit;\n\t}\n\tif (jiffies_to_msecs(jiffies - competitor->last_scanned) >= mlme->roam_scanr_exp_ms)\n\t\tgoto exit;\n\n\tif (competitor->network.rssi - mlme->cur_network_scanned->network.rssi < mlme->roam_rssi_diff_th)\n\t\tgoto exit;\n\n\tif (*candidate && (*candidate)->network.rssi >= competitor->network.rssi)\n\t\tgoto exit;\n\nupdate:\n\t*candidate = competitor;\n\tupdated = true;\n\nexit:\n\treturn updated;\n}\n\nint rtw_select_roaming_candidate(struct mlme_priv *mlme)\n{\n\tint ret = _FAIL;\n\tstruct list_head\t*phead;\n\tstruct __queue\t*queue\t= &(mlme->scanned_queue);\n\tstruct\twlan_network\t*pnetwork = NULL;\n\tstruct\twlan_network\t*candidate = NULL;\n\n\tif (!mlme->cur_network_scanned) {\n\t\trtw_warn_on(1);\n\t\treturn ret;\n\t}\n\n\tspin_lock_bh(&(mlme->scanned_queue.lock));\n\tphead = get_list_head(queue);\n\n\tlist_for_each(mlme->pscanned, phead) {\n\n\t\tpnetwork = list_entry(mlme->pscanned, struct wlan_network,\n\t\t\t\t      list);\n\n\t\trtw_check_roaming_candidate(mlme, &candidate, pnetwork);\n\n\t}\n\n\tif (!candidate) {\n\t\tret = _FAIL;\n\t\tgoto exit;\n\t} else {\n\t\tmlme->roam_network = candidate;\n\n\t\tif (!memcmp(candidate->network.mac_address, mlme->roam_tgt_addr, ETH_ALEN))\n\t\t\teth_zero_addr(mlme->roam_tgt_addr);\n\t}\n\n\tret = _SUCCESS;\nexit:\n\tspin_unlock_bh(&(mlme->scanned_queue.lock));\n\n\treturn ret;\n}\n\n \nstatic int rtw_check_join_candidate(struct mlme_priv *mlme\n\t, struct wlan_network **candidate, struct wlan_network *competitor)\n{\n\tint updated = false;\n\tstruct adapter *adapter = container_of(mlme, struct adapter, mlmepriv);\n\n\t \n\tif (mlme->assoc_by_bssid) {\n\t\tif (memcmp(competitor->network.mac_address, mlme->assoc_bssid, ETH_ALEN))\n\t\t\tgoto exit;\n\t}\n\n\t \n\tif (mlme->assoc_ssid.ssid[0] && mlme->assoc_ssid.ssid_length) {\n\t\tif (competitor->network.ssid.ssid_length != mlme->assoc_ssid.ssid_length\n\t\t\t|| memcmp(competitor->network.ssid.ssid, mlme->assoc_ssid.ssid, mlme->assoc_ssid.ssid_length)\n\t\t)\n\t\t\tgoto exit;\n\t}\n\n\tif (rtw_is_desired_network(adapter, competitor)  == false)\n\t\tgoto exit;\n\n\tif (rtw_to_roam(adapter) > 0) {\n\t\tif (jiffies_to_msecs(jiffies - competitor->last_scanned) >= mlme->roam_scanr_exp_ms\n\t\t\t|| is_same_ess(&competitor->network, &mlme->cur_network.network) == false\n\t\t)\n\t\t\tgoto exit;\n\t}\n\n\tif (!*candidate || (*candidate)->network.rssi < competitor->network.rssi) {\n\t\t*candidate = competitor;\n\t\tupdated = true;\n\t}\n\nexit:\n\treturn updated;\n}\n\n \n\nint rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv)\n{\n\tint ret;\n\tstruct list_head\t*phead;\n\tstruct adapter *adapter;\n\tstruct __queue\t*queue\t= &(pmlmepriv->scanned_queue);\n\tstruct\twlan_network\t*pnetwork = NULL;\n\tstruct\twlan_network\t*candidate = NULL;\n\n\tadapter = (struct adapter *)pmlmepriv->nic_hdl;\n\n\tspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\n\n\tif (pmlmepriv->roam_network) {\n\t\tcandidate = pmlmepriv->roam_network;\n\t\tpmlmepriv->roam_network = NULL;\n\t\tgoto candidate_exist;\n\t}\n\n\tphead = get_list_head(queue);\n\tlist_for_each(pmlmepriv->pscanned, phead) {\n\n\t\tpnetwork = list_entry(pmlmepriv->pscanned,\n\t\t\t\t      struct wlan_network, list);\n\n\t\trtw_check_join_candidate(pmlmepriv, &candidate, pnetwork);\n\n\t}\n\n\tif (!candidate) {\n\t\tret = _FAIL;\n\t\tgoto exit;\n\t} else {\n\t\tgoto candidate_exist;\n\t}\n\ncandidate_exist:\n\n\t \n\tif (check_fwstate(pmlmepriv, _FW_LINKED) == true) {\n\t\trtw_disassoc_cmd(adapter, 0, true);\n\t\trtw_indicate_disconnect(adapter);\n\t\trtw_free_assoc_resources(adapter, 0);\n\t}\n\n\tset_fwstate(pmlmepriv, _FW_UNDER_LINKING);\n\tret = rtw_joinbss_cmd(adapter, candidate);\n\nexit:\n\tspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\n\treturn ret;\n}\n\nsigned int rtw_set_auth(struct adapter *adapter, struct security_priv *psecuritypriv)\n{\n\tstruct\tcmd_obj *pcmd;\n\tstruct\tsetauth_parm *psetauthparm;\n\tstruct\tcmd_priv *pcmdpriv = &(adapter->cmdpriv);\n\tsigned int\t\tres = _SUCCESS;\n\n\tpcmd = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!pcmd) {\n\t\tres = _FAIL;   \n\t\tgoto exit;\n\t}\n\n\tpsetauthparm = rtw_zmalloc(sizeof(struct setauth_parm));\n\tif (!psetauthparm) {\n\t\tkfree(pcmd);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpsetauthparm->mode = (unsigned char)psecuritypriv->dot11AuthAlgrthm;\n\n\tpcmd->cmdcode = _SetAuth_CMD_;\n\tpcmd->parmbuf = (unsigned char *)psetauthparm;\n\tpcmd->cmdsz =  (sizeof(struct setauth_parm));\n\tpcmd->rsp = NULL;\n\tpcmd->rspsz = 0;\n\n\tINIT_LIST_HEAD(&pcmd->list);\n\n\tres = rtw_enqueue_cmd(pcmdpriv, pcmd);\n\nexit:\n\treturn res;\n}\n\nsigned int rtw_set_key(struct adapter *adapter, struct security_priv *psecuritypriv, signed int keyid, u8 set_tx, bool enqueue)\n{\n\tu8 keylen;\n\tstruct cmd_obj\t\t*pcmd;\n\tstruct setkey_parm\t*psetkeyparm;\n\tstruct cmd_priv \t*pcmdpriv = &(adapter->cmdpriv);\n\tsigned int\tres = _SUCCESS;\n\n\tpsetkeyparm = rtw_zmalloc(sizeof(struct setkey_parm));\n\tif (!psetkeyparm) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tif (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)\n\t\tpsetkeyparm->algorithm = (unsigned char)psecuritypriv->dot118021XGrpPrivacy;\n\telse\n\t\tpsetkeyparm->algorithm = (u8)psecuritypriv->dot11PrivacyAlgrthm;\n\n\tpsetkeyparm->keyid = (u8)keyid; \n\tpsetkeyparm->set_tx = set_tx;\n\tif (is_wep_enc(psetkeyparm->algorithm))\n\t\tadapter->securitypriv.key_mask |= BIT(psetkeyparm->keyid);\n\n\tswitch (psetkeyparm->algorithm) {\n\n\tcase _WEP40_:\n\t\tkeylen = 5;\n\t\tmemcpy(&(psetkeyparm->key[0]), &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);\n\t\tbreak;\n\tcase _WEP104_:\n\t\tkeylen = 13;\n\t\tmemcpy(&(psetkeyparm->key[0]), &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);\n\t\tbreak;\n\tcase _TKIP_:\n\t\tkeylen = 16;\n\t\tmemcpy(&psetkeyparm->key, &psecuritypriv->dot118021XGrpKey[keyid], keylen);\n\t\tpsetkeyparm->grpkey = 1;\n\t\tbreak;\n\tcase _AES_:\n\t\tkeylen = 16;\n\t\tmemcpy(&psetkeyparm->key, &psecuritypriv->dot118021XGrpKey[keyid], keylen);\n\t\tpsetkeyparm->grpkey = 1;\n\t\tbreak;\n\tdefault:\n\t\tres = _FAIL;\n\t\tkfree(psetkeyparm);\n\t\tgoto exit;\n\t}\n\n\tif (enqueue) {\n\t\tpcmd = rtw_zmalloc(sizeof(struct cmd_obj));\n\t\tif (!pcmd) {\n\t\t\tkfree(psetkeyparm);\n\t\t\tres = _FAIL;   \n\t\t\tgoto exit;\n\t\t}\n\n\t\tpcmd->cmdcode = _SetKey_CMD_;\n\t\tpcmd->parmbuf = (u8 *)psetkeyparm;\n\t\tpcmd->cmdsz =  (sizeof(struct setkey_parm));\n\t\tpcmd->rsp = NULL;\n\t\tpcmd->rspsz = 0;\n\n\t\tINIT_LIST_HEAD(&pcmd->list);\n\n\t\tres = rtw_enqueue_cmd(pcmdpriv, pcmd);\n\t} else {\n\t\tsetkey_hdl(adapter, (u8 *)psetkeyparm);\n\t\tkfree(psetkeyparm);\n\t}\nexit:\n\treturn res;\n}\n\n \nint rtw_restruct_wmm_ie(struct adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, uint initial_out_len)\n{\n\tunsigned\tint ielength = 0;\n\tunsigned int i, j;\n\n\ti = 12;  \n\twhile (i < in_len) {\n\t\tielength = initial_out_len;\n\n\t\tif (in_ie[i] == 0xDD && in_ie[i+2] == 0x00 && in_ie[i+3] == 0x50  && in_ie[i+4] == 0xF2 && in_ie[i+5] == 0x02 && i+5 < in_len) {  \n\t\t\tfor (j = i; j < i + 9; j++) {\n\t\t\t\tout_ie[ielength] = in_ie[j];\n\t\t\t\tielength++;\n\t\t\t}\n\t\t\tout_ie[initial_out_len + 1] = 0x07;\n\t\t\tout_ie[initial_out_len + 6] = 0x00;\n\t\t\tout_ie[initial_out_len + 8] = 0x00;\n\n\t\t\tbreak;\n\t\t}\n\n\t\ti += (in_ie[i+1]+2);  \n\t}\n\n\treturn ielength;\n\n}\n\n \n \n \n \n \n \n \n \n \n \n\nstatic int SecIsInPMKIDList(struct adapter *Adapter, u8 *bssid)\n{\n\tstruct security_priv *p = &Adapter->securitypriv;\n\tint i;\n\n\tfor (i = 0; i < NUM_PMKID_CACHE; i++)\n\t\tif ((p->PMKIDList[i].bUsed) &&\n\t\t\t\t(!memcmp(p->PMKIDList[i].Bssid, bssid, ETH_ALEN)))\n\t\t\treturn i;\n\treturn -1;\n}\n\n \n \n \n \n \n \n \n\nstatic int rtw_append_pmkid(struct adapter *Adapter, int iEntry, u8 *ie, uint ie_len)\n{\n\tstruct security_priv *psecuritypriv = &Adapter->securitypriv;\n\n\tif (ie[13] <= 20) {\n\t\t \n\t\tie[ie_len] = 1;\n\t\tie_len++;\n\t\tie[ie_len] = 0;\t \n\t\tie_len++;\n\t\tmemcpy(&ie[ie_len], &psecuritypriv->PMKIDList[iEntry].PMKID, 16);\n\t\tie_len += 16;\n\t\tie[13] += 18; \n\t}\n\treturn ie_len;\n}\n\nsigned int rtw_restruct_sec_ie(struct adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len)\n{\n\tu8 authmode = 0x0;\n\tuint\tielength;\n\tint iEntry;\n\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &adapter->securitypriv;\n\tuint\tndisauthmode = psecuritypriv->ndisauthtype;\n\n\t \n\tmemcpy(out_ie, in_ie, 12);\n\tielength = 12;\n\tif ((ndisauthmode == Ndis802_11AuthModeWPA) || (ndisauthmode == Ndis802_11AuthModeWPAPSK))\n\t\tauthmode = WLAN_EID_VENDOR_SPECIFIC;\n\tif ((ndisauthmode == Ndis802_11AuthModeWPA2) || (ndisauthmode == Ndis802_11AuthModeWPA2PSK))\n\t\tauthmode = WLAN_EID_RSN;\n\n\tif (check_fwstate(pmlmepriv, WIFI_UNDER_WPS)) {\n\t\tmemcpy(out_ie+ielength, psecuritypriv->wps_ie, psecuritypriv->wps_ie_len);\n\n\t\tielength += psecuritypriv->wps_ie_len;\n\t} else if ((authmode == WLAN_EID_VENDOR_SPECIFIC) || (authmode == WLAN_EID_RSN)) {\n\t\t \n\t\tmemcpy(&out_ie[ielength], &psecuritypriv->supplicant_ie[0], psecuritypriv->supplicant_ie[1]+2);\n\t\t \n\t\tielength += psecuritypriv->supplicant_ie[1]+2;\n\t\trtw_report_sec_ie(adapter, authmode, psecuritypriv->supplicant_ie);\n\t}\n\n\tiEntry = SecIsInPMKIDList(adapter, pmlmepriv->assoc_bssid);\n\tif (iEntry < 0) {\n\t\treturn ielength;\n\t} else {\n\t\tif (authmode == WLAN_EID_RSN)\n\t\t\tielength = rtw_append_pmkid(adapter, iEntry, out_ie, ielength);\n\t}\n\treturn ielength;\n}\n\nvoid rtw_init_registrypriv_dev_network(struct adapter *adapter)\n{\n\tstruct registry_priv *pregistrypriv = &adapter->registrypriv;\n\tstruct eeprom_priv *peepriv = &adapter->eeprompriv;\n\tstruct wlan_bssid_ex    *pdev_network = &pregistrypriv->dev_network;\n\tu8 *myhwaddr = myid(peepriv);\n\n\tmemcpy(pdev_network->mac_address, myhwaddr, ETH_ALEN);\n\n\tmemcpy(&pdev_network->ssid, &pregistrypriv->ssid, sizeof(struct ndis_802_11_ssid));\n\n\tpdev_network->configuration.length = sizeof(struct ndis_802_11_conf);\n\tpdev_network->configuration.beacon_period = 100;\n}\n\nvoid rtw_update_registrypriv_dev_network(struct adapter *adapter)\n{\n\tint sz = 0;\n\tstruct registry_priv *pregistrypriv = &adapter->registrypriv;\n\tstruct wlan_bssid_ex    *pdev_network = &pregistrypriv->dev_network;\n\tstruct\tsecurity_priv *psecuritypriv = &adapter->securitypriv;\n\tstruct\twlan_network\t*cur_network = &adapter->mlmepriv.cur_network;\n\t \n\n\tpdev_network->privacy = (psecuritypriv->dot11PrivacyAlgrthm > 0 ? 1 : 0) ;  \n\n\tpdev_network->rssi = 0;\n\n\tswitch (pregistrypriv->wireless_mode) {\n\tcase WIRELESS_11B:\n\t\tpdev_network->network_type_in_use = (Ndis802_11DS);\n\t\tbreak;\n\tcase WIRELESS_11G:\n\tcase WIRELESS_11BG:\n\tcase WIRELESS_11_24N:\n\tcase WIRELESS_11G_24N:\n\tcase WIRELESS_11BG_24N:\n\t\tpdev_network->network_type_in_use = (Ndis802_11OFDM24);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tpdev_network->configuration.ds_config = (pregistrypriv->channel);\n\n\tif (cur_network->network.infrastructure_mode == Ndis802_11IBSS)\n\t\tpdev_network->configuration.atim_window = (0);\n\n\tpdev_network->infrastructure_mode = (cur_network->network.infrastructure_mode);\n\n\t \n\t \n\n\t \n\tsz = rtw_generate_ie(pregistrypriv);\n\n\tpdev_network->ie_length = sz;\n\n\tpdev_network->length = get_wlan_bssid_ex_sz((struct wlan_bssid_ex  *)pdev_network);\n\n\t \n\t \n}\n\nvoid rtw_get_encrypt_decrypt_from_registrypriv(struct adapter *adapter)\n{\n}\n\n \nvoid rtw_joinbss_reset(struct adapter *padapter)\n{\n\tu8 threshold;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tstruct ht_priv \t*phtpriv = &pmlmepriv->htpriv;\n\n\t \n\n\tpmlmepriv->num_FortyMHzIntolerant = 0;\n\n\tpmlmepriv->num_sta_no_ht = 0;\n\n\tphtpriv->ampdu_enable = false; \n\n\t \n\t \n\tif (phtpriv->ht_option) {\n\t\tif (padapter->registrypriv.wifi_spec == 1)\n\t\t\tthreshold = 1;\n\t\telse\n\t\t\tthreshold = 0;\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_RXDMA_AGG_PG_TH, (u8 *)(&threshold));\n\t} else {\n\t\tthreshold = 1;\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_RXDMA_AGG_PG_TH, (u8 *)(&threshold));\n\t}\n}\n\nvoid rtw_ht_use_default_setting(struct adapter *padapter)\n{\n\tstruct mlme_priv \t*pmlmepriv = &padapter->mlmepriv;\n\tstruct ht_priv \t*phtpriv = &pmlmepriv->htpriv;\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\tbool\t\tbHwLDPCSupport = false, bHwSTBCSupport = false;\n\tbool\t\tbHwSupportBeamformer = false, bHwSupportBeamformee = false;\n\n\tif (pregistrypriv->wifi_spec)\n\t\tphtpriv->bss_coexist = 1;\n\telse\n\t\tphtpriv->bss_coexist = 0;\n\n\tphtpriv->sgi_40m = TEST_FLAG(pregistrypriv->short_gi, BIT1) ? true : false;\n\tphtpriv->sgi_20m = TEST_FLAG(pregistrypriv->short_gi, BIT0) ? true : false;\n\n\t \n\trtw_hal_get_def_var(padapter, HAL_DEF_RX_LDPC, (u8 *)&bHwLDPCSupport);\n\tCLEAR_FLAGS(phtpriv->ldpc_cap);\n\tif (bHwLDPCSupport) {\n\t\tif (TEST_FLAG(pregistrypriv->ldpc_cap, BIT4))\n\t\t\tSET_FLAG(phtpriv->ldpc_cap, LDPC_HT_ENABLE_RX);\n\t}\n\trtw_hal_get_def_var(padapter, HAL_DEF_TX_LDPC, (u8 *)&bHwLDPCSupport);\n\tif (bHwLDPCSupport) {\n\t\tif (TEST_FLAG(pregistrypriv->ldpc_cap, BIT5))\n\t\t\tSET_FLAG(phtpriv->ldpc_cap, LDPC_HT_ENABLE_TX);\n\t}\n\n\t \n\trtw_hal_get_def_var(padapter, HAL_DEF_TX_STBC, (u8 *)&bHwSTBCSupport);\n\tCLEAR_FLAGS(phtpriv->stbc_cap);\n\tif (bHwSTBCSupport) {\n\t\tif (TEST_FLAG(pregistrypriv->stbc_cap, BIT5))\n\t\t\tSET_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_TX);\n\t}\n\trtw_hal_get_def_var(padapter, HAL_DEF_RX_STBC, (u8 *)&bHwSTBCSupport);\n\tif (bHwSTBCSupport) {\n\t\tif (TEST_FLAG(pregistrypriv->stbc_cap, BIT4))\n\t\t\tSET_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_RX);\n\t}\n\n\t \n\trtw_hal_get_def_var(padapter, HAL_DEF_EXPLICIT_BEAMFORMER, (u8 *)&bHwSupportBeamformer);\n\trtw_hal_get_def_var(padapter, HAL_DEF_EXPLICIT_BEAMFORMEE, (u8 *)&bHwSupportBeamformee);\n\tCLEAR_FLAGS(phtpriv->beamform_cap);\n\tif (TEST_FLAG(pregistrypriv->beamform_cap, BIT4) && bHwSupportBeamformer)\n\t\tSET_FLAG(phtpriv->beamform_cap, BEAMFORMING_HT_BEAMFORMER_ENABLE);\n\n\tif (TEST_FLAG(pregistrypriv->beamform_cap, BIT5) && bHwSupportBeamformee)\n\t\tSET_FLAG(phtpriv->beamform_cap, BEAMFORMING_HT_BEAMFORMEE_ENABLE);\n}\n\nvoid rtw_build_wmm_ie_ht(struct adapter *padapter, u8 *out_ie, uint *pout_len)\n{\n\tunsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};\n\tint out_len;\n\n\tif (padapter->mlmepriv.qospriv.qos_option == 0) {\n\t\tout_len = *pout_len;\n\t\trtw_set_ie(out_ie+out_len, WLAN_EID_VENDOR_SPECIFIC,\n\t\t\t   _WMM_IE_Length_, WMM_IE, pout_len);\n\n\t\tpadapter->mlmepriv.qospriv.qos_option = 1;\n\t}\n}\n\n \nunsigned int rtw_restructure_ht_ie(struct adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len, u8 channel)\n{\n\tu32 ielen, out_len;\n\tenum ieee80211_max_ampdu_length_exp max_rx_ampdu_factor;\n\tunsigned char *p;\n\tstruct ieee80211_ht_cap ht_capie;\n\tu8 cbw40_enable = 0, stbc_rx_enable = 0, operation_bw = 0;\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct ht_priv \t*phtpriv = &pmlmepriv->htpriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\n\tphtpriv->ht_option = false;\n\n\tout_len = *pout_len;\n\n\tmemset(&ht_capie, 0, sizeof(struct ieee80211_ht_cap));\n\n\tht_capie.cap_info = cpu_to_le16(IEEE80211_HT_CAP_DSSSCCK40);\n\n\tif (phtpriv->sgi_20m)\n\t\tht_capie.cap_info |= cpu_to_le16(IEEE80211_HT_CAP_SGI_20);\n\n\t \n\tif (!in_ie) {\n\t\t \n\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\n\t\t\toperation_bw = padapter->mlmeextpriv.cur_bwmode;\n\t\t\tif (operation_bw > CHANNEL_WIDTH_40)\n\t\t\t\toperation_bw = CHANNEL_WIDTH_40;\n\t\t} else\n\t\t\t \n\t\t\toperation_bw = CHANNEL_WIDTH_40;\n\t} else {\n\t\tp = rtw_get_ie(in_ie, WLAN_EID_HT_OPERATION, &ielen, in_len);\n\t\tif (p && (ielen == sizeof(struct ieee80211_ht_addt_info))) {\n\t\t\tstruct HT_info_element *pht_info = (struct HT_info_element *)(p+2);\n\n\t\t\tif (pht_info->infos[0] & BIT(2)) {\n\t\t\t\tswitch (pht_info->infos[0] & 0x3) {\n\t\t\t\tcase 1:\n\t\t\t\tcase 3:\n\t\t\t\t\toperation_bw = CHANNEL_WIDTH_40;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\toperation_bw = CHANNEL_WIDTH_20;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toperation_bw = CHANNEL_WIDTH_20;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (channel > 14) {\n\t\tif ((pregistrypriv->bw_mode & 0xf0) > 0)\n\t\t\tcbw40_enable = 1;\n\t} else {\n\t\tif ((pregistrypriv->bw_mode & 0x0f) > 0)\n\t\t\tcbw40_enable = 1;\n\t}\n\n\tif ((cbw40_enable == 1) && (operation_bw == CHANNEL_WIDTH_40)) {\n\t\tht_capie.cap_info |= cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH);\n\t\tif (phtpriv->sgi_40m)\n\t\t\tht_capie.cap_info |= cpu_to_le16(IEEE80211_HT_CAP_SGI_40);\n\t}\n\n\tif (TEST_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_TX))\n\t\tht_capie.cap_info |= cpu_to_le16(IEEE80211_HT_CAP_TX_STBC);\n\n\t \n\tht_capie.cap_info |= cpu_to_le16(IEEE80211_HT_CAP_SM_PS);\n\n\tif (TEST_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_RX)) {\n\t\tif ((channel <= 14 && pregistrypriv->rx_stbc == 0x1) ||\t \n\t\t\t(pregistrypriv->wifi_spec == 1))\n\t\t\tstbc_rx_enable = 1;\n\t}\n\n\t \n\tmemcpy(&ht_capie.mcs, pmlmeext->default_supported_mcs_set, 16);\n\n\t \n\tif (stbc_rx_enable)\n\t\tht_capie.cap_info |= cpu_to_le16(IEEE80211_HT_CAP_RX_STBC_1R); \n\n\tset_mcs_rate_by_mask(ht_capie.mcs.rx_mask, MCS_RATE_1R);\n\n\t{\n\t\tu32 rx_packet_offset, max_recvbuf_sz;\n\n\t\trtw_hal_get_def_var(padapter, HAL_DEF_RX_PACKET_OFFSET, &rx_packet_offset);\n\t\trtw_hal_get_def_var(padapter, HAL_DEF_MAX_RECVBUF_SZ, &max_recvbuf_sz);\n\t}\n\n\tif (padapter->driver_rx_ampdu_factor != 0xFF)\n\t\tmax_rx_ampdu_factor =\n\t\t  (enum ieee80211_max_ampdu_length_exp)padapter->driver_rx_ampdu_factor;\n\telse\n\t\trtw_hal_get_def_var(padapter, HW_VAR_MAX_RX_AMPDU_FACTOR,\n\t\t\t\t    &max_rx_ampdu_factor);\n\n\t \n\tht_capie.ampdu_params_info = (max_rx_ampdu_factor&0x03);\n\n\tif (padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)\n\t\tht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&(0x07<<2));\n\telse\n\t\tht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);\n\n\trtw_set_ie(out_ie+out_len, WLAN_EID_HT_CAPABILITY,\n\t\t   sizeof(struct ieee80211_ht_cap), (unsigned char *)&ht_capie, pout_len);\n\n\tphtpriv->ht_option = true;\n\n\tif (in_ie) {\n\t\tp = rtw_get_ie(in_ie, WLAN_EID_HT_OPERATION, &ielen, in_len);\n\t\tif (p && (ielen == sizeof(struct ieee80211_ht_addt_info))) {\n\t\t\tout_len = *pout_len;\n\t\t\trtw_set_ie(out_ie+out_len, WLAN_EID_HT_OPERATION, ielen, p+2, pout_len);\n\t\t}\n\t}\n\n\treturn phtpriv->ht_option;\n\n}\n\n \nvoid rtw_update_ht_cap(struct adapter *padapter, u8 *pie, uint ie_len, u8 channel)\n{\n\tu8 *p, max_ampdu_sz;\n\tint len;\n\t \n\tstruct ieee80211_ht_cap *pht_capie;\n\t \n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct ht_priv \t*phtpriv = &pmlmepriv->htpriv;\n\t \n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\t \n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tu8 cbw40_enable = 0;\n\n\tif (!phtpriv->ht_option)\n\t\treturn;\n\n\tif ((!pmlmeinfo->HT_info_enable) || (!pmlmeinfo->HT_caps_enable))\n\t\treturn;\n\n\t \n\tif (!(phtpriv->ampdu_enable) && pregistrypriv->ampdu_enable == 1) {\n\t\tphtpriv->ampdu_enable = true;\n\t}\n\n\t \n\tlen = 0;\n\tp = rtw_get_ie(pie+sizeof(struct ndis_802_11_fix_ie), WLAN_EID_HT_CAPABILITY, &len, ie_len-sizeof(struct ndis_802_11_fix_ie));\n\tif (p && len > 0) {\n\t\tpht_capie = (struct ieee80211_ht_cap *)(p+2);\n\t\tmax_ampdu_sz = (pht_capie->ampdu_params_info & IEEE80211_HT_CAP_AMPDU_FACTOR);\n\t\tmax_ampdu_sz = 1 << (max_ampdu_sz+3);  \n\n\t\tphtpriv->rx_ampdu_maxlen = max_ampdu_sz;\n\n\t}\n\n\tlen = 0;\n\tp = rtw_get_ie(pie+sizeof(struct ndis_802_11_fix_ie), WLAN_EID_HT_OPERATION, &len, ie_len-sizeof(struct ndis_802_11_fix_ie));\n\tif (p && len > 0) {\n\t\t \n\t}\n\n\tif (channel > 14) {\n\t\tif ((pregistrypriv->bw_mode & 0xf0) > 0)\n\t\t\tcbw40_enable = 1;\n\t} else {\n\t\tif ((pregistrypriv->bw_mode & 0x0f) > 0)\n\t\t\tcbw40_enable = 1;\n\t}\n\n\t \n\tif ((cbw40_enable) &&\n\t    (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) &\n\t      BIT(1)) && (pmlmeinfo->HT_info.infos[0] & BIT(2))) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < 16; i++)\n\t\t\tpmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= pmlmeext->default_supported_mcs_set[i];\n\n\t\t \n\t\tset_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_1R);\n\n\t\t \n\t\t \n\t\tswitch ((pmlmeinfo->HT_info.infos[0] & 0x3)) {\n\t\tcase EXTCHNL_OFFSET_UPPER:\n\t\t\tpmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;\n\t\t\tbreak;\n\n\t\tcase EXTCHNL_OFFSET_LOWER:\n\t\t\tpmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\t \n\t \n\tpmlmeinfo->SM_PS =\n\t\t(le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) &\n\t\t 0x0C) >> 2;\n\n\t \n\t \n\t \n\tpmlmeinfo->HT_protection = pmlmeinfo->HT_info.infos[1] & 0x3;\n}\n\nvoid rtw_issue_addbareq_cmd(struct adapter *padapter, struct xmit_frame *pxmitframe)\n{\n\tu8 issued;\n\tint priority;\n\tstruct sta_info *psta;\n\tstruct ht_priv *phtpriv;\n\tstruct pkt_attrib *pattrib = &pxmitframe->attrib;\n\ts32 bmcst = is_multicast_ether_addr(pattrib->ra);\n\n\t \n\tif (bmcst || (padapter->mlmepriv.LinkDetectInfo.NumTxOkInPeriod < 100))\n\t\treturn;\n\n\tpriority = pattrib->priority;\n\n\tpsta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);\n\tif (pattrib->psta != psta)\n\t\treturn;\n\n\tif (!psta)\n\t\treturn;\n\n\tif (!(psta->state & _FW_LINKED))\n\t\treturn;\n\n\tphtpriv = &psta->htpriv;\n\n\tif (phtpriv->ht_option && phtpriv->ampdu_enable) {\n\t\tissued = (phtpriv->agg_enable_bitmap>>priority)&0x1;\n\t\tissued |= (phtpriv->candidate_tid_bitmap>>priority)&0x1;\n\n\t\tif (issued == 0) {\n\t\t\tpsta->htpriv.candidate_tid_bitmap |= BIT((u8)priority);\n\t\t\trtw_addbareq_cmd(padapter, (u8) priority, pattrib->ra);\n\t\t}\n\t}\n\n}\n\nvoid rtw_append_exented_cap(struct adapter *padapter, u8 *out_ie, uint *pout_len)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct ht_priv \t*phtpriv = &pmlmepriv->htpriv;\n\tu8 cap_content[8] = {0};\n\n\tif (phtpriv->bss_coexist)\n\t\tSET_EXT_CAPABILITY_ELE_BSS_COEXIST(cap_content, 1);\n\n\trtw_set_ie(out_ie + *pout_len, WLAN_EID_EXT_CAPABILITY, 8, cap_content, pout_len);\n}\n\ninline void rtw_set_to_roam(struct adapter *adapter, u8 to_roam)\n{\n\tif (to_roam == 0)\n\t\tadapter->mlmepriv.to_join = false;\n\tadapter->mlmepriv.to_roam = to_roam;\n}\n\ninline u8 rtw_dec_to_roam(struct adapter *adapter)\n{\n\tadapter->mlmepriv.to_roam--;\n\treturn adapter->mlmepriv.to_roam;\n}\n\ninline u8 rtw_to_roam(struct adapter *adapter)\n{\n\treturn adapter->mlmepriv.to_roam;\n}\n\nvoid rtw_roaming(struct adapter *padapter, struct wlan_network *tgt_network)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\t_rtw_roaming(padapter, tgt_network);\n\tspin_unlock_bh(&pmlmepriv->lock);\n}\nvoid _rtw_roaming(struct adapter *padapter, struct wlan_network *tgt_network)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct wlan_network *cur_network = &pmlmepriv->cur_network;\n\n\tif (rtw_to_roam(padapter) > 0) {\n\t\tmemcpy(&pmlmepriv->assoc_ssid, &cur_network->network.ssid, sizeof(struct ndis_802_11_ssid));\n\n\t\tpmlmepriv->assoc_by_bssid = false;\n\n\t\twhile (rtw_do_join(padapter) != _SUCCESS) {\n\t\t\trtw_dec_to_roam(padapter);\n\t\t\tif (rtw_to_roam(padapter) <= 0) {\n\t\t\t\trtw_indicate_disconnect(padapter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned int rtw_linked_check(struct adapter *padapter)\n{\n\tif ((check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == true) ||\n\t\t\t(check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)) {\n\t\tif (padapter->stapriv.asoc_sta_count > 2)\n\t\t\treturn true;\n\t} else {\t \n\t\tif (check_fwstate(&padapter->mlmepriv, _FW_LINKED) == true)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}