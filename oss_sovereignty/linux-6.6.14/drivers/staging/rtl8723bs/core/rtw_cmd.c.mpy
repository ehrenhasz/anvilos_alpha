{
  "module_name": "rtw_cmd.c",
  "hash_id": "0fd5ff6bdb63468e8b81a583418d0f6606fb192a177bf892d036140c196772d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/core/rtw_cmd.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <hal_btcoex.h>\n#include <linux/jiffies.h>\n\nstatic struct _cmd_callback rtw_cmd_callback[] = {\n\t{GEN_CMD_CODE(_Read_MACREG), NULL},  \n\t{GEN_CMD_CODE(_Write_MACREG), NULL},\n\t{GEN_CMD_CODE(_Read_BBREG), &rtw_getbbrfreg_cmdrsp_callback},\n\t{GEN_CMD_CODE(_Write_BBREG), NULL},\n\t{GEN_CMD_CODE(_Read_RFREG), &rtw_getbbrfreg_cmdrsp_callback},\n\t{GEN_CMD_CODE(_Write_RFREG), NULL},  \n\t{GEN_CMD_CODE(_Read_EEPROM), NULL},\n\t{GEN_CMD_CODE(_Write_EEPROM), NULL},\n\t{GEN_CMD_CODE(_Read_EFUSE), NULL},\n\t{GEN_CMD_CODE(_Write_EFUSE), NULL},\n\n\t{GEN_CMD_CODE(_Read_CAM),\tNULL},\t \n\t{GEN_CMD_CODE(_Write_CAM),\t NULL},\n\t{GEN_CMD_CODE(_setBCNITV), NULL},\n\t{GEN_CMD_CODE(_setMBIDCFG), NULL},\n\t{GEN_CMD_CODE(_JoinBss), &rtw_joinbss_cmd_callback},   \n\t{GEN_CMD_CODE(_DisConnect), &rtw_disassoc_cmd_callback},  \n\t{GEN_CMD_CODE(_CreateBss), &rtw_createbss_cmd_callback},\n\t{GEN_CMD_CODE(_SetOpMode), NULL},\n\t{GEN_CMD_CODE(_SiteSurvey), &rtw_survey_cmd_callback},  \n\t{GEN_CMD_CODE(_SetAuth), NULL},\n\n\t{GEN_CMD_CODE(_SetKey), NULL},\t \n\t{GEN_CMD_CODE(_SetStaKey), &rtw_setstaKey_cmdrsp_callback},\n\t{GEN_CMD_CODE(_SetAssocSta), &rtw_setassocsta_cmdrsp_callback},\n\t{GEN_CMD_CODE(_DelAssocSta), NULL},\n\t{GEN_CMD_CODE(_SetStaPwrState), NULL},\n\t{GEN_CMD_CODE(_SetBasicRate), NULL},  \n\t{GEN_CMD_CODE(_GetBasicRate), NULL},\n\t{GEN_CMD_CODE(_SetDataRate), NULL},\n\t{GEN_CMD_CODE(_GetDataRate), NULL},\n\t{GEN_CMD_CODE(_SetPhyInfo), NULL},\n\n\t{GEN_CMD_CODE(_GetPhyInfo), NULL},  \n\t{GEN_CMD_CODE(_SetPhy), NULL},\n\t{GEN_CMD_CODE(_GetPhy), NULL},\n\t{GEN_CMD_CODE(_readRssi), NULL},\n\t{GEN_CMD_CODE(_readGain), NULL},\n\t{GEN_CMD_CODE(_SetAtim), NULL},  \n\t{GEN_CMD_CODE(_SetPwrMode), NULL},\n\t{GEN_CMD_CODE(_JoinbssRpt), NULL},\n\t{GEN_CMD_CODE(_SetRaTable), NULL},\n\t{GEN_CMD_CODE(_GetRaTable), NULL},\n\n\t{GEN_CMD_CODE(_GetCCXReport), NULL},  \n\t{GEN_CMD_CODE(_GetDTMReport),\tNULL},\n\t{GEN_CMD_CODE(_GetTXRateStatistics), NULL},\n\t{GEN_CMD_CODE(_SetUsbSuspend), NULL},\n\t{GEN_CMD_CODE(_SetH2cLbk), NULL},\n\t{GEN_CMD_CODE(_AddBAReq), NULL},  \n\t{GEN_CMD_CODE(_SetChannel), NULL},\t\t \n\t{GEN_CMD_CODE(_SetTxPower), NULL},\n\t{GEN_CMD_CODE(_SwitchAntenna), NULL},\n\t{GEN_CMD_CODE(_SetCrystalCap), NULL},\n\t{GEN_CMD_CODE(_SetSingleCarrierTx), NULL},\t \n\n\t{GEN_CMD_CODE(_SetSingleToneTx), NULL},  \n\t{GEN_CMD_CODE(_SetCarrierSuppressionTx), NULL},\n\t{GEN_CMD_CODE(_SetContinuousTx), NULL},\n\t{GEN_CMD_CODE(_SwitchBandwidth), NULL},\t\t \n\t{GEN_CMD_CODE(_TX_Beacon), NULL}, \n\n\t{GEN_CMD_CODE(_Set_MLME_EVT), NULL}, \n\t{GEN_CMD_CODE(_Set_Drv_Extra), NULL}, \n\t{GEN_CMD_CODE(_Set_H2C_MSG), NULL}, \n\t{GEN_CMD_CODE(_SetChannelPlan), NULL}, \n\n\t{GEN_CMD_CODE(_SetChannelSwitch), NULL}, \n\t{GEN_CMD_CODE(_TDLS), NULL}, \n\t{GEN_CMD_CODE(_ChkBMCSleepq), NULL},  \n\n\t{GEN_CMD_CODE(_RunInThreadCMD), NULL}, \n};\n\nstatic struct cmd_hdl wlancmds[] = {\n\tGEN_DRV_CMD_HANDLER(0, NULL)  \n\tGEN_DRV_CMD_HANDLER(0, NULL)\n\tGEN_DRV_CMD_HANDLER(0, NULL)\n\tGEN_DRV_CMD_HANDLER(0, NULL)\n\tGEN_DRV_CMD_HANDLER(0, NULL)\n\tGEN_DRV_CMD_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)  \n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct joinbss_parm), join_cmd_hdl)  \n\tGEN_MLME_EXT_HANDLER(sizeof(struct disconnect_parm), disconnect_hdl)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct createbss_parm), createbss_hdl)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct setopmode_parm), setopmode_hdl)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct sitesurvey_parm), sitesurvey_cmd_hdl)  \n\tGEN_MLME_EXT_HANDLER(sizeof(struct setauth_parm), setauth_hdl)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct setkey_parm), setkey_hdl)  \n\tGEN_MLME_EXT_HANDLER(sizeof(struct set_stakey_parm), set_stakey_hdl)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct set_assocsta_parm), NULL)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct del_assocsta_parm), NULL)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct setstapwrstate_parm), NULL)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct setbasicrate_parm), NULL)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct getbasicrate_parm), NULL)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct setdatarate_parm), NULL)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct getdatarate_parm), NULL)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct setphyinfo_parm), NULL)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct getphyinfo_parm), NULL)   \n\tGEN_MLME_EXT_HANDLER(sizeof(struct setphy_parm), NULL)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct getphy_parm), NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\t \n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct addBaReq_parm), add_ba_hdl)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct set_ch_parm), set_ch_hdl)  \n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)  \n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(0, NULL)\n\tGEN_MLME_EXT_HANDLER(sizeof(struct Tx_Beacon_param), tx_beacon_hdl)  \n\n\tGEN_MLME_EXT_HANDLER(0, mlme_evt_hdl)  \n\tGEN_MLME_EXT_HANDLER(0, rtw_drvextra_cmd_hdl)  \n\n\tGEN_MLME_EXT_HANDLER(0, h2c_msg_hdl)  \n\tGEN_MLME_EXT_HANDLER(sizeof(struct SetChannelPlan_param), set_chplan_hdl)  \n\n\tGEN_MLME_EXT_HANDLER(sizeof(struct SetChannelSwitch_param), set_csa_hdl)  \n\tGEN_MLME_EXT_HANDLER(sizeof(struct TDLSoption_param), tdls_hdl)  \n\tGEN_MLME_EXT_HANDLER(0, chk_bmc_sleepq_hdl)  \n\tGEN_MLME_EXT_HANDLER(sizeof(struct RunInThread_param), run_in_thread_hdl)  \n};\n\n \n\nint rtw_init_cmd_priv(struct\tcmd_priv *pcmdpriv)\n{\n\tinit_completion(&pcmdpriv->cmd_queue_comp);\n\tinit_completion(&pcmdpriv->terminate_cmdthread_comp);\n\n\tINIT_LIST_HEAD(&pcmdpriv->cmd_queue.queue);\n\tspin_lock_init(&pcmdpriv->cmd_queue.lock);\n\n\t \n\n\tpcmdpriv->cmd_seq = 1;\n\n\tpcmdpriv->cmd_allocated_buf = rtw_zmalloc(MAX_CMDSZ + CMDBUFF_ALIGN_SZ);\n\n\tif (!pcmdpriv->cmd_allocated_buf)\n\t\treturn -ENOMEM;\n\n\tpcmdpriv->cmd_buf = pcmdpriv->cmd_allocated_buf  +  CMDBUFF_ALIGN_SZ - ((SIZE_PTR)(pcmdpriv->cmd_allocated_buf) & (CMDBUFF_ALIGN_SZ-1));\n\n\tpcmdpriv->rsp_allocated_buf = rtw_zmalloc(MAX_RSPSZ + 4);\n\n\tif (!pcmdpriv->rsp_allocated_buf) {\n\t\tkfree(pcmdpriv->cmd_allocated_buf);\n\t\treturn -ENOMEM;\n\t}\n\n\tpcmdpriv->rsp_buf = pcmdpriv->rsp_allocated_buf  +  4 - ((SIZE_PTR)(pcmdpriv->rsp_allocated_buf) & 3);\n\n\tpcmdpriv->cmd_issued_cnt = 0;\n\tpcmdpriv->cmd_done_cnt = 0;\n\tpcmdpriv->rsp_cnt = 0;\n\n\tmutex_init(&pcmdpriv->sctx_mutex);\n\n\treturn 0;\n}\n\nstatic void c2h_wk_callback(struct work_struct *work);\nint rtw_init_evt_priv(struct evt_priv *pevtpriv)\n{\n\t \n\tatomic_set(&pevtpriv->event_seq, 0);\n\tpevtpriv->evt_done_cnt = 0;\n\n\t_init_workitem(&pevtpriv->c2h_wk, c2h_wk_callback, NULL);\n\tpevtpriv->c2h_wk_alive = false;\n\tpevtpriv->c2h_queue = rtw_cbuf_alloc(C2H_QUEUE_MAX_LEN+1);\n\tif (!pevtpriv->c2h_queue)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid _rtw_free_evt_priv(struct\tevt_priv *pevtpriv)\n{\n\t_cancel_workitem_sync(&pevtpriv->c2h_wk);\n\twhile (pevtpriv->c2h_wk_alive)\n\t\tmsleep(10);\n\n\twhile (!rtw_cbuf_empty(pevtpriv->c2h_queue)) {\n\t\tvoid *c2h = rtw_cbuf_pop(pevtpriv->c2h_queue);\n\n\t\tif (c2h && c2h != (void *)pevtpriv)\n\t\t\tkfree(c2h);\n\t}\n\tkfree(pevtpriv->c2h_queue);\n}\n\nvoid _rtw_free_cmd_priv(struct\tcmd_priv *pcmdpriv)\n{\n\tif (pcmdpriv) {\n\t\tkfree(pcmdpriv->cmd_allocated_buf);\n\n\t\tkfree(pcmdpriv->rsp_allocated_buf);\n\n\t\tmutex_destroy(&pcmdpriv->sctx_mutex);\n\t}\n}\n\n \n\nint _rtw_enqueue_cmd(struct __queue *queue, struct cmd_obj *obj)\n{\n\tunsigned long irqL;\n\n\tif (!obj)\n\t\tgoto exit;\n\n\t \n\tspin_lock_irqsave(&queue->lock, irqL);\n\n\tlist_add_tail(&obj->list, &queue->queue);\n\n\t \n\tspin_unlock_irqrestore(&queue->lock, irqL);\n\nexit:\n\treturn _SUCCESS;\n}\n\nstruct\tcmd_obj\t*_rtw_dequeue_cmd(struct __queue *queue)\n{\n\tunsigned long irqL;\n\tstruct cmd_obj *obj;\n\n\t \n\tspin_lock_irqsave(&queue->lock, irqL);\n\tif (list_empty(&queue->queue))\n\t\tobj = NULL;\n\telse {\n\t\tobj = container_of(get_next(&queue->queue), struct cmd_obj, list);\n\t\tlist_del_init(&obj->list);\n\t}\n\n\t \n\tspin_unlock_irqrestore(&queue->lock, irqL);\n\n\treturn obj;\n}\n\nvoid rtw_free_evt_priv(struct\tevt_priv *pevtpriv)\n{\n\t_rtw_free_evt_priv(pevtpriv);\n}\n\nvoid rtw_free_cmd_priv(struct\tcmd_priv *pcmdpriv)\n{\n\t_rtw_free_cmd_priv(pcmdpriv);\n}\n\nint rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj);\nint rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)\n{\n\tu8 bAllow = false;  \n\n\tif (cmd_obj->cmdcode == GEN_CMD_CODE(_SetChannelPlan))\n\t\tbAllow = true;\n\n\tif ((!pcmdpriv->padapter->hw_init_completed && !bAllow) ||\n\t\t!atomic_read(&pcmdpriv->cmdthd_running))\t \n\t\treturn _FAIL;\n\n\treturn _SUCCESS;\n}\n\nint rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)\n{\n\tint res = _FAIL;\n\tstruct adapter *padapter = pcmdpriv->padapter;\n\n\tif (!cmd_obj)\n\t\tgoto exit;\n\n\tcmd_obj->padapter = padapter;\n\n\tres = rtw_cmd_filter(pcmdpriv, cmd_obj);\n\tif (res == _FAIL) {\n\t\trtw_free_cmd_obj(cmd_obj);\n\t\tgoto exit;\n\t}\n\n\tres = _rtw_enqueue_cmd(&pcmdpriv->cmd_queue, cmd_obj);\n\n\tif (res == _SUCCESS)\n\t\tcomplete(&pcmdpriv->cmd_queue_comp);\n\nexit:\n\treturn res;\n}\n\nstruct\tcmd_obj\t*rtw_dequeue_cmd(struct cmd_priv *pcmdpriv)\n{\n\treturn _rtw_dequeue_cmd(&pcmdpriv->cmd_queue);\n}\n\nvoid rtw_free_cmd_obj(struct cmd_obj *pcmd)\n{\n\tif ((pcmd->cmdcode != _JoinBss_CMD_) &&\n\t    (pcmd->cmdcode != _CreateBss_CMD_)) {\n\t\t \n\t\tkfree(pcmd->parmbuf);\n\t}\n\n\tif (pcmd->rsp) {\n\t\tif (pcmd->rspsz != 0) {\n\t\t\t \n\t\t\tkfree(pcmd->rsp);\n\t\t}\n\t}\n\n\t \n\tkfree(pcmd);\n}\n\nvoid rtw_stop_cmd_thread(struct adapter *adapter)\n{\n\tif (adapter->cmdThread &&\n\t\tatomic_read(&adapter->cmdpriv.cmdthd_running) &&\n\t\tadapter->cmdpriv.stop_req == 0) {\n\t\tadapter->cmdpriv.stop_req = 1;\n\t\tcomplete(&adapter->cmdpriv.cmd_queue_comp);\n\t\twait_for_completion(&adapter->cmdpriv.terminate_cmdthread_comp);\n\t}\n}\n\nint rtw_cmd_thread(void *context)\n{\n\tu8 ret;\n\tstruct cmd_obj *pcmd;\n\tu8 *pcmdbuf;\n\tu8 (*cmd_hdl)(struct adapter *padapter, u8 *pbuf);\n\tvoid (*pcmd_callback)(struct adapter *dev, struct cmd_obj *pcmd);\n\tstruct adapter *padapter = context;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tstruct drvextra_cmd_parm *extra_parm = NULL;\n\n\tthread_enter(\"RTW_CMD_THREAD\");\n\n\tpcmdbuf = pcmdpriv->cmd_buf;\n\n\tpcmdpriv->stop_req = 0;\n\tatomic_set(&pcmdpriv->cmdthd_running, true);\n\tcomplete(&pcmdpriv->terminate_cmdthread_comp);\n\n\twhile (1) {\n\t\tif (wait_for_completion_interruptible(&pcmdpriv->cmd_queue_comp)) {\n\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t   FUNC_ADPT_FMT \" wait_for_completion_interruptible(&pcmdpriv->cmd_queue_comp) return != 0, break\\n\",\n\t\t\t\t   FUNC_ADPT_ARG(padapter));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (padapter->bDriverStopped || padapter->bSurpriseRemoved) {\n\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t   \"%s: DriverStopped(%d) SurpriseRemoved(%d) break at line %d\\n\",\n\t\t\t\t   __func__, padapter->bDriverStopped,\n\t\t\t\t   padapter->bSurpriseRemoved, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pcmdpriv->stop_req) {\n\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t   FUNC_ADPT_FMT \" stop_req:%u, break\\n\",\n\t\t\t\t   FUNC_ADPT_ARG(padapter),\n\t\t\t\t   pcmdpriv->stop_req);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (list_empty(&pcmdpriv->cmd_queue.queue))\n\t\t\tcontinue;\n\n\t\tif (rtw_register_cmd_alive(padapter) != _SUCCESS)\n\t\t\tcontinue;\n\n_next:\n\t\tif (padapter->bDriverStopped || padapter->bSurpriseRemoved) {\n\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t   \"%s: DriverStopped(%d) SurpriseRemoved(%d) break at line %d\\n\",\n\t\t\t\t   __func__, padapter->bDriverStopped,\n\t\t\t\t   padapter->bSurpriseRemoved, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tpcmd = rtw_dequeue_cmd(pcmdpriv);\n\t\tif (!pcmd) {\n\t\t\trtw_unregister_cmd_alive(padapter);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rtw_cmd_filter(pcmdpriv, pcmd) == _FAIL) {\n\t\t\tpcmd->res = H2C_DROPPED;\n\t\t\tgoto post_process;\n\t\t}\n\n\t\tpcmdpriv->cmd_issued_cnt++;\n\n\t\tpcmd->cmdsz = round_up((pcmd->cmdsz), 4);\n\n\t\tmemcpy(pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);\n\n\t\tif (pcmd->cmdcode < ARRAY_SIZE(wlancmds)) {\n\t\t\tcmd_hdl = wlancmds[pcmd->cmdcode].h2cfuns;\n\n\t\t\tif (cmd_hdl) {\n\t\t\t\tret = cmd_hdl(pcmd->padapter, pcmdbuf);\n\t\t\t\tpcmd->res = ret;\n\t\t\t}\n\n\t\t\tpcmdpriv->cmd_seq++;\n\t\t} else {\n\t\t\tpcmd->res = H2C_PARAMETERS_ERROR;\n\t\t}\n\n\t\tcmd_hdl = NULL;\n\npost_process:\n\n\t\tif (mutex_lock_interruptible(&pcmd->padapter->cmdpriv.sctx_mutex) == 0) {\n\t\t\tif (pcmd->sctx) {\n\t\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t\t   FUNC_ADPT_FMT \" pcmd->sctx\\n\",\n\t\t\t\t\t   FUNC_ADPT_ARG(pcmd->padapter));\n\n\t\t\t\tif (pcmd->res == H2C_SUCCESS)\n\t\t\t\t\trtw_sctx_done(&pcmd->sctx);\n\t\t\t\telse\n\t\t\t\t\trtw_sctx_done_err(&pcmd->sctx, RTW_SCTX_DONE_CMD_ERROR);\n\t\t\t}\n\t\t\tmutex_unlock(&pcmd->padapter->cmdpriv.sctx_mutex);\n\t\t}\n\n\t\t \n\t\tif (pcmd->cmdcode < ARRAY_SIZE(rtw_cmd_callback)) {\n\t\t\tpcmd_callback = rtw_cmd_callback[pcmd->cmdcode].callback;\n\t\t\tif (!pcmd_callback) {\n\t\t\t\trtw_free_cmd_obj(pcmd);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tpcmd_callback(pcmd->padapter, pcmd); \n\t\t\t}\n\t\t} else {\n\t\t\trtw_free_cmd_obj(pcmd);\n\t\t}\n\t\tflush_signals_thread();\n\t\tgoto _next;\n\t}\n\n\t \n\tdo {\n\t\tpcmd = rtw_dequeue_cmd(pcmdpriv);\n\t\tif (!pcmd) {\n\t\t\trtw_unregister_cmd_alive(padapter);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pcmd->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra)) {\n\t\t\textra_parm = (struct drvextra_cmd_parm *)pcmd->parmbuf;\n\t\t\tif (extra_parm->pbuf && extra_parm->size > 0)\n\t\t\t\tkfree(extra_parm->pbuf);\n\t\t}\n\n\t\trtw_free_cmd_obj(pcmd);\n\t} while (1);\n\n\tcomplete(&pcmdpriv->terminate_cmdthread_comp);\n\tatomic_set(&pcmdpriv->cmdthd_running, false);\n\n\treturn 0;\n}\n\n \n\nu8 rtw_sitesurvey_cmd(struct adapter  *padapter, struct ndis_802_11_ssid *ssid, int ssid_num,\n\tstruct rtw_ieee80211_channel *ch, int ch_num)\n{\n\tu8 res = _FAIL;\n\tstruct cmd_obj *ph2c;\n\tstruct sitesurvey_parm *psurveyPara;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (check_fwstate(pmlmepriv, _FW_LINKED))\n\t\trtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SCAN, 1);\n\n\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ph2c)\n\t\treturn _FAIL;\n\n\tpsurveyPara = rtw_zmalloc(sizeof(struct sitesurvey_parm));\n\tif (!psurveyPara) {\n\t\tkfree(ph2c);\n\t\treturn _FAIL;\n\t}\n\n\trtw_free_network_queue(padapter, false);\n\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara, GEN_CMD_CODE(_SiteSurvey));\n\n\t \n\tpsurveyPara->scan_mode = pmlmepriv->scan_mode;\n\n\t \n\tif (ssid) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ssid_num && i < RTW_SSID_SCAN_AMOUNT; i++) {\n\t\t\tif (ssid[i].ssid_length) {\n\t\t\t\tmemcpy(&psurveyPara->ssid[i], &ssid[i], sizeof(struct ndis_802_11_ssid));\n\t\t\t\tpsurveyPara->ssid_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (ch) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ch_num && i < RTW_CHANNEL_SCAN_AMOUNT; i++) {\n\t\t\tif (ch[i].hw_value && !(ch[i].flags & RTW_IEEE80211_CHAN_DISABLED)) {\n\t\t\t\tmemcpy(&psurveyPara->ch[i], &ch[i], sizeof(struct rtw_ieee80211_channel));\n\t\t\t\tpsurveyPara->ch_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\tset_fwstate(pmlmepriv, _FW_UNDER_SURVEY);\n\n\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\n\tif (res == _SUCCESS) {\n\t\tpmlmepriv->scan_start_time = jiffies;\n\t\t_set_timer(&pmlmepriv->scan_to_timer, SCANNING_TIMEOUT);\n\t} else {\n\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);\n\t}\n\treturn res;\n}\n\nvoid rtw_getbbrfreg_cmdrsp_callback(struct adapter *padapter,  struct cmd_obj *pcmd)\n{\n\t \n\tkfree(pcmd->parmbuf);\n\tkfree(pcmd);\n}\n\nu8 rtw_createbss_cmd(struct adapter  *padapter)\n{\n\tstruct cmd_obj *pcmd;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tstruct wlan_bssid_ex *pdev_network = &padapter->registrypriv.dev_network;\n\tu8 res = _SUCCESS;\n\n\tpcmd = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!pcmd) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tINIT_LIST_HEAD(&pcmd->list);\n\tpcmd->cmdcode = _CreateBss_CMD_;\n\tpcmd->parmbuf = (unsigned char *)pdev_network;\n\tpcmd->cmdsz = get_wlan_bssid_ex_sz((struct wlan_bssid_ex *)pdev_network);\n\tpcmd->rsp = NULL;\n\tpcmd->rspsz = 0;\n\n\tpdev_network->length = pcmd->cmdsz;\n\n\tres = rtw_enqueue_cmd(pcmdpriv, pcmd);\n\nexit:\n\treturn res;\n}\n\nint rtw_startbss_cmd(struct adapter  *padapter, int flags)\n{\n\tstruct cmd_obj *pcmd;\n\tstruct cmd_priv  *pcmdpriv = &padapter->cmdpriv;\n\tstruct submit_ctx sctx;\n\tint res = _SUCCESS;\n\n\tif (flags & RTW_CMDF_DIRECTLY) {\n\t\t \n\t\tstart_bss_network(padapter);\n\t} else {\n\t\t \n\t\tpcmd = rtw_zmalloc(sizeof(struct cmd_obj));\n\t\tif (!pcmd) {\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&pcmd->list);\n\t\tpcmd->cmdcode = GEN_CMD_CODE(_CreateBss);\n\t\tpcmd->parmbuf = NULL;\n\t\tpcmd->cmdsz =  0;\n\t\tpcmd->rsp = NULL;\n\t\tpcmd->rspsz = 0;\n\n\t\tif (flags & RTW_CMDF_WAIT_ACK) {\n\t\t\tpcmd->sctx = &sctx;\n\t\t\trtw_sctx_init(&sctx, 2000);\n\t\t}\n\n\t\tres = rtw_enqueue_cmd(pcmdpriv, pcmd);\n\n\t\tif (res == _SUCCESS && (flags & RTW_CMDF_WAIT_ACK)) {\n\t\t\trtw_sctx_wait(&sctx);\n\t\t\tif (mutex_lock_interruptible(&pcmdpriv->sctx_mutex) == 0) {\n\t\t\t\tif (sctx.status == RTW_SCTX_SUBMITTED)\n\t\t\t\t\tpcmd->sctx = NULL;\n\t\t\t\tmutex_unlock(&pcmdpriv->sctx_mutex);\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\treturn res;\n}\n\nu8 rtw_joinbss_cmd(struct adapter  *padapter, struct wlan_network *pnetwork)\n{\n\tu8 res = _SUCCESS;\n\tuint\tt_len = 0;\n\tstruct wlan_bssid_ex *psecnetwork;\n\tstruct cmd_obj *pcmd;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\tstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\n\tenum ndis_802_11_network_infrastructure ndis_network_mode = pnetwork->network.infrastructure_mode;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\n\tu32 tmp_len;\n\tu8 *ptmp = NULL;\n\n\tpcmd = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!pcmd) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\t \n\tt_len = sizeof(struct wlan_bssid_ex);\n\n\n\t \n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) != true) {\n\t\tswitch (ndis_network_mode) {\n\t\tcase Ndis802_11IBSS:\n\t\t\tset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\n\t\t\tbreak;\n\n\t\tcase Ndis802_11Infrastructure:\n\t\t\tset_fwstate(pmlmepriv, WIFI_STATION_STATE);\n\t\t\tbreak;\n\n\t\tcase Ndis802_11APMode:\n\t\tcase Ndis802_11AutoUnknown:\n\t\tcase Ndis802_11InfrastructureMax:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpsecnetwork = (struct wlan_bssid_ex *)&psecuritypriv->sec_bss;\n\n\tmemset(psecnetwork, 0, t_len);\n\n\tmemcpy(psecnetwork, &pnetwork->network, get_wlan_bssid_ex_sz(&pnetwork->network));\n\n\tpsecuritypriv->authenticator_ie[0] = (unsigned char)psecnetwork->ie_length;\n\n\tif ((psecnetwork->ie_length-12) < (256-1))\n\t\tmemcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->ies[12], psecnetwork->ie_length-12);\n\telse\n\t\tmemcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->ies[12], (256-1));\n\n\tpsecnetwork->ie_length = 0;\n\t \n\t \n\t \n\t \n\n\tif (!pmlmepriv->assoc_by_bssid)\n\t\tmemcpy(&pmlmepriv->assoc_bssid[0], &pnetwork->network.mac_address[0], ETH_ALEN);\n\n\tpsecnetwork->ie_length = rtw_restruct_sec_ie(padapter, &pnetwork->network.ies[0], &psecnetwork->ies[0], pnetwork->network.ie_length);\n\n\n\tpqospriv->qos_option = 0;\n\n\tif (pregistrypriv->wmm_enable) {\n\t\ttmp_len = rtw_restruct_wmm_ie(padapter, &pnetwork->network.ies[0], &psecnetwork->ies[0], pnetwork->network.ie_length, psecnetwork->ie_length);\n\n\t\tif (psecnetwork->ie_length != tmp_len) {\n\t\t\tpsecnetwork->ie_length = tmp_len;\n\t\t\tpqospriv->qos_option = 1;  \n\t\t} else {\n\t\t\tpqospriv->qos_option = 0; \n\t\t}\n\t}\n\n\tphtpriv->ht_option = false;\n\tptmp = rtw_get_ie(&pnetwork->network.ies[12], WLAN_EID_HT_CAPABILITY, &tmp_len, pnetwork->network.ie_length-12);\n\tif (pregistrypriv->ht_enable && ptmp && tmp_len > 0) {\n\t\t \n\t\t \n\t\t \n\t\tif ((padapter->securitypriv.dot11PrivacyAlgrthm != _WEP40_) &&\n\t\t\t(padapter->securitypriv.dot11PrivacyAlgrthm != _WEP104_) &&\n\t\t\t(padapter->securitypriv.dot11PrivacyAlgrthm != _TKIP_)) {\n\t\t\trtw_ht_use_default_setting(padapter);\n\n\t\t\trtw_build_wmm_ie_ht(padapter, &psecnetwork->ies[12], &psecnetwork->ie_length);\n\n\t\t\t \n\t\t\trtw_restructure_ht_ie(padapter, &pnetwork->network.ies[12], &psecnetwork->ies[0],\n\t\t\t\t\t\t\t\t\tpnetwork->network.ie_length-12, &psecnetwork->ie_length,\n\t\t\t\t\t\t\t\t\tpnetwork->network.configuration.ds_config);\n\t\t}\n\t}\n\n\trtw_append_exented_cap(padapter, &psecnetwork->ies[0], &psecnetwork->ie_length);\n\n\tpmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->network.ies, pnetwork->network.ie_length);\n\n\tpcmd->cmdsz = get_wlan_bssid_ex_sz(psecnetwork); \n\n\tINIT_LIST_HEAD(&pcmd->list);\n\tpcmd->cmdcode = _JoinBss_CMD_; \n\tpcmd->parmbuf = (unsigned char *)psecnetwork;\n\tpcmd->rsp = NULL;\n\tpcmd->rspsz = 0;\n\n\tres = rtw_enqueue_cmd(pcmdpriv, pcmd);\n\nexit:\n\treturn res;\n}\n\nu8 rtw_disassoc_cmd(struct adapter *padapter, u32 deauth_timeout_ms, bool enqueue)  \n{\n\tstruct cmd_obj *cmdobj = NULL;\n\tstruct disconnect_parm *param = NULL;\n\tstruct cmd_priv *cmdpriv = &padapter->cmdpriv;\n\tu8 res = _SUCCESS;\n\n\t \n\tparam = rtw_zmalloc(sizeof(*param));\n\tif (!param) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\tparam->deauth_timeout_ms = deauth_timeout_ms;\n\n\tif (enqueue) {\n\t\t \n\t\tcmdobj = rtw_zmalloc(sizeof(*cmdobj));\n\t\tif (!cmdobj) {\n\t\t\tres = _FAIL;\n\t\t\tkfree(param);\n\t\t\tgoto exit;\n\t\t}\n\t\tinit_h2fwcmd_w_parm_no_rsp(cmdobj, param, _DisConnect_CMD_);\n\t\tres = rtw_enqueue_cmd(cmdpriv, cmdobj);\n\t} else {\n\t\t \n\t\tif (disconnect_hdl(padapter, (u8 *)param) != H2C_SUCCESS)\n\t\t\tres = _FAIL;\n\t\tkfree(param);\n\t}\n\nexit:\n\treturn res;\n}\n\nu8 rtw_setopmode_cmd(struct adapter  *padapter, enum ndis_802_11_network_infrastructure networktype, bool enqueue)\n{\n\tstruct\tcmd_obj *ph2c;\n\tstruct\tsetopmode_parm *psetop;\n\n\tstruct\tcmd_priv   *pcmdpriv = &padapter->cmdpriv;\n\tu8 res = _SUCCESS;\n\n\tpsetop = rtw_zmalloc(sizeof(struct setopmode_parm));\n\n\tif (!psetop) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\tpsetop->mode = (u8)networktype;\n\n\tif (enqueue) {\n\t\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\t\tif (!ph2c) {\n\t\t\tkfree(psetop);\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tinit_h2fwcmd_w_parm_no_rsp(ph2c, psetop, _SetOpMode_CMD_);\n\t\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\t} else {\n\t\tsetopmode_hdl(padapter, (u8 *)psetop);\n\t\tkfree(psetop);\n\t}\nexit:\n\treturn res;\n}\n\nu8 rtw_setstakey_cmd(struct adapter *padapter, struct sta_info *sta, u8 unicast_key, bool enqueue)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct set_stakey_parm *psetstakey_para;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tstruct set_stakey_rsp *psetstakey_rsp = NULL;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tu8 res = _SUCCESS;\n\n\tpsetstakey_para = rtw_zmalloc(sizeof(struct set_stakey_parm));\n\tif (!psetstakey_para) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(psetstakey_para->addr, sta->hwaddr, ETH_ALEN);\n\n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE))\n\t\tpsetstakey_para->algorithm = (unsigned char)psecuritypriv->dot11PrivacyAlgrthm;\n\telse\n\t\tGET_ENCRY_ALGO(psecuritypriv, sta, psetstakey_para->algorithm, false);\n\n\tif (unicast_key)\n\t\tmemcpy(&psetstakey_para->key, &sta->dot118021x_UncstKey, 16);\n\telse\n\t\tmemcpy(&psetstakey_para->key, &psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey, 16);\n\n\t \n\tpadapter->securitypriv.busetkipkey = true;\n\n\tif (enqueue) {\n\t\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\t\tif (!ph2c) {\n\t\t\tkfree(psetstakey_para);\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tpsetstakey_rsp = rtw_zmalloc(sizeof(struct set_stakey_rsp));\n\t\tif (!psetstakey_rsp) {\n\t\t\tkfree(ph2c);\n\t\t\tkfree(psetstakey_para);\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tinit_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);\n\t\tph2c->rsp = (u8 *)psetstakey_rsp;\n\t\tph2c->rspsz = sizeof(struct set_stakey_rsp);\n\t\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\t} else {\n\t\tset_stakey_hdl(padapter, (u8 *)psetstakey_para);\n\t\tkfree(psetstakey_para);\n\t}\nexit:\n\treturn res;\n}\n\nu8 rtw_clearstakey_cmd(struct adapter *padapter, struct sta_info *sta, u8 enqueue)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct set_stakey_parm *psetstakey_para;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tstruct set_stakey_rsp *psetstakey_rsp = NULL;\n\ts16 cam_id = 0;\n\tu8 res = _SUCCESS;\n\n\tif (!enqueue) {\n\t\twhile ((cam_id = rtw_camid_search(padapter, sta->hwaddr, -1)) >= 0) {\n\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t   \"clear key for addr:%pM, camid:%d\\n\",\n\t\t\t\t   MAC_ARG(sta->hwaddr), cam_id);\n\t\t\tclear_cam_entry(padapter, cam_id);\n\t\t\trtw_camid_free(padapter, cam_id);\n\t\t}\n\t} else {\n\t\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\t\tif (!ph2c) {\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tpsetstakey_para = rtw_zmalloc(sizeof(struct set_stakey_parm));\n\t\tif (!psetstakey_para) {\n\t\t\tkfree(ph2c);\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tpsetstakey_rsp = rtw_zmalloc(sizeof(struct set_stakey_rsp));\n\t\tif (!psetstakey_rsp) {\n\t\t\tkfree(ph2c);\n\t\t\tkfree(psetstakey_para);\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tinit_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);\n\t\tph2c->rsp = (u8 *)psetstakey_rsp;\n\t\tph2c->rspsz = sizeof(struct set_stakey_rsp);\n\n\t\tmemcpy(psetstakey_para->addr, sta->hwaddr, ETH_ALEN);\n\n\t\tpsetstakey_para->algorithm = _NO_PRIVACY_;\n\n\t\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\t}\nexit:\n\treturn res;\n}\n\nu8 rtw_addbareq_cmd(struct adapter *padapter, u8 tid, u8 *addr)\n{\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tstruct cmd_obj *ph2c;\n\tstruct addBaReq_parm *paddbareq_parm;\n\n\tu8 res = _SUCCESS;\n\n\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ph2c) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpaddbareq_parm = rtw_zmalloc(sizeof(struct addBaReq_parm));\n\tif (!paddbareq_parm) {\n\t\tkfree(ph2c);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpaddbareq_parm->tid = tid;\n\tmemcpy(paddbareq_parm->addr, addr, ETH_ALEN);\n\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, paddbareq_parm, GEN_CMD_CODE(_AddBAReq));\n\n\t \n\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\nexit:\n\treturn res;\n}\n \nu8 rtw_reset_securitypriv_cmd(struct adapter *padapter)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct drvextra_cmd_parm  *pdrvextra_cmd_parm;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tu8 res = _SUCCESS;\n\n\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ph2c) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm = rtw_zmalloc(sizeof(struct drvextra_cmd_parm));\n\tif (!pdrvextra_cmd_parm) {\n\t\tkfree(ph2c);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm->ec_id = RESET_SECURITYPRIV;\n\tpdrvextra_cmd_parm->type = 0;\n\tpdrvextra_cmd_parm->size = 0;\n\tpdrvextra_cmd_parm->pbuf = NULL;\n\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\n\n\n\t \n\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\nexit:\n\treturn res;\n}\n\nu8 rtw_free_assoc_resources_cmd(struct adapter *padapter)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct drvextra_cmd_parm  *pdrvextra_cmd_parm;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tu8 res = _SUCCESS;\n\n\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ph2c) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm = rtw_zmalloc(sizeof(struct drvextra_cmd_parm));\n\tif (!pdrvextra_cmd_parm) {\n\t\tkfree(ph2c);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm->ec_id = FREE_ASSOC_RESOURCES;\n\tpdrvextra_cmd_parm->type = 0;\n\tpdrvextra_cmd_parm->size = 0;\n\tpdrvextra_cmd_parm->pbuf = NULL;\n\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\n\n\t \n\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\nexit:\n\treturn res;\n}\n\nu8 rtw_dynamic_chk_wk_cmd(struct adapter *padapter)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct drvextra_cmd_parm  *pdrvextra_cmd_parm;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tu8 res = _SUCCESS;\n\n\t \n\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ph2c) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm = rtw_zmalloc(sizeof(struct drvextra_cmd_parm));\n\tif (!pdrvextra_cmd_parm) {\n\t\tkfree(ph2c);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm->ec_id = DYNAMIC_CHK_WK_CID;\n\tpdrvextra_cmd_parm->type = 0;\n\tpdrvextra_cmd_parm->size = 0;\n\tpdrvextra_cmd_parm->pbuf = NULL;\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\n\n\n\t \n\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\nexit:\n\treturn res;\n}\n\nstatic void collect_traffic_statistics(struct adapter *padapter)\n{\n\tstruct dvobj_priv *pdvobjpriv = adapter_to_dvobj(padapter);\n\n\t \n\tpdvobjpriv->traffic_stat.tx_bytes = padapter->xmitpriv.tx_bytes;\n\tpdvobjpriv->traffic_stat.tx_pkts = padapter->xmitpriv.tx_pkts;\n\tpdvobjpriv->traffic_stat.tx_drop = padapter->xmitpriv.tx_drop;\n\n\t \n\tpdvobjpriv->traffic_stat.rx_bytes = padapter->recvpriv.rx_bytes;\n\tpdvobjpriv->traffic_stat.rx_pkts = padapter->recvpriv.rx_pkts;\n\tpdvobjpriv->traffic_stat.rx_drop = padapter->recvpriv.rx_drop;\n\n\t \n\tpdvobjpriv->traffic_stat.cur_tx_bytes = pdvobjpriv->traffic_stat.tx_bytes - pdvobjpriv->traffic_stat.last_tx_bytes;\n\tpdvobjpriv->traffic_stat.cur_rx_bytes = pdvobjpriv->traffic_stat.rx_bytes - pdvobjpriv->traffic_stat.last_rx_bytes;\n\tpdvobjpriv->traffic_stat.last_tx_bytes = pdvobjpriv->traffic_stat.tx_bytes;\n\tpdvobjpriv->traffic_stat.last_rx_bytes = pdvobjpriv->traffic_stat.rx_bytes;\n\n\tpdvobjpriv->traffic_stat.cur_tx_tp = (u32)(pdvobjpriv->traffic_stat.cur_tx_bytes * 8/2/1024/1024);\n\tpdvobjpriv->traffic_stat.cur_rx_tp = (u32)(pdvobjpriv->traffic_stat.cur_rx_bytes * 8/2/1024/1024);\n}\n\nu8 traffic_status_watchdog(struct adapter *padapter, u8 from_timer)\n{\n\tu8 bEnterPS = false;\n\tu16 BusyThresholdHigh = 25;\n\tu16 BusyThresholdLow = 10;\n\tu16 BusyThreshold = BusyThresholdHigh;\n\tu8 bBusyTraffic = false, bTxBusyTraffic = false, bRxBusyTraffic = false;\n\tu8 bHigherBusyTraffic = false, bHigherBusyRxTraffic = false, bHigherBusyTxTraffic = false;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tcollect_traffic_statistics(padapter);\n\n\t \n\t \n\t \n\tif ((check_fwstate(pmlmepriv, _FW_LINKED))\n\t\t ) {\n\t\t \n\t\tif (pmlmepriv->LinkDetectInfo.bBusyTraffic)\n\t\t\tBusyThreshold = BusyThresholdLow;\n\n\t\tif (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > BusyThreshold ||\n\t\t\tpmlmepriv->LinkDetectInfo.NumTxOkInPeriod > BusyThreshold) {\n\t\t\tbBusyTraffic = true;\n\n\t\t\tif (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > pmlmepriv->LinkDetectInfo.NumTxOkInPeriod)\n\t\t\t\tbRxBusyTraffic = true;\n\t\t\telse\n\t\t\t\tbTxBusyTraffic = true;\n\t\t}\n\n\t\t \n\t\tif (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 4000 ||\n\t\t\tpmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 4000) {\n\t\t\tbHigherBusyTraffic = true;\n\n\t\t\tif (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > pmlmepriv->LinkDetectInfo.NumTxOkInPeriod)\n\t\t\t\tbHigherBusyRxTraffic = true;\n\t\t\telse\n\t\t\t\tbHigherBusyTxTraffic = true;\n\t\t}\n\n\t\t \n\t\tif (((pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod + pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) > 8) ||\n\t\t\t(pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 2)) {\n\t\t\tbEnterPS = false;\n\n\t\t\tif (bBusyTraffic) {\n\t\t\t\tif (pmlmepriv->LinkDetectInfo.TrafficTransitionCount <= 4)\n\t\t\t\t\tpmlmepriv->LinkDetectInfo.TrafficTransitionCount = 4;\n\n\t\t\t\tpmlmepriv->LinkDetectInfo.TrafficTransitionCount++;\n\n\t\t\t\tif (pmlmepriv->LinkDetectInfo.TrafficTransitionCount > 30 )\n\t\t\t\t\tpmlmepriv->LinkDetectInfo.TrafficTransitionCount = 30;\n\t\t\t}\n\t\t} else {\n\t\t\tif (pmlmepriv->LinkDetectInfo.TrafficTransitionCount >= 2)\n\t\t\t\tpmlmepriv->LinkDetectInfo.TrafficTransitionCount -= 2;\n\t\t\telse\n\t\t\t\tpmlmepriv->LinkDetectInfo.TrafficTransitionCount = 0;\n\n\t\t\tif (pmlmepriv->LinkDetectInfo.TrafficTransitionCount == 0)\n\t\t\t\tbEnterPS = true;\n\t\t}\n\n\t\t \n\t\tif (bEnterPS) {\n\t\t\tif (!from_timer)\n\t\t\t\tLPS_Enter(padapter, \"TRAFFIC_IDLE\");\n\t\t} else {\n\t\t\tif (!from_timer)\n\t\t\t\tLPS_Leave(padapter, \"TRAFFIC_BUSY\");\n\t\t\telse\n\t\t\t\trtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_TRAFFIC_BUSY, 1);\n\t\t}\n\t} else {\n\t\tstruct dvobj_priv *dvobj = adapter_to_dvobj(padapter);\n\t\tint n_assoc_iface = 0;\n\n\t\tif (check_fwstate(&dvobj->padapters->mlmepriv, WIFI_ASOC_STATE))\n\t\t\tn_assoc_iface++;\n\n\t\tif (!from_timer && n_assoc_iface == 0)\n\t\t\tLPS_Leave(padapter, \"NON_LINKED\");\n\t}\n\n\tpmlmepriv->LinkDetectInfo.NumRxOkInPeriod = 0;\n\tpmlmepriv->LinkDetectInfo.NumTxOkInPeriod = 0;\n\tpmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod = 0;\n\tpmlmepriv->LinkDetectInfo.bBusyTraffic = bBusyTraffic;\n\tpmlmepriv->LinkDetectInfo.bTxBusyTraffic = bTxBusyTraffic;\n\tpmlmepriv->LinkDetectInfo.bRxBusyTraffic = bRxBusyTraffic;\n\tpmlmepriv->LinkDetectInfo.bHigherBusyTraffic = bHigherBusyTraffic;\n\tpmlmepriv->LinkDetectInfo.bHigherBusyRxTraffic = bHigherBusyRxTraffic;\n\tpmlmepriv->LinkDetectInfo.bHigherBusyTxTraffic = bHigherBusyTxTraffic;\n\n\treturn bEnterPS;\n\n}\n\nstatic void dynamic_chk_wk_hdl(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv;\n\n\tpmlmepriv = &padapter->mlmepriv;\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE))\n\t\texpire_timeout_chk(padapter);\n\n\t \n\t_linked_info_dump(padapter);\n\t \n\t{\n\t\tlinked_status_chk(padapter);\n\t\ttraffic_status_watchdog(padapter, 0);\n\t}\n\trtw_hal_dm_watchdog(padapter);\n\n\t \n\n\t \n\t \n\t \n\thal_btcoex_Handler(padapter);\n\n\n\t \n\tif (is_primary_adapter(padapter))\n\t\trtw_ps_processor(padapter);\n}\n\nvoid lps_ctrl_wk_hdl(struct adapter *padapter, u8 lps_ctrl_type);\nvoid lps_ctrl_wk_hdl(struct adapter *padapter, u8 lps_ctrl_type)\n{\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tu8 mstatus;\n\n\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) ||\n\t\tcheck_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {\n\t\treturn;\n\t}\n\n\tswitch (lps_ctrl_type) {\n\tcase LPS_CTRL_SCAN:\n\t\thal_btcoex_ScanNotify(padapter, true);\n\n\t\tif (check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\t\t \n\t\t\tLPS_Leave(padapter, \"LPS_CTRL_SCAN\");\n\t\t}\n\t\tbreak;\n\tcase LPS_CTRL_JOINBSS:\n\t\tLPS_Leave(padapter, \"LPS_CTRL_JOINBSS\");\n\t\tbreak;\n\tcase LPS_CTRL_CONNECT:\n\t\tmstatus = 1; \n\t\t \n\t\tpwrpriv->LpsIdleCount = 0;\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT, (u8 *)(&mstatus));\n\t\trtw_btcoex_MediaStatusNotify(padapter, mstatus);\n\t\tbreak;\n\tcase LPS_CTRL_DISCONNECT:\n\t\tmstatus = 0; \n\t\trtw_btcoex_MediaStatusNotify(padapter, mstatus);\n\t\tLPS_Leave(padapter, \"LPS_CTRL_DISCONNECT\");\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT, (u8 *)(&mstatus));\n\t\tbreak;\n\tcase LPS_CTRL_SPECIAL_PACKET:\n\t\tpwrpriv->DelayLPSLastTimeStamp = jiffies;\n\t\thal_btcoex_SpecialPacketNotify(padapter, PACKET_DHCP);\n\t\tLPS_Leave(padapter, \"LPS_CTRL_SPECIAL_PACKET\");\n\t\tbreak;\n\tcase LPS_CTRL_LEAVE:\n\t\tLPS_Leave(padapter, \"LPS_CTRL_LEAVE\");\n\t\tbreak;\n\tcase LPS_CTRL_TRAFFIC_BUSY:\n\t\tLPS_Leave(padapter, \"LPS_CTRL_TRAFFIC_BUSY\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nu8 rtw_lps_ctrl_wk_cmd(struct adapter *padapter, u8 lps_ctrl_type, u8 enqueue)\n{\n\tstruct cmd_obj\t*ph2c;\n\tstruct drvextra_cmd_parm *pdrvextra_cmd_parm;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\t \n\tu8 res = _SUCCESS;\n\n\t \n\t \n\n\tif (enqueue) {\n\t\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\t\tif (!ph2c) {\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tpdrvextra_cmd_parm = rtw_zmalloc(sizeof(struct drvextra_cmd_parm));\n\t\tif (!pdrvextra_cmd_parm) {\n\t\t\tkfree(ph2c);\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tpdrvextra_cmd_parm->ec_id = LPS_CTRL_WK_CID;\n\t\tpdrvextra_cmd_parm->type = lps_ctrl_type;\n\t\tpdrvextra_cmd_parm->size = 0;\n\t\tpdrvextra_cmd_parm->pbuf = NULL;\n\n\t\tinit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\n\n\t\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\t} else {\n\t\tlps_ctrl_wk_hdl(padapter, lps_ctrl_type);\n\t}\n\nexit:\n\treturn res;\n}\n\nstatic void rtw_dm_in_lps_hdl(struct adapter *padapter)\n{\n\trtw_hal_set_hwreg(padapter, HW_VAR_DM_IN_LPS, NULL);\n}\n\nu8 rtw_dm_in_lps_wk_cmd(struct adapter *padapter)\n{\n\tstruct cmd_obj\t*ph2c;\n\tstruct drvextra_cmd_parm\t*pdrvextra_cmd_parm;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tu8 res = _SUCCESS;\n\n\n\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ph2c) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm = rtw_zmalloc(sizeof(struct drvextra_cmd_parm));\n\tif (!pdrvextra_cmd_parm) {\n\t\tkfree(ph2c);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm->ec_id = DM_IN_LPS_WK_CID;\n\tpdrvextra_cmd_parm->type = 0;\n\tpdrvextra_cmd_parm->size = 0;\n\tpdrvextra_cmd_parm->pbuf = NULL;\n\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\n\n\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\nexit:\n\treturn res;\n}\n\nstatic void rtw_lps_change_dtim_hdl(struct adapter *padapter, u8 dtim)\n{\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\n\tif (dtim <= 0 || dtim > 16)\n\t\treturn;\n\n\tif (hal_btcoex_IsBtControlLps(padapter))\n\t\treturn;\n\n\tmutex_lock(&pwrpriv->lock);\n\n\tpwrpriv->dtim = dtim;\n\n\tif (pwrpriv->fw_current_in_ps_mode && (pwrpriv->pwr_mode > PS_MODE_ACTIVE)) {\n\t\tu8 ps_mode = pwrpriv->pwr_mode;\n\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, (u8 *)(&ps_mode));\n\t}\n\n\tmutex_unlock(&pwrpriv->lock);\n}\n\nstatic void rtw_dm_ra_mask_hdl(struct adapter *padapter, struct sta_info *psta)\n{\n\tif (psta)\n\t\tset_sta_rate(padapter, psta);\n}\n\nu8 rtw_dm_ra_mask_wk_cmd(struct adapter *padapter, u8 *psta)\n{\n\tstruct cmd_obj\t*ph2c;\n\tstruct drvextra_cmd_parm\t*pdrvextra_cmd_parm;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tu8 res = _SUCCESS;\n\n\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ph2c) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm = rtw_zmalloc(sizeof(struct drvextra_cmd_parm));\n\tif (!pdrvextra_cmd_parm) {\n\t\tkfree(ph2c);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm->ec_id = DM_RA_MSK_WK_CID;\n\tpdrvextra_cmd_parm->type = 0;\n\tpdrvextra_cmd_parm->size = 0;\n\tpdrvextra_cmd_parm->pbuf = psta;\n\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\n\n\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\nexit:\n\n\treturn res;\n\n}\n\nu8 rtw_ps_cmd(struct adapter *padapter)\n{\n\tstruct cmd_obj\t\t*ppscmd;\n\tstruct drvextra_cmd_parm\t*pdrvextra_cmd_parm;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tu8 res = _SUCCESS;\n\tppscmd = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ppscmd) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm = rtw_zmalloc(sizeof(struct drvextra_cmd_parm));\n\tif (!pdrvextra_cmd_parm) {\n\t\tkfree(ppscmd);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm->ec_id = POWER_SAVING_CTRL_WK_CID;\n\tpdrvextra_cmd_parm->type = 0;\n\tpdrvextra_cmd_parm->size = 0;\n\tpdrvextra_cmd_parm->pbuf = NULL;\n\tinit_h2fwcmd_w_parm_no_rsp(ppscmd, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\n\n\tres = rtw_enqueue_cmd(pcmdpriv, ppscmd);\n\nexit:\n\treturn res;\n}\n\nu32 g_wait_hiq_empty;\n\nstatic void rtw_chk_hi_queue_hdl(struct adapter *padapter)\n{\n\tstruct sta_info *psta_bmc;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tunsigned long start = jiffies;\n\tu8 empty = false;\n\n\tpsta_bmc = rtw_get_bcmc_stainfo(padapter);\n\tif (!psta_bmc)\n\t\treturn;\n\n\trtw_hal_get_hwreg(padapter, HW_VAR_CHK_HI_QUEUE_EMPTY, &empty);\n\n\twhile (!empty && jiffies_to_msecs(jiffies - start) < g_wait_hiq_empty) {\n\t\tmsleep(100);\n\t\trtw_hal_get_hwreg(padapter, HW_VAR_CHK_HI_QUEUE_EMPTY, &empty);\n\t}\n\n\tif (psta_bmc->sleepq_len == 0) {\n\t\tif (empty == _SUCCESS) {\n\t\t\tbool update_tim = false;\n\n\t\t\tif (pstapriv->tim_bitmap & BIT(0))\n\t\t\t\tupdate_tim = true;\n\n\t\t\tpstapriv->tim_bitmap &= ~BIT(0);\n\t\t\tpstapriv->sta_dz_bitmap &= ~BIT(0);\n\n\t\t\tif (update_tim)\n\t\t\t\tupdate_beacon(padapter, WLAN_EID_TIM, NULL, true);\n\t\t} else { \n\t\t\trtw_chk_hi_queue_cmd(padapter);\n\t\t}\n\n\t}\n\n}\n\nu8 rtw_chk_hi_queue_cmd(struct adapter *padapter)\n{\n\tstruct cmd_obj\t*ph2c;\n\tstruct drvextra_cmd_parm\t*pdrvextra_cmd_parm;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tu8 res = _SUCCESS;\n\n\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ph2c) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm = rtw_zmalloc(sizeof(struct drvextra_cmd_parm));\n\tif (!pdrvextra_cmd_parm) {\n\t\tkfree(ph2c);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm->ec_id = CHECK_HIQ_WK_CID;\n\tpdrvextra_cmd_parm->type = 0;\n\tpdrvextra_cmd_parm->size = 0;\n\tpdrvextra_cmd_parm->pbuf = NULL;\n\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\n\n\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\nexit:\n\treturn res;\n}\n\nstruct btinfo {\n\tu8 cid;\n\tu8 len;\n\n\tu8 bConnection:1;\n\tu8 bSCOeSCO:1;\n\tu8 bInQPage:1;\n\tu8 bACLBusy:1;\n\tu8 bSCOBusy:1;\n\tu8 bHID:1;\n\tu8 bA2DP:1;\n\tu8 bFTP:1;\n\n\tu8 retry_cnt:4;\n\tu8 rsvd_34:1;\n\tu8 rsvd_35:1;\n\tu8 rsvd_36:1;\n\tu8 rsvd_37:1;\n\n\tu8 rssi;\n\n\tu8 rsvd_50:1;\n\tu8 rsvd_51:1;\n\tu8 rsvd_52:1;\n\tu8 rsvd_53:1;\n\tu8 rsvd_54:1;\n\tu8 rsvd_55:1;\n\tu8 eSCO_SCO:1;\n\tu8 Master_Slave:1;\n\n\tu8 rsvd_6;\n\tu8 rsvd_7;\n};\n\nstatic void rtw_btinfo_hdl(struct adapter *adapter, u8 *buf, u16 buf_len)\n{\n\t#define BTINFO_WIFI_FETCH 0x23\n\t#define BTINFO_BT_AUTO_RPT 0x27\n\tstruct btinfo *info = (struct btinfo *)buf;\n\tu8 cmd_idx;\n\tu8 len;\n\n\tcmd_idx = info->cid;\n\n\tif (info->len > buf_len-2) {\n\t\trtw_warn_on(1);\n\t\tlen = buf_len-2;\n\t} else {\n\t\tlen = info->len;\n\t}\n\n\t \n\tif (cmd_idx == BTINFO_WIFI_FETCH)\n\t\tbuf[1] = 0;\n\telse if (cmd_idx == BTINFO_BT_AUTO_RPT)\n\t\tbuf[1] = 2;\n\thal_btcoex_BtInfoNotify(adapter, len+1, &buf[1]);\n}\n\nu8 rtw_c2h_packet_wk_cmd(struct adapter *padapter, u8 *pbuf, u16 length)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct drvextra_cmd_parm *pdrvextra_cmd_parm;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tu8 res = _SUCCESS;\n\n\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ph2c) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm = rtw_zmalloc(sizeof(struct drvextra_cmd_parm));\n\tif (!pdrvextra_cmd_parm) {\n\t\tkfree(ph2c);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm->ec_id = C2H_WK_CID;\n\tpdrvextra_cmd_parm->type = 0;\n\tpdrvextra_cmd_parm->size = length;\n\tpdrvextra_cmd_parm->pbuf = pbuf;\n\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\n\n\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\nexit:\n\treturn res;\n}\n\n \n \nu8 rtw_c2h_wk_cmd(struct adapter *padapter, u8 *c2h_evt)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct drvextra_cmd_parm *pdrvextra_cmd_parm;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tu8 res = _SUCCESS;\n\n\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ph2c) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm = rtw_zmalloc(sizeof(struct drvextra_cmd_parm));\n\tif (!pdrvextra_cmd_parm) {\n\t\tkfree(ph2c);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpdrvextra_cmd_parm->ec_id = C2H_WK_CID;\n\tpdrvextra_cmd_parm->type = 0;\n\tpdrvextra_cmd_parm->size =  c2h_evt?16:0;\n\tpdrvextra_cmd_parm->pbuf = c2h_evt;\n\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\n\n\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\nexit:\n\n\treturn res;\n}\n\nstatic void c2h_wk_callback(struct work_struct *work)\n{\n\tstruct evt_priv *evtpriv = container_of(work, struct evt_priv, c2h_wk);\n\tstruct adapter *adapter = container_of(evtpriv, struct adapter, evtpriv);\n\tu8 *c2h_evt;\n\tc2h_id_filter ccx_id_filter = rtw_hal_c2h_id_filter_ccx(adapter);\n\n\tevtpriv->c2h_wk_alive = true;\n\n\twhile (!rtw_cbuf_empty(evtpriv->c2h_queue)) {\n\t\tc2h_evt = (u8 *)rtw_cbuf_pop(evtpriv->c2h_queue);\n\t\tif (c2h_evt) {\n\t\t\t \n\t\t\tc2h_evt_clear(adapter);\n\t\t} else {\n\t\t\tc2h_evt = rtw_malloc(16);\n\t\t\tif (c2h_evt) {\n\t\t\t\t \n\t\t\t\tif (c2h_evt_read_88xx(adapter, c2h_evt) != _SUCCESS) {\n\t\t\t\t\tkfree(c2h_evt);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((void *)c2h_evt == (void *)evtpriv)\n\t\t\tcontinue;\n\n\t\tif (!rtw_hal_c2h_valid(adapter, c2h_evt)) {\n\t\t\tkfree(c2h_evt);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ccx_id_filter(c2h_evt)) {\n\t\t\t \n\t\t\trtw_hal_c2h_handler(adapter, c2h_evt);\n\t\t\tkfree(c2h_evt);\n\t\t} else {\n\t\t\t \n\t\t\trtw_c2h_wk_cmd(adapter, c2h_evt);\n\t\t}\n\t}\n\n\tevtpriv->c2h_wk_alive = false;\n}\n\nu8 rtw_drvextra_cmd_hdl(struct adapter *padapter, unsigned char *pbuf)\n{\n\tstruct drvextra_cmd_parm *pdrvextra_cmd;\n\n\tif (!pbuf)\n\t\treturn H2C_PARAMETERS_ERROR;\n\n\tpdrvextra_cmd = (struct drvextra_cmd_parm *)pbuf;\n\n\tswitch (pdrvextra_cmd->ec_id) {\n\tcase DYNAMIC_CHK_WK_CID: \n\t\tdynamic_chk_wk_hdl(padapter);\n\t\tbreak;\n\tcase POWER_SAVING_CTRL_WK_CID:\n\t\trtw_ps_processor(padapter);\n\t\tbreak;\n\tcase LPS_CTRL_WK_CID:\n\t\tlps_ctrl_wk_hdl(padapter, (u8)pdrvextra_cmd->type);\n\t\tbreak;\n\tcase DM_IN_LPS_WK_CID:\n\t\trtw_dm_in_lps_hdl(padapter);\n\t\tbreak;\n\tcase LPS_CHANGE_DTIM_CID:\n\t\trtw_lps_change_dtim_hdl(padapter, (u8)pdrvextra_cmd->type);\n\t\tbreak;\n\tcase CHECK_HIQ_WK_CID:\n\t\trtw_chk_hi_queue_hdl(padapter);\n\t\tbreak;\n\t \n\tcase RESET_SECURITYPRIV:\n\t\trtw_reset_securitypriv(padapter);\n\t\tbreak;\n\tcase FREE_ASSOC_RESOURCES:\n\t\trtw_free_assoc_resources(padapter, 1);\n\t\tbreak;\n\tcase C2H_WK_CID:\n\t\trtw_hal_set_hwreg_with_buf(padapter, HW_VAR_C2H_HANDLE, pdrvextra_cmd->pbuf, pdrvextra_cmd->size);\n\t\tbreak;\n\tcase DM_RA_MSK_WK_CID:\n\t\trtw_dm_ra_mask_hdl(padapter, (struct sta_info *)pdrvextra_cmd->pbuf);\n\t\tbreak;\n\tcase BTINFO_WK_CID:\n\t\trtw_btinfo_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->size);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (pdrvextra_cmd->pbuf && pdrvextra_cmd->size > 0)\n\t\tkfree(pdrvextra_cmd->pbuf);\n\n\treturn H2C_SUCCESS;\n}\n\nvoid rtw_survey_cmd_callback(struct adapter *padapter,  struct cmd_obj *pcmd)\n{\n\tstruct\tmlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (pcmd->res != H2C_SUCCESS) {\n\t\t \n\t\t_set_timer(&pmlmepriv->scan_to_timer, 1);\n\t}\n\n\t \n\trtw_free_cmd_obj(pcmd);\n}\n\nvoid rtw_disassoc_cmd_callback(struct adapter *padapter,  struct cmd_obj *pcmd)\n{\n\tstruct\tmlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (pcmd->res != H2C_SUCCESS) {\n\t\tspin_lock_bh(&pmlmepriv->lock);\n\t\tset_fwstate(pmlmepriv, _FW_LINKED);\n\t\tspin_unlock_bh(&pmlmepriv->lock);\n\n\t\treturn;\n\t}\n\t \n\trtw_free_cmd_obj(pcmd);\n}\n\nvoid rtw_joinbss_cmd_callback(struct adapter *padapter,  struct cmd_obj *pcmd)\n{\n\tstruct\tmlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (pcmd->res != H2C_SUCCESS) {\n\t\t \n\t\t_set_timer(&pmlmepriv->assoc_timer, 1);\n\t}\n\n\trtw_free_cmd_obj(pcmd);\n}\n\nvoid rtw_createbss_cmd_callback(struct adapter *padapter, struct cmd_obj *pcmd)\n{\n\tstruct sta_info *psta = NULL;\n\tstruct wlan_network *pwlan = NULL;\n\tstruct\tmlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct wlan_bssid_ex *pnetwork = (struct wlan_bssid_ex *)pcmd->parmbuf;\n\tstruct wlan_network *tgt_network = &pmlmepriv->cur_network;\n\n\tif (!pcmd->parmbuf)\n\t\tgoto exit;\n\n\tif (pcmd->res != H2C_SUCCESS)\n\t\t_set_timer(&pmlmepriv->assoc_timer, 1);\n\n\tdel_timer_sync(&pmlmepriv->assoc_timer);\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\tpsta = rtw_get_stainfo(&padapter->stapriv, pnetwork->mac_address);\n\t\tif (!psta) {\n\t\t\tpsta = rtw_alloc_stainfo(&padapter->stapriv, pnetwork->mac_address);\n\t\t\tif (!psta)\n\t\t\t\tgoto createbss_cmd_fail;\n\t\t}\n\n\t\trtw_indicate_connect(padapter);\n\t} else {\n\t\tpwlan = rtw_alloc_network(pmlmepriv);\n\t\tspin_lock_bh(&pmlmepriv->scanned_queue.lock);\n\t\tif (!pwlan) {\n\t\t\tpwlan = rtw_get_oldest_wlan_network(&pmlmepriv->scanned_queue);\n\t\t\tif (!pwlan) {\n\t\t\t\tspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\n\t\t\t\tgoto createbss_cmd_fail;\n\t\t\t}\n\t\t\tpwlan->last_scanned = jiffies;\n\t\t} else {\n\t\t\tlist_add_tail(&pwlan->list, &pmlmepriv->scanned_queue.queue);\n\t\t}\n\n\t\tpnetwork->length = get_wlan_bssid_ex_sz(pnetwork);\n\t\tmemcpy(&pwlan->network, pnetwork, pnetwork->length);\n\t\t \n\n\t\t \n\n\t\t \n\t\tmemcpy(&tgt_network->network, pnetwork, (get_wlan_bssid_ex_sz(pnetwork)));\n\n\t\t \n\t\t \n\n\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\n\n\t\tspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\n\t\t \n\n\t}\n\ncreatebss_cmd_fail:\n\n\tspin_unlock_bh(&pmlmepriv->lock);\nexit:\n\trtw_free_cmd_obj(pcmd);\n}\n\nvoid rtw_setstaKey_cmdrsp_callback(struct adapter *padapter,  struct cmd_obj *pcmd)\n{\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct set_stakey_rsp *psetstakey_rsp = (struct set_stakey_rsp *)(pcmd->rsp);\n\tstruct sta_info *psta = rtw_get_stainfo(pstapriv, psetstakey_rsp->addr);\n\n\tif (!psta)\n\t\tgoto exit;\n\nexit:\n\trtw_free_cmd_obj(pcmd);\n}\n\nvoid rtw_setassocsta_cmdrsp_callback(struct adapter *padapter,  struct cmd_obj *pcmd)\n{\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct set_assocsta_parm *passocsta_parm = (struct set_assocsta_parm *)(pcmd->parmbuf);\n\tstruct set_assocsta_rsp *passocsta_rsp = (struct set_assocsta_rsp *)(pcmd->rsp);\n\tstruct sta_info *psta = rtw_get_stainfo(pstapriv, passocsta_parm->addr);\n\n\tif (!psta)\n\t\tgoto exit;\n\n\tpsta->aid = passocsta_rsp->cam_id;\n\tpsta->mac_id = passocsta_rsp->cam_id;\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\n\tif (check_fwstate(pmlmepriv, WIFI_MP_STATE) && check_fwstate(pmlmepriv, _FW_UNDER_LINKING))\n\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\n\n\tset_fwstate(pmlmepriv, _FW_LINKED);\n\tspin_unlock_bh(&pmlmepriv->lock);\n\nexit:\n\trtw_free_cmd_obj(pcmd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}