{
  "module_name": "rtw_ioctl_set.c",
  "hash_id": "150d244455c2155c5599afdc81c7d8c1c34333d1863610d5722d8bca78a14239",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/core/rtw_ioctl_set.c",
  "human_readable_source": "\n \n\n#include <drv_types.h>\n#include <rtw_debug.h>\n\nu8 rtw_validate_bssid(u8 *bssid)\n{\n\tu8 ret = true;\n\n\tif (is_zero_mac_addr(bssid)\n\t\t|| is_broadcast_mac_addr(bssid)\n\t\t|| is_multicast_mac_addr(bssid)\n\t) {\n\t\tret = false;\n\t}\n\n\treturn ret;\n}\n\nu8 rtw_validate_ssid(struct ndis_802_11_ssid *ssid)\n{\n\tu8 ret = true;\n\n\tif (ssid->ssid_length > 32) {\n\t\tret = false;\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn ret;\n}\n\nu8 rtw_do_join(struct adapter *padapter)\n{\n\tstruct list_head\t*plist, *phead;\n\tu8 *pibss = NULL;\n\tstruct\tmlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct __queue\t*queue\t= &(pmlmepriv->scanned_queue);\n\tu8 ret = _SUCCESS;\n\n\tspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\n\tphead = get_list_head(queue);\n\tplist = get_next(phead);\n\n\tpmlmepriv->cur_network.join_res = -2;\n\n\tset_fwstate(pmlmepriv, _FW_UNDER_LINKING);\n\n\tpmlmepriv->pscanned = plist;\n\n\tpmlmepriv->to_join = true;\n\n\tif (list_empty(&queue->queue)) {\n\t\tspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\n\n\t\t \n\t\t \n\n\t\tif (pmlmepriv->LinkDetectInfo.bBusyTraffic == false\n\t\t\t|| rtw_to_roam(padapter) > 0\n\t\t) {\n\t\t\t \n\t\t\tret = rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0);\n\t\t\tif (ret != _SUCCESS)\n\t\t\t\tpmlmepriv->to_join = false;\n\n\t\t} else {\n\t\t\tpmlmepriv->to_join = false;\n\t\t\tret = _FAIL;\n\t\t}\n\n\t\tgoto exit;\n\t} else {\n\t\tint select_ret;\n\n\t\tspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\n\t\tselect_ret = rtw_select_and_join_from_scanned_queue(pmlmepriv);\n\t\tif (select_ret == _SUCCESS) {\n\t\t\tpmlmepriv->to_join = false;\n\t\t\t_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);\n\t\t} else {\n\t\t\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) {\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tstruct wlan_bssid_ex    *pdev_network = &(padapter->registrypriv.dev_network);\n\n\t\t\t\tpmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;\n\n\t\t\t\tpibss = padapter->registrypriv.dev_network.mac_address;\n\n\t\t\t\tmemcpy(&pdev_network->ssid, &pmlmepriv->assoc_ssid, sizeof(struct ndis_802_11_ssid));\n\n\t\t\t\trtw_update_registrypriv_dev_network(padapter);\n\n\t\t\t\trtw_generate_random_ibss(pibss);\n\n\t\t\t\tif (rtw_createbss_cmd(padapter) != _SUCCESS) {\n\t\t\t\t\tret =  false;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tpmlmepriv->to_join = false;\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (pmlmepriv->LinkDetectInfo.bBusyTraffic == false\n\t\t\t\t\t|| rtw_to_roam(padapter) > 0\n\t\t\t\t) {\n\t\t\t\t\tret = rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0);\n\t\t\t\t\tif (ret != _SUCCESS)\n\t\t\t\t\t\tpmlmepriv->to_join = false;\n\n\t\t\t\t} else {\n\t\t\t\t\tret = _FAIL;\n\t\t\t\t\tpmlmepriv->to_join = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\nexit:\n\treturn ret;\n}\n\nu8 rtw_set_802_11_ssid(struct adapter *padapter, struct ndis_802_11_ssid *ssid)\n{\n\tu8 status = _SUCCESS;\n\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct wlan_network *pnetwork = &pmlmepriv->cur_network;\n\n\tnetdev_dbg(padapter->pnetdev, \"set ssid [%s] fw_state = 0x%08x\\n\",\n\t\t   ssid->ssid, get_fwstate(pmlmepriv));\n\n\tif (padapter->hw_init_completed == false) {\n\t\tstatus = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)\n\t\tgoto handle_tkip_countermeasure;\n\telse if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true)\n\t\tgoto release_mlme_lock;\n\n\tif (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true) {\n\t\tif ((pmlmepriv->assoc_ssid.ssid_length == ssid->ssid_length) &&\n\t\t    (!memcmp(&pmlmepriv->assoc_ssid.ssid, ssid->ssid, ssid->ssid_length))) {\n\t\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false) {\n\t\t\t\tif (rtw_is_same_ibss(padapter, pnetwork) == false) {\n\t\t\t\t\t \n\t\t\t\t\trtw_disassoc_cmd(padapter, 0, true);\n\n\t\t\t\t\tif (check_fwstate(pmlmepriv, _FW_LINKED) == true)\n\t\t\t\t\t\trtw_indicate_disconnect(padapter);\n\n\t\t\t\t\trtw_free_assoc_resources(padapter, 1);\n\n\t\t\t\t\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {\n\t\t\t\t\t\t_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);\n\t\t\t\t\t\tset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgoto release_mlme_lock; \n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_JOINBSS, 1);\n\t\t\t}\n\t\t} else {\n\t\t\trtw_disassoc_cmd(padapter, 0, true);\n\n\t\t\tif (check_fwstate(pmlmepriv, _FW_LINKED) == true)\n\t\t\t\trtw_indicate_disconnect(padapter);\n\n\t\t\trtw_free_assoc_resources(padapter, 1);\n\n\t\t\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {\n\t\t\t\t_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);\n\t\t\t\tset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\n\t\t\t}\n\t\t}\n\t}\n\nhandle_tkip_countermeasure:\n\tif (rtw_handle_tkip_countermeasure(padapter, __func__) == _FAIL) {\n\t\tstatus = _FAIL;\n\t\tgoto release_mlme_lock;\n\t}\n\n\tif (rtw_validate_ssid(ssid) == false) {\n\t\tstatus = _FAIL;\n\t\tgoto release_mlme_lock;\n\t}\n\n\tmemcpy(&pmlmepriv->assoc_ssid, ssid, sizeof(struct ndis_802_11_ssid));\n\tpmlmepriv->assoc_by_bssid = false;\n\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)\n\t\tpmlmepriv->to_join = true;\n\telse\n\t\tstatus = rtw_do_join(padapter);\n\nrelease_mlme_lock:\n\tspin_unlock_bh(&pmlmepriv->lock);\n\nexit:\n\n\treturn status;\n}\n\nu8 rtw_set_802_11_connect(struct adapter *padapter, u8 *bssid, struct ndis_802_11_ssid *ssid)\n{\n\tu8 status = _SUCCESS;\n\tbool bssid_valid = true;\n\tbool ssid_valid = true;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (!ssid || rtw_validate_ssid(ssid) == false)\n\t\tssid_valid = false;\n\n\tif (!bssid || rtw_validate_bssid(bssid) == false)\n\t\tbssid_valid = false;\n\n\tif (!ssid_valid && !bssid_valid) {\n\t\tstatus = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tif (padapter->hw_init_completed == false) {\n\t\tstatus = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\n\tnetdev_dbg(padapter->pnetdev, FUNC_ADPT_FMT \"  fw_state = 0x%08x\\n\",\n\t\t   FUNC_ADPT_ARG(padapter), get_fwstate(pmlmepriv));\n\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)\n\t\tgoto handle_tkip_countermeasure;\n\telse if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true)\n\t\tgoto release_mlme_lock;\n\nhandle_tkip_countermeasure:\n\tif (rtw_handle_tkip_countermeasure(padapter, __func__) == _FAIL) {\n\t\tstatus = _FAIL;\n\t\tgoto release_mlme_lock;\n\t}\n\n\tif (ssid && ssid_valid)\n\t\tmemcpy(&pmlmepriv->assoc_ssid, ssid, sizeof(struct ndis_802_11_ssid));\n\telse\n\t\tmemset(&pmlmepriv->assoc_ssid, 0, sizeof(struct ndis_802_11_ssid));\n\n\tif (bssid && bssid_valid) {\n\t\tmemcpy(&pmlmepriv->assoc_bssid, bssid, ETH_ALEN);\n\t\tpmlmepriv->assoc_by_bssid = true;\n\t} else {\n\t\tpmlmepriv->assoc_by_bssid = false;\n\t}\n\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)\n\t\tpmlmepriv->to_join = true;\n\telse\n\t\tstatus = rtw_do_join(padapter);\n\nrelease_mlme_lock:\n\tspin_unlock_bh(&pmlmepriv->lock);\n\nexit:\n\treturn status;\n}\n\nu8 rtw_set_802_11_infrastructure_mode(struct adapter *padapter,\n\tenum ndis_802_11_network_infrastructure networktype)\n{\n\tstruct\tmlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct\twlan_network\t*cur_network = &pmlmepriv->cur_network;\n\tenum ndis_802_11_network_infrastructure *pold_state = &(cur_network->network.infrastructure_mode);\n\n\tif (*pold_state != networktype) {\n\t\tif (*pold_state == Ndis802_11APMode) {\n\t\t\t \n\t\t\tcur_network->join_res = -1;\n\n\t\t\tstop_ap_mode(padapter);\n\t\t}\n\n\t\tspin_lock_bh(&pmlmepriv->lock);\n\n\t\tif ((check_fwstate(pmlmepriv, _FW_LINKED) == true) || (*pold_state == Ndis802_11IBSS))\n\t\t\trtw_disassoc_cmd(padapter, 0, true);\n\n\t\tif ((check_fwstate(pmlmepriv, _FW_LINKED) == true) ||\n\t\t\t(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true))\n\t\t\trtw_free_assoc_resources(padapter, 1);\n\n\t\tif ((*pold_state == Ndis802_11Infrastructure) || (*pold_state == Ndis802_11IBSS)) {\n\t\t\tif (check_fwstate(pmlmepriv, _FW_LINKED) == true)\n\t\t\t\trtw_indicate_disconnect(padapter);  \n\t\t}\n\n\t\t*pold_state = networktype;\n\n\t\t_clr_fwstate_(pmlmepriv, ~WIFI_NULL_STATE);\n\n\t\tswitch (networktype) {\n\t\tcase Ndis802_11IBSS:\n\t\t\tset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\n\t\t\tbreak;\n\n\t\tcase Ndis802_11Infrastructure:\n\t\t\tset_fwstate(pmlmepriv, WIFI_STATION_STATE);\n\t\t\tbreak;\n\n\t\tcase Ndis802_11APMode:\n\t\t\tset_fwstate(pmlmepriv, WIFI_AP_STATE);\n\t\t\tstart_ap_mode(padapter);\n\t\t\t \n\n\t\t\tbreak;\n\n\t\tcase Ndis802_11AutoUnknown:\n\t\tcase Ndis802_11InfrastructureMax:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tspin_unlock_bh(&pmlmepriv->lock);\n\t}\n\treturn true;\n}\n\n\nu8 rtw_set_802_11_disassociate(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\n\tif (check_fwstate(pmlmepriv, _FW_LINKED) == true) {\n\t\trtw_disassoc_cmd(padapter, 0, true);\n\t\trtw_indicate_disconnect(padapter);\n\t\t \n\t\trtw_free_assoc_resources_cmd(padapter);\n\t\trtw_pwr_wakeup(padapter);\n\t}\n\n\tspin_unlock_bh(&pmlmepriv->lock);\n\n\treturn true;\n}\n\nu8 rtw_set_802_11_bssid_list_scan(struct adapter *padapter, struct ndis_802_11_ssid *pssid, int ssid_max_num)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tu8 res = true;\n\n\tif (!padapter) {\n\t\tres = false;\n\t\tgoto exit;\n\t}\n\tif (padapter->hw_init_completed == false) {\n\t\tres = false;\n\t\tgoto exit;\n\t}\n\n\tif ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true) ||\n\t\t(pmlmepriv->LinkDetectInfo.bBusyTraffic == true)) {\n\t\t \n\t\tres = true;\n\n\t} else {\n\t\tif (rtw_is_scan_deny(padapter))\n\t\t\treturn _SUCCESS;\n\n\t\tspin_lock_bh(&pmlmepriv->lock);\n\n\t\tres = rtw_sitesurvey_cmd(padapter, pssid, ssid_max_num, NULL, 0);\n\n\t\tspin_unlock_bh(&pmlmepriv->lock);\n\t}\nexit:\n\n\treturn res;\n}\n\nu8 rtw_set_802_11_authentication_mode(struct adapter *padapter, enum ndis_802_11_authentication_mode authmode)\n{\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tint res;\n\tu8 ret;\n\n\tpsecuritypriv->ndisauthtype = authmode;\n\n\tif (psecuritypriv->ndisauthtype > 3)\n\t\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\n\n\tres = rtw_set_auth(padapter, psecuritypriv);\n\n\tif (res == _SUCCESS)\n\t\tret = true;\n\telse\n\t\tret = false;\n\n\treturn ret;\n}\n\nu8 rtw_set_802_11_add_wep(struct adapter *padapter, struct ndis_802_11_wep *wep)\n{\n\n\tsigned int\t\tkeyid, res;\n\tstruct security_priv *psecuritypriv = &(padapter->securitypriv);\n\tu8 ret = _SUCCESS;\n\n\tkeyid = wep->key_index & 0x3fffffff;\n\n\tif (keyid >= 4) {\n\t\tret = false;\n\t\tgoto exit;\n\t}\n\n\tswitch (wep->key_length) {\n\tcase 5:\n\t\tpsecuritypriv->dot11PrivacyAlgrthm = _WEP40_;\n\t\tbreak;\n\tcase 13:\n\t\tpsecuritypriv->dot11PrivacyAlgrthm = _WEP104_;\n\t\tbreak;\n\tdefault:\n\t\tpsecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;\n\t\tbreak;\n\t}\n\n\tmemcpy(&(psecuritypriv->dot11DefKey[keyid].skey[0]), &(wep->key_material), wep->key_length);\n\n\tpsecuritypriv->dot11DefKeylen[keyid] = wep->key_length;\n\n\tpsecuritypriv->dot11PrivacyKeyIndex = keyid;\n\n\tres = rtw_set_key(padapter, psecuritypriv, keyid, 1, true);\n\n\tif (res == _FAIL)\n\t\tret = false;\nexit:\n\n\treturn ret;\n}\n\n \nu16 rtw_get_cur_max_rate(struct adapter *adapter)\n{\n\tint\ti = 0;\n\tu16 rate = 0, max_rate = 0;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tstruct wlan_bssid_ex\t*pcur_bss = &pmlmepriv->cur_network.network;\n\tstruct sta_info *psta = NULL;\n\tu8 short_GI = 0;\n\n\tif ((check_fwstate(pmlmepriv, _FW_LINKED) != true)\n\t\t&& (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != true))\n\t\treturn 0;\n\n\tpsta = rtw_get_stainfo(&adapter->stapriv, get_bssid(pmlmepriv));\n\tif (!psta)\n\t\treturn 0;\n\n\tshort_GI = query_ra_short_GI(psta);\n\n\tif (is_supported_ht(psta->wireless_mode)) {\n\t\tmax_rate = rtw_mcs_rate(psta->bw_mode == CHANNEL_WIDTH_40 ? 1 : 0,\n\t\t\t\t\tshort_GI,\n\t\t\t\t\tpsta->htpriv.ht_cap.mcs.rx_mask);\n\t} else {\n\t\twhile ((pcur_bss->supported_rates[i] != 0) && (pcur_bss->supported_rates[i] != 0xFF)) {\n\t\t\trate = pcur_bss->supported_rates[i]&0x7F;\n\t\t\tif (rate > max_rate)\n\t\t\t\tmax_rate = rate;\n\t\t\ti++;\n\t\t}\n\n\t\tmax_rate = max_rate*10/2;\n\t}\n\n\treturn max_rate;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}