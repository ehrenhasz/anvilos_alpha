{
  "module_name": "rtw_efuse.c",
  "hash_id": "056ea06b64bbb4c34cf280dad8e85ae8e78576ae4c98b11b58343394ba7cad59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/core/rtw_efuse.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <hal_data.h>\n#include <linux/jiffies.h>\n\n\n \nu8 fakeEfuseBank;\nu32 fakeEfuseUsedBytes;\nu8 fakeEfuseContent[EFUSE_MAX_HW_SIZE] = {0};\nu8 fakeEfuseInitMap[EFUSE_MAX_MAP_LEN] = {0};\nu8 fakeEfuseModifiedMap[EFUSE_MAX_MAP_LEN] = {0};\n\nu32 BTEfuseUsedBytes;\nu8 BTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];\nu8 BTEfuseInitMap[EFUSE_BT_MAX_MAP_LEN] = {0};\nu8 BTEfuseModifiedMap[EFUSE_BT_MAX_MAP_LEN] = {0};\n\nu32 fakeBTEfuseUsedBytes;\nu8 fakeBTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];\nu8 fakeBTEfuseInitMap[EFUSE_BT_MAX_MAP_LEN] = {0};\nu8 fakeBTEfuseModifiedMap[EFUSE_BT_MAX_MAP_LEN] = {0};\n\n#define REG_EFUSE_CTRL\t\t0x0030\n#define EFUSE_CTRL\t\t\tREG_EFUSE_CTRL\t\t \n\nstatic bool\nEfuse_Read1ByteFromFakeContent(u16 Offset, u8 *Value)\n{\n\tif (Offset >= EFUSE_MAX_HW_SIZE)\n\t\treturn false;\n\tif (fakeEfuseBank == 0)\n\t\t*Value = fakeEfuseContent[Offset];\n\telse\n\t\t*Value = fakeBTEfuseContent[fakeEfuseBank-1][Offset];\n\treturn true;\n}\n\nstatic bool\nEfuse_Write1ByteToFakeContent(u16 Offset, u8 Value)\n{\n\tif (Offset >= EFUSE_MAX_HW_SIZE)\n\t\treturn false;\n\tif (fakeEfuseBank == 0)\n\t\tfakeEfuseContent[Offset] = Value;\n\telse\n\t\tfakeBTEfuseContent[fakeEfuseBank-1][Offset] = Value;\n\treturn true;\n}\n\n \nvoid\nEfuse_PowerSwitch(\nstruct adapter *padapter,\nu8 bWrite,\nu8 PwrState)\n{\n\tpadapter->HalFunc.EfusePowerSwitch(padapter, bWrite, PwrState);\n}\n\n \nu16\nEfuse_GetCurrentSize(\n\tstruct adapter *padapter,\n\tu8\tefuseType,\n\tbool\t\tbPseudoTest)\n{\n\treturn padapter->HalFunc.EfuseGetCurrentSize(padapter, efuseType,\n\t\t\t\t\t\t     bPseudoTest);\n}\n\n \nu8\nEfuse_CalculateWordCnts(u8 word_en)\n{\n\tu8 word_cnts = 0;\n\tif (!(word_en & BIT(0)))\n\t\tword_cnts++;  \n\tif (!(word_en & BIT(1)))\n\t\tword_cnts++;\n\tif (!(word_en & BIT(2)))\n\t\tword_cnts++;\n\tif (!(word_en & BIT(3)))\n\t\tword_cnts++;\n\treturn word_cnts;\n}\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\nvoid\nefuse_ReadEFuse(\n\tstruct adapter *Adapter,\n\tu8 efuseType,\n\tu16\t\t_offset,\n\tu16\t\t_size_byte,\n\tu8 *pbuf,\nbool\tbPseudoTest\n\t);\nvoid\nefuse_ReadEFuse(\n\tstruct adapter *Adapter,\n\tu8 efuseType,\n\tu16\t\t_offset,\n\tu16\t\t_size_byte,\n\tu8 *pbuf,\nbool\tbPseudoTest\n\t)\n{\n\tAdapter->HalFunc.ReadEFuse(Adapter, efuseType, _offset, _size_byte, pbuf, bPseudoTest);\n}\n\nvoid\nEFUSE_GetEfuseDefinition(\n\tstruct adapter *padapter,\n\tu8 efuseType,\n\tu8 type,\n\tvoid\t*pOut,\n\tbool\t\tbPseudoTest\n\t)\n{\n\tpadapter->HalFunc.EFUSEGetEfuseDefinition(padapter, efuseType, type, pOut, bPseudoTest);\n}\n\n \nu8\nEFUSE_Read1Byte(\nstruct adapter *Adapter,\nu16\t\tAddress)\n{\n\tu8 Bytetemp = {0x00};\n\tu8 temp = {0x00};\n\tu32 k = 0;\n\tu16 contentLen = 0;\n\n\tEFUSE_GetEfuseDefinition(Adapter, EFUSE_WIFI, TYPE_EFUSE_REAL_CONTENT_LEN, (void *)&contentLen, false);\n\n\tif (Address < contentLen) { \n\t\t \n\t\ttemp = Address & 0xFF;\n\t\trtw_write8(Adapter, EFUSE_CTRL+1, temp);\n\t\tBytetemp = rtw_read8(Adapter, EFUSE_CTRL+2);\n\t\t \n\t\ttemp = ((Address >> 8) & 0x03) | (Bytetemp & 0xFC);\n\t\trtw_write8(Adapter, EFUSE_CTRL+2, temp);\n\n\t\t \n\t\tBytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);\n\t\ttemp = Bytetemp & 0x7F;\n\t\trtw_write8(Adapter, EFUSE_CTRL+3, temp);\n\n\t\t \n\t\tBytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);\n\t\twhile (!(Bytetemp & 0x80)) {\n\t\t\tBytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);\n\t\t\tk++;\n\t\t\tif (k == 1000)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn rtw_read8(Adapter, EFUSE_CTRL);\n\t} else\n\t\treturn 0xFF;\n\n}  \n\n \nu8\nefuse_OneByteRead(\nstruct adapter *padapter,\nu16\taddr,\nu8\t*data,\nbool\t\tbPseudoTest)\n{\n\tu32 tmpidx = 0;\n\tu8 bResult;\n\tu8 readbyte;\n\n\tif (bPseudoTest)\n\t\treturn Efuse_Read1ByteFromFakeContent(addr, data);\n\n\t \n\t \n\t \n\trtw_write16(padapter, 0x34, rtw_read16(padapter, 0x34) & (~BIT11));\n\n\t \n\t \n\trtw_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xff));\n\trtw_write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8) & 0x03)) |\n\t(rtw_read8(padapter, EFUSE_CTRL+2)&0xFC));\n\n\t \n\t \n\treadbyte = rtw_read8(padapter, EFUSE_CTRL+3);\n\trtw_write8(padapter, EFUSE_CTRL+3, (readbyte & 0x7f));\n\n\twhile (!(0x80 & rtw_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 1000)) {\n\t\tmdelay(1);\n\t\ttmpidx++;\n\t}\n\tif (tmpidx < 100) {\n\t\t*data = rtw_read8(padapter, EFUSE_CTRL);\n\t\tbResult = true;\n\t} else {\n\t\t*data = 0xff;\n\t\tbResult = false;\n\t}\n\n\treturn bResult;\n}\n\n \nu8 efuse_OneByteWrite(struct adapter *padapter, u16 addr, u8 data, bool bPseudoTest)\n{\n\tu8 tmpidx = 0;\n\tu8 bResult = false;\n\tu32 efuseValue;\n\n\tif (bPseudoTest)\n\t\treturn Efuse_Write1ByteToFakeContent(addr, data);\n\n\n\t \n\t \n\n\n\tefuseValue = rtw_read32(padapter, EFUSE_CTRL);\n\tefuseValue |= (BIT21|BIT31);\n\tefuseValue &= ~(0x3FFFF);\n\tefuseValue |= ((addr<<8 | data) & 0x3FFFF);\n\n\n\t \n\n\t \n\t \n\t \n\trtw_write16(padapter, 0x34, rtw_read16(padapter, 0x34) | (BIT11));\n\trtw_write32(padapter, EFUSE_CTRL, 0x90600000|((addr<<8 | data)));\n\n\twhile ((0x80 &  rtw_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100)) {\n\t\tmdelay(1);\n\t\ttmpidx++;\n\t}\n\n\tif (tmpidx < 100)\n\t\tbResult = true;\n\telse\n\t\tbResult = false;\n\n\t \n\tPHY_SetMacReg(padapter, EFUSE_TEST, BIT(11), 0);\n\n\treturn bResult;\n}\n\nint\nEfuse_PgPacketRead(struct adapter *padapter,\n\t\t\t\tu8\toffset,\n\t\t\t\tu8\t*data,\n\t\t\t\tbool\t\tbPseudoTest)\n{\n\treturn padapter->HalFunc.Efuse_PgPacketRead(padapter, offset, data,\n\t\t\t\t\t\t    bPseudoTest);\n}\n\nint\nEfuse_PgPacketWrite(struct adapter *padapter,\n\t\t\t\tu8\toffset,\n\t\t\t\tu8\tword_en,\n\t\t\t\tu8\t*data,\n\t\t\t\tbool\t\tbPseudoTest)\n{\n\treturn padapter->HalFunc.Efuse_PgPacketWrite(padapter, offset, word_en,\n\t\t\t\t\t\t     data, bPseudoTest);\n}\n\n \nvoid\nefuse_WordEnableDataRead(u8 word_en,\n\t\t\t\t\t\tu8 *sourdata,\n\t\t\t\t\t\tu8 *targetdata)\n{\n\tif (!(word_en&BIT(0))) {\n\t\ttargetdata[0] = sourdata[0];\n\t\ttargetdata[1] = sourdata[1];\n\t}\n\tif (!(word_en&BIT(1))) {\n\t\ttargetdata[2] = sourdata[2];\n\t\ttargetdata[3] = sourdata[3];\n\t}\n\tif (!(word_en&BIT(2))) {\n\t\ttargetdata[4] = sourdata[4];\n\t\ttargetdata[5] = sourdata[5];\n\t}\n\tif (!(word_en&BIT(3))) {\n\t\ttargetdata[6] = sourdata[6];\n\t\ttargetdata[7] = sourdata[7];\n\t}\n}\n\n\nu8\nEfuse_WordEnableDataWrite(struct adapter *padapter,\n\t\t\t\t\t\tu16\t\tefuse_addr,\n\t\t\t\t\t\tu8 word_en,\n\t\t\t\t\t\tu8 *data,\n\t\t\t\t\t\tbool\t\tbPseudoTest)\n{\n\treturn padapter->HalFunc.Efuse_WordEnableDataWrite(padapter, efuse_addr,\n\t\t\t\t\t\t\t   word_en, data,\n\t\t\t\t\t\t\t   bPseudoTest);\n}\n\n \nvoid\nEfuse_ReadAllMap(\n\tstruct adapter *padapter,\n\tu8 efuseType,\n\tu8 *Efuse,\n\tbool\t\tbPseudoTest);\nvoid Efuse_ReadAllMap(struct adapter *padapter, u8 efuseType, u8 *Efuse, bool bPseudoTest)\n{\n\tu16 mapLen = 0;\n\n\tEfuse_PowerSwitch(padapter, false, true);\n\n\tEFUSE_GetEfuseDefinition(padapter, efuseType, TYPE_EFUSE_MAP_LEN, (void *)&mapLen, bPseudoTest);\n\n\tefuse_ReadEFuse(padapter, efuseType, 0, mapLen, Efuse, bPseudoTest);\n\n\tEfuse_PowerSwitch(padapter, false, false);\n}\n\n \nstatic void efuse_ShadowRead1Byte(struct adapter *padapter, u16 Offset, u8 *Value)\n{\n\tstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\n\n\t*Value = pEEPROM->efuse_eeprom_data[Offset];\n\n}\t \n\n \nstatic void efuse_ShadowRead2Byte(struct adapter *padapter, u16 Offset, u16 *Value)\n{\n\tstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\n\n\t*Value = pEEPROM->efuse_eeprom_data[Offset];\n\t*Value |= pEEPROM->efuse_eeprom_data[Offset+1]<<8;\n\n}\t \n\n \nstatic void efuse_ShadowRead4Byte(struct adapter *padapter, u16 Offset, u32 *Value)\n{\n\tstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\n\n\t*Value = pEEPROM->efuse_eeprom_data[Offset];\n\t*Value |= pEEPROM->efuse_eeprom_data[Offset+1]<<8;\n\t*Value |= pEEPROM->efuse_eeprom_data[Offset+2]<<16;\n\t*Value |= pEEPROM->efuse_eeprom_data[Offset+3]<<24;\n\n}\t \n\n \nvoid EFUSE_ShadowMapUpdate(struct adapter *padapter, u8 efuseType, bool bPseudoTest)\n{\n\tstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\n\tu16 mapLen = 0;\n\n\tEFUSE_GetEfuseDefinition(padapter, efuseType, TYPE_EFUSE_MAP_LEN, (void *)&mapLen, bPseudoTest);\n\n\tif (pEEPROM->bautoload_fail_flag)\n\t\tmemset(pEEPROM->efuse_eeprom_data, 0xFF, mapLen);\n\telse\n\t\tEfuse_ReadAllMap(padapter, efuseType, pEEPROM->efuse_eeprom_data, bPseudoTest);\n\n\t \n\t \n}  \n\n\n \nvoid EFUSE_ShadowRead(struct adapter *padapter, u8 Type, u16 Offset, u32 *Value)\n{\n\tif (Type == 1)\n\t\tefuse_ShadowRead1Byte(padapter, Offset, (u8 *)Value);\n\telse if (Type == 2)\n\t\tefuse_ShadowRead2Byte(padapter, Offset, (u16 *)Value);\n\telse if (Type == 4)\n\t\tefuse_ShadowRead4Byte(padapter, Offset, (u32 *)Value);\n\n}\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}