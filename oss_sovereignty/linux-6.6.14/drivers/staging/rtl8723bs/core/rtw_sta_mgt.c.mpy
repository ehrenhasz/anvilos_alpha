{
  "module_name": "rtw_sta_mgt.c",
  "hash_id": "e3eec7362d7f14a9d25ccf1fcd9f6b91b672120daa73747b679a94251f730906",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/core/rtw_sta_mgt.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n\nvoid _rtw_init_stainfo(struct sta_info *psta);\nvoid _rtw_init_stainfo(struct sta_info *psta)\n{\n\tmemset((u8 *)psta, 0, sizeof(struct sta_info));\n\n\tspin_lock_init(&psta->lock);\n\tINIT_LIST_HEAD(&psta->list);\n\tINIT_LIST_HEAD(&psta->hash_list);\n\t \n\t \n\t \n\n\tINIT_LIST_HEAD(&psta->sleep_q.queue);\n\tspin_lock_init(&psta->sleep_q.lock);\n\tpsta->sleepq_len = 0;\n\n\t_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);\n\t_rtw_init_sta_recv_priv(&psta->sta_recvpriv);\n\n\tINIT_LIST_HEAD(&psta->asoc_list);\n\n\tINIT_LIST_HEAD(&psta->auth_list);\n\n\tpsta->expire_to = 0;\n\n\tpsta->flags = 0;\n\n\tpsta->capability = 0;\n\n\tpsta->bpairwise_key_installed = false;\n\n\tpsta->nonerp_set = 0;\n\tpsta->no_short_slot_time_set = 0;\n\tpsta->no_short_preamble_set = 0;\n\tpsta->no_ht_gf_set = 0;\n\tpsta->no_ht_set = 0;\n\tpsta->ht_20mhz_set = 0;\n\n\tpsta->under_exist_checking = 0;\n\n\tpsta->keep_alive_trycnt = 0;\n}\n\nu32 _rtw_init_sta_priv(struct\tsta_priv *pstapriv)\n{\n\tstruct sta_info *psta;\n\ts32 i;\n\n\tpstapriv->pallocated_stainfo_buf = vzalloc(sizeof(struct sta_info) * NUM_STA+4);\n\n\tif (!pstapriv->pallocated_stainfo_buf)\n\t\treturn _FAIL;\n\n\tpstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 -\n\t\t((SIZE_PTR)(pstapriv->pallocated_stainfo_buf) & 3);\n\n\tINIT_LIST_HEAD(&pstapriv->free_sta_queue.queue);\n\tspin_lock_init(&pstapriv->free_sta_queue.lock);\n\n\tspin_lock_init(&pstapriv->sta_hash_lock);\n\n\t \n\tpstapriv->asoc_sta_count = 0;\n\tINIT_LIST_HEAD(&pstapriv->sleep_q.queue);\n\tspin_lock_init(&pstapriv->sleep_q.lock);\n\tINIT_LIST_HEAD(&pstapriv->wakeup_q.queue);\n\tspin_lock_init(&pstapriv->wakeup_q.lock);\n\n\tpsta = (struct sta_info *)(pstapriv->pstainfo_buf);\n\n\tfor (i = 0; i < NUM_STA; i++) {\n\t\t_rtw_init_stainfo(psta);\n\n\t\tINIT_LIST_HEAD(&(pstapriv->sta_hash[i]));\n\n\t\tlist_add_tail(&psta->list, get_list_head(&pstapriv->free_sta_queue));\n\n\t\tpsta++;\n\t}\n\n\tpstapriv->sta_dz_bitmap = 0;\n\tpstapriv->tim_bitmap = 0;\n\n\tINIT_LIST_HEAD(&pstapriv->asoc_list);\n\tINIT_LIST_HEAD(&pstapriv->auth_list);\n\tspin_lock_init(&pstapriv->asoc_list_lock);\n\tspin_lock_init(&pstapriv->auth_list_lock);\n\tpstapriv->asoc_list_cnt = 0;\n\tpstapriv->auth_list_cnt = 0;\n\n\tpstapriv->auth_to = 3;  \n\tpstapriv->assoc_to = 3;\n\tpstapriv->expire_to = 3;  \n\tpstapriv->max_num_sta = NUM_STA;\n\treturn _SUCCESS;\n}\n\ninline int rtw_stainfo_offset(struct sta_priv *stapriv, struct sta_info *sta)\n{\n\tint offset = (((u8 *)sta) - stapriv->pstainfo_buf)/sizeof(struct sta_info);\n\n\treturn offset;\n}\n\ninline struct sta_info *rtw_get_stainfo_by_offset(struct sta_priv *stapriv, int offset)\n{\n\treturn (struct sta_info *)(stapriv->pstainfo_buf + offset * sizeof(struct sta_info));\n}\n\n \nvoid kfree_all_stainfo(struct sta_priv *pstapriv);\nvoid kfree_all_stainfo(struct sta_priv *pstapriv)\n{\n\tstruct list_head\t*plist, *phead;\n\n\tspin_lock_bh(&pstapriv->sta_hash_lock);\n\n\tphead = get_list_head(&pstapriv->free_sta_queue);\n\tplist = get_next(phead);\n\n\twhile (phead != plist) {\n\t\tplist = get_next(plist);\n\t}\n\n\tspin_unlock_bh(&pstapriv->sta_hash_lock);\n}\n\nvoid kfree_sta_priv_lock(struct\tsta_priv *pstapriv);\nvoid kfree_sta_priv_lock(struct\tsta_priv *pstapriv)\n{\n\t kfree_all_stainfo(pstapriv);  \n}\n\nu32 _rtw_free_sta_priv(struct\tsta_priv *pstapriv)\n{\n\tstruct list_head\t*phead, *plist;\n\tstruct sta_info *psta = NULL;\n\tstruct recv_reorder_ctrl *preorder_ctrl;\n\tint\tindex;\n\n\tif (pstapriv) {\n\t\t \n\t\tspin_lock_bh(&pstapriv->sta_hash_lock);\n\t\tfor (index = 0; index < NUM_STA; index++) {\n\t\t\tphead = &(pstapriv->sta_hash[index]);\n\t\t\tlist_for_each(plist, phead) {\n\t\t\t\tint i;\n\n\t\t\t\tpsta = list_entry(plist, struct sta_info,\n\t\t\t\t\t\t  hash_list);\n\n\t\t\t\tfor (i = 0; i < 16 ; i++) {\n\t\t\t\t\tpreorder_ctrl = &psta->recvreorder_ctrl[i];\n\t\t\t\t\tdel_timer_sync(&preorder_ctrl->reordering_ctrl_timer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&pstapriv->sta_hash_lock);\n\t\t \n\n\t\tkfree_sta_priv_lock(pstapriv);\n\n\t\tvfree(pstapriv->pallocated_stainfo_buf);\n\t}\n\treturn _SUCCESS;\n}\n\n \nstruct\tsta_info *rtw_alloc_stainfo(struct\tsta_priv *pstapriv, u8 *hwaddr)\n{\n\ts32\tindex;\n\tstruct list_head\t*phash_list;\n\tstruct sta_info *psta;\n\tstruct __queue *pfree_sta_queue;\n\tstruct recv_reorder_ctrl *preorder_ctrl;\n\tint i = 0;\n\tu16  wRxSeqInitialValue = 0xffff;\n\n\tpfree_sta_queue = &pstapriv->free_sta_queue;\n\n\t \n\tspin_lock_bh(&(pstapriv->sta_hash_lock));\n\tif (list_empty(&pfree_sta_queue->queue)) {\n\t\t \n\t\tspin_unlock_bh(&(pstapriv->sta_hash_lock));\n\t\treturn NULL;\n\t} else {\n\t\tpsta = container_of(get_next(&pfree_sta_queue->queue), struct sta_info, list);\n\n\t\tlist_del_init(&(psta->list));\n\n\t\t \n\n\t\t_rtw_init_stainfo(psta);\n\n\t\tpsta->padapter = pstapriv->padapter;\n\n\t\tmemcpy(psta->hwaddr, hwaddr, ETH_ALEN);\n\n\t\tindex = wifi_mac_hash(hwaddr);\n\n\t\tif (index >= NUM_STA) {\n\t\t\tspin_unlock_bh(&(pstapriv->sta_hash_lock));\n\t\t\tpsta = NULL;\n\t\t\tgoto exit;\n\t\t}\n\t\tphash_list = &(pstapriv->sta_hash[index]);\n\n\t\t \n\n\t\tlist_add_tail(&psta->hash_list, phash_list);\n\n\t\tpstapriv->asoc_sta_count++;\n\n\t\t \n\n \n \n \n \n\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tmemcpy(&psta->sta_recvpriv.rxcache.tid_rxseq[i], &wRxSeqInitialValue, 2);\n\n\t\tinit_addba_retry_timer(pstapriv->padapter, psta);\n\n\t\t \n\t\tfor (i = 0; i < 16 ; i++) {\n\t\t\tpreorder_ctrl = &psta->recvreorder_ctrl[i];\n\n\t\t\tpreorder_ctrl->padapter = pstapriv->padapter;\n\n\t\t\tpreorder_ctrl->enable = false;\n\n\t\t\tpreorder_ctrl->indicate_seq = 0xffff;\n\t\t\tpreorder_ctrl->wend_b = 0xffff;\n\t\t\t \n\t\t\tpreorder_ctrl->wsize_b = 64; \n\n\t\t\tINIT_LIST_HEAD(&preorder_ctrl->pending_recvframe_queue.queue);\n\t\t\tspin_lock_init(&preorder_ctrl->pending_recvframe_queue.lock);\n\n\t\t\trtw_init_recv_timer(preorder_ctrl);\n\t\t}\n\n\t\t \n\t\tpsta->rssi_stat.UndecoratedSmoothedPWDB = (-1);\n\t\tpsta->rssi_stat.UndecoratedSmoothedCCK = (-1);\n\n\t\t \n\t\tpsta->RxMgmtFrameSeqNum = 0xffff;\n\t\tspin_unlock_bh(&(pstapriv->sta_hash_lock));\n\t\t \n\t\trtw_alloc_macid(pstapriv->padapter, psta);\n\t}\n\nexit:\n\n\treturn psta;\n}\n\nu32 rtw_free_stainfo(struct adapter *padapter, struct sta_info *psta)\n{\n\tint i;\n\tstruct __queue *pfree_sta_queue;\n\tstruct recv_reorder_ctrl *preorder_ctrl;\n\tstruct\tsta_xmit_priv *pstaxmitpriv;\n\tstruct\txmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct\tsta_priv *pstapriv = &padapter->stapriv;\n\tstruct hw_xmit *phwxmit;\n\n\tif (!psta)\n\t\tgoto exit;\n\n\tspin_lock_bh(&psta->lock);\n\tpsta->state &= ~_FW_LINKED;\n\tspin_unlock_bh(&psta->lock);\n\n\tpfree_sta_queue = &pstapriv->free_sta_queue;\n\n\tpstaxmitpriv = &psta->sta_xmitpriv;\n\n\t \n\n\t \n\n\tspin_lock_bh(&pxmitpriv->lock);\n\n\trtw_free_xmitframe_queue(pxmitpriv, &psta->sleep_q);\n\tpsta->sleepq_len = 0;\n\n\t \n\t \n\trtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);\n\tlist_del_init(&(pstaxmitpriv->vo_q.tx_pending));\n\tphwxmit = pxmitpriv->hwxmits;\n\tphwxmit->accnt -= pstaxmitpriv->vo_q.qcnt;\n\tpstaxmitpriv->vo_q.qcnt = 0;\n\t \n\n\t \n\t \n\trtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);\n\tlist_del_init(&(pstaxmitpriv->vi_q.tx_pending));\n\tphwxmit = pxmitpriv->hwxmits+1;\n\tphwxmit->accnt -= pstaxmitpriv->vi_q.qcnt;\n\tpstaxmitpriv->vi_q.qcnt = 0;\n\t \n\n\t \n\t \n\trtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->be_q.sta_pending);\n\tlist_del_init(&(pstaxmitpriv->be_q.tx_pending));\n\tphwxmit = pxmitpriv->hwxmits+2;\n\tphwxmit->accnt -= pstaxmitpriv->be_q.qcnt;\n\tpstaxmitpriv->be_q.qcnt = 0;\n\t \n\n\t \n\t \n\trtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);\n\tlist_del_init(&(pstaxmitpriv->bk_q.tx_pending));\n\tphwxmit = pxmitpriv->hwxmits+3;\n\tphwxmit->accnt -= pstaxmitpriv->bk_q.qcnt;\n\tpstaxmitpriv->bk_q.qcnt = 0;\n\t \n\n\tspin_unlock_bh(&pxmitpriv->lock);\n\n\tspin_lock_bh(&pstapriv->sta_hash_lock);\n\tlist_del_init(&psta->hash_list);\n\tpstapriv->asoc_sta_count--;\n\tspin_unlock_bh(&pstapriv->sta_hash_lock);\n\n\t \n\t \n\t \n\n\tdel_timer_sync(&psta->addba_retry_timer);\n\n\t \n\tfor (i = 0; i < 16 ; i++) {\n\t\tstruct list_head\t*phead, *plist;\n\t\tunion recv_frame *prframe;\n\t\tstruct __queue *ppending_recvframe_queue;\n\t\tstruct __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;\n\n\t\tpreorder_ctrl = &psta->recvreorder_ctrl[i];\n\n\t\tdel_timer_sync(&preorder_ctrl->reordering_ctrl_timer);\n\n\t\tppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;\n\n\t\tspin_lock_bh(&ppending_recvframe_queue->lock);\n\n\t\tphead =\t\tget_list_head(ppending_recvframe_queue);\n\t\tplist = get_next(phead);\n\n\t\twhile (!list_empty(phead)) {\n\t\t\tprframe = (union recv_frame *)plist;\n\n\t\t\tplist = get_next(plist);\n\n\t\t\tlist_del_init(&(prframe->u.hdr.list));\n\n\t\t\trtw_free_recvframe(prframe, pfree_recv_queue);\n\t\t}\n\n\t\tspin_unlock_bh(&ppending_recvframe_queue->lock);\n\t}\n\n\tif (!(psta->state & WIFI_AP_STATE))\n\t\trtw_hal_set_odm_var(padapter, HAL_ODM_STA_INFO, psta, false);\n\n\t \n\trtw_release_macid(pstapriv->padapter, psta);\n\n \n\tspin_lock_bh(&pstapriv->auth_list_lock);\n\tif (!list_empty(&psta->auth_list)) {\n\t\tlist_del_init(&psta->auth_list);\n\t\tpstapriv->auth_list_cnt--;\n\t}\n\tspin_unlock_bh(&pstapriv->auth_list_lock);\n\n\tpsta->expire_to = 0;\n\tpsta->sleepq_ac_len = 0;\n\tpsta->qos_info = 0;\n\n\tpsta->max_sp_len = 0;\n\tpsta->uapsd_bk = 0;\n\tpsta->uapsd_be = 0;\n\tpsta->uapsd_vi = 0;\n\tpsta->uapsd_vo = 0;\n\n\tpsta->has_legacy_ac = 0;\n\n\tpstapriv->sta_dz_bitmap &= ~BIT(psta->aid);\n\tpstapriv->tim_bitmap &= ~BIT(psta->aid);\n\n\tif ((psta->aid > 0) && (pstapriv->sta_aid[psta->aid - 1] == psta)) {\n\t\tpstapriv->sta_aid[psta->aid - 1] = NULL;\n\t\tpsta->aid = 0;\n\t}\n\n\tpsta->under_exist_checking = 0;\n\n\t \n\tlist_add_tail(&psta->list, get_list_head(pfree_sta_queue));\n\t \n\nexit:\n\treturn _SUCCESS;\n}\n\n \nvoid rtw_free_all_stainfo(struct adapter *padapter)\n{\n\tstruct list_head *plist, *phead, *tmp;\n\ts32\tindex;\n\tstruct sta_info *psta = NULL;\n\tstruct\tsta_priv *pstapriv = &padapter->stapriv;\n\tstruct sta_info *pbcmc_stainfo = rtw_get_bcmc_stainfo(padapter);\n\tLIST_HEAD(stainfo_free_list);\n\n\tif (pstapriv->asoc_sta_count == 1)\n\t\treturn;\n\n\tspin_lock_bh(&pstapriv->sta_hash_lock);\n\n\tfor (index = 0; index < NUM_STA; index++) {\n\t\tphead = &(pstapriv->sta_hash[index]);\n\t\tlist_for_each_safe(plist, tmp, phead) {\n\t\t\tpsta = list_entry(plist, struct sta_info, hash_list);\n\n\t\t\tif (pbcmc_stainfo != psta)\n\t\t\t\tlist_move(&psta->hash_list, &stainfo_free_list);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&pstapriv->sta_hash_lock);\n\n\tlist_for_each_safe(plist, tmp, &stainfo_free_list) {\n\t\tpsta = list_entry(plist, struct sta_info, hash_list);\n\t\trtw_free_stainfo(padapter, psta);\n\t}\n}\n\n \nstruct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)\n{\n\tstruct list_head\t*plist, *phead;\n\tstruct sta_info *psta = NULL;\n\tu32 index;\n\tu8 *addr;\n\tu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n\tif (!hwaddr)\n\t\treturn NULL;\n\n\tif (is_multicast_ether_addr(hwaddr))\n\t\taddr = bc_addr;\n\telse\n\t\taddr = hwaddr;\n\n\tindex = wifi_mac_hash(addr);\n\n\tspin_lock_bh(&pstapriv->sta_hash_lock);\n\n\tphead = &(pstapriv->sta_hash[index]);\n\tlist_for_each(plist, phead) {\n\t\tpsta = list_entry(plist, struct sta_info, hash_list);\n\n\t\tif ((!memcmp(psta->hwaddr, addr, ETH_ALEN)))\n\t\t  \n\t\t\tbreak;\n\n\t\tpsta = NULL;\n\t}\n\n\tspin_unlock_bh(&pstapriv->sta_hash_lock);\n\treturn psta;\n}\n\nu32 rtw_init_bcmc_stainfo(struct adapter *padapter)\n{\n\tstruct sta_info *psta;\n\tNDIS_802_11_MAC_ADDRESS\tbcast_addr = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n\tstruct\tsta_priv *pstapriv = &padapter->stapriv;\n\t \n\n\tpsta = rtw_alloc_stainfo(pstapriv, bcast_addr);\n\n\tif (!psta)\n\t\treturn _FAIL;\n\n\t \n\tpsta->mac_id = 1;\n\n\treturn _SUCCESS;\n}\n\nstruct sta_info *rtw_get_bcmc_stainfo(struct adapter *padapter)\n{\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n\treturn rtw_get_stainfo(pstapriv, bc_addr);\n}\n\nu8 rtw_access_ctrl(struct adapter *padapter, u8 *mac_addr)\n{\n\tbool res = true;\n\tstruct list_head\t*plist, *phead;\n\tstruct rtw_wlan_acl_node *paclnode;\n\tbool match = false;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\n\tstruct __queue\t*pacl_node_q = &pacl_list->acl_node_q;\n\n\tspin_lock_bh(&(pacl_node_q->lock));\n\tphead = get_list_head(pacl_node_q);\n\tlist_for_each(plist, phead) {\n\t\tpaclnode = list_entry(plist, struct rtw_wlan_acl_node, list);\n\n\t\tif (!memcmp(paclnode->addr, mac_addr, ETH_ALEN))\n\t\t\tif (paclnode->valid == true) {\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tspin_unlock_bh(&(pacl_node_q->lock));\n\n\tif (pacl_list->mode == 1)  \n\t\tres = !match;\n\n\telse if (pacl_list->mode == 2) \n\t\tres = match;\n\telse\n\t\tres = true;\n\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}