{
  "module_name": "rtw_ap.c",
  "hash_id": "71bbd7ce8c04a3d24df9e9feb358eba4579345e7515b5919098db50c636af0d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/core/rtw_ap.c",
  "human_readable_source": "\n \n\n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <asm/unaligned.h>\n\nvoid init_mlme_ap_info(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\n\n\tspin_lock_init(&pmlmepriv->bcn_update_lock);\n\n\t \n\tINIT_LIST_HEAD(&pacl_list->acl_node_q.queue);\n\tspin_lock_init(&pacl_list->acl_node_q.lock);\n\n\t \n\n\tstart_ap_mode(padapter);\n}\n\nvoid free_mlme_ap_info(struct adapter *padapter)\n{\n\tstruct sta_info *psta = NULL;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\n\n\t \n\n\tpmlmepriv->update_bcn = false;\n\tpmlmeext->bstart_bss = false;\n\n\trtw_sta_flush(padapter);\n\n\tpmlmeinfo->state = _HW_STATE_NOLINK_;\n\n\t \n\trtw_free_all_stainfo(padapter);\n\n\t \n\tpsta = rtw_get_bcmc_stainfo(padapter);\n\trtw_free_stainfo(padapter, psta);\n}\n\nstatic void update_BCNTIM(struct adapter *padapter)\n{\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\n\tstruct wlan_bssid_ex *pnetwork_mlmeext = &pmlmeinfo->network;\n\tunsigned char *pie = pnetwork_mlmeext->ies;\n\n\t \n\tu8 *p, *dst_ie, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;\n\t__le16 tim_bitmap_le;\n\tuint offset, tmp_len, tim_ielen, tim_ie_offset, remainder_ielen;\n\n\ttim_bitmap_le = cpu_to_le16(pstapriv->tim_bitmap);\n\n\tp = rtw_get_ie(pie + _FIXED_IE_LENGTH_,\n\t\t       WLAN_EID_TIM,\n\t\t       &tim_ielen,\n\t\t       pnetwork_mlmeext->ie_length - _FIXED_IE_LENGTH_\n\t);\n\tif (p && tim_ielen > 0) {\n\t\ttim_ielen += 2;\n\n\t\tpremainder_ie = p + tim_ielen;\n\n\t\ttim_ie_offset = (signed int)(p - pie);\n\n\t\tremainder_ielen = pnetwork_mlmeext->ie_length - tim_ie_offset - tim_ielen;\n\n\t\t \n\t\tdst_ie = p;\n\t} else {\n\t\ttim_ielen = 0;\n\n\t\t \n\t\toffset = _FIXED_IE_LENGTH_;\n\n\t\t \n\t\tp = rtw_get_ie(pie + _BEACON_IE_OFFSET_,\n\t\t\t       WLAN_EID_SSID,\n\t\t\t       &tmp_len,\n\t\t\t       (pnetwork_mlmeext->ie_length - _BEACON_IE_OFFSET_)\n\t\t);\n\t\tif (p)\n\t\t\toffset += tmp_len + 2;\n\n\t\t \n\t\tp = rtw_get_ie(pie + _BEACON_IE_OFFSET_,\n\t\t\t       WLAN_EID_SUPP_RATES, &tmp_len,\n\t\t\t       (pnetwork_mlmeext->ie_length - _BEACON_IE_OFFSET_)\n\t\t);\n\t\tif (p)\n\t\t\toffset += tmp_len + 2;\n\n\t\t \n\t\toffset += 3;\n\n\t\tpremainder_ie = pie + offset;\n\n\t\tremainder_ielen = pnetwork_mlmeext->ie_length - offset - tim_ielen;\n\n\t\t \n\t\tdst_ie = pie + offset;\n\t}\n\n\tif (remainder_ielen > 0) {\n\t\tpbackup_remainder_ie = rtw_malloc(remainder_ielen);\n\t\tif (pbackup_remainder_ie && premainder_ie)\n\t\t\tmemcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);\n\t}\n\n\t*dst_ie++ = WLAN_EID_TIM;\n\n\tif ((pstapriv->tim_bitmap & 0xff00) && (pstapriv->tim_bitmap & 0x00fe))\n\t\ttim_ielen = 5;\n\telse\n\t\ttim_ielen = 4;\n\n\t*dst_ie++ = tim_ielen;\n\n\t*dst_ie++ = 0; \n\t*dst_ie++ = 1; \n\n\tif (pstapriv->tim_bitmap & BIT(0)) \n\t\t*dst_ie++ = BIT(0); \n\telse\n\t\t*dst_ie++ = 0;\n\n\tif (tim_ielen == 4) {\n\t\t__le16 pvb;\n\n\t\tif (pstapriv->tim_bitmap & 0xff00)\n\t\t\tpvb = cpu_to_le16(pstapriv->tim_bitmap >> 8);\n\t\telse\n\t\t\tpvb = tim_bitmap_le;\n\n\t\t*dst_ie++ = le16_to_cpu(pvb);\n\n\t} else if (tim_ielen == 5) {\n\t\tmemcpy(dst_ie, &tim_bitmap_le, 2);\n\t\tdst_ie += 2;\n\t}\n\n\t \n\tif (pbackup_remainder_ie) {\n\t\tmemcpy(dst_ie, pbackup_remainder_ie, remainder_ielen);\n\n\t\tkfree(pbackup_remainder_ie);\n\t}\n\n\toffset =  (uint)(dst_ie - pie);\n\tpnetwork_mlmeext->ie_length = offset + remainder_ielen;\n}\n\nstatic u8 chk_sta_is_alive(struct sta_info *psta)\n{\n\tsta_update_last_rx_pkts(psta);\n\n\treturn true;\n}\n\nvoid expire_timeout_chk(struct adapter *padapter)\n{\n\tstruct list_head *phead, *plist, *tmp;\n\tu8 updated = false;\n\tstruct sta_info *psta = NULL;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tu8 chk_alive_num = 0;\n\tchar chk_alive_list[NUM_STA];\n\tint i;\n\n\tspin_lock_bh(&pstapriv->auth_list_lock);\n\n\tphead = &pstapriv->auth_list;\n\t \n\tlist_for_each_safe(plist, tmp, phead) {\n\t\tpsta = list_entry(plist, struct sta_info, auth_list);\n\n\t\tif (psta->expire_to > 0) {\n\t\t\tpsta->expire_to--;\n\t\t\tif (psta->expire_to == 0) {\n\t\t\t\tlist_del_init(&psta->auth_list);\n\t\t\t\tpstapriv->auth_list_cnt--;\n\n\t\t\t\tspin_unlock_bh(&pstapriv->auth_list_lock);\n\n\t\t\t\trtw_free_stainfo(padapter, psta);\n\n\t\t\t\tspin_lock_bh(&pstapriv->auth_list_lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_bh(&pstapriv->auth_list_lock);\n\tpsta = NULL;\n\n\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\n\tphead = &pstapriv->asoc_list;\n\t \n\tlist_for_each_safe(plist, tmp, phead) {\n\t\tpsta = list_entry(plist, struct sta_info, asoc_list);\n\t\tif (chk_sta_is_alive(psta) || !psta->expire_to) {\n\t\t\tpsta->expire_to = pstapriv->expire_to;\n\t\t\tpsta->keep_alive_trycnt = 0;\n\t\t\tpsta->under_exist_checking = 0;\n\t\t} else {\n\t\t\tif (psta->expire_to > 0)\n\t\t\t\tpsta->expire_to--;\n\t\t}\n\n\t\tif (psta->expire_to == 0) {\n\t\t\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\n\t\t\tif (padapter->registrypriv.wifi_spec == 1) {\n\t\t\t\tpsta->expire_to = pstapriv->expire_to;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (psta->state & WIFI_SLEEP_STATE) {\n\t\t\t\tif (!(psta->state & WIFI_STA_ALIVE_CHK_STATE)) {\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tpsta->expire_to = pstapriv->expire_to;\n\t\t\t\t\tpsta->state |= WIFI_STA_ALIVE_CHK_STATE;\n\n\t\t\t\t\t \n\t\t\t\t\tpstapriv->tim_bitmap |= BIT(psta->aid);\n\t\t\t\t\tupdate_beacon(padapter, WLAN_EID_TIM, NULL, true);\n\n\t\t\t\t\tif (!pmlmeext->active_keep_alive_check)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pmlmeext->active_keep_alive_check) {\n\t\t\t\tint stainfo_offset;\n\n\t\t\t\tstainfo_offset = rtw_stainfo_offset(pstapriv, psta);\n\t\t\t\tif (stainfo_offset_valid(stainfo_offset))\n\t\t\t\t\tchk_alive_list[chk_alive_num++] = stainfo_offset;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlist_del_init(&psta->asoc_list);\n\t\t\tpstapriv->asoc_list_cnt--;\n\t\t\tupdated = ap_free_sta(padapter, psta, false, WLAN_REASON_DEAUTH_LEAVING);\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tif (psta->sleepq_len > (NR_XMITFRAME / pstapriv->asoc_list_cnt)\n\t\t\t\t&& padapter->xmitpriv.free_xmitframe_cnt < ((\n\t\t\t\t\tNR_XMITFRAME / pstapriv->asoc_list_cnt\n\t\t\t\t) / 2)\n\t\t\t)\n\t\t\t\twakeup_sta_to_xmit(padapter, psta);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\n\tif (chk_alive_num) {\n\t\tu8 backup_oper_channel = 0;\n\t\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\n\t\t \n\t\tif (rtw_get_oper_ch(padapter) != pmlmeext->cur_channel) {\n\t\t\tbackup_oper_channel = rtw_get_oper_ch(padapter);\n\t\t\tSelectChannel(padapter, pmlmeext->cur_channel);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < chk_alive_num; i++) {\n\t\t\tint ret = _FAIL;\n\n\t\t\tpsta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);\n\t\t\tif (!(psta->state & _FW_LINKED))\n\t\t\t\tcontinue;\n\n\t\t\tif (psta->state & WIFI_SLEEP_STATE)\n\t\t\t\tret = issue_nulldata(padapter, psta->hwaddr, 0, 1, 50);\n\t\t\telse\n\t\t\t\tret = issue_nulldata(padapter, psta->hwaddr, 0, 3, 50);\n\n\t\t\tpsta->keep_alive_trycnt++;\n\t\t\tif (ret == _SUCCESS) {\n\t\t\t\tpsta->expire_to = pstapriv->expire_to;\n\t\t\t\tpsta->keep_alive_trycnt = 0;\n\t\t\t\tcontinue;\n\t\t\t} else if (psta->keep_alive_trycnt <= 3) {\n\t\t\t\tpsta->expire_to = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpsta->keep_alive_trycnt = 0;\n\t\t\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\t\t\tif (list_empty(&psta->asoc_list) == false) {\n\t\t\t\tlist_del_init(&psta->asoc_list);\n\t\t\t\tpstapriv->asoc_list_cnt--;\n\t\t\t\tupdated = ap_free_sta(padapter, psta, false,\n\t\t\t\t\t\t      WLAN_REASON_DEAUTH_LEAVING);\n\t\t\t}\n\t\t\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\t\t}\n\n\t\tif (backup_oper_channel > 0)  \n\t\t\tSelectChannel(padapter, backup_oper_channel);\n\t}\n\n\tassociated_clients_update(padapter, updated);\n}\n\nvoid add_RATid(struct adapter *padapter, struct sta_info *psta, u8 rssi_level)\n{\n\tunsigned char sta_band = 0, shortGIrate = false;\n\tunsigned int tx_ra_bitmap = 0;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct wlan_bssid_ex\n\t\t*pcur_network = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;\n\n\tif (!psta)\n\t\treturn;\n\n\tif (!(psta->state & _FW_LINKED))\n\t\treturn;\n\n\trtw_hal_update_sta_rate_mask(padapter, psta);\n\ttx_ra_bitmap = psta->ra_mask;\n\n\tshortGIrate = query_ra_short_GI(psta);\n\n\tif (pcur_network->configuration.ds_config > 14) {\n\t\tsta_band |= WIRELESS_INVALID;\n\t} else {\n\t\tif (tx_ra_bitmap & 0xffff000)\n\t\t\tsta_band |= WIRELESS_11_24N;\n\n\t\tif (tx_ra_bitmap & 0xff0)\n\t\t\tsta_band |= WIRELESS_11G;\n\n\t\tif (tx_ra_bitmap & 0x0f)\n\t\t\tsta_band |= WIRELESS_11B;\n\t}\n\n\tpsta->wireless_mode = sta_band;\n\tpsta->raid = networktype_to_raid_ex(padapter, psta);\n\n\tif (psta->aid < NUM_STA) {\n\t\tu8 arg[4] = {0};\n\n\t\targ[0] = psta->mac_id;\n\t\targ[1] = psta->raid;\n\t\targ[2] = shortGIrate;\n\t\targ[3] = psta->init_rate;\n\n\t\trtw_hal_add_ra_tid(padapter, tx_ra_bitmap, arg, rssi_level);\n\t}\n}\n\nvoid update_bmc_sta(struct adapter *padapter)\n{\n\tunsigned char network_type;\n\tint supportRateNum = 0;\n\tunsigned int tx_ra_bitmap = 0;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex\n\t\t*pcur_network = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;\n\tstruct sta_info *psta = rtw_get_bcmc_stainfo(padapter);\n\n\tif (psta) {\n\t\tpsta->aid = 0; \n\t\t \n\t\tpsta->mac_id = psta->aid + 1; \n\n\t\tpmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;\n\n\t\tpsta->qos_option = 0;\n\t\tpsta->htpriv.ht_option = false;\n\n\t\tpsta->ieee8021x_blocked = 0;\n\n\t\tmemset((void *)&psta->sta_stats, 0, sizeof(struct stainfo_stats));\n\n\t\t \n\t\tsupportRateNum = rtw_get_rateset_len((u8 *)&pcur_network->supported_rates);\n\t\tnetwork_type = rtw_check_network_type((u8 *)&pcur_network->supported_rates,\n\t\t\t\t\t\t      supportRateNum,\n\t\t\t\t\t\t      pcur_network->configuration.ds_config\n\t\t);\n\t\tif (is_supported_tx_cck(network_type)) {\n\t\t\tnetwork_type = WIRELESS_11B;\n\t\t} else if (network_type == WIRELESS_INVALID) {  \n\n\t\t\tif (pcur_network->configuration.ds_config > 14)\n\t\t\t\tnetwork_type = WIRELESS_INVALID;\n\t\t\telse\n\t\t\t\tnetwork_type = WIRELESS_11B;\n\t\t}\n\t\tupdate_sta_basic_rate(psta, network_type);\n\t\tpsta->wireless_mode = network_type;\n\n\t\trtw_hal_update_sta_rate_mask(padapter, psta);\n\t\ttx_ra_bitmap = psta->ra_mask;\n\n\t\tpsta->raid = networktype_to_raid_ex(padapter, psta);\n\n\t\t \n\t\trtw_hal_set_odm_var(padapter, HAL_ODM_STA_INFO, psta, true);\n\n\t\t \n\t\t{\n\t\t\tu8 arg[4] = {0};\n\n\t\t\targ[0] = psta->mac_id;\n\t\t\targ[1] = psta->raid;\n\t\t\targ[2] = 0;\n\t\t\targ[3] = psta->init_rate;\n\n\t\t\trtw_hal_add_ra_tid(padapter, tx_ra_bitmap, arg, 0);\n\t\t}\n\n\t\trtw_sta_media_status_rpt(padapter, psta, 1);\n\n\t\tspin_lock_bh(&psta->lock);\n\t\tpsta->state = _FW_LINKED;\n\t\tspin_unlock_bh(&psta->lock);\n\n\t}\n}\n\n \n \n \n \n \n \n\nvoid update_sta_info_apmode(struct adapter *padapter, struct sta_info *psta)\n{\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct ht_priv *phtpriv_ap = &pmlmepriv->htpriv;\n\tstruct ht_priv *phtpriv_sta = &psta->htpriv;\n\tu8 cur_ldpc_cap = 0, cur_stbc_cap = 0, cur_beamform_cap = 0;\n\t \n\t \n\n\t \n\t \n\n\t \n\trtw_hal_set_odm_var(padapter, HAL_ODM_STA_INFO, psta, true);\n\n\tif (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)\n\t\tpsta->ieee8021x_blocked = true;\n\telse\n\t\tpsta->ieee8021x_blocked = false;\n\n\t \n\n\t \n\tVCS_update(padapter, psta);\n\n\t \n\tif (phtpriv_sta->ht_option) {\n\t\t \n\t\tphtpriv_sta->ampdu_enable = phtpriv_ap->ampdu_enable;\n\n\t\tphtpriv_sta->rx_ampdu_min_spacing = (\n\t\t\tphtpriv_sta->ht_cap.ampdu_params_info & IEEE80211_HT_CAP_AMPDU_DENSITY\n\t\t) >> 2;\n\n\t\t \n\t\tif ((\n\t\t\tphtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info\n\t\t) & cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH))\n\t\t\tpsta->bw_mode = CHANNEL_WIDTH_40;\n\t\telse\n\t\t\tpsta->bw_mode = CHANNEL_WIDTH_20;\n\n\t\tif (pmlmeext->cur_bwmode < psta->bw_mode)\n\t\t\tpsta->bw_mode = pmlmeext->cur_bwmode;\n\n\t\tphtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;\n\n\t\t \n\t\tif ((\n\t\t\tphtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info\n\t\t) & cpu_to_le16(IEEE80211_HT_CAP_SGI_20))\n\t\t\tphtpriv_sta->sgi_20m = true;\n\n\t\t \n\t\tif ((\n\t\t\tphtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info\n\t\t) & cpu_to_le16(IEEE80211_HT_CAP_SGI_40)) {\n\t\t\tif (psta->bw_mode == CHANNEL_WIDTH_40)  \n\t\t\t\tphtpriv_sta->sgi_40m = true;\n\t\t\telse\n\t\t\t\tphtpriv_sta->sgi_40m = false;\n\t\t}\n\n\t\tpsta->qos_option = true;\n\n\t\t \n\t\tif (TEST_FLAG(phtpriv_ap->ldpc_cap, LDPC_HT_ENABLE_TX) &&\n\t\t    GET_HT_CAPABILITY_ELE_LDPC_CAP((u8 *)(&phtpriv_sta->ht_cap)))\n\t\t\tSET_FLAG(cur_ldpc_cap, (LDPC_HT_ENABLE_TX | LDPC_HT_CAP_TX));\n\n\t\t \n\t\tif (TEST_FLAG(phtpriv_ap->stbc_cap, STBC_HT_ENABLE_TX) &&\n\t\t    GET_HT_CAPABILITY_ELE_RX_STBC((u8 *)(&phtpriv_sta->ht_cap)))\n\t\t\tSET_FLAG(cur_stbc_cap, (STBC_HT_ENABLE_TX | STBC_HT_CAP_TX));\n\t} else {\n\t\tphtpriv_sta->ampdu_enable = false;\n\n\t\tphtpriv_sta->sgi_20m = false;\n\t\tphtpriv_sta->sgi_40m = false;\n\t\tpsta->bw_mode = CHANNEL_WIDTH_20;\n\t\tphtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\t}\n\n\tphtpriv_sta->ldpc_cap = cur_ldpc_cap;\n\tphtpriv_sta->stbc_cap = cur_stbc_cap;\n\tphtpriv_sta->beamform_cap = cur_beamform_cap;\n\n\t \n\tsend_delba(padapter, 0, psta->hwaddr); \n\n\t \n\tsend_delba(padapter, 1, psta->hwaddr); \n\tphtpriv_sta->agg_enable_bitmap = 0x0; \n\tphtpriv_sta->candidate_tid_bitmap = 0x0; \n\n\tupdate_ldpc_stbc_cap(psta);\n\n\t \n\n\tmemset((void *)&psta->sta_stats, 0, sizeof(struct stainfo_stats));\n\n\t \n\t \n\n\tspin_lock_bh(&psta->lock);\n\tpsta->state |= _FW_LINKED;\n\tspin_unlock_bh(&psta->lock);\n}\n\nstatic void update_ap_info(struct adapter *padapter, struct sta_info *psta)\n{\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct wlan_bssid_ex\n\t\t*pnetwork = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct ht_priv *phtpriv_ap = &pmlmepriv->htpriv;\n\n\tpsta->wireless_mode = pmlmeext->cur_wireless_mode;\n\n\tpsta->bssratelen = rtw_get_rateset_len(pnetwork->supported_rates);\n\tmemcpy(psta->bssrateset, pnetwork->supported_rates, psta->bssratelen);\n\n\t \n\tif (phtpriv_ap->ht_option) {\n\t\t \n\t\t \n\n\t\t \n\t\tif ((phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SGI_20))\n\t\t\tphtpriv_ap->sgi_20m = true;\n\n\t\t \n\t\tif ((phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SGI_40))\n\t\t\tphtpriv_ap->sgi_40m = true;\n\n\t\tpsta->qos_option = true;\n\t} else {\n\t\tphtpriv_ap->ampdu_enable = false;\n\n\t\tphtpriv_ap->sgi_20m = false;\n\t\tphtpriv_ap->sgi_40m = false;\n\t}\n\n\tpsta->bw_mode = pmlmeext->cur_bwmode;\n\tphtpriv_ap->ch_offset = pmlmeext->cur_ch_offset;\n\n\tphtpriv_ap->agg_enable_bitmap = 0x0; \n\tphtpriv_ap->candidate_tid_bitmap = 0x0; \n\n\tmemcpy(&psta->htpriv, &pmlmepriv->htpriv, sizeof(struct ht_priv));\n}\n\nstatic void update_hw_ht_param(struct adapter *padapter)\n{\n\tunsigned char max_AMPDU_len;\n\tunsigned char min_MPDU_spacing;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\t \n\tmax_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;\n\n\tmin_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) >> 2;\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_MIN_SPACE, (u8 *)(&min_MPDU_spacing));\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_FACTOR, (u8 *)(&max_AMPDU_len));\n\n\t \n\t \n\t \n\tpmlmeinfo->SM_PS = (le16_to_cpu(\n\t\tpmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info\n\t) & 0x0C) >> 2;\n\n\t \n\t \n\t \n\t \n}\n\nvoid start_bss_network(struct adapter *padapter)\n{\n\tu8 *p;\n\tu8 val8, cur_channel, cur_bwmode, cur_ch_offset;\n\tu16 bcn_interval;\n\tu32 acparm;\n\tint\tie_len;\n\tstruct registry_priv  *pregpriv = &padapter->registrypriv;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct security_priv *psecuritypriv = &(padapter->securitypriv);\n\tstruct wlan_bssid_ex\n\t\t*pnetwork = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex *pnetwork_mlmeext = &(pmlmeinfo->network);\n\tstruct HT_info_element *pht_info = NULL;\n\tu8 cbw40_enable = 0;\n\n\tbcn_interval = (u16)pnetwork->configuration.beacon_period;\n\tcur_channel = pnetwork->configuration.ds_config;\n\tcur_bwmode = CHANNEL_WIDTH_20;\n\tcur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\n\t \n\t \n\t \n\tif (!rtw_get_wps_ie(pnetwork->ies + _FIXED_IE_LENGTH_,\n\t\t\t    pnetwork->ie_length - _FIXED_IE_LENGTH_, NULL, NULL))\n\t\tpmlmeext->bstart_bss = true;\n\n\t \n\t \n\t \n\tif (pmlmepriv->qospriv.qos_option)\n\t\tpmlmeinfo->WMM_enable = true;\n\tif (pmlmepriv->htpriv.ht_option) {\n\t\tpmlmeinfo->WMM_enable = true;\n\t\tpmlmeinfo->HT_enable = true;\n\t\t \n\t\t \n\n\t\tupdate_hw_ht_param(padapter);\n\t}\n\n\tif (!pmlmepriv->cur_network.join_res) {  \n\n\t\t \n\t\tif ((psecuritypriv->dot11PrivacyAlgrthm != _WEP40_) &&\n\t\t    (psecuritypriv->dot11PrivacyAlgrthm != _WEP104_))\n\t\t\tflush_all_cam_entry(padapter);\t \n\t}\n\n\t \n\tSet_MSR(padapter, _HW_STATE_AP_);\n\n\t \n\trtw_hal_set_hwreg(padapter, HW_VAR_BSSID, pnetwork->mac_address);\n\n\t \n\tacparm = 0x002F3217;  \n\trtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VO, (u8 *)(&acparm));\n\tacparm = 0x005E4317;  \n\trtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VI, (u8 *)(&acparm));\n\t \n\tacparm = 0x005ea42b;\n\trtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BE, (u8 *)(&acparm));\n\tacparm = 0x0000A444;  \n\trtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BK, (u8 *)(&acparm));\n\n\t \n\tval8 = (\n\t\tpsecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X\n\t) ? 0xcc : 0xcf;\n\trtw_hal_set_hwreg(padapter, HW_VAR_SEC_CFG, (u8 *)(&val8));\n\n\t \n\trtw_hal_set_hwreg(padapter, HW_VAR_BEACON_INTERVAL, (u8 *)(&bcn_interval));\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_DO_IQK, NULL);\n\n\tif (!pmlmepriv->cur_network.join_res) {  \n\t\t \n\n\t\t \n\n\t\t \n\t\t \n\t\t \n\n\t\t \n\t\tSwitch_DM_Func(padapter, DYNAMIC_ALL_FUNC_ENABLE, true);\n\n\t\t \n\t}\n\n\t \n\tp = rtw_get_ie((pnetwork->ies + sizeof(struct ndis_802_11_fix_ie)),\n\t\t       WLAN_EID_HT_OPERATION,\n\t\t       &ie_len,\n\t\t       (pnetwork->ie_length - sizeof(struct ndis_802_11_fix_ie))\n\t);\n\tif (p && ie_len) {\n\t\tpht_info = (struct HT_info_element *)(p + 2);\n\n\t\tif (cur_channel > 14) {\n\t\t\tif ((pregpriv->bw_mode & 0xf0) > 0)\n\t\t\t\tcbw40_enable = 1;\n\t\t} else {\n\t\t\tif ((pregpriv->bw_mode & 0x0f) > 0)\n\t\t\t\tcbw40_enable = 1;\n\t\t}\n\n\t\tif ((cbw40_enable) &&\t (pht_info->infos[0] & BIT(2))) {\n\t\t\t \n\t\t\t \n\t\t\tcur_bwmode = CHANNEL_WIDTH_40;\n\t\t\tswitch (pht_info->infos[0] & 0x3) {\n\t\t\tcase 1:\n\t\t\t\t \n\t\t\t\tcur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\t \n\t\t\t\tcur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tcur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tset_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);\n\tpmlmeext->cur_channel = cur_channel;\n\tpmlmeext->cur_bwmode = cur_bwmode;\n\tpmlmeext->cur_ch_offset = cur_ch_offset;\n\tpmlmeext->cur_wireless_mode = pmlmepriv->cur_network.network_type;\n\n\t \n\tmemcpy(pnetwork_mlmeext, pnetwork, pnetwork->length);\n\n\t \n\tupdate_wireless_mode(padapter);\n\n\t \n\tUpdateBrateTbl(padapter, pnetwork->supported_rates);\n\trtw_hal_set_hwreg(padapter, HW_VAR_BASIC_RATE, pnetwork->supported_rates);\n\n\t \n\tupdate_capinfo(\n\t\tpadapter,\n\t\trtw_get_capability((struct wlan_bssid_ex *)pnetwork)\n\t);\n\n\tif (pmlmeext->bstart_bss) {\n\t\tupdate_beacon(padapter, WLAN_EID_TIM, NULL, true);\n\n\t\t \n\t\tsend_beacon(padapter);\n\t}\n\n\t \n\tupdate_bmc_sta(padapter);\n\n\t \n}\n\nint rtw_check_beacon_data(struct adapter *padapter, u8 *pbuf,  int len)\n{\n\tint ret = _SUCCESS;\n\tu8 *p;\n\tu8 *pHT_caps_ie = NULL;\n\tu8 *pHT_info_ie = NULL;\n\tstruct sta_info *psta = NULL;\n\tu16 cap, ht_cap = false;\n\tuint ie_len = 0;\n\tint group_cipher, pairwise_cipher;\n\tu8 channel, network_type, supportRate[NDIS_802_11_LENGTH_RATES_EX];\n\tint supportRateNum = 0;\n\tu8 OUI1[] = {0x00, 0x50, 0xf2, 0x01};\n\tu8 WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct wlan_bssid_ex\n\t\t*pbss_network = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;\n\tu8 *ie = pbss_network->ies;\n\n\tif (!check_fwstate(pmlmepriv, WIFI_AP_STATE))\n\t\treturn _FAIL;\n\n\tif (len < 0 || len > MAX_IE_SZ)\n\t\treturn _FAIL;\n\n\tpbss_network->ie_length = len;\n\n\tmemset(ie, 0, MAX_IE_SZ);\n\n\tmemcpy(ie, pbuf, pbss_network->ie_length);\n\n\tif (pbss_network->infrastructure_mode != Ndis802_11APMode)\n\t\treturn _FAIL;\n\n\tpbss_network->rssi = 0;\n\n\tmemcpy(pbss_network->mac_address, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\n\t \n\tp = rtw_get_beacon_interval_from_ie(ie); \n\t \n\tpbss_network->configuration.beacon_period = get_unaligned_le16(p);\n\n\t \n\t \n\t \n\tcap = get_unaligned_le16(ie);\n\n\t \n\tp = rtw_get_ie(\n\t\tie + _BEACON_IE_OFFSET_,\n\t\tWLAN_EID_SSID,\n\t\t&ie_len,\n\t\t(pbss_network->ie_length - _BEACON_IE_OFFSET_)\n\t);\n\tif (p && ie_len > 0) {\n\t\tmemset(&pbss_network->ssid, 0, sizeof(struct ndis_802_11_ssid));\n\t\tmemcpy(pbss_network->ssid.ssid, (p + 2), ie_len);\n\t\tpbss_network->ssid.ssid_length = ie_len;\n\t}\n\n\t \n\tchannel = 0;\n\tpbss_network->configuration.length = 0;\n\tp = rtw_get_ie(\n\t\tie + _BEACON_IE_OFFSET_,\n\t\tWLAN_EID_DS_PARAMS, &ie_len,\n\t\t(pbss_network->ie_length - _BEACON_IE_OFFSET_)\n\t);\n\tif (p && ie_len > 0)\n\t\tchannel = *(p + 2);\n\n\tpbss_network->configuration.ds_config = channel;\n\n\tmemset(supportRate, 0, NDIS_802_11_LENGTH_RATES_EX);\n\t \n\tp = rtw_get_ie(\n\t\tie + _BEACON_IE_OFFSET_,\n\t\tWLAN_EID_SUPP_RATES,\n\t\t&ie_len,\n\t\t(pbss_network->ie_length - _BEACON_IE_OFFSET_)\n\t);\n\tif (p) {\n\t\tmemcpy(supportRate, p + 2, ie_len);\n\t\tsupportRateNum = ie_len;\n\t}\n\n\t \n\tp = rtw_get_ie(\n\t\tie + _BEACON_IE_OFFSET_,\n\t\tWLAN_EID_EXT_SUPP_RATES,\n\t\t&ie_len,\n\t\tpbss_network->ie_length - _BEACON_IE_OFFSET_\n\t);\n\tif (p) {\n\t\tmemcpy(supportRate + supportRateNum, p + 2, ie_len);\n\t\tsupportRateNum += ie_len;\n\t}\n\n\tnetwork_type = rtw_check_network_type(supportRate, supportRateNum, channel);\n\n\trtw_set_supported_rate(pbss_network->supported_rates, network_type);\n\n\t \n\tp = rtw_get_ie(\n\t\tie + _BEACON_IE_OFFSET_,\n\t\tWLAN_EID_ERP_INFO,\n\t\t&ie_len,\n\t\t(pbss_network->ie_length - _BEACON_IE_OFFSET_)\n\t);\n\tif (p && ie_len > 0)\n\t\tERP_IE_handler(padapter, (struct ndis_80211_var_ie *)p);\n\n\t \n\tif (cap & BIT(4))\n\t\tpbss_network->privacy = 1;\n\telse\n\t\tpbss_network->privacy = 0;\n\n\tpsecuritypriv->wpa_psk = 0;\n\n\t \n\tgroup_cipher = 0; pairwise_cipher = 0;\n\tpsecuritypriv->wpa2_group_cipher = _NO_PRIVACY_;\n\tpsecuritypriv->wpa2_pairwise_cipher = _NO_PRIVACY_;\n\tp = rtw_get_ie(\n\t\tie + _BEACON_IE_OFFSET_,\n\t\tWLAN_EID_RSN,\n\t\t&ie_len,\n\t\t(pbss_network->ie_length - _BEACON_IE_OFFSET_)\n\t);\n\tif (p && ie_len > 0) {\n\t\tif (rtw_parse_wpa2_ie(\n\t\t\tp,\n\t\t\tie_len + 2,\n\t\t\t&group_cipher,\n\t\t\t&pairwise_cipher,\n\t\t\tNULL\n\t\t) == _SUCCESS) {\n\t\t\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\n\n\t\t\tpsecuritypriv->dot8021xalg = 1; \n\t\t\tpsecuritypriv->wpa_psk |= BIT(1);\n\n\t\t\tpsecuritypriv->wpa2_group_cipher = group_cipher;\n\t\t\tpsecuritypriv->wpa2_pairwise_cipher = pairwise_cipher;\n\t\t}\n\t}\n\n\t \n\tie_len = 0;\n\tgroup_cipher = 0; pairwise_cipher = 0;\n\tpsecuritypriv->wpa_group_cipher = _NO_PRIVACY_;\n\tpsecuritypriv->wpa_pairwise_cipher = _NO_PRIVACY_;\n\tfor (p = ie + _BEACON_IE_OFFSET_; ; p += (ie_len + 2)) {\n\t\tp = rtw_get_ie(\n\t\t\tp,\n\t\t\tWLAN_EID_VENDOR_SPECIFIC,\n\t\t\t&ie_len,\n\t\t\t(pbss_network->ie_length - _BEACON_IE_OFFSET_ - (ie_len + 2))\n\t\t);\n\t\tif ((p) && (!memcmp(p + 2, OUI1, 4))) {\n\t\t\tif (rtw_parse_wpa_ie(\n\t\t\t\tp,\n\t\t\t\tie_len + 2,\n\t\t\t\t&group_cipher,\n\t\t\t\t&pairwise_cipher,\n\t\t\t\tNULL\n\t\t\t) == _SUCCESS) {\n\t\t\t\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\n\n\t\t\t\tpsecuritypriv->dot8021xalg = 1; \n\n\t\t\t\tpsecuritypriv->wpa_psk |= BIT(0);\n\n\t\t\t\tpsecuritypriv->wpa_group_cipher = group_cipher;\n\t\t\t\tpsecuritypriv->wpa_pairwise_cipher = pairwise_cipher;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!p || ie_len == 0)\n\t\t\tbreak;\n\t}\n\n\t \n\tie_len = 0;\n\tpmlmepriv->qospriv.qos_option = 0;\n\tif (pregistrypriv->wmm_enable) {\n\t\tfor (p = ie + _BEACON_IE_OFFSET_; ; p += (ie_len + 2)) {\n\t\t\tp = rtw_get_ie(\n\t\t\t\tp,\n\t\t\t\tWLAN_EID_VENDOR_SPECIFIC,\n\t\t\t\t&ie_len,\n\t\t\t\t(pbss_network->ie_length - _BEACON_IE_OFFSET_ - (ie_len + 2))\n\t\t\t);\n\t\t\tif ((p) && !memcmp(p + 2, WMM_PARA_IE, 6)) {\n\t\t\t\tpmlmepriv->qospriv.qos_option = 1;\n\n\t\t\t\t*(p + 8) |= BIT(7); \n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t*(p + 10) &= ~BIT(4);  \n\t\t\t\t*(p + 14) &= ~BIT(4);  \n\t\t\t\t*(p + 18) &= ~BIT(4);  \n\t\t\t\t*(p + 22) &= ~BIT(4);  \n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!p || ie_len == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tp = rtw_get_ie(\n\t\tie + _BEACON_IE_OFFSET_,\n\t\tWLAN_EID_HT_CAPABILITY,\n\t\t&ie_len,\n\t\t(pbss_network->ie_length - _BEACON_IE_OFFSET_)\n\t);\n\tif (p && ie_len > 0) {\n\t\tu8 max_rx_ampdu_factor = 0;\n\t\tstruct ieee80211_ht_cap *pht_cap = (struct ieee80211_ht_cap *)(p + 2);\n\n\t\tpHT_caps_ie = p;\n\n\t\tht_cap = true;\n\t\tnetwork_type |= WIRELESS_11_24N;\n\n\t\trtw_ht_use_default_setting(padapter);\n\n\t\tif (pmlmepriv->htpriv.sgi_20m == false)\n\t\t\tpht_cap->cap_info &= cpu_to_le16(~(IEEE80211_HT_CAP_SGI_20));\n\n\t\tif (pmlmepriv->htpriv.sgi_40m == false)\n\t\t\tpht_cap->cap_info &= cpu_to_le16(~(IEEE80211_HT_CAP_SGI_40));\n\n\t\tif (!TEST_FLAG(pmlmepriv->htpriv.ldpc_cap, LDPC_HT_ENABLE_RX))\n\t\t\tpht_cap->cap_info &= cpu_to_le16(~(IEEE80211_HT_CAP_LDPC_CODING));\n\n\t\tif (!TEST_FLAG(pmlmepriv->htpriv.stbc_cap, STBC_HT_ENABLE_TX))\n\t\t\tpht_cap->cap_info &= cpu_to_le16(~(IEEE80211_HT_CAP_TX_STBC));\n\n\t\tif (!TEST_FLAG(pmlmepriv->htpriv.stbc_cap, STBC_HT_ENABLE_RX))\n\t\t\tpht_cap->cap_info &= cpu_to_le16(~(IEEE80211_HT_CAP_RX_STBC_3R));\n\n\t\tpht_cap->ampdu_params_info &= ~(\n\t\t\tIEEE80211_HT_CAP_AMPDU_FACTOR | IEEE80211_HT_CAP_AMPDU_DENSITY\n\t\t);\n\n\t\tif ((psecuritypriv->wpa_pairwise_cipher & WPA_CIPHER_CCMP) ||\n\t\t    (psecuritypriv->wpa2_pairwise_cipher & WPA_CIPHER_CCMP)) {\n\t\t\tpht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY &\n\t\t\t\t\t\t       (0x07 << 2));\n\t\t} else {\n\t\t\tpht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY &\n\t\t\t\t\t\t       0x00);\n\t\t}\n\n\t\trtw_hal_get_def_var(\n\t\t\tpadapter,\n\t\t\tHW_VAR_MAX_RX_AMPDU_FACTOR,\n\t\t\t&max_rx_ampdu_factor\n\t\t);\n\t\tpht_cap->ampdu_params_info |= (\n\t\t\tIEEE80211_HT_CAP_AMPDU_FACTOR & max_rx_ampdu_factor\n\t\t);  \n\n\t\tpht_cap->mcs.rx_mask[0] = 0xff;\n\t\tpht_cap->mcs.rx_mask[1] = 0x0;\n\n\t\tmemcpy(&pmlmepriv->htpriv.ht_cap, p + 2, ie_len);\n\t}\n\n\t \n\tp = rtw_get_ie(\n\t\tie + _BEACON_IE_OFFSET_,\n\t\tWLAN_EID_HT_OPERATION,\n\t\t&ie_len,\n\t\t(pbss_network->ie_length - _BEACON_IE_OFFSET_)\n\t);\n\tif (p && ie_len > 0)\n\t\tpHT_info_ie = p;\n\n\tswitch (network_type) {\n\tcase WIRELESS_11B:\n\t\tpbss_network->network_type_in_use = Ndis802_11DS;\n\t\tbreak;\n\tcase WIRELESS_11G:\n\tcase WIRELESS_11BG:\n\tcase WIRELESS_11G_24N:\n\tcase WIRELESS_11BG_24N:\n\t\tpbss_network->network_type_in_use = Ndis802_11OFDM24;\n\t\tbreak;\n\tdefault:\n\t\tpbss_network->network_type_in_use = Ndis802_11OFDM24;\n\t\tbreak;\n\t}\n\n\tpmlmepriv->cur_network.network_type = network_type;\n\n\tpmlmepriv->htpriv.ht_option = false;\n\n\tif ((psecuritypriv->wpa2_pairwise_cipher & WPA_CIPHER_TKIP) ||\n\t    (psecuritypriv->wpa_pairwise_cipher & WPA_CIPHER_TKIP)) {\n\t\t \n\t\t \n\t}\n\n\t \n\tif (pregistrypriv->ht_enable && ht_cap) {\n\t\tpmlmepriv->htpriv.ht_option = true;\n\t\tpmlmepriv->qospriv.qos_option = 1;\n\n\t\tif (pregistrypriv->ampdu_enable == 1)\n\t\t\tpmlmepriv->htpriv.ampdu_enable = true;\n\n\t\tHT_caps_handler(padapter, (struct ndis_80211_var_ie *)pHT_caps_ie);\n\n\t\tHT_info_handler(padapter, (struct ndis_80211_var_ie *)pHT_info_ie);\n\t}\n\n\tpbss_network->length = get_wlan_bssid_ex_sz(\n\t\t(struct wlan_bssid_ex  *)pbss_network\n\t);\n\n\t \n\t \n\trtw_startbss_cmd(padapter, RTW_CMDF_WAIT_ACK);\n\n\t \n\tpsta = rtw_get_stainfo(&padapter->stapriv, pbss_network->mac_address);\n\tif (!psta) {\n\t\tpsta = rtw_alloc_stainfo(&padapter->stapriv, pbss_network->mac_address);\n\t\tif (!psta)\n\t\t\treturn _FAIL;\n\t}\n\n\t \n\tupdate_ap_info(padapter, psta);\n\n\tpsta->state |= WIFI_AP_STATE;\t\t \n\trtw_indicate_connect(padapter);\n\n\tpmlmepriv->cur_network.join_res = true; \n\n\t \n\t \n\n\treturn ret;\n}\n\nvoid rtw_set_macaddr_acl(struct adapter *padapter, int mode)\n{\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\n\n\tpacl_list->mode = mode;\n}\n\nint rtw_acl_add_sta(struct adapter *padapter, u8 *addr)\n{\n\tstruct list_head\t*plist, *phead;\n\tu8 added = false;\n\tint i, ret = 0;\n\tstruct rtw_wlan_acl_node *paclnode;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\n\tstruct __queue\t*pacl_node_q = &pacl_list->acl_node_q;\n\n\tif ((NUM_ACL - 1) < pacl_list->num)\n\t\treturn (-1);\n\n\tspin_lock_bh(&(pacl_node_q->lock));\n\n\tphead = get_list_head(pacl_node_q);\n\tlist_for_each(plist, phead) {\n\t\tpaclnode = list_entry(plist, struct rtw_wlan_acl_node, list);\n\n\t\tif (!memcmp(paclnode->addr, addr, ETH_ALEN)) {\n\t\t\tif (paclnode->valid == true) {\n\t\t\t\tadded = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_bh(&(pacl_node_q->lock));\n\n\tif (added)\n\t\treturn ret;\n\n\tspin_lock_bh(&(pacl_node_q->lock));\n\n\tfor (i = 0; i < NUM_ACL; i++) {\n\t\tpaclnode = &pacl_list->aclnode[i];\n\n\t\tif (!paclnode->valid) {\n\t\t\tINIT_LIST_HEAD(&paclnode->list);\n\n\t\t\tmemcpy(paclnode->addr, addr, ETH_ALEN);\n\n\t\t\tpaclnode->valid = true;\n\n\t\t\tlist_add_tail(&paclnode->list, get_list_head(pacl_node_q));\n\n\t\t\tpacl_list->num++;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&(pacl_node_q->lock));\n\n\treturn ret;\n}\n\nvoid rtw_acl_remove_sta(struct adapter *padapter, u8 *addr)\n{\n\tstruct list_head *plist, *phead, *tmp;\n\tstruct rtw_wlan_acl_node *paclnode;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\n\tstruct __queue\t*pacl_node_q = &pacl_list->acl_node_q;\n\n\tspin_lock_bh(&(pacl_node_q->lock));\n\n\tphead = get_list_head(pacl_node_q);\n\tlist_for_each_safe(plist, tmp, phead) {\n\t\tpaclnode = list_entry(plist, struct rtw_wlan_acl_node, list);\n\n\t\tif (\n\t\t\t!memcmp(paclnode->addr, addr, ETH_ALEN) ||\n\t\t\tis_broadcast_ether_addr(addr)\n\t\t) {\n\t\t\tif (paclnode->valid) {\n\t\t\t\tpaclnode->valid = false;\n\n\t\t\t\tlist_del_init(&paclnode->list);\n\n\t\t\t\tpacl_list->num--;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_bh(&(pacl_node_q->lock));\n\n}\n\nu8 rtw_ap_set_pairwise_key(struct adapter *padapter, struct sta_info *psta)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct set_stakey_parm\t*psetstakey_para;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tu8 res = _SUCCESS;\n\n\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ph2c) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpsetstakey_para = rtw_zmalloc(sizeof(struct set_stakey_parm));\n\tif (!psetstakey_para) {\n\t\tkfree(ph2c);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);\n\n\tpsetstakey_para->algorithm = (u8)psta->dot118021XPrivacy;\n\n\tmemcpy(psetstakey_para->addr, psta->hwaddr, ETH_ALEN);\n\n\tmemcpy(psetstakey_para->key, &psta->dot118021x_UncstKey, 16);\n\n\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\nexit:\n\n\treturn res;\n}\n\nstatic int rtw_ap_set_key(\n\tstruct adapter *padapter,\n\tu8 *key,\n\tu8 alg,\n\tint keyid,\n\tu8 set_tx\n)\n{\n\tu8 keylen;\n\tstruct cmd_obj *pcmd;\n\tstruct setkey_parm *psetkeyparm;\n\tstruct cmd_priv *pcmdpriv = &(padapter->cmdpriv);\n\tint res = _SUCCESS;\n\n\tpcmd = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!pcmd) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\tpsetkeyparm = rtw_zmalloc(sizeof(struct setkey_parm));\n\tif (!psetkeyparm) {\n\t\tkfree(pcmd);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpsetkeyparm->keyid = (u8)keyid;\n\tif (is_wep_enc(alg))\n\t\tpadapter->securitypriv.key_mask |= BIT(psetkeyparm->keyid);\n\n\tpsetkeyparm->algorithm = alg;\n\n\tpsetkeyparm->set_tx = set_tx;\n\n\tswitch (alg) {\n\tcase _WEP40_:\n\t\tkeylen = 5;\n\t\tbreak;\n\tcase _WEP104_:\n\t\tkeylen = 13;\n\t\tbreak;\n\tcase _TKIP_:\n\tcase _TKIP_WTMIC_:\n\tcase _AES_:\n\tdefault:\n\t\tkeylen = 16;\n\t}\n\n\tmemcpy(&(psetkeyparm->key[0]), key, keylen);\n\n\tpcmd->cmdcode = _SetKey_CMD_;\n\tpcmd->parmbuf = (u8 *)psetkeyparm;\n\tpcmd->cmdsz =  (sizeof(struct setkey_parm));\n\tpcmd->rsp = NULL;\n\tpcmd->rspsz = 0;\n\n\tINIT_LIST_HEAD(&pcmd->list);\n\n\tres = rtw_enqueue_cmd(pcmdpriv, pcmd);\n\nexit:\n\n\treturn res;\n}\n\nint rtw_ap_set_group_key(struct adapter *padapter, u8 *key, u8 alg, int keyid)\n{\n\treturn rtw_ap_set_key(padapter, key, alg, keyid, 1);\n}\n\nint rtw_ap_set_wep_key(\n\tstruct adapter *padapter,\n\tu8 *key,\n\tu8 keylen,\n\tint keyid,\n\tu8 set_tx\n)\n{\n\tu8 alg;\n\n\tswitch (keylen) {\n\tcase 5:\n\t\talg = _WEP40_;\n\t\tbreak;\n\tcase 13:\n\t\talg = _WEP104_;\n\t\tbreak;\n\tdefault:\n\t\talg = _NO_PRIVACY_;\n\t}\n\n\treturn rtw_ap_set_key(padapter, key, alg, keyid, set_tx);\n}\n\nstatic void update_bcn_fixed_ie(struct adapter *padapter)\n{\n}\n\nstatic void update_bcn_erpinfo_ie(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\n\tunsigned char *p, *ie = pnetwork->ies;\n\tu32 len = 0;\n\n\tif (!pmlmeinfo->ERP_enable)\n\t\treturn;\n\n\t \n\tp = rtw_get_ie(\n\t\tie + _BEACON_IE_OFFSET_,\n\t\tWLAN_EID_ERP_INFO,\n\t\t&len,\n\t\t(pnetwork->ie_length - _BEACON_IE_OFFSET_)\n\t);\n\tif (p && len > 0) {\n\t\tstruct ndis_80211_var_ie *pIE = (struct ndis_80211_var_ie *)p;\n\n\t\tif (pmlmepriv->num_sta_non_erp == 1)\n\t\t\tpIE->data[0] |= RTW_ERP_INFO_NON_ERP_PRESENT | RTW_ERP_INFO_USE_PROTECTION;\n\t\telse\n\t\t\tpIE->data[0] &= ~(\n\t\t\t\tRTW_ERP_INFO_NON_ERP_PRESENT | RTW_ERP_INFO_USE_PROTECTION\n\t\t\t);\n\n\t\tif (pmlmepriv->num_sta_no_short_preamble > 0)\n\t\t\tpIE->data[0] |= RTW_ERP_INFO_BARKER_PREAMBLE_MODE;\n\t\telse\n\t\t\tpIE->data[0] &= ~(RTW_ERP_INFO_BARKER_PREAMBLE_MODE);\n\n\t\tERP_IE_handler(padapter, pIE);\n\t}\n}\n\nstatic void update_bcn_htcap_ie(struct adapter *padapter)\n{\n}\n\nstatic void update_bcn_htinfo_ie(struct adapter *padapter)\n{\n}\n\nstatic void update_bcn_rsn_ie(struct adapter *padapter)\n{\n}\n\nstatic void update_bcn_wpa_ie(struct adapter *padapter)\n{\n}\n\nstatic void update_bcn_wmm_ie(struct adapter *padapter)\n{\n}\n\nstatic void update_bcn_wps_ie(struct adapter *padapter)\n{\n\tu8 *pwps_ie = NULL;\n\tu8 *pwps_ie_src;\n\tu8 *premainder_ie;\n\tu8 *pbackup_remainder_ie = NULL;\n\n\tuint wps_ielen = 0, wps_offset, remainder_ielen;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\n\tunsigned char *ie = pnetwork->ies;\n\tu32 ielen = pnetwork->ie_length;\n\n\tpwps_ie = rtw_get_wps_ie(\n\t\tie + _FIXED_IE_LENGTH_,\n\t\tielen - _FIXED_IE_LENGTH_,\n\t\tNULL,\n\t\t&wps_ielen\n\t);\n\n\tif (!pwps_ie || wps_ielen == 0)\n\t\treturn;\n\n\tpwps_ie_src = pmlmepriv->wps_beacon_ie;\n\tif (!pwps_ie_src)\n\t\treturn;\n\n\twps_offset = (uint)(pwps_ie - ie);\n\n\tpremainder_ie = pwps_ie + wps_ielen;\n\n\tremainder_ielen = ielen - wps_offset - wps_ielen;\n\n\tif (remainder_ielen > 0) {\n\t\tpbackup_remainder_ie = rtw_malloc(remainder_ielen);\n\t\tif (pbackup_remainder_ie)\n\t\t\tmemcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);\n\t}\n\n\twps_ielen = (uint)pwps_ie_src[1]; \n\tif ((wps_offset + wps_ielen + 2 + remainder_ielen) <= MAX_IE_SZ) {\n\t\tmemcpy(pwps_ie, pwps_ie_src, wps_ielen + 2);\n\t\tpwps_ie += (wps_ielen+2);\n\n\t\tif (pbackup_remainder_ie)\n\t\t\tmemcpy(pwps_ie, pbackup_remainder_ie, remainder_ielen);\n\n\t\t \n\t\tpnetwork->ie_length = wps_offset + (wps_ielen + 2) + remainder_ielen;\n\t}\n\n\tkfree(pbackup_remainder_ie);\n}\n\nstatic void update_bcn_p2p_ie(struct adapter *padapter)\n{\n}\n\nstatic void update_bcn_vendor_spec_ie(struct adapter *padapter, u8 *oui)\n{\n\tif (!memcmp(RTW_WPA_OUI, oui, 4))\n\t\tupdate_bcn_wpa_ie(padapter);\n\n\telse if (!memcmp(WMM_OUI, oui, 4))\n\t\tupdate_bcn_wmm_ie(padapter);\n\n\telse if (!memcmp(WPS_OUI, oui, 4))\n\t\tupdate_bcn_wps_ie(padapter);\n\n\telse if (!memcmp(P2P_OUI, oui, 4))\n\t\tupdate_bcn_p2p_ie(padapter);\n}\n\nvoid update_beacon(struct adapter *padapter, u8 ie_id, u8 *oui, u8 tx)\n{\n\tstruct mlme_priv *pmlmepriv;\n\tstruct mlme_ext_priv *pmlmeext;\n\t \n\n\tif (!padapter)\n\t\treturn;\n\n\tpmlmepriv = &(padapter->mlmepriv);\n\tpmlmeext = &(padapter->mlmeextpriv);\n\t \n\n\tif (!pmlmeext->bstart_bss)\n\t\treturn;\n\n\tspin_lock_bh(&pmlmepriv->bcn_update_lock);\n\n\tswitch (ie_id) {\n\tcase 0xFF:\n\n\t\tupdate_bcn_fixed_ie(padapter); \n\n\t\tbreak;\n\n\tcase WLAN_EID_TIM:\n\n\t\tupdate_BCNTIM(padapter);\n\n\t\tbreak;\n\n\tcase WLAN_EID_ERP_INFO:\n\n\t\tupdate_bcn_erpinfo_ie(padapter);\n\n\t\tbreak;\n\n\tcase WLAN_EID_HT_CAPABILITY:\n\n\t\tupdate_bcn_htcap_ie(padapter);\n\n\t\tbreak;\n\n\tcase WLAN_EID_RSN:\n\n\t\tupdate_bcn_rsn_ie(padapter);\n\n\t\tbreak;\n\n\tcase WLAN_EID_HT_OPERATION:\n\n\t\tupdate_bcn_htinfo_ie(padapter);\n\n\t\tbreak;\n\n\tcase WLAN_EID_VENDOR_SPECIFIC:\n\n\t\tupdate_bcn_vendor_spec_ie(padapter, oui);\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpmlmepriv->update_bcn = true;\n\n\tspin_unlock_bh(&pmlmepriv->bcn_update_lock);\n\n\tif (tx) {\n\t\t \nstatic int rtw_ht_operation_update(struct adapter *padapter)\n{\n\tu16 cur_op_mode, new_op_mode;\n\tint op_mode_changes = 0;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct ht_priv *phtpriv_ap = &pmlmepriv->htpriv;\n\n\tif (pmlmepriv->htpriv.ht_option)\n\t\treturn 0;\n\n\tif (!(pmlmepriv->ht_op_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)\n\t    && pmlmepriv->num_sta_ht_no_gf) {\n\t\tpmlmepriv->ht_op_mode |=\n\t\t\tIEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT;\n\t\top_mode_changes++;\n\t} else if ((pmlmepriv->ht_op_mode &\n\t\t    IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT) &&\n\t\t   pmlmepriv->num_sta_ht_no_gf == 0) {\n\t\tpmlmepriv->ht_op_mode &=\n\t\t\t~IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT;\n\t\top_mode_changes++;\n\t}\n\n\tif (!(pmlmepriv->ht_op_mode & IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT) &&\n\t    (pmlmepriv->num_sta_no_ht || pmlmepriv->olbc_ht)) {\n\t\tpmlmepriv->ht_op_mode |= IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\n\t\top_mode_changes++;\n\t} else if ((pmlmepriv->ht_op_mode &\n\t\t    IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT) &&\n\t\t   (pmlmepriv->num_sta_no_ht == 0 && !pmlmepriv->olbc_ht)) {\n\t\tpmlmepriv->ht_op_mode &=\n\t\t\t~IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\n\t\top_mode_changes++;\n\t}\n\n\t \n\tnew_op_mode = 0;\n\tif (pmlmepriv->num_sta_no_ht ||\n\t    (pmlmepriv->ht_op_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT))\n\t\tnew_op_mode = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED;\n\telse if (\n\t\t(le16_to_cpu(phtpriv_ap->ht_cap.cap_info) & IEEE80211_HT_CAP_SUP_WIDTH)\n\t\t&& pmlmepriv->num_sta_ht_20mhz)\n\t\tnew_op_mode = IEEE80211_HT_OP_MODE_PROTECTION_20MHZ;\n\telse if (pmlmepriv->olbc_ht)\n\t\tnew_op_mode = IEEE80211_HT_OP_MODE_PROTECTION_NONMEMBER;\n\telse\n\t\tnew_op_mode = IEEE80211_HT_OP_MODE_PROTECTION_NONE;\n\n\tcur_op_mode = pmlmepriv->ht_op_mode & IEEE80211_HT_OP_MODE_PROTECTION;\n\tif (cur_op_mode != new_op_mode) {\n\t\tpmlmepriv->ht_op_mode &= ~IEEE80211_HT_OP_MODE_PROTECTION;\n\t\tpmlmepriv->ht_op_mode |= new_op_mode;\n\t\top_mode_changes++;\n\t}\n\n\treturn op_mode_changes;\n}\n\nvoid associated_clients_update(struct adapter *padapter, u8 updated)\n{\n\t \n\tif (updated) {\n\t\tstruct list_head\t*phead, *plist;\n\t\tstruct sta_info *psta = NULL;\n\t\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\n\t\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\n\t\tphead = &pstapriv->asoc_list;\n\t\t \n\t\tlist_for_each(plist, phead) {\n\t\t\tpsta = list_entry(plist, struct sta_info, asoc_list);\n\n\t\t\tVCS_update(padapter, psta);\n\t\t}\n\n\t\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\t}\n}\n\n \nvoid bss_cap_update_on_sta_join(struct adapter *padapter, struct sta_info *psta)\n{\n\tu8 beacon_updated = false;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\n\tif (!(psta->flags & WLAN_STA_SHORT_PREAMBLE)) {\n\t\tif (!psta->no_short_preamble_set) {\n\t\t\tpsta->no_short_preamble_set = 1;\n\n\t\t\tpmlmepriv->num_sta_no_short_preamble++;\n\n\t\t\tif ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&\n\t\t\t    (pmlmepriv->num_sta_no_short_preamble == 1)) {\n\t\t\t\tbeacon_updated = true;\n\t\t\t\tupdate_beacon(padapter, 0xFF, NULL, true);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (psta->no_short_preamble_set) {\n\t\t\tpsta->no_short_preamble_set = 0;\n\n\t\t\tpmlmepriv->num_sta_no_short_preamble--;\n\n\t\t\tif ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&\n\t\t\t    (pmlmepriv->num_sta_no_short_preamble == 0)) {\n\t\t\t\tbeacon_updated = true;\n\t\t\t\tupdate_beacon(padapter, 0xFF, NULL, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (psta->flags & WLAN_STA_NONERP) {\n\t\tif (!psta->nonerp_set) {\n\t\t\tpsta->nonerp_set = 1;\n\n\t\t\tpmlmepriv->num_sta_non_erp++;\n\n\t\t\tif (pmlmepriv->num_sta_non_erp == 1) {\n\t\t\t\tbeacon_updated = true;\n\t\t\t\tupdate_beacon(padapter, WLAN_EID_ERP_INFO, NULL, true);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (psta->nonerp_set) {\n\t\t\tpsta->nonerp_set = 0;\n\n\t\t\tpmlmepriv->num_sta_non_erp--;\n\n\t\t\tif (pmlmepriv->num_sta_non_erp == 0) {\n\t\t\t\tbeacon_updated = true;\n\t\t\t\tupdate_beacon(padapter, WLAN_EID_ERP_INFO, NULL, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(psta->capability & WLAN_CAPABILITY_SHORT_SLOT_TIME)) {\n\t\tif (!psta->no_short_slot_time_set) {\n\t\t\tpsta->no_short_slot_time_set = 1;\n\n\t\t\tpmlmepriv->num_sta_no_short_slot_time++;\n\n\t\t\tif ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&\n\t\t\t    (pmlmepriv->num_sta_no_short_slot_time == 1)) {\n\t\t\t\tbeacon_updated = true;\n\t\t\t\tupdate_beacon(padapter, 0xFF, NULL, true);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (psta->no_short_slot_time_set) {\n\t\t\tpsta->no_short_slot_time_set = 0;\n\n\t\t\tpmlmepriv->num_sta_no_short_slot_time--;\n\n\t\t\tif ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&\n\t\t\t    (pmlmepriv->num_sta_no_short_slot_time == 0)) {\n\t\t\t\tbeacon_updated = true;\n\t\t\t\tupdate_beacon(padapter, 0xFF, NULL, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (psta->flags & WLAN_STA_HT) {\n\t\tu16 ht_capab = le16_to_cpu(psta->htpriv.ht_cap.cap_info);\n\n\t\tif (psta->no_ht_set) {\n\t\t\tpsta->no_ht_set = 0;\n\t\t\tpmlmepriv->num_sta_no_ht--;\n\t\t}\n\n\t\tif ((ht_capab & IEEE80211_HT_CAP_GRN_FLD) == 0) {\n\t\t\tif (!psta->no_ht_gf_set) {\n\t\t\t\tpsta->no_ht_gf_set = 1;\n\t\t\t\tpmlmepriv->num_sta_ht_no_gf++;\n\t\t\t}\n\t\t}\n\n\t\tif ((ht_capab & IEEE80211_HT_CAP_SUP_WIDTH) == 0) {\n\t\t\tif (!psta->ht_20mhz_set) {\n\t\t\t\tpsta->ht_20mhz_set = 1;\n\t\t\t\tpmlmepriv->num_sta_ht_20mhz++;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tif (!psta->no_ht_set) {\n\t\t\tpsta->no_ht_set = 1;\n\t\t\tpmlmepriv->num_sta_no_ht++;\n\t\t}\n\t}\n\n\tif (rtw_ht_operation_update(padapter) > 0) {\n\t\tupdate_beacon(padapter, WLAN_EID_HT_CAPABILITY, NULL, false);\n\t\tupdate_beacon(padapter, WLAN_EID_HT_OPERATION, NULL, true);\n\t}\n\n\t \n\tassociated_clients_update(padapter,  beacon_updated);\n}\n\nu8 bss_cap_update_on_sta_leave(struct adapter *padapter, struct sta_info *psta)\n{\n\tu8 beacon_updated = false;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\n\tif (!psta)\n\t\treturn beacon_updated;\n\n\tif (psta->no_short_preamble_set) {\n\t\tpsta->no_short_preamble_set = 0;\n\t\tpmlmepriv->num_sta_no_short_preamble--;\n\t\tif (pmlmeext->cur_wireless_mode > WIRELESS_11B\n\t\t    && pmlmepriv->num_sta_no_short_preamble == 0){\n\t\t\tbeacon_updated = true;\n\t\t\tupdate_beacon(padapter, 0xFF, NULL, true);\n\t\t}\n\t}\n\n\tif (psta->nonerp_set) {\n\t\tpsta->nonerp_set = 0;\n\t\tpmlmepriv->num_sta_non_erp--;\n\t\tif (pmlmepriv->num_sta_non_erp == 0) {\n\t\t\tbeacon_updated = true;\n\t\t\tupdate_beacon(padapter, WLAN_EID_ERP_INFO, NULL, true);\n\t\t}\n\t}\n\n\tif (psta->no_short_slot_time_set) {\n\t\tpsta->no_short_slot_time_set = 0;\n\t\tpmlmepriv->num_sta_no_short_slot_time--;\n\t\tif (pmlmeext->cur_wireless_mode > WIRELESS_11B\n\t\t    && pmlmepriv->num_sta_no_short_slot_time == 0){\n\t\t\tbeacon_updated = true;\n\t\t\tupdate_beacon(padapter, 0xFF, NULL, true);\n\t\t}\n\t}\n\n\tif (psta->no_ht_gf_set) {\n\t\tpsta->no_ht_gf_set = 0;\n\t\tpmlmepriv->num_sta_ht_no_gf--;\n\t}\n\n\tif (psta->no_ht_set) {\n\t\tpsta->no_ht_set = 0;\n\t\tpmlmepriv->num_sta_no_ht--;\n\t}\n\n\tif (psta->ht_20mhz_set) {\n\t\tpsta->ht_20mhz_set = 0;\n\t\tpmlmepriv->num_sta_ht_20mhz--;\n\t}\n\n\tif (rtw_ht_operation_update(padapter) > 0) {\n\t\tupdate_beacon(padapter, WLAN_EID_HT_CAPABILITY, NULL, false);\n\t\tupdate_beacon(padapter, WLAN_EID_HT_OPERATION, NULL, true);\n\t}\n\n\treturn beacon_updated;\n}\n\nu8 ap_free_sta(\n\tstruct adapter *padapter,\n\tstruct sta_info *psta,\n\tbool active,\n\tu16 reason\n)\n{\n\tu8 beacon_updated = false;\n\n\tif (!psta)\n\t\treturn beacon_updated;\n\n\tif (active) {\n\t\t \n\t\tsend_delba(padapter, 0, psta->hwaddr); \n\n\t\t \n\t\tsend_delba(padapter, 1, psta->hwaddr); \n\tpsta->htpriv.candidate_tid_bitmap = 0x0; \n\n\t \n\n\t \n\trtw_clearstakey_cmd(padapter, psta, true);\n\n\tspin_lock_bh(&psta->lock);\n\tpsta->state &= ~_FW_LINKED;\n\tspin_unlock_bh(&psta->lock);\n\n\trtw_cfg80211_indicate_sta_disassoc(padapter, psta->hwaddr, reason);\n\n\treport_del_sta_event(padapter, psta->hwaddr, reason);\n\n\tbeacon_updated = bss_cap_update_on_sta_leave(padapter, psta);\n\n\trtw_free_stainfo(padapter, psta);\n\n\treturn beacon_updated;\n}\n\nvoid rtw_sta_flush(struct adapter *padapter)\n{\n\tstruct list_head *phead, *plist, *tmp;\n\tstruct sta_info *psta = NULL;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n\tif ((pmlmeinfo->state & 0x03) != WIFI_FW_AP_STATE)\n\t\treturn;\n\n\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\tphead = &pstapriv->asoc_list;\n\t \n\tlist_for_each_safe(plist, tmp, phead) {\n\t\tpsta = list_entry(plist, struct sta_info, asoc_list);\n\n\t\tlist_del_init(&psta->asoc_list);\n\t\tpstapriv->asoc_list_cnt--;\n\n\t\t \n\t\tap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);\n\t\t \n\t}\n\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\n\tissue_deauth(padapter, bc_addr, WLAN_REASON_DEAUTH_LEAVING);\n\n\tassociated_clients_update(padapter, true);\n}\n\n \nvoid sta_info_update(struct adapter *padapter, struct sta_info *psta)\n{\n\tint flags = psta->flags;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\n\t \n\tif (WLAN_STA_WME & flags)\n\t\tpsta->qos_option = 1;\n\telse\n\t\tpsta->qos_option = 0;\n\n\tif (pmlmepriv->qospriv.qos_option == 0)\n\t\tpsta->qos_option = 0;\n\n\t \n\tif (WLAN_STA_HT & flags) {\n\t\tpsta->htpriv.ht_option = true;\n\t\tpsta->qos_option = 1;\n\t} else {\n\t\tpsta->htpriv.ht_option = false;\n\t}\n\n\tif (!pmlmepriv->htpriv.ht_option)\n\t\tpsta->htpriv.ht_option = false;\n\n\tupdate_sta_info_apmode(padapter, psta);\n}\n\n \nvoid ap_sta_info_defer_update(struct adapter *padapter, struct sta_info *psta)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tif (psta->state & _FW_LINKED) {\n\t\tpmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;\n\n\t\t \n\t\tadd_RATid(padapter, psta, 0); \n\t}\n}\n \nvoid rtw_ap_restore_network(struct adapter *padapter)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct sta_info *psta;\n\tstruct security_priv *psecuritypriv = &(padapter->securitypriv);\n\tstruct list_head\t*phead, *plist;\n\tu8 chk_alive_num = 0;\n\tchar chk_alive_list[NUM_STA];\n\tint i;\n\n\trtw_setopmode_cmd(padapter, Ndis802_11APMode, false);\n\n\tset_channel_bwmode(\n\t\tpadapter,\n\t\tpmlmeext->cur_channel,\n\t\tpmlmeext->cur_ch_offset,\n\t\tpmlmeext->cur_bwmode\n\t);\n\n\tstart_bss_network(padapter);\n\n\tif ((padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_) ||\n\t    (padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)) {\n\t\t \n\t\trtw_set_key(\n\t\t\tpadapter,\n\t\t\tpsecuritypriv,\n\t\t\tpsecuritypriv->dot118021XGrpKeyid,\n\t\t\t0,\n\t\t\tfalse\n\t\t);\n\t}\n\n\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\n\tphead = &pstapriv->asoc_list;\n\tlist_for_each(plist, phead) {\n\t\tint stainfo_offset;\n\n\t\tpsta = list_entry(plist, struct sta_info, asoc_list);\n\n\t\tstainfo_offset = rtw_stainfo_offset(pstapriv, psta);\n\t\tif (stainfo_offset_valid(stainfo_offset))\n\t\t\tchk_alive_list[chk_alive_num++] = stainfo_offset;\n\t}\n\n\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\n\tfor (i = 0; i < chk_alive_num; i++) {\n\t\tpsta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);\n\n\t\tif (!psta)\n\t\t\tcontinue;\n\n\t\tif (psta->state & _FW_LINKED) {\n\t\t\trtw_sta_media_status_rpt(padapter, psta, 1);\n\t\t\tUpdate_RA_Entry(padapter, psta);\n\t\t\t \n\t\t\t \n\t\t\tif ((psecuritypriv->dot11PrivacyAlgrthm == _TKIP_) ||\n\t\t\t    (psecuritypriv->dot11PrivacyAlgrthm == _AES_)) {\n\t\t\t\trtw_setstakey_cmd(padapter, psta, true, false);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid start_ap_mode(struct adapter *padapter)\n{\n\tint i;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\n\n\tpmlmepriv->update_bcn = false;\n\n\t \n\tpmlmeext->bstart_bss = false;\n\n\tpmlmepriv->num_sta_non_erp = 0;\n\n\tpmlmepriv->num_sta_no_short_slot_time = 0;\n\n\tpmlmepriv->num_sta_no_short_preamble = 0;\n\n\tpmlmepriv->num_sta_ht_no_gf = 0;\n\tpmlmepriv->num_sta_no_ht = 0;\n\tpmlmepriv->num_sta_ht_20mhz = 0;\n\n\tpmlmepriv->olbc = false;\n\n\tpmlmepriv->olbc_ht = false;\n\n\tpmlmepriv->ht_op_mode = 0;\n\n\tfor (i = 0; i < NUM_STA; i++)\n\t\tpstapriv->sta_aid[i] = NULL;\n\n\tpmlmepriv->wps_beacon_ie = NULL;\n\tpmlmepriv->wps_probe_resp_ie = NULL;\n\tpmlmepriv->wps_assoc_resp_ie = NULL;\n\n\tpmlmepriv->p2p_beacon_ie = NULL;\n\tpmlmepriv->p2p_probe_resp_ie = NULL;\n\n\t \n\tINIT_LIST_HEAD(&(pacl_list->acl_node_q.queue));\n\tpacl_list->num = 0;\n\tpacl_list->mode = 0;\n\tfor (i = 0; i < NUM_ACL; i++) {\n\t\tINIT_LIST_HEAD(&pacl_list->aclnode[i].list);\n\t\tpacl_list->aclnode[i].valid = false;\n\t}\n}\n\nvoid stop_ap_mode(struct adapter *padapter)\n{\n\tstruct list_head *phead, *plist, *tmp;\n\tstruct rtw_wlan_acl_node *paclnode;\n\tstruct sta_info *psta = NULL;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\n\tstruct __queue\t*pacl_node_q = &pacl_list->acl_node_q;\n\n\tpmlmepriv->update_bcn = false;\n\tpmlmeext->bstart_bss = false;\n\n\t \n\tmemset(\n\t\t(unsigned char *)&padapter->securitypriv,\n\t\t0,\n\t\tsizeof(struct security_priv)\n\t);\n\tpadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;\n\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11WEPDisabled;\n\n\t \n\tspin_lock_bh(&(pacl_node_q->lock));\n\tphead = get_list_head(pacl_node_q);\n\tlist_for_each_safe(plist, tmp, phead) {\n\t\tpaclnode = list_entry(plist, struct rtw_wlan_acl_node, list);\n\n\t\tif (paclnode->valid) {\n\t\t\tpaclnode->valid = false;\n\n\t\t\tlist_del_init(&paclnode->list);\n\n\t\t\tpacl_list->num--;\n\t\t}\n\t}\n\tspin_unlock_bh(&(pacl_node_q->lock));\n\n\trtw_sta_flush(padapter);\n\n\t \n\trtw_free_all_stainfo(padapter);\n\n\tpsta = rtw_get_bcmc_stainfo(padapter);\n\trtw_free_stainfo(padapter, psta);\n\n\trtw_init_bcmc_stainfo(padapter);\n\n\trtw_free_mlme_priv_ie_data(pmlmepriv);\n\n\trtw_btcoex_MediaStatusNotify(padapter, 0);  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}