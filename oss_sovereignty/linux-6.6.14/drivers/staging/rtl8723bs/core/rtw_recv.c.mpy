{
  "module_name": "rtw_recv.c",
  "hash_id": "21b9be61d370cc68617e8d9fcf7d1f687568eee432c8c9c9639dac00d85d4f79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/core/rtw_recv.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <linux/jiffies.h>\n#include <rtw_recv.h>\n#include <net/cfg80211.h>\n#include <asm/unaligned.h>\n\nstatic u8 SNAP_ETH_TYPE_IPX[2] = {0x81, 0x37};\nstatic u8 SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};\n\nstatic void rtw_signal_stat_timer_hdl(struct timer_list *t);\n\nvoid _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)\n{\n\tmemset((u8 *)psta_recvpriv, 0, sizeof(struct sta_recv_priv));\n\n\tspin_lock_init(&psta_recvpriv->lock);\n\n\t \n\t \n\n\tINIT_LIST_HEAD(&psta_recvpriv->defrag_q.queue);\n\tspin_lock_init(&psta_recvpriv->defrag_q.lock);\n}\n\nsigned int _rtw_init_recv_priv(struct recv_priv *precvpriv, struct adapter *padapter)\n{\n\tsigned int i;\n\tunion recv_frame *precvframe;\n\tsigned int\tres = _SUCCESS;\n\n\tspin_lock_init(&precvpriv->lock);\n\n\tINIT_LIST_HEAD(&precvpriv->free_recv_queue.queue);\n\tspin_lock_init(&precvpriv->free_recv_queue.lock);\n\tINIT_LIST_HEAD(&precvpriv->recv_pending_queue.queue);\n\tspin_lock_init(&precvpriv->recv_pending_queue.lock);\n\tINIT_LIST_HEAD(&precvpriv->uc_swdec_pending_queue.queue);\n\tspin_lock_init(&precvpriv->uc_swdec_pending_queue.lock);\n\n\tprecvpriv->adapter = padapter;\n\n\tprecvpriv->free_recvframe_cnt = NR_RECVFRAME;\n\n\tprecvpriv->pallocated_frame_buf = vzalloc(NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);\n\n\tif (!precvpriv->pallocated_frame_buf) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tprecvpriv->precv_frame_buf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(precvpriv->pallocated_frame_buf), RXFRAME_ALIGN_SZ);\n\t \n\t \n\n\tprecvframe = (union recv_frame *) precvpriv->precv_frame_buf;\n\n\n\tfor (i = 0; i < NR_RECVFRAME; i++) {\n\t\tINIT_LIST_HEAD(&(precvframe->u.list));\n\n\t\tlist_add_tail(&(precvframe->u.list), &(precvpriv->free_recv_queue.queue));\n\n\t\trtw_os_recv_resource_alloc(padapter, precvframe);\n\n\t\tprecvframe->u.hdr.len = 0;\n\n\t\tprecvframe->u.hdr.adapter = padapter;\n\t\tprecvframe++;\n\n\t}\n\n\tres = rtw_hal_init_recv_priv(padapter);\n\n\ttimer_setup(&precvpriv->signal_stat_timer, rtw_signal_stat_timer_hdl,\n\t\t    0);\n\n\tprecvpriv->signal_stat_sampling_interval = 2000;  \n\n\trtw_set_signal_stat_timer(precvpriv);\n\nexit:\n\treturn res;\n}\n\nvoid _rtw_free_recv_priv(struct recv_priv *precvpriv)\n{\n\tstruct adapter\t*padapter = precvpriv->adapter;\n\n\trtw_free_uc_swdec_pending_queue(padapter);\n\n\trtw_os_recv_resource_free(precvpriv);\n\n\tvfree(precvpriv->pallocated_frame_buf);\n\n\trtw_hal_free_recv_priv(padapter);\n}\n\nunion recv_frame *_rtw_alloc_recvframe(struct __queue *pfree_recv_queue)\n{\n\n\tunion recv_frame  *precvframe;\n\tstruct list_head\t*plist, *phead;\n\tstruct adapter *padapter;\n\tstruct recv_priv *precvpriv;\n\n\tif (list_empty(&pfree_recv_queue->queue))\n\t\tprecvframe = NULL;\n\telse {\n\t\tphead = get_list_head(pfree_recv_queue);\n\n\t\tplist = get_next(phead);\n\n\t\tprecvframe = (union recv_frame *)plist;\n\n\t\tlist_del_init(&precvframe->u.hdr.list);\n\t\tpadapter = precvframe->u.hdr.adapter;\n\t\tif (padapter) {\n\t\t\tprecvpriv = &padapter->recvpriv;\n\t\t\tif (pfree_recv_queue == &precvpriv->free_recv_queue)\n\t\t\t\tprecvpriv->free_recvframe_cnt--;\n\t\t}\n\t}\n\treturn precvframe;\n}\n\nunion recv_frame *rtw_alloc_recvframe(struct __queue *pfree_recv_queue)\n{\n\tunion recv_frame  *precvframe;\n\n\tspin_lock_bh(&pfree_recv_queue->lock);\n\n\tprecvframe = _rtw_alloc_recvframe(pfree_recv_queue);\n\n\tspin_unlock_bh(&pfree_recv_queue->lock);\n\n\treturn precvframe;\n}\n\nint rtw_free_recvframe(union recv_frame *precvframe, struct __queue *pfree_recv_queue)\n{\n\tstruct adapter *padapter = precvframe->u.hdr.adapter;\n\tstruct recv_priv *precvpriv = &padapter->recvpriv;\n\n\trtw_os_free_recvframe(precvframe);\n\n\n\tspin_lock_bh(&pfree_recv_queue->lock);\n\n\tlist_del_init(&(precvframe->u.hdr.list));\n\n\tprecvframe->u.hdr.len = 0;\n\n\tlist_add_tail(&(precvframe->u.hdr.list), get_list_head(pfree_recv_queue));\n\n\tif (padapter) {\n\t\tif (pfree_recv_queue == &precvpriv->free_recv_queue)\n\t\t\tprecvpriv->free_recvframe_cnt++;\n\t}\n\tspin_unlock_bh(&pfree_recv_queue->lock);\n\treturn _SUCCESS;\n}\n\n\n\n\nsigned int _rtw_enqueue_recvframe(union recv_frame *precvframe, struct __queue *queue)\n{\n\n\tstruct adapter *padapter = precvframe->u.hdr.adapter;\n\tstruct recv_priv *precvpriv = &padapter->recvpriv;\n\n\t \n\tlist_del_init(&(precvframe->u.hdr.list));\n\n\n\tlist_add_tail(&(precvframe->u.hdr.list), get_list_head(queue));\n\n\tif (padapter)\n\t\tif (queue == &precvpriv->free_recv_queue)\n\t\t\tprecvpriv->free_recvframe_cnt++;\n\n\treturn _SUCCESS;\n}\n\nsigned int rtw_enqueue_recvframe(union recv_frame *precvframe, struct __queue *queue)\n{\n\tsigned int ret;\n\n\t \n\tspin_lock_bh(&queue->lock);\n\tret = _rtw_enqueue_recvframe(precvframe, queue);\n\t \n\tspin_unlock_bh(&queue->lock);\n\n\treturn ret;\n}\n\n \n\nvoid rtw_free_recvframe_queue(struct __queue *pframequeue,  struct __queue *pfree_recv_queue)\n{\n\tunion\trecv_frame\t*precvframe;\n\tstruct list_head\t*plist, *phead;\n\n\tspin_lock(&pframequeue->lock);\n\n\tphead = get_list_head(pframequeue);\n\tplist = get_next(phead);\n\n\twhile (phead != plist) {\n\t\tprecvframe = (union recv_frame *)plist;\n\n\t\tplist = get_next(plist);\n\n\t\trtw_free_recvframe(precvframe, pfree_recv_queue);\n\t}\n\n\tspin_unlock(&pframequeue->lock);\n}\n\nu32 rtw_free_uc_swdec_pending_queue(struct adapter *adapter)\n{\n\tu32 cnt = 0;\n\tunion recv_frame *pending_frame;\n\n\twhile ((pending_frame = rtw_alloc_recvframe(&adapter->recvpriv.uc_swdec_pending_queue))) {\n\t\trtw_free_recvframe(pending_frame, &adapter->recvpriv.free_recv_queue);\n\t\tcnt++;\n\t}\n\n\treturn cnt;\n}\n\n\nsigned int rtw_enqueue_recvbuf_to_head(struct recv_buf *precvbuf, struct __queue *queue)\n{\n\tspin_lock_bh(&queue->lock);\n\n\tlist_del_init(&precvbuf->list);\n\tlist_add(&precvbuf->list, get_list_head(queue));\n\n\tspin_unlock_bh(&queue->lock);\n\n\treturn _SUCCESS;\n}\n\nsigned int rtw_enqueue_recvbuf(struct recv_buf *precvbuf, struct __queue *queue)\n{\n\tspin_lock_bh(&queue->lock);\n\n\tlist_del_init(&precvbuf->list);\n\n\tlist_add_tail(&precvbuf->list, get_list_head(queue));\n\tspin_unlock_bh(&queue->lock);\n\treturn _SUCCESS;\n\n}\n\nstruct recv_buf *rtw_dequeue_recvbuf(struct __queue *queue)\n{\n\tstruct recv_buf *precvbuf;\n\tstruct list_head\t*plist, *phead;\n\n\tspin_lock_bh(&queue->lock);\n\n\tif (list_empty(&queue->queue))\n\t\tprecvbuf = NULL;\n\telse {\n\t\tphead = get_list_head(queue);\n\n\t\tplist = get_next(phead);\n\n\t\tprecvbuf = container_of(plist, struct recv_buf, list);\n\n\t\tlist_del_init(&precvbuf->list);\n\n\t}\n\n\tspin_unlock_bh(&queue->lock);\n\n\treturn precvbuf;\n\n}\n\nstatic signed int recvframe_chkmic(struct adapter *adapter,  union recv_frame *precvframe)\n{\n\n\tsigned int\ti, res = _SUCCESS;\n\tu32 datalen;\n\tu8 miccode[8];\n\tu8 bmic_err = false, brpt_micerror = true;\n\tu8 *pframe, *payload, *pframemic;\n\tu8 *mickey;\n\t \n\tstruct sta_info *stainfo;\n\tstruct rx_pkt_attrib *prxattrib = &precvframe->u.hdr.attrib;\n\tstruct security_priv *psecuritypriv = &adapter->securitypriv;\n\n\tstruct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tstainfo = rtw_get_stainfo(&adapter->stapriv, &prxattrib->ta[0]);\n\n\tif (prxattrib->encrypt == _TKIP_) {\n\t\t \n\t\tif (stainfo) {\n\t\t\tif (is_multicast_ether_addr(prxattrib->ra)) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\tmickey = &psecuritypriv->dot118021XGrprxmickey[prxattrib->key_index].skey[0];\n\n\t\t\t\t \n\n\t\t\t\tif (psecuritypriv->binstallGrpkey == false) {\n\t\t\t\t\tres = _FAIL;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmickey = &stainfo->dot11tkiprxmickey.skey[0];\n\t\t\t}\n\n\t\t\tdatalen = precvframe->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len-prxattrib->icv_len-8; \n\t\t\tpframe = precvframe->u.hdr.rx_data;\n\t\t\tpayload = pframe+prxattrib->hdrlen+prxattrib->iv_len;\n\n\t\t\trtw_seccalctkipmic(mickey, pframe, payload, datalen, &miccode[0], (unsigned char)prxattrib->priority);  \n\n\t\t\tpframemic = payload+datalen;\n\n\t\t\tbmic_err = false;\n\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tif (miccode[i] != *(pframemic + i))\n\t\t\t\t\tbmic_err = true;\n\t\t\t}\n\n\n\t\t\tif (bmic_err == true) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif ((is_multicast_ether_addr(prxattrib->ra) == true)  && (prxattrib->key_index != pmlmeinfo->key_index))\n\t\t\t\t\tbrpt_micerror = false;\n\n\t\t\t\tif (prxattrib->bdecrypted && brpt_micerror)\n\t\t\t\t\trtw_handle_tkip_mic_err(adapter, (u8)is_multicast_ether_addr(prxattrib->ra));\n\n\t\t\t\tres = _FAIL;\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (!psecuritypriv->bcheck_grpkey &&\n\t\t\t\t    is_multicast_ether_addr(prxattrib->ra))\n\t\t\t\t\tpsecuritypriv->bcheck_grpkey = true;\n\t\t\t}\n\t\t}\n\n\t\trecvframe_pull_tail(precvframe, 8);\n\n\t}\n\nexit:\n\treturn res;\n\n}\n\n \nstatic union recv_frame *decryptor(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\n\tstruct rx_pkt_attrib *prxattrib = &precv_frame->u.hdr.attrib;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tunion recv_frame *return_packet = precv_frame;\n\tu32  res = _SUCCESS;\n\n\tif (prxattrib->encrypt > 0) {\n\t\tu8 *iv = precv_frame->u.hdr.rx_data+prxattrib->hdrlen;\n\n\t\tprxattrib->key_index = (((iv[3])>>6)&0x3);\n\n\t\tif (prxattrib->key_index > WEP_KEYS) {\n\t\t\tswitch (prxattrib->encrypt) {\n\t\t\tcase _WEP40_:\n\t\t\tcase _WEP104_:\n\t\t\t\tprxattrib->key_index = psecuritypriv->dot11PrivacyKeyIndex;\n\t\t\t\tbreak;\n\t\t\tcase _TKIP_:\n\t\t\tcase _AES_:\n\t\t\tdefault:\n\t\t\t\tprxattrib->key_index = psecuritypriv->dot118021XGrpKeyid;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((prxattrib->encrypt > 0) && ((prxattrib->bdecrypted == 0) || (psecuritypriv->sw_decrypt == true))) {\n\t\tpsecuritypriv->hw_decrypted = false;\n\n\t\tswitch (prxattrib->encrypt) {\n\t\tcase _WEP40_:\n\t\tcase _WEP104_:\n\t\t\trtw_wep_decrypt(padapter, (u8 *)precv_frame);\n\t\t\tbreak;\n\t\tcase _TKIP_:\n\t\t\tres = rtw_tkip_decrypt(padapter, (u8 *)precv_frame);\n\t\t\tbreak;\n\t\tcase _AES_:\n\t\t\tres = rtw_aes_decrypt(padapter, (u8 *)precv_frame);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t} else if (prxattrib->bdecrypted == 1 && prxattrib->encrypt > 0 &&\n\t\t   (psecuritypriv->busetkipkey == 1 || prxattrib->encrypt != _TKIP_)\n\t\t) {\n\t\tpsecuritypriv->hw_decrypted = true;\n\t} else {\n\t}\n\n\tif (res == _FAIL) {\n\t\trtw_free_recvframe(return_packet, &padapter->recvpriv.free_recv_queue);\n\t\treturn_packet = NULL;\n\t} else\n\t\tprxattrib->bdecrypted = true;\n\n\treturn return_packet;\n}\n\n \nstatic union recv_frame *portctrl(struct adapter *adapter, union recv_frame *precv_frame)\n{\n\tu8 *psta_addr = NULL;\n\tu8 *ptr;\n\tuint  auth_alg;\n\tstruct recv_frame_hdr *pfhdr;\n\tstruct sta_info *psta;\n\tstruct sta_priv *pstapriv;\n\tunion recv_frame *prtnframe;\n\tu16 ether_type = 0;\n\tu16  eapol_type = 0x888e; \n\tstruct rx_pkt_attrib *pattrib;\n\n\tpstapriv = &adapter->stapriv;\n\n\tauth_alg = adapter->securitypriv.dot11AuthAlgrthm;\n\n\tptr = precv_frame->u.hdr.rx_data;\n\tpfhdr = &precv_frame->u.hdr;\n\tpattrib = &pfhdr->attrib;\n\tpsta_addr = pattrib->ta;\n\n\tprtnframe = NULL;\n\n\tpsta = rtw_get_stainfo(pstapriv, psta_addr);\n\n\tif (auth_alg == 2) {\n\t\tif ((psta) && (psta->ieee8021x_blocked)) {\n\t\t\t__be16 be_tmp;\n\n\t\t\t \n\t\t\t \n\n\t\t\tprtnframe = precv_frame;\n\n\t\t\t \n\t\t\tptr = ptr + pfhdr->attrib.hdrlen + pfhdr->attrib.iv_len + LLC_HEADER_LENGTH;\n\t\t\tmemcpy(&be_tmp, ptr, 2);\n\t\t\tether_type = ntohs(be_tmp);\n\n\t\t\tif (ether_type == eapol_type)\n\t\t\t\tprtnframe = precv_frame;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\trtw_free_recvframe(precv_frame, &adapter->recvpriv.free_recv_queue);\n\t\t\t\tprtnframe = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\t \n\n\t\t\tprtnframe = precv_frame;\n\t\t\t \n\t\t\t \n\t\t\t\t \n\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t}\n\t} else\n\t\tprtnframe = precv_frame;\n\n\treturn prtnframe;\n}\n\nstatic signed int recv_decache(union recv_frame *precv_frame, u8 bretry, struct stainfo_rxcache *prxcache)\n{\n\tsigned int tid = precv_frame->u.hdr.attrib.priority;\n\n\tu16 seq_ctrl = ((precv_frame->u.hdr.attrib.seq_num&0xffff) << 4) |\n\t\t(precv_frame->u.hdr.attrib.frag_num & 0xf);\n\n\tif (tid > 15)\n\t\treturn _FAIL;\n\n\tif (1) {  \n\t\tif (seq_ctrl == prxcache->tid_rxseq[tid])\n\t\t\treturn _FAIL;\n\t}\n\n\tprxcache->tid_rxseq[tid] = seq_ctrl;\n\n\treturn _SUCCESS;\n\n}\n\nstatic void process_pwrbit_data(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tunsigned char pwrbit;\n\tu8 *ptr = precv_frame->u.hdr.rx_data;\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct sta_info *psta = NULL;\n\n\tpsta = rtw_get_stainfo(pstapriv, pattrib->src);\n\n\tpwrbit = GetPwrMgt(ptr);\n\n\tif (psta) {\n\t\tif (pwrbit) {\n\t\t\tif (!(psta->state & WIFI_SLEEP_STATE)) {\n\t\t\t\t \n\t\t\t\t \n\n\t\t\t\tstop_sta_xmit(padapter, psta);\n\n\t\t\t}\n\t\t} else {\n\t\t\tif (psta->state & WIFI_SLEEP_STATE) {\n\t\t\t\t \n\t\t\t\t \n\n\t\t\t\twakeup_sta_to_xmit(padapter, psta);\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nstatic void process_wmmps_data(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct sta_info *psta = NULL;\n\n\tpsta = rtw_get_stainfo(pstapriv, pattrib->src);\n\n\tif (!psta)\n\t\treturn;\n\n\tif (!psta->qos_option)\n\t\treturn;\n\n\tif (!(psta->qos_info&0xf))\n\t\treturn;\n\n\tif (psta->state&WIFI_SLEEP_STATE) {\n\t\tu8 wmmps_ac = 0;\n\n\t\tswitch (pattrib->priority) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\twmmps_ac = psta->uapsd_bk&BIT(1);\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\t\twmmps_ac = psta->uapsd_vi&BIT(1);\n\t\t\tbreak;\n\t\tcase 6:\n\t\tcase 7:\n\t\t\twmmps_ac = psta->uapsd_vo&BIT(1);\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase 3:\n\t\tdefault:\n\t\t\twmmps_ac = psta->uapsd_be&BIT(1);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wmmps_ac) {\n\t\t\tif (psta->sleepq_ac_len > 0)\n\t\t\t\t \n\t\t\t\txmit_delivery_enabled_frames(padapter, psta);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tissue_qos_nulldata(padapter, psta->hwaddr, (u16)pattrib->priority, 0, 0);\n\t\t}\n\t}\n}\n\nstatic void count_rx_stats(struct adapter *padapter, union recv_frame *prframe, struct sta_info *sta)\n{\n\tint sz;\n\tstruct sta_info *psta = NULL;\n\tstruct stainfo_stats *pstats = NULL;\n\tstruct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;\n\tstruct recv_priv *precvpriv = &padapter->recvpriv;\n\n\tsz = get_recvframe_len(prframe);\n\tprecvpriv->rx_bytes += sz;\n\n\tpadapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod++;\n\n\tif ((!is_broadcast_ether_addr(pattrib->dst)) && (!is_multicast_ether_addr(pattrib->dst)))\n\t\tpadapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod++;\n\n\tif (sta)\n\t\tpsta = sta;\n\telse\n\t\tpsta = prframe->u.hdr.psta;\n\n\tif (psta) {\n\t\tpstats = &psta->sta_stats;\n\n\t\tpstats->rx_data_pkts++;\n\t\tpstats->rx_bytes += sz;\n\t}\n\n\ttraffic_check_for_leave_lps(padapter, false, 0);\n}\n\nstatic signed int sta2sta_data_frame(struct adapter *adapter, union recv_frame *precv_frame,\n\t\t\tstruct sta_info **psta)\n{\n\tu8 *ptr = precv_frame->u.hdr.rx_data;\n\tsigned int ret = _SUCCESS;\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\tstruct sta_priv *pstapriv = &adapter->stapriv;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tu8 *mybssid  = get_bssid(pmlmepriv);\n\tu8 *myhwaddr = myid(&adapter->eeprompriv);\n\tu8 *sta_addr = NULL;\n\tsigned int bmcast = is_multicast_ether_addr(pattrib->dst);\n\n\tif ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||\n\t\t(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {\n\n\t\t \n\t\tif (!memcmp(myhwaddr, pattrib->src, ETH_ALEN)) {\n\t\t\tret = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif ((memcmp(myhwaddr, pattrib->dst, ETH_ALEN))\t&& (!bmcast)) {\n\t\t\tret = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (is_zero_ether_addr(pattrib->bssid) ||\n\t\t    is_zero_ether_addr(mybssid) ||\n\t\t    (memcmp(pattrib->bssid, mybssid, ETH_ALEN))) {\n\t\t\tret = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tsta_addr = pattrib->src;\n\n\t} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {\n\t\t \n\t\tif (memcmp(pattrib->bssid, pattrib->src, ETH_ALEN)) {\n\t\t\tret = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tsta_addr = pattrib->bssid;\n\t} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {\n\t\tif (bmcast) {\n\t\t\t \n\t\t\tif (!is_multicast_ether_addr(pattrib->bssid)) {\n\t\t\t\tret = _FAIL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {  \n\t\t\t \n\t\t\tif (memcmp(pattrib->bssid, pattrib->dst, ETH_ALEN)) {\n\t\t\t\tret = _FAIL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tsta_addr = pattrib->src;\n\t\t}\n\n\t} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {\n\t\tmemcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\n\n\t\tsta_addr = mybssid;\n\t} else\n\t\tret  = _FAIL;\n\n\n\n\tif (bmcast)\n\t\t*psta = rtw_get_bcmc_stainfo(adapter);\n\telse\n\t\t*psta = rtw_get_stainfo(pstapriv, sta_addr);  \n\n\tif (!*psta) {\n\t\tret = _FAIL;\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic signed int ap2sta_data_frame(struct adapter *adapter, union recv_frame *precv_frame,\n\t\t       struct sta_info **psta)\n{\n\tu8 *ptr = precv_frame->u.hdr.rx_data;\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\tsigned int ret = _SUCCESS;\n\tstruct sta_priv *pstapriv = &adapter->stapriv;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tu8 *mybssid  = get_bssid(pmlmepriv);\n\tu8 *myhwaddr = myid(&adapter->eeprompriv);\n\tsigned int bmcast = is_multicast_ether_addr(pattrib->dst);\n\n\tif ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) &&\n\t    (check_fwstate(pmlmepriv, _FW_LINKED) == true ||\n\t     check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true)\n\t\t) {\n\n\t\t \n\t\tif (!memcmp(myhwaddr, pattrib->src, ETH_ALEN)) {\n\t\t\tret = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tif ((memcmp(myhwaddr, pattrib->dst, ETH_ALEN)) && (!bmcast)) {\n\t\t\tret = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\n\t\t \n\t\tif (is_zero_ether_addr(pattrib->bssid) ||\n\t\t    is_zero_ether_addr(mybssid) ||\n\t\t    (memcmp(pattrib->bssid, mybssid, ETH_ALEN))) {\n\n\t\t\tif (!bmcast)\n\t\t\t\tissue_deauth(adapter, pattrib->bssid, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\n\n\t\t\tret = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (bmcast)\n\t\t\t*psta = rtw_get_bcmc_stainfo(adapter);\n\t\telse\n\t\t\t*psta = rtw_get_stainfo(pstapriv, pattrib->bssid);  \n\n\t\tif (!*psta) {\n\t\t\tret = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (GetFrameSubType(ptr) & BIT(6)) {\n\t\t\t \n\t\t\tcount_rx_stats(adapter, precv_frame, *psta);\n\t\t\tret = RTW_RX_HANDLED;\n\t\t\tgoto exit;\n\t\t}\n\n\t} else if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) &&\n\t\t     (check_fwstate(pmlmepriv, _FW_LINKED) == true)) {\n\t\tmemcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\n\n\t\t \n\t\tmemcpy(pattrib->bssid,  mybssid, ETH_ALEN);\n\n\n\t\t*psta = rtw_get_stainfo(pstapriv, pattrib->bssid);  \n\t\tif (!*psta) {\n\t\t\tret = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\n\t} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {\n\t\t \n\t\tret = RTW_RX_HANDLED;\n\t\tgoto exit;\n\t} else {\n\t\tif (!memcmp(myhwaddr, pattrib->dst, ETH_ALEN) && (!bmcast)) {\n\t\t\t*psta = rtw_get_stainfo(pstapriv, pattrib->bssid);  \n\t\t\tif (!*psta) {\n\n\t\t\t\t \n\t\t\t\tstatic unsigned long send_issue_deauth_time;\n\n\t\t\t\tif (jiffies_to_msecs(jiffies - send_issue_deauth_time) > 10000 || send_issue_deauth_time == 0) {\n\t\t\t\t\tsend_issue_deauth_time = jiffies;\n\n\t\t\t\t\tissue_deauth(adapter, pattrib->bssid, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tret = _FAIL;\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic signed int sta2ap_data_frame(struct adapter *adapter, union recv_frame *precv_frame,\n\t\t       struct sta_info **psta)\n{\n\tu8 *ptr = precv_frame->u.hdr.rx_data;\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\tstruct sta_priv *pstapriv = &adapter->stapriv;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tunsigned char *mybssid  = get_bssid(pmlmepriv);\n\tsigned int ret = _SUCCESS;\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {\n\t\t \n\t\tif (memcmp(pattrib->bssid, mybssid, ETH_ALEN)) {\n\t\t\tret = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t*psta = rtw_get_stainfo(pstapriv, pattrib->src);\n\t\tif (!*psta) {\n\t\t\tissue_deauth(adapter, pattrib->src, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\n\n\t\t\tret = RTW_RX_HANDLED;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tprocess_pwrbit_data(adapter, precv_frame);\n\n\t\tif ((GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE) == WIFI_QOS_DATA_TYPE)\n\t\t\tprocess_wmmps_data(adapter, precv_frame);\n\n\t\tif (GetFrameSubType(ptr) & BIT(6)) {\n\t\t\t \n\t\t\tcount_rx_stats(adapter, precv_frame, *psta);\n\t\t\tret = RTW_RX_HANDLED;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tu8 *myhwaddr = myid(&adapter->eeprompriv);\n\n\t\tif (memcmp(pattrib->ra, myhwaddr, ETH_ALEN)) {\n\t\t\tret = RTW_RX_HANDLED;\n\t\t\tgoto exit;\n\t\t}\n\t\tissue_deauth(adapter, pattrib->src, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\n\t\tret = RTW_RX_HANDLED;\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic signed int validate_recv_ctrl_frame(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tstruct sta_info *psta = NULL;\n\t \n\n\tif (GetFrameType(pframe) != WIFI_CTRL_TYPE)\n\t\treturn _FAIL;\n\n\t \n\tif (memcmp(GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN))\n\t\treturn _FAIL;\n\n\tpsta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));\n\tif (!psta)\n\t\treturn _FAIL;\n\n\t \n\tpsta->sta_stats.rx_ctrl_pkts++;\n\n\t \n\tif (GetFrameSubType(pframe) == WIFI_PSPOLL) {\n\t\tu16 aid;\n\t\tu8 wmmps_ac = 0;\n\n\t\taid = GetAid(pframe);\n\t\tif (psta->aid != aid)\n\t\t\treturn _FAIL;\n\n\t\tswitch (pattrib->priority) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\twmmps_ac = psta->uapsd_bk&BIT(0);\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\t\twmmps_ac = psta->uapsd_vi&BIT(0);\n\t\t\tbreak;\n\t\tcase 6:\n\t\tcase 7:\n\t\t\twmmps_ac = psta->uapsd_vo&BIT(0);\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase 3:\n\t\tdefault:\n\t\t\twmmps_ac = psta->uapsd_be&BIT(0);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wmmps_ac)\n\t\t\treturn _FAIL;\n\n\t\tif (psta->state & WIFI_STA_ALIVE_CHK_STATE) {\n\t\t\tpsta->expire_to = pstapriv->expire_to;\n\t\t\tpsta->state ^= WIFI_STA_ALIVE_CHK_STATE;\n\t\t}\n\n\t\tif ((psta->state&WIFI_SLEEP_STATE) && (pstapriv->sta_dz_bitmap&BIT(psta->aid))) {\n\t\t\tstruct list_head\t*xmitframe_plist, *xmitframe_phead;\n\t\t\tstruct xmit_frame *pxmitframe = NULL;\n\t\t\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\t\t\t \n\t\t\tspin_lock_bh(&pxmitpriv->lock);\n\n\t\t\txmitframe_phead = get_list_head(&psta->sleep_q);\n\t\t\txmitframe_plist = get_next(xmitframe_phead);\n\n\t\t\tif (xmitframe_phead != xmitframe_plist) {\n\t\t\t\tpxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);\n\n\t\t\t\txmitframe_plist = get_next(xmitframe_plist);\n\n\t\t\t\tlist_del_init(&pxmitframe->list);\n\n\t\t\t\tpsta->sleepq_len--;\n\n\t\t\t\tif (psta->sleepq_len > 0)\n\t\t\t\t\tpxmitframe->attrib.mdata = 1;\n\t\t\t\telse\n\t\t\t\t\tpxmitframe->attrib.mdata = 0;\n\n\t\t\t\tpxmitframe->attrib.triggered = 1;\n\n\t\t\t\trtw_hal_xmitframe_enqueue(padapter, pxmitframe);\n\n\t\t\t\tif (psta->sleepq_len == 0) {\n\t\t\t\t\tpstapriv->tim_bitmap &= ~BIT(psta->aid);\n\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tupdate_beacon(padapter, WLAN_EID_TIM, NULL, true);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tspin_unlock_bh(&pxmitpriv->lock);\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tspin_unlock_bh(&pxmitpriv->lock);\n\n\t\t\t\tif (pstapriv->tim_bitmap&BIT(psta->aid)) {\n\t\t\t\t\tif (psta->sleepq_len == 0) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tissue_nulldata_in_interrupt(padapter, psta->hwaddr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpsta->sleepq_len = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tpstapriv->tim_bitmap &= ~BIT(psta->aid);\n\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tupdate_beacon(padapter, WLAN_EID_TIM, NULL, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn _FAIL;\n\n}\n\n \nstatic union recv_frame *recvframe_defrag(struct adapter *adapter,\n\t\t\t\t\t  struct __queue *defrag_q)\n{\n\tstruct list_head\t *plist, *phead;\n\tu8  wlanhdr_offset;\n\tu8 curfragnum;\n\tstruct recv_frame_hdr *pfhdr, *pnfhdr;\n\tunion recv_frame *prframe, *pnextrframe;\n\tstruct __queue\t*pfree_recv_queue;\n\n\tcurfragnum = 0;\n\tpfree_recv_queue = &adapter->recvpriv.free_recv_queue;\n\n\tphead = get_list_head(defrag_q);\n\tplist = get_next(phead);\n\tprframe = (union recv_frame *)plist;\n\tpfhdr = &prframe->u.hdr;\n\tlist_del_init(&(prframe->u.list));\n\n\tif (curfragnum != pfhdr->attrib.frag_num) {\n\t\t \n\t\t \n\t\trtw_free_recvframe(prframe, pfree_recv_queue);\n\t\trtw_free_recvframe_queue(defrag_q, pfree_recv_queue);\n\n\t\treturn NULL;\n\t}\n\n\tcurfragnum++;\n\n\tplist = get_list_head(defrag_q);\n\n\tplist = get_next(plist);\n\n\twhile (phead != plist) {\n\t\tpnextrframe = (union recv_frame *)plist;\n\t\tpnfhdr = &pnextrframe->u.hdr;\n\n\n\t\t \n\n\t\tif (curfragnum != pnfhdr->attrib.frag_num) {\n\t\t\t \n\t\t\t \n\t\t\trtw_free_recvframe(prframe, pfree_recv_queue);\n\t\t\trtw_free_recvframe_queue(defrag_q, pfree_recv_queue);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tcurfragnum++;\n\n\t\t \n\t\t \n\n\t\twlanhdr_offset = pnfhdr->attrib.hdrlen + pnfhdr->attrib.iv_len;\n\n\t\trecvframe_pull(pnextrframe, wlanhdr_offset);\n\n\t\t \n\t\trecvframe_pull_tail(prframe, pfhdr->attrib.icv_len);\n\n\t\t \n\t\tmemcpy(pfhdr->rx_tail, pnfhdr->rx_data, pnfhdr->len);\n\n\t\trecvframe_put(prframe, pnfhdr->len);\n\n\t\tpfhdr->attrib.icv_len = pnfhdr->attrib.icv_len;\n\t\tplist = get_next(plist);\n\n\t}\n\n\t \n\trtw_free_recvframe_queue(defrag_q, pfree_recv_queue);\n\n\treturn prframe;\n}\n\n \nstatic union recv_frame *recvframe_chk_defrag(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tu8 ismfrag;\n\tu8 fragnum;\n\tu8 *psta_addr;\n\tstruct recv_frame_hdr *pfhdr;\n\tstruct sta_info *psta;\n\tstruct sta_priv *pstapriv;\n\tstruct list_head *phead;\n\tunion recv_frame *prtnframe = NULL;\n\tstruct __queue *pfree_recv_queue, *pdefrag_q;\n\n\tpstapriv = &padapter->stapriv;\n\n\tpfhdr = &precv_frame->u.hdr;\n\n\tpfree_recv_queue = &padapter->recvpriv.free_recv_queue;\n\n\t \n\tismfrag = pfhdr->attrib.mfrag;\n\tfragnum = pfhdr->attrib.frag_num;\n\n\tpsta_addr = pfhdr->attrib.ta;\n\tpsta = rtw_get_stainfo(pstapriv, psta_addr);\n\tif (!psta) {\n\t\tu8 type = GetFrameType(pfhdr->rx_data);\n\n\t\tif (type != WIFI_DATA_TYPE) {\n\t\t\tpsta = rtw_get_bcmc_stainfo(padapter);\n\t\t\tpdefrag_q = &psta->sta_recvpriv.defrag_q;\n\t\t} else\n\t\t\tpdefrag_q = NULL;\n\t} else\n\t\tpdefrag_q = &psta->sta_recvpriv.defrag_q;\n\n\tif ((ismfrag == 0) && (fragnum == 0))\n\t\tprtnframe = precv_frame; \n\n\tif (ismfrag == 1) {\n\t\t \n\t\t \n\t\tif (pdefrag_q) {\n\t\t\tif (fragnum == 0)\n\t\t\t\t \n\t\t\t\tif (!list_empty(&pdefrag_q->queue))\n\t\t\t\t\t \n\t\t\t\t\trtw_free_recvframe_queue(pdefrag_q, pfree_recv_queue);\n\n\n\t\t\t \n\n\t\t\t \n\t\t\tphead = get_list_head(pdefrag_q);\n\t\t\tlist_add_tail(&pfhdr->list, phead);\n\t\t\t \n\n\t\t\tprtnframe = NULL;\n\n\t\t} else {\n\t\t\t \n\t\t\trtw_free_recvframe(precv_frame, pfree_recv_queue);\n\t\t\tprtnframe = NULL;\n\t\t}\n\n\t}\n\n\tif ((ismfrag == 0) && (fragnum != 0)) {\n\t\t \n\t\t \n\t\tif (pdefrag_q) {\n\t\t\t \n\t\t\tphead = get_list_head(pdefrag_q);\n\t\t\tlist_add_tail(&pfhdr->list, phead);\n\t\t\t \n\n\t\t\t \n\t\t\tprecv_frame = recvframe_defrag(padapter, pdefrag_q);\n\t\t\tprtnframe = precv_frame;\n\n\t\t} else {\n\t\t\t \n\t\t\trtw_free_recvframe(precv_frame, pfree_recv_queue);\n\t\t\tprtnframe = NULL;\n\t\t}\n\n\t}\n\n\n\tif ((prtnframe) && (prtnframe->u.hdr.attrib.privacy)) {\n\t\t \n\t\tif (recvframe_chkmic(padapter,  prtnframe) == _FAIL) {\n\t\t\trtw_free_recvframe(prtnframe, pfree_recv_queue);\n\t\t\tprtnframe = NULL;\n\t\t}\n\t}\n\treturn prtnframe;\n}\n\nstatic signed int validate_recv_mgnt_frame(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\t \n\n\tprecv_frame = recvframe_chk_defrag(padapter, precv_frame);\n\tif (!precv_frame)\n\t\treturn _SUCCESS;\n\n\t{\n\t\t \n\t\tstruct sta_info *psta = rtw_get_stainfo(&padapter->stapriv, GetAddr2Ptr(precv_frame->u.hdr.rx_data));\n\n\t\tif (psta) {\n\t\t\tpsta->sta_stats.rx_mgnt_pkts++;\n\t\t\tif (GetFrameSubType(precv_frame->u.hdr.rx_data) == WIFI_BEACON)\n\t\t\t\tpsta->sta_stats.rx_beacon_pkts++;\n\t\t\telse if (GetFrameSubType(precv_frame->u.hdr.rx_data) == WIFI_PROBEREQ)\n\t\t\t\tpsta->sta_stats.rx_probereq_pkts++;\n\t\t\telse if (GetFrameSubType(precv_frame->u.hdr.rx_data) == WIFI_PROBERSP) {\n\t\t\t\tif (!memcmp(padapter->eeprompriv.mac_addr, GetAddr1Ptr(precv_frame->u.hdr.rx_data), ETH_ALEN))\n\t\t\t\t\tpsta->sta_stats.rx_probersp_pkts++;\n\t\t\t\telse if (is_broadcast_mac_addr(GetAddr1Ptr(precv_frame->u.hdr.rx_data)) ||\n\t\t\t\t\t is_multicast_mac_addr(GetAddr1Ptr(precv_frame->u.hdr.rx_data)))\n\t\t\t\t\tpsta->sta_stats.rx_probersp_bm_pkts++;\n\t\t\t\telse\n\t\t\t\t\tpsta->sta_stats.rx_probersp_uo_pkts++;\n\t\t\t}\n\t\t}\n\t}\n\n\tmgt_dispatcher(padapter, precv_frame);\n\n\treturn _SUCCESS;\n\n}\n\nstatic signed int validate_recv_data_frame(struct adapter *adapter, union recv_frame *precv_frame)\n{\n\tu8 bretry;\n\tu8 *psa, *pda, *pbssid;\n\tstruct sta_info *psta = NULL;\n\tu8 *ptr = precv_frame->u.hdr.rx_data;\n\tstruct rx_pkt_attrib\t*pattrib = &precv_frame->u.hdr.attrib;\n\tstruct security_priv *psecuritypriv = &adapter->securitypriv;\n\tsigned int ret = _SUCCESS;\n\n\tbretry = GetRetry(ptr);\n\tpda = get_da(ptr);\n\tpsa = get_sa(ptr);\n\tpbssid = get_hdr_bssid(ptr);\n\n\tif (!pbssid) {\n\t\tret = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(pattrib->dst, pda, ETH_ALEN);\n\tmemcpy(pattrib->src, psa, ETH_ALEN);\n\n\tmemcpy(pattrib->bssid, pbssid, ETH_ALEN);\n\n\tswitch (pattrib->to_fr_ds) {\n\tcase 0:\n\t\tmemcpy(pattrib->ra, pda, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, psa, ETH_ALEN);\n\t\tret = sta2sta_data_frame(adapter, precv_frame, &psta);\n\t\tbreak;\n\n\tcase 1:\n\t\tmemcpy(pattrib->ra, pda, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, pbssid, ETH_ALEN);\n\t\tret = ap2sta_data_frame(adapter, precv_frame, &psta);\n\t\tbreak;\n\n\tcase 2:\n\t\tmemcpy(pattrib->ra, pbssid, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, psa, ETH_ALEN);\n\t\tret = sta2ap_data_frame(adapter, precv_frame, &psta);\n\t\tbreak;\n\n\tcase 3:\n\t\tmemcpy(pattrib->ra, GetAddr1Ptr(ptr), ETH_ALEN);\n\t\tmemcpy(pattrib->ta, GetAddr2Ptr(ptr), ETH_ALEN);\n\t\tret = _FAIL;\n\t\tbreak;\n\n\tdefault:\n\t\tret = _FAIL;\n\t\tbreak;\n\n\t}\n\n\tif (ret == _FAIL) {\n\t\tgoto exit;\n\t} else if (ret == RTW_RX_HANDLED) {\n\t\tgoto exit;\n\t}\n\n\n\tif (!psta) {\n\t\tret = _FAIL;\n\t\tgoto exit;\n\t}\n\n\t \n\t \n\tprecv_frame->u.hdr.psta = psta;\n\n\n\tpattrib->amsdu = 0;\n\tpattrib->ack_policy = 0;\n\t \n\tif (pattrib->qos == 1) {\n\t\tpattrib->priority = GetPriority((ptr + 24));\n\t\tpattrib->ack_policy = GetAckpolicy((ptr + 24));\n\t\tpattrib->amsdu = GetAMsdu((ptr + 24));\n\t\tpattrib->hdrlen = pattrib->to_fr_ds == 3 ? 32 : 26;\n\n\t\tif (pattrib->priority != 0 && pattrib->priority != 3)\n\t\t\tadapter->recvpriv.bIsAnyNonBEPkts = true;\n\n\t} else {\n\t\tpattrib->priority = 0;\n\t\tpattrib->hdrlen = pattrib->to_fr_ds == 3 ? 30 : 24;\n\t}\n\n\n\tif (pattrib->order) \n\t\tpattrib->hdrlen += 4;\n\n\tprecv_frame->u.hdr.preorder_ctrl = &psta->recvreorder_ctrl[pattrib->priority];\n\n\t \n\tif (recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) == _FAIL) {\n\t\tret = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tif (pattrib->privacy) {\n\t\tGET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, is_multicast_ether_addr(pattrib->ra));\n\n\t\tSET_ICE_IV_LEN(pattrib->iv_len, pattrib->icv_len, pattrib->encrypt);\n\t} else {\n\t\tpattrib->encrypt = 0;\n\t\tpattrib->iv_len = pattrib->icv_len = 0;\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic signed int validate_80211w_mgmt(struct adapter *adapter, union recv_frame *precv_frame)\n{\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\tu8 *ptr = precv_frame->u.hdr.rx_data;\n\tu8 subtype;\n\n\tsubtype = GetFrameSubType(ptr);  \n\n\t \n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) && check_fwstate(pmlmepriv, _FW_LINKED) &&\n\t    adapter->securitypriv.binstallBIPkey == true) {\n\t\t \n\t\tif (pattrib->privacy && !(is_multicast_ether_addr(GetAddr1Ptr(ptr))) &&\n\t\t\t(subtype == WIFI_DEAUTH || subtype == WIFI_DISASSOC || subtype == WIFI_ACTION)) {\n\t\t\tu8 *mgmt_DATA;\n\t\t\tu32 data_len = 0;\n\n\t\t\tpattrib->bdecrypted = 0;\n\t\t\tpattrib->encrypt = _AES_;\n\t\t\tpattrib->hdrlen = sizeof(struct ieee80211_hdr_3addr);\n\t\t\t \n\t\t\tSET_ICE_IV_LEN(pattrib->iv_len, pattrib->icv_len, pattrib->encrypt);\n\t\t\tmemcpy(pattrib->ra, GetAddr1Ptr(ptr), ETH_ALEN);\n\t\t\tmemcpy(pattrib->ta, GetAddr2Ptr(ptr), ETH_ALEN);\n\t\t\t \n\t\t\tdata_len = pattrib->pkt_len - pattrib->hdrlen - pattrib->iv_len - pattrib->icv_len;\n\t\t\tmgmt_DATA = rtw_zmalloc(data_len);\n\t\t\tif (!mgmt_DATA)\n\t\t\t\tgoto validate_80211w_fail;\n\t\t\tprecv_frame = decryptor(adapter, precv_frame);\n\t\t\t \n\t\t\tmemcpy(mgmt_DATA, ptr+pattrib->hdrlen+pattrib->iv_len, data_len);\n\t\t\t \n\t\t\tmemcpy(ptr+pattrib->hdrlen, mgmt_DATA, data_len);\n\t\t\t \n\t\t\tpattrib->pkt_len = pattrib->pkt_len - pattrib->iv_len - pattrib->icv_len;\n\t\t\tkfree(mgmt_DATA);\n\t\t\tif (!precv_frame)\n\t\t\t\tgoto validate_80211w_fail;\n\t\t} else if (is_multicast_ether_addr(GetAddr1Ptr(ptr)) &&\n\t\t\t(subtype == WIFI_DEAUTH || subtype == WIFI_DISASSOC)) {\n\t\t\tsigned int BIP_ret = _SUCCESS;\n\t\t\t \n\t\t\tBIP_ret = rtw_BIP_verify(adapter, (u8 *)precv_frame);\n\t\t\tif (BIP_ret == _FAIL) {\n\t\t\t\tgoto validate_80211w_fail;\n\t\t\t} else if (BIP_ret == RTW_RX_HANDLED) {\n\t\t\t\t \n\t\t\t\tissue_action_SA_Query(adapter, NULL, 0, 0);\n\t\t\t\tgoto validate_80211w_fail;\n\t\t\t}\n\t\t} else {  \n\t\t\tif (subtype == WIFI_ACTION) {\n\t\t\t\t \n\t\t\t\tif (ptr[WLAN_HDR_A3_LEN] != RTW_WLAN_CATEGORY_PUBLIC          &&\n\t\t\t\t\tptr[WLAN_HDR_A3_LEN] != RTW_WLAN_CATEGORY_HT              &&\n\t\t\t\t\tptr[WLAN_HDR_A3_LEN] != RTW_WLAN_CATEGORY_UNPROTECTED_WNM &&\n\t\t\t\t\tptr[WLAN_HDR_A3_LEN] != RTW_WLAN_CATEGORY_SELF_PROTECTED  &&\n\t\t\t\t\tptr[WLAN_HDR_A3_LEN] != RTW_WLAN_CATEGORY_P2P) {\n\t\t\t\t\tgoto validate_80211w_fail;\n\t\t\t\t}\n\t\t\t} else if (subtype == WIFI_DEAUTH || subtype == WIFI_DISASSOC) {\n\t\t\t\t \n\t\t\t\tissue_action_SA_Query(adapter, NULL, 0, 0);\n\t\t\t\tgoto validate_80211w_fail;\n\t\t\t}\n\t\t}\n\t}\n\treturn _SUCCESS;\n\nvalidate_80211w_fail:\n\treturn _FAIL;\n\n}\n\nstatic signed int validate_recv_frame(struct adapter *adapter, union recv_frame *precv_frame)\n{\n\t \n\n\t \n\n\tu8 type;\n\tu8 subtype;\n\tsigned int retval = _SUCCESS;\n\tu8 bDumpRxPkt;\n\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\n\tu8 *ptr = precv_frame->u.hdr.rx_data;\n\tu8  ver = (unsigned char) (*ptr)&0x3;\n\n\t \n\tif (ver != 0) {\n\t\tretval = _FAIL;\n\t\tgoto exit;\n\t}\n\n\ttype =  GetFrameType(ptr);\n\tsubtype = GetFrameSubType(ptr);  \n\n\tpattrib->to_fr_ds = get_tofr_ds(ptr);\n\n\tpattrib->frag_num = GetFragNum(ptr);\n\tpattrib->seq_num = GetSequence(ptr);\n\n\tpattrib->pw_save = GetPwrMgt(ptr);\n\tpattrib->mfrag = GetMFrag(ptr);\n\tpattrib->mdata = GetMData(ptr);\n\tpattrib->privacy = GetPrivacy(ptr);\n\tpattrib->order = GetOrder(ptr);\n\trtw_hal_get_def_var(adapter, HAL_DEF_DBG_DUMP_RXPKT, &(bDumpRxPkt));\n\n\tswitch (type) {\n\tcase WIFI_MGT_TYPE:  \n\t\tif (validate_80211w_mgmt(adapter, precv_frame) == _FAIL) {\n\t\t\tretval = _FAIL;\n\t\t\tbreak;\n\t\t}\n\n\t\tretval = validate_recv_mgnt_frame(adapter, precv_frame);\n\t\tretval = _FAIL;  \n\t\tbreak;\n\tcase WIFI_CTRL_TYPE:  \n\t\tretval = validate_recv_ctrl_frame(adapter, precv_frame);\n\t\tretval = _FAIL;  \n\t\tbreak;\n\tcase WIFI_DATA_TYPE:  \n\t\tpattrib->qos = (subtype & BIT(7)) ? 1:0;\n\t\tretval = validate_recv_data_frame(adapter, precv_frame);\n\t\tif (retval == _FAIL) {\n\t\t\tstruct recv_priv *precvpriv = &adapter->recvpriv;\n\n\t\t\tprecvpriv->rx_drop++;\n\t\t} else if (retval == _SUCCESS) {\n#ifdef DBG_RX_DUMP_EAP\n\t\t\tu8 bDumpRxPkt;\n\t\t\tu16 eth_type;\n\n\t\t\t \n\t\t\trtw_hal_get_def_var(adapter, HAL_DEF_DBG_DUMP_RXPKT, &(bDumpRxPkt));\n\t\t\t \n\t\t\tmemcpy(&eth_type, ptr + pattrib->hdrlen + pattrib->iv_len + LLC_HEADER_LENGTH, 2);\n\t\t\teth_type = ntohs((unsigned short) eth_type);\n#endif\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tretval = _FAIL;\n\t\tbreak;\n\t}\n\nexit:\n\treturn retval;\n}\n\n \nstatic signed int wlanhdr_to_ethhdr(union recv_frame *precvframe)\n{\n\tsigned int\trmv_len;\n\tu16 eth_type, len;\n\tu8 bsnaphdr;\n\tu8 *psnap_type;\n\tstruct ieee80211_snap_hdr\t*psnap;\n\t__be16 be_tmp;\n\tstruct adapter\t\t\t*adapter = precvframe->u.hdr.adapter;\n\tstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\n\tu8 *ptr = precvframe->u.hdr.rx_data;  \n\tstruct rx_pkt_attrib *pattrib = &precvframe->u.hdr.attrib;\n\n\tif (pattrib->encrypt)\n\t\trecvframe_pull_tail(precvframe, pattrib->icv_len);\n\n\tpsnap = (struct ieee80211_snap_hdr\t*)(ptr+pattrib->hdrlen + pattrib->iv_len);\n\tpsnap_type = ptr+pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;\n\t \n\t \n\tif ((!memcmp(psnap, rfc1042_header, SNAP_SIZE) &&\n\t\t(memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2)) &&\n\t\t(memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2))) ||\n\t\t \n\t\t !memcmp(psnap, bridge_tunnel_header, SNAP_SIZE)) {\n\t\t \n\t\tbsnaphdr = true;\n\t} else\n\t\t \n\t\tbsnaphdr = false;\n\n\trmv_len = pattrib->hdrlen + pattrib->iv_len + (bsnaphdr?SNAP_SIZE:0);\n\tlen = precvframe->u.hdr.len - rmv_len;\n\n\tmemcpy(&be_tmp, ptr+rmv_len, 2);\n\teth_type = ntohs(be_tmp);  \n\tpattrib->eth_type = eth_type;\n\n\tif ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)) {\n\t\tptr += rmv_len;\n\t\t*ptr = 0x87;\n\t\t*(ptr+1) = 0x12;\n\n\t\teth_type = 0x8712;\n\t\t \n\t\tptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+2)-24);\n\t\tif (!ptr)\n\t\t\treturn _FAIL;\n\t\tmemcpy(ptr, get_rxmem(precvframe), 24);\n\t\tptr += 24;\n\t} else {\n\t\tptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr) + (bsnaphdr?2:0)));\n\t\tif (!ptr)\n\t\t\treturn _FAIL;\n\t}\n\n\tmemcpy(ptr, pattrib->dst, ETH_ALEN);\n\tmemcpy(ptr+ETH_ALEN, pattrib->src, ETH_ALEN);\n\n\tif (!bsnaphdr) {\n\t\tbe_tmp = htons(len);\n\t\tmemcpy(ptr+12, &be_tmp, 2);\n\t}\n\n\treturn _SUCCESS;\n}\n\nstatic int amsdu_to_msdu(struct adapter *padapter, union recv_frame *prframe)\n{\n\tint\ta_len, padding_len;\n\tu16 nSubframe_Length;\n\tu8 nr_subframes, i;\n\tu8 *pdata;\n\tstruct sk_buff *sub_pkt, *subframes[MAX_SUBFRAME_COUNT];\n\tstruct recv_priv *precvpriv = &padapter->recvpriv;\n\tstruct __queue *pfree_recv_queue = &(precvpriv->free_recv_queue);\n\n\tnr_subframes = 0;\n\n\trecvframe_pull(prframe, prframe->u.hdr.attrib.hdrlen);\n\n\tif (prframe->u.hdr.attrib.iv_len > 0)\n\t\trecvframe_pull(prframe, prframe->u.hdr.attrib.iv_len);\n\n\ta_len = prframe->u.hdr.len;\n\n\tpdata = prframe->u.hdr.rx_data;\n\n\twhile (a_len > ETH_HLEN) {\n\n\t\t \n\t\tnSubframe_Length = get_unaligned_be16(pdata + 12);\n\n\t\tif (a_len < ETH_HLEN + nSubframe_Length)\n\t\t\tbreak;\n\n\t\tsub_pkt = rtw_os_alloc_msdu_pkt(prframe, nSubframe_Length, pdata);\n\t\tif (!sub_pkt)\n\t\t\tbreak;\n\n\t\t \n\t\tpdata += ETH_HLEN;\n\t\ta_len -= ETH_HLEN;\n\n\t\tsubframes[nr_subframes++] = sub_pkt;\n\n\t\tif (nr_subframes >= MAX_SUBFRAME_COUNT)\n\t\t\tbreak;\n\n\t\tpdata += nSubframe_Length;\n\t\ta_len -= nSubframe_Length;\n\t\tif (a_len != 0) {\n\t\t\tpadding_len = 4 - ((nSubframe_Length + ETH_HLEN) & (4-1));\n\t\t\tif (padding_len == 4)\n\t\t\t\tpadding_len = 0;\n\n\t\t\tif (a_len < padding_len)\n\t\t\t\tbreak;\n\n\t\t\tpdata += padding_len;\n\t\t\ta_len -= padding_len;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_subframes; i++) {\n\t\tsub_pkt = subframes[i];\n\n\t\t \n\t\tif (sub_pkt)\n\t\t\trtw_os_recv_indicate_pkt(padapter, sub_pkt, &prframe->u.hdr.attrib);\n\t}\n\n\tprframe->u.hdr.len = 0;\n\trtw_free_recvframe(prframe, pfree_recv_queue); \n\n\treturn  _SUCCESS;\n}\n\nstatic int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl, u16 seq_num)\n{\n\tstruct adapter *padapter = preorder_ctrl->padapter;\n\tstruct dvobj_priv *psdpriv = padapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\tu8 wsize = preorder_ctrl->wsize_b;\n\tu16 wend = (preorder_ctrl->indicate_seq + wsize - 1) & 0xFFF; \n\n\t \n\tif (preorder_ctrl->indicate_seq == 0xFFFF)\n\t\tpreorder_ctrl->indicate_seq = seq_num;\n\n\t \n\tif (SN_LESS(seq_num, preorder_ctrl->indicate_seq))\n\t\treturn false;\n\n\t \n\t \n\t \n\t \n\t \n\tif (SN_EQUAL(seq_num, preorder_ctrl->indicate_seq)) {\n\t\tpreorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1) & 0xFFF;\n\n\t} else if (SN_LESS(wend, seq_num)) {\n\t\t \n\t\tif (seq_num >= (wsize - 1))\n\t\t\tpreorder_ctrl->indicate_seq = seq_num + 1 - wsize;\n\t\telse\n\t\t\tpreorder_ctrl->indicate_seq = 0xFFF - (wsize - (seq_num + 1)) + 1;\n\t\tpdbgpriv->dbg_rx_ampdu_window_shift_cnt++;\n\t}\n\n\treturn true;\n}\n\nstatic int enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl, union recv_frame *prframe)\n{\n\tstruct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;\n\tstruct __queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;\n\tstruct list_head\t*phead, *plist;\n\tunion recv_frame *pnextrframe;\n\tstruct rx_pkt_attrib *pnextattrib;\n\n\t \n\t \n\n\n\tphead = get_list_head(ppending_recvframe_queue);\n\tplist = get_next(phead);\n\n\twhile (phead != plist) {\n\t\tpnextrframe = (union recv_frame *)plist;\n\t\tpnextattrib = &pnextrframe->u.hdr.attrib;\n\n\t\tif (SN_LESS(pnextattrib->seq_num, pattrib->seq_num))\n\t\t\tplist = get_next(plist);\n\t\telse if (SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num))\n\t\t\t \n\t\t\t \n\t\t\treturn false;\n\t\telse\n\t\t\tbreak;\n\n\t}\n\n\n\t \n\t \n\n\tlist_del_init(&(prframe->u.hdr.list));\n\n\tlist_add_tail(&(prframe->u.hdr.list), plist);\n\n\t \n\t \n\n\treturn true;\n\n}\n\nstatic void recv_indicatepkts_pkt_loss_cnt(struct debug_priv *pdbgpriv, u64 prev_seq, u64 current_seq)\n{\n\tif (current_seq < prev_seq)\n\t\tpdbgpriv->dbg_rx_ampdu_loss_count += (4096 + current_seq - prev_seq);\n\telse\n\t\tpdbgpriv->dbg_rx_ampdu_loss_count += (current_seq - prev_seq);\n\n}\n\nstatic int recv_indicatepkts_in_order(struct adapter *padapter, struct recv_reorder_ctrl *preorder_ctrl, int bforced)\n{\n\tstruct list_head\t*phead, *plist;\n\tunion recv_frame *prframe;\n\tstruct rx_pkt_attrib *pattrib;\n\t \n\tint bPktInBuf = false;\n\tstruct recv_priv *precvpriv = &padapter->recvpriv;\n\tstruct __queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;\n\tstruct dvobj_priv *psdpriv = padapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\n\t \n\t \n\n\tphead =\t\tget_list_head(ppending_recvframe_queue);\n\tplist = get_next(phead);\n\n\t \n\tif (bforced == true) {\n\t\tpdbgpriv->dbg_rx_ampdu_forced_indicate_count++;\n\t\tif (list_empty(phead)) {\n\t\t\t \n\t\t\t \n\t\t\treturn true;\n\t\t}\n\n\t\tprframe = (union recv_frame *)plist;\n\t\tpattrib = &prframe->u.hdr.attrib;\n\n\t\trecv_indicatepkts_pkt_loss_cnt(pdbgpriv, preorder_ctrl->indicate_seq, pattrib->seq_num);\n\t\tpreorder_ctrl->indicate_seq = pattrib->seq_num;\n\n\t}\n\n\t \n\t \n\twhile (!list_empty(phead)) {\n\n\t\tprframe = (union recv_frame *)plist;\n\t\tpattrib = &prframe->u.hdr.attrib;\n\n\t\tif (!SN_LESS(preorder_ctrl->indicate_seq, pattrib->seq_num)) {\n\t\t\tplist = get_next(plist);\n\t\t\tlist_del_init(&(prframe->u.hdr.list));\n\n\t\t\tif (SN_EQUAL(preorder_ctrl->indicate_seq, pattrib->seq_num))\n\t\t\t\tpreorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1) & 0xFFF;\n\n\t\t\t \n\t\t\t \n\n\t\t\t \n\n\t\t\t \n\t\t\tif (!pattrib->amsdu) {\n\t\t\t\tif ((padapter->bDriverStopped == false) &&\n\t\t\t\t    (padapter->bSurpriseRemoved == false))\n\t\t\t\t\trtw_recv_indicatepkt(padapter, prframe); \n\n\t\t\t} else if (pattrib->amsdu == 1) {\n\t\t\t\tif (amsdu_to_msdu(padapter, prframe) != _SUCCESS)\n\t\t\t\t\trtw_free_recvframe(prframe, &precvpriv->free_recv_queue);\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t}\n\n\n\t\t\t \n\t\t\tbPktInBuf = false;\n\n\t\t} else {\n\t\t\tbPktInBuf = true;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\t \n\t \n\n\treturn bPktInBuf;\n}\n\nstatic int recv_indicatepkt_reorder(struct adapter *padapter, union recv_frame *prframe)\n{\n\tint retval = _SUCCESS;\n\tstruct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;\n\tstruct recv_reorder_ctrl *preorder_ctrl = prframe->u.hdr.preorder_ctrl;\n\tstruct __queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;\n\tstruct dvobj_priv *psdpriv = padapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\n\tif (!pattrib->amsdu) {\n\t\t \n\t\twlanhdr_to_ethhdr(prframe);\n\n\t\tif (pattrib->qos != 1) {\n\t\t\tif ((padapter->bDriverStopped == false) &&\n\t\t\t    (padapter->bSurpriseRemoved == false)) {\n\t\t\t\trtw_recv_indicatepkt(padapter, prframe);\n\t\t\t\treturn _SUCCESS;\n\n\t\t\t}\n\n\t\t\treturn _FAIL;\n\n\t\t}\n\n\t\tif (preorder_ctrl->enable == false) {\n\t\t\t \n\t\t\tpreorder_ctrl->indicate_seq = pattrib->seq_num;\n\n\t\t\trtw_recv_indicatepkt(padapter, prframe);\n\n\t\t\tpreorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1)%4096;\n\n\t\t\treturn _SUCCESS;\n\t\t}\n\t} else if (pattrib->amsdu == 1) {  \n\t\tif (preorder_ctrl->enable == false) {\n\t\t\tpreorder_ctrl->indicate_seq = pattrib->seq_num;\n\n\t\t\tretval = amsdu_to_msdu(padapter, prframe);\n\n\t\t\tpreorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1)%4096;\n\n\t\t\tif (retval != _SUCCESS) {\n\t\t\t}\n\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tspin_lock_bh(&ppending_recvframe_queue->lock);\n\n\t \n\tif (!check_indicate_seq(preorder_ctrl, pattrib->seq_num)) {\n\t\tpdbgpriv->dbg_rx_ampdu_drop_count++;\n\t\tgoto _err_exit;\n\t}\n\n\n\t \n\tif (!enqueue_reorder_recvframe(preorder_ctrl, prframe)) {\n\t\t \n\t\t \n\t\tgoto _err_exit;\n\t}\n\n\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\n\t \n\tif (recv_indicatepkts_in_order(padapter, preorder_ctrl, false) == true) {\n\t\t_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);\n\t\tspin_unlock_bh(&ppending_recvframe_queue->lock);\n\t} else {\n\t\tspin_unlock_bh(&ppending_recvframe_queue->lock);\n\t\tdel_timer_sync(&preorder_ctrl->reordering_ctrl_timer);\n\t}\n\n\treturn _SUCCESS;\n\n_err_exit:\n\tspin_unlock_bh(&ppending_recvframe_queue->lock);\n\n\treturn _FAIL;\n}\n\n\nvoid rtw_reordering_ctrl_timeout_handler(struct timer_list *t)\n{\n\tstruct recv_reorder_ctrl *preorder_ctrl =\n\t\tfrom_timer(preorder_ctrl, t, reordering_ctrl_timer);\n\tstruct adapter *padapter = preorder_ctrl->padapter;\n\tstruct __queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;\n\n\n\tif (padapter->bDriverStopped || padapter->bSurpriseRemoved)\n\t\treturn;\n\n\tspin_lock_bh(&ppending_recvframe_queue->lock);\n\n\tif (recv_indicatepkts_in_order(padapter, preorder_ctrl, true) == true)\n\t\t_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);\n\n\tspin_unlock_bh(&ppending_recvframe_queue->lock);\n\n}\n\nstatic int process_recv_indicatepkts(struct adapter *padapter, union recv_frame *prframe)\n{\n\tint retval = _SUCCESS;\n\t \n\t \n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\n\n\tif (phtpriv->ht_option == true) {  \n\t\t \n\n\t\tif (recv_indicatepkt_reorder(padapter, prframe) != _SUCCESS) {  \n\n\t\t\tif ((padapter->bDriverStopped == false) &&\n\t\t\t    (padapter->bSurpriseRemoved == false)) {\n\t\t\t\tretval = _FAIL;\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t} else {  \n\t\tretval = wlanhdr_to_ethhdr(prframe);\n\t\tif (retval != _SUCCESS)\n\t\t\treturn retval;\n\n\t\tif ((padapter->bDriverStopped == false) && (padapter->bSurpriseRemoved == false)) {\n\t\t\t \n\t\t\trtw_recv_indicatepkt(padapter, prframe);\n\t\t} else {\n\t\t\tretval = _FAIL;\n\t\t\treturn retval;\n\t\t}\n\n\t}\n\n\treturn retval;\n\n}\n\nstatic int recv_func_prehandle(struct adapter *padapter, union recv_frame *rframe)\n{\n\tint ret = _SUCCESS;\n\tstruct __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;\n\n\t \n\tret = validate_recv_frame(padapter, rframe);\n\tif (ret != _SUCCESS) {\n\t\trtw_free_recvframe(rframe, pfree_recv_queue); \n\t\tgoto exit;\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int recv_func_posthandle(struct adapter *padapter, union recv_frame *prframe)\n{\n\tint ret = _SUCCESS;\n\tunion recv_frame *orig_prframe = prframe;\n\tstruct recv_priv *precvpriv = &padapter->recvpriv;\n\tstruct __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;\n\n\tprframe = decryptor(padapter, prframe);\n\tif (!prframe) {\n\t\tret = _FAIL;\n\t\tgoto _recv_data_drop;\n\t}\n\n\tprframe = recvframe_chk_defrag(padapter, prframe);\n\tif (!prframe)\n\t\tgoto _recv_data_drop;\n\n\tprframe = portctrl(padapter, prframe);\n\tif (!prframe) {\n\t\tret = _FAIL;\n\t\tgoto _recv_data_drop;\n\t}\n\n\tcount_rx_stats(padapter, prframe, NULL);\n\n\tret = process_recv_indicatepkts(padapter, prframe);\n\tif (ret != _SUCCESS) {\n\t\trtw_free_recvframe(orig_prframe, pfree_recv_queue); \n\t\tgoto _recv_data_drop;\n\t}\n\n_recv_data_drop:\n\tprecvpriv->rx_drop++;\n\treturn ret;\n}\n\nstatic int recv_func(struct adapter *padapter, union recv_frame *rframe)\n{\n\tint ret;\n\tstruct rx_pkt_attrib *prxattrib = &rframe->u.hdr.attrib;\n\tstruct recv_priv *recvpriv = &padapter->recvpriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tstruct mlme_priv *mlmepriv = &padapter->mlmepriv;\n\n\t \n\tif (check_fwstate(mlmepriv, WIFI_STATION_STATE) && psecuritypriv->busetkipkey) {\n\t\tunion recv_frame *pending_frame;\n\t\tint cnt = 0;\n\n\t\twhile ((pending_frame = rtw_alloc_recvframe(&padapter->recvpriv.uc_swdec_pending_queue))) {\n\t\t\tcnt++;\n\t\t\trecv_func_posthandle(padapter, pending_frame);\n\t\t}\n\t}\n\n\tret = recv_func_prehandle(padapter, rframe);\n\n\tif (ret == _SUCCESS) {\n\n\t\t \n\t\tif (check_fwstate(mlmepriv, WIFI_STATION_STATE) &&\n\t\t\t!is_multicast_ether_addr(prxattrib->ra) && prxattrib->encrypt > 0 &&\n\t\t\t(prxattrib->bdecrypted == 0 || psecuritypriv->sw_decrypt == true) &&\n\t\t\tpsecuritypriv->ndisauthtype == Ndis802_11AuthModeWPAPSK &&\n\t\t\t!psecuritypriv->busetkipkey) {\n\t\t\trtw_enqueue_recvframe(rframe, &padapter->recvpriv.uc_swdec_pending_queue);\n\n\t\t\tif (recvpriv->free_recvframe_cnt < NR_RECVFRAME/4) {\n\t\t\t\t \n\t\t\t\trframe = rtw_alloc_recvframe(&padapter->recvpriv.uc_swdec_pending_queue);\n\t\t\t\tif (rframe)\n\t\t\t\t\tgoto do_posthandle;\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\ndo_posthandle:\n\t\tret = recv_func_posthandle(padapter, rframe);\n\t}\n\nexit:\n\treturn ret;\n}\n\n\ns32 rtw_recv_entry(union recv_frame *precvframe)\n{\n\tstruct adapter *padapter;\n\tstruct recv_priv *precvpriv;\n\ts32 ret = _SUCCESS;\n\n\tpadapter = precvframe->u.hdr.adapter;\n\n\tprecvpriv = &padapter->recvpriv;\n\n\tret = recv_func(padapter, precvframe);\n\tif (ret == _FAIL)\n\t\tgoto _recv_entry_drop;\n\n\tprecvpriv->rx_pkts++;\n\n\treturn ret;\n\n_recv_entry_drop:\n\n\treturn ret;\n}\n\nstatic void rtw_signal_stat_timer_hdl(struct timer_list *t)\n{\n\tstruct adapter *adapter =\n\t\tfrom_timer(adapter, t, recvpriv.signal_stat_timer);\n\tstruct recv_priv *recvpriv = &adapter->recvpriv;\n\n\tu32 tmp_s, tmp_q;\n\tu8 avg_signal_strength = 0;\n\tu8 avg_signal_qual = 0;\n\tu32 num_signal_strength = 0;\n\tu32 __maybe_unused num_signal_qual = 0;\n\tu8 _alpha = 5;  \n\n\tif (adapter->recvpriv.is_signal_dbg) {\n\t\t \n\t\tadapter->recvpriv.signal_strength = adapter->recvpriv.signal_strength_dbg;\n\t\tadapter->recvpriv.rssi = (s8)translate_percentage_to_dbm((u8)adapter->recvpriv.signal_strength_dbg);\n\t} else {\n\n\t\tif (recvpriv->signal_strength_data.update_req == 0) { \n\t\t\tavg_signal_strength = recvpriv->signal_strength_data.avg_val;\n\t\t\tnum_signal_strength = recvpriv->signal_strength_data.total_num;\n\t\t\t \n\t\t\trecvpriv->signal_strength_data.update_req = 1;\n\t\t}\n\n\t\tif (recvpriv->signal_qual_data.update_req == 0) { \n\t\t\tavg_signal_qual = recvpriv->signal_qual_data.avg_val;\n\t\t\tnum_signal_qual = recvpriv->signal_qual_data.total_num;\n\t\t\t \n\t\t\trecvpriv->signal_qual_data.update_req = 1;\n\t\t}\n\n\t\tif (num_signal_strength == 0) {\n\t\t\tif (rtw_get_on_cur_ch_time(adapter) == 0 ||\n\t\t\t    jiffies_to_msecs(jiffies - rtw_get_on_cur_ch_time(adapter)) < 2 * adapter->mlmeextpriv.mlmext_info.bcn_interval\n\t\t\t) {\n\t\t\t\tgoto set_timer;\n\t\t\t}\n\t\t}\n\n\t\tif (check_fwstate(&adapter->mlmepriv, _FW_UNDER_SURVEY) == true ||\n\t\t    check_fwstate(&adapter->mlmepriv, _FW_LINKED) == false\n\t\t) {\n\t\t\tgoto set_timer;\n\t\t}\n\n\t\t \n\t\ttmp_s = (avg_signal_strength+(_alpha-1)*recvpriv->signal_strength);\n\t\tif (tmp_s % _alpha)\n\t\t\ttmp_s = tmp_s/_alpha + 1;\n\t\telse\n\t\t\ttmp_s = tmp_s/_alpha;\n\t\tif (tmp_s > 100)\n\t\t\ttmp_s = 100;\n\n\t\ttmp_q = (avg_signal_qual+(_alpha-1)*recvpriv->signal_qual);\n\t\tif (tmp_q % _alpha)\n\t\t\ttmp_q = tmp_q/_alpha + 1;\n\t\telse\n\t\t\ttmp_q = tmp_q/_alpha;\n\t\tif (tmp_q > 100)\n\t\t\ttmp_q = 100;\n\n\t\trecvpriv->signal_strength = tmp_s;\n\t\trecvpriv->rssi = (s8)translate_percentage_to_dbm(tmp_s);\n\t\trecvpriv->signal_qual = tmp_q;\n\t}\n\nset_timer:\n\trtw_set_signal_stat_timer(recvpriv);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}