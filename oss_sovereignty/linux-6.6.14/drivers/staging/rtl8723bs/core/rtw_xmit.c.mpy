{
  "module_name": "rtw_xmit.c",
  "hash_id": "b677d15bdce868c05b0126686f7bfb626841161f80e83aefd4f5f6a02e524c0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/core/rtw_xmit.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n\nstatic u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };\nstatic u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };\n\nstatic void _init_txservq(struct tx_servq *ptxservq)\n{\n\tINIT_LIST_HEAD(&ptxservq->tx_pending);\n\tINIT_LIST_HEAD(&ptxservq->sta_pending.queue);\n\tspin_lock_init(&ptxservq->sta_pending.lock);\n\tptxservq->qcnt = 0;\n}\n\nvoid _rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)\n{\n\tmemset((unsigned char *)psta_xmitpriv, 0, sizeof(struct sta_xmit_priv));\n\n\tspin_lock_init(&psta_xmitpriv->lock);\n\n\t_init_txservq(&psta_xmitpriv->be_q);\n\t_init_txservq(&psta_xmitpriv->bk_q);\n\t_init_txservq(&psta_xmitpriv->vi_q);\n\t_init_txservq(&psta_xmitpriv->vo_q);\n\tINIT_LIST_HEAD(&psta_xmitpriv->legacy_dz);\n\tINIT_LIST_HEAD(&psta_xmitpriv->apsd);\n}\n\ns32 _rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct adapter *padapter)\n{\n\tint i;\n\tstruct xmit_buf *pxmitbuf;\n\tstruct xmit_frame *pxframe;\n\tsigned int\tres = _SUCCESS;\n\n\tspin_lock_init(&pxmitpriv->lock);\n\tspin_lock_init(&pxmitpriv->lock_sctx);\n\tinit_completion(&pxmitpriv->xmit_comp);\n\tinit_completion(&pxmitpriv->terminate_xmitthread_comp);\n\n\t \n\n\tpxmitpriv->adapter = padapter;\n\n\tINIT_LIST_HEAD(&pxmitpriv->be_pending.queue);\n\tspin_lock_init(&pxmitpriv->be_pending.lock);\n\tINIT_LIST_HEAD(&pxmitpriv->bk_pending.queue);\n\tspin_lock_init(&pxmitpriv->bk_pending.lock);\n\tINIT_LIST_HEAD(&pxmitpriv->vi_pending.queue);\n\tspin_lock_init(&pxmitpriv->vi_pending.lock);\n\tINIT_LIST_HEAD(&pxmitpriv->vo_pending.queue);\n\tspin_lock_init(&pxmitpriv->vo_pending.lock);\n\tINIT_LIST_HEAD(&pxmitpriv->bm_pending.queue);\n\tspin_lock_init(&pxmitpriv->bm_pending.lock);\n\n\tINIT_LIST_HEAD(&pxmitpriv->free_xmit_queue.queue);\n\tspin_lock_init(&pxmitpriv->free_xmit_queue.lock);\n\n\t \n\n\tpxmitpriv->pallocated_frame_buf = vzalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4);\n\n\tif (!pxmitpriv->pallocated_frame_buf) {\n\t\tpxmitpriv->pxmit_frame_buf = NULL;\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\tpxmitpriv->pxmit_frame_buf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_frame_buf), 4);\n\n\tpxframe = (struct xmit_frame *) pxmitpriv->pxmit_frame_buf;\n\n\tfor (i = 0; i < NR_XMITFRAME; i++) {\n\t\tINIT_LIST_HEAD(&pxframe->list);\n\n\t\tpxframe->padapter = padapter;\n\t\tpxframe->frame_tag = NULL_FRAMETAG;\n\n\t\tpxframe->pkt = NULL;\n\n\t\tpxframe->buf_addr = NULL;\n\t\tpxframe->pxmitbuf = NULL;\n\n\t\tlist_add_tail(&pxframe->list,\n\t\t\t      &pxmitpriv->free_xmit_queue.queue);\n\n\t\tpxframe++;\n\t}\n\n\tpxmitpriv->free_xmitframe_cnt = NR_XMITFRAME;\n\n\tpxmitpriv->frag_len = MAX_FRAG_THRESHOLD;\n\n\t \n\tINIT_LIST_HEAD(&pxmitpriv->free_xmitbuf_queue.queue);\n\tspin_lock_init(&pxmitpriv->free_xmitbuf_queue.lock);\n\tINIT_LIST_HEAD(&pxmitpriv->pending_xmitbuf_queue.queue);\n\tspin_lock_init(&pxmitpriv->pending_xmitbuf_queue.lock);\n\n\tpxmitpriv->pallocated_xmitbuf = vzalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4);\n\n\tif (!pxmitpriv->pallocated_xmitbuf) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpxmitpriv->pxmitbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_xmitbuf), 4);\n\n\tpxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;\n\n\tfor (i = 0; i < NR_XMITBUFF; i++) {\n\t\tINIT_LIST_HEAD(&pxmitbuf->list);\n\n\t\tpxmitbuf->priv_data = NULL;\n\t\tpxmitbuf->padapter = padapter;\n\t\tpxmitbuf->buf_tag = XMITBUF_DATA;\n\n\t\t \n\t\tres = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ), true);\n\t\tif (res == _FAIL) {\n\t\t\tmsleep(10);\n\t\t\tres = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ), true);\n\t\t\tif (res == _FAIL)\n\t\t\t\tgoto exit;\n\t\t}\n\n\t\tpxmitbuf->phead = pxmitbuf->pbuf;\n\t\tpxmitbuf->pend = pxmitbuf->pbuf + MAX_XMITBUF_SZ;\n\t\tpxmitbuf->len = 0;\n\t\tpxmitbuf->pdata = pxmitbuf->ptail = pxmitbuf->phead;\n\n\t\tpxmitbuf->flags = XMIT_VO_QUEUE;\n\n\t\tlist_add_tail(&pxmitbuf->list,\n\t\t\t      &pxmitpriv->free_xmitbuf_queue.queue);\n\t\t#ifdef DBG_XMIT_BUF\n\t\tpxmitbuf->no = i;\n\t\t#endif\n\n\t\tpxmitbuf++;\n\t}\n\n\tpxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;\n\n\t \n\tINIT_LIST_HEAD(&pxmitpriv->free_xframe_ext_queue.queue);\n\tspin_lock_init(&pxmitpriv->free_xframe_ext_queue.lock);\n\n\tpxmitpriv->xframe_ext_alloc_addr = vzalloc(NR_XMIT_EXTBUFF * sizeof(struct xmit_frame) + 4);\n\n\tif (!pxmitpriv->xframe_ext_alloc_addr) {\n\t\tpxmitpriv->xframe_ext = NULL;\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\tpxmitpriv->xframe_ext = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->xframe_ext_alloc_addr), 4);\n\tpxframe = (struct xmit_frame *)pxmitpriv->xframe_ext;\n\n\tfor (i = 0; i < NR_XMIT_EXTBUFF; i++) {\n\t\tINIT_LIST_HEAD(&pxframe->list);\n\n\t\tpxframe->padapter = padapter;\n\t\tpxframe->frame_tag = NULL_FRAMETAG;\n\n\t\tpxframe->pkt = NULL;\n\n\t\tpxframe->buf_addr = NULL;\n\t\tpxframe->pxmitbuf = NULL;\n\n\t\tpxframe->ext_tag = 1;\n\n\t\tlist_add_tail(&pxframe->list,\n\t\t\t      &pxmitpriv->free_xframe_ext_queue.queue);\n\n\t\tpxframe++;\n\t}\n\tpxmitpriv->free_xframe_ext_cnt = NR_XMIT_EXTBUFF;\n\n\t \n\tINIT_LIST_HEAD(&pxmitpriv->free_xmit_extbuf_queue.queue);\n\tspin_lock_init(&pxmitpriv->free_xmit_extbuf_queue.lock);\n\n\tpxmitpriv->pallocated_xmit_extbuf = vzalloc(NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);\n\n\tif (!pxmitpriv->pallocated_xmit_extbuf) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tpxmitpriv->pxmit_extbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_xmit_extbuf), 4);\n\n\tpxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;\n\n\tfor (i = 0; i < NR_XMIT_EXTBUFF; i++) {\n\t\tINIT_LIST_HEAD(&pxmitbuf->list);\n\n\t\tpxmitbuf->priv_data = NULL;\n\t\tpxmitbuf->padapter = padapter;\n\t\tpxmitbuf->buf_tag = XMITBUF_MGNT;\n\n\t\tres = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ, true);\n\t\tif (res == _FAIL) {\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tpxmitbuf->phead = pxmitbuf->pbuf;\n\t\tpxmitbuf->pend = pxmitbuf->pbuf + MAX_XMIT_EXTBUF_SZ;\n\t\tpxmitbuf->len = 0;\n\t\tpxmitbuf->pdata = pxmitbuf->ptail = pxmitbuf->phead;\n\n\t\tlist_add_tail(&pxmitbuf->list,\n\t\t\t      &pxmitpriv->free_xmit_extbuf_queue.queue);\n\t\t#ifdef DBG_XMIT_BUF_EXT\n\t\tpxmitbuf->no = i;\n\t\t#endif\n\t\tpxmitbuf++;\n\t}\n\n\tpxmitpriv->free_xmit_extbuf_cnt = NR_XMIT_EXTBUFF;\n\n\tfor (i = 0; i < CMDBUF_MAX; i++) {\n\t\tpxmitbuf = &pxmitpriv->pcmd_xmitbuf[i];\n\t\tif (pxmitbuf) {\n\t\t\tINIT_LIST_HEAD(&pxmitbuf->list);\n\n\t\t\tpxmitbuf->priv_data = NULL;\n\t\t\tpxmitbuf->padapter = padapter;\n\t\t\tpxmitbuf->buf_tag = XMITBUF_CMD;\n\n\t\t\tres = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, MAX_CMDBUF_SZ+XMITBUF_ALIGN_SZ, true);\n\t\t\tif (res == _FAIL) {\n\t\t\t\tres = _FAIL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tpxmitbuf->phead = pxmitbuf->pbuf;\n\t\t\tpxmitbuf->pend = pxmitbuf->pbuf + MAX_CMDBUF_SZ;\n\t\t\tpxmitbuf->len = 0;\n\t\t\tpxmitbuf->pdata = pxmitbuf->ptail = pxmitbuf->phead;\n\t\t\tpxmitbuf->alloc_sz = MAX_CMDBUF_SZ+XMITBUF_ALIGN_SZ;\n\t\t}\n\t}\n\n\tres = rtw_alloc_hwxmits(padapter);\n\tif (res == _FAIL)\n\t\tgoto exit;\n\trtw_init_hwxmits(pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);\n\n\tfor (i = 0; i < 4; i++)\n\t\tpxmitpriv->wmm_para_seq[i] = i;\n\n\tpxmitpriv->ack_tx = false;\n\tmutex_init(&pxmitpriv->ack_tx_mutex);\n\trtw_sctx_init(&pxmitpriv->ack_tx_ops, 0);\n\n\trtw_hal_init_xmit_priv(padapter);\n\nexit:\n\treturn res;\n}\n\nvoid _rtw_free_xmit_priv(struct xmit_priv *pxmitpriv)\n{\n\tint i;\n\tstruct adapter *padapter = pxmitpriv->adapter;\n\tstruct xmit_frame\t*pxmitframe = (struct xmit_frame *) pxmitpriv->pxmit_frame_buf;\n\tstruct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;\n\n\trtw_hal_free_xmit_priv(padapter);\n\n\tif (!pxmitpriv->pxmit_frame_buf)\n\t\treturn;\n\n\tfor (i = 0; i < NR_XMITFRAME; i++) {\n\t\trtw_os_xmit_complete(padapter, pxmitframe);\n\n\t\tpxmitframe++;\n\t}\n\n\tfor (i = 0; i < NR_XMITBUFF; i++) {\n\t\trtw_os_xmit_resource_free(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ), true);\n\n\t\tpxmitbuf++;\n\t}\n\n\tvfree(pxmitpriv->pallocated_frame_buf);\n\tvfree(pxmitpriv->pallocated_xmitbuf);\n\n\t \n\tpxmitframe = (struct xmit_frame *)pxmitpriv->xframe_ext;\n\tif (pxmitframe) {\n\t\tfor (i = 0; i < NR_XMIT_EXTBUFF; i++) {\n\t\t\trtw_os_xmit_complete(padapter, pxmitframe);\n\t\t\tpxmitframe++;\n\t\t}\n\t}\n\n\tvfree(pxmitpriv->xframe_ext_alloc_addr);\n\n\t \n\tpxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;\n\tfor (i = 0; i < NR_XMIT_EXTBUFF; i++) {\n\t\trtw_os_xmit_resource_free(padapter, pxmitbuf, (MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ), true);\n\n\t\tpxmitbuf++;\n\t}\n\n\tvfree(pxmitpriv->pallocated_xmit_extbuf);\n\n\tfor (i = 0; i < CMDBUF_MAX; i++) {\n\t\tpxmitbuf = &pxmitpriv->pcmd_xmitbuf[i];\n\t\tif (pxmitbuf)\n\t\t\trtw_os_xmit_resource_free(padapter, pxmitbuf, MAX_CMDBUF_SZ+XMITBUF_ALIGN_SZ, true);\n\t}\n\n\trtw_free_hwxmits(padapter);\n\n\tmutex_destroy(&pxmitpriv->ack_tx_mutex);\n}\n\nu8 query_ra_short_GI(struct sta_info *psta)\n{\n\tu8 sgi = false, sgi_20m = false, sgi_40m = false;\n\n\tsgi_20m = psta->htpriv.sgi_20m;\n\tsgi_40m = psta->htpriv.sgi_40m;\n\n\tswitch (psta->bw_mode) {\n\tcase CHANNEL_WIDTH_40:\n\t\tsgi = sgi_40m;\n\t\tbreak;\n\tcase CHANNEL_WIDTH_20:\n\tdefault:\n\t\tsgi = sgi_20m;\n\t\tbreak;\n\t}\n\n\treturn sgi;\n}\n\nstatic void update_attrib_vcs_info(struct adapter *padapter, struct xmit_frame *pxmitframe)\n{\n\tu32 sz;\n\tstruct pkt_attrib\t*pattrib = &pxmitframe->attrib;\n\t \n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\n\n\tif (pattrib->nr_frags != 1)\n\t\tsz = padapter->xmitpriv.frag_len;\n\telse  \n\t\tsz = pattrib->last_txcmdsz;\n\n\t \n\t \n\t \n\t \n\tif (pmlmeext->cur_wireless_mode < WIRELESS_11_24N  || padapter->registrypriv.wifi_spec) {\n\t\tif (sz > padapter->registrypriv.rts_thresh) {\n\t\t\tpattrib->vcs_mode = RTS_CTS;\n\t\t} else {\n\t\t\tif (pattrib->rtsen)\n\t\t\t\tpattrib->vcs_mode = RTS_CTS;\n\t\t\telse if (pattrib->cts2self)\n\t\t\t\tpattrib->vcs_mode = CTS_TO_SELF;\n\t\t\telse\n\t\t\t\tpattrib->vcs_mode = NONE_VCS;\n\t\t}\n\t} else {\n\t\twhile (true) {\n\t\t\t \n\t\t\tif ((pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_ATHEROS) && (pattrib->ampdu_en == true) &&\n\t\t\t\t(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)) {\n\t\t\t\tpattrib->vcs_mode = CTS_TO_SELF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (pattrib->rtsen || pattrib->cts2self) {\n\t\t\t\tif (pattrib->rtsen)\n\t\t\t\t\tpattrib->vcs_mode = RTS_CTS;\n\t\t\t\telse if (pattrib->cts2self)\n\t\t\t\t\tpattrib->vcs_mode = CTS_TO_SELF;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (pattrib->ht_en) {\n\t\t\t\tu8 HTOpMode = pmlmeinfo->HT_protection;\n\n\t\t\t\tif ((pmlmeext->cur_bwmode && (HTOpMode == 2 || HTOpMode == 3)) ||\n\t\t\t\t\t(!pmlmeext->cur_bwmode && HTOpMode == 3)) {\n\t\t\t\t\tpattrib->vcs_mode = RTS_CTS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (sz > padapter->registrypriv.rts_thresh) {\n\t\t\t\tpattrib->vcs_mode = RTS_CTS;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\n\t\t\t \n\t\t\tif (pattrib->ampdu_en == true) {\n\t\t\t\tpattrib->vcs_mode = RTS_CTS;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpattrib->vcs_mode = NONE_VCS;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (padapter->driver_vcs_en == 1)\n\t\tpattrib->vcs_mode = padapter->driver_vcs_type;\n}\n\nstatic void update_attrib_phy_info(struct adapter *padapter, struct pkt_attrib *pattrib, struct sta_info *psta)\n{\n\tstruct mlme_ext_priv *mlmeext = &padapter->mlmeextpriv;\n\n\tpattrib->rtsen = psta->rtsen;\n\tpattrib->cts2self = psta->cts2self;\n\n\tpattrib->mdata = 0;\n\tpattrib->eosp = 0;\n\tpattrib->triggered = 0;\n\tpattrib->ampdu_spacing = 0;\n\n\t \n\tpattrib->qos_en = psta->qos_option;\n\n\tpattrib->raid = psta->raid;\n\n\tpattrib->bwmode = min(mlmeext->cur_bwmode, psta->bw_mode);\n\n\tpattrib->sgi = query_ra_short_GI(psta);\n\n\tpattrib->ldpc = psta->ldpc;\n\tpattrib->stbc = psta->stbc;\n\n\tpattrib->ht_en = psta->htpriv.ht_option;\n\tpattrib->ch_offset = psta->htpriv.ch_offset;\n\tpattrib->ampdu_en = false;\n\n\tif (padapter->driver_ampdu_spacing != 0xFF)  \n\t\tpattrib->ampdu_spacing = padapter->driver_ampdu_spacing;\n\telse\n\t\tpattrib->ampdu_spacing = psta->htpriv.rx_ampdu_min_spacing;\n\n\tpattrib->retry_ctrl = false;\n}\n\nstatic s32 update_attrib_sec_info(struct adapter *padapter, struct pkt_attrib *pattrib, struct sta_info *psta)\n{\n\tsigned int res = _SUCCESS;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tsigned int bmcast = is_multicast_ether_addr(pattrib->ra);\n\n\tmemset(pattrib->dot118021x_UncstKey.skey,  0, 16);\n\tmemset(pattrib->dot11tkiptxmickey.skey,  0, 16);\n\tpattrib->mac_id = psta->mac_id;\n\n\tif (psta->ieee8021x_blocked == true) {\n\t\tpattrib->encrypt = 0;\n\n\t\tif ((pattrib->ether_type != 0x888e) && (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false)) {\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tGET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);\n\n\t\tswitch (psecuritypriv->dot11AuthAlgrthm) {\n\t\tcase dot11AuthAlgrthm_Open:\n\t\tcase dot11AuthAlgrthm_Shared:\n\t\tcase dot11AuthAlgrthm_Auto:\n\t\t\tpattrib->key_idx = (u8)psecuritypriv->dot11PrivacyKeyIndex;\n\t\t\tbreak;\n\t\tcase dot11AuthAlgrthm_8021X:\n\t\t\tif (bmcast)\n\t\t\t\tpattrib->key_idx = (u8)psecuritypriv->dot118021XGrpKeyid;\n\t\t\telse\n\t\t\t\tpattrib->key_idx = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpattrib->key_idx = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (((pattrib->encrypt == _WEP40_) || (pattrib->encrypt == _WEP104_)) && (pattrib->ether_type == 0x888e))\n\t\t\tpattrib->encrypt = _NO_PRIVACY_;\n\t}\n\n\tswitch (pattrib->encrypt) {\n\tcase _WEP40_:\n\tcase _WEP104_:\n\t\tpattrib->iv_len = 4;\n\t\tpattrib->icv_len = 4;\n\t\tWEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);\n\t\tbreak;\n\n\tcase _TKIP_:\n\t\tpattrib->iv_len = 8;\n\t\tpattrib->icv_len = 4;\n\n\t\tif (psecuritypriv->busetkipkey == _FAIL) {\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (bmcast)\n\t\t\tTKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);\n\t\telse\n\t\t\tTKIP_IV(pattrib->iv, psta->dot11txpn, 0);\n\n\t\tmemcpy(pattrib->dot11tkiptxmickey.skey, psta->dot11tkiptxmickey.skey, 16);\n\n\t\tbreak;\n\n\tcase _AES_:\n\n\t\tpattrib->iv_len = 8;\n\t\tpattrib->icv_len = 8;\n\n\t\tif (bmcast)\n\t\t\tAES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);\n\t\telse\n\t\t\tAES_IV(pattrib->iv, psta->dot11txpn, 0);\n\n\t\tbreak;\n\n\tdefault:\n\t\tpattrib->iv_len = 0;\n\t\tpattrib->icv_len = 0;\n\t\tbreak;\n\t}\n\n\tif (pattrib->encrypt > 0)\n\t\tmemcpy(pattrib->dot118021x_UncstKey.skey, psta->dot118021x_UncstKey.skey, 16);\n\n\tif (pattrib->encrypt &&\n\t\t((padapter->securitypriv.sw_encrypt) || (!psecuritypriv->hw_decrypted)))\n\t\tpattrib->bswenc = true;\n\telse\n\t\tpattrib->bswenc = false;\n\nexit:\n\n\treturn res;\n}\n\nu8 qos_acm(u8 acm_mask, u8 priority)\n{\n\tswitch (priority) {\n\tcase 0:\n\tcase 3:\n\t\tif (acm_mask & BIT(1))\n\t\t\tpriority = 1;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tif (acm_mask & BIT(2))\n\t\t\tpriority = 0;\n\t\tbreak;\n\tcase 6:\n\tcase 7:\n\t\tif (acm_mask & BIT(3))\n\t\t\tpriority = 5;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn priority;\n}\n\nstatic void set_qos(struct pkt_file *ppktfile, struct pkt_attrib *pattrib)\n{\n\tstruct ethhdr etherhdr;\n\tstruct iphdr ip_hdr;\n\ts32 UserPriority = 0;\n\n\t_rtw_open_pktfile(ppktfile->pkt, ppktfile);\n\t_rtw_pktfile_read(ppktfile, (unsigned char *)&etherhdr, ETH_HLEN);\n\n\t \n\tif (pattrib->ether_type == 0x0800) {\n\t\t_rtw_pktfile_read(ppktfile, (u8 *)&ip_hdr, sizeof(ip_hdr));\n\t\tUserPriority = ip_hdr.tos >> 5;\n\t}\n\tpattrib->priority = UserPriority;\n\tpattrib->hdrlen = WLAN_HDR_A3_QOS_LEN;\n\tpattrib->subtype = WIFI_QOS_DATA_TYPE;\n}\n\nstatic s32 update_attrib(struct adapter *padapter, struct sk_buff *pkt, struct pkt_attrib *pattrib)\n{\n\tstruct pkt_file pktfile;\n\tstruct sta_info *psta = NULL;\n\tstruct ethhdr etherhdr;\n\n\tsigned int bmcast;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\n\tsigned int res = _SUCCESS;\n\n\t_rtw_open_pktfile(pkt, &pktfile);\n\t_rtw_pktfile_read(&pktfile, (u8 *)&etherhdr, ETH_HLEN);\n\n\tpattrib->ether_type = ntohs(etherhdr.h_proto);\n\n\tmemcpy(pattrib->dst, &etherhdr.h_dest, ETH_ALEN);\n\tmemcpy(pattrib->src, &etherhdr.h_source, ETH_ALEN);\n\n\tif ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||\n\t\t(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {\n\t\tmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\n\t} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\n\t\tmemcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);\n\t\tmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\n\t} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\tmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\n\t\tmemcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);\n\t}\n\n\tpattrib->pktlen = pktfile.pkt_len;\n\n\tif (pattrib->ether_type == ETH_P_IP) {\n\t\t \n\t\t \n\n\t\tu8 tmp[24];\n\n\t\t_rtw_pktfile_read(&pktfile, &tmp[0], 24);\n\n\t\tpattrib->dhcp_pkt = 0;\n\t\tif (pktfile.pkt_len > 282) { \n\t\t\tif (pattrib->ether_type == ETH_P_IP) { \n\t\t\t\tif (((tmp[21] == 68) && (tmp[23] == 67)) ||\n\t\t\t\t\t((tmp[21] == 67) && (tmp[23] == 68))) {\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tpattrib->dhcp_pkt = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\t{\n\t\t\tstruct iphdr *piphdr = (struct iphdr *)tmp;\n\n\t\t\tpattrib->icmp_pkt = 0;\n\t\t\tif (piphdr->protocol == 0x1)  \n\t\t\t\tpattrib->icmp_pkt = 1;\n\t\t}\n\t} else if (pattrib->ether_type == 0x888e) {\n\t\tnetdev_dbg(padapter->pnetdev, \"send eapol packet\\n\");\n\t}\n\n\tif ((pattrib->ether_type == 0x888e) || (pattrib->dhcp_pkt == 1))\n\t\trtw_set_scan_deny(padapter, 3000);\n\n\t \n\tif (pattrib->icmp_pkt == 1)\n\t\trtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_LEAVE, 1);\n\telse if (pattrib->dhcp_pkt == 1)\n\t\trtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SPECIAL_PACKET, 1);\n\n\tbmcast = is_multicast_ether_addr(pattrib->ra);\n\n\t \n\tif (bmcast) {\n\t\tpsta = rtw_get_bcmc_stainfo(padapter);\n\t} else {\n\t\tpsta = rtw_get_stainfo(pstapriv, pattrib->ra);\n\t\tif (!psta)\t{  \n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t} else if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) && (!(psta->state & _FW_LINKED))) {\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (!psta) {\n\t\t \n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tif (!(psta->state & _FW_LINKED))\n\t\treturn _FAIL;\n\n\t \n\tif (update_attrib_sec_info(padapter, pattrib, psta) == _FAIL) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tupdate_attrib_phy_info(padapter, pattrib, psta);\n\n\tpattrib->psta = psta;\n\t \n\n\tpattrib->pctrl = 0;\n\n\tpattrib->ack_policy = 0;\n\t \n\tpattrib->pkt_hdrlen = ETH_HLEN; \n\n\tpattrib->hdrlen = WLAN_HDR_A3_LEN;\n\tpattrib->subtype = WIFI_DATA_TYPE;\n\tpattrib->priority = 0;\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE)) {\n\t\tif (pattrib->qos_en)\n\t\t\tset_qos(&pktfile, pattrib);\n\t} else {\n\t\tif (pqospriv->qos_option) {\n\t\t\tset_qos(&pktfile, pattrib);\n\n\t\t\tif (pmlmepriv->acm_mask != 0)\n\t\t\t\tpattrib->priority = qos_acm(pmlmepriv->acm_mask, pattrib->priority);\n\t\t}\n\t}\n\n\t \n\nexit:\n\treturn res;\n}\n\nstatic s32 xmitframe_addmic(struct adapter *padapter, struct xmit_frame *pxmitframe)\n{\n\tsigned int\t\t\tcurfragnum, length;\n\tu8 *pframe, *payload, mic[8];\n\tstruct mic_data micdata;\n\tstruct pkt_attrib *pattrib = &pxmitframe->attrib;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tu8 priority[4] = {0x0, 0x0, 0x0, 0x0};\n\tu8 hw_hdr_offset = 0;\n\tsigned int bmcst = is_multicast_ether_addr(pattrib->ra);\n\n\thw_hdr_offset = TXDESC_OFFSET;\n\n\tif (pattrib->encrypt == _TKIP_) {\n\t\t \n\t\t{\n\t\t\tu8 null_key[16] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};\n\n\t\t\tpframe = pxmitframe->buf_addr + hw_hdr_offset;\n\n\t\t\tif (bmcst) {\n\t\t\t\tif (!memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16))\n\t\t\t\t\treturn _FAIL;\n\t\t\t\t \n\t\t\t\trtw_secmicsetkey(&micdata, psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey);\n\t\t\t} else {\n\t\t\t\tif (!memcmp(&pattrib->dot11tkiptxmickey.skey[0], null_key, 16))\n\t\t\t\t\treturn _FAIL;\n\t\t\t\t \n\t\t\t\trtw_secmicsetkey(&micdata, &pattrib->dot11tkiptxmickey.skey[0]);\n\t\t\t}\n\n\t\t\tif (pframe[1]&1) {    \n\t\t\t\trtw_secmicappend(&micdata, &pframe[16], 6);   \n\t\t\t\tif (pframe[1]&2)   \n\t\t\t\t\trtw_secmicappend(&micdata, &pframe[24], 6);\n\t\t\t\telse\n\t\t\t\t\trtw_secmicappend(&micdata, &pframe[10], 6);\n\t\t\t} else {\t \n\t\t\t\trtw_secmicappend(&micdata, &pframe[4], 6);    \n\t\t\t\tif (pframe[1]&2)   \n\t\t\t\t\trtw_secmicappend(&micdata, &pframe[16], 6);\n\t\t\t\telse\n\t\t\t\t\trtw_secmicappend(&micdata, &pframe[10], 6);\n\t\t\t}\n\n\t\t\tif (pattrib->qos_en)\n\t\t\t\tpriority[0] = (u8)pxmitframe->attrib.priority;\n\n\t\t\trtw_secmicappend(&micdata, &priority[0], 4);\n\n\t\t\tpayload = pframe;\n\n\t\t\tfor (curfragnum = 0; curfragnum < pattrib->nr_frags; curfragnum++) {\n\t\t\t\tpayload = (u8 *)round_up((SIZE_PTR)(payload), 4);\n\t\t\t\tpayload = payload+pattrib->hdrlen+pattrib->iv_len;\n\n\t\t\t\tif ((curfragnum+1) == pattrib->nr_frags) {\n\t\t\t\t\tlength = pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);\n\t\t\t\t\trtw_secmicappend(&micdata, payload, length);\n\t\t\t\t\tpayload = payload+length;\n\t\t\t\t} else {\n\t\t\t\t\tlength = pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);\n\t\t\t\t\trtw_secmicappend(&micdata, payload, length);\n\t\t\t\t\tpayload = payload+length+pattrib->icv_len;\n\t\t\t\t}\n\t\t\t}\n\t\t\trtw_secgetmic(&micdata, &mic[0]);\n\t\t\t \n\n\t\t\tmemcpy(payload, &mic[0], 8);\n\t\t\tpattrib->last_txcmdsz += 8;\n\t\t\t}\n\t}\n\treturn _SUCCESS;\n}\n\nstatic s32 xmitframe_swencrypt(struct adapter *padapter, struct xmit_frame *pxmitframe)\n{\n\tstruct\tpkt_attrib\t *pattrib = &pxmitframe->attrib;\n\n\tif (pattrib->bswenc) {\n\t\tswitch (pattrib->encrypt) {\n\t\tcase _WEP40_:\n\t\tcase _WEP104_:\n\t\t\trtw_wep_encrypt(padapter, (u8 *)pxmitframe);\n\t\t\tbreak;\n\t\tcase _TKIP_:\n\t\t\trtw_tkip_encrypt(padapter, (u8 *)pxmitframe);\n\t\t\tbreak;\n\t\tcase _AES_:\n\t\t\trtw_aes_encrypt(padapter, (u8 *)pxmitframe);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn _SUCCESS;\n}\n\ns32 rtw_make_wlanhdr(struct adapter *padapter, u8 *hdr, struct pkt_attrib *pattrib)\n{\n\tu16 *qc;\n\n\tstruct ieee80211_hdr *pwlanhdr = (struct ieee80211_hdr *)hdr;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\n\tu8 qos_option = false;\n\tsigned int res = _SUCCESS;\n\t__le16 *fctrl = &pwlanhdr->frame_control;\n\n\tmemset(hdr, 0, WLANHDR_OFFSET);\n\n\tSetFrameSubType(fctrl, pattrib->subtype);\n\n\tif (pattrib->subtype & WIFI_DATA_TYPE) {\n\t\tif (check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == true) {\n\t\t\t \n\n\t\t\t{\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tSetToDs(fctrl);\n\t\t\t\tmemcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);\n\t\t\t\tmemcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);\n\t\t\t\tmemcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);\n\t\t\t}\n\n\t\t\tif (pqospriv->qos_option)\n\t\t\t\tqos_option = true;\n\t\t} else if (check_fwstate(pmlmepriv,  WIFI_AP_STATE) == true) {\n\t\t\t \n\t\t\tSetFrDs(fctrl);\n\t\t\tmemcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);\n\t\t\tmemcpy(pwlanhdr->addr2, get_bssid(pmlmepriv), ETH_ALEN);\n\t\t\tmemcpy(pwlanhdr->addr3, pattrib->src, ETH_ALEN);\n\n\t\t\tif (pattrib->qos_en)\n\t\t\t\tqos_option = true;\n\t\t} else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||\n\t\t(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {\n\t\t\tmemcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);\n\t\t\tmemcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);\n\t\t\tmemcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);\n\n\t\t\tif (pattrib->qos_en)\n\t\t\t\tqos_option = true;\n\t\t} else {\n\t\t\tres = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (pattrib->mdata)\n\t\t\tSetMData(fctrl);\n\n\t\tif (pattrib->encrypt)\n\t\t\tSetPrivacy(fctrl);\n\n\t\tif (qos_option) {\n\t\t\tqc = (unsigned short *)(hdr + pattrib->hdrlen - 2);\n\n\t\t\tif (pattrib->priority)\n\t\t\t\tSetPriority(qc, pattrib->priority);\n\n\t\t\tSetEOSP(qc, pattrib->eosp);\n\n\t\t\tSetAckpolicy(qc, pattrib->ack_policy);\n\t\t}\n\n\t\t \n\n\t\t \n\t\t{\n\t\t\tstruct sta_info *psta;\n\n\t\t\tpsta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);\n\t\t\tif (pattrib->psta != psta)\n\t\t\t\treturn _FAIL;\n\n\t\t\tif (!psta)\n\t\t\t\treturn _FAIL;\n\n\t\t\tif (!(psta->state & _FW_LINKED))\n\t\t\t\treturn _FAIL;\n\n\t\t\tif (psta) {\n\t\t\t\tpsta->sta_xmitpriv.txseq_tid[pattrib->priority]++;\n\t\t\t\tpsta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;\n\t\t\t\tpattrib->seqnum = psta->sta_xmitpriv.txseq_tid[pattrib->priority];\n\n\t\t\t\tSetSeqNum(hdr, pattrib->seqnum);\n\n\t\t\t\t \n\t\t\t\tif (pattrib->ht_en && psta->htpriv.ampdu_enable)\n\t\t\t\t\tif (psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))\n\t\t\t\t\t\tpattrib->ampdu_en = true;\n\n\t\t\t\t \n\t\t\t\tif (pattrib->ampdu_en == true) {\n\t\t\t\t\tu16 tx_seq;\n\n\t\t\t\t\ttx_seq = psta->BA_starting_seqctrl[pattrib->priority & 0x0f];\n\n\t\t\t\t\t \n\t\t\t\t\tif (SN_LESS(pattrib->seqnum, tx_seq)) {\n\t\t\t\t\t\tpattrib->ampdu_en = false; \n\t\t\t\t\t} else if (SN_EQUAL(pattrib->seqnum, tx_seq)) {\n\t\t\t\t\t\tpsta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (tx_seq+1)&0xfff;\n\n\t\t\t\t\t\tpattrib->ampdu_en = true; \n\t\t\t\t\t} else {\n\t\t\t\t\t\tpsta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (pattrib->seqnum+1)&0xfff;\n\t\t\t\t\t\tpattrib->ampdu_en = true; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t}\n\nexit:\n\treturn res;\n}\n\ns32 rtw_txframes_pending(struct adapter *padapter)\n{\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\treturn ((!list_empty(&pxmitpriv->be_pending.queue)) ||\n\t\t\t (!list_empty(&pxmitpriv->bk_pending.queue)) ||\n\t\t\t (!list_empty(&pxmitpriv->vi_pending.queue)) ||\n\t\t\t (!list_empty(&pxmitpriv->vo_pending.queue)));\n}\n\n \nu32 rtw_calculate_wlan_pkt_size_by_attribue(struct pkt_attrib *pattrib)\n{\n\tu32 len = 0;\n\n\tlen = pattrib->hdrlen + pattrib->iv_len;  \n\tlen += SNAP_SIZE + sizeof(u16);  \n\tlen += pattrib->pktlen;\n\tif (pattrib->encrypt == _TKIP_)\n\t\tlen += 8;  \n\tlen += ((pattrib->bswenc) ? pattrib->icv_len : 0);  \n\n\treturn len;\n}\n\n \ns32 rtw_xmitframe_coalesce(struct adapter *padapter, struct sk_buff *pkt, struct xmit_frame *pxmitframe)\n{\n\tstruct pkt_file pktfile;\n\n\ts32 frg_inx, frg_len, mpdu_len, llc_sz, mem_sz;\n\n\tSIZE_PTR addr;\n\n\tu8 *pframe, *mem_start;\n\tu8 hw_hdr_offset;\n\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tstruct pkt_attrib\t*pattrib = &pxmitframe->attrib;\n\n\tu8 *pbuf_start;\n\n\ts32 bmcst = is_multicast_ether_addr(pattrib->ra);\n\ts32 res = _SUCCESS;\n\n\tif (!pxmitframe->buf_addr)\n\t\treturn _FAIL;\n\n\tpbuf_start = pxmitframe->buf_addr;\n\n\thw_hdr_offset = TXDESC_OFFSET;\n\tmem_start = pbuf_start +\thw_hdr_offset;\n\n\tif (rtw_make_wlanhdr(padapter, mem_start, pattrib) == _FAIL) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\t_rtw_open_pktfile(pkt, &pktfile);\n\t_rtw_pktfile_read(&pktfile, NULL, pattrib->pkt_hdrlen);\n\n\tfrg_inx = 0;\n\tfrg_len = pxmitpriv->frag_len - 4; \n\n\twhile (1) {\n\t\tllc_sz = 0;\n\n\t\tmpdu_len = frg_len;\n\n\t\tpframe = mem_start;\n\n\t\tSetMFrag(mem_start);\n\n\t\tpframe += pattrib->hdrlen;\n\t\tmpdu_len -= pattrib->hdrlen;\n\n\t\t \n\t\tif (pattrib->iv_len) {\n\t\t\tmemcpy(pframe, pattrib->iv, pattrib->iv_len);\n\n\t\t\tpframe += pattrib->iv_len;\n\n\t\t\tmpdu_len -= pattrib->iv_len;\n\t\t}\n\n\t\tif (frg_inx == 0) {\n\t\t\tllc_sz = rtw_put_snap(pframe, pattrib->ether_type);\n\t\t\tpframe += llc_sz;\n\t\t\tmpdu_len -= llc_sz;\n\t\t}\n\n\t\tif ((pattrib->icv_len > 0) && (pattrib->bswenc))\n\t\t\tmpdu_len -= pattrib->icv_len;\n\n\t\tif (bmcst) {\n\t\t\t \n\t\t\tmem_sz = _rtw_pktfile_read(&pktfile, pframe, pattrib->pktlen);\n\t\t} else {\n\t\t\tmem_sz = _rtw_pktfile_read(&pktfile, pframe, mpdu_len);\n\t\t}\n\n\t\tpframe += mem_sz;\n\n\t\tif ((pattrib->icv_len > 0) && (pattrib->bswenc)) {\n\t\t\tmemcpy(pframe, pattrib->icv, pattrib->icv_len);\n\t\t\tpframe += pattrib->icv_len;\n\t\t}\n\n\t\tfrg_inx++;\n\n\t\tif (bmcst || (rtw_endofpktfile(&pktfile) == true)) {\n\t\t\tpattrib->nr_frags = frg_inx;\n\n\t\t\tpattrib->last_txcmdsz = pattrib->hdrlen + pattrib->iv_len + ((pattrib->nr_frags == 1) ? llc_sz:0) +\n\t\t\t\t\t((pattrib->bswenc) ? pattrib->icv_len : 0) + mem_sz;\n\n\t\t\tClearMFrag(mem_start);\n\n\t\t\tbreak;\n\t\t}\n\n\t\taddr = (SIZE_PTR)(pframe);\n\n\t\tmem_start = (unsigned char *)round_up(addr, 4) + hw_hdr_offset;\n\t\tmemcpy(mem_start, pbuf_start + hw_hdr_offset, pattrib->hdrlen);\n\t}\n\n\tif (xmitframe_addmic(padapter, pxmitframe) == _FAIL) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\txmitframe_swencrypt(padapter, pxmitframe);\n\n\tif (bmcst == false)\n\t\tupdate_attrib_vcs_info(padapter, pxmitframe);\n\telse\n\t\tpattrib->vcs_mode = NONE_VCS;\n\nexit:\n\treturn res;\n}\n\n \ns32 rtw_mgmt_xmitframe_coalesce(struct adapter *padapter, struct sk_buff *pkt, struct xmit_frame *pxmitframe)\n{\n\tu8 *pframe, *mem_start = NULL, *tmp_buf = NULL;\n\tu8 subtype;\n\tstruct sta_info *psta = NULL;\n\tstruct pkt_attrib *pattrib = &pxmitframe->attrib;\n\ts32 bmcst = is_multicast_ether_addr(pattrib->ra);\n\tu8 *BIP_AAD = NULL;\n\tu8 *MGMT_body = NULL;\n\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct ieee80211_hdr\t*pwlanhdr;\n\tu8 MME[_MME_IE_LENGTH_];\n\tu32 ori_len;\n\n\tmem_start = pframe = (u8 *)(pxmitframe->buf_addr) + TXDESC_OFFSET;\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tori_len = BIP_AAD_SIZE+pattrib->pktlen;\n\ttmp_buf = BIP_AAD = rtw_zmalloc(ori_len);\n\tsubtype = GetFrameSubType(pframe);  \n\n\tif (!BIP_AAD)\n\t\treturn _FAIL;\n\n\tspin_lock_bh(&padapter->security_key_mutex);\n\n\t \n\tif (!check_fwstate(pmlmepriv, WIFI_STATION_STATE) || !check_fwstate(pmlmepriv, _FW_LINKED))\n\t\tgoto xmitframe_coalesce_success;\n\n\t \n\tif (!padapter->securitypriv.binstallBIPkey)\n\t\tgoto xmitframe_coalesce_success;\n\n\t \n\tif (bmcst) {\n\t\tint frame_body_len;\n\t\tu8 mic[16];\n\n\t\tmemset(MME, 0, 18);\n\n\t\t \n\t\tif (GetFrameSubType(pframe) != WIFI_DEAUTH && GetFrameSubType(pframe) != WIFI_DISASSOC)\n\t\t\tgoto xmitframe_coalesce_fail;\n\n\t\tMGMT_body = pframe + sizeof(struct ieee80211_hdr_3addr);\n\t\tpframe += pattrib->pktlen;\n\n\t\t \n\t\tMME[0] = padapter->securitypriv.dot11wBIPKeyid;\n\t\t \n\t\tmemcpy(&MME[2], &pmlmeext->mgnt_80211w_IPN, 6);\n\t\t \n\t\tpmlmeext->mgnt_80211w_IPN++;\n\n\t\t \n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_MMIE, 16,\n\t\t\t\t    MME, &pattrib->pktlen);\n\t\tpattrib->last_txcmdsz = pattrib->pktlen;\n\t\t \n\t\tframe_body_len = pattrib->pktlen - sizeof(struct ieee80211_hdr_3addr);\n\n\t\t \n\t\tmemcpy(BIP_AAD, &pwlanhdr->frame_control, 2);\n\t\tClearRetry(BIP_AAD);\n\t\tClearPwrMgt(BIP_AAD);\n\t\tClearMData(BIP_AAD);\n\t\t \n\t\tmemcpy(BIP_AAD+2, pwlanhdr->addr1, 18);\n\t\t \n\t\tmemcpy(BIP_AAD+BIP_AAD_SIZE, MGMT_body, frame_body_len);\n\t\t \n\t\tif (omac1_aes_128(padapter->securitypriv.dot11wBIPKey[padapter->securitypriv.dot11wBIPKeyid].skey\n\t\t\t, BIP_AAD, BIP_AAD_SIZE+frame_body_len, mic))\n\t\t\tgoto xmitframe_coalesce_fail;\n\n\t\t \n\t\tmemcpy(pframe-8, mic, 8);\n\t} else {  \n\t\t \n\t\tif (subtype == WIFI_DEAUTH || subtype == WIFI_DISASSOC ||\n\t\t\tsubtype == WIFI_REASSOCREQ || subtype == WIFI_ACTION) {\n\t\t\tif (pattrib->psta)\n\t\t\t\tpsta = pattrib->psta;\n\t\t\telse\n\t\t\t\tpsta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);\n\n\t\t\tif (!psta)\n\t\t\t\tgoto xmitframe_coalesce_fail;\n\n\t\t\tif (!(psta->state & _FW_LINKED) || !pxmitframe->buf_addr)\n\t\t\t\tgoto xmitframe_coalesce_fail;\n\n\t\t\t \n\t\t\tif (subtype == WIFI_ACTION &&\n\t\t\t(pframe[WLAN_HDR_A3_LEN] == RTW_WLAN_CATEGORY_PUBLIC ||\n\t\t\tpframe[WLAN_HDR_A3_LEN] == RTW_WLAN_CATEGORY_HT ||\n\t\t\tpframe[WLAN_HDR_A3_LEN] == RTW_WLAN_CATEGORY_UNPROTECTED_WNM ||\n\t\t\tpframe[WLAN_HDR_A3_LEN] == RTW_WLAN_CATEGORY_SELF_PROTECTED  ||\n\t\t\tpframe[WLAN_HDR_A3_LEN] == RTW_WLAN_CATEGORY_P2P))\n\t\t\t\tgoto xmitframe_coalesce_fail;\n\t\t\t \n\t\t\tif (pattrib->encrypt > 0)\n\t\t\t\tmemcpy(pattrib->dot118021x_UncstKey.skey, psta->dot118021x_UncstKey.skey, 16);\n\t\t\t \n\t\t\tmemcpy(tmp_buf, pframe, pattrib->pktlen);\n\t\t\t \n\t\t\tpframe += pattrib->hdrlen;\n\n\t\t\t \n\t\t\tpattrib->iv_len = 8;\n\t\t\t \n\t\t\tpattrib->icv_len = 8;\n\n\t\t\tswitch (pattrib->encrypt) {\n\t\t\tcase _AES_:\n\t\t\t\t\t \n\t\t\t\t\tAES_IV(pattrib->iv, psta->dot11wtxpn, 0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto xmitframe_coalesce_fail;\n\t\t\t}\n\t\t\t \n\t\t\tmemcpy(pframe, pattrib->iv, pattrib->iv_len);\n\t\t\tpframe += pattrib->iv_len;\n\t\t\t \n\t\t\tmemcpy(pframe, tmp_buf+pattrib->hdrlen, pattrib->pktlen-pattrib->hdrlen);\n\t\t\t \n\t\t\tpframe += pattrib->pktlen-pattrib->hdrlen;\n\t\t\t \n\t\t\tpattrib->pktlen += pattrib->iv_len;\n\t\t\tif ((pattrib->icv_len > 0) && (pattrib->bswenc)) {\n\t\t\t\tmemcpy(pframe, pattrib->icv, pattrib->icv_len);\n\t\t\t\tpframe += pattrib->icv_len;\n\t\t\t}\n\t\t\t \n\t\t\tpattrib->pktlen += pattrib->icv_len;\n\t\t\t \n\t\t\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\t\t\t \n\t\t\tSetPrivacy(mem_start);\n\t\t\t \n\t\t\txmitframe_swencrypt(padapter, pxmitframe);\n\t\t}\n\t}\n\nxmitframe_coalesce_success:\n\tspin_unlock_bh(&padapter->security_key_mutex);\n\tkfree(BIP_AAD);\n\treturn _SUCCESS;\n\nxmitframe_coalesce_fail:\n\tspin_unlock_bh(&padapter->security_key_mutex);\n\tkfree(BIP_AAD);\n\treturn _FAIL;\n}\n\n \ns32 rtw_put_snap(u8 *data, u16 h_proto)\n{\n\tstruct ieee80211_snap_hdr *snap;\n\tu8 *oui;\n\n\tsnap = (struct ieee80211_snap_hdr *)data;\n\tsnap->dsap = 0xaa;\n\tsnap->ssap = 0xaa;\n\tsnap->ctrl = 0x03;\n\n\tif (h_proto == 0x8137 || h_proto == 0x80f3)\n\t\toui = P802_1H_OUI;\n\telse\n\t\toui = RFC1042_OUI;\n\n\tsnap->oui[0] = oui[0];\n\tsnap->oui[1] = oui[1];\n\tsnap->oui[2] = oui[2];\n\n\t*(__be16 *)(data + SNAP_SIZE) = htons(h_proto);\n\n\treturn SNAP_SIZE + sizeof(u16);\n}\n\nvoid rtw_update_protection(struct adapter *padapter, u8 *ie, uint ie_len)\n{\n\tuint\tprotection;\n\tu8 *perp;\n\tsigned int\t erp_len;\n\tstruct\txmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct\tregistry_priv *pregistrypriv = &padapter->registrypriv;\n\n\tswitch (pxmitpriv->vcs_setting) {\n\tcase DISABLE_VCS:\n\t\tpxmitpriv->vcs = NONE_VCS;\n\t\tbreak;\n\n\tcase ENABLE_VCS:\n\t\tbreak;\n\n\tcase AUTO_VCS:\n\tdefault:\n\t\tperp = rtw_get_ie(ie, WLAN_EID_ERP_INFO, &erp_len, ie_len);\n\t\tif (!perp) {\n\t\t\tpxmitpriv->vcs = NONE_VCS;\n\t\t} else {\n\t\t\tprotection = (*(perp + 2)) & BIT(1);\n\t\t\tif (protection) {\n\t\t\t\tif (pregistrypriv->vcs_type == RTS_CTS)\n\t\t\t\t\tpxmitpriv->vcs = RTS_CTS;\n\t\t\t\telse\n\t\t\t\t\tpxmitpriv->vcs = CTS_TO_SELF;\n\t\t\t} else {\n\t\t\t\tpxmitpriv->vcs = NONE_VCS;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n}\n\nvoid rtw_count_tx_stats(struct adapter *padapter, struct xmit_frame *pxmitframe, int sz)\n{\n\tstruct sta_info *psta = NULL;\n\tstruct stainfo_stats *pstats = NULL;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tu8 pkt_num = 1;\n\n\tif ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG) {\n\t\tpkt_num = pxmitframe->agg_num;\n\n\t\tpmlmepriv->LinkDetectInfo.NumTxOkInPeriod += pkt_num;\n\n\t\tpxmitpriv->tx_pkts += pkt_num;\n\n\t\tpxmitpriv->tx_bytes += sz;\n\n\t\tpsta = pxmitframe->attrib.psta;\n\t\tif (psta) {\n\t\t\tpstats = &psta->sta_stats;\n\n\t\t\tpstats->tx_pkts += pkt_num;\n\n\t\t\tpstats->tx_bytes += sz;\n\t\t}\n\t}\n}\n\nstatic struct xmit_buf *__rtw_alloc_cmd_xmitbuf(struct xmit_priv *pxmitpriv,\n\t\tenum cmdbuf_type buf_type)\n{\n\tstruct xmit_buf *pxmitbuf =  NULL;\n\n\tpxmitbuf = &pxmitpriv->pcmd_xmitbuf[buf_type];\n\tif (pxmitbuf) {\n\t\tpxmitbuf->priv_data = NULL;\n\n\t\tpxmitbuf->len = 0;\n\t\tpxmitbuf->pdata = pxmitbuf->ptail = pxmitbuf->phead;\n\t\tpxmitbuf->agg_num = 0;\n\t\tpxmitbuf->pg_num = 0;\n\n\t\tif (pxmitbuf->sctx)\n\t\t\trtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_ALLOC);\n\t}\n\n\treturn pxmitbuf;\n}\n\nstruct xmit_frame *__rtw_alloc_cmdxmitframe(struct xmit_priv *pxmitpriv,\n\t\tenum cmdbuf_type buf_type)\n{\n\tstruct xmit_frame\t\t*pcmdframe;\n\tstruct xmit_buf\t\t*pxmitbuf;\n\n\tpcmdframe = rtw_alloc_xmitframe(pxmitpriv);\n\tif (!pcmdframe)\n\t\treturn NULL;\n\n\tpxmitbuf = __rtw_alloc_cmd_xmitbuf(pxmitpriv, buf_type);\n\tif (!pxmitbuf) {\n\t\trtw_free_xmitframe(pxmitpriv, pcmdframe);\n\t\treturn NULL;\n\t}\n\n\tpcmdframe->frame_tag = MGNT_FRAMETAG;\n\n\tpcmdframe->pxmitbuf = pxmitbuf;\n\n\tpcmdframe->buf_addr = pxmitbuf->pbuf;\n\n\tpxmitbuf->priv_data = pcmdframe;\n\n\treturn pcmdframe;\n}\n\nstruct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv)\n{\n\tunsigned long irqL;\n\tstruct xmit_buf *pxmitbuf =  NULL;\n\tstruct list_head *plist, *phead;\n\tstruct __queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;\n\n\tspin_lock_irqsave(&pfree_queue->lock, irqL);\n\n\tif (list_empty(&pfree_queue->queue)) {\n\t\tpxmitbuf = NULL;\n\t} else {\n\t\tphead = get_list_head(pfree_queue);\n\n\t\tplist = get_next(phead);\n\n\t\tpxmitbuf = container_of(plist, struct xmit_buf, list);\n\n\t\tlist_del_init(&pxmitbuf->list);\n\t}\n\n\tif (pxmitbuf) {\n\t\tpxmitpriv->free_xmit_extbuf_cnt--;\n\n\t\tpxmitbuf->priv_data = NULL;\n\n\t\tpxmitbuf->len = 0;\n\t\tpxmitbuf->pdata = pxmitbuf->ptail = pxmitbuf->phead;\n\t\tpxmitbuf->agg_num = 1;\n\n\t\tif (pxmitbuf->sctx)\n\t\t\trtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_ALLOC);\n\t}\n\n\tspin_unlock_irqrestore(&pfree_queue->lock, irqL);\n\n\treturn pxmitbuf;\n}\n\ns32 rtw_free_xmitbuf_ext(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)\n{\n\tunsigned long irqL;\n\tstruct __queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;\n\n\tif (!pxmitbuf)\n\t\treturn _FAIL;\n\n\tspin_lock_irqsave(&pfree_queue->lock, irqL);\n\n\tlist_del_init(&pxmitbuf->list);\n\n\tlist_add_tail(&pxmitbuf->list, get_list_head(pfree_queue));\n\tpxmitpriv->free_xmit_extbuf_cnt++;\n\n\tspin_unlock_irqrestore(&pfree_queue->lock, irqL);\n\n\treturn _SUCCESS;\n}\n\nstruct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv)\n{\n\tunsigned long irqL;\n\tstruct xmit_buf *pxmitbuf =  NULL;\n\tstruct list_head *plist, *phead;\n\tstruct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;\n\n\tspin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);\n\n\tif (list_empty(&pfree_xmitbuf_queue->queue)) {\n\t\tpxmitbuf = NULL;\n\t} else {\n\t\tphead = get_list_head(pfree_xmitbuf_queue);\n\n\t\tplist = get_next(phead);\n\n\t\tpxmitbuf = container_of(plist, struct xmit_buf, list);\n\n\t\tlist_del_init(&pxmitbuf->list);\n\t}\n\n\tif (pxmitbuf) {\n\t\tpxmitpriv->free_xmitbuf_cnt--;\n\n\t\tpxmitbuf->priv_data = NULL;\n\n\t\tpxmitbuf->len = 0;\n\t\tpxmitbuf->pdata = pxmitbuf->ptail = pxmitbuf->phead;\n\t\tpxmitbuf->agg_num = 0;\n\t\tpxmitbuf->pg_num = 0;\n\n\t\tif (pxmitbuf->sctx)\n\t\t\trtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_ALLOC);\n\t}\n\n\tspin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);\n\n\treturn pxmitbuf;\n}\n\ns32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)\n{\n\tunsigned long irqL;\n\tstruct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;\n\n\tif (!pxmitbuf)\n\t\treturn _FAIL;\n\n\tif (pxmitbuf->sctx)\n\t\trtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_FREE);\n\n\tif (pxmitbuf->buf_tag == XMITBUF_CMD) {\n\t} else if (pxmitbuf->buf_tag == XMITBUF_MGNT) {\n\t\trtw_free_xmitbuf_ext(pxmitpriv, pxmitbuf);\n\t} else {\n\t\tspin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);\n\n\t\tlist_del_init(&pxmitbuf->list);\n\n\t\tlist_add_tail(&pxmitbuf->list,\n\t\t\t      get_list_head(pfree_xmitbuf_queue));\n\n\t\tpxmitpriv->free_xmitbuf_cnt++;\n\t\tspin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);\n\t}\n\treturn _SUCCESS;\n}\n\nstatic void rtw_init_xmitframe(struct xmit_frame *pxframe)\n{\n\tif (pxframe) {  \n\t\tpxframe->buf_addr = NULL;\n\t\tpxframe->pxmitbuf = NULL;\n\n\t\tmemset(&pxframe->attrib, 0, sizeof(struct pkt_attrib));\n\n\t\tpxframe->frame_tag = DATA_FRAMETAG;\n\n\t\tpxframe->pg_num = 1;\n\t\tpxframe->agg_num = 1;\n\t\tpxframe->ack_report = 0;\n\t}\n}\n\n \nstruct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv) \n{\n\t \n\n\tstruct xmit_frame *pxframe = NULL;\n\tstruct list_head *plist, *phead;\n\tstruct __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;\n\n\tspin_lock_bh(&pfree_xmit_queue->lock);\n\n\tif (list_empty(&pfree_xmit_queue->queue)) {\n\t\tpxframe =  NULL;\n\t} else {\n\t\tphead = get_list_head(pfree_xmit_queue);\n\n\t\tplist = get_next(phead);\n\n\t\tpxframe = container_of(plist, struct xmit_frame, list);\n\n\t\tlist_del_init(&pxframe->list);\n\t\tpxmitpriv->free_xmitframe_cnt--;\n\t}\n\n\tspin_unlock_bh(&pfree_xmit_queue->lock);\n\n\trtw_init_xmitframe(pxframe);\n\treturn pxframe;\n}\n\nstruct xmit_frame *rtw_alloc_xmitframe_ext(struct xmit_priv *pxmitpriv)\n{\n\tstruct xmit_frame *pxframe = NULL;\n\tstruct list_head *plist, *phead;\n\tstruct __queue *queue = &pxmitpriv->free_xframe_ext_queue;\n\n\tspin_lock_bh(&queue->lock);\n\n\tif (list_empty(&queue->queue)) {\n\t\tpxframe =  NULL;\n\t} else {\n\t\tphead = get_list_head(queue);\n\t\tplist = get_next(phead);\n\t\tpxframe = container_of(plist, struct xmit_frame, list);\n\n\t\tlist_del_init(&pxframe->list);\n\t\tpxmitpriv->free_xframe_ext_cnt--;\n\t}\n\n\tspin_unlock_bh(&queue->lock);\n\n\trtw_init_xmitframe(pxframe);\n\n\treturn pxframe;\n}\n\nstruct xmit_frame *rtw_alloc_xmitframe_once(struct xmit_priv *pxmitpriv)\n{\n\tstruct xmit_frame *pxframe = NULL;\n\tu8 *alloc_addr;\n\n\talloc_addr = rtw_zmalloc(sizeof(struct xmit_frame) + 4);\n\n\tif (!alloc_addr)\n\t\tgoto exit;\n\n\tpxframe = (struct xmit_frame *)N_BYTE_ALIGMENT((SIZE_PTR)(alloc_addr), 4);\n\tpxframe->alloc_addr = alloc_addr;\n\n\tpxframe->padapter = pxmitpriv->adapter;\n\tpxframe->frame_tag = NULL_FRAMETAG;\n\n\tpxframe->pkt = NULL;\n\n\tpxframe->buf_addr = NULL;\n\tpxframe->pxmitbuf = NULL;\n\n\trtw_init_xmitframe(pxframe);\n\nexit:\n\treturn pxframe;\n}\n\ns32 rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe)\n{\n\tstruct __queue *queue = NULL;\n\tstruct adapter *padapter = pxmitpriv->adapter;\n\tstruct sk_buff *pndis_pkt = NULL;\n\n\tif (!pxmitframe)\n\t\tgoto exit;\n\n\tif (pxmitframe->pkt) {\n\t\tpndis_pkt = pxmitframe->pkt;\n\t\tpxmitframe->pkt = NULL;\n\t}\n\n\tif (pxmitframe->alloc_addr) {\n\t\tkfree(pxmitframe->alloc_addr);\n\t\tgoto check_pkt_complete;\n\t}\n\n\tif (pxmitframe->ext_tag == 0)\n\t\tqueue = &pxmitpriv->free_xmit_queue;\n\telse if (pxmitframe->ext_tag == 1)\n\t\tqueue = &pxmitpriv->free_xframe_ext_queue;\n\telse {\n\t}\n\n\tspin_lock_bh(&queue->lock);\n\n\tlist_del_init(&pxmitframe->list);\n\tlist_add_tail(&pxmitframe->list, get_list_head(queue));\n\tif (pxmitframe->ext_tag == 0)\n\t\tpxmitpriv->free_xmitframe_cnt++;\n\telse if (pxmitframe->ext_tag == 1)\n\t\tpxmitpriv->free_xframe_ext_cnt++;\n\n\tspin_unlock_bh(&queue->lock);\n\ncheck_pkt_complete:\n\n\tif (pndis_pkt)\n\t\trtw_os_pkt_complete(padapter, pndis_pkt);\n\nexit:\n\treturn _SUCCESS;\n}\n\nvoid rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, struct __queue *pframequeue)\n{\n\tstruct list_head *plist, *phead, *tmp;\n\tstruct\txmit_frame\t*pxmitframe;\n\n\tspin_lock_bh(&pframequeue->lock);\n\n\tphead = get_list_head(pframequeue);\n\tlist_for_each_safe(plist, tmp, phead) {\n\t\tpxmitframe = list_entry(plist, struct xmit_frame, list);\n\n\t\trtw_free_xmitframe(pxmitpriv, pxmitframe);\n\t}\n\tspin_unlock_bh(&pframequeue->lock);\n}\n\ns32 rtw_xmitframe_enqueue(struct adapter *padapter, struct xmit_frame *pxmitframe)\n{\n\tif (rtw_xmit_classifier(padapter, pxmitframe) == _FAIL)\n\t\treturn _FAIL;\n\n\treturn _SUCCESS;\n}\n\nstruct tx_servq *rtw_get_sta_pending(struct adapter *padapter, struct sta_info *psta, signed int up, u8 *ac)\n{\n\tstruct tx_servq *ptxservq = NULL;\n\n\tswitch (up) {\n\tcase 1:\n\tcase 2:\n\t\tptxservq = &psta->sta_xmitpriv.bk_q;\n\t\t*(ac) = 3;\n\t\tbreak;\n\n\tcase 4:\n\tcase 5:\n\t\tptxservq = &psta->sta_xmitpriv.vi_q;\n\t\t*(ac) = 1;\n\t\tbreak;\n\n\tcase 6:\n\tcase 7:\n\t\tptxservq = &psta->sta_xmitpriv.vo_q;\n\t\t*(ac) = 0;\n\t\tbreak;\n\n\tcase 0:\n\tcase 3:\n\tdefault:\n\t\tptxservq = &psta->sta_xmitpriv.be_q;\n\t\t*(ac) = 2;\n\tbreak;\n\t}\n\n\treturn ptxservq;\n}\n\n \ns32 rtw_xmit_classifier(struct adapter *padapter, struct xmit_frame *pxmitframe)\n{\n\tu8 ac_index;\n\tstruct sta_info *psta;\n\tstruct tx_servq\t*ptxservq;\n\tstruct pkt_attrib\t*pattrib = &pxmitframe->attrib;\n\tstruct hw_xmit\t*phwxmits =  padapter->xmitpriv.hwxmits;\n\tsigned int res = _SUCCESS;\n\n\tpsta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);\n\tif (pattrib->psta != psta)\n\t\treturn _FAIL;\n\n\tif (!psta) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tif (!(psta->state & _FW_LINKED))\n\t\treturn _FAIL;\n\n\tptxservq = rtw_get_sta_pending(padapter, psta, pattrib->priority, (u8 *)(&ac_index));\n\n\tif (list_empty(&ptxservq->tx_pending))\n\t\tlist_add_tail(&ptxservq->tx_pending, get_list_head(phwxmits[ac_index].sta_queue));\n\n\tlist_add_tail(&pxmitframe->list, get_list_head(&ptxservq->sta_pending));\n\tptxservq->qcnt++;\n\tphwxmits[ac_index].accnt++;\n\nexit:\n\n\treturn res;\n}\n\ns32 rtw_alloc_hwxmits(struct adapter *padapter)\n{\n\tstruct hw_xmit *hwxmits;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tpxmitpriv->hwxmit_entry = HWXMIT_ENTRY;\n\n\tpxmitpriv->hwxmits = NULL;\n\n\tpxmitpriv->hwxmits = rtw_zmalloc(sizeof(struct hw_xmit) * pxmitpriv->hwxmit_entry);\n\n\tif (!pxmitpriv->hwxmits)\n\t\treturn _FAIL;\n\n\thwxmits = pxmitpriv->hwxmits;\n\n\tif (pxmitpriv->hwxmit_entry == 5) {\n\t\thwxmits[0] .sta_queue = &pxmitpriv->bm_pending;\n\n\t\thwxmits[1] .sta_queue = &pxmitpriv->vo_pending;\n\n\t\thwxmits[2] .sta_queue = &pxmitpriv->vi_pending;\n\n\t\thwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\n\n\t\thwxmits[4] .sta_queue = &pxmitpriv->be_pending;\n\t} else if (pxmitpriv->hwxmit_entry == 4) {\n\t\thwxmits[0] .sta_queue = &pxmitpriv->vo_pending;\n\n\t\thwxmits[1] .sta_queue = &pxmitpriv->vi_pending;\n\n\t\thwxmits[2] .sta_queue = &pxmitpriv->be_pending;\n\n\t\thwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\n\t} else {\n\t}\n\n\treturn _SUCCESS;\n}\n\nvoid rtw_free_hwxmits(struct adapter *padapter)\n{\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tkfree(pxmitpriv->hwxmits);\n}\n\nvoid rtw_init_hwxmits(struct hw_xmit *phwxmit, signed int entry)\n{\n\tsigned int i;\n\n\tfor (i = 0; i < entry; i++, phwxmit++)\n\t\tphwxmit->accnt = 0;\n}\n\nu32 rtw_get_ff_hwaddr(struct xmit_frame *pxmitframe)\n{\n\tu32 addr;\n\tstruct pkt_attrib *pattrib = &pxmitframe->attrib;\n\n\tswitch (pattrib->qsel) {\n\tcase 0:\n\tcase 3:\n\t\taddr = BE_QUEUE_INX;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\taddr = BK_QUEUE_INX;\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\taddr = VI_QUEUE_INX;\n\t\tbreak;\n\tcase 6:\n\tcase 7:\n\t\taddr = VO_QUEUE_INX;\n\t\tbreak;\n\tcase 0x10:\n\t\taddr = BCN_QUEUE_INX;\n\t\tbreak;\n\tcase 0x11: \n\t\taddr = HIGH_QUEUE_INX;\n\t\tbreak;\n\tcase 0x12:\n\tdefault:\n\t\taddr = MGT_QUEUE_INX;\n\t\tbreak;\n\t}\n\n\treturn addr;\n}\n\nstatic void do_queue_select(struct adapter\t*padapter, struct pkt_attrib *pattrib)\n{\n\tu8 qsel;\n\n\tqsel = pattrib->priority;\n\n\tpattrib->qsel = qsel;\n}\n\n \ns32 rtw_xmit(struct adapter *padapter, struct sk_buff **ppkt)\n{\n\tstatic unsigned long start;\n\tstatic u32 drop_cnt;\n\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct xmit_frame *pxmitframe = NULL;\n\n\ts32 res;\n\n\tif (start == 0)\n\t\tstart = jiffies;\n\n\tpxmitframe = rtw_alloc_xmitframe(pxmitpriv);\n\n\tif (jiffies_to_msecs(jiffies - start) > 2000) {\n\t\tstart = jiffies;\n\t\tdrop_cnt = 0;\n\t}\n\n\tif (!pxmitframe) {\n\t\tdrop_cnt++;\n\t\treturn -1;\n\t}\n\n\tres = update_attrib(padapter, *ppkt, &pxmitframe->attrib);\n\n\tif (res == _FAIL) {\n\t\trtw_free_xmitframe(pxmitpriv, pxmitframe);\n\t\treturn -1;\n\t}\n\tpxmitframe->pkt = *ppkt;\n\n\tdo_queue_select(padapter, &pxmitframe->attrib);\n\n\tspin_lock_bh(&pxmitpriv->lock);\n\tif (xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == true) {\n\t\tspin_unlock_bh(&pxmitpriv->lock);\n\t\treturn 1;\n\t}\n\tspin_unlock_bh(&pxmitpriv->lock);\n\n\t \n\tif (rtw_hal_xmit(padapter, pxmitframe) == false)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n#define RTW_HIQ_FILTER_ALLOW_ALL 0\n#define RTW_HIQ_FILTER_ALLOW_SPECIAL 1\n#define RTW_HIQ_FILTER_DENY_ALL 2\n\ninline bool xmitframe_hiq_filter(struct xmit_frame *xmitframe)\n{\n\tbool allow = false;\n\tstruct adapter *adapter = xmitframe->padapter;\n\tstruct registry_priv *registry = &adapter->registrypriv;\n\n\tif (registry->hiq_filter == RTW_HIQ_FILTER_ALLOW_SPECIAL) {\n\t\tstruct pkt_attrib *attrib = &xmitframe->attrib;\n\n\t\tif (attrib->ether_type == 0x0806 ||\n\t\t    attrib->ether_type == 0x888e ||\n\t\t    attrib->dhcp_pkt\n\t\t)\n\t\t\tallow = true;\n\n\t} else if (registry->hiq_filter == RTW_HIQ_FILTER_ALLOW_ALL)\n\t\tallow = true;\n\telse if (registry->hiq_filter == RTW_HIQ_FILTER_DENY_ALL) {\n\t} else\n\t\trtw_warn_on(1);\n\n\treturn allow;\n}\n\nsigned int xmitframe_enqueue_for_sleeping_sta(struct adapter *padapter, struct xmit_frame *pxmitframe)\n{\n\tsigned int ret = false;\n\tstruct sta_info *psta = NULL;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct pkt_attrib *pattrib = &pxmitframe->attrib;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tsigned int bmcst = is_multicast_ether_addr(pattrib->ra);\n\tbool update_tim = false;\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == false)\n\t\treturn ret;\n\tpsta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);\n\tif (pattrib->psta != psta)\n\t\treturn false;\n\n\tif (!psta)\n\t\treturn false;\n\n\tif (!(psta->state & _FW_LINKED))\n\t\treturn false;\n\n\tif (pattrib->triggered == 1) {\n\t\tif (bmcst && xmitframe_hiq_filter(pxmitframe))\n\t\t\tpattrib->qsel = 0x11; \n\n\t\treturn ret;\n\t}\n\n\tif (bmcst) {\n\t\tspin_lock_bh(&psta->sleep_q.lock);\n\n\t\tif (pstapriv->sta_dz_bitmap) {  \n\t\t\t \n\n\t\t\tlist_del_init(&pxmitframe->list);\n\n\t\t\tlist_add_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));\n\n\t\t\tpsta->sleepq_len++;\n\n\t\t\tif (!(pstapriv->tim_bitmap & BIT(0)))\n\t\t\t\tupdate_tim = true;\n\n\t\t\tpstapriv->tim_bitmap |= BIT(0);\n\t\t\tpstapriv->sta_dz_bitmap |= BIT(0);\n\n\t\t\tif (update_tim)\n\t\t\t\tupdate_beacon(padapter, WLAN_EID_TIM, NULL, true);\n\t\t\telse\n\t\t\t\tchk_bmc_sleepq_cmd(padapter);\n\n\t\t\tret = true;\n\t\t}\n\n\t\tspin_unlock_bh(&psta->sleep_q.lock);\n\n\t\treturn ret;\n\t}\n\n\tspin_lock_bh(&psta->sleep_q.lock);\n\n\tif (psta->state&WIFI_SLEEP_STATE) {\n\t\tu8 wmmps_ac = 0;\n\n\t\tif (pstapriv->sta_dz_bitmap & BIT(psta->aid)) {\n\t\t\tlist_del_init(&pxmitframe->list);\n\n\t\t\tlist_add_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));\n\n\t\t\tpsta->sleepq_len++;\n\n\t\t\tswitch (pattrib->priority) {\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\t\twmmps_ac = psta->uapsd_bk&BIT(0);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\t\twmmps_ac = psta->uapsd_vi&BIT(0);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\t\twmmps_ac = psta->uapsd_vo&BIT(0);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase 3:\n\t\t\tdefault:\n\t\t\t\twmmps_ac = psta->uapsd_be&BIT(0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (wmmps_ac)\n\t\t\t\tpsta->sleepq_ac_len++;\n\n\t\t\tif (((psta->has_legacy_ac) && (!wmmps_ac)) || ((!psta->has_legacy_ac) && (wmmps_ac))) {\n\t\t\t\tif (!(pstapriv->tim_bitmap & BIT(psta->aid)))\n\t\t\t\t\tupdate_tim = true;\n\n\t\t\t\tpstapriv->tim_bitmap |= BIT(psta->aid);\n\n\t\t\t\tif (update_tim)\n\t\t\t\t\t \n\t\t\t\t\tupdate_beacon(padapter, WLAN_EID_TIM, NULL, true);\n\t\t\t}\n\n\t\t\tret = true;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&psta->sleep_q.lock);\n\n\treturn ret;\n}\n\nstatic void dequeue_xmitframes_to_sleeping_queue(struct adapter *padapter, struct sta_info *psta, struct __queue *pframequeue)\n{\n\tsigned int ret;\n\tstruct list_head *plist, *phead, *tmp;\n\tu8 ac_index;\n\tstruct tx_servq\t*ptxservq;\n\tstruct pkt_attrib\t*pattrib;\n\tstruct xmit_frame\t*pxmitframe;\n\tstruct hw_xmit *phwxmits =  padapter->xmitpriv.hwxmits;\n\n\tphead = get_list_head(pframequeue);\n\tlist_for_each_safe(plist, tmp, phead) {\n\t\tpxmitframe = list_entry(plist, struct xmit_frame, list);\n\n\t\tpattrib = &pxmitframe->attrib;\n\n\t\tpattrib->triggered = 0;\n\n\t\tret = xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe);\n\n\t\tif (true == ret) {\n\t\t\tptxservq = rtw_get_sta_pending(padapter, psta, pattrib->priority, (u8 *)(&ac_index));\n\n\t\t\tptxservq->qcnt--;\n\t\t\tphwxmits[ac_index].accnt--;\n\t\t} else {\n\t\t}\n\t}\n}\n\nvoid stop_sta_xmit(struct adapter *padapter, struct sta_info *psta)\n{\n\tstruct sta_info *psta_bmc;\n\tstruct sta_xmit_priv *pstaxmitpriv;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tpstaxmitpriv = &psta->sta_xmitpriv;\n\n\t \n\tpsta_bmc = rtw_get_bcmc_stainfo(padapter);\n\n\tspin_lock_bh(&pxmitpriv->lock);\n\n\tpsta->state |= WIFI_SLEEP_STATE;\n\n\tpstapriv->sta_dz_bitmap |= BIT(psta->aid);\n\n\tdequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vo_q.sta_pending);\n\tlist_del_init(&pstaxmitpriv->vo_q.tx_pending);\n\n\tdequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vi_q.sta_pending);\n\tlist_del_init(&pstaxmitpriv->vi_q.tx_pending);\n\n\tdequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->be_q.sta_pending);\n\tlist_del_init(&pstaxmitpriv->be_q.tx_pending);\n\n\tdequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->bk_q.sta_pending);\n\tlist_del_init(&pstaxmitpriv->bk_q.tx_pending);\n\n\t \n\tpstaxmitpriv = &psta_bmc->sta_xmitpriv;\n\tdequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, &pstaxmitpriv->be_q.sta_pending);\n\tlist_del_init(&pstaxmitpriv->be_q.tx_pending);\n\n\tspin_unlock_bh(&pxmitpriv->lock);\n}\n\nvoid wakeup_sta_to_xmit(struct adapter *padapter, struct sta_info *psta)\n{\n\tu8 update_mask = 0, wmmps_ac = 0;\n\tstruct sta_info *psta_bmc;\n\tstruct list_head *xmitframe_plist, *xmitframe_phead, *tmp;\n\tstruct xmit_frame *pxmitframe = NULL;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tpsta_bmc = rtw_get_bcmc_stainfo(padapter);\n\n\tspin_lock_bh(&pxmitpriv->lock);\n\n\txmitframe_phead = get_list_head(&psta->sleep_q);\n\tlist_for_each_safe(xmitframe_plist, tmp, xmitframe_phead) {\n\t\tpxmitframe = list_entry(xmitframe_plist, struct xmit_frame,\n\t\t\t\t\tlist);\n\n\t\tlist_del_init(&pxmitframe->list);\n\n\t\tswitch (pxmitframe->attrib.priority) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\twmmps_ac = psta->uapsd_bk&BIT(1);\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\t\twmmps_ac = psta->uapsd_vi&BIT(1);\n\t\t\tbreak;\n\t\tcase 6:\n\t\tcase 7:\n\t\t\twmmps_ac = psta->uapsd_vo&BIT(1);\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase 3:\n\t\tdefault:\n\t\t\twmmps_ac = psta->uapsd_be&BIT(1);\n\t\t\tbreak;\n\t\t}\n\n\t\tpsta->sleepq_len--;\n\t\tif (psta->sleepq_len > 0)\n\t\t\tpxmitframe->attrib.mdata = 1;\n\t\telse\n\t\t\tpxmitframe->attrib.mdata = 0;\n\n\t\tif (wmmps_ac) {\n\t\t\tpsta->sleepq_ac_len--;\n\t\t\tif (psta->sleepq_ac_len > 0) {\n\t\t\t\tpxmitframe->attrib.mdata = 1;\n\t\t\t\tpxmitframe->attrib.eosp = 0;\n\t\t\t} else {\n\t\t\t\tpxmitframe->attrib.mdata = 0;\n\t\t\t\tpxmitframe->attrib.eosp = 1;\n\t\t\t}\n\t\t}\n\n\t\tpxmitframe->attrib.triggered = 1;\n\n\t\trtw_hal_xmitframe_enqueue(padapter, pxmitframe);\n\t}\n\n\tif (psta->sleepq_len == 0) {\n\t\tif (pstapriv->tim_bitmap & BIT(psta->aid))\n\t\t\tupdate_mask = BIT(0);\n\n\t\tpstapriv->tim_bitmap &= ~BIT(psta->aid);\n\n\t\tif (psta->state&WIFI_SLEEP_STATE)\n\t\t\tpsta->state ^= WIFI_SLEEP_STATE;\n\n\t\tif (psta->state & WIFI_STA_ALIVE_CHK_STATE) {\n\t\t\tpsta->expire_to = pstapriv->expire_to;\n\t\t\tpsta->state ^= WIFI_STA_ALIVE_CHK_STATE;\n\t\t}\n\n\t\tpstapriv->sta_dz_bitmap &= ~BIT(psta->aid);\n\t}\n\n\t \n\tif (!psta_bmc)\n\t\tgoto _exit;\n\n\tif ((pstapriv->sta_dz_bitmap&0xfffe) == 0x0) {  \n\t\txmitframe_phead = get_list_head(&psta_bmc->sleep_q);\n\t\tlist_for_each_safe(xmitframe_plist, tmp, xmitframe_phead) {\n\t\t\tpxmitframe = list_entry(xmitframe_plist,\n\t\t\t\t\t\tstruct xmit_frame, list);\n\n\t\t\tlist_del_init(&pxmitframe->list);\n\n\t\t\tpsta_bmc->sleepq_len--;\n\t\t\tif (psta_bmc->sleepq_len > 0)\n\t\t\t\tpxmitframe->attrib.mdata = 1;\n\t\t\telse\n\t\t\t\tpxmitframe->attrib.mdata = 0;\n\n\t\t\tpxmitframe->attrib.triggered = 1;\n\t\t\trtw_hal_xmitframe_enqueue(padapter, pxmitframe);\n\t\t}\n\n\t\tif (psta_bmc->sleepq_len == 0) {\n\t\t\tif (pstapriv->tim_bitmap & BIT(0))\n\t\t\t\tupdate_mask |= BIT(1);\n\n\t\t\tpstapriv->tim_bitmap &= ~BIT(0);\n\t\t\tpstapriv->sta_dz_bitmap &= ~BIT(0);\n\t\t}\n\t}\n\n_exit:\n\n\tspin_unlock_bh(&pxmitpriv->lock);\n\n\tif (update_mask)\n\t\tupdate_beacon(padapter, WLAN_EID_TIM, NULL, true);\n}\n\nvoid xmit_delivery_enabled_frames(struct adapter *padapter, struct sta_info *psta)\n{\n\tu8 wmmps_ac = 0;\n\tstruct list_head *xmitframe_plist, *xmitframe_phead, *tmp;\n\tstruct xmit_frame *pxmitframe = NULL;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tspin_lock_bh(&pxmitpriv->lock);\n\n\txmitframe_phead = get_list_head(&psta->sleep_q);\n\tlist_for_each_safe(xmitframe_plist, tmp, xmitframe_phead) {\n\t\tpxmitframe = list_entry(xmitframe_plist, struct xmit_frame,\n\t\t\t\t\tlist);\n\n\t\tswitch (pxmitframe->attrib.priority) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\twmmps_ac = psta->uapsd_bk&BIT(1);\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\t\twmmps_ac = psta->uapsd_vi&BIT(1);\n\t\t\tbreak;\n\t\tcase 6:\n\t\tcase 7:\n\t\t\twmmps_ac = psta->uapsd_vo&BIT(1);\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase 3:\n\t\tdefault:\n\t\t\twmmps_ac = psta->uapsd_be&BIT(1);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!wmmps_ac)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&pxmitframe->list);\n\n\t\tpsta->sleepq_len--;\n\t\tpsta->sleepq_ac_len--;\n\n\t\tif (psta->sleepq_ac_len > 0) {\n\t\t\tpxmitframe->attrib.mdata = 1;\n\t\t\tpxmitframe->attrib.eosp = 0;\n\t\t} else {\n\t\t\tpxmitframe->attrib.mdata = 0;\n\t\t\tpxmitframe->attrib.eosp = 1;\n\t\t}\n\n\t\tpxmitframe->attrib.triggered = 1;\n\t\trtw_hal_xmitframe_enqueue(padapter, pxmitframe);\n\n\t\tif ((psta->sleepq_ac_len == 0) && (!psta->has_legacy_ac) && (wmmps_ac)) {\n\t\t\tpstapriv->tim_bitmap &= ~BIT(psta->aid);\n\n\t\t\tupdate_beacon(padapter, WLAN_EID_TIM, NULL, true);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&pxmitpriv->lock);\n}\n\nvoid enqueue_pending_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)\n{\n\tstruct __queue *pqueue;\n\tstruct adapter *pri_adapter = pxmitpriv->adapter;\n\n\tpqueue = &pxmitpriv->pending_xmitbuf_queue;\n\n\tspin_lock_bh(&pqueue->lock);\n\tlist_del_init(&pxmitbuf->list);\n\tlist_add_tail(&pxmitbuf->list, get_list_head(pqueue));\n\tspin_unlock_bh(&pqueue->lock);\n\n\tcomplete(&pri_adapter->xmitpriv.xmit_comp);\n}\n\nvoid enqueue_pending_xmitbuf_to_head(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)\n{\n\tstruct __queue *pqueue;\n\n\tpqueue = &pxmitpriv->pending_xmitbuf_queue;\n\n\tspin_lock_bh(&pqueue->lock);\n\tlist_del_init(&pxmitbuf->list);\n\tlist_add(&pxmitbuf->list, get_list_head(pqueue));\n\tspin_unlock_bh(&pqueue->lock);\n}\n\nstruct xmit_buf *dequeue_pending_xmitbuf(struct xmit_priv *pxmitpriv)\n{\n\tstruct xmit_buf *pxmitbuf;\n\tstruct __queue *pqueue;\n\n\tpxmitbuf = NULL;\n\tpqueue = &pxmitpriv->pending_xmitbuf_queue;\n\n\tspin_lock_bh(&pqueue->lock);\n\n\tif (!list_empty(&pqueue->queue)) {\n\t\tstruct list_head *plist, *phead;\n\n\t\tphead = get_list_head(pqueue);\n\t\tplist = get_next(phead);\n\t\tpxmitbuf = container_of(plist, struct xmit_buf, list);\n\t\tlist_del_init(&pxmitbuf->list);\n\t}\n\n\tspin_unlock_bh(&pqueue->lock);\n\n\treturn pxmitbuf;\n}\n\nstruct xmit_buf *dequeue_pending_xmitbuf_under_survey(struct xmit_priv *pxmitpriv)\n{\n\tstruct xmit_buf *pxmitbuf;\n\tstruct __queue *pqueue;\n\n\tpxmitbuf = NULL;\n\tpqueue = &pxmitpriv->pending_xmitbuf_queue;\n\n\tspin_lock_bh(&pqueue->lock);\n\n\tif (!list_empty(&pqueue->queue)) {\n\t\tstruct list_head *plist, *phead;\n\t\tu8 type;\n\n\t\tphead = get_list_head(pqueue);\n\t\tplist = phead;\n\t\tdo {\n\t\t\tplist = get_next(plist);\n\t\t\tif (plist == phead)\n\t\t\t\tbreak;\n\n\t\t\tpxmitbuf = container_of(plist, struct xmit_buf, list);\n\n\t\t\ttype = GetFrameSubType(pxmitbuf->pbuf + TXDESC_OFFSET);\n\n\t\t\tif ((type == WIFI_PROBEREQ) ||\n\t\t\t\t(type == WIFI_DATA_NULL) ||\n\t\t\t\t(type == WIFI_QOS_DATA_NULL)) {\n\t\t\t\tlist_del_init(&pxmitbuf->list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpxmitbuf = NULL;\n\t\t} while (1);\n\t}\n\n\tspin_unlock_bh(&pqueue->lock);\n\n\treturn pxmitbuf;\n}\n\nsigned int check_pending_xmitbuf(struct xmit_priv *pxmitpriv)\n{\n\tstruct __queue *pqueue;\n\tsigned int\tret = false;\n\n\tpqueue = &pxmitpriv->pending_xmitbuf_queue;\n\n\tspin_lock_bh(&pqueue->lock);\n\n\tif (!list_empty(&pqueue->queue))\n\t\tret = true;\n\n\tspin_unlock_bh(&pqueue->lock);\n\n\treturn ret;\n}\n\nint rtw_xmit_thread(void *context)\n{\n\ts32 err;\n\tstruct adapter *padapter;\n\n\terr = _SUCCESS;\n\tpadapter = context;\n\n\tthread_enter(\"RTW_XMIT_THREAD\");\n\n\tdo {\n\t\terr = rtw_hal_xmit_thread_handler(padapter);\n\t\tflush_signals_thread();\n\t} while (err == _SUCCESS);\n\n\tcomplete(&padapter->xmitpriv.terminate_xmitthread_comp);\n\n\treturn 0;\n}\n\nvoid rtw_sctx_init(struct submit_ctx *sctx, int timeout_ms)\n{\n\tsctx->timeout_ms = timeout_ms;\n\tsctx->submit_time = jiffies;\n\tinit_completion(&sctx->done);\n\tsctx->status = RTW_SCTX_SUBMITTED;\n}\n\nint rtw_sctx_wait(struct submit_ctx *sctx)\n{\n\tint ret = _FAIL;\n\tunsigned long expire;\n\tint status = 0;\n\n\texpire = sctx->timeout_ms ? msecs_to_jiffies(sctx->timeout_ms) : MAX_SCHEDULE_TIMEOUT;\n\tif (!wait_for_completion_timeout(&sctx->done, expire))\n\t\t \n\t\tstatus = RTW_SCTX_DONE_TIMEOUT;\n\telse\n\t\tstatus = sctx->status;\n\n\tif (status == RTW_SCTX_DONE_SUCCESS)\n\t\tret = _SUCCESS;\n\n\treturn ret;\n}\n\nvoid rtw_sctx_done_err(struct submit_ctx **sctx, int status)\n{\n\tif (*sctx) {\n\t\t(*sctx)->status = status;\n\t\tcomplete(&((*sctx)->done));\n\t\t*sctx = NULL;\n\t}\n}\n\nvoid rtw_sctx_done(struct submit_ctx **sctx)\n{\n\trtw_sctx_done_err(sctx, RTW_SCTX_DONE_SUCCESS);\n}\n\nint rtw_ack_tx_wait(struct xmit_priv *pxmitpriv, u32 timeout_ms)\n{\n\tstruct submit_ctx *pack_tx_ops = &pxmitpriv->ack_tx_ops;\n\n\tpack_tx_ops->submit_time = jiffies;\n\tpack_tx_ops->timeout_ms = timeout_ms;\n\tpack_tx_ops->status = RTW_SCTX_SUBMITTED;\n\n\treturn rtw_sctx_wait(pack_tx_ops);\n}\n\nvoid rtw_ack_tx_done(struct xmit_priv *pxmitpriv, int status)\n{\n\tstruct submit_ctx *pack_tx_ops = &pxmitpriv->ack_tx_ops;\n\n\tif (pxmitpriv->ack_tx)\n\t\trtw_sctx_done_err(&pack_tx_ops, status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}