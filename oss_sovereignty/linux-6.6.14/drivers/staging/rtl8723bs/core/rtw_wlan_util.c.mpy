{
  "module_name": "rtw_wlan_util.c",
  "hash_id": "2fabb08397d0a4fb04c42d6f333fdf4b051689acdae4fbd2c9b18d64bd8f382a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/core/rtw_wlan_util.c",
  "human_readable_source": "\n \n\n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <hal_com_h2c.h>\n\nstatic unsigned char ARTHEROS_OUI1[] = {0x00, 0x03, 0x7f};\nstatic unsigned char ARTHEROS_OUI2[] = {0x00, 0x13, 0x74};\n\nstatic unsigned char BROADCOM_OUI1[] = {0x00, 0x10, 0x18};\nstatic unsigned char BROADCOM_OUI2[] = {0x00, 0x0a, 0xf7};\nstatic unsigned char BROADCOM_OUI3[] = {0x00, 0x05, 0xb5};\n\nstatic unsigned char CISCO_OUI[] = {0x00, 0x40, 0x96};\nstatic unsigned char MARVELL_OUI[] = {0x00, 0x50, 0x43};\nstatic unsigned char RALINK_OUI[] = {0x00, 0x0c, 0x43};\nstatic unsigned char REALTEK_OUI[] = {0x00, 0xe0, 0x4c};\nstatic unsigned char AIRGOCAP_OUI[] = {0x00, 0x0a, 0xf5};\nstatic unsigned char RSN_TKIP_CIPHER[4] = {0x00, 0x0f, 0xac, 0x02};\nstatic unsigned char WPA_TKIP_CIPHER[4] = {0x00, 0x50, 0xf2, 0x02};\n\n \n#define WAIT_FOR_BCN_TO_MIN\t(6000)\n#define WAIT_FOR_BCN_TO_MAX\t(20000)\n\n#define DISCONNECT_BY_CHK_BCN_FAIL_OBSERV_PERIOD_IN_MS 1000\n#define DISCONNECT_BY_CHK_BCN_FAIL_THRESHOLD 3\n\nstatic u8 rtw_basic_rate_cck[4] = {\n\tIEEE80211_CCK_RATE_1MB | IEEE80211_BASIC_RATE_MASK,\n\tIEEE80211_CCK_RATE_2MB | IEEE80211_BASIC_RATE_MASK,\n\tIEEE80211_CCK_RATE_5MB | IEEE80211_BASIC_RATE_MASK,\n\tIEEE80211_CCK_RATE_11MB | IEEE80211_BASIC_RATE_MASK\n};\n\nstatic u8 rtw_basic_rate_ofdm[3] = {\n\tIEEE80211_OFDM_RATE_6MB | IEEE80211_BASIC_RATE_MASK,\n\tIEEE80211_OFDM_RATE_12MB | IEEE80211_BASIC_RATE_MASK,\n\tIEEE80211_OFDM_RATE_24MB | IEEE80211_BASIC_RATE_MASK\n};\n\nu8 networktype_to_raid_ex(struct adapter *adapter, struct sta_info *psta)\n{\n\tu8 raid;\n\n\tswitch (psta->wireless_mode) {\n\tcase WIRELESS_11B:\n\t\traid = RATEID_IDX_B;\n\t\tbreak;\n\tcase WIRELESS_11G:\n\t\traid = RATEID_IDX_G;\n\t\tbreak;\n\tcase WIRELESS_11BG:\n\t\traid = RATEID_IDX_BG;\n\t\tbreak;\n\tcase WIRELESS_11_24N:\n\tcase WIRELESS_11G_24N:\n\t\traid = RATEID_IDX_GN_N1SS;\n\t\tbreak;\n\tcase WIRELESS_11B_24N:\n\tcase WIRELESS_11BG_24N:\n\t\tif (psta->bw_mode == CHANNEL_WIDTH_20) {\n\t\t\traid = RATEID_IDX_BGN_20M_1SS_BN;\n\t\t} else {\n\t\t\traid = RATEID_IDX_BGN_40M_1SS;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\traid = RATEID_IDX_BGN_40M_2SS;\n\t\tbreak;\n\t}\n\treturn raid;\n}\n\nunsigned char ratetbl_val_2wifirate(unsigned char rate);\nunsigned char ratetbl_val_2wifirate(unsigned char rate)\n{\n\tswitch (rate & 0x7f) {\n\tcase 0:\n\t\treturn IEEE80211_CCK_RATE_1MB;\n\tcase 1:\n\t\treturn IEEE80211_CCK_RATE_2MB;\n\tcase 2:\n\t\treturn IEEE80211_CCK_RATE_5MB;\n\tcase 3:\n\t\treturn IEEE80211_CCK_RATE_11MB;\n\tcase 4:\n\t\treturn IEEE80211_OFDM_RATE_6MB;\n\tcase 5:\n\t\treturn IEEE80211_OFDM_RATE_9MB;\n\tcase 6:\n\t\treturn IEEE80211_OFDM_RATE_12MB;\n\tcase 7:\n\t\treturn IEEE80211_OFDM_RATE_18MB;\n\tcase 8:\n\t\treturn IEEE80211_OFDM_RATE_24MB;\n\tcase 9:\n\t\treturn IEEE80211_OFDM_RATE_36MB;\n\tcase 10:\n\t\treturn IEEE80211_OFDM_RATE_48MB;\n\tcase 11:\n\t\treturn IEEE80211_OFDM_RATE_54MB;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint is_basicrate(struct adapter *padapter, unsigned char rate);\nint is_basicrate(struct adapter *padapter, unsigned char rate)\n{\n\tint i;\n\tunsigned char val;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\n\tfor (i = 0; i < NumRates; i++) {\n\t\tval = pmlmeext->basicrate[i];\n\n\t\tif ((val != 0xff) && (val != 0xfe))\n\t\t\tif (rate == ratetbl_val_2wifirate(val))\n\t\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nunsigned int ratetbl2rateset(struct adapter *padapter, unsigned char *rateset);\nunsigned int ratetbl2rateset(struct adapter *padapter, unsigned char *rateset)\n{\n\tint i;\n\tunsigned char rate;\n\tunsigned int\tlen = 0;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\n\tfor (i = 0; i < NumRates; i++) {\n\t\trate = pmlmeext->datarate[i];\n\n\t\tswitch (rate) {\n\t\tcase 0xff:\n\t\t\treturn len;\n\n\t\tcase 0xfe:\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\trate = ratetbl_val_2wifirate(rate);\n\n\t\t\tif (is_basicrate(padapter, rate) == true)\n\t\t\t\trate |= IEEE80211_BASIC_RATE_MASK;\n\n\t\t\trateset[len] = rate;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn len;\n}\n\nvoid get_rate_set(struct adapter *padapter, unsigned char *pbssrate, int *bssrate_len)\n{\n\tunsigned char supportedrates[NumRates];\n\n\tmemset(supportedrates, 0, NumRates);\n\t*bssrate_len = ratetbl2rateset(padapter, supportedrates);\n\tmemcpy(pbssrate, supportedrates, *bssrate_len);\n}\n\nvoid set_mcs_rate_by_mask(u8 *mcs_set, u32 mask)\n{\n\tu8 mcs_rate_1r = (u8)(mask&0xff);\n\tu8 mcs_rate_2r = (u8)((mask>>8)&0xff);\n\tu8 mcs_rate_3r = (u8)((mask>>16)&0xff);\n\tu8 mcs_rate_4r = (u8)((mask>>24)&0xff);\n\n\tmcs_set[0] &= mcs_rate_1r;\n\tmcs_set[1] &= mcs_rate_2r;\n\tmcs_set[2] &= mcs_rate_3r;\n\tmcs_set[3] &= mcs_rate_4r;\n}\n\nvoid UpdateBrateTbl(struct adapter *Adapter, u8 *mBratesOS)\n{\n\tu8 i;\n\tu8 rate;\n\n\t \n\tfor (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {\n\t\trate = mBratesOS[i] & 0x7f;\n\t\tswitch (rate) {\n\t\tcase IEEE80211_CCK_RATE_1MB:\n\t\tcase IEEE80211_CCK_RATE_2MB:\n\t\tcase IEEE80211_CCK_RATE_5MB:\n\t\tcase IEEE80211_CCK_RATE_11MB:\n\t\tcase IEEE80211_OFDM_RATE_6MB:\n\t\tcase IEEE80211_OFDM_RATE_12MB:\n\t\tcase IEEE80211_OFDM_RATE_24MB:\n\t\t\tmBratesOS[i] |= IEEE80211_BASIC_RATE_MASK;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid UpdateBrateTblForSoftAP(u8 *bssrateset, u32 bssratelen)\n{\n\tu8 i;\n\tu8 rate;\n\n\tfor (i = 0; i < bssratelen; i++) {\n\t\trate = bssrateset[i] & 0x7f;\n\t\tswitch (rate) {\n\t\tcase IEEE80211_CCK_RATE_1MB:\n\t\tcase IEEE80211_CCK_RATE_2MB:\n\t\tcase IEEE80211_CCK_RATE_5MB:\n\t\tcase IEEE80211_CCK_RATE_11MB:\n\t\t\tbssrateset[i] |= IEEE80211_BASIC_RATE_MASK;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid Save_DM_Func_Flag(struct adapter *padapter)\n{\n\tu8 bSaveFlag = true;\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));\n}\n\nvoid Restore_DM_Func_Flag(struct adapter *padapter)\n{\n\tu8 bSaveFlag = false;\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));\n}\n\nvoid Switch_DM_Func(struct adapter *padapter, u32 mode, u8 enable)\n{\n\tif (enable == true)\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_SET, (u8 *)(&mode));\n\telse\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_CLR, (u8 *)(&mode));\n}\n\nvoid Set_MSR(struct adapter *padapter, u8 type)\n{\n\trtw_hal_set_hwreg(padapter, HW_VAR_MEDIA_STATUS, (u8 *)(&type));\n}\n\ninline u8 rtw_get_oper_ch(struct adapter *adapter)\n{\n\treturn adapter_to_dvobj(adapter)->oper_channel;\n}\n\ninline void rtw_set_oper_ch(struct adapter *adapter, u8 ch)\n{\n#ifdef DBG_CH_SWITCH\n\tconst int len = 128;\n\tchar msg[128] = {0};\n\tint cnt = 0;\n\tint i = 0;\n#endif   \n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\n\n\tif (dvobj->oper_channel != ch) {\n\t\tdvobj->on_oper_ch_time = jiffies;\n\n#ifdef DBG_CH_SWITCH\n\t\tcnt += scnprintf(msg+cnt, len-cnt, \"switch to ch %3u\", ch);\n\n\t\tfor (i = 0; i < dvobj->iface_nums; i++) {\n\t\t\tstruct adapter *iface = dvobj->padapters[i];\n\n\t\t\tcnt += scnprintf(msg+cnt, len-cnt, \" [%s:\", ADPT_ARG(iface));\n\t\t\tif (iface->mlmeextpriv.cur_channel == ch)\n\t\t\t\tcnt += scnprintf(msg+cnt, len-cnt, \"C\");\n\t\t\telse\n\t\t\t\tcnt += scnprintf(msg+cnt, len-cnt, \"_\");\n\t\t\tif (iface->wdinfo.listen_channel == ch && !rtw_p2p_chk_state(&iface->wdinfo, P2P_STATE_NONE))\n\t\t\t\tcnt += scnprintf(msg+cnt, len-cnt, \"L\");\n\t\t\telse\n\t\t\t\tcnt += scnprintf(msg+cnt, len-cnt, \"_\");\n\t\t\tcnt += scnprintf(msg+cnt, len-cnt, \"]\");\n\t\t}\n\n#endif  \n\t}\n\n\tdvobj->oper_channel = ch;\n}\n\ninline u8 rtw_get_oper_bw(struct adapter *adapter)\n{\n\treturn adapter_to_dvobj(adapter)->oper_bwmode;\n}\n\ninline void rtw_set_oper_bw(struct adapter *adapter, u8 bw)\n{\n\tadapter_to_dvobj(adapter)->oper_bwmode = bw;\n}\n\ninline u8 rtw_get_oper_choffset(struct adapter *adapter)\n{\n\treturn adapter_to_dvobj(adapter)->oper_ch_offset;\n}\n\ninline void rtw_set_oper_choffset(struct adapter *adapter, u8 offset)\n{\n\tadapter_to_dvobj(adapter)->oper_ch_offset = offset;\n}\n\nu8 rtw_get_center_ch(u8 channel, u8 chnl_bw, u8 chnl_offset)\n{\n\tu8 center_ch = channel;\n\n\tif (chnl_bw == CHANNEL_WIDTH_40) {\n\t\tif (chnl_offset == HAL_PRIME_CHNL_OFFSET_LOWER)\n\t\t\tcenter_ch = channel + 2;\n\t\telse\n\t\t\tcenter_ch = channel - 2;\n\t}\n\n\treturn center_ch;\n}\n\ninline unsigned long rtw_get_on_cur_ch_time(struct adapter *adapter)\n{\n\tif (adapter->mlmeextpriv.cur_channel == adapter_to_dvobj(adapter)->oper_channel)\n\t\treturn adapter_to_dvobj(adapter)->on_oper_ch_time;\n\telse\n\t\treturn 0;\n}\n\nvoid SelectChannel(struct adapter *padapter, unsigned char channel)\n{\n\tif (mutex_lock_interruptible(&(adapter_to_dvobj(padapter)->setch_mutex)))\n\t\treturn;\n\n\t \n\trtw_set_oper_ch(padapter, channel);\n\n\trtw_hal_set_chan(padapter, channel);\n\n\tmutex_unlock(&(adapter_to_dvobj(padapter)->setch_mutex));\n}\n\nvoid set_channel_bwmode(struct adapter *padapter, unsigned char channel, unsigned char channel_offset, unsigned short bwmode)\n{\n\tu8 center_ch, chnl_offset80 = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\n\tcenter_ch = rtw_get_center_ch(channel, bwmode, channel_offset);\n\n\n\t \n\tif (mutex_lock_interruptible(&(adapter_to_dvobj(padapter)->setch_mutex)))\n\t\treturn;\n\n\t \n\trtw_set_oper_ch(padapter, channel);\n\trtw_set_oper_bw(padapter, bwmode);\n\trtw_set_oper_choffset(padapter, channel_offset);\n\n\trtw_hal_set_chnl_bw(padapter, center_ch, bwmode, channel_offset, chnl_offset80);  \n\n\tmutex_unlock(&(adapter_to_dvobj(padapter)->setch_mutex));\n}\n\ninline u8 *get_my_bssid(struct wlan_bssid_ex *pnetwork)\n{\n\treturn pnetwork->mac_address;\n}\n\nu16 get_beacon_interval(struct wlan_bssid_ex *bss)\n{\n\t__le16 val;\n\n\tmemcpy((unsigned char *)&val, rtw_get_beacon_interval_from_ie(bss->ies), 2);\n\n\treturn le16_to_cpu(val);\n}\n\nint is_client_associated_to_ap(struct adapter *padapter)\n{\n\tstruct mlme_ext_priv *pmlmeext;\n\tstruct mlme_ext_info *pmlmeinfo;\n\n\tif (!padapter)\n\t\treturn _FAIL;\n\n\tpmlmeext = &padapter->mlmeextpriv;\n\tpmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tif ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE))\n\t\treturn true;\n\telse\n\t\treturn _FAIL;\n}\n\nint is_client_associated_to_ibss(struct adapter *padapter)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tif ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))\n\t\treturn true;\n\telse\n\t\treturn _FAIL;\n}\n\nint is_IBSS_empty(struct adapter *padapter)\n{\n\tunsigned int i;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tfor (i = IBSS_START_MAC_ID; i < NUM_STA; i++) {\n\t\tif (pmlmeinfo->FW_sta_info[i].status == 1)\n\t\t\treturn _FAIL;\n\t}\n\n\treturn true;\n}\n\nunsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval)\n{\n\tif ((bcn_interval << 2) < WAIT_FOR_BCN_TO_MIN)\n\t\treturn WAIT_FOR_BCN_TO_MIN;\n\telse if ((bcn_interval << 2) > WAIT_FOR_BCN_TO_MAX)\n\t\treturn WAIT_FOR_BCN_TO_MAX;\n\telse\n\t\treturn bcn_interval << 2;\n}\n\nvoid invalidate_cam_all(struct adapter *padapter)\n{\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(padapter);\n\tstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, NULL);\n\n\tspin_lock_bh(&cam_ctl->lock);\n\tcam_ctl->bitmap = 0;\n\tmemset(dvobj->cam_cache, 0, sizeof(struct cam_entry_cache)*TOTAL_CAM_ENTRY);\n\tspin_unlock_bh(&cam_ctl->lock);\n}\n\nstatic u32 _ReadCAM(struct adapter *padapter, u32 addr)\n{\n\tu32 count = 0, cmd;\n\n\tcmd = CAM_POLLINIG | addr;\n\trtw_write32(padapter, RWCAM, cmd);\n\n\tdo {\n\t\tif (0 == (rtw_read32(padapter, REG_CAMCMD) & CAM_POLLINIG))\n\t\t\tbreak;\n\t} while (count++ < 100);\n\n\treturn rtw_read32(padapter, REG_CAMREAD);\n}\n\nvoid read_cam(struct adapter *padapter, u8 entry, u8 *get_key)\n{\n\tu32 j, addr, cmd;\n\n\taddr = entry << 3;\n\n\tfor (j = 0; j < 6; j++) {\n\t\tcmd = _ReadCAM(padapter, addr+j);\n\t\tif (j > 1)  \n\t\t\tmemcpy(get_key+(j-2)*4, &cmd, 4);\n\t}\n}\n\nvoid _write_cam(struct adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key)\n{\n\tunsigned int i, val, addr;\n\tint j;\n\tu32 cam_val[2];\n\n\taddr = entry << 3;\n\n\tfor (j = 5; j >= 0; j--) {\n\t\tswitch (j) {\n\t\tcase 0:\n\t\t\tval = (ctrl | (mac[0] << 16) | (mac[1] << 24));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tval = (mac[2] | (mac[3] << 8) | (mac[4] << 16) | (mac[5] << 24));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ti = (j - 2) << 2;\n\t\t\tval = (key[i] | (key[i+1] << 8) | (key[i+2] << 16) | (key[i+3] << 24));\n\t\t\tbreak;\n\t\t}\n\n\t\tcam_val[0] = val;\n\t\tcam_val[1] = addr + (unsigned int)j;\n\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_CAM_WRITE, (u8 *)cam_val);\n\t}\n}\n\nvoid _clear_cam_entry(struct adapter *padapter, u8 entry)\n{\n\tunsigned char null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\tunsigned char null_key[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n\t_write_cam(padapter, entry, 0, null_sta, null_key);\n}\n\ninline void write_cam(struct adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key)\n{\n\t_write_cam(adapter, id, ctrl, mac, key);\n\twrite_cam_cache(adapter, id, ctrl, mac, key);\n}\n\ninline void clear_cam_entry(struct adapter *adapter, u8 id)\n{\n\t_clear_cam_entry(adapter, id);\n\tclear_cam_cache(adapter, id);\n}\n\nvoid write_cam_cache(struct adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key)\n{\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\n\tstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\n\n\tspin_lock_bh(&cam_ctl->lock);\n\n\tdvobj->cam_cache[id].ctrl = ctrl;\n\tmemcpy(dvobj->cam_cache[id].mac, mac, ETH_ALEN);\n\tmemcpy(dvobj->cam_cache[id].key, key, 16);\n\n\tspin_unlock_bh(&cam_ctl->lock);\n}\n\nvoid clear_cam_cache(struct adapter *adapter, u8 id)\n{\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\n\tstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\n\n\tspin_lock_bh(&cam_ctl->lock);\n\n\tmemset(&(dvobj->cam_cache[id]), 0, sizeof(struct cam_entry_cache));\n\n\tspin_unlock_bh(&cam_ctl->lock);\n}\n\nstatic bool _rtw_camid_is_gk(struct adapter *adapter, u8 cam_id)\n{\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\n\tstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\n\tbool ret = false;\n\n\tif (cam_id >= TOTAL_CAM_ENTRY)\n\t\tgoto exit;\n\n\tif (!(cam_ctl->bitmap & BIT(cam_id)))\n\t\tgoto exit;\n\n\tret = (dvobj->cam_cache[cam_id].ctrl&BIT6)?true:false;\n\nexit:\n\treturn ret;\n}\n\nstatic s16 _rtw_camid_search(struct adapter *adapter, u8 *addr, s16 kid)\n{\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\n\tint i;\n\ts16 cam_id = -1;\n\n\tfor (i = 0; i < TOTAL_CAM_ENTRY; i++) {\n\t\tif (addr && memcmp(dvobj->cam_cache[i].mac, addr, ETH_ALEN))\n\t\t\tcontinue;\n\t\tif (kid >= 0 && kid != (dvobj->cam_cache[i].ctrl&0x03))\n\t\t\tcontinue;\n\n\t\tcam_id = i;\n\t\tbreak;\n\t}\n\n\treturn cam_id;\n}\n\ns16 rtw_camid_search(struct adapter *adapter, u8 *addr, s16 kid)\n{\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\n\tstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\n\ts16 cam_id = -1;\n\n\tspin_lock_bh(&cam_ctl->lock);\n\tcam_id = _rtw_camid_search(adapter, addr, kid);\n\tspin_unlock_bh(&cam_ctl->lock);\n\n\treturn cam_id;\n}\n\ns16 rtw_camid_alloc(struct adapter *adapter, struct sta_info *sta, u8 kid)\n{\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\n\tstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\n\ts16 cam_id = -1;\n\tstruct mlme_ext_info *mlmeinfo;\n\n\tspin_lock_bh(&cam_ctl->lock);\n\n\tmlmeinfo = &adapter->mlmeextpriv.mlmext_info;\n\n\tif ((((mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) || ((mlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))\n\t\t&& !sta) {\n\t\t \n\t\tif (kid > 3) {\n\t\t\tnetdev_dbg(adapter->pnetdev,\n\t\t\t\t   FUNC_ADPT_FMT \" group key with invalid key id:%u\\n\",\n\t\t\t\t   FUNC_ADPT_ARG(adapter), kid);\n\t\t\trtw_warn_on(1);\n\t\t\tgoto bitmap_handle;\n\t\t}\n\n\t\tcam_id = kid;\n\t} else {\n\t\tint i;\n\t\tu8 *addr = sta?sta->hwaddr:NULL;\n\n\t\tif (!sta) {\n\t\t\tif (!(mlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)) {\n\t\t\t\t \n\t\t\t\tgoto bitmap_handle;\n\t\t\t}\n\n\t\t\taddr = get_bssid(&adapter->mlmepriv);\n\t\t}\n\n\t\ti = _rtw_camid_search(adapter, addr, kid);\n\t\tif (i >= 0) {\n\t\t\t \n\t\t\tif (sta || _rtw_camid_is_gk(adapter, i))\n\t\t\t\tcam_id = i;\n\t\t\telse\n\t\t\t\tnetdev_dbg(adapter->pnetdev,\n\t\t\t\t\t   FUNC_ADPT_FMT \" group key id:%u the same key id as pairwise key\\n\",\n\t\t\t\t\t   FUNC_ADPT_ARG(adapter), kid);\n\t\t\tgoto bitmap_handle;\n\t\t}\n\n\t\tfor (i = 4; i < TOTAL_CAM_ENTRY; i++)\n\t\t\tif (!(cam_ctl->bitmap & BIT(i)))\n\t\t\t\tbreak;\n\n\t\tif (i == TOTAL_CAM_ENTRY) {\n\t\t\tif (sta)\n\t\t\t\tnetdev_dbg(adapter->pnetdev,\n\t\t\t\t\t   FUNC_ADPT_FMT \" pairwise key with %pM id:%u no room\\n\",\n\t\t\t\t\t   FUNC_ADPT_ARG(adapter),\n\t\t\t\t\t   MAC_ARG(sta->hwaddr), kid);\n\t\t\telse\n\t\t\t\tnetdev_dbg(adapter->pnetdev,\n\t\t\t\t\t   FUNC_ADPT_FMT \" group key id:%u no room\\n\",\n\t\t\t\t\t   FUNC_ADPT_ARG(adapter), kid);\n\t\t\trtw_warn_on(1);\n\t\t\tgoto bitmap_handle;\n\t\t}\n\n\t\tcam_id = i;\n\t}\n\nbitmap_handle:\n\tif (cam_id >= 0 && cam_id < 32)\n\t\tcam_ctl->bitmap |= BIT(cam_id);\n\n\tspin_unlock_bh(&cam_ctl->lock);\n\n\treturn cam_id;\n}\n\nvoid rtw_camid_free(struct adapter *adapter, u8 cam_id)\n{\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\n\tstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\n\n\tspin_lock_bh(&cam_ctl->lock);\n\n\tif (cam_id < TOTAL_CAM_ENTRY)\n\t\tcam_ctl->bitmap &= ~(BIT(cam_id));\n\n\tspin_unlock_bh(&cam_ctl->lock);\n}\n\nint allocate_fw_sta_entry(struct adapter *padapter)\n{\n\tunsigned int mac_id;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tfor (mac_id = IBSS_START_MAC_ID; mac_id < NUM_STA; mac_id++) {\n\t\tif (pmlmeinfo->FW_sta_info[mac_id].status == 0) {\n\t\t\tpmlmeinfo->FW_sta_info[mac_id].status = 1;\n\t\t\tpmlmeinfo->FW_sta_info[mac_id].retry = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn mac_id;\n}\n\nvoid flush_all_cam_entry(struct adapter *padapter)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tinvalidate_cam_all(padapter);\n\t \n\trtw_hal_set_hwreg(padapter, HW_VAR_SEC_DK_CFG, (u8 *)false);\n\n\tmemset((u8 *)(pmlmeinfo->FW_sta_info), 0, sizeof(pmlmeinfo->FW_sta_info));\n}\n\nint WMM_param_handler(struct adapter *padapter, struct ndis_80211_var_ie *pIE)\n{\n\t \n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tif (pmlmepriv->qospriv.qos_option == 0) {\n\t\tpmlmeinfo->WMM_enable = 0;\n\t\treturn false;\n\t}\n\n\tif (!memcmp(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element)))\n\t\treturn false;\n\telse\n\t\tmemcpy(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element));\n\n\tpmlmeinfo->WMM_enable = 1;\n\treturn true;\n}\n\nstatic void sort_wmm_ac_params(u32 *inx, u32 *edca)\n{\n\tu32 i, j, change_inx = false;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tfor (j = i + 1; j < 4; j++) {\n\t\t\t \n\t\t\tif ((edca[j] & 0xFFFF) < (edca[i] & 0xFFFF)) {\n\t\t\t\tchange_inx = true;\n\t\t\t} else if ((edca[j] & 0xFFFF) == (edca[i] & 0xFFFF)) {\n\t\t\t\t \n\t\t\t\tif ((edca[j] >> 16) > (edca[i] >> 16))\n\t\t\t\t\tchange_inx = true;\n\t\t\t}\n\n\t\t\tif (change_inx) {\n\t\t\t\tswap(edca[i], edca[j]);\n\t\t\t\tswap(inx[i], inx[j]);\n\n\t\t\t\tchange_inx = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid WMMOnAssocRsp(struct adapter *padapter)\n{\n\tu8 ACI, ACM, AIFS, ECWMin, ECWMax, aSifsTime;\n\tu8 acm_mask;\n\tu16 TXOP;\n\tu32 acParm, i;\n\tu32 edca[4], inx[4];\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct registry_priv *pregpriv = &padapter->registrypriv;\n\n\tacm_mask = 0;\n\n\tif (pmlmeext->cur_wireless_mode & WIRELESS_11_24N)\n\t\taSifsTime = 16;\n\telse\n\t\taSifsTime = 10;\n\n\tif (pmlmeinfo->WMM_enable == 0) {\n\t\tpadapter->mlmepriv.acm_mask = 0;\n\n\t\tAIFS = aSifsTime + (2 * pmlmeinfo->slotTime);\n\n\t\tif (pmlmeext->cur_wireless_mode & WIRELESS_11G) {\n\t\t\tECWMin = 4;\n\t\t\tECWMax = 10;\n\t\t} else if (pmlmeext->cur_wireless_mode & WIRELESS_11B) {\n\t\t\tECWMin = 5;\n\t\t\tECWMax = 10;\n\t\t} else {\n\t\t\tECWMin = 4;\n\t\t\tECWMax = 10;\n\t\t}\n\n\t\tTXOP = 0;\n\t\tacParm = AIFS | (ECWMin << 8) | (ECWMax << 12) | (TXOP << 16);\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BE, (u8 *)(&acParm));\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BK, (u8 *)(&acParm));\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VI, (u8 *)(&acParm));\n\n\t\tECWMin = 2;\n\t\tECWMax = 3;\n\t\tTXOP = 0x2f;\n\t\tacParm = AIFS | (ECWMin << 8) | (ECWMax << 12) | (TXOP << 16);\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VO, (u8 *)(&acParm));\n\t} else {\n\t\tedca[0] = edca[1] = edca[2] = edca[3] = 0;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tACI = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 5) & 0x03;\n\t\t\tACM = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 4) & 0x01;\n\n\t\t\t \n\t\t\tAIFS = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN & 0x0f) * pmlmeinfo->slotTime + aSifsTime;\n\n\t\t\tECWMin = (pmlmeinfo->WMM_param.ac_param[i].CW & 0x0f);\n\t\t\tECWMax = (pmlmeinfo->WMM_param.ac_param[i].CW & 0xf0) >> 4;\n\t\t\tTXOP = le16_to_cpu(pmlmeinfo->WMM_param.ac_param[i].TXOP_limit);\n\n\t\t\tacParm = AIFS | (ECWMin << 8) | (ECWMax << 12) | (TXOP << 16);\n\n\t\t\tswitch (ACI) {\n\t\t\tcase 0x0:\n\t\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BE, (u8 *)(&acParm));\n\t\t\t\tacm_mask |= (ACM ? BIT(1):0);\n\t\t\t\tedca[XMIT_BE_QUEUE] = acParm;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x1:\n\t\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BK, (u8 *)(&acParm));\n\t\t\t\t \n\t\t\t\tedca[XMIT_BK_QUEUE] = acParm;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2:\n\t\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VI, (u8 *)(&acParm));\n\t\t\t\tacm_mask |= (ACM ? BIT(2):0);\n\t\t\t\tedca[XMIT_VI_QUEUE] = acParm;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x3:\n\t\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VO, (u8 *)(&acParm));\n\t\t\t\tacm_mask |= (ACM ? BIT(3):0);\n\t\t\t\tedca[XMIT_VO_QUEUE] = acParm;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (padapter->registrypriv.acm_method == 1)\n\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_ACM_CTRL, (u8 *)(&acm_mask));\n\t\telse\n\t\t\tpadapter->mlmepriv.acm_mask = acm_mask;\n\n\t\tinx[0] = 0; inx[1] = 1; inx[2] = 2; inx[3] = 3;\n\n\t\tif (pregpriv->wifi_spec == 1)\n\t\t\tsort_wmm_ac_params(inx, edca);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tpxmitpriv->wmm_para_seq[i] = inx[i];\n\t}\n}\n\nstatic void bwmode_update_check(struct adapter *padapter, struct ndis_80211_var_ie *pIE)\n{\n\tunsigned char  new_bwmode;\n\tunsigned char  new_ch_offset;\n\tstruct HT_info_element\t *pHT_info;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\tstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\n\tu8 cbw40_enable = 0;\n\n\tif (!pIE)\n\t\treturn;\n\n\tif (phtpriv->ht_option == false)\n\t\treturn;\n\n\tif (pIE->length > sizeof(struct HT_info_element))\n\t\treturn;\n\n\tpHT_info = (struct HT_info_element *)pIE->data;\n\n\tif (pmlmeext->cur_channel > 14) {\n\t\tif ((pregistrypriv->bw_mode & 0xf0) > 0)\n\t\t\tcbw40_enable = 1;\n\t} else {\n\t\tif ((pregistrypriv->bw_mode & 0x0f) > 0)\n\t\t\tcbw40_enable = 1;\n\t}\n\n\tif ((pHT_info->infos[0] & BIT(2)) && cbw40_enable) {\n\t\tnew_bwmode = CHANNEL_WIDTH_40;\n\n\t\tswitch (pHT_info->infos[0] & 0x3) {\n\t\tcase 1:\n\t\t\tnew_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tnew_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnew_bwmode = CHANNEL_WIDTH_20;\n\t\t\tnew_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tnew_bwmode = CHANNEL_WIDTH_20;\n\t\tnew_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\t}\n\n\tif ((new_bwmode != pmlmeext->cur_bwmode) || (new_ch_offset != pmlmeext->cur_ch_offset)) {\n\t\tpmlmeinfo->bwmode_updated = true;\n\n\t\tpmlmeext->cur_bwmode = new_bwmode;\n\t\tpmlmeext->cur_ch_offset = new_ch_offset;\n\n\t\t \n\t\tHT_info_handler(padapter, pIE);\n\t} else {\n\t\tpmlmeinfo->bwmode_updated = false;\n\t}\n\n\tif (true == pmlmeinfo->bwmode_updated) {\n\t\tstruct sta_info *psta;\n\t\tstruct wlan_bssid_ex\t*cur_network = &(pmlmeinfo->network);\n\t\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\n\t\t \n\n\t\t \n\t\tpsta = rtw_get_stainfo(pstapriv, cur_network->mac_address);\n\t\tif (psta) {\n\t\t\tstruct ht_priv *phtpriv_sta = &psta->htpriv;\n\n\t\t\tif (phtpriv_sta->ht_option) {\n\t\t\t\t \n\t\t\t\tpsta->bw_mode = pmlmeext->cur_bwmode;\n\t\t\t\tphtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;\n\t\t\t} else {\n\t\t\t\tpsta->bw_mode = CHANNEL_WIDTH_20;\n\t\t\t\tphtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\t\t\t}\n\n\t\t\trtw_dm_ra_mask_wk_cmd(padapter, (u8 *)psta);\n\t\t}\n\t}\n}\n\nvoid HT_caps_handler(struct adapter *padapter, struct ndis_80211_var_ie *pIE)\n{\n\tunsigned int\ti;\n\tu8 max_AMPDU_len, min_MPDU_spacing;\n\tu8 cur_ldpc_cap = 0, cur_stbc_cap = 0;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\n\n\tif (!pIE)\n\t\treturn;\n\n\tif (phtpriv->ht_option == false)\n\t\treturn;\n\n\tpmlmeinfo->HT_caps_enable = 1;\n\n\tfor (i = 0; i < (pIE->length); i++) {\n\t\tif (i != 2) {\n\t\t\t \n\t\t\t \n\t\t\tpmlmeinfo->HT_caps.u.HT_cap[i] &= (pIE->data[i]);\n\t\t} else {\n\t\t\t \n\t\t\tmax_AMPDU_len = min(pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x3,\n\t\t\t\t\t    pIE->data[i] & 0x3);\n\n\t\t\tmin_MPDU_spacing = max(pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c,\n\t\t\t\t\t       pIE->data[i] & 0x1c);\n\n\t\t\tpmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para = max_AMPDU_len | min_MPDU_spacing;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\tpmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= pmlmeext->default_supported_mcs_set[i];\n\n\t \n\tset_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_1R);\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\t \n\t\tif (TEST_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_TX) &&\n\t\t    GET_HT_CAPABILITY_ELE_TX_STBC(pIE->data))\n\t\t\tSET_FLAG(cur_stbc_cap, STBC_HT_ENABLE_TX);\n\n\t\tphtpriv->stbc_cap = cur_stbc_cap;\n\t} else {\n\t\t \n\t\tif (TEST_FLAG(phtpriv->ldpc_cap, LDPC_HT_ENABLE_TX) &&\n\t\t    GET_HT_CAPABILITY_ELE_LDPC_CAP(pIE->data))\n\t\t\tSET_FLAG(cur_ldpc_cap, (LDPC_HT_ENABLE_TX | LDPC_HT_CAP_TX));\n\n\t\tphtpriv->ldpc_cap = cur_ldpc_cap;\n\n\t\t \n\t\tif (TEST_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_TX) &&\n\t\t    GET_HT_CAPABILITY_ELE_RX_STBC(pIE->data))\n\t\t\tSET_FLAG(cur_stbc_cap, (STBC_HT_ENABLE_TX | STBC_HT_CAP_TX));\n\n\t\tphtpriv->stbc_cap = cur_stbc_cap;\n\t}\n}\n\nvoid HT_info_handler(struct adapter *padapter, struct ndis_80211_var_ie *pIE)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\n\n\tif (!pIE)\n\t\treturn;\n\n\tif (phtpriv->ht_option == false)\n\t\treturn;\n\n\tif (pIE->length > sizeof(struct HT_info_element))\n\t\treturn;\n\n\tpmlmeinfo->HT_info_enable = 1;\n\tmemcpy(&(pmlmeinfo->HT_info), pIE->data, pIE->length);\n}\n\nvoid HTOnAssocRsp(struct adapter *padapter)\n{\n\tunsigned char max_AMPDU_len;\n\tunsigned char min_MPDU_spacing;\n\t \n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tif ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable)) {\n\t\tpmlmeinfo->HT_enable = 1;\n\t} else {\n\t\tpmlmeinfo->HT_enable = 0;\n\t\t \n\t\treturn;\n\t}\n\n\t \n\t \n\tmax_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;\n\n\tmin_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) >> 2;\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_MIN_SPACE, (u8 *)(&min_MPDU_spacing));\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_FACTOR, (u8 *)(&max_AMPDU_len));\n}\n\nvoid ERP_IE_handler(struct adapter *padapter, struct ndis_80211_var_ie *pIE)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tif (pIE->length > 1)\n\t\treturn;\n\n\tpmlmeinfo->ERP_enable = 1;\n\tmemcpy(&(pmlmeinfo->ERP_IE), pIE->data, pIE->length);\n}\n\nvoid VCS_update(struct adapter *padapter, struct sta_info *psta)\n{\n\tstruct registry_priv  *pregpriv = &padapter->registrypriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tswitch (pregpriv->vrtl_carrier_sense) { \n\tcase 0:  \n\t\tpsta->rtsen = 0;\n\t\tpsta->cts2self = 0;\n\t\tbreak;\n\n\tcase 1:  \n\t\tif (pregpriv->vcs_type == 1) {  \n\t\t\tpsta->rtsen = 1;\n\t\t\tpsta->cts2self = 0;\n\t\t} else {\n\t\t\tpsta->rtsen = 0;\n\t\t\tpsta->cts2self = 1;\n\t\t}\n\t\tbreak;\n\n\tcase 2:  \n\tdefault:\n\t\tif ((pmlmeinfo->ERP_enable) && (pmlmeinfo->ERP_IE & BIT(1))) {\n\t\t\tif (pregpriv->vcs_type == 1) {\n\t\t\t\tpsta->rtsen = 1;\n\t\t\t\tpsta->cts2self = 0;\n\t\t\t} else {\n\t\t\t\tpsta->rtsen = 0;\n\t\t\t\tpsta->cts2self = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tpsta->rtsen = 0;\n\t\t\tpsta->cts2self = 0;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid update_ldpc_stbc_cap(struct sta_info *psta)\n{\n\tif (psta->htpriv.ht_option) {\n\t\tif (TEST_FLAG(psta->htpriv.ldpc_cap, LDPC_HT_ENABLE_TX))\n\t\t\tpsta->ldpc = 1;\n\n\t\tif (TEST_FLAG(psta->htpriv.stbc_cap, STBC_HT_ENABLE_TX))\n\t\t\tpsta->stbc = 1;\n\t} else {\n\t\tpsta->ldpc = 0;\n\t\tpsta->stbc = 0;\n\t}\n}\n\nint rtw_check_bcn_info(struct adapter *Adapter, u8 *pframe, u32 packet_len)\n{\n\tunsigned int len;\n\tunsigned char *p;\n\tunsigned short\tval16, subtype;\n\tstruct wlan_network *cur_network = &(Adapter->mlmepriv.cur_network);\n\t \n\tu16 wpa_len = 0, rsn_len = 0;\n\tu8 encryp_protocol = 0;\n\tstruct wlan_bssid_ex *bssid;\n\tint group_cipher = 0, pairwise_cipher = 0, is_8021x = 0;\n\tunsigned char *pbuf;\n\tu32 wpa_ielen = 0;\n\tu8 *pbssid = GetAddr3Ptr(pframe);\n\tstruct HT_info_element *pht_info = NULL;\n\tstruct ieee80211_ht_cap *pht_cap = NULL;\n\tu32 bcn_channel;\n\tunsigned short\tht_cap_info;\n\tunsigned char ht_info_infos_0;\n\tstruct mlme_priv *pmlmepriv = &Adapter->mlmepriv;\n\tint ssid_len;\n\n\tif (is_client_associated_to_ap(Adapter) == false)\n\t\treturn true;\n\n\tlen = packet_len - sizeof(struct ieee80211_hdr_3addr);\n\n\tif (len > MAX_IE_SZ)\n\t\treturn _FAIL;\n\n\tif (memcmp(cur_network->network.mac_address, pbssid, 6))\n\t\treturn true;\n\n\tbssid = rtw_zmalloc(sizeof(struct wlan_bssid_ex));\n\tif (!bssid)\n\t\treturn true;\n\n\tif ((pmlmepriv->timeBcnInfoChkStart != 0) && (jiffies_to_msecs(jiffies - pmlmepriv->timeBcnInfoChkStart) > DISCONNECT_BY_CHK_BCN_FAIL_OBSERV_PERIOD_IN_MS)) {\n\t\tpmlmepriv->timeBcnInfoChkStart = 0;\n\t\tpmlmepriv->NumOfBcnInfoChkFail = 0;\n\t}\n\n\tsubtype = GetFrameSubType(pframe) >> 4;\n\n\tif (subtype == WIFI_BEACON)\n\t\tbssid->reserved[0] = 1;\n\n\tbssid->length = sizeof(struct wlan_bssid_ex) - MAX_IE_SZ + len;\n\n\t \n\tbssid->ie_length = len;\n\tmemcpy(bssid->ies, (pframe + sizeof(struct ieee80211_hdr_3addr)), bssid->ie_length);\n\n\t \n\t \n\tp = rtw_get_ie(bssid->ies + _FIXED_IE_LENGTH_, WLAN_EID_HT_CAPABILITY, &len, bssid->ie_length - _FIXED_IE_LENGTH_);\n\tif (p && len > 0) {\n\t\tpht_cap = (struct ieee80211_ht_cap *)(p + 2);\n\t\tht_cap_info = le16_to_cpu(pht_cap->cap_info);\n\t} else {\n\t\tht_cap_info = 0;\n\t}\n\t \n\tp = rtw_get_ie(bssid->ies + _FIXED_IE_LENGTH_, WLAN_EID_HT_OPERATION, &len, bssid->ie_length - _FIXED_IE_LENGTH_);\n\tif (p && len > 0) {\n\t\tpht_info = (struct HT_info_element *)(p + 2);\n\t\tht_info_infos_0 = pht_info->infos[0];\n\t} else {\n\t\tht_info_infos_0 = 0;\n\t}\n\tif (ht_cap_info != cur_network->bcn_info.ht_cap_info ||\n\t    ((ht_info_infos_0&0x03) != (cur_network->bcn_info.ht_info_infos_0&0x03))) {\n\t\t{\n\t\t\t \n\t\t\tcur_network->bcn_info.ht_cap_info = ht_cap_info;\n\t\t\tcur_network->bcn_info.ht_info_infos_0 = ht_info_infos_0;\n\t\t\t \n\t\t}\n\t\t \n\t}\n\n\t \n\tp = rtw_get_ie(bssid->ies + _FIXED_IE_LENGTH_, WLAN_EID_DS_PARAMS, &len, bssid->ie_length - _FIXED_IE_LENGTH_);\n\tif (p) {\n\t\tbcn_channel = *(p + 2);\n\t} else { \n\t\trtw_get_ie(bssid->ies + _FIXED_IE_LENGTH_, WLAN_EID_HT_OPERATION,\n\t\t\t   &len, bssid->ie_length - _FIXED_IE_LENGTH_);\n\t\tif (pht_info)\n\t\t\tbcn_channel = pht_info->primary_channel;\n\t\telse  \n\t\t\tbcn_channel = Adapter->mlmeextpriv.cur_channel;\n\t}\n\n\tif (bcn_channel != Adapter->mlmeextpriv.cur_channel)\n\t\tgoto _mismatch;\n\n\t \n\tssid_len = 0;\n\tp = rtw_get_ie(bssid->ies + _FIXED_IE_LENGTH_, WLAN_EID_SSID, &len, bssid->ie_length - _FIXED_IE_LENGTH_);\n\tif (p) {\n\t\tssid_len = *(p + 1);\n\t\tif (ssid_len > NDIS_802_11_LENGTH_SSID)\n\t\t\tssid_len = 0;\n\t}\n\tmemcpy(bssid->ssid.ssid, (p + 2), ssid_len);\n\tbssid->ssid.ssid_length = ssid_len;\n\n\tif (memcmp(bssid->ssid.ssid, cur_network->network.ssid.ssid, 32) ||\n\t\t\tbssid->ssid.ssid_length != cur_network->network.ssid.ssid_length)\n\t\tif (bssid->ssid.ssid[0] != '\\0' &&\n\t\t    bssid->ssid.ssid_length != 0)  \n\t\t\tgoto _mismatch;\n\n\t \n\tval16 = rtw_get_capability((struct wlan_bssid_ex *)bssid);\n\n\tif (val16 & BIT(4))\n\t\tbssid->privacy = 1;\n\telse\n\t\tbssid->privacy = 0;\n\n\tif (cur_network->network.privacy != bssid->privacy)\n\t\tgoto _mismatch;\n\n\trtw_get_sec_ie(bssid->ies, bssid->ie_length, NULL, &rsn_len, NULL, &wpa_len);\n\n\tif (rsn_len > 0)\n\t\tencryp_protocol = ENCRYP_PROTOCOL_WPA2;\n\telse if (wpa_len > 0)\n\t\tencryp_protocol = ENCRYP_PROTOCOL_WPA;\n\telse\n\t\tif (bssid->privacy)\n\t\t\tencryp_protocol = ENCRYP_PROTOCOL_WEP;\n\n\tif (cur_network->bcn_info.encryp_protocol != encryp_protocol)\n\t\tgoto _mismatch;\n\n\tif (encryp_protocol == ENCRYP_PROTOCOL_WPA || encryp_protocol == ENCRYP_PROTOCOL_WPA2) {\n\t\tpbuf = rtw_get_wpa_ie(&bssid->ies[12], &wpa_ielen, bssid->ie_length-12);\n\t\tif (pbuf && (wpa_ielen > 0)) {\n\t\t\trtw_parse_wpa_ie(pbuf, wpa_ielen + 2, &group_cipher,\n\t\t\t\t\t &pairwise_cipher, &is_8021x);\n\t\t} else {\n\t\t\tpbuf = rtw_get_wpa2_ie(&bssid->ies[12], &wpa_ielen, bssid->ie_length-12);\n\n\t\t\tif (pbuf && (wpa_ielen > 0))\n\t\t\t\trtw_parse_wpa2_ie(pbuf, wpa_ielen + 2, &group_cipher,\n\t\t\t\t\t\t  &pairwise_cipher, &is_8021x);\n\t\t}\n\n\t\tif (pairwise_cipher != cur_network->bcn_info.pairwise_cipher ||\n\t\t    group_cipher != cur_network->bcn_info.group_cipher)\n\t\t\tgoto _mismatch;\n\n\t\tif (is_8021x != cur_network->bcn_info.is_8021x)\n\t\t\tgoto _mismatch;\n\t}\n\n\tkfree(bssid);\n\treturn _SUCCESS;\n\n_mismatch:\n\tkfree(bssid);\n\n\tif (pmlmepriv->NumOfBcnInfoChkFail == 0)\n\t\tpmlmepriv->timeBcnInfoChkStart = jiffies;\n\n\tpmlmepriv->NumOfBcnInfoChkFail++;\n\n\tif ((pmlmepriv->timeBcnInfoChkStart != 0) && (jiffies_to_msecs(jiffies - pmlmepriv->timeBcnInfoChkStart) <= DISCONNECT_BY_CHK_BCN_FAIL_OBSERV_PERIOD_IN_MS)\n\t\t&& (pmlmepriv->NumOfBcnInfoChkFail >= DISCONNECT_BY_CHK_BCN_FAIL_THRESHOLD)) {\n\t\tpmlmepriv->timeBcnInfoChkStart = 0;\n\t\tpmlmepriv->NumOfBcnInfoChkFail = 0;\n\t\treturn _FAIL;\n\t}\n\n\treturn _SUCCESS;\n}\n\nvoid update_beacon_info(struct adapter *padapter, u8 *pframe, uint pkt_len, struct sta_info *psta)\n{\n\tunsigned int i;\n\tunsigned int len;\n\tstruct ndis_80211_var_ie *pIE;\n\n\tlen = pkt_len - (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN);\n\n\tfor (i = 0; i < len;) {\n\t\tpIE = (struct ndis_80211_var_ie *)(pframe + (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN) + i);\n\n\t\tswitch (pIE->element_id) {\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t \n\t\t\tif (!memcmp(pIE->data, WMM_PARA_OUI, 6) && pIE->length == WLAN_WMM_LEN)\t \n\t\t\t\tif (WMM_param_handler(padapter, pIE))\n\t\t\t\t\treport_wmm_edca_update(padapter);\n\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_HT_OPERATION:\t \n\t\t\t \n\t\t\tbwmode_update_check(padapter, pIE);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_ERP_INFO:\n\t\t\tERP_IE_handler(padapter, pIE);\n\t\t\tVCS_update(padapter, psta);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\ti += (pIE->length + 2);\n\t}\n}\n\nunsigned int is_ap_in_tkip(struct adapter *padapter)\n{\n\tu32 i;\n\tstruct ndis_80211_var_ie *pIE;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex\t\t*cur_network = &(pmlmeinfo->network);\n\n\tif (rtw_get_capability((struct wlan_bssid_ex *)cur_network) & WLAN_CAPABILITY_PRIVACY) {\n\t\tfor (i = sizeof(struct ndis_802_11_fix_ie); i < pmlmeinfo->network.ie_length;) {\n\t\t\tpIE = (struct ndis_80211_var_ie *)(pmlmeinfo->network.ies + i);\n\n\t\t\tswitch (pIE->element_id) {\n\t\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t\tif ((!memcmp(pIE->data, RTW_WPA_OUI, 4)) && (!memcmp((pIE->data + 12), WPA_TKIP_CIPHER, 4)))\n\t\t\t\t\treturn true;\n\n\t\t\t\tbreak;\n\n\t\t\tcase WLAN_EID_RSN:\n\t\t\t\tif (!memcmp((pIE->data + 8), RSN_TKIP_CIPHER, 4))\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ti += (pIE->length + 2);\n\t\t}\n\n\t\treturn false;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nint support_short_GI(struct adapter *padapter, struct HT_caps_element *pHT_caps, u8 bwmode)\n{\n\tunsigned char bit_offset;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tif (!(pmlmeinfo->HT_enable))\n\t\treturn _FAIL;\n\n\tbit_offset = (bwmode & CHANNEL_WIDTH_40) ? 6 : 5;\n\n\tif (le16_to_cpu(pHT_caps->u.HT_cap_element.HT_caps_info) & (0x1 << bit_offset))\n\t\treturn _SUCCESS;\n\telse\n\t\treturn _FAIL;\n}\n\nunsigned char get_highest_rate_idx(u32 mask)\n{\n\tint i;\n\tunsigned char rate_idx = 0;\n\n\tfor (i = 31; i >= 0; i--) {\n\t\tif (mask & BIT(i)) {\n\t\t\trate_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rate_idx;\n}\n\nvoid Update_RA_Entry(struct adapter *padapter, struct sta_info *psta)\n{\n\trtw_hal_update_ra_mask(psta, 0);\n}\n\nvoid set_sta_rate(struct adapter *padapter, struct sta_info *psta)\n{\n\t \n\tUpdate_RA_Entry(padapter, psta);\n}\n\nstatic u32 get_realtek_assoc_AP_vender(struct ndis_80211_var_ie *pIE)\n{\n\tu32 Vender = HT_IOT_PEER_REALTEK;\n\n\tif (pIE->length >= 5) {\n\t\tif (pIE->data[4] == 1)\n\t\t\t \n\t\t\t \n\t\t\tif (pIE->data[5] & RT_HT_CAP_USE_92SE)\n\t\t\t\t \n\t\t\t\tVender = HT_IOT_PEER_REALTEK_92SE;\n\n\t\tif (pIE->data[5] & RT_HT_CAP_USE_SOFTAP)\n\t\t\tVender = HT_IOT_PEER_REALTEK_SOFTAP;\n\n\t\tif (pIE->data[4] == 2) {\n\t\t\tif (pIE->data[6] & RT_HT_CAP_USE_JAGUAR_BCUT)\n\t\t\t\tVender = HT_IOT_PEER_REALTEK_JAGUAR_BCUTAP;\n\n\t\t\tif (pIE->data[6] & RT_HT_CAP_USE_JAGUAR_CCUT)\n\t\t\t\tVender = HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP;\n\t\t}\n\t}\n\n\treturn Vender;\n}\n\nunsigned char check_assoc_AP(u8 *pframe, uint len)\n{\n\tunsigned int\ti;\n\tstruct ndis_80211_var_ie *pIE;\n\n\tfor (i = sizeof(struct ndis_802_11_fix_ie); i < len;) {\n\t\tpIE = (struct ndis_80211_var_ie *)(pframe + i);\n\n\t\tswitch (pIE->element_id) {\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\tif ((!memcmp(pIE->data, ARTHEROS_OUI1, 3)) || (!memcmp(pIE->data, ARTHEROS_OUI2, 3)))\n\t\t\t\treturn HT_IOT_PEER_ATHEROS;\n\t\t\telse if ((!memcmp(pIE->data, BROADCOM_OUI1, 3)) ||\n\t\t\t\t (!memcmp(pIE->data, BROADCOM_OUI2, 3)) ||\n\t\t\t\t (!memcmp(pIE->data, BROADCOM_OUI3, 3)))\n\t\t\t\treturn HT_IOT_PEER_BROADCOM;\n\t\t\telse if (!memcmp(pIE->data, MARVELL_OUI, 3))\n\t\t\t\treturn HT_IOT_PEER_MARVELL;\n\t\t\telse if (!memcmp(pIE->data, RALINK_OUI, 3))\n\t\t\t\treturn HT_IOT_PEER_RALINK;\n\t\t\telse if (!memcmp(pIE->data, CISCO_OUI, 3))\n\t\t\t\treturn HT_IOT_PEER_CISCO;\n\t\t\telse if (!memcmp(pIE->data, REALTEK_OUI, 3))\n\t\t\t\treturn get_realtek_assoc_AP_vender(pIE);\n\t\t\telse if (!memcmp(pIE->data, AIRGOCAP_OUI, 3))\n\t\t\t\treturn HT_IOT_PEER_AIRGO;\n\t\t\telse\n\t\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\ti += (pIE->length + 2);\n\t}\n\n\treturn HT_IOT_PEER_UNKNOWN;\n}\n\nvoid update_IOT_info(struct adapter *padapter)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tswitch (pmlmeinfo->assoc_AP_vendor) {\n\tcase HT_IOT_PEER_MARVELL:\n\t\tpmlmeinfo->turboMode_cts2self = 1;\n\t\tpmlmeinfo->turboMode_rtsen = 0;\n\t\tbreak;\n\n\tcase HT_IOT_PEER_RALINK:\n\t\tpmlmeinfo->turboMode_cts2self = 0;\n\t\tpmlmeinfo->turboMode_rtsen = 1;\n\t\t \n\t\tSwitch_DM_Func(padapter, (~DYNAMIC_BB_DYNAMIC_TXPWR), false);\n\t\tbreak;\n\tcase HT_IOT_PEER_REALTEK:\n\t\t \n\t\t \n\t\t \n\t\tSwitch_DM_Func(padapter, (~DYNAMIC_BB_DYNAMIC_TXPWR), false);\n\t\tbreak;\n\tdefault:\n\t\tpmlmeinfo->turboMode_cts2self = 0;\n\t\tpmlmeinfo->turboMode_rtsen = 1;\n\t\tbreak;\n\t}\n}\n\nvoid update_capinfo(struct adapter *Adapter, u16 updateCap)\n{\n\tstruct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tbool\t\tShortPreamble;\n\n\t \n\t \n\t \n\t{\n\t\tif (updateCap & cShortPreamble) {\n\t\t\t \n\t\t\tif (pmlmeinfo->preamble_mode != PREAMBLE_SHORT) {  \n\t\t\t\tShortPreamble = true;\n\t\t\t\tpmlmeinfo->preamble_mode = PREAMBLE_SHORT;\n\t\t\t\trtw_hal_set_hwreg(Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&ShortPreamble);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (pmlmeinfo->preamble_mode != PREAMBLE_LONG) {  \n\t\t\t\tShortPreamble = false;\n\t\t\t\tpmlmeinfo->preamble_mode = PREAMBLE_LONG;\n\t\t\t\trtw_hal_set_hwreg(Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&ShortPreamble);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (updateCap & cIBSS) {\n\t\t \n\t\tpmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;\n\t} else {\n\t\t \n\t\tif (pmlmeext->cur_wireless_mode & (WIRELESS_11_24N)) {\n\t\t\tpmlmeinfo->slotTime = SHORT_SLOT_TIME;\n\t\t} else if (pmlmeext->cur_wireless_mode & (WIRELESS_11G)) {\n\t\t\tif ((updateCap & cShortSlotTime)  )\n\t\t\t\t \n\t\t\t\tpmlmeinfo->slotTime = SHORT_SLOT_TIME;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tpmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;\n\t\t} else {\n\t\t\t \n\t\t\tpmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;\n\t\t}\n\t}\n\n\trtw_hal_set_hwreg(Adapter, HW_VAR_SLOT_TIME, &pmlmeinfo->slotTime);\n}\n\nvoid update_wireless_mode(struct adapter *padapter)\n{\n\tint network_type = 0;\n\tu32 SIFS_Timer;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\n\tunsigned char *rate = cur_network->supported_rates;\n\n\tif ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable))\n\t\tpmlmeinfo->HT_enable = 1;\n\n\tif (pmlmeinfo->HT_enable)\n\t\tnetwork_type = WIRELESS_11_24N;\n\n\tif (rtw_is_cckratesonly_included(rate))\n\t\tnetwork_type |= WIRELESS_11B;\n\telse if (rtw_is_cckrates_included(rate))\n\t\tnetwork_type |= WIRELESS_11BG;\n\telse\n\t\tnetwork_type |= WIRELESS_11G;\n\n\tpmlmeext->cur_wireless_mode = network_type & padapter->registrypriv.wireless_mode;\n\n\tSIFS_Timer = 0x0a0a0808;  \n\t\t\t\t\t\t\t\t\t\t\t\t\t \n\n\tpadapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_RESP_SIFS,  (u8 *)&SIFS_Timer);\n\n\tpadapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_WIRELESS_MODE,  (u8 *)&(pmlmeext->cur_wireless_mode));\n\n\tif (pmlmeext->cur_wireless_mode & WIRELESS_11B)\n\t\tupdate_mgnt_tx_rate(padapter, IEEE80211_CCK_RATE_1MB);\n\telse\n\t\tupdate_mgnt_tx_rate(padapter, IEEE80211_OFDM_RATE_6MB);\n}\n\nvoid update_sta_basic_rate(struct sta_info *psta, u8 wireless_mode)\n{\n\tif (is_supported_tx_cck(wireless_mode)) {\n\t\t \n\t\tmemcpy(psta->bssrateset, rtw_basic_rate_cck, 4);\n\t\tpsta->bssratelen = 4;\n\t} else {\n\t\tmemcpy(psta->bssrateset, rtw_basic_rate_ofdm, 3);\n\t\tpsta->bssratelen = 3;\n\t}\n}\n\nint update_sta_support_rate(struct adapter *padapter, u8 *pvar_ie, uint var_ie_len, int cam_idx)\n{\n\tunsigned int\tie_len;\n\tstruct ndis_80211_var_ie *pIE;\n\tint\tsupportRateNum = 0;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tpIE = (struct ndis_80211_var_ie *)rtw_get_ie(pvar_ie, WLAN_EID_SUPP_RATES, &ie_len, var_ie_len);\n\tif (!pIE)\n\t\treturn _FAIL;\n\tif (ie_len > sizeof(pmlmeinfo->FW_sta_info[cam_idx].SupportedRates))\n\t\treturn _FAIL;\n\n\tmemcpy(pmlmeinfo->FW_sta_info[cam_idx].SupportedRates, pIE->data, ie_len);\n\tsupportRateNum = ie_len;\n\n\tpIE = (struct ndis_80211_var_ie *)rtw_get_ie(pvar_ie, WLAN_EID_EXT_SUPP_RATES, &ie_len, var_ie_len);\n\tif (pIE && (ie_len <= sizeof(pmlmeinfo->FW_sta_info[cam_idx].SupportedRates) - supportRateNum))\n\t\tmemcpy((pmlmeinfo->FW_sta_info[cam_idx].SupportedRates + supportRateNum), pIE->data, ie_len);\n\n\treturn _SUCCESS;\n}\n\nvoid process_addba_req(struct adapter *padapter, u8 *paddba_req, u8 *addr)\n{\n\tstruct sta_info *psta;\n\tu16 tid, param;\n\tstruct recv_reorder_ctrl *preorder_ctrl;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct ADDBA_request *preq = (struct ADDBA_request *)paddba_req;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tpsta = rtw_get_stainfo(pstapriv, addr);\n\n\tif (psta) {\n\t\tparam = le16_to_cpu(preq->BA_para_set);\n\t\ttid = (param>>2)&0x0f;\n\n\t\tpreorder_ctrl = &psta->recvreorder_ctrl[tid];\n\n\t\tpreorder_ctrl->indicate_seq = 0xffff;\n\n\t\tpreorder_ctrl->enable = pmlmeinfo->accept_addba_req;\n\t}\n}\n\nvoid update_TSF(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len)\n{\n\tu8 *pIE;\n\t__le32 *pbuf;\n\n\tpIE = pframe + sizeof(struct ieee80211_hdr_3addr);\n\tpbuf = (__le32 *)pIE;\n\n\tpmlmeext->TSFValue = le32_to_cpu(*(pbuf+1));\n\n\tpmlmeext->TSFValue = pmlmeext->TSFValue << 32;\n\n\tpmlmeext->TSFValue |= le32_to_cpu(*pbuf);\n}\n\nvoid correct_TSF(struct adapter *padapter, struct mlme_ext_priv *pmlmeext)\n{\n\trtw_hal_set_hwreg(padapter, HW_VAR_CORRECT_TSF, NULL);\n}\n\nvoid adaptive_early_32k(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len)\n{\n\tint i;\n\tu8 *pIE;\n\t__le32 *pbuf;\n\tu64 tsf = 0;\n\tu32 delay_ms;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tpmlmeext->bcn_cnt++;\n\n\tpIE = pframe + sizeof(struct ieee80211_hdr_3addr);\n\tpbuf = (__le32 *)pIE;\n\n\ttsf = le32_to_cpu(*(pbuf+1));\n\ttsf = tsf << 32;\n\ttsf |= le32_to_cpu(*pbuf);\n\n\t \n\t \n\tdelay_ms = do_div(tsf, (pmlmeinfo->bcn_interval*1024));\n\tdelay_ms = delay_ms/1000;\n\n\tif (delay_ms >= 8)\n\t\tpmlmeext->bcn_delay_cnt[8]++;\n\t\t \n\telse\n\t\tpmlmeext->bcn_delay_cnt[delay_ms]++;\n\t\t \n\n \n\n\t \n\tif (pmlmeext->bcn_cnt > 100 && (pmlmeext->adaptive_tsf_done == true)) {\n\t\tu8 ratio_20_delay, ratio_80_delay;\n\t\tu8 DrvBcnEarly, DrvBcnTimeOut;\n\n\t\tratio_20_delay = 0;\n\t\tratio_80_delay = 0;\n\t\tDrvBcnEarly = 0xff;\n\t\tDrvBcnTimeOut = 0xff;\n\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tpmlmeext->bcn_delay_ratio[i] = (pmlmeext->bcn_delay_cnt[i] * 100) / pmlmeext->bcn_cnt;\n\n\t\t\tratio_20_delay += pmlmeext->bcn_delay_ratio[i];\n\t\t\tratio_80_delay += pmlmeext->bcn_delay_ratio[i];\n\n\t\t\tif (ratio_20_delay > 20 && DrvBcnEarly == 0xff)\n\t\t\t\tDrvBcnEarly = i;\n\n\t\t\tif (ratio_80_delay > 80 && DrvBcnTimeOut == 0xff)\n\t\t\t\tDrvBcnTimeOut = i;\n\n\t\t\t \n\t\t\tpmlmeext->bcn_delay_cnt[i] = 0;\n\t\t\tpmlmeext->bcn_delay_ratio[i] = 0;\n\t\t}\n\n\t\tpmlmeext->DrvBcnEarly = DrvBcnEarly;\n\t\tpmlmeext->DrvBcnTimeOut = DrvBcnTimeOut;\n\n\t\tpmlmeext->bcn_cnt = 0;\n\t}\n}\n\nvoid rtw_alloc_macid(struct adapter *padapter, struct sta_info *psta)\n{\n\tint i;\n\tstruct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);\n\n\tif (is_broadcast_ether_addr(psta->hwaddr))\n\t\treturn;\n\n\tif (!memcmp(psta->hwaddr, myid(&padapter->eeprompriv), ETH_ALEN)) {\n\t\tpsta->mac_id = NUM_STA;\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&pdvobj->lock);\n\tfor (i = 0; i < NUM_STA; i++) {\n\t\tif (pdvobj->macid[i] == false) {\n\t\t\tpdvobj->macid[i]  = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&pdvobj->lock);\n\n\tif (i > (NUM_STA - 1))\n\t\tpsta->mac_id = NUM_STA;\n\telse\n\t\tpsta->mac_id = i;\n}\n\nvoid rtw_release_macid(struct adapter *padapter, struct sta_info *psta)\n{\n\tstruct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);\n\n\tif (is_broadcast_ether_addr(psta->hwaddr))\n\t\treturn;\n\n\tif (!memcmp(psta->hwaddr, myid(&padapter->eeprompriv), ETH_ALEN))\n\t\treturn;\n\n\tspin_lock_bh(&pdvobj->lock);\n\tif (psta->mac_id < NUM_STA && psta->mac_id != 1) {\n\t\tif (pdvobj->macid[psta->mac_id] == true) {\n\t\t\tpdvobj->macid[psta->mac_id] = false;\n\t\t\tpsta->mac_id = NUM_STA;\n\t\t}\n\t}\n\tspin_unlock_bh(&pdvobj->lock);\n}\n\n \nu8 rtw_search_max_mac_id(struct adapter *padapter)\n{\n\tu8 max_mac_id = 0;\n\tstruct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);\n\tint i;\n\n\tspin_lock_bh(&pdvobj->lock);\n\tfor (i = (NUM_STA-1); i >= 0 ; i--) {\n\t\tif (pdvobj->macid[i] == true)\n\t\t\tbreak;\n\t}\n\tmax_mac_id = i;\n\tspin_unlock_bh(&pdvobj->lock);\n\n\treturn max_mac_id;\n}\n\nstruct adapter *dvobj_get_port0_adapter(struct dvobj_priv *dvobj)\n{\n\tif (get_iface_type(dvobj->padapters[i]) != IFACE_PORT0)\n\t\treturn NULL;\n\n\treturn dvobj->padapters;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}