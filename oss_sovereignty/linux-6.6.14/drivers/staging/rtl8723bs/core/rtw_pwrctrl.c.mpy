{
  "module_name": "rtw_pwrctrl.c",
  "hash_id": "c8d6e099108693a282ea56d55e03f65bf43d5d7fc34590657362a41aadc88842",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/core/rtw_pwrctrl.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <hal_data.h>\n#include <linux/jiffies.h>\n\n\nvoid _ips_enter(struct adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\n\tpwrpriv->bips_processing = true;\n\n\t \n\tpwrpriv->ips_mode = pwrpriv->ips_mode_req;\n\n\tpwrpriv->ips_enter_cnts++;\n\n\tif (rf_off == pwrpriv->change_rfpwrstate) {\n\t\tpwrpriv->bpower_saving = true;\n\n\t\tif (pwrpriv->ips_mode == IPS_LEVEL_2)\n\t\t\tpwrpriv->bkeepfwalive = true;\n\n\t\trtw_ips_pwr_down(padapter);\n\t\tpwrpriv->rf_pwrstate = rf_off;\n\t}\n\tpwrpriv->bips_processing = false;\n\n}\n\nvoid ips_enter(struct adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\n\n\thal_btcoex_IpsNotify(padapter, pwrpriv->ips_mode_req);\n\n\tmutex_lock(&pwrpriv->lock);\n\t_ips_enter(padapter);\n\tmutex_unlock(&pwrpriv->lock);\n}\n\nint _ips_leave(struct adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\tint result = _SUCCESS;\n\n\tif ((pwrpriv->rf_pwrstate == rf_off) && (!pwrpriv->bips_processing)) {\n\t\tpwrpriv->bips_processing = true;\n\t\tpwrpriv->change_rfpwrstate = rf_on;\n\t\tpwrpriv->ips_leave_cnts++;\n\n\t\tresult = rtw_ips_pwr_up(padapter);\n\t\tif (result == _SUCCESS) {\n\t\t\tpwrpriv->rf_pwrstate = rf_on;\n\t\t}\n\t\tpwrpriv->bips_processing = false;\n\n\t\tpwrpriv->bkeepfwalive = false;\n\t\tpwrpriv->bpower_saving = false;\n\t}\n\n\treturn result;\n}\n\nint ips_leave(struct adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\tint ret;\n\n\tif (!is_primary_adapter(padapter))\n\t\treturn _SUCCESS;\n\n\tmutex_lock(&pwrpriv->lock);\n\tret = _ips_leave(padapter);\n\tmutex_unlock(&pwrpriv->lock);\n\n\tif (ret == _SUCCESS)\n\t\thal_btcoex_IpsNotify(padapter, IPS_NONE);\n\n\treturn ret;\n}\n\nstatic bool rtw_pwr_unassociated_idle(struct adapter *adapter)\n{\n\tstruct adapter *buddy = adapter->pbuddy_adapter;\n\tstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\n\tstruct xmit_priv *pxmit_priv = &adapter->xmitpriv;\n\n\tbool ret = false;\n\n\tif (adapter_to_pwrctl(adapter)->bpower_saving)\n\t\tgoto exit;\n\n\tif (time_before(jiffies, adapter_to_pwrctl(adapter)->ips_deny_time))\n\t\tgoto exit;\n\n\tif (check_fwstate(pmlmepriv, WIFI_ASOC_STATE|WIFI_SITE_MONITOR)\n\t\t|| check_fwstate(pmlmepriv, WIFI_UNDER_LINKING|WIFI_UNDER_WPS)\n\t\t|| check_fwstate(pmlmepriv, WIFI_AP_STATE)\n\t\t|| check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_ADHOC_STATE)\n\t)\n\t\tgoto exit;\n\n\t \n\tif (buddy) {\n\t\tstruct mlme_priv *b_pmlmepriv = &(buddy->mlmepriv);\n\n\t\tif (check_fwstate(b_pmlmepriv, WIFI_ASOC_STATE|WIFI_SITE_MONITOR)\n\t\t\t|| check_fwstate(b_pmlmepriv, WIFI_UNDER_LINKING|WIFI_UNDER_WPS)\n\t\t\t|| check_fwstate(b_pmlmepriv, WIFI_AP_STATE)\n\t\t\t|| check_fwstate(b_pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_ADHOC_STATE)\n\t\t)\n\t\t\tgoto exit;\n\t}\n\n\tif (pxmit_priv->free_xmitbuf_cnt != NR_XMITBUFF ||\n\t\tpxmit_priv->free_xmit_extbuf_cnt != NR_XMIT_EXTBUFF) {\n\t\tnetdev_dbg(adapter->pnetdev,\n\t\t\t   \"There are some pkts to transmit\\n\");\n\t\tnetdev_dbg(adapter->pnetdev,\n\t\t\t   \"free_xmitbuf_cnt: %d, free_xmit_extbuf_cnt: %d\\n\",\n\t\t\t   pxmit_priv->free_xmitbuf_cnt,\n\t\t\t   pxmit_priv->free_xmit_extbuf_cnt);\n\t\tgoto exit;\n\t}\n\n\tret = true;\n\nexit:\n\treturn ret;\n}\n\n\n \nvoid rtw_ps_processor(struct adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\tstruct dvobj_priv *psdpriv = padapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\tu32 ps_deny = 0;\n\n\tmutex_lock(&adapter_to_pwrctl(padapter)->lock);\n\tps_deny = rtw_ps_deny_get(padapter);\n\tmutex_unlock(&adapter_to_pwrctl(padapter)->lock);\n\tif (ps_deny != 0)\n\t\tgoto exit;\n\n\tif (pwrpriv->bInSuspend) { \n\t\tpdbgpriv->dbg_ps_insuspend_cnt++;\n\t\treturn;\n\t}\n\n\tpwrpriv->ps_processing = true;\n\n\tif (pwrpriv->ips_mode_req == IPS_NONE)\n\t\tgoto exit;\n\n\tif (!rtw_pwr_unassociated_idle(padapter))\n\t\tgoto exit;\n\n\tif ((pwrpriv->rf_pwrstate == rf_on) && ((pwrpriv->pwr_state_check_cnts%4) == 0)) {\n\t\tpwrpriv->change_rfpwrstate = rf_off;\n\t\t{\n\t\t\tips_enter(padapter);\n\t\t}\n\t}\nexit:\n\tpwrpriv->ps_processing = false;\n}\n\nstatic void pwr_state_check_handler(struct timer_list *t)\n{\n\tstruct pwrctrl_priv *pwrctrlpriv =\n\t\tfrom_timer(pwrctrlpriv, t, pwr_state_check_timer);\n\tstruct adapter *padapter = pwrctrlpriv->adapter;\n\n\trtw_ps_cmd(padapter);\n}\n\nvoid traffic_check_for_leave_lps(struct adapter *padapter, u8 tx, u32 tx_packets)\n{\n\tstatic unsigned long start_time;\n\tstatic u32 xmit_cnt;\n\tu8 bLeaveLPS = false;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\n\n\tif (tx) {  \n\t\txmit_cnt += tx_packets;\n\n\t\tif (start_time == 0)\n\t\t\tstart_time = jiffies;\n\n\t\tif (jiffies_to_msecs(jiffies - start_time) > 2000) {  \n\t\t\tif (xmit_cnt > 8) {\n\t\t\t\tif (adapter_to_pwrctl(padapter)->bLeisurePs\n\t\t\t\t    && (adapter_to_pwrctl(padapter)->pwr_mode != PS_MODE_ACTIVE)\n\t\t\t\t    && !(hal_btcoex_IsBtControlLps(padapter))) {\n\t\t\t\t\tbLeaveLPS = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstart_time = jiffies;\n\t\t\txmit_cnt = 0;\n\t\t}\n\n\t} else {  \n\t\tif (pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 4 ) {\n\t\t\tif (adapter_to_pwrctl(padapter)->bLeisurePs\n\t\t\t    && (adapter_to_pwrctl(padapter)->pwr_mode != PS_MODE_ACTIVE)\n\t\t\t    && !(hal_btcoex_IsBtControlLps(padapter)))\n\t\t\t\tbLeaveLPS = true;\n\t\t}\n\t}\n\n\tif (bLeaveLPS)\n\t\t \n\t\trtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_LEAVE, tx?0:1);\n}\n\n \nvoid rtw_set_rpwm(struct adapter *padapter, u8 pslv)\n{\n\tu8 rpwm;\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\tu8 cpwm_orig;\n\n\tpslv = PS_STATE(pslv);\n\n\tif (!pwrpriv->brpwmtimeout) {\n\t\tif (pwrpriv->rpwm == pslv ||\n\t\t    (pwrpriv->rpwm >= PS_STATE_S2 && pslv >= PS_STATE_S2))\n\t\t\treturn;\n\n\t}\n\n\tif ((padapter->bSurpriseRemoved) || !(padapter->hw_init_completed)) {\n\t\tpwrpriv->cpwm = PS_STATE_S4;\n\n\t\treturn;\n\t}\n\n\tif (padapter->bDriverStopped) {\n\t\tif (pslv < PS_STATE_S2)\n\t\t\treturn;\n\t}\n\n\trpwm = pslv | pwrpriv->tog;\n\t \n\tif ((pwrpriv->cpwm < PS_STATE_S2) && (pslv >= PS_STATE_S2))\n\t\trpwm |= PS_ACK;\n\n\tpwrpriv->rpwm = pslv;\n\n\tcpwm_orig = 0;\n\tif (rpwm & PS_ACK)\n\t\trtw_hal_get_hwreg(padapter, HW_VAR_CPWM, &cpwm_orig);\n\n\tif (rpwm & PS_ACK)\n\t\t_set_timer(&pwrpriv->pwr_rpwm_timer, LPS_RPWM_WAIT_MS);\n\trtw_hal_set_hwreg(padapter, HW_VAR_SET_RPWM, (u8 *)(&rpwm));\n\n\tpwrpriv->tog += 0x80;\n\n\t \n\tif (rpwm & PS_ACK) {\n\t\tunsigned long start_time;\n\t\tu8 cpwm_now;\n\t\tu8 poll_cnt = 0;\n\n\t\tstart_time = jiffies;\n\n\t\t \n\t\tdo {\n\t\t\tmdelay(1);\n\t\t\tpoll_cnt++;\n\t\t\trtw_hal_get_hwreg(padapter, HW_VAR_CPWM, &cpwm_now);\n\t\t\tif ((cpwm_orig ^ cpwm_now) & 0x80) {\n\t\t\t\tpwrpriv->cpwm = PS_STATE_S4;\n\t\t\t\tpwrpriv->cpwm_tog = cpwm_now & PS_TOGGLE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (jiffies_to_msecs(jiffies - start_time) > LPS_RPWM_WAIT_MS) {\n\t\t\t\t_set_timer(&pwrpriv->pwr_rpwm_timer, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (1);\n\t} else\n\t\tpwrpriv->cpwm = pslv;\n}\n\nstatic u8 PS_RDY_CHECK(struct adapter *padapter)\n{\n\tunsigned long curr_time, delta_time;\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\n\tif (pwrpriv->bInSuspend)\n\t\treturn false;\n\n\tcurr_time = jiffies;\n\n\tdelta_time = curr_time - pwrpriv->DelayLPSLastTimeStamp;\n\n\tif (delta_time < LPS_DELAY_TIME)\n\t\treturn false;\n\n\tif (check_fwstate(pmlmepriv, WIFI_SITE_MONITOR)\n\t\t|| check_fwstate(pmlmepriv, WIFI_UNDER_LINKING|WIFI_UNDER_WPS)\n\t\t|| check_fwstate(pmlmepriv, WIFI_AP_STATE)\n\t\t|| check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_ADHOC_STATE)\n\t\t|| rtw_is_scan_deny(padapter)\n\t)\n\t\treturn false;\n\n\tif (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X &&\n\t    !padapter->securitypriv.binstallGrpkey)\n\t\treturn false;\n\n\tif (!rtw_cfg80211_pwr_mgmt(padapter))\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid rtw_set_ps_mode(struct adapter *padapter, u8 ps_mode, u8 smart_ps, u8 bcn_ant_mode, const char *msg)\n{\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\n\tif (ps_mode > PM_Card_Disable)\n\t\treturn;\n\n\tif (pwrpriv->pwr_mode == ps_mode)\n\t\tif (ps_mode == PS_MODE_ACTIVE)\n\t\t\treturn;\n\n\n\tmutex_lock(&pwrpriv->lock);\n\n\t \n\tif (ps_mode == PS_MODE_ACTIVE) {\n\t\tif (!(hal_btcoex_IsBtControlLps(padapter))\n\t\t\t\t|| (hal_btcoex_IsBtControlLps(padapter)\n\t\t\t\t\t&& !(hal_btcoex_IsLpsOn(padapter)))) {\n\t\t\tpwrpriv->pwr_mode = ps_mode;\n\t\t\trtw_set_rpwm(padapter, PS_STATE_S4);\n\n\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, (u8 *)(&ps_mode));\n\t\t\tpwrpriv->fw_current_in_ps_mode = false;\n\n\t\t\thal_btcoex_LpsNotify(padapter, ps_mode);\n\t\t}\n\t} else {\n\t\tif ((PS_RDY_CHECK(padapter) && check_fwstate(&padapter->mlmepriv, WIFI_ASOC_STATE)) ||\n\t\t    ((hal_btcoex_IsBtControlLps(padapter)) && (hal_btcoex_IsLpsOn(padapter)))\n\t\t\t) {\n\t\t\tu8 pslv;\n\n\t\t\thal_btcoex_LpsNotify(padapter, ps_mode);\n\n\t\t\tpwrpriv->fw_current_in_ps_mode = true;\n\t\t\tpwrpriv->pwr_mode = ps_mode;\n\t\t\tpwrpriv->smart_ps = smart_ps;\n\t\t\tpwrpriv->bcn_ant_mode = bcn_ant_mode;\n\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, (u8 *)(&ps_mode));\n\n\t\t\tpslv = PS_STATE_S2;\n\t\t\tif (pwrpriv->alives == 0)\n\t\t\t\tpslv = PS_STATE_S0;\n\n\t\t\tif (!(hal_btcoex_IsBtDisabled(padapter)) &&\n\t\t\t    (hal_btcoex_IsBtControlLps(padapter))) {\n\t\t\t\tu8 val8;\n\n\t\t\t\tval8 = hal_btcoex_LpsVal(padapter);\n\t\t\t\tif (val8 & BIT(4))\n\t\t\t\t\tpslv = PS_STATE_S2;\n\t\t\t}\n\n\t\t\trtw_set_rpwm(padapter, pslv);\n\t\t}\n\t}\n\n\tmutex_unlock(&pwrpriv->lock);\n}\n\n \ns32 LPS_RF_ON_check(struct adapter *padapter, u32 delay_ms)\n{\n\tunsigned long start_time;\n\tu8 bAwake = false;\n\ts32 err = 0;\n\n\n\tstart_time = jiffies;\n\twhile (1) {\n\t\trtw_hal_get_hwreg(padapter, HW_VAR_FWLPS_RF_ON, &bAwake);\n\t\tif (bAwake)\n\t\t\tbreak;\n\n\t\tif (padapter->bSurpriseRemoved) {\n\t\t\terr = -2;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (jiffies_to_msecs(jiffies - start_time) > delay_ms) {\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\treturn err;\n}\n\n \n \n \n \nvoid LPS_Enter(struct adapter *padapter, const char *msg)\n{\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(padapter);\n\tstruct pwrctrl_priv *pwrpriv = dvobj_to_pwrctl(dvobj);\n\tint n_assoc_iface = 0;\n\tchar buf[32] = {0};\n\n\tif (hal_btcoex_IsBtControlLps(padapter))\n\t\treturn;\n\n\t \n\tif (check_fwstate(&(dvobj->padapters->mlmepriv), WIFI_ASOC_STATE))\n\t\tn_assoc_iface++;\n\tif (n_assoc_iface != 1)\n\t\treturn;\n\n\t \n\tif (get_iface_type(padapter) != IFACE_PORT0)\n\t\treturn;\n\n\tif (!PS_RDY_CHECK(dvobj->padapters))\n\t\treturn;\n\n\tif (pwrpriv->bLeisurePs) {\n\t\t \n\t\tif (pwrpriv->LpsIdleCount >= 2) {  \n\t\t\tif (pwrpriv->pwr_mode == PS_MODE_ACTIVE) {\n\t\t\t\tscnprintf(buf, sizeof(buf), \"WIFI-%s\", msg);\n\t\t\t\tpwrpriv->bpower_saving = true;\n\t\t\t\trtw_set_ps_mode(padapter, pwrpriv->power_mgnt, padapter->registrypriv.smart_ps, 0, buf);\n\t\t\t}\n\t\t} else\n\t\t\tpwrpriv->LpsIdleCount++;\n\t}\n}\n\n \n \n \n \nvoid LPS_Leave(struct adapter *padapter, const char *msg)\n{\n#define LPS_LEAVE_TIMEOUT_MS 100\n\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(padapter);\n\tstruct pwrctrl_priv *pwrpriv = dvobj_to_pwrctl(dvobj);\n\tchar buf[32] = {0};\n\n\tif (hal_btcoex_IsBtControlLps(padapter))\n\t\treturn;\n\n\tif (pwrpriv->bLeisurePs) {\n\t\tif (pwrpriv->pwr_mode != PS_MODE_ACTIVE) {\n\t\t\tscnprintf(buf, sizeof(buf), \"WIFI-%s\", msg);\n\t\t\trtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, 0, buf);\n\n\t\t\tif (pwrpriv->pwr_mode == PS_MODE_ACTIVE)\n\t\t\t\tLPS_RF_ON_check(padapter, LPS_LEAVE_TIMEOUT_MS);\n\t\t}\n\t}\n\n\tpwrpriv->bpower_saving = false;\n}\n\nvoid LeaveAllPowerSaveModeDirect(struct adapter *Adapter)\n{\n\tstruct adapter *pri_padapter = GET_PRIMARY_ADAPTER(Adapter);\n\tstruct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(Adapter);\n\n\tif (Adapter->bSurpriseRemoved)\n\t\treturn;\n\n\tif (check_fwstate(pmlmepriv, _FW_LINKED)) {  \n\n\t\tif (pwrpriv->pwr_mode == PS_MODE_ACTIVE)\n\t\t\treturn;\n\n\t\tmutex_lock(&pwrpriv->lock);\n\n\t\trtw_set_rpwm(Adapter, PS_STATE_S4);\n\n\t\tmutex_unlock(&pwrpriv->lock);\n\n\t\trtw_lps_ctrl_wk_cmd(pri_padapter, LPS_CTRL_LEAVE, 0);\n\t} else {\n\t\tif (pwrpriv->rf_pwrstate == rf_off)\n\t\t\tips_leave(pri_padapter);\n\t}\n}\n\n \n \n \n \nvoid LeaveAllPowerSaveMode(struct adapter *Adapter)\n{\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(Adapter);\n\tu8 enqueue = 0;\n\tint n_assoc_iface = 0;\n\n\tif (!Adapter->bup)\n\t\treturn;\n\n\tif (Adapter->bSurpriseRemoved)\n\t\treturn;\n\n\tif (check_fwstate(&(dvobj->padapters->mlmepriv), WIFI_ASOC_STATE))\n\t\tn_assoc_iface++;\n\n\tif (n_assoc_iface) {  \n\t\tenqueue = 1;\n\n\t\trtw_lps_ctrl_wk_cmd(Adapter, LPS_CTRL_LEAVE, enqueue);\n\n\t\tLPS_Leave_check(Adapter);\n\t} else {\n\t\tif (adapter_to_pwrctl(Adapter)->rf_pwrstate == rf_off) {\n\t\t\tips_leave(Adapter);\n\t\t}\n\t}\n}\n\nvoid LPS_Leave_check(struct adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrpriv;\n\tunsigned long\tstart_time;\n\tu8 bReady;\n\n\tpwrpriv = adapter_to_pwrctl(padapter);\n\n\tbReady = false;\n\tstart_time = jiffies;\n\n\tcond_resched();\n\n\twhile (1) {\n\t\tmutex_lock(&pwrpriv->lock);\n\n\t\tif (padapter->bSurpriseRemoved ||\n\t\t    !(padapter->hw_init_completed) ||\n\t\t    (pwrpriv->pwr_mode == PS_MODE_ACTIVE))\n\t\t\tbReady = true;\n\n\t\tmutex_unlock(&pwrpriv->lock);\n\n\t\tif (bReady)\n\t\t\tbreak;\n\n\t\tif (jiffies_to_msecs(jiffies - start_time) > 100)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t}\n}\n\n \nvoid cpwm_int_hdl(struct adapter *padapter, struct reportpwrstate_parm *preportpwrstate)\n{\n\tstruct pwrctrl_priv *pwrpriv;\n\n\tpwrpriv = adapter_to_pwrctl(padapter);\n\n\tmutex_lock(&pwrpriv->lock);\n\n\tif (pwrpriv->rpwm < PS_STATE_S2)\n\t\tgoto exit;\n\n\tpwrpriv->cpwm = PS_STATE(preportpwrstate->state);\n\tpwrpriv->cpwm_tog = preportpwrstate->state & PS_TOGGLE;\n\n\tif (pwrpriv->cpwm >= PS_STATE_S2) {\n\t\tif (pwrpriv->alives & CMD_ALIVE)\n\t\t\tcomplete(&padapter->cmdpriv.cmd_queue_comp);\n\n\t\tif (pwrpriv->alives & XMIT_ALIVE)\n\t\t\tcomplete(&padapter->xmitpriv.xmit_comp);\n\t}\n\nexit:\n\tmutex_unlock(&pwrpriv->lock);\n\n}\n\nstatic void cpwm_event_callback(struct work_struct *work)\n{\n\tstruct pwrctrl_priv *pwrpriv = container_of(work, struct pwrctrl_priv, cpwm_event);\n\tstruct dvobj_priv *dvobj = pwrctl_to_dvobj(pwrpriv);\n\tstruct adapter *adapter = dvobj->if1;\n\tstruct reportpwrstate_parm report;\n\n\treport.state = PS_STATE_S2;\n\tcpwm_int_hdl(adapter, &report);\n}\n\nstatic void rpwmtimeout_workitem_callback(struct work_struct *work)\n{\n\tstruct adapter *padapter;\n\tstruct dvobj_priv *dvobj;\n\tstruct pwrctrl_priv *pwrpriv;\n\n\n\tpwrpriv = container_of(work, struct pwrctrl_priv, rpwmtimeoutwi);\n\tdvobj = pwrctl_to_dvobj(pwrpriv);\n\tpadapter = dvobj->if1;\n\n\tmutex_lock(&pwrpriv->lock);\n\tif ((pwrpriv->rpwm == pwrpriv->cpwm) || (pwrpriv->cpwm >= PS_STATE_S2))\n\t\tgoto exit;\n\n\tmutex_unlock(&pwrpriv->lock);\n\n\tif (rtw_read8(padapter, 0x100) != 0xEA) {\n\t\tstruct reportpwrstate_parm report;\n\n\t\treport.state = PS_STATE_S2;\n\t\tcpwm_int_hdl(padapter, &report);\n\n\t\treturn;\n\t}\n\n\tmutex_lock(&pwrpriv->lock);\n\n\tif ((pwrpriv->rpwm == pwrpriv->cpwm) || (pwrpriv->cpwm >= PS_STATE_S2))\n\t\tgoto exit;\n\n\tpwrpriv->brpwmtimeout = true;\n\trtw_set_rpwm(padapter, pwrpriv->rpwm);\n\tpwrpriv->brpwmtimeout = false;\n\nexit:\n\tmutex_unlock(&pwrpriv->lock);\n}\n\n \nstatic void pwr_rpwm_timeout_handler(struct timer_list *t)\n{\n\tstruct pwrctrl_priv *pwrpriv = from_timer(pwrpriv, t, pwr_rpwm_timer);\n\n\tif ((pwrpriv->rpwm == pwrpriv->cpwm) || (pwrpriv->cpwm >= PS_STATE_S2))\n\t\treturn;\n\n\t_set_workitem(&pwrpriv->rpwmtimeoutwi);\n}\n\nstatic inline void register_task_alive(struct pwrctrl_priv *pwrctrl, u32 tag)\n{\n\tpwrctrl->alives |= tag;\n}\n\nstatic inline void unregister_task_alive(struct pwrctrl_priv *pwrctrl, u32 tag)\n{\n\tpwrctrl->alives &= ~tag;\n}\n\n\n \ns32 rtw_register_task_alive(struct adapter *padapter, u32 task)\n{\n\ts32 res;\n\tstruct pwrctrl_priv *pwrctrl;\n\tu8 pslv;\n\n\tres = _SUCCESS;\n\tpwrctrl = adapter_to_pwrctl(padapter);\n\tpslv = PS_STATE_S2;\n\n\tmutex_lock(&pwrctrl->lock);\n\n\tregister_task_alive(pwrctrl, task);\n\n\tif (pwrctrl->fw_current_in_ps_mode) {\n\t\tif (pwrctrl->cpwm < pslv) {\n\t\t\tif (pwrctrl->cpwm < PS_STATE_S2)\n\t\t\t\tres = _FAIL;\n\t\t\tif (pwrctrl->rpwm < pslv)\n\t\t\t\trtw_set_rpwm(padapter, pslv);\n\t\t}\n\t}\n\n\tmutex_unlock(&pwrctrl->lock);\n\n\tif (res == _FAIL)\n\t\tif (pwrctrl->cpwm >= PS_STATE_S2)\n\t\t\tres = _SUCCESS;\n\n\treturn res;\n}\n\n \nvoid rtw_unregister_task_alive(struct adapter *padapter, u32 task)\n{\n\tstruct pwrctrl_priv *pwrctrl;\n\tu8 pslv;\n\n\tpwrctrl = adapter_to_pwrctl(padapter);\n\tpslv = PS_STATE_S0;\n\n\tif (!(hal_btcoex_IsBtDisabled(padapter)) && hal_btcoex_IsBtControlLps(padapter)) {\n\t\tu8 val8;\n\n\t\tval8 = hal_btcoex_LpsVal(padapter);\n\t\tif (val8 & BIT(4))\n\t\t\tpslv = PS_STATE_S2;\n\t}\n\n\tmutex_lock(&pwrctrl->lock);\n\n\tunregister_task_alive(pwrctrl, task);\n\n\tif ((pwrctrl->pwr_mode != PS_MODE_ACTIVE) && pwrctrl->fw_current_in_ps_mode) {\n\t\tif (pwrctrl->cpwm > pslv)\n\t\t\tif ((pslv >= PS_STATE_S2) || (pwrctrl->alives == 0))\n\t\t\t\trtw_set_rpwm(padapter, pslv);\n\n\t}\n\n\tmutex_unlock(&pwrctrl->lock);\n}\n\n \ns32 rtw_register_tx_alive(struct adapter *padapter)\n{\n\ts32 res;\n\tstruct pwrctrl_priv *pwrctrl;\n\tu8 pslv;\n\n\tres = _SUCCESS;\n\tpwrctrl = adapter_to_pwrctl(padapter);\n\tpslv = PS_STATE_S2;\n\n\tmutex_lock(&pwrctrl->lock);\n\n\tregister_task_alive(pwrctrl, XMIT_ALIVE);\n\n\tif (pwrctrl->fw_current_in_ps_mode) {\n\t\tif (pwrctrl->cpwm < pslv) {\n\t\t\tif (pwrctrl->cpwm < PS_STATE_S2)\n\t\t\t\tres = _FAIL;\n\t\t\tif (pwrctrl->rpwm < pslv)\n\t\t\t\trtw_set_rpwm(padapter, pslv);\n\t\t}\n\t}\n\n\tmutex_unlock(&pwrctrl->lock);\n\n\tif (res == _FAIL)\n\t\tif (pwrctrl->cpwm >= PS_STATE_S2)\n\t\t\tres = _SUCCESS;\n\n\treturn res;\n}\n\n \ns32 rtw_register_cmd_alive(struct adapter *padapter)\n{\n\ts32 res;\n\tstruct pwrctrl_priv *pwrctrl;\n\tu8 pslv;\n\n\tres = _SUCCESS;\n\tpwrctrl = adapter_to_pwrctl(padapter);\n\tpslv = PS_STATE_S2;\n\n\tmutex_lock(&pwrctrl->lock);\n\n\tregister_task_alive(pwrctrl, CMD_ALIVE);\n\n\tif (pwrctrl->fw_current_in_ps_mode) {\n\t\tif (pwrctrl->cpwm < pslv) {\n\t\t\tif (pwrctrl->cpwm < PS_STATE_S2)\n\t\t\t\tres = _FAIL;\n\t\t\tif (pwrctrl->rpwm < pslv)\n\t\t\t\trtw_set_rpwm(padapter, pslv);\n\t\t}\n\t}\n\n\tmutex_unlock(&pwrctrl->lock);\n\n\tif (res == _FAIL)\n\t\tif (pwrctrl->cpwm >= PS_STATE_S2)\n\t\t\tres = _SUCCESS;\n\n\treturn res;\n}\n\n \nvoid rtw_unregister_tx_alive(struct adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrctrl;\n\tu8 pslv;\n\n\tpwrctrl = adapter_to_pwrctl(padapter);\n\tpslv = PS_STATE_S0;\n\n\tif (!(hal_btcoex_IsBtDisabled(padapter)) && hal_btcoex_IsBtControlLps(padapter)) {\n\t\tu8 val8;\n\n\t\tval8 = hal_btcoex_LpsVal(padapter);\n\t\tif (val8 & BIT(4))\n\t\t\tpslv = PS_STATE_S2;\n\t}\n\n\tmutex_lock(&pwrctrl->lock);\n\n\tunregister_task_alive(pwrctrl, XMIT_ALIVE);\n\n\tif ((pwrctrl->pwr_mode != PS_MODE_ACTIVE) && pwrctrl->fw_current_in_ps_mode) {\n\t\tif (pwrctrl->cpwm > pslv)\n\t\t\tif ((pslv >= PS_STATE_S2) || (pwrctrl->alives == 0))\n\t\t\t\trtw_set_rpwm(padapter, pslv);\n\t}\n\n\tmutex_unlock(&pwrctrl->lock);\n}\n\n \nvoid rtw_unregister_cmd_alive(struct adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrctrl;\n\tu8 pslv;\n\n\tpwrctrl = adapter_to_pwrctl(padapter);\n\tpslv = PS_STATE_S0;\n\n\tif (!(hal_btcoex_IsBtDisabled(padapter)) && hal_btcoex_IsBtControlLps(padapter)) {\n\t\tu8 val8;\n\n\t\tval8 = hal_btcoex_LpsVal(padapter);\n\t\tif (val8 & BIT(4))\n\t\t\tpslv = PS_STATE_S2;\n\t}\n\n\tmutex_lock(&pwrctrl->lock);\n\n\tunregister_task_alive(pwrctrl, CMD_ALIVE);\n\n\tif ((pwrctrl->pwr_mode != PS_MODE_ACTIVE) && pwrctrl->fw_current_in_ps_mode) {\n\t\tif (pwrctrl->cpwm > pslv) {\n\t\t\tif ((pslv >= PS_STATE_S2) || (pwrctrl->alives == 0))\n\t\t\t\trtw_set_rpwm(padapter, pslv);\n\t\t}\n\t}\n\n\tmutex_unlock(&pwrctrl->lock);\n}\n\nvoid rtw_init_pwrctrl_priv(struct adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);\n\n\tmutex_init(&pwrctrlpriv->lock);\n\tpwrctrlpriv->rf_pwrstate = rf_on;\n\tpwrctrlpriv->ips_enter_cnts = 0;\n\tpwrctrlpriv->ips_leave_cnts = 0;\n\tpwrctrlpriv->bips_processing = false;\n\n\tpwrctrlpriv->ips_mode = padapter->registrypriv.ips_mode;\n\tpwrctrlpriv->ips_mode_req = padapter->registrypriv.ips_mode;\n\n\tpwrctrlpriv->pwr_state_check_interval = RTW_PWR_STATE_CHK_INTERVAL;\n\tpwrctrlpriv->pwr_state_check_cnts = 0;\n\tpwrctrlpriv->bInternalAutoSuspend = false;\n\tpwrctrlpriv->bInSuspend = false;\n\tpwrctrlpriv->bkeepfwalive = false;\n\n\tpwrctrlpriv->LpsIdleCount = 0;\n\tpwrctrlpriv->power_mgnt = padapter->registrypriv.power_mgnt; \n\tpwrctrlpriv->bLeisurePs = pwrctrlpriv->power_mgnt != PS_MODE_ACTIVE;\n\n\tpwrctrlpriv->fw_current_in_ps_mode = false;\n\n\tpwrctrlpriv->rpwm = 0;\n\tpwrctrlpriv->cpwm = PS_STATE_S4;\n\n\tpwrctrlpriv->pwr_mode = PS_MODE_ACTIVE;\n\tpwrctrlpriv->smart_ps = padapter->registrypriv.smart_ps;\n\tpwrctrlpriv->bcn_ant_mode = 0;\n\tpwrctrlpriv->dtim = 0;\n\n\tpwrctrlpriv->tog = 0x80;\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_SET_RPWM, (u8 *)(&pwrctrlpriv->rpwm));\n\n\t_init_workitem(&pwrctrlpriv->cpwm_event, cpwm_event_callback, NULL);\n\n\tpwrctrlpriv->brpwmtimeout = false;\n\tpwrctrlpriv->adapter = padapter;\n\t_init_workitem(&pwrctrlpriv->rpwmtimeoutwi, rpwmtimeout_workitem_callback, NULL);\n\ttimer_setup(&pwrctrlpriv->pwr_rpwm_timer, pwr_rpwm_timeout_handler, 0);\n\ttimer_setup(&pwrctrlpriv->pwr_state_check_timer,\n\t\t    pwr_state_check_handler, 0);\n\n\tpwrctrlpriv->wowlan_mode = false;\n\tpwrctrlpriv->wowlan_ap_mode = false;\n}\n\n\nvoid rtw_free_pwrctrl_priv(struct adapter *adapter)\n{\n}\n\ninline void rtw_set_ips_deny(struct adapter *padapter, u32 ms)\n{\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\tpwrpriv->ips_deny_time = jiffies + msecs_to_jiffies(ms);\n}\n\n \n\nint _rtw_pwr_wakeup(struct adapter *padapter, u32 ips_deffer_ms, const char *caller)\n{\n\tstruct dvobj_priv *dvobj = adapter_to_dvobj(padapter);\n\tstruct pwrctrl_priv *pwrpriv = dvobj_to_pwrctl(dvobj);\n\tstruct mlme_priv *pmlmepriv;\n\tint ret = _SUCCESS;\n\tunsigned long start = jiffies;\n\tunsigned long deny_time = jiffies + msecs_to_jiffies(ips_deffer_ms);\n\n\t \n\tLeaveAllPowerSaveMode(padapter);\n\n\t \n\tpadapter = GET_PRIMARY_ADAPTER(padapter);\n\tpmlmepriv = &padapter->mlmepriv;\n\n\tif (time_before(pwrpriv->ips_deny_time, deny_time))\n\t\tpwrpriv->ips_deny_time = deny_time;\n\n\n\tif (pwrpriv->ps_processing)\n\t\twhile (pwrpriv->ps_processing && jiffies_to_msecs(jiffies - start) <= 3000)\n\t\t\tmdelay(10);\n\n\tif (!(pwrpriv->bInternalAutoSuspend) && pwrpriv->bInSuspend)\n\t\twhile (pwrpriv->bInSuspend && jiffies_to_msecs(jiffies - start) <= 3000\n\t\t)\n\t\t\tmdelay(10);\n\n\t \n\tif (!(pwrpriv->bInternalAutoSuspend) && pwrpriv->bInSuspend) {\n\t\tret = _FAIL;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (pwrpriv->bInternalAutoSuspend  && padapter->net_closed) {\n\t\tret = _FAIL;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\tret = _SUCCESS;\n\t\tgoto exit;\n\t}\n\n\tif (rf_off == pwrpriv->rf_pwrstate) {\n\t\t{\n\t\t\tif (ips_leave(padapter) == _FAIL) {\n\t\t\t\tret = _FAIL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (padapter->bDriverStopped || !padapter->bup || !padapter->hw_init_completed) {\n\t\tret = false;\n\t\tgoto exit;\n\t}\n\nexit:\n\tdeny_time = jiffies + msecs_to_jiffies(ips_deffer_ms);\n\tif (time_before(pwrpriv->ips_deny_time, deny_time))\n\t\tpwrpriv->ips_deny_time = deny_time;\n\treturn ret;\n\n}\n\nint rtw_pm_set_lps(struct adapter *padapter, u8 mode)\n{\n\tint\tret = 0;\n\tstruct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);\n\n\tif (mode < PS_MODE_NUM) {\n\t\tif (pwrctrlpriv->power_mgnt != mode) {\n\t\t\tif (mode == PS_MODE_ACTIVE)\n\t\t\t\tLeaveAllPowerSaveMode(padapter);\n\t\t\telse\n\t\t\t\tpwrctrlpriv->LpsIdleCount = 2;\n\n\t\t\tpwrctrlpriv->power_mgnt = mode;\n\t\t\tpwrctrlpriv->bLeisurePs =\n\t\t\t\tpwrctrlpriv->power_mgnt != PS_MODE_ACTIVE;\n\t\t}\n\t} else\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nint rtw_pm_set_ips(struct adapter *padapter, u8 mode)\n{\n\tstruct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);\n\n\tif (mode == IPS_NORMAL || mode == IPS_LEVEL_2) {\n\t\trtw_ips_mode_req(pwrctrlpriv, mode);\n\t\treturn 0;\n\t} else if (mode == IPS_NONE) {\n\t\trtw_ips_mode_req(pwrctrlpriv, mode);\n\t\tif ((padapter->bSurpriseRemoved == 0) && (rtw_pwr_wakeup(padapter) == _FAIL))\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nvoid rtw_ps_deny(struct adapter *padapter, enum ps_deny_reason reason)\n{\n\tstruct pwrctrl_priv *pwrpriv;\n\n\tpwrpriv = adapter_to_pwrctl(padapter);\n\n\tmutex_lock(&pwrpriv->lock);\n\tpwrpriv->ps_deny |= BIT(reason);\n\tmutex_unlock(&pwrpriv->lock);\n}\n\n \nvoid rtw_ps_deny_cancel(struct adapter *padapter, enum ps_deny_reason reason)\n{\n\tstruct pwrctrl_priv *pwrpriv;\n\n\tpwrpriv = adapter_to_pwrctl(padapter);\n\n\tmutex_lock(&pwrpriv->lock);\n\tpwrpriv->ps_deny &= ~BIT(reason);\n\tmutex_unlock(&pwrpriv->lock);\n}\n\n \nu32 rtw_ps_deny_get(struct adapter *padapter)\n{\n\treturn adapter_to_pwrctl(padapter)->ps_deny;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}