{
  "module_name": "rtw_mlme_ext.c",
  "hash_id": "ffb8b13867aa49ca23d1b1fa826384ecac19224beea40618ddd0678efb07f44c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/core/rtw_mlme_ext.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <rtw_wifi_regd.h>\n#include <hal_btcoex.h>\n#include <linux/kernel.h>\n#include <asm/unaligned.h>\n\nstatic struct mlme_handler mlme_sta_tbl[] = {\n\t{WIFI_ASSOCREQ,\t\t\"OnAssocReq\",\t&OnAssocReq},\n\t{WIFI_ASSOCRSP,\t\t\"OnAssocRsp\",\t&OnAssocRsp},\n\t{WIFI_REASSOCREQ,\t\"OnReAssocReq\",\t&OnAssocReq},\n\t{WIFI_REASSOCRSP,\t\"OnReAssocRsp\",\t&OnAssocRsp},\n\t{WIFI_PROBEREQ,\t\t\"OnProbeReq\",\t&OnProbeReq},\n\t{WIFI_PROBERSP,\t\t\"OnProbeRsp\",\t\t&OnProbeRsp},\n\n\t \n\t{0,\t\t\t\t\t\"DoReserved\",\t\t&DoReserved},\n\t{0,\t\t\t\t\t\"DoReserved\",\t\t&DoReserved},\n\t{WIFI_BEACON,\t\t\"OnBeacon\",\t\t&OnBeacon},\n\t{WIFI_ATIM,\t\t\t\"OnATIM\",\t\t&OnAtim},\n\t{WIFI_DISASSOC,\t\t\"OnDisassoc\",\t\t&OnDisassoc},\n\t{WIFI_AUTH,\t\t\t\"OnAuth\",\t\t&OnAuthClient},\n\t{WIFI_DEAUTH,\t\t\"OnDeAuth\",\t\t&OnDeAuth},\n\t{WIFI_ACTION,\t\t\"OnAction\",\t\t&OnAction},\n\t{WIFI_ACTION_NOACK, \"OnActionNoAck\",\t&OnAction},\n};\n\nstatic struct action_handler OnAction_tbl[] = {\n\t{RTW_WLAN_CATEGORY_SPECTRUM_MGMT,\t \"ACTION_SPECTRUM_MGMT\", on_action_spct},\n\t{RTW_WLAN_CATEGORY_QOS, \"ACTION_QOS\", &DoReserved},\n\t{RTW_WLAN_CATEGORY_DLS, \"ACTION_DLS\", &DoReserved},\n\t{RTW_WLAN_CATEGORY_BACK, \"ACTION_BACK\", &OnAction_back},\n\t{RTW_WLAN_CATEGORY_PUBLIC, \"ACTION_PUBLIC\", on_action_public},\n\t{RTW_WLAN_CATEGORY_RADIO_MEASUREMENT, \"ACTION_RADIO_MEASUREMENT\", &DoReserved},\n\t{RTW_WLAN_CATEGORY_FT, \"ACTION_FT\",\t&DoReserved},\n\t{RTW_WLAN_CATEGORY_HT,\t\"ACTION_HT\",\t&OnAction_ht},\n\t{RTW_WLAN_CATEGORY_SA_QUERY, \"ACTION_SA_QUERY\", &OnAction_sa_query},\n\t{RTW_WLAN_CATEGORY_UNPROTECTED_WNM, \"ACTION_UNPROTECTED_WNM\", &DoReserved},\n\t{RTW_WLAN_CATEGORY_SELF_PROTECTED, \"ACTION_SELF_PROTECTED\", &DoReserved},\n\t{RTW_WLAN_CATEGORY_WMM, \"ACTION_WMM\", &DoReserved},\n\t{RTW_WLAN_CATEGORY_P2P, \"ACTION_P2P\", &DoReserved},\n};\n\nstatic u8 null_addr[ETH_ALEN] = {0, 0, 0, 0, 0, 0};\n\n \nunsigned char RTW_WPA_OUI[] = {0x00, 0x50, 0xf2, 0x01};\nunsigned char WMM_OUI[] = {0x00, 0x50, 0xf2, 0x02};\nunsigned char WPS_OUI[] = {0x00, 0x50, 0xf2, 0x04};\nunsigned char P2P_OUI[] = {0x50, 0x6F, 0x9A, 0x09};\nunsigned char WFD_OUI[] = {0x50, 0x6F, 0x9A, 0x0A};\n\nunsigned char WMM_INFO_OUI[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01};\nunsigned char WMM_PARA_OUI[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};\n\nstatic unsigned char REALTEK_96B_IE[] = {0x00, 0xe0, 0x4c, 0x02, 0x01, 0x20};\n\n \nstatic struct rt_channel_plan_2g\tRTW_ChannelPlan2G[RT_CHANNEL_DOMAIN_2G_MAX] = {\n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}, 13},\t\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}, 13},\t\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, 11},\t\t\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}, 14},\t \n\t{{10, 11, 12, 13}, 4},\t\t\t\t\t\t \n\t{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}, 14},\t \n\t{{}, 0},\t\t\t\t\t\t\t\t \n};\n\nstatic struct rt_channel_plan_map\tRTW_ChannelPlanMap[RT_CHANNEL_DOMAIN_MAX] = {\n\t \n\t{0x02},\t \n\t{0x02},\t \n\t{0x01},\t \n\t{0x01},\t \n\t{0x01},\t \n\t{0x03},\t \n\t{0x03},\t \n\t{0x01},\t \n\t{0x03},\t \n\t{0x03},\t \n\t{0x00},\t \n\t{0x02},\t \n\t{0x01},\t \n\t{0x02},\t \n\t{0x02},\t \n\t{0x02},\t \n\t{0x01},\t \n\t{0x02},\t \n\t{0x01},\t \n\t{0x00},\t \n\t{0x02},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x03},\t \n\t{0x06},\t \n\t{0x02},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x06},\t \n\t \n\t{0x00},\t \n\t{0x01},\t \n\t{0x02},\t \n\t{0x03},\t \n\t{0x04},\t \n\t{0x02},\t \n\t{0x00},\t \n\t{0x03},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x02},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x03},\t \n\t{0x03},\t \n\t{0x02},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x02},\t \n\t{0x05},\t \n\t{0x01},\t \n\t{0x02},\t \n\t{0x02},\t \n\t{0x00},\t \n\t{0x02},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x00},\t \n\t{0x02},\t \n\t{0x00},\t \n\t{0x02},\t \n\t{0x00},\t \n\t{0x02},\t \n};\n\n  \nstatic struct rt_channel_plan_map RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE = {0x03};\n\n \nint rtw_ch_set_search_ch(struct rt_channel_info *ch_set, const u32 ch)\n{\n\tint i;\n\n\tfor (i = 0; ch_set[i].ChannelNum != 0; i++) {\n\t\tif (ch == ch_set[i].ChannelNum)\n\t\t\tbreak;\n\t}\n\n\tif (i >= ch_set[i].ChannelNum)\n\t\treturn -1;\n\treturn i;\n}\n\n \n\nint init_hw_mlme_ext(struct adapter *padapter)\n{\n\tstruct\tmlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\n\tset_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);\n\treturn _SUCCESS;\n}\n\nvoid init_mlme_default_rate_set(struct adapter *padapter)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\n\tunsigned char mixed_datarate[NumRates] = {_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, _6M_RATE_, _9M_RATE_, _12M_RATE_, _18M_RATE_, _24M_RATE_, _36M_RATE_, _48M_RATE_, _54M_RATE_, 0xff};\n\tunsigned char mixed_basicrate[NumRates] = {_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, _6M_RATE_, _12M_RATE_, _24M_RATE_, 0xff,};\n\tunsigned char supported_mcs_set[16] = {0xff, 0xff, 0x00, 0x00, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};\n\n\tmemcpy(pmlmeext->datarate, mixed_datarate, NumRates);\n\tmemcpy(pmlmeext->basicrate, mixed_basicrate, NumRates);\n\n\tmemcpy(pmlmeext->default_supported_mcs_set, supported_mcs_set, sizeof(pmlmeext->default_supported_mcs_set));\n}\n\nstatic void init_mlme_ext_priv_value(struct adapter *padapter)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\n\n\tatomic_set(&pmlmeext->event_seq, 0);\n\tpmlmeext->mgnt_seq = 0; \n\tpmlmeext->sa_query_seq = 0;\n\tpmlmeext->mgnt_80211w_IPN = 0;\n\tpmlmeext->mgnt_80211w_IPN_rx = 0;\n\tpmlmeext->cur_channel = padapter->registrypriv.channel;\n\tpmlmeext->cur_bwmode = CHANNEL_WIDTH_20;\n\tpmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\n\tpmlmeext->retry = 0;\n\n\tpmlmeext->cur_wireless_mode = padapter->registrypriv.wireless_mode;\n\n\tinit_mlme_default_rate_set(padapter);\n\n\tpmlmeext->tx_rate = IEEE80211_CCK_RATE_1MB;\n\tpmlmeext->sitesurvey_res.state = SCAN_DISABLE;\n\tpmlmeext->sitesurvey_res.channel_idx = 0;\n\tpmlmeext->sitesurvey_res.bss_cnt = 0;\n\tpmlmeext->scan_abort = false;\n\n\tpmlmeinfo->state = WIFI_FW_NULL_STATE;\n\tpmlmeinfo->reauth_count = 0;\n\tpmlmeinfo->reassoc_count = 0;\n\tpmlmeinfo->link_count = 0;\n\tpmlmeinfo->auth_seq = 0;\n\tpmlmeinfo->auth_algo = dot11AuthAlgrthm_Open;\n\tpmlmeinfo->key_index = 0;\n\tpmlmeinfo->iv = 0;\n\n\tpmlmeinfo->enc_algo = _NO_PRIVACY_;\n\tpmlmeinfo->authModeToggle = 0;\n\n\tmemset(pmlmeinfo->chg_txt, 0, 128);\n\n\tpmlmeinfo->slotTime = SHORT_SLOT_TIME;\n\tpmlmeinfo->preamble_mode = PREAMBLE_AUTO;\n\n\tpmlmeinfo->dialogToken = 0;\n\n\tpmlmeext->action_public_rxseq = 0xffff;\n\tpmlmeext->action_public_dialog_token = 0xff;\n}\n\nstatic int has_channel(struct rt_channel_info *channel_set,\n\t\t\t\t\t   u8 chanset_size,\n\t\t\t\t\t   u8 chan)\n{\n\tint i;\n\n\tfor (i = 0; i < chanset_size; i++)\n\t\tif (channel_set[i].ChannelNum == chan)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void init_channel_list(struct adapter *padapter, struct rt_channel_info *channel_set,\n\t\t\t\t\t\t\t  u8 chanset_size,\n\t\t\t\t\t\t\t  struct p2p_channels *channel_list)\n{\n\n\tstatic const struct p2p_oper_class_map op_class[] = {\n\t\t{ IEEE80211G,  81,   1,  13,  1, BW20 },\n\t\t{ IEEE80211G,  82,  14,  14,  1, BW20 },\n\t\t{ IEEE80211A, 115,  36,  48,  4, BW20 },\n\t\t{ IEEE80211A, 116,  36,  44,  8, BW40PLUS },\n\t\t{ IEEE80211A, 117,  40,  48,  8, BW40MINUS },\n\t\t{ IEEE80211A, 124, 149, 161,  4, BW20 },\n\t\t{ IEEE80211A, 125, 149, 169,  4, BW20 },\n\t\t{ IEEE80211A, 126, 149, 157,  8, BW40PLUS },\n\t\t{ IEEE80211A, 127, 153, 161,  8, BW40MINUS },\n\t\t{ -1, 0, 0, 0, 0, BW20 }\n\t};\n\n\tint cla, op;\n\n\tcla = 0;\n\n\tfor (op = 0; op_class[op].op_class; op++) {\n\t\tu8 ch;\n\t\tconst struct p2p_oper_class_map *o = &op_class[op];\n\t\tstruct p2p_reg_class *reg = NULL;\n\n\t\tfor (ch = o->min_chan; ch <= o->max_chan; ch += o->inc) {\n\t\t\tif (!has_channel(channel_set, chanset_size, ch))\n\t\t\t\tcontinue;\n\n\t\t\tif ((padapter->registrypriv.ht_enable == 0) && (o->inc == 8))\n\t\t\t\tcontinue;\n\n\t\t\tif ((0 < (padapter->registrypriv.bw_mode & 0xf0)) &&\n\t\t\t\t((o->bw == BW40MINUS) || (o->bw == BW40PLUS)))\n\t\t\t\tcontinue;\n\n\t\t\tif (!reg) {\n\t\t\t\treg = &channel_list->reg_class[cla];\n\t\t\t\tcla++;\n\t\t\t\treg->reg_class = o->op_class;\n\t\t\t\treg->channels = 0;\n\t\t\t}\n\t\t\treg->channel[reg->channels] = ch;\n\t\t\treg->channels++;\n\t\t}\n\t}\n\tchannel_list->reg_classes = cla;\n\n}\n\nstatic u8 init_channel_set(struct adapter *padapter, u8 ChannelPlan, struct rt_channel_info *channel_set)\n{\n\tu8 index, chanset_size = 0;\n\tu8 b2_4GBand = false;\n\tu8 Index2G = 0;\n\n\tmemset(channel_set, 0, sizeof(struct rt_channel_info)*MAX_CHANNEL_NUM);\n\n\tif (ChannelPlan >= RT_CHANNEL_DOMAIN_MAX && ChannelPlan != RT_CHANNEL_DOMAIN_REALTEK_DEFINE)\n\t\treturn chanset_size;\n\n\tif (is_supported_24g(padapter->registrypriv.wireless_mode)) {\n\t\tb2_4GBand = true;\n\t\tif (ChannelPlan == RT_CHANNEL_DOMAIN_REALTEK_DEFINE)\n\t\t\tIndex2G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index2G;\n\t\telse\n\t\t\tIndex2G = RTW_ChannelPlanMap[ChannelPlan].Index2G;\n\t}\n\n\tif (b2_4GBand) {\n\t\tfor (index = 0; index < RTW_ChannelPlan2G[Index2G].Len; index++) {\n\t\t\tchannel_set[chanset_size].ChannelNum = RTW_ChannelPlan2G[Index2G].Channel[index];\n\n\t\t\tif ((ChannelPlan == RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN) || \n\t\t\t\t(ChannelPlan == RT_CHANNEL_DOMAIN_GLOBAL_NULL)) {\n\t\t\t\tif (channel_set[chanset_size].ChannelNum >= 1 && channel_set[chanset_size].ChannelNum <= 11)\n\t\t\t\t\tchannel_set[chanset_size].ScanType = SCAN_ACTIVE;\n\t\t\t\telse if ((channel_set[chanset_size].ChannelNum  >= 12 && channel_set[chanset_size].ChannelNum  <= 14))\n\t\t\t\t\tchannel_set[chanset_size].ScanType  = SCAN_PASSIVE;\n\t\t\t} else if (ChannelPlan == RT_CHANNEL_DOMAIN_WORLD_WIDE_13 ||\n\t\t\t\t Index2G == RT_CHANNEL_DOMAIN_2G_WORLD) {  \n\t\t\t\tif (channel_set[chanset_size].ChannelNum <= 11)\n\t\t\t\t\tchannel_set[chanset_size].ScanType = SCAN_ACTIVE;\n\t\t\t\telse\n\t\t\t\t\tchannel_set[chanset_size].ScanType = SCAN_PASSIVE;\n\t\t\t} else\n\t\t\t\tchannel_set[chanset_size].ScanType = SCAN_ACTIVE;\n\n\t\t\tchanset_size++;\n\t\t}\n\t}\n\n\treturn chanset_size;\n}\n\nvoid init_mlme_ext_priv(struct adapter *padapter)\n{\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\n\n\tpmlmeext->padapter = padapter;\n\n\t \n\n\tinit_mlme_ext_priv_value(padapter);\n\tpmlmeinfo->accept_addba_req = pregistrypriv->accept_addba_req;\n\n\tinit_mlme_ext_timer(padapter);\n\n\tinit_mlme_ap_info(padapter);\n\n\tpmlmeext->max_chan_nums = init_channel_set(padapter, pmlmepriv->ChannelPlan, pmlmeext->channel_set);\n\tinit_channel_list(padapter, pmlmeext->channel_set, pmlmeext->max_chan_nums, &pmlmeext->channel_list);\n\tpmlmeext->last_scan_time = 0;\n\tpmlmeext->chan_scan_time = SURVEY_TO;\n\tpmlmeext->mlmeext_init = true;\n\tpmlmeext->active_keep_alive_check = true;\n\n#ifdef DBG_FIXED_CHAN\n\tpmlmeext->fixed_chan = 0xFF;\n#endif\n}\n\nvoid free_mlme_ext_priv(struct mlme_ext_priv *pmlmeext)\n{\n\tstruct adapter *padapter = pmlmeext->padapter;\n\n\tif (!padapter)\n\t\treturn;\n\n\tif (padapter->bDriverStopped) {\n\t\tdel_timer_sync(&pmlmeext->survey_timer);\n\t\tdel_timer_sync(&pmlmeext->link_timer);\n\t\t \n\t}\n}\n\nstatic void _mgt_dispatcher(struct adapter *padapter, struct mlme_handler *ptable, union recv_frame *precv_frame)\n{\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\n\tif (ptable->func) {\n\t\t \n\t\tif (memcmp(GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN) &&\n\t\t    !is_broadcast_ether_addr(GetAddr1Ptr(pframe)))\n\t\t\treturn;\n\n\t\tptable->func(padapter, precv_frame);\n\t}\n}\n\nvoid mgt_dispatcher(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tint index;\n\tstruct mlme_handler *ptable;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tstruct sta_info *psta = rtw_get_stainfo(&padapter->stapriv, GetAddr2Ptr(pframe));\n\tstruct dvobj_priv *psdpriv = padapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\n\tif (GetFrameType(pframe) != WIFI_MGT_TYPE)\n\t\treturn;\n\n\t \n\tif (memcmp(GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN) &&\n\t    !is_broadcast_ether_addr(GetAddr1Ptr(pframe))) {\n\t\treturn;\n\t}\n\n\tptable = mlme_sta_tbl;\n\n\tindex = GetFrameSubType(pframe) >> 4;\n\n\tif (index >= ARRAY_SIZE(mlme_sta_tbl))\n\t\treturn;\n\n\tptable += index;\n\n\tif (psta) {\n\t\tif (GetRetry(pframe)) {\n\t\t\tif (precv_frame->u.hdr.attrib.seq_num == psta->RxMgmtFrameSeqNum) {\n\t\t\t\t \n\t\t\t\tpdbgpriv->dbg_rx_dup_mgt_frame_drop_count++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tpsta->RxMgmtFrameSeqNum = precv_frame->u.hdr.attrib.seq_num;\n\t}\n\n\tswitch (GetFrameSubType(pframe)) {\n\tcase WIFI_AUTH:\n\t\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE))\n\t\t\tptable->func = &OnAuth;\n\t\telse\n\t\t\tptable->func = &OnAuthClient;\n\t\tfallthrough;\n\tcase WIFI_ASSOCREQ:\n\tcase WIFI_REASSOCREQ:\n\t\t_mgt_dispatcher(padapter, ptable, precv_frame);\n\t\tbreak;\n\tcase WIFI_PROBEREQ:\n\t\t_mgt_dispatcher(padapter, ptable, precv_frame);\n\t\tbreak;\n\tcase WIFI_BEACON:\n\t\t_mgt_dispatcher(padapter, ptable, precv_frame);\n\t\tbreak;\n\tcase WIFI_ACTION:\n\t\t \n\t\t_mgt_dispatcher(padapter, ptable, precv_frame);\n\t\tbreak;\n\tdefault:\n\t\t_mgt_dispatcher(padapter, ptable, precv_frame);\n\t\tbreak;\n\t}\n}\n\n \n\nunsigned int OnProbeReq(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tunsigned int\tielen;\n\tunsigned char *p;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\n\tstruct wlan_bssid_ex\t*cur = &pmlmeinfo->network;\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tuint len = precv_frame->u.hdr.len;\n\tu8 is_valid_p2p_probereq = false;\n\n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE))\n\t\treturn _SUCCESS;\n\n\tif (check_fwstate(pmlmepriv, _FW_LINKED) == false &&\n\t\tcheck_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE) == false) {\n\t\treturn _SUCCESS;\n\t}\n\n\tp = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, WLAN_EID_SSID, (int *)&ielen,\n\t\t\tlen - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);\n\n\n\t \n\tif (p) {\n\t\tif (is_valid_p2p_probereq)\n\t\t\tgoto _issue_probersp;\n\n\t\tif ((ielen != 0 && false == !memcmp((void *)(p+2), (void *)cur->ssid.ssid, cur->ssid.ssid_length))\n\t\t\t|| (ielen == 0 && pmlmeinfo->hidden_ssid_mode)\n\t\t)\n\t\t\treturn _SUCCESS;\n\n_issue_probersp:\n\t\tif ((check_fwstate(pmlmepriv, _FW_LINKED) &&\n\t\t     pmlmepriv->cur_network.join_res) ||\n\t\t    check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE))\n\t\t\tissue_probersp(padapter, get_sa(pframe), is_valid_p2p_probereq);\n\t}\n\n\treturn _SUCCESS;\n\n}\n\nunsigned int OnProbeRsp(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\n\tif (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {\n\t\treport_survey_event(padapter, precv_frame);\n\t\treturn _SUCCESS;\n\t}\n\n\treturn _SUCCESS;\n\n}\n\nunsigned int OnBeacon(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tint cam_idx;\n\tstruct sta_info *psta;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tuint len = precv_frame->u.hdr.len;\n\tstruct wlan_bssid_ex *pbss;\n\tint ret = _SUCCESS;\n\tu8 *p = NULL;\n\tu32 ielen = 0;\n\n\tp = rtw_get_ie(pframe + sizeof(struct ieee80211_hdr_3addr) + _BEACON_IE_OFFSET_, WLAN_EID_EXT_SUPP_RATES, &ielen, precv_frame->u.hdr.len - sizeof(struct ieee80211_hdr_3addr) - _BEACON_IE_OFFSET_);\n\tif (p && ielen > 0) {\n\t\tif ((*(p + 1 + ielen) == 0x2D) && (*(p + 2 + ielen) != 0x2D))\n\t\t\t \n\t\t\t*(p + 1) = ielen - 1;\n\t}\n\n\tif (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {\n\t\treport_survey_event(padapter, precv_frame);\n\t\treturn _SUCCESS;\n\t}\n\n\tif (!memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN)) {\n\t\tif (pmlmeinfo->state & WIFI_FW_AUTH_NULL) {\n\t\t\t \n\t\t\tpbss = rtw_malloc(sizeof(struct wlan_bssid_ex));\n\t\t\tif (pbss) {\n\t\t\t\tif (collect_bss_info(padapter, precv_frame, pbss) == _SUCCESS) {\n\t\t\t\t\tupdate_network(&(pmlmepriv->cur_network.network), pbss, padapter, true);\n\t\t\t\t\trtw_get_bcn_info(&(pmlmepriv->cur_network));\n\t\t\t\t}\n\t\t\t\tkfree(pbss);\n\t\t\t}\n\n\t\t\t \n\t\t\tpmlmeinfo->assoc_AP_vendor = check_assoc_AP(pframe+sizeof(struct ieee80211_hdr_3addr), len-sizeof(struct ieee80211_hdr_3addr));\n\n\t\t\t \n\t\t\tupdate_TSF(pmlmeext, pframe, len);\n\n\t\t\t \n\t\t\tpmlmeext->adaptive_tsf_done = false;\n\t\t\tpmlmeext->DrvBcnEarly = 0xff;\n\t\t\tpmlmeext->DrvBcnTimeOut = 0xff;\n\t\t\tpmlmeext->bcn_cnt = 0;\n\t\t\tmemset(pmlmeext->bcn_delay_cnt, 0, sizeof(pmlmeext->bcn_delay_cnt));\n\t\t\tmemset(pmlmeext->bcn_delay_ratio, 0, sizeof(pmlmeext->bcn_delay_ratio));\n\n\t\t\t \n\t\t\tstart_clnt_auth(padapter);\n\n\t\t\treturn _SUCCESS;\n\t\t}\n\n\t\tif (((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) && (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)) {\n\t\t\tpsta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));\n\t\t\tif (psta) {\n\t\t\t\tret = rtw_check_bcn_info(padapter, pframe, len);\n\t\t\t\tif (!ret) {\n\t\t\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t\t\t   \"ap has changed, disconnect now\\n \");\n\t\t\t\t\treceive_disconnect(padapter,\n\t\t\t\t\t\t\t   pmlmeinfo->network.mac_address, 0);\n\t\t\t\t\treturn _SUCCESS;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif ((sta_rx_pkts(psta) & 0xf) == 0)\n\t\t\t\t\tupdate_beacon_info(padapter, pframe, len, psta);\n\n\t\t\t\tadaptive_early_32k(pmlmeext, pframe, len);\n\t\t\t}\n\t\t} else if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {\n\t\t\tpsta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));\n\t\t\tif (psta) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif ((sta_rx_pkts(psta) & 0xf) == 0)\n\t\t\t\t\tupdate_beacon_info(padapter, pframe, len, psta);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tcam_idx = allocate_fw_sta_entry(padapter);\n\t\t\t\tif (cam_idx == NUM_STA)\n\t\t\t\t\tgoto _END_ONBEACON_;\n\n\t\t\t\t \n\t\t\t\tif (update_sta_support_rate(padapter, (pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_), (len - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_), cam_idx) == _FAIL) {\n\t\t\t\t\tpmlmeinfo->FW_sta_info[cam_idx].status = 0;\n\t\t\t\t\tgoto _END_ONBEACON_;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tupdate_TSF(pmlmeext, pframe, len);\n\n\t\t\t\t \n\t\t\t\treport_add_sta_event(padapter, GetAddr2Ptr(pframe), cam_idx);\n\t\t\t}\n\t\t}\n\t}\n\n_END_ONBEACON_:\n\n\treturn _SUCCESS;\n\n}\n\nunsigned int OnAuth(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tunsigned int\tauth_mode, seq, ie_len;\n\tunsigned char *sa, *p;\n\tu16 algorithm;\n\tint\tstatus;\n\tstatic struct sta_info stat;\n\tstruct\tsta_info *pstat = NULL;\n\tstruct\tsta_priv *pstapriv = &padapter->stapriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tuint len = precv_frame->u.hdr.len;\n\tu8 offset = 0;\n\n\tif ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)\n\t\treturn _FAIL;\n\n\tsa = GetAddr2Ptr(pframe);\n\n\tauth_mode = psecuritypriv->dot11AuthAlgrthm;\n\n\tif (GetPrivacy(pframe)) {\n\t\tu8 *iv;\n\t\tstruct rx_pkt_attrib\t *prxattrib = &(precv_frame->u.hdr.attrib);\n\n\t\tprxattrib->hdrlen = WLAN_HDR_A3_LEN;\n\t\tprxattrib->encrypt = _WEP40_;\n\n\t\tiv = pframe+prxattrib->hdrlen;\n\t\tprxattrib->key_index = ((iv[3]>>6)&0x3);\n\n\t\tprxattrib->iv_len = 4;\n\t\tprxattrib->icv_len = 4;\n\n\t\trtw_wep_decrypt(padapter, (u8 *)precv_frame);\n\n\t\toffset = 4;\n\t}\n\n\talgorithm = le16_to_cpu(*(__le16 *)((SIZE_PTR)pframe + WLAN_HDR_A3_LEN + offset));\n\tseq\t= le16_to_cpu(*(__le16 *)((SIZE_PTR)pframe + WLAN_HDR_A3_LEN + offset + 2));\n\n\tif (auth_mode == 2 &&\n\t\t\tpsecuritypriv->dot11PrivacyAlgrthm != _WEP40_ &&\n\t\t\tpsecuritypriv->dot11PrivacyAlgrthm != _WEP104_)\n\t\tauth_mode = 0;\n\n\tif ((algorithm > 0 && auth_mode == 0) ||\t \n\t\t(algorithm == 0 && auth_mode == 1)) {\t \n\n\t\tstatus = WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG;\n\n\t\tgoto auth_fail;\n\t}\n\n\tif (rtw_access_ctrl(padapter, sa) == false) {\n\t\tstatus = WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;\n\t\tgoto auth_fail;\n\t}\n\n\tpstat = rtw_get_stainfo(pstapriv, sa);\n\tif (!pstat) {\n\n\t\t \n\t\tpstat = rtw_alloc_stainfo(pstapriv, sa);\n\t\tif (!pstat) {\n\t\t\tstatus = WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;\n\t\t\tgoto auth_fail;\n\t\t}\n\n\t\tpstat->state = WIFI_FW_AUTH_NULL;\n\t\tpstat->auth_seq = 0;\n\n\t\t \n\t\t \n\t} else {\n\n\t\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\t\tif (list_empty(&pstat->asoc_list) == false) {\n\t\t\tlist_del_init(&pstat->asoc_list);\n\t\t\tpstapriv->asoc_list_cnt--;\n\t\t\tif (pstat->expire_to > 0) {\n\t\t\t\t \n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\n\t\tif (seq == 1) {\n\t\t\t \n\t\t}\n\t}\n\n\tspin_lock_bh(&pstapriv->auth_list_lock);\n\tif (list_empty(&pstat->auth_list)) {\n\n\t\tlist_add_tail(&pstat->auth_list, &pstapriv->auth_list);\n\t\tpstapriv->auth_list_cnt++;\n\t}\n\tspin_unlock_bh(&pstapriv->auth_list_lock);\n\n\tif (pstat->auth_seq == 0)\n\t\tpstat->expire_to = pstapriv->auth_to;\n\n\n\tif ((pstat->auth_seq + 1) != seq) {\n\t\tstatus = WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION;\n\t\tgoto auth_fail;\n\t}\n\n\tif (algorithm == 0 && (auth_mode == 0 || auth_mode == 2 || auth_mode == 3)) {\n\t\tif (seq == 1) {\n\t\t\tpstat->state &= ~WIFI_FW_AUTH_NULL;\n\t\t\tpstat->state |= WIFI_FW_AUTH_SUCCESS;\n\t\t\tpstat->expire_to = pstapriv->assoc_to;\n\t\t\tpstat->authalg = algorithm;\n\t\t} else {\n\t\t\tstatus = WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION;\n\t\t\tgoto auth_fail;\n\t\t}\n\t} else {  \n\t\tif (seq == 1) {\n\t\t\t \n\t\t\tmemset((void *)pstat->chg_txt, 78, 128);\n\n\t\t\tpstat->state &= ~WIFI_FW_AUTH_NULL;\n\t\t\tpstat->state |= WIFI_FW_AUTH_STATE;\n\t\t\tpstat->authalg = algorithm;\n\t\t} else if (seq == 3) {\n\n\t\t\tp = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + 4 + _AUTH_IE_OFFSET_, WLAN_EID_CHALLENGE, (int *)&ie_len,\n\t\t\t\t\tlen - WLAN_HDR_A3_LEN - _AUTH_IE_OFFSET_ - 4);\n\n\t\t\tif (!p || ie_len <= 0) {\n\t\t\t\tstatus = WLAN_STATUS_CHALLENGE_FAIL;\n\t\t\t\tgoto auth_fail;\n\t\t\t}\n\n\t\t\tif (!memcmp((void *)(p + 2), pstat->chg_txt, 128)) {\n\t\t\t\tpstat->state &= (~WIFI_FW_AUTH_STATE);\n\t\t\t\tpstat->state |= WIFI_FW_AUTH_SUCCESS;\n\t\t\t\t \n\t\t\t\tpstat->expire_to =  pstapriv->assoc_to;\n\t\t\t} else {\n\t\t\t\tstatus = WLAN_STATUS_CHALLENGE_FAIL;\n\t\t\t\tgoto auth_fail;\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION;\n\t\t\tgoto auth_fail;\n\t\t}\n\t}\n\n\n\t \n\tpstat->auth_seq = seq + 1;\n\n\tissue_auth(padapter, pstat, (unsigned short)(WLAN_STATUS_SUCCESS));\n\n\tif (pstat->state & WIFI_FW_AUTH_SUCCESS)\n\t\tpstat->auth_seq = 0;\n\n\n\treturn _SUCCESS;\n\nauth_fail:\n\n\tif (pstat)\n\t\trtw_free_stainfo(padapter, pstat);\n\n\tpstat = &stat;\n\tmemset((char *)pstat, '\\0', sizeof(stat));\n\tpstat->auth_seq = 2;\n\tmemcpy(pstat->hwaddr, sa, 6);\n\n\tissue_auth(padapter, pstat, (unsigned short)status);\n\n\treturn _FAIL;\n\n}\n\nunsigned int OnAuthClient(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tunsigned int\tseq, len, status, offset;\n\tunsigned char *p;\n\tunsigned int\tgo2asoc = 0;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tuint pkt_len = precv_frame->u.hdr.len;\n\n\t \n\tif (memcmp(myid(&(padapter->eeprompriv)), get_da(pframe), ETH_ALEN))\n\t\treturn _SUCCESS;\n\n\tif (!(pmlmeinfo->state & WIFI_FW_AUTH_STATE))\n\t\treturn _SUCCESS;\n\n\toffset = (GetPrivacy(pframe)) ? 4 : 0;\n\n\tseq\t= le16_to_cpu(*(__le16 *)((SIZE_PTR)pframe + WLAN_HDR_A3_LEN + offset + 2));\n\tstatus\t= le16_to_cpu(*(__le16 *)((SIZE_PTR)pframe + WLAN_HDR_A3_LEN + offset + 4));\n\n\tif (status != 0) {\n\t\tif (status == 13) {  \n\t\t\tif (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)\n\t\t\t\tpmlmeinfo->auth_algo = dot11AuthAlgrthm_Open;\n\t\t\telse\n\t\t\t\tpmlmeinfo->auth_algo = dot11AuthAlgrthm_Shared;\n\t\t\t \n\t\t}\n\n\t\tset_link_timer(pmlmeext, 1);\n\t\tgoto authclnt_fail;\n\t}\n\n\tif (seq == 2) {\n\t\tif (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared) {\n\t\t\t  \n\t\t\tp = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _AUTH_IE_OFFSET_, WLAN_EID_CHALLENGE, (int *)&len,\n\t\t\t\tpkt_len - WLAN_HDR_A3_LEN - _AUTH_IE_OFFSET_);\n\n\t\t\tif (!p)\n\t\t\t\tgoto authclnt_fail;\n\n\t\t\tmemcpy((void *)(pmlmeinfo->chg_txt), (void *)(p + 2), len);\n\t\t\tpmlmeinfo->auth_seq = 3;\n\t\t\tissue_auth(padapter, NULL, 0);\n\t\t\tset_link_timer(pmlmeext, REAUTH_TO);\n\n\t\t\treturn _SUCCESS;\n\t\t}\n\t\t \n\t\tgo2asoc = 1;\n\t} else if (seq == 4) {\n\t\tif (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)\n\t\t\tgo2asoc = 1;\n\t\telse\n\t\t\tgoto authclnt_fail;\n\t} else {\n\t\t \n\t\tgoto authclnt_fail;\n\t}\n\n\tif (go2asoc) {\n\t\tnetdev_dbg(padapter->pnetdev, \"auth success, start assoc\\n\");\n\t\tstart_clnt_assoc(padapter);\n\t\treturn _SUCCESS;\n\t}\n\nauthclnt_fail:\n\n\t \n\n\treturn _FAIL;\n\n}\n\nunsigned int OnAssocReq(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tu16 capab_info;\n\tstruct rtw_ieee802_11_elems elems;\n\tstruct sta_info *pstat;\n\tunsigned char \t*p, *pos, *wpa_ie;\n\tunsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01};\n\tint\t\ti, ie_len, wpa_ie_len, left;\n\tunsigned char \tsupportRate[16];\n\tint\t\t\t\t\tsupportRateNum;\n\tunsigned short\t\tstatus = WLAN_STATUS_SUCCESS;\n\tunsigned short\t\tframe_type, ie_offset = 0;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex\t*cur = &(pmlmeinfo->network);\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tuint pkt_len = precv_frame->u.hdr.len;\n\n\tif ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)\n\t\treturn _FAIL;\n\n\tframe_type = GetFrameSubType(pframe);\n\tif (frame_type == WIFI_ASSOCREQ)\n\t\tie_offset = _ASOCREQ_IE_OFFSET_;\n\telse  \n\t\tie_offset = _REASOCREQ_IE_OFFSET_;\n\n\n\tif (pkt_len < sizeof(struct ieee80211_hdr_3addr) + ie_offset)\n\t\treturn _FAIL;\n\n\tpstat = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));\n\tif (!pstat) {\n\t\tstatus = WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA;\n\t\tgoto asoc_class2_error;\n\t}\n\n\tcapab_info = get_unaligned_le16(pframe + WLAN_HDR_A3_LEN);\n\t \n\n\tleft = pkt_len - (sizeof(struct ieee80211_hdr_3addr) + ie_offset);\n\tpos = pframe + (sizeof(struct ieee80211_hdr_3addr) + ie_offset);\n\n\t \n\tif (!((pstat->state) & WIFI_FW_AUTH_SUCCESS)) {\n\t\tif (!((pstat->state) & WIFI_FW_ASSOC_SUCCESS)) {\n\t\t\tstatus = WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA;\n\t\t\tgoto asoc_class2_error;\n\t\t} else {\n\t\t\tpstat->state &= (~WIFI_FW_ASSOC_SUCCESS);\n\t\t\tpstat->state |= WIFI_FW_ASSOC_STATE;\n\t\t}\n\t} else {\n\t\tpstat->state &= (~WIFI_FW_AUTH_SUCCESS);\n\t\tpstat->state |= WIFI_FW_ASSOC_STATE;\n\t}\n\n\n\tpstat->capability = capab_info;\n\n\t \n\tif (rtw_ieee802_11_parse_elems(pos, left, &elems, 1) == ParseFailed ||\n\t    !elems.ssid) {\n\t\tstatus = WLAN_STATUS_CHALLENGE_FAIL;\n\t\tgoto OnAssocReqFail;\n\t}\n\n\t \n\t \n\tp = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, WLAN_EID_SSID, &ie_len,\n\t\tpkt_len - WLAN_HDR_A3_LEN - ie_offset);\n\n\tif (!p || ie_len == 0) {\n\t\t \n\t\tstatus = WLAN_STATUS_CHALLENGE_FAIL;\n\t\tgoto OnAssocReqFail;\n\t} else {\n\t\t \n\t\tif (memcmp((void *)(p+2), cur->ssid.ssid, cur->ssid.ssid_length))\n\t\t\tstatus = WLAN_STATUS_CHALLENGE_FAIL;\n\n\t\tif (ie_len != cur->ssid.ssid_length)\n\t\t\tstatus = WLAN_STATUS_CHALLENGE_FAIL;\n\t}\n\n\tif (status != WLAN_STATUS_SUCCESS)\n\t\tgoto OnAssocReqFail;\n\n\t \n\tp = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, WLAN_EID_SUPP_RATES, &ie_len, pkt_len - WLAN_HDR_A3_LEN - ie_offset);\n\tif (!p) {\n\t\t \n\t\t \n\t\t \n\n\t\tstatus = WLAN_STATUS_CHALLENGE_FAIL;\n\t\tgoto OnAssocReqFail;\n\t} else {\n\t\tmemcpy(supportRate, p+2, ie_len);\n\t\tsupportRateNum = ie_len;\n\n\t\tp = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, WLAN_EID_EXT_SUPP_RATES, &ie_len,\n\t\t\t\tpkt_len - WLAN_HDR_A3_LEN - ie_offset);\n\t\tif (p) {\n\n\t\t\tif (supportRateNum <= sizeof(supportRate)) {\n\t\t\t\tmemcpy(supportRate+supportRateNum, p+2, ie_len);\n\t\t\t\tsupportRateNum += ie_len;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\t \n\n\t \n\tpstat->bssratelen = supportRateNum;\n\tmemcpy(pstat->bssrateset, supportRate, supportRateNum);\n\tUpdateBrateTblForSoftAP(pstat->bssrateset, pstat->bssratelen);\n\n\t \n\tpstat->dot8021xalg = 0;\n\tpstat->wpa_psk = 0;\n\tpstat->wpa_group_cipher = 0;\n\tpstat->wpa2_group_cipher = 0;\n\tpstat->wpa_pairwise_cipher = 0;\n\tpstat->wpa2_pairwise_cipher = 0;\n\tmemset(pstat->wpa_ie, 0, sizeof(pstat->wpa_ie));\n\tif ((psecuritypriv->wpa_psk & BIT(1)) && elems.rsn_ie) {\n\n\t\tint group_cipher = 0, pairwise_cipher = 0;\n\n\t\twpa_ie = elems.rsn_ie;\n\t\twpa_ie_len = elems.rsn_ie_len;\n\n\t\tif (rtw_parse_wpa2_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {\n\t\t\tpstat->dot8021xalg = 1; \n\t\t\tpstat->wpa_psk |= BIT(1);\n\n\t\t\tpstat->wpa2_group_cipher = group_cipher&psecuritypriv->wpa2_group_cipher;\n\t\t\tpstat->wpa2_pairwise_cipher = pairwise_cipher&psecuritypriv->wpa2_pairwise_cipher;\n\n\t\t\tif (!pstat->wpa2_group_cipher)\n\t\t\t\tstatus = WLAN_STATUS_INVALID_GROUP_CIPHER;\n\n\t\t\tif (!pstat->wpa2_pairwise_cipher)\n\t\t\t\tstatus = WLAN_STATUS_INVALID_PAIRWISE_CIPHER;\n\t\t} else {\n\t\t\tstatus = WLAN_STATUS_INVALID_IE;\n\t\t}\n\n\t} else if ((psecuritypriv->wpa_psk & BIT(0)) && elems.wpa_ie) {\n\n\t\tint group_cipher = 0, pairwise_cipher = 0;\n\n\t\twpa_ie = elems.wpa_ie;\n\t\twpa_ie_len = elems.wpa_ie_len;\n\n\t\tif (rtw_parse_wpa_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {\n\t\t\tpstat->dot8021xalg = 1; \n\t\t\tpstat->wpa_psk |= BIT(0);\n\n\t\t\tpstat->wpa_group_cipher = group_cipher&psecuritypriv->wpa_group_cipher;\n\t\t\tpstat->wpa_pairwise_cipher = pairwise_cipher&psecuritypriv->wpa_pairwise_cipher;\n\n\t\t\tif (!pstat->wpa_group_cipher)\n\t\t\t\tstatus = WLAN_STATUS_INVALID_GROUP_CIPHER;\n\n\t\t\tif (!pstat->wpa_pairwise_cipher)\n\t\t\t\tstatus = WLAN_STATUS_INVALID_PAIRWISE_CIPHER;\n\n\t\t} else {\n\t\t\tstatus = WLAN_STATUS_INVALID_IE;\n\t\t}\n\n\t} else {\n\t\twpa_ie = NULL;\n\t\twpa_ie_len = 0;\n\t}\n\n\tif (status != WLAN_STATUS_SUCCESS)\n\t\tgoto OnAssocReqFail;\n\n\tpstat->flags &= ~(WLAN_STA_WPS | WLAN_STA_MAYBE_WPS);\n\tif (!wpa_ie) {\n\t\tif (elems.wps_ie) {\n\t\t\tpstat->flags |= WLAN_STA_WPS;\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t} else {\n\t\t\tpstat->flags |= WLAN_STA_MAYBE_WPS;\n\t\t}\n\n\n\t\t \n\t\t \n\t\tif ((psecuritypriv->wpa_psk > 0)\n\t\t\t&& (pstat->flags & (WLAN_STA_WPS|WLAN_STA_MAYBE_WPS))) {\n\t\t\tif (pmlmepriv->wps_beacon_ie) {\n\t\t\t\tu8 selected_registrar = 0;\n\n\t\t\t\trtw_get_wps_attr_content(pmlmepriv->wps_beacon_ie, pmlmepriv->wps_beacon_ie_len, WPS_ATTR_SELECTED_REGISTRAR, &selected_registrar, NULL);\n\n\t\t\t\tif (!selected_registrar) {\n\t\t\t\t\tstatus = WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;\n\n\t\t\t\t\tgoto OnAssocReqFail;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tint copy_len;\n\n\t\tif (psecuritypriv->wpa_psk == 0) {\n\t\t\tstatus = WLAN_STATUS_INVALID_IE;\n\n\t\t\tgoto OnAssocReqFail;\n\n\t\t}\n\n\t\tif (elems.wps_ie) {\n\t\t\tpstat->flags |= WLAN_STA_WPS;\n\t\t\tcopy_len = 0;\n\t\t} else {\n\t\t\tcopy_len = ((wpa_ie_len+2) > sizeof(pstat->wpa_ie)) ? (sizeof(pstat->wpa_ie)):(wpa_ie_len+2);\n\t\t}\n\n\n\t\tif (copy_len > 0)\n\t\t\tmemcpy(pstat->wpa_ie, wpa_ie-2, copy_len);\n\n\t}\n\n\n\t \n\tpstat->flags &= ~WLAN_STA_WME;\n\tpstat->qos_option = 0;\n\tpstat->qos_info = 0;\n\tpstat->has_legacy_ac = true;\n\tpstat->uapsd_vo = 0;\n\tpstat->uapsd_vi = 0;\n\tpstat->uapsd_be = 0;\n\tpstat->uapsd_bk = 0;\n\tif (pmlmepriv->qospriv.qos_option) {\n\t\tp = pframe + WLAN_HDR_A3_LEN + ie_offset; ie_len = 0;\n\t\tfor (;;) {\n\t\t\tp = rtw_get_ie(p, WLAN_EID_VENDOR_SPECIFIC, &ie_len, pkt_len - WLAN_HDR_A3_LEN - ie_offset);\n\t\t\tif (p) {\n\t\t\t\tif (!memcmp(p+2, WMM_IE, 6)) {\n\n\t\t\t\t\tpstat->flags |= WLAN_STA_WME;\n\n\t\t\t\t\tpstat->qos_option = 1;\n\t\t\t\t\tpstat->qos_info = *(p+8);\n\n\t\t\t\t\tpstat->max_sp_len = (pstat->qos_info>>5)&0x3;\n\n\t\t\t\t\tif ((pstat->qos_info&0xf) != 0xf)\n\t\t\t\t\t\tpstat->has_legacy_ac = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tpstat->has_legacy_ac = false;\n\n\t\t\t\t\tif (pstat->qos_info&0xf) {\n\t\t\t\t\t\tif (pstat->qos_info&BIT(0))\n\t\t\t\t\t\t\tpstat->uapsd_vo = BIT(0)|BIT(1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpstat->uapsd_vo = 0;\n\n\t\t\t\t\t\tif (pstat->qos_info&BIT(1))\n\t\t\t\t\t\t\tpstat->uapsd_vi = BIT(0)|BIT(1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpstat->uapsd_vi = 0;\n\n\t\t\t\t\t\tif (pstat->qos_info&BIT(2))\n\t\t\t\t\t\t\tpstat->uapsd_bk = BIT(0)|BIT(1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpstat->uapsd_bk = 0;\n\n\t\t\t\t\t\tif (pstat->qos_info&BIT(3))\n\t\t\t\t\t\t\tpstat->uapsd_be = BIT(0)|BIT(1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpstat->uapsd_be = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = p + ie_len + 2;\n\t\t}\n\t}\n\n\t \n\tmemset(&pstat->htpriv.ht_cap, 0, sizeof(struct ieee80211_ht_cap));\n\tif (elems.ht_capabilities && elems.ht_capabilities_len >= sizeof(struct ieee80211_ht_cap)) {\n\t\tpstat->flags |= WLAN_STA_HT;\n\n\t\tpstat->flags |= WLAN_STA_WME;\n\n\t\tmemcpy(&pstat->htpriv.ht_cap, elems.ht_capabilities, sizeof(struct ieee80211_ht_cap));\n\n\t} else\n\t\tpstat->flags &= ~WLAN_STA_HT;\n\n\n\tif ((pmlmepriv->htpriv.ht_option == false) && (pstat->flags&WLAN_STA_HT)) {\n\t\tstatus = WLAN_STATUS_CHALLENGE_FAIL;\n\t\tgoto OnAssocReqFail;\n\t}\n\n\n\tif ((pstat->flags & WLAN_STA_HT) &&\n\t\t    ((pstat->wpa2_pairwise_cipher&WPA_CIPHER_TKIP) ||\n\t\t      (pstat->wpa_pairwise_cipher&WPA_CIPHER_TKIP))) {\n\t\t \n\t\t \n\t}\n\tpstat->flags |= WLAN_STA_NONERP;\n\tfor (i = 0; i < pstat->bssratelen; i++) {\n\t\tif ((pstat->bssrateset[i] & 0x7f) > 22) {\n\t\t\tpstat->flags &= ~WLAN_STA_NONERP;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pstat->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\n\t\tpstat->flags |= WLAN_STA_SHORT_PREAMBLE;\n\telse\n\t\tpstat->flags &= ~WLAN_STA_SHORT_PREAMBLE;\n\n\n\n\tif (status != WLAN_STATUS_SUCCESS)\n\t\tgoto OnAssocReqFail;\n\n\t \n\t \n\t \n\t \n\t \n\n\n\n\t \n\tif (pstat->aid == 0) {\n\t\tfor (pstat->aid = 1; pstat->aid <= NUM_STA; pstat->aid++)\n\t\t\tif (!pstapriv->sta_aid[pstat->aid - 1])\n\t\t\t\tbreak;\n\n\t\t \n\t\tif (pstat->aid > pstapriv->max_num_sta) {\n\n\t\t\tpstat->aid = 0;\n\n\t\t\tstatus = WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;\n\n\t\t\tgoto OnAssocReqFail;\n\n\n\t\t} else {\n\t\t\tpstapriv->sta_aid[pstat->aid - 1] = pstat;\n\t\t}\n\t}\n\n\n\tpstat->state &= (~WIFI_FW_ASSOC_STATE);\n\tpstat->state |= WIFI_FW_ASSOC_SUCCESS;\n\n\tspin_lock_bh(&pstapriv->auth_list_lock);\n\tif (!list_empty(&pstat->auth_list)) {\n\t\tlist_del_init(&pstat->auth_list);\n\t\tpstapriv->auth_list_cnt--;\n\t}\n\tspin_unlock_bh(&pstapriv->auth_list_lock);\n\n\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\tif (list_empty(&pstat->asoc_list)) {\n\t\tpstat->expire_to = pstapriv->expire_to;\n\t\tlist_add_tail(&pstat->asoc_list, &pstapriv->asoc_list);\n\t\tpstapriv->asoc_list_cnt++;\n\t}\n\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\n\t \n\tif (pstat && (pstat->state & WIFI_FW_ASSOC_SUCCESS) && (status == WLAN_STATUS_SUCCESS)) {\n\t\t \n\t\tbss_cap_update_on_sta_join(padapter, pstat);\n\t\tsta_info_update(padapter, pstat);\n\n\t\t \n\t\tif (frame_type == WIFI_ASSOCREQ)\n\t\t\tissue_asocrsp(padapter, status, pstat, WIFI_ASSOCRSP);\n\t\telse\n\t\t\tissue_asocrsp(padapter, status, pstat, WIFI_REASSOCRSP);\n\n\t\tspin_lock_bh(&pstat->lock);\n\t\tkfree(pstat->passoc_req);\n\t\tpstat->assoc_req_len = 0;\n\t\tpstat->passoc_req =  rtw_zmalloc(pkt_len);\n\t\tif (pstat->passoc_req) {\n\t\t\tmemcpy(pstat->passoc_req, pframe, pkt_len);\n\t\t\tpstat->assoc_req_len = pkt_len;\n\t\t}\n\t\tspin_unlock_bh(&pstat->lock);\n\n\t\t \n\t\treport_add_sta_event(padapter, pstat->hwaddr, pstat->aid);\n\t}\n\n\treturn _SUCCESS;\n\nasoc_class2_error:\n\n\tissue_deauth(padapter, (void *)GetAddr2Ptr(pframe), status);\n\n\treturn _FAIL;\n\nOnAssocReqFail:\n\n\tpstat->aid = 0;\n\tif (frame_type == WIFI_ASSOCREQ)\n\t\tissue_asocrsp(padapter, status, pstat, WIFI_ASSOCRSP);\n\telse\n\t\tissue_asocrsp(padapter, status, pstat, WIFI_REASSOCRSP);\n\n\treturn _FAIL;\n}\n\nunsigned int OnAssocRsp(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tuint i;\n\tint res;\n\tunsigned short\tstatus;\n\tstruct ndis_80211_var_ie *pIE;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\t \n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tuint pkt_len = precv_frame->u.hdr.len;\n\n\t \n\tif (memcmp(myid(&(padapter->eeprompriv)), get_da(pframe), ETH_ALEN))\n\t\treturn _SUCCESS;\n\n\tif (!(pmlmeinfo->state & (WIFI_FW_AUTH_SUCCESS | WIFI_FW_ASSOC_STATE)))\n\t\treturn _SUCCESS;\n\n\tif (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)\n\t\treturn _SUCCESS;\n\n\tdel_timer_sync(&pmlmeext->link_timer);\n\n\t \n\tstatus = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN + 2));\n\tif (status > 0) {\n\t\tpmlmeinfo->state = WIFI_FW_NULL_STATE;\n\t\tres = -4;\n\t\tgoto report_assoc_result;\n\t}\n\n\t \n\tpmlmeinfo->capability = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));\n\n\t \n\tpmlmeinfo->slotTime = (pmlmeinfo->capability & BIT(10)) ? 9 : 20;\n\n\t \n\tres = pmlmeinfo->aid = (int)(le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN + 4))&0x3fff);\n\n\t \n\t \n\t \n\tfor (i = (6 + WLAN_HDR_A3_LEN); i < pkt_len;) {\n\t\tpIE = (struct ndis_80211_var_ie *)(pframe + i);\n\n\t\tswitch (pIE->element_id) {\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\tif (!memcmp(pIE->data, WMM_PARA_OUI, 6))\t \n\t\t\t\tWMM_param_handler(padapter, pIE);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_HT_CAPABILITY:\t \n\t\t\tHT_caps_handler(padapter, pIE);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_HT_OPERATION:\t \n\t\t\tHT_info_handler(padapter, pIE);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_ERP_INFO:\n\t\t\tERP_IE_handler(padapter, pIE);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\ti += (pIE->length + 2);\n\t}\n\n\tpmlmeinfo->state &= (~WIFI_FW_ASSOC_STATE);\n\tpmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;\n\n\t \n\tUpdateBrateTbl(padapter, pmlmeinfo->network.supported_rates);\n\nreport_assoc_result:\n\tif (res > 0)\n\t\trtw_buf_update(&pmlmepriv->assoc_rsp, &pmlmepriv->assoc_rsp_len, pframe, pkt_len);\n\telse\n\t\trtw_buf_free(&pmlmepriv->assoc_rsp, &pmlmepriv->assoc_rsp_len);\n\n\treport_join_res(padapter, res);\n\n\treturn _SUCCESS;\n}\n\nunsigned int OnDeAuth(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tunsigned short\treason;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tint ignore_received_deauth = 0;\n\n\t \n\tif (memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN))\n\t\treturn _SUCCESS;\n\n\treason = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\tstruct sta_info *psta;\n\t\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\n\t\t \n\n\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t   \"ap recv deauth reason code(%d) sta:%pM\\n\", reason,\n\t\t\t   GetAddr2Ptr(pframe));\n\n\t\tpsta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));\n\t\tif (psta) {\n\t\t\tu8 updated = false;\n\n\t\t\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\t\t\tif (list_empty(&psta->asoc_list) == false) {\n\t\t\t\tlist_del_init(&psta->asoc_list);\n\t\t\t\tpstapriv->asoc_list_cnt--;\n\t\t\t\tupdated = ap_free_sta(padapter, psta, false, reason);\n\n\t\t\t}\n\t\t\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\n\t\t\tassociated_clients_update(padapter, updated);\n\t\t}\n\n\n\t\treturn _SUCCESS;\n\t}\n\n\t \n\t \n\t \n\t \n\t \n\tif ((pmlmeinfo->state & WIFI_FW_AUTH_STATE) ||\n\t    (pmlmeinfo->state & WIFI_FW_ASSOC_STATE)) {\n\t\tif (reason == WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA) {\n\t\t\tignore_received_deauth = 1;\n\t\t} else if (reason == WLAN_REASON_PREV_AUTH_NOT_VALID) {\n\t\t\t \n\t\t\tignore_received_deauth = 1;\n\t\t}\n\t}\n\n\tnetdev_dbg(padapter->pnetdev,\n\t\t   \"sta recv deauth reason code(%d) sta:%pM, ignore = %d\\n\",\n\t\t   reason, GetAddr3Ptr(pframe),\n\t\t   ignore_received_deauth);\n\n\tif (ignore_received_deauth == 0)\n\t\treceive_disconnect(padapter, GetAddr3Ptr(pframe), reason);\n\n\tpmlmepriv->LinkDetectInfo.bBusyTraffic = false;\n\treturn _SUCCESS;\n}\n\nunsigned int OnDisassoc(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tunsigned short\treason;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\n\t \n\tif (memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN))\n\t\treturn _SUCCESS;\n\n\treason = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\tstruct sta_info *psta;\n\t\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\n\t\t \n\n\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t   \"ap recv disassoc reason code(%d) sta:%pM\\n\",\n\t\t\t   reason, GetAddr2Ptr(pframe));\n\n\t\tpsta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));\n\t\tif (psta) {\n\t\t\tu8 updated = false;\n\n\t\t\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\t\t\tif (list_empty(&psta->asoc_list) == false) {\n\t\t\t\tlist_del_init(&psta->asoc_list);\n\t\t\t\tpstapriv->asoc_list_cnt--;\n\t\t\t\tupdated = ap_free_sta(padapter, psta, false, reason);\n\n\t\t\t}\n\t\t\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\n\t\t\tassociated_clients_update(padapter, updated);\n\t\t}\n\n\t\treturn _SUCCESS;\n\t}\n\tnetdev_dbg(padapter->pnetdev,\n\t\t   \"sta recv disassoc reason code(%d) sta:%pM\\n\",\n\t\t   reason, GetAddr3Ptr(pframe));\n\n\treceive_disconnect(padapter, GetAddr3Ptr(pframe), reason);\n\n\tpmlmepriv->LinkDetectInfo.bBusyTraffic = false;\n\treturn _SUCCESS;\n\n}\n\nunsigned int OnAtim(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\treturn _SUCCESS;\n}\n\nunsigned int on_action_spct(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tstruct sta_info *psta = NULL;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tu8 *frame_body = (u8 *)(pframe + sizeof(struct ieee80211_hdr_3addr));\n\tu8 category;\n\tu8 action;\n\n\tpsta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));\n\n\tif (!psta)\n\t\tgoto exit;\n\n\tcategory = frame_body[0];\n\tif (category != RTW_WLAN_CATEGORY_SPECTRUM_MGMT)\n\t\tgoto exit;\n\n\taction = frame_body[1];\n\tswitch (action) {\n\tcase WLAN_ACTION_SPCT_MSR_REQ:\n\tcase WLAN_ACTION_SPCT_MSR_RPRT:\n\tcase WLAN_ACTION_SPCT_TPC_REQ:\n\tcase WLAN_ACTION_SPCT_TPC_RPRT:\n\tcase WLAN_ACTION_SPCT_CHL_SWITCH:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nexit:\n\treturn _FAIL;\n}\n\nunsigned int OnAction_back(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tu8 *addr;\n\tstruct sta_info *psta = NULL;\n\tstruct recv_reorder_ctrl *preorder_ctrl;\n\tunsigned char \t*frame_body;\n\tunsigned char \tcategory, action;\n\tunsigned short\ttid, status;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\n\t \n\tif (memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN)) \n\t\treturn _SUCCESS;\n\n\tif ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)\n\t\tif (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))\n\t\t\treturn _SUCCESS;\n\n\taddr = GetAddr2Ptr(pframe);\n\tpsta = rtw_get_stainfo(pstapriv, addr);\n\n\tif (!psta)\n\t\treturn _SUCCESS;\n\n\tframe_body = (unsigned char *)(pframe + sizeof(struct ieee80211_hdr_3addr));\n\n\tcategory = frame_body[0];\n\tif (category == RTW_WLAN_CATEGORY_BACK) { \n\t\tif (!pmlmeinfo->HT_enable)\n\t\t\treturn _SUCCESS;\n\n\t\taction = frame_body[1];\n\t\tswitch (action) {\n\t\tcase WLAN_ACTION_ADDBA_REQ:  \n\n\t\t\tmemcpy(&(pmlmeinfo->ADDBA_req), &(frame_body[2]), sizeof(struct ADDBA_request));\n\t\t\t \n\t\t\tprocess_addba_req(padapter, (u8 *)&(pmlmeinfo->ADDBA_req), addr);\n\n\t\t\tif (pmlmeinfo->accept_addba_req)\n\t\t\t\tissue_action_BA(padapter, addr, WLAN_ACTION_ADDBA_RESP, 0);\n\t\t\telse\n\t\t\t\tissue_action_BA(padapter, addr, WLAN_ACTION_ADDBA_RESP, 37); \n\n\t\t\tbreak;\n\n\t\tcase WLAN_ACTION_ADDBA_RESP:  \n\t\t\tstatus = get_unaligned_le16(&frame_body[3]);\n\t\t\ttid = ((frame_body[5] >> 2) & 0x7);\n\n\t\t\tif (status == 0) {\n\t\t\t\t \n\t\t\t\tpsta->htpriv.agg_enable_bitmap |= BIT(tid);\n\t\t\t\tpsta->htpriv.candidate_tid_bitmap &= ~BIT(tid);\n\t\t\t} else {\n\t\t\t\tpsta->htpriv.agg_enable_bitmap &= ~BIT(tid);\n\t\t\t}\n\n\t\t\tif (psta->state & WIFI_STA_ALIVE_CHK_STATE) {\n\t\t\t\tpsta->htpriv.agg_enable_bitmap &= ~BIT(tid);\n\t\t\t\tpsta->expire_to = pstapriv->expire_to;\n\t\t\t\tpsta->state ^= WIFI_STA_ALIVE_CHK_STATE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase WLAN_ACTION_DELBA:  \n\t\t\tif ((frame_body[3] & BIT(3)) == 0) {\n\t\t\t\tpsta->htpriv.agg_enable_bitmap &=\n\t\t\t\t\t~BIT((frame_body[3] >> 4) & 0xf);\n\t\t\t\tpsta->htpriv.candidate_tid_bitmap &=\n\t\t\t\t\t~BIT((frame_body[3] >> 4) & 0xf);\n\t\t\t} else if ((frame_body[3] & BIT(3)) == BIT(3)) {\n\t\t\t\ttid = (frame_body[3] >> 4) & 0x0F;\n\n\t\t\t\tpreorder_ctrl =  &psta->recvreorder_ctrl[tid];\n\t\t\t\tpreorder_ctrl->enable = false;\n\t\t\t\tpreorder_ctrl->indicate_seq = 0xffff;\n\t\t\t}\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn _SUCCESS;\n}\n\nstatic s32 rtw_action_public_decache(union recv_frame *recv_frame, s32 token)\n{\n\tstruct adapter *adapter = recv_frame->u.hdr.adapter;\n\tstruct mlme_ext_priv *mlmeext = &(adapter->mlmeextpriv);\n\tu8 *frame = recv_frame->u.hdr.rx_data;\n\tu16 seq_ctrl = ((recv_frame->u.hdr.attrib.seq_num&0xffff) << 4) |\n\t\t(recv_frame->u.hdr.attrib.frag_num & 0xf);\n\n\tif (GetRetry(frame)) {\n\t\tif (token >= 0) {\n\t\t\tif ((seq_ctrl == mlmeext->action_public_rxseq)\n\t\t\t\t&& (token == mlmeext->action_public_dialog_token))\n\t\t\t\treturn _FAIL;\n\t\t} else {\n\t\t\tif (seq_ctrl == mlmeext->action_public_rxseq)\n\t\t\t\treturn _FAIL;\n\t\t}\n\t}\n\n\tmlmeext->action_public_rxseq = seq_ctrl;\n\n\tif (token >= 0)\n\t\tmlmeext->action_public_dialog_token = token;\n\n\treturn _SUCCESS;\n}\n\nstatic unsigned int on_action_public_p2p(union recv_frame *precv_frame)\n{\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tu8 *frame_body;\n\tu8 dialogToken = 0;\n\n\tframe_body = (unsigned char *)(pframe + sizeof(struct ieee80211_hdr_3addr));\n\n\tdialogToken = frame_body[7];\n\n\tif (rtw_action_public_decache(precv_frame, dialogToken) == _FAIL)\n\t\treturn _FAIL;\n\n\treturn _SUCCESS;\n}\n\nstatic unsigned int on_action_public_vendor(union recv_frame *precv_frame)\n{\n\tunsigned int ret = _FAIL;\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tu8 *frame_body = pframe + sizeof(struct ieee80211_hdr_3addr);\n\n\tif (!memcmp(frame_body + 2, P2P_OUI, 4))\n\t\tret = on_action_public_p2p(precv_frame);\n\n\treturn ret;\n}\n\nstatic unsigned int on_action_public_default(union recv_frame *precv_frame, u8 action)\n{\n\tunsigned int ret = _FAIL;\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tuint frame_len = precv_frame->u.hdr.len;\n\tu8 *frame_body = pframe + sizeof(struct ieee80211_hdr_3addr);\n\tu8 token;\n\tstruct adapter *adapter = precv_frame->u.hdr.adapter;\n\tchar msg[64];\n\n\ttoken = frame_body[2];\n\n\tif (rtw_action_public_decache(precv_frame, token) == _FAIL)\n\t\tgoto exit;\n\n\tscnprintf(msg, sizeof(msg), \"%s(token:%u)\", action_public_str(action), token);\n\trtw_cfg80211_rx_action(adapter, pframe, frame_len, msg);\n\n\tret = _SUCCESS;\n\nexit:\n\treturn ret;\n}\n\nunsigned int on_action_public(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tunsigned int ret = _FAIL;\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tu8 *frame_body = pframe + sizeof(struct ieee80211_hdr_3addr);\n\tu8 category, action;\n\n\t \n\tif (memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))\n\t\tgoto exit;\n\n\tcategory = frame_body[0];\n\tif (category != RTW_WLAN_CATEGORY_PUBLIC)\n\t\tgoto exit;\n\n\taction = frame_body[1];\n\tswitch (action) {\n\tcase ACT_PUBLIC_VENDOR:\n\t\tret = on_action_public_vendor(precv_frame);\n\t\tbreak;\n\tdefault:\n\t\tret = on_action_public_default(precv_frame, action);\n\t\tbreak;\n\t}\n\nexit:\n\treturn ret;\n}\n\nunsigned int OnAction_ht(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tu8 *frame_body = pframe + sizeof(struct ieee80211_hdr_3addr);\n\tu8 category, action;\n\n\t \n\tif (memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))\n\t\tgoto exit;\n\n\tcategory = frame_body[0];\n\tif (category != RTW_WLAN_CATEGORY_HT)\n\t\tgoto exit;\n\n\taction = frame_body[1];\n\tswitch (action) {\n\tcase WLAN_HT_ACTION_COMPRESSED_BF:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nexit:\n\n\treturn _SUCCESS;\n}\n\nunsigned int OnAction_sa_query(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tunsigned short tid;\n\n\tswitch (pframe[WLAN_HDR_A3_LEN+1]) {\n\tcase 0:  \n\t\tmemcpy(&tid, &pframe[WLAN_HDR_A3_LEN+2], sizeof(unsigned short));\n\t\tissue_action_SA_Query(padapter, GetAddr2Ptr(pframe), 1, tid);\n\t\tbreak;\n\n\tcase 1:  \n\t\tdel_timer_sync(&pmlmeext->sa_query_timer);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (0) {\n\t\tint pp;\n\n\t\tprintk(\"pattrib->pktlen = %d =>\", pattrib->pkt_len);\n\t\tfor (pp = 0; pp < pattrib->pkt_len; pp++)\n\t\t\tprintk(\" %02x \", pframe[pp]);\n\t\tprintk(\"\\n\");\n\t}\n\n\treturn _SUCCESS;\n}\n\nunsigned int OnAction(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tint i;\n\tunsigned char category;\n\tstruct action_handler *ptable;\n\tunsigned char *frame_body;\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\n\tframe_body = (unsigned char *)(pframe + sizeof(struct ieee80211_hdr_3addr));\n\n\tcategory = frame_body[0];\n\n\tfor (i = 0; i < ARRAY_SIZE(OnAction_tbl); i++) {\n\t\tptable = &OnAction_tbl[i];\n\n\t\tif (category == ptable->num)\n\t\t\tptable->func(padapter, precv_frame);\n\n\t}\n\n\treturn _SUCCESS;\n\n}\n\nunsigned int DoReserved(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\treturn _SUCCESS;\n}\n\nstatic struct xmit_frame *_alloc_mgtxmitframe(struct xmit_priv *pxmitpriv, bool once)\n{\n\tstruct xmit_frame *pmgntframe;\n\tstruct xmit_buf *pxmitbuf;\n\n\tif (once)\n\t\tpmgntframe = rtw_alloc_xmitframe_once(pxmitpriv);\n\telse\n\t\tpmgntframe = rtw_alloc_xmitframe_ext(pxmitpriv);\n\n\tif (!pmgntframe)\n\t\tgoto exit;\n\n\tpxmitbuf = rtw_alloc_xmitbuf_ext(pxmitpriv);\n\tif (!pxmitbuf) {\n\t\trtw_free_xmitframe(pxmitpriv, pmgntframe);\n\t\tpmgntframe = NULL;\n\t\tgoto exit;\n\t}\n\n\tpmgntframe->frame_tag = MGNT_FRAMETAG;\n\tpmgntframe->pxmitbuf = pxmitbuf;\n\tpmgntframe->buf_addr = pxmitbuf->pbuf;\n\tpxmitbuf->priv_data = pmgntframe;\n\nexit:\n\treturn pmgntframe;\n\n}\n\ninline struct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv)\n{\n\treturn _alloc_mgtxmitframe(pxmitpriv, false);\n}\n\n \n\nvoid update_mgnt_tx_rate(struct adapter *padapter, u8 rate)\n{\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\n\tpmlmeext->tx_rate = rate;\n}\n\nvoid update_mgntframe_attrib(struct adapter *padapter, struct pkt_attrib *pattrib)\n{\n\tu8 wireless_mode;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\n\t \n\n\tpattrib->hdrlen = 24;\n\tpattrib->nr_frags = 1;\n\tpattrib->priority = 7;\n\tpattrib->mac_id = 0;\n\tpattrib->qsel = 0x12;\n\n\tpattrib->pktlen = 0;\n\n\tif (pmlmeext->tx_rate == IEEE80211_CCK_RATE_1MB)\n\t\twireless_mode = WIRELESS_11B;\n\telse\n\t\twireless_mode = WIRELESS_11G;\n\tpattrib->raid =  rtw_get_mgntframe_raid(padapter, wireless_mode);\n\tpattrib->rate = pmlmeext->tx_rate;\n\n\tpattrib->encrypt = _NO_PRIVACY_;\n\tpattrib->bswenc = false;\n\n\tpattrib->qos_en = false;\n\tpattrib->ht_en = false;\n\tpattrib->bwmode = CHANNEL_WIDTH_20;\n\tpattrib->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\tpattrib->sgi = false;\n\n\tpattrib->seqnum = pmlmeext->mgnt_seq;\n\n\tpattrib->retry_ctrl = true;\n\n\tpattrib->mbssid = 0;\n\n}\n\nvoid update_mgntframe_attrib_addr(struct adapter *padapter, struct xmit_frame *pmgntframe)\n{\n\tu8 *pframe;\n\tstruct pkt_attrib\t*pattrib = &pmgntframe->attrib;\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\n\tmemcpy(pattrib->ra, GetAddr1Ptr(pframe), ETH_ALEN);\n\tmemcpy(pattrib->ta, GetAddr2Ptr(pframe), ETH_ALEN);\n}\n\nvoid dump_mgntframe(struct adapter *padapter, struct xmit_frame *pmgntframe)\n{\n\tif (padapter->bSurpriseRemoved ||\n\t\tpadapter->bDriverStopped) {\n\t\trtw_free_xmitbuf(&padapter->xmitpriv, pmgntframe->pxmitbuf);\n\t\trtw_free_xmitframe(&padapter->xmitpriv, pmgntframe);\n\t\treturn;\n\t}\n\n\trtw_hal_mgnt_xmit(padapter, pmgntframe);\n}\n\ns32 dump_mgntframe_and_wait(struct adapter *padapter, struct xmit_frame *pmgntframe, int timeout_ms)\n{\n\ts32 ret = _FAIL;\n\tunsigned long irqL;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct xmit_buf *pxmitbuf = pmgntframe->pxmitbuf;\n\tstruct submit_ctx sctx;\n\n\tif (padapter->bSurpriseRemoved ||\n\t\tpadapter->bDriverStopped) {\n\t\trtw_free_xmitbuf(&padapter->xmitpriv, pmgntframe->pxmitbuf);\n\t\trtw_free_xmitframe(&padapter->xmitpriv, pmgntframe);\n\t\treturn ret;\n\t}\n\n\trtw_sctx_init(&sctx, timeout_ms);\n\tpxmitbuf->sctx = &sctx;\n\n\tret = rtw_hal_mgnt_xmit(padapter, pmgntframe);\n\n\tif (ret == _SUCCESS)\n\t\tret = rtw_sctx_wait(&sctx);\n\n\tspin_lock_irqsave(&pxmitpriv->lock_sctx, irqL);\n\tpxmitbuf->sctx = NULL;\n\tspin_unlock_irqrestore(&pxmitpriv->lock_sctx, irqL);\n\n\treturn ret;\n}\n\ns32 dump_mgntframe_and_wait_ack(struct adapter *padapter, struct xmit_frame *pmgntframe)\n{\n\tstatic u8 seq_no;\n\ts32 ret = _FAIL;\n\tu32 timeout_ms = 500; \n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tif (padapter->bSurpriseRemoved ||\n\t\tpadapter->bDriverStopped) {\n\t\trtw_free_xmitbuf(&padapter->xmitpriv, pmgntframe->pxmitbuf);\n\t\trtw_free_xmitframe(&padapter->xmitpriv, pmgntframe);\n\t\treturn -1;\n\t}\n\n\tif (mutex_lock_interruptible(&pxmitpriv->ack_tx_mutex) == 0) {\n\t\tpxmitpriv->ack_tx = true;\n\t\tpxmitpriv->seq_no = seq_no++;\n\t\tpmgntframe->ack_report = 1;\n\t\tif (rtw_hal_mgnt_xmit(padapter, pmgntframe) == _SUCCESS)\n\t\t\tret = rtw_ack_tx_wait(pxmitpriv, timeout_ms);\n\n\t\tpxmitpriv->ack_tx = false;\n\t\tmutex_unlock(&pxmitpriv->ack_tx_mutex);\n\t}\n\n\treturn ret;\n}\n\nstatic int update_hidden_ssid(u8 *ies, u32 ies_len, u8 hidden_ssid_mode)\n{\n\tu8 *ssid_ie;\n\tsigned int ssid_len_ori;\n\tint len_diff = 0;\n\n\tssid_ie = rtw_get_ie(ies,  WLAN_EID_SSID, &ssid_len_ori, ies_len);\n\n\tif (ssid_ie && ssid_len_ori > 0) {\n\t\tswitch (hidden_ssid_mode) {\n\t\tcase 1:\n\t\t{\n\t\t\tu8 *next_ie = ssid_ie + 2 + ssid_len_ori;\n\t\t\tu32 remain_len = 0;\n\n\t\t\tremain_len = ies_len - (next_ie-ies);\n\n\t\t\tssid_ie[1] = 0;\n\t\t\tmemcpy(ssid_ie+2, next_ie, remain_len);\n\t\t\tlen_diff -= ssid_len_ori;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t\tmemset(&ssid_ie[2], 0, ssid_len_ori);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\t}\n\n\treturn len_diff;\n}\n\nvoid issue_beacon(struct adapter *padapter, int timeout_ms)\n{\n\tstruct xmit_frame\t*pmgntframe;\n\tstruct pkt_attrib\t*pattrib;\n\tunsigned char *pframe;\n\tstruct ieee80211_hdr *pwlanhdr;\n\t__le16 *fctrl;\n\tunsigned int\trate_len;\n\tstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex\t\t*cur_network = &(pmlmeinfo->network);\n\n\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\tif (!pmgntframe)\n\t\treturn;\n\n\tspin_lock_bh(&pmlmepriv->bcn_update_lock);\n\n\t \n\tpattrib = &pmgntframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\tpattrib->qsel = 0x10;\n\n\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\n\teth_broadcast_addr(pwlanhdr->addr1);\n\tmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\tmemcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);\n\n\tSetSeqNum(pwlanhdr, 0 );\n\t \n\tSetFrameSubType(pframe, WIFI_BEACON);\n\n\tpframe += sizeof(struct ieee80211_hdr_3addr);\n\tpattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);\n\n\tif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {\n\t\t{\n\t\t\tint len_diff;\n\n\t\t\tmemcpy(pframe, cur_network->ies, cur_network->ie_length);\n\t\t\tlen_diff = update_hidden_ssid(pframe+_BEACON_IE_OFFSET_,\n\t\t\t\t\t\t      cur_network->ie_length-_BEACON_IE_OFFSET_,\n\t\t\t\t\t\t      pmlmeinfo->hidden_ssid_mode);\n\t\t\tpframe += (cur_network->ie_length+len_diff);\n\t\t\tpattrib->pktlen += (cur_network->ie_length+len_diff);\n\t\t}\n\n\t\t{\n\t\t\tu8 *wps_ie;\n\t\t\tuint wps_ielen;\n\t\t\tu8 sr = 0;\n\n\t\t\twps_ie = rtw_get_wps_ie(pmgntframe->buf_addr+TXDESC_OFFSET+sizeof(struct ieee80211_hdr_3addr)+_BEACON_IE_OFFSET_,\n\t\t\t\tpattrib->pktlen-sizeof(struct ieee80211_hdr_3addr)-_BEACON_IE_OFFSET_, NULL, &wps_ielen);\n\t\t\tif (wps_ie && wps_ielen > 0)\n\t\t\t\trtw_get_wps_attr_content(wps_ie,  wps_ielen, WPS_ATTR_SELECTED_REGISTRAR, (u8 *)(&sr), NULL);\n\t\t\tif (sr != 0)\n\t\t\t\tset_fwstate(pmlmepriv, WIFI_UNDER_WPS);\n\t\t\telse\n\t\t\t\t_clr_fwstate_(pmlmepriv, WIFI_UNDER_WPS);\n\t\t}\n\n\t\tgoto _issue_bcn;\n\n\t}\n\n\t \n\n\t \n\tpframe += 8;\n\tpattrib->pktlen += 8;\n\n\t \n\n\tmemcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->ies)), 2);\n\n\tpframe += 2;\n\tpattrib->pktlen += 2;\n\n\t \n\n\tmemcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->ies)), 2);\n\n\tpframe += 2;\n\tpattrib->pktlen += 2;\n\n\t \n\tpframe = rtw_set_ie(pframe, WLAN_EID_SSID, cur_network->ssid.ssid_length, cur_network->ssid.ssid, &pattrib->pktlen);\n\n\t \n\trate_len = rtw_get_rateset_len(cur_network->supported_rates);\n\tpframe = rtw_set_ie(pframe, WLAN_EID_SUPP_RATES, ((rate_len > 8) ? 8 : rate_len), cur_network->supported_rates, &pattrib->pktlen);\n\n\t \n\tpframe = rtw_set_ie(pframe, WLAN_EID_DS_PARAMS, 1, (unsigned char *)&(cur_network->configuration.ds_config), &pattrib->pktlen);\n\n\t \n\t{\n\t\tu8 erpinfo = 0;\n\t\tu32 ATIMWindow;\n\t\t \n\t\t \n\t\tATIMWindow = 0;\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_IBSS_PARAMS, 2, (unsigned char *)(&ATIMWindow), &pattrib->pktlen);\n\n\t\t \n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_ERP_INFO, 1, &erpinfo, &pattrib->pktlen);\n\t}\n\n\n\t \n\tif (rate_len > 8)\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_EXT_SUPP_RATES, (rate_len - 8), (cur_network->supported_rates + 8), &pattrib->pktlen);\n\n\n\t \n\n_issue_bcn:\n\n\tpmlmepriv->update_bcn = false;\n\n\tspin_unlock_bh(&pmlmepriv->bcn_update_lock);\n\n\tif ((pattrib->pktlen + TXDESC_SIZE) > 512)\n\t\treturn;\n\n\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\tif (timeout_ms > 0)\n\t\tdump_mgntframe_and_wait(padapter, pmgntframe, timeout_ms);\n\telse\n\t\tdump_mgntframe(padapter, pmgntframe);\n\n}\n\nvoid issue_probersp(struct adapter *padapter, unsigned char *da, u8 is_valid_p2p_probereq)\n{\n\tstruct xmit_frame\t\t\t*pmgntframe;\n\tstruct pkt_attrib\t\t\t*pattrib;\n\tunsigned char \t\t\t\t*pframe;\n\tstruct ieee80211_hdr\t*pwlanhdr;\n\t__le16 *fctrl;\n\tunsigned char \t\t\t\t*mac, *bssid;\n\tstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\n\n\tu8 *pwps_ie;\n\tuint wps_ielen;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex\t\t*cur_network = &(pmlmeinfo->network);\n\tunsigned int\trate_len;\n\n\tif (!da)\n\t\treturn;\n\n\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\tif (!pmgntframe)\n\t\treturn;\n\n\t \n\tpattrib = &pmgntframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\n\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tmac = myid(&(padapter->eeprompriv));\n\tbssid = cur_network->mac_address;\n\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\tmemcpy(pwlanhdr->addr1, da, ETH_ALEN);\n\tmemcpy(pwlanhdr->addr2, mac, ETH_ALEN);\n\tmemcpy(pwlanhdr->addr3, bssid, ETH_ALEN);\n\n\tSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\n\tpmlmeext->mgnt_seq++;\n\tSetFrameSubType(fctrl, WIFI_PROBERSP);\n\n\tpattrib->hdrlen = sizeof(struct ieee80211_hdr_3addr);\n\tpattrib->pktlen = pattrib->hdrlen;\n\tpframe += pattrib->hdrlen;\n\n\n\tif (cur_network->ie_length > MAX_IE_SZ)\n\t\treturn;\n\n\tif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {\n\t\tpwps_ie = rtw_get_wps_ie(cur_network->ies+_FIXED_IE_LENGTH_, cur_network->ie_length-_FIXED_IE_LENGTH_, NULL, &wps_ielen);\n\n\t\t \n\t\tif (pmlmepriv->wps_probe_resp_ie && pwps_ie && wps_ielen > 0) {\n\t\t\tuint wps_offset, remainder_ielen;\n\t\t\tu8 *premainder_ie;\n\n\t\t\twps_offset = (uint)(pwps_ie - cur_network->ies);\n\n\t\t\tpremainder_ie = pwps_ie + wps_ielen;\n\n\t\t\tremainder_ielen = cur_network->ie_length - wps_offset - wps_ielen;\n\n\t\t\tmemcpy(pframe, cur_network->ies, wps_offset);\n\t\t\tpframe += wps_offset;\n\t\t\tpattrib->pktlen += wps_offset;\n\n\t\t\twps_ielen = (uint)pmlmepriv->wps_probe_resp_ie[1]; \n\t\t\tif ((wps_offset+wps_ielen+2) <= MAX_IE_SZ) {\n\t\t\t\tmemcpy(pframe, pmlmepriv->wps_probe_resp_ie, wps_ielen+2);\n\t\t\t\tpframe += wps_ielen+2;\n\t\t\t\tpattrib->pktlen += wps_ielen+2;\n\t\t\t}\n\n\t\t\tif ((wps_offset+wps_ielen+2+remainder_ielen) <= MAX_IE_SZ) {\n\t\t\t\tmemcpy(pframe, premainder_ie, remainder_ielen);\n\t\t\t\tpframe += remainder_ielen;\n\t\t\t\tpattrib->pktlen += remainder_ielen;\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy(pframe, cur_network->ies, cur_network->ie_length);\n\t\t\tpframe += cur_network->ie_length;\n\t\t\tpattrib->pktlen += cur_network->ie_length;\n\t\t}\n\n\t\t \n\t\t{\n\t\t\tu8 *ssid_ie;\n\t\t\tsigned int ssid_ielen;\n\t\t\tsigned int ssid_ielen_diff;\n\t\t\tu8 *buf;\n\t\t\tu8 *ies = pmgntframe->buf_addr+TXDESC_OFFSET+sizeof(struct ieee80211_hdr_3addr);\n\n\t\t\tbuf = rtw_zmalloc(MAX_IE_SZ);\n\t\t\tif (!buf)\n\t\t\t\treturn;\n\n\t\t\tssid_ie = rtw_get_ie(ies+_FIXED_IE_LENGTH_, WLAN_EID_SSID, &ssid_ielen,\n\t\t\t\t(pframe-ies)-_FIXED_IE_LENGTH_);\n\n\t\t\tssid_ielen_diff = cur_network->ssid.ssid_length - ssid_ielen;\n\n\t\t\tif (ssid_ie &&  cur_network->ssid.ssid_length) {\n\t\t\t\tuint remainder_ielen;\n\t\t\t\tu8 *remainder_ie;\n\n\t\t\t\tremainder_ie = ssid_ie+2;\n\t\t\t\tremainder_ielen = (pframe-remainder_ie);\n\n\t\t\t\tif (remainder_ielen > MAX_IE_SZ) {\n\t\t\t\t\tnetdev_warn(padapter->pnetdev,\n\t\t\t\t\t\t    FUNC_ADPT_FMT \" remainder_ielen > MAX_IE_SZ\\n\",\n\t\t\t\t\t\t    FUNC_ADPT_ARG(padapter));\n\t\t\t\t\tremainder_ielen = MAX_IE_SZ;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(buf, remainder_ie, remainder_ielen);\n\t\t\t\tmemcpy(remainder_ie+ssid_ielen_diff, buf, remainder_ielen);\n\t\t\t\t*(ssid_ie+1) = cur_network->ssid.ssid_length;\n\t\t\t\tmemcpy(ssid_ie+2, cur_network->ssid.ssid, cur_network->ssid.ssid_length);\n\n\t\t\t\tpframe += ssid_ielen_diff;\n\t\t\t\tpattrib->pktlen += ssid_ielen_diff;\n\t\t\t}\n\t\t\tkfree(buf);\n\t\t}\n\t} else {\n\t\t \n\t\tpframe += 8;\n\t\tpattrib->pktlen += 8;\n\n\t\t \n\n\t\tmemcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->ies)), 2);\n\n\t\tpframe += 2;\n\t\tpattrib->pktlen += 2;\n\n\t\t \n\n\t\tmemcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->ies)), 2);\n\n\t\tpframe += 2;\n\t\tpattrib->pktlen += 2;\n\n\t\t \n\n\t\t \n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_SSID, cur_network->ssid.ssid_length, cur_network->ssid.ssid, &pattrib->pktlen);\n\n\t\t \n\t\trate_len = rtw_get_rateset_len(cur_network->supported_rates);\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_SUPP_RATES, ((rate_len > 8) ? 8 : rate_len), cur_network->supported_rates, &pattrib->pktlen);\n\n\t\t \n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_DS_PARAMS, 1, (unsigned char *)&(cur_network->configuration.ds_config), &pattrib->pktlen);\n\n\t\tif ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {\n\t\t\tu8 erpinfo = 0;\n\t\t\tu32 ATIMWindow;\n\t\t\t \n\t\t\t \n\t\t\tATIMWindow = 0;\n\t\t\tpframe = rtw_set_ie(pframe, WLAN_EID_IBSS_PARAMS, 2, (unsigned char *)(&ATIMWindow), &pattrib->pktlen);\n\n\t\t\t \n\t\t\tpframe = rtw_set_ie(pframe, WLAN_EID_ERP_INFO, 1, &erpinfo, &pattrib->pktlen);\n\t\t}\n\n\n\t\t \n\t\tif (rate_len > 8)\n\t\t\tpframe = rtw_set_ie(pframe, WLAN_EID_EXT_SUPP_RATES, (rate_len - 8), (cur_network->supported_rates + 8), &pattrib->pktlen);\n\n\n\t\t \n\n\t}\n\n\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\n\tdump_mgntframe(padapter, pmgntframe);\n\n\treturn;\n\n}\n\nstatic int _issue_probereq(struct adapter *padapter,\n\t\t\t   struct ndis_802_11_ssid *pssid,\n\t\t\t   u8 *da, u8 ch, bool append_wps, bool wait_ack)\n{\n\tint ret = _FAIL;\n\tstruct xmit_frame\t\t*pmgntframe;\n\tstruct pkt_attrib\t\t*pattrib;\n\tunsigned char \t\t*pframe;\n\tstruct ieee80211_hdr\t*pwlanhdr;\n\t__le16 *fctrl;\n\tunsigned char \t\t*mac;\n\tunsigned char \t\tbssrate[NumRates];\n\tstruct xmit_priv \t*pxmitpriv = &(padapter->xmitpriv);\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tint\tbssrate_len = 0;\n\n\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\tif (!pmgntframe)\n\t\tgoto exit;\n\n\t \n\tpattrib = &pmgntframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\n\n\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tmac = myid(&(padapter->eeprompriv));\n\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\n\tif (da) {\n\t\t \n\t\tmemcpy(pwlanhdr->addr1, da, ETH_ALEN);\n\t\tmemcpy(pwlanhdr->addr3, da, ETH_ALEN);\n\t} else {\n\t\t \n\t\teth_broadcast_addr(pwlanhdr->addr1);\n\t\teth_broadcast_addr(pwlanhdr->addr3);\n\t}\n\n\tmemcpy(pwlanhdr->addr2, mac, ETH_ALEN);\n\n\tSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\n\tpmlmeext->mgnt_seq++;\n\tSetFrameSubType(pframe, WIFI_PROBEREQ);\n\n\tpframe += sizeof(struct ieee80211_hdr_3addr);\n\tpattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);\n\n\tif (pssid)\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_SSID, pssid->ssid_length, pssid->ssid, &(pattrib->pktlen));\n\telse\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_SSID, 0, NULL, &(pattrib->pktlen));\n\n\tget_rate_set(padapter, bssrate, &bssrate_len);\n\n\tif (bssrate_len > 8) {\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_SUPP_RATES, 8, bssrate, &(pattrib->pktlen));\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_EXT_SUPP_RATES, (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));\n\t} else {\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_SUPP_RATES, bssrate_len, bssrate, &(pattrib->pktlen));\n\t}\n\n\tif (ch)\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_DS_PARAMS, 1, &ch, &pattrib->pktlen);\n\n\tif (append_wps) {\n\t\t \n\t\tif (pmlmepriv->wps_probe_req_ie_len > 0 && pmlmepriv->wps_probe_req_ie) {\n\t\t\tmemcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);\n\t\t\tpframe += pmlmepriv->wps_probe_req_ie_len;\n\t\t\tpattrib->pktlen += pmlmepriv->wps_probe_req_ie_len;\n\t\t}\n\t}\n\n\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\tif (wait_ack) {\n\t\tret = dump_mgntframe_and_wait_ack(padapter, pmgntframe);\n\t} else {\n\t\tdump_mgntframe(padapter, pmgntframe);\n\t\tret = _SUCCESS;\n\t}\n\nexit:\n\treturn ret;\n}\n\ninline void issue_probereq(struct adapter *padapter, struct ndis_802_11_ssid *pssid, u8 *da)\n{\n\t_issue_probereq(padapter, pssid, da, 0, 1, false);\n}\n\nint issue_probereq_ex(struct adapter *padapter, struct ndis_802_11_ssid *pssid, u8 *da, u8 ch, bool append_wps,\n\tint try_cnt, int wait_ms)\n{\n\tint ret;\n\tint i = 0;\n\n\tdo {\n\t\tret = _issue_probereq(padapter, pssid, da, ch, append_wps,\n\t\t\t\t      wait_ms > 0);\n\n\t\ti++;\n\n\t\tif (padapter->bDriverStopped || padapter->bSurpriseRemoved)\n\t\t\tbreak;\n\n\t\tif (i < try_cnt && wait_ms > 0 && ret == _FAIL)\n\t\t\tmsleep(wait_ms);\n\n\t} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));\n\n\tif (ret != _FAIL) {\n\t\tret = _SUCCESS;\n\t\t#ifndef DBG_XMIT_ACK\n\t\tgoto exit;\n\t\t#endif\n\t}\n\nexit:\n\treturn ret;\n}\n\n \nvoid issue_auth(struct adapter *padapter, struct sta_info *psta, unsigned short status)\n{\n\tstruct xmit_frame\t\t\t*pmgntframe;\n\tstruct pkt_attrib\t\t\t*pattrib;\n\tunsigned char \t\t\t\t*pframe;\n\tstruct ieee80211_hdr\t*pwlanhdr;\n\t__le16 *fctrl;\n\tunsigned int\t\t\t\t\tval32;\n\tunsigned short\t\t\t\tval16;\n\tint use_shared_key = 0;\n\tstruct xmit_priv \t\t*pxmitpriv = &(padapter->xmitpriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\t__le16 le_tmp;\n\n\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\tif (!pmgntframe)\n\t\treturn;\n\n\t \n\tpattrib = &pmgntframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\n\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\n\tSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\n\tpmlmeext->mgnt_seq++;\n\tSetFrameSubType(pframe, WIFI_AUTH);\n\n\tpframe += sizeof(struct ieee80211_hdr_3addr);\n\tpattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);\n\n\n\tif (psta) {  \n\t\tmemcpy(pwlanhdr->addr1, psta->hwaddr, ETH_ALEN);\n\t\tmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\t\tmemcpy(pwlanhdr->addr3, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\n\t\t \n\t\tval16 = (u16)psta->authalg;\n\n\t\tif (status != WLAN_STATUS_SUCCESS)\n\t\t\tval16 = 0;\n\n\t\tif (val16)\n\t\t\tuse_shared_key = 1;\n\n\t\tle_tmp = cpu_to_le16(val16);\n\n\t\tpframe = rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_, (unsigned char *)&le_tmp, &(pattrib->pktlen));\n\n\t\t \n\t\tval16 = (u16)psta->auth_seq;\n\t\tle_tmp = cpu_to_le16(val16);\n\t\tpframe = rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_, (unsigned char *)&le_tmp, &(pattrib->pktlen));\n\n\t\t \n\t\tval16 = status;\n\t\tle_tmp = cpu_to_le16(val16);\n\t\tpframe = rtw_set_fixed_ie(pframe, _STATUS_CODE_, (unsigned char *)&le_tmp, &(pattrib->pktlen));\n\n\t\t \n\t\tif ((psta->auth_seq == 2) && (psta->state & WIFI_FW_AUTH_STATE) && (use_shared_key == 1))\n\t\t\tpframe = rtw_set_ie(pframe, WLAN_EID_CHALLENGE, 128, psta->chg_txt, &(pattrib->pktlen));\n\n\t} else {\n\t\tmemcpy(pwlanhdr->addr1, get_my_bssid(&pmlmeinfo->network), ETH_ALEN);\n\t\tmemcpy(pwlanhdr->addr2, myid(&padapter->eeprompriv), ETH_ALEN);\n\t\tmemcpy(pwlanhdr->addr3, get_my_bssid(&pmlmeinfo->network), ETH_ALEN);\n\n\t\t \n\t\tval16 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared) ? 1 : 0; \n\t\tif (val16)\n\t\t\tuse_shared_key = 1;\n\t\tle_tmp = cpu_to_le16(val16);\n\n\t\t \n\t\tif ((pmlmeinfo->auth_seq == 3) && (pmlmeinfo->state & WIFI_FW_AUTH_STATE) && (use_shared_key == 1)) {\n\t\t\t__le32 le_tmp32;\n\n\t\t\tval32 = ((pmlmeinfo->iv++) | (pmlmeinfo->key_index << 30));\n\t\t\tle_tmp32 = cpu_to_le32(val32);\n\t\t\tpframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *)&le_tmp32, &(pattrib->pktlen));\n\n\t\t\tpattrib->iv_len = 4;\n\t\t}\n\n\t\tpframe = rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_, (unsigned char *)&le_tmp, &(pattrib->pktlen));\n\n\t\t \n\t\tle_tmp = cpu_to_le16(pmlmeinfo->auth_seq);\n\t\tpframe = rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_, (unsigned char *)&le_tmp, &(pattrib->pktlen));\n\n\n\t\t \n\t\tle_tmp = cpu_to_le16(status);\n\t\tpframe = rtw_set_fixed_ie(pframe, _STATUS_CODE_, (unsigned char *)&le_tmp, &(pattrib->pktlen));\n\n\t\t \n\t\tif ((pmlmeinfo->auth_seq == 3) && (pmlmeinfo->state & WIFI_FW_AUTH_STATE) && (use_shared_key == 1)) {\n\t\t\tpframe = rtw_set_ie(pframe, WLAN_EID_CHALLENGE, 128, pmlmeinfo->chg_txt, &(pattrib->pktlen));\n\n\t\t\tSetPrivacy(fctrl);\n\n\t\t\tpattrib->hdrlen = sizeof(struct ieee80211_hdr_3addr);\n\n\t\t\tpattrib->encrypt = _WEP40_;\n\n\t\t\tpattrib->icv_len = 4;\n\n\t\t\tpattrib->pktlen += pattrib->icv_len;\n\n\t\t}\n\n\t}\n\n\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\trtw_wep_encrypt(padapter, (u8 *)pmgntframe);\n\tdump_mgntframe(padapter, pmgntframe);\n}\n\n\nvoid issue_asocrsp(struct adapter *padapter, unsigned short status, struct sta_info *pstat, int pkt_type)\n{\n\tstruct xmit_frame\t*pmgntframe;\n\tstruct ieee80211_hdr\t*pwlanhdr;\n\tstruct pkt_attrib *pattrib;\n\tunsigned char *pbuf, *pframe;\n\tunsigned short val;\n\t__le16 *fctrl;\n\tstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\n\tu8 *ie = pnetwork->ies;\n\t__le16 lestatus, le_tmp;\n\n\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\tif (!pmgntframe)\n\t\treturn;\n\n\t \n\tpattrib = &pmgntframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\n\n\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\n\tmemcpy((void *)GetAddr1Ptr(pwlanhdr), pstat->hwaddr, ETH_ALEN);\n\tmemcpy((void *)GetAddr2Ptr(pwlanhdr), myid(&(padapter->eeprompriv)), ETH_ALEN);\n\tmemcpy((void *)GetAddr3Ptr(pwlanhdr), get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\n\n\tSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\n\tpmlmeext->mgnt_seq++;\n\tif ((pkt_type == WIFI_ASSOCRSP) || (pkt_type == WIFI_REASSOCRSP))\n\t\tSetFrameSubType(pwlanhdr, pkt_type);\n\telse\n\t\treturn;\n\n\tpattrib->hdrlen = sizeof(struct ieee80211_hdr_3addr);\n\tpattrib->pktlen += pattrib->hdrlen;\n\tpframe += pattrib->hdrlen;\n\n\t \n\tval = *(unsigned short *)rtw_get_capability_from_ie(ie);\n\n\tpframe = rtw_set_fixed_ie(pframe, _CAPABILITY_, (unsigned char *)&val, &(pattrib->pktlen));\n\n\tlestatus = cpu_to_le16(status);\n\tpframe = rtw_set_fixed_ie(pframe, _STATUS_CODE_, (unsigned char *)&lestatus, &(pattrib->pktlen));\n\n\tle_tmp = cpu_to_le16(pstat->aid | BIT(14) | BIT(15));\n\tpframe = rtw_set_fixed_ie(pframe, _ASOC_ID_, (unsigned char *)&le_tmp, &(pattrib->pktlen));\n\n\tif (pstat->bssratelen <= 8) {\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_SUPP_RATES, pstat->bssratelen, pstat->bssrateset, &(pattrib->pktlen));\n\t} else {\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_SUPP_RATES, 8, pstat->bssrateset, &(pattrib->pktlen));\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_EXT_SUPP_RATES, (pstat->bssratelen-8), pstat->bssrateset+8, &(pattrib->pktlen));\n\t}\n\n\tif ((pstat->flags & WLAN_STA_HT) && (pmlmepriv->htpriv.ht_option)) {\n\t\tuint ie_len = 0;\n\n\t\t \n\t\t \n\t\tpbuf = rtw_get_ie(ie + _BEACON_IE_OFFSET_, WLAN_EID_HT_CAPABILITY, &ie_len, (pnetwork->ie_length - _BEACON_IE_OFFSET_));\n\t\tif (pbuf && ie_len > 0) {\n\t\t\tmemcpy(pframe, pbuf, ie_len+2);\n\t\t\tpframe += (ie_len+2);\n\t\t\tpattrib->pktlen += (ie_len+2);\n\t\t}\n\n\t\t \n\t\t \n\t\tpbuf = rtw_get_ie(ie + _BEACON_IE_OFFSET_, WLAN_EID_HT_OPERATION, &ie_len, (pnetwork->ie_length - _BEACON_IE_OFFSET_));\n\t\tif (pbuf && ie_len > 0) {\n\t\t\tmemcpy(pframe, pbuf, ie_len+2);\n\t\t\tpframe += (ie_len+2);\n\t\t\tpattrib->pktlen += (ie_len+2);\n\t\t}\n\n\t}\n\n\t \n\tif ((pstat->flags & WLAN_STA_WME) && (pmlmepriv->qospriv.qos_option)) {\n\t\tuint ie_len = 0;\n\t\tunsigned char WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};\n\n\t\tfor (pbuf = ie + _BEACON_IE_OFFSET_; ; pbuf += (ie_len + 2)) {\n\t\t\tpbuf = rtw_get_ie(pbuf, WLAN_EID_VENDOR_SPECIFIC, &ie_len, (pnetwork->ie_length - _BEACON_IE_OFFSET_ - (ie_len + 2)));\n\t\t\tif (pbuf && !memcmp(pbuf+2, WMM_PARA_IE, 6)) {\n\t\t\t\tmemcpy(pframe, pbuf, ie_len+2);\n\t\t\t\tpframe += (ie_len+2);\n\t\t\t\tpattrib->pktlen += (ie_len+2);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!pbuf || ie_len == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_REALTEK)\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_VENDOR_SPECIFIC, 6, REALTEK_96B_IE, &(pattrib->pktlen));\n\n\t \n\tif (pmlmepriv->wps_assoc_resp_ie && pmlmepriv->wps_assoc_resp_ie_len > 0) {\n\t\tmemcpy(pframe, pmlmepriv->wps_assoc_resp_ie, pmlmepriv->wps_assoc_resp_ie_len);\n\n\t\tpframe += pmlmepriv->wps_assoc_resp_ie_len;\n\t\tpattrib->pktlen += pmlmepriv->wps_assoc_resp_ie_len;\n\t}\n\n\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\tdump_mgntframe(padapter, pmgntframe);\n}\n\nvoid issue_assocreq(struct adapter *padapter)\n{\n\tint ret = _FAIL;\n\tstruct xmit_frame\t\t\t\t*pmgntframe;\n\tstruct pkt_attrib\t\t\t\t*pattrib;\n\tunsigned char \t\t\t\t*pframe;\n\tstruct ieee80211_hdr\t\t\t*pwlanhdr;\n\t__le16 *fctrl;\n\t__le16 val16;\n\tunsigned int\t\t\t\t\ti, j, index = 0;\n\tunsigned char bssrate[NumRates], sta_bssrate[NumRates];\n\tstruct ndis_80211_var_ie *pIE;\n\tstruct xmit_priv \t*pxmitpriv = &(padapter->xmitpriv);\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tint\tbssrate_len = 0, sta_bssrate_len = 0;\n\tu8 vs_ie_length = 0;\n\n\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\tif (!pmgntframe)\n\t\tgoto exit;\n\n\t \n\tpattrib = &pmgntframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\n\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\tmemcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\tmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\tmemcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\n\tSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\n\tpmlmeext->mgnt_seq++;\n\tSetFrameSubType(pframe, WIFI_ASSOCREQ);\n\n\tpframe += sizeof(struct ieee80211_hdr_3addr);\n\tpattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);\n\n\t \n\tmemcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.ies), 2);\n\n\tpframe += 2;\n\tpattrib->pktlen += 2;\n\n\t \n\t \n\tval16 = cpu_to_le16(3);\n\tmemcpy(pframe, (unsigned char *)&val16, 2);\n\tpframe += 2;\n\tpattrib->pktlen += 2;\n\n\t \n\tpframe = rtw_set_ie(pframe, WLAN_EID_SSID,  pmlmeinfo->network.ssid.ssid_length, pmlmeinfo->network.ssid.ssid, &(pattrib->pktlen));\n\n\t \n\n\t \n\tget_rate_set(padapter, sta_bssrate, &sta_bssrate_len);\n\n\tif (pmlmeext->cur_channel == 14)  \n\t\tsta_bssrate_len = 4;\n\n\n\t \n\t \n\n\tfor (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {\n\t\tif (pmlmeinfo->network.supported_rates[i] == 0)\n\t\t\tbreak;\n\t}\n\n\n\tfor (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {\n\t\tif (pmlmeinfo->network.supported_rates[i] == 0)\n\t\t\tbreak;\n\n\n\t\t \n\t\tfor (j = 0; j < sta_bssrate_len; j++) {\n\t\t\t  \n\t\t\tif ((pmlmeinfo->network.supported_rates[i] | IEEE80211_BASIC_RATE_MASK)\n\t\t\t\t\t== (sta_bssrate[j] | IEEE80211_BASIC_RATE_MASK))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j != sta_bssrate_len)\n\t\t\t \n\t\t\tbssrate[index++] = pmlmeinfo->network.supported_rates[i];\n\t}\n\n\tbssrate_len = index;\n\n\tif (bssrate_len == 0) {\n\t\trtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);\n\t\trtw_free_xmitframe(pxmitpriv, pmgntframe);\n\t\tgoto exit;  \n\t}\n\n\n\tif (bssrate_len > 8) {\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_SUPP_RATES, 8, bssrate, &(pattrib->pktlen));\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_EXT_SUPP_RATES, (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));\n\t} else\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_SUPP_RATES, bssrate_len, bssrate, &(pattrib->pktlen));\n\n\t \n\tfor (i = sizeof(struct ndis_802_11_fix_ie); i < pmlmeinfo->network.ie_length;) {\n\t\tpIE = (struct ndis_80211_var_ie *)(pmlmeinfo->network.ies + i);\n\n\t\tswitch (pIE->element_id) {\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\tif ((!memcmp(pIE->data, RTW_WPA_OUI, 4)) ||\n\t\t\t\t\t(!memcmp(pIE->data, WMM_OUI, 4)) ||\n\t\t\t\t\t(!memcmp(pIE->data, WPS_OUI, 4))) {\n\t\t\t\tvs_ie_length = pIE->length;\n\t\t\t\tif ((!padapter->registrypriv.wifi_spec) && (!memcmp(pIE->data, WPS_OUI, 4))) {\n\t\t\t\t\t \n\n\t\t\t\t\tvs_ie_length = 14;\n\t\t\t\t}\n\n\t\t\t\tpframe = rtw_set_ie(pframe, WLAN_EID_VENDOR_SPECIFIC, vs_ie_length, pIE->data, &(pattrib->pktlen));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_RSN:\n\t\t\tpframe = rtw_set_ie(pframe, WLAN_EID_RSN, pIE->length, pIE->data, &(pattrib->pktlen));\n\t\t\tbreak;\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\t\tif (padapter->mlmepriv.htpriv.ht_option) {\n\t\t\t\tif (!(is_ap_in_tkip(padapter))) {\n\t\t\t\t\tmemcpy(&(pmlmeinfo->HT_caps), pIE->data, sizeof(struct HT_caps_element));\n\t\t\t\t\tpframe = rtw_set_ie(pframe, WLAN_EID_HT_CAPABILITY, pIE->length, (u8 *)(&(pmlmeinfo->HT_caps)), &(pattrib->pktlen));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_EXT_CAPABILITY:\n\t\t\tif (padapter->mlmepriv.htpriv.ht_option)\n\t\t\t\tpframe = rtw_set_ie(pframe, WLAN_EID_EXT_CAPABILITY, pIE->length, pIE->data, &(pattrib->pktlen));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\ti += (pIE->length + 2);\n\t}\n\n\tif (pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_REALTEK)\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_VENDOR_SPECIFIC, 6, REALTEK_96B_IE, &(pattrib->pktlen));\n\n\n\tpattrib->last_txcmdsz = pattrib->pktlen;\n\tdump_mgntframe(padapter, pmgntframe);\n\n\tret = _SUCCESS;\n\nexit:\n\tif (ret == _SUCCESS)\n\t\trtw_buf_update(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len, (u8 *)pwlanhdr, pattrib->pktlen);\n\telse\n\t\trtw_buf_free(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len);\n}\n\n \nstatic int _issue_nulldata(struct adapter *padapter, unsigned char *da,\n\t\t\t   unsigned int power_mode, bool wait_ack)\n{\n\tint ret = _FAIL;\n\tstruct xmit_frame\t\t\t*pmgntframe;\n\tstruct pkt_attrib\t\t\t*pattrib;\n\tunsigned char \t\t\t\t*pframe;\n\tstruct ieee80211_hdr\t*pwlanhdr;\n\t__le16 *fctrl;\n\tstruct xmit_priv *pxmitpriv;\n\tstruct mlme_ext_priv *pmlmeext;\n\tstruct mlme_ext_info *pmlmeinfo;\n\n\tif (!padapter)\n\t\tgoto exit;\n\n\tpxmitpriv = &(padapter->xmitpriv);\n\tpmlmeext = &(padapter->mlmeextpriv);\n\tpmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\tif (!pmgntframe)\n\t\tgoto exit;\n\n\t \n\tpattrib = &pmgntframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\tpattrib->retry_ctrl = false;\n\n\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\n\tif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)\n\t\tSetFrDs(fctrl);\n\telse if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)\n\t\tSetToDs(fctrl);\n\n\tif (power_mode)\n\t\tSetPwrMgt(fctrl);\n\n\tmemcpy(pwlanhdr->addr1, da, ETH_ALEN);\n\tmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\tmemcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\n\tSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\n\tpmlmeext->mgnt_seq++;\n\tSetFrameSubType(pframe, WIFI_DATA_NULL);\n\n\tpframe += sizeof(struct ieee80211_hdr_3addr);\n\tpattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);\n\n\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\tif (wait_ack) {\n\t\tret = dump_mgntframe_and_wait_ack(padapter, pmgntframe);\n\t} else {\n\t\tdump_mgntframe(padapter, pmgntframe);\n\t\tret = _SUCCESS;\n\t}\n\nexit:\n\treturn ret;\n}\n\n \nint issue_nulldata(struct adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms)\n{\n\tint ret;\n\tint i = 0;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct sta_info *psta;\n\n\n\t \n\tif (!da)\n\t\tda = get_my_bssid(&(pmlmeinfo->network));\n\n\tpsta = rtw_get_stainfo(&padapter->stapriv, da);\n\tif (psta) {\n\t\tif (power_mode)\n\t\t\trtw_hal_macid_sleep(padapter, psta->mac_id);\n\t\telse\n\t\t\trtw_hal_macid_wakeup(padapter, psta->mac_id);\n\t} else {\n\t\trtw_warn_on(1);\n\t}\n\n\tdo {\n\t\tret = _issue_nulldata(padapter, da, power_mode, wait_ms > 0);\n\n\t\ti++;\n\n\t\tif (padapter->bDriverStopped || padapter->bSurpriseRemoved)\n\t\t\tbreak;\n\n\t\tif (i < try_cnt && wait_ms > 0 && ret == _FAIL)\n\t\t\tmsleep(wait_ms);\n\n\t} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));\n\n\tif (ret != _FAIL) {\n\t\tret = _SUCCESS;\n\t\t#ifndef DBG_XMIT_ACK\n\t\tgoto exit;\n\t\t#endif\n\t}\n\nexit:\n\treturn ret;\n}\n\n \ns32 issue_nulldata_in_interrupt(struct adapter *padapter, u8 *da)\n{\n\tstruct mlme_ext_priv *pmlmeext;\n\tstruct mlme_ext_info *pmlmeinfo;\n\n\n\tpmlmeext = &padapter->mlmeextpriv;\n\tpmlmeinfo = &pmlmeext->mlmext_info;\n\n\t \n\tif (!da)\n\t\tda = get_my_bssid(&(pmlmeinfo->network));\n\n\treturn _issue_nulldata(padapter, da, 0, false);\n}\n\n \nstatic int _issue_qos_nulldata(struct adapter *padapter, unsigned char *da,\n\t\t\t       u16 tid, bool wait_ack)\n{\n\tint ret = _FAIL;\n\tstruct xmit_frame\t\t\t*pmgntframe;\n\tstruct pkt_attrib\t\t\t*pattrib;\n\tunsigned char \t\t\t\t*pframe;\n\tstruct ieee80211_hdr\t*pwlanhdr;\n\t__le16 *fctrl;\n\tu16 *qc;\n\tstruct xmit_priv \t\t*pxmitpriv = &(padapter->xmitpriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\tif (!pmgntframe)\n\t\tgoto exit;\n\n\t \n\tpattrib = &pmgntframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\n\tpattrib->hdrlen += 2;\n\tpattrib->qos_en = true;\n\tpattrib->eosp = 1;\n\tpattrib->ack_policy = 0;\n\tpattrib->mdata = 0;\n\n\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\n\tif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)\n\t\tSetFrDs(fctrl);\n\telse if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)\n\t\tSetToDs(fctrl);\n\n\tqc = (unsigned short *)(pframe + pattrib->hdrlen - 2);\n\n\tSetPriority(qc, tid);\n\n\tSetEOSP(qc, pattrib->eosp);\n\n\tSetAckpolicy(qc, pattrib->ack_policy);\n\n\tmemcpy(pwlanhdr->addr1, da, ETH_ALEN);\n\tmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\tmemcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\n\tSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\n\tpmlmeext->mgnt_seq++;\n\tSetFrameSubType(pframe, WIFI_QOS_DATA_NULL);\n\n\tpframe += sizeof(struct ieee80211_qos_hdr);\n\tpattrib->pktlen = sizeof(struct ieee80211_qos_hdr);\n\n\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\tif (wait_ack) {\n\t\tret = dump_mgntframe_and_wait_ack(padapter, pmgntframe);\n\t} else {\n\t\tdump_mgntframe(padapter, pmgntframe);\n\t\tret = _SUCCESS;\n\t}\n\nexit:\n\treturn ret;\n}\n\n \n \nint issue_qos_nulldata(struct adapter *padapter, unsigned char *da, u16 tid, int try_cnt, int wait_ms)\n{\n\tint ret;\n\tint i = 0;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\t \n\tif (!da)\n\t\tda = get_my_bssid(&(pmlmeinfo->network));\n\n\tdo {\n\t\tret = _issue_qos_nulldata(padapter, da, tid, wait_ms > 0);\n\n\t\ti++;\n\n\t\tif (padapter->bDriverStopped || padapter->bSurpriseRemoved)\n\t\t\tbreak;\n\n\t\tif (i < try_cnt && wait_ms > 0 && ret == _FAIL)\n\t\t\tmsleep(wait_ms);\n\n\t} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));\n\n\tif (ret != _FAIL) {\n\t\tret = _SUCCESS;\n\t\t#ifndef DBG_XMIT_ACK\n\t\tgoto exit;\n\t\t#endif\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int _issue_deauth(struct adapter *padapter, unsigned char *da,\n\t\t\t unsigned short reason, bool wait_ack)\n{\n\tstruct xmit_frame\t\t\t*pmgntframe;\n\tstruct pkt_attrib\t\t\t*pattrib;\n\tunsigned char \t\t\t\t*pframe;\n\tstruct ieee80211_hdr\t*pwlanhdr;\n\t__le16 *fctrl;\n\tstruct xmit_priv \t\t*pxmitpriv = &(padapter->xmitpriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tint ret = _FAIL;\n\t__le16 le_tmp;\n\n\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\tif (!pmgntframe)\n\t\tgoto exit;\n\n\t \n\tpattrib = &pmgntframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\tpattrib->retry_ctrl = false;\n\n\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\n\tmemcpy(pwlanhdr->addr1, da, ETH_ALEN);\n\tmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\tmemcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\n\tSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\n\tpmlmeext->mgnt_seq++;\n\tSetFrameSubType(pframe, WIFI_DEAUTH);\n\n\tpframe += sizeof(struct ieee80211_hdr_3addr);\n\tpattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);\n\n\tle_tmp = cpu_to_le16(reason);\n\tpframe = rtw_set_fixed_ie(pframe, _RSON_CODE_, (unsigned char *)&le_tmp, &(pattrib->pktlen));\n\n\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\n\tif (wait_ack) {\n\t\tret = dump_mgntframe_and_wait_ack(padapter, pmgntframe);\n\t} else {\n\t\tdump_mgntframe(padapter, pmgntframe);\n\t\tret = _SUCCESS;\n\t}\n\nexit:\n\treturn ret;\n}\n\nint issue_deauth(struct adapter *padapter, unsigned char *da, unsigned short reason)\n{\n\treturn _issue_deauth(padapter, da, reason, false);\n}\n\nint issue_deauth_ex(struct adapter *padapter, u8 *da, unsigned short reason, int try_cnt,\n\tint wait_ms)\n{\n\tint ret;\n\tint i = 0;\n\n\tdo {\n\t\tret = _issue_deauth(padapter, da, reason, wait_ms > 0);\n\n\t\ti++;\n\n\t\tif (padapter->bDriverStopped || padapter->bSurpriseRemoved)\n\t\t\tbreak;\n\n\t\tif (i < try_cnt && wait_ms > 0 && ret == _FAIL)\n\t\t\tmdelay(wait_ms);\n\n\t} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));\n\n\tif (ret != _FAIL) {\n\t\tret = _SUCCESS;\n\t\t#ifndef DBG_XMIT_ACK\n\t\tgoto exit;\n\t\t#endif\n\t}\n\nexit:\n\treturn ret;\n}\n\nvoid issue_action_SA_Query(struct adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short tid)\n{\n\tu8 category = RTW_WLAN_CATEGORY_SA_QUERY;\n\tstruct xmit_frame\t\t*pmgntframe;\n\tstruct pkt_attrib\t\t*pattrib;\n\tu8 \t\t\t*pframe;\n\tstruct ieee80211_hdr\t*pwlanhdr;\n\t__le16 *fctrl;\n\tstruct xmit_priv \t*pxmitpriv = &(padapter->xmitpriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\t__le16 le_tmp;\n\n\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\tif (!pmgntframe)\n\t\treturn;\n\n\t \n\tpattrib = &pmgntframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\n\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\n\tif (raddr)\n\t\tmemcpy(pwlanhdr->addr1, raddr, ETH_ALEN);\n\telse\n\t\tmemcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\tmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\tmemcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\n\tSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\n\tpmlmeext->mgnt_seq++;\n\tSetFrameSubType(pframe, WIFI_ACTION);\n\n\tpframe += sizeof(struct ieee80211_hdr_3addr);\n\tpattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);\n\n\tpframe = rtw_set_fixed_ie(pframe, 1, &category, &pattrib->pktlen);\n\tpframe = rtw_set_fixed_ie(pframe, 1, &action, &pattrib->pktlen);\n\n\tswitch (action) {\n\tcase 0:  \n\t\tpframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)&pmlmeext->sa_query_seq, &pattrib->pktlen);\n\t\tpmlmeext->sa_query_seq++;\n\t\t \n\t\tset_sa_query_timer(pmlmeext, 1000);\n\t\tbreak;\n\n\tcase 1:  \n\t\tle_tmp = cpu_to_le16(tid);\n\t\tpframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)&le_tmp, &pattrib->pktlen);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\tdump_mgntframe(padapter, pmgntframe);\n}\n\nvoid issue_action_BA(struct adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short status)\n{\n\tu8 category = RTW_WLAN_CATEGORY_BACK;\n\tu16 start_seq;\n\tu16 BA_para_set;\n\tu16 reason_code;\n\tu16 BA_timeout_value;\n\tu16 BA_starting_seqctrl = 0;\n\tenum ieee80211_max_ampdu_length_exp max_rx_ampdu_factor;\n\tstruct xmit_frame\t\t*pmgntframe;\n\tstruct pkt_attrib\t\t*pattrib;\n\tu8 \t\t\t*pframe;\n\tstruct ieee80211_hdr\t*pwlanhdr;\n\t__le16 *fctrl;\n\tstruct xmit_priv \t*pxmitpriv = &(padapter->xmitpriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct sta_info \t*psta;\n\tstruct sta_priv \t*pstapriv = &padapter->stapriv;\n\tstruct registry_priv \t*pregpriv = &padapter->registrypriv;\n\t__le16 le_tmp;\n\n\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\tif (!pmgntframe)\n\t\treturn;\n\n\t \n\tpattrib = &pmgntframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\n\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\n\t \n\tmemcpy(pwlanhdr->addr1, raddr, ETH_ALEN);\n\tmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\tmemcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\n\tSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\n\tpmlmeext->mgnt_seq++;\n\tSetFrameSubType(pframe, WIFI_ACTION);\n\n\tpframe += sizeof(struct ieee80211_hdr_3addr);\n\tpattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);\n\n\tpframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));\n\tpframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));\n\n\tif (category == 3) {\n\t\tswitch (action) {\n\t\tcase 0:  \n\t\t\tdo {\n\t\t\t\tpmlmeinfo->dialogToken++;\n\t\t\t} while (pmlmeinfo->dialogToken == 0);\n\t\t\tpframe = rtw_set_fixed_ie(pframe, 1, &(pmlmeinfo->dialogToken), &(pattrib->pktlen));\n\n\t\t\tif (hal_btcoex_IsBTCoexCtrlAMPDUSize(padapter)) {\n\t\t\t\t \n\t\t\t\tBA_para_set = 0;\n\t\t\t\t \n\t\t\t\tBA_para_set |= BIT(1) & IEEE80211_ADDBA_PARAM_POLICY_MASK;\n\t\t\t\t \n\t\t\t\tBA_para_set |= (status << 2) & IEEE80211_ADDBA_PARAM_TID_MASK;\n\t\t\t\t \n\t\t\t\tBA_para_set |= (8 << 6) & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK;\n\t\t\t} else {\n\t\t\t\tBA_para_set = (0x1002 | ((status & 0xf) << 2));  \n\t\t\t}\n\t\t\tle_tmp = cpu_to_le16(BA_para_set);\n\t\t\tpframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(le_tmp)), &(pattrib->pktlen));\n\n\t\t\tBA_timeout_value = 5000; \n\t\t\tle_tmp = cpu_to_le16(BA_timeout_value);\n\t\t\tpframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(le_tmp)), &(pattrib->pktlen));\n\n\t\t\t \n\t\t\tpsta = rtw_get_stainfo(pstapriv, raddr);\n\t\t\tif (psta) {\n\t\t\t\tstart_seq = (psta->sta_xmitpriv.txseq_tid[status & 0x07]&0xfff) + 1;\n\n\t\t\t\tpsta->BA_starting_seqctrl[status & 0x07] = start_seq;\n\n\t\t\t\tBA_starting_seqctrl = start_seq << 4;\n\t\t\t}\n\n\t\t\tle_tmp = cpu_to_le16(BA_starting_seqctrl);\n\t\t\tpframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(le_tmp)), &(pattrib->pktlen));\n\t\t\tbreak;\n\n\t\tcase 1:  \n\t\t\tpframe = rtw_set_fixed_ie(pframe, 1, &(pmlmeinfo->ADDBA_req.dialog_token), &(pattrib->pktlen));\n\t\t\tpframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&status), &(pattrib->pktlen));\n\t\t\tif (padapter->driver_rx_ampdu_factor != 0xFF)\n\t\t\t\tmax_rx_ampdu_factor =\n\t\t\t\t  (enum ieee80211_max_ampdu_length_exp)padapter->driver_rx_ampdu_factor;\n\t\t\telse\n\t\t\t\trtw_hal_get_def_var(padapter,\n\t\t\t\t\t\t    HW_VAR_MAX_RX_AMPDU_FACTOR, &max_rx_ampdu_factor);\n\n\t\t\tif (max_rx_ampdu_factor == IEEE80211_HT_MAX_AMPDU_64K)\n\t\t\t\tBA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000);  \n\t\t\telse if (max_rx_ampdu_factor == IEEE80211_HT_MAX_AMPDU_32K)\n\t\t\t\tBA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x0800);  \n\t\t\telse if (max_rx_ampdu_factor == IEEE80211_HT_MAX_AMPDU_16K)\n\t\t\t\tBA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x0400);  \n\t\t\telse if (max_rx_ampdu_factor == IEEE80211_HT_MAX_AMPDU_8K)\n\t\t\t\tBA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x0200);  \n\t\t\telse\n\t\t\t\tBA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000);  \n\n\t\t\tif (hal_btcoex_IsBTCoexCtrlAMPDUSize(padapter) &&\n\t\t\t    padapter->driver_rx_ampdu_factor == 0xFF) {\n\t\t\t\t \n\t\t\t\tBA_para_set &= ~IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK;\n\t\t\t\tBA_para_set |= (8 << 6) & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK;\n\t\t\t}\n\n\t\t\tif (pregpriv->ampdu_amsdu == 0) \n\t\t\t\tle_tmp = cpu_to_le16(BA_para_set & ~BIT(0));\n\t\t\telse if (pregpriv->ampdu_amsdu == 1) \n\t\t\t\tle_tmp = cpu_to_le16(BA_para_set | BIT(0));\n\t\t\telse  \n\t\t\t\tle_tmp = cpu_to_le16(BA_para_set);\n\n\t\t\tpframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(le_tmp)), &(pattrib->pktlen));\n\t\t\tpframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(pmlmeinfo->ADDBA_req.BA_timeout_value)), &(pattrib->pktlen));\n\t\t\tbreak;\n\t\tcase 2: \n\t\t\tBA_para_set = (status & 0x1F) << 3;\n\t\t\tle_tmp = cpu_to_le16(BA_para_set);\n\t\t\tpframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(le_tmp)), &(pattrib->pktlen));\n\n\t\t\treason_code = 37;\n\t\t\tle_tmp = cpu_to_le16(reason_code);\n\t\t\tpframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(le_tmp)), &(pattrib->pktlen));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\tdump_mgntframe(padapter, pmgntframe);\n}\n\nstatic void issue_action_BSSCoexistPacket(struct adapter *padapter)\n{\n\tstruct list_head\t\t*plist, *phead;\n\tunsigned char category, action;\n\tstruct xmit_frame\t\t\t*pmgntframe;\n\tstruct pkt_attrib\t\t\t*pattrib;\n\tunsigned char \t\t\t*pframe;\n\tstruct ieee80211_hdr\t*pwlanhdr;\n\t__le16 *fctrl;\n\tstruct\twlan_network\t*pnetwork = NULL;\n\tstruct xmit_priv \t\t*pxmitpriv = &(padapter->xmitpriv);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct __queue\t\t*queue\t= &(pmlmepriv->scanned_queue);\n\tu8 InfoContent[16] = {0};\n\tu8 ICS[8][15];\n\n\tif ((pmlmepriv->num_FortyMHzIntolerant == 0) || (pmlmepriv->num_sta_no_ht == 0))\n\t\treturn;\n\n\tif (true == pmlmeinfo->bwmode_updated)\n\t\treturn;\n\n\tcategory = RTW_WLAN_CATEGORY_PUBLIC;\n\taction = ACT_PUBLIC_BSSCOEXIST;\n\n\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\tif (!pmgntframe)\n\t\treturn;\n\n\t \n\tpattrib = &pmgntframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\n\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\n\tmemcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\tmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\tmemcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\n\n\tSetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);\n\tpmlmeext->mgnt_seq++;\n\tSetFrameSubType(pframe, WIFI_ACTION);\n\n\tpframe += sizeof(struct ieee80211_hdr_3addr);\n\tpattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);\n\n\tpframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));\n\tpframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));\n\n\n\t \n\tif (pmlmepriv->num_FortyMHzIntolerant > 0) {\n\t\tu8 iedata = 0;\n\n\t\tiedata |= BIT(2); \n\n\t\tpframe = rtw_set_ie(pframe, WLAN_EID_BSS_COEX_2040,  1, &iedata, &(pattrib->pktlen));\n\n\t}\n\n\n\t \n\tmemset(ICS, 0, sizeof(ICS));\n\tif (pmlmepriv->num_sta_no_ht > 0) {\n\t\tint i;\n\n\t\tspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\n\n\t\tphead = get_list_head(queue);\n\t\tplist = get_next(phead);\n\n\t\twhile (1) {\n\t\t\tint len;\n\t\t\tu8 *p;\n\t\t\tstruct wlan_bssid_ex *pbss_network;\n\n\t\t\tif (phead == plist)\n\t\t\t\tbreak;\n\n\t\t\tpnetwork = container_of(plist, struct wlan_network, list);\n\n\t\t\tplist = get_next(plist);\n\n\t\t\tpbss_network = (struct wlan_bssid_ex *)&pnetwork->network;\n\n\t\t\tp = rtw_get_ie(pbss_network->ies + _FIXED_IE_LENGTH_, WLAN_EID_HT_CAPABILITY, &len, pbss_network->ie_length - _FIXED_IE_LENGTH_);\n\t\t\tif (!p || len == 0) { \n\n\t\t\t\tif (pbss_network->configuration.ds_config <= 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tICS[0][pbss_network->configuration.ds_config] = 1;\n\n\t\t\t\tif (ICS[0][0] == 0)\n\t\t\t\t\tICS[0][0] = 1;\n\t\t\t}\n\n\t\t}\n\n\t\tspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\n\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (ICS[i][0] == 1) {\n\t\t\t\tint j, k = 0;\n\n\t\t\t\tInfoContent[k] = i;\n\t\t\t\t \n\t\t\t\tk++;\n\n\t\t\t\tfor (j = 1; j <= 14; j++) {\n\t\t\t\t\tif (ICS[i][j] == 1) {\n\t\t\t\t\t\tif (k < 16) {\n\t\t\t\t\t\t\tInfoContent[k] = j;  \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpframe = rtw_set_ie(pframe, WLAN_EID_BSS_INTOLERANT_CHL_REPORT, k, InfoContent, &(pattrib->pktlen));\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\n\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\tdump_mgntframe(padapter, pmgntframe);\n}\n\nunsigned int send_delba(struct adapter *padapter, u8 initiator, u8 *addr)\n{\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct sta_info *psta = NULL;\n\t \n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tu16 tid;\n\n\tif ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)\n\t\tif (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))\n\t\t\treturn _SUCCESS;\n\n\tpsta = rtw_get_stainfo(pstapriv, addr);\n\tif (!psta)\n\t\treturn _SUCCESS;\n\n\tif (initiator == 0) { \n\t\tfor (tid = 0; tid < MAXTID; tid++) {\n\t\t\tif (psta->recvreorder_ctrl[tid].enable) {\n\t\t\t\tissue_action_BA(padapter, addr, WLAN_ACTION_DELBA, (((tid << 1) | initiator)&0x1F));\n\t\t\t\tpsta->recvreorder_ctrl[tid].enable = false;\n\t\t\t\tpsta->recvreorder_ctrl[tid].indicate_seq = 0xffff;\n\t\t\t}\n\t\t}\n\t} else if (initiator == 1) { \n\t\tfor (tid = 0; tid < MAXTID; tid++) {\n\t\t\tif (psta->htpriv.agg_enable_bitmap & BIT(tid)) {\n\t\t\t\tissue_action_BA(padapter, addr, WLAN_ACTION_DELBA, (((tid << 1) | initiator)&0x1F));\n\t\t\t\tpsta->htpriv.agg_enable_bitmap &= ~BIT(tid);\n\t\t\t\tpsta->htpriv.candidate_tid_bitmap &= ~BIT(tid);\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn _SUCCESS;\n\n}\n\nunsigned int send_beacon(struct adapter *padapter)\n{\n\tu8 bxmitok = false;\n\tint\tissue = 0;\n\tint poll = 0;\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_BCN_VALID, NULL);\n\trtw_hal_set_hwreg(padapter, HW_VAR_DL_BCN_SEL, NULL);\n\tdo {\n\t\tissue_beacon(padapter, 100);\n\t\tissue++;\n\t\tdo {\n\t\t\tcond_resched();\n\t\t\trtw_hal_get_hwreg(padapter, HW_VAR_BCN_VALID, (u8 *)(&bxmitok));\n\t\t\tpoll++;\n\t\t} while ((poll%10) != 0 && false == bxmitok && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);\n\n\t} while (false == bxmitok && issue < 100 && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);\n\n\tif (padapter->bSurpriseRemoved || padapter->bDriverStopped)\n\t\treturn _FAIL;\n\n\tif (!bxmitok)\n\t\treturn _FAIL;\n\telse\n\t\treturn _SUCCESS;\n}\n\n \n\nvoid site_survey(struct adapter *padapter)\n{\n\tunsigned char \tsurvey_channel = 0, val8;\n\tenum rt_scan_type\tScanType = SCAN_PASSIVE;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tu32 initialgain = 0;\n\tu32 channel_scan_time_ms = 0;\n\n\t{\n\t\tstruct rtw_ieee80211_channel *ch;\n\n\t\tif (pmlmeext->sitesurvey_res.channel_idx < pmlmeext->sitesurvey_res.ch_num) {\n\t\t\tch = &pmlmeext->sitesurvey_res.ch[pmlmeext->sitesurvey_res.channel_idx];\n\t\t\tsurvey_channel = ch->hw_value;\n\t\t\tScanType = (ch->flags & RTW_IEEE80211_CHAN_PASSIVE_SCAN) ? SCAN_PASSIVE : SCAN_ACTIVE;\n\t\t}\n\t}\n\n\tif (survey_channel != 0) {\n\t\t \n\t\t \n\t\t \n\t\t \n\t\tif (pmlmeext->sitesurvey_res.channel_idx == 0) {\n#ifdef DBG_FIXED_CHAN\n\t\t\tif (pmlmeext->fixed_chan != 0xff)\n\t\t\t\tset_channel_bwmode(padapter, pmlmeext->fixed_chan, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);\n\t\t\telse\n#endif\n\t\t\t\tset_channel_bwmode(padapter, survey_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);\n\t\t} else {\n#ifdef DBG_FIXED_CHAN\n\t\t\tif (pmlmeext->fixed_chan != 0xff)\n\t\t\t\tSelectChannel(padapter, pmlmeext->fixed_chan);\n\t\t\telse\n#endif\n\t\t\t\tSelectChannel(padapter, survey_channel);\n\t\t}\n\n\t\tif (ScanType == SCAN_ACTIVE) {  \n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < RTW_SSID_SCAN_AMOUNT; i++) {\n\t\t\t\t\tif (pmlmeext->sitesurvey_res.ssid[i].ssid_length) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (padapter->registrypriv.wifi_spec)\n\t\t\t\t\t\t\tissue_probereq(padapter, &(pmlmeext->sitesurvey_res.ssid[i]), NULL);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tissue_probereq_ex(padapter, &(pmlmeext->sitesurvey_res.ssid[i]), NULL, 0, 0, 0, 0);\n\t\t\t\t\t\tissue_probereq(padapter, &(pmlmeext->sitesurvey_res.ssid[i]), NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (pmlmeext->sitesurvey_res.scan_mode == SCAN_ACTIVE) {\n\t\t\t\t\t \n\t\t\t\t\tif (padapter->registrypriv.wifi_spec)\n\t\t\t\t\t\tissue_probereq(padapter, NULL, NULL);\n\t\t\t\t\telse\n\t\t\t\t\t\tissue_probereq_ex(padapter, NULL, NULL, 0, 0, 0, 0);\n\t\t\t\t\tissue_probereq(padapter, NULL, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tchannel_scan_time_ms = pmlmeext->chan_scan_time;\n\n\t\tset_survey_timer(pmlmeext, channel_scan_time_ms);\n\t} else {\n\n\t\t \n\n\t\t{\n\t\t\tpmlmeext->sitesurvey_res.state = SCAN_COMPLETE;\n\n\t\t\t \n\t\t\t \n\n\t\t\tset_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);\n\n\t\t\t \n\t\t\t \n\t\t\t \n\n\t\t\t \n\t\t\tSet_MSR(padapter, (pmlmeinfo->state & 0x3));\n\n\t\t\tinitialgain = 0xff;  \n\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));\n\t\t\t \n\t\t\tRestore_DM_Func_Flag(padapter);\n\t\t\t \n\n\t\t\tif (is_client_associated_to_ap(padapter))\n\t\t\t\tissue_nulldata(padapter, NULL, 0, 3, 500);\n\n\t\t\tval8 = 0;  \n\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));\n\n\t\t\treport_surveydone_event(padapter);\n\n\t\t\tpmlmeext->chan_scan_time = SURVEY_TO;\n\t\t\tpmlmeext->sitesurvey_res.state = SCAN_DISABLE;\n\n\t\t\tissue_action_BSSCoexistPacket(padapter);\n\t\t\tissue_action_BSSCoexistPacket(padapter);\n\t\t\tissue_action_BSSCoexistPacket(padapter);\n\t\t}\n\t}\n\n\treturn;\n\n}\n\n \nu8 collect_bss_info(struct adapter *padapter, union recv_frame *precv_frame, struct wlan_bssid_ex *bssid)\n{\n\tint\ti;\n\tu32 len;\n\tu8 *p;\n\tu16 val16, subtype;\n\tu8 *pframe = precv_frame->u.hdr.rx_data;\n\tu32 packet_len = precv_frame->u.hdr.len;\n\tu8 ie_offset;\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\t__le32 le32_tmp;\n\n\tlen = packet_len - sizeof(struct ieee80211_hdr_3addr);\n\n\tif (len > MAX_IE_SZ)\n\t\treturn _FAIL;\n\n\tmemset(bssid, 0, sizeof(struct wlan_bssid_ex));\n\n\tsubtype = GetFrameSubType(pframe);\n\n\tif (subtype == WIFI_BEACON) {\n\t\tbssid->reserved[0] = 1;\n\t\tie_offset = _BEACON_IE_OFFSET_;\n\t} else {\n\t\t \n\t\tif (subtype == WIFI_PROBERSP) {\n\t\t\tie_offset = _PROBERSP_IE_OFFSET_;\n\t\t\tbssid->reserved[0] = 3;\n\t\t} else if (subtype == WIFI_PROBEREQ) {\n\t\t\tie_offset = _PROBEREQ_IE_OFFSET_;\n\t\t\tbssid->reserved[0] = 2;\n\t\t} else {\n\t\t\tbssid->reserved[0] = 0;\n\t\t\tie_offset = _FIXED_IE_LENGTH_;\n\t\t}\n\t}\n\n\tbssid->length = sizeof(struct wlan_bssid_ex) - MAX_IE_SZ + len;\n\n\t \n\tbssid->ie_length = len;\n\tmemcpy(bssid->ies, (pframe + sizeof(struct ieee80211_hdr_3addr)), bssid->ie_length);\n\n\t \n\tbssid->rssi = precv_frame->u.hdr.attrib.phy_info.RecvSignalPower;  \n\tbssid->phy_info.signal_quality = precv_frame->u.hdr.attrib.phy_info.SignalQuality; \n\tbssid->phy_info.signal_strength = precv_frame->u.hdr.attrib.phy_info.SignalStrength; \n\n\t \n\tp = rtw_get_ie(bssid->ies + ie_offset, WLAN_EID_SSID, &len, bssid->ie_length - ie_offset);\n\tif (!p)\n\t\treturn _FAIL;\n\n\tif (*(p + 1)) {\n\t\tif (len > NDIS_802_11_LENGTH_SSID)\n\t\t\treturn _FAIL;\n\n\t\tmemcpy(bssid->ssid.ssid, (p + 2), *(p + 1));\n\t\tbssid->ssid.ssid_length = *(p + 1);\n\t} else\n\t\tbssid->ssid.ssid_length = 0;\n\n\tmemset(bssid->supported_rates, 0, NDIS_802_11_LENGTH_RATES_EX);\n\n\t \n\ti = 0;\n\tp = rtw_get_ie(bssid->ies + ie_offset, WLAN_EID_SUPP_RATES, &len, bssid->ie_length - ie_offset);\n\tif (p) {\n\t\tif (len > NDIS_802_11_LENGTH_RATES_EX)\n\t\t\treturn _FAIL;\n\n\t\tmemcpy(bssid->supported_rates, (p + 2), len);\n\t\ti = len;\n\t}\n\n\tp = rtw_get_ie(bssid->ies + ie_offset, WLAN_EID_EXT_SUPP_RATES, &len, bssid->ie_length - ie_offset);\n\tif (p) {\n\t\tif (len > (NDIS_802_11_LENGTH_RATES_EX-i))\n\t\t\treturn _FAIL;\n\n\t\tmemcpy(bssid->supported_rates + i, (p + 2), len);\n\t}\n\n\tbssid->network_type_in_use = Ndis802_11OFDM24;\n\n\tif (bssid->ie_length < 12)\n\t\treturn _FAIL;\n\n\t \n\tp = rtw_get_ie(bssid->ies + ie_offset, WLAN_EID_DS_PARAMS, &len, bssid->ie_length - ie_offset);\n\n\tbssid->configuration.ds_config = 0;\n\tbssid->configuration.length = 0;\n\n\tif (p) {\n\t\tbssid->configuration.ds_config = *(p + 2);\n\t} else {\n\t\t \n\t\t \n\t\tp = rtw_get_ie(bssid->ies + ie_offset, WLAN_EID_HT_OPERATION, &len, bssid->ie_length - ie_offset);\n\t\tif (p) {\n\t\t\tstruct HT_info_element *HT_info = (struct HT_info_element *)(p + 2);\n\n\t\t\tbssid->configuration.ds_config = HT_info->primary_channel;\n\t\t} else {  \n\t\t\tbssid->configuration.ds_config = rtw_get_oper_ch(padapter);\n\t\t}\n\t}\n\n\tmemcpy(&le32_tmp, rtw_get_beacon_interval_from_ie(bssid->ies), 2);\n\tbssid->configuration.beacon_period = le32_to_cpu(le32_tmp);\n\n\tval16 = rtw_get_capability((struct wlan_bssid_ex *)bssid);\n\n\tif (val16 & BIT(0)) {\n\t\tbssid->infrastructure_mode = Ndis802_11Infrastructure;\n\t\tmemcpy(bssid->mac_address, GetAddr2Ptr(pframe), ETH_ALEN);\n\t} else {\n\t\tbssid->infrastructure_mode = Ndis802_11IBSS;\n\t\tmemcpy(bssid->mac_address, GetAddr3Ptr(pframe), ETH_ALEN);\n\t}\n\n\tif (val16 & BIT(4))\n\t\tbssid->privacy = 1;\n\telse\n\t\tbssid->privacy = 0;\n\n\tbssid->configuration.atim_window = 0;\n\n\t \n\tif ((pregistrypriv->wifi_spec == 1) && (false == pmlmeinfo->bwmode_updated)) {\n\t\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\t\tp = rtw_get_ie(bssid->ies + ie_offset, WLAN_EID_HT_CAPABILITY, &len, bssid->ie_length - ie_offset);\n\t\tif (p && len > 0) {\n\t\t\tstruct HT_caps_element\t*pHT_caps;\n\n\t\t\tpHT_caps = (struct HT_caps_element\t*)(p + 2);\n\n\t\t\tif (le16_to_cpu(pHT_caps->u.HT_cap_element.HT_caps_info) & BIT(14))\n\t\t\t\tpmlmepriv->num_FortyMHzIntolerant++;\n\t\t} else\n\t\t\tpmlmepriv->num_sta_no_ht++;\n\t}\n\n\t \n\tif (bssid->configuration.ds_config != rtw_get_oper_ch(padapter))\n\t\tbssid->phy_info.signal_quality = 101;\n\n\treturn _SUCCESS;\n}\n\nvoid start_create_ibss(struct adapter *padapter)\n{\n\tunsigned short\tcaps;\n\tu8 val8;\n\tu8 join_type;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex\t\t*pnetwork = (struct wlan_bssid_ex *)(&(pmlmeinfo->network));\n\n\tpmlmeext->cur_channel = (u8)pnetwork->configuration.ds_config;\n\tpmlmeinfo->bcn_interval = get_beacon_interval(pnetwork);\n\n\t \n\tupdate_wireless_mode(padapter);\n\n\t \n\tcaps = rtw_get_capability((struct wlan_bssid_ex *)pnetwork);\n\tupdate_capinfo(padapter, caps);\n\tif (caps&WLAN_CAPABILITY_IBSS) { \n\t\tval8 = 0xcf;\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_SEC_CFG, (u8 *)(&val8));\n\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_DO_IQK, NULL);\n\n\t\t \n\t\t \n\t\tset_channel_bwmode(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);\n\n\t\tbeacon_timing_control(padapter);\n\n\t\t \n\t\tpmlmeinfo->state = WIFI_FW_ADHOC_STATE;\n\t\tSet_MSR(padapter, (pmlmeinfo->state & 0x3));\n\n\t\t \n\t\tif (send_beacon(padapter) == _FAIL) {\n\t\t\treport_join_res(padapter, -1);\n\t\t\tpmlmeinfo->state = WIFI_FW_NULL_STATE;\n\t\t} else {\n\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_BSSID, padapter->registrypriv.dev_network.mac_address);\n\t\t\tjoin_type = 0;\n\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));\n\n\t\t\treport_join_res(padapter, 1);\n\t\t\tpmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;\n\t\t\trtw_indicate_connect(padapter);\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n\t \n\tupdate_bmc_sta(padapter);\n\n}\n\nvoid start_clnt_join(struct adapter *padapter)\n{\n\tunsigned short\tcaps;\n\tu8 val8;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex\t\t*pnetwork = (struct wlan_bssid_ex *)(&(pmlmeinfo->network));\n\tint beacon_timeout;\n\n\t \n\tupdate_wireless_mode(padapter);\n\n\t \n\tcaps = rtw_get_capability((struct wlan_bssid_ex *)pnetwork);\n\tupdate_capinfo(padapter, caps);\n\tif (caps&WLAN_CAPABILITY_ESS) {\n\t\tSet_MSR(padapter, WIFI_FW_STATION_STATE);\n\n\t\tval8 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_8021X) ? 0xcc : 0xcf;\n\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_SEC_CFG, (u8 *)(&val8));\n\n\t\t \n\t\t \n\t\t \n\n\t\t \n\t\t \n\t\t{\n\t\t\t\t \n\t\t\t\tissue_deauth_ex(padapter, pnetwork->mac_address, WLAN_REASON_DEAUTH_LEAVING, 1, 100);\n\t\t}\n\n\t\t \n\t\t \n\t\tbeacon_timeout = decide_wait_for_beacon_timeout(pmlmeinfo->bcn_interval);\n\t\tset_link_timer(pmlmeext, beacon_timeout);\n\t\t_set_timer(&padapter->mlmepriv.assoc_timer,\n\t\t\t(REAUTH_TO * REAUTH_LIMIT) + (REASSOC_TO*REASSOC_LIMIT) + beacon_timeout);\n\n\t\tpmlmeinfo->state = WIFI_FW_AUTH_NULL | WIFI_FW_STATION_STATE;\n\t} else if (caps&WLAN_CAPABILITY_IBSS) {  \n\t\tSet_MSR(padapter, WIFI_FW_ADHOC_STATE);\n\n\t\tval8 = 0xcf;\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_SEC_CFG, (u8 *)(&val8));\n\n\t\tbeacon_timing_control(padapter);\n\n\t\tpmlmeinfo->state = WIFI_FW_ADHOC_STATE;\n\n\t\treport_join_res(padapter, 1);\n\t} else {\n\t\treturn;\n\t}\n\n}\n\nvoid start_clnt_auth(struct adapter *padapter)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tdel_timer_sync(&pmlmeext->link_timer);\n\n\tpmlmeinfo->state &= (~WIFI_FW_AUTH_NULL);\n\tpmlmeinfo->state |= WIFI_FW_AUTH_STATE;\n\n\tpmlmeinfo->auth_seq = 1;\n\tpmlmeinfo->reauth_count = 0;\n\tpmlmeinfo->reassoc_count = 0;\n\tpmlmeinfo->link_count = 0;\n\tpmlmeext->retry = 0;\n\n\n\tnetdev_dbg(padapter->pnetdev, \"start auth\\n\");\n\tissue_auth(padapter, NULL, 0);\n\n\tset_link_timer(pmlmeext, REAUTH_TO);\n\n}\n\n\nvoid start_clnt_assoc(struct adapter *padapter)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tdel_timer_sync(&pmlmeext->link_timer);\n\n\tpmlmeinfo->state &= (~(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE));\n\tpmlmeinfo->state |= (WIFI_FW_AUTH_SUCCESS | WIFI_FW_ASSOC_STATE);\n\n\tissue_assocreq(padapter);\n\n\tset_link_timer(pmlmeext, REASSOC_TO);\n}\n\nunsigned int receive_disconnect(struct adapter *padapter, unsigned char *MacAddr, unsigned short reason)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\t \n\tif (!(!memcmp(MacAddr, get_my_bssid(&pmlmeinfo->network), ETH_ALEN)))\n\t\treturn _SUCCESS;\n\n\tif ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) {\n\t\tif (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) {\n\t\t\tpmlmeinfo->state = WIFI_FW_NULL_STATE;\n\t\t\treport_del_sta_event(padapter, MacAddr, reason);\n\n\t\t} else if (pmlmeinfo->state & WIFI_FW_LINKING_STATE) {\n\t\t\tpmlmeinfo->state = WIFI_FW_NULL_STATE;\n\t\t\treport_join_res(padapter, -2);\n\t\t}\n\t}\n\n\treturn _SUCCESS;\n}\n\nstatic void process_80211d(struct adapter *padapter, struct wlan_bssid_ex *bssid)\n{\n\tstruct registry_priv *pregistrypriv;\n\tstruct mlme_ext_priv *pmlmeext;\n\tstruct rt_channel_info *chplan_new;\n\tu8 channel;\n\tu8 i;\n\n\n\tpregistrypriv = &padapter->registrypriv;\n\tpmlmeext = &padapter->mlmeextpriv;\n\n\t \n\tif (pregistrypriv->enable80211d &&\n\t\t(!pmlmeext->update_channel_plan_by_ap_done)) {\n\t\tu8 *ie, *p;\n\t\tu32 len;\n\t\tstruct rt_channel_plan chplan_ap;\n\t\tstruct rt_channel_info chplan_sta[MAX_CHANNEL_NUM];\n\t\tu8 country[4];\n\t\tu8 fcn;  \n\t\tu8 noc;  \n\t\tu8 j, k;\n\n\t\tie = rtw_get_ie(bssid->ies + _FIXED_IE_LENGTH_, WLAN_EID_COUNTRY, &len, bssid->ie_length - _FIXED_IE_LENGTH_);\n\t\tif (!ie)\n\t\t\treturn;\n\t\tif (len < 6)\n\t\t\treturn;\n\n\t\tie += 2;\n\t\tp = ie;\n\t\tie += len;\n\n\t\tmemset(country, 0, 4);\n\t\tmemcpy(country, p, 3);\n\t\tp += 3;\n\n\t\ti = 0;\n\t\twhile ((ie - p) >= 3) {\n\t\t\tfcn = *(p++);\n\t\t\tnoc = *(p++);\n\t\t\tp++;\n\n\t\t\tfor (j = 0; j < noc; j++) {\n\t\t\t\tif (fcn <= 14)\n\t\t\t\t\tchannel = fcn + j;  \n\t\t\t\telse\n\t\t\t\t\tchannel = fcn + j*4;  \n\n\t\t\t\tchplan_ap.Channel[i++] = channel;\n\t\t\t}\n\t\t}\n\t\tchplan_ap.Len = i;\n\n\t\tmemcpy(chplan_sta, pmlmeext->channel_set, sizeof(chplan_sta));\n\n\t\tmemset(pmlmeext->channel_set, 0, sizeof(pmlmeext->channel_set));\n\t\tchplan_new = pmlmeext->channel_set;\n\n\t\ti = j = k = 0;\n\t\tif (pregistrypriv->wireless_mode & WIRELESS_11G) {\n\t\t\tdo {\n\t\t\t\tif ((i == MAX_CHANNEL_NUM) ||\n\t\t\t\t\t(chplan_sta[i].ChannelNum == 0) ||\n\t\t\t\t\t(chplan_sta[i].ChannelNum > 14))\n\t\t\t\t\tbreak;\n\n\t\t\t\tif ((j == chplan_ap.Len) || (chplan_ap.Channel[j] > 14))\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (chplan_sta[i].ChannelNum == chplan_ap.Channel[j]) {\n\t\t\t\t\tchplan_new[k].ChannelNum = chplan_ap.Channel[j];\n\t\t\t\t\tchplan_new[k].ScanType = SCAN_ACTIVE;\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tk++;\n\t\t\t\t} else if (chplan_sta[i].ChannelNum < chplan_ap.Channel[j]) {\n\t\t\t\t\tchplan_new[k].ChannelNum = chplan_sta[i].ChannelNum;\n \n\t\t\t\t\tchplan_new[k].ScanType = SCAN_PASSIVE;\n\t\t\t\t\ti++;\n\t\t\t\t\tk++;\n\t\t\t\t} else if (chplan_sta[i].ChannelNum > chplan_ap.Channel[j]) {\n\t\t\t\t\tchplan_new[k].ChannelNum = chplan_ap.Channel[j];\n\t\t\t\t\tchplan_new[k].ScanType = SCAN_ACTIVE;\n\t\t\t\t\tj++;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t} while (1);\n\n\t\t\t \n\t\t\twhile ((i < MAX_CHANNEL_NUM) &&\n\t\t\t\t(chplan_sta[i].ChannelNum != 0) &&\n\t\t\t\t(chplan_sta[i].ChannelNum <= 14)) {\n\n\t\t\t\tchplan_new[k].ChannelNum = chplan_sta[i].ChannelNum;\n \n\t\t\t\tchplan_new[k].ScanType = SCAN_PASSIVE;\n\t\t\t\ti++;\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\t \n\t\t\twhile ((j < chplan_ap.Len) && (chplan_ap.Channel[j] <= 14)) {\n\t\t\t\tchplan_new[k].ChannelNum = chplan_ap.Channel[j];\n\t\t\t\tchplan_new[k].ScanType = SCAN_ACTIVE;\n\t\t\t\tj++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\twhile ((i < MAX_CHANNEL_NUM) &&\n\t\t\t\t(chplan_sta[i].ChannelNum != 0) &&\n\t\t\t\t(chplan_sta[i].ChannelNum <= 14)) {\n\t\t\t\tchplan_new[k].ChannelNum = chplan_sta[i].ChannelNum;\n\t\t\t\tchplan_new[k].ScanType = chplan_sta[i].ScanType;\n\t\t\t\ti++;\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\t \n\t\t\twhile ((j < chplan_ap.Len) && (chplan_ap.Channel[j] <= 14))\n\t\t\t\tj++;\n\t\t}\n\n\t\tpmlmeext->update_channel_plan_by_ap_done = 1;\n\t}\n\n\t \n\tchannel = bssid->configuration.ds_config;\n\tchplan_new = pmlmeext->channel_set;\n\ti = 0;\n\twhile ((i < MAX_CHANNEL_NUM) && (chplan_new[i].ChannelNum != 0)) {\n\t\tif (chplan_new[i].ChannelNum == channel) {\n\t\t\tif (chplan_new[i].ScanType == SCAN_PASSIVE)\n\t\t\t\tchplan_new[i].ScanType = SCAN_ACTIVE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n}\n\n \n\nvoid report_survey_event(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tstruct cmd_obj *pcmd_obj;\n\tu8 *pevtcmd;\n\tu32 cmdsz;\n\tstruct survey_event\t*psurvey_evt;\n\tstruct C2HEvent_Header *pc2h_evt_hdr;\n\tstruct mlme_ext_priv *pmlmeext;\n\tstruct cmd_priv *pcmdpriv;\n\t \n\t \n\n\tif (!padapter)\n\t\treturn;\n\n\tpmlmeext = &padapter->mlmeextpriv;\n\tpcmdpriv = &padapter->cmdpriv;\n\n\tpcmd_obj = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!pcmd_obj)\n\t\treturn;\n\n\tcmdsz = (sizeof(struct survey_event) + sizeof(struct C2HEvent_Header));\n\tpevtcmd = rtw_zmalloc(cmdsz);\n\tif (!pevtcmd) {\n\t\tkfree(pcmd_obj);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&pcmd_obj->list);\n\n\tpcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);\n\tpcmd_obj->cmdsz = cmdsz;\n\tpcmd_obj->parmbuf = pevtcmd;\n\n\tpcmd_obj->rsp = NULL;\n\tpcmd_obj->rspsz  = 0;\n\n\tpc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);\n\tpc2h_evt_hdr->len = sizeof(struct survey_event);\n\tpc2h_evt_hdr->ID = GEN_EVT_CODE(_Survey);\n\tpc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);\n\n\tpsurvey_evt = (struct survey_event *)(pevtcmd + sizeof(struct C2HEvent_Header));\n\n\tif (collect_bss_info(padapter, precv_frame, (struct wlan_bssid_ex *)&psurvey_evt->bss) == _FAIL) {\n\t\tkfree(pcmd_obj);\n\t\tkfree(pevtcmd);\n\t\treturn;\n\t}\n\n\tprocess_80211d(padapter, &psurvey_evt->bss);\n\n\trtw_enqueue_cmd(pcmdpriv, pcmd_obj);\n\n\tpmlmeext->sitesurvey_res.bss_cnt++;\n\n\treturn;\n\n}\n\nvoid report_surveydone_event(struct adapter *padapter)\n{\n\tstruct cmd_obj *pcmd_obj;\n\tu8 *pevtcmd;\n\tu32 cmdsz;\n\tstruct surveydone_event *psurveydone_evt;\n\tstruct C2HEvent_Header\t*pc2h_evt_hdr;\n\tstruct mlme_ext_priv \t*pmlmeext = &padapter->mlmeextpriv;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\n\tpcmd_obj = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!pcmd_obj)\n\t\treturn;\n\n\tcmdsz = (sizeof(struct surveydone_event) + sizeof(struct C2HEvent_Header));\n\tpevtcmd = rtw_zmalloc(cmdsz);\n\tif (!pevtcmd) {\n\t\tkfree(pcmd_obj);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&pcmd_obj->list);\n\n\tpcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);\n\tpcmd_obj->cmdsz = cmdsz;\n\tpcmd_obj->parmbuf = pevtcmd;\n\n\tpcmd_obj->rsp = NULL;\n\tpcmd_obj->rspsz  = 0;\n\n\tpc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);\n\tpc2h_evt_hdr->len = sizeof(struct surveydone_event);\n\tpc2h_evt_hdr->ID = GEN_EVT_CODE(_SurveyDone);\n\tpc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);\n\n\tpsurveydone_evt = (struct surveydone_event *)(pevtcmd + sizeof(struct C2HEvent_Header));\n\tpsurveydone_evt->bss_cnt = pmlmeext->sitesurvey_res.bss_cnt;\n\n\trtw_enqueue_cmd(pcmdpriv, pcmd_obj);\n\n\treturn;\n\n}\n\nvoid report_join_res(struct adapter *padapter, int res)\n{\n\tstruct cmd_obj *pcmd_obj;\n\tu8 *pevtcmd;\n\tu32 cmdsz;\n\tstruct joinbss_event\t\t*pjoinbss_evt;\n\tstruct C2HEvent_Header\t*pc2h_evt_hdr;\n\tstruct mlme_ext_priv \t*pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\n\tpcmd_obj = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!pcmd_obj)\n\t\treturn;\n\n\tcmdsz = (sizeof(struct joinbss_event) + sizeof(struct C2HEvent_Header));\n\tpevtcmd = rtw_zmalloc(cmdsz);\n\tif (!pevtcmd) {\n\t\tkfree(pcmd_obj);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&pcmd_obj->list);\n\n\tpcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);\n\tpcmd_obj->cmdsz = cmdsz;\n\tpcmd_obj->parmbuf = pevtcmd;\n\n\tpcmd_obj->rsp = NULL;\n\tpcmd_obj->rspsz  = 0;\n\n\tpc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);\n\tpc2h_evt_hdr->len = sizeof(struct joinbss_event);\n\tpc2h_evt_hdr->ID = GEN_EVT_CODE(_JoinBss);\n\tpc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);\n\n\tpjoinbss_evt = (struct joinbss_event *)(pevtcmd + sizeof(struct C2HEvent_Header));\n\tmemcpy((unsigned char *)(&(pjoinbss_evt->network.network)), &(pmlmeinfo->network), sizeof(struct wlan_bssid_ex));\n\tpjoinbss_evt->network.join_res\t= pjoinbss_evt->network.aid = res;\n\n\n\trtw_joinbss_event_prehandle(padapter, (u8 *)&pjoinbss_evt->network);\n\n\n\trtw_enqueue_cmd(pcmdpriv, pcmd_obj);\n\n\treturn;\n\n}\n\nvoid report_wmm_edca_update(struct adapter *padapter)\n{\n\tstruct cmd_obj *pcmd_obj;\n\tu8 *pevtcmd;\n\tu32 cmdsz;\n\tstruct wmm_event\t\t*pwmm_event;\n\tstruct C2HEvent_Header\t*pc2h_evt_hdr;\n\tstruct mlme_ext_priv \t*pmlmeext = &padapter->mlmeextpriv;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\n\tpcmd_obj = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!pcmd_obj)\n\t\treturn;\n\n\tcmdsz = (sizeof(struct wmm_event) + sizeof(struct C2HEvent_Header));\n\tpevtcmd = rtw_zmalloc(cmdsz);\n\tif (!pevtcmd) {\n\t\tkfree(pcmd_obj);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&pcmd_obj->list);\n\n\tpcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);\n\tpcmd_obj->cmdsz = cmdsz;\n\tpcmd_obj->parmbuf = pevtcmd;\n\n\tpcmd_obj->rsp = NULL;\n\tpcmd_obj->rspsz  = 0;\n\n\tpc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);\n\tpc2h_evt_hdr->len = sizeof(struct wmm_event);\n\tpc2h_evt_hdr->ID = GEN_EVT_CODE(_WMM);\n\tpc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);\n\n\tpwmm_event = (struct wmm_event *)(pevtcmd + sizeof(struct C2HEvent_Header));\n\tpwmm_event->wmm = 0;\n\n\trtw_enqueue_cmd(pcmdpriv, pcmd_obj);\n\n\treturn;\n\n}\n\nvoid report_del_sta_event(struct adapter *padapter, unsigned char *MacAddr, unsigned short reason)\n{\n\tstruct cmd_obj *pcmd_obj;\n\tu8 *pevtcmd;\n\tu32 cmdsz;\n\tstruct sta_info *psta;\n\tint\tmac_id;\n\tstruct stadel_event\t\t\t*pdel_sta_evt;\n\tstruct C2HEvent_Header\t*pc2h_evt_hdr;\n\tstruct mlme_ext_priv \t*pmlmeext = &padapter->mlmeextpriv;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\n\tpcmd_obj = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!pcmd_obj)\n\t\treturn;\n\n\tcmdsz = (sizeof(struct stadel_event) + sizeof(struct C2HEvent_Header));\n\tpevtcmd = rtw_zmalloc(cmdsz);\n\tif (!pevtcmd) {\n\t\tkfree(pcmd_obj);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&pcmd_obj->list);\n\n\tpcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);\n\tpcmd_obj->cmdsz = cmdsz;\n\tpcmd_obj->parmbuf = pevtcmd;\n\n\tpcmd_obj->rsp = NULL;\n\tpcmd_obj->rspsz  = 0;\n\n\tpc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);\n\tpc2h_evt_hdr->len = sizeof(struct stadel_event);\n\tpc2h_evt_hdr->ID = GEN_EVT_CODE(_DelSTA);\n\tpc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);\n\n\tpdel_sta_evt = (struct stadel_event *)(pevtcmd + sizeof(struct C2HEvent_Header));\n\tmemcpy((unsigned char *)(&(pdel_sta_evt->macaddr)), MacAddr, ETH_ALEN);\n\tmemcpy((unsigned char *)(pdel_sta_evt->rsvd), (unsigned char *)(&reason), 2);\n\n\n\tpsta = rtw_get_stainfo(&padapter->stapriv, MacAddr);\n\tif (psta)\n\t\tmac_id = (int)psta->mac_id;\n\telse\n\t\tmac_id = (-1);\n\n\tpdel_sta_evt->mac_id = mac_id;\n\n\trtw_enqueue_cmd(pcmdpriv, pcmd_obj);\n}\n\nvoid report_add_sta_event(struct adapter *padapter, unsigned char *MacAddr, int cam_idx)\n{\n\tstruct cmd_obj *pcmd_obj;\n\tu8 *pevtcmd;\n\tu32 cmdsz;\n\tstruct stassoc_event\t\t*padd_sta_evt;\n\tstruct C2HEvent_Header\t*pc2h_evt_hdr;\n\tstruct mlme_ext_priv \t*pmlmeext = &padapter->mlmeextpriv;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\n\tpcmd_obj = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!pcmd_obj)\n\t\treturn;\n\n\tcmdsz = (sizeof(struct stassoc_event) + sizeof(struct C2HEvent_Header));\n\tpevtcmd = rtw_zmalloc(cmdsz);\n\tif (!pevtcmd) {\n\t\tkfree(pcmd_obj);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&pcmd_obj->list);\n\n\tpcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);\n\tpcmd_obj->cmdsz = cmdsz;\n\tpcmd_obj->parmbuf = pevtcmd;\n\n\tpcmd_obj->rsp = NULL;\n\tpcmd_obj->rspsz  = 0;\n\n\tpc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);\n\tpc2h_evt_hdr->len = sizeof(struct stassoc_event);\n\tpc2h_evt_hdr->ID = GEN_EVT_CODE(_AddSTA);\n\tpc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);\n\n\tpadd_sta_evt = (struct stassoc_event *)(pevtcmd + sizeof(struct C2HEvent_Header));\n\tmemcpy((unsigned char *)(&(padd_sta_evt->macaddr)), MacAddr, ETH_ALEN);\n\tpadd_sta_evt->cam_id = cam_idx;\n\n\trtw_enqueue_cmd(pcmdpriv, pcmd_obj);\n}\n\n \n\n \nvoid update_sta_info(struct adapter *padapter, struct sta_info *psta)\n{\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\t \n\tVCS_update(padapter, psta);\n\n\t \n\tif (pmlmepriv->htpriv.ht_option) {\n\t\tpsta->htpriv.ht_option = true;\n\n\t\tpsta->htpriv.ampdu_enable = pmlmepriv->htpriv.ampdu_enable;\n\n\t\tpsta->htpriv.rx_ampdu_min_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para&IEEE80211_HT_CAP_AMPDU_DENSITY)>>2;\n\n\t\tif (support_short_GI(padapter, &(pmlmeinfo->HT_caps), CHANNEL_WIDTH_20))\n\t\t\tpsta->htpriv.sgi_20m = true;\n\n\t\tif (support_short_GI(padapter, &(pmlmeinfo->HT_caps), CHANNEL_WIDTH_40))\n\t\t\tpsta->htpriv.sgi_40m = true;\n\n\t\tpsta->qos_option = true;\n\n\t\tpsta->htpriv.ldpc_cap = pmlmepriv->htpriv.ldpc_cap;\n\t\tpsta->htpriv.stbc_cap = pmlmepriv->htpriv.stbc_cap;\n\t\tpsta->htpriv.beamform_cap = pmlmepriv->htpriv.beamform_cap;\n\n\t\tmemcpy(&psta->htpriv.ht_cap, &pmlmeinfo->HT_caps, sizeof(struct ieee80211_ht_cap));\n\t} else {\n\t\tpsta->htpriv.ht_option = false;\n\n\t\tpsta->htpriv.ampdu_enable = false;\n\n\t\tpsta->htpriv.sgi_20m = false;\n\t\tpsta->htpriv.sgi_40m = false;\n\t\tpsta->qos_option = false;\n\n\t}\n\n\tpsta->htpriv.ch_offset = pmlmeext->cur_ch_offset;\n\n\tpsta->htpriv.agg_enable_bitmap = 0x0; \n\tpsta->htpriv.candidate_tid_bitmap = 0x0; \n\n\tpsta->bw_mode = pmlmeext->cur_bwmode;\n\n\t \n\tif (pmlmepriv->qospriv.qos_option)\n\t\tpsta->qos_option = true;\n\n\tupdate_ldpc_stbc_cap(psta);\n\n\tspin_lock_bh(&psta->lock);\n\tpsta->state = _FW_LINKED;\n\tspin_unlock_bh(&psta->lock);\n\n}\n\nstatic void rtw_mlmeext_disconnect(struct adapter *padapter)\n{\n\tstruct mlme_priv \t*pmlmepriv = &padapter->mlmepriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex\t\t*pnetwork = (struct wlan_bssid_ex *)(&(pmlmeinfo->network));\n\n\t \n\n\t \n\t \n\t{\n\t\tstruct sta_info *psta;\n\n\t\tpsta = rtw_get_stainfo(&padapter->stapriv, get_my_bssid(pnetwork));\n\t\tif (psta)\n\t\t\trtw_hal_macid_wakeup(padapter, psta->mac_id);\n\t}\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_MLME_DISCONNECT, NULL);\n\trtw_hal_set_hwreg(padapter, HW_VAR_BSSID, null_addr);\n\n\t \n\tSet_MSR(padapter, _HW_STATE_STATION_);\n\n\tpmlmeinfo->state = WIFI_FW_NULL_STATE;\n\n\t \n\tpmlmeext->cur_bwmode = CHANNEL_WIDTH_20;\n\tpmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\n\tset_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);\n\n\tflush_all_cam_entry(padapter);\n\n\tdel_timer_sync(&pmlmeext->link_timer);\n\n\t \n\tpmlmepriv->LinkDetectInfo.TrafficTransitionCount = 0;\n\tpmlmepriv->LinkDetectInfo.LowPowerTransitionCount = 0;\n\n}\n\nvoid mlmeext_joinbss_event_callback(struct adapter *padapter, int join_res)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex\t\t*cur_network = &(pmlmeinfo->network);\n\tstruct sta_priv \t*pstapriv = &padapter->stapriv;\n\tu8 join_type;\n\tstruct sta_info *psta;\n\n\tif (join_res < 0) {\n\t\tjoin_type = 1;\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_BSSID, null_addr);\n\n\t\treturn;\n\t}\n\n\tif ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)\n\t\t \n\t\tupdate_bmc_sta(padapter);\n\n\n\t \n\tSwitch_DM_Func(padapter, DYNAMIC_ALL_FUNC_ENABLE, true);\n\n\t \n\tupdate_IOT_info(padapter);\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_BASIC_RATE, cur_network->supported_rates);\n\n\t \n\trtw_hal_set_hwreg(padapter, HW_VAR_BEACON_INTERVAL, (u8 *)(&pmlmeinfo->bcn_interval));\n\n\t \n\tupdate_capinfo(padapter, pmlmeinfo->capability);\n\n\t \n\tWMMOnAssocRsp(padapter);\n\n\t \n\tHTOnAssocRsp(padapter);\n\n\t \n\tset_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);\n\n\tpsta = rtw_get_stainfo(pstapriv, cur_network->mac_address);\n\tif (psta) {  \n\n\t\tpmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;\n\n\t\tpsta->wireless_mode = pmlmeext->cur_wireless_mode;\n\n\t\t \n\t\tset_sta_rate(padapter, psta);\n\n\t\trtw_sta_media_status_rpt(padapter, psta, 1);\n\n\t\t \n\t\trtw_hal_macid_wakeup(padapter, psta->mac_id);\n\t}\n\n\tjoin_type = 2;\n\trtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));\n\n\tif ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) {\n\t\t \n\t\tcorrect_TSF(padapter, pmlmeext);\n\n\t\t \n\t}\n\n\tif (get_iface_type(padapter) == IFACE_PORT0)\n\t\trtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_CONNECT, 0);\n}\n\n \nvoid mlmeext_sta_add_event_callback(struct adapter *padapter, struct sta_info *psta)\n{\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tu8 join_type;\n\n\tif ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {\n\t\tif (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) {  \n\n\t\t\t \n\t\t} else {  \n\t\t\t \n\t\t\t \n\n\t\t\t \n\t\t\tcorrect_TSF(padapter, pmlmeext);\n\n\t\t\t \n\t\t\tif (send_beacon(padapter) == _FAIL) {\n\t\t\t\tpmlmeinfo->FW_sta_info[psta->mac_id].status = 0;\n\n\t\t\t\tpmlmeinfo->state ^= WIFI_FW_ADHOC_STATE;\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;\n\n\t\t}\n\n\t\tjoin_type = 2;\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));\n\t}\n\n\tpmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;\n\n\tpsta->bssratelen = rtw_get_rateset_len(pmlmeinfo->FW_sta_info[psta->mac_id].SupportedRates);\n\tmemcpy(psta->bssrateset, pmlmeinfo->FW_sta_info[psta->mac_id].SupportedRates, psta->bssratelen);\n\n\t \n\tupdate_sta_info(padapter, psta);\n\n\trtw_hal_update_sta_rate_mask(padapter, psta);\n\n\t \n\tpsta->wireless_mode = rtw_check_network_type(psta->bssrateset, psta->bssratelen, pmlmeext->cur_channel);\n\tpsta->raid = networktype_to_raid_ex(padapter, psta);\n\n\t \n\tUpdate_RA_Entry(padapter, psta);\n}\n\nvoid mlmeext_sta_del_event_callback(struct adapter *padapter)\n{\n\tif (is_client_associated_to_ap(padapter) || is_IBSS_empty(padapter))\n\t\trtw_mlmeext_disconnect(padapter);\n}\n\n \nvoid _linked_info_dump(struct adapter *padapter)\n{\n\tint i;\n\tstruct mlme_ext_priv    *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info    *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tint UndecoratedSmoothedPWDB;\n\tstruct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);\n\n\tif (padapter->bLinkInfoDump) {\n\n\t\tif ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)\n\t\t\trtw_hal_get_def_var(padapter, HAL_DEF_UNDERCORATEDSMOOTHEDPWDB, &UndecoratedSmoothedPWDB);\n\n\t\tfor (i = 0; i < NUM_STA; i++) {\n\t\t\tif (pdvobj->macid[i]) {\n\t\t\t\tif (i != 1)  \n\t\t\t\t\t \n\t\t\t\t\trtw_hal_get_def_var(padapter, HW_DEF_RA_INFO_DUMP, &i);\n\t\t\t}\n\t\t}\n\t\trtw_hal_set_def_var(padapter, HAL_DEF_DBG_RX_INFO_DUMP, NULL);\n\t}\n}\n\nstatic u8 chk_ap_is_alive(struct adapter *padapter, struct sta_info *psta)\n{\n\tu8 ret = false;\n\n\tif ((sta_rx_data_pkts(psta) == sta_last_rx_data_pkts(psta))\n\t\t&& sta_rx_beacon_pkts(psta) == sta_last_rx_beacon_pkts(psta)\n\t\t&& sta_rx_probersp_pkts(psta) == sta_last_rx_probersp_pkts(psta)\n\t) {\n\t\tret = false;\n\t} else {\n\t\tret = true;\n\t}\n\n\tsta_update_last_rx_pkts(psta);\n\n\treturn ret;\n}\n\nvoid linked_status_chk(struct adapter *padapter)\n{\n\tu32 i;\n\tstruct sta_info \t*psta;\n\tstruct xmit_priv \t*pxmitpriv = &(padapter->xmitpriv);\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct sta_priv \t*pstapriv = &padapter->stapriv;\n\n\n\tif (is_client_associated_to_ap(padapter)) {\n\t\t \n\n\t\tint tx_chk = _SUCCESS, rx_chk = _SUCCESS;\n\t\tint rx_chk_limit;\n\t\tint link_count_limit;\n\n\t\t#if defined(DBG_ROAMING_TEST)\n\t\trx_chk_limit = 1;\n\t\t#else\n\t\trx_chk_limit = 8;\n\t\t#endif\n\t\tlink_count_limit = 7;  \n\n\t\t \n\t\t \n\t\t \n\t\tpsta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.mac_address);\n\t\tif (psta) {\n\t\t\tif (chk_ap_is_alive(padapter, psta) == false)\n\t\t\t\trx_chk = _FAIL;\n\n\t\t\tif (pxmitpriv->last_tx_pkts == pxmitpriv->tx_pkts)\n\t\t\t\ttx_chk = _FAIL;\n\n\t\t\t{\n\t\t\t\tif (rx_chk != _SUCCESS) {\n\t\t\t\t\tif (pmlmeext->retry == 0) {\n\t\t\t\t\t\tissue_probereq_ex(padapter, &pmlmeinfo->network.ssid, pmlmeinfo->network.mac_address, 0, 0, 0, 0);\n\t\t\t\t\t\tissue_probereq_ex(padapter, &pmlmeinfo->network.ssid, pmlmeinfo->network.mac_address, 0, 0, 0, 0);\n\t\t\t\t\t\tissue_probereq_ex(padapter, &pmlmeinfo->network.ssid, pmlmeinfo->network.mac_address, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (tx_chk != _SUCCESS &&\n\t\t\t\t    pmlmeinfo->link_count++ == link_count_limit)\n\t\t\t\t\ttx_chk = issue_nulldata_in_interrupt(padapter, NULL);\n\t\t\t}\n\n\t\t\tif (rx_chk == _FAIL) {\n\t\t\t\tpmlmeext->retry++;\n\t\t\t\tif (pmlmeext->retry > rx_chk_limit) {\n\t\t\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t\t\t   FUNC_ADPT_FMT \" disconnect or roaming\\n\",\n\t\t\t\t\t\t   FUNC_ADPT_ARG(padapter));\n\t\t\t\t\treceive_disconnect(padapter, pmlmeinfo->network.mac_address\n\t\t\t\t\t\t, WLAN_REASON_EXPIRATION_CHK);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpmlmeext->retry = 0;\n\t\t\t}\n\n\t\t\tif (tx_chk == _FAIL) {\n\t\t\t\tpmlmeinfo->link_count %= (link_count_limit+1);\n\t\t\t} else {\n\t\t\t\tpxmitpriv->last_tx_pkts = pxmitpriv->tx_pkts;\n\t\t\t\tpmlmeinfo->link_count = 0;\n\t\t\t}\n\n\t\t}  \n\t} else if (is_client_associated_to_ibss(padapter)) {\n\t\t \n\t\t \n\t\tfor (i = IBSS_START_MAC_ID; i < NUM_STA; i++) {\n\t\t\tif (pmlmeinfo->FW_sta_info[i].status == 1) {\n\t\t\t\tpsta = pmlmeinfo->FW_sta_info[i].psta;\n\n\t\t\t\tif (psta == NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (pmlmeinfo->FW_sta_info[i].rx_pkt == sta_rx_pkts(psta)) {\n\n\t\t\t\t\tif (pmlmeinfo->FW_sta_info[i].retry < 3) {\n\t\t\t\t\t\tpmlmeinfo->FW_sta_info[i].retry++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpmlmeinfo->FW_sta_info[i].retry = 0;\n\t\t\t\t\t\tpmlmeinfo->FW_sta_info[i].status = 0;\n\t\t\t\t\t\treport_del_sta_event(padapter, psta->hwaddr\n\t\t\t\t\t\t\t, 65535 \n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpmlmeinfo->FW_sta_info[i].retry = 0;\n\t\t\t\t\tpmlmeinfo->FW_sta_info[i].rx_pkt = (u32)sta_rx_pkts(psta);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t}\n\n}\n\nvoid survey_timer_hdl(struct timer_list *t)\n{\n\tstruct adapter *padapter =\n\t\tfrom_timer(padapter, t, mlmeextpriv.survey_timer);\n\tstruct cmd_obj\t*ph2c;\n\tstruct sitesurvey_parm\t*psurveyPara;\n\tstruct cmd_priv \t\t\t\t*pcmdpriv = &padapter->cmdpriv;\n\tstruct mlme_ext_priv \t*pmlmeext = &padapter->mlmeextpriv;\n\n\t \n\tif (pmlmeext->sitesurvey_res.state > SCAN_START) {\n\t\tif (pmlmeext->sitesurvey_res.state ==  SCAN_PROCESS)\n\t\t\tpmlmeext->sitesurvey_res.channel_idx++;\n\n\t\tif (pmlmeext->scan_abort) {\n\t\t\tpmlmeext->sitesurvey_res.channel_idx = pmlmeext->sitesurvey_res.ch_num;\n\n\t\t\tpmlmeext->scan_abort = false; \n\t\t}\n\n\t\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\t\tif (!ph2c)\n\t\t\treturn;\n\n\t\tpsurveyPara = rtw_zmalloc(sizeof(struct sitesurvey_parm));\n\t\tif (!psurveyPara) {\n\t\t\tkfree(ph2c);\n\t\t\treturn;\n\t\t}\n\n\t\tinit_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara, GEN_CMD_CODE(_SiteSurvey));\n\t\trtw_enqueue_cmd(pcmdpriv, ph2c);\n\t}\n}\n\nvoid link_timer_hdl(struct timer_list *t)\n{\n\tstruct adapter *padapter =\n\t\tfrom_timer(padapter, t, mlmeextpriv.link_timer);\n\t \n\t \n\t \n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\t \n\n\n\tif (pmlmeinfo->state & WIFI_FW_AUTH_NULL) {\n\t\tpmlmeinfo->state = WIFI_FW_NULL_STATE;\n\t\treport_join_res(padapter, -3);\n\t} else if (pmlmeinfo->state & WIFI_FW_AUTH_STATE) {\n\t\t \n\t\tif (++pmlmeinfo->reauth_count > REAUTH_LIMIT) {\n\t\t\tpmlmeinfo->state = 0;\n\t\t\treport_join_res(padapter, -1);\n\t\t\treturn;\n\t\t}\n\n\t\tpmlmeinfo->auth_seq = 1;\n\t\tissue_auth(padapter, NULL, 0);\n\t\tset_link_timer(pmlmeext, REAUTH_TO);\n\t} else if (pmlmeinfo->state & WIFI_FW_ASSOC_STATE) {\n\t\t \n\t\tif (++pmlmeinfo->reassoc_count > REASSOC_LIMIT) {\n\t\t\tpmlmeinfo->state = WIFI_FW_NULL_STATE;\n\t\t\treport_join_res(padapter, -2);\n\t\t\treturn;\n\t\t}\n\n\t\tissue_assocreq(padapter);\n\t\tset_link_timer(pmlmeext, REASSOC_TO);\n\t}\n}\n\nvoid addba_timer_hdl(struct timer_list *t)\n{\n\tstruct sta_info *psta = from_timer(psta, t, addba_retry_timer);\n\tstruct ht_priv *phtpriv;\n\n\tif (!psta)\n\t\treturn;\n\n\tphtpriv = &psta->htpriv;\n\n\tif (phtpriv->ht_option && phtpriv->ampdu_enable) {\n\t\tif (phtpriv->candidate_tid_bitmap)\n\t\t\tphtpriv->candidate_tid_bitmap = 0x0;\n\n\t}\n}\n\nvoid sa_query_timer_hdl(struct timer_list *t)\n{\n\tstruct adapter *padapter =\n\t\tfrom_timer(padapter, t, mlmeextpriv.sa_query_timer);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\t \n\tspin_lock_bh(&pmlmepriv->lock);\n\n\tif (check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\trtw_disassoc_cmd(padapter, 0, true);\n\t\trtw_indicate_disconnect(padapter);\n\t\trtw_free_assoc_resources(padapter, 1);\n\t}\n\n\tspin_unlock_bh(&pmlmepriv->lock);\n}\n\nu8 NULL_hdl(struct adapter *padapter, u8 *pbuf)\n{\n\treturn H2C_SUCCESS;\n}\n\nu8 setopmode_hdl(struct adapter *padapter, u8 *pbuf)\n{\n\tu8 type;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct setopmode_parm *psetop = (struct setopmode_parm *)pbuf;\n\n\tif (psetop->mode == Ndis802_11APMode) {\n\t\tpmlmeinfo->state = WIFI_FW_AP_STATE;\n\t\ttype = _HW_STATE_AP_;\n\t\t \n\t} else if (psetop->mode == Ndis802_11Infrastructure) {\n\t\tpmlmeinfo->state &= ~(BIT(0)|BIT(1)); \n\t\tpmlmeinfo->state |= WIFI_FW_STATION_STATE; \n\t\ttype = _HW_STATE_STATION_;\n\t} else if (psetop->mode == Ndis802_11IBSS) {\n\t\ttype = _HW_STATE_ADHOC_;\n\t} else {\n\t\ttype = _HW_STATE_NOLINK_;\n\t}\n\n\trtw_hal_set_hwreg(padapter, HW_VAR_SET_OPMODE, (u8 *)(&type));\n\t \n\n\tif (psetop->mode == Ndis802_11APMode) {\n\t\t \n\t\t \n\t\trtw_btcoex_MediaStatusNotify(padapter, 1);  \n\t}\n\n\treturn H2C_SUCCESS;\n\n}\n\nu8 createbss_hdl(struct adapter *padapter, u8 *pbuf)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex\t*pnetwork = (struct wlan_bssid_ex *)(&(pmlmeinfo->network));\n\tstruct joinbss_parm *pparm = (struct joinbss_parm *)pbuf;\n\t \n\n\tif (pmlmeinfo->state == WIFI_FW_AP_STATE) {\n\t\tstart_bss_network(padapter);\n\t\treturn H2C_SUCCESS;\n\t}\n\n\t \n\tif (pparm->network.infrastructure_mode == Ndis802_11IBSS) {\n\t\trtw_joinbss_reset(padapter);\n\n\t\tpmlmeext->cur_bwmode = CHANNEL_WIDTH_20;\n\t\tpmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\t\tpmlmeinfo->ERP_enable = 0;\n\t\tpmlmeinfo->WMM_enable = 0;\n\t\tpmlmeinfo->HT_enable = 0;\n\t\tpmlmeinfo->HT_caps_enable = 0;\n\t\tpmlmeinfo->HT_info_enable = 0;\n\t\tpmlmeinfo->agg_enable_bitmap = 0;\n\t\tpmlmeinfo->candidate_tid_bitmap = 0;\n\n\t\t \n\t\tSave_DM_Func_Flag(padapter);\n\t\tSwitch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, false);\n\n\t\t \n\t\t \n\t\t \n\n\t\t \n\t\tdel_timer_sync(&pmlmeext->link_timer);\n\n\t\t \n\t\tflush_all_cam_entry(padapter);\n\n\t\tmemcpy(pnetwork, pbuf, FIELD_OFFSET(struct wlan_bssid_ex, ie_length));\n\t\tpnetwork->ie_length = ((struct wlan_bssid_ex *)pbuf)->ie_length;\n\n\t\tif (pnetwork->ie_length > MAX_IE_SZ) \n\t\t\treturn H2C_PARAMETERS_ERROR;\n\n\t\tmemcpy(pnetwork->ies, ((struct wlan_bssid_ex *)pbuf)->ies, pnetwork->ie_length);\n\n\t\tstart_create_ibss(padapter);\n\n\t}\n\n\treturn H2C_SUCCESS;\n\n}\n\nu8 join_cmd_hdl(struct adapter *padapter, u8 *pbuf)\n{\n\tu8 join_type;\n\tstruct ndis_80211_var_ie *pIE;\n\tstruct registry_priv *pregpriv = &padapter->registrypriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex\t\t*pnetwork = (struct wlan_bssid_ex *)(&(pmlmeinfo->network));\n\tu32 i;\n\tu8 cbw40_enable = 0;\n\t \n\t \n\tu8 ch, bw, offset;\n\n\t \n\tif (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) {\n\t\tif (pmlmeinfo->state & WIFI_FW_STATION_STATE)\n\t\t\tissue_deauth_ex(padapter, pnetwork->mac_address, WLAN_REASON_DEAUTH_LEAVING, 1, 100);\n\t\tpmlmeinfo->state = WIFI_FW_NULL_STATE;\n\n\t\t \n\t\tflush_all_cam_entry(padapter);\n\n\t\tdel_timer_sync(&pmlmeext->link_timer);\n\n\t\t \n\t\t \n\t\tSet_MSR(padapter, _HW_STATE_STATION_);\n\n\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_MLME_DISCONNECT, NULL);\n\t}\n\n\trtw_joinbss_reset(padapter);\n\n\tpmlmeext->cur_bwmode = CHANNEL_WIDTH_20;\n\tpmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\tpmlmeinfo->ERP_enable = 0;\n\tpmlmeinfo->WMM_enable = 0;\n\tpmlmeinfo->HT_enable = 0;\n\tpmlmeinfo->HT_caps_enable = 0;\n\tpmlmeinfo->HT_info_enable = 0;\n\tpmlmeinfo->agg_enable_bitmap = 0;\n\tpmlmeinfo->candidate_tid_bitmap = 0;\n\tpmlmeinfo->bwmode_updated = false;\n\t \n\tpmlmeinfo->VHT_enable = 0;\n\n\tmemcpy(pnetwork, pbuf, FIELD_OFFSET(struct wlan_bssid_ex, ie_length));\n\tpnetwork->ie_length = ((struct wlan_bssid_ex *)pbuf)->ie_length;\n\n\tif (pnetwork->ie_length > MAX_IE_SZ) \n\t\treturn H2C_PARAMETERS_ERROR;\n\n\tmemcpy(pnetwork->ies, ((struct wlan_bssid_ex *)pbuf)->ies, pnetwork->ie_length);\n\n\tpmlmeext->cur_channel = (u8)pnetwork->configuration.ds_config;\n\tpmlmeinfo->bcn_interval = get_beacon_interval(pnetwork);\n\n\t \n\t \n\n\t \n\tfor (i = _FIXED_IE_LENGTH_; i < pnetwork->ie_length;) {\n\t\tpIE = (struct ndis_80211_var_ie *)(pnetwork->ies + i);\n\n\t\tswitch (pIE->element_id) {\n\t\tcase WLAN_EID_VENDOR_SPECIFIC: \n\t\t\tif (!memcmp(pIE->data, WMM_OUI, 4))\n\t\t\t\tWMM_param_handler(padapter, pIE);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_HT_CAPABILITY:\t \n\t\t\tpmlmeinfo->HT_caps_enable = 1;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_HT_OPERATION:\t \n\t\t\tpmlmeinfo->HT_info_enable = 1;\n\n\t\t\t \n\t\t\t{\n\t\t\t\tstruct HT_info_element *pht_info = (struct HT_info_element *)(pIE->data);\n\n\t\t\t\tif (pnetwork->configuration.ds_config <= 14) {\n\t\t\t\t\tif ((pregpriv->bw_mode & 0x0f) > CHANNEL_WIDTH_20)\n\t\t\t\t\t\tcbw40_enable = 1;\n\t\t\t\t}\n\n\t\t\t\tif ((cbw40_enable) && (pht_info->infos[0] & BIT(2))) {\n\t\t\t\t\t \n\t\t\t\t\tpmlmeext->cur_bwmode = CHANNEL_WIDTH_40;\n\t\t\t\t\tswitch (pht_info->infos[0] & 0x3) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tpmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tpmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tpmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\t\t\t\t\t\tpmlmeext->cur_bwmode = CHANNEL_WIDTH_20;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\ti += (pIE->length + 2);\n\t}\n\n\t \n\tif (rtw_chk_start_clnt_join(padapter, &ch, &bw, &offset) == _FAIL) {\n\t\treport_join_res(padapter, (-4));\n\t\treturn H2C_SUCCESS;\n\t}\n\n\t \n\t \n\n\t \n\t \n\t \n\n\trtw_hal_set_hwreg(padapter, HW_VAR_BSSID, pmlmeinfo->network.mac_address);\n\tjoin_type = 0;\n\trtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));\n\trtw_hal_set_hwreg(padapter, HW_VAR_DO_IQK, NULL);\n\n\tset_channel_bwmode(padapter, ch, offset, bw);\n\n\t \n\tdel_timer_sync(&pmlmeext->link_timer);\n\n\tstart_clnt_join(padapter);\n\n\treturn H2C_SUCCESS;\n\n}\n\nu8 disconnect_hdl(struct adapter *padapter, unsigned char *pbuf)\n{\n\tstruct disconnect_parm *param = (struct disconnect_parm *)pbuf;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct wlan_bssid_ex\t\t*pnetwork = (struct wlan_bssid_ex *)(&(pmlmeinfo->network));\n\tu8 val8;\n\n\tif (is_client_associated_to_ap(padapter))\n\t\tissue_deauth_ex(padapter, pnetwork->mac_address, WLAN_REASON_DEAUTH_LEAVING, param->deauth_timeout_ms/100, 100);\n\n\tif (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)) {\n\t\t \n\t\tval8 = 0;\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_BCN_FUNC, (u8 *)(&val8));\n\t}\n\n\trtw_mlmeext_disconnect(padapter);\n\n\trtw_free_uc_swdec_pending_queue(padapter);\n\n\treturn\tH2C_SUCCESS;\n}\n\nstatic int rtw_scan_ch_decision(struct adapter *padapter, struct rtw_ieee80211_channel *out,\n\tu32 out_num, struct rtw_ieee80211_channel *in, u32 in_num)\n{\n\tint i, j;\n\tint set_idx;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\n\t \n\tmemset(out, 0, sizeof(struct rtw_ieee80211_channel)*out_num);\n\n\t \n\tj = 0;\n\tfor (i = 0; i < in_num; i++) {\n\n\t\tset_idx = rtw_ch_set_search_ch(pmlmeext->channel_set, in[i].hw_value);\n\t\tif (in[i].hw_value && !(in[i].flags & RTW_IEEE80211_CHAN_DISABLED)\n\t\t\t&& set_idx >= 0\n\t\t) {\n\t\t\tif (j >= out_num) {\n\t\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t\t   FUNC_ADPT_FMT \" out_num:%u not enough\\n\",\n\t\t\t\t\t   FUNC_ADPT_ARG(padapter), out_num);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&out[j], &in[i], sizeof(struct rtw_ieee80211_channel));\n\n\t\t\tif (pmlmeext->channel_set[set_idx].ScanType == SCAN_PASSIVE)\n\t\t\t\tout[j].flags |= RTW_IEEE80211_CHAN_PASSIVE_SCAN;\n\n\t\t\tj++;\n\t\t}\n\t\tif (j >= out_num)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (j == 0) {\n\t\tfor (i = 0; i < pmlmeext->max_chan_nums; i++) {\n\n\t\t\tif (j >= out_num) {\n\t\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t\t   FUNC_ADPT_FMT \" out_num:%u not enough\\n\",\n\t\t\t\t\t   FUNC_ADPT_ARG(padapter),\n\t\t\t\t\t   out_num);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tout[j].hw_value = pmlmeext->channel_set[i].ChannelNum;\n\n\t\t\tif (pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)\n\t\t\t\tout[j].flags |= RTW_IEEE80211_CHAN_PASSIVE_SCAN;\n\n\t\t\tj++;\n\t\t}\n\t}\n\n\treturn j;\n}\n\nu8 sitesurvey_cmd_hdl(struct adapter *padapter, u8 *pbuf)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct sitesurvey_parm\t*pparm = (struct sitesurvey_parm *)pbuf;\n\tu8 bdelayscan = false;\n\tu8 val8;\n\tu32 initialgain;\n\tu32 i;\n\n\tif (pmlmeext->sitesurvey_res.state == SCAN_DISABLE) {\n\t\tpmlmeext->sitesurvey_res.state = SCAN_START;\n\t\tpmlmeext->sitesurvey_res.bss_cnt = 0;\n\t\tpmlmeext->sitesurvey_res.channel_idx = 0;\n\n\t\tfor (i = 0; i < RTW_SSID_SCAN_AMOUNT; i++) {\n\t\t\tif (pparm->ssid[i].ssid_length) {\n\t\t\t\tmemcpy(pmlmeext->sitesurvey_res.ssid[i].ssid, pparm->ssid[i].ssid, IW_ESSID_MAX_SIZE);\n\t\t\t\tpmlmeext->sitesurvey_res.ssid[i].ssid_length = pparm->ssid[i].ssid_length;\n\t\t\t} else {\n\t\t\t\tpmlmeext->sitesurvey_res.ssid[i].ssid_length = 0;\n\t\t\t}\n\t\t}\n\n\t\tpmlmeext->sitesurvey_res.ch_num = rtw_scan_ch_decision(padapter\n\t\t\t, pmlmeext->sitesurvey_res.ch, RTW_CHANNEL_SCAN_AMOUNT\n\t\t\t, pparm->ch, pparm->ch_num\n\t\t);\n\n\t\tpmlmeext->sitesurvey_res.scan_mode = pparm->scan_mode;\n\n\t\t \n\t\tif (is_client_associated_to_ap(padapter)) {\n\t\t\tpmlmeext->sitesurvey_res.state = SCAN_TXNULL;\n\n\t\t\tissue_nulldata(padapter, NULL, 1, 3, 500);\n\n\t\t\tbdelayscan = true;\n\t\t}\n\t\tif (bdelayscan) {\n\t\t\t \n\t\t\tset_survey_timer(pmlmeext, 50);\n\t\t\treturn H2C_SUCCESS;\n\t\t}\n\t}\n\n\tif ((pmlmeext->sitesurvey_res.state == SCAN_START) || (pmlmeext->sitesurvey_res.state == SCAN_TXNULL)) {\n\t\t \n\t\tSave_DM_Func_Flag(padapter);\n\t\tSwitch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, false);\n\n\t\t \n\t\tinitialgain = 0x1e;\n\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));\n\n\t\t \n\t\tSet_MSR(padapter, _HW_STATE_NOLINK_);\n\n\t\tval8 = 1;  \n\t\trtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));\n\n\t\tpmlmeext->sitesurvey_res.state = SCAN_PROCESS;\n\t}\n\n\tsite_survey(padapter);\n\n\treturn H2C_SUCCESS;\n\n}\n\nu8 setauth_hdl(struct adapter *padapter, unsigned char *pbuf)\n{\n\tstruct setauth_parm\t\t*pparm = (struct setauth_parm *)pbuf;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tif (pparm->mode < 4)\n\t\tpmlmeinfo->auth_algo = pparm->mode;\n\n\treturn\tH2C_SUCCESS;\n}\n\nu8 setkey_hdl(struct adapter *padapter, u8 *pbuf)\n{\n\tu16 ctrl = 0;\n\ts16 cam_id = 0;\n\tstruct setkey_parm\t\t*pparm = (struct setkey_parm *)pbuf;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tunsigned char null_addr[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\tu8 *addr;\n\n\t \n\tif (pparm->set_tx)\n\t\tpmlmeinfo->key_index = pparm->keyid;\n\n\tcam_id = rtw_camid_alloc(padapter, NULL, pparm->keyid);\n\n\tif (cam_id < 0) {\n\t} else {\n\t\tif (cam_id > 3)  \n\t\t\taddr = get_bssid(&padapter->mlmepriv);\n\t\telse\n\t\t\taddr = null_addr;\n\n\t\tctrl = BIT(15) | BIT6 | ((pparm->algorithm) << 2) | pparm->keyid;\n\t\twrite_cam(padapter, cam_id, ctrl, addr, pparm->key);\n\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t   \"set group key camid:%d, addr:%pM, kid:%d, type:%s\\n\",\n\t\t\t   cam_id, MAC_ARG(addr), pparm->keyid,\n\t\t\t   security_type_str(pparm->algorithm));\n\t}\n\n\tif (cam_id >= 0 && cam_id <= 3)\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_SEC_DK_CFG, (u8 *)true);\n\n\t \n\tpadapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_ON_RCR_AM, null_addr);\n\n\treturn H2C_SUCCESS;\n}\n\nu8 set_stakey_hdl(struct adapter *padapter, u8 *pbuf)\n{\n\tu16 ctrl = 0;\n\ts16 cam_id = 0;\n\tu8 ret = H2C_SUCCESS;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tstruct set_stakey_parm\t*pparm = (struct set_stakey_parm *)pbuf;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct sta_info *psta;\n\n\tif (pparm->algorithm == _NO_PRIVACY_)\n\t\tgoto write_to_cam;\n\n\tpsta = rtw_get_stainfo(pstapriv, pparm->addr);\n\tif (!psta) {\n\t\tnetdev_dbg(padapter->pnetdev, \"%s sta:%pM not found\\n\",\n\t\t\t   __func__, MAC_ARG(pparm->addr));\n\t\tret = H2C_REJECTED;\n\t\tgoto exit;\n\t}\n\n\tpmlmeinfo->enc_algo = pparm->algorithm;\n\tcam_id = rtw_camid_alloc(padapter, psta, 0);\n\tif (cam_id < 0)\n\t\tgoto exit;\n\nwrite_to_cam:\n\tif (pparm->algorithm == _NO_PRIVACY_) {\n\t\twhile ((cam_id = rtw_camid_search(padapter, pparm->addr, -1)) >= 0) {\n\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t   \"clear key for addr:%pM, camid:%d\\n\",\n\t\t\t\t   MAC_ARG(pparm->addr), cam_id);\n\t\t\tclear_cam_entry(padapter, cam_id);\n\t\t\trtw_camid_free(padapter, cam_id);\n\t\t}\n\t} else {\n\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t   \"set pairwise key camid:%d, addr:%pM, kid:%d, type:%s\\n\",\n\t\t\t   cam_id, MAC_ARG(pparm->addr), pparm->keyid,\n\t\t\t   security_type_str(pparm->algorithm));\n\t\tctrl = BIT(15) | ((pparm->algorithm) << 2) | pparm->keyid;\n\t\twrite_cam(padapter, cam_id, ctrl, pparm->addr, pparm->key);\n\t}\n\tret = H2C_SUCCESS_RSP;\n\nexit:\n\treturn ret;\n}\n\nu8 add_ba_hdl(struct adapter *padapter, unsigned char *pbuf)\n{\n\tstruct addBaReq_parm\t*pparm = (struct addBaReq_parm *)pbuf;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tstruct sta_info *psta = rtw_get_stainfo(&padapter->stapriv, pparm->addr);\n\n\tif (!psta)\n\t\treturn\tH2C_SUCCESS;\n\n\tif (((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && (pmlmeinfo->HT_enable)) ||\n\t\t((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)) {\n\t\t \n\t\t \n\t\t \n\t\tissue_action_BA(padapter, pparm->addr, WLAN_ACTION_ADDBA_REQ, (u16)pparm->tid);\n\t\t \n\t\t_set_timer(&psta->addba_retry_timer, ADDBA_TO);\n\t} else {\n\t\tpsta->htpriv.candidate_tid_bitmap &= ~BIT(pparm->tid);\n\t}\n\treturn\tH2C_SUCCESS;\n}\n\n\nu8 chk_bmc_sleepq_cmd(struct adapter *padapter)\n{\n\tstruct cmd_obj *ph2c;\n\tstruct cmd_priv *pcmdpriv = &(padapter->cmdpriv);\n\tu8 res = _SUCCESS;\n\n\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ph2c) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tinit_h2fwcmd_w_parm_no_parm_rsp(ph2c, GEN_CMD_CODE(_ChkBMCSleepq));\n\n\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\nexit:\n\treturn res;\n}\n\nu8 set_tx_beacon_cmd(struct adapter *padapter)\n{\n\tstruct cmd_obj\t*ph2c;\n\tstruct Tx_Beacon_param\t*ptxBeacon_parm;\n\tstruct cmd_priv *pcmdpriv = &(padapter->cmdpriv);\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\n\tu8 res = _SUCCESS;\n\tint len_diff = 0;\n\n\tph2c = rtw_zmalloc(sizeof(struct cmd_obj));\n\tif (!ph2c) {\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tptxBeacon_parm = rtw_zmalloc(sizeof(struct Tx_Beacon_param));\n\tif (!ptxBeacon_parm) {\n\t\tkfree(ph2c);\n\t\tres = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(&(ptxBeacon_parm->network), &(pmlmeinfo->network), sizeof(struct wlan_bssid_ex));\n\n\tlen_diff = update_hidden_ssid(ptxBeacon_parm->network.ies+_BEACON_IE_OFFSET_,\n\t\t\t\t      ptxBeacon_parm->network.ie_length-_BEACON_IE_OFFSET_,\n\t\t\t\t      pmlmeinfo->hidden_ssid_mode);\n\tptxBeacon_parm->network.ie_length += len_diff;\n\n\tinit_h2fwcmd_w_parm_no_rsp(ph2c, ptxBeacon_parm, GEN_CMD_CODE(_TX_Beacon));\n\n\tres = rtw_enqueue_cmd(pcmdpriv, ph2c);\n\nexit:\n\treturn res;\n}\n\nstatic struct fwevent wlanevents[] = {\n\t{0, rtw_dummy_event_callback},\t \n\t{0, NULL},\n\t{0, NULL},\n\t{0, NULL},\n\t{0, NULL},\n\t{0, NULL},\n\t{0, NULL},\n\t{0, NULL},\n\t{0, &rtw_survey_event_callback},\t\t \n\t{sizeof(struct surveydone_event), &rtw_surveydone_event_callback},\t \n\n\t{0, &rtw_joinbss_event_callback},\t\t \n\t{sizeof(struct stassoc_event), &rtw_stassoc_event_callback},\n\t{sizeof(struct stadel_event), &rtw_stadel_event_callback},\n\t{0, &rtw_atimdone_event_callback},\n\t{0, rtw_dummy_event_callback},\n\t{0, NULL},\t \n\t{0, NULL},\n\t{0, NULL},\n\t{0, NULL},\n\t{0, rtw_fwdbg_event_callback},\n\t{0, NULL},\t  \n\t{0, NULL},\n\t{0, NULL},\n\t{0, &rtw_cpwm_event_callback},\n\t{0, NULL},\n\t{0, &rtw_wmm_event_callback},\n\n};\n\nu8 mlme_evt_hdl(struct adapter *padapter, unsigned char *pbuf)\n{\n\tu8 evt_code;\n\tu16 evt_sz;\n\tuint\t*peventbuf;\n\tvoid (*event_callback)(struct adapter *dev, u8 *pbuf);\n\tstruct evt_priv *pevt_priv = &(padapter->evtpriv);\n\n\tif (!pbuf)\n\t\tgoto _abort_event_;\n\n\tpeventbuf = (uint *)pbuf;\n\tevt_sz = (u16)(*peventbuf&0xffff);\n\tevt_code = (u8)((*peventbuf>>16)&0xff);\n\n\t \n\tif (evt_code >= MAX_C2HEVT)\n\t\tgoto _abort_event_;\n\n\t \n\tif ((wlanevents[evt_code].parmsize != 0) &&\n\t\t\t(wlanevents[evt_code].parmsize != evt_sz))\n\t\tgoto _abort_event_;\n\n\tatomic_inc(&pevt_priv->event_seq);\n\n\tpeventbuf += 2;\n\n\tif (peventbuf) {\n\t\tevent_callback = wlanevents[evt_code].event_callback;\n\t\tevent_callback(padapter, (u8 *)peventbuf);\n\n\t\tpevt_priv->evt_done_cnt++;\n\t}\n\n\n_abort_event_:\n\n\n\treturn H2C_SUCCESS;\n\n}\n\nu8 h2c_msg_hdl(struct adapter *padapter, unsigned char *pbuf)\n{\n\tif (!pbuf)\n\t\treturn H2C_PARAMETERS_ERROR;\n\n\treturn H2C_SUCCESS;\n}\n\nu8 chk_bmc_sleepq_hdl(struct adapter *padapter, unsigned char *pbuf)\n{\n\tstruct sta_info *psta_bmc;\n\tstruct list_head *xmitframe_plist, *xmitframe_phead, *tmp;\n\tstruct xmit_frame *pxmitframe = NULL;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct sta_priv  *pstapriv = &padapter->stapriv;\n\n\t \n\tpsta_bmc = rtw_get_bcmc_stainfo(padapter);\n\tif (!psta_bmc)\n\t\treturn H2C_SUCCESS;\n\n\tif ((pstapriv->tim_bitmap&BIT(0)) && (psta_bmc->sleepq_len > 0)) {\n\t\tmsleep(10); \n\n\t\t \n\t\tspin_lock_bh(&pxmitpriv->lock);\n\n\t\txmitframe_phead = get_list_head(&psta_bmc->sleep_q);\n\t\tlist_for_each_safe(xmitframe_plist, tmp, xmitframe_phead) {\n\t\t\tpxmitframe = list_entry(xmitframe_plist,\n\t\t\t\t\t\tstruct xmit_frame, list);\n\n\t\t\tlist_del_init(&pxmitframe->list);\n\n\t\t\tpsta_bmc->sleepq_len--;\n\t\t\tif (psta_bmc->sleepq_len > 0)\n\t\t\t\tpxmitframe->attrib.mdata = 1;\n\t\t\telse\n\t\t\t\tpxmitframe->attrib.mdata = 0;\n\n\t\t\tpxmitframe->attrib.triggered = 1;\n\n\t\t\tif (xmitframe_hiq_filter(pxmitframe))\n\t\t\t\tpxmitframe->attrib.qsel = 0x11; \n\n\t\t\trtw_hal_xmitframe_enqueue(padapter, pxmitframe);\n\t\t}\n\n\t\t \n\t\tspin_unlock_bh(&pxmitpriv->lock);\n\n\t\t \n\t\trtw_chk_hi_queue_cmd(padapter);\n\t}\n\n\treturn H2C_SUCCESS;\n}\n\nu8 tx_beacon_hdl(struct adapter *padapter, unsigned char *pbuf)\n{\n\tif (send_beacon(padapter) == _FAIL)\n\t\treturn H2C_PARAMETERS_ERROR;\n\n\t \n\tchk_bmc_sleepq_hdl(padapter, NULL);\n\n\treturn H2C_SUCCESS;\n}\n\nint rtw_chk_start_clnt_join(struct adapter *padapter, u8 *ch, u8 *bw, u8 *offset)\n{\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tunsigned char cur_ch = pmlmeext->cur_channel;\n\tunsigned char cur_bw = pmlmeext->cur_bwmode;\n\tunsigned char cur_ch_offset = pmlmeext->cur_ch_offset;\n\tbool connect_allow = true;\n\n\tif (!ch || !bw || !offset) {\n\t\trtw_warn_on(1);\n\t\tconnect_allow = false;\n\t}\n\n\tif (connect_allow) {\n\t\t*ch = cur_ch;\n\t\t*bw = cur_bw;\n\t\t*offset = cur_ch_offset;\n\t}\n\n\treturn connect_allow ? _SUCCESS : _FAIL;\n}\n\nu8 set_ch_hdl(struct adapter *padapter, u8 *pbuf)\n{\n\tstruct set_ch_parm *set_ch_parm;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\n\tif (!pbuf)\n\t\treturn H2C_PARAMETERS_ERROR;\n\n\tset_ch_parm = (struct set_ch_parm *)pbuf;\n\n\tpmlmeext->cur_channel = set_ch_parm->ch;\n\tpmlmeext->cur_ch_offset = set_ch_parm->ch_offset;\n\tpmlmeext->cur_bwmode = set_ch_parm->bw;\n\n\tset_channel_bwmode(padapter, set_ch_parm->ch, set_ch_parm->ch_offset, set_ch_parm->bw);\n\n\treturn\tH2C_SUCCESS;\n}\n\nu8 set_chplan_hdl(struct adapter *padapter, unsigned char *pbuf)\n{\n\tstruct SetChannelPlan_param *setChannelPlan_param;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\n\tif (!pbuf)\n\t\treturn H2C_PARAMETERS_ERROR;\n\n\tsetChannelPlan_param = (struct SetChannelPlan_param *)pbuf;\n\n\tpmlmeext->max_chan_nums = init_channel_set(padapter, setChannelPlan_param->channel_plan, pmlmeext->channel_set);\n\tinit_channel_list(padapter, pmlmeext->channel_set, pmlmeext->max_chan_nums, &pmlmeext->channel_list);\n\n\tif (padapter->rtw_wdev && padapter->rtw_wdev->wiphy) {\n\t\tstruct regulatory_request request;\n\n\t\trequest.initiator = NL80211_REGDOM_SET_BY_DRIVER;\n\t\trtw_reg_notifier(padapter->rtw_wdev->wiphy, &request);\n\t}\n\n\treturn\tH2C_SUCCESS;\n}\n\nu8 set_csa_hdl(struct adapter *padapter, unsigned char *pbuf)\n{\n\treturn\tH2C_REJECTED;\n}\n\n \n \n \n \n \n \n \n \n \n \nu8 tdls_hdl(struct adapter *padapter, unsigned char *pbuf)\n{\n\treturn H2C_REJECTED;\n}\n\nu8 run_in_thread_hdl(struct adapter *padapter, u8 *pbuf)\n{\n\tstruct RunInThread_param *p;\n\n\n\tif (pbuf == NULL)\n\t\treturn H2C_PARAMETERS_ERROR;\n\tp = (struct RunInThread_param *)pbuf;\n\n\tif (p->func)\n\t\tp->func(p->context);\n\n\treturn H2C_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}