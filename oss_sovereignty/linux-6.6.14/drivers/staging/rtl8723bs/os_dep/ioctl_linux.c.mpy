{
  "module_name": "ioctl_linux.c",
  "hash_id": "0076f27a5e4dad63c0b0b107eb9dea9803dbe89b95cae36e8a5754f883d8fde6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/os_dep/ioctl_linux.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <rtw_mp.h>\n#include <hal_btcoex.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define RTL_IOCTL_WPA_SUPPLICANT\t(SIOCIWFIRSTPRIV + 30)\n\nstatic int wpa_set_auth_algs(struct net_device *dev, u32 value)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tint ret = 0;\n\n\tif ((value & IW_AUTH_ALG_SHARED_KEY) && (value & IW_AUTH_ALG_OPEN_SYSTEM)) {\n\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\tpadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeAutoSwitch;\n\t\tpadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;\n\t} else if (value & IW_AUTH_ALG_SHARED_KEY)\t{\n\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\n\t\tpadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeShared;\n\t\tpadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;\n\t} else if (value & IW_AUTH_ALG_OPEN_SYSTEM) {\n\t\t \n\t\tif (padapter->securitypriv.ndisauthtype < Ndis802_11AuthModeWPAPSK) {\n\t\t\tpadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;\n\t\t\tpadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int wpa_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)\n{\n\tint ret = 0;\n\tu8 max_idx;\n\tu32 wep_key_idx, wep_key_len, wep_total_len;\n\tstruct ndis_802_11_wep\t *pwep = NULL;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\n\tparam->u.crypt.err = 0;\n\tparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\\0';\n\n\tif (param_len < (u32)((u8 *)param->u.crypt.key - (u8 *)param) + param->u.crypt.key_len) {\n\t\tret =  -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (param->sta_addr[0] != 0xff || param->sta_addr[1] != 0xff ||\n\t    param->sta_addr[2] != 0xff || param->sta_addr[3] != 0xff ||\n\t    param->sta_addr[4] != 0xff || param->sta_addr[5] != 0xff) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0)\n\t\tmax_idx = WEP_KEYS - 1;\n\telse\n\t\tmax_idx = BIP_MAX_KEYID;\n\n\tif (param->u.crypt.idx > max_idx) {\n\t\tnetdev_err(dev, \"Error crypt.idx %d > %d\\n\", param->u.crypt.idx, max_idx);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0) {\n\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\tpadapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;\n\t\tpadapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;\n\n\t\twep_key_idx = param->u.crypt.idx;\n\t\twep_key_len = param->u.crypt.key_len;\n\n\t\tif (wep_key_len > 0) {\n\t\t\twep_key_len = wep_key_len <= 5 ? 5 : 13;\n\t\t\twep_total_len = wep_key_len + FIELD_OFFSET(struct ndis_802_11_wep, key_material);\n\t\t\t \n\t\t\tpwep = kzalloc(sizeof(*pwep), GFP_KERNEL);\n\t\t\tif (!pwep) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tpwep->key_length = wep_key_len;\n\t\t\tpwep->length = wep_total_len;\n\n\t\t\tif (wep_key_len == 13) {\n\t\t\t\tpadapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;\n\t\t\t\tpadapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tpwep->key_index = wep_key_idx;\n\t\tpwep->key_index |= 0x80000000;\n\n\t\tmemcpy(pwep->key_material,  param->u.crypt.key, pwep->key_length);\n\n\t\tif (param->u.crypt.set_tx) {\n\t\t\tif (rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t} else {\n\t\t\t \n\t\t\t \n\n\t\t\tif (wep_key_idx >= WEP_KEYS) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tmemcpy(&psecuritypriv->dot11DefKey[wep_key_idx].skey[0], pwep->key_material, pwep->key_length);\n\t\t\tpsecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->key_length;\n\t\t\trtw_set_key(padapter, psecuritypriv, wep_key_idx, 0, true);\n\t\t}\n\n\t\tgoto exit;\n\t}\n\n\tif (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) {  \n\t\tstruct sta_info *psta, *pbcmc_sta;\n\t\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == true) {  \n\t\t\tpsta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));\n\t\t\tif (!psta) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (strcmp(param->u.crypt.alg, \"none\") != 0)\n\t\t\t\t\tpsta->ieee8021x_blocked = false;\n\n\t\t\t\tif ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled) ||\n\t\t\t\t    (padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled)) {\n\t\t\t\t\tpsta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;\n\t\t\t\t}\n\n\t\t\t\tif (param->u.crypt.set_tx == 1) {  \n\t\t\t\t\tmemcpy(psta->dot118021x_UncstKey.skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\n\t\t\t\t\tif (strcmp(param->u.crypt.alg, \"TKIP\") == 0) {  \n\t\t\t\t\t\t \n\t\t\t\t\t\tmemcpy(psta->dot11tkiptxmickey.skey, &param->u.crypt.key[16], 8);\n\t\t\t\t\t\tmemcpy(psta->dot11tkiprxmickey.skey, &param->u.crypt.key[24], 8);\n\n\t\t\t\t\t\tpadapter->securitypriv.busetkipkey = false;\n\t\t\t\t\t\t \n\t\t\t\t\t}\n\n\t\t\t\t\trtw_setstakey_cmd(padapter, psta, true, true);\n\t\t\t\t} else {  \n\t\t\t\t\tif (strcmp(param->u.crypt.alg, \"TKIP\") == 0 || strcmp(param->u.crypt.alg, \"CCMP\") == 0) {\n\t\t\t\t\t\tmemcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (param->u.crypt.key_len > 16) {\n\t\t\t\t\t\t\tmemcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey, &param->u.crypt.key[16], 8);\n\t\t\t\t\t\t\tmemcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey, &param->u.crypt.key[24], 8);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpadapter->securitypriv.binstallGrpkey = true;\n\n\t\t\t\t\t\tpadapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;\n\n\t\t\t\t\t\trtw_set_key(padapter, &padapter->securitypriv, param->u.crypt.idx, 1, true);\n\t\t\t\t\t} else if (strcmp(param->u.crypt.alg, \"BIP\") == 0) {\n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\tmemcpy(padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\t\t\t\t\t\t \n\t\t\t\t\t\tpadapter->securitypriv.dot11wBIPKeyid = param->u.crypt.idx;\n\t\t\t\t\t\tpadapter->securitypriv.binstallBIPkey = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpbcmc_sta = rtw_get_bcmc_stainfo(padapter);\n\t\t\tif (!pbcmc_sta) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (strcmp(param->u.crypt.alg, \"none\") != 0)\n\t\t\t\t\tpbcmc_sta->ieee8021x_blocked = false;\n\n\t\t\t\tif ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled) ||\n\t\t\t\t    (padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled)) {\n\t\t\t\t\tpbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {\n\t\t\t \n\t\t}\n\t}\n\nexit:\n\n\tkfree(pwep);\n\treturn ret;\n}\n\nstatic int rtw_set_wpa_ie(struct adapter *padapter, char *pie, unsigned short ielen)\n{\n\tu8 *buf = NULL;\n\tint group_cipher = 0, pairwise_cipher = 0;\n\tint ret = 0;\n\tu8 null_addr[] = {0, 0, 0, 0, 0, 0};\n\n\tif (ielen > MAX_WPA_IE_LEN || !pie) {\n\t\t_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);\n\t\tif (!pie)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (ielen) {\n\t\tbuf = rtw_zmalloc(ielen);\n\t\tif (!buf) {\n\t\t\tret =  -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tmemcpy(buf, pie, ielen);\n\n\t\tif (ielen < RSN_HEADER_LEN) {\n\t\t\tret  = -1;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {\n\t\t\tpadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\n\t\t\tpadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPAPSK;\n\t\t\tmemcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);\n\t\t}\n\n\t\tif (rtw_parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {\n\t\t\tpadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\n\t\t\tpadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPA2PSK;\n\t\t\tmemcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);\n\t\t}\n\n\t\tif (group_cipher == 0)\n\t\t\tgroup_cipher = WPA_CIPHER_NONE;\n\t\tif (pairwise_cipher == 0)\n\t\t\tpairwise_cipher = WPA_CIPHER_NONE;\n\n\t\tswitch (group_cipher) {\n\t\tcase WPA_CIPHER_NONE:\n\t\t\tpadapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_WEP40:\n\t\t\tpadapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_TKIP:\n\t\t\tpadapter->securitypriv.dot118021XGrpPrivacy = _TKIP_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_CCMP:\n\t\t\tpadapter->securitypriv.dot118021XGrpPrivacy = _AES_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_WEP104:\n\t\t\tpadapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (pairwise_cipher) {\n\t\tcase WPA_CIPHER_NONE:\n\t\t\tpadapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_WEP40:\n\t\t\tpadapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_TKIP:\n\t\t\tpadapter->securitypriv.dot11PrivacyAlgrthm = _TKIP_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_CCMP:\n\t\t\tpadapter->securitypriv.dot11PrivacyAlgrthm = _AES_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_WEP104:\n\t\t\tpadapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;\n\t\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\t\tbreak;\n\t\t}\n\n\t\t_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);\n\t\t{ \n\t\t\tu16 cnt = 0;\n\t\t\tu8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};\n\n\t\t\twhile (cnt < ielen) {\n\t\t\t\teid = buf[cnt];\n\n\t\t\t\tif ((eid == WLAN_EID_VENDOR_SPECIFIC) && (!memcmp(&buf[cnt + 2], wps_oui, 4))) {\n\t\t\t\t\tpadapter->securitypriv.wps_ie_len = ((buf[cnt + 1] + 2) < MAX_WPS_IE_LEN) ? (buf[cnt + 1] + 2) : MAX_WPS_IE_LEN;\n\n\t\t\t\t\tmemcpy(padapter->securitypriv.wps_ie, &buf[cnt], padapter->securitypriv.wps_ie_len);\n\n\t\t\t\t\tset_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS);\n\n\t\t\t\t\tcnt += buf[cnt + 1] + 2;\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tcnt += buf[cnt + 1] + 2;  \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_ ||\n\t    padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_ ||\n\t    padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)\n\t\t \n\t\t \n\t\trtw_hal_set_hwreg(padapter, HW_VAR_OFF_RCR_AM, null_addr);\n\nexit:\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int wpa_set_param(struct net_device *dev, u8 name, u32 value)\n{\n\tuint ret = 0;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\n\tswitch (name) {\n\tcase IEEE_PARAM_WPA_ENABLED:\n\n\t\tpadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;  \n\n\t\t \n\n\t\tswitch ((value) & 0xff) {\n\t\tcase 1:  \n\t\t\tpadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPAPSK;  \n\t\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tpadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPA2PSK;  \n\t\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase IEEE_PARAM_TKIP_COUNTERMEASURES:\n\t\t \n\t\tbreak;\n\n\tcase IEEE_PARAM_DROP_UNENCRYPTED:\n\t{\n\t\t \n\t\tbreak;\n\t}\n\tcase IEEE_PARAM_PRIVACY_INVOKED:\n\n\t\t \n\n\t\tbreak;\n\n\tcase IEEE_PARAM_AUTH_ALGS:\n\n\t\tret = wpa_set_auth_algs(dev, value);\n\n\t\tbreak;\n\n\tcase IEEE_PARAM_IEEE_802_1X:\n\n\t\t \n\n\t\tbreak;\n\n\tcase IEEE_PARAM_WPAX_SELECT:\n\n\t\t \n\t\t \n\n\t\tbreak;\n\n\tdefault:\n\n\t\tret = -EOPNOTSUPP;\n\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int wpa_mlme(struct net_device *dev, u32 command, u32 reason)\n{\n\tint ret = 0;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\n\tswitch (command) {\n\tcase IEEE_MLME_STA_DEAUTH:\n\n\t\tif (!rtw_set_802_11_disassociate(padapter))\n\t\t\tret = -1;\n\n\t\tbreak;\n\n\tcase IEEE_MLME_STA_DISASSOC:\n\n\t\tif (!rtw_set_802_11_disassociate(padapter))\n\t\t\tret = -1;\n\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)\n{\n\tstruct ieee_param *param;\n\tuint ret = 0;\n\n\t \n\n\tif (!p->pointer || p->length != sizeof(struct ieee_param))\n\t\treturn -EINVAL;\n\n\tparam = rtw_malloc(p->length);\n\tif (!param)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(param, p->pointer, p->length)) {\n\t\tkfree(param);\n\t\treturn -EFAULT;\n\t}\n\n\tswitch (param->cmd) {\n\tcase IEEE_CMD_SET_WPA_PARAM:\n\t\tret = wpa_set_param(dev, param->u.wpa_param.name, param->u.wpa_param.value);\n\t\tbreak;\n\n\tcase IEEE_CMD_SET_WPA_IE:\n\t\t \n\t\tret =  rtw_set_wpa_ie(rtw_netdev_priv(dev), (char *)param->u.wpa_ie.data, (u16)param->u.wpa_ie.len);\n\t\tbreak;\n\n\tcase IEEE_CMD_SET_ENCRYPTION:\n\t\tret = wpa_set_encryption(dev, param, p->length);\n\t\tbreak;\n\n\tcase IEEE_CMD_MLME:\n\t\tret = wpa_mlme(dev, param->u.mlme.command, param->u.mlme.reason_code);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (ret == 0 && copy_to_user(p->pointer, param, p->length))\n\t\tret = -EFAULT;\n\n\tkfree(param);\n\n\t \n\treturn ret;\n}\n\nstatic int rtw_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)\n{\n\tint ret = 0;\n\tu32 wep_key_idx, wep_key_len, wep_total_len;\n\tstruct ndis_802_11_wep\t *pwep = NULL;\n\tstruct sta_info *psta = NULL, *pbcmc_sta = NULL;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tchar *txkey = padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey;\n\tchar *rxkey = padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey;\n\tchar *grpkey = psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey;\n\n\tparam->u.crypt.err = 0;\n\tparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\\0';\n\n\t \n\t \n\tif (param_len !=  sizeof(struct ieee_param) + param->u.crypt.key_len) {\n\t\tret =  -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\n\t    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\n\t    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {\n\t\tif (param->u.crypt.idx >= WEP_KEYS) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tpsta = rtw_get_stainfo(pstapriv, param->sta_addr);\n\t\tif (!psta)\n\t\t\t \n\t\t\tgoto exit;\n\t}\n\n\tif (strcmp(param->u.crypt.alg, \"none\") == 0 && !psta) {\n\t\t \n\n\t\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\n\t\tpsecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;\n\t\tpsecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;\n\t\tpsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\n\n\t\tgoto exit;\n\t}\n\n\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0 && !psta) {\n\t\twep_key_idx = param->u.crypt.idx;\n\t\twep_key_len = param->u.crypt.key_len;\n\n\t\tif ((wep_key_idx >= WEP_KEYS) || (wep_key_len <= 0)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (wep_key_len > 0) {\n\t\t\twep_key_len = wep_key_len <= 5 ? 5 : 13;\n\t\t\twep_total_len = wep_key_len + FIELD_OFFSET(struct ndis_802_11_wep, key_material);\n\t\t\t \n\t\t\tpwep = kzalloc(sizeof(*pwep), GFP_KERNEL);\n\t\t\tif (!pwep)\n\t\t\t\tgoto exit;\n\n\t\t\tpwep->key_length = wep_key_len;\n\t\t\tpwep->length = wep_total_len;\n\t\t}\n\n\t\tpwep->key_index = wep_key_idx;\n\n\t\tmemcpy(pwep->key_material,  param->u.crypt.key, pwep->key_length);\n\n\t\tif (param->u.crypt.set_tx) {\n\t\t\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;\n\t\t\tpsecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\t\tpsecuritypriv->dot11PrivacyAlgrthm = _WEP40_;\n\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\n\n\t\t\tif (pwep->key_length == 13) {\n\t\t\t\tpsecuritypriv->dot11PrivacyAlgrthm = _WEP104_;\n\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\n\t\t\t}\n\n\t\t\tpsecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;\n\n\t\t\tmemcpy(&psecuritypriv->dot11DefKey[wep_key_idx].skey[0], pwep->key_material, pwep->key_length);\n\n\t\t\tpsecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->key_length;\n\n\t\t\trtw_ap_set_wep_key(padapter, pwep->key_material, pwep->key_length, wep_key_idx, 1);\n\t\t} else {\n\t\t\t \n\t\t\t \n\n\t\t\tmemcpy(&psecuritypriv->dot11DefKey[wep_key_idx].skey[0], pwep->key_material, pwep->key_length);\n\n\t\t\tpsecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->key_length;\n\n\t\t\trtw_ap_set_wep_key(padapter, pwep->key_material, pwep->key_length, wep_key_idx, 0);\n\t\t}\n\n\t\tgoto exit;\n\t}\n\n\tif (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) {  \n\t\tif (param->u.crypt.set_tx == 1) {\n\t\t\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0) {\n\t\t\t\tmemcpy(grpkey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\n\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\n\t\t\t\tif (param->u.crypt.key_len == 13)\n\t\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\n\n\t\t\t} else if (strcmp(param->u.crypt.alg, \"TKIP\") == 0) {\n\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _TKIP_;\n\n\t\t\t\tmemcpy(grpkey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tmemcpy(txkey, &param->u.crypt.key[16], 8);\n\t\t\t\tmemcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &param->u.crypt.key[24], 8);\n\n\t\t\t\tpsecuritypriv->busetkipkey = true;\n\n\t\t\t} else if (strcmp(param->u.crypt.alg, \"CCMP\") == 0) {\n\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _AES_;\n\n\t\t\t\tmemcpy(grpkey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\t\t\t} else {\n\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\n\t\t\t}\n\n\t\t\tpsecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;\n\n\t\t\tpsecuritypriv->binstallGrpkey = true;\n\n\t\t\tpsecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy; \n\n\t\t\trtw_ap_set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);\n\n\t\t\tpbcmc_sta = rtw_get_bcmc_stainfo(padapter);\n\t\t\tif (pbcmc_sta) {\n\t\t\t\tpbcmc_sta->ieee8021x_blocked = false;\n\t\t\t\tpbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy; \n\t\t\t}\n\t\t}\n\n\t\tgoto exit;\n\t}\n\n\tif (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) {  \n\t\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\t\tif (param->u.crypt.set_tx == 1)\t{\n\t\t\t\tmemcpy(psta->dot118021x_UncstKey.skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\n\t\t\t\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0) {\n\t\t\t\t\tpsta->dot118021XPrivacy = _WEP40_;\n\t\t\t\t\tif (param->u.crypt.key_len == 13)\n\t\t\t\t\t\tpsta->dot118021XPrivacy = _WEP104_;\n\t\t\t\t} else if (strcmp(param->u.crypt.alg, \"TKIP\") == 0) {\n\t\t\t\t\tpsta->dot118021XPrivacy = _TKIP_;\n\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tmemcpy(psta->dot11tkiptxmickey.skey, &param->u.crypt.key[16], 8);\n\t\t\t\t\tmemcpy(psta->dot11tkiprxmickey.skey, &param->u.crypt.key[24], 8);\n\n\t\t\t\t\tpsecuritypriv->busetkipkey = true;\n\n\t\t\t\t} else if (strcmp(param->u.crypt.alg, \"CCMP\") == 0) {\n\t\t\t\t\tpsta->dot118021XPrivacy = _AES_;\n\t\t\t\t} else {\n\t\t\t\t\tpsta->dot118021XPrivacy = _NO_PRIVACY_;\n\t\t\t\t}\n\n\t\t\t\trtw_ap_set_pairwise_key(padapter, psta);\n\n\t\t\t\tpsta->ieee8021x_blocked = false;\n\n\t\t\t} else {  \n\t\t\t\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0) {\n\t\t\t\t\tmemcpy(grpkey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\n\t\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\n\t\t\t\t\tif (param->u.crypt.key_len == 13)\n\t\t\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\n\t\t\t\t} else if (strcmp(param->u.crypt.alg, \"TKIP\") == 0) {\n\t\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _TKIP_;\n\n\t\t\t\t\tmemcpy(grpkey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tmemcpy(txkey, &param->u.crypt.key[16], 8);\n\t\t\t\t\tmemcpy(rxkey, &param->u.crypt.key[24], 8);\n\n\t\t\t\t\tpsecuritypriv->busetkipkey = true;\n\n\t\t\t\t} else if (strcmp(param->u.crypt.alg, \"CCMP\") == 0) {\n\t\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _AES_;\n\n\t\t\t\t\tmemcpy(grpkey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\t\t\t\t} else {\n\t\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\n\t\t\t\t}\n\n\t\t\t\tpsecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;\n\n\t\t\t\tpsecuritypriv->binstallGrpkey = true;\n\n\t\t\t\tpsecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy; \n\n\t\t\t\trtw_ap_set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);\n\n\t\t\t\tpbcmc_sta = rtw_get_bcmc_stainfo(padapter);\n\t\t\t\tif (pbcmc_sta) {\n\t\t\t\t\tpbcmc_sta->ieee8021x_blocked = false;\n\t\t\t\t\tpbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\tkfree(pwep);\n\n\treturn ret;\n}\n\nstatic int rtw_set_beacon(struct net_device *dev, struct ieee_param *param, int len)\n{\n\tint ret = 0;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tunsigned char *pbuf = param->u.bcn_ie.buf;\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\n\t\treturn -EINVAL;\n\n\tmemcpy(&pstapriv->max_num_sta, param->u.bcn_ie.reserved, 2);\n\n\tif ((pstapriv->max_num_sta > NUM_STA) || (pstapriv->max_num_sta <= 0))\n\t\tpstapriv->max_num_sta = NUM_STA;\n\n\tif (rtw_check_beacon_data(padapter, pbuf,  (len - 12 - 2)) == _SUCCESS) \n\t\tret = 0;\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic void rtw_hostapd_sta_flush(struct net_device *dev)\n{\n\t \n\t \n\t \n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\t \n\n\tflush_all_cam_entry(padapter);\t \n\n\trtw_sta_flush(padapter);\n}\n\nstatic int rtw_add_sta(struct net_device *dev, struct ieee_param *param)\n{\n\tint ret = 0;\n\tstruct sta_info *psta = NULL;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\n\tif (check_fwstate(pmlmepriv, (_FW_LINKED | WIFI_AP_STATE)) != true)\n\t\treturn -EINVAL;\n\n\tif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\n\t    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\n\t    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {\n\t\treturn -EINVAL;\n\t}\n\n \n\t \n\tpsta = rtw_get_stainfo(pstapriv, param->sta_addr);\n\tif (psta) {\n\t\tint flags = param->u.add_sta.flags;\n\n\t\tpsta->aid = param->u.add_sta.aid; \n\n\t\tmemcpy(psta->bssrateset, param->u.add_sta.tx_supp_rates, 16);\n\n\t\t \n\t\tif (WLAN_STA_WME & flags)\n\t\t\tpsta->qos_option = 1;\n\t\telse\n\t\t\tpsta->qos_option = 0;\n\n\t\tif (pmlmepriv->qospriv.qos_option == 0)\n\t\t\tpsta->qos_option = 0;\n\n\t\t \n\t\tif (WLAN_STA_HT & flags) {\n\t\t\tpsta->htpriv.ht_option = true;\n\t\t\tpsta->qos_option = 1;\n\t\t\tmemcpy((void *)&psta->htpriv.ht_cap, (void *)&param->u.add_sta.ht_cap, sizeof(struct ieee80211_ht_cap));\n\t\t} else {\n\t\t\tpsta->htpriv.ht_option = false;\n\t\t}\n\n\t\tif (!pmlmepriv->htpriv.ht_option)\n\t\t\tpsta->htpriv.ht_option = false;\n\n\t\tupdate_sta_info_apmode(padapter, psta);\n\n\t} else {\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}\n\nstatic int rtw_del_sta(struct net_device *dev, struct ieee_param *param)\n{\n\tint ret = 0;\n\tstruct sta_info *psta = NULL;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\n\tif (check_fwstate(pmlmepriv, (_FW_LINKED | WIFI_AP_STATE)) != true)\n\t\treturn -EINVAL;\n\n\tif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\n\t    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\n\t    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {\n\t\treturn -EINVAL;\n\t}\n\n\tpsta = rtw_get_stainfo(pstapriv, param->sta_addr);\n\tif (psta) {\n\t\tu8 updated = false;\n\n\t\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\t\tif (list_empty(&psta->asoc_list) == false) {\n\t\t\tlist_del_init(&psta->asoc_list);\n\t\t\tpstapriv->asoc_list_cnt--;\n\t\t\tupdated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);\n\t\t}\n\t\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\n\t\tassociated_clients_update(padapter, updated);\n\n\t\tpsta = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int rtw_ioctl_get_sta_data(struct net_device *dev, struct ieee_param *param, int len)\n{\n\tint ret = 0;\n\tstruct sta_info *psta = NULL;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tstruct ieee_param_ex *param_ex = (struct ieee_param_ex *)param;\n\tstruct sta_data *psta_data = (struct sta_data *)param_ex->data;\n\n\tif (check_fwstate(pmlmepriv, (_FW_LINKED | WIFI_AP_STATE)) != true)\n\t\treturn -EINVAL;\n\n\tif (param_ex->sta_addr[0] == 0xff && param_ex->sta_addr[1] == 0xff &&\n\t    param_ex->sta_addr[2] == 0xff && param_ex->sta_addr[3] == 0xff &&\n\t    param_ex->sta_addr[4] == 0xff && param_ex->sta_addr[5] == 0xff) {\n\t\treturn -EINVAL;\n\t}\n\n\tpsta = rtw_get_stainfo(pstapriv, param_ex->sta_addr);\n\tif (psta) {\n\t\tpsta_data->aid = (u16)psta->aid;\n\t\tpsta_data->capability = psta->capability;\n\t\tpsta_data->flags = psta->flags;\n\n \n\n\t\tpsta_data->sta_set = ((psta->nonerp_set) |\n\t\t\t\t\t\t\t (psta->no_short_slot_time_set << 1) |\n\t\t\t\t\t\t\t (psta->no_short_preamble_set << 2) |\n\t\t\t\t\t\t\t (psta->no_ht_gf_set << 3) |\n\t\t\t\t\t\t\t (psta->no_ht_set << 4) |\n\t\t\t\t\t\t\t (psta->ht_20mhz_set << 5));\n\n\t\tpsta_data->tx_supp_rates_len =  psta->bssratelen;\n\t\tmemcpy(psta_data->tx_supp_rates, psta->bssrateset, psta->bssratelen);\n\t\tmemcpy(&psta_data->ht_cap, &psta->htpriv.ht_cap, sizeof(struct ieee80211_ht_cap));\n\t\tpsta_data->rx_pkts = psta->sta_stats.rx_data_pkts;\n\t\tpsta_data->rx_bytes = psta->sta_stats.rx_bytes;\n\t\tpsta_data->rx_drops = psta->sta_stats.rx_drops;\n\n\t\tpsta_data->tx_pkts = psta->sta_stats.tx_pkts;\n\t\tpsta_data->tx_bytes = psta->sta_stats.tx_bytes;\n\t\tpsta_data->tx_drops = psta->sta_stats.tx_drops;\n\n\t} else {\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}\n\nstatic int rtw_get_sta_wpaie(struct net_device *dev, struct ieee_param *param)\n{\n\tint ret = 0;\n\tstruct sta_info *psta = NULL;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\n\tif (check_fwstate(pmlmepriv, (_FW_LINKED | WIFI_AP_STATE)) != true)\n\t\treturn -EINVAL;\n\n\tif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\n\t    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\n\t    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {\n\t\treturn -EINVAL;\n\t}\n\n\tpsta = rtw_get_stainfo(pstapriv, param->sta_addr);\n\tif (psta) {\n\t\tif ((psta->wpa_ie[0] == WLAN_EID_RSN) || (psta->wpa_ie[0] == WLAN_EID_VENDOR_SPECIFIC)) {\n\t\t\tint wpa_ie_len;\n\t\t\tint copy_len;\n\n\t\t\twpa_ie_len = psta->wpa_ie[1];\n\n\t\t\tcopy_len = ((wpa_ie_len + 2) > sizeof(psta->wpa_ie)) ? (sizeof(psta->wpa_ie)) : (wpa_ie_len + 2);\n\n\t\t\tparam->u.wpa_ie.len = copy_len;\n\n\t\t\tmemcpy(param->u.wpa_ie.reserved, psta->wpa_ie, copy_len);\n\t\t}\n\t} else {\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}\n\nstatic int rtw_set_wps_beacon(struct net_device *dev, struct ieee_param *param, int len)\n{\n\tint ret = 0;\n\tunsigned char wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tint ie_len;\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\n\t\treturn -EINVAL;\n\n\tie_len = len - 12 - 2; \n\n\tkfree(pmlmepriv->wps_beacon_ie);\n\tpmlmepriv->wps_beacon_ie = NULL;\n\n\tif (ie_len > 0) {\n\t\tpmlmepriv->wps_beacon_ie = rtw_malloc(ie_len);\n\t\tpmlmepriv->wps_beacon_ie_len = ie_len;\n\t\tif (!pmlmepriv->wps_beacon_ie)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(pmlmepriv->wps_beacon_ie, param->u.bcn_ie.buf, ie_len);\n\n\t\tupdate_beacon(padapter, WLAN_EID_VENDOR_SPECIFIC, wps_oui, true);\n\n\t\tpmlmeext->bstart_bss = true;\n\t}\n\n\treturn ret;\n}\n\nstatic int rtw_set_wps_probe_resp(struct net_device *dev, struct ieee_param *param, int len)\n{\n\tint ret = 0;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tint ie_len;\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\n\t\treturn -EINVAL;\n\n\tie_len = len - 12 - 2; \n\n\tkfree(pmlmepriv->wps_probe_resp_ie);\n\tpmlmepriv->wps_probe_resp_ie = NULL;\n\n\tif (ie_len > 0) {\n\t\tpmlmepriv->wps_probe_resp_ie = rtw_malloc(ie_len);\n\t\tpmlmepriv->wps_probe_resp_ie_len = ie_len;\n\t\tif (!pmlmepriv->wps_probe_resp_ie)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(pmlmepriv->wps_probe_resp_ie, param->u.bcn_ie.buf, ie_len);\n\t}\n\n\treturn ret;\n}\n\nstatic int rtw_set_wps_assoc_resp(struct net_device *dev, struct ieee_param *param, int len)\n{\n\tint ret = 0;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tint ie_len;\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\n\t\treturn -EINVAL;\n\n\tie_len = len - 12 - 2; \n\n\tkfree(pmlmepriv->wps_assoc_resp_ie);\n\tpmlmepriv->wps_assoc_resp_ie = NULL;\n\n\tif (ie_len > 0) {\n\t\tpmlmepriv->wps_assoc_resp_ie = rtw_malloc(ie_len);\n\t\tpmlmepriv->wps_assoc_resp_ie_len = ie_len;\n\t\tif (!pmlmepriv->wps_assoc_resp_ie)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(pmlmepriv->wps_assoc_resp_ie, param->u.bcn_ie.buf, ie_len);\n\t}\n\n\treturn ret;\n}\n\nstatic int rtw_set_hidden_ssid(struct net_device *dev, struct ieee_param *param, int len)\n{\n\tint ret = 0;\n\tstruct adapter *adapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *mlmepriv = &adapter->mlmepriv;\n\tstruct mlme_ext_priv *mlmeext = &adapter->mlmeextpriv;\n\tstruct mlme_ext_info *mlmeinfo = &mlmeext->mlmext_info;\n\tint ie_len;\n\tu8 *ssid_ie;\n\tchar ssid[NDIS_802_11_LENGTH_SSID + 1];\n\tsigned int ssid_len;\n\tu8 ignore_broadcast_ssid;\n\n\tif (check_fwstate(mlmepriv, WIFI_AP_STATE) != true)\n\t\treturn -EPERM;\n\n\tif (param->u.bcn_ie.reserved[0] != 0xea)\n\t\treturn -EINVAL;\n\n\tmlmeinfo->hidden_ssid_mode = ignore_broadcast_ssid = param->u.bcn_ie.reserved[1];\n\n\tie_len = len - 12 - 2; \n\tssid_ie = rtw_get_ie(param->u.bcn_ie.buf,  WLAN_EID_SSID, &ssid_len, ie_len);\n\n\tif (ssid_ie && ssid_len > 0 && ssid_len <= NDIS_802_11_LENGTH_SSID) {\n\t\tstruct wlan_bssid_ex *pbss_network = &mlmepriv->cur_network.network;\n\t\tstruct wlan_bssid_ex *pbss_network_ext = &mlmeinfo->network;\n\n\t\tmemcpy(ssid, ssid_ie + 2, ssid_len);\n\t\tssid[ssid_len] = 0x0;\n\n\t\tmemcpy(pbss_network->ssid.ssid, (void *)ssid, ssid_len);\n\t\tpbss_network->ssid.ssid_length = ssid_len;\n\t\tmemcpy(pbss_network_ext->ssid.ssid, (void *)ssid, ssid_len);\n\t\tpbss_network_ext->ssid.ssid_length = ssid_len;\n\t}\n\n\treturn ret;\n}\n\nstatic int rtw_ioctl_acl_remove_sta(struct net_device *dev, struct ieee_param *param, int len)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\n\t\treturn -EINVAL;\n\n\tif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\n\t    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\n\t    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {\n\t\treturn -EINVAL;\n\t}\n\n\trtw_acl_remove_sta(padapter, param->sta_addr);\n\treturn 0;\n}\n\nstatic int rtw_ioctl_acl_add_sta(struct net_device *dev, struct ieee_param *param, int len)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\n\t\treturn -EINVAL;\n\n\tif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\n\t    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\n\t    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn rtw_acl_add_sta(padapter, param->sta_addr);\n}\n\nstatic int rtw_ioctl_set_macaddr_acl(struct net_device *dev, struct ieee_param *param, int len)\n{\n\tint ret = 0;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\n\t\treturn -EINVAL;\n\n\trtw_set_macaddr_acl(padapter, param->u.mlme.command);\n\n\treturn ret;\n}\n\nstatic int rtw_hostapd_ioctl(struct net_device *dev, struct iw_point *p)\n{\n\tstruct ieee_param *param;\n\tint ret = 0;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\n\t \n\n\tif (!padapter->hw_init_completed)\n\t\treturn -EPERM;\n\n\tif (!p->pointer || p->length != sizeof(*param))\n\t\treturn -EINVAL;\n\n\tparam = rtw_malloc(p->length);\n\tif (!param)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(param, p->pointer, p->length)) {\n\t\tkfree(param);\n\t\treturn -EFAULT;\n\t}\n\n\tswitch (param->cmd) {\n\tcase RTL871X_HOSTAPD_FLUSH:\n\n\t\trtw_hostapd_sta_flush(dev);\n\n\t\tbreak;\n\n\tcase RTL871X_HOSTAPD_ADD_STA:\n\n\t\tret = rtw_add_sta(dev, param);\n\n\t\tbreak;\n\n\tcase RTL871X_HOSTAPD_REMOVE_STA:\n\n\t\tret = rtw_del_sta(dev, param);\n\n\t\tbreak;\n\n\tcase RTL871X_HOSTAPD_SET_BEACON:\n\n\t\tret = rtw_set_beacon(dev, param, p->length);\n\n\t\tbreak;\n\n\tcase RTL871X_SET_ENCRYPTION:\n\n\t\tret = rtw_set_encryption(dev, param, p->length);\n\n\t\tbreak;\n\n\tcase RTL871X_HOSTAPD_GET_WPAIE_STA:\n\n\t\tret = rtw_get_sta_wpaie(dev, param);\n\n\t\tbreak;\n\n\tcase RTL871X_HOSTAPD_SET_WPS_BEACON:\n\n\t\tret = rtw_set_wps_beacon(dev, param, p->length);\n\n\t\tbreak;\n\n\tcase RTL871X_HOSTAPD_SET_WPS_PROBE_RESP:\n\n\t\tret = rtw_set_wps_probe_resp(dev, param, p->length);\n\n\t\tbreak;\n\n\tcase RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP:\n\n\t\tret = rtw_set_wps_assoc_resp(dev, param, p->length);\n\n\t\tbreak;\n\n\tcase RTL871X_HOSTAPD_SET_HIDDEN_SSID:\n\n\t\tret = rtw_set_hidden_ssid(dev, param, p->length);\n\n\t\tbreak;\n\n\tcase RTL871X_HOSTAPD_GET_INFO_STA:\n\n\t\tret = rtw_ioctl_get_sta_data(dev, param, p->length);\n\n\t\tbreak;\n\n\tcase RTL871X_HOSTAPD_SET_MACADDR_ACL:\n\n\t\tret = rtw_ioctl_set_macaddr_acl(dev, param, p->length);\n\n\t\tbreak;\n\n\tcase RTL871X_HOSTAPD_ACL_ADD_STA:\n\n\t\tret = rtw_ioctl_acl_add_sta(dev, param, p->length);\n\n\t\tbreak;\n\n\tcase RTL871X_HOSTAPD_ACL_REMOVE_STA:\n\n\t\tret = rtw_ioctl_acl_remove_sta(dev, param, p->length);\n\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (ret == 0 && copy_to_user(p->pointer, param, p->length))\n\t\tret = -EFAULT;\n\n\tkfree(param);\n\treturn ret;\n}\n\n \n\nint rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct iwreq *wrq = (struct iwreq *)rq;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase RTL_IOCTL_WPA_SUPPLICANT:\n\t\tret = wpa_supplicant_ioctl(dev, &wrq->u.data);\n\t\tbreak;\n\tcase RTL_IOCTL_HOSTAPD:\n\t\tret = rtw_hostapd_ioctl(dev, &wrq->u.data);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}