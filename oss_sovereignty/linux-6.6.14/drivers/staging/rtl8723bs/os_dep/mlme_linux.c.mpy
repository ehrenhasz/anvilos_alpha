{
  "module_name": "mlme_linux.c",
  "hash_id": "1669cacced0f559e7f86750de325052cf98a0704c3e4a664b2c50d1499a90db0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/os_dep/mlme_linux.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n\nstatic void _dynamic_check_timer_handler(struct timer_list *t)\n{\n\tstruct adapter *adapter =\n\t\tfrom_timer(adapter, t, mlmepriv.dynamic_chk_timer);\n\n\trtw_dynamic_check_timer_handler(adapter);\n\n\t_set_timer(&adapter->mlmepriv.dynamic_chk_timer, 2000);\n}\n\nstatic void _rtw_set_scan_deny_timer_hdl(struct timer_list *t)\n{\n\tstruct adapter *adapter =\n\t\tfrom_timer(adapter, t, mlmepriv.set_scan_deny_timer);\n\n\trtw_clear_scan_deny(adapter);\n}\n\nvoid rtw_init_mlme_timer(struct adapter *padapter)\n{\n\tstruct\tmlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\ttimer_setup(&pmlmepriv->assoc_timer, _rtw_join_timeout_handler, 0);\n\ttimer_setup(&pmlmepriv->scan_to_timer, rtw_scan_timeout_handler, 0);\n\ttimer_setup(&pmlmepriv->dynamic_chk_timer,\n\t\t    _dynamic_check_timer_handler, 0);\n\ttimer_setup(&pmlmepriv->set_scan_deny_timer,\n\t\t    _rtw_set_scan_deny_timer_hdl, 0);\n}\n\nvoid rtw_os_indicate_connect(struct adapter *adapter)\n{\n\tstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\n\n\tif ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||\n\t\t(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)) {\n\t\trtw_cfg80211_ibss_indicate_connect(adapter);\n\t} else {\n\t\trtw_cfg80211_indicate_connect(adapter);\n\t}\n\n\tnetif_carrier_on(adapter->pnetdev);\n\n\tif (adapter->pid[2] != 0)\n\t\trtw_signal_process(adapter->pid[2], SIGALRM);\n}\n\nvoid rtw_os_indicate_scan_done(struct adapter *padapter, bool aborted)\n{\n\trtw_cfg80211_indicate_scan_done(padapter, aborted);\n}\n\nstatic struct rt_pmkid_list   backupPMKIDList[NUM_PMKID_CACHE];\nvoid rtw_reset_securitypriv(struct adapter *adapter)\n{\n\tu8 backupPMKIDIndex = 0;\n\tu8 backupTKIPCountermeasure = 0x00;\n\tu32 backupTKIPcountermeasure_time = 0;\n\t \n\tstruct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;\n\n\tspin_lock_bh(&adapter->security_key_mutex);\n\n\tif (adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) {\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\n\t\tmemcpy(&backupPMKIDList[0], &adapter->securitypriv.PMKIDList[0], sizeof(struct rt_pmkid_list) * NUM_PMKID_CACHE);\n\t\tbackupPMKIDIndex = adapter->securitypriv.PMKIDIndex;\n\t\tbackupTKIPCountermeasure = adapter->securitypriv.btkip_countermeasure;\n\t\tbackupTKIPcountermeasure_time = adapter->securitypriv.btkip_countermeasure_time;\n\n\t\t \n\t\tpmlmeext->mgnt_80211w_IPN_rx = 0;\n\n\t\tmemset((unsigned char *)&adapter->securitypriv, 0, sizeof(struct security_priv));\n\n\t\t \n\t\t \n\t\tmemcpy(&adapter->securitypriv.PMKIDList[0], &backupPMKIDList[0], sizeof(struct rt_pmkid_list) * NUM_PMKID_CACHE);\n\t\tadapter->securitypriv.PMKIDIndex = backupPMKIDIndex;\n\t\tadapter->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;\n\t\tadapter->securitypriv.btkip_countermeasure_time = backupTKIPcountermeasure_time;\n\n\t\tadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;\n\t\tadapter->securitypriv.ndisencryptstatus = Ndis802_11WEPDisabled;\n\n\t} else {\n\t\t \n\t\t \n\t\t \n\t\tstruct security_priv *psec_priv = &adapter->securitypriv;\n\n\t\tpsec_priv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;   \n\t\tpsec_priv->dot11PrivacyAlgrthm = _NO_PRIVACY_;\n\t\tpsec_priv->dot11PrivacyKeyIndex = 0;\n\n\t\tpsec_priv->dot118021XGrpPrivacy = _NO_PRIVACY_;\n\t\tpsec_priv->dot118021XGrpKeyid = 1;\n\n\t\tpsec_priv->ndisauthtype = Ndis802_11AuthModeOpen;\n\t\tpsec_priv->ndisencryptstatus = Ndis802_11WEPDisabled;\n\t\t \n\t}\n\t \n\tspin_unlock_bh(&adapter->security_key_mutex);\n}\n\nvoid rtw_os_indicate_disconnect(struct adapter *adapter)\n{\n\t \n\n\tnetif_carrier_off(adapter->pnetdev);  \n\n\trtw_cfg80211_indicate_disconnect(adapter);\n\n\t \n\trtw_reset_securitypriv_cmd(adapter);\n}\n\nvoid rtw_report_sec_ie(struct adapter *adapter, u8 authmode, u8 *sec_ie)\n{\n\tuint\tlen;\n\tu8 *buff, *p, i;\n\tunion iwreq_data wrqu;\n\n\tbuff = NULL;\n\tif (authmode == WLAN_EID_VENDOR_SPECIFIC) {\n\t\tbuff = rtw_zmalloc(IW_CUSTOM_MAX);\n\t\tif (!buff)\n\t\t\treturn;\n\n\t\tp = buff;\n\n\t\tp += scnprintf(p, IW_CUSTOM_MAX - (p - buff), \"ASSOCINFO(ReqIEs =\");\n\n\t\tlen = sec_ie[1] + 2;\n\t\tlen = (len < IW_CUSTOM_MAX) ? len : IW_CUSTOM_MAX;\n\n\t\tfor (i = 0; i < len; i++)\n\t\t\tp += scnprintf(p, IW_CUSTOM_MAX - (p - buff), \"%02x\", sec_ie[i]);\n\n\t\tp += scnprintf(p, IW_CUSTOM_MAX - (p - buff), \")\");\n\n\t\tmemset(&wrqu, 0, sizeof(wrqu));\n\n\t\twrqu.data.length = p - buff;\n\n\t\twrqu.data.length = (wrqu.data.length < IW_CUSTOM_MAX) ? wrqu.data.length : IW_CUSTOM_MAX;\n\n\t\tkfree(buff);\n\t}\n}\n\nvoid init_addba_retry_timer(struct adapter *padapter, struct sta_info *psta)\n{\n\ttimer_setup(&psta->addba_retry_timer, addba_timer_hdl, 0);\n}\n\nvoid init_mlme_ext_timer(struct adapter *padapter)\n{\n\tstruct\tmlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\n\ttimer_setup(&pmlmeext->survey_timer, survey_timer_hdl, 0);\n\ttimer_setup(&pmlmeext->link_timer, link_timer_hdl, 0);\n\ttimer_setup(&pmlmeext->sa_query_timer, sa_query_timer_hdl, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}