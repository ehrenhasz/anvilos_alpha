{
  "module_name": "recv_linux.c",
  "hash_id": "56f846d7f5d4ae0915e12d093e5f8f367df3259c49c520bd12001595374b016a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/os_dep/recv_linux.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <linux/jiffies.h>\n#include <net/cfg80211.h>\n#include <asm/unaligned.h>\n\nvoid rtw_os_free_recvframe(union recv_frame *precvframe)\n{\n\tif (precvframe->u.hdr.pkt) {\n\t\tdev_kfree_skb_any(precvframe->u.hdr.pkt); \n\n\t\tprecvframe->u.hdr.pkt = NULL;\n\t}\n}\n\n \nvoid rtw_os_recv_resource_alloc(struct adapter *padapter, union recv_frame *precvframe)\n{\n\tprecvframe->u.hdr.pkt_newalloc = precvframe->u.hdr.pkt = NULL;\n}\n\n \nvoid rtw_os_recv_resource_free(struct recv_priv *precvpriv)\n{\n\tsigned int i;\n\tunion recv_frame *precvframe;\n\n\tprecvframe = (union recv_frame *) precvpriv->precv_frame_buf;\n\n\tfor (i = 0; i < NR_RECVFRAME; i++) {\n\t\tif (precvframe->u.hdr.pkt) {\n\t\t\t \n\t\t\tdev_kfree_skb_any(precvframe->u.hdr.pkt);\n\t\t\tprecvframe->u.hdr.pkt = NULL;\n\t\t}\n\t\tprecvframe++;\n\t}\n}\n\n \nvoid rtw_os_recvbuf_resource_free(struct adapter *padapter, struct recv_buf *precvbuf)\n{\n\tif (precvbuf->pskb) {\n\t\tdev_kfree_skb_any(precvbuf->pskb);\n\t}\n}\n\nstruct sk_buff *rtw_os_alloc_msdu_pkt(union recv_frame *prframe, u16 nSubframe_Length, u8 *pdata)\n{\n\tu16 eth_type;\n\tstruct sk_buff *sub_skb;\n\tstruct rx_pkt_attrib *pattrib;\n\n\tpattrib = &prframe->u.hdr.attrib;\n\n\tsub_skb = rtw_skb_alloc(nSubframe_Length + 12);\n\tif (!sub_skb)\n\t\treturn NULL;\n\n\tskb_reserve(sub_skb, 12);\n\tskb_put_data(sub_skb, (pdata + ETH_HLEN), nSubframe_Length);\n\n\teth_type = get_unaligned_be16(&sub_skb->data[6]);\n\n\tif (sub_skb->len >= 8 &&\n\t\t((!memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) &&\n\t\t  eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||\n\t\t !memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE))) {\n\t\t \n\t\tskb_pull(sub_skb, SNAP_SIZE);\n\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src, ETH_ALEN);\n\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst, ETH_ALEN);\n\t} else {\n\t\t__be16 len;\n\t\t \n\t\tlen = htons(sub_skb->len);\n\t\tmemcpy(skb_push(sub_skb, 2), &len, 2);\n\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src, ETH_ALEN);\n\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst, ETH_ALEN);\n\t}\n\n\treturn sub_skb;\n}\n\nvoid rtw_os_recv_indicate_pkt(struct adapter *padapter, struct sk_buff *pkt, struct rx_pkt_attrib *pattrib)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\t \n\tif (pkt) {\n\t\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {\n\t\t\tstruct sk_buff *pskb2 = NULL;\n\t\t\tstruct sta_info *psta = NULL;\n\t\t\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\t\t\tint bmcast = is_multicast_ether_addr(pattrib->dst);\n\n\t\t\tif (memcmp(pattrib->dst, myid(&padapter->eeprompriv), ETH_ALEN)) {\n\t\t\t\tif (bmcast) {\n\t\t\t\t\tpsta = rtw_get_bcmc_stainfo(padapter);\n\t\t\t\t\tpskb2 = skb_clone(pkt, GFP_ATOMIC);\n\t\t\t\t} else {\n\t\t\t\t\tpsta = rtw_get_stainfo(pstapriv, pattrib->dst);\n\t\t\t\t}\n\n\t\t\t\tif (psta) {\n\t\t\t\t\tstruct net_device *pnetdev = (struct net_device *)padapter->pnetdev;\n\t\t\t\t\t \n\t\t\t\t\tpkt->dev = pnetdev;\n\t\t\t\t\tskb_set_queue_mapping(pkt, rtw_recv_select_queue(pkt));\n\n\t\t\t\t\t_rtw_xmit_entry(pkt, pnetdev);\n\n\t\t\t\t\tif (bmcast && pskb2)\n\t\t\t\t\t\tpkt = pskb2;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t}\n\t\t}\n\n\t\tpkt->protocol = eth_type_trans(pkt, padapter->pnetdev);\n\t\tpkt->dev = padapter->pnetdev;\n\n\t\tpkt->ip_summed = CHECKSUM_NONE;\n\n\t\trtw_netif_rx(padapter->pnetdev, pkt);\n\t}\n}\n\nvoid rtw_handle_tkip_mic_err(struct adapter *padapter, u8 bgroup)\n{\n\tenum nl80211_key_type key_type = 0;\n\tunion iwreq_data wrqu;\n\tstruct iw_michaelmicfailure    ev;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tunsigned long cur_time = 0;\n\n\tif (psecuritypriv->last_mic_err_time == 0) {\n\t\tpsecuritypriv->last_mic_err_time = jiffies;\n\t} else {\n\t\tcur_time = jiffies;\n\n\t\tif (cur_time - psecuritypriv->last_mic_err_time < 60*HZ) {\n\t\t\tpsecuritypriv->btkip_countermeasure = true;\n\t\t\tpsecuritypriv->last_mic_err_time = 0;\n\t\t\tpsecuritypriv->btkip_countermeasure_time = cur_time;\n\t\t} else {\n\t\t\tpsecuritypriv->last_mic_err_time = jiffies;\n\t\t}\n\t}\n\n\tif (bgroup) {\n\t\tkey_type |= NL80211_KEYTYPE_GROUP;\n\t} else {\n\t\tkey_type |= NL80211_KEYTYPE_PAIRWISE;\n\t}\n\n\tcfg80211_michael_mic_failure(padapter->pnetdev, (u8 *)&pmlmepriv->assoc_bssid[0], key_type, -1,\n\t\tNULL, GFP_ATOMIC);\n\n\tmemset(&ev, 0x00, sizeof(ev));\n\tif (bgroup) {\n\t\tev.flags |= IW_MICFAILURE_GROUP;\n\t} else {\n\t\tev.flags |= IW_MICFAILURE_PAIRWISE;\n\t}\n\n\tev.src_addr.sa_family = ARPHRD_ETHER;\n\tmemcpy(ev.src_addr.sa_data, &pmlmepriv->assoc_bssid[0], ETH_ALEN);\n\n\tmemset(&wrqu, 0x00, sizeof(wrqu));\n\twrqu.data.length = sizeof(ev);\n}\n\nint rtw_recv_indicatepkt(struct adapter *padapter, union recv_frame *precv_frame)\n{\n\tstruct recv_priv *precvpriv;\n\tstruct __queue\t*pfree_recv_queue;\n\tstruct sk_buff *skb;\n\tstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\n\n\tprecvpriv = &(padapter->recvpriv);\n\tpfree_recv_queue = &(precvpriv->free_recv_queue);\n\n\tskb = precv_frame->u.hdr.pkt;\n\tif (!skb)\n\t\tgoto _recv_indicatepkt_drop;\n\n\tskb->data = precv_frame->u.hdr.rx_data;\n\n\tskb_set_tail_pointer(skb, precv_frame->u.hdr.len);\n\n\tskb->len = precv_frame->u.hdr.len;\n\n\trtw_os_recv_indicate_pkt(padapter, skb, pattrib);\n\n\t \n\tprecv_frame->u.hdr.pkt = NULL;\n\n\trtw_free_recvframe(precv_frame, pfree_recv_queue);\n\n\treturn _SUCCESS;\n\n_recv_indicatepkt_drop:\n\n\t \n\trtw_free_recvframe(precv_frame, pfree_recv_queue);\n\n\treturn _FAIL;\n}\n\nvoid rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl)\n{\n\ttimer_setup(&preorder_ctrl->reordering_ctrl_timer,\n\t\t    rtw_reordering_ctrl_timeout_handler, 0);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}