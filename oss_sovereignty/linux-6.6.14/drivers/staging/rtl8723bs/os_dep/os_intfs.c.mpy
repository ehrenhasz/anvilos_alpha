{
  "module_name": "os_intfs.c",
  "hash_id": "47ac73fb71ea5a96a15848cfb1f44d821ac048507e8b466a9d63f5521a734200",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/os_dep/os_intfs.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <hal_data.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Realtek Wireless Lan Driver\");\nMODULE_AUTHOR(\"Realtek Semiconductor Corp.\");\nMODULE_VERSION(DRIVERVERSION);\n\n \nstatic int rtw_chip_version;\nstatic int rtw_rfintfs = HWPI;\nstatic int rtw_lbkmode; \n\n\nstatic int rtw_network_mode = Ndis802_11IBSS; \n \nstatic int rtw_channel = 1; \nstatic int rtw_wireless_mode = WIRELESS_11BG_24N;\nstatic int rtw_vrtl_carrier_sense = AUTO_VCS;\nstatic int rtw_vcs_type = RTS_CTS; \nstatic int rtw_rts_thresh = 2347; \nstatic int rtw_frag_thresh = 2346; \nstatic int rtw_preamble = PREAMBLE_LONG; \nstatic int rtw_scan_mode = 1; \nstatic int rtw_adhoc_tx_pwr = 1;\nstatic int rtw_soft_ap;\n \nstatic int rtw_power_mgnt = 1;\nstatic int rtw_ips_mode = IPS_NORMAL;\nmodule_param(rtw_ips_mode, int, 0644);\nMODULE_PARM_DESC(rtw_ips_mode, \"The default IPS mode\");\n\nstatic int rtw_smart_ps = 2;\n\nstatic int rtw_check_fw_ps = 1;\n\nstatic int rtw_usb_rxagg_mode = 2; \nmodule_param(rtw_usb_rxagg_mode, int, 0644);\n\nstatic int rtw_radio_enable = 1;\nstatic int rtw_long_retry_lmt = 7;\nstatic int rtw_short_retry_lmt = 7;\nstatic int rtw_busy_thresh = 40;\n \nstatic int rtw_ack_policy = NORMAL_ACK;\n\nstatic int rtw_software_encrypt;\nstatic int rtw_software_decrypt;\n\nstatic int rtw_acm_method; \n\nstatic int rtw_wmm_enable = 1; \nstatic int rtw_uapsd_enable;\nstatic int rtw_uapsd_max_sp = NO_LIMIT;\nstatic int rtw_uapsd_acbk_en;\nstatic int rtw_uapsd_acbe_en;\nstatic int rtw_uapsd_acvi_en;\nstatic int rtw_uapsd_acvo_en;\n\nint rtw_ht_enable = 1;\n \nstatic int rtw_bw_mode = 0x01;\nstatic int rtw_ampdu_enable = 1; \nstatic int rtw_rx_stbc = 1; \nstatic int rtw_ampdu_amsdu; \n \n \n \n \n \nstatic int rtw_short_gi = 0xf;\n \nstatic int rtw_ldpc_cap = 0x33;\n \nstatic int rtw_stbc_cap = 0x13;\n \nstatic int rtw_beamform_cap = 0x2;\n\nstatic int rtw_lowrate_two_xmit = 1; \n\nstatic int rtw_low_power;\nstatic int rtw_wifi_spec;\nstatic int rtw_channel_plan = RT_CHANNEL_DOMAIN_MAX;\n\nstatic int rtw_ant_num = -1;  \nmodule_param(rtw_ant_num, int, 0644);\nMODULE_PARM_DESC(rtw_ant_num, \"Antenna number setting\");\n\nstatic int rtw_antdiv_cfg = 1;  \nstatic int rtw_antdiv_type;  \n\n\n\nstatic int rtw_hw_wps_pbc;\n\nint rtw_mc2u_disable;\n\nstatic int rtw_80211d;\n\nstatic int rtw_qos_opt_enable; \nmodule_param(rtw_qos_opt_enable, int, 0644);\n\nstatic char *ifname = \"wlan%d\";\nmodule_param(ifname, charp, 0644);\nMODULE_PARM_DESC(ifname, \"The default name to allocate for first interface\");\n\nchar *rtw_initmac;   \n\nmodule_param(rtw_initmac, charp, 0644);\nmodule_param(rtw_channel_plan, int, 0644);\nmodule_param(rtw_chip_version, int, 0644);\nmodule_param(rtw_rfintfs, int, 0644);\nmodule_param(rtw_lbkmode, int, 0644);\nmodule_param(rtw_network_mode, int, 0644);\nmodule_param(rtw_channel, int, 0644);\nmodule_param(rtw_wmm_enable, int, 0644);\nmodule_param(rtw_vrtl_carrier_sense, int, 0644);\nmodule_param(rtw_vcs_type, int, 0644);\nmodule_param(rtw_busy_thresh, int, 0644);\n\nmodule_param(rtw_ht_enable, int, 0644);\nmodule_param(rtw_bw_mode, int, 0644);\nmodule_param(rtw_ampdu_enable, int, 0644);\nmodule_param(rtw_rx_stbc, int, 0644);\nmodule_param(rtw_ampdu_amsdu, int, 0644);\n\nmodule_param(rtw_lowrate_two_xmit, int, 0644);\n\nmodule_param(rtw_power_mgnt, int, 0644);\nmodule_param(rtw_smart_ps, int, 0644);\nmodule_param(rtw_low_power, int, 0644);\nmodule_param(rtw_wifi_spec, int, 0644);\n\nmodule_param(rtw_antdiv_cfg, int, 0644);\nmodule_param(rtw_antdiv_type, int, 0644);\n\n\nmodule_param(rtw_hw_wps_pbc, int, 0644);\n\nstatic uint rtw_max_roaming_times = 2;\nmodule_param(rtw_max_roaming_times, uint, 0644);\nMODULE_PARM_DESC(rtw_max_roaming_times, \"The max roaming times to try\");\n\nmodule_param(rtw_mc2u_disable, int, 0644);\n\nmodule_param(rtw_80211d, int, 0644);\nMODULE_PARM_DESC(rtw_80211d, \"Enable 802.11d mechanism\");\n\nstatic uint rtw_notch_filter;\nmodule_param(rtw_notch_filter, uint, 0644);\nMODULE_PARM_DESC(rtw_notch_filter, \"0:Disable, 1:Enable, 2:Enable only for P2P\");\n\n#define CONFIG_RTW_HIQ_FILTER 1\n\nstatic uint rtw_hiq_filter = CONFIG_RTW_HIQ_FILTER;\nmodule_param(rtw_hiq_filter, uint, 0644);\nMODULE_PARM_DESC(rtw_hiq_filter, \"0:allow all, 1:allow special, 2:deny all\");\n\nstatic int rtw_tx_pwr_lmt_enable;\nstatic int rtw_tx_pwr_by_rate;\n\nmodule_param(rtw_tx_pwr_lmt_enable, int, 0644);\nMODULE_PARM_DESC(rtw_tx_pwr_lmt_enable, \"0:Disable, 1:Enable, 2: Depend on efuse\");\n\nmodule_param(rtw_tx_pwr_by_rate, int, 0644);\nMODULE_PARM_DESC(rtw_tx_pwr_by_rate, \"0:Disable, 1:Enable, 2: Depend on efuse\");\n\nstatic int netdev_close(struct net_device *pnetdev);\n\nstatic void loadparam(struct adapter *padapter, struct net_device *pnetdev)\n{\n\tstruct registry_priv  *registry_par = &padapter->registrypriv;\n\n\tregistry_par->chip_version = (u8)rtw_chip_version;\n\tregistry_par->rfintfs = (u8)rtw_rfintfs;\n\tregistry_par->lbkmode = (u8)rtw_lbkmode;\n\t \n\tregistry_par->network_mode  = (u8)rtw_network_mode;\n\n\tmemcpy(registry_par->ssid.ssid, \"ANY\", 3);\n\tregistry_par->ssid.ssid_length = 3;\n\n\tregistry_par->channel = (u8)rtw_channel;\n\tregistry_par->wireless_mode = (u8)rtw_wireless_mode;\n\n\tregistry_par->vrtl_carrier_sense = (u8)rtw_vrtl_carrier_sense;\n\tregistry_par->vcs_type = (u8)rtw_vcs_type;\n\tregistry_par->rts_thresh = (u16)rtw_rts_thresh;\n\tregistry_par->frag_thresh = (u16)rtw_frag_thresh;\n\tregistry_par->preamble = (u8)rtw_preamble;\n\tregistry_par->scan_mode = (u8)rtw_scan_mode;\n\tregistry_par->adhoc_tx_pwr = (u8)rtw_adhoc_tx_pwr;\n\tregistry_par->soft_ap =  (u8)rtw_soft_ap;\n\tregistry_par->smart_ps =  (u8)rtw_smart_ps;\n\tregistry_par->check_fw_ps = (u8)rtw_check_fw_ps;\n\tregistry_par->power_mgnt = (u8)rtw_power_mgnt;\n\tregistry_par->ips_mode = (u8)rtw_ips_mode;\n\tregistry_par->radio_enable = (u8)rtw_radio_enable;\n\tregistry_par->long_retry_lmt = (u8)rtw_long_retry_lmt;\n\tregistry_par->short_retry_lmt = (u8)rtw_short_retry_lmt;\n\tregistry_par->busy_thresh = (u16)rtw_busy_thresh;\n\t \n\tregistry_par->ack_policy = (u8)rtw_ack_policy;\n\tregistry_par->software_encrypt = (u8)rtw_software_encrypt;\n\tregistry_par->software_decrypt = (u8)rtw_software_decrypt;\n\n\tregistry_par->acm_method = (u8)rtw_acm_method;\n\tregistry_par->usb_rxagg_mode = (u8)rtw_usb_rxagg_mode;\n\n\t  \n\tregistry_par->wmm_enable = (u8)rtw_wmm_enable;\n\tregistry_par->uapsd_enable = (u8)rtw_uapsd_enable;\n\tregistry_par->uapsd_max_sp = (u8)rtw_uapsd_max_sp;\n\tregistry_par->uapsd_acbk_en = (u8)rtw_uapsd_acbk_en;\n\tregistry_par->uapsd_acbe_en = (u8)rtw_uapsd_acbe_en;\n\tregistry_par->uapsd_acvi_en = (u8)rtw_uapsd_acvi_en;\n\tregistry_par->uapsd_acvo_en = (u8)rtw_uapsd_acvo_en;\n\n\tregistry_par->ht_enable = (u8)rtw_ht_enable;\n\tregistry_par->bw_mode = (u8)rtw_bw_mode;\n\tregistry_par->ampdu_enable = (u8)rtw_ampdu_enable;\n\tregistry_par->rx_stbc = (u8)rtw_rx_stbc;\n\tregistry_par->ampdu_amsdu = (u8)rtw_ampdu_amsdu;\n\tregistry_par->short_gi = (u8)rtw_short_gi;\n\tregistry_par->ldpc_cap = (u8)rtw_ldpc_cap;\n\tregistry_par->stbc_cap = (u8)rtw_stbc_cap;\n\tregistry_par->beamform_cap = (u8)rtw_beamform_cap;\n\n\tregistry_par->lowrate_two_xmit = (u8)rtw_lowrate_two_xmit;\n\tregistry_par->low_power = (u8)rtw_low_power;\n\n\n\tregistry_par->wifi_spec = (u8)rtw_wifi_spec;\n\n\tregistry_par->channel_plan = (u8)rtw_channel_plan;\n\n\tregistry_par->ant_num = (s8)rtw_ant_num;\n\n\tregistry_par->accept_addba_req = true;\n\n\tregistry_par->antdiv_cfg = (u8)rtw_antdiv_cfg;\n\tregistry_par->antdiv_type = (u8)rtw_antdiv_type;\n\n\tregistry_par->hw_wps_pbc = (u8)rtw_hw_wps_pbc;\n\n\tregistry_par->max_roaming_times = (u8)rtw_max_roaming_times;\n\n\tregistry_par->enable80211d = (u8)rtw_80211d;\n\n\tsnprintf(registry_par->ifname, 16, \"%s\", ifname);\n\n\tregistry_par->notch_filter = (u8)rtw_notch_filter;\n\n\tregistry_par->RegEnableTxPowerLimit = (u8)rtw_tx_pwr_lmt_enable;\n\tregistry_par->RegEnableTxPowerByRate = (u8)rtw_tx_pwr_by_rate;\n\n\tregistry_par->RegPowerBase = 14;\n\tregistry_par->TxBBSwing_2G = 0xFF;\n\tregistry_par->bEn_RFE = 1;\n\tregistry_par->RFE_Type = 64;\n\n\tregistry_par->qos_opt_enable = (u8)rtw_qos_opt_enable;\n\n\tregistry_par->hiq_filter = (u8)rtw_hiq_filter;\n}\n\nstatic int rtw_net_set_mac_address(struct net_device *pnetdev, void *p)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(pnetdev);\n\tstruct sockaddr *addr = p;\n\n\tif (!padapter->bup) {\n\t\t \n\t\tmemcpy(padapter->eeprompriv.mac_addr, addr->sa_data, ETH_ALEN);\n\t\t \n\t\t \n\t}\n\n\treturn 0;\n}\n\nstatic struct net_device_stats *rtw_net_get_stats(struct net_device *pnetdev)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(pnetdev);\n\tstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\n\tstruct recv_priv *precvpriv = &(padapter->recvpriv);\n\n\tpadapter->stats.tx_packets = pxmitpriv->tx_pkts; \n\tpadapter->stats.rx_packets = precvpriv->rx_pkts; \n\tpadapter->stats.tx_dropped = pxmitpriv->tx_drop;\n\tpadapter->stats.rx_dropped = precvpriv->rx_drop;\n\tpadapter->stats.tx_bytes = pxmitpriv->tx_bytes;\n\tpadapter->stats.rx_bytes = precvpriv->rx_bytes;\n\n\treturn &padapter->stats;\n}\n\n \nstatic const u16 rtw_1d_to_queue[8] = { 2, 3, 3, 2, 1, 1, 0, 0 };\n\n \nstatic unsigned int rtw_classify8021d(struct sk_buff *skb)\n{\n\tunsigned int dscp;\n\n\t \n\tif (skb->priority >= 256 && skb->priority <= 263)\n\t\treturn skb->priority - 256;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tdscp = ip_hdr(skb)->tos & 0xfc;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn dscp >> 5;\n}\n\n\nstatic u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t    struct net_device *sb_dev)\n{\n\tstruct adapter\t*padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tskb->priority = rtw_classify8021d(skb);\n\n\tif (pmlmepriv->acm_mask != 0)\n\t\tskb->priority = qos_acm(pmlmepriv->acm_mask, skb->priority);\n\n\treturn rtw_1d_to_queue[skb->priority];\n}\n\nu16 rtw_recv_select_queue(struct sk_buff *skb)\n{\n\tstruct iphdr *piphdr;\n\tunsigned int dscp;\n\t__be16\teth_type;\n\tu32 priority;\n\tu8 *pdata = skb->data;\n\n\tmemcpy(&eth_type, pdata + (ETH_ALEN << 1), 2);\n\n\tswitch (be16_to_cpu(eth_type)) {\n\tcase ETH_P_IP:\n\n\t\tpiphdr = (struct iphdr *)(pdata + ETH_HLEN);\n\n\t\tdscp = piphdr->tos & 0xfc;\n\n\t\tpriority = dscp >> 5;\n\n\t\tbreak;\n\tdefault:\n\t\tpriority = 0;\n\t}\n\n\treturn rtw_1d_to_queue[priority];\n}\n\nstatic int rtw_ndev_notifier_call(struct notifier_block *nb, unsigned long state, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (dev->netdev_ops->ndo_do_ioctl != rtw_ioctl)\n\t\treturn NOTIFY_DONE;\n\n\tnetdev_dbg(dev, FUNC_NDEV_FMT \" state:%lu\\n\", FUNC_NDEV_ARG(dev),\n\t\t    state);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block rtw_ndev_notifier = {\n\t.notifier_call = rtw_ndev_notifier_call,\n};\n\nint rtw_ndev_notifier_register(void)\n{\n\treturn register_netdevice_notifier(&rtw_ndev_notifier);\n}\n\nvoid rtw_ndev_notifier_unregister(void)\n{\n\tunregister_netdevice_notifier(&rtw_ndev_notifier);\n}\n\n\nstatic int rtw_ndev_init(struct net_device *dev)\n{\n\tstruct adapter *adapter = rtw_netdev_priv(dev);\n\n\tnetdev_dbg(dev, FUNC_ADPT_FMT \"\\n\", FUNC_ADPT_ARG(adapter));\n\tstrncpy(adapter->old_ifname, dev->name, IFNAMSIZ);\n\n\treturn 0;\n}\n\nstatic void rtw_ndev_uninit(struct net_device *dev)\n{\n\tstruct adapter *adapter = rtw_netdev_priv(dev);\n\n\tnetdev_dbg(dev, FUNC_ADPT_FMT \"\\n\", FUNC_ADPT_ARG(adapter));\n}\n\nstatic const struct net_device_ops rtw_netdev_ops = {\n\t.ndo_init = rtw_ndev_init,\n\t.ndo_uninit = rtw_ndev_uninit,\n\t.ndo_open = netdev_open,\n\t.ndo_stop = netdev_close,\n\t.ndo_start_xmit = rtw_xmit_entry,\n\t.ndo_select_queue\t= rtw_select_queue,\n\t.ndo_set_mac_address = rtw_net_set_mac_address,\n\t.ndo_get_stats = rtw_net_get_stats,\n\t.ndo_do_ioctl = rtw_ioctl,\n};\n\nint rtw_init_netdev_name(struct net_device *pnetdev, const char *ifname)\n{\n\tif (dev_alloc_name(pnetdev, ifname) < 0) {\n\t\tpr_err(\"dev_alloc_name, fail for %s\\n\", ifname);\n\t\treturn 1;\n\t}\n\tnetif_carrier_off(pnetdev);\n\t \n\n\treturn 0;\n}\n\nstruct net_device *rtw_init_netdev(struct adapter *old_padapter)\n{\n\tstruct adapter *padapter;\n\tstruct net_device *pnetdev;\n\n\tif (old_padapter)\n\t\tpnetdev = rtw_alloc_etherdev_with_old_priv(sizeof(struct adapter), (void *)old_padapter);\n\telse\n\t\tpnetdev = rtw_alloc_etherdev(sizeof(struct adapter));\n\n\tpr_info(\"pnetdev = %p\\n\", pnetdev);\n\tif (!pnetdev)\n\t\treturn NULL;\n\n\tpadapter = rtw_netdev_priv(pnetdev);\n\tpadapter->pnetdev = pnetdev;\n\n\t \n\n\tpnetdev->netdev_ops = &rtw_netdev_ops;\n\n\t \n\tpnetdev->watchdog_timeo = HZ * 3;  \n\n\t \n\tloadparam(padapter, pnetdev);\n\n\treturn pnetdev;\n}\n\nvoid rtw_unregister_netdevs(struct dvobj_priv *dvobj)\n{\n\tstruct adapter *padapter = NULL;\n\tstruct net_device *pnetdev = NULL;\n\n\tpadapter = dvobj->padapters;\n\n\tif (!padapter)\n\t\treturn;\n\n\tpnetdev = padapter->pnetdev;\n\n\tif ((padapter->DriverState != DRIVER_DISAPPEAR) && pnetdev)\n\t\tunregister_netdev(pnetdev);  \n\trtw_wdev_unregister(padapter->rtw_wdev);\n}\n\nu32 rtw_start_drv_threads(struct adapter *padapter)\n{\n\tu32 _status = _SUCCESS;\n\n\tpadapter->xmitThread = kthread_run(rtw_xmit_thread, padapter, \"RTW_XMIT_THREAD\");\n\tif (IS_ERR(padapter->xmitThread))\n\t\t_status = _FAIL;\n\n\tpadapter->cmdThread = kthread_run(rtw_cmd_thread, padapter, \"RTW_CMD_THREAD\");\n\tif (IS_ERR(padapter->cmdThread))\n\t\t_status = _FAIL;\n\telse\n\t\twait_for_completion(&padapter->cmdpriv.terminate_cmdthread_comp);  \n\n\trtw_hal_start_thread(padapter);\n\treturn _status;\n}\n\nvoid rtw_stop_drv_threads(struct adapter *padapter)\n{\n\trtw_stop_cmd_thread(padapter);\n\n\t \n\tcomplete(&padapter->xmitpriv.xmit_comp);\n\twait_for_completion(&padapter->xmitpriv.terminate_xmitthread_comp);\n\n\trtw_hal_stop_thread(padapter);\n}\n\nstatic void rtw_init_default_value(struct adapter *padapter)\n{\n\tstruct registry_priv *pregistrypriv = &padapter->registrypriv;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\n\t \n\tpxmitpriv->vcs_setting = pregistrypriv->vrtl_carrier_sense;\n\tpxmitpriv->vcs = pregistrypriv->vcs_type;\n\tpxmitpriv->vcs_type = pregistrypriv->vcs_type;\n\t \n\tpxmitpriv->frag_len = pregistrypriv->frag_thresh;\n\n\t \n\n\t \n\tpmlmepriv->scan_mode = SCAN_ACTIVE;\n\n\t \n\t \n\n\t \n\tpmlmepriv->htpriv.ampdu_enable = false; \n\n\t \n\t \n\tpsecuritypriv->binstallGrpkey = _FAIL;\n\tpsecuritypriv->sw_encrypt = pregistrypriv->software_encrypt;\n\tpsecuritypriv->sw_decrypt = pregistrypriv->software_decrypt;\n\n\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;  \n\tpsecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;\n\n\tpsecuritypriv->dot11PrivacyKeyIndex = 0;\n\n\tpsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\n\tpsecuritypriv->dot118021XGrpKeyid = 1;\n\n\tpsecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;\n\tpsecuritypriv->ndisencryptstatus = Ndis802_11WEPDisabled;\n\n\t \n\trtw_init_registrypriv_dev_network(padapter);\n\trtw_update_registrypriv_dev_network(padapter);\n\n\t \n\trtw_hal_def_value_init(padapter);\n\n\t \n\tRTW_ENABLE_FUNC(padapter, DF_RX_BIT);\n\tRTW_ENABLE_FUNC(padapter, DF_TX_BIT);\n\tpadapter->bLinkInfoDump = 0;\n\tpadapter->bNotifyChannelChange = 0;\n\n\t \n\tpadapter->fix_rate = 0xFF;\n\tpadapter->driver_ampdu_spacing = 0xFF;\n\tpadapter->driver_rx_ampdu_factor =  0xFF;\n\n}\n\nstruct dvobj_priv *devobj_init(void)\n{\n\tstruct dvobj_priv *pdvobj = NULL;\n\n\tpdvobj = rtw_zmalloc(sizeof(*pdvobj));\n\tif (!pdvobj)\n\t\treturn NULL;\n\n\tmutex_init(&pdvobj->hw_init_mutex);\n\tmutex_init(&pdvobj->h2c_fwcmd_mutex);\n\tmutex_init(&pdvobj->setch_mutex);\n\tmutex_init(&pdvobj->setbw_mutex);\n\n\tspin_lock_init(&pdvobj->lock);\n\n\tpdvobj->macid[1] = true;  \n\n\tpdvobj->processing_dev_remove = false;\n\n\tatomic_set(&pdvobj->disable_func, 0);\n\n\tspin_lock_init(&pdvobj->cam_ctl.lock);\n\n\treturn pdvobj;\n}\n\nvoid devobj_deinit(struct dvobj_priv *pdvobj)\n{\n\tif (!pdvobj)\n\t\treturn;\n\n\tmutex_destroy(&pdvobj->hw_init_mutex);\n\tmutex_destroy(&pdvobj->h2c_fwcmd_mutex);\n\tmutex_destroy(&pdvobj->setch_mutex);\n\tmutex_destroy(&pdvobj->setbw_mutex);\n\n\tkfree(pdvobj);\n}\n\nvoid rtw_reset_drv_sw(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);\n\n\t \n\tif (is_primary_adapter(padapter))\n\t\trtw_hal_def_value_init(padapter);\n\n\tRTW_ENABLE_FUNC(padapter, DF_RX_BIT);\n\tRTW_ENABLE_FUNC(padapter, DF_TX_BIT);\n\tpadapter->bLinkInfoDump = 0;\n\n\tpadapter->xmitpriv.tx_pkts = 0;\n\tpadapter->recvpriv.rx_pkts = 0;\n\n\tpmlmepriv->LinkDetectInfo.bBusyTraffic = false;\n\n\t \n\tpmlmepriv->LinkDetectInfo.TrafficTransitionCount = 0;\n\tpmlmepriv->LinkDetectInfo.LowPowerTransitionCount = 0;\n\n\t_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY | _FW_UNDER_LINKING);\n\n\tpwrctrlpriv->pwr_state_check_cnts = 0;\n\n\t \n\tpadapter->mlmeextpriv.sitesurvey_res.state = SCAN_DISABLE;\n\n\trtw_set_signal_stat_timer(&padapter->recvpriv);\n\n}\n\n\nu8 rtw_init_drv_sw(struct adapter *padapter)\n{\n\trtw_init_default_value(padapter);\n\n\trtw_init_hal_com_default_value(padapter);\n\n\tif (rtw_init_cmd_priv(&padapter->cmdpriv))\n\t\treturn _FAIL;\n\n\tpadapter->cmdpriv.padapter = padapter;\n\n\tif (rtw_init_evt_priv(&padapter->evtpriv))\n\t\tgoto free_cmd_priv;\n\n\tif (rtw_init_mlme_priv(padapter) == _FAIL)\n\t\tgoto free_evt_priv;\n\n\tinit_mlme_ext_priv(padapter);\n\n\tif (_rtw_init_xmit_priv(&padapter->xmitpriv, padapter) == _FAIL)\n\t\tgoto free_mlme_ext;\n\n\tif (_rtw_init_recv_priv(&padapter->recvpriv, padapter) == _FAIL)\n\t\tgoto free_xmit_priv;\n\t \n\tspin_lock_init(&padapter->security_key_mutex);\n\n\t \n\t \n\n\tif (_rtw_init_sta_priv(&padapter->stapriv) == _FAIL)\n\t\tgoto free_recv_priv;\n\n\tpadapter->stapriv.padapter = padapter;\n\tpadapter->setband = GHZ24_50;\n\tpadapter->fix_rate = 0xFF;\n\trtw_init_bcmc_stainfo(padapter);\n\n\trtw_init_pwrctrl_priv(padapter);\n\n\trtw_hal_dm_init(padapter);\n\n\treturn _SUCCESS;\n\nfree_recv_priv:\n\t_rtw_free_recv_priv(&padapter->recvpriv);\n\nfree_xmit_priv:\n\t_rtw_free_xmit_priv(&padapter->xmitpriv);\n\nfree_mlme_ext:\n\tfree_mlme_ext_priv(&padapter->mlmeextpriv);\n\n\trtw_free_mlme_priv(&padapter->mlmepriv);\n\nfree_evt_priv:\n\trtw_free_evt_priv(&padapter->evtpriv);\n\nfree_cmd_priv:\n\trtw_free_cmd_priv(&padapter->cmdpriv);\n\n\treturn _FAIL;\n}\n\nvoid rtw_cancel_all_timer(struct adapter *padapter)\n{\n\tdel_timer_sync(&padapter->mlmepriv.assoc_timer);\n\n\tdel_timer_sync(&padapter->mlmepriv.scan_to_timer);\n\n\tdel_timer_sync(&padapter->mlmepriv.dynamic_chk_timer);\n\n\tdel_timer_sync(&(adapter_to_pwrctl(padapter)->pwr_state_check_timer));\n\n\tdel_timer_sync(&padapter->mlmepriv.set_scan_deny_timer);\n\trtw_clear_scan_deny(padapter);\n\n\tdel_timer_sync(&padapter->recvpriv.signal_stat_timer);\n\n\t \n\trtw_hal_dm_deinit(padapter);\n}\n\nu8 rtw_free_drv_sw(struct adapter *padapter)\n{\n\tfree_mlme_ext_priv(&padapter->mlmeextpriv);\n\n\trtw_free_cmd_priv(&padapter->cmdpriv);\n\n\trtw_free_evt_priv(&padapter->evtpriv);\n\n\trtw_free_mlme_priv(&padapter->mlmepriv);\n\n\t \n\n\t_rtw_free_xmit_priv(&padapter->xmitpriv);\n\n\t_rtw_free_sta_priv(&padapter->stapriv);  \n\n\t_rtw_free_recv_priv(&padapter->recvpriv);\n\n\trtw_free_pwrctrl_priv(padapter);\n\n\t \n\n\trtw_hal_free_data(padapter);\n\n\t \n\tif (padapter->rereg_nd_name_priv.old_pnetdev) {\n\t\tfree_netdev(padapter->rereg_nd_name_priv.old_pnetdev);\n\t\tpadapter->rereg_nd_name_priv.old_pnetdev = NULL;\n\t}\n\n\t \n\tif (padapter->pbuddy_adapter)\n\t\tpadapter->pbuddy_adapter->pbuddy_adapter = NULL;\n\n\treturn _SUCCESS;\n}\n\nstatic int _rtw_drv_register_netdev(struct adapter *padapter, char *name)\n{\n\tint ret = _SUCCESS;\n\tstruct net_device *pnetdev = padapter->pnetdev;\n\n\t \n\tif (rtw_init_netdev_name(pnetdev, name))\n\t\treturn _FAIL;\n\n\teth_hw_addr_set(pnetdev, padapter->eeprompriv.mac_addr);\n\n\t \n\tif (register_netdev(pnetdev) != 0) {\n\t\tret = _FAIL;\n\t\tgoto error_register_netdev;\n\t}\n\n\treturn ret;\n\nerror_register_netdev:\n\n\trtw_free_drv_sw(padapter);\n\n\trtw_free_netdev(pnetdev);\n\n\treturn ret;\n}\n\nint rtw_drv_register_netdev(struct adapter *if1)\n{\n\tstruct dvobj_priv *dvobj = if1->dvobj;\n\tstruct adapter *padapter = dvobj->padapters;\n\tchar *name = if1->registrypriv.ifname;\n\n\treturn _rtw_drv_register_netdev(padapter, name);\n}\n\nstatic int _netdev_open(struct net_device *pnetdev)\n{\n\tuint status;\n\tstruct adapter *padapter = rtw_netdev_priv(pnetdev);\n\tstruct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);\n\n\tpadapter->netif_up = true;\n\n\tif (pwrctrlpriv->ps_flag) {\n\t\tpadapter->net_closed = false;\n\t\tgoto netdev_open_normal_process;\n\t}\n\n\tif (!padapter->bup) {\n\t\tpadapter->bDriverStopped = false;\n\t\tpadapter->bSurpriseRemoved = false;\n\t\tpadapter->bCardDisableWOHSM = false;\n\n\t\tstatus = rtw_hal_init(padapter);\n\t\tif (status == _FAIL)\n\t\t\tgoto netdev_open_error;\n\n\t\tstatus = rtw_start_drv_threads(padapter);\n\t\tif (status == _FAIL)\n\t\t\tgoto netdev_open_error;\n\n\t\tif (padapter->intf_start)\n\t\t\tpadapter->intf_start(padapter);\n\n\t\trtw_cfg80211_init_wiphy(padapter);\n\n\t\tpadapter->bup = true;\n\t\tpwrctrlpriv->bips_processing = false;\n\t}\n\tpadapter->net_closed = false;\n\n\t_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);\n\n\tif (!rtw_netif_queue_stopped(pnetdev))\n\t\trtw_netif_start_queue(pnetdev);\n\telse\n\t\trtw_netif_wake_queue(pnetdev);\n\nnetdev_open_normal_process:\n\n\treturn 0;\n\nnetdev_open_error:\n\n\tpadapter->bup = false;\n\n\tnetif_carrier_off(pnetdev);\n\trtw_netif_stop_queue(pnetdev);\n\n\treturn (-1);\n}\n\nint netdev_open(struct net_device *pnetdev)\n{\n\tint ret;\n\tstruct adapter *padapter = rtw_netdev_priv(pnetdev);\n\tstruct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);\n\n\tif (pwrctrlpriv->bInSuspend)\n\t\treturn 0;\n\n\tif (mutex_lock_interruptible(&(adapter_to_dvobj(padapter)->hw_init_mutex)))\n\t\treturn -1;\n\n\tret = _netdev_open(pnetdev);\n\tmutex_unlock(&(adapter_to_dvobj(padapter)->hw_init_mutex));\n\n\treturn ret;\n}\n\nstatic int  ips_netdrv_open(struct adapter *padapter)\n{\n\tint status = _SUCCESS;\n\t \n\n\tpadapter->net_closed = false;\n\n\tpadapter->bDriverStopped = false;\n\tpadapter->bCardDisableWOHSM = false;\n\t \n\n\tstatus = rtw_hal_init(padapter);\n\tif (status == _FAIL)\n\t\tgoto netdev_open_error;\n\n\tif (padapter->intf_start)\n\t\tpadapter->intf_start(padapter);\n\n\t_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);\n\n\treturn _SUCCESS;\n\nnetdev_open_error:\n\n\treturn _FAIL;\n}\n\n\nint rtw_ips_pwr_up(struct adapter *padapter)\n{\n\treturn ips_netdrv_open(padapter);\n}\n\nvoid rtw_ips_pwr_down(struct adapter *padapter)\n{\n\tpadapter->bCardDisableWOHSM = true;\n\tpadapter->net_closed = true;\n\n\trtw_ips_dev_unload(padapter);\n\tpadapter->bCardDisableWOHSM = false;\n}\n\nvoid rtw_ips_dev_unload(struct adapter *padapter)\n{\n\n\tif (!padapter->bSurpriseRemoved)\n\t\trtw_hal_deinit(padapter);\n}\n\nstatic int pm_netdev_open(struct net_device *pnetdev, u8 bnormal)\n{\n\tint status = -1;\n\n\tstruct adapter *padapter = rtw_netdev_priv(pnetdev);\n\n\tif (bnormal) {\n\t\tif (mutex_lock_interruptible(&(adapter_to_dvobj(padapter)->hw_init_mutex)) == 0) {\n\t\t\tstatus = _netdev_open(pnetdev);\n\t\t\tmutex_unlock(&(adapter_to_dvobj(padapter)->hw_init_mutex));\n\t\t}\n\t} else {\n\t\tstatus =  (_SUCCESS == ips_netdrv_open(padapter)) ? (0) : (-1);\n\t}\n\n\treturn status;\n}\n\nstatic int netdev_close(struct net_device *pnetdev)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(pnetdev);\n\tstruct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);\n\n\tif (pwrctl->bInternalAutoSuspend) {\n\t\t \n\t\tif (pwrctl->rf_pwrstate == rf_off)\n\t\t\tpwrctl->ps_flag = true;\n\t}\n\tpadapter->net_closed = true;\n\tpadapter->netif_up = false;\n\n \n\tif (pwrctl->rf_pwrstate == rf_on) {\n\t\t \n\t\tif (pnetdev) {\n\t\t\tif (!rtw_netif_queue_stopped(pnetdev))\n\t\t\t\trtw_netif_stop_queue(pnetdev);\n\t\t}\n\n\t\t \n\t\tLeaveAllPowerSaveMode(padapter);\n\t\trtw_disassoc_cmd(padapter, 500, false);\n\t\t \n\t\trtw_indicate_disconnect(padapter);\n\t\t \n\t\trtw_free_assoc_resources(padapter, 1);\n\t\t \n\t\trtw_free_network_queue(padapter, true);\n\t}\n\n\trtw_scan_abort(padapter);\n\tadapter_wdev_data(padapter)->bandroid_scan = false;\n\n\treturn 0;\n}\n\nvoid rtw_ndev_destructor(struct net_device *ndev)\n{\n\tkfree(ndev->ieee80211_ptr);\n}\n\nvoid rtw_dev_unload(struct adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);\n\tstruct dvobj_priv *pobjpriv = padapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &pobjpriv->drv_dbg;\n\tstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\n\tu8 cnt = 0;\n\n\tif (padapter->bup) {\n\n\t\tpadapter->bDriverStopped = true;\n\t\tif (padapter->xmitpriv.ack_tx)\n\t\t\trtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_DRV_STOP);\n\n\t\tif (padapter->intf_stop)\n\t\t\tpadapter->intf_stop(padapter);\n\n\t\tif (!pwrctl->bInternalAutoSuspend)\n\t\t\trtw_stop_drv_threads(padapter);\n\n\t\twhile (atomic_read(&pcmdpriv->cmdthd_running)) {\n\t\t\tif (cnt > 5) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tcnt++;\n\t\t\t\tmsleep(10);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (rtw_hal_check_ips_status(padapter) || pwrctl->rf_pwrstate == rf_off) {\n\t\t\t \n\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t   \"%s: driver in IPS-FWLPS\\n\", __func__);\n\t\t\tpdbgpriv->dbg_dev_unload_inIPS_cnt++;\n\t\t\tLeaveAllPowerSaveMode(padapter);\n\t\t} else {\n\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t   \"%s: driver not in IPS\\n\", __func__);\n\t\t}\n\n\t\tif (!padapter->bSurpriseRemoved) {\n\t\t\thal_btcoex_IpsNotify(padapter, pwrctl->ips_mode_req);\n\n\t\t\t \n\t\t\trtw_hal_deinit(padapter);\n\n\t\t\tpadapter->bSurpriseRemoved = true;\n\t\t}\n\n\t\tpadapter->bup = false;\n\n\t}\n}\n\nstatic int rtw_suspend_free_assoc_resource(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tif (rtw_chk_roam_flags(padapter, RTW_ROAM_ON_RESUME)) {\n\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)\n\t\t\t&& check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\t\trtw_set_to_roam(padapter, 1);\n\t\t}\n\t}\n\n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) && check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\trtw_disassoc_cmd(padapter, 0, false);\n\t\t \n\t\trtw_indicate_disconnect(padapter);\n\t} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\trtw_sta_flush(padapter);\n\t}\n\n\t \n\trtw_free_assoc_resources(padapter, 1);\n\n\t \n\trtw_free_network_queue(padapter, true);\n\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))\n\t\trtw_indicate_scan_done(padapter, 1);\n\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) {\n\t\tnetdev_dbg(padapter->pnetdev, \"%s: fw_under_linking\\n\",\n\t\t\t   __func__);\n\t\trtw_indicate_disconnect(padapter);\n\t}\n\n\treturn _SUCCESS;\n}\n\nstatic void rtw_suspend_normal(struct adapter *padapter)\n{\n\tstruct net_device *pnetdev = padapter->pnetdev;\n\n\tif (pnetdev) {\n\t\tnetif_carrier_off(pnetdev);\n\t\trtw_netif_stop_queue(pnetdev);\n\t}\n\n\trtw_suspend_free_assoc_resource(padapter);\n\n\tif ((rtw_hal_check_ips_status(padapter)) || (adapter_to_pwrctl(padapter)->rf_pwrstate == rf_off))\n\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t   \"%s: ### ERROR #### driver in IPS ####ERROR###!!!\\n\",\n\t\t\t   __func__);\n\n\trtw_dev_unload(padapter);\n\n\t \n\tif (padapter->intf_deinit)\n\t\tpadapter->intf_deinit(adapter_to_dvobj(padapter));\n}\n\nvoid rtw_suspend_common(struct adapter *padapter)\n{\n\tstruct dvobj_priv *psdpriv = padapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\tstruct pwrctrl_priv *pwrpriv = dvobj_to_pwrctl(psdpriv);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tunsigned long start_time = jiffies;\n\n\tnetdev_dbg(padapter->pnetdev, \" suspend start\\n\");\n\tpdbgpriv->dbg_suspend_cnt++;\n\n\tpwrpriv->bInSuspend = true;\n\n\twhile (pwrpriv->bips_processing)\n\t\tmsleep(1);\n\n\tif ((!padapter->bup) || (padapter->bDriverStopped) || (padapter->bSurpriseRemoved)) {\n\t\tpdbgpriv->dbg_suspend_error_cnt++;\n\t\tgoto exit;\n\t}\n\trtw_ps_deny(padapter, PS_DENY_SUSPEND);\n\n\trtw_cancel_all_timer(padapter);\n\n\tLeaveAllPowerSaveModeDirect(padapter);\n\n\trtw_stop_cmd_thread(padapter);\n\n\t \n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE))\n\t\thal_btcoex_SuspendNotify(padapter, 0);\n\telse if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))\n\t\thal_btcoex_SuspendNotify(padapter, 1);\n\n\trtw_ps_deny_cancel(padapter, PS_DENY_SUSPEND);\n\n\trtw_suspend_normal(padapter);\n\n\tnetdev_dbg(padapter->pnetdev, \"rtw suspend success in %d ms\\n\",\n\t\t   jiffies_to_msecs(jiffies - start_time));\n\nexit:\n\n\treturn;\n}\n\nstatic int rtw_resume_process_normal(struct adapter *padapter)\n{\n\tstruct net_device *pnetdev;\n\tstruct pwrctrl_priv *pwrpriv;\n\tstruct mlme_priv *pmlmepriv;\n\tstruct dvobj_priv *psdpriv;\n\tstruct debug_priv *pdbgpriv;\n\n\tint ret = _SUCCESS;\n\n\tif (!padapter) {\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n\n\tpnetdev = padapter->pnetdev;\n\tpwrpriv = adapter_to_pwrctl(padapter);\n\tpmlmepriv = &padapter->mlmepriv;\n\tpsdpriv = padapter->dvobj;\n\tpdbgpriv = &psdpriv->drv_dbg;\n\t \n\t \n\tif ((padapter->intf_init) && (padapter->intf_init(adapter_to_dvobj(padapter)) != _SUCCESS)) {\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n\trtw_hal_disable_interrupt(padapter);\n\t \n\tif ((padapter->intf_alloc_irq) && (padapter->intf_alloc_irq(adapter_to_dvobj(padapter)) != _SUCCESS)) {\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n\n\trtw_reset_drv_sw(padapter);\n\tpwrpriv->bkeepfwalive = false;\n\n\tif (pm_netdev_open(pnetdev, true) != 0) {\n\t\tret = -1;\n\t\tpdbgpriv->dbg_resume_error_cnt++;\n\t\tgoto exit;\n\t}\n\n\tnetif_device_attach(pnetdev);\n\tnetif_carrier_on(pnetdev);\n\n\tif (padapter->pid[1] != 0)\n\t\trtw_signal_process(padapter->pid[1], SIGUSR2);\n\n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\n\t\tif (rtw_chk_roam_flags(padapter, RTW_ROAM_ON_RESUME))\n\t\t\trtw_roaming(padapter, NULL);\n\t} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\trtw_ap_restore_network(padapter);\n\t}\n\nexit:\n\treturn ret;\n}\n\nint rtw_resume_common(struct adapter *padapter)\n{\n\tint ret = 0;\n\tunsigned long start_time = jiffies;\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\n\tnetdev_dbg(padapter->pnetdev, \"resume start\\n\");\n\n\trtw_resume_process_normal(padapter);\n\n\thal_btcoex_SuspendNotify(padapter, 0);\n\n\tif (pwrpriv) {\n\t\tpwrpriv->bInSuspend = false;\n\t}\n\tnetdev_dbg(padapter->pnetdev, \"%s:%d in %d ms\\n\", __func__, ret,\n\t\t   jiffies_to_msecs(jiffies - start_time));\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}