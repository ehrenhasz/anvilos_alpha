{
  "module_name": "osdep_service.c",
  "hash_id": "74e7e0d3630a8aa54fdfff66ea987fefd141302cb4b35b1b83315ff1b7c5b276",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/os_dep/osdep_service.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n\n \ninline int RTW_STATUS_CODE(int error_code)\n{\n\tif (error_code >= 0)\n\t\treturn _SUCCESS;\n\treturn _FAIL;\n}\n\nvoid *_rtw_malloc(u32 sz)\n{\n\treturn kmalloc(sz, in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);\n}\n\nvoid *_rtw_zmalloc(u32 sz)\n{\n\tvoid *pbuf = _rtw_malloc(sz);\n\n\tif (pbuf)\n\t\tmemset(pbuf, 0, sz);\n\n\treturn pbuf;\n}\n\ninline struct sk_buff *_rtw_skb_alloc(u32 sz)\n{\n\treturn __dev_alloc_skb(sz, in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);\n}\n\ninline struct sk_buff *_rtw_skb_copy(const struct sk_buff *skb)\n{\n\treturn skb_copy(skb, in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);\n}\n\ninline int _rtw_netif_rx(struct net_device *ndev, struct sk_buff *skb)\n{\n\tskb->dev = ndev;\n\treturn netif_rx(skb);\n}\n\nstruct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_priv)\n{\n\tstruct net_device *pnetdev;\n\tstruct rtw_netdev_priv_indicator *pnpi;\n\n\tpnetdev = alloc_etherdev_mq(sizeof(struct rtw_netdev_priv_indicator), 4);\n\tif (!pnetdev)\n\t\tgoto RETURN;\n\n\tpnpi = netdev_priv(pnetdev);\n\tpnpi->priv = old_priv;\n\tpnpi->sizeof_priv = sizeof_priv;\n\nRETURN:\n\treturn pnetdev;\n}\n\nstruct net_device *rtw_alloc_etherdev(int sizeof_priv)\n{\n\tstruct net_device *pnetdev;\n\tstruct rtw_netdev_priv_indicator *pnpi;\n\n\tpnetdev = alloc_etherdev_mq(sizeof(struct rtw_netdev_priv_indicator), 4);\n\tif (!pnetdev)\n\t\tgoto RETURN;\n\n\tpnpi = netdev_priv(pnetdev);\n\n\tpnpi->priv = vzalloc(sizeof_priv);\n\tif (!pnpi->priv) {\n\t\tfree_netdev(pnetdev);\n\t\tpnetdev = NULL;\n\t\tgoto RETURN;\n\t}\n\n\tpnpi->sizeof_priv = sizeof_priv;\nRETURN:\n\treturn pnetdev;\n}\n\nvoid rtw_free_netdev(struct net_device *netdev)\n{\n\tstruct rtw_netdev_priv_indicator *pnpi;\n\n\tif (!netdev)\n\t\tgoto RETURN;\n\n\tpnpi = netdev_priv(netdev);\n\n\tif (!pnpi->priv)\n\t\tgoto RETURN;\n\n\tvfree(pnpi->priv);\n\tfree_netdev(netdev);\n\nRETURN:\n\treturn;\n}\n\nvoid rtw_buf_free(u8 **buf, u32 *buf_len)\n{\n\tif (!buf || !buf_len)\n\t\treturn;\n\n\tif (*buf) {\n\t\t*buf_len = 0;\n\t\tkfree(*buf);\n\t\t*buf = NULL;\n\t}\n}\n\nvoid rtw_buf_update(u8 **buf, u32 *buf_len, u8 *src, u32 src_len)\n{\n\tu32 ori_len = 0, dup_len = 0;\n\tu8 *ori = NULL;\n\tu8 *dup = NULL;\n\n\tif (!buf || !buf_len)\n\t\treturn;\n\n\tif (!src || !src_len)\n\t\tgoto keep_ori;\n\n\t \n\tdup = rtw_malloc(src_len);\n\tif (dup) {\n\t\tdup_len = src_len;\n\t\tmemcpy(dup, src, dup_len);\n\t}\n\nkeep_ori:\n\tori = *buf;\n\tori_len = *buf_len;\n\n\t \n\t*buf_len = 0;\n\t*buf = dup;\n\t*buf_len = dup_len;\n\n\t \n\tif (ori && ori_len > 0)\n\t\tkfree(ori);\n}\n\n\n \ninline bool rtw_cbuf_full(struct rtw_cbuf *cbuf)\n{\n\treturn (cbuf->write == cbuf->read - 1) ? true : false;\n}\n\n \ninline bool rtw_cbuf_empty(struct rtw_cbuf *cbuf)\n{\n\treturn (cbuf->write == cbuf->read) ? true : false;\n}\n\n \nbool rtw_cbuf_push(struct rtw_cbuf *cbuf, void *buf)\n{\n\tif (rtw_cbuf_full(cbuf))\n\t\treturn _FAIL;\n\n\tcbuf->bufs[cbuf->write] = buf;\n\tcbuf->write = (cbuf->write + 1) % cbuf->size;\n\n\treturn _SUCCESS;\n}\n\n \nvoid *rtw_cbuf_pop(struct rtw_cbuf *cbuf)\n{\n\tvoid *buf;\n\tif (rtw_cbuf_empty(cbuf))\n\t\treturn NULL;\n\n\tbuf = cbuf->bufs[cbuf->read];\n\tcbuf->read = (cbuf->read + 1) % cbuf->size;\n\n\treturn buf;\n}\n\n \nstruct rtw_cbuf *rtw_cbuf_alloc(u32 size)\n{\n\tstruct rtw_cbuf *cbuf;\n\n\tcbuf = rtw_malloc(struct_size(cbuf, bufs, size));\n\n\tif (cbuf) {\n\t\tcbuf->write = cbuf->read = 0;\n\t\tcbuf->size = size;\n\t}\n\n\treturn cbuf;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}