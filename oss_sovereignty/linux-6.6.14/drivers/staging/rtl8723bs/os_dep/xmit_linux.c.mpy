{
  "module_name": "xmit_linux.c",
  "hash_id": "7862f2ae6cc4efd27a4534fdd92fa4aeb0c94a0c6f11df4886c683cd23b99c24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/os_dep/xmit_linux.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n\n\nuint rtw_remainder_len(struct pkt_file *pfile)\n{\n\treturn (pfile->buf_len - ((SIZE_PTR)(pfile->cur_addr) - (SIZE_PTR)(pfile->buf_start)));\n}\n\nvoid _rtw_open_pktfile(struct sk_buff *pktptr, struct pkt_file *pfile)\n{\n\tpfile->pkt = pktptr;\n\tpfile->cur_addr = pfile->buf_start = pktptr->data;\n\tpfile->pkt_len = pfile->buf_len = pktptr->len;\n\n\tpfile->cur_buffer = pfile->buf_start;\n}\n\nuint _rtw_pktfile_read(struct pkt_file *pfile, u8 *rmem, uint rlen)\n{\n\tuint\tlen = 0;\n\n\tlen =  rtw_remainder_len(pfile);\n\tlen = (rlen > len) ? len : rlen;\n\n\tif (rmem)\n\t\tskb_copy_bits(pfile->pkt, pfile->buf_len - pfile->pkt_len, rmem, len);\n\n\tpfile->cur_addr += len;\n\tpfile->pkt_len -= len;\n\treturn len;\n}\n\nsigned int rtw_endofpktfile(struct pkt_file *pfile)\n{\n\tif (pfile->pkt_len == 0)\n\t\treturn true;\n\treturn false;\n}\n\nint rtw_os_xmit_resource_alloc(struct adapter *padapter, struct xmit_buf *pxmitbuf, u32 alloc_sz, u8 flag)\n{\n\tif (alloc_sz > 0) {\n\t\tpxmitbuf->pallocated_buf = rtw_zmalloc(alloc_sz);\n\t\tif (!pxmitbuf->pallocated_buf)\n\t\t\treturn _FAIL;\n\n\t\tpxmitbuf->pbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitbuf->pallocated_buf), XMITBUF_ALIGN_SZ);\n\t}\n\n\treturn _SUCCESS;\n}\n\nvoid rtw_os_xmit_resource_free(struct adapter *padapter, struct xmit_buf *pxmitbuf, u32 free_sz, u8 flag)\n{\n\tif (free_sz > 0)\n\t\tkfree(pxmitbuf->pallocated_buf);\n}\n\n#define WMM_XMIT_THRESHOLD\t(NR_XMITFRAME * 2 / 5)\n\nvoid rtw_os_pkt_complete(struct adapter *padapter, struct sk_buff *pkt)\n{\n\tu16 queue;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tqueue = skb_get_queue_mapping(pkt);\n\tif (padapter->registrypriv.wifi_spec) {\n\t\tif (__netif_subqueue_stopped(padapter->pnetdev, queue) &&\n\t\t    (pxmitpriv->hwxmits[queue].accnt < WMM_XMIT_THRESHOLD))\n\t\t\tnetif_wake_subqueue(padapter->pnetdev, queue);\n\t} else {\n\t\tif (__netif_subqueue_stopped(padapter->pnetdev, queue))\n\t\t\tnetif_wake_subqueue(padapter->pnetdev, queue);\n\t}\n\n\tdev_kfree_skb_any(pkt);\n}\n\nvoid rtw_os_xmit_complete(struct adapter *padapter, struct xmit_frame *pxframe)\n{\n\tif (pxframe->pkt)\n\t\trtw_os_pkt_complete(padapter, pxframe->pkt);\n\n\tpxframe->pkt = NULL;\n}\n\nvoid rtw_os_xmit_schedule(struct adapter *padapter)\n{\n\tstruct adapter *pri_adapter = padapter;\n\n\tif (!padapter)\n\t\treturn;\n\n\tif (!list_empty(&padapter->xmitpriv.pending_xmitbuf_queue.queue))\n\t\tcomplete(&pri_adapter->xmitpriv.xmit_comp);\n}\n\nstatic void rtw_check_xmit_resource(struct adapter *padapter, struct sk_buff *pkt)\n{\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tu16 queue;\n\n\tqueue = skb_get_queue_mapping(pkt);\n\tif (padapter->registrypriv.wifi_spec) {\n\t\t \n\t\tif (pxmitpriv->hwxmits[queue].accnt > WMM_XMIT_THRESHOLD)\n\t\t\tnetif_stop_subqueue(padapter->pnetdev, queue);\n\t} else {\n\t\tif (pxmitpriv->free_xmitframe_cnt <= 4) {\n\t\t\tif (!netif_tx_queue_stopped(netdev_get_tx_queue(padapter->pnetdev, queue)))\n\t\t\t\tnetif_stop_subqueue(padapter->pnetdev, queue);\n\t\t}\n\t}\n}\n\nstatic int rtw_mlcst2unicst(struct adapter *padapter, struct sk_buff *skb)\n{\n\tstruct\tsta_priv *pstapriv = &padapter->stapriv;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct list_head\t*phead, *plist;\n\tstruct sk_buff *newskb;\n\tstruct sta_info *psta = NULL;\n\tu8 chk_alive_num = 0;\n\tchar chk_alive_list[NUM_STA];\n\tu8 bc_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tu8 null_addr[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n\tint i;\n\ts32\tres;\n\n\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\tphead = &pstapriv->asoc_list;\n\t \n\tlist_for_each(plist, phead) {\n\t\tint stainfo_offset;\n\n\t\tpsta = list_entry(plist, struct sta_info, asoc_list);\n\n\t\tstainfo_offset = rtw_stainfo_offset(pstapriv, psta);\n\t\tif (stainfo_offset_valid(stainfo_offset)) {\n\t\t\tchk_alive_list[chk_alive_num++] = stainfo_offset;\n\t\t}\n\t}\n\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\n\tfor (i = 0; i < chk_alive_num; i++) {\n\t\tpsta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);\n\t\tif (!(psta->state & _FW_LINKED))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!memcmp(psta->hwaddr, &skb->data[6], 6) ||\n\t\t    !memcmp(psta->hwaddr, null_addr, 6) ||\n\t\t    !memcmp(psta->hwaddr, bc_addr, 6))\n\t\t\tcontinue;\n\n\t\tnewskb = rtw_skb_copy(skb);\n\n\t\tif (newskb) {\n\t\t\tmemcpy(newskb->data, psta->hwaddr, 6);\n\t\t\tres = rtw_xmit(padapter, &newskb);\n\t\t\tif (res < 0) {\n\t\t\t\tpxmitpriv->tx_drop++;\n\t\t\t\tdev_kfree_skb_any(newskb);\n\t\t\t}\n\t\t} else {\n\t\t\tpxmitpriv->tx_drop++;\n\t\t\t \n\t\t\treturn false;\t \n\t\t}\n\t}\n\n\tdev_kfree_skb_any(skb);\n\treturn true;\n}\n\nvoid _rtw_xmit_entry(struct sk_buff *pkt, struct net_device *pnetdev)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(pnetdev);\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\ts32 res = 0;\n\n\tif (rtw_if_up(padapter) == false)\n\t\tgoto drop_packet;\n\n\trtw_check_xmit_resource(padapter, pkt);\n\n\tif (!rtw_mc2u_disable\n\t\t&& check_fwstate(pmlmepriv, WIFI_AP_STATE) == true\n\t\t&& (IP_MCAST_MAC(pkt->data)\n\t\t\t|| ICMPV6_MCAST_MAC(pkt->data)\n\t\t\t)\n\t\t&& padapter->registrypriv.wifi_spec == 0) {\n\t\tif (pxmitpriv->free_xmitframe_cnt > (NR_XMITFRAME / 4)) {\n\t\t\tres = rtw_mlcst2unicst(padapter, pkt);\n\t\t\tif (res)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tres = rtw_xmit(padapter, &pkt);\n\tif (res < 0)\n\t\tgoto drop_packet;\n\n\treturn;\n\ndrop_packet:\n\tpxmitpriv->tx_drop++;\n\tdev_kfree_skb_any(pkt);\n}\n\nnetdev_tx_t rtw_xmit_entry(struct sk_buff *pkt, struct net_device *pnetdev)\n{\n\tif (pkt)\n\t\t_rtw_xmit_entry(pkt, pnetdev);\n\n\treturn NETDEV_TX_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}