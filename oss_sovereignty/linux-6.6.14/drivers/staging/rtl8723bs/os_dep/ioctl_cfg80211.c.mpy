{
  "module_name": "ioctl_cfg80211.c",
  "hash_id": "6ad388e5d7241f93187f070a68e2ad26c40a2110a5626ae63c7dc6469d6e221a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/os_dep/ioctl_cfg80211.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <linux/jiffies.h>\n\n#include <rtw_wifi_regd.h>\n\n#define RTW_MAX_MGMT_TX_CNT (8)\n\n#define RTW_SCAN_IE_LEN_MAX      2304\n#define RTW_MAX_REMAIN_ON_CHANNEL_DURATION 5000  \n#define RTW_MAX_NUM_PMKIDS 4\n\nstatic const u32 rtw_cipher_suites[] = {\n\tWLAN_CIPHER_SUITE_WEP40,\n\tWLAN_CIPHER_SUITE_WEP104,\n\tWLAN_CIPHER_SUITE_TKIP,\n\tWLAN_CIPHER_SUITE_CCMP,\n\tWLAN_CIPHER_SUITE_AES_CMAC,\n};\n\n#define RATETAB_ENT(_rate, _rateid, _flags) \\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.bitrate\t= (_rate),\t\t\t\t\\\n\t\t.hw_value\t= (_rateid),\t\t\t\t\\\n\t\t.flags\t\t= (_flags),\t\t\t\t\\\n\t}\n\n#define CHAN2G(_channel, _freq, _flags) {\t\t\t\\\n\t.band\t\t\t= NL80211_BAND_2GHZ,\t\t\\\n\t.center_freq\t\t= (_freq),\t\t\t\\\n\t.hw_value\t\t= (_channel),\t\t\t\\\n\t.flags\t\t\t= (_flags),\t\t\t\\\n\t.max_antenna_gain\t= 0,\t\t\t\t\\\n\t.max_power\t\t= 30,\t\t\t\t\\\n}\n\n \nstatic __maybe_unused const struct wiphy_wowlan_support wowlan_stub = {\n\t.flags = WIPHY_WOWLAN_ANY,\n\t.n_patterns = 0,\n\t.pattern_max_len = 0,\n\t.pattern_min_len = 0,\n\t.max_pkt_offset = 0,\n};\n\nstatic struct ieee80211_rate rtw_rates[] = {\n\tRATETAB_ENT(10,  0x1,   0),\n\tRATETAB_ENT(20,  0x2,   0),\n\tRATETAB_ENT(55,  0x4,   0),\n\tRATETAB_ENT(110, 0x8,   0),\n\tRATETAB_ENT(60,  0x10,  0),\n\tRATETAB_ENT(90,  0x20,  0),\n\tRATETAB_ENT(120, 0x40,  0),\n\tRATETAB_ENT(180, 0x80,  0),\n\tRATETAB_ENT(240, 0x100, 0),\n\tRATETAB_ENT(360, 0x200, 0),\n\tRATETAB_ENT(480, 0x400, 0),\n\tRATETAB_ENT(540, 0x800, 0),\n};\n\n#define rtw_g_rates\t\t(rtw_rates + 0)\n#define RTW_G_RATES_NUM\t12\n\n#define RTW_2G_CHANNELS_NUM 14\n\nstatic struct ieee80211_channel rtw_2ghz_channels[] = {\n\tCHAN2G(1, 2412, 0),\n\tCHAN2G(2, 2417, 0),\n\tCHAN2G(3, 2422, 0),\n\tCHAN2G(4, 2427, 0),\n\tCHAN2G(5, 2432, 0),\n\tCHAN2G(6, 2437, 0),\n\tCHAN2G(7, 2442, 0),\n\tCHAN2G(8, 2447, 0),\n\tCHAN2G(9, 2452, 0),\n\tCHAN2G(10, 2457, 0),\n\tCHAN2G(11, 2462, 0),\n\tCHAN2G(12, 2467, 0),\n\tCHAN2G(13, 2472, 0),\n\tCHAN2G(14, 2484, 0),\n};\n\nstatic void rtw_2g_channels_init(struct ieee80211_channel *channels)\n{\n\tmemcpy((void *)channels, (void *)rtw_2ghz_channels,\n\t       sizeof(struct ieee80211_channel) * RTW_2G_CHANNELS_NUM\n\t);\n}\n\nstatic void rtw_2g_rates_init(struct ieee80211_rate *rates)\n{\n\tmemcpy(rates, rtw_g_rates,\n\t       sizeof(struct ieee80211_rate) * RTW_G_RATES_NUM\n\t);\n}\n\nstatic struct ieee80211_supported_band *rtw_spt_band_alloc(\n\tenum nl80211_band band\n\t)\n{\n\tstruct ieee80211_supported_band *spt_band = NULL;\n\tint n_channels, n_bitrates;\n\n\tif (band == NL80211_BAND_2GHZ) {\n\t\tn_channels = RTW_2G_CHANNELS_NUM;\n\t\tn_bitrates = RTW_G_RATES_NUM;\n\t} else {\n\t\tgoto exit;\n\t}\n\n\tspt_band = rtw_zmalloc(sizeof(struct ieee80211_supported_band) +\n\t\t\t       sizeof(struct ieee80211_channel) * n_channels +\n\t\t\t       sizeof(struct ieee80211_rate) * n_bitrates);\n\tif (!spt_band)\n\t\tgoto exit;\n\n\tspt_band->channels = (struct ieee80211_channel *)(((u8 *)spt_band) + sizeof(struct ieee80211_supported_band));\n\tspt_band->bitrates = (struct ieee80211_rate *)(((u8 *)spt_band->channels) + sizeof(struct ieee80211_channel) * n_channels);\n\tspt_band->band = band;\n\tspt_band->n_channels = n_channels;\n\tspt_band->n_bitrates = n_bitrates;\n\n\tif (band == NL80211_BAND_2GHZ) {\n\t\trtw_2g_channels_init(spt_band->channels);\n\t\trtw_2g_rates_init(spt_band->bitrates);\n\t}\n\n\t \n\nexit:\n\n\treturn spt_band;\n}\n\nstatic const struct ieee80211_txrx_stypes\nrtw_cfg80211_default_mgmt_stypes[NUM_NL80211_IFTYPES] = {\n\t[NL80211_IFTYPE_ADHOC] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4)\n\t},\n\t[NL80211_IFTYPE_STATION] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_AP] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\tBIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\tBIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\tBIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\tBIT(IEEE80211_STYPE_ACTION >> 4)\n\t},\n\t[NL80211_IFTYPE_AP_VLAN] = {\n\t\t \n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\tBIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\tBIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\tBIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\tBIT(IEEE80211_STYPE_ACTION >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_CLIENT] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_GO] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\tBIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\tBIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\tBIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\tBIT(IEEE80211_STYPE_ACTION >> 4)\n\t},\n};\n\nstatic int rtw_ieee80211_channel_to_frequency(int chan, int band)\n{\n\tif (band == NL80211_BAND_2GHZ) {\n\t\tif (chan == 14)\n\t\t\treturn 2484;\n\t\telse if (chan < 14)\n\t\t\treturn 2407 + chan * 5;\n\t}\n\n\treturn 0;  \n}\n\n#define MAX_BSSINFO_LEN 1000\nstruct cfg80211_bss *rtw_cfg80211_inform_bss(struct adapter *padapter, struct wlan_network *pnetwork)\n{\n\tstruct ieee80211_channel *notify_channel;\n\tstruct cfg80211_bss *bss = NULL;\n\t \n\tu16 channel;\n\tu32 freq;\n\tu64 notify_timestamp;\n\ts32 notify_signal;\n\tu8 *buf = NULL, *pbuf;\n\tsize_t len, bssinf_len = 0;\n\tstruct ieee80211_hdr *pwlanhdr;\n\t__le16 *fctrl;\n\n\tstruct wireless_dev *wdev = padapter->rtw_wdev;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\n\tbssinf_len = pnetwork->network.ie_length + sizeof(struct ieee80211_hdr_3addr);\n\tif (bssinf_len > MAX_BSSINFO_LEN)\n\t\tgoto exit;\n\n\t{\n\t\tu16 wapi_len = 0;\n\n\t\tif (rtw_get_wapi_ie(pnetwork->network.ies, pnetwork->network.ie_length, NULL, &wapi_len) > 0) {\n\t\t\tif (wapi_len > 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\t \n\tif (adapter_wdev_data(padapter)->scan_request) {\n\t\tu8 *psr = NULL, sr = 0;\n\t\tstruct ndis_802_11_ssid *pssid = &pnetwork->network.ssid;\n\t\tstruct cfg80211_scan_request *request = adapter_wdev_data(padapter)->scan_request;\n\t\tstruct cfg80211_ssid *ssids = request->ssids;\n\t\tu32 wpsielen = 0;\n\t\tu8 *wpsie = NULL;\n\n\t\twpsie = rtw_get_wps_ie(pnetwork->network.ies + _FIXED_IE_LENGTH_, pnetwork->network.ie_length - _FIXED_IE_LENGTH_, NULL, &wpsielen);\n\n\t\tif (wpsie && wpsielen > 0)\n\t\t\tpsr = rtw_get_wps_attr_content(wpsie, wpsielen, WPS_ATTR_SELECTED_REGISTRAR, (u8 *)(&sr), NULL);\n\n\t\tif (sr != 0) {\n\t\t\t \n\t\t\tif (request->n_ssids == 1 && request->n_channels == 1) {\n\t\t\t\tif (ssids[0].ssid_len != 0 &&\n\t\t\t\t    (pssid->ssid_length != ssids[0].ssid_len ||\n\t\t\t\t     memcmp(pssid->ssid, ssids[0].ssid, ssids[0].ssid_len))) {\n\t\t\t\t\tif (psr)\n\t\t\t\t\t\t*psr = 0;  \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\tchannel = pnetwork->network.configuration.ds_config;\n\tfreq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);\n\n\tnotify_channel = ieee80211_get_channel(wiphy, freq);\n\n\tnotify_timestamp = ktime_to_us(ktime_get_boottime());\n\n\t \n\tif (check_fwstate(pmlmepriv, _FW_LINKED) == true &&\n\t    is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network, 0)) {\n\t\tnotify_signal = 100 * translate_percentage_to_dbm(padapter->recvpriv.signal_strength); \n\t} else {\n\t\tnotify_signal = 100 * translate_percentage_to_dbm(pnetwork->network.phy_info.signal_strength); \n\t}\n\n\tbuf = kzalloc(MAX_BSSINFO_LEN, GFP_ATOMIC);\n\tif (!buf)\n\t\tgoto exit;\n\tpbuf = buf;\n\n\tpwlanhdr = (struct ieee80211_hdr *)pbuf;\n\tfctrl = &(pwlanhdr->frame_control);\n\t*(fctrl) = 0;\n\n\tSetSeqNum(pwlanhdr, 0 );\n\t \n\n\tif (pnetwork->network.reserved[0] == 1) {  \n\t\teth_broadcast_addr(pwlanhdr->addr1);\n\t\tSetFrameSubType(pbuf, WIFI_BEACON);\n\t} else {\n\t\tmemcpy(pwlanhdr->addr1, myid(&(padapter->eeprompriv)), ETH_ALEN);\n\t\tSetFrameSubType(pbuf, WIFI_PROBERSP);\n\t}\n\n\tmemcpy(pwlanhdr->addr2, pnetwork->network.mac_address, ETH_ALEN);\n\tmemcpy(pwlanhdr->addr3, pnetwork->network.mac_address, ETH_ALEN);\n\n\tpbuf += sizeof(struct ieee80211_hdr_3addr);\n\tlen = sizeof(struct ieee80211_hdr_3addr);\n\n\tmemcpy(pbuf, pnetwork->network.ies, pnetwork->network.ie_length);\n\tlen += pnetwork->network.ie_length;\n\n\t*((__le64 *)pbuf) = cpu_to_le64(notify_timestamp);\n\n\tbss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)buf,\n\t\t\t\t\tlen, notify_signal, GFP_ATOMIC);\n\n\tif (unlikely(!bss))\n\t\tgoto exit;\n\n\tcfg80211_put_bss(wiphy, bss);\n\tkfree(buf);\n\nexit:\n\treturn bss;\n}\n\n \nint rtw_cfg80211_check_bss(struct adapter *padapter)\n{\n\tstruct wlan_bssid_ex  *pnetwork = &(padapter->mlmeextpriv.mlmext_info.network);\n\tstruct cfg80211_bss *bss = NULL;\n\tstruct ieee80211_channel *notify_channel = NULL;\n\tu32 freq;\n\n\tif (!(pnetwork) || !(padapter->rtw_wdev))\n\t\treturn false;\n\n\tfreq = rtw_ieee80211_channel_to_frequency(pnetwork->configuration.ds_config, NL80211_BAND_2GHZ);\n\n\tnotify_channel = ieee80211_get_channel(padapter->rtw_wdev->wiphy, freq);\n\tbss = cfg80211_get_bss(padapter->rtw_wdev->wiphy, notify_channel,\n\t\t\t       pnetwork->mac_address, pnetwork->ssid.ssid,\n\t\t\t       pnetwork->ssid.ssid_length,\n\t\t\t       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);\n\n\tcfg80211_put_bss(padapter->rtw_wdev->wiphy, bss);\n\n\treturn\t(bss != NULL);\n}\n\nvoid rtw_cfg80211_ibss_indicate_connect(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct wlan_network  *cur_network = &(pmlmepriv->cur_network);\n\tstruct wireless_dev *pwdev = padapter->rtw_wdev;\n\tstruct wiphy *wiphy = pwdev->wiphy;\n\tint freq = (int)cur_network->network.configuration.ds_config;\n\tstruct ieee80211_channel *chan;\n\n\tif (pwdev->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn;\n\n\tif (!rtw_cfg80211_check_bss(padapter)) {\n\t\tstruct wlan_bssid_ex  *pnetwork = &(padapter->mlmeextpriv.mlmext_info.network);\n\t\tstruct wlan_network *scanned = pmlmepriv->cur_network_scanned;\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {\n\t\t\tmemcpy(&cur_network->network, pnetwork, sizeof(struct wlan_bssid_ex));\n\t\t\trtw_cfg80211_inform_bss(padapter, cur_network);\n\t\t} else {\n\t\t\tif (!scanned) {\n\t\t\t\trtw_warn_on(1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!memcmp(&(scanned->network.ssid), &(pnetwork->ssid), sizeof(struct ndis_802_11_ssid))\n\t\t\t\t&& !memcmp(scanned->network.mac_address, pnetwork->mac_address, sizeof(NDIS_802_11_MAC_ADDRESS))\n\t\t\t)\n\t\t\t\trtw_cfg80211_inform_bss(padapter, scanned);\n\t\t\telse\n\t\t\t\trtw_warn_on(1);\n\t\t}\n\n\t\tif (!rtw_cfg80211_check_bss(padapter))\n\t\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t\t   FUNC_ADPT_FMT \" BSS not found !!\\n\",\n\t\t\t\t   FUNC_ADPT_ARG(padapter));\n\t}\n\t \n\tchan = ieee80211_get_channel(wiphy, freq);\n\tcfg80211_ibss_joined(padapter->pnetdev, cur_network->network.mac_address, chan, GFP_ATOMIC);\n}\n\nvoid rtw_cfg80211_indicate_connect(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct wlan_network  *cur_network = &(pmlmepriv->cur_network);\n\tstruct wireless_dev *pwdev = padapter->rtw_wdev;\n\n\tif (pwdev->iftype != NL80211_IFTYPE_STATION\n\t\t&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT\n\t) {\n\t\treturn;\n\t}\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)\n\t\treturn;\n\n\t{\n\t\tstruct wlan_bssid_ex  *pnetwork = &(padapter->mlmeextpriv.mlmext_info.network);\n\t\tstruct wlan_network *scanned = pmlmepriv->cur_network_scanned;\n\n\t\tif (!scanned) {\n\t\t\trtw_warn_on(1);\n\t\t\tgoto check_bss;\n\t\t}\n\n\t\tif (!memcmp(scanned->network.mac_address, pnetwork->mac_address, sizeof(NDIS_802_11_MAC_ADDRESS))\n\t\t\t&& !memcmp(&(scanned->network.ssid), &(pnetwork->ssid), sizeof(struct ndis_802_11_ssid))\n\t\t)\n\t\t\trtw_cfg80211_inform_bss(padapter, scanned);\n\t\telse\n\t\t\trtw_warn_on(1);\n\t}\n\ncheck_bss:\n\tif (!rtw_cfg80211_check_bss(padapter))\n\t\tnetdev_dbg(padapter->pnetdev,\n\t\t\t   FUNC_ADPT_FMT \" BSS not found !!\\n\",\n\t\t\t   FUNC_ADPT_ARG(padapter));\n\n\tif (rtw_to_roam(padapter) > 0) {\n\t\tstruct wiphy *wiphy = pwdev->wiphy;\n\t\tstruct ieee80211_channel *notify_channel;\n\t\tu32 freq;\n\t\tu16 channel = cur_network->network.configuration.ds_config;\n\t\tstruct cfg80211_roam_info roam_info = {};\n\n\t\tfreq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);\n\n\t\tnotify_channel = ieee80211_get_channel(wiphy, freq);\n\n\t\troam_info.links[0].channel = notify_channel;\n\t\troam_info.links[0].bssid = cur_network->network.mac_address;\n\t\troam_info.req_ie =\n\t\t\tpmlmepriv->assoc_req + sizeof(struct ieee80211_hdr_3addr) + 2;\n\t\troam_info.req_ie_len =\n\t\t\tpmlmepriv->assoc_req_len - sizeof(struct ieee80211_hdr_3addr) - 2;\n\t\troam_info.resp_ie =\n\t\t\tpmlmepriv->assoc_rsp + sizeof(struct ieee80211_hdr_3addr) + 6;\n\t\troam_info.resp_ie_len =\n\t\t\tpmlmepriv->assoc_rsp_len - sizeof(struct ieee80211_hdr_3addr) - 6;\n\t\tcfg80211_roamed(padapter->pnetdev, &roam_info, GFP_ATOMIC);\n\t} else {\n\t\tcfg80211_connect_result(padapter->pnetdev, cur_network->network.mac_address\n\t\t\t, pmlmepriv->assoc_req + sizeof(struct ieee80211_hdr_3addr) + 2\n\t\t\t, pmlmepriv->assoc_req_len - sizeof(struct ieee80211_hdr_3addr) - 2\n\t\t\t, pmlmepriv->assoc_rsp + sizeof(struct ieee80211_hdr_3addr) + 6\n\t\t\t, pmlmepriv->assoc_rsp_len - sizeof(struct ieee80211_hdr_3addr) - 6\n\t\t\t, WLAN_STATUS_SUCCESS, GFP_ATOMIC);\n\t}\n}\n\nvoid rtw_cfg80211_indicate_disconnect(struct adapter *padapter)\n{\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct wireless_dev *pwdev = padapter->rtw_wdev;\n\n\tif (pwdev->iftype != NL80211_IFTYPE_STATION\n\t\t&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT\n\t) {\n\t\treturn;\n\t}\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)\n\t\treturn;\n\n\tif (!padapter->mlmepriv.not_indic_disco) {\n\t\tif (check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {\n\t\t\tcfg80211_disconnected(padapter->pnetdev, 0,\n\t\t\t\t\t      NULL, 0, true, GFP_ATOMIC);\n\t\t} else {\n\t\t\tcfg80211_connect_result(padapter->pnetdev, NULL, NULL, 0, NULL, 0,\n\t\t\t\t\t\tWLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC );\n\t\t}\n\t}\n}\n\nstatic int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)\n{\n\tint ret = 0;\n\tu32 wep_key_idx, wep_key_len;\n\tstruct sta_info *psta = NULL, *pbcmc_sta = NULL;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct security_priv *psecuritypriv =  &(padapter->securitypriv);\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tchar *grpkey = padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey;\n\tchar *txkey = padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey;\n\tchar *rxkey = padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey;\n\n\tparam->u.crypt.err = 0;\n\tparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\\0';\n\n\tif (param_len !=  sizeof(struct ieee_param) + param->u.crypt.key_len) {\n\t\tret =  -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\n\t    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\n\t    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {\n\t\tif (param->u.crypt.idx >= WEP_KEYS) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tpsta = rtw_get_stainfo(pstapriv, param->sta_addr);\n\t\tif (!psta)\n\t\t\t \n\t\t\tgoto exit;\n\t}\n\n\tif (strcmp(param->u.crypt.alg, \"none\") == 0 && !psta)\n\t\tgoto exit;\n\n\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0 && !psta) {\n\t\twep_key_idx = param->u.crypt.idx;\n\t\twep_key_len = param->u.crypt.key_len;\n\n\t\tif ((wep_key_idx >= WEP_KEYS) || (wep_key_len <= 0)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (wep_key_len > 0)\n\t\t\twep_key_len = wep_key_len <= 5 ? 5 : 13;\n\n\t\tif (psecuritypriv->bWepDefaultKeyIdxSet == 0) {\n\t\t\t \n\n\t\t\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;\n\t\t\tpsecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\t\tpsecuritypriv->dot11PrivacyAlgrthm = _WEP40_;\n\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\n\n\t\t\tif (wep_key_len == 13) {\n\t\t\t\tpsecuritypriv->dot11PrivacyAlgrthm = _WEP104_;\n\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\n\t\t\t}\n\n\t\t\tpsecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;\n\t\t}\n\n\t\tmemcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), param->u.crypt.key, wep_key_len);\n\n\t\tpsecuritypriv->dot11DefKeylen[wep_key_idx] = wep_key_len;\n\n\t\trtw_ap_set_wep_key(padapter, param->u.crypt.key, wep_key_len, wep_key_idx, 1);\n\n\t\tgoto exit;\n\t}\n\n\t \n\tif (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\t \n\t\tif (param->u.crypt.set_tx == 0) {\n\t\t\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0) {\n\t\t\t\tmemcpy(grpkey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\n\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\n\t\t\t\tif (param->u.crypt.key_len == 13)\n\t\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\n\n\t\t\t} else if (strcmp(param->u.crypt.alg, \"TKIP\") == 0) {\n\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _TKIP_;\n\n\t\t\t\tmemcpy(grpkey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tmemcpy(txkey, &(param->u.crypt.key[16]), 8);\n\t\t\t\tmemcpy(rxkey, &(param->u.crypt.key[24]), 8);\n\n\t\t\t\tpsecuritypriv->busetkipkey = true;\n\n\t\t\t} else if (strcmp(param->u.crypt.alg, \"CCMP\") == 0) {\n\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _AES_;\n\n\t\t\t\tmemcpy(grpkey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\t\t\t} else {\n\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\n\t\t\t}\n\n\t\t\tpsecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;\n\n\t\t\tpsecuritypriv->binstallGrpkey = true;\n\n\t\t\tpsecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy; \n\n\t\t\trtw_ap_set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);\n\n\t\t\tpbcmc_sta = rtw_get_bcmc_stainfo(padapter);\n\t\t\tif (pbcmc_sta) {\n\t\t\t\tpbcmc_sta->ieee8021x_blocked = false;\n\t\t\t\tpbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy; \n\t\t\t}\n\t\t}\n\n\t\tgoto exit;\n\t}\n\n\tif (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) {  \n\t\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\t\tif (param->u.crypt.set_tx == 1) {  \n\t\t\t\tmemcpy(psta->dot118021x_UncstKey.skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\n\t\t\t\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0) {\n\t\t\t\t\tpsta->dot118021XPrivacy = _WEP40_;\n\t\t\t\t\tif (param->u.crypt.key_len == 13)\n\t\t\t\t\t\tpsta->dot118021XPrivacy = _WEP104_;\n\t\t\t\t} else if (strcmp(param->u.crypt.alg, \"TKIP\") == 0) {\n\t\t\t\t\tpsta->dot118021XPrivacy = _TKIP_;\n\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tmemcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);\n\t\t\t\t\tmemcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);\n\n\t\t\t\t\tpsecuritypriv->busetkipkey = true;\n\n\t\t\t\t} else if (strcmp(param->u.crypt.alg, \"CCMP\") == 0) {\n\t\t\t\t\tpsta->dot118021XPrivacy = _AES_;\n\t\t\t\t} else {\n\t\t\t\t\tpsta->dot118021XPrivacy = _NO_PRIVACY_;\n\t\t\t\t}\n\n\t\t\t\trtw_ap_set_pairwise_key(padapter, psta);\n\n\t\t\t\tpsta->ieee8021x_blocked = false;\n\n\t\t\t\tpsta->bpairwise_key_installed = true;\n\n\t\t\t} else {  \n\t\t\t\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0) {\n\t\t\t\t\tmemcpy(grpkey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\n\t\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\n\t\t\t\t\tif (param->u.crypt.key_len == 13)\n\t\t\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\n\t\t\t\t} else if (strcmp(param->u.crypt.alg, \"TKIP\") == 0) {\n\t\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _TKIP_;\n\n\t\t\t\t\tmemcpy(grpkey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tmemcpy(txkey, &(param->u.crypt.key[16]), 8);\n\t\t\t\t\tmemcpy(rxkey, &(param->u.crypt.key[24]), 8);\n\n\t\t\t\t\tpsecuritypriv->busetkipkey = true;\n\n\t\t\t\t} else if (strcmp(param->u.crypt.alg, \"CCMP\") == 0) {\n\t\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _AES_;\n\n\t\t\t\t\tmemcpy(grpkey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\t\t\t\t} else {\n\t\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\n\t\t\t\t}\n\n\t\t\t\tpsecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;\n\n\t\t\t\tpsecuritypriv->binstallGrpkey = true;\n\n\t\t\t\tpsecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy; \n\n\t\t\t\trtw_ap_set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);\n\n\t\t\t\tpbcmc_sta = rtw_get_bcmc_stainfo(padapter);\n\t\t\t\tif (pbcmc_sta) {\n\t\t\t\t\tpbcmc_sta->ieee8021x_blocked = false;\n\t\t\t\t\tpbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\n\treturn ret;\n}\n\nstatic int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)\n{\n\tint ret = 0;\n\tu8 max_idx;\n\tu32 wep_key_idx, wep_key_len;\n\tstruct adapter *padapter = rtw_netdev_priv(dev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\n\tparam->u.crypt.err = 0;\n\tparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\\0';\n\n\tif (param_len < (u32)((u8 *)param->u.crypt.key - (u8 *)param) + param->u.crypt.key_len) {\n\t\tret =  -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (param->sta_addr[0] != 0xff || param->sta_addr[1] != 0xff ||\n\t    param->sta_addr[2] != 0xff || param->sta_addr[3] != 0xff ||\n\t    param->sta_addr[4] != 0xff || param->sta_addr[5] != 0xff) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0)\n\t\tmax_idx = WEP_KEYS - 1;\n\telse\n\t\tmax_idx = BIP_MAX_KEYID;\n\n\tif (param->u.crypt.idx > max_idx) {\n\t\tnetdev_err(dev, \"Error crypt.idx %d > %d\\n\", param->u.crypt.idx, max_idx);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (strcmp(param->u.crypt.alg, \"WEP\") == 0) {\n\t\twep_key_idx = param->u.crypt.idx;\n\t\twep_key_len = param->u.crypt.key_len;\n\n\t\tif (wep_key_len <= 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (psecuritypriv->bWepDefaultKeyIdxSet == 0) {\n\t\t\t \n\n\t\t\twep_key_len = wep_key_len <= 5 ? 5 : 13;\n\n\t\t\tpsecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\t\tpsecuritypriv->dot11PrivacyAlgrthm = _WEP40_;\n\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\n\n\t\t\tif (wep_key_len == 13) {\n\t\t\t\tpsecuritypriv->dot11PrivacyAlgrthm = _WEP104_;\n\t\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\n\t\t\t}\n\n\t\t\tpsecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;\n\t\t}\n\n\t\tmemcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), param->u.crypt.key, wep_key_len);\n\n\t\tpsecuritypriv->dot11DefKeylen[wep_key_idx] = wep_key_len;\n\n\t\trtw_set_key(padapter, psecuritypriv, wep_key_idx, 0, true);\n\n\t\tgoto exit;\n\t}\n\n\tif (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) {  \n\t\tstruct sta_info *psta, *pbcmc_sta;\n\t\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == true) {  \n\t\t\tpsta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));\n\t\t\tif (psta) {\n\t\t\t\t \n\t\t\t\tif (strcmp(param->u.crypt.alg, \"none\") != 0)\n\t\t\t\t\tpsta->ieee8021x_blocked = false;\n\n\t\t\t\tif ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled) ||\n\t\t\t\t    (padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled)) {\n\t\t\t\t\tpsta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;\n\t\t\t\t}\n\n\t\t\t\tif (param->u.crypt.set_tx == 1) {  \n\n\t\t\t\t\tmemcpy(psta->dot118021x_UncstKey.skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\n\t\t\t\t\tif (strcmp(param->u.crypt.alg, \"TKIP\") == 0) {  \n\t\t\t\t\t\t \n\t\t\t\t\t\tmemcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);\n\t\t\t\t\t\tmemcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);\n\n\t\t\t\t\t\tpadapter->securitypriv.busetkipkey = false;\n\t\t\t\t\t\t \n\t\t\t\t\t}\n\n\t\t\t\t\trtw_setstakey_cmd(padapter, psta, true, true);\n\t\t\t\t} else {  \n\t\t\t\t\tif (strcmp(param->u.crypt.alg, \"TKIP\") == 0 || strcmp(param->u.crypt.alg, \"CCMP\") == 0) {\n\t\t\t\t\t\tmemcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\t\t\t\t\t\tmemcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);\n\t\t\t\t\t\tmemcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);\n\t\t\t\t\t\tpadapter->securitypriv.binstallGrpkey = true;\n\n\t\t\t\t\t\tpadapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;\n\t\t\t\t\t\trtw_set_key(padapter, &padapter->securitypriv, param->u.crypt.idx, 1, true);\n\t\t\t\t\t} else if (strcmp(param->u.crypt.alg, \"BIP\") == 0) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tmemcpy(padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\n\t\t\t\t\t\t \n\t\t\t\t\t\tpadapter->securitypriv.dot11wBIPKeyid = param->u.crypt.idx;\n\t\t\t\t\t\tpadapter->securitypriv.binstallBIPkey = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpbcmc_sta = rtw_get_bcmc_stainfo(padapter);\n\t\t\tif (!pbcmc_sta) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (strcmp(param->u.crypt.alg, \"none\") != 0)\n\t\t\t\t\tpbcmc_sta->ieee8021x_blocked = false;\n\n\t\t\t\tif ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled) ||\n\t\t\t\t    (padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled)) {\n\t\t\t\t\tpbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {  \n\t\t}\n\t}\n\nexit:\n\n\treturn ret;\n}\n\nstatic int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\tint link_id, u8 key_index, bool pairwise,\n\t\t\t\tconst u8 *mac_addr, struct key_params *params)\n{\n\tchar *alg_name;\n\tu32 param_len;\n\tstruct ieee_param *param = NULL;\n\tint ret = 0;\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\n\tparam_len = sizeof(struct ieee_param) + params->key_len;\n\tparam = rtw_malloc(param_len);\n\tif (!param)\n\t\treturn -1;\n\n\tmemset(param, 0, param_len);\n\n\tparam->cmd = IEEE_CMD_SET_ENCRYPTION;\n\teth_broadcast_addr(param->sta_addr);\n\n\tswitch (params->cipher) {\n\tcase IW_AUTH_CIPHER_NONE:\n\t\t \n\t\t \n\t\talg_name = \"none\";\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\talg_name = \"WEP\";\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\talg_name = \"TKIP\";\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\talg_name = \"CCMP\";\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\talg_name = \"BIP\";\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tgoto addkey_end;\n\t}\n\n\tstrncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);\n\n\tif (!mac_addr || is_broadcast_ether_addr(mac_addr))\n\t\tparam->u.crypt.set_tx = 0;  \n\telse\n\t\tparam->u.crypt.set_tx = 1;  \n\n\tparam->u.crypt.idx = key_index;\n\n\tif (params->seq_len && params->seq)\n\t\tmemcpy(param->u.crypt.seq, (u8 *)params->seq, params->seq_len);\n\n\tif (params->key_len && params->key) {\n\t\tparam->u.crypt.key_len = params->key_len;\n\t\tmemcpy(param->u.crypt.key, (u8 *)params->key, params->key_len);\n\t}\n\n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {\n\t\tret =  rtw_cfg80211_set_encryption(ndev, param, param_len);\n\t} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {\n\t\tif (mac_addr)\n\t\t\tmemcpy(param->sta_addr, (void *)mac_addr, ETH_ALEN);\n\n\t\tret = rtw_cfg80211_ap_set_encryption(ndev, param, param_len);\n\t} else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true\n\t\t|| check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {\n\t\tret =  rtw_cfg80211_set_encryption(ndev, param, param_len);\n\t}\n\naddkey_end:\n\tkfree(param);\n\n\treturn ret;\n}\n\nstatic int cfg80211_rtw_get_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\tint link_id, u8 key_index, bool pairwise,\n\t\t\t\tconst u8 *mac_addr, void *cookie,\n\t\t\t\tvoid (*callback)(void *cookie,\n\t\t\t\t\t\t struct key_params*))\n{\n\treturn 0;\n}\n\nstatic int cfg80211_rtw_del_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\tint link_id, u8 key_index, bool pairwise,\n\t\t\t\tconst u8 *mac_addr)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\n\tif (key_index == psecuritypriv->dot11PrivacyKeyIndex) {\n\t\t \n\t\tpsecuritypriv->bWepDefaultKeyIdxSet = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int cfg80211_rtw_set_default_key(struct wiphy *wiphy,\n\t\t\t\t\tstruct net_device *ndev, int link_id,\n\t\t\t\t\tu8 key_index, bool unicast,\n\t\t\t\t\tbool multicast)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\n\tif ((key_index < WEP_KEYS) && ((psecuritypriv->dot11PrivacyAlgrthm == _WEP40_) || (psecuritypriv->dot11PrivacyAlgrthm == _WEP104_))) {  \n\t\tpsecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\n\t\tpsecuritypriv->dot11PrivacyKeyIndex = key_index;\n\n\t\tpsecuritypriv->dot11PrivacyAlgrthm = _WEP40_;\n\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\n\t\tif (psecuritypriv->dot11DefKeylen[key_index] == 13) {\n\t\t\tpsecuritypriv->dot11PrivacyAlgrthm = _WEP104_;\n\t\t\tpsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\n\t\t}\n\n\t\tpsecuritypriv->bWepDefaultKeyIdxSet = 1;  \n\t}\n\n\treturn 0;\n}\n\nstatic int cfg80211_rtw_get_station(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *ndev,\n\t\t\t\tconst u8 *mac,\n\t\t\t\tstruct station_info *sinfo)\n{\n\tint ret = 0;\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct sta_info *psta = NULL;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\n\tsinfo->filled = 0;\n\n\tif (!mac) {\n\t\tret = -ENOENT;\n\t\tgoto exit;\n\t}\n\n\tpsta = rtw_get_stainfo(pstapriv, (u8 *)mac);\n\tif (!psta) {\n\t\tret = -ENOENT;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)\n\t\t&& check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\tstruct wlan_network  *cur_network = &(pmlmepriv->cur_network);\n\n\t\tif (memcmp((u8 *)mac, cur_network->network.mac_address, ETH_ALEN)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\t\tsinfo->signal = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t\tsinfo->txrate.legacy = rtw_get_cur_max_rate(padapter);\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS);\n\t\tsinfo->rx_packets = sta_rx_data_pkts(psta);\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);\n\t\tsinfo->tx_packets = psta->sta_stats.tx_pkts;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);\n\t}\n\n\t \n\tif ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) ||\n\t     check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) ||\n\t     check_fwstate(pmlmepriv, WIFI_AP_STATE)) &&\n\t    check_fwstate(pmlmepriv, _FW_LINKED)) {\n\t\t \n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int cfg80211_rtw_change_iface(struct wiphy *wiphy,\n\t\t\t\t     struct net_device *ndev,\n\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t     struct vif_params *params)\n{\n\tenum nl80211_iftype old_type;\n\tenum ndis_802_11_network_infrastructure networkType;\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct wireless_dev *rtw_wdev = padapter->rtw_wdev;\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\tint ret = 0;\n\n\tif (adapter_to_dvobj(padapter)->processing_dev_remove == true) {\n\t\tret = -EPERM;\n\t\tgoto exit;\n\t}\n\n\t{\n\t\tif (netdev_open(ndev) != 0) {\n\t\t\tret = -EPERM;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (rtw_pwr_wakeup(padapter) == _FAIL) {\n\t\tret = -EPERM;\n\t\tgoto exit;\n\t}\n\n\told_type = rtw_wdev->iftype;\n\n\tif (old_type != type) {\n\t\tpmlmeext->action_public_rxseq = 0xffff;\n\t\tpmlmeext->action_public_dialog_token = 0xff;\n\t}\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tnetworkType = Ndis802_11IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tnetworkType = Ndis802_11Infrastructure;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tnetworkType = Ndis802_11APMode;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tgoto exit;\n\t}\n\n\trtw_wdev->iftype = type;\n\n\tif (rtw_set_802_11_infrastructure_mode(padapter, networkType) == false) {\n\t\trtw_wdev->iftype = old_type;\n\t\tret = -EPERM;\n\t\tgoto exit;\n\t}\n\n\trtw_setopmode_cmd(padapter, networkType, true);\n\nexit:\n\n\treturn ret;\n}\n\nvoid rtw_cfg80211_indicate_scan_done(struct adapter *adapter, bool aborted)\n{\n\tstruct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(adapter);\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = aborted\n\t};\n\n\tspin_lock_bh(&pwdev_priv->scan_req_lock);\n\tif (pwdev_priv->scan_request) {\n\t\t \n\t\tif (pwdev_priv->scan_request->wiphy == pwdev_priv->rtw_wdev->wiphy)\n\t\t\tcfg80211_scan_done(pwdev_priv->scan_request, &info);\n\n\t\tpwdev_priv->scan_request = NULL;\n\t}\n\tspin_unlock_bh(&pwdev_priv->scan_req_lock);\n}\n\nvoid rtw_cfg80211_unlink_bss(struct adapter *padapter, struct wlan_network *pnetwork)\n{\n\tstruct wireless_dev *pwdev = padapter->rtw_wdev;\n\tstruct wiphy *wiphy = pwdev->wiphy;\n\tstruct cfg80211_bss *bss = NULL;\n\tstruct wlan_bssid_ex *select_network = &pnetwork->network;\n\n\tbss = cfg80211_get_bss(wiphy, NULL ,\n\t\t\t       select_network->mac_address,\n\t\t\t       select_network->ssid.ssid,\n\t\t\t       select_network->ssid.ssid_length,\n\t\t\t       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);\n\n\tif (bss) {\n\t\tcfg80211_unlink_bss(wiphy, bss);\n\t\tcfg80211_put_bss(padapter->rtw_wdev->wiphy, bss);\n\t}\n}\n\nvoid rtw_cfg80211_surveydone_event_callback(struct adapter *padapter)\n{\n\tstruct list_head\t\t\t\t\t*plist, *phead;\n\tstruct\tmlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct __queue *queue\t= &(pmlmepriv->scanned_queue);\n\tstruct\twlan_network\t*pnetwork = NULL;\n\n\tspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\n\n\tphead = get_list_head(queue);\n\tlist_for_each(plist, phead)\n\t{\n\t\tpnetwork = list_entry(plist, struct wlan_network, list);\n\n\t\t \n\t\tif (rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.configuration.ds_config) >= 0\n\t\t\t&& true == rtw_validate_ssid(&(pnetwork->network.ssid))) {\n\t\t\t \n\t\t\trtw_cfg80211_inform_bss(padapter, pnetwork);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\n}\n\nstatic int rtw_cfg80211_set_probe_req_wpsp2pie(struct adapter *padapter, char *buf, int len)\n{\n\tint ret = 0;\n\tuint wps_ielen = 0;\n\tu8 *wps_ie;\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\n\tif (len > 0) {\n\t\twps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen);\n\t\tif (wps_ie) {\n\t\t\tif (pmlmepriv->wps_probe_req_ie) {\n\t\t\t\tpmlmepriv->wps_probe_req_ie_len = 0;\n\t\t\t\tkfree(pmlmepriv->wps_probe_req_ie);\n\t\t\t\tpmlmepriv->wps_probe_req_ie = NULL;\n\t\t\t}\n\n\t\t\tpmlmepriv->wps_probe_req_ie = rtw_malloc(wps_ielen);\n\t\t\tif (!pmlmepriv->wps_probe_req_ie)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmemcpy(pmlmepriv->wps_probe_req_ie, wps_ie, wps_ielen);\n\t\t\tpmlmepriv->wps_probe_req_ie_len = wps_ielen;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int cfg80211_rtw_scan(struct wiphy *wiphy\n\t, struct cfg80211_scan_request *request)\n{\n\tstruct net_device *ndev = wdev_to_ndev(request->wdev);\n\tint i;\n\tu8 _status = false;\n\tint ret = 0;\n\tstruct ndis_802_11_ssid *ssid = NULL;\n\tstruct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];\n\tu8 survey_times = 3;\n\tu8 survey_times_for_one_ch = 6;\n\tstruct cfg80211_ssid *ssids = request->ssids;\n\tint j = 0;\n\tbool need_indicate_scan_done = false;\n\n\tstruct adapter *padapter;\n\tstruct rtw_wdev_priv *pwdev_priv;\n\tstruct mlme_priv *pmlmepriv;\n\n\tif (!ndev) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tpadapter = rtw_netdev_priv(ndev);\n\tpwdev_priv = adapter_wdev_data(padapter);\n\tpmlmepriv = &padapter->mlmepriv;\n \n\n\tspin_lock_bh(&pwdev_priv->scan_req_lock);\n\tpwdev_priv->scan_request = request;\n\tspin_unlock_bh(&pwdev_priv->scan_req_lock);\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {\n\t\tif (check_fwstate(pmlmepriv, WIFI_UNDER_WPS | _FW_UNDER_SURVEY | _FW_UNDER_LINKING) == true) {\n\t\t\tneed_indicate_scan_done = true;\n\t\t\tgoto check_need_indicate_scan_done;\n\t\t}\n\t}\n\n\trtw_ps_deny(padapter, PS_DENY_SCAN);\n\tif (rtw_pwr_wakeup(padapter) == _FAIL) {\n\t\tneed_indicate_scan_done = true;\n\t\tgoto check_need_indicate_scan_done;\n\t}\n\n\tif (request->ie && request->ie_len > 0)\n\t\trtw_cfg80211_set_probe_req_wpsp2pie(padapter, (u8 *)request->ie, request->ie_len);\n\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {\n\t\tneed_indicate_scan_done = true;\n\t\tgoto check_need_indicate_scan_done;\n\t} else if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {\n\t\tret = -EBUSY;\n\t\tgoto check_need_indicate_scan_done;\n\t}\n\n\tif (pmlmepriv->LinkDetectInfo.bBusyTraffic == true) {\n\t\tstatic unsigned long lastscantime;\n\t\tunsigned long passtime;\n\n\t\tpasstime = jiffies_to_msecs(jiffies - lastscantime);\n\t\tlastscantime = jiffies;\n\t\tif (passtime > 12000) {\n\t\t\tneed_indicate_scan_done = true;\n\t\t\tgoto check_need_indicate_scan_done;\n\t\t}\n\t}\n\n\tif (rtw_is_scan_deny(padapter)) {\n\t\tneed_indicate_scan_done = true;\n\t\tgoto check_need_indicate_scan_done;\n\t}\n\n\tssid = kzalloc(RTW_SSID_SCAN_AMOUNT * sizeof(struct ndis_802_11_ssid),\n\t\t       GFP_KERNEL);\n\tif (!ssid) {\n\t\tret = -ENOMEM;\n\t\tgoto check_need_indicate_scan_done;\n\t}\n\n\t \n\tfor (i = 0; i < request->n_ssids && i < RTW_SSID_SCAN_AMOUNT; i++) {\n\t\tmemcpy(ssid[i].ssid, ssids[i].ssid, ssids[i].ssid_len);\n\t\tssid[i].ssid_length = ssids[i].ssid_len;\n\t}\n\n\t \n\tmemset(ch, 0, sizeof(struct rtw_ieee80211_channel) * RTW_CHANNEL_SCAN_AMOUNT);\n\tfor (i = 0; i < request->n_channels && i < RTW_CHANNEL_SCAN_AMOUNT; i++) {\n\t\tch[i].hw_value = request->channels[i]->hw_value;\n\t\tch[i].flags = request->channels[i]->flags;\n\t}\n\n\tspin_lock_bh(&pmlmepriv->lock);\n\tif (request->n_channels == 1) {\n\t\tfor (i = 1; i < survey_times_for_one_ch; i++)\n\t\t\tmemcpy(&ch[i], &ch[0], sizeof(struct rtw_ieee80211_channel));\n\t\t_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, ch, survey_times_for_one_ch);\n\t} else if (request->n_channels <= 4) {\n\t\tfor (j = request->n_channels - 1; j >= 0; j--)\n\t\t\tfor (i = 0; i < survey_times; i++)\n\t\t\t\tmemcpy(&ch[j * survey_times + i], &ch[j], sizeof(struct rtw_ieee80211_channel));\n\t\t_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, ch, survey_times * request->n_channels);\n\t} else {\n\t\t_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, NULL, 0);\n\t}\n\tspin_unlock_bh(&pmlmepriv->lock);\n\n\tif (_status == false)\n\t\tret = -1;\n\ncheck_need_indicate_scan_done:\n\tkfree(ssid);\n\tif (need_indicate_scan_done) {\n\t\trtw_cfg80211_surveydone_event_callback(padapter);\n\t\trtw_cfg80211_indicate_scan_done(padapter, false);\n\t}\n\n\trtw_ps_deny_cancel(padapter, PS_DENY_SCAN);\n\nexit:\n\treturn ret;\n}\n\nstatic int cfg80211_rtw_set_wiphy_params(struct wiphy *wiphy, u32 changed)\n{\n\treturn 0;\n}\n\nstatic int rtw_cfg80211_set_wpa_version(struct security_priv *psecuritypriv, u32 wpa_version)\n{\n\tif (!wpa_version) {\n\t\tpsecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;\n\t\treturn 0;\n\t}\n\n\tif (wpa_version & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))\n\t\tpsecuritypriv->ndisauthtype = Ndis802_11AuthModeWPAPSK;\n\n\treturn 0;\n}\n\nstatic int rtw_cfg80211_set_auth_type(struct security_priv *psecuritypriv,\n\t\t\t\t      enum nl80211_auth_type sme_auth_type)\n{\n\tswitch (sme_auth_type) {\n\tcase NL80211_AUTHTYPE_AUTOMATIC:\n\n\t\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;\n\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\n\t\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\n\n\t\tif (psecuritypriv->ndisauthtype > Ndis802_11AuthModeWPA)\n\t\t\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\n\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_SHARED_KEY:\n\n\t\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;\n\n\t\tpsecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\n\t\tbreak;\n\tdefault:\n\t\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\n\t\t \n\t}\n\n\treturn 0;\n}\n\nstatic int rtw_cfg80211_set_cipher(struct security_priv *psecuritypriv, u32 cipher, bool ucast)\n{\n\tu32 ndisencryptstatus = Ndis802_11EncryptionDisabled;\n\n\tu32 *profile_cipher = ucast ? &psecuritypriv->dot11PrivacyAlgrthm :\n\t\t&psecuritypriv->dot118021XGrpPrivacy;\n\n\tif (!cipher) {\n\t\t*profile_cipher = _NO_PRIVACY_;\n\t\tpsecuritypriv->ndisencryptstatus = ndisencryptstatus;\n\t\treturn 0;\n\t}\n\n\tswitch (cipher) {\n\tcase IW_AUTH_CIPHER_NONE:\n\t\t*profile_cipher = _NO_PRIVACY_;\n\t\tndisencryptstatus = Ndis802_11EncryptionDisabled;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\t*profile_cipher = _WEP40_;\n\t\tndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t*profile_cipher = _WEP104_;\n\t\tndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t*profile_cipher = _TKIP_;\n\t\tndisencryptstatus = Ndis802_11Encryption2Enabled;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t*profile_cipher = _AES_;\n\t\tndisencryptstatus = Ndis802_11Encryption3Enabled;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (ucast) {\n\t\tpsecuritypriv->ndisencryptstatus = ndisencryptstatus;\n\n\t\t \n\t\t \n\t}\n\n\treturn 0;\n}\n\nstatic int rtw_cfg80211_set_key_mgt(struct security_priv *psecuritypriv, u32 key_mgt)\n{\n\tif (key_mgt == WLAN_AKM_SUITE_8021X)\n\t\t \n\t\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\n\telse if (key_mgt == WLAN_AKM_SUITE_PSK) {\n\t\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw_cfg80211_set_wpa_ie(struct adapter *padapter, u8 *pie, size_t ielen)\n{\n\tu8 *buf = NULL;\n\tint group_cipher = 0, pairwise_cipher = 0;\n\tint ret = 0;\n\tint wpa_ielen = 0;\n\tint wpa2_ielen = 0;\n\tu8 *pwpa, *pwpa2;\n\tu8 null_addr[] = {0, 0, 0, 0, 0, 0};\n\n\tif (!pie || !ielen) {\n\t\t \n\t\t_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);\n\t\tgoto exit;\n\t}\n\n\tif (ielen > MAX_WPA_IE_LEN + MAX_WPS_IE_LEN + MAX_P2P_IE_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tbuf = rtw_zmalloc(ielen);\n\tif (!buf) {\n\t\tret =  -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(buf, pie, ielen);\n\n\tif (ielen < RSN_HEADER_LEN) {\n\t\tret  = -1;\n\t\tgoto exit;\n\t}\n\n\tpwpa = rtw_get_wpa_ie(buf, &wpa_ielen, ielen);\n\tif (pwpa && wpa_ielen > 0) {\n\t\tif (rtw_parse_wpa_ie(pwpa, wpa_ielen + 2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {\n\t\t\tpadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\n\t\t\tpadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPAPSK;\n\t\t\tmemcpy(padapter->securitypriv.supplicant_ie, &pwpa[0], wpa_ielen + 2);\n\t\t}\n\t}\n\n\tpwpa2 = rtw_get_wpa2_ie(buf, &wpa2_ielen, ielen);\n\tif (pwpa2 && wpa2_ielen > 0) {\n\t\tif (rtw_parse_wpa2_ie(pwpa2, wpa2_ielen + 2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {\n\t\t\tpadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\n\t\t\tpadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPA2PSK;\n\t\t\tmemcpy(padapter->securitypriv.supplicant_ie, &pwpa2[0], wpa2_ielen + 2);\n\t\t}\n\t}\n\n\tif (group_cipher == 0)\n\t\tgroup_cipher = WPA_CIPHER_NONE;\n\n\tif (pairwise_cipher == 0)\n\t\tpairwise_cipher = WPA_CIPHER_NONE;\n\n\tswitch (group_cipher) {\n\tcase WPA_CIPHER_NONE:\n\t\tpadapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;\n\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;\n\t\tbreak;\n\tcase WPA_CIPHER_WEP40:\n\t\tpadapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;\n\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\tbreak;\n\tcase WPA_CIPHER_TKIP:\n\t\tpadapter->securitypriv.dot118021XGrpPrivacy = _TKIP_;\n\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;\n\t\tbreak;\n\tcase WPA_CIPHER_CCMP:\n\t\tpadapter->securitypriv.dot118021XGrpPrivacy = _AES_;\n\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;\n\t\tbreak;\n\tcase WPA_CIPHER_WEP104:\n\t\tpadapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;\n\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\tbreak;\n\t}\n\n\tswitch (pairwise_cipher) {\n\tcase WPA_CIPHER_NONE:\n\t\tpadapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;\n\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;\n\t\tbreak;\n\tcase WPA_CIPHER_WEP40:\n\t\tpadapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;\n\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\tbreak;\n\tcase WPA_CIPHER_TKIP:\n\t\tpadapter->securitypriv.dot11PrivacyAlgrthm = _TKIP_;\n\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;\n\t\tbreak;\n\tcase WPA_CIPHER_CCMP:\n\t\tpadapter->securitypriv.dot11PrivacyAlgrthm = _AES_;\n\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;\n\t\tbreak;\n\tcase WPA_CIPHER_WEP104:\n\t\tpadapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;\n\t\tpadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\n\t\tbreak;\n\t}\n\n\t{ \n\t\tuint wps_ielen;\n\t\tu8 *wps_ie;\n\n\t\twps_ie = rtw_get_wps_ie(buf, ielen, NULL, &wps_ielen);\n\t\tif (wps_ie && wps_ielen > 0) {\n\t\t\tpadapter->securitypriv.wps_ie_len = min_t(uint, wps_ielen, MAX_WPS_IE_LEN);\n\t\t\tmemcpy(padapter->securitypriv.wps_ie, wps_ie, padapter->securitypriv.wps_ie_len);\n\t\t\tset_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS);\n\t\t} else {\n\t\t\t_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);\n\t\t}\n\t}\n\n\t \n\tif (padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_\n\t\t|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_\n\t\t|| padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)\n\t\t \n\t\t \n\t\trtw_hal_set_hwreg(padapter, HW_VAR_OFF_RCR_AM, null_addr);\n\nexit:\n\tkfree(buf);\n\tif (ret)\n\t\t_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);\n\treturn ret;\n}\n\nstatic int cfg80211_rtw_join_ibss(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\t  struct cfg80211_ibss_params *params)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct ndis_802_11_ssid ndis_ssid;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tint ret = 0;\n\n\tif (rtw_pwr_wakeup(padapter) == _FAIL) {\n\t\tret = -EPERM;\n\t\tgoto exit;\n\t}\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\tret = -EPERM;\n\t\tgoto exit;\n\t}\n\n\tif (!params->ssid || !params->ssid_len) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (params->ssid_len > IW_ESSID_MAX_SIZE) {\n\t\tret = -E2BIG;\n\t\tgoto exit;\n\t}\n\n\tmemset(&ndis_ssid, 0, sizeof(struct ndis_802_11_ssid));\n\tndis_ssid.ssid_length = params->ssid_len;\n\tmemcpy(ndis_ssid.ssid, (u8 *)params->ssid, params->ssid_len);\n\n\tpsecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;\n\tpsecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;\n\tpsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\n\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;  \n\tpsecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;\n\n\tret = rtw_cfg80211_set_auth_type(psecuritypriv, NL80211_AUTHTYPE_OPEN_SYSTEM);\n\trtw_set_802_11_authentication_mode(padapter, psecuritypriv->ndisauthtype);\n\n\tif (rtw_set_802_11_ssid(padapter, &ndis_ssid) == false) {\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int cfg80211_rtw_leave_ibss(struct wiphy *wiphy, struct net_device *ndev)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct wireless_dev *rtw_wdev = padapter->rtw_wdev;\n\tenum nl80211_iftype old_type;\n\tint ret = 0;\n\n\told_type = rtw_wdev->iftype;\n\n\trtw_set_to_roam(padapter, 0);\n\n\tif (check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {\n\t\trtw_scan_abort(padapter);\n\t\tLeaveAllPowerSaveMode(padapter);\n\n\t\trtw_wdev->iftype = NL80211_IFTYPE_STATION;\n\n\t\tif (rtw_set_802_11_infrastructure_mode(padapter, Ndis802_11Infrastructure) == false) {\n\t\t\trtw_wdev->iftype = old_type;\n\t\t\tret = -EPERM;\n\t\t\tgoto leave_ibss;\n\t\t}\n\t\trtw_setopmode_cmd(padapter, Ndis802_11Infrastructure, true);\n\t}\n\nleave_ibss:\n\treturn ret;\n}\n\nstatic int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\tstruct cfg80211_connect_params *sme)\n{\n\tint ret = 0;\n\tenum ndis_802_11_authentication_mode authmode;\n\tstruct ndis_802_11_ssid ndis_ssid;\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\n\tpadapter->mlmepriv.not_indic_disco = true;\n\n\tif (adapter_wdev_data(padapter)->block == true) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\trtw_ps_deny(padapter, PS_DENY_JOIN);\n\tif (rtw_pwr_wakeup(padapter) == _FAIL) {\n\t\tret = -EPERM;\n\t\tgoto exit;\n\t}\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\n\t\tret = -EPERM;\n\t\tgoto exit;\n\t}\n\n\tif (!sme->ssid || !sme->ssid_len) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (sme->ssid_len > IW_ESSID_MAX_SIZE) {\n\t\tret = -E2BIG;\n\t\tgoto exit;\n\t}\n\n\tmemset(&ndis_ssid, 0, sizeof(struct ndis_802_11_ssid));\n\tndis_ssid.ssid_length = sme->ssid_len;\n\tmemcpy(ndis_ssid.ssid, (u8 *)sme->ssid, sme->ssid_len);\n\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\tif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)\n\t\trtw_scan_abort(padapter);\n\n\tpsecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;\n\tpsecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;\n\tpsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\n\tpsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;  \n\tpsecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;\n\n\tret = rtw_cfg80211_set_wpa_version(psecuritypriv, sme->crypto.wpa_versions);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tret = rtw_cfg80211_set_auth_type(psecuritypriv, sme->auth_type);\n\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tret = rtw_cfg80211_set_wpa_ie(padapter, (u8 *)sme->ie, sme->ie_len);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif (sme->crypto.n_ciphers_pairwise) {\n\t\tret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.ciphers_pairwise[0], true);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tif ((psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Shared ||\n\t     psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Auto) && sme->key) {\n\t\tu32 wep_key_idx, wep_key_len, wep_total_len;\n\t\tstruct ndis_802_11_wep\t *pwep = NULL;\n\n\t\twep_key_idx = sme->key_idx;\n\t\twep_key_len = sme->key_len;\n\n\t\tif (sme->key_idx > WEP_KEYS) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (wep_key_len > 0) {\n\t\t\twep_key_len = wep_key_len <= 5 ? 5 : 13;\n\t\t\twep_total_len = wep_key_len + FIELD_OFFSET(struct ndis_802_11_wep, key_material);\n\t\t\tpwep = rtw_malloc(wep_total_len);\n\t\t\tif (!pwep) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tmemset(pwep, 0, wep_total_len);\n\n\t\t\tpwep->key_length = wep_key_len;\n\t\t\tpwep->length = wep_total_len;\n\n\t\t\tif (wep_key_len == 13) {\n\t\t\t\tpadapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;\n\t\t\t\tpadapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tpwep->key_index = wep_key_idx;\n\t\tpwep->key_index |= 0x80000000;\n\n\t\tmemcpy(pwep->key_material,  (void *)sme->key, pwep->key_length);\n\n\t\tif (rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)\n\t\t\tret = -EOPNOTSUPP;\n\n\t\tkfree(pwep);\n\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t}\n\n\tret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.cipher_group, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (sme->crypto.n_akm_suites) {\n\t\tret = rtw_cfg80211_set_key_mgt(psecuritypriv, sme->crypto.akm_suites[0]);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t}\n\n\tauthmode = psecuritypriv->ndisauthtype;\n\trtw_set_802_11_authentication_mode(padapter, authmode);\n\n\t \n\n\tif (rtw_set_802_11_connect(padapter, (u8 *)sme->bssid, &ndis_ssid) == false) {\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n\nexit:\n\n\trtw_ps_deny_cancel(padapter, PS_DENY_JOIN);\n\n\tpadapter->mlmepriv.not_indic_disco = false;\n\n\treturn ret;\n}\n\nstatic int cfg80211_rtw_disconnect(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\t   u16 reason_code)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\n\trtw_set_to_roam(padapter, 0);\n\n\trtw_scan_abort(padapter);\n\tLeaveAllPowerSaveMode(padapter);\n\trtw_disassoc_cmd(padapter, 500, false);\n\n\trtw_indicate_disconnect(padapter);\n\n\trtw_free_assoc_resources(padapter, 1);\n\trtw_pwr_wakeup(padapter);\n\n\treturn 0;\n}\n\nstatic int cfg80211_rtw_set_txpower(struct wiphy *wiphy,\n\t\t\t\t    struct wireless_dev *wdev,\n\t\t\t\t    enum nl80211_tx_power_setting type, int mbm)\n{\n\treturn 0;\n}\n\nstatic int cfg80211_rtw_get_txpower(struct wiphy *wiphy,\n\t\t\t\t    struct wireless_dev *wdev, int *dbm)\n{\n\t*dbm = (12);\n\n\treturn 0;\n}\n\ninline bool rtw_cfg80211_pwr_mgmt(struct adapter *adapter)\n{\n\tstruct rtw_wdev_priv *rtw_wdev_priv = adapter_wdev_data(adapter);\n\n\treturn rtw_wdev_priv->power_mgmt;\n}\n\nstatic int cfg80211_rtw_set_power_mgmt(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *ndev,\n\t\t\t\t       bool enabled, int timeout)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct rtw_wdev_priv *rtw_wdev_priv = adapter_wdev_data(padapter);\n\n\trtw_wdev_priv->power_mgmt = enabled;\n\n\tif (!enabled)\n\t\tLPS_Leave(padapter, \"CFG80211_PWRMGMT\");\n\n\treturn 0;\n}\n\nstatic int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *ndev,\n\t\t\t\t  struct cfg80211_pmksa *pmksa)\n{\n\tu8 index, blInserted = false;\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\n\tif (is_zero_ether_addr((u8 *)pmksa->bssid))\n\t\treturn -EINVAL;\n\n\tblInserted = false;\n\n\t \n\tfor (index = 0 ; index < NUM_PMKID_CACHE; index++) {\n\t\tif (!memcmp(psecuritypriv->PMKIDList[index].Bssid, (u8 *)pmksa->bssid, ETH_ALEN)) {\n\t\t\tmemcpy(psecuritypriv->PMKIDList[index].PMKID, (u8 *)pmksa->pmkid, WLAN_PMKID_LEN);\n\t\t\tpsecuritypriv->PMKIDList[index].bUsed = true;\n\t\t\tpsecuritypriv->PMKIDIndex = index + 1;\n\t\t\tblInserted = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!blInserted) {\n\t\tmemcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, (u8 *)pmksa->bssid, ETH_ALEN);\n\t\tmemcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, (u8 *)pmksa->pmkid, WLAN_PMKID_LEN);\n\n\t\tpsecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = true;\n\t\tpsecuritypriv->PMKIDIndex++;\n\t\tif (psecuritypriv->PMKIDIndex == 16)\n\t\t\tpsecuritypriv->PMKIDIndex = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int cfg80211_rtw_del_pmksa(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *ndev,\n\t\t\t\t  struct cfg80211_pmksa *pmksa)\n{\n\tu8 index, bMatched = false;\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\n\tfor (index = 0 ; index < NUM_PMKID_CACHE; index++) {\n\t\tif (!memcmp(psecuritypriv->PMKIDList[index].Bssid, (u8 *)pmksa->bssid, ETH_ALEN)) {\n\t\t\t \n\t\t\teth_zero_addr(psecuritypriv->PMKIDList[index].Bssid);\n\t\t\tmemset(psecuritypriv->PMKIDList[index].PMKID, 0x00, WLAN_PMKID_LEN);\n\t\t\tpsecuritypriv->PMKIDList[index].bUsed = false;\n\t\t\tbMatched = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!bMatched)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cfg80211_rtw_flush_pmksa(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *ndev)\n{\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct security_priv *psecuritypriv = &padapter->securitypriv;\n\n\tmemset(&psecuritypriv->PMKIDList[0], 0x00, sizeof(struct rt_pmkid_list) * NUM_PMKID_CACHE);\n\tpsecuritypriv->PMKIDIndex = 0;\n\n\treturn 0;\n}\n\nvoid rtw_cfg80211_indicate_sta_assoc(struct adapter *padapter, u8 *pmgmt_frame, uint frame_len)\n{\n\tstruct net_device *ndev = padapter->pnetdev;\n\n\t{\n\t\tstruct station_info sinfo = {};\n\t\tu8 ie_offset;\n\n\t\tif (GetFrameSubType(pmgmt_frame) == WIFI_ASSOCREQ)\n\t\t\tie_offset = _ASOCREQ_IE_OFFSET_;\n\t\telse  \n\t\t\tie_offset = _REASOCREQ_IE_OFFSET_;\n\n\t\tsinfo.filled = 0;\n\t\tsinfo.assoc_req_ies = pmgmt_frame + WLAN_HDR_A3_LEN + ie_offset;\n\t\tsinfo.assoc_req_ies_len = frame_len - WLAN_HDR_A3_LEN - ie_offset;\n\t\tcfg80211_new_sta(ndev, GetAddr2Ptr(pmgmt_frame), &sinfo, GFP_ATOMIC);\n\t}\n}\n\nvoid rtw_cfg80211_indicate_sta_disassoc(struct adapter *padapter, unsigned char *da, unsigned short reason)\n{\n\tstruct net_device *ndev = padapter->pnetdev;\n\n\tcfg80211_del_sta(ndev, da, GFP_ATOMIC);\n}\n\nstatic u8 rtw_get_chan_type(struct adapter *adapter)\n{\n\tstruct mlme_ext_priv *mlme_ext = &adapter->mlmeextpriv;\n\n\tswitch (mlme_ext->cur_bwmode) {\n\tcase CHANNEL_WIDTH_20:\n\t\tif (is_supported_ht(adapter->registrypriv.wireless_mode))\n\t\t\treturn NL80211_CHAN_HT20;\n\t\telse\n\t\t\treturn NL80211_CHAN_NO_HT;\n\tcase CHANNEL_WIDTH_40:\n\t\tif (mlme_ext->cur_ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)\n\t\t\treturn NL80211_CHAN_HT40PLUS;\n\t\telse\n\t\t\treturn NL80211_CHAN_HT40MINUS;\n\tdefault:\n\t\treturn NL80211_CHAN_HT20;\n\t}\n\n\treturn NL80211_CHAN_HT20;\n}\n\nstatic int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\t    unsigned int link_id,\n\t\t\t\t    struct cfg80211_chan_def *chandef)\n{\n\tstruct adapter *adapter = wiphy_to_adapter(wiphy);\n\tstruct registry_priv *registrypriv = &adapter->registrypriv;\n\tenum nl80211_channel_type chan_type;\n\tstruct ieee80211_channel *chan = NULL;\n\tint channel;\n\tint freq;\n\n\tif (!adapter->rtw_wdev)\n\t\treturn -ENODEV;\n\n\tchannel = rtw_get_oper_ch(adapter);\n\tif (!channel)\n\t\treturn -ENODATA;\n\n\tfreq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);\n\n\tchan = ieee80211_get_channel(adapter->rtw_wdev->wiphy, freq);\n\n\tif (registrypriv->ht_enable) {\n\t\tchan_type = rtw_get_chan_type(adapter);\n\t\tcfg80211_chandef_create(chandef, chan, chan_type);\n\t} else {\n\t\tcfg80211_chandef_create(chandef, chan, NL80211_CHAN_NO_HT);\n\t}\n\n\treturn 0;\n}\n\nstatic netdev_tx_t rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_device *ndev)\n{\n\tint rtap_len;\n\tint qos_len = 0;\n\tint dot11_hdr_len = 24;\n\tint snap_len = 6;\n\tunsigned char *pdata;\n\tu16 frame_control;\n\tunsigned char src_mac_addr[6];\n\tunsigned char dst_mac_addr[6];\n\tstruct ieee80211_hdr *dot11_hdr;\n\tstruct ieee80211_radiotap_header *rtap_hdr;\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\n\tif (!skb)\n\t\tgoto fail;\n\n\tif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\n\t\tgoto fail;\n\n\trtap_hdr = (struct ieee80211_radiotap_header *)skb->data;\n\tif (unlikely(rtap_hdr->it_version))\n\t\tgoto fail;\n\n\trtap_len = ieee80211_get_radiotap_len(skb->data);\n\tif (unlikely(skb->len < rtap_len))\n\t\tgoto fail;\n\n\tif (rtap_len != 14)\n\t\tgoto fail;\n\n\t \n\tskb_pull(skb, rtap_len);\n\n\tdot11_hdr = (struct ieee80211_hdr *)skb->data;\n\tframe_control = le16_to_cpu(dot11_hdr->frame_control);\n\t \n\tif ((frame_control & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA) {\n\t\t \n\t\tif (frame_control & 0x0080)\n\t\t\tqos_len = 2;\n\t\tif ((frame_control & 0x0300) == 0x0300)\n\t\t\tdot11_hdr_len += 6;\n\n\t\tmemcpy(dst_mac_addr, dot11_hdr->addr1, sizeof(dst_mac_addr));\n\t\tmemcpy(src_mac_addr, dot11_hdr->addr2, sizeof(src_mac_addr));\n\n\t\t \n\t\tskb_pull(skb, dot11_hdr_len + qos_len + snap_len - sizeof(src_mac_addr) * 2);\n\t\tpdata = (unsigned char *)skb->data;\n\t\tmemcpy(pdata, dst_mac_addr, sizeof(dst_mac_addr));\n\t\tmemcpy(pdata + sizeof(dst_mac_addr), src_mac_addr, sizeof(src_mac_addr));\n\n\t\t \n\t\t_rtw_xmit_entry(skb, padapter->pnetdev);\n\t\treturn NETDEV_TX_OK;\n\n\t} else if ((frame_control & (IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) ==\n\t\t   (IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ACTION)) {\n\t\t \n\t\tstruct xmit_frame\t\t*pmgntframe;\n\t\tstruct pkt_attrib\t*pattrib;\n\t\tunsigned char *pframe;\n\t\t \n\t\t \n\t\tstruct ieee80211_hdr *pwlanhdr;\n\t\tstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\n\t\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\t\tu8 *buf = skb->data;\n\t\tu32 len = skb->len;\n\t\tu8 category, action;\n\n\t\tif (rtw_action_frame_parse(buf, len, &category, &action) == false)\n\t\t\tgoto fail;\n\n\t\t \n\t\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\t\tif (!pmgntframe)\n\t\t\tgoto fail;\n\n\t\t \n\t\tpattrib = &pmgntframe->attrib;\n\t\tupdate_mgntframe_attrib(padapter, pattrib);\n\t\tpattrib->retry_ctrl = false;\n\n\t\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\t\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\n\t\tmemcpy(pframe, (void *)buf, len);\n\t\tpattrib->pktlen = len;\n\n\t\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\t\t \n\t\tpmlmeext->mgnt_seq = GetSequence(pwlanhdr);\n\t\tpattrib->seqnum = pmlmeext->mgnt_seq;\n\t\tpmlmeext->mgnt_seq++;\n\n\t\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\t\tdump_mgntframe(padapter, pmgntframe);\n\t}\n\nfail:\n\n\tdev_kfree_skb_any(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops rtw_cfg80211_monitor_if_ops = {\n\t.ndo_start_xmit = rtw_cfg80211_monitor_if_xmit_entry,\n};\n\nstatic int rtw_cfg80211_add_monitor_if(struct adapter *padapter, char *name, struct net_device **ndev)\n{\n\tint ret = 0;\n\tstruct net_device *mon_ndev = NULL;\n\tstruct wireless_dev *mon_wdev = NULL;\n\tstruct rtw_netdev_priv_indicator *pnpi;\n\tstruct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(padapter);\n\n\tif (!name) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (pwdev_priv->pmon_ndev) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tmon_ndev = alloc_etherdev(sizeof(struct rtw_netdev_priv_indicator));\n\tif (!mon_ndev) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmon_ndev->type = ARPHRD_IEEE80211_RADIOTAP;\n\tstrncpy(mon_ndev->name, name, IFNAMSIZ);\n\tmon_ndev->name[IFNAMSIZ - 1] = 0;\n\tmon_ndev->needs_free_netdev = true;\n\tmon_ndev->priv_destructor = rtw_ndev_destructor;\n\n\tmon_ndev->netdev_ops = &rtw_cfg80211_monitor_if_ops;\n\n\tpnpi = netdev_priv(mon_ndev);\n\tpnpi->priv = padapter;\n\tpnpi->sizeof_priv = sizeof(struct adapter);\n\n\t \n\tmon_wdev = rtw_zmalloc(sizeof(struct wireless_dev));\n\tif (!mon_wdev) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmon_wdev->wiphy = padapter->rtw_wdev->wiphy;\n\tmon_wdev->netdev = mon_ndev;\n\tmon_wdev->iftype = NL80211_IFTYPE_MONITOR;\n\tmon_ndev->ieee80211_ptr = mon_wdev;\n\n\tret = cfg80211_register_netdevice(mon_ndev);\n\tif (ret)\n\t\tgoto out;\n\n\t*ndev = pwdev_priv->pmon_ndev = mon_ndev;\n\tmemcpy(pwdev_priv->ifname_mon, name, IFNAMSIZ + 1);\n\nout:\n\tif (ret && mon_wdev) {\n\t\tkfree(mon_wdev);\n\t\tmon_wdev = NULL;\n\t}\n\n\tif (ret && mon_ndev) {\n\t\tfree_netdev(mon_ndev);\n\t\t*ndev = mon_ndev = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic struct wireless_dev *\n\tcfg80211_rtw_add_virtual_intf(\n\t\tstruct wiphy *wiphy,\n\t\tconst char *name,\n\t\tunsigned char name_assign_type,\n\t\tenum nl80211_iftype type, struct vif_params *params)\n{\n\tint ret = 0;\n\tstruct net_device *ndev = NULL;\n\tstruct adapter *padapter = wiphy_to_adapter(wiphy);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tret = -ENODEV;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tret = rtw_cfg80211_add_monitor_if(padapter, (char *)name, &ndev);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tret = -ENODEV;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_AP:\n\t\tret = -ENODEV;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t\tbreak;\n\t}\n\n\treturn ndev ? ndev->ieee80211_ptr : ERR_PTR(ret);\n}\n\nstatic int cfg80211_rtw_del_virtual_intf(struct wiphy *wiphy,\n\t\t\t\t\t struct wireless_dev *wdev\n)\n{\n\tstruct net_device *ndev = wdev_to_ndev(wdev);\n\tint ret = 0;\n\tstruct adapter *adapter;\n\tstruct rtw_wdev_priv *pwdev_priv;\n\n\tif (!ndev) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tadapter = rtw_netdev_priv(ndev);\n\tpwdev_priv = adapter_wdev_data(adapter);\n\n\tcfg80211_unregister_netdevice(ndev);\n\n\tif (ndev == pwdev_priv->pmon_ndev) {\n\t\tpwdev_priv->pmon_ndev = NULL;\n\t\tpwdev_priv->ifname_mon[0] = '\\0';\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int rtw_add_beacon(struct adapter *adapter, const u8 *head, size_t head_len, const u8 *tail, size_t tail_len)\n{\n\tint ret = 0;\n\tu8 *pbuf = NULL;\n\tuint len, wps_ielen = 0;\n\tstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\n\n\tif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\n\t\treturn -EINVAL;\n\n\tif (head_len < 24)\n\t\treturn -EINVAL;\n\n\tpbuf = rtw_zmalloc(head_len + tail_len);\n\tif (!pbuf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(pbuf, (void *)head + 24, head_len - 24); \n\tmemcpy(pbuf + head_len - 24, (void *)tail, tail_len);\n\n\tlen = head_len + tail_len - 24;\n\n\t \n\trtw_get_wps_ie(pbuf + _FIXED_IE_LENGTH_, len - _FIXED_IE_LENGTH_, NULL, &wps_ielen);\n\n\t \n\trtw_ies_remove_ie(pbuf, &len, _BEACON_IE_OFFSET_, WLAN_EID_VENDOR_SPECIFIC, P2P_OUI, 4);\n\trtw_ies_remove_ie(pbuf, &len, _BEACON_IE_OFFSET_, WLAN_EID_VENDOR_SPECIFIC, WFD_OUI, 4);\n\n\tif (rtw_check_beacon_data(adapter, pbuf,  len) == _SUCCESS)\n\t\tret = 0;\n\telse\n\t\tret = -EINVAL;\n\n\tkfree(pbuf);\n\n\treturn ret;\n}\n\nstatic int cfg80211_rtw_start_ap(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\t struct cfg80211_ap_settings *settings)\n{\n\tint ret = 0;\n\tstruct adapter *adapter = rtw_netdev_priv(ndev);\n\n\tret = rtw_add_beacon(adapter, settings->beacon.head,\n\t\t\t     settings->beacon.head_len, settings->beacon.tail,\n\t\t\t     settings->beacon.tail_len);\n\n\tadapter->mlmeextpriv.mlmext_info.hidden_ssid_mode = settings->hidden_ssid;\n\n\tif (settings->ssid && settings->ssid_len) {\n\t\tstruct wlan_bssid_ex *pbss_network = &adapter->mlmepriv.cur_network.network;\n\t\tstruct wlan_bssid_ex *pbss_network_ext = &adapter->mlmeextpriv.mlmext_info.network;\n\n\t\tmemcpy(pbss_network->ssid.ssid, (void *)settings->ssid, settings->ssid_len);\n\t\tpbss_network->ssid.ssid_length = settings->ssid_len;\n\t\tmemcpy(pbss_network_ext->ssid.ssid, (void *)settings->ssid, settings->ssid_len);\n\t\tpbss_network_ext->ssid.ssid_length = settings->ssid_len;\n\t}\n\n\treturn ret;\n}\n\nstatic int cfg80211_rtw_change_beacon(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *ndev,\n\t\t\t\t      struct cfg80211_beacon_data *info)\n{\n\tstruct adapter *adapter = rtw_netdev_priv(ndev);\n\n\treturn rtw_add_beacon(adapter, info->head, info->head_len, info->tail, info->tail_len);\n}\n\nstatic int cfg80211_rtw_stop_ap(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\tunsigned int link_id)\n{\n\treturn 0;\n}\n\nstatic int\tcfg80211_rtw_add_station(struct wiphy *wiphy,\n\t\t\t\t\t struct net_device *ndev,\n\t\t\t\t\t const u8 *mac,\n\t\t\t\t\t struct station_parameters *params)\n{\n\treturn 0;\n}\n\nstatic int cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\t    struct station_del_parameters *params)\n{\n\tint ret = 0;\n\tstruct list_head *phead, *plist, *tmp;\n\tu8 updated = false;\n\tstruct sta_info *psta = NULL;\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\tconst u8 *mac = params->mac;\n\n\tif (check_fwstate(pmlmepriv, (_FW_LINKED | WIFI_AP_STATE)) != true)\n\t\treturn -EINVAL;\n\n\tif (!mac) {\n\t\tflush_all_cam_entry(padapter);\t \n\n\t\trtw_sta_flush(padapter);\n\n\t\treturn 0;\n\t}\n\n\tif (mac[0] == 0xff && mac[1] == 0xff &&\n\t    mac[2] == 0xff && mac[3] == 0xff &&\n\t    mac[4] == 0xff && mac[5] == 0xff) {\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\n\tphead = &pstapriv->asoc_list;\n\t \n\tlist_for_each_safe(plist, tmp, phead) {\n\t\tpsta = list_entry(plist, struct sta_info, asoc_list);\n\n\t\tif (!memcmp((u8 *)mac, psta->hwaddr, ETH_ALEN)) {\n\t\t\tif (psta->dot8021xalg != 1 || psta->bpairwise_key_installed) {\n\t\t\t\tlist_del_init(&psta->asoc_list);\n\t\t\t\tpstapriv->asoc_list_cnt--;\n\n\t\t\t\tupdated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);\n\n\t\t\t\tpsta = NULL;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\n\tassociated_clients_update(padapter, updated);\n\n\treturn ret;\n}\n\nstatic int cfg80211_rtw_change_station(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *ndev,\n\t\t\t\t       const u8 *mac,\n\t\t\t\t       struct station_parameters *params)\n{\n\treturn 0;\n}\n\nstatic struct sta_info *rtw_sta_info_get_by_idx(const int idx, struct sta_priv *pstapriv)\n\n{\n\tstruct list_head\t*phead, *plist;\n\tstruct sta_info *psta = NULL;\n\tint i = 0;\n\n\tphead = &pstapriv->asoc_list;\n\tplist = get_next(phead);\n\n\t \n\twhile (phead != plist) {\n\t\tif (idx == i)\n\t\t\tpsta = container_of(plist, struct sta_info, asoc_list);\n\t\tplist = get_next(plist);\n\t\ti++;\n\t}\n\treturn psta;\n}\n\nstatic int\tcfg80211_rtw_dump_station(struct wiphy *wiphy,\n\t\t\t\t\t  struct net_device *ndev,\n\t\t\t\t\t  int idx, u8 *mac,\n\t\t\t\t\t  struct station_info *sinfo)\n{\n\tint ret = 0;\n\tstruct adapter *padapter = rtw_netdev_priv(ndev);\n\tstruct sta_info *psta = NULL;\n\tstruct sta_priv *pstapriv = &padapter->stapriv;\n\n\tspin_lock_bh(&pstapriv->asoc_list_lock);\n\tpsta = rtw_sta_info_get_by_idx(idx, pstapriv);\n\tspin_unlock_bh(&pstapriv->asoc_list_lock);\n\tif (psta == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto exit;\n\t}\n\tmemcpy(mac, psta->hwaddr, ETH_ALEN);\n\tsinfo->filled = BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\tsinfo->signal = psta->rssi;\n\nexit:\n\treturn ret;\n}\n\nstatic int\tcfg80211_rtw_change_bss(struct wiphy *wiphy,\n\t\t\t\t\tstruct net_device *ndev,\n\t\t\t\t\tstruct bss_parameters *params)\n{\n\treturn 0;\n}\n\nvoid rtw_cfg80211_rx_action(struct adapter *adapter, u8 *frame, uint frame_len, const char *msg)\n{\n\ts32 freq;\n\tint channel;\n\tu8 category, action;\n\n\tchannel = rtw_get_oper_ch(adapter);\n\n\trtw_action_frame_parse(frame, frame_len, &category, &action);\n\n\tfreq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);\n\n\trtw_cfg80211_rx_mgmt(adapter, freq, 0, frame, frame_len, GFP_ATOMIC);\n}\n\nstatic int _cfg80211_rtw_mgmt_tx(struct adapter *padapter, u8 tx_ch, const u8 *buf, size_t len)\n{\n\tstruct xmit_frame\t*pmgntframe;\n\tstruct pkt_attrib\t*pattrib;\n\tunsigned char *pframe;\n\tint ret = _FAIL;\n\tbool __maybe_unused ack = true;\n\tstruct ieee80211_hdr *pwlanhdr;\n\tstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\n\tstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\n\n\trtw_set_scan_deny(padapter, 1000);\n\n\trtw_scan_abort(padapter);\n\tif (tx_ch != rtw_get_oper_ch(padapter)) {\n\t\tif (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))\n\t\t\tpmlmeext->cur_channel = tx_ch;\n\t\tset_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);\n\t}\n\n\t \n\tpmgntframe = alloc_mgtxmitframe(pxmitpriv);\n\tif (!pmgntframe) {\n\t\t \n\t\tret = _FAIL;\n\t\tgoto exit;\n\t}\n\n\t \n\tpattrib = &pmgntframe->attrib;\n\tupdate_mgntframe_attrib(padapter, pattrib);\n\tpattrib->retry_ctrl = false;\n\n\tmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\n\n\tpframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\n\n\tmemcpy(pframe, (void *)buf, len);\n\tpattrib->pktlen = len;\n\n\tpwlanhdr = (struct ieee80211_hdr *)pframe;\n\t \n\tpmlmeext->mgnt_seq = GetSequence(pwlanhdr);\n\tpattrib->seqnum = pmlmeext->mgnt_seq;\n\tpmlmeext->mgnt_seq++;\n\n\tpattrib->last_txcmdsz = pattrib->pktlen;\n\n\tif (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS) {\n\t\tack = false;\n\t\tret = _FAIL;\n\n\t} else {\n\t\tmsleep(50);\n\n\t\tret = _SUCCESS;\n\t}\n\nexit:\n\n\treturn ret;\n}\n\nstatic int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\tstruct cfg80211_mgmt_tx_params *params,\n\t\t\t\tu64 *cookie)\n{\n\tstruct net_device *ndev = wdev_to_ndev(wdev);\n\tstruct ieee80211_channel *chan = params->chan;\n\tconst u8 *buf = params->buf;\n\tsize_t len = params->len;\n\tint ret = 0;\n\tint tx_ret;\n\tu32 dump_limit = RTW_MAX_MGMT_TX_CNT;\n\tu32 dump_cnt = 0;\n\tbool ack = true;\n\tu8 tx_ch = (u8)ieee80211_frequency_to_channel(chan->center_freq);\n\tu8 category, action;\n\tint type = (-1);\n\tstruct adapter *padapter;\n\tstruct rtw_wdev_priv *pwdev_priv;\n\n\tif (!ndev) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tpadapter = rtw_netdev_priv(ndev);\n\tpwdev_priv = adapter_wdev_data(padapter);\n\n\t \n\t*cookie = (unsigned long)buf;\n\n\t \n\trtw_cfg80211_mgmt_tx_status(padapter, *cookie, buf, len, ack, GFP_KERNEL);\n\n\tif (rtw_action_frame_parse(buf, len, &category, &action) == false)\n\t\tgoto exit;\n\n\trtw_ps_deny(padapter, PS_DENY_MGNT_TX);\n\tif (rtw_pwr_wakeup(padapter) == _FAIL) {\n\t\tret = -EFAULT;\n\t\tgoto cancel_ps_deny;\n\t}\n\n\tdo {\n\t\tdump_cnt++;\n\t\ttx_ret = _cfg80211_rtw_mgmt_tx(padapter, tx_ch, buf, len);\n\t} while (dump_cnt < dump_limit && tx_ret != _SUCCESS);\n\n\tswitch (type) {\n\tcase P2P_GO_NEGO_CONF:\n\t\trtw_clear_scan_deny(padapter);\n\t\tbreak;\n\tcase P2P_INVIT_RESP:\n\t\tif (pwdev_priv->invit_info.flags & BIT(0) && pwdev_priv->invit_info.status == 0) {\n\t\t\trtw_set_scan_deny(padapter, 5000);\n\t\t\trtw_pwr_wakeup_ex(padapter, 5000);\n\t\t\trtw_clear_scan_deny(padapter);\n\t\t}\n\t\tbreak;\n\t}\n\ncancel_ps_deny:\n\trtw_ps_deny_cancel(padapter, PS_DENY_MGNT_TX);\nexit:\n\treturn ret;\n}\n\nstatic void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap, enum nl80211_band band)\n{\n#define MAX_BIT_RATE_40MHZ_MCS15\t300\t \n#define MAX_BIT_RATE_40MHZ_MCS7\t\t150\t \n\n\tht_cap->ht_supported = true;\n\n\tht_cap->cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t\t\t\tIEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20 |\n\t\t\t\t\tIEEE80211_HT_CAP_DSSSCCK40 | IEEE80211_HT_CAP_MAX_AMSDU;\n\n\t \n\tht_cap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\n\t \n\tht_cap->ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;\n\n\tht_cap->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\n\t \n\tht_cap->mcs.rx_mask[0] = 0xFF;\n\tht_cap->mcs.rx_mask[1] = 0x00;\n\tht_cap->mcs.rx_mask[4] = 0x01;\n\n\tht_cap->mcs.rx_highest = cpu_to_le16(MAX_BIT_RATE_40MHZ_MCS7);\n}\n\nvoid rtw_cfg80211_init_wiphy(struct adapter *padapter)\n{\n\tstruct ieee80211_supported_band *bands;\n\tstruct wireless_dev *pwdev = padapter->rtw_wdev;\n\tstruct wiphy *wiphy = pwdev->wiphy;\n\n\t{\n\t\tbands = wiphy->bands[NL80211_BAND_2GHZ];\n\t\tif (bands)\n\t\t\trtw_cfg80211_init_ht_capab(&bands->ht_cap, NL80211_BAND_2GHZ);\n\t}\n\n\t \n\tmemcpy(wiphy->perm_addr, padapter->eeprompriv.mac_addr, ETH_ALEN);\n}\n\nstatic void rtw_cfg80211_preinit_wiphy(struct adapter *padapter, struct wiphy *wiphy)\n{\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\n\twiphy->max_scan_ssids = RTW_SSID_SCAN_AMOUNT;\n\twiphy->max_scan_ie_len = RTW_SCAN_IE_LEN_MAX;\n\twiphy->max_num_pmkids = RTW_MAX_NUM_PMKIDS;\n\n\twiphy->max_remain_on_channel_duration = RTW_MAX_REMAIN_ON_CHANNEL_DURATION;\n\n\twiphy->interface_modes =\tBIT(NL80211_IFTYPE_STATION)\n\t\t\t\t\t\t\t\t| BIT(NL80211_IFTYPE_ADHOC)\n\t\t\t\t\t\t\t\t| BIT(NL80211_IFTYPE_AP)\n\t\t\t\t\t\t\t\t| BIT(NL80211_IFTYPE_MONITOR)\n\t\t\t\t\t\t\t\t;\n\n\twiphy->mgmt_stypes = rtw_cfg80211_default_mgmt_stypes;\n\n\twiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);\n\n\twiphy->cipher_suites = rtw_cipher_suites;\n\twiphy->n_cipher_suites = ARRAY_SIZE(rtw_cipher_suites);\n\n\t \n\twiphy->bands[NL80211_BAND_2GHZ] = rtw_spt_band_alloc(NL80211_BAND_2GHZ);\n\n\twiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\twiphy->flags |= WIPHY_FLAG_OFFCHAN_TX | WIPHY_FLAG_HAVE_AP_SME;\n\n#if defined(CONFIG_PM)\n\twiphy->max_sched_scan_reqs = 1;\n#endif\n\n#if defined(CONFIG_PM)\n\twiphy->wowlan = &wowlan_stub;\n#endif\n\n\tif (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)\n\t\twiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\telse\n\t\twiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n}\n\nstatic struct cfg80211_ops rtw_cfg80211_ops = {\n\t.change_virtual_intf = cfg80211_rtw_change_iface,\n\t.add_key = cfg80211_rtw_add_key,\n\t.get_key = cfg80211_rtw_get_key,\n\t.del_key = cfg80211_rtw_del_key,\n\t.set_default_key = cfg80211_rtw_set_default_key,\n\t.get_station = cfg80211_rtw_get_station,\n\t.scan = cfg80211_rtw_scan,\n\t.set_wiphy_params = cfg80211_rtw_set_wiphy_params,\n\t.connect = cfg80211_rtw_connect,\n\t.disconnect = cfg80211_rtw_disconnect,\n\t.join_ibss = cfg80211_rtw_join_ibss,\n\t.leave_ibss = cfg80211_rtw_leave_ibss,\n\t.set_tx_power = cfg80211_rtw_set_txpower,\n\t.get_tx_power = cfg80211_rtw_get_txpower,\n\t.set_power_mgmt = cfg80211_rtw_set_power_mgmt,\n\t.set_pmksa = cfg80211_rtw_set_pmksa,\n\t.del_pmksa = cfg80211_rtw_del_pmksa,\n\t.flush_pmksa = cfg80211_rtw_flush_pmksa,\n\t.get_channel = cfg80211_rtw_get_channel,\n\t.add_virtual_intf = cfg80211_rtw_add_virtual_intf,\n\t.del_virtual_intf = cfg80211_rtw_del_virtual_intf,\n\n\t.start_ap = cfg80211_rtw_start_ap,\n\t.change_beacon = cfg80211_rtw_change_beacon,\n\t.stop_ap = cfg80211_rtw_stop_ap,\n\n\t.add_station = cfg80211_rtw_add_station,\n\t.del_station = cfg80211_rtw_del_station,\n\t.change_station = cfg80211_rtw_change_station,\n\t.dump_station = cfg80211_rtw_dump_station,\n\t.change_bss = cfg80211_rtw_change_bss,\n\n\t.mgmt_tx = cfg80211_rtw_mgmt_tx,\n};\n\nint rtw_wdev_alloc(struct adapter *padapter, struct device *dev)\n{\n\tint ret = 0;\n\tstruct wiphy *wiphy;\n\tstruct wireless_dev *wdev;\n\tstruct rtw_wdev_priv *pwdev_priv;\n\tstruct net_device *pnetdev = padapter->pnetdev;\n\n\t \n\twiphy = wiphy_new(&rtw_cfg80211_ops, sizeof(struct adapter *));\n\tif (!wiphy) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tset_wiphy_dev(wiphy, dev);\n\t*((struct adapter **)wiphy_priv(wiphy)) = padapter;\n\trtw_cfg80211_preinit_wiphy(padapter, wiphy);\n\n\t \n\trtw_regd_init(wiphy, rtw_reg_notifier);\n\n\tret = wiphy_register(wiphy);\n\tif (ret < 0)\n\t\tgoto free_wiphy;\n\n\t \n\twdev = rtw_zmalloc(sizeof(struct wireless_dev));\n\tif (!wdev) {\n\t\tret = -ENOMEM;\n\t\tgoto unregister_wiphy;\n\t}\n\twdev->wiphy = wiphy;\n\twdev->netdev = pnetdev;\n\n\twdev->iftype = NL80211_IFTYPE_STATION;  \n\t\t\t\t\t    \n\t\t\t\t\t    \n\tpadapter->rtw_wdev = wdev;\n\tpnetdev->ieee80211_ptr = wdev;\n\n\t \n\tpwdev_priv = adapter_wdev_data(padapter);\n\tpwdev_priv->rtw_wdev = wdev;\n\tpwdev_priv->pmon_ndev = NULL;\n\tpwdev_priv->ifname_mon[0] = '\\0';\n\tpwdev_priv->padapter = padapter;\n\tpwdev_priv->scan_request = NULL;\n\tspin_lock_init(&pwdev_priv->scan_req_lock);\n\n\tpwdev_priv->p2p_enabled = false;\n\tpwdev_priv->provdisc_req_issued = false;\n\trtw_wdev_invit_info_init(&pwdev_priv->invit_info);\n\trtw_wdev_nego_info_init(&pwdev_priv->nego_info);\n\n\tpwdev_priv->bandroid_scan = false;\n\n\tif (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)\n\t\tpwdev_priv->power_mgmt = true;\n\telse\n\t\tpwdev_priv->power_mgmt = false;\n\n\treturn ret;\n\nunregister_wiphy:\n\twiphy_unregister(wiphy);\n free_wiphy:\n\twiphy_free(wiphy);\nexit:\n\treturn ret;\n}\n\nvoid rtw_wdev_free(struct wireless_dev *wdev)\n{\n\tif (!wdev)\n\t\treturn;\n\n\tkfree(wdev->wiphy->bands[NL80211_BAND_2GHZ]);\n\n\twiphy_free(wdev->wiphy);\n\n\tkfree(wdev);\n}\n\nvoid rtw_wdev_unregister(struct wireless_dev *wdev)\n{\n\tstruct net_device *ndev;\n\tstruct adapter *adapter;\n\tstruct rtw_wdev_priv *pwdev_priv;\n\n\tif (!wdev)\n\t\treturn;\n\tndev = wdev_to_ndev(wdev);\n\tif (!ndev)\n\t\treturn;\n\n\tadapter = rtw_netdev_priv(ndev);\n\tpwdev_priv = adapter_wdev_data(adapter);\n\n\trtw_cfg80211_indicate_scan_done(adapter, true);\n\n\tif (pwdev_priv->pmon_ndev)\n\t\tunregister_netdev(pwdev_priv->pmon_ndev);\n\n\twiphy_unregister(wdev->wiphy);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}