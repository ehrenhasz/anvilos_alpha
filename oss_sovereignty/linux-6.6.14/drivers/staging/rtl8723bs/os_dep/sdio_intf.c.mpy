{
  "module_name": "sdio_intf.c",
  "hash_id": "df5e2dd90228692166233745e5dc6ab28637b0192772fef301ae4d004aec1e35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/os_dep/sdio_intf.c",
  "human_readable_source": "\n \n#include <drv_types.h>\n#include <rtw_debug.h>\n#include <hal_btcoex.h>\n#include <linux/jiffies.h>\n\n#ifndef dev_to_sdio_func\n#define dev_to_sdio_func(d)     container_of(d, struct sdio_func, dev)\n#endif\n\nstatic const struct sdio_device_id sdio_ids[] = {\n\t{ SDIO_DEVICE(0x024c, 0x0523), },\n\t{ SDIO_DEVICE(0x024c, 0x0525), },\n\t{ SDIO_DEVICE(0x024c, 0x0623), },\n\t{ SDIO_DEVICE(0x024c, 0x0626), },\n\t{ SDIO_DEVICE(0x024c, 0x0627), },\n\t{ SDIO_DEVICE(0x024c, 0xb723), },\n\t{  \t\t\t\t},\n};\nMODULE_DEVICE_TABLE(sdio, sdio_ids);\n\nstatic int rtw_drv_init(struct sdio_func *func, const struct sdio_device_id *id);\nstatic void rtw_dev_remove(struct sdio_func *func);\nstatic int rtw_sdio_resume(struct device *dev);\nstatic int rtw_sdio_suspend(struct device *dev);\n\nstatic const struct dev_pm_ops rtw_sdio_pm_ops = {\n\t.suspend\t= rtw_sdio_suspend,\n\t.resume\t= rtw_sdio_resume,\n};\n\nstatic struct sdio_driver rtl8723bs_sdio_driver = {\n\t.probe = rtw_drv_init,\n\t.remove = rtw_dev_remove,\n\t.name = \"rtl8723bs\",\n\t.id_table = sdio_ids,\n\t.drv = {\n\t\t.pm = &rtw_sdio_pm_ops,\n\t}\n};\n\nstatic void sd_sync_int_hdl(struct sdio_func *func)\n{\n\tstruct dvobj_priv *psdpriv;\n\n\n\tpsdpriv = sdio_get_drvdata(func);\n\n\tif (!psdpriv->if1)\n\t\treturn;\n\n\trtw_sdio_set_irq_thd(psdpriv, current);\n\tsd_int_hdl(psdpriv->if1);\n\trtw_sdio_set_irq_thd(psdpriv, NULL);\n}\n\nstatic int sdio_alloc_irq(struct dvobj_priv *dvobj)\n{\n\tstruct sdio_data *psdio_data;\n\tstruct sdio_func *func;\n\tint err;\n\n\tpsdio_data = &dvobj->intf_data;\n\tfunc = psdio_data->func;\n\n\tsdio_claim_host(func);\n\n\terr = sdio_claim_irq(func, &sd_sync_int_hdl);\n\tif (err) {\n\t\tdvobj->drv_dbg.dbg_sdio_alloc_irq_error_cnt++;\n\t\tprintk(KERN_CRIT \"%s: sdio_claim_irq FAIL(%d)!\\n\", __func__, err);\n\t} else {\n\t\tdvobj->drv_dbg.dbg_sdio_alloc_irq_cnt++;\n\t\tdvobj->irq_alloc = 1;\n\t}\n\n\tsdio_release_host(func);\n\n\treturn err?_FAIL:_SUCCESS;\n}\n\nstatic void sdio_free_irq(struct dvobj_priv *dvobj)\n{\n\tstruct sdio_data *psdio_data;\n\tstruct sdio_func *func;\n\tint err;\n\n\tif (dvobj->irq_alloc) {\n\t\tpsdio_data = &dvobj->intf_data;\n\t\tfunc = psdio_data->func;\n\n\t\tif (func) {\n\t\t\tsdio_claim_host(func);\n\t\t\terr = sdio_release_irq(func);\n\t\t\tif (err) {\n\t\t\t\tdvobj->drv_dbg.dbg_sdio_free_irq_error_cnt++;\n\t\t\t\tnetdev_err(dvobj->if1->pnetdev,\n\t\t\t\t\t   \"%s: sdio_release_irq FAIL(%d)!\\n\",\n\t\t\t\t\t   __func__, err);\n\t\t\t} else\n\t\t\t\tdvobj->drv_dbg.dbg_sdio_free_irq_cnt++;\n\t\t\tsdio_release_host(func);\n\t\t}\n\t\tdvobj->irq_alloc = 0;\n\t}\n}\n\nstatic u32 sdio_init(struct dvobj_priv *dvobj)\n{\n\tstruct sdio_data *psdio_data;\n\tstruct sdio_func *func;\n\tint err;\n\n\tpsdio_data = &dvobj->intf_data;\n\tfunc = psdio_data->func;\n\n\t \n\tsdio_claim_host(func);\n\n\terr = sdio_enable_func(func);\n\tif (err) {\n\t\tdvobj->drv_dbg.dbg_sdio_init_error_cnt++;\n\t\tgoto release;\n\t}\n\n\terr = sdio_set_block_size(func, 512);\n\tif (err) {\n\t\tdvobj->drv_dbg.dbg_sdio_init_error_cnt++;\n\t\tgoto release;\n\t}\n\tpsdio_data->block_transfer_len = 512;\n\tpsdio_data->tx_block_mode = 1;\n\tpsdio_data->rx_block_mode = 1;\n\nrelease:\n\tsdio_release_host(func);\n\n\tif (err)\n\t\treturn _FAIL;\n\treturn _SUCCESS;\n}\n\nstatic void sdio_deinit(struct dvobj_priv *dvobj)\n{\n\tstruct sdio_func *func;\n\tint err;\n\n\tfunc = dvobj->intf_data.func;\n\n\tif (func) {\n\t\tsdio_claim_host(func);\n\t\terr = sdio_disable_func(func);\n\t\tif (err)\n\t\t\tdvobj->drv_dbg.dbg_sdio_deinit_error_cnt++;\n\n\t\tif (dvobj->irq_alloc) {\n\t\t\terr = sdio_release_irq(func);\n\t\t\tif (err)\n\t\t\t\tdvobj->drv_dbg.dbg_sdio_free_irq_error_cnt++;\n\t\t\telse\n\t\t\t\tdvobj->drv_dbg.dbg_sdio_free_irq_cnt++;\n\t\t}\n\n\t\tsdio_release_host(func);\n\t}\n}\nstatic struct dvobj_priv *sdio_dvobj_init(struct sdio_func *func)\n{\n\tint status = _FAIL;\n\tstruct dvobj_priv *dvobj = NULL;\n\tstruct sdio_data *psdio;\n\n\tdvobj = devobj_init();\n\tif (!dvobj)\n\t\tgoto exit;\n\n\tsdio_set_drvdata(func, dvobj);\n\n\tpsdio = &dvobj->intf_data;\n\tpsdio->func = func;\n\n\tif (sdio_init(dvobj) != _SUCCESS)\n\t\tgoto free_dvobj;\n\n\trtw_reset_continual_io_error(dvobj);\n\tstatus = _SUCCESS;\n\nfree_dvobj:\n\tif (status != _SUCCESS && dvobj) {\n\t\tsdio_set_drvdata(func, NULL);\n\n\t\tdevobj_deinit(dvobj);\n\n\t\tdvobj = NULL;\n\t}\nexit:\n\treturn dvobj;\n}\n\nstatic void sdio_dvobj_deinit(struct sdio_func *func)\n{\n\tstruct dvobj_priv *dvobj = sdio_get_drvdata(func);\n\n\tsdio_set_drvdata(func, NULL);\n\tif (dvobj) {\n\t\tsdio_deinit(dvobj);\n\t\tdevobj_deinit(dvobj);\n\t}\n}\n\nvoid rtw_set_hal_ops(struct adapter *padapter)\n{\n\t \n\trtw_hal_data_init(padapter);\n\n\trtl8723bs_set_hal_ops(padapter);\n}\n\nstatic void sd_intf_start(struct adapter *padapter)\n{\n\tif (!padapter)\n\t\treturn;\n\n\t \n\trtw_hal_enable_interrupt(padapter);\n}\n\nstatic void sd_intf_stop(struct adapter *padapter)\n{\n\tif (!padapter)\n\t\treturn;\n\n\t \n\trtw_hal_disable_interrupt(padapter);\n}\n\n\nstatic struct adapter *rtw_sdio_if1_init(struct dvobj_priv *dvobj, const struct sdio_device_id  *pdid)\n{\n\tint status = _FAIL;\n\tstruct net_device *pnetdev;\n\tstruct adapter *padapter = NULL;\n\tstruct sdio_data *psdio = &dvobj->intf_data;\n\n\tpadapter = vzalloc(sizeof(*padapter));\n\tif (!padapter)\n\t\tgoto exit;\n\n\tpadapter->dvobj = dvobj;\n\tdvobj->if1 = padapter;\n\n\tpadapter->bDriverStopped = true;\n\n\tdvobj->padapters = padapter;\n\tpadapter->iface_id = 0;\n\n\t \n\tpnetdev = rtw_init_netdev(padapter);\n\tif (!pnetdev)\n\t\tgoto free_adapter;\n\n\tSET_NETDEV_DEV(pnetdev, dvobj_to_dev(dvobj));\n\n\tpadapter = rtw_netdev_priv(pnetdev);\n\n\t \n\n\t \n\trtw_set_hal_ops(padapter);\n\n\n\t \n\tpadapter->intf_start = &sd_intf_start;\n\tpadapter->intf_stop = &sd_intf_stop;\n\n\tpadapter->intf_init = &sdio_init;\n\tpadapter->intf_deinit = &sdio_deinit;\n\tpadapter->intf_alloc_irq = &sdio_alloc_irq;\n\tpadapter->intf_free_irq = &sdio_free_irq;\n\n\tif (rtw_init_io_priv(padapter, sdio_set_intf_ops) == _FAIL)\n\t\tgoto free_hal_data;\n\n\trtw_hal_read_chip_version(padapter);\n\n\trtw_hal_chip_configure(padapter);\n\n\thal_btcoex_Initialize((void *) padapter);\n\n\t \n\trtw_hal_read_chip_info(padapter);\n\n\t \n\tif (rtw_init_drv_sw(padapter) == _FAIL)\n\t\tgoto free_hal_data;\n\n\trtw_wdev_alloc(padapter, dvobj_to_dev(dvobj));\n\n\t \n\t \n\trtw_macaddr_cfg(&psdio->func->dev, padapter->eeprompriv.mac_addr);\n\n\trtw_hal_disable_interrupt(padapter);\n\n\tstatus = _SUCCESS;\n\nfree_hal_data:\n\tif (status != _SUCCESS && padapter->HalData)\n\t\tkfree(padapter->HalData);\n\n\tif (status != _SUCCESS) {\n\t\trtw_wdev_unregister(padapter->rtw_wdev);\n\t\trtw_wdev_free(padapter->rtw_wdev);\n\t}\n\nfree_adapter:\n\tif (status != _SUCCESS) {\n\t\tif (pnetdev)\n\t\t\trtw_free_netdev(pnetdev);\n\t\telse\n\t\t\tvfree((u8 *)padapter);\n\t\tpadapter = NULL;\n\t}\nexit:\n\treturn padapter;\n}\n\nstatic void rtw_sdio_if1_deinit(struct adapter *if1)\n{\n\tstruct net_device *pnetdev = if1->pnetdev;\n\tstruct mlme_priv *pmlmepriv = &if1->mlmepriv;\n\n\tif (check_fwstate(pmlmepriv, _FW_LINKED))\n\t\trtw_disassoc_cmd(if1, 0, false);\n\n\tfree_mlme_ap_info(if1);\n\n\trtw_cancel_all_timer(if1);\n\n\trtw_dev_unload(if1);\n\n\tif (if1->rtw_wdev)\n\t\trtw_wdev_free(if1->rtw_wdev);\n\n\trtw_free_drv_sw(if1);\n\n\tif (pnetdev)\n\t\trtw_free_netdev(pnetdev);\n}\n\n \nstatic int rtw_drv_init(\n\tstruct sdio_func *func,\n\tconst struct sdio_device_id *id)\n{\n\tint status = _FAIL;\n\tstruct adapter *if1 = NULL;\n\tstruct dvobj_priv *dvobj;\n\n\tdvobj = sdio_dvobj_init(func);\n\tif (!dvobj)\n\t\tgoto exit;\n\n\tif1 = rtw_sdio_if1_init(dvobj, id);\n\tif (!if1)\n\t\tgoto free_dvobj;\n\n\t \n\tstatus = rtw_drv_register_netdev(if1);\n\tif (status != _SUCCESS)\n\t\tgoto free_if1;\n\n\tif (sdio_alloc_irq(dvobj) != _SUCCESS)\n\t\tgoto free_if1;\n\n\trtw_ndev_notifier_register();\n\tstatus = _SUCCESS;\n\nfree_if1:\n\tif (status != _SUCCESS && if1)\n\t\trtw_sdio_if1_deinit(if1);\n\nfree_dvobj:\n\tif (status != _SUCCESS)\n\t\tsdio_dvobj_deinit(func);\nexit:\n\treturn status == _SUCCESS ? 0 : -ENODEV;\n}\n\nstatic void rtw_dev_remove(struct sdio_func *func)\n{\n\tstruct dvobj_priv *dvobj = sdio_get_drvdata(func);\n\tstruct adapter *padapter = dvobj->if1;\n\n\tdvobj->processing_dev_remove = true;\n\n\trtw_unregister_netdevs(dvobj);\n\n\tif (!padapter->bSurpriseRemoved) {\n\t\tint err;\n\n\t\t \n\t\tsdio_claim_host(func);\n\t\tsdio_readb(func, 0, &err);\n\t\tsdio_release_host(func);\n\t\tif (err == -ENOMEDIUM)\n\t\t\tpadapter->bSurpriseRemoved = true;\n\t}\n\n\trtw_ps_deny(padapter, PS_DENY_DRV_REMOVE);\n\n\trtw_pm_set_ips(padapter, IPS_NONE);\n\trtw_pm_set_lps(padapter, PS_MODE_ACTIVE);\n\n\tLeaveAllPowerSaveMode(padapter);\n\n\trtw_btcoex_HaltNotify(padapter);\n\n\trtw_sdio_if1_deinit(padapter);\n\n\tsdio_dvobj_deinit(func);\n}\n\nstatic int rtw_sdio_suspend(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct dvobj_priv *psdpriv = sdio_get_drvdata(func);\n\tstruct pwrctrl_priv *pwrpriv = dvobj_to_pwrctl(psdpriv);\n\tstruct adapter *padapter = psdpriv->if1;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\n\tif (padapter->bDriverStopped)\n\t\treturn 0;\n\n\tif (pwrpriv->bInSuspend) {\n\t\tpdbgpriv->dbg_suspend_error_cnt++;\n\t\treturn 0;\n\t}\n\n\trtw_suspend_common(padapter);\n\n\treturn 0;\n}\n\nstatic int rtw_resume_process(struct adapter *padapter)\n{\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\tstruct dvobj_priv *psdpriv = padapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\n\tif (!pwrpriv->bInSuspend) {\n\t\tpdbgpriv->dbg_resume_error_cnt++;\n\t\treturn -1;\n\t}\n\n\treturn rtw_resume_common(padapter);\n}\n\nstatic int rtw_sdio_resume(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct dvobj_priv *psdpriv = sdio_get_drvdata(func);\n\tstruct adapter *padapter = psdpriv->if1;\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tint ret = 0;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\n\tpdbgpriv->dbg_resume_cnt++;\n\n\tret = rtw_resume_process(padapter);\n\n\tpmlmeext->last_scan_time = jiffies;\n\treturn ret;\n}\n\nstatic int __init rtw_drv_entry(void)\n{\n\tint ret;\n\n\tret = sdio_register_driver(&rtl8723bs_sdio_driver);\n\tif (ret != 0)\n\t\trtw_ndev_notifier_unregister();\n\n\treturn ret;\n}\n\nstatic void __exit rtw_drv_halt(void)\n{\n\tsdio_unregister_driver(&rtl8723bs_sdio_driver);\n\n\trtw_ndev_notifier_unregister();\n}\n\n\nmodule_init(rtw_drv_entry);\nmodule_exit(rtw_drv_halt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}