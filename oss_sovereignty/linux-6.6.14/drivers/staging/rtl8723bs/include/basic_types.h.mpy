{
  "module_name": "basic_types.h",
  "hash_id": "3b15f0b9087c6383fb036745decee5e84f675eba698f63d10e060ae15795b135",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/include/basic_types.h",
  "human_readable_source": " \n \n#ifndef __BASIC_TYPES_H__\n#define __BASIC_TYPES_H__\n\n\n#define SUCCESS\t0\n#define FAIL\t(-1)\n\n#include <linux/types.h>\n\n#define FIELD_OFFSET(s, field)\t((__kernel_ssize_t)&((s *)(0))->field)\n\n#define SIZE_PTR __kernel_size_t\n#define SSIZE_PTR __kernel_ssize_t\n\n \n \n\n \n\n \n \n \n#define EF1Byte\t(u8)\n#define EF2Byte\t\tle16_to_cpu\n#define EF4Byte\tle32_to_cpu\n\n \n#define EF1BYTE(_val)\t\t\\\n\t((u8)(_val))\n#define EF2BYTE(_val)\t\t\\\n\t(le16_to_cpu(_val))\n#define EF4BYTE(_val)\t\t\\\n\t(le32_to_cpu(_val))\n\n \n#define READEF1BYTE(_ptr)\t\\\n\tEF1BYTE(*((u8 *)(_ptr)))\n \n#define READEF2BYTE(_ptr)\t\\\n\tEF2BYTE(*(_ptr))\n#define READEF4BYTE(_ptr)\t\\\n\tEF4BYTE(*(_ptr))\n\n \n#define WRITEEF1BYTE(_ptr, _val)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\t(*((u8 *)(_ptr))) = EF1BYTE(_val);\t\\\n\t} while (0)\n \n#define WRITEEF2BYTE(_ptr, _val)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\t(*((u16 *)(_ptr))) = EF2BYTE(_val);\t\\\n\t} while (0)\n\n#define WRITEEF4BYTE(_ptr, _val)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\t(*((u32 *)(_ptr))) = EF2BYTE(_val);\t\\\n\t} while (0)\n\n \n#define BIT_LEN_MASK_32(__bitlen)\t \\\n\t(0xFFFFFFFF >> (32 - (__bitlen)))\n#define BIT_LEN_MASK_16(__bitlen)\t \\\n\t(0xFFFF >> (16 - (__bitlen)))\n#define BIT_LEN_MASK_8(__bitlen) \\\n\t(0xFF >> (8 - (__bitlen)))\n\n \n#define BIT_OFFSET_LEN_MASK_32(__bitoffset, __bitlen) \\\n\t(BIT_LEN_MASK_32(__bitlen) << (__bitoffset))\n#define BIT_OFFSET_LEN_MASK_16(__bitoffset, __bitlen) \\\n\t(BIT_LEN_MASK_16(__bitlen) << (__bitoffset))\n#define BIT_OFFSET_LEN_MASK_8(__bitoffset, __bitlen) \\\n\t(BIT_LEN_MASK_8(__bitlen) << (__bitoffset))\n\n \n#define LE_P4BYTE_TO_HOST_4BYTE(__pstart) \\\n\t(EF4BYTE(*((__le32 *)(__pstart))))\n#define LE_P2BYTE_TO_HOST_2BYTE(__pstart) \\\n\t(EF2BYTE(*((__le16 *)(__pstart))))\n#define LE_P1BYTE_TO_HOST_1BYTE(__pstart) \\\n\t(EF1BYTE(*((u8 *)(__pstart))))\n\n \n \n \n \n \n#define LE_BITS_TO_4BYTE(__pstart, __bitoffset, __bitlen) \\\n\t(\\\n\t\t(LE_P4BYTE_TO_HOST_4BYTE(__pstart) >> (__bitoffset))  & \\\n\t\tBIT_LEN_MASK_32(__bitlen) \\\n\t)\n#define LE_BITS_TO_2BYTE(__pstart, __bitoffset, __bitlen) \\\n\t(\\\n\t\t(LE_P2BYTE_TO_HOST_2BYTE(__pstart) >> (__bitoffset)) & \\\n\t\tBIT_LEN_MASK_16(__bitlen) \\\n\t)\n#define LE_BITS_TO_1BYTE(__pstart, __bitoffset, __bitlen) \\\n\t(\\\n\t\t(LE_P1BYTE_TO_HOST_1BYTE(__pstart) >> (__bitoffset)) & \\\n\t\tBIT_LEN_MASK_8(__bitlen) \\\n\t)\n\n \n \n \n \n \n#define LE_BITS_CLEARED_TO_4BYTE(__pstart, __bitoffset, __bitlen) \\\n\t(\\\n\t\tLE_P4BYTE_TO_HOST_4BYTE(__pstart)  & \\\n\t\t(~BIT_OFFSET_LEN_MASK_32(__bitoffset, __bitlen)) \\\n\t)\n#define LE_BITS_CLEARED_TO_2BYTE(__pstart, __bitoffset, __bitlen) \\\n\t(\\\n\t\tLE_P2BYTE_TO_HOST_2BYTE(__pstart) & \\\n\t\t(~BIT_OFFSET_LEN_MASK_16(__bitoffset, __bitlen)) \\\n\t)\n#define LE_BITS_CLEARED_TO_1BYTE(__pstart, __bitoffset, __bitlen) \\\n\t(\\\n\t\tLE_P1BYTE_TO_HOST_1BYTE(__pstart) & \\\n\t\t(~BIT_OFFSET_LEN_MASK_8(__bitoffset, __bitlen)) \\\n\t)\n\n \n \n \n \n#define SET_BITS_TO_LE_4BYTE(__pstart, __bitoffset, __bitlen, __val) \\\n\t\t*((u32 *)(__pstart)) =\t\t\t\t\\\n\t\t(\t\t\t\t\t\t\\\n\t\tLE_BITS_CLEARED_TO_4BYTE(__pstart, __bitoffset, __bitlen) | \\\n\t\t((((u32)__val) & BIT_LEN_MASK_32(__bitlen)) << (__bitoffset)) \\\n\t\t)\n\n#define SET_BITS_TO_LE_2BYTE(__pstart, __bitoffset, __bitlen, __val) \\\n\t\t*((u16 *)(__pstart)) =\t\t\t\t\\\n\t\t(\t\t\t\t\t\\\n\t\tLE_BITS_CLEARED_TO_2BYTE(__pstart, __bitoffset, __bitlen) | \\\n\t\t((((u16)__val) & BIT_LEN_MASK_16(__bitlen)) << (__bitoffset)) \\\n\t\t);\n\n#define SET_BITS_TO_LE_1BYTE(__pstart, __bitoffset, __bitlen, __val) \\\n\t\t*((u8 *)(__pstart)) = EF1BYTE\t\t\t\\\n\t\t(\t\t\t\t\t\\\n\t\tLE_BITS_CLEARED_TO_1BYTE(__pstart, __bitoffset, __bitlen) | \\\n\t\t((((u8)__val) & BIT_LEN_MASK_8(__bitlen)) << (__bitoffset)) \\\n\t\t)\n\n#define LE_BITS_CLEARED_TO_1BYTE_8BIT(__pStart, __BitOffset, __BitLen) \\\n\t(\\\n\t\tLE_P1BYTE_TO_HOST_1BYTE(__pStart) \\\n\t)\n\n#define SET_BITS_TO_LE_1BYTE_8BIT(__pStart, __BitOffset, __BitLen, __Value) \\\n{ \\\n\t*((u8 *)(__pStart)) = \\\n\t\tEF1Byte(\\\n\t\t\tLE_BITS_CLEARED_TO_1BYTE_8BIT(__pStart, __BitOffset, __BitLen) \\\n\t\t\t| \\\n\t\t\t((u8)__Value) \\\n\t\t); \\\n}\n\n \n#define N_BYTE_ALIGMENT(__Value, __Aligment) ((__Aligment == 1) ? (__Value) : (((__Value + __Aligment - 1) / __Aligment) * __Aligment))\n\n#define TEST_FLAG(__Flag, __testFlag)\t\t(((__Flag) & (__testFlag)) != 0)\n#define SET_FLAG(__Flag, __setFlag)\t\t\t((__Flag) |= __setFlag)\n#define CLEAR_FLAG(__Flag, __clearFlag)\t\t((__Flag) &= ~(__clearFlag))\n#define CLEAR_FLAGS(__Flag)\t\t\t\t\t((__Flag) = 0)\n#define TEST_FLAGS(__Flag, __testFlags)\t\t(((__Flag) & (__testFlags)) == (__testFlags))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}