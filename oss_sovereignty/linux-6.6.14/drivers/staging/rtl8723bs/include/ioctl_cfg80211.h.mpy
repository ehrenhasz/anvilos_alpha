{
  "module_name": "ioctl_cfg80211.h",
  "hash_id": "5b4f5edd21989f3b1fcbe9f8733ebd90a7e21a6fe79cd9b8a8a2c339491182e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/include/ioctl_cfg80211.h",
  "human_readable_source": " \n \n#ifndef __IOCTL_CFG80211_H__\n#define __IOCTL_CFG80211_H__\n\nstruct rtw_wdev_invit_info {\n\tu8 state;  \n\tu8 peer_mac[ETH_ALEN];\n\tu8 active;\n\tu8 token;\n\tu8 flags;\n\tu8 status;\n\tu8 req_op_ch;\n\tu8 rsp_op_ch;\n};\n\n#define rtw_wdev_invit_info_init(invit_info) \\\n\tdo { \\\n\t\t(invit_info)->state = 0xff; \\\n\t\tmemset((invit_info)->peer_mac, 0, ETH_ALEN); \\\n\t\t(invit_info)->active = 0xff; \\\n\t\t(invit_info)->token = 0; \\\n\t\t(invit_info)->flags = 0x00; \\\n\t\t(invit_info)->status = 0xff; \\\n\t\t(invit_info)->req_op_ch = 0; \\\n\t\t(invit_info)->rsp_op_ch = 0; \\\n\t} while (0)\n\nstruct rtw_wdev_nego_info {\n\tu8 state;  \n\tu8 peer_mac[ETH_ALEN];\n\tu8 active;\n\tu8 token;\n\tu8 status;\n\tu8 req_intent;\n\tu8 req_op_ch;\n\tu8 req_listen_ch;\n\tu8 rsp_intent;\n\tu8 rsp_op_ch;\n\tu8 conf_op_ch;\n};\n\n#define rtw_wdev_nego_info_init(nego_info) \\\n\tdo { \\\n\t\t(nego_info)->state = 0xff; \\\n\t\tmemset((nego_info)->peer_mac, 0, ETH_ALEN); \\\n\t\t(nego_info)->active = 0xff; \\\n\t\t(nego_info)->token = 0; \\\n\t\t(nego_info)->status = 0xff; \\\n\t\t(nego_info)->req_intent = 0xff; \\\n\t\t(nego_info)->req_op_ch = 0; \\\n\t\t(nego_info)->req_listen_ch = 0; \\\n\t\t(nego_info)->rsp_intent = 0xff; \\\n\t\t(nego_info)->rsp_op_ch = 0; \\\n\t\t(nego_info)->conf_op_ch = 0; \\\n\t} while (0)\n\nstruct rtw_wdev_priv {\n\tstruct wireless_dev *rtw_wdev;\n\n\tstruct adapter *padapter;\n\n\tstruct cfg80211_scan_request *scan_request;\n\tspinlock_t scan_req_lock;\n\n\tstruct net_device *pmon_ndev; \n\tchar ifname_mon[IFNAMSIZ + 1];  \n\n\tu8 p2p_enabled;\n\n\tu8 provdisc_req_issued;\n\n\tstruct rtw_wdev_invit_info invit_info;\n\tstruct rtw_wdev_nego_info nego_info;\n\n\tu8 bandroid_scan;\n\tbool block;\n\tbool power_mgmt;\n};\n\n#define wiphy_to_adapter(x) (*((struct adapter **)wiphy_priv(x)))\n\n#define wdev_to_ndev(w) ((w)->netdev)\n\nint rtw_wdev_alloc(struct adapter *padapter, struct device *dev);\nvoid rtw_wdev_free(struct wireless_dev *wdev);\nvoid rtw_wdev_unregister(struct wireless_dev *wdev);\n\nvoid rtw_cfg80211_init_wiphy(struct adapter *padapter);\n\nvoid rtw_cfg80211_unlink_bss(struct adapter *padapter, struct wlan_network *pnetwork);\nvoid rtw_cfg80211_surveydone_event_callback(struct adapter *padapter);\nstruct cfg80211_bss *rtw_cfg80211_inform_bss(struct adapter *padapter, struct wlan_network *pnetwork);\nint rtw_cfg80211_check_bss(struct adapter *padapter);\nvoid rtw_cfg80211_ibss_indicate_connect(struct adapter *padapter);\nvoid rtw_cfg80211_indicate_connect(struct adapter *padapter);\nvoid rtw_cfg80211_indicate_disconnect(struct adapter *padapter);\nvoid rtw_cfg80211_indicate_scan_done(struct adapter *adapter, bool aborted);\n\nvoid rtw_cfg80211_indicate_sta_assoc(struct adapter *padapter, u8 *pmgmt_frame, uint frame_len);\nvoid rtw_cfg80211_indicate_sta_disassoc(struct adapter *padapter, unsigned char *da, unsigned short reason);\n\nvoid rtw_cfg80211_rx_action(struct adapter *adapter, u8 *frame, uint frame_len, const char *msg);\n\nbool rtw_cfg80211_pwr_mgmt(struct adapter *adapter);\n\n#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, 0)\n#define rtw_cfg80211_send_rx_assoc(adapter, bss, buf, len) cfg80211_send_rx_assoc((adapter)->pnetdev, bss, buf, len)\n#define rtw_cfg80211_mgmt_tx_status(adapter, cookie, buf, len, ack, gfp) cfg80211_mgmt_tx_status((adapter)->rtw_wdev, cookie, buf, len, ack, gfp)\n#define rtw_cfg80211_ready_on_channel(adapter, cookie, chan, channel_type, duration, gfp)  cfg80211_ready_on_channel((adapter)->rtw_wdev, cookie, chan, duration, gfp)\n#define rtw_cfg80211_remain_on_channel_expired(adapter, cookie, chan, chan_type, gfp) cfg80211_remain_on_channel_expired((adapter)->rtw_wdev, cookie, chan, gfp)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}