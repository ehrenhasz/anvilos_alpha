{
  "module_name": "osdep_service_linux.h",
  "hash_id": "348f612f9a8bc0c5498cfad258d106bc99c67411f0574b9934898cbdb0918b31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/include/osdep_service_linux.h",
  "human_readable_source": " \n \n#ifndef __OSDEP_LINUX_SERVICE_H_\n#define __OSDEP_LINUX_SERVICE_H_\n\n\t#include <linux/spinlock.h>\n\t#include <linux/compiler.h>\n\t#include <linux/kernel.h>\n\t#include <linux/errno.h>\n\t#include <linux/init.h>\n\t#include <linux/slab.h>\n\t#include <linux/module.h>\n\t#include <linux/kref.h>\n\t \n\t#include <linux/netdevice.h>\n\t#include <linux/skbuff.h>\n\t#include <linux/uaccess.h>\n\t#include <asm/byteorder.h>\n\t#include <linux/atomic.h>\n\t#include <linux/io.h>\n\t#include <linux/sem.h>\n\t#include <linux/sched.h>\n\t#include <linux/etherdevice.h>\n\t#include <linux/wireless.h>\n\t#include <net/iw_handler.h>\n\t#include <linux/if_arp.h>\n\t#include <linux/rtnetlink.h>\n\t#include <linux/delay.h>\n\t#include <linux/interrupt.h>\t \n\t#include <linux/ip.h>\n\t#include <linux/kthread.h>\n\t#include <linux/list.h>\n\t#include <linux/vmalloc.h>\n\n \n        #include <net/ieee80211_radiotap.h>\n\t#include <net/cfg80211.h>\n\n\tstruct\t__queue\t{\n\t\tstruct\tlist_head\tqueue;\n\t\tspinlock_t\tlock;\n\t};\n\nstatic inline struct list_head *get_next(struct list_head\t*list)\n{\n\treturn list->next;\n}\n\nstatic inline struct list_head\t*get_list_head(struct __queue\t*queue)\n{\n\treturn (&(queue->queue));\n}\n\nstatic inline void _set_timer(struct timer_list *ptimer, u32 delay_time)\n{\n\tmod_timer(ptimer, (jiffies + (delay_time * HZ / 1000)));\n}\n\nstatic inline void _init_workitem(struct work_struct *pwork, void *pfunc, void *cntx)\n{\n\tINIT_WORK(pwork, pfunc);\n}\n\nstatic inline void _set_workitem(struct work_struct *pwork)\n{\n\tschedule_work(pwork);\n}\n\nstatic inline void _cancel_workitem_sync(struct work_struct *pwork)\n{\n\tcancel_work_sync(pwork);\n}\n\nstatic inline int rtw_netif_queue_stopped(struct net_device *pnetdev)\n{\n\treturn (netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 0)) &&\n\t\tnetif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 1)) &&\n\t\tnetif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 2)) &&\n\t\tnetif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 3)));\n}\n\nstatic inline void rtw_netif_wake_queue(struct net_device *pnetdev)\n{\n\tnetif_tx_wake_all_queues(pnetdev);\n}\n\nstatic inline void rtw_netif_start_queue(struct net_device *pnetdev)\n{\n\tnetif_tx_start_all_queues(pnetdev);\n}\n\nstatic inline void rtw_netif_stop_queue(struct net_device *pnetdev)\n{\n\tnetif_tx_stop_all_queues(pnetdev);\n}\n\n#define rtw_signal_process(pid, sig) kill_pid(find_vpid((pid)), (sig), 1)\n\n#define NDEV_ARG(ndev) ndev->name\n#define ADPT_ARG(adapter) adapter->pnetdev->name\n#define FUNC_NDEV_FMT \"%s(%s)\"\n#define FUNC_NDEV_ARG(ndev) __func__, ndev->name\n#define FUNC_ADPT_FMT \"%s(%s)\"\n#define FUNC_ADPT_ARG(adapter) __func__, adapter->pnetdev->name\n\nstruct rtw_netdev_priv_indicator {\n\tvoid *priv;\n\tu32 sizeof_priv;\n};\n\nstatic inline struct adapter *rtw_netdev_priv(struct net_device *netdev)\n{\n\treturn ((struct rtw_netdev_priv_indicator *)netdev_priv(netdev))->priv;\n}\n\nstruct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_priv);\nextern struct net_device *rtw_alloc_etherdev(int sizeof_priv);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}