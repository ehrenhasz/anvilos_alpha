{
  "module_name": "rtw_pwrctrl.h",
  "hash_id": "954ec286114b7ebdd6386d427d2e55f40be5147bb72db9cf06fbba2a0f3f6b19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/include/rtw_pwrctrl.h",
  "human_readable_source": " \n \n#ifndef __RTW_PWRCTRL_H_\n#define __RTW_PWRCTRL_H_\n\n#include <linux/mutex.h>\n\n#define FW_PWR0\t0\n#define FW_PWR1\t\t1\n#define FW_PWR2\t\t2\n#define FW_PWR3\t\t3\n\n\n#define HW_PWR0\t7\n#define HW_PWR1\t\t6\n#define HW_PWR2\t\t2\n#define HW_PWR3\t0\n#define HW_PWR4\t8\n\n#define FW_PWRMSK\t0x7\n\n\n#define XMIT_ALIVE\tBIT(0)\n#define RECV_ALIVE\tBIT(1)\n#define CMD_ALIVE\tBIT(2)\n#define EVT_ALIVE\tBIT(3)\n#define BTCOEX_ALIVE\tBIT(4)\n\n\nenum {\n\tPS_MODE_ACTIVE\t= 0,\n\tPS_MODE_MIN,\n\tPS_MODE_MAX,\n\tPS_MODE_DTIM,\t \n\tPS_MODE_VOIP,\n\tPS_MODE_UAPSD_WMM,\n\tPS_MODE_UAPSD,\n\tPS_MODE_IBSS,\n\tPS_MODE_WWLAN,\n\tPM_Radio_Off,\n\tPM_Card_Disable,\n\tPS_MODE_NUM,\n};\n\n \n\n#define PS_DPS\t\t\t\tBIT(0)\n#define PS_LCLK\t\t\t\t(PS_DPS)\n#define PS_RF_OFF\t\t\tBIT(1)\n#define PS_ALL_ON\t\t\tBIT(2)\n#define PS_ST_ACTIVE\t\tBIT(3)\n\n#define PS_ISR_ENABLE\t\tBIT(4)\n#define PS_IMR_ENABLE\t\tBIT(5)\n#define PS_ACK\t\t\t\tBIT(6)\n#define PS_TOGGLE\t\t\tBIT(7)\n\n#define PS_STATE_MASK\t\t(0x0F)\n#define PS_STATE_HW_MASK\t(0x07)\n#define PS_SEQ_MASK\t\t\t(0xc0)\n\n#define PS_STATE(x)\t\t(PS_STATE_MASK & (x))\n#define PS_STATE_HW(x)\t(PS_STATE_HW_MASK & (x))\n#define PS_SEQ(x)\t\t(PS_SEQ_MASK & (x))\n\n#define PS_STATE_S0\t\t(PS_DPS)\n#define PS_STATE_S1\t\t(PS_LCLK)\n#define PS_STATE_S2\t\t(PS_RF_OFF)\n#define PS_STATE_S3\t\t(PS_ALL_ON)\n#define PS_STATE_S4\t\t((PS_ST_ACTIVE) | (PS_ALL_ON))\n\n\n#define PS_IS_RF_ON(x)\t((x) & (PS_ALL_ON))\n#define PS_IS_ACTIVE(x)\t((x) & (PS_ST_ACTIVE))\n#define CLR_PS_STATE(x)\t((x) = ((x) & (0xF0)))\n\n\nstruct reportpwrstate_parm {\n\tunsigned char mode;\n\tunsigned char state;  \n\tunsigned short rsvd;\n};\n\n#define LPS_DELAY_TIME\t(1 * HZ)  \n\n#define EXE_PWR_NONE\t0x01\n#define EXE_PWR_IPS\t\t0x02\n#define EXE_PWR_LPS\t\t0x04\n\n \nenum rt_rf_power_state {\n\trf_on,\t\t \n\trf_sleep,\t \n\trf_off,\t\t \n\t \n\trf_max\n};\n\n \n#define\tRT_RF_OFF_LEVL_ASPM\t\t\tBIT(0)\t \n#define\tRT_RF_OFF_LEVL_CLK_REQ\t\tBIT(1)\t \n#define\tRT_RF_OFF_LEVL_PCI_D3\t\t\tBIT(2)\t \n#define\tRT_RF_OFF_LEVL_HALT_NIC\t\tBIT(3)\t \n#define\tRT_RF_OFF_LEVL_FREE_FW\t\tBIT(4)\t \n#define\tRT_RF_OFF_LEVL_FW_32K\t\tBIT(5)\t \n#define\tRT_RF_PS_LEVEL_ALWAYS_ASPM\tBIT(6)\t \n#define\tRT_RF_LPS_DISALBE_2R\t\t\tBIT(30)\t \n#define\tRT_RF_LPS_LEVEL_ASPM\t\t\tBIT(31)\t \n\n#define\tRT_IN_PS_LEVEL(ppsc, _PS_FLAG)\t\t((ppsc->cur_ps_level & _PS_FLAG) ? true : false)\n#define\tRT_CLEAR_PS_LEVEL(ppsc, _PS_FLAG)\t(ppsc->cur_ps_level &= (~(_PS_FLAG)))\n#define\tRT_SET_PS_LEVEL(ppsc, _PS_FLAG)\t\t(ppsc->cur_ps_level |= _PS_FLAG)\n\n \n#define\tRT_PCI_ASPM_OSC_IGNORE\t\t0\t  \n#define\tRT_PCI_ASPM_OSC_ENABLE\t\tBIT0  \n#define\tRT_PCI_ASPM_OSC_DISABLE\t\tBIT1  \n\nenum {\n\tPSBBREG_RF0 = 0,\n\tPSBBREG_RF1,\n\tPSBBREG_RF2,\n\tPSBBREG_AFE0,\n\tPSBBREG_TOTALCNT\n};\n\nenum {  \n\tIPS_NONE = 0,\n\tIPS_NORMAL,\n\tIPS_LEVEL_2,\n\tIPS_NUM\n};\n\n \nenum ps_deny_reason {\n\tPS_DENY_DRV_INITIAL = 0,\n\tPS_DENY_SCAN,\n\tPS_DENY_JOIN,\n\tPS_DENY_DISCONNECT,\n\tPS_DENY_SUSPEND,\n\tPS_DENY_IOCTL,\n\tPS_DENY_MGNT_TX,\n\tPS_DENY_DRV_REMOVE = 30,\n\tPS_DENY_OTHERS = 31\n};\n\nstruct pwrctrl_priv {\n\tstruct mutex lock;\n\tvolatile u8 rpwm;  \n\tvolatile u8 cpwm;  \n\tvolatile u8 tog;  \n\tvolatile u8 cpwm_tog;  \n\n\tu8 pwr_mode;\n\tu8 smart_ps;\n\tu8 bcn_ant_mode;\n\tu8 dtim;\n\n\tu32 alives;\n\tstruct work_struct cpwm_event;\n\tu8 brpwmtimeout;\n\tstruct work_struct rpwmtimeoutwi;\n\tstruct timer_list pwr_rpwm_timer;\n\tu8 bpower_saving;  \n\n\tu8 b_hw_radio_off;\n\tu8 reg_rfoff;\n\tu8 reg_pdnmode;  \n\tu32 rfoff_reason;\n\n\t \n\tu32 cur_ps_level;\n\tu32 reg_rfps_level;\n\n\tuint\tips_enter_cnts;\n\tuint\tips_leave_cnts;\n\n\tu8 ips_mode;\n\tu8 ips_org_mode;\n\tu8 ips_mode_req;  \n\tbool bips_processing;\n\tunsigned long ips_deny_time;  \n\tu8 pre_ips_type; \n\n\t \n\t \n\t \n\t \n\tu32 ps_deny;\n\n\tu8 ps_processing;  \n\n\tu8 fw_psmode_iface_id;\n\tu8 bLeisurePs;\n\tu8 LpsIdleCount;\n\tu8 power_mgnt;\n\tu8 org_power_mgnt;\n\tbool fw_current_in_ps_mode;\n\tunsigned long\tDelayLPSLastTimeStamp;\n\ts32\t\tpnp_current_pwr_state;\n\tu8 pnp_bstop_trx;\n\n\n\tu8 bInternalAutoSuspend;\n\tu8 bInSuspend;\n\n\tu8 bAutoResume;\n\tu8 autopm_cnt;\n\n\tu8 bSupportRemoteWakeup;\n\tu8 wowlan_wake_reason;\n\tu8 wowlan_ap_mode;\n\tu8 wowlan_mode;\n\tstruct timer_list\tpwr_state_check_timer;\n\tstruct adapter *adapter;\n\tint\t\tpwr_state_check_interval;\n\tu8 pwr_state_check_cnts;\n\n\tint\t\tps_flag;  \n\n\tenum rt_rf_power_state\trf_pwrstate; \n\t \n\tenum rt_rf_power_state\tchange_rfpwrstate;\n\n\tu8 bHWPowerdown;  \n\tu8 bHWPwrPindetect;  \n\tu8 bkeepfwalive;\n\tu8 brfoffbyhw;\n\tunsigned long PS_BBRegBackup[PSBBREG_TOTALCNT];\n};\n\n#define rtw_ips_mode_req(pwrctl, ips_mode) \\\n\t((pwrctl)->ips_mode_req = (ips_mode))\n\n#define RTW_PWR_STATE_CHK_INTERVAL 2000\n\n#define _rtw_set_pwr_state_check_timer(pwrctl, ms) \\\n\tdo { \\\n\t\t_set_timer(&(pwrctl)->pwr_state_check_timer, (ms)); \\\n\t} while (0)\n\n#define rtw_set_pwr_state_check_timer(pwrctl) \\\n\t_rtw_set_pwr_state_check_timer((pwrctl), (pwrctl)->pwr_state_check_interval)\n\nextern void rtw_init_pwrctrl_priv(struct adapter *adapter);\nextern void rtw_free_pwrctrl_priv(struct adapter *adapter);\n\ns32 rtw_register_task_alive(struct adapter *, u32 task);\nvoid rtw_unregister_task_alive(struct adapter *, u32 task);\nextern s32 rtw_register_tx_alive(struct adapter *padapter);\nextern void rtw_unregister_tx_alive(struct adapter *padapter);\nextern s32 rtw_register_cmd_alive(struct adapter *padapter);\nextern void rtw_unregister_cmd_alive(struct adapter *padapter);\nextern void cpwm_int_hdl(struct adapter *padapter, struct reportpwrstate_parm *preportpwrstate);\nextern void LPS_Leave_check(struct adapter *padapter);\n\nextern void LeaveAllPowerSaveMode(struct adapter *Adapter);\nextern void LeaveAllPowerSaveModeDirect(struct adapter *Adapter);\nvoid _ips_enter(struct adapter *padapter);\nvoid ips_enter(struct adapter *padapter);\nint _ips_leave(struct adapter *padapter);\nint ips_leave(struct adapter *padapter);\n\nvoid rtw_ps_processor(struct adapter *padapter);\n\ns32 LPS_RF_ON_check(struct adapter *padapter, u32 delay_ms);\nvoid LPS_Enter(struct adapter *padapter, const char *msg);\nvoid LPS_Leave(struct adapter *padapter, const char *msg);\nvoid traffic_check_for_leave_lps(struct adapter *padapter, u8 tx, u32 tx_packets);\nvoid rtw_set_ps_mode(struct adapter *padapter, u8 ps_mode, u8 smart_ps, u8 bcn_ant_mode, const char *msg);\nvoid rtw_set_rpwm(struct adapter *padapter, u8 val8);\n\nvoid rtw_set_ips_deny(struct adapter *padapter, u32 ms);\nint _rtw_pwr_wakeup(struct adapter *padapter, u32 ips_deffer_ms, const char *caller);\n#define rtw_pwr_wakeup(adapter) _rtw_pwr_wakeup(adapter, RTW_PWR_STATE_CHK_INTERVAL, __func__)\n#define rtw_pwr_wakeup_ex(adapter, ips_deffer_ms) _rtw_pwr_wakeup(adapter, ips_deffer_ms, __func__)\nint rtw_pm_set_ips(struct adapter *padapter, u8 mode);\nint rtw_pm_set_lps(struct adapter *padapter, u8 mode);\n\nvoid rtw_ps_deny(struct adapter *padapter, enum ps_deny_reason reason);\nvoid rtw_ps_deny_cancel(struct adapter *padapter, enum ps_deny_reason reason);\nu32 rtw_ps_deny_get(struct adapter *padapter);\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}