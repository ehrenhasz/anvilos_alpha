{
  "module_name": "rtw_recv.h",
  "hash_id": "2c66e04a09e8cf0f6b5e66ed6b7a0be846434db65be9cb1a329d565f957d0f83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8723bs/include/rtw_recv.h",
  "human_readable_source": " \n \n#ifndef _RTW_RECV_H_\n#define _RTW_RECV_H_\n\n#define NR_RECVBUFF (8)\n\n#define NR_PREALLOC_RECV_SKB (8)\n\n#define NR_RECVFRAME 256\n\n#define RXFRAME_ALIGN\t8\n#define RXFRAME_ALIGN_SZ\t(1<<RXFRAME_ALIGN)\n\n#define DRVINFO_SZ\t4  \n\n#define MAX_RXFRAME_CNT\t512\n#define MAX_RX_NUMBLKS\t\t(32)\n#define RECVFRAME_HDR_ALIGN 128\n\n\n#define PHY_RSSI_SLID_WIN_MAX\t\t\t\t100\n#define PHY_LINKQUALITY_SLID_WIN_MAX\t\t20\n\n\n#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)\n\n#define RX_MPDU_QUEUE\t\t\t\t0\n#define RX_CMD_QUEUE\t\t\t\t1\n#define RX_MAX_QUEUE\t\t\t\t2\n\n#define MAX_SUBFRAME_COUNT\t64\n\n#define LLC_HEADER_LENGTH\t6\n\n \nstruct recv_reorder_ctrl {\n\tstruct adapter\t*padapter;\n\tu8 enable;\n\tu16 indicate_seq; \n\tu16 wend_b;\n\tu8 wsize_b;\n\tstruct __queue pending_recvframe_queue;\n\tstruct timer_list reordering_ctrl_timer;\n};\n\nstruct\tstainfo_rxcache\t{\n\tu16 tid_rxseq[16];\n \n};\n\n\nstruct signal_stat {\n\tu8 update_req;\t\t \n\tu8 avg_val;\t\t \n\tu32 total_num;\t\t \n\tu32 total_val;\t\t \n};\n\nstruct phy_info {\n\tu8 rx_pwd_ba11;\n\n\tu8 SignalQuality;\t  \n\ts8\t\trx_mimo_signal_quality[4];\t \n\tu8 RxMIMOEVMdbm[4];\t\t \n\n\tu8 rx_mimo_signal_strength[4]; \n\n\tu16 \tCfo_short[4];\t\t\t \n\tu16 \tCfo_tail[4];\t\t\t \n\n\ts8\t\tRxPower;  \n\ts8\t\tRecvSignalPower; \n\tu8 bt_rx_rssi_percentage;\n\tu8 SignalStrength;  \n\n\ts8\t\tRxPwr[4];\t\t\t\t \n\tu8 RxSNR[4];\t\t\t\t \n\tu8 BandWidth;\n\tu8 btCoexPwrAdjust;\n};\n\n#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA\nstruct rx_raw_rssi {\n\tu8 data_rate;\n\tu8 pwdball;\n\ts8 pwr_all;\n\n\tu8 mimo_signal_strength[4]; \n\tu8 mimo_signal_quality[4];\n\n\ts8 ofdm_pwr[4];\n\tu8 ofdm_snr[4];\n\n};\n#endif\n\nstruct rx_pkt_attrib\t{\n\tu16 pkt_len;\n\tu8 physt;\n\tu8 drvinfo_sz;\n\tu8 shift_sz;\n\tu8 hdrlen;  \n\tu8 to_fr_ds;\n\tu8 amsdu;\n\tu8 qos;\n\tu8 priority;\n\tu8 pw_save;\n\tu8 mdata;\n\tu16 seq_num;\n\tu8 frag_num;\n\tu8 mfrag;\n\tu8 order;\n\tu8 privacy;  \n\tu8 bdecrypted;\n\tu8 encrypt;  \n\tu8 iv_len;\n\tu8 icv_len;\n\tu8 crc_err;\n\tu8 icv_err;\n\n\tu16 eth_type;\n\n\tu8 dst[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n\tu8 ta[ETH_ALEN];\n\tu8 ra[ETH_ALEN];\n\tu8 bssid[ETH_ALEN];\n\n\tu8 ack_policy;\n\n\tu8 key_index;\n\n\tu8 data_rate;\n\tu8 sgi;\n\tu8 pkt_rpt_type;\n\tu32 MacIDValidEntry[2];\t \n\n \n\tstruct phy_info phy_info;\n};\n\n\n \n#define SN_LESS(a, b)\t\t(((a - b) & 0x800) != 0)\n#define SN_EQUAL(a, b)\t(a == b)\n \n \n#define REORDER_WAIT_TIME\t(50)  \n\n#define RECVBUFF_ALIGN_SZ 8\n\n#define RXDESC_SIZE\t24\n#define RXDESC_OFFSET RXDESC_SIZE\n\nstruct recv_stat {\n\t__le32 rxdw0;\n\t__le32 rxdw1;\n\t__le32 rxdw2;\n\t__le32 rxdw3;\n#ifndef BUF_DESC_ARCH\n\t__le32 rxdw4;\n\t__le32 rxdw5;\n#endif  \n};\n\n#define EOR BIT(30)\n\n \nstruct recv_priv {\n\tspinlock_t\tlock;\n\tstruct __queue\tfree_recv_queue;\n\tstruct __queue\trecv_pending_queue;\n\tstruct __queue\tuc_swdec_pending_queue;\n\tu8 *pallocated_frame_buf;\n\tu8 *precv_frame_buf;\n\tuint free_recvframe_cnt;\n\tstruct adapter\t*adapter;\n\tu32 bIsAnyNonBEPkts;\n\tu64\trx_bytes;\n\tu64\trx_pkts;\n\tu64\trx_drop;\n\tuint  rx_icv_err;\n\tuint  rx_largepacket_crcerr;\n\tuint  rx_smallpacket_crcerr;\n\tuint  rx_middlepacket_crcerr;\n\n\tstruct tasklet_struct irq_prepare_beacon_tasklet;\n\tstruct tasklet_struct recv_tasklet;\n\tstruct sk_buff_head free_recv_skb_queue;\n\tstruct sk_buff_head rx_skb_queue;\n\n\tu8 *pallocated_recv_buf;\n\tu8 *precv_buf;     \n\tstruct __queue\tfree_recv_buf_queue;\n\tu32 free_recv_buf_queue_cnt;\n\n\tstruct __queue\trecv_buf_pending_queue;\n\n\t \n\tu8 is_signal_dbg;\t \n\tu8 signal_strength_dbg;\t \n\n\tu8 signal_strength;\n\tu8 signal_qual;\n\ts8 rssi;\t \n\t#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA\n\tstruct rx_raw_rssi raw_rssi_info;\n\t#endif\n\t \n\ts16 noise;\n\t \n\t \n\t \n\n\n\tstruct timer_list signal_stat_timer;\n\tu32 signal_stat_sampling_interval;\n\t \n\tstruct signal_stat signal_qual_data;\n\tstruct signal_stat signal_strength_data;\n};\n\n#define rtw_set_signal_stat_timer(recvpriv) _set_timer(&(recvpriv)->signal_stat_timer, (recvpriv)->signal_stat_sampling_interval)\n\nstruct sta_recv_priv {\n\n\tspinlock_t\tlock;\n\tsigned int\toption;\n\n\t \n\tstruct __queue defrag_q;\t  \n\n\tstruct\tstainfo_rxcache rxcache;\n\n\t \n\t \n\t \n\n};\n\n\nstruct recv_buf {\n\tstruct list_head list;\n\n\tspinlock_t recvbuf_lock;\n\n\tu32 ref_cnt;\n\n\tstruct adapter *adapter;\n\n\tu8 *pbuf;\n\tu8 *pallocated_buf;\n\n\tu32 len;\n\tu8 *phead;\n\tu8 *pdata;\n\tu8 *ptail;\n\tu8 *pend;\n\n\tstruct sk_buff\t*pskb;\n\tu8 reuse;\n};\n\n\n \nstruct recv_frame_hdr {\n\tstruct list_head\tlist;\n\tstruct sk_buff\t *pkt;\n\tstruct sk_buff\t *pkt_newalloc;\n\n\tstruct adapter  *adapter;\n\n\tu8 fragcnt;\n\n\tint frame_tag;\n\n\tstruct rx_pkt_attrib attrib;\n\n\tuint  len;\n\tu8 *rx_head;\n\tu8 *rx_data;\n\tu8 *rx_tail;\n\tu8 *rx_end;\n\n\tvoid *precvbuf;\n\n\n\t \n\tstruct sta_info *psta;\n\n\t \n\tstruct recv_reorder_ctrl *preorder_ctrl;\n};\n\n\nunion recv_frame {\n\tunion{\n\t\tstruct list_head list;\n\t\tstruct recv_frame_hdr hdr;\n\t\tuint mem[RECVFRAME_HDR_ALIGN>>2];\n\t} u;\n\n\t \n\n};\n\nenum {\n\tNORMAL_RX, \n\tTX_REPORT1, \n\tTX_REPORT2, \n\tHIS_REPORT, \n\tC2H_PACKET\n};\n\nextern union recv_frame *_rtw_alloc_recvframe(struct __queue *pfree_recv_queue);   \nextern union recv_frame *rtw_alloc_recvframe(struct __queue *pfree_recv_queue);   \nextern int\t rtw_free_recvframe(union recv_frame *precvframe, struct __queue *pfree_recv_queue);\n\n#define rtw_dequeue_recvframe(queue) rtw_alloc_recvframe(queue)\nextern int _rtw_enqueue_recvframe(union recv_frame *precvframe, struct __queue *queue);\nextern int rtw_enqueue_recvframe(union recv_frame *precvframe, struct __queue *queue);\n\nextern void rtw_free_recvframe_queue(struct __queue *pframequeue,  struct __queue *pfree_recv_queue);\nu32 rtw_free_uc_swdec_pending_queue(struct adapter *adapter);\n\nsigned int rtw_enqueue_recvbuf_to_head(struct recv_buf *precvbuf, struct __queue *queue);\nsigned int rtw_enqueue_recvbuf(struct recv_buf *precvbuf, struct __queue *queue);\nstruct recv_buf *rtw_dequeue_recvbuf(struct __queue *queue);\n\nvoid rtw_reordering_ctrl_timeout_handler(struct timer_list *t);\n\nstatic inline u8 *get_rxmem(union recv_frame *precvframe)\n{\n\t \n\tif (precvframe == NULL)\n\t\treturn NULL;\n\n\treturn precvframe->u.hdr.rx_head;\n}\n\nstatic inline u8 *recvframe_pull(union recv_frame *precvframe, signed int sz)\n{\n\t \n\n\t \n\n\n\tif (precvframe == NULL)\n\t\treturn NULL;\n\n\n\tprecvframe->u.hdr.rx_data += sz;\n\n\tif (precvframe->u.hdr.rx_data > precvframe->u.hdr.rx_tail) {\n\t\tprecvframe->u.hdr.rx_data -= sz;\n\t\treturn NULL;\n\t}\n\n\tprecvframe->u.hdr.len -= sz;\n\n\treturn precvframe->u.hdr.rx_data;\n\n}\n\nstatic inline u8 *recvframe_put(union recv_frame *precvframe, signed int sz)\n{\n\t \n\n\t \n\t \n\tunsigned char *prev_rx_tail;\n\n\tif (precvframe == NULL)\n\t\treturn NULL;\n\n\tprev_rx_tail = precvframe->u.hdr.rx_tail;\n\n\tprecvframe->u.hdr.rx_tail += sz;\n\n\tif (precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end) {\n\t\tprecvframe->u.hdr.rx_tail = prev_rx_tail;\n\t\treturn NULL;\n\t}\n\n\tprecvframe->u.hdr.len += sz;\n\n\treturn precvframe->u.hdr.rx_tail;\n\n}\n\n\n\nstatic inline u8 *recvframe_pull_tail(union recv_frame *precvframe, signed int sz)\n{\n\t \n\n\t \n\t \n\n\tif (precvframe == NULL)\n\t\treturn NULL;\n\n\tprecvframe->u.hdr.rx_tail -= sz;\n\n\tif (precvframe->u.hdr.rx_tail < precvframe->u.hdr.rx_data) {\n\t\tprecvframe->u.hdr.rx_tail += sz;\n\t\treturn NULL;\n\t}\n\n\tprecvframe->u.hdr.len -= sz;\n\n\treturn precvframe->u.hdr.rx_tail;\n\n}\n\nstatic inline union recv_frame *rxmem_to_recvframe(u8 *rxmem)\n{\n\t \n\t \n\t \n\n\treturn (union recv_frame *)(((SIZE_PTR)rxmem >> RXFRAME_ALIGN) << RXFRAME_ALIGN);\n\n}\n\nstatic inline signed int get_recvframe_len(union recv_frame *precvframe)\n{\n\treturn precvframe->u.hdr.len;\n}\n\n\nstatic inline s32 translate_percentage_to_dbm(u32 SignalStrengthIndex)\n{\n\ts32\tSignalPower;  \n\n\t \n\tSignalPower = (s32)((SignalStrengthIndex + 1) >> 1);\n\tSignalPower -= 95;\n\n\treturn SignalPower;\n}\n\n\nstruct sta_info;\n\nextern void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv);\n\nextern void  mgt_dispatcher(struct adapter *padapter, union recv_frame *precv_frame);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}