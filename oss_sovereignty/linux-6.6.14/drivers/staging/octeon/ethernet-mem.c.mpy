{
  "module_name": "ethernet-mem.c",
  "hash_id": "bfc54400781901605474ba5e3d1e2e74b3a26fbcd597f5af46594eeb5d6351c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/octeon/ethernet-mem.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n\n#include \"octeon-ethernet.h\"\n#include \"ethernet-mem.h\"\n#include \"ethernet-defines.h\"\n\n \nstatic int cvm_oct_fill_hw_skbuff(int pool, int size, int elements)\n{\n\tint freed = elements;\n\n\twhile (freed) {\n\t\tstruct sk_buff *skb = dev_alloc_skb(size + 256);\n\n\t\tif (unlikely(!skb))\n\t\t\tbreak;\n\t\tskb_reserve(skb, 256 - (((unsigned long)skb->data) & 0x7f));\n\t\t*(struct sk_buff **)(skb->data - sizeof(void *)) = skb;\n\t\tcvmx_fpa_free(skb->data, pool, size / 128);\n\t\tfreed--;\n\t}\n\treturn elements - freed;\n}\n\n \nstatic void cvm_oct_free_hw_skbuff(int pool, int size, int elements)\n{\n\tchar *memory;\n\n\tdo {\n\t\tmemory = cvmx_fpa_alloc(pool);\n\t\tif (memory) {\n\t\t\tstruct sk_buff *skb =\n\t\t\t    *(struct sk_buff **)(memory - sizeof(void *));\n\t\t\telements--;\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t} while (memory);\n\n\tif (elements < 0)\n\t\tpr_warn(\"Freeing of pool %u had too many skbuffs (%d)\\n\",\n\t\t\tpool, elements);\n\telse if (elements > 0)\n\t\tpr_warn(\"Freeing of pool %u is missing %d skbuffs\\n\",\n\t\t\tpool, elements);\n}\n\n \nstatic int cvm_oct_fill_hw_memory(int pool, int size, int elements)\n{\n\tchar *memory;\n\tchar *fpa;\n\tint freed = elements;\n\n\twhile (freed) {\n\t\t \n\t\tmemory = kmalloc(size + 256, GFP_ATOMIC);\n\t\tif (unlikely(!memory)) {\n\t\t\tpr_warn(\"Unable to allocate %u bytes for FPA pool %d\\n\",\n\t\t\t\telements * size, pool);\n\t\t\tbreak;\n\t\t}\n\t\tfpa = (char *)(((unsigned long)memory + 256) & ~0x7fUL);\n\t\t*((char **)fpa - 1) = memory;\n\t\tcvmx_fpa_free(fpa, pool, 0);\n\t\tfreed--;\n\t}\n\treturn elements - freed;\n}\n\n \nstatic void cvm_oct_free_hw_memory(int pool, int size, int elements)\n{\n\tchar *memory;\n\tchar *fpa;\n\n\tdo {\n\t\tfpa = cvmx_fpa_alloc(pool);\n\t\tif (fpa) {\n\t\t\telements--;\n\t\t\tfpa = (char *)phys_to_virt(cvmx_ptr_to_phys(fpa));\n\t\t\tmemory = *((char **)fpa - 1);\n\t\t\tkfree(memory);\n\t\t}\n\t} while (fpa);\n\n\tif (elements < 0)\n\t\tpr_warn(\"Freeing of pool %u had too many buffers (%d)\\n\",\n\t\t\tpool, elements);\n\telse if (elements > 0)\n\t\tpr_warn(\"Warning: Freeing of pool %u is missing %d buffers\\n\",\n\t\t\tpool, elements);\n}\n\nint cvm_oct_mem_fill_fpa(int pool, int size, int elements)\n{\n\tint freed;\n\n\tif (pool == CVMX_FPA_PACKET_POOL)\n\t\tfreed = cvm_oct_fill_hw_skbuff(pool, size, elements);\n\telse\n\t\tfreed = cvm_oct_fill_hw_memory(pool, size, elements);\n\treturn freed;\n}\n\nvoid cvm_oct_mem_empty_fpa(int pool, int size, int elements)\n{\n\tif (pool == CVMX_FPA_PACKET_POOL)\n\t\tcvm_oct_free_hw_skbuff(pool, size, elements);\n\telse\n\t\tcvm_oct_free_hw_memory(pool, size, elements);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}