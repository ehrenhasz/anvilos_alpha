{
  "module_name": "ethernet.c",
  "hash_id": "9696dfd9bda9fe105c9758a0a3f9b2cde8a100366860e8ef07cc6d13dc7589fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/octeon/ethernet.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/phy.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n\n#include <net/dst.h>\n\n#include \"octeon-ethernet.h\"\n#include \"ethernet-defines.h\"\n#include \"ethernet-mem.h\"\n#include \"ethernet-rx.h\"\n#include \"ethernet-tx.h\"\n#include \"ethernet-mdio.h\"\n#include \"ethernet-util.h\"\n\n#define OCTEON_MAX_MTU 65392\n\nstatic int num_packet_buffers = 1024;\nmodule_param(num_packet_buffers, int, 0444);\nMODULE_PARM_DESC(num_packet_buffers, \"\\n\"\n\t\"\\tNumber of packet buffers to allocate and store in the\\n\"\n\t\"\\tFPA. By default, 1024 packet buffers are used.\\n\");\n\nstatic int pow_receive_group = 15;\nmodule_param(pow_receive_group, int, 0444);\nMODULE_PARM_DESC(pow_receive_group, \"\\n\"\n\t\"\\tPOW group to receive packets from. All ethernet hardware\\n\"\n\t\"\\twill be configured to send incoming packets to this POW\\n\"\n\t\"\\tgroup. Also any other software can submit packets to this\\n\"\n\t\"\\tgroup for the kernel to process.\");\n\nstatic int receive_group_order;\nmodule_param(receive_group_order, int, 0444);\nMODULE_PARM_DESC(receive_group_order, \"\\n\"\n\t\"\\tOrder (0..4) of receive groups to take into use. Ethernet hardware\\n\"\n\t\"\\twill be configured to send incoming packets to multiple POW\\n\"\n\t\"\\tgroups. pow_receive_group parameter is ignored when multiple\\n\"\n\t\"\\tgroups are taken into use and groups are allocated starting\\n\"\n\t\"\\tfrom 0. By default, a single group is used.\\n\");\n\nint pow_send_group = -1;\nmodule_param(pow_send_group, int, 0644);\nMODULE_PARM_DESC(pow_send_group, \"\\n\"\n\t\"\\tPOW group to send packets to other software on. This\\n\"\n\t\"\\tcontrols the creation of the virtual device pow0.\\n\"\n\t\"\\talways_use_pow also depends on this value.\");\n\nint always_use_pow;\nmodule_param(always_use_pow, int, 0444);\nMODULE_PARM_DESC(always_use_pow, \"\\n\"\n\t\"\\tWhen set, always send to the pow group. This will cause\\n\"\n\t\"\\tpackets sent to real ethernet devices to be sent to the\\n\"\n\t\"\\tPOW group instead of the hardware. Unless some other\\n\"\n\t\"\\tapplication changes the config, packets will still be\\n\"\n\t\"\\treceived from the low level hardware. Use this option\\n\"\n\t\"\\tto allow a CVMX app to intercept all packets from the\\n\"\n\t\"\\tlinux kernel. You must specify pow_send_group along with\\n\"\n\t\"\\tthis option.\");\n\nchar pow_send_list[128] = \"\";\nmodule_param_string(pow_send_list, pow_send_list, sizeof(pow_send_list), 0444);\nMODULE_PARM_DESC(pow_send_list, \"\\n\"\n\t\"\\tComma separated list of ethernet devices that should use the\\n\"\n\t\"\\tPOW for transmit instead of the actual ethernet hardware. This\\n\"\n\t\"\\tis a per port version of always_use_pow. always_use_pow takes\\n\"\n\t\"\\tprecedence over this list. For example, setting this to\\n\"\n\t\"\\t\\\"eth2,spi3,spi7\\\" would cause these three devices to transmit\\n\"\n\t\"\\tusing the pow_send_group.\");\n\nint rx_napi_weight = 32;\nmodule_param(rx_napi_weight, int, 0444);\nMODULE_PARM_DESC(rx_napi_weight, \"The NAPI WEIGHT parameter.\");\n\n \nint pow_receive_groups;\n\n \natomic_t cvm_oct_poll_queue_stopping = ATOMIC_INIT(0);\n\n \nstruct net_device *cvm_oct_device[TOTAL_NUMBER_OF_PORTS];\n\nu64 cvm_oct_tx_poll_interval;\n\nstatic void cvm_oct_rx_refill_worker(struct work_struct *work);\nstatic DECLARE_DELAYED_WORK(cvm_oct_rx_refill_work, cvm_oct_rx_refill_worker);\n\nstatic void cvm_oct_rx_refill_worker(struct work_struct *work)\n{\n\t \n\tcvm_oct_rx_refill_pool(num_packet_buffers / 2);\n\n\tif (!atomic_read(&cvm_oct_poll_queue_stopping))\n\t\tschedule_delayed_work(&cvm_oct_rx_refill_work, HZ);\n}\n\nstatic void cvm_oct_periodic_worker(struct work_struct *work)\n{\n\tstruct octeon_ethernet *priv = container_of(work,\n\t\t\t\t\t\t    struct octeon_ethernet,\n\t\t\t\t\t\t    port_periodic_work.work);\n\n\tif (priv->poll)\n\t\tpriv->poll(cvm_oct_device[priv->port]);\n\n\tcvm_oct_device[priv->port]->netdev_ops->ndo_get_stats\n\t\t\t\t\t\t(cvm_oct_device[priv->port]);\n\n\tif (!atomic_read(&cvm_oct_poll_queue_stopping))\n\t\tschedule_delayed_work(&priv->port_periodic_work, HZ);\n}\n\nstatic void cvm_oct_configure_common_hw(void)\n{\n\t \n\tcvmx_fpa_enable();\n\tcvm_oct_mem_fill_fpa(CVMX_FPA_PACKET_POOL, CVMX_FPA_PACKET_POOL_SIZE,\n\t\t\t     num_packet_buffers);\n\tcvm_oct_mem_fill_fpa(CVMX_FPA_WQE_POOL, CVMX_FPA_WQE_POOL_SIZE,\n\t\t\t     num_packet_buffers);\n\tif (CVMX_FPA_OUTPUT_BUFFER_POOL != CVMX_FPA_PACKET_POOL)\n\t\tcvm_oct_mem_fill_fpa(CVMX_FPA_OUTPUT_BUFFER_POOL,\n\t\t\t\t     CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE, 1024);\n\n#ifdef __LITTLE_ENDIAN\n\t{\n\t\tunion cvmx_ipd_ctl_status ipd_ctl_status;\n\n\t\tipd_ctl_status.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);\n\t\tipd_ctl_status.s.pkt_lend = 1;\n\t\tipd_ctl_status.s.wqe_lend = 1;\n\t\tcvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_ctl_status.u64);\n\t}\n#endif\n\n\tcvmx_helper_setup_red(num_packet_buffers / 4, num_packet_buffers / 8);\n}\n\n \nint cvm_oct_free_work(void *work_queue_entry)\n{\n\tstruct cvmx_wqe *work = work_queue_entry;\n\n\tint segments = work->word2.s.bufs;\n\tunion cvmx_buf_ptr segment_ptr = work->packet_ptr;\n\n\twhile (segments--) {\n\t\tunion cvmx_buf_ptr next_ptr = *(union cvmx_buf_ptr *)\n\t\t\tcvmx_phys_to_ptr(segment_ptr.s.addr - 8);\n\t\tif (unlikely(!segment_ptr.s.i))\n\t\t\tcvmx_fpa_free(cvm_oct_get_buffer_ptr(segment_ptr),\n\t\t\t\t      segment_ptr.s.pool,\n\t\t\t\t      CVMX_FPA_PACKET_POOL_SIZE / 128);\n\t\tsegment_ptr = next_ptr;\n\t}\n\tcvmx_fpa_free(work, CVMX_FPA_WQE_POOL, 1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cvm_oct_free_work);\n\n \nstatic struct net_device_stats *cvm_oct_common_get_stats(struct net_device *dev)\n{\n\tcvmx_pip_port_status_t rx_status;\n\tcvmx_pko_port_status_t tx_status;\n\tstruct octeon_ethernet *priv = netdev_priv(dev);\n\n\tif (priv->port < CVMX_PIP_NUM_INPUT_PORTS) {\n\t\tif (octeon_is_simulation()) {\n\t\t\t \n\t\t\tmemset(&rx_status, 0, sizeof(rx_status));\n\t\t\tmemset(&tx_status, 0, sizeof(tx_status));\n\t\t} else {\n\t\t\tcvmx_pip_get_port_status(priv->port, 1, &rx_status);\n\t\t\tcvmx_pko_get_port_status(priv->port, 1, &tx_status);\n\t\t}\n\n\t\tdev->stats.rx_packets += rx_status.inb_packets;\n\t\tdev->stats.tx_packets += tx_status.packets;\n\t\tdev->stats.rx_bytes += rx_status.inb_octets;\n\t\tdev->stats.tx_bytes += tx_status.octets;\n\t\tdev->stats.multicast += rx_status.multicast_packets;\n\t\tdev->stats.rx_crc_errors += rx_status.inb_errors;\n\t\tdev->stats.rx_frame_errors += rx_status.fcs_align_err_packets;\n\t\tdev->stats.rx_dropped += rx_status.dropped_packets;\n\t}\n\n\treturn &dev->stats;\n}\n\n \nstatic int cvm_oct_common_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct octeon_ethernet *priv = netdev_priv(dev);\n\tint interface = INTERFACE(priv->port);\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n\tint vlan_bytes = VLAN_HLEN;\n#else\n\tint vlan_bytes = 0;\n#endif\n\tint mtu_overhead = ETH_HLEN + ETH_FCS_LEN + vlan_bytes;\n\n\tdev->mtu = new_mtu;\n\n\tif ((interface < 2) &&\n\t    (cvmx_helper_interface_get_mode(interface) !=\n\t\tCVMX_HELPER_INTERFACE_MODE_SPI)) {\n\t\tint index = INDEX(priv->port);\n\t\t \n\t\tint max_packet = new_mtu + mtu_overhead;\n\n\t\tif (OCTEON_IS_MODEL(OCTEON_CN3XXX) ||\n\t\t    OCTEON_IS_MODEL(OCTEON_CN58XX)) {\n\t\t\t \n\t\t\tcvmx_write_csr(CVMX_GMXX_RXX_FRM_MAX(index, interface),\n\t\t\t\t       max_packet);\n\t\t} else {\n\t\t\t \n\t\t\tunion cvmx_pip_frm_len_chkx frm_len_chk;\n\n\t\t\tfrm_len_chk.u64 = 0;\n\t\t\tfrm_len_chk.s.minlen = VLAN_ETH_ZLEN;\n\t\t\tfrm_len_chk.s.maxlen = max_packet;\n\t\t\tcvmx_write_csr(CVMX_PIP_FRM_LEN_CHKX(interface),\n\t\t\t\t       frm_len_chk.u64);\n\t\t}\n\t\t \n\t\tcvmx_write_csr(CVMX_GMXX_RXX_JABBER(index, interface),\n\t\t\t       (max_packet + 7) & ~7u);\n\t}\n\treturn 0;\n}\n\n \nstatic void cvm_oct_common_set_multicast_list(struct net_device *dev)\n{\n\tunion cvmx_gmxx_prtx_cfg gmx_cfg;\n\tstruct octeon_ethernet *priv = netdev_priv(dev);\n\tint interface = INTERFACE(priv->port);\n\n\tif ((interface < 2) &&\n\t    (cvmx_helper_interface_get_mode(interface) !=\n\t\tCVMX_HELPER_INTERFACE_MODE_SPI)) {\n\t\tunion cvmx_gmxx_rxx_adr_ctl control;\n\t\tint index = INDEX(priv->port);\n\n\t\tcontrol.u64 = 0;\n\t\tcontrol.s.bcst = 1;\t \n\n\t\tif (!netdev_mc_empty(dev) || (dev->flags & IFF_ALLMULTI) ||\n\t\t    (dev->flags & IFF_PROMISC))\n\t\t\t \n\t\t\tcontrol.s.mcst = 2;\n\t\telse\n\t\t\t \n\t\t\tcontrol.s.mcst = 1;\n\n\t\tif (dev->flags & IFF_PROMISC)\n\t\t\t \n\t\t\tcontrol.s.cam_mode = 0;\n\t\telse\n\t\t\t \n\t\t\tcontrol.s.cam_mode = 1;\n\n\t\tgmx_cfg.u64 =\n\t\t    cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));\n\t\tcvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface),\n\t\t\t       gmx_cfg.u64 & ~1ull);\n\n\t\tcvmx_write_csr(CVMX_GMXX_RXX_ADR_CTL(index, interface),\n\t\t\t       control.u64);\n\t\tif (dev->flags & IFF_PROMISC)\n\t\t\tcvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM_EN\n\t\t\t\t       (index, interface), 0);\n\t\telse\n\t\t\tcvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM_EN\n\t\t\t\t       (index, interface), 1);\n\n\t\tcvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface),\n\t\t\t       gmx_cfg.u64);\n\t}\n}\n\nstatic int cvm_oct_set_mac_filter(struct net_device *dev)\n{\n\tstruct octeon_ethernet *priv = netdev_priv(dev);\n\tunion cvmx_gmxx_prtx_cfg gmx_cfg;\n\tint interface = INTERFACE(priv->port);\n\n\tif ((interface < 2) &&\n\t    (cvmx_helper_interface_get_mode(interface) !=\n\t\tCVMX_HELPER_INTERFACE_MODE_SPI)) {\n\t\tint i;\n\t\tconst u8 *ptr = dev->dev_addr;\n\t\tu64 mac = 0;\n\t\tint index = INDEX(priv->port);\n\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tmac = (mac << 8) | (u64)ptr[i];\n\n\t\tgmx_cfg.u64 =\n\t\t    cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));\n\t\tcvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface),\n\t\t\t       gmx_cfg.u64 & ~1ull);\n\n\t\tcvmx_write_csr(CVMX_GMXX_SMACX(index, interface), mac);\n\t\tcvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM0(index, interface),\n\t\t\t       ptr[0]);\n\t\tcvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM1(index, interface),\n\t\t\t       ptr[1]);\n\t\tcvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM2(index, interface),\n\t\t\t       ptr[2]);\n\t\tcvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM3(index, interface),\n\t\t\t       ptr[3]);\n\t\tcvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM4(index, interface),\n\t\t\t       ptr[4]);\n\t\tcvmx_write_csr(CVMX_GMXX_RXX_ADR_CAM5(index, interface),\n\t\t\t       ptr[5]);\n\t\tcvm_oct_common_set_multicast_list(dev);\n\t\tcvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface),\n\t\t\t       gmx_cfg.u64);\n\t}\n\treturn 0;\n}\n\n \nstatic int cvm_oct_common_set_mac_address(struct net_device *dev, void *addr)\n{\n\tint r = eth_mac_addr(dev, addr);\n\n\tif (r)\n\t\treturn r;\n\treturn cvm_oct_set_mac_filter(dev);\n}\n\n \nint cvm_oct_common_init(struct net_device *dev)\n{\n\tstruct octeon_ethernet *priv = netdev_priv(dev);\n\tint ret;\n\n\tret = of_get_ethdev_address(priv->of_node, dev);\n\tif (ret)\n\t\teth_hw_addr_random(dev);\n\n\t \n\tif ((pow_send_group != -1) &&\n\t    (always_use_pow || strstr(pow_send_list, dev->name)))\n\t\tpriv->queue = -1;\n\n\tif (priv->queue != -1)\n\t\tdev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;\n\n\t \n\tdev->features |= NETIF_F_LLTX;\n\tdev->ethtool_ops = &cvm_oct_ethtool_ops;\n\n\tcvm_oct_set_mac_filter(dev);\n\tdev_set_mtu(dev, dev->mtu);\n\n\t \n\tmemset(dev->netdev_ops->ndo_get_stats(dev), 0,\n\t       sizeof(struct net_device_stats));\n\n\tif (dev->netdev_ops->ndo_stop)\n\t\tdev->netdev_ops->ndo_stop(dev);\n\n\treturn 0;\n}\n\nvoid cvm_oct_common_uninit(struct net_device *dev)\n{\n\tif (dev->phydev)\n\t\tphy_disconnect(dev->phydev);\n}\n\nint cvm_oct_common_open(struct net_device *dev,\n\t\t\tvoid (*link_poll)(struct net_device *))\n{\n\tunion cvmx_gmxx_prtx_cfg gmx_cfg;\n\tstruct octeon_ethernet *priv = netdev_priv(dev);\n\tint interface = INTERFACE(priv->port);\n\tint index = INDEX(priv->port);\n\tunion cvmx_helper_link_info link_info;\n\tint rv;\n\n\trv = cvm_oct_phy_setup_device(dev);\n\tif (rv)\n\t\treturn rv;\n\n\tgmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));\n\tgmx_cfg.s.en = 1;\n\tif (octeon_has_feature(OCTEON_FEATURE_PKND))\n\t\tgmx_cfg.s.pknd = priv->port;\n\tcvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmx_cfg.u64);\n\n\tif (octeon_is_simulation())\n\t\treturn 0;\n\n\tif (dev->phydev) {\n\t\tint r = phy_read_status(dev->phydev);\n\n\t\tif (r == 0 && dev->phydev->link == 0)\n\t\t\tnetif_carrier_off(dev);\n\t\tcvm_oct_adjust_link(dev);\n\t} else {\n\t\tlink_info = cvmx_helper_link_get(priv->port);\n\t\tif (!link_info.s.link_up)\n\t\t\tnetif_carrier_off(dev);\n\t\tpriv->poll = link_poll;\n\t\tlink_poll(dev);\n\t}\n\n\treturn 0;\n}\n\nvoid cvm_oct_link_poll(struct net_device *dev)\n{\n\tstruct octeon_ethernet *priv = netdev_priv(dev);\n\tunion cvmx_helper_link_info link_info;\n\n\tlink_info = cvmx_helper_link_get(priv->port);\n\tif (link_info.u64 == priv->link_info)\n\t\treturn;\n\n\tif (cvmx_helper_link_set(priv->port, link_info))\n\t\tlink_info.u64 = priv->link_info;\n\telse\n\t\tpriv->link_info = link_info.u64;\n\n\tif (link_info.s.link_up) {\n\t\tif (!netif_carrier_ok(dev))\n\t\t\tnetif_carrier_on(dev);\n\t} else if (netif_carrier_ok(dev)) {\n\t\tnetif_carrier_off(dev);\n\t}\n\tcvm_oct_note_carrier(priv, link_info);\n}\n\nstatic int cvm_oct_xaui_open(struct net_device *dev)\n{\n\treturn cvm_oct_common_open(dev, cvm_oct_link_poll);\n}\n\nstatic const struct net_device_ops cvm_oct_npi_netdev_ops = {\n\t.ndo_init\t\t= cvm_oct_common_init,\n\t.ndo_uninit\t\t= cvm_oct_common_uninit,\n\t.ndo_start_xmit\t\t= cvm_oct_xmit,\n\t.ndo_set_rx_mode\t= cvm_oct_common_set_multicast_list,\n\t.ndo_set_mac_address\t= cvm_oct_common_set_mac_address,\n\t.ndo_eth_ioctl\t\t= cvm_oct_ioctl,\n\t.ndo_change_mtu\t\t= cvm_oct_common_change_mtu,\n\t.ndo_get_stats\t\t= cvm_oct_common_get_stats,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= cvm_oct_poll_controller,\n#endif\n};\n\nstatic const struct net_device_ops cvm_oct_xaui_netdev_ops = {\n\t.ndo_init\t\t= cvm_oct_common_init,\n\t.ndo_uninit\t\t= cvm_oct_common_uninit,\n\t.ndo_open\t\t= cvm_oct_xaui_open,\n\t.ndo_stop\t\t= cvm_oct_common_stop,\n\t.ndo_start_xmit\t\t= cvm_oct_xmit,\n\t.ndo_set_rx_mode\t= cvm_oct_common_set_multicast_list,\n\t.ndo_set_mac_address\t= cvm_oct_common_set_mac_address,\n\t.ndo_eth_ioctl\t\t= cvm_oct_ioctl,\n\t.ndo_change_mtu\t\t= cvm_oct_common_change_mtu,\n\t.ndo_get_stats\t\t= cvm_oct_common_get_stats,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= cvm_oct_poll_controller,\n#endif\n};\n\nstatic const struct net_device_ops cvm_oct_sgmii_netdev_ops = {\n\t.ndo_init\t\t= cvm_oct_sgmii_init,\n\t.ndo_uninit\t\t= cvm_oct_common_uninit,\n\t.ndo_open\t\t= cvm_oct_sgmii_open,\n\t.ndo_stop\t\t= cvm_oct_common_stop,\n\t.ndo_start_xmit\t\t= cvm_oct_xmit,\n\t.ndo_set_rx_mode\t= cvm_oct_common_set_multicast_list,\n\t.ndo_set_mac_address\t= cvm_oct_common_set_mac_address,\n\t.ndo_eth_ioctl\t\t= cvm_oct_ioctl,\n\t.ndo_change_mtu\t\t= cvm_oct_common_change_mtu,\n\t.ndo_get_stats\t\t= cvm_oct_common_get_stats,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= cvm_oct_poll_controller,\n#endif\n};\n\nstatic const struct net_device_ops cvm_oct_spi_netdev_ops = {\n\t.ndo_init\t\t= cvm_oct_spi_init,\n\t.ndo_uninit\t\t= cvm_oct_spi_uninit,\n\t.ndo_start_xmit\t\t= cvm_oct_xmit,\n\t.ndo_set_rx_mode\t= cvm_oct_common_set_multicast_list,\n\t.ndo_set_mac_address\t= cvm_oct_common_set_mac_address,\n\t.ndo_eth_ioctl\t\t= cvm_oct_ioctl,\n\t.ndo_change_mtu\t\t= cvm_oct_common_change_mtu,\n\t.ndo_get_stats\t\t= cvm_oct_common_get_stats,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= cvm_oct_poll_controller,\n#endif\n};\n\nstatic const struct net_device_ops cvm_oct_rgmii_netdev_ops = {\n\t.ndo_init\t\t= cvm_oct_common_init,\n\t.ndo_uninit\t\t= cvm_oct_common_uninit,\n\t.ndo_open\t\t= cvm_oct_rgmii_open,\n\t.ndo_stop\t\t= cvm_oct_common_stop,\n\t.ndo_start_xmit\t\t= cvm_oct_xmit,\n\t.ndo_set_rx_mode\t= cvm_oct_common_set_multicast_list,\n\t.ndo_set_mac_address\t= cvm_oct_common_set_mac_address,\n\t.ndo_eth_ioctl\t\t= cvm_oct_ioctl,\n\t.ndo_change_mtu\t\t= cvm_oct_common_change_mtu,\n\t.ndo_get_stats\t\t= cvm_oct_common_get_stats,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= cvm_oct_poll_controller,\n#endif\n};\n\nstatic const struct net_device_ops cvm_oct_pow_netdev_ops = {\n\t.ndo_init\t\t= cvm_oct_common_init,\n\t.ndo_start_xmit\t\t= cvm_oct_xmit_pow,\n\t.ndo_set_rx_mode\t= cvm_oct_common_set_multicast_list,\n\t.ndo_set_mac_address\t= cvm_oct_common_set_mac_address,\n\t.ndo_eth_ioctl\t\t= cvm_oct_ioctl,\n\t.ndo_change_mtu\t\t= cvm_oct_common_change_mtu,\n\t.ndo_get_stats\t\t= cvm_oct_common_get_stats,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= cvm_oct_poll_controller,\n#endif\n};\n\nstatic struct device_node *cvm_oct_of_get_child\n\t\t\t\t(const struct device_node *parent, int reg_val)\n{\n\tstruct device_node *node;\n\tconst __be32 *addr;\n\tint size;\n\n\tfor_each_child_of_node(parent, node) {\n\t\taddr = of_get_property(node, \"reg\", &size);\n\t\tif (addr && (be32_to_cpu(*addr) == reg_val))\n\t\t\tbreak;\n\t}\n\treturn node;\n}\n\nstatic struct device_node *cvm_oct_node_for_port(struct device_node *pip,\n\t\t\t\t\t\t int interface, int port)\n{\n\tstruct device_node *ni, *np;\n\n\tni = cvm_oct_of_get_child(pip, interface);\n\tif (!ni)\n\t\treturn NULL;\n\n\tnp = cvm_oct_of_get_child(ni, port);\n\tof_node_put(ni);\n\n\treturn np;\n}\n\nstatic void cvm_set_rgmii_delay(struct octeon_ethernet *priv, int iface,\n\t\t\t\tint port)\n{\n\tstruct device_node *np = priv->of_node;\n\tu32 delay_value;\n\tbool rx_delay;\n\tbool tx_delay;\n\n\t \n\trx_delay = true;\n\ttx_delay = true;\n\n\tif (!of_property_read_u32(np, \"rx-delay\", &delay_value)) {\n\t\tcvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(port, iface), delay_value);\n\t\trx_delay = delay_value > 0;\n\t}\n\tif (!of_property_read_u32(np, \"tx-delay\", &delay_value)) {\n\t\tcvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(port, iface), delay_value);\n\t\ttx_delay = delay_value > 0;\n\t}\n\n\tif (!rx_delay && !tx_delay)\n\t\tpriv->phy_mode = PHY_INTERFACE_MODE_RGMII_ID;\n\telse if (!rx_delay)\n\t\tpriv->phy_mode = PHY_INTERFACE_MODE_RGMII_RXID;\n\telse if (!tx_delay)\n\t\tpriv->phy_mode = PHY_INTERFACE_MODE_RGMII_TXID;\n\telse\n\t\tpriv->phy_mode = PHY_INTERFACE_MODE_RGMII;\n}\n\nstatic int cvm_oct_probe(struct platform_device *pdev)\n{\n\tint num_interfaces;\n\tint interface;\n\tint fau = FAU_NUM_PACKET_BUFFERS_TO_FREE;\n\tint qos;\n\tstruct device_node *pip;\n\tint mtu_overhead = ETH_HLEN + ETH_FCS_LEN;\n\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n\tmtu_overhead += VLAN_HLEN;\n#endif\n\n\tpip = pdev->dev.of_node;\n\tif (!pip) {\n\t\tpr_err(\"Error: No 'pip' in /aliases\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcvm_oct_configure_common_hw();\n\n\tcvmx_helper_initialize_packet_io_global();\n\n\tif (receive_group_order) {\n\t\tif (receive_group_order > 4)\n\t\t\treceive_group_order = 4;\n\t\tpow_receive_groups = (1 << (1 << receive_group_order)) - 1;\n\t} else {\n\t\tpow_receive_groups = BIT(pow_receive_group);\n\t}\n\n\t \n\tnum_interfaces = cvmx_helper_get_number_of_interfaces();\n\tfor (interface = 0; interface < num_interfaces; interface++) {\n\t\tint num_ports = cvmx_helper_ports_on_interface(interface);\n\t\tint port;\n\n\t\tfor (port = cvmx_helper_get_ipd_port(interface, 0);\n\t\t     port < cvmx_helper_get_ipd_port(interface, num_ports);\n\t\t     port++) {\n\t\t\tunion cvmx_pip_prt_tagx pip_prt_tagx;\n\n\t\t\tpip_prt_tagx.u64 =\n\t\t\t    cvmx_read_csr(CVMX_PIP_PRT_TAGX(port));\n\n\t\t\tif (receive_group_order) {\n\t\t\t\tint tag_mask;\n\n\t\t\t\t \n\t\t\t\tif (OCTEON_IS_MODEL(OCTEON_CN68XX))\n\t\t\t\t\tpip_prt_tagx.u64 |= 0x3ull << 44;\n\n\t\t\t\ttag_mask = ~((1 << receive_group_order) - 1);\n\t\t\t\tpip_prt_tagx.s.grptagbase\t= 0;\n\t\t\t\tpip_prt_tagx.s.grptagmask\t= tag_mask;\n\t\t\t\tpip_prt_tagx.s.grptag\t\t= 1;\n\t\t\t\tpip_prt_tagx.s.tag_mode\t\t= 0;\n\t\t\t\tpip_prt_tagx.s.inc_prt_flag\t= 1;\n\t\t\t\tpip_prt_tagx.s.ip6_dprt_flag\t= 1;\n\t\t\t\tpip_prt_tagx.s.ip4_dprt_flag\t= 1;\n\t\t\t\tpip_prt_tagx.s.ip6_sprt_flag\t= 1;\n\t\t\t\tpip_prt_tagx.s.ip4_sprt_flag\t= 1;\n\t\t\t\tpip_prt_tagx.s.ip6_dst_flag\t= 1;\n\t\t\t\tpip_prt_tagx.s.ip4_dst_flag\t= 1;\n\t\t\t\tpip_prt_tagx.s.ip6_src_flag\t= 1;\n\t\t\t\tpip_prt_tagx.s.ip4_src_flag\t= 1;\n\t\t\t\tpip_prt_tagx.s.grp\t\t= 0;\n\t\t\t} else {\n\t\t\t\tpip_prt_tagx.s.grptag\t= 0;\n\t\t\t\tpip_prt_tagx.s.grp\t= pow_receive_group;\n\t\t\t}\n\n\t\t\tcvmx_write_csr(CVMX_PIP_PRT_TAGX(port),\n\t\t\t\t       pip_prt_tagx.u64);\n\t\t}\n\t}\n\n\tcvmx_helper_ipd_and_packet_input_enable();\n\n\tmemset(cvm_oct_device, 0, sizeof(cvm_oct_device));\n\n\t \n\tcvmx_fau_atomic_write32(FAU_NUM_PACKET_BUFFERS_TO_FREE, 0);\n\n\t \n\tcvmx_fau_atomic_write32(FAU_TOTAL_TX_TO_CLEAN, 0);\n\n\tif ((pow_send_group != -1)) {\n\t\tstruct net_device *dev;\n\n\t\tdev = alloc_etherdev(sizeof(struct octeon_ethernet));\n\t\tif (dev) {\n\t\t\t \n\t\t\tstruct octeon_ethernet *priv = netdev_priv(dev);\n\n\t\t\tSET_NETDEV_DEV(dev, &pdev->dev);\n\t\t\tdev->netdev_ops = &cvm_oct_pow_netdev_ops;\n\t\t\tpriv->imode = CVMX_HELPER_INTERFACE_MODE_DISABLED;\n\t\t\tpriv->port = CVMX_PIP_NUM_INPUT_PORTS;\n\t\t\tpriv->queue = -1;\n\t\t\tstrscpy(dev->name, \"pow%d\", sizeof(dev->name));\n\t\t\tfor (qos = 0; qos < 16; qos++)\n\t\t\t\tskb_queue_head_init(&priv->tx_free_list[qos]);\n\t\t\tdev->min_mtu = VLAN_ETH_ZLEN - mtu_overhead;\n\t\t\tdev->max_mtu = OCTEON_MAX_MTU - mtu_overhead;\n\n\t\t\tif (register_netdev(dev) < 0) {\n\t\t\t\tpr_err(\"Failed to register ethernet device for POW\\n\");\n\t\t\t\tfree_netdev(dev);\n\t\t\t} else {\n\t\t\t\tcvm_oct_device[CVMX_PIP_NUM_INPUT_PORTS] = dev;\n\t\t\t\tpr_info(\"%s: POW send group %d, receive group %d\\n\",\n\t\t\t\t\tdev->name, pow_send_group,\n\t\t\t\t\tpow_receive_group);\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err(\"Failed to allocate ethernet device for POW\\n\");\n\t\t}\n\t}\n\n\tnum_interfaces = cvmx_helper_get_number_of_interfaces();\n\tfor (interface = 0; interface < num_interfaces; interface++) {\n\t\tcvmx_helper_interface_mode_t imode =\n\t\t    cvmx_helper_interface_get_mode(interface);\n\t\tint num_ports = cvmx_helper_ports_on_interface(interface);\n\t\tint port;\n\t\tint port_index;\n\n\t\tfor (port_index = 0,\n\t\t     port = cvmx_helper_get_ipd_port(interface, 0);\n\t\t     port < cvmx_helper_get_ipd_port(interface, num_ports);\n\t\t     port_index++, port++) {\n\t\t\tstruct octeon_ethernet *priv;\n\t\t\tstruct net_device *dev =\n\t\t\t    alloc_etherdev(sizeof(struct octeon_ethernet));\n\t\t\tif (!dev) {\n\t\t\t\tpr_err(\"Failed to allocate ethernet device for port %d\\n\",\n\t\t\t\t       port);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tSET_NETDEV_DEV(dev, &pdev->dev);\n\t\t\tpriv = netdev_priv(dev);\n\t\t\tpriv->netdev = dev;\n\t\t\tpriv->of_node = cvm_oct_node_for_port(pip, interface,\n\t\t\t\t\t\t\t      port_index);\n\n\t\t\tINIT_DELAYED_WORK(&priv->port_periodic_work,\n\t\t\t\t\t  cvm_oct_periodic_worker);\n\t\t\tpriv->imode = imode;\n\t\t\tpriv->port = port;\n\t\t\tpriv->queue = cvmx_pko_get_base_queue(priv->port);\n\t\t\tpriv->fau = fau - cvmx_pko_get_num_queues(port) * 4;\n\t\t\tpriv->phy_mode = PHY_INTERFACE_MODE_NA;\n\t\t\tfor (qos = 0; qos < 16; qos++)\n\t\t\t\tskb_queue_head_init(&priv->tx_free_list[qos]);\n\t\t\tfor (qos = 0; qos < cvmx_pko_get_num_queues(port);\n\t\t\t     qos++)\n\t\t\t\tcvmx_fau_atomic_write32(priv->fau + qos * 4, 0);\n\t\t\tdev->min_mtu = VLAN_ETH_ZLEN - mtu_overhead;\n\t\t\tdev->max_mtu = OCTEON_MAX_MTU - mtu_overhead;\n\n\t\t\tswitch (priv->imode) {\n\t\t\t \n\t\t\tcase CVMX_HELPER_INTERFACE_MODE_DISABLED:\n\t\t\tcase CVMX_HELPER_INTERFACE_MODE_PCIE:\n\t\t\tcase CVMX_HELPER_INTERFACE_MODE_PICMG:\n\t\t\t\tbreak;\n\n\t\t\tcase CVMX_HELPER_INTERFACE_MODE_NPI:\n\t\t\t\tdev->netdev_ops = &cvm_oct_npi_netdev_ops;\n\t\t\t\tstrscpy(dev->name, \"npi%d\", sizeof(dev->name));\n\t\t\t\tbreak;\n\n\t\t\tcase CVMX_HELPER_INTERFACE_MODE_XAUI:\n\t\t\t\tdev->netdev_ops = &cvm_oct_xaui_netdev_ops;\n\t\t\t\tstrscpy(dev->name, \"xaui%d\", sizeof(dev->name));\n\t\t\t\tbreak;\n\n\t\t\tcase CVMX_HELPER_INTERFACE_MODE_LOOP:\n\t\t\t\tdev->netdev_ops = &cvm_oct_npi_netdev_ops;\n\t\t\t\tstrscpy(dev->name, \"loop%d\", sizeof(dev->name));\n\t\t\t\tbreak;\n\n\t\t\tcase CVMX_HELPER_INTERFACE_MODE_SGMII:\n\t\t\t\tpriv->phy_mode = PHY_INTERFACE_MODE_SGMII;\n\t\t\t\tdev->netdev_ops = &cvm_oct_sgmii_netdev_ops;\n\t\t\t\tstrscpy(dev->name, \"eth%d\", sizeof(dev->name));\n\t\t\t\tbreak;\n\n\t\t\tcase CVMX_HELPER_INTERFACE_MODE_SPI:\n\t\t\t\tdev->netdev_ops = &cvm_oct_spi_netdev_ops;\n\t\t\t\tstrscpy(dev->name, \"spi%d\", sizeof(dev->name));\n\t\t\t\tbreak;\n\n\t\t\tcase CVMX_HELPER_INTERFACE_MODE_GMII:\n\t\t\t\tpriv->phy_mode = PHY_INTERFACE_MODE_GMII;\n\t\t\t\tdev->netdev_ops = &cvm_oct_rgmii_netdev_ops;\n\t\t\t\tstrscpy(dev->name, \"eth%d\", sizeof(dev->name));\n\t\t\t\tbreak;\n\n\t\t\tcase CVMX_HELPER_INTERFACE_MODE_RGMII:\n\t\t\t\tdev->netdev_ops = &cvm_oct_rgmii_netdev_ops;\n\t\t\t\tstrscpy(dev->name, \"eth%d\", sizeof(dev->name));\n\t\t\t\tcvm_set_rgmii_delay(priv, interface,\n\t\t\t\t\t\t    port_index);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (priv->of_node && of_phy_is_fixed_link(priv->of_node)) {\n\t\t\t\tif (of_phy_register_fixed_link(priv->of_node)) {\n\t\t\t\t\tnetdev_err(dev, \"Failed to register fixed link for interface %d, port %d\\n\",\n\t\t\t\t\t\t   interface, priv->port);\n\t\t\t\t\tdev->netdev_ops = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dev->netdev_ops) {\n\t\t\t\tfree_netdev(dev);\n\t\t\t} else if (register_netdev(dev) < 0) {\n\t\t\t\tpr_err(\"Failed to register ethernet device for interface %d, port %d\\n\",\n\t\t\t\t       interface, priv->port);\n\t\t\t\tfree_netdev(dev);\n\t\t\t} else {\n\t\t\t\tcvm_oct_device[priv->port] = dev;\n\t\t\t\tfau -=\n\t\t\t\t    cvmx_pko_get_num_queues(priv->port) *\n\t\t\t\t    sizeof(u32);\n\t\t\t\tschedule_delayed_work(&priv->port_periodic_work,\n\t\t\t\t\t\t      HZ);\n\t\t\t}\n\t\t}\n\t}\n\n\tcvm_oct_tx_initialize();\n\tcvm_oct_rx_initialize();\n\n\t \n\tcvm_oct_tx_poll_interval = 150 * (octeon_get_clock_rate() / 1000000);\n\n\tschedule_delayed_work(&cvm_oct_rx_refill_work, HZ);\n\n\treturn 0;\n}\n\nstatic void cvm_oct_remove(struct platform_device *pdev)\n{\n\tint port;\n\n\tcvmx_ipd_disable();\n\n\tatomic_inc_return(&cvm_oct_poll_queue_stopping);\n\tcancel_delayed_work_sync(&cvm_oct_rx_refill_work);\n\n\tcvm_oct_rx_shutdown();\n\tcvm_oct_tx_shutdown();\n\n\tcvmx_pko_disable();\n\n\t \n\tfor (port = 0; port < TOTAL_NUMBER_OF_PORTS; port++) {\n\t\tif (cvm_oct_device[port]) {\n\t\t\tstruct net_device *dev = cvm_oct_device[port];\n\t\t\tstruct octeon_ethernet *priv = netdev_priv(dev);\n\n\t\t\tcancel_delayed_work_sync(&priv->port_periodic_work);\n\n\t\t\tcvm_oct_tx_shutdown_dev(dev);\n\t\t\tunregister_netdev(dev);\n\t\t\tfree_netdev(dev);\n\t\t\tcvm_oct_device[port] = NULL;\n\t\t}\n\t}\n\n\tcvmx_pko_shutdown();\n\n\tcvmx_ipd_free_ptr();\n\n\t \n\tcvm_oct_mem_empty_fpa(CVMX_FPA_PACKET_POOL, CVMX_FPA_PACKET_POOL_SIZE,\n\t\t\t      num_packet_buffers);\n\tcvm_oct_mem_empty_fpa(CVMX_FPA_WQE_POOL, CVMX_FPA_WQE_POOL_SIZE,\n\t\t\t      num_packet_buffers);\n\tif (CVMX_FPA_OUTPUT_BUFFER_POOL != CVMX_FPA_PACKET_POOL)\n\t\tcvm_oct_mem_empty_fpa(CVMX_FPA_OUTPUT_BUFFER_POOL,\n\t\t\t\t      CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE, 128);\n}\n\nstatic const struct of_device_id cvm_oct_match[] = {\n\t{\n\t\t.compatible = \"cavium,octeon-3860-pip\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cvm_oct_match);\n\nstatic struct platform_driver cvm_oct_driver = {\n\t.probe\t\t= cvm_oct_probe,\n\t.remove_new\t= cvm_oct_remove,\n\t.driver\t\t= {\n\t\t.name\t= KBUILD_MODNAME,\n\t\t.of_match_table = cvm_oct_match,\n\t},\n};\n\nmodule_platform_driver(cvm_oct_driver);\n\nMODULE_SOFTDEP(\"pre: mdio-cavium\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Cavium Networks <support@caviumnetworks.com>\");\nMODULE_DESCRIPTION(\"Cavium Networks Octeon ethernet driver.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}