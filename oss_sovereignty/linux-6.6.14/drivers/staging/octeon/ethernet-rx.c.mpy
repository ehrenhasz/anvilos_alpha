{
  "module_name": "ethernet-rx.c",
  "hash_id": "2c7ec898b7f218888ab94601596a4dfe3f1a590dd7da2db8dd99a23d48bc53dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/octeon/ethernet-rx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/cache.h>\n#include <linux/cpumask.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ip.h>\n#include <linux/string.h>\n#include <linux/prefetch.h>\n#include <linux/ratelimit.h>\n#include <linux/smp.h>\n#include <linux/interrupt.h>\n#include <net/dst.h>\n#ifdef CONFIG_XFRM\n#include <linux/xfrm.h>\n#include <net/xfrm.h>\n#endif  \n\n#include \"octeon-ethernet.h\"\n#include \"ethernet-defines.h\"\n#include \"ethernet-mem.h\"\n#include \"ethernet-rx.h\"\n#include \"ethernet-util.h\"\n\nstatic atomic_t oct_rx_ready = ATOMIC_INIT(0);\n\nstatic struct oct_rx_group {\n\tint irq;\n\tint group;\n\tstruct napi_struct napi;\n} oct_rx_group[16];\n\n \nstatic irqreturn_t cvm_oct_do_interrupt(int irq, void *napi_id)\n{\n\t \n\tdisable_irq_nosync(irq);\n\tnapi_schedule(napi_id);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic inline int cvm_oct_check_rcv_error(struct cvmx_wqe *work)\n{\n\tint port;\n\n\tif (octeon_has_feature(OCTEON_FEATURE_PKND))\n\t\tport = work->word0.pip.cn68xx.pknd;\n\telse\n\t\tport = work->word1.cn38xx.ipprt;\n\n\tif ((work->word2.snoip.err_code == 10) && (work->word1.len <= 64))\n\t\t \n\t\treturn 0;\n\n\tif (work->word2.snoip.err_code == 5 ||\n\t    work->word2.snoip.err_code == 7) {\n\t\t \n\t\tint interface = cvmx_helper_get_interface_num(port);\n\t\tint index = cvmx_helper_get_interface_index_num(port);\n\t\tunion cvmx_gmxx_rxx_frm_ctl gmxx_rxx_frm_ctl;\n\n\t\tgmxx_rxx_frm_ctl.u64 =\n\t\t    cvmx_read_csr(CVMX_GMXX_RXX_FRM_CTL(index, interface));\n\t\tif (gmxx_rxx_frm_ctl.s.pre_chk == 0) {\n\t\t\tu8 *ptr =\n\t\t\t    cvmx_phys_to_ptr(work->packet_ptr.s.addr);\n\t\t\tint i = 0;\n\n\t\t\twhile (i < work->word1.len - 1) {\n\t\t\t\tif (*ptr != 0x55)\n\t\t\t\t\tbreak;\n\t\t\t\tptr++;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (*ptr == 0xd5) {\n\t\t\t\t \n\t\t\t\twork->packet_ptr.s.addr += i + 1;\n\t\t\t\twork->word1.len -= i + 5;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif ((*ptr & 0xf) == 0xd) {\n\t\t\t\t \n\t\t\t\twork->packet_ptr.s.addr += i;\n\t\t\t\twork->word1.len -= i + 4;\n\t\t\t\tfor (i = 0; i < work->word1.len; i++) {\n\t\t\t\t\t*ptr =\n\t\t\t\t\t    ((*ptr & 0xf0) >> 4) |\n\t\t\t\t\t    ((*(ptr + 1) & 0xf) << 4);\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tprintk_ratelimited(\"Port %d unknown preamble, packet dropped\\n\",\n\t\t\t\t\t   port);\n\t\t\tcvm_oct_free_work(work);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tprintk_ratelimited(\"Port %d receive error code %d, packet dropped\\n\",\n\t\t\t   port, work->word2.snoip.err_code);\n\tcvm_oct_free_work(work);\n\treturn 1;\n}\n\nstatic void copy_segments_to_skb(struct cvmx_wqe *work, struct sk_buff *skb)\n{\n\tint segments = work->word2.s.bufs;\n\tunion cvmx_buf_ptr segment_ptr = work->packet_ptr;\n\tint len = work->word1.len;\n\tint segment_size;\n\n\twhile (segments--) {\n\t\tunion cvmx_buf_ptr next_ptr;\n\n\t\tnext_ptr = *(union cvmx_buf_ptr *)\n\t\t\tcvmx_phys_to_ptr(segment_ptr.s.addr - 8);\n\n\t\t \n\t\tsegment_size =\n\t\t\tCVMX_FPA_PACKET_POOL_SIZE -\n\t\t\t(segment_ptr.s.addr -\n\t\t\t (((segment_ptr.s.addr >> 7) -\n\t\t\t   segment_ptr.s.back) << 7));\n\n\t\t \n\t\tif (segment_size > len)\n\t\t\tsegment_size = len;\n\n\t\t \n\t\tskb_put_data(skb, cvmx_phys_to_ptr(segment_ptr.s.addr),\n\t\t\t     segment_size);\n\t\tlen -= segment_size;\n\t\tsegment_ptr = next_ptr;\n\t}\n}\n\nstatic int cvm_oct_poll(struct oct_rx_group *rx_group, int budget)\n{\n\tconst int\tcoreid = cvmx_get_core_num();\n\tu64\told_group_mask;\n\tu64\told_scratch;\n\tint\t\trx_count = 0;\n\tint\t\tdid_work_request = 0;\n\tint\t\tpacket_not_copied;\n\n\t \n\tprefetch(cvm_oct_device);\n\n\tif (USE_ASYNC_IOBDMA) {\n\t\t \n\t\tCVMX_SYNCIOBDMA;\n\t\told_scratch = cvmx_scratch_read64(CVMX_SCR_SCRATCH);\n\t}\n\n\t \n\tif (OCTEON_IS_MODEL(OCTEON_CN68XX)) {\n\t\told_group_mask = cvmx_read_csr(CVMX_SSO_PPX_GRP_MSK(coreid));\n\t\tcvmx_write_csr(CVMX_SSO_PPX_GRP_MSK(coreid),\n\t\t\t       BIT(rx_group->group));\n\t\tcvmx_read_csr(CVMX_SSO_PPX_GRP_MSK(coreid));  \n\t} else {\n\t\told_group_mask = cvmx_read_csr(CVMX_POW_PP_GRP_MSKX(coreid));\n\t\tcvmx_write_csr(CVMX_POW_PP_GRP_MSKX(coreid),\n\t\t\t       (old_group_mask & ~0xFFFFull) |\n\t\t\t       BIT(rx_group->group));\n\t}\n\n\tif (USE_ASYNC_IOBDMA) {\n\t\tcvmx_pow_work_request_async(CVMX_SCR_SCRATCH, CVMX_POW_NO_WAIT);\n\t\tdid_work_request = 1;\n\t}\n\n\twhile (rx_count < budget) {\n\t\tstruct sk_buff *skb = NULL;\n\t\tstruct sk_buff **pskb = NULL;\n\t\tint skb_in_hw;\n\t\tstruct cvmx_wqe *work;\n\t\tint port;\n\n\t\tif (USE_ASYNC_IOBDMA && did_work_request)\n\t\t\twork = cvmx_pow_work_response_async(CVMX_SCR_SCRATCH);\n\t\telse\n\t\t\twork = cvmx_pow_work_request_sync(CVMX_POW_NO_WAIT);\n\n\t\tprefetch(work);\n\t\tdid_work_request = 0;\n\t\tif (!work) {\n\t\t\tif (OCTEON_IS_MODEL(OCTEON_CN68XX)) {\n\t\t\t\tcvmx_write_csr(CVMX_SSO_WQ_IQ_DIS,\n\t\t\t\t\t       BIT(rx_group->group));\n\t\t\t\tcvmx_write_csr(CVMX_SSO_WQ_INT,\n\t\t\t\t\t       BIT(rx_group->group));\n\t\t\t} else {\n\t\t\t\tunion cvmx_pow_wq_int wq_int;\n\n\t\t\t\twq_int.u64 = 0;\n\t\t\t\twq_int.s.iq_dis = BIT(rx_group->group);\n\t\t\t\twq_int.s.wq_int = BIT(rx_group->group);\n\t\t\t\tcvmx_write_csr(CVMX_POW_WQ_INT, wq_int.u64);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tpskb = (struct sk_buff **)\n\t\t\t(cvm_oct_get_buffer_ptr(work->packet_ptr) -\n\t\t\tsizeof(void *));\n\t\tprefetch(pskb);\n\n\t\tif (USE_ASYNC_IOBDMA && rx_count < (budget - 1)) {\n\t\t\tcvmx_pow_work_request_async_nocheck(CVMX_SCR_SCRATCH,\n\t\t\t\t\t\t\t    CVMX_POW_NO_WAIT);\n\t\t\tdid_work_request = 1;\n\t\t}\n\t\trx_count++;\n\n\t\tskb_in_hw = work->word2.s.bufs == 1;\n\t\tif (likely(skb_in_hw)) {\n\t\t\tskb = *pskb;\n\t\t\tprefetch(&skb->head);\n\t\t\tprefetch(&skb->len);\n\t\t}\n\n\t\tif (octeon_has_feature(OCTEON_FEATURE_PKND))\n\t\t\tport = work->word0.pip.cn68xx.pknd;\n\t\telse\n\t\t\tport = work->word1.cn38xx.ipprt;\n\n\t\tprefetch(cvm_oct_device[port]);\n\n\t\t \n\t\tif (unlikely(work->word2.snoip.rcv_error)) {\n\t\t\tif (cvm_oct_check_rcv_error(work))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (likely(skb_in_hw)) {\n\t\t\tskb->data = skb->head + work->packet_ptr.s.addr -\n\t\t\t\tcvmx_ptr_to_phys(skb->head);\n\t\t\tprefetch(skb->data);\n\t\t\tskb->len = work->word1.len;\n\t\t\tskb_set_tail_pointer(skb, skb->len);\n\t\t\tpacket_not_copied = 1;\n\t\t} else {\n\t\t\t \n\t\t\tskb = dev_alloc_skb(work->word1.len);\n\t\t\tif (!skb) {\n\t\t\t\tcvm_oct_free_work(work);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (unlikely(work->word2.s.bufs == 0)) {\n\t\t\t\tu8 *ptr = work->packet_data;\n\n\t\t\t\tif (likely(!work->word2.s.not_IP)) {\n\t\t\t\t\t \n\t\t\t\t\tif (work->word2.s.is_v6)\n\t\t\t\t\t\tptr += 2;\n\t\t\t\t\telse\n\t\t\t\t\t\tptr += 6;\n\t\t\t\t}\n\t\t\t\tskb_put_data(skb, ptr, work->word1.len);\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\tcopy_segments_to_skb(work, skb);\n\t\t\t}\n\t\t\tpacket_not_copied = 0;\n\t\t}\n\t\tif (likely((port < TOTAL_NUMBER_OF_PORTS) &&\n\t\t\t   cvm_oct_device[port])) {\n\t\t\tstruct net_device *dev = cvm_oct_device[port];\n\n\t\t\t \n\t\t\tif (likely(dev->flags & IFF_UP)) {\n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\tskb->dev = dev;\n\n\t\t\t\tif (unlikely(work->word2.s.not_IP ||\n\t\t\t\t\t     work->word2.s.IP_exc ||\n\t\t\t\t\t     work->word2.s.L4_error ||\n\t\t\t\t\t     !work->word2.s.tcp_or_udp))\n\t\t\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\t\telse\n\t\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\t\t\t \n\t\t\t\tif (port >= CVMX_PIP_NUM_INPUT_PORTS) {\n\t\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\t\tdev->stats.rx_bytes += skb->len;\n\t\t\t\t}\n\t\t\t\tnetif_receive_skb(skb);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tprintk_ratelimited(\"Port %d not controlled by Linux, packet dropped\\n\",\n\t\t\t\t\t   port);\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t}\n\t\t \n\t\tif (likely(packet_not_copied)) {\n\t\t\t \n\t\t\tcvmx_fau_atomic_add32(FAU_NUM_PACKET_BUFFERS_TO_FREE,\n\t\t\t\t\t      1);\n\n\t\t\tcvmx_fpa_free(work, CVMX_FPA_WQE_POOL, 1);\n\t\t} else {\n\t\t\tcvm_oct_free_work(work);\n\t\t}\n\t}\n\t \n\tif (OCTEON_IS_MODEL(OCTEON_CN68XX)) {\n\t\tcvmx_write_csr(CVMX_SSO_PPX_GRP_MSK(coreid), old_group_mask);\n\t\tcvmx_read_csr(CVMX_SSO_PPX_GRP_MSK(coreid));  \n\t} else {\n\t\tcvmx_write_csr(CVMX_POW_PP_GRP_MSKX(coreid), old_group_mask);\n\t}\n\n\tif (USE_ASYNC_IOBDMA) {\n\t\t \n\t\tcvmx_scratch_write64(CVMX_SCR_SCRATCH, old_scratch);\n\t}\n\tcvm_oct_rx_refill_pool(0);\n\n\treturn rx_count;\n}\n\n \nstatic int cvm_oct_napi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct oct_rx_group *rx_group = container_of(napi, struct oct_rx_group,\n\t\t\t\t\t\t     napi);\n\tint rx_count;\n\n\trx_count = cvm_oct_poll(rx_group, budget);\n\n\tif (rx_count < budget) {\n\t\t \n\t\tnapi_complete_done(napi, rx_count);\n\t\tenable_irq(rx_group->irq);\n\t}\n\treturn rx_count;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nvoid cvm_oct_poll_controller(struct net_device *dev)\n{\n\tint i;\n\n\tif (!atomic_read(&oct_rx_ready))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(oct_rx_group); i++) {\n\t\tif (!(pow_receive_groups & BIT(i)))\n\t\t\tcontinue;\n\n\t\tcvm_oct_poll(&oct_rx_group[i], 16);\n\t}\n}\n#endif\n\nvoid cvm_oct_rx_initialize(void)\n{\n\tint i;\n\tstruct net_device *dev_for_napi = NULL;\n\n\tfor (i = 0; i < TOTAL_NUMBER_OF_PORTS; i++) {\n\t\tif (cvm_oct_device[i]) {\n\t\t\tdev_for_napi = cvm_oct_device[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!dev_for_napi)\n\t\tpanic(\"No net_devices were allocated.\");\n\n\tfor (i = 0; i < ARRAY_SIZE(oct_rx_group); i++) {\n\t\tint ret;\n\n\t\tif (!(pow_receive_groups & BIT(i)))\n\t\t\tcontinue;\n\n\t\tnetif_napi_add_weight(dev_for_napi, &oct_rx_group[i].napi,\n\t\t\t\t      cvm_oct_napi_poll, rx_napi_weight);\n\t\tnapi_enable(&oct_rx_group[i].napi);\n\n\t\toct_rx_group[i].irq = OCTEON_IRQ_WORKQ0 + i;\n\t\toct_rx_group[i].group = i;\n\n\t\t \n\t\tret = request_irq(oct_rx_group[i].irq, cvm_oct_do_interrupt, 0,\n\t\t\t\t  \"Ethernet\", &oct_rx_group[i].napi);\n\t\tif (ret)\n\t\t\tpanic(\"Could not acquire Ethernet IRQ %d\\n\",\n\t\t\t      oct_rx_group[i].irq);\n\n\t\tdisable_irq_nosync(oct_rx_group[i].irq);\n\n\t\t \n\t\tif (OCTEON_IS_MODEL(OCTEON_CN68XX)) {\n\t\t\tunion cvmx_sso_wq_int_thrx int_thr;\n\t\t\tunion cvmx_pow_wq_int_pc int_pc;\n\n\t\t\tint_thr.u64 = 0;\n\t\t\tint_thr.s.tc_en = 1;\n\t\t\tint_thr.s.tc_thr = 1;\n\t\t\tcvmx_write_csr(CVMX_SSO_WQ_INT_THRX(i), int_thr.u64);\n\n\t\t\tint_pc.u64 = 0;\n\t\t\tint_pc.s.pc_thr = 5;\n\t\t\tcvmx_write_csr(CVMX_SSO_WQ_INT_PC, int_pc.u64);\n\t\t} else {\n\t\t\tunion cvmx_pow_wq_int_thrx int_thr;\n\t\t\tunion cvmx_pow_wq_int_pc int_pc;\n\n\t\t\tint_thr.u64 = 0;\n\t\t\tint_thr.s.tc_en = 1;\n\t\t\tint_thr.s.tc_thr = 1;\n\t\t\tcvmx_write_csr(CVMX_POW_WQ_INT_THRX(i), int_thr.u64);\n\n\t\t\tint_pc.u64 = 0;\n\t\t\tint_pc.s.pc_thr = 5;\n\t\t\tcvmx_write_csr(CVMX_POW_WQ_INT_PC, int_pc.u64);\n\t\t}\n\n\t\t \n\t\tnapi_schedule(&oct_rx_group[i].napi);\n\t}\n\tatomic_inc(&oct_rx_ready);\n}\n\nvoid cvm_oct_rx_shutdown(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(oct_rx_group); i++) {\n\t\tif (!(pow_receive_groups & BIT(i)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (OCTEON_IS_MODEL(OCTEON_CN68XX))\n\t\t\tcvmx_write_csr(CVMX_SSO_WQ_INT_THRX(i), 0);\n\t\telse\n\t\t\tcvmx_write_csr(CVMX_POW_WQ_INT_THRX(i), 0);\n\n\t\t \n\t\tfree_irq(oct_rx_group[i].irq, cvm_oct_device);\n\n\t\tnetif_napi_del(&oct_rx_group[i].napi);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}