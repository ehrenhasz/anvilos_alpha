{
  "module_name": "ethernet-spi.c",
  "hash_id": "88a3dbe9e23274eaa56717cd9d2edd9e7523f46ec1201be1cd8621fd8c638e65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/octeon/ethernet-spi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/interrupt.h>\n#include <net/dst.h>\n\n#include \"octeon-ethernet.h\"\n#include \"ethernet-defines.h\"\n#include \"ethernet-util.h\"\n\nstatic int number_spi_ports;\nstatic int need_retrain[2] = { 0, 0 };\n\nstatic void cvm_oct_spxx_int_pr(union cvmx_spxx_int_reg spx_int_reg, int index)\n{\n\tif (spx_int_reg.s.spf)\n\t\tpr_err(\"SPI%d: SRX Spi4 interface down\\n\", index);\n\tif (spx_int_reg.s.calerr)\n\t\tpr_err(\"SPI%d: SRX Spi4 Calendar table parity error\\n\", index);\n\tif (spx_int_reg.s.syncerr)\n\t\tpr_err(\"SPI%d: SRX Consecutive Spi4 DIP4 errors have exceeded SPX_ERR_CTL[ERRCNT]\\n\",\n\t\t       index);\n\tif (spx_int_reg.s.diperr)\n\t\tpr_err(\"SPI%d: SRX Spi4 DIP4 error\\n\", index);\n\tif (spx_int_reg.s.tpaovr)\n\t\tpr_err(\"SPI%d: SRX Selected port has hit TPA overflow\\n\",\n\t\t       index);\n\tif (spx_int_reg.s.rsverr)\n\t\tpr_err(\"SPI%d: SRX Spi4 reserved control word detected\\n\",\n\t\t       index);\n\tif (spx_int_reg.s.drwnng)\n\t\tpr_err(\"SPI%d: SRX Spi4 receive FIFO drowning/overflow\\n\",\n\t\t       index);\n\tif (spx_int_reg.s.clserr)\n\t\tpr_err(\"SPI%d: SRX Spi4 packet closed on non-16B alignment without EOP\\n\",\n\t\t       index);\n\tif (spx_int_reg.s.spiovr)\n\t\tpr_err(\"SPI%d: SRX Spi4 async FIFO overflow\\n\", index);\n\tif (spx_int_reg.s.abnorm)\n\t\tpr_err(\"SPI%d: SRX Abnormal packet termination (ERR bit)\\n\",\n\t\t       index);\n\tif (spx_int_reg.s.prtnxa)\n\t\tpr_err(\"SPI%d: SRX Port out of range\\n\", index);\n}\n\nstatic void cvm_oct_stxx_int_pr(union cvmx_stxx_int_reg stx_int_reg, int index)\n{\n\tif (stx_int_reg.s.syncerr)\n\t\tpr_err(\"SPI%d: STX Interface encountered a fatal error\\n\",\n\t\t       index);\n\tif (stx_int_reg.s.frmerr)\n\t\tpr_err(\"SPI%d: STX FRMCNT has exceeded STX_DIP_CNT[MAXFRM]\\n\",\n\t\t       index);\n\tif (stx_int_reg.s.unxfrm)\n\t\tpr_err(\"SPI%d: STX Unexpected framing sequence\\n\", index);\n\tif (stx_int_reg.s.nosync)\n\t\tpr_err(\"SPI%d: STX ERRCNT has exceeded STX_DIP_CNT[MAXDIP]\\n\",\n\t\t       index);\n\tif (stx_int_reg.s.diperr)\n\t\tpr_err(\"SPI%d: STX DIP2 error on the Spi4 Status channel\\n\",\n\t\t       index);\n\tif (stx_int_reg.s.datovr)\n\t\tpr_err(\"SPI%d: STX Spi4 FIFO overflow error\\n\", index);\n\tif (stx_int_reg.s.ovrbst)\n\t\tpr_err(\"SPI%d: STX Transmit packet burst too big\\n\", index);\n\tif (stx_int_reg.s.calpar1)\n\t\tpr_err(\"SPI%d: STX Calendar Table Parity Error Bank%d\\n\",\n\t\t       index, 1);\n\tif (stx_int_reg.s.calpar0)\n\t\tpr_err(\"SPI%d: STX Calendar Table Parity Error Bank%d\\n\",\n\t\t       index, 0);\n}\n\nstatic irqreturn_t cvm_oct_spi_spx_int(int index)\n{\n\tunion cvmx_spxx_int_reg spx_int_reg;\n\tunion cvmx_stxx_int_reg stx_int_reg;\n\n\tspx_int_reg.u64 = cvmx_read_csr(CVMX_SPXX_INT_REG(index));\n\tcvmx_write_csr(CVMX_SPXX_INT_REG(index), spx_int_reg.u64);\n\tif (!need_retrain[index]) {\n\t\tspx_int_reg.u64 &= cvmx_read_csr(CVMX_SPXX_INT_MSK(index));\n\t\tcvm_oct_spxx_int_pr(spx_int_reg, index);\n\t}\n\n\tstx_int_reg.u64 = cvmx_read_csr(CVMX_STXX_INT_REG(index));\n\tcvmx_write_csr(CVMX_STXX_INT_REG(index), stx_int_reg.u64);\n\tif (!need_retrain[index]) {\n\t\tstx_int_reg.u64 &= cvmx_read_csr(CVMX_STXX_INT_MSK(index));\n\t\tcvm_oct_stxx_int_pr(stx_int_reg, index);\n\t}\n\n\tcvmx_write_csr(CVMX_SPXX_INT_MSK(index), 0);\n\tcvmx_write_csr(CVMX_STXX_INT_MSK(index), 0);\n\tneed_retrain[index] = 1;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cvm_oct_spi_rml_interrupt(int cpl, void *dev_id)\n{\n\tirqreturn_t return_status = IRQ_NONE;\n\tunion cvmx_npi_rsl_int_blocks rsl_int_blocks;\n\n\t \n\trsl_int_blocks.u64 = cvmx_read_csr(CVMX_NPI_RSL_INT_BLOCKS);\n\tif (rsl_int_blocks.s.spx1)  \n\t\treturn_status = cvm_oct_spi_spx_int(1);\n\n\tif (rsl_int_blocks.s.spx0)  \n\t\treturn_status = cvm_oct_spi_spx_int(0);\n\n\treturn return_status;\n}\n\nstatic void cvm_oct_spi_enable_error_reporting(int interface)\n{\n\tunion cvmx_spxx_int_msk spxx_int_msk;\n\tunion cvmx_stxx_int_msk stxx_int_msk;\n\n\tspxx_int_msk.u64 = cvmx_read_csr(CVMX_SPXX_INT_MSK(interface));\n\tspxx_int_msk.s.calerr = 1;\n\tspxx_int_msk.s.syncerr = 1;\n\tspxx_int_msk.s.diperr = 1;\n\tspxx_int_msk.s.tpaovr = 1;\n\tspxx_int_msk.s.rsverr = 1;\n\tspxx_int_msk.s.drwnng = 1;\n\tspxx_int_msk.s.clserr = 1;\n\tspxx_int_msk.s.spiovr = 1;\n\tspxx_int_msk.s.abnorm = 1;\n\tspxx_int_msk.s.prtnxa = 1;\n\tcvmx_write_csr(CVMX_SPXX_INT_MSK(interface), spxx_int_msk.u64);\n\n\tstxx_int_msk.u64 = cvmx_read_csr(CVMX_STXX_INT_MSK(interface));\n\tstxx_int_msk.s.frmerr = 1;\n\tstxx_int_msk.s.unxfrm = 1;\n\tstxx_int_msk.s.nosync = 1;\n\tstxx_int_msk.s.diperr = 1;\n\tstxx_int_msk.s.datovr = 1;\n\tstxx_int_msk.s.ovrbst = 1;\n\tstxx_int_msk.s.calpar1 = 1;\n\tstxx_int_msk.s.calpar0 = 1;\n\tcvmx_write_csr(CVMX_STXX_INT_MSK(interface), stxx_int_msk.u64);\n}\n\nstatic void cvm_oct_spi_poll(struct net_device *dev)\n{\n\tstatic int spi4000_port;\n\tstruct octeon_ethernet *priv = netdev_priv(dev);\n\tint interface;\n\n\tfor (interface = 0; interface < 2; interface++) {\n\t\tif ((priv->port == interface * 16) && need_retrain[interface]) {\n\t\t\tif (cvmx_spi_restart_interface\n\t\t\t    (interface, CVMX_SPI_MODE_DUPLEX, 10) == 0) {\n\t\t\t\tneed_retrain[interface] = 0;\n\t\t\t\tcvm_oct_spi_enable_error_reporting(interface);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (priv->port == spi4000_port) {\n\t\t\t \n\t\t\tcvmx_spi4000_check_speed(interface, priv->port);\n\t\t\t \n\t\t\tspi4000_port--;\n\t\t\tif (spi4000_port < 0)\n\t\t\t\tspi4000_port = 10;\n\t\t}\n\t}\n}\n\nint cvm_oct_spi_init(struct net_device *dev)\n{\n\tint r;\n\tstruct octeon_ethernet *priv = netdev_priv(dev);\n\n\tif (number_spi_ports == 0) {\n\t\tr = request_irq(OCTEON_IRQ_RML, cvm_oct_spi_rml_interrupt,\n\t\t\t\tIRQF_SHARED, \"SPI\", &number_spi_ports);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tnumber_spi_ports++;\n\n\tif (priv->port == 0 || priv->port == 16) {\n\t\tcvm_oct_spi_enable_error_reporting(INTERFACE(priv->port));\n\t\tpriv->poll = cvm_oct_spi_poll;\n\t}\n\tcvm_oct_common_init(dev);\n\treturn 0;\n}\n\nvoid cvm_oct_spi_uninit(struct net_device *dev)\n{\n\tint interface;\n\n\tcvm_oct_common_uninit(dev);\n\tnumber_spi_ports--;\n\tif (number_spi_ports == 0) {\n\t\tfor (interface = 0; interface < 2; interface++) {\n\t\t\tcvmx_write_csr(CVMX_SPXX_INT_MSK(interface), 0);\n\t\t\tcvmx_write_csr(CVMX_STXX_INT_MSK(interface), 0);\n\t\t}\n\t\tfree_irq(OCTEON_IRQ_RML, &number_spi_ports);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}