{
  "module_name": "board.c",
  "hash_id": "fa96cf50ea4211a6c5718b10c54a8d2cad27684c24ee0b2ddc0ce4deedcdd768",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/board/board.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"board_staging: \"  fmt\n\n#include <linux/clkdev.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n\n#include \"board.h\"\n\nstatic struct device_node *irqc_node __initdata;\nstatic unsigned int irqc_base __initdata;\n\nstatic bool find_by_address(u64 base_address)\n{\n\tstruct device_node *dn = of_find_all_nodes(NULL);\n\tstruct resource res;\n\n\twhile (dn) {\n\t\tif (!of_address_to_resource(dn, 0, &res)) {\n\t\t\tif (res.start == base_address) {\n\t\t\t\tof_node_put(dn);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tdn = of_find_all_nodes(dn);\n\t}\n\n\treturn false;\n}\n\nbool __init board_staging_dt_node_available(const struct resource *resource,\n\t\t\t\t\t    unsigned int num_resources)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num_resources; i++) {\n\t\tconst struct resource *r = resource + i;\n\n\t\tif (resource_type(r) == IORESOURCE_MEM)\n\t\t\tif (find_by_address(r->start))\n\t\t\t\treturn true;  \n\t}\n\n\treturn false;  \n}\n\nint __init board_staging_gic_setup_xlate(const char *gic_match,\n\t\t\t\t\t unsigned int base)\n{\n\tWARN_ON(irqc_node);\n\n\tirqc_node = of_find_compatible_node(NULL, NULL, gic_match);\n\n\tWARN_ON(!irqc_node);\n\tif (!irqc_node)\n\t\treturn -ENOENT;\n\n\tirqc_base = base;\n\treturn 0;\n}\n\nstatic void __init gic_fixup_resource(struct resource *res)\n{\n\tstruct of_phandle_args irq_data;\n\tunsigned int hwirq = res->start;\n\tunsigned int virq;\n\n\tif (resource_type(res) != IORESOURCE_IRQ || !irqc_node)\n\t\treturn;\n\n\tirq_data.np = irqc_node;\n\tirq_data.args_count = 3;\n\tirq_data.args[0] = 0;\n\tirq_data.args[1] = hwirq - irqc_base;\n\tswitch (res->flags &\n\t\t(IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE |\n\t\t IORESOURCE_IRQ_LOWLEVEL | IORESOURCE_IRQ_HIGHLEVEL)) {\n\tcase IORESOURCE_IRQ_LOWEDGE:\n\t\tirq_data.args[2] = IRQ_TYPE_EDGE_FALLING;\n\t\tbreak;\n\tcase IORESOURCE_IRQ_HIGHEDGE:\n\t\tirq_data.args[2] = IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IORESOURCE_IRQ_LOWLEVEL:\n\t\tirq_data.args[2] = IRQ_TYPE_LEVEL_LOW;\n\t\tbreak;\n\tcase IORESOURCE_IRQ_HIGHLEVEL:\n\tdefault:\n\t\tirq_data.args[2] = IRQ_TYPE_LEVEL_HIGH;\n\t\tbreak;\n\t}\n\n\tvirq = irq_create_of_mapping(&irq_data);\n\tif (WARN_ON(!virq))\n\t\treturn;\n\n\tpr_debug(\"hwirq %u -> virq %u\\n\", hwirq, virq);\n\tres->start = virq;\n}\n\nvoid __init board_staging_gic_fixup_resources(struct resource *res,\n\t\t\t\t\t      unsigned int nres)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < nres; i++)\n\t\tgic_fixup_resource(&res[i]);\n}\n\nint __init board_staging_register_clock(const struct board_staging_clk *bsc)\n{\n\tint error;\n\n\tpr_debug(\"Aliasing clock %s for con_id %s dev_id %s\\n\", bsc->clk,\n\t\t bsc->con_id, bsc->dev_id);\n\terror = clk_add_alias(bsc->con_id, bsc->dev_id, bsc->clk, NULL);\n\tif (error)\n\t\tpr_err(\"Failed to alias clock %s (%d)\\n\", bsc->clk, error);\n\n\treturn error;\n}\n\n#ifdef CONFIG_PM_GENERIC_DOMAINS_OF\nstatic int board_staging_add_dev_domain(struct platform_device *pdev,\n\t\t\t\t\tconst char *domain)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct of_phandle_args pd_args;\n\tstruct device_node *np;\n\n\tnp = of_find_node_by_path(domain);\n\tif (!np) {\n\t\tpr_err(\"Cannot find domain node %s\\n\", domain);\n\t\treturn -ENOENT;\n\t}\n\n\tpd_args.np = np;\n\tpd_args.args_count = 0;\n\n\t \n\tspin_lock_init(&dev->power.lock);\n\tdev->power.early_init = true;\n\n\treturn of_genpd_add_device(&pd_args, dev);\n}\n#else\nstatic inline int board_staging_add_dev_domain(struct platform_device *pdev,\n\t\t\t\t\t       const char *domain)\n{\n\treturn 0;\n}\n#endif\n\nint __init board_staging_register_device(const struct board_staging_dev *dev)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tunsigned int i;\n\tint error;\n\n\tpr_debug(\"Trying to register device %s\\n\", pdev->name);\n\tif (board_staging_dt_node_available(pdev->resource,\n\t\t\t\t\t    pdev->num_resources)) {\n\t\tpr_warn(\"Skipping %s, already in DT\\n\", pdev->name);\n\t\treturn -EEXIST;\n\t}\n\n\tboard_staging_gic_fixup_resources(pdev->resource, pdev->num_resources);\n\n\tfor (i = 0; i < dev->nclocks; i++)\n\t\tboard_staging_register_clock(&dev->clocks[i]);\n\n\tif (dev->domain)\n\t\tboard_staging_add_dev_domain(pdev, dev->domain);\n\n\terror = platform_device_register(pdev);\n\tif (error) {\n\t\tpr_err(\"Failed to register device %s (%d)\\n\", pdev->name,\n\t\t       error);\n\t\treturn error;\n\t}\n\n\treturn error;\n}\n\nvoid __init board_staging_register_devices(const struct board_staging_dev *devs,\n\t\t\t\t\t   unsigned int ndevs)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ndevs; i++)\n\t\tboard_staging_register_device(&devs[i]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}