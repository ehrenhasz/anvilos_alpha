{
  "module_name": "fb_agm1264k-fl.c",
  "hash_id": "9aee1a8de532cf22a56eeb9e9ff54abe022db28b982cacc4124df357868f3144",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fbtft/fb_agm1264k-fl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include \"fbtft.h\"\n\n \n \n\n#define WHITE\t\t0xff\n#define BLACK\t\t0\n\n#define DRVNAME\t\t\"fb_agm1264k-fl\"\n#define WIDTH\t\t64\n#define HEIGHT\t\t64\n#define TOTALWIDTH\t(WIDTH * 2)\t  \n#define FPS\t\t\t20\n\n#define EPIN\t\tgpio.wr\n#define RS\t\t\tgpio.dc\n#define RW\t\t\tgpio.aux[2]\n#define CS0\t\t\tgpio.aux[0]\n#define CS1\t\t\tgpio.aux[1]\n\n \n#define DIFFUSING_MATRIX_WIDTH\t2\n#define DIFFUSING_MATRIX_HEIGHT\t2\n\nstatic const signed char\ndiffusing_matrix[DIFFUSING_MATRIX_WIDTH][DIFFUSING_MATRIX_HEIGHT] = {\n\t{-1, 3},\n\t{3, 2},\n};\n\nstatic const unsigned char gamma_correction_table[] = {\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6,\n6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12, 12, 13,\n13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21,\n22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 28, 28, 29, 30, 30, 31, 32,\n33, 33, 34, 35, 35, 36, 37, 38, 39, 39, 40, 41, 42, 43, 43, 44, 45,\n46, 47, 48, 49, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\n62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 73, 74, 75, 76, 77, 78, 79, 81,\n82, 83, 84, 85, 87, 88, 89, 90, 91, 93, 94, 95, 97, 98, 99, 100, 102,\n103, 105, 106, 107, 109, 110, 111, 113, 114, 116, 117, 119, 120, 121,\n123, 124, 126, 127, 129, 130, 132, 133, 135, 137, 138, 140, 141, 143,\n145, 146, 148, 149, 151, 153, 154, 156, 158, 159, 161, 163, 165, 166,\n168, 170, 172, 173, 175, 177, 179, 181, 182, 184, 186, 188, 190, 192,\n194, 196, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219,\n221, 223, 225, 227, 229, 231, 234, 236, 238, 240, 242, 244, 246, 248,\n251, 253, 255\n};\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tu8 i;\n\n\tpar->fbtftops.reset(par);\n\n\tfor (i = 0; i < 2; ++i) {\n\t\twrite_reg(par, i, 0x3f);  \n\t\twrite_reg(par, i, 0x40);  \n\t\twrite_reg(par, i, 0xb0);  \n\t\twrite_reg(par, i, 0xc0);  \n\t}\n\n\treturn 0;\n}\n\n \nstatic int verify_gpios(struct fbtft_par *par)\n{\n\tint i;\n\n\tdev_dbg(par->info->device,\n\t\t\"%s()\\n\", __func__);\n\n\tif (!par->EPIN) {\n\t\tdev_err(par->info->device,\n\t\t\t\"Missing info about 'wr' (aka E) gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < 8; ++i) {\n\t\tif (!par->gpio.db[i]) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"Missing info about 'db[%i]' gpio. Aborting.\\n\",\n\t\t\t\ti);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!par->CS0) {\n\t\tdev_err(par->info->device,\n\t\t\t\"Missing info about 'cs0' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!par->CS1) {\n\t\tdev_err(par->info->device,\n\t\t\t\"Missing info about 'cs1' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!par->RW) {\n\t\tdev_err(par->info->device,\n\t\t\t\"Missing info about 'rw' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long\nrequest_gpios_match(struct fbtft_par *par, const struct fbtft_gpio *gpio)\n{\n\tdev_dbg(par->info->device,\n\t\t\"%s('%s')\\n\", __func__, gpio->name);\n\n\tif (strcasecmp(gpio->name, \"wr\") == 0) {\n\t\t \n\t\tpar->EPIN = gpio->gpio;\n\t\treturn GPIOD_OUT_LOW;\n\t} else if (strcasecmp(gpio->name, \"cs0\") == 0) {\n\t\t \n\t\tpar->CS0 = gpio->gpio;\n\t\treturn GPIOD_OUT_HIGH;\n\t} else if (strcasecmp(gpio->name, \"cs1\") == 0) {\n\t\t \n\t\tpar->CS1 = gpio->gpio;\n\t\treturn GPIOD_OUT_HIGH;\n\t}\n\n\t \n\t \n\telse if (strcasecmp(gpio->name, \"rw\") == 0) {\n\t\tpar->RW = gpio->gpio;\n\t\treturn GPIOD_OUT_LOW;\n\t}\n\n\treturn FBTFT_GPIO_NO_MATCH;\n}\n\n \nstatic void write_reg8_bus8(struct fbtft_par *par, int len, ...)\n{\n\tva_list args;\n\tint i, ret;\n\tu8 *buf = par->buf;\n\n\tif (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {\n\t\tva_start(args, len);\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbuf[i] = (u8)va_arg(args, unsigned int);\n\n\t\tva_end(args);\n\t\tfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par, par->info->device,\n\t\t\t\t  u8, buf, len, \"%s: \", __func__);\n}\n\n\tva_start(args, len);\n\n\t*buf = (u8)va_arg(args, unsigned int);\n\n\tif (*buf > 1) {\n\t\tva_end(args);\n\t\tdev_err(par->info->device,\n\t\t\t\"Incorrect chip select request (%d)\\n\", *buf);\n\t\treturn;\n\t}\n\n\t \n\tif (*buf) {\n\t\t \n\t\tgpiod_set_value(par->CS0, 0);\n\t\tgpiod_set_value(par->CS1, 1);\n\t} else {\n\t\t \n\t\tgpiod_set_value(par->CS0, 1);\n\t\tgpiod_set_value(par->CS1, 0);\n\t}\n\n\tgpiod_set_value(par->RS, 0);  \n\tlen--;\n\n\tif (len) {\n\t\ti = len;\n\t\twhile (i--)\n\t\t\t*buf++ = (u8)va_arg(args, unsigned int);\n\t\tret = par->fbtftops.write(par, par->buf, len * (sizeof(u8)));\n\t\tif (ret < 0) {\n\t\t\tva_end(args);\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"write() failed and returned %d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tva_end(args);\n}\n\nstatic struct\n{\n\tint xs, ys_page, xe, ye_page;\n} addr_win;\n\n \nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\taddr_win.xs = xs;\n\taddr_win.ys_page = ys / 8;\n\taddr_win.xe = xe;\n\taddr_win.ye_page = ye / 8;\n}\n\nstatic void\nconstruct_line_bitmap(struct fbtft_par *par, u8 *dest, signed short *src,\n\t\t      int xs, int xe, int y)\n{\n\tint x, i;\n\n\tfor (x = xs; x < xe; ++x) {\n\t\tu8 res = 0;\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tif (src[(y * 8 + i) * par->info->var.xres + x])\n\t\t\t\tres |= 1 << i;\n#ifdef NEGATIVE\n\t\t*dest++ = res;\n#else\n\t\t*dest++ = ~res;\n#endif\n\t}\n}\n\nstatic void iterate_diffusion_matrix(u32 xres, u32 yres, int x,\n\t\t\t\t     int y, signed short *convert_buf,\n\t\t\t\t     signed short pixel, signed short error)\n{\n\tu16 i, j;\n\n\t \n\tfor (i = 0; i < DIFFUSING_MATRIX_WIDTH; ++i)\n\t\t \n\t\tfor (j = 0; j < DIFFUSING_MATRIX_HEIGHT; ++j) {\n\t\t\tsigned short *write_pos;\n\t\t\tsigned char coeff;\n\n\t\t\t \n\t\t\tif (x + i < 0 || x + i >= xres || y + j >= yres)\n\t\t\t\tcontinue;\n\t\t\twrite_pos = &convert_buf[(y + j) * xres + x + i];\n\t\t\tcoeff = diffusing_matrix[i][j];\n\t\t\tif (-1 == coeff) {\n\t\t\t\t \n\t\t\t\t*write_pos = pixel;\n\t\t\t} else {\n\t\t\t\tsigned short p = *write_pos + error * coeff;\n\n\t\t\t\tif (p > WHITE)\n\t\t\t\t\tp = WHITE;\n\t\t\t\tif (p < BLACK)\n\t\t\t\t\tp = BLACK;\n\t\t\t\t*write_pos = p;\n\t\t\t}\n\t\t}\n}\n\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu16 *vmem16 = (u16 *)par->info->screen_buffer;\n\tu8 *buf = par->txbuf.buf;\n\tint x, y;\n\tint ret = 0;\n\n\t \n\tsigned short *convert_buf = kmalloc_array(par->info->var.xres *\n\t\tpar->info->var.yres, sizeof(signed short), GFP_NOIO);\n\n\tif (!convert_buf)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (x = 0; x < par->info->var.xres; ++x)\n\t\tfor (y = 0; y < par->info->var.yres; ++y) {\n\t\t\tu16 pixel = vmem16[y *  par->info->var.xres + x];\n\t\t\tu16 b = pixel & 0x1f;\n\t\t\tu16 g = (pixel & (0x3f << 5)) >> 5;\n\t\t\tu16 r = (pixel & (0x1f << (5 + 6))) >> (5 + 6);\n\n\t\t\tpixel = (299 * r + 587 * g + 114 * b) / 200;\n\t\t\tif (pixel > 255)\n\t\t\t\tpixel = 255;\n\n\t\t\t \n\t\t\tconvert_buf[y *  par->info->var.xres + x] =\n\t\t\t\t(signed short)gamma_correction_table[pixel];\n\t\t}\n\n\t \n\tfor (x = 0; x < par->info->var.xres; ++x)\n\t\tfor (y = 0; y < par->info->var.yres; ++y) {\n\t\t\tsigned short pixel =\n\t\t\t\tconvert_buf[y *  par->info->var.xres + x];\n\t\t\tsigned short error_b = pixel - BLACK;\n\t\t\tsigned short error_w = pixel - WHITE;\n\t\t\tsigned short error;\n\n\t\t\t \n\t\t\tif (abs(error_b) >= abs(error_w)) {\n\t\t\t\t \n\t\t\t\terror = error_w;\n\t\t\t\tpixel = 0xff;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\terror = error_b;\n\t\t\t\tpixel = 0;\n\t\t\t}\n\n\t\t\terror /= 8;\n\n\t\t\titerate_diffusion_matrix(par->info->var.xres,\n\t\t\t\t\t\t par->info->var.yres,\n\t\t\t\t\t\t x, y, convert_buf,\n\t\t\t\t\t\t pixel, error);\n\t\t}\n\n\t \n\tfor (y = addr_win.ys_page; y <= addr_win.ye_page; ++y) {\n\t\t \n\t\tif (addr_win.xs < par->info->var.xres / 2) {\n\t\t\tconstruct_line_bitmap(par, buf, convert_buf,\n\t\t\t\t\t      addr_win.xs,\n\t\t\t\t\t      par->info->var.xres / 2, y);\n\n\t\t\tlen = par->info->var.xres / 2 - addr_win.xs;\n\n\t\t\t \n\t\t\twrite_reg(par, 0x00, BIT(6) | (u8)addr_win.xs);\n\t\t\twrite_reg(par, 0x00, (0x17 << 3) | (u8)y);\n\n\t\t\t \n\t\t\tgpiod_set_value(par->RS, 1);  \n\t\t\tret = par->fbtftops.write(par, buf, len);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(par->info->device,\n\t\t\t\t\t\"write failed and returned: %d\\n\",\n\t\t\t\t\tret);\n\t\t}\n\t\t \n\t\tif (addr_win.xe >= par->info->var.xres / 2) {\n\t\t\tconstruct_line_bitmap(par, buf,\n\t\t\t\t\t      convert_buf,\n\t\t\t\t\t      par->info->var.xres / 2,\n\t\t\t\t\t      addr_win.xe + 1, y);\n\n\t\t\tlen = addr_win.xe + 1 - par->info->var.xres / 2;\n\n\t\t\t \n\t\t\twrite_reg(par, 0x01, BIT(6));\n\t\t\twrite_reg(par, 0x01, (0x17 << 3) | (u8)y);\n\n\t\t\t \n\t\t\tgpiod_set_value(par->RS, 1);  \n\t\t\tpar->fbtftops.write(par, buf, len);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(par->info->device,\n\t\t\t\t\t\"write failed and returned: %d\\n\",\n\t\t\t\t\tret);\n\t\t}\n\t}\n\tkfree(convert_buf);\n\n\tgpiod_set_value(par->CS0, 0);\n\tgpiod_set_value(par->CS1, 0);\n\n\treturn ret;\n}\n\nstatic int write(struct fbtft_par *par, void *buf, size_t len)\n{\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\t  \"%s(len=%zu): \", __func__, len);\n\n\tgpiod_set_value(par->RW, 0);  \n\n\twhile (len--) {\n\t\tu8 i, data;\n\n\t\tdata = *(u8 *)buf++;\n\n\t\t \n\t\tfor (i = 0; i < 8; ++i)\n\t\t\tgpiod_set_value(par->gpio.db[i], data & (1 << i));\n\t\t \n\t\tgpiod_set_value(par->EPIN, 0);\n\t\tudelay(5);\n\t\t \n\t\tgpiod_set_value(par->EPIN, 1);\n\t\tudelay(1);\n\t}\n\n\treturn 0;\n}\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = TOTALWIDTH,\n\t.height = HEIGHT,\n\t.fps = FPS,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.verify_gpios = verify_gpios,\n\t\t.request_gpios_match = request_gpios_match,\n\t\t.write = write,\n\t\t.write_register = write_reg8_bus8,\n\t\t.write_vmem = write_vmem,\n\t},\n};\n\nFBTFT_REGISTER_DRIVER(DRVNAME, \"displaytronic,fb_agm1264k-fl\", &display);\n\nMODULE_ALIAS(\"platform:\" DRVNAME);\n\nMODULE_DESCRIPTION(\"Two KS0108 LCD controllers in AGM1264K-FL display\");\nMODULE_AUTHOR(\"ololoshka2871\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}