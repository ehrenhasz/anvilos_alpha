{
  "module_name": "fb_sh1106.c",
  "hash_id": "f87c42fd8bfda1d7b47b314580b811156b1bd2848d4f6d4aa7f66e07d195fa49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fbtft/fb_sh1106.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_sh1106\"\n#define WIDTH\t\t128\n#define HEIGHT\t\t64\n\n \nstatic int init_display(struct fbtft_par *par)\n{\n\tif (!par->info->var.xres || par->info->var.xres > WIDTH ||\n\t    !par->info->var.yres || par->info->var.yres > HEIGHT ||\n\t    par->info->var.yres % 8) {\n\t\tdev_err(par->info->device, \"Invalid screen size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (par->info->var.rotate) {\n\t\tdev_err(par->info->device, \"Display rotation not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpar->fbtftops.reset(par);\n\n\t \n\twrite_reg(par, 0xAE);\n\n\t \n\twrite_reg(par, 0xD5, 0x80);\n\n\t \n\twrite_reg(par, 0xA8, par->info->var.yres - 1);\n\n\t \n\twrite_reg(par, 0xD3, 0x00);\n\n\t \n\twrite_reg(par, 0x40 | 0x0);\n\n\t \n\t \n\twrite_reg(par, 0xA0 | 0x1);\n\n\t \n\t \n\twrite_reg(par, 0xC8);\n\n\t \n\tif (par->info->var.yres == 64)\n\t\t \n\t\twrite_reg(par, 0xDA, 0x12);\n\telse if (par->info->var.yres == 48)\n\t\t \n\t\twrite_reg(par, 0xDA, 0x12);\n\telse\n\t\t \n\t\twrite_reg(par, 0xDA, 0x02);\n\n\t \n\twrite_reg(par, 0xD9, 0xF1);\n\n\t \n\twrite_reg(par, 0xDB, 0x40);\n\n\t \n\twrite_reg(par, 0xAF);\n\n\tmsleep(150);\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n}\n\nstatic int blank(struct fbtft_par *par, bool on)\n{\n\tfbtft_par_dbg(DEBUG_BLANK, par, \"(%s=%s)\\n\",\n\t\t      __func__, on ? \"true\" : \"false\");\n\n\twrite_reg(par, on ? 0xAE : 0xAF);\n\n\treturn 0;\n}\n\n \nstatic int set_gamma(struct fbtft_par *par, u32 *curves)\n{\n\t \n\tcurves[0] &= 0xFF;\n\n\t \n\twrite_reg(par, 0x81, curves[0]);\n\n\treturn 0;\n}\n\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu16 *vmem16 = (u16 *)par->info->screen_buffer;\n\tu32 xres = par->info->var.xres;\n\tint page, page_start, page_end, x, i, ret;\n\tu8 *buf = par->txbuf.buf;\n\n\t \n\tpage_start = offset / (8 * 2 * xres);\n\tpage_end = DIV_ROUND_UP(offset + len, 8 * 2 * xres);\n\n\tfor (page = page_start; page < page_end; page++) {\n\t\t \n\t\twrite_reg(par, 0xb0 | page, 0x00 | 2, 0x10 | 0);\n\n\t\tmemset(buf, 0, xres);\n\t\tfor (x = 0; x < xres; x++)\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\tif (vmem16[(page * 8 + i) * xres + x])\n\t\t\t\t\tbuf[x] |= BIT(i);\n\n\t\t \n\t\tret = fbtft_write_buf_dc(par, buf, xres, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void write_register(struct fbtft_par *par, int len, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, len);\n\n\tfor (i = 0; i < len; i++)\n\t\tpar->buf[i] = va_arg(args, unsigned int);\n\n\t \n\tfbtft_write_buf_dc(par, par->buf, len, 0);\n\n\tva_end(args);\n}\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.txbuflen = WIDTH,\n\t.gamma_num = 1,\n\t.gamma_len = 1,\n\t \n\t.gamma = \"cd\",\n\t.fbtftops = {\n\t\t.write_vmem = write_vmem,\n\t\t.write_register = write_register,\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.blank = blank,\n\t\t.set_gamma = set_gamma,\n\t},\n};\n\nFBTFT_REGISTER_SPI_DRIVER(DRVNAME, \"sinowealth\", \"sh1106\", &display);\n\nMODULE_DESCRIPTION(\"SH1106 OLED Driver\");\nMODULE_AUTHOR(\"Heiner Kallweit\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}