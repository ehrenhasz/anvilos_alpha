{
  "module_name": "fb_ssd1331.c",
  "hash_id": "48904ab66128ad11053162d787236ca9c5a744c82d09e32ce502eff5dde97329",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fbtft/fb_ssd1331.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_ssd1331\"\n#define WIDTH\t\t96\n#define HEIGHT\t\t64\n#define GAMMA_NUM\t1\n#define GAMMA_LEN\t63\n#define DEFAULT_GAMMA\t\"0 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2 2 \" \\\n\t\t\t\"2 2 2 2 2 2 2\" \\\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tpar->fbtftops.reset(par);\n\n\twrite_reg(par, 0xae);  \n\n\t \n\tif (par->info->var.rotate == 180)\n\t\twrite_reg(par, 0xa0, 0x60 | (par->bgr << 2));\n\telse\n\t\twrite_reg(par, 0xa0, 0x72 | (par->bgr << 2));\n\n\twrite_reg(par, 0x72);  \n\twrite_reg(par, 0xa1, 0x00);  \n\twrite_reg(par, 0xa2, 0x00);  \n\twrite_reg(par, 0xa4);  \n\twrite_reg(par, 0xa8, 0x3f);  \n\twrite_reg(par, 0xad, 0x8e);  \n\t \n\twrite_reg(par, 0xb1, 0x31);  \n\twrite_reg(par, 0xb3, 0xf0);  \n\twrite_reg(par, 0x8a, 0x64);  \n\twrite_reg(par, 0x8b, 0x78);  \n\twrite_reg(par, 0x8c, 0x64);  \n\twrite_reg(par, 0xbb, 0x3a);  \n\twrite_reg(par, 0xbe, 0x3e);  \n\twrite_reg(par, 0x87, 0x06);  \n\twrite_reg(par, 0x81, 0x91);  \n\twrite_reg(par, 0x82, 0x50);  \n\twrite_reg(par, 0x83, 0x7d);  \n\twrite_reg(par, 0xaf);  \n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\twrite_reg(par, 0x15, xs, xe);\n\twrite_reg(par, 0x75, ys, ye);\n}\n\nstatic void write_reg8_bus8(struct fbtft_par *par, int len, ...)\n{\n\tva_list args;\n\tint i, ret;\n\tu8 *buf = par->buf;\n\n\tif (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {\n\t\tva_start(args, len);\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbuf[i] = (u8)va_arg(args, unsigned int);\n\t\tva_end(args);\n\t\tfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par, par->info->device,\n\t\t\t\t  u8, buf, len, \"%s: \", __func__);\n\t}\n\n\tva_start(args, len);\n\n\t*buf = (u8)va_arg(args, unsigned int);\n\tgpiod_set_value(par->gpio.dc, 0);\n\tret = par->fbtftops.write(par, par->buf, sizeof(u8));\n\tif (ret < 0) {\n\t\tva_end(args);\n\t\tdev_err(par->info->device,\n\t\t\t\"write() failed and returned %d\\n\", ret);\n\t\treturn;\n\t}\n\tlen--;\n\n\tif (len) {\n\t\ti = len;\n\t\twhile (i--)\n\t\t\t*buf++ = (u8)va_arg(args, unsigned int);\n\t\tret = par->fbtftops.write(par, par->buf, len * (sizeof(u8)));\n\t\tif (ret < 0) {\n\t\t\tva_end(args);\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"write() failed and returned %d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\t}\n\tgpiod_set_value(par->gpio.dc, 1);\n\tva_end(args);\n}\n\n \nstatic int set_gamma(struct fbtft_par *par, u32 *curves)\n{\n\tunsigned long tmp[GAMMA_NUM * GAMMA_LEN];\n\tint i, acc = 0;\n\n\tfor (i = 0; i < 63; i++) {\n\t\tif (i > 0 && curves[i] < 2) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"Illegal value in Grayscale Lookup Table at index %d. Must be greater than 1\\n\",\n\t\t\t\ti);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tacc += curves[i];\n\t\ttmp[i] = acc;\n\t\tif (acc > 180) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"Illegal value(s) in Grayscale Lookup Table. At index=%d, the accumulated value has exceeded 180\\n\",\n\t\t\t\ti);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\twrite_reg(par, 0xB8,\n\t\t  tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6],\n\t\t  tmp[7], tmp[8], tmp[9], tmp[10], tmp[11], tmp[12], tmp[13],\n\t\t  tmp[14], tmp[15], tmp[16], tmp[17], tmp[18], tmp[19], tmp[20],\n\t\t  tmp[21], tmp[22], tmp[23], tmp[24], tmp[25], tmp[26],\ttmp[27],\n\t\t  tmp[28], tmp[29], tmp[30], tmp[31], tmp[32], tmp[33], tmp[34],\n\t\t  tmp[35], tmp[36], tmp[37], tmp[38], tmp[39], tmp[40], tmp[41],\n\t\t  tmp[42], tmp[43], tmp[44], tmp[45], tmp[46], tmp[47], tmp[48],\n\t\t  tmp[49], tmp[50], tmp[51], tmp[52], tmp[53], tmp[54], tmp[55],\n\t\t  tmp[56], tmp[57], tmp[58], tmp[59], tmp[60], tmp[61],\n\t\t  tmp[62]);\n\n\treturn 0;\n}\n\nstatic int blank(struct fbtft_par *par, bool on)\n{\n\tfbtft_par_dbg(DEBUG_BLANK, par, \"(%s=%s)\\n\",\n\t\t      __func__, on ? \"true\" : \"false\");\n\tif (on)\n\t\twrite_reg(par, 0xAE);\n\telse\n\t\twrite_reg(par, 0xAF);\n\treturn 0;\n}\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.gamma_num = GAMMA_NUM,\n\t.gamma_len = GAMMA_LEN,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.write_register = write_reg8_bus8,\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_gamma = set_gamma,\n\t\t.blank = blank,\n\t},\n};\n\nFBTFT_REGISTER_DRIVER(DRVNAME, \"solomon,ssd1331\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ssd1331\");\nMODULE_ALIAS(\"platform:ssd1331\");\n\nMODULE_DESCRIPTION(\"SSD1331 OLED Driver\");\nMODULE_AUTHOR(\"Alec Smecher (adapted from SSD1351 by James Davies)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}