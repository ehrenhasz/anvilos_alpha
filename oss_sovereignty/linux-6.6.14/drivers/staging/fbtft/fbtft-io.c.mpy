{
  "module_name": "fbtft-io.c",
  "hash_id": "eddeb8567e8f08a51e98e5729d60fad7d2ceadbafdf70bf34a743682cc953d87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fbtft/fbtft-io.c",
  "human_readable_source": "\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/spi/spi.h>\n#include \"fbtft.h\"\n\nint fbtft_write_spi(struct fbtft_par *par, void *buf, size_t len)\n{\n\tstruct spi_transfer t = {\n\t\t.tx_buf = buf,\n\t\t.len = len,\n\t};\n\tstruct spi_message m;\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\t  \"%s(len=%zu): \", __func__, len);\n\n\tif (!par->spi) {\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: par->spi is unexpectedly NULL\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t, &m);\n\treturn spi_sync(par->spi, &m);\n}\nEXPORT_SYMBOL(fbtft_write_spi);\n\n \nint fbtft_write_spi_emulate_9(struct fbtft_par *par, void *buf, size_t len)\n{\n\tu16 *src = buf;\n\tu8 *dst = par->extra;\n\tsize_t size = len / 2;\n\tsize_t added = 0;\n\tint bits, i, j;\n\tu64 val, dc, tmp;\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\t  \"%s(len=%zu): \", __func__, len);\n\n\tif (!par->extra) {\n\t\tdev_err(par->info->device, \"%s: error: par->extra is NULL\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tif ((len % 8) != 0) {\n\t\tdev_err(par->info->device,\n\t\t\t\"error: len=%zu must be divisible by 8\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i += 8) {\n\t\ttmp = 0;\n\t\tbits = 63;\n\t\tfor (j = 0; j < 7; j++) {\n\t\t\tdc = (*src & 0x0100) ? 1 : 0;\n\t\t\tval = *src & 0x00FF;\n\t\t\ttmp |= dc << bits;\n\t\t\tbits -= 8;\n\t\t\ttmp |= val << bits--;\n\t\t\tsrc++;\n\t\t}\n\t\ttmp |= ((*src & 0x0100) ? 1 : 0);\n\t\t*(__be64 *)dst = cpu_to_be64(tmp);\n\t\tdst += 8;\n\t\t*dst++ = (u8)(*src++ & 0x00FF);\n\t\tadded++;\n\t}\n\n\treturn spi_write(par->spi, par->extra, size + added);\n}\nEXPORT_SYMBOL(fbtft_write_spi_emulate_9);\n\nint fbtft_read_spi(struct fbtft_par *par, void *buf, size_t len)\n{\n\tint ret;\n\tu8 txbuf[32] = { 0, };\n\tstruct spi_transfer\tt = {\n\t\t\t.speed_hz = 2000000,\n\t\t\t.rx_buf\t\t= buf,\n\t\t\t.len\t\t= len,\n\t\t};\n\tstruct spi_message\tm;\n\n\tif (!par->spi) {\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: par->spi is unexpectedly NULL\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (par->startbyte) {\n\t\tif (len > 32) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"len=%zu can't be larger than 32 when using 'startbyte'\\n\",\n\t\t\t\tlen);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttxbuf[0] = par->startbyte | 0x3;\n\t\tt.tx_buf = txbuf;\n\t\tfbtft_par_dbg_hex(DEBUG_READ, par, par->info->device, u8,\n\t\t\t\t  txbuf, len, \"%s(len=%zu) txbuf => \",\n\t\t\t\t  __func__, len);\n\t}\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t, &m);\n\tret = spi_sync(par->spi, &m);\n\tfbtft_par_dbg_hex(DEBUG_READ, par, par->info->device, u8, buf, len,\n\t\t\t  \"%s(len=%zu) buf <= \", __func__, len);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fbtft_read_spi);\n\n \nint fbtft_write_gpio8_wr(struct fbtft_par *par, void *buf, size_t len)\n{\n\tu8 data;\n\tint i;\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\tstatic u8 prev_data;\n#endif\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\t  \"%s(len=%zu): \", __func__, len);\n\n\twhile (len--) {\n\t\tdata = *(u8 *)buf;\n\n\t\t \n\t\tgpiod_set_value(par->gpio.wr, 1);\n\n\t\t \n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\t\tif (data == prev_data) {\n\t\t\tgpiod_set_value(par->gpio.wr, 1);  \n\t\t} else {\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tif ((data & 1) != (prev_data & 1))\n\t\t\t\t\tgpiod_set_value(par->gpio.db[i],\n\t\t\t\t\t\t\tdata & 1);\n\t\t\t\tdata >>= 1;\n\t\t\t\tprev_data >>= 1;\n\t\t\t}\n\t\t}\n#else\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tgpiod_set_value(par->gpio.db[i], data & 1);\n\t\t\tdata >>= 1;\n\t\t}\n#endif\n\n\t\t \n\t\tgpiod_set_value(par->gpio.wr, 0);\n\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\t\tprev_data = *(u8 *)buf;\n#endif\n\t\tbuf++;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fbtft_write_gpio8_wr);\n\nint fbtft_write_gpio16_wr(struct fbtft_par *par, void *buf, size_t len)\n{\n\tu16 data;\n\tint i;\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\tstatic u16 prev_data;\n#endif\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\t  \"%s(len=%zu): \", __func__, len);\n\n\twhile (len) {\n\t\tdata = *(u16 *)buf;\n\n\t\t \n\t\tgpiod_set_value(par->gpio.wr, 1);\n\n\t\t \n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\t\tif (data == prev_data) {\n\t\t\tgpiod_set_value(par->gpio.wr, 1);  \n\t\t} else {\n\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\tif ((data & 1) != (prev_data & 1))\n\t\t\t\t\tgpiod_set_value(par->gpio.db[i],\n\t\t\t\t\t\t\tdata & 1);\n\t\t\t\tdata >>= 1;\n\t\t\t\tprev_data >>= 1;\n\t\t\t}\n\t\t}\n#else\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tgpiod_set_value(par->gpio.db[i], data & 1);\n\t\t\tdata >>= 1;\n\t\t}\n#endif\n\n\t\t \n\t\tgpiod_set_value(par->gpio.wr, 0);\n\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\n\t\tprev_data = *(u16 *)buf;\n#endif\n\t\tbuf += 2;\n\t\tlen -= 2;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fbtft_write_gpio16_wr);\n\nint fbtft_write_gpio16_wr_latched(struct fbtft_par *par, void *buf, size_t len)\n{\n\tdev_err(par->info->device, \"%s: function not implemented\\n\", __func__);\n\treturn -1;\n}\nEXPORT_SYMBOL(fbtft_write_gpio16_wr_latched);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}