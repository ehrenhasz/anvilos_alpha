{
  "module_name": "fb_ili9325.c",
  "hash_id": "1412e4239be9f212dd255456dd17d01e95a1275ccfc37ddbe26a4710f729bca3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fbtft/fb_ili9325.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_ili9325\"\n#define WIDTH\t\t240\n#define HEIGHT\t\t320\n#define BPP\t\t16\n#define FPS\t\t20\n#define DEFAULT_GAMMA\t\"0F 00 7 2 0 0 6 5 4 1\\n\" \\\n\t\t\t\"04 16 2 7 6 3 2 1 7 7\"\n\nstatic unsigned int bt = 6;  \nmodule_param(bt, uint, 0000);\nMODULE_PARM_DESC(bt, \"Sets the factor used in the step-up circuits\");\n\nstatic unsigned int vc = 0x03;  \nmodule_param(vc, uint, 0000);\nMODULE_PARM_DESC(vc, \"Sets the ratio factor of Vci to generate the reference voltages Vci1\");\n\nstatic unsigned int vrh = 0x0d;  \nmodule_param(vrh, uint, 0000);\nMODULE_PARM_DESC(vrh, \"Set the amplifying rate (1.6 ~ 1.9) of Vci applied to output the VREG1OUT\");\n\nstatic unsigned int vdv = 0x12;  \nmodule_param(vdv, uint, 0000);\nMODULE_PARM_DESC(vdv, \"Select the factor of VREG1OUT to set the amplitude of Vcom\");\n\nstatic unsigned int vcm = 0x0a;  \nmodule_param(vcm, uint, 0000);\nMODULE_PARM_DESC(vcm, \"Set the internal VcomH voltage\");\n\n \n\nstatic int init_display(struct fbtft_par *par)\n{\n\tpar->fbtftops.reset(par);\n\n\tbt &= 0x07;\n\tvc &= 0x07;\n\tvrh &= 0x0f;\n\tvdv &= 0x1f;\n\tvcm &= 0x3f;\n\n\t \n\n\t \n\twrite_reg(par, 0x00E3, 0x3008);  \n\twrite_reg(par, 0x00E7, 0x0012);  \n\twrite_reg(par, 0x00EF, 0x1231);  \n\twrite_reg(par, 0x0001, 0x0100);  \n\twrite_reg(par, 0x0002, 0x0700);  \n\twrite_reg(par, 0x0004, 0x0000);  \n\twrite_reg(par, 0x0008, 0x0207);  \n\twrite_reg(par, 0x0009, 0x0000);  \n\twrite_reg(par, 0x000A, 0x0000);  \n\twrite_reg(par, 0x000C, 0x0000);  \n\twrite_reg(par, 0x000D, 0x0000);  \n\twrite_reg(par, 0x000F, 0x0000);  \n\n\t \n\twrite_reg(par, 0x0010, 0x0000);  \n\twrite_reg(par, 0x0011, 0x0007);  \n\twrite_reg(par, 0x0012, 0x0000);  \n\twrite_reg(par, 0x0013, 0x0000);  \n\tmdelay(200);  \n\twrite_reg(par, 0x0010,  \n\t\tBIT(12) | (bt << 8) | BIT(7) | BIT(4));\n\twrite_reg(par, 0x0011, 0x220 | vc);  \n\tmdelay(50);  \n\twrite_reg(par, 0x0012, vrh);  \n\tmdelay(50);  \n\twrite_reg(par, 0x0013, vdv << 8);  \n\twrite_reg(par, 0x0029, vcm);  \n\twrite_reg(par, 0x002B, 0x000C);  \n\tmdelay(50);  \n\twrite_reg(par, 0x0020, 0x0000);  \n\twrite_reg(par, 0x0021, 0x0000);  \n\n\t \n\twrite_reg(par, 0x0050, 0x0000);  \n\twrite_reg(par, 0x0051, 0x00EF);  \n\twrite_reg(par, 0x0052, 0x0000);  \n\twrite_reg(par, 0x0053, 0x013F);  \n\twrite_reg(par, 0x0060, 0xA700);  \n\twrite_reg(par, 0x0061, 0x0001);  \n\twrite_reg(par, 0x006A, 0x0000);  \n\n\t \n\twrite_reg(par, 0x0080, 0x0000);\n\twrite_reg(par, 0x0081, 0x0000);\n\twrite_reg(par, 0x0082, 0x0000);\n\twrite_reg(par, 0x0083, 0x0000);\n\twrite_reg(par, 0x0084, 0x0000);\n\twrite_reg(par, 0x0085, 0x0000);\n\n\t \n\twrite_reg(par, 0x0090, 0x0010);\n\twrite_reg(par, 0x0092, 0x0600);\n\twrite_reg(par, 0x0007, 0x0133);  \n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tswitch (par->info->var.rotate) {\n\t \n\t \n\tcase 0:\n\t\twrite_reg(par, 0x0020, xs);\n\t\twrite_reg(par, 0x0021, ys);\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x0020, WIDTH - 1 - xs);\n\t\twrite_reg(par, 0x0021, HEIGHT - 1 - ys);\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x0020, WIDTH - 1 - ys);\n\t\twrite_reg(par, 0x0021, xs);\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x0020, ys);\n\t\twrite_reg(par, 0x0021, HEIGHT - 1 - xs);\n\t\tbreak;\n\t}\n\twrite_reg(par, 0x0022);  \n}\n\nstatic int set_var(struct fbtft_par *par)\n{\n\tswitch (par->info->var.rotate) {\n\t \n\tcase 0:\n\t\twrite_reg(par, 0x03, 0x0030 | (par->bgr << 12));\n\t\tbreak;\n\tcase 180:\n\t\twrite_reg(par, 0x03, 0x0000 | (par->bgr << 12));\n\t\tbreak;\n\tcase 270:\n\t\twrite_reg(par, 0x03, 0x0028 | (par->bgr << 12));\n\t\tbreak;\n\tcase 90:\n\t\twrite_reg(par, 0x03, 0x0018 | (par->bgr << 12));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \n#define CURVE(num, idx)  curves[(num) * par->gamma.num_values + (idx)]\nstatic int set_gamma(struct fbtft_par *par, u32 *curves)\n{\n\tstatic const unsigned long mask[] = {\n\t\t0x1f, 0x1f, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\n\t\t0x1f, 0x1f, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\n\t};\n\tint i, j;\n\n\t \n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < 10; j++)\n\t\t\tCURVE(i, j) &= mask[i * par->gamma.num_values + j];\n\n\twrite_reg(par, 0x0030, CURVE(0, 5) << 8 | CURVE(0, 4));\n\twrite_reg(par, 0x0031, CURVE(0, 7) << 8 | CURVE(0, 6));\n\twrite_reg(par, 0x0032, CURVE(0, 9) << 8 | CURVE(0, 8));\n\twrite_reg(par, 0x0035, CURVE(0, 3) << 8 | CURVE(0, 2));\n\twrite_reg(par, 0x0036, CURVE(0, 1) << 8 | CURVE(0, 0));\n\n\twrite_reg(par, 0x0037, CURVE(1, 5) << 8 | CURVE(1, 4));\n\twrite_reg(par, 0x0038, CURVE(1, 7) << 8 | CURVE(1, 6));\n\twrite_reg(par, 0x0039, CURVE(1, 9) << 8 | CURVE(1, 8));\n\twrite_reg(par, 0x003C, CURVE(1, 3) << 8 | CURVE(1, 2));\n\twrite_reg(par, 0x003D, CURVE(1, 1) << 8 | CURVE(1, 0));\n\n\treturn 0;\n}\n\n#undef CURVE\n\nstatic struct fbtft_display display = {\n\t.regwidth = 16,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.bpp = BPP,\n\t.fps = FPS,\n\t.gamma_num = 2,\n\t.gamma_len = 10,\n\t.gamma = DEFAULT_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t\t.set_gamma = set_gamma,\n\t},\n};\n\nFBTFT_REGISTER_DRIVER(DRVNAME, \"ilitek,ili9325\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ili9325\");\nMODULE_ALIAS(\"platform:ili9325\");\n\nMODULE_DESCRIPTION(\"FB driver for the ILI9325 LCD Controller\");\nMODULE_AUTHOR(\"Noralf Tronnes\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}