{
  "module_name": "fb_st7789v.c",
  "hash_id": "370e7bfb8bb9b2e8a58c6fb8c156a77adf7181509b01109508aa91dcc094794c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fbtft/fb_st7789v.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/completion.h>\n#include <linux/module.h>\n\n#include <video/mipi_display.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME \"fb_st7789v\"\n\n#define DEFAULT_GAMMA \\\n\t\"70 2C 2E 15 10 09 48 33 53 0B 19 18 20 25\\n\" \\\n\t\"70 2C 2E 15 10 09 48 33 53 0B 19 18 20 25\"\n\n#define HSD20_IPS_GAMMA \\\n\t\"D0 05 0A 09 08 05 2E 44 45 0F 17 16 2B 33\\n\" \\\n\t\"D0 05 0A 09 08 05 2E 43 45 0F 16 16 2B 33\"\n\n#define HSD20_IPS 1\n\n \nenum st7789v_command {\n\tPORCTRL = 0xB2,\n\tGCTRL = 0xB7,\n\tVCOMS = 0xBB,\n\tVDVVRHEN = 0xC2,\n\tVRHS = 0xC3,\n\tVDVS = 0xC4,\n\tVCMOFSET = 0xC5,\n\tPWCTRL1 = 0xD0,\n\tPVGAMCTRL = 0xE0,\n\tNVGAMCTRL = 0xE1,\n};\n\n#define MADCTL_BGR BIT(3)  \n#define MADCTL_MV BIT(5)  \n#define MADCTL_MX BIT(6)  \n#define MADCTL_MY BIT(7)  \n\n \n#define PANEL_TE_TIMEOUT_MS  33\n\nstatic struct completion panel_te;  \nstatic int irq_te;  \n\nstatic irqreturn_t panel_te_handler(int irq, void *data)\n{\n\tcomplete(&panel_te);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int init_tearing_effect_line(struct fbtft_par *par)\n{\n\tstruct device *dev = par->info->device;\n\tstruct gpio_desc *te;\n\tint rc, irq;\n\n\tte = gpiod_get_optional(dev, \"te\", GPIOD_IN);\n\tif (IS_ERR(te))\n\t\treturn dev_err_probe(dev, PTR_ERR(te), \"Failed to request te GPIO\\n\");\n\n\t \n\tif (!te) {\n\t\tirq_te = 0;\n\t\treturn 0;\n\t}\n\n\tirq = gpiod_to_irq(te);\n\n\t \n\tgpiod_put(te);\n\n\tif (irq < 0)\n\t\treturn irq;\n\n\tirq_te = irq;\n\tinit_completion(&panel_te);\n\n\t \n\trc = devm_request_irq(dev, irq_te, panel_te_handler,\n\t\t\t      IRQF_TRIGGER_RISING, \"TE_GPIO\", par);\n\tif (rc)\n\t\treturn dev_err_probe(dev, rc, \"TE IRQ request failed.\\n\");\n\n\tdisable_irq_nosync(irq_te);\n\n\treturn 0;\n}\n\n \nstatic int init_display(struct fbtft_par *par)\n{\n\tint rc;\n\n\tpar->fbtftops.reset(par);\n\n\trc = init_tearing_effect_line(par);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\twrite_reg(par, MIPI_DCS_EXIT_SLEEP_MODE);\n\tmdelay(120);\n\n\t \n\twrite_reg(par, MIPI_DCS_SET_PIXEL_FORMAT, MIPI_DCS_PIXEL_FMT_16BIT);\n\tif (HSD20_IPS)\n\t\twrite_reg(par, PORCTRL, 0x05, 0x05, 0x00, 0x33, 0x33);\n\n\telse\n\t\twrite_reg(par, PORCTRL, 0x08, 0x08, 0x00, 0x22, 0x22);\n\n\t \n\tif (HSD20_IPS)\n\t\twrite_reg(par, GCTRL, 0x75);\n\telse\n\t\twrite_reg(par, GCTRL, 0x35);\n\n\t \n\twrite_reg(par, VDVVRHEN, 0x01, 0xFF);\n\n\t \n\tif (HSD20_IPS)\n\t\twrite_reg(par, VRHS, 0x13);\n\telse\n\t\twrite_reg(par, VRHS, 0x0B);\n\n\t \n\twrite_reg(par, VDVS, 0x20);\n\n\t \n\tif (HSD20_IPS)\n\t\twrite_reg(par, VCOMS, 0x22);\n\telse\n\t\twrite_reg(par, VCOMS, 0x20);\n\n\t \n\twrite_reg(par, VCMOFSET, 0x20);\n\n\t \n\twrite_reg(par, PWCTRL1, 0xA4, 0xA1);\n\n\t \n\tif (irq_te)\n\t\twrite_reg(par, MIPI_DCS_SET_TEAR_ON, 0x00);\n\n\twrite_reg(par, MIPI_DCS_SET_DISPLAY_ON);\n\n\tif (HSD20_IPS)\n\t\twrite_reg(par, MIPI_DCS_ENTER_INVERT_MODE);\n\n\treturn 0;\n}\n\n \nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tstruct device *dev = par->info->device;\n\tint ret;\n\n\tif (irq_te) {\n\t\tenable_irq(irq_te);\n\t\treinit_completion(&panel_te);\n\t\tret = wait_for_completion_timeout(&panel_te,\n\t\t\t\t\t\t  msecs_to_jiffies(PANEL_TE_TIMEOUT_MS));\n\t\tif (ret == 0)\n\t\t\tdev_err(dev, \"wait panel TE timeout\\n\");\n\n\t\tdisable_irq(irq_te);\n\t}\n\n\tswitch (par->pdata->display.buswidth) {\n\tcase 8:\n\t\tret = fbtft_write_vmem16_bus8(par, offset, len);\n\t\tbreak;\n\tcase 9:\n\t\tret = fbtft_write_vmem16_bus9(par, offset, len);\n\t\tbreak;\n\tcase 16:\n\t\tret = fbtft_write_vmem16_bus16(par, offset, len);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported buswidth %d\\n\",\n\t\t\tpar->pdata->display.buswidth);\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int set_var(struct fbtft_par *par)\n{\n\tu8 madctl_par = 0;\n\n\tif (par->bgr)\n\t\tmadctl_par |= MADCTL_BGR;\n\tswitch (par->info->var.rotate) {\n\tcase 0:\n\t\tbreak;\n\tcase 90:\n\t\tmadctl_par |= (MADCTL_MV | MADCTL_MY);\n\t\tbreak;\n\tcase 180:\n\t\tmadctl_par |= (MADCTL_MX | MADCTL_MY);\n\t\tbreak;\n\tcase 270:\n\t\tmadctl_par |= (MADCTL_MV | MADCTL_MX);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\twrite_reg(par, MIPI_DCS_SET_ADDRESS_MODE, madctl_par);\n\treturn 0;\n}\n\n \nstatic int set_gamma(struct fbtft_par *par, u32 *curves)\n{\n\tint i;\n\tint j;\n\tint c;  \n\n\t \n\tstatic const u8 gamma_par_mask[] = {\n\t\t0xFF,  \n\t\t0x3F,  \n\t\t0x3F,  \n\t\t0x1F,  \n\t\t0x1F,  \n\t\t0x3F,  \n\t\t0x7F,  \n\t\t0x77,  \n\t\t0x7F,  \n\t\t0x3F,  \n\t\t0x1F,  \n\t\t0x1F,  \n\t\t0x3F,  \n\t\t0x3F,  \n\t};\n\n\tfor (i = 0; i < par->gamma.num_curves; i++) {\n\t\tc = i * par->gamma.num_values;\n\t\tfor (j = 0; j < par->gamma.num_values; j++)\n\t\t\tcurves[c + j] &= gamma_par_mask[j];\n\t\twrite_reg(par, PVGAMCTRL + i,\n\t\t\t  curves[c + 0],  curves[c + 1],  curves[c + 2],\n\t\t\t  curves[c + 3],  curves[c + 4],  curves[c + 5],\n\t\t\t  curves[c + 6],  curves[c + 7],  curves[c + 8],\n\t\t\t  curves[c + 9],  curves[c + 10], curves[c + 11],\n\t\t\t  curves[c + 12], curves[c + 13]);\n\t}\n\treturn 0;\n}\n\n \nstatic int blank(struct fbtft_par *par, bool on)\n{\n\tif (on)\n\t\twrite_reg(par, MIPI_DCS_SET_DISPLAY_OFF);\n\telse\n\t\twrite_reg(par, MIPI_DCS_SET_DISPLAY_ON);\n\treturn 0;\n}\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = 240,\n\t.height = 320,\n\t.gamma_num = 2,\n\t.gamma_len = 14,\n\t.gamma = HSD20_IPS_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.write_vmem = write_vmem,\n\t\t.set_var = set_var,\n\t\t.set_gamma = set_gamma,\n\t\t.blank = blank,\n\t},\n};\n\nFBTFT_REGISTER_DRIVER(DRVNAME, \"sitronix,st7789v\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:st7789v\");\nMODULE_ALIAS(\"platform:st7789v\");\n\nMODULE_DESCRIPTION(\"FB driver for the ST7789V LCD Controller\");\nMODULE_AUTHOR(\"Dennis Menschel\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}