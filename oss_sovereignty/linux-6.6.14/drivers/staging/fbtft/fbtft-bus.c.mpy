{
  "module_name": "fbtft-bus.c",
  "hash_id": "dae49e40af4f01df576d25319d50c26e1a7aea11258fe16fb9b9625683a26874",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fbtft/fbtft-bus.c",
  "human_readable_source": "\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/spi/spi.h>\n#include \"fbtft.h\"\n\n \n\n#define define_fbtft_write_reg(func, buffer_type, data_type, modifier)        \\\nvoid func(struct fbtft_par *par, int len, ...)                                \\\n{                                                                             \\\n\tva_list args;                                                         \\\n\tint i, ret;                                                           \\\n\tint offset = 0;                                                       \\\n\tbuffer_type *buf = (buffer_type *)par->buf;                           \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {                    \\\n\t\tva_start(args, len);                                          \\\n\t\tfor (i = 0; i < len; i++) {                                   \\\n\t\t\tbuf[i] = modifier((data_type)va_arg(args,             \\\n\t\t\t\t\t\t\t    unsigned int));   \\\n\t\t}                                                             \\\n\t\tva_end(args);                                                 \\\n\t\tfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par,                  \\\n\t\t\t\t  par->info->device, buffer_type, buf, len,   \\\n\t\t\t\t  \"%s: \", __func__);                          \\\n\t}                                                                     \\\n\t\t\t\t\t\t\t\t\t      \\\n\tva_start(args, len);                                                  \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (par->startbyte) {                                                 \\\n\t\t*(u8 *)par->buf = par->startbyte;                             \\\n\t\tbuf = (buffer_type *)(par->buf + 1);                          \\\n\t\toffset = 1;                                                   \\\n\t}                                                                     \\\n\t\t\t\t\t\t\t\t\t      \\\n\t*buf = modifier((data_type)va_arg(args, unsigned int));               \\\n\tret = fbtft_write_buf_dc(par, par->buf, sizeof(data_type) + offset,   \\\n\t\t\t\t 0);                                          \\\n\tif (ret < 0)\t\t\t\t\t\t\t      \\\n\t\tgoto out;\t\t\t\t\t\t      \\\n\tlen--;                                                                \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (par->startbyte)                                                   \\\n\t\t*(u8 *)par->buf = par->startbyte | 0x2;                       \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (len) {                                                            \\\n\t\ti = len;                                                      \\\n\t\twhile (i--)\t\t\t\t\t\t      \\\n\t\t\t*buf++ = modifier((data_type)va_arg(args,             \\\n\t\t\t\t\t\t\t    unsigned int));   \\\n\t\tfbtft_write_buf_dc(par, par->buf,\t\t\t      \\\n\t\t\t\t   len * (sizeof(data_type) + offset), 1);    \\\n\t}                                                                     \\\nout:\t\t\t\t\t\t\t\t\t      \\\n\tva_end(args);                                                         \\\n}                                                                             \\\nEXPORT_SYMBOL(func);\n\ndefine_fbtft_write_reg(fbtft_write_reg8_bus8, u8, u8, )\ndefine_fbtft_write_reg(fbtft_write_reg16_bus8, __be16, u16, cpu_to_be16)\ndefine_fbtft_write_reg(fbtft_write_reg16_bus16, u16, u16, )\n\nvoid fbtft_write_reg8_bus9(struct fbtft_par *par, int len, ...)\n{\n\tva_list args;\n\tint i, ret;\n\tint pad = 0;\n\tu16 *buf = (u16 *)par->buf;\n\n\tif (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {\n\t\tva_start(args, len);\n\t\tfor (i = 0; i < len; i++)\n\t\t\t*(((u8 *)buf) + i) = (u8)va_arg(args, unsigned int);\n\t\tva_end(args);\n\t\tfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par,\n\t\t\t\t  par->info->device, u8, buf, len, \"%s: \",\n\t\t\t\t  __func__);\n\t}\n\tif (len <= 0)\n\t\treturn;\n\n\tif (par->spi && (par->spi->bits_per_word == 8)) {\n\t\t \n\t\tpad = (len % 4) ? 4 - (len % 4) : 0;\n\t\tfor (i = 0; i < pad; i++)\n\t\t\t*buf++ = 0x000;\n\t}\n\n\tva_start(args, len);\n\t*buf++ = (u8)va_arg(args, unsigned int);\n\ti = len - 1;\n\twhile (i--) {\n\t\t*buf = (u8)va_arg(args, unsigned int);\n\t\t*buf++ |= 0x100;  \n\t}\n\tva_end(args);\n\tret = par->fbtftops.write(par, par->buf, (len + pad) * sizeof(u16));\n\tif (ret < 0) {\n\t\tdev_err(par->info->device,\n\t\t\t\"write() failed and returned %d\\n\", ret);\n\t\treturn;\n\t}\n}\nEXPORT_SYMBOL(fbtft_write_reg8_bus9);\n\n \n\n \nint fbtft_write_vmem16_bus8(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu16 *vmem16;\n\t__be16 *txbuf16 = par->txbuf.buf;\n\tsize_t remain;\n\tsize_t to_copy;\n\tsize_t tx_array_size;\n\tint i;\n\tint ret = 0;\n\tsize_t startbyte_size = 0;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s(offset=%zu, len=%zu)\\n\",\n\t\t      __func__, offset, len);\n\n\tremain = len / 2;\n\tvmem16 = (u16 *)(par->info->screen_buffer + offset);\n\n\tgpiod_set_value(par->gpio.dc, 1);\n\n\t \n\tif (!par->txbuf.buf)\n\t\treturn par->fbtftops.write(par, vmem16, len);\n\n\t \n\ttx_array_size = par->txbuf.len / 2;\n\n\tif (par->startbyte) {\n\t\ttxbuf16 = par->txbuf.buf + 1;\n\t\ttx_array_size -= 2;\n\t\t*(u8 *)(par->txbuf.buf) = par->startbyte | 0x2;\n\t\tstartbyte_size = 1;\n\t}\n\n\twhile (remain) {\n\t\tto_copy = min(tx_array_size, remain);\n\t\tdev_dbg(par->info->device, \"to_copy=%zu, remain=%zu\\n\",\n\t\t\tto_copy, remain - to_copy);\n\n\t\tfor (i = 0; i < to_copy; i++)\n\t\t\ttxbuf16[i] = cpu_to_be16(vmem16[i]);\n\n\t\tvmem16 = vmem16 + to_copy;\n\t\tret = par->fbtftops.write(par, par->txbuf.buf,\n\t\t\t\t\t\tstartbyte_size + to_copy * 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tremain -= to_copy;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fbtft_write_vmem16_bus8);\n\n \nint fbtft_write_vmem16_bus9(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu8 *vmem8;\n\tu16 *txbuf16 = par->txbuf.buf;\n\tsize_t remain;\n\tsize_t to_copy;\n\tsize_t tx_array_size;\n\tint i;\n\tint ret = 0;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s(offset=%zu, len=%zu)\\n\",\n\t\t      __func__, offset, len);\n\n\tif (!par->txbuf.buf) {\n\t\tdev_err(par->info->device, \"%s: txbuf.buf is NULL\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tremain = len;\n\tvmem8 = par->info->screen_buffer + offset;\n\n\ttx_array_size = par->txbuf.len / 2;\n\n\twhile (remain) {\n\t\tto_copy = min(tx_array_size, remain);\n\t\tdev_dbg(par->info->device, \"to_copy=%zu, remain=%zu\\n\",\n\t\t\tto_copy, remain - to_copy);\n\n#ifdef __LITTLE_ENDIAN\n\t\tfor (i = 0; i < to_copy; i += 2) {\n\t\t\ttxbuf16[i]     = 0x0100 | vmem8[i + 1];\n\t\t\ttxbuf16[i + 1] = 0x0100 | vmem8[i];\n\t\t}\n#else\n\t\tfor (i = 0; i < to_copy; i++)\n\t\t\ttxbuf16[i]   = 0x0100 | vmem8[i];\n#endif\n\t\tvmem8 = vmem8 + to_copy;\n\t\tret = par->fbtftops.write(par, par->txbuf.buf, to_copy * 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tremain -= to_copy;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fbtft_write_vmem16_bus9);\n\nint fbtft_write_vmem8_bus8(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tdev_err(par->info->device, \"%s: function not implemented\\n\", __func__);\n\treturn -1;\n}\nEXPORT_SYMBOL(fbtft_write_vmem8_bus8);\n\n \nint fbtft_write_vmem16_bus16(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu16 *vmem16;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s(offset=%zu, len=%zu)\\n\",\n\t\t      __func__, offset, len);\n\n\tvmem16 = (u16 *)(par->info->screen_buffer + offset);\n\n\t \n\treturn fbtft_write_buf_dc(par, vmem16, len, 1);\n}\nEXPORT_SYMBOL(fbtft_write_vmem16_bus16);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}