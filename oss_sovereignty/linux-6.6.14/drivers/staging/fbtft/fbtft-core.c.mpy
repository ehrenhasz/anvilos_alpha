{
  "module_name": "fbtft-core.c",
  "hash_id": "5ed538b108730eb8c21c15e586c7d560df0c8e4578e15128eda52af10b6259e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fbtft/fbtft-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fb.h>\n#include <linux/gpio/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <linux/backlight.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/spinlock.h>\n\n#include <video/mipi_display.h>\n\n#include \"fbtft.h\"\n#include \"internal.h\"\n\nstatic unsigned long debug;\nmodule_param(debug, ulong, 0000);\nMODULE_PARM_DESC(debug, \"override device debug level\");\n\nint fbtft_write_buf_dc(struct fbtft_par *par, void *buf, size_t len, int dc)\n{\n\tint ret;\n\n\tgpiod_set_value(par->gpio.dc, dc);\n\n\tret = par->fbtftops.write(par, buf, len);\n\tif (ret < 0)\n\t\tdev_err(par->info->device,\n\t\t\t\"write() failed and returned %d\\n\", ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(fbtft_write_buf_dc);\n\nvoid fbtft_dbg_hex(const struct device *dev, int groupsize,\n\t\t   const void *buf, size_t len, const char *fmt, ...)\n{\n\tva_list args;\n\tstatic char textbuf[512];\n\tchar *text = textbuf;\n\tsize_t text_len;\n\n\tva_start(args, fmt);\n\ttext_len = vscnprintf(text, sizeof(textbuf), fmt, args);\n\tva_end(args);\n\n\thex_dump_to_buffer(buf, len, 32, groupsize, text + text_len,\n\t\t\t   512 - text_len, false);\n\n\tif (len > 32)\n\t\tdev_info(dev, \"%s ...\\n\", text);\n\telse\n\t\tdev_info(dev, \"%s\\n\", text);\n}\nEXPORT_SYMBOL(fbtft_dbg_hex);\n\nstatic int fbtft_request_one_gpio(struct fbtft_par *par,\n\t\t\t\t  const char *name, int index,\n\t\t\t\t  struct gpio_desc **gpiop)\n{\n\tstruct device *dev = par->info->device;\n\n\t*gpiop = devm_gpiod_get_index_optional(dev, name, index,\n\t\t\t\t\t       GPIOD_OUT_LOW);\n\tif (IS_ERR(*gpiop))\n\t\treturn dev_err_probe(dev, PTR_ERR(*gpiop), \"Failed to request %s GPIO\\n\", name);\n\n\tfbtft_par_dbg(DEBUG_REQUEST_GPIOS, par, \"%s: '%s' GPIO\\n\",\n\t\t      __func__, name);\n\n\treturn 0;\n}\n\nstatic int fbtft_request_gpios(struct fbtft_par *par)\n{\n\tint i;\n\tint ret;\n\n\tret = fbtft_request_one_gpio(par, \"reset\", 0, &par->gpio.reset);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, \"dc\", 0, &par->gpio.dc);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, \"rd\", 0, &par->gpio.rd);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, \"wr\", 0, &par->gpio.wr);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, \"cs\", 0, &par->gpio.cs);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, \"latch\", 0, &par->gpio.latch);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < 16; i++) {\n\t\tret = fbtft_request_one_gpio(par, \"db\", i,\n\t\t\t\t\t     &par->gpio.db[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fbtft_request_one_gpio(par, \"led\", i,\n\t\t\t\t\t     &par->gpio.led[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fbtft_request_one_gpio(par, \"aux\", i,\n\t\t\t\t\t     &par->gpio.aux[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fbtft_backlight_update_status(struct backlight_device *bd)\n{\n\tstruct fbtft_par *par = bl_get_data(bd);\n\tbool polarity = par->polarity;\n\n\tfbtft_par_dbg(DEBUG_BACKLIGHT, par,\n\t\t      \"%s: polarity=%d, power=%d, fb_blank=%d\\n\",\n\t\t      __func__, polarity, bd->props.power, bd->props.fb_blank);\n\n\tif (!backlight_is_blank(bd))\n\t\tgpiod_set_value(par->gpio.led[0], polarity);\n\telse\n\t\tgpiod_set_value(par->gpio.led[0], !polarity);\n\n\treturn 0;\n}\n\nstatic int fbtft_backlight_get_brightness(struct backlight_device *bd)\n{\n\treturn bd->props.brightness;\n}\n\nvoid fbtft_unregister_backlight(struct fbtft_par *par)\n{\n\tif (par->info->bl_dev) {\n\t\tpar->info->bl_dev->props.power = FB_BLANK_POWERDOWN;\n\t\tbacklight_update_status(par->info->bl_dev);\n\t\tbacklight_device_unregister(par->info->bl_dev);\n\t\tpar->info->bl_dev = NULL;\n\t}\n}\nEXPORT_SYMBOL(fbtft_unregister_backlight);\n\nstatic const struct backlight_ops fbtft_bl_ops = {\n\t.get_brightness\t= fbtft_backlight_get_brightness,\n\t.update_status\t= fbtft_backlight_update_status,\n};\n\nvoid fbtft_register_backlight(struct fbtft_par *par)\n{\n\tstruct backlight_device *bd;\n\tstruct backlight_properties bl_props = { 0, };\n\n\tif (!par->gpio.led[0]) {\n\t\tfbtft_par_dbg(DEBUG_BACKLIGHT, par,\n\t\t\t      \"%s(): led pin not set, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\n\tbl_props.type = BACKLIGHT_RAW;\n\t \n\tbl_props.power = FB_BLANK_POWERDOWN;\n\tif (!gpiod_get_value(par->gpio.led[0]))\n\t\tpar->polarity = true;\n\n\tbd = backlight_device_register(dev_driver_string(par->info->device),\n\t\t\t\t       par->info->device, par,\n\t\t\t\t       &fbtft_bl_ops, &bl_props);\n\tif (IS_ERR(bd)) {\n\t\tdev_err(par->info->device,\n\t\t\t\"cannot register backlight device (%ld)\\n\",\n\t\t\tPTR_ERR(bd));\n\t\treturn;\n\t}\n\tpar->info->bl_dev = bd;\n\n\tif (!par->fbtftops.unregister_backlight)\n\t\tpar->fbtftops.unregister_backlight = fbtft_unregister_backlight;\n}\nEXPORT_SYMBOL(fbtft_register_backlight);\n\nstatic void fbtft_set_addr_win(struct fbtft_par *par, int xs, int ys, int xe,\n\t\t\t       int ye)\n{\n\twrite_reg(par, MIPI_DCS_SET_COLUMN_ADDRESS,\n\t\t  (xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);\n\n\twrite_reg(par, MIPI_DCS_SET_PAGE_ADDRESS,\n\t\t  (ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);\n\n\twrite_reg(par, MIPI_DCS_WRITE_MEMORY_START);\n}\n\nstatic void fbtft_reset(struct fbtft_par *par)\n{\n\tif (!par->gpio.reset)\n\t\treturn;\n\n\tfbtft_par_dbg(DEBUG_RESET, par, \"%s()\\n\", __func__);\n\n\tgpiod_set_value_cansleep(par->gpio.reset, 1);\n\tusleep_range(20, 40);\n\tgpiod_set_value_cansleep(par->gpio.reset, 0);\n\tmsleep(120);\n\n\tgpiod_set_value_cansleep(par->gpio.cs, 1);   \n}\n\nstatic void fbtft_update_display(struct fbtft_par *par, unsigned int start_line,\n\t\t\t\t unsigned int end_line)\n{\n\tsize_t offset, len;\n\tktime_t ts_start, ts_end;\n\tlong fps, throughput;\n\tbool timeit = false;\n\tint ret = 0;\n\n\tif (unlikely(par->debug & (DEBUG_TIME_FIRST_UPDATE |\n\t\t\tDEBUG_TIME_EACH_UPDATE))) {\n\t\tif ((par->debug & DEBUG_TIME_EACH_UPDATE) ||\n\t\t    ((par->debug & DEBUG_TIME_FIRST_UPDATE) &&\n\t\t    !par->first_update_done)) {\n\t\t\tts_start = ktime_get();\n\t\t\ttimeit = true;\n\t\t}\n\t}\n\n\t \n\tif (start_line > end_line) {\n\t\tdev_warn(par->info->device,\n\t\t\t \"%s: start_line=%u is larger than end_line=%u. Shouldn't happen, will do full display update\\n\",\n\t\t\t __func__, start_line, end_line);\n\t\tstart_line = 0;\n\t\tend_line = par->info->var.yres - 1;\n\t}\n\tif (start_line > par->info->var.yres - 1 ||\n\t    end_line > par->info->var.yres - 1) {\n\t\tdev_warn(par->info->device,\n\t\t\t \"%s: start_line=%u or end_line=%u is larger than max=%d. Shouldn't happen, will do full display update\\n\",\n\t\t\t __func__, start_line,\n\t\t\t end_line, par->info->var.yres - 1);\n\t\tstart_line = 0;\n\t\tend_line = par->info->var.yres - 1;\n\t}\n\n\tfbtft_par_dbg(DEBUG_UPDATE_DISPLAY, par, \"%s(start_line=%u, end_line=%u)\\n\",\n\t\t      __func__, start_line, end_line);\n\n\tif (par->fbtftops.set_addr_win)\n\t\tpar->fbtftops.set_addr_win(par, 0, start_line,\n\t\t\t\tpar->info->var.xres - 1, end_line);\n\n\toffset = start_line * par->info->fix.line_length;\n\tlen = (end_line - start_line + 1) * par->info->fix.line_length;\n\tret = par->fbtftops.write_vmem(par, offset, len);\n\tif (ret < 0)\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: write_vmem failed to update display buffer\\n\",\n\t\t\t__func__);\n\n\tif (unlikely(timeit)) {\n\t\tts_end = ktime_get();\n\t\tif (!ktime_to_ns(par->update_time))\n\t\t\tpar->update_time = ts_start;\n\n\t\tfps = ktime_us_delta(ts_start, par->update_time);\n\t\tpar->update_time = ts_start;\n\t\tfps = fps ? 1000000 / fps : 0;\n\n\t\tthroughput = ktime_us_delta(ts_end, ts_start);\n\t\tthroughput = throughput ? (len * 1000) / throughput : 0;\n\t\tthroughput = throughput * 1000 / 1024;\n\n\t\tdev_info(par->info->device,\n\t\t\t \"Display update: %ld kB/s, fps=%ld\\n\",\n\t\t\t throughput, fps);\n\t\tpar->first_update_done = true;\n\t}\n}\n\nstatic void fbtft_mkdirty(struct fb_info *info, int y, int height)\n{\n\tstruct fbtft_par *par = info->par;\n\tstruct fb_deferred_io *fbdefio = info->fbdefio;\n\n\t \n\tif (y == -1) {\n\t\ty = 0;\n\t\theight = info->var.yres;\n\t}\n\n\t \n\tspin_lock(&par->dirty_lock);\n\tif (y < par->dirty_lines_start)\n\t\tpar->dirty_lines_start = y;\n\tif (y + height - 1 > par->dirty_lines_end)\n\t\tpar->dirty_lines_end = y + height - 1;\n\tspin_unlock(&par->dirty_lock);\n\n\t \n\tschedule_delayed_work(&info->deferred_work, fbdefio->delay);\n}\n\nstatic void fbtft_deferred_io(struct fb_info *info, struct list_head *pagereflist)\n{\n\tstruct fbtft_par *par = info->par;\n\tunsigned int dirty_lines_start, dirty_lines_end;\n\tstruct fb_deferred_io_pageref *pageref;\n\tunsigned int y_low = 0, y_high = 0;\n\tint count = 0;\n\n\tspin_lock(&par->dirty_lock);\n\tdirty_lines_start = par->dirty_lines_start;\n\tdirty_lines_end = par->dirty_lines_end;\n\t \n\tpar->dirty_lines_start = par->info->var.yres - 1;\n\tpar->dirty_lines_end = 0;\n\tspin_unlock(&par->dirty_lock);\n\n\t \n\tlist_for_each_entry(pageref, pagereflist, list) {\n\t\tcount++;\n\t\ty_low = pageref->offset / info->fix.line_length;\n\t\ty_high = (pageref->offset + PAGE_SIZE - 1) / info->fix.line_length;\n\t\tdev_dbg(info->device,\n\t\t\t\"page->index=%lu y_low=%d y_high=%d\\n\",\n\t\t\tpageref->page->index, y_low, y_high);\n\t\tif (y_high > info->var.yres - 1)\n\t\t\ty_high = info->var.yres - 1;\n\t\tif (y_low < dirty_lines_start)\n\t\t\tdirty_lines_start = y_low;\n\t\tif (y_high > dirty_lines_end)\n\t\t\tdirty_lines_end = y_high;\n\t}\n\n\tpar->fbtftops.update_display(info->par,\n\t\t\t\t\tdirty_lines_start, dirty_lines_end);\n}\n\nstatic void fbtft_fb_fillrect(struct fb_info *info,\n\t\t\t      const struct fb_fillrect *rect)\n{\n\tstruct fbtft_par *par = info->par;\n\n\tdev_dbg(info->dev,\n\t\t\"%s: dx=%d, dy=%d, width=%d, height=%d\\n\",\n\t\t__func__, rect->dx, rect->dy, rect->width, rect->height);\n\tsys_fillrect(info, rect);\n\n\tpar->fbtftops.mkdirty(info, rect->dy, rect->height);\n}\n\nstatic void fbtft_fb_copyarea(struct fb_info *info,\n\t\t\t      const struct fb_copyarea *area)\n{\n\tstruct fbtft_par *par = info->par;\n\n\tdev_dbg(info->dev,\n\t\t\"%s: dx=%d, dy=%d, width=%d, height=%d\\n\",\n\t\t__func__,  area->dx, area->dy, area->width, area->height);\n\tsys_copyarea(info, area);\n\n\tpar->fbtftops.mkdirty(info, area->dy, area->height);\n}\n\nstatic void fbtft_fb_imageblit(struct fb_info *info,\n\t\t\t       const struct fb_image *image)\n{\n\tstruct fbtft_par *par = info->par;\n\n\tdev_dbg(info->dev,\n\t\t\"%s: dx=%d, dy=%d, width=%d, height=%d\\n\",\n\t\t__func__,  image->dx, image->dy, image->width, image->height);\n\tsys_imageblit(info, image);\n\n\tpar->fbtftops.mkdirty(info, image->dy, image->height);\n}\n\nstatic ssize_t fbtft_fb_write(struct fb_info *info, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct fbtft_par *par = info->par;\n\tssize_t res;\n\n\tdev_dbg(info->dev,\n\t\t\"%s: count=%zd, ppos=%llu\\n\", __func__,  count, *ppos);\n\tres = fb_sys_write(info, buf, count, ppos);\n\n\t \n\tpar->fbtftops.mkdirty(info, -1, 0);\n\n\treturn res;\n}\n\n \nstatic unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)\n{\n\tchan &= 0xffff;\n\tchan >>= 16 - bf->length;\n\treturn chan << bf->offset;\n}\n\nstatic int fbtft_fb_setcolreg(unsigned int regno, unsigned int red,\n\t\t\t      unsigned int green, unsigned int blue,\n\t\t\t      unsigned int transp, struct fb_info *info)\n{\n\tunsigned int val;\n\tint ret = 1;\n\n\tdev_dbg(info->dev,\n\t\t\"%s(regno=%u, red=0x%X, green=0x%X, blue=0x%X, trans=0x%X)\\n\",\n\t\t__func__, regno, red, green, blue, transp);\n\n\tswitch (info->fix.visual) {\n\tcase FB_VISUAL_TRUECOLOR:\n\t\tif (regno < 16) {\n\t\t\tu32 *pal = info->pseudo_palette;\n\n\t\t\tval  = chan_to_field(red,   &info->var.red);\n\t\t\tval |= chan_to_field(green, &info->var.green);\n\t\t\tval |= chan_to_field(blue,  &info->var.blue);\n\n\t\t\tpal[regno] = val;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int fbtft_fb_blank(int blank, struct fb_info *info)\n{\n\tstruct fbtft_par *par = info->par;\n\tint ret = -EINVAL;\n\n\tdev_dbg(info->dev, \"%s(blank=%d)\\n\",\n\t\t__func__, blank);\n\n\tif (!par->fbtftops.blank)\n\t\treturn ret;\n\n\tswitch (blank) {\n\tcase FB_BLANK_POWERDOWN:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_NORMAL:\n\t\tret = par->fbtftops.blank(par, true);\n\t\tbreak;\n\tcase FB_BLANK_UNBLANK:\n\t\tret = par->fbtftops.blank(par, false);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void fbtft_merge_fbtftops(struct fbtft_ops *dst, struct fbtft_ops *src)\n{\n\tif (src->write)\n\t\tdst->write = src->write;\n\tif (src->read)\n\t\tdst->read = src->read;\n\tif (src->write_vmem)\n\t\tdst->write_vmem = src->write_vmem;\n\tif (src->write_register)\n\t\tdst->write_register = src->write_register;\n\tif (src->set_addr_win)\n\t\tdst->set_addr_win = src->set_addr_win;\n\tif (src->reset)\n\t\tdst->reset = src->reset;\n\tif (src->mkdirty)\n\t\tdst->mkdirty = src->mkdirty;\n\tif (src->update_display)\n\t\tdst->update_display = src->update_display;\n\tif (src->init_display)\n\t\tdst->init_display = src->init_display;\n\tif (src->blank)\n\t\tdst->blank = src->blank;\n\tif (src->request_gpios_match)\n\t\tdst->request_gpios_match = src->request_gpios_match;\n\tif (src->request_gpios)\n\t\tdst->request_gpios = src->request_gpios;\n\tif (src->verify_gpios)\n\t\tdst->verify_gpios = src->verify_gpios;\n\tif (src->register_backlight)\n\t\tdst->register_backlight = src->register_backlight;\n\tif (src->unregister_backlight)\n\t\tdst->unregister_backlight = src->unregister_backlight;\n\tif (src->set_var)\n\t\tdst->set_var = src->set_var;\n\tif (src->set_gamma)\n\t\tdst->set_gamma = src->set_gamma;\n}\n\n \nstruct fb_info *fbtft_framebuffer_alloc(struct fbtft_display *display,\n\t\t\t\t\tstruct device *dev,\n\t\t\t\t\tstruct fbtft_platform_data *pdata)\n{\n\tstruct fb_info *info;\n\tstruct fbtft_par *par;\n\tstruct fb_ops *fbops = NULL;\n\tstruct fb_deferred_io *fbdefio = NULL;\n\tu8 *vmem = NULL;\n\tvoid *txbuf = NULL;\n\tvoid *buf = NULL;\n\tunsigned int width;\n\tunsigned int height;\n\tint txbuflen = display->txbuflen;\n\tunsigned int bpp = display->bpp;\n\tunsigned int fps = display->fps;\n\tint vmem_size;\n\tconst s16 *init_sequence = display->init_sequence;\n\tchar *gamma = display->gamma;\n\tu32 *gamma_curves = NULL;\n\n\t \n\tif (display->gamma_num * display->gamma_len >\n\t\t\tFBTFT_GAMMA_MAX_VALUES_TOTAL) {\n\t\tdev_err(dev, \"FBTFT_GAMMA_MAX_VALUES_TOTAL=%d is exceeded\\n\",\n\t\t\tFBTFT_GAMMA_MAX_VALUES_TOTAL);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (!fps)\n\t\tfps = 20;\n\tif (!bpp)\n\t\tbpp = 16;\n\n\tif (!pdata) {\n\t\tdev_err(dev, \"platform data is missing\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tif (pdata->fps)\n\t\tfps = pdata->fps;\n\tif (pdata->txbuflen)\n\t\ttxbuflen = pdata->txbuflen;\n\tif (pdata->display.init_sequence)\n\t\tinit_sequence = pdata->display.init_sequence;\n\tif (pdata->gamma)\n\t\tgamma = pdata->gamma;\n\tif (pdata->display.debug)\n\t\tdisplay->debug = pdata->display.debug;\n\tif (pdata->display.backlight)\n\t\tdisplay->backlight = pdata->display.backlight;\n\tif (pdata->display.width)\n\t\tdisplay->width = pdata->display.width;\n\tif (pdata->display.height)\n\t\tdisplay->height = pdata->display.height;\n\tif (pdata->display.buswidth)\n\t\tdisplay->buswidth = pdata->display.buswidth;\n\tif (pdata->display.regwidth)\n\t\tdisplay->regwidth = pdata->display.regwidth;\n\n\tdisplay->debug |= debug;\n\tfbtft_expand_debug_value(&display->debug);\n\n\tswitch (pdata->rotate) {\n\tcase 90:\n\tcase 270:\n\t\twidth =  display->height;\n\t\theight = display->width;\n\t\tbreak;\n\tdefault:\n\t\twidth =  display->width;\n\t\theight = display->height;\n\t}\n\n\tvmem_size = display->width * display->height * bpp / 8;\n\tvmem = vzalloc(vmem_size);\n\tif (!vmem)\n\t\tgoto alloc_fail;\n\n\tfbops = devm_kzalloc(dev, sizeof(struct fb_ops), GFP_KERNEL);\n\tif (!fbops)\n\t\tgoto alloc_fail;\n\n\tfbdefio = devm_kzalloc(dev, sizeof(struct fb_deferred_io), GFP_KERNEL);\n\tif (!fbdefio)\n\t\tgoto alloc_fail;\n\n\tbuf = devm_kzalloc(dev, 128, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto alloc_fail;\n\n\tif (display->gamma_num && display->gamma_len) {\n\t\tgamma_curves = devm_kcalloc(dev,\n\t\t\t\t\t    display->gamma_num *\n\t\t\t\t\t    display->gamma_len,\n\t\t\t\t\t    sizeof(gamma_curves[0]),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!gamma_curves)\n\t\t\tgoto alloc_fail;\n\t}\n\n\tinfo = framebuffer_alloc(sizeof(struct fbtft_par), dev);\n\tif (!info)\n\t\tgoto alloc_fail;\n\n\tinfo->screen_buffer = vmem;\n\tinfo->fbops = fbops;\n\tinfo->fbdefio = fbdefio;\n\n\tfbops->owner        =      dev->driver->owner;\n\tfbops->fb_read      =      fb_sys_read;\n\tfbops->fb_write     =      fbtft_fb_write;\n\tfbops->fb_fillrect  =      fbtft_fb_fillrect;\n\tfbops->fb_copyarea  =      fbtft_fb_copyarea;\n\tfbops->fb_imageblit =      fbtft_fb_imageblit;\n\tfbops->fb_setcolreg =      fbtft_fb_setcolreg;\n\tfbops->fb_blank     =      fbtft_fb_blank;\n\tfbops->fb_mmap      =      fb_deferred_io_mmap;\n\n\tfbdefio->delay =            HZ / fps;\n\tfbdefio->sort_pagereflist = true;\n\tfbdefio->deferred_io =      fbtft_deferred_io;\n\n\tsnprintf(info->fix.id, sizeof(info->fix.id), \"%s\", dev->driver->name);\n\tinfo->fix.type =           FB_TYPE_PACKED_PIXELS;\n\tinfo->fix.visual =         FB_VISUAL_TRUECOLOR;\n\tinfo->fix.xpanstep =\t   0;\n\tinfo->fix.ypanstep =\t   0;\n\tinfo->fix.ywrapstep =\t   0;\n\tinfo->fix.line_length =    width * bpp / 8;\n\tinfo->fix.accel =          FB_ACCEL_NONE;\n\tinfo->fix.smem_len =       vmem_size;\n\tfb_deferred_io_init(info);\n\n\tinfo->var.rotate =         pdata->rotate;\n\tinfo->var.xres =           width;\n\tinfo->var.yres =           height;\n\tinfo->var.xres_virtual =   info->var.xres;\n\tinfo->var.yres_virtual =   info->var.yres;\n\tinfo->var.bits_per_pixel = bpp;\n\tinfo->var.nonstd =         1;\n\n\t \n\tinfo->var.red.offset =     11;\n\tinfo->var.red.length =     5;\n\tinfo->var.green.offset =   5;\n\tinfo->var.green.length =   6;\n\tinfo->var.blue.offset =    0;\n\tinfo->var.blue.length =    5;\n\tinfo->var.transp.offset =  0;\n\tinfo->var.transp.length =  0;\n\n\tinfo->flags =              FBINFO_VIRTFB;\n\n\tpar = info->par;\n\tpar->info = info;\n\tpar->pdata = pdata;\n\tpar->debug = display->debug;\n\tpar->buf = buf;\n\tspin_lock_init(&par->dirty_lock);\n\tpar->bgr = pdata->bgr;\n\tpar->startbyte = pdata->startbyte;\n\tpar->init_sequence = init_sequence;\n\tpar->gamma.curves = gamma_curves;\n\tpar->gamma.num_curves = display->gamma_num;\n\tpar->gamma.num_values = display->gamma_len;\n\tmutex_init(&par->gamma.lock);\n\tinfo->pseudo_palette = par->pseudo_palette;\n\n\tif (par->gamma.curves && gamma) {\n\t\tif (fbtft_gamma_parse_str(par, par->gamma.curves, gamma,\n\t\t\t\t\t  strlen(gamma)))\n\t\t\tgoto release_framebuf;\n\t}\n\n\t \n\tif (txbuflen == -1)\n\t\ttxbuflen = vmem_size + 2;  \n\tif (txbuflen >= vmem_size + 2)\n\t\ttxbuflen = 0;\n\n#ifdef __LITTLE_ENDIAN\n\tif ((!txbuflen) && (bpp > 8))\n\t\ttxbuflen = PAGE_SIZE;  \n#endif\n\n\tif (txbuflen > 0) {\n\t\ttxbuf = devm_kzalloc(par->info->device, txbuflen, GFP_KERNEL);\n\t\tif (!txbuf)\n\t\t\tgoto release_framebuf;\n\t\tpar->txbuf.buf = txbuf;\n\t\tpar->txbuf.len = txbuflen;\n\t}\n\n\t \n\tpar->fbtftops.write = fbtft_write_spi;\n\tpar->fbtftops.read = fbtft_read_spi;\n\tpar->fbtftops.write_vmem = fbtft_write_vmem16_bus8;\n\tpar->fbtftops.write_register = fbtft_write_reg8_bus8;\n\tpar->fbtftops.set_addr_win = fbtft_set_addr_win;\n\tpar->fbtftops.reset = fbtft_reset;\n\tpar->fbtftops.mkdirty = fbtft_mkdirty;\n\tpar->fbtftops.update_display = fbtft_update_display;\n\tif (display->backlight)\n\t\tpar->fbtftops.register_backlight = fbtft_register_backlight;\n\n\t \n\tfbtft_merge_fbtftops(&par->fbtftops, &display->fbtftops);\n\n\treturn info;\n\nrelease_framebuf:\n\tframebuffer_release(info);\n\nalloc_fail:\n\tvfree(vmem);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(fbtft_framebuffer_alloc);\n\n \nvoid fbtft_framebuffer_release(struct fb_info *info)\n{\n\tfb_deferred_io_cleanup(info);\n\tvfree(info->screen_buffer);\n\tframebuffer_release(info);\n}\nEXPORT_SYMBOL(fbtft_framebuffer_release);\n\n \nint fbtft_register_framebuffer(struct fb_info *fb_info)\n{\n\tint ret;\n\tchar text1[50] = \"\";\n\tchar text2[50] = \"\";\n\tstruct fbtft_par *par = fb_info->par;\n\tstruct spi_device *spi = par->spi;\n\n\t \n\tif (!par->fbtftops.init_display) {\n\t\tdev_err(fb_info->device, \"missing fbtftops.init_display()\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (spi)\n\t\tspi_set_drvdata(spi, fb_info);\n\tif (par->pdev)\n\t\tplatform_set_drvdata(par->pdev, fb_info);\n\n\tret = par->fbtftops.request_gpios(par);\n\tif (ret < 0)\n\t\tgoto reg_fail;\n\n\tif (par->fbtftops.verify_gpios) {\n\t\tret = par->fbtftops.verify_gpios(par);\n\t\tif (ret < 0)\n\t\t\tgoto reg_fail;\n\t}\n\n\tret = par->fbtftops.init_display(par);\n\tif (ret < 0)\n\t\tgoto reg_fail;\n\tif (par->fbtftops.set_var) {\n\t\tret = par->fbtftops.set_var(par);\n\t\tif (ret < 0)\n\t\t\tgoto reg_fail;\n\t}\n\n\t \n\tpar->fbtftops.update_display(par, 0, par->info->var.yres - 1);\n\n\tif (par->fbtftops.set_gamma && par->gamma.curves) {\n\t\tret = par->fbtftops.set_gamma(par, par->gamma.curves);\n\t\tif (ret)\n\t\t\tgoto reg_fail;\n\t}\n\n\tif (par->fbtftops.register_backlight)\n\t\tpar->fbtftops.register_backlight(par);\n\n\tret = register_framebuffer(fb_info);\n\tif (ret < 0)\n\t\tgoto reg_fail;\n\n\tfbtft_sysfs_init(par);\n\n\tif (par->txbuf.buf && par->txbuf.len >= 1024)\n\t\tsprintf(text1, \", %zu KiB buffer memory\", par->txbuf.len >> 10);\n\tif (spi)\n\t\tsprintf(text2, \", spi%d.%d at %d MHz\", spi->master->bus_num,\n\t\t\tspi_get_chipselect(spi, 0), spi->max_speed_hz / 1000000);\n\tdev_info(fb_info->dev,\n\t\t \"%s frame buffer, %dx%d, %d KiB video memory%s, fps=%lu%s\\n\",\n\t\t fb_info->fix.id, fb_info->var.xres, fb_info->var.yres,\n\t\t fb_info->fix.smem_len >> 10, text1,\n\t\t HZ / fb_info->fbdefio->delay, text2);\n\n\t \n\tif (fb_info->bl_dev) {\n\t\tfb_info->bl_dev->props.power = FB_BLANK_UNBLANK;\n\t\tfb_info->bl_dev->ops->update_status(fb_info->bl_dev);\n\t}\n\n\treturn 0;\n\nreg_fail:\n\tif (par->fbtftops.unregister_backlight)\n\t\tpar->fbtftops.unregister_backlight(par);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fbtft_register_framebuffer);\n\n \nint fbtft_unregister_framebuffer(struct fb_info *fb_info)\n{\n\tstruct fbtft_par *par = fb_info->par;\n\n\tif (par->fbtftops.unregister_backlight)\n\t\tpar->fbtftops.unregister_backlight(par);\n\tfbtft_sysfs_exit(par);\n\tunregister_framebuffer(fb_info);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fbtft_unregister_framebuffer);\n\n \nstatic int fbtft_init_display_from_property(struct fbtft_par *par)\n{\n\tstruct device *dev = par->info->device;\n\tint buf[64], count, index, i, j, ret;\n\tu32 *values;\n\tu32 val;\n\n\tcount = device_property_count_u32(dev, \"init\");\n\tif (count < 0)\n\t\treturn count;\n\tif (count == 0)\n\t\treturn -EINVAL;\n\n\tvalues = kmalloc_array(count + 1, sizeof(*values), GFP_KERNEL);\n\tif (!values)\n\t\treturn -ENOMEM;\n\n\tret = device_property_read_u32_array(dev, \"init\", values, count);\n\tif (ret)\n\t\tgoto out_free;\n\n\tpar->fbtftops.reset(par);\n\n\tindex = -1;\n\tval = values[++index];\n\n\twhile (index < count) {\n\t\tif (val & FBTFT_OF_INIT_CMD) {\n\t\t\tval &= 0xFFFF;\n\t\t\ti = 0;\n\t\t\twhile ((index < count) && !(val & 0xFFFF0000)) {\n\t\t\t\tif (i > 63) {\n\t\t\t\t\tdev_err(dev,\n\t\t\t\t\t\t\"%s: Maximum register values exceeded\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t\tbuf[i++] = val;\n\t\t\t\tval = values[++index];\n\t\t\t}\n\t\t\t \n\t\t\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t\t\t      \"init: write_register:\\n\");\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t\t\t\t      \"buf[%d] = %02X\\n\", j, buf[j]);\n\n\t\t\tpar->fbtftops.write_register(par, i,\n\t\t\t\tbuf[0], buf[1], buf[2], buf[3],\n\t\t\t\tbuf[4], buf[5], buf[6], buf[7],\n\t\t\t\tbuf[8], buf[9], buf[10], buf[11],\n\t\t\t\tbuf[12], buf[13], buf[14], buf[15],\n\t\t\t\tbuf[16], buf[17], buf[18], buf[19],\n\t\t\t\tbuf[20], buf[21], buf[22], buf[23],\n\t\t\t\tbuf[24], buf[25], buf[26], buf[27],\n\t\t\t\tbuf[28], buf[29], buf[30], buf[31],\n\t\t\t\tbuf[32], buf[33], buf[34], buf[35],\n\t\t\t\tbuf[36], buf[37], buf[38], buf[39],\n\t\t\t\tbuf[40], buf[41], buf[42], buf[43],\n\t\t\t\tbuf[44], buf[45], buf[46], buf[47],\n\t\t\t\tbuf[48], buf[49], buf[50], buf[51],\n\t\t\t\tbuf[52], buf[53], buf[54], buf[55],\n\t\t\t\tbuf[56], buf[57], buf[58], buf[59],\n\t\t\t\tbuf[60], buf[61], buf[62], buf[63]);\n\t\t} else if (val & FBTFT_OF_INIT_DELAY) {\n\t\t\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t\t\t      \"init: msleep(%u)\\n\", val & 0xFFFF);\n\t\t\tmsleep(val & 0xFFFF);\n\t\t\tval = values[++index];\n\t\t} else {\n\t\t\tdev_err(dev, \"illegal init value 0x%X\\n\", val);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\nout_free:\n\tkfree(values);\n\treturn ret;\n}\n\n \nint fbtft_init_display(struct fbtft_par *par)\n{\n\tint buf[64];\n\tint i;\n\tint j;\n\n\t \n\tif (!par->init_sequence) {\n\t\tdev_err(par->info->device,\n\t\t\t\"error: init_sequence is not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < FBTFT_MAX_INIT_SEQUENCE; i++) {\n\t\tif (par->init_sequence[i] == -3)\n\t\t\tbreak;\n\t}\n\n\tif (i == FBTFT_MAX_INIT_SEQUENCE) {\n\t\tdev_err(par->info->device,\n\t\t\t\"missing stop marker at end of init sequence\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpar->fbtftops.reset(par);\n\n\ti = 0;\n\twhile (i < FBTFT_MAX_INIT_SEQUENCE) {\n\t\tif (par->init_sequence[i] == -3) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tif (par->init_sequence[i] >= 0) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"missing delimiter at position %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (par->init_sequence[i + 1] < 0) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"missing value after delimiter %d at position %d\\n\",\n\t\t\t\tpar->init_sequence[i], i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (par->init_sequence[i]) {\n\t\tcase -1:\n\t\t\ti++;\n\n\t\t\t \n\t\t\tfor (j = 0; par->init_sequence[i + 1 + j] >= 0; j++)\n\t\t\t\t;\n\n\t\t\tfbtft_par_dbg_hex(DEBUG_INIT_DISPLAY, par, par->info->device,\n\t\t\t\t\t  s16, &par->init_sequence[i + 1], j,\n\t\t\t\t\t  \"init: write(0x%02X)\", par->init_sequence[i]);\n\n\t\t\t \n\t\t\tj = 0;\n\t\t\twhile (par->init_sequence[i] >= 0) {\n\t\t\t\tif (j > 63) {\n\t\t\t\t\tdev_err(par->info->device,\n\t\t\t\t\t\t\"%s: Maximum register values exceeded\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbuf[j++] = par->init_sequence[i++];\n\t\t\t}\n\t\t\tpar->fbtftops.write_register(par, j,\n\t\t\t\tbuf[0], buf[1], buf[2], buf[3],\n\t\t\t\tbuf[4], buf[5], buf[6], buf[7],\n\t\t\t\tbuf[8], buf[9], buf[10], buf[11],\n\t\t\t\tbuf[12], buf[13], buf[14], buf[15],\n\t\t\t\tbuf[16], buf[17], buf[18], buf[19],\n\t\t\t\tbuf[20], buf[21], buf[22], buf[23],\n\t\t\t\tbuf[24], buf[25], buf[26], buf[27],\n\t\t\t\tbuf[28], buf[29], buf[30], buf[31],\n\t\t\t\tbuf[32], buf[33], buf[34], buf[35],\n\t\t\t\tbuf[36], buf[37], buf[38], buf[39],\n\t\t\t\tbuf[40], buf[41], buf[42], buf[43],\n\t\t\t\tbuf[44], buf[45], buf[46], buf[47],\n\t\t\t\tbuf[48], buf[49], buf[50], buf[51],\n\t\t\t\tbuf[52], buf[53], buf[54], buf[55],\n\t\t\t\tbuf[56], buf[57], buf[58], buf[59],\n\t\t\t\tbuf[60], buf[61], buf[62], buf[63]);\n\t\t\tbreak;\n\t\tcase -2:\n\t\t\ti++;\n\t\t\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t\t\t      \"init: mdelay(%d)\\n\",\n\t\t\t\t      par->init_sequence[i]);\n\t\t\tmdelay(par->init_sequence[i++]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"unknown delimiter %d at position %d\\n\",\n\t\t\t\tpar->init_sequence[i], i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdev_err(par->info->device,\n\t\t\"%s: something is wrong. Shouldn't get here.\\n\", __func__);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(fbtft_init_display);\n\n \nstatic int fbtft_verify_gpios(struct fbtft_par *par)\n{\n\tstruct fbtft_platform_data *pdata = par->pdata;\n\tint i;\n\n\tfbtft_par_dbg(DEBUG_VERIFY_GPIOS, par, \"%s()\\n\", __func__);\n\n\tif (pdata->display.buswidth != 9 &&  par->startbyte == 0 &&\n\t    !par->gpio.dc) {\n\t\tdev_err(par->info->device,\n\t\t\t\"Missing info about 'dc' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!par->pdev)\n\t\treturn 0;\n\n\tif (!par->gpio.wr) {\n\t\tdev_err(par->info->device, \"Missing 'wr' gpio. Aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < pdata->display.buswidth; i++) {\n\t\tif (!par->gpio.db[i]) {\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"Missing 'db%02d' gpio. Aborting.\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic u32 fbtft_property_value(struct device *dev, const char *propname)\n{\n\tint ret;\n\tu32 val = 0;\n\n\tret = device_property_read_u32(dev, propname, &val);\n\tif (ret == 0)\n\t\tdev_info(dev, \"%s: %s = %u\\n\", __func__, propname, val);\n\n\treturn val;\n}\n\nstatic struct fbtft_platform_data *fbtft_properties_read(struct device *dev)\n{\n\tstruct fbtft_platform_data *pdata;\n\n\tif (!dev_fwnode(dev)) {\n\t\tdev_err(dev, \"Missing platform data or properties\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdata->display.width = fbtft_property_value(dev, \"width\");\n\tpdata->display.height = fbtft_property_value(dev, \"height\");\n\tpdata->display.regwidth = fbtft_property_value(dev, \"regwidth\");\n\tpdata->display.buswidth = fbtft_property_value(dev, \"buswidth\");\n\tpdata->display.backlight = fbtft_property_value(dev, \"backlight\");\n\tpdata->display.bpp = fbtft_property_value(dev, \"bpp\");\n\tpdata->display.debug = fbtft_property_value(dev, \"debug\");\n\tpdata->rotate = fbtft_property_value(dev, \"rotate\");\n\tpdata->bgr = device_property_read_bool(dev, \"bgr\");\n\tpdata->fps = fbtft_property_value(dev, \"fps\");\n\tpdata->txbuflen = fbtft_property_value(dev, \"txbuflen\");\n\tpdata->startbyte = fbtft_property_value(dev, \"startbyte\");\n\tdevice_property_read_string(dev, \"gamma\", (const char **)&pdata->gamma);\n\n\tif (device_property_present(dev, \"led-gpios\"))\n\t\tpdata->display.backlight = 1;\n\tif (device_property_present(dev, \"init\"))\n\t\tpdata->display.fbtftops.init_display =\n\t\t\tfbtft_init_display_from_property;\n\n\tpdata->display.fbtftops.request_gpios = fbtft_request_gpios;\n\n\treturn pdata;\n}\n\n \nint fbtft_probe_common(struct fbtft_display *display,\n\t\t       struct spi_device *sdev,\n\t\t       struct platform_device *pdev)\n{\n\tstruct device *dev;\n\tstruct fb_info *info;\n\tstruct fbtft_par *par;\n\tstruct fbtft_platform_data *pdata;\n\tint ret;\n\n\tif (sdev)\n\t\tdev = &sdev->dev;\n\telse\n\t\tdev = &pdev->dev;\n\n\tif (unlikely(display->debug & DEBUG_DRIVER_INIT_FUNCTIONS))\n\t\tdev_info(dev, \"%s()\\n\", __func__);\n\n\tpdata = dev->platform_data;\n\tif (!pdata) {\n\t\tpdata = fbtft_properties_read(dev);\n\t\tif (IS_ERR(pdata))\n\t\t\treturn PTR_ERR(pdata);\n\t}\n\n\tinfo = fbtft_framebuffer_alloc(display, dev, pdata);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\tpar->spi = sdev;\n\tpar->pdev = pdev;\n\n\tif (display->buswidth == 0) {\n\t\tdev_err(dev, \"buswidth is not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (display->regwidth == 8 && display->buswidth == 8)\n\t\tpar->fbtftops.write_register = fbtft_write_reg8_bus8;\n\telse if (display->regwidth == 8 && display->buswidth == 9 && par->spi)\n\t\tpar->fbtftops.write_register = fbtft_write_reg8_bus9;\n\telse if (display->regwidth == 16 && display->buswidth == 8)\n\t\tpar->fbtftops.write_register = fbtft_write_reg16_bus8;\n\telse if (display->regwidth == 16 && display->buswidth == 16)\n\t\tpar->fbtftops.write_register = fbtft_write_reg16_bus16;\n\telse\n\t\tdev_warn(dev,\n\t\t\t \"no default functions for regwidth=%d and buswidth=%d\\n\",\n\t\t\t display->regwidth, display->buswidth);\n\n\t \n\tif (display->buswidth == 8)\n\t\tpar->fbtftops.write_vmem = fbtft_write_vmem16_bus8;\n\telse if (display->buswidth == 9)\n\t\tpar->fbtftops.write_vmem = fbtft_write_vmem16_bus9;\n\telse if (display->buswidth == 16)\n\t\tpar->fbtftops.write_vmem = fbtft_write_vmem16_bus16;\n\n\t \n\tif (par->pdev) {\n\t\tif (display->buswidth == 8)\n\t\t\tpar->fbtftops.write = fbtft_write_gpio8_wr;\n\t\telse if (display->buswidth == 16)\n\t\t\tpar->fbtftops.write = fbtft_write_gpio16_wr;\n\t}\n\n\t \n\tif (par->spi && display->buswidth == 9) {\n\t\tif (par->spi->master->bits_per_word_mask & SPI_BPW_MASK(9)) {\n\t\t\tpar->spi->bits_per_word = 9;\n\t\t} else {\n\t\t\tdev_warn(&par->spi->dev,\n\t\t\t\t \"9-bit SPI not available, emulating using 8-bit.\\n\");\n\t\t\t \n\t\t\tpar->extra = devm_kzalloc(par->info->device,\n\t\t\t\t\t\t  par->txbuf.len +\n\t\t\t\t\t\t  (par->txbuf.len / 8) + 8,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!par->extra) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_release;\n\t\t\t}\n\t\t\tpar->fbtftops.write = fbtft_write_spi_emulate_9;\n\t\t}\n\t}\n\n\tif (!par->fbtftops.verify_gpios)\n\t\tpar->fbtftops.verify_gpios = fbtft_verify_gpios;\n\n\t \n\tfbtft_merge_fbtftops(&par->fbtftops, &display->fbtftops);\n\n\t \n\tif (par->init_sequence)\n\t\tpar->fbtftops.init_display = fbtft_init_display;\n\n\t \n\tfbtft_merge_fbtftops(&par->fbtftops, &pdata->display.fbtftops);\n\n\tret = fbtft_register_framebuffer(info);\n\tif (ret < 0)\n\t\tgoto out_release;\n\n\treturn 0;\n\nout_release:\n\tfbtft_framebuffer_release(info);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fbtft_probe_common);\n\n \nvoid fbtft_remove_common(struct device *dev, struct fb_info *info)\n{\n\tstruct fbtft_par *par;\n\n\tpar = info->par;\n\tif (par)\n\t\tfbtft_par_dbg(DEBUG_DRIVER_INIT_FUNCTIONS, par,\n\t\t\t      \"%s()\\n\", __func__);\n\tfbtft_unregister_framebuffer(info);\n\tfbtft_framebuffer_release(info);\n}\nEXPORT_SYMBOL(fbtft_remove_common);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}