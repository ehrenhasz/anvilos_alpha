{
  "module_name": "fb_ra8875.c",
  "hash_id": "9b5ce594e07e52da12ecd16c42f4961b751a9c4a76d460e4dd4bbb4258d79a3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fbtft/fb_ra8875.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n\n#include <linux/gpio/consumer.h>\n#include \"fbtft.h\"\n\n#define DRVNAME \"fb_ra8875\"\n\nstatic int write_spi(struct fbtft_par *par, void *buf, size_t len)\n{\n\tstruct spi_transfer t = {\n\t\t.tx_buf = buf,\n\t\t.len = len,\n\t\t.speed_hz = 1000000,\n\t};\n\tstruct spi_message m;\n\n\tfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\n\t\t\t  \"%s(len=%zu): \", __func__, len);\n\n\tif (!par->spi) {\n\t\tdev_err(par->info->device,\n\t\t\t\"%s: par->spi is unexpectedly NULL\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t, &m);\n\treturn spi_sync(par->spi, &m);\n}\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tgpiod_set_value(par->gpio.dc, 1);\n\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t      \"%s()\\n\", __func__);\n\tfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\n\t\t      \"display size %dx%d\\n\",\n\t\tpar->info->var.xres,\n\t\tpar->info->var.yres);\n\n\tpar->fbtftops.reset(par);\n\n\tif ((par->info->var.xres == 320) && (par->info->var.yres == 240)) {\n\t\t \n\t\twrite_reg(par, 0x88, 0x0A);\n\t\twrite_reg(par, 0x89, 0x02);\n\t\tmdelay(10);\n\t\t \n\t\twrite_reg(par, 0x10, 0x0C);\n\t\t \n\t\twrite_reg(par, 0x04, 0x03);\n\t\tmdelay(1);\n\t\t \n\t\twrite_reg(par, 0x14, 0x27);\n\t\twrite_reg(par, 0x15, 0x00);\n\t\twrite_reg(par, 0x16, 0x05);\n\t\twrite_reg(par, 0x17, 0x04);\n\t\twrite_reg(par, 0x18, 0x03);\n\t\t \n\t\twrite_reg(par, 0x19, 0xEF);\n\t\twrite_reg(par, 0x1A, 0x00);\n\t\twrite_reg(par, 0x1B, 0x05);\n\t\twrite_reg(par, 0x1C, 0x00);\n\t\twrite_reg(par, 0x1D, 0x0E);\n\t\twrite_reg(par, 0x1E, 0x00);\n\t\twrite_reg(par, 0x1F, 0x02);\n\t} else if ((par->info->var.xres == 480) &&\n\t\t   (par->info->var.yres == 272)) {\n\t\t \n\t\twrite_reg(par, 0x88, 0x0A);\n\t\twrite_reg(par, 0x89, 0x02);\n\t\tmdelay(10);\n\t\t \n\t\twrite_reg(par, 0x10, 0x0C);\n\t\t \n\t\twrite_reg(par, 0x04, 0x82);\n\t\tmdelay(1);\n\t\t \n\t\twrite_reg(par, 0x14, 0x3B);\n\t\twrite_reg(par, 0x15, 0x00);\n\t\twrite_reg(par, 0x16, 0x01);\n\t\twrite_reg(par, 0x17, 0x00);\n\t\twrite_reg(par, 0x18, 0x05);\n\t\t \n\t\twrite_reg(par, 0x19, 0x0F);\n\t\twrite_reg(par, 0x1A, 0x01);\n\t\twrite_reg(par, 0x1B, 0x02);\n\t\twrite_reg(par, 0x1C, 0x00);\n\t\twrite_reg(par, 0x1D, 0x07);\n\t\twrite_reg(par, 0x1E, 0x00);\n\t\twrite_reg(par, 0x1F, 0x09);\n\t} else if ((par->info->var.xres == 640) &&\n\t\t   (par->info->var.yres == 480)) {\n\t\t \n\t\twrite_reg(par, 0x88, 0x0B);\n\t\twrite_reg(par, 0x89, 0x02);\n\t\tmdelay(10);\n\t\t \n\t\twrite_reg(par, 0x10, 0x0C);\n\t\t \n\t\twrite_reg(par, 0x04, 0x01);\n\t\tmdelay(1);\n\t\t \n\t\twrite_reg(par, 0x14, 0x4F);\n\t\twrite_reg(par, 0x15, 0x05);\n\t\twrite_reg(par, 0x16, 0x0F);\n\t\twrite_reg(par, 0x17, 0x01);\n\t\twrite_reg(par, 0x18, 0x00);\n\t\t \n\t\twrite_reg(par, 0x19, 0xDF);\n\t\twrite_reg(par, 0x1A, 0x01);\n\t\twrite_reg(par, 0x1B, 0x0A);\n\t\twrite_reg(par, 0x1C, 0x00);\n\t\twrite_reg(par, 0x1D, 0x0E);\n\t\twrite_reg(par, 0x1E, 0x00);\n\t\twrite_reg(par, 0x1F, 0x01);\n\t} else if ((par->info->var.xres == 800) &&\n\t\t   (par->info->var.yres == 480)) {\n\t\t \n\t\twrite_reg(par, 0x88, 0x0B);\n\t\twrite_reg(par, 0x89, 0x02);\n\t\tmdelay(10);\n\t\t \n\t\twrite_reg(par, 0x10, 0x0C);\n\t\t \n\t\twrite_reg(par, 0x04, 0x81);\n\t\tmdelay(1);\n\t\t \n\t\twrite_reg(par, 0x14, 0x63);\n\t\twrite_reg(par, 0x15, 0x03);\n\t\twrite_reg(par, 0x16, 0x03);\n\t\twrite_reg(par, 0x17, 0x02);\n\t\twrite_reg(par, 0x18, 0x00);\n\t\t \n\t\twrite_reg(par, 0x19, 0xDF);\n\t\twrite_reg(par, 0x1A, 0x01);\n\t\twrite_reg(par, 0x1B, 0x14);\n\t\twrite_reg(par, 0x1C, 0x00);\n\t\twrite_reg(par, 0x1D, 0x06);\n\t\twrite_reg(par, 0x1E, 0x00);\n\t\twrite_reg(par, 0x1F, 0x01);\n\t} else {\n\t\tdev_err(par->info->device, \"display size is not supported!!\");\n\t\treturn -1;\n\t}\n\n\t \n\twrite_reg(par, 0x8a, 0x81);\n\twrite_reg(par, 0x8b, 0xFF);\n\tmdelay(10);\n\n\t \n\twrite_reg(par, 0x01, 0x80);\n\tmdelay(10);\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\t \n\twrite_reg(par, 0x30, xs & 0x00FF);\n\twrite_reg(par, 0x31, (xs & 0xFF00) >> 8);\n\twrite_reg(par, 0x32, ys & 0x00FF);\n\twrite_reg(par, 0x33, (ys & 0xFF00) >> 8);\n\twrite_reg(par, 0x34, (xs + xe) & 0x00FF);\n\twrite_reg(par, 0x35, ((xs + xe) & 0xFF00) >> 8);\n\twrite_reg(par, 0x36, (ys + ye) & 0x00FF);\n\twrite_reg(par, 0x37, ((ys + ye) & 0xFF00) >> 8);\n\n\t \n\twrite_reg(par, 0x46,  xs & 0xff);\n\twrite_reg(par, 0x47, (xs >> 8) & 0x03);\n\twrite_reg(par, 0x48,  ys & 0xff);\n\twrite_reg(par, 0x49, (ys >> 8) & 0x01);\n\n\twrite_reg(par, 0x02);\n}\n\nstatic void write_reg8_bus8(struct fbtft_par *par, int len, ...)\n{\n\tva_list args;\n\tint i, ret;\n\tu8 *buf = par->buf;\n\n\t \n\tpar->fbtftops.write = write_spi;\n\n\tif (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {\n\t\tva_start(args, len);\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbuf[i] = (u8)va_arg(args, unsigned int);\n\t\tva_end(args);\n\t\tfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par, par->info->device,\n\t\t\t\t  u8, buf, len, \"%s: \", __func__);\n\t}\n\n\tva_start(args, len);\n\t*buf++ = 0x80;\n\t*buf = (u8)va_arg(args, unsigned int);\n\tret = par->fbtftops.write(par, par->buf, 2);\n\tif (ret < 0) {\n\t\tva_end(args);\n\t\tdev_err(par->info->device, \"write() failed and returned %dn\",\n\t\t\tret);\n\t\treturn;\n\t}\n\tlen--;\n\n\tudelay(100);\n\n\tif (len) {\n\t\tbuf = (u8 *)par->buf;\n\t\t*buf++ = 0x00;\n\t\ti = len;\n\t\twhile (i--)\n\t\t\t*buf++ = (u8)va_arg(args, unsigned int);\n\n\t\tret = par->fbtftops.write(par, par->buf, len + 1);\n\t\tif (ret < 0) {\n\t\t\tva_end(args);\n\t\t\tdev_err(par->info->device,\n\t\t\t\t\"write() failed and returned %dn\", ret);\n\t\t\treturn;\n\t\t}\n\t}\n\tva_end(args);\n\n\t \n\tpar->fbtftops.write = fbtft_write_spi;\n\tudelay(100);\n}\n\nstatic int write_vmem16_bus8(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu16 *vmem16;\n\t__be16 *txbuf16;\n\tsize_t remain;\n\tsize_t to_copy;\n\tsize_t tx_array_size;\n\tint i;\n\tint ret = 0;\n\tsize_t startbyte_size = 0;\n\n\tfbtft_par_dbg(DEBUG_WRITE_VMEM, par, \"%s(offset=%zu, len=%zu)\\n\",\n\t\t      __func__, offset, len);\n\n\tremain = len / 2;\n\tvmem16 = (u16 *)(par->info->screen_buffer + offset);\n\ttx_array_size = par->txbuf.len / 2;\n\ttxbuf16 = par->txbuf.buf + 1;\n\ttx_array_size -= 2;\n\t*(u8 *)(par->txbuf.buf) = 0x00;\n\tstartbyte_size = 1;\n\n\twhile (remain) {\n\t\tto_copy = min(tx_array_size, remain);\n\t\tdev_dbg(par->info->device, \"    to_copy=%zu, remain=%zu\\n\",\n\t\t\tto_copy, remain - to_copy);\n\n\t\tfor (i = 0; i < to_copy; i++)\n\t\t\ttxbuf16[i] = cpu_to_be16(vmem16[i]);\n\n\t\tvmem16 = vmem16 + to_copy;\n\t\tret = par->fbtftops.write(par, par->txbuf.buf,\n\t\t\tstartbyte_size + to_copy * 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tremain -= to_copy;\n\t}\n\n\treturn ret;\n}\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.write_register = write_reg8_bus8,\n\t\t.write_vmem = write_vmem16_bus8,\n\t\t.write = write_spi,\n\t},\n};\n\nFBTFT_REGISTER_DRIVER(DRVNAME, \"raio,ra8875\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:ra8875\");\nMODULE_ALIAS(\"platform:ra8875\");\n\nMODULE_DESCRIPTION(\"FB driver for the RA8875 LCD Controller\");\nMODULE_AUTHOR(\"Pf@nne\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}