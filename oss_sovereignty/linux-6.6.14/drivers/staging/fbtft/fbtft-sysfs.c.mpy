{
  "module_name": "fbtft-sysfs.c",
  "hash_id": "554c53d727c0e65041645b237fb2e656d3d57a318a13bd6074e404f0f731f8d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fbtft/fbtft-sysfs.c",
  "human_readable_source": "\n#include \"fbtft.h\"\n#include \"internal.h\"\n\nstatic int get_next_ulong(char **str_p, unsigned long *val, char *sep, int base)\n{\n\tchar *p_val;\n\n\tif (!str_p || !(*str_p))\n\t\treturn -EINVAL;\n\n\tp_val = strsep(str_p, sep);\n\n\tif (!p_val)\n\t\treturn -EINVAL;\n\n\treturn kstrtoul(p_val, base, val);\n}\n\nint fbtft_gamma_parse_str(struct fbtft_par *par, u32 *curves,\n\t\t\t  const char *str, int size)\n{\n\tchar *str_p, *curve_p = NULL;\n\tchar *tmp;\n\tunsigned long val = 0;\n\tint ret = 0;\n\tint curve_counter, value_counter;\n\tint _count;\n\n\tfbtft_par_dbg(DEBUG_SYSFS, par, \"%s() str=\\n\", __func__);\n\n\tif (!str || !curves)\n\t\treturn -EINVAL;\n\n\tfbtft_par_dbg(DEBUG_SYSFS, par, \"%s\\n\", str);\n\n\ttmp = kmemdup(str, size + 1, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\t \n\tstr_p = tmp;\n\twhile (*str_p) {\n\t\tif (*str_p == ',')\n\t\t\t*str_p = ' ';\n\t\tif (*str_p == ';')\n\t\t\t*str_p = '\\n';\n\t\tstr_p++;\n\t}\n\n\tstr_p = strim(tmp);\n\n\tcurve_counter = 0;\n\twhile (str_p) {\n\t\tif (curve_counter == par->gamma.num_curves) {\n\t\t\tdev_err(par->info->device, \"Gamma: Too many curves\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcurve_p = strsep(&str_p, \"\\n\");\n\t\tvalue_counter = 0;\n\t\twhile (curve_p) {\n\t\t\tif (value_counter == par->gamma.num_values) {\n\t\t\t\tdev_err(par->info->device,\n\t\t\t\t\t\"Gamma: Too many values\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = get_next_ulong(&curve_p, &val, \" \", 16);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\t_count = curve_counter * par->gamma.num_values +\n\t\t\t\t value_counter;\n\t\t\tcurves[_count] = val;\n\t\t\tvalue_counter++;\n\t\t}\n\t\tif (value_counter != par->gamma.num_values) {\n\t\t\tdev_err(par->info->device, \"Gamma: Too few values\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcurve_counter++;\n\t}\n\tif (curve_counter != par->gamma.num_curves) {\n\t\tdev_err(par->info->device, \"Gamma: Too few curves\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(tmp);\n\treturn ret;\n}\n\nstatic ssize_t\nsprintf_gamma(struct fbtft_par *par, u32 *curves, char *buf)\n{\n\tssize_t len = 0;\n\tunsigned int i, j;\n\n\tmutex_lock(&par->gamma.lock);\n\tfor (i = 0; i < par->gamma.num_curves; i++) {\n\t\tfor (j = 0; j < par->gamma.num_values; j++)\n\t\t\tlen += scnprintf(&buf[len], PAGE_SIZE,\n\t\t\t     \"%04x \", curves[i * par->gamma.num_values + j]);\n\t\tbuf[len - 1] = '\\n';\n\t}\n\tmutex_unlock(&par->gamma.lock);\n\n\treturn len;\n}\n\nstatic ssize_t store_gamma_curve(struct device *device,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct fb_info *fb_info = dev_get_drvdata(device);\n\tstruct fbtft_par *par = fb_info->par;\n\tu32 tmp_curves[FBTFT_GAMMA_MAX_VALUES_TOTAL];\n\tint ret;\n\n\tret = fbtft_gamma_parse_str(par, tmp_curves, buf, count);\n\tif (ret)\n\t\treturn ret;\n\n\tret = par->fbtftops.set_gamma(par, tmp_curves);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&par->gamma.lock);\n\tmemcpy(par->gamma.curves, tmp_curves,\n\t       par->gamma.num_curves * par->gamma.num_values *\n\t       sizeof(tmp_curves[0]));\n\tmutex_unlock(&par->gamma.lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_gamma_curve(struct device *device,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *fb_info = dev_get_drvdata(device);\n\tstruct fbtft_par *par = fb_info->par;\n\n\treturn sprintf_gamma(par, par->gamma.curves, buf);\n}\n\nstatic struct device_attribute gamma_device_attrs[] = {\n\t__ATTR(gamma, 0660, show_gamma_curve, store_gamma_curve),\n};\n\nvoid fbtft_expand_debug_value(unsigned long *debug)\n{\n\tswitch (*debug & 0x7) {\n\tcase 1:\n\t\t*debug |= DEBUG_LEVEL_1;\n\t\tbreak;\n\tcase 2:\n\t\t*debug |= DEBUG_LEVEL_2;\n\t\tbreak;\n\tcase 3:\n\t\t*debug |= DEBUG_LEVEL_3;\n\t\tbreak;\n\tcase 4:\n\t\t*debug |= DEBUG_LEVEL_4;\n\t\tbreak;\n\tcase 5:\n\t\t*debug |= DEBUG_LEVEL_5;\n\t\tbreak;\n\tcase 6:\n\t\t*debug |= DEBUG_LEVEL_6;\n\t\tbreak;\n\tcase 7:\n\t\t*debug = 0xFFFFFFFF;\n\t\tbreak;\n\t}\n}\n\nstatic ssize_t store_debug(struct device *device,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct fb_info *fb_info = dev_get_drvdata(device);\n\tstruct fbtft_par *par = fb_info->par;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &par->debug);\n\tif (ret)\n\t\treturn ret;\n\tfbtft_expand_debug_value(&par->debug);\n\n\treturn count;\n}\n\nstatic ssize_t show_debug(struct device *device,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *fb_info = dev_get_drvdata(device);\n\tstruct fbtft_par *par = fb_info->par;\n\n\treturn sysfs_emit(buf, \"%lu\\n\", par->debug);\n}\n\nstatic struct device_attribute debug_device_attr =\n\t__ATTR(debug, 0660, show_debug, store_debug);\n\nvoid fbtft_sysfs_init(struct fbtft_par *par)\n{\n\tdevice_create_file(par->info->dev, &debug_device_attr);\n\tif (par->gamma.curves && par->fbtftops.set_gamma)\n\t\tdevice_create_file(par->info->dev, &gamma_device_attrs[0]);\n}\n\nvoid fbtft_sysfs_exit(struct fbtft_par *par)\n{\n\tdevice_remove_file(par->info->dev, &debug_device_attr);\n\tif (par->gamma.curves && par->fbtftops.set_gamma)\n\t\tdevice_remove_file(par->info->dev, &gamma_device_attrs[0]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}