{
  "module_name": "fb_uc1611.c",
  "hash_id": "22c472e8604517e481d86b155a77b2ebe6c8f67d8616f6a43605939f1d379c36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/fbtft/fb_uc1611.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gpio/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/delay.h>\n\n#include \"fbtft.h\"\n\n#define DRVNAME\t\t\"fb_uc1611\"\n#define WIDTH\t\t240\n#define HEIGHT\t\t160\n#define BPP\t\t8\n#define FPS\t\t40\n\n \n\n \nstatic unsigned int ratio = 2;\nmodule_param(ratio, uint, 0000);\nMODULE_PARM_DESC(ratio, \"BR[1:0] Bias voltage ratio: 0-3 (default: 2)\");\n\nstatic unsigned int gain = 3;\nmodule_param(gain, uint, 0000);\nMODULE_PARM_DESC(gain, \"GN[1:0] Bias voltage gain: 0-3 (default: 3)\");\n\nstatic unsigned int pot = 16;\nmodule_param(pot, uint, 0000);\nMODULE_PARM_DESC(pot, \"PM[6:0] Bias voltage pot.: 0-63 (default: 16)\");\n\n \nstatic unsigned int temp;\nmodule_param(temp, uint, 0000);\nMODULE_PARM_DESC(temp, \"TC[1:0] Temperature compensation: 0-3 (default: 0)\");\n\n \nstatic unsigned int load = 1;\nmodule_param(load, uint, 0000);\nMODULE_PARM_DESC(load, \"PC[1:0] Panel Loading: 0-3 (default: 1)\");\n\n \nstatic unsigned int pump = 3;\nmodule_param(pump, uint, 0000);\nMODULE_PARM_DESC(pump, \"PC[3:2] Pump control: 0,1,3 (default: 3)\");\n\nstatic int init_display(struct fbtft_par *par)\n{\n\tint ret;\n\n\t \n\tpar->spi->mode ^= SPI_CS_HIGH;\n\tret = spi_setup(par->spi);\n\tif (ret) {\n\t\tdev_err(par->info->device,\n\t\t\t\"Could not set inverse CS polarity\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\twrite_reg(par, 0xE2);\n\n\t \n\twrite_reg(par, 0xE8 | (ratio & 0x03));\n\n\t \n\twrite_reg(par, 0x81);\n\twrite_reg(par, (gain & 0x03) << 6 | (pot & 0x3F));\n\n\t \n\twrite_reg(par, 0x24 | (temp & 0x03));\n\n\t \n\twrite_reg(par, 0x28 | (load & 0x03));\n\n\t \n\twrite_reg(par, 0x2C | (pump & 0x03));\n\n\t \n\twrite_reg(par, 0xA6 | 0x01);\n\n\t \n\twrite_reg(par, 0xD0 | (0x02 & 0x03));\n\n\t \n\twrite_reg(par, 0xA8 | 0x07);\n\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tswitch (par->info->var.rotate) {\n\tcase 90:\n\tcase 270:\n\t\t \n\t\twrite_reg(par, ys & 0x0F);\n\t\twrite_reg(par, 0x10 | (ys >> 4));\n\n\t\t \n\t\twrite_reg(par, 0x60 | ((xs >> 1) & 0x0F));\n\t\twrite_reg(par, 0x70 | (xs >> 5));\n\t\tbreak;\n\tdefault:\n\t\t \n\t\twrite_reg(par, xs & 0x0F);\n\t\twrite_reg(par, 0x10 | (xs >> 4));\n\n\t\t \n\t\twrite_reg(par, 0x60 | ((ys >> 1) & 0x0F));\n\t\twrite_reg(par, 0x70 | (ys >> 5));\n\t\tbreak;\n\t}\n}\n\nstatic int blank(struct fbtft_par *par, bool on)\n{\n\tfbtft_par_dbg(DEBUG_BLANK, par, \"(%s=%s)\\n\",\n\t\t      __func__, on ? \"true\" : \"false\");\n\n\tif (on)\n\t\twrite_reg(par, 0xA8 | 0x00);\n\telse\n\t\twrite_reg(par, 0xA8 | 0x07);\n\treturn 0;\n}\n\nstatic int set_var(struct fbtft_par *par)\n{\n\t \n\tpar->info->var.grayscale = 1;\n\tpar->info->var.red.offset    = 0;\n\tpar->info->var.red.length    = 8;\n\tpar->info->var.green.offset  = 0;\n\tpar->info->var.green.length  = 8;\n\tpar->info->var.blue.offset   = 0;\n\tpar->info->var.blue.length   = 8;\n\tpar->info->var.transp.offset = 0;\n\tpar->info->var.transp.length = 0;\n\n\tswitch (par->info->var.rotate) {\n\tcase 90:\n\t\t \n\t\twrite_reg(par, 0x88\n\t\t\t| (0x0 & 0x1) << 2  \n\t\t\t| (0x1 << 1)\t    \n\t\t\t| 0x1);\t\t    \n\n\t\t \n\t\twrite_reg(par, 0xC0\n\t\t\t| (0x0 & 0x1) << 2  \n\t\t\t| (0x0 & 0x1) << 1  \n\t\t\t| (0x0 & 0x1));     \n\t\tbreak;\n\tcase 180:\n\t\t \n\t\twrite_reg(par, 0x88\n\t\t\t| (0x0 & 0x1) << 2  \n\t\t\t| (0x0 & 0x1) << 1  \n\t\t\t| 0x1);\t\t    \n\n\t\t \n\t\twrite_reg(par, 0xC0\n\t\t\t| (0x1 << 2)\t    \n\t\t\t| (0x0 & 0x1) << 1  \n\t\t\t| (0x0 & 0x1));     \n\t\tbreak;\n\tcase 270:\n\t\t \n\t\twrite_reg(par, 0x88\n\t\t\t| (0x0 & 0x1) << 2  \n\t\t\t| (0x1 << 1)\t    \n\t\t\t| 0x1);\t\t    \n\n\t\t \n\t\twrite_reg(par, 0xC0\n\t\t\t| (0x1 << 2)\t    \n\t\t\t| (0x1 << 1)\t    \n\t\t\t| (0x0 & 0x1));     \n\t\tbreak;\n\tdefault:\n\t\t \n\t\twrite_reg(par, 0x88\n\t\t\t| (0x0 & 0x1) << 2  \n\t\t\t| (0x0 & 0x1) << 1  \n\t\t\t| 0x1);\t\t    \n\n\t\t \n\t\twrite_reg(par, 0xC0\n\t\t\t| (0x0 & 0x1) << 2  \n\t\t\t| (0x1 << 1)\t    \n\t\t\t| (0x0 & 0x1));     \n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\n{\n\tu8 *vmem8 = (u8 *)(par->info->screen_buffer);\n\tu8 *buf8 = par->txbuf.buf;\n\tu16 *buf16 = par->txbuf.buf;\n\tint line_length = par->info->fix.line_length;\n\tint y_start = offset / line_length;\n\tint y_end = (offset + len - 1) / line_length;\n\tint x, y, i;\n\tint ret = 0;\n\n\tswitch (par->pdata->display.buswidth) {\n\tcase 8:\n\t\tswitch (par->info->var.rotate) {\n\t\tcase 90:\n\t\tcase 270:\n\t\t\ti = y_start * line_length;\n\t\t\tfor (y = y_start; y <= y_end; y++) {\n\t\t\t\tfor (x = 0; x < line_length; x += 2) {\n\t\t\t\t\t*buf8 = vmem8[i] >> 4;\n\t\t\t\t\t*buf8 |= vmem8[i + 1] & 0xF0;\n\t\t\t\t\tbuf8++;\n\t\t\t\t\ti += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\ty_start &= 0xFE;\n\t\t\ti = y_start * line_length;\n\t\t\tfor (y = y_start; y <= y_end; y += 2) {\n\t\t\t\tfor (x = 0; x < line_length; x++) {\n\t\t\t\t\t*buf8 = vmem8[i] >> 4;\n\t\t\t\t\t*buf8 |= vmem8[i + line_length] & 0xF0;\n\t\t\t\t\tbuf8++;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ti += line_length;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgpiod_set_value(par->gpio.dc, 1);\n\n\t\t \n\t\tret = par->fbtftops.write(par, par->txbuf.buf, len / 2);\n\t\tbreak;\n\tcase 9:\n\t\tswitch (par->info->var.rotate) {\n\t\tcase 90:\n\t\tcase 270:\n\t\t\ti = y_start * line_length;\n\t\t\tfor (y = y_start; y <= y_end; y++) {\n\t\t\t\tfor (x = 0; x < line_length; x += 2) {\n\t\t\t\t\t*buf16 = 0x100;\n\t\t\t\t\t*buf16 |= vmem8[i] >> 4;\n\t\t\t\t\t*buf16 |= vmem8[i + 1] & 0xF0;\n\t\t\t\t\tbuf16++;\n\t\t\t\t\ti += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\ty_start &= 0xFE;\n\t\t\ti = y_start * line_length;\n\t\t\tfor (y = y_start; y <= y_end; y += 2) {\n\t\t\t\tfor (x = 0; x < line_length; x++) {\n\t\t\t\t\t*buf16 = 0x100;\n\t\t\t\t\t*buf16 |= vmem8[i] >> 4;\n\t\t\t\t\t*buf16 |= vmem8[i + line_length] & 0xF0;\n\t\t\t\t\tbuf16++;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ti += line_length;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = par->fbtftops.write(par, par->txbuf.buf, len);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(par->info->device, \"unsupported buswidth %d\\n\",\n\t\t\tpar->pdata->display.buswidth);\n\t}\n\n\tif (ret < 0)\n\t\tdev_err(par->info->device, \"write failed and returned: %d\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic struct fbtft_display display = {\n\t.txbuflen = -1,\n\t.regwidth = 8,\n\t.width = WIDTH,\n\t.height = HEIGHT,\n\t.bpp = BPP,\n\t.fps = FPS,\n\t.fbtftops = {\n\t\t.write_vmem = write_vmem,\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t\t.blank = blank,\n\t},\n};\n\nFBTFT_REGISTER_DRIVER(DRVNAME, \"ultrachip,uc1611\", &display);\n\nMODULE_ALIAS(\"spi:\" DRVNAME);\nMODULE_ALIAS(\"platform:\" DRVNAME);\nMODULE_ALIAS(\"spi:uc1611\");\nMODULE_ALIAS(\"platform:uc1611\");\n\nMODULE_DESCRIPTION(\"FB driver for the UC1611 LCD controller\");\nMODULE_AUTHOR(\"Henri Chain\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}