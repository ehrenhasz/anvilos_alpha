{
  "module_name": "rtllib_tx.c",
  "hash_id": "d44da5d91512784172d52de467a132be3fd433342a6ae061bff0ff54ffef2672",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtllib_tx.c",
  "human_readable_source": "\n \n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n#include <linux/wireless.h>\n#include <linux/etherdevice.h>\n#include <linux/uaccess.h>\n#include <linux/if_vlan.h>\n\n#include \"rtllib.h\"\n\n \n\nstatic u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };\nstatic u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };\n\nstatic int rtllib_put_snap(u8 *data, u16 h_proto)\n{\n\tstruct rtllib_snap_hdr *snap;\n\tu8 *oui;\n\n\tsnap = (struct rtllib_snap_hdr *)data;\n\tsnap->dsap = 0xaa;\n\tsnap->ssap = 0xaa;\n\tsnap->ctrl = 0x03;\n\n\tif (h_proto == 0x8137 || h_proto == 0x80f3)\n\t\toui = P802_1H_OUI;\n\telse\n\t\toui = RFC1042_OUI;\n\tsnap->oui[0] = oui[0];\n\tsnap->oui[1] = oui[1];\n\tsnap->oui[2] = oui[2];\n\n\t*(__be16 *)(data + SNAP_SIZE) = htons(h_proto);\n\n\treturn SNAP_SIZE + sizeof(u16);\n}\n\nint rtllib_encrypt_fragment(struct rtllib_device *ieee, struct sk_buff *frag,\n\t\t\t    int hdr_len)\n{\n\tstruct lib80211_crypt_data *crypt = NULL;\n\tint res;\n\n\tcrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\n\n\tif (!(crypt && crypt->ops)) {\n\t\tnetdev_info(ieee->dev, \"=========>%s(), crypt is null\\n\",\n\t\t\t    __func__);\n\t\treturn -1;\n\t}\n\t \n\n\t \n\tatomic_inc(&crypt->refcnt);\n\tres = 0;\n\tif (crypt->ops->encrypt_msdu)\n\t\tres = crypt->ops->encrypt_msdu(frag, hdr_len, crypt->priv);\n\tif (res == 0 && crypt->ops->encrypt_mpdu)\n\t\tres = crypt->ops->encrypt_mpdu(frag, hdr_len, crypt->priv);\n\n\tatomic_dec(&crypt->refcnt);\n\tif (res < 0) {\n\t\tnetdev_info(ieee->dev, \"%s: Encryption failed: len=%d.\\n\",\n\t\t\t    ieee->dev->name, frag->len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid rtllib_txb_free(struct rtllib_txb *txb)\n{\n\tif (unlikely(!txb))\n\t\treturn;\n\tkfree(txb);\n}\n\nstatic struct rtllib_txb *rtllib_alloc_txb(int nr_frags, int txb_size,\n\t\t\t\t\t   gfp_t gfp_mask)\n{\n\tstruct rtllib_txb *txb;\n\tint i;\n\n\ttxb = kzalloc(struct_size(txb, fragments, nr_frags), gfp_mask);\n\tif (!txb)\n\t\treturn NULL;\n\n\ttxb->nr_frags = nr_frags;\n\ttxb->frag_size = cpu_to_le16(txb_size);\n\n\tfor (i = 0; i < nr_frags; i++) {\n\t\ttxb->fragments[i] = dev_alloc_skb(txb_size);\n\t\tif (unlikely(!txb->fragments[i]))\n\t\t\tgoto err_free;\n\t\tmemset(txb->fragments[i]->cb, 0, sizeof(txb->fragments[i]->cb));\n\t}\n\n\treturn txb;\n\nerr_free:\n\twhile (--i >= 0)\n\t\tdev_kfree_skb_any(txb->fragments[i]);\n\tkfree(txb);\n\n\treturn NULL;\n}\n\nstatic int rtllib_classify(struct sk_buff *skb, u8 bIsAmsdu)\n{\n\tstruct ethhdr *eth;\n\tstruct iphdr *ip;\n\n\teth = (struct ethhdr *)skb->data;\n\tif (eth->h_proto != htons(ETH_P_IP))\n\t\treturn 0;\n\n#ifdef VERBOSE_DEBUG\n\tprint_hex_dump_bytes(\"%s: \", __func__, DUMP_PREFIX_NONE, skb->data,\n\t\t\t     skb->len);\n#endif\n\tip = ip_hdr(skb);\n\tswitch (ip->tos & 0xfc) {\n\tcase 0x20:\n\t\treturn 2;\n\tcase 0x40:\n\t\treturn 1;\n\tcase 0x60:\n\t\treturn 3;\n\tcase 0x80:\n\t\treturn 4;\n\tcase 0xa0:\n\t\treturn 5;\n\tcase 0xc0:\n\t\treturn 6;\n\tcase 0xe0:\n\t\treturn 7;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void rtllib_tx_query_agg_cap(struct rtllib_device *ieee,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct cb_desc *tcb_desc)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\tstruct tx_ts_record *pTxTs = NULL;\n\tstruct rtllib_hdr_1addr *hdr = (struct rtllib_hdr_1addr *)skb->data;\n\n\tif (rtllib_act_scanning(ieee, false))\n\t\treturn;\n\n\tif (!ht_info->bCurrentHTSupport || !ht_info->enable_ht)\n\t\treturn;\n\tif (!IsQoSDataFrame(skb->data))\n\t\treturn;\n\tif (is_multicast_ether_addr(hdr->addr1))\n\t\treturn;\n\n\tif (tcb_desc->bdhcp || ieee->CntAfterLink < 2)\n\t\treturn;\n\n\tif (ht_info->iot_action & HT_IOT_ACT_TX_NO_AGGREGATION)\n\t\treturn;\n\n\tif (!ieee->GetNmodeSupportBySecCfg(ieee->dev))\n\t\treturn;\n\tif (ht_info->bCurrentAMPDUEnable) {\n\t\tif (!GetTs(ieee, (struct ts_common_info **)(&pTxTs), hdr->addr1,\n\t\t\t   skb->priority, TX_DIR, true)) {\n\t\t\tnetdev_info(ieee->dev, \"%s: can't get TS\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tif (!pTxTs->TxAdmittedBARecord.b_valid) {\n\t\t\tif (ieee->wpa_ie_len && (ieee->pairwise_key_type ==\n\t\t\t    KEY_TYPE_NA)) {\n\t\t\t\t;\n\t\t\t} else if (tcb_desc->bdhcp == 1) {\n\t\t\t\t;\n\t\t\t} else if (!pTxTs->bDisable_AddBa) {\n\t\t\t\tTsStartAddBaProcess(ieee, pTxTs);\n\t\t\t}\n\t\t\tgoto FORCED_AGG_SETTING;\n\t\t} else if (!pTxTs->bUsingBa) {\n\t\t\tif (SN_LESS(pTxTs->TxAdmittedBARecord.ba_start_seq_ctrl.field.seq_num,\n\t\t\t\t    (pTxTs->TxCurSeq + 1) % 4096))\n\t\t\t\tpTxTs->bUsingBa = true;\n\t\t\telse\n\t\t\t\tgoto FORCED_AGG_SETTING;\n\t\t}\n\t\tif (ieee->iw_mode == IW_MODE_INFRA) {\n\t\t\ttcb_desc->bAMPDUEnable = true;\n\t\t\ttcb_desc->ampdu_factor = ht_info->CurrentAMPDUFactor;\n\t\t\ttcb_desc->ampdu_density = ht_info->current_mpdu_density;\n\t\t}\n\t}\nFORCED_AGG_SETTING:\n\tswitch (ht_info->ForcedAMPDUMode) {\n\tcase HT_AGG_AUTO:\n\t\tbreak;\n\n\tcase HT_AGG_FORCE_ENABLE:\n\t\ttcb_desc->bAMPDUEnable = true;\n\t\ttcb_desc->ampdu_density = ht_info->forced_mpdu_density;\n\t\ttcb_desc->ampdu_factor = ht_info->forced_ampdu_factor;\n\t\tbreak;\n\n\tcase HT_AGG_FORCE_DISABLE:\n\t\ttcb_desc->bAMPDUEnable = false;\n\t\ttcb_desc->ampdu_density = 0;\n\t\ttcb_desc->ampdu_factor = 0;\n\t\tbreak;\n\t}\n}\n\nstatic void rtllib_query_ShortPreambleMode(struct rtllib_device *ieee,\n\t\t\t\t\t   struct cb_desc *tcb_desc)\n{\n\ttcb_desc->bUseShortPreamble = false;\n\tif (tcb_desc->data_rate == 2)\n\t\treturn;\n\telse if (ieee->current_network.capability &\n\t\t WLAN_CAPABILITY_SHORT_PREAMBLE)\n\t\ttcb_desc->bUseShortPreamble = true;\n}\n\nstatic void rtllib_query_HTCapShortGI(struct rtllib_device *ieee,\n\t\t\t\t      struct cb_desc *tcb_desc)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\n\ttcb_desc->bUseShortGI\t\t= false;\n\n\tif (!ht_info->bCurrentHTSupport || !ht_info->enable_ht)\n\t\treturn;\n\n\tif (ht_info->forced_short_gi) {\n\t\ttcb_desc->bUseShortGI = true;\n\t\treturn;\n\t}\n\n\tif (ht_info->bCurBW40MHz && ht_info->bCurShortGI40MHz)\n\t\ttcb_desc->bUseShortGI = true;\n\telse if (!ht_info->bCurBW40MHz && ht_info->bCurShortGI20MHz)\n\t\ttcb_desc->bUseShortGI = true;\n}\n\nstatic void rtllib_query_BandwidthMode(struct rtllib_device *ieee,\n\t\t\t\t       struct cb_desc *tcb_desc)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\n\ttcb_desc->bPacketBW = false;\n\n\tif (!ht_info->bCurrentHTSupport || !ht_info->enable_ht)\n\t\treturn;\n\n\tif (tcb_desc->bMulticast || tcb_desc->bBroadcast)\n\t\treturn;\n\n\tif ((tcb_desc->data_rate & 0x80) == 0)\n\t\treturn;\n\tif (ht_info->bCurBW40MHz && ht_info->cur_tx_bw40mhz &&\n\t    !ieee->bandwidth_auto_switch.bforced_tx20Mhz)\n\t\ttcb_desc->bPacketBW = true;\n}\n\nstatic void rtllib_query_protectionmode(struct rtllib_device *ieee,\n\t\t\t\t\tstruct cb_desc *tcb_desc,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct rt_hi_throughput *ht_info;\n\n\ttcb_desc->bRTSSTBC\t\t\t= false;\n\ttcb_desc->bRTSUseShortGI\t\t= false;\n\ttcb_desc->bCTSEnable\t\t\t= false;\n\ttcb_desc->RTSSC\t\t\t\t= 0;\n\ttcb_desc->bRTSBW\t\t\t= false;\n\n\tif (tcb_desc->bBroadcast || tcb_desc->bMulticast)\n\t\treturn;\n\n\tif (is_broadcast_ether_addr(skb->data + 16))\n\t\treturn;\n\n\tif (ieee->mode < WIRELESS_MODE_N_24G) {\n\t\tif (skb->len > ieee->rts) {\n\t\t\ttcb_desc->bRTSEnable = true;\n\t\t\ttcb_desc->rts_rate = MGN_24M;\n\t\t} else if (ieee->current_network.buseprotection) {\n\t\t\ttcb_desc->bRTSEnable = true;\n\t\t\ttcb_desc->bCTSEnable = true;\n\t\t\ttcb_desc->rts_rate = MGN_24M;\n\t\t}\n\t\treturn;\n\t}\n\n\tht_info = ieee->ht_info;\n\n\twhile (true) {\n\t\tif (ht_info->iot_action & HT_IOT_ACT_FORCED_CTS2SELF) {\n\t\t\ttcb_desc->bCTSEnable\t= true;\n\t\t\ttcb_desc->rts_rate  =\tMGN_24M;\n\t\t\ttcb_desc->bRTSEnable = true;\n\t\t\tbreak;\n\t\t} else if (ht_info->iot_action & (HT_IOT_ACT_FORCED_RTS |\n\t\t\t   HT_IOT_ACT_PURE_N_MODE)) {\n\t\t\ttcb_desc->bRTSEnable = true;\n\t\t\ttcb_desc->rts_rate  =\tMGN_24M;\n\t\t\tbreak;\n\t\t}\n\t\tif (ieee->current_network.buseprotection) {\n\t\t\ttcb_desc->bRTSEnable = true;\n\t\t\ttcb_desc->bCTSEnable = true;\n\t\t\ttcb_desc->rts_rate = MGN_24M;\n\t\t\tbreak;\n\t\t}\n\t\tif (ht_info->bCurrentHTSupport  && ht_info->enable_ht) {\n\t\t\tu8 HTOpMode = ht_info->current_op_mode;\n\n\t\t\tif ((ht_info->bCurBW40MHz && (HTOpMode == 2 ||\n\t\t\t\t\t\t      HTOpMode == 3)) ||\n\t\t\t     (!ht_info->bCurBW40MHz && HTOpMode == 3)) {\n\t\t\t\ttcb_desc->rts_rate = MGN_24M;\n\t\t\t\ttcb_desc->bRTSEnable = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skb->len > ieee->rts) {\n\t\t\ttcb_desc->rts_rate = MGN_24M;\n\t\t\ttcb_desc->bRTSEnable = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (tcb_desc->bAMPDUEnable) {\n\t\t\ttcb_desc->rts_rate = MGN_24M;\n\t\t\ttcb_desc->bRTSEnable = false;\n\t\t\tbreak;\n\t\t}\n\t\tgoto NO_PROTECTION;\n\t}\n\tif (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\n\t\ttcb_desc->bUseShortPreamble = true;\n\treturn;\nNO_PROTECTION:\n\ttcb_desc->bRTSEnable\t= false;\n\ttcb_desc->bCTSEnable\t= false;\n\ttcb_desc->rts_rate\t= 0;\n\ttcb_desc->RTSSC\t\t= 0;\n\ttcb_desc->bRTSBW\t= false;\n}\n\nstatic void rtllib_txrate_selectmode(struct rtllib_device *ieee,\n\t\t\t\t     struct cb_desc *tcb_desc)\n{\n\tif (ieee->tx_dis_rate_fallback)\n\t\ttcb_desc->tx_dis_rate_fallback = true;\n\n\tif (ieee->tx_use_drv_assinged_rate)\n\t\ttcb_desc->tx_use_drv_assinged_rate = true;\n\tif (!tcb_desc->tx_dis_rate_fallback ||\n\t    !tcb_desc->tx_use_drv_assinged_rate) {\n\t\tif (ieee->iw_mode == IW_MODE_INFRA ||\n\t\t    ieee->iw_mode == IW_MODE_ADHOC)\n\t\t\ttcb_desc->ratr_index = 0;\n\t}\n}\n\nstatic u16 rtllib_query_seqnum(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t\t       u8 *dst)\n{\n\tu16 seqnum = 0;\n\n\tif (is_multicast_ether_addr(dst))\n\t\treturn 0;\n\tif (IsQoSDataFrame(skb->data)) {\n\t\tstruct tx_ts_record *pTS = NULL;\n\n\t\tif (!GetTs(ieee, (struct ts_common_info **)(&pTS), dst,\n\t\t\t   skb->priority, TX_DIR, true))\n\t\t\treturn 0;\n\t\tseqnum = pTS->TxCurSeq;\n\t\tpTS->TxCurSeq = (pTS->TxCurSeq + 1) % 4096;\n\t\treturn seqnum;\n\t}\n\treturn 0;\n}\n\nstatic int wme_downgrade_ac(struct sk_buff *skb)\n{\n\tswitch (skb->priority) {\n\tcase 6:\n\tcase 7:\n\t\tskb->priority = 5;  \n\t\treturn 0;\n\tcase 4:\n\tcase 5:\n\t\tskb->priority = 3;  \n\t\treturn 0;\n\tcase 0:\n\tcase 3:\n\t\tskb->priority = 1;  \n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic u8 rtllib_current_rate(struct rtllib_device *ieee)\n{\n\tif (ieee->mode & IEEE_MODE_MASK)\n\t\treturn ieee->rate;\n\n\tif (ieee->HTCurrentOperaRate)\n\t\treturn ieee->HTCurrentOperaRate;\n\telse\n\t\treturn ieee->rate & 0x7F;\n}\n\nstatic int rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct rtllib_device *ieee = (struct rtllib_device *)\n\t\t\t\t     netdev_priv_rsl(dev);\n\tstruct rtllib_txb *txb = NULL;\n\tstruct rtllib_hdr_3addrqos *frag_hdr;\n\tint i, bytes_per_frag, nr_frags, bytes_last_frag, frag_size;\n\tunsigned long flags;\n\tstruct net_device_stats *stats = &ieee->stats;\n\tint ether_type = 0, encrypt;\n\tint bytes, fc, qos_ctl = 0, hdr_len;\n\tstruct sk_buff *skb_frag;\n\tstruct rtllib_hdr_3addrqos header = {  \n\t\t.duration_id = 0,\n\t\t.seq_ctl = 0,\n\t\t.qos_ctl = 0\n\t};\n\tint qos_activated = ieee->current_network.qos_data.active;\n\tu8 dest[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n\tstruct lib80211_crypt_data *crypt = NULL;\n\tstruct cb_desc *tcb_desc;\n\tu8 bIsMulticast = false;\n\tu8 IsAmsdu = false;\n\tbool\tbdhcp = false;\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\t \n\tif (!(ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE) ||\n\t   ((!ieee->softmac_data_hard_start_xmit &&\n\t   (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)))) {\n\t\tnetdev_warn(ieee->dev, \"No xmit handler.\\n\");\n\t\tgoto success;\n\t}\n\n\tif (likely(ieee->raw_tx == 0)) {\n\t\tif (unlikely(skb->len < SNAP_SIZE + sizeof(u16))) {\n\t\t\tnetdev_warn(ieee->dev, \"skb too small (%d).\\n\",\n\t\t\t\t    skb->len);\n\t\t\tgoto success;\n\t\t}\n\t\t \n\t\tether_addr_copy(dest, skb->data);\n\t\tether_addr_copy(src, skb->data + ETH_ALEN);\n\n\t\tmemset(skb->cb, 0, sizeof(skb->cb));\n\t\tether_type = ntohs(((struct ethhdr *)skb->data)->h_proto);\n\n\t\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\t\ttxb = rtllib_alloc_txb(1, skb->len, GFP_ATOMIC);\n\t\t\tif (unlikely(!txb)) {\n\t\t\t\tnetdev_warn(ieee->dev,\n\t\t\t\t\t    \"Could not allocate TXB\\n\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\ttxb->encrypted = 0;\n\t\t\ttxb->payload_size = cpu_to_le16(skb->len);\n\t\t\tskb_put_data(txb->fragments[0], skb->data, skb->len);\n\n\t\t\tgoto success;\n\t\t}\n\n\t\tif (skb->len > 282) {\n\t\t\tif (ether_type == ETH_P_IP) {\n\t\t\t\tconst struct iphdr *ip = (struct iphdr *)\n\t\t\t\t\t((u8 *)skb->data + 14);\n\t\t\t\tif (ip->protocol == IPPROTO_UDP) {\n\t\t\t\t\tstruct udphdr *udp;\n\n\t\t\t\t\tudp = (struct udphdr *)((u8 *)ip +\n\t\t\t\t\t      (ip->ihl << 2));\n\t\t\t\t\tif (((((u8 *)udp)[1] == 68) &&\n\t\t\t\t\t     (((u8 *)udp)[3] == 67)) ||\n\t\t\t\t\t   ((((u8 *)udp)[1] == 67) &&\n\t\t\t\t\t   (((u8 *)udp)[3] == 68))) {\n\t\t\t\t\t\tbdhcp = true;\n\t\t\t\t\t\tieee->LPSDelayCnt = 200;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (ether_type == ETH_P_ARP) {\n\t\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t\t    \"=================>DHCP Protocol start tx ARP pkt!!\\n\");\n\t\t\t\tbdhcp = true;\n\t\t\t\tieee->LPSDelayCnt =\n\t\t\t\t\t ieee->current_network.tim.tim_count;\n\t\t\t}\n\t\t}\n\n\t\tskb->priority = rtllib_classify(skb, IsAmsdu);\n\t\tcrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\n\t\tencrypt = !(ether_type == ETH_P_PAE && ieee->ieee802_1x) && crypt && crypt->ops;\n\t\tif (!encrypt && ieee->ieee802_1x &&\n\t\t    ieee->drop_unencrypted && ether_type != ETH_P_PAE) {\n\t\t\tstats->tx_dropped++;\n\t\t\tgoto success;\n\t\t}\n\t\tif (crypt && !encrypt && ether_type == ETH_P_PAE) {\n\t\t\tstruct eapol *eap = (struct eapol *)(skb->data +\n\t\t\t\tsizeof(struct ethhdr) - SNAP_SIZE -\n\t\t\t\tsizeof(u16));\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"TX: IEEE 802.11 EAPOL frame: %s\\n\",\n\t\t\t\t   eap_get_type(eap->type));\n\t\t}\n\n\t\t \n\t\tskb_pull(skb, sizeof(struct ethhdr));\n\n\t\t \n\t\tbytes = skb->len + SNAP_SIZE + sizeof(u16);\n\n\t\tif (encrypt)\n\t\t\tfc = RTLLIB_FTYPE_DATA | RTLLIB_FCTL_WEP;\n\t\telse\n\t\t\tfc = RTLLIB_FTYPE_DATA;\n\n\t\tif (qos_activated)\n\t\t\tfc |= RTLLIB_STYPE_QOS_DATA;\n\t\telse\n\t\t\tfc |= RTLLIB_STYPE_DATA;\n\n\t\tif (ieee->iw_mode == IW_MODE_INFRA) {\n\t\t\tfc |= RTLLIB_FCTL_TODS;\n\t\t\t \n\t\t\tether_addr_copy(header.addr1,\n\t\t\t\t\tieee->current_network.bssid);\n\t\t\tether_addr_copy(header.addr2, src);\n\t\t\tif (IsAmsdu)\n\t\t\t\tether_addr_copy(header.addr3,\n\t\t\t\t\t\tieee->current_network.bssid);\n\t\t\telse\n\t\t\t\tether_addr_copy(header.addr3, dest);\n\t\t} else if (ieee->iw_mode == IW_MODE_ADHOC) {\n\t\t\t \n\t\t\tether_addr_copy(header.addr1, dest);\n\t\t\tether_addr_copy(header.addr2, src);\n\t\t\tether_addr_copy(header.addr3,\n\t\t\t\t\tieee->current_network.bssid);\n\t\t}\n\n\t\tbIsMulticast = is_multicast_ether_addr(header.addr1);\n\n\t\theader.frame_ctl = cpu_to_le16(fc);\n\n\t\t \n\t\tif (bIsMulticast) {\n\t\t\tfrag_size = MAX_FRAG_THRESHOLD;\n\t\t\tqos_ctl |= QOS_CTL_NOTCONTAIN_ACK;\n\t\t} else {\n\t\t\tfrag_size = ieee->fts;\n\t\t\tqos_ctl = 0;\n\t\t}\n\n\t\tif (qos_activated) {\n\t\t\thdr_len = RTLLIB_3ADDR_LEN + 2;\n\n\t\t\t \n\t\t\twhile (unlikely(ieee->wmm_acm & (0x01 << skb->priority))) {\n\t\t\t\tnetdev_info(ieee->dev, \"skb->priority = %x\\n\",\n\t\t\t\t\t    skb->priority);\n\t\t\t\tif (wme_downgrade_ac(skb))\n\t\t\t\t\tbreak;\n\t\t\t\tnetdev_info(ieee->dev, \"converted skb->priority = %x\\n\",\n\t\t\t\t\t    skb->priority);\n\t\t\t}\n\n\t\t\tqos_ctl |= skb->priority;\n\t\t\theader.qos_ctl = cpu_to_le16(qos_ctl & RTLLIB_QOS_TID);\n\n\t\t} else {\n\t\t\thdr_len = RTLLIB_3ADDR_LEN;\n\t\t}\n\t\t \n\t\tbytes_per_frag = frag_size - hdr_len;\n\t\tif (ieee->config &\n\t\t   (CFG_RTLLIB_COMPUTE_FCS | CFG_RTLLIB_RESERVE_FCS))\n\t\t\tbytes_per_frag -= RTLLIB_FCS_LEN;\n\n\t\t \n\t\tif (encrypt) {\n\t\t\tbytes_per_frag -= crypt->ops->extra_mpdu_prefix_len +\n\t\t\t\tcrypt->ops->extra_mpdu_postfix_len +\n\t\t\t\tcrypt->ops->extra_msdu_prefix_len +\n\t\t\t\tcrypt->ops->extra_msdu_postfix_len;\n\t\t}\n\t\t \n\t\tnr_frags = bytes / bytes_per_frag;\n\t\tbytes_last_frag = bytes % bytes_per_frag;\n\t\tif (bytes_last_frag)\n\t\t\tnr_frags++;\n\t\telse\n\t\t\tbytes_last_frag = bytes_per_frag;\n\n\t\t \n\t\ttxb = rtllib_alloc_txb(nr_frags, frag_size +\n\t\t\t\t       ieee->tx_headroom, GFP_ATOMIC);\n\t\tif (unlikely(!txb)) {\n\t\t\tnetdev_warn(ieee->dev, \"Could not allocate TXB\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t\ttxb->encrypted = encrypt;\n\t\ttxb->payload_size = cpu_to_le16(bytes);\n\n\t\tif (qos_activated)\n\t\t\ttxb->queue_index = UP2AC(skb->priority);\n\t\telse\n\t\t\ttxb->queue_index = WME_AC_BE;\n\n\t\tfor (i = 0; i < nr_frags; i++) {\n\t\t\tskb_frag = txb->fragments[i];\n\t\t\ttcb_desc = (struct cb_desc *)(skb_frag->cb +\n\t\t\t\t    MAX_DEV_ADDR_SIZE);\n\t\t\tif (qos_activated) {\n\t\t\t\tskb_frag->priority = skb->priority;\n\t\t\t\ttcb_desc->queue_index =  UP2AC(skb->priority);\n\t\t\t} else {\n\t\t\t\tskb_frag->priority = WME_AC_BE;\n\t\t\t\ttcb_desc->queue_index = WME_AC_BE;\n\t\t\t}\n\t\t\tskb_reserve(skb_frag, ieee->tx_headroom);\n\n\t\t\tif (encrypt) {\n\t\t\t\tif (ieee->hwsec_active)\n\t\t\t\t\ttcb_desc->bHwSec = 1;\n\t\t\t\telse\n\t\t\t\t\ttcb_desc->bHwSec = 0;\n\t\t\t\tskb_reserve(skb_frag,\n\t\t\t\t\t    crypt->ops->extra_mpdu_prefix_len +\n\t\t\t\t\t    crypt->ops->extra_msdu_prefix_len);\n\t\t\t} else {\n\t\t\t\ttcb_desc->bHwSec = 0;\n\t\t\t}\n\t\t\tfrag_hdr = skb_put_data(skb_frag, &header, hdr_len);\n\n\t\t\t \n\t\t\tif (i != nr_frags - 1) {\n\t\t\t\tfrag_hdr->frame_ctl = cpu_to_le16(fc |\n\t\t\t\t\t\t\t\t  RTLLIB_FCTL_MOREFRAGS);\n\t\t\t\tbytes = bytes_per_frag;\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbytes = bytes_last_frag;\n\t\t\t}\n\t\t\tif ((qos_activated) && (!bIsMulticast)) {\n\t\t\t\tfrag_hdr->seq_ctl =\n\t\t\t\t\t cpu_to_le16(rtllib_query_seqnum(ieee, skb_frag,\n\t\t\t\t\t\t\t\t\t header.addr1));\n\t\t\t\tfrag_hdr->seq_ctl =\n\t\t\t\t\t cpu_to_le16(le16_to_cpu(frag_hdr->seq_ctl) << 4 | i);\n\t\t\t} else {\n\t\t\t\tfrag_hdr->seq_ctl =\n\t\t\t\t\t cpu_to_le16(ieee->seq_ctrl[0] << 4 | i);\n\t\t\t}\n\t\t\t \n\t\t\tif (i == 0) {\n\t\t\t\trtllib_put_snap(skb_put(skb_frag,\n\t\t\t\t\t\t\tSNAP_SIZE +\n\t\t\t\t\t\t\tsizeof(u16)), ether_type);\n\t\t\t\tbytes -= SNAP_SIZE + sizeof(u16);\n\t\t\t}\n\n\t\t\tskb_put_data(skb_frag, skb->data, bytes);\n\n\t\t\t \n\t\t\tskb_pull(skb, bytes);\n\n\t\t\t \n\t\t\tif (encrypt)\n\t\t\t\trtllib_encrypt_fragment(ieee, skb_frag,\n\t\t\t\t\t\t\thdr_len);\n\t\t\tif (ieee->config &\n\t\t\t   (CFG_RTLLIB_COMPUTE_FCS | CFG_RTLLIB_RESERVE_FCS))\n\t\t\t\tskb_put(skb_frag, 4);\n\t\t}\n\n\t\tif ((qos_activated) && (!bIsMulticast)) {\n\t\t\tif (ieee->seq_ctrl[UP2AC(skb->priority) + 1] == 0xFFF)\n\t\t\t\tieee->seq_ctrl[UP2AC(skb->priority) + 1] = 0;\n\t\t\telse\n\t\t\t\tieee->seq_ctrl[UP2AC(skb->priority) + 1]++;\n\t\t} else {\n\t\t\tif (ieee->seq_ctrl[0] == 0xFFF)\n\t\t\t\tieee->seq_ctrl[0] = 0;\n\t\t\telse\n\t\t\t\tieee->seq_ctrl[0]++;\n\t\t}\n\t} else {\n\t\tif (unlikely(skb->len < sizeof(struct rtllib_hdr_3addr))) {\n\t\t\tnetdev_warn(ieee->dev, \"skb too small (%d).\\n\",\n\t\t\t\t    skb->len);\n\t\t\tgoto success;\n\t\t}\n\n\t\ttxb = rtllib_alloc_txb(1, skb->len, GFP_ATOMIC);\n\t\tif (!txb) {\n\t\t\tnetdev_warn(ieee->dev, \"Could not allocate TXB\\n\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\ttxb->encrypted = 0;\n\t\ttxb->payload_size = cpu_to_le16(skb->len);\n\t\tskb_put_data(txb->fragments[0], skb->data, skb->len);\n\t}\n\n success:\n\tif (txb) {\n\t\ttcb_desc = (struct cb_desc *)\n\t\t\t\t(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);\n\t\ttcb_desc->bTxEnableFwCalcDur = 1;\n\t\ttcb_desc->priority = skb->priority;\n\n\t\tif (ether_type == ETH_P_PAE) {\n\t\t\tif (ieee->ht_info->iot_action &\n\t\t\t    HT_IOT_ACT_WA_IOT_Broadcom) {\n\t\t\t\ttcb_desc->data_rate =\n\t\t\t\t\t MgntQuery_TxRateExcludeCCKRates(ieee);\n\t\t\t\ttcb_desc->tx_dis_rate_fallback = false;\n\t\t\t} else {\n\t\t\t\ttcb_desc->data_rate = ieee->basic_rate;\n\t\t\t\ttcb_desc->tx_dis_rate_fallback = 1;\n\t\t\t}\n\n\t\t\ttcb_desc->ratr_index = 7;\n\t\t\ttcb_desc->tx_use_drv_assinged_rate = 1;\n\t\t} else {\n\t\t\tif (is_multicast_ether_addr(header.addr1))\n\t\t\t\ttcb_desc->bMulticast = 1;\n\t\t\tif (is_broadcast_ether_addr(header.addr1))\n\t\t\t\ttcb_desc->bBroadcast = 1;\n\t\t\trtllib_txrate_selectmode(ieee, tcb_desc);\n\t\t\tif (tcb_desc->bMulticast ||  tcb_desc->bBroadcast)\n\t\t\t\ttcb_desc->data_rate = ieee->basic_rate;\n\t\t\telse\n\t\t\t\ttcb_desc->data_rate = rtllib_current_rate(ieee);\n\n\t\t\tif (bdhcp) {\n\t\t\t\tif (ieee->ht_info->iot_action &\n\t\t\t\t    HT_IOT_ACT_WA_IOT_Broadcom) {\n\t\t\t\t\ttcb_desc->data_rate =\n\t\t\t\t\t   MgntQuery_TxRateExcludeCCKRates(ieee);\n\t\t\t\t\ttcb_desc->tx_dis_rate_fallback = false;\n\t\t\t\t} else {\n\t\t\t\t\ttcb_desc->data_rate = MGN_1M;\n\t\t\t\t\ttcb_desc->tx_dis_rate_fallback = 1;\n\t\t\t\t}\n\n\t\t\t\ttcb_desc->ratr_index = 7;\n\t\t\t\ttcb_desc->tx_use_drv_assinged_rate = 1;\n\t\t\t\ttcb_desc->bdhcp = 1;\n\t\t\t}\n\n\t\t\trtllib_query_ShortPreambleMode(ieee, tcb_desc);\n\t\t\trtllib_tx_query_agg_cap(ieee, txb->fragments[0],\n\t\t\t\t\t\ttcb_desc);\n\t\t\trtllib_query_HTCapShortGI(ieee, tcb_desc);\n\t\t\trtllib_query_BandwidthMode(ieee, tcb_desc);\n\t\t\trtllib_query_protectionmode(ieee, tcb_desc,\n\t\t\t\t\t\t    txb->fragments[0]);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\tdev_kfree_skb_any(skb);\n\tif (txb) {\n\t\tif (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE) {\n\t\t\tdev->stats.tx_packets++;\n\t\t\tdev->stats.tx_bytes += le16_to_cpu(txb->payload_size);\n\t\t\trtllib_softmac_xmit(txb, ieee);\n\t\t} else {\n\t\t\trtllib_txb_free(txb);\n\t\t}\n\t}\n\n\treturn 0;\n\n failed:\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\tnetif_stop_queue(dev);\n\tstats->tx_errors++;\n\treturn 1;\n}\n\nnetdev_tx_t rtllib_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\treturn rtllib_xmit_inter(skb, dev) ? NETDEV_TX_BUSY : NETDEV_TX_OK;\n}\nEXPORT_SYMBOL(rtllib_xmit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}