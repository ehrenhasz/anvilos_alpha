{
  "module_name": "rtl819x_BAProc.c",
  "hash_id": "907736f9ee238588118f65d0c3f092bc0fea3aa48e79c48371c80dd637936db1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtl819x_BAProc.c",
  "human_readable_source": "\n \n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include <linux/etherdevice.h>\n#include \"rtllib.h\"\n#include \"rtl819x_BA.h\"\n\nstatic void activate_ba_entry(struct ba_record *pBA, u16 Time)\n{\n\tpBA->b_valid = true;\n\tif (Time != 0)\n\t\tmod_timer(&pBA->timer, jiffies + msecs_to_jiffies(Time));\n}\n\nstatic void deactivate_ba_entry(struct rtllib_device *ieee, struct ba_record *pBA)\n{\n\tpBA->b_valid = false;\n\tdel_timer_sync(&pBA->timer);\n}\n\nstatic u8 tx_ts_delete_ba(struct rtllib_device *ieee, struct tx_ts_record *pTxTs)\n{\n\tstruct ba_record *pAdmittedBa = &pTxTs->TxAdmittedBARecord;\n\tstruct ba_record *pPendingBa = &pTxTs->TxPendingBARecord;\n\tu8 bSendDELBA = false;\n\n\tif (pPendingBa->b_valid) {\n\t\tdeactivate_ba_entry(ieee, pPendingBa);\n\t\tbSendDELBA = true;\n\t}\n\n\tif (pAdmittedBa->b_valid) {\n\t\tdeactivate_ba_entry(ieee, pAdmittedBa);\n\t\tbSendDELBA = true;\n\t}\n\treturn bSendDELBA;\n}\n\nstatic u8 rx_ts_delete_ba(struct rtllib_device *ieee, struct rx_ts_record *pRxTs)\n{\n\tstruct ba_record *pBa = &pRxTs->rx_admitted_ba_record;\n\tu8\t\t\tbSendDELBA = false;\n\n\tif (pBa->b_valid) {\n\t\tdeactivate_ba_entry(ieee, pBa);\n\t\tbSendDELBA = true;\n\t}\n\n\treturn bSendDELBA;\n}\n\nvoid rtllib_reset_ba_entry(struct ba_record *pBA)\n{\n\tpBA->b_valid\t\t\t  = false;\n\tpBA->ba_param_set.short_data\t  = 0;\n\tpBA->ba_timeout_value\t\t  = 0;\n\tpBA->dialog_token\t\t  = 0;\n\tpBA->ba_start_seq_ctrl.short_data = 0;\n}\n\nstatic struct sk_buff *rtllib_ADDBA(struct rtllib_device *ieee, u8 *Dst,\n\t\t\t\t    struct ba_record *pBA,\n\t\t\t\t    u16 StatusCode, u8 type)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct rtllib_hdr_3addr *BAReq = NULL;\n\tu8 *tag = NULL;\n\tu16 len = ieee->tx_headroom + 9;\n\n\tnetdev_dbg(ieee->dev, \"%s(): frame(%d) sentd to: %pM, ieee->dev:%p\\n\",\n\t\t   __func__, type, Dst, ieee->dev);\n\n\tif (!pBA) {\n\t\tnetdev_warn(ieee->dev, \"pBA is NULL\\n\");\n\t\treturn NULL;\n\t}\n\tskb = dev_alloc_skb(len + sizeof(struct rtllib_hdr_3addr));\n\tif (!skb)\n\t\treturn NULL;\n\n\tmemset(skb->data, 0, sizeof(struct rtllib_hdr_3addr));\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\tBAReq = skb_put(skb, sizeof(struct rtllib_hdr_3addr));\n\n\tether_addr_copy(BAReq->addr1, Dst);\n\tether_addr_copy(BAReq->addr2, ieee->dev->dev_addr);\n\n\tether_addr_copy(BAReq->addr3, ieee->current_network.bssid);\n\tBAReq->frame_ctl = cpu_to_le16(RTLLIB_STYPE_MANAGE_ACT);\n\n\ttag = skb_put(skb, 9);\n\t*tag++ = ACT_CAT_BA;\n\t*tag++ = type;\n\t*tag++ = pBA->dialog_token;\n\n\tif (type == ACT_ADDBARSP) {\n\t\tput_unaligned_le16(StatusCode, tag);\n\t\ttag += 2;\n\t}\n\n\tput_unaligned_le16(pBA->ba_param_set.short_data, tag);\n\ttag += 2;\n\n\tput_unaligned_le16(pBA->ba_timeout_value, tag);\n\ttag += 2;\n\n\tif (type == ACT_ADDBAREQ) {\n\t\tmemcpy(tag, (u8 *)&pBA->ba_start_seq_ctrl, 2);\n\t\ttag += 2;\n\t}\n\n#ifdef VERBOSE_DEBUG\n\tprint_hex_dump_bytes(\"%s: \", DUMP_PREFIX_NONE, skb->data,\n\t\t\t     __func__, skb->len);\n#endif\n\treturn skb;\n}\n\nstatic struct sk_buff *rtllib_DELBA(struct rtllib_device *ieee, u8 *dst,\n\t\t\t\t    struct ba_record *pBA,\n\t\t\t\t    enum tr_select TxRxSelect, u16 ReasonCode)\n{\n\tunion delba_param_set DelbaParamSet;\n\tstruct sk_buff *skb = NULL;\n\tstruct rtllib_hdr_3addr *Delba = NULL;\n\tu8 *tag = NULL;\n\tu16 len = 6 + ieee->tx_headroom;\n\n\tif (net_ratelimit())\n\t\tnetdev_dbg(ieee->dev, \"%s(): ReasonCode(%d) sentd to: %pM\\n\",\n\t\t\t   __func__, ReasonCode, dst);\n\n\tmemset(&DelbaParamSet, 0, 2);\n\n\tDelbaParamSet.field.initiator = (TxRxSelect == TX_DIR) ? 1 : 0;\n\tDelbaParamSet.field.tid\t= pBA->ba_param_set.field.tid;\n\n\tskb = dev_alloc_skb(len + sizeof(struct rtllib_hdr_3addr));\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\tDelba = skb_put(skb, sizeof(struct rtllib_hdr_3addr));\n\n\tether_addr_copy(Delba->addr1, dst);\n\tether_addr_copy(Delba->addr2, ieee->dev->dev_addr);\n\tether_addr_copy(Delba->addr3, ieee->current_network.bssid);\n\tDelba->frame_ctl = cpu_to_le16(RTLLIB_STYPE_MANAGE_ACT);\n\n\ttag = skb_put(skb, 6);\n\n\t*tag++ = ACT_CAT_BA;\n\t*tag++ = ACT_DELBA;\n\n\tput_unaligned_le16(DelbaParamSet.short_data, tag);\n\ttag += 2;\n\n\tput_unaligned_le16(ReasonCode, tag);\n\ttag += 2;\n\n#ifdef VERBOSE_DEBUG\n\tprint_hex_dump_bytes(\"%s: \", DUMP_PREFIX_NONE, skb->data,\n\t\t\t     __func__, skb->len);\n#endif\n\treturn skb;\n}\n\nstatic void rtllib_send_ADDBAReq(struct rtllib_device *ieee, u8 *dst,\n\t\t\t\t struct ba_record *pBA)\n{\n\tstruct sk_buff *skb;\n\n\tskb = rtllib_ADDBA(ieee, dst, pBA, 0, ACT_ADDBAREQ);\n\n\tif (skb)\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\telse\n\t\tnetdev_dbg(ieee->dev, \"Failed to generate ADDBAReq packet.\\n\");\n}\n\nstatic void rtllib_send_ADDBARsp(struct rtllib_device *ieee, u8 *dst,\n\t\t\t\t struct ba_record *pBA, u16 StatusCode)\n{\n\tstruct sk_buff *skb;\n\n\tskb = rtllib_ADDBA(ieee, dst, pBA, StatusCode, ACT_ADDBARSP);\n\tif (skb)\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\telse\n\t\tnetdev_dbg(ieee->dev, \"Failed to generate ADDBARsp packet.\\n\");\n}\n\nstatic void rtllib_send_DELBA(struct rtllib_device *ieee, u8 *dst,\n\t\t\t      struct ba_record *pBA, enum tr_select TxRxSelect,\n\t\t\t      u16 ReasonCode)\n{\n\tstruct sk_buff *skb;\n\n\tskb = rtllib_DELBA(ieee, dst, pBA, TxRxSelect, ReasonCode);\n\tif (skb)\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\telse\n\t\tnetdev_dbg(ieee->dev, \"Failed to generate DELBA packet.\\n\");\n}\n\nint rtllib_rx_ADDBAReq(struct rtllib_device *ieee, struct sk_buff *skb)\n{\n\tstruct rtllib_hdr_3addr *req = NULL;\n\tu16 rc = 0;\n\tu8 *dst = NULL, *pDialogToken = NULL, *tag = NULL;\n\tstruct ba_record *pBA = NULL;\n\tunion ba_param_set *pBaParamSet = NULL;\n\tu16 *pBaTimeoutVal = NULL;\n\tunion sequence_control *pBaStartSeqCtrl = NULL;\n\tstruct rx_ts_record *pTS = NULL;\n\n\tif (skb->len < sizeof(struct rtllib_hdr_3addr) + 9) {\n\t\tnetdev_warn(ieee->dev, \"Invalid skb len in BAREQ(%d / %d)\\n\",\n\t\t\t    (int)skb->len,\n\t\t\t    (int)(sizeof(struct rtllib_hdr_3addr) + 9));\n\t\treturn -1;\n\t}\n\n#ifdef VERBOSE_DEBUG\n\tprint_hex_dump_bytes(\"%s: \", DUMP_PREFIX_NONE, __func__,\n\t\t\t     skb->data, skb->len);\n#endif\n\n\treq = (struct rtllib_hdr_3addr *)skb->data;\n\ttag = (u8 *)req;\n\tdst = (u8 *)(&req->addr2[0]);\n\ttag += sizeof(struct rtllib_hdr_3addr);\n\tpDialogToken = tag + 2;\n\tpBaParamSet = (union ba_param_set *)(tag + 3);\n\tpBaTimeoutVal = (u16 *)(tag + 5);\n\tpBaStartSeqCtrl = (union sequence_control *)(req + 7);\n\n\tif (!ieee->current_network.qos_data.active ||\n\t    !ieee->ht_info->bCurrentHTSupport ||\n\t    (ieee->ht_info->iot_action & HT_IOT_ACT_REJECT_ADDBA_REQ)) {\n\t\trc = ADDBA_STATUS_REFUSED;\n\t\tnetdev_warn(ieee->dev,\n\t\t\t    \"Failed to reply on ADDBA_REQ as some capability is not ready(%d, %d)\\n\",\n\t\t\t    ieee->current_network.qos_data.active,\n\t\t\t    ieee->ht_info->bCurrentHTSupport);\n\t\tgoto OnADDBAReq_Fail;\n\t}\n\tif (!GetTs(ieee, (struct ts_common_info **)&pTS, dst,\n\t\t   (u8)(pBaParamSet->field.tid), RX_DIR, true)) {\n\t\trc = ADDBA_STATUS_REFUSED;\n\t\tnetdev_warn(ieee->dev, \"%s(): can't get TS\\n\", __func__);\n\t\tgoto OnADDBAReq_Fail;\n\t}\n\tpBA = &pTS->rx_admitted_ba_record;\n\n\tif (pBaParamSet->field.ba_policy == BA_POLICY_DELAYED) {\n\t\trc = ADDBA_STATUS_INVALID_PARAM;\n\t\tnetdev_warn(ieee->dev, \"%s(): BA Policy is not correct\\n\",\n\t\t\t    __func__);\n\t\tgoto OnADDBAReq_Fail;\n\t}\n\n\trtllib_FlushRxTsPendingPkts(ieee, pTS);\n\n\tdeactivate_ba_entry(ieee, pBA);\n\tpBA->dialog_token = *pDialogToken;\n\tpBA->ba_param_set = *pBaParamSet;\n\tpBA->ba_timeout_value = *pBaTimeoutVal;\n\tpBA->ba_start_seq_ctrl = *pBaStartSeqCtrl;\n\n\tif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev) ||\n\t   (ieee->ht_info->iot_action & HT_IOT_ACT_ALLOW_PEER_AGG_ONE_PKT))\n\t\tpBA->ba_param_set.field.buffer_size = 1;\n\telse\n\t\tpBA->ba_param_set.field.buffer_size = 32;\n\n\tactivate_ba_entry(pBA, 0);\n\trtllib_send_ADDBARsp(ieee, dst, pBA, ADDBA_STATUS_SUCCESS);\n\n\treturn 0;\n\nOnADDBAReq_Fail:\n\t{\n\t\tstruct ba_record BA;\n\n\t\tBA.ba_param_set = *pBaParamSet;\n\t\tBA.ba_timeout_value = *pBaTimeoutVal;\n\t\tBA.dialog_token = *pDialogToken;\n\t\tBA.ba_param_set.field.ba_policy = BA_POLICY_IMMEDIATE;\n\t\trtllib_send_ADDBARsp(ieee, dst, &BA, rc);\n\t\treturn 0;\n\t}\n}\n\nint rtllib_rx_ADDBARsp(struct rtllib_device *ieee, struct sk_buff *skb)\n{\n\tstruct rtllib_hdr_3addr *rsp = NULL;\n\tstruct ba_record *pPendingBA, *pAdmittedBA;\n\tstruct tx_ts_record *pTS = NULL;\n\tu8 *dst = NULL, *pDialogToken = NULL, *tag = NULL;\n\tu16 *pStatusCode = NULL, *pBaTimeoutVal = NULL;\n\tunion ba_param_set *pBaParamSet = NULL;\n\tu16\t\t\tReasonCode;\n\n\tif (skb->len < sizeof(struct rtllib_hdr_3addr) + 9) {\n\t\tnetdev_warn(ieee->dev, \"Invalid skb len in BARSP(%d / %d)\\n\",\n\t\t\t    (int)skb->len,\n\t\t\t    (int)(sizeof(struct rtllib_hdr_3addr) + 9));\n\t\treturn -1;\n\t}\n\trsp = (struct rtllib_hdr_3addr *)skb->data;\n\ttag = (u8 *)rsp;\n\tdst = (u8 *)(&rsp->addr2[0]);\n\ttag += sizeof(struct rtllib_hdr_3addr);\n\tpDialogToken = tag + 2;\n\tpStatusCode = (u16 *)(tag + 3);\n\tpBaParamSet = (union ba_param_set *)(tag + 5);\n\tpBaTimeoutVal = (u16 *)(tag + 7);\n\n\tif (!ieee->current_network.qos_data.active ||\n\t    !ieee->ht_info->bCurrentHTSupport ||\n\t    !ieee->ht_info->bCurrentAMPDUEnable) {\n\t\tnetdev_warn(ieee->dev,\n\t\t\t    \"reject to ADDBA_RSP as some capability is not ready(%d, %d, %d)\\n\",\n\t\t\t    ieee->current_network.qos_data.active,\n\t\t\t    ieee->ht_info->bCurrentHTSupport,\n\t\t\t    ieee->ht_info->bCurrentAMPDUEnable);\n\t\tReasonCode = DELBA_REASON_UNKNOWN_BA;\n\t\tgoto OnADDBARsp_Reject;\n\t}\n\n\tif (!GetTs(ieee, (struct ts_common_info **)&pTS, dst,\n\t\t   (u8)(pBaParamSet->field.tid), TX_DIR, false)) {\n\t\tnetdev_warn(ieee->dev, \"%s(): can't get TS\\n\", __func__);\n\t\tReasonCode = DELBA_REASON_UNKNOWN_BA;\n\t\tgoto OnADDBARsp_Reject;\n\t}\n\n\tpTS->bAddBaReqInProgress = false;\n\tpPendingBA = &pTS->TxPendingBARecord;\n\tpAdmittedBA = &pTS->TxAdmittedBARecord;\n\n\tif (pAdmittedBA->b_valid) {\n\t\tnetdev_dbg(ieee->dev, \"%s(): ADDBA response already admitted\\n\",\n\t\t\t   __func__);\n\t\treturn -1;\n\t} else if (!pPendingBA->b_valid ||\n\t\t   (*pDialogToken != pPendingBA->dialog_token)) {\n\t\tnetdev_warn(ieee->dev,\n\t\t\t    \"%s(): ADDBA Rsp. BA invalid, DELBA!\\n\",\n\t\t\t    __func__);\n\t\tReasonCode = DELBA_REASON_UNKNOWN_BA;\n\t\tgoto OnADDBARsp_Reject;\n\t} else {\n\t\tnetdev_dbg(ieee->dev,\n\t\t\t   \"%s(): Recv ADDBA Rsp. BA is admitted! Status code:%X\\n\",\n\t\t\t   __func__, *pStatusCode);\n\t\tdeactivate_ba_entry(ieee, pPendingBA);\n\t}\n\n\tif (*pStatusCode == ADDBA_STATUS_SUCCESS) {\n\t\tif (pBaParamSet->field.ba_policy == BA_POLICY_DELAYED) {\n\t\t\tpTS->bAddBaReqDelayed = true;\n\t\t\tdeactivate_ba_entry(ieee, pAdmittedBA);\n\t\t\tReasonCode = DELBA_REASON_END_BA;\n\t\t\tgoto OnADDBARsp_Reject;\n\t\t}\n\n\t\tpAdmittedBA->dialog_token = *pDialogToken;\n\t\tpAdmittedBA->ba_timeout_value = *pBaTimeoutVal;\n\t\tpAdmittedBA->ba_start_seq_ctrl = pPendingBA->ba_start_seq_ctrl;\n\t\tpAdmittedBA->ba_param_set = *pBaParamSet;\n\t\tdeactivate_ba_entry(ieee, pAdmittedBA);\n\t\tactivate_ba_entry(pAdmittedBA, *pBaTimeoutVal);\n\t} else {\n\t\tpTS->bAddBaReqDelayed = true;\n\t\tpTS->bDisable_AddBa = true;\n\t\tReasonCode = DELBA_REASON_END_BA;\n\t\tgoto OnADDBARsp_Reject;\n\t}\n\n\treturn 0;\n\nOnADDBARsp_Reject:\n\t{\n\t\tstruct ba_record BA;\n\n\t\tBA.ba_param_set = *pBaParamSet;\n\t\trtllib_send_DELBA(ieee, dst, &BA, TX_DIR, ReasonCode);\n\t\treturn 0;\n\t}\n}\n\nint rtllib_rx_DELBA(struct rtllib_device *ieee, struct sk_buff *skb)\n{\n\tstruct rtllib_hdr_3addr *delba = NULL;\n\tunion delba_param_set *pDelBaParamSet = NULL;\n\tu8 *dst = NULL;\n\n\tif (skb->len < sizeof(struct rtllib_hdr_3addr) + 6) {\n\t\tnetdev_warn(ieee->dev, \"Invalid skb len in DELBA(%d / %d)\\n\",\n\t\t\t    (int)skb->len,\n\t\t\t    (int)(sizeof(struct rtllib_hdr_3addr) + 6));\n\t\treturn -1;\n\t}\n\n\tif (!ieee->current_network.qos_data.active ||\n\t    !ieee->ht_info->bCurrentHTSupport) {\n\t\tnetdev_warn(ieee->dev,\n\t\t\t    \"received DELBA while QOS or HT is not supported(%d, %d)\\n\",\n\t\t\t    ieee->current_network. qos_data.active,\n\t\t\t    ieee->ht_info->bCurrentHTSupport);\n\t\treturn -1;\n\t}\n\n#ifdef VERBOSE_DEBUG\n\tprint_hex_dump_bytes(\"%s: \", DUMP_PREFIX_NONE, skb->data,\n\t\t\t     __func__, skb->len);\n#endif\n\tdelba = (struct rtllib_hdr_3addr *)skb->data;\n\tdst = (u8 *)(&delba->addr2[0]);\n\tpDelBaParamSet = (union delba_param_set *)&delba->payload[2];\n\n\tif (pDelBaParamSet->field.initiator == 1) {\n\t\tstruct rx_ts_record *pRxTs;\n\n\t\tif (!GetTs(ieee, (struct ts_common_info **)&pRxTs, dst,\n\t\t\t   (u8)pDelBaParamSet->field.tid, RX_DIR, false)) {\n\t\t\tnetdev_warn(ieee->dev,\n\t\t\t\t    \"%s(): can't get TS for RXTS. dst:%pM TID:%d\\n\",\n\t\t\t\t    __func__, dst,\n\t\t\t\t    (u8)pDelBaParamSet->field.tid);\n\t\t\treturn -1;\n\t\t}\n\n\t\trx_ts_delete_ba(ieee, pRxTs);\n\t} else {\n\t\tstruct tx_ts_record *pTxTs;\n\n\t\tif (!GetTs(ieee, (struct ts_common_info **)&pTxTs, dst,\n\t\t\t   (u8)pDelBaParamSet->field.tid, TX_DIR, false)) {\n\t\t\tnetdev_warn(ieee->dev, \"%s(): can't get TS for TXTS\\n\",\n\t\t\t\t    __func__);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpTxTs->bUsingBa = false;\n\t\tpTxTs->bAddBaReqInProgress = false;\n\t\tpTxTs->bAddBaReqDelayed = false;\n\t\tdel_timer_sync(&pTxTs->TsAddBaTimer);\n\t\ttx_ts_delete_ba(ieee, pTxTs);\n\t}\n\treturn 0;\n}\n\nvoid rtllib_ts_init_add_ba(struct rtllib_device *ieee, struct tx_ts_record *pTS,\n\t\t\t   u8 Policy, u8\tbOverwritePending)\n{\n\tstruct ba_record *pBA = &pTS->TxPendingBARecord;\n\n\tif (pBA->b_valid && !bOverwritePending)\n\t\treturn;\n\n\tdeactivate_ba_entry(ieee, pBA);\n\n\tpBA->dialog_token++;\n\tpBA->ba_param_set.field.amsdu_support = 0;\n\tpBA->ba_param_set.field.ba_policy = Policy;\n\tpBA->ba_param_set.field.tid = pTS->TsCommonInfo.TSpec.f.TSInfo.field.ucTSID;\n\tpBA->ba_param_set.field.buffer_size = 32;\n\tpBA->ba_timeout_value = 0;\n\tpBA->ba_start_seq_ctrl.field.seq_num = (pTS->TxCurSeq + 3) % 4096;\n\n\tactivate_ba_entry(pBA, BA_SETUP_TIMEOUT);\n\n\trtllib_send_ADDBAReq(ieee, pTS->TsCommonInfo.Addr, pBA);\n}\n\nvoid rtllib_ts_init_del_ba(struct rtllib_device *ieee,\n\t\t\t   struct ts_common_info *pTsCommonInfo,\n\t\t\t   enum tr_select TxRxSelect)\n{\n\tif (TxRxSelect == TX_DIR) {\n\t\tstruct tx_ts_record *pTxTs =\n\t\t\t (struct tx_ts_record *)pTsCommonInfo;\n\n\t\tif (tx_ts_delete_ba(ieee, pTxTs))\n\t\t\trtllib_send_DELBA(ieee, pTsCommonInfo->Addr,\n\t\t\t\t\t  (pTxTs->TxAdmittedBARecord.b_valid) ?\n\t\t\t\t\t (&pTxTs->TxAdmittedBARecord) :\n\t\t\t\t\t(&pTxTs->TxPendingBARecord),\n\t\t\t\t\t TxRxSelect, DELBA_REASON_END_BA);\n\t} else if (TxRxSelect == RX_DIR) {\n\t\tstruct rx_ts_record *pRxTs =\n\t\t\t\t (struct rx_ts_record *)pTsCommonInfo;\n\t\tif (rx_ts_delete_ba(ieee, pRxTs))\n\t\t\trtllib_send_DELBA(ieee, pTsCommonInfo->Addr,\n\t\t\t\t\t  &pRxTs->rx_admitted_ba_record,\n\t\t\t\t\t  TxRxSelect, DELBA_REASON_END_BA);\n\t}\n}\n\nvoid rtllib_ba_setup_timeout(struct timer_list *t)\n{\n\tstruct tx_ts_record *pTxTs = from_timer(pTxTs, t,\n\t\t\t\t\t      TxPendingBARecord.timer);\n\n\tpTxTs->bAddBaReqInProgress = false;\n\tpTxTs->bAddBaReqDelayed = true;\n\tpTxTs->TxPendingBARecord.b_valid = false;\n}\n\nvoid rtllib_tx_ba_inact_timeout(struct timer_list *t)\n{\n\tstruct tx_ts_record *pTxTs = from_timer(pTxTs, t,\n\t\t\t\t\t      TxAdmittedBARecord.timer);\n\tstruct rtllib_device *ieee = container_of(pTxTs, struct rtllib_device,\n\t\t\t\t     TxTsRecord[pTxTs->num]);\n\ttx_ts_delete_ba(ieee, pTxTs);\n\trtllib_send_DELBA(ieee, pTxTs->TsCommonInfo.Addr,\n\t\t\t  &pTxTs->TxAdmittedBARecord, TX_DIR,\n\t\t\t  DELBA_REASON_TIMEOUT);\n}\n\nvoid rtllib_rx_ba_inact_timeout(struct timer_list *t)\n{\n\tstruct rx_ts_record *pRxTs = from_timer(pRxTs, t,\n\t\t\t\t\t      rx_admitted_ba_record.timer);\n\tstruct rtllib_device *ieee = container_of(pRxTs, struct rtllib_device,\n\t\t\t\t     RxTsRecord[pRxTs->num]);\n\n\trx_ts_delete_ba(ieee, pRxTs);\n\trtllib_send_DELBA(ieee, pRxTs->ts_common_info.Addr,\n\t\t\t  &pRxTs->rx_admitted_ba_record, RX_DIR,\n\t\t\t  DELBA_REASON_TIMEOUT);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}