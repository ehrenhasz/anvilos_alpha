{
  "module_name": "rtl819x_HTProc.c",
  "hash_id": "aee6f18ad78f90f1c84400cb7d8e0ecc24db6b01ec72e8c001a209ac0ce1750e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtl819x_HTProc.c",
  "human_readable_source": "\n \n#include \"rtllib.h\"\n#include \"rtl819x_HT.h\"\nu8 MCS_FILTER_ALL[16] = {\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\nu8 MCS_FILTER_1SS[16] = {\n\t0xff, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}\n;\n\nu16 MCS_DATA_RATE[2][2][77] = {\n\t{{13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78, 104, 156, 208, 234,\n\t 260, 39, 78, 117, 234, 312, 351, 390, 52, 104, 156, 208, 312, 416,\n\t 468, 520, 0, 78, 104, 130, 117, 156, 195, 104, 130, 130, 156, 182,\n\t 182, 208, 156, 195, 195, 234, 273, 273, 312, 130, 156, 181, 156,\n\t 181, 208, 234, 208, 234, 260, 260, 286, 195, 234, 273, 234, 273,\n\t 312, 351, 312, 351, 390, 390, 429},\n\t{14, 29, 43, 58, 87, 116, 130, 144, 29, 58, 87, 116, 173, 231, 260, 289,\n\t 43, 87, 130, 173, 260, 347, 390, 433, 58, 116, 173, 231, 347, 462, 520,\n\t 578, 0, 87, 116, 144, 130, 173, 217, 116, 144, 144, 173, 202, 202, 231,\n\t 173, 217, 217, 260, 303, 303, 347, 144, 173, 202, 173, 202, 231, 260,\n\t 231, 260, 289, 289, 318, 217, 260, 303, 260, 303, 347, 390, 347, 390,\n\t 433, 433, 477} },\n\t{{27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486,\n\t 540, 81, 162, 243, 324, 486, 648, 729, 810, 108, 216, 324, 432, 648,\n\t 864, 972, 1080, 12, 162, 216, 270, 243, 324, 405, 216, 270, 270, 324,\n\t 378, 378, 432, 324, 405, 405, 486, 567, 567, 648, 270, 324, 378, 324,\n\t 378, 432, 486, 432, 486, 540, 540, 594, 405, 486, 567, 486, 567, 648,\n\t 729, 648, 729, 810, 810, 891},\n\t{30, 60, 90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540,\n\t 600, 90, 180, 270, 360, 540, 720, 810, 900, 120, 240, 360, 480, 720,\n\t 960, 1080, 1200, 13, 180, 240, 300, 270, 360, 450, 240, 300, 300, 360,\n\t 420, 420, 480, 360, 450, 450, 540, 630, 630, 720, 300, 360, 420, 360,\n\t 420, 480, 540, 480, 540, 600, 600, 660, 450, 540, 630, 540, 630, 720,\n\t 810, 720, 810, 900, 900, 990} }\n};\n\nstatic u8 UNKNOWN_BORADCOM[3] = {0x00, 0x14, 0xbf};\n\nstatic u8 LINKSYSWRT330_LINKSYSWRT300_BROADCOM[3] = {0x00, 0x1a, 0x70};\n\nstatic u8 LINKSYSWRT350_LINKSYSWRT150_BROADCOM[3] = {0x00, 0x1d, 0x7e};\n\nstatic u8 BELKINF5D8233V1_RALINK[3] = {0x00, 0x17, 0x3f};\n\nstatic u8 BELKINF5D82334V3_RALINK[3] = {0x00, 0x1c, 0xdf};\n\nstatic u8 PCI_RALINK[3] = {0x00, 0x90, 0xcc};\n\nstatic u8 EDIMAX_RALINK[3] = {0x00, 0x0e, 0x2e};\n\nstatic u8 AIRLINK_RALINK[3] = {0x00, 0x18, 0x02};\n\nstatic u8 DLINK_ATHEROS_1[3] = {0x00, 0x1c, 0xf0};\n\nstatic u8 DLINK_ATHEROS_2[3] = {0x00, 0x21, 0x91};\n\nstatic u8 CISCO_BROADCOM[3] = {0x00, 0x17, 0x94};\n\nstatic u8 LINKSYS_MARVELL_4400N[3] = {0x00, 0x14, 0xa4};\n\nvoid HTUpdateDefaultSetting(struct rtllib_device *ieee)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\n\tht_info->bRegShortGI20MHz = 1;\n\tht_info->bRegShortGI40MHz = 1;\n\n\tht_info->bRegBW40MHz = 1;\n\n\tif (ht_info->bRegBW40MHz)\n\t\tht_info->bRegSuppCCK = 1;\n\telse\n\t\tht_info->bRegSuppCCK = true;\n\n\tht_info->nAMSDU_MaxSize = 7935UL;\n\tht_info->bAMSDU_Support = 0;\n\n\tht_info->bAMPDUEnable = 1;\n\tht_info->AMPDU_Factor = 2;\n\tht_info->MPDU_Density = 0;\n\n\tht_info->self_mimo_ps = 3;\n\tif (ht_info->self_mimo_ps == 2)\n\t\tht_info->self_mimo_ps = 3;\n\tieee->tx_dis_rate_fallback = 0;\n\tieee->tx_use_drv_assinged_rate = 0;\n\n\tieee->bTxEnableFwCalcDur = 1;\n\n\tht_info->reg_rt2rt_aggregation = 1;\n\n\tht_info->reg_rx_reorder_enable = 1;\n\tht_info->rx_reorder_win_size = 64;\n\tht_info->rx_reorder_pending_time = 30;\n}\n\nstatic u16 HTMcsToDataRate(struct rtllib_device *ieee, u8 nMcsRate)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\n\tu8\tis40MHz = (ht_info->bCurBW40MHz) ? 1 : 0;\n\tu8\tisShortGI = (ht_info->bCurBW40MHz) ?\n\t\t\t    ((ht_info->bCurShortGI40MHz) ? 1 : 0) :\n\t\t\t    ((ht_info->bCurShortGI20MHz) ? 1 : 0);\n\treturn MCS_DATA_RATE[is40MHz][isShortGI][(nMcsRate & 0x7f)];\n}\n\nu16  TxCountToDataRate(struct rtllib_device *ieee, u8 nDataRate)\n{\n\tu16\tCCKOFDMRate[12] = {0x02, 0x04, 0x0b, 0x16, 0x0c, 0x12, 0x18,\n\t\t\t\t   0x24, 0x30, 0x48, 0x60, 0x6c};\n\tu8\tis40MHz = 0;\n\tu8\tisShortGI = 0;\n\n\tif (nDataRate < 12)\n\t\treturn CCKOFDMRate[nDataRate];\n\tif (nDataRate >= 0x10 && nDataRate <= 0x1f) {\n\t\tis40MHz = 0;\n\t\tisShortGI = 0;\n\t} else if (nDataRate >= 0x20  && nDataRate <= 0x2f) {\n\t\tis40MHz = 1;\n\t\tisShortGI = 0;\n\t} else if (nDataRate >= 0x30  && nDataRate <= 0x3f) {\n\t\tis40MHz = 0;\n\t\tisShortGI = 1;\n\t} else if (nDataRate >= 0x40  && nDataRate <= 0x4f) {\n\t\tis40MHz = 1;\n\t\tisShortGI = 1;\n\t}\n\treturn MCS_DATA_RATE[is40MHz][isShortGI][nDataRate & 0xf];\n}\n\nbool IsHTHalfNmodeAPs(struct rtllib_device *ieee)\n{\n\tbool\t\t\tretValue = false;\n\tstruct rtllib_network *net = &ieee->current_network;\n\n\tif ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3) == 0) ||\n\t    (memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3) == 0) ||\n\t    (memcmp(net->bssid, PCI_RALINK, 3) == 0) ||\n\t    (memcmp(net->bssid, EDIMAX_RALINK, 3) == 0) ||\n\t    (memcmp(net->bssid, AIRLINK_RALINK, 3) == 0) ||\n\t    (net->ralink_cap_exist))\n\t\tretValue = true;\n\telse if (!memcmp(net->bssid, UNKNOWN_BORADCOM, 3) ||\n\t\t !memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3) ||\n\t\t !memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3) ||\n\t\t(net->broadcom_cap_exist))\n\t\tretValue = true;\n\telse if (net->bssht.bd_rt2rt_aggregation)\n\t\tretValue = true;\n\telse\n\t\tretValue = false;\n\n\treturn retValue;\n}\n\nstatic void HTIOTPeerDetermine(struct rtllib_device *ieee)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\tstruct rtllib_network *net = &ieee->current_network;\n\n\tif (net->bssht.bd_rt2rt_aggregation) {\n\t\tht_info->IOTPeer = HT_IOT_PEER_REALTEK;\n\t\tif (net->bssht.rt2rt_ht_mode & RT_HT_CAP_USE_92SE)\n\t\t\tht_info->IOTPeer = HT_IOT_PEER_REALTEK_92SE;\n\t\tif (net->bssht.rt2rt_ht_mode & RT_HT_CAP_USE_SOFTAP)\n\t\t\tht_info->IOTPeer = HT_IOT_PEER_92U_SOFTAP;\n\t} else if (net->broadcom_cap_exist) {\n\t\tht_info->IOTPeer = HT_IOT_PEER_BROADCOM;\n\t} else if (!memcmp(net->bssid, UNKNOWN_BORADCOM, 3) ||\n\t\t !memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3) ||\n\t\t !memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3)) {\n\t\tht_info->IOTPeer = HT_IOT_PEER_BROADCOM;\n\t} else if ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3) == 0) ||\n\t\t (memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3) == 0) ||\n\t\t (memcmp(net->bssid, PCI_RALINK, 3) == 0) ||\n\t\t (memcmp(net->bssid, EDIMAX_RALINK, 3) == 0) ||\n\t\t (memcmp(net->bssid, AIRLINK_RALINK, 3) == 0) ||\n\t\t  net->ralink_cap_exist) {\n\t\tht_info->IOTPeer = HT_IOT_PEER_RALINK;\n\t} else if ((net->atheros_cap_exist) ||\n\t\t(memcmp(net->bssid, DLINK_ATHEROS_1, 3) == 0) ||\n\t\t(memcmp(net->bssid, DLINK_ATHEROS_2, 3) == 0)) {\n\t\tht_info->IOTPeer = HT_IOT_PEER_ATHEROS;\n\t} else if ((memcmp(net->bssid, CISCO_BROADCOM, 3) == 0) ||\n\t\t  net->cisco_cap_exist) {\n\t\tht_info->IOTPeer = HT_IOT_PEER_CISCO;\n\t} else if ((memcmp(net->bssid, LINKSYS_MARVELL_4400N, 3) == 0) ||\n\t\t  net->marvell_cap_exist) {\n\t\tht_info->IOTPeer = HT_IOT_PEER_MARVELL;\n\t} else if (net->airgo_cap_exist) {\n\t\tht_info->IOTPeer = HT_IOT_PEER_AIRGO;\n\t} else {\n\t\tht_info->IOTPeer = HT_IOT_PEER_UNKNOWN;\n\t}\n\n\tnetdev_dbg(ieee->dev, \"IOTPEER: %x\\n\", ht_info->IOTPeer);\n}\n\nstatic u8 HTIOTActIsDisableMCS14(struct rtllib_device *ieee, u8 *PeerMacAddr)\n{\n\treturn 0;\n}\n\nstatic bool HTIOTActIsDisableMCS15(struct rtllib_device *ieee)\n{\n\treturn false;\n}\n\nstatic bool HTIOTActIsDisableMCSTwoSpatialStream(struct rtllib_device *ieee)\n{\n\treturn false;\n}\n\nstatic u8 HTIOTActIsDisableEDCATurbo(struct rtllib_device *ieee,\n\t\t\t\t     u8 *PeerMacAddr)\n{\n\treturn false;\n}\n\nstatic u8 HTIOTActIsMgntUseCCK6M(struct rtllib_device *ieee,\n\t\t\t\t struct rtllib_network *network)\n{\n\tu8\tretValue = 0;\n\n\tif (ieee->ht_info->IOTPeer == HT_IOT_PEER_BROADCOM)\n\t\tretValue = 1;\n\n\treturn retValue;\n}\n\nstatic u8 HTIOTActIsCCDFsync(struct rtllib_device *ieee)\n{\n\tu8\tretValue = 0;\n\n\tif (ieee->ht_info->IOTPeer == HT_IOT_PEER_BROADCOM)\n\t\tretValue = 1;\n\treturn retValue;\n}\n\nstatic void HTIOTActDetermineRaFunc(struct rtllib_device *ieee, bool bPeerRx2ss)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\n\tht_info->iot_ra_func &= HT_IOT_RAFUNC_DISABLE_ALL;\n\n\tif (ht_info->IOTPeer == HT_IOT_PEER_RALINK && !bPeerRx2ss)\n\t\tht_info->iot_ra_func |= HT_IOT_RAFUNC_PEER_1R;\n\n\tif (ht_info->iot_action & HT_IOT_ACT_AMSDU_ENABLE)\n\t\tht_info->iot_ra_func |= HT_IOT_RAFUNC_TX_AMSDU;\n}\n\nvoid HTResetIOTSetting(struct rt_hi_throughput *ht_info)\n{\n\tht_info->iot_action = 0;\n\tht_info->IOTPeer = HT_IOT_PEER_UNKNOWN;\n\tht_info->iot_ra_func = 0;\n}\n\nvoid HTConstructCapabilityElement(struct rtllib_device *ieee, u8 *posHTCap,\n\t\t\t\t  u8 *len, u8 IsEncrypt, bool bAssoc)\n{\n\tstruct rt_hi_throughput *pHT = ieee->ht_info;\n\tstruct ht_capab_ele *pCapELE = NULL;\n\n\tif (!posHTCap || !pHT) {\n\t\tnetdev_warn(ieee->dev,\n\t\t\t    \"%s(): posHTCap and ht_info are null\\n\", __func__);\n\t\treturn;\n\t}\n\tmemset(posHTCap, 0, *len);\n\n\tif ((bAssoc) && (pHT->ePeerHTSpecVer == HT_SPEC_VER_EWC)) {\n\t\tstatic const u8\tEWC11NHTCap[] = { 0x00, 0x90, 0x4c, 0x33 };\n\n\t\tmemcpy(posHTCap, EWC11NHTCap, sizeof(EWC11NHTCap));\n\t\tpCapELE = (struct ht_capab_ele *)&posHTCap[4];\n\t\t*len = 30 + 2;\n\t} else {\n\t\tpCapELE = (struct ht_capab_ele *)posHTCap;\n\t\t*len = 26 + 2;\n\t}\n\n\tpCapELE->AdvCoding\t\t= 0;\n\tif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))\n\t\tpCapELE->ChlWidth = 0;\n\telse\n\t\tpCapELE->ChlWidth = (pHT->bRegBW40MHz ? 1 : 0);\n\n\tpCapELE->MimoPwrSave\t\t= pHT->self_mimo_ps;\n\tpCapELE->GreenField\t\t= 0;\n\tpCapELE->ShortGI20Mhz\t\t= 1;\n\tpCapELE->ShortGI40Mhz\t\t= 1;\n\n\tpCapELE->TxSTBC\t\t\t= 1;\n\tpCapELE->RxSTBC\t\t\t= 0;\n\tpCapELE->DelayBA\t\t= 0;\n\tpCapELE->MaxAMSDUSize = (MAX_RECEIVE_BUFFER_SIZE >= 7935) ? 1 : 0;\n\tpCapELE->DssCCk = ((pHT->bRegBW40MHz) ? (pHT->bRegSuppCCK ? 1 : 0) : 0);\n\tpCapELE->PSMP = 0;\n\tpCapELE->LSigTxopProtect = 0;\n\n\tnetdev_dbg(ieee->dev,\n\t\t   \"TX HT cap/info ele BW=%d MaxAMSDUSize:%d DssCCk:%d\\n\",\n\t\t   pCapELE->ChlWidth, pCapELE->MaxAMSDUSize, pCapELE->DssCCk);\n\n\tif (IsEncrypt) {\n\t\tpCapELE->MPDUDensity\t= 7;\n\t\tpCapELE->MaxRxAMPDUFactor\t= 2;\n\t} else {\n\t\tpCapELE->MaxRxAMPDUFactor\t= 3;\n\t\tpCapELE->MPDUDensity\t= 0;\n\t}\n\n\tmemcpy(pCapELE->MCS, ieee->reg_dot11ht_oper_rate_set, 16);\n\tmemset(&pCapELE->ExtHTCapInfo, 0, 2);\n\tmemset(pCapELE->TxBFCap, 0, 4);\n\n\tpCapELE->ASCap = 0;\n\n\tif (bAssoc) {\n\t\tif (pHT->iot_action & HT_IOT_ACT_DISABLE_MCS15)\n\t\t\tpCapELE->MCS[1] &= 0x7f;\n\n\t\tif (pHT->iot_action & HT_IOT_ACT_DISABLE_MCS14)\n\t\t\tpCapELE->MCS[1] &= 0xbf;\n\n\t\tif (pHT->iot_action & HT_IOT_ACT_DISABLE_ALL_2SS)\n\t\t\tpCapELE->MCS[1] &= 0x00;\n\n\t\tif (pHT->iot_action & HT_IOT_ACT_DISABLE_RX_40MHZ_SHORT_GI)\n\t\t\tpCapELE->ShortGI40Mhz\t\t= 0;\n\n\t\tif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev)) {\n\t\t\tpCapELE->ChlWidth = 0;\n\t\t\tpCapELE->MCS[1] = 0;\n\t\t}\n\t}\n}\n\nvoid HTConstructInfoElement(struct rtllib_device *ieee, u8 *posHTInfo,\n\t\t\t    u8 *len, u8 IsEncrypt)\n{\n\tstruct rt_hi_throughput *pHT = ieee->ht_info;\n\tstruct ht_info_ele *pHTInfoEle = (struct ht_info_ele *)posHTInfo;\n\n\tif (!posHTInfo || !pHTInfoEle) {\n\t\tnetdev_warn(ieee->dev,\n\t\t\t    \"%s(): posHTInfo and pHTInfoEle are null\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\tmemset(posHTInfo, 0, *len);\n\tif (ieee->iw_mode == IW_MODE_ADHOC) {\n\t\tpHTInfoEle->ControlChl\t= ieee->current_network.channel;\n\t\tpHTInfoEle->ExtChlOffset = ((!pHT->bRegBW40MHz) ?\n\t\t\t\t\t    HT_EXTCHNL_OFFSET_NO_EXT :\n\t\t\t\t\t    (ieee->current_network.channel <= 6)\n\t\t\t\t\t    ? HT_EXTCHNL_OFFSET_UPPER :\n\t\t\t\t\t    HT_EXTCHNL_OFFSET_LOWER);\n\t\tpHTInfoEle->RecommemdedTxWidth\t= pHT->bRegBW40MHz;\n\t\tpHTInfoEle->RIFS\t\t\t= 0;\n\t\tpHTInfoEle->PSMPAccessOnly\t\t= 0;\n\t\tpHTInfoEle->SrvIntGranularity\t\t= 0;\n\t\tpHTInfoEle->OptMode\t\t\t= pHT->current_op_mode;\n\t\tpHTInfoEle->NonGFDevPresent\t\t= 0;\n\t\tpHTInfoEle->DualBeacon\t\t\t= 0;\n\t\tpHTInfoEle->SecondaryBeacon\t\t= 0;\n\t\tpHTInfoEle->LSigTxopProtectFull\t\t= 0;\n\t\tpHTInfoEle->PcoActive\t\t\t= 0;\n\t\tpHTInfoEle->PcoPhase\t\t\t= 0;\n\n\t\tmemset(pHTInfoEle->BasicMSC, 0, 16);\n\n\t\t*len = 22 + 2;\n\n\t} else {\n\t\t*len = 0;\n\t}\n}\n\nvoid HTConstructRT2RTAggElement(struct rtllib_device *ieee, u8 *posRT2RTAgg,\n\t\t\t\tu8 *len)\n{\n\tif (!posRT2RTAgg) {\n\t\tnetdev_warn(ieee->dev, \"%s(): posRT2RTAgg is null\\n\", __func__);\n\t\treturn;\n\t}\n\tmemset(posRT2RTAgg, 0, *len);\n\t*posRT2RTAgg++ = 0x00;\n\t*posRT2RTAgg++ = 0xe0;\n\t*posRT2RTAgg++ = 0x4c;\n\t*posRT2RTAgg++ = 0x02;\n\t*posRT2RTAgg++ = 0x01;\n\n\t*posRT2RTAgg = 0x30;\n\n\tif (ieee->bSupportRemoteWakeUp)\n\t\t*posRT2RTAgg |= RT_HT_CAP_USE_WOW;\n\n\t*len = 6 + 2;\n}\n\nstatic u8 HT_PickMCSRate(struct rtllib_device *ieee, u8 *pOperateMCS)\n{\n\tu8 i;\n\n\tif (!pOperateMCS) {\n\t\tnetdev_warn(ieee->dev, \"%s(): pOperateMCS is null\\n\", __func__);\n\t\treturn false;\n\t}\n\n\tswitch (ieee->mode) {\n\tcase WIRELESS_MODE_B:\n\tcase WIRELESS_MODE_G:\n\t\tfor (i = 0; i <= 15; i++)\n\t\t\tpOperateMCS[i] = 0;\n\t\tbreak;\n\tcase WIRELESS_MODE_N_24G:\n\t\tpOperateMCS[0] &= RATE_ADPT_1SS_MASK;\n\t\tpOperateMCS[1] &= RATE_ADPT_2SS_MASK;\n\t\tpOperateMCS[3] &= RATE_ADPT_MCS32_MASK;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nu8 HTGetHighestMCSRate(struct rtllib_device *ieee, u8 *pMCSRateSet,\n\t\t       u8 *pMCSFilter)\n{\n\tu8\t\ti, j;\n\tu8\t\tbitMap;\n\tu8\t\tmcsRate = 0;\n\tu8\t\tavailableMcsRate[16];\n\n\tif (!pMCSRateSet || !pMCSFilter) {\n\t\tnetdev_warn(ieee->dev,\n\t\t\t    \"%s(): pMCSRateSet and pMCSFilter are null\\n\",\n\t\t\t    __func__);\n\t\treturn false;\n\t}\n\tfor (i = 0; i < 16; i++)\n\t\tavailableMcsRate[i] = pMCSRateSet[i] & pMCSFilter[i];\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (availableMcsRate[i] != 0)\n\t\t\tbreak;\n\t}\n\tif (i == 16)\n\t\treturn false;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (availableMcsRate[i] != 0) {\n\t\t\tbitMap = availableMcsRate[i];\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tif ((bitMap % 2) != 0) {\n\t\t\t\t\tif (HTMcsToDataRate(ieee, (8 * i + j)) >\n\t\t\t\t\t    HTMcsToDataRate(ieee, mcsRate))\n\t\t\t\t\t\tmcsRate = 8 * i + j;\n\t\t\t\t}\n\t\t\t\tbitMap >>= 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn mcsRate | 0x80;\n}\n\nstatic u8 HTFilterMCSRate(struct rtllib_device *ieee, u8 *pSupportMCS,\n\t\t\t  u8 *pOperateMCS)\n{\n\tu8 i;\n\n\tfor (i = 0; i <= 15; i++)\n\t\tpOperateMCS[i] = ieee->reg_dot11tx_ht_oper_rate_set[i] &\n\t\t\t\t pSupportMCS[i];\n\n\tHT_PickMCSRate(ieee, pOperateMCS);\n\n\tif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))\n\t\tpOperateMCS[1] = 0;\n\n\tfor (i = 2; i <= 15; i++)\n\t\tpOperateMCS[i] = 0;\n\n\treturn true;\n}\n\nvoid HTSetConnectBwMode(struct rtllib_device *ieee,\n\t\t\tenum ht_channel_width bandwidth,\n\t\t\tenum ht_extchnl_offset Offset);\n\nvoid HTOnAssocRsp(struct rtllib_device *ieee)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\tstruct ht_capab_ele *pPeerHTCap = NULL;\n\tstruct ht_info_ele *pPeerHTInfo = NULL;\n\tu16 nMaxAMSDUSize = 0;\n\tu8 *pMcsFilter = NULL;\n\n\tstatic const u8 EWC11NHTCap[] = { 0x00, 0x90, 0x4c, 0x33 };\n\tstatic const u8 EWC11NHTInfo[] = { 0x00, 0x90, 0x4c, 0x34 };\n\n\tif (!ht_info->bCurrentHTSupport) {\n\t\tnetdev_warn(ieee->dev, \"%s(): HT_DISABLE\\n\", __func__);\n\t\treturn;\n\t}\n\tnetdev_dbg(ieee->dev, \"%s(): HT_ENABLE\\n\", __func__);\n\n\tif (!memcmp(ht_info->PeerHTCapBuf, EWC11NHTCap, sizeof(EWC11NHTCap)))\n\t\tpPeerHTCap = (struct ht_capab_ele *)(&ht_info->PeerHTCapBuf[4]);\n\telse\n\t\tpPeerHTCap = (struct ht_capab_ele *)(ht_info->PeerHTCapBuf);\n\n\tif (!memcmp(ht_info->PeerHTInfoBuf, EWC11NHTInfo, sizeof(EWC11NHTInfo)))\n\t\tpPeerHTInfo = (struct ht_info_ele *)\n\t\t\t     (&ht_info->PeerHTInfoBuf[4]);\n\telse\n\t\tpPeerHTInfo = (struct ht_info_ele *)(ht_info->PeerHTInfoBuf);\n\n#ifdef VERBOSE_DEBUG\n\tprint_hex_dump_bytes(\"%s: \", __func__, DUMP_PREFIX_NONE,\n\t\t\t     pPeerHTCap, sizeof(struct ht_capab_ele));\n#endif\n\tHTSetConnectBwMode(ieee, (enum ht_channel_width)(pPeerHTCap->ChlWidth),\n\t\t\t   (enum ht_extchnl_offset)(pPeerHTInfo->ExtChlOffset));\n\tht_info->cur_tx_bw40mhz = ((pPeerHTInfo->RecommemdedTxWidth == 1) ?\n\t\t\t\t true : false);\n\n\tht_info->bCurShortGI20MHz = ((ht_info->bRegShortGI20MHz) ?\n\t\t\t\t    ((pPeerHTCap->ShortGI20Mhz == 1) ?\n\t\t\t\t    true : false) : false);\n\tht_info->bCurShortGI40MHz = ((ht_info->bRegShortGI40MHz) ?\n\t\t\t\t     ((pPeerHTCap->ShortGI40Mhz == 1) ?\n\t\t\t\t     true : false) : false);\n\n\tht_info->bCurSuppCCK = ((ht_info->bRegSuppCCK) ?\n\t\t\t       ((pPeerHTCap->DssCCk == 1) ? true :\n\t\t\t       false) : false);\n\n\tht_info->bCurrent_AMSDU_Support = ht_info->bAMSDU_Support;\n\n\tnMaxAMSDUSize = (pPeerHTCap->MaxAMSDUSize == 0) ? 3839 : 7935;\n\n\tif (ht_info->nAMSDU_MaxSize > nMaxAMSDUSize)\n\t\tht_info->nCurrent_AMSDU_MaxSize = nMaxAMSDUSize;\n\telse\n\t\tht_info->nCurrent_AMSDU_MaxSize = ht_info->nAMSDU_MaxSize;\n\n\tht_info->bCurrentAMPDUEnable = ht_info->bAMPDUEnable;\n\tif (ieee->rtllib_ap_sec_type &&\n\t    (ieee->rtllib_ap_sec_type(ieee) & (SEC_ALG_WEP | SEC_ALG_TKIP))) {\n\t\tif ((ht_info->IOTPeer == HT_IOT_PEER_ATHEROS) ||\n\t\t    (ht_info->IOTPeer == HT_IOT_PEER_UNKNOWN))\n\t\t\tht_info->bCurrentAMPDUEnable = false;\n\t}\n\n\tif (!ht_info->reg_rt2rt_aggregation) {\n\t\tif (ht_info->AMPDU_Factor > pPeerHTCap->MaxRxAMPDUFactor)\n\t\t\tht_info->CurrentAMPDUFactor =\n\t\t\t\t\t\t pPeerHTCap->MaxRxAMPDUFactor;\n\t\telse\n\t\t\tht_info->CurrentAMPDUFactor = ht_info->AMPDU_Factor;\n\n\t} else {\n\t\tif (ieee->current_network.bssht.bd_rt2rt_aggregation) {\n\t\t\tif (ieee->pairwise_key_type != KEY_TYPE_NA)\n\t\t\t\tht_info->CurrentAMPDUFactor =\n\t\t\t\t\t\t pPeerHTCap->MaxRxAMPDUFactor;\n\t\t\telse\n\t\t\t\tht_info->CurrentAMPDUFactor = HT_AGG_SIZE_64K;\n\t\t} else {\n\t\t\tht_info->CurrentAMPDUFactor = min_t(u32, pPeerHTCap->MaxRxAMPDUFactor,\n\t\t\t\t\t\t\t    HT_AGG_SIZE_32K);\n\t\t}\n\t}\n\tht_info->current_mpdu_density = max_t(u8, ht_info->MPDU_Density,\n\t\t\t\t\t      pPeerHTCap->MPDUDensity);\n\tif (ht_info->iot_action & HT_IOT_ACT_TX_USE_AMSDU_8K) {\n\t\tht_info->bCurrentAMPDUEnable = false;\n\t\tht_info->ForcedAMSDUMode = HT_AGG_FORCE_ENABLE;\n\t}\n\tht_info->cur_rx_reorder_enable = ht_info->reg_rx_reorder_enable;\n\n\tif (pPeerHTCap->MCS[0] == 0)\n\t\tpPeerHTCap->MCS[0] = 0xff;\n\n\tHTIOTActDetermineRaFunc(ieee, ((pPeerHTCap->MCS[1]) != 0));\n\n\tHTFilterMCSRate(ieee, pPeerHTCap->MCS, ieee->dot11ht_oper_rate_set);\n\n\tht_info->peer_mimo_ps = pPeerHTCap->MimoPwrSave;\n\tif (ht_info->peer_mimo_ps == MIMO_PS_STATIC)\n\t\tpMcsFilter = MCS_FILTER_1SS;\n\telse\n\t\tpMcsFilter = MCS_FILTER_ALL;\n\tieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee,\n\t\t\t\t\t\t       ieee->dot11ht_oper_rate_set,\n\t\t\t\t\t\t       pMcsFilter);\n\tieee->HTCurrentOperaRate = ieee->HTHighestOperaRate;\n\n\tht_info->current_op_mode = pPeerHTInfo->OptMode;\n}\n\nvoid HTInitializeHTInfo(struct rtllib_device *ieee)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\n\tht_info->bCurrentHTSupport = false;\n\n\tht_info->bCurBW40MHz = false;\n\tht_info->cur_tx_bw40mhz = false;\n\n\tht_info->bCurShortGI20MHz = false;\n\tht_info->bCurShortGI40MHz = false;\n\tht_info->forced_short_gi = false;\n\n\tht_info->bCurSuppCCK = true;\n\n\tht_info->bCurrent_AMSDU_Support = false;\n\tht_info->nCurrent_AMSDU_MaxSize = ht_info->nAMSDU_MaxSize;\n\tht_info->current_mpdu_density = ht_info->MPDU_Density;\n\tht_info->CurrentAMPDUFactor = ht_info->AMPDU_Factor;\n\n\tmemset((void *)(&ht_info->SelfHTCap), 0,\n\t       sizeof(ht_info->SelfHTCap));\n\tmemset((void *)(&ht_info->SelfHTInfo), 0,\n\t       sizeof(ht_info->SelfHTInfo));\n\tmemset((void *)(&ht_info->PeerHTCapBuf), 0,\n\t       sizeof(ht_info->PeerHTCapBuf));\n\tmemset((void *)(&ht_info->PeerHTInfoBuf), 0,\n\t       sizeof(ht_info->PeerHTInfoBuf));\n\n\tht_info->sw_bw_in_progress = false;\n\n\tht_info->ePeerHTSpecVer = HT_SPEC_VER_IEEE;\n\n\tht_info->current_rt2rt_aggregation = false;\n\tht_info->current_rt2rt_long_slot_time = false;\n\tht_info->RT2RT_HT_Mode = (enum rt_ht_capability)0;\n\n\tht_info->IOTPeer = 0;\n\tht_info->iot_action = 0;\n\tht_info->iot_ra_func = 0;\n\n\t{\n\t\tu8 *RegHTSuppRateSets = &ieee->reg_ht_supp_rate_set[0];\n\n\t\tRegHTSuppRateSets[0] = 0xFF;\n\t\tRegHTSuppRateSets[1] = 0xFF;\n\t\tRegHTSuppRateSets[4] = 0x01;\n\t}\n}\n\nvoid HTInitializeBssDesc(struct bss_ht *pBssHT)\n{\n\tpBssHT->bd_support_ht = false;\n\tmemset(pBssHT->bd_ht_cap_buf, 0, sizeof(pBssHT->bd_ht_cap_buf));\n\tpBssHT->bd_ht_cap_len = 0;\n\tmemset(pBssHT->bd_ht_info_buf, 0, sizeof(pBssHT->bd_ht_info_buf));\n\tpBssHT->bd_ht_info_len = 0;\n\n\tpBssHT->bd_ht_spec_ver = HT_SPEC_VER_IEEE;\n\n\tpBssHT->bd_rt2rt_aggregation = false;\n\tpBssHT->bd_rt2rt_long_slot_time = false;\n\tpBssHT->rt2rt_ht_mode = (enum rt_ht_capability)0;\n}\n\nvoid HTResetSelfAndSavePeerSetting(struct rtllib_device *ieee,\n\t\t\t\t   struct rtllib_network *pNetwork)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\tu8\tbIOTAction = 0;\n\n\t \n\tif (pNetwork->bssht.bd_support_ht) {\n\t\tht_info->bCurrentHTSupport = true;\n\t\tht_info->ePeerHTSpecVer = pNetwork->bssht.bd_ht_spec_ver;\n\n\t\tif (pNetwork->bssht.bd_ht_cap_len > 0 &&\n\t\t    pNetwork->bssht.bd_ht_cap_len <= sizeof(ht_info->PeerHTCapBuf))\n\t\t\tmemcpy(ht_info->PeerHTCapBuf,\n\t\t\t       pNetwork->bssht.bd_ht_cap_buf,\n\t\t\t       pNetwork->bssht.bd_ht_cap_len);\n\n\t\tif (pNetwork->bssht.bd_ht_info_len > 0 &&\n\t\t    pNetwork->bssht.bd_ht_info_len <=\n\t\t    sizeof(ht_info->PeerHTInfoBuf))\n\t\t\tmemcpy(ht_info->PeerHTInfoBuf,\n\t\t\t       pNetwork->bssht.bd_ht_info_buf,\n\t\t\t       pNetwork->bssht.bd_ht_info_len);\n\n\t\tif (ht_info->reg_rt2rt_aggregation) {\n\t\t\tht_info->current_rt2rt_aggregation =\n\t\t\t\t pNetwork->bssht.bd_rt2rt_aggregation;\n\t\t\tht_info->current_rt2rt_long_slot_time =\n\t\t\t\t pNetwork->bssht.bd_rt2rt_long_slot_time;\n\t\t\tht_info->RT2RT_HT_Mode = pNetwork->bssht.rt2rt_ht_mode;\n\t\t} else {\n\t\t\tht_info->current_rt2rt_aggregation = false;\n\t\t\tht_info->current_rt2rt_long_slot_time = false;\n\t\t\tht_info->RT2RT_HT_Mode = (enum rt_ht_capability)0;\n\t\t}\n\n\t\tHTIOTPeerDetermine(ieee);\n\n\t\tht_info->iot_action = 0;\n\t\tbIOTAction = HTIOTActIsDisableMCS14(ieee, pNetwork->bssid);\n\t\tif (bIOTAction)\n\t\t\tht_info->iot_action |= HT_IOT_ACT_DISABLE_MCS14;\n\n\t\tbIOTAction = HTIOTActIsDisableMCS15(ieee);\n\t\tif (bIOTAction)\n\t\t\tht_info->iot_action |= HT_IOT_ACT_DISABLE_MCS15;\n\n\t\tbIOTAction = HTIOTActIsDisableMCSTwoSpatialStream(ieee);\n\t\tif (bIOTAction)\n\t\t\tht_info->iot_action |= HT_IOT_ACT_DISABLE_ALL_2SS;\n\n\t\tbIOTAction = HTIOTActIsDisableEDCATurbo(ieee, pNetwork->bssid);\n\t\tif (bIOTAction)\n\t\t\tht_info->iot_action |= HT_IOT_ACT_DISABLE_EDCA_TURBO;\n\n\t\tbIOTAction = HTIOTActIsMgntUseCCK6M(ieee, pNetwork);\n\t\tif (bIOTAction)\n\t\t\tht_info->iot_action |= HT_IOT_ACT_MGNT_USE_CCK_6M;\n\t\tbIOTAction = HTIOTActIsCCDFsync(ieee);\n\t\tif (bIOTAction)\n\t\t\tht_info->iot_action |= HT_IOT_ACT_CDD_FSYNC;\n\t} else {\n\t\tht_info->bCurrentHTSupport = false;\n\t\tht_info->current_rt2rt_aggregation = false;\n\t\tht_info->current_rt2rt_long_slot_time = false;\n\t\tht_info->RT2RT_HT_Mode = (enum rt_ht_capability)0;\n\n\t\tht_info->iot_action = 0;\n\t\tht_info->iot_ra_func = 0;\n\t}\n}\n\nvoid HT_update_self_and_peer_setting(struct rtllib_device *ieee,\n\t\t\t\t     struct rtllib_network *pNetwork)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\tstruct ht_info_ele *pPeerHTInfo =\n\t\t (struct ht_info_ele *)pNetwork->bssht.bd_ht_info_buf;\n\n\tif (ht_info->bCurrentHTSupport) {\n\t\tif (pNetwork->bssht.bd_ht_info_len != 0)\n\t\t\tht_info->current_op_mode = pPeerHTInfo->OptMode;\n\t}\n}\nEXPORT_SYMBOL(HT_update_self_and_peer_setting);\n\nvoid HTUseDefaultSetting(struct rtllib_device *ieee)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\n\tif (ht_info->enable_ht) {\n\t\tht_info->bCurrentHTSupport = true;\n\t\tht_info->bCurSuppCCK = ht_info->bRegSuppCCK;\n\n\t\tht_info->bCurBW40MHz = ht_info->bRegBW40MHz;\n\t\tht_info->bCurShortGI20MHz = ht_info->bRegShortGI20MHz;\n\n\t\tht_info->bCurShortGI40MHz = ht_info->bRegShortGI40MHz;\n\n\t\tif (ieee->iw_mode == IW_MODE_ADHOC)\n\t\t\tieee->current_network.qos_data.active =\n\t\t\t\t ieee->current_network.qos_data.supported;\n\t\tht_info->bCurrent_AMSDU_Support = ht_info->bAMSDU_Support;\n\t\tht_info->nCurrent_AMSDU_MaxSize = ht_info->nAMSDU_MaxSize;\n\n\t\tht_info->bCurrentAMPDUEnable = ht_info->bAMPDUEnable;\n\t\tht_info->CurrentAMPDUFactor = ht_info->AMPDU_Factor;\n\n\t\tht_info->current_mpdu_density = ht_info->current_mpdu_density;\n\n\t\tHTFilterMCSRate(ieee, ieee->reg_dot11tx_ht_oper_rate_set,\n\t\t\t\tieee->dot11ht_oper_rate_set);\n\t\tieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee,\n\t\t\t\t\t\t\t       ieee->dot11ht_oper_rate_set,\n\t\t\t\t\t\t\t       MCS_FILTER_ALL);\n\t\tieee->HTCurrentOperaRate = ieee->HTHighestOperaRate;\n\n\t} else {\n\t\tht_info->bCurrentHTSupport = false;\n\t}\n}\n\nu8 HTCCheck(struct rtllib_device *ieee, u8 *pFrame)\n{\n\tif (ieee->ht_info->bCurrentHTSupport) {\n\t\tif ((IsQoSDataFrame(pFrame) && Frame_Order(pFrame)) == 1) {\n\t\t\tnetdev_dbg(ieee->dev, \"HT CONTROL FILED EXIST!!\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void HTSetConnectBwModeCallback(struct rtllib_device *ieee)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\n\tif (ht_info->bCurBW40MHz) {\n\t\tif (ht_info->CurSTAExtChnlOffset == HT_EXTCHNL_OFFSET_UPPER)\n\t\t\tieee->set_chan(ieee->dev,\n\t\t\t\t       ieee->current_network.channel + 2);\n\t\telse if (ht_info->CurSTAExtChnlOffset ==\n\t\t\t HT_EXTCHNL_OFFSET_LOWER)\n\t\t\tieee->set_chan(ieee->dev,\n\t\t\t\t       ieee->current_network.channel - 2);\n\t\telse\n\t\t\tieee->set_chan(ieee->dev,\n\t\t\t\t       ieee->current_network.channel);\n\n\t\tieee->set_bw_mode_handler(ieee->dev, HT_CHANNEL_WIDTH_20_40,\n\t\t\t\t       ht_info->CurSTAExtChnlOffset);\n\t} else {\n\t\tieee->set_chan(ieee->dev, ieee->current_network.channel);\n\t\tieee->set_bw_mode_handler(ieee->dev, HT_CHANNEL_WIDTH_20,\n\t\t\t\t       HT_EXTCHNL_OFFSET_NO_EXT);\n\t}\n\n\tht_info->sw_bw_in_progress = false;\n}\n\nvoid HTSetConnectBwMode(struct rtllib_device *ieee,\n\t\t\tenum ht_channel_width bandwidth,\n\t\t\tenum ht_extchnl_offset Offset)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\n\tif (!ht_info->bRegBW40MHz)\n\t\treturn;\n\n\tif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))\n\t\tbandwidth = HT_CHANNEL_WIDTH_20;\n\n\tif (ht_info->sw_bw_in_progress) {\n\t\tpr_info(\"%s: sw_bw_in_progress!!\\n\", __func__);\n\t\treturn;\n\t}\n\tif (bandwidth == HT_CHANNEL_WIDTH_20_40) {\n\t\tif (ieee->current_network.channel < 2 &&\n\t\t    Offset == HT_EXTCHNL_OFFSET_LOWER)\n\t\t\tOffset = HT_EXTCHNL_OFFSET_NO_EXT;\n\t\tif (Offset == HT_EXTCHNL_OFFSET_UPPER ||\n\t\t    Offset == HT_EXTCHNL_OFFSET_LOWER) {\n\t\t\tht_info->bCurBW40MHz = true;\n\t\t\tht_info->CurSTAExtChnlOffset = Offset;\n\t\t} else {\n\t\t\tht_info->bCurBW40MHz = false;\n\t\t\tht_info->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;\n\t\t}\n\t} else {\n\t\tht_info->bCurBW40MHz = false;\n\t\tht_info->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;\n\t}\n\n\tnetdev_dbg(ieee->dev, \"%s():ht_info->bCurBW40MHz:%x\\n\", __func__,\n\t\t   ht_info->bCurBW40MHz);\n\n\tht_info->sw_bw_in_progress = true;\n\n\tHTSetConnectBwModeCallback(ieee);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}