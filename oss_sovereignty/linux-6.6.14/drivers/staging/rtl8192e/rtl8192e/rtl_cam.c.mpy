{
  "module_name": "rtl_cam.c",
  "hash_id": "096a87d45541a88a0a635753a99d110841a2939385c78b5c03b92fe45fd41c77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtl8192e/rtl_cam.c",
  "human_readable_source": "\n \n#include \"rtl_core.h\"\n#include \"r8192E_phy.h\"\n#include \"r8192E_phyreg.h\"\n#include \"r8190P_rtl8256.h\"  \n#include \"r8192E_cmdpkt.h\"\n\nvoid rtl92e_cam_reset(struct net_device *dev)\n{\n\tu32 ulcommand = 0;\n\n\tulcommand |= BIT31 | BIT30;\n\trtl92e_writel(dev, RWCAM, ulcommand);\n}\n\nvoid rtl92e_enable_hw_security_config(struct net_device *dev)\n{\n\tu8 SECR_value = 0x0;\n\tstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\n\tSECR_value = SCR_TxEncEnable | SCR_RxDecEnable;\n\tif (((ieee->pairwise_key_type == KEY_TYPE_WEP40) ||\n\t     (ieee->pairwise_key_type == KEY_TYPE_WEP104)) &&\n\t     (priv->rtllib->auth_mode != 2)) {\n\t\tSECR_value |= SCR_RxUseDK;\n\t\tSECR_value |= SCR_TxUseDK;\n\t} else if ((ieee->iw_mode == IW_MODE_ADHOC) &&\n\t\t   (ieee->pairwise_key_type & (KEY_TYPE_CCMP |\n\t\t   KEY_TYPE_TKIP))) {\n\t\tSECR_value |= SCR_RxUseDK;\n\t\tSECR_value |= SCR_TxUseDK;\n\t}\n\n\tieee->hwsec_active = 1;\n\tif ((ieee->ht_info->iot_action & HT_IOT_ACT_PURE_N_MODE) || !hwwep) {\n\t\tieee->hwsec_active = 0;\n\t\tSECR_value &= ~SCR_RxDecEnable;\n\t}\n\trtl92e_writeb(dev, SECR, SECR_value);\n}\n\nvoid rtl92e_set_swcam(struct net_device *dev, u8 EntryNo, u8 KeyIndex,\n\t\t      u16 KeyType, const u8 *MacAddr, u32 *KeyContent)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\n\tif (EntryNo >= TOTAL_CAM_ENTRY)\n\t\treturn;\n\n\tieee->swcamtable[EntryNo].bused = true;\n\tieee->swcamtable[EntryNo].key_index = KeyIndex;\n\tieee->swcamtable[EntryNo].key_type = KeyType;\n\tmemcpy(ieee->swcamtable[EntryNo].macaddr, MacAddr, 6);\n\tieee->swcamtable[EntryNo].useDK = 0;\n\tmemcpy(ieee->swcamtable[EntryNo].key_buf, (u8 *)KeyContent, 16);\n}\n\nvoid rtl92e_set_key(struct net_device *dev, u8 EntryNo, u8 KeyIndex,\n\t\t    u16 KeyType, const u8 *MacAddr, u8 DefaultKey,\n\t\t    u32 *KeyContent)\n{\n\tu32 TargetCommand = 0;\n\tu32 TargetContent = 0;\n\tu16 usConfig = 0;\n\tu8 i;\n\tstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\n\tenum rt_rf_power_state rt_state;\n\n\trt_state = priv->rtllib->rf_power_state;\n\tif (rt_state == rf_off) {\n\t\tif (priv->rtllib->rf_off_reason > RF_CHANGE_BY_IPS) {\n\t\t\tnetdev_warn(dev, \"%s(): RF is OFF.\\n\",\n\t\t\t\t    __func__);\n\t\t\treturn;\n\t\t}\n\t\tmutex_lock(&priv->rtllib->ips_mutex);\n\t\trtl92e_ips_leave(dev);\n\t\tmutex_unlock(&priv->rtllib->ips_mutex);\n\t}\n\tpriv->rtllib->is_set_key = true;\n\tif (EntryNo >= TOTAL_CAM_ENTRY) {\n\t\tnetdev_info(dev, \"%s(): Invalid CAM entry\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (DefaultKey)\n\t\tusConfig |= BIT15 | (KeyType << 2);\n\telse\n\t\tusConfig |= BIT15 | (KeyType << 2) | KeyIndex;\n\n\tfor (i = 0; i < CAM_CONTENT_COUNT; i++) {\n\t\tTargetCommand  = i + CAM_CONTENT_COUNT * EntryNo;\n\t\tTargetCommand |= BIT31 | BIT16;\n\n\t\tif (i == 0) {\n\t\t\tTargetContent = (u32)(*(MacAddr + 0)) << 16 |\n\t\t\t\t(u32)(*(MacAddr + 1)) << 24 |\n\t\t\t\t(u32)usConfig;\n\n\t\t\trtl92e_writel(dev, WCAMI, TargetContent);\n\t\t\trtl92e_writel(dev, RWCAM, TargetCommand);\n\t\t} else if (i == 1) {\n\t\t\tTargetContent = (u32)(*(MacAddr + 2)) |\n\t\t\t\t(u32)(*(MacAddr + 3)) <<  8 |\n\t\t\t\t(u32)(*(MacAddr + 4)) << 16 |\n\t\t\t\t(u32)(*(MacAddr + 5)) << 24;\n\t\t\trtl92e_writel(dev, WCAMI, TargetContent);\n\t\t\trtl92e_writel(dev, RWCAM, TargetCommand);\n\t\t} else {\n\t\t\tif (KeyContent != NULL) {\n\t\t\t\trtl92e_writel(dev, WCAMI,\n\t\t\t\t\t      (u32)(*(KeyContent + i - 2)));\n\t\t\t\trtl92e_writel(dev, RWCAM, TargetCommand);\n\t\t\t\tudelay(100);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid rtl92e_cam_restore(struct net_device *dev)\n{\n\tu8 EntryId = 0;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8 *MacAddr = priv->rtllib->current_network.bssid;\n\n\tstatic u8\tCAM_CONST_ADDR[4][6] = {\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x03}\n\t};\n\tstatic u8\tCAM_CONST_BROAD[] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n\t};\n\n\tif ((priv->rtllib->pairwise_key_type == KEY_TYPE_WEP40) ||\n\t    (priv->rtllib->pairwise_key_type == KEY_TYPE_WEP104)) {\n\t\tfor (EntryId = 0; EntryId < 4; EntryId++) {\n\t\t\tMacAddr = CAM_CONST_ADDR[EntryId];\n\t\t\tif (priv->rtllib->swcamtable[EntryId].bused) {\n\t\t\t\trtl92e_set_key(dev, EntryId, EntryId,\n\t\t\t\t\t       priv->rtllib->pairwise_key_type,\n\t\t\t\t\t       MacAddr, 0,\n\t\t\t\t\t       (u32 *)(&priv->rtllib->swcamtable\n\t\t\t\t\t\t       [EntryId].key_buf[0]));\n\t\t\t}\n\t\t}\n\n\t} else if (priv->rtllib->pairwise_key_type == KEY_TYPE_TKIP) {\n\t\tif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\n\t\t\trtl92e_set_key(dev, 4, 0,\n\t\t\t\t       priv->rtllib->pairwise_key_type,\n\t\t\t\t       (const u8 *)dev->dev_addr, 0,\n\t\t\t\t       (u32 *)(&priv->rtllib->swcamtable[4].key_buf[0]));\n\t\t} else {\n\t\t\trtl92e_set_key(dev, 4, 0,\n\t\t\t\t       priv->rtllib->pairwise_key_type,\n\t\t\t\t       MacAddr, 0,\n\t\t\t\t       (u32 *)(&priv->rtllib->swcamtable[4].key_buf[0]));\n\t\t}\n\n\t} else if (priv->rtllib->pairwise_key_type == KEY_TYPE_CCMP) {\n\t\tif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\n\t\t\trtl92e_set_key(dev, 4, 0,\n\t\t\t\t       priv->rtllib->pairwise_key_type,\n\t\t\t\t       (const u8 *)dev->dev_addr, 0,\n\t\t\t\t       (u32 *)(&priv->rtllib->swcamtable[4].key_buf[0]));\n\t\t} else {\n\t\t\trtl92e_set_key(dev, 4, 0,\n\t\t\t\t       priv->rtllib->pairwise_key_type, MacAddr,\n\t\t\t\t       0, (u32 *)(&priv->rtllib->swcamtable[4].key_buf[0]));\n\t\t\t}\n\t}\n\n\tif (priv->rtllib->group_key_type == KEY_TYPE_TKIP) {\n\t\tMacAddr = CAM_CONST_BROAD;\n\t\tfor (EntryId = 1; EntryId < 4; EntryId++) {\n\t\t\tif (priv->rtllib->swcamtable[EntryId].bused) {\n\t\t\t\trtl92e_set_key(dev, EntryId, EntryId,\n\t\t\t\t\t       priv->rtllib->group_key_type,\n\t\t\t\t\t       MacAddr, 0,\n\t\t\t\t\t       (u32 *)(&priv->rtllib->swcamtable[EntryId].key_buf[0]));\n\t\t\t}\n\t\t}\n\t\tif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\n\t\t\tif (priv->rtllib->swcamtable[0].bused) {\n\t\t\t\trtl92e_set_key(dev, 0, 0,\n\t\t\t\t\t       priv->rtllib->group_key_type,\n\t\t\t\t\t       CAM_CONST_ADDR[0], 0,\n\t\t\t\t\t       (u32 *)(&priv->rtllib->swcamtable[0].key_buf[0]));\n\t\t\t} else {\n\t\t\t\tnetdev_warn(dev,\n\t\t\t\t\t    \"%s(): ADHOC TKIP: missing key entry.\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else if (priv->rtllib->group_key_type == KEY_TYPE_CCMP) {\n\t\tMacAddr = CAM_CONST_BROAD;\n\t\tfor (EntryId = 1; EntryId < 4; EntryId++) {\n\t\t\tif (priv->rtllib->swcamtable[EntryId].bused) {\n\t\t\t\trtl92e_set_key(dev, EntryId, EntryId,\n\t\t\t\t\t       priv->rtllib->group_key_type,\n\t\t\t\t\t       MacAddr, 0,\n\t\t\t\t\t       (u32 *)(&priv->rtllib->swcamtable[EntryId].key_buf[0]));\n\t\t\t}\n\t\t}\n\n\t\tif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\n\t\t\tif (priv->rtllib->swcamtable[0].bused) {\n\t\t\t\trtl92e_set_key(dev, 0, 0,\n\t\t\t\t\t       priv->rtllib->group_key_type,\n\t\t\t\t\t       CAM_CONST_ADDR[0], 0,\n\t\t\t\t\t       (u32 *)(&priv->rtllib->swcamtable[0].key_buf[0]));\n\t\t\t} else {\n\t\t\t\tnetdev_warn(dev,\n\t\t\t\t\t    \"%s(): ADHOC CCMP: missing key entry.\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}