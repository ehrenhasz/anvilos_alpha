{
  "module_name": "r8190P_rtl8256.c",
  "hash_id": "76068b05304dc3adc91703baa8d49c882cfb7fb0596fae0b11231a10aac15ea1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtl8192e/r8190P_rtl8256.c",
  "human_readable_source": "\n \n#include \"rtl_core.h\"\n#include \"r8192E_phyreg.h\"\n#include \"r8192E_phy.h\"\n#include \"r8190P_rtl8256.h\"\n\nvoid rtl92e_set_bandwidth(struct net_device *dev,\n\t\t\t  enum ht_channel_width bandwidth)\n{\n\tu8\teRFPath;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->card_8192_version != VERSION_8190_BD &&\n\t    priv->card_8192_version != VERSION_8190_BE) {\n\t\tnetdev_warn(dev, \"%s(): Unknown HW version.\\n\", __func__);\n\t\treturn;\n\t}\n\n\tfor (eRFPath = 0; eRFPath < priv->num_total_rf_path; eRFPath++) {\n\t\tswitch (bandwidth) {\n\t\tcase HT_CHANNEL_WIDTH_20:\n\t\t\trtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath,\n\t\t\t\t\t  0x0b, bMask12Bits, 0x100);\n\t\t\trtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath,\n\t\t\t\t\t  0x2c, bMask12Bits, 0x3d7);\n\t\t\trtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath,\n\t\t\t\t\t  0x0e, bMask12Bits, 0x021);\n\t\t\tbreak;\n\t\tcase HT_CHANNEL_WIDTH_20_40:\n\t\t\trtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath,\n\t\t\t\t\t  0x0b, bMask12Bits, 0x300);\n\t\t\trtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath,\n\t\t\t\t\t  0x2c, bMask12Bits, 0x3ff);\n\t\t\trtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath,\n\t\t\t\t\t  0x0e, bMask12Bits, 0x0e1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_err(dev, \"%s(): Unknown bandwidth: %#X\\n\",\n\t\t\t\t   __func__, bandwidth);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nbool rtl92e_config_rf(struct net_device *dev)\n{\n\tu32\tu4RegValue = 0;\n\tu8\teRFPath;\n\tbool rtStatus = true;\n\tstruct bb_reg_definition *pPhyReg;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu32\tRegOffSetToBeCheck = 0x3;\n\tu32\tRegValueToBeCheck = 0x7f1;\n\tu32\tRF3_Final_Value = 0;\n\tu8\tConstRetryTimes = 5, RetryTimes = 5;\n\tu8 ret = 0;\n\n\tpriv->num_total_rf_path = RTL819X_TOTAL_RF_PATH;\n\n\tfor (eRFPath = (enum rf90_radio_path)RF90_PATH_A;\n\t     eRFPath < priv->num_total_rf_path; eRFPath++) {\n\t\tpPhyReg = &priv->phy_reg_def[eRFPath];\n\n\t\tswitch (eRFPath) {\n\t\tcase RF90_PATH_A:\n\t\t\tu4RegValue = rtl92e_get_bb_reg(dev, pPhyReg->rfintfs,\n\t\t\t\t\t\t       bRFSI_RFENV);\n\t\t\tbreak;\n\t\tcase RF90_PATH_B:\n\t\t\tu4RegValue = rtl92e_get_bb_reg(dev, pPhyReg->rfintfs,\n\t\t\t\t\t\t       bRFSI_RFENV << 16);\n\t\t\tbreak;\n\t\t}\n\n\t\trtl92e_set_bb_reg(dev, pPhyReg->rfintfe, bRFSI_RFENV << 16, 0x1);\n\n\t\trtl92e_set_bb_reg(dev, pPhyReg->rfintfo, bRFSI_RFENV, 0x1);\n\n\t\trtl92e_set_bb_reg(dev, pPhyReg->rfHSSIPara2,\n\t\t\t\t  b3WireAddressLength, 0x0);\n\t\trtl92e_set_bb_reg(dev, pPhyReg->rfHSSIPara2,\n\t\t\t\t  b3WireDataLength, 0x0);\n\n\t\trtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath, 0x0,\n\t\t\t\t  bMask12Bits, 0xbf);\n\n\t\trtStatus = rtl92e_check_bb_and_rf(dev, HW90_BLOCK_RF,\n\t\t\t\t\t\t  (enum rf90_radio_path)eRFPath);\n\t\tif (!rtStatus) {\n\t\t\tnetdev_err(dev, \"%s(): Failed to check RF Path %d.\\n\",\n\t\t\t\t   __func__, eRFPath);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tRetryTimes = ConstRetryTimes;\n\t\tRF3_Final_Value = 0;\n\t\twhile (RF3_Final_Value != RegValueToBeCheck &&\n\t\t       RetryTimes != 0) {\n\t\t\tret = rtl92e_config_rf_path(dev,\n\t\t\t\t\t\t(enum rf90_radio_path)eRFPath);\n\t\t\tRF3_Final_Value = rtl92e_get_rf_reg(dev,\n\t\t\t\t\t\t(enum rf90_radio_path)eRFPath,\n\t\t\t\t\t\tRegOffSetToBeCheck,\n\t\t\t\t\t\tbMask12Bits);\n\t\t\tRetryTimes--;\n\t\t}\n\n\t\tswitch (eRFPath) {\n\t\tcase RF90_PATH_A:\n\t\t\trtl92e_set_bb_reg(dev, pPhyReg->rfintfs, bRFSI_RFENV,\n\t\t\t\t\t  u4RegValue);\n\t\t\tbreak;\n\t\tcase RF90_PATH_B:\n\t\t\trtl92e_set_bb_reg(dev, pPhyReg->rfintfs,\n\t\t\t\t\t  bRFSI_RFENV << 16, u4RegValue);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tnetdev_err(dev,\n\t\t\t\t   \"%s(): Failed to initialize RF Path %d.\\n\",\n\t\t\t\t   __func__, eRFPath);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn true;\n\nfail:\n\treturn false;\n}\n\nvoid rtl92e_set_cck_tx_power(struct net_device *dev, u8 powerlevel)\n{\n\tu32\tTxAGC = 0;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tTxAGC = powerlevel;\n\tif (priv->dynamic_tx_low_pwr) {\n\t\tif (priv->customer_id == RT_CID_819X_NETCORE)\n\t\t\tTxAGC = 0x22;\n\t\telse\n\t\t\tTxAGC += priv->cck_pwr_enl;\n\t}\n\tif (TxAGC > 0x24)\n\t\tTxAGC = 0x24;\n\trtl92e_set_bb_reg(dev, rTxAGC_CCK_Mcs32, bTxAGCRateCCK, TxAGC);\n}\n\nvoid rtl92e_set_ofdm_tx_power(struct net_device *dev, u8 powerlevel)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu32 writeVal, powerBase0, powerBase1, writeVal_tmp;\n\tu8 index = 0;\n\tu16 RegOffset[6] = {0xe00, 0xe04, 0xe10, 0xe14, 0xe18, 0xe1c};\n\tu8 byte0, byte1, byte2, byte3;\n\n\tpowerBase0 = powerlevel + priv->legacy_ht_tx_pwr_diff;\n\tpowerBase0 = (powerBase0 << 24) | (powerBase0 << 16) |\n\t\t     (powerBase0 << 8) | powerBase0;\n\tpowerBase1 = powerlevel;\n\tpowerBase1 = (powerBase1 << 24) | (powerBase1 << 16) |\n\t\t     (powerBase1 << 8) | powerBase1;\n\n\tfor (index = 0; index < 6; index++) {\n\t\twriteVal = (u32)(priv->mcs_tx_pwr_level_org_offset[index] +\n\t\t\t   ((index < 2) ? powerBase0 : powerBase1));\n\t\tbyte0 = writeVal & 0x7f;\n\t\tbyte1 = (writeVal & 0x7f00) >> 8;\n\t\tbyte2 = (writeVal & 0x7f0000) >> 16;\n\t\tbyte3 = (writeVal & 0x7f000000) >> 24;\n\t\tif (byte0 > 0x24)\n\t\t\tbyte0 = 0x24;\n\t\tif (byte1 > 0x24)\n\t\t\tbyte1 = 0x24;\n\t\tif (byte2 > 0x24)\n\t\t\tbyte2 = 0x24;\n\t\tif (byte3 > 0x24)\n\t\t\tbyte3 = 0x24;\n\n\t\tif (index == 3) {\n\t\t\twriteVal_tmp = (byte3 << 24) | (byte2 << 16) |\n\t\t\t\t       (byte1 << 8) | byte0;\n\t\t\tpriv->pwr_track = writeVal_tmp;\n\t\t}\n\n\t\tif (priv->dynamic_tx_high_pwr)\n\t\t\twriteVal = 0x03030303;\n\t\telse\n\t\t\twriteVal = (byte3 << 24) | (byte2 << 16) |\n\t\t\t\t   (byte1 << 8) | byte0;\n\t\trtl92e_set_bb_reg(dev, RegOffset[index], 0x7f7f7f7f, writeVal);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}