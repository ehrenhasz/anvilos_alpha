{
  "module_name": "r8192E_phy.c",
  "hash_id": "0e9a3d6c1fd7f3023176cecfad025df729e8e0b97ff4355aeaa01a0bfffb8c63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtl8192e/r8192E_phy.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include \"rtl_core.h\"\n#include \"r8192E_hw.h\"\n#include \"r8192E_phyreg.h\"\n#include \"r8190P_rtl8256.h\"\n#include \"r8192E_phy.h\"\n#include \"rtl_dm.h\"\n\n#include \"table.h\"\n\n \n\nstatic u32 _rtl92e_phy_rf_fw_read(struct net_device *dev,\n\t\t\t\t  enum rf90_radio_path eRFPath, u32 Offset);\nstatic void _rtl92e_phy_rf_fw_write(struct net_device *dev,\n\t\t\t\t    enum rf90_radio_path eRFPath, u32 Offset,\n\t\t\t\t    u32 Data);\n\nstatic u32 _rtl92e_calculate_bit_shift(u32 dwBitMask)\n{\n\tif (!dwBitMask)\n\t\treturn 32;\n\treturn ffs(dwBitMask) - 1;\n}\n\nvoid rtl92e_set_bb_reg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask,\n\t\t       u32 dwData)\n{\n\tu32 OriginalValue, BitShift, NewValue;\n\n\tif (dwBitMask != bMaskDWord) {\n\t\tOriginalValue = rtl92e_readl(dev, dwRegAddr);\n\t\tBitShift = _rtl92e_calculate_bit_shift(dwBitMask);\n\t\tNewValue = (OriginalValue & ~dwBitMask) | (dwData << BitShift);\n\t\trtl92e_writel(dev, dwRegAddr, NewValue);\n\t} else {\n\t\trtl92e_writel(dev, dwRegAddr, dwData);\n\t}\n}\n\nu32 rtl92e_get_bb_reg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask)\n{\n\tu32 OriginalValue, BitShift;\n\n\tOriginalValue = rtl92e_readl(dev, dwRegAddr);\n\tBitShift = _rtl92e_calculate_bit_shift(dwBitMask);\n\n\treturn (OriginalValue & dwBitMask) >> BitShift;\n}\n\nstatic u32 _rtl92e_phy_rf_read(struct net_device *dev,\n\t\t\t       enum rf90_radio_path eRFPath, u32 Offset)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu32 ret = 0;\n\tu32 NewOffset = 0;\n\tstruct bb_reg_definition *pPhyReg = &priv->phy_reg_def[eRFPath];\n\n\tOffset &= 0x3f;\n\n\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter4, 0xf00, 0x0);\n\tif (Offset >= 31) {\n\t\tpriv->rf_reg_0value[eRFPath] |= 0x140;\n\t\trtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset,\n\t\t\t\t  bMaskDWord,\n\t\t\t\t  (priv->rf_reg_0value[eRFPath] << 16));\n\t\tNewOffset = Offset - 30;\n\t} else if (Offset >= 16) {\n\t\tpriv->rf_reg_0value[eRFPath] |= 0x100;\n\t\tpriv->rf_reg_0value[eRFPath] &= (~0x40);\n\t\trtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset,\n\t\t\t\t  bMaskDWord,\n\t\t\t\t  (priv->rf_reg_0value[eRFPath] << 16));\n\t\tNewOffset = Offset - 15;\n\t} else {\n\t\tNewOffset = Offset;\n\t}\n\trtl92e_set_bb_reg(dev, pPhyReg->rfHSSIPara2, bLSSIReadAddress,\n\t\t\t  NewOffset);\n\trtl92e_set_bb_reg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x0);\n\trtl92e_set_bb_reg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x1);\n\n\tmdelay(1);\n\n\tret = rtl92e_get_bb_reg(dev, pPhyReg->rfLSSIReadBack,\n\t\t\t\tbLSSIReadBackData);\n\n\tpriv->rf_reg_0value[eRFPath] &= 0xebf;\n\n\trtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset, bMaskDWord,\n\t\t\t  (priv->rf_reg_0value[eRFPath] << 16));\n\n\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3);\n\n\treturn ret;\n}\n\nstatic void _rtl92e_phy_rf_write(struct net_device *dev,\n\t\t\t\t enum rf90_radio_path eRFPath, u32 Offset,\n\t\t\t\t u32 Data)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu32 DataAndAddr = 0, NewOffset = 0;\n\tstruct bb_reg_definition *pPhyReg = &priv->phy_reg_def[eRFPath];\n\n\tOffset &= 0x3f;\n\n\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter4, 0xf00, 0x0);\n\n\tif (Offset >= 31) {\n\t\tpriv->rf_reg_0value[eRFPath] |= 0x140;\n\t\trtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset,\n\t\t\t\t  bMaskDWord,\n\t\t\t\t  (priv->rf_reg_0value[eRFPath] << 16));\n\t\tNewOffset = Offset - 30;\n\t} else if (Offset >= 16) {\n\t\tpriv->rf_reg_0value[eRFPath] |= 0x100;\n\t\tpriv->rf_reg_0value[eRFPath] &= (~0x40);\n\t\trtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset,\n\t\t\t\t  bMaskDWord,\n\t\t\t\t  (priv->rf_reg_0value[eRFPath] << 16));\n\t\tNewOffset = Offset - 15;\n\t} else {\n\t\tNewOffset = Offset;\n\t}\n\n\tDataAndAddr = (NewOffset & 0x3f) | (Data << 16);\n\n\trtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);\n\n\tif (Offset == 0x0)\n\t\tpriv->rf_reg_0value[eRFPath] = Data;\n\n\tif (Offset != 0) {\n\t\tpriv->rf_reg_0value[eRFPath] &= 0xebf;\n\t\trtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset,\n\t\t\t\t  bMaskDWord,\n\t\t\t\t  (priv->rf_reg_0value[eRFPath] << 16));\n\t}\n\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3);\n}\n\nvoid rtl92e_set_rf_reg(struct net_device *dev, enum rf90_radio_path eRFPath,\n\t\t       u32 RegAddr, u32 BitMask, u32 Data)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu32 Original_Value, BitShift, New_Value;\n\n\tif (priv->rtllib->rf_power_state != rf_on && !priv->being_init_adapter)\n\t\treturn;\n\n\tif (priv->rf_mode == RF_OP_By_FW) {\n\t\tif (BitMask != bMask12Bits) {\n\t\t\tOriginal_Value = _rtl92e_phy_rf_fw_read(dev, eRFPath,\n\t\t\t\t\t\t\t\tRegAddr);\n\t\t\tBitShift =  _rtl92e_calculate_bit_shift(BitMask);\n\t\t\tNew_Value = (Original_Value & ~BitMask) | (Data << BitShift);\n\n\t\t\t_rtl92e_phy_rf_fw_write(dev, eRFPath, RegAddr,\n\t\t\t\t\t\tNew_Value);\n\t\t} else {\n\t\t\t_rtl92e_phy_rf_fw_write(dev, eRFPath, RegAddr, Data);\n\t\t}\n\t\tudelay(200);\n\t} else {\n\t\tif (BitMask != bMask12Bits) {\n\t\t\tOriginal_Value = _rtl92e_phy_rf_read(dev, eRFPath,\n\t\t\t\t\t\t\t     RegAddr);\n\t\t\tBitShift =  _rtl92e_calculate_bit_shift(BitMask);\n\t\t\tNew_Value = (Original_Value & ~BitMask) | (Data << BitShift);\n\n\t\t\t_rtl92e_phy_rf_write(dev, eRFPath, RegAddr, New_Value);\n\t\t} else {\n\t\t\t_rtl92e_phy_rf_write(dev, eRFPath, RegAddr, Data);\n\t\t}\n\t}\n}\n\nu32 rtl92e_get_rf_reg(struct net_device *dev, enum rf90_radio_path eRFPath,\n\t\t      u32 RegAddr, u32 BitMask)\n{\n\tu32 Original_Value, Readback_Value, BitShift;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->rtllib->rf_power_state != rf_on && !priv->being_init_adapter)\n\t\treturn\t0;\n\tmutex_lock(&priv->rf_mutex);\n\tif (priv->rf_mode == RF_OP_By_FW) {\n\t\tOriginal_Value = _rtl92e_phy_rf_fw_read(dev, eRFPath, RegAddr);\n\t\tudelay(200);\n\t} else {\n\t\tOriginal_Value = _rtl92e_phy_rf_read(dev, eRFPath, RegAddr);\n\t}\n\tBitShift =  _rtl92e_calculate_bit_shift(BitMask);\n\tReadback_Value = (Original_Value & BitMask) >> BitShift;\n\tmutex_unlock(&priv->rf_mutex);\n\treturn Readback_Value;\n}\n\nstatic u32 _rtl92e_phy_rf_fw_read(struct net_device *dev,\n\t\t\t\t  enum rf90_radio_path eRFPath, u32 Offset)\n{\n\tu32\t\tData = 0;\n\tu8\t\ttime = 0;\n\n\tData |= ((Offset & 0xFF) << 12);\n\tData |= ((eRFPath & 0x3) << 20);\n\tData |= 0x80000000;\n\twhile (rtl92e_readl(dev, QPNR) & 0x80000000) {\n\t\tif (time++ < 100)\n\t\t\tudelay(10);\n\t\telse\n\t\t\tbreak;\n\t}\n\trtl92e_writel(dev, QPNR, Data);\n\twhile (rtl92e_readl(dev, QPNR) & 0x80000000) {\n\t\tif (time++ < 100)\n\t\t\tudelay(10);\n\t\telse\n\t\t\treturn 0;\n\t}\n\treturn rtl92e_readl(dev, RF_DATA);\n}\n\nstatic void _rtl92e_phy_rf_fw_write(struct net_device *dev,\n\t\t\t\t    enum rf90_radio_path eRFPath, u32 Offset,\n\t\t\t\t    u32 Data)\n{\n\tu8\ttime = 0;\n\n\tData |= ((Offset & 0xFF) << 12);\n\tData |= ((eRFPath & 0x3) << 20);\n\tData |= 0x400000;\n\tData |= 0x80000000;\n\n\twhile (rtl92e_readl(dev, QPNR) & 0x80000000) {\n\t\tif (time++ < 100)\n\t\t\tudelay(10);\n\t\telse\n\t\t\tbreak;\n\t}\n\trtl92e_writel(dev, QPNR, Data);\n}\n\nvoid rtl92e_config_mac(struct net_device *dev)\n{\n\tu32 dwArrayLen = 0, i = 0;\n\tu32 *pdwArray = NULL;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->tx_pwr_data_read_from_eeprom) {\n\t\tdwArrayLen = RTL8192E_MACPHY_ARR_PG_LEN;\n\t\tpdwArray = RTL8192E_MACPHY_ARR_PG;\n\n\t} else {\n\t\tdwArrayLen = RTL8192E_MACPHY_ARR_LEN;\n\t\tpdwArray = RTL8192E_MACPHY_ARR;\n\t}\n\tfor (i = 0; i < dwArrayLen; i += 3) {\n\t\tif (pdwArray[i] == 0x318)\n\t\t\tpdwArray[i + 2] = 0x00000800;\n\t\trtl92e_set_bb_reg(dev, pdwArray[i], pdwArray[i + 1],\n\t\t\t\t  pdwArray[i + 2]);\n\t}\n}\n\nstatic void _rtl92e_phy_config_bb(struct net_device *dev, u8 ConfigType)\n{\n\tint i;\n\tu32 *Rtl819XPHY_REGArray_Table = NULL;\n\tu32 *Rtl819XAGCTAB_Array_Table = NULL;\n\tu16 AGCTAB_ArrayLen, PHY_REGArrayLen = 0;\n\n\tAGCTAB_ArrayLen = RTL8192E_AGCTAB_ARR_LEN;\n\tRtl819XAGCTAB_Array_Table = RTL8192E_AGCTAB_ARR;\n\tPHY_REGArrayLen = RTL8192E_PHY_REG_1T2R_ARR_LEN;\n\tRtl819XPHY_REGArray_Table = RTL8192E_PHY_REG_1T2R_ARR;\n\n\tif (ConfigType == BB_CONFIG_PHY_REG) {\n\t\tfor (i = 0; i < PHY_REGArrayLen; i += 2) {\n\t\t\trtl92e_set_bb_reg(dev, Rtl819XPHY_REGArray_Table[i],\n\t\t\t\t\t  bMaskDWord,\n\t\t\t\t\t  Rtl819XPHY_REGArray_Table[i + 1]);\n\t\t}\n\t} else if (ConfigType == BB_CONFIG_AGC_TAB) {\n\t\tfor (i = 0; i < AGCTAB_ArrayLen; i += 2) {\n\t\t\trtl92e_set_bb_reg(dev, Rtl819XAGCTAB_Array_Table[i],\n\t\t\t\t\t  bMaskDWord,\n\t\t\t\t\t  Rtl819XAGCTAB_Array_Table[i + 1]);\n\t\t}\n\t}\n}\n\nstatic void _rtl92e_init_bb_rf_reg_def(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tpriv->phy_reg_def[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW;\n\tpriv->phy_reg_def[RF90_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW;\n\n\tpriv->phy_reg_def[RF90_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE;\n\tpriv->phy_reg_def[RF90_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE;\n\n\tpriv->phy_reg_def[RF90_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE;\n\tpriv->phy_reg_def[RF90_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE;\n\n\tpriv->phy_reg_def[RF90_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter;\n\tpriv->phy_reg_def[RF90_PATH_B].rf3wireOffset = rFPGA0_XB_LSSIParameter;\n\n\tpriv->phy_reg_def[RF90_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;\n\tpriv->phy_reg_def[RF90_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;\n\n\tpriv->phy_reg_def[RF90_PATH_A].rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;\n\tpriv->phy_reg_def[RF90_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;\n}\n\nbool rtl92e_check_bb_and_rf(struct net_device *dev, enum hw90_block CheckBlock,\n\t\t\t    enum rf90_radio_path eRFPath)\n{\n\tbool ret = true;\n\tu32 i, CheckTimes = 4, dwRegRead = 0;\n\tu32 WriteAddr[4];\n\tu32 WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};\n\n\tWriteAddr[HW90_BLOCK_MAC] = 0x100;\n\tWriteAddr[HW90_BLOCK_PHY0] = 0x900;\n\tWriteAddr[HW90_BLOCK_PHY1] = 0x800;\n\tWriteAddr[HW90_BLOCK_RF] = 0x3;\n\n\tif (CheckBlock == HW90_BLOCK_MAC) {\n\t\tnetdev_warn(dev, \"%s(): No checks available for MAC block.\\n\",\n\t\t\t    __func__);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < CheckTimes; i++) {\n\t\tswitch (CheckBlock) {\n\t\tcase HW90_BLOCK_PHY0:\n\t\tcase HW90_BLOCK_PHY1:\n\t\t\trtl92e_writel(dev, WriteAddr[CheckBlock],\n\t\t\t\t      WriteData[i]);\n\t\t\tdwRegRead = rtl92e_readl(dev, WriteAddr[CheckBlock]);\n\t\t\tbreak;\n\n\t\tcase HW90_BLOCK_RF:\n\t\t\tWriteData[i] &= 0xfff;\n\t\t\trtl92e_set_rf_reg(dev, eRFPath,\n\t\t\t\t\t  WriteAddr[HW90_BLOCK_RF],\n\t\t\t\t\t  bMask12Bits, WriteData[i]);\n\t\t\tmdelay(10);\n\t\t\tdwRegRead = rtl92e_get_rf_reg(dev, eRFPath,\n\t\t\t\t\t\t      WriteAddr[HW90_BLOCK_RF],\n\t\t\t\t\t\t      bMaskDWord);\n\t\t\tmdelay(10);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (dwRegRead != WriteData[i]) {\n\t\t\tnetdev_warn(dev, \"%s(): Check failed.\\n\", __func__);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic bool _rtl92e_bb_config_para_file(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tbool rtStatus = true;\n\tu8 bRegValue = 0, eCheckItem = 0;\n\tu32 dwRegValue = 0;\n\n\tbRegValue = rtl92e_readb(dev, BB_GLOBAL_RESET);\n\trtl92e_writeb(dev, BB_GLOBAL_RESET, (bRegValue | BB_GLOBAL_RESET_BIT));\n\n\tdwRegValue = rtl92e_readl(dev, CPU_GEN);\n\trtl92e_writel(dev, CPU_GEN, (dwRegValue & (~CPU_GEN_BB_RST)));\n\n\tfor (eCheckItem = (enum hw90_block)HW90_BLOCK_PHY0;\n\t     eCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {\n\t\trtStatus  = rtl92e_check_bb_and_rf(dev,\n\t\t\t\t\t\t   (enum hw90_block)eCheckItem,\n\t\t\t\t\t\t   (enum rf90_radio_path)0);\n\t\tif (!rtStatus)\n\t\t\treturn rtStatus;\n\t}\n\trtl92e_set_bb_reg(dev, rFPGA0_RFMOD, bCCKEn | bOFDMEn, 0x0);\n\t_rtl92e_phy_config_bb(dev, BB_CONFIG_PHY_REG);\n\n\tdwRegValue = rtl92e_readl(dev, CPU_GEN);\n\trtl92e_writel(dev, CPU_GEN, (dwRegValue | CPU_GEN_BB_RST));\n\n\t_rtl92e_phy_config_bb(dev, BB_CONFIG_AGC_TAB);\n\n\tif (priv->ic_cut  > VERSION_8190_BD) {\n\t\tdwRegValue = 0x0;\n\t\trtl92e_set_bb_reg(dev, rFPGA0_TxGainStage,\n\t\t\t\t  (bXBTxAGC | bXCTxAGC | bXDTxAGC), dwRegValue);\n\n\t\tdwRegValue = priv->crystal_cap;\n\t\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1, bXtalCap92x,\n\t\t\t\t  dwRegValue);\n\t}\n\n\treturn rtStatus;\n}\nbool rtl92e_config_bb(struct net_device *dev)\n{\n\t_rtl92e_init_bb_rf_reg_def(dev);\n\treturn _rtl92e_bb_config_para_file(dev);\n}\n\nvoid rtl92e_get_tx_power(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tpriv->mcs_tx_pwr_level_org_offset[0] =\n\t\trtl92e_readl(dev, rTxAGC_Rate18_06);\n\tpriv->mcs_tx_pwr_level_org_offset[1] =\n\t\trtl92e_readl(dev, rTxAGC_Rate54_24);\n\tpriv->mcs_tx_pwr_level_org_offset[2] =\n\t\trtl92e_readl(dev, rTxAGC_Mcs03_Mcs00);\n\tpriv->mcs_tx_pwr_level_org_offset[3] =\n\t\trtl92e_readl(dev, rTxAGC_Mcs07_Mcs04);\n\tpriv->mcs_tx_pwr_level_org_offset[4] =\n\t\trtl92e_readl(dev, rTxAGC_Mcs11_Mcs08);\n\tpriv->mcs_tx_pwr_level_org_offset[5] =\n\t\trtl92e_readl(dev, rTxAGC_Mcs15_Mcs12);\n\n\tpriv->def_initial_gain[0] = rtl92e_readb(dev, rOFDM0_XAAGCCore1);\n\tpriv->def_initial_gain[1] = rtl92e_readb(dev, rOFDM0_XBAGCCore1);\n\tpriv->def_initial_gain[2] = rtl92e_readb(dev, rOFDM0_XCAGCCore1);\n\tpriv->def_initial_gain[3] = rtl92e_readb(dev, rOFDM0_XDAGCCore1);\n\n\tpriv->framesync = rtl92e_readb(dev, rOFDM0_RxDetector3);\n}\n\nvoid rtl92e_set_tx_power(struct net_device *dev, u8 channel)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8\tpowerlevel = 0, powerlevelOFDM24G = 0;\n\n\tif (priv->epromtype == EEPROM_93C46) {\n\t\tpowerlevel = priv->tx_pwr_level_cck[channel - 1];\n\t\tpowerlevelOFDM24G = priv->tx_pwr_level_ofdm_24g[channel - 1];\n\t}\n\n\trtl92e_set_cck_tx_power(dev, powerlevel);\n\trtl92e_set_ofdm_tx_power(dev, powerlevelOFDM24G);\n}\n\nu8 rtl92e_config_rf_path(struct net_device *dev, enum rf90_radio_path eRFPath)\n{\n\tint i;\n\n\tswitch (eRFPath) {\n\tcase RF90_PATH_A:\n\t\tfor (i = 0; i < RTL8192E_RADIO_A_ARR_LEN; i += 2) {\n\t\t\tif (RTL8192E_RADIO_A_ARR[i] == 0xfe) {\n\t\t\t\tmsleep(100);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trtl92e_set_rf_reg(dev, eRFPath, RTL8192E_RADIO_A_ARR[i],\n\t\t\t\t\t  bMask12Bits,\n\t\t\t\t\t  RTL8192E_RADIO_A_ARR[i + 1]);\n\t\t}\n\t\tbreak;\n\tcase RF90_PATH_B:\n\t\tfor (i = 0; i < RTL8192E_RADIO_B_ARR_LEN; i += 2) {\n\t\t\tif (RTL8192E_RADIO_B_ARR[i] == 0xfe) {\n\t\t\t\tmsleep(100);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trtl92e_set_rf_reg(dev, eRFPath, RTL8192E_RADIO_B_ARR[i],\n\t\t\t\t\t  bMask12Bits,\n\t\t\t\t\t  RTL8192E_RADIO_B_ARR[i + 1]);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void _rtl92e_set_tx_power_level(struct net_device *dev, u8 channel)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8\tpowerlevel = priv->tx_pwr_level_cck[channel - 1];\n\tu8\tpowerlevelOFDM24G = priv->tx_pwr_level_ofdm_24g[channel - 1];\n\n\trtl92e_set_cck_tx_power(dev, powerlevel);\n\trtl92e_set_ofdm_tx_power(dev, powerlevelOFDM24G);\n}\n\nstatic u8 _rtl92e_phy_set_sw_chnl_cmd_array(struct net_device *dev,\n\t\t\t\t\t    struct sw_chnl_cmd *CmdTable,\n\t\t\t\t\t    u32 CmdTableIdx, u32 CmdTableSz,\n\t\t\t\t\t    enum sw_chnl_cmd_id CmdID,\n\t\t\t\t\t    u32 Para1, u32 Para2, u32 msDelay)\n{\n\tstruct sw_chnl_cmd *pCmd;\n\n\tif (CmdTable == NULL) {\n\t\tnetdev_err(dev, \"%s(): CmdTable cannot be NULL.\\n\", __func__);\n\t\treturn false;\n\t}\n\tif (CmdTableIdx >= CmdTableSz) {\n\t\tnetdev_err(dev, \"%s(): Invalid index requested.\\n\", __func__);\n\t\treturn false;\n\t}\n\n\tpCmd = CmdTable + CmdTableIdx;\n\tpCmd->CmdID = CmdID;\n\tpCmd->Para1 = Para1;\n\tpCmd->Para2 = Para2;\n\tpCmd->msDelay = msDelay;\n\n\treturn true;\n}\n\nstatic u8 _rtl92e_phy_switch_channel_step(struct net_device *dev, u8 channel,\n\t\t\t\t\t  u8 *stage, u8 *step, u32 *delay)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\tu32\t\t\t\t\tPreCommonCmdCnt;\n\tu32\t\t\t\t\tPostCommonCmdCnt;\n\tu32\t\t\t\t\tRfDependCmdCnt;\n\tstruct sw_chnl_cmd *CurrentCmd = NULL;\n\tu8\t\teRFPath;\n\n\tif (!rtllib_legal_channel(priv->rtllib, channel)) {\n\t\tnetdev_err(dev, \"Invalid channel requested: %d\\n\", channel);\n\t\treturn true;\n\t}\n\n\t{\n\t\tPreCommonCmdCnt = 0;\n\t\t_rtl92e_phy_set_sw_chnl_cmd_array(dev, ieee->PreCommonCmd,\n\t\t\t\t\t\t  PreCommonCmdCnt++,\n\t\t\t\t\t\t  MAX_PRECMD_CNT,\n\t\t\t\t\t\t  CmdID_SetTxPowerLevel,\n\t\t\t\t\t\t  0, 0, 0);\n\t\t_rtl92e_phy_set_sw_chnl_cmd_array(dev, ieee->PreCommonCmd,\n\t\t\t\t\t\t  PreCommonCmdCnt++,\n\t\t\t\t\t\t  MAX_PRECMD_CNT, CmdID_End,\n\t\t\t\t\t\t  0, 0, 0);\n\n\t\tPostCommonCmdCnt = 0;\n\n\t\t_rtl92e_phy_set_sw_chnl_cmd_array(dev, ieee->PostCommonCmd,\n\t\t\t\t\t\t  PostCommonCmdCnt++,\n\t\t\t\t\t\t  MAX_POSTCMD_CNT, CmdID_End,\n\t\t\t\t\t\t  0, 0, 0);\n\n\t\tRfDependCmdCnt = 0;\n\n\t\tif (!(channel >= 1 && channel <= 14)) {\n\t\t\tnetdev_err(dev,\n\t\t\t\t   \"Invalid channel requested for 8256: %d\\n\",\n\t\t\t\t   channel);\n\t\t\treturn false;\n\t\t}\n\t\t_rtl92e_phy_set_sw_chnl_cmd_array(dev,\n\t\t\t\t\t\t  ieee->RfDependCmd,\n\t\t\t\t\t\t  RfDependCmdCnt++,\n\t\t\t\t\t\t  MAX_RFDEPENDCMD_CNT,\n\t\t\t\t\t\t  CmdID_RF_WriteReg,\n\t\t\t\t\t\t  rZebra1_Channel,\n\t\t\t\t\t\t  channel, 10);\n\t\t_rtl92e_phy_set_sw_chnl_cmd_array(dev,\n\t\t\t\t\t\t  ieee->RfDependCmd,\n\t\t\t\t\t\t  RfDependCmdCnt++,\n\t\t\t\t\t\t  MAX_RFDEPENDCMD_CNT,\n\t\t\t\t\t\t  CmdID_End, 0, 0, 0);\n\n\t\tdo {\n\t\t\tswitch (*stage) {\n\t\t\tcase 0:\n\t\t\t\tCurrentCmd = &ieee->PreCommonCmd[*step];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tCurrentCmd = &ieee->RfDependCmd[*step];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tCurrentCmd = &ieee->PostCommonCmd[*step];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (CurrentCmd && CurrentCmd->CmdID == CmdID_End) {\n\t\t\t\tif ((*stage) == 2)\n\t\t\t\t\treturn true;\n\t\t\t\t(*stage)++;\n\t\t\t\t(*step) = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!CurrentCmd)\n\t\t\t\tcontinue;\n\t\t\tswitch (CurrentCmd->CmdID) {\n\t\t\tcase CmdID_SetTxPowerLevel:\n\t\t\t\tif (priv->ic_cut > VERSION_8190_BD)\n\t\t\t\t\t_rtl92e_set_tx_power_level(dev,\n\t\t\t\t\t\t\t\t   channel);\n\t\t\t\tbreak;\n\t\t\tcase CmdID_WritePortUlong:\n\t\t\t\trtl92e_writel(dev, CurrentCmd->Para1,\n\t\t\t\t\t      CurrentCmd->Para2);\n\t\t\t\tbreak;\n\t\t\tcase CmdID_WritePortUshort:\n\t\t\t\trtl92e_writew(dev, CurrentCmd->Para1,\n\t\t\t\t\t      CurrentCmd->Para2);\n\t\t\t\tbreak;\n\t\t\tcase CmdID_WritePortUchar:\n\t\t\t\trtl92e_writeb(dev, CurrentCmd->Para1,\n\t\t\t\t\t      CurrentCmd->Para2);\n\t\t\t\tbreak;\n\t\t\tcase CmdID_RF_WriteReg:\n\t\t\t\tfor (eRFPath = 0; eRFPath <\n\t\t\t\t     priv->num_total_rf_path; eRFPath++)\n\t\t\t\t\trtl92e_set_rf_reg(dev,\n\t\t\t\t\t\t (enum rf90_radio_path)eRFPath,\n\t\t\t\t\t\t CurrentCmd->Para1, bMask12Bits,\n\t\t\t\t\t\t CurrentCmd->Para2 << 7);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t} while (true);\n\t}  \n\n\t(*delay) = CurrentCmd->msDelay;\n\t(*step)++;\n\treturn false;\n}\n\nstatic void _rtl92e_phy_switch_channel(struct net_device *dev, u8 channel)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu32 delay = 0;\n\n\twhile (!_rtl92e_phy_switch_channel_step(dev, channel,\n\t\t\t\t\t\t&priv->sw_chnl_stage,\n\t\t\t\t\t\t&priv->sw_chnl_step, &delay)) {\n\t\tif (delay > 0)\n\t\t\tmsleep(delay);\n\t\tif (!priv->up)\n\t\t\tbreak;\n\t}\n}\n\nstatic void _rtl92e_phy_switch_channel_work_item(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\t_rtl92e_phy_switch_channel(dev, priv->chan);\n}\n\nu8 rtl92e_set_channel(struct net_device *dev, u8 channel)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (!priv->up) {\n\t\tnetdev_err(dev, \"%s(): Driver is not initialized\\n\", __func__);\n\t\treturn false;\n\t}\n\tif (priv->sw_chnl_in_progress)\n\t\treturn false;\n\n\tswitch (priv->rtllib->mode) {\n\tcase WIRELESS_MODE_B:\n\t\tif (channel > 14) {\n\t\t\tnetdev_warn(dev,\n\t\t\t\t    \"Channel %d not available in 802.11b.\\n\",\n\t\t\t\t    channel);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\tcase WIRELESS_MODE_N_24G:\n\t\tif (channel > 14) {\n\t\t\tnetdev_warn(dev,\n\t\t\t\t    \"Channel %d not available in 802.11g.\\n\",\n\t\t\t\t    channel);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n\n\tpriv->sw_chnl_in_progress = true;\n\tif (channel == 0)\n\t\tchannel = 1;\n\n\tpriv->chan = channel;\n\n\tpriv->sw_chnl_stage = 0;\n\tpriv->sw_chnl_step = 0;\n\n\tif (priv->up)\n\t\t_rtl92e_phy_switch_channel_work_item(dev);\n\tpriv->sw_chnl_in_progress = false;\n\treturn true;\n}\n\nstatic void _rtl92e_cck_tx_power_track_bw_switch_tssi(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tswitch (priv->current_chnl_bw) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\tpriv->cck_present_attn =\n\t\t\tpriv->cck_present_attn_20m_def +\n\t\t\t    priv->cck_present_attn_diff;\n\n\t\tif (priv->cck_present_attn >\n\t\t    (CCK_TX_BB_GAIN_TABLE_LEN - 1))\n\t\t\tpriv->cck_present_attn =\n\t\t\t\t\t CCK_TX_BB_GAIN_TABLE_LEN - 1;\n\t\tif (priv->cck_present_attn < 0)\n\t\t\tpriv->cck_present_attn = 0;\n\n\t\tif (priv->rtllib->current_network.channel == 14 &&\n\t\t    !priv->bcck_in_ch14) {\n\t\t\tpriv->bcck_in_ch14 = true;\n\t\t\trtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t} else if (priv->rtllib->current_network.channel !=\n\t\t\t   14 && priv->bcck_in_ch14) {\n\t\t\tpriv->bcck_in_ch14 = false;\n\t\t\trtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t} else {\n\t\t\trtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t}\n\t\tbreak;\n\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\tpriv->cck_present_attn =\n\t\t\tpriv->cck_present_attn_40m_def +\n\t\t\tpriv->cck_present_attn_diff;\n\n\t\tif (priv->cck_present_attn >\n\t\t    (CCK_TX_BB_GAIN_TABLE_LEN - 1))\n\t\t\tpriv->cck_present_attn =\n\t\t\t\t\t CCK_TX_BB_GAIN_TABLE_LEN - 1;\n\t\tif (priv->cck_present_attn < 0)\n\t\t\tpriv->cck_present_attn = 0;\n\n\t\tif (priv->rtllib->current_network.channel == 14 &&\n\t\t    !priv->bcck_in_ch14) {\n\t\t\tpriv->bcck_in_ch14 = true;\n\t\t\trtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t} else if (priv->rtllib->current_network.channel != 14\n\t\t\t   && priv->bcck_in_ch14) {\n\t\t\tpriv->bcck_in_ch14 = false;\n\t\t\trtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t} else {\n\t\t\trtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void _rtl92e_cck_tx_power_track_bw_switch_thermal(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->rtllib->current_network.channel == 14 &&\n\t    !priv->bcck_in_ch14)\n\t\tpriv->bcck_in_ch14 = true;\n\telse if (priv->rtllib->current_network.channel != 14 &&\n\t\t priv->bcck_in_ch14)\n\t\tpriv->bcck_in_ch14 = false;\n\n\tswitch (priv->current_chnl_bw) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\tif (priv->rec_cck_20m_idx == 0)\n\t\t\tpriv->rec_cck_20m_idx = 6;\n\t\tpriv->cck_index = priv->rec_cck_20m_idx;\n\tbreak;\n\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\tpriv->cck_index = priv->rec_cck_40m_idx;\n\tbreak;\n\t}\n\trtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n}\n\nstatic void _rtl92e_cck_tx_power_track_bw_switch(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->ic_cut >= IC_VersionCut_D)\n\t\t_rtl92e_cck_tx_power_track_bw_switch_tssi(dev);\n\telse\n\t\t_rtl92e_cck_tx_power_track_bw_switch_thermal(dev);\n}\n\nstatic void _rtl92e_set_bw_mode_work_item(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8 regBwOpMode;\n\n\tif (!priv->up) {\n\t\tnetdev_err(dev, \"%s(): Driver is not initialized\\n\", __func__);\n\t\treturn;\n\t}\n\tregBwOpMode = rtl92e_readb(dev, BW_OPMODE);\n\n\tswitch (priv->current_chnl_bw) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\tregBwOpMode |= BW_OPMODE_20MHZ;\n\t\trtl92e_writeb(dev, BW_OPMODE, regBwOpMode);\n\t\tbreak;\n\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\tregBwOpMode &= ~BW_OPMODE_20MHZ;\n\t\trtl92e_writeb(dev, BW_OPMODE, regBwOpMode);\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_err(dev, \"%s(): unknown Bandwidth: %#X\\n\", __func__,\n\t\t\t   priv->current_chnl_bw);\n\t\tbreak;\n\t}\n\n\tswitch (priv->current_chnl_bw) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\trtl92e_set_bb_reg(dev, rFPGA0_RFMOD, bRFMOD, 0x0);\n\t\trtl92e_set_bb_reg(dev, rFPGA1_RFMOD, bRFMOD, 0x0);\n\n\t\tif (!priv->btxpower_tracking) {\n\t\t\trtl92e_writel(dev, rCCK0_TxFilter1, 0x1a1b0000);\n\t\t\trtl92e_writel(dev, rCCK0_TxFilter2, 0x090e1317);\n\t\t\trtl92e_writel(dev, rCCK0_DebugPort, 0x00000204);\n\t\t} else {\n\t\t\t_rtl92e_cck_tx_power_track_bw_switch(dev);\n\t\t}\n\n\t\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1, 0x00100000, 1);\n\n\t\tbreak;\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\trtl92e_set_bb_reg(dev, rFPGA0_RFMOD, bRFMOD, 0x1);\n\t\trtl92e_set_bb_reg(dev, rFPGA1_RFMOD, bRFMOD, 0x1);\n\n\t\tif (!priv->btxpower_tracking) {\n\t\t\trtl92e_writel(dev, rCCK0_TxFilter1, 0x35360000);\n\t\t\trtl92e_writel(dev, rCCK0_TxFilter2, 0x121c252e);\n\t\t\trtl92e_writel(dev, rCCK0_DebugPort, 0x00000409);\n\t\t} else {\n\t\t\t_rtl92e_cck_tx_power_track_bw_switch(dev);\n\t\t}\n\n\t\trtl92e_set_bb_reg(dev, rCCK0_System, bCCKSideBand,\n\t\t\t\t  (priv->n_cur_40mhz_prime_sc >> 1));\n\t\trtl92e_set_bb_reg(dev, rOFDM1_LSTF, 0xC00,\n\t\t\t\t  priv->n_cur_40mhz_prime_sc);\n\n\t\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(dev, \"%s(): unknown Bandwidth: %#X\\n\", __func__,\n\t\t\t   priv->current_chnl_bw);\n\t\tbreak;\n\t}\n\n\trtl92e_set_bandwidth(dev, priv->current_chnl_bw);\n\n\tatomic_dec(&(priv->rtllib->atm_swbw));\n\tpriv->set_bw_mode_in_progress = false;\n}\n\nvoid rtl92e_set_bw_mode(struct net_device *dev, enum ht_channel_width bandwidth,\n\t\t\tenum ht_extchnl_offset Offset)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->set_bw_mode_in_progress)\n\t\treturn;\n\n\tatomic_inc(&(priv->rtllib->atm_swbw));\n\tpriv->set_bw_mode_in_progress = true;\n\n\tpriv->current_chnl_bw = bandwidth;\n\n\tif (Offset == HT_EXTCHNL_OFFSET_LOWER)\n\t\tpriv->n_cur_40mhz_prime_sc = HAL_PRIME_CHNL_OFFSET_UPPER;\n\telse if (Offset == HT_EXTCHNL_OFFSET_UPPER)\n\t\tpriv->n_cur_40mhz_prime_sc = HAL_PRIME_CHNL_OFFSET_LOWER;\n\telse\n\t\tpriv->n_cur_40mhz_prime_sc = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\n\n\t_rtl92e_set_bw_mode_work_item(dev);\n}\n\nvoid rtl92e_init_gain(struct net_device *dev, u8 Operation)\n{\n#define SCAN_RX_INITIAL_GAIN\t0x17\n#define POWER_DETECTION_TH\t0x08\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu32 BitMask;\n\tu8 initial_gain;\n\n\tif (priv->up) {\n\t\tswitch (Operation) {\n\t\tcase IG_Backup:\n\t\t\tinitial_gain = SCAN_RX_INITIAL_GAIN;\n\t\t\tBitMask = bMaskByte0;\n\t\t\tif (dm_digtable.dig_algorithm ==\n\t\t\t    DIG_ALGO_BY_FALSE_ALARM)\n\t\t\t\trtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x8);\n\t\t\tpriv->initgain_backup.xaagccore1 =\n\t\t\t\t rtl92e_get_bb_reg(dev, rOFDM0_XAAGCCore1,\n\t\t\t\t\t\t   BitMask);\n\t\t\tpriv->initgain_backup.xbagccore1 =\n\t\t\t\t rtl92e_get_bb_reg(dev, rOFDM0_XBAGCCore1,\n\t\t\t\t\t\t   BitMask);\n\t\t\tpriv->initgain_backup.xcagccore1 =\n\t\t\t\t rtl92e_get_bb_reg(dev, rOFDM0_XCAGCCore1,\n\t\t\t\t\t\t   BitMask);\n\t\t\tpriv->initgain_backup.xdagccore1 =\n\t\t\t\t rtl92e_get_bb_reg(dev, rOFDM0_XDAGCCore1,\n\t\t\t\t\t\t   BitMask);\n\t\t\tBitMask = bMaskByte2;\n\t\t\tpriv->initgain_backup.cca = (u8)rtl92e_get_bb_reg(dev,\n\t\t\t\t\t\t    rCCK0_CCA, BitMask);\n\n\t\t\trtl92e_writeb(dev, rOFDM0_XAAGCCore1, initial_gain);\n\t\t\trtl92e_writeb(dev, rOFDM0_XBAGCCore1, initial_gain);\n\t\t\trtl92e_writeb(dev, rOFDM0_XCAGCCore1, initial_gain);\n\t\t\trtl92e_writeb(dev, rOFDM0_XDAGCCore1, initial_gain);\n\t\t\trtl92e_writeb(dev, 0xa0a, POWER_DETECTION_TH);\n\t\t\tbreak;\n\t\tcase IG_Restore:\n\t\t\tBitMask = 0x7f;\n\t\t\tif (dm_digtable.dig_algorithm ==\n\t\t\t    DIG_ALGO_BY_FALSE_ALARM)\n\t\t\t\trtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x8);\n\n\t\t\trtl92e_set_bb_reg(dev, rOFDM0_XAAGCCore1, BitMask,\n\t\t\t\t\t (u32)priv->initgain_backup.xaagccore1);\n\t\t\trtl92e_set_bb_reg(dev, rOFDM0_XBAGCCore1, BitMask,\n\t\t\t\t\t (u32)priv->initgain_backup.xbagccore1);\n\t\t\trtl92e_set_bb_reg(dev, rOFDM0_XCAGCCore1, BitMask,\n\t\t\t\t\t (u32)priv->initgain_backup.xcagccore1);\n\t\t\trtl92e_set_bb_reg(dev, rOFDM0_XDAGCCore1, BitMask,\n\t\t\t\t\t (u32)priv->initgain_backup.xdagccore1);\n\t\t\tBitMask  = bMaskByte2;\n\t\t\trtl92e_set_bb_reg(dev, rCCK0_CCA, BitMask,\n\t\t\t\t\t (u32)priv->initgain_backup.cca);\n\n\t\t\trtl92e_set_tx_power(dev,\n\t\t\t\t\t priv->rtllib->current_network.channel);\n\n\t\t\tif (dm_digtable.dig_algorithm ==\n\t\t\t    DIG_ALGO_BY_FALSE_ALARM)\n\t\t\t\trtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x1);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid rtl92e_set_rf_off(struct net_device *dev)\n{\n\trtl92e_set_bb_reg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x0);\n\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter4, 0x300, 0x0);\n\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1, 0x18, 0x0);\n\trtl92e_set_bb_reg(dev, rOFDM0_TRxPathEnable, 0xf, 0x0);\n\trtl92e_set_bb_reg(dev, rOFDM1_TRxPathEnable, 0xf, 0x0);\n\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1, 0x60, 0x0);\n\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1, 0x4, 0x0);\n\trtl92e_writeb(dev, ANAPAR_FOR_8192PCIE, 0x07);\n}\n\nstatic bool _rtl92e_set_rf_power_state(struct net_device *dev,\n\t\t\t\t       enum rt_rf_power_state rf_power_state)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_pwr_save_ctrl *psc = (struct rt_pwr_save_ctrl *)\n\t\t\t\t\t(&priv->rtllib->pwr_save_ctrl);\n\tbool bResult = true;\n\tu8\ti = 0, QueueID = 0;\n\tstruct rtl8192_tx_ring  *ring = NULL;\n\n\tif (priv->set_rf_pwr_state_in_progress)\n\t\treturn false;\n\tpriv->set_rf_pwr_state_in_progress = true;\n\n\tswitch (rf_power_state) {\n\tcase rf_on:\n\t\tif ((priv->rtllib->rf_power_state == rf_off) &&\n\t\t     RT_IN_PS_LEVEL(psc, RT_RF_OFF_LEVL_HALT_NIC)) {\n\t\t\tbool rtstatus;\n\t\t\tu32 InitilizeCount = 3;\n\n\t\t\tdo {\n\t\t\t\tInitilizeCount--;\n\t\t\t\trtstatus = rtl92e_enable_nic(dev);\n\t\t\t} while (!rtstatus && (InitilizeCount > 0));\n\t\t\tif (!rtstatus) {\n\t\t\t\tnetdev_err(dev,\n\t\t\t\t\t   \"%s(): Failed to initialize Adapter.\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t\tpriv->set_rf_pwr_state_in_progress = false;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tRT_CLEAR_PS_LEVEL(psc,\n\t\t\t\t\t  RT_RF_OFF_LEVL_HALT_NIC);\n\t\t} else {\n\t\t\trtl92e_writeb(dev, ANAPAR, 0x37);\n\t\t\tmdelay(1);\n\t\t\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1,\n\t\t\t\t\t 0x4, 0x1);\n\t\t\tpriv->hw_rf_off_action = 0;\n\t\t\trtl92e_set_bb_reg(dev, rFPGA0_XA_RFInterfaceOE,\n\t\t\t\t\t  BIT4, 0x1);\n\t\t\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter4,\n\t\t\t\t\t  0x300, 0x3);\n\t\t\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1,\n\t\t\t\t\t  0x18, 0x3);\n\t\t\trtl92e_set_bb_reg(dev, rOFDM0_TRxPathEnable,\n\t\t\t\t\t  0x3, 0x3);\n\t\t\trtl92e_set_bb_reg(dev, rOFDM1_TRxPathEnable,\n\t\t\t\t\t  0x3, 0x3);\n\t\t\trtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1,\n\t\t\t\t\t  0x60, 0x3);\n\t\t}\n\t\tbreak;\n\tcase rf_sleep:\n\t\tif (priv->rtllib->rf_power_state == rf_off)\n\t\t\tbreak;\n\t\tfor (QueueID = 0, i = 0; QueueID < MAX_TX_QUEUE; ) {\n\t\t\tring = &priv->tx_ring[QueueID];\n\t\t\tif (skb_queue_len(&ring->queue) == 0) {\n\t\t\t\tQueueID++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tudelay(10);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i >= MAX_DOZE_WAITING_TIMES_9x)\n\t\t\t\tbreak;\n\t\t}\n\t\trtl92e_set_rf_off(dev);\n\t\tbreak;\n\tcase rf_off:\n\t\tfor (QueueID = 0, i = 0; QueueID < MAX_TX_QUEUE; ) {\n\t\t\tring = &priv->tx_ring[QueueID];\n\t\t\tif (skb_queue_len(&ring->queue) == 0) {\n\t\t\t\tQueueID++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tudelay(10);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i >= MAX_DOZE_WAITING_TIMES_9x)\n\t\t\t\tbreak;\n\t\t}\n\t\trtl92e_set_rf_off(dev);\n\t\tbreak;\n\tdefault:\n\t\tbResult = false;\n\t\tnetdev_warn(dev,\n\t\t\t    \"%s(): Unknown state requested: 0x%X.\\n\",\n\t\t\t    __func__, rf_power_state);\n\t\tbreak;\n\t}\n\n\tif (bResult)\n\t\tpriv->rtllib->rf_power_state = rf_power_state;\n\n\tpriv->set_rf_pwr_state_in_progress = false;\n\treturn bResult;\n}\n\nbool rtl92e_set_rf_power_state(struct net_device *dev,\n\t\t\t       enum rt_rf_power_state rf_power_state)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tbool bResult = false;\n\n\tif (rf_power_state == priv->rtllib->rf_power_state &&\n\t    priv->hw_rf_off_action == 0) {\n\t\treturn bResult;\n\t}\n\n\tbResult = _rtl92e_set_rf_power_state(dev, rf_power_state);\n\treturn bResult;\n}\n\nvoid rtl92e_scan_op_backup(struct net_device *dev, u8 Operation)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->up) {\n\t\tswitch (Operation) {\n\t\tcase SCAN_OPT_BACKUP:\n\t\t\tpriv->rtllib->init_gain_handler(dev, IG_Backup);\n\t\t\tbreak;\n\n\t\tcase SCAN_OPT_RESTORE:\n\t\t\tpriv->rtllib->init_gain_handler(dev, IG_Restore);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}