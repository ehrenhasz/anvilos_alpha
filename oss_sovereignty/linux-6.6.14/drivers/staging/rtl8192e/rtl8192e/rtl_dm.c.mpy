{
  "module_name": "rtl_dm.c",
  "hash_id": "8bb2122fce2d43532b7c4ed250c8b9760daf415e080504747f064590d747afa6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtl8192e/rtl_dm.c",
  "human_readable_source": "\n \n#include \"rtl_core.h\"\n#include \"rtl_dm.h\"\n#include \"r8192E_hw.h\"\n#include \"r8192E_phy.h\"\n#include \"r8192E_phyreg.h\"\n#include \"r8190P_rtl8256.h\"\n#include \"r8192E_cmdpkt.h\"\n\n \nstatic u32 edca_setting_DL[HT_IOT_PEER_MAX] = {\n\t0x5e4322,\n\t0x5e4322,\n\t0x5ea44f,\n\t0x5e4322,\n\t0x604322,\n\t0xa44f,\n\t0x5e4322,\n\t0x5e4332\n};\n\nstatic u32 edca_setting_DL_GMode[HT_IOT_PEER_MAX] = {\n\t0x5e4322,\n\t0x5e4322,\n\t0x5e4322,\n\t0x5e4322,\n\t0x604322,\n\t0xa44f,\n\t0x5e4322,\n\t0x5e4322\n};\n\nstatic u32 edca_setting_UL[HT_IOT_PEER_MAX] = {\n\t0x5e4322,\n\t0xa44f,\n\t0x5ea44f,\n\t0x5e4322,\n\t0x604322,\n\t0x5e4322,\n\t0x5e4322,\n\t0x5e4332\n};\n\nconst u32 dm_tx_bb_gain[TX_BB_GAIN_TABLE_LEN] = {\n\t0x7f8001fe,  \n\t0x788001e2,  \n\t0x71c001c7,\n\t0x6b8001ae,\n\t0x65400195,\n\t0x5fc0017f,\n\t0x5a400169,\n\t0x55400155,\n\t0x50800142,\n\t0x4c000130,\n\t0x47c0011f,\n\t0x43c0010f,\n\t0x40000100,\n\t0x3c8000f2,\n\t0x390000e4,\n\t0x35c000d7,\n\t0x32c000cb,\n\t0x300000c0,\n\t0x2d4000b5,\n\t0x2ac000ab,\n\t0x288000a2,\n\t0x26000098,\n\t0x24000090,\n\t0x22000088,\n\t0x20000080,\n\t0x1a00006c,\n\t0x1c800072,\n\t0x18000060,\n\t0x19800066,\n\t0x15800056,\n\t0x26c0005b,\n\t0x14400051,\n\t0x24400051,\n\t0x1300004c,\n\t0x12000048,\n\t0x11000044,\n\t0x10000040,  \n};\n\nconst u8 dm_cck_tx_bb_gain[CCK_TX_BB_GAIN_TABLE_LEN][8] = {\n\t{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},\n\t{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},\n\t{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},\n\t{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},\n\t{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},\n\t{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},\n\t{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},\n\t{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},\n\t{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},\n\t{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},\n\t{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},\n\t{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},\n\t{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},\n\t{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},\n\t{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},\n\t{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},\n\t{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},\n\t{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},\n\t{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},\n\t{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},\n\t{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},\n\t{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},\n\t{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01}\n};\n\nconst u8 dm_cck_tx_bb_gain_ch14[CCK_TX_BB_GAIN_TABLE_LEN][8] = {\n\t{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},\n\t{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},\n\t{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},\n\t{0x2d, 0x2d, 0x27, 0x17, 0x00, 0x00, 0x00, 0x00},\n\t{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},\n\t{0x28, 0x28, 0x22, 0x14, 0x00, 0x00, 0x00, 0x00},\n\t{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},\n\t{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},\n\t{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},\n\t{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},\n\t{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},\n\t{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},\n\t{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},\n\t{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},\n\t{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},\n\t{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},\n\t{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},\n\t{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},\n\t{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},\n\t{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},\n\t{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},\n\t{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},\n\t{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00}\n};\n\n \n\n\n \nstruct dig_t dm_digtable;\n\nstruct drx_path_sel dm_rx_path_sel_table;\n \n\n\n \n \n\n\n\n \nstatic void _rtl92e_dm_check_rate_adaptive(struct net_device *dev);\n\nstatic void _rtl92e_dm_init_bandwidth_autoswitch(struct net_device *dev);\nstatic\tvoid\t_rtl92e_dm_bandwidth_autoswitch(struct net_device *dev);\n\nstatic\tvoid\t_rtl92e_dm_check_tx_power_tracking(struct net_device *dev);\n\nstatic void _rtl92e_dm_bb_initialgain_restore(struct net_device *dev);\nstatic void _rtl92e_dm_dig_init(struct net_device *dev);\nstatic void _rtl92e_dm_ctrl_initgain_byrssi(struct net_device *dev);\nstatic void _rtl92e_dm_ctrl_initgain_byrssi_highpwr(struct net_device *dev);\nstatic void _rtl92e_dm_ctrl_initgain_byrssi_driver(struct net_device *dev);\nstatic void _rtl92e_dm_ctrl_initgain_byrssi_false_alarm(struct net_device *dev);\nstatic void _rtl92e_dm_initial_gain(struct net_device *dev);\nstatic void _rtl92e_dm_pd_th(struct net_device *dev);\nstatic void _rtl92e_dm_cs_ratio(struct net_device *dev);\n\nstatic\tvoid _rtl92e_dm_init_cts_to_self(struct net_device *dev);\n\nstatic void _rtl92e_dm_check_edca_turbo(struct net_device *dev);\nstatic void _rtl92e_dm_check_rx_path_selection(struct net_device *dev);\nstatic void _rtl92e_dm_init_rx_path_selection(struct net_device *dev);\nstatic void _rtl92e_dm_rx_path_sel_byrssi(struct net_device *dev);\n\nstatic void _rtl92e_dm_init_fsync(struct net_device *dev);\nstatic void _rtl92e_dm_deinit_fsync(struct net_device *dev);\n\nstatic\tvoid _rtl92e_dm_check_txrateandretrycount(struct net_device *dev);\nstatic void _rtl92e_dm_check_fsync(struct net_device *dev);\nstatic void _rtl92e_dm_check_rf_ctrl_gpio(void *data);\nstatic void _rtl92e_dm_fsync_timer_callback(struct timer_list *t);\n\n \n\nstatic\tvoid\t_rtl92e_dm_init_dynamic_tx_power(struct net_device *dev);\nstatic void _rtl92e_dm_dynamic_tx_power(struct net_device *dev);\n\nstatic void _rtl92e_dm_send_rssi_to_fw(struct net_device *dev);\nstatic void _rtl92e_dm_cts_to_self(struct net_device *dev);\n \n\nvoid rtl92e_dm_init(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tpriv->undecorated_smoothed_pwdb = -1;\n\n\t_rtl92e_dm_init_dynamic_tx_power(dev);\n\n\trtl92e_init_adaptive_rate(dev);\n\n\t_rtl92e_dm_dig_init(dev);\n\trtl92e_dm_init_edca_turbo(dev);\n\t_rtl92e_dm_init_bandwidth_autoswitch(dev);\n\t_rtl92e_dm_init_fsync(dev);\n\t_rtl92e_dm_init_rx_path_selection(dev);\n\t_rtl92e_dm_init_cts_to_self(dev);\n\n\tINIT_DELAYED_WORK(&priv->gpio_change_rf_wq, (void *)_rtl92e_dm_check_rf_ctrl_gpio);\n}\n\nvoid rtl92e_dm_deinit(struct net_device *dev)\n{\n\t_rtl92e_dm_deinit_fsync(dev);\n}\n\nvoid rtl92e_dm_watchdog(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->being_init_adapter)\n\t\treturn;\n\n\t_rtl92e_dm_check_txrateandretrycount(dev);\n\t_rtl92e_dm_check_edca_turbo(dev);\n\n\t_rtl92e_dm_check_rate_adaptive(dev);\n\t_rtl92e_dm_dynamic_tx_power(dev);\n\t_rtl92e_dm_check_tx_power_tracking(dev);\n\n\t_rtl92e_dm_ctrl_initgain_byrssi(dev);\n\t_rtl92e_dm_bandwidth_autoswitch(dev);\n\n\t_rtl92e_dm_check_rx_path_selection(dev);\n\t_rtl92e_dm_check_fsync(dev);\n\n\t_rtl92e_dm_send_rssi_to_fw(dev);\n\t_rtl92e_dm_cts_to_self(dev);\n}\n\nvoid rtl92e_init_adaptive_rate(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rate_adaptive *pra = &priv->rate_adaptive;\n\n\tpra->ratr_state = DM_RATR_STA_MAX;\n\tpra->high2low_rssi_thresh_for_ra = RATE_ADAPTIVE_TH_HIGH;\n\tpra->low2high_rssi_thresh_for_ra20M = RATE_ADAPTIVE_TH_LOW_20M + 5;\n\tpra->low2high_rssi_thresh_for_ra40M = RATE_ADAPTIVE_TH_LOW_40M + 5;\n\n\tpra->high_rssi_thresh_for_ra = RATE_ADAPTIVE_TH_HIGH + 5;\n\tpra->low_rssi_thresh_for_ra20M = RATE_ADAPTIVE_TH_LOW_20M;\n\tpra->low_rssi_thresh_for_ra40M = RATE_ADAPTIVE_TH_LOW_40M;\n\n\tif (priv->customer_id == RT_CID_819X_NETCORE)\n\t\tpra->ping_rssi_enable = 1;\n\telse\n\t\tpra->ping_rssi_enable = 0;\n\tpra->ping_rssi_thresh_for_ra = 15;\n\n\tpra->upper_rssi_threshold_ratr\t\t=\t0x000fc000;\n\tpra->middle_rssi_threshold_ratr\t\t=\t0x000ff000;\n\tpra->low_rssi_threshold_ratr\t\t=\t0x000ff001;\n\tpra->low_rssi_threshold_ratr_40M\t=\t0x000ff005;\n\tpra->low_rssi_threshold_ratr_20M\t=\t0x000ff001;\n\tpra->ping_rssi_ratr\t=\t0x0000000d;\n}\n\nstatic void _rtl92e_dm_check_rate_adaptive(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_hi_throughput *ht_info = priv->rtllib->ht_info;\n\tstruct rate_adaptive *pra = &priv->rate_adaptive;\n\tu32 current_ratr, target_ratr = 0;\n\tu32 low_rssi_thresh_for_ra = 0, high_rssi_thresh_for_ra = 0;\n\tbool bshort_gi_enabled = false;\n\tstatic u8 ping_rssi_state;\n\n\tif (!priv->up)\n\t\treturn;\n\n\tif (pra->rate_adaptive_disabled)\n\t\treturn;\n\n\tif (priv->rtllib->mode != WIRELESS_MODE_N_24G)\n\t\treturn;\n\n\tif (priv->rtllib->link_state == MAC80211_LINKED) {\n\t\tbshort_gi_enabled = (ht_info->cur_tx_bw40mhz &&\n\t\t\t\t     ht_info->bCurShortGI40MHz) ||\n\t\t\t\t    (!ht_info->cur_tx_bw40mhz &&\n\t\t\t\t     ht_info->bCurShortGI20MHz);\n\n\t\tpra->upper_rssi_threshold_ratr =\n\t\t\t\t(pra->upper_rssi_threshold_ratr & (~BIT31)) |\n\t\t\t\t((bshort_gi_enabled) ? BIT31 : 0);\n\n\t\tpra->middle_rssi_threshold_ratr =\n\t\t\t\t(pra->middle_rssi_threshold_ratr & (~BIT31)) |\n\t\t\t\t((bshort_gi_enabled) ? BIT31 : 0);\n\n\t\tif (priv->current_chnl_bw != HT_CHANNEL_WIDTH_20) {\n\t\t\tpra->low_rssi_threshold_ratr =\n\t\t\t\t(pra->low_rssi_threshold_ratr_40M & (~BIT31)) |\n\t\t\t\t((bshort_gi_enabled) ? BIT31 : 0);\n\t\t} else {\n\t\t\tpra->low_rssi_threshold_ratr =\n\t\t\t\t(pra->low_rssi_threshold_ratr_20M & (~BIT31)) |\n\t\t\t\t((bshort_gi_enabled) ? BIT31 : 0);\n\t\t}\n\t\tpra->ping_rssi_ratr =\n\t\t\t\t(pra->ping_rssi_ratr & (~BIT31)) |\n\t\t\t\t((bshort_gi_enabled) ? BIT31 : 0);\n\n\t\tif (pra->ratr_state == DM_RATR_STA_HIGH) {\n\t\t\thigh_rssi_thresh_for_ra = pra->high2low_rssi_thresh_for_ra;\n\t\t\tlow_rssi_thresh_for_ra = (priv->current_chnl_bw != HT_CHANNEL_WIDTH_20) ?\n\t\t\t\t\t(pra->low_rssi_thresh_for_ra40M) : (pra->low_rssi_thresh_for_ra20M);\n\t\t} else if (pra->ratr_state == DM_RATR_STA_LOW) {\n\t\t\thigh_rssi_thresh_for_ra = pra->high_rssi_thresh_for_ra;\n\t\t\tlow_rssi_thresh_for_ra = (priv->current_chnl_bw != HT_CHANNEL_WIDTH_20) ?\n\t\t\t\t\t(pra->low2high_rssi_thresh_for_ra40M) : (pra->low2high_rssi_thresh_for_ra20M);\n\t\t} else {\n\t\t\thigh_rssi_thresh_for_ra = pra->high_rssi_thresh_for_ra;\n\t\t\tlow_rssi_thresh_for_ra = (priv->current_chnl_bw != HT_CHANNEL_WIDTH_20) ?\n\t\t\t\t\t(pra->low_rssi_thresh_for_ra40M) : (pra->low_rssi_thresh_for_ra20M);\n\t\t}\n\n\t\tif (priv->undecorated_smoothed_pwdb >=\n\t\t    (long)high_rssi_thresh_for_ra) {\n\t\t\tpra->ratr_state = DM_RATR_STA_HIGH;\n\t\t\ttarget_ratr = pra->upper_rssi_threshold_ratr;\n\t\t} else if (priv->undecorated_smoothed_pwdb >=\n\t\t\t   (long)low_rssi_thresh_for_ra) {\n\t\t\tpra->ratr_state = DM_RATR_STA_MIDDLE;\n\t\t\ttarget_ratr = pra->middle_rssi_threshold_ratr;\n\t\t} else {\n\t\t\tpra->ratr_state = DM_RATR_STA_LOW;\n\t\t\ttarget_ratr = pra->low_rssi_threshold_ratr;\n\t\t}\n\n\t\tif (pra->ping_rssi_enable) {\n\t\t\tif (priv->undecorated_smoothed_pwdb <\n\t\t\t    (long)(pra->ping_rssi_thresh_for_ra + 5)) {\n\t\t\t\tif ((priv->undecorated_smoothed_pwdb <\n\t\t\t\t     (long)pra->ping_rssi_thresh_for_ra) ||\n\t\t\t\t    ping_rssi_state) {\n\t\t\t\t\tpra->ratr_state = DM_RATR_STA_LOW;\n\t\t\t\t\ttarget_ratr = pra->ping_rssi_ratr;\n\t\t\t\t\tping_rssi_state = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tping_rssi_state = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (priv->rtllib->GetHalfNmodeSupportByAPsHandler(dev))\n\t\t\ttarget_ratr &=  0xf00fffff;\n\n\t\tcurrent_ratr = rtl92e_readl(dev, RATR0);\n\t\tif (target_ratr !=  current_ratr) {\n\t\t\tu32 ratr_value;\n\n\t\t\tratr_value = target_ratr;\n\t\t\tratr_value &= ~(RATE_ALL_OFDM_2SS);\n\t\t\trtl92e_writel(dev, RATR0, ratr_value);\n\t\t\trtl92e_writeb(dev, UFWP, 1);\n\n\t\t\tpra->last_ratr = target_ratr;\n\t\t}\n\n\t} else {\n\t\tpra->ratr_state = DM_RATR_STA_MAX;\n\t}\n}\n\nstatic void _rtl92e_dm_init_bandwidth_autoswitch(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tpriv->rtllib->bandwidth_auto_switch.threshold_20Mhzto40Mhz = BW_AUTO_SWITCH_LOW_HIGH;\n\tpriv->rtllib->bandwidth_auto_switch.threshold_40Mhzto20Mhz = BW_AUTO_SWITCH_HIGH_LOW;\n\tpriv->rtllib->bandwidth_auto_switch.bforced_tx20Mhz = false;\n\tpriv->rtllib->bandwidth_auto_switch.bautoswitch_enable = false;\n}\n\nstatic void _rtl92e_dm_bandwidth_autoswitch(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->current_chnl_bw == HT_CHANNEL_WIDTH_20 ||\n\t    !priv->rtllib->bandwidth_auto_switch.bautoswitch_enable)\n\t\treturn;\n\tif (!priv->rtllib->bandwidth_auto_switch.bforced_tx20Mhz) {\n\t\tif (priv->undecorated_smoothed_pwdb <=\n\t\t    priv->rtllib->bandwidth_auto_switch.threshold_40Mhzto20Mhz)\n\t\t\tpriv->rtllib->bandwidth_auto_switch.bforced_tx20Mhz = true;\n\t} else {\n\t\tif (priv->undecorated_smoothed_pwdb >=\n\t\t    priv->rtllib->bandwidth_auto_switch.threshold_20Mhzto40Mhz)\n\t\t\tpriv->rtllib->bandwidth_auto_switch.bforced_tx20Mhz = false;\n\t}\n}\n\nstatic u32 OFDMSwingTable[OFDM_TABLE_LEN] = {\n\t0x7f8001fe,\n\t0x71c001c7,\n\t0x65400195,\n\t0x5a400169,\n\t0x50800142,\n\t0x47c0011f,\n\t0x40000100,\n\t0x390000e4,\n\t0x32c000cb,\n\t0x2d4000b5,\n\t0x288000a2,\n\t0x24000090,\n\t0x20000080,\n\t0x1c800072,\n\t0x19800066,\n\t0x26c0005b,\n\t0x24400051,\n\t0x12000048,\n\t0x10000040\n};\n\nstatic u8\tCCKSwingTable_Ch1_Ch13[CCK_TABLE_LEN][8] = {\n\t{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},\n\t{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},\n\t{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},\n\t{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},\n\t{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},\n\t{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},\n\t{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},\n\t{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},\n\t{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},\n\t{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},\n\t{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},\n\t{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01}\n};\n\nstatic u8\tCCKSwingTable_Ch14[CCK_TABLE_LEN][8] = {\n\t{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},\n\t{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},\n\t{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},\n\t{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},\n\t{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},\n\t{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},\n\t{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},\n\t{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},\n\t{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},\n\t{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},\n\t{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},\n\t{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00}\n};\n\n#define\t\tPw_Track_Flag\t\t\t\t0x11d\n#define\t\tTssi_Mea_Value\t\t\t\t0x13c\n#define\t\tTssi_Report_Value1\t\t\t0x134\n#define\t\tTssi_Report_Value2\t\t\t0x13e\n#define\t\tFW_Busy_Flag\t\t\t\t0x13f\n\nstatic void _rtl92e_dm_tx_update_tssi_weak_signal(struct net_device *dev)\n{\n\tstruct r8192_priv *p = rtllib_priv(dev);\n\n\tif (p->rfa_txpowertrackingindex > 0) {\n\t\tp->rfa_txpowertrackingindex--;\n\t\tif (p->rfa_txpowertrackingindex_real > 4) {\n\t\t\tp->rfa_txpowertrackingindex_real--;\n\t\t\trtl92e_set_bb_reg(dev,\n\t\t\t\t\t  rOFDM0_XATxIQImbalance,\n\t\t\t\t\t  bMaskDWord,\n\t\t\t\t\t  dm_tx_bb_gain[p->rfa_txpowertrackingindex_real]);\n\t\t}\n\t} else {\n\t\trtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance,\n\t\t\t\t  bMaskDWord, dm_tx_bb_gain[4]);\n\t}\n}\n\nstatic void _rtl92e_dm_tx_update_tssi_strong_signal(struct net_device *dev)\n{\n\tstruct r8192_priv *p = rtllib_priv(dev);\n\n\tif (p->rfa_txpowertrackingindex < (TX_BB_GAIN_TABLE_LEN - 1)) {\n\t\tp->rfa_txpowertrackingindex++;\n\t\tp->rfa_txpowertrackingindex_real++;\n\t\trtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance,\n\t\t\t\t  bMaskDWord,\n\t\t\t\t  dm_tx_bb_gain[p->rfa_txpowertrackingindex_real]);\n\t} else {\n\t\trtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance,\n\t\t\t\t  bMaskDWord,\n\t\t\t\t  dm_tx_bb_gain[TX_BB_GAIN_TABLE_LEN - 1]);\n\t}\n}\n\nstatic void _rtl92e_dm_tx_power_tracking_callback_tssi(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tbool\tviviflag = false;\n\tstruct dcmd_txcmd tx_cmd;\n\tint\ti = 0, j = 0, k = 0;\n\tu8\ttmp_report[5] = {0, 0, 0, 0, 0};\n\tu8\tPwr_Flag;\n\tu16\tAvg_TSSI_Meas, tssi_13dBm, Avg_TSSI_Meas_from_driver = 0;\n\tu32\tdelta = 0;\n\n\trtl92e_writeb(dev, Pw_Track_Flag, 0);\n\trtl92e_writeb(dev, FW_Busy_Flag, 0);\n\tpriv->rtllib->bdynamic_txpower_enable = false;\n\n\tfor (j = 0; j <= 30; j++) {\n\t\ttx_cmd.op\t= TXCMD_SET_TX_PWR_TRACKING;\n\t\ttx_cmd.length\t= 4;\n\t\ttx_cmd.value\t= priv->pwr_track >> 24;\n\t\trtl92e_send_cmd_pkt(dev, DESC_PACKET_TYPE_NORMAL, (u8 *)&tx_cmd,\n\t\t\t\t    sizeof(struct dcmd_txcmd));\n\t\tmdelay(1);\n\t\tfor (i = 0; i <= 30; i++) {\n\t\t\tPwr_Flag = rtl92e_readb(dev, Pw_Track_Flag);\n\n\t\t\tif (Pwr_Flag == 0) {\n\t\t\t\tmdelay(1);\n\n\t\t\t\tif (priv->reset_in_progress) {\n\t\t\t\t\trtl92e_writeb(dev, Pw_Track_Flag, 0);\n\t\t\t\t\trtl92e_writeb(dev, FW_Busy_Flag, 0);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (priv->rtllib->rf_power_state != rf_on) {\n\t\t\t\t\trtl92e_writeb(dev, Pw_Track_Flag, 0);\n\t\t\t\t\trtl92e_writeb(dev, FW_Busy_Flag, 0);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tAvg_TSSI_Meas = rtl92e_readw(dev, Tssi_Mea_Value);\n\n\t\t\tif (Avg_TSSI_Meas == 0) {\n\t\t\t\trtl92e_writeb(dev, Pw_Track_Flag, 0);\n\t\t\t\trtl92e_writeb(dev, FW_Busy_Flag, 0);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (k = 0; k < 5; k++) {\n\t\t\t\tif (k != 4)\n\t\t\t\t\ttmp_report[k] = rtl92e_readb(dev,\n\t\t\t\t\t\t\t Tssi_Report_Value1 + k);\n\t\t\t\telse\n\t\t\t\t\ttmp_report[k] = rtl92e_readb(dev,\n\t\t\t\t\t\t\t Tssi_Report_Value2);\n\n\t\t\t\tif (tmp_report[k] <= 20) {\n\t\t\t\t\tviviflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (viviflag) {\n\t\t\t\trtl92e_writeb(dev, Pw_Track_Flag, 0);\n\t\t\t\tviviflag = false;\n\t\t\t\tfor (k = 0; k < 5; k++)\n\t\t\t\t\ttmp_report[k] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (k = 0; k < 5; k++)\n\t\t\t\tAvg_TSSI_Meas_from_driver += tmp_report[k];\n\n\t\t\tAvg_TSSI_Meas_from_driver *= 100 / 5;\n\t\t\ttssi_13dBm = priv->tssi_13dBm;\n\n\t\t\tif (Avg_TSSI_Meas_from_driver > tssi_13dBm)\n\t\t\t\tdelta = Avg_TSSI_Meas_from_driver - tssi_13dBm;\n\t\t\telse\n\t\t\t\tdelta = tssi_13dBm - Avg_TSSI_Meas_from_driver;\n\n\t\t\tif (delta <= E_FOR_TX_POWER_TRACK) {\n\t\t\t\tpriv->rtllib->bdynamic_txpower_enable = true;\n\t\t\t\trtl92e_writeb(dev, Pw_Track_Flag, 0);\n\t\t\t\trtl92e_writeb(dev, FW_Busy_Flag, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (Avg_TSSI_Meas_from_driver < tssi_13dBm - E_FOR_TX_POWER_TRACK)\n\t\t\t\t_rtl92e_dm_tx_update_tssi_weak_signal(dev);\n\t\t\telse\n\t\t\t\t_rtl92e_dm_tx_update_tssi_strong_signal(dev);\n\n\t\t\tpriv->cck_present_attn_diff\n\t\t\t\t= priv->rfa_txpowertrackingindex_real - priv->rfa_txpowertracking_default;\n\n\t\t\tif (priv->current_chnl_bw == HT_CHANNEL_WIDTH_20)\n\t\t\t\tpriv->cck_present_attn =\n\t\t\t\t\t priv->cck_present_attn_20m_def +\n\t\t\t\t\t priv->cck_present_attn_diff;\n\t\t\telse\n\t\t\t\tpriv->cck_present_attn =\n\t\t\t\t\t priv->cck_present_attn_40m_def +\n\t\t\t\t\t priv->cck_present_attn_diff;\n\n\t\t\tif (priv->cck_present_attn > (CCK_TX_BB_GAIN_TABLE_LEN - 1))\n\t\t\t\tpriv->cck_present_attn = CCK_TX_BB_GAIN_TABLE_LEN - 1;\n\t\t\tif (priv->cck_present_attn < 0)\n\t\t\t\tpriv->cck_present_attn = 0;\n\n\t\t\tif (priv->cck_present_attn > -1 &&\n\t\t\t    priv->cck_present_attn < CCK_TX_BB_GAIN_TABLE_LEN) {\n\t\t\t\tif (priv->rtllib->current_network.channel == 14 &&\n\t\t\t\t    !priv->bcck_in_ch14) {\n\t\t\t\t\tpriv->bcck_in_ch14 = true;\n\t\t\t\t\trtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t\t\t} else if (priv->rtllib->current_network.channel != 14 && priv->bcck_in_ch14) {\n\t\t\t\t\tpriv->bcck_in_ch14 = false;\n\t\t\t\t\trtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t\t\t} else {\n\t\t\t\t\trtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (priv->cck_present_attn_diff <= -12 ||\n\t\t\t    priv->cck_present_attn_diff >= 24) {\n\t\t\t\tpriv->rtllib->bdynamic_txpower_enable = true;\n\t\t\t\trtl92e_writeb(dev, Pw_Track_Flag, 0);\n\t\t\t\trtl92e_writeb(dev, FW_Busy_Flag, 0);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trtl92e_writeb(dev, Pw_Track_Flag, 0);\n\t\t\tAvg_TSSI_Meas_from_driver = 0;\n\t\t\tfor (k = 0; k < 5; k++)\n\t\t\t\ttmp_report[k] = 0;\n\t\t\tbreak;\n\t\t}\n\t\trtl92e_writeb(dev, FW_Busy_Flag, 0);\n\t}\n\tpriv->rtllib->bdynamic_txpower_enable = true;\n\trtl92e_writeb(dev, Pw_Track_Flag, 0);\n}\n\nstatic void _rtl92e_dm_tx_power_tracking_cb_thermal(struct net_device *dev)\n{\n#define ThermalMeterVal\t9\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu32 tmp_reg, tmp_cck;\n\tu8 tmp_ofdm_index, tmp_cck_index, tmp_cck_20m_index, tmp_cck_40m_index, tmpval;\n\tint i = 0, CCKSwingNeedUpdate = 0;\n\n\tif (!priv->tx_pwr_tracking_init) {\n\t\ttmp_reg = rtl92e_get_bb_reg(dev, rOFDM0_XATxIQImbalance,\n\t\t\t\t\t    bMaskDWord);\n\t\tfor (i = 0; i < OFDM_TABLE_LEN; i++) {\n\t\t\tif (tmp_reg == OFDMSwingTable[i])\n\t\t\t\tpriv->ofdm_index[0] = i;\n\t\t}\n\n\t\ttmp_cck = rtl92e_get_bb_reg(dev, rCCK0_TxFilter1, bMaskByte2);\n\t\tfor (i = 0; i < CCK_TABLE_LEN; i++) {\n\t\t\tif (tmp_cck == (u32)CCKSwingTable_Ch1_Ch13[i][0]) {\n\t\t\t\tpriv->cck_index = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpriv->tx_pwr_tracking_init = true;\n\t\treturn;\n\t}\n\n\ttmp_reg = rtl92e_get_rf_reg(dev, RF90_PATH_A, 0x12, 0x078);\n\tif (tmp_reg < 3 || tmp_reg > 13)\n\t\treturn;\n\tif (tmp_reg >= 12)\n\t\ttmp_reg = 12;\n\tpriv->thermal_meter[0] = ThermalMeterVal;\n\tpriv->thermal_meter[1] = ThermalMeterVal;\n\n\tif (priv->thermal_meter[0] >= (u8)tmp_reg) {\n\t\ttmp_ofdm_index = 6 + (priv->thermal_meter[0] - (u8)tmp_reg);\n\t\ttmp_cck_20m_index = tmp_ofdm_index;\n\t\ttmp_cck_40m_index = tmp_cck_20m_index - 6;\n\t\tif (tmp_ofdm_index >= OFDM_TABLE_LEN)\n\t\t\ttmp_ofdm_index = OFDM_TABLE_LEN - 1;\n\t\tif (tmp_cck_20m_index >= CCK_TABLE_LEN)\n\t\t\ttmp_cck_20m_index = CCK_TABLE_LEN - 1;\n\t\tif (tmp_cck_40m_index >= CCK_TABLE_LEN)\n\t\t\ttmp_cck_40m_index = CCK_TABLE_LEN - 1;\n\t} else {\n\t\ttmpval = (u8)tmp_reg - priv->thermal_meter[0];\n\t\tif (tmpval >= 6) {\n\t\t\ttmp_ofdm_index = 0;\n\t\t\ttmp_cck_20m_index = 0;\n\t\t} else {\n\t\t\ttmp_ofdm_index = 6 - tmpval;\n\t\t\ttmp_cck_20m_index = 6 - tmpval;\n\t\t}\n\t\ttmp_cck_40m_index = 0;\n\t}\n\tif (priv->current_chnl_bw != HT_CHANNEL_WIDTH_20)\n\t\ttmp_cck_index = tmp_cck_40m_index;\n\telse\n\t\ttmp_cck_index = tmp_cck_20m_index;\n\n\tpriv->rec_cck_20m_idx = tmp_cck_20m_index;\n\tpriv->rec_cck_40m_idx = tmp_cck_40m_index;\n\n\tif (priv->rtllib->current_network.channel == 14 &&\n\t    !priv->bcck_in_ch14) {\n\t\tpriv->bcck_in_ch14 = true;\n\t\tCCKSwingNeedUpdate = 1;\n\t} else if (priv->rtllib->current_network.channel != 14 &&\n\t\t   priv->bcck_in_ch14) {\n\t\tpriv->bcck_in_ch14 = false;\n\t\tCCKSwingNeedUpdate = 1;\n\t}\n\n\tif (priv->cck_index != tmp_cck_index) {\n\t\tpriv->cck_index = tmp_cck_index;\n\t\tCCKSwingNeedUpdate = 1;\n\t}\n\n\tif (CCKSwingNeedUpdate)\n\t\trtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\tif (priv->ofdm_index[0] != tmp_ofdm_index) {\n\t\tpriv->ofdm_index[0] = tmp_ofdm_index;\n\t\trtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance, bMaskDWord,\n\t\t\t\t  OFDMSwingTable[priv->ofdm_index[0]]);\n\t}\n\tpriv->txpower_count = 0;\n}\n\nvoid rtl92e_dm_txpower_tracking_wq(void *data)\n{\n\tstruct r8192_priv *priv = container_of_dwork_rsl(data,\n\t\t\t\t  struct r8192_priv, txpower_tracking_wq);\n\tstruct net_device *dev = priv->rtllib->dev;\n\n\tif (priv->ic_cut >= IC_VersionCut_D)\n\t\t_rtl92e_dm_tx_power_tracking_callback_tssi(dev);\n\telse\n\t\t_rtl92e_dm_tx_power_tracking_cb_thermal(dev);\n}\n\nstatic void _rtl92e_dm_initialize_tx_power_tracking_tssi(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tpriv->btxpower_tracking = true;\n\tpriv->txpower_count       = 0;\n\tpriv->tx_pwr_tracking_init = false;\n}\n\nstatic void _rtl92e_dm_init_tx_power_tracking_thermal(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->rtllib->FwRWRF)\n\t\tpriv->btxpower_tracking = true;\n\telse\n\t\tpriv->btxpower_tracking = false;\n\tpriv->txpower_count       = 0;\n\tpriv->tx_pwr_tracking_init = false;\n}\n\nvoid rtl92e_dm_init_txpower_tracking(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->ic_cut >= IC_VersionCut_D)\n\t\t_rtl92e_dm_initialize_tx_power_tracking_tssi(dev);\n\telse\n\t\t_rtl92e_dm_init_tx_power_tracking_thermal(dev);\n}\n\nstatic void _rtl92e_dm_check_tx_power_tracking_tssi(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstatic u32 tx_power_track_counter;\n\n\tif (rtl92e_readb(dev, 0x11e) == 1)\n\t\treturn;\n\tif (!priv->btxpower_tracking)\n\t\treturn;\n\ttx_power_track_counter++;\n\n\tif (tx_power_track_counter >= 180) {\n\t\tschedule_delayed_work(&priv->txpower_tracking_wq, 0);\n\t\ttx_power_track_counter = 0;\n\t}\n}\n\nstatic void _rtl92e_dm_check_tx_power_tracking_thermal(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstatic u8\tTM_Trigger;\n\tu8\t\tTxPowerCheckCnt = 0;\n\n\tTxPowerCheckCnt = 2;\n\tif (!priv->btxpower_tracking)\n\t\treturn;\n\n\tif (priv->txpower_count  <= TxPowerCheckCnt) {\n\t\tpriv->txpower_count++;\n\t\treturn;\n\t}\n\n\tif (!TM_Trigger) {\n\t\trtl92e_set_rf_reg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4d);\n\t\trtl92e_set_rf_reg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4f);\n\t\trtl92e_set_rf_reg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4d);\n\t\trtl92e_set_rf_reg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4f);\n\t\tTM_Trigger = 1;\n\t\treturn;\n\t}\n\tnetdev_info(dev, \"===============>Schedule TxPowerTrackingWorkItem\\n\");\n\tschedule_delayed_work(&priv->txpower_tracking_wq, 0);\n\tTM_Trigger = 0;\n}\n\nstatic void _rtl92e_dm_check_tx_power_tracking(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->ic_cut >= IC_VersionCut_D)\n\t\t_rtl92e_dm_check_tx_power_tracking_tssi(dev);\n\telse\n\t\t_rtl92e_dm_check_tx_power_tracking_thermal(dev);\n}\n\nstatic void _rtl92e_dm_cck_tx_power_adjust_tssi(struct net_device *dev,\n\t\t\t\t\t\tbool bInCH14)\n{\n\tu32 TempVal;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8 attenuation = priv->cck_present_attn;\n\n\tTempVal = 0;\n\tif (!bInCH14) {\n\t\tTempVal = (u32)(dm_cck_tx_bb_gain[attenuation][0] +\n\t\t\t  (dm_cck_tx_bb_gain[attenuation][1] << 8));\n\n\t\trtl92e_set_bb_reg(dev, rCCK0_TxFilter1, bMaskHWord, TempVal);\n\t\tTempVal = (u32)((dm_cck_tx_bb_gain[attenuation][2]) +\n\t\t\t  (dm_cck_tx_bb_gain[attenuation][3] << 8) +\n\t\t\t  (dm_cck_tx_bb_gain[attenuation][4] << 16) +\n\t\t\t  (dm_cck_tx_bb_gain[attenuation][5] << 24));\n\t\trtl92e_set_bb_reg(dev, rCCK0_TxFilter2, bMaskDWord, TempVal);\n\t\tTempVal = (u32)(dm_cck_tx_bb_gain[attenuation][6] +\n\t\t\t  (dm_cck_tx_bb_gain[attenuation][7] << 8));\n\n\t\trtl92e_set_bb_reg(dev, rCCK0_DebugPort, bMaskLWord, TempVal);\n\t} else {\n\t\tTempVal = (u32)((dm_cck_tx_bb_gain_ch14[attenuation][0]) +\n\t\t\t  (dm_cck_tx_bb_gain_ch14[attenuation][1] << 8));\n\n\t\trtl92e_set_bb_reg(dev, rCCK0_TxFilter1, bMaskHWord, TempVal);\n\t\tTempVal = (u32)((dm_cck_tx_bb_gain_ch14[attenuation][2]) +\n\t\t\t  (dm_cck_tx_bb_gain_ch14[attenuation][3] << 8) +\n\t\t\t  (dm_cck_tx_bb_gain_ch14[attenuation][4] << 16) +\n\t\t\t  (dm_cck_tx_bb_gain_ch14[attenuation][5] << 24));\n\t\trtl92e_set_bb_reg(dev, rCCK0_TxFilter2, bMaskDWord, TempVal);\n\t\tTempVal = (u32)((dm_cck_tx_bb_gain_ch14[attenuation][6]) +\n\t\t\t  (dm_cck_tx_bb_gain_ch14[attenuation][7] << 8));\n\n\t\trtl92e_set_bb_reg(dev, rCCK0_DebugPort, bMaskLWord, TempVal);\n\t}\n}\n\nstatic void _rtl92e_dm_cck_tx_power_adjust_thermal_meter(struct net_device *dev,\n\t\t\t\t\t\t\t bool bInCH14)\n{\n\tu32 TempVal;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tTempVal = 0;\n\tif (!bInCH14) {\n\t\tTempVal = CCKSwingTable_Ch1_Ch13[priv->cck_index][0] +\n\t\t\t  (CCKSwingTable_Ch1_Ch13[priv->cck_index][1] << 8);\n\t\trtl92e_set_bb_reg(dev, rCCK0_TxFilter1, bMaskHWord, TempVal);\n\t\tTempVal = CCKSwingTable_Ch1_Ch13[priv->cck_index][2] +\n\t\t\t  (CCKSwingTable_Ch1_Ch13[priv->cck_index][3] << 8) +\n\t\t\t  (CCKSwingTable_Ch1_Ch13[priv->cck_index][4] << 16) +\n\t\t\t  (CCKSwingTable_Ch1_Ch13[priv->cck_index][5] << 24);\n\t\trtl92e_set_bb_reg(dev, rCCK0_TxFilter2, bMaskDWord, TempVal);\n\t\tTempVal = CCKSwingTable_Ch1_Ch13[priv->cck_index][6] +\n\t\t\t  (CCKSwingTable_Ch1_Ch13[priv->cck_index][7] << 8);\n\n\t\trtl92e_set_bb_reg(dev, rCCK0_DebugPort, bMaskLWord, TempVal);\n\t} else {\n\t\tTempVal = CCKSwingTable_Ch14[priv->cck_index][0] +\n\t\t\t  (CCKSwingTable_Ch14[priv->cck_index][1] << 8);\n\n\t\trtl92e_set_bb_reg(dev, rCCK0_TxFilter1, bMaskHWord, TempVal);\n\t\tTempVal = CCKSwingTable_Ch14[priv->cck_index][2] +\n\t\t\t  (CCKSwingTable_Ch14[priv->cck_index][3] << 8) +\n\t\t\t  (CCKSwingTable_Ch14[priv->cck_index][4] << 16) +\n\t\t\t  (CCKSwingTable_Ch14[priv->cck_index][5] << 24);\n\t\trtl92e_set_bb_reg(dev, rCCK0_TxFilter2, bMaskDWord, TempVal);\n\t\tTempVal = CCKSwingTable_Ch14[priv->cck_index][6] +\n\t\t\t  (CCKSwingTable_Ch14[priv->cck_index][7] << 8);\n\n\t\trtl92e_set_bb_reg(dev, rCCK0_DebugPort, bMaskLWord, TempVal);\n\t}\n}\n\nvoid rtl92e_dm_cck_txpower_adjust(struct net_device *dev, bool binch14)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->ic_cut >= IC_VersionCut_D)\n\t\t_rtl92e_dm_cck_tx_power_adjust_tssi(dev, binch14);\n\telse\n\t\t_rtl92e_dm_cck_tx_power_adjust_thermal_meter(dev, binch14);\n}\n\nstatic void _rtl92e_dm_tx_power_reset_recovery(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\trtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance, bMaskDWord,\n\t\t\t  dm_tx_bb_gain[priv->rfa_txpowertrackingindex]);\n\trtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\n\n\trtl92e_set_bb_reg(dev, rOFDM0_XCTxIQImbalance, bMaskDWord,\n\t\t\t  dm_tx_bb_gain[priv->rfc_txpowertrackingindex]);\n}\n\nvoid rtl92e_dm_restore_state(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu32\treg_ratr = priv->rate_adaptive.last_ratr;\n\tu32 ratr_value;\n\n\tif (!priv->up)\n\t\treturn;\n\n\tif (priv->rate_adaptive.rate_adaptive_disabled)\n\t\treturn;\n\tif (priv->rtllib->mode != WIRELESS_MODE_N_24G)\n\t\treturn;\n\tratr_value = reg_ratr;\n\tratr_value &= ~(RATE_ALL_OFDM_2SS);\n\trtl92e_writel(dev, RATR0, ratr_value);\n\trtl92e_writeb(dev, UFWP, 1);\n\tif (priv->tx_pwr_tracking_init && priv->btxpower_tracking)\n\t\t_rtl92e_dm_tx_power_reset_recovery(dev);\n\n\t_rtl92e_dm_bb_initialgain_restore(dev);\n}\n\nstatic void _rtl92e_dm_bb_initialgain_restore(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu32 bit_mask = 0x7f;\n\n\tif (dm_digtable.dig_algorithm == DIG_ALGO_BY_RSSI)\n\t\treturn;\n\n\trtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x8);\n\trtl92e_set_bb_reg(dev, rOFDM0_XAAGCCore1, bit_mask,\n\t\t\t  (u32)priv->initgain_backup.xaagccore1);\n\trtl92e_set_bb_reg(dev, rOFDM0_XBAGCCore1, bit_mask,\n\t\t\t  (u32)priv->initgain_backup.xbagccore1);\n\trtl92e_set_bb_reg(dev, rOFDM0_XCAGCCore1, bit_mask,\n\t\t\t  (u32)priv->initgain_backup.xcagccore1);\n\trtl92e_set_bb_reg(dev, rOFDM0_XDAGCCore1, bit_mask,\n\t\t\t  (u32)priv->initgain_backup.xdagccore1);\n\tbit_mask  = bMaskByte2;\n\trtl92e_set_bb_reg(dev, rCCK0_CCA, bit_mask,\n\t\t\t  (u32)priv->initgain_backup.cca);\n\trtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x1);\n}\n\nvoid rtl92e_dm_backup_state(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu32 bit_mask = bMaskByte0;\n\n\tpriv->bswitch_fsync  = false;\n\n\tif (dm_digtable.dig_algorithm == DIG_ALGO_BY_RSSI)\n\t\treturn;\n\n\trtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x8);\n\tpriv->initgain_backup.xaagccore1 = rtl92e_get_bb_reg(dev, rOFDM0_XAAGCCore1, bit_mask);\n\tpriv->initgain_backup.xbagccore1 = rtl92e_get_bb_reg(dev, rOFDM0_XBAGCCore1, bit_mask);\n\tpriv->initgain_backup.xcagccore1 = rtl92e_get_bb_reg(dev, rOFDM0_XCAGCCore1, bit_mask);\n\tpriv->initgain_backup.xdagccore1 = rtl92e_get_bb_reg(dev, rOFDM0_XDAGCCore1, bit_mask);\n\tbit_mask  = bMaskByte2;\n\tpriv->initgain_backup.cca = (u8)rtl92e_get_bb_reg(dev, rCCK0_CCA, bit_mask);\n}\n\nstatic void _rtl92e_dm_dig_init(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tdm_digtable.dig_enable_flag\t= true;\n\n\tdm_digtable.dig_algorithm = DIG_ALGO_BY_RSSI;\n\n\tdm_digtable.dig_algorithm_switch = 0;\n\n\tdm_digtable.dig_state\t\t= DM_STA_DIG_MAX;\n\tdm_digtable.dig_highpwr_state\t= DM_STA_DIG_MAX;\n\tdm_digtable.cur_sta_connect_state = DIG_STA_DISCONNECT;\n\tdm_digtable.pre_sta_connect_state = DIG_STA_DISCONNECT;\n\n\tdm_digtable.rssi_low_thresh\t= DM_DIG_THRESH_LOW;\n\tdm_digtable.rssi_high_thresh\t= DM_DIG_THRESH_HIGH;\n\n\tdm_digtable.rssi_high_power_lowthresh = DM_DIG_HIGH_PWR_THRESH_LOW;\n\tdm_digtable.rssi_high_power_highthresh = DM_DIG_HIGH_PWR_THRESH_HIGH;\n\n\tdm_digtable.rssi_val = 50;\n\tdm_digtable.backoff_val = DM_DIG_BACKOFF;\n\tdm_digtable.rx_gain_range_max = DM_DIG_MAX;\n\tif (priv->customer_id == RT_CID_819X_NETCORE)\n\t\tdm_digtable.rx_gain_range_min = DM_DIG_MIN_Netcore;\n\telse\n\t\tdm_digtable.rx_gain_range_min = DM_DIG_MIN;\n}\n\nstatic void _rtl92e_dm_ctrl_initgain_byrssi(struct net_device *dev)\n{\n\tif (!dm_digtable.dig_enable_flag)\n\t\treturn;\n\n\tif (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\n\t\t_rtl92e_dm_ctrl_initgain_byrssi_false_alarm(dev);\n\telse if (dm_digtable.dig_algorithm == DIG_ALGO_BY_RSSI)\n\t\t_rtl92e_dm_ctrl_initgain_byrssi_driver(dev);\n\telse\n\t\treturn;\n}\n\n \n\nstatic void _rtl92e_dm_ctrl_initgain_byrssi_driver(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8 i;\n\tstatic u8\tfw_dig;\n\n\tif (!dm_digtable.dig_enable_flag)\n\t\treturn;\n\n\tif (dm_digtable.dig_algorithm_switch)\n\t\tfw_dig = 0;\n\tif (fw_dig <= 3) {\n\t\tfor (i = 0; i < 3; i++)\n\t\t\trtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x8);\n\t\tfw_dig++;\n\t\tdm_digtable.dig_state = DM_STA_DIG_OFF;\n\t}\n\n\tif (priv->rtllib->link_state == MAC80211_LINKED)\n\t\tdm_digtable.cur_sta_connect_state = DIG_STA_CONNECT;\n\telse\n\t\tdm_digtable.cur_sta_connect_state = DIG_STA_DISCONNECT;\n\n\tdm_digtable.rssi_val = priv->undecorated_smoothed_pwdb;\n\t_rtl92e_dm_initial_gain(dev);\n\t_rtl92e_dm_pd_th(dev);\n\t_rtl92e_dm_cs_ratio(dev);\n\tif (dm_digtable.dig_algorithm_switch)\n\t\tdm_digtable.dig_algorithm_switch = 0;\n\tdm_digtable.pre_sta_connect_state = dm_digtable.cur_sta_connect_state;\n}\n\nstatic void _rtl92e_dm_ctrl_initgain_byrssi_false_alarm(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstatic u32 reset_cnt;\n\tu8 i;\n\n\tif (!dm_digtable.dig_enable_flag)\n\t\treturn;\n\n\tif (dm_digtable.dig_algorithm_switch) {\n\t\tdm_digtable.dig_state = DM_STA_DIG_MAX;\n\t\tfor (i = 0; i < 3; i++)\n\t\t\trtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x1);\n\t\tdm_digtable.dig_algorithm_switch = 0;\n\t}\n\n\tif (priv->rtllib->link_state != MAC80211_LINKED)\n\t\treturn;\n\n\tif ((priv->undecorated_smoothed_pwdb > dm_digtable.rssi_low_thresh) &&\n\t\t(priv->undecorated_smoothed_pwdb < dm_digtable.rssi_high_thresh))\n\t\treturn;\n\tif (priv->undecorated_smoothed_pwdb <= dm_digtable.rssi_low_thresh) {\n\t\tif (dm_digtable.dig_state == DM_STA_DIG_OFF &&\n\t\t\t(priv->reset_count == reset_cnt))\n\t\t\treturn;\n\t\treset_cnt = priv->reset_count;\n\n\t\tdm_digtable.dig_highpwr_state = DM_STA_DIG_MAX;\n\t\tdm_digtable.dig_state = DM_STA_DIG_OFF;\n\n\t\trtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x8);\n\n\t\trtl92e_writeb(dev, rOFDM0_XAAGCCore1, 0x17);\n\t\trtl92e_writeb(dev, rOFDM0_XBAGCCore1, 0x17);\n\t\trtl92e_writeb(dev, rOFDM0_XCAGCCore1, 0x17);\n\t\trtl92e_writeb(dev, rOFDM0_XDAGCCore1, 0x17);\n\n\t\tif (priv->current_chnl_bw != HT_CHANNEL_WIDTH_20)\n\t\t\trtl92e_writeb(dev, (rOFDM0_XATxAFE + 3), 0x00);\n\t\telse\n\t\t\trtl92e_writeb(dev, rOFDM0_RxDetector1, 0x42);\n\n\t\trtl92e_writeb(dev, 0xa0a, 0x08);\n\n\t\treturn;\n\t}\n\n\tif (priv->undecorated_smoothed_pwdb >= dm_digtable.rssi_high_thresh) {\n\t\tu8 reset_flag = 0;\n\n\t\tif (dm_digtable.dig_state == DM_STA_DIG_ON &&\n\t\t    (priv->reset_count == reset_cnt)) {\n\t\t\t_rtl92e_dm_ctrl_initgain_byrssi_highpwr(dev);\n\t\t\treturn;\n\t\t}\n\t\tif (priv->reset_count != reset_cnt)\n\t\t\treset_flag = 1;\n\n\t\treset_cnt = priv->reset_count;\n\n\t\tdm_digtable.dig_state = DM_STA_DIG_ON;\n\n\t\tif (reset_flag == 1) {\n\t\t\trtl92e_writeb(dev, rOFDM0_XAAGCCore1, 0x2c);\n\t\t\trtl92e_writeb(dev, rOFDM0_XBAGCCore1, 0x2c);\n\t\t\trtl92e_writeb(dev, rOFDM0_XCAGCCore1, 0x2c);\n\t\t\trtl92e_writeb(dev, rOFDM0_XDAGCCore1, 0x2c);\n\t\t} else {\n\t\t\trtl92e_writeb(dev, rOFDM0_XAAGCCore1, 0x20);\n\t\t\trtl92e_writeb(dev, rOFDM0_XBAGCCore1, 0x20);\n\t\t\trtl92e_writeb(dev, rOFDM0_XCAGCCore1, 0x20);\n\t\t\trtl92e_writeb(dev, rOFDM0_XDAGCCore1, 0x20);\n\t\t}\n\n\t\tif (priv->current_chnl_bw != HT_CHANNEL_WIDTH_20)\n\t\t\trtl92e_writeb(dev, (rOFDM0_XATxAFE + 3), 0x20);\n\t\telse\n\t\t\trtl92e_writeb(dev, rOFDM0_RxDetector1, 0x44);\n\n\t\trtl92e_writeb(dev, 0xa0a, 0xcd);\n\n\t\trtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x1);\n\t}\n\t_rtl92e_dm_ctrl_initgain_byrssi_highpwr(dev);\n}\n\nstatic void _rtl92e_dm_ctrl_initgain_byrssi_highpwr(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstatic u32 reset_cnt_highpwr;\n\n\tif ((priv->undecorated_smoothed_pwdb >\n\t     dm_digtable.rssi_high_power_lowthresh) &&\n\t    (priv->undecorated_smoothed_pwdb <\n\t     dm_digtable.rssi_high_power_highthresh))\n\t\treturn;\n\n\tif (priv->undecorated_smoothed_pwdb >=\n\t    dm_digtable.rssi_high_power_highthresh) {\n\t\tif (dm_digtable.dig_highpwr_state == DM_STA_DIG_ON &&\n\t\t\t(priv->reset_count == reset_cnt_highpwr))\n\t\t\treturn;\n\t\tdm_digtable.dig_highpwr_state = DM_STA_DIG_ON;\n\n\t\tif (priv->current_chnl_bw != HT_CHANNEL_WIDTH_20)\n\t\t\trtl92e_writeb(dev, (rOFDM0_XATxAFE + 3), 0x10);\n\t\telse\n\t\t\trtl92e_writeb(dev, rOFDM0_RxDetector1, 0x43);\n\t} else {\n\t\tif (dm_digtable.dig_highpwr_state == DM_STA_DIG_OFF &&\n\t\t\t(priv->reset_count == reset_cnt_highpwr))\n\t\t\treturn;\n\t\tdm_digtable.dig_highpwr_state = DM_STA_DIG_OFF;\n\n\t\tif ((priv->undecorated_smoothed_pwdb <\n\t\t     dm_digtable.rssi_high_power_lowthresh) &&\n\t\t    (priv->undecorated_smoothed_pwdb >=\n\t\t    dm_digtable.rssi_high_thresh)) {\n\t\t\tif (priv->current_chnl_bw != HT_CHANNEL_WIDTH_20)\n\t\t\t\trtl92e_writeb(dev, (rOFDM0_XATxAFE + 3), 0x20);\n\t\t\telse\n\t\t\t\trtl92e_writeb(dev, rOFDM0_RxDetector1, 0x44);\n\t\t}\n\t}\n\treset_cnt_highpwr = priv->reset_count;\n}\n\nstatic void _rtl92e_dm_initial_gain(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8 initial_gain = 0;\n\tstatic u8 initialized, force_write;\n\tstatic u32 reset_cnt;\n\n\tif (dm_digtable.dig_algorithm_switch) {\n\t\tinitialized = 0;\n\t\treset_cnt = 0;\n\t}\n\n\tif (rtllib_act_scanning(priv->rtllib, true)) {\n\t\tforce_write = 1;\n\t\treturn;\n\t}\n\n\tif (dm_digtable.pre_sta_connect_state == dm_digtable.cur_sta_connect_state) {\n\t\tif (dm_digtable.cur_sta_connect_state == DIG_STA_CONNECT) {\n\t\t\tlong gain_range = dm_digtable.rssi_val + 10 -\n\t\t\t\t\t  dm_digtable.backoff_val;\n\t\t\tgain_range = clamp_t(long, gain_range,\n\t\t\t\t\t     dm_digtable.rx_gain_range_min,\n\t\t\t\t\t     dm_digtable.rx_gain_range_max);\n\t\t\tdm_digtable.cur_ig_value = gain_range;\n\t\t} else {\n\t\t\tif (dm_digtable.cur_ig_value == 0)\n\t\t\t\tdm_digtable.cur_ig_value = priv->def_initial_gain[0];\n\t\t\telse\n\t\t\t\tdm_digtable.cur_ig_value = dm_digtable.pre_ig_value;\n\t\t}\n\t} else {\n\t\tdm_digtable.cur_ig_value = priv->def_initial_gain[0];\n\t\tdm_digtable.pre_ig_value = 0;\n\t}\n\n\tif (priv->reset_count != reset_cnt) {\n\t\tforce_write = 1;\n\t\treset_cnt = priv->reset_count;\n\t}\n\n\tif (dm_digtable.pre_ig_value != rtl92e_readb(dev, rOFDM0_XAAGCCore1))\n\t\tforce_write = 1;\n\n\tif ((dm_digtable.pre_ig_value != dm_digtable.cur_ig_value)\n\t    || !initialized || force_write) {\n\t\tinitial_gain = dm_digtable.cur_ig_value;\n\t\trtl92e_writeb(dev, rOFDM0_XAAGCCore1, initial_gain);\n\t\trtl92e_writeb(dev, rOFDM0_XBAGCCore1, initial_gain);\n\t\trtl92e_writeb(dev, rOFDM0_XCAGCCore1, initial_gain);\n\t\trtl92e_writeb(dev, rOFDM0_XDAGCCore1, initial_gain);\n\t\tdm_digtable.pre_ig_value = dm_digtable.cur_ig_value;\n\t\tinitialized = 1;\n\t\tforce_write = 0;\n\t}\n}\n\nstatic void _rtl92e_dm_pd_th(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstatic u8 initialized, force_write;\n\tstatic u32 reset_cnt;\n\n\tif (dm_digtable.dig_algorithm_switch) {\n\t\tinitialized = 0;\n\t\treset_cnt = 0;\n\t}\n\n\tif (dm_digtable.pre_sta_connect_state == dm_digtable.cur_sta_connect_state) {\n\t\tif (dm_digtable.cur_sta_connect_state == DIG_STA_CONNECT) {\n\t\t\tif (dm_digtable.rssi_val >=\n\t\t\t    dm_digtable.rssi_high_power_highthresh)\n\t\t\t\tdm_digtable.curpd_thstate =\n\t\t\t\t\t\t\tDIG_PD_AT_HIGH_POWER;\n\t\t\telse if (dm_digtable.rssi_val <=\n\t\t\t\t dm_digtable.rssi_low_thresh)\n\t\t\t\tdm_digtable.curpd_thstate =\n\t\t\t\t\t\t\tDIG_PD_AT_LOW_POWER;\n\t\t\telse if ((dm_digtable.rssi_val >=\n\t\t\t\t  dm_digtable.rssi_high_thresh) &&\n\t\t\t\t (dm_digtable.rssi_val <\n\t\t\t\t  dm_digtable.rssi_high_power_lowthresh))\n\t\t\t\tdm_digtable.curpd_thstate =\n\t\t\t\t\t\t\tDIG_PD_AT_NORMAL_POWER;\n\t\t\telse\n\t\t\t\tdm_digtable.curpd_thstate =\n\t\t\t\t\t\tdm_digtable.prepd_thstate;\n\t\t} else {\n\t\t\tdm_digtable.curpd_thstate = DIG_PD_AT_LOW_POWER;\n\t\t}\n\t} else {\n\t\tdm_digtable.curpd_thstate = DIG_PD_AT_LOW_POWER;\n\t}\n\n\tif (priv->reset_count != reset_cnt) {\n\t\tforce_write = 1;\n\t\treset_cnt = priv->reset_count;\n\t}\n\n\tif ((dm_digtable.prepd_thstate != dm_digtable.curpd_thstate) ||\n\t    (initialized <= 3) || force_write) {\n\t\tif (dm_digtable.curpd_thstate == DIG_PD_AT_LOW_POWER) {\n\t\t\tif (priv->current_chnl_bw != HT_CHANNEL_WIDTH_20)\n\t\t\t\trtl92e_writeb(dev, (rOFDM0_XATxAFE + 3), 0x00);\n\t\t\telse\n\t\t\t\trtl92e_writeb(dev, rOFDM0_RxDetector1, 0x42);\n\t\t} else if (dm_digtable.curpd_thstate ==\n\t\t\t   DIG_PD_AT_NORMAL_POWER) {\n\t\t\tif (priv->current_chnl_bw != HT_CHANNEL_WIDTH_20)\n\t\t\t\trtl92e_writeb(dev, (rOFDM0_XATxAFE + 3), 0x20);\n\t\t\telse\n\t\t\t\trtl92e_writeb(dev, rOFDM0_RxDetector1, 0x44);\n\t\t} else if (dm_digtable.curpd_thstate == DIG_PD_AT_HIGH_POWER) {\n\t\t\tif (priv->current_chnl_bw != HT_CHANNEL_WIDTH_20)\n\t\t\t\trtl92e_writeb(dev, (rOFDM0_XATxAFE + 3), 0x10);\n\t\t\telse\n\t\t\t\trtl92e_writeb(dev, rOFDM0_RxDetector1, 0x43);\n\t\t}\n\t\tdm_digtable.prepd_thstate = dm_digtable.curpd_thstate;\n\t\tif (initialized <= 3)\n\t\t\tinitialized++;\n\t\tforce_write = 0;\n\t}\n}\n\nstatic void _rtl92e_dm_cs_ratio(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstatic u8 initialized, force_write;\n\tstatic u32 reset_cnt;\n\n\tif (dm_digtable.dig_algorithm_switch) {\n\t\tinitialized = 0;\n\t\treset_cnt = 0;\n\t}\n\n\tif (dm_digtable.pre_sta_connect_state == dm_digtable.cur_sta_connect_state) {\n\t\tif (dm_digtable.cur_sta_connect_state == DIG_STA_CONNECT) {\n\t\t\tif (dm_digtable.rssi_val <= dm_digtable.rssi_low_thresh)\n\t\t\t\tdm_digtable.curcs_ratio_state = DIG_CS_RATIO_LOWER;\n\t\t\telse if (dm_digtable.rssi_val >= dm_digtable.rssi_high_thresh)\n\t\t\t\tdm_digtable.curcs_ratio_state = DIG_CS_RATIO_HIGHER;\n\t\t\telse\n\t\t\t\tdm_digtable.curcs_ratio_state = dm_digtable.precs_ratio_state;\n\t\t} else {\n\t\t\tdm_digtable.curcs_ratio_state = DIG_CS_RATIO_LOWER;\n\t\t}\n\t} else {\n\t\tdm_digtable.curcs_ratio_state = DIG_CS_RATIO_LOWER;\n\t}\n\n\tif (priv->reset_count != reset_cnt) {\n\t\tforce_write = 1;\n\t\treset_cnt = priv->reset_count;\n\t}\n\n\tif ((dm_digtable.precs_ratio_state != dm_digtable.curcs_ratio_state) ||\n\t    !initialized || force_write) {\n\t\tif (dm_digtable.curcs_ratio_state == DIG_CS_RATIO_LOWER)\n\t\t\trtl92e_writeb(dev, 0xa0a, 0x08);\n\t\telse if (dm_digtable.curcs_ratio_state == DIG_CS_RATIO_HIGHER)\n\t\t\trtl92e_writeb(dev, 0xa0a, 0xcd);\n\t\tdm_digtable.precs_ratio_state = dm_digtable.curcs_ratio_state;\n\t\tinitialized = 1;\n\t\tforce_write = 0;\n\t}\n}\n\nvoid rtl92e_dm_init_edca_turbo(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tpriv->bcurrent_turbo_EDCA = false;\n\tpriv->rtllib->bis_any_nonbepkts = false;\n\tpriv->bis_cur_rdlstate = false;\n}\n\nstatic void _rtl92e_dm_check_edca_turbo(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_hi_throughput *ht_info = priv->rtllib->ht_info;\n\n\tstatic unsigned long lastTxOkCnt;\n\tstatic unsigned long lastRxOkCnt;\n\tunsigned long curTxOkCnt = 0;\n\tunsigned long curRxOkCnt = 0;\n\n\tif (priv->rtllib->iw_mode == IW_MODE_ADHOC)\n\t\tgoto dm_CheckEdcaTurbo_EXIT;\n\tif (priv->rtllib->link_state != MAC80211_LINKED)\n\t\tgoto dm_CheckEdcaTurbo_EXIT;\n\tif (priv->rtllib->ht_info->iot_action & HT_IOT_ACT_DISABLE_EDCA_TURBO)\n\t\tgoto dm_CheckEdcaTurbo_EXIT;\n\n\tif (!priv->rtllib->bis_any_nonbepkts) {\n\t\tcurTxOkCnt = priv->stats.txbytesunicast - lastTxOkCnt;\n\t\tcurRxOkCnt = priv->stats.rxbytesunicast - lastRxOkCnt;\n\t\tif (ht_info->iot_action & HT_IOT_ACT_EDCA_BIAS_ON_RX) {\n\t\t\tif (curTxOkCnt > 4 * curRxOkCnt) {\n\t\t\t\tif (priv->bis_cur_rdlstate ||\n\t\t\t\t    !priv->bcurrent_turbo_EDCA) {\n\t\t\t\t\trtl92e_writel(dev, EDCAPARA_BE,\n\t\t\t\t\t\t      edca_setting_UL[ht_info->IOTPeer]);\n\t\t\t\t\tpriv->bis_cur_rdlstate = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!priv->bis_cur_rdlstate ||\n\t\t\t\t    !priv->bcurrent_turbo_EDCA) {\n\t\t\t\t\tif (priv->rtllib->mode == WIRELESS_MODE_G)\n\t\t\t\t\t\trtl92e_writel(dev, EDCAPARA_BE,\n\t\t\t\t\t\t\t      edca_setting_DL_GMode[ht_info->IOTPeer]);\n\t\t\t\t\telse\n\t\t\t\t\t\trtl92e_writel(dev, EDCAPARA_BE,\n\t\t\t\t\t\t\t      edca_setting_DL[ht_info->IOTPeer]);\n\t\t\t\t\tpriv->bis_cur_rdlstate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriv->bcurrent_turbo_EDCA = true;\n\t\t} else {\n\t\t\tif (curRxOkCnt > 4 * curTxOkCnt) {\n\t\t\t\tif (!priv->bis_cur_rdlstate ||\n\t\t\t\t    !priv->bcurrent_turbo_EDCA) {\n\t\t\t\t\tif (priv->rtllib->mode == WIRELESS_MODE_G)\n\t\t\t\t\t\trtl92e_writel(dev, EDCAPARA_BE,\n\t\t\t\t\t\t\t      edca_setting_DL_GMode[ht_info->IOTPeer]);\n\t\t\t\t\telse\n\t\t\t\t\t\trtl92e_writel(dev, EDCAPARA_BE,\n\t\t\t\t\t\t\t      edca_setting_DL[ht_info->IOTPeer]);\n\t\t\t\t\tpriv->bis_cur_rdlstate = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (priv->bis_cur_rdlstate ||\n\t\t\t\t    !priv->bcurrent_turbo_EDCA) {\n\t\t\t\t\trtl92e_writel(dev, EDCAPARA_BE,\n\t\t\t\t\t\t      edca_setting_UL[ht_info->IOTPeer]);\n\t\t\t\t\tpriv->bis_cur_rdlstate = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpriv->bcurrent_turbo_EDCA = true;\n\t\t}\n\t} else {\n\t\tif (priv->bcurrent_turbo_EDCA) {\n\t\t\tu8 tmp = AC0_BE;\n\n\t\t\tpriv->rtllib->SetHwRegHandler(dev, HW_VAR_AC_PARAM,\n\t\t\t\t\t\t      (u8 *)(&tmp));\n\t\t\tpriv->bcurrent_turbo_EDCA = false;\n\t\t}\n\t}\n\ndm_CheckEdcaTurbo_EXIT:\n\tpriv->rtllib->bis_any_nonbepkts = false;\n\tlastTxOkCnt = priv->stats.txbytesunicast;\n\tlastRxOkCnt = priv->stats.rxbytesunicast;\n}\n\nstatic void _rtl92e_dm_init_cts_to_self(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv((struct net_device *)dev);\n\n\tpriv->rtllib->bCTSToSelfEnable = true;\n}\n\nstatic void _rtl92e_dm_cts_to_self(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv((struct net_device *)dev);\n\tstruct rt_hi_throughput *ht_info = priv->rtllib->ht_info;\n\tstatic unsigned long lastTxOkCnt;\n\tstatic unsigned long lastRxOkCnt;\n\tunsigned long curTxOkCnt = 0;\n\tunsigned long curRxOkCnt = 0;\n\n\tif (!priv->rtllib->bCTSToSelfEnable) {\n\t\tht_info->iot_action &= ~HT_IOT_ACT_FORCED_CTS2SELF;\n\t\treturn;\n\t}\n\tif (ht_info->IOTPeer == HT_IOT_PEER_BROADCOM) {\n\t\tcurTxOkCnt = priv->stats.txbytesunicast - lastTxOkCnt;\n\t\tcurRxOkCnt = priv->stats.rxbytesunicast - lastRxOkCnt;\n\t\tif (curRxOkCnt > 4 * curTxOkCnt)\n\t\t\tht_info->iot_action &= ~HT_IOT_ACT_FORCED_CTS2SELF;\n\t\telse\n\t\t\tht_info->iot_action |= HT_IOT_ACT_FORCED_CTS2SELF;\n\n\t\tlastTxOkCnt = priv->stats.txbytesunicast;\n\t\tlastRxOkCnt = priv->stats.rxbytesunicast;\n\t}\n}\n\nstatic void _rtl92e_dm_check_rf_ctrl_gpio(void *data)\n{\n\tstruct r8192_priv *priv = container_of_dwork_rsl(data,\n\t\t\t\t  struct r8192_priv, gpio_change_rf_wq);\n\tstruct net_device *dev = priv->rtllib->dev;\n\tu8 tmp1byte;\n\tenum rt_rf_power_state rf_power_state_to_set;\n\tbool bActuallySet = false;\n\n\tif ((priv->up_first_time == 1) || (priv->being_init_adapter))\n\t\treturn;\n\n\tif (priv->bfirst_after_down)\n\t\treturn;\n\n\ttmp1byte = rtl92e_readb(dev, GPI);\n\n\trf_power_state_to_set = (tmp1byte & BIT1) ?  rf_on : rf_off;\n\n\tif (priv->hw_radio_off && (rf_power_state_to_set == rf_on)) {\n\t\tnetdev_info(dev, \"gpiochangeRF  - HW Radio ON\\n\");\n\t\tpriv->hw_radio_off = false;\n\t\tbActuallySet = true;\n\t} else if (!priv->hw_radio_off && (rf_power_state_to_set == rf_off)) {\n\t\tnetdev_info(dev, \"gpiochangeRF  - HW Radio OFF\\n\");\n\t\tpriv->hw_radio_off = true;\n\t\tbActuallySet = true;\n\t}\n\n\tif (bActuallySet) {\n\t\tmdelay(1000);\n\t\tpriv->hw_rf_off_action = 1;\n\t\trtl92e_set_rf_state(dev, rf_power_state_to_set, RF_CHANGE_BY_HW);\n\t}\n}\n\nvoid rtl92e_dm_rf_pathcheck_wq(void *data)\n{\n\tstruct r8192_priv *priv = container_of_dwork_rsl(data,\n\t\t\t\t  struct r8192_priv,\n\t\t\t\t  rfpath_check_wq);\n\tstruct net_device *dev = priv->rtllib->dev;\n\tu8 rfpath, i;\n\n\trfpath = rtl92e_readb(dev, 0xc04);\n\n\tfor (i = 0; i < RF90_PATH_MAX; i++) {\n\t\tif (rfpath & (0x01 << i))\n\t\t\tpriv->brfpath_rxenable[i] = true;\n\t\telse\n\t\t\tpriv->brfpath_rxenable[i] = false;\n\t}\n\tif (!dm_rx_path_sel_table.enable)\n\t\treturn;\n\n\t_rtl92e_dm_rx_path_sel_byrssi(dev);\n}\n\nstatic void _rtl92e_dm_init_rx_path_selection(struct net_device *dev)\n{\n\tu8 i;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tdm_rx_path_sel_table.enable = 1;\n\tdm_rx_path_sel_table.ss_th_low = RX_PATH_SEL_SS_TH_LOW;\n\tdm_rx_path_sel_table.diff_th = RX_PATH_SEL_DIFF_TH;\n\tif (priv->customer_id == RT_CID_819X_NETCORE)\n\t\tdm_rx_path_sel_table.cck_method = CCK_Rx_Version_2;\n\telse\n\t\tdm_rx_path_sel_table.cck_method = CCK_Rx_Version_1;\n\tdm_rx_path_sel_table.disabled_rf = 0;\n\tfor (i = 0; i < 4; i++) {\n\t\tdm_rx_path_sel_table.rf_rssi[i] = 50;\n\t\tdm_rx_path_sel_table.cck_pwdb_sta[i] = -64;\n\t\tdm_rx_path_sel_table.rf_enable_rssi_th[i] = 100;\n\t}\n}\n\n#define PWDB_IN_RANGE\t((cur_cck_pwdb < tmp_cck_max_pwdb) &&\t\\\n\t\t\t(cur_cck_pwdb > tmp_cck_sec_pwdb))\n\nstatic void _rtl92e_dm_rx_path_sel_byrssi(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8 i, max_rssi_index = 0, min_rssi_index = 0;\n\tu8 sec_rssi_index = 0, rf_num = 0;\n\tu8 tmp_max_rssi = 0, tmp_min_rssi = 0, tmp_sec_rssi = 0;\n\tu8 cck_default_Rx = 0x2;\n\tu8 cck_optional_Rx = 0x3;\n\tlong tmp_cck_max_pwdb = 0, tmp_cck_min_pwdb = 0, tmp_cck_sec_pwdb = 0;\n\tu8 cck_rx_ver2_max_index = 0;\n\tu8 cck_rx_ver2_sec_index = 0;\n\tu8 cur_rf_rssi;\n\tlong cur_cck_pwdb;\n\tstatic u8 disabled_rf_cnt, cck_Rx_Path_initialized;\n\tu8 update_cck_rx_path;\n\n\tif (!cck_Rx_Path_initialized) {\n\t\tdm_rx_path_sel_table.cck_rx_path = (rtl92e_readb(dev, 0xa07) & 0xf);\n\t\tcck_Rx_Path_initialized = 1;\n\t}\n\n\tdm_rx_path_sel_table.disabled_rf = 0xf;\n\tdm_rx_path_sel_table.disabled_rf &= ~(rtl92e_readb(dev, 0xc04));\n\n\tif (priv->rtllib->mode == WIRELESS_MODE_B)\n\t\tdm_rx_path_sel_table.cck_method = CCK_Rx_Version_2;\n\n\tfor (i = 0; i < RF90_PATH_MAX; i++) {\n\t\tdm_rx_path_sel_table.rf_rssi[i] = priv->stats.rx_rssi_percentage[i];\n\n\t\tif (priv->brfpath_rxenable[i]) {\n\t\t\trf_num++;\n\t\t\tcur_rf_rssi = dm_rx_path_sel_table.rf_rssi[i];\n\n\t\t\tif (rf_num == 1) {\n\t\t\t\tmax_rssi_index = min_rssi_index = sec_rssi_index = i;\n\t\t\t\ttmp_max_rssi = tmp_min_rssi = tmp_sec_rssi = cur_rf_rssi;\n\t\t\t} else if (rf_num == 2) {\n\t\t\t\tif (cur_rf_rssi >= tmp_max_rssi) {\n\t\t\t\t\ttmp_max_rssi = cur_rf_rssi;\n\t\t\t\t\tmax_rssi_index = i;\n\t\t\t\t} else {\n\t\t\t\t\ttmp_sec_rssi = tmp_min_rssi = cur_rf_rssi;\n\t\t\t\t\tsec_rssi_index = min_rssi_index = i;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (cur_rf_rssi > tmp_max_rssi) {\n\t\t\t\t\ttmp_sec_rssi = tmp_max_rssi;\n\t\t\t\t\tsec_rssi_index = max_rssi_index;\n\t\t\t\t\ttmp_max_rssi = cur_rf_rssi;\n\t\t\t\t\tmax_rssi_index = i;\n\t\t\t\t} else if (cur_rf_rssi == tmp_max_rssi) {\n\t\t\t\t\ttmp_sec_rssi = cur_rf_rssi;\n\t\t\t\t\tsec_rssi_index = i;\n\t\t\t\t} else if ((cur_rf_rssi < tmp_max_rssi) &&\n\t\t\t\t\t   (cur_rf_rssi > tmp_sec_rssi)) {\n\t\t\t\t\ttmp_sec_rssi = cur_rf_rssi;\n\t\t\t\t\tsec_rssi_index = i;\n\t\t\t\t} else if (cur_rf_rssi == tmp_sec_rssi) {\n\t\t\t\t\tif (tmp_sec_rssi == tmp_min_rssi) {\n\t\t\t\t\t\ttmp_sec_rssi = cur_rf_rssi;\n\t\t\t\t\t\tsec_rssi_index = i;\n\t\t\t\t\t}\n\t\t\t\t} else if ((cur_rf_rssi < tmp_sec_rssi) &&\n\t\t\t\t\t   (cur_rf_rssi > tmp_min_rssi)) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cur_rf_rssi == tmp_min_rssi) {\n\t\t\t\t\tif (tmp_sec_rssi == tmp_min_rssi) {\n\t\t\t\t\t\ttmp_min_rssi = cur_rf_rssi;\n\t\t\t\t\t\tmin_rssi_index = i;\n\t\t\t\t\t}\n\t\t\t\t} else if (cur_rf_rssi < tmp_min_rssi) {\n\t\t\t\t\ttmp_min_rssi = cur_rf_rssi;\n\t\t\t\t\tmin_rssi_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trf_num = 0;\n\tif (dm_rx_path_sel_table.cck_method == CCK_Rx_Version_2) {\n\t\tfor (i = 0; i < RF90_PATH_MAX; i++) {\n\t\t\tif (priv->brfpath_rxenable[i]) {\n\t\t\t\trf_num++;\n\t\t\t\tcur_cck_pwdb =\n\t\t\t\t\t dm_rx_path_sel_table.cck_pwdb_sta[i];\n\n\t\t\t\tif (rf_num == 1) {\n\t\t\t\t\tcck_rx_ver2_max_index = i;\n\t\t\t\t\tcck_rx_ver2_sec_index = i;\n\t\t\t\t\ttmp_cck_max_pwdb = cur_cck_pwdb;\n\t\t\t\t\ttmp_cck_min_pwdb = cur_cck_pwdb;\n\t\t\t\t\ttmp_cck_sec_pwdb = cur_cck_pwdb;\n\t\t\t\t} else if (rf_num == 2) {\n\t\t\t\t\tif (cur_cck_pwdb >= tmp_cck_max_pwdb) {\n\t\t\t\t\t\ttmp_cck_max_pwdb = cur_cck_pwdb;\n\t\t\t\t\t\tcck_rx_ver2_max_index = i;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp_cck_sec_pwdb = cur_cck_pwdb;\n\t\t\t\t\t\ttmp_cck_min_pwdb = cur_cck_pwdb;\n\t\t\t\t\t\tcck_rx_ver2_sec_index = i;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (cur_cck_pwdb > tmp_cck_max_pwdb) {\n\t\t\t\t\t\ttmp_cck_sec_pwdb =\n\t\t\t\t\t\t\t tmp_cck_max_pwdb;\n\t\t\t\t\t\tcck_rx_ver2_sec_index =\n\t\t\t\t\t\t\t cck_rx_ver2_max_index;\n\t\t\t\t\t\ttmp_cck_max_pwdb = cur_cck_pwdb;\n\t\t\t\t\t\tcck_rx_ver2_max_index = i;\n\t\t\t\t\t} else if (cur_cck_pwdb ==\n\t\t\t\t\t\t   tmp_cck_max_pwdb) {\n\t\t\t\t\t\ttmp_cck_sec_pwdb = cur_cck_pwdb;\n\t\t\t\t\t\tcck_rx_ver2_sec_index = i;\n\t\t\t\t\t} else if (PWDB_IN_RANGE) {\n\t\t\t\t\t\ttmp_cck_sec_pwdb = cur_cck_pwdb;\n\t\t\t\t\t\tcck_rx_ver2_sec_index = i;\n\t\t\t\t\t} else if (cur_cck_pwdb ==\n\t\t\t\t\t\t   tmp_cck_sec_pwdb) {\n\t\t\t\t\t\tif (tmp_cck_sec_pwdb ==\n\t\t\t\t\t\t    tmp_cck_min_pwdb) {\n\t\t\t\t\t\t\ttmp_cck_sec_pwdb =\n\t\t\t\t\t\t\t\t cur_cck_pwdb;\n\t\t\t\t\t\t\tcck_rx_ver2_sec_index =\n\t\t\t\t\t\t\t\t i;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ((cur_cck_pwdb < tmp_cck_sec_pwdb) &&\n\t\t\t\t\t\t   (cur_cck_pwdb > tmp_cck_min_pwdb)) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (cur_cck_pwdb == tmp_cck_min_pwdb) {\n\t\t\t\t\t\tif (tmp_cck_sec_pwdb == tmp_cck_min_pwdb)\n\t\t\t\t\t\t\ttmp_cck_min_pwdb = cur_cck_pwdb;\n\t\t\t\t\t} else if (cur_cck_pwdb < tmp_cck_min_pwdb) {\n\t\t\t\t\t\ttmp_cck_min_pwdb = cur_cck_pwdb;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate_cck_rx_path = 0;\n\tif (dm_rx_path_sel_table.cck_method == CCK_Rx_Version_2) {\n\t\tcck_default_Rx = cck_rx_ver2_max_index;\n\t\tcck_optional_Rx = cck_rx_ver2_sec_index;\n\t\tif (tmp_cck_max_pwdb != -64)\n\t\t\tupdate_cck_rx_path = 1;\n\t}\n\n\tif (tmp_min_rssi < dm_rx_path_sel_table.ss_th_low && disabled_rf_cnt < 2) {\n\t\tif ((tmp_max_rssi - tmp_min_rssi) >=\n\t\t     dm_rx_path_sel_table.diff_th) {\n\t\t\tdm_rx_path_sel_table.rf_enable_rssi_th[min_rssi_index] =\n\t\t\t\t tmp_max_rssi + 5;\n\t\t\trtl92e_set_bb_reg(dev, rOFDM0_TRxPathEnable,\n\t\t\t\t\t  0x1 << min_rssi_index, 0x0);\n\t\t\trtl92e_set_bb_reg(dev, rOFDM1_TRxPathEnable,\n\t\t\t\t\t  0x1 << min_rssi_index, 0x0);\n\t\t\tdisabled_rf_cnt++;\n\t\t}\n\t\tif (dm_rx_path_sel_table.cck_method == CCK_Rx_Version_1) {\n\t\t\tcck_default_Rx = max_rssi_index;\n\t\t\tcck_optional_Rx = sec_rssi_index;\n\t\t\tif (tmp_max_rssi)\n\t\t\t\tupdate_cck_rx_path = 1;\n\t\t}\n\t}\n\n\tif (update_cck_rx_path) {\n\t\tdm_rx_path_sel_table.cck_rx_path = (cck_default_Rx << 2) |\n\t\t\t\t\t\t(cck_optional_Rx);\n\t\trtl92e_set_bb_reg(dev, rCCK0_AFESetting, 0x0f000000,\n\t\t\t\t  dm_rx_path_sel_table.cck_rx_path);\n\t}\n\n\tif (dm_rx_path_sel_table.disabled_rf) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif ((dm_rx_path_sel_table.disabled_rf >> i) & 0x1) {\n\t\t\t\tif (tmp_max_rssi >=\n\t\t\t\t    dm_rx_path_sel_table.rf_enable_rssi_th[i]) {\n\t\t\t\t\trtl92e_set_bb_reg(dev,\n\t\t\t\t\t\t\t  rOFDM0_TRxPathEnable,\n\t\t\t\t\t\t\t  0x1 << i, 0x1);\n\t\t\t\t\trtl92e_set_bb_reg(dev,\n\t\t\t\t\t\t\t  rOFDM1_TRxPathEnable,\n\t\t\t\t\t\t\t  0x1 << i, 0x1);\n\t\t\t\t\tdm_rx_path_sel_table.rf_enable_rssi_th[i]\n\t\t\t\t\t\t = 100;\n\t\t\t\t\tdisabled_rf_cnt--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void _rtl92e_dm_check_rx_path_selection(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tschedule_delayed_work(&priv->rfpath_check_wq, 0);\n}\n\nstatic void _rtl92e_dm_init_fsync(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tpriv->rtllib->fsync_time_interval = 500;\n\tpriv->rtllib->fsync_rate_bitmap = 0x0f000800;\n\tpriv->rtllib->fsync_rssi_threshold = 30;\n\tpriv->rtllib->bfsync_enable = false;\n\tpriv->rtllib->fsync_multiple_timeinterval = 3;\n\tpriv->rtllib->fsync_firstdiff_ratethreshold = 100;\n\tpriv->rtllib->fsync_seconddiff_ratethreshold = 200;\n\tpriv->rtllib->fsync_state = Default_Fsync;\n\n\ttimer_setup(&priv->fsync_timer, _rtl92e_dm_fsync_timer_callback, 0);\n}\n\nstatic void _rtl92e_dm_deinit_fsync(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tdel_timer_sync(&priv->fsync_timer);\n}\n\nstatic void _rtl92e_dm_fsync_timer_callback(struct timer_list *t)\n{\n\tstruct r8192_priv *priv = from_timer(priv, t, fsync_timer);\n\tstruct net_device *dev = priv->rtllib->dev;\n\tu32 rate_index, rate_count = 0, rate_count_diff = 0;\n\tbool\t\tbSwitchFromCountDiff = false;\n\tbool\t\tbDoubleTimeInterval = false;\n\n\tif (priv->rtllib->link_state == MAC80211_LINKED &&\n\t    priv->rtllib->bfsync_enable &&\n\t    (priv->rtllib->ht_info->iot_action & HT_IOT_ACT_CDD_FSYNC)) {\n\t\tu32 rate_bitmap;\n\n\t\tfor (rate_index = 0; rate_index <= 27; rate_index++) {\n\t\t\trate_bitmap  = 1 << rate_index;\n\t\t\tif (priv->rtllib->fsync_rate_bitmap &  rate_bitmap)\n\t\t\t\trate_count +=\n\t\t\t\t   priv->stats.received_rate_histogram[1]\n\t\t\t\t   [rate_index];\n\t\t}\n\n\t\tif (rate_count < priv->rate_record)\n\t\t\trate_count_diff = 0xffffffff - rate_count +\n\t\t\t\t\t  priv->rate_record;\n\t\telse\n\t\t\trate_count_diff = rate_count - priv->rate_record;\n\t\tif (rate_count_diff < priv->rate_count_diff_rec) {\n\t\t\tu32 DiffNum = priv->rate_count_diff_rec -\n\t\t\t\t      rate_count_diff;\n\t\t\tif (DiffNum >=\n\t\t\t    priv->rtllib->fsync_seconddiff_ratethreshold)\n\t\t\t\tpriv->continue_diff_count++;\n\t\t\telse\n\t\t\t\tpriv->continue_diff_count = 0;\n\n\t\t\tif (priv->continue_diff_count >= 2) {\n\t\t\t\tbSwitchFromCountDiff = true;\n\t\t\t\tpriv->continue_diff_count = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tpriv->continue_diff_count = 0;\n\t\t}\n\n\t\tif (rate_count_diff <=\n\t\t    priv->rtllib->fsync_firstdiff_ratethreshold) {\n\t\t\tbSwitchFromCountDiff = true;\n\t\t\tpriv->continue_diff_count = 0;\n\t\t}\n\t\tpriv->rate_record = rate_count;\n\t\tpriv->rate_count_diff_rec = rate_count_diff;\n\t\tif (priv->undecorated_smoothed_pwdb >\n\t\t    priv->rtllib->fsync_rssi_threshold &&\n\t\t    bSwitchFromCountDiff) {\n\t\t\tbDoubleTimeInterval = true;\n\t\t\tpriv->bswitch_fsync = !priv->bswitch_fsync;\n\t\t\tif (priv->bswitch_fsync) {\n\t\t\t\trtl92e_writeb(dev, 0xC36, 0x1c);\n\t\t\t\trtl92e_writeb(dev, 0xC3e, 0x90);\n\t\t\t} else {\n\t\t\t\trtl92e_writeb(dev, 0xC36, 0x5c);\n\t\t\t\trtl92e_writeb(dev, 0xC3e, 0x96);\n\t\t\t}\n\t\t} else if (priv->undecorated_smoothed_pwdb <=\n\t\t\t   priv->rtllib->fsync_rssi_threshold) {\n\t\t\tif (priv->bswitch_fsync) {\n\t\t\t\tpriv->bswitch_fsync  = false;\n\t\t\t\trtl92e_writeb(dev, 0xC36, 0x5c);\n\t\t\t\trtl92e_writeb(dev, 0xC3e, 0x96);\n\t\t\t}\n\t\t}\n\t\tif (bDoubleTimeInterval) {\n\t\t\tif (timer_pending(&priv->fsync_timer))\n\t\t\t\tdel_timer_sync(&priv->fsync_timer);\n\t\t\tpriv->fsync_timer.expires = jiffies +\n\t\t\t\t msecs_to_jiffies(priv->rtllib->fsync_time_interval *\n\t\t\t\t priv->rtllib->fsync_multiple_timeinterval);\n\t\t\tadd_timer(&priv->fsync_timer);\n\t\t} else {\n\t\t\tif (timer_pending(&priv->fsync_timer))\n\t\t\t\tdel_timer_sync(&priv->fsync_timer);\n\t\t\tpriv->fsync_timer.expires = jiffies +\n\t\t\t\t msecs_to_jiffies(priv->rtllib->fsync_time_interval);\n\t\t\tadd_timer(&priv->fsync_timer);\n\t\t}\n\t} else {\n\t\tif (priv->bswitch_fsync) {\n\t\t\tpriv->bswitch_fsync  = false;\n\t\t\trtl92e_writeb(dev, 0xC36, 0x5c);\n\t\t\trtl92e_writeb(dev, 0xC3e, 0x96);\n\t\t}\n\t\tpriv->continue_diff_count = 0;\n\t\trtl92e_writel(dev, rOFDM0_RxDetector2, 0x465c52cd);\n\t}\n}\n\nstatic void _rtl92e_dm_start_hw_fsync(struct net_device *dev)\n{\n\tu8 rf_timing = 0x77;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\trtl92e_writel(dev, rOFDM0_RxDetector2, 0x465c12cf);\n\tpriv->rtllib->SetHwRegHandler(dev, HW_VAR_RF_TIMING,\n\t\t\t\t      (u8 *)(&rf_timing));\n\trtl92e_writeb(dev, 0xc3b, 0x41);\n}\n\nstatic void _rtl92e_dm_end_hw_fsync(struct net_device *dev)\n{\n\tu8 rf_timing = 0xaa;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\trtl92e_writel(dev, rOFDM0_RxDetector2, 0x465c52cd);\n\tpriv->rtllib->SetHwRegHandler(dev, HW_VAR_RF_TIMING, (u8 *)\n\t\t\t\t     (&rf_timing));\n\trtl92e_writeb(dev, 0xc3b, 0x49);\n}\n\nstatic void _rtl92e_dm_end_sw_fsync(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tdel_timer_sync(&(priv->fsync_timer));\n\n\tif (priv->bswitch_fsync) {\n\t\tpriv->bswitch_fsync  = false;\n\n\t\trtl92e_writeb(dev, 0xC36, 0x5c);\n\n\t\trtl92e_writeb(dev, 0xC3e, 0x96);\n\t}\n\n\tpriv->continue_diff_count = 0;\n\trtl92e_writel(dev, rOFDM0_RxDetector2, 0x465c52cd);\n}\n\nstatic void _rtl92e_dm_start_sw_fsync(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu32 rate_index;\n\tu32 rate_bitmap;\n\n\tpriv->rate_record = 0;\n\tpriv->continue_diff_count = 0;\n\tpriv->rate_count_diff_rec = 0;\n\tpriv->bswitch_fsync  = false;\n\n\tif (priv->rtllib->mode == WIRELESS_MODE_N_24G) {\n\t\tpriv->rtllib->fsync_firstdiff_ratethreshold = 600;\n\t\tpriv->rtllib->fsync_seconddiff_ratethreshold = 0xffff;\n\t} else {\n\t\tpriv->rtllib->fsync_firstdiff_ratethreshold = 200;\n\t\tpriv->rtllib->fsync_seconddiff_ratethreshold = 200;\n\t}\n\tfor (rate_index = 0; rate_index <= 27; rate_index++) {\n\t\trate_bitmap  = 1 << rate_index;\n\t\tif (priv->rtllib->fsync_rate_bitmap & rate_bitmap)\n\t\t\tpriv->rate_record +=\n\t\t\t\t priv->stats.received_rate_histogram[1]\n\t\t\t\t[rate_index];\n\t}\n\tif (timer_pending(&priv->fsync_timer))\n\t\tdel_timer_sync(&priv->fsync_timer);\n\tpriv->fsync_timer.expires = jiffies +\n\t\t\t\t    msecs_to_jiffies(priv->rtllib->fsync_time_interval);\n\tadd_timer(&priv->fsync_timer);\n\n\trtl92e_writel(dev, rOFDM0_RxDetector2, 0x465c12cd);\n}\n\nstatic void _rtl92e_dm_check_fsync(struct net_device *dev)\n{\n#define\tRegC38_Default\t\t\t0\n#define\tRegC38_NonFsync_Other_AP\t1\n#define\tRegC38_Fsync_AP_BCM\t\t2\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstatic u8 reg_c38_State = RegC38_Default;\n\tstatic u32 reset_cnt;\n\n\tif (priv->rtllib->link_state == MAC80211_LINKED &&\n\t    priv->rtllib->ht_info->IOTPeer == HT_IOT_PEER_BROADCOM) {\n\t\tif (priv->rtllib->bfsync_enable == 0) {\n\t\t\tswitch (priv->rtllib->fsync_state) {\n\t\t\tcase Default_Fsync:\n\t\t\t\t_rtl92e_dm_start_hw_fsync(dev);\n\t\t\t\tpriv->rtllib->fsync_state = HW_Fsync;\n\t\t\t\tbreak;\n\t\t\tcase SW_Fsync:\n\t\t\t\t_rtl92e_dm_end_sw_fsync(dev);\n\t\t\t\t_rtl92e_dm_start_hw_fsync(dev);\n\t\t\t\tpriv->rtllib->fsync_state = HW_Fsync;\n\t\t\t\tbreak;\n\t\t\tcase HW_Fsync:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (priv->rtllib->fsync_state) {\n\t\t\tcase Default_Fsync:\n\t\t\t\t_rtl92e_dm_start_sw_fsync(dev);\n\t\t\t\tpriv->rtllib->fsync_state = SW_Fsync;\n\t\t\t\tbreak;\n\t\t\tcase HW_Fsync:\n\t\t\t\t_rtl92e_dm_end_hw_fsync(dev);\n\t\t\t\t_rtl92e_dm_start_sw_fsync(dev);\n\t\t\t\tpriv->rtllib->fsync_state = SW_Fsync;\n\t\t\t\tbreak;\n\t\t\tcase SW_Fsync:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (reg_c38_State != RegC38_Fsync_AP_BCM) {\n\t\t\trtl92e_writeb(dev, rOFDM0_RxDetector3, 0x95);\n\n\t\t\treg_c38_State = RegC38_Fsync_AP_BCM;\n\t\t}\n\t} else {\n\t\tswitch (priv->rtllib->fsync_state) {\n\t\tcase HW_Fsync:\n\t\t\t_rtl92e_dm_end_hw_fsync(dev);\n\t\t\tpriv->rtllib->fsync_state = Default_Fsync;\n\t\t\tbreak;\n\t\tcase SW_Fsync:\n\t\t\t_rtl92e_dm_end_sw_fsync(dev);\n\t\t\tpriv->rtllib->fsync_state = Default_Fsync;\n\t\t\tbreak;\n\t\tcase Default_Fsync:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (priv->rtllib->link_state == MAC80211_LINKED) {\n\t\t\tif (priv->undecorated_smoothed_pwdb <=\n\t\t\t    RegC38_TH) {\n\t\t\t\tif (reg_c38_State !=\n\t\t\t\t    RegC38_NonFsync_Other_AP) {\n\t\t\t\t\trtl92e_writeb(dev,\n\t\t\t\t\t\t      rOFDM0_RxDetector3,\n\t\t\t\t\t\t      0x90);\n\n\t\t\t\t\treg_c38_State =\n\t\t\t\t\t     RegC38_NonFsync_Other_AP;\n\t\t\t\t}\n\t\t\t} else if (priv->undecorated_smoothed_pwdb >=\n\t\t\t\t   (RegC38_TH + 5)) {\n\t\t\t\tif (reg_c38_State) {\n\t\t\t\t\trtl92e_writeb(dev,\n\t\t\t\t\t\trOFDM0_RxDetector3,\n\t\t\t\t\t\tpriv->framesync);\n\t\t\t\t\treg_c38_State = RegC38_Default;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (reg_c38_State) {\n\t\t\t\trtl92e_writeb(dev, rOFDM0_RxDetector3,\n\t\t\t\t\t      priv->framesync);\n\t\t\t\treg_c38_State = RegC38_Default;\n\t\t\t}\n\t\t}\n\t}\n\tif (priv->reset_count != reset_cnt) {\n\t\trtl92e_writeb(dev, rOFDM0_RxDetector3,\n\t\t\t       priv->framesync);\n\t\treg_c38_State = RegC38_Default;\n\t\treset_cnt = priv->reset_count;\n\t}\n}\n\n \nstatic void _rtl92e_dm_init_dynamic_tx_power(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tpriv->rtllib->bdynamic_txpower_enable = true;\n\tpriv->last_dtp_flag_high = false;\n\tpriv->last_dtp_flag_low = false;\n\tpriv->dynamic_tx_high_pwr = false;\n\tpriv->dynamic_tx_low_pwr = false;\n}\n\nstatic void _rtl92e_dm_dynamic_tx_power(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tunsigned int txhipower_threshold = 0;\n\tunsigned int txlowpower_threshold = 0;\n\n\tif (!priv->rtllib->bdynamic_txpower_enable) {\n\t\tpriv->dynamic_tx_high_pwr = false;\n\t\tpriv->dynamic_tx_low_pwr = false;\n\t\treturn;\n\t}\n\tif ((priv->rtllib->ht_info->IOTPeer == HT_IOT_PEER_ATHEROS) &&\n\t    (priv->rtllib->mode == WIRELESS_MODE_G)) {\n\t\ttxhipower_threshold = TX_POWER_ATHEROAP_THRESH_HIGH;\n\t\ttxlowpower_threshold = TX_POWER_ATHEROAP_THRESH_LOW;\n\t} else {\n\t\ttxhipower_threshold = TX_POWER_NEAR_FIELD_THRESH_HIGH;\n\t\ttxlowpower_threshold = TX_POWER_NEAR_FIELD_THRESH_LOW;\n\t}\n\n\tif (priv->rtllib->link_state == MAC80211_LINKED) {\n\t\tif (priv->undecorated_smoothed_pwdb >= txhipower_threshold) {\n\t\t\tpriv->dynamic_tx_high_pwr = true;\n\t\t\tpriv->dynamic_tx_low_pwr = false;\n\t\t} else {\n\t\t\tif (priv->undecorated_smoothed_pwdb <\n\t\t\t    txlowpower_threshold && priv->dynamic_tx_high_pwr)\n\t\t\t\tpriv->dynamic_tx_high_pwr = false;\n\t\t\tif (priv->undecorated_smoothed_pwdb < 35)\n\t\t\t\tpriv->dynamic_tx_low_pwr = true;\n\t\t\telse if (priv->undecorated_smoothed_pwdb >= 40)\n\t\t\t\tpriv->dynamic_tx_low_pwr = false;\n\t\t}\n\t} else {\n\t\tpriv->dynamic_tx_high_pwr = false;\n\t\tpriv->dynamic_tx_low_pwr = false;\n\t}\n\n\tif ((priv->dynamic_tx_high_pwr != priv->last_dtp_flag_high) ||\n\t    (priv->dynamic_tx_low_pwr != priv->last_dtp_flag_low)) {\n\t\trtl92e_set_tx_power(dev, priv->rtllib->current_network.channel);\n\t}\n\tpriv->last_dtp_flag_high = priv->dynamic_tx_high_pwr;\n\tpriv->last_dtp_flag_low = priv->dynamic_tx_low_pwr;\n}\n\nstatic void _rtl92e_dm_check_txrateandretrycount(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\n\tieee->softmac_stats.CurrentShowTxate = rtl92e_readb(dev, CURRENT_TX_RATE_REG);\n\tieee->softmac_stats.last_packet_rate = rtl92e_readb(dev, INITIAL_TX_RATE_REG);\n\tieee->softmac_stats.txretrycount = rtl92e_readl(dev, TX_RETRY_COUNT_REG);\n}\n\nstatic void _rtl92e_dm_send_rssi_to_fw(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\trtl92e_writeb(dev, DRIVER_RSSI, priv->undecorated_smoothed_pwdb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}