{
  "module_name": "rtl_wx.c",
  "hash_id": "8a31d1ed39c62de6118b3a6073bc289029ca4dec8b8c2680b539ef7abeaec939",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtl8192e/rtl_wx.c",
  "human_readable_source": "\n \n#include <linux/string.h>\n#include \"rtl_core.h\"\n#include \"rtl_wx.h\"\n\n#define RATE_COUNT 12\nstatic u32 rtl8192_rates[] = {\n\t1000000, 2000000, 5500000, 11000000, 6000000, 9000000, 12000000,\n\t18000000, 24000000, 36000000, 48000000, 54000000\n};\n\n#ifndef ENETDOWN\n#define ENETDOWN 1\n#endif\n\nstatic int _rtl92e_wx_get_freq(struct net_device *dev,\n\t\t\t       struct iw_request_info *a,\n\t\t\t       union iwreq_data *wrqu, char *b)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\treturn rtllib_wx_get_freq(priv->rtllib, a, wrqu, b);\n}\n\nstatic int _rtl92e_wx_get_mode(struct net_device *dev,\n\t\t\t       struct iw_request_info *a,\n\t\t\t       union iwreq_data *wrqu, char *b)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\treturn rtllib_wx_get_mode(priv->rtllib, a, wrqu, b);\n}\n\nstatic int _rtl92e_wx_get_rate(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\treturn rtllib_wx_get_rate(priv->rtllib, info, wrqu, extra);\n}\n\nstatic int _rtl92e_wx_set_rate(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tint ret;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = rtllib_wx_set_rate(priv->rtllib, info, wrqu, extra);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_set_rts(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tint ret;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = rtllib_wx_set_rts(priv->rtllib, info, wrqu, extra);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_get_rts(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\treturn rtllib_wx_get_rts(priv->rtllib, info, wrqu, extra);\n}\n\nstatic int _rtl92e_wx_set_power(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tint ret;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->hw_radio_off) {\n\t\tnetdev_warn(dev, \"%s(): Can't set Power: Radio is Off.\\n\",\n\t\t\t    __func__);\n\t\treturn 0;\n\t}\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = rtllib_wx_set_power(priv->rtllib, info, wrqu, extra);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_get_power(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\treturn rtllib_wx_get_power(priv->rtllib, info, wrqu, extra);\n}\n\nstatic int _rtl92e_wx_set_rawtx(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tint ret;\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = rtllib_wx_set_rawtx(priv->rtllib, info, wrqu, extra);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_force_reset(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tpriv->force_reset = *extra;\n\tmutex_unlock(&priv->wx_mutex);\n\treturn 0;\n}\n\nstatic int _rtl92e_wx_adapter_power_status(struct net_device *dev,\n\t\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_pwr_save_ctrl *psc = (struct rt_pwr_save_ctrl *)\n\t\t\t\t\t(&priv->rtllib->pwr_save_ctrl);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tif (*extra || priv->force_lps) {\n\t\tpriv->ps_force = false;\n\t\tpsc->bLeisurePs = true;\n\t} else {\n\t\tif (priv->rtllib->link_state == MAC80211_LINKED)\n\t\t\trtl92e_leisure_ps_leave(dev);\n\n\t\tpriv->ps_force = true;\n\t\tpsc->bLeisurePs = false;\n\t\tieee->ps = *extra;\n\t}\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn 0;\n}\n\nstatic int _rtl92e_wx_set_lps_awake_interval(struct net_device *dev,\n\t\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t\t     union iwreq_data *wrqu,\n\t\t\t\t\t     char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_pwr_save_ctrl *psc = (struct rt_pwr_save_ctrl *)\n\t\t\t\t\t(&priv->rtllib->pwr_save_ctrl);\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tnetdev_info(dev, \"%s(): set lps awake interval ! extra is %d\\n\",\n\t\t    __func__, *extra);\n\n\tpsc->reg_max_lps_awake_intvl = *extra;\n\tmutex_unlock(&priv->wx_mutex);\n\treturn 0;\n}\n\nstatic int _rtl92e_wx_set_force_lps(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tnetdev_info(dev,\n\t\t    \"%s(): force LPS ! extra is %d (1 is open 0 is close)\\n\",\n\t\t    __func__, *extra);\n\tpriv->force_lps = *extra;\n\tmutex_unlock(&priv->wx_mutex);\n\treturn 0;\n}\n\nstatic int _rtl92e_wx_set_debug(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8 c = *extra;\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tnetdev_info(dev, \"=====>%s(), *extra:%x, debugflag:%x\\n\", __func__,\n\t\t    *extra, rt_global_debug_component);\n\tif (c > 0)\n\t\trt_global_debug_component |= (1 << c);\n\telse\n\t\trt_global_debug_component &= BIT31;\n\treturn 0;\n}\n\nstatic int _rtl92e_wx_set_mode(struct net_device *dev,\n\t\t\t       struct iw_request_info *a,\n\t\t\t       union iwreq_data *wrqu, char *b)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = netdev_priv_rsl(dev);\n\n\tenum rt_rf_power_state rt_state;\n\tint ret;\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\trt_state = priv->rtllib->rf_power_state;\n\tmutex_lock(&priv->wx_mutex);\n\tif (wrqu->mode == IW_MODE_ADHOC || wrqu->mode == IW_MODE_MONITOR ||\n\t    ieee->net_promiscuous_md) {\n\t\tif (rt_state == rf_off) {\n\t\t\tif (priv->rtllib->rf_off_reason >\n\t\t\t    RF_CHANGE_BY_IPS) {\n\t\t\t\tnetdev_warn(dev, \"%s(): RF is OFF.\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\tmutex_unlock(&priv->wx_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tnetdev_info(dev,\n\t\t\t\t    \"=========>%s(): rtl92e_ips_leave\\n\",\n\t\t\t\t    __func__);\n\t\t\tmutex_lock(&priv->rtllib->ips_mutex);\n\t\t\trtl92e_ips_leave(dev);\n\t\t\tmutex_unlock(&priv->rtllib->ips_mutex);\n\t\t}\n\t}\n\tret = rtllib_wx_set_mode(priv->rtllib, a, wrqu, b);\n\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstruct  iw_range_with_scan_capa {\n\t \n\t__u32\t   throughput;      \n\t \n\n\t \n\t__u32\t   min_nwid;\t \n\t__u32\t   max_nwid;\t \n\n\t \n\t__u16\t   old_num_channels;\n\t__u8\t    old_num_frequency;\n\n\t \n\t__u8\t    scan_capa;\n};\n\nstatic int _rtl92e_wx_get_range(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_range *range = (struct iw_range *)extra;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu16 val;\n\tint i;\n\n\twrqu->data.length = sizeof(*range);\n\tmemset(range, 0, sizeof(*range));\n\n\t \n\trange->throughput = 130 * 1000 * 1000;\n\n\trange->max_qual.qual = 100;\n\trange->max_qual.level = 0;\n\trange->max_qual.noise = 0;\n\trange->max_qual.updated = 7;  \n\n\trange->avg_qual.qual = 70;  \n\trange->avg_qual.level = 0;\n\trange->avg_qual.noise = 0;\n\trange->avg_qual.updated = 7;  \n\n\trange->num_bitrates = min(RATE_COUNT, IW_MAX_BITRATES);\n\n\tfor (i = 0; i < range->num_bitrates; i++)\n\t\trange->bitrate[i] = rtl8192_rates[i];\n\n\trange->max_rts = DEFAULT_RTS_THRESHOLD;\n\trange->min_frag = MIN_FRAG_THRESHOLD;\n\trange->max_frag = MAX_FRAG_THRESHOLD;\n\n\trange->min_pmp = 0;\n\trange->max_pmp = 5000000;\n\trange->min_pmt = 0;\n\trange->max_pmt = 65535 * 1000;\n\trange->pmp_flags = IW_POWER_PERIOD;\n\trange->pmt_flags = IW_POWER_TIMEOUT;\n\trange->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT | IW_POWER_ALL_R;\n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->we_version_source = 18;\n\n\tfor (i = 0, val = 0; i < 14; i++) {\n\t\tif ((priv->rtllib->active_channel_map)[i + 1]) {\n\t\t\ts32 freq_khz;\n\n\t\t\trange->freq[val].i = i + 1;\n\t\t\tfreq_khz = ieee80211_channel_to_freq_khz(i + 1, NL80211_BAND_2GHZ);\n\t\t\trange->freq[val].m = freq_khz * 100;\n\t\t\trange->freq[val].e = 1;\n\t\t\tval++;\n\t\t}\n\n\t\tif (val == IW_MAX_FREQUENCIES)\n\t\t\tbreak;\n\t}\n\trange->num_frequency = val;\n\trange->num_channels = val;\n\trange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |\n\t\t\t  IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;\n\trange->scan_capa = IW_SCAN_CAPA_ESSID | IW_SCAN_CAPA_TYPE;\n\n\t \n\n\treturn 0;\n}\n\nstatic int _rtl92e_wx_set_scan(struct net_device *dev,\n\t\t\t       struct iw_request_info *a,\n\t\t\t       union iwreq_data *wrqu, char *b)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\tenum rt_rf_power_state rt_state;\n\tint ret;\n\n\tif (!(ieee->softmac_features & IEEE_SOFTMAC_SCAN)) {\n\t\tif ((ieee->link_state >= RTLLIB_ASSOCIATING) &&\n\t\t    (ieee->link_state <= RTLLIB_ASSOCIATING_AUTHENTICATED))\n\t\t\treturn 0;\n\t\tif ((priv->rtllib->link_state == MAC80211_LINKED) &&\n\t\t    (priv->rtllib->CntAfterLink < 2))\n\t\t\treturn 0;\n\t}\n\n\tif (priv->hw_radio_off) {\n\t\tnetdev_info(dev, \"================>%s(): hwradio off\\n\",\n\t\t\t    __func__);\n\t\treturn 0;\n\t}\n\trt_state = priv->rtllib->rf_power_state;\n\tif (!priv->up)\n\t\treturn -ENETDOWN;\n\tif (priv->rtllib->link_detect_info.bBusyTraffic)\n\t\treturn -EAGAIN;\n\n\tif (wrqu->data.flags & IW_SCAN_THIS_ESSID) {\n\t\tstruct iw_scan_req *req = (struct iw_scan_req *)b;\n\n\t\tif (req->essid_len) {\n\t\t\tint len = min_t(int, req->essid_len, IW_ESSID_MAX_SIZE);\n\n\t\t\tieee->current_network.ssid_len = len;\n\t\t\tmemcpy(ieee->current_network.ssid, req->essid, len);\n\t\t}\n\t}\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tpriv->rtllib->FirstIe_InScan = true;\n\n\tif (priv->rtllib->link_state != MAC80211_LINKED) {\n\t\tif (rt_state == rf_off) {\n\t\t\tif (priv->rtllib->rf_off_reason >\n\t\t\t    RF_CHANGE_BY_IPS) {\n\t\t\t\tnetdev_warn(dev, \"%s(): RF is OFF.\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\tmutex_unlock(&priv->wx_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_lock(&priv->rtllib->ips_mutex);\n\t\t\trtl92e_ips_leave(dev);\n\t\t\tmutex_unlock(&priv->rtllib->ips_mutex);\n\t\t}\n\t\trtllib_stop_scan(priv->rtllib);\n\t\tif (priv->rtllib->rf_power_state != rf_off) {\n\t\t\tpriv->rtllib->actscanning = true;\n\n\t\t\tieee->ScanOperationBackupHandler(ieee->dev, SCAN_OPT_BACKUP);\n\n\t\t\trtllib_start_scan_syncro(priv->rtllib);\n\n\t\t\tieee->ScanOperationBackupHandler(ieee->dev, SCAN_OPT_RESTORE);\n\t\t}\n\t\tret = 0;\n\t} else {\n\t\tpriv->rtllib->actscanning = true;\n\t\tret = rtllib_wx_set_scan(priv->rtllib, a, wrqu, b);\n\t}\n\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_get_scan(struct net_device *dev,\n\t\t\t       struct iw_request_info *a,\n\t\t\t       union iwreq_data *wrqu, char *b)\n{\n\tint ret;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (!priv->up)\n\t\treturn -ENETDOWN;\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = rtllib_wx_get_scan(priv->rtllib, a, wrqu, b);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_set_essid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *a,\n\t\t\t\tunion iwreq_data *wrqu, char *b)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tint ret;\n\n\tif (priv->hw_radio_off) {\n\t\tnetdev_info(dev,\n\t\t\t    \"=========>%s():hw radio off,or Rf state is rf_off, return\\n\",\n\t\t\t    __func__);\n\t\treturn 0;\n\t}\n\tmutex_lock(&priv->wx_mutex);\n\tret = rtllib_wx_set_essid(priv->rtllib, a, wrqu, b);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_get_essid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *a,\n\t\t\t\tunion iwreq_data *wrqu, char *b)\n{\n\tint ret;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = rtllib_wx_get_essid(priv->rtllib, a, wrqu, b);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_set_nick(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (wrqu->data.length > IW_ESSID_MAX_SIZE)\n\t\treturn -E2BIG;\n\tmutex_lock(&priv->wx_mutex);\n\twrqu->data.length = min_t(size_t, wrqu->data.length,\n\t\t\t\t  sizeof(priv->nick));\n\tmemset(priv->nick, 0, sizeof(priv->nick));\n\tmemcpy(priv->nick, extra, wrqu->data.length);\n\tmutex_unlock(&priv->wx_mutex);\n\treturn 0;\n}\n\nstatic int _rtl92e_wx_get_nick(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tmutex_lock(&priv->wx_mutex);\n\twrqu->data.length = strlen(priv->nick);\n\tmemcpy(extra, priv->nick, wrqu->data.length);\n\twrqu->data.flags = 1;    \n\tmutex_unlock(&priv->wx_mutex);\n\treturn 0;\n}\n\nstatic int _rtl92e_wx_set_freq(struct net_device *dev,\n\t\t\t       struct iw_request_info *a,\n\t\t\t       union iwreq_data *wrqu, char *b)\n{\n\tint ret;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = rtllib_wx_set_freq(priv->rtllib, a, wrqu, b);\n\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_get_name(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\treturn rtllib_wx_get_name(priv->rtllib, info, wrqu, extra);\n}\n\nstatic int _rtl92e_wx_set_frag(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tif (wrqu->frag.disabled) {\n\t\tpriv->rtllib->fts = DEFAULT_FRAG_THRESHOLD;\n\t} else {\n\t\tif (wrqu->frag.value < MIN_FRAG_THRESHOLD ||\n\t\t    wrqu->frag.value > MAX_FRAG_THRESHOLD)\n\t\t\treturn -EINVAL;\n\n\t\tpriv->rtllib->fts = wrqu->frag.value & ~0x1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _rtl92e_wx_get_frag(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\twrqu->frag.value = priv->rtllib->fts;\n\twrqu->frag.fixed = 0;\t \n\twrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FRAG_THRESHOLD);\n\n\treturn 0;\n}\n\nstatic int _rtl92e_wx_set_wap(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *awrq, char *extra)\n{\n\tint ret;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = rtllib_wx_set_wap(priv->rtllib, info, awrq, extra);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_get_wap(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\treturn rtllib_wx_get_wap(priv->rtllib, info, wrqu, extra);\n}\n\nstatic int _rtl92e_wx_get_enc(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *key)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\treturn rtllib_wx_get_encode(priv->rtllib, info, wrqu, key);\n}\n\nstatic int _rtl92e_wx_set_enc(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *key)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tint ret;\n\n\tstruct rtllib_device *ieee = priv->rtllib;\n\tu32 hwkey[4] = {0, 0, 0, 0};\n\tu8 mask = 0xff;\n\tu32 key_idx = 0;\n\tu8 zero_addr[4][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t\t     {0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\n\t\t\t     {0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\n\t\t\t     {0x00, 0x00, 0x00, 0x00, 0x00, 0x03} };\n\tint i;\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tif (!priv->up)\n\t\treturn -ENETDOWN;\n\n\tpriv->rtllib->wx_set_enc = 1;\n\tmutex_lock(&priv->rtllib->ips_mutex);\n\trtl92e_ips_leave(dev);\n\tmutex_unlock(&priv->rtllib->ips_mutex);\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = rtllib_wx_set_encode(priv->rtllib, info, wrqu, key);\n\tmutex_unlock(&priv->wx_mutex);\n\n\tif (wrqu->encoding.flags & IW_ENCODE_DISABLED) {\n\t\tieee->pairwise_key_type = ieee->group_key_type = KEY_TYPE_NA;\n\t\trtl92e_cam_reset(dev);\n\t\tmemset(priv->rtllib->swcamtable, 0,\n\t\t       sizeof(struct sw_cam_table) * 32);\n\t\tgoto end_hw_sec;\n\t}\n\tif (wrqu->encoding.length != 0) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\thwkey[i] |=  key[4 * i + 0] & mask;\n\t\t\tif (i == 1 && (4 * i + 1) == wrqu->encoding.length)\n\t\t\t\tmask = 0x00;\n\t\t\tif (i == 3 && (4 * i + 1) == wrqu->encoding.length)\n\t\t\t\tmask = 0x00;\n\t\t\thwkey[i] |= (key[4 * i + 1] & mask) << 8;\n\t\t\thwkey[i] |= (key[4 * i + 2] & mask) << 16;\n\t\t\thwkey[i] |= (key[4 * i + 3] & mask) << 24;\n\t\t}\n\n\t\tswitch (wrqu->encoding.flags & IW_ENCODE_INDEX) {\n\t\tcase 0:\n\t\t\tkey_idx = ieee->crypt_info.tx_keyidx;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tkey_idx = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tkey_idx = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tkey_idx = 2;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tkey_idx\t= 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (wrqu->encoding.length == 0x5) {\n\t\t\tieee->pairwise_key_type = KEY_TYPE_WEP40;\n\t\t\trtl92e_enable_hw_security_config(dev);\n\t\t}\n\n\t\telse if (wrqu->encoding.length == 0xd) {\n\t\t\tieee->pairwise_key_type = KEY_TYPE_WEP104;\n\t\t\trtl92e_enable_hw_security_config(dev);\n\t\t\trtl92e_set_key(dev, key_idx, key_idx, KEY_TYPE_WEP104,\n\t\t\t\t       zero_addr[key_idx], 0, hwkey);\n\t\t\trtl92e_set_swcam(dev, key_idx, key_idx, KEY_TYPE_WEP104,\n\t\t\t\t\t zero_addr[key_idx], hwkey);\n\t\t} else {\n\t\t\tnetdev_info(dev,\n\t\t\t\t    \"wrong type in WEP, not WEP40 and WEP104\\n\");\n\t\t}\n\t}\n\nend_hw_sec:\n\tpriv->rtllib->wx_set_enc = 0;\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_set_scan_type(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *aa,\n\t\t\t\t    union iwreq_data *wrqu, char *p)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tint *parms = (int *)p;\n\tint mode = parms[0];\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tpriv->rtllib->active_scan = mode;\n\n\treturn 1;\n}\n\n#define R8192_MAX_RETRY 255\nstatic int _rtl92e_wx_set_retry(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tint err = 0;\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tif (wrqu->retry.flags & IW_RETRY_LIFETIME ||\n\t    wrqu->retry.disabled) {\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\tif (!(wrqu->retry.flags & IW_RETRY_LIMIT)) {\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (wrqu->retry.value > R8192_MAX_RETRY) {\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\tif (wrqu->retry.flags & IW_RETRY_MAX)\n\t\tpriv->retry_rts = wrqu->retry.value;\n\telse\n\t\tpriv->retry_data = wrqu->retry.value;\n\n\trtl92e_commit(dev);\nexit:\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn err;\n}\n\nstatic int _rtl92e_wx_get_retry(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\twrqu->retry.disabled = 0;  \n\n\tif ((wrqu->retry.flags & IW_RETRY_TYPE) ==\n\t    IW_RETRY_LIFETIME)\n\t\treturn -EINVAL;\n\n\tif (wrqu->retry.flags & IW_RETRY_MAX) {\n\t\twrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_MAX;\n\t\twrqu->retry.value = priv->retry_rts;\n\t} else {\n\t\twrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_MIN;\n\t\twrqu->retry.value = priv->retry_data;\n\t}\n\treturn 0;\n}\n\nstatic int _rtl92e_wx_set_encode_ext(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tint ret = 0;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tpriv->rtllib->wx_set_enc = 1;\n\tmutex_lock(&priv->rtllib->ips_mutex);\n\trtl92e_ips_leave(dev);\n\tmutex_unlock(&priv->rtllib->ips_mutex);\n\n\tret = rtllib_wx_set_encode_ext(ieee, info, wrqu, extra);\n\t{\n\t\tconst u8 broadcast_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\t\tconst u8 zero[ETH_ALEN] = {0};\n\t\tu32 key[4] = {0};\n\t\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\t\tstruct iw_point *encoding = &wrqu->encoding;\n\t\tu8 idx = 0, alg = 0, group = 0;\n\n\t\tif ((encoding->flags & IW_ENCODE_DISABLED) ||\n\t\t     ext->alg == IW_ENCODE_ALG_NONE) {\n\t\t\tieee->pairwise_key_type = ieee->group_key_type\n\t\t\t\t\t\t= KEY_TYPE_NA;\n\t\t\trtl92e_cam_reset(dev);\n\t\t\tmemset(priv->rtllib->swcamtable, 0,\n\t\t\t       sizeof(struct sw_cam_table) * 32);\n\t\t\tgoto end_hw_sec;\n\t\t}\n\t\talg = (ext->alg == IW_ENCODE_ALG_CCMP) ? KEY_TYPE_CCMP :\n\t\t      ext->alg;\n\t\tidx = encoding->flags & IW_ENCODE_INDEX;\n\t\tif (idx)\n\t\t\tidx--;\n\t\tgroup = ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY;\n\n\t\tif ((!group) || (ieee->iw_mode == IW_MODE_ADHOC) ||\n\t\t    (alg ==  KEY_TYPE_WEP40)) {\n\t\t\tif ((ext->key_len == 13) && (alg == KEY_TYPE_WEP40))\n\t\t\t\talg = KEY_TYPE_WEP104;\n\t\t\tieee->pairwise_key_type = alg;\n\t\t\trtl92e_enable_hw_security_config(dev);\n\t\t}\n\t\tmemcpy((u8 *)key, ext->key, 16);\n\n\t\tif ((alg & KEY_TYPE_WEP40) && (ieee->auth_mode != 2)) {\n\t\t\tif (ext->key_len == 13)\n\t\t\t\tieee->pairwise_key_type = alg = KEY_TYPE_WEP104;\n\t\t\trtl92e_set_key(dev, idx, idx, alg, zero, 0, key);\n\t\t\trtl92e_set_swcam(dev, idx, idx, alg, zero, key);\n\t\t} else if (group) {\n\t\t\tieee->group_key_type = alg;\n\t\t\trtl92e_set_key(dev, idx, idx, alg, broadcast_addr, 0,\n\t\t\t\t       key);\n\t\t\trtl92e_set_swcam(dev, idx, idx, alg, broadcast_addr, key);\n\t\t} else {\n\t\t\tif ((ieee->pairwise_key_type == KEY_TYPE_CCMP) &&\n\t\t\t     ieee->ht_info->bCurrentHTSupport)\n\t\t\t\trtl92e_writeb(dev, 0x173, 1);\n\t\t\trtl92e_set_key(dev, 4, idx, alg,\n\t\t\t\t       (u8 *)ieee->ap_mac_addr, 0, key);\n\t\t\trtl92e_set_swcam(dev, 4, idx, alg, (u8 *)ieee->ap_mac_addr, key);\n\t\t}\n\t}\n\nend_hw_sec:\n\tpriv->rtllib->wx_set_enc = 0;\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_set_auth(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *data, char *extra)\n{\n\tint ret = 0;\n\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tmutex_lock(&priv->wx_mutex);\n\tret = rtllib_wx_set_auth(priv->rtllib, info, &data->param, extra);\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_set_mlme(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tint ret = 0;\n\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tmutex_lock(&priv->wx_mutex);\n\tret = rtllib_wx_set_mlme(priv->rtllib, info, wrqu, extra);\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_set_gen_ie(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *data, char *extra)\n{\n\tint ret = 0;\n\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->hw_radio_off)\n\t\treturn 0;\n\n\tmutex_lock(&priv->wx_mutex);\n\tret = rtllib_wx_set_gen_ie(priv->rtllib, extra, data->data.length);\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic int _rtl92e_wx_get_gen_ie(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *data, char *extra)\n{\n\tint ret = 0;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\n\tif (ieee->wpa_ie_len == 0 || ieee->wpa_ie == NULL) {\n\t\tdata->data.length = 0;\n\t\treturn 0;\n\t}\n\n\tif (data->data.length < ieee->wpa_ie_len)\n\t\treturn -E2BIG;\n\n\tdata->data.length = ieee->wpa_ie_len;\n\tmemcpy(extra, ieee->wpa_ie, ieee->wpa_ie_len);\n\treturn ret;\n}\n\n#define OID_RT_INTEL_PROMISCUOUS_MODE\t0xFF0101F6\n\nstatic int _rtl92e_wx_set_promisc_mode(struct net_device *dev,\n\t\t\t\t       struct iw_request_info *info,\n\t\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\n\tu32 info_buf[3];\n\n\tu32 oid;\n\tu32 promiscuous_on;\n\tu32 fltr_src_sta_frame;\n\n\tif (copy_from_user(info_buf, wrqu->data.pointer, sizeof(info_buf)))\n\t\treturn -EFAULT;\n\n\toid = info_buf[0];\n\tpromiscuous_on = info_buf[1];\n\tfltr_src_sta_frame = info_buf[2];\n\n\tif (oid == OID_RT_INTEL_PROMISCUOUS_MODE) {\n\t\tieee->intel_promiscuous_md_info.promiscuous_on =\n\t\t\t\t\t(promiscuous_on) ? (true) : (false);\n\t\tieee->intel_promiscuous_md_info.fltr_src_sta_frame =\n\t\t\t(fltr_src_sta_frame) ? (true) : (false);\n\t\t(promiscuous_on) ?\n\t\t(rtllib_EnableIntelPromiscuousMode(dev, false)) :\n\t\t(rtllib_DisableIntelPromiscuousMode(dev, false));\n\n\t\tnetdev_info(dev,\n\t\t\t    \"=======>%s(), on = %d, filter src sta = %d\\n\",\n\t\t\t    __func__, promiscuous_on,\n\t\t\t    fltr_src_sta_frame);\n\t} else {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _rtl92e_wx_get_promisc_mode(struct net_device *dev,\n\t\t\t\t       struct iw_request_info *info,\n\t\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tsnprintf(extra, 45, \"PromiscuousMode:%d, FilterSrcSTAFrame:%d\",\n\t\t ieee->intel_promiscuous_md_info.promiscuous_on,\n\t\t ieee->intel_promiscuous_md_info.fltr_src_sta_frame);\n\twrqu->data.length = strlen(extra) + 1;\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn 0;\n}\n\n#define IW_IOCTL(x) ((x) - SIOCSIWCOMMIT)\nstatic iw_handler r8192_wx_handlers[] = {\n\t[IW_IOCTL(SIOCGIWNAME)] = _rtl92e_wx_get_name,\n\t[IW_IOCTL(SIOCSIWFREQ)] = _rtl92e_wx_set_freq,\n\t[IW_IOCTL(SIOCGIWFREQ)] = _rtl92e_wx_get_freq,\n\t[IW_IOCTL(SIOCSIWMODE)] = _rtl92e_wx_set_mode,\n\t[IW_IOCTL(SIOCGIWMODE)] = _rtl92e_wx_get_mode,\n\t[IW_IOCTL(SIOCGIWRANGE)] = _rtl92e_wx_get_range,\n\t[IW_IOCTL(SIOCSIWAP)] = _rtl92e_wx_set_wap,\n\t[IW_IOCTL(SIOCGIWAP)] = _rtl92e_wx_get_wap,\n\t[IW_IOCTL(SIOCSIWSCAN)] = _rtl92e_wx_set_scan,\n\t[IW_IOCTL(SIOCGIWSCAN)] = _rtl92e_wx_get_scan,\n\t[IW_IOCTL(SIOCSIWESSID)] = _rtl92e_wx_set_essid,\n\t[IW_IOCTL(SIOCGIWESSID)] = _rtl92e_wx_get_essid,\n\t[IW_IOCTL(SIOCSIWNICKN)] = _rtl92e_wx_set_nick,\n\t[IW_IOCTL(SIOCGIWNICKN)] = _rtl92e_wx_get_nick,\n\t[IW_IOCTL(SIOCSIWRATE)] = _rtl92e_wx_set_rate,\n\t[IW_IOCTL(SIOCGIWRATE)] = _rtl92e_wx_get_rate,\n\t[IW_IOCTL(SIOCSIWRTS)] = _rtl92e_wx_set_rts,\n\t[IW_IOCTL(SIOCGIWRTS)] = _rtl92e_wx_get_rts,\n\t[IW_IOCTL(SIOCSIWFRAG)] = _rtl92e_wx_set_frag,\n\t[IW_IOCTL(SIOCGIWFRAG)] = _rtl92e_wx_get_frag,\n\t[IW_IOCTL(SIOCSIWRETRY)] = _rtl92e_wx_set_retry,\n\t[IW_IOCTL(SIOCGIWRETRY)] = _rtl92e_wx_get_retry,\n\t[IW_IOCTL(SIOCSIWENCODE)] = _rtl92e_wx_set_enc,\n\t[IW_IOCTL(SIOCGIWENCODE)] = _rtl92e_wx_get_enc,\n\t[IW_IOCTL(SIOCSIWPOWER)] = _rtl92e_wx_set_power,\n\t[IW_IOCTL(SIOCGIWPOWER)] = _rtl92e_wx_get_power,\n\t[IW_IOCTL(SIOCSIWGENIE)] = _rtl92e_wx_set_gen_ie,\n\t[IW_IOCTL(SIOCGIWGENIE)] = _rtl92e_wx_get_gen_ie,\n\t[IW_IOCTL(SIOCSIWMLME)] = _rtl92e_wx_set_mlme,\n\t[IW_IOCTL(SIOCSIWAUTH)] = _rtl92e_wx_set_auth,\n\t[IW_IOCTL(SIOCSIWENCODEEXT)] = _rtl92e_wx_set_encode_ext,\n};\n\n \nstatic const struct iw_priv_args r8192_private_args[] = {\n\t{\n\t\tSIOCIWFIRSTPRIV + 0x0,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"set_debugflag\"\n\t}, {\n\t\tSIOCIWFIRSTPRIV + 0x1,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"activescan\"\n\t}, {\n\t\tSIOCIWFIRSTPRIV + 0x2,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"rawtx\"\n\t}, {\n\t\tSIOCIWFIRSTPRIV + 0x3,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"forcereset\"\n\t}, {\n\t\tSIOCIWFIRSTPRIV + 0x6,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE,\n\t\t\"set_power\"\n\t}, {\n\t\tSIOCIWFIRSTPRIV + 0xa,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE,\n\t\t\"lps_interv\"\n\t}, {\n\t\tSIOCIWFIRSTPRIV + 0xb,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, IW_PRIV_TYPE_NONE,\n\t\t\"lps_force\"\n\t}, {\n\t\tSIOCIWFIRSTPRIV + 0x16,\n\t\tIW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 3, 0, \"setpromisc\"\n\t}, {\n\t\tSIOCIWFIRSTPRIV + 0x17,\n\t\t0, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | 45, \"getpromisc\"\n\t}\n\n};\n\nstatic iw_handler r8192_private_handler[] = {\n\t(iw_handler)_rtl92e_wx_set_debug,    \n\t(iw_handler)_rtl92e_wx_set_scan_type,\n\t(iw_handler)_rtl92e_wx_set_rawtx,\n\t(iw_handler)_rtl92e_wx_force_reset,\n\t(iw_handler)NULL,\n\t(iw_handler)NULL,\n\t(iw_handler)_rtl92e_wx_adapter_power_status,\n\t(iw_handler)NULL,\n\t(iw_handler)NULL,\n\t(iw_handler)NULL,\n\t(iw_handler)_rtl92e_wx_set_lps_awake_interval,\n\t(iw_handler)_rtl92e_wx_set_force_lps,\n\t(iw_handler)NULL,\n\t(iw_handler)NULL,\n\t(iw_handler)NULL,\n\t(iw_handler)NULL,\n\t(iw_handler)NULL,\n\t(iw_handler)NULL,\n\t(iw_handler)NULL,\n\t(iw_handler)NULL,\n\t(iw_handler)NULL,\n\t(iw_handler)NULL,\n\t(iw_handler)_rtl92e_wx_set_promisc_mode,\n\t(iw_handler)_rtl92e_wx_get_promisc_mode,\n};\n\nstatic struct iw_statistics *_rtl92e_get_wireless_stats(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\tstruct iw_statistics *wstats = &priv->wstats;\n\tint tmp_level = 0;\n\tint tmp_qual = 0;\n\tint tmp_noise = 0;\n\n\tif (ieee->link_state < MAC80211_LINKED) {\n\t\twstats->qual.qual = 10;\n\t\twstats->qual.level = 0;\n\t\twstats->qual.noise = 0x100 - 100;\t \n\t\twstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\n\t\treturn wstats;\n\t}\n\n\ttmp_level = (&ieee->current_network)->stats.rssi;\n\ttmp_qual = (&ieee->current_network)->stats.signal;\n\ttmp_noise = (&ieee->current_network)->stats.noise;\n\n\twstats->qual.level = tmp_level;\n\twstats->qual.qual = tmp_qual;\n\twstats->qual.noise = tmp_noise;\n\twstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\n\treturn wstats;\n}\n\nconst struct iw_handler_def r8192_wx_handlers_def = {\n\t.standard = r8192_wx_handlers,\n\t.num_standard = ARRAY_SIZE(r8192_wx_handlers),\n\t.private = r8192_private_handler,\n\t.num_private = ARRAY_SIZE(r8192_private_handler),\n\t.num_private_args = sizeof(r8192_private_args) /\n\t\t\t    sizeof(struct iw_priv_args),\n\t.get_wireless_stats = _rtl92e_get_wireless_stats,\n\t.private_args = (struct iw_priv_args *)r8192_private_args,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}