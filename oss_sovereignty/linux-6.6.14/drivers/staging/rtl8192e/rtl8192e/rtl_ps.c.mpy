{
  "module_name": "rtl_ps.c",
  "hash_id": "993d2fad370706c23803e78bda32a69fce1093926456e8f840f93a59e94bc1c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtl8192e/rtl_ps.c",
  "human_readable_source": "\n \n#include \"rtl_ps.h\"\n#include \"rtl_core.h\"\n#include \"r8192E_phy.h\"\n#include \"r8192E_phyreg.h\"\n#include \"r8190P_rtl8256.h\"  \n#include \"r8192E_cmdpkt.h\"\n#include <linux/jiffies.h>\n\nstatic void _rtl92e_hw_sleep(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&priv->rf_ps_lock, flags);\n\tif (priv->rf_change_in_progress) {\n\t\tspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\n\trtl92e_set_rf_state(dev, rf_sleep, RF_CHANGE_BY_PS);\n}\n\nvoid rtl92e_hw_sleep_wq(void *data)\n{\n\tstruct rtllib_device *ieee = container_of_dwork_rsl(data,\n\t\t\t\t     struct rtllib_device, hw_sleep_wq);\n\tstruct net_device *dev = ieee->dev;\n\n\t_rtl92e_hw_sleep(dev);\n}\n\nvoid rtl92e_hw_wakeup(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&priv->rf_ps_lock, flags);\n\tif (priv->rf_change_in_progress) {\n\t\tspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\n\t\tschedule_delayed_work(&priv->rtllib->hw_wakeup_wq,\n\t\t\t\t      msecs_to_jiffies(10));\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\n\trtl92e_set_rf_state(dev, rf_on, RF_CHANGE_BY_PS);\n}\n\nvoid rtl92e_hw_wakeup_wq(void *data)\n{\n\tstruct rtllib_device *ieee = container_of_dwork_rsl(data,\n\t\t\t\t     struct rtllib_device, hw_wakeup_wq);\n\tstruct net_device *dev = ieee->dev;\n\n\trtl92e_hw_wakeup(dev);\n}\n\n#define MIN_SLEEP_TIME 50\n#define MAX_SLEEP_TIME 10000\nvoid rtl92e_enter_sleep(struct net_device *dev, u64 time)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tu32 tmp;\n\tunsigned long flags;\n\tunsigned long timeout;\n\n\tspin_lock_irqsave(&priv->ps_lock, flags);\n\n\ttime -= msecs_to_jiffies(8 + 16 + 7);\n\n\ttimeout = jiffies + msecs_to_jiffies(MIN_SLEEP_TIME);\n\tif (time_before((unsigned long)time, timeout)) {\n\t\tspin_unlock_irqrestore(&priv->ps_lock, flags);\n\t\tnetdev_info(dev, \"too short to sleep::%lld < %ld\\n\",\n\t\t\t    time - jiffies, msecs_to_jiffies(MIN_SLEEP_TIME));\n\t\treturn;\n\t}\n\ttimeout = jiffies + msecs_to_jiffies(MAX_SLEEP_TIME);\n\tif (time_after((unsigned long)time, timeout)) {\n\t\tnetdev_info(dev, \"========>too long to sleep:%lld > %ld\\n\",\n\t\t\t    time - jiffies, msecs_to_jiffies(MAX_SLEEP_TIME));\n\t\tspin_unlock_irqrestore(&priv->ps_lock, flags);\n\t\treturn;\n\t}\n\ttmp = time - jiffies;\n\tschedule_delayed_work(&priv->rtllib->hw_wakeup_wq, tmp);\n\tschedule_delayed_work(&priv->rtllib->hw_sleep_wq, 0);\n\tspin_unlock_irqrestore(&priv->ps_lock, flags);\n}\n\nstatic void _rtl92e_ps_update_rf_state(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_pwr_save_ctrl *psc = (struct rt_pwr_save_ctrl *)\n\t\t\t\t\t&priv->rtllib->pwr_save_ctrl;\n\n\tpsc->bSwRfProcessing = true;\n\trtl92e_set_rf_state(dev, psc->eInactivePowerState, RF_CHANGE_BY_IPS);\n\n\tpsc->bSwRfProcessing = false;\n}\n\nvoid rtl92e_ips_enter(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_pwr_save_ctrl *psc = (struct rt_pwr_save_ctrl *)\n\t\t\t\t\t&priv->rtllib->pwr_save_ctrl;\n\tenum rt_rf_power_state rt_state;\n\n\trt_state = priv->rtllib->rf_power_state;\n\tif (rt_state == rf_on && !psc->bSwRfProcessing &&\n\t\t(priv->rtllib->link_state != MAC80211_LINKED)) {\n\t\tpsc->eInactivePowerState = rf_off;\n\t\t_rtl92e_ps_update_rf_state(dev);\n\t}\n}\n\nvoid rtl92e_ips_leave(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_pwr_save_ctrl *psc = (struct rt_pwr_save_ctrl *)\n\t\t\t\t\t&priv->rtllib->pwr_save_ctrl;\n\tenum rt_rf_power_state rt_state;\n\n\trt_state = priv->rtllib->rf_power_state;\n\tif (rt_state != rf_on  && !psc->bSwRfProcessing &&\n\t    priv->rtllib->rf_off_reason <= RF_CHANGE_BY_IPS) {\n\t\tpsc->eInactivePowerState = rf_on;\n\t\t_rtl92e_ps_update_rf_state(dev);\n\t}\n}\n\nvoid rtl92e_ips_leave_wq(void *data)\n{\n\tstruct rtllib_device *ieee = container_of(data, struct rtllib_device, ips_leave_wq);\n\tstruct net_device *dev = ieee->dev;\n\tstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\n\n\tmutex_lock(&priv->rtllib->ips_mutex);\n\trtl92e_ips_leave(dev);\n\tmutex_unlock(&priv->rtllib->ips_mutex);\n}\n\nvoid rtl92e_rtllib_ips_leave_wq(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\n\tenum rt_rf_power_state rt_state;\n\n\trt_state = priv->rtllib->rf_power_state;\n\tif (rt_state == rf_off) {\n\t\tif (priv->rtllib->rf_off_reason > RF_CHANGE_BY_IPS) {\n\t\t\tnetdev_warn(dev, \"%s(): RF is OFF.\\n\",\n\t\t\t\t    __func__);\n\t\t\treturn;\n\t\t}\n\t\tnetdev_info(dev, \"=========>%s(): rtl92e_ips_leave\\n\",\n\t\t\t    __func__);\n\t\tschedule_work(&priv->rtllib->ips_leave_wq);\n\t}\n}\n\nvoid rtl92e_rtllib_ips_leave(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\n\n\tmutex_lock(&priv->rtllib->ips_mutex);\n\trtl92e_ips_leave(dev);\n\tmutex_unlock(&priv->rtllib->ips_mutex);\n}\n\nstatic bool _rtl92e_ps_set_mode(struct net_device *dev, u8 rtPsMode)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->rtllib->iw_mode == IW_MODE_ADHOC)\n\t\treturn false;\n\n\tif (!priv->ps_force)\n\t\tpriv->rtllib->ps = rtPsMode;\n\tif (priv->rtllib->sta_sleep != LPS_IS_WAKE &&\n\t    rtPsMode == RTLLIB_PS_DISABLED) {\n\t\tunsigned long flags;\n\n\t\trtl92e_hw_wakeup(dev);\n\t\tpriv->rtllib->sta_sleep = LPS_IS_WAKE;\n\n\t\tspin_lock_irqsave(&(priv->rtllib->mgmt_tx_lock), flags);\n\t\trtllib_sta_ps_send_null_frame(priv->rtllib, 0);\n\t\tspin_unlock_irqrestore(&(priv->rtllib->mgmt_tx_lock), flags);\n\t}\n\n\treturn true;\n}\n\nvoid rtl92e_leisure_ps_enter(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_pwr_save_ctrl *psc = (struct rt_pwr_save_ctrl *)\n\t\t\t\t\t&priv->rtllib->pwr_save_ctrl;\n\n\tif (!((priv->rtllib->iw_mode == IW_MODE_INFRA) &&\n\t    (priv->rtllib->link_state == MAC80211_LINKED))\n\t    || (priv->rtllib->iw_mode == IW_MODE_ADHOC))\n\t\treturn;\n\n\tif (psc->bLeisurePs) {\n\t\tif (psc->LpsIdleCount >= RT_CHECK_FOR_HANG_PERIOD) {\n\n\t\t\tif (priv->rtllib->ps == RTLLIB_PS_DISABLED)\n\t\t\t\t_rtl92e_ps_set_mode(dev, RTLLIB_PS_MBCAST | RTLLIB_PS_UNICAST);\n\t\t} else {\n\t\t\tpsc->LpsIdleCount++;\n\t\t}\n\t}\n}\n\nvoid rtl92e_leisure_ps_leave(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_pwr_save_ctrl *psc = (struct rt_pwr_save_ctrl *)\n\t\t\t\t\t&priv->rtllib->pwr_save_ctrl;\n\n\tif (psc->bLeisurePs) {\n\t\tif (priv->rtllib->ps != RTLLIB_PS_DISABLED)\n\t\t\t_rtl92e_ps_set_mode(dev, RTLLIB_PS_DISABLED);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}