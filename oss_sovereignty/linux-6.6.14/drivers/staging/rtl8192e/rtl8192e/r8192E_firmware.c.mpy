{
  "module_name": "r8192E_firmware.c",
  "hash_id": "3dd73bfd0d4ae7d59ce953f598f9a87479d68d27b81680b2e65f1640e2018f4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtl8192e/r8192E_firmware.c",
  "human_readable_source": "\n \n#include \"rtl_core.h\"\n#include \"r8192E_hw.h\"\n#include \"table.h\"\n#include \"r8192E_firmware.h\"\n#include \"r8192E_cmdpkt.h\"\n#include <linux/firmware.h>\n\nstatic bool _rtl92e_wait_for_fw(struct net_device *dev, u32 mask, u32 timeout)\n{\n\tunsigned long deadline = jiffies + msecs_to_jiffies(timeout);\n\n\twhile (time_before(jiffies, deadline)) {\n\t\tif (rtl92e_readl(dev, CPU_GEN) & mask)\n\t\t\treturn true;\n\t\tmdelay(2);\n\t}\n\treturn false;\n}\n\nstatic bool _rtl92e_fw_boot_cpu(struct net_device *dev)\n{\n\tu32\t\tCPU_status = 0;\n\n\tif (!_rtl92e_wait_for_fw(dev, CPU_GEN_PUT_CODE_OK, 200)) {\n\t\tnetdev_err(dev, \"Firmware download failed.\\n\");\n\t\treturn false;\n\t}\n\tnetdev_dbg(dev, \"Download Firmware: Put code ok!\\n\");\n\n\tCPU_status = rtl92e_readl(dev, CPU_GEN);\n\trtl92e_writeb(dev, CPU_GEN, (CPU_status | CPU_GEN_PWR_STB_CPU) & 0xff);\n\tmdelay(1);\n\n\tif (!_rtl92e_wait_for_fw(dev, CPU_GEN_BOOT_RDY, 200)) {\n\t\tnetdev_err(dev, \"Firmware boot failed.\\n\");\n\t\treturn false;\n\t}\n\n\tnetdev_dbg(dev, \"Download Firmware: Boot ready!\\n\");\n\n\treturn true;\n}\n\nstatic bool _rtl92e_fw_check_ready(struct net_device *dev,\n\t\t\t\t   u8 load_fw_status)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_firmware *pfirmware = priv->fw_info;\n\tbool rt_status  = true;\n\n\tswitch (load_fw_status) {\n\tcase FW_INIT_STEP0_BOOT:\n\t\tpfirmware->status = FW_STATUS_1_MOVE_BOOT_CODE;\n\t\tbreak;\n\n\tcase FW_INIT_STEP1_MAIN:\n\t\tpfirmware->status = FW_STATUS_2_MOVE_MAIN_CODE;\n\n\t\trt_status = _rtl92e_fw_boot_cpu(dev);\n\t\tif (rt_status)\n\t\t\tpfirmware->status = FW_STATUS_3_TURNON_CPU;\n\t\telse\n\t\t\tnetdev_dbg(dev, \"_rtl92e_fw_boot_cpu fail!\\n\");\n\n\t\tbreak;\n\n\tcase FW_INIT_STEP2_DATA:\n\t\tpfirmware->status = FW_STATUS_4_MOVE_DATA_CODE;\n\t\tmdelay(1);\n\n\t\trt_status = _rtl92e_wait_for_fw(dev, CPU_GEN_FIRM_RDY, 20);\n\t\tif (rt_status)\n\t\t\tpfirmware->status = FW_STATUS_5_READY;\n\t\tbreak;\n\tdefault:\n\t\trt_status = false;\n\t\tnetdev_dbg(dev, \"Unknown firmware status\");\n\t\tbreak;\n\t}\n\n\treturn rt_status;\n}\n\nstatic bool _rtl92e_fw_prepare(struct net_device *dev, struct rt_fw_blob *blob,\n\t\t\t       const char *name, u8 padding)\n{\n\tconst struct firmware *fw;\n\tint rc, i;\n\tbool ret = true;\n\n\trc = request_firmware(&fw, name, &dev->dev);\n\tif (rc < 0)\n\t\treturn false;\n\n\tif (round_up(fw->size, 4) > MAX_FW_SIZE - padding) {\n\t\tnetdev_err(dev, \"Firmware image %s too big for the device.\\n\",\n\t\t\t   name);\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (padding)\n\t\tmemset(blob->data, 0, padding);\n\tif (fw->size % 4)\n\t\tmemset(blob->data + padding + fw->size, 0, 4);\n\tmemcpy(blob->data + padding, fw->data, fw->size);\n\n\tblob->size = round_up(fw->size, 4) + padding;\n\n\t \n\tfor (i = padding; i < blob->size; i += 4) {\n\t\tu32 *data = (u32 *)(blob->data + i);\n\t\t*data = swab32p(data);\n\t}\nout:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nbool rtl92e_init_fw(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tbool\t\t\trt_status = true;\n\n\tu32\tfile_length = 0;\n\tu8\t*mapped_file = NULL;\n\tu8\ti = 0;\n\tenum opt_rst_type rst_opt = OPT_SYSTEM_RESET;\n\tenum firmware_init_step starting_state = FW_INIT_STEP0_BOOT;\n\n\tstruct rt_firmware *pfirmware = priv->fw_info;\n\n\tnetdev_dbg(dev, \" PlatformInitFirmware()==>\\n\");\n\n\tif (pfirmware->status == FW_STATUS_0_INIT) {\n\t\trst_opt = OPT_SYSTEM_RESET;\n\t\tstarting_state = FW_INIT_STEP0_BOOT;\n\n\t} else if (pfirmware->status == FW_STATUS_5_READY) {\n\t\trst_opt = OPT_FIRMWARE_RESET;\n\t\tstarting_state = FW_INIT_STEP2_DATA;\n\t}\n\n\tfor (i = starting_state; i <= FW_INIT_STEP2_DATA; i++) {\n\t\tif (rst_opt == OPT_SYSTEM_RESET) {\n\t\t\tif (pfirmware->blobs[i].size == 0) {\n\t\t\t\tconst char *fw_name[3] = {\n\t\t\t\t\tRTL8192E_BOOT_IMG_FW,\n\t\t\t\t\tRTL8192E_MAIN_IMG_FW,\n\t\t\t\t\tRTL8192E_DATA_IMG_FW\n\t\t\t\t};\n\t\t\t\tint pad = 0;\n\n\t\t\t\tif (i == FW_INIT_STEP1_MAIN)\n\t\t\t\t\tpad = 128;\n\n\t\t\t\tif (!_rtl92e_fw_prepare(dev,\n\t\t\t\t\t\t\t&pfirmware->blobs[i],\n\t\t\t\t\t\t\tfw_name[i],\n\t\t\t\t\t\t\tpad))\n\t\t\t\t\tgoto download_firmware_fail;\n\t\t\t}\n\t\t}\n\n\t\tmapped_file = pfirmware->blobs[i].data;\n\t\tfile_length = pfirmware->blobs[i].size;\n\n\t\trt_status = rtl92e_send_cmd_pkt(dev, DESC_PACKET_TYPE_INIT,\n\t\t\t\t\t\tmapped_file, file_length);\n\t\tif (!rt_status)\n\t\t\tgoto download_firmware_fail;\n\n\t\tif (!_rtl92e_fw_check_ready(dev, i))\n\t\t\tgoto download_firmware_fail;\n\t}\n\n\tnetdev_dbg(dev, \"Firmware Download Success\\n\");\n\treturn rt_status;\n\ndownload_firmware_fail:\n\tnetdev_err(dev, \"%s: Failed to initialize firmware.\\n\", __func__);\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}