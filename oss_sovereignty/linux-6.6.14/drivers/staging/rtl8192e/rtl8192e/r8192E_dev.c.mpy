{
  "module_name": "r8192E_dev.c",
  "hash_id": "54e4b0f17a5f0de357fa15cc91a02b1c649ef585051cb0a6dc26283054a81827",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtl8192e/r8192E_dev.c",
  "human_readable_source": "\n \n#include \"rtl_core.h\"\n#include \"r8192E_phy.h\"\n#include \"r8192E_phyreg.h\"\n#include \"r8190P_rtl8256.h\"\n#include \"r8192E_cmdpkt.h\"\n#include \"rtl_dm.h\"\n#include \"rtl_wx.h\"\n\nstatic int WDCAPARA_ADD[] = {EDCAPARA_BE, EDCAPARA_BK, EDCAPARA_VI,\n\t\t\t     EDCAPARA_VO};\n\nvoid rtl92e_start_beacon(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\n\tstruct rtllib_network *net = &priv->rtllib->current_network;\n\tu16 BcnTimeCfg = 0;\n\tu16 BcnCW = 6;\n\tu16 BcnIFS = 0xf;\n\n\trtl92e_irq_disable(dev);\n\n\trtl92e_writew(dev, ATIMWND, 2);\n\n\trtl92e_writew(dev, BCN_INTERVAL, net->beacon_interval);\n\trtl92e_writew(dev, BCN_DRV_EARLY_INT, 10);\n\trtl92e_writew(dev, BCN_DMATIME, 256);\n\n\trtl92e_writeb(dev, BCN_ERR_THRESH, 100);\n\n\tBcnTimeCfg |= BcnCW << BCN_TCFG_CW_SHIFT;\n\tBcnTimeCfg |= BcnIFS << BCN_TCFG_IFS;\n\trtl92e_writew(dev, BCN_TCFG, BcnTimeCfg);\n\trtl92e_irq_enable(dev);\n}\n\nstatic void _rtl92e_update_msr(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8 msr;\n\n\tmsr  = rtl92e_readb(dev, MSR);\n\tmsr &= ~MSR_LINK_MASK;\n\n\tswitch (priv->rtllib->iw_mode) {\n\tcase IW_MODE_INFRA:\n\t\tif (priv->rtllib->link_state == MAC80211_LINKED)\n\t\t\tmsr |= MSR_LINK_MANAGED;\n\t\tbreak;\n\tcase IW_MODE_ADHOC:\n\t\tif (priv->rtllib->link_state == MAC80211_LINKED)\n\t\t\tmsr |= MSR_LINK_ADHOC;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trtl92e_writeb(dev, MSR, msr);\n}\n\nvoid rtl92e_set_reg(struct net_device *dev, u8 variable, u8 *val)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tswitch (variable) {\n\tcase HW_VAR_BSSID:\n\t\t \n\t\trtl92e_writew(dev, BSSIDR, *(u16 *)val);\n\t\trtl92e_writel(dev, BSSIDR + 2, *(u32 *)(val + 2));\n\t\tbreak;\n\n\tcase HW_VAR_MEDIA_STATUS:\n\t{\n\t\tenum rt_op_mode OpMode = *((enum rt_op_mode *)(val));\n\t\tu8 btMsr = rtl92e_readb(dev, MSR);\n\n\t\tbtMsr &= 0xfc;\n\n\t\tswitch (OpMode) {\n\t\tcase RT_OP_MODE_INFRASTRUCTURE:\n\t\t\tbtMsr |= MSR_INFRA;\n\t\t\tbreak;\n\n\t\tcase RT_OP_MODE_IBSS:\n\t\t\tbtMsr |= MSR_ADHOC;\n\t\t\tbreak;\n\n\t\tcase RT_OP_MODE_AP:\n\t\t\tbtMsr |= MSR_AP;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbtMsr |= MSR_NOLINK;\n\t\t\tbreak;\n\t\t}\n\n\t\trtl92e_writeb(dev, MSR, btMsr);\n\t}\n\tbreak;\n\n\tcase HW_VAR_CECHK_BSSID:\n\t{\n\t\tu32\tRegRCR, Type;\n\n\t\tType = val[0];\n\t\tRegRCR = rtl92e_readl(dev, RCR);\n\t\tpriv->receive_config = RegRCR;\n\n\t\tif (Type)\n\t\t\tRegRCR |= (RCR_CBSSID);\n\t\telse\n\t\t\tRegRCR &= (~RCR_CBSSID);\n\n\t\trtl92e_writel(dev, RCR, RegRCR);\n\t\tpriv->receive_config = RegRCR;\n\t}\n\tbreak;\n\n\tcase HW_VAR_SLOT_TIME:\n\n\t\tpriv->slot_time = val[0];\n\t\trtl92e_writeb(dev, SLOT_TIME, val[0]);\n\n\t\tbreak;\n\n\tcase HW_VAR_ACK_PREAMBLE:\n\t{\n\t\tu32 regTmp;\n\n\t\tpriv->short_preamble = (bool)*val;\n\t\tregTmp = priv->basic_rate;\n\t\tif (priv->short_preamble)\n\t\t\tregTmp |= BRSR_AckShortPmb;\n\t\trtl92e_writel(dev, RRSR, regTmp);\n\t\tbreak;\n\t}\n\n\tcase HW_VAR_CPU_RST:\n\t\trtl92e_writel(dev, CPU_GEN, ((u32 *)(val))[0]);\n\t\tbreak;\n\n\tcase HW_VAR_AC_PARAM:\n\t{\n\t\tu8\tpAcParam = *val;\n\t\tu32\teACI = pAcParam;\n\t\tu8\t\tu1bAIFS;\n\t\tu32\t\tu4bAcParam;\n\t\tu8 mode = priv->rtllib->mode;\n\t\tstruct rtllib_qos_parameters *qop =\n\t\t\t &priv->rtllib->current_network.qos_data.parameters;\n\n\t\tu1bAIFS = qop->aifs[pAcParam] *\n\t\t\t  ((mode & (WIRELESS_MODE_G | WIRELESS_MODE_N_24G)) ? 9 : 20) + aSifsTime;\n\n\t\trtl92e_dm_init_edca_turbo(dev);\n\n\t\tu4bAcParam = (le16_to_cpu(qop->tx_op_limit[pAcParam]) <<\n\t\t\t      AC_PARAM_TXOP_LIMIT_OFFSET) |\n\t\t\t\t((le16_to_cpu(qop->cw_max[pAcParam])) <<\n\t\t\t\t AC_PARAM_ECW_MAX_OFFSET) |\n\t\t\t\t((le16_to_cpu(qop->cw_min[pAcParam])) <<\n\t\t\t\t AC_PARAM_ECW_MIN_OFFSET) |\n\t\t\t\t(((u32)u1bAIFS) << AC_PARAM_AIFS_OFFSET);\n\n\t\tswitch (eACI) {\n\t\tcase AC1_BK:\n\t\t\trtl92e_writel(dev, EDCAPARA_BK, u4bAcParam);\n\t\t\tbreak;\n\n\t\tcase AC0_BE:\n\t\t\trtl92e_writel(dev, EDCAPARA_BE, u4bAcParam);\n\t\t\tbreak;\n\n\t\tcase AC2_VI:\n\t\t\trtl92e_writel(dev, EDCAPARA_VI, u4bAcParam);\n\t\t\tbreak;\n\n\t\tcase AC3_VO:\n\t\t\trtl92e_writel(dev, EDCAPARA_VO, u4bAcParam);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnetdev_info(dev, \"SetHwReg8185(): invalid ACI: %d !\\n\",\n\t\t\t\t    eACI);\n\t\t\tbreak;\n\t\t}\n\t\tpriv->rtllib->SetHwRegHandler(dev, HW_VAR_ACM_CTRL,\n\t\t\t\t\t      &pAcParam);\n\t\tbreak;\n\t}\n\n\tcase HW_VAR_ACM_CTRL:\n\t{\n\t\tstruct rtllib_qos_parameters *qos_parameters =\n\t\t\t &priv->rtllib->current_network.qos_data.parameters;\n\t\tu8 pAcParam = *val;\n\t\tu32 eACI = pAcParam;\n\t\tunion aci_aifsn *pAciAifsn = (union aci_aifsn *)&\n\t\t\t\t\t      (qos_parameters->aifs[0]);\n\t\tu8 acm = pAciAifsn->f.acm;\n\t\tu8 AcmCtrl = rtl92e_readb(dev, ACM_HW_CTRL);\n\n\t\tif (acm) {\n\t\t\tswitch (eACI) {\n\t\t\tcase AC0_BE:\n\t\t\t\tAcmCtrl |= ACM_HW_BEQ_EN;\n\t\t\t\tbreak;\n\n\t\t\tcase AC2_VI:\n\t\t\t\tAcmCtrl |= ACM_HW_VIQ_EN;\n\t\t\t\tbreak;\n\n\t\t\tcase AC3_VO:\n\t\t\t\tAcmCtrl |= ACM_HW_VOQ_EN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (eACI) {\n\t\t\tcase AC0_BE:\n\t\t\t\tAcmCtrl &= (~ACM_HW_BEQ_EN);\n\t\t\t\tbreak;\n\n\t\t\tcase AC2_VI:\n\t\t\t\tAcmCtrl &= (~ACM_HW_VIQ_EN);\n\t\t\t\tbreak;\n\n\t\t\tcase AC3_VO:\n\t\t\t\tAcmCtrl &= (~ACM_HW_BEQ_EN);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trtl92e_writeb(dev, ACM_HW_CTRL, AcmCtrl);\n\t\tbreak;\n\t}\n\n\tcase HW_VAR_SIFS:\n\t\trtl92e_writeb(dev, SIFS, val[0]);\n\t\trtl92e_writeb(dev, SIFS + 1, val[0]);\n\t\tbreak;\n\n\tcase HW_VAR_RF_TIMING:\n\t{\n\t\tu8 Rf_Timing = *val;\n\n\t\trtl92e_writeb(dev, rFPGA0_RFTiming1, Rf_Timing);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void _rtl92e_read_eeprom_info(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tconst u8 bMac_Tmp_Addr[ETH_ALEN] = {0x00, 0xe0, 0x4c, 0x00, 0x00, 0x01};\n\tu8 tempval;\n\tu8 ICVer8192, ICVer8256;\n\tu16 i, usValue, IC_Version;\n\tu16 EEPROMId;\n\n\tEEPROMId = rtl92e_eeprom_read(dev, 0);\n\tif (EEPROMId != RTL8190_EEPROM_ID) {\n\t\tnetdev_err(dev, \"%s(): Invalid EEPROM ID: %x\\n\", __func__,\n\t\t\t   EEPROMId);\n\t\tpriv->autoload_fail_flag = true;\n\t} else {\n\t\tpriv->autoload_fail_flag = false;\n\t}\n\n\tif (!priv->autoload_fail_flag) {\n\t\tpriv->eeprom_vid = rtl92e_eeprom_read(dev, EEPROM_VID >> 1);\n\t\tpriv->eeprom_did = rtl92e_eeprom_read(dev, EEPROM_DID >> 1);\n\n\t\tusValue = rtl92e_eeprom_read(dev,\n\t\t\t\t\t     (EEPROM_Customer_ID >> 1)) >> 8;\n\t\tpriv->eeprom_customer_id = usValue & 0xff;\n\t\tusValue = rtl92e_eeprom_read(dev,\n\t\t\t\t\t     EEPROM_ICVersion_ChannelPlan >> 1);\n\t\tpriv->eeprom_chnl_plan = usValue & 0xff;\n\t\tIC_Version = (usValue & 0xff00) >> 8;\n\n\t\tICVer8192 = IC_Version & 0xf;\n\t\tICVer8256 = (IC_Version & 0xf0) >> 4;\n\t\tif (ICVer8192 == 0x2) {\n\t\t\tif (ICVer8256 == 0x5)\n\t\t\t\tpriv->card_8192_version = VERSION_8190_BE;\n\t\t}\n\t\tswitch (priv->card_8192_version) {\n\t\tcase VERSION_8190_BD:\n\t\tcase VERSION_8190_BE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpriv->card_8192_version = VERSION_8190_BD;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tpriv->card_8192_version = VERSION_8190_BD;\n\t\tpriv->eeprom_vid = 0;\n\t\tpriv->eeprom_did = 0;\n\t\tpriv->eeprom_customer_id = 0;\n\t\tpriv->eeprom_chnl_plan = 0;\n\t}\n\n\tif (!priv->autoload_fail_flag) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\tfor (i = 0; i < 6; i += 2) {\n\t\t\tusValue = rtl92e_eeprom_read(dev,\n\t\t\t\t (EEPROM_NODE_ADDRESS_BYTE_0 + i) >> 1);\n\t\t\t*(u16 *)(&addr[i]) = usValue;\n\t\t}\n\t\teth_hw_addr_set(dev, addr);\n\t} else {\n\t\teth_hw_addr_set(dev, bMac_Tmp_Addr);\n\t}\n\n\tif (priv->card_8192_version > VERSION_8190_BD)\n\t\tpriv->tx_pwr_data_read_from_eeprom = true;\n\telse\n\t\tpriv->tx_pwr_data_read_from_eeprom = false;\n\n\tif (priv->card_8192_version > VERSION_8190_BD) {\n\t\tif (!priv->autoload_fail_flag) {\n\t\t\ttempval = (rtl92e_eeprom_read(dev,\n\t\t\t\t\t\t      (EEPROM_RFInd_PowerDiff >> 1))) & 0xff;\n\t\t\tpriv->eeprom_legacy_ht_tx_pwr_diff = tempval & 0xf;\n\t\t} else {\n\t\t\tpriv->eeprom_legacy_ht_tx_pwr_diff = 0x04;\n\t\t}\n\n\t\tif (!priv->autoload_fail_flag)\n\t\t\tpriv->eeprom_thermal_meter = ((rtl92e_eeprom_read(dev,\n\t\t\t\t\t\t   (EEPROM_ThermalMeter >> 1))) &\n\t\t\t\t\t\t   0xff00) >> 8;\n\t\telse\n\t\t\tpriv->eeprom_thermal_meter = EEPROM_Default_ThermalMeter;\n\t\tpriv->tssi_13dBm = priv->eeprom_thermal_meter * 100;\n\n\t\tif (priv->epromtype == EEPROM_93C46) {\n\t\t\tif (!priv->autoload_fail_flag) {\n\t\t\t\tusValue = rtl92e_eeprom_read(dev,\n\t\t\t\t\t  EEPROM_TxPwDiff_CrystalCap >> 1);\n\t\t\t\tpriv->eeprom_ant_pwr_diff = usValue & 0x0fff;\n\t\t\t\tpriv->eeprom_crystal_cap = (usValue & 0xf000)\n\t\t\t\t\t\t\t >> 12;\n\t\t\t} else {\n\t\t\t\tpriv->eeprom_ant_pwr_diff =\n\t\t\t\t\t EEPROM_Default_AntTxPowerDiff;\n\t\t\t\tpriv->eeprom_crystal_cap =\n\t\t\t\t\t EEPROM_Default_TxPwDiff_CrystalCap;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 14; i += 2) {\n\t\t\t\tif (!priv->autoload_fail_flag)\n\t\t\t\t\tusValue = rtl92e_eeprom_read(dev,\n\t\t\t\t\t\t  (EEPROM_TxPwIndex_CCK + i) >> 1);\n\t\t\t\telse\n\t\t\t\t\tusValue = EEPROM_Default_TxPower;\n\t\t\t\t*((u16 *)(&priv->eeprom_tx_pwr_level_cck[i])) =\n\t\t\t\t\t\t\t\t usValue;\n\t\t\t}\n\t\t\tfor (i = 0; i < 14; i += 2) {\n\t\t\t\tif (!priv->autoload_fail_flag)\n\t\t\t\t\tusValue = rtl92e_eeprom_read(dev,\n\t\t\t\t\t\t(EEPROM_TxPwIndex_OFDM_24G + i) >> 1);\n\t\t\t\telse\n\t\t\t\t\tusValue = EEPROM_Default_TxPower;\n\t\t\t\t*((u16 *)(&priv->eeprom_tx_pwr_level_ofdm24g[i]))\n\t\t\t\t\t\t\t = usValue;\n\t\t\t}\n\t\t}\n\t\tif (priv->epromtype == EEPROM_93C46) {\n\t\t\tfor (i = 0; i < 14; i++) {\n\t\t\t\tpriv->tx_pwr_level_cck[i] =\n\t\t\t\t\t priv->eeprom_tx_pwr_level_cck[i];\n\t\t\t\tpriv->tx_pwr_level_ofdm_24g[i] =\n\t\t\t\t\t priv->eeprom_tx_pwr_level_ofdm24g[i];\n\t\t\t}\n\t\t\tpriv->legacy_ht_tx_pwr_diff =\n\t\t\t\t\t priv->eeprom_legacy_ht_tx_pwr_diff;\n\t\t\tpriv->antenna_tx_pwr_diff[0] = priv->eeprom_ant_pwr_diff & 0xf;\n\t\t\tpriv->antenna_tx_pwr_diff[1] = (priv->eeprom_ant_pwr_diff &\n\t\t\t\t\t\t\t0xf0) >> 4;\n\t\t\tpriv->antenna_tx_pwr_diff[2] = (priv->eeprom_ant_pwr_diff &\n\t\t\t\t\t\t\t0xf00) >> 8;\n\t\t\tpriv->crystal_cap = priv->eeprom_crystal_cap;\n\t\t\tpriv->thermal_meter[0] = priv->eeprom_thermal_meter & 0xf;\n\t\t\tpriv->thermal_meter[1] = (priv->eeprom_thermal_meter &\n\t\t\t\t\t\t     0xf0) >> 4;\n\t\t} else if (priv->epromtype == EEPROM_93C56) {\n\t\t\tpriv->legacy_ht_tx_pwr_diff =\n\t\t\t\t priv->eeprom_legacy_ht_tx_pwr_diff;\n\t\t\tpriv->antenna_tx_pwr_diff[0] = 0;\n\t\t\tpriv->antenna_tx_pwr_diff[1] = 0;\n\t\t\tpriv->antenna_tx_pwr_diff[2] = 0;\n\t\t\tpriv->crystal_cap = priv->eeprom_crystal_cap;\n\t\t\tpriv->thermal_meter[0] = priv->eeprom_thermal_meter & 0xf;\n\t\t\tpriv->thermal_meter[1] = (priv->eeprom_thermal_meter &\n\t\t\t\t\t\t     0xf0) >> 4;\n\t\t}\n\t}\n\n\trtl92e_init_adaptive_rate(dev);\n\n\tpriv->chnl_plan = priv->eeprom_chnl_plan;\n\n\tswitch (priv->eeprom_customer_id) {\n\tcase EEPROM_CID_NetCore:\n\t\tpriv->customer_id = RT_CID_819X_NETCORE;\n\t\tbreak;\n\tcase EEPROM_CID_TOSHIBA:\n\t\tpriv->customer_id = RT_CID_TOSHIBA;\n\t\tif (priv->eeprom_chnl_plan & 0x80)\n\t\t\tpriv->chnl_plan = priv->eeprom_chnl_plan & 0x7f;\n\t\telse\n\t\t\tpriv->chnl_plan = 0x0;\n\t\tbreak;\n\t}\n\n\tif (priv->chnl_plan > CHANNEL_PLAN_LEN - 1)\n\t\tpriv->chnl_plan = 0;\n\tpriv->chnl_plan = COUNTRY_CODE_WORLD_WIDE_13;\n\n\tif (priv->eeprom_vid == 0x1186 &&  priv->eeprom_did == 0x3304)\n\t\tpriv->rtllib->bSupportRemoteWakeUp = true;\n\telse\n\t\tpriv->rtllib->bSupportRemoteWakeUp = false;\n}\n\nvoid rtl92e_get_eeprom_size(struct net_device *dev)\n{\n\tu16 curCR;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tcurCR = rtl92e_readw(dev, EPROM_CMD);\n\tpriv->epromtype = (curCR & EPROM_CMD_9356SEL) ? EEPROM_93C56 :\n\t\t\t  EEPROM_93C46;\n\t_rtl92e_read_eeprom_info(dev);\n}\n\nstatic void _rtl92e_hwconfig(struct net_device *dev)\n{\n\tu32 regRATR = 0, regRRSR = 0;\n\tu8 regBwOpMode = 0, regTmp = 0;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tswitch (priv->rtllib->mode) {\n\tcase WIRELESS_MODE_B:\n\t\tregBwOpMode = BW_OPMODE_20MHZ;\n\t\tregRATR = RATE_ALL_CCK;\n\t\tregRRSR = RATE_ALL_CCK;\n\t\tbreak;\n\tcase WIRELESS_MODE_AUTO:\n\tcase WIRELESS_MODE_N_24G:\n\t\tregBwOpMode = BW_OPMODE_20MHZ;\n\t\tregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG |\n\t\t\t  RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;\n\t\tregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\tdefault:\n\t\tregBwOpMode = BW_OPMODE_20MHZ;\n\t\tregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\n\t\tregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\n\t\tbreak;\n\t}\n\n\trtl92e_writeb(dev, BW_OPMODE, regBwOpMode);\n\t{\n\t\tu32 ratr_value;\n\n\t\tratr_value = regRATR;\n\t\tratr_value &= ~(RATE_ALL_OFDM_2SS);\n\t\trtl92e_writel(dev, RATR0, ratr_value);\n\t\trtl92e_writeb(dev, UFWP, 1);\n\t}\n\tregTmp = rtl92e_readb(dev, 0x313);\n\tregRRSR = ((regTmp) << 24) | (regRRSR & 0x00ffffff);\n\trtl92e_writel(dev, RRSR, regRRSR);\n\n\trtl92e_writew(dev, RETRY_LIMIT,\n\t\t      priv->short_retry_limit << RETRY_LIMIT_SHORT_SHIFT |\n\t\t      priv->long_retry_limit << RETRY_LIMIT_LONG_SHIFT);\n}\n\nbool rtl92e_start_adapter(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu32 ulRegRead;\n\tbool rtStatus = true;\n\tu8 tmpvalue;\n\tu8 ICVersion, SwitchingRegulatorOutput;\n\tbool bfirmwareok = true;\n\tu32 tmpRegA, TempCCk;\n\tint i = 0;\n\tu32 retry_times = 0;\n\n\tpriv->being_init_adapter = true;\n\nstart:\n\trtl92e_reset_desc_ring(dev);\n\tpriv->rf_mode = RF_OP_By_SW_3wire;\n\tif (priv->rst_progress == RESET_TYPE_NORESET) {\n\t\trtl92e_writeb(dev, ANAPAR, 0x37);\n\t\tmdelay(500);\n\t}\n\tpriv->fw_info->status = FW_STATUS_0_INIT;\n\n\tulRegRead = rtl92e_readl(dev, CPU_GEN);\n\tif (priv->fw_info->status == FW_STATUS_0_INIT)\n\t\tulRegRead |= CPU_GEN_SYSTEM_RESET;\n\telse if (priv->fw_info->status == FW_STATUS_5_READY)\n\t\tulRegRead |= CPU_GEN_FIRMWARE_RESET;\n\telse\n\t\tnetdev_err(dev, \"%s(): undefined firmware state: %d.\\n\",\n\t\t\t   __func__, priv->fw_info->status);\n\n\trtl92e_writel(dev, CPU_GEN, ulRegRead);\n\n\tICVersion = rtl92e_readb(dev, IC_VERRSION);\n\tif (ICVersion >= 0x4) {\n\t\tSwitchingRegulatorOutput = rtl92e_readb(dev, SWREGULATOR);\n\t\tif (SwitchingRegulatorOutput  != 0xb8) {\n\t\t\trtl92e_writeb(dev, SWREGULATOR, 0xa8);\n\t\t\tmdelay(1);\n\t\t\trtl92e_writeb(dev, SWREGULATOR, 0xb8);\n\t\t}\n\t}\n\trtStatus = rtl92e_config_bb(dev);\n\tif (!rtStatus) {\n\t\tnetdev_warn(dev, \"%s(): Failed to configure BB\\n\", __func__);\n\t\treturn rtStatus;\n\t}\n\n\tpriv->loopback_mode = RTL819X_NO_LOOPBACK;\n\tif (priv->rst_progress == RESET_TYPE_NORESET) {\n\t\tulRegRead = rtl92e_readl(dev, CPU_GEN);\n\t\tif (priv->loopback_mode == RTL819X_NO_LOOPBACK)\n\t\t\tulRegRead = (ulRegRead & CPU_GEN_NO_LOOPBACK_MSK) |\n\t\t\t\t    CPU_GEN_NO_LOOPBACK_SET;\n\t\telse if (priv->loopback_mode == RTL819X_MAC_LOOPBACK)\n\t\t\tulRegRead |= CPU_CCK_LOOPBACK;\n\t\telse\n\t\t\tnetdev_err(dev, \"%s: Invalid loopback mode setting.\\n\",\n\t\t\t\t   __func__);\n\n\t\trtl92e_writel(dev, CPU_GEN, ulRegRead);\n\n\t\tudelay(500);\n\t}\n\t_rtl92e_hwconfig(dev);\n\trtl92e_writeb(dev, CMDR, CR_RE | CR_TE);\n\n\trtl92e_writeb(dev, PCIF, ((MXDMA2_NO_LIMIT << MXDMA2_RX_SHIFT) |\n\t\t\t\t  (MXDMA2_NO_LIMIT << MXDMA2_TX_SHIFT)));\n\trtl92e_writel(dev, MAC0, ((u32 *)dev->dev_addr)[0]);\n\trtl92e_writew(dev, MAC4, ((u16 *)(dev->dev_addr + 4))[0]);\n\trtl92e_writel(dev, RCR, priv->receive_config);\n\n\trtl92e_writel(dev, RQPN1, NUM_OF_PAGE_IN_FW_QUEUE_BK <<\n\t\t      RSVD_FW_QUEUE_PAGE_BK_SHIFT |\n\t\t      NUM_OF_PAGE_IN_FW_QUEUE_BE <<\n\t\t      RSVD_FW_QUEUE_PAGE_BE_SHIFT |\n\t\t      NUM_OF_PAGE_IN_FW_QUEUE_VI <<\n\t\t      RSVD_FW_QUEUE_PAGE_VI_SHIFT |\n\t\t      NUM_OF_PAGE_IN_FW_QUEUE_VO <<\n\t\t      RSVD_FW_QUEUE_PAGE_VO_SHIFT);\n\trtl92e_writel(dev, RQPN2, NUM_OF_PAGE_IN_FW_QUEUE_MGNT <<\n\t\t      RSVD_FW_QUEUE_PAGE_MGNT_SHIFT);\n\trtl92e_writel(dev, RQPN3, APPLIED_RESERVED_QUEUE_IN_FW |\n\t\t      NUM_OF_PAGE_IN_FW_QUEUE_BCN <<\n\t\t      RSVD_FW_QUEUE_PAGE_BCN_SHIFT |\n\t\t      NUM_OF_PAGE_IN_FW_QUEUE_PUB <<\n\t\t      RSVD_FW_QUEUE_PAGE_PUB_SHIFT);\n\n\trtl92e_tx_enable(dev);\n\trtl92e_rx_enable(dev);\n\tulRegRead = (0xFFF00000 & rtl92e_readl(dev, RRSR))  |\n\t\t     RATE_ALL_OFDM_AG | RATE_ALL_CCK;\n\trtl92e_writel(dev, RRSR, ulRegRead);\n\trtl92e_writel(dev, RATR0 + 4 * 7, (RATE_ALL_OFDM_AG | RATE_ALL_CCK));\n\n\trtl92e_writeb(dev, ACK_TIMEOUT, 0x30);\n\n\tif (priv->rst_progress == RESET_TYPE_NORESET)\n\t\trtl92e_set_wireless_mode(dev, priv->rtllib->mode);\n\trtl92e_cam_reset(dev);\n\t{\n\t\tu8 SECR_value = 0x0;\n\n\t\tSECR_value |= SCR_TxEncEnable;\n\t\tSECR_value |= SCR_RxDecEnable;\n\t\tSECR_value |= SCR_NoSKMC;\n\t\trtl92e_writeb(dev, SECR, SECR_value);\n\t}\n\trtl92e_writew(dev, ATIMWND, 2);\n\trtl92e_writew(dev, BCN_INTERVAL, 100);\n\n\tfor (i = 0; i < QOS_QUEUE_NUM; i++)\n\t\trtl92e_writel(dev, WDCAPARA_ADD[i], 0x005e4332);\n\n\trtl92e_writeb(dev, 0xbe, 0xc0);\n\n\trtl92e_config_mac(dev);\n\n\tif (priv->card_8192_version > VERSION_8190_BD) {\n\t\trtl92e_get_tx_power(dev);\n\t\trtl92e_set_tx_power(dev, priv->chan);\n\t}\n\n\ttmpvalue = rtl92e_readb(dev, IC_VERRSION);\n\tpriv->ic_cut = tmpvalue;\n\n\tbfirmwareok = rtl92e_init_fw(dev);\n\tif (!bfirmwareok) {\n\t\tif (retry_times < 10) {\n\t\t\tretry_times++;\n\t\t\tgoto start;\n\t\t} else {\n\t\t\trtStatus = false;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (priv->rst_progress == RESET_TYPE_NORESET) {\n\t\trtStatus = rtl92e_config_rf(dev);\n\t\tif (!rtStatus) {\n\t\t\tnetdev_info(dev, \"RF Config failed\\n\");\n\t\t\treturn rtStatus;\n\t\t}\n\t}\n\n\trtl92e_set_bb_reg(dev, rFPGA0_RFMOD, bCCKEn, 0x1);\n\trtl92e_set_bb_reg(dev, rFPGA0_RFMOD, bOFDMEn, 0x1);\n\n\trtl92e_writeb(dev, 0x87, 0x0);\n\n\tif (priv->rtllib->rf_off_reason > RF_CHANGE_BY_PS) {\n\t\trtl92e_set_rf_state(dev, rf_off, priv->rtllib->rf_off_reason);\n\t} else if (priv->rtllib->rf_off_reason >= RF_CHANGE_BY_IPS) {\n\t\trtl92e_set_rf_state(dev, rf_off, priv->rtllib->rf_off_reason);\n\t} else {\n\t\tpriv->rtllib->rf_power_state = rf_on;\n\t\tpriv->rtllib->rf_off_reason = 0;\n\t}\n\n\tif (priv->rtllib->FwRWRF)\n\t\tpriv->rf_mode = RF_OP_By_FW;\n\telse\n\t\tpriv->rf_mode = RF_OP_By_SW_3wire;\n\n\tif (priv->rst_progress == RESET_TYPE_NORESET) {\n\t\trtl92e_dm_init_txpower_tracking(dev);\n\n\t\tif (priv->ic_cut >= IC_VersionCut_D) {\n\t\t\ttmpRegA = rtl92e_get_bb_reg(dev, rOFDM0_XATxIQImbalance,\n\t\t\t\t\t\t    bMaskDWord);\n\t\t\trtl92e_get_bb_reg(dev, rOFDM0_XCTxIQImbalance, bMaskDWord);\n\n\t\t\tfor (i = 0; i < TX_BB_GAIN_TABLE_LEN; i++) {\n\t\t\t\tif (tmpRegA == dm_tx_bb_gain[i]) {\n\t\t\t\t\tpriv->rfa_txpowertrackingindex = i;\n\t\t\t\t\tpriv->rfa_txpowertrackingindex_real = i;\n\t\t\t\t\tpriv->rfa_txpowertracking_default =\n\t\t\t\t\t\t priv->rfa_txpowertrackingindex;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTempCCk = rtl92e_get_bb_reg(dev, rCCK0_TxFilter1,\n\t\t\t\t\t\t    bMaskByte2);\n\n\t\t\tfor (i = 0; i < CCK_TX_BB_GAIN_TABLE_LEN; i++) {\n\t\t\t\tif (TempCCk == dm_cck_tx_bb_gain[i][0]) {\n\t\t\t\t\tpriv->cck_present_attn_20m_def = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriv->cck_present_attn_40m_def = 0;\n\t\t\tpriv->cck_present_attn_diff = 0;\n\t\t\tpriv->cck_present_attn =\n\t\t\t\t  priv->cck_present_attn_20m_def;\n\t\t\tpriv->btxpower_tracking = false;\n\t\t}\n\t}\n\trtl92e_irq_enable(dev);\nend:\n\tpriv->being_init_adapter = false;\n\treturn rtStatus;\n}\n\nstatic void _rtl92e_net_update(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_network *net;\n\tu16 BcnTimeCfg = 0, BcnCW = 6, BcnIFS = 0xf;\n\tu16 rate_config = 0;\n\n\tnet = &priv->rtllib->current_network;\n\trtl92e_config_rate(dev, &rate_config);\n\tpriv->dot11_current_preamble_mode = PREAMBLE_AUTO;\n\tpriv->basic_rate = rate_config &= 0x15f;\n\trtl92e_writew(dev, BSSIDR, *(u16 *)net->bssid);\n\trtl92e_writel(dev, BSSIDR + 2, *(u32 *)(net->bssid + 2));\n\n\tif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\n\t\trtl92e_writew(dev, ATIMWND, 2);\n\t\trtl92e_writew(dev, BCN_DMATIME, 256);\n\t\trtl92e_writew(dev, BCN_INTERVAL, net->beacon_interval);\n\t\trtl92e_writew(dev, BCN_DRV_EARLY_INT, 10);\n\t\trtl92e_writeb(dev, BCN_ERR_THRESH, 100);\n\n\t\tBcnTimeCfg |= (BcnCW << BCN_TCFG_CW_SHIFT);\n\t\tBcnTimeCfg |= BcnIFS << BCN_TCFG_IFS;\n\n\t\trtl92e_writew(dev, BCN_TCFG, BcnTimeCfg);\n\t}\n}\n\nvoid rtl92e_link_change(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\n\tif (!priv->up)\n\t\treturn;\n\n\tif (ieee->link_state == MAC80211_LINKED) {\n\t\t_rtl92e_net_update(dev);\n\t\trtl92e_update_ratr_table(dev);\n\t\tif ((ieee->pairwise_key_type == KEY_TYPE_WEP40) ||\n\t\t    (ieee->pairwise_key_type == KEY_TYPE_WEP104))\n\t\t\trtl92e_enable_hw_security_config(dev);\n\t} else {\n\t\trtl92e_writeb(dev, 0x173, 0);\n\t}\n\t_rtl92e_update_msr(dev);\n\n\tif (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC) {\n\t\tu32 reg;\n\n\t\treg = rtl92e_readl(dev, RCR);\n\t\tif (priv->rtllib->link_state == MAC80211_LINKED) {\n\t\t\tif (ieee->intel_promiscuous_md_info.promiscuous_on)\n\t\t\t\t;\n\t\t\telse\n\t\t\t\tpriv->receive_config = reg |= RCR_CBSSID;\n\t\t} else {\n\t\t\tpriv->receive_config = reg &= ~RCR_CBSSID;\n\t\t}\n\n\t\trtl92e_writel(dev, RCR, reg);\n\t}\n}\n\nvoid rtl92e_set_monitor_mode(struct net_device *dev, bool bAllowAllDA,\n\t\t\t     bool WriteIntoReg)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (bAllowAllDA)\n\t\tpriv->receive_config |= RCR_AAP;\n\telse\n\t\tpriv->receive_config &= ~RCR_AAP;\n\n\tif (WriteIntoReg)\n\t\trtl92e_writel(dev, RCR, priv->receive_config);\n}\n\nstatic u8 _rtl92e_rate_mgn_to_hw(u8 rate)\n{\n\tu8  ret = DESC90_RATE1M;\n\n\tswitch (rate) {\n\tcase MGN_1M:\n\t\tret = DESC90_RATE1M;\n\t\tbreak;\n\tcase MGN_2M:\n\t\tret = DESC90_RATE2M;\n\t\tbreak;\n\tcase MGN_5_5M:\n\t\tret = DESC90_RATE5_5M;\n\t\tbreak;\n\tcase MGN_11M:\n\t\tret = DESC90_RATE11M;\n\t\tbreak;\n\tcase MGN_6M:\n\t\tret = DESC90_RATE6M;\n\t\tbreak;\n\tcase MGN_9M:\n\t\tret = DESC90_RATE9M;\n\t\tbreak;\n\tcase MGN_12M:\n\t\tret = DESC90_RATE12M;\n\t\tbreak;\n\tcase MGN_18M:\n\t\tret = DESC90_RATE18M;\n\t\tbreak;\n\tcase MGN_24M:\n\t\tret = DESC90_RATE24M;\n\t\tbreak;\n\tcase MGN_36M:\n\t\tret = DESC90_RATE36M;\n\t\tbreak;\n\tcase MGN_48M:\n\t\tret = DESC90_RATE48M;\n\t\tbreak;\n\tcase MGN_54M:\n\t\tret = DESC90_RATE54M;\n\t\tbreak;\n\tcase MGN_MCS0:\n\t\tret = DESC90_RATEMCS0;\n\t\tbreak;\n\tcase MGN_MCS1:\n\t\tret = DESC90_RATEMCS1;\n\t\tbreak;\n\tcase MGN_MCS2:\n\t\tret = DESC90_RATEMCS2;\n\t\tbreak;\n\tcase MGN_MCS3:\n\t\tret = DESC90_RATEMCS3;\n\t\tbreak;\n\tcase MGN_MCS4:\n\t\tret = DESC90_RATEMCS4;\n\t\tbreak;\n\tcase MGN_MCS5:\n\t\tret = DESC90_RATEMCS5;\n\t\tbreak;\n\tcase MGN_MCS6:\n\t\tret = DESC90_RATEMCS6;\n\t\tbreak;\n\tcase MGN_MCS7:\n\t\tret = DESC90_RATEMCS7;\n\t\tbreak;\n\tcase MGN_MCS8:\n\t\tret = DESC90_RATEMCS8;\n\t\tbreak;\n\tcase MGN_MCS9:\n\t\tret = DESC90_RATEMCS9;\n\t\tbreak;\n\tcase MGN_MCS10:\n\t\tret = DESC90_RATEMCS10;\n\t\tbreak;\n\tcase MGN_MCS11:\n\t\tret = DESC90_RATEMCS11;\n\t\tbreak;\n\tcase MGN_MCS12:\n\t\tret = DESC90_RATEMCS12;\n\t\tbreak;\n\tcase MGN_MCS13:\n\t\tret = DESC90_RATEMCS13;\n\t\tbreak;\n\tcase MGN_MCS14:\n\t\tret = DESC90_RATEMCS14;\n\t\tbreak;\n\tcase MGN_MCS15:\n\t\tret = DESC90_RATEMCS15;\n\t\tbreak;\n\tcase (0x80 | 0x20):\n\t\tret = DESC90_RATEMCS32;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic u8 _rtl92e_hw_queue_to_fw_queue(struct net_device *dev, u8 QueueID,\n\t\t\t\t       u8 priority)\n{\n\tu8 QueueSelect = 0x0;\n\n\tswitch (QueueID) {\n\tcase BE_QUEUE:\n\t\tQueueSelect = QSLT_BE;\n\t\tbreak;\n\n\tcase BK_QUEUE:\n\t\tQueueSelect = QSLT_BK;\n\t\tbreak;\n\n\tcase VO_QUEUE:\n\t\tQueueSelect = QSLT_VO;\n\t\tbreak;\n\n\tcase VI_QUEUE:\n\t\tQueueSelect = QSLT_VI;\n\t\tbreak;\n\tcase MGNT_QUEUE:\n\t\tQueueSelect = QSLT_MGNT;\n\t\tbreak;\n\tcase BEACON_QUEUE:\n\t\tQueueSelect = QSLT_BEACON;\n\t\tbreak;\n\tcase TXCMD_QUEUE:\n\t\tQueueSelect = QSLT_CMD;\n\t\tbreak;\n\tcase HIGH_QUEUE:\n\t\tQueueSelect = QSLT_HIGH;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(dev, \"%s(): Impossible Queue Selection: %d\\n\",\n\t\t\t    __func__, QueueID);\n\t\tbreak;\n\t}\n\treturn QueueSelect;\n}\n\nstatic u8 _rtl92e_query_is_short(u8 TxHT, u8 TxRate, struct cb_desc *tcb_desc)\n{\n\tu8   tmp_Short;\n\n\ttmp_Short = (TxHT == 1) ? ((tcb_desc->bUseShortGI) ? 1 : 0) :\n\t\t\t((tcb_desc->bUseShortPreamble) ? 1 : 0);\n\tif (TxHT == 1 && TxRate != DESC90_RATEMCS15)\n\t\ttmp_Short = 0;\n\n\treturn tmp_Short;\n}\n\nvoid  rtl92e_fill_tx_desc(struct net_device *dev, struct tx_desc *pdesc,\n\t\t\t  struct cb_desc *cb_desc, struct sk_buff *skb)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tdma_addr_t mapping;\n\tstruct tx_fwinfo_8190pci *pTxFwInfo;\n\n\tpTxFwInfo = (struct tx_fwinfo_8190pci *)skb->data;\n\tmemset(pTxFwInfo, 0, sizeof(struct tx_fwinfo_8190pci));\n\tpTxFwInfo->TxHT = (cb_desc->data_rate & 0x80) ? 1 : 0;\n\tpTxFwInfo->TxRate = _rtl92e_rate_mgn_to_hw(cb_desc->data_rate);\n\tpTxFwInfo->EnableCPUDur = cb_desc->bTxEnableFwCalcDur;\n\tpTxFwInfo->Short = _rtl92e_query_is_short(pTxFwInfo->TxHT,\n\t\t\t\t\t\t  pTxFwInfo->TxRate, cb_desc);\n\n\tif (cb_desc->bAMPDUEnable) {\n\t\tpTxFwInfo->AllowAggregation = 1;\n\t\tpTxFwInfo->RxMF = cb_desc->ampdu_factor;\n\t\tpTxFwInfo->RxAMD = cb_desc->ampdu_density;\n\t} else {\n\t\tpTxFwInfo->AllowAggregation = 0;\n\t\tpTxFwInfo->RxMF = 0;\n\t\tpTxFwInfo->RxAMD = 0;\n\t}\n\n\tpTxFwInfo->RtsEnable =\t(cb_desc->bRTSEnable) ? 1 : 0;\n\tpTxFwInfo->CtsEnable = (cb_desc->bCTSEnable) ? 1 : 0;\n\tpTxFwInfo->RtsSTBC = (cb_desc->bRTSSTBC) ? 1 : 0;\n\tpTxFwInfo->RtsHT = (cb_desc->rts_rate & 0x80) ? 1 : 0;\n\tpTxFwInfo->RtsRate = _rtl92e_rate_mgn_to_hw(cb_desc->rts_rate);\n\tpTxFwInfo->RtsBandwidth = 0;\n\tpTxFwInfo->RtsSubcarrier = cb_desc->RTSSC;\n\tpTxFwInfo->RtsShort = (pTxFwInfo->RtsHT == 0) ?\n\t\t\t  (cb_desc->bRTSUseShortPreamble ? 1 : 0) :\n\t\t\t  (cb_desc->bRTSUseShortGI ? 1 : 0);\n\tif (priv->current_chnl_bw == HT_CHANNEL_WIDTH_20_40) {\n\t\tif (cb_desc->bPacketBW) {\n\t\t\tpTxFwInfo->TxBandwidth = 1;\n\t\t\tpTxFwInfo->TxSubCarrier = 0;\n\t\t} else {\n\t\t\tpTxFwInfo->TxBandwidth = 0;\n\t\t\tpTxFwInfo->TxSubCarrier = priv->n_cur_40mhz_prime_sc;\n\t\t}\n\t} else {\n\t\tpTxFwInfo->TxBandwidth = 0;\n\t\tpTxFwInfo->TxSubCarrier = 0;\n\t}\n\n\tmemset((u8 *)pdesc, 0, 12);\n\n\tmapping = dma_map_single(&priv->pdev->dev, skb->data, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\tif (dma_mapping_error(&priv->pdev->dev, mapping)) {\n\t\tnetdev_err(dev, \"%s(): DMA Mapping error\\n\", __func__);\n\t\treturn;\n\t}\n\n\tpdesc->LINIP = 0;\n\tpdesc->CmdInit = 1;\n\tpdesc->Offset = sizeof(struct tx_fwinfo_8190pci) + 8;\n\tpdesc->PktSize = skb->len - sizeof(struct tx_fwinfo_8190pci);\n\n\tpdesc->SecCAMID = 0;\n\tpdesc->RATid = cb_desc->ratr_index;\n\n\tpdesc->NoEnc = 1;\n\tpdesc->SecType = 0x0;\n\tif (cb_desc->bHwSec) {\n\t\tstatic u8 tmp;\n\n\t\tif (!tmp)\n\t\t\ttmp = 1;\n\t\tswitch (priv->rtllib->pairwise_key_type) {\n\t\tcase KEY_TYPE_WEP40:\n\t\tcase KEY_TYPE_WEP104:\n\t\t\tpdesc->SecType = 0x1;\n\t\t\tpdesc->NoEnc = 0;\n\t\t\tbreak;\n\t\tcase KEY_TYPE_TKIP:\n\t\t\tpdesc->SecType = 0x2;\n\t\t\tpdesc->NoEnc = 0;\n\t\t\tbreak;\n\t\tcase KEY_TYPE_CCMP:\n\t\t\tpdesc->SecType = 0x3;\n\t\t\tpdesc->NoEnc = 0;\n\t\t\tbreak;\n\t\tcase KEY_TYPE_NA:\n\t\t\tpdesc->SecType = 0x0;\n\t\t\tpdesc->NoEnc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpdesc->PktId = 0x0;\n\n\tpdesc->QueueSelect = _rtl92e_hw_queue_to_fw_queue(dev,\n\t\t\t\t\t\t\t  cb_desc->queue_index,\n\t\t\t\t\t\t\t  cb_desc->priority);\n\tpdesc->TxFWInfoSize = sizeof(struct tx_fwinfo_8190pci);\n\n\tpdesc->DISFB = cb_desc->tx_dis_rate_fallback;\n\tpdesc->USERATE = cb_desc->tx_use_drv_assinged_rate;\n\n\tpdesc->FirstSeg = 1;\n\tpdesc->LastSeg = 1;\n\tpdesc->TxBufferSize = skb->len;\n\n\tpdesc->TxBuffAddr = mapping;\n}\n\nvoid  rtl92e_fill_tx_cmd_desc(struct net_device *dev, struct tx_desc_cmd *entry,\n\t\t\t      struct cb_desc *cb_desc, struct sk_buff *skb)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tdma_addr_t mapping = dma_map_single(&priv->pdev->dev, skb->data,\n\t\t\t\t\t    skb->len, DMA_TO_DEVICE);\n\n\tif (dma_mapping_error(&priv->pdev->dev, mapping))\n\t\tnetdev_err(dev, \"%s(): DMA Mapping error\\n\", __func__);\n\tmemset(entry, 0, 12);\n\tentry->LINIP = cb_desc->bLastIniPkt;\n\tentry->FirstSeg = 1;\n\tentry->LastSeg = 1;\n\tif (cb_desc->bCmdOrInit == DESC_PACKET_TYPE_INIT) {\n\t\tentry->CmdInit = DESC_PACKET_TYPE_INIT;\n\t} else {\n\t\tstruct tx_desc *entry_tmp = (struct tx_desc *)entry;\n\n\t\tentry_tmp->CmdInit = DESC_PACKET_TYPE_NORMAL;\n\t\tentry_tmp->Offset = sizeof(struct tx_fwinfo_8190pci) + 8;\n\t\tentry_tmp->PktSize = cb_desc->pkt_size + entry_tmp->Offset;\n\t\tentry_tmp->QueueSelect = QSLT_CMD;\n\t\tentry_tmp->TxFWInfoSize = 0x08;\n\t\tentry_tmp->RATid = DESC_PACKET_TYPE_INIT;\n\t}\n\tentry->TxBufferSize = skb->len;\n\tentry->TxBuffAddr = mapping;\n\tentry->OWN = 1;\n}\n\nstatic u8 _rtl92e_rate_hw_to_mgn(bool bIsHT, u8 rate)\n{\n\tu8  ret_rate = 0x02;\n\n\tif (!bIsHT) {\n\t\tswitch (rate) {\n\t\tcase DESC90_RATE1M:\n\t\t\tret_rate = MGN_1M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE2M:\n\t\t\tret_rate = MGN_2M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE5_5M:\n\t\t\tret_rate = MGN_5_5M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE11M:\n\t\t\tret_rate = MGN_11M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE6M:\n\t\t\tret_rate = MGN_6M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE9M:\n\t\t\tret_rate = MGN_9M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE12M:\n\t\t\tret_rate = MGN_12M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE18M:\n\t\t\tret_rate = MGN_18M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE24M:\n\t\t\tret_rate = MGN_24M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE36M:\n\t\t\tret_rate = MGN_36M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE48M:\n\t\t\tret_rate = MGN_48M;\n\t\t\tbreak;\n\t\tcase DESC90_RATE54M:\n\t\t\tret_rate = MGN_54M;\n\t\t\tbreak;\n\t\t}\n\n\t} else {\n\t\tswitch (rate) {\n\t\tcase DESC90_RATEMCS0:\n\t\t\tret_rate = MGN_MCS0;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS1:\n\t\t\tret_rate = MGN_MCS1;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS2:\n\t\t\tret_rate = MGN_MCS2;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS3:\n\t\t\tret_rate = MGN_MCS3;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS4:\n\t\t\tret_rate = MGN_MCS4;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS5:\n\t\t\tret_rate = MGN_MCS5;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS6:\n\t\t\tret_rate = MGN_MCS6;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS7:\n\t\t\tret_rate = MGN_MCS7;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS8:\n\t\t\tret_rate = MGN_MCS8;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS9:\n\t\t\tret_rate = MGN_MCS9;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS10:\n\t\t\tret_rate = MGN_MCS10;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS11:\n\t\t\tret_rate = MGN_MCS11;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS12:\n\t\t\tret_rate = MGN_MCS12;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS13:\n\t\t\tret_rate = MGN_MCS13;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS14:\n\t\t\tret_rate = MGN_MCS14;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS15:\n\t\t\tret_rate = MGN_MCS15;\n\t\t\tbreak;\n\t\tcase DESC90_RATEMCS32:\n\t\t\tret_rate = 0x80 | 0x20;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret_rate;\n}\n\nstatic long _rtl92e_signal_scale_mapping(struct r8192_priv *priv, long currsig)\n{\n\tlong retsig;\n\n\tif (currsig >= 61 && currsig <= 100)\n\t\tretsig = 90 + ((currsig - 60) / 4);\n\telse if (currsig >= 41 && currsig <= 60)\n\t\tretsig = 78 + ((currsig - 40) / 2);\n\telse if (currsig >= 31 && currsig <= 40)\n\t\tretsig = 66 + (currsig - 30);\n\telse if (currsig >= 21 && currsig <= 30)\n\t\tretsig = 54 + (currsig - 20);\n\telse if (currsig >= 5 && currsig <= 20)\n\t\tretsig = 42 + (((currsig - 5) * 2) / 3);\n\telse if (currsig == 4)\n\t\tretsig = 36;\n\telse if (currsig == 3)\n\t\tretsig = 27;\n\telse if (currsig == 2)\n\t\tretsig = 18;\n\telse if (currsig == 1)\n\t\tretsig = 9;\n\telse\n\t\tretsig = currsig;\n\n\treturn retsig;\n}\n\n#define\t rx_hal_is_cck_rate(_pdrvinfo)\\\n\t\t\t((_pdrvinfo->RxRate == DESC90_RATE1M ||\\\n\t\t\t_pdrvinfo->RxRate == DESC90_RATE2M ||\\\n\t\t\t_pdrvinfo->RxRate == DESC90_RATE5_5M ||\\\n\t\t\t_pdrvinfo->RxRate == DESC90_RATE11M) &&\\\n\t\t\t!_pdrvinfo->RxHT)\n\nstatic void _rtl92e_query_rxphystatus(\n\tstruct r8192_priv *priv,\n\tstruct rtllib_rx_stats *pstats,\n\tstruct rx_desc  *pdesc,\n\tstruct rx_fwinfo   *pdrvinfo,\n\tstruct rtllib_rx_stats *precord_stats,\n\tbool bpacket_match_bssid,\n\tbool bpacket_toself,\n\tbool bPacketBeacon,\n\tbool bToSelfBA\n\t)\n{\n\tstruct phy_sts_ofdm_819xpci *pofdm_buf;\n\tstruct phy_sts_cck_819xpci *pcck_buf;\n\tu8 *prxpkt;\n\tu8 i, max_spatial_stream, tmp_rxevm;\n\ts8 rx_pwr[4], rx_pwr_all = 0;\n\ts8 rx_evmX;\n\tu8 evm, pwdb_all;\n\tu32 RSSI, total_rssi = 0;\n\tu8 is_cck_rate = 0;\n\tu8 rf_rx_num = 0;\n\tstatic\tu8 check_reg824;\n\tstatic\tu32 reg824_bit9;\n\n\tis_cck_rate = rx_hal_is_cck_rate(pdrvinfo);\n\tmemset(precord_stats, 0, sizeof(struct rtllib_rx_stats));\n\tpstats->bPacketMatchBSSID = precord_stats->bPacketMatchBSSID =\n\t\t\t\t    bpacket_match_bssid;\n\tpstats->bPacketToSelf = precord_stats->bPacketToSelf = bpacket_toself;\n\tpstats->bIsCCK = precord_stats->bIsCCK = is_cck_rate;\n\tpstats->bPacketBeacon = precord_stats->bPacketBeacon = bPacketBeacon;\n\tpstats->bToSelfBA = precord_stats->bToSelfBA = bToSelfBA;\n\tif (check_reg824 == 0) {\n\t\treg824_bit9 = rtl92e_get_bb_reg(priv->rtllib->dev,\n\t\t\t\t\t\trFPGA0_XA_HSSIParameter2,\n\t\t\t\t\t\t0x200);\n\t\tcheck_reg824 = 1;\n\t}\n\n\tprxpkt = (u8 *)pdrvinfo;\n\n\tprxpkt += sizeof(struct rx_fwinfo);\n\n\tpcck_buf = (struct phy_sts_cck_819xpci *)prxpkt;\n\tpofdm_buf = (struct phy_sts_ofdm_819xpci *)prxpkt;\n\n\tpstats->RxMIMOSignalQuality[0] = -1;\n\tpstats->RxMIMOSignalQuality[1] = -1;\n\tprecord_stats->RxMIMOSignalQuality[0] = -1;\n\tprecord_stats->RxMIMOSignalQuality[1] = -1;\n\n\tif (is_cck_rate) {\n\t\tu8 report;\n\n\t\tif (!reg824_bit9) {\n\t\t\treport = pcck_buf->cck_agc_rpt & 0xc0;\n\t\t\treport >>= 6;\n\t\t\tswitch (report) {\n\t\t\tcase 0x3:\n\t\t\t\trx_pwr_all = -35 - (pcck_buf->cck_agc_rpt &\n\t\t\t\t\t     0x3e);\n\t\t\t\tbreak;\n\t\t\tcase 0x2:\n\t\t\t\trx_pwr_all = -23 - (pcck_buf->cck_agc_rpt &\n\t\t\t\t\t     0x3e);\n\t\t\t\tbreak;\n\t\t\tcase 0x1:\n\t\t\t\trx_pwr_all = -11 - (pcck_buf->cck_agc_rpt &\n\t\t\t\t\t     0x3e);\n\t\t\t\tbreak;\n\t\t\tcase 0x0:\n\t\t\t\trx_pwr_all = 8 - (pcck_buf->cck_agc_rpt & 0x3e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\treport = pcck_buf->cck_agc_rpt & 0x60;\n\t\t\treport >>= 5;\n\t\t\tswitch (report) {\n\t\t\tcase 0x3:\n\t\t\t\trx_pwr_all = -35 -\n\t\t\t\t\t((pcck_buf->cck_agc_rpt &\n\t\t\t\t\t0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\tcase 0x2:\n\t\t\t\trx_pwr_all = -23 -\n\t\t\t\t\t((pcck_buf->cck_agc_rpt &\n\t\t\t\t\t 0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\tcase 0x1:\n\t\t\t\trx_pwr_all = -11 -\n\t\t\t\t\t ((pcck_buf->cck_agc_rpt &\n\t\t\t\t\t 0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\tcase 0x0:\n\t\t\t\trx_pwr_all = -8 -\n\t\t\t\t\t ((pcck_buf->cck_agc_rpt &\n\t\t\t\t\t 0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpwdb_all = rtl92e_rx_db_to_percent(rx_pwr_all);\n\t\tpstats->RxPWDBAll = precord_stats->RxPWDBAll = pwdb_all;\n\t\tpstats->RecvSignalPower = rx_pwr_all;\n\n\t\tif (bpacket_match_bssid) {\n\t\t\tu8\tsq;\n\n\t\t\tif (pstats->RxPWDBAll > 40) {\n\t\t\t\tsq = 100;\n\t\t\t} else {\n\t\t\t\tsq = pcck_buf->sq_rpt;\n\n\t\t\t\tif (pcck_buf->sq_rpt > 64)\n\t\t\t\t\tsq = 0;\n\t\t\t\telse if (pcck_buf->sq_rpt < 20)\n\t\t\t\t\tsq = 100;\n\t\t\t\telse\n\t\t\t\t\tsq = ((64 - sq) * 100) / 44;\n\t\t\t}\n\t\t\tpstats->SignalQuality = sq;\n\t\t\tprecord_stats->SignalQuality = sq;\n\t\t\tpstats->RxMIMOSignalQuality[0] = sq;\n\t\t\tprecord_stats->RxMIMOSignalQuality[0] = sq;\n\t\t\tpstats->RxMIMOSignalQuality[1] = -1;\n\t\t\tprecord_stats->RxMIMOSignalQuality[1] = -1;\n\t\t}\n\t} else {\n\t\tfor (i = RF90_PATH_A; i < RF90_PATH_MAX; i++) {\n\t\t\tif (priv->brfpath_rxenable[i])\n\t\t\t\trf_rx_num++;\n\n\t\t\trx_pwr[i] = ((pofdm_buf->trsw_gain_X[i] & 0x3F) *\n\t\t\t\t     2) - 110;\n\n\t\t\tRSSI = rtl92e_rx_db_to_percent(rx_pwr[i]);\n\t\t\tif (priv->brfpath_rxenable[i])\n\t\t\t\ttotal_rssi += RSSI;\n\n\t\t\tif (bpacket_match_bssid) {\n\t\t\t\tpstats->RxMIMOSignalStrength[i] = RSSI;\n\t\t\t\tprecord_stats->RxMIMOSignalStrength[i] = RSSI;\n\t\t\t}\n\t\t}\n\n\t\trx_pwr_all = (((pofdm_buf->pwdb_all) >> 1) & 0x7f) - 106;\n\t\tpwdb_all = rtl92e_rx_db_to_percent(rx_pwr_all);\n\n\t\tpstats->RxPWDBAll = precord_stats->RxPWDBAll = pwdb_all;\n\t\tpstats->RxPower = precord_stats->RxPower =\trx_pwr_all;\n\t\tpstats->RecvSignalPower = rx_pwr_all;\n\t\tif (pdrvinfo->RxHT && pdrvinfo->RxRate >= DESC90_RATEMCS8 &&\n\t\t    pdrvinfo->RxRate <= DESC90_RATEMCS15)\n\t\t\tmax_spatial_stream = 2;\n\t\telse\n\t\t\tmax_spatial_stream = 1;\n\n\t\tfor (i = 0; i < max_spatial_stream; i++) {\n\t\t\ttmp_rxevm = pofdm_buf->rxevm_X[i];\n\t\t\trx_evmX = (s8)(tmp_rxevm);\n\n\t\t\trx_evmX /= 2;\n\n\t\t\tevm = rtl92e_evm_db_to_percent(rx_evmX);\n\t\t\tif (bpacket_match_bssid) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tpstats->SignalQuality = evm & 0xff;\n\t\t\t\t\tprecord_stats->SignalQuality = evm & 0xff;\n\t\t\t\t}\n\t\t\t\tpstats->RxMIMOSignalQuality[i] = evm & 0xff;\n\t\t\t\tprecord_stats->RxMIMOSignalQuality[i] = evm & 0xff;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_cck_rate) {\n\t\tpstats->SignalStrength = precord_stats->SignalStrength =\n\t\t\t\t\t _rtl92e_signal_scale_mapping(priv,\n\t\t\t\t\t (long)pwdb_all);\n\n\t} else {\n\t\tif (rf_rx_num != 0)\n\t\t\tpstats->SignalStrength = precord_stats->SignalStrength =\n\t\t\t\t\t _rtl92e_signal_scale_mapping(priv,\n\t\t\t\t\t (long)(total_rssi /= rf_rx_num));\n\t}\n}\n\nstatic void _rtl92e_process_phyinfo(struct r8192_priv *priv, u8 *buffer,\n\t\t\t\t    struct rtllib_rx_stats *prev_st,\n\t\t\t\t    struct rtllib_rx_stats *curr_st)\n{\n\tbool bcheck = false;\n\tu8\trfpath;\n\tu32 ij, tmp_val;\n\tstatic u32 slide_rssi_index, slide_rssi_statistics;\n\tstatic u32 slide_evm_index, slide_evm_statistics;\n\tstatic u32 last_rssi, last_evm;\n\tstatic u32 slide_beacon_adc_pwdb_index;\n\tstatic u32 slide_beacon_adc_pwdb_statistics;\n\tstatic u32 last_beacon_adc_pwdb;\n\tstruct rtllib_hdr_3addr *hdr;\n\tu16 sc;\n\tunsigned int seq;\n\n\thdr = (struct rtllib_hdr_3addr *)buffer;\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\tseq = WLAN_GET_SEQ_SEQ(sc);\n\tcurr_st->Seq_Num = seq;\n\tif (!prev_st->bIsAMPDU)\n\t\tbcheck = true;\n\n\tif (slide_rssi_statistics++ >= PHY_RSSI_SLID_WIN_MAX) {\n\t\tslide_rssi_statistics = PHY_RSSI_SLID_WIN_MAX;\n\t\tlast_rssi = priv->stats.slide_signal_strength[slide_rssi_index];\n\t\tpriv->stats.slide_rssi_total -= last_rssi;\n\t}\n\tpriv->stats.slide_rssi_total += prev_st->SignalStrength;\n\n\tpriv->stats.slide_signal_strength[slide_rssi_index++] =\n\t\t\t\t\t prev_st->SignalStrength;\n\tif (slide_rssi_index >= PHY_RSSI_SLID_WIN_MAX)\n\t\tslide_rssi_index = 0;\n\n\ttmp_val = priv->stats.slide_rssi_total / slide_rssi_statistics;\n\tpriv->stats.signal_strength = rtl92e_translate_to_dbm(priv, tmp_val);\n\tcurr_st->rssi = priv->stats.signal_strength;\n\tif (!prev_st->bPacketMatchBSSID) {\n\t\tif (!prev_st->bToSelfBA)\n\t\t\treturn;\n\t}\n\n\tif (!bcheck)\n\t\treturn;\n\n\tif (!prev_st->bIsCCK && prev_st->bPacketToSelf) {\n\t\tfor (rfpath = RF90_PATH_A; rfpath < priv->num_total_rf_path; rfpath++) {\n\t\t\tif (priv->stats.rx_rssi_percentage[rfpath] == 0) {\n\t\t\t\tpriv->stats.rx_rssi_percentage[rfpath] =\n\t\t\t\t\t prev_st->RxMIMOSignalStrength[rfpath];\n\t\t\t}\n\t\t\tif (prev_st->RxMIMOSignalStrength[rfpath]  >\n\t\t\t    priv->stats.rx_rssi_percentage[rfpath]) {\n\t\t\t\tpriv->stats.rx_rssi_percentage[rfpath] =\n\t\t\t\t\t((priv->stats.rx_rssi_percentage[rfpath]\n\t\t\t\t\t* (RX_SMOOTH - 1)) +\n\t\t\t\t\t(prev_st->RxMIMOSignalStrength\n\t\t\t\t\t[rfpath])) / (RX_SMOOTH);\n\t\t\t\tpriv->stats.rx_rssi_percentage[rfpath] =\n\t\t\t\t\t priv->stats.rx_rssi_percentage[rfpath]\n\t\t\t\t\t + 1;\n\t\t\t} else {\n\t\t\t\tpriv->stats.rx_rssi_percentage[rfpath] =\n\t\t\t\t   ((priv->stats.rx_rssi_percentage[rfpath] *\n\t\t\t\t   (RX_SMOOTH - 1)) +\n\t\t\t\t   (prev_st->RxMIMOSignalStrength[rfpath])) /\n\t\t\t\t   (RX_SMOOTH);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (prev_st->bPacketBeacon) {\n\t\tif (slide_beacon_adc_pwdb_statistics++ >=\n\t\t    PHY_Beacon_RSSI_SLID_WIN_MAX) {\n\t\t\tslide_beacon_adc_pwdb_statistics =\n\t\t\t\t\t PHY_Beacon_RSSI_SLID_WIN_MAX;\n\t\t\tlast_beacon_adc_pwdb = priv->stats.slide_beacon_pwdb\n\t\t\t\t\t       [slide_beacon_adc_pwdb_index];\n\t\t\tpriv->stats.slide_beacon_total -= last_beacon_adc_pwdb;\n\t\t}\n\t\tpriv->stats.slide_beacon_total += prev_st->RxPWDBAll;\n\t\tpriv->stats.slide_beacon_pwdb[slide_beacon_adc_pwdb_index] =\n\t\t\t\t\t\t\t prev_st->RxPWDBAll;\n\t\tslide_beacon_adc_pwdb_index++;\n\t\tif (slide_beacon_adc_pwdb_index >= PHY_Beacon_RSSI_SLID_WIN_MAX)\n\t\t\tslide_beacon_adc_pwdb_index = 0;\n\t\tprev_st->RxPWDBAll = priv->stats.slide_beacon_total /\n\t\t\t\t     slide_beacon_adc_pwdb_statistics;\n\t\tif (prev_st->RxPWDBAll >= 3)\n\t\t\tprev_st->RxPWDBAll -= 3;\n\t}\n\tif (prev_st->bPacketToSelf || prev_st->bPacketBeacon ||\n\t    prev_st->bToSelfBA) {\n\t\tif (priv->undecorated_smoothed_pwdb < 0)\n\t\t\tpriv->undecorated_smoothed_pwdb = prev_st->RxPWDBAll;\n\t\tif (prev_st->RxPWDBAll > (u32)priv->undecorated_smoothed_pwdb) {\n\t\t\tpriv->undecorated_smoothed_pwdb =\n\t\t\t\t\t(((priv->undecorated_smoothed_pwdb) *\n\t\t\t\t\t(RX_SMOOTH - 1)) +\n\t\t\t\t\t(prev_st->RxPWDBAll)) / (RX_SMOOTH);\n\t\t\tpriv->undecorated_smoothed_pwdb =\n\t\t\t\t\t priv->undecorated_smoothed_pwdb + 1;\n\t\t} else {\n\t\t\tpriv->undecorated_smoothed_pwdb =\n\t\t\t\t\t(((priv->undecorated_smoothed_pwdb) *\n\t\t\t\t\t(RX_SMOOTH - 1)) +\n\t\t\t\t\t(prev_st->RxPWDBAll)) / (RX_SMOOTH);\n\t\t}\n\t\trtl92e_update_rx_statistics(priv, prev_st);\n\t}\n\n\tif (prev_st->SignalQuality != 0) {\n\t\tif (prev_st->bPacketToSelf || prev_st->bPacketBeacon ||\n\t\t    prev_st->bToSelfBA) {\n\t\t\tif (slide_evm_statistics++ >= PHY_RSSI_SLID_WIN_MAX) {\n\t\t\t\tslide_evm_statistics = PHY_RSSI_SLID_WIN_MAX;\n\t\t\t\tlast_evm =\n\t\t\t\t\t priv->stats.slide_evm[slide_evm_index];\n\t\t\t\tpriv->stats.slide_evm_total -= last_evm;\n\t\t\t}\n\n\t\t\tpriv->stats.slide_evm_total += prev_st->SignalQuality;\n\n\t\t\tpriv->stats.slide_evm[slide_evm_index++] =\n\t\t\t\t\t\t prev_st->SignalQuality;\n\t\t\tif (slide_evm_index >= PHY_RSSI_SLID_WIN_MAX)\n\t\t\t\tslide_evm_index = 0;\n\n\t\t\ttmp_val = priv->stats.slide_evm_total /\n\t\t\t\t  slide_evm_statistics;\n\t\t\tpriv->stats.last_signal_strength_inpercent = tmp_val;\n\t\t}\n\n\t\tif (prev_st->bPacketToSelf ||\n\t\t    prev_st->bPacketBeacon ||\n\t\t    prev_st->bToSelfBA) {\n\t\t\tfor (ij = 0; ij < 2; ij++) {\n\t\t\t\tif (prev_st->RxMIMOSignalQuality[ij] != -1) {\n\t\t\t\t\tif (priv->stats.rx_evm_percentage[ij] == 0)\n\t\t\t\t\t\tpriv->stats.rx_evm_percentage[ij] =\n\t\t\t\t\t\t   prev_st->RxMIMOSignalQuality[ij];\n\t\t\t\t\tpriv->stats.rx_evm_percentage[ij] =\n\t\t\t\t\t  ((priv->stats.rx_evm_percentage[ij] *\n\t\t\t\t\t  (RX_SMOOTH - 1)) +\n\t\t\t\t\t  (prev_st->RxMIMOSignalQuality[ij])) /\n\t\t\t\t\t  (RX_SMOOTH);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void _rtl92e_translate_rx_signal_stats(struct net_device *dev,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct rtllib_rx_stats *pstats,\n\t\t\t\t\t      struct rx_desc *pdesc,\n\t\t\t\t\t      struct rx_fwinfo *pdrvinfo)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\n\tbool bpacket_match_bssid, bpacket_toself;\n\tbool bPacketBeacon = false;\n\tstruct rtllib_hdr_3addr *hdr;\n\tbool bToSelfBA = false;\n\tstatic struct rtllib_rx_stats  previous_stats;\n\tu16 fc, type;\n\tu8 *tmp_buf;\n\tu8 *praddr;\n\n\ttmp_buf = skb->data + pstats->RxDrvInfoSize + pstats->RxBufShift;\n\n\thdr = (struct rtllib_hdr_3addr *)tmp_buf;\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tpraddr = hdr->addr1;\n\n\tbpacket_match_bssid =\n\t\t((type != RTLLIB_FTYPE_CTL) &&\n\t\t ether_addr_equal(priv->rtllib->current_network.bssid,\n\t\t\t\t  (fc & RTLLIB_FCTL_TODS) ? hdr->addr1 :\n\t\t\t\t  (fc & RTLLIB_FCTL_FROMDS) ? hdr->addr2 :\n\t\t\t\t  hdr->addr3) &&\n\t\t (!pstats->bHwError) && (!pstats->bCRC) && (!pstats->bICV));\n\tbpacket_toself = bpacket_match_bssid &&\t\t \n\t\t\t ether_addr_equal(praddr, priv->rtllib->dev->dev_addr);\n\tif (WLAN_FC_GET_FRAMETYPE(fc) == RTLLIB_STYPE_BEACON)\n\t\tbPacketBeacon = true;\n\t_rtl92e_process_phyinfo(priv, tmp_buf, &previous_stats, pstats);\n\t_rtl92e_query_rxphystatus(priv, pstats, pdesc, pdrvinfo,\n\t\t\t\t  &previous_stats, bpacket_match_bssid,\n\t\t\t\t  bpacket_toself, bPacketBeacon, bToSelfBA);\n\trtl92e_copy_mpdu_stats(pstats, &previous_stats);\n}\n\nstatic void _rtl92e_update_received_rate_histogram_stats(\n\t\t\t\t\t   struct net_device *dev,\n\t\t\t\t\t   struct rtllib_rx_stats *pstats)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\n\tu32 rcvType = 1;\n\tu32 rateIndex;\n\n\tif (pstats->bCRC)\n\t\trcvType = 2;\n\telse if (pstats->bICV)\n\t\trcvType = 3;\n\n\tswitch (pstats->rate) {\n\tcase MGN_1M:\n\t\trateIndex = 0;\n\t\tbreak;\n\tcase MGN_2M:\n\t\trateIndex = 1;\n\t\tbreak;\n\tcase MGN_5_5M:\n\t\trateIndex = 2;\n\t\tbreak;\n\tcase MGN_11M:\n\t\trateIndex = 3;\n\t\tbreak;\n\tcase MGN_6M:\n\t\trateIndex = 4;\n\t\tbreak;\n\tcase MGN_9M:\n\t\trateIndex = 5;\n\t\tbreak;\n\tcase MGN_12M:\n\t\trateIndex = 6;\n\t\tbreak;\n\tcase MGN_18M:\n\t\trateIndex = 7;\n\t\tbreak;\n\tcase MGN_24M:\n\t\trateIndex = 8;\n\t\tbreak;\n\tcase MGN_36M:\n\t\trateIndex = 9;\n\t\tbreak;\n\tcase MGN_48M:\n\t\trateIndex = 10;\n\t\tbreak;\n\tcase MGN_54M:\n\t\trateIndex = 11;\n\t\tbreak;\n\tcase MGN_MCS0:\n\t\trateIndex = 12;\n\t\tbreak;\n\tcase MGN_MCS1:\n\t\trateIndex = 13;\n\t\tbreak;\n\tcase MGN_MCS2:\n\t\trateIndex = 14;\n\t\tbreak;\n\tcase MGN_MCS3:\n\t\trateIndex = 15;\n\t\tbreak;\n\tcase MGN_MCS4:\n\t\trateIndex = 16;\n\t\tbreak;\n\tcase MGN_MCS5:\n\t\trateIndex = 17;\n\t\tbreak;\n\tcase MGN_MCS6:\n\t\trateIndex = 18;\n\t\tbreak;\n\tcase MGN_MCS7:\n\t\trateIndex = 19;\n\t\tbreak;\n\tcase MGN_MCS8:\n\t\trateIndex = 20;\n\t\tbreak;\n\tcase MGN_MCS9:\n\t\trateIndex = 21;\n\t\tbreak;\n\tcase MGN_MCS10:\n\t\trateIndex = 22;\n\t\tbreak;\n\tcase MGN_MCS11:\n\t\trateIndex = 23;\n\t\tbreak;\n\tcase MGN_MCS12:\n\t\trateIndex = 24;\n\t\tbreak;\n\tcase MGN_MCS13:\n\t\trateIndex = 25;\n\t\tbreak;\n\tcase MGN_MCS14:\n\t\trateIndex = 26;\n\t\tbreak;\n\tcase MGN_MCS15:\n\t\trateIndex = 27;\n\t\tbreak;\n\tdefault:\n\t\trateIndex = 28;\n\t\tbreak;\n\t}\n\tpriv->stats.received_rate_histogram[0][rateIndex]++;\n\tpriv->stats.received_rate_histogram[rcvType][rateIndex]++;\n}\n\nbool rtl92e_get_rx_stats(struct net_device *dev, struct rtllib_rx_stats *stats,\n\t\t\t struct rx_desc *pdesc, struct sk_buff *skb)\n{\n\tstruct rx_fwinfo *pDrvInfo = NULL;\n\n\tstats->bICV = pdesc->ICV;\n\tstats->bCRC = pdesc->CRC32;\n\tstats->bHwError = pdesc->CRC32 | pdesc->ICV;\n\n\tstats->Length = pdesc->Length;\n\tif (stats->Length < 24)\n\t\tstats->bHwError |= 1;\n\n\tif (stats->bHwError) {\n\t\tstats->bShift = false;\n\t\treturn false;\n\t}\n\n\tstats->RxDrvInfoSize = pdesc->RxDrvInfoSize;\n\tstats->RxBufShift = (pdesc->Shift) & 0x03;\n\tstats->Decrypted = !pdesc->SWDec;\n\n\tpDrvInfo = (struct rx_fwinfo *)(skb->data + stats->RxBufShift);\n\n\tstats->rate = _rtl92e_rate_hw_to_mgn((bool)pDrvInfo->RxHT,\n\t\t\t\t\t     pDrvInfo->RxRate);\n\tstats->bShortPreamble = pDrvInfo->SPLCP;\n\n\t_rtl92e_update_received_rate_histogram_stats(dev, stats);\n\n\tstats->bIsAMPDU = (pDrvInfo->PartAggr == 1);\n\tstats->bFirstMPDU = (pDrvInfo->PartAggr == 1) &&\n\t\t\t    (pDrvInfo->FirstAGGR == 1);\n\n\tstats->TimeStampLow = pDrvInfo->TSFL;\n\tstats->TimeStampHigh = rtl92e_readl(dev, TSFR + 4);\n\n\trtl92e_update_rx_pkt_timestamp(dev, stats);\n\n\tif ((stats->RxBufShift + stats->RxDrvInfoSize) > 0)\n\t\tstats->bShift = 1;\n\n\tstats->RxIs40MHzPacket = pDrvInfo->BW;\n\n\t_rtl92e_translate_rx_signal_stats(dev, skb, stats, pdesc, pDrvInfo);\n\tskb_trim(skb, skb->len - S_CRC_LEN);\n\n\n\tstats->packetlength = stats->Length - 4;\n\tstats->fraglength = stats->packetlength;\n\tstats->fragoffset = 0;\n\tstats->ntotalfrag = 1;\n\treturn true;\n}\n\nvoid rtl92e_stop_adapter(struct net_device *dev, bool reset)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tint i;\n\tu8\tOpMode;\n\tu8\tu1bTmp;\n\tu32\tulRegRead;\n\n\tOpMode = RT_OP_MODE_NO_LINK;\n\tpriv->rtllib->SetHwRegHandler(dev, HW_VAR_MEDIA_STATUS, &OpMode);\n\n\tif (!priv->rtllib->bSupportRemoteWakeUp) {\n\t\tu1bTmp = 0x0;\n\t\trtl92e_writeb(dev, CMDR, u1bTmp);\n\t}\n\n\tmdelay(20);\n\n\tif (!reset) {\n\t\tmdelay(150);\n\n\t\tpriv->hw_rf_off_action = 2;\n\n\t\tif (!priv->rtllib->bSupportRemoteWakeUp) {\n\t\t\trtl92e_set_rf_off(dev);\n\t\t\tulRegRead = rtl92e_readl(dev, CPU_GEN);\n\t\t\tulRegRead |= CPU_GEN_SYSTEM_RESET;\n\t\t\trtl92e_writel(dev, CPU_GEN, ulRegRead);\n\t\t} else {\n\t\t\trtl92e_writel(dev, WFCRC0, 0xffffffff);\n\t\t\trtl92e_writel(dev, WFCRC1, 0xffffffff);\n\t\t\trtl92e_writel(dev, WFCRC2, 0xffffffff);\n\n\t\t\trtl92e_writeb(dev, PMR, 0x5);\n\t\t\trtl92e_writeb(dev, MAC_BLK_CTRL, 0xa);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_QUEUE_SIZE; i++)\n\t\tskb_queue_purge(&priv->rtllib->skb_waitQ[i]);\n\n\tskb_queue_purge(&priv->skb_queue);\n}\n\nvoid rtl92e_update_ratr_table(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\tu8 *pMcsRate = ieee->dot11ht_oper_rate_set;\n\tu32 ratr_value = 0;\n\tu16 rate_config = 0;\n\tu8 rate_index = 0;\n\n\trtl92e_config_rate(dev, &rate_config);\n\tratr_value = rate_config | *pMcsRate << 12;\n\tswitch (ieee->mode) {\n\tcase WIRELESS_MODE_B:\n\t\tratr_value &= 0x0000000F;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\tcase WIRELESS_MODE_G | WIRELESS_MODE_B:\n\t\tratr_value &= 0x00000FF7;\n\t\tbreak;\n\tcase WIRELESS_MODE_N_24G:\n\t\tif (ieee->ht_info->peer_mimo_ps == 0)\n\t\t\tratr_value &= 0x0007F007;\n\t\telse\n\t\t\tratr_value &= 0x000FF007;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tratr_value &= 0x0FFFFFFF;\n\tif (ieee->ht_info->cur_tx_bw40mhz &&\n\t    ieee->ht_info->bCurShortGI40MHz)\n\t\tratr_value |= 0x80000000;\n\telse if (!ieee->ht_info->cur_tx_bw40mhz &&\n\t\t  ieee->ht_info->bCurShortGI20MHz)\n\t\tratr_value |= 0x80000000;\n\trtl92e_writel(dev, RATR0 + rate_index * 4, ratr_value);\n\trtl92e_writeb(dev, UFWP, 1);\n}\n\nvoid\nrtl92e_init_variables(struct net_device  *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tstrscpy(priv->nick, \"rtl8192E\", sizeof(priv->nick));\n\n\tpriv->rtllib->softmac_features  = IEEE_SOFTMAC_SCAN |\n\t\tIEEE_SOFTMAC_ASSOCIATE | IEEE_SOFTMAC_PROBERQ |\n\t\tIEEE_SOFTMAC_PROBERS | IEEE_SOFTMAC_TX_QUEUE;\n\n\tpriv->rtllib->tx_headroom = sizeof(struct tx_fwinfo_8190pci);\n\n\tpriv->short_retry_limit = 0x30;\n\tpriv->long_retry_limit = 0x30;\n\n\tpriv->receive_config = RCR_ADD3\t|\n\t\tRCR_AMF | RCR_ADF |\n\t\tRCR_AICV |\n\t\tRCR_AB | RCR_AM | RCR_APM |\n\t\tRCR_AAP | ((u32)7 << RCR_MXDMA_OFFSET) |\n\t\t((u32)7 << RCR_FIFO_OFFSET) | RCR_ONLYERLPKT;\n\n\tpriv->irq_mask[0] = (u32)(IMR_ROK | IMR_VODOK | IMR_VIDOK |\n\t\t\t    IMR_BEDOK | IMR_BKDOK | IMR_HCCADOK |\n\t\t\t    IMR_MGNTDOK | IMR_COMDOK | IMR_HIGHDOK |\n\t\t\t    IMR_BDOK | IMR_RXCMDOK | IMR_TIMEOUT0 |\n\t\t\t    IMR_RDU | IMR_RXFOVW | IMR_TXFOVW |\n\t\t\t    IMR_BcnInt | IMR_TBDOK | IMR_TBDER);\n\n\tpriv->bfirst_after_down = false;\n}\n\nvoid rtl92e_enable_irq(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\n\n\tpriv->irq_enabled = 1;\n\n\trtl92e_writel(dev, INTA_MASK, priv->irq_mask[0]);\n}\n\nvoid rtl92e_disable_irq(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\n\n\trtl92e_writel(dev, INTA_MASK, 0);\n\n\tpriv->irq_enabled = 0;\n}\n\nvoid rtl92e_enable_rx(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\n\n\trtl92e_writel(dev, RDQDA, priv->rx_ring_dma[RX_MPDU_QUEUE]);\n}\n\nstatic const u32 TX_DESC_BASE[] = {\n\tBKQDA, BEQDA, VIQDA, VOQDA, HCCAQDA, CQDA, MQDA, HQDA, BQDA\n};\n\nvoid rtl92e_enable_tx(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\n\tu32 i;\n\n\tfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++)\n\t\trtl92e_writel(dev, TX_DESC_BASE[i], priv->tx_ring[i].dma);\n}\n\nvoid rtl92e_ack_irq(struct net_device *dev, u32 *p_inta)\n{\n\t*p_inta = rtl92e_readl(dev, ISR);\n\trtl92e_writel(dev, ISR, *p_inta);\n}\n\nbool rtl92e_is_rx_stuck(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu16\t\t  RegRxCounter = rtl92e_readw(dev, 0x130);\n\tbool\t\t  bStuck = false;\n\tstatic u8\t  rx_chk_cnt;\n\tu32\t\tSlotIndex = 0, TotalRxStuckCount = 0;\n\tu8\t\ti;\n\tu8\t\tSilentResetRxSoltNum = 4;\n\n\trx_chk_cnt++;\n\tif (priv->undecorated_smoothed_pwdb >= (RATE_ADAPTIVE_TH_HIGH + 5)) {\n\t\trx_chk_cnt = 0;\n\t} else if ((priv->undecorated_smoothed_pwdb < (RATE_ADAPTIVE_TH_HIGH + 5))\n\t  && (((priv->current_chnl_bw != HT_CHANNEL_WIDTH_20) &&\n\t  (priv->undecorated_smoothed_pwdb >= RATE_ADAPTIVE_TH_LOW_40M))\n\t  || ((priv->current_chnl_bw == HT_CHANNEL_WIDTH_20) &&\n\t  (priv->undecorated_smoothed_pwdb >= RATE_ADAPTIVE_TH_LOW_20M)))) {\n\t\tif (rx_chk_cnt < 2)\n\t\t\treturn bStuck;\n\t\trx_chk_cnt = 0;\n\t} else if ((((priv->current_chnl_bw != HT_CHANNEL_WIDTH_20) &&\n\t\t  (priv->undecorated_smoothed_pwdb < RATE_ADAPTIVE_TH_LOW_40M)) ||\n\t\t((priv->current_chnl_bw == HT_CHANNEL_WIDTH_20) &&\n\t\t (priv->undecorated_smoothed_pwdb < RATE_ADAPTIVE_TH_LOW_20M))) &&\n\t\tpriv->undecorated_smoothed_pwdb >= VERY_LOW_RSSI) {\n\t\tif (rx_chk_cnt < 4)\n\t\t\treturn bStuck;\n\t\trx_chk_cnt = 0;\n\t} else {\n\t\tif (rx_chk_cnt < 8)\n\t\t\treturn bStuck;\n\t\trx_chk_cnt = 0;\n\t}\n\n\n\tSlotIndex = (priv->silent_reset_rx_slot_index++) % SilentResetRxSoltNum;\n\n\tif (priv->rx_ctr == RegRxCounter) {\n\t\tpriv->silent_reset_rx_stuck_event[SlotIndex] = 1;\n\n\t\tfor (i = 0; i < SilentResetRxSoltNum; i++)\n\t\t\tTotalRxStuckCount += priv->silent_reset_rx_stuck_event[i];\n\n\t\tif (TotalRxStuckCount == SilentResetRxSoltNum) {\n\t\t\tbStuck = true;\n\t\t\tfor (i = 0; i < SilentResetRxSoltNum; i++)\n\t\t\t\tTotalRxStuckCount +=\n\t\t\t\t\t priv->silent_reset_rx_stuck_event[i];\n\t\t}\n\t} else {\n\t\tpriv->silent_reset_rx_stuck_event[SlotIndex] = 0;\n\t}\n\n\tpriv->rx_ctr = RegRxCounter;\n\n\treturn bStuck;\n}\n\nbool rtl92e_is_tx_stuck(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tbool\tbStuck = false;\n\tu16\tRegTxCounter = rtl92e_readw(dev, 0x128);\n\n\tif (priv->tx_counter == RegTxCounter)\n\t\tbStuck = true;\n\n\tpriv->tx_counter = RegTxCounter;\n\n\treturn bStuck;\n}\n\nbool rtl92e_get_nmode_support_by_sec(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\n\tif (ieee->rtllib_ap_sec_type &&\n\t   (ieee->rtllib_ap_sec_type(priv->rtllib) & (SEC_ALG_WEP |\n\t\t\t\t     SEC_ALG_TKIP))) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\nbool rtl92e_is_halfn_supported_by_ap(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\n\treturn ieee->bHalfWirelessN24GMode;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}