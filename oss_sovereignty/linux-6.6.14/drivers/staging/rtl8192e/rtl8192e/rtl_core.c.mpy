{
  "module_name": "rtl_core.c",
  "hash_id": "34a59feba23ac45bd6d9580880a8108833a6c3354d36dfa960c5c2e0d962ffee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtl8192e/rtl_core.c",
  "human_readable_source": "\n \n#include <linux/uaccess.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/ieee80211.h>\n#include \"rtl_core.h\"\n#include \"r8192E_phy.h\"\n#include \"r8192E_phyreg.h\"\n#include \"r8190P_rtl8256.h\"\n#include \"r8192E_cmdpkt.h\"\n\n#include \"rtl_wx.h\"\n#include \"rtl_dm.h\"\n\n#include \"rtl_pm.h\"\n\nint hwwep = 1;\nstatic char *ifname = \"wlan%d\";\n\nstatic struct pci_device_id rtl8192_pci_id_tbl[] = {\n\t{PCI_DEVICE(0x10ec, 0x8192)},\n\t{PCI_DEVICE(0x07aa, 0x0044)},\n\t{PCI_DEVICE(0x07aa, 0x0047)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, rtl8192_pci_id_tbl);\n\nstatic int _rtl92e_pci_probe(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *id);\nstatic void _rtl92e_pci_disconnect(struct pci_dev *pdev);\nstatic irqreturn_t _rtl92e_irq(int irq, void *netdev);\n\nstatic SIMPLE_DEV_PM_OPS(rtl92e_pm_ops, rtl92e_suspend, rtl92e_resume);\n\nstatic struct pci_driver rtl8192_pci_driver = {\n\t.name = DRV_NAME,\t \n\t.id_table = rtl8192_pci_id_tbl,\t \n\t.probe\t= _rtl92e_pci_probe,\t \n\t.remove\t = _rtl92e_pci_disconnect,\t \n\t.driver.pm = &rtl92e_pm_ops,\n};\n\nstatic short _rtl92e_is_tx_queue_empty(struct net_device *dev);\nstatic void _rtl92e_watchdog_wq_cb(void *data);\nstatic void _rtl92e_watchdog_timer_cb(struct timer_list *t);\nstatic void _rtl92e_hard_data_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t   int rate);\nstatic int _rtl92e_hard_start_xmit(struct sk_buff *skb, struct net_device *dev);\nstatic void _rtl92e_tx_cmd(struct net_device *dev, struct sk_buff *skb);\nstatic short _rtl92e_tx(struct net_device *dev, struct sk_buff *skb);\nstatic short _rtl92e_pci_initdescring(struct net_device *dev);\nstatic void _rtl92e_irq_tx_tasklet(struct tasklet_struct *t);\nstatic void _rtl92e_irq_rx_tasklet(struct tasklet_struct *t);\nstatic void _rtl92e_cancel_deferred_work(struct r8192_priv *priv);\nstatic int _rtl92e_up(struct net_device *dev, bool is_silent_reset);\nstatic int _rtl92e_try_up(struct net_device *dev);\nstatic int _rtl92e_down(struct net_device *dev, bool shutdownrf);\nstatic void _rtl92e_restart(void *data);\n\n \n\nu8 rtl92e_readb(struct net_device *dev, int x)\n{\n\treturn 0xff & readb((u8 __iomem *)dev->mem_start + x);\n}\n\nu32 rtl92e_readl(struct net_device *dev, int x)\n{\n\treturn readl((u8 __iomem *)dev->mem_start + x);\n}\n\nu16 rtl92e_readw(struct net_device *dev, int x)\n{\n\treturn readw((u8 __iomem *)dev->mem_start + x);\n}\n\nvoid rtl92e_writeb(struct net_device *dev, int x, u8 y)\n{\n\twriteb(y, (u8 __iomem *)dev->mem_start + x);\n\n\tudelay(20);\n}\n\nvoid rtl92e_writel(struct net_device *dev, int x, u32 y)\n{\n\twritel(y, (u8 __iomem *)dev->mem_start + x);\n\n\tudelay(20);\n}\n\nvoid rtl92e_writew(struct net_device *dev, int x, u16 y)\n{\n\twritew(y, (u8 __iomem *)dev->mem_start + x);\n\n\tudelay(20);\n}\n\n \nbool rtl92e_set_rf_state(struct net_device *dev,\n\t\t\t enum rt_rf_power_state state_to_set,\n\t\t\t RT_RF_CHANGE_SOURCE change_source)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\tbool action_allowed = false;\n\tbool connect_by_ssid = false;\n\tenum rt_rf_power_state rt_state;\n\tu16 rf_wait_counter = 0;\n\tunsigned long flag;\n\n\twhile (true) {\n\t\tspin_lock_irqsave(&priv->rf_ps_lock, flag);\n\t\tif (priv->rf_change_in_progress) {\n\t\t\tspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\n\n\t\t\twhile (priv->rf_change_in_progress) {\n\t\t\t\trf_wait_counter++;\n\t\t\t\tmdelay(1);\n\n\t\t\t\tif (rf_wait_counter > 100) {\n\t\t\t\t\tnetdev_warn(dev,\n\t\t\t\t\t\t    \"%s(): Timeout waiting for RF change.\\n\",\n\t\t\t\t\t\t    __func__);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tpriv->rf_change_in_progress = true;\n\t\t\tspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trt_state = priv->rtllib->rf_power_state;\n\n\tswitch (state_to_set) {\n\tcase rf_on:\n\t\tpriv->rtllib->rf_off_reason &= (~change_source);\n\n\t\tif ((change_source == RF_CHANGE_BY_HW) && priv->hw_radio_off)\n\t\t\tpriv->hw_radio_off = false;\n\n\t\tif (!priv->rtllib->rf_off_reason) {\n\t\t\tpriv->rtllib->rf_off_reason = 0;\n\t\t\taction_allowed = true;\n\n\t\t\tif (rt_state == rf_off &&\n\t\t\t    change_source >= RF_CHANGE_BY_HW)\n\t\t\t\tconnect_by_ssid = true;\n\t\t}\n\t\tbreak;\n\n\tcase rf_off:\n\n\t\tif ((priv->rtllib->iw_mode == IW_MODE_INFRA) ||\n\t\t    (priv->rtllib->iw_mode == IW_MODE_ADHOC)) {\n\t\t\tif ((priv->rtllib->rf_off_reason > RF_CHANGE_BY_IPS) ||\n\t\t\t    (change_source > RF_CHANGE_BY_IPS)) {\n\t\t\t\tif (ieee->link_state == MAC80211_LINKED)\n\t\t\t\t\tpriv->blinked_ingpio = true;\n\t\t\t\telse\n\t\t\t\t\tpriv->blinked_ingpio = false;\n\t\t\t\trtllib_MgntDisconnect(priv->rtllib,\n\t\t\t\t\t\t      WLAN_REASON_DISASSOC_STA_HAS_LEFT);\n\t\t\t}\n\t\t}\n\t\tif ((change_source == RF_CHANGE_BY_HW) && !priv->hw_radio_off)\n\t\t\tpriv->hw_radio_off = true;\n\t\tpriv->rtllib->rf_off_reason |= change_source;\n\t\taction_allowed = true;\n\t\tbreak;\n\n\tcase rf_sleep:\n\t\tpriv->rtllib->rf_off_reason |= change_source;\n\t\taction_allowed = true;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (action_allowed) {\n\t\trtl92e_set_rf_power_state(dev, state_to_set);\n\t\tif (state_to_set == rf_on) {\n\t\t\tif (connect_by_ssid && priv->blinked_ingpio) {\n\t\t\t\tschedule_delayed_work(\n\t\t\t\t\t &ieee->associate_procedure_wq, 0);\n\t\t\t\tpriv->blinked_ingpio = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&priv->rf_ps_lock, flag);\n\tpriv->rf_change_in_progress = false;\n\tspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\n\treturn action_allowed;\n}\n\nstatic short _rtl92e_check_nic_enough_desc(struct net_device *dev, int prio)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtl8192_tx_ring *ring = &priv->tx_ring[prio];\n\n\tif (ring->entries - skb_queue_len(&ring->queue) >= 2)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void _rtl92e_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tschedule_work(&priv->reset_wq);\n\tnetdev_info(dev, \"TXTIMEOUT\");\n}\n\nvoid rtl92e_irq_enable(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tpriv->irq_enabled = 1;\n\n\trtl92e_enable_irq(dev);\n}\n\nvoid rtl92e_irq_disable(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\trtl92e_disable_irq(dev);\n\n\tpriv->irq_enabled = 0;\n}\n\nstatic void _rtl92e_set_chan(struct net_device *dev, short ch)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tpriv->chan = ch;\n\n\tif (priv->rf_set_chan)\n\t\tpriv->rf_set_chan(dev, priv->chan);\n}\n\nstatic void _rtl92e_update_cap(struct net_device *dev, u16 cap)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_network *net = &priv->rtllib->current_network;\n\tbool\t\tShortPreamble;\n\n\tif (cap & WLAN_CAPABILITY_SHORT_PREAMBLE) {\n\t\tif (priv->dot11_current_preamble_mode != PREAMBLE_SHORT) {\n\t\t\tShortPreamble = true;\n\t\t\tpriv->dot11_current_preamble_mode = PREAMBLE_SHORT;\n\t\t\tpriv->rtllib->SetHwRegHandler(dev, HW_VAR_ACK_PREAMBLE,\n\t\t\t\t\t(unsigned char *)&ShortPreamble);\n\t\t}\n\t} else {\n\t\tif (priv->dot11_current_preamble_mode != PREAMBLE_LONG) {\n\t\t\tShortPreamble = false;\n\t\t\tpriv->dot11_current_preamble_mode = PREAMBLE_LONG;\n\t\t\tpriv->rtllib->SetHwRegHandler(dev, HW_VAR_ACK_PREAMBLE,\n\t\t\t\t\t      (unsigned char *)&ShortPreamble);\n\t\t}\n\t}\n\n\tif (net->mode & (WIRELESS_MODE_G | WIRELESS_MODE_N_24G)) {\n\t\tu8\tslot_time_val;\n\t\tu8\tcur_slot_time = priv->slot_time;\n\n\t\tif ((cap & WLAN_CAPABILITY_SHORT_SLOT_TIME) &&\n\t\t   (!priv->rtllib->ht_info->current_rt2rt_long_slot_time)) {\n\t\t\tif (cur_slot_time != SHORT_SLOT_TIME) {\n\t\t\t\tslot_time_val = SHORT_SLOT_TIME;\n\t\t\t\tpriv->rtllib->SetHwRegHandler(dev,\n\t\t\t\t\t HW_VAR_SLOT_TIME, &slot_time_val);\n\t\t\t}\n\t\t} else {\n\t\t\tif (cur_slot_time != NON_SHORT_SLOT_TIME) {\n\t\t\t\tslot_time_val = NON_SHORT_SLOT_TIME;\n\t\t\t\tpriv->rtllib->SetHwRegHandler(dev,\n\t\t\t\t\t HW_VAR_SLOT_TIME, &slot_time_val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const struct rtllib_qos_parameters def_qos_parameters = {\n\t{cpu_to_le16(3), cpu_to_le16(3), cpu_to_le16(3), cpu_to_le16(3)},\n\t{cpu_to_le16(7), cpu_to_le16(7), cpu_to_le16(7), cpu_to_le16(7)},\n\t{2, 2, 2, 2},\n\t{0, 0, 0, 0},\n\t{0, 0, 0, 0}\n};\n\nstatic void _rtl92e_update_beacon(void *data)\n{\n\tstruct r8192_priv *priv = container_of(data, struct r8192_priv, update_beacon_wq.work);\n\tstruct net_device *dev = priv->rtllib->dev;\n\tstruct rtllib_device *ieee = priv->rtllib;\n\tstruct rtllib_network *net = &ieee->current_network;\n\n\tif (ieee->ht_info->bCurrentHTSupport)\n\t\tHT_update_self_and_peer_setting(ieee, net);\n\tieee->ht_info->current_rt2rt_long_slot_time = net->bssht.bd_rt2rt_long_slot_time;\n\tieee->ht_info->RT2RT_HT_Mode = net->bssht.rt2rt_ht_mode;\n\t_rtl92e_update_cap(dev, net->capability);\n}\n\nstatic void _rtl92e_qos_activate(void *data)\n{\n\tstruct r8192_priv *priv = container_of(data, struct r8192_priv, qos_activate);\n\tstruct net_device *dev = priv->rtllib->dev;\n\tint i;\n\n\tmutex_lock(&priv->mutex);\n\tif (priv->rtllib->link_state != MAC80211_LINKED)\n\t\tgoto success;\n\n\tfor (i = 0; i <  QOS_QUEUE_NUM; i++)\n\t\tpriv->rtllib->SetHwRegHandler(dev, HW_VAR_AC_PARAM, (u8 *)(&i));\n\nsuccess:\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int _rtl92e_qos_handle_probe_response(struct r8192_priv *priv,\n\t\t\t\t\t     int active_network,\n\t\t\t\t\t     struct rtllib_network *network)\n{\n\tint ret = 0;\n\tu32 size = sizeof(struct rtllib_qos_parameters);\n\n\tif (priv->rtllib->link_state != MAC80211_LINKED)\n\t\treturn ret;\n\n\tif (priv->rtllib->iw_mode != IW_MODE_INFRA)\n\t\treturn ret;\n\n\tif (network->flags & NETWORK_HAS_QOS_MASK) {\n\t\tif (active_network &&\n\t\t\t\t(network->flags & NETWORK_HAS_QOS_PARAMETERS))\n\t\t\tnetwork->qos_data.active = network->qos_data.supported;\n\n\t\tif ((network->qos_data.active == 1) && (active_network == 1) &&\n\t\t\t\t(network->flags & NETWORK_HAS_QOS_PARAMETERS) &&\n\t\t\t\t(network->qos_data.old_param_count !=\n\t\t\t\tnetwork->qos_data.param_count)) {\n\t\t\tnetwork->qos_data.old_param_count =\n\t\t\t\tnetwork->qos_data.param_count;\n\t\t\tpriv->rtllib->wmm_acm = network->qos_data.wmm_acm;\n\t\t\tschedule_work(&priv->qos_activate);\n\t\t}\n\t} else {\n\t\tmemcpy(&priv->rtllib->current_network.qos_data.parameters,\n\t\t       &def_qos_parameters, size);\n\n\t\tif ((network->qos_data.active == 1) && (active_network == 1))\n\t\t\tschedule_work(&priv->qos_activate);\n\n\t\tnetwork->qos_data.active = 0;\n\t\tnetwork->qos_data.supported = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int _rtl92e_handle_beacon(struct net_device *dev,\n\t\t\t\t struct rtllib_beacon *beacon,\n\t\t\t\t struct rtllib_network *network)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\t_rtl92e_qos_handle_probe_response(priv, 1, network);\n\n\tschedule_delayed_work(&priv->update_beacon_wq, 0);\n\treturn 0;\n}\n\nstatic int _rtl92e_qos_assoc_resp(struct r8192_priv *priv,\n\t\t\t\t  struct rtllib_network *network)\n{\n\tunsigned long flags;\n\tu32 size = sizeof(struct rtllib_qos_parameters);\n\tint set_qos_param = 0;\n\n\tif (!priv || !network)\n\t\treturn 0;\n\n\tif (priv->rtllib->link_state != MAC80211_LINKED)\n\t\treturn 0;\n\n\tif (priv->rtllib->iw_mode != IW_MODE_INFRA)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&priv->rtllib->lock, flags);\n\tif (network->flags & NETWORK_HAS_QOS_PARAMETERS) {\n\t\tmemcpy(&priv->rtllib->current_network.qos_data.parameters,\n\t\t       &network->qos_data.parameters,\n\t\t       sizeof(struct rtllib_qos_parameters));\n\t\tpriv->rtllib->current_network.qos_data.active = 1;\n\t\tpriv->rtllib->wmm_acm = network->qos_data.wmm_acm;\n\t\tset_qos_param = 1;\n\t\tpriv->rtllib->current_network.qos_data.old_param_count =\n\t\t\tpriv->rtllib->current_network.qos_data.param_count;\n\t\tpriv->rtllib->current_network.qos_data.param_count =\n\t\t\tnetwork->qos_data.param_count;\n\t} else {\n\t\tmemcpy(&priv->rtllib->current_network.qos_data.parameters,\n\t\t&def_qos_parameters, size);\n\t\tpriv->rtllib->current_network.qos_data.active = 0;\n\t\tpriv->rtllib->current_network.qos_data.supported = 0;\n\t\tset_qos_param = 1;\n\t}\n\n\tspin_unlock_irqrestore(&priv->rtllib->lock, flags);\n\n\tif (set_qos_param == 1) {\n\t\trtl92e_dm_init_edca_turbo(priv->rtllib->dev);\n\t\tschedule_work(&priv->qos_activate);\n\t}\n\treturn 0;\n}\n\nstatic int _rtl92e_handle_assoc_response(struct net_device *dev,\n\t\t\t\t struct rtllib_assoc_response_frame *resp,\n\t\t\t\t struct rtllib_network *network)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\t_rtl92e_qos_assoc_resp(priv, network);\n\treturn 0;\n}\n\nstatic void _rtl92e_prepare_beacon(struct tasklet_struct *t)\n{\n\tstruct r8192_priv *priv = from_tasklet(priv, t,\n\t\t\t\t\t       irq_prepare_beacon_tasklet);\n\tstruct net_device *dev = priv->rtllib->dev;\n\tstruct sk_buff *pskb = NULL, *pnewskb = NULL;\n\tstruct cb_desc *tcb_desc = NULL;\n\tstruct rtl8192_tx_ring *ring = NULL;\n\tstruct tx_desc *pdesc = NULL;\n\n\tring = &priv->tx_ring[BEACON_QUEUE];\n\tpskb = __skb_dequeue(&ring->queue);\n\tkfree_skb(pskb);\n\n\tpnewskb = rtllib_get_beacon(priv->rtllib);\n\tif (!pnewskb)\n\t\treturn;\n\n\ttcb_desc = (struct cb_desc *)(pnewskb->cb + 8);\n\ttcb_desc->queue_index = BEACON_QUEUE;\n\ttcb_desc->data_rate = 2;\n\ttcb_desc->ratr_index = 7;\n\ttcb_desc->tx_dis_rate_fallback = 1;\n\ttcb_desc->tx_use_drv_assinged_rate = 1;\n\tskb_push(pnewskb, priv->rtllib->tx_headroom);\n\n\tpdesc = &ring->desc[0];\n\trtl92e_fill_tx_desc(dev, pdesc, tcb_desc, pnewskb);\n\t__skb_queue_tail(&ring->queue, pnewskb);\n\tpdesc->OWN = 1;\n}\n\nstatic void _rtl92e_stop_beacon(struct net_device *dev)\n{\n}\n\nvoid rtl92e_config_rate(struct net_device *dev, u16 *rate_config)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_network *net;\n\tu8 i = 0, basic_rate = 0;\n\n\tnet = &priv->rtllib->current_network;\n\n\tfor (i = 0; i < net->rates_len; i++) {\n\t\tbasic_rate = net->rates[i] & 0x7f;\n\t\tswitch (basic_rate) {\n\t\tcase MGN_1M:\n\t\t\t*rate_config |= RRSR_1M;\n\t\t\tbreak;\n\t\tcase MGN_2M:\n\t\t\t*rate_config |= RRSR_2M;\n\t\t\tbreak;\n\t\tcase MGN_5_5M:\n\t\t\t*rate_config |= RRSR_5_5M;\n\t\t\tbreak;\n\t\tcase MGN_11M:\n\t\t\t*rate_config |= RRSR_11M;\n\t\t\tbreak;\n\t\tcase MGN_6M:\n\t\t\t*rate_config |= RRSR_6M;\n\t\t\tbreak;\n\t\tcase MGN_9M:\n\t\t\t*rate_config |= RRSR_9M;\n\t\t\tbreak;\n\t\tcase MGN_12M:\n\t\t\t*rate_config |= RRSR_12M;\n\t\t\tbreak;\n\t\tcase MGN_18M:\n\t\t\t*rate_config |= RRSR_18M;\n\t\t\tbreak;\n\t\tcase MGN_24M:\n\t\t\t*rate_config |= RRSR_24M;\n\t\t\tbreak;\n\t\tcase MGN_36M:\n\t\t\t*rate_config |= RRSR_36M;\n\t\t\tbreak;\n\t\tcase MGN_48M:\n\t\t\t*rate_config |= RRSR_48M;\n\t\t\tbreak;\n\t\tcase MGN_54M:\n\t\t\t*rate_config |= RRSR_54M;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < net->rates_ex_len; i++) {\n\t\tbasic_rate = net->rates_ex[i] & 0x7f;\n\t\tswitch (basic_rate) {\n\t\tcase MGN_1M:\n\t\t\t*rate_config |= RRSR_1M;\n\t\t\tbreak;\n\t\tcase MGN_2M:\n\t\t\t*rate_config |= RRSR_2M;\n\t\t\tbreak;\n\t\tcase MGN_5_5M:\n\t\t\t*rate_config |= RRSR_5_5M;\n\t\t\tbreak;\n\t\tcase MGN_11M:\n\t\t\t*rate_config |= RRSR_11M;\n\t\t\tbreak;\n\t\tcase MGN_6M:\n\t\t\t*rate_config |= RRSR_6M;\n\t\t\tbreak;\n\t\tcase MGN_9M:\n\t\t\t*rate_config |= RRSR_9M;\n\t\t\tbreak;\n\t\tcase MGN_12M:\n\t\t\t*rate_config |= RRSR_12M;\n\t\t\tbreak;\n\t\tcase MGN_18M:\n\t\t\t*rate_config |= RRSR_18M;\n\t\t\tbreak;\n\t\tcase MGN_24M:\n\t\t\t*rate_config |= RRSR_24M;\n\t\t\tbreak;\n\t\tcase MGN_36M:\n\t\t\t*rate_config |= RRSR_36M;\n\t\t\tbreak;\n\t\tcase MGN_48M:\n\t\t\t*rate_config |= RRSR_48M;\n\t\t\tbreak;\n\t\tcase MGN_54M:\n\t\t\t*rate_config |= RRSR_54M;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void _rtl92e_refresh_support_rate(struct r8192_priv *priv)\n{\n\tstruct rtllib_device *ieee = priv->rtllib;\n\n\tif (ieee->mode == WIRELESS_MODE_N_24G) {\n\t\tmemcpy(ieee->reg_dot11ht_oper_rate_set,\n\t\t       ieee->reg_ht_supp_rate_set, 16);\n\t\tmemcpy(ieee->reg_dot11tx_ht_oper_rate_set,\n\t\t       ieee->reg_ht_supp_rate_set, 16);\n\n\t} else {\n\t\tmemset(ieee->reg_dot11ht_oper_rate_set, 0, 16);\n\t}\n}\n\nvoid rtl92e_set_wireless_mode(struct net_device *dev, u8 wireless_mode)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8 support_mode = (WIRELESS_MODE_N_24G | WIRELESS_MODE_G | WIRELESS_MODE_B);\n\n\tif ((wireless_mode == WIRELESS_MODE_AUTO) || ((wireless_mode & support_mode) == 0))\n\t\twireless_mode = WIRELESS_MODE_N_24G;\n\n\tif ((wireless_mode & (WIRELESS_MODE_B | WIRELESS_MODE_G)) ==\n\t    (WIRELESS_MODE_G | WIRELESS_MODE_B))\n\t\twireless_mode = WIRELESS_MODE_G;\n\n\tpriv->rtllib->mode = wireless_mode;\n\n\tif (wireless_mode == WIRELESS_MODE_N_24G)\n\t\tpriv->rtllib->ht_info->enable_ht = 1;\n\telse\n\t\tpriv->rtllib->ht_info->enable_ht = 0;\n\n\t_rtl92e_refresh_support_rate(priv);\n}\n\nstatic int _rtl92e_sta_up(struct net_device *dev, bool is_silent_reset)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_pwr_save_ctrl *psc = (struct rt_pwr_save_ctrl *)\n\t\t\t\t\t(&priv->rtllib->pwr_save_ctrl);\n\tbool init_status;\n\n\tpriv->up = 1;\n\tpriv->rtllib->ieee_up = 1;\n\n\tpriv->up_first_time = 0;\n\tinit_status = rtl92e_start_adapter(dev);\n\tif (!init_status) {\n\t\tnetdev_err(dev, \"%s(): Initialization failed!\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tRT_CLEAR_PS_LEVEL(psc, RT_RF_OFF_LEVL_HALT_NIC);\n\n\tif (priv->polling_timer_on == 0)\n\t\trtl92e_check_rfctrl_gpio_timer(&priv->gpio_polling_timer);\n\n\tif (priv->rtllib->link_state != MAC80211_LINKED)\n\t\trtllib_softmac_start_protocol(priv->rtllib, 0);\n\trtllib_reset_queue(priv->rtllib);\n\t_rtl92e_watchdog_timer_cb(&priv->watch_dog_timer);\n\n\tif (!netif_queue_stopped(dev))\n\t\tnetif_start_queue(dev);\n\telse\n\t\tnetif_wake_queue(dev);\n\n\tpriv->bfirst_after_down = false;\n\treturn 0;\n}\n\nstatic int _rtl92e_sta_down(struct net_device *dev, bool shutdownrf)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tunsigned long flags = 0;\n\tu8 rf_in_progress_timeout = 0;\n\n\tif (priv->up == 0)\n\t\treturn -1;\n\n\tpriv->rtllib->rtllib_ips_leave(dev);\n\n\tif (priv->rtllib->link_state == MAC80211_LINKED)\n\t\trtl92e_leisure_ps_leave(dev);\n\n\tpriv->up = 0;\n\tpriv->rtllib->ieee_up = 0;\n\tpriv->bfirst_after_down = true;\n\tif (!netif_queue_stopped(dev))\n\t\tnetif_stop_queue(dev);\n\n\tpriv->rtllib->wpa_ie_len = 0;\n\tkfree(priv->rtllib->wpa_ie);\n\tpriv->rtllib->wpa_ie = NULL;\n\trtl92e_cam_reset(dev);\n\tmemset(priv->rtllib->swcamtable, 0, sizeof(struct sw_cam_table) * 32);\n\trtl92e_irq_disable(dev);\n\n\tdel_timer_sync(&priv->watch_dog_timer);\n\t_rtl92e_cancel_deferred_work(priv);\n\tcancel_delayed_work(&priv->rtllib->hw_wakeup_wq);\n\n\trtllib_softmac_stop_protocol(priv->rtllib, 0, true);\n\tspin_lock_irqsave(&priv->rf_ps_lock, flags);\n\twhile (priv->rf_change_in_progress) {\n\t\tspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\n\t\tif (rf_in_progress_timeout > 100) {\n\t\t\tspin_lock_irqsave(&priv->rf_ps_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tmdelay(1);\n\t\trf_in_progress_timeout++;\n\t\tspin_lock_irqsave(&priv->rf_ps_lock, flags);\n\t}\n\tpriv->rf_change_in_progress = true;\n\tspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\n\trtl92e_stop_adapter(dev, false);\n\tspin_lock_irqsave(&priv->rf_ps_lock, flags);\n\tpriv->rf_change_in_progress = false;\n\tspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\n\tudelay(100);\n\tmemset(&priv->rtllib->current_network, 0,\n\t       offsetof(struct rtllib_network, list));\n\n\treturn 0;\n}\n\nstatic void _rtl92e_init_priv_handler(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tpriv->rtllib->softmac_hard_start_xmit\t= _rtl92e_hard_start_xmit;\n\tpriv->rtllib->set_chan\t\t\t= _rtl92e_set_chan;\n\tpriv->rtllib->link_change\t\t= rtl92e_link_change;\n\tpriv->rtllib->softmac_data_hard_start_xmit = _rtl92e_hard_data_xmit;\n\tpriv->rtllib->check_nic_enough_desc\t= _rtl92e_check_nic_enough_desc;\n\tpriv->rtllib->handle_assoc_response\t= _rtl92e_handle_assoc_response;\n\tpriv->rtllib->handle_beacon\t\t= _rtl92e_handle_beacon;\n\tpriv->rtllib->set_wireless_mode\t\t= rtl92e_set_wireless_mode;\n\tpriv->rtllib->leisure_ps_leave\t\t= rtl92e_leisure_ps_leave;\n\tpriv->rtllib->set_bw_mode_handler\t= rtl92e_set_bw_mode;\n\tpriv->rf_set_chan\t\t\t= rtl92e_set_channel;\n\n\tpriv->rtllib->start_send_beacons = rtl92e_start_beacon;\n\tpriv->rtllib->stop_send_beacons = _rtl92e_stop_beacon;\n\n\tpriv->rtllib->sta_wake_up = rtl92e_hw_wakeup;\n\tpriv->rtllib->enter_sleep_state = rtl92e_enter_sleep;\n\tpriv->rtllib->ps_is_queue_empty = _rtl92e_is_tx_queue_empty;\n\n\tpriv->rtllib->GetNmodeSupportBySecCfg = rtl92e_get_nmode_support_by_sec;\n\tpriv->rtllib->GetHalfNmodeSupportByAPsHandler =\n\t\t\t\t\t\trtl92e_is_halfn_supported_by_ap;\n\n\tpriv->rtllib->SetHwRegHandler = rtl92e_set_reg;\n\tpriv->rtllib->AllowAllDestAddrHandler = rtl92e_set_monitor_mode;\n\tpriv->rtllib->init_gain_handler = rtl92e_init_gain;\n\tpriv->rtllib->rtllib_ips_leave_wq = rtl92e_rtllib_ips_leave_wq;\n\tpriv->rtllib->rtllib_ips_leave = rtl92e_rtllib_ips_leave;\n\tpriv->rtllib->ScanOperationBackupHandler = rtl92e_scan_op_backup;\n}\n\nstatic void _rtl92e_init_priv_constant(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_pwr_save_ctrl *psc = (struct rt_pwr_save_ctrl *)\n\t\t\t\t\t&priv->rtllib->pwr_save_ctrl;\n\n\tpsc->reg_max_lps_awake_intvl = 5;\n}\n\nstatic void _rtl92e_init_priv_variable(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8 i;\n\n\tpriv->dot11_current_preamble_mode = PREAMBLE_AUTO;\n\tpriv->rtllib->status = 0;\n\tpriv->polling_timer_on = 0;\n\tpriv->up_first_time = 1;\n\tpriv->blinked_ingpio = false;\n\tpriv->being_init_adapter = false;\n\tpriv->txringcount = 64;\n\tpriv->rxbuffersize = 9100;\n\tpriv->rxringcount = MAX_RX_COUNT;\n\tpriv->irq_enabled = 0;\n\tpriv->chan = 1;\n\tpriv->rtllib->mode = WIRELESS_MODE_AUTO;\n\tpriv->rtllib->iw_mode = IW_MODE_INFRA;\n\tpriv->rtllib->net_promiscuous_md = false;\n\tpriv->rtllib->intel_promiscuous_md_info.promiscuous_on = false;\n\tpriv->rtllib->intel_promiscuous_md_info.fltr_src_sta_frame =\n\t\t\t\t\t\t\t\t false;\n\tpriv->rtllib->ieee_up = 0;\n\tpriv->retry_rts = DEFAULT_RETRY_RTS;\n\tpriv->retry_data = DEFAULT_RETRY_DATA;\n\tpriv->rtllib->rts = DEFAULT_RTS_THRESHOLD;\n\tpriv->rtllib->rate = 110;\n\tpriv->promisc = (dev->flags & IFF_PROMISC) ? 1 : 0;\n\tpriv->bcck_in_ch14 = false;\n\tpriv->cck_present_attn = 0;\n\tpriv->rfa_txpowertrackingindex = 0;\n\tpriv->rfc_txpowertrackingindex = 0;\n\tpriv->cck_pwr_enl = 6;\n\tpriv->rst_progress = RESET_TYPE_NORESET;\n\tpriv->force_reset = false;\n\tmemset(priv->rtllib->swcamtable, 0, sizeof(struct sw_cam_table) * 32);\n\tpriv->rx_ctr = 0;\n\tpriv->rtllib->wx_set_enc = 0;\n\tpriv->hw_radio_off = false;\n\tpriv->rtllib->rf_off_reason = 0;\n\tpriv->rf_change_in_progress = false;\n\tpriv->hw_rf_off_action = 0;\n\tpriv->set_rf_pwr_state_in_progress = false;\n\tpriv->rtllib->pwr_save_ctrl.bLeisurePs = true;\n\tpriv->rtllib->LPSDelayCnt = 0;\n\tpriv->rtllib->sta_sleep = LPS_IS_WAKE;\n\tpriv->rtllib->rf_power_state = rf_on;\n\n\tpriv->rtllib->current_network.beacon_interval = DEFAULT_BEACONINTERVAL;\n\tpriv->rtllib->iw_mode = IW_MODE_INFRA;\n\tpriv->rtllib->active_scan = 1;\n\tpriv->rtllib->be_scan_inprogress = false;\n\n\tpriv->rtllib->fts = DEFAULT_FRAG_THRESHOLD;\n\n\tpriv->fw_info = vzalloc(sizeof(struct rt_firmware));\n\tif (!priv->fw_info)\n\t\tnetdev_err(dev,\n\t\t\t   \"rtl8192e: Unable to allocate space for firmware\\n\");\n\n\tskb_queue_head_init(&priv->skb_queue);\n\n\tfor (i = 0; i < MAX_QUEUE_SIZE; i++)\n\t\tskb_queue_head_init(&priv->rtllib->skb_waitQ[i]);\n}\n\nstatic void _rtl92e_init_priv_lock(struct r8192_priv *priv)\n{\n\tspin_lock_init(&priv->tx_lock);\n\tspin_lock_init(&priv->irq_th_lock);\n\tspin_lock_init(&priv->rf_ps_lock);\n\tspin_lock_init(&priv->ps_lock);\n\tmutex_init(&priv->wx_mutex);\n\tmutex_init(&priv->rf_mutex);\n\tmutex_init(&priv->mutex);\n}\n\nstatic void _rtl92e_init_priv_task(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tINIT_WORK(&priv->reset_wq, (void *)_rtl92e_restart);\n\tINIT_WORK(&priv->rtllib->ips_leave_wq, (void *)rtl92e_ips_leave_wq);\n\tINIT_DELAYED_WORK(&priv->watch_dog_wq, (void *)_rtl92e_watchdog_wq_cb);\n\tINIT_DELAYED_WORK(&priv->txpower_tracking_wq, (void *)rtl92e_dm_txpower_tracking_wq);\n\tINIT_DELAYED_WORK(&priv->rfpath_check_wq, (void *)rtl92e_dm_rf_pathcheck_wq);\n\tINIT_DELAYED_WORK(&priv->update_beacon_wq, (void *)_rtl92e_update_beacon);\n\tINIT_WORK(&priv->qos_activate, (void *)_rtl92e_qos_activate);\n\tINIT_DELAYED_WORK(&priv->rtllib->hw_wakeup_wq, (void *)rtl92e_hw_wakeup_wq);\n\tINIT_DELAYED_WORK(&priv->rtllib->hw_sleep_wq, (void *)rtl92e_hw_sleep_wq);\n\ttasklet_setup(&priv->irq_rx_tasklet, _rtl92e_irq_rx_tasklet);\n\ttasklet_setup(&priv->irq_tx_tasklet, _rtl92e_irq_tx_tasklet);\n\ttasklet_setup(&priv->irq_prepare_beacon_tasklet,\n\t\t      _rtl92e_prepare_beacon);\n}\n\nstatic short _rtl92e_get_channel_map(struct net_device *dev)\n{\n\tint i;\n\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->chnl_plan >= COUNTRY_CODE_MAX) {\n\t\tnetdev_info(dev,\n\t\t\t    \"rtl819x_init:Error channel plan! Set to default.\\n\");\n\t\tpriv->chnl_plan = COUNTRY_CODE_FCC;\n\t}\n\tdot11d_init(priv->rtllib);\n\tdot11d_channel_map(priv->chnl_plan, priv->rtllib);\n\tfor (i = 1; i <= 11; i++)\n\t\t(priv->rtllib->active_channel_map)[i] = 1;\n\t(priv->rtllib->active_channel_map)[12] = 2;\n\t(priv->rtllib->active_channel_map)[13] = 2;\n\n\treturn 0;\n}\n\nstatic short _rtl92e_init(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tmemset(&priv->stats, 0, sizeof(struct rt_stats));\n\n\t_rtl92e_init_priv_handler(dev);\n\t_rtl92e_init_priv_constant(dev);\n\t_rtl92e_init_priv_variable(dev);\n\t_rtl92e_init_priv_lock(priv);\n\t_rtl92e_init_priv_task(dev);\n\trtl92e_get_eeprom_size(dev);\n\trtl92e_init_variables(dev);\n\t_rtl92e_get_channel_map(dev);\n\n\trtl92e_dm_init(dev);\n\n\ttimer_setup(&priv->watch_dog_timer, _rtl92e_watchdog_timer_cb, 0);\n\n\ttimer_setup(&priv->gpio_polling_timer, rtl92e_check_rfctrl_gpio_timer,\n\t\t    0);\n\n\trtl92e_irq_disable(dev);\n\tif (request_irq(dev->irq, _rtl92e_irq, IRQF_SHARED, dev->name, dev)) {\n\t\tnetdev_err(dev, \"Error allocating IRQ %d\", dev->irq);\n\t\treturn -1;\n\t}\n\n\tpriv->irq = dev->irq;\n\n\tif (_rtl92e_pci_initdescring(dev) != 0) {\n\t\tnetdev_err(dev, \"Endopoints initialization failed\");\n\t\tfree_irq(dev->irq, dev);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic short _rtl92e_is_tx_queue_empty(struct net_device *dev)\n{\n\tint i = 0;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tfor (i = 0; i <= MGNT_QUEUE; i++) {\n\t\tif ((i == TXCMD_QUEUE) || (i == HCCA_QUEUE))\n\t\t\tcontinue;\n\t\tif (skb_queue_len(&(&priv->tx_ring[i])->queue) > 0) {\n\t\t\tnetdev_info(dev, \"===>tx queue is not empty:%d, %d\\n\",\n\t\t\t       i, skb_queue_len(&(&priv->tx_ring[i])->queue));\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic enum reset_type _rtl92e_tx_check_stuck(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8\tQueueID;\n\tbool\tbCheckFwTxCnt = false;\n\tstruct rtl8192_tx_ring  *ring = NULL;\n\tstruct sk_buff *skb = NULL;\n\tstruct cb_desc *tcb_desc = NULL;\n\tunsigned long flags = 0;\n\n\tswitch (priv->rtllib->ps) {\n\tcase RTLLIB_PS_DISABLED:\n\t\tbreak;\n\tcase (RTLLIB_PS_MBCAST | RTLLIB_PS_UNICAST):\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_lock_irqsave(&priv->irq_th_lock, flags);\n\tfor (QueueID = 0; QueueID < MAX_TX_QUEUE; QueueID++) {\n\t\tif (QueueID == TXCMD_QUEUE)\n\t\t\tcontinue;\n\n\t\tif (QueueID == BEACON_QUEUE)\n\t\t\tcontinue;\n\n\t\tring = &priv->tx_ring[QueueID];\n\n\t\tif (skb_queue_len(&ring->queue) == 0) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tskb = __skb_peek(&ring->queue);\n\t\t\ttcb_desc = (struct cb_desc *)(skb->cb +\n\t\t\t\t    MAX_DEV_ADDR_SIZE);\n\t\t\ttcb_desc->nStuckCount++;\n\t\t\tbCheckFwTxCnt = true;\n\t\t\tif (tcb_desc->nStuckCount > 1)\n\t\t\t\tnetdev_info(dev,\n\t\t\t\t\t    \"%s: QueueID=%d tcb_desc->nStuckCount=%d\\n\",\n\t\t\t\t\t    __func__, QueueID,\n\t\t\t\t\t    tcb_desc->nStuckCount);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->irq_th_lock, flags);\n\n\tif (bCheckFwTxCnt) {\n\t\tif (rtl92e_is_tx_stuck(dev))\n\t\t\treturn RESET_TYPE_SILENT;\n\t}\n\n\treturn RESET_TYPE_NORESET;\n}\n\nstatic enum reset_type _rtl92e_rx_check_stuck(struct net_device *dev)\n{\n\tif (rtl92e_is_rx_stuck(dev))\n\t\treturn RESET_TYPE_SILENT;\n\n\treturn RESET_TYPE_NORESET;\n}\n\nstatic enum reset_type _rtl92e_if_check_reset(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tenum reset_type TxResetType = RESET_TYPE_NORESET;\n\tenum reset_type RxResetType = RESET_TYPE_NORESET;\n\tenum rt_rf_power_state rfState;\n\n\trfState = priv->rtllib->rf_power_state;\n\n\tif (rfState == rf_on)\n\t\tTxResetType = _rtl92e_tx_check_stuck(dev);\n\n\tif (rfState == rf_on &&\n\t    (priv->rtllib->iw_mode == IW_MODE_INFRA) &&\n\t    (priv->rtllib->link_state == MAC80211_LINKED))\n\t\tRxResetType = _rtl92e_rx_check_stuck(dev);\n\n\tif (TxResetType == RESET_TYPE_NORMAL ||\n\t    RxResetType == RESET_TYPE_NORMAL) {\n\t\tnetdev_info(dev, \"%s(): TxResetType is %d, RxResetType is %d\\n\",\n\t\t\t    __func__, TxResetType, RxResetType);\n\t\treturn RESET_TYPE_NORMAL;\n\t} else if (TxResetType == RESET_TYPE_SILENT ||\n\t\t   RxResetType == RESET_TYPE_SILENT) {\n\t\tnetdev_info(dev, \"%s(): TxResetType is %d, RxResetType is %d\\n\",\n\t\t\t    __func__, TxResetType, RxResetType);\n\t\treturn RESET_TYPE_SILENT;\n\t} else {\n\t\treturn RESET_TYPE_NORESET;\n\t}\n}\n\nstatic void _rtl92e_if_silent_reset(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tu8\treset_times = 0;\n\tint reset_status = 0;\n\tstruct rtllib_device *ieee = priv->rtllib;\n\tunsigned long flag;\n\n\tif (priv->rst_progress == RESET_TYPE_NORESET) {\n\t\tpriv->rst_progress = RESET_TYPE_SILENT;\n\n\t\tspin_lock_irqsave(&priv->rf_ps_lock, flag);\n\t\tif (priv->rf_change_in_progress) {\n\t\t\tspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\n\t\t\tgoto END;\n\t\t}\n\t\tpriv->rf_change_in_progress = true;\n\t\tpriv->reset_in_progress = true;\n\t\tspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\n\nRESET_START:\n\n\t\tmutex_lock(&priv->wx_mutex);\n\n\t\tif (priv->rtllib->link_state == MAC80211_LINKED)\n\t\t\trtl92e_leisure_ps_leave(dev);\n\n\t\tif (priv->up) {\n\t\t\tnetdev_info(dev, \"%s():the driver is not up.\\n\",\n\t\t\t\t    __func__);\n\t\t\tmutex_unlock(&priv->wx_mutex);\n\t\t\treturn;\n\t\t}\n\t\tpriv->up = 0;\n\n\t\tmdelay(1000);\n\n\t\tif (!netif_queue_stopped(dev))\n\t\t\tnetif_stop_queue(dev);\n\n\t\trtl92e_irq_disable(dev);\n\t\tdel_timer_sync(&priv->watch_dog_timer);\n\t\t_rtl92e_cancel_deferred_work(priv);\n\t\trtl92e_dm_deinit(dev);\n\t\trtllib_stop_scan_syncro(ieee);\n\n\t\tif (ieee->link_state == MAC80211_LINKED) {\n\t\t\tmutex_lock(&ieee->wx_mutex);\n\t\t\tnetdev_info(dev, \"ieee->link_state is MAC80211_LINKED\\n\");\n\t\t\trtllib_stop_send_beacons(priv->rtllib);\n\t\t\tdel_timer_sync(&ieee->associate_timer);\n\t\t\tcancel_delayed_work(&ieee->associate_retry_wq);\n\t\t\trtllib_stop_scan(ieee);\n\t\t\tnetif_carrier_off(dev);\n\t\t\tmutex_unlock(&ieee->wx_mutex);\n\t\t} else {\n\t\t\tnetdev_info(dev, \"ieee->link_state is NOT LINKED\\n\");\n\t\t\trtllib_softmac_stop_protocol(priv->rtllib, 0, true);\n\t\t}\n\n\t\trtl92e_dm_backup_state(dev);\n\n\t\tmutex_unlock(&priv->wx_mutex);\n\t\treset_status = _rtl92e_up(dev, true);\n\n\t\tif (reset_status == -1) {\n\t\t\tif (reset_times < 3) {\n\t\t\t\treset_times++;\n\t\t\t\tgoto RESET_START;\n\t\t\t} else {\n\t\t\t\tnetdev_warn(dev, \"%s():\tReset Failed\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t}\n\t\t}\n\n\t\tieee->is_silent_reset = 1;\n\n\t\tspin_lock_irqsave(&priv->rf_ps_lock, flag);\n\t\tpriv->rf_change_in_progress = false;\n\t\tspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\n\n\t\trtl92e_enable_hw_security_config(dev);\n\n\t\tif (ieee->link_state == MAC80211_LINKED && ieee->iw_mode ==\n\t\t    IW_MODE_INFRA) {\n\t\t\tieee->set_chan(ieee->dev,\n\t\t\t\t       ieee->current_network.channel);\n\n\t\t\tschedule_work(&ieee->associate_complete_wq);\n\n\t\t} else if (ieee->link_state == MAC80211_LINKED && ieee->iw_mode ==\n\t\t\t   IW_MODE_ADHOC) {\n\t\t\tieee->set_chan(ieee->dev,\n\t\t\t\t       ieee->current_network.channel);\n\t\t\tieee->link_change(ieee->dev);\n\n\t\t\tnotify_wx_assoc_event(ieee);\n\n\t\t\trtllib_start_send_beacons(ieee);\n\n\t\t\tnetif_carrier_on(ieee->dev);\n\t\t}\n\n\t\trtl92e_cam_restore(dev);\n\t\trtl92e_dm_restore_state(dev);\nEND:\n\t\tpriv->rst_progress = RESET_TYPE_NORESET;\n\t\tpriv->reset_count++;\n\t\tpriv->reset_in_progress = false;\n\n\t\trtl92e_writeb(dev, UFWP, 1);\n\t}\n}\n\nstatic void _rtl92e_update_rxcounts(struct r8192_priv *priv, u32 *TotalRxBcnNum,\n\t\t\t\t    u32 *TotalRxDataNum)\n{\n\tu16\tSlotIndex;\n\tu8\ti;\n\n\t*TotalRxBcnNum = 0;\n\t*TotalRxDataNum = 0;\n\n\tSlotIndex = (priv->rtllib->link_detect_info.SlotIndex++) %\n\t\t\t(priv->rtllib->link_detect_info.SlotNum);\n\tpriv->rtllib->link_detect_info.RxBcnNum[SlotIndex] =\n\t\t\tpriv->rtllib->link_detect_info.NumRecvBcnInPeriod;\n\tpriv->rtllib->link_detect_info.RxDataNum[SlotIndex] =\n\t\t\tpriv->rtllib->link_detect_info.NumRecvDataInPeriod;\n\tfor (i = 0; i < priv->rtllib->link_detect_info.SlotNum; i++) {\n\t\t*TotalRxBcnNum += priv->rtllib->link_detect_info.RxBcnNum[i];\n\t\t*TotalRxDataNum += priv->rtllib->link_detect_info.RxDataNum[i];\n\t}\n}\n\nstatic void _rtl92e_watchdog_wq_cb(void *data)\n{\n\tstruct r8192_priv *priv = container_of_dwork_rsl(data,\n\t\t\t\t  struct r8192_priv, watch_dog_wq);\n\tstruct net_device *dev = priv->rtllib->dev;\n\tstruct rtllib_device *ieee = priv->rtllib;\n\tenum reset_type ResetType = RESET_TYPE_NORESET;\n\tstatic u8 check_reset_cnt;\n\tunsigned long flags;\n\tstruct rt_pwr_save_ctrl *psc = (struct rt_pwr_save_ctrl *)\n\t\t\t\t\t(&priv->rtllib->pwr_save_ctrl);\n\tbool bBusyTraffic = false;\n\tbool\tbHigherBusyTraffic = false;\n\tbool\tbHigherBusyRxTraffic = false;\n\tbool bEnterPS = false;\n\n\tif (!priv->up || priv->hw_radio_off)\n\t\treturn;\n\n\tif (priv->rtllib->link_state >= MAC80211_LINKED) {\n\t\tif (priv->rtllib->CntAfterLink < 2)\n\t\t\tpriv->rtllib->CntAfterLink++;\n\t} else {\n\t\tpriv->rtllib->CntAfterLink = 0;\n\t}\n\n\trtl92e_dm_watchdog(dev);\n\n\tif (!rtllib_act_scanning(priv->rtllib, false)) {\n\t\tif ((ieee->iw_mode == IW_MODE_INFRA) && (ieee->link_state ==\n\t\t     MAC80211_NOLINK) &&\n\t\t     (ieee->rf_power_state == rf_on) && !ieee->is_set_key &&\n\t\t     (!ieee->proto_stoppping) && !ieee->wx_set_enc) {\n\t\t\tif ((ieee->pwr_save_ctrl.ReturnPoint ==\n\t\t\t     IPS_CALLBACK_NONE) &&\n\t\t\t     (!ieee->net_promiscuous_md)) {\n\t\t\t\trtl92e_ips_enter(dev);\n\t\t\t}\n\t\t}\n\t}\n\tif ((ieee->link_state == MAC80211_LINKED) && (ieee->iw_mode ==\n\t     IW_MODE_INFRA) && (!ieee->net_promiscuous_md)) {\n\t\tif (ieee->link_detect_info.NumRxOkInPeriod > 100 ||\n\t\tieee->link_detect_info.NumTxOkInPeriod > 100)\n\t\t\tbBusyTraffic = true;\n\n\t\tif (ieee->link_detect_info.NumRxOkInPeriod > 4000 ||\n\t\t    ieee->link_detect_info.NumTxOkInPeriod > 4000) {\n\t\t\tbHigherBusyTraffic = true;\n\t\t\tif (ieee->link_detect_info.NumRxOkInPeriod > 5000)\n\t\t\t\tbHigherBusyRxTraffic = true;\n\t\t\telse\n\t\t\t\tbHigherBusyRxTraffic = false;\n\t\t}\n\n\t\tif (((ieee->link_detect_info.NumRxUnicastOkInPeriod +\n\t\t    ieee->link_detect_info.NumTxOkInPeriod) > 8) ||\n\t\t    (ieee->link_detect_info.NumRxUnicastOkInPeriod > 2))\n\t\t\tbEnterPS = false;\n\t\telse\n\t\t\tbEnterPS = true;\n\n\t\tif (ieee->current_network.beacon_interval < 95)\n\t\t\tbEnterPS = false;\n\n\t\tif (bEnterPS)\n\t\t\trtl92e_leisure_ps_enter(dev);\n\t\telse\n\t\t\trtl92e_leisure_ps_leave(dev);\n\n\t} else {\n\t\trtl92e_leisure_ps_leave(dev);\n\t}\n\n\tieee->link_detect_info.NumRxOkInPeriod = 0;\n\tieee->link_detect_info.NumTxOkInPeriod = 0;\n\tieee->link_detect_info.NumRxUnicastOkInPeriod = 0;\n\tieee->link_detect_info.bBusyTraffic = bBusyTraffic;\n\n\tieee->link_detect_info.bHigherBusyTraffic = bHigherBusyTraffic;\n\tieee->link_detect_info.bHigherBusyRxTraffic = bHigherBusyRxTraffic;\n\n\tif (ieee->link_state == MAC80211_LINKED && ieee->iw_mode == IW_MODE_INFRA) {\n\t\tu32\tTotalRxBcnNum = 0;\n\t\tu32\tTotalRxDataNum = 0;\n\n\t\t_rtl92e_update_rxcounts(priv, &TotalRxBcnNum, &TotalRxDataNum);\n\n\t\tif ((TotalRxBcnNum + TotalRxDataNum) == 0)\n\t\t\tpriv->check_roaming_cnt++;\n\t\telse\n\t\t\tpriv->check_roaming_cnt = 0;\n\n\t\tif (priv->check_roaming_cnt > 0) {\n\t\t\tif (ieee->rf_power_state == rf_off)\n\t\t\t\tnetdev_info(dev, \"%s(): RF is off\\n\", __func__);\n\n\t\t\tnetdev_info(dev,\n\t\t\t\t    \"===>%s(): AP is power off, chan:%d, connect another one\\n\",\n\t\t\t\t    __func__, priv->chan);\n\n\t\t\tieee->link_state = RTLLIB_ASSOCIATING;\n\n\t\t\tRemovePeerTS(priv->rtllib,\n\t\t\t\t     priv->rtllib->current_network.bssid);\n\t\t\tieee->is_roaming = true;\n\t\t\tieee->is_set_key = false;\n\t\t\tieee->link_change(dev);\n\t\t\tnotify_wx_assoc_event(ieee);\n\n\t\t\tif (!(ieee->rtllib_ap_sec_type(ieee) &\n\t\t\t     (SEC_ALG_CCMP | SEC_ALG_TKIP)))\n\t\t\t\tschedule_delayed_work(\n\t\t\t\t\t&ieee->associate_procedure_wq, 0);\n\n\t\t\tpriv->check_roaming_cnt = 0;\n\t\t}\n\t\tieee->link_detect_info.NumRecvBcnInPeriod = 0;\n\t\tieee->link_detect_info.NumRecvDataInPeriod = 0;\n\t}\n\n\tspin_lock_irqsave(&priv->tx_lock, flags);\n\tif ((check_reset_cnt++ >= 3) && (!ieee->is_roaming) &&\n\t    (!priv->rf_change_in_progress) && (!psc->bSwRfProcessing)) {\n\t\tResetType = _rtl92e_if_check_reset(dev);\n\t\tcheck_reset_cnt = 3;\n\t}\n\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\n\tif (ResetType == RESET_TYPE_NORMAL) {\n\t\tpriv->rst_progress = RESET_TYPE_NORMAL;\n\t\treturn;\n\t}\n\n\tif ((priv->force_reset || ResetType == RESET_TYPE_SILENT))\n\t\t_rtl92e_if_silent_reset(dev);\n\tpriv->force_reset = false;\n\tpriv->reset_in_progress = false;\n}\n\nstatic void _rtl92e_watchdog_timer_cb(struct timer_list *t)\n{\n\tstruct r8192_priv *priv = from_timer(priv, t, watch_dog_timer);\n\n\tschedule_delayed_work(&priv->watch_dog_wq, 0);\n\tmod_timer(&priv->watch_dog_timer, jiffies +\n\t\t  msecs_to_jiffies(RTLLIB_WATCH_DOG_TIME));\n}\n\n \nvoid rtl92e_rx_enable(struct net_device *dev)\n{\n\trtl92e_enable_rx(dev);\n}\n\nvoid rtl92e_tx_enable(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\trtl92e_enable_tx(dev);\n\n\trtllib_reset_queue(priv->rtllib);\n}\n\nstatic void _rtl92e_free_rx_ring(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tint i, rx_queue_idx;\n\n\tfor (rx_queue_idx = 0; rx_queue_idx < MAX_RX_QUEUE;\n\t     rx_queue_idx++) {\n\t\tfor (i = 0; i < priv->rxringcount; i++) {\n\t\t\tstruct sk_buff *skb = priv->rx_buf[rx_queue_idx][i];\n\n\t\t\tif (!skb)\n\t\t\t\tcontinue;\n\n\t\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t\t *((dma_addr_t *)skb->cb),\n\t\t\t\t\t priv->rxbuffersize, DMA_FROM_DEVICE);\n\t\t\tkfree_skb(skb);\n\t\t}\n\n\t\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t\t  sizeof(*priv->rx_ring[rx_queue_idx]) * priv->rxringcount,\n\t\t\t\t  priv->rx_ring[rx_queue_idx],\n\t\t\t\t  priv->rx_ring_dma[rx_queue_idx]);\n\t\tpriv->rx_ring[rx_queue_idx] = NULL;\n\t}\n}\n\nstatic void _rtl92e_free_tx_ring(struct net_device *dev, unsigned int prio)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtl8192_tx_ring *ring = &priv->tx_ring[prio];\n\n\twhile (skb_queue_len(&ring->queue)) {\n\t\tstruct tx_desc *entry = &ring->desc[ring->idx];\n\t\tstruct sk_buff *skb = __skb_dequeue(&ring->queue);\n\n\t\tdma_unmap_single(&priv->pdev->dev, entry->TxBuffAddr,\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\tkfree_skb(skb);\n\t\tring->idx = (ring->idx + 1) % ring->entries;\n\t}\n\n\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t  sizeof(*ring->desc) * ring->entries, ring->desc,\n\t\t\t  ring->dma);\n\tring->desc = NULL;\n}\n\nstatic void _rtl92e_hard_data_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t   int rate)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tint ret;\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb +\n\t\t\t\t    MAX_DEV_ADDR_SIZE);\n\tu8 queue_index = tcb_desc->queue_index;\n\n\tif ((priv->rtllib->rf_power_state == rf_off) || !priv->up ||\n\t     priv->reset_in_progress) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (queue_index == TXCMD_QUEUE)\n\t\tnetdev_warn(dev, \"%s(): queue index == TXCMD_QUEUE\\n\",\n\t\t\t    __func__);\n\n\tmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\n\tskb_push(skb, priv->rtllib->tx_headroom);\n\tret = _rtl92e_tx(dev, skb);\n\n\tif (queue_index != MGNT_QUEUE) {\n\t\tpriv->rtllib->stats.tx_bytes += (skb->len -\n\t\t\t\t\t\t priv->rtllib->tx_headroom);\n\t\tpriv->rtllib->stats.tx_packets++;\n\t}\n\n\tif (ret != 0)\n\t\tkfree_skb(skb);\n}\n\nstatic int _rtl92e_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tint ret;\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb +\n\t\t\t\t    MAX_DEV_ADDR_SIZE);\n\tu8 queue_index = tcb_desc->queue_index;\n\n\tif (queue_index != TXCMD_QUEUE) {\n\t\tif ((priv->rtllib->rf_power_state == rf_off) ||\n\t\t     !priv->up || priv->reset_in_progress) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\n\tif (queue_index == TXCMD_QUEUE) {\n\t\t_rtl92e_tx_cmd(dev, skb);\n\t\treturn 0;\n\t}\n\n\ttcb_desc->ratr_index = 7;\n\ttcb_desc->tx_dis_rate_fallback = 1;\n\ttcb_desc->tx_use_drv_assinged_rate = 1;\n\ttcb_desc->bTxEnableFwCalcDur = 1;\n\tskb_push(skb, priv->rtllib->tx_headroom);\n\tret = _rtl92e_tx(dev, skb);\n\tif (ret != 0)\n\t\tkfree_skb(skb);\n\treturn ret;\n}\n\nstatic void _rtl92e_tx_isr(struct net_device *dev, int prio)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tstruct rtl8192_tx_ring *ring = &priv->tx_ring[prio];\n\n\twhile (skb_queue_len(&ring->queue)) {\n\t\tstruct tx_desc *entry = &ring->desc[ring->idx];\n\t\tstruct sk_buff *skb;\n\n\t\tif (prio != BEACON_QUEUE) {\n\t\t\tif (entry->OWN)\n\t\t\t\treturn;\n\t\t\tring->idx = (ring->idx + 1) % ring->entries;\n\t\t}\n\n\t\tskb = __skb_dequeue(&ring->queue);\n\t\tdma_unmap_single(&priv->pdev->dev, entry->TxBuffAddr,\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\n\t\tkfree_skb(skb);\n\t}\n\tif (prio != BEACON_QUEUE)\n\t\ttasklet_schedule(&priv->irq_tx_tasklet);\n}\n\nstatic void _rtl92e_tx_cmd(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtl8192_tx_ring *ring;\n\tstruct tx_desc_cmd *entry;\n\tunsigned int idx;\n\tstruct cb_desc *tcb_desc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->irq_th_lock, flags);\n\tring = &priv->tx_ring[TXCMD_QUEUE];\n\n\tidx = (ring->idx + skb_queue_len(&ring->queue)) % ring->entries;\n\tentry = (struct tx_desc_cmd *)&ring->desc[idx];\n\n\ttcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\n\n\trtl92e_fill_tx_cmd_desc(dev, entry, tcb_desc, skb);\n\n\t__skb_queue_tail(&ring->queue, skb);\n\tspin_unlock_irqrestore(&priv->irq_th_lock, flags);\n}\n\nstatic short _rtl92e_tx(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtl8192_tx_ring  *ring;\n\tunsigned long flags;\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb +\n\t\t\t\t    MAX_DEV_ADDR_SIZE);\n\tstruct tx_desc *pdesc = NULL;\n\tstruct rtllib_hdr_1addr *header = NULL;\n\tu8 *pda_addr = NULL;\n\tint   idx;\n\tu32 fwinfo_size = 0;\n\n\tpriv->rtllib->bAwakePktSent = true;\n\n\tfwinfo_size = sizeof(struct tx_fwinfo_8190pci);\n\n\theader = (struct rtllib_hdr_1addr *)(((u8 *)skb->data) + fwinfo_size);\n\tpda_addr = header->addr1;\n\n\tif (!is_broadcast_ether_addr(pda_addr) && !is_multicast_ether_addr(pda_addr))\n\t\tpriv->stats.txbytesunicast += skb->len - fwinfo_size;\n\n\tspin_lock_irqsave(&priv->irq_th_lock, flags);\n\tring = &priv->tx_ring[tcb_desc->queue_index];\n\tif (tcb_desc->queue_index != BEACON_QUEUE)\n\t\tidx = (ring->idx + skb_queue_len(&ring->queue)) % ring->entries;\n\telse\n\t\tidx = 0;\n\n\tpdesc = &ring->desc[idx];\n\tif ((pdesc->OWN == 1) && (tcb_desc->queue_index != BEACON_QUEUE)) {\n\t\tnetdev_warn(dev,\n\t\t\t    \"No more TX desc@%d, ring->idx = %d, idx = %d, skblen = 0x%x queuelen=%d\",\n\t\t\t    tcb_desc->queue_index, ring->idx, idx, skb->len,\n\t\t\t    skb_queue_len(&ring->queue));\n\t\tspin_unlock_irqrestore(&priv->irq_th_lock, flags);\n\t\treturn skb->len;\n\t}\n\trtl92e_fill_tx_desc(dev, pdesc, tcb_desc, skb);\n\t__skb_queue_tail(&ring->queue, skb);\n\tpdesc->OWN = 1;\n\tspin_unlock_irqrestore(&priv->irq_th_lock, flags);\n\tnetif_trans_update(dev);\n\n\trtl92e_writew(dev, TP_POLL, 0x01 << tcb_desc->queue_index);\n\treturn 0;\n}\n\nstatic short _rtl92e_alloc_rx_ring(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rx_desc *entry = NULL;\n\tint i, rx_queue_idx;\n\n\tfor (rx_queue_idx = 0; rx_queue_idx < MAX_RX_QUEUE; rx_queue_idx++) {\n\t\tpriv->rx_ring[rx_queue_idx] = dma_alloc_coherent(&priv->pdev->dev,\n\t\t\t\t\t\t\t\t sizeof(*priv->rx_ring[rx_queue_idx]) * priv->rxringcount,\n\t\t\t\t\t\t\t\t &priv->rx_ring_dma[rx_queue_idx],\n\t\t\t\t\t\t\t\t GFP_ATOMIC);\n\t\tif (!priv->rx_ring[rx_queue_idx] ||\n\t\t    (unsigned long)priv->rx_ring[rx_queue_idx] & 0xFF) {\n\t\t\tnetdev_warn(dev, \"Cannot allocate RX ring\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpriv->rx_idx[rx_queue_idx] = 0;\n\n\t\tfor (i = 0; i < priv->rxringcount; i++) {\n\t\t\tstruct sk_buff *skb = dev_alloc_skb(priv->rxbuffersize);\n\t\t\tdma_addr_t *mapping;\n\n\t\t\tentry = &priv->rx_ring[rx_queue_idx][i];\n\t\t\tif (!skb)\n\t\t\t\treturn 0;\n\t\t\tskb->dev = dev;\n\t\t\tpriv->rx_buf[rx_queue_idx][i] = skb;\n\t\t\tmapping = (dma_addr_t *)skb->cb;\n\t\t\t*mapping = dma_map_single(&priv->pdev->dev,\n\t\t\t\t\t\t  skb_tail_pointer(skb),\n\t\t\t\t\t\t  priv->rxbuffersize, DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&priv->pdev->dev, *mapping)) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tentry->BufferAddress = *mapping;\n\n\t\t\tentry->Length = priv->rxbuffersize;\n\t\t\tentry->OWN = 1;\n\t\t}\n\n\t\tif (entry)\n\t\t\tentry->EOR = 1;\n\t}\n\treturn 0;\n}\n\nstatic int _rtl92e_alloc_tx_ring(struct net_device *dev, unsigned int prio,\n\t\t\t\t unsigned int entries)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct tx_desc *ring;\n\tdma_addr_t dma;\n\tint i;\n\n\tring = dma_alloc_coherent(&priv->pdev->dev, sizeof(*ring) * entries,\n\t\t\t\t  &dma, GFP_ATOMIC);\n\tif (!ring || (unsigned long)ring & 0xFF) {\n\t\tnetdev_warn(dev, \"Cannot allocate TX ring (prio = %d)\\n\", prio);\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->tx_ring[prio].desc = ring;\n\tpriv->tx_ring[prio].dma = dma;\n\tpriv->tx_ring[prio].idx = 0;\n\tpriv->tx_ring[prio].entries = entries;\n\tskb_queue_head_init(&priv->tx_ring[prio].queue);\n\n\tfor (i = 0; i < entries; i++)\n\t\tring[i].NextDescAddress =\n\t\t\t(u32)dma + ((i + 1) % entries) *\n\t\t\tsizeof(*ring);\n\n\treturn 0;\n}\n\nstatic short _rtl92e_pci_initdescring(struct net_device *dev)\n{\n\tu32 ret;\n\tint i;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tret = _rtl92e_alloc_rx_ring(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++) {\n\t\tret = _rtl92e_alloc_tx_ring(dev, i, priv->txringcount);\n\t\tif (ret)\n\t\t\tgoto err_free_rings;\n\t}\n\n\treturn 0;\n\nerr_free_rings:\n\t_rtl92e_free_rx_ring(dev);\n\tfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++)\n\t\tif (priv->tx_ring[i].desc)\n\t\t\t_rtl92e_free_tx_ring(dev, i);\n\treturn 1;\n}\n\nvoid rtl92e_reset_desc_ring(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tint i, rx_queue_idx;\n\tunsigned long flags = 0;\n\n\tfor (rx_queue_idx = 0; rx_queue_idx < MAX_RX_QUEUE; rx_queue_idx++) {\n\t\tif (priv->rx_ring[rx_queue_idx]) {\n\t\t\tstruct rx_desc *entry = NULL;\n\n\t\t\tfor (i = 0; i < priv->rxringcount; i++) {\n\t\t\t\tentry = &priv->rx_ring[rx_queue_idx][i];\n\t\t\t\tentry->OWN = 1;\n\t\t\t}\n\t\t\tpriv->rx_idx[rx_queue_idx] = 0;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&priv->irq_th_lock, flags);\n\tfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++) {\n\t\tif (priv->tx_ring[i].desc) {\n\t\t\tstruct rtl8192_tx_ring *ring = &priv->tx_ring[i];\n\n\t\t\twhile (skb_queue_len(&ring->queue)) {\n\t\t\t\tstruct tx_desc *entry = &ring->desc[ring->idx];\n\t\t\t\tstruct sk_buff *skb =\n\t\t\t\t\t\t __skb_dequeue(&ring->queue);\n\n\t\t\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t\t\t entry->TxBuffAddr, skb->len,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tring->idx = (ring->idx + 1) % ring->entries;\n\t\t\t}\n\t\t\tring->idx = 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->irq_th_lock, flags);\n}\n\nvoid rtl92e_update_rx_pkt_timestamp(struct net_device *dev,\n\t\t\t\t    struct rtllib_rx_stats *stats)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (stats->bIsAMPDU && !stats->bFirstMPDU)\n\t\tstats->mac_time = priv->last_rx_desc_tsf;\n\telse\n\t\tpriv->last_rx_desc_tsf = stats->mac_time;\n}\n\nlong rtl92e_translate_to_dbm(struct r8192_priv *priv, u8 signal_strength_index)\n{\n\tlong\tsignal_power;\n\n\tsignal_power = (long)((signal_strength_index + 1) >> 1);\n\tsignal_power -= 95;\n\n\treturn signal_power;\n}\n\nvoid rtl92e_update_rx_statistics(struct r8192_priv *priv,\n\t\t\t\t struct rtllib_rx_stats *pprevious_stats)\n{\n\tint weighting = 0;\n\n\tif (priv->stats.recv_signal_power == 0)\n\t\tpriv->stats.recv_signal_power =\n\t\t\t\t\t pprevious_stats->RecvSignalPower;\n\n\tif (pprevious_stats->RecvSignalPower > priv->stats.recv_signal_power)\n\t\tweighting = 5;\n\telse if (pprevious_stats->RecvSignalPower <\n\t\t priv->stats.recv_signal_power)\n\t\tweighting = (-5);\n\tpriv->stats.recv_signal_power = (priv->stats.recv_signal_power * 5 +\n\t\t\t\t\tpprevious_stats->RecvSignalPower +\n\t\t\t\t\tweighting) / 6;\n}\n\nu8 rtl92e_rx_db_to_percent(s8 antpower)\n{\n\tif ((antpower <= -100) || (antpower >= 20))\n\t\treturn\t0;\n\telse if (antpower >= 0)\n\t\treturn\t100;\n\telse\n\t\treturn\t100 + antpower;\n\n}\t \n\nu8 rtl92e_evm_db_to_percent(s8 value)\n{\n\ts8 ret_val = clamp(-value, 0, 33) * 3;\n\n\tif (ret_val == 99)\n\t\tret_val = 100;\n\n\treturn ret_val;\n}\n\nvoid rtl92e_copy_mpdu_stats(struct rtllib_rx_stats *psrc_stats,\n\t\t\t    struct rtllib_rx_stats *ptarget_stats)\n{\n\tptarget_stats->bIsAMPDU = psrc_stats->bIsAMPDU;\n\tptarget_stats->bFirstMPDU = psrc_stats->bFirstMPDU;\n}\n\nstatic void _rtl92e_rx_normal(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_hdr_1addr *rtllib_hdr = NULL;\n\tbool unicast_packet = false;\n\tu32 skb_len = 0;\n\tint rx_queue_idx = RX_MPDU_QUEUE;\n\n\tstruct rtllib_rx_stats stats = {\n\t\t.signal = 0,\n\t\t.noise = (u8)-98,\n\t\t.rate = 0,\n\t};\n\tunsigned int count = priv->rxringcount;\n\n\tstats.nic_type = NIC_8192E;\n\n\twhile (count--) {\n\t\tstruct rx_desc *pdesc = &priv->rx_ring[rx_queue_idx]\n\t\t\t\t\t[priv->rx_idx[rx_queue_idx]];\n\t\tstruct sk_buff *skb = priv->rx_buf[rx_queue_idx]\n\t\t\t\t      [priv->rx_idx[rx_queue_idx]];\n\t\tstruct sk_buff *new_skb;\n\n\t\tif (pdesc->OWN)\n\t\t\treturn;\n\t\tif (!rtl92e_get_rx_stats(dev, &stats, pdesc, skb))\n\t\t\tgoto done;\n\t\tnew_skb = dev_alloc_skb(priv->rxbuffersize);\n\t\t \n\t\tif (unlikely(!new_skb))\n\t\t\tgoto done;\n\n\t\tdma_unmap_single(&priv->pdev->dev, *((dma_addr_t *)skb->cb),\n\t\t\t\t priv->rxbuffersize, DMA_FROM_DEVICE);\n\n\t\tskb_put(skb, pdesc->Length);\n\t\tskb_reserve(skb, stats.RxDrvInfoSize +\n\t\t\tstats.RxBufShift);\n\t\tskb_trim(skb, skb->len - S_CRC_LEN);\n\t\trtllib_hdr = (struct rtllib_hdr_1addr *)skb->data;\n\t\tif (!is_multicast_ether_addr(rtllib_hdr->addr1)) {\n\t\t\t \n\t\t\tunicast_packet = true;\n\t\t}\n\t\tskb_len = skb->len;\n\n\t\tif (!rtllib_rx(priv->rtllib, skb, &stats)) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t} else {\n\t\t\tif (unicast_packet)\n\t\t\t\tpriv->stats.rxbytesunicast += skb_len;\n\t\t}\n\n\t\tskb = new_skb;\n\t\tskb->dev = dev;\n\n\t\tpriv->rx_buf[rx_queue_idx][priv->rx_idx[rx_queue_idx]] =\n\t\t\t\t\t\t\t\t skb;\n\t\t*((dma_addr_t *)skb->cb) = dma_map_single(&priv->pdev->dev,\n\t\t\t\t\t\t\t  skb_tail_pointer(skb),\n\t\t\t\t\t\t\t  priv->rxbuffersize, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&priv->pdev->dev, *((dma_addr_t *)skb->cb))) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn;\n\t\t}\ndone:\n\t\tpdesc->BufferAddress = *((dma_addr_t *)skb->cb);\n\t\tpdesc->OWN = 1;\n\t\tpdesc->Length = priv->rxbuffersize;\n\t\tif (priv->rx_idx[rx_queue_idx] == priv->rxringcount - 1)\n\t\t\tpdesc->EOR = 1;\n\t\tpriv->rx_idx[rx_queue_idx] = (priv->rx_idx[rx_queue_idx] + 1) %\n\t\t\t\t\t      priv->rxringcount;\n\t}\n}\n\nstatic void _rtl92e_tx_resume(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rtllib_device *ieee = priv->rtllib;\n\tstruct sk_buff *skb;\n\tint queue_index;\n\n\tfor (queue_index = BK_QUEUE;\n\t     queue_index < MAX_QUEUE_SIZE; queue_index++) {\n\t\twhile ((!skb_queue_empty(&ieee->skb_waitQ[queue_index])) &&\n\t\t(priv->rtllib->check_nic_enough_desc(dev, queue_index) > 0)) {\n\t\t\tskb = skb_dequeue(&ieee->skb_waitQ[queue_index]);\n\t\t\tieee->softmac_data_hard_start_xmit(skb, dev, 0);\n\t\t}\n\t}\n}\n\nstatic void _rtl92e_irq_tx_tasklet(struct tasklet_struct *t)\n{\n\tstruct r8192_priv *priv = from_tasklet(priv, t, irq_tx_tasklet);\n\n\t_rtl92e_tx_resume(priv->rtllib->dev);\n}\n\nstatic void _rtl92e_irq_rx_tasklet(struct tasklet_struct *t)\n{\n\tstruct r8192_priv *priv = from_tasklet(priv, t, irq_rx_tasklet);\n\n\t_rtl92e_rx_normal(priv->rtllib->dev);\n\n\trtl92e_writel(priv->rtllib->dev, INTA_MASK,\n\t\t      rtl92e_readl(priv->rtllib->dev, INTA_MASK) | IMR_RDU);\n}\n\n \nstatic void _rtl92e_cancel_deferred_work(struct r8192_priv *priv)\n{\n\tcancel_delayed_work_sync(&priv->watch_dog_wq);\n\tcancel_delayed_work_sync(&priv->update_beacon_wq);\n\tcancel_delayed_work(&priv->rtllib->hw_sleep_wq);\n\tcancel_work_sync(&priv->reset_wq);\n\tcancel_work_sync(&priv->qos_activate);\n}\n\nstatic int _rtl92e_up(struct net_device *dev, bool is_silent_reset)\n{\n\tif (_rtl92e_sta_up(dev, is_silent_reset) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int _rtl92e_open(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tint ret;\n\n\tmutex_lock(&priv->wx_mutex);\n\tret = _rtl92e_try_up(dev);\n\tmutex_unlock(&priv->wx_mutex);\n\treturn ret;\n}\n\nstatic int _rtl92e_try_up(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->up == 1)\n\t\treturn -1;\n\treturn _rtl92e_up(dev, false);\n}\n\nstatic int _rtl92e_close(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tint ret;\n\n\tif ((rtllib_act_scanning(priv->rtllib, false)) &&\n\t\t!(priv->rtllib->softmac_features & IEEE_SOFTMAC_SCAN)) {\n\t\trtllib_stop_scan(priv->rtllib);\n\t}\n\n\tmutex_lock(&priv->wx_mutex);\n\n\tret = _rtl92e_down(dev, true);\n\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn ret;\n}\n\nstatic int _rtl92e_down(struct net_device *dev, bool shutdownrf)\n{\n\tif (_rtl92e_sta_down(dev, shutdownrf) == -1)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nvoid rtl92e_commit(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\n\tif (priv->up == 0)\n\t\treturn;\n\trtllib_softmac_stop_protocol(priv->rtllib, 0, true);\n\trtl92e_irq_disable(dev);\n\trtl92e_stop_adapter(dev, true);\n\t_rtl92e_up(dev, false);\n}\n\nstatic void _rtl92e_restart(void *data)\n{\n\tstruct r8192_priv *priv = container_of(data, struct r8192_priv, reset_wq);\n\tstruct net_device *dev = priv->rtllib->dev;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\trtl92e_commit(dev);\n\n\tmutex_unlock(&priv->wx_mutex);\n}\n\nstatic void _rtl92e_set_multicast(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tshort promisc;\n\n\tpromisc = (dev->flags & IFF_PROMISC) ? 1 : 0;\n\tpriv->promisc = promisc;\n}\n\nstatic int _rtl92e_set_mac_adr(struct net_device *dev, void *mac)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct sockaddr *addr = mac;\n\n\tmutex_lock(&priv->wx_mutex);\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\tschedule_work(&priv->reset_wq);\n\tmutex_unlock(&priv->wx_mutex);\n\n\treturn 0;\n}\n\nstatic irqreturn_t _rtl92e_irq(int irq, void *netdev)\n{\n\tstruct net_device *dev = netdev;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tunsigned long flags;\n\tu32 inta;\n\n\tif (priv->irq_enabled == 0)\n\t\tgoto done;\n\n\tspin_lock_irqsave(&priv->irq_th_lock, flags);\n\n\trtl92e_ack_irq(dev, &inta);\n\n\tif (!inta) {\n\t\tspin_unlock_irqrestore(&priv->irq_th_lock, flags);\n\t\tgoto done;\n\t}\n\n\tif (inta == 0xffff) {\n\t\tspin_unlock_irqrestore(&priv->irq_th_lock, flags);\n\t\tgoto done;\n\t}\n\n\tif (!netif_running(dev)) {\n\t\tspin_unlock_irqrestore(&priv->irq_th_lock, flags);\n\t\tgoto done;\n\t}\n\n\tif (inta  & IMR_MGNTDOK) {\n\t\t_rtl92e_tx_isr(dev, MGNT_QUEUE);\n\t\tspin_unlock_irqrestore(&priv->irq_th_lock, flags);\n\t\tif (priv->rtllib->ack_tx_to_ieee) {\n\t\t\tif (_rtl92e_is_tx_queue_empty(dev)) {\n\t\t\t\tpriv->rtllib->ack_tx_to_ieee = 0;\n\t\t\t\trtllib_ps_tx_ack(priv->rtllib, 1);\n\t\t\t}\n\t\t}\n\t\tspin_lock_irqsave(&priv->irq_th_lock, flags);\n\t}\n\n\tif (inta & IMR_COMDOK)\n\t\t_rtl92e_tx_isr(dev, TXCMD_QUEUE);\n\n\tif (inta & IMR_HIGHDOK)\n\t\t_rtl92e_tx_isr(dev, HIGH_QUEUE);\n\n\tif (inta & IMR_ROK)\n\t\ttasklet_schedule(&priv->irq_rx_tasklet);\n\n\tif (inta & IMR_BcnInt)\n\t\ttasklet_schedule(&priv->irq_prepare_beacon_tasklet);\n\n\tif (inta & IMR_RDU) {\n\t\trtl92e_writel(dev, INTA_MASK,\n\t\t\t      rtl92e_readl(dev, INTA_MASK) & ~IMR_RDU);\n\t\ttasklet_schedule(&priv->irq_rx_tasklet);\n\t}\n\n\tif (inta & IMR_RXFOVW)\n\t\ttasklet_schedule(&priv->irq_rx_tasklet);\n\n\tif (inta & IMR_BKDOK) {\n\t\tpriv->rtllib->link_detect_info.NumTxOkInPeriod++;\n\t\t_rtl92e_tx_isr(dev, BK_QUEUE);\n\t}\n\n\tif (inta & IMR_BEDOK) {\n\t\tpriv->rtllib->link_detect_info.NumTxOkInPeriod++;\n\t\t_rtl92e_tx_isr(dev, BE_QUEUE);\n\t}\n\n\tif (inta & IMR_VIDOK) {\n\t\tpriv->rtllib->link_detect_info.NumTxOkInPeriod++;\n\t\t_rtl92e_tx_isr(dev, VI_QUEUE);\n\t}\n\n\tif (inta & IMR_VODOK) {\n\t\tpriv->rtllib->link_detect_info.NumTxOkInPeriod++;\n\t\t_rtl92e_tx_isr(dev, VO_QUEUE);\n\t}\n\n\tspin_unlock_irqrestore(&priv->irq_th_lock, flags);\n\ndone:\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic const struct net_device_ops rtl8192_netdev_ops = {\n\t.ndo_open = _rtl92e_open,\n\t.ndo_stop = _rtl92e_close,\n\t.ndo_tx_timeout = _rtl92e_tx_timeout,\n\t.ndo_set_rx_mode = _rtl92e_set_multicast,\n\t.ndo_set_mac_address = _rtl92e_set_mac_adr,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_start_xmit = rtllib_xmit,\n};\n\nstatic int _rtl92e_pci_probe(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tunsigned long ioaddr = 0;\n\tstruct net_device *dev = NULL;\n\tstruct r8192_priv *priv = NULL;\n\tunsigned long pmem_start, pmem_len, pmem_flags;\n\tint err = -ENOMEM;\n\n\tif (pci_enable_device(pdev)) {\n\t\tdev_err(&pdev->dev, \"Failed to enable PCI device\");\n\t\treturn -EIO;\n\t}\n\n\tpci_set_master(pdev);\n\n\tif (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tif (dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Unable to obtain 32bit DMA for consistent allocations\\n\");\n\t\t\tgoto err_pci_disable;\n\t\t}\n\t}\n\tdev = alloc_rtllib(sizeof(struct r8192_priv));\n\tif (!dev)\n\t\tgoto err_pci_disable;\n\n\terr = -ENODEV;\n\n\tpci_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tpriv = rtllib_priv(dev);\n\tpriv->rtllib = (struct rtllib_device *)netdev_priv_rsl(dev);\n\tpriv->pdev = pdev;\n\tpriv->rtllib->pdev = pdev;\n\tif ((pdev->subsystem_vendor == PCI_VENDOR_ID_DLINK) &&\n\t    (pdev->subsystem_device == 0x3304))\n\t\tpriv->rtllib->bSupportRemoteWakeUp = 1;\n\telse\n\t\tpriv->rtllib->bSupportRemoteWakeUp = 0;\n\n\tpmem_start = pci_resource_start(pdev, 1);\n\tpmem_len = pci_resource_len(pdev, 1);\n\tpmem_flags = pci_resource_flags(pdev, 1);\n\n\tif (!(pmem_flags & IORESOURCE_MEM)) {\n\t\tnetdev_err(dev, \"region #1 not a MMIO resource, aborting\");\n\t\tgoto err_rel_rtllib;\n\t}\n\n\tdev_info(&pdev->dev, \"Memory mapped space start: 0x%08lx\\n\",\n\t\t pmem_start);\n\tif (!request_mem_region(pmem_start, pmem_len, DRV_NAME)) {\n\t\tnetdev_err(dev, \"request_mem_region failed!\");\n\t\tgoto err_rel_rtllib;\n\t}\n\n\tioaddr = (unsigned long)ioremap(pmem_start, pmem_len);\n\tif (ioaddr == (unsigned long)NULL) {\n\t\tnetdev_err(dev, \"ioremap failed!\");\n\t\tgoto err_rel_mem;\n\t}\n\n\tdev->mem_start = ioaddr;\n\tdev->mem_end = ioaddr + pci_resource_len(pdev, 0);\n\n\tif (!rtl92e_check_adapter(pdev, dev))\n\t\tgoto err_unmap;\n\n\tdev->irq = pdev->irq;\n\tpriv->irq = 0;\n\n\tdev->netdev_ops = &rtl8192_netdev_ops;\n\n\tdev->wireless_handlers = &r8192_wx_handlers_def;\n\tdev->ethtool_ops = &rtl819x_ethtool_ops;\n\n\tdev->type = ARPHRD_ETHER;\n\tdev->watchdog_timeo = HZ * 3;\n\n\tif (dev_alloc_name(dev, ifname) < 0)\n\t\tdev_alloc_name(dev, ifname);\n\n\tif (_rtl92e_init(dev) != 0) {\n\t\tnetdev_warn(dev, \"Initialization failed\");\n\t\tgoto err_free_irq;\n\t}\n\n\tnetif_carrier_off(dev);\n\tnetif_stop_queue(dev);\n\n\tif (register_netdev(dev))\n\t\tgoto err_free_irq;\n\n\tif (priv->polling_timer_on == 0)\n\t\trtl92e_check_rfctrl_gpio_timer(&priv->gpio_polling_timer);\n\n\treturn 0;\n\nerr_free_irq:\n\tfree_irq(dev->irq, dev);\n\tpriv->irq = 0;\nerr_unmap:\n\tiounmap((void __iomem *)ioaddr);\nerr_rel_mem:\n\trelease_mem_region(pmem_start, pmem_len);\nerr_rel_rtllib:\n\tfree_rtllib(dev);\nerr_pci_disable:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\nstatic void _rtl92e_pci_disconnect(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct r8192_priv *priv;\n\tu32 i;\n\n\tif (dev) {\n\t\tunregister_netdev(dev);\n\n\t\tpriv = rtllib_priv(dev);\n\n\t\tdel_timer_sync(&priv->gpio_polling_timer);\n\t\tcancel_delayed_work_sync(&priv->gpio_change_rf_wq);\n\t\tpriv->polling_timer_on = 0;\n\t\t_rtl92e_down(dev, true);\n\t\trtl92e_dm_deinit(dev);\n\t\tvfree(priv->fw_info);\n\t\tpriv->fw_info = NULL;\n\t\t_rtl92e_free_rx_ring(dev);\n\t\tfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++)\n\t\t\t_rtl92e_free_tx_ring(dev, i);\n\n\t\tif (priv->irq) {\n\t\t\tdev_info(&pdev->dev, \"Freeing irq %d\\n\", dev->irq);\n\t\t\tfree_irq(dev->irq, dev);\n\t\t\tpriv->irq = 0;\n\t\t}\n\n\t\tif (dev->mem_start != 0) {\n\t\t\tiounmap((void __iomem *)dev->mem_start);\n\t\t\trelease_mem_region(pci_resource_start(pdev, 1),\n\t\t\t\t\tpci_resource_len(pdev, 1));\n\t\t}\n\n\t\tfree_rtllib(dev);\n\t}\n\n\tpci_disable_device(pdev);\n}\n\nbool rtl92e_enable_nic(struct net_device *dev)\n{\n\tbool init_status = true;\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tstruct rt_pwr_save_ctrl *psc = (struct rt_pwr_save_ctrl *)\n\t\t\t\t\t(&priv->rtllib->pwr_save_ctrl);\n\n\tif (!priv->up) {\n\t\tnetdev_warn(dev, \"%s(): Driver is already down!\\n\", __func__);\n\t\treturn false;\n\t}\n\n\tinit_status = rtl92e_start_adapter(dev);\n\tif (!init_status) {\n\t\tnetdev_warn(dev, \"%s(): Initialization failed!\\n\", __func__);\n\t\treturn false;\n\t}\n\tRT_CLEAR_PS_LEVEL(psc, RT_RF_OFF_LEVL_HALT_NIC);\n\n\trtl92e_irq_enable(dev);\n\treturn init_status;\n}\n\nmodule_pci_driver(rtl8192_pci_driver);\n\nvoid rtl92e_check_rfctrl_gpio_timer(struct timer_list *t)\n{\n\tstruct r8192_priv *priv = from_timer(priv, t, gpio_polling_timer);\n\n\tpriv->polling_timer_on = 1;\n\n\tschedule_delayed_work(&priv->gpio_change_rf_wq, 0);\n\n\tmod_timer(&priv->gpio_polling_timer, jiffies +\n\t\t  msecs_to_jiffies(RTLLIB_WATCH_DOG_TIME));\n}\n\n \nMODULE_DESCRIPTION(\"Linux driver for Realtek RTL819x WiFi cards\");\nMODULE_AUTHOR(DRV_COPYRIGHT \" \" DRV_AUTHOR);\nMODULE_VERSION(DRV_VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(RTL8192E_BOOT_IMG_FW);\nMODULE_FIRMWARE(RTL8192E_MAIN_IMG_FW);\nMODULE_FIRMWARE(RTL8192E_DATA_IMG_FW);\n\nmodule_param(ifname, charp, 0644);\nmodule_param(hwwep, int, 0644);\n\nMODULE_PARM_DESC(ifname, \" Net interface name, wlan%d=default\");\nMODULE_PARM_DESC(hwwep, \" Try to use hardware WEP support(default use hw. set 0 to use software security)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}