{
  "module_name": "rtllib_crypt_wep.c",
  "hash_id": "15f703adade5074c46f71e4d3236b40ae2bd3ba7be5d40c50ce1d2bbb8f47c27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtllib_crypt_wep.c",
  "human_readable_source": "\n \n\n#include <crypto/arc4.h>\n#include <linux/fips.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/skbuff.h>\n#include <linux/string.h>\n#include \"rtllib.h\"\n\n#include <linux/crc32.h>\n\nstruct prism2_wep_data {\n\tu32 iv;\n#define WEP_KEY_LEN 13\n\tu8 key[WEP_KEY_LEN + 1];\n\tu8 key_len;\n\tu8 key_idx;\n\tstruct arc4_ctx rx_ctx_arc4;\n\tstruct arc4_ctx tx_ctx_arc4;\n};\n\nstatic void *prism2_wep_init(int keyidx)\n{\n\tstruct prism2_wep_data *priv;\n\n\tif (fips_enabled)\n\t\treturn NULL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_ATOMIC);\n\tif (priv == NULL)\n\t\treturn NULL;\n\tpriv->key_idx = keyidx;\n\n\t \n\tget_random_bytes(&priv->iv, 4);\n\n\treturn priv;\n}\n\nstatic void prism2_wep_deinit(void *priv)\n{\n\tkfree_sensitive(priv);\n}\n\n \nstatic int prism2_wep_encrypt(struct sk_buff *skb, int hdr_len, void *priv)\n{\n\tstruct prism2_wep_data *wep = priv;\n\tu32 klen, len;\n\tu8 key[WEP_KEY_LEN + 3];\n\tu8 *pos;\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb +\n\t\t\t\t    MAX_DEV_ADDR_SIZE);\n\tu32 crc;\n\tu8 *icv;\n\n\tif (skb_headroom(skb) < 4 || skb_tailroom(skb) < 4 ||\n\t    skb->len < hdr_len){\n\t\tpr_err(\"Error!!! headroom=%d tailroom=%d skblen=%d hdr_len=%d\\n\",\n\t\t       skb_headroom(skb), skb_tailroom(skb), skb->len, hdr_len);\n\t\treturn -1;\n\t}\n\tlen = skb->len - hdr_len;\n\tpos = skb_push(skb, 4);\n\tmemmove(pos, pos + 4, hdr_len);\n\tpos += hdr_len;\n\n\tklen = 3 + wep->key_len;\n\n\twep->iv++;\n\n\t \n\tif ((wep->iv & 0xff00) == 0xff00) {\n\t\tu8 B = (wep->iv >> 16) & 0xff;\n\n\t\tif (B >= 3 && B < klen)\n\t\t\twep->iv += 0x0100;\n\t}\n\n\t \n\t*pos++ = key[0] = (wep->iv >> 16) & 0xff;\n\t*pos++ = key[1] = (wep->iv >> 8) & 0xff;\n\t*pos++ = key[2] = wep->iv & 0xff;\n\t*pos++ = wep->key_idx << 6;\n\n\t \n\tmemcpy(key + 3, wep->key, wep->key_len);\n\n\tif (!tcb_desc->bHwSec) {\n\t\t \n\t\tcrc = ~crc32_le(~0, pos, len);\n\t\ticv = skb_put(skb, 4);\n\t\ticv[0] = crc;\n\t\ticv[1] = crc >> 8;\n\t\ticv[2] = crc >> 16;\n\t\ticv[3] = crc >> 24;\n\n\t\tarc4_setkey(&wep->tx_ctx_arc4, key, klen);\n\t\tarc4_crypt(&wep->tx_ctx_arc4, pos, pos, len + 4);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int prism2_wep_decrypt(struct sk_buff *skb, int hdr_len, void *priv)\n{\n\tstruct prism2_wep_data *wep = priv;\n\tu32  klen, plen;\n\tu8 key[WEP_KEY_LEN + 3];\n\tu8 keyidx, *pos;\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb +\n\t\t\t\t    MAX_DEV_ADDR_SIZE);\n\tu32 crc;\n\tu8 icv[4];\n\n\tif (skb->len < hdr_len + 8)\n\t\treturn -1;\n\n\tpos = skb->data + hdr_len;\n\tkey[0] = *pos++;\n\tkey[1] = *pos++;\n\tkey[2] = *pos++;\n\tkeyidx = *pos++ >> 6;\n\tif (keyidx != wep->key_idx)\n\t\treturn -1;\n\n\tklen = 3 + wep->key_len;\n\n\t \n\tmemcpy(key + 3, wep->key, wep->key_len);\n\n\t \n\tplen = skb->len - hdr_len - 8;\n\n\tif (!tcb_desc->bHwSec) {\n\t\tarc4_setkey(&wep->rx_ctx_arc4, key, klen);\n\t\tarc4_crypt(&wep->rx_ctx_arc4, pos, pos, plen + 4);\n\n\t\tcrc = ~crc32_le(~0, pos, plen);\n\t\ticv[0] = crc;\n\t\ticv[1] = crc >> 8;\n\t\ticv[2] = crc >> 16;\n\t\ticv[3] = crc >> 24;\n\t\tif (memcmp(icv, pos + plen, 4) != 0) {\n\t\t\t \n\t\t\treturn -2;\n\t\t}\n\t}\n\t \n\tmemmove(skb->data + 4, skb->data, hdr_len);\n\tskb_pull(skb, 4);\n\tskb_trim(skb, skb->len - 4);\n\n\treturn 0;\n}\n\nstatic int prism2_wep_set_key(void *key, int len, u8 *seq, void *priv)\n{\n\tstruct prism2_wep_data *wep = priv;\n\n\tif (len < 0 || len > WEP_KEY_LEN)\n\t\treturn -1;\n\n\tmemcpy(wep->key, key, len);\n\twep->key_len = len;\n\n\treturn 0;\n}\n\nstatic int prism2_wep_get_key(void *key, int len, u8 *seq, void *priv)\n{\n\tstruct prism2_wep_data *wep = priv;\n\n\tif (len < wep->key_len)\n\t\treturn -1;\n\n\tmemcpy(key, wep->key, wep->key_len);\n\n\treturn wep->key_len;\n}\n\nstatic void prism2_wep_print_stats(struct seq_file *m, void *priv)\n{\n\tstruct prism2_wep_data *wep = priv;\n\n\tseq_printf(m, \"key[%d] alg=WEP len=%d\\n\", wep->key_idx, wep->key_len);\n}\n\nstatic struct lib80211_crypto_ops rtllib_crypt_wep = {\n\t.name\t\t\t= \"R-WEP\",\n\t.init\t\t\t= prism2_wep_init,\n\t.deinit\t\t\t= prism2_wep_deinit,\n\t.encrypt_mpdu\t\t= prism2_wep_encrypt,\n\t.decrypt_mpdu\t\t= prism2_wep_decrypt,\n\t.encrypt_msdu\t\t= NULL,\n\t.decrypt_msdu\t\t= NULL,\n\t.set_key\t\t= prism2_wep_set_key,\n\t.get_key\t\t= prism2_wep_get_key,\n\t.print_stats\t\t= prism2_wep_print_stats,\n\t.extra_mpdu_prefix_len  = 4,\t \n\t.extra_mpdu_postfix_len = 4,\t \n\t.owner\t\t\t= THIS_MODULE,\n};\n\nstatic int __init rtllib_crypto_wep_init(void)\n{\n\treturn lib80211_register_crypto_ops(&rtllib_crypt_wep);\n}\n\nstatic void __exit rtllib_crypto_wep_exit(void)\n{\n\tlib80211_unregister_crypto_ops(&rtllib_crypt_wep);\n}\n\nmodule_init(rtllib_crypto_wep_init);\nmodule_exit(rtllib_crypto_wep_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}