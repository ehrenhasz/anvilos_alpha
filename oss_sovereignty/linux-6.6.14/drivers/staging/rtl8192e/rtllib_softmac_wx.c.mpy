{
  "module_name": "rtllib_softmac_wx.c",
  "hash_id": "88cb8f4030cb893f6bf07cfae79829f5d7fc254f77083b76c165a183b39c46c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtllib_softmac_wx.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n\n#include \"rtllib.h\"\n#include \"dot11d.h\"\n\nint rtllib_wx_set_freq(struct rtllib_device *ieee, struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tint ret;\n\tstruct iw_freq *fwrq = &wrqu->freq;\n\n\tmutex_lock(&ieee->wx_mutex);\n\n\tif (ieee->iw_mode == IW_MODE_INFRA) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (fwrq->e == 1) {\n\t\tif ((fwrq->m >= (int)2.412e8 &&\n\t\t     fwrq->m <= (int)2.487e8)) {\n\t\t\tfwrq->m = ieee80211_freq_khz_to_channel(fwrq->m / 100);\n\t\t\tfwrq->e = 0;\n\t\t}\n\t}\n\n\tif (fwrq->e > 0 || fwrq->m > 14 || fwrq->m < 1) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\n\t} else {  \n\n\t\tif (ieee->active_channel_map[fwrq->m] != 1) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tieee->current_network.channel = fwrq->m;\n\t\tieee->set_chan(ieee->dev, ieee->current_network.channel);\n\n\t\tif (ieee->iw_mode == IW_MODE_ADHOC)\n\t\t\tif (ieee->link_state == MAC80211_LINKED) {\n\t\t\t\trtllib_stop_send_beacons(ieee);\n\t\t\t\trtllib_start_send_beacons(ieee);\n\t\t\t}\n\t}\n\n\tret = 0;\nout:\n\tmutex_unlock(&ieee->wx_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(rtllib_wx_set_freq);\n\nint rtllib_wx_get_freq(struct rtllib_device *ieee,\n\t\t\t     struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tstruct iw_freq *fwrq = &wrqu->freq;\n\n\tif (ieee->current_network.channel == 0)\n\t\treturn -1;\n\tfwrq->m = ieee80211_channel_to_freq_khz(ieee->current_network.channel,\n\t\t\t\t\t\tNL80211_BAND_2GHZ) * 100;\n\tfwrq->e = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_get_freq);\n\nint rtllib_wx_get_wap(struct rtllib_device *ieee,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tunsigned long flags;\n\n\twrqu->ap_addr.sa_family = ARPHRD_ETHER;\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR)\n\t\treturn -1;\n\n\t \n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif (ieee->link_state != MAC80211_LINKED &&\n\t\tieee->link_state != MAC80211_LINKED_SCANNING &&\n\t\tieee->wap_set == 0)\n\n\t\teth_zero_addr(wrqu->ap_addr.sa_data);\n\telse\n\t\tmemcpy(wrqu->ap_addr.sa_data,\n\t\t       ieee->current_network.bssid, ETH_ALEN);\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_get_wap);\n\nint rtllib_wx_set_wap(struct rtllib_device *ieee,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *awrq,\n\t\t\t char *extra)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tshort ifup = ieee->proto_started;\n\tstruct sockaddr *temp = (struct sockaddr *)awrq;\n\n\trtllib_stop_scan_syncro(ieee);\n\n\tmutex_lock(&ieee->wx_mutex);\n\t \n\n\tif (temp->sa_family != ARPHRD_ETHER) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (is_zero_ether_addr(temp->sa_data)) {\n\t\tspin_lock_irqsave(&ieee->lock, flags);\n\t\tether_addr_copy(ieee->current_network.bssid, temp->sa_data);\n\t\tieee->wap_set = 0;\n\t\tspin_unlock_irqrestore(&ieee->lock, flags);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (ifup)\n\t\trtllib_stop_protocol(ieee, true);\n\n\t \n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tieee->cannot_notify = false;\n\tether_addr_copy(ieee->current_network.bssid, temp->sa_data);\n\tieee->wap_set = !is_zero_ether_addr(temp->sa_data);\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\n\tif (ifup)\n\t\trtllib_start_protocol(ieee);\nout:\n\tmutex_unlock(&ieee->wx_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(rtllib_wx_set_wap);\n\nint rtllib_wx_get_essid(struct rtllib_device *ieee, struct iw_request_info *a,\n\t\t\t union iwreq_data *wrqu, char *b)\n{\n\tint len, ret = 0;\n\tunsigned long flags;\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR)\n\t\treturn -1;\n\n\t \n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif (ieee->current_network.ssid[0] == '\\0' ||\n\t\tieee->current_network.ssid_len == 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (ieee->link_state != MAC80211_LINKED &&\n\t\tieee->link_state != MAC80211_LINKED_SCANNING &&\n\t\tieee->ssid_set == 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tlen = ieee->current_network.ssid_len;\n\twrqu->essid.length = len;\n\tstrncpy(b, ieee->current_network.ssid, len);\n\twrqu->essid.flags = 1;\n\nout:\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(rtllib_wx_get_essid);\n\nint rtllib_wx_set_rate(struct rtllib_device *ieee,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tu32 target_rate = wrqu->bitrate.value;\n\n\tieee->rate = target_rate / 100000;\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_set_rate);\n\nint rtllib_wx_get_rate(struct rtllib_device *ieee,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tu32 tmp_rate;\n\n\ttmp_rate = TxCountToDataRate(ieee,\n\t\t\t\t     ieee->softmac_stats.CurrentShowTxate);\n\twrqu->bitrate.value = tmp_rate * 500000;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_get_rate);\n\nint rtllib_wx_set_rts(struct rtllib_device *ieee,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tif (wrqu->rts.disabled || !wrqu->rts.fixed) {\n\t\tieee->rts = DEFAULT_RTS_THRESHOLD;\n\t} else {\n\t\tif (wrqu->rts.value < MIN_RTS_THRESHOLD ||\n\t\t\t\twrqu->rts.value > MAX_RTS_THRESHOLD)\n\t\t\treturn -EINVAL;\n\t\tieee->rts = wrqu->rts.value;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_set_rts);\n\nint rtllib_wx_get_rts(struct rtllib_device *ieee,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\twrqu->rts.value = ieee->rts;\n\twrqu->rts.fixed = 0;\t \n\twrqu->rts.disabled = (wrqu->rts.value == DEFAULT_RTS_THRESHOLD);\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_get_rts);\n\nint rtllib_wx_set_mode(struct rtllib_device *ieee, struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tint set_mode_status = 0;\n\n\trtllib_stop_scan_syncro(ieee);\n\tmutex_lock(&ieee->wx_mutex);\n\tswitch (wrqu->mode) {\n\tcase IW_MODE_MONITOR:\n\tcase IW_MODE_ADHOC:\n\tcase IW_MODE_INFRA:\n\t\tbreak;\n\tcase IW_MODE_AUTO:\n\t\twrqu->mode = IW_MODE_INFRA;\n\t\tbreak;\n\tdefault:\n\t\tset_mode_status = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (wrqu->mode == ieee->iw_mode)\n\t\tgoto out;\n\n\tif (wrqu->mode == IW_MODE_MONITOR) {\n\t\tieee->dev->type = ARPHRD_IEEE80211;\n\t\trtllib_EnableNetMonitorMode(ieee->dev, false);\n\t} else {\n\t\tieee->dev->type = ARPHRD_ETHER;\n\t\tif (ieee->iw_mode == IW_MODE_MONITOR)\n\t\t\trtllib_DisableNetMonitorMode(ieee->dev, false);\n\t}\n\n\tif (!ieee->proto_started) {\n\t\tieee->iw_mode = wrqu->mode;\n\t} else {\n\t\trtllib_stop_protocol(ieee, true);\n\t\tieee->iw_mode = wrqu->mode;\n\t\trtllib_start_protocol(ieee);\n\t}\n\nout:\n\tmutex_unlock(&ieee->wx_mutex);\n\treturn set_mode_status;\n}\nEXPORT_SYMBOL(rtllib_wx_set_mode);\n\nvoid rtllib_wx_sync_scan_wq(void *data)\n{\n\tstruct rtllib_device *ieee = container_of(data, struct rtllib_device, wx_sync_scan_wq);\n\tshort chan;\n\tenum ht_extchnl_offset chan_offset = 0;\n\tenum ht_channel_width bandwidth = 0;\n\tint b40M = 0;\n\n\tmutex_lock(&ieee->wx_mutex);\n\tif (!(ieee->softmac_features & IEEE_SOFTMAC_SCAN)) {\n\t\trtllib_start_scan_syncro(ieee);\n\t\tgoto out;\n\t}\n\n\tchan = ieee->current_network.channel;\n\n\tieee->leisure_ps_leave(ieee->dev);\n\t \n\trtllib_sta_ps_send_null_frame(ieee, 1);\n\trtllib_sta_ps_send_null_frame(ieee, 1);\n\n\trtllib_stop_all_queues(ieee);\n\trtllib_stop_send_beacons(ieee);\n\tieee->link_state = MAC80211_LINKED_SCANNING;\n\tieee->link_change(ieee->dev);\n\t \n\tmsleep(50);\n\n\tieee->ScanOperationBackupHandler(ieee->dev, SCAN_OPT_BACKUP);\n\n\tif (ieee->ht_info->bCurrentHTSupport && ieee->ht_info->enable_ht &&\n\t    ieee->ht_info->bCurBW40MHz) {\n\t\tb40M = 1;\n\t\tchan_offset = ieee->ht_info->CurSTAExtChnlOffset;\n\t\tbandwidth = (enum ht_channel_width)ieee->ht_info->bCurBW40MHz;\n\t\tieee->set_bw_mode_handler(ieee->dev, HT_CHANNEL_WIDTH_20,\n\t\t\t\t       HT_EXTCHNL_OFFSET_NO_EXT);\n\t}\n\n\trtllib_start_scan_syncro(ieee);\n\n\tif (b40M) {\n\t\tif (chan_offset == HT_EXTCHNL_OFFSET_UPPER)\n\t\t\tieee->set_chan(ieee->dev, chan + 2);\n\t\telse if (chan_offset == HT_EXTCHNL_OFFSET_LOWER)\n\t\t\tieee->set_chan(ieee->dev, chan - 2);\n\t\telse\n\t\t\tieee->set_chan(ieee->dev, chan);\n\t\tieee->set_bw_mode_handler(ieee->dev, bandwidth, chan_offset);\n\t} else {\n\t\tieee->set_chan(ieee->dev, chan);\n\t}\n\n\tieee->ScanOperationBackupHandler(ieee->dev, SCAN_OPT_RESTORE);\n\n\tieee->link_state = MAC80211_LINKED;\n\tieee->link_change(ieee->dev);\n\n\t \n\trtllib_sta_ps_send_null_frame(ieee, 0);\n\n\tif (ieee->link_detect_info.NumRecvBcnInPeriod == 0 ||\n\t    ieee->link_detect_info.NumRecvDataInPeriod == 0) {\n\t\tieee->link_detect_info.NumRecvBcnInPeriod = 1;\n\t\tieee->link_detect_info.NumRecvDataInPeriod = 1;\n\t}\n\tif (ieee->iw_mode == IW_MODE_ADHOC)\n\t\trtllib_start_send_beacons(ieee);\n\n\trtllib_wake_all_queues(ieee);\n\nout:\n\tmutex_unlock(&ieee->wx_mutex);\n}\n\nint rtllib_wx_set_scan(struct rtllib_device *ieee, struct iw_request_info *a,\n\t\t\t     union iwreq_data *wrqu, char *b)\n{\n\tint ret = 0;\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR || !(ieee->proto_started)) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (ieee->link_state == MAC80211_LINKED) {\n\t\tschedule_work(&ieee->wx_sync_scan_wq);\n\t\t \n\t\treturn 0;\n\t}\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(rtllib_wx_set_scan);\n\nint rtllib_wx_set_essid(struct rtllib_device *ieee,\n\t\t\tstruct iw_request_info *a,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tint ret = 0, len;\n\tshort proto_started;\n\tunsigned long flags;\n\n\trtllib_stop_scan_syncro(ieee);\n\tmutex_lock(&ieee->wx_mutex);\n\n\tproto_started = ieee->proto_started;\n\n\tlen = min_t(__u16, wrqu->essid.length, IW_ESSID_MAX_SIZE);\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (proto_started)\n\t\trtllib_stop_protocol(ieee, true);\n\n\t \n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif (wrqu->essid.flags && wrqu->essid.length) {\n\t\tstrncpy(ieee->current_network.ssid, extra, len);\n\t\tieee->current_network.ssid_len = len;\n\t\tieee->cannot_notify = false;\n\t\tieee->ssid_set = 1;\n\t} else {\n\t\tieee->ssid_set = 0;\n\t\tieee->current_network.ssid[0] = '\\0';\n\t\tieee->current_network.ssid_len = 0;\n\t}\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\n\tif (proto_started)\n\t\trtllib_start_protocol(ieee);\nout:\n\tmutex_unlock(&ieee->wx_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(rtllib_wx_set_essid);\n\nint rtllib_wx_get_mode(struct rtllib_device *ieee, struct iw_request_info *a,\n\t\t       union iwreq_data *wrqu, char *b)\n{\n\twrqu->mode = ieee->iw_mode;\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_get_mode);\n\nint rtllib_wx_set_rawtx(struct rtllib_device *ieee,\n\t\t\tstruct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tint *parms = (int *)extra;\n\tint enable = (parms[0] > 0);\n\tshort prev = ieee->raw_tx;\n\n\tmutex_lock(&ieee->wx_mutex);\n\n\tif (enable)\n\t\tieee->raw_tx = 1;\n\telse\n\t\tieee->raw_tx = 0;\n\n\tnetdev_info(ieee->dev, \"raw TX is %s\\n\",\n\t\t    ieee->raw_tx ? \"enabled\" : \"disabled\");\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tif (prev == 0 && ieee->raw_tx)\n\t\t\tnetif_carrier_on(ieee->dev);\n\n\t\tif (prev && ieee->raw_tx == 1)\n\t\t\tnetif_carrier_off(ieee->dev);\n\t}\n\n\tmutex_unlock(&ieee->wx_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_set_rawtx);\n\nint rtllib_wx_get_name(struct rtllib_device *ieee, struct iw_request_info *info,\n\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tconst char *n = ieee->mode & (WIRELESS_MODE_N_24G) ? \"n\" : \"\";\n\n\tscnprintf(wrqu->name, sizeof(wrqu->name), \"802.11bg%s\", n);\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_get_name);\n\n \nint rtllib_wx_set_power(struct rtllib_device *ieee,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tint ret = 0;\n\n\tif ((!ieee->sta_wake_up) ||\n\t    (!ieee->enter_sleep_state) ||\n\t    (!ieee->ps_is_queue_empty)) {\n\t\tnetdev_warn(ieee->dev,\n\t\t\t    \"%s(): PS mode is tried to be use but driver missed a callback\\n\",\n\t\t\t    __func__);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&ieee->wx_mutex);\n\n\tif (wrqu->power.disabled) {\n\t\tieee->ps = RTLLIB_PS_DISABLED;\n\t\tgoto exit;\n\t}\n\tif (wrqu->power.flags & IW_POWER_TIMEOUT)\n\t\tieee->ps_timeout = wrqu->power.value / 1000;\n\n\tif (wrqu->power.flags & IW_POWER_PERIOD)\n\t\tieee->ps_period = wrqu->power.value / 1000;\n\n\tswitch (wrqu->power.flags & IW_POWER_MODE) {\n\tcase IW_POWER_UNICAST_R:\n\t\tieee->ps = RTLLIB_PS_UNICAST;\n\t\tbreak;\n\tcase IW_POWER_MULTICAST_R:\n\t\tieee->ps = RTLLIB_PS_MBCAST;\n\t\tbreak;\n\tcase IW_POWER_ALL_R:\n\t\tieee->ps = RTLLIB_PS_UNICAST | RTLLIB_PS_MBCAST;\n\t\tbreak;\n\n\tcase IW_POWER_ON:\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\nexit:\n\tmutex_unlock(&ieee->wx_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(rtllib_wx_set_power);\n\n \nint rtllib_wx_get_power(struct rtllib_device *ieee,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tmutex_lock(&ieee->wx_mutex);\n\n\tif (ieee->ps == RTLLIB_PS_DISABLED) {\n\t\twrqu->power.disabled = 1;\n\t\tgoto exit;\n\t}\n\n\twrqu->power.disabled = 0;\n\n\tif ((wrqu->power.flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\n\t\twrqu->power.flags = IW_POWER_TIMEOUT;\n\t\twrqu->power.value = ieee->ps_timeout * 1000;\n\t} else {\n\t\twrqu->power.flags = IW_POWER_PERIOD;\n\t\twrqu->power.value = ieee->ps_period * 1000;\n\t}\n\n\tif ((ieee->ps & (RTLLIB_PS_MBCAST | RTLLIB_PS_UNICAST)) ==\n\t    (RTLLIB_PS_MBCAST | RTLLIB_PS_UNICAST))\n\t\twrqu->power.flags |= IW_POWER_ALL_R;\n\telse if (ieee->ps & RTLLIB_PS_MBCAST)\n\t\twrqu->power.flags |= IW_POWER_MULTICAST_R;\n\telse\n\t\twrqu->power.flags |= IW_POWER_UNICAST_R;\n\nexit:\n\tmutex_unlock(&ieee->wx_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_get_power);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}