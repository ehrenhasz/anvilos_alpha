{
  "module_name": "rtllib.h",
  "hash_id": "a438ca385a35e088de9be4dae1d321008937b823439bbdcf1ee0d9e342da4a32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtllib.h",
  "human_readable_source": " \n \n#ifndef RTLLIB_H\n#define RTLLIB_H\n#include <linux/if_ether.h>  \n#include <linux/kernel.h>    \n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\n#include <linux/delay.h>\n#include <linux/wireless.h>\n\n#include \"rtllib_debug.h\"\n#include \"rtl819x_HT.h\"\n#include \"rtl819x_BA.h\"\n#include \"rtl819x_TS.h\"\n\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>  \n#include <net/cfg80211.h>\n#include <net/lib80211.h>\n\n#define MAX_PRECMD_CNT 16\n#define MAX_RFDEPENDCMD_CNT 16\n#define MAX_POSTCMD_CNT 16\n\n#ifndef WIRELESS_SPY\n#define WIRELESS_SPY\n#endif\n#include <net/iw_handler.h>\n\n#ifndef IW_MODE_MONITOR\n#define IW_MODE_MONITOR 6\n#endif\n\n#ifndef IWEVCUSTOM\n#define IWEVCUSTOM 0x8c02\n#endif\n\n#ifndef IW_CUSTOM_MAX\n \n#define IW_CUSTOM_MAX\t256\t \n#endif\n\n#define container_of_dwork_rsl(x, y, z)\t\t\t\t\\\n\tcontainer_of(to_delayed_work(x), y, z)\n\nstatic inline void *netdev_priv_rsl(struct net_device *dev)\n{\n\treturn netdev_priv(dev);\n}\n\n#define KEY_TYPE_NA\t\t0x0\n#define KEY_TYPE_WEP40\t\t0x1\n#define KEY_TYPE_TKIP\t\t0x2\n#define KEY_TYPE_CCMP\t\t0x4\n#define KEY_TYPE_WEP104\t\t0x5\n \n#define MAX_QUEUE_SIZE\t\t0x10\n\n#define BK_QUEUE\t\t\t       0\n#define BE_QUEUE\t\t\t       1\n#define VI_QUEUE\t\t\t       2\n#define VO_QUEUE\t\t\t       3\n#define HCCA_QUEUE\t\t\t     4\n#define TXCMD_QUEUE\t\t\t    5\n#define MGNT_QUEUE\t\t\t     6\n#define HIGH_QUEUE\t\t\t     7\n#define BEACON_QUEUE\t\t\t   8\n\n#define IE_CISCO_FLAG_POSITION\t\t0x08\n#define SUPPORT_CKIP_MIC\t\t\t0x08\n#define SUPPORT_CKIP_PK\t\t\t0x10\n#define\tRT_RF_OFF_LEVL_HALT_NIC\t\tBIT3\n#define\tRT_IN_PS_LEVEL(psc, _PS_FLAG)\t\t\\\n\t((psc->CurPsLevel & _PS_FLAG) ? true : false)\n#define\tRT_CLEAR_PS_LEVEL(psc, _PS_FLAG)\t\\\n\t(psc->CurPsLevel &= (~(_PS_FLAG)))\n\n \n \nstruct cb_desc {\n\t \n\tu8 bLastIniPkt:1;\n\tu8 bCmdOrInit:1;\n\tu8 bFirstSeg:1;\n\tu8 bLastSeg:1;\n\tu8 bEncrypt:1;\n\tu8 tx_dis_rate_fallback:1;\n\tu8 tx_use_drv_assinged_rate:1;\n\tu8 bHwSec:1;\n\n\tu8 nStuckCount;\n\n\t \n\tu8 bCTSEnable:1;\n\tu8 bRTSEnable:1;\n\tu8 bUseShortGI:1;\n\tu8 bUseShortPreamble:1;\n\tu8 bTxEnableFwCalcDur:1;\n\tu8 bAMPDUEnable:1;\n\tu8 bRTSSTBC:1;\n\tu8 RTSSC:1;\n\n\tu8 bRTSBW:1;\n\tu8 bPacketBW:1;\n\tu8 bRTSUseShortPreamble:1;\n\tu8 bRTSUseShortGI:1;\n\tu8 bMulticast:1;\n\tu8 bBroadcast:1;\n\tu8 drv_agg_enable:1;\n\tu8 reserved2:1;\n\n\t \n\tu8 rata_index;\n\tu8 queue_index;\n\tu16 txbuf_size;\n\tu8 ratr_index;\n\tu8 bAMSDU:1;\n\tu8 bFromAggrQ:1;\n\tu8 reserved6:6;\n\tu8 macId;\n\tu8 priority;\n\n\t \n\tu8 data_rate;\n\tu8 rts_rate;\n\tu8 ampdu_factor;\n\tu8 ampdu_density;\n\tu8 DrvAggrNum;\n\tu8 bdhcp;\n\tu16 pkt_size;\n\tu8 bIsSpecialDataFrame;\n\n\tu8 bBTTxPacket;\n\tu8 bIsBTProbRsp;\n};\n\nenum sw_chnl_cmd_id {\n\tCmdID_End,\n\tCmdID_SetTxPowerLevel,\n\tCmdID_BBRegWrite10,\n\tCmdID_WritePortUlong,\n\tCmdID_WritePortUshort,\n\tCmdID_WritePortUchar,\n\tCmdID_RF_WriteReg,\n};\n\nstruct sw_chnl_cmd {\n\tenum sw_chnl_cmd_id CmdID;\n\tu32\t\t\tPara1;\n\tu32\t\t\tPara2;\n\tu32\t\t\tmsDelay;\n} __packed;\n\n \n#define MGN_1M\t\t  0x02\n#define MGN_2M\t\t  0x04\n#define MGN_5_5M\t\t0x0b\n#define MGN_11M\t\t 0x16\n\n#define MGN_6M\t\t  0x0c\n#define MGN_9M\t\t  0x12\n#define MGN_12M\t\t 0x18\n#define MGN_18M\t\t 0x24\n#define MGN_24M\t\t 0x30\n#define MGN_36M\t\t 0x48\n#define MGN_48M\t\t 0x60\n#define MGN_54M\t\t 0x6c\n\n#define MGN_MCS0\t\t0x80\n#define MGN_MCS1\t\t0x81\n#define MGN_MCS2\t\t0x82\n#define MGN_MCS3\t\t0x83\n#define MGN_MCS4\t\t0x84\n#define MGN_MCS5\t\t0x85\n#define MGN_MCS6\t\t0x86\n#define MGN_MCS7\t\t0x87\n#define MGN_MCS8\t\t0x88\n#define MGN_MCS9\t\t0x89\n#define MGN_MCS10\t       0x8a\n#define MGN_MCS11\t       0x8b\n#define MGN_MCS12\t       0x8c\n#define MGN_MCS13\t       0x8d\n#define MGN_MCS14\t       0x8e\n#define MGN_MCS15\t       0x8f\n\nenum hw_variables {\n\tHW_VAR_ETHER_ADDR,\n\tHW_VAR_MULTICAST_REG,\n\tHW_VAR_BASIC_RATE,\n\tHW_VAR_BSSID,\n\tHW_VAR_MEDIA_STATUS,\n\tHW_VAR_SECURITY_CONF,\n\tHW_VAR_BEACON_INTERVAL,\n\tHW_VAR_ATIM_WINDOW,\n\tHW_VAR_LISTEN_INTERVAL,\n\tHW_VAR_CS_COUNTER,\n\tHW_VAR_DEFAULTKEY0,\n\tHW_VAR_DEFAULTKEY1,\n\tHW_VAR_DEFAULTKEY2,\n\tHW_VAR_DEFAULTKEY3,\n\tHW_VAR_SIFS,\n\tHW_VAR_DIFS,\n\tHW_VAR_EIFS,\n\tHW_VAR_SLOT_TIME,\n\tHW_VAR_ACK_PREAMBLE,\n\tHW_VAR_CW_CONFIG,\n\tHW_VAR_CW_VALUES,\n\tHW_VAR_RATE_FALLBACK_CONTROL,\n\tHW_VAR_CONTENTION_WINDOW,\n\tHW_VAR_RETRY_COUNT,\n\tHW_VAR_TR_SWITCH,\n\tHW_VAR_COMMAND,\n\tHW_VAR_WPA_CONFIG,\n\tHW_VAR_AMPDU_MIN_SPACE,\n\tHW_VAR_SHORTGI_DENSITY,\n\tHW_VAR_AMPDU_FACTOR,\n\tHW_VAR_MCS_RATE_AVAILABLE,\n\tHW_VAR_AC_PARAM,\n\tHW_VAR_ACM_CTRL,\n\tHW_VAR_DIS_Req_Qsize,\n\tHW_VAR_CCX_CHNL_LOAD,\n\tHW_VAR_CCX_NOISE_HISTOGRAM,\n\tHW_VAR_CCX_CLM_NHM,\n\tHW_VAR_TxOPLimit,\n\tHW_VAR_TURBO_MODE,\n\tHW_VAR_RF_STATE,\n\tHW_VAR_RF_OFF_BY_HW,\n\tHW_VAR_BUS_SPEED,\n\tHW_VAR_SET_DEV_POWER,\n\n\tHW_VAR_RCR,\n\tHW_VAR_RATR_0,\n\tHW_VAR_RRSR,\n\tHW_VAR_CPU_RST,\n\tHW_VAR_CECHK_BSSID,\n\tHW_VAR_LBK_MODE,\n\tHW_VAR_AES_11N_FIX,\n\tHW_VAR_USB_RX_AGGR,\n\tHW_VAR_USER_CONTROL_TURBO_MODE,\n\tHW_VAR_RETRY_LIMIT,\n\tHW_VAR_INIT_TX_RATE,\n\tHW_VAR_TX_RATE_REG,\n\tHW_VAR_EFUSE_USAGE,\n\tHW_VAR_EFUSE_BYTES,\n\tHW_VAR_AUTOLOAD_STATUS,\n\tHW_VAR_RF_2R_DISABLE,\n\tHW_VAR_SET_RPWM,\n\tHW_VAR_H2C_FW_PWRMODE,\n\tHW_VAR_H2C_FW_JOINBSSRPT,\n\tHW_VAR_1X1_RECV_COMBINE,\n\tHW_VAR_STOP_SEND_BEACON,\n\tHW_VAR_TSF_TIMER,\n\tHW_VAR_IO_CMD,\n\n\tHW_VAR_RF_RECOVERY,\n\tHW_VAR_H2C_FW_UPDATE_GTK,\n\tHW_VAR_WF_MASK,\n\tHW_VAR_WF_CRC,\n\tHW_VAR_WF_IS_MAC_ADDR,\n\tHW_VAR_H2C_FW_OFFLOAD,\n\tHW_VAR_RESET_WFCRC,\n\n\tHW_VAR_HANDLE_FW_C2H,\n\tHW_VAR_DL_FW_RSVD_PAGE,\n\tHW_VAR_AID,\n\tHW_VAR_HW_SEQ_ENABLE,\n\tHW_VAR_CORRECT_TSF,\n\tHW_VAR_BCN_VALID,\n\tHW_VAR_FWLPS_RF_ON,\n\tHW_VAR_DUAL_TSF_RST,\n\tHW_VAR_SWITCH_EPHY_WoWLAN,\n\tHW_VAR_INT_MIGRATION,\n\tHW_VAR_INT_AC,\n\tHW_VAR_RF_TIMING,\n};\n\nenum rt_op_mode {\n\tRT_OP_MODE_AP,\n\tRT_OP_MODE_INFRASTRUCTURE,\n\tRT_OP_MODE_IBSS,\n\tRT_OP_MODE_NO_LINK,\n};\n\n#define aSifsTime\t\t\t\t\t\t\\\n\t ((priv->rtllib->current_network.mode == WIRELESS_MODE_N_24G) ? 16 : 10)\n\n#define MGMT_QUEUE_NUM 5\n\n#define MAX_IE_LEN  0xff\n\n#define msleep_interruptible_rsl  msleep_interruptible\n\n \n#define RTLLIB_1ADDR_LEN 10\n#define RTLLIB_2ADDR_LEN 16\n#define RTLLIB_3ADDR_LEN 24\n#define RTLLIB_4ADDR_LEN 30\n#define RTLLIB_FCS_LEN    4\n\n#define RTLLIB_SKBBUFFER_SIZE 2500\n\n#define MIN_FRAG_THRESHOLD     256U\n#define MAX_FRAG_THRESHOLD     2346U\n\n \n#define RTLLIB_FCTL_FTYPE\t\t0x000c\n#define RTLLIB_FCTL_STYPE\t\t0x00f0\n#define RTLLIB_FCTL_FRAMETYPE\t0x00fc\n#define RTLLIB_FCTL_TODS\t\t0x0100\n#define RTLLIB_FCTL_FROMDS\t\t0x0200\n#define RTLLIB_FCTL_DSTODS\t\t0x0300\n#define RTLLIB_FCTL_MOREFRAGS\t0x0400\n#define RTLLIB_FCTL_RETRY\t\t0x0800\n#define RTLLIB_FCTL_PM\t\t0x1000\n#define RTLLIB_FCTL_MOREDATA\t\t0x2000\n#define RTLLIB_FCTL_WEP\t\t0x4000\n#define RTLLIB_FCTL_ORDER\t\t0x8000\n\n#define RTLLIB_FTYPE_MGMT\t\t0x0000\n#define RTLLIB_FTYPE_CTL\t\t0x0004\n#define RTLLIB_FTYPE_DATA\t\t0x0008\n\n \n#define RTLLIB_STYPE_ASSOC_REQ\t0x0000\n#define RTLLIB_STYPE_ASSOC_RESP\t\t0x0010\n#define RTLLIB_STYPE_REASSOC_REQ\t0x0020\n#define RTLLIB_STYPE_REASSOC_RESP\t0x0030\n#define RTLLIB_STYPE_PROBE_REQ\t0x0040\n#define RTLLIB_STYPE_PROBE_RESP\t0x0050\n#define RTLLIB_STYPE_BEACON\t\t0x0080\n#define RTLLIB_STYPE_ATIM\t\t0x0090\n#define RTLLIB_STYPE_DISASSOC\t0x00A0\n#define RTLLIB_STYPE_AUTH\t\t0x00B0\n#define RTLLIB_STYPE_DEAUTH\t\t0x00C0\n#define RTLLIB_STYPE_MANAGE_ACT\t0x00D0\n\n \n#define RTLLIB_STYPE_PSPOLL\t\t0x00A0\n#define RTLLIB_STYPE_RTS\t\t0x00B0\n#define RTLLIB_STYPE_CTS\t\t0x00C0\n#define RTLLIB_STYPE_ACK\t\t0x00D0\n\n \n#define RTLLIB_STYPE_DATA\t\t0x0000\n#define RTLLIB_STYPE_DATA_CFACK\t0x0010\n#define RTLLIB_STYPE_DATA_CFPOLL\t0x0020\n#define RTLLIB_STYPE_DATA_CFACKPOLL\t0x0030\n#define RTLLIB_STYPE_NULLFUNC\t0x0040\n#define RTLLIB_STYPE_QOS_DATA\t0x0080\n#define RTLLIB_STYPE_QOS_NULL\t0x00C0\n\n#define RTLLIB_SCTL_FRAG\t\t0x000F\n#define RTLLIB_SCTL_SEQ\t\t0xFFF0\n\n \n#define RTLLIB_QCTL_TID\t      0x000F\n\n#define\tFC_QOS_BIT\t\t\t\t\tBIT7\n#define IsDataFrame(pdu)\t(((pdu[0] & 0x0C) == 0x08) ? true : false)\n#define\tIsLegacyDataFrame(pdu)\t(IsDataFrame(pdu) && (!(pdu[0]&FC_QOS_BIT)))\n#define IsQoSDataFrame(pframe)\t\t\t\\\n\t((*(u16 *)pframe&(RTLLIB_STYPE_QOS_DATA|RTLLIB_FTYPE_DATA)) ==\t\\\n\t(RTLLIB_STYPE_QOS_DATA|RTLLIB_FTYPE_DATA))\n#define Frame_Order(pframe)     (*(u16 *)pframe&RTLLIB_FCTL_ORDER)\n#define SN_LESS(a, b)\t\t(((a-b)&0x800) != 0)\n#define SN_EQUAL(a, b)\t(a == b)\n#define MAX_DEV_ADDR_SIZE 8\n\nenum act_category {\n\tACT_CAT_QOS = 1,\n\tACT_CAT_DLS = 2,\n\tACT_CAT_BA  = 3,\n\tACT_CAT_HT  = 7,\n\tACT_CAT_WMM = 17,\n};\n\nenum ba_action {\n\tACT_ADDBAREQ = 0,\n\tACT_ADDBARSP = 1,\n\tACT_DELBA    = 2,\n};\n\nenum init_gain_op_type {\n\tIG_Backup = 0,\n\tIG_Restore,\n\tIG_Max\n};\n\nenum wireless_mode {\n\tWIRELESS_MODE_UNKNOWN = 0x00,\n\tWIRELESS_MODE_A = 0x01,\n\tWIRELESS_MODE_B = 0x02,\n\tWIRELESS_MODE_G = 0x04,\n\tWIRELESS_MODE_AUTO = 0x08,\n\tWIRELESS_MODE_N_24G = 0x10,\n};\n\n#ifndef ETH_P_PAE\n#define ETH_P_PAE\t0x888E\t\t \n#define ETH_P_IP\t0x0800\t\t \n#define ETH_P_ARP\t0x0806\t\t \n#endif  \n\n#ifndef ETH_P_80211_RAW\n#define ETH_P_80211_RAW (ETH_P_ECONET + 1)\n#endif\n\n \n\n#define P80211_OUI_LEN 3\n\nstruct rtllib_snap_hdr {\n\tu8    dsap;    \n\tu8    ssap;    \n\tu8    ctrl;    \n\tu8    oui[P80211_OUI_LEN];     \n\n} __packed;\n\nenum _REG_PREAMBLE_MODE {\n\tPREAMBLE_LONG = 1,\n\tPREAMBLE_AUTO = 2,\n\tPREAMBLE_SHORT = 3,\n};\n\n#define SNAP_SIZE sizeof(struct rtllib_snap_hdr)\n\n#define WLAN_FC_GET_TYPE(fc) ((fc) & RTLLIB_FCTL_FTYPE)\n#define WLAN_FC_GET_STYPE(fc) ((fc) & RTLLIB_FCTL_STYPE)\n#define WLAN_FC_MORE_DATA(fc) ((fc) & RTLLIB_FCTL_MOREDATA)\n\n#define WLAN_FC_GET_FRAMETYPE(fc) ((fc) & RTLLIB_FCTL_FRAMETYPE)\n#define WLAN_GET_SEQ_FRAG(seq) ((seq) & RTLLIB_SCTL_FRAG)\n#define WLAN_GET_SEQ_SEQ(seq)  (((seq) & RTLLIB_SCTL_SEQ) >> 4)\n\n \n#define WLAN_AUTH_OPEN 0\n#define WLAN_AUTH_SHARED_KEY 1\n#define WLAN_AUTH_LEAP 128\n\n#define WLAN_CAPABILITY_ESS (1<<0)\n#define WLAN_CAPABILITY_IBSS (1<<1)\n#define WLAN_CAPABILITY_PRIVACY (1<<4)\n#define WLAN_CAPABILITY_SHORT_PREAMBLE (1<<5)\n#define WLAN_CAPABILITY_SHORT_SLOT_TIME (1<<10)\n\n#define RTLLIB_STATMASK_SIGNAL (1<<0)\n#define RTLLIB_STATMASK_RSSI (1<<1)\n#define RTLLIB_STATMASK_NOISE (1<<2)\n#define RTLLIB_STATMASK_WEMASK 0x7\n\n#define RTLLIB_CCK_MODULATION    (1<<0)\n#define RTLLIB_OFDM_MODULATION   (1<<1)\n\n#define RTLLIB_CCK_RATE_LEN\t\t4\n#define RTLLIB_CCK_RATE_1MB\t\t\t0x02\n#define RTLLIB_CCK_RATE_2MB\t\t\t0x04\n#define RTLLIB_CCK_RATE_5MB\t\t\t0x0B\n#define RTLLIB_CCK_RATE_11MB\t\t\t0x16\n#define RTLLIB_OFDM_RATE_LEN\t\t8\n#define RTLLIB_OFDM_RATE_6MB\t\t\t0x0C\n#define RTLLIB_OFDM_RATE_9MB\t\t\t0x12\n#define RTLLIB_OFDM_RATE_12MB\t\t0x18\n#define RTLLIB_OFDM_RATE_18MB\t\t0x24\n#define RTLLIB_OFDM_RATE_24MB\t\t0x30\n#define RTLLIB_OFDM_RATE_36MB\t\t0x48\n#define RTLLIB_OFDM_RATE_48MB\t\t0x60\n#define RTLLIB_OFDM_RATE_54MB\t\t0x6C\n#define RTLLIB_BASIC_RATE_MASK\t\t0x80\n\n \n#define RTLLIB_FC0_TYPE_MASK\t\t0x0c\n#define RTLLIB_FC0_TYPE_DATA\t\t0x08\n#define RTLLIB_FC0_SUBTYPE_MASK\t0xB0\n#define RTLLIB_FC0_SUBTYPE_QOS\t0x80\n\n#define RTLLIB_QOS_HAS_SEQ(fc) \\\n\t(((fc) & (RTLLIB_FC0_TYPE_MASK | RTLLIB_FC0_SUBTYPE_MASK)) == \\\n\t (RTLLIB_FC0_TYPE_DATA | RTLLIB_FC0_SUBTYPE_QOS))\n\n \n#define IEEE_IBSS_MAC_HASH_SIZE 31\nstruct ieee_ibss_seq {\n\tu8 mac[ETH_ALEN];\n\tu16 seq_num[17];\n\tu16 frag_num[17];\n\tunsigned long packet_time[17];\n\tstruct list_head list;\n};\n\n \nstruct rtllib_rx_stats {\n\tu64 mac_time;\n\ts8  rssi;\n\tu8  signal;\n\tu8  noise;\n\tu16 rate;  \n\tu8  control;\n\tu8  mask;\n\tu16 len;\n\tu64 tsf;\n\tu32 beacon_time;\n\tu8  nic_type;\n\tu16 Length;\n\tu8  SignalQuality;\n\ts32 RecvSignalPower;\n\ts8  RxPower;\n\tu8  SignalStrength;\n\tu16 bHwError:1;\n\tu16 bCRC:1;\n\tu16 bICV:1;\n\tu16 bShortPreamble:1;\n\tu16 Antenna:1;\n\tu16 Decrypted:1;\n\tu16 Wakeup:1;\n\tu16 Reserved0:1;\n\tu8  AGC;\n\tu32 TimeStampLow;\n\tu32 TimeStampHigh;\n\tbool bShift;\n\tbool bIsQosData;\n\n\tu8    RxDrvInfoSize;\n\tu8    RxBufShift;\n\tbool  bIsAMPDU;\n\tbool  bFirstMPDU;\n\tbool  bContainHTC;\n\tbool  RxIs40MHzPacket;\n\tu32   RxPWDBAll;\n\tu8    RxMIMOSignalStrength[4];\n\ts8    RxMIMOSignalQuality[2];\n\tbool  bPacketMatchBSSID;\n\tbool  bIsCCK;\n\tbool  bPacketToSelf;\n\tu16    packetlength;\n\tu16    fraglength;\n\tu16    fragoffset;\n\tu16    ntotalfrag;\n\tbool   bPacketBeacon;\n\tbool   bToSelfBA;\n\tu16    Seq_Num;\n};\n\n \n#define RTLLIB_FRAG_CACHE_LEN 4\n\nstruct rtllib_frag_entry {\n\tunsigned long first_frag_time;\n\tunsigned int seq;\n\tunsigned int last_frag;\n\tstruct sk_buff *skb;\n\tu8 src_addr[ETH_ALEN];\n\tu8 dst_addr[ETH_ALEN];\n};\n\nstruct rtllib_device;\n\n#define SEC_ACTIVE_KEY    (1<<4)\n#define SEC_AUTH_MODE     (1<<5)\n#define SEC_UNICAST_GROUP (1<<6)\n#define SEC_LEVEL\t (1<<7)\n#define SEC_ENABLED       (1<<8)\n\n#define SEC_LEVEL_0      0  \n#define SEC_LEVEL_1      1  \n#define SEC_LEVEL_2      2  \n#define SEC_LEVEL_2_CKIP 3  \n#define SEC_LEVEL_3      4  \n\n#define SEC_ALG_NONE\t\t0\n#define SEC_ALG_WEP\t\t1\n#define SEC_ALG_TKIP\t\t2\n#define SEC_ALG_CCMP\t\t4\n\n#define WEP_KEY_LEN\t\t13\n#define SCM_KEY_LEN\t\t32\n\nstruct rtllib_security {\n\tu16 active_key:2,\n\t    enabled:1,\n\t    auth_mode:2,\n\t    auth_algo:4,\n\t    unicast_uses_group:1,\n\t    encrypt:1;\n\tu8 key_sizes[NUM_WEP_KEYS];\n\tu8 keys[NUM_WEP_KEYS][SCM_KEY_LEN];\n\tu8 level;\n\tu16 flags;\n} __packed;\n\n \n\n \nenum rtllib_mfie {\n\tMFIE_TYPE_SSID = 0,\n\tMFIE_TYPE_RATES = 1,\n\tMFIE_TYPE_FH_SET = 2,\n\tMFIE_TYPE_DS_SET = 3,\n\tMFIE_TYPE_CF_SET = 4,\n\tMFIE_TYPE_TIM = 5,\n\tMFIE_TYPE_IBSS_SET = 6,\n\tMFIE_TYPE_COUNTRY = 7,\n\tMFIE_TYPE_HOP_PARAMS = 8,\n\tMFIE_TYPE_HOP_TABLE = 9,\n\tMFIE_TYPE_REQUEST = 10,\n\tMFIE_TYPE_CHALLENGE = 16,\n\tMFIE_TYPE_POWER_CONSTRAINT = 32,\n\tMFIE_TYPE_POWER_CAPABILITY = 33,\n\tMFIE_TYPE_TPC_REQUEST = 34,\n\tMFIE_TYPE_TPC_REPORT = 35,\n\tMFIE_TYPE_SUPP_CHANNELS = 36,\n\tMFIE_TYPE_CSA = 37,\n\tMFIE_TYPE_MEASURE_REQUEST = 38,\n\tMFIE_TYPE_MEASURE_REPORT = 39,\n\tMFIE_TYPE_QUIET = 40,\n\tMFIE_TYPE_IBSS_DFS = 41,\n\tMFIE_TYPE_ERP = 42,\n\tMFIE_TYPE_HT_CAP = 45,\n\tMFIE_TYPE_RSN = 48,\n\tMFIE_TYPE_RATES_EX = 50,\n\tMFIE_TYPE_HT_INFO = 61,\n\tMFIE_TYPE_AIRONET = 133,\n\tMFIE_TYPE_GENERIC = 221,\n\tMFIE_TYPE_QOS_PARAMETER = 222,\n};\n\n \nstruct rtllib_pspoll_hdr {\n\t__le16 frame_ctl;\n\t__le16 aid;\n\tu8 bssid[ETH_ALEN];\n\tu8 ta[ETH_ALEN];\n} __packed;\n\nstruct rtllib_hdr {\n\t__le16 frame_ctl;\n\t__le16 duration_id;\n\tu8 payload[];\n} __packed;\n\nstruct rtllib_hdr_1addr {\n\t__le16 frame_ctl;\n\t__le16 duration_id;\n\tu8 addr1[ETH_ALEN];\n\tu8 payload[];\n} __packed;\n\nstruct rtllib_hdr_2addr {\n\t__le16 frame_ctl;\n\t__le16 duration_id;\n\tu8 addr1[ETH_ALEN];\n\tu8 addr2[ETH_ALEN];\n\tu8 payload[];\n} __packed;\n\nstruct rtllib_hdr_3addr {\n\t__le16 frame_ctl;\n\t__le16 duration_id;\n\tu8 addr1[ETH_ALEN];\n\tu8 addr2[ETH_ALEN];\n\tu8 addr3[ETH_ALEN];\n\t__le16 seq_ctl;\n\tu8 payload[];\n} __packed;\n\nstruct rtllib_hdr_4addr {\n\t__le16 frame_ctl;\n\t__le16 duration_id;\n\tu8 addr1[ETH_ALEN];\n\tu8 addr2[ETH_ALEN];\n\tu8 addr3[ETH_ALEN];\n\t__le16 seq_ctl;\n\tu8 addr4[ETH_ALEN];\n\tu8 payload[];\n} __packed;\n\nstruct rtllib_hdr_3addrqos {\n\t__le16 frame_ctl;\n\t__le16 duration_id;\n\tu8 addr1[ETH_ALEN];\n\tu8 addr2[ETH_ALEN];\n\tu8 addr3[ETH_ALEN];\n\t__le16 seq_ctl;\n\t__le16 qos_ctl;\n\tu8 payload[];\n} __packed;\n\nstruct rtllib_hdr_4addrqos {\n\t__le16 frame_ctl;\n\t__le16 duration_id;\n\tu8 addr1[ETH_ALEN];\n\tu8 addr2[ETH_ALEN];\n\tu8 addr3[ETH_ALEN];\n\t__le16 seq_ctl;\n\tu8 addr4[ETH_ALEN];\n\t__le16 qos_ctl;\n\tu8 payload[];\n} __packed;\n\nstruct rtllib_info_element {\n\tu8 id;\n\tu8 len;\n\tu8 data[];\n} __packed;\n\nstruct rtllib_authentication {\n\tstruct rtllib_hdr_3addr header;\n\t__le16 algorithm;\n\t__le16 transaction;\n\t__le16 status;\n\t \n\tstruct rtllib_info_element info_element[];\n} __packed;\n\nstruct rtllib_disauth {\n\tstruct rtllib_hdr_3addr header;\n\t__le16 reason;\n} __packed;\n\nstruct rtllib_disassoc {\n\tstruct rtllib_hdr_3addr header;\n\t__le16 reason;\n} __packed;\n\nstruct rtllib_probe_request {\n\tstruct rtllib_hdr_3addr header;\n\t \n\tstruct rtllib_info_element info_element[];\n} __packed;\n\nstruct rtllib_probe_response {\n\tstruct rtllib_hdr_3addr header;\n\tu32 time_stamp[2];\n\t__le16 beacon_interval;\n\t__le16 capability;\n\t \n\tstruct rtllib_info_element info_element[];\n} __packed;\n\n \n#define rtllib_beacon rtllib_probe_response\n\nstruct rtllib_assoc_request_frame {\n\tstruct rtllib_hdr_3addr header;\n\t__le16 capability;\n\t__le16 listen_interval;\n\t \n\tstruct rtllib_info_element info_element[];\n} __packed;\n\nstruct rtllib_assoc_response_frame {\n\tstruct rtllib_hdr_3addr header;\n\t__le16 capability;\n\t__le16 status;\n\t__le16 aid;\n\tstruct rtllib_info_element info_element[];  \n} __packed;\n\nstruct rtllib_txb {\n\tu8 nr_frags;\n\tu8 encrypted;\n\tu8 queue_index;\n\tu8 rts_included;\n\tu16 reserved;\n\t__le16 frag_size;\n\t__le16 payload_size;\n\tstruct sk_buff *fragments[] __counted_by(nr_frags);\n};\n\n#define MAX_SUBFRAME_COUNT\t\t  64\nstruct rtllib_rxb {\n\tu8 nr_subframes;\n\tstruct sk_buff *subframes[MAX_SUBFRAME_COUNT];\n\tu8 dst[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n} __packed;\n\nunion frameqos {\n\tu16 shortdata;\n\tu8  chardata[2];\n\tstruct {\n\t\tu16 tid:4;\n\t\tu16 eosp:1;\n\t\tu16 ack_policy:2;\n\t\tu16 reserved:1;\n\t\tu16 txop:8;\n\t} field;\n};\n\n \n#define MAX_RATES_LENGTH\t\t  ((u8)12)\n#define MAX_RATES_EX_LENGTH\t       ((u8)16)\n#define MAX_NETWORK_COUNT\t\t  96\n\n#define MAX_CHANNEL_NUMBER\t\t 161\n#define RTLLIB_SOFTMAC_SCAN_TIME\t   100\n#define RTLLIB_SOFTMAC_ASSOC_RETRY_TIME (HZ * 2)\n\n#define MAX_WPA_IE_LEN 64\n#define MAX_WZC_IE_LEN 256\n\n#define NETWORK_EMPTY_ESSID (1<<0)\n#define NETWORK_HAS_OFDM    (1<<1)\n#define NETWORK_HAS_CCK     (1<<2)\n\n \n#define NETWORK_HAS_QOS_PARAMETERS      (1<<3)\n#define NETWORK_HAS_QOS_INFORMATION     (1<<4)\n#define NETWORK_HAS_QOS_MASK\t    (NETWORK_HAS_QOS_PARAMETERS | \\\n\t\t\t\t\t NETWORK_HAS_QOS_INFORMATION)\n \n#define NETWORK_HAS_ERP_VALUE\t   (1<<10)\n\n#define QOS_QUEUE_NUM\t\t   4\n#define QOS_OUI_LEN\t\t     3\n#define QOS_OUI_TYPE\t\t    2\n#define QOS_ELEMENT_ID\t\t  221\n#define QOS_OUI_INFO_SUB_TYPE\t   0\n#define QOS_OUI_PARAM_SUB_TYPE\t  1\n#define QOS_VERSION_1\t\t   1\n\nstruct rtllib_qos_information_element {\n\tu8 elementID;\n\tu8 length;\n\tu8 qui[QOS_OUI_LEN];\n\tu8 qui_type;\n\tu8 qui_subtype;\n\tu8 version;\n\tu8 ac_info;\n} __packed;\n\nstruct rtllib_qos_ac_parameter {\n\tu8 aci_aifsn;\n\tu8 ecw_min_max;\n\t__le16 tx_op_limit;\n} __packed;\n\nstruct rtllib_qos_parameter_info {\n\tstruct rtllib_qos_information_element info_element;\n\tu8 reserved;\n\tstruct rtllib_qos_ac_parameter ac_params_record[QOS_QUEUE_NUM];\n} __packed;\n\nstruct rtllib_qos_parameters {\n\t__le16 cw_min[QOS_QUEUE_NUM];\n\t__le16 cw_max[QOS_QUEUE_NUM];\n\tu8 aifs[QOS_QUEUE_NUM];\n\tu8 flag[QOS_QUEUE_NUM];\n\t__le16 tx_op_limit[QOS_QUEUE_NUM];\n} __packed;\n\nstruct rtllib_qos_data {\n\tstruct rtllib_qos_parameters parameters;\n\tunsigned int wmm_acm;\n\tint active;\n\tint supported;\n\tu8 param_count;\n\tu8 old_param_count;\n};\n\nstruct rtllib_tim_parameters {\n\tu8 tim_count;\n\tu8 tim_period;\n} __packed;\n\nstruct rtllib_wmm_ac_param {\n\tu8 ac_aci_acm_aifsn;\n\tu8 ac_ecwmin_ecwmax;\n\tu16 ac_txop_limit;\n};\n\nenum eap_type {\n\tEAP_PACKET = 0,\n\tEAPOL_START,\n\tEAPOL_LOGOFF,\n\tEAPOL_KEY,\n\tEAPOL_ENCAP_ASF_ALERT\n};\n\nstatic const char * const eap_types[] = {\n\t[EAP_PACKET]\t\t= \"EAP-Packet\",\n\t[EAPOL_START]\t\t= \"EAPOL-Start\",\n\t[EAPOL_LOGOFF]\t\t= \"EAPOL-Logoff\",\n\t[EAPOL_KEY]\t\t= \"EAPOL-Key\",\n\t[EAPOL_ENCAP_ASF_ALERT]\t= \"EAPOL-Encap-ASF-Alert\"\n};\n\nstatic inline const char *eap_get_type(int type)\n{\n\treturn ((u32)type >= ARRAY_SIZE(eap_types)) ? \"Unknown\" :\n\t\t eap_types[type];\n}\n\nstatic inline u8 Frame_QoSTID(u8 *buf)\n{\n\tstruct rtllib_hdr_3addr *hdr;\n\tu16 fc;\n\n\thdr = (struct rtllib_hdr_3addr *)buf;\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\treturn (u8)((union frameqos *)(buf + (((fc & RTLLIB_FCTL_TODS) &&\n\t\t    (fc & RTLLIB_FCTL_FROMDS)) ? 30 : 24)))->field.tid;\n}\n\nstruct eapol {\n\tu8 snap[6];\n\tu16 ethertype;\n\tu8 version;\n\tu8 type;\n\tu16 length;\n} __packed;\n\nstruct rtllib_softmac_stats {\n\tunsigned int rx_ass_ok;\n\tunsigned int rx_ass_err;\n\tunsigned int rx_probe_rq;\n\tunsigned int tx_probe_rs;\n\tunsigned int tx_beacons;\n\tunsigned int rx_auth_rq;\n\tunsigned int rx_auth_rs_ok;\n\tunsigned int rx_auth_rs_err;\n\tunsigned int tx_auth_rq;\n\tunsigned int no_auth_rs;\n\tunsigned int no_ass_rs;\n\tunsigned int tx_ass_rq;\n\tunsigned int rx_ass_rq;\n\tunsigned int tx_probe_rq;\n\tunsigned int reassoc;\n\tunsigned int swtxstop;\n\tunsigned int swtxawake;\n\tunsigned char CurrentShowTxate;\n\tunsigned char last_packet_rate;\n\tunsigned int txretrycount;\n};\n\n \n\n#define RTLLIB_DEFAULT_TX_ESSID \"Penguin\"\n#define RTLLIB_DEFAULT_BASIC_RATE 2\n\nenum {WMM_all_frame, WMM_two_frame, WMM_four_frame, WMM_six_frame};\n#define MAX_SP_Len  (WMM_all_frame << 4)\n#define RTLLIB_QOS_TID 0x0f\n#define QOS_CTL_NOTCONTAIN_ACK (0x01 << 5)\n\n#define RTLLIB_DTIM_MBCAST 4\n#define RTLLIB_DTIM_UCAST 2\n#define RTLLIB_DTIM_VALID 1\n#define RTLLIB_DTIM_INVALID 0\n\n#define RTLLIB_PS_DISABLED 0\n#define RTLLIB_PS_UNICAST RTLLIB_DTIM_UCAST\n#define RTLLIB_PS_MBCAST RTLLIB_DTIM_MBCAST\n\n#define WME_AC_BK   0x00\n#define WME_AC_BE   0x01\n#define WME_AC_VI   0x02\n#define WME_AC_VO   0x03\n#define WME_AC_PRAM_LEN 16\n\n#define MAX_RECEIVE_BUFFER_SIZE 9100\n\n#define UP2AC(up) (\t\t   \\\n\t((up) < 1) ? WME_AC_BE : \\\n\t((up) < 3) ? WME_AC_BK : \\\n\t((up) < 4) ? WME_AC_BE : \\\n\t((up) < 6) ? WME_AC_VI : \\\n\tWME_AC_VO)\n\n#define\tETHER_ADDR_LEN\t\t6\t \n#define ETHERNET_HEADER_SIZE    14       \n\nenum erp_t {\n\tERP_NonERPpresent\t= 0x01,\n\tERP_UseProtection\t= 0x02,\n\tERP_BarkerPreambleMode = 0x04,\n};\n\nstruct rtllib_network {\n\t \n\tu8 bssid[ETH_ALEN];\n\tu8 channel;\n\t \n\tu8 ssid[IW_ESSID_MAX_SIZE + 1];\n\tu8 ssid_len;\n\tu8 hidden_ssid[IW_ESSID_MAX_SIZE + 1];\n\tu8 hidden_ssid_len;\n\tstruct rtllib_qos_data qos_data;\n\n\tbool\tbWithAironetIE;\n\tbool\tbCkipSupported;\n\tbool\tbCcxRmEnable;\n\tu8\tCcxRmState[2];\n\tbool\tbMBssidValid;\n\tu8\tMBssidMask;\n\tu8\tMBssid[ETH_ALEN];\n\tbool\tbWithCcxVerNum;\n\tu8\tBssCcxVerNumber;\n\t \n\tstruct rtllib_rx_stats stats;\n\tu16 capability;\n\tu8  rates[MAX_RATES_LENGTH];\n\tu8  rates_len;\n\tu8  rates_ex[MAX_RATES_EX_LENGTH];\n\tu8  rates_ex_len;\n\tunsigned long last_scanned;\n\tu8  mode;\n\tu32 flags;\n\tu32 time_stamp[2];\n\tu16 beacon_interval;\n\tu16 listen_interval;\n\tu16 atim_window;\n\tu8  erp_value;\n\tu8  wpa_ie[MAX_WPA_IE_LEN];\n\tsize_t wpa_ie_len;\n\tu8  rsn_ie[MAX_WPA_IE_LEN];\n\tsize_t rsn_ie_len;\n\tu8  wzc_ie[MAX_WZC_IE_LEN];\n\tsize_t wzc_ie_len;\n\n\tstruct rtllib_tim_parameters tim;\n\tu8  dtim_period;\n\tu8  dtim_data;\n\tu64 last_dtim_sta_time;\n\n\tu8 wmm_info;\n\tstruct rtllib_wmm_ac_param wmm_param[4];\n\tu8 Turbo_Enable;\n\tu16 CountryIeLen;\n\tu8 CountryIeBuf[MAX_IE_LEN];\n\tstruct bss_ht bssht;\n\tbool broadcom_cap_exist;\n\tbool realtek_cap_exit;\n\tbool marvell_cap_exist;\n\tbool ralink_cap_exist;\n\tbool atheros_cap_exist;\n\tbool cisco_cap_exist;\n\tbool airgo_cap_exist;\n\tbool unknown_cap_exist;\n\tbool\tberp_info_valid;\n\tbool buseprotection;\n\tu8 SignalStrength;\n\tu8 RSSI;\n\tstruct list_head list;\n};\n\nenum rtl_link_state {\n\t \n\tMAC80211_NOLINK = 0,\n\n\t \n\n\t \n\tRTLLIB_ASSOCIATING,\n\tRTLLIB_ASSOCIATING_RETRY,\n\n\t \n\tRTLLIB_ASSOCIATING_AUTHENTICATING,\n\n\t \n\tRTLLIB_ASSOCIATING_AUTHENTICATED,\n\n\t \n\tMAC80211_LINKED,\n\n\t \n\tMAC80211_LINKED_SCANNING,\n};\n\n#define DEFAULT_MAX_SCAN_AGE (15 * HZ)\n#define DEFAULT_FTS 2346\n\n#define CFG_RTLLIB_RESERVE_FCS (1<<0)\n#define CFG_RTLLIB_COMPUTE_FCS (1<<1)\n\nstruct tx_pending {\n\tint frag;\n\tstruct rtllib_txb *txb;\n};\n\nstruct bandwidth_autoswitch {\n\tlong threshold_20Mhzto40Mhz;\n\tlong\tthreshold_40Mhzto20Mhz;\n\tbool bforced_tx20Mhz;\n\tbool bautoswitch_enable;\n};\n\n#define REORDER_WIN_SIZE\t128\n#define REORDER_ENTRY_NUM\t128\nstruct rx_reorder_entry {\n\tstruct list_head\tList;\n\tu16\t\t\tSeqNum;\n\tstruct rtllib_rxb *prxb;\n};\n\nenum fsync_state {\n\tDefault_Fsync,\n\tHW_Fsync,\n\tSW_Fsync\n};\n\nenum rt_ps_mode {\n\teActive,\n\teMaxPs,\n\teFastPs,\n\teAutoPs,\n};\n\nenum ips_callback_function {\n\tIPS_CALLBACK_NONE = 0,\n\tIPS_CALLBACK_MGNT_LINK_REQUEST = 1,\n\tIPS_CALLBACK_JOIN_REQUEST = 2,\n};\n\nenum rt_rf_power_state {\n\trf_on,\n\trf_sleep,\n\trf_off\n};\n\nstruct rt_pwr_save_ctrl {\n\tbool\t\t\t\tbSwRfProcessing;\n\tenum rt_rf_power_state eInactivePowerState;\n\tenum ips_callback_function ReturnPoint;\n\n\tbool\t\t\t\tbLeisurePs;\n\tu8\t\t\t\tLpsIdleCount;\n\tu8\t\t\t\treg_max_lps_awake_intvl;\n\tu8\t\t\t\tLPSAwakeIntvl;\n\n\tu32\t\t\t\tCurPsLevel;\n};\n\n#define RT_RF_CHANGE_SOURCE u32\n\n#define RF_CHANGE_BY_SW BIT31\n#define RF_CHANGE_BY_HW BIT30\n#define RF_CHANGE_BY_PS BIT29\n#define RF_CHANGE_BY_IPS BIT28\n#define RF_CHANGE_BY_INIT\t0\n\nenum country_code_type {\n\tCOUNTRY_CODE_FCC = 0,\n\tCOUNTRY_CODE_IC = 1,\n\tCOUNTRY_CODE_ETSI = 2,\n\tCOUNTRY_CODE_SPAIN = 3,\n\tCOUNTRY_CODE_FRANCE = 4,\n\tCOUNTRY_CODE_MKK = 5,\n\tCOUNTRY_CODE_MKK1 = 6,\n\tCOUNTRY_CODE_ISRAEL = 7,\n\tCOUNTRY_CODE_TELEC = 8,\n\tCOUNTRY_CODE_MIC = 9,\n\tCOUNTRY_CODE_GLOBAL_DOMAIN = 10,\n\tCOUNTRY_CODE_WORLD_WIDE_13 = 11,\n\tCOUNTRY_CODE_TELEC_NETGEAR = 12,\n\tCOUNTRY_CODE_MAX\n};\n\nenum scan_op_backup_opt {\n\tSCAN_OPT_BACKUP = 0,\n\tSCAN_OPT_RESTORE,\n\tSCAN_OPT_MAX\n};\n\nenum fw_cmd_io_type {\n\tFW_CMD_DIG_ENABLE = 0,\n\tFW_CMD_DIG_DISABLE = 1,\n\tFW_CMD_DIG_HALT = 2,\n\tFW_CMD_DIG_RESUME = 3,\n\tFW_CMD_HIGH_PWR_ENABLE = 4,\n\tFW_CMD_HIGH_PWR_DISABLE = 5,\n\tFW_CMD_RA_RESET = 6,\n\tFW_CMD_RA_ACTIVE = 7,\n\tFW_CMD_RA_REFRESH_N = 8,\n\tFW_CMD_RA_REFRESH_BG = 9,\n\tFW_CMD_RA_INIT = 10,\n\tFW_CMD_IQK_ENABLE = 11,\n\tFW_CMD_TXPWR_TRACK_ENABLE = 12,\n\tFW_CMD_TXPWR_TRACK_DISABLE = 13,\n\tFW_CMD_TXPWR_TRACK_THERMAL = 14,\n\tFW_CMD_PAUSE_DM_BY_SCAN = 15,\n\tFW_CMD_RESUME_DM_BY_SCAN = 16,\n\tFW_CMD_RA_REFRESH_N_COMB = 17,\n\tFW_CMD_RA_REFRESH_BG_COMB = 18,\n\tFW_CMD_ANTENNA_SW_ENABLE = 19,\n\tFW_CMD_ANTENNA_SW_DISABLE = 20,\n\tFW_CMD_TX_FEEDBACK_CCX_ENABLE = 21,\n\tFW_CMD_LPS_ENTER = 22,\n\tFW_CMD_LPS_LEAVE = 23,\n};\n\n#define RT_MAX_LD_SLOT_NUM\t10\nstruct rt_link_detect {\n\tu32\t\t\t\tNumRecvBcnInPeriod;\n\tu32\t\t\t\tNumRecvDataInPeriod;\n\n\tu32\t\t\t\tRxBcnNum[RT_MAX_LD_SLOT_NUM];\n\tu32\t\t\t\tRxDataNum[RT_MAX_LD_SLOT_NUM];\n\tu16\t\t\t\tSlotNum;\n\tu16\t\t\t\tSlotIndex;\n\n\tu32\t\t\t\tNumTxOkInPeriod;\n\tu32\t\t\t\tNumRxOkInPeriod;\n\tu32\t\t\t\tNumRxUnicastOkInPeriod;\n\tbool\t\t\t\tbBusyTraffic;\n\tbool\t\t\t\tbHigherBusyTraffic;\n\tbool\t\t\t\tbHigherBusyRxTraffic;\n};\n\nstruct sw_cam_table {\n\tu8\t\t\t\tmacaddr[ETH_ALEN];\n\tbool\t\t\t\tbused;\n\tu8\t\t\t\tkey_buf[16];\n\tu16\t\t\t\tkey_type;\n\tu8\t\t\t\tuseDK;\n\tu8\t\t\t\tkey_index;\n\n};\n\n#define   TOTAL_CAM_ENTRY\t\t\t\t32\nstruct rate_adaptive {\n\tu8\t\t\t\trate_adaptive_disabled;\n\tu8\t\t\t\tratr_state;\n\tu16\t\t\t\treserve;\n\n\tu32\t\t\t\thigh_rssi_thresh_for_ra;\n\tu32\t\t\t\thigh2low_rssi_thresh_for_ra;\n\tu8\t\t\t\tlow2high_rssi_thresh_for_ra40M;\n\tu32\t\t\t\tlow_rssi_thresh_for_ra40M;\n\tu8\t\t\t\tlow2high_rssi_thresh_for_ra20M;\n\tu32\t\t\t\tlow_rssi_thresh_for_ra20M;\n\tu32\t\t\t\tupper_rssi_threshold_ratr;\n\tu32\t\t\t\tmiddle_rssi_threshold_ratr;\n\tu32\t\t\t\tlow_rssi_threshold_ratr;\n\tu32\t\t\t\tlow_rssi_threshold_ratr_40M;\n\tu32\t\t\t\tlow_rssi_threshold_ratr_20M;\n\tu8\t\t\t\tping_rssi_enable;\n\tu32\t\t\t\tping_rssi_ratr;\n\tu32\t\t\t\tping_rssi_thresh_for_ra;\n\tu32\t\t\t\tlast_ratr;\n\tu8\t\t\t\tPreRATRState;\n\n};\n\n#define\tNUM_PMKID_CACHE\t\t16\nstruct rt_pmkid_list {\n\tu8 Bssid[ETH_ALEN];\n\tu8 PMKID[16];\n\tu8 SsidBuf[33];\n\tu8 bUsed;\n};\n\nstruct rt_intel_promisc_mode {\n\tbool promiscuous_on;\n\tbool fltr_src_sta_frame;\n};\n\n \n#define STATUS_SCANNING\t\t\t0\n \n\nenum {\n\tLPS_IS_WAKE = 0,\n\tLPS_IS_SLEEP = 1,\n\tLPS_WAIT_NULL_DATA_SEND = 2,\n};\n\nstruct rtllib_device {\n\tstruct pci_dev *pdev;\n\tstruct net_device *dev;\n\tstruct rtllib_security sec;\n\n\tbool disable_mgnt_queue;\n\n\tunsigned long status;\n\tu8\tCntAfterLink;\n\n\tenum rt_op_mode OpMode;\n\n\t \n\tu8 *assocreq_ies, *assocresp_ies;\n\tsize_t assocreq_ies_len, assocresp_ies_len;\n\n\tbool\tbForcedBgMode;\n\n\tu8 hwsec_active;\n\tbool is_silent_reset;\n\tbool is_roaming;\n\tbool ieee_up;\n\tbool cannot_notify;\n\tbool bSupportRemoteWakeUp;\n\tbool actscanning;\n\tbool FirstIe_InScan;\n\tbool be_scan_inprogress;\n\tbool beinretry;\n\tenum rt_rf_power_state rf_power_state;\n\tRT_RF_CHANGE_SOURCE rf_off_reason;\n\tbool is_set_key;\n\tbool wx_set_enc;\n\tstruct rt_hi_throughput *ht_info;\n\n\tspinlock_t reorder_spinlock;\n\tu8\treg_dot11ht_oper_rate_set[16];\n\tu8\treg_dot11tx_ht_oper_rate_set[16];\n\tu8\tdot11ht_oper_rate_set[16];\n\tu8\treg_ht_supp_rate_set[16];\n\tu8\tHTCurrentOperaRate;\n\tu8\tHTHighestOperaRate;\n\tu8\ttx_dis_rate_fallback;\n\tu8\ttx_use_drv_assinged_rate;\n\tu8\tbTxEnableFwCalcDur;\n\tatomic_t\tatm_swbw;\n\n\tstruct list_head\t\tTx_TS_Admit_List;\n\tstruct list_head\t\tTx_TS_Pending_List;\n\tstruct list_head\t\tTx_TS_Unused_List;\n\tstruct tx_ts_record TxTsRecord[TOTAL_TS_NUM];\n\tstruct list_head\t\tRx_TS_Admit_List;\n\tstruct list_head\t\tRx_TS_Pending_List;\n\tstruct list_head\t\tRx_TS_Unused_List;\n\tstruct rx_ts_record RxTsRecord[TOTAL_TS_NUM];\n\tstruct rx_reorder_entry RxReorderEntry[128];\n\tstruct list_head\t\tRxReorder_Unused_List;\n\n\t \n\tstruct net_device_stats stats;\n\tstruct rtllib_softmac_stats softmac_stats;\n\n\t \n\tstruct list_head network_free_list;\n\tstruct list_head network_list;\n\tstruct rtllib_network *networks;\n\tint scans;\n\tint scan_age;\n\n\tint iw_mode;  \n\tbool net_promiscuous_md;\n\tstruct rt_intel_promisc_mode intel_promiscuous_md_info;\n\n\tspinlock_t lock;\n\tspinlock_t wpax_suitlist_lock;\n\n\tint tx_headroom;  \n\tu32 config;\n\n\t \n\tint open_wep;  \n\tint auth_mode;\n\tint reset_on_keychange;  \n\n\tint ieee802_1x;  \n\n\t \n\tbool bHalfWirelessN24GMode;\n\tint wpa_enabled;\n\tint drop_unencrypted;\n\tint tkip_countermeasures;\n\tint privacy_invoked;\n\tsize_t wpa_ie_len;\n\tu8 *wpa_ie;\n\tsize_t wps_ie_len;\n\tu8 *wps_ie;\n\tu8 ap_mac_addr[ETH_ALEN];\n\tu16 pairwise_key_type;\n\tu16 group_key_type;\n\n\tstruct lib80211_crypt_info crypt_info;\n\n\tstruct sw_cam_table swcamtable[TOTAL_CAM_ENTRY];\n\n\tstruct rt_pmkid_list PMKIDList[NUM_PMKID_CACHE];\n\n\t \n\tstruct rtllib_frag_entry frag_cache[17][RTLLIB_FRAG_CACHE_LEN];\n\tunsigned int frag_next_idx[17];\n\tu16 fts;  \n#define DEFAULT_RTS_THRESHOLD 2346U\n#define MIN_RTS_THRESHOLD 1\n#define MAX_RTS_THRESHOLD 2346U\n\tu16 rts;  \n\n\t \n\tu8 bssid[ETH_ALEN];\n\n\t \n\tstruct rtllib_network current_network;\n\n\tenum rtl_link_state link_state;\n\n\tint mode;        \n\n\t \n\tshort sync_scan_hurryup;\n\tu16 scan_watch_dog;\n\n\t \n\tvoid *dot11d_info;\n\tbool global_domain;\n\tu8 active_channel_map[MAX_CHANNEL_NUMBER+1];\n\n\tu8   bss_start_channel;\n\tu8   ibss_maxjoin_chal;\n\n\tint rate;        \n\tint basic_rate;\n\n\tshort active_scan;\n\n\t \n\tu16 softmac_features;\n\n\t \n\tu16 seq_ctrl[5];\n\n\t \n\tu16 associate_seq;\n\n\t \n\tu16 assoc_id;\n\n\t \n\tu8 ack_tx_to_ieee;\n\tshort ps;\n\tshort sta_sleep;\n\tint ps_timeout;\n\tint ps_period;\n\tstruct work_struct ps_task;\n\tu64 ps_time;\n\tbool polling;\n\n\tshort raw_tx;\n\t \n\tshort queue_stop;\n\tshort scanning_continue;\n\tshort proto_started;\n\tshort proto_stoppping;\n\n\tstruct mutex wx_mutex;\n\tstruct mutex scan_mutex;\n\tstruct mutex ips_mutex;\n\n\tspinlock_t mgmt_tx_lock;\n\tspinlock_t beacon_lock;\n\n\tshort beacon_txing;\n\n\tshort wap_set;\n\tshort ssid_set;\n\n\t \n\tunsigned int wmm_acm;\n\n\t \n\tstruct list_head ibss_mac_hash[IEEE_IBSS_MAC_HASH_SIZE];\n\n\t \n\tu16 last_rxseq_num[17];  \n\tu16 last_rxfrag_num[17]; \n\tunsigned long last_packet_time[17];\n\n\t \n\tunsigned long last_rx_ps_time;\n\tbool\t\t\tbAwakePktSent;\n\tu8\t\t\tLPSDelayCnt;\n\n\t \n\tstruct sk_buff *mgmt_queue_ring[MGMT_QUEUE_NUM];\n\tint mgmt_queue_head;\n\tint mgmt_queue_tail;\n\tu8 AsocRetryCount;\n\tstruct sk_buff_head skb_waitQ[MAX_QUEUE_SIZE];\n\n\tbool\tbdynamic_txpower_enable;\n\n\tbool bCTSToSelfEnable;\n\n\tu32\tfsync_time_interval;\n\tu32\tfsync_rate_bitmap;\n\tu8\tfsync_rssi_threshold;\n\tbool\tbfsync_enable;\n\n\tu8\tfsync_multiple_timeinterval;\n\tu32\tfsync_firstdiff_ratethreshold;\n\tu32\tfsync_seconddiff_ratethreshold;\n\tenum fsync_state fsync_state;\n\tbool\t\tbis_any_nonbepkts;\n\tstruct bandwidth_autoswitch bandwidth_auto_switch;\n\tbool FwRWRF;\n\n\tstruct rt_link_detect link_detect_info;\n\tbool bIsAggregateFrame;\n\tstruct rt_pwr_save_ctrl pwr_save_ctrl;\n\n\t \n\tstruct tx_pending tx_pending;\n\n\t \n\tstruct timer_list associate_timer;\n\n\t \n\tstruct timer_list beacon_timer;\n\tu8 need_sw_enc;\n\tstruct work_struct associate_complete_wq;\n\tstruct work_struct ips_leave_wq;\n\tstruct delayed_work associate_procedure_wq;\n\tstruct delayed_work softmac_scan_wq;\n\tstruct delayed_work associate_retry_wq;\n\tstruct delayed_work start_ibss_wq;\n\tstruct delayed_work hw_wakeup_wq;\n\tstruct delayed_work hw_sleep_wq;\n\tstruct delayed_work link_change_wq;\n\tstruct work_struct wx_sync_scan_wq;\n\n\tunion {\n\t\tstruct rtllib_rxb *RfdArray[REORDER_WIN_SIZE];\n\t\tstruct rtllib_rxb *stats_IndicateArray[REORDER_WIN_SIZE];\n\t\tstruct rtllib_rxb *prxbIndicateArray[REORDER_WIN_SIZE];\n\t\tstruct {\n\t\t\tstruct sw_chnl_cmd PreCommonCmd[MAX_PRECMD_CNT];\n\t\t\tstruct sw_chnl_cmd PostCommonCmd[MAX_POSTCMD_CNT];\n\t\t\tstruct sw_chnl_cmd RfDependCmd[MAX_RFDEPENDCMD_CNT];\n\t\t};\n\t};\n\n\t \n\n\t \n\tint (*softmac_hard_start_xmit)(struct sk_buff *skb,\n\t\t\t       struct net_device *dev);\n\n\t \n\tvoid (*softmac_data_hard_start_xmit)(struct sk_buff *skb,\n\t\t\t       struct net_device *dev, int rate);\n\n\t \n\tvoid (*set_chan)(struct net_device *dev, short ch);\n\n\t \n\tvoid (*link_change)(struct net_device *dev);\n\n\t \n\tvoid (*start_send_beacons)(struct net_device *dev);\n\tvoid (*stop_send_beacons)(struct net_device *dev);\n\n\t \n\tvoid (*sta_wake_up)(struct net_device *dev);\n\tvoid (*enter_sleep_state)(struct net_device *dev, u64 time);\n\tshort (*ps_is_queue_empty)(struct net_device *dev);\n\tint (*handle_beacon)(struct net_device *dev,\n\t\t\t     struct rtllib_beacon *beacon,\n\t\t\t     struct rtllib_network *network);\n\tint (*handle_assoc_response)(struct net_device *dev,\n\t\t\t\t     struct rtllib_assoc_response_frame *resp,\n\t\t\t\t     struct rtllib_network *network);\n\n\t \n\tshort (*check_nic_enough_desc)(struct net_device *dev, int queue_index);\n\tvoid (*set_bw_mode_handler)(struct net_device *dev,\n\t\t\t\t    enum ht_channel_width bandwidth,\n\t\t\t\t    enum ht_extchnl_offset Offset);\n\tbool (*GetNmodeSupportBySecCfg)(struct net_device *dev);\n\tvoid (*set_wireless_mode)(struct net_device *dev, u8 wireless_mode);\n\tbool (*GetHalfNmodeSupportByAPsHandler)(struct net_device *dev);\n\tu8   (*rtllib_ap_sec_type)(struct rtllib_device *ieee);\n\tvoid (*init_gain_handler)(struct net_device *dev, u8 Operation);\n\tvoid (*ScanOperationBackupHandler)(struct net_device *dev,\n\t\t\t\t\t   u8 Operation);\n\tvoid (*SetHwRegHandler)(struct net_device *dev, u8 variable, u8 *val);\n\n\tvoid (*AllowAllDestAddrHandler)(struct net_device *dev,\n\t\t\t\t\tbool bAllowAllDA, bool WriteIntoReg);\n\n\tvoid (*rtllib_ips_leave_wq)(struct net_device *dev);\n\tvoid (*rtllib_ips_leave)(struct net_device *dev);\n\tvoid (*leisure_ps_leave)(struct net_device *dev);\n\n\t \n\tu8 priv[];\n};\n\n#define IEEE_MODE_MASK    (WIRELESS_MODE_B | WIRELESS_MODE_G)\n\n \n\n \n#define IEEE_SOFTMAC_SCAN (1<<2)\n\n \n#define IEEE_SOFTMAC_ASSOCIATE (1<<3)\n\n \n#define IEEE_SOFTMAC_PROBERQ (1<<4)\n\n \n#define IEEE_SOFTMAC_PROBERS (1<<5)\n\n \n#define IEEE_SOFTMAC_TX_QUEUE (1<<7)\n\n \n#define IEEE_SOFTMAC_SINGLE_QUEUE (1<<8)\n\n \n#define IEEE_SOFTMAC_BEACONS (1<<6)\n\nstatic inline void *rtllib_priv(struct net_device *dev)\n{\n\treturn ((struct rtllib_device *)netdev_priv(dev))->priv;\n}\n\nstatic inline int rtllib_is_empty_essid(const char *essid, int essid_len)\n{\n\t \n\tif (essid_len == 1 && essid[0] == ' ')\n\t\treturn 1;\n\n\t \n\twhile (essid_len) {\n\t\tessid_len--;\n\t\tif (essid[essid_len] != '\\0')\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic inline int rtllib_get_hdrlen(u16 fc)\n{\n\tint hdrlen = RTLLIB_3ADDR_LEN;\n\n\tswitch (WLAN_FC_GET_TYPE(fc)) {\n\tcase RTLLIB_FTYPE_DATA:\n\t\tif ((fc & RTLLIB_FCTL_FROMDS) && (fc & RTLLIB_FCTL_TODS))\n\t\t\thdrlen = RTLLIB_4ADDR_LEN;  \n\t\tif (RTLLIB_QOS_HAS_SEQ(fc))\n\t\t\thdrlen += 2;  \n\t\tbreak;\n\tcase RTLLIB_FTYPE_CTL:\n\t\tswitch (WLAN_FC_GET_STYPE(fc)) {\n\t\tcase RTLLIB_STYPE_CTS:\n\t\tcase RTLLIB_STYPE_ACK:\n\t\t\thdrlen = RTLLIB_1ADDR_LEN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thdrlen = RTLLIB_2ADDR_LEN;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn hdrlen;\n}\n\nstatic inline u8 *rtllib_get_payload(struct rtllib_hdr *hdr)\n{\n\tswitch (rtllib_get_hdrlen(le16_to_cpu(hdr->frame_ctl))) {\n\tcase RTLLIB_1ADDR_LEN:\n\t\treturn ((struct rtllib_hdr_1addr *)hdr)->payload;\n\tcase RTLLIB_2ADDR_LEN:\n\t\treturn ((struct rtllib_hdr_2addr *)hdr)->payload;\n\tcase RTLLIB_3ADDR_LEN:\n\t\treturn ((struct rtllib_hdr_3addr *)hdr)->payload;\n\tcase RTLLIB_4ADDR_LEN:\n\t\treturn ((struct rtllib_hdr_4addr *)hdr)->payload;\n\t}\n\treturn NULL;\n}\n\nstatic inline int rtllib_is_ofdm_rate(u8 rate)\n{\n\tswitch (rate & ~RTLLIB_BASIC_RATE_MASK) {\n\tcase RTLLIB_OFDM_RATE_6MB:\n\tcase RTLLIB_OFDM_RATE_9MB:\n\tcase RTLLIB_OFDM_RATE_12MB:\n\tcase RTLLIB_OFDM_RATE_18MB:\n\tcase RTLLIB_OFDM_RATE_24MB:\n\tcase RTLLIB_OFDM_RATE_36MB:\n\tcase RTLLIB_OFDM_RATE_48MB:\n\tcase RTLLIB_OFDM_RATE_54MB:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline int rtllib_is_cck_rate(u8 rate)\n{\n\tswitch (rate & ~RTLLIB_BASIC_RATE_MASK) {\n\tcase RTLLIB_CCK_RATE_1MB:\n\tcase RTLLIB_CCK_RATE_2MB:\n\tcase RTLLIB_CCK_RATE_5MB:\n\tcase RTLLIB_CCK_RATE_11MB:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nvoid free_rtllib(struct net_device *dev);\nstruct net_device *alloc_rtllib(int sizeof_priv);\n\n \n\nint rtllib_encrypt_fragment(struct rtllib_device *ieee,\n\t\t\t    struct sk_buff *frag,\n\t\t\t    int hdr_len);\n\nnetdev_tx_t rtllib_xmit(struct sk_buff *skb,  struct net_device *dev);\nvoid rtllib_txb_free(struct rtllib_txb *txb);\n\n \nint rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,\n\t      struct rtllib_rx_stats *rx_stats);\nvoid rtllib_rx_probe_rq(struct rtllib_device *ieee,\n\t\t\tstruct sk_buff *skb);\nint rtllib_legal_channel(struct rtllib_device *rtllib, u8 channel);\n\n \nint rtllib_wx_get_scan(struct rtllib_device *ieee,\n\t\t       struct iw_request_info *info,\n\t\t       union iwreq_data *wrqu, char *key);\nint rtllib_wx_set_encode(struct rtllib_device *ieee,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu, char *key);\nint rtllib_wx_get_encode(struct rtllib_device *ieee,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu, char *key);\nint rtllib_wx_set_encode_ext(struct rtllib_device *ieee,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra);\nint rtllib_wx_set_auth(struct rtllib_device *ieee,\n\t\t       struct iw_request_info *info,\n\t\t       struct iw_param *data, char *extra);\nint rtllib_wx_set_mlme(struct rtllib_device *ieee,\n\t\t       struct iw_request_info *info,\n\t\t       union iwreq_data *wrqu, char *extra);\nint rtllib_wx_set_gen_ie(struct rtllib_device *ieee, u8 *ie, size_t len);\n\n \nint rtllib_rx_frame_softmac(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t\t    struct rtllib_rx_stats *rx_stats, u16 type,\n\t\t\t    u16 stype);\nvoid rtllib_softmac_new_net(struct rtllib_device *ieee,\n\t\t\t    struct rtllib_network *net);\n\nvoid SendDisassociation(struct rtllib_device *ieee, bool deauth, u16 asRsn);\nvoid rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee);\n\nvoid rtllib_start_ibss(struct rtllib_device *ieee);\nint rtllib_softmac_init(struct rtllib_device *ieee);\nvoid rtllib_softmac_free(struct rtllib_device *ieee);\nvoid rtllib_disassociate(struct rtllib_device *ieee);\nvoid rtllib_stop_scan(struct rtllib_device *ieee);\nbool rtllib_act_scanning(struct rtllib_device *ieee, bool sync_scan);\nvoid rtllib_stop_scan_syncro(struct rtllib_device *ieee);\nvoid rtllib_start_scan_syncro(struct rtllib_device *ieee);\nvoid rtllib_sta_ps_send_null_frame(struct rtllib_device *ieee, short pwr);\nvoid rtllib_sta_ps_send_pspoll_frame(struct rtllib_device *ieee);\nvoid rtllib_start_protocol(struct rtllib_device *ieee);\nvoid rtllib_stop_protocol(struct rtllib_device *ieee, u8 shutdown);\n\nvoid rtllib_EnableNetMonitorMode(struct net_device *dev, bool bInitState);\nvoid rtllib_DisableNetMonitorMode(struct net_device *dev, bool bInitState);\nvoid rtllib_EnableIntelPromiscuousMode(struct net_device *dev, bool bInitState);\nvoid rtllib_DisableIntelPromiscuousMode(struct net_device *dev,\n\t\t\t\t\tbool bInitState);\nvoid rtllib_softmac_stop_protocol(struct rtllib_device *ieee,\n\t\t\t\t  u8 mesh_flag, u8 shutdown);\nvoid rtllib_softmac_start_protocol(struct rtllib_device *ieee, u8 mesh_flag);\n\nvoid rtllib_reset_queue(struct rtllib_device *ieee);\nvoid rtllib_wake_all_queues(struct rtllib_device *ieee);\nvoid rtllib_stop_all_queues(struct rtllib_device *ieee);\nstruct sk_buff *rtllib_get_beacon(struct rtllib_device *ieee);\nvoid rtllib_start_send_beacons(struct rtllib_device *ieee);\nvoid rtllib_stop_send_beacons(struct rtllib_device *ieee);\n\nvoid notify_wx_assoc_event(struct rtllib_device *ieee);\nvoid rtllib_ps_tx_ack(struct rtllib_device *ieee, short success);\n\nvoid softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee);\nu8 rtllib_ap_sec_type(struct rtllib_device *ieee);\n\n \n\nint rtllib_wx_get_wap(struct rtllib_device *ieee, struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu, char *ext);\n\nint rtllib_wx_set_wap(struct rtllib_device *ieee, struct iw_request_info *info,\n\t\t      union iwreq_data *awrq, char *extra);\n\nint rtllib_wx_get_essid(struct rtllib_device *ieee, struct iw_request_info *a,\n\t\t\tunion iwreq_data *wrqu, char *b);\n\nint rtllib_wx_set_rate(struct rtllib_device *ieee, struct iw_request_info *info,\n\t\t       union iwreq_data *wrqu, char *extra);\n\nint rtllib_wx_get_rate(struct rtllib_device *ieee, struct iw_request_info *info,\n\t\t       union iwreq_data *wrqu, char *extra);\n\nint rtllib_wx_set_mode(struct rtllib_device *ieee, struct iw_request_info *a,\n\t\t       union iwreq_data *wrqu, char *b);\n\nint rtllib_wx_set_scan(struct rtllib_device *ieee, struct iw_request_info *a,\n\t\t       union iwreq_data *wrqu, char *b);\n\nint rtllib_wx_set_essid(struct rtllib_device *ieee, struct iw_request_info *a,\n\t\t\tunion iwreq_data *wrqu, char *extra);\n\nint rtllib_wx_get_mode(struct rtllib_device *ieee, struct iw_request_info *a,\n\t\t       union iwreq_data *wrqu, char *b);\n\nint rtllib_wx_set_freq(struct rtllib_device *ieee, struct iw_request_info *a,\n\t\t       union iwreq_data *wrqu, char *b);\n\nint rtllib_wx_get_freq(struct rtllib_device *ieee, struct iw_request_info *a,\n\t\t       union iwreq_data *wrqu, char *b);\nvoid rtllib_wx_sync_scan_wq(void *data);\n\nint rtllib_wx_set_rawtx(struct rtllib_device *ieee,\n\t\t\tstruct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra);\n\nint rtllib_wx_get_name(struct rtllib_device *ieee, struct iw_request_info *info,\n\t\t       union iwreq_data *wrqu, char *extra);\n\nint rtllib_wx_set_power(struct rtllib_device *ieee,\n\t\t\tstruct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra);\n\nint rtllib_wx_get_power(struct rtllib_device *ieee,\n\t\t\tstruct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra);\n\nint rtllib_wx_set_rts(struct rtllib_device *ieee, struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu, char *extra);\n\nint rtllib_wx_get_rts(struct rtllib_device *ieee, struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu, char *extra);\n#define MAX_RECEIVE_BUFFER_SIZE 9100\n\nvoid HTSetConnectBwMode(struct rtllib_device *ieee,\n\t\t\tenum ht_channel_width bandwidth,\n\t\t\tenum ht_extchnl_offset Offset);\nvoid HTUpdateDefaultSetting(struct rtllib_device *ieee);\nvoid HTConstructCapabilityElement(struct rtllib_device *ieee,\n\t\t\t\t  u8 *posHTCap, u8 *len,\n\t\t\t\t  u8 isEncrypt, bool bAssoc);\nvoid HTConstructInfoElement(struct rtllib_device *ieee,\n\t\t\t    u8 *posHTInfo, u8 *len, u8 isEncrypt);\nvoid HTConstructRT2RTAggElement(struct rtllib_device *ieee,\n\t\t\t\tu8 *posRT2RTAgg, u8 *len);\nvoid HTOnAssocRsp(struct rtllib_device *ieee);\nvoid HTInitializeHTInfo(struct rtllib_device *ieee);\nvoid HTInitializeBssDesc(struct bss_ht *pBssHT);\nvoid HTResetSelfAndSavePeerSetting(struct rtllib_device *ieee,\n\t\t\t\t   struct rtllib_network *pNetwork);\nvoid HT_update_self_and_peer_setting(struct rtllib_device *ieee,\n\t\t\t\t     struct rtllib_network *pNetwork);\nu8 HTGetHighestMCSRate(struct rtllib_device *ieee, u8 *pMCSRateSet,\n\t\t       u8 *pMCSFilter);\nextern u8 MCS_FILTER_ALL[];\nextern u16 MCS_DATA_RATE[2][2][77];\nu8 HTCCheck(struct rtllib_device *ieee, u8 *pFrame);\nvoid HTResetIOTSetting(struct rt_hi_throughput *ht_info);\nbool IsHTHalfNmodeAPs(struct rtllib_device *ieee);\nu16  TxCountToDataRate(struct rtllib_device *ieee, u8 nDataRate);\nint rtllib_rx_ADDBAReq(struct rtllib_device *ieee, struct sk_buff *skb);\nint rtllib_rx_ADDBARsp(struct rtllib_device *ieee, struct sk_buff *skb);\nint rtllib_rx_DELBA(struct rtllib_device *ieee, struct sk_buff *skb);\nvoid rtllib_ts_init_add_ba(struct rtllib_device *ieee, struct tx_ts_record *pTS,\n\t\t\t   u8 Policy, u8 bOverwritePending);\nvoid rtllib_ts_init_del_ba(struct rtllib_device *ieee,\n\t\t\t   struct ts_common_info *pTsCommonInfo,\n\t\t\t   enum tr_select TxRxSelect);\nvoid rtllib_ba_setup_timeout(struct timer_list *t);\nvoid rtllib_tx_ba_inact_timeout(struct timer_list *t);\nvoid rtllib_rx_ba_inact_timeout(struct timer_list *t);\nvoid rtllib_reset_ba_entry(struct ba_record *pBA);\nbool GetTs(struct rtllib_device *ieee, struct ts_common_info **ppTS, u8 *Addr,\n\t   u8 TID, enum tr_select TxRxSelect, bool bAddNewTs);\nvoid TSInitialize(struct rtllib_device *ieee);\nvoid TsStartAddBaProcess(struct rtllib_device *ieee,\n\t\t\t struct tx_ts_record *pTxTS);\nvoid RemovePeerTS(struct rtllib_device *ieee, u8 *Addr);\nvoid RemoveAllTS(struct rtllib_device *ieee);\n\nstatic inline const char *escape_essid(const char *essid, u8 essid_len)\n{\n\tstatic char escaped[IW_ESSID_MAX_SIZE * 2 + 1];\n\n\tif (rtllib_is_empty_essid(essid, essid_len)) {\n\t\tmemcpy(escaped, \"<hidden>\", sizeof(\"<hidden>\"));\n\t\treturn escaped;\n\t}\n\n\tsnprintf(escaped, sizeof(escaped), \"%*pE\", essid_len, essid);\n\treturn escaped;\n}\n\n \nbool rtllib_MgntDisconnect(struct rtllib_device *rtllib, u8 asRsn);\n\n \nvoid rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,\n\t\t\t\t struct rx_ts_record *pTS);\nint rtllib_parse_info_param(struct rtllib_device *ieee,\n\t\t\t    struct rtllib_info_element *info_element,\n\t\t\t    u16 length,\n\t\t\t    struct rtllib_network *network,\n\t\t\t    struct rtllib_rx_stats *stats);\n\nvoid rtllib_indicate_packets(struct rtllib_device *ieee,\n\t\t\t     struct rtllib_rxb **prxbIndicateArray, u8  index);\nvoid HTUseDefaultSetting(struct rtllib_device *ieee);\n#define RT_ASOC_RETRY_LIMIT\t5\nu8 MgntQuery_TxRateExcludeCCKRates(struct rtllib_device *ieee);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}