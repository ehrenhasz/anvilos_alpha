{
  "module_name": "rtllib_module.c",
  "hash_id": "e3b46ac98bfbe366d3b91c0120a2fa8aecca587740fc6ba7f392a529ddcc650f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtllib_module.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n#include <linux/wireless.h>\n#include <linux/etherdevice.h>\n#include <linux/uaccess.h>\n#include <net/arp.h>\n#include \"rtllib.h\"\n\nu32 rt_global_debug_component = COMP_ERR;\nEXPORT_SYMBOL(rt_global_debug_component);\n\nstatic inline int rtllib_networks_allocate(struct rtllib_device *ieee)\n{\n\tif (ieee->networks)\n\t\treturn 0;\n\n\tieee->networks = kcalloc(MAX_NETWORK_COUNT,\n\t\t\t\t sizeof(struct rtllib_network), GFP_KERNEL);\n\tif (!ieee->networks)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic inline void rtllib_networks_free(struct rtllib_device *ieee)\n{\n\tif (!ieee->networks)\n\t\treturn;\n\tkfree(ieee->networks);\n\tieee->networks = NULL;\n}\n\nstatic inline void rtllib_networks_initialize(struct rtllib_device *ieee)\n{\n\tint i;\n\n\tINIT_LIST_HEAD(&ieee->network_free_list);\n\tINIT_LIST_HEAD(&ieee->network_list);\n\tfor (i = 0; i < MAX_NETWORK_COUNT; i++)\n\t\tlist_add_tail(&ieee->networks[i].list,\n\t\t\t      &ieee->network_free_list);\n}\n\nstruct net_device *alloc_rtllib(int sizeof_priv)\n{\n\tstruct rtllib_device *ieee = NULL;\n\tstruct net_device *dev;\n\tint i, err;\n\n\tpr_debug(\"rtllib: Initializing...\\n\");\n\n\tdev = alloc_etherdev(sizeof(struct rtllib_device) + sizeof_priv);\n\tif (!dev) {\n\t\tpr_err(\"Unable to allocate net_device.\\n\");\n\t\treturn NULL;\n\t}\n\tieee = (struct rtllib_device *)netdev_priv_rsl(dev);\n\tieee->dev = dev;\n\n\terr = rtllib_networks_allocate(ieee);\n\tif (err) {\n\t\tpr_err(\"Unable to allocate beacon storage: %d\\n\", err);\n\t\tgoto free_netdev;\n\t}\n\trtllib_networks_initialize(ieee);\n\n\t \n\tieee->fts = DEFAULT_FTS;\n\tieee->scan_age = DEFAULT_MAX_SCAN_AGE;\n\tieee->open_wep = 1;\n\n\tieee->ieee802_1x = 1;  \n\n\tieee->rtllib_ap_sec_type = rtllib_ap_sec_type;\n\n\tspin_lock_init(&ieee->lock);\n\tspin_lock_init(&ieee->wpax_suitlist_lock);\n\tspin_lock_init(&ieee->reorder_spinlock);\n\tatomic_set(&ieee->atm_swbw, 0);\n\n\t \n\tlib80211_crypt_info_init(&ieee->crypt_info, \"RTLLIB\", &ieee->lock);\n\n\tieee->wpa_enabled = 0;\n\tieee->tkip_countermeasures = 0;\n\tieee->drop_unencrypted = 0;\n\tieee->privacy_invoked = 0;\n\tieee->ieee802_1x = 1;\n\tieee->raw_tx = 0;\n\tieee->hwsec_active = 0;\n\n\tmemset(ieee->swcamtable, 0, sizeof(struct sw_cam_table) * 32);\n\terr = rtllib_softmac_init(ieee);\n\tif (err)\n\t\tgoto free_crypt_info;\n\n\tieee->ht_info = kzalloc(sizeof(struct rt_hi_throughput), GFP_KERNEL);\n\tif (!ieee->ht_info)\n\t\tgoto free_softmac;\n\n\tHTUpdateDefaultSetting(ieee);\n\tHTInitializeHTInfo(ieee);\n\tTSInitialize(ieee);\n\tfor (i = 0; i < IEEE_IBSS_MAC_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&ieee->ibss_mac_hash[i]);\n\n\tfor (i = 0; i < 17; i++) {\n\t\tieee->last_rxseq_num[i] = -1;\n\t\tieee->last_rxfrag_num[i] = -1;\n\t\tieee->last_packet_time[i] = 0;\n\t}\n\n\treturn dev;\n\nfree_softmac:\n\trtllib_softmac_free(ieee);\nfree_crypt_info:\n\tlib80211_crypt_info_free(&ieee->crypt_info);\n\trtllib_networks_free(ieee);\nfree_netdev:\n\tfree_netdev(dev);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(alloc_rtllib);\n\nvoid free_rtllib(struct net_device *dev)\n{\n\tstruct rtllib_device *ieee = (struct rtllib_device *)\n\t\t\t\t      netdev_priv_rsl(dev);\n\n\tkfree(ieee->ht_info);\n\trtllib_softmac_free(ieee);\n\n\tlib80211_crypt_info_free(&ieee->crypt_info);\n\n\trtllib_networks_free(ieee);\n\tfree_netdev(dev);\n}\nEXPORT_SYMBOL(free_rtllib);\n\nstatic int __init rtllib_init(void)\n{\n\treturn 0;\n}\n\nstatic void __exit rtllib_exit(void)\n{\n}\n\nmodule_init(rtllib_init);\nmodule_exit(rtllib_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}