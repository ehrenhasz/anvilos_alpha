{
  "module_name": "rtl819x_TSProc.c",
  "hash_id": "80570b92a4335ae4ccbaf7d30cd518a6846cc5cbeca8bf1d7b0169d38acab966",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtl819x_TSProc.c",
  "human_readable_source": "\n \n#include \"rtllib.h\"\n#include <linux/etherdevice.h>\n#include \"rtl819x_TS.h\"\n\nstatic void RxPktPendingTimeout(struct timer_list *t)\n{\n\tstruct rx_ts_record *pRxTs = from_timer(pRxTs, t,\n\t\t\t\t\t\t     rx_pkt_pending_timer);\n\tstruct rtllib_device *ieee = container_of(pRxTs, struct rtllib_device,\n\t\t\t\t\t\t  RxTsRecord[pRxTs->num]);\n\n\tstruct rx_reorder_entry *pReorderEntry = NULL;\n\n\tunsigned long flags = 0;\n\tu8 index = 0;\n\tbool bPktInBuf = false;\n\n\tspin_lock_irqsave(&(ieee->reorder_spinlock), flags);\n\tif (pRxTs->rx_timeout_indicate_seq != 0xffff) {\n\t\twhile (!list_empty(&pRxTs->rx_pending_pkt_list)) {\n\t\t\tpReorderEntry = (struct rx_reorder_entry *)\n\t\t\t\t\tlist_entry(pRxTs->rx_pending_pkt_list.prev,\n\t\t\t\t\tstruct rx_reorder_entry, List);\n\t\t\tif (index == 0)\n\t\t\t\tpRxTs->rx_indicate_seq = pReorderEntry->SeqNum;\n\n\t\t\tif (SN_LESS(pReorderEntry->SeqNum,\n\t\t\t\t    pRxTs->rx_indicate_seq) ||\n\t\t\t    SN_EQUAL(pReorderEntry->SeqNum,\n\t\t\t\t     pRxTs->rx_indicate_seq)) {\n\t\t\t\tlist_del_init(&pReorderEntry->List);\n\n\t\t\t\tif (SN_EQUAL(pReorderEntry->SeqNum,\n\t\t\t\t    pRxTs->rx_indicate_seq))\n\t\t\t\t\tpRxTs->rx_indicate_seq =\n\t\t\t\t\t      (pRxTs->rx_indicate_seq + 1) % 4096;\n\n\t\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t\t   \"%s(): Indicate SeqNum: %d\\n\",\n\t\t\t\t\t   __func__, pReorderEntry->SeqNum);\n\t\t\t\tieee->stats_IndicateArray[index] =\n\t\t\t\t\t\t\t pReorderEntry->prxb;\n\t\t\t\tindex++;\n\n\t\t\t\tlist_add_tail(&pReorderEntry->List,\n\t\t\t\t\t      &ieee->RxReorder_Unused_List);\n\t\t\t} else {\n\t\t\t\tbPktInBuf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (index > 0) {\n\t\tpRxTs->rx_timeout_indicate_seq = 0xffff;\n\n\t\tif (index > REORDER_WIN_SIZE) {\n\t\t\tnetdev_warn(ieee->dev,\n\t\t\t\t    \"%s(): Rx Reorder struct buffer full\\n\",\n\t\t\t\t    __func__);\n\t\t\tspin_unlock_irqrestore(&(ieee->reorder_spinlock),\n\t\t\t\t\t       flags);\n\t\t\treturn;\n\t\t}\n\t\trtllib_indicate_packets(ieee, ieee->stats_IndicateArray, index);\n\t\tbPktInBuf = false;\n\t}\n\n\tif (bPktInBuf && (pRxTs->rx_timeout_indicate_seq == 0xffff)) {\n\t\tpRxTs->rx_timeout_indicate_seq = pRxTs->rx_indicate_seq;\n\t\tmod_timer(&pRxTs->rx_pkt_pending_timer,  jiffies +\n\t\t\t  msecs_to_jiffies(ieee->ht_info->rx_reorder_pending_time)\n\t\t\t  );\n\t}\n\tspin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);\n}\n\nstatic void TsAddBaProcess(struct timer_list *t)\n{\n\tstruct tx_ts_record *pTxTs = from_timer(pTxTs, t, TsAddBaTimer);\n\tu8 num = pTxTs->num;\n\tstruct rtllib_device *ieee = container_of(pTxTs, struct rtllib_device,\n\t\t\t\t     TxTsRecord[num]);\n\n\trtllib_ts_init_add_ba(ieee, pTxTs, BA_POLICY_IMMEDIATE, false);\n\tnetdev_dbg(ieee->dev, \"%s(): ADDBA Req is started\\n\", __func__);\n}\n\nstatic void ResetTsCommonInfo(struct ts_common_info *pTsCommonInfo)\n{\n\teth_zero_addr(pTsCommonInfo->Addr);\n\tmemset(&pTsCommonInfo->TSpec, 0, sizeof(union tspec_body));\n\tmemset(&pTsCommonInfo->TClass, 0, sizeof(union qos_tclas) * TCLAS_NUM);\n\tpTsCommonInfo->TClasProc = 0;\n\tpTsCommonInfo->TClasNum = 0;\n}\n\nstatic void ResetTxTsEntry(struct tx_ts_record *pTS)\n{\n\tResetTsCommonInfo(&pTS->TsCommonInfo);\n\tpTS->TxCurSeq = 0;\n\tpTS->bAddBaReqInProgress = false;\n\tpTS->bAddBaReqDelayed = false;\n\tpTS->bUsingBa = false;\n\tpTS->bDisable_AddBa = false;\n\trtllib_reset_ba_entry(&pTS->TxAdmittedBARecord);\n\trtllib_reset_ba_entry(&pTS->TxPendingBARecord);\n}\n\nstatic void ResetRxTsEntry(struct rx_ts_record *pTS)\n{\n\tResetTsCommonInfo(&pTS->ts_common_info);\n\tpTS->rx_indicate_seq = 0xffff;\n\tpTS->rx_timeout_indicate_seq = 0xffff;\n\trtllib_reset_ba_entry(&pTS->rx_admitted_ba_record);\n}\n\nvoid TSInitialize(struct rtllib_device *ieee)\n{\n\tstruct tx_ts_record *pTxTS  = ieee->TxTsRecord;\n\tstruct rx_ts_record *pRxTS  = ieee->RxTsRecord;\n\tstruct rx_reorder_entry *pRxReorderEntry = ieee->RxReorderEntry;\n\tu8\t\t\t\tcount = 0;\n\n\tINIT_LIST_HEAD(&ieee->Tx_TS_Admit_List);\n\tINIT_LIST_HEAD(&ieee->Tx_TS_Pending_List);\n\tINIT_LIST_HEAD(&ieee->Tx_TS_Unused_List);\n\n\tfor (count = 0; count < TOTAL_TS_NUM; count++) {\n\t\tpTxTS->num = count;\n\t\ttimer_setup(&pTxTS->TsAddBaTimer, TsAddBaProcess, 0);\n\n\t\ttimer_setup(&pTxTS->TxPendingBARecord.timer, rtllib_ba_setup_timeout,\n\t\t\t    0);\n\t\ttimer_setup(&pTxTS->TxAdmittedBARecord.timer,\n\t\t\t    rtllib_tx_ba_inact_timeout, 0);\n\n\t\tResetTxTsEntry(pTxTS);\n\t\tlist_add_tail(&pTxTS->TsCommonInfo.List,\n\t\t\t\t&ieee->Tx_TS_Unused_List);\n\t\tpTxTS++;\n\t}\n\n\tINIT_LIST_HEAD(&ieee->Rx_TS_Admit_List);\n\tINIT_LIST_HEAD(&ieee->Rx_TS_Pending_List);\n\tINIT_LIST_HEAD(&ieee->Rx_TS_Unused_List);\n\tfor (count = 0; count < TOTAL_TS_NUM; count++) {\n\t\tpRxTS->num = count;\n\t\tINIT_LIST_HEAD(&pRxTS->rx_pending_pkt_list);\n\t\ttimer_setup(&pRxTS->rx_admitted_ba_record.timer,\n\t\t\t    rtllib_rx_ba_inact_timeout, 0);\n\n\t\ttimer_setup(&pRxTS->rx_pkt_pending_timer, RxPktPendingTimeout, 0);\n\n\t\tResetRxTsEntry(pRxTS);\n\t\tlist_add_tail(&pRxTS->ts_common_info.List,\n\t\t\t      &ieee->Rx_TS_Unused_List);\n\t\tpRxTS++;\n\t}\n\tINIT_LIST_HEAD(&ieee->RxReorder_Unused_List);\n\tfor (count = 0; count < REORDER_ENTRY_NUM; count++) {\n\t\tlist_add_tail(&pRxReorderEntry->List,\n\t\t\t      &ieee->RxReorder_Unused_List);\n\t\tif (count == (REORDER_ENTRY_NUM - 1))\n\t\t\tbreak;\n\t\tpRxReorderEntry = &ieee->RxReorderEntry[count + 1];\n\t}\n}\n\nstatic struct ts_common_info *SearchAdmitTRStream(struct rtllib_device *ieee,\n\t\t\t\t\t\t  u8 *Addr, u8 TID,\n\t\t\t\t\t\t  enum tr_select TxRxSelect)\n{\n\tu8\tdir;\n\tbool\tsearch_dir[4] = {0};\n\tstruct list_head *psearch_list;\n\tstruct ts_common_info *pRet = NULL;\n\n\tif (ieee->iw_mode == IW_MODE_ADHOC) {\n\t\tif (TxRxSelect == TX_DIR)\n\t\t\tsearch_dir[DIR_UP] = true;\n\t\telse\n\t\t\tsearch_dir[DIR_DOWN] = true;\n\t} else {\n\t\tif (TxRxSelect == TX_DIR) {\n\t\t\tsearch_dir[DIR_UP] = true;\n\t\t\tsearch_dir[DIR_BI_DIR] = true;\n\t\t\tsearch_dir[DIR_DIRECT] = true;\n\t\t} else {\n\t\t\tsearch_dir[DIR_DOWN] = true;\n\t\t\tsearch_dir[DIR_BI_DIR] = true;\n\t\t\tsearch_dir[DIR_DIRECT] = true;\n\t\t}\n\t}\n\n\tif (TxRxSelect == TX_DIR)\n\t\tpsearch_list = &ieee->Tx_TS_Admit_List;\n\telse\n\t\tpsearch_list = &ieee->Rx_TS_Admit_List;\n\n\tfor (dir = 0; dir <= DIR_BI_DIR; dir++) {\n\t\tif (!search_dir[dir])\n\t\t\tcontinue;\n\t\tlist_for_each_entry(pRet, psearch_list, List) {\n\t\t\tif (memcmp(pRet->Addr, Addr, 6) == 0 &&\n\t\t\t    pRet->TSpec.f.TSInfo.field.ucTSID == TID &&\n\t\t\t    pRet->TSpec.f.TSInfo.field.ucDirection == dir)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (&pRet->List  != psearch_list)\n\t\t\tbreak;\n\t}\n\n\tif (pRet && &pRet->List  != psearch_list)\n\t\treturn pRet;\n\treturn NULL;\n}\n\nstatic void MakeTSEntry(struct ts_common_info *pTsCommonInfo, u8 *Addr,\n\t\t\tunion tspec_body *pTSPEC, union qos_tclas *pTCLAS,\n\t\t\tu8 TCLAS_Num, u8 TCLAS_Proc)\n{\n\tu8\tcount;\n\n\tif (!pTsCommonInfo)\n\t\treturn;\n\n\tmemcpy(pTsCommonInfo->Addr, Addr, 6);\n\n\tif (pTSPEC)\n\t\tmemcpy((u8 *)(&(pTsCommonInfo->TSpec)), (u8 *)pTSPEC,\n\t\t\tsizeof(union tspec_body));\n\n\tfor (count = 0; count < TCLAS_Num; count++)\n\t\tmemcpy((u8 *)(&(pTsCommonInfo->TClass[count])),\n\t\t       (u8 *)pTCLAS, sizeof(union qos_tclas));\n\n\tpTsCommonInfo->TClasProc = TCLAS_Proc;\n\tpTsCommonInfo->TClasNum = TCLAS_Num;\n}\n\nbool GetTs(struct rtllib_device *ieee, struct ts_common_info **ppTS,\n\t   u8 *Addr, u8 TID, enum tr_select TxRxSelect, bool bAddNewTs)\n{\n\tu8\tUP = 0;\n\tunion tspec_body TSpec;\n\tunion qos_tsinfo *pTSInfo = &TSpec.f.TSInfo;\n\tstruct list_head *pUnusedList;\n\tstruct list_head *pAddmitList;\n\tenum direction_value Dir;\n\n\tif (is_multicast_ether_addr(Addr)) {\n\t\tnetdev_warn(ieee->dev, \"Get TS for Broadcast or Multicast\\n\");\n\t\treturn false;\n\t}\n\tif (ieee->current_network.qos_data.supported == 0) {\n\t\tUP = 0;\n\t} else {\n\t\tswitch (TID) {\n\t\tcase 0:\n\t\tcase 3:\n\t\t\tUP = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tUP = 2;\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\t\tUP = 5;\n\t\t\tbreak;\n\t\tcase 6:\n\t\tcase 7:\n\t\t\tUP = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_warn(ieee->dev, \"%s(): TID(%d) is not valid\\n\",\n\t\t\t\t    __func__, TID);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t*ppTS = SearchAdmitTRStream(ieee, Addr, UP, TxRxSelect);\n\tif (*ppTS)\n\t\treturn true;\n\n\tif (!bAddNewTs) {\n\t\tnetdev_dbg(ieee->dev, \"add new TS failed(tid:%d)\\n\", UP);\n\t\treturn false;\n\t}\n\n\tpUnusedList = (TxRxSelect == TX_DIR) ?\n\t\t\t\t(&ieee->Tx_TS_Unused_List) :\n\t\t\t\t(&ieee->Rx_TS_Unused_List);\n\n\tpAddmitList = (TxRxSelect == TX_DIR) ?\n\t\t\t\t(&ieee->Tx_TS_Admit_List) :\n\t\t\t\t(&ieee->Rx_TS_Admit_List);\n\n\tDir = ((TxRxSelect == TX_DIR) ? DIR_UP : DIR_DOWN);\n\n\tif (!list_empty(pUnusedList)) {\n\t\t(*ppTS) = list_entry(pUnusedList->next,\n\t\t\t  struct ts_common_info, List);\n\t\tlist_del_init(&(*ppTS)->List);\n\t\tif (TxRxSelect == TX_DIR) {\n\t\t\tstruct tx_ts_record *tmp =\n\t\t\t\tcontainer_of(*ppTS,\n\t\t\t\tstruct tx_ts_record,\n\t\t\t\tTsCommonInfo);\n\t\t\tResetTxTsEntry(tmp);\n\t\t} else {\n\t\t\tstruct rx_ts_record *tmp =\n\t\t\t\t container_of(*ppTS,\n\t\t\t\t struct rx_ts_record,\n\t\t\t\t ts_common_info);\n\t\t\tResetRxTsEntry(tmp);\n\t\t}\n\n\t\tnetdev_dbg(ieee->dev,\n\t\t\t   \"to init current TS, UP:%d, Dir:%d, addr: %pM ppTs=%p\\n\",\n\t\t\t   UP, Dir, Addr, *ppTS);\n\t\tpTSInfo->field.ucTrafficType = 0;\n\t\tpTSInfo->field.ucTSID = UP;\n\t\tpTSInfo->field.ucDirection = Dir;\n\t\tpTSInfo->field.ucAccessPolicy = 1;\n\t\tpTSInfo->field.ucAggregation = 0;\n\t\tpTSInfo->field.ucPSB = 0;\n\t\tpTSInfo->field.ucUP = UP;\n\t\tpTSInfo->field.ucTSInfoAckPolicy = 0;\n\t\tpTSInfo->field.ucSchedule = 0;\n\n\t\tMakeTSEntry(*ppTS, Addr, &TSpec, NULL, 0, 0);\n\t\tlist_add_tail(&((*ppTS)->List), pAddmitList);\n\n\t\treturn true;\n\t}\n\n\tnetdev_warn(ieee->dev,\n\t\t    \"There is not enough dir=%d(0=up down=1) TS record to be used!\",\n\t\t    Dir);\n\treturn false;\n}\n\nstatic void RemoveTsEntry(struct rtllib_device *ieee,\n\t\t\t  struct ts_common_info *pTs, enum tr_select TxRxSelect)\n{\n\trtllib_ts_init_del_ba(ieee, pTs, TxRxSelect);\n\n\tif (TxRxSelect == RX_DIR) {\n\t\tstruct rx_reorder_entry *pRxReorderEntry;\n\t\tstruct rx_ts_record *pRxTS = (struct rx_ts_record *)pTs;\n\n\t\tif (timer_pending(&pRxTS->rx_pkt_pending_timer))\n\t\t\tdel_timer_sync(&pRxTS->rx_pkt_pending_timer);\n\n\t\twhile (!list_empty(&pRxTS->rx_pending_pkt_list)) {\n\t\t\tpRxReorderEntry = (struct rx_reorder_entry *)\n\t\t\t\t\tlist_entry(pRxTS->rx_pending_pkt_list.prev,\n\t\t\t\t\tstruct rx_reorder_entry, List);\n\t\t\tnetdev_dbg(ieee->dev,  \"%s(): Delete SeqNum %d!\\n\",\n\t\t\t\t   __func__, pRxReorderEntry->SeqNum);\n\t\t\tlist_del_init(&pRxReorderEntry->List);\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\tstruct rtllib_rxb *prxb = pRxReorderEntry->prxb;\n\n\t\t\t\tif (unlikely(!prxb))\n\t\t\t\t\treturn;\n\t\t\t\tfor (i = 0; i < prxb->nr_subframes; i++)\n\t\t\t\t\tdev_kfree_skb(prxb->subframes[i]);\n\t\t\t\tkfree(prxb);\n\t\t\t\tprxb = NULL;\n\t\t\t}\n\t\t\tlist_add_tail(&pRxReorderEntry->List,\n\t\t\t\t      &ieee->RxReorder_Unused_List);\n\t\t}\n\t} else {\n\t\tstruct tx_ts_record *pTxTS = (struct tx_ts_record *)pTs;\n\n\t\tdel_timer_sync(&pTxTS->TsAddBaTimer);\n\t}\n}\n\nvoid RemovePeerTS(struct rtllib_device *ieee, u8 *Addr)\n{\n\tstruct ts_common_info *pTS, *pTmpTS;\n\n\tnetdev_info(ieee->dev, \"===========>%s, %pM\\n\", __func__, Addr);\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Pending_List, List) {\n\t\tif (memcmp(pTS->Addr, Addr, 6) == 0) {\n\t\t\tRemoveTsEntry(ieee, pTS, TX_DIR);\n\t\t\tlist_del_init(&pTS->List);\n\t\t\tlist_add_tail(&pTS->List, &ieee->Tx_TS_Unused_List);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Admit_List, List) {\n\t\tif (memcmp(pTS->Addr, Addr, 6) == 0) {\n\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t    \"====>remove Tx_TS_admin_list\\n\");\n\t\t\tRemoveTsEntry(ieee, pTS, TX_DIR);\n\t\t\tlist_del_init(&pTS->List);\n\t\t\tlist_add_tail(&pTS->List, &ieee->Tx_TS_Unused_List);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Rx_TS_Pending_List, List) {\n\t\tif (memcmp(pTS->Addr, Addr, 6) == 0) {\n\t\t\tRemoveTsEntry(ieee, pTS, RX_DIR);\n\t\t\tlist_del_init(&pTS->List);\n\t\t\tlist_add_tail(&pTS->List, &ieee->Rx_TS_Unused_List);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Rx_TS_Admit_List, List) {\n\t\tif (memcmp(pTS->Addr, Addr, 6) == 0) {\n\t\t\tRemoveTsEntry(ieee, pTS, RX_DIR);\n\t\t\tlist_del_init(&pTS->List);\n\t\t\tlist_add_tail(&pTS->List, &ieee->Rx_TS_Unused_List);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(RemovePeerTS);\n\nvoid RemoveAllTS(struct rtllib_device *ieee)\n{\n\tstruct ts_common_info *pTS, *pTmpTS;\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Pending_List, List) {\n\t\tRemoveTsEntry(ieee, pTS, TX_DIR);\n\t\tlist_del_init(&pTS->List);\n\t\tlist_add_tail(&pTS->List, &ieee->Tx_TS_Unused_List);\n\t}\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Admit_List, List) {\n\t\tRemoveTsEntry(ieee, pTS, TX_DIR);\n\t\tlist_del_init(&pTS->List);\n\t\tlist_add_tail(&pTS->List, &ieee->Tx_TS_Unused_List);\n\t}\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Rx_TS_Pending_List, List) {\n\t\tRemoveTsEntry(ieee, pTS, RX_DIR);\n\t\tlist_del_init(&pTS->List);\n\t\tlist_add_tail(&pTS->List, &ieee->Rx_TS_Unused_List);\n\t}\n\n\tlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Rx_TS_Admit_List, List) {\n\t\tRemoveTsEntry(ieee, pTS, RX_DIR);\n\t\tlist_del_init(&pTS->List);\n\t\tlist_add_tail(&pTS->List, &ieee->Rx_TS_Unused_List);\n\t}\n}\n\nvoid TsStartAddBaProcess(struct rtllib_device *ieee, struct tx_ts_record *pTxTS)\n{\n\tif (pTxTS->bAddBaReqInProgress == false) {\n\t\tpTxTS->bAddBaReqInProgress = true;\n\n\t\tif (pTxTS->bAddBaReqDelayed) {\n\t\t\tnetdev_dbg(ieee->dev, \"Start ADDBA after 60 sec!!\\n\");\n\t\t\tmod_timer(&pTxTS->TsAddBaTimer, jiffies +\n\t\t\t\t  msecs_to_jiffies(TS_ADDBA_DELAY));\n\t\t} else {\n\t\t\tnetdev_dbg(ieee->dev, \"Immediately Start ADDBA\\n\");\n\t\t\tmod_timer(&pTxTS->TsAddBaTimer, jiffies + 10);\n\t\t}\n\t} else {\n\t\tnetdev_dbg(ieee->dev, \"BA timer is already added\\n\");\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}