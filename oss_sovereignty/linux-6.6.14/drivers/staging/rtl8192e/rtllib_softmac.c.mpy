{
  "module_name": "rtllib_softmac.c",
  "hash_id": "5dadbf7f27d5a14d40edaa09d603666129cbc82bedca3c13acda5762c66afd1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtllib_softmac.c",
  "human_readable_source": "\n \n#include \"rtllib.h\"\n\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <linux/etherdevice.h>\n#include <linux/ieee80211.h>\n#include \"dot11d.h\"\n\nstatic void rtllib_sta_wakeup(struct rtllib_device *ieee, short nl);\n\nstatic short rtllib_is_54g(struct rtllib_network *net)\n{\n\treturn (net->rates_ex_len > 0) || (net->rates_len > 4);\n}\n\n \nstatic unsigned int rtllib_MFIE_rate_len(struct rtllib_device *ieee)\n{\n\tunsigned int rate_len = 0;\n\n\trate_len = RTLLIB_CCK_RATE_LEN + 2;\n\trate_len += RTLLIB_OFDM_RATE_LEN + 2;\n\n\treturn rate_len;\n}\n\n \nstatic void rtllib_MFIE_Brate(struct rtllib_device *ieee, u8 **tag_p)\n{\n\tu8 *tag = *tag_p;\n\n\t*tag++ = MFIE_TYPE_RATES;\n\t*tag++ = 4;\n\t*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_1MB;\n\t*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_2MB;\n\t*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_5MB;\n\t*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_11MB;\n\n\t \n\t*tag_p = tag;\n}\n\nstatic void rtllib_MFIE_Grate(struct rtllib_device *ieee, u8 **tag_p)\n{\n\tu8 *tag = *tag_p;\n\n\t*tag++ = MFIE_TYPE_RATES_EX;\n\t*tag++ = 8;\n\t*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_6MB;\n\t*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_9MB;\n\t*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_12MB;\n\t*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_18MB;\n\t*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_24MB;\n\t*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_36MB;\n\t*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_48MB;\n\t*tag++ = RTLLIB_BASIC_RATE_MASK | RTLLIB_OFDM_RATE_54MB;\n\n\t \n\t*tag_p = tag;\n}\n\nstatic void rtllib_WMM_Info(struct rtllib_device *ieee, u8 **tag_p)\n{\n\tu8 *tag = *tag_p;\n\n\t*tag++ = MFIE_TYPE_GENERIC;\n\t*tag++ = 7;\n\t*tag++ = 0x00;\n\t*tag++ = 0x50;\n\t*tag++ = 0xf2;\n\t*tag++ = 0x02;\n\t*tag++ = 0x00;\n\t*tag++ = 0x01;\n\t*tag++ = MAX_SP_Len;\n\t*tag_p = tag;\n}\n\nstatic void rtllib_TURBO_Info(struct rtllib_device *ieee, u8 **tag_p)\n{\n\tu8 *tag = *tag_p;\n\n\t*tag++ = MFIE_TYPE_GENERIC;\n\t*tag++ = 7;\n\t*tag++ = 0x00;\n\t*tag++ = 0xe0;\n\t*tag++ = 0x4c;\n\t*tag++ = 0x01;\n\t*tag++ = 0x02;\n\t*tag++ = 0x11;\n\t*tag++ = 0x00;\n\n\t*tag_p = tag;\n\tnetdev_alert(ieee->dev, \"This is enable turbo mode IE process\\n\");\n}\n\nstatic void enqueue_mgmt(struct rtllib_device *ieee, struct sk_buff *skb)\n{\n\tint nh;\n\n\tnh = (ieee->mgmt_queue_head + 1) % MGMT_QUEUE_NUM;\n\n \n\tieee->mgmt_queue_head = nh;\n\tieee->mgmt_queue_ring[nh] = skb;\n}\n\nstatic void init_mgmt_queue(struct rtllib_device *ieee)\n{\n\tieee->mgmt_queue_tail = ieee->mgmt_queue_head = 0;\n}\n\nu8 MgntQuery_TxRateExcludeCCKRates(struct rtllib_device *ieee)\n{\n\tu16\ti;\n\tu8\tQueryRate = 0;\n\tu8\tBasicRate;\n\n\tfor (i = 0; i < ieee->current_network.rates_len; i++) {\n\t\tBasicRate = ieee->current_network.rates[i] & 0x7F;\n\t\tif (!rtllib_is_cck_rate(BasicRate)) {\n\t\t\tif (QueryRate == 0) {\n\t\t\t\tQueryRate = BasicRate;\n\t\t\t} else {\n\t\t\t\tif (BasicRate < QueryRate)\n\t\t\t\t\tQueryRate = BasicRate;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (QueryRate == 0) {\n\t\tQueryRate = 12;\n\t\tnetdev_info(ieee->dev, \"No BasicRate found!!\\n\");\n\t}\n\treturn QueryRate;\n}\n\nstatic u8 MgntQuery_MgntFrameTxRate(struct rtllib_device *ieee)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\tu8 rate;\n\n\tif (ht_info->iot_action & HT_IOT_ACT_MGNT_USE_CCK_6M)\n\t\trate = 0x0c;\n\telse\n\t\trate = ieee->basic_rate & 0x7f;\n\n\tif (rate == 0) {\n\t\tif (ieee->mode == WIRELESS_MODE_N_24G && !ht_info->bCurSuppCCK)\n\t\t\trate = 0x0c;\n\t\telse\n\t\t\trate = 0x02;\n\t}\n\n\treturn rate;\n}\n\ninline void softmac_mgmt_xmit(struct sk_buff *skb, struct rtllib_device *ieee)\n{\n\tunsigned long flags;\n\tshort single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;\n\tstruct rtllib_hdr_3addr  *header =\n\t\t(struct rtllib_hdr_3addr  *)skb->data;\n\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + 8);\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\t \n\trtllib_sta_wakeup(ieee, 0);\n\n\tif (le16_to_cpu(header->frame_ctl) == RTLLIB_STYPE_BEACON)\n\t\ttcb_desc->queue_index = BEACON_QUEUE;\n\telse\n\t\ttcb_desc->queue_index = MGNT_QUEUE;\n\n\tif (ieee->disable_mgnt_queue)\n\t\ttcb_desc->queue_index = HIGH_QUEUE;\n\n\ttcb_desc->data_rate = MgntQuery_MgntFrameTxRate(ieee);\n\ttcb_desc->ratr_index = 7;\n\ttcb_desc->tx_dis_rate_fallback = 1;\n\ttcb_desc->tx_use_drv_assinged_rate = 1;\n\tif (single) {\n\t\tif (ieee->queue_stop) {\n\t\t\tenqueue_mgmt(ieee, skb);\n\t\t} else {\n\t\t\theader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\n\n\t\t\tif (ieee->seq_ctrl[0] == 0xFFF)\n\t\t\t\tieee->seq_ctrl[0] = 0;\n\t\t\telse\n\t\t\t\tieee->seq_ctrl[0]++;\n\n\t\t\t \n\t\t\tieee->softmac_data_hard_start_xmit(skb, ieee->dev,\n\t\t\t\t\t\t\t   ieee->basic_rate);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&ieee->lock, flags);\n\t} else {\n\t\tspin_unlock_irqrestore(&ieee->lock, flags);\n\t\tspin_lock_irqsave(&ieee->mgmt_tx_lock, flags);\n\n\t\theader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\n\n\t\tif (ieee->seq_ctrl[0] == 0xFFF)\n\t\t\tieee->seq_ctrl[0] = 0;\n\t\telse\n\t\t\tieee->seq_ctrl[0]++;\n\n\t\t \n\t\tif (!ieee->check_nic_enough_desc(ieee->dev,\n\t\t\t\t\t\t tcb_desc->queue_index) ||\n\t\t    skb_queue_len(&ieee->skb_waitQ[tcb_desc->queue_index]) ||\n\t\t    ieee->queue_stop) {\n\t\t\t \n\t\t\tnetdev_info(ieee->dev,\n\t\t\t       \"%s():insert to waitqueue, queue_index:%d!\\n\",\n\t\t\t       __func__, tcb_desc->queue_index);\n\t\t\tskb_queue_tail(&ieee->skb_waitQ[tcb_desc->queue_index],\n\t\t\t\t       skb);\n\t\t} else {\n\t\t\tieee->softmac_hard_start_xmit(skb, ieee->dev);\n\t\t}\n\t\tspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags);\n\t}\n}\n\nstatic inline void\nsoftmac_ps_mgmt_xmit(struct sk_buff *skb,\n\t\t     struct rtllib_device *ieee)\n{\n\tshort single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;\n\tstruct rtllib_hdr_3addr  *header =\n\t\t(struct rtllib_hdr_3addr  *)skb->data;\n\tu16 fc, type, stype;\n\tstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb + 8);\n\n\tfc = le16_to_cpu(header->frame_ctl);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tstype = WLAN_FC_GET_STYPE(fc);\n\n\tif (stype != RTLLIB_STYPE_PSPOLL)\n\t\ttcb_desc->queue_index = MGNT_QUEUE;\n\telse\n\t\ttcb_desc->queue_index = HIGH_QUEUE;\n\n\tif (ieee->disable_mgnt_queue)\n\t\ttcb_desc->queue_index = HIGH_QUEUE;\n\n\ttcb_desc->data_rate = MgntQuery_MgntFrameTxRate(ieee);\n\ttcb_desc->ratr_index = 7;\n\ttcb_desc->tx_dis_rate_fallback = 1;\n\ttcb_desc->tx_use_drv_assinged_rate = 1;\n\tif (single) {\n\t\tif (type != RTLLIB_FTYPE_CTL) {\n\t\t\theader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\n\n\t\t\tif (ieee->seq_ctrl[0] == 0xFFF)\n\t\t\t\tieee->seq_ctrl[0] = 0;\n\t\t\telse\n\t\t\t\tieee->seq_ctrl[0]++;\n\t\t}\n\t\t \n\t\tieee->softmac_data_hard_start_xmit(skb, ieee->dev,\n\t\t\t\t\t\t   ieee->basic_rate);\n\n\t} else {\n\t\tif (type != RTLLIB_FTYPE_CTL) {\n\t\t\theader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\n\n\t\t\tif (ieee->seq_ctrl[0] == 0xFFF)\n\t\t\t\tieee->seq_ctrl[0] = 0;\n\t\t\telse\n\t\t\t\tieee->seq_ctrl[0]++;\n\t\t}\n\t\tieee->softmac_hard_start_xmit(skb, ieee->dev);\n\t}\n}\n\nstatic inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)\n{\n\tunsigned int len, rate_len;\n\tu8 *tag;\n\tstruct sk_buff *skb;\n\tstruct rtllib_probe_request *req;\n\n\tlen = ieee->current_network.ssid_len;\n\n\trate_len = rtllib_MFIE_rate_len(ieee);\n\n\tskb = dev_alloc_skb(sizeof(struct rtllib_probe_request) +\n\t\t\t    2 + len + rate_len + ieee->tx_headroom);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\treq = skb_put(skb, sizeof(struct rtllib_probe_request));\n\treq->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_PROBE_REQ);\n\treq->header.duration_id = 0;\n\n\teth_broadcast_addr(req->header.addr1);\n\tether_addr_copy(req->header.addr2, ieee->dev->dev_addr);\n\teth_broadcast_addr(req->header.addr3);\n\n\ttag = skb_put(skb, len + 2 + rate_len);\n\n\t*tag++ = MFIE_TYPE_SSID;\n\t*tag++ = len;\n\tmemcpy(tag, ieee->current_network.ssid, len);\n\ttag += len;\n\n\trtllib_MFIE_Brate(ieee, &tag);\n\trtllib_MFIE_Grate(ieee, &tag);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee);\n\nstatic void rtllib_send_beacon(struct rtllib_device *ieee)\n{\n\tstruct sk_buff *skb;\n\n\tif (!ieee->ieee_up)\n\t\treturn;\n\tskb = rtllib_get_beacon_(ieee);\n\n\tif (skb) {\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\tieee->softmac_stats.tx_beacons++;\n\t}\n\n\tif (ieee->beacon_txing && ieee->ieee_up)\n\t\tmod_timer(&ieee->beacon_timer, jiffies +\n\t\t\t  (msecs_to_jiffies(ieee->current_network.beacon_interval - 5)));\n}\n\nstatic void rtllib_send_beacon_cb(struct timer_list *t)\n{\n\tstruct rtllib_device *ieee =\n\t\tfrom_timer(ieee, t, beacon_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ieee->beacon_lock, flags);\n\trtllib_send_beacon(ieee);\n\tspin_unlock_irqrestore(&ieee->beacon_lock, flags);\n}\n\n \nvoid rtllib_EnableNetMonitorMode(struct net_device *dev,\n\t\tbool bInitState)\n{\n\tstruct rtllib_device *ieee = netdev_priv_rsl(dev);\n\n\tnetdev_info(dev, \"========>Enter Monitor Mode\\n\");\n\n\tieee->AllowAllDestAddrHandler(dev, true, !bInitState);\n}\n\n \nvoid rtllib_DisableNetMonitorMode(struct net_device *dev,\n\t\tbool bInitState)\n{\n\tstruct rtllib_device *ieee = netdev_priv_rsl(dev);\n\n\tnetdev_info(dev, \"========>Exit Monitor Mode\\n\");\n\n\tieee->AllowAllDestAddrHandler(dev, false, !bInitState);\n}\n\n \nvoid rtllib_EnableIntelPromiscuousMode(struct net_device *dev,\n\t\tbool bInitState)\n{\n\tbool bFilterOutNonAssociatedBSSID = false;\n\n\tstruct rtllib_device *ieee = netdev_priv_rsl(dev);\n\n\tnetdev_info(dev, \"========>Enter Intel Promiscuous Mode\\n\");\n\n\tieee->AllowAllDestAddrHandler(dev, true, !bInitState);\n\tieee->SetHwRegHandler(dev, HW_VAR_CECHK_BSSID,\n\t\t\t     (u8 *)&bFilterOutNonAssociatedBSSID);\n\n\tieee->net_promiscuous_md = true;\n}\nEXPORT_SYMBOL(rtllib_EnableIntelPromiscuousMode);\n\n \nvoid rtllib_DisableIntelPromiscuousMode(struct net_device *dev,\n\t\tbool bInitState)\n{\n\tbool bFilterOutNonAssociatedBSSID = true;\n\n\tstruct rtllib_device *ieee = netdev_priv_rsl(dev);\n\n\tnetdev_info(dev, \"========>Exit Intel Promiscuous Mode\\n\");\n\n\tieee->AllowAllDestAddrHandler(dev, false, !bInitState);\n\tieee->SetHwRegHandler(dev, HW_VAR_CECHK_BSSID,\n\t\t\t     (u8 *)&bFilterOutNonAssociatedBSSID);\n\n\tieee->net_promiscuous_md = false;\n}\nEXPORT_SYMBOL(rtllib_DisableIntelPromiscuousMode);\n\nstatic void rtllib_send_probe(struct rtllib_device *ieee)\n{\n\tstruct sk_buff *skb;\n\n\tskb = rtllib_probe_req(ieee);\n\tif (skb) {\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\tieee->softmac_stats.tx_probe_rq++;\n\t}\n}\n\nstatic void rtllib_send_probe_requests(struct rtllib_device *ieee)\n{\n\tif (ieee->active_scan && (ieee->softmac_features &\n\t    IEEE_SOFTMAC_PROBERQ)) {\n\t\trtllib_send_probe(ieee);\n\t\trtllib_send_probe(ieee);\n\t}\n}\n\nstatic void rtllib_update_active_chan_map(struct rtllib_device *ieee)\n{\n\tmemcpy(ieee->active_channel_map, GET_DOT11D_INFO(ieee)->channel_map,\n\t       MAX_CHANNEL_NUMBER + 1);\n}\n\n \nstatic void rtllib_softmac_scan_syncro(struct rtllib_device *ieee)\n{\n\tunion iwreq_data wrqu;\n\tshort ch = 0;\n\n\trtllib_update_active_chan_map(ieee);\n\n\tieee->be_scan_inprogress = true;\n\n\tmutex_lock(&ieee->scan_mutex);\n\n\twhile (1) {\n\t\tdo {\n\t\t\tch++;\n\t\t\tif (ch > MAX_CHANNEL_NUMBER)\n\t\t\t\tgoto out;  \n\t\t} while (!ieee->active_channel_map[ch]);\n\n\t\t \n\n\t\tif (ieee->link_state == MAC80211_LINKED)\n\t\t\tgoto out;\n\t\tif (ieee->sync_scan_hurryup) {\n\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t    \"============>sync_scan_hurryup out\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tieee->set_chan(ieee->dev, ch);\n\t\tif (ieee->active_channel_map[ch] == 1)\n\t\t\trtllib_send_probe_requests(ieee);\n\n\t\t \n\t\tmsleep_interruptible_rsl(RTLLIB_SOFTMAC_SCAN_TIME);\n\t}\nout:\n\tieee->actscanning = false;\n\tieee->sync_scan_hurryup = 0;\n\n\tif (ieee->link_state >= MAC80211_LINKED) {\n\t\tif (IS_DOT11D_ENABLE(ieee))\n\t\t\tdot11d_scan_complete(ieee);\n\t}\n\tmutex_unlock(&ieee->scan_mutex);\n\n\tieee->be_scan_inprogress = false;\n\n\tmemset(&wrqu, 0, sizeof(wrqu));\n\twireless_send_event(ieee->dev, SIOCGIWSCAN, &wrqu, NULL);\n}\n\nstatic void rtllib_softmac_scan_wq(void *data)\n{\n\tstruct rtllib_device *ieee = container_of_dwork_rsl(data,\n\t\t\t\t     struct rtllib_device, softmac_scan_wq);\n\tu8 last_channel = ieee->current_network.channel;\n\n\trtllib_update_active_chan_map(ieee);\n\n\tif (!ieee->ieee_up)\n\t\treturn;\n\tif (rtllib_act_scanning(ieee, true))\n\t\treturn;\n\n\tmutex_lock(&ieee->scan_mutex);\n\n\tif (ieee->rf_power_state == rf_off) {\n\t\tnetdev_info(ieee->dev,\n\t\t\t    \"======>%s():rf state is rf_off, return\\n\",\n\t\t\t    __func__);\n\t\tgoto out1;\n\t}\n\n\tdo {\n\t\tieee->current_network.channel =\n\t\t\t(ieee->current_network.channel + 1) %\n\t\t\tMAX_CHANNEL_NUMBER;\n\t\tif (ieee->scan_watch_dog++ > MAX_CHANNEL_NUMBER) {\n\t\t\tif (!ieee->active_channel_map[ieee->current_network.channel])\n\t\t\t\tieee->current_network.channel = 6;\n\t\t\tgoto out;  \n\t\t}\n\t} while (!ieee->active_channel_map[ieee->current_network.channel]);\n\n\tif (ieee->scanning_continue == 0)\n\t\tgoto out;\n\n\tieee->set_chan(ieee->dev, ieee->current_network.channel);\n\n\tif (ieee->active_channel_map[ieee->current_network.channel] == 1)\n\t\trtllib_send_probe_requests(ieee);\n\n\tschedule_delayed_work(&ieee->softmac_scan_wq,\n\t\t\t      msecs_to_jiffies(RTLLIB_SOFTMAC_SCAN_TIME));\n\n\tmutex_unlock(&ieee->scan_mutex);\n\treturn;\n\nout:\n\tif (IS_DOT11D_ENABLE(ieee))\n\t\tdot11d_scan_complete(ieee);\n\tieee->current_network.channel = last_channel;\n\nout1:\n\tieee->actscanning = false;\n\tieee->scan_watch_dog = 0;\n\tieee->scanning_continue = 0;\n\tmutex_unlock(&ieee->scan_mutex);\n}\n\nstatic void rtllib_beacons_start(struct rtllib_device *ieee)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ieee->beacon_lock, flags);\n\n\tieee->beacon_txing = 1;\n\trtllib_send_beacon(ieee);\n\n\tspin_unlock_irqrestore(&ieee->beacon_lock, flags);\n}\n\nstatic void rtllib_beacons_stop(struct rtllib_device *ieee)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ieee->beacon_lock, flags);\n\n\tieee->beacon_txing = 0;\n\n\tspin_unlock_irqrestore(&ieee->beacon_lock, flags);\n\tdel_timer_sync(&ieee->beacon_timer);\n}\n\nvoid rtllib_stop_send_beacons(struct rtllib_device *ieee)\n{\n\tieee->stop_send_beacons(ieee->dev);\n\tif (ieee->softmac_features & IEEE_SOFTMAC_BEACONS)\n\t\trtllib_beacons_stop(ieee);\n}\nEXPORT_SYMBOL(rtllib_stop_send_beacons);\n\nvoid rtllib_start_send_beacons(struct rtllib_device *ieee)\n{\n\tieee->start_send_beacons(ieee->dev);\n\tif (ieee->softmac_features & IEEE_SOFTMAC_BEACONS)\n\t\trtllib_beacons_start(ieee);\n}\nEXPORT_SYMBOL(rtllib_start_send_beacons);\n\nstatic void rtllib_softmac_stop_scan(struct rtllib_device *ieee)\n{\n\tmutex_lock(&ieee->scan_mutex);\n\tieee->scan_watch_dog = 0;\n\tif (ieee->scanning_continue == 1) {\n\t\tieee->scanning_continue = 0;\n\t\tieee->actscanning = false;\n\t\tmutex_unlock(&ieee->scan_mutex);\n\t\tcancel_delayed_work_sync(&ieee->softmac_scan_wq);\n\t} else {\n\t\tmutex_unlock(&ieee->scan_mutex);\n\t}\n}\n\nvoid rtllib_stop_scan(struct rtllib_device *ieee)\n{\n\tif (ieee->softmac_features & IEEE_SOFTMAC_SCAN)\n\t\trtllib_softmac_stop_scan(ieee);\n}\nEXPORT_SYMBOL(rtllib_stop_scan);\n\nvoid rtllib_stop_scan_syncro(struct rtllib_device *ieee)\n{\n\tif (ieee->softmac_features & IEEE_SOFTMAC_SCAN)\n\t\tieee->sync_scan_hurryup = 1;\n}\nEXPORT_SYMBOL(rtllib_stop_scan_syncro);\n\nbool rtllib_act_scanning(struct rtllib_device *ieee, bool sync_scan)\n{\n\tif (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {\n\t\tif (sync_scan)\n\t\t\treturn ieee->be_scan_inprogress;\n\t\telse\n\t\t\treturn ieee->actscanning || ieee->be_scan_inprogress;\n\t} else {\n\t\treturn test_bit(STATUS_SCANNING, &ieee->status);\n\t}\n}\nEXPORT_SYMBOL(rtllib_act_scanning);\n\n \nstatic void rtllib_start_scan(struct rtllib_device *ieee)\n{\n\tieee->rtllib_ips_leave_wq(ieee->dev);\n\n\tif (IS_DOT11D_ENABLE(ieee)) {\n\t\tif (IS_COUNTRY_IE_VALID(ieee))\n\t\t\tRESET_CIE_WATCHDOG(ieee);\n\t}\n\tif (ieee->softmac_features & IEEE_SOFTMAC_SCAN) {\n\t\tif (ieee->scanning_continue == 0) {\n\t\t\tieee->actscanning = true;\n\t\t\tieee->scanning_continue = 1;\n\t\t\tschedule_delayed_work(&ieee->softmac_scan_wq, 0);\n\t\t}\n\t}\n}\n\n \nvoid rtllib_start_scan_syncro(struct rtllib_device *ieee)\n{\n\tif (IS_DOT11D_ENABLE(ieee)) {\n\t\tif (IS_COUNTRY_IE_VALID(ieee))\n\t\t\tRESET_CIE_WATCHDOG(ieee);\n\t}\n\tieee->sync_scan_hurryup = 0;\n\tif (ieee->softmac_features & IEEE_SOFTMAC_SCAN)\n\t\trtllib_softmac_scan_syncro(ieee);\n}\nEXPORT_SYMBOL(rtllib_start_scan_syncro);\n\nstatic inline struct sk_buff *\nrtllib_authentication_req(struct rtllib_network *beacon,\n\t\t\t  struct rtllib_device *ieee,\n\t\t\t  int challengelen, u8 *daddr)\n{\n\tstruct sk_buff *skb;\n\tstruct rtllib_authentication *auth;\n\tint  len;\n\n\tlen = sizeof(struct rtllib_authentication) + challengelen +\n\t\t     ieee->tx_headroom + 4;\n\tskb = dev_alloc_skb(len);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\tauth = skb_put(skb, sizeof(struct rtllib_authentication));\n\n\tauth->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_AUTH);\n\tif (challengelen)\n\t\tauth->header.frame_ctl |= cpu_to_le16(RTLLIB_FCTL_WEP);\n\n\tauth->header.duration_id = cpu_to_le16(0x013a);\n\tether_addr_copy(auth->header.addr1, beacon->bssid);\n\tether_addr_copy(auth->header.addr2, ieee->dev->dev_addr);\n\tether_addr_copy(auth->header.addr3, beacon->bssid);\n\tif (ieee->auth_mode == 0)\n\t\tauth->algorithm = WLAN_AUTH_OPEN;\n\telse if (ieee->auth_mode == 1)\n\t\tauth->algorithm = cpu_to_le16(WLAN_AUTH_SHARED_KEY);\n\telse if (ieee->auth_mode == 2)\n\t\tauth->algorithm = WLAN_AUTH_OPEN;\n\tauth->transaction = cpu_to_le16(ieee->associate_seq);\n\tieee->associate_seq++;\n\n\tauth->status = cpu_to_le16(WLAN_STATUS_SUCCESS);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *rtllib_probe_resp(struct rtllib_device *ieee,\n\t\t\t\t\t const u8 *dest)\n{\n\tu8 *tag;\n\tint beacon_size;\n\tstruct rtllib_probe_response *beacon_buf;\n\tstruct sk_buff *skb = NULL;\n\tint encrypt;\n\tint atim_len, erp_len;\n\tstruct lib80211_crypt_data *crypt;\n\n\tchar *ssid = ieee->current_network.ssid;\n\tint ssid_len = ieee->current_network.ssid_len;\n\tint rate_len = ieee->current_network.rates_len + 2;\n\tint rate_ex_len = ieee->current_network.rates_ex_len;\n\tint wpa_ie_len = ieee->wpa_ie_len;\n\tu8 erpinfo_content = 0;\n\n\tu8 *tmp_ht_cap_buf = NULL;\n\tu8 tmp_ht_cap_len = 0;\n\tu8 *tmp_ht_info_buf = NULL;\n\tu8 tmp_ht_info_len = 0;\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\tu8 *tmp_generic_ie_buf = NULL;\n\tu8 tmp_generic_ie_len = 0;\n\n\tif (rate_ex_len > 0)\n\t\trate_ex_len += 2;\n\n\tif (ieee->current_network.capability & WLAN_CAPABILITY_IBSS)\n\t\tatim_len = 4;\n\telse\n\t\tatim_len = 0;\n\n\tif ((ieee->current_network.mode == WIRELESS_MODE_G) ||\n\t   (ieee->current_network.mode == WIRELESS_MODE_N_24G &&\n\t   ieee->ht_info->bCurSuppCCK)) {\n\t\terp_len = 3;\n\t\terpinfo_content = 0;\n\t\tif (ieee->current_network.buseprotection)\n\t\t\terpinfo_content |= ERP_UseProtection;\n\t} else {\n\t\terp_len = 0;\n\t}\n\n\tcrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\n\tencrypt = crypt && crypt->ops &&\n\t\t((strcmp(crypt->ops->name, \"R-WEP\") == 0 || wpa_ie_len));\n\tif (ieee->ht_info->bCurrentHTSupport) {\n\t\ttmp_ht_cap_buf = (u8 *)&(ieee->ht_info->SelfHTCap);\n\t\ttmp_ht_cap_len = sizeof(ieee->ht_info->SelfHTCap);\n\t\ttmp_ht_info_buf = (u8 *)&(ieee->ht_info->SelfHTInfo);\n\t\ttmp_ht_info_len = sizeof(ieee->ht_info->SelfHTInfo);\n\t\tHTConstructCapabilityElement(ieee, tmp_ht_cap_buf,\n\t\t\t\t\t     &tmp_ht_cap_len, encrypt, false);\n\t\tHTConstructInfoElement(ieee, tmp_ht_info_buf, &tmp_ht_info_len,\n\t\t\t\t       encrypt);\n\n\t\tif (ht_info->reg_rt2rt_aggregation) {\n\t\t\ttmp_generic_ie_buf = ieee->ht_info->sz_rt2rt_agg_buf;\n\t\t\ttmp_generic_ie_len =\n\t\t\t\t sizeof(ieee->ht_info->sz_rt2rt_agg_buf);\n\t\t\tHTConstructRT2RTAggElement(ieee, tmp_generic_ie_buf,\n\t\t\t\t\t\t   &tmp_generic_ie_len);\n\t\t}\n\t}\n\n\tbeacon_size = sizeof(struct rtllib_probe_response) + 2 +\n\t\tssid_len + 3 + rate_len + rate_ex_len + atim_len + erp_len\n\t\t+ wpa_ie_len + ieee->tx_headroom;\n\tskb = dev_alloc_skb(beacon_size);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\tbeacon_buf = skb_put(skb, (beacon_size - ieee->tx_headroom));\n\tether_addr_copy(beacon_buf->header.addr1, dest);\n\tether_addr_copy(beacon_buf->header.addr2, ieee->dev->dev_addr);\n\tether_addr_copy(beacon_buf->header.addr3, ieee->current_network.bssid);\n\n\tbeacon_buf->header.duration_id = 0;\n\tbeacon_buf->beacon_interval =\n\t\tcpu_to_le16(ieee->current_network.beacon_interval);\n\tbeacon_buf->capability =\n\t\tcpu_to_le16(ieee->current_network.capability &\n\t\tWLAN_CAPABILITY_IBSS);\n\tbeacon_buf->capability |=\n\t\tcpu_to_le16(ieee->current_network.capability &\n\t\tWLAN_CAPABILITY_SHORT_PREAMBLE);\n\n\tif (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_SLOT_TIME)\n\t\tbeacon_buf->capability |=\n\t\t\tcpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);\n\n\tcrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\n\tif (encrypt)\n\t\tbeacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\n\n\tbeacon_buf->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_PROBE_RESP);\n\tbeacon_buf->info_element[0].id = MFIE_TYPE_SSID;\n\tbeacon_buf->info_element[0].len = ssid_len;\n\n\ttag = (u8 *)beacon_buf->info_element[0].data;\n\n\tmemcpy(tag, ssid, ssid_len);\n\n\ttag += ssid_len;\n\n\t*(tag++) = MFIE_TYPE_RATES;\n\t*(tag++) = rate_len - 2;\n\tmemcpy(tag, ieee->current_network.rates, rate_len - 2);\n\ttag += rate_len - 2;\n\n\t*(tag++) = MFIE_TYPE_DS_SET;\n\t*(tag++) = 1;\n\t*(tag++) = ieee->current_network.channel;\n\n\tif (atim_len) {\n\t\tu16 val16;\n\t\t*(tag++) = MFIE_TYPE_IBSS_SET;\n\t\t*(tag++) = 2;\n\t\tval16 = ieee->current_network.atim_window;\n\t\tmemcpy((u8 *)tag, (u8 *)&val16, 2);\n\t\ttag += 2;\n\t}\n\n\tif (erp_len) {\n\t\t*(tag++) = MFIE_TYPE_ERP;\n\t\t*(tag++) = 1;\n\t\t*(tag++) = erpinfo_content;\n\t}\n\tif (rate_ex_len) {\n\t\t*(tag++) = MFIE_TYPE_RATES_EX;\n\t\t*(tag++) = rate_ex_len - 2;\n\t\tmemcpy(tag, ieee->current_network.rates_ex, rate_ex_len - 2);\n\t\ttag += rate_ex_len - 2;\n\t}\n\n\tif (wpa_ie_len) {\n\t\tif (ieee->iw_mode == IW_MODE_ADHOC)\n\t\t\tmemcpy(&ieee->wpa_ie[14], &ieee->wpa_ie[8], 4);\n\t\tmemcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);\n\t\ttag += ieee->wpa_ie_len;\n\t}\n\treturn skb;\n}\n\nstatic struct sk_buff *rtllib_null_func(struct rtllib_device *ieee, short pwr)\n{\n\tstruct sk_buff *skb;\n\tstruct rtllib_hdr_3addr *hdr;\n\n\tskb = dev_alloc_skb(sizeof(struct rtllib_hdr_3addr) + ieee->tx_headroom);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\thdr = skb_put(skb, sizeof(struct rtllib_hdr_3addr));\n\n\tether_addr_copy(hdr->addr1, ieee->current_network.bssid);\n\tether_addr_copy(hdr->addr2, ieee->dev->dev_addr);\n\tether_addr_copy(hdr->addr3, ieee->current_network.bssid);\n\n\thdr->frame_ctl = cpu_to_le16(RTLLIB_FTYPE_DATA |\n\t\tRTLLIB_STYPE_NULLFUNC | RTLLIB_FCTL_TODS |\n\t\t(pwr ? RTLLIB_FCTL_PM : 0));\n\n\treturn skb;\n}\n\nstatic struct sk_buff *rtllib_pspoll_func(struct rtllib_device *ieee)\n{\n\tstruct sk_buff *skb;\n\tstruct rtllib_pspoll_hdr *hdr;\n\n\tskb = dev_alloc_skb(sizeof(struct rtllib_pspoll_hdr) + ieee->tx_headroom);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\thdr = skb_put(skb, sizeof(struct rtllib_pspoll_hdr));\n\n\tether_addr_copy(hdr->bssid, ieee->current_network.bssid);\n\tether_addr_copy(hdr->ta, ieee->dev->dev_addr);\n\n\thdr->aid = cpu_to_le16(ieee->assoc_id | 0xc000);\n\thdr->frame_ctl = cpu_to_le16(RTLLIB_FTYPE_CTL | RTLLIB_STYPE_PSPOLL |\n\t\t\t RTLLIB_FCTL_PM);\n\n\treturn skb;\n}\n\nstatic void rtllib_resp_to_probe(struct rtllib_device *ieee, u8 *dest)\n{\n\tstruct sk_buff *buf = rtllib_probe_resp(ieee, dest);\n\n\tif (buf)\n\t\tsoftmac_mgmt_xmit(buf, ieee);\n}\n\nstatic inline int SecIsInPMKIDList(struct rtllib_device *ieee, u8 *bssid)\n{\n\tint i = 0;\n\n\tdo {\n\t\tif ((ieee->PMKIDList[i].bUsed) &&\n\t\t   (memcmp(ieee->PMKIDList[i].Bssid, bssid, ETH_ALEN) == 0))\n\t\t\tbreak;\n\t\ti++;\n\t} while (i < NUM_PMKID_CACHE);\n\n\tif (i == NUM_PMKID_CACHE)\n\t\ti = -1;\n\treturn i;\n}\n\nstatic inline struct sk_buff *\nrtllib_association_req(struct rtllib_network *beacon,\n\t\t       struct rtllib_device *ieee)\n{\n\tstruct sk_buff *skb;\n\tstruct rtllib_assoc_request_frame *hdr;\n\tu8 *tag, *ies;\n\tint i;\n\tu8 *ht_cap_buf = NULL;\n\tu8 ht_cap_len = 0;\n\tu8 *realtek_ie_buf = NULL;\n\tu8 realtek_ie_len = 0;\n\tint wpa_ie_len = ieee->wpa_ie_len;\n\tint wps_ie_len = ieee->wps_ie_len;\n\tunsigned int ckip_ie_len = 0;\n\tunsigned int ccxrm_ie_len = 0;\n\tunsigned int cxvernum_ie_len = 0;\n\tstruct lib80211_crypt_data *crypt;\n\tint encrypt;\n\tint\tPMKCacheIdx;\n\n\tunsigned int rate_len = (beacon->rates_len ?\n\t\t\t\t(beacon->rates_len + 2) : 0) +\n\t\t\t\t(beacon->rates_ex_len ? (beacon->rates_ex_len) +\n\t\t\t\t2 : 0);\n\n\tunsigned int wmm_info_len = beacon->qos_data.supported ? 9 : 0;\n\tunsigned int turbo_info_len = beacon->Turbo_Enable ? 9 : 0;\n\n\tint len = 0;\n\n\tcrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\n\tif (crypt != NULL)\n\t\tencrypt = crypt && crypt->ops &&\n\t\t\t  ((strcmp(crypt->ops->name, \"R-WEP\") == 0 ||\n\t\t\t  wpa_ie_len));\n\telse\n\t\tencrypt = 0;\n\n\tif ((ieee->rtllib_ap_sec_type &&\n\t    (ieee->rtllib_ap_sec_type(ieee) & SEC_ALG_TKIP)) ||\n\t    ieee->bForcedBgMode) {\n\t\tieee->ht_info->enable_ht = 0;\n\t\tieee->mode = WIRELESS_MODE_G;\n\t}\n\n\tif (ieee->ht_info->bCurrentHTSupport && ieee->ht_info->enable_ht) {\n\t\tht_cap_buf = (u8 *)&(ieee->ht_info->SelfHTCap);\n\t\tht_cap_len = sizeof(ieee->ht_info->SelfHTCap);\n\t\tHTConstructCapabilityElement(ieee, ht_cap_buf, &ht_cap_len,\n\t\t\t\t\t     encrypt, true);\n\t\tif (ieee->ht_info->current_rt2rt_aggregation) {\n\t\t\trealtek_ie_buf = ieee->ht_info->sz_rt2rt_agg_buf;\n\t\t\trealtek_ie_len =\n\t\t\t\t sizeof(ieee->ht_info->sz_rt2rt_agg_buf);\n\t\t\tHTConstructRT2RTAggElement(ieee, realtek_ie_buf,\n\t\t\t\t\t\t   &realtek_ie_len);\n\t\t}\n\t}\n\n\tif (beacon->bCkipSupported)\n\t\tckip_ie_len = 30 + 2;\n\tif (beacon->bCcxRmEnable)\n\t\tccxrm_ie_len = 6 + 2;\n\tif (beacon->BssCcxVerNumber >= 2)\n\t\tcxvernum_ie_len = 5 + 2;\n\n\tPMKCacheIdx = SecIsInPMKIDList(ieee, ieee->current_network.bssid);\n\tif (PMKCacheIdx >= 0) {\n\t\twpa_ie_len += 18;\n\t\tnetdev_info(ieee->dev, \"[PMK cache]: WPA2 IE length: %x\\n\",\n\t\t\t    wpa_ie_len);\n\t}\n\tlen = sizeof(struct rtllib_assoc_request_frame) + 2\n\t\t+ beacon->ssid_len\n\t\t+ rate_len\n\t\t+ wpa_ie_len\n\t\t+ wps_ie_len\n\t\t+ wmm_info_len\n\t\t+ turbo_info_len\n\t\t+ ht_cap_len\n\t\t+ realtek_ie_len\n\t\t+ ckip_ie_len\n\t\t+ ccxrm_ie_len\n\t\t+ cxvernum_ie_len\n\t\t+ ieee->tx_headroom;\n\n\tskb = dev_alloc_skb(len);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\thdr = skb_put(skb, sizeof(struct rtllib_assoc_request_frame) + 2);\n\n\thdr->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_ASSOC_REQ);\n\thdr->header.duration_id = cpu_to_le16(37);\n\tether_addr_copy(hdr->header.addr1, beacon->bssid);\n\tether_addr_copy(hdr->header.addr2, ieee->dev->dev_addr);\n\tether_addr_copy(hdr->header.addr3, beacon->bssid);\n\n\tether_addr_copy(ieee->ap_mac_addr, beacon->bssid);\n\n\thdr->capability = cpu_to_le16(WLAN_CAPABILITY_ESS);\n\tif (beacon->capability & WLAN_CAPABILITY_PRIVACY)\n\t\thdr->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\n\n\tif (beacon->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\n\t\thdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE);\n\n\tif (beacon->capability & WLAN_CAPABILITY_SHORT_SLOT_TIME)\n\t\thdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);\n\n\thdr->listen_interval = cpu_to_le16(beacon->listen_interval);\n\n\thdr->info_element[0].id = MFIE_TYPE_SSID;\n\n\thdr->info_element[0].len = beacon->ssid_len;\n\tskb_put_data(skb, beacon->ssid, beacon->ssid_len);\n\n\ttag = skb_put(skb, rate_len);\n\n\tif (beacon->rates_len) {\n\t\t*tag++ = MFIE_TYPE_RATES;\n\t\t*tag++ = beacon->rates_len;\n\t\tfor (i = 0; i < beacon->rates_len; i++)\n\t\t\t*tag++ = beacon->rates[i];\n\t}\n\n\tif (beacon->rates_ex_len) {\n\t\t*tag++ = MFIE_TYPE_RATES_EX;\n\t\t*tag++ = beacon->rates_ex_len;\n\t\tfor (i = 0; i < beacon->rates_ex_len; i++)\n\t\t\t*tag++ = beacon->rates_ex[i];\n\t}\n\n\tif (beacon->bCkipSupported) {\n\t\tstatic const u8 AironetIeOui[] = {0x00, 0x01, 0x66};\n\t\tu8\tCcxAironetBuf[30];\n\t\tstruct octet_string osCcxAironetIE;\n\n\t\tmemset(CcxAironetBuf, 0, 30);\n\t\tosCcxAironetIE.Octet = CcxAironetBuf;\n\t\tosCcxAironetIE.Length = sizeof(CcxAironetBuf);\n\t\tmemcpy(osCcxAironetIE.Octet, AironetIeOui,\n\t\t       sizeof(AironetIeOui));\n\n\t\tosCcxAironetIE.Octet[IE_CISCO_FLAG_POSITION] |=\n\t\t\t\t\t (SUPPORT_CKIP_PK | SUPPORT_CKIP_MIC);\n\t\ttag = skb_put(skb, ckip_ie_len);\n\t\t*tag++ = MFIE_TYPE_AIRONET;\n\t\t*tag++ = osCcxAironetIE.Length;\n\t\tmemcpy(tag, osCcxAironetIE.Octet, osCcxAironetIE.Length);\n\t\ttag += osCcxAironetIE.Length;\n\t}\n\n\tif (beacon->bCcxRmEnable) {\n\t\tstatic const u8 CcxRmCapBuf[] = {0x00, 0x40, 0x96, 0x01, 0x01,\n\t\t\t0x00};\n\t\tstruct octet_string osCcxRmCap;\n\n\t\tosCcxRmCap.Octet = (u8 *)CcxRmCapBuf;\n\t\tosCcxRmCap.Length = sizeof(CcxRmCapBuf);\n\t\ttag = skb_put(skb, ccxrm_ie_len);\n\t\t*tag++ = MFIE_TYPE_GENERIC;\n\t\t*tag++ = osCcxRmCap.Length;\n\t\tmemcpy(tag, osCcxRmCap.Octet, osCcxRmCap.Length);\n\t\ttag += osCcxRmCap.Length;\n\t}\n\n\tif (beacon->BssCcxVerNumber >= 2) {\n\t\tu8 CcxVerNumBuf[] = {0x00, 0x40, 0x96, 0x03, 0x00};\n\t\tstruct octet_string osCcxVerNum;\n\n\t\tCcxVerNumBuf[4] = beacon->BssCcxVerNumber;\n\t\tosCcxVerNum.Octet = CcxVerNumBuf;\n\t\tosCcxVerNum.Length = sizeof(CcxVerNumBuf);\n\t\ttag = skb_put(skb, cxvernum_ie_len);\n\t\t*tag++ = MFIE_TYPE_GENERIC;\n\t\t*tag++ = osCcxVerNum.Length;\n\t\tmemcpy(tag, osCcxVerNum.Octet, osCcxVerNum.Length);\n\t\ttag += osCcxVerNum.Length;\n\t}\n\tif (ieee->ht_info->bCurrentHTSupport && ieee->ht_info->enable_ht) {\n\t\tif (ieee->ht_info->ePeerHTSpecVer != HT_SPEC_VER_EWC) {\n\t\t\ttag = skb_put(skb, ht_cap_len);\n\t\t\t*tag++ = MFIE_TYPE_HT_CAP;\n\t\t\t*tag++ = ht_cap_len - 2;\n\t\t\tmemcpy(tag, ht_cap_buf, ht_cap_len - 2);\n\t\t\ttag += ht_cap_len - 2;\n\t\t}\n\t}\n\n\tif (wpa_ie_len) {\n\t\tskb_put_data(skb, ieee->wpa_ie, ieee->wpa_ie_len);\n\n\t\tif (PMKCacheIdx >= 0) {\n\t\t\ttag = skb_put(skb, 18);\n\t\t\t*tag = 1;\n\t\t\t*(tag + 1) = 0;\n\t\t\tmemcpy((tag + 2), &ieee->PMKIDList[PMKCacheIdx].PMKID,\n\t\t\t       16);\n\t\t}\n\t}\n\tif (wmm_info_len) {\n\t\ttag = skb_put(skb, wmm_info_len);\n\t\trtllib_WMM_Info(ieee, &tag);\n\t}\n\n\tif (wps_ie_len && ieee->wps_ie)\n\t\tskb_put_data(skb, ieee->wps_ie, wps_ie_len);\n\n\tif (turbo_info_len) {\n\t\ttag = skb_put(skb, turbo_info_len);\n\t\trtllib_TURBO_Info(ieee, &tag);\n\t}\n\n\tif (ieee->ht_info->bCurrentHTSupport && ieee->ht_info->enable_ht) {\n\t\tif (ieee->ht_info->ePeerHTSpecVer == HT_SPEC_VER_EWC) {\n\t\t\ttag = skb_put(skb, ht_cap_len);\n\t\t\t*tag++ = MFIE_TYPE_GENERIC;\n\t\t\t*tag++ = ht_cap_len - 2;\n\t\t\tmemcpy(tag, ht_cap_buf, ht_cap_len - 2);\n\t\t\ttag += ht_cap_len - 2;\n\t\t}\n\n\t\tif (ieee->ht_info->current_rt2rt_aggregation) {\n\t\t\ttag = skb_put(skb, realtek_ie_len);\n\t\t\t*tag++ = MFIE_TYPE_GENERIC;\n\t\t\t*tag++ = realtek_ie_len - 2;\n\t\t\tmemcpy(tag, realtek_ie_buf, realtek_ie_len - 2);\n\t\t}\n\t}\n\n\tkfree(ieee->assocreq_ies);\n\tieee->assocreq_ies = NULL;\n\ties = &(hdr->info_element[0].id);\n\tieee->assocreq_ies_len = (skb->data + skb->len) - ies;\n\tieee->assocreq_ies = kmemdup(ies, ieee->assocreq_ies_len, GFP_ATOMIC);\n\tif (!ieee->assocreq_ies)\n\t\tieee->assocreq_ies_len = 0;\n\n\treturn skb;\n}\n\nstatic void rtllib_associate_abort(struct rtllib_device *ieee)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tieee->associate_seq++;\n\n\t \n\tif (ieee->link_state == RTLLIB_ASSOCIATING_AUTHENTICATING) {\n\t\tnetdev_dbg(ieee->dev, \"Authentication failed\\n\");\n\t\tieee->softmac_stats.no_auth_rs++;\n\t} else {\n\t\tnetdev_dbg(ieee->dev, \"Association failed\\n\");\n\t\tieee->softmac_stats.no_ass_rs++;\n\t}\n\n\tieee->link_state = RTLLIB_ASSOCIATING_RETRY;\n\n\tschedule_delayed_work(&ieee->associate_retry_wq,\n\t\t\t      RTLLIB_SOFTMAC_ASSOC_RETRY_TIME);\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\n\nstatic void rtllib_associate_abort_cb(struct timer_list *t)\n{\n\tstruct rtllib_device *dev = from_timer(dev, t, associate_timer);\n\n\trtllib_associate_abort(dev);\n}\n\nstatic void rtllib_associate_step1(struct rtllib_device *ieee, u8 *daddr)\n{\n\tstruct rtllib_network *beacon = &ieee->current_network;\n\tstruct sk_buff *skb;\n\n\tnetdev_dbg(ieee->dev, \"Stopping scan\\n\");\n\n\tieee->softmac_stats.tx_auth_rq++;\n\n\tskb = rtllib_authentication_req(beacon, ieee, 0, daddr);\n\n\tif (!skb) {\n\t\trtllib_associate_abort(ieee);\n\t} else {\n\t\tieee->link_state = RTLLIB_ASSOCIATING_AUTHENTICATING;\n\t\tnetdev_dbg(ieee->dev, \"Sending authentication request\\n\");\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\tif (!timer_pending(&ieee->associate_timer)) {\n\t\t\tieee->associate_timer.expires = jiffies + (HZ / 2);\n\t\t\tadd_timer(&ieee->associate_timer);\n\t\t}\n\t}\n}\n\nstatic void rtllib_auth_challenge(struct rtllib_device *ieee, u8 *challenge,\n\t\t\t\t  int chlen)\n{\n\tu8 *c;\n\tstruct sk_buff *skb;\n\tstruct rtllib_network *beacon = &ieee->current_network;\n\n\tieee->associate_seq++;\n\tieee->softmac_stats.tx_auth_rq++;\n\n\tskb = rtllib_authentication_req(beacon, ieee, chlen + 2, beacon->bssid);\n\n\tif (!skb) {\n\t\trtllib_associate_abort(ieee);\n\t} else {\n\t\tc = skb_put(skb, chlen + 2);\n\t\t*(c++) = MFIE_TYPE_CHALLENGE;\n\t\t*(c++) = chlen;\n\t\tmemcpy(c, challenge, chlen);\n\n\t\tnetdev_dbg(ieee->dev,\n\t\t\t   \"Sending authentication challenge response\\n\");\n\n\t\trtllib_encrypt_fragment(ieee, skb,\n\t\t\t\t\tsizeof(struct rtllib_hdr_3addr));\n\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\tmod_timer(&ieee->associate_timer, jiffies + (HZ / 2));\n\t}\n\tkfree(challenge);\n}\n\nstatic void rtllib_associate_step2(struct rtllib_device *ieee)\n{\n\tstruct sk_buff *skb;\n\tstruct rtllib_network *beacon = &ieee->current_network;\n\n\tdel_timer_sync(&ieee->associate_timer);\n\n\tnetdev_dbg(ieee->dev, \"Sending association request\\n\");\n\n\tieee->softmac_stats.tx_ass_rq++;\n\tskb = rtllib_association_req(beacon, ieee);\n\tif (!skb) {\n\t\trtllib_associate_abort(ieee);\n\t} else {\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n\t\tmod_timer(&ieee->associate_timer, jiffies + (HZ / 2));\n\t}\n}\n\nstatic void rtllib_associate_complete_wq(void *data)\n{\n\tstruct rtllib_device *ieee = (struct rtllib_device *)\n\t\t\t\t     container_of(data,\n\t\t\t\t     struct rtllib_device,\n\t\t\t\t     associate_complete_wq);\n\tstruct rt_pwr_save_ctrl *psc = &ieee->pwr_save_ctrl;\n\n\tnetdev_info(ieee->dev, \"Associated successfully with %pM\\n\",\n\t\t    ieee->current_network.bssid);\n\tif (!ieee->is_silent_reset) {\n\t\tnetdev_info(ieee->dev, \"normal associate\\n\");\n\t\tnotify_wx_assoc_event(ieee);\n\t}\n\n\tnetif_carrier_on(ieee->dev);\n\tieee->is_roaming = false;\n\tif (rtllib_is_54g(&ieee->current_network)) {\n\t\tieee->rate = 108;\n\t\tnetdev_info(ieee->dev, \"Using G rates:%d\\n\", ieee->rate);\n\t} else {\n\t\tieee->rate = 22;\n\t\tieee->set_wireless_mode(ieee->dev, WIRELESS_MODE_B);\n\t\tnetdev_info(ieee->dev, \"Using B rates:%d\\n\", ieee->rate);\n\t}\n\tif (ieee->ht_info->bCurrentHTSupport && ieee->ht_info->enable_ht) {\n\t\tnetdev_info(ieee->dev, \"Successfully associated, ht enabled\\n\");\n\t\tHTOnAssocRsp(ieee);\n\t} else {\n\t\tnetdev_info(ieee->dev,\n\t\t\t    \"Successfully associated, ht not enabled(%d, %d)\\n\",\n\t\t\t    ieee->ht_info->bCurrentHTSupport,\n\t\t\t    ieee->ht_info->enable_ht);\n\t\tmemset(ieee->dot11ht_oper_rate_set, 0, 16);\n\t}\n\tieee->link_detect_info.SlotNum = 2 * (1 +\n\t\t\t\t       ieee->current_network.beacon_interval /\n\t\t\t\t       500);\n\tif (ieee->link_detect_info.NumRecvBcnInPeriod == 0 ||\n\t    ieee->link_detect_info.NumRecvDataInPeriod == 0) {\n\t\tieee->link_detect_info.NumRecvBcnInPeriod = 1;\n\t\tieee->link_detect_info.NumRecvDataInPeriod = 1;\n\t}\n\tpsc->LpsIdleCount = 0;\n\tieee->link_change(ieee->dev);\n\n\tif (ieee->is_silent_reset) {\n\t\tnetdev_info(ieee->dev, \"silent reset associate\\n\");\n\t\tieee->is_silent_reset = false;\n\t}\n}\n\nstatic void rtllib_sta_send_associnfo(struct rtllib_device *ieee)\n{\n}\n\nstatic void rtllib_associate_complete(struct rtllib_device *ieee)\n{\n\tdel_timer_sync(&ieee->associate_timer);\n\n\tieee->link_state = MAC80211_LINKED;\n\trtllib_sta_send_associnfo(ieee);\n\n\tschedule_work(&ieee->associate_complete_wq);\n}\n\nstatic void rtllib_associate_procedure_wq(void *data)\n{\n\tstruct rtllib_device *ieee = container_of_dwork_rsl(data,\n\t\t\t\t     struct rtllib_device,\n\t\t\t\t     associate_procedure_wq);\n\trtllib_stop_scan_syncro(ieee);\n\tieee->rtllib_ips_leave(ieee->dev);\n\tmutex_lock(&ieee->wx_mutex);\n\n\trtllib_stop_scan(ieee);\n\tHTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);\n\tif (ieee->rf_power_state == rf_off) {\n\t\tieee->rtllib_ips_leave_wq(ieee->dev);\n\t\tmutex_unlock(&ieee->wx_mutex);\n\t\treturn;\n\t}\n\tieee->associate_seq = 1;\n\n\trtllib_associate_step1(ieee, ieee->current_network.bssid);\n\n\tmutex_unlock(&ieee->wx_mutex);\n}\n\ninline void rtllib_softmac_new_net(struct rtllib_device *ieee,\n\t\t\t\t   struct rtllib_network *net)\n{\n\tu8 tmp_ssid[IW_ESSID_MAX_SIZE + 1];\n\tint tmp_ssid_len = 0;\n\n\tshort apset, ssidset, ssidbroad, apmatch, ssidmatch;\n\n\t \n\tif (ieee->link_state != MAC80211_NOLINK)\n\t\treturn;\n\n\tif ((ieee->iw_mode == IW_MODE_INFRA) && !(net->capability &\n\t    WLAN_CAPABILITY_ESS))\n\t\treturn;\n\n\tif ((ieee->iw_mode == IW_MODE_ADHOC) && !(net->capability &\n\t     WLAN_CAPABILITY_IBSS))\n\t\treturn;\n\n\tif ((ieee->iw_mode == IW_MODE_ADHOC) &&\n\t    (net->channel > ieee->ibss_maxjoin_chal))\n\t\treturn;\n\tif (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC) {\n\t\t \n\t\tapset = ieee->wap_set;\n\t\tssidset = ieee->ssid_set;\n\t\tssidbroad =  !(net->ssid_len == 0 || net->ssid[0] == '\\0');\n\t\tapmatch = (memcmp(ieee->current_network.bssid, net->bssid,\n\t\t\t\t  ETH_ALEN) == 0);\n\t\tif (!ssidbroad) {\n\t\t\tssidmatch = (ieee->current_network.ssid_len ==\n\t\t\t\t    net->hidden_ssid_len) &&\n\t\t\t\t    (!strncmp(ieee->current_network.ssid,\n\t\t\t\t    net->hidden_ssid, net->hidden_ssid_len));\n\t\t\tif (net->hidden_ssid_len > 0) {\n\t\t\t\tstrncpy(net->ssid, net->hidden_ssid,\n\t\t\t\t\tnet->hidden_ssid_len);\n\t\t\t\tnet->ssid_len = net->hidden_ssid_len;\n\t\t\t\tssidbroad = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tssidmatch =\n\t\t\t   (ieee->current_network.ssid_len == net->ssid_len) &&\n\t\t\t   (!strncmp(ieee->current_network.ssid, net->ssid,\n\t\t\t   net->ssid_len));\n\t\t}\n\n\t\t \n\t\tif ((apset && apmatch &&\n\t\t   ((ssidset && ssidbroad && ssidmatch) ||\n\t\t   (ssidbroad && !ssidset) || (!ssidbroad && ssidset))) ||\n\t\t   (!apset && ssidset && ssidbroad && ssidmatch) ||\n\t\t   (ieee->is_roaming && ssidset && ssidbroad && ssidmatch)) {\n\t\t\t \n\t\t\tif (!ssidbroad) {\n\t\t\t\tmemcpy(tmp_ssid, ieee->current_network.ssid,\n\t\t\t\t       ieee->current_network.ssid_len);\n\t\t\t\ttmp_ssid_len = ieee->current_network.ssid_len;\n\t\t\t}\n\t\t\tmemcpy(&ieee->current_network, net,\n\t\t\t\tsizeof(ieee->current_network));\n\t\t\tif (!ssidbroad) {\n\t\t\t\tmemcpy(ieee->current_network.ssid, tmp_ssid,\n\t\t\t\t       tmp_ssid_len);\n\t\t\t\tieee->current_network.ssid_len = tmp_ssid_len;\n\t\t\t}\n\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t    \"Linking with %s,channel:%d, qos:%d, myHT:%d, networkHT:%d, mode:%x cur_net.flags:0x%x\\n\",\n\t\t\t\t    ieee->current_network.ssid,\n\t\t\t\t    ieee->current_network.channel,\n\t\t\t\t    ieee->current_network.qos_data.supported,\n\t\t\t\t    ieee->ht_info->enable_ht,\n\t\t\t\t    ieee->current_network.bssht.bd_support_ht,\n\t\t\t\t    ieee->current_network.mode,\n\t\t\t\t    ieee->current_network.flags);\n\n\t\t\tif ((rtllib_act_scanning(ieee, false)) &&\n\t\t\t   !(ieee->softmac_features & IEEE_SOFTMAC_SCAN))\n\t\t\t\trtllib_stop_scan_syncro(ieee);\n\n\t\t\tHTResetIOTSetting(ieee->ht_info);\n\t\t\tieee->wmm_acm = 0;\n\t\t\tif (ieee->iw_mode == IW_MODE_INFRA) {\n\t\t\t\t \n\t\t\t\tieee->AsocRetryCount = 0;\n\t\t\t\tif ((ieee->current_network.qos_data.supported == 1) &&\n\t\t\t\t    ieee->current_network.bssht.bd_support_ht)\n\t\t\t\t\tHTResetSelfAndSavePeerSetting(ieee,\n\t\t\t\t\t\t &(ieee->current_network));\n\t\t\t\telse\n\t\t\t\t\tieee->ht_info->bCurrentHTSupport =\n\t\t\t\t\t\t\t\t false;\n\n\t\t\t\tieee->link_state = RTLLIB_ASSOCIATING;\n\t\t\t\tschedule_delayed_work(\n\t\t\t\t\t   &ieee->associate_procedure_wq, 0);\n\t\t\t} else {\n\t\t\t\tif (rtllib_is_54g(&ieee->current_network)) {\n\t\t\t\t\tieee->rate = 108;\n\t\t\t\t\tieee->set_wireless_mode(ieee->dev, WIRELESS_MODE_G);\n\t\t\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t\t\t    \"Using G rates\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tieee->rate = 22;\n\t\t\t\t\tieee->set_wireless_mode(ieee->dev, WIRELESS_MODE_B);\n\t\t\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t\t\t    \"Using B rates\\n\");\n\t\t\t\t}\n\t\t\t\tmemset(ieee->dot11ht_oper_rate_set, 0, 16);\n\t\t\t\tieee->link_state = MAC80211_LINKED;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void rtllib_softmac_check_all_nets(struct rtllib_device *ieee)\n{\n\tunsigned long flags;\n\tstruct rtllib_network *target;\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tlist_for_each_entry(target, &ieee->network_list, list) {\n\t\t \n\n\t\tif (ieee->link_state != MAC80211_NOLINK)\n\t\t\tbreak;\n\n\t\tif (ieee->scan_age == 0 || time_after(target->last_scanned +\n\t\t    ieee->scan_age, jiffies))\n\t\t\trtllib_softmac_new_net(ieee, target);\n\t}\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\n\nstatic inline int auth_parse(struct net_device *dev, struct sk_buff *skb,\n\t\t\t     u8 **challenge, int *chlen)\n{\n\tstruct rtllib_authentication *a;\n\tu8 *t;\n\n\tif (skb->len <  (sizeof(struct rtllib_authentication) -\n\t    sizeof(struct rtllib_info_element))) {\n\t\tnetdev_dbg(dev, \"invalid len in auth resp: %d\\n\", skb->len);\n\t\treturn -EINVAL;\n\t}\n\t*challenge = NULL;\n\ta = (struct rtllib_authentication *)skb->data;\n\tif (skb->len > (sizeof(struct rtllib_authentication) + 3)) {\n\t\tt = skb->data + sizeof(struct rtllib_authentication);\n\n\t\tif (*(t++) == MFIE_TYPE_CHALLENGE) {\n\t\t\t*chlen = *(t++);\n\t\t\t*challenge = kmemdup(t, *chlen, GFP_ATOMIC);\n\t\t\tif (!*challenge)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (a->status) {\n\t\tnetdev_dbg(dev, \"auth_parse() failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic short probe_rq_parse(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t\t    u8 *src)\n{\n\tu8 *tag;\n\tu8 *skbend;\n\tu8 *ssid = NULL;\n\tu8 ssidlen = 0;\n\tstruct rtllib_hdr_3addr   *header =\n\t\t(struct rtllib_hdr_3addr   *)skb->data;\n\tbool bssid_match;\n\n\tif (skb->len < sizeof(struct rtllib_hdr_3addr))\n\t\treturn -1;  \n\n\tbssid_match =\n\t  (!ether_addr_equal(header->addr3, ieee->current_network.bssid)) &&\n\t  (!is_broadcast_ether_addr(header->addr3));\n\tif (bssid_match)\n\t\treturn -1;\n\n\tether_addr_copy(src, header->addr2);\n\n\tskbend = (u8 *)skb->data + skb->len;\n\n\ttag = skb->data + sizeof(struct rtllib_hdr_3addr);\n\n\twhile (tag + 1 < skbend) {\n\t\tif (*tag == 0) {\n\t\t\tssid = tag + 2;\n\t\t\tssidlen = *(tag + 1);\n\t\t\tbreak;\n\t\t}\n\t\ttag++;  \n\t\ttag = tag + *(tag);  \n\t\ttag++;  \n\t}\n\n\tif (ssidlen == 0)\n\t\treturn 1;\n\n\tif (!ssid)\n\t\treturn 1;  \n\n\treturn !strncmp(ssid, ieee->current_network.ssid, ssidlen);\n}\n\nstatic inline u16 assoc_parse(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t\t      int *aid)\n{\n\tstruct rtllib_assoc_response_frame *response_head;\n\tu16 status_code;\n\n\tif (skb->len <  sizeof(struct rtllib_assoc_response_frame)) {\n\t\tnetdev_dbg(ieee->dev, \"Invalid len in auth resp: %d\\n\",\n\t\t\t   skb->len);\n\t\treturn 0xcafe;\n\t}\n\n\tresponse_head = (struct rtllib_assoc_response_frame *)skb->data;\n\t*aid = le16_to_cpu(response_head->aid) & 0x3fff;\n\n\tstatus_code = le16_to_cpu(response_head->status);\n\tif ((status_code == WLAN_STATUS_ASSOC_DENIED_RATES ||\n\t   status_code == WLAN_STATUS_CAPS_UNSUPPORTED) &&\n\t   ((ieee->mode == WIRELESS_MODE_G) &&\n\t   (ieee->current_network.mode == WIRELESS_MODE_N_24G) &&\n\t   (ieee->AsocRetryCount++ < (RT_ASOC_RETRY_LIMIT - 1)))) {\n\t\tieee->ht_info->iot_action |= HT_IOT_ACT_PURE_N_MODE;\n\t} else {\n\t\tieee->AsocRetryCount = 0;\n\t}\n\n\treturn le16_to_cpu(response_head->status);\n}\n\nvoid rtllib_rx_probe_rq(struct rtllib_device *ieee, struct sk_buff *skb)\n{\n\tu8 dest[ETH_ALEN];\n\n\tieee->softmac_stats.rx_probe_rq++;\n\tif (probe_rq_parse(ieee, skb, dest) > 0) {\n\t\tieee->softmac_stats.tx_probe_rs++;\n\t\trtllib_resp_to_probe(ieee, dest);\n\t}\n}\n\nvoid rtllib_sta_ps_send_null_frame(struct rtllib_device *ieee, short pwr)\n{\n\tstruct sk_buff *buf = rtllib_null_func(ieee, pwr);\n\n\tif (buf)\n\t\tsoftmac_ps_mgmt_xmit(buf, ieee);\n}\nEXPORT_SYMBOL(rtllib_sta_ps_send_null_frame);\n\nvoid rtllib_sta_ps_send_pspoll_frame(struct rtllib_device *ieee)\n{\n\tstruct sk_buff *buf = rtllib_pspoll_func(ieee);\n\n\tif (buf)\n\t\tsoftmac_ps_mgmt_xmit(buf, ieee);\n}\n\nstatic short rtllib_sta_ps_sleep(struct rtllib_device *ieee, u64 *time)\n{\n\tint timeout;\n\tu8 dtim;\n\tstruct rt_pwr_save_ctrl *psc = &ieee->pwr_save_ctrl;\n\n\tif (ieee->LPSDelayCnt) {\n\t\tieee->LPSDelayCnt--;\n\t\treturn 0;\n\t}\n\n\tdtim = ieee->current_network.dtim_data;\n\tif (!(dtim & RTLLIB_DTIM_VALID))\n\t\treturn 0;\n\ttimeout = ieee->current_network.beacon_interval;\n\tieee->current_network.dtim_data = RTLLIB_DTIM_INVALID;\n\t \n\tif (dtim & (RTLLIB_DTIM_UCAST & ieee->ps))\n\t\treturn 2;\n\n\tif (!time_after(jiffies,\n\t\t\tdev_trans_start(ieee->dev) + msecs_to_jiffies(timeout)))\n\t\treturn 0;\n\tif (!time_after(jiffies,\n\t\t\tieee->last_rx_ps_time + msecs_to_jiffies(timeout)))\n\t\treturn 0;\n\tif ((ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE) &&\n\t    (ieee->mgmt_queue_tail != ieee->mgmt_queue_head))\n\t\treturn 0;\n\n\tif (time) {\n\t\tif (ieee->bAwakePktSent) {\n\t\t\tpsc->LPSAwakeIntvl = 1;\n\t\t} else {\n\t\t\tu8 MaxPeriod = 1;\n\n\t\t\tif (psc->LPSAwakeIntvl == 0)\n\t\t\t\tpsc->LPSAwakeIntvl = 1;\n\t\t\tif (psc->reg_max_lps_awake_intvl == 0)\n\t\t\t\tMaxPeriod = 1;\n\t\t\telse if (psc->reg_max_lps_awake_intvl == 0xFF)\n\t\t\t\tMaxPeriod = ieee->current_network.dtim_period;\n\t\t\telse\n\t\t\t\tMaxPeriod = psc->reg_max_lps_awake_intvl;\n\t\t\tpsc->LPSAwakeIntvl = (psc->LPSAwakeIntvl >=\n\t\t\t\t\t       MaxPeriod) ? MaxPeriod :\n\t\t\t\t\t       (psc->LPSAwakeIntvl + 1);\n\t\t}\n\t\t{\n\t\t\tu8 LPSAwakeIntvl_tmp = 0;\n\t\t\tu8 period = ieee->current_network.dtim_period;\n\t\t\tu8 count = ieee->current_network.tim.tim_count;\n\n\t\t\tif (count == 0) {\n\t\t\t\tif (psc->LPSAwakeIntvl > period)\n\t\t\t\t\tLPSAwakeIntvl_tmp = period +\n\t\t\t\t\t\t (psc->LPSAwakeIntvl -\n\t\t\t\t\t\t period) -\n\t\t\t\t\t\t ((psc->LPSAwakeIntvl - period) %\n\t\t\t\t\t\t period);\n\t\t\t\telse\n\t\t\t\t\tLPSAwakeIntvl_tmp = psc->LPSAwakeIntvl;\n\n\t\t\t} else {\n\t\t\t\tif (psc->LPSAwakeIntvl >\n\t\t\t\t    ieee->current_network.tim.tim_count)\n\t\t\t\t\tLPSAwakeIntvl_tmp = count +\n\t\t\t\t\t(psc->LPSAwakeIntvl - count) -\n\t\t\t\t\t((psc->LPSAwakeIntvl - count) % period);\n\t\t\t\telse\n\t\t\t\t\tLPSAwakeIntvl_tmp = psc->LPSAwakeIntvl;\n\t\t\t}\n\n\t\t*time = ieee->current_network.last_dtim_sta_time\n\t\t\t+ msecs_to_jiffies(ieee->current_network.beacon_interval *\n\t\t\tLPSAwakeIntvl_tmp);\n\t}\n\t}\n\n\treturn 1;\n}\n\nstatic inline void rtllib_sta_ps(struct work_struct *work)\n{\n\tstruct rtllib_device *ieee;\n\tu64 time;\n\tshort sleep;\n\tunsigned long flags, flags2;\n\n\tieee = container_of(work, struct rtllib_device, ps_task);\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif ((ieee->ps == RTLLIB_PS_DISABLED ||\n\t     ieee->iw_mode != IW_MODE_INFRA ||\n\t     ieee->link_state != MAC80211_LINKED)) {\n\t\tspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\n\t\trtllib_sta_wakeup(ieee, 1);\n\n\t\tspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\n\t}\n\tsleep = rtllib_sta_ps_sleep(ieee, &time);\n\t \n\tif (sleep == 0)\n\t\tgoto out;\n\tif (sleep == 1) {\n\t\tif (ieee->sta_sleep == LPS_IS_SLEEP) {\n\t\t\tieee->enter_sleep_state(ieee->dev, time);\n\t\t} else if (ieee->sta_sleep == LPS_IS_WAKE) {\n\t\t\tspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\n\n\t\t\tif (ieee->ps_is_queue_empty(ieee->dev)) {\n\t\t\t\tieee->sta_sleep = LPS_WAIT_NULL_DATA_SEND;\n\t\t\t\tieee->ack_tx_to_ieee = 1;\n\t\t\t\trtllib_sta_ps_send_null_frame(ieee, 1);\n\t\t\t\tieee->ps_time = time;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\n\t\t}\n\n\t\tieee->bAwakePktSent = false;\n\n\t} else if (sleep == 2) {\n\t\tspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\n\n\t\trtllib_sta_wakeup(ieee, 1);\n\n\t\tspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\n\nstatic void rtllib_sta_wakeup(struct rtllib_device *ieee, short nl)\n{\n\tif (ieee->sta_sleep == LPS_IS_WAKE) {\n\t\tif (nl) {\n\t\t\tif (ieee->ht_info->iot_action &\n\t\t\t    HT_IOT_ACT_NULL_DATA_POWER_SAVING) {\n\t\t\t\tieee->ack_tx_to_ieee = 1;\n\t\t\t\trtllib_sta_ps_send_null_frame(ieee, 0);\n\t\t\t} else {\n\t\t\t\tieee->ack_tx_to_ieee = 1;\n\t\t\t\trtllib_sta_ps_send_pspoll_frame(ieee);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ieee->sta_sleep == LPS_IS_SLEEP)\n\t\tieee->sta_wake_up(ieee->dev);\n\tif (nl) {\n\t\tif (ieee->ht_info->iot_action &\n\t\t    HT_IOT_ACT_NULL_DATA_POWER_SAVING) {\n\t\t\tieee->ack_tx_to_ieee = 1;\n\t\t\trtllib_sta_ps_send_null_frame(ieee, 0);\n\t\t} else {\n\t\t\tieee->ack_tx_to_ieee = 1;\n\t\t\tieee->polling = true;\n\t\t\trtllib_sta_ps_send_pspoll_frame(ieee);\n\t\t}\n\n\t} else {\n\t\tieee->sta_sleep = LPS_IS_WAKE;\n\t\tieee->polling = false;\n\t}\n}\n\nvoid rtllib_ps_tx_ack(struct rtllib_device *ieee, short success)\n{\n\tunsigned long flags, flags2;\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif (ieee->sta_sleep == LPS_WAIT_NULL_DATA_SEND) {\n\t\t \n\t\tif (success) {\n\t\t\tieee->sta_sleep = LPS_IS_SLEEP;\n\t\t\tieee->enter_sleep_state(ieee->dev, ieee->ps_time);\n\t\t}\n\t\t \n\t} else { \n\n\t\tif ((ieee->sta_sleep == LPS_IS_WAKE) && !success) {\n\t\t\tspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\n\t\t\tif (ieee->ht_info->iot_action &\n\t\t\t    HT_IOT_ACT_NULL_DATA_POWER_SAVING)\n\t\t\t\trtllib_sta_ps_send_null_frame(ieee, 0);\n\t\t\telse\n\t\t\t\trtllib_sta_ps_send_pspoll_frame(ieee);\n\t\t\tspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\nEXPORT_SYMBOL(rtllib_ps_tx_ack);\n\nstatic void rtllib_process_action(struct rtllib_device *ieee,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *)skb->data;\n\tu8 *act = rtllib_get_payload((struct rtllib_hdr *)header);\n\tu8 category = 0;\n\n\tif (act == NULL) {\n\t\tnetdev_warn(ieee->dev,\n\t\t\t    \"Error getting payload of action frame\\n\");\n\t\treturn;\n\t}\n\n\tcategory = *act;\n\tact++;\n\tswitch (category) {\n\tcase ACT_CAT_BA:\n\t\tswitch (*act) {\n\t\tcase ACT_ADDBAREQ:\n\t\t\trtllib_rx_ADDBAReq(ieee, skb);\n\t\t\tbreak;\n\t\tcase ACT_ADDBARSP:\n\t\t\trtllib_rx_ADDBARsp(ieee, skb);\n\t\t\tbreak;\n\t\tcase ACT_DELBA:\n\t\t\trtllib_rx_DELBA(ieee, skb);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic inline int\nrtllib_rx_assoc_resp(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t     struct rtllib_rx_stats *rx_stats)\n{\n\tu16 errcode;\n\tint aid;\n\tu8 *ies;\n\tstruct rtllib_assoc_response_frame *assoc_resp;\n\tstruct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *)skb->data;\n\tu16 frame_ctl = le16_to_cpu(header->frame_ctl);\n\n\tnetdev_dbg(ieee->dev, \"received [RE]ASSOCIATION RESPONSE (%d)\\n\",\n\t\t   WLAN_FC_GET_STYPE(frame_ctl));\n\n\tif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\n\t     ieee->link_state == RTLLIB_ASSOCIATING_AUTHENTICATED &&\n\t     (ieee->iw_mode == IW_MODE_INFRA)) {\n\t\terrcode = assoc_parse(ieee, skb, &aid);\n\t\tif (!errcode) {\n\t\t\tstruct rtllib_network *network =\n\t\t\t\t kzalloc(sizeof(struct rtllib_network),\n\t\t\t\t GFP_ATOMIC);\n\n\t\t\tif (!network)\n\t\t\t\treturn 1;\n\t\t\tieee->link_state = MAC80211_LINKED;\n\t\t\tieee->assoc_id = aid;\n\t\t\tieee->softmac_stats.rx_ass_ok++;\n\t\t\t \n\t\t\t \n\t\t\tassoc_resp = (struct rtllib_assoc_response_frame *)skb->data;\n\t\t\tif (ieee->current_network.qos_data.supported == 1) {\n\t\t\t\tif (rtllib_parse_info_param(ieee, assoc_resp->info_element,\n\t\t\t\t\t\t\trx_stats->len - sizeof(*assoc_resp),\n\t\t\t\t\t\t\tnetwork, rx_stats)) {\n\t\t\t\t\tkfree(network);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tmemcpy(ieee->ht_info->PeerHTCapBuf,\n\t\t\t\t       network->bssht.bd_ht_cap_buf,\n\t\t\t\t       network->bssht.bd_ht_cap_len);\n\t\t\t\tmemcpy(ieee->ht_info->PeerHTInfoBuf,\n\t\t\t\t       network->bssht.bd_ht_info_buf,\n\t\t\t\t       network->bssht.bd_ht_info_len);\n\t\t\t\tieee->handle_assoc_response(ieee->dev,\n\t\t\t\t\t(struct rtllib_assoc_response_frame *)header, network);\n\t\t\t}\n\t\t\tkfree(network);\n\n\t\t\tkfree(ieee->assocresp_ies);\n\t\t\tieee->assocresp_ies = NULL;\n\t\t\ties = &(assoc_resp->info_element[0].id);\n\t\t\tieee->assocresp_ies_len = (skb->data + skb->len) - ies;\n\t\t\tieee->assocresp_ies = kmemdup(ies,\n\t\t\t\t\t\t      ieee->assocresp_ies_len,\n\t\t\t\t\t\t      GFP_ATOMIC);\n\t\t\tif (!ieee->assocresp_ies)\n\t\t\t\tieee->assocresp_ies_len = 0;\n\n\t\t\trtllib_associate_complete(ieee);\n\t\t} else {\n\t\t\t \n\t\t\tieee->softmac_stats.rx_ass_err++;\n\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t    \"Association response status code 0x%x\\n\",\n\t\t\t\t    errcode);\n\t\t\tif (ieee->AsocRetryCount < RT_ASOC_RETRY_LIMIT)\n\t\t\t\tschedule_delayed_work(\n\t\t\t\t\t &ieee->associate_procedure_wq, 0);\n\t\t\telse\n\t\t\t\trtllib_associate_abort(ieee);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void rtllib_rx_auth_resp(struct rtllib_device *ieee, struct sk_buff *skb)\n{\n\tint errcode;\n\tu8 *challenge;\n\tint chlen = 0;\n\tbool bSupportNmode = true, bHalfSupportNmode = false;\n\n\terrcode = auth_parse(ieee->dev, skb, &challenge, &chlen);\n\n\tif (errcode) {\n\t\tieee->softmac_stats.rx_auth_rs_err++;\n\t\tnetdev_info(ieee->dev,\n\t\t\t    \"Authentication response status code %d\", errcode);\n\t\trtllib_associate_abort(ieee);\n\t\treturn;\n\t}\n\n\tif (ieee->open_wep || !challenge) {\n\t\tieee->link_state = RTLLIB_ASSOCIATING_AUTHENTICATED;\n\t\tieee->softmac_stats.rx_auth_rs_ok++;\n\t\tif (!(ieee->ht_info->iot_action & HT_IOT_ACT_PURE_N_MODE)) {\n\t\t\tif (!ieee->GetNmodeSupportBySecCfg(ieee->dev)) {\n\t\t\t\tif (IsHTHalfNmodeAPs(ieee)) {\n\t\t\t\t\tbSupportNmode = true;\n\t\t\t\t\tbHalfSupportNmode = true;\n\t\t\t\t} else {\n\t\t\t\t\tbSupportNmode = false;\n\t\t\t\t\tbHalfSupportNmode = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (bSupportNmode) {\n\t\t\tieee->set_wireless_mode(ieee->dev,\n\t\t\t\t\t      ieee->current_network.mode);\n\t\t} else {\n\t\t\t \n\t\t\tieee->set_wireless_mode(ieee->dev, WIRELESS_MODE_G);\n\t\t}\n\n\t\tif ((ieee->current_network.mode == WIRELESS_MODE_N_24G) &&\n\t\t    bHalfSupportNmode) {\n\t\t\tnetdev_info(ieee->dev, \"======>enter half N mode\\n\");\n\t\t\tieee->bHalfWirelessN24GMode = true;\n\t\t} else {\n\t\t\tieee->bHalfWirelessN24GMode = false;\n\t\t}\n\t\trtllib_associate_step2(ieee);\n\t} else {\n\t\trtllib_auth_challenge(ieee, challenge,  chlen);\n\t}\n}\n\nstatic inline int\nrtllib_rx_auth(struct rtllib_device *ieee, struct sk_buff *skb,\n\t       struct rtllib_rx_stats *rx_stats)\n{\n\tif (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) {\n\t\tif (ieee->link_state == RTLLIB_ASSOCIATING_AUTHENTICATING &&\n\t\t    (ieee->iw_mode == IW_MODE_INFRA)) {\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"Received authentication response\");\n\t\t\trtllib_rx_auth_resp(ieee, skb);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic inline int\nrtllib_rx_deauth(struct rtllib_device *ieee, struct sk_buff *skb)\n{\n\tstruct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *)skb->data;\n\tu16 frame_ctl;\n\n\tif (memcmp(header->addr3, ieee->current_network.bssid, ETH_ALEN) != 0)\n\t\treturn 0;\n\n\t \n\tif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\n\t    ieee->link_state == MAC80211_LINKED &&\n\t    (ieee->iw_mode == IW_MODE_INFRA)) {\n\t\tframe_ctl = le16_to_cpu(header->frame_ctl);\n\t\tnetdev_info(ieee->dev,\n\t\t\t    \"==========>received disassoc/deauth(%x) frame, reason code:%x\\n\",\n\t\t\t    WLAN_FC_GET_STYPE(frame_ctl),\n\t\t\t    ((struct rtllib_disassoc *)skb->data)->reason);\n\t\tieee->link_state = RTLLIB_ASSOCIATING;\n\t\tieee->softmac_stats.reassoc++;\n\t\tieee->is_roaming = true;\n\t\tieee->link_detect_info.bBusyTraffic = false;\n\t\trtllib_disassociate(ieee);\n\t\tRemovePeerTS(ieee, header->addr2);\n\t\tif (!(ieee->rtllib_ap_sec_type(ieee) &\n\t\t    (SEC_ALG_CCMP | SEC_ALG_TKIP)))\n\t\t\tschedule_delayed_work(\n\t\t\t\t       &ieee->associate_procedure_wq, 5);\n\t}\n\treturn 0;\n}\n\ninline int rtllib_rx_frame_softmac(struct rtllib_device *ieee,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   struct rtllib_rx_stats *rx_stats, u16 type,\n\t\t\t\t   u16 stype)\n{\n\tstruct rtllib_hdr_3addr *header = (struct rtllib_hdr_3addr *)skb->data;\n\tu16 frame_ctl;\n\n\tif (!ieee->proto_started)\n\t\treturn 0;\n\n\tframe_ctl = le16_to_cpu(header->frame_ctl);\n\tswitch (WLAN_FC_GET_STYPE(frame_ctl)) {\n\tcase RTLLIB_STYPE_ASSOC_RESP:\n\tcase RTLLIB_STYPE_REASSOC_RESP:\n\t\tif (rtllib_rx_assoc_resp(ieee, skb, rx_stats) == 1)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase RTLLIB_STYPE_ASSOC_REQ:\n\tcase RTLLIB_STYPE_REASSOC_REQ:\n\t\tbreak;\n\tcase RTLLIB_STYPE_AUTH:\n\t\trtllib_rx_auth(ieee, skb, rx_stats);\n\t\tbreak;\n\tcase RTLLIB_STYPE_DISASSOC:\n\tcase RTLLIB_STYPE_DEAUTH:\n\t\trtllib_rx_deauth(ieee, skb);\n\t\tbreak;\n\tcase RTLLIB_STYPE_MANAGE_ACT:\n\t\trtllib_process_action(ieee, skb);\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nvoid rtllib_softmac_xmit(struct rtllib_txb *txb, struct rtllib_device *ieee)\n{\n\tunsigned int queue_index = txb->queue_index;\n\tunsigned long flags;\n\tint  i;\n\tstruct cb_desc *tcb_desc = NULL;\n\tunsigned long queue_len = 0;\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\t \n\trtllib_sta_wakeup(ieee, 0);\n\n\t \n\ttcb_desc = (struct cb_desc *)(txb->fragments[0]->cb +\n\t\t   MAX_DEV_ADDR_SIZE);\n\tif (tcb_desc->bMulticast)\n\t\tieee->stats.multicast++;\n\n\t \n\tfor (i = 0; i < txb->nr_frags; i++) {\n\t\tqueue_len = skb_queue_len(&ieee->skb_waitQ[queue_index]);\n\t\tif ((queue_len  != 0) ||\n\t\t    (!ieee->check_nic_enough_desc(ieee->dev, queue_index)) ||\n\t\t    (ieee->queue_stop)) {\n\t\t\t \n\t\t\tif (queue_len < 200)\n\t\t\t\tskb_queue_tail(&ieee->skb_waitQ[queue_index],\n\t\t\t\t\t       txb->fragments[i]);\n\t\t\telse\n\t\t\t\tkfree_skb(txb->fragments[i]);\n\t\t} else {\n\t\t\tieee->softmac_data_hard_start_xmit(\n\t\t\t\t\ttxb->fragments[i],\n\t\t\t\t\tieee->dev, ieee->rate);\n\t\t}\n\t}\n\n\trtllib_txb_free(txb);\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\n\nvoid rtllib_reset_queue(struct rtllib_device *ieee)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\tinit_mgmt_queue(ieee);\n\tif (ieee->tx_pending.txb) {\n\t\trtllib_txb_free(ieee->tx_pending.txb);\n\t\tieee->tx_pending.txb = NULL;\n\t}\n\tieee->queue_stop = 0;\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\nEXPORT_SYMBOL(rtllib_reset_queue);\n\nvoid rtllib_stop_all_queues(struct rtllib_device *ieee)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ieee->dev->num_tx_queues; i++)\n\t\ttxq_trans_cond_update(netdev_get_tx_queue(ieee->dev, i));\n\n\tnetif_tx_stop_all_queues(ieee->dev);\n}\n\nvoid rtllib_wake_all_queues(struct rtllib_device *ieee)\n{\n\tnetif_tx_wake_all_queues(ieee->dev);\n}\n\nstatic void rtllib_start_monitor_mode(struct rtllib_device *ieee)\n{\n\t \n\tif (ieee->raw_tx)\n\t\tnetif_carrier_on(ieee->dev);\n}\n\nstatic void rtllib_start_ibss_wq(void *data)\n{\n\tstruct rtllib_device *ieee = container_of_dwork_rsl(data,\n\t\t\t\t     struct rtllib_device, start_ibss_wq);\n\t \n\tif (!ieee->proto_started) {\n\t\tnetdev_info(ieee->dev, \"==========oh driver down return\\n\");\n\t\treturn;\n\t}\n\tmutex_lock(&ieee->wx_mutex);\n\n\tif (ieee->current_network.ssid_len == 0) {\n\t\tstrscpy(ieee->current_network.ssid, RTLLIB_DEFAULT_TX_ESSID,\n\t\t\tsizeof(ieee->current_network.ssid));\n\t\tieee->current_network.ssid_len = strlen(RTLLIB_DEFAULT_TX_ESSID);\n\t\tieee->ssid_set = 1;\n\t}\n\n\tieee->link_state = MAC80211_NOLINK;\n\tieee->mode = WIRELESS_MODE_G;\n\t \n\trtllib_softmac_check_all_nets(ieee);\n\n\t \n\tif (ieee->link_state == MAC80211_NOLINK)\n\t\trtllib_start_scan_syncro(ieee);\n\n\t \n\tif (ieee->link_state == MAC80211_NOLINK) {\n\t\tnetdev_info(ieee->dev, \"creating new IBSS cell\\n\");\n\t\tieee->current_network.channel = ieee->bss_start_channel;\n\t\tif (!ieee->wap_set)\n\t\t\teth_random_addr(ieee->current_network.bssid);\n\n\t\tieee->current_network.rates_len = 4;\n\t\tieee->current_network.rates[0] =\n\t\t\tRTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_1MB;\n\t\tieee->current_network.rates[1] =\n\t\t\tRTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_2MB;\n\t\tieee->current_network.rates[2] =\n\t\t\tRTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_5MB;\n\t\tieee->current_network.rates[3] =\n\t\t\tRTLLIB_BASIC_RATE_MASK | RTLLIB_CCK_RATE_11MB;\n\n\t\tieee->current_network.rates_ex_len = 8;\n\t\tieee->current_network.rates_ex[0] =\n\t\t\tRTLLIB_OFDM_RATE_6MB;\n\t\tieee->current_network.rates_ex[1] =\n\t\t\tRTLLIB_OFDM_RATE_9MB;\n\t\tieee->current_network.rates_ex[2] =\n\t\t\tRTLLIB_OFDM_RATE_12MB;\n\t\tieee->current_network.rates_ex[3] =\n\t\t\tRTLLIB_OFDM_RATE_18MB;\n\t\tieee->current_network.rates_ex[4] =\n\t\t\tRTLLIB_OFDM_RATE_24MB;\n\t\tieee->current_network.rates_ex[5] =\n\t\t\tRTLLIB_OFDM_RATE_36MB;\n\t\tieee->current_network.rates_ex[6] =\n\t\t\tRTLLIB_OFDM_RATE_48MB;\n\t\tieee->current_network.rates_ex[7] =\n\t\t\tRTLLIB_OFDM_RATE_54MB;\n\t\tieee->rate = 108;\n\n\t\tieee->current_network.qos_data.supported = 0;\n\t\tieee->set_wireless_mode(ieee->dev, WIRELESS_MODE_G);\n\t\tieee->current_network.mode = ieee->mode;\n\t\tieee->current_network.atim_window = 0;\n\t\tieee->current_network.capability = WLAN_CAPABILITY_IBSS;\n\t}\n\n\tnetdev_info(ieee->dev, \"%s(): ieee->mode = %d\\n\", __func__, ieee->mode);\n\tif (ieee->mode == WIRELESS_MODE_N_24G)\n\t\tHTUseDefaultSetting(ieee);\n\telse\n\t\tieee->ht_info->bCurrentHTSupport = false;\n\n\tieee->SetHwRegHandler(ieee->dev, HW_VAR_MEDIA_STATUS,\n\t\t\t      (u8 *)(&ieee->link_state));\n\n\tieee->link_state = MAC80211_LINKED;\n\tieee->link_change(ieee->dev);\n\n\tHTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);\n\trtllib_start_send_beacons(ieee);\n\n\tnotify_wx_assoc_event(ieee);\n\tnetif_carrier_on(ieee->dev);\n\n\tmutex_unlock(&ieee->wx_mutex);\n}\n\ninline void rtllib_start_ibss(struct rtllib_device *ieee)\n{\n\tschedule_delayed_work(&ieee->start_ibss_wq, msecs_to_jiffies(150));\n}\n\n \nstatic void rtllib_start_bss(struct rtllib_device *ieee)\n{\n\tunsigned long flags;\n\n\tif (IS_DOT11D_ENABLE(ieee) && !IS_COUNTRY_IE_VALID(ieee)) {\n\t\tif (!ieee->global_domain)\n\t\t\treturn;\n\t}\n\t \n\trtllib_softmac_check_all_nets(ieee);\n\n\t \n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif (ieee->link_state == MAC80211_NOLINK)\n\t\trtllib_start_scan(ieee);\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\n\nstatic void rtllib_link_change_wq(void *data)\n{\n\tstruct rtllib_device *ieee = container_of_dwork_rsl(data,\n\t\t\t\t     struct rtllib_device, link_change_wq);\n\tieee->link_change(ieee->dev);\n}\n \nvoid rtllib_disassociate(struct rtllib_device *ieee)\n{\n\tnetif_carrier_off(ieee->dev);\n\tif (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)\n\t\trtllib_reset_queue(ieee);\n\n\tif (IS_DOT11D_ENABLE(ieee))\n\t\tdot11d_reset(ieee);\n\tieee->link_state = MAC80211_NOLINK;\n\tieee->is_set_key = false;\n\tieee->wap_set = 0;\n\n\tschedule_delayed_work(&ieee->link_change_wq, 0);\n\n\tnotify_wx_assoc_event(ieee);\n}\n\nstatic void rtllib_associate_retry_wq(void *data)\n{\n\tstruct rtllib_device *ieee = container_of_dwork_rsl(data,\n\t\t\t\t     struct rtllib_device, associate_retry_wq);\n\tunsigned long flags;\n\n\tmutex_lock(&ieee->wx_mutex);\n\tif (!ieee->proto_started)\n\t\tgoto exit;\n\n\tif (ieee->link_state != RTLLIB_ASSOCIATING_RETRY)\n\t\tgoto exit;\n\n\t \n\tieee->beinretry = true;\n\tieee->link_state = MAC80211_NOLINK;\n\n\trtllib_softmac_check_all_nets(ieee);\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tif (ieee->link_state == MAC80211_NOLINK)\n\t\trtllib_start_scan(ieee);\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\n\tieee->beinretry = false;\nexit:\n\tmutex_unlock(&ieee->wx_mutex);\n}\n\nstatic struct sk_buff *rtllib_get_beacon_(struct rtllib_device *ieee)\n{\n\tstatic const u8 broadcast_addr[] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n\t};\n\tstruct sk_buff *skb;\n\tstruct rtllib_probe_response *b;\n\n\tskb = rtllib_probe_resp(ieee, broadcast_addr);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tb = (struct rtllib_probe_response *)skb->data;\n\tb->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_BEACON);\n\n\treturn skb;\n}\n\nstruct sk_buff *rtllib_get_beacon(struct rtllib_device *ieee)\n{\n\tstruct sk_buff *skb;\n\tstruct rtllib_probe_response *b;\n\n\tskb = rtllib_get_beacon_(ieee);\n\tif (!skb)\n\t\treturn NULL;\n\n\tb = (struct rtllib_probe_response *)skb->data;\n\tb->header.seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\n\n\tif (ieee->seq_ctrl[0] == 0xFFF)\n\t\tieee->seq_ctrl[0] = 0;\n\telse\n\t\tieee->seq_ctrl[0]++;\n\n\treturn skb;\n}\nEXPORT_SYMBOL(rtllib_get_beacon);\n\nvoid rtllib_softmac_stop_protocol(struct rtllib_device *ieee, u8 mesh_flag,\n\t\t\t\t  u8 shutdown)\n{\n\trtllib_stop_scan_syncro(ieee);\n\tmutex_lock(&ieee->wx_mutex);\n\trtllib_stop_protocol(ieee, shutdown);\n\tmutex_unlock(&ieee->wx_mutex);\n}\nEXPORT_SYMBOL(rtllib_softmac_stop_protocol);\n\nvoid rtllib_stop_protocol(struct rtllib_device *ieee, u8 shutdown)\n{\n\tif (!ieee->proto_started)\n\t\treturn;\n\n\tif (shutdown) {\n\t\tieee->proto_started = 0;\n\t\tieee->proto_stoppping = 1;\n\t\tieee->rtllib_ips_leave(ieee->dev);\n\t}\n\n\trtllib_stop_send_beacons(ieee);\n\tdel_timer_sync(&ieee->associate_timer);\n\tcancel_delayed_work_sync(&ieee->associate_retry_wq);\n\tcancel_delayed_work_sync(&ieee->start_ibss_wq);\n\tcancel_delayed_work_sync(&ieee->link_change_wq);\n\trtllib_stop_scan(ieee);\n\n\tif (ieee->link_state <= RTLLIB_ASSOCIATING_AUTHENTICATED)\n\t\tieee->link_state = MAC80211_NOLINK;\n\n\tif (ieee->link_state == MAC80211_LINKED) {\n\t\tif (ieee->iw_mode == IW_MODE_INFRA)\n\t\t\tSendDisassociation(ieee, 1, WLAN_REASON_DEAUTH_LEAVING);\n\t\trtllib_disassociate(ieee);\n\t}\n\n\tif (shutdown) {\n\t\tRemoveAllTS(ieee);\n\t\tieee->proto_stoppping = 0;\n\t}\n\tkfree(ieee->assocreq_ies);\n\tieee->assocreq_ies = NULL;\n\tieee->assocreq_ies_len = 0;\n\tkfree(ieee->assocresp_ies);\n\tieee->assocresp_ies = NULL;\n\tieee->assocresp_ies_len = 0;\n}\n\nvoid rtllib_softmac_start_protocol(struct rtllib_device *ieee, u8 mesh_flag)\n{\n\tmutex_lock(&ieee->wx_mutex);\n\trtllib_start_protocol(ieee);\n\tmutex_unlock(&ieee->wx_mutex);\n}\nEXPORT_SYMBOL(rtllib_softmac_start_protocol);\n\nvoid rtllib_start_protocol(struct rtllib_device *ieee)\n{\n\tshort ch = 0;\n\tint i = 0;\n\n\trtllib_update_active_chan_map(ieee);\n\n\tif (ieee->proto_started)\n\t\treturn;\n\n\tieee->proto_started = 1;\n\n\tif (ieee->current_network.channel == 0) {\n\t\tdo {\n\t\t\tch++;\n\t\t\tif (ch > MAX_CHANNEL_NUMBER)\n\t\t\t\treturn;  \n\t\t} while (!ieee->active_channel_map[ch]);\n\t\tieee->current_network.channel = ch;\n\t}\n\n\tif (ieee->current_network.beacon_interval == 0)\n\t\tieee->current_network.beacon_interval = 100;\n\n\tfor (i = 0; i < 17; i++) {\n\t\tieee->last_rxseq_num[i] = -1;\n\t\tieee->last_rxfrag_num[i] = -1;\n\t\tieee->last_packet_time[i] = 0;\n\t}\n\n\tieee->wmm_acm = 0;\n\t \n\tswitch (ieee->iw_mode) {\n\tcase IW_MODE_INFRA:\n\t\trtllib_start_bss(ieee);\n\t\tbreak;\n\tcase IW_MODE_ADHOC:\n\t\trtllib_start_ibss(ieee);\n\t\tbreak;\n\tcase IW_MODE_MONITOR:\n\t\trtllib_start_monitor_mode(ieee);\n\t\tbreak;\n\t}\n}\n\nint rtllib_softmac_init(struct rtllib_device *ieee)\n{\n\tint i;\n\n\tmemset(&ieee->current_network, 0, sizeof(struct rtllib_network));\n\n\tieee->link_state = MAC80211_NOLINK;\n\tfor (i = 0; i < 5; i++)\n\t\tieee->seq_ctrl[i] = 0;\n\tieee->dot11d_info = kzalloc(sizeof(struct rt_dot11d_info), GFP_ATOMIC);\n\tif (!ieee->dot11d_info)\n\t\treturn -ENOMEM;\n\n\tieee->link_detect_info.SlotIndex = 0;\n\tieee->link_detect_info.SlotNum = 2;\n\tieee->link_detect_info.NumRecvBcnInPeriod = 0;\n\tieee->link_detect_info.NumRecvDataInPeriod = 0;\n\tieee->link_detect_info.NumTxOkInPeriod = 0;\n\tieee->link_detect_info.NumRxOkInPeriod = 0;\n\tieee->link_detect_info.NumRxUnicastOkInPeriod = 0;\n\tieee->bIsAggregateFrame = false;\n\tieee->assoc_id = 0;\n\tieee->queue_stop = 0;\n\tieee->scanning_continue = 0;\n\tieee->softmac_features = 0;\n\tieee->wap_set = 0;\n\tieee->ssid_set = 0;\n\tieee->proto_started = 0;\n\tieee->proto_stoppping = 0;\n\tieee->basic_rate = RTLLIB_DEFAULT_BASIC_RATE;\n\tieee->rate = 22;\n\tieee->ps = RTLLIB_PS_DISABLED;\n\tieee->sta_sleep = LPS_IS_WAKE;\n\n\tieee->reg_dot11ht_oper_rate_set[0] = 0xff;\n\tieee->reg_dot11ht_oper_rate_set[1] = 0xff;\n\tieee->reg_dot11ht_oper_rate_set[4] = 0x01;\n\n\tieee->reg_dot11tx_ht_oper_rate_set[0] = 0xff;\n\tieee->reg_dot11tx_ht_oper_rate_set[1] = 0xff;\n\tieee->reg_dot11tx_ht_oper_rate_set[4] = 0x01;\n\n\tieee->FirstIe_InScan = false;\n\tieee->actscanning = false;\n\tieee->beinretry = false;\n\tieee->is_set_key = false;\n\tinit_mgmt_queue(ieee);\n\n\tieee->tx_pending.txb = NULL;\n\n\ttimer_setup(&ieee->associate_timer, rtllib_associate_abort_cb, 0);\n\n\ttimer_setup(&ieee->beacon_timer, rtllib_send_beacon_cb, 0);\n\n\tINIT_DELAYED_WORK(&ieee->link_change_wq, (void *)rtllib_link_change_wq);\n\tINIT_DELAYED_WORK(&ieee->start_ibss_wq, (void *)rtllib_start_ibss_wq);\n\tINIT_WORK(&ieee->associate_complete_wq, (void *)rtllib_associate_complete_wq);\n\tINIT_DELAYED_WORK(&ieee->associate_procedure_wq, (void *)rtllib_associate_procedure_wq);\n\tINIT_DELAYED_WORK(&ieee->softmac_scan_wq, (void *)rtllib_softmac_scan_wq);\n\tINIT_DELAYED_WORK(&ieee->associate_retry_wq, (void *)rtllib_associate_retry_wq);\n\tINIT_WORK(&ieee->wx_sync_scan_wq, (void *)rtllib_wx_sync_scan_wq);\n\n\tmutex_init(&ieee->wx_mutex);\n\tmutex_init(&ieee->scan_mutex);\n\tmutex_init(&ieee->ips_mutex);\n\n\tspin_lock_init(&ieee->mgmt_tx_lock);\n\tspin_lock_init(&ieee->beacon_lock);\n\n\tINIT_WORK(&ieee->ps_task, rtllib_sta_ps);\n\n\treturn 0;\n}\n\nvoid rtllib_softmac_free(struct rtllib_device *ieee)\n{\n\tmutex_lock(&ieee->wx_mutex);\n\tkfree(ieee->dot11d_info);\n\tieee->dot11d_info = NULL;\n\tdel_timer_sync(&ieee->associate_timer);\n\n\tcancel_delayed_work_sync(&ieee->associate_retry_wq);\n\tcancel_delayed_work_sync(&ieee->associate_procedure_wq);\n\tcancel_delayed_work_sync(&ieee->softmac_scan_wq);\n\tcancel_delayed_work_sync(&ieee->start_ibss_wq);\n\tcancel_delayed_work_sync(&ieee->hw_wakeup_wq);\n\tcancel_delayed_work_sync(&ieee->hw_sleep_wq);\n\tcancel_delayed_work_sync(&ieee->link_change_wq);\n\tcancel_work_sync(&ieee->associate_complete_wq);\n\tcancel_work_sync(&ieee->ips_leave_wq);\n\tcancel_work_sync(&ieee->wx_sync_scan_wq);\n\tcancel_work_sync(&ieee->ps_task);\n\tmutex_unlock(&ieee->wx_mutex);\n}\n\nstatic inline struct sk_buff *\nrtllib_disauth_skb(struct rtllib_network *beacon,\n\t\t   struct rtllib_device *ieee, u16 asRsn)\n{\n\tstruct sk_buff *skb;\n\tstruct rtllib_disauth *disauth;\n\tint len = sizeof(struct rtllib_disauth) + ieee->tx_headroom;\n\n\tskb = dev_alloc_skb(len);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\tdisauth = skb_put(skb, sizeof(struct rtllib_disauth));\n\tdisauth->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_DEAUTH);\n\tdisauth->header.duration_id = 0;\n\n\tether_addr_copy(disauth->header.addr1, beacon->bssid);\n\tether_addr_copy(disauth->header.addr2, ieee->dev->dev_addr);\n\tether_addr_copy(disauth->header.addr3, beacon->bssid);\n\n\tdisauth->reason = cpu_to_le16(asRsn);\n\treturn skb;\n}\n\nstatic inline struct sk_buff *\nrtllib_disassociate_skb(struct rtllib_network *beacon,\n\t\t\tstruct rtllib_device *ieee, u16 asRsn)\n{\n\tstruct sk_buff *skb;\n\tstruct rtllib_disassoc *disass;\n\tint len = sizeof(struct rtllib_disassoc) + ieee->tx_headroom;\n\n\tskb = dev_alloc_skb(len);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, ieee->tx_headroom);\n\n\tdisass = skb_put(skb, sizeof(struct rtllib_disassoc));\n\tdisass->header.frame_ctl = cpu_to_le16(RTLLIB_STYPE_DISASSOC);\n\tdisass->header.duration_id = 0;\n\n\tether_addr_copy(disass->header.addr1, beacon->bssid);\n\tether_addr_copy(disass->header.addr2, ieee->dev->dev_addr);\n\tether_addr_copy(disass->header.addr3, beacon->bssid);\n\n\tdisass->reason = cpu_to_le16(asRsn);\n\treturn skb;\n}\n\nvoid SendDisassociation(struct rtllib_device *ieee, bool deauth, u16 asRsn)\n{\n\tstruct rtllib_network *beacon = &ieee->current_network;\n\tstruct sk_buff *skb;\n\n\tif (deauth)\n\t\tskb = rtllib_disauth_skb(beacon, ieee, asRsn);\n\telse\n\t\tskb = rtllib_disassociate_skb(beacon, ieee, asRsn);\n\n\tif (skb)\n\t\tsoftmac_mgmt_xmit(skb, ieee);\n}\n\nu8 rtllib_ap_sec_type(struct rtllib_device *ieee)\n{\n\tstatic u8 ccmp_ie[4] = {0x00, 0x50, 0xf2, 0x04};\n\tstatic u8 ccmp_rsn_ie[4] = {0x00, 0x0f, 0xac, 0x04};\n\tint wpa_ie_len = ieee->wpa_ie_len;\n\tstruct lib80211_crypt_data *crypt;\n\tint encrypt;\n\n\tcrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\n\tencrypt = (ieee->current_network.capability & WLAN_CAPABILITY_PRIVACY)\n\t\t  || (crypt && crypt->ops && (strcmp(crypt->ops->name, \"R-WEP\") == 0));\n\n\t \n\tif (encrypt && (wpa_ie_len == 0)) {\n\t\treturn SEC_ALG_WEP;\n\t} else if ((wpa_ie_len != 0)) {\n\t\tif (((ieee->wpa_ie[0] == 0xdd) &&\n\t\t    (!memcmp(&(ieee->wpa_ie[14]), ccmp_ie, 4))) ||\n\t\t    ((ieee->wpa_ie[0] == 0x30) &&\n\t\t    (!memcmp(&ieee->wpa_ie[10], ccmp_rsn_ie, 4))))\n\t\t\treturn SEC_ALG_CCMP;\n\t\telse\n\t\t\treturn SEC_ALG_TKIP;\n\t} else {\n\t\treturn SEC_ALG_NONE;\n\t}\n}\n\nstatic void rtllib_MgntDisconnectIBSS(struct rtllib_device *rtllib)\n{\n\tu8\tOpMode;\n\tu8\ti;\n\tbool\tbFilterOutNonAssociatedBSSID = false;\n\n\trtllib->link_state = MAC80211_NOLINK;\n\n\tfor (i = 0; i < 6; i++)\n\t\trtllib->current_network.bssid[i] = 0x55;\n\n\trtllib->OpMode = RT_OP_MODE_NO_LINK;\n\trtllib->SetHwRegHandler(rtllib->dev, HW_VAR_BSSID,\n\t\t\t\trtllib->current_network.bssid);\n\tOpMode = RT_OP_MODE_NO_LINK;\n\trtllib->SetHwRegHandler(rtllib->dev, HW_VAR_MEDIA_STATUS, &OpMode);\n\trtllib_stop_send_beacons(rtllib);\n\n\tbFilterOutNonAssociatedBSSID = false;\n\trtllib->SetHwRegHandler(rtllib->dev, HW_VAR_CECHK_BSSID,\n\t\t\t\t(u8 *)(&bFilterOutNonAssociatedBSSID));\n\tnotify_wx_assoc_event(rtllib);\n}\n\nstatic void rtllib_MlmeDisassociateRequest(struct rtllib_device *rtllib,\n\t\t\t\t\t   u8 *asSta, u8 asRsn)\n{\n\tu8 i;\n\tu8\tOpMode;\n\n\tRemovePeerTS(rtllib, asSta);\n\n\tif (memcmp(rtllib->current_network.bssid, asSta, 6) == 0) {\n\t\trtllib->link_state = MAC80211_NOLINK;\n\n\t\tfor (i = 0; i < 6; i++)\n\t\t\trtllib->current_network.bssid[i] = 0x22;\n\t\tOpMode = RT_OP_MODE_NO_LINK;\n\t\trtllib->OpMode = RT_OP_MODE_NO_LINK;\n\t\trtllib->SetHwRegHandler(rtllib->dev, HW_VAR_MEDIA_STATUS,\n\t\t\t\t\t(u8 *)(&OpMode));\n\t\trtllib_disassociate(rtllib);\n\n\t\trtllib->SetHwRegHandler(rtllib->dev, HW_VAR_BSSID,\n\t\t\t\t\trtllib->current_network.bssid);\n\t}\n}\n\nstatic void\nrtllib_MgntDisconnectAP(\n\tstruct rtllib_device *rtllib,\n\tu8 asRsn\n)\n{\n\tbool bFilterOutNonAssociatedBSSID = false;\n\n\tbFilterOutNonAssociatedBSSID = false;\n\trtllib->SetHwRegHandler(rtllib->dev, HW_VAR_CECHK_BSSID,\n\t\t\t\t(u8 *)(&bFilterOutNonAssociatedBSSID));\n\trtllib_MlmeDisassociateRequest(rtllib, rtllib->current_network.bssid,\n\t\t\t\t       asRsn);\n\n\trtllib->link_state = MAC80211_NOLINK;\n}\n\nbool rtllib_MgntDisconnect(struct rtllib_device *rtllib, u8 asRsn)\n{\n\tif (rtllib->ps != RTLLIB_PS_DISABLED)\n\t\trtllib->sta_wake_up(rtllib->dev);\n\n\tif (rtllib->link_state == MAC80211_LINKED) {\n\t\tif (rtllib->iw_mode == IW_MODE_ADHOC)\n\t\t\trtllib_MgntDisconnectIBSS(rtllib);\n\t\tif (rtllib->iw_mode == IW_MODE_INFRA)\n\t\t\trtllib_MgntDisconnectAP(rtllib, asRsn);\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(rtllib_MgntDisconnect);\n\nvoid notify_wx_assoc_event(struct rtllib_device *ieee)\n{\n\tunion iwreq_data wrqu;\n\n\tif (ieee->cannot_notify)\n\t\treturn;\n\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\tif (ieee->link_state == MAC80211_LINKED) {\n\t\tmemcpy(wrqu.ap_addr.sa_data, ieee->current_network.bssid,\n\t\t       ETH_ALEN);\n\t} else {\n\t\tnetdev_info(ieee->dev, \"%s(): Tell user space disconnected\\n\",\n\t\t\t    __func__);\n\t\teth_zero_addr(wrqu.ap_addr.sa_data);\n\t}\n\twireless_send_event(ieee->dev, SIOCGIWAP, &wrqu, NULL);\n}\nEXPORT_SYMBOL(notify_wx_assoc_event);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}