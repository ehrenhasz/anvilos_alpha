{
  "module_name": "rtllib_rx.c",
  "hash_id": "208ac328847bfcedd051f81bea2bab6a3b646b457637b69cf29c59e027ad980a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtllib_rx.c",
  "human_readable_source": "\n \n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n#include <linux/wireless.h>\n#include <linux/etherdevice.h>\n#include <linux/uaccess.h>\n#include <linux/ctype.h>\n\n#include \"rtllib.h\"\n#include \"dot11d.h\"\n\nstatic void rtllib_rx_mgt(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t\t  struct rtllib_rx_stats *stats);\n\nstatic inline void rtllib_monitor_rx(struct rtllib_device *ieee,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     struct rtllib_rx_stats *rx_status,\n\t\t\t\t     size_t hdr_length)\n{\n\tskb->dev = ieee->dev;\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, hdr_length);\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_80211_RAW);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tnetif_rx(skb);\n}\n\n \nstatic struct rtllib_frag_entry *\nrtllib_frag_cache_find(struct rtllib_device *ieee, unsigned int seq,\n\t\t\t  unsigned int frag, u8 tid, u8 *src, u8 *dst)\n{\n\tstruct rtllib_frag_entry *entry;\n\tint i;\n\n\tfor (i = 0; i < RTLLIB_FRAG_CACHE_LEN; i++) {\n\t\tentry = &ieee->frag_cache[tid][i];\n\t\tif (entry->skb != NULL &&\n\t\t    time_after(jiffies, entry->first_frag_time + 2 * HZ)) {\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"expiring fragment cache entry seq=%u last_frag=%u\\n\",\n\t\t\t\t   entry->seq, entry->last_frag);\n\t\t\tdev_kfree_skb_any(entry->skb);\n\t\t\tentry->skb = NULL;\n\t\t}\n\n\t\tif (entry->skb != NULL && entry->seq == seq &&\n\t\t    (entry->last_frag + 1 == frag || frag == -1) &&\n\t\t    memcmp(entry->src_addr, src, ETH_ALEN) == 0 &&\n\t\t    memcmp(entry->dst_addr, dst, ETH_ALEN) == 0)\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct sk_buff *\nrtllib_frag_cache_get(struct rtllib_device *ieee,\n\t\t\t struct rtllib_hdr_4addr *hdr)\n{\n\tstruct sk_buff *skb = NULL;\n\tu16 fc = le16_to_cpu(hdr->frame_ctl);\n\tu16 sc = le16_to_cpu(hdr->seq_ctl);\n\tunsigned int frag = WLAN_GET_SEQ_FRAG(sc);\n\tunsigned int seq = WLAN_GET_SEQ_SEQ(sc);\n\tstruct rtllib_frag_entry *entry;\n\tstruct rtllib_hdr_3addrqos *hdr_3addrqos;\n\tstruct rtllib_hdr_4addrqos *hdr_4addrqos;\n\tu8 tid;\n\n\tif (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) &&\n\t    RTLLIB_QOS_HAS_SEQ(fc)) {\n\t\thdr_4addrqos = (struct rtllib_hdr_4addrqos *)hdr;\n\t\ttid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;\n\t\ttid = UP2AC(tid);\n\t\ttid++;\n\t} else if (RTLLIB_QOS_HAS_SEQ(fc)) {\n\t\thdr_3addrqos = (struct rtllib_hdr_3addrqos *)hdr;\n\t\ttid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;\n\t\ttid = UP2AC(tid);\n\t\ttid++;\n\t} else {\n\t\ttid = 0;\n\t}\n\n\tif (frag == 0) {\n\t\t \n\t\tskb = dev_alloc_skb(ieee->dev->mtu +\n\t\t\t\t    sizeof(struct rtllib_hdr_4addr) +\n\t\t\t\t    8   +\n\t\t\t\t    2   +\n\t\t\t\t    8   +\n\t\t\t\t    ETH_ALEN   +\n\t\t\t\t     \n\t\t\t\t    (RTLLIB_QOS_HAS_SEQ(fc) ? 2 : 0));\n\t\tif (!skb)\n\t\t\treturn NULL;\n\n\t\tentry = &ieee->frag_cache[tid][ieee->frag_next_idx[tid]];\n\t\tieee->frag_next_idx[tid]++;\n\t\tif (ieee->frag_next_idx[tid] >= RTLLIB_FRAG_CACHE_LEN)\n\t\t\tieee->frag_next_idx[tid] = 0;\n\n\t\tif (entry->skb != NULL)\n\t\t\tdev_kfree_skb_any(entry->skb);\n\n\t\tentry->first_frag_time = jiffies;\n\t\tentry->seq = seq;\n\t\tentry->last_frag = frag;\n\t\tentry->skb = skb;\n\t\tether_addr_copy(entry->src_addr, hdr->addr2);\n\t\tether_addr_copy(entry->dst_addr, hdr->addr1);\n\t} else {\n\t\t \n\t\tentry = rtllib_frag_cache_find(ieee, seq, frag, tid, hdr->addr2,\n\t\t\t\t\t\t  hdr->addr1);\n\t\tif (entry != NULL) {\n\t\t\tentry->last_frag = frag;\n\t\t\tskb = entry->skb;\n\t\t}\n\t}\n\n\treturn skb;\n}\n\n \nstatic int rtllib_frag_cache_invalidate(struct rtllib_device *ieee,\n\t\t\t\t\t   struct rtllib_hdr_4addr *hdr)\n{\n\tu16 fc = le16_to_cpu(hdr->frame_ctl);\n\tu16 sc = le16_to_cpu(hdr->seq_ctl);\n\tunsigned int seq = WLAN_GET_SEQ_SEQ(sc);\n\tstruct rtllib_frag_entry *entry;\n\tstruct rtllib_hdr_3addrqos *hdr_3addrqos;\n\tstruct rtllib_hdr_4addrqos *hdr_4addrqos;\n\tu8 tid;\n\n\tif (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) &&\n\t    RTLLIB_QOS_HAS_SEQ(fc)) {\n\t\thdr_4addrqos = (struct rtllib_hdr_4addrqos *)hdr;\n\t\ttid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;\n\t\ttid = UP2AC(tid);\n\t\ttid++;\n\t} else if (RTLLIB_QOS_HAS_SEQ(fc)) {\n\t\thdr_3addrqos = (struct rtllib_hdr_3addrqos *)hdr;\n\t\ttid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;\n\t\ttid = UP2AC(tid);\n\t\ttid++;\n\t} else {\n\t\ttid = 0;\n\t}\n\n\tentry = rtllib_frag_cache_find(ieee, seq, -1, tid, hdr->addr2,\n\t\t\t\t\t  hdr->addr1);\n\n\tif (entry == NULL) {\n\t\tnetdev_dbg(ieee->dev,\n\t\t\t   \"Couldn't invalidate fragment cache entry (seq=%u)\\n\",\n\t\t\t   seq);\n\t\treturn -1;\n\t}\n\n\tentry->skb = NULL;\n\treturn 0;\n}\n\n \nstatic inline int\nrtllib_rx_frame_mgmt(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t\tstruct rtllib_rx_stats *rx_stats, u16 type,\n\t\t\tu16 stype)\n{\n\t \n\tstruct rtllib_hdr_3addr *hdr = (struct rtllib_hdr_3addr *)skb->data;\n\n\trx_stats->len = skb->len;\n\trtllib_rx_mgt(ieee, skb, rx_stats);\n\tif ((memcmp(hdr->addr1, ieee->dev->dev_addr, ETH_ALEN))) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn 0;\n\t}\n\trtllib_rx_frame_softmac(ieee, skb, rx_stats, type, stype);\n\n\tdev_kfree_skb_any(skb);\n\n\treturn 0;\n}\n\n \n\n \nstatic int rtllib_is_eapol_frame(struct rtllib_device *ieee,\n\t\t\t\t    struct sk_buff *skb, size_t hdrlen)\n{\n\tstruct net_device *dev = ieee->dev;\n\tu16 fc, ethertype;\n\tstruct rtllib_hdr_4addr *hdr;\n\tu8 *pos;\n\n\tif (skb->len < 24)\n\t\treturn 0;\n\n\thdr = (struct rtllib_hdr_4addr *)skb->data;\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\n\t \n\tif ((fc & (RTLLIB_FCTL_TODS | RTLLIB_FCTL_FROMDS)) ==\n\t    RTLLIB_FCTL_TODS &&\n\t    memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0 &&\n\t    memcmp(hdr->addr3, dev->dev_addr, ETH_ALEN) == 0) {\n\t\t \n\t} else if ((fc & (RTLLIB_FCTL_TODS | RTLLIB_FCTL_FROMDS)) ==\n\t\t   RTLLIB_FCTL_FROMDS &&\n\t\t   memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0) {\n\t\t \n\t} else {\n\t\treturn 0;\n\t}\n\n\tif (skb->len < 24 + 8)\n\t\treturn 0;\n\n\t \n\tpos = skb->data + hdrlen;\n\tethertype = (pos[6] << 8) | pos[7];\n\tif (ethertype == ETH_P_PAE)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic inline int\nrtllib_rx_frame_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t\tstruct lib80211_crypt_data *crypt)\n{\n\tstruct rtllib_hdr_4addr *hdr;\n\tint res, hdrlen;\n\n\tif (crypt == NULL || crypt->ops->decrypt_mpdu == NULL)\n\t\treturn 0;\n\n\tif (ieee->hwsec_active) {\n\t\tstruct cb_desc *tcb_desc = (struct cb_desc *)\n\t\t\t\t\t\t(skb->cb + MAX_DEV_ADDR_SIZE);\n\n\t\ttcb_desc->bHwSec = 1;\n\n\t\tif (ieee->need_sw_enc)\n\t\t\ttcb_desc->bHwSec = 0;\n\t}\n\n\thdr = (struct rtllib_hdr_4addr *)skb->data;\n\thdrlen = rtllib_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\n\n\tatomic_inc(&crypt->refcnt);\n\tres = crypt->ops->decrypt_mpdu(skb, hdrlen, crypt->priv);\n\tatomic_dec(&crypt->refcnt);\n\tif (res < 0) {\n\t\tnetdev_dbg(ieee->dev, \"decryption failed (SA= %pM) res=%d\\n\",\n\t\t\t   hdr->addr2, res);\n\t\tif (res == -2)\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"Decryption failed ICV mismatch (key %d)\\n\",\n\t\t\t\t   skb->data[hdrlen + 3] >> 6);\n\t\treturn -1;\n\t}\n\n\treturn res;\n}\n\n \nstatic inline int\nrtllib_rx_frame_decrypt_msdu(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t\t     int keyidx, struct lib80211_crypt_data *crypt)\n{\n\tstruct rtllib_hdr_4addr *hdr;\n\tint res, hdrlen;\n\n\tif (crypt == NULL || crypt->ops->decrypt_msdu == NULL)\n\t\treturn 0;\n\tif (ieee->hwsec_active) {\n\t\tstruct cb_desc *tcb_desc = (struct cb_desc *)\n\t\t\t\t\t\t(skb->cb + MAX_DEV_ADDR_SIZE);\n\n\t\ttcb_desc->bHwSec = 1;\n\n\t\tif (ieee->need_sw_enc)\n\t\t\ttcb_desc->bHwSec = 0;\n\t}\n\n\thdr = (struct rtllib_hdr_4addr *)skb->data;\n\thdrlen = rtllib_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\n\n\tatomic_inc(&crypt->refcnt);\n\tres = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv);\n\tatomic_dec(&crypt->refcnt);\n\tif (res < 0) {\n\t\tnetdev_dbg(ieee->dev,\n\t\t\t   \"MSDU decryption/MIC verification failed (SA= %pM keyidx=%d)\\n\",\n\t\t\t   hdr->addr2, keyidx);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \n#define IEEE_PACKET_RETRY_TIME (5 * HZ)\nstatic int is_duplicate_packet(struct rtllib_device *ieee,\n\t\t\t\t      struct rtllib_hdr_4addr *header)\n{\n\tu16 fc = le16_to_cpu(header->frame_ctl);\n\tu16 sc = le16_to_cpu(header->seq_ctl);\n\tu16 seq = WLAN_GET_SEQ_SEQ(sc);\n\tu16 frag = WLAN_GET_SEQ_FRAG(sc);\n\tu16 *last_seq, *last_frag;\n\tunsigned long *last_time;\n\tstruct rtllib_hdr_3addrqos *hdr_3addrqos;\n\tstruct rtllib_hdr_4addrqos *hdr_4addrqos;\n\tu8 tid;\n\n\tif (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) &&\n\t    RTLLIB_QOS_HAS_SEQ(fc)) {\n\t\thdr_4addrqos = (struct rtllib_hdr_4addrqos *)header;\n\t\ttid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;\n\t\ttid = UP2AC(tid);\n\t\ttid++;\n\t} else if (RTLLIB_QOS_HAS_SEQ(fc)) {\n\t\thdr_3addrqos = (struct rtllib_hdr_3addrqos *)header;\n\t\ttid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;\n\t\ttid = UP2AC(tid);\n\t\ttid++;\n\t} else {\n\t\ttid = 0;\n\t}\n\n\tswitch (ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\t{\n\t\tstruct list_head *p;\n\t\tstruct ieee_ibss_seq *entry = NULL;\n\t\tu8 *mac = header->addr2;\n\t\tint index = mac[5] % IEEE_IBSS_MAC_HASH_SIZE;\n\n\t\tlist_for_each(p, &ieee->ibss_mac_hash[index]) {\n\t\t\tentry = list_entry(p, struct ieee_ibss_seq, list);\n\t\t\tif (!memcmp(entry->mac, mac, ETH_ALEN))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (p == &ieee->ibss_mac_hash[index]) {\n\t\t\tentry = kmalloc(sizeof(struct ieee_ibss_seq),\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (!entry)\n\t\t\t\treturn 0;\n\n\t\t\tether_addr_copy(entry->mac, mac);\n\t\t\tentry->seq_num[tid] = seq;\n\t\t\tentry->frag_num[tid] = frag;\n\t\t\tentry->packet_time[tid] = jiffies;\n\t\t\tlist_add(&entry->list, &ieee->ibss_mac_hash[index]);\n\t\t\treturn 0;\n\t\t}\n\t\tlast_seq = &entry->seq_num[tid];\n\t\tlast_frag = &entry->frag_num[tid];\n\t\tlast_time = &entry->packet_time[tid];\n\t\tbreak;\n\t}\n\n\tcase IW_MODE_INFRA:\n\t\tlast_seq = &ieee->last_rxseq_num[tid];\n\t\tlast_frag = &ieee->last_rxfrag_num[tid];\n\t\tlast_time = &ieee->last_packet_time[tid];\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif ((*last_seq == seq) &&\n\t    time_after(*last_time + IEEE_PACKET_RETRY_TIME, jiffies)) {\n\t\tif (*last_frag == frag)\n\t\t\tgoto drop;\n\t\tif (*last_frag + 1 != frag)\n\t\t\t \n\t\t\tgoto drop;\n\t} else {\n\t\t*last_seq = seq;\n\t}\n\n\t*last_frag = frag;\n\t*last_time = jiffies;\n\treturn 0;\n\ndrop:\n\n\treturn 1;\n}\n\nstatic bool AddReorderEntry(struct rx_ts_record *pTS,\n\t\t\t    struct rx_reorder_entry *pReorderEntry)\n{\n\tstruct list_head *pList = &pTS->rx_pending_pkt_list;\n\n\twhile (pList->next != &pTS->rx_pending_pkt_list) {\n\t\tif (SN_LESS(pReorderEntry->SeqNum, ((struct rx_reorder_entry *)\n\t\t    list_entry(pList->next, struct rx_reorder_entry,\n\t\t    List))->SeqNum))\n\t\t\tpList = pList->next;\n\t\telse if (SN_EQUAL(pReorderEntry->SeqNum,\n\t\t\t((struct rx_reorder_entry *)list_entry(pList->next,\n\t\t\tstruct rx_reorder_entry, List))->SeqNum))\n\t\t\treturn false;\n\t\telse\n\t\t\tbreak;\n\t}\n\tpReorderEntry->List.next = pList->next;\n\tpReorderEntry->List.next->prev = &pReorderEntry->List;\n\tpReorderEntry->List.prev = pList;\n\tpList->next = &pReorderEntry->List;\n\n\treturn true;\n}\n\nvoid rtllib_indicate_packets(struct rtllib_device *ieee,\n\t\t\t     struct rtllib_rxb **prxbIndicateArray, u8 index)\n{\n\tstruct net_device_stats *stats = &ieee->stats;\n\tu8 i = 0, j = 0;\n\tu16 ethertype;\n\n\tfor (j = 0; j < index; j++) {\n\t\tstruct rtllib_rxb *prxb = prxbIndicateArray[j];\n\n\t\tfor (i = 0; i < prxb->nr_subframes; i++) {\n\t\t\tstruct sk_buff *sub_skb = prxb->subframes[i];\n\n\t\t \n\t\t\tethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];\n\t\t\tif (sub_skb->len >= 8 &&\n\t\t\t    ((memcmp(sub_skb->data, rfc1042_header,\n\t\t\t\t     SNAP_SIZE) == 0 &&\n\t\t\t      ethertype != ETH_P_AARP &&\n\t\t\t      ethertype != ETH_P_IPX) ||\n\t\t\t    memcmp(sub_skb->data, bridge_tunnel_header,\n\t\t\t\t   SNAP_SIZE) == 0)) {\n\t\t\t\t \n\t\t\t\tskb_pull(sub_skb, SNAP_SIZE);\n\t\t\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), prxb->src, ETH_ALEN);\n\t\t\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), prxb->dst, ETH_ALEN);\n\t\t\t} else {\n\t\t\t\tu16 len;\n\t\t\t \n\t\t\t\tlen = sub_skb->len;\n\t\t\t\tmemcpy(skb_push(sub_skb, 2), &len, 2);\n\t\t\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), prxb->src, ETH_ALEN);\n\t\t\t\tmemcpy(skb_push(sub_skb, ETH_ALEN), prxb->dst, ETH_ALEN);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (sub_skb) {\n\t\t\t\tstats->rx_packets++;\n\t\t\t\tstats->rx_bytes += sub_skb->len;\n\n\t\t\t\tmemset(sub_skb->cb, 0, sizeof(sub_skb->cb));\n\t\t\t\tsub_skb->protocol = eth_type_trans(sub_skb,\n\t\t\t\t\t\t\t\t   ieee->dev);\n\t\t\t\tsub_skb->dev = ieee->dev;\n\t\t\t\tsub_skb->dev->stats.rx_packets++;\n\t\t\t\tsub_skb->dev->stats.rx_bytes += sub_skb->len;\n\t\t\t\t \n\t\t\t\tsub_skb->ip_summed = CHECKSUM_NONE;\n\t\t\t\tieee->last_rx_ps_time = jiffies;\n\t\t\t\tnetif_rx(sub_skb);\n\t\t\t}\n\t\t}\n\t\tkfree(prxb);\n\t\tprxb = NULL;\n\t}\n}\n\nvoid rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,\n\t\t\t\t struct rx_ts_record *pTS)\n{\n\tstruct rx_reorder_entry *pRxReorderEntry;\n\tu8 RfdCnt = 0;\n\n\tdel_timer_sync(&pTS->rx_pkt_pending_timer);\n\twhile (!list_empty(&pTS->rx_pending_pkt_list)) {\n\t\tif (RfdCnt >= REORDER_WIN_SIZE) {\n\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t    \"-------------->%s() error! RfdCnt >= REORDER_WIN_SIZE\\n\",\n\t\t\t\t    __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tpRxReorderEntry = (struct rx_reorder_entry *)\n\t\t\t\t  list_entry(pTS->rx_pending_pkt_list.prev,\n\t\t\t\t\t     struct rx_reorder_entry, List);\n\t\tnetdev_dbg(ieee->dev, \"%s(): Indicate SeqNum %d!\\n\", __func__,\n\t\t\t   pRxReorderEntry->SeqNum);\n\t\tlist_del_init(&pRxReorderEntry->List);\n\n\t\tieee->RfdArray[RfdCnt] = pRxReorderEntry->prxb;\n\n\t\tRfdCnt = RfdCnt + 1;\n\t\tlist_add_tail(&pRxReorderEntry->List,\n\t\t\t      &ieee->RxReorder_Unused_List);\n\t}\n\trtllib_indicate_packets(ieee, ieee->RfdArray, RfdCnt);\n\n\tpTS->rx_indicate_seq = 0xffff;\n}\n\nstatic void RxReorderIndicatePacket(struct rtllib_device *ieee,\n\t\t\t\t    struct rtllib_rxb *prxb,\n\t\t\t\t    struct rx_ts_record *pTS, u16 SeqNum)\n{\n\tstruct rt_hi_throughput *ht_info = ieee->ht_info;\n\tstruct rx_reorder_entry *pReorderEntry = NULL;\n\tu8 WinSize = ht_info->rx_reorder_win_size;\n\tu16 WinEnd = 0;\n\tu8 index = 0;\n\tbool bMatchWinStart = false, bPktInBuf = false;\n\tunsigned long flags;\n\n\tnetdev_dbg(ieee->dev,\n\t\t   \"%s(): Seq is %d, pTS->rx_indicate_seq is %d, WinSize is %d\\n\",\n\t\t   __func__, SeqNum, pTS->rx_indicate_seq, WinSize);\n\n\tspin_lock_irqsave(&(ieee->reorder_spinlock), flags);\n\n\tWinEnd = (pTS->rx_indicate_seq + WinSize - 1) % 4096;\n\t \n\tif (pTS->rx_indicate_seq == 0xffff)\n\t\tpTS->rx_indicate_seq = SeqNum;\n\n\t \n\tif (SN_LESS(SeqNum, pTS->rx_indicate_seq)) {\n\t\tnetdev_dbg(ieee->dev,\n\t\t\t   \"Packet Drop! IndicateSeq: %d, NewSeq: %d\\n\",\n\t\t\t   pTS->rx_indicate_seq, SeqNum);\n\t\tht_info->rx_reorder_drop_counter++;\n\t\t{\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < prxb->nr_subframes; i++)\n\t\t\t\tdev_kfree_skb(prxb->subframes[i]);\n\t\t\tkfree(prxb);\n\t\t\tprxb = NULL;\n\t\t}\n\t\tspin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);\n\t\treturn;\n\t}\n\n\t \n\tif (SN_EQUAL(SeqNum, pTS->rx_indicate_seq)) {\n\t\tpTS->rx_indicate_seq = (pTS->rx_indicate_seq + 1) % 4096;\n\t\tbMatchWinStart = true;\n\t} else if (SN_LESS(WinEnd, SeqNum)) {\n\t\tif (SeqNum >= (WinSize - 1))\n\t\t\tpTS->rx_indicate_seq = SeqNum + 1 - WinSize;\n\t\telse\n\t\t\tpTS->rx_indicate_seq = 4095 -\n\t\t\t\t\t     (WinSize - (SeqNum + 1)) + 1;\n\t\tnetdev_dbg(ieee->dev,\n\t\t\t   \"Window Shift! IndicateSeq: %d, NewSeq: %d\\n\",\n\t\t\t   pTS->rx_indicate_seq, SeqNum);\n\t}\n\n\t \n\tif (bMatchWinStart) {\n\t\t \n\t\tnetdev_dbg(ieee->dev,\n\t\t\t   \"Packets indication! IndicateSeq: %d, NewSeq: %d\\n\",\n\t\t\t   pTS->rx_indicate_seq, SeqNum);\n\t\tieee->prxbIndicateArray[0] = prxb;\n\t\tindex = 1;\n\t} else {\n\t\t \n\t\tif (!list_empty(&ieee->RxReorder_Unused_List)) {\n\t\t\tpReorderEntry = (struct rx_reorder_entry *)\n\t\t\t\t\tlist_entry(ieee->RxReorder_Unused_List.next,\n\t\t\t\t\tstruct rx_reorder_entry, List);\n\t\t\tlist_del_init(&pReorderEntry->List);\n\n\t\t\t \n\t\t\tpReorderEntry->SeqNum = SeqNum;\n\t\t\tpReorderEntry->prxb = prxb;\n\n\t\t\tif (!AddReorderEntry(pTS, pReorderEntry)) {\n\t\t\t\tint i;\n\n\t\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t\t   \"%s(): Duplicate packet is dropped. IndicateSeq: %d, NewSeq: %d\\n\",\n\t\t\t\t\t   __func__, pTS->rx_indicate_seq,\n\t\t\t\t\t   SeqNum);\n\t\t\t\tlist_add_tail(&pReorderEntry->List,\n\t\t\t\t\t      &ieee->RxReorder_Unused_List);\n\n\t\t\t\tfor (i = 0; i < prxb->nr_subframes; i++)\n\t\t\t\t\tdev_kfree_skb(prxb->subframes[i]);\n\t\t\t\tkfree(prxb);\n\t\t\t\tprxb = NULL;\n\t\t\t} else {\n\t\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t\t   \"Pkt insert into struct buffer. IndicateSeq: %d, NewSeq: %d\\n\",\n\t\t\t\t\t   pTS->rx_indicate_seq, SeqNum);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tnetdev_err(ieee->dev,\n\t\t\t\t   \"%s(): There is no reorder entry! Packet is dropped!\\n\",\n\t\t\t\t   __func__);\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < prxb->nr_subframes; i++)\n\t\t\t\t\tdev_kfree_skb(prxb->subframes[i]);\n\t\t\t\tkfree(prxb);\n\t\t\t\tprxb = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\twhile (!list_empty(&pTS->rx_pending_pkt_list)) {\n\t\tnetdev_dbg(ieee->dev, \"%s(): start RREORDER indicate\\n\",\n\t\t\t   __func__);\n\n\t\tpReorderEntry = (struct rx_reorder_entry *)\n\t\t\t\t\tlist_entry(pTS->rx_pending_pkt_list.prev,\n\t\t\t\t\t\t   struct rx_reorder_entry,\n\t\t\t\t\t\t   List);\n\t\tif (SN_LESS(pReorderEntry->SeqNum, pTS->rx_indicate_seq) ||\n\t\t    SN_EQUAL(pReorderEntry->SeqNum, pTS->rx_indicate_seq)) {\n\t\t\t \n\t\t\tif (index >= REORDER_WIN_SIZE) {\n\t\t\t\tnetdev_err(ieee->dev,\n\t\t\t\t\t   \"%s(): Buffer overflow!\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t\tbPktInBuf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlist_del_init(&pReorderEntry->List);\n\n\t\t\tif (SN_EQUAL(pReorderEntry->SeqNum, pTS->rx_indicate_seq))\n\t\t\t\tpTS->rx_indicate_seq = (pTS->rx_indicate_seq + 1) %\n\t\t\t\t\t\t     4096;\n\n\t\t\tieee->prxbIndicateArray[index] = pReorderEntry->prxb;\n\t\t\tnetdev_dbg(ieee->dev, \"%s(): Indicate SeqNum %d!\\n\",\n\t\t\t\t   __func__, pReorderEntry->SeqNum);\n\t\t\tindex++;\n\n\t\t\tlist_add_tail(&pReorderEntry->List,\n\t\t\t\t      &ieee->RxReorder_Unused_List);\n\t\t} else {\n\t\t\tbPktInBuf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (index > 0) {\n\t\tif (timer_pending(&pTS->rx_pkt_pending_timer))\n\t\t\tdel_timer_sync(&pTS->rx_pkt_pending_timer);\n\t\tpTS->rx_timeout_indicate_seq = 0xffff;\n\n\t\tif (index > REORDER_WIN_SIZE) {\n\t\t\tnetdev_err(ieee->dev,\n\t\t\t\t   \"%s(): Rx Reorder struct buffer full!\\n\",\n\t\t\t\t   __func__);\n\t\t\tspin_unlock_irqrestore(&(ieee->reorder_spinlock),\n\t\t\t\t\t       flags);\n\t\t\treturn;\n\t\t}\n\t\trtllib_indicate_packets(ieee, ieee->prxbIndicateArray, index);\n\t\tbPktInBuf = false;\n\t}\n\n\tif (bPktInBuf && pTS->rx_timeout_indicate_seq == 0xffff) {\n\t\tnetdev_dbg(ieee->dev, \"%s(): SET rx timeout timer\\n\", __func__);\n\t\tpTS->rx_timeout_indicate_seq = pTS->rx_indicate_seq;\n\t\tmod_timer(&pTS->rx_pkt_pending_timer, jiffies +\n\t\t\t  msecs_to_jiffies(ht_info->rx_reorder_pending_time));\n\t}\n\tspin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);\n}\n\nstatic u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t\t struct rtllib_rx_stats *rx_stats,\n\t\t\t struct rtllib_rxb *rxb, u8 *src, u8 *dst)\n{\n\tstruct rtllib_hdr_3addr  *hdr = (struct rtllib_hdr_3addr *)skb->data;\n\tu16\t\tfc = le16_to_cpu(hdr->frame_ctl);\n\n\tu16\t\tLLCOffset = sizeof(struct rtllib_hdr_3addr);\n\tu16\t\tChkLength;\n\tbool\t\tbIsAggregateFrame = false;\n\tu16\t\tnSubframe_Length;\n\tu8\t\tnPadding_Length = 0;\n\tu16\t\tSeqNum = 0;\n\tstruct sk_buff *sub_skb;\n\t \n\tSeqNum = WLAN_GET_SEQ_SEQ(le16_to_cpu(hdr->seq_ctl));\n\tif ((RTLLIB_QOS_HAS_SEQ(fc)) &&\n\t   (((union frameqos *)(skb->data + RTLLIB_3ADDR_LEN))->field.reserved))\n\t\tbIsAggregateFrame = true;\n\n\tif (RTLLIB_QOS_HAS_SEQ(fc))\n\t\tLLCOffset += 2;\n\tif (rx_stats->bContainHTC)\n\t\tLLCOffset += sHTCLng;\n\n\tChkLength = LLCOffset;\n\n\tif (skb->len <= ChkLength)\n\t\treturn 0;\n\n\tskb_pull(skb, LLCOffset);\n\tieee->bIsAggregateFrame = bIsAggregateFrame;\n\tif (!bIsAggregateFrame) {\n\t\trxb->nr_subframes = 1;\n\n\t\t \n\n\t\t \n\t\tsub_skb = dev_alloc_skb(RTLLIB_SKBBUFFER_SIZE);\n\t\tif (!sub_skb)\n\t\t\treturn 0;\n\t\tskb_reserve(sub_skb, 12);\n\t\tskb_put_data(sub_skb, skb->data, skb->len);\n\t\tsub_skb->dev = ieee->dev;\n\n\t\trxb->subframes[0] = sub_skb;\n\n\t\tmemcpy(rxb->src, src, ETH_ALEN);\n\t\tmemcpy(rxb->dst, dst, ETH_ALEN);\n\t\trxb->subframes[0]->dev = ieee->dev;\n\t\treturn 1;\n\t}\n\n\trxb->nr_subframes = 0;\n\tmemcpy(rxb->src, src, ETH_ALEN);\n\tmemcpy(rxb->dst, dst, ETH_ALEN);\n\twhile (skb->len > ETHERNET_HEADER_SIZE) {\n\t\t \n\t\tnSubframe_Length = *((u16 *)(skb->data + 12));\n\t\tnSubframe_Length = (nSubframe_Length >> 8) +\n\t\t\t\t   (nSubframe_Length << 8);\n\n\t\tif (skb->len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {\n\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t    \"%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\\n\",\n\t\t\t\t    __func__, rxb->nr_subframes);\n\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t    \"%s: A-MSDU parse error!! Subframe Length: %d\\n\",\n\t\t\t\t    __func__, nSubframe_Length);\n\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t    \"nRemain_Length is %d and nSubframe_Length is : %d\\n\",\n\t\t\t\t    skb->len, nSubframe_Length);\n\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t    \"The Packet SeqNum is %d\\n\",\n\t\t\t\t    SeqNum);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tskb_pull(skb, ETHERNET_HEADER_SIZE);\n\n\t\t \n\n\t\t \n\t\tsub_skb = dev_alloc_skb(nSubframe_Length + 12);\n\t\tif (!sub_skb)\n\t\t\treturn 0;\n\t\tskb_reserve(sub_skb, 12);\n\t\tskb_put_data(sub_skb, skb->data, nSubframe_Length);\n\n\t\tsub_skb->dev = ieee->dev;\n\t\trxb->subframes[rxb->nr_subframes++] = sub_skb;\n\t\tif (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"ParseSubframe(): Too many Subframes! Packets dropped!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tskb_pull(skb, nSubframe_Length);\n\n\t\tif (skb->len != 0) {\n\t\t\tnPadding_Length = 4 - ((nSubframe_Length +\n\t\t\t\t\t  ETHERNET_HEADER_SIZE) % 4);\n\t\t\tif (nPadding_Length == 4)\n\t\t\t\tnPadding_Length = 0;\n\n\t\t\tif (skb->len < nPadding_Length)\n\t\t\t\treturn 0;\n\n\t\t\tskb_pull(skb, nPadding_Length);\n\t\t}\n\t}\n\n\treturn rxb->nr_subframes;\n}\n\nstatic size_t rtllib_rx_get_hdrlen(struct rtllib_device *ieee,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   struct rtllib_rx_stats *rx_stats)\n{\n\tstruct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;\n\tu16 fc = le16_to_cpu(hdr->frame_ctl);\n\tsize_t hdrlen;\n\n\thdrlen = rtllib_get_hdrlen(fc);\n\tif (HTCCheck(ieee, skb->data)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(ieee->dev, \"%s: find HTCControl!\\n\",\n\t\t\t\t    __func__);\n\t\thdrlen += 4;\n\t\trx_stats->bContainHTC = true;\n\t}\n\n\tif (RTLLIB_QOS_HAS_SEQ(fc))\n\t\trx_stats->bIsQosData = true;\n\n\treturn hdrlen;\n}\n\nstatic int rtllib_rx_check_duplicate(struct rtllib_device *ieee,\n\t\t\t\t     struct sk_buff *skb, u8 multicast)\n{\n\tstruct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;\n\tu16 fc, sc;\n\tu8 frag, type, stype;\n\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tstype = WLAN_FC_GET_STYPE(fc);\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\tfrag = WLAN_GET_SEQ_FRAG(sc);\n\n\tif (!ieee->ht_info->cur_rx_reorder_enable ||\n\t\t!ieee->current_network.qos_data.active ||\n\t\t!IsDataFrame(skb->data) ||\n\t\tIsLegacyDataFrame(skb->data)) {\n\t\tif (!((type == RTLLIB_FTYPE_MGMT) &&\n\t\t      (stype == RTLLIB_STYPE_BEACON))) {\n\t\t\tif (is_duplicate_packet(ieee, hdr))\n\t\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tstruct rx_ts_record *pRxTS = NULL;\n\n\t\tif (GetTs(ieee, (struct ts_common_info **)&pRxTS, hdr->addr2,\n\t\t\t(u8)Frame_QoSTID((u8 *)(skb->data)), RX_DIR, true)) {\n\t\t\tif ((fc & (1 << 11)) && (frag == pRxTS->rx_last_frag_num) &&\n\t\t\t    (WLAN_GET_SEQ_SEQ(sc) == pRxTS->rx_last_seq_num))\n\t\t\t\treturn -1;\n\t\t\tpRxTS->rx_last_frag_num = frag;\n\t\t\tpRxTS->rx_last_seq_num = WLAN_GET_SEQ_SEQ(sc);\n\t\t} else {\n\t\t\tnetdev_warn(ieee->dev, \"%s(): No TS! Skip the check!\\n\",\n\t\t\t\t    __func__);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void rtllib_rx_extract_addr(struct rtllib_device *ieee,\n\t\t\t\t   struct rtllib_hdr_4addr *hdr, u8 *dst,\n\t\t\t\t   u8 *src, u8 *bssid)\n{\n\tu16 fc = le16_to_cpu(hdr->frame_ctl);\n\n\tswitch (fc & (RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS)) {\n\tcase RTLLIB_FCTL_FROMDS:\n\t\tether_addr_copy(dst, hdr->addr1);\n\t\tether_addr_copy(src, hdr->addr3);\n\t\tether_addr_copy(bssid, hdr->addr2);\n\t\tbreak;\n\tcase RTLLIB_FCTL_TODS:\n\t\tether_addr_copy(dst, hdr->addr3);\n\t\tether_addr_copy(src, hdr->addr2);\n\t\tether_addr_copy(bssid, hdr->addr1);\n\t\tbreak;\n\tcase RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS:\n\t\tether_addr_copy(dst, hdr->addr3);\n\t\tether_addr_copy(src, hdr->addr4);\n\t\tether_addr_copy(bssid, ieee->current_network.bssid);\n\t\tbreak;\n\tdefault:\n\t\tether_addr_copy(dst, hdr->addr1);\n\t\tether_addr_copy(src, hdr->addr2);\n\t\tether_addr_copy(bssid, hdr->addr3);\n\t\tbreak;\n\t}\n}\n\nstatic int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc,\n\t\t\t\t u8 *dst, u8 *src, u8 *bssid, u8 *addr2)\n{\n\tu8 type, stype;\n\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tstype = WLAN_FC_GET_STYPE(fc);\n\n\t \n\tif (((fc & RTLLIB_FCTL_DSTODS) != RTLLIB_FCTL_DSTODS) &&\n\t    !ether_addr_equal(ieee->current_network.bssid, bssid) &&\n\t    !is_zero_ether_addr(ieee->current_network.bssid)) {\n\t\treturn -1;\n\t}\n\n\t \n\tif (ieee->intel_promiscuous_md_info.promiscuous_on  &&\n\t\tieee->intel_promiscuous_md_info.fltr_src_sta_frame) {\n\t\tif ((fc & RTLLIB_FCTL_TODS) && !(fc & RTLLIB_FCTL_FROMDS) &&\n\t\t    !ether_addr_equal(dst, ieee->current_network.bssid) &&\n\t\t    ether_addr_equal(bssid, ieee->current_network.bssid)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tif (!ieee->intel_promiscuous_md_info.promiscuous_on) {\n\t\tif (stype != RTLLIB_STYPE_DATA &&\n\t\t    stype != RTLLIB_STYPE_DATA_CFACK &&\n\t\t    stype != RTLLIB_STYPE_DATA_CFPOLL &&\n\t\t    stype != RTLLIB_STYPE_DATA_CFACKPOLL &&\n\t\t    stype != RTLLIB_STYPE_QOS_DATA) {\n\t\t\tif (stype != RTLLIB_STYPE_NULLFUNC)\n\t\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t\t   \"RX: dropped data frame with no data (type=0x%02x, subtype=0x%02x)\\n\",\n\t\t\t\t\t   type, stype);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tif (!memcmp(src, ieee->dev->dev_addr, ETH_ALEN))\n\t\treturn -1;\n\n\t \n\tif (is_multicast_ether_addr(dst)) {\n\t\tif (memcmp(bssid, ieee->current_network.bssid,\n\t\t\t   ETH_ALEN))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t\tstruct lib80211_crypt_data **crypt, size_t hdrlen)\n{\n\tstruct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;\n\tu16 fc = le16_to_cpu(hdr->frame_ctl);\n\tint idx = 0;\n\n\tif (skb->len >= hdrlen + 3)\n\t\tidx = skb->data[hdrlen + 3] >> 6;\n\n\t*crypt = ieee->crypt_info.crypt[idx];\n\t \n\tif (*crypt && ((*crypt)->ops == NULL ||\n\t\t      (*crypt)->ops->decrypt_mpdu == NULL))\n\t\t*crypt = NULL;\n\n\tif (!*crypt && (fc & RTLLIB_FCTL_WEP)) {\n\t\t \n\t\tnetdev_dbg(ieee->dev,\n\t\t\t   \"Decryption failed (not set) (SA= %pM)\\n\",\n\t\t\t   hdr->addr2);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t      struct rtllib_rx_stats *rx_stats,\n\t\t      struct lib80211_crypt_data *crypt, size_t hdrlen)\n{\n\tstruct rtllib_hdr_4addr *hdr;\n\tint keyidx = 0;\n\tu16 fc, sc;\n\tu8 frag;\n\n\thdr = (struct rtllib_hdr_4addr *)skb->data;\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\tfrag = WLAN_GET_SEQ_FRAG(sc);\n\n\tif ((!rx_stats->Decrypted))\n\t\tieee->need_sw_enc = 1;\n\telse\n\t\tieee->need_sw_enc = 0;\n\n\tkeyidx = rtllib_rx_frame_decrypt(ieee, skb, crypt);\n\tif ((fc & RTLLIB_FCTL_WEP) && (keyidx < 0)) {\n\t\tnetdev_info(ieee->dev, \"%s: decrypt frame error\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\thdr = (struct rtllib_hdr_4addr *)skb->data;\n\tif ((frag != 0 || (fc & RTLLIB_FCTL_MOREFRAGS))) {\n\t\tint flen;\n\t\tstruct sk_buff *frag_skb = rtllib_frag_cache_get(ieee, hdr);\n\n\t\tnetdev_dbg(ieee->dev, \"Rx Fragment received (%u)\\n\", frag);\n\n\t\tif (!frag_skb) {\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"Rx cannot get skb from fragment cache (morefrag=%d seq=%u frag=%u)\\n\",\n\t\t\t\t   (fc & RTLLIB_FCTL_MOREFRAGS) != 0,\n\t\t\t\t   WLAN_GET_SEQ_SEQ(sc), frag);\n\t\t\treturn -1;\n\t\t}\n\t\tflen = skb->len;\n\t\tif (frag != 0)\n\t\t\tflen -= hdrlen;\n\n\t\tif (frag_skb->tail + flen > frag_skb->end) {\n\t\t\tnetdev_warn(ieee->dev,\n\t\t\t\t    \"%s: host decrypted and reassembled frame did not fit skb\\n\",\n\t\t\t\t    __func__);\n\t\t\trtllib_frag_cache_invalidate(ieee, hdr);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (frag == 0) {\n\t\t\t \n\t\t\tskb_put_data(frag_skb, skb->data, flen);\n\t\t} else {\n\t\t\t \n\t\t\tskb_put_data(frag_skb, skb->data + hdrlen, flen);\n\t\t}\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = NULL;\n\n\t\tif (fc & RTLLIB_FCTL_MOREFRAGS) {\n\t\t\t \n\t\t\treturn -2;\n\t\t}\n\n\t\t \n\t\tskb = frag_skb;\n\t\thdr = (struct rtllib_hdr_4addr *)skb->data;\n\t\trtllib_frag_cache_invalidate(ieee, hdr);\n\t}\n\n\t \n\tif ((fc & RTLLIB_FCTL_WEP) &&\n\t\trtllib_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt)) {\n\t\tnetdev_info(ieee->dev, \"%s: ==>decrypt msdu error\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\thdr = (struct rtllib_hdr_4addr *)skb->data;\n\tif (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep) {\n\t\tif ( \n\t\t    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {\n\t\t\t \n\t\t\tstruct eapol *eap = (struct eapol *)(skb->data +\n\t\t\t\t24);\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"RX: IEEE 802.1X EAPOL frame: %s\\n\",\n\t\t\t\t   eap_get_type(eap->type));\n\t\t} else {\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"encryption configured, but RX frame not encrypted (SA= %pM)\\n\",\n\t\t\t\t   hdr->addr2);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (crypt && !(fc & RTLLIB_FCTL_WEP) &&\n\t    rtllib_is_eapol_frame(ieee, skb, hdrlen)) {\n\t\tstruct eapol *eap = (struct eapol *)(skb->data + 24);\n\n\t\tnetdev_dbg(ieee->dev, \"RX: IEEE 802.1X EAPOL frame: %s\\n\",\n\t\t\t   eap_get_type(eap->type));\n\t}\n\n\tif (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep &&\n\t    !rtllib_is_eapol_frame(ieee, skb, hdrlen)) {\n\t\tnetdev_dbg(ieee->dev,\n\t\t\t   \"dropped unencrypted RX data frame from %pM (drop_unencrypted=1)\\n\",\n\t\t\t   hdr->addr2);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtllib_rx_check_leave_lps(struct rtllib_device *ieee, u8 unicast,\n\t\t\t\t      u8 nr_subframes)\n{\n\tif (unicast) {\n\t\tif (ieee->link_state == MAC80211_LINKED) {\n\t\t\tif (((ieee->link_detect_info.NumRxUnicastOkInPeriod +\n\t\t\t    ieee->link_detect_info.NumTxOkInPeriod) > 8) ||\n\t\t\t    (ieee->link_detect_info.NumRxUnicastOkInPeriod > 2)) {\n\t\t\t\tieee->leisure_ps_leave(ieee->dev);\n\t\t\t}\n\t\t}\n\t}\n\tieee->last_rx_ps_time = jiffies;\n}\n\nstatic void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,\n\t\tstruct rtllib_rx_stats *rx_stats,\n\t\tstruct rtllib_rxb *rxb,\n\t\tu8 *dst,\n\t\tu8 *src)\n{\n\tstruct net_device *dev = ieee->dev;\n\tu16 ethertype;\n\tint i = 0;\n\n\tif (rxb == NULL) {\n\t\tnetdev_info(dev, \"%s: rxb is NULL!!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < rxb->nr_subframes; i++) {\n\t\tstruct sk_buff *sub_skb = rxb->subframes[i];\n\n\t\tif (sub_skb) {\n\t\t\t \n\t\t\tethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];\n\t\t\tif (sub_skb->len >= 8 &&\n\t\t\t\t((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&\n\t\t\t\tethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\n\t\t\t\tmemcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {\n\t\t\t\t \n\t\t\t\tskb_pull(sub_skb, SNAP_SIZE);\n\t\t\t\tether_addr_copy(skb_push(sub_skb, ETH_ALEN),\n\t\t\t\t\t\tsrc);\n\t\t\t\tether_addr_copy(skb_push(sub_skb, ETH_ALEN),\n\t\t\t\t\t\tdst);\n\t\t\t} else {\n\t\t\t\tu16 len;\n\t\t\t\t \n\t\t\t\tlen = sub_skb->len;\n\t\t\t\tmemcpy(skb_push(sub_skb, 2), &len, 2);\n\t\t\t\tether_addr_copy(skb_push(sub_skb, ETH_ALEN),\n\t\t\t\t\t\tsrc);\n\t\t\t\tether_addr_copy(skb_push(sub_skb, ETH_ALEN),\n\t\t\t\t\t\tdst);\n\t\t\t}\n\n\t\t\tieee->stats.rx_packets++;\n\t\t\tieee->stats.rx_bytes += sub_skb->len;\n\n\t\t\tif (is_multicast_ether_addr(dst))\n\t\t\t\tieee->stats.multicast++;\n\n\t\t\t \n\t\t\tmemset(sub_skb->cb, 0, sizeof(sub_skb->cb));\n\t\t\tsub_skb->protocol = eth_type_trans(sub_skb, dev);\n\t\t\tsub_skb->dev = dev;\n\t\t\tsub_skb->dev->stats.rx_packets++;\n\t\t\tsub_skb->dev->stats.rx_bytes += sub_skb->len;\n\t\t\t \n\t\t\tsub_skb->ip_summed = CHECKSUM_NONE;\n\t\t\tnetif_rx(sub_skb);\n\t\t}\n\t}\n\tkfree(rxb);\n}\n\nstatic int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t struct rtllib_rx_stats *rx_stats)\n{\n\tstruct net_device *dev = ieee->dev;\n\tstruct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;\n\tstruct lib80211_crypt_data *crypt = NULL;\n\tstruct rtllib_rxb *rxb = NULL;\n\tstruct rx_ts_record *pTS = NULL;\n\tu16 fc, sc, SeqNum = 0;\n\tu8 type, stype, multicast = 0, unicast = 0, nr_subframes = 0, TID = 0;\n\tu8 dst[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n\tu8 bssid[ETH_ALEN] = {0};\n\n\tsize_t hdrlen = 0;\n\tbool bToOtherSTA = false;\n\tint ret = 0, i = 0;\n\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tstype = WLAN_FC_GET_STYPE(fc);\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\n\t \n\tmulticast = is_multicast_ether_addr(hdr->addr1);\n\tunicast = !multicast;\n\tif (unicast && !ether_addr_equal(dev->dev_addr, hdr->addr1)) {\n\t\tif (ieee->net_promiscuous_md)\n\t\t\tbToOtherSTA = true;\n\t\telse\n\t\t\tgoto rx_dropped;\n\t}\n\n\t \n\thdrlen = rtllib_rx_get_hdrlen(ieee, skb, rx_stats);\n\tif (skb->len < hdrlen) {\n\t\tnetdev_info(dev,\n\t\t\t    \"%s():ERR!!! skb->len is smaller than hdrlen\\n\",\n\t\t\t    __func__);\n\t\tgoto rx_dropped;\n\t}\n\n\t \n\tret = rtllib_rx_check_duplicate(ieee, skb, multicast);\n\tif (ret < 0)\n\t\tgoto rx_dropped;\n\n\t \n\tif (type == RTLLIB_FTYPE_CTL)\n\t\tgoto rx_dropped;\n\n\t \n\tif (type == RTLLIB_FTYPE_MGMT) {\n\t\tif (bToOtherSTA)\n\t\t\tgoto rx_dropped;\n\t\tif (rtllib_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))\n\t\t\tgoto rx_dropped;\n\t\telse\n\t\t\tgoto rx_exit;\n\t}\n\n\t \n\n\t \n\tif (!bToOtherSTA) {\n\t\tieee->link_detect_info.NumRecvDataInPeriod++;\n\t\tieee->link_detect_info.NumRxOkInPeriod++;\n\t}\n\n\t \n\trtllib_rx_extract_addr(ieee, hdr, dst, src, bssid);\n\n\t \n\tret = rtllib_rx_data_filter(ieee, fc, dst, src, bssid, hdr->addr2);\n\tif (ret < 0)\n\t\tgoto rx_dropped;\n\n\tif (skb->len == hdrlen)\n\t\tgoto rx_dropped;\n\n\t \n\tif ((ieee->iw_mode == IW_MODE_INFRA)  &&\n\t    (ieee->sta_sleep == LPS_IS_SLEEP) &&\n\t    (ieee->polling) && (!bToOtherSTA)) {\n\t\tif (WLAN_FC_MORE_DATA(fc)) {\n\t\t\t \n\t\t\trtllib_sta_ps_send_pspoll_frame(ieee);\n\t\t} else {\n\t\t\tieee->polling =  false;\n\t\t}\n\t}\n\n\t \n\tret = rtllib_rx_get_crypt(ieee, skb, &crypt, hdrlen);\n\tif (ret == -1)\n\t\tgoto rx_dropped;\n\n\t \n\tret = rtllib_rx_decrypt(ieee, skb, rx_stats, crypt, hdrlen);\n\tif (ret == -1)\n\t\tgoto rx_dropped;\n\telse if (ret == -2)\n\t\tgoto rx_exit;\n\n\t \n\thdr = (struct rtllib_hdr_4addr *)skb->data;\n\tif (ieee->current_network.qos_data.active && IsQoSDataFrame(skb->data)\n\t\t&& !is_multicast_ether_addr(hdr->addr1)\n\t\t&& (!bToOtherSTA)) {\n\t\tTID = Frame_QoSTID(skb->data);\n\t\tSeqNum = WLAN_GET_SEQ_SEQ(sc);\n\t\tGetTs(ieee, (struct ts_common_info **)&pTS, hdr->addr2, TID,\n\t\t      RX_DIR, true);\n\t\tif (TID != 0 && TID != 3)\n\t\t\tieee->bis_any_nonbepkts = true;\n\t}\n\n\t \n\t \n\trxb = kmalloc(sizeof(struct rtllib_rxb), GFP_ATOMIC);\n\tif (!rxb)\n\t\tgoto rx_dropped;\n\n\t \n\t \n\tif (parse_subframe(ieee, skb, rx_stats, rxb, src, dst) == 0) {\n\t\t \n\t\tfor (i = 0; i < rxb->nr_subframes; i++)\n\t\t\tdev_kfree_skb(rxb->subframes[i]);\n\t\tkfree(rxb);\n\t\trxb = NULL;\n\t\tgoto rx_dropped;\n\t}\n\n\t \n\n\t \n\tif (!bToOtherSTA) {\n\t\tif (ieee->bIsAggregateFrame)\n\t\t\tnr_subframes = rxb->nr_subframes;\n\t\telse\n\t\t\tnr_subframes = 1;\n\t\tif (unicast)\n\t\t\tieee->link_detect_info.NumRxUnicastOkInPeriod += nr_subframes;\n\t\trtllib_rx_check_leave_lps(ieee, unicast, nr_subframes);\n\t}\n\n\t \n\tif (!ieee->ht_info->cur_rx_reorder_enable || pTS == NULL || bToOtherSTA)\n\t\trtllib_rx_indicate_pkt_legacy(ieee, rx_stats, rxb, dst, src);\n\telse\n\t\tRxReorderIndicatePacket(ieee, rxb, pTS, SeqNum);\n\n\tdev_kfree_skb(skb);\n\n rx_exit:\n\treturn 1;\n\n rx_dropped:\n\tieee->stats.rx_dropped++;\n\n\t \n\treturn 0;\n}\n\nstatic int rtllib_rx_Monitor(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t struct rtllib_rx_stats *rx_stats)\n{\n\tstruct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;\n\tu16 fc = le16_to_cpu(hdr->frame_ctl);\n\tsize_t hdrlen = rtllib_get_hdrlen(fc);\n\n\tif (skb->len < hdrlen) {\n\t\tnetdev_info(ieee->dev,\n\t\t\t    \"%s():ERR!!! skb->len is smaller than hdrlen\\n\",\n\t\t\t    __func__);\n\t\treturn 0;\n\t}\n\n\tif (HTCCheck(ieee, skb->data)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(ieee->dev, \"%s: Find HTCControl!\\n\",\n\t\t\t\t    __func__);\n\t\thdrlen += 4;\n\t}\n\n\tieee->stats.rx_packets++;\n\tieee->stats.rx_bytes += skb->len;\n\trtllib_monitor_rx(ieee, skb, rx_stats, hdrlen);\n\n\treturn 1;\n}\n\n \nint rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,\n\t\t struct rtllib_rx_stats *rx_stats)\n{\n\tint ret = 0;\n\n\tif (!ieee || !skb || !rx_stats) {\n\t\tpr_info(\"%s: Input parameters NULL!\\n\", __func__);\n\t\tgoto rx_dropped;\n\t}\n\tif (skb->len < 10) {\n\t\tnetdev_info(ieee->dev, \"%s: SKB length < 10\\n\", __func__);\n\t\tgoto rx_dropped;\n\t}\n\n\tswitch (ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\tcase IW_MODE_INFRA:\n\t\tret = rtllib_rx_InfraAdhoc(ieee, skb, rx_stats);\n\t\tbreak;\n\tcase IW_MODE_MONITOR:\n\t\tret = rtllib_rx_Monitor(ieee, skb, rx_stats);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_info(ieee->dev, \"%s: ERR iw mode!!!\\n\", __func__);\n\t\tbreak;\n\t}\n\n\treturn ret;\n\n rx_dropped:\n\tif (ieee)\n\t\tieee->stats.rx_dropped++;\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_rx);\n\nstatic u8 qos_oui[QOS_OUI_LEN] = { 0x00, 0x50, 0xF2 };\n\n \nstatic int rtllib_verify_qos_info(struct rtllib_qos_information_element\n\t\t\t\t     *info_element, int sub_type)\n{\n\tif (info_element->elementID != QOS_ELEMENT_ID)\n\t\treturn -1;\n\tif (info_element->qui_subtype != sub_type)\n\t\treturn -1;\n\tif (memcmp(info_element->qui, qos_oui, QOS_OUI_LEN))\n\t\treturn -1;\n\tif (info_element->qui_type != QOS_OUI_TYPE)\n\t\treturn -1;\n\tif (info_element->version != QOS_VERSION_1)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int rtllib_read_qos_param_element(\n\t\t\tstruct rtllib_qos_parameter_info *element_param,\n\t\t\tstruct rtllib_info_element *info_element)\n{\n\tsize_t size = sizeof(*element_param);\n\n\tif (!element_param || !info_element || info_element->len != size - 2)\n\t\treturn -1;\n\n\tmemcpy(element_param, info_element, size);\n\treturn rtllib_verify_qos_info(&element_param->info_element,\n\t\t\t\t      QOS_OUI_PARAM_SUB_TYPE);\n}\n\n \nstatic int rtllib_read_qos_info_element(\n\t\t\tstruct rtllib_qos_information_element *element_info,\n\t\t\tstruct rtllib_info_element *info_element)\n{\n\tsize_t size = sizeof(*element_info);\n\n\tif (!element_info || !info_element || info_element->len != size - 2)\n\t\treturn -1;\n\n\tmemcpy(element_info, info_element, size);\n\treturn rtllib_verify_qos_info(element_info, QOS_OUI_INFO_SUB_TYPE);\n}\n\n \nstatic int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info *param_elm,\n\t\t\t\t\t       struct rtllib_qos_data *qos_data)\n{\n\tstruct rtllib_qos_ac_parameter *ac_params;\n\tstruct rtllib_qos_parameters *qos_param = &(qos_data->parameters);\n\tint i;\n\tu8 aci;\n\tu8 acm;\n\n\tqos_data->wmm_acm = 0;\n\tfor (i = 0; i < QOS_QUEUE_NUM; i++) {\n\t\tac_params = &(param_elm->ac_params_record[i]);\n\n\t\taci = (ac_params->aci_aifsn & 0x60) >> 5;\n\t\tacm = (ac_params->aci_aifsn & 0x10) >> 4;\n\n\t\tif (aci >= QOS_QUEUE_NUM)\n\t\t\tcontinue;\n\t\tswitch (aci) {\n\t\tcase 1:\n\t\t\t \n\t\t\tif (acm)\n\t\t\t\tqos_data->wmm_acm |= (0x01 << 0) | (0x01 << 3);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tif (acm)\n\t\t\t\tqos_data->wmm_acm |= (0x01 << 4) | (0x01 << 5);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t \n\t\t\tif (acm)\n\t\t\t\tqos_data->wmm_acm |= (0x01 << 6) | (0x01 << 7);\n\t\t\tbreak;\n\t\tcase 0:\n\t\tdefault:\n\t\t\t \n\t\t\tif (acm)\n\t\t\t\tqos_data->wmm_acm |= (0x01 << 1) | (0x01 << 2);\n\t\t\tbreak;\n\t\t}\n\n\t\tqos_param->aifs[aci] = (ac_params->aci_aifsn) & 0x0f;\n\n\t\t \n\t\tqos_param->aifs[aci] = max_t(u8, qos_param->aifs[aci], 2);\n\n\t\tqos_param->cw_min[aci] = cpu_to_le16(ac_params->ecw_min_max &\n\t\t\t\t\t\t     0x0F);\n\n\t\tqos_param->cw_max[aci] = cpu_to_le16((ac_params->ecw_min_max &\n\t\t\t\t\t\t      0xF0) >> 4);\n\n\t\tqos_param->flag[aci] =\n\t\t    (ac_params->aci_aifsn & 0x10) ? 0x01 : 0x00;\n\t\tqos_param->tx_op_limit[aci] = ac_params->tx_op_limit;\n\t}\n\treturn 0;\n}\n\n \nstatic int rtllib_parse_qos_info_param_IE(struct rtllib_device *ieee,\n\t\t\t\t\t  struct rtllib_info_element\n\t\t\t\t\t     *info_element,\n\t\t\t\t\t  struct rtllib_network *network)\n{\n\tint rc = 0;\n\tstruct rtllib_qos_information_element qos_info_element;\n\n\trc = rtllib_read_qos_info_element(&qos_info_element, info_element);\n\n\tif (rc == 0) {\n\t\tnetwork->qos_data.param_count = qos_info_element.ac_info & 0x0F;\n\t\tnetwork->flags |= NETWORK_HAS_QOS_INFORMATION;\n\t} else {\n\t\tstruct rtllib_qos_parameter_info param_element;\n\n\t\trc = rtllib_read_qos_param_element(&param_element,\n\t\t\t\t\t\t      info_element);\n\t\tif (rc == 0) {\n\t\t\trtllib_qos_convert_ac_to_parameters(&param_element,\n\t\t\t\t\t\t\t       &(network->qos_data));\n\t\t\tnetwork->flags |= NETWORK_HAS_QOS_PARAMETERS;\n\t\t\tnetwork->qos_data.param_count =\n\t\t\t    param_element.info_element.ac_info & 0x0F;\n\t\t}\n\t}\n\n\tif (rc == 0) {\n\t\tnetdev_dbg(ieee->dev, \"QoS is supported\\n\");\n\t\tnetwork->qos_data.supported = 1;\n\t}\n\treturn rc;\n}\n\nstatic const char *get_info_element_string(u16 id)\n{\n\tswitch (id) {\n\tcase MFIE_TYPE_SSID:\n\t\treturn \"SSID\";\n\tcase MFIE_TYPE_RATES:\n\t\treturn \"RATES\";\n\tcase MFIE_TYPE_FH_SET:\n\t\treturn \"FH_SET\";\n\tcase MFIE_TYPE_DS_SET:\n\t\treturn \"DS_SET\";\n\tcase MFIE_TYPE_CF_SET:\n\t\treturn \"CF_SET\";\n\tcase MFIE_TYPE_TIM:\n\t\treturn \"TIM\";\n\tcase MFIE_TYPE_IBSS_SET:\n\t\treturn \"IBSS_SET\";\n\tcase MFIE_TYPE_COUNTRY:\n\t\treturn \"COUNTRY\";\n\tcase MFIE_TYPE_HOP_PARAMS:\n\t\treturn \"HOP_PARAMS\";\n\tcase MFIE_TYPE_HOP_TABLE:\n\t\treturn \"HOP_TABLE\";\n\tcase MFIE_TYPE_REQUEST:\n\t\treturn \"REQUEST\";\n\tcase MFIE_TYPE_CHALLENGE:\n\t\treturn \"CHALLENGE\";\n\tcase MFIE_TYPE_POWER_CONSTRAINT:\n\t\treturn \"POWER_CONSTRAINT\";\n\tcase MFIE_TYPE_POWER_CAPABILITY:\n\t\treturn \"POWER_CAPABILITY\";\n\tcase MFIE_TYPE_TPC_REQUEST:\n\t\treturn \"TPC_REQUEST\";\n\tcase MFIE_TYPE_TPC_REPORT:\n\t\treturn \"TPC_REPORT\";\n\tcase MFIE_TYPE_SUPP_CHANNELS:\n\t\treturn \"SUPP_CHANNELS\";\n\tcase MFIE_TYPE_CSA:\n\t\treturn \"CSA\";\n\tcase MFIE_TYPE_MEASURE_REQUEST:\n\t\treturn \"MEASURE_REQUEST\";\n\tcase MFIE_TYPE_MEASURE_REPORT:\n\t\treturn \"MEASURE_REPORT\";\n\tcase MFIE_TYPE_QUIET:\n\t\treturn \"QUIET\";\n\tcase MFIE_TYPE_IBSS_DFS:\n\t\treturn \"IBSS_DFS\";\n\tcase MFIE_TYPE_RSN:\n\t\treturn \"RSN\";\n\tcase MFIE_TYPE_RATES_EX:\n\t\treturn \"RATES_EX\";\n\tcase MFIE_TYPE_GENERIC:\n\t\treturn \"GENERIC\";\n\tcase MFIE_TYPE_QOS_PARAMETER:\n\t\treturn \"QOS_PARAMETER\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic inline void rtllib_extract_country_ie(\n\tstruct rtllib_device *ieee,\n\tstruct rtllib_info_element *info_element,\n\tstruct rtllib_network *network,\n\tu8 *addr2)\n{\n\tif (IS_DOT11D_ENABLE(ieee)) {\n\t\tif (info_element->len != 0) {\n\t\t\tmemcpy(network->CountryIeBuf, info_element->data,\n\t\t\t       info_element->len);\n\t\t\tnetwork->CountryIeLen = info_element->len;\n\n\t\t\tif (!IS_COUNTRY_IE_VALID(ieee)) {\n\t\t\t\tif (rtllib_act_scanning(ieee, false) &&\n\t\t\t\t    ieee->FirstIe_InScan)\n\t\t\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t\t\t    \"Received beacon CountryIE, SSID: <%s>\\n\",\n\t\t\t\t\t\t    network->ssid);\n\t\t\t\tdot11d_update_country(ieee, addr2,\n\t\t\t\t\t\t       info_element->len,\n\t\t\t\t\t\t       info_element->data);\n\t\t\t}\n\t\t}\n\n\t\tif (IS_EQUAL_CIE_SRC(ieee, addr2))\n\t\t\tUPDATE_CIE_WATCHDOG(ieee);\n\t}\n}\n\nstatic void rtllib_parse_mife_generic(struct rtllib_device *ieee,\n\t\t\t\t      struct rtllib_info_element *info_element,\n\t\t\t\t      struct rtllib_network *network,\n\t\t\t\t      u16 *tmp_htcap_len,\n\t\t\t\t      u16 *tmp_htinfo_len)\n{\n\tu16 ht_realtek_agg_len = 0;\n\tu8  ht_realtek_agg_buf[MAX_IE_LEN];\n\n\tif (!rtllib_parse_qos_info_param_IE(ieee, info_element, network))\n\t\treturn;\n\tif (info_element->len >= 4 &&\n\t    info_element->data[0] == 0x00 &&\n\t    info_element->data[1] == 0x50 &&\n\t    info_element->data[2] == 0xf2 &&\n\t    info_element->data[3] == 0x01) {\n\t\tnetwork->wpa_ie_len = min(info_element->len + 2,\n\t\t\t\t\t  MAX_WPA_IE_LEN);\n\t\tmemcpy(network->wpa_ie, info_element, network->wpa_ie_len);\n\t\treturn;\n\t}\n\tif (info_element->len == 7 &&\n\t    info_element->data[0] == 0x00 &&\n\t    info_element->data[1] == 0xe0 &&\n\t    info_element->data[2] == 0x4c &&\n\t    info_element->data[3] == 0x01 &&\n\t    info_element->data[4] == 0x02)\n\t\tnetwork->Turbo_Enable = 1;\n\n\tif (*tmp_htcap_len == 0) {\n\t\tif (info_element->len >= 4 &&\n\t\t    info_element->data[0] == 0x00 &&\n\t\t    info_element->data[1] == 0x90 &&\n\t\t    info_element->data[2] == 0x4c &&\n\t\t    info_element->data[3] == 0x033) {\n\t\t\t*tmp_htcap_len = min_t(u8, info_element->len,\n\t\t\t\t\t       MAX_IE_LEN);\n\t\t\tif (*tmp_htcap_len != 0) {\n\t\t\t\tnetwork->bssht.bd_ht_spec_ver = HT_SPEC_VER_EWC;\n\t\t\t\tnetwork->bssht.bd_ht_cap_len = min_t(u16, *tmp_htcap_len,\n\t\t\t\t\t\t\t\t  sizeof(network->bssht.bd_ht_cap_buf));\n\t\t\t\tmemcpy(network->bssht.bd_ht_cap_buf,\n\t\t\t\t       info_element->data,\n\t\t\t\t       network->bssht.bd_ht_cap_len);\n\t\t\t}\n\t\t}\n\t\tif (*tmp_htcap_len != 0) {\n\t\t\tnetwork->bssht.bd_support_ht = true;\n\t\t\tnetwork->bssht.bd_ht_1r = ((((struct ht_capab_ele *)(network->bssht.bd_ht_cap_buf))->MCS[1]) == 0);\n\t\t} else {\n\t\t\tnetwork->bssht.bd_support_ht = false;\n\t\t\tnetwork->bssht.bd_ht_1r = false;\n\t\t}\n\t}\n\n\tif (*tmp_htinfo_len == 0) {\n\t\tif (info_element->len >= 4 &&\n\t\t    info_element->data[0] == 0x00 &&\n\t\t    info_element->data[1] == 0x90 &&\n\t\t    info_element->data[2] == 0x4c &&\n\t\t    info_element->data[3] == 0x034) {\n\t\t\t*tmp_htinfo_len = min_t(u8, info_element->len,\n\t\t\t\t\t\tMAX_IE_LEN);\n\t\t\tif (*tmp_htinfo_len != 0) {\n\t\t\t\tnetwork->bssht.bd_ht_spec_ver = HT_SPEC_VER_EWC;\n\t\t\t\tnetwork->bssht.bd_ht_info_len = min_t(u16, *tmp_htinfo_len,\n\t\t\t\t\t\t\t\t      sizeof(network->bssht.bd_ht_info_buf));\n\t\t\t\tmemcpy(network->bssht.bd_ht_info_buf,\n\t\t\t\t       info_element->data,\n\t\t\t\t       network->bssht.bd_ht_info_len);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (network->bssht.bd_support_ht) {\n\t\tif (info_element->len >= 4 &&\n\t\t    info_element->data[0] == 0x00 &&\n\t\t    info_element->data[1] == 0xe0 &&\n\t\t    info_element->data[2] == 0x4c &&\n\t\t    info_element->data[3] == 0x02) {\n\t\t\tht_realtek_agg_len = min_t(u8, info_element->len,\n\t\t\t\t\t\t   MAX_IE_LEN);\n\t\t\tmemcpy(ht_realtek_agg_buf, info_element->data,\n\t\t\t       info_element->len);\n\t\t}\n\t\tif (ht_realtek_agg_len >= 5) {\n\t\t\tnetwork->realtek_cap_exit = true;\n\t\t\tnetwork->bssht.bd_rt2rt_aggregation = true;\n\n\t\t\tif ((ht_realtek_agg_buf[4] == 1) &&\n\t\t\t    (ht_realtek_agg_buf[5] & 0x02))\n\t\t\t\tnetwork->bssht.bd_rt2rt_long_slot_time = true;\n\n\t\t\tif ((ht_realtek_agg_buf[4] == 1) &&\n\t\t\t    (ht_realtek_agg_buf[5] & RT_HT_CAP_USE_92SE))\n\t\t\t\tnetwork->bssht.rt2rt_ht_mode |= RT_HT_CAP_USE_92SE;\n\t\t}\n\t}\n\tif (ht_realtek_agg_len >= 5) {\n\t\tif ((ht_realtek_agg_buf[5] & RT_HT_CAP_USE_SOFTAP))\n\t\t\tnetwork->bssht.rt2rt_ht_mode |= RT_HT_CAP_USE_SOFTAP;\n\t}\n\n\tif ((info_element->len >= 3 &&\n\t     info_element->data[0] == 0x00 &&\n\t     info_element->data[1] == 0x05 &&\n\t     info_element->data[2] == 0xb5) ||\n\t     (info_element->len >= 3 &&\n\t     info_element->data[0] == 0x00 &&\n\t     info_element->data[1] == 0x0a &&\n\t     info_element->data[2] == 0xf7) ||\n\t     (info_element->len >= 3 &&\n\t     info_element->data[0] == 0x00 &&\n\t     info_element->data[1] == 0x10 &&\n\t     info_element->data[2] == 0x18)) {\n\t\tnetwork->broadcom_cap_exist = true;\n\t}\n\tif (info_element->len >= 3 &&\n\t    info_element->data[0] == 0x00 &&\n\t    info_element->data[1] == 0x0c &&\n\t    info_element->data[2] == 0x43)\n\t\tnetwork->ralink_cap_exist = true;\n\tif ((info_element->len >= 3 &&\n\t     info_element->data[0] == 0x00 &&\n\t     info_element->data[1] == 0x03 &&\n\t     info_element->data[2] == 0x7f) ||\n\t     (info_element->len >= 3 &&\n\t     info_element->data[0] == 0x00 &&\n\t     info_element->data[1] == 0x13 &&\n\t     info_element->data[2] == 0x74))\n\t\tnetwork->atheros_cap_exist = true;\n\n\tif ((info_element->len >= 3 &&\n\t     info_element->data[0] == 0x00 &&\n\t     info_element->data[1] == 0x50 &&\n\t     info_element->data[2] == 0x43))\n\t\tnetwork->marvell_cap_exist = true;\n\tif (info_element->len >= 3 &&\n\t    info_element->data[0] == 0x00 &&\n\t    info_element->data[1] == 0x40 &&\n\t    info_element->data[2] == 0x96)\n\t\tnetwork->cisco_cap_exist = true;\n\n\tif (info_element->len >= 3 &&\n\t    info_element->data[0] == 0x00 &&\n\t    info_element->data[1] == 0x0a &&\n\t    info_element->data[2] == 0xf5)\n\t\tnetwork->airgo_cap_exist = true;\n\n\tif (info_element->len > 4 &&\n\t    info_element->data[0] == 0x00 &&\n\t    info_element->data[1] == 0x40 &&\n\t    info_element->data[2] == 0x96 &&\n\t    info_element->data[3] == 0x01) {\n\t\tif (info_element->len == 6) {\n\t\t\tmemcpy(network->CcxRmState, &info_element->data[4], 2);\n\t\t\tif (network->CcxRmState[0] != 0)\n\t\t\t\tnetwork->bCcxRmEnable = true;\n\t\t\telse\n\t\t\t\tnetwork->bCcxRmEnable = false;\n\t\t\tnetwork->MBssidMask = network->CcxRmState[1] & 0x07;\n\t\t\tif (network->MBssidMask != 0) {\n\t\t\t\tnetwork->bMBssidValid = true;\n\t\t\t\tnetwork->MBssidMask = 0xff <<\n\t\t\t\t\t\t      (network->MBssidMask);\n\t\t\t\tether_addr_copy(network->MBssid,\n\t\t\t\t\t\tnetwork->bssid);\n\t\t\t\tnetwork->MBssid[5] &= network->MBssidMask;\n\t\t\t} else {\n\t\t\t\tnetwork->bMBssidValid = false;\n\t\t\t}\n\t\t} else {\n\t\t\tnetwork->bCcxRmEnable = false;\n\t\t}\n\t}\n\tif (info_element->len > 4  &&\n\t    info_element->data[0] == 0x00 &&\n\t    info_element->data[1] == 0x40 &&\n\t    info_element->data[2] == 0x96 &&\n\t    info_element->data[3] == 0x03) {\n\t\tif (info_element->len == 5) {\n\t\t\tnetwork->bWithCcxVerNum = true;\n\t\t\tnetwork->BssCcxVerNumber = info_element->data[4];\n\t\t} else {\n\t\t\tnetwork->bWithCcxVerNum = false;\n\t\t\tnetwork->BssCcxVerNumber = 0;\n\t\t}\n\t}\n\tif (info_element->len > 4  &&\n\t    info_element->data[0] == 0x00 &&\n\t    info_element->data[1] == 0x50 &&\n\t    info_element->data[2] == 0xf2 &&\n\t    info_element->data[3] == 0x04) {\n\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_WZC: %d bytes\\n\",\n\t\t\t   info_element->len);\n\t\tnetwork->wzc_ie_len = min(info_element->len + 2, MAX_WZC_IE_LEN);\n\t\tmemcpy(network->wzc_ie, info_element, network->wzc_ie_len);\n\t}\n}\n\nstatic void rtllib_parse_mfie_ht_cap(struct rtllib_info_element *info_element,\n\t\t\t\t     struct rtllib_network *network,\n\t\t\t\t     u16 *tmp_htcap_len)\n{\n\tstruct bss_ht *ht = &network->bssht;\n\n\t*tmp_htcap_len = min_t(u8, info_element->len, MAX_IE_LEN);\n\tif (*tmp_htcap_len != 0) {\n\t\tht->bd_ht_spec_ver = HT_SPEC_VER_EWC;\n\t\tht->bd_ht_cap_len = min_t(u16, *tmp_htcap_len,\n\t\t\t\t       sizeof(ht->bd_ht_cap_buf));\n\t\tmemcpy(ht->bd_ht_cap_buf, info_element->data, ht->bd_ht_cap_len);\n\n\t\tht->bd_support_ht = true;\n\t\tht->bd_ht_1r = ((((struct ht_capab_ele *)\n\t\t\t\tht->bd_ht_cap_buf))->MCS[1]) == 0;\n\n\t\tht->bd_bandwidth = (enum ht_channel_width)\n\t\t\t\t\t     (((struct ht_capab_ele *)\n\t\t\t\t\t     (ht->bd_ht_cap_buf))->ChlWidth);\n\t} else {\n\t\tht->bd_support_ht = false;\n\t\tht->bd_ht_1r = false;\n\t\tht->bd_bandwidth = HT_CHANNEL_WIDTH_20;\n\t}\n}\n\nint rtllib_parse_info_param(struct rtllib_device *ieee,\n\t\tstruct rtllib_info_element *info_element,\n\t\tu16 length,\n\t\tstruct rtllib_network *network,\n\t\tstruct rtllib_rx_stats *stats)\n{\n\tu8 i;\n\tshort offset;\n\tu16\ttmp_htcap_len = 0;\n\tu16\ttmp_htinfo_len = 0;\n\tchar rates_str[64];\n\tchar *p;\n\n\twhile (length >= sizeof(*info_element)) {\n\t\tif (sizeof(*info_element) + info_element->len > length) {\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"Info elem: parse failed: info_element->len + 2 > left : info_element->len+2=%zd left=%d, id=%d.\\n\",\n\t\t\t\t   info_element->len + sizeof(*info_element),\n\t\t\t\t   length, info_element->id);\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (info_element->id) {\n\t\tcase MFIE_TYPE_SSID:\n\t\t\tif (rtllib_is_empty_essid(info_element->data,\n\t\t\t\t\t\t     info_element->len)) {\n\t\t\t\tnetwork->flags |= NETWORK_EMPTY_ESSID;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnetwork->ssid_len = min(info_element->len,\n\t\t\t\t\t\t(u8)IW_ESSID_MAX_SIZE);\n\t\t\tmemcpy(network->ssid, info_element->data,\n\t\t\t       network->ssid_len);\n\t\t\tif (network->ssid_len < IW_ESSID_MAX_SIZE)\n\t\t\t\tmemset(network->ssid + network->ssid_len, 0,\n\t\t\t\t       IW_ESSID_MAX_SIZE - network->ssid_len);\n\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_SSID: '%s' len=%d.\\n\",\n\t\t\t\t   network->ssid, network->ssid_len);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_RATES:\n\t\t\tp = rates_str;\n\t\t\tnetwork->rates_len = min(info_element->len,\n\t\t\t\t\t\t MAX_RATES_LENGTH);\n\t\t\tfor (i = 0; i < network->rates_len; i++) {\n\t\t\t\tnetwork->rates[i] = info_element->data[i];\n\t\t\t\tp += scnprintf(p, sizeof(rates_str) -\n\t\t\t\t\t      (p - rates_str), \"%02X \",\n\t\t\t\t\t      network->rates[i]);\n\t\t\t\tif (rtllib_is_ofdm_rate\n\t\t\t\t    (info_element->data[i])) {\n\t\t\t\t\tnetwork->flags |= NETWORK_HAS_OFDM;\n\t\t\t\t\tif (info_element->data[i] &\n\t\t\t\t\t    RTLLIB_BASIC_RATE_MASK)\n\t\t\t\t\t\tnetwork->flags &=\n\t\t\t\t\t\t    ~NETWORK_HAS_CCK;\n\t\t\t\t}\n\n\t\t\t\tif (rtllib_is_cck_rate\n\t\t\t\t    (info_element->data[i])) {\n\t\t\t\t\tnetwork->flags |= NETWORK_HAS_CCK;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_RATES: '%s' (%d)\\n\",\n\t\t\t\t   rates_str, network->rates_len);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_RATES_EX:\n\t\t\tp = rates_str;\n\t\t\tnetwork->rates_ex_len = min(info_element->len,\n\t\t\t\t\t\t    MAX_RATES_EX_LENGTH);\n\t\t\tfor (i = 0; i < network->rates_ex_len; i++) {\n\t\t\t\tnetwork->rates_ex[i] = info_element->data[i];\n\t\t\t\tp += scnprintf(p, sizeof(rates_str) -\n\t\t\t\t\t      (p - rates_str), \"%02X \",\n\t\t\t\t\t      network->rates_ex[i]);\n\t\t\t\tif (rtllib_is_ofdm_rate\n\t\t\t\t    (info_element->data[i])) {\n\t\t\t\t\tnetwork->flags |= NETWORK_HAS_OFDM;\n\t\t\t\t\tif (info_element->data[i] &\n\t\t\t\t\t    RTLLIB_BASIC_RATE_MASK)\n\t\t\t\t\t\tnetwork->flags &=\n\t\t\t\t\t\t    ~NETWORK_HAS_CCK;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_RATES_EX: '%s' (%d)\\n\",\n\t\t\t\t   rates_str, network->rates_ex_len);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_DS_SET:\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_DS_SET: %d\\n\",\n\t\t\t\t   info_element->data[0]);\n\t\t\tnetwork->channel = info_element->data[0];\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_FH_SET:\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_FH_SET: ignored\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_CF_SET:\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_CF_SET: ignored\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_TIM:\n\t\t\tif (info_element->len < 4)\n\t\t\t\tbreak;\n\n\t\t\tnetwork->tim.tim_count = info_element->data[0];\n\t\t\tnetwork->tim.tim_period = info_element->data[1];\n\n\t\t\tnetwork->dtim_period = info_element->data[1];\n\t\t\tif (ieee->link_state != MAC80211_LINKED)\n\t\t\t\tbreak;\n\t\t\tnetwork->last_dtim_sta_time = jiffies;\n\n\t\t\tnetwork->dtim_data = RTLLIB_DTIM_VALID;\n\n\t\t\tif (info_element->data[2] & 1)\n\t\t\t\tnetwork->dtim_data |= RTLLIB_DTIM_MBCAST;\n\n\t\t\toffset = (info_element->data[2] >> 1) * 2;\n\n\t\t\tif (ieee->assoc_id < 8 * offset ||\n\t\t\t    ieee->assoc_id > 8 * (offset + info_element->len - 3))\n\t\t\t\tbreak;\n\n\t\t\toffset = (ieee->assoc_id / 8) - offset;\n\t\t\tif (info_element->data[3 + offset] &\n\t\t\t   (1 << (ieee->assoc_id % 8)))\n\t\t\t\tnetwork->dtim_data |= RTLLIB_DTIM_UCAST;\n\n\t\t\tnetwork->listen_interval = network->dtim_period;\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_ERP:\n\t\t\tnetwork->erp_value = info_element->data[0];\n\t\t\tnetwork->flags |= NETWORK_HAS_ERP_VALUE;\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_ERP_SET: %d\\n\",\n\t\t\t\t   network->erp_value);\n\t\t\tbreak;\n\t\tcase MFIE_TYPE_IBSS_SET:\n\t\t\tnetwork->atim_window = info_element->data[0];\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_IBSS_SET: %d\\n\",\n\t\t\t\t   network->atim_window);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_CHALLENGE:\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_CHALLENGE: ignored\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_GENERIC:\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_GENERIC: %d bytes\\n\",\n\t\t\t\t   info_element->len);\n\n\t\t\trtllib_parse_mife_generic(ieee, info_element, network,\n\t\t\t\t\t\t  &tmp_htcap_len,\n\t\t\t\t\t\t  &tmp_htinfo_len);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_RSN:\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_RSN: %d bytes\\n\",\n\t\t\t\t   info_element->len);\n\t\t\tnetwork->rsn_ie_len = min(info_element->len + 2,\n\t\t\t\t\t\t  MAX_WPA_IE_LEN);\n\t\t\tmemcpy(network->rsn_ie, info_element,\n\t\t\t       network->rsn_ie_len);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_HT_CAP:\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_HT_CAP: %d bytes\\n\",\n\t\t\t\t   info_element->len);\n\n\t\t\trtllib_parse_mfie_ht_cap(info_element, network,\n\t\t\t\t\t\t &tmp_htcap_len);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_HT_INFO:\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_HT_INFO: %d bytes\\n\",\n\t\t\t\t   info_element->len);\n\t\t\ttmp_htinfo_len = min_t(u8, info_element->len,\n\t\t\t\t\t       MAX_IE_LEN);\n\t\t\tif (tmp_htinfo_len) {\n\t\t\t\tnetwork->bssht.bd_ht_spec_ver = HT_SPEC_VER_IEEE;\n\t\t\t\tnetwork->bssht.bd_ht_info_len = tmp_htinfo_len >\n\t\t\t\t\tsizeof(network->bssht.bd_ht_info_buf) ?\n\t\t\t\t\tsizeof(network->bssht.bd_ht_info_buf) :\n\t\t\t\t\ttmp_htinfo_len;\n\t\t\t\tmemcpy(network->bssht.bd_ht_info_buf,\n\t\t\t\t       info_element->data,\n\t\t\t\t       network->bssht.bd_ht_info_len);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_AIRONET:\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_AIRONET: %d bytes\\n\",\n\t\t\t\t   info_element->len);\n\t\t\tif (info_element->len > IE_CISCO_FLAG_POSITION) {\n\t\t\t\tnetwork->bWithAironetIE = true;\n\n\t\t\t\tif ((info_element->data[IE_CISCO_FLAG_POSITION]\n\t\t\t\t     & SUPPORT_CKIP_MIC) ||\n\t\t\t\t     (info_element->data[IE_CISCO_FLAG_POSITION]\n\t\t\t\t     & SUPPORT_CKIP_PK))\n\t\t\t\t\tnetwork->bCkipSupported = true;\n\t\t\t\telse\n\t\t\t\t\tnetwork->bCkipSupported = false;\n\t\t\t} else {\n\t\t\t\tnetwork->bWithAironetIE = false;\n\t\t\t\tnetwork->bCkipSupported = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MFIE_TYPE_QOS_PARAMETER:\n\t\t\tnetdev_err(ieee->dev,\n\t\t\t\t   \"QoS Error need to parse QOS_PARAMETER IE\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_COUNTRY:\n\t\t\tnetdev_dbg(ieee->dev, \"MFIE_TYPE_COUNTRY: %d bytes\\n\",\n\t\t\t\t   info_element->len);\n\t\t\trtllib_extract_country_ie(ieee, info_element, network,\n\t\t\t\t\t\t  network->bssid);\n\t\t\tbreak;\n \n\t\tdefault:\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"Unsupported info element: %s (%d)\\n\",\n\t\t\t\t   get_info_element_string(info_element->id),\n\t\t\t\t   info_element->id);\n\t\t\tbreak;\n\t\t}\n\n\t\tlength -= sizeof(*info_element) + info_element->len;\n\t\tinfo_element =\n\t\t    (struct rtllib_info_element *)&info_element->data[info_element->len];\n\t}\n\n\tif (!network->atheros_cap_exist && !network->broadcom_cap_exist &&\n\t    !network->cisco_cap_exist && !network->ralink_cap_exist &&\n\t    !network->bssht.bd_rt2rt_aggregation)\n\t\tnetwork->unknown_cap_exist = true;\n\telse\n\t\tnetwork->unknown_cap_exist = false;\n\treturn 0;\n}\n\nstatic long rtllib_translate_todbm(u8 signal_strength_index)\n{\n\tlong\tsignal_power;\n\n\tsignal_power = (long)((signal_strength_index + 1) >> 1);\n\tsignal_power -= 95;\n\n\treturn signal_power;\n}\n\nstatic inline int rtllib_network_init(\n\tstruct rtllib_device *ieee,\n\tstruct rtllib_probe_response *beacon,\n\tstruct rtllib_network *network,\n\tstruct rtllib_rx_stats *stats)\n{\n\tmemset(&network->qos_data, 0, sizeof(struct rtllib_qos_data));\n\n\t \n\tether_addr_copy(network->bssid, beacon->header.addr3);\n\tnetwork->capability = le16_to_cpu(beacon->capability);\n\tnetwork->last_scanned = jiffies;\n\tnetwork->time_stamp[0] = beacon->time_stamp[0];\n\tnetwork->time_stamp[1] = beacon->time_stamp[1];\n\tnetwork->beacon_interval = le16_to_cpu(beacon->beacon_interval);\n\t \n\tnetwork->listen_interval = 0x0A;\n\tnetwork->rates_len = network->rates_ex_len = 0;\n\tnetwork->ssid_len = 0;\n\tnetwork->hidden_ssid_len = 0;\n\tmemset(network->hidden_ssid, 0, sizeof(network->hidden_ssid));\n\tnetwork->flags = 0;\n\tnetwork->atim_window = 0;\n\tnetwork->erp_value = (network->capability & WLAN_CAPABILITY_IBSS) ?\n\t    0x3 : 0x0;\n\tnetwork->berp_info_valid = false;\n\tnetwork->broadcom_cap_exist = false;\n\tnetwork->ralink_cap_exist = false;\n\tnetwork->atheros_cap_exist = false;\n\tnetwork->cisco_cap_exist = false;\n\tnetwork->unknown_cap_exist = false;\n\tnetwork->realtek_cap_exit = false;\n\tnetwork->marvell_cap_exist = false;\n\tnetwork->airgo_cap_exist = false;\n\tnetwork->Turbo_Enable = 0;\n\tnetwork->SignalStrength = stats->SignalStrength;\n\tnetwork->RSSI = stats->SignalStrength;\n\tnetwork->CountryIeLen = 0;\n\tmemset(network->CountryIeBuf, 0, MAX_IE_LEN);\n\tHTInitializeBssDesc(&network->bssht);\n\tnetwork->flags |= NETWORK_HAS_CCK;\n\n\tnetwork->wpa_ie_len = 0;\n\tnetwork->rsn_ie_len = 0;\n\tnetwork->wzc_ie_len = 0;\n\n\tif (rtllib_parse_info_param(ieee,\n\t\t\tbeacon->info_element,\n\t\t\t(stats->len - sizeof(*beacon)),\n\t\t\tnetwork,\n\t\t\tstats))\n\t\treturn 1;\n\n\tnetwork->mode = 0;\n\n\tif (network->flags & NETWORK_HAS_OFDM)\n\t\tnetwork->mode |= WIRELESS_MODE_G;\n\tif (network->flags & NETWORK_HAS_CCK)\n\t\tnetwork->mode |= WIRELESS_MODE_B;\n\n\tif (network->mode == 0) {\n\t\tnetdev_dbg(ieee->dev, \"Filtered out '%s (%pM)' network.\\n\",\n\t\t\t   escape_essid(network->ssid, network->ssid_len),\n\t\t\t   network->bssid);\n\t\treturn 1;\n\t}\n\n\tif (network->bssht.bd_support_ht) {\n\t\tif (network->mode & (WIRELESS_MODE_G | WIRELESS_MODE_B))\n\t\t\tnetwork->mode = WIRELESS_MODE_N_24G;\n\t}\n\tif (rtllib_is_empty_essid(network->ssid, network->ssid_len))\n\t\tnetwork->flags |= NETWORK_EMPTY_ESSID;\n\tstats->signal = 30 + (stats->SignalStrength * 70) / 100;\n\tstats->noise = rtllib_translate_todbm((u8)(100 - stats->signal)) - 25;\n\n\tmemcpy(&network->stats, stats, sizeof(network->stats));\n\n\treturn 0;\n}\n\nstatic inline int is_same_network(struct rtllib_network *src,\n\t\t\t\t  struct rtllib_network *dst, u8 ssidbroad)\n{\n\t \n\treturn (((src->ssid_len == dst->ssid_len) || (!ssidbroad)) &&\n\t\t(src->channel == dst->channel) &&\n\t\t!memcmp(src->bssid, dst->bssid, ETH_ALEN) &&\n\t\t(!memcmp(src->ssid, dst->ssid, src->ssid_len) ||\n\t\t(!ssidbroad)) &&\n\t\t((src->capability & WLAN_CAPABILITY_IBSS) ==\n\t\t(dst->capability & WLAN_CAPABILITY_IBSS)) &&\n\t\t((src->capability & WLAN_CAPABILITY_ESS) ==\n\t\t(dst->capability & WLAN_CAPABILITY_ESS)));\n}\n\nstatic inline void update_network(struct rtllib_device *ieee,\n\t\t\t\t  struct rtllib_network *dst,\n\t\t\t\t  struct rtllib_network *src)\n{\n\tint qos_active;\n\tu8 old_param;\n\n\tmemcpy(&dst->stats, &src->stats, sizeof(struct rtllib_rx_stats));\n\tdst->capability = src->capability;\n\tmemcpy(dst->rates, src->rates, src->rates_len);\n\tdst->rates_len = src->rates_len;\n\tmemcpy(dst->rates_ex, src->rates_ex, src->rates_ex_len);\n\tdst->rates_ex_len = src->rates_ex_len;\n\tif (src->ssid_len > 0) {\n\t\tif (dst->ssid_len == 0) {\n\t\t\tmemset(dst->hidden_ssid, 0, sizeof(dst->hidden_ssid));\n\t\t\tdst->hidden_ssid_len = src->ssid_len;\n\t\t\tmemcpy(dst->hidden_ssid, src->ssid, src->ssid_len);\n\t\t} else {\n\t\t\tmemset(dst->ssid, 0, dst->ssid_len);\n\t\t\tdst->ssid_len = src->ssid_len;\n\t\t\tmemcpy(dst->ssid, src->ssid, src->ssid_len);\n\t\t}\n\t}\n\tdst->mode = src->mode;\n\tdst->flags = src->flags;\n\tdst->time_stamp[0] = src->time_stamp[0];\n\tdst->time_stamp[1] = src->time_stamp[1];\n\tif (src->flags & NETWORK_HAS_ERP_VALUE) {\n\t\tdst->erp_value = src->erp_value;\n\t\tdst->berp_info_valid = src->berp_info_valid = true;\n\t}\n\tdst->beacon_interval = src->beacon_interval;\n\tdst->listen_interval = src->listen_interval;\n\tdst->atim_window = src->atim_window;\n\tdst->dtim_period = src->dtim_period;\n\tdst->dtim_data = src->dtim_data;\n\tdst->last_dtim_sta_time = src->last_dtim_sta_time;\n\tmemcpy(&dst->tim, &src->tim, sizeof(struct rtllib_tim_parameters));\n\n\tdst->bssht.bd_support_ht = src->bssht.bd_support_ht;\n\tdst->bssht.bd_rt2rt_aggregation = src->bssht.bd_rt2rt_aggregation;\n\tdst->bssht.bd_ht_cap_len = src->bssht.bd_ht_cap_len;\n\tmemcpy(dst->bssht.bd_ht_cap_buf, src->bssht.bd_ht_cap_buf,\n\t       src->bssht.bd_ht_cap_len);\n\tdst->bssht.bd_ht_info_len = src->bssht.bd_ht_info_len;\n\tmemcpy(dst->bssht.bd_ht_info_buf, src->bssht.bd_ht_info_buf,\n\t       src->bssht.bd_ht_info_len);\n\tdst->bssht.bd_ht_spec_ver = src->bssht.bd_ht_spec_ver;\n\tdst->bssht.bd_rt2rt_long_slot_time = src->bssht.bd_rt2rt_long_slot_time;\n\tdst->broadcom_cap_exist = src->broadcom_cap_exist;\n\tdst->ralink_cap_exist = src->ralink_cap_exist;\n\tdst->atheros_cap_exist = src->atheros_cap_exist;\n\tdst->realtek_cap_exit = src->realtek_cap_exit;\n\tdst->marvell_cap_exist = src->marvell_cap_exist;\n\tdst->cisco_cap_exist = src->cisco_cap_exist;\n\tdst->airgo_cap_exist = src->airgo_cap_exist;\n\tdst->unknown_cap_exist = src->unknown_cap_exist;\n\tmemcpy(dst->wpa_ie, src->wpa_ie, src->wpa_ie_len);\n\tdst->wpa_ie_len = src->wpa_ie_len;\n\tmemcpy(dst->rsn_ie, src->rsn_ie, src->rsn_ie_len);\n\tdst->rsn_ie_len = src->rsn_ie_len;\n\tmemcpy(dst->wzc_ie, src->wzc_ie, src->wzc_ie_len);\n\tdst->wzc_ie_len = src->wzc_ie_len;\n\n\tdst->last_scanned = jiffies;\n\t \n\tqos_active = dst->qos_data.active;\n\told_param = dst->qos_data.param_count;\n\tdst->qos_data.supported = src->qos_data.supported;\n\tif (dst->flags & NETWORK_HAS_QOS_PARAMETERS)\n\t\tmemcpy(&dst->qos_data, &src->qos_data,\n\t\t       sizeof(struct rtllib_qos_data));\n\tif (dst->qos_data.supported == 1) {\n\t\tif (dst->ssid_len)\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"QoS the network %s is QoS supported\\n\",\n\t\t\t\t   dst->ssid);\n\t\telse\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"QoS the network is QoS supported\\n\");\n\t}\n\tdst->qos_data.active = qos_active;\n\tdst->qos_data.old_param_count = old_param;\n\n\tdst->wmm_info = src->wmm_info;\n\tif (src->wmm_param[0].ac_aci_acm_aifsn ||\n\t   src->wmm_param[1].ac_aci_acm_aifsn ||\n\t   src->wmm_param[2].ac_aci_acm_aifsn ||\n\t   src->wmm_param[3].ac_aci_acm_aifsn)\n\t\tmemcpy(dst->wmm_param, src->wmm_param, WME_AC_PRAM_LEN);\n\n\tdst->SignalStrength = src->SignalStrength;\n\tdst->RSSI = src->RSSI;\n\tdst->Turbo_Enable = src->Turbo_Enable;\n\n\tdst->CountryIeLen = src->CountryIeLen;\n\tmemcpy(dst->CountryIeBuf, src->CountryIeBuf, src->CountryIeLen);\n\n\tdst->bWithAironetIE = src->bWithAironetIE;\n\tdst->bCkipSupported = src->bCkipSupported;\n\tmemcpy(dst->CcxRmState, src->CcxRmState, 2);\n\tdst->bCcxRmEnable = src->bCcxRmEnable;\n\tdst->MBssidMask = src->MBssidMask;\n\tdst->bMBssidValid = src->bMBssidValid;\n\tmemcpy(dst->MBssid, src->MBssid, 6);\n\tdst->bWithCcxVerNum = src->bWithCcxVerNum;\n\tdst->BssCcxVerNumber = src->BssCcxVerNumber;\n}\n\nstatic inline int is_beacon(u16 fc)\n{\n\treturn (WLAN_FC_GET_STYPE(fc) == RTLLIB_STYPE_BEACON);\n}\n\nstatic int IsPassiveChannel(struct rtllib_device *rtllib, u8 channel)\n{\n\tif (channel > MAX_CHANNEL_NUMBER) {\n\t\tnetdev_info(rtllib->dev, \"%s(): Invalid Channel\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (rtllib->active_channel_map[channel] == 2)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint rtllib_legal_channel(struct rtllib_device *rtllib, u8 channel)\n{\n\tif (channel > MAX_CHANNEL_NUMBER) {\n\t\tnetdev_info(rtllib->dev, \"%s(): Invalid Channel\\n\", __func__);\n\t\treturn 0;\n\t}\n\tif (rtllib->active_channel_map[channel] > 0)\n\t\treturn 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_legal_channel);\n\nstatic inline void rtllib_process_probe_response(\n\tstruct rtllib_device *ieee,\n\tstruct rtllib_probe_response *beacon,\n\tstruct rtllib_rx_stats *stats)\n{\n\tstruct rtllib_network *target;\n\tstruct rtllib_network *oldest = NULL;\n\tstruct rtllib_info_element *info_element = &beacon->info_element[0];\n\tunsigned long flags;\n\tshort renew;\n\tstruct rtllib_network *network = kzalloc(sizeof(struct rtllib_network),\n\t\t\t\t\t\t GFP_ATOMIC);\n\tu16 frame_ctl = le16_to_cpu(beacon->header.frame_ctl);\n\n\tif (!network)\n\t\treturn;\n\n\tnetdev_dbg(ieee->dev,\n\t\t   \"'%s' ( %pM ): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\\n\",\n\t\t   escape_essid(info_element->data, info_element->len),\n\t\t   beacon->header.addr3,\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0xf)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0xe)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0xd)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0xc)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0xb)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0xa)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0x9)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0x8)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0x7)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0x6)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0x5)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0x4)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0x3)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0x2)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0x1)) ? '1' : '0',\n\t\t   (le16_to_cpu(beacon->capability) & (1 << 0x0)) ? '1' : '0');\n\n\tif (rtllib_network_init(ieee, beacon, network, stats)) {\n\t\tnetdev_dbg(ieee->dev, \"Dropped '%s' ( %pM) via %s.\\n\",\n\t\t\t   escape_essid(info_element->data, info_element->len),\n\t\t\t   beacon->header.addr3,\n\t\t\t   is_beacon(frame_ctl) ? \"BEACON\" : \"PROBE RESPONSE\");\n\t\tgoto free_network;\n\t}\n\n\tif (!rtllib_legal_channel(ieee, network->channel))\n\t\tgoto free_network;\n\n\tif (WLAN_FC_GET_STYPE(frame_ctl) == RTLLIB_STYPE_PROBE_RESP) {\n\t\tif (IsPassiveChannel(ieee, network->channel)) {\n\t\t\tnetdev_info(ieee->dev,\n\t\t\t\t    \"GetScanInfo(): For Global Domain, filter probe response at channel(%d).\\n\",\n\t\t\t\t    network->channel);\n\t\t\tgoto free_network;\n\t\t}\n\t}\n\n\t \n\n\t \n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\tif (is_same_network(&ieee->current_network, network,\n\t   (network->ssid_len ? 1 : 0))) {\n\t\tupdate_network(ieee, &ieee->current_network, network);\n\t\tif ((ieee->current_network.mode == WIRELESS_MODE_N_24G ||\n\t\t     ieee->current_network.mode == WIRELESS_MODE_G) &&\n\t\t    ieee->current_network.berp_info_valid) {\n\t\t\tif (ieee->current_network.erp_value & ERP_UseProtection)\n\t\t\t\tieee->current_network.buseprotection = true;\n\t\t\telse\n\t\t\t\tieee->current_network.buseprotection = false;\n\t\t}\n\t\tif (is_beacon(frame_ctl)) {\n\t\t\tif (ieee->link_state >= MAC80211_LINKED)\n\t\t\t\tieee->link_detect_info.NumRecvBcnInPeriod++;\n\t\t}\n\t}\n\tlist_for_each_entry(target, &ieee->network_list, list) {\n\t\tif (is_same_network(target, network,\n\t\t   (target->ssid_len ? 1 : 0)))\n\t\t\tbreak;\n\t\tif ((oldest == NULL) ||\n\t\t    (target->last_scanned < oldest->last_scanned))\n\t\t\toldest = target;\n\t}\n\n\t \n\tif (&target->list == &ieee->network_list) {\n\t\tif (list_empty(&ieee->network_free_list)) {\n\t\t\t \n\t\t\tlist_del(&oldest->list);\n\t\t\ttarget = oldest;\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"Expired '%s' ( %pM) from network list.\\n\",\n\t\t\t\t   escape_essid(target->ssid, target->ssid_len),\n\t\t\t\t   target->bssid);\n\t\t} else {\n\t\t\t \n\t\t\ttarget = list_entry(ieee->network_free_list.next,\n\t\t\t\t\t    struct rtllib_network, list);\n\t\t\tlist_del(ieee->network_free_list.next);\n\t\t}\n\n\t\tnetdev_dbg(ieee->dev, \"Adding '%s' ( %pM) via %s.\\n\",\n\t\t\t   escape_essid(network->ssid, network->ssid_len),\n\t\t\t   network->bssid,\n\t\t\t   is_beacon(frame_ctl) ? \"BEACON\" : \"PROBE RESPONSE\");\n\n\t\tmemcpy(target, network, sizeof(*target));\n\t\tlist_add_tail(&target->list, &ieee->network_list);\n\t\tif (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE)\n\t\t\trtllib_softmac_new_net(ieee, network);\n\t} else {\n\t\tnetdev_dbg(ieee->dev, \"Updating '%s' ( %pM) via %s.\\n\",\n\t\t\t   escape_essid(target->ssid, target->ssid_len),\n\t\t\t   target->bssid,\n\t\t\t   is_beacon(frame_ctl) ? \"BEACON\" : \"PROBE RESPONSE\");\n\n\t\t \n\t\trenew = !time_after(target->last_scanned + ieee->scan_age,\n\t\t\t\t    jiffies);\n\t\tif ((!target->ssid_len) &&\n\t\t    (((network->ssid_len > 0) && (target->hidden_ssid_len == 0))\n\t\t    || ((ieee->current_network.ssid_len == network->ssid_len) &&\n\t\t    (strncmp(ieee->current_network.ssid, network->ssid,\n\t\t    network->ssid_len) == 0) &&\n\t\t    (ieee->link_state == MAC80211_NOLINK))))\n\t\t\trenew = 1;\n\t\tupdate_network(ieee, target, network);\n\t\tif (renew && (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE))\n\t\t\trtllib_softmac_new_net(ieee, network);\n\t}\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\tif (is_beacon(frame_ctl) &&\n\t    is_same_network(&ieee->current_network, network,\n\t    (network->ssid_len ? 1 : 0)) &&\n\t    (ieee->link_state == MAC80211_LINKED)) {\n\t\tieee->handle_beacon(ieee->dev, beacon, &ieee->current_network);\n\t}\nfree_network:\n\tkfree(network);\n}\n\nstatic void rtllib_rx_mgt(struct rtllib_device *ieee,\n\t\t\t  struct sk_buff *skb,\n\t\t\t  struct rtllib_rx_stats *stats)\n{\n\tstruct rtllib_hdr_4addr *header = (struct rtllib_hdr_4addr *)skb->data;\n\n\tif ((WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)) !=\n\t    RTLLIB_STYPE_PROBE_RESP) &&\n\t    (WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)) !=\n\t    RTLLIB_STYPE_BEACON))\n\t\tieee->last_rx_ps_time = jiffies;\n\n\tswitch (WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl))) {\n\tcase RTLLIB_STYPE_BEACON:\n\t\tnetdev_dbg(ieee->dev, \"received BEACON (%d)\\n\",\n\t\t\t   WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));\n\t\trtllib_process_probe_response(\n\t\t\t\tieee, (struct rtllib_probe_response *)header,\n\t\t\t\tstats);\n\n\t\tif (ieee->sta_sleep || (ieee->ps != RTLLIB_PS_DISABLED &&\n\t\t    ieee->iw_mode == IW_MODE_INFRA &&\n\t\t    ieee->link_state == MAC80211_LINKED))\n\t\t\tschedule_work(&ieee->ps_task);\n\n\t\tbreak;\n\n\tcase RTLLIB_STYPE_PROBE_RESP:\n\t\tnetdev_dbg(ieee->dev, \"received PROBE RESPONSE (%d)\\n\",\n\t\t\t   WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));\n\t\trtllib_process_probe_response(ieee,\n\t\t\t      (struct rtllib_probe_response *)header, stats);\n\t\tbreak;\n\tcase RTLLIB_STYPE_PROBE_REQ:\n\t\tnetdev_dbg(ieee->dev, \"received PROBE REQUEST (%d)\\n\",\n\t\t\t   WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));\n\t\tif ((ieee->softmac_features & IEEE_SOFTMAC_PROBERS) &&\n\t\t    (ieee->iw_mode == IW_MODE_ADHOC &&\n\t\t    ieee->link_state == MAC80211_LINKED))\n\t\t\trtllib_rx_probe_rq(ieee, skb);\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}