{
  "module_name": "rtllib_wx.c",
  "hash_id": "ad0e412f692282f223f97c10adceb313bcf8b072ca8ae799712cb18e0548d5f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/rtl8192e/rtllib_wx.c",
  "human_readable_source": "\n \n#include <linux/wireless.h>\n#include <linux/kmod.h>\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include \"rtllib.h\"\n\nstatic const char * const rtllib_modes[] = {\n\t\"a\", \"b\", \"g\", \"?\", \"N-24G\"\n};\n\n#define MAX_CUSTOM_LEN 64\nstatic inline char *rtl819x_translate_scan(struct rtllib_device *ieee,\n\t\t\t\t\t   char *start, char *stop,\n\t\t\t\t\t   struct rtllib_network *network,\n\t\t\t\t\t   struct iw_request_info *info)\n{\n\tchar custom[MAX_CUSTOM_LEN];\n\tchar proto_name[IFNAMSIZ];\n\tchar *pname = proto_name;\n\tchar *p;\n\tstruct iw_event iwe;\n\tint i, j;\n\tu16 max_rate, rate;\n\tstatic u8\tEWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};\n\n\t \n\tiwe.cmd = SIOCGIWAP;\n\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\tether_addr_copy(iwe.u.ap_addr.sa_data, network->bssid);\n\tstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);\n\t \n\n\t \n\tiwe.cmd = SIOCGIWESSID;\n\tiwe.u.data.flags = 1;\n\tif (network->ssid_len > 0) {\n\t\tiwe.u.data.length = min_t(u8, network->ssid_len, 32);\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, network->ssid);\n\t} else if (network->hidden_ssid_len == 0) {\n\t\tiwe.u.data.length = sizeof(\"<hidden>\");\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, \"<hidden>\");\n\t} else {\n\t\tiwe.u.data.length = min_t(u8, network->hidden_ssid_len, 32);\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, network->hidden_ssid);\n\t}\n\t \n\tiwe.cmd = SIOCGIWNAME;\n\tfor (i = 0; i < ARRAY_SIZE(rtllib_modes); i++) {\n\t\tif (network->mode & BIT(i)) {\n\t\t\tstrcpy(pname, rtllib_modes[i]);\n\t\t\tpname += strlen(rtllib_modes[i]);\n\t\t}\n\t}\n\t*pname = '\\0';\n\tsnprintf(iwe.u.name, IFNAMSIZ, \"IEEE802.11%s\", proto_name);\n\tstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);\n\t \n\tiwe.cmd = SIOCGIWMODE;\n\tif (network->capability &\n\t    (WLAN_CAPABILITY_ESS | WLAN_CAPABILITY_IBSS)) {\n\t\tif (network->capability & WLAN_CAPABILITY_ESS)\n\t\t\tiwe.u.mode = IW_MODE_MASTER;\n\t\telse\n\t\t\tiwe.u.mode = IW_MODE_ADHOC;\n\t\tstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_UINT_LEN);\n\t}\n\n\t \n\tiwe.cmd = SIOCGIWFREQ;\n\tiwe.u.freq.m = network->channel;\n\tiwe.u.freq.e = 0;\n\tiwe.u.freq.i = 0;\n\tstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_FREQ_LEN);\n\n\t \n\tiwe.cmd = SIOCGIWENCODE;\n\tif (network->capability & WLAN_CAPABILITY_PRIVACY)\n\t\tiwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\n\telse\n\t\tiwe.u.data.flags = IW_ENCODE_DISABLED;\n\tiwe.u.data.length = 0;\n\tstart = iwe_stream_add_point(info, start, stop, &iwe, network->ssid);\n\t \n\tmax_rate = 0;\n\tp = custom;\n\tp += scnprintf(p, MAX_CUSTOM_LEN - (p - custom), \" Rates (Mb/s): \");\n\tfor (i = 0, j = 0; i < network->rates_len;) {\n\t\tif (j < network->rates_ex_len &&\n\t\t    ((network->rates_ex[j] & 0x7F) <\n\t\t     (network->rates[i] & 0x7F)))\n\t\t\trate = network->rates_ex[j++] & 0x7F;\n\t\telse\n\t\t\trate = network->rates[i++] & 0x7F;\n\t\tif (rate > max_rate)\n\t\t\tmax_rate = rate;\n\t\tp += scnprintf(p, MAX_CUSTOM_LEN - (p - custom),\n\t\t\t      \"%d%s \", rate >> 1, (rate & 1) ? \".5\" : \"\");\n\t}\n\tfor (; j < network->rates_ex_len; j++) {\n\t\trate = network->rates_ex[j] & 0x7F;\n\t\tp += scnprintf(p, MAX_CUSTOM_LEN - (p - custom),\n\t\t\t      \"%d%s \", rate >> 1, (rate & 1) ? \".5\" : \"\");\n\t\tif (rate > max_rate)\n\t\t\tmax_rate = rate;\n\t}\n\n\tif (network->mode >= WIRELESS_MODE_N_24G) {\n\t\tstruct ht_capab_ele *ht_cap = NULL;\n\t\tbool is40M = false, isShortGI = false;\n\t\tu8 max_mcs = 0;\n\n\t\tif (!memcmp(network->bssht.bd_ht_cap_buf, EWC11NHTCap, 4))\n\t\t\tht_cap = (struct ht_capab_ele *)\n\t\t\t\t &network->bssht.bd_ht_cap_buf[4];\n\t\telse\n\t\t\tht_cap = (struct ht_capab_ele *)\n\t\t\t\t &network->bssht.bd_ht_cap_buf[0];\n\t\tis40M = (ht_cap->ChlWidth) ? 1 : 0;\n\t\tisShortGI = (ht_cap->ChlWidth) ?\n\t\t\t\t((ht_cap->ShortGI40Mhz) ? 1 : 0) :\n\t\t\t\t((ht_cap->ShortGI20Mhz) ? 1 : 0);\n\n\t\tmax_mcs = HTGetHighestMCSRate(ieee, ht_cap->MCS,\n\t\t\t\t\t      MCS_FILTER_ALL);\n\t\trate = MCS_DATA_RATE[is40M][isShortGI][max_mcs & 0x7f];\n\t\tif (rate > max_rate)\n\t\t\tmax_rate = rate;\n\t}\n\tiwe.cmd = SIOCGIWRATE;\n\tiwe.u.bitrate.disabled = 0;\n\tiwe.u.bitrate.fixed = 0;\n\tiwe.u.bitrate.value = max_rate * 500000;\n\tstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_PARAM_LEN);\n\tiwe.cmd = IWEVCUSTOM;\n\tiwe.u.data.length = p - custom;\n\tif (iwe.u.data.length)\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\n\t \n\t \n\tiwe.cmd = IWEVQUAL;\n\tiwe.u.qual.qual = network->stats.signal;\n\tiwe.u.qual.level = network->stats.rssi;\n\tiwe.u.qual.noise = network->stats.noise;\n\tiwe.u.qual.updated = network->stats.mask & RTLLIB_STATMASK_WEMASK;\n\tif (!(network->stats.mask & RTLLIB_STATMASK_RSSI))\n\t\tiwe.u.qual.updated |= IW_QUAL_LEVEL_INVALID;\n\tif (!(network->stats.mask & RTLLIB_STATMASK_NOISE))\n\t\tiwe.u.qual.updated |= IW_QUAL_NOISE_INVALID;\n\tif (!(network->stats.mask & RTLLIB_STATMASK_SIGNAL))\n\t\tiwe.u.qual.updated |= IW_QUAL_QUAL_INVALID;\n\tiwe.u.qual.updated = 7;\n\tstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);\n\n\tiwe.cmd = IWEVCUSTOM;\n\tp = custom;\n\tiwe.u.data.length = p - custom;\n\tif (iwe.u.data.length)\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\n\n\tmemset(&iwe, 0, sizeof(iwe));\n\tif (network->wpa_ie_len) {\n\t\tchar buf[MAX_WPA_IE_LEN];\n\n\t\tmemcpy(buf, network->wpa_ie, network->wpa_ie_len);\n\t\tiwe.cmd = IWEVGENIE;\n\t\tiwe.u.data.length = network->wpa_ie_len;\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, buf);\n\t}\n\tmemset(&iwe, 0, sizeof(iwe));\n\tif (network->rsn_ie_len) {\n\t\tchar buf[MAX_WPA_IE_LEN];\n\n\t\tmemcpy(buf, network->rsn_ie, network->rsn_ie_len);\n\t\tiwe.cmd = IWEVGENIE;\n\t\tiwe.u.data.length = network->rsn_ie_len;\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, buf);\n\t}\n\n\t \n\tmemset(&iwe, 0, sizeof(iwe));\n\tif (network->wzc_ie_len) {\n\t\tchar buf[MAX_WZC_IE_LEN];\n\n\t\tmemcpy(buf, network->wzc_ie, network->wzc_ie_len);\n\t\tiwe.cmd = IWEVGENIE;\n\t\tiwe.u.data.length = network->wzc_ie_len;\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, buf);\n\t}\n\n\t \n\tiwe.cmd = IWEVCUSTOM;\n\tp = custom;\n\tp += scnprintf(p, MAX_CUSTOM_LEN - (p - custom),\n\t\t      \" Last beacon: %lums ago\",\n\t\t      (100 * (jiffies - network->last_scanned)) / HZ);\n\tiwe.u.data.length = p - custom;\n\tif (iwe.u.data.length)\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\n\n\treturn start;\n}\n\nint rtllib_wx_get_scan(struct rtllib_device *ieee,\n\t\t       struct iw_request_info *info,\n\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct rtllib_network *network;\n\tunsigned long flags;\n\n\tchar *ev = extra;\n\tchar *stop = ev + wrqu->data.length;\n\tint i = 0;\n\tint err = 0;\n\n\tnetdev_dbg(ieee->dev, \"Getting scan\\n\");\n\tmutex_lock(&ieee->wx_mutex);\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tlist_for_each_entry(network, &ieee->network_list, list) {\n\t\ti++;\n\t\tif ((stop - ev) < 200) {\n\t\t\terr = -E2BIG;\n\t\t\tbreak;\n\t\t}\n\t\tif (ieee->scan_age == 0 ||\n\t\t    time_after(network->last_scanned + ieee->scan_age, jiffies))\n\t\t\tev = rtl819x_translate_scan(ieee, ev, stop, network,\n\t\t\t\t\t\t    info);\n\t\telse\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"Network '%s ( %pM)' hidden due to age (%lums).\\n\",\n\t\t\t\t   escape_essid(network->ssid,\n\t\t\t\t\t\tnetwork->ssid_len),\n\t\t\t\t   network->bssid,\n\t\t\t\t   (100 * (jiffies - network->last_scanned)) /\n\t\t\t\t   HZ);\n\t}\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\tmutex_unlock(&ieee->wx_mutex);\n\twrqu->data.length = ev -  extra;\n\twrqu->data.flags = 0;\n\n\tnetdev_dbg(ieee->dev, \"%s(): %d networks returned.\\n\", __func__, i);\n\n\treturn err;\n}\nEXPORT_SYMBOL(rtllib_wx_get_scan);\n\nint rtllib_wx_set_encode(struct rtllib_device *ieee,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu, char *keybuf)\n{\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct net_device *dev = ieee->dev;\n\tstruct rtllib_security sec = {\n\t\t.flags = 0\n\t};\n\tint i, key, key_provided, len;\n\tstruct lib80211_crypt_data **crypt;\n\n\tkey = erq->flags & IW_ENCODE_INDEX;\n\tif (key) {\n\t\tif (key > NUM_WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tkey--;\n\t\tkey_provided = 1;\n\t} else {\n\t\tkey_provided = 0;\n\t\tkey = ieee->crypt_info.tx_keyidx;\n\t}\n\n\tnetdev_dbg(ieee->dev, \"Key: %d [%s]\\n\", key, key_provided ?\n\t\t\t   \"provided\" : \"default\");\n\tcrypt = &ieee->crypt_info.crypt[key];\n\tif (erq->flags & IW_ENCODE_DISABLED) {\n\t\tif (key_provided && *crypt) {\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"Disabling encryption on key %d.\\n\", key);\n\t\t\tlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\n\t\t} else {\n\t\t\tnetdev_dbg(ieee->dev, \"Disabling encryption.\\n\");\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < NUM_WEP_KEYS; i++) {\n\t\t\tif (ieee->crypt_info.crypt[i]) {\n\t\t\t\tif (key_provided)\n\t\t\t\t\tbreak;\n\t\t\t\tlib80211_crypt_delayed_deinit(&ieee->crypt_info,\n\t\t\t\t\t\t\t      &ieee->crypt_info.crypt[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (i == NUM_WEP_KEYS) {\n\t\t\tsec.enabled = 0;\n\t\t\tsec.level = SEC_LEVEL_0;\n\t\t\tsec.flags |= SEC_ENABLED | SEC_LEVEL;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\tsec.enabled = 1;\n\tsec.flags |= SEC_ENABLED;\n\n\tif (*crypt && (*crypt)->ops &&\n\t    strcmp((*crypt)->ops->name, \"R-WEP\") != 0) {\n\t\t \n\t\tlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\n\t}\n\n\tif (!*crypt) {\n\t\tstruct lib80211_crypt_data *new_crypt;\n\n\t\t \n\t\tnew_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);\n\t\tif (!new_crypt)\n\t\t\treturn -ENOMEM;\n\t\tnew_crypt->ops = lib80211_get_crypto_ops(\"R-WEP\");\n\t\tif (!new_crypt->ops) {\n\t\t\trequest_module(\"rtllib_crypt_wep\");\n\t\t\tnew_crypt->ops = lib80211_get_crypto_ops(\"R-WEP\");\n\t\t}\n\n\t\tif (new_crypt->ops)\n\t\t\tnew_crypt->priv = new_crypt->ops->init(key);\n\n\t\tif (!new_crypt->ops || !new_crypt->priv) {\n\t\t\tkfree(new_crypt);\n\t\t\tnew_crypt = NULL;\n\n\t\t\tnetdev_warn(dev,\n\t\t\t\t    \"%s: could not initialize WEP: load module rtllib_crypt_wep\\n\",\n\t\t\t\t    dev->name);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t*crypt = new_crypt;\n\t}\n\n\t \n\tif (erq->length > 0) {\n\t\tlen = erq->length <= 5 ? 5 : 13;\n\t\tmemcpy(sec.keys[key], keybuf, erq->length);\n\t\tif (len > erq->length)\n\t\t\tmemset(sec.keys[key] + erq->length, 0,\n\t\t\t       len - erq->length);\n\t\tnetdev_dbg(ieee->dev, \"Setting key %d to '%s' (%d:%d bytes)\\n\",\n\t\t\t   key, escape_essid(sec.keys[key], len), erq->length,\n\t\t\t   len);\n\t\tsec.key_sizes[key] = len;\n\t\t(*crypt)->ops->set_key(sec.keys[key], len, NULL,\n\t\t\t\t       (*crypt)->priv);\n\t\tsec.flags |= (1 << key);\n\t\t \n\t\tif (key == sec.active_key)\n\t\t\tsec.flags |= SEC_ACTIVE_KEY;\n\t\tieee->crypt_info.tx_keyidx = key;\n\n\t} else {\n\t\tlen = (*crypt)->ops->get_key(sec.keys[key], WEP_KEY_LEN,\n\t\t\t\t\t     NULL, (*crypt)->priv);\n\t\tif (len == 0) {\n\t\t\t \n\t\t\tnetdev_info(ieee->dev, \"Setting key %d to all zero.\\n\", key);\n\n\t\t\tmemset(sec.keys[key], 0, 13);\n\t\t\t(*crypt)->ops->set_key(sec.keys[key], 13, NULL,\n\t\t\t\t\t       (*crypt)->priv);\n\t\t\tsec.key_sizes[key] = 13;\n\t\t\tsec.flags |= (1 << key);\n\t\t}\n\n\t\t \n\t\tif (key_provided) {\n\t\t\tnetdev_dbg(ieee->dev,\n\t\t\t\t   \"Setting key %d as default Tx key.\\n\", key);\n\t\t\tieee->crypt_info.tx_keyidx = key;\n\t\t\tsec.active_key = key;\n\t\t\tsec.flags |= SEC_ACTIVE_KEY;\n\t\t}\n\t}\n done:\n\tieee->open_wep = !(erq->flags & IW_ENCODE_RESTRICTED);\n\tieee->auth_mode = ieee->open_wep ? WLAN_AUTH_OPEN :\n\t\t\t  WLAN_AUTH_SHARED_KEY;\n\tsec.auth_mode = ieee->open_wep ? WLAN_AUTH_OPEN : WLAN_AUTH_SHARED_KEY;\n\tsec.flags |= SEC_AUTH_MODE;\n\tnetdev_dbg(ieee->dev, \"Auth: %s\\n\", sec.auth_mode == WLAN_AUTH_OPEN ?\n\t\t\t   \"OPEN\" : \"SHARED KEY\");\n\n\t \n\tsec.flags |= SEC_LEVEL;\n\tsec.level = SEC_LEVEL_1;  \n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_set_encode);\n\nint rtllib_wx_get_encode(struct rtllib_device *ieee,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu, char *keybuf)\n{\n\tstruct iw_point *erq = &wrqu->encoding;\n\tint len, key;\n\tstruct lib80211_crypt_data *crypt;\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR)\n\t\treturn -1;\n\n\tkey = erq->flags & IW_ENCODE_INDEX;\n\tif (key) {\n\t\tif (key > NUM_WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tkey--;\n\t} else {\n\t\tkey = ieee->crypt_info.tx_keyidx;\n\t}\n\tcrypt = ieee->crypt_info.crypt[key];\n\n\terq->flags = key + 1;\n\n\tif (!crypt || !crypt->ops) {\n\t\terq->length = 0;\n\t\terq->flags |= IW_ENCODE_DISABLED;\n\t\treturn 0;\n\t}\n\tlen = crypt->ops->get_key(keybuf, SCM_KEY_LEN, NULL, crypt->priv);\n\n\terq->length = max(len, 0);\n\n\terq->flags |= IW_ENCODE_ENABLED;\n\n\tif (ieee->open_wep)\n\t\terq->flags |= IW_ENCODE_OPEN;\n\telse\n\t\terq->flags |= IW_ENCODE_RESTRICTED;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_get_encode);\n\nint rtllib_wx_set_encode_ext(struct rtllib_device *ieee,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tint ret = 0;\n\tstruct net_device *dev = ieee->dev;\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint i, idx;\n\tint group_key = 0;\n\tconst char *alg, *module;\n\tstruct lib80211_crypto_ops *ops;\n\tstruct lib80211_crypt_data **crypt;\n\n\tstruct rtllib_security sec = {\n\t\t.flags = 0,\n\t};\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif (idx < 1 || idx > NUM_WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tidx--;\n\t} else {\n\t\tidx = ieee->crypt_info.tx_keyidx;\n\t}\n\tif (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {\n\t\tcrypt = &ieee->crypt_info.crypt[idx];\n\t\tgroup_key = 1;\n\t} else {\n\t\t \n\t\tif (idx != 0 && ext->alg != IW_ENCODE_ALG_WEP)\n\t\t\treturn -EINVAL;\n\t\tif (ieee->iw_mode == IW_MODE_INFRA)\n\t\t\tcrypt = &ieee->crypt_info.crypt[idx];\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tsec.flags |= SEC_ENABLED;\n\tif ((encoding->flags & IW_ENCODE_DISABLED) ||\n\t    ext->alg == IW_ENCODE_ALG_NONE) {\n\t\tif (*crypt)\n\t\t\tlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\n\n\t\tfor (i = 0; i < NUM_WEP_KEYS; i++) {\n\t\t\tif (ieee->crypt_info.crypt[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == NUM_WEP_KEYS) {\n\t\t\tsec.enabled = 0;\n\t\t\tsec.level = SEC_LEVEL_0;\n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t}\n\t\tgoto done;\n\t}\n\n\tsec.enabled = 1;\n\tswitch (ext->alg) {\n\tcase IW_ENCODE_ALG_WEP:\n\t\talg = \"R-WEP\";\n\t\tmodule = \"rtllib_crypt_wep\";\n\t\tbreak;\n\tcase IW_ENCODE_ALG_TKIP:\n\t\talg = \"R-TKIP\";\n\t\tmodule = \"rtllib_crypt_tkip\";\n\t\tbreak;\n\tcase IW_ENCODE_ALG_CCMP:\n\t\talg = \"R-CCMP\";\n\t\tmodule = \"rtllib_crypt_ccmp\";\n\t\tbreak;\n\tdefault:\n\t\tnetdev_dbg(ieee->dev, \"Unknown crypto alg %d\\n\", ext->alg);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tnetdev_dbg(dev, \"alg name:%s\\n\", alg);\n\n\tops = lib80211_get_crypto_ops(alg);\n\tif (!ops) {\n\t\tchar tempbuf[100];\n\n\t\tmemset(tempbuf, 0x00, 100);\n\t\tsprintf(tempbuf, \"%s\", module);\n\t\trequest_module(\"%s\", tempbuf);\n\t\tops = lib80211_get_crypto_ops(alg);\n\t}\n\tif (!ops) {\n\t\tnetdev_info(dev, \"========>unknown crypto alg %d\\n\", ext->alg);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (!*crypt || (*crypt)->ops != ops) {\n\t\tstruct lib80211_crypt_data *new_crypt;\n\n\t\tlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\n\n\t\tnew_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);\n\t\tif (!new_crypt) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tnew_crypt->ops = ops;\n\t\tif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\n\t\t\tnew_crypt->priv = new_crypt->ops->init(idx);\n\n\t\tif (!new_crypt->priv) {\n\t\t\tkfree(new_crypt);\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\t*crypt = new_crypt;\n\t}\n\n\tif (ext->key_len > 0 && (*crypt)->ops->set_key &&\n\t    (*crypt)->ops->set_key(ext->key, ext->key_len, ext->rx_seq,\n\t\t\t\t   (*crypt)->priv) < 0) {\n\t\tnetdev_info(dev, \"key setting failed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\n\t\tieee->crypt_info.tx_keyidx = idx;\n\t\tsec.active_key = idx;\n\t\tsec.flags |= SEC_ACTIVE_KEY;\n\t}\n\tif (ext->alg != IW_ENCODE_ALG_NONE) {\n\t\tsec.key_sizes[idx] = ext->key_len;\n\t\tsec.flags |= (1 << idx);\n\t\tif (ext->alg == IW_ENCODE_ALG_WEP) {\n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\tsec.level = SEC_LEVEL_1;\n\t\t} else if (ext->alg == IW_ENCODE_ALG_TKIP) {\n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\tsec.level = SEC_LEVEL_2;\n\t\t} else if (ext->alg == IW_ENCODE_ALG_CCMP) {\n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\tsec.level = SEC_LEVEL_3;\n\t\t}\n\t\t \n\t\tif (group_key)\n\t\t\tsec.flags &= ~SEC_LEVEL;\n\t}\ndone:\n\treturn ret;\n}\nEXPORT_SYMBOL(rtllib_wx_set_encode_ext);\n\nint rtllib_wx_set_mlme(struct rtllib_device *ieee,\n\t\t       struct iw_request_info *info,\n\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tu8 i = 0;\n\tbool deauth = false;\n\tstruct iw_mlme *mlme = (struct iw_mlme *)extra;\n\n\tif (ieee->link_state != MAC80211_LINKED)\n\t\treturn -ENOLINK;\n\n\tmutex_lock(&ieee->wx_mutex);\n\n\tswitch (mlme->cmd) {\n\tcase IW_MLME_DEAUTH:\n\t\tdeauth = true;\n\t\tfallthrough;\n\tcase IW_MLME_DISASSOC:\n\t\tif (deauth)\n\t\t\tnetdev_info(ieee->dev, \"disauth packet !\\n\");\n\t\telse\n\t\t\tnetdev_info(ieee->dev, \"dis associate packet!\\n\");\n\n\t\tieee->cannot_notify = true;\n\n\t\tSendDisassociation(ieee, deauth, mlme->reason_code);\n\t\trtllib_disassociate(ieee);\n\n\t\tieee->wap_set = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tieee->current_network.bssid[i] = 0x55;\n\n\t\tieee->ssid_set = 0;\n\t\tieee->current_network.ssid[0] = '\\0';\n\t\tieee->current_network.ssid_len = 0;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&ieee->wx_mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_unlock(&ieee->wx_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_set_mlme);\n\nint rtllib_wx_set_auth(struct rtllib_device *ieee,\n\t\t       struct iw_request_info *info,\n\t\t       struct iw_param *data, char *extra)\n{\n\tswitch (data->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\t\tbreak;\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\t\t \n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tieee->tkip_countermeasures = data->value;\n\t\tbreak;\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tieee->drop_unencrypted = data->value;\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (data->value & IW_AUTH_ALG_SHARED_KEY) {\n\t\t\tieee->open_wep = 0;\n\t\t\tieee->auth_mode = 1;\n\t\t} else if (data->value & IW_AUTH_ALG_OPEN_SYSTEM) {\n\t\t\tieee->open_wep = 1;\n\t\t\tieee->auth_mode = 0;\n\t\t} else if (data->value & IW_AUTH_ALG_LEAP) {\n\t\t\tieee->open_wep = 1;\n\t\t\tieee->auth_mode = 2;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tieee->wpa_enabled = (data->value) ? 1 : 0;\n\t\tbreak;\n\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\t\tieee->ieee802_1x = data->value;\n\t\tbreak;\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\tieee->privacy_invoked = data->value;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_set_auth);\n\nint rtllib_wx_set_gen_ie(struct rtllib_device *ieee, u8 *ie, size_t len)\n{\n\tu8 *buf;\n\tu8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};\n\n\tif (len > MAX_WPA_IE_LEN || (len && !ie))\n\t\treturn -EINVAL;\n\n\tif (len) {\n\t\teid = ie[0];\n\t\tif ((eid == MFIE_TYPE_GENERIC) && (!memcmp(&ie[2], wps_oui, 4))) {\n\t\t\tieee->wps_ie_len = min_t(size_t, len, MAX_WZC_IE_LEN);\n\t\t\tbuf = kmemdup(ie, ieee->wps_ie_len, GFP_KERNEL);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tieee->wps_ie = buf;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tieee->wps_ie_len = 0;\n\tkfree(ieee->wps_ie);\n\tieee->wps_ie = NULL;\n\tif (len) {\n\t\tif (len != ie[1] + 2)\n\t\t\treturn -EINVAL;\n\t\tbuf = kmemdup(ie, len, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = buf;\n\t\tieee->wpa_ie_len = len;\n\t} else {\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = NULL;\n\t\tieee->wpa_ie_len = 0;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(rtllib_wx_set_gen_ie);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}