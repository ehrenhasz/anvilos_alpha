{
  "module_name": "adis16240.c",
  "hash_id": "479405dbbb7de10079247edc234f672b7f149627411c2f23e7a3255e16a04a0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/iio/accel/adis16240.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/sysfs.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/imu/adis.h>\n\n#define ADIS16240_STARTUP_DELAY\t220  \n\n \n#define ADIS16240_FLASH_CNT      0x00\n\n \n#define ADIS16240_SUPPLY_OUT     0x02\n\n \n#define ADIS16240_XACCL_OUT      0x04\n\n \n#define ADIS16240_YACCL_OUT      0x06\n\n \n#define ADIS16240_ZACCL_OUT      0x08\n\n \n#define ADIS16240_AUX_ADC        0x0A\n\n \n#define ADIS16240_TEMP_OUT       0x0C\n\n \n#define ADIS16240_XPEAK_OUT      0x0E\n\n \n#define ADIS16240_YPEAK_OUT      0x10\n\n \n#define ADIS16240_ZPEAK_OUT      0x12\n\n \n#define ADIS16240_XYZPEAK_OUT    0x14\n\n \n#define ADIS16240_CAPT_BUF1      0x16\n\n \n#define ADIS16240_CAPT_BUF2      0x18\n\n \n#define ADIS16240_DIAG_STAT      0x1A\n\n \n#define ADIS16240_EVNT_CNTR      0x1C\n\n \n#define ADIS16240_CHK_SUM        0x1E\n\n \n#define ADIS16240_XACCL_OFF      0x20\n\n \n#define ADIS16240_YACCL_OFF      0x22\n\n \n#define ADIS16240_ZACCL_OFF      0x24\n\n \n#define ADIS16240_CLK_TIME       0x2E\n\n \n#define ADIS16240_CLK_DATE       0x30\n\n \n#define ADIS16240_CLK_YEAR       0x32\n\n \n#define ADIS16240_WAKE_TIME      0x34\n\n \n#define ADIS16240_WAKE_DATE      0x36\n\n \n#define ADIS16240_ALM_MAG1       0x38\n\n \n#define ADIS16240_ALM_MAG2       0x3A\n\n \n#define ADIS16240_ALM_CTRL       0x3C\n\n \n#define ADIS16240_XTRIG_CTRL     0x3E\n\n \n#define ADIS16240_CAPT_PNTR      0x40\n\n \n#define ADIS16240_CAPT_CTRL      0x42\n\n \n#define ADIS16240_GPIO_CTRL      0x44\n\n \n#define ADIS16240_MSC_CTRL       0x46\n\n \n#define ADIS16240_SMPL_PRD       0x48\n\n \n#define ADIS16240_GLOB_CMD       0x4A\n\n \n\n \n#define ADIS16240_MSC_CTRL_XYZPEAK_OUT_EN\tBIT(15)\n\n \n#define ADIS16240_MSC_CTRL_X_Y_ZPEAK_OUT_EN\tBIT(14)\n\n \n#define ADIS16240_MSC_CTRL_SELF_TEST_EN\t        BIT(8)\n\n \n#define ADIS16240_MSC_CTRL_DATA_RDY_EN\t        BIT(2)\n\n \n#define ADIS16240_MSC_CTRL_ACTIVE_HIGH\t        BIT(1)\n\n \n#define ADIS16240_MSC_CTRL_DATA_RDY_DIO2\tBIT(0)\n\n \n\n \n#define ADIS16240_DIAG_STAT_ALARM2      BIT(9)\n\n \n#define ADIS16240_DIAG_STAT_ALARM1      BIT(8)\n\n \n#define ADIS16240_DIAG_STAT_CPT_BUF_FUL BIT(7)\n\n \n#define ADIS16240_DIAG_STAT_CHKSUM      BIT(6)\n\n \n#define ADIS16240_DIAG_STAT_PWRON_FAIL_BIT  5\n\n \n#define ADIS16240_DIAG_STAT_PWRON_BUSY  BIT(4)\n\n \n#define ADIS16240_DIAG_STAT_SPI_FAIL_BIT\t3\n\n \n#define ADIS16240_DIAG_STAT_FLASH_UPT_BIT\t2\n\n \n#define ADIS16240_DIAG_STAT_POWER_HIGH_BIT\t1\n\n  \n#define ADIS16240_DIAG_STAT_POWER_LOW_BIT\t0\n\n \n\n#define ADIS16240_GLOB_CMD_RESUME\tBIT(8)\n#define ADIS16240_GLOB_CMD_SW_RESET\tBIT(7)\n#define ADIS16240_GLOB_CMD_STANDBY\tBIT(2)\n\n#define ADIS16240_ERROR_ACTIVE          BIT(14)\n\n \n\nenum adis16240_scan {\n\tADIS16240_SCAN_ACC_X,\n\tADIS16240_SCAN_ACC_Y,\n\tADIS16240_SCAN_ACC_Z,\n\tADIS16240_SCAN_SUPPLY,\n\tADIS16240_SCAN_AUX_ADC,\n\tADIS16240_SCAN_TEMP,\n};\n\nstatic ssize_t adis16240_spi_read_signed(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf,\n\t\t\t\t\t unsigned int bits)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct adis *st = iio_priv(indio_dev);\n\tint ret;\n\ts16 val = 0;\n\tunsigned int shift = 16 - bits;\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\n\tret = adis_read_reg_16(st,\n\t\t\t       this_attr->address, (u16 *)&val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & ADIS16240_ERROR_ACTIVE)\n\t\tadis_check_status(st);\n\n\tval = (s16)(val << shift) >> shift;\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t adis16240_read_12bit_signed(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\treturn adis16240_spi_read_signed(dev, attr, buf, 12);\n}\n\nstatic IIO_DEVICE_ATTR(in_accel_xyz_squared_peak_raw, 0444,\n\t\t       adis16240_read_12bit_signed, NULL,\n\t\t       ADIS16240_XYZPEAK_OUT);\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"4096\");\n\nstatic const u8 adis16240_addresses[][2] = {\n\t[ADIS16240_SCAN_ACC_X] = { ADIS16240_XACCL_OFF, ADIS16240_XPEAK_OUT },\n\t[ADIS16240_SCAN_ACC_Y] = { ADIS16240_YACCL_OFF, ADIS16240_YPEAK_OUT },\n\t[ADIS16240_SCAN_ACC_Z] = { ADIS16240_ZACCL_OFF, ADIS16240_ZPEAK_OUT },\n};\n\nstatic int adis16240_read_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int *val, int *val2,\n\t\t\t      long mask)\n{\n\tstruct adis *st = iio_priv(indio_dev);\n\tint ret;\n\tu8 addr;\n\ts16 val16;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn adis_single_conversion(indio_dev, chan,\n\t\t\t\tADIS16240_ERROR_ACTIVE, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (chan->channel == 0) {\n\t\t\t\t*val = 4;\n\t\t\t\t*val2 = 880000;  \n\t\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\tcase IIO_TEMP:\n\t\t\t*val = 244;  \n\t\t\t*val2 = 0;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_ACCEL:\n\t\t\t*val = 0;\n\t\t\t*val2 = IIO_G_TO_M_S_2(51400);  \n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_PEAK_SCALE:\n\t\t*val = 0;\n\t\t*val2 = IIO_G_TO_M_S_2(51400);  \n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = 25000 / 244 - 0x133;  \n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\taddr = adis16240_addresses[chan->scan_index][0];\n\t\tret = adis_read_reg_16(st, addr, &val16);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*val = sign_extend32(val16, 9);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_PEAK:\n\t\taddr = adis16240_addresses[chan->scan_index][1];\n\t\tret = adis_read_reg_16(st, addr, &val16);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*val = sign_extend32(val16, 9);\n\t\treturn IIO_VAL_INT;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int adis16240_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val,\n\t\t\t       int val2,\n\t\t\t       long mask)\n{\n\tstruct adis *st = iio_priv(indio_dev);\n\tu8 addr;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\taddr = adis16240_addresses[chan->scan_index][0];\n\t\treturn adis_write_reg_16(st, addr, val & GENMASK(9, 0));\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_chan_spec adis16240_channels[] = {\n\tADIS_SUPPLY_CHAN(ADIS16240_SUPPLY_OUT, ADIS16240_SCAN_SUPPLY, 0, 10),\n\tADIS_AUX_ADC_CHAN(ADIS16240_AUX_ADC, ADIS16240_SCAN_AUX_ADC, 0, 10),\n\tADIS_ACCEL_CHAN(X, ADIS16240_XACCL_OUT, ADIS16240_SCAN_ACC_X,\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS) | BIT(IIO_CHAN_INFO_PEAK),\n\t\t\t0, 10),\n\tADIS_ACCEL_CHAN(Y, ADIS16240_YACCL_OUT, ADIS16240_SCAN_ACC_Y,\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS) | BIT(IIO_CHAN_INFO_PEAK),\n\t\t\t0, 10),\n\tADIS_ACCEL_CHAN(Z, ADIS16240_ZACCL_OUT, ADIS16240_SCAN_ACC_Z,\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS) | BIT(IIO_CHAN_INFO_PEAK),\n\t\t\t0, 10),\n\tADIS_TEMP_CHAN(ADIS16240_TEMP_OUT, ADIS16240_SCAN_TEMP, 0, 10),\n\tIIO_CHAN_SOFT_TIMESTAMP(6)\n};\n\nstatic struct attribute *adis16240_attributes[] = {\n\t&iio_dev_attr_in_accel_xyz_squared_peak_raw.dev_attr.attr,\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adis16240_attribute_group = {\n\t.attrs = adis16240_attributes,\n};\n\nstatic const struct iio_info adis16240_info = {\n\t.attrs = &adis16240_attribute_group,\n\t.read_raw = adis16240_read_raw,\n\t.write_raw = adis16240_write_raw,\n\t.update_scan_mode = adis_update_scan_mode,\n};\n\nstatic const char * const adis16240_status_error_msgs[] = {\n\t[ADIS16240_DIAG_STAT_PWRON_FAIL_BIT] = \"Power on, self-test failed\",\n\t[ADIS16240_DIAG_STAT_SPI_FAIL_BIT] = \"SPI failure\",\n\t[ADIS16240_DIAG_STAT_FLASH_UPT_BIT] = \"Flash update failed\",\n\t[ADIS16240_DIAG_STAT_POWER_HIGH_BIT] = \"Power supply above 3.625V\",\n\t[ADIS16240_DIAG_STAT_POWER_LOW_BIT] = \"Power supply below 2.225V\",\n};\n\nstatic const struct adis_timeout adis16240_timeouts = {\n\t.reset_ms = ADIS16240_STARTUP_DELAY,\n\t.sw_reset_ms = ADIS16240_STARTUP_DELAY,\n\t.self_test_ms = ADIS16240_STARTUP_DELAY,\n};\n\nstatic const struct adis_data adis16240_data = {\n\t.write_delay = 35,\n\t.read_delay = 35,\n\t.msc_ctrl_reg = ADIS16240_MSC_CTRL,\n\t.glob_cmd_reg = ADIS16240_GLOB_CMD,\n\t.diag_stat_reg = ADIS16240_DIAG_STAT,\n\n\t.self_test_mask = ADIS16240_MSC_CTRL_SELF_TEST_EN,\n\t.self_test_reg = ADIS16240_MSC_CTRL,\n\t.self_test_no_autoclear = true,\n\t.timeouts = &adis16240_timeouts,\n\n\t.status_error_msgs = adis16240_status_error_msgs,\n\t.status_error_mask = BIT(ADIS16240_DIAG_STAT_PWRON_FAIL_BIT) |\n\t\tBIT(ADIS16240_DIAG_STAT_SPI_FAIL_BIT) |\n\t\tBIT(ADIS16240_DIAG_STAT_FLASH_UPT_BIT) |\n\t\tBIT(ADIS16240_DIAG_STAT_POWER_HIGH_BIT) |\n\t\tBIT(ADIS16240_DIAG_STAT_POWER_LOW_BIT),\n};\n\nstatic int adis16240_probe(struct spi_device *spi)\n{\n\tint ret;\n\tstruct adis *st;\n\tstruct iio_dev *indio_dev;\n\n\t \n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tst = iio_priv(indio_dev);\n\t \n\tspi_set_drvdata(spi, indio_dev);\n\n\tindio_dev->name = spi->dev.driver->name;\n\tindio_dev->info = &adis16240_info;\n\tindio_dev->channels = adis16240_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adis16240_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tspi->mode = SPI_MODE_3;\n\tret = spi_setup(spi);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"spi_setup failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = adis_init(st, indio_dev, spi, &adis16240_data);\n\tif (ret)\n\t\treturn ret;\n\tret = devm_adis_setup_buffer_and_trigger(st, indio_dev, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = __adis_initial_startup(st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id adis16240_of_match[] = {\n\t{ .compatible = \"adi,adis16240\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, adis16240_of_match);\n\nstatic struct spi_driver adis16240_driver = {\n\t.driver = {\n\t\t.name = \"adis16240\",\n\t\t.of_match_table = adis16240_of_match,\n\t},\n\t.probe = adis16240_probe,\n};\nmodule_spi_driver(adis16240_driver);\n\nMODULE_AUTHOR(\"Barry Song <21cnbao@gmail.com>\");\nMODULE_DESCRIPTION(\"Analog Devices Programmable Impact Sensor and Recorder\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"spi:adis16240\");\nMODULE_IMPORT_NS(IIO_ADISLIB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}