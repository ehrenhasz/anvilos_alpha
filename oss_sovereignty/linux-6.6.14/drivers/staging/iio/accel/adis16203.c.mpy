{
  "module_name": "adis16203.c",
  "hash_id": "3d3f368bf8f6b81390041521c5074b410c081e1260e911f85b8ad36716a92d71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/iio/accel/adis16203.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/imu/adis.h>\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n\n#define ADIS16203_STARTUP_DELAY 220  \n\n \n#define ADIS16203_FLASH_CNT      0x00\n\n \n#define ADIS16203_SUPPLY_OUT     0x02\n\n \n#define ADIS16203_AUX_ADC        0x08\n\n \n#define ADIS16203_TEMP_OUT       0x0A\n\n \n#define ADIS16203_XINCL_OUT      0x0C\n\n \n#define ADIS16203_YINCL_OUT      0x0E\n\n \n#define ADIS16203_INCL_NULL      0x18\n\n \n#define ADIS16203_ALM_MAG1       0x20\n\n \n#define ADIS16203_ALM_MAG2       0x22\n\n \n#define ADIS16203_ALM_SMPL1      0x24\n\n \n#define ADIS16203_ALM_SMPL2      0x26\n\n \n#define ADIS16203_ALM_CTRL       0x28\n\n \n#define ADIS16203_AUX_DAC        0x30\n\n \n#define ADIS16203_GPIO_CTRL      0x32\n\n \n#define ADIS16203_MSC_CTRL       0x34\n\n \n#define ADIS16203_SMPL_PRD       0x36\n\n \n#define ADIS16203_AVG_CNT        0x38\n\n \n#define ADIS16203_SLP_CNT        0x3A\n\n \n#define ADIS16203_DIAG_STAT      0x3C\n\n \n#define ADIS16203_GLOB_CMD       0x3E\n\n \n\n \n#define ADIS16203_MSC_CTRL_PWRUP_SELF_TEST      BIT(10)\n\n \n#define ADIS16203_MSC_CTRL_REVERSE_ROT_EN       BIT(9)\n\n \n#define ADIS16203_MSC_CTRL_SELF_TEST_EN         BIT(8)\n\n \n#define ADIS16203_MSC_CTRL_DATA_RDY_EN          BIT(2)\n\n \n#define ADIS16203_MSC_CTRL_ACTIVE_HIGH          BIT(1)\n\n \n#define ADIS16203_MSC_CTRL_DATA_RDY_DIO1        BIT(0)\n\n \n\n \n#define ADIS16203_DIAG_STAT_ALARM2        BIT(9)\n\n \n#define ADIS16203_DIAG_STAT_ALARM1        BIT(8)\n\n \n#define ADIS16203_DIAG_STAT_SELFTEST_FAIL_BIT 5\n\n \n#define ADIS16203_DIAG_STAT_SPI_FAIL_BIT      3\n\n \n#define ADIS16203_DIAG_STAT_FLASH_UPT_BIT     2\n\n \n#define ADIS16203_DIAG_STAT_POWER_HIGH_BIT    1\n\n \n#define ADIS16203_DIAG_STAT_POWER_LOW_BIT     0\n\n \n\n#define ADIS16203_GLOB_CMD_SW_RESET     BIT(7)\n#define ADIS16203_GLOB_CMD_CLEAR_STAT   BIT(4)\n#define ADIS16203_GLOB_CMD_FACTORY_CAL  BIT(1)\n\n#define ADIS16203_ERROR_ACTIVE          BIT(14)\n\nenum adis16203_scan {\n\t ADIS16203_SCAN_INCLI_X,\n\t ADIS16203_SCAN_INCLI_Y,\n\t ADIS16203_SCAN_SUPPLY,\n\t ADIS16203_SCAN_AUX_ADC,\n\t ADIS16203_SCAN_TEMP,\n};\n\n#define DRIVER_NAME\t\t\"adis16203\"\n\nstatic const u8 adis16203_addresses[] = {\n\t[ADIS16203_SCAN_INCLI_X] = ADIS16203_INCL_NULL,\n};\n\nstatic int adis16203_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val,\n\t\t\t       int val2,\n\t\t\t       long mask)\n{\n\tstruct adis *st = iio_priv(indio_dev);\n\t \n\tu8 addr = adis16203_addresses[chan->scan_index];\n\n\treturn adis_write_reg_16(st, addr, val & 0x3FFF);\n}\n\nstatic int adis16203_read_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int *val, int *val2,\n\t\t\t      long mask)\n{\n\tstruct adis *st = iio_priv(indio_dev);\n\tint ret;\n\tu8 addr;\n\ts16 val16;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn adis_single_conversion(indio_dev, chan,\n\t\t\t\tADIS16203_ERROR_ACTIVE, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (chan->channel == 0) {\n\t\t\t\t*val = 1;\n\t\t\t\t*val2 = 220000;  \n\t\t\t} else {\n\t\t\t\t*val = 0;\n\t\t\t\t*val2 = 610000;  \n\t\t\t}\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_TEMP:\n\t\t\t*val = -470;  \n\t\t\t*val2 = 0;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_INCLI:\n\t\t\t*val = 0;\n\t\t\t*val2 = 25000;  \n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = 25000 / -470 - 1278;  \n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\taddr = adis16203_addresses[chan->scan_index];\n\t\tret = adis_read_reg_16(st, addr, &val16);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*val = sign_extend32(val16, 13);\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_chan_spec adis16203_channels[] = {\n\tADIS_SUPPLY_CHAN(ADIS16203_SUPPLY_OUT, ADIS16203_SCAN_SUPPLY, 0, 12),\n\tADIS_AUX_ADC_CHAN(ADIS16203_AUX_ADC, ADIS16203_SCAN_AUX_ADC, 0, 12),\n\tADIS_INCLI_CHAN(X, ADIS16203_XINCL_OUT, ADIS16203_SCAN_INCLI_X,\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS), 0, 14),\n\t \n\tADIS_INCLI_CHAN(Y, ADIS16203_YINCL_OUT, ADIS16203_SCAN_INCLI_Y,\n\t\t\t0, 0, 14),\n\tADIS_TEMP_CHAN(ADIS16203_TEMP_OUT, ADIS16203_SCAN_TEMP, 0, 12),\n\tIIO_CHAN_SOFT_TIMESTAMP(5),\n};\n\nstatic const struct iio_info adis16203_info = {\n\t.read_raw = adis16203_read_raw,\n\t.write_raw = adis16203_write_raw,\n\t.update_scan_mode = adis_update_scan_mode,\n};\n\nstatic const char * const adis16203_status_error_msgs[] = {\n\t[ADIS16203_DIAG_STAT_SELFTEST_FAIL_BIT] = \"Self test failure\",\n\t[ADIS16203_DIAG_STAT_SPI_FAIL_BIT] = \"SPI failure\",\n\t[ADIS16203_DIAG_STAT_FLASH_UPT_BIT] = \"Flash update failed\",\n\t[ADIS16203_DIAG_STAT_POWER_HIGH_BIT] = \"Power supply above 3.625V\",\n\t[ADIS16203_DIAG_STAT_POWER_LOW_BIT] = \"Power supply below 2.975V\",\n};\n\nstatic const struct adis_timeout adis16203_timeouts = {\n\t.reset_ms = ADIS16203_STARTUP_DELAY,\n\t.sw_reset_ms = ADIS16203_STARTUP_DELAY,\n\t.self_test_ms = ADIS16203_STARTUP_DELAY\n};\n\nstatic const struct adis_data adis16203_data = {\n\t.read_delay = 20,\n\t.msc_ctrl_reg = ADIS16203_MSC_CTRL,\n\t.glob_cmd_reg = ADIS16203_GLOB_CMD,\n\t.diag_stat_reg = ADIS16203_DIAG_STAT,\n\n\t.self_test_mask = ADIS16203_MSC_CTRL_SELF_TEST_EN,\n\t.self_test_reg = ADIS16203_MSC_CTRL,\n\t.self_test_no_autoclear = true,\n\t.timeouts = &adis16203_timeouts,\n\n\t.status_error_msgs = adis16203_status_error_msgs,\n\t.status_error_mask = BIT(ADIS16203_DIAG_STAT_SELFTEST_FAIL_BIT) |\n\t\tBIT(ADIS16203_DIAG_STAT_SPI_FAIL_BIT) |\n\t\tBIT(ADIS16203_DIAG_STAT_FLASH_UPT_BIT) |\n\t\tBIT(ADIS16203_DIAG_STAT_POWER_HIGH_BIT) |\n\t\tBIT(ADIS16203_DIAG_STAT_POWER_LOW_BIT),\n};\n\nstatic int adis16203_probe(struct spi_device *spi)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct adis *st;\n\n\t \n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tst = iio_priv(indio_dev);\n\t \n\tspi_set_drvdata(spi, indio_dev);\n\n\tindio_dev->name = spi->dev.driver->name;\n\tindio_dev->channels = adis16203_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adis16203_channels);\n\tindio_dev->info = &adis16203_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = adis_init(st, indio_dev, spi, &adis16203_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_adis_setup_buffer_and_trigger(st, indio_dev, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = __adis_initial_startup(st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id adis16203_of_match[] = {\n\t{ .compatible = \"adi,adis16203\" },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, adis16203_of_match);\n\nstatic struct spi_driver adis16203_driver = {\n\t.driver = {\n\t\t.name = \"adis16203\",\n\t\t.of_match_table = adis16203_of_match,\n\t},\n\t.probe = adis16203_probe,\n};\nmodule_spi_driver(adis16203_driver);\n\nMODULE_AUTHOR(\"Barry Song <21cnbao@gmail.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADIS16203 Programmable 360 Degrees Inclinometer\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"spi:adis16203\");\nMODULE_IMPORT_NS(IIO_ADISLIB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}