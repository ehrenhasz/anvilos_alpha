{
  "module_name": "ad9832.c",
  "hash_id": "974eb3ec84a6c573efd82225799288e5f34c71b45c1a9772e03f13d85a5a0d66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/iio/frequency/ad9832.c",
  "human_readable_source": "\n \n\n#include <asm/div64.h>\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/sysfs.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include \"ad9832.h\"\n\n#include \"dds.h\"\n\n \n\n#define AD9832_FREQ0LL\t\t0x0\n#define AD9832_FREQ0HL\t\t0x1\n#define AD9832_FREQ0LM\t\t0x2\n#define AD9832_FREQ0HM\t\t0x3\n#define AD9832_FREQ1LL\t\t0x4\n#define AD9832_FREQ1HL\t\t0x5\n#define AD9832_FREQ1LM\t\t0x6\n#define AD9832_FREQ1HM\t\t0x7\n#define AD9832_PHASE0L\t\t0x8\n#define AD9832_PHASE0H\t\t0x9\n#define AD9832_PHASE1L\t\t0xA\n#define AD9832_PHASE1H\t\t0xB\n#define AD9832_PHASE2L\t\t0xC\n#define AD9832_PHASE2H\t\t0xD\n#define AD9832_PHASE3L\t\t0xE\n#define AD9832_PHASE3H\t\t0xF\n\n#define AD9832_PHASE_SYM\t0x10\n#define AD9832_FREQ_SYM\t\t0x11\n#define AD9832_PINCTRL_EN\t0x12\n#define AD9832_OUTPUT_EN\t0x13\n\n \n\n#define AD9832_CMD_PHA8BITSW\t0x1\n#define AD9832_CMD_PHA16BITSW\t0x0\n#define AD9832_CMD_FRE8BITSW\t0x3\n#define AD9832_CMD_FRE16BITSW\t0x2\n#define AD9832_CMD_FPSELECT\t0x6\n#define AD9832_CMD_SYNCSELSRC\t0x8\n#define AD9832_CMD_SLEEPRESCLR\t0xC\n\n#define AD9832_FREQ\t\tBIT(11)\n#define AD9832_PHASE(x)\t\t(((x) & 3) << 9)\n#define AD9832_SYNC\t\tBIT(13)\n#define AD9832_SELSRC\t\tBIT(12)\n#define AD9832_SLEEP\t\tBIT(13)\n#define AD9832_RESET\t\tBIT(12)\n#define AD9832_CLR\t\tBIT(11)\n#define CMD_SHIFT\t\t12\n#define ADD_SHIFT\t\t8\n#define AD9832_FREQ_BITS\t32\n#define AD9832_PHASE_BITS\t12\n#define RES_MASK(bits)\t\t((1 << (bits)) - 1)\n\n \n\nstruct ad9832_state {\n\tstruct spi_device\t\t*spi;\n\tstruct regulator\t\t*avdd;\n\tstruct regulator\t\t*dvdd;\n\tstruct clk\t\t\t*mclk;\n\tunsigned short\t\t\tctrl_fp;\n\tunsigned short\t\t\tctrl_ss;\n\tunsigned short\t\t\tctrl_src;\n\tstruct spi_transfer\t\txfer;\n\tstruct spi_message\t\tmsg;\n\tstruct spi_transfer\t\tfreq_xfer[4];\n\tstruct spi_message\t\tfreq_msg;\n\tstruct spi_transfer\t\tphase_xfer[2];\n\tstruct spi_message\t\tphase_msg;\n\tstruct mutex\t\t\tlock;\t \n\t \n\tunion {\n\t\t__be16\t\t\tfreq_data[4];\n\t\t__be16\t\t\tphase_data[2];\n\t\t__be16\t\t\tdata;\n\t} __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic unsigned long ad9832_calc_freqreg(unsigned long mclk, unsigned long fout)\n{\n\tunsigned long long freqreg = (u64)fout *\n\t\t\t\t     (u64)((u64)1L << AD9832_FREQ_BITS);\n\tdo_div(freqreg, mclk);\n\treturn freqreg;\n}\n\nstatic int ad9832_write_frequency(struct ad9832_state *st,\n\t\t\t\t  unsigned int addr, unsigned long fout)\n{\n\tunsigned long regval;\n\n\tif (fout > (clk_get_rate(st->mclk) / 2))\n\t\treturn -EINVAL;\n\n\tregval = ad9832_calc_freqreg(clk_get_rate(st->mclk), fout);\n\n\tst->freq_data[0] = cpu_to_be16((AD9832_CMD_FRE8BITSW << CMD_SHIFT) |\n\t\t\t\t\t(addr << ADD_SHIFT) |\n\t\t\t\t\t((regval >> 24) & 0xFF));\n\tst->freq_data[1] = cpu_to_be16((AD9832_CMD_FRE16BITSW << CMD_SHIFT) |\n\t\t\t\t\t((addr - 1) << ADD_SHIFT) |\n\t\t\t\t\t((regval >> 16) & 0xFF));\n\tst->freq_data[2] = cpu_to_be16((AD9832_CMD_FRE8BITSW << CMD_SHIFT) |\n\t\t\t\t\t((addr - 2) << ADD_SHIFT) |\n\t\t\t\t\t((regval >> 8) & 0xFF));\n\tst->freq_data[3] = cpu_to_be16((AD9832_CMD_FRE16BITSW << CMD_SHIFT) |\n\t\t\t\t\t((addr - 3) << ADD_SHIFT) |\n\t\t\t\t\t((regval >> 0) & 0xFF));\n\n\treturn spi_sync(st->spi, &st->freq_msg);\n}\n\nstatic int ad9832_write_phase(struct ad9832_state *st,\n\t\t\t      unsigned long addr, unsigned long phase)\n{\n\tif (phase > BIT(AD9832_PHASE_BITS))\n\t\treturn -EINVAL;\n\n\tst->phase_data[0] = cpu_to_be16((AD9832_CMD_PHA8BITSW << CMD_SHIFT) |\n\t\t\t\t\t(addr << ADD_SHIFT) |\n\t\t\t\t\t((phase >> 8) & 0xFF));\n\tst->phase_data[1] = cpu_to_be16((AD9832_CMD_PHA16BITSW << CMD_SHIFT) |\n\t\t\t\t\t((addr - 1) << ADD_SHIFT) |\n\t\t\t\t\t(phase & 0xFF));\n\n\treturn spi_sync(st->spi, &st->phase_msg);\n}\n\nstatic ssize_t ad9832_write(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad9832_state *st = iio_priv(indio_dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint ret;\n\tunsigned long val;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\tgoto error_ret;\n\n\tmutex_lock(&st->lock);\n\tswitch ((u32)this_attr->address) {\n\tcase AD9832_FREQ0HM:\n\tcase AD9832_FREQ1HM:\n\t\tret = ad9832_write_frequency(st, this_attr->address, val);\n\t\tbreak;\n\tcase AD9832_PHASE0H:\n\tcase AD9832_PHASE1H:\n\tcase AD9832_PHASE2H:\n\tcase AD9832_PHASE3H:\n\t\tret = ad9832_write_phase(st, this_attr->address, val);\n\t\tbreak;\n\tcase AD9832_PINCTRL_EN:\n\t\tif (val)\n\t\t\tst->ctrl_ss &= ~AD9832_SELSRC;\n\t\telse\n\t\t\tst->ctrl_ss |= AD9832_SELSRC;\n\t\tst->data = cpu_to_be16((AD9832_CMD_SYNCSELSRC << CMD_SHIFT) |\n\t\t\t\t\tst->ctrl_ss);\n\t\tret = spi_sync(st->spi, &st->msg);\n\t\tbreak;\n\tcase AD9832_FREQ_SYM:\n\t\tif (val == 1) {\n\t\t\tst->ctrl_fp |= AD9832_FREQ;\n\t\t} else if (val == 0) {\n\t\t\tst->ctrl_fp &= ~AD9832_FREQ;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tst->data = cpu_to_be16((AD9832_CMD_FPSELECT << CMD_SHIFT) |\n\t\t\t\t\tst->ctrl_fp);\n\t\tret = spi_sync(st->spi, &st->msg);\n\t\tbreak;\n\tcase AD9832_PHASE_SYM:\n\t\tif (val > 3) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tst->ctrl_fp &= ~AD9832_PHASE(3);\n\t\tst->ctrl_fp |= AD9832_PHASE(val);\n\n\t\tst->data = cpu_to_be16((AD9832_CMD_FPSELECT << CMD_SHIFT) |\n\t\t\t\t\tst->ctrl_fp);\n\t\tret = spi_sync(st->spi, &st->msg);\n\t\tbreak;\n\tcase AD9832_OUTPUT_EN:\n\t\tif (val)\n\t\t\tst->ctrl_src &= ~(AD9832_RESET | AD9832_SLEEP |\n\t\t\t\t\tAD9832_CLR);\n\t\telse\n\t\t\tst->ctrl_src |= AD9832_RESET;\n\n\t\tst->data = cpu_to_be16((AD9832_CMD_SLEEPRESCLR << CMD_SHIFT) |\n\t\t\t\t\tst->ctrl_src);\n\t\tret = spi_sync(st->spi, &st->msg);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t}\n\tmutex_unlock(&st->lock);\n\nerror_ret:\n\treturn ret ? ret : len;\n}\n\n \n\nstatic IIO_DEV_ATTR_FREQ(0, 0, 0200, NULL, ad9832_write, AD9832_FREQ0HM);\nstatic IIO_DEV_ATTR_FREQ(0, 1, 0200, NULL, ad9832_write, AD9832_FREQ1HM);\nstatic IIO_DEV_ATTR_FREQSYMBOL(0, 0200, NULL, ad9832_write, AD9832_FREQ_SYM);\nstatic IIO_CONST_ATTR_FREQ_SCALE(0, \"1\");  \n\nstatic IIO_DEV_ATTR_PHASE(0, 0, 0200, NULL, ad9832_write, AD9832_PHASE0H);\nstatic IIO_DEV_ATTR_PHASE(0, 1, 0200, NULL, ad9832_write, AD9832_PHASE1H);\nstatic IIO_DEV_ATTR_PHASE(0, 2, 0200, NULL, ad9832_write, AD9832_PHASE2H);\nstatic IIO_DEV_ATTR_PHASE(0, 3, 0200, NULL, ad9832_write, AD9832_PHASE3H);\nstatic IIO_DEV_ATTR_PHASESYMBOL(0, 0200, NULL,\n\t\t\t\tad9832_write, AD9832_PHASE_SYM);\nstatic IIO_CONST_ATTR_PHASE_SCALE(0, \"0.0015339808\");  \n\nstatic IIO_DEV_ATTR_PINCONTROL_EN(0, 0200, NULL,\n\t\t\t\tad9832_write, AD9832_PINCTRL_EN);\nstatic IIO_DEV_ATTR_OUT_ENABLE(0, 0200, NULL,\n\t\t\t\tad9832_write, AD9832_OUTPUT_EN);\n\nstatic struct attribute *ad9832_attributes[] = {\n\t&iio_dev_attr_out_altvoltage0_frequency0.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_frequency1.dev_attr.attr,\n\t&iio_const_attr_out_altvoltage0_frequency_scale.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_phase0.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_phase1.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_phase2.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_phase3.dev_attr.attr,\n\t&iio_const_attr_out_altvoltage0_phase_scale.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_pincontrol_en.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_frequencysymbol.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_phasesymbol.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_out_enable.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad9832_attribute_group = {\n\t.attrs = ad9832_attributes,\n};\n\nstatic const struct iio_info ad9832_info = {\n\t.attrs = &ad9832_attribute_group,\n};\n\nstatic void ad9832_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic void ad9832_clk_disable(void *clk)\n{\n\tclk_disable_unprepare(clk);\n}\n\nstatic int ad9832_probe(struct spi_device *spi)\n{\n\tstruct ad9832_platform_data *pdata = dev_get_platdata(&spi->dev);\n\tstruct iio_dev *indio_dev;\n\tstruct ad9832_state *st;\n\tint ret;\n\n\tif (!pdata) {\n\t\tdev_dbg(&spi->dev, \"no platform data?\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->avdd = devm_regulator_get(&spi->dev, \"avdd\");\n\tif (IS_ERR(st->avdd))\n\t\treturn PTR_ERR(st->avdd);\n\n\tret = regulator_enable(st->avdd);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to enable specified AVDD supply\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, ad9832_reg_disable, st->avdd);\n\tif (ret)\n\t\treturn ret;\n\n\tst->dvdd = devm_regulator_get(&spi->dev, \"dvdd\");\n\tif (IS_ERR(st->dvdd))\n\t\treturn PTR_ERR(st->dvdd);\n\n\tret = regulator_enable(st->dvdd);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to enable specified DVDD supply\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, ad9832_reg_disable, st->dvdd);\n\tif (ret)\n\t\treturn ret;\n\n\tst->mclk = devm_clk_get(&spi->dev, \"mclk\");\n\tif (IS_ERR(st->mclk))\n\t\treturn PTR_ERR(st->mclk);\n\n\tret = clk_prepare_enable(st->mclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, ad9832_clk_disable, st->mclk);\n\tif (ret)\n\t\treturn ret;\n\n\tst->spi = spi;\n\tmutex_init(&st->lock);\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &ad9832_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\t \n\n\tst->xfer.tx_buf = &st->data;\n\tst->xfer.len = 2;\n\n\tspi_message_init(&st->msg);\n\tspi_message_add_tail(&st->xfer, &st->msg);\n\n\tst->freq_xfer[0].tx_buf = &st->freq_data[0];\n\tst->freq_xfer[0].len = 2;\n\tst->freq_xfer[0].cs_change = 1;\n\tst->freq_xfer[1].tx_buf = &st->freq_data[1];\n\tst->freq_xfer[1].len = 2;\n\tst->freq_xfer[1].cs_change = 1;\n\tst->freq_xfer[2].tx_buf = &st->freq_data[2];\n\tst->freq_xfer[2].len = 2;\n\tst->freq_xfer[2].cs_change = 1;\n\tst->freq_xfer[3].tx_buf = &st->freq_data[3];\n\tst->freq_xfer[3].len = 2;\n\n\tspi_message_init(&st->freq_msg);\n\tspi_message_add_tail(&st->freq_xfer[0], &st->freq_msg);\n\tspi_message_add_tail(&st->freq_xfer[1], &st->freq_msg);\n\tspi_message_add_tail(&st->freq_xfer[2], &st->freq_msg);\n\tspi_message_add_tail(&st->freq_xfer[3], &st->freq_msg);\n\n\tst->phase_xfer[0].tx_buf = &st->phase_data[0];\n\tst->phase_xfer[0].len = 2;\n\tst->phase_xfer[0].cs_change = 1;\n\tst->phase_xfer[1].tx_buf = &st->phase_data[1];\n\tst->phase_xfer[1].len = 2;\n\n\tspi_message_init(&st->phase_msg);\n\tspi_message_add_tail(&st->phase_xfer[0], &st->phase_msg);\n\tspi_message_add_tail(&st->phase_xfer[1], &st->phase_msg);\n\n\tst->ctrl_src = AD9832_SLEEP | AD9832_RESET | AD9832_CLR;\n\tst->data = cpu_to_be16((AD9832_CMD_SLEEPRESCLR << CMD_SHIFT) |\n\t\t\t\t\tst->ctrl_src);\n\tret = spi_sync(st->spi, &st->msg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"device init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ad9832_write_frequency(st, AD9832_FREQ0HM, pdata->freq0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad9832_write_frequency(st, AD9832_FREQ1HM, pdata->freq1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad9832_write_phase(st, AD9832_PHASE0H, pdata->phase0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad9832_write_phase(st, AD9832_PHASE1H, pdata->phase1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad9832_write_phase(st, AD9832_PHASE2H, pdata->phase2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad9832_write_phase(st, AD9832_PHASE3H, pdata->phase3);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad9832_id[] = {\n\t{\"ad9832\", 0},\n\t{\"ad9835\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad9832_id);\n\nstatic struct spi_driver ad9832_driver = {\n\t.driver = {\n\t\t.name\t= \"ad9832\",\n\t},\n\t.probe\t\t= ad9832_probe,\n\t.id_table\t= ad9832_id,\n};\nmodule_spi_driver(ad9832_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD9832/AD9835 DDS\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}