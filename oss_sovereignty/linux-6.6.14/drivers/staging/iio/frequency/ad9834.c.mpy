{
  "module_name": "ad9834.c",
  "hash_id": "6660e1aa5c457a3d645827eccb8a286e9bc171d478e64b228fcf18eb6fb009ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/iio/frequency/ad9834.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/list.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <asm/div64.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include \"dds.h\"\n\n#include \"ad9834.h\"\n\n \n\n#define AD9834_REG_CMD\t\t0\n#define AD9834_REG_FREQ0\tBIT(14)\n#define AD9834_REG_FREQ1\tBIT(15)\n#define AD9834_REG_PHASE0\t(BIT(15) | BIT(14))\n#define AD9834_REG_PHASE1\t(BIT(15) | BIT(14) | BIT(13))\n\n \n\n#define AD9834_B28\t\tBIT(13)\n#define AD9834_HLB\t\tBIT(12)\n#define AD9834_FSEL\t\tBIT(11)\n#define AD9834_PSEL\t\tBIT(10)\n#define AD9834_PIN_SW\t\tBIT(9)\n#define AD9834_RESET\t\tBIT(8)\n#define AD9834_SLEEP1\t\tBIT(7)\n#define AD9834_SLEEP12\t\tBIT(6)\n#define AD9834_OPBITEN\t\tBIT(5)\n#define AD9834_SIGN_PIB\t\tBIT(4)\n#define AD9834_DIV2\t\tBIT(3)\n#define AD9834_MODE\t\tBIT(1)\n\n#define AD9834_FREQ_BITS\t28\n#define AD9834_PHASE_BITS\t12\n\n#define RES_MASK(bits)\t(BIT(bits) - 1)\n\n \n\nstruct ad9834_state {\n\tstruct spi_device\t\t*spi;\n\tstruct clk\t\t\t*mclk;\n\tunsigned short\t\t\tcontrol;\n\tunsigned short\t\t\tdevid;\n\tstruct spi_transfer\t\txfer;\n\tstruct spi_message\t\tmsg;\n\tstruct spi_transfer\t\tfreq_xfer[2];\n\tstruct spi_message\t\tfreq_msg;\n\tstruct mutex                    lock;    \n\n\t \n\t__be16\t\t\t\tdata __aligned(IIO_DMA_MINALIGN);\n\t__be16\t\t\t\tfreq_data[2];\n};\n\n \n\nenum ad9834_supported_device_ids {\n\tID_AD9833,\n\tID_AD9834,\n\tID_AD9837,\n\tID_AD9838,\n};\n\nstatic unsigned int ad9834_calc_freqreg(unsigned long mclk, unsigned long fout)\n{\n\tunsigned long long freqreg = (u64)fout * (u64)BIT(AD9834_FREQ_BITS);\n\n\tdo_div(freqreg, mclk);\n\treturn freqreg;\n}\n\nstatic int ad9834_write_frequency(struct ad9834_state *st,\n\t\t\t\t  unsigned long addr, unsigned long fout)\n{\n\tunsigned long clk_freq;\n\tunsigned long regval;\n\n\tclk_freq = clk_get_rate(st->mclk);\n\n\tif (fout > (clk_freq / 2))\n\t\treturn -EINVAL;\n\n\tregval = ad9834_calc_freqreg(clk_freq, fout);\n\n\tst->freq_data[0] = cpu_to_be16(addr | (regval &\n\t\t\t\t       RES_MASK(AD9834_FREQ_BITS / 2)));\n\tst->freq_data[1] = cpu_to_be16(addr | ((regval >>\n\t\t\t\t       (AD9834_FREQ_BITS / 2)) &\n\t\t\t\t       RES_MASK(AD9834_FREQ_BITS / 2)));\n\n\treturn spi_sync(st->spi, &st->freq_msg);\n}\n\nstatic int ad9834_write_phase(struct ad9834_state *st,\n\t\t\t      unsigned long addr, unsigned long phase)\n{\n\tif (phase > BIT(AD9834_PHASE_BITS))\n\t\treturn -EINVAL;\n\tst->data = cpu_to_be16(addr | phase);\n\n\treturn spi_sync(st->spi, &st->msg);\n}\n\nstatic ssize_t ad9834_write(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf,\n\t\t\t    size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad9834_state *st = iio_priv(indio_dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint ret;\n\tunsigned long val;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\tswitch ((u32)this_attr->address) {\n\tcase AD9834_REG_FREQ0:\n\tcase AD9834_REG_FREQ1:\n\t\tret = ad9834_write_frequency(st, this_attr->address, val);\n\t\tbreak;\n\tcase AD9834_REG_PHASE0:\n\tcase AD9834_REG_PHASE1:\n\t\tret = ad9834_write_phase(st, this_attr->address, val);\n\t\tbreak;\n\tcase AD9834_OPBITEN:\n\t\tif (st->control & AD9834_MODE) {\n\t\t\tret = -EINVAL;   \n\t\t\tbreak;\n\t\t}\n\n\t\tif (val)\n\t\t\tst->control |= AD9834_OPBITEN;\n\t\telse\n\t\t\tst->control &= ~AD9834_OPBITEN;\n\n\t\tst->data = cpu_to_be16(AD9834_REG_CMD | st->control);\n\t\tret = spi_sync(st->spi, &st->msg);\n\t\tbreak;\n\tcase AD9834_PIN_SW:\n\t\tif (val)\n\t\t\tst->control |= AD9834_PIN_SW;\n\t\telse\n\t\t\tst->control &= ~AD9834_PIN_SW;\n\t\tst->data = cpu_to_be16(AD9834_REG_CMD | st->control);\n\t\tret = spi_sync(st->spi, &st->msg);\n\t\tbreak;\n\tcase AD9834_FSEL:\n\tcase AD9834_PSEL:\n\t\tif (!val) {\n\t\t\tst->control &= ~(this_attr->address | AD9834_PIN_SW);\n\t\t} else if (val == 1) {\n\t\t\tst->control |= this_attr->address;\n\t\t\tst->control &= ~AD9834_PIN_SW;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tst->data = cpu_to_be16(AD9834_REG_CMD | st->control);\n\t\tret = spi_sync(st->spi, &st->msg);\n\t\tbreak;\n\tcase AD9834_RESET:\n\t\tif (val)\n\t\t\tst->control &= ~AD9834_RESET;\n\t\telse\n\t\t\tst->control |= AD9834_RESET;\n\n\t\tst->data = cpu_to_be16(AD9834_REG_CMD | st->control);\n\t\tret = spi_sync(st->spi, &st->msg);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret ? ret : len;\n}\n\nstatic ssize_t ad9834_store_wavetype(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf,\n\t\t\t\t     size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad9834_state *st = iio_priv(indio_dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint ret = 0;\n\tbool is_ad9833_7 = (st->devid == ID_AD9833) || (st->devid == ID_AD9837);\n\n\tmutex_lock(&st->lock);\n\n\tswitch ((u32)this_attr->address) {\n\tcase 0:\n\t\tif (sysfs_streq(buf, \"sine\")) {\n\t\t\tst->control &= ~AD9834_MODE;\n\t\t\tif (is_ad9833_7)\n\t\t\t\tst->control &= ~AD9834_OPBITEN;\n\t\t} else if (sysfs_streq(buf, \"triangle\")) {\n\t\t\tif (is_ad9833_7) {\n\t\t\t\tst->control &= ~AD9834_OPBITEN;\n\t\t\t\tst->control |= AD9834_MODE;\n\t\t\t} else if (st->control & AD9834_OPBITEN) {\n\t\t\t\tret = -EINVAL;\t \n\t\t\t} else {\n\t\t\t\tst->control |= AD9834_MODE;\n\t\t\t}\n\t\t} else if (is_ad9833_7 && sysfs_streq(buf, \"square\")) {\n\t\t\tst->control &= ~AD9834_MODE;\n\t\t\tst->control |= AD9834_OPBITEN;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tbreak;\n\tcase 1:\n\t\tif (sysfs_streq(buf, \"square\") &&\n\t\t    !(st->control & AD9834_MODE)) {\n\t\t\tst->control &= ~AD9834_MODE;\n\t\t\tst->control |= AD9834_OPBITEN;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\tst->data = cpu_to_be16(AD9834_REG_CMD | st->control);\n\t\tret = spi_sync(st->spi, &st->msg);\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret ? ret : len;\n}\n\nstatic\nssize_t ad9834_show_out0_wavetype_available(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad9834_state *st = iio_priv(indio_dev);\n\tchar *str;\n\n\tif (st->devid == ID_AD9833 || st->devid == ID_AD9837)\n\t\tstr = \"sine triangle square\";\n\telse if (st->control & AD9834_OPBITEN)\n\t\tstr = \"sine\";\n\telse\n\t\tstr = \"sine triangle\";\n\n\treturn sprintf(buf, \"%s\\n\", str);\n}\n\nstatic IIO_DEVICE_ATTR(out_altvoltage0_out0_wavetype_available, 0444,\n\t\t       ad9834_show_out0_wavetype_available, NULL, 0);\n\nstatic\nssize_t ad9834_show_out1_wavetype_available(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad9834_state *st = iio_priv(indio_dev);\n\tchar *str;\n\n\tif (st->control & AD9834_MODE)\n\t\tstr = \"\";\n\telse\n\t\tstr = \"square\";\n\n\treturn sprintf(buf, \"%s\\n\", str);\n}\n\nstatic IIO_DEVICE_ATTR(out_altvoltage0_out1_wavetype_available, 0444,\n\t\t       ad9834_show_out1_wavetype_available, NULL, 0);\n\n \n\nstatic IIO_DEV_ATTR_FREQ(0, 0, 0200, NULL, ad9834_write, AD9834_REG_FREQ0);\nstatic IIO_DEV_ATTR_FREQ(0, 1, 0200, NULL, ad9834_write, AD9834_REG_FREQ1);\nstatic IIO_DEV_ATTR_FREQSYMBOL(0, 0200, NULL, ad9834_write, AD9834_FSEL);\nstatic IIO_CONST_ATTR_FREQ_SCALE(0, \"1\");  \n\nstatic IIO_DEV_ATTR_PHASE(0, 0, 0200, NULL, ad9834_write, AD9834_REG_PHASE0);\nstatic IIO_DEV_ATTR_PHASE(0, 1, 0200, NULL, ad9834_write, AD9834_REG_PHASE1);\nstatic IIO_DEV_ATTR_PHASESYMBOL(0, 0200, NULL, ad9834_write, AD9834_PSEL);\nstatic IIO_CONST_ATTR_PHASE_SCALE(0, \"0.0015339808\");  \n\nstatic IIO_DEV_ATTR_PINCONTROL_EN(0, 0200, NULL, ad9834_write, AD9834_PIN_SW);\nstatic IIO_DEV_ATTR_OUT_ENABLE(0, 0200, NULL, ad9834_write, AD9834_RESET);\nstatic IIO_DEV_ATTR_OUTY_ENABLE(0, 1, 0200, NULL, ad9834_write, AD9834_OPBITEN);\nstatic IIO_DEV_ATTR_OUT_WAVETYPE(0, 0, ad9834_store_wavetype, 0);\nstatic IIO_DEV_ATTR_OUT_WAVETYPE(0, 1, ad9834_store_wavetype, 1);\n\nstatic struct attribute *ad9834_attributes[] = {\n\t&iio_dev_attr_out_altvoltage0_frequency0.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_frequency1.dev_attr.attr,\n\t&iio_const_attr_out_altvoltage0_frequency_scale.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_phase0.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_phase1.dev_attr.attr,\n\t&iio_const_attr_out_altvoltage0_phase_scale.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_pincontrol_en.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_frequencysymbol.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_phasesymbol.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_out_enable.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_out1_enable.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_out0_wavetype.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_out1_wavetype.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_out0_wavetype_available.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_out1_wavetype_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic struct attribute *ad9833_attributes[] = {\n\t&iio_dev_attr_out_altvoltage0_frequency0.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_frequency1.dev_attr.attr,\n\t&iio_const_attr_out_altvoltage0_frequency_scale.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_phase0.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_phase1.dev_attr.attr,\n\t&iio_const_attr_out_altvoltage0_phase_scale.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_frequencysymbol.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_phasesymbol.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_out_enable.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_out0_wavetype.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_out0_wavetype_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad9834_attribute_group = {\n\t.attrs = ad9834_attributes,\n};\n\nstatic const struct attribute_group ad9833_attribute_group = {\n\t.attrs = ad9833_attributes,\n};\n\nstatic const struct iio_info ad9834_info = {\n\t.attrs = &ad9834_attribute_group,\n};\n\nstatic const struct iio_info ad9833_info = {\n\t.attrs = &ad9833_attribute_group,\n};\n\nstatic void ad9834_disable_reg(void *data)\n{\n\tstruct regulator *reg = data;\n\n\tregulator_disable(reg);\n}\n\nstatic void ad9834_disable_clk(void *data)\n{\n\tstruct clk *clk = data;\n\n\tclk_disable_unprepare(clk);\n}\n\nstatic int ad9834_probe(struct spi_device *spi)\n{\n\tstruct ad9834_state *st;\n\tstruct iio_dev *indio_dev;\n\tstruct regulator *reg;\n\tint ret;\n\n\treg = devm_regulator_get(&spi->dev, \"avdd\");\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tret = regulator_enable(reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to enable specified AVDD supply\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, ad9834_disable_reg, reg);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev) {\n\t\tret = -ENOMEM;\n\t\treturn ret;\n\t}\n\tst = iio_priv(indio_dev);\n\tmutex_init(&st->lock);\n\tst->mclk = devm_clk_get(&spi->dev, NULL);\n\tif (IS_ERR(st->mclk)) {\n\t\tret = PTR_ERR(st->mclk);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(st->mclk);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to enable master clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, ad9834_disable_clk, st->mclk);\n\tif (ret)\n\t\treturn ret;\n\n\tst->spi = spi;\n\tst->devid = spi_get_device_id(spi)->driver_data;\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tswitch (st->devid) {\n\tcase ID_AD9833:\n\tcase ID_AD9837:\n\t\tindio_dev->info = &ad9833_info;\n\t\tbreak;\n\tdefault:\n\t\tindio_dev->info = &ad9834_info;\n\t\tbreak;\n\t}\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\t \n\n\tst->xfer.tx_buf = &st->data;\n\tst->xfer.len = 2;\n\n\tspi_message_init(&st->msg);\n\tspi_message_add_tail(&st->xfer, &st->msg);\n\n\tst->freq_xfer[0].tx_buf = &st->freq_data[0];\n\tst->freq_xfer[0].len = 2;\n\tst->freq_xfer[0].cs_change = 1;\n\tst->freq_xfer[1].tx_buf = &st->freq_data[1];\n\tst->freq_xfer[1].len = 2;\n\n\tspi_message_init(&st->freq_msg);\n\tspi_message_add_tail(&st->freq_xfer[0], &st->freq_msg);\n\tspi_message_add_tail(&st->freq_xfer[1], &st->freq_msg);\n\n\tst->control = AD9834_B28 | AD9834_RESET;\n\tst->control |= AD9834_DIV2;\n\n\tif (st->devid == ID_AD9834)\n\t\tst->control |= AD9834_SIGN_PIB;\n\n\tst->data = cpu_to_be16(AD9834_REG_CMD | st->control);\n\tret = spi_sync(st->spi, &st->msg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"device init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ad9834_write_frequency(st, AD9834_REG_FREQ0, 1000000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad9834_write_frequency(st, AD9834_REG_FREQ1, 5000000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad9834_write_phase(st, AD9834_REG_PHASE0, 512);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad9834_write_phase(st, AD9834_REG_PHASE1, 1024);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad9834_id[] = {\n\t{\"ad9833\", ID_AD9833},\n\t{\"ad9834\", ID_AD9834},\n\t{\"ad9837\", ID_AD9837},\n\t{\"ad9838\", ID_AD9838},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad9834_id);\n\nstatic const struct of_device_id ad9834_of_match[] = {\n\t{.compatible = \"adi,ad9833\"},\n\t{.compatible = \"adi,ad9834\"},\n\t{.compatible = \"adi,ad9837\"},\n\t{.compatible = \"adi,ad9838\"},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, ad9834_of_match);\n\nstatic struct spi_driver ad9834_driver = {\n\t.driver = {\n\t\t.name\t= \"ad9834\",\n\t\t.of_match_table = ad9834_of_match\n\t},\n\t.probe\t\t= ad9834_probe,\n\t.id_table\t= ad9834_id,\n};\nmodule_spi_driver(ad9834_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD9833/AD9834/AD9837/AD9838 DDS\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}