{
  "module_name": "adt7316-spi.c",
  "hash_id": "fb2fa0ca23747f07c9192eef0e90abcb4157a7cfeedfdf43e7ad19398c4af8b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/iio/addac/adt7316-spi.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/spi/spi.h>\n\n#include \"adt7316.h\"\n\n#define ADT7316_SPI_MAX_FREQ_HZ\t\t5000000\n#define ADT7316_SPI_CMD_READ\t\t0x91\n#define ADT7316_SPI_CMD_WRITE\t\t0x90\n\n \n\nstatic int adt7316_spi_multi_read(void *client, u8 reg, u8 count, u8 *data)\n{\n\tstruct spi_device *spi_dev = client;\n\tu8 cmd[2];\n\tint ret;\n\n\tif (count > ADT7316_REG_MAX_ADDR)\n\t\tcount = ADT7316_REG_MAX_ADDR;\n\n\tcmd[0] = ADT7316_SPI_CMD_WRITE;\n\tcmd[1] = reg;\n\n\tret = spi_write(spi_dev, cmd, 2);\n\tif (ret < 0) {\n\t\tdev_err(&spi_dev->dev, \"SPI fail to select reg\\n\");\n\t\treturn ret;\n\t}\n\n\tcmd[0] = ADT7316_SPI_CMD_READ;\n\n\tret = spi_write_then_read(spi_dev, cmd, 1, data, count);\n\tif (ret < 0) {\n\t\tdev_err(&spi_dev->dev, \"SPI read data error\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int adt7316_spi_multi_write(void *client, u8 reg, u8 count, u8 *data)\n{\n\tstruct spi_device *spi_dev = client;\n\tu8 buf[ADT7316_REG_MAX_ADDR + 2];\n\tint i, ret;\n\n\tif (count > ADT7316_REG_MAX_ADDR)\n\t\tcount = ADT7316_REG_MAX_ADDR;\n\n\tbuf[0] = ADT7316_SPI_CMD_WRITE;\n\tbuf[1] = reg;\n\tfor (i = 0; i < count; i++)\n\t\tbuf[i + 2] = data[i];\n\n\tret = spi_write(spi_dev, buf, count + 2);\n\tif (ret < 0) {\n\t\tdev_err(&spi_dev->dev, \"SPI write error\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int adt7316_spi_read(void *client, u8 reg, u8 *data)\n{\n\treturn adt7316_spi_multi_read(client, reg, 1, data);\n}\n\nstatic int adt7316_spi_write(void *client, u8 reg, u8 val)\n{\n\treturn adt7316_spi_multi_write(client, reg, 1, &val);\n}\n\n \n\nstatic int adt7316_spi_probe(struct spi_device *spi_dev)\n{\n\tstruct adt7316_bus bus = {\n\t\t.client = spi_dev,\n\t\t.irq = spi_dev->irq,\n\t\t.read = adt7316_spi_read,\n\t\t.write = adt7316_spi_write,\n\t\t.multi_read = adt7316_spi_multi_read,\n\t\t.multi_write = adt7316_spi_multi_write,\n\t};\n\n\t \n\tif (spi_dev->max_speed_hz > ADT7316_SPI_MAX_FREQ_HZ) {\n\t\tdev_err(&spi_dev->dev, \"SPI CLK %d Hz?\\n\",\n\t\t\tspi_dev->max_speed_hz);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tadt7316_spi_write(spi_dev, 0, 0);\n\tadt7316_spi_write(spi_dev, 0, 0);\n\tadt7316_spi_write(spi_dev, 0, 0);\n\n\treturn adt7316_probe(&spi_dev->dev, &bus, spi_dev->modalias);\n}\n\nstatic const struct spi_device_id adt7316_spi_id[] = {\n\t{ \"adt7316\", 0 },\n\t{ \"adt7317\", 0 },\n\t{ \"adt7318\", 0 },\n\t{ \"adt7516\", 0 },\n\t{ \"adt7517\", 0 },\n\t{ \"adt7519\", 0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(spi, adt7316_spi_id);\n\nstatic const struct of_device_id adt7316_of_spi_match[] = {\n\t{ .compatible = \"adi,adt7316\" },\n\t{ .compatible = \"adi,adt7317\" },\n\t{ .compatible = \"adi,adt7318\" },\n\t{ .compatible = \"adi,adt7516\" },\n\t{ .compatible = \"adi,adt7517\" },\n\t{ .compatible = \"adi,adt7519\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, adt7316_of_spi_match);\n\nstatic struct spi_driver adt7316_driver = {\n\t.driver = {\n\t\t.name = \"adt7316\",\n\t\t.of_match_table = adt7316_of_spi_match,\n\t\t.pm = ADT7316_PM_OPS,\n\t},\n\t.probe = adt7316_spi_probe,\n\t.id_table = adt7316_spi_id,\n};\nmodule_spi_driver(adt7316_driver);\n\nMODULE_AUTHOR(\"Sonic Zhang <sonic.zhang@analog.com>\");\nMODULE_DESCRIPTION(\"SPI bus driver for Analog Devices ADT7316/7/8 and ADT7516/7/9 digital temperature sensor, ADC and DAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}