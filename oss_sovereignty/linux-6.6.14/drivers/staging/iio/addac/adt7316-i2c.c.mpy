{
  "module_name": "adt7316-i2c.c",
  "hash_id": "50dbef8785293354fb1762b52d9b4102bde09d46b092f23076ce0e9b88028388",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/iio/addac/adt7316-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n\n#include \"adt7316.h\"\n\n \nstatic int adt7316_i2c_read(void *client, u8 reg, u8 *data)\n{\n\tstruct i2c_client *cl = client;\n\tint ret;\n\n\tret = i2c_smbus_write_byte(cl, reg);\n\tif (ret < 0) {\n\t\tdev_err(&cl->dev, \"I2C fail to select reg\\n\");\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_read_byte(client);\n\tif (ret < 0) {\n\t\tdev_err(&cl->dev, \"I2C read error\\n\");\n\t\treturn ret;\n\t}\n\n\t*data = ret;\n\n\treturn 0;\n}\n\nstatic int adt7316_i2c_write(void *client, u8 reg, u8 data)\n{\n\tstruct i2c_client *cl = client;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(cl, reg, data);\n\tif (ret < 0)\n\t\tdev_err(&cl->dev, \"I2C write error\\n\");\n\n\treturn ret;\n}\n\nstatic int adt7316_i2c_multi_read(void *client, u8 reg, u8 count, u8 *data)\n{\n\tstruct i2c_client *cl = client;\n\tint i, ret;\n\n\tif (count > ADT7316_REG_MAX_ADDR)\n\t\tcount = ADT7316_REG_MAX_ADDR;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = adt7316_i2c_read(cl, reg, &data[i]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&cl->dev, \"I2C multi read error\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int adt7316_i2c_multi_write(void *client, u8 reg, u8 count, u8 *data)\n{\n\tstruct i2c_client *cl = client;\n\tint i, ret;\n\n\tif (count > ADT7316_REG_MAX_ADDR)\n\t\tcount = ADT7316_REG_MAX_ADDR;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = adt7316_i2c_write(cl, reg, data[i]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&cl->dev, \"I2C multi write error\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int adt7316_i2c_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct adt7316_bus bus = {\n\t\t.client = client,\n\t\t.irq = client->irq,\n\t\t.read = adt7316_i2c_read,\n\t\t.write = adt7316_i2c_write,\n\t\t.multi_read = adt7316_i2c_multi_read,\n\t\t.multi_write = adt7316_i2c_multi_write,\n\t};\n\n\treturn adt7316_probe(&client->dev, &bus, id->name);\n}\n\nstatic const struct i2c_device_id adt7316_i2c_id[] = {\n\t{ \"adt7316\", 0 },\n\t{ \"adt7317\", 0 },\n\t{ \"adt7318\", 0 },\n\t{ \"adt7516\", 0 },\n\t{ \"adt7517\", 0 },\n\t{ \"adt7519\", 0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, adt7316_i2c_id);\n\nstatic const struct of_device_id adt7316_of_match[] = {\n\t{ .compatible = \"adi,adt7316\" },\n\t{ .compatible = \"adi,adt7317\" },\n\t{ .compatible = \"adi,adt7318\" },\n\t{ .compatible = \"adi,adt7516\" },\n\t{ .compatible = \"adi,adt7517\" },\n\t{ .compatible = \"adi,adt7519\" },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, adt7316_of_match);\n\nstatic struct i2c_driver adt7316_driver = {\n\t.driver = {\n\t\t.name = \"adt7316\",\n\t\t.of_match_table = adt7316_of_match,\n\t\t.pm = ADT7316_PM_OPS,\n\t},\n\t.probe = adt7316_i2c_probe,\n\t.id_table = adt7316_i2c_id,\n};\nmodule_i2c_driver(adt7316_driver);\n\nMODULE_AUTHOR(\"Sonic Zhang <sonic.zhang@analog.com>\");\nMODULE_DESCRIPTION(\"I2C bus driver for Analog Devices ADT7316/7/9 and ADT7516/7/8 digital temperature sensor, ADC and DAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}