{
  "module_name": "inkernel.txt",
  "hash_id": "45ad5ae181488a01f8e051a96fc3b1b8246e6aa0e4725ace231be9325b988679",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/iio/Documentation/inkernel.txt",
  "human_readable_source": "Industrial I/O Subsystem in kernel consumers.\n\nThe IIO subsystem can act as a layer under other elements of the kernel\nproviding a means of obtaining ADC type readings or of driving DAC type\nsignals.  The functionality supported will grow as use cases arise.\n\nDescribing the channel mapping (iio/machine.h)\n\nChannel associations are described using:\n\nstruct iio_map {\n\tconst char *adc_channel_label;\n\tconst char *consumer_dev_name;\n\tconst char *consumer_channel;\n};\n\nadc_channel_label identifies the channel on the IIO device by being\nmatched against the datasheet_name field of the iio_chan_spec.\n\nconsumer_dev_name allows identification of the consumer device.\nThis are then used to find the channel mapping from the consumer device (see\nbelow).\n\nFinally consumer_channel is a string identifying the channel to the consumer.\n(Perhaps 'battery_voltage' or similar).\n\nAn array of these structures is then passed to the IIO driver.\n\nSupporting in kernel interfaces in the driver (driver.h)\n\nThe driver must provide datasheet_name values for its channels and\nmust pass the iio_map structures and a pointer to its own iio_dev structure\n on to the core via a call to iio_map_array_register.  On removal,\niio_map_array_unregister reverses this process.\n\nThe result of this is that the IIO core now has all the information needed\nto associate a given channel with the consumer requesting it.\n\nActing as an IIO consumer (consumer.h)\n\nThe consumer first has to obtain an iio_channel structure from the core\nby calling iio_channel_get().  The correct channel is identified by:\n\n* matching dev or dev_name against consumer_dev and consumer_dev_name\n* matching consumer_channel against consumer_channel in the map\n\nThere are then a number of functions that can be used to get information\nabout this channel such as it's current reading.\n\ne.g.\niio_read_channel_raw() - get a reading\niio_get_channel_type() - get the type of channel\n\nThere is also provision for retrieving all of the channels associated\nwith a given consumer.  This is useful for generic drivers such as\niio_hwmon where the number and naming of channels is not known by the\nconsumer driver.  To do this, use iio_channel_get_all.\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}