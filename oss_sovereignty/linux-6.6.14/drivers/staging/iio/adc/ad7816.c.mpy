{
  "module_name": "ad7816.c",
  "hash_id": "7a28e92b24b5d0cea8d8162d58d36dd99f9fde9cd7d5fff7bc679aa394a65e90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/iio/adc/ad7816.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/gpio/consumer.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/list.h>\n#include <linux/spi/spi.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n\n \n#define AD7816_FULL\t\t\t0x1\n#define AD7816_PD\t\t\t0x2\n#define AD7816_CS_MASK\t\t\t0x7\n#define AD7816_CS_MAX\t\t\t0x4\n\n \n#define AD7816_VALUE_OFFSET\t\t6\n#define AD7816_BOUND_VALUE_BASE\t\t0x8\n#define AD7816_BOUND_VALUE_MIN\t\t-95\n#define AD7816_BOUND_VALUE_MAX\t\t152\n#define AD7816_TEMP_FLOAT_OFFSET\t2\n#define AD7816_TEMP_FLOAT_MASK\t\t0x3\n\n \n\nstruct ad7816_chip_info {\n\tkernel_ulong_t id;\n\tstruct spi_device *spi_dev;\n\tstruct gpio_desc *rdwr_pin;\n\tstruct gpio_desc *convert_pin;\n\tstruct gpio_desc *busy_pin;\n\tu8  oti_data[AD7816_CS_MAX + 1];\n\tu8  channel_id;\t \n\tu8  mode;\n};\n\nenum ad7816_type {\n\tID_AD7816,\n\tID_AD7817,\n\tID_AD7818,\n};\n\n \nstatic int ad7816_spi_read(struct ad7816_chip_info *chip, u16 *data)\n{\n\tstruct spi_device *spi_dev = chip->spi_dev;\n\tint ret;\n\t__be16 buf;\n\n\tgpiod_set_value(chip->rdwr_pin, 1);\n\tgpiod_set_value(chip->rdwr_pin, 0);\n\tret = spi_write(spi_dev, &chip->channel_id, sizeof(chip->channel_id));\n\tif (ret < 0) {\n\t\tdev_err(&spi_dev->dev, \"SPI channel setting error\\n\");\n\t\treturn ret;\n\t}\n\tgpiod_set_value(chip->rdwr_pin, 1);\n\n\tif (chip->mode == AD7816_PD) {  \n\t\tgpiod_set_value(chip->convert_pin, 1);\n\t\tgpiod_set_value(chip->convert_pin, 0);\n\t} else {  \n\t\tgpiod_set_value(chip->convert_pin, 0);\n\t\tgpiod_set_value(chip->convert_pin, 1);\n\t}\n\n\tif (chip->id == ID_AD7816 || chip->id == ID_AD7817) {\n\t\twhile (gpiod_get_value(chip->busy_pin))\n\t\t\tcpu_relax();\n\t}\n\n\tgpiod_set_value(chip->rdwr_pin, 0);\n\tgpiod_set_value(chip->rdwr_pin, 1);\n\tret = spi_read(spi_dev, &buf, sizeof(*data));\n\tif (ret < 0) {\n\t\tdev_err(&spi_dev->dev, \"SPI data read error\\n\");\n\t\treturn ret;\n\t}\n\n\t*data = be16_to_cpu(buf);\n\n\treturn ret;\n}\n\nstatic int ad7816_spi_write(struct ad7816_chip_info *chip, u8 data)\n{\n\tstruct spi_device *spi_dev = chip->spi_dev;\n\tint ret;\n\n\tgpiod_set_value(chip->rdwr_pin, 1);\n\tgpiod_set_value(chip->rdwr_pin, 0);\n\tret = spi_write(spi_dev, &data, sizeof(data));\n\tif (ret < 0)\n\t\tdev_err(&spi_dev->dev, \"SPI oti data write error\\n\");\n\n\treturn ret;\n}\n\nstatic ssize_t ad7816_show_mode(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7816_chip_info *chip = iio_priv(indio_dev);\n\n\tif (chip->mode)\n\t\treturn sprintf(buf, \"power-save\\n\");\n\treturn sprintf(buf, \"full\\n\");\n}\n\nstatic ssize_t ad7816_store_mode(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf,\n\t\t\t\t size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7816_chip_info *chip = iio_priv(indio_dev);\n\n\tif (strcmp(buf, \"full\")) {\n\t\tgpiod_set_value(chip->rdwr_pin, 1);\n\t\tchip->mode = AD7816_FULL;\n\t} else {\n\t\tgpiod_set_value(chip->rdwr_pin, 0);\n\t\tchip->mode = AD7816_PD;\n\t}\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(mode, 0644,\n\t\tad7816_show_mode,\n\t\tad7816_store_mode,\n\t\t0);\n\nstatic ssize_t ad7816_show_available_modes(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\treturn sprintf(buf, \"full\\npower-save\\n\");\n}\n\nstatic IIO_DEVICE_ATTR(available_modes, 0444, ad7816_show_available_modes,\n\t\t\tNULL, 0);\n\nstatic ssize_t ad7816_show_channel(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7816_chip_info *chip = iio_priv(indio_dev);\n\n\treturn sprintf(buf, \"%d\\n\", chip->channel_id);\n}\n\nstatic ssize_t ad7816_store_channel(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf,\n\t\t\t\t    size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7816_chip_info *chip = iio_priv(indio_dev);\n\tunsigned long data;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data > AD7816_CS_MAX && data != AD7816_CS_MASK) {\n\t\tdev_err(&chip->spi_dev->dev, \"Invalid channel id %lu for %s.\\n\",\n\t\t\tdata, indio_dev->name);\n\t\treturn -EINVAL;\n\t} else if (strcmp(indio_dev->name, \"ad7818\") == 0 && data > 1) {\n\t\tdev_err(&chip->spi_dev->dev,\n\t\t\t\"Invalid channel id %lu for ad7818.\\n\", data);\n\t\treturn -EINVAL;\n\t} else if (strcmp(indio_dev->name, \"ad7816\") == 0 && data > 0) {\n\t\tdev_err(&chip->spi_dev->dev,\n\t\t\t\"Invalid channel id %lu for ad7816.\\n\", data);\n\t\treturn -EINVAL;\n\t}\n\n\tchip->channel_id = data;\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(channel, 0644,\n\t\tad7816_show_channel,\n\t\tad7816_store_channel,\n\t\t0);\n\nstatic ssize_t ad7816_show_value(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7816_chip_info *chip = iio_priv(indio_dev);\n\tu16 data;\n\ts8 value;\n\tint ret;\n\n\tret = ad7816_spi_read(chip, &data);\n\tif (ret)\n\t\treturn -EIO;\n\n\tdata >>= AD7816_VALUE_OFFSET;\n\n\tif (chip->channel_id == 0) {\n\t\tvalue = (s8)((data >> AD7816_TEMP_FLOAT_OFFSET) - 103);\n\t\tdata &= AD7816_TEMP_FLOAT_MASK;\n\t\tif (value < 0)\n\t\t\tdata = BIT(AD7816_TEMP_FLOAT_OFFSET) - data;\n\t\treturn sprintf(buf, \"%d.%.2d\\n\", value, data * 25);\n\t}\n\treturn sprintf(buf, \"%u\\n\", data);\n}\n\nstatic IIO_DEVICE_ATTR(value, 0444, ad7816_show_value, NULL, 0);\n\nstatic struct attribute *ad7816_attributes[] = {\n\t&iio_dev_attr_available_modes.dev_attr.attr,\n\t&iio_dev_attr_mode.dev_attr.attr,\n\t&iio_dev_attr_channel.dev_attr.attr,\n\t&iio_dev_attr_value.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad7816_attribute_group = {\n\t.attrs = ad7816_attributes,\n};\n\n \n\n#define IIO_EVENT_CODE_AD7816_OTI IIO_UNMOD_EVENT_CODE(IIO_TEMP,\t\\\n\t\t\t\t\t\t       0,\t\t\\\n\t\t\t\t\t\t       IIO_EV_TYPE_THRESH, \\\n\t\t\t\t\t\t       IIO_EV_DIR_FALLING)\n\nstatic irqreturn_t ad7816_event_handler(int irq, void *private)\n{\n\tiio_push_event(private, IIO_EVENT_CODE_AD7816_OTI,\n\t\t       iio_get_time_ns(private));\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t ad7816_show_oti(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7816_chip_info *chip = iio_priv(indio_dev);\n\tint value;\n\n\tif (chip->channel_id > AD7816_CS_MAX) {\n\t\tdev_err(dev, \"Invalid oti channel id %d.\\n\", chip->channel_id);\n\t\treturn -EINVAL;\n\t} else if (chip->channel_id == 0) {\n\t\tvalue = AD7816_BOUND_VALUE_MIN +\n\t\t\t(chip->oti_data[chip->channel_id] -\n\t\t\tAD7816_BOUND_VALUE_BASE);\n\t\treturn sprintf(buf, \"%d\\n\", value);\n\t}\n\treturn sprintf(buf, \"%u\\n\", chip->oti_data[chip->channel_id]);\n}\n\nstatic inline ssize_t ad7816_set_oti(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf,\n\t\t\t\t     size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7816_chip_info *chip = iio_priv(indio_dev);\n\tlong value;\n\tu8 data;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chip->channel_id > AD7816_CS_MAX) {\n\t\tdev_err(dev, \"Invalid oti channel id %d.\\n\", chip->channel_id);\n\t\treturn -EINVAL;\n\t} else if (chip->channel_id == 0) {\n\t\tif (value < AD7816_BOUND_VALUE_MIN ||\n\t\t    value > AD7816_BOUND_VALUE_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tdata = (u8)(value - AD7816_BOUND_VALUE_MIN +\n\t\t\tAD7816_BOUND_VALUE_BASE);\n\t} else {\n\t\tif (value < AD7816_BOUND_VALUE_BASE || value > 255)\n\t\t\treturn -EINVAL;\n\n\t\tdata = (u8)value;\n\t}\n\n\tret = ad7816_spi_write(chip, data);\n\tif (ret)\n\t\treturn -EIO;\n\n\tchip->oti_data[chip->channel_id] = data;\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(oti, 0644,\n\t\t       ad7816_show_oti, ad7816_set_oti, 0);\n\nstatic struct attribute *ad7816_event_attributes[] = {\n\t&iio_dev_attr_oti.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad7816_event_attribute_group = {\n\t.attrs = ad7816_event_attributes,\n\t.name = \"events\",\n};\n\nstatic const struct iio_info ad7816_info = {\n\t.attrs = &ad7816_attribute_group,\n\t.event_attrs = &ad7816_event_attribute_group,\n};\n\n \n\nstatic int ad7816_probe(struct spi_device *spi_dev)\n{\n\tstruct ad7816_chip_info *chip;\n\tstruct iio_dev *indio_dev;\n\tint i, ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi_dev->dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tchip = iio_priv(indio_dev);\n\t \n\tdev_set_drvdata(&spi_dev->dev, indio_dev);\n\n\tchip->spi_dev = spi_dev;\n\tfor (i = 0; i <= AD7816_CS_MAX; i++)\n\t\tchip->oti_data[i] = 203;\n\n\tchip->id = spi_get_device_id(spi_dev)->driver_data;\n\tchip->rdwr_pin = devm_gpiod_get(&spi_dev->dev, \"rdwr\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(chip->rdwr_pin)) {\n\t\tret = PTR_ERR(chip->rdwr_pin);\n\t\tdev_err(&spi_dev->dev, \"Failed to request rdwr GPIO: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tchip->convert_pin = devm_gpiod_get(&spi_dev->dev, \"convert\",\n\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(chip->convert_pin)) {\n\t\tret = PTR_ERR(chip->convert_pin);\n\t\tdev_err(&spi_dev->dev, \"Failed to request convert GPIO: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tif (chip->id == ID_AD7816 || chip->id == ID_AD7817) {\n\t\tchip->busy_pin = devm_gpiod_get(&spi_dev->dev, \"busy\",\n\t\t\t\t\t\tGPIOD_IN);\n\t\tif (IS_ERR(chip->busy_pin)) {\n\t\t\tret = PTR_ERR(chip->busy_pin);\n\t\t\tdev_err(&spi_dev->dev, \"Failed to request busy GPIO: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tindio_dev->name = spi_get_device_id(spi_dev)->name;\n\tindio_dev->info = &ad7816_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (spi_dev->irq) {\n\t\t \n\t\tret = devm_request_threaded_irq(&spi_dev->dev, spi_dev->irq,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&ad7816_event_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\tindio_dev->name,\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_iio_device_register(&spi_dev->dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(&spi_dev->dev, \"%s temperature sensor and ADC registered.\\n\",\n\t\t indio_dev->name);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ad7816_of_match[] = {\n\t{ .compatible = \"adi,ad7816\", },\n\t{ .compatible = \"adi,ad7817\", },\n\t{ .compatible = \"adi,ad7818\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ad7816_of_match);\n\nstatic const struct spi_device_id ad7816_id[] = {\n\t{ \"ad7816\", ID_AD7816 },\n\t{ \"ad7817\", ID_AD7817 },\n\t{ \"ad7818\", ID_AD7818 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(spi, ad7816_id);\n\nstatic struct spi_driver ad7816_driver = {\n\t.driver = {\n\t\t.name = \"ad7816\",\n\t\t.of_match_table = ad7816_of_match,\n\t},\n\t.probe = ad7816_probe,\n\t.id_table = ad7816_id,\n};\nmodule_spi_driver(ad7816_driver);\n\nMODULE_AUTHOR(\"Sonic Zhang <sonic.zhang@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7816/7/8 digital temperature sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}