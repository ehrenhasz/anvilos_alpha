{
  "module_name": "ad2s1210.c",
  "hash_id": "0044df5f6c64bc486fc2d9bd08584a21488b8c24eba53a6a5347d9f3daaee890",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/iio/resolver/ad2s1210.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define DRV_NAME \"ad2s1210\"\n\n#define AD2S1210_DEF_CONTROL\t\t0x7E\n\n#define AD2S1210_MSB_IS_HIGH\t\t0x80\n#define AD2S1210_MSB_IS_LOW\t\t0x7F\n#define AD2S1210_PHASE_LOCK_RANGE_44\t0x20\n#define AD2S1210_ENABLE_HYSTERESIS\t0x10\n#define AD2S1210_SET_ENRES1\t\t0x08\n#define AD2S1210_SET_ENRES0\t\t0x04\n#define AD2S1210_SET_RES1\t\t0x02\n#define AD2S1210_SET_RES0\t\t0x01\n\n#define AD2S1210_SET_RESOLUTION\t\t(AD2S1210_SET_RES1 | AD2S1210_SET_RES0)\n\n#define AD2S1210_REG_POSITION\t\t0x80\n#define AD2S1210_REG_VELOCITY\t\t0x82\n#define AD2S1210_REG_LOS_THRD\t\t0x88\n#define AD2S1210_REG_DOS_OVR_THRD\t0x89\n#define AD2S1210_REG_DOS_MIS_THRD\t0x8A\n#define AD2S1210_REG_DOS_RST_MAX_THRD\t0x8B\n#define AD2S1210_REG_DOS_RST_MIN_THRD\t0x8C\n#define AD2S1210_REG_LOT_HIGH_THRD\t0x8D\n#define AD2S1210_REG_LOT_LOW_THRD\t0x8E\n#define AD2S1210_REG_EXCIT_FREQ\t\t0x91\n#define AD2S1210_REG_CONTROL\t\t0x92\n#define AD2S1210_REG_SOFT_RESET\t\t0xF0\n#define AD2S1210_REG_FAULT\t\t0xFF\n\n#define AD2S1210_MIN_CLKIN\t6144000\n#define AD2S1210_MAX_CLKIN\t10240000\n#define AD2S1210_MIN_EXCIT\t2000\n#define AD2S1210_MAX_EXCIT\t20000\n#define AD2S1210_MIN_FCW\t0x4\n#define AD2S1210_MAX_FCW\t0x50\n\n#define AD2S1210_DEF_EXCIT\t10000\n\nenum ad2s1210_mode {\n\tMOD_POS = 0,\n\tMOD_VEL,\n\tMOD_CONFIG,\n\tMOD_RESERVED,\n};\n\nenum ad2s1210_gpios {\n\tAD2S1210_SAMPLE,\n\tAD2S1210_A0,\n\tAD2S1210_A1,\n\tAD2S1210_RES0,\n\tAD2S1210_RES1,\n};\n\nstruct ad2s1210_gpio {\n\tconst char *name;\n\tunsigned long flags;\n};\n\nstatic const struct ad2s1210_gpio gpios[] = {\n\t[AD2S1210_SAMPLE] = { .name = \"adi,sample\", .flags = GPIOD_OUT_LOW },\n\t[AD2S1210_A0] = { .name = \"adi,a0\", .flags = GPIOD_OUT_LOW },\n\t[AD2S1210_A1] = { .name = \"adi,a1\", .flags = GPIOD_OUT_LOW },\n\t[AD2S1210_RES0] = { .name = \"adi,res0\", .flags = GPIOD_OUT_LOW },\n\t[AD2S1210_RES1] = { .name = \"adi,res1\", .flags = GPIOD_OUT_LOW },\n};\n\nstatic const unsigned int ad2s1210_resolution_value[] = { 10, 12, 14, 16 };\n\nstruct ad2s1210_state {\n\tstruct mutex lock;\n\tstruct spi_device *sdev;\n\tstruct gpio_desc *gpios[5];\n\tunsigned int fclkin;\n\tunsigned int fexcit;\n\tbool hysteresis;\n\tu8 resolution;\n\tenum ad2s1210_mode mode;\n\tu8 rx[2] __aligned(IIO_DMA_MINALIGN);\n\tu8 tx[2];\n};\n\nstatic const int ad2s1210_mode_vals[4][2] = {\n\t[MOD_POS] = { 0, 0 },\n\t[MOD_VEL] = { 0, 1 },\n\t[MOD_CONFIG] = { 1, 1 },\n};\n\nstatic inline void ad2s1210_set_mode(enum ad2s1210_mode mode,\n\t\t\t\t     struct ad2s1210_state *st)\n{\n\tgpiod_set_value(st->gpios[AD2S1210_A0], ad2s1210_mode_vals[mode][0]);\n\tgpiod_set_value(st->gpios[AD2S1210_A1], ad2s1210_mode_vals[mode][1]);\n\tst->mode = mode;\n}\n\n \nstatic int ad2s1210_config_write(struct ad2s1210_state *st, u8 data)\n{\n\tint ret;\n\n\tad2s1210_set_mode(MOD_CONFIG, st);\n\tst->tx[0] = data;\n\tret = spi_write(st->sdev, st->tx, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int ad2s1210_config_read(struct ad2s1210_state *st,\n\t\t\t\tunsigned char address)\n{\n\tstruct spi_transfer xfers[] = {\n\t\t{\n\t\t\t.len = 1,\n\t\t\t.rx_buf = &st->rx[0],\n\t\t\t.tx_buf = &st->tx[0],\n\t\t\t.cs_change = 1,\n\t\t}, {\n\t\t\t.len = 1,\n\t\t\t.rx_buf = &st->rx[1],\n\t\t\t.tx_buf = &st->tx[1],\n\t\t},\n\t};\n\tint ret = 0;\n\n\tad2s1210_set_mode(MOD_CONFIG, st);\n\tst->tx[0] = address | AD2S1210_MSB_IS_HIGH;\n\tst->tx[1] = AD2S1210_REG_FAULT;\n\tret = spi_sync_transfer(st->sdev, xfers, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn st->rx[1];\n}\n\nstatic inline\nint ad2s1210_update_frequency_control_word(struct ad2s1210_state *st)\n{\n\tint ret;\n\tunsigned char fcw;\n\n\tfcw = (unsigned char)(st->fexcit * (1 << 15) / st->fclkin);\n\tif (fcw < AD2S1210_MIN_FCW || fcw > AD2S1210_MAX_FCW) {\n\t\tdev_err(&st->sdev->dev, \"ad2s1210: FCW out of range\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\tret = ad2s1210_config_write(st, AD2S1210_REG_EXCIT_FREQ);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ad2s1210_config_write(st, fcw);\n}\n\nstatic const int ad2s1210_res_pins[4][2] = {\n\t{ 0, 0 }, {0, 1}, {1, 0}, {1, 1}\n};\n\nstatic inline void ad2s1210_set_resolution_pin(struct ad2s1210_state *st)\n{\n\tgpiod_set_value(st->gpios[AD2S1210_RES0],\n\t\t\tad2s1210_res_pins[(st->resolution - 10) / 2][0]);\n\tgpiod_set_value(st->gpios[AD2S1210_RES1],\n\t\t\tad2s1210_res_pins[(st->resolution - 10) / 2][1]);\n}\n\nstatic inline int ad2s1210_soft_reset(struct ad2s1210_state *st)\n{\n\tint ret;\n\n\tret = ad2s1210_config_write(st, AD2S1210_REG_SOFT_RESET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ad2s1210_config_write(st, 0x0);\n}\n\nstatic ssize_t ad2s1210_show_fclkin(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));\n\n\treturn sprintf(buf, \"%u\\n\", st->fclkin);\n}\n\nstatic ssize_t ad2s1210_store_fclkin(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf,\n\t\t\t\t     size_t len)\n{\n\tstruct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));\n\tunsigned int fclkin;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &fclkin);\n\tif (ret)\n\t\treturn ret;\n\tif (fclkin < AD2S1210_MIN_CLKIN || fclkin > AD2S1210_MAX_CLKIN) {\n\t\tdev_err(dev, \"ad2s1210: fclkin out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&st->lock);\n\tst->fclkin = fclkin;\n\n\tret = ad2s1210_update_frequency_control_word(st);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tret = ad2s1210_soft_reset(st);\nerror_ret:\n\tmutex_unlock(&st->lock);\n\n\treturn ret < 0 ? ret : len;\n}\n\nstatic ssize_t ad2s1210_show_fexcit(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));\n\n\treturn sprintf(buf, \"%u\\n\", st->fexcit);\n}\n\nstatic ssize_t ad2s1210_store_fexcit(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));\n\tunsigned int fexcit;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &fexcit);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (fexcit < AD2S1210_MIN_EXCIT || fexcit > AD2S1210_MAX_EXCIT) {\n\t\tdev_err(dev,\n\t\t\t\"ad2s1210: excitation frequency out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&st->lock);\n\tst->fexcit = fexcit;\n\tret = ad2s1210_update_frequency_control_word(st);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tret = ad2s1210_soft_reset(st);\nerror_ret:\n\tmutex_unlock(&st->lock);\n\n\treturn ret < 0 ? ret : len;\n}\n\nstatic ssize_t ad2s1210_show_control(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);\n\tmutex_unlock(&st->lock);\n\treturn ret < 0 ? ret : sprintf(buf, \"0x%x\\n\", ret);\n}\n\nstatic ssize_t ad2s1210_store_control(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));\n\tunsigned char udata;\n\tunsigned char data;\n\tint ret;\n\n\tret = kstrtou8(buf, 16, &udata);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&st->lock);\n\tret = ad2s1210_config_write(st, AD2S1210_REG_CONTROL);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tdata = udata & AD2S1210_MSB_IS_LOW;\n\tret = ad2s1210_config_write(st, data);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\n\tret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tif (ret & AD2S1210_MSB_IS_HIGH) {\n\t\tret = -EIO;\n\t\tdev_err(dev,\n\t\t\t\"ad2s1210: write control register fail\\n\");\n\t\tgoto error_ret;\n\t}\n\tst->resolution =\n\t\tad2s1210_resolution_value[data & AD2S1210_SET_RESOLUTION];\n\tad2s1210_set_resolution_pin(st);\n\tret = len;\n\tst->hysteresis = !!(data & AD2S1210_ENABLE_HYSTERESIS);\n\nerror_ret:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic ssize_t ad2s1210_show_resolution(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));\n\n\treturn sprintf(buf, \"%d\\n\", st->resolution);\n}\n\nstatic ssize_t ad2s1210_store_resolution(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t len)\n{\n\tstruct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));\n\tunsigned char data;\n\tunsigned char udata;\n\tint ret;\n\n\tret = kstrtou8(buf, 10, &udata);\n\tif (ret || udata < 10 || udata > 16) {\n\t\tdev_err(dev, \"ad2s1210: resolution out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&st->lock);\n\tret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tdata = ret;\n\tdata &= ~AD2S1210_SET_RESOLUTION;\n\tdata |= (udata - 10) >> 1;\n\tret = ad2s1210_config_write(st, AD2S1210_REG_CONTROL);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tret = ad2s1210_config_write(st, data & AD2S1210_MSB_IS_LOW);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tdata = ret;\n\tif (data & AD2S1210_MSB_IS_HIGH) {\n\t\tret = -EIO;\n\t\tdev_err(dev, \"ad2s1210: setting resolution fail\\n\");\n\t\tgoto error_ret;\n\t}\n\tst->resolution =\n\t\tad2s1210_resolution_value[data & AD2S1210_SET_RESOLUTION];\n\tad2s1210_set_resolution_pin(st);\n\tret = len;\nerror_ret:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\n \nstatic ssize_t ad2s1210_show_fault(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = ad2s1210_config_read(st, AD2S1210_REG_FAULT);\n\tmutex_unlock(&st->lock);\n\n\treturn ret ? ret : sprintf(buf, \"0x%x\\n\", ret);\n}\n\nstatic ssize_t ad2s1210_clear_fault(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf,\n\t\t\t\t    size_t len)\n{\n\tstruct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tgpiod_set_value(st->gpios[AD2S1210_SAMPLE], 0);\n\t \n\tudelay(1);\n\tgpiod_set_value(st->gpios[AD2S1210_SAMPLE], 1);\n\tret = ad2s1210_config_read(st, AD2S1210_REG_FAULT);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tgpiod_set_value(st->gpios[AD2S1210_SAMPLE], 0);\n\tgpiod_set_value(st->gpios[AD2S1210_SAMPLE], 1);\nerror_ret:\n\tmutex_unlock(&st->lock);\n\n\treturn ret < 0 ? ret : len;\n}\n\nstatic ssize_t ad2s1210_show_reg(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));\n\tstruct iio_dev_attr *iattr = to_iio_dev_attr(attr);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = ad2s1210_config_read(st, iattr->address);\n\tmutex_unlock(&st->lock);\n\n\treturn ret < 0 ? ret : sprintf(buf, \"%d\\n\", ret);\n}\n\nstatic ssize_t ad2s1210_store_reg(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));\n\tunsigned char data;\n\tint ret;\n\tstruct iio_dev_attr *iattr = to_iio_dev_attr(attr);\n\n\tret = kstrtou8(buf, 10, &data);\n\tif (ret)\n\t\treturn -EINVAL;\n\tmutex_lock(&st->lock);\n\tret = ad2s1210_config_write(st, iattr->address);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tret = ad2s1210_config_write(st, data & AD2S1210_MSB_IS_LOW);\nerror_ret:\n\tmutex_unlock(&st->lock);\n\treturn ret < 0 ? ret : len;\n}\n\nstatic int ad2s1210_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val,\n\t\t\t     int *val2,\n\t\t\t     long m)\n{\n\tstruct ad2s1210_state *st = iio_priv(indio_dev);\n\tu16 negative;\n\tint ret = 0;\n\tu16 pos;\n\ts16 vel;\n\n\tmutex_lock(&st->lock);\n\tgpiod_set_value(st->gpios[AD2S1210_SAMPLE], 0);\n\t \n\tudelay(1);\n\n\tswitch (chan->type) {\n\tcase IIO_ANGL:\n\t\tad2s1210_set_mode(MOD_POS, st);\n\t\tbreak;\n\tcase IIO_ANGL_VEL:\n\t\tad2s1210_set_mode(MOD_VEL, st);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tret = spi_read(st->sdev, st->rx, 2);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\n\tswitch (chan->type) {\n\tcase IIO_ANGL:\n\t\tpos = be16_to_cpup((__be16 *)st->rx);\n\t\tif (st->hysteresis)\n\t\t\tpos >>= 16 - st->resolution;\n\t\t*val = pos;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_ANGL_VEL:\n\t\tvel = be16_to_cpup((__be16 *)st->rx);\n\t\tvel >>= 16 - st->resolution;\n\t\tif (vel & 0x8000) {\n\t\t\tnegative = (0xffff >> st->resolution) << st->resolution;\n\t\t\tvel |= negative;\n\t\t}\n\t\t*val = vel;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&st->lock);\n\t\treturn -EINVAL;\n\t}\n\nerror_ret:\n\tgpiod_set_value(st->gpios[AD2S1210_SAMPLE], 1);\n\t \n\tudelay(1);\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic IIO_DEVICE_ATTR(fclkin, 0644,\n\t\t       ad2s1210_show_fclkin, ad2s1210_store_fclkin, 0);\nstatic IIO_DEVICE_ATTR(fexcit, 0644,\n\t\t       ad2s1210_show_fexcit,\tad2s1210_store_fexcit, 0);\nstatic IIO_DEVICE_ATTR(control, 0644,\n\t\t       ad2s1210_show_control, ad2s1210_store_control, 0);\nstatic IIO_DEVICE_ATTR(bits, 0644,\n\t\t       ad2s1210_show_resolution, ad2s1210_store_resolution, 0);\nstatic IIO_DEVICE_ATTR(fault, 0644,\n\t\t       ad2s1210_show_fault, ad2s1210_clear_fault, 0);\n\nstatic IIO_DEVICE_ATTR(los_thrd, 0644,\n\t\t       ad2s1210_show_reg, ad2s1210_store_reg,\n\t\t       AD2S1210_REG_LOS_THRD);\nstatic IIO_DEVICE_ATTR(dos_ovr_thrd, 0644,\n\t\t       ad2s1210_show_reg, ad2s1210_store_reg,\n\t\t       AD2S1210_REG_DOS_OVR_THRD);\nstatic IIO_DEVICE_ATTR(dos_mis_thrd, 0644,\n\t\t       ad2s1210_show_reg, ad2s1210_store_reg,\n\t\t       AD2S1210_REG_DOS_MIS_THRD);\nstatic IIO_DEVICE_ATTR(dos_rst_max_thrd, 0644,\n\t\t       ad2s1210_show_reg, ad2s1210_store_reg,\n\t\t       AD2S1210_REG_DOS_RST_MAX_THRD);\nstatic IIO_DEVICE_ATTR(dos_rst_min_thrd, 0644,\n\t\t       ad2s1210_show_reg, ad2s1210_store_reg,\n\t\t       AD2S1210_REG_DOS_RST_MIN_THRD);\nstatic IIO_DEVICE_ATTR(lot_high_thrd, 0644,\n\t\t       ad2s1210_show_reg, ad2s1210_store_reg,\n\t\t       AD2S1210_REG_LOT_HIGH_THRD);\nstatic IIO_DEVICE_ATTR(lot_low_thrd, 0644,\n\t\t       ad2s1210_show_reg, ad2s1210_store_reg,\n\t\t       AD2S1210_REG_LOT_LOW_THRD);\n\nstatic const struct iio_chan_spec ad2s1210_channels[] = {\n\t{\n\t\t.type = IIO_ANGL,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t}, {\n\t\t.type = IIO_ANGL_VEL,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t}\n};\n\nstatic struct attribute *ad2s1210_attributes[] = {\n\t&iio_dev_attr_fclkin.dev_attr.attr,\n\t&iio_dev_attr_fexcit.dev_attr.attr,\n\t&iio_dev_attr_control.dev_attr.attr,\n\t&iio_dev_attr_bits.dev_attr.attr,\n\t&iio_dev_attr_fault.dev_attr.attr,\n\t&iio_dev_attr_los_thrd.dev_attr.attr,\n\t&iio_dev_attr_dos_ovr_thrd.dev_attr.attr,\n\t&iio_dev_attr_dos_mis_thrd.dev_attr.attr,\n\t&iio_dev_attr_dos_rst_max_thrd.dev_attr.attr,\n\t&iio_dev_attr_dos_rst_min_thrd.dev_attr.attr,\n\t&iio_dev_attr_lot_high_thrd.dev_attr.attr,\n\t&iio_dev_attr_lot_low_thrd.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad2s1210_attribute_group = {\n\t.attrs = ad2s1210_attributes,\n};\n\nstatic int ad2s1210_initial(struct ad2s1210_state *st)\n{\n\tunsigned char data;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tad2s1210_set_resolution_pin(st);\n\n\tret = ad2s1210_config_write(st, AD2S1210_REG_CONTROL);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tdata = AD2S1210_DEF_CONTROL & ~(AD2S1210_SET_RESOLUTION);\n\tdata |= (st->resolution - 10) >> 1;\n\tret = ad2s1210_config_write(st, data);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\n\tif (ret & AD2S1210_MSB_IS_HIGH) {\n\t\tret = -EIO;\n\t\tgoto error_ret;\n\t}\n\n\tret = ad2s1210_update_frequency_control_word(st);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tret = ad2s1210_soft_reset(st);\nerror_ret:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic const struct iio_info ad2s1210_info = {\n\t.read_raw = ad2s1210_read_raw,\n\t.attrs = &ad2s1210_attribute_group,\n};\n\nstatic int ad2s1210_setup_gpios(struct ad2s1210_state *st)\n{\n\tstruct spi_device *spi = st->sdev;\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(gpios); i++) {\n\t\tst->gpios[i] = devm_gpiod_get(&spi->dev, gpios[i].name,\n\t\t\t\t\t      gpios[i].flags);\n\t\tif (IS_ERR(st->gpios[i])) {\n\t\t\tret = PTR_ERR(st->gpios[i]);\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"ad2s1210: failed to request %s GPIO: %d\\n\",\n\t\t\t\tgpios[i].name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ad2s1210_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct ad2s1210_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tst = iio_priv(indio_dev);\n\tret = ad2s1210_setup_gpios(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tspi_set_drvdata(spi, indio_dev);\n\n\tmutex_init(&st->lock);\n\tst->sdev = spi;\n\tst->hysteresis = true;\n\tst->mode = MOD_CONFIG;\n\tst->resolution = 12;\n\tst->fexcit = AD2S1210_DEF_EXCIT;\n\n\tindio_dev->info = &ad2s1210_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = ad2s1210_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ad2s1210_channels);\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\n\tret = devm_iio_device_register(&spi->dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tst->fclkin = spi->max_speed_hz;\n\tspi->mode = SPI_MODE_3;\n\tspi_setup(spi);\n\tad2s1210_initial(st);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ad2s1210_of_match[] = {\n\t{ .compatible = \"adi,ad2s1210\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ad2s1210_of_match);\n\nstatic const struct spi_device_id ad2s1210_id[] = {\n\t{ \"ad2s1210\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad2s1210_id);\n\nstatic struct spi_driver ad2s1210_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = of_match_ptr(ad2s1210_of_match),\n\t},\n\t.probe = ad2s1210_probe,\n\t.id_table = ad2s1210_id,\n};\nmodule_spi_driver(ad2s1210_driver);\n\nMODULE_AUTHOR(\"Graff Yang <graff.yang@gmail.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD2S1210 Resolver to Digital SPI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}