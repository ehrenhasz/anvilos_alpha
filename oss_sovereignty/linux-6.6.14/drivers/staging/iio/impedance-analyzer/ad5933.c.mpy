{
  "module_name": "ad5933.c",
  "hash_id": "c7daacdfa5c2b5d2e1cffee9cbd39bc424bcb5201fa744042362387482050f8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/iio/impedance-analyzer/ad5933.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/iio/sysfs.h>\n\n \n#define AD5933_REG_CONTROL_HB\t\t0x80\t \n#define AD5933_REG_CONTROL_LB\t\t0x81\t \n#define AD5933_REG_FREQ_START\t\t0x82\t \n#define AD5933_REG_FREQ_INC\t\t0x85\t \n#define AD5933_REG_INC_NUM\t\t0x88\t \n#define AD5933_REG_SETTLING_CYCLES\t0x8A\t \n#define AD5933_REG_STATUS\t\t0x8F\t \n#define AD5933_REG_TEMP_DATA\t\t0x92\t \n#define AD5933_REG_REAL_DATA\t\t0x94\t \n#define AD5933_REG_IMAG_DATA\t\t0x96\t \n\n \n#define AD5933_CTRL_INIT_START_FREQ\t(0x1 << 4)\n#define AD5933_CTRL_START_SWEEP\t\t(0x2 << 4)\n#define AD5933_CTRL_INC_FREQ\t\t(0x3 << 4)\n#define AD5933_CTRL_REPEAT_FREQ\t\t(0x4 << 4)\n#define AD5933_CTRL_MEASURE_TEMP\t(0x9 << 4)\n#define AD5933_CTRL_POWER_DOWN\t\t(0xA << 4)\n#define AD5933_CTRL_STANDBY\t\t(0xB << 4)\n\n#define AD5933_CTRL_RANGE_2000mVpp\t(0x0 << 1)\n#define AD5933_CTRL_RANGE_200mVpp\t(0x1 << 1)\n#define AD5933_CTRL_RANGE_400mVpp\t(0x2 << 1)\n#define AD5933_CTRL_RANGE_1000mVpp\t(0x3 << 1)\n#define AD5933_CTRL_RANGE(x)\t\t((x) << 1)\n\n#define AD5933_CTRL_PGA_GAIN_1\t\t(0x1 << 0)\n#define AD5933_CTRL_PGA_GAIN_5\t\t(0x0 << 0)\n\n \n#define AD5933_CTRL_RESET\t\t(0x1 << 4)\n#define AD5933_CTRL_INT_SYSCLK\t\t(0x0 << 3)\n#define AD5933_CTRL_EXT_SYSCLK\t\t(0x1 << 3)\n\n \n#define AD5933_STAT_TEMP_VALID\t\t(0x1 << 0)\n#define AD5933_STAT_DATA_VALID\t\t(0x1 << 1)\n#define AD5933_STAT_SWEEP_DONE\t\t(0x1 << 2)\n\n \n#define AD5933_I2C_BLOCK_WRITE\t\t0xA0\n#define AD5933_I2C_BLOCK_READ\t\t0xA1\n#define AD5933_I2C_ADDR_POINTER\t\t0xB0\n\n \n#define AD5933_INT_OSC_FREQ_Hz\t\t16776000\n#define AD5933_MAX_OUTPUT_FREQ_Hz\t100000\n#define AD5933_MAX_RETRIES\t\t100\n\n#define AD5933_OUT_RANGE\t\t1\n#define AD5933_OUT_RANGE_AVAIL\t\t2\n#define AD5933_OUT_SETTLING_CYCLES\t3\n#define AD5933_IN_PGA_GAIN\t\t4\n#define AD5933_IN_PGA_GAIN_AVAIL\t5\n#define AD5933_FREQ_POINTS\t\t6\n\n#define AD5933_POLL_TIME_ms\t\t10\n#define AD5933_INIT_EXCITATION_TIME_ms\t100\n\nstruct ad5933_state {\n\tstruct i2c_client\t\t*client;\n\tstruct regulator\t\t*reg;\n\tstruct clk\t\t\t*mclk;\n\tstruct delayed_work\t\twork;\n\tstruct mutex\t\t\tlock;  \n\tunsigned long\t\t\tmclk_hz;\n\tunsigned char\t\t\tctrl_hb;\n\tunsigned char\t\t\tctrl_lb;\n\tunsigned int\t\t\trange_avail[4];\n\tunsigned short\t\t\tvref_mv;\n\tunsigned short\t\t\tsettling_cycles;\n\tunsigned short\t\t\tfreq_points;\n\tunsigned int\t\t\tfreq_start;\n\tunsigned int\t\t\tfreq_inc;\n\tunsigned int\t\t\tstate;\n\tunsigned int\t\t\tpoll_time_jiffies;\n};\n\n#define AD5933_CHANNEL(_type, _extend_name, _info_mask_separate, _address, \\\n\t\t_scan_index, _realbits) { \\\n\t.type = (_type), \\\n\t.extend_name = (_extend_name), \\\n\t.info_mask_separate = (_info_mask_separate), \\\n\t.address = (_address), \\\n\t.scan_index = (_scan_index), \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = (_realbits), \\\n\t\t.storagebits = 16, \\\n\t}, \\\n}\n\nstatic const struct iio_chan_spec ad5933_channels[] = {\n\tAD5933_CHANNEL(IIO_TEMP, NULL, BIT(IIO_CHAN_INFO_RAW) |\n\t\tBIT(IIO_CHAN_INFO_SCALE), AD5933_REG_TEMP_DATA, -1, 14),\n\t \n\tAD5933_CHANNEL(IIO_VOLTAGE, \"real\", 0, AD5933_REG_REAL_DATA, 0, 16),\n\tAD5933_CHANNEL(IIO_VOLTAGE, \"imag\", 0, AD5933_REG_IMAG_DATA, 1, 16),\n};\n\nstatic int ad5933_i2c_write(struct i2c_client *client, u8 reg, u8 len, u8 *data)\n{\n\tint ret;\n\n\twhile (len--) {\n\t\tret = i2c_smbus_write_byte_data(client, reg++, *data++);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"I2C write error\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ad5933_i2c_read(struct i2c_client *client, u8 reg, u8 len, u8 *data)\n{\n\tint ret;\n\n\twhile (len--) {\n\t\tret = i2c_smbus_read_byte_data(client, reg++);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"I2C read error\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t*data++ = ret;\n\t}\n\treturn 0;\n}\n\nstatic int ad5933_cmd(struct ad5933_state *st, unsigned char cmd)\n{\n\tunsigned char dat = st->ctrl_hb | cmd;\n\n\treturn ad5933_i2c_write(st->client,\n\t\t\tAD5933_REG_CONTROL_HB, 1, &dat);\n}\n\nstatic int ad5933_reset(struct ad5933_state *st)\n{\n\tunsigned char dat = st->ctrl_lb | AD5933_CTRL_RESET;\n\n\treturn ad5933_i2c_write(st->client,\n\t\t\tAD5933_REG_CONTROL_LB, 1, &dat);\n}\n\nstatic int ad5933_wait_busy(struct ad5933_state *st, unsigned char event)\n{\n\tunsigned char val, timeout = AD5933_MAX_RETRIES;\n\tint ret;\n\n\twhile (timeout--) {\n\t\tret =  ad5933_i2c_read(st->client, AD5933_REG_STATUS, 1, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (val & event)\n\t\t\treturn val;\n\t\tcpu_relax();\n\t\tmdelay(1);\n\t}\n\n\treturn -EAGAIN;\n}\n\nstatic int ad5933_set_freq(struct ad5933_state *st,\n\t\t\t   unsigned int reg, unsigned long freq)\n{\n\tunsigned long long freqreg;\n\tunion {\n\t\t__be32 d32;\n\t\tu8 d8[4];\n\t} dat;\n\n\tfreqreg = (u64)freq * (u64)(1 << 27);\n\tdo_div(freqreg, st->mclk_hz / 4);\n\n\tswitch (reg) {\n\tcase AD5933_REG_FREQ_START:\n\t\tst->freq_start = freq;\n\t\tbreak;\n\tcase AD5933_REG_FREQ_INC:\n\t\tst->freq_inc = freq;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdat.d32 = cpu_to_be32(freqreg);\n\treturn ad5933_i2c_write(st->client, reg, 3, &dat.d8[1]);\n}\n\nstatic int ad5933_setup(struct ad5933_state *st)\n{\n\t__be16 dat;\n\tint ret;\n\n\tret = ad5933_reset(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad5933_set_freq(st, AD5933_REG_FREQ_START, 10000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad5933_set_freq(st, AD5933_REG_FREQ_INC, 200);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->settling_cycles = 10;\n\tdat = cpu_to_be16(st->settling_cycles);\n\n\tret = ad5933_i2c_write(st->client,\n\t\t\t       AD5933_REG_SETTLING_CYCLES,\n\t\t\t       2, (u8 *)&dat);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->freq_points = 100;\n\tdat = cpu_to_be16(st->freq_points);\n\n\treturn ad5933_i2c_write(st->client, AD5933_REG_INC_NUM, 2, (u8 *)&dat);\n}\n\nstatic void ad5933_calc_out_ranges(struct ad5933_state *st)\n{\n\tint i;\n\tunsigned int normalized_3v3[4] = {1980, 198, 383, 970};\n\n\tfor (i = 0; i < 4; i++)\n\t\tst->range_avail[i] = normalized_3v3[i] * st->vref_mv / 3300;\n}\n\n \n\nstatic ssize_t ad5933_show_frequency(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad5933_state *st = iio_priv(indio_dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint ret;\n\tunsigned long long freqreg;\n\tunion {\n\t\t__be32 d32;\n\t\tu8 d8[4];\n\t} dat;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\tret = ad5933_i2c_read(st->client, this_attr->address, 3, &dat.d8[1]);\n\tiio_device_release_direct_mode(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfreqreg = be32_to_cpu(dat.d32) & 0xFFFFFF;\n\n\tfreqreg = (u64)freqreg * (u64)(st->mclk_hz / 4);\n\tdo_div(freqreg, BIT(27));\n\n\treturn sprintf(buf, \"%d\\n\", (int)freqreg);\n}\n\nstatic ssize_t ad5933_store_frequency(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf,\n\t\t\t\t      size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad5933_state *st = iio_priv(indio_dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > AD5933_MAX_OUTPUT_FREQ_Hz)\n\t\treturn -EINVAL;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\tret = ad5933_set_freq(st, this_attr->address, val);\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret ? ret : len;\n}\n\nstatic IIO_DEVICE_ATTR(out_altvoltage0_frequency_start, 0644,\n\t\t\tad5933_show_frequency,\n\t\t\tad5933_store_frequency,\n\t\t\tAD5933_REG_FREQ_START);\n\nstatic IIO_DEVICE_ATTR(out_altvoltage0_frequency_increment, 0644,\n\t\t\tad5933_show_frequency,\n\t\t\tad5933_store_frequency,\n\t\t\tAD5933_REG_FREQ_INC);\n\nstatic ssize_t ad5933_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad5933_state *st = iio_priv(indio_dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint ret = 0, len = 0;\n\n\tmutex_lock(&st->lock);\n\tswitch ((u32)this_attr->address) {\n\tcase AD5933_OUT_RANGE:\n\t\tlen = sprintf(buf, \"%u\\n\",\n\t\t\t      st->range_avail[(st->ctrl_hb >> 1) & 0x3]);\n\t\tbreak;\n\tcase AD5933_OUT_RANGE_AVAIL:\n\t\tlen = sprintf(buf, \"%u %u %u %u\\n\", st->range_avail[0],\n\t\t\t      st->range_avail[3], st->range_avail[2],\n\t\t\t      st->range_avail[1]);\n\t\tbreak;\n\tcase AD5933_OUT_SETTLING_CYCLES:\n\t\tlen = sprintf(buf, \"%d\\n\", st->settling_cycles);\n\t\tbreak;\n\tcase AD5933_IN_PGA_GAIN:\n\t\tlen = sprintf(buf, \"%s\\n\",\n\t\t\t      (st->ctrl_hb & AD5933_CTRL_PGA_GAIN_1) ?\n\t\t\t      \"1\" : \"0.2\");\n\t\tbreak;\n\tcase AD5933_IN_PGA_GAIN_AVAIL:\n\t\tlen = sprintf(buf, \"1 0.2\\n\");\n\t\tbreak;\n\tcase AD5933_FREQ_POINTS:\n\t\tlen = sprintf(buf, \"%d\\n\", st->freq_points);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&st->lock);\n\treturn ret ? ret : len;\n}\n\nstatic ssize_t ad5933_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf,\n\t\t\t    size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad5933_state *st = iio_priv(indio_dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tu16 val;\n\tint i, ret = 0;\n\t__be16 dat;\n\n\tif (this_attr->address != AD5933_IN_PGA_GAIN) {\n\t\tret = kstrtou16(buf, 10, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&st->lock);\n\tswitch ((u32)this_attr->address) {\n\tcase AD5933_OUT_RANGE:\n\t\tret = -EINVAL;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tif (val == st->range_avail[i]) {\n\t\t\t\tst->ctrl_hb &= ~AD5933_CTRL_RANGE(0x3);\n\t\t\t\tst->ctrl_hb |= AD5933_CTRL_RANGE(i);\n\t\t\t\tret = ad5933_cmd(st, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tbreak;\n\tcase AD5933_IN_PGA_GAIN:\n\t\tif (sysfs_streq(buf, \"1\")) {\n\t\t\tst->ctrl_hb |= AD5933_CTRL_PGA_GAIN_1;\n\t\t} else if (sysfs_streq(buf, \"0.2\")) {\n\t\t\tst->ctrl_hb &= ~AD5933_CTRL_PGA_GAIN_1;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = ad5933_cmd(st, 0);\n\t\tbreak;\n\tcase AD5933_OUT_SETTLING_CYCLES:\n\t\tval = clamp(val, (u16)0, (u16)0x7FF);\n\t\tst->settling_cycles = val;\n\n\t\t \n\t\tif (val > 1022)\n\t\t\tval = (val >> 2) | (3 << 9);\n\t\telse if (val > 511)\n\t\t\tval = (val >> 1) | BIT(9);\n\n\t\tdat = cpu_to_be16(val);\n\t\tret = ad5933_i2c_write(st->client,\n\t\t\t\t       AD5933_REG_SETTLING_CYCLES,\n\t\t\t\t       2, (u8 *)&dat);\n\t\tbreak;\n\tcase AD5933_FREQ_POINTS:\n\t\tval = clamp(val, (u16)0, (u16)511);\n\t\tst->freq_points = val;\n\n\t\tdat = cpu_to_be16(val);\n\t\tret = ad5933_i2c_write(st->client, AD5933_REG_INC_NUM, 2,\n\t\t\t\t       (u8 *)&dat);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&st->lock);\n\tiio_device_release_direct_mode(indio_dev);\n\treturn ret ? ret : len;\n}\n\nstatic IIO_DEVICE_ATTR(out_altvoltage0_raw, 0644,\n\t\t\tad5933_show,\n\t\t\tad5933_store,\n\t\t\tAD5933_OUT_RANGE);\n\nstatic IIO_DEVICE_ATTR(out_altvoltage0_scale_available, 0444,\n\t\t\tad5933_show,\n\t\t\tNULL,\n\t\t\tAD5933_OUT_RANGE_AVAIL);\n\nstatic IIO_DEVICE_ATTR(in_voltage0_scale, 0644,\n\t\t\tad5933_show,\n\t\t\tad5933_store,\n\t\t\tAD5933_IN_PGA_GAIN);\n\nstatic IIO_DEVICE_ATTR(in_voltage0_scale_available, 0444,\n\t\t\tad5933_show,\n\t\t\tNULL,\n\t\t\tAD5933_IN_PGA_GAIN_AVAIL);\n\nstatic IIO_DEVICE_ATTR(out_altvoltage0_frequency_points, 0644,\n\t\t\tad5933_show,\n\t\t\tad5933_store,\n\t\t\tAD5933_FREQ_POINTS);\n\nstatic IIO_DEVICE_ATTR(out_altvoltage0_settling_cycles, 0644,\n\t\t\tad5933_show,\n\t\t\tad5933_store,\n\t\t\tAD5933_OUT_SETTLING_CYCLES);\n\n \nstatic struct attribute *ad5933_attributes[] = {\n\t&iio_dev_attr_out_altvoltage0_raw.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_scale_available.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_frequency_start.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_frequency_increment.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_frequency_points.dev_attr.attr,\n\t&iio_dev_attr_out_altvoltage0_settling_cycles.dev_attr.attr,\n\t&iio_dev_attr_in_voltage0_scale.dev_attr.attr,\n\t&iio_dev_attr_in_voltage0_scale_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ad5933_attribute_group = {\n\t.attrs = ad5933_attributes,\n};\n\nstatic int ad5933_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tstruct ad5933_state *st = iio_priv(indio_dev);\n\t__be16 dat;\n\tint ret;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ad5933_cmd(st, AD5933_CTRL_MEASURE_TEMP);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = ad5933_wait_busy(st, AD5933_STAT_TEMP_VALID);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = ad5933_i2c_read(st->client,\n\t\t\t\t      AD5933_REG_TEMP_DATA,\n\t\t\t\t      2, (u8 *)&dat);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\t*val = sign_extend32(be16_to_cpu(dat), 13);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 1000;\n\t\t*val2 = 5;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\n\treturn -EINVAL;\nout:\n\tiio_device_release_direct_mode(indio_dev);\n\treturn ret;\n}\n\nstatic const struct iio_info ad5933_info = {\n\t.read_raw = ad5933_read_raw,\n\t.attrs = &ad5933_attribute_group,\n};\n\nstatic int ad5933_ring_preenable(struct iio_dev *indio_dev)\n{\n\tstruct ad5933_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tif (bitmap_empty(indio_dev->active_scan_mask, indio_dev->masklength))\n\t\treturn -EINVAL;\n\n\tret = ad5933_reset(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad5933_cmd(st, AD5933_CTRL_STANDBY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad5933_cmd(st, AD5933_CTRL_INIT_START_FREQ);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->state = AD5933_CTRL_INIT_START_FREQ;\n\n\treturn 0;\n}\n\nstatic int ad5933_ring_postenable(struct iio_dev *indio_dev)\n{\n\tstruct ad5933_state *st = iio_priv(indio_dev);\n\n\t \n\n\tschedule_delayed_work(&st->work,\n\t\t\t      msecs_to_jiffies(AD5933_INIT_EXCITATION_TIME_ms));\n\treturn 0;\n}\n\nstatic int ad5933_ring_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct ad5933_state *st = iio_priv(indio_dev);\n\n\tcancel_delayed_work_sync(&st->work);\n\treturn ad5933_cmd(st, AD5933_CTRL_POWER_DOWN);\n}\n\nstatic const struct iio_buffer_setup_ops ad5933_ring_setup_ops = {\n\t.preenable = ad5933_ring_preenable,\n\t.postenable = ad5933_ring_postenable,\n\t.postdisable = ad5933_ring_postdisable,\n};\n\nstatic void ad5933_work(struct work_struct *work)\n{\n\tstruct ad5933_state *st = container_of(work,\n\t\tstruct ad5933_state, work.work);\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(st->client);\n\t__be16 buf[2];\n\tint val[2];\n\tunsigned char status;\n\tint ret;\n\n\tif (st->state == AD5933_CTRL_INIT_START_FREQ) {\n\t\t \n\t\tad5933_cmd(st, AD5933_CTRL_START_SWEEP);\n\t\tst->state = AD5933_CTRL_START_SWEEP;\n\t\tschedule_delayed_work(&st->work, st->poll_time_jiffies);\n\t\treturn;\n\t}\n\n\tret = ad5933_i2c_read(st->client, AD5933_REG_STATUS, 1, &status);\n\tif (ret)\n\t\treturn;\n\n\tif (status & AD5933_STAT_DATA_VALID) {\n\t\tint scan_count = bitmap_weight(indio_dev->active_scan_mask,\n\t\t\t\t\t       indio_dev->masklength);\n\t\tret = ad5933_i2c_read(st->client,\n\t\t\t\ttest_bit(1, indio_dev->active_scan_mask) ?\n\t\t\t\tAD5933_REG_REAL_DATA : AD5933_REG_IMAG_DATA,\n\t\t\t\tscan_count * 2, (u8 *)buf);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tif (scan_count == 2) {\n\t\t\tval[0] = be16_to_cpu(buf[0]);\n\t\t\tval[1] = be16_to_cpu(buf[1]);\n\t\t} else {\n\t\t\tval[0] = be16_to_cpu(buf[0]);\n\t\t}\n\t\tiio_push_to_buffers(indio_dev, val);\n\t} else {\n\t\t \n\t\tschedule_delayed_work(&st->work, st->poll_time_jiffies);\n\t\treturn;\n\t}\n\n\tif (status & AD5933_STAT_SWEEP_DONE) {\n\t\t \n\t\tad5933_cmd(st, AD5933_CTRL_POWER_DOWN);\n\t} else {\n\t\t \n\t\tad5933_cmd(st, AD5933_CTRL_INC_FREQ);\n\t\tschedule_delayed_work(&st->work, st->poll_time_jiffies);\n\t}\n}\n\nstatic void ad5933_reg_disable(void *data)\n{\n\tstruct ad5933_state *st = data;\n\n\tregulator_disable(st->reg);\n}\n\nstatic void ad5933_clk_disable(void *data)\n{\n\tstruct ad5933_state *st = data;\n\n\tclk_disable_unprepare(st->mclk);\n}\n\nstatic int ad5933_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tint ret;\n\tstruct ad5933_state *st;\n\tstruct iio_dev *indio_dev;\n\tunsigned long ext_clk_hz = 0;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tst->client = client;\n\n\tmutex_init(&st->lock);\n\n\tst->reg = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(st->reg))\n\t\treturn PTR_ERR(st->reg);\n\n\tret = regulator_enable(st->reg);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to enable specified VDD supply\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&client->dev, ad5933_reg_disable, st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_get_voltage(st->reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->vref_mv = ret / 1000;\n\n\tst->mclk = devm_clk_get(&client->dev, \"mclk\");\n\tif (IS_ERR(st->mclk) && PTR_ERR(st->mclk) != -ENOENT)\n\t\treturn PTR_ERR(st->mclk);\n\n\tif (!IS_ERR(st->mclk)) {\n\t\tret = clk_prepare_enable(st->mclk);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\t       ad5933_clk_disable,\n\t\t\t\t\t       st);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\text_clk_hz = clk_get_rate(st->mclk);\n\t}\n\n\tif (ext_clk_hz) {\n\t\tst->mclk_hz = ext_clk_hz;\n\t\tst->ctrl_lb = AD5933_CTRL_EXT_SYSCLK;\n\t} else {\n\t\tst->mclk_hz = AD5933_INT_OSC_FREQ_Hz;\n\t\tst->ctrl_lb = AD5933_CTRL_INT_SYSCLK;\n\t}\n\n\tad5933_calc_out_ranges(st);\n\tINIT_DELAYED_WORK(&st->work, ad5933_work);\n\tst->poll_time_jiffies = msecs_to_jiffies(AD5933_POLL_TIME_ms);\n\n\tindio_dev->info = &ad5933_info;\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = ad5933_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ad5933_channels);\n\n\tret = devm_iio_kfifo_buffer_setup(&client->dev, indio_dev,\n\t\t\t\t\t  &ad5933_ring_setup_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad5933_setup(st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id ad5933_id[] = {\n\t{ \"ad5933\", 0 },\n\t{ \"ad5934\", 0 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, ad5933_id);\n\nstatic const struct of_device_id ad5933_of_match[] = {\n\t{ .compatible = \"adi,ad5933\" },\n\t{ .compatible = \"adi,ad5934\" },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, ad5933_of_match);\n\nstatic struct i2c_driver ad5933_driver = {\n\t.driver = {\n\t\t.name = \"ad5933\",\n\t\t.of_match_table = ad5933_of_match,\n\t},\n\t.probe = ad5933_probe,\n\t.id_table = ad5933_id,\n};\nmodule_i2c_driver(ad5933_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5933 Impedance Conv. Network Analyzer\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}