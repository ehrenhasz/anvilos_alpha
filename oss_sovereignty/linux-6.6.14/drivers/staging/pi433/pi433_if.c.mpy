{
  "module_name": "pi433_if.c",
  "hash_id": "a148b6bed78341b94de3e3ad21c062e502bf9c9f902aba9d1980ffc3cf5a93c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/pi433/pi433_if.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/idr.h>\n#include <linux/ioctl.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/err.h>\n#include <linux/kfifo.h>\n#include <linux/errno.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/spi/spi.h>\n#ifdef CONFIG_COMPAT\n#include <linux/compat.h>\n#endif\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n#include \"pi433_if.h\"\n#include \"rf69.h\"\n\n#define N_PI433_MINORS\t\tBIT(MINORBITS)  \t \n#define MAX_MSG_SIZE\t\t900\t \n#define MSG_FIFO_SIZE\t\t65536    \n#define NUM_DIO\t\t\t2\n\nstatic dev_t pi433_dev;\nstatic DEFINE_IDR(pi433_idr);\nstatic DEFINE_MUTEX(minor_lock);  \nstatic struct dentry *root_dir;\t \n\nstatic struct class *pi433_class;  \n\n \n \nstruct pi433_device {\n\t \n\tdev_t\t\t\tdevt;\n\tint\t\t\tminor;\n\tstruct device\t\t*dev;\n\tstruct cdev\t\t*cdev;\n\tstruct spi_device\t*spi;\n\n\t \n\tstruct gpio_desc\t*gpiod[NUM_DIO];\n\tint\t\t\tirq_num[NUM_DIO];\n\tu8\t\t\tirq_state[NUM_DIO];\n\n\t \n\tSTRUCT_KFIFO_REC_1(MSG_FIFO_SIZE) tx_fifo;\n\tstruct mutex\t\ttx_fifo_lock;  \n\tstruct task_struct\t*tx_task_struct;\n\twait_queue_head_t\ttx_wait_queue;\n\tu8\t\t\tfree_in_fifo;\n\tchar\t\t\tbuffer[MAX_MSG_SIZE];\n\n\t \n\tstruct pi433_rx_cfg\trx_cfg;\n\tu8\t\t\t*rx_buffer;\n\tunsigned int\t\trx_buffer_size;\n\tu32\t\t\trx_bytes_to_drop;\n\tu32\t\t\trx_bytes_dropped;\n\tunsigned int\t\trx_position;\n\tstruct mutex\t\trx_lock;  \n\twait_queue_head_t\trx_wait_queue;\n\n\t \n\tstruct task_struct\t*fifo_task_struct;\n\twait_queue_head_t\tfifo_wait_queue;\n\n\t \n\tbool\t\t\trx_active;\n\tbool\t\t\ttx_active;\n\tbool\t\t\tinterrupt_rx_allowed;\n};\n\nstruct pi433_instance {\n\tstruct pi433_device\t*device;\n\tstruct pi433_tx_cfg\ttx_cfg;\n\n\t \n\tbool\t\t\ttx_cfg_initialized;\n};\n\n \n\n \nstatic irqreturn_t DIO0_irq_handler(int irq, void *dev_id)\n{\n\tstruct pi433_device *device = dev_id;\n\n\tif (device->irq_state[DIO0] == DIO_PACKET_SENT) {\n\t\tdevice->free_in_fifo = FIFO_SIZE;\n\t\tdev_dbg(device->dev, \"DIO0 irq: Packet sent\\n\");\n\t\twake_up_interruptible(&device->fifo_wait_queue);\n\t} else if (device->irq_state[DIO0] == DIO_RSSI_DIO0) {\n\t\tdev_dbg(device->dev, \"DIO0 irq: RSSI level over threshold\\n\");\n\t\twake_up_interruptible(&device->rx_wait_queue);\n\t} else if (device->irq_state[DIO0] == DIO_PAYLOAD_READY) {\n\t\tdev_dbg(device->dev, \"DIO0 irq: Payload ready\\n\");\n\t\tdevice->free_in_fifo = 0;\n\t\twake_up_interruptible(&device->fifo_wait_queue);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t DIO1_irq_handler(int irq, void *dev_id)\n{\n\tstruct pi433_device *device = dev_id;\n\n\tif (device->irq_state[DIO1] == DIO_FIFO_NOT_EMPTY_DIO1) {\n\t\tdevice->free_in_fifo = FIFO_SIZE;\n\t} else if (device->irq_state[DIO1] == DIO_FIFO_LEVEL) {\n\t\tif (device->rx_active)\n\t\t\tdevice->free_in_fifo = FIFO_THRESHOLD - 1;\n\t\telse\n\t\t\tdevice->free_in_fifo = FIFO_SIZE - FIFO_THRESHOLD - 1;\n\t}\n\tdev_dbg(device->dev,\n\t\t\"DIO1 irq: %d bytes free in fifo\\n\", device->free_in_fifo);\n\twake_up_interruptible(&device->fifo_wait_queue);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int\nrf69_set_rx_cfg(struct pi433_device *dev, struct pi433_rx_cfg *rx_cfg)\n{\n\tint ret;\n\tint payload_length;\n\n\t \n\tret = rf69_set_frequency(dev->spi, rx_cfg->frequency);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_modulation(dev->spi, rx_cfg->modulation);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_bit_rate(dev->spi, rx_cfg->bit_rate);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_antenna_impedance(dev->spi, rx_cfg->antenna_impedance);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_rssi_threshold(dev->spi, rx_cfg->rssi_threshold);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_ook_threshold_dec(dev->spi, rx_cfg->threshold_decrement);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_bandwidth(dev->spi, rx_cfg->bw_mantisse,\n\t\t\t\t rx_cfg->bw_exponent);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_bandwidth_during_afc(dev->spi, rx_cfg->bw_mantisse,\n\t\t\t\t\t    rx_cfg->bw_exponent);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_dagc(dev->spi, rx_cfg->dagc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev->rx_bytes_to_drop = rx_cfg->bytes_to_drop;\n\n\t \n\t \n\tif (rx_cfg->enable_sync == OPTION_ON) {\n\t\tret = rf69_enable_sync(dev->spi);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = rf69_set_fifo_fill_condition(dev->spi,\n\t\t\t\t\t\t   after_sync_interrupt);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = rf69_disable_sync(dev->spi);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = rf69_set_fifo_fill_condition(dev->spi, always);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tif (rx_cfg->enable_length_byte == OPTION_ON) {\n\t\tret = rf69_set_packet_format(dev->spi, packet_length_var);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = rf69_set_packet_format(dev->spi, packet_length_fix);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tret = rf69_set_address_filtering(dev->spi,\n\t\t\t\t\t rx_cfg->enable_address_filtering);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (rx_cfg->enable_crc == OPTION_ON) {\n\t\tret = rf69_enable_crc(dev->spi);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = rf69_disable_crc(dev->spi);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = rf69_set_sync_size(dev->spi, rx_cfg->sync_length);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (rx_cfg->enable_length_byte == OPTION_ON) {\n\t\tret = rf69_set_payload_length(dev->spi, 0xff);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (rx_cfg->fixed_message_length != 0) {\n\t\tpayload_length = rx_cfg->fixed_message_length;\n\t\tif (rx_cfg->enable_length_byte  == OPTION_ON)\n\t\t\tpayload_length++;\n\t\tif (rx_cfg->enable_address_filtering != filtering_off)\n\t\t\tpayload_length++;\n\t\tret = rf69_set_payload_length(dev->spi, payload_length);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = rf69_set_payload_length(dev->spi, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (rx_cfg->enable_sync == OPTION_ON) {\n\t\tret = rf69_set_sync_values(dev->spi, rx_cfg->sync_pattern);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tif (rx_cfg->enable_address_filtering != filtering_off) {\n\t\tret = rf69_set_node_address(dev->spi, rx_cfg->node_address);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = rf69_set_broadcast_address(dev->spi,\n\t\t\t\t\t\t rx_cfg->broadcast_address);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nrf69_set_tx_cfg(struct pi433_device *dev, struct pi433_tx_cfg *tx_cfg)\n{\n\tint ret;\n\n\tret = rf69_set_frequency(dev->spi, tx_cfg->frequency);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_modulation(dev->spi, tx_cfg->modulation);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_bit_rate(dev->spi, tx_cfg->bit_rate);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_deviation(dev->spi, tx_cfg->dev_frequency);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_pa_ramp(dev->spi, tx_cfg->pa_ramp);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_modulation_shaping(dev->spi, tx_cfg->mod_shaping);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rf69_set_tx_start_condition(dev->spi, tx_cfg->tx_start_condition);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (tx_cfg->enable_preamble == OPTION_ON) {\n\t\tret = rf69_set_preamble_length(dev->spi,\n\t\t\t\t\t       tx_cfg->preamble_length);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = rf69_set_preamble_length(dev->spi, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (tx_cfg->enable_sync == OPTION_ON) {\n\t\tret = rf69_set_sync_size(dev->spi, tx_cfg->sync_length);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = rf69_set_sync_values(dev->spi, tx_cfg->sync_pattern);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = rf69_enable_sync(dev->spi);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = rf69_disable_sync(dev->spi);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (tx_cfg->enable_length_byte == OPTION_ON) {\n\t\tret = rf69_set_packet_format(dev->spi, packet_length_var);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = rf69_set_packet_format(dev->spi, packet_length_fix);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (tx_cfg->enable_crc == OPTION_ON) {\n\t\tret = rf69_enable_crc(dev->spi);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = rf69_disable_crc(dev->spi);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int pi433_start_rx(struct pi433_device *dev)\n{\n\tint retval;\n\n\t \n\tif (!dev->rx_active)\n\t\treturn 0;\n\n\t \n\tretval = rf69_set_rx_cfg(dev, &dev->rx_cfg);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tretval = rf69_set_dio_mapping(dev->spi, DIO0, DIO_RSSI_DIO0);\n\tif (retval < 0)\n\t\treturn retval;\n\tdev->irq_state[DIO0] = DIO_RSSI_DIO0;\n\tirq_set_irq_type(dev->irq_num[DIO0], IRQ_TYPE_EDGE_RISING);\n\n\t \n\tretval = rf69_set_fifo_threshold(dev->spi, FIFO_SIZE - FIFO_THRESHOLD);\n\tif (retval < 0)\n\t\treturn retval;\n\tretval = rf69_set_dio_mapping(dev->spi, DIO1, DIO_FIFO_LEVEL);\n\tif (retval < 0)\n\t\treturn retval;\n\tdev->irq_state[DIO1] = DIO_FIFO_LEVEL;\n\tirq_set_irq_type(dev->irq_num[DIO1], IRQ_TYPE_EDGE_RISING);\n\n\t \n\tretval = rf69_set_mode(dev->spi, receive);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn 0;\n}\n\n \n\nstatic int pi433_receive(void *data)\n{\n\tstruct pi433_device *dev = data;\n\tstruct spi_device *spi = dev->spi;\n\tint bytes_to_read, bytes_total;\n\tint retval;\n\n\tdev->interrupt_rx_allowed = false;\n\n\t \n\tdev_dbg(dev->dev, \"rx: going to wait for any tx to finish\\n\");\n\tretval = wait_event_interruptible(dev->rx_wait_queue, !dev->tx_active);\n\tif (retval) {\n\t\t \n\t\tdev->interrupt_rx_allowed = true;\n\t\twake_up_interruptible(&dev->tx_wait_queue);\n\t\treturn retval;\n\t}\n\n\t \n\tdev->free_in_fifo = FIFO_SIZE;\n\tdev->rx_position = 0;\n\tdev->rx_bytes_dropped = 0;\n\n\t \n\tretval = pi433_start_rx(dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\twhile (!(rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RSSI)) {\n\t\t \n\t\tdev->interrupt_rx_allowed = true;\n\t\twake_up_interruptible(&dev->tx_wait_queue);\n\n\t\t \n\t\tdev_dbg(dev->dev, \"rx: going to wait for high RSSI level\\n\");\n\t\tretval = wait_event_interruptible(dev->rx_wait_queue,\n\t\t\t\t\t\t  rf69_read_reg(spi, REG_IRQFLAGS1) &\n\t\t\t\t\t\t  MASK_IRQFLAGS1_RSSI);\n\t\tif (retval)  \n\t\t\tgoto abort;\n\t\tdev->interrupt_rx_allowed = false;\n\n\t\t \n\t\tif (!dev->tx_active)\n\t\t\tbreak;\n\t}\n\n\t \n\tretval = rf69_set_dio_mapping(spi, DIO0, DIO_PAYLOAD_READY);\n\tif (retval < 0)\n\t\tgoto abort;\n\tdev->irq_state[DIO0] = DIO_PAYLOAD_READY;\n\tirq_set_irq_type(dev->irq_num[DIO0], IRQ_TYPE_EDGE_RISING);\n\n\t \n\tif (dev->rx_cfg.fixed_message_length != 0) {\n\t\tif (dev->rx_cfg.fixed_message_length > dev->rx_buffer_size) {\n\t\t\tretval = -1;\n\t\t\tgoto abort;\n\t\t}\n\t\tbytes_total = dev->rx_cfg.fixed_message_length;\n\t\tdev_dbg(dev->dev, \"rx: msg len set to %d by fixed length\\n\",\n\t\t\tbytes_total);\n\t} else {\n\t\tbytes_total = dev->rx_buffer_size;\n\t\tdev_dbg(dev->dev, \"rx: msg len set to %d as requested by read\\n\",\n\t\t\tbytes_total);\n\t}\n\n\t \n\tif (dev->rx_cfg.enable_length_byte == OPTION_ON) {\n\t\tretval = wait_event_interruptible(dev->fifo_wait_queue,\n\t\t\t\t\t\t  dev->free_in_fifo < FIFO_SIZE);\n\t\tif (retval)  \n\t\t\tgoto abort;\n\n\t\trf69_read_fifo(spi, (u8 *)&bytes_total, 1);\n\t\tif (bytes_total > dev->rx_buffer_size) {\n\t\t\tretval = -1;\n\t\t\tgoto abort;\n\t\t}\n\t\tdev->free_in_fifo++;\n\t\tdev_dbg(dev->dev, \"rx: msg len reset to %d due to length byte\\n\",\n\t\t\tbytes_total);\n\t}\n\n\t \n\tif (dev->rx_cfg.enable_address_filtering != filtering_off) {\n\t\tu8 dummy;\n\n\t\tbytes_total--;\n\n\t\tretval = wait_event_interruptible(dev->fifo_wait_queue,\n\t\t\t\t\t\t  dev->free_in_fifo < FIFO_SIZE);\n\t\tif (retval)  \n\t\t\tgoto abort;\n\n\t\trf69_read_fifo(spi, &dummy, 1);\n\t\tdev->free_in_fifo++;\n\t\tdev_dbg(dev->dev, \"rx: address byte stripped off\\n\");\n\t}\n\n\t \n\twhile (dev->rx_position < bytes_total) {\n\t\tif (!(rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PAYLOAD_READY)) {\n\t\t\tretval = wait_event_interruptible(dev->fifo_wait_queue,\n\t\t\t\t\t\t\t  dev->free_in_fifo < FIFO_SIZE);\n\t\t\tif (retval)  \n\t\t\t\tgoto abort;\n\t\t}\n\n\t\t \n\t\tif (dev->rx_bytes_to_drop > dev->rx_bytes_dropped)\n\t\t\tbytes_to_read = dev->rx_bytes_to_drop -\n\t\t\t\t\tdev->rx_bytes_dropped;\n\t\telse\n\t\t\tbytes_to_read = bytes_total - dev->rx_position;\n\n\t\t \n\t\tif (bytes_to_read > FIFO_SIZE - dev->free_in_fifo)\n\t\t\tbytes_to_read = FIFO_SIZE - dev->free_in_fifo;\n\t\tretval = rf69_read_fifo(spi,\n\t\t\t\t\t&dev->rx_buffer[dev->rx_position],\n\t\t\t\t\tbytes_to_read);\n\t\tif (retval)  \n\t\t\tgoto abort;\n\n\t\tdev->free_in_fifo += bytes_to_read;\n\n\t\t \n\t\tif (dev->rx_bytes_to_drop > dev->rx_bytes_dropped)\n\t\t\tdev->rx_bytes_dropped += bytes_to_read;\n\t\telse\n\t\t\tdev->rx_position += bytes_to_read;\n\t}\n\n\t \nabort:\n\tdev->interrupt_rx_allowed = true;\n\tif (rf69_set_mode(dev->spi, standby))\n\t\tpr_err(\"rf69_set_mode(): radio module failed to go standby\\n\");\n\twake_up_interruptible(&dev->tx_wait_queue);\n\n\tif (retval)\n\t\treturn retval;\n\telse\n\t\treturn bytes_total;\n}\n\nstatic int pi433_tx_thread(void *data)\n{\n\tstruct pi433_device *device = data;\n\tstruct spi_device *spi = device->spi;\n\tstruct pi433_tx_cfg tx_cfg;\n\tsize_t size;\n\tbool   rx_interrupted = false;\n\tint    position, repetitions;\n\tint    retval;\n\n\twhile (1) {\n\t\t \n\t\tdev_dbg(device->dev, \"thread: going to wait for new messages\\n\");\n\t\twait_event_interruptible(device->tx_wait_queue,\n\t\t\t\t\t (!kfifo_is_empty(&device->tx_fifo) ||\n\t\t\t\t\t  kthread_should_stop()));\n\t\tif (kthread_should_stop())\n\t\t\treturn 0;\n\n\t\t \n\t\tretval = kfifo_out(&device->tx_fifo, &tx_cfg, sizeof(tx_cfg));\n\t\tif (retval != sizeof(tx_cfg)) {\n\t\t\tdev_dbg(device->dev,\n\t\t\t\t\"reading tx_cfg from fifo failed: got %d byte(s), expected %d\\n\",\n\t\t\t\tretval, (unsigned int)sizeof(tx_cfg));\n\t\t\tcontinue;\n\t\t}\n\n\t\tretval = kfifo_out(&device->tx_fifo, &size, sizeof(size_t));\n\t\tif (retval != sizeof(size_t)) {\n\t\t\tdev_dbg(device->dev,\n\t\t\t\t\"reading msg size from fifo failed: got %d, expected %d\\n\",\n\t\t\t\tretval, (unsigned int)sizeof(size_t));\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (tx_cfg.fixed_message_length != 0)\n\t\t\tsize = tx_cfg.fixed_message_length;\n\n\t\t \n\t\tif (tx_cfg.enable_length_byte == OPTION_ON)\n\t\t\tsize++;\n\n\t\t \n\t\tif (tx_cfg.enable_address_byte == OPTION_ON)\n\t\t\tsize++;\n\n\t\t \n\t\tmemset(device->buffer, 0, size);\n\t\tposition = 0;\n\n\t\t \n\t\tif (tx_cfg.enable_length_byte  == OPTION_ON)\n\t\t\t \n\t\t\tdevice->buffer[position++] = size - 1;\n\n\t\t \n\t\tif (tx_cfg.enable_address_byte == OPTION_ON)\n\t\t\tdevice->buffer[position++] = tx_cfg.address_byte;\n\n\t\t \n\t\tretval = kfifo_out(&device->tx_fifo, &device->buffer[position],\n\t\t\t\t   sizeof(device->buffer) - position);\n\t\tdev_dbg(device->dev,\n\t\t\t\"read %d message byte(s) from fifo queue.\\n\", retval);\n\n\t\t \n\t\twait_event_interruptible(device->tx_wait_queue,\n\t\t\t\t\t !device->rx_active ||\n\t\t\t\t\t  device->interrupt_rx_allowed);\n\n\t\t \n\t\tdisable_irq(device->irq_num[DIO0]);\n\t\tdevice->tx_active = true;\n\n\t\t \n\t\tretval = rf69_set_mode(spi, standby);  \n\t\tif (retval < 0)\n\t\t\tgoto abort;\n\n\t\tif (device->rx_active && !rx_interrupted) {\n\t\t\t \n\t\t\trx_interrupted = true;\n\t\t}\n\n\t\tretval = rf69_set_fifo_threshold(spi, FIFO_THRESHOLD);\n\t\tif (retval < 0)\n\t\t\tgoto abort;\n\t\tif (tx_cfg.enable_length_byte == OPTION_ON) {\n\t\t\tretval = rf69_set_payload_length(spi, size * tx_cfg.repetitions);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto abort;\n\t\t} else {\n\t\t\tretval = rf69_set_payload_length(spi, 0);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto abort;\n\t\t}\n\n\t\t \n\t\tretval = rf69_set_tx_cfg(device, &tx_cfg);\n\t\tif (retval < 0)\n\t\t\tgoto abort;\n\n\t\t \n\t\tretval = rf69_set_dio_mapping(spi, DIO1, DIO_FIFO_LEVEL);\n\t\tif (retval < 0)\n\t\t\tgoto abort;\n\t\tdevice->irq_state[DIO1] = DIO_FIFO_LEVEL;\n\t\tirq_set_irq_type(device->irq_num[DIO1], IRQ_TYPE_EDGE_FALLING);\n\n\t\t \n\t\tretval = rf69_set_dio_mapping(spi, DIO0, DIO_PACKET_SENT);\n\t\tif (retval < 0)\n\t\t\tgoto abort;\n\t\tdevice->irq_state[DIO0] = DIO_PACKET_SENT;\n\t\tirq_set_irq_type(device->irq_num[DIO0], IRQ_TYPE_EDGE_RISING);\n\t\tenable_irq(device->irq_num[DIO0]);  \n\n\t\t \n\t\tretval = rf69_set_mode(spi, transmit);\n\t\tif (retval < 0)\n\t\t\tgoto abort;\n\n\t\t \n\t\tdevice->free_in_fifo = FIFO_SIZE;\n\t\tposition = 0;\n\t\trepetitions = tx_cfg.repetitions;\n\t\twhile ((repetitions > 0) && (size > position)) {\n\t\t\tif ((size - position) > device->free_in_fifo) {\n\t\t\t\t \n\t\t\t\tint write_size = device->free_in_fifo;\n\n\t\t\t\tdevice->free_in_fifo = 0;\n\t\t\t\trf69_write_fifo(spi,\n\t\t\t\t\t\t&device->buffer[position],\n\t\t\t\t\t\twrite_size);\n\t\t\t\tposition += write_size;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdevice->free_in_fifo -= size;\n\t\t\t\trepetitions--;\n\t\t\t\trf69_write_fifo(spi,\n\t\t\t\t\t\t&device->buffer[position],\n\t\t\t\t\t\t(size - position));\n\t\t\t\tposition = 0;  \n\t\t\t}\n\n\t\t\tretval = wait_event_interruptible(device->fifo_wait_queue,\n\t\t\t\t\t\t\t  device->free_in_fifo > 0);\n\t\t\tif (retval) {\n\t\t\t\tdev_dbg(device->dev, \"ABORT\\n\");\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdev_dbg(device->dev,\n\t\t\t\"thread: wait for packet to get sent/fifo to be empty\\n\");\n\t\twait_event_interruptible(device->fifo_wait_queue,\n\t\t\t\t\t device->free_in_fifo == FIFO_SIZE ||\n\t\t\t\t\t kthread_should_stop());\n\t\tif (kthread_should_stop())\n\t\t\treturn 0;\n\n\t\t \n\t\tdev_dbg(device->dev, \"thread: Packet sent. Set mode to stby.\\n\");\n\t\tretval = rf69_set_mode(spi, standby);\n\t\tif (retval < 0)\n\t\t\tgoto abort;\n\n\t\t \n\t\tif (kfifo_is_empty(&device->tx_fifo)) {\nabort:\n\t\t\tif (rx_interrupted) {\n\t\t\t\trx_interrupted = false;\n\t\t\t\tpi433_start_rx(device);\n\t\t\t}\n\t\t\tdevice->tx_active = false;\n\t\t\twake_up_interruptible(&device->rx_wait_queue);\n\t\t}\n\t}\n}\n\n \n\nstatic ssize_t\npi433_read(struct file *filp, char __user *buf, size_t size, loff_t *f_pos)\n{\n\tstruct pi433_instance\t*instance;\n\tstruct pi433_device\t*device;\n\tint\t\t\tbytes_received;\n\tssize_t\t\t\tretval;\n\n\t \n\tif (size > MAX_MSG_SIZE)\n\t\treturn -EMSGSIZE;\n\n\tinstance = filp->private_data;\n\tdevice = instance->device;\n\n\t \n\tmutex_lock(&device->rx_lock);\n\tif (device->rx_active) {\n\t\tmutex_unlock(&device->rx_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tdevice->rx_active = true;\n\tmutex_unlock(&device->rx_lock);\n\n\t \n\t \n\tdevice->rx_buffer_size = size;\n\tbytes_received = pi433_receive(device);\n\n\t \n\tmutex_lock(&device->rx_lock);\n\tdevice->rx_active = false;\n\tmutex_unlock(&device->rx_lock);\n\n\t \n\tif (bytes_received > 0) {\n\t\tretval = copy_to_user(buf, device->rx_buffer, bytes_received);\n\t\tif (retval)\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn bytes_received;\n}\n\nstatic ssize_t\npi433_write(struct file *filp, const char __user *buf,\n\t    size_t count, loff_t *f_pos)\n{\n\tstruct pi433_instance\t*instance;\n\tstruct pi433_device\t*device;\n\tint                     retval;\n\tunsigned int\t\trequired, available, copied;\n\n\tinstance = filp->private_data;\n\tdevice = instance->device;\n\n\t \n\tif (count > MAX_MSG_SIZE)\n\t\treturn -EMSGSIZE;\n\n\t \n\tif (!instance->tx_cfg_initialized) {\n\t\tdev_notice_once(device->dev,\n\t\t\t\t\"write: failed due to unconfigured tx_cfg (see PI433_IOC_WR_TX_CFG)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmutex_lock(&device->tx_fifo_lock);\n\n\trequired = sizeof(instance->tx_cfg) + sizeof(size_t) + count;\n\tavailable = kfifo_avail(&device->tx_fifo);\n\tif (required > available) {\n\t\tdev_dbg(device->dev, \"write to fifo failed: %d bytes required but %d available\\n\",\n\t\t\trequired, available);\n\t\tmutex_unlock(&device->tx_fifo_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tretval = kfifo_in(&device->tx_fifo, &instance->tx_cfg,\n\t\t\t  sizeof(instance->tx_cfg));\n\tif (retval != sizeof(instance->tx_cfg))\n\t\tgoto abort;\n\n\tretval = kfifo_in(&device->tx_fifo, &count, sizeof(size_t));\n\tif (retval != sizeof(size_t))\n\t\tgoto abort;\n\n\tretval = kfifo_from_user(&device->tx_fifo, buf, count, &copied);\n\tif (retval || copied != count)\n\t\tgoto abort;\n\n\tmutex_unlock(&device->tx_fifo_lock);\n\n\t \n\twake_up_interruptible(&device->tx_wait_queue);\n\tdev_dbg(device->dev, \"write: generated new msg with %d bytes.\\n\", copied);\n\n\treturn copied;\n\nabort:\n\tdev_warn(device->dev,\n\t\t \"write to fifo failed, non recoverable: 0x%x\\n\", retval);\n\tmutex_unlock(&device->tx_fifo_lock);\n\treturn -EAGAIN;\n}\n\nstatic long pi433_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct pi433_instance\t*instance;\n\tstruct pi433_device\t*device;\n\tstruct pi433_tx_cfg\ttx_cfg;\n\tvoid __user *argp = (void __user *)arg;\n\n\t \n\tif (_IOC_TYPE(cmd) != PI433_IOC_MAGIC)\n\t\treturn -ENOTTY;\n\n\tinstance = filp->private_data;\n\tdevice = instance->device;\n\n\tif (!device)\n\t\treturn -ESHUTDOWN;\n\n\tswitch (cmd) {\n\tcase PI433_IOC_RD_TX_CFG:\n\t\tif (copy_to_user(argp, &instance->tx_cfg,\n\t\t\t\t sizeof(struct pi433_tx_cfg)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase PI433_IOC_WR_TX_CFG:\n\t\tif (copy_from_user(&tx_cfg, argp, sizeof(struct pi433_tx_cfg)))\n\t\t\treturn -EFAULT;\n\t\tmutex_lock(&device->tx_fifo_lock);\n\t\tmemcpy(&instance->tx_cfg, &tx_cfg, sizeof(struct pi433_tx_cfg));\n\t\tinstance->tx_cfg_initialized = true;\n\t\tmutex_unlock(&device->tx_fifo_lock);\n\t\tbreak;\n\tcase PI433_IOC_RD_RX_CFG:\n\t\tif (copy_to_user(argp, &device->rx_cfg,\n\t\t\t\t sizeof(struct pi433_rx_cfg)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase PI433_IOC_WR_RX_CFG:\n\t\tmutex_lock(&device->rx_lock);\n\n\t\t \n\t\tif (device->rx_active) {\n\t\t\tmutex_unlock(&device->rx_lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (copy_from_user(&device->rx_cfg, argp,\n\t\t\t\t   sizeof(struct pi433_rx_cfg))) {\n\t\t\tmutex_unlock(&device->rx_lock);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tmutex_unlock(&device->rx_lock);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int pi433_open(struct inode *inode, struct file *filp)\n{\n\tstruct pi433_device\t*device;\n\tstruct pi433_instance\t*instance;\n\n\tmutex_lock(&minor_lock);\n\tdevice = idr_find(&pi433_idr, iminor(inode));\n\tmutex_unlock(&minor_lock);\n\tif (!device) {\n\t\tpr_debug(\"device: minor %d unknown.\\n\", iminor(inode));\n\t\treturn -ENODEV;\n\t}\n\n\tinstance = kzalloc(sizeof(*instance), GFP_KERNEL);\n\tif (!instance)\n\t\treturn -ENOMEM;\n\n\t \n\tinstance->device = device;\n\n\t \n\tfilp->private_data = instance;\n\tstream_open(inode, filp);\n\n\treturn 0;\n}\n\nstatic int pi433_release(struct inode *inode, struct file *filp)\n{\n\tstruct pi433_instance\t*instance;\n\n\tinstance = filp->private_data;\n\tkfree(instance);\n\tfilp->private_data = NULL;\n\n\treturn 0;\n}\n\n \n\nstatic int setup_gpio(struct pi433_device *device)\n{\n\tchar\tname[5];\n\tint\tretval;\n\tint\ti;\n\tconst irq_handler_t DIO_irq_handler[NUM_DIO] = {\n\t\tDIO0_irq_handler,\n\t\tDIO1_irq_handler\n\t};\n\n\tfor (i = 0; i < NUM_DIO; i++) {\n\t\t \n\t\tsnprintf(name, sizeof(name), \"DIO%d\", i);\n\t\tdevice->gpiod[i] = gpiod_get(&device->spi->dev, name,\n\t\t\t\t\t     0  );\n\n\t\tif (device->gpiod[i] == ERR_PTR(-ENOENT)) {\n\t\t\tdev_dbg(&device->spi->dev,\n\t\t\t\t\"Could not find entry for %s. Ignoring.\\n\", name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (device->gpiod[i] == ERR_PTR(-EBUSY))\n\t\t\tdev_dbg(&device->spi->dev, \"%s is busy.\\n\", name);\n\n\t\tif (IS_ERR(device->gpiod[i])) {\n\t\t\tretval = PTR_ERR(device->gpiod[i]);\n\t\t\t \n\t\t\tfor (i--; i >= 0; i--) {\n\t\t\t\tfree_irq(device->irq_num[i], device);\n\t\t\t\tgpiod_put(device->gpiod[i]);\n\t\t\t}\n\t\t\treturn retval;\n\t\t}\n\n\t\t \n\t\tretval = gpiod_direction_input(device->gpiod[i]);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\t \n\t\tdevice->irq_num[i] = gpiod_to_irq(device->gpiod[i]);\n\t\tif (device->irq_num[i] < 0) {\n\t\t\tdevice->gpiod[i] = ERR_PTR(-EINVAL);\n\t\t\treturn device->irq_num[i];\n\t\t}\n\t\tretval = request_irq(device->irq_num[i],\n\t\t\t\t     DIO_irq_handler[i],\n\t\t\t\t     0,  \n\t\t\t\t     name,\n\t\t\t\t     device);\n\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tdev_dbg(&device->spi->dev, \"%s successfully configured\\n\", name);\n\t}\n\n\treturn 0;\n}\n\nstatic void free_gpio(struct pi433_device *device)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_DIO; i++) {\n\t\t \n\t\tif (IS_ERR(device->gpiod[i]))\n\t\t\tcontinue;\n\n\t\tfree_irq(device->irq_num[i], device);\n\t\tgpiod_put(device->gpiod[i]);\n\t}\n}\n\nstatic int pi433_get_minor(struct pi433_device *device)\n{\n\tint retval = -ENOMEM;\n\n\tmutex_lock(&minor_lock);\n\tretval = idr_alloc(&pi433_idr, device, 0, N_PI433_MINORS, GFP_KERNEL);\n\tif (retval >= 0) {\n\t\tdevice->minor = retval;\n\t\tretval = 0;\n\t} else if (retval == -ENOSPC) {\n\t\tdev_err(&device->spi->dev, \"too many pi433 devices\\n\");\n\t\tretval = -EINVAL;\n\t}\n\tmutex_unlock(&minor_lock);\n\treturn retval;\n}\n\nstatic void pi433_free_minor(struct pi433_device *dev)\n{\n\tmutex_lock(&minor_lock);\n\tidr_remove(&pi433_idr, dev->minor);\n\tmutex_unlock(&minor_lock);\n}\n\n \n\nstatic const struct file_operations pi433_fops = {\n\t.owner =\tTHIS_MODULE,\n\t \n\t.write =\tpi433_write,\n\t.read =\t\tpi433_read,\n\t.unlocked_ioctl = pi433_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.open =\t\tpi433_open,\n\t.release =\tpi433_release,\n\t.llseek =\tno_llseek,\n};\n\nstatic int pi433_debugfs_regs_show(struct seq_file *m, void *p)\n{\n\tstruct pi433_device *dev;\n\tu8 reg_data[114];\n\tint i;\n\tchar *fmt = \"0x%02x, 0x%02x\\n\";\n\tint ret;\n\n\tdev = m->private;\n\n\tmutex_lock(&dev->tx_fifo_lock);\n\tmutex_lock(&dev->rx_lock);\n\n\t \n\tret = wait_event_interruptible(dev->rx_wait_queue, !dev->tx_active);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = wait_event_interruptible(dev->tx_wait_queue, !dev->rx_active);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tfor (i = 1; i < 0x50; i++)\n\t\treg_data[i] = rf69_read_reg(dev->spi, i);\n\n\treg_data[REG_TESTLNA] = rf69_read_reg(dev->spi, REG_TESTLNA);\n\treg_data[REG_TESTPA1] = rf69_read_reg(dev->spi, REG_TESTPA1);\n\treg_data[REG_TESTPA2] = rf69_read_reg(dev->spi, REG_TESTPA2);\n\treg_data[REG_TESTDAGC] = rf69_read_reg(dev->spi, REG_TESTDAGC);\n\treg_data[REG_TESTAFC] = rf69_read_reg(dev->spi, REG_TESTAFC);\n\n\tseq_puts(m, \"# reg, val\\n\");\n\n\tfor (i = 1; i < 0x50; i++)\n\t\tseq_printf(m, fmt, i, reg_data[i]);\n\n\tseq_printf(m, fmt, REG_TESTLNA, reg_data[REG_TESTLNA]);\n\tseq_printf(m, fmt, REG_TESTPA1, reg_data[REG_TESTPA1]);\n\tseq_printf(m, fmt, REG_TESTPA2, reg_data[REG_TESTPA2]);\n\tseq_printf(m, fmt, REG_TESTDAGC, reg_data[REG_TESTDAGC]);\n\tseq_printf(m, fmt, REG_TESTAFC, reg_data[REG_TESTAFC]);\n\nout_unlock:\n\tmutex_unlock(&dev->rx_lock);\n\tmutex_unlock(&dev->tx_fifo_lock);\n\n\treturn ret;\n}\nDEFINE_SHOW_ATTRIBUTE(pi433_debugfs_regs);\n\n \n\nstatic int pi433_probe(struct spi_device *spi)\n{\n\tstruct pi433_device\t*device;\n\tint\t\t\tretval;\n\tstruct dentry\t\t*entry;\n\n\t \n\tspi->mode = 0x00;\n\tspi->bits_per_word = 8;\n\t \n\n\tretval = spi_setup(spi);\n\tif (retval) {\n\t\tdev_dbg(&spi->dev, \"configuration of SPI interface failed!\\n\");\n\t\treturn retval;\n\t}\n\n\tdev_dbg(&spi->dev,\n\t\t\"spi interface setup: mode 0x%2x, %d bits per word, %dhz max speed\\n\",\n\t\tspi->mode, spi->bits_per_word, spi->max_speed_hz);\n\n\t \n\tretval = rf69_get_version(spi);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tswitch (retval) {\n\tcase 0x24:\n\t\tdev_dbg(&spi->dev, \"found pi433 (ver. 0x%x)\\n\", retval);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&spi->dev, \"unknown chip version: 0x%x\\n\", retval);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdevice = kzalloc(sizeof(*device), GFP_KERNEL);\n\tif (!device)\n\t\treturn -ENOMEM;\n\n\t \n\tdevice->spi = spi;\n\tdevice->rx_active = false;\n\tdevice->tx_active = false;\n\tdevice->interrupt_rx_allowed = false;\n\n\t \n\tdevice->rx_buffer = kmalloc(MAX_MSG_SIZE, GFP_KERNEL);\n\tif (!device->rx_buffer) {\n\t\tretval = -ENOMEM;\n\t\tgoto RX_failed;\n\t}\n\n\t \n\tinit_waitqueue_head(&device->tx_wait_queue);\n\tinit_waitqueue_head(&device->rx_wait_queue);\n\tinit_waitqueue_head(&device->fifo_wait_queue);\n\n\t \n\tINIT_KFIFO(device->tx_fifo);\n\n\t \n\tmutex_init(&device->tx_fifo_lock);\n\tmutex_init(&device->rx_lock);\n\n\t \n\tretval = setup_gpio(device);\n\tif (retval) {\n\t\tdev_dbg(&spi->dev, \"setup of GPIOs failed\\n\");\n\t\tgoto GPIO_failed;\n\t}\n\n\t \n\tretval = rf69_set_mode(spi, standby);\n\tif (retval < 0)\n\t\tgoto minor_failed;\n\tretval = rf69_set_data_mode(spi, DATAMODUL_MODE_PACKET);\n\tif (retval < 0)\n\t\tgoto minor_failed;\n\tretval = rf69_enable_amplifier(spi, MASK_PALEVEL_PA0);\n\tif (retval < 0)\n\t\tgoto minor_failed;\n\tretval = rf69_disable_amplifier(spi, MASK_PALEVEL_PA1);\n\tif (retval < 0)\n\t\tgoto minor_failed;\n\tretval = rf69_disable_amplifier(spi, MASK_PALEVEL_PA2);\n\tif (retval < 0)\n\t\tgoto minor_failed;\n\tretval = rf69_set_output_power_level(spi, 13);\n\tif (retval < 0)\n\t\tgoto minor_failed;\n\tretval = rf69_set_antenna_impedance(spi, fifty_ohm);\n\tif (retval < 0)\n\t\tgoto minor_failed;\n\n\t \n\tretval = pi433_get_minor(device);\n\tif (retval) {\n\t\tdev_dbg(&spi->dev, \"get of minor number failed\\n\");\n\t\tgoto minor_failed;\n\t}\n\n\t \n\tdevice->devt = MKDEV(MAJOR(pi433_dev), device->minor);\n\tdevice->dev = device_create(pi433_class,\n\t\t\t\t    &spi->dev,\n\t\t\t\t    device->devt,\n\t\t\t\t    device,\n\t\t\t\t    \"pi433.%d\",\n\t\t\t\t    device->minor);\n\tif (IS_ERR(device->dev)) {\n\t\tpr_err(\"pi433: device register failed\\n\");\n\t\tretval = PTR_ERR(device->dev);\n\t\tgoto device_create_failed;\n\t} else {\n\t\tdev_dbg(device->dev,\n\t\t\t\"created device for major %d, minor %d\\n\",\n\t\t\tMAJOR(pi433_dev),\n\t\t\tdevice->minor);\n\t}\n\n\t \n\tdevice->tx_task_struct = kthread_run(pi433_tx_thread,\n\t\t\t\t\t     device,\n\t\t\t\t\t     \"pi433.%d_tx_task\",\n\t\t\t\t\t     device->minor);\n\tif (IS_ERR(device->tx_task_struct)) {\n\t\tdev_dbg(device->dev, \"start of send thread failed\\n\");\n\t\tretval = PTR_ERR(device->tx_task_struct);\n\t\tgoto send_thread_failed;\n\t}\n\n\t \n\tdevice->cdev = cdev_alloc();\n\tif (!device->cdev) {\n\t\tdev_dbg(device->dev, \"allocation of cdev failed\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto cdev_failed;\n\t}\n\tdevice->cdev->owner = THIS_MODULE;\n\tcdev_init(device->cdev, &pi433_fops);\n\tretval = cdev_add(device->cdev, device->devt, 1);\n\tif (retval) {\n\t\tdev_dbg(device->dev, \"register of cdev failed\\n\");\n\t\tgoto del_cdev;\n\t}\n\n\t \n\tspi_set_drvdata(spi, device);\n\n\tentry = debugfs_create_dir(dev_name(device->dev), root_dir);\n\tdebugfs_create_file(\"regs\", 0400, entry, device, &pi433_debugfs_regs_fops);\n\n\treturn 0;\n\ndel_cdev:\n\tcdev_del(device->cdev);\ncdev_failed:\n\tkthread_stop(device->tx_task_struct);\nsend_thread_failed:\n\tdevice_destroy(pi433_class, device->devt);\ndevice_create_failed:\n\tpi433_free_minor(device);\nminor_failed:\n\tfree_gpio(device);\nGPIO_failed:\n\tkfree(device->rx_buffer);\nRX_failed:\n\tkfree(device);\n\n\treturn retval;\n}\n\nstatic void pi433_remove(struct spi_device *spi)\n{\n\tstruct pi433_device\t*device = spi_get_drvdata(spi);\n\n\tdebugfs_lookup_and_remove(dev_name(device->dev), root_dir);\n\n\t \n\tfree_gpio(device);\n\n\t \n\tdevice->spi = NULL;\n\n\tkthread_stop(device->tx_task_struct);\n\n\tdevice_destroy(pi433_class, device->devt);\n\n\tcdev_del(device->cdev);\n\n\tpi433_free_minor(device);\n\n\tkfree(device->rx_buffer);\n\tkfree(device);\n}\n\nstatic const struct of_device_id pi433_dt_ids[] = {\n\t{ .compatible = \"Smarthome-Wolf,pi433\" },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, pi433_dt_ids);\n\nstatic struct spi_driver pi433_spi_driver = {\n\t.driver = {\n\t\t.name =\t\t\"pi433\",\n\t\t.owner =\tTHIS_MODULE,\n\t\t.of_match_table = of_match_ptr(pi433_dt_ids),\n\t},\n\t.probe =\tpi433_probe,\n\t.remove =\tpi433_remove,\n\n\t \n};\n\n \n\nstatic int __init pi433_init(void)\n{\n\tint status;\n\n\t \n\tif (MAX_MSG_SIZE < FIFO_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tstatus = alloc_chrdev_region(&pi433_dev, 0, N_PI433_MINORS, \"pi433\");\n\tif (status < 0)\n\t\treturn status;\n\n\tpi433_class = class_create(\"pi433\");\n\tif (IS_ERR(pi433_class)) {\n\t\tunregister_chrdev(MAJOR(pi433_dev),\n\t\t\t\t  pi433_spi_driver.driver.name);\n\t\treturn PTR_ERR(pi433_class);\n\t}\n\n\troot_dir = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\n\tstatus = spi_register_driver(&pi433_spi_driver);\n\tif (status < 0) {\n\t\tclass_destroy(pi433_class);\n\t\tunregister_chrdev(MAJOR(pi433_dev),\n\t\t\t\t  pi433_spi_driver.driver.name);\n\t}\n\n\treturn status;\n}\n\nmodule_init(pi433_init);\n\nstatic void __exit pi433_exit(void)\n{\n\tspi_unregister_driver(&pi433_spi_driver);\n\tclass_destroy(pi433_class);\n\tunregister_chrdev(MAJOR(pi433_dev), pi433_spi_driver.driver.name);\n\tdebugfs_remove(root_dir);\n}\nmodule_exit(pi433_exit);\n\nMODULE_AUTHOR(\"Marcus Wolf, <linux@wolf-entwicklungen.de>\");\nMODULE_DESCRIPTION(\"Driver for Pi433\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:pi433\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}