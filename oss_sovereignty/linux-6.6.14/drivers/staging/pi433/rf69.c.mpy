{
  "module_name": "rf69.c",
  "hash_id": "21d2bdfca3cd4d9e2fdcaa67645da4d2426ecfe57a54853024513966dfc6b150",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/pi433/rf69.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/spi/spi.h>\n\n#include \"rf69.h\"\n#include \"rf69_registers.h\"\n\n#define F_OSC\t  32000000  \n#define FIFO_SIZE 66\t    \n\n \n\nu8 rf69_read_reg(struct spi_device *spi, u8 addr)\n{\n\treturn spi_w8r8(spi, addr);\n}\n\nstatic int rf69_write_reg(struct spi_device *spi, u8 addr, u8 value)\n{\n\tchar buffer[2];\n\n\tbuffer[0] = addr | WRITE_BIT;\n\tbuffer[1] = value;\n\n\treturn spi_write(spi, &buffer, ARRAY_SIZE(buffer));\n}\n\n \n\nstatic int rf69_set_bit(struct spi_device *spi, u8 reg, u8 mask)\n{\n\tu8 tmp;\n\n\ttmp = rf69_read_reg(spi, reg);\n\ttmp = tmp | mask;\n\treturn rf69_write_reg(spi, reg, tmp);\n}\n\nstatic int rf69_clear_bit(struct spi_device *spi, u8 reg, u8 mask)\n{\n\tu8 tmp;\n\n\ttmp = rf69_read_reg(spi, reg);\n\ttmp = tmp & ~mask;\n\treturn rf69_write_reg(spi, reg, tmp);\n}\n\nstatic inline int rf69_read_mod_write(struct spi_device *spi, u8 reg,\n\t\t\t\t      u8 mask, u8 value)\n{\n\tu8 tmp;\n\n\ttmp = rf69_read_reg(spi, reg);\n\ttmp = (tmp & ~mask) | value;\n\treturn rf69_write_reg(spi, reg, tmp);\n}\n\n \n\nint rf69_get_version(struct spi_device *spi)\n{\n\treturn rf69_read_reg(spi, REG_VERSION);\n}\n\nint rf69_set_mode(struct spi_device *spi, enum mode mode)\n{\n\tstatic const u8 mode_map[] = {\n\t\t[transmit] = OPMODE_MODE_TRANSMIT,\n\t\t[receive] = OPMODE_MODE_RECEIVE,\n\t\t[synthesizer] = OPMODE_MODE_SYNTHESIZER,\n\t\t[standby] = OPMODE_MODE_STANDBY,\n\t\t[mode_sleep] = OPMODE_MODE_SLEEP,\n\t};\n\n\tif (unlikely(mode >= ARRAY_SIZE(mode_map))) {\n\t\tdev_dbg(&spi->dev, \"set: illegal mode %u\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE,\n\t\t\t\t   mode_map[mode]);\n\n\t \n}\n\nint rf69_set_data_mode(struct spi_device *spi, u8 data_mode)\n{\n\treturn rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODE,\n\t\t\t\t   data_mode);\n}\n\nint rf69_set_modulation(struct spi_device *spi, enum modulation modulation)\n{\n\tstatic const u8 modulation_map[] = {\n\t\t[OOK] = DATAMODUL_MODULATION_TYPE_OOK,\n\t\t[FSK] = DATAMODUL_MODULATION_TYPE_FSK,\n\t};\n\n\tif (unlikely(modulation >= ARRAY_SIZE(modulation_map))) {\n\t\tdev_dbg(&spi->dev, \"set: illegal modulation %u\\n\", modulation);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rf69_read_mod_write(spi, REG_DATAMODUL,\n\t\t\t\t   MASK_DATAMODUL_MODULATION_TYPE,\n\t\t\t\t   modulation_map[modulation]);\n}\n\nstatic enum modulation rf69_get_modulation(struct spi_device *spi)\n{\n\tu8 modulation_reg;\n\n\tmodulation_reg = rf69_read_reg(spi, REG_DATAMODUL);\n\n\tswitch (modulation_reg & MASK_DATAMODUL_MODULATION_TYPE) {\n\tcase DATAMODUL_MODULATION_TYPE_OOK:\n\t\treturn OOK;\n\tcase DATAMODUL_MODULATION_TYPE_FSK:\n\t\treturn FSK;\n\tdefault:\n\t\treturn UNDEF;\n\t}\n}\n\nint rf69_set_modulation_shaping(struct spi_device *spi,\n\t\t\t\tenum mod_shaping mod_shaping)\n{\n\tswitch (rf69_get_modulation(spi)) {\n\tcase FSK:\n\t\tswitch (mod_shaping) {\n\t\tcase SHAPING_OFF:\n\t\t\treturn rf69_read_mod_write(spi, REG_DATAMODUL,\n\t\t\t\t\t\t   MASK_DATAMODUL_MODULATION_SHAPE,\n\t\t\t\t\t\t   DATAMODUL_MODULATION_SHAPE_NONE);\n\t\tcase SHAPING_1_0:\n\t\t\treturn rf69_read_mod_write(spi, REG_DATAMODUL,\n\t\t\t\t\t\t   MASK_DATAMODUL_MODULATION_SHAPE,\n\t\t\t\t\t\t   DATAMODUL_MODULATION_SHAPE_1_0);\n\t\tcase SHAPING_0_5:\n\t\t\treturn rf69_read_mod_write(spi, REG_DATAMODUL,\n\t\t\t\t\t\t   MASK_DATAMODUL_MODULATION_SHAPE,\n\t\t\t\t\t\t   DATAMODUL_MODULATION_SHAPE_0_5);\n\t\tcase SHAPING_0_3:\n\t\t\treturn rf69_read_mod_write(spi, REG_DATAMODUL,\n\t\t\t\t\t\t   MASK_DATAMODUL_MODULATION_SHAPE,\n\t\t\t\t\t\t   DATAMODUL_MODULATION_SHAPE_0_3);\n\t\tdefault:\n\t\t\tdev_dbg(&spi->dev, \"set: illegal mod shaping for FSK %u\\n\", mod_shaping);\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase OOK:\n\t\tswitch (mod_shaping) {\n\t\tcase SHAPING_OFF:\n\t\t\treturn rf69_read_mod_write(spi, REG_DATAMODUL,\n\t\t\t\t\t\t   MASK_DATAMODUL_MODULATION_SHAPE,\n\t\t\t\t\t\t   DATAMODUL_MODULATION_SHAPE_NONE);\n\t\tcase SHAPING_BR:\n\t\t\treturn rf69_read_mod_write(spi, REG_DATAMODUL,\n\t\t\t\t\t\t   MASK_DATAMODUL_MODULATION_SHAPE,\n\t\t\t\t\t\t   DATAMODUL_MODULATION_SHAPE_BR);\n\t\tcase SHAPING_2BR:\n\t\t\treturn rf69_read_mod_write(spi, REG_DATAMODUL,\n\t\t\t\t\t\t   MASK_DATAMODUL_MODULATION_SHAPE,\n\t\t\t\t\t\t   DATAMODUL_MODULATION_SHAPE_2BR);\n\t\tdefault:\n\t\t\tdev_dbg(&spi->dev, \"set: illegal mod shaping for OOK %u\\n\", mod_shaping);\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\tdev_dbg(&spi->dev, \"set: modulation undefined\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nint rf69_set_bit_rate(struct spi_device *spi, u16 bit_rate)\n{\n\tint retval;\n\tu32 bit_rate_reg;\n\tu8 msb;\n\tu8 lsb;\n\tenum modulation mod;\n\n\t\n\tmod = rf69_get_modulation(spi);\n\tif (mod == UNDEF) {\n\t\tdev_dbg(&spi->dev, \"setBitRate: modulation is undefined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tif (bit_rate < 1200 || (mod == OOK && bit_rate > 32768)) {\n\t\tdev_dbg(&spi->dev, \"setBitRate: illegal input param\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tbit_rate_reg = (F_OSC / bit_rate);\n\n\tmsb = (bit_rate_reg & 0xff00) >> 8;\n\tlsb = (bit_rate_reg & 0xff);\n\n\t\n\tretval = rf69_write_reg(spi, REG_BITRATE_MSB, msb);\n\tif (retval)\n\t\treturn retval;\n\tretval = rf69_write_reg(spi, REG_BITRATE_LSB, lsb);\n\tif (retval)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nint rf69_set_deviation(struct spi_device *spi, u32 deviation)\n{\n\tint retval;\n\tu64 f_reg;\n\tu64 f_step;\n\tu32 bit_rate_reg;\n\tu32 bit_rate;\n\tu8 msb;\n\tu8 lsb;\n\tu64 factor = 1000000; \n\n\t\n\tbit_rate_reg = rf69_read_reg(spi, REG_BITRATE_MSB) << 8;\n\tbit_rate_reg |= rf69_read_reg(spi, REG_BITRATE_LSB);\n\tbit_rate = F_OSC / bit_rate_reg;\n\n\t \n\tif (deviation < 600 || (deviation + (bit_rate / 2)) > 500000) {\n\t\tdev_dbg(&spi->dev,\n\t\t\t\"set_deviation: illegal input param: %u\\n\", deviation);\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tf_step = F_OSC * factor;\n\tdo_div(f_step, 524288); \n\n\t\n\tf_reg = deviation * factor;\n\tdo_div(f_reg, f_step);\n\n\tmsb = (f_reg & 0xff00) >> 8;\n\tlsb = (f_reg & 0xff);\n\n\t\n\tif (msb & ~FDEVMASB_MASK) {\n\t\tdev_dbg(&spi->dev, \"set_deviation: err in calc of msb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tretval = rf69_write_reg(spi, REG_FDEV_MSB, msb);\n\tif (retval)\n\t\treturn retval;\n\tretval = rf69_write_reg(spi, REG_FDEV_LSB, lsb);\n\tif (retval)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nint rf69_set_frequency(struct spi_device *spi, u32 frequency)\n{\n\tint retval;\n\tu32 f_max;\n\tu64 f_reg;\n\tu64 f_step;\n\tu8 msb;\n\tu8 mid;\n\tu8 lsb;\n\tu64 factor = 1000000; \n\n\t\n\tf_step = F_OSC * factor;\n\tdo_div(f_step, 524288); \n\n\t\n\tf_max = div_u64(f_step * 8388608, factor);\n\tif (frequency > f_max) {\n\t\tdev_dbg(&spi->dev, \"setFrequency: illegal input param\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tf_reg = frequency * factor;\n\tdo_div(f_reg, f_step);\n\n\tmsb = (f_reg & 0xff0000) >> 16;\n\tmid = (f_reg & 0xff00)   >>  8;\n\tlsb = (f_reg & 0xff);\n\n\t\n\tretval = rf69_write_reg(spi, REG_FRF_MSB, msb);\n\tif (retval)\n\t\treturn retval;\n\tretval = rf69_write_reg(spi, REG_FRF_MID, mid);\n\tif (retval)\n\t\treturn retval;\n\tretval = rf69_write_reg(spi, REG_FRF_LSB, lsb);\n\tif (retval)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nint rf69_enable_amplifier(struct spi_device *spi, u8 amplifier_mask)\n{\n\treturn rf69_set_bit(spi, REG_PALEVEL, amplifier_mask);\n}\n\nint rf69_disable_amplifier(struct spi_device *spi, u8 amplifier_mask)\n{\n\treturn rf69_clear_bit(spi, REG_PALEVEL, amplifier_mask);\n}\n\nint rf69_set_output_power_level(struct spi_device *spi, u8 power_level)\n{\n\tu8 pa_level, ocp, test_pa1, test_pa2;\n\tbool pa0, pa1, pa2, high_power;\n\tu8 min_power_level;\n\n\t\n\tpa_level = rf69_read_reg(spi, REG_PALEVEL);\n\tpa0 = pa_level & MASK_PALEVEL_PA0;\n\tpa1 = pa_level & MASK_PALEVEL_PA1;\n\tpa2 = pa_level & MASK_PALEVEL_PA2;\n\n\t\n\tocp = rf69_read_reg(spi, REG_OCP);\n\ttest_pa1 = rf69_read_reg(spi, REG_TESTPA1);\n\ttest_pa2 = rf69_read_reg(spi, REG_TESTPA2);\n\thigh_power = (ocp == 0x0f) && (test_pa1 == 0x5d) && (test_pa2 == 0x7c);\n\n\tif (pa0 && !pa1 && !pa2) {\n\t\tpower_level += 18;\n\t\tmin_power_level = 0;\n\t} else if (!pa0 && pa1 && !pa2) {\n\t\tpower_level += 18;\n\t\tmin_power_level = 16;\n\t} else if (!pa0 && pa1 && pa2) {\n\t\tif (high_power)\n\t\t\tpower_level += 11;\n\t\telse\n\t\t\tpower_level += 14;\n\t\tmin_power_level = 16;\n\t} else {\n\t\tgoto failed;\n\t}\n\n\t\n\tif (power_level > 0x1f)\n\t\tgoto failed;\n\n\tif (power_level < min_power_level)\n\t\tgoto failed;\n\n\t\n\treturn rf69_read_mod_write(spi, REG_PALEVEL, MASK_PALEVEL_OUTPUT_POWER,\n\t\t\t\t   power_level);\nfailed:\n\tdev_dbg(&spi->dev, \"set: illegal power level %u\\n\", power_level);\n\treturn -EINVAL;\n}\n\nint rf69_set_pa_ramp(struct spi_device *spi, enum pa_ramp pa_ramp)\n{\n\tstatic const u8 pa_ramp_map[] = {\n\t\t[ramp3400] = PARAMP_3400,\n\t\t[ramp2000] = PARAMP_2000,\n\t\t[ramp1000] = PARAMP_1000,\n\t\t[ramp500] = PARAMP_500,\n\t\t[ramp250] = PARAMP_250,\n\t\t[ramp125] = PARAMP_125,\n\t\t[ramp100] = PARAMP_100,\n\t\t[ramp62] = PARAMP_62,\n\t\t[ramp50] = PARAMP_50,\n\t\t[ramp40] = PARAMP_40,\n\t\t[ramp31] = PARAMP_31,\n\t\t[ramp25] = PARAMP_25,\n\t\t[ramp20] = PARAMP_20,\n\t\t[ramp15] = PARAMP_15,\n\t\t[ramp10] = PARAMP_10,\n\t};\n\n\tif (unlikely(pa_ramp >= ARRAY_SIZE(pa_ramp_map))) {\n\t\tdev_dbg(&spi->dev, \"set: illegal pa_ramp %u\\n\", pa_ramp);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rf69_write_reg(spi, REG_PARAMP, pa_ramp_map[pa_ramp]);\n}\n\nint rf69_set_antenna_impedance(struct spi_device *spi,\n\t\t\t       enum antenna_impedance antenna_impedance)\n{\n\tswitch (antenna_impedance) {\n\tcase fifty_ohm:\n\t\treturn rf69_clear_bit(spi, REG_LNA, MASK_LNA_ZIN);\n\tcase two_hundred_ohm:\n\t\treturn rf69_set_bit(spi, REG_LNA, MASK_LNA_ZIN);\n\tdefault:\n\t\tdev_dbg(&spi->dev, \"set: illegal antenna impedance %u\\n\", antenna_impedance);\n\t\treturn -EINVAL;\n\t}\n}\n\nint rf69_set_lna_gain(struct spi_device *spi, enum lna_gain lna_gain)\n{\n\tstatic const u8 lna_gain_map[] = {\n\t\t[automatic] = LNA_GAIN_AUTO,\n\t\t[max] = LNA_GAIN_MAX,\n\t\t[max_minus_6] = LNA_GAIN_MAX_MINUS_6,\n\t\t[max_minus_12] = LNA_GAIN_MAX_MINUS_12,\n\t\t[max_minus_24] = LNA_GAIN_MAX_MINUS_24,\n\t\t[max_minus_36] = LNA_GAIN_MAX_MINUS_36,\n\t\t[max_minus_48] = LNA_GAIN_MAX_MINUS_48,\n\t};\n\n\tif (unlikely(lna_gain >= ARRAY_SIZE(lna_gain_map))) {\n\t\tdev_dbg(&spi->dev, \"set: illegal lna gain %u\\n\", lna_gain);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,\n\t\t\t\t   lna_gain_map[lna_gain]);\n}\n\nstatic int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,\n\t\t\t\t     enum mantisse mantisse, u8 exponent)\n{\n\tu8 bandwidth;\n\n\t\n\tif (exponent > 7) {\n\t\tdev_dbg(&spi->dev, \"set: illegal bandwidth exponent %u\\n\", exponent);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mantisse != mantisse16 &&\n\t    mantisse != mantisse20 &&\n\t    mantisse != mantisse24) {\n\t\tdev_dbg(&spi->dev, \"set: illegal bandwidth mantisse %u\\n\", mantisse);\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tbandwidth = rf69_read_reg(spi, reg);\n\n\t\n\tbandwidth = bandwidth & MASK_BW_DCC_FREQ;\n\n\t\n\tswitch (mantisse) {\n\tcase mantisse16:\n\t\tbandwidth = bandwidth | BW_MANT_16;\n\t\tbreak;\n\tcase mantisse20:\n\t\tbandwidth = bandwidth | BW_MANT_20;\n\t\tbreak;\n\tcase mantisse24:\n\t\tbandwidth = bandwidth | BW_MANT_24;\n\t\tbreak;\n\t}\n\n\t\n\tbandwidth = bandwidth | exponent;\n\n\t\n\treturn rf69_write_reg(spi, reg, bandwidth);\n}\n\nint rf69_set_bandwidth(struct spi_device *spi, enum mantisse mantisse,\n\t\t       u8 exponent)\n{\n\treturn rf69_set_bandwidth_intern(spi, REG_RXBW, mantisse, exponent);\n}\n\nint rf69_set_bandwidth_during_afc(struct spi_device *spi,\n\t\t\t\t  enum mantisse mantisse,\n\t\t\t\t  u8 exponent)\n{\n\treturn rf69_set_bandwidth_intern(spi, REG_AFCBW, mantisse, exponent);\n}\n\nint rf69_set_ook_threshold_dec(struct spi_device *spi,\n\t\t\t       enum threshold_decrement threshold_decrement)\n{\n\tstatic const u8 td_map[] = {\n\t\t[dec_every8th] = OOKPEAK_THRESHDEC_EVERY_8TH,\n\t\t[dec_every4th] = OOKPEAK_THRESHDEC_EVERY_4TH,\n\t\t[dec_every2nd] = OOKPEAK_THRESHDEC_EVERY_2ND,\n\t\t[dec_once] = OOKPEAK_THRESHDEC_ONCE,\n\t\t[dec_twice] = OOKPEAK_THRESHDEC_TWICE,\n\t\t[dec_4times] = OOKPEAK_THRESHDEC_4_TIMES,\n\t\t[dec_8times] = OOKPEAK_THRESHDEC_8_TIMES,\n\t\t[dec_16times] = OOKPEAK_THRESHDEC_16_TIMES,\n\t};\n\n\tif (unlikely(threshold_decrement >= ARRAY_SIZE(td_map))) {\n\t\tdev_dbg(&spi->dev, \"set: illegal OOK threshold decrement %u\\n\",\n\t\t\tthreshold_decrement);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC,\n\t\t\t\t   td_map[threshold_decrement]);\n}\n\nint rf69_set_dio_mapping(struct spi_device *spi, u8 dio_number, u8 value)\n{\n\tu8 mask;\n\tu8 shift;\n\tu8 dio_addr;\n\tu8 dio_value;\n\n\tswitch (dio_number) {\n\tcase 0:\n\t\tmask = MASK_DIO0;\n\t\tshift = SHIFT_DIO0;\n\t\tdio_addr = REG_DIOMAPPING1;\n\t\tbreak;\n\tcase 1:\n\t\tmask = MASK_DIO1;\n\t\tshift = SHIFT_DIO1;\n\t\tdio_addr = REG_DIOMAPPING1;\n\t\tbreak;\n\tcase 2:\n\t\tmask = MASK_DIO2;\n\t\tshift = SHIFT_DIO2;\n\t\tdio_addr = REG_DIOMAPPING1;\n\t\tbreak;\n\tcase 3:\n\t\tmask = MASK_DIO3;\n\t\tshift = SHIFT_DIO3;\n\t\tdio_addr = REG_DIOMAPPING1;\n\t\tbreak;\n\tcase 4:\n\t\tmask = MASK_DIO4;\n\t\tshift = SHIFT_DIO4;\n\t\tdio_addr = REG_DIOMAPPING2;\n\t\tbreak;\n\tcase 5:\n\t\tmask = MASK_DIO5;\n\t\tshift = SHIFT_DIO5;\n\t\tdio_addr = REG_DIOMAPPING2;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&spi->dev, \"set: illegal dio number %u\\n\", dio_number);\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tdio_value = rf69_read_reg(spi, dio_addr);\n\t\n\tdio_value = dio_value & ~mask;\n\t\n\tdio_value = dio_value | value << shift;\n\t\n\treturn rf69_write_reg(spi, dio_addr, dio_value);\n}\n\nint rf69_set_rssi_threshold(struct spi_device *spi, u8 threshold)\n{\n\t \n\n\treturn rf69_write_reg(spi, REG_RSSITHRESH, threshold);\n}\n\nint rf69_set_preamble_length(struct spi_device *spi, u16 preamble_length)\n{\n\tint retval;\n\tu8 msb, lsb;\n\n\t \n\n\t \n\tmsb = (preamble_length & 0xff00) >> 8;\n\tlsb = (preamble_length & 0xff);\n\n\t \n\tretval = rf69_write_reg(spi, REG_PREAMBLE_MSB, msb);\n\tif (retval)\n\t\treturn retval;\n\treturn rf69_write_reg(spi, REG_PREAMBLE_LSB, lsb);\n}\n\nint rf69_enable_sync(struct spi_device *spi)\n{\n\treturn rf69_set_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_ON);\n}\n\nint rf69_disable_sync(struct spi_device *spi)\n{\n\treturn rf69_clear_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_ON);\n}\n\nint rf69_set_fifo_fill_condition(struct spi_device *spi,\n\t\t\t\t enum fifo_fill_condition fifo_fill_condition)\n{\n\tswitch (fifo_fill_condition) {\n\tcase always:\n\t\treturn rf69_set_bit(spi, REG_SYNC_CONFIG,\n\t\t\t\t    MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);\n\tcase after_sync_interrupt:\n\t\treturn rf69_clear_bit(spi, REG_SYNC_CONFIG,\n\t\t\t\t      MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);\n\tdefault:\n\t\tdev_dbg(&spi->dev, \"set: illegal fifo fill condition %u\\n\", fifo_fill_condition);\n\t\treturn -EINVAL;\n\t}\n}\n\nint rf69_set_sync_size(struct spi_device *spi, u8 sync_size)\n{\n\t\n\tif (sync_size > 0x07) {\n\t\tdev_dbg(&spi->dev, \"set: illegal sync size %u\\n\", sync_size);\n\t\treturn -EINVAL;\n\t}\n\n\t\n\treturn rf69_read_mod_write(spi, REG_SYNC_CONFIG,\n\t\t\t\t   MASK_SYNC_CONFIG_SYNC_SIZE,\n\t\t\t\t   (sync_size << 3));\n}\n\nint rf69_set_sync_values(struct spi_device *spi, u8 sync_values[8])\n{\n\tint retval = 0;\n\n\tretval += rf69_write_reg(spi, REG_SYNCVALUE1, sync_values[0]);\n\tretval += rf69_write_reg(spi, REG_SYNCVALUE2, sync_values[1]);\n\tretval += rf69_write_reg(spi, REG_SYNCVALUE3, sync_values[2]);\n\tretval += rf69_write_reg(spi, REG_SYNCVALUE4, sync_values[3]);\n\tretval += rf69_write_reg(spi, REG_SYNCVALUE5, sync_values[4]);\n\tretval += rf69_write_reg(spi, REG_SYNCVALUE6, sync_values[5]);\n\tretval += rf69_write_reg(spi, REG_SYNCVALUE7, sync_values[6]);\n\tretval += rf69_write_reg(spi, REG_SYNCVALUE8, sync_values[7]);\n\n\treturn retval;\n}\n\nint rf69_set_packet_format(struct spi_device *spi,\n\t\t\t   enum packet_format packet_format)\n{\n\tswitch (packet_format) {\n\tcase packet_length_var:\n\t\treturn rf69_set_bit(spi, REG_PACKETCONFIG1,\n\t\t\t\t    MASK_PACKETCONFIG1_PACKET_FORMAT_VARIABLE);\n\tcase packet_length_fix:\n\t\treturn rf69_clear_bit(spi, REG_PACKETCONFIG1,\n\t\t\t\t      MASK_PACKETCONFIG1_PACKET_FORMAT_VARIABLE);\n\tdefault:\n\t\tdev_dbg(&spi->dev, \"set: illegal packet format %u\\n\", packet_format);\n\t\treturn -EINVAL;\n\t}\n}\n\nint rf69_enable_crc(struct spi_device *spi)\n{\n\treturn rf69_set_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_CRC_ON);\n}\n\nint rf69_disable_crc(struct spi_device *spi)\n{\n\treturn rf69_clear_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_CRC_ON);\n}\n\nint rf69_set_address_filtering(struct spi_device *spi,\n\t\t\t       enum address_filtering address_filtering)\n{\n\tstatic const u8 af_map[] = {\n\t\t[filtering_off] = PACKETCONFIG1_ADDRESSFILTERING_OFF,\n\t\t[node_address] = PACKETCONFIG1_ADDRESSFILTERING_NODE,\n\t\t[node_or_broadcast_address] =\n\t\t\tPACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST,\n\t};\n\n\tif (unlikely(address_filtering >= ARRAY_SIZE(af_map))) {\n\t\tdev_dbg(&spi->dev, \"set: illegal address filtering %u\\n\", address_filtering);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rf69_read_mod_write(spi, REG_PACKETCONFIG1,\n\t\t\t\t   MASK_PACKETCONFIG1_ADDRESSFILTERING,\n\t\t\t\t   af_map[address_filtering]);\n}\n\nint rf69_set_payload_length(struct spi_device *spi, u8 payload_length)\n{\n\treturn rf69_write_reg(spi, REG_PAYLOAD_LENGTH, payload_length);\n}\n\nint rf69_set_node_address(struct spi_device *spi, u8 node_address)\n{\n\treturn rf69_write_reg(spi, REG_NODEADRS, node_address);\n}\n\nint rf69_set_broadcast_address(struct spi_device *spi, u8 broadcast_address)\n{\n\treturn rf69_write_reg(spi, REG_BROADCASTADRS, broadcast_address);\n}\n\nint rf69_set_tx_start_condition(struct spi_device *spi,\n\t\t\t\tenum tx_start_condition tx_start_condition)\n{\n\tswitch (tx_start_condition) {\n\tcase fifo_level:\n\t\treturn rf69_clear_bit(spi, REG_FIFO_THRESH,\n\t\t\t\t      MASK_FIFO_THRESH_TXSTART);\n\tcase fifo_not_empty:\n\t\treturn rf69_set_bit(spi, REG_FIFO_THRESH,\n\t\t\t\t    MASK_FIFO_THRESH_TXSTART);\n\tdefault:\n\t\tdev_dbg(&spi->dev, \"set: illegal tx start condition %u\\n\", tx_start_condition);\n\t\treturn -EINVAL;\n\t}\n}\n\nint rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)\n{\n\tint retval;\n\n\t \n\tif (threshold & ~MASK_FIFO_THRESH_VALUE) {\n\t\tdev_dbg(&spi->dev, \"set: illegal fifo threshold %u\\n\", threshold);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tretval = rf69_read_mod_write(spi, REG_FIFO_THRESH,\n\t\t\t\t     MASK_FIFO_THRESH_VALUE,\n\t\t\t\t     threshold);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\treturn rf69_read_fifo(spi, (u8 *)&retval, 1);\n}\n\nint rf69_set_dagc(struct spi_device *spi, enum dagc dagc)\n{\n\tstatic const u8 dagc_map[] = {\n\t\t[normal_mode] = DAGC_NORMAL,\n\t\t[improve] = DAGC_IMPROVED_LOWBETA0,\n\t\t[improve_for_low_modulation_index] = DAGC_IMPROVED_LOWBETA1,\n\t};\n\n\tif (unlikely(dagc >= ARRAY_SIZE(dagc_map))) {\n\t\tdev_dbg(&spi->dev, \"set: illegal dagc %u\\n\", dagc);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rf69_write_reg(spi, REG_TESTDAGC, dagc_map[dagc]);\n}\n\n \n\nint rf69_read_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)\n{\n\tint i;\n\tstruct spi_transfer transfer;\n\tu8 local_buffer[FIFO_SIZE + 1] = {};\n\tint retval;\n\n\tif (size > FIFO_SIZE) {\n\t\tdev_dbg(&spi->dev,\n\t\t\t\"read fifo: passed in buffer bigger then internal buffer\\n\");\n\t\treturn -EMSGSIZE;\n\t}\n\n\t \n\tlocal_buffer[0] = REG_FIFO;\n\tmemset(&transfer, 0, sizeof(transfer));\n\ttransfer.tx_buf = local_buffer;\n\ttransfer.rx_buf = local_buffer;\n\ttransfer.len\t= size + 1;\n\n\tretval = spi_sync_transfer(spi, &transfer, 1);\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tdev_dbg(&spi->dev, \"%d - 0x%x\\n\", i, local_buffer[i + 1]);\n\n\tmemcpy(buffer, &local_buffer[1], size);\n\n\treturn retval;\n}\n\nint rf69_write_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)\n{\n\tint i;\n\tu8 local_buffer[FIFO_SIZE + 1];\n\n\tif (size > FIFO_SIZE) {\n\t\tdev_dbg(&spi->dev,\n\t\t\t\"write fifo: passed in buffer bigger then internal buffer\\n\");\n\t\treturn -EMSGSIZE;\n\t}\n\n\tlocal_buffer[0] = REG_FIFO | WRITE_BIT;\n\tmemcpy(&local_buffer[1], buffer, size);\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tdev_dbg(&spi->dev, \"%d - 0x%x\\n\", i, buffer[i]);\n\n\treturn spi_write(spi, local_buffer, size + 1);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}