{
  "module_name": "netlink_k.c",
  "hash_id": "289db909b5efd867f8eeb1f2c00f08433704f085bc4c60fca9ed339de227a9e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/gdm724x/netlink_k.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/etherdevice.h>\n#include <linux/netlink.h>\n#include <asm/byteorder.h>\n#include <net/sock.h>\n\n#include \"netlink_k.h\"\n\nstatic DEFINE_MUTEX(netlink_mutex);\n\n#define ND_MAX_GROUP\t\t30\n#define ND_IFINDEX_LEN\t\tsizeof(int)\n#define ND_NLMSG_SPACE(len)\t(NLMSG_SPACE(len) + ND_IFINDEX_LEN)\n#define ND_NLMSG_DATA(nlh)\t((void *)((char *)NLMSG_DATA(nlh) + \\\n\t\t\t\t\t\t  ND_IFINDEX_LEN))\n#define ND_NLMSG_S_LEN(len)\t((len) + ND_IFINDEX_LEN)\n#define ND_NLMSG_R_LEN(nlh)\t((nlh)->nlmsg_len - ND_IFINDEX_LEN)\n#define ND_NLMSG_IFIDX(nlh)\tNLMSG_DATA(nlh)\n#define ND_MAX_MSG_LEN\t\t(1024 * 32)\n\nstatic void (*rcv_cb)(struct net_device *dev, u16 type, void *msg, int len);\n\nstatic void netlink_rcv_cb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr\t*nlh;\n\tstruct net_device *dev;\n\tu32 mlen;\n\tvoid *msg;\n\tint ifindex;\n\n\tif (!rcv_cb) {\n\t\tpr_err(\"nl cb - unregistered\\n\");\n\t\treturn;\n\t}\n\n\tif (skb->len < NLMSG_HDRLEN) {\n\t\tpr_err(\"nl cb - invalid skb length\\n\");\n\t\treturn;\n\t}\n\n\tnlh = (struct nlmsghdr *)skb->data;\n\n\tif (skb->len < nlh->nlmsg_len || nlh->nlmsg_len > ND_MAX_MSG_LEN) {\n\t\tpr_err(\"nl cb - invalid length (%d,%d)\\n\",\n\t\t       skb->len, nlh->nlmsg_len);\n\t\treturn;\n\t}\n\n\tmemcpy(&ifindex, ND_NLMSG_IFIDX(nlh), ND_IFINDEX_LEN);\n\tmsg = ND_NLMSG_DATA(nlh);\n\tmlen = ND_NLMSG_R_LEN(nlh);\n\n\tdev = dev_get_by_index(&init_net, ifindex);\n\tif (dev) {\n\t\trcv_cb(dev, nlh->nlmsg_type, msg, mlen);\n\t\tdev_put(dev);\n\t} else {\n\t\tpr_err(\"nl cb - dev (%d) not found\\n\", ifindex);\n\t}\n}\n\nstatic void netlink_rcv(struct sk_buff *skb)\n{\n\tmutex_lock(&netlink_mutex);\n\tnetlink_rcv_cb(skb);\n\tmutex_unlock(&netlink_mutex);\n}\n\nstruct sock *netlink_init(int unit,\n\t\t\t  void (*cb)(struct net_device *dev, u16 type,\n\t\t\t\t     void *msg, int len))\n{\n\tstruct sock *sock;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input  = netlink_rcv,\n\t};\n\n\tsock = netlink_kernel_create(&init_net, unit, &cfg);\n\n\tif (sock)\n\t\trcv_cb = cb;\n\n\treturn sock;\n}\n\nint netlink_send(struct sock *sock, int group, u16 type, void *msg, int len,\n\t\t struct net_device *dev)\n{\n\tstatic u32 seq;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tint ret = 0;\n\n\tif (group > ND_MAX_GROUP)\n\t\treturn -EINVAL;\n\n\tif (!netlink_has_listeners(sock, group + 1))\n\t\treturn -ESRCH;\n\n\tskb = alloc_skb(NLMSG_SPACE(len), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tseq++;\n\n\tnlh = nlmsg_put(skb, 0, seq, type, len, 0);\n\tmemcpy(NLMSG_DATA(nlh), msg, len);\n\tNETLINK_CB(skb).portid = 0;\n\tNETLINK_CB(skb).dst_group = 0;\n\n\tret = netlink_broadcast(sock, skb, 0, group + 1, GFP_ATOMIC);\n\tif (!ret)\n\t\treturn len;\n\n\tif (ret != -ESRCH)\n\t\tnetdev_err(dev, \"nl broadcast g=%d, t=%d, l=%d, r=%d\\n\",\n\t\t\t   group, type, len, ret);\n\telse if (netlink_has_listeners(sock, group + 1))\n\t\treturn -EAGAIN;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}