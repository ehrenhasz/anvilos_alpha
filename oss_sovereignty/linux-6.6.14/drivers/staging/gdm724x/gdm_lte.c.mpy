{
  "module_name": "gdm_lte.c",
  "hash_id": "35f9ae1c3670fb3bf0c427863dd0bad3392d2d41227024086335a6621d8e30d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/gdm724x/gdm_lte.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/etherdevice.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/udp.h>\n#include <linux/in.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/in6.h>\n#include <linux/tcp.h>\n#include <linux/icmp.h>\n#include <linux/icmpv6.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <net/ndisc.h>\n\n#include \"gdm_lte.h\"\n#include \"netlink_k.h\"\n#include \"hci.h\"\n#include \"hci_packet.h\"\n#include \"gdm_endian.h\"\n\n \n#define NETLINK_LTE 30\n\n \n#define DEFAULT_MTU_SIZE 1500\n\n#define IP_VERSION_4\t4\n#define IP_VERSION_6\t6\n\nstatic struct {\n\tint ref_cnt;\n\tstruct sock *sock;\n} lte_event;\n\nstatic struct device_type wwan_type = {\n\t.name   = \"wwan\",\n};\n\nstatic int gdm_lte_open(struct net_device *dev)\n{\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\nstatic int gdm_lte_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\nstatic int gdm_lte_set_config(struct net_device *dev, struct ifmap *map)\n{\n\tif (dev->flags & IFF_UP)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic void tx_complete(void *arg)\n{\n\tstruct nic *nic = arg;\n\n\tif (netif_queue_stopped(nic->netdev))\n\t\tnetif_wake_queue(nic->netdev);\n}\n\nstatic int gdm_lte_rx(struct sk_buff *skb, struct nic *nic, int nic_type)\n{\n\tint ret, len;\n\n\tlen = skb->len + ETH_HLEN;\n\tret = netif_rx(skb);\n\tif (ret == NET_RX_DROP) {\n\t\tnic->stats.rx_dropped++;\n\t} else {\n\t\tnic->stats.rx_packets++;\n\t\tnic->stats.rx_bytes += len;\n\t}\n\n\treturn 0;\n}\n\nstatic int gdm_lte_emulate_arp(struct sk_buff *skb_in, u32 nic_type)\n{\n\tstruct nic *nic = netdev_priv(skb_in->dev);\n\tstruct sk_buff *skb_out;\n\tstruct ethhdr eth;\n\tstruct vlan_ethhdr vlan_eth;\n\tstruct arphdr *arp_in;\n\tstruct arphdr *arp_out;\n\tstruct arpdata {\n\t\tu8 ar_sha[ETH_ALEN];\n\t\tu8 ar_sip[4];\n\t\tu8 ar_tha[ETH_ALEN];\n\t\tu8 ar_tip[4];\n\t};\n\tstruct arpdata *arp_data_in;\n\tstruct arpdata *arp_data_out;\n\tu8 arp_temp[60];\n\tvoid *mac_header_data;\n\tu32 mac_header_len;\n\n\t \n\tif (skb_in->len == 0)\n\t\treturn -ENODATA;\n\n\t \n\tif (ntohs(((struct ethhdr *)skb_in->data)->h_proto) == ETH_P_8021Q) {\n\t\tmemcpy(&vlan_eth, skb_in->data, sizeof(struct vlan_ethhdr));\n\t\tmac_header_data = &vlan_eth;\n\t\tmac_header_len = VLAN_ETH_HLEN;\n\t} else {\n\t\tmemcpy(&eth, skb_in->data, sizeof(struct ethhdr));\n\t\tmac_header_data = &eth;\n\t\tmac_header_len = ETH_HLEN;\n\t}\n\n\t \n\tarp_in = (struct arphdr *)(skb_in->data + mac_header_len);\n\tarp_data_in = (struct arpdata *)(skb_in->data + mac_header_len +\n\t\t\t\t\tsizeof(struct arphdr));\n\n\t \n\tarp_out = (struct arphdr *)arp_temp;\n\tarp_data_out = (struct arpdata *)(arp_temp + sizeof(struct arphdr));\n\n\t \n\tmemcpy(arp_out, arp_in, sizeof(struct arphdr));\n\tarp_out->ar_op = htons(ARPOP_REPLY);\n\n\t \n\tarp_data_out->ar_sha[0] = arp_data_in->ar_sha[0];\n\tarp_data_out->ar_sha[1] = arp_data_in->ar_sha[1];\n\tmemcpy(&arp_data_out->ar_sha[2], &arp_data_in->ar_tip[0], 4);\n\tmemcpy(&arp_data_out->ar_sip[0], &arp_data_in->ar_tip[0], 4);\n\tmemcpy(&arp_data_out->ar_tha[0], &arp_data_in->ar_sha[0], 6);\n\tmemcpy(&arp_data_out->ar_tip[0], &arp_data_in->ar_sip[0], 4);\n\n\t \n\tmemcpy(mac_header_data, mac_header_data + ETH_ALEN, ETH_ALEN);\n\t \n\tmemcpy(mac_header_data + ETH_ALEN, nic->src_mac_addr, ETH_ALEN);\n\n\t \n\tskb_out = dev_alloc_skb(skb_in->len);\n\tif (!skb_out)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb_out, NET_IP_ALIGN);\n\n\tskb_put_data(skb_out, mac_header_data, mac_header_len);\n\tskb_put_data(skb_out, arp_out, sizeof(struct arphdr));\n\tskb_put_data(skb_out, arp_data_out, sizeof(struct arpdata));\n\n\tskb_out->protocol = ((struct ethhdr *)mac_header_data)->h_proto;\n\tskb_out->dev = skb_in->dev;\n\tskb_reset_mac_header(skb_out);\n\tskb_pull(skb_out, ETH_HLEN);\n\n\tgdm_lte_rx(skb_out, nic, nic_type);\n\n\treturn 0;\n}\n\nstatic __sum16 icmp6_checksum(struct ipv6hdr *ipv6, u16 *ptr, int len)\n{\n\tunsigned short *w;\n\t__wsum sum = 0;\n\tint i;\n\tu16 pa;\n\n\tunion {\n\t\tstruct {\n\t\t\tu8 ph_src[16];\n\t\t\tu8 ph_dst[16];\n\t\t\tu32 ph_len;\n\t\t\tu8 ph_zero[3];\n\t\t\tu8 ph_nxt;\n\t\t} ph __packed;\n\t\tu16 pa[20];\n\t} pseudo_header;\n\n\tmemset(&pseudo_header, 0, sizeof(pseudo_header));\n\tmemcpy(&pseudo_header.ph.ph_src, &ipv6->saddr.in6_u.u6_addr8, 16);\n\tmemcpy(&pseudo_header.ph.ph_dst, &ipv6->daddr.in6_u.u6_addr8, 16);\n\tpseudo_header.ph.ph_len = be16_to_cpu(ipv6->payload_len);\n\tpseudo_header.ph.ph_nxt = ipv6->nexthdr;\n\n\tfor (i = 0; i < ARRAY_SIZE(pseudo_header.pa); i++) {\n\t\tpa = pseudo_header.pa[i];\n\t\tsum = csum_add(sum, csum_unfold((__force __sum16)pa));\n\t}\n\n\tw = ptr;\n\twhile (len > 1) {\n\t\tsum = csum_add(sum, csum_unfold((__force __sum16)*w++));\n\t\tlen -= 2;\n\t}\n\n\treturn csum_fold(sum);\n}\n\nstatic int gdm_lte_emulate_ndp(struct sk_buff *skb_in, u32 nic_type)\n{\n\tstruct nic *nic = netdev_priv(skb_in->dev);\n\tstruct sk_buff *skb_out;\n\tstruct ethhdr eth;\n\tstruct vlan_ethhdr vlan_eth;\n\tstruct neighbour_advertisement {\n\t\tu8 target_address[16];\n\t\tu8 type;\n\t\tu8 length;\n\t\tu8 link_layer_address[6];\n\t};\n\tstruct neighbour_advertisement na;\n\tstruct neighbour_solicitation {\n\t\tu8 target_address[16];\n\t};\n\tstruct neighbour_solicitation *ns;\n\tstruct ipv6hdr *ipv6_in;\n\tstruct ipv6hdr ipv6_out;\n\tstruct icmp6hdr *icmp6_in;\n\tstruct icmp6hdr icmp6_out;\n\n\tvoid *mac_header_data;\n\tu32 mac_header_len;\n\n\t \n\tif (ntohs(((struct ethhdr *)skb_in->data)->h_proto) == ETH_P_8021Q) {\n\t\tmemcpy(&vlan_eth, skb_in->data, sizeof(struct vlan_ethhdr));\n\t\tif (ntohs(vlan_eth.h_vlan_encapsulated_proto) != ETH_P_IPV6)\n\t\t\treturn -EPROTONOSUPPORT;\n\t\tmac_header_data = &vlan_eth;\n\t\tmac_header_len = VLAN_ETH_HLEN;\n\t} else {\n\t\tmemcpy(&eth, skb_in->data, sizeof(struct ethhdr));\n\t\tif (ntohs(eth.h_proto) != ETH_P_IPV6)\n\t\t\treturn -EPROTONOSUPPORT;\n\t\tmac_header_data = &eth;\n\t\tmac_header_len = ETH_HLEN;\n\t}\n\n\t \n\tipv6_in = (struct ipv6hdr *)(skb_in->data + mac_header_len);\n\tif (ipv6_in->version != 6 || ipv6_in->nexthdr != IPPROTO_ICMPV6)\n\t\treturn -EPROTONOSUPPORT;\n\n\t \n\ticmp6_in = (struct icmp6hdr *)(skb_in->data + mac_header_len +\n\t\t\t\t\tsizeof(struct ipv6hdr));\n\tif (icmp6_in->icmp6_type == NDISC_ROUTER_SOLICITATION) {  \n\t\treturn -EPROTONOSUPPORT;\n\t} else if (icmp6_in->icmp6_type == NDISC_NEIGHBOUR_SOLICITATION) {\n\t\t \n\t\tu8 icmp_na[sizeof(struct icmp6hdr) +\n\t\t\tsizeof(struct neighbour_advertisement)];\n\t\tu8 zero_addr8[16] = {0,};\n\n\t\tif (memcmp(ipv6_in->saddr.in6_u.u6_addr8, zero_addr8, 16) == 0)\n\t\t\t \n\t\t\treturn 0;\n\n\t\ticmp6_out.icmp6_type = NDISC_NEIGHBOUR_ADVERTISEMENT;\n\t\ticmp6_out.icmp6_code = 0;\n\t\ticmp6_out.icmp6_cksum = 0;\n\t\t \n\t\ticmp6_out.icmp6_dataun.un_data32[0] = htonl(0x60000000);\n\n\t\tns = (struct neighbour_solicitation *)\n\t\t\t(skb_in->data + mac_header_len +\n\t\t\t sizeof(struct ipv6hdr) + sizeof(struct icmp6hdr));\n\t\tmemcpy(&na.target_address, ns->target_address, 16);\n\t\tna.type = 0x02;\n\t\tna.length = 1;\n\t\tna.link_layer_address[0] = 0x00;\n\t\tna.link_layer_address[1] = 0x0a;\n\t\tna.link_layer_address[2] = 0x3b;\n\t\tna.link_layer_address[3] = 0xaf;\n\t\tna.link_layer_address[4] = 0x63;\n\t\tna.link_layer_address[5] = 0xc7;\n\n\t\tmemcpy(&ipv6_out, ipv6_in, sizeof(struct ipv6hdr));\n\t\tmemcpy(ipv6_out.saddr.in6_u.u6_addr8, &na.target_address, 16);\n\t\tmemcpy(ipv6_out.daddr.in6_u.u6_addr8,\n\t\t       ipv6_in->saddr.in6_u.u6_addr8, 16);\n\t\tipv6_out.payload_len = htons(sizeof(struct icmp6hdr) +\n\t\t\t\tsizeof(struct neighbour_advertisement));\n\n\t\tmemcpy(icmp_na, &icmp6_out, sizeof(struct icmp6hdr));\n\t\tmemcpy(icmp_na + sizeof(struct icmp6hdr), &na,\n\t\t       sizeof(struct neighbour_advertisement));\n\n\t\ticmp6_out.icmp6_cksum = icmp6_checksum(&ipv6_out,\n\t\t\t\t\t\t       (u16 *)icmp_na,\n\t\t\t\t\t\t       sizeof(icmp_na));\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemcpy(mac_header_data, mac_header_data + ETH_ALEN, ETH_ALEN);\n\t \n\tmemcpy(mac_header_data + ETH_ALEN, nic->src_mac_addr, ETH_ALEN);\n\n\t \n\tskb_out = dev_alloc_skb(skb_in->len);\n\tif (!skb_out)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb_out, NET_IP_ALIGN);\n\n\tskb_put_data(skb_out, mac_header_data, mac_header_len);\n\tskb_put_data(skb_out, &ipv6_out, sizeof(struct ipv6hdr));\n\tskb_put_data(skb_out, &icmp6_out, sizeof(struct icmp6hdr));\n\tskb_put_data(skb_out, &na, sizeof(struct neighbour_advertisement));\n\n\tskb_out->protocol = ((struct ethhdr *)mac_header_data)->h_proto;\n\tskb_out->dev = skb_in->dev;\n\tskb_reset_mac_header(skb_out);\n\tskb_pull(skb_out, ETH_HLEN);\n\n\tgdm_lte_rx(skb_out, nic, nic_type);\n\n\treturn 0;\n}\n\nstatic s32 gdm_lte_tx_nic_type(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct nic *nic = netdev_priv(dev);\n\tstruct ethhdr *eth;\n\tstruct vlan_ethhdr *vlan_eth;\n\tstruct iphdr *ip;\n\tstruct ipv6hdr *ipv6;\n\tint mac_proto;\n\tvoid *network_data;\n\tu32 nic_type;\n\n\t \n\tnic_type = 0x00000010 | nic->nic_id;\n\n\t \n\teth = (struct ethhdr *)skb->data;\n\tif (ntohs(eth->h_proto) == ETH_P_8021Q) {\n\t\tvlan_eth = skb_vlan_eth_hdr(skb);\n\t\tmac_proto = ntohs(vlan_eth->h_vlan_encapsulated_proto);\n\t\tnetwork_data = skb->data + VLAN_ETH_HLEN;\n\t\tnic_type |= NIC_TYPE_F_VLAN;\n\t} else {\n\t\tmac_proto = ntohs(eth->h_proto);\n\t\tnetwork_data = skb->data + ETH_HLEN;\n\t}\n\n\t \n\tswitch (mac_proto) {\n\tcase ETH_P_ARP:\n\t\tnic_type |= NIC_TYPE_ARP;\n\t\tbreak;\n\tcase ETH_P_IP:\n\t\tnic_type |= NIC_TYPE_F_IPV4;\n\t\tip = network_data;\n\n\t\t \n\t\tif (ip->protocol == IPPROTO_UDP) {\n\t\t\tstruct udphdr *udp =\n\t\t\t\t\tnetwork_data + sizeof(struct iphdr);\n\t\t\tif (ntohs(udp->dest) == 67 || ntohs(udp->dest) == 68)\n\t\t\t\tnic_type |= NIC_TYPE_F_DHCP;\n\t\t}\n\t\tbreak;\n\tcase ETH_P_IPV6:\n\t\tnic_type |= NIC_TYPE_F_IPV6;\n\t\tipv6 = network_data;\n\n\t\tif (ipv6->nexthdr == IPPROTO_ICMPV6)   {\n\t\t\tstruct icmp6hdr *icmp6 =\n\t\t\t\t\tnetwork_data + sizeof(struct ipv6hdr);\n\t\t\tif (icmp6->icmp6_type == NDISC_NEIGHBOUR_SOLICITATION)\n\t\t\t\tnic_type |= NIC_TYPE_ICMPV6;\n\t\t} else if (ipv6->nexthdr == IPPROTO_UDP)   {\n\t\t\tstruct udphdr *udp =\n\t\t\t\t\tnetwork_data + sizeof(struct ipv6hdr);\n\t\t\tif (ntohs(udp->dest) == 546 || ntohs(udp->dest) == 547)\n\t\t\t\tnic_type |= NIC_TYPE_F_DHCP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn nic_type;\n}\n\nstatic netdev_tx_t gdm_lte_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct nic *nic = netdev_priv(dev);\n\tu32 nic_type;\n\tvoid *data_buf;\n\tint data_len;\n\tint idx;\n\tint ret = 0;\n\n\tnic_type = gdm_lte_tx_nic_type(dev, skb);\n\tif (nic_type == 0) {\n\t\tnetdev_err(dev, \"tx - invalid nic_type\\n\");\n\t\treturn -EMEDIUMTYPE;\n\t}\n\n\tif (nic_type & NIC_TYPE_ARP) {\n\t\tif (gdm_lte_emulate_arp(skb, nic_type) == 0) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (nic_type & NIC_TYPE_ICMPV6) {\n\t\tif (gdm_lte_emulate_ndp(skb, nic_type) == 0) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (nic_type & NIC_TYPE_F_VLAN) {\n\t\tstruct vlan_ethhdr *vlan_eth = skb_vlan_eth_hdr(skb);\n\n\t\tnic->vlan_id = ntohs(vlan_eth->h_vlan_TCI) & VLAN_VID_MASK;\n\t\tdata_buf = skb->data + (VLAN_ETH_HLEN - ETH_HLEN);\n\t\tdata_len = skb->len - (VLAN_ETH_HLEN - ETH_HLEN);\n\t} else {\n\t\tnic->vlan_id = 0;\n\t\tdata_buf = skb->data;\n\t\tdata_len = skb->len;\n\t}\n\n\t \n\tif (nic_type & NIC_TYPE_ICMPV6)\n\t\tnic_type = NIC_TYPE_ICMPV6;\n\n\t \n\tif (!(nic_type & NIC_TYPE_F_DHCP))\n\t\tnic_type &= NIC_TYPE_MASK;\n\n\tret = sscanf(dev->name, \"lte%d\", &idx);\n\tif (ret != 1) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tret = nic->phy_dev->send_sdu_func(nic->phy_dev->priv_dev,\n\t\t\t\t\t  data_buf, data_len,\n\t\t\t\t\t  nic->pdn_table.dft_eps_id, 0,\n\t\t\t\t\t  tx_complete, nic, idx,\n\t\t\t\t\t  nic_type);\n\n\tif (ret == TX_NO_BUFFER || ret == TX_NO_SPC) {\n\t\tnetif_stop_queue(dev);\n\t\tif (ret == TX_NO_BUFFER)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = -ENOSPC;\n\t} else if (ret == TX_NO_DEV) {\n\t\tret = -ENODEV;\n\t}\n\n\t \n\tif (ret) {\n\t\tnic->stats.tx_dropped++;\n\t} else {\n\t\tnic->stats.tx_packets++;\n\t\tnic->stats.tx_bytes += data_len;\n\t}\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic struct net_device_stats *gdm_lte_stats(struct net_device *dev)\n{\n\tstruct nic *nic = netdev_priv(dev);\n\n\treturn &nic->stats;\n}\n\nstatic int gdm_lte_event_send(struct net_device *dev, char *buf, int len)\n{\n\tstruct phy_dev *phy_dev = ((struct nic *)netdev_priv(dev))->phy_dev;\n\tstruct hci_packet *hci = (struct hci_packet *)buf;\n\tint length;\n\tint idx;\n\tint ret;\n\n\tret = sscanf(dev->name, \"lte%d\", &idx);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tlength = gdm_dev16_to_cpu(phy_dev->get_endian(phy_dev->priv_dev),\n\t\t\t\t  hci->len) + HCI_HEADER_SIZE;\n\treturn netlink_send(lte_event.sock, idx, 0, buf, length, dev);\n}\n\nstatic void gdm_lte_event_rcv(struct net_device *dev, u16 type,\n\t\t\t      void *msg, int len)\n{\n\tstruct nic *nic = netdev_priv(dev);\n\n\tnic->phy_dev->send_hci_func(nic->phy_dev->priv_dev, msg, len, NULL,\n\t\t\t\t    NULL);\n}\n\nint gdm_lte_event_init(void)\n{\n\tif (lte_event.ref_cnt == 0)\n\t\tlte_event.sock = netlink_init(NETLINK_LTE, gdm_lte_event_rcv);\n\n\tif (lte_event.sock) {\n\t\tlte_event.ref_cnt++;\n\t\treturn 0;\n\t}\n\n\tpr_err(\"event init failed\\n\");\n\treturn -ENODATA;\n}\n\nvoid gdm_lte_event_exit(void)\n{\n\tif (lte_event.sock && --lte_event.ref_cnt == 0) {\n\t\tsock_release(lte_event.sock->sk_socket);\n\t\tlte_event.sock = NULL;\n\t}\n}\n\nstatic int find_dev_index(u32 nic_type)\n{\n\tu8 index;\n\n\tindex = (u8)(nic_type & 0x0000000f);\n\tif (index >= MAX_NIC_TYPE)\n\t\treturn -EINVAL;\n\n\treturn index;\n}\n\nstatic void gdm_lte_netif_rx(struct net_device *dev, char *buf,\n\t\t\t     int len, int flagged_nic_type)\n{\n\tu32 nic_type;\n\tstruct nic *nic;\n\tstruct sk_buff *skb;\n\tstruct ethhdr eth;\n\tstruct vlan_ethhdr vlan_eth;\n\tvoid *mac_header_data;\n\tu32 mac_header_len;\n\tchar ip_version = 0;\n\n\tnic_type = flagged_nic_type & NIC_TYPE_MASK;\n\tnic = netdev_priv(dev);\n\n\tif (flagged_nic_type & NIC_TYPE_F_DHCP) {\n\t\t \n\t\tif (flagged_nic_type & NIC_TYPE_F_IPV4) {\n\t\t\tstruct dhcp_packet {\n\t\t\t\tu8 op;       \n\t\t\t\tu8 htype;    \n\t\t\t\tu8 hlen;     \n\t\t\t\tu8 hops;     \n\t\t\t\tu32 xid;     \n\t\t\t\tu16 secs;    \n\t\t\t\tu16 flags;   \n\t\t\t\t#define BROADCAST_FLAG 0x8000\n\t\t\t\t \n\t\t\t\tu32 ciaddr;  \n\t\t\t\tu32 yiaddr;  \n\t\t\t\t \n\t\t\t\tu32 siaddr_nip;\n\t\t\t\tu32 gateway_nip;  \n\t\t\t\tu8 chaddr[16];    \n\t\t\t\tu8 sname[64];     \n\t\t\t\tu8 file[128];     \n\t\t\t\tu32 cookie;       \n\t\t\t} __packed;\n\t\t\tint offset = sizeof(struct iphdr) +\n\t\t\t\t     sizeof(struct udphdr) +\n\t\t\t\t     offsetof(struct dhcp_packet, chaddr);\n\t\t\tif (offset + ETH_ALEN > len)\n\t\t\t\treturn;\n\t\t\tether_addr_copy(nic->dest_mac_addr, buf + offset);\n\t\t}\n\t}\n\n\tif (nic->vlan_id > 0) {\n\t\tmac_header_data = (void *)&vlan_eth;\n\t\tmac_header_len = VLAN_ETH_HLEN;\n\t} else {\n\t\tmac_header_data = (void *)&eth;\n\t\tmac_header_len = ETH_HLEN;\n\t}\n\n\t \n\tether_addr_copy(mac_header_data, nic->dest_mac_addr);\n\tmemcpy(mac_header_data + ETH_ALEN, nic->src_mac_addr, ETH_ALEN);\n\n\tvlan_eth.h_vlan_TCI = htons(nic->vlan_id);\n\tvlan_eth.h_vlan_proto = htons(ETH_P_8021Q);\n\n\tif (nic_type == NIC_TYPE_ARP) {\n\t\t \n\t\teth.h_proto = htons(ETH_P_ARP);\n\t\tvlan_eth.h_vlan_encapsulated_proto = htons(ETH_P_ARP);\n\t} else {\n\t\tip_version = buf[0] >> 4;\n\t\tif (ip_version == IP_VERSION_4) {\n\t\t\teth.h_proto = htons(ETH_P_IP);\n\t\t\tvlan_eth.h_vlan_encapsulated_proto = htons(ETH_P_IP);\n\t\t} else if (ip_version == IP_VERSION_6) {\n\t\t\teth.h_proto = htons(ETH_P_IPV6);\n\t\t\tvlan_eth.h_vlan_encapsulated_proto = htons(ETH_P_IPV6);\n\t\t} else {\n\t\t\tnetdev_err(dev, \"Unknown IP version %d\\n\", ip_version);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tskb = dev_alloc_skb(len + mac_header_len + NET_IP_ALIGN);\n\tif (!skb)\n\t\treturn;\n\tskb_reserve(skb, NET_IP_ALIGN);\n\n\tskb_put_data(skb, mac_header_data, mac_header_len);\n\tskb_put_data(skb, buf, len);\n\n\tskb->protocol = ((struct ethhdr *)mac_header_data)->h_proto;\n\tskb->dev = dev;\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, ETH_HLEN);\n\n\tgdm_lte_rx(skb, nic, nic_type);\n}\n\nstatic void gdm_lte_multi_sdu_pkt(struct phy_dev *phy_dev, char *buf, int len)\n{\n\tstruct net_device *dev;\n\tstruct multi_sdu *multi_sdu = (struct multi_sdu *)buf;\n\tstruct sdu *sdu = NULL;\n\tu8 endian = phy_dev->get_endian(phy_dev->priv_dev);\n\tu8 *data = (u8 *)multi_sdu->data;\n\tint copied;\n\tu16 i = 0;\n\tu16 num_packet;\n\tu16 hci_len;\n\tu16 cmd_evt;\n\tu32 nic_type;\n\tint index;\n\n\tnum_packet = gdm_dev16_to_cpu(endian, multi_sdu->num_packet);\n\n\tfor (i = 0; i < num_packet; i++) {\n\t\tcopied = data - multi_sdu->data;\n\t\tif (len < copied + sizeof(*sdu)) {\n\t\t\tpr_err(\"rx prevent buffer overflow\");\n\t\t\treturn;\n\t\t}\n\n\t\tsdu = (struct sdu *)data;\n\n\t\tcmd_evt  = gdm_dev16_to_cpu(endian, sdu->cmd_evt);\n\t\thci_len  = gdm_dev16_to_cpu(endian, sdu->len);\n\t\tnic_type = gdm_dev32_to_cpu(endian, sdu->nic_type);\n\n\t\tif (cmd_evt != LTE_RX_SDU) {\n\t\t\tpr_err(\"rx sdu wrong hci %04x\\n\", cmd_evt);\n\t\t\treturn;\n\t\t}\n\t\tif (hci_len < 12 ||\n\t\t    len < copied + sizeof(*sdu) + (hci_len - 12)) {\n\t\t\tpr_err(\"rx sdu invalid len %d\\n\", hci_len);\n\t\t\treturn;\n\t\t}\n\n\t\tindex = find_dev_index(nic_type);\n\t\tif (index < 0) {\n\t\t\tpr_err(\"rx sdu invalid nic_type :%x\\n\", nic_type);\n\t\t\treturn;\n\t\t}\n\t\tdev = phy_dev->dev[index];\n\t\tgdm_lte_netif_rx(dev, (char *)sdu->data,\n\t\t\t\t (int)(hci_len - 12), nic_type);\n\n\t\tdata += ((hci_len + 3) & 0xfffc) + HCI_HEADER_SIZE;\n\t}\n}\n\nstatic void gdm_lte_pdn_table(struct net_device *dev, char *buf, int len)\n{\n\tstruct nic *nic = netdev_priv(dev);\n\tstruct hci_pdn_table_ind *pdn_table = (struct hci_pdn_table_ind *)buf;\n\tu8 ed = nic->phy_dev->get_endian(nic->phy_dev->priv_dev);\n\n\tif (!pdn_table->activate) {\n\t\tmemset(&nic->pdn_table, 0x00, sizeof(struct pdn_table));\n\t\tnetdev_info(dev, \"pdn deactivated\\n\");\n\n\t\treturn;\n\t}\n\n\tnic->pdn_table.activate = pdn_table->activate;\n\tnic->pdn_table.dft_eps_id = gdm_dev32_to_cpu(ed, pdn_table->dft_eps_id);\n\tnic->pdn_table.nic_type = gdm_dev32_to_cpu(ed, pdn_table->nic_type);\n\n\tnetdev_info(dev, \"pdn activated, nic_type=0x%x\\n\",\n\t\t    nic->pdn_table.nic_type);\n}\n\nstatic int gdm_lte_receive_pkt(struct phy_dev *phy_dev, char *buf, int len)\n{\n\tstruct hci_packet *hci = (struct hci_packet *)buf;\n\tstruct hci_pdn_table_ind *pdn_table = (struct hci_pdn_table_ind *)buf;\n\tstruct sdu *sdu;\n\tstruct net_device *dev;\n\tu8 endian = phy_dev->get_endian(phy_dev->priv_dev);\n\tint ret = 0;\n\tu16 cmd_evt;\n\tu32 nic_type;\n\tint index;\n\n\tif (!len)\n\t\treturn ret;\n\n\tcmd_evt = gdm_dev16_to_cpu(endian, hci->cmd_evt);\n\n\tdev = phy_dev->dev[0];\n\tif (!dev)\n\t\treturn 0;\n\n\tswitch (cmd_evt) {\n\tcase LTE_RX_SDU:\n\t\tsdu = (struct sdu *)hci->data;\n\t\tnic_type = gdm_dev32_to_cpu(endian, sdu->nic_type);\n\t\tindex = find_dev_index(nic_type);\n\t\tif (index < 0)\n\t\t\treturn index;\n\t\tdev = phy_dev->dev[index];\n\t\tgdm_lte_netif_rx(dev, hci->data, len, nic_type);\n\t\tbreak;\n\tcase LTE_RX_MULTI_SDU:\n\t\tgdm_lte_multi_sdu_pkt(phy_dev, buf, len);\n\t\tbreak;\n\tcase LTE_LINK_ON_OFF_INDICATION:\n\t\tnetdev_info(dev, \"link %s\\n\",\n\t\t\t    ((struct hci_connect_ind *)buf)->connect\n\t\t\t    ? \"on\" : \"off\");\n\t\tbreak;\n\tcase LTE_PDN_TABLE_IND:\n\t\tpdn_table = (struct hci_pdn_table_ind *)buf;\n\t\tnic_type = gdm_dev32_to_cpu(endian, pdn_table->nic_type);\n\t\tindex = find_dev_index(nic_type);\n\t\tif (index < 0)\n\t\t\treturn index;\n\t\tdev = phy_dev->dev[index];\n\t\tgdm_lte_pdn_table(dev, buf, len);\n\t\tfallthrough;\n\tdefault:\n\t\tret = gdm_lte_event_send(dev, buf, len);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int rx_complete(void *arg, void *data, int len, int context)\n{\n\tstruct phy_dev *phy_dev = arg;\n\n\treturn gdm_lte_receive_pkt(phy_dev, data, len);\n}\n\nvoid start_rx_proc(struct phy_dev *phy_dev)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_RX_SUBMIT_COUNT; i++)\n\t\tphy_dev->rcv_func(phy_dev->priv_dev,\n\t\t\t\trx_complete, phy_dev, USB_COMPLETE);\n}\n\nstatic const struct net_device_ops gdm_netdev_ops = {\n\t.ndo_open\t\t\t= gdm_lte_open,\n\t.ndo_stop\t\t\t= gdm_lte_close,\n\t.ndo_set_config\t\t\t= gdm_lte_set_config,\n\t.ndo_start_xmit\t\t\t= gdm_lte_tx,\n\t.ndo_get_stats\t\t\t= gdm_lte_stats,\n};\n\nstatic u8 gdm_lte_macaddr[ETH_ALEN] = {0x00, 0x0a, 0x3b, 0x00, 0x00, 0x00};\n\nstatic void form_mac_address(u8 *dev_addr, u8 *nic_src, u8 *nic_dest,\n\t\t\t     u8 *mac_address, u8 index)\n{\n\t \n\tif (!mac_address)\n\t\tether_addr_copy(dev_addr, gdm_lte_macaddr);\n\telse\n\t\tether_addr_copy(dev_addr, mac_address);\n\n\t \n\tdev_addr[ETH_ALEN - 1] += index;\n\n\t \n\teth_random_addr(nic_src);\n\tmemcpy(nic_src, dev_addr, 3);\n\n\t \n\tether_addr_copy(nic_dest, dev_addr);\n}\n\nstatic void validate_mac_address(u8 *mac_address)\n{\n\t \n\tif (is_zero_ether_addr(mac_address) || (mac_address[0] & 0x01)) {\n\t\tpr_err(\"MAC invalid, restoring default\\n\");\n\t\tmemcpy(mac_address, gdm_lte_macaddr, 6);\n\t}\n}\n\nint register_lte_device(struct phy_dev *phy_dev,\n\t\t\tstruct device *dev, u8 *mac_address)\n{\n\tstruct nic *nic;\n\tstruct net_device *net;\n\tchar pdn_dev_name[16];\n\tu8 addr[ETH_ALEN];\n\tint ret = 0;\n\tu8 index;\n\n\tvalidate_mac_address(mac_address);\n\n\tfor (index = 0; index < MAX_NIC_TYPE; index++) {\n\t\t \n\t\tsprintf(pdn_dev_name, \"lte%%dpdn%d\", index);\n\n\t\t \n\t\tnet = alloc_netdev(sizeof(struct nic), pdn_dev_name,\n\t\t\t\t   NET_NAME_UNKNOWN, ether_setup);\n\t\tif (!net) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tnet->netdev_ops = &gdm_netdev_ops;\n\t\tnet->flags &= ~IFF_MULTICAST;\n\t\tnet->mtu = DEFAULT_MTU_SIZE;\n\n\t\tnic = netdev_priv(net);\n\t\tmemset(nic, 0, sizeof(struct nic));\n\t\tnic->netdev = net;\n\t\tnic->phy_dev = phy_dev;\n\t\tnic->nic_id = index;\n\n\t\tform_mac_address(addr,\n\t\t\t\t nic->src_mac_addr,\n\t\t\t\t nic->dest_mac_addr,\n\t\t\t\t mac_address,\n\t\t\t\t index);\n\t\teth_hw_addr_set(net, addr);\n\n\t\tSET_NETDEV_DEV(net, dev);\n\t\tSET_NETDEV_DEVTYPE(net, &wwan_type);\n\n\t\tret = register_netdev(net);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tnetif_carrier_on(net);\n\n\t\tphy_dev->dev[index] = net;\n\t}\n\n\treturn 0;\n\nerr:\n\tunregister_lte_device(phy_dev);\n\n\treturn ret;\n}\n\nvoid unregister_lte_device(struct phy_dev *phy_dev)\n{\n\tstruct net_device *net;\n\tint index;\n\n\tfor (index = 0; index < MAX_NIC_TYPE; index++) {\n\t\tnet = phy_dev->dev[index];\n\t\tif (!net)\n\t\t\tcontinue;\n\n\t\tunregister_netdev(net);\n\t\tfree_netdev(net);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}