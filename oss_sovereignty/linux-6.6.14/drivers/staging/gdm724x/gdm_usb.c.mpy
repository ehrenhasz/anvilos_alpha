{
  "module_name": "gdm_usb.c",
  "hash_id": "12ef6b17df2b187e623ef96e6da46ffd6fae7f3a5ad6a3381fce8f7b7b5df692",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/gdm724x/gdm_usb.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/usb.h>\n#include <linux/sched.h>\n#include <linux/kthread.h>\n#include <linux/usb/cdc.h>\n#include <linux/wait.h>\n#include <linux/if_ether.h>\n#include <linux/pm_runtime.h>\n\n#include \"gdm_usb.h\"\n#include \"gdm_lte.h\"\n#include \"hci.h\"\n#include \"hci_packet.h\"\n#include \"gdm_endian.h\"\n\n#define USB_DEVICE_CDC_DATA(vid, pid) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\tUSB_DEVICE_ID_MATCH_INT_CLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_INT_SUBCLASS,\\\n\t.idVendor = vid,\\\n\t.idProduct = pid,\\\n\t.bInterfaceClass = USB_CLASS_COMM,\\\n\t.bInterfaceSubClass = USB_CDC_SUBCLASS_ETHERNET\n\n#define USB_DEVICE_MASS_DATA(vid, pid) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\tUSB_DEVICE_ID_MATCH_INT_INFO,\\\n\t.idVendor = vid,\\\n\t.idProduct = pid,\\\n\t.bInterfaceSubClass = USB_SC_SCSI, \\\n\t.bInterfaceClass = USB_CLASS_MASS_STORAGE,\\\n\t.bInterfaceProtocol = USB_PR_BULK\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE_CDC_DATA(VID_GCT, PID_GDM7240) },  \n\t{ USB_DEVICE_CDC_DATA(VID_GCT, PID_GDM7243) },  \n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic void do_tx(struct work_struct *work);\nstatic void do_rx(struct work_struct *work);\n\nstatic int gdm_usb_recv(void *priv_dev,\n\t\t\tint (*cb)(void *cb_data,\n\t\t\t\t  void *data, int len, int context),\n\t\t\tvoid *cb_data,\n\t\t\tint context);\n\nstatic int request_mac_address(struct lte_udev *udev)\n{\n\tstruct hci_packet *hci;\n\tstruct usb_device *usbdev = udev->usbdev;\n\tint actual;\n\tint ret = -1;\n\n\thci = kmalloc(struct_size(hci, data, 1), GFP_KERNEL);\n\tif (!hci)\n\t\treturn -ENOMEM;\n\n\thci->cmd_evt = gdm_cpu_to_dev16(udev->gdm_ed, LTE_GET_INFORMATION);\n\thci->len = gdm_cpu_to_dev16(udev->gdm_ed, 1);\n\thci->data[0] = MAC_ADDRESS;\n\n\tret = usb_bulk_msg(usbdev, usb_sndbulkpipe(usbdev, 2), hci, 5,\n\t\t\t   &actual, 1000);\n\n\tudev->request_mac_addr = 1;\n\tkfree(hci);\n\n\treturn ret;\n}\n\nstatic struct usb_tx *alloc_tx_struct(int len)\n{\n\tstruct usb_tx *t = NULL;\n\tint ret = 0;\n\n\tt = kzalloc(sizeof(*t), GFP_ATOMIC);\n\tif (!t) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tt->urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!(len % 512))\n\t\tlen++;\n\n\tt->buf = kmalloc(len, GFP_ATOMIC);\n\tif (!t->urb || !t->buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret < 0) {\n\t\tif (t) {\n\t\t\tusb_free_urb(t->urb);\n\t\t\tkfree(t->buf);\n\t\t\tkfree(t);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\treturn t;\n}\n\nstatic struct usb_tx_sdu *alloc_tx_sdu_struct(void)\n{\n\tstruct usb_tx_sdu *t_sdu;\n\n\tt_sdu = kzalloc(sizeof(*t_sdu), GFP_KERNEL);\n\tif (!t_sdu)\n\t\treturn NULL;\n\n\tt_sdu->buf = kmalloc(SDU_BUF_SIZE, GFP_KERNEL);\n\tif (!t_sdu->buf) {\n\t\tkfree(t_sdu);\n\t\treturn NULL;\n\t}\n\n\treturn t_sdu;\n}\n\nstatic void free_tx_struct(struct usb_tx *t)\n{\n\tif (t) {\n\t\tusb_free_urb(t->urb);\n\t\tkfree(t->buf);\n\t\tkfree(t);\n\t}\n}\n\nstatic void free_tx_sdu_struct(struct usb_tx_sdu *t_sdu)\n{\n\tif (t_sdu) {\n\t\tkfree(t_sdu->buf);\n\t\tkfree(t_sdu);\n\t}\n}\n\nstatic struct usb_tx_sdu *get_tx_sdu_struct(struct tx_cxt *tx, int *no_spc)\n{\n\tstruct usb_tx_sdu *t_sdu;\n\n\tif (list_empty(&tx->free_list))\n\t\treturn NULL;\n\n\tt_sdu = list_entry(tx->free_list.next, struct usb_tx_sdu, list);\n\tlist_del(&t_sdu->list);\n\n\ttx->avail_count--;\n\n\t*no_spc = list_empty(&tx->free_list) ? 1 : 0;\n\n\treturn t_sdu;\n}\n\nstatic void put_tx_struct(struct tx_cxt *tx, struct usb_tx_sdu *t_sdu)\n{\n\tlist_add_tail(&t_sdu->list, &tx->free_list);\n\ttx->avail_count++;\n}\n\nstatic struct usb_rx *alloc_rx_struct(void)\n{\n\tstruct usb_rx *r = NULL;\n\tint ret = 0;\n\n\tr = kmalloc(sizeof(*r), GFP_KERNEL);\n\tif (!r) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tr->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tr->buf = kmalloc(RX_BUF_SIZE, GFP_KERNEL);\n\tif (!r->urb || !r->buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\nout:\n\n\tif (ret < 0) {\n\t\tif (r) {\n\t\t\tusb_free_urb(r->urb);\n\t\t\tkfree(r->buf);\n\t\t\tkfree(r);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\treturn r;\n}\n\nstatic void free_rx_struct(struct usb_rx *r)\n{\n\tif (r) {\n\t\tusb_free_urb(r->urb);\n\t\tkfree(r->buf);\n\t\tkfree(r);\n\t}\n}\n\nstatic struct usb_rx *get_rx_struct(struct rx_cxt *rx, int *no_spc)\n{\n\tstruct usb_rx *r;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rx->rx_lock, flags);\n\n\tif (list_empty(&rx->free_list)) {\n\t\tspin_unlock_irqrestore(&rx->rx_lock, flags);\n\t\treturn NULL;\n\t}\n\n\tr = list_entry(rx->free_list.next, struct usb_rx, free_list);\n\tlist_del(&r->free_list);\n\n\trx->avail_count--;\n\n\t*no_spc = list_empty(&rx->free_list) ? 1 : 0;\n\n\tspin_unlock_irqrestore(&rx->rx_lock, flags);\n\n\treturn r;\n}\n\nstatic void put_rx_struct(struct rx_cxt *rx, struct usb_rx *r)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rx->rx_lock, flags);\n\n\tlist_add_tail(&r->free_list, &rx->free_list);\n\trx->avail_count++;\n\n\tspin_unlock_irqrestore(&rx->rx_lock, flags);\n}\n\nstatic void release_usb(struct lte_udev *udev)\n{\n\tstruct rx_cxt\t*rx = &udev->rx;\n\tstruct tx_cxt\t*tx = &udev->tx;\n\tstruct usb_tx\t*t, *t_next;\n\tstruct usb_rx\t*r, *r_next;\n\tstruct usb_tx_sdu\t*t_sdu, *t_sdu_next;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tx->lock, flags);\n\tlist_for_each_entry_safe(t_sdu, t_sdu_next, &tx->sdu_list, list) {\n\t\tlist_del(&t_sdu->list);\n\t\tfree_tx_sdu_struct(t_sdu);\n\t}\n\n\tlist_for_each_entry_safe(t, t_next, &tx->hci_list, list) {\n\t\tlist_del(&t->list);\n\t\tfree_tx_struct(t);\n\t}\n\n\tlist_for_each_entry_safe(t_sdu, t_sdu_next, &tx->free_list, list) {\n\t\tlist_del(&t_sdu->list);\n\t\tfree_tx_sdu_struct(t_sdu);\n\t}\n\tspin_unlock_irqrestore(&tx->lock, flags);\n\n\tspin_lock_irqsave(&rx->submit_lock, flags);\n\tlist_for_each_entry_safe(r, r_next, &rx->rx_submit_list,\n\t\t\t\t rx_submit_list) {\n\t\tspin_unlock_irqrestore(&rx->submit_lock, flags);\n\t\tusb_kill_urb(r->urb);\n\t\tspin_lock_irqsave(&rx->submit_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&rx->submit_lock, flags);\n\n\tspin_lock_irqsave(&rx->rx_lock, flags);\n\tlist_for_each_entry_safe(r, r_next, &rx->free_list, free_list) {\n\t\tlist_del(&r->free_list);\n\t\tfree_rx_struct(r);\n\t}\n\tspin_unlock_irqrestore(&rx->rx_lock, flags);\n\n\tspin_lock_irqsave(&rx->to_host_lock, flags);\n\tlist_for_each_entry_safe(r, r_next, &rx->to_host_list, to_host_list) {\n\t\tif (r->index == (void *)udev) {\n\t\t\tlist_del(&r->to_host_list);\n\t\t\tfree_rx_struct(r);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&rx->to_host_lock, flags);\n}\n\nstatic int init_usb(struct lte_udev *udev)\n{\n\tint ret = 0;\n\tint i;\n\tstruct tx_cxt *tx = &udev->tx;\n\tstruct rx_cxt *rx = &udev->rx;\n\tstruct usb_tx_sdu *t_sdu = NULL;\n\tstruct usb_rx *r = NULL;\n\n\tudev->send_complete = 1;\n\tudev->tx_stop = 0;\n\tudev->request_mac_addr = 0;\n\tudev->usb_state = PM_NORMAL;\n\n\tINIT_LIST_HEAD(&tx->sdu_list);\n\tINIT_LIST_HEAD(&tx->hci_list);\n\tINIT_LIST_HEAD(&tx->free_list);\n\tINIT_LIST_HEAD(&rx->rx_submit_list);\n\tINIT_LIST_HEAD(&rx->free_list);\n\tINIT_LIST_HEAD(&rx->to_host_list);\n\tspin_lock_init(&tx->lock);\n\tspin_lock_init(&rx->rx_lock);\n\tspin_lock_init(&rx->submit_lock);\n\tspin_lock_init(&rx->to_host_lock);\n\n\ttx->avail_count = 0;\n\trx->avail_count = 0;\n\n\tudev->rx_cb = NULL;\n\n\tfor (i = 0; i < MAX_NUM_SDU_BUF; i++) {\n\t\tt_sdu = alloc_tx_sdu_struct();\n\t\tif (!t_sdu) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlist_add(&t_sdu->list, &tx->free_list);\n\t\ttx->avail_count++;\n\t}\n\n\tfor (i = 0; i < MAX_RX_SUBMIT_COUNT * 2; i++) {\n\t\tr = alloc_rx_struct();\n\t\tif (!r) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlist_add(&r->free_list, &rx->free_list);\n\t\trx->avail_count++;\n\t}\n\tINIT_DELAYED_WORK(&udev->work_tx, do_tx);\n\tINIT_DELAYED_WORK(&udev->work_rx, do_rx);\n\treturn 0;\nfail:\n\trelease_usb(udev);\n\treturn ret;\n}\n\nstatic int set_mac_address(u8 *data, void *arg)\n{\n\tstruct phy_dev *phy_dev = arg;\n\tstruct lte_udev *udev = phy_dev->priv_dev;\n\tstruct tlv *tlv = (struct tlv *)data;\n\tu8 mac_address[ETH_ALEN] = {0, };\n\n\tif (tlv->type == MAC_ADDRESS && udev->request_mac_addr) {\n\t\tmemcpy(mac_address, tlv->data, tlv->len);\n\n\t\tif (register_lte_device(phy_dev,\n\t\t\t\t\t&udev->intf->dev, mac_address) < 0)\n\t\t\tpr_err(\"register lte device failed\\n\");\n\n\t\tudev->request_mac_addr = 0;\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void do_rx(struct work_struct *work)\n{\n\tstruct lte_udev *udev =\n\t\tcontainer_of(work, struct lte_udev, work_rx.work);\n\tstruct rx_cxt *rx = &udev->rx;\n\tstruct usb_rx *r;\n\tstruct hci_packet *hci;\n\tstruct phy_dev *phy_dev;\n\tu16 cmd_evt;\n\tint ret;\n\tunsigned long flags;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(&rx->to_host_lock, flags);\n\t\tif (list_empty(&rx->to_host_list)) {\n\t\t\tspin_unlock_irqrestore(&rx->to_host_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tr = list_entry(rx->to_host_list.next,\n\t\t\t       struct usb_rx, to_host_list);\n\t\tlist_del(&r->to_host_list);\n\t\tspin_unlock_irqrestore(&rx->to_host_lock, flags);\n\n\t\tphy_dev = r->cb_data;\n\t\tudev = phy_dev->priv_dev;\n\t\thci = (struct hci_packet *)r->buf;\n\t\tcmd_evt = gdm_dev16_to_cpu(udev->gdm_ed, hci->cmd_evt);\n\n\t\tswitch (cmd_evt) {\n\t\tcase LTE_GET_INFORMATION_RESULT:\n\t\t\tif (set_mac_address(hci->data, r->cb_data) == 0) {\n\t\t\t\tr->callback(r->cb_data,\n\t\t\t\t\t    r->buf,\n\t\t\t\t\t    r->urb->actual_length,\n\t\t\t\t\t    KERNEL_THREAD);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (r->callback) {\n\t\t\t\tret = r->callback(r->cb_data,\n\t\t\t\t\t\t  r->buf,\n\t\t\t\t\t\t  r->urb->actual_length,\n\t\t\t\t\t\t  KERNEL_THREAD);\n\n\t\t\t\tif (ret == -EAGAIN)\n\t\t\t\t\tpr_err(\"failed to send received data\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tput_rx_struct(rx, r);\n\n\t\tgdm_usb_recv(udev,\n\t\t\t     r->callback,\n\t\t\t     r->cb_data,\n\t\t\t     USB_COMPLETE);\n\t}\n}\n\nstatic void remove_rx_submit_list(struct usb_rx *r, struct rx_cxt *rx)\n{\n\tunsigned long flags;\n\tstruct usb_rx\t*r_remove, *r_remove_next;\n\n\tspin_lock_irqsave(&rx->submit_lock, flags);\n\tlist_for_each_entry_safe(r_remove, r_remove_next,\n\t\t\t\t &rx->rx_submit_list, rx_submit_list) {\n\t\tif (r == r_remove) {\n\t\t\tlist_del(&r->rx_submit_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&rx->submit_lock, flags);\n}\n\nstatic void gdm_usb_rcv_complete(struct urb *urb)\n{\n\tstruct usb_rx *r = urb->context;\n\tstruct rx_cxt *rx = r->rx;\n\tunsigned long flags;\n\tstruct lte_udev *udev = container_of(r->rx, struct lte_udev, rx);\n\tstruct usb_device *usbdev = udev->usbdev;\n\n\tremove_rx_submit_list(r, rx);\n\n\tif (!urb->status && r->callback) {\n\t\tspin_lock_irqsave(&rx->to_host_lock, flags);\n\t\tlist_add_tail(&r->to_host_list, &rx->to_host_list);\n\t\tschedule_work(&udev->work_rx.work);\n\t\tspin_unlock_irqrestore(&rx->to_host_lock, flags);\n\t} else {\n\t\tif (urb->status && udev->usb_state == PM_NORMAL)\n\t\t\tdev_err(&urb->dev->dev, \"%s: urb status error %d\\n\",\n\t\t\t\t__func__, urb->status);\n\n\t\tput_rx_struct(rx, r);\n\t}\n\n\tusb_mark_last_busy(usbdev);\n}\n\nstatic int gdm_usb_recv(void *priv_dev,\n\t\t\tint (*cb)(void *cb_data,\n\t\t\t\t  void *data, int len, int context),\n\t\t\tvoid *cb_data,\n\t\t\tint context)\n{\n\tstruct lte_udev *udev = priv_dev;\n\tstruct usb_device *usbdev = udev->usbdev;\n\tstruct rx_cxt *rx = &udev->rx;\n\tstruct usb_rx *r;\n\tint no_spc;\n\tint ret;\n\tunsigned long flags;\n\n\tif (!udev->usbdev) {\n\t\tpr_err(\"invalid device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tr = get_rx_struct(rx, &no_spc);\n\tif (!r) {\n\t\tpr_err(\"Out of Memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tudev->rx_cb = cb;\n\tr->callback = cb;\n\tr->cb_data = cb_data;\n\tr->index = (void *)udev;\n\tr->rx = rx;\n\n\tusb_fill_bulk_urb(r->urb,\n\t\t\t  usbdev,\n\t\t\t  usb_rcvbulkpipe(usbdev, 0x83),\n\t\t\t  r->buf,\n\t\t\t  RX_BUF_SIZE,\n\t\t\t  gdm_usb_rcv_complete,\n\t\t\t  r);\n\n\tspin_lock_irqsave(&rx->submit_lock, flags);\n\tlist_add_tail(&r->rx_submit_list, &rx->rx_submit_list);\n\tspin_unlock_irqrestore(&rx->submit_lock, flags);\n\n\tif (context == KERNEL_THREAD)\n\t\tret = usb_submit_urb(r->urb, GFP_KERNEL);\n\telse\n\t\tret = usb_submit_urb(r->urb, GFP_ATOMIC);\n\n\tif (ret) {\n\t\tspin_lock_irqsave(&rx->submit_lock, flags);\n\t\tlist_del(&r->rx_submit_list);\n\t\tspin_unlock_irqrestore(&rx->submit_lock, flags);\n\n\t\tpr_err(\"usb_submit_urb failed (%p)\\n\", r);\n\t\tput_rx_struct(rx, r);\n\t}\n\n\treturn ret;\n}\n\nstatic void gdm_usb_send_complete(struct urb *urb)\n{\n\tstruct usb_tx *t = urb->context;\n\tstruct tx_cxt *tx = t->tx;\n\tstruct lte_udev *udev = container_of(tx, struct lte_udev, tx);\n\tunsigned long flags;\n\n\tif (urb->status == -ECONNRESET) {\n\t\tdev_info(&urb->dev->dev, \"CONNRESET\\n\");\n\t\treturn;\n\t}\n\n\tif (t->callback)\n\t\tt->callback(t->cb_data);\n\n\tfree_tx_struct(t);\n\n\tspin_lock_irqsave(&tx->lock, flags);\n\tudev->send_complete = 1;\n\tschedule_work(&udev->work_tx.work);\n\tspin_unlock_irqrestore(&tx->lock, flags);\n}\n\nstatic int send_tx_packet(struct usb_device *usbdev, struct usb_tx *t, u32 len)\n{\n\tint ret = 0;\n\n\tif (!(len % 512))\n\t\tlen++;\n\n\tusb_fill_bulk_urb(t->urb,\n\t\t\t  usbdev,\n\t\t\t  usb_sndbulkpipe(usbdev, 2),\n\t\t\t  t->buf,\n\t\t\t  len,\n\t\t\t  gdm_usb_send_complete,\n\t\t\t  t);\n\n\tret = usb_submit_urb(t->urb, GFP_ATOMIC);\n\n\tif (ret)\n\t\tdev_err(&usbdev->dev, \"usb_submit_urb failed: %d\\n\",\n\t\t\tret);\n\n\tusb_mark_last_busy(usbdev);\n\n\treturn ret;\n}\n\nstatic u32 packet_aggregation(struct lte_udev *udev, u8 *send_buf)\n{\n\tstruct tx_cxt *tx = &udev->tx;\n\tstruct usb_tx_sdu *t_sdu = NULL;\n\tstruct multi_sdu *multi_sdu = (struct multi_sdu *)send_buf;\n\tu16 send_len = 0;\n\tu16 num_packet = 0;\n\tunsigned long flags;\n\n\tmulti_sdu->cmd_evt = gdm_cpu_to_dev16(udev->gdm_ed, LTE_TX_MULTI_SDU);\n\n\twhile (num_packet < MAX_PACKET_IN_MULTI_SDU) {\n\t\tspin_lock_irqsave(&tx->lock, flags);\n\t\tif (list_empty(&tx->sdu_list)) {\n\t\t\tspin_unlock_irqrestore(&tx->lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tt_sdu = list_entry(tx->sdu_list.next, struct usb_tx_sdu, list);\n\t\tif (send_len + t_sdu->len > MAX_SDU_SIZE) {\n\t\t\tspin_unlock_irqrestore(&tx->lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del(&t_sdu->list);\n\t\tspin_unlock_irqrestore(&tx->lock, flags);\n\n\t\tmemcpy(multi_sdu->data + send_len, t_sdu->buf, t_sdu->len);\n\n\t\tsend_len += (t_sdu->len + 3) & 0xfffc;\n\t\tnum_packet++;\n\n\t\tif (tx->avail_count > 10)\n\t\t\tt_sdu->callback(t_sdu->cb_data);\n\n\t\tspin_lock_irqsave(&tx->lock, flags);\n\t\tput_tx_struct(tx, t_sdu);\n\t\tspin_unlock_irqrestore(&tx->lock, flags);\n\t}\n\n\tmulti_sdu->len = gdm_cpu_to_dev16(udev->gdm_ed, send_len);\n\tmulti_sdu->num_packet = gdm_cpu_to_dev16(udev->gdm_ed, num_packet);\n\n\treturn send_len + offsetof(struct multi_sdu, data);\n}\n\nstatic void do_tx(struct work_struct *work)\n{\n\tstruct lte_udev *udev =\n\t\tcontainer_of(work, struct lte_udev, work_tx.work);\n\tstruct usb_device *usbdev = udev->usbdev;\n\tstruct tx_cxt *tx = &udev->tx;\n\tstruct usb_tx *t = NULL;\n\tint is_send = 0;\n\tu32 len = 0;\n\tunsigned long flags;\n\n\tif (!usb_autopm_get_interface(udev->intf))\n\t\tusb_autopm_put_interface(udev->intf);\n\n\tif (udev->usb_state == PM_SUSPEND)\n\t\treturn;\n\n\tspin_lock_irqsave(&tx->lock, flags);\n\tif (!udev->send_complete) {\n\t\tspin_unlock_irqrestore(&tx->lock, flags);\n\t\treturn;\n\t}\n\tudev->send_complete = 0;\n\n\tif (!list_empty(&tx->hci_list)) {\n\t\tt = list_entry(tx->hci_list.next, struct usb_tx, list);\n\t\tlist_del(&t->list);\n\t\tlen = t->len;\n\t\tt->is_sdu = 0;\n\t\tis_send = 1;\n\t} else if (!list_empty(&tx->sdu_list)) {\n\t\tif (udev->tx_stop) {\n\t\t\tudev->send_complete = 1;\n\t\t\tspin_unlock_irqrestore(&tx->lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tt = alloc_tx_struct(TX_BUF_SIZE);\n\t\tif (!t) {\n\t\t\tspin_unlock_irqrestore(&tx->lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tt->callback = NULL;\n\t\tt->tx = tx;\n\t\tt->is_sdu = 1;\n\t\tis_send = 1;\n\t}\n\n\tif (!is_send) {\n\t\tudev->send_complete = 1;\n\t\tspin_unlock_irqrestore(&tx->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&tx->lock, flags);\n\n\tif (t->is_sdu)\n\t\tlen = packet_aggregation(udev, t->buf);\n\n\tif (send_tx_packet(usbdev, t, len)) {\n\t\tpr_err(\"send_tx_packet failed\\n\");\n\t\tt->callback = NULL;\n\t\tgdm_usb_send_complete(t->urb);\n\t}\n}\n\n#define SDU_PARAM_LEN 12\nstatic int gdm_usb_sdu_send(void *priv_dev, void *data, int len,\n\t\t\t    unsigned int dft_eps_ID, unsigned int eps_ID,\n\t\t\t    void (*cb)(void *data), void *cb_data,\n\t\t\t    int dev_idx, int nic_type)\n{\n\tstruct lte_udev *udev = priv_dev;\n\tstruct tx_cxt *tx = &udev->tx;\n\tstruct usb_tx_sdu *t_sdu;\n\tstruct sdu *sdu = NULL;\n\tunsigned long flags;\n\tint no_spc = 0;\n\tu16 send_len;\n\n\tif (!udev->usbdev) {\n\t\tpr_err(\"sdu send - invalid device\\n\");\n\t\treturn TX_NO_DEV;\n\t}\n\n\tspin_lock_irqsave(&tx->lock, flags);\n\tt_sdu = get_tx_sdu_struct(tx, &no_spc);\n\tspin_unlock_irqrestore(&tx->lock, flags);\n\n\tif (!t_sdu) {\n\t\tpr_err(\"sdu send - free list empty\\n\");\n\t\treturn TX_NO_SPC;\n\t}\n\n\tsdu = (struct sdu *)t_sdu->buf;\n\tsdu->cmd_evt = gdm_cpu_to_dev16(udev->gdm_ed, LTE_TX_SDU);\n\tif (nic_type == NIC_TYPE_ARP) {\n\t\tsend_len = len + SDU_PARAM_LEN;\n\t\tmemcpy(sdu->data, data, len);\n\t} else {\n\t\tsend_len = len - ETH_HLEN;\n\t\tsend_len += SDU_PARAM_LEN;\n\t\tmemcpy(sdu->data, data + ETH_HLEN, len - ETH_HLEN);\n\t}\n\n\tsdu->len = gdm_cpu_to_dev16(udev->gdm_ed, send_len);\n\tsdu->dft_eps_ID = gdm_cpu_to_dev32(udev->gdm_ed, dft_eps_ID);\n\tsdu->bearer_ID = gdm_cpu_to_dev32(udev->gdm_ed, eps_ID);\n\tsdu->nic_type = gdm_cpu_to_dev32(udev->gdm_ed, nic_type);\n\n\tt_sdu->len = send_len + HCI_HEADER_SIZE;\n\tt_sdu->callback = cb;\n\tt_sdu->cb_data = cb_data;\n\n\tspin_lock_irqsave(&tx->lock, flags);\n\tlist_add_tail(&t_sdu->list, &tx->sdu_list);\n\tschedule_work(&udev->work_tx.work);\n\tspin_unlock_irqrestore(&tx->lock, flags);\n\n\tif (no_spc)\n\t\treturn TX_NO_BUFFER;\n\n\treturn 0;\n}\n\nstatic int gdm_usb_hci_send(void *priv_dev, void *data, int len,\n\t\t\t    void (*cb)(void *data), void *cb_data)\n{\n\tstruct lte_udev *udev = priv_dev;\n\tstruct tx_cxt *tx = &udev->tx;\n\tstruct usb_tx *t;\n\tunsigned long flags;\n\n\tif (!udev->usbdev) {\n\t\tpr_err(\"hci send - invalid device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tt = alloc_tx_struct(len);\n\tif (!t) {\n\t\tpr_err(\"hci_send - out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(t->buf, data, len);\n\tt->callback = cb;\n\tt->cb_data = cb_data;\n\tt->len = len;\n\tt->tx = tx;\n\tt->is_sdu = 0;\n\n\tspin_lock_irqsave(&tx->lock, flags);\n\tlist_add_tail(&t->list, &tx->hci_list);\n\tschedule_work(&udev->work_tx.work);\n\tspin_unlock_irqrestore(&tx->lock, flags);\n\n\treturn 0;\n}\n\nstatic u8 gdm_usb_get_endian(void *priv_dev)\n{\n\tstruct lte_udev *udev = priv_dev;\n\n\treturn udev->gdm_ed;\n}\n\nstatic int gdm_usb_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tint ret = 0;\n\tstruct phy_dev *phy_dev = NULL;\n\tstruct lte_udev *udev = NULL;\n\tu16 idVendor, idProduct;\n\tint bInterfaceNumber;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\n\tbInterfaceNumber = intf->cur_altsetting->desc.bInterfaceNumber;\n\tidVendor = __le16_to_cpu(usbdev->descriptor.idVendor);\n\tidProduct = __le16_to_cpu(usbdev->descriptor.idProduct);\n\n\tpr_info(\"net vid = 0x%04x pid = 0x%04x\\n\", idVendor, idProduct);\n\n\tif (bInterfaceNumber > NETWORK_INTERFACE) {\n\t\tpr_info(\"not a network device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tphy_dev = kzalloc(sizeof(*phy_dev), GFP_KERNEL);\n\tif (!phy_dev)\n\t\treturn -ENOMEM;\n\n\tudev = kzalloc(sizeof(*udev), GFP_KERNEL);\n\tif (!udev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_udev;\n\t}\n\n\tphy_dev->priv_dev = (void *)udev;\n\tphy_dev->send_hci_func = gdm_usb_hci_send;\n\tphy_dev->send_sdu_func = gdm_usb_sdu_send;\n\tphy_dev->rcv_func = gdm_usb_recv;\n\tphy_dev->get_endian = gdm_usb_get_endian;\n\n\tudev->usbdev = usbdev;\n\tret = init_usb(udev);\n\tif (ret < 0) {\n\t\tdev_err(intf->usb_dev, \"init_usb func failed\\n\");\n\t\tgoto err_init_usb;\n\t}\n\tudev->intf = intf;\n\n\tintf->needs_remote_wakeup = 1;\n\tusb_enable_autosuspend(usbdev);\n\tpm_runtime_set_autosuspend_delay(&usbdev->dev, AUTO_SUSPEND_TIMER);\n\n\t \n\tif (idProduct == PID_GDM7243)\n\t\tudev->gdm_ed = ENDIANNESS_BIG;\n\telse\n\t\tudev->gdm_ed = ENDIANNESS_LITTLE;\n\n\tret = request_mac_address(udev);\n\tif (ret < 0) {\n\t\tdev_err(intf->usb_dev, \"request Mac address failed\\n\");\n\t\tgoto err_mac_address;\n\t}\n\n\tstart_rx_proc(phy_dev);\n\tusb_get_dev(usbdev);\n\tusb_set_intfdata(intf, phy_dev);\n\n\treturn 0;\n\nerr_mac_address:\n\trelease_usb(udev);\nerr_init_usb:\n\tkfree(udev);\nerr_udev:\n\tkfree(phy_dev);\n\n\treturn ret;\n}\n\nstatic void gdm_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct phy_dev *phy_dev;\n\tstruct lte_udev *udev;\n\tstruct usb_device *usbdev;\n\n\tusbdev = interface_to_usbdev(intf);\n\tphy_dev = usb_get_intfdata(intf);\n\n\tudev = phy_dev->priv_dev;\n\tunregister_lte_device(phy_dev);\n\n\trelease_usb(udev);\n\n\tkfree(udev);\n\tudev = NULL;\n\n\tkfree(phy_dev);\n\tphy_dev = NULL;\n\n\tusb_put_dev(usbdev);\n}\n\nstatic int gdm_usb_suspend(struct usb_interface *intf, pm_message_t pm_msg)\n{\n\tstruct phy_dev *phy_dev;\n\tstruct lte_udev *udev;\n\tstruct rx_cxt *rx;\n\tstruct usb_rx *r;\n\tstruct usb_rx *r_next;\n\tunsigned long flags;\n\n\tphy_dev = usb_get_intfdata(intf);\n\tudev = phy_dev->priv_dev;\n\trx = &udev->rx;\n\tif (udev->usb_state != PM_NORMAL) {\n\t\tdev_err(intf->usb_dev, \"usb suspend - invalid state\\n\");\n\t\treturn -1;\n\t}\n\n\tudev->usb_state = PM_SUSPEND;\n\n\tspin_lock_irqsave(&rx->submit_lock, flags);\n\tlist_for_each_entry_safe(r, r_next, &rx->rx_submit_list,\n\t\t\t\t rx_submit_list) {\n\t\tspin_unlock_irqrestore(&rx->submit_lock, flags);\n\t\tusb_kill_urb(r->urb);\n\t\tspin_lock_irqsave(&rx->submit_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&rx->submit_lock, flags);\n\n\tcancel_work_sync(&udev->work_tx.work);\n\tcancel_work_sync(&udev->work_rx.work);\n\n\treturn 0;\n}\n\nstatic int gdm_usb_resume(struct usb_interface *intf)\n{\n\tstruct phy_dev *phy_dev;\n\tstruct lte_udev *udev;\n\tstruct tx_cxt *tx;\n\tstruct rx_cxt *rx;\n\tunsigned long flags;\n\tint issue_count;\n\tint i;\n\n\tphy_dev = usb_get_intfdata(intf);\n\tudev = phy_dev->priv_dev;\n\trx = &udev->rx;\n\n\tif (udev->usb_state != PM_SUSPEND) {\n\t\tdev_err(intf->usb_dev, \"usb resume - invalid state\\n\");\n\t\treturn -1;\n\t}\n\tudev->usb_state = PM_NORMAL;\n\n\tspin_lock_irqsave(&rx->rx_lock, flags);\n\tissue_count = rx->avail_count - MAX_RX_SUBMIT_COUNT;\n\tspin_unlock_irqrestore(&rx->rx_lock, flags);\n\n\tif (issue_count >= 0) {\n\t\tfor (i = 0; i < issue_count; i++)\n\t\t\tgdm_usb_recv(phy_dev->priv_dev,\n\t\t\t\t     udev->rx_cb,\n\t\t\t\t     phy_dev,\n\t\t\t\t     USB_COMPLETE);\n\t}\n\n\ttx = &udev->tx;\n\tspin_lock_irqsave(&tx->lock, flags);\n\tschedule_work(&udev->work_tx.work);\n\tspin_unlock_irqrestore(&tx->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct usb_driver gdm_usb_lte_driver = {\n\t.name = \"gdm_lte\",\n\t.probe = gdm_usb_probe,\n\t.disconnect = gdm_usb_disconnect,\n\t.id_table = id_table,\n\t.supports_autosuspend = 1,\n\t.suspend = gdm_usb_suspend,\n\t.resume = gdm_usb_resume,\n\t.reset_resume = gdm_usb_resume,\n};\n\nstatic int __init gdm_usb_lte_init(void)\n{\n\tif (gdm_lte_event_init() < 0) {\n\t\tpr_err(\"error creating event\\n\");\n\t\treturn -1;\n\t}\n\n\treturn usb_register(&gdm_usb_lte_driver);\n}\n\nstatic void __exit gdm_usb_lte_exit(void)\n{\n\tgdm_lte_event_exit();\n\n\tusb_deregister(&gdm_usb_lte_driver);\n}\n\nmodule_init(gdm_usb_lte_init);\nmodule_exit(gdm_usb_lte_exit);\n\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_DESCRIPTION(\"GCT LTE USB Device Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}