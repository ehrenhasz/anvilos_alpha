{
  "module_name": "gdm_mux.c",
  "hash_id": "2a20df6f9d6b37970ff3fc19cca166849a821c6f57ce05cd155ce908989f1bf8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/gdm724x/gdm_mux.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/usb.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/slab.h>\n#include <linux/usb/cdc.h>\n\n#include \"gdm_mux.h\"\n\nstatic u16 packet_type_for_tty_index[TTY_MAX_COUNT] = {0xF011, 0xF010};\n\n#define USB_DEVICE_CDC_DATA(vid, pid) \\\n\t.match_flags = \\\n\t\tUSB_DEVICE_ID_MATCH_DEVICE |\\\n\t\tUSB_DEVICE_ID_MATCH_INT_CLASS |\\\n\t\tUSB_DEVICE_ID_MATCH_INT_SUBCLASS,\\\n\t.idVendor = vid,\\\n\t.idProduct = pid,\\\n\t.bInterfaceClass = USB_CLASS_COMM,\\\n\t.bInterfaceSubClass = USB_CDC_SUBCLASS_ACM\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE_CDC_DATA(0x1076, 0x8000) },  \n\t{ USB_DEVICE_CDC_DATA(0x1076, 0x8f00) },  \n\t{ USB_DEVICE_CDC_DATA(0x1076, 0x9000) },  \n\t{ USB_DEVICE_CDC_DATA(0x1d74, 0x2300) },  \n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic int packet_type_to_tty_index(u16 packet_type)\n{\n\tint i;\n\n\tfor (i = 0; i < TTY_MAX_COUNT; i++) {\n\t\tif (packet_type_for_tty_index[i] == packet_type)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nstatic struct mux_tx *alloc_mux_tx(int len)\n{\n\tstruct mux_tx *t;\n\n\tt = kzalloc(sizeof(*t), GFP_ATOMIC);\n\tif (!t)\n\t\treturn NULL;\n\n\tt->urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tt->buf = kmalloc(MUX_TX_MAX_SIZE, GFP_ATOMIC);\n\tif (!t->urb || !t->buf) {\n\t\tusb_free_urb(t->urb);\n\t\tkfree(t->buf);\n\t\tkfree(t);\n\t\treturn NULL;\n\t}\n\n\treturn t;\n}\n\nstatic void free_mux_tx(struct mux_tx *t)\n{\n\tif (t) {\n\t\tusb_free_urb(t->urb);\n\t\tkfree(t->buf);\n\t\tkfree(t);\n\t}\n}\n\nstatic struct mux_rx *alloc_mux_rx(void)\n{\n\tstruct mux_rx *r;\n\n\tr = kzalloc(sizeof(*r), GFP_KERNEL);\n\tif (!r)\n\t\treturn NULL;\n\n\tr->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tr->buf = kmalloc(MUX_RX_MAX_SIZE, GFP_KERNEL);\n\tif (!r->urb || !r->buf) {\n\t\tusb_free_urb(r->urb);\n\t\tkfree(r->buf);\n\t\tkfree(r);\n\t\treturn NULL;\n\t}\n\n\treturn r;\n}\n\nstatic void free_mux_rx(struct mux_rx *r)\n{\n\tif (r) {\n\t\tusb_free_urb(r->urb);\n\t\tkfree(r->buf);\n\t\tkfree(r);\n\t}\n}\n\nstatic struct mux_rx *get_rx_struct(struct rx_cxt *rx)\n{\n\tstruct mux_rx *r;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rx->free_list_lock, flags);\n\n\tif (list_empty(&rx->rx_free_list)) {\n\t\tspin_unlock_irqrestore(&rx->free_list_lock, flags);\n\t\treturn NULL;\n\t}\n\n\tr = list_entry(rx->rx_free_list.prev, struct mux_rx, free_list);\n\tlist_del(&r->free_list);\n\n\tspin_unlock_irqrestore(&rx->free_list_lock, flags);\n\n\treturn r;\n}\n\nstatic void put_rx_struct(struct rx_cxt *rx, struct mux_rx *r)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rx->free_list_lock, flags);\n\tlist_add_tail(&r->free_list, &rx->rx_free_list);\n\tspin_unlock_irqrestore(&rx->free_list_lock, flags);\n}\n\nstatic int up_to_host(struct mux_rx *r)\n{\n\tstruct mux_dev *mux_dev = r->mux_dev;\n\tstruct mux_pkt_header *mux_header;\n\tunsigned int start_flag;\n\tunsigned int payload_size;\n\tunsigned short packet_type;\n\tint total_len;\n\tu32 packet_size_sum = r->offset;\n\tint index;\n\tint ret = TO_HOST_INVALID_PACKET;\n\tint len = r->len;\n\n\twhile (1) {\n\t\tmux_header = (struct mux_pkt_header *)(r->buf +\n\t\t\t\t\t\t       packet_size_sum);\n\t\tstart_flag = __le32_to_cpu(mux_header->start_flag);\n\t\tpayload_size = __le32_to_cpu(mux_header->payload_size);\n\t\tpacket_type = __le16_to_cpu(mux_header->packet_type);\n\n\t\tif (start_flag != START_FLAG) {\n\t\t\tpr_err(\"invalid START_FLAG %x\\n\", start_flag);\n\t\t\tbreak;\n\t\t}\n\n\t\ttotal_len = ALIGN(MUX_HEADER_SIZE + payload_size, 4);\n\n\t\tif (len - packet_size_sum < total_len) {\n\t\t\tpr_err(\"invalid payload : %d %d %04x\\n\",\n\t\t\t       payload_size, len, packet_type);\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = packet_type_to_tty_index(packet_type);\n\t\tif (index < 0) {\n\t\t\tpr_err(\"invalid index %d\\n\", index);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = r->callback(mux_header->data,\n\t\t\t\tpayload_size,\n\t\t\t\tindex,\n\t\t\t\tmux_dev->tty_dev,\n\t\t\t\tRECV_PACKET_PROCESS_CONTINUE\n\t\t\t\t);\n\t\tif (ret == TO_HOST_BUFFER_REQUEST_FAIL) {\n\t\t\tr->offset += packet_size_sum;\n\t\t\tbreak;\n\t\t}\n\n\t\tpacket_size_sum += total_len;\n\t\tif (len - packet_size_sum <= MUX_HEADER_SIZE + 2) {\n\t\t\tret = r->callback(NULL,\n\t\t\t\t\t0,\n\t\t\t\t\tindex,\n\t\t\t\t\tmux_dev->tty_dev,\n\t\t\t\t\tRECV_PACKET_PROCESS_COMPLETE\n\t\t\t\t\t);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void do_rx(struct work_struct *work)\n{\n\tstruct mux_dev *mux_dev =\n\t\tcontainer_of(work, struct mux_dev, work_rx.work);\n\tstruct mux_rx *r;\n\tstruct rx_cxt *rx = &mux_dev->rx;\n\tunsigned long flags;\n\tint ret = 0;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(&rx->to_host_lock, flags);\n\t\tif (list_empty(&rx->to_host_list)) {\n\t\t\tspin_unlock_irqrestore(&rx->to_host_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tr = list_entry(rx->to_host_list.next, struct mux_rx,\n\t\t\t       to_host_list);\n\t\tlist_del(&r->to_host_list);\n\t\tspin_unlock_irqrestore(&rx->to_host_lock, flags);\n\n\t\tret = up_to_host(r);\n\t\tif (ret == TO_HOST_BUFFER_REQUEST_FAIL)\n\t\t\tpr_err(\"failed to send mux data to host\\n\");\n\t\telse\n\t\t\tput_rx_struct(rx, r);\n\t}\n}\n\nstatic void remove_rx_submit_list(struct mux_rx *r, struct rx_cxt *rx)\n{\n\tunsigned long flags;\n\tstruct mux_rx\t*r_remove, *r_remove_next;\n\n\tspin_lock_irqsave(&rx->submit_list_lock, flags);\n\tlist_for_each_entry_safe(r_remove, r_remove_next, &rx->rx_submit_list,\n\t\t\t\t rx_submit_list) {\n\t\tif (r == r_remove)\n\t\t\tlist_del(&r->rx_submit_list);\n\t}\n\tspin_unlock_irqrestore(&rx->submit_list_lock, flags);\n}\n\nstatic void gdm_mux_rcv_complete(struct urb *urb)\n{\n\tstruct mux_rx *r = urb->context;\n\tstruct mux_dev *mux_dev = r->mux_dev;\n\tstruct rx_cxt *rx = &mux_dev->rx;\n\tunsigned long flags;\n\n\tremove_rx_submit_list(r, rx);\n\n\tif (urb->status) {\n\t\tif (mux_dev->usb_state == PM_NORMAL)\n\t\t\tdev_err(&urb->dev->dev, \"%s: urb status error %d\\n\",\n\t\t\t\t__func__, urb->status);\n\t\tput_rx_struct(rx, r);\n\t} else {\n\t\tr->len = r->urb->actual_length;\n\t\tspin_lock_irqsave(&rx->to_host_lock, flags);\n\t\tlist_add_tail(&r->to_host_list, &rx->to_host_list);\n\t\tschedule_work(&mux_dev->work_rx.work);\n\t\tspin_unlock_irqrestore(&rx->to_host_lock, flags);\n\t}\n}\n\nstatic int gdm_mux_recv(void *priv_dev,\n\t\t\tint (*cb)(void *data, int len, int tty_index,\n\t\t\t\t  struct tty_dev *tty_dev, int complete))\n{\n\tstruct mux_dev *mux_dev = priv_dev;\n\tstruct usb_device *usbdev = mux_dev->usbdev;\n\tstruct mux_rx *r;\n\tstruct rx_cxt *rx = &mux_dev->rx;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!usbdev) {\n\t\tpr_err(\"device is disconnected\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tr = get_rx_struct(rx);\n\tif (!r) {\n\t\tpr_err(\"get_rx_struct fail\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tr->offset = 0;\n\tr->mux_dev = (void *)mux_dev;\n\tr->callback = cb;\n\tmux_dev->rx_cb = cb;\n\n\tusb_fill_bulk_urb(r->urb,\n\t\t\t  usbdev,\n\t\t\t  usb_rcvbulkpipe(usbdev, 0x86),\n\t\t\t  r->buf,\n\t\t\t  MUX_RX_MAX_SIZE,\n\t\t\t  gdm_mux_rcv_complete,\n\t\t\t  r);\n\n\tspin_lock_irqsave(&rx->submit_list_lock, flags);\n\tlist_add_tail(&r->rx_submit_list, &rx->rx_submit_list);\n\tspin_unlock_irqrestore(&rx->submit_list_lock, flags);\n\n\tret = usb_submit_urb(r->urb, GFP_KERNEL);\n\n\tif (ret) {\n\t\tspin_lock_irqsave(&rx->submit_list_lock, flags);\n\t\tlist_del(&r->rx_submit_list);\n\t\tspin_unlock_irqrestore(&rx->submit_list_lock, flags);\n\n\t\tput_rx_struct(rx, r);\n\n\t\tpr_err(\"usb_submit_urb ret=%d\\n\", ret);\n\t}\n\n\tusb_mark_last_busy(usbdev);\n\n\treturn ret;\n}\n\nstatic void gdm_mux_send_complete(struct urb *urb)\n{\n\tstruct mux_tx *t = urb->context;\n\n\tif (urb->status == -ECONNRESET) {\n\t\tdev_info(&urb->dev->dev, \"CONNRESET\\n\");\n\t\tfree_mux_tx(t);\n\t\treturn;\n\t}\n\n\tif (t->callback)\n\t\tt->callback(t->cb_data);\n\n\tfree_mux_tx(t);\n}\n\nstatic int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,\n\t\t\tvoid (*cb)(void *data), void *cb_data)\n{\n\tstruct mux_dev *mux_dev = priv_dev;\n\tstruct usb_device *usbdev = mux_dev->usbdev;\n\tstruct mux_pkt_header *mux_header;\n\tstruct mux_tx *t = NULL;\n\tstatic u32 seq_num = 1;\n\tint total_len;\n\tint ret;\n\tunsigned long flags;\n\n\tif (mux_dev->usb_state == PM_SUSPEND) {\n\t\tret = usb_autopm_get_interface(mux_dev->intf);\n\t\tif (!ret)\n\t\t\tusb_autopm_put_interface(mux_dev->intf);\n\t}\n\n\tspin_lock_irqsave(&mux_dev->write_lock, flags);\n\n\ttotal_len = ALIGN(MUX_HEADER_SIZE + len, 4);\n\n\tt = alloc_mux_tx(total_len);\n\tif (!t) {\n\t\tpr_err(\"alloc_mux_tx fail\\n\");\n\t\tspin_unlock_irqrestore(&mux_dev->write_lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\n\tmux_header = (struct mux_pkt_header *)t->buf;\n\tmux_header->start_flag = __cpu_to_le32(START_FLAG);\n\tmux_header->seq_num = __cpu_to_le32(seq_num++);\n\tmux_header->payload_size = __cpu_to_le32((u32)len);\n\tmux_header->packet_type = __cpu_to_le16(packet_type_for_tty_index[tty_index]);\n\n\tmemcpy(t->buf + MUX_HEADER_SIZE, data, len);\n\tmemset(t->buf + MUX_HEADER_SIZE + len, 0,\n\t       total_len - MUX_HEADER_SIZE - len);\n\n\tt->len = total_len;\n\tt->callback = cb;\n\tt->cb_data = cb_data;\n\n\tusb_fill_bulk_urb(t->urb,\n\t\t\t  usbdev,\n\t\t\t  usb_sndbulkpipe(usbdev, 5),\n\t\t\t  t->buf,\n\t\t\t  total_len,\n\t\t\t  gdm_mux_send_complete,\n\t\t\t  t);\n\n\tret = usb_submit_urb(t->urb, GFP_ATOMIC);\n\n\tspin_unlock_irqrestore(&mux_dev->write_lock, flags);\n\n\tif (ret)\n\t\tpr_err(\"usb_submit_urb Error: %d\\n\", ret);\n\n\tusb_mark_last_busy(usbdev);\n\n\treturn ret;\n}\n\nstatic int gdm_mux_send_control(void *priv_dev, int request, int value,\n\t\t\t\tvoid *buf, int len)\n{\n\tstruct mux_dev *mux_dev = priv_dev;\n\tstruct usb_device *usbdev = mux_dev->usbdev;\n\tint ret;\n\n\tret = usb_control_msg(usbdev,\n\t\t\t      usb_sndctrlpipe(usbdev, 0),\n\t\t\t      request,\n\t\t\t      USB_RT_ACM,\n\t\t\t      value,\n\t\t\t      2,\n\t\t\t      buf,\n\t\t\t      len,\n\t\t\t      5000\n\t\t\t     );\n\n\tif (ret < 0)\n\t\tpr_err(\"usb_control_msg error: %d\\n\", ret);\n\n\treturn min(ret, 0);\n}\n\nstatic void release_usb(struct mux_dev *mux_dev)\n{\n\tstruct rx_cxt\t\t*rx = &mux_dev->rx;\n\tstruct mux_rx\t\t*r, *r_next;\n\tunsigned long\t\tflags;\n\n\tcancel_delayed_work(&mux_dev->work_rx);\n\n\tspin_lock_irqsave(&rx->submit_list_lock, flags);\n\tlist_for_each_entry_safe(r, r_next, &rx->rx_submit_list,\n\t\t\t\t rx_submit_list) {\n\t\tspin_unlock_irqrestore(&rx->submit_list_lock, flags);\n\t\tusb_kill_urb(r->urb);\n\t\tspin_lock_irqsave(&rx->submit_list_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&rx->submit_list_lock, flags);\n\n\tspin_lock_irqsave(&rx->free_list_lock, flags);\n\tlist_for_each_entry_safe(r, r_next, &rx->rx_free_list, free_list) {\n\t\tlist_del(&r->free_list);\n\t\tfree_mux_rx(r);\n\t}\n\tspin_unlock_irqrestore(&rx->free_list_lock, flags);\n\n\tspin_lock_irqsave(&rx->to_host_lock, flags);\n\tlist_for_each_entry_safe(r, r_next, &rx->to_host_list, to_host_list) {\n\t\tif (r->mux_dev == (void *)mux_dev) {\n\t\t\tlist_del(&r->to_host_list);\n\t\t\tfree_mux_rx(r);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&rx->to_host_lock, flags);\n}\n\nstatic int init_usb(struct mux_dev *mux_dev)\n{\n\tstruct mux_rx *r;\n\tstruct rx_cxt *rx = &mux_dev->rx;\n\tint ret = 0;\n\tint i;\n\n\tspin_lock_init(&mux_dev->write_lock);\n\tINIT_LIST_HEAD(&rx->to_host_list);\n\tINIT_LIST_HEAD(&rx->rx_submit_list);\n\tINIT_LIST_HEAD(&rx->rx_free_list);\n\tspin_lock_init(&rx->to_host_lock);\n\tspin_lock_init(&rx->submit_list_lock);\n\tspin_lock_init(&rx->free_list_lock);\n\n\tfor (i = 0; i < MAX_ISSUE_NUM * 2; i++) {\n\t\tr = alloc_mux_rx();\n\t\tif (!r) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&r->free_list, &rx->rx_free_list);\n\t}\n\n\tINIT_DELAYED_WORK(&mux_dev->work_rx, do_rx);\n\n\treturn ret;\n}\n\nstatic int gdm_mux_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct mux_dev *mux_dev;\n\tstruct tty_dev *tty_dev;\n\tu16 idVendor, idProduct;\n\tint bInterfaceNumber;\n\tint ret;\n\tint i;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\n\tbInterfaceNumber = intf->cur_altsetting->desc.bInterfaceNumber;\n\n\tidVendor = __le16_to_cpu(usbdev->descriptor.idVendor);\n\tidProduct = __le16_to_cpu(usbdev->descriptor.idProduct);\n\n\tpr_info(\"mux vid = 0x%04x pid = 0x%04x\\n\", idVendor, idProduct);\n\n\tif (bInterfaceNumber != 2)\n\t\treturn -ENODEV;\n\n\tmux_dev = kzalloc(sizeof(*mux_dev), GFP_KERNEL);\n\tif (!mux_dev)\n\t\treturn -ENOMEM;\n\n\ttty_dev = kzalloc(sizeof(*tty_dev), GFP_KERNEL);\n\tif (!tty_dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_mux;\n\t}\n\n\tmux_dev->usbdev = usbdev;\n\tmux_dev->control_intf = intf;\n\n\tret = init_usb(mux_dev);\n\tif (ret)\n\t\tgoto err_free_usb;\n\n\ttty_dev->priv_dev = (void *)mux_dev;\n\ttty_dev->send_func = gdm_mux_send;\n\ttty_dev->recv_func = gdm_mux_recv;\n\ttty_dev->send_control = gdm_mux_send_control;\n\n\tret = register_lte_tty_device(tty_dev, &intf->dev);\n\tif (ret)\n\t\tgoto err_unregister_tty;\n\n\tfor (i = 0; i < TTY_MAX_COUNT; i++)\n\t\tmux_dev->tty_dev = tty_dev;\n\n\tmux_dev->intf = intf;\n\tmux_dev->usb_state = PM_NORMAL;\n\n\tusb_get_dev(usbdev);\n\tusb_set_intfdata(intf, tty_dev);\n\n\treturn 0;\n\nerr_unregister_tty:\n\tunregister_lte_tty_device(tty_dev);\nerr_free_usb:\n\trelease_usb(mux_dev);\n\tkfree(tty_dev);\nerr_free_mux:\n\tkfree(mux_dev);\n\n\treturn ret;\n}\n\nstatic void gdm_mux_disconnect(struct usb_interface *intf)\n{\n\tstruct tty_dev *tty_dev;\n\tstruct mux_dev *mux_dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\n\ttty_dev = usb_get_intfdata(intf);\n\n\tmux_dev = tty_dev->priv_dev;\n\n\trelease_usb(mux_dev);\n\tunregister_lte_tty_device(tty_dev);\n\n\tkfree(mux_dev);\n\tkfree(tty_dev);\n\n\tusb_put_dev(usbdev);\n}\n\nstatic int gdm_mux_suspend(struct usb_interface *intf, pm_message_t pm_msg)\n{\n\tstruct tty_dev *tty_dev;\n\tstruct mux_dev *mux_dev;\n\tstruct rx_cxt *rx;\n\tstruct mux_rx *r, *r_next;\n\tunsigned long flags;\n\n\ttty_dev = usb_get_intfdata(intf);\n\tmux_dev = tty_dev->priv_dev;\n\trx = &mux_dev->rx;\n\n\tcancel_work_sync(&mux_dev->work_rx.work);\n\n\tif (mux_dev->usb_state != PM_NORMAL) {\n\t\tdev_err(intf->usb_dev, \"usb suspend - invalid state\\n\");\n\t\treturn -1;\n\t}\n\n\tmux_dev->usb_state = PM_SUSPEND;\n\n\tspin_lock_irqsave(&rx->submit_list_lock, flags);\n\tlist_for_each_entry_safe(r, r_next, &rx->rx_submit_list,\n\t\t\t\t rx_submit_list) {\n\t\tspin_unlock_irqrestore(&rx->submit_list_lock, flags);\n\t\tusb_kill_urb(r->urb);\n\t\tspin_lock_irqsave(&rx->submit_list_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&rx->submit_list_lock, flags);\n\n\treturn 0;\n}\n\nstatic int gdm_mux_resume(struct usb_interface *intf)\n{\n\tstruct tty_dev *tty_dev;\n\tstruct mux_dev *mux_dev;\n\tu8 i;\n\n\ttty_dev = usb_get_intfdata(intf);\n\tmux_dev = tty_dev->priv_dev;\n\n\tif (mux_dev->usb_state != PM_SUSPEND) {\n\t\tdev_err(intf->usb_dev, \"usb resume - invalid state\\n\");\n\t\treturn -1;\n\t}\n\n\tmux_dev->usb_state = PM_NORMAL;\n\n\tfor (i = 0; i < MAX_ISSUE_NUM; i++)\n\t\tgdm_mux_recv(mux_dev, mux_dev->rx_cb);\n\n\treturn 0;\n}\n\nstatic struct usb_driver gdm_mux_driver = {\n\t.name = \"gdm_mux\",\n\t.probe = gdm_mux_probe,\n\t.disconnect = gdm_mux_disconnect,\n\t.id_table = id_table,\n\t.supports_autosuspend = 1,\n\t.suspend = gdm_mux_suspend,\n\t.resume = gdm_mux_resume,\n\t.reset_resume = gdm_mux_resume,\n};\n\nstatic int __init gdm_usb_mux_init(void)\n{\n\tint ret;\n\n\tret = register_lte_tty_driver();\n\tif (ret)\n\t\treturn ret;\n\n\treturn usb_register(&gdm_mux_driver);\n}\n\nstatic void __exit gdm_usb_mux_exit(void)\n{\n\tusb_deregister(&gdm_mux_driver);\n\tunregister_lte_tty_driver();\n}\n\nmodule_init(gdm_usb_mux_init);\nmodule_exit(gdm_usb_mux_exit);\n\nMODULE_DESCRIPTION(\"GCT LTE TTY Device Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}