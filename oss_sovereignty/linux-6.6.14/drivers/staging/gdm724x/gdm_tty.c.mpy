{
  "module_name": "gdm_tty.c",
  "hash_id": "e85aa491e62ec7c7d188b7253882c155c05ac8c38f247ace0360fb81b333ba70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/gdm724x/gdm_tty.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb/cdc.h>\n#include <linux/serial.h>\n#include \"gdm_tty.h\"\n\n#define GDM_TTY_MAJOR 0\n#define GDM_TTY_MINOR 32\n\n#define WRITE_SIZE 2048\n\n#define MUX_TX_MAX_SIZE 2048\n\nstatic inline bool gdm_tty_ready(struct gdm *gdm)\n{\n\treturn gdm && gdm->tty_dev && gdm->port.count;\n}\n\nstatic struct tty_driver *gdm_driver[TTY_MAX_COUNT];\nstatic struct gdm *gdm_table[TTY_MAX_COUNT][GDM_TTY_MINOR];\nstatic DEFINE_MUTEX(gdm_table_lock);\n\nstatic const char *DRIVER_STRING[TTY_MAX_COUNT] = {\"GCTATC\", \"GCTDM\"};\nstatic char *DEVICE_STRING[TTY_MAX_COUNT] = {\"GCT-ATC\", \"GCT-DM\"};\n\nstatic void gdm_port_destruct(struct tty_port *port)\n{\n\tstruct gdm *gdm = container_of(port, struct gdm, port);\n\n\tmutex_lock(&gdm_table_lock);\n\tgdm_table[gdm->index][gdm->minor] = NULL;\n\tmutex_unlock(&gdm_table_lock);\n\n\tkfree(gdm);\n}\n\nstatic const struct tty_port_operations gdm_port_ops = {\n\t.destruct = gdm_port_destruct,\n};\n\nstatic int gdm_tty_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct gdm *gdm = NULL;\n\tint ret;\n\n\tret = match_string(DRIVER_STRING, TTY_MAX_COUNT,\n\t\t\t   tty->driver->driver_name);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&gdm_table_lock);\n\tgdm = gdm_table[ret][tty->index];\n\tif (!gdm) {\n\t\tmutex_unlock(&gdm_table_lock);\n\t\treturn -ENODEV;\n\t}\n\n\ttty_port_get(&gdm->port);\n\n\tret = tty_standard_install(driver, tty);\n\tif (ret) {\n\t\ttty_port_put(&gdm->port);\n\t\tmutex_unlock(&gdm_table_lock);\n\t\treturn ret;\n\t}\n\n\ttty->driver_data = gdm;\n\tmutex_unlock(&gdm_table_lock);\n\n\treturn 0;\n}\n\nstatic int gdm_tty_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct gdm *gdm = tty->driver_data;\n\n\treturn tty_port_open(&gdm->port, tty, filp);\n}\n\nstatic void gdm_tty_cleanup(struct tty_struct *tty)\n{\n\tstruct gdm *gdm = tty->driver_data;\n\n\ttty_port_put(&gdm->port);\n}\n\nstatic void gdm_tty_hangup(struct tty_struct *tty)\n{\n\tstruct gdm *gdm = tty->driver_data;\n\n\ttty_port_hangup(&gdm->port);\n}\n\nstatic void gdm_tty_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct gdm *gdm = tty->driver_data;\n\n\ttty_port_close(&gdm->port, tty, filp);\n}\n\nstatic int gdm_tty_recv_complete(void *data,\n\t\t\t\t int len,\n\t\t\t\t int index,\n\t\t\t\t struct tty_dev *tty_dev,\n\t\t\t\t int complete)\n{\n\tstruct gdm *gdm = tty_dev->gdm[index];\n\n\tif (!gdm_tty_ready(gdm)) {\n\t\tif (complete == RECV_PACKET_PROCESS_COMPLETE)\n\t\t\tgdm->tty_dev->recv_func(gdm->tty_dev->priv_dev,\n\t\t\t\t\t\tgdm_tty_recv_complete);\n\t\treturn TO_HOST_PORT_CLOSE;\n\t}\n\n\tif (data && len) {\n\t\tif (tty_buffer_request_room(&gdm->port, len) == len) {\n\t\t\ttty_insert_flip_string(&gdm->port, data, len);\n\t\t\ttty_flip_buffer_push(&gdm->port);\n\t\t} else {\n\t\t\treturn TO_HOST_BUFFER_REQUEST_FAIL;\n\t\t}\n\t}\n\n\tif (complete == RECV_PACKET_PROCESS_COMPLETE)\n\t\tgdm->tty_dev->recv_func(gdm->tty_dev->priv_dev,\n\t\t\t\t\tgdm_tty_recv_complete);\n\n\treturn 0;\n}\n\nstatic void gdm_tty_send_complete(void *arg)\n{\n\tstruct gdm *gdm = arg;\n\n\tif (!gdm_tty_ready(gdm))\n\t\treturn;\n\n\ttty_port_tty_wakeup(&gdm->port);\n}\n\nstatic ssize_t gdm_tty_write(struct tty_struct *tty, const u8 *buf, size_t len)\n{\n\tstruct gdm *gdm = tty->driver_data;\n\tsize_t remain = len;\n\tsize_t sent_len = 0;\n\n\tif (!gdm_tty_ready(gdm))\n\t\treturn -ENODEV;\n\n\twhile (remain) {\n\t\tsize_t sending_len = min_t(size_t, MUX_TX_MAX_SIZE, remain);\n\t\tgdm->tty_dev->send_func(gdm->tty_dev->priv_dev,\n\t\t\t\t\t(void *)(buf + sent_len),\n\t\t\t\t\tsending_len,\n\t\t\t\t\tgdm->index,\n\t\t\t\t\tgdm_tty_send_complete,\n\t\t\t\t\tgdm);\n\t\tsent_len += sending_len;\n\t\tremain -= sending_len;\n\t}\n\n\treturn len;\n}\n\nstatic unsigned int gdm_tty_write_room(struct tty_struct *tty)\n{\n\tstruct gdm *gdm = tty->driver_data;\n\n\tif (!gdm_tty_ready(gdm))\n\t\treturn 0;\n\n\treturn WRITE_SIZE;\n}\n\nint register_lte_tty_device(struct tty_dev *tty_dev, struct device *device)\n{\n\tstruct gdm *gdm;\n\tint i;\n\tint j;\n\n\tfor (i = 0; i < TTY_MAX_COUNT; i++) {\n\t\tgdm = kmalloc(sizeof(*gdm), GFP_KERNEL);\n\t\tif (!gdm)\n\t\t\treturn -ENOMEM;\n\n\t\tmutex_lock(&gdm_table_lock);\n\t\tfor (j = 0; j < GDM_TTY_MINOR; j++) {\n\t\t\tif (!gdm_table[i][j])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j == GDM_TTY_MINOR) {\n\t\t\tkfree(gdm);\n\t\t\tmutex_unlock(&gdm_table_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgdm_table[i][j] = gdm;\n\t\tmutex_unlock(&gdm_table_lock);\n\n\t\ttty_dev->gdm[i] = gdm;\n\t\ttty_port_init(&gdm->port);\n\n\t\tgdm->port.ops = &gdm_port_ops;\n\t\tgdm->index = i;\n\t\tgdm->minor = j;\n\t\tgdm->tty_dev = tty_dev;\n\n\t\ttty_port_register_device(&gdm->port, gdm_driver[i],\n\t\t\t\t\t gdm->minor, device);\n\t}\n\n\tfor (i = 0; i < MAX_ISSUE_NUM; i++)\n\t\tgdm->tty_dev->recv_func(gdm->tty_dev->priv_dev,\n\t\t\t\t\tgdm_tty_recv_complete);\n\n\treturn 0;\n}\n\nvoid unregister_lte_tty_device(struct tty_dev *tty_dev)\n{\n\tstruct gdm *gdm;\n\tstruct tty_struct *tty;\n\tint i;\n\n\tfor (i = 0; i < TTY_MAX_COUNT; i++) {\n\t\tgdm = tty_dev->gdm[i];\n\t\tif (!gdm)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&gdm_table_lock);\n\t\tgdm_table[gdm->index][gdm->minor] = NULL;\n\t\tmutex_unlock(&gdm_table_lock);\n\n\t\ttty = tty_port_tty_get(&gdm->port);\n\t\tif (tty) {\n\t\t\ttty_vhangup(tty);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\n\t\ttty_unregister_device(gdm_driver[i], gdm->minor);\n\t\ttty_port_put(&gdm->port);\n\t}\n}\n\nstatic const struct tty_operations gdm_tty_ops = {\n\t.install =\tgdm_tty_install,\n\t.open =\t\tgdm_tty_open,\n\t.close =\tgdm_tty_close,\n\t.cleanup =\tgdm_tty_cleanup,\n\t.hangup =\tgdm_tty_hangup,\n\t.write =\tgdm_tty_write,\n\t.write_room =\tgdm_tty_write_room,\n};\n\nint register_lte_tty_driver(void)\n{\n\tstruct tty_driver *tty_driver;\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < TTY_MAX_COUNT; i++) {\n\t\ttty_driver = tty_alloc_driver(GDM_TTY_MINOR,\n\t\t\t\tTTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV);\n\t\tif (IS_ERR(tty_driver))\n\t\t\treturn PTR_ERR(tty_driver);\n\n\t\ttty_driver->owner = THIS_MODULE;\n\t\ttty_driver->driver_name = DRIVER_STRING[i];\n\t\ttty_driver->name = DEVICE_STRING[i];\n\t\ttty_driver->major = GDM_TTY_MAJOR;\n\t\ttty_driver->type = TTY_DRIVER_TYPE_SERIAL;\n\t\ttty_driver->subtype = SERIAL_TYPE_NORMAL;\n\t\ttty_driver->init_termios = tty_std_termios;\n\t\ttty_driver->init_termios.c_cflag = B9600 | CS8 | HUPCL | CLOCAL;\n\t\ttty_driver->init_termios.c_lflag = ISIG | ICANON | IEXTEN;\n\t\ttty_set_operations(tty_driver, &gdm_tty_ops);\n\n\t\tret = tty_register_driver(tty_driver);\n\t\tif (ret) {\n\t\t\ttty_driver_kref_put(tty_driver);\n\t\t\treturn ret;\n\t\t}\n\n\t\tgdm_driver[i] = tty_driver;\n\t}\n\n\treturn ret;\n}\n\nvoid unregister_lte_tty_driver(void)\n{\n\tstruct tty_driver *tty_driver;\n\tint i;\n\n\tfor (i = 0; i < TTY_MAX_COUNT; i++) {\n\t\ttty_driver = gdm_driver[i];\n\t\tif (tty_driver) {\n\t\t\ttty_unregister_driver(tty_driver);\n\t\t\ttty_driver_kref_put(tty_driver);\n\t\t}\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}