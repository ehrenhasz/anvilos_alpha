{
  "module_name": "driver_usage.txt",
  "hash_id": "3a13daea19e08b7f5b9242f75fa0bba94eeeaf4d74521e2965c68e9b84caeba1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/most/Documentation/driver_usage.txt",
  "human_readable_source": "\n\t\tSection 1 Overview\n\nThe Media Oriented Systems Transport (MOST) driver gives Linux applications\naccess a MOST network: The Automotive Information Backbone and the de-facto\nstandard for high-bandwidth automotive multimedia networking.\n\nMOST defines the protocol, hardware and software layers necessary to allow\nfor the efficient and low-cost transport of control, real-time and packet\ndata using a single medium (physical layer). Media currently in use are\nfiber optics, unshielded twisted pair cables (UTP) and coax cables. MOST\nalso supports various speed grades up to 150 Mbps.\nFor more information on MOST, visit the MOST Cooperation website:\nwww.mostcooperation.com.\n\nCars continue to evolve into sophisticated consumer electronics platforms,\nincreasing the demand for reliable and simple solutions to support audio,\nvideo and data communications. MOST can be used to connect multiple\nconsumer devices via optical or electrical physical layers directly to one\nanother or in a network configuration. As a synchronous network, MOST\nprovides excellent Quality of Service and seamless connectivity for\naudio/video streaming. Therefore, the driver perfectly fits to the mission\nof Automotive Grade Linux to create open source software solutions for\nautomotive applications.\n\nThe MOST driver uses module stacking to divide the associated modules into\nthree layers. From bottom up these layers are: the adapter layer, the core\nlayer and the application layer. The core layer implements the MOST\nsubsystem and consists basically of the module core.c and its API. It\nregisters the MOST bus with the kernel's device model, handles the data\nrouting through all three layers, the configuration of the driver, the\nrepresentation of the configuration interface in sysfs and the buffer\nmanagement.\n\nFor each of the other two layers a set of modules is provided. Those can be\narbitrarily combined with the core to meet the connectivity of the desired\nsystem architecture.\n\nA module of the adapter layer is basically a device driver for a different\nsubsystem. It is registered with the core to connect the MOST subsystem to\nthe attached network interface controller hardware. Hence, a given module\nof this layer is designed to handle exactly one of the peripheral\ninterfaces (e.g. USB, MediaLB, I2C) the hardware provides.\n\nA module of the application layer is referred to as a core component,\nwhich kind of extends the core by providing connectivity to the user space.\nApplications, then, can access a MOST network via character devices, an\nALSA soundcard, a Network adapter or a V4L2 capture device.\n\nTo physically access MOST, an Intelligent Network Interface Controller\n(INIC) is needed. For more information on available controllers visit:\nwww.microchip.com\n\n\n\n\t\tSection 1.1 Adapter Layer\n\nThe adapter layer contains a pool of device drivers. For each peripheral\ninterface the hardware supports there is one suitable module that handles\nthe interface. Adapter drivers encapsulate the peripheral interface\nspecific knowledge of the MOST driver stack and provide an easy way of\nextending the number of supported interfaces. Currently the following\ninterfaces are available:\n\n\t1) MediaLB (DIM2)\n\t   Host wants to communicate with hardware via MediaLB.\n\n\t2) I2C\n\t   Host wants to communicate with the hardware via I2C.\n\n\t3) USB\n\t   Host wants to communicate with the hardware via USB.\n\nOnce an adapter driver recognizes a MOST device being attached, it\nregisters it with the core, which, in turn, assigns the necessary members\nof the embedded struct device (e.g. the bus this device belongs to and\nattribute groups) and registers it with the kernel's device model.\n\n\n\t\tSection 1.2 Core Layer\n\nThis layer implements the MOST subsystem. It contains the core module and\nthe header file most.h that exposes the API of the core. When inserted in\nthe kernel, it registers the MOST bus_type with the kernel's device model\nand registers itself as a device driver for this bus. Besides these meta\ntasks the core populates the configuration directory for a registered MOST\ndevice (represented by struct most_interface) in sysfs and processes the\nconfiguration of the device's interface. The core layer also handles the\nbuffer management and the data/message routing.\n\n\n\t\tSection 1.3 Application Layer\n\nThis layer contains a pool of device drivers that are components of the\ncore designed to make up the userspace experience of the MOST driver stack.\nDepending on how an application is meant to interface the driver, one or\nmore modules of this pool can be registered with the core. Currently the\nfollowing components are available\n\n\t1) Character Device\n\t   Userspace can access the driver by means of character devices.\n\n\t2) Networking\n\t   Standard networking applications (e.g. iperf) can by used to access\n\t   the driver via the networking subsystem.\n\n\t3) Video4Linux (v4l2)\n\t   Standard video applications (e.g. VLC) can by used to access the\n\t   driver via the V4L subsystem.\n\n\t4) Advanced Linux Sound Architecture (ALSA)\n\t   Standard sound applications (e.g. aplay, arecord, audacity) can by\n\t   used to access the driver via the ALSA subsystem.\n\n\n\t\tSection 2 Usage of the MOST Driver\n\n\t\tSection 2.1 Configuration and Data Link\n\nThe driver is to be configured via configfs. Each loaded component kernel\nobject (see section 1.3) registers a subsystem with configfs, which is used to\nconfigure and establish communication pathways (links) to attached devices on\nthe bus. To do so, the user has to descend into the component's configuration\ndirectory and create a new directory (child config itmes). The name of this\ndirectory will be used as a reference for the link and it will contain the\nfollowing attributes:\n\n\t- buffer_size\n\t  configure the buffer size for this channel\n\t- subbuffer_size\n\t  configure the sub-buffer size for this channel (needed for\n\t  synchronous and isochrnous data)\n\t- num_buffers\n\t  configure number of buffers used for this channel\n\t- datatype\n\t  configure type of data that will travel over this channel\n\t- direction\n\t  configure whether this link will be an input or output\n\t- dbr_size\n\t  configure DBR data buffer size (this is used for MediaLB communication\n\t  only)\n\t- packets_per_xact\n\t  configure the number of packets that will be collected from the\n\t  network before being transmitted via USB (this is used for USB\n\t  communication only)\n\t- device\n\t  name of the device the link is to be attached to\n\t- channel\n\t  name of the channel the link is to be attached to\n\t- comp_params\n\t  pass parameters needed by some components\n\t- create_link\n\t  write '1' to this attribute to trigger the creation of the link. In\n\t  case of speculative configuration, the creation is post-poned until\n\t  a physical device is being attached to the bus.\n\t- destroy_link\n\t  write '1' to this attribute to destroy an already established link\n\n\nSee ABI/sysfs-bus-most.txt and ABI/configfs-most.txt\n\n\n\t\tSection 2.2 Configure a Sound Card\n\nSetting up synchronous channels to be mapped as an ALSA sound adapter is a two\nstep process. Firstly, a directory (child config group) has to be created\ninside the most_sound's configuration directory. This adapter dir will\nrepresent the sound adapter. The name of the directory is for user reference\nonly and has no further influence, as all sound adapters will be given a static\nname in ALSA. The sound adapter will have the following attribute:\n\n\t- create_card\n\t  write '1' to this attribute to trigger the registration of the card\n\t  with the ALSA subsystem.\n\t  In case of speculative configuration, the creation is post-poned\n\t  until a physical device is being attached to the bus.\n\nSecondly, links will have to be created inside the adapter dir as described in\nsection 2.1. These links will become the PCM devices of the sound card. The\nname of a PCM device will be inherited from the directory name. When all\nchannels have been configured and created, the sound card itself can be created\nby writing '1' to the create_card attribute.\n\nThe sound component needs an additional parameter to determine the audio\nresolution that is going to be used.\nThe following audio formats are available:\n\n\t- \"1x8\" (Mono)\n\t- \"2x16\" (16-bit stereo)\n\t- \"2x24\" (24-bit stereo)\n\t- \"2x32\" (32-bit stereo)\n\t- \"6x16\" (16-bit surround 5.1)\n\nThe resolution string has to be written to the link directory's comp_params\nattribute.\n\n\t\tSection 2.3 USB Padding\n\nWhen transceiving synchronous or isochronous data, the number of packets\nper USB transaction and the sub-buffer size need to be configured. These\nvalues are needed for the driver to process buffer padding, as expected by\nhardware, which is for performance optimization purposes of the USB\ntransmission.\n\nWhen transmitting synchronous data the allocated channel width needs to be\nwritten to 'subbuffer_size'. Additionally, the number of MOST frames that\nshould travel to the host within one USB transaction need to be written to\n'packets_per_xact'.\n\nThe driver, then, calculates the synchronous threshold as follows:\n\n\tframe_size = subbuffer_size * packets_per_xact\n\nIn case 'packets_per_xact' is set to 0xFF the maximum number of packets,\nallocated within one MOST frame, is calculated that fit into _one_ 512 byte\nUSB full packet.\n\n\tframe_size = floor(MTU_USB / bandwidth_sync) * bandwidth_sync\n\nThis frame_size is the number of synchronous data within an USB\ntransaction, which renders MTU_USB - frame_size bytes for padding.\n\nWhen transmitting isochronous AVP data the desired packet size needs to be\nwritten to 'subbuffer_size' and hardware will always expect two isochronous\npackets within one USB transaction. This renders\n\n\tMTU_USB - (2 * subbuffer_size)\n\nbytes for padding.\n\nNote that at least (2 * subbuffer_size) bytes for isochronous data or\n(subbuffer_size * packts_per_xact) bytes for synchronous data need to\nbe put in the transmission buffer and passed to the driver.\n\nSince adapter drivers are allowed to change a chosen configuration to best\nfit its constraints, it is recommended to always double check the\nconfiguration and read back the previously written files.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}