{
  "module_name": "hal.c",
  "hash_id": "28d44e81f673ec1bef47ef306af9b38e6233b890a0f5db97a4de3c7aa46b4037",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/most/dim2/hal.c",
  "human_readable_source": "\n \n\n \n\n#include \"hal.h\"\n#include \"errors.h\"\n#include \"reg.h\"\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n\n \n#define ISOC_DBR_FACTOR 3u\n\n \n#define DBR_MAP_SIZE 2\n\n \n \n\n#define CDT 0x00\n#define ADT 0x40\n#define MLB_CAT 0x80\n#define AHB_CAT 0x88\n\n#define DBR_SIZE  (16 * 1024)  \n#define DBR_BLOCK_SIZE  (DBR_SIZE / 32 / DBR_MAP_SIZE)\n\n#define ROUND_UP_TO(x, d)  (DIV_ROUND_UP(x, (d)) * (d))\n\n \n \n\nstatic inline u32 bit_mask(u8 position)\n{\n\treturn (u32)1 << position;\n}\n\nstatic inline bool dim_on_error(u8 error_id, const char *error_message)\n{\n\tdimcb_on_error(error_id, error_message);\n\treturn false;\n}\n\n \n \n\nstruct async_tx_dbr {\n\tu8 ch_addr;\n\tu16 rpc;\n\tu16 wpc;\n\tu16 rest_size;\n\tu16 sz_queue[CDT0_RPC_MASK + 1];\n};\n\nstruct lld_global_vars_t {\n\tbool dim_is_initialized;\n\tbool mcm_is_initialized;\n\tstruct dim2_regs __iomem *dim2;  \n\tstruct async_tx_dbr atx_dbr;\n\tu32 fcnt;\n\tu32 dbr_map[DBR_MAP_SIZE];\n};\n\nstatic struct lld_global_vars_t g = { false };\n\n \n\nstatic int dbr_get_mask_size(u16 size)\n{\n\tint i;\n\n\tfor (i = 0; i < 6; i++)\n\t\tif (size <= (DBR_BLOCK_SIZE << i))\n\t\t\treturn 1 << i;\n\treturn 0;\n}\n\n \nstatic int alloc_dbr(u16 size)\n{\n\tint mask_size;\n\tint i, block_idx = 0;\n\n\tif (size <= 0)\n\t\treturn DBR_SIZE;  \n\n\tmask_size = dbr_get_mask_size(size);\n\tif (mask_size == 0)\n\t\treturn DBR_SIZE;  \n\n\tfor (i = 0; i < DBR_MAP_SIZE; i++) {\n\t\tu32 const blocks = DIV_ROUND_UP(size, DBR_BLOCK_SIZE);\n\t\tu32 mask = ~((~(u32)0) << blocks);\n\n\t\tdo {\n\t\t\tif ((g.dbr_map[i] & mask) == 0) {\n\t\t\t\tg.dbr_map[i] |= mask;\n\t\t\t\treturn block_idx * DBR_BLOCK_SIZE;\n\t\t\t}\n\t\t\tblock_idx += mask_size;\n\t\t\t \n\t\t\tmask <<= mask_size - 1;\n\t\t} while ((mask <<= 1) != 0);\n\t}\n\n\treturn DBR_SIZE;  \n}\n\nstatic void free_dbr(int offs, int size)\n{\n\tint block_idx = offs / DBR_BLOCK_SIZE;\n\tu32 const blocks = DIV_ROUND_UP(size, DBR_BLOCK_SIZE);\n\tu32 mask = ~((~(u32)0) << blocks);\n\n\tmask <<= block_idx % 32;\n\tg.dbr_map[block_idx / 32] &= ~mask;\n}\n\n \n\nstatic void dim2_transfer_madr(u32 val)\n{\n\twritel(val, &g.dim2->MADR);\n\n\t \n\twhile ((readl(&g.dim2->MCTL) & 1) != 1)\n\t\tcontinue;\n\n\twritel(0, &g.dim2->MCTL);    \n}\n\nstatic void dim2_clear_dbr(u16 addr, u16 size)\n{\n\tenum { MADR_TB_BIT = 30, MADR_WNR_BIT = 31 };\n\n\tu16 const end_addr = addr + size;\n\tu32 const cmd = bit_mask(MADR_WNR_BIT) | bit_mask(MADR_TB_BIT);\n\n\twritel(0, &g.dim2->MCTL);    \n\twritel(0, &g.dim2->MDAT0);\n\n\tfor (; addr < end_addr; addr++)\n\t\tdim2_transfer_madr(cmd | addr);\n}\n\nstatic u32 dim2_read_ctr(u32 ctr_addr, u16 mdat_idx)\n{\n\tdim2_transfer_madr(ctr_addr);\n\n\treturn readl((&g.dim2->MDAT0) + mdat_idx);\n}\n\nstatic void dim2_write_ctr_mask(u32 ctr_addr, const u32 *mask, const u32 *value)\n{\n\tenum { MADR_WNR_BIT = 31 };\n\n\twritel(0, &g.dim2->MCTL);    \n\n\tif (mask[0] != 0)\n\t\twritel(value[0], &g.dim2->MDAT0);\n\tif (mask[1] != 0)\n\t\twritel(value[1], &g.dim2->MDAT1);\n\tif (mask[2] != 0)\n\t\twritel(value[2], &g.dim2->MDAT2);\n\tif (mask[3] != 0)\n\t\twritel(value[3], &g.dim2->MDAT3);\n\n\twritel(mask[0], &g.dim2->MDWE0);\n\twritel(mask[1], &g.dim2->MDWE1);\n\twritel(mask[2], &g.dim2->MDWE2);\n\twritel(mask[3], &g.dim2->MDWE3);\n\n\tdim2_transfer_madr(bit_mask(MADR_WNR_BIT) | ctr_addr);\n}\n\nstatic inline void dim2_write_ctr(u32 ctr_addr, const u32 *value)\n{\n\tu32 const mask[4] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };\n\n\tdim2_write_ctr_mask(ctr_addr, mask, value);\n}\n\nstatic inline void dim2_clear_ctr(u32 ctr_addr)\n{\n\tu32 const value[4] = { 0, 0, 0, 0 };\n\n\tdim2_write_ctr(ctr_addr, value);\n}\n\nstatic void dim2_configure_cat(u8 cat_base, u8 ch_addr, u8 ch_type,\n\t\t\t       bool read_not_write)\n{\n\tbool isoc_fce = ch_type == CAT_CT_VAL_ISOC;\n\tbool sync_mfe = ch_type == CAT_CT_VAL_SYNC;\n\tu16 const cat =\n\t\t(read_not_write << CAT_RNW_BIT) |\n\t\t(ch_type << CAT_CT_SHIFT) |\n\t\t(ch_addr << CAT_CL_SHIFT) |\n\t\t(isoc_fce << CAT_FCE_BIT) |\n\t\t(sync_mfe << CAT_MFE_BIT) |\n\t\t(false << CAT_MT_BIT) |\n\t\t(true << CAT_CE_BIT);\n\tu8 const ctr_addr = cat_base + ch_addr / 8;\n\tu8 const idx = (ch_addr % 8) / 2;\n\tu8 const shift = (ch_addr % 2) * 16;\n\tu32 mask[4] = { 0, 0, 0, 0 };\n\tu32 value[4] = { 0, 0, 0, 0 };\n\n\tmask[idx] = (u32)0xFFFF << shift;\n\tvalue[idx] = cat << shift;\n\tdim2_write_ctr_mask(ctr_addr, mask, value);\n}\n\nstatic void dim2_clear_cat(u8 cat_base, u8 ch_addr)\n{\n\tu8 const ctr_addr = cat_base + ch_addr / 8;\n\tu8 const idx = (ch_addr % 8) / 2;\n\tu8 const shift = (ch_addr % 2) * 16;\n\tu32 mask[4] = { 0, 0, 0, 0 };\n\tu32 value[4] = { 0, 0, 0, 0 };\n\n\tmask[idx] = (u32)0xFFFF << shift;\n\tdim2_write_ctr_mask(ctr_addr, mask, value);\n}\n\nstatic void dim2_configure_cdt(u8 ch_addr, u16 dbr_address, u16 hw_buffer_size,\n\t\t\t       u16 packet_length)\n{\n\tu32 cdt[4] = { 0, 0, 0, 0 };\n\n\tif (packet_length)\n\t\tcdt[1] = ((packet_length - 1) << CDT1_BS_ISOC_SHIFT);\n\n\tcdt[3] =\n\t\t((hw_buffer_size - 1) << CDT3_BD_SHIFT) |\n\t\t(dbr_address << CDT3_BA_SHIFT);\n\tdim2_write_ctr(CDT + ch_addr, cdt);\n}\n\nstatic u16 dim2_rpc(u8 ch_addr)\n{\n\tu32 cdt0 = dim2_read_ctr(CDT + ch_addr, 0);\n\n\treturn (cdt0 >> CDT0_RPC_SHIFT) & CDT0_RPC_MASK;\n}\n\nstatic void dim2_clear_cdt(u8 ch_addr)\n{\n\tu32 cdt[4] = { 0, 0, 0, 0 };\n\n\tdim2_write_ctr(CDT + ch_addr, cdt);\n}\n\nstatic void dim2_configure_adt(u8 ch_addr)\n{\n\tu32 adt[4] = { 0, 0, 0, 0 };\n\n\tadt[0] =\n\t\t(true << ADT0_CE_BIT) |\n\t\t(true << ADT0_LE_BIT) |\n\t\t(0 << ADT0_PG_BIT);\n\n\tdim2_write_ctr(ADT + ch_addr, adt);\n}\n\nstatic void dim2_clear_adt(u8 ch_addr)\n{\n\tu32 adt[4] = { 0, 0, 0, 0 };\n\n\tdim2_write_ctr(ADT + ch_addr, adt);\n}\n\nstatic void dim2_start_ctrl_async(u8 ch_addr, u8 idx, u32 buf_addr,\n\t\t\t\t  u16 buffer_size)\n{\n\tu8 const shift = idx * 16;\n\n\tu32 mask[4] = { 0, 0, 0, 0 };\n\tu32 adt[4] = { 0, 0, 0, 0 };\n\n\tmask[1] =\n\t\tbit_mask(ADT1_PS_BIT + shift) |\n\t\tbit_mask(ADT1_RDY_BIT + shift) |\n\t\t(ADT1_CTRL_ASYNC_BD_MASK << (ADT1_BD_SHIFT + shift));\n\tadt[1] =\n\t\t(true << (ADT1_PS_BIT + shift)) |\n\t\t(true << (ADT1_RDY_BIT + shift)) |\n\t\t((buffer_size - 1) << (ADT1_BD_SHIFT + shift));\n\n\tmask[idx + 2] = 0xFFFFFFFF;\n\tadt[idx + 2] = buf_addr;\n\n\tdim2_write_ctr_mask(ADT + ch_addr, mask, adt);\n}\n\nstatic void dim2_start_isoc_sync(u8 ch_addr, u8 idx, u32 buf_addr,\n\t\t\t\t u16 buffer_size)\n{\n\tu8 const shift = idx * 16;\n\n\tu32 mask[4] = { 0, 0, 0, 0 };\n\tu32 adt[4] = { 0, 0, 0, 0 };\n\n\tmask[1] =\n\t\tbit_mask(ADT1_RDY_BIT + shift) |\n\t\t(ADT1_ISOC_SYNC_BD_MASK << (ADT1_BD_SHIFT + shift));\n\tadt[1] =\n\t\t(true << (ADT1_RDY_BIT + shift)) |\n\t\t((buffer_size - 1) << (ADT1_BD_SHIFT + shift));\n\n\tmask[idx + 2] = 0xFFFFFFFF;\n\tadt[idx + 2] = buf_addr;\n\n\tdim2_write_ctr_mask(ADT + ch_addr, mask, adt);\n}\n\nstatic void dim2_clear_ctram(void)\n{\n\tu32 ctr_addr;\n\n\tfor (ctr_addr = 0; ctr_addr < 0x90; ctr_addr++)\n\t\tdim2_clear_ctr(ctr_addr);\n}\n\nstatic void dim2_configure_channel(u8 ch_addr, u8 type, u8 is_tx, u16 dbr_address,\n\t\t\t\t   u16 hw_buffer_size, u16 packet_length)\n{\n\tdim2_configure_cdt(ch_addr, dbr_address, hw_buffer_size, packet_length);\n\tdim2_configure_cat(MLB_CAT, ch_addr, type, is_tx ? 1 : 0);\n\n\tdim2_configure_adt(ch_addr);\n\tdim2_configure_cat(AHB_CAT, ch_addr, type, is_tx ? 0 : 1);\n\n\t \n\twritel(readl(&g.dim2->ACMR0) | bit_mask(ch_addr), &g.dim2->ACMR0);\n}\n\nstatic void dim2_clear_channel(u8 ch_addr)\n{\n\t \n\twritel(readl(&g.dim2->ACMR0) & ~bit_mask(ch_addr), &g.dim2->ACMR0);\n\n\tdim2_clear_cat(AHB_CAT, ch_addr);\n\tdim2_clear_adt(ch_addr);\n\n\tdim2_clear_cat(MLB_CAT, ch_addr);\n\tdim2_clear_cdt(ch_addr);\n\n\t \n\twritel(bit_mask(ch_addr), &g.dim2->ACSR0);\n}\n\n \n \n\nstatic inline u16 norm_pc(u16 pc)\n{\n\treturn pc & CDT0_RPC_MASK;\n}\n\nstatic void dbrcnt_init(u8 ch_addr, u16 dbr_size)\n{\n\tg.atx_dbr.rest_size = dbr_size;\n\tg.atx_dbr.rpc = dim2_rpc(ch_addr);\n\tg.atx_dbr.wpc = g.atx_dbr.rpc;\n}\n\nstatic void dbrcnt_enq(int buf_sz)\n{\n\tg.atx_dbr.rest_size -= buf_sz;\n\tg.atx_dbr.sz_queue[norm_pc(g.atx_dbr.wpc)] = buf_sz;\n\tg.atx_dbr.wpc++;\n}\n\nu16 dim_dbr_space(struct dim_channel *ch)\n{\n\tu16 cur_rpc;\n\tstruct async_tx_dbr *dbr = &g.atx_dbr;\n\n\tif (ch->addr != dbr->ch_addr)\n\t\treturn 0xFFFF;\n\n\tcur_rpc = dim2_rpc(ch->addr);\n\n\twhile (norm_pc(dbr->rpc) != cur_rpc) {\n\t\tdbr->rest_size += dbr->sz_queue[norm_pc(dbr->rpc)];\n\t\tdbr->rpc++;\n\t}\n\n\tif ((u16)(dbr->wpc - dbr->rpc) >= CDT0_RPC_MASK)\n\t\treturn 0;\n\n\treturn dbr->rest_size;\n}\n\n \n \n\nstatic void state_init(struct int_ch_state *state)\n{\n\tstate->request_counter = 0;\n\tstate->service_counter = 0;\n\n\tstate->idx1 = 0;\n\tstate->idx2 = 0;\n\tstate->level = 0;\n}\n\n \n \n\nstatic inline bool check_channel_address(u32 ch_address)\n{\n\treturn ch_address > 0 && (ch_address % 2) == 0 &&\n\t       (ch_address / 2) <= (u32)CAT_CL_MASK;\n}\n\nstatic inline bool check_packet_length(u32 packet_length)\n{\n\tu16 const max_size = ((u16)CDT3_BD_ISOC_MASK + 1u) / ISOC_DBR_FACTOR;\n\n\tif (packet_length <= 0)\n\t\treturn false;  \n\n\tif (packet_length > max_size)\n\t\treturn false;  \n\n\tif (packet_length - 1u > (u32)CDT1_BS_ISOC_MASK)\n\t\treturn false;  \n\n\treturn true;\n}\n\nstatic inline bool check_bytes_per_frame(u32 bytes_per_frame)\n{\n\tu16 const bd_factor = g.fcnt + 2;\n\tu16 const max_size = ((u16)CDT3_BD_MASK + 1u) >> bd_factor;\n\n\tif (bytes_per_frame <= 0)\n\t\treturn false;  \n\n\tif (bytes_per_frame > max_size)\n\t\treturn false;  \n\n\treturn true;\n}\n\nu16 dim_norm_ctrl_async_buffer_size(u16 buf_size)\n{\n\tu16 const max_size = (u16)ADT1_CTRL_ASYNC_BD_MASK + 1u;\n\n\tif (buf_size > max_size)\n\t\treturn max_size;\n\n\treturn buf_size;\n}\n\nstatic inline u16 norm_isoc_buffer_size(u16 buf_size, u16 packet_length)\n{\n\tu16 n;\n\tu16 const max_size = (u16)ADT1_ISOC_SYNC_BD_MASK + 1u;\n\n\tif (buf_size > max_size)\n\t\tbuf_size = max_size;\n\n\tn = buf_size / packet_length;\n\n\tif (n < 2u)\n\t\treturn 0;  \n\n\treturn packet_length * n;\n}\n\nstatic inline u16 norm_sync_buffer_size(u16 buf_size, u16 bytes_per_frame)\n{\n\tu16 n;\n\tu16 const max_size = (u16)ADT1_ISOC_SYNC_BD_MASK + 1u;\n\tu32 const unit = bytes_per_frame << g.fcnt;\n\n\tif (buf_size > max_size)\n\t\tbuf_size = max_size;\n\n\tn = buf_size / unit;\n\n\tif (n < 1u)\n\t\treturn 0;  \n\n\treturn unit * n;\n}\n\nstatic void dim2_cleanup(void)\n{\n\t \n\twritel(false << MLBC0_MLBEN_BIT, &g.dim2->MLBC0);\n\n\tdim2_clear_ctram();\n\n\t \n\twritel(0, &g.dim2->MIEN);\n\n\t \n\twritel(0xFFFFFFFF, &g.dim2->ACSR0);\n\twritel(0xFFFFFFFF, &g.dim2->ACSR1);\n\n\t \n\twritel(0, &g.dim2->ACMR0);\n\twritel(0, &g.dim2->ACMR1);\n}\n\nstatic void dim2_initialize(bool enable_6pin, u8 mlb_clock)\n{\n\tdim2_cleanup();\n\n\t \n\twritel(enable_6pin << MLBC0_MLBPEN_BIT |\n\t       mlb_clock << MLBC0_MLBCLK_SHIFT |\n\t       g.fcnt << MLBC0_FCNT_SHIFT |\n\t       true << MLBC0_MLBEN_BIT,\n\t       &g.dim2->MLBC0);\n\n\t \n\twritel(0xFFFFFFFF, &g.dim2->HCMR0);\n\twritel(0xFFFFFFFF, &g.dim2->HCMR1);\n\n\t \n\twritel(bit_mask(HCTL_EN_BIT), &g.dim2->HCTL);\n\n\t \n\twritel(ACTL_DMA_MODE_VAL_DMA_MODE_1 << ACTL_DMA_MODE_BIT |\n\t       true << ACTL_SCE_BIT, &g.dim2->ACTL);\n}\n\nstatic bool dim2_is_mlb_locked(void)\n{\n\tu32 const mask0 = bit_mask(MLBC0_MLBLK_BIT);\n\tu32 const mask1 = bit_mask(MLBC1_CLKMERR_BIT) |\n\t\t\t  bit_mask(MLBC1_LOCKERR_BIT);\n\tu32 const c1 = readl(&g.dim2->MLBC1);\n\tu32 const nda_mask = (u32)MLBC1_NDA_MASK << MLBC1_NDA_SHIFT;\n\n\twritel(c1 & nda_mask, &g.dim2->MLBC1);\n\treturn (readl(&g.dim2->MLBC1) & mask1) == 0 &&\n\t       (readl(&g.dim2->MLBC0) & mask0) != 0;\n}\n\n \n \n\nstatic inline bool service_channel(u8 ch_addr, u8 idx)\n{\n\tu8 const shift = idx * 16;\n\tu32 const adt1 = dim2_read_ctr(ADT + ch_addr, 1);\n\tu32 mask[4] = { 0, 0, 0, 0 };\n\tu32 adt_w[4] = { 0, 0, 0, 0 };\n\n\tif (((adt1 >> (ADT1_DNE_BIT + shift)) & 1) == 0)\n\t\treturn false;\n\n\tmask[1] =\n\t\tbit_mask(ADT1_DNE_BIT + shift) |\n\t\tbit_mask(ADT1_ERR_BIT + shift) |\n\t\tbit_mask(ADT1_RDY_BIT + shift);\n\tdim2_write_ctr_mask(ADT + ch_addr, mask, adt_w);\n\n\t \n\twritel(bit_mask(ch_addr), &g.dim2->ACSR0);\n\n\treturn true;\n}\n\n \n \n\nstatic void isoc_init(struct dim_channel *ch, u8 ch_addr, u16 packet_length)\n{\n\tstate_init(&ch->state);\n\n\tch->addr = ch_addr;\n\n\tch->packet_length = packet_length;\n\tch->bytes_per_frame = 0;\n\tch->done_sw_buffers_number = 0;\n}\n\nstatic void sync_init(struct dim_channel *ch, u8 ch_addr, u16 bytes_per_frame)\n{\n\tstate_init(&ch->state);\n\n\tch->addr = ch_addr;\n\n\tch->packet_length = 0;\n\tch->bytes_per_frame = bytes_per_frame;\n\tch->done_sw_buffers_number = 0;\n}\n\nstatic void channel_init(struct dim_channel *ch, u8 ch_addr)\n{\n\tstate_init(&ch->state);\n\n\tch->addr = ch_addr;\n\n\tch->packet_length = 0;\n\tch->bytes_per_frame = 0;\n\tch->done_sw_buffers_number = 0;\n}\n\n \nstatic bool channel_service_interrupt(struct dim_channel *ch)\n{\n\tstruct int_ch_state *const state = &ch->state;\n\n\tif (!service_channel(ch->addr, state->idx2))\n\t\treturn false;\n\n\tstate->idx2 ^= 1;\n\tstate->request_counter++;\n\treturn true;\n}\n\nstatic bool channel_start(struct dim_channel *ch, u32 buf_addr, u16 buf_size)\n{\n\tstruct int_ch_state *const state = &ch->state;\n\n\tif (buf_size <= 0)\n\t\treturn dim_on_error(DIM_ERR_BAD_BUFFER_SIZE, \"Bad buffer size\");\n\n\tif (ch->packet_length == 0 && ch->bytes_per_frame == 0 &&\n\t    buf_size != dim_norm_ctrl_async_buffer_size(buf_size))\n\t\treturn dim_on_error(DIM_ERR_BAD_BUFFER_SIZE,\n\t\t\t\t    \"Bad control/async buffer size\");\n\n\tif (ch->packet_length &&\n\t    buf_size != norm_isoc_buffer_size(buf_size, ch->packet_length))\n\t\treturn dim_on_error(DIM_ERR_BAD_BUFFER_SIZE,\n\t\t\t\t    \"Bad isochronous buffer size\");\n\n\tif (ch->bytes_per_frame &&\n\t    buf_size != norm_sync_buffer_size(buf_size, ch->bytes_per_frame))\n\t\treturn dim_on_error(DIM_ERR_BAD_BUFFER_SIZE,\n\t\t\t\t    \"Bad synchronous buffer size\");\n\n\tif (state->level >= 2u)\n\t\treturn dim_on_error(DIM_ERR_OVERFLOW, \"Channel overflow\");\n\n\t++state->level;\n\n\tif (ch->addr == g.atx_dbr.ch_addr)\n\t\tdbrcnt_enq(buf_size);\n\n\tif (ch->packet_length || ch->bytes_per_frame)\n\t\tdim2_start_isoc_sync(ch->addr, state->idx1, buf_addr, buf_size);\n\telse\n\t\tdim2_start_ctrl_async(ch->addr, state->idx1, buf_addr,\n\t\t\t\t      buf_size);\n\tstate->idx1 ^= 1;\n\n\treturn true;\n}\n\nstatic u8 channel_service(struct dim_channel *ch)\n{\n\tstruct int_ch_state *const state = &ch->state;\n\n\tif (state->service_counter != state->request_counter) {\n\t\tstate->service_counter++;\n\t\tif (state->level == 0)\n\t\t\treturn DIM_ERR_UNDERFLOW;\n\n\t\t--state->level;\n\t\tch->done_sw_buffers_number++;\n\t}\n\n\treturn DIM_NO_ERROR;\n}\n\nstatic bool channel_detach_buffers(struct dim_channel *ch, u16 buffers_number)\n{\n\tif (buffers_number > ch->done_sw_buffers_number)\n\t\treturn dim_on_error(DIM_ERR_UNDERFLOW, \"Channel underflow\");\n\n\tch->done_sw_buffers_number -= buffers_number;\n\treturn true;\n}\n\n \n \n\nu8 dim_startup(struct dim2_regs __iomem *dim_base_address, u32 mlb_clock,\n\t       u32 fcnt)\n{\n\tg.dim_is_initialized = false;\n\n\tif (!dim_base_address)\n\t\treturn DIM_INIT_ERR_DIM_ADDR;\n\n\t \n\t \n\tif (mlb_clock >= 8)\n\t\treturn DIM_INIT_ERR_MLB_CLOCK;\n\n\tif (fcnt > MLBC0_FCNT_MAX_VAL)\n\t\treturn DIM_INIT_ERR_MLB_CLOCK;\n\n\tg.dim2 = dim_base_address;\n\tg.fcnt = fcnt;\n\tg.dbr_map[0] = 0;\n\tg.dbr_map[1] = 0;\n\n\tdim2_initialize(mlb_clock >= 3, mlb_clock);\n\n\tg.dim_is_initialized = true;\n\n\treturn DIM_NO_ERROR;\n}\n\nvoid dim_shutdown(void)\n{\n\tg.dim_is_initialized = false;\n\tdim2_cleanup();\n}\n\nbool dim_get_lock_state(void)\n{\n\treturn dim2_is_mlb_locked();\n}\n\nstatic u8 init_ctrl_async(struct dim_channel *ch, u8 type, u8 is_tx,\n\t\t\t  u16 ch_address, u16 hw_buffer_size)\n{\n\tif (!g.dim_is_initialized || !ch)\n\t\treturn DIM_ERR_DRIVER_NOT_INITIALIZED;\n\n\tif (!check_channel_address(ch_address))\n\t\treturn DIM_INIT_ERR_CHANNEL_ADDRESS;\n\n\tif (!ch->dbr_size)\n\t\tch->dbr_size = ROUND_UP_TO(hw_buffer_size, DBR_BLOCK_SIZE);\n\tch->dbr_addr = alloc_dbr(ch->dbr_size);\n\tif (ch->dbr_addr >= DBR_SIZE)\n\t\treturn DIM_INIT_ERR_OUT_OF_MEMORY;\n\n\tchannel_init(ch, ch_address / 2);\n\n\tdim2_configure_channel(ch->addr, type, is_tx,\n\t\t\t       ch->dbr_addr, ch->dbr_size, 0);\n\n\treturn DIM_NO_ERROR;\n}\n\nvoid dim_service_mlb_int_irq(void)\n{\n\twritel(0, &g.dim2->MS0);\n\twritel(0, &g.dim2->MS1);\n}\n\n \nu16 dim_norm_isoc_buffer_size(u16 buf_size, u16 packet_length)\n{\n\tif (!check_packet_length(packet_length))\n\t\treturn 0;\n\n\treturn norm_isoc_buffer_size(buf_size, packet_length);\n}\n\n \nu16 dim_norm_sync_buffer_size(u16 buf_size, u16 bytes_per_frame)\n{\n\tif (!check_bytes_per_frame(bytes_per_frame))\n\t\treturn 0;\n\n\treturn norm_sync_buffer_size(buf_size, bytes_per_frame);\n}\n\nu8 dim_init_control(struct dim_channel *ch, u8 is_tx, u16 ch_address,\n\t\t    u16 max_buffer_size)\n{\n\treturn init_ctrl_async(ch, CAT_CT_VAL_CONTROL, is_tx, ch_address,\n\t\t\t       max_buffer_size);\n}\n\nu8 dim_init_async(struct dim_channel *ch, u8 is_tx, u16 ch_address,\n\t\t  u16 max_buffer_size)\n{\n\tu8 ret = init_ctrl_async(ch, CAT_CT_VAL_ASYNC, is_tx, ch_address,\n\t\t\t\t max_buffer_size);\n\n\tif (is_tx && !g.atx_dbr.ch_addr) {\n\t\tg.atx_dbr.ch_addr = ch->addr;\n\t\tdbrcnt_init(ch->addr, ch->dbr_size);\n\t\twritel(bit_mask(20), &g.dim2->MIEN);\n\t}\n\n\treturn ret;\n}\n\nu8 dim_init_isoc(struct dim_channel *ch, u8 is_tx, u16 ch_address,\n\t\t u16 packet_length)\n{\n\tif (!g.dim_is_initialized || !ch)\n\t\treturn DIM_ERR_DRIVER_NOT_INITIALIZED;\n\n\tif (!check_channel_address(ch_address))\n\t\treturn DIM_INIT_ERR_CHANNEL_ADDRESS;\n\n\tif (!check_packet_length(packet_length))\n\t\treturn DIM_ERR_BAD_CONFIG;\n\n\tif (!ch->dbr_size)\n\t\tch->dbr_size = packet_length * ISOC_DBR_FACTOR;\n\tch->dbr_addr = alloc_dbr(ch->dbr_size);\n\tif (ch->dbr_addr >= DBR_SIZE)\n\t\treturn DIM_INIT_ERR_OUT_OF_MEMORY;\n\n\tisoc_init(ch, ch_address / 2, packet_length);\n\n\tdim2_configure_channel(ch->addr, CAT_CT_VAL_ISOC, is_tx, ch->dbr_addr,\n\t\t\t       ch->dbr_size, packet_length);\n\n\treturn DIM_NO_ERROR;\n}\n\nu8 dim_init_sync(struct dim_channel *ch, u8 is_tx, u16 ch_address,\n\t\t u16 bytes_per_frame)\n{\n\tu16 bd_factor = g.fcnt + 2;\n\n\tif (!g.dim_is_initialized || !ch)\n\t\treturn DIM_ERR_DRIVER_NOT_INITIALIZED;\n\n\tif (!check_channel_address(ch_address))\n\t\treturn DIM_INIT_ERR_CHANNEL_ADDRESS;\n\n\tif (!check_bytes_per_frame(bytes_per_frame))\n\t\treturn DIM_ERR_BAD_CONFIG;\n\n\tif (!ch->dbr_size)\n\t\tch->dbr_size = bytes_per_frame << bd_factor;\n\tch->dbr_addr = alloc_dbr(ch->dbr_size);\n\tif (ch->dbr_addr >= DBR_SIZE)\n\t\treturn DIM_INIT_ERR_OUT_OF_MEMORY;\n\n\tsync_init(ch, ch_address / 2, bytes_per_frame);\n\n\tdim2_clear_dbr(ch->dbr_addr, ch->dbr_size);\n\tdim2_configure_channel(ch->addr, CAT_CT_VAL_SYNC, is_tx,\n\t\t\t       ch->dbr_addr, ch->dbr_size, 0);\n\n\treturn DIM_NO_ERROR;\n}\n\nu8 dim_destroy_channel(struct dim_channel *ch)\n{\n\tif (!g.dim_is_initialized || !ch)\n\t\treturn DIM_ERR_DRIVER_NOT_INITIALIZED;\n\n\tif (ch->addr == g.atx_dbr.ch_addr) {\n\t\twritel(0, &g.dim2->MIEN);\n\t\tg.atx_dbr.ch_addr = 0;\n\t}\n\n\tdim2_clear_channel(ch->addr);\n\tif (ch->dbr_addr < DBR_SIZE)\n\t\tfree_dbr(ch->dbr_addr, ch->dbr_size);\n\tch->dbr_addr = DBR_SIZE;\n\n\treturn DIM_NO_ERROR;\n}\n\nvoid dim_service_ahb_int_irq(struct dim_channel *const *channels)\n{\n\tbool state_changed;\n\n\tif (!g.dim_is_initialized) {\n\t\tdim_on_error(DIM_ERR_DRIVER_NOT_INITIALIZED,\n\t\t\t     \"DIM is not initialized\");\n\t\treturn;\n\t}\n\n\tif (!channels) {\n\t\tdim_on_error(DIM_ERR_DRIVER_NOT_INITIALIZED, \"Bad channels\");\n\t\treturn;\n\t}\n\n\t \n\tdo {\n\t\tstruct dim_channel *const *ch = channels;\n\n\t\tstate_changed = false;\n\n\t\twhile (*ch) {\n\t\t\tstate_changed |= channel_service_interrupt(*ch);\n\t\t\t++ch;\n\t\t}\n\t} while (state_changed);\n}\n\nu8 dim_service_channel(struct dim_channel *ch)\n{\n\tif (!g.dim_is_initialized || !ch)\n\t\treturn DIM_ERR_DRIVER_NOT_INITIALIZED;\n\n\treturn channel_service(ch);\n}\n\nstruct dim_ch_state *dim_get_channel_state(struct dim_channel *ch,\n\t\t\t\t\t   struct dim_ch_state *state_ptr)\n{\n\tif (!ch || !state_ptr)\n\t\treturn NULL;\n\n\tstate_ptr->ready = ch->state.level < 2;\n\tstate_ptr->done_buffers = ch->done_sw_buffers_number;\n\n\treturn state_ptr;\n}\n\nbool dim_enqueue_buffer(struct dim_channel *ch, u32 buffer_addr,\n\t\t\tu16 buffer_size)\n{\n\tif (!ch)\n\t\treturn dim_on_error(DIM_ERR_DRIVER_NOT_INITIALIZED,\n\t\t\t\t    \"Bad channel\");\n\n\treturn channel_start(ch, buffer_addr, buffer_size);\n}\n\nbool dim_detach_buffers(struct dim_channel *ch, u16 buffers_number)\n{\n\tif (!ch)\n\t\treturn dim_on_error(DIM_ERR_DRIVER_NOT_INITIALIZED,\n\t\t\t\t    \"Bad channel\");\n\n\treturn channel_detach_buffers(ch, buffers_number);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}