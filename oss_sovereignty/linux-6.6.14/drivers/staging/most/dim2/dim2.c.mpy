{
  "module_name": "dim2.c",
  "hash_id": "0c69779878e31c24dc0ec606033ddf8e30ed4eba025674391c63b34da59c8ff0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/most/dim2/dim2.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/sched.h>\n#include <linux/kthread.h>\n#include <linux/most.h>\n#include <linux/of.h>\n#include \"hal.h\"\n#include \"errors.h\"\n#include \"sysfs.h\"\n\n#define DMA_CHANNELS (32 - 1)   \n\n#define MAX_BUFFERS_PACKET      32\n#define MAX_BUFFERS_STREAMING   32\n#define MAX_BUF_SIZE_PACKET     2048\n#define MAX_BUF_SIZE_STREAMING  (8 * 1024)\n\n \nstatic u8 fcnt = 4;   \nmodule_param(fcnt, byte, 0000);\nMODULE_PARM_DESC(fcnt, \"Num of frames per sub-buffer for sync channels as a power of 2\");\n\nstatic DEFINE_SPINLOCK(dim_lock);\n\n \nstruct hdm_channel {\n\tchar name[sizeof \"caNNN\"];\n\tbool is_initialized;\n\tstruct dim_channel ch;\n\tu16 *reset_dbr_size;\n\tstruct list_head pending_list;\t \n\tstruct list_head started_list;\t \n\tenum most_channel_direction direction;\n\tenum most_channel_data_type data_type;\n};\n\n \nstruct dim2_hdm {\n\tstruct device dev;\n\tstruct hdm_channel hch[DMA_CHANNELS];\n\tstruct most_channel_capability capabilities[DMA_CHANNELS];\n\tstruct most_interface most_iface;\n\tchar name[16 + sizeof \"dim2-\"];\n\tvoid __iomem *io_base;\n\tu8 clk_speed;\n\tstruct clk *clk;\n\tstruct clk *clk_pll;\n\tstruct task_struct *netinfo_task;\n\twait_queue_head_t netinfo_waitq;\n\tint deliver_netinfo;\n\tunsigned char mac_addrs[6];\n\tunsigned char link_state;\n\tint atx_idx;\n\tstruct medialb_bus bus;\n\tvoid (*on_netinfo)(struct most_interface *most_iface,\n\t\t\t   unsigned char link_state, unsigned char *addrs);\n\tvoid (*disable_platform)(struct platform_device *pdev);\n};\n\nstruct dim2_platform_data {\n\tint (*enable)(struct platform_device *pdev);\n\tvoid (*disable)(struct platform_device *pdev);\n\tu8 fcnt;\n};\n\nstatic inline struct dim2_hdm *iface_to_hdm(struct most_interface *iface)\n{\n\treturn container_of(iface, struct dim2_hdm, most_iface);\n}\n\n \n#define PACKET_IS_NET_INFO(p)  \\\n\t(((p)[1] == 0x18) && ((p)[2] == 0x05) && ((p)[3] == 0x0C) && \\\n\t ((p)[13] == 0x3C) && ((p)[14] == 0x00) && ((p)[15] == 0x0A))\n\nstatic ssize_t state_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tbool state;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dim_lock, flags);\n\tstate = dim_get_lock_state();\n\tspin_unlock_irqrestore(&dim_lock, flags);\n\n\treturn sysfs_emit(buf, \"%s\\n\", state ? \"locked\" : \"\");\n}\n\nstatic DEVICE_ATTR_RO(state);\n\nstatic struct attribute *dim2_attrs[] = {\n\t&dev_attr_state.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(dim2);\n\n \nvoid dimcb_on_error(u8 error_id, const char *error_message)\n{\n\tpr_err(\"%s: error_id - %d, error_message - %s\\n\", __func__, error_id,\n\t       error_message);\n}\n\n \nstatic int try_start_dim_transfer(struct hdm_channel *hdm_ch)\n{\n\tu16 buf_size;\n\tstruct list_head *head = &hdm_ch->pending_list;\n\tstruct mbo *mbo;\n\tunsigned long flags;\n\tstruct dim_ch_state st;\n\n\tBUG_ON(!hdm_ch);\n\tBUG_ON(!hdm_ch->is_initialized);\n\n\tspin_lock_irqsave(&dim_lock, flags);\n\tif (list_empty(head)) {\n\t\tspin_unlock_irqrestore(&dim_lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!dim_get_channel_state(&hdm_ch->ch, &st)->ready) {\n\t\tspin_unlock_irqrestore(&dim_lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\n\tmbo = list_first_entry(head, struct mbo, list);\n\tbuf_size = mbo->buffer_length;\n\n\tif (dim_dbr_space(&hdm_ch->ch) < buf_size) {\n\t\tspin_unlock_irqrestore(&dim_lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\n\tBUG_ON(mbo->bus_address == 0);\n\tif (!dim_enqueue_buffer(&hdm_ch->ch, mbo->bus_address, buf_size)) {\n\t\tlist_del(head->next);\n\t\tspin_unlock_irqrestore(&dim_lock, flags);\n\t\tmbo->processed_length = 0;\n\t\tmbo->status = MBO_E_INVAL;\n\t\tmbo->complete(mbo);\n\t\treturn -EFAULT;\n\t}\n\n\tlist_move_tail(head->next, &hdm_ch->started_list);\n\tspin_unlock_irqrestore(&dim_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int deliver_netinfo_thread(void *data)\n{\n\tstruct dim2_hdm *dev = data;\n\n\twhile (!kthread_should_stop()) {\n\t\twait_event_interruptible(dev->netinfo_waitq,\n\t\t\t\t\t dev->deliver_netinfo ||\n\t\t\t\t\t kthread_should_stop());\n\n\t\tif (dev->deliver_netinfo) {\n\t\t\tdev->deliver_netinfo--;\n\t\t\tif (dev->on_netinfo) {\n\t\t\t\tdev->on_netinfo(&dev->most_iface,\n\t\t\t\t\t\tdev->link_state,\n\t\t\t\t\t\tdev->mac_addrs);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void retrieve_netinfo(struct dim2_hdm *dev, struct mbo *mbo)\n{\n\tu8 *data = mbo->virt_address;\n\n\tpr_info(\"Node Address: 0x%03x\\n\", (u16)data[16] << 8 | data[17]);\n\tdev->link_state = data[18];\n\tpr_info(\"NIState: %d\\n\", dev->link_state);\n\tmemcpy(dev->mac_addrs, data + 19, 6);\n\tdev->deliver_netinfo++;\n\twake_up_interruptible(&dev->netinfo_waitq);\n}\n\n \nstatic void service_done_flag(struct dim2_hdm *dev, int ch_idx)\n{\n\tstruct hdm_channel *hdm_ch = dev->hch + ch_idx;\n\tstruct dim_ch_state st;\n\tstruct list_head *head;\n\tstruct mbo *mbo;\n\tint done_buffers;\n\tunsigned long flags;\n\tu8 *data;\n\n\tBUG_ON(!hdm_ch);\n\tBUG_ON(!hdm_ch->is_initialized);\n\n\tspin_lock_irqsave(&dim_lock, flags);\n\n\tdone_buffers = dim_get_channel_state(&hdm_ch->ch, &st)->done_buffers;\n\tif (!done_buffers) {\n\t\tspin_unlock_irqrestore(&dim_lock, flags);\n\t\treturn;\n\t}\n\n\tif (!dim_detach_buffers(&hdm_ch->ch, done_buffers)) {\n\t\tspin_unlock_irqrestore(&dim_lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&dim_lock, flags);\n\n\thead = &hdm_ch->started_list;\n\n\twhile (done_buffers) {\n\t\tspin_lock_irqsave(&dim_lock, flags);\n\t\tif (list_empty(head)) {\n\t\t\tspin_unlock_irqrestore(&dim_lock, flags);\n\t\t\tpr_crit(\"hard error: started_mbo list is empty whereas DIM2 has sent buffers\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmbo = list_first_entry(head, struct mbo, list);\n\t\tlist_del(head->next);\n\t\tspin_unlock_irqrestore(&dim_lock, flags);\n\n\t\tdata = mbo->virt_address;\n\n\t\tif (hdm_ch->data_type == MOST_CH_ASYNC &&\n\t\t    hdm_ch->direction == MOST_CH_RX &&\n\t\t    PACKET_IS_NET_INFO(data)) {\n\t\t\tretrieve_netinfo(dev, mbo);\n\n\t\t\tspin_lock_irqsave(&dim_lock, flags);\n\t\t\tlist_add_tail(&mbo->list, &hdm_ch->pending_list);\n\t\t\tspin_unlock_irqrestore(&dim_lock, flags);\n\t\t} else {\n\t\t\tif (hdm_ch->data_type == MOST_CH_CONTROL ||\n\t\t\t    hdm_ch->data_type == MOST_CH_ASYNC) {\n\t\t\t\tu32 const data_size =\n\t\t\t\t\t(u32)data[0] * 256 + data[1] + 2;\n\n\t\t\t\tmbo->processed_length =\n\t\t\t\t\tmin_t(u32, data_size,\n\t\t\t\t\t      mbo->buffer_length);\n\t\t\t} else {\n\t\t\t\tmbo->processed_length = mbo->buffer_length;\n\t\t\t}\n\t\t\tmbo->status = MBO_SUCCESS;\n\t\t\tmbo->complete(mbo);\n\t\t}\n\n\t\tdone_buffers--;\n\t}\n}\n\nstatic struct dim_channel **get_active_channels(struct dim2_hdm *dev,\n\t\t\t\t\t\tstruct dim_channel **buffer)\n{\n\tint idx = 0;\n\tint ch_idx;\n\n\tfor (ch_idx = 0; ch_idx < DMA_CHANNELS; ch_idx++) {\n\t\tif (dev->hch[ch_idx].is_initialized)\n\t\t\tbuffer[idx++] = &dev->hch[ch_idx].ch;\n\t}\n\tbuffer[idx++] = NULL;\n\n\treturn buffer;\n}\n\nstatic irqreturn_t dim2_mlb_isr(int irq, void *_dev)\n{\n\tstruct dim2_hdm *dev = _dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dim_lock, flags);\n\tdim_service_mlb_int_irq();\n\tspin_unlock_irqrestore(&dim_lock, flags);\n\n\tif (dev->atx_idx >= 0 && dev->hch[dev->atx_idx].is_initialized)\n\t\twhile (!try_start_dim_transfer(dev->hch + dev->atx_idx))\n\t\t\tcontinue;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t dim2_task_irq(int irq, void *_dev)\n{\n\tstruct dim2_hdm *dev = _dev;\n\tunsigned long flags;\n\tint ch_idx;\n\n\tfor (ch_idx = 0; ch_idx < DMA_CHANNELS; ch_idx++) {\n\t\tif (!dev->hch[ch_idx].is_initialized)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&dim_lock, flags);\n\t\tdim_service_channel(&dev->hch[ch_idx].ch);\n\t\tspin_unlock_irqrestore(&dim_lock, flags);\n\n\t\tservice_done_flag(dev, ch_idx);\n\t\twhile (!try_start_dim_transfer(dev->hch + ch_idx))\n\t\t\tcontinue;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t dim2_ahb_isr(int irq, void *_dev)\n{\n\tstruct dim2_hdm *dev = _dev;\n\tstruct dim_channel *buffer[DMA_CHANNELS + 1];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dim_lock, flags);\n\tdim_service_ahb_int_irq(get_active_channels(dev, buffer));\n\tspin_unlock_irqrestore(&dim_lock, flags);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n \nstatic void complete_all_mbos(struct list_head *head)\n{\n\tunsigned long flags;\n\tstruct mbo *mbo;\n\n\tfor (;;) {\n\t\tspin_lock_irqsave(&dim_lock, flags);\n\t\tif (list_empty(head)) {\n\t\t\tspin_unlock_irqrestore(&dim_lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tmbo = list_first_entry(head, struct mbo, list);\n\t\tlist_del(head->next);\n\t\tspin_unlock_irqrestore(&dim_lock, flags);\n\n\t\tmbo->processed_length = 0;\n\t\tmbo->status = MBO_E_CLOSE;\n\t\tmbo->complete(mbo);\n\t}\n}\n\n \nstatic int configure_channel(struct most_interface *most_iface, int ch_idx,\n\t\t\t     struct most_channel_config *ccfg)\n{\n\tstruct dim2_hdm *dev = iface_to_hdm(most_iface);\n\tbool const is_tx = ccfg->direction == MOST_CH_TX;\n\tu16 const sub_size = ccfg->subbuffer_size;\n\tu16 const buf_size = ccfg->buffer_size;\n\tu16 new_size;\n\tunsigned long flags;\n\tu8 hal_ret;\n\tint const ch_addr = ch_idx * 2 + 2;\n\tstruct hdm_channel *const hdm_ch = dev->hch + ch_idx;\n\n\tBUG_ON(ch_idx < 0 || ch_idx >= DMA_CHANNELS);\n\n\tif (hdm_ch->is_initialized)\n\t\treturn -EPERM;\n\n\t \n\thdm_ch->reset_dbr_size = ccfg->dbr_size ? NULL : &ccfg->dbr_size;\n\n\t \n\thdm_ch->ch.dbr_size = ccfg->dbr_size;\n\n\tswitch (ccfg->data_type) {\n\tcase MOST_CH_CONTROL:\n\t\tnew_size = dim_norm_ctrl_async_buffer_size(buf_size);\n\t\tif (new_size == 0) {\n\t\t\tpr_err(\"%s: too small buffer size\\n\", hdm_ch->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tccfg->buffer_size = new_size;\n\t\tif (new_size != buf_size)\n\t\t\tpr_warn(\"%s: fixed buffer size (%d -> %d)\\n\",\n\t\t\t\thdm_ch->name, buf_size, new_size);\n\t\tspin_lock_irqsave(&dim_lock, flags);\n\t\thal_ret = dim_init_control(&hdm_ch->ch, is_tx, ch_addr,\n\t\t\t\t\t   is_tx ? new_size * 2 : new_size);\n\t\tbreak;\n\tcase MOST_CH_ASYNC:\n\t\tnew_size = dim_norm_ctrl_async_buffer_size(buf_size);\n\t\tif (new_size == 0) {\n\t\t\tpr_err(\"%s: too small buffer size\\n\", hdm_ch->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tccfg->buffer_size = new_size;\n\t\tif (new_size != buf_size)\n\t\t\tpr_warn(\"%s: fixed buffer size (%d -> %d)\\n\",\n\t\t\t\thdm_ch->name, buf_size, new_size);\n\t\tspin_lock_irqsave(&dim_lock, flags);\n\t\thal_ret = dim_init_async(&hdm_ch->ch, is_tx, ch_addr,\n\t\t\t\t\t is_tx ? new_size * 2 : new_size);\n\t\tbreak;\n\tcase MOST_CH_ISOC:\n\t\tnew_size = dim_norm_isoc_buffer_size(buf_size, sub_size);\n\t\tif (new_size == 0) {\n\t\t\tpr_err(\"%s: invalid sub-buffer size or too small buffer size\\n\",\n\t\t\t       hdm_ch->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tccfg->buffer_size = new_size;\n\t\tif (new_size != buf_size)\n\t\t\tpr_warn(\"%s: fixed buffer size (%d -> %d)\\n\",\n\t\t\t\thdm_ch->name, buf_size, new_size);\n\t\tspin_lock_irqsave(&dim_lock, flags);\n\t\thal_ret = dim_init_isoc(&hdm_ch->ch, is_tx, ch_addr, sub_size);\n\t\tbreak;\n\tcase MOST_CH_SYNC:\n\t\tnew_size = dim_norm_sync_buffer_size(buf_size, sub_size);\n\t\tif (new_size == 0) {\n\t\t\tpr_err(\"%s: invalid sub-buffer size or too small buffer size\\n\",\n\t\t\t       hdm_ch->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tccfg->buffer_size = new_size;\n\t\tif (new_size != buf_size)\n\t\t\tpr_warn(\"%s: fixed buffer size (%d -> %d)\\n\",\n\t\t\t\thdm_ch->name, buf_size, new_size);\n\t\tspin_lock_irqsave(&dim_lock, flags);\n\t\thal_ret = dim_init_sync(&hdm_ch->ch, is_tx, ch_addr, sub_size);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: configure failed, bad channel type: %d\\n\",\n\t\t       hdm_ch->name, ccfg->data_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hal_ret != DIM_NO_ERROR) {\n\t\tspin_unlock_irqrestore(&dim_lock, flags);\n\t\tpr_err(\"%s: configure failed (%d), type: %d, is_tx: %d\\n\",\n\t\t       hdm_ch->name, hal_ret, ccfg->data_type, (int)is_tx);\n\t\treturn -ENODEV;\n\t}\n\n\thdm_ch->data_type = ccfg->data_type;\n\thdm_ch->direction = ccfg->direction;\n\thdm_ch->is_initialized = true;\n\n\tif (hdm_ch->data_type == MOST_CH_ASYNC &&\n\t    hdm_ch->direction == MOST_CH_TX &&\n\t    dev->atx_idx < 0)\n\t\tdev->atx_idx = ch_idx;\n\n\tspin_unlock_irqrestore(&dim_lock, flags);\n\tccfg->dbr_size = hdm_ch->ch.dbr_size;\n\n\treturn 0;\n}\n\n \nstatic int enqueue(struct most_interface *most_iface, int ch_idx,\n\t\t   struct mbo *mbo)\n{\n\tstruct dim2_hdm *dev = iface_to_hdm(most_iface);\n\tstruct hdm_channel *hdm_ch = dev->hch + ch_idx;\n\tunsigned long flags;\n\n\tBUG_ON(ch_idx < 0 || ch_idx >= DMA_CHANNELS);\n\n\tif (!hdm_ch->is_initialized)\n\t\treturn -EPERM;\n\n\tif (mbo->bus_address == 0)\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&dim_lock, flags);\n\tlist_add_tail(&mbo->list, &hdm_ch->pending_list);\n\tspin_unlock_irqrestore(&dim_lock, flags);\n\n\t(void)try_start_dim_transfer(hdm_ch);\n\n\treturn 0;\n}\n\n \nstatic void request_netinfo(struct most_interface *most_iface, int ch_idx,\n\t\t\t    void (*on_netinfo)(struct most_interface *,\n\t\t\t\t\t       unsigned char, unsigned char *))\n{\n\tstruct dim2_hdm *dev = iface_to_hdm(most_iface);\n\tstruct mbo *mbo;\n\tu8 *data;\n\n\tdev->on_netinfo = on_netinfo;\n\tif (!on_netinfo)\n\t\treturn;\n\n\tif (dev->atx_idx < 0) {\n\t\tpr_err(\"Async Tx Not initialized\\n\");\n\t\treturn;\n\t}\n\n\tmbo = most_get_mbo(&dev->most_iface, dev->atx_idx, NULL);\n\tif (!mbo)\n\t\treturn;\n\n\tmbo->buffer_length = 5;\n\n\tdata = mbo->virt_address;\n\n\tdata[0] = 0x00;  \n\tdata[1] = 0x03;  \n\tdata[2] = 0x02;  \n\tdata[3] = 0x08;  \n\tdata[4] = 0x40;  \n\n\tmost_submit_mbo(mbo);\n}\n\n \nstatic int poison_channel(struct most_interface *most_iface, int ch_idx)\n{\n\tstruct dim2_hdm *dev = iface_to_hdm(most_iface);\n\tstruct hdm_channel *hdm_ch = dev->hch + ch_idx;\n\tunsigned long flags;\n\tu8 hal_ret;\n\tint ret = 0;\n\n\tBUG_ON(ch_idx < 0 || ch_idx >= DMA_CHANNELS);\n\n\tif (!hdm_ch->is_initialized)\n\t\treturn -EPERM;\n\n\tspin_lock_irqsave(&dim_lock, flags);\n\thal_ret = dim_destroy_channel(&hdm_ch->ch);\n\thdm_ch->is_initialized = false;\n\tif (ch_idx == dev->atx_idx)\n\t\tdev->atx_idx = -1;\n\tspin_unlock_irqrestore(&dim_lock, flags);\n\tif (hal_ret != DIM_NO_ERROR) {\n\t\tpr_err(\"HAL Failed to close channel %s\\n\", hdm_ch->name);\n\t\tret = -EFAULT;\n\t}\n\n\tcomplete_all_mbos(&hdm_ch->started_list);\n\tcomplete_all_mbos(&hdm_ch->pending_list);\n\tif (hdm_ch->reset_dbr_size)\n\t\t*hdm_ch->reset_dbr_size = 0;\n\n\treturn ret;\n}\n\nstatic void *dma_alloc(struct mbo *mbo, u32 size)\n{\n\tstruct device *dev = mbo->ifp->driver_dev;\n\n\treturn dma_alloc_coherent(dev, size, &mbo->bus_address, GFP_KERNEL);\n}\n\nstatic void dma_free(struct mbo *mbo, u32 size)\n{\n\tstruct device *dev = mbo->ifp->driver_dev;\n\n\tdma_free_coherent(dev, size, mbo->virt_address, mbo->bus_address);\n}\n\nstatic const struct of_device_id dim2_of_match[];\n\nstatic struct {\n\tconst char *clock_speed;\n\tu8 clk_speed;\n} clk_mt[] = {\n\t{ \"256fs\", CLK_256FS },\n\t{ \"512fs\", CLK_512FS },\n\t{ \"1024fs\", CLK_1024FS },\n\t{ \"2048fs\", CLK_2048FS },\n\t{ \"3072fs\", CLK_3072FS },\n\t{ \"4096fs\", CLK_4096FS },\n\t{ \"6144fs\", CLK_6144FS },\n\t{ \"8192fs\", CLK_8192FS },\n};\n\n \nstatic int get_dim2_clk_speed(const char *clock_speed, u8 *val)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(clk_mt); i++) {\n\t\tif (!strcmp(clock_speed, clk_mt[i].clock_speed)) {\n\t\t\t*val = clk_mt[i].clk_speed;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic void dim2_release(struct device *d)\n{\n\tstruct dim2_hdm *dev = container_of(d, struct dim2_hdm, dev);\n\tunsigned long flags;\n\n\tkthread_stop(dev->netinfo_task);\n\n\tspin_lock_irqsave(&dim_lock, flags);\n\tdim_shutdown();\n\tspin_unlock_irqrestore(&dim_lock, flags);\n\n\tif (dev->disable_platform)\n\t\tdev->disable_platform(to_platform_device(d->parent));\n\n\tkfree(dev);\n}\n\n \nstatic int dim2_probe(struct platform_device *pdev)\n{\n\tconst struct dim2_platform_data *pdata;\n\tconst struct of_device_id *of_id;\n\tconst char *clock_speed;\n\tstruct dim2_hdm *dev;\n\tstruct resource *res;\n\tint ret, i;\n\tu8 hal_ret;\n\tu8 dev_fcnt = fcnt;\n\tint irq;\n\n\tenum { MLB_INT_IDX, AHB0_INT_IDX };\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->atx_idx = -1;\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tret = of_property_read_string(pdev->dev.of_node,\n\t\t\t\t      \"microchip,clock-speed\", &clock_speed);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"missing dt property clock-speed\\n\");\n\t\tgoto err_free_dev;\n\t}\n\n\tret = get_dim2_clk_speed(clock_speed, &dev->clk_speed);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"bad dt property clock-speed\\n\");\n\t\tgoto err_free_dev;\n\t}\n\n\tdev->io_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(dev->io_base)) {\n\t\tret = PTR_ERR(dev->io_base);\n\t\tgoto err_free_dev;\n\t}\n\n\tof_id = of_match_node(dim2_of_match, pdev->dev.of_node);\n\tpdata = of_id->data;\n\tif (pdata) {\n\t\tif (pdata->enable) {\n\t\t\tret = pdata->enable(pdev);\n\t\t\tif (ret)\n\t\t\t\tgoto err_free_dev;\n\t\t}\n\t\tdev->disable_platform = pdata->disable;\n\t\tif (pdata->fcnt)\n\t\t\tdev_fcnt = pdata->fcnt;\n\t}\n\n\tdev_info(&pdev->dev, \"sync: num of frames per sub-buffer: %u\\n\",\n\t\t dev_fcnt);\n\thal_ret = dim_startup(dev->io_base, dev->clk_speed, dev_fcnt);\n\tif (hal_ret != DIM_NO_ERROR) {\n\t\tdev_err(&pdev->dev, \"dim_startup failed: %d\\n\", hal_ret);\n\t\tret = -ENODEV;\n\t\tgoto err_disable_platform;\n\t}\n\n\tirq = platform_get_irq(pdev, AHB0_INT_IDX);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err_shutdown_dim;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq, dim2_ahb_isr,\n\t\t\t\t\tdim2_task_irq, 0, \"dim2_ahb0_int\", dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request ahb0_int irq %d\\n\", irq);\n\t\tgoto err_shutdown_dim;\n\t}\n\n\tirq = platform_get_irq(pdev, MLB_INT_IDX);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err_shutdown_dim;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, dim2_mlb_isr, 0,\n\t\t\t       \"dim2_mlb_int\", dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request mlb_int irq %d\\n\", irq);\n\t\tgoto err_shutdown_dim;\n\t}\n\n\tinit_waitqueue_head(&dev->netinfo_waitq);\n\tdev->deliver_netinfo = 0;\n\tdev->netinfo_task = kthread_run(&deliver_netinfo_thread, dev,\n\t\t\t\t\t\"dim2_netinfo\");\n\tif (IS_ERR(dev->netinfo_task)) {\n\t\tret = PTR_ERR(dev->netinfo_task);\n\t\tgoto err_shutdown_dim;\n\t}\n\n\tfor (i = 0; i < DMA_CHANNELS; i++) {\n\t\tstruct most_channel_capability *cap = dev->capabilities + i;\n\t\tstruct hdm_channel *hdm_ch = dev->hch + i;\n\n\t\tINIT_LIST_HEAD(&hdm_ch->pending_list);\n\t\tINIT_LIST_HEAD(&hdm_ch->started_list);\n\t\thdm_ch->is_initialized = false;\n\t\tsnprintf(hdm_ch->name, sizeof(hdm_ch->name), \"ca%d\", i * 2 + 2);\n\n\t\tcap->name_suffix = hdm_ch->name;\n\t\tcap->direction = MOST_CH_RX | MOST_CH_TX;\n\t\tcap->data_type = MOST_CH_CONTROL | MOST_CH_ASYNC |\n\t\t\t\t MOST_CH_ISOC | MOST_CH_SYNC;\n\t\tcap->num_buffers_packet = MAX_BUFFERS_PACKET;\n\t\tcap->buffer_size_packet = MAX_BUF_SIZE_PACKET;\n\t\tcap->num_buffers_streaming = MAX_BUFFERS_STREAMING;\n\t\tcap->buffer_size_streaming = MAX_BUF_SIZE_STREAMING;\n\t}\n\n\t{\n\t\tconst char *fmt;\n\n\t\tif (sizeof(res->start) == sizeof(long long))\n\t\t\tfmt = \"dim2-%016llx\";\n\t\telse if (sizeof(res->start) == sizeof(long))\n\t\t\tfmt = \"dim2-%016lx\";\n\t\telse\n\t\t\tfmt = \"dim2-%016x\";\n\n\t\tsnprintf(dev->name, sizeof(dev->name), fmt, res->start);\n\t}\n\n\tdev->most_iface.interface = ITYPE_MEDIALB_DIM2;\n\tdev->most_iface.description = dev->name;\n\tdev->most_iface.num_channels = DMA_CHANNELS;\n\tdev->most_iface.channel_vector = dev->capabilities;\n\tdev->most_iface.configure = configure_channel;\n\tdev->most_iface.enqueue = enqueue;\n\tdev->most_iface.dma_alloc = dma_alloc;\n\tdev->most_iface.dma_free = dma_free;\n\tdev->most_iface.poison_channel = poison_channel;\n\tdev->most_iface.request_netinfo = request_netinfo;\n\tdev->most_iface.driver_dev = &pdev->dev;\n\tdev->most_iface.dev = &dev->dev;\n\tdev->dev.init_name = dev->name;\n\tdev->dev.parent = &pdev->dev;\n\tdev->dev.release = dim2_release;\n\n\treturn most_register_interface(&dev->most_iface);\n\nerr_shutdown_dim:\n\tdim_shutdown();\nerr_disable_platform:\n\tif (dev->disable_platform)\n\t\tdev->disable_platform(pdev);\nerr_free_dev:\n\tkfree(dev);\n\n\treturn ret;\n}\n\n \nstatic void dim2_remove(struct platform_device *pdev)\n{\n\tstruct dim2_hdm *dev = platform_get_drvdata(pdev);\n\n\tmost_deregister_interface(&dev->most_iface);\n}\n\n \n\nstatic int fsl_mx6_enable(struct platform_device *pdev)\n{\n\tstruct dim2_hdm *dev = platform_get_drvdata(pdev);\n\tint ret;\n\n\tdev->clk = devm_clk_get(&pdev->dev, \"mlb\");\n\tif (IS_ERR_OR_NULL(dev->clk)) {\n\t\tdev_err(&pdev->dev, \"unable to get mlb clock\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tret = clk_prepare_enable(dev->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s\\n\", \"clk_prepare_enable failed\");\n\t\treturn ret;\n\t}\n\n\tif (dev->clk_speed >= CLK_2048FS) {\n\t\t \n\t\tdev->clk_pll = devm_clk_get(&pdev->dev, \"pll8_mlb\");\n\t\tif (IS_ERR_OR_NULL(dev->clk_pll)) {\n\t\t\tdev_err(&pdev->dev, \"unable to get mlb pll clock\\n\");\n\t\t\tclk_disable_unprepare(dev->clk);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\twritel(0x888, dev->io_base + 0x38);\n\t\tclk_prepare_enable(dev->clk_pll);\n\t}\n\n\treturn 0;\n}\n\nstatic void fsl_mx6_disable(struct platform_device *pdev)\n{\n\tstruct dim2_hdm *dev = platform_get_drvdata(pdev);\n\n\tif (dev->clk_speed >= CLK_2048FS)\n\t\tclk_disable_unprepare(dev->clk_pll);\n\n\tclk_disable_unprepare(dev->clk);\n}\n\nstatic int rcar_gen2_enable(struct platform_device *pdev)\n{\n\tstruct dim2_hdm *dev = platform_get_drvdata(pdev);\n\tint ret;\n\n\tdev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dev->clk)) {\n\t\tdev_err(&pdev->dev, \"cannot get clock\\n\");\n\t\treturn PTR_ERR(dev->clk);\n\t}\n\n\tret = clk_prepare_enable(dev->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s\\n\", \"clk_prepare_enable failed\");\n\t\treturn ret;\n\t}\n\n\tif (dev->clk_speed >= CLK_2048FS) {\n\t\t \n\t\twritel(0x03, dev->io_base + 0x600);\n\t\t \n\t\twritel(0x888, dev->io_base + 0x38);\n\t} else {\n\t\t \n\t\twritel(0x04, dev->io_base + 0x600);\n\t}\n\n\t \n\twritel(0x03, dev->io_base + 0x500);\n\twritel(0x0002FF02, dev->io_base + 0x508);\n\n\treturn 0;\n}\n\nstatic void rcar_gen2_disable(struct platform_device *pdev)\n{\n\tstruct dim2_hdm *dev = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(dev->clk);\n\n\t \n\twritel(0x0, dev->io_base + 0x600);\n}\n\nstatic int rcar_gen3_enable(struct platform_device *pdev)\n{\n\tstruct dim2_hdm *dev = platform_get_drvdata(pdev);\n\tu32 enable_512fs = dev->clk_speed == CLK_512FS;\n\tint ret;\n\n\tdev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dev->clk)) {\n\t\tdev_err(&pdev->dev, \"cannot get clock\\n\");\n\t\treturn PTR_ERR(dev->clk);\n\t}\n\n\tret = clk_prepare_enable(dev->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s\\n\", \"clk_prepare_enable failed\");\n\t\treturn ret;\n\t}\n\n\t \n\twritel(0x04, dev->io_base + 0x600);\n\n\twritel(enable_512fs, dev->io_base + 0x604);\n\n\t \n\twritel(0x03, dev->io_base + 0x500);\n\twritel(0x0002FF02, dev->io_base + 0x508);\n\n\treturn 0;\n}\n\nstatic void rcar_gen3_disable(struct platform_device *pdev)\n{\n\tstruct dim2_hdm *dev = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(dev->clk);\n\n\t \n\twritel(0x0, dev->io_base + 0x600);\n}\n\n \n\nenum dim2_platforms { FSL_MX6, RCAR_GEN2, RCAR_GEN3 };\n\nstatic struct dim2_platform_data plat_data[] = {\n\t[FSL_MX6] = {\n\t\t.enable = fsl_mx6_enable,\n\t\t.disable = fsl_mx6_disable,\n\t},\n\t[RCAR_GEN2] = {\n\t\t.enable = rcar_gen2_enable,\n\t\t.disable = rcar_gen2_disable,\n\t},\n\t[RCAR_GEN3] = {\n\t\t.enable = rcar_gen3_enable,\n\t\t.disable = rcar_gen3_disable,\n\t\t.fcnt = 3,\n\t},\n};\n\nstatic const struct of_device_id dim2_of_match[] = {\n\t{\n\t\t.compatible = \"fsl,imx6q-mlb150\",\n\t\t.data = plat_data + FSL_MX6\n\t},\n\t{\n\t\t.compatible = \"renesas,mlp\",\n\t\t.data = plat_data + RCAR_GEN2\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen3-mlp\",\n\t\t.data = plat_data + RCAR_GEN3\n\t},\n\t{\n\t\t.compatible = \"xlnx,axi4-os62420_3pin-1.00.a\",\n\t},\n\t{\n\t\t.compatible = \"xlnx,axi4-os62420_6pin-1.00.a\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, dim2_of_match);\n\nstatic struct platform_driver dim2_driver = {\n\t.probe = dim2_probe,\n\t.remove_new = dim2_remove,\n\t.driver = {\n\t\t.name = \"hdm_dim2\",\n\t\t.of_match_table = dim2_of_match,\n\t\t.dev_groups = dim2_groups,\n\t},\n};\n\nmodule_platform_driver(dim2_driver);\n\nMODULE_AUTHOR(\"Andrey Shvetsov <andrey.shvetsov@k2l.de>\");\nMODULE_DESCRIPTION(\"MediaLB DIM2 Hardware Dependent Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}