{
  "module_name": "i2c.c",
  "hash_id": "1c519edf4da8ade514c84ecae71fea5015e7de726fc00dbdfcc4e1ed7f74f88a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/most/i2c/i2c.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/err.h>\n#include <linux/most.h>\n\nenum { CH_RX, CH_TX, NUM_CHANNELS };\n\n#define MAX_BUFFERS_CONTROL 32\n#define MAX_BUF_SIZE_CONTROL 256\n\n \n#define list_first_mbo(ptr) \\\n\tlist_first_entry(ptr, struct mbo, list)\n\nstatic unsigned int polling_rate;\nmodule_param(polling_rate, uint, 0644);\nMODULE_PARM_DESC(polling_rate, \"Polling rate [Hz]. Default = 0 (use IRQ)\");\n\nstruct hdm_i2c {\n\tstruct most_interface most_iface;\n\tstruct most_channel_capability capabilities[NUM_CHANNELS];\n\tstruct i2c_client *client;\n\tstruct rx {\n\t\tstruct delayed_work dwork;\n\t\tstruct list_head list;\n\t\tbool int_disabled;\n\t\tunsigned int delay;\n\t} rx;\n\tchar name[64];\n};\n\nstatic inline struct hdm_i2c *to_hdm(struct most_interface *iface)\n{\n\treturn container_of(iface, struct hdm_i2c, most_iface);\n}\n\nstatic irqreturn_t most_irq_handler(int, void *);\nstatic void pending_rx_work(struct work_struct *);\n\n \nstatic int configure_channel(struct most_interface *most_iface,\n\t\t\t     int ch_idx,\n\t\t\t     struct most_channel_config *channel_config)\n{\n\tint ret;\n\tstruct hdm_i2c *dev = to_hdm(most_iface);\n\tunsigned int delay, pr;\n\n\tBUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);\n\n\tif (channel_config->data_type != MOST_CH_CONTROL) {\n\t\tpr_err(\"bad data type for channel %d\\n\", ch_idx);\n\t\treturn -EPERM;\n\t}\n\n\tif (channel_config->direction != dev->capabilities[ch_idx].direction) {\n\t\tpr_err(\"bad direction for channel %d\\n\", ch_idx);\n\t\treturn -EPERM;\n\t}\n\n\tif (channel_config->direction == MOST_CH_RX) {\n\t\tif (!polling_rate) {\n\t\t\tif (dev->client->irq <= 0) {\n\t\t\t\tpr_err(\"bad irq: %d\\n\", dev->client->irq);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t\tdev->rx.int_disabled = false;\n\t\t\tret = request_irq(dev->client->irq, most_irq_handler, 0,\n\t\t\t\t\t  dev->client->name, dev);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"request_irq(%d) failed: %d\\n\",\n\t\t\t\t       dev->client->irq, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tdelay = msecs_to_jiffies(MSEC_PER_SEC / polling_rate);\n\t\t\tdev->rx.delay = delay ? delay : 1;\n\t\t\tpr = MSEC_PER_SEC / jiffies_to_msecs(dev->rx.delay);\n\t\t\tpr_info(\"polling rate is %u Hz\\n\", pr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int enqueue(struct most_interface *most_iface,\n\t\t   int ch_idx, struct mbo *mbo)\n{\n\tstruct hdm_i2c *dev = to_hdm(most_iface);\n\tint ret;\n\n\tBUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);\n\n\tif (ch_idx == CH_RX) {\n\t\t \n\t\tif (!polling_rate)\n\t\t\tdisable_irq(dev->client->irq);\n\t\tcancel_delayed_work_sync(&dev->rx.dwork);\n\t\tlist_add_tail(&mbo->list, &dev->rx.list);\n\t\tif (dev->rx.int_disabled || polling_rate)\n\t\t\tpending_rx_work(&dev->rx.dwork.work);\n\t\tif (!polling_rate)\n\t\t\tenable_irq(dev->client->irq);\n\t} else {\n\t\t \n\t\tret = i2c_master_send(dev->client, mbo->virt_address,\n\t\t\t\t      mbo->buffer_length);\n\t\tif (ret <= 0) {\n\t\t\tmbo->processed_length = 0;\n\t\t\tmbo->status = MBO_E_INVAL;\n\t\t} else {\n\t\t\tmbo->processed_length = mbo->buffer_length;\n\t\t\tmbo->status = MBO_SUCCESS;\n\t\t}\n\t\tmbo->complete(mbo);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int poison_channel(struct most_interface *most_iface,\n\t\t\t  int ch_idx)\n{\n\tstruct hdm_i2c *dev = to_hdm(most_iface);\n\tstruct mbo *mbo;\n\n\tBUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);\n\n\tif (ch_idx == CH_RX) {\n\t\tif (!polling_rate)\n\t\t\tfree_irq(dev->client->irq, dev);\n\t\tcancel_delayed_work_sync(&dev->rx.dwork);\n\n\t\twhile (!list_empty(&dev->rx.list)) {\n\t\t\tmbo = list_first_mbo(&dev->rx.list);\n\t\t\tlist_del(&mbo->list);\n\n\t\t\tmbo->processed_length = 0;\n\t\t\tmbo->status = MBO_E_CLOSE;\n\t\t\tmbo->complete(mbo);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void do_rx_work(struct hdm_i2c *dev)\n{\n\tstruct mbo *mbo;\n\tunsigned char msg[MAX_BUF_SIZE_CONTROL];\n\tint ret;\n\tu16 pml, data_size;\n\n\t \n\tret = i2c_master_recv(dev->client, msg, 2);\n\tif (ret <= 0) {\n\t\tpr_err(\"Failed to receive PML\\n\");\n\t\treturn;\n\t}\n\n\tpml = (msg[0] << 8) | msg[1];\n\tif (!pml)\n\t\treturn;\n\n\tdata_size = pml + 2;\n\n\t \n\tret = i2c_master_recv(dev->client, msg, data_size);\n\tif (ret <= 0) {\n\t\tpr_err(\"Failed to receive a Port Message\\n\");\n\t\treturn;\n\t}\n\n\tmbo = list_first_mbo(&dev->rx.list);\n\tlist_del(&mbo->list);\n\n\tmbo->processed_length = min(data_size, mbo->buffer_length);\n\tmemcpy(mbo->virt_address, msg, mbo->processed_length);\n\tmbo->status = MBO_SUCCESS;\n\tmbo->complete(mbo);\n}\n\n \nstatic void pending_rx_work(struct work_struct *work)\n{\n\tstruct hdm_i2c *dev = container_of(work, struct hdm_i2c, rx.dwork.work);\n\n\tif (list_empty(&dev->rx.list))\n\t\treturn;\n\n\tdo_rx_work(dev);\n\n\tif (polling_rate) {\n\t\tschedule_delayed_work(&dev->rx.dwork, dev->rx.delay);\n\t} else {\n\t\tdev->rx.int_disabled = false;\n\t\tenable_irq(dev->client->irq);\n\t}\n}\n\n \nstatic irqreturn_t most_irq_handler(int irq, void *_dev)\n{\n\tstruct hdm_i2c *dev = _dev;\n\n\tdisable_irq_nosync(irq);\n\tdev->rx.int_disabled = true;\n\tschedule_delayed_work(&dev->rx.dwork, 0);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int i2c_probe(struct i2c_client *client)\n{\n\tstruct hdm_i2c *dev;\n\tint ret, i;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tsnprintf(dev->name, sizeof(dev->name), \"i2c-%d-%04x\",\n\t\t client->adapter->nr, client->addr);\n\n\tfor (i = 0; i < NUM_CHANNELS; i++) {\n\t\tdev->capabilities[i].data_type = MOST_CH_CONTROL;\n\t\tdev->capabilities[i].num_buffers_packet = MAX_BUFFERS_CONTROL;\n\t\tdev->capabilities[i].buffer_size_packet = MAX_BUF_SIZE_CONTROL;\n\t}\n\tdev->capabilities[CH_RX].direction = MOST_CH_RX;\n\tdev->capabilities[CH_RX].name_suffix = \"rx\";\n\tdev->capabilities[CH_TX].direction = MOST_CH_TX;\n\tdev->capabilities[CH_TX].name_suffix = \"tx\";\n\n\tdev->most_iface.interface = ITYPE_I2C;\n\tdev->most_iface.description = dev->name;\n\tdev->most_iface.num_channels = NUM_CHANNELS;\n\tdev->most_iface.channel_vector = dev->capabilities;\n\tdev->most_iface.configure = configure_channel;\n\tdev->most_iface.enqueue = enqueue;\n\tdev->most_iface.poison_channel = poison_channel;\n\n\tINIT_LIST_HEAD(&dev->rx.list);\n\n\tINIT_DELAYED_WORK(&dev->rx.dwork, pending_rx_work);\n\n\tdev->client = client;\n\ti2c_set_clientdata(client, dev);\n\n\tret = most_register_interface(&dev->most_iface);\n\tif (ret) {\n\t\tpr_err(\"Failed to register i2c as a MOST interface\\n\");\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void i2c_remove(struct i2c_client *client)\n{\n\tstruct hdm_i2c *dev = i2c_get_clientdata(client);\n\n\tmost_deregister_interface(&dev->most_iface);\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id i2c_id[] = {\n\t{ \"most_i2c\", 0 },\n\t{ },  \n};\n\nMODULE_DEVICE_TABLE(i2c, i2c_id);\n\nstatic struct i2c_driver i2c_driver = {\n\t.driver = {\n\t\t.name = \"hdm_i2c\",\n\t},\n\t.probe = i2c_probe,\n\t.remove = i2c_remove,\n\t.id_table = i2c_id,\n};\n\nmodule_i2c_driver(i2c_driver);\n\nMODULE_AUTHOR(\"Andrey Shvetsov <andrey.shvetsov@k2l.de>\");\nMODULE_DESCRIPTION(\"I2C Hardware Dependent Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}