{
  "module_name": "video.c",
  "hash_id": "855b8a3518ee71199aeb2174451770a8f0f3ff0bd062f0dca7437bbf884e2669",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/most/video/video.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/videodev2.h>\n#include <linux/mutex.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fh.h>\n#include <linux/most.h>\n\n#define V4L2_CMP_MAX_INPUT  1\n\nstatic struct most_component comp;\n\nstruct most_video_dev {\n\tstruct most_interface *iface;\n\tint ch_idx;\n\tstruct list_head list;\n\tbool mute;\n\n\tstruct list_head pending_mbos;\n\tspinlock_t list_lock;\n\n\tstruct v4l2_device v4l2_dev;\n\tatomic_t access_ref;\n\tstruct video_device *vdev;\n\tunsigned int ctrl_input;\n\n\tstruct mutex lock;\n\n\twait_queue_head_t wait_data;\n};\n\nstruct comp_fh {\n\t \n\tstruct v4l2_fh fh;\n\tstruct most_video_dev *mdev;\n\tu32 offs;\n};\n\nstatic LIST_HEAD(video_devices);\nstatic DEFINE_SPINLOCK(list_lock);\n\nstatic inline bool data_ready(struct most_video_dev *mdev)\n{\n\treturn !list_empty(&mdev->pending_mbos);\n}\n\nstatic inline struct mbo *get_top_mbo(struct most_video_dev *mdev)\n{\n\treturn list_first_entry(&mdev->pending_mbos, struct mbo, list);\n}\n\nstatic int comp_vdev_open(struct file *filp)\n{\n\tint ret;\n\tstruct video_device *vdev = video_devdata(filp);\n\tstruct most_video_dev *mdev = video_drvdata(filp);\n\tstruct comp_fh *fh;\n\n\tswitch (vdev->vfl_type) {\n\tcase VFL_TYPE_VIDEO:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfh = kzalloc(sizeof(*fh), GFP_KERNEL);\n\tif (!fh)\n\t\treturn -ENOMEM;\n\n\tif (!atomic_inc_and_test(&mdev->access_ref)) {\n\t\tv4l2_err(&mdev->v4l2_dev, \"too many clients\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err_dec;\n\t}\n\n\tfh->mdev = mdev;\n\tv4l2_fh_init(&fh->fh, vdev);\n\tfilp->private_data = fh;\n\n\tv4l2_fh_add(&fh->fh);\n\n\tret = most_start_channel(mdev->iface, mdev->ch_idx, &comp);\n\tif (ret) {\n\t\tv4l2_err(&mdev->v4l2_dev, \"most_start_channel() failed\\n\");\n\t\tgoto err_rm;\n\t}\n\n\treturn 0;\n\nerr_rm:\n\tv4l2_fh_del(&fh->fh);\n\tv4l2_fh_exit(&fh->fh);\n\nerr_dec:\n\tatomic_dec(&mdev->access_ref);\n\tkfree(fh);\n\treturn ret;\n}\n\nstatic int comp_vdev_close(struct file *filp)\n{\n\tstruct comp_fh *fh = filp->private_data;\n\tstruct most_video_dev *mdev = fh->mdev;\n\tstruct mbo *mbo, *tmp;\n\n\t \n\n\tspin_lock_irq(&mdev->list_lock);\n\tmdev->mute = true;\n\tlist_for_each_entry_safe(mbo, tmp, &mdev->pending_mbos, list) {\n\t\tlist_del(&mbo->list);\n\t\tspin_unlock_irq(&mdev->list_lock);\n\t\tmost_put_mbo(mbo);\n\t\tspin_lock_irq(&mdev->list_lock);\n\t}\n\tspin_unlock_irq(&mdev->list_lock);\n\tmost_stop_channel(mdev->iface, mdev->ch_idx, &comp);\n\tmdev->mute = false;\n\n\tv4l2_fh_del(&fh->fh);\n\tv4l2_fh_exit(&fh->fh);\n\n\tatomic_dec(&mdev->access_ref);\n\tkfree(fh);\n\treturn 0;\n}\n\nstatic ssize_t comp_vdev_read(struct file *filp, char __user *buf,\n\t\t\t      size_t count, loff_t *pos)\n{\n\tstruct comp_fh *fh = filp->private_data;\n\tstruct most_video_dev *mdev = fh->mdev;\n\tint ret = 0;\n\n\tif (*pos)\n\t\treturn -ESPIPE;\n\n\tif (!mdev)\n\t\treturn -ENODEV;\n\n\t \n\tif (!(filp->f_flags & O_NONBLOCK)) {\n\t\tif (wait_event_interruptible(mdev->wait_data, data_ready(mdev)))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tif (!data_ready(mdev))\n\t\treturn -EAGAIN;\n\n\twhile (count > 0 && data_ready(mdev)) {\n\t\tstruct mbo *const mbo = get_top_mbo(mdev);\n\t\tint const rem = mbo->processed_length - fh->offs;\n\t\tint const cnt = rem < count ? rem : count;\n\n\t\tif (copy_to_user(buf, mbo->virt_address + fh->offs, cnt)) {\n\t\t\tv4l2_err(&mdev->v4l2_dev, \"read: copy_to_user failed\\n\");\n\t\t\tif (!ret)\n\t\t\t\tret = -EFAULT;\n\t\t\treturn ret;\n\t\t}\n\n\t\tfh->offs += cnt;\n\t\tcount -= cnt;\n\t\tbuf += cnt;\n\t\tret += cnt;\n\n\t\tif (cnt >= rem) {\n\t\t\tfh->offs = 0;\n\t\t\tspin_lock_irq(&mdev->list_lock);\n\t\t\tlist_del(&mbo->list);\n\t\t\tspin_unlock_irq(&mdev->list_lock);\n\t\t\tmost_put_mbo(mbo);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic __poll_t comp_vdev_poll(struct file *filp, poll_table *wait)\n{\n\tstruct comp_fh *fh = filp->private_data;\n\tstruct most_video_dev *mdev = fh->mdev;\n\t__poll_t mask = 0;\n\n\t \n\tif (!data_ready(mdev))\n\t\tpoll_wait(filp, &mdev->wait_data, wait);\n\tif (data_ready(mdev))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic void comp_set_format_struct(struct v4l2_format *f)\n{\n\tf->fmt.pix.width = 8;\n\tf->fmt.pix.height = 8;\n\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\n\tf->fmt.pix.bytesperline = 0;\n\tf->fmt.pix.sizeimage = 188 * 2;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\tf->fmt.pix.priv = 0;\n}\n\nstatic int comp_set_format(struct most_video_dev *mdev, unsigned int cmd,\n\t\t\t   struct v4l2_format *format)\n{\n\tif (format->fmt.pix.pixelformat != V4L2_PIX_FMT_MPEG)\n\t\treturn -EINVAL;\n\n\tif (cmd == VIDIOC_TRY_FMT)\n\t\treturn 0;\n\n\tcomp_set_format_struct(format);\n\n\treturn 0;\n}\n\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct comp_fh *fh = priv;\n\tstruct most_video_dev *mdev = fh->mdev;\n\n\tstrscpy(cap->driver, \"v4l2_component\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"MOST\", sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"%s\", mdev->iface->description);\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tif (f->index)\n\t\treturn -EINVAL;\n\n\tstrscpy(f->description, \"MPEG\", sizeof(f->description));\n\tf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tf->flags = V4L2_FMT_FLAG_COMPRESSED;\n\tf->pixelformat = V4L2_PIX_FMT_MPEG;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tcomp_set_format_struct(f);\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct comp_fh *fh = priv;\n\tstruct most_video_dev *mdev = fh->mdev;\n\n\treturn comp_set_format(mdev, VIDIOC_TRY_FMT, f);\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct comp_fh *fh = priv;\n\tstruct most_video_dev *mdev = fh->mdev;\n\n\treturn comp_set_format(mdev, VIDIOC_S_FMT, f);\n}\n\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *norm)\n{\n\t*norm = V4L2_STD_UNKNOWN;\n\treturn 0;\n}\n\nstatic int vidioc_enum_input(struct file *file, void *priv,\n\t\t\t     struct v4l2_input *input)\n{\n\tstruct comp_fh *fh = priv;\n\tstruct most_video_dev *mdev = fh->mdev;\n\n\tif (input->index >= V4L2_CMP_MAX_INPUT)\n\t\treturn -EINVAL;\n\n\tstrscpy(input->name, \"MOST Video\", sizeof(input->name));\n\tinput->type |= V4L2_INPUT_TYPE_CAMERA;\n\tinput->audioset = 0;\n\n\tinput->std = mdev->vdev->tvnorms;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct comp_fh *fh = priv;\n\tstruct most_video_dev *mdev = fh->mdev;\n\t*i = mdev->ctrl_input;\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int index)\n{\n\tstruct comp_fh *fh = priv;\n\tstruct most_video_dev *mdev = fh->mdev;\n\n\tif (index >= V4L2_CMP_MAX_INPUT)\n\t\treturn -EINVAL;\n\tmdev->ctrl_input = index;\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations comp_fops = {\n\t.owner      = THIS_MODULE,\n\t.open       = comp_vdev_open,\n\t.release    = comp_vdev_close,\n\t.read       = comp_vdev_read,\n\t.poll       = comp_vdev_poll,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops video_ioctl_ops = {\n\t.vidioc_querycap            = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap    = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap       = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap     = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap       = vidioc_s_fmt_vid_cap,\n\t.vidioc_g_std               = vidioc_g_std,\n\t.vidioc_enum_input          = vidioc_enum_input,\n\t.vidioc_g_input             = vidioc_g_input,\n\t.vidioc_s_input             = vidioc_s_input,\n};\n\nstatic const struct video_device comp_videodev_template = {\n\t.fops = &comp_fops,\n\t.release = video_device_release,\n\t.ioctl_ops = &video_ioctl_ops,\n\t.tvnorms = V4L2_STD_UNKNOWN,\n\t.device_caps = V4L2_CAP_READWRITE | V4L2_CAP_VIDEO_CAPTURE,\n};\n\n \n\nstatic struct most_video_dev *get_comp_dev(struct most_interface *iface, int channel_idx)\n{\n\tstruct most_video_dev *mdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&list_lock, flags);\n\tlist_for_each_entry(mdev, &video_devices, list) {\n\t\tif (mdev->iface == iface && mdev->ch_idx == channel_idx) {\n\t\t\tspin_unlock_irqrestore(&list_lock, flags);\n\t\t\treturn mdev;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&list_lock, flags);\n\treturn NULL;\n}\n\nstatic int comp_rx_data(struct mbo *mbo)\n{\n\tunsigned long flags;\n\tstruct most_video_dev *mdev =\n\t\tget_comp_dev(mbo->ifp, mbo->hdm_channel_id);\n\n\tif (!mdev)\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&mdev->list_lock, flags);\n\tif (unlikely(mdev->mute)) {\n\t\tspin_unlock_irqrestore(&mdev->list_lock, flags);\n\t\treturn -EIO;\n\t}\n\n\tlist_add_tail(&mbo->list, &mdev->pending_mbos);\n\tspin_unlock_irqrestore(&mdev->list_lock, flags);\n\twake_up_interruptible(&mdev->wait_data);\n\treturn 0;\n}\n\nstatic int comp_register_videodev(struct most_video_dev *mdev)\n{\n\tint ret;\n\n\tinit_waitqueue_head(&mdev->wait_data);\n\n\t \n\tmdev->vdev = video_device_alloc();\n\tif (!mdev->vdev)\n\t\treturn -ENOMEM;\n\n\t \n\t*mdev->vdev = comp_videodev_template;\n\tmdev->vdev->v4l2_dev = &mdev->v4l2_dev;\n\tmdev->vdev->lock = &mdev->lock;\n\tsnprintf(mdev->vdev->name, sizeof(mdev->vdev->name), \"MOST: %s\",\n\t\t mdev->v4l2_dev.name);\n\n\t \n\tvideo_set_drvdata(mdev->vdev, mdev);\n\tret = video_register_device(mdev->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tv4l2_err(&mdev->v4l2_dev, \"video_register_device failed (%d)\\n\",\n\t\t\t ret);\n\t\tvideo_device_release(mdev->vdev);\n\t}\n\n\treturn ret;\n}\n\nstatic void comp_unregister_videodev(struct most_video_dev *mdev)\n{\n\tvideo_unregister_device(mdev->vdev);\n}\n\nstatic void comp_v4l2_dev_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct most_video_dev *mdev =\n\t\tcontainer_of(v4l2_dev, struct most_video_dev, v4l2_dev);\n\n\tv4l2_device_unregister(v4l2_dev);\n\tkfree(mdev);\n}\n\nstatic int comp_probe_channel(struct most_interface *iface, int channel_idx,\n\t\t\t      struct most_channel_config *ccfg, char *name,\n\t\t\t      char *args)\n{\n\tint ret;\n\tstruct most_video_dev *mdev = get_comp_dev(iface, channel_idx);\n\n\tif (mdev) {\n\t\tpr_err(\"channel already linked\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\tif (ccfg->direction != MOST_CH_RX) {\n\t\tpr_err(\"wrong direction, expect rx\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ccfg->data_type != MOST_CH_SYNC &&\n\t    ccfg->data_type != MOST_CH_ISOC) {\n\t\tpr_err(\"wrong channel type, expect sync or isoc\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&mdev->lock);\n\tatomic_set(&mdev->access_ref, -1);\n\tspin_lock_init(&mdev->list_lock);\n\tINIT_LIST_HEAD(&mdev->pending_mbos);\n\tmdev->iface = iface;\n\tmdev->ch_idx = channel_idx;\n\tmdev->v4l2_dev.release = comp_v4l2_dev_release;\n\n\t \n\tstrscpy(mdev->v4l2_dev.name, name, sizeof(mdev->v4l2_dev.name));\n\tret = v4l2_device_register(NULL, &mdev->v4l2_dev);\n\tif (ret) {\n\t\tpr_err(\"v4l2_device_register() failed\\n\");\n\t\tkfree(mdev);\n\t\treturn ret;\n\t}\n\n\tret = comp_register_videodev(mdev);\n\tif (ret)\n\t\tgoto err_unreg;\n\n\tspin_lock_irq(&list_lock);\n\tlist_add(&mdev->list, &video_devices);\n\tspin_unlock_irq(&list_lock);\n\treturn 0;\n\nerr_unreg:\n\tv4l2_device_disconnect(&mdev->v4l2_dev);\n\tv4l2_device_put(&mdev->v4l2_dev);\n\treturn ret;\n}\n\nstatic int comp_disconnect_channel(struct most_interface *iface,\n\t\t\t\t   int channel_idx)\n{\n\tstruct most_video_dev *mdev = get_comp_dev(iface, channel_idx);\n\n\tif (!mdev) {\n\t\tpr_err(\"no such channel is linked\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock_irq(&list_lock);\n\tlist_del(&mdev->list);\n\tspin_unlock_irq(&list_lock);\n\n\tcomp_unregister_videodev(mdev);\n\tv4l2_device_disconnect(&mdev->v4l2_dev);\n\tv4l2_device_put(&mdev->v4l2_dev);\n\treturn 0;\n}\n\nstatic struct most_component comp = {\n\t.mod = THIS_MODULE,\n\t.name = \"video\",\n\t.probe_channel = comp_probe_channel,\n\t.disconnect_channel = comp_disconnect_channel,\n\t.rx_completion = comp_rx_data,\n};\n\nstatic int __init comp_init(void)\n{\n\tint err;\n\n\terr = most_register_component(&comp);\n\tif (err)\n\t\treturn err;\n\terr = most_register_configfs_subsys(&comp);\n\tif (err) {\n\t\tmost_deregister_component(&comp);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void __exit comp_exit(void)\n{\n\tstruct most_video_dev *mdev, *tmp;\n\n\t \n\tspin_lock_irq(&list_lock);\n\tlist_for_each_entry_safe(mdev, tmp, &video_devices, list) {\n\t\tlist_del(&mdev->list);\n\t\tspin_unlock_irq(&list_lock);\n\n\t\tcomp_unregister_videodev(mdev);\n\t\tv4l2_device_disconnect(&mdev->v4l2_dev);\n\t\tv4l2_device_put(&mdev->v4l2_dev);\n\t\tspin_lock_irq(&list_lock);\n\t}\n\tspin_unlock_irq(&list_lock);\n\n\tmost_deregister_configfs_subsys(&comp);\n\tmost_deregister_component(&comp);\n\tBUG_ON(!list_empty(&video_devices));\n}\n\nmodule_init(comp_init);\nmodule_exit(comp_exit);\n\nMODULE_DESCRIPTION(\"V4L2 Component Module for Mostcore\");\nMODULE_AUTHOR(\"Andrey Shvetsov <andrey.shvetsov@k2l.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}