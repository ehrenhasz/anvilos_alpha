{
  "module_name": "net.c",
  "hash_id": "63a93ea24b988366e32b7c21d15ce42a1a0db70f62d46bc0270fb264dc471bc2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/most/net/net.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/kobject.h>\n#include <linux/most.h>\n\n#define MEP_HDR_LEN 8\n#define MDP_HDR_LEN 16\n#define MAMAC_DATA_LEN (1024 - MDP_HDR_LEN)\n\n#define PMHL 5\n\n#define PMS_TELID_UNSEGM_MAMAC\t0x0A\n#define PMS_FIFONO_MDP\t\t0x01\n#define PMS_FIFONO_MEP\t\t0x04\n#define PMS_MSGTYPE_DATA\t0x04\n#define PMS_DEF_PRIO\t\t0\n#define MEP_DEF_RETRY\t\t15\n\n#define PMS_FIFONO_MASK\t\t0x07\n#define PMS_FIFONO_SHIFT\t3\n#define PMS_RETRY_SHIFT\t\t4\n#define PMS_TELID_MASK\t\t0x0F\n#define PMS_TELID_SHIFT\t\t4\n\n#define HB(value)\t\t((u8)((u16)(value) >> 8))\n#define LB(value)\t\t((u8)(value))\n\n#define EXTRACT_BIT_SET(bitset_name, value) \\\n\t(((value) >> bitset_name##_SHIFT) & bitset_name##_MASK)\n\n#define PMS_IS_MEP(buf, len) \\\n\t((len) > MEP_HDR_LEN && \\\n\t EXTRACT_BIT_SET(PMS_FIFONO, (buf)[3]) == PMS_FIFONO_MEP)\n\nstatic inline bool pms_is_mamac(char *buf, u32 len)\n{\n\treturn (len > MDP_HDR_LEN &&\n\t\tEXTRACT_BIT_SET(PMS_FIFONO, buf[3]) == PMS_FIFONO_MDP &&\n\t\tEXTRACT_BIT_SET(PMS_TELID, buf[14]) == PMS_TELID_UNSEGM_MAMAC);\n}\n\nstruct net_dev_channel {\n\tbool linked;\n\tint ch_id;\n};\n\nstruct net_dev_context {\n\tstruct most_interface *iface;\n\tbool is_mamac;\n\tstruct net_device *dev;\n\tstruct net_dev_channel rx;\n\tstruct net_dev_channel tx;\n\tstruct list_head list;\n};\n\nstatic LIST_HEAD(net_devices);\nstatic DEFINE_MUTEX(probe_disc_mt);  \nstatic DEFINE_SPINLOCK(list_lock);  \nstatic struct most_component comp;\n\nstatic int skb_to_mamac(const struct sk_buff *skb, struct mbo *mbo)\n{\n\tu8 *buff = mbo->virt_address;\n\tstatic const u8 broadcast[] = { 0x03, 0xFF };\n\tconst u8 *dest_addr = skb->data + 4;\n\tconst u8 *eth_type = skb->data + 12;\n\tunsigned int payload_len = skb->len - ETH_HLEN;\n\tunsigned int mdp_len = payload_len + MDP_HDR_LEN;\n\n\tif (mdp_len < skb->len) {\n\t\tpr_err(\"drop: too large packet! (%u)\\n\", skb->len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mbo->buffer_length < mdp_len) {\n\t\tpr_err(\"drop: too small buffer! (%d for %d)\\n\",\n\t\t       mbo->buffer_length, mdp_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (skb->len < ETH_HLEN) {\n\t\tpr_err(\"drop: too small packet! (%d)\\n\", skb->len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dest_addr[0] == 0xFF && dest_addr[1] == 0xFF)\n\t\tdest_addr = broadcast;\n\n\t*buff++ = HB(mdp_len - 2);\n\t*buff++ = LB(mdp_len - 2);\n\n\t*buff++ = PMHL;\n\t*buff++ = (PMS_FIFONO_MDP << PMS_FIFONO_SHIFT) | PMS_MSGTYPE_DATA;\n\t*buff++ = PMS_DEF_PRIO;\n\t*buff++ = dest_addr[0];\n\t*buff++ = dest_addr[1];\n\t*buff++ = 0x00;\n\n\t*buff++ = HB(payload_len + 6);\n\t*buff++ = LB(payload_len + 6);\n\n\t \n\n\t*buff++ = eth_type[0];\n\t*buff++ = eth_type[1];\n\t*buff++ = 0;\n\t*buff++ = 0;\n\n\t*buff++ = PMS_TELID_UNSEGM_MAMAC << 4 | HB(payload_len);\n\t*buff++ = LB(payload_len);\n\n\tmemcpy(buff, skb->data + ETH_HLEN, payload_len);\n\tmbo->buffer_length = mdp_len;\n\treturn 0;\n}\n\nstatic int skb_to_mep(const struct sk_buff *skb, struct mbo *mbo)\n{\n\tu8 *buff = mbo->virt_address;\n\tunsigned int mep_len = skb->len + MEP_HDR_LEN;\n\n\tif (mep_len < skb->len) {\n\t\tpr_err(\"drop: too large packet! (%u)\\n\", skb->len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mbo->buffer_length < mep_len) {\n\t\tpr_err(\"drop: too small buffer! (%d for %d)\\n\",\n\t\t       mbo->buffer_length, mep_len);\n\t\treturn -EINVAL;\n\t}\n\n\t*buff++ = HB(mep_len - 2);\n\t*buff++ = LB(mep_len - 2);\n\n\t*buff++ = PMHL;\n\t*buff++ = (PMS_FIFONO_MEP << PMS_FIFONO_SHIFT) | PMS_MSGTYPE_DATA;\n\t*buff++ = (MEP_DEF_RETRY << PMS_RETRY_SHIFT) | PMS_DEF_PRIO;\n\t*buff++ = 0;\n\t*buff++ = 0;\n\t*buff++ = 0;\n\n\tmemcpy(buff, skb->data, skb->len);\n\tmbo->buffer_length = mep_len;\n\treturn 0;\n}\n\nstatic int most_nd_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct net_dev_context *nd = netdev_priv(dev);\n\tint err = eth_mac_addr(dev, p);\n\n\tif (err)\n\t\treturn err;\n\n\tnd->is_mamac =\n\t\t(dev->dev_addr[0] == 0 && dev->dev_addr[1] == 0 &&\n\t\t dev->dev_addr[2] == 0 && dev->dev_addr[3] == 0);\n\n\t \n\tdev->mtu = nd->is_mamac ? MAMAC_DATA_LEN : ETH_DATA_LEN;\n\n\treturn 0;\n}\n\nstatic void on_netinfo(struct most_interface *iface,\n\t\t       unsigned char link_stat, unsigned char *mac_addr);\n\nstatic int most_nd_open(struct net_device *dev)\n{\n\tstruct net_dev_context *nd = netdev_priv(dev);\n\tint ret = 0;\n\n\tmutex_lock(&probe_disc_mt);\n\n\tif (most_start_channel(nd->iface, nd->rx.ch_id, &comp)) {\n\t\tnetdev_err(dev, \"most_start_channel() failed\\n\");\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (most_start_channel(nd->iface, nd->tx.ch_id, &comp)) {\n\t\tnetdev_err(dev, \"most_start_channel() failed\\n\");\n\t\tmost_stop_channel(nd->iface, nd->rx.ch_id, &comp);\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tnetif_carrier_off(dev);\n\tif (is_valid_ether_addr(dev->dev_addr))\n\t\tnetif_dormant_off(dev);\n\telse\n\t\tnetif_dormant_on(dev);\n\tnetif_wake_queue(dev);\n\tif (nd->iface->request_netinfo)\n\t\tnd->iface->request_netinfo(nd->iface, nd->tx.ch_id, on_netinfo);\n\nunlock:\n\tmutex_unlock(&probe_disc_mt);\n\treturn ret;\n}\n\nstatic int most_nd_stop(struct net_device *dev)\n{\n\tstruct net_dev_context *nd = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\tif (nd->iface->request_netinfo)\n\t\tnd->iface->request_netinfo(nd->iface, nd->tx.ch_id, NULL);\n\tmost_stop_channel(nd->iface, nd->rx.ch_id, &comp);\n\tmost_stop_channel(nd->iface, nd->tx.ch_id, &comp);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t most_nd_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct net_dev_context *nd = netdev_priv(dev);\n\tstruct mbo *mbo;\n\tint ret;\n\n\tmbo = most_get_mbo(nd->iface, nd->tx.ch_id, &comp);\n\n\tif (!mbo) {\n\t\tnetif_stop_queue(dev);\n\t\tdev->stats.tx_fifo_errors++;\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (nd->is_mamac)\n\t\tret = skb_to_mamac(skb, mbo);\n\telse\n\t\tret = skb_to_mep(skb, mbo);\n\n\tif (ret) {\n\t\tmost_put_mbo(mbo);\n\t\tdev->stats.tx_dropped++;\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tmost_submit_mbo(mbo);\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops most_nd_ops = {\n\t.ndo_open = most_nd_open,\n\t.ndo_stop = most_nd_stop,\n\t.ndo_start_xmit = most_nd_start_xmit,\n\t.ndo_set_mac_address = most_nd_set_mac_address,\n};\n\nstatic void most_nd_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->netdev_ops = &most_nd_ops;\n}\n\nstatic struct net_dev_context *get_net_dev(struct most_interface *iface)\n{\n\tstruct net_dev_context *nd;\n\n\tlist_for_each_entry(nd, &net_devices, list)\n\t\tif (nd->iface == iface)\n\t\t\treturn nd;\n\treturn NULL;\n}\n\nstatic struct net_dev_context *get_net_dev_hold(struct most_interface *iface)\n{\n\tstruct net_dev_context *nd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&list_lock, flags);\n\tnd = get_net_dev(iface);\n\tif (nd && nd->rx.linked && nd->tx.linked)\n\t\tdev_hold(nd->dev);\n\telse\n\t\tnd = NULL;\n\tspin_unlock_irqrestore(&list_lock, flags);\n\treturn nd;\n}\n\nstatic int comp_probe_channel(struct most_interface *iface, int channel_idx,\n\t\t\t      struct most_channel_config *ccfg, char *name,\n\t\t\t      char *args)\n{\n\tstruct net_dev_context *nd;\n\tstruct net_dev_channel *ch;\n\tstruct net_device *dev;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!iface)\n\t\treturn -EINVAL;\n\n\tif (ccfg->data_type != MOST_CH_ASYNC)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&probe_disc_mt);\n\tnd = get_net_dev(iface);\n\tif (!nd) {\n\t\tdev = alloc_netdev(sizeof(struct net_dev_context), \"meth%d\",\n\t\t\t\t   NET_NAME_UNKNOWN, most_nd_setup);\n\t\tif (!dev) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tnd = netdev_priv(dev);\n\t\tnd->iface = iface;\n\t\tnd->dev = dev;\n\n\t\tspin_lock_irqsave(&list_lock, flags);\n\t\tlist_add(&nd->list, &net_devices);\n\t\tspin_unlock_irqrestore(&list_lock, flags);\n\n\t\tch = ccfg->direction == MOST_CH_TX ? &nd->tx : &nd->rx;\n\t} else {\n\t\tch = ccfg->direction == MOST_CH_TX ? &nd->tx : &nd->rx;\n\t\tif (ch->linked) {\n\t\t\tpr_err(\"direction is allocated\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (register_netdev(nd->dev)) {\n\t\t\tpr_err(\"register_netdev() failed\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tch->ch_id = channel_idx;\n\tch->linked = true;\n\nunlock:\n\tmutex_unlock(&probe_disc_mt);\n\treturn ret;\n}\n\nstatic int comp_disconnect_channel(struct most_interface *iface,\n\t\t\t\t   int channel_idx)\n{\n\tstruct net_dev_context *nd;\n\tstruct net_dev_channel *ch;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tmutex_lock(&probe_disc_mt);\n\tnd = get_net_dev(iface);\n\tif (!nd) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (nd->rx.linked && channel_idx == nd->rx.ch_id) {\n\t\tch = &nd->rx;\n\t} else if (nd->tx.linked && channel_idx == nd->tx.ch_id) {\n\t\tch = &nd->tx;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (nd->rx.linked && nd->tx.linked) {\n\t\tspin_lock_irqsave(&list_lock, flags);\n\t\tch->linked = false;\n\t\tspin_unlock_irqrestore(&list_lock, flags);\n\n\t\t \n\t\tunregister_netdev(nd->dev);\n\t} else {\n\t\tspin_lock_irqsave(&list_lock, flags);\n\t\tlist_del(&nd->list);\n\t\tspin_unlock_irqrestore(&list_lock, flags);\n\n\t\tfree_netdev(nd->dev);\n\t}\n\nunlock:\n\tmutex_unlock(&probe_disc_mt);\n\treturn ret;\n}\n\nstatic int comp_resume_tx_channel(struct most_interface *iface,\n\t\t\t\t  int channel_idx)\n{\n\tstruct net_dev_context *nd;\n\n\tnd = get_net_dev_hold(iface);\n\tif (!nd)\n\t\treturn 0;\n\n\tif (nd->tx.ch_id != channel_idx)\n\t\tgoto put_nd;\n\n\tnetif_wake_queue(nd->dev);\n\nput_nd:\n\tdev_put(nd->dev);\n\treturn 0;\n}\n\nstatic int comp_rx_data(struct mbo *mbo)\n{\n\tconst u32 zero = 0;\n\tstruct net_dev_context *nd;\n\tchar *buf = mbo->virt_address;\n\tu32 len = mbo->processed_length;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tunsigned int skb_len;\n\tint ret = 0;\n\n\tnd = get_net_dev_hold(mbo->ifp);\n\tif (!nd)\n\t\treturn -EIO;\n\n\tif (nd->rx.ch_id != mbo->hdm_channel_id) {\n\t\tret = -EIO;\n\t\tgoto put_nd;\n\t}\n\n\tdev = nd->dev;\n\n\tif (nd->is_mamac) {\n\t\tif (!pms_is_mamac(buf, len)) {\n\t\t\tret = -EIO;\n\t\t\tgoto put_nd;\n\t\t}\n\n\t\tskb = dev_alloc_skb(len - MDP_HDR_LEN + 2 * ETH_ALEN + 2);\n\t} else {\n\t\tif (!PMS_IS_MEP(buf, len)) {\n\t\t\tret = -EIO;\n\t\t\tgoto put_nd;\n\t\t}\n\n\t\tskb = dev_alloc_skb(len - MEP_HDR_LEN);\n\t}\n\n\tif (!skb) {\n\t\tdev->stats.rx_dropped++;\n\t\tpr_err_once(\"drop packet: no memory for skb\\n\");\n\t\tgoto out;\n\t}\n\n\tskb->dev = dev;\n\n\tif (nd->is_mamac) {\n\t\t \n\t\tether_addr_copy(skb_put(skb, ETH_ALEN), dev->dev_addr);\n\n\t\t \n\t\tskb_put_data(skb, &zero, 4);\n\t\tskb_put_data(skb, buf + 5, 2);\n\n\t\t \n\t\tskb_put_data(skb, buf + 10, 2);\n\n\t\tbuf += MDP_HDR_LEN;\n\t\tlen -= MDP_HDR_LEN;\n\t} else {\n\t\tbuf += MEP_HDR_LEN;\n\t\tlen -= MEP_HDR_LEN;\n\t}\n\n\tskb_put_data(skb, buf, len);\n\tskb->protocol = eth_type_trans(skb, dev);\n\tskb_len = skb->len;\n\tif (netif_rx(skb) == NET_RX_SUCCESS) {\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += skb_len;\n\t} else {\n\t\tdev->stats.rx_dropped++;\n\t}\n\nout:\n\tmost_put_mbo(mbo);\n\nput_nd:\n\tdev_put(nd->dev);\n\treturn ret;\n}\n\nstatic struct most_component comp = {\n\t.mod = THIS_MODULE,\n\t.name = \"net\",\n\t.probe_channel = comp_probe_channel,\n\t.disconnect_channel = comp_disconnect_channel,\n\t.tx_completion = comp_resume_tx_channel,\n\t.rx_completion = comp_rx_data,\n};\n\nstatic int __init most_net_init(void)\n{\n\tint err;\n\n\terr = most_register_component(&comp);\n\tif (err)\n\t\treturn err;\n\terr = most_register_configfs_subsys(&comp);\n\tif (err) {\n\t\tmost_deregister_component(&comp);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void __exit most_net_exit(void)\n{\n\tmost_deregister_configfs_subsys(&comp);\n\tmost_deregister_component(&comp);\n}\n\n \nstatic void on_netinfo(struct most_interface *iface,\n\t\t       unsigned char link_stat, unsigned char *mac_addr)\n{\n\tstruct net_dev_context *nd;\n\tstruct net_device *dev;\n\tconst u8 *m = mac_addr;\n\n\tnd = get_net_dev_hold(iface);\n\tif (!nd)\n\t\treturn;\n\n\tdev = nd->dev;\n\n\tif (link_stat)\n\t\tnetif_carrier_on(dev);\n\telse\n\t\tnetif_carrier_off(dev);\n\n\tif (m && is_valid_ether_addr(m)) {\n\t\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\t\tnetdev_info(dev, \"set mac %pM\\n\", m);\n\t\t\teth_hw_addr_set(dev, m);\n\t\t\tnetif_dormant_off(dev);\n\t\t} else if (!ether_addr_equal(dev->dev_addr, m)) {\n\t\t\tnetdev_warn(dev, \"reject mac %pM\\n\", m);\n\t\t}\n\t}\n\n\tdev_put(nd->dev);\n}\n\nmodule_init(most_net_init);\nmodule_exit(most_net_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Andrey Shvetsov <andrey.shvetsov@k2l.de>\");\nMODULE_DESCRIPTION(\"Networking Component Module for Mostcore\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}