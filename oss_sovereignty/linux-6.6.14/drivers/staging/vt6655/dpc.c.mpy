{
  "module_name": "dpc.c",
  "hash_id": "a2a70d6109bfe6b87cc716c99dfd65250a8691ab96b65426200605012ee7edd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vt6655/dpc.c",
  "human_readable_source": "\n \n\n#include \"device.h\"\n#include \"baseband.h\"\n#include \"rf.h\"\n#include \"dpc.h\"\n\nstatic bool vnt_rx_data(struct vnt_private *priv, struct sk_buff *skb,\n\t\t\tu16 bytes_received)\n{\n\tstruct ieee80211_hw *hw = priv->hw;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_rx_status rx_status = { 0 };\n\tstruct ieee80211_hdr *hdr;\n\t__le16 fc;\n\tu8 *rsr, *new_rsr, *rssi;\n\t__le64 *tsf_time;\n\tu16 frame_size;\n\tint ii, r;\n\tu8 *rx_rate;\n\tu8 *skb_data;\n\tu8 rate_idx = 0;\n\tu8 rate[MAX_RATE] = {2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108};\n\tlong rx_dbm;\n\n\t \n\tframe_size = le16_to_cpu(*((__le16 *)(skb->data + 2)));\n\tif (frame_size > 2346 || frame_size < 14) {\n\t\tdev_dbg(&priv->pcid->dev, \"------- WRONG Length 1\\n\");\n\t\treturn false;\n\t}\n\n\tskb_data = (u8 *)skb->data;\n\n\trx_rate = skb_data + 1;\n\n\tsband = hw->wiphy->bands[hw->conf.chandef.chan->band];\n\n\tfor (r = RATE_1M; r < MAX_RATE; r++) {\n\t\tif (*rx_rate == rate[r])\n\t\t\tbreak;\n\t}\n\n\tpriv->rx_rate = r;\n\n\tfor (ii = 0; ii < sband->n_bitrates; ii++) {\n\t\tif (sband->bitrates[ii].hw_value == r) {\n\t\t\trate_idx = ii;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ii == sband->n_bitrates) {\n\t\tdev_dbg(&priv->pcid->dev, \"Wrong RxRate %x\\n\", *rx_rate);\n\t\treturn false;\n\t}\n\n\ttsf_time = (__le64 *)(skb_data + bytes_received - 12);\n\tnew_rsr = skb_data + bytes_received - 3;\n\trssi = skb_data + bytes_received - 2;\n\trsr = skb_data + bytes_received - 1;\n\tif (*rsr & (RSR_IVLDTYP | RSR_IVLDLEN))\n\t\treturn false;\n\n\tRFvRSSITodBm(priv, *rssi, &rx_dbm);\n\n\tpriv->byBBPreEDRSSI = (u8)rx_dbm + 1;\n\tpriv->current_rssi = *rssi;\n\n\tskb_pull(skb, 4);\n\tskb_trim(skb, frame_size);\n\n\trx_status.mactime = le64_to_cpu(*tsf_time);\n\trx_status.band = hw->conf.chandef.chan->band;\n\trx_status.signal = rx_dbm;\n\trx_status.flag = 0;\n\trx_status.freq = hw->conf.chandef.chan->center_freq;\n\n\tif (!(*rsr & RSR_CRCOK))\n\t\trx_status.flag |= RX_FLAG_FAILED_FCS_CRC;\n\n\thdr = (struct ieee80211_hdr *)(skb->data);\n\tfc = hdr->frame_control;\n\n\trx_status.rate_idx = rate_idx;\n\n\tif (ieee80211_has_protected(fc)) {\n\t\tif (priv->local_id > REV_ID_VT3253_A1)\n\t\t\trx_status.flag |= RX_FLAG_DECRYPTED;\n\n\t\t \n\t\tif (!(*new_rsr & NEWRSR_DECRYPTOK))\n\t\t\treturn false;\n\t}\n\n\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\n\n\tieee80211_rx_irqsafe(priv->hw, skb);\n\n\treturn true;\n}\n\nbool vnt_receive_frame(struct vnt_private *priv, struct vnt_rx_desc *curr_rd)\n{\n\tstruct vnt_rd_info *rd_info = curr_rd->rd_info;\n\tstruct sk_buff *skb;\n\tu16 frame_size;\n\n\tskb = rd_info->skb;\n\n\tdma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,\n\t\t\t priv->rx_buf_sz, DMA_FROM_DEVICE);\n\n\tframe_size = le16_to_cpu(curr_rd->rd1.req_count)\n\t\t\t- le16_to_cpu(curr_rd->rd0.res_count);\n\n\tif ((frame_size > 2364) || (frame_size < 33)) {\n\t\t \n\t\tdev_dbg(&priv->pcid->dev, \"Wrong frame size %d\\n\", frame_size);\n\t\tdev_kfree_skb_irq(skb);\n\t\treturn true;\n\t}\n\n\tif (vnt_rx_data(priv, skb, frame_size))\n\t\treturn true;\n\n\tdev_kfree_skb_irq(skb);\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}