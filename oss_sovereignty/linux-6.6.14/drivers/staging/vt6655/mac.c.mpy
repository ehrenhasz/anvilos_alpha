{
  "module_name": "mac.c",
  "hash_id": "047f2631f5efd7d1a6d806539c49e834da645f5c8a7988cc8950f4fffca5f013",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vt6655/mac.c",
  "human_readable_source": "\n \n\n#include \"mac.h\"\n\nvoid vt6655_mac_reg_bits_on(void __iomem *iobase, const u8 reg_offset, const u8 bit_mask)\n{\n\tunsigned char reg_value;\n\n\treg_value = ioread8(iobase + reg_offset);\n\tiowrite8(reg_value | bit_mask, iobase + reg_offset);\n}\n\nvoid vt6655_mac_word_reg_bits_on(void __iomem *iobase, const u8 reg_offset, const u16 bit_mask)\n{\n\tunsigned short reg_value;\n\n\treg_value = ioread16(iobase + reg_offset);\n\tiowrite16(reg_value | (bit_mask), iobase + reg_offset);\n}\n\nvoid vt6655_mac_reg_bits_off(void __iomem *iobase, const u8 reg_offset, const u8 bit_mask)\n{\n\tunsigned char reg_value;\n\n\treg_value = ioread8(iobase + reg_offset);\n\tiowrite8(reg_value & ~(bit_mask), iobase + reg_offset);\n}\n\nvoid vt6655_mac_word_reg_bits_off(void __iomem *iobase, const u8 reg_offset, const u16 bit_mask)\n{\n\tunsigned short reg_value;\n\n\treg_value = ioread16(iobase + reg_offset);\n\tiowrite16(reg_value & ~(bit_mask), iobase + reg_offset);\n}\n\nstatic void vt6655_mac_clear_stck_ds(void __iomem *iobase)\n{\n\tu8 reg_value;\n\n\treg_value = ioread8(iobase + MAC_REG_STICKHW);\n\treg_value = reg_value & 0xFC;\n\tiowrite8(reg_value, iobase + MAC_REG_STICKHW);\n}\n\n \nstatic bool vt6655_mac_is_reg_bits_off(struct vnt_private *priv,\n\t\t\t\t       unsigned char reg_offset,\n\t\t\t\t       unsigned char mask)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\n\treturn !(ioread8(io_base + reg_offset) & mask);\n}\n\n \nvoid vt6655_mac_set_short_retry_limit(struct vnt_private *priv, unsigned char retry_limit)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\t \n\tiowrite8(retry_limit, io_base + MAC_REG_SRT);\n}\n\n \nvoid MACvSetLongRetryLimit(struct vnt_private *priv,\n\t\t\t   unsigned char byRetryLimit)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\t \n\tiowrite8(byRetryLimit, io_base + MAC_REG_LRT);\n}\n\n \nstatic void vt6655_mac_set_loopback_mode(struct vnt_private *priv, u8 loopback_mode)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\n\tloopback_mode <<= 6;\n\t \n\tiowrite8((ioread8(io_base + MAC_REG_TEST) & 0x3f) | loopback_mode, io_base + MAC_REG_TEST);\n}\n\n \nstatic void vt6655_mac_save_context(struct vnt_private *priv, u8 *cxt_buf)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\n\t \n\tmemcpy_fromio(cxt_buf, io_base, MAC_MAX_CONTEXT_SIZE_PAGE0);\n\n\tVT6655_MAC_SELECT_PAGE1(io_base);\n\n\t \n\tmemcpy_fromio(cxt_buf + MAC_MAX_CONTEXT_SIZE_PAGE0, io_base,\n\t\t      MAC_MAX_CONTEXT_SIZE_PAGE1);\n\n\tVT6655_MAC_SELECT_PAGE0(io_base);\n}\n\n \nstatic void vt6655_mac_restore_context(struct vnt_private *priv, u8 *cxt_buf)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\n\tVT6655_MAC_SELECT_PAGE1(io_base);\n\t \n\tmemcpy_toio(io_base, cxt_buf + MAC_MAX_CONTEXT_SIZE_PAGE0,\n\t\t    MAC_MAX_CONTEXT_SIZE_PAGE1);\n\n\tVT6655_MAC_SELECT_PAGE0(io_base);\n\n\t \n\tmemcpy_toio(io_base + MAC_REG_RCR, cxt_buf + MAC_REG_RCR,\n\t\t    MAC_REG_ISR - MAC_REG_RCR);\n\n\t \n\tmemcpy_toio(io_base + MAC_REG_LRT, cxt_buf + MAC_REG_LRT,\n\t\t    MAC_REG_PAGE1SEL - MAC_REG_LRT);\n\n\tiowrite8(*(cxt_buf + MAC_REG_CFG), io_base + MAC_REG_CFG);\n\n\t \n\tmemcpy_toio(io_base + MAC_REG_PSCFG, cxt_buf + MAC_REG_PSCFG,\n\t\t    MAC_REG_BBREGCTL - MAC_REG_PSCFG);\n\n\t \n\tiowrite32(*(u32 *)(cxt_buf + MAC_REG_TXDMAPTR0),\n\t\t  io_base + MAC_REG_TXDMAPTR0);\n\tiowrite32(*(u32 *)(cxt_buf + MAC_REG_AC0DMAPTR),\n\t\t  io_base + MAC_REG_AC0DMAPTR);\n\tiowrite32(*(u32 *)(cxt_buf + MAC_REG_BCNDMAPTR),\n\t\t  io_base + MAC_REG_BCNDMAPTR);\n\tiowrite32(*(u32 *)(cxt_buf + MAC_REG_RXDMAPTR0),\n\t\t  io_base + MAC_REG_RXDMAPTR0);\n\tiowrite32(*(u32 *)(cxt_buf + MAC_REG_RXDMAPTR1),\n\t\t  io_base + MAC_REG_RXDMAPTR1);\n}\n\n \nbool MACbSoftwareReset(struct vnt_private *priv)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\tunsigned short ww;\n\n\t \n\tiowrite8(0x01, io_base + MAC_REG_HOSTCR);\n\n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tif (!(ioread8(io_base + MAC_REG_HOSTCR) & HOSTCR_SOFTRST))\n\t\t\tbreak;\n\t}\n\tif (ww == W_MAX_TIMEOUT)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic void vt6655_mac_save_soft_reset(struct vnt_private *priv)\n{\n\tu8 tmp_reg_data[MAC_MAX_CONTEXT_SIZE_PAGE0 + MAC_MAX_CONTEXT_SIZE_PAGE1];\n\n\t \n\t \n\tvt6655_mac_save_context(priv, tmp_reg_data);\n\t \n\tMACbSoftwareReset(priv);\n\t \n\tvt6655_mac_restore_context(priv, tmp_reg_data);\n}\n\n \nstatic bool vt6655_mac_safe_rx_off(struct vnt_private *priv)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\tunsigned short ww;\n\n\t \n\n\t \n\tiowrite32(DMACTL_CLRRUN, io_base + MAC_REG_RXDMACTL0);\n\tiowrite32(DMACTL_CLRRUN, io_base + MAC_REG_RXDMACTL1);\n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tif (!(ioread32(io_base + MAC_REG_RXDMACTL0) & DMACTL_RUN))\n\t\t\tbreak;\n\t}\n\tif (ww == W_MAX_TIMEOUT) {\n\t\tpr_debug(\" DBG_PORT80(0x10)\\n\");\n\t\treturn false;\n\t}\n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tif (!(ioread32(io_base + MAC_REG_RXDMACTL1) & DMACTL_RUN))\n\t\t\tbreak;\n\t}\n\tif (ww == W_MAX_TIMEOUT) {\n\t\tpr_debug(\" DBG_PORT80(0x11)\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tvt6655_mac_reg_bits_off(io_base, MAC_REG_HOSTCR, HOSTCR_RXON);\n\t \n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tif (!(ioread8(io_base + MAC_REG_HOSTCR) & HOSTCR_RXONST))\n\t\t\tbreak;\n\t}\n\tif (ww == W_MAX_TIMEOUT) {\n\t\tpr_debug(\" DBG_PORT80(0x12)\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic bool vt6655_mac_safe_tx_off(struct vnt_private *priv)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\tunsigned short ww;\n\n\t \n\t \n\tiowrite32(DMACTL_CLRRUN, io_base + MAC_REG_TXDMACTL0);\n\t \n\tiowrite32(DMACTL_CLRRUN, io_base + MAC_REG_AC0DMACTL);\n\n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tif (!(ioread32(io_base + MAC_REG_TXDMACTL0) & DMACTL_RUN))\n\t\t\tbreak;\n\t}\n\tif (ww == W_MAX_TIMEOUT) {\n\t\tpr_debug(\" DBG_PORT80(0x20)\\n\");\n\t\treturn false;\n\t}\n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tif (!(ioread32(io_base + MAC_REG_AC0DMACTL) & DMACTL_RUN))\n\t\t\tbreak;\n\t}\n\tif (ww == W_MAX_TIMEOUT) {\n\t\tpr_debug(\" DBG_PORT80(0x21)\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tvt6655_mac_reg_bits_off(io_base, MAC_REG_HOSTCR, HOSTCR_TXON);\n\n\t \n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tif (!(ioread8(io_base + MAC_REG_HOSTCR) & HOSTCR_TXONST))\n\t\t\tbreak;\n\t}\n\tif (ww == W_MAX_TIMEOUT) {\n\t\tpr_debug(\" DBG_PORT80(0x24)\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic bool vt6655_mac_safe_stop(struct vnt_private *priv)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\n\tvt6655_mac_reg_bits_off(io_base, MAC_REG_TCR, TCR_AUTOBCNTX);\n\n\tif (!vt6655_mac_safe_rx_off(priv)) {\n\t\tpr_debug(\" vt6655_mac_safe_rx_off == false)\\n\");\n\t\tvt6655_mac_save_soft_reset(priv);\n\t\treturn false;\n\t}\n\tif (!vt6655_mac_safe_tx_off(priv)) {\n\t\tpr_debug(\" vt6655_mac_safe_tx_off == false)\\n\");\n\t\tvt6655_mac_save_soft_reset(priv);\n\t\treturn false;\n\t}\n\n\tvt6655_mac_reg_bits_off(io_base, MAC_REG_HOSTCR, HOSTCR_MACEN);\n\n\treturn true;\n}\n\n \nbool MACbShutdown(struct vnt_private *priv)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\t \n\tiowrite32(0, io_base + MAC_REG_IMR);\n\tvt6655_mac_set_loopback_mode(priv, MAC_LB_INTERNAL);\n\t \n\tif (!vt6655_mac_safe_stop(priv)) {\n\t\tvt6655_mac_set_loopback_mode(priv, MAC_LB_NONE);\n\t\treturn false;\n\t}\n\tvt6655_mac_set_loopback_mode(priv, MAC_LB_NONE);\n\treturn true;\n}\n\n \nvoid MACvInitialize(struct vnt_private *priv)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\t \n\tvt6655_mac_clear_stck_ds(io_base);\n\t \n\tiowrite8(PME_OVR, io_base + MAC_REG_PMC1);\n\t \n\n\t \n\tMACbSoftwareReset(priv);\n\n\t \n\tiowrite8(TFTCTL_TSFCNTRST, io_base + MAC_REG_TFTCTL);\n\t \n\tiowrite8(TFTCTL_TSFCNTREN, io_base + MAC_REG_TFTCTL);\n}\n\n \nvoid vt6655_mac_set_curr_rx_0_desc_addr(struct vnt_private *priv, u32 curr_desc_addr)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\tunsigned short ww;\n\tunsigned char org_dma_ctl;\n\n\torg_dma_ctl = ioread8(io_base + MAC_REG_RXDMACTL0);\n\tif (org_dma_ctl & DMACTL_RUN)\n\t\tiowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL0 + 2);\n\n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tif (!(ioread8(io_base + MAC_REG_RXDMACTL0) & DMACTL_RUN))\n\t\t\tbreak;\n\t}\n\n\tiowrite32(curr_desc_addr, io_base + MAC_REG_RXDMAPTR0);\n\tif (org_dma_ctl & DMACTL_RUN)\n\t\tiowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL0);\n}\n\n \nvoid vt6655_mac_set_curr_rx_1_desc_addr(struct vnt_private *priv, u32 curr_desc_addr)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\tunsigned short ww;\n\tunsigned char org_dma_ctl;\n\n\torg_dma_ctl = ioread8(io_base + MAC_REG_RXDMACTL1);\n\tif (org_dma_ctl & DMACTL_RUN)\n\t\tiowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL1 + 2);\n\n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tif (!(ioread8(io_base + MAC_REG_RXDMACTL1) & DMACTL_RUN))\n\t\t\tbreak;\n\t}\n\n\tiowrite32(curr_desc_addr, io_base + MAC_REG_RXDMAPTR1);\n\tif (org_dma_ctl & DMACTL_RUN)\n\t\tiowrite8(DMACTL_RUN, io_base + MAC_REG_RXDMACTL1);\n}\n\n \nstatic void vt6655_mac_set_curr_tx_0_desc_addr_ex(struct vnt_private *priv, u32 curr_desc_addr)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\tunsigned short ww;\n\tunsigned char org_dma_ctl;\n\n\torg_dma_ctl = ioread8(io_base + MAC_REG_TXDMACTL0);\n\tif (org_dma_ctl & DMACTL_RUN)\n\t\tiowrite8(DMACTL_RUN, io_base + MAC_REG_TXDMACTL0 + 2);\n\n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tif (!(ioread8(io_base + MAC_REG_TXDMACTL0) & DMACTL_RUN))\n\t\t\tbreak;\n\t}\n\n\tiowrite32(curr_desc_addr, io_base + MAC_REG_TXDMAPTR0);\n\tif (org_dma_ctl & DMACTL_RUN)\n\t\tiowrite8(DMACTL_RUN, io_base + MAC_REG_TXDMACTL0);\n}\n\n \n \nstatic void vt6655_mac_set_curr_ac_0_desc_addr_ex(struct vnt_private *priv, u32 curr_desc_addr)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\tunsigned short ww;\n\tunsigned char org_dma_ctl;\n\n\torg_dma_ctl = ioread8(io_base + MAC_REG_AC0DMACTL);\n\tif (org_dma_ctl & DMACTL_RUN)\n\t\tiowrite8(DMACTL_RUN, io_base + MAC_REG_AC0DMACTL + 2);\n\n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tif (!(ioread8(io_base + MAC_REG_AC0DMACTL) & DMACTL_RUN))\n\t\t\tbreak;\n\t}\n\tif (ww == W_MAX_TIMEOUT)\n\t\tpr_debug(\" DBG_PORT80(0x26)\\n\");\n\tiowrite32(curr_desc_addr, io_base + MAC_REG_AC0DMAPTR);\n\tif (org_dma_ctl & DMACTL_RUN)\n\t\tiowrite8(DMACTL_RUN, io_base + MAC_REG_AC0DMACTL);\n}\n\nvoid vt6655_mac_set_curr_tx_desc_addr(int tx_type, struct vnt_private *priv, u32 curr_desc_addr)\n{\n\tif (tx_type == TYPE_AC0DMA)\n\t\tvt6655_mac_set_curr_ac_0_desc_addr_ex(priv, curr_desc_addr);\n\telse if (tx_type == TYPE_TXDMA0)\n\t\tvt6655_mac_set_curr_tx_0_desc_addr_ex(priv, curr_desc_addr);\n}\n\n \nvoid MACvTimer0MicroSDelay(struct vnt_private *priv, unsigned int uDelay)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\tunsigned char byValue;\n\tunsigned int uu, ii;\n\n\tiowrite8(0, io_base + MAC_REG_TMCTL0);\n\tiowrite32(uDelay, io_base + MAC_REG_TMDATA0);\n\tiowrite8((TMCTL_TMD | TMCTL_TE), io_base + MAC_REG_TMCTL0);\n\tfor (ii = 0; ii < 66; ii++) {   \n\t\tfor (uu = 0; uu < uDelay; uu++) {\n\t\t\tbyValue = ioread8(io_base + MAC_REG_TMCTL0);\n\t\t\tif ((byValue == 0) ||\n\t\t\t    (byValue & TMCTL_TSUSP)) {\n\t\t\t\tiowrite8(0, io_base + MAC_REG_TMCTL0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tiowrite8(0, io_base + MAC_REG_TMCTL0);\n}\n\n \nvoid MACvOneShotTimer1MicroSec(struct vnt_private *priv,\n\t\t\t       unsigned int uDelayTime)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\n\tiowrite8(0, io_base + MAC_REG_TMCTL1);\n\tiowrite32(uDelayTime, io_base + MAC_REG_TMDATA1);\n\tiowrite8((TMCTL_TMD | TMCTL_TE), io_base + MAC_REG_TMCTL1);\n}\n\nvoid MACvSetMISCFifo(struct vnt_private *priv, unsigned short offset,\n\t\t     u32 data)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\n\tif (offset > 273)\n\t\treturn;\n\tiowrite16(offset, io_base + MAC_REG_MISCFFNDEX);\n\tiowrite32(data, io_base + MAC_REG_MISCFFDATA);\n\tiowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);\n}\n\nbool MACbPSWakeup(struct vnt_private *priv)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\tunsigned int ww;\n\t \n\tif (vt6655_mac_is_reg_bits_off(priv, MAC_REG_PSCTL, PSCTL_PS))\n\t\treturn true;\n\n\t \n\tvt6655_mac_reg_bits_off(io_base, MAC_REG_PSCTL, PSCTL_PSEN);\n\n\t \n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tif (ioread8(io_base + MAC_REG_PSCTL) & PSCTL_WAKEDONE)\n\t\t\tbreak;\n\t}\n\tif (ww == W_MAX_TIMEOUT) {\n\t\tpr_debug(\" DBG_PORT80(0x33)\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \n\nvoid MACvSetKeyEntry(struct vnt_private *priv, unsigned short wKeyCtl,\n\t\t     unsigned int uEntryIdx, unsigned int uKeyIdx,\n\t\t     unsigned char *pbyAddr, u32 *pdwKey,\n\t\t     unsigned char local_id)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\tunsigned short offset;\n\tu32 data;\n\tint     ii;\n\n\tif (local_id <= 1)\n\t\treturn;\n\n\toffset = MISCFIFO_KEYETRY0;\n\toffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);\n\n\tdata = 0;\n\tdata |= wKeyCtl;\n\tdata <<= 16;\n\tdata |= MAKEWORD(*(pbyAddr + 4), *(pbyAddr + 5));\n\tpr_debug(\"1. offset: %d, Data: %X, KeyCtl:%X\\n\",\n\t\t offset, data, wKeyCtl);\n\n\tiowrite16(offset, io_base + MAC_REG_MISCFFNDEX);\n\tiowrite32(data, io_base + MAC_REG_MISCFFDATA);\n\tiowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);\n\toffset++;\n\n\tdata = 0;\n\tdata |= *(pbyAddr + 3);\n\tdata <<= 8;\n\tdata |= *(pbyAddr + 2);\n\tdata <<= 8;\n\tdata |= *(pbyAddr + 1);\n\tdata <<= 8;\n\tdata |= *pbyAddr;\n\tpr_debug(\"2. offset: %d, Data: %X\\n\", offset, data);\n\n\tiowrite16(offset, io_base + MAC_REG_MISCFFNDEX);\n\tiowrite32(data, io_base + MAC_REG_MISCFFDATA);\n\tiowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);\n\toffset++;\n\n\toffset += (uKeyIdx * 4);\n\tfor (ii = 0; ii < 4; ii++) {\n\t\t \n\t\tpr_debug(\"3.(%d) offset: %d, Data: %X\\n\",\n\t\t\t ii, offset + ii, *pdwKey);\n\t\tiowrite16(offset + ii, io_base + MAC_REG_MISCFFNDEX);\n\t\tiowrite32(*pdwKey++, io_base + MAC_REG_MISCFFDATA);\n\t\tiowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);\n\t}\n}\n\n \nvoid MACvDisableKeyEntry(struct vnt_private *priv, unsigned int uEntryIdx)\n{\n\tvoid __iomem *io_base = priv->port_offset;\n\tunsigned short offset;\n\n\toffset = MISCFIFO_KEYETRY0;\n\toffset += (uEntryIdx * MISCFIFO_KEYENTRYSIZE);\n\n\tiowrite16(offset, io_base + MAC_REG_MISCFFNDEX);\n\tiowrite32(0, io_base + MAC_REG_MISCFFDATA);\n\tiowrite16(MISCFFCTL_WRITE, io_base + MAC_REG_MISCFFCTL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}