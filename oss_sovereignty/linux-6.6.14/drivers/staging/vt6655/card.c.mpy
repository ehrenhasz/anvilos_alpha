{
  "module_name": "card.c",
  "hash_id": "e7b4b1dbf8ad364d4caa73345207f051cfcf05994d1918f8b137dcde91c211f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vt6655/card.c",
  "human_readable_source": "\n \n\n#include \"card.h\"\n#include \"baseband.h\"\n#include \"mac.h\"\n#include \"desc.h\"\n#include \"rf.h\"\n#include \"power.h\"\n\n \n\n#define C_SIFS_A        16       \n#define C_SIFS_BG       10\n\n#define C_EIFS          80       \n\n#define C_SLOT_SHORT    9        \n#define C_SLOT_LONG     20\n\n#define C_CWMIN_A       15       \n#define C_CWMIN_B       31\n\n#define C_CWMAX         1023     \n\n#define WAIT_BEACON_TX_DOWN_TMO         3     \n\n \n\nstatic const unsigned short cwRXBCNTSFOff[MAX_RATE] = {\n\t17, 17, 17, 17, 34, 23, 17, 11, 8, 5, 4, 3};\n\n \n\nstatic void vt6655_mac_set_bb_type(void __iomem *iobase, u32 mask)\n{\n\tu32 reg_value;\n\n\treg_value = ioread32(iobase + MAC_REG_ENCFG);\n\treg_value = reg_value & ~ENCFG_BBTYPE_MASK;\n\treg_value = reg_value | mask;\n\tiowrite32(reg_value, iobase + MAC_REG_ENCFG);\n}\n\n \n\n \nstatic void s_vCalculateOFDMRParameter(unsigned char rate,\n\t\t\t\t       u8 bb_type,\n\t\t\t\t       unsigned char *pbyTxRate,\n\t\t\t\t       unsigned char *pbyRsvTime)\n{\n\tswitch (rate) {\n\tcase RATE_6M:\n\t\tif (bb_type == BB_TYPE_11A) {  \n\t\t\t*pbyTxRate = 0x9B;\n\t\t\t*pbyRsvTime = 44;\n\t\t} else {\n\t\t\t*pbyTxRate = 0x8B;\n\t\t\t*pbyRsvTime = 50;\n\t\t}\n\t\tbreak;\n\n\tcase RATE_9M:\n\t\tif (bb_type == BB_TYPE_11A) {  \n\t\t\t*pbyTxRate = 0x9F;\n\t\t\t*pbyRsvTime = 36;\n\t\t} else {\n\t\t\t*pbyTxRate = 0x8F;\n\t\t\t*pbyRsvTime = 42;\n\t\t}\n\t\tbreak;\n\n\tcase RATE_12M:\n\t\tif (bb_type == BB_TYPE_11A) {  \n\t\t\t*pbyTxRate = 0x9A;\n\t\t\t*pbyRsvTime = 32;\n\t\t} else {\n\t\t\t*pbyTxRate = 0x8A;\n\t\t\t*pbyRsvTime = 38;\n\t\t}\n\t\tbreak;\n\n\tcase RATE_18M:\n\t\tif (bb_type == BB_TYPE_11A) {  \n\t\t\t*pbyTxRate = 0x9E;\n\t\t\t*pbyRsvTime = 28;\n\t\t} else {\n\t\t\t*pbyTxRate = 0x8E;\n\t\t\t*pbyRsvTime = 34;\n\t\t}\n\t\tbreak;\n\n\tcase RATE_36M:\n\t\tif (bb_type == BB_TYPE_11A) {  \n\t\t\t*pbyTxRate = 0x9D;\n\t\t\t*pbyRsvTime = 24;\n\t\t} else {\n\t\t\t*pbyTxRate = 0x8D;\n\t\t\t*pbyRsvTime = 30;\n\t\t}\n\t\tbreak;\n\n\tcase RATE_48M:\n\t\tif (bb_type == BB_TYPE_11A) {  \n\t\t\t*pbyTxRate = 0x98;\n\t\t\t*pbyRsvTime = 24;\n\t\t} else {\n\t\t\t*pbyTxRate = 0x88;\n\t\t\t*pbyRsvTime = 30;\n\t\t}\n\t\tbreak;\n\n\tcase RATE_54M:\n\t\tif (bb_type == BB_TYPE_11A) {  \n\t\t\t*pbyTxRate = 0x9C;\n\t\t\t*pbyRsvTime = 24;\n\t\t} else {\n\t\t\t*pbyTxRate = 0x8C;\n\t\t\t*pbyRsvTime = 30;\n\t\t}\n\t\tbreak;\n\n\tcase RATE_24M:\n\tdefault:\n\t\tif (bb_type == BB_TYPE_11A) {  \n\t\t\t*pbyTxRate = 0x99;\n\t\t\t*pbyRsvTime = 28;\n\t\t} else {\n\t\t\t*pbyTxRate = 0x89;\n\t\t\t*pbyRsvTime = 34;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \n\n \nbool CARDbSetPhyParameter(struct vnt_private *priv, u8 bb_type)\n{\n\tunsigned char byCWMaxMin = 0;\n\tunsigned char bySlot = 0;\n\tunsigned char bySIFS = 0;\n\tunsigned char byDIFS = 0;\n\tint i;\n\n\t \n\tif (bb_type == BB_TYPE_11A) {\n\t\tvt6655_mac_set_bb_type(priv->port_offset, BB_TYPE_11A);\n\t\tbb_write_embedded(priv, 0x88, 0x03);\n\t\tbySlot = C_SLOT_SHORT;\n\t\tbySIFS = C_SIFS_A;\n\t\tbyDIFS = C_SIFS_A + 2 * C_SLOT_SHORT;\n\t\tbyCWMaxMin = 0xA4;\n\t} else if (bb_type == BB_TYPE_11B) {\n\t\tvt6655_mac_set_bb_type(priv->port_offset, BB_TYPE_11B);\n\t\tbb_write_embedded(priv, 0x88, 0x02);\n\t\tbySlot = C_SLOT_LONG;\n\t\tbySIFS = C_SIFS_BG;\n\t\tbyDIFS = C_SIFS_BG + 2 * C_SLOT_LONG;\n\t\tbyCWMaxMin = 0xA5;\n\t} else {  \n\t\tvt6655_mac_set_bb_type(priv->port_offset, BB_TYPE_11G);\n\t\tbb_write_embedded(priv, 0x88, 0x08);\n\t\tbySIFS = C_SIFS_BG;\n\n\t\tif (priv->short_slot_time) {\n\t\t\tbySlot = C_SLOT_SHORT;\n\t\t\tbyDIFS = C_SIFS_BG + 2 * C_SLOT_SHORT;\n\t\t} else {\n\t\t\tbySlot = C_SLOT_LONG;\n\t\t\tbyDIFS = C_SIFS_BG + 2 * C_SLOT_LONG;\n\t\t}\n\n\t\tbyCWMaxMin = 0xa4;\n\n\t\tfor (i = RATE_54M; i >= RATE_6M; i--) {\n\t\t\tif (priv->basic_rates & ((u32)(0x1 << i))) {\n\t\t\t\tbyCWMaxMin |= 0x1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (priv->byRFType == RF_RFMD2959) {\n\t\t \n\t\tbySIFS -= 3;\n\t\tbyDIFS -= 3;\n\t\t \n\t}\n\n\tif (priv->bySIFS != bySIFS) {\n\t\tpriv->bySIFS = bySIFS;\n\t\tiowrite8(priv->bySIFS, priv->port_offset + MAC_REG_SIFS);\n\t}\n\tif (priv->byDIFS != byDIFS) {\n\t\tpriv->byDIFS = byDIFS;\n\t\tiowrite8(priv->byDIFS, priv->port_offset + MAC_REG_DIFS);\n\t}\n\tif (priv->byEIFS != C_EIFS) {\n\t\tpriv->byEIFS = C_EIFS;\n\t\tiowrite8(priv->byEIFS, priv->port_offset + MAC_REG_EIFS);\n\t}\n\tif (priv->bySlot != bySlot) {\n\t\tpriv->bySlot = bySlot;\n\t\tiowrite8(priv->bySlot, priv->port_offset + MAC_REG_SLOT);\n\n\t\tbb_set_short_slot_time(priv);\n\t}\n\tif (priv->byCWMaxMin != byCWMaxMin) {\n\t\tpriv->byCWMaxMin = byCWMaxMin;\n\t\tiowrite8(priv->byCWMaxMin, priv->port_offset + MAC_REG_CWMAXMIN0);\n\t}\n\n\tpriv->byPacketType = CARDbyGetPktType(priv);\n\n\tCARDvSetRSPINF(priv, bb_type);\n\n\treturn true;\n}\n\n \nbool CARDbUpdateTSF(struct vnt_private *priv, unsigned char byRxRate,\n\t\t    u64 qwBSSTimestamp)\n{\n\tu64 local_tsf;\n\tu64 qwTSFOffset = 0;\n\n\tlocal_tsf = vt6655_get_current_tsf(priv);\n\n\tif (qwBSSTimestamp != local_tsf) {\n\t\tqwTSFOffset = CARDqGetTSFOffset(byRxRate, qwBSSTimestamp,\n\t\t\t\t\t\tlocal_tsf);\n\t\t \n\t\tqwTSFOffset =  le64_to_cpu(qwTSFOffset);\n\t\tiowrite32((u32)qwTSFOffset, priv->port_offset + MAC_REG_TSFOFST);\n\t\tiowrite32((u32)(qwTSFOffset >> 32), priv->port_offset + MAC_REG_TSFOFST + 4);\n\t\tvt6655_mac_reg_bits_on(priv->port_offset, MAC_REG_TFTCTL, TFTCTL_TSFSYNCEN);\n\t}\n\treturn true;\n}\n\n \nbool CARDbSetBeaconPeriod(struct vnt_private *priv,\n\t\t\t  unsigned short wBeaconInterval)\n{\n\tu64 qwNextTBTT;\n\n\tqwNextTBTT = vt6655_get_current_tsf(priv);  \n\n\tqwNextTBTT = CARDqGetNextTBTT(qwNextTBTT, wBeaconInterval);\n\n\t \n\tiowrite16(wBeaconInterval, priv->port_offset + MAC_REG_BI);\n\tpriv->wBeaconInterval = wBeaconInterval;\n\t \n\tqwNextTBTT =  le64_to_cpu(qwNextTBTT);\n\tiowrite32((u32)qwNextTBTT, priv->port_offset + MAC_REG_NEXTTBTT);\n\tiowrite32((u32)(qwNextTBTT >> 32), priv->port_offset + MAC_REG_NEXTTBTT + 4);\n\tvt6655_mac_reg_bits_on(priv->port_offset, MAC_REG_TFTCTL, TFTCTL_TBTTSYNCEN);\n\n\treturn true;\n}\n\n \nvoid CARDbRadioPowerOff(struct vnt_private *priv)\n{\n\tif (priv->radio_off)\n\t\treturn;\n\n\tswitch (priv->byRFType) {\n\tcase RF_RFMD2959:\n\t\tvt6655_mac_word_reg_bits_off(priv->port_offset, MAC_REG_SOFTPWRCTL,\n\t\t\t\t\t     SOFTPWRCTL_TXPEINV);\n\t\tvt6655_mac_word_reg_bits_on(priv->port_offset, MAC_REG_SOFTPWRCTL,\n\t\t\t\t\t    SOFTPWRCTL_SWPE1);\n\t\tbreak;\n\n\tcase RF_AIROHA:\n\tcase RF_AL2230S:\n\t\tvt6655_mac_word_reg_bits_off(priv->port_offset, MAC_REG_SOFTPWRCTL,\n\t\t\t\t\t     SOFTPWRCTL_SWPE2);\n\t\tvt6655_mac_word_reg_bits_off(priv->port_offset, MAC_REG_SOFTPWRCTL,\n\t\t\t\t\t     SOFTPWRCTL_SWPE3);\n\t\tbreak;\n\t}\n\n\tvt6655_mac_reg_bits_off(priv->port_offset, MAC_REG_HOSTCR, HOSTCR_RXON);\n\n\tbb_set_deep_sleep(priv, priv->local_id);\n\n\tpriv->radio_off = true;\n\tpr_debug(\"chester power off\\n\");\n\tvt6655_mac_reg_bits_on(priv->port_offset, MAC_REG_GPIOCTL0, LED_ACTSET);   \n}\n\nvoid CARDvSafeResetTx(struct vnt_private *priv)\n{\n\tunsigned int uu;\n\tstruct vnt_tx_desc *pCurrTD;\n\n\t \n\tpriv->apTailTD[0] = &priv->apTD0Rings[0];\n\tpriv->apCurrTD[0] = &priv->apTD0Rings[0];\n\n\tpriv->apTailTD[1] = &priv->apTD1Rings[0];\n\tpriv->apCurrTD[1] = &priv->apTD1Rings[0];\n\n\tfor (uu = 0; uu < TYPE_MAXTD; uu++)\n\t\tpriv->iTDUsed[uu] = 0;\n\n\tfor (uu = 0; uu < priv->opts.tx_descs[0]; uu++) {\n\t\tpCurrTD = &priv->apTD0Rings[uu];\n\t\tpCurrTD->td0.owner = OWNED_BY_HOST;\n\t\t \n\t}\n\tfor (uu = 0; uu < priv->opts.tx_descs[1]; uu++) {\n\t\tpCurrTD = &priv->apTD1Rings[uu];\n\t\tpCurrTD->td0.owner = OWNED_BY_HOST;\n\t\t \n\t}\n\n\t \n\tvt6655_mac_set_curr_tx_desc_addr(TYPE_TXDMA0, priv, priv->td0_pool_dma);\n\n\tvt6655_mac_set_curr_tx_desc_addr(TYPE_AC0DMA, priv, priv->td1_pool_dma);\n\n\t \n\tiowrite32((u32)priv->tx_beacon_dma, priv->port_offset + MAC_REG_BCNDMAPTR);\n}\n\n \nvoid CARDvSafeResetRx(struct vnt_private *priv)\n{\n\tunsigned int uu;\n\tstruct vnt_rx_desc *pDesc;\n\n\t \n\tpriv->pCurrRD[0] = &priv->aRD0Ring[0];\n\tpriv->pCurrRD[1] = &priv->aRD1Ring[0];\n\n\t \n\tfor (uu = 0; uu < priv->opts.rx_descs0; uu++) {\n\t\tpDesc = &priv->aRD0Ring[uu];\n\t\tpDesc->rd0.res_count = cpu_to_le16(priv->rx_buf_sz);\n\t\tpDesc->rd0.owner = OWNED_BY_NIC;\n\t\tpDesc->rd1.req_count = cpu_to_le16(priv->rx_buf_sz);\n\t}\n\n\t \n\tfor (uu = 0; uu < priv->opts.rx_descs1; uu++) {\n\t\tpDesc = &priv->aRD1Ring[uu];\n\t\tpDesc->rd0.res_count = cpu_to_le16(priv->rx_buf_sz);\n\t\tpDesc->rd0.owner = OWNED_BY_NIC;\n\t\tpDesc->rd1.req_count = cpu_to_le16(priv->rx_buf_sz);\n\t}\n\n\t \n\tiowrite32(RX_PERPKT, priv->port_offset + MAC_REG_RXDMACTL0);\n\tiowrite32(RX_PERPKT, priv->port_offset + MAC_REG_RXDMACTL1);\n\t \n\tvt6655_mac_set_curr_rx_0_desc_addr(priv, priv->rd0_pool_dma);\n\n\tvt6655_mac_set_curr_rx_1_desc_addr(priv, priv->rd1_pool_dma);\n}\n\n \nstatic unsigned short CARDwGetCCKControlRate(struct vnt_private *priv,\n\t\t\t\t\t     unsigned short wRateIdx)\n{\n\tunsigned int ui = (unsigned int)wRateIdx;\n\n\twhile (ui > RATE_1M) {\n\t\tif (priv->basic_rates & ((u32)0x1 << ui))\n\t\t\treturn (unsigned short)ui;\n\n\t\tui--;\n\t}\n\treturn (unsigned short)RATE_1M;\n}\n\n \nstatic unsigned short CARDwGetOFDMControlRate(struct vnt_private *priv,\n\t\t\t\t\t      unsigned short wRateIdx)\n{\n\tunsigned int ui = (unsigned int)wRateIdx;\n\n\tpr_debug(\"BASIC RATE: %X\\n\", priv->basic_rates);\n\n\tif (!CARDbIsOFDMinBasicRate((void *)priv)) {\n\t\tpr_debug(\"%s:(NO OFDM) %d\\n\", __func__, wRateIdx);\n\t\tif (wRateIdx > RATE_24M)\n\t\t\twRateIdx = RATE_24M;\n\t\treturn wRateIdx;\n\t}\n\twhile (ui > RATE_11M) {\n\t\tif (priv->basic_rates & ((u32)0x1 << ui)) {\n\t\t\tpr_debug(\"%s : %d\\n\", __func__, ui);\n\t\t\treturn (unsigned short)ui;\n\t\t}\n\t\tui--;\n\t}\n\tpr_debug(\"%s: 6M\\n\", __func__);\n\treturn (unsigned short)RATE_24M;\n}\n\n \nvoid CARDvSetRSPINF(struct vnt_private *priv, u8 bb_type)\n{\n\tunion vnt_phy_field_swap phy;\n\tunsigned char byTxRate, byRsvTime;       \n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t \n\tVT6655_MAC_SELECT_PAGE1(priv->port_offset);\n\n\t \n\tvnt_get_phy_field(priv, 14,\n\t\t\t  CARDwGetCCKControlRate(priv, RATE_1M),\n\t\t\t  PK_TYPE_11B, &phy.field_read);\n\n\t  \n\tswap(phy.swap[0], phy.swap[1]);\n\n\tiowrite32(phy.field_write, priv->port_offset + MAC_REG_RSPINF_B_1);\n\n\t \n\tvnt_get_phy_field(priv, 14,\n\t\t\t  CARDwGetCCKControlRate(priv, RATE_2M),\n\t\t\t  PK_TYPE_11B, &phy.field_read);\n\n\tswap(phy.swap[0], phy.swap[1]);\n\n\tiowrite32(phy.field_write, priv->port_offset + MAC_REG_RSPINF_B_2);\n\n\t \n\tvnt_get_phy_field(priv, 14,\n\t\t\t  CARDwGetCCKControlRate(priv, RATE_5M),\n\t\t\t  PK_TYPE_11B, &phy.field_read);\n\n\tswap(phy.swap[0], phy.swap[1]);\n\n\tiowrite32(phy.field_write, priv->port_offset + MAC_REG_RSPINF_B_5);\n\n\t \n\tvnt_get_phy_field(priv, 14,\n\t\t\t  CARDwGetCCKControlRate(priv, RATE_11M),\n\t\t\t  PK_TYPE_11B, &phy.field_read);\n\n\tswap(phy.swap[0], phy.swap[1]);\n\n\tiowrite32(phy.field_write, priv->port_offset + MAC_REG_RSPINF_B_11);\n\n\t \n\ts_vCalculateOFDMRParameter(RATE_6M,\n\t\t\t\t   bb_type,\n\t\t\t\t   &byTxRate,\n\t\t\t\t   &byRsvTime);\n\tiowrite16(MAKEWORD(byTxRate, byRsvTime), priv->port_offset + MAC_REG_RSPINF_A_6);\n\t \n\ts_vCalculateOFDMRParameter(RATE_9M,\n\t\t\t\t   bb_type,\n\t\t\t\t   &byTxRate,\n\t\t\t\t   &byRsvTime);\n\tiowrite16(MAKEWORD(byTxRate, byRsvTime), priv->port_offset + MAC_REG_RSPINF_A_9);\n\t \n\ts_vCalculateOFDMRParameter(RATE_12M,\n\t\t\t\t   bb_type,\n\t\t\t\t   &byTxRate,\n\t\t\t\t   &byRsvTime);\n\tiowrite16(MAKEWORD(byTxRate, byRsvTime), priv->port_offset + MAC_REG_RSPINF_A_12);\n\t \n\ts_vCalculateOFDMRParameter(RATE_18M,\n\t\t\t\t   bb_type,\n\t\t\t\t   &byTxRate,\n\t\t\t\t   &byRsvTime);\n\tiowrite16(MAKEWORD(byTxRate, byRsvTime), priv->port_offset + MAC_REG_RSPINF_A_18);\n\t \n\ts_vCalculateOFDMRParameter(RATE_24M,\n\t\t\t\t   bb_type,\n\t\t\t\t   &byTxRate,\n\t\t\t\t   &byRsvTime);\n\tiowrite16(MAKEWORD(byTxRate, byRsvTime), priv->port_offset + MAC_REG_RSPINF_A_24);\n\t \n\ts_vCalculateOFDMRParameter(CARDwGetOFDMControlRate((void *)priv,\n\t\t\t\t\t\t\t   RATE_36M),\n\t\t\t\t   bb_type,\n\t\t\t\t   &byTxRate,\n\t\t\t\t   &byRsvTime);\n\tiowrite16(MAKEWORD(byTxRate, byRsvTime), priv->port_offset + MAC_REG_RSPINF_A_36);\n\t \n\ts_vCalculateOFDMRParameter(CARDwGetOFDMControlRate((void *)priv,\n\t\t\t\t\t\t\t   RATE_48M),\n\t\t\t\t   bb_type,\n\t\t\t\t   &byTxRate,\n\t\t\t\t   &byRsvTime);\n\tiowrite16(MAKEWORD(byTxRate, byRsvTime), priv->port_offset + MAC_REG_RSPINF_A_48);\n\t \n\ts_vCalculateOFDMRParameter(CARDwGetOFDMControlRate((void *)priv,\n\t\t\t\t\t\t\t   RATE_54M),\n\t\t\t\t   bb_type,\n\t\t\t\t   &byTxRate,\n\t\t\t\t   &byRsvTime);\n\tiowrite16(MAKEWORD(byTxRate, byRsvTime), priv->port_offset + MAC_REG_RSPINF_A_54);\n\t \n\ts_vCalculateOFDMRParameter(CARDwGetOFDMControlRate((void *)priv,\n\t\t\t\t\t\t\t   RATE_54M),\n\t\t\t\t   bb_type,\n\t\t\t\t   &byTxRate,\n\t\t\t\t   &byRsvTime);\n\tiowrite16(MAKEWORD(byTxRate, byRsvTime), priv->port_offset + MAC_REG_RSPINF_A_72);\n\t \n\tVT6655_MAC_SELECT_PAGE0(priv->port_offset);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nvoid CARDvUpdateBasicTopRate(struct vnt_private *priv)\n{\n\tunsigned char byTopOFDM = RATE_24M, byTopCCK = RATE_1M;\n\tunsigned char ii;\n\n\t \n\tfor (ii = RATE_54M; ii >= RATE_6M; ii--) {\n\t\tif ((priv->basic_rates) & ((u32)(1 << ii))) {\n\t\t\tbyTopOFDM = ii;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpriv->byTopOFDMBasicRate = byTopOFDM;\n\n\tfor (ii = RATE_11M;; ii--) {\n\t\tif ((priv->basic_rates) & ((u32)(1 << ii))) {\n\t\t\tbyTopCCK = ii;\n\t\t\tbreak;\n\t\t}\n\t\tif (ii == RATE_1M)\n\t\t\tbreak;\n\t}\n\tpriv->byTopCCKBasicRate = byTopCCK;\n}\n\nbool CARDbIsOFDMinBasicRate(struct vnt_private *priv)\n{\n\tint ii;\n\n\tfor (ii = RATE_54M; ii >= RATE_6M; ii--) {\n\t\tif ((priv->basic_rates) & ((u32)BIT(ii)))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nunsigned char CARDbyGetPktType(struct vnt_private *priv)\n{\n\tif (priv->byBBType == BB_TYPE_11A || priv->byBBType == BB_TYPE_11B)\n\t\treturn (unsigned char)priv->byBBType;\n\telse if (CARDbIsOFDMinBasicRate((void *)priv))\n\t\treturn PK_TYPE_11GA;\n\telse\n\t\treturn PK_TYPE_11GB;\n}\n\n \nu64 CARDqGetTSFOffset(unsigned char byRxRate, u64 qwTSF1, u64 qwTSF2)\n{\n\tunsigned short wRxBcnTSFOffst;\n\n\twRxBcnTSFOffst = cwRXBCNTSFOff[byRxRate % MAX_RATE];\n\n\tqwTSF2 += (u64)wRxBcnTSFOffst;\n\n\treturn qwTSF1 - qwTSF2;\n}\n\n \nu64 vt6655_get_current_tsf(struct vnt_private *priv)\n{\n\tvoid __iomem *iobase = priv->port_offset;\n\tunsigned short ww;\n\tunsigned char data;\n\tu32 low, high;\n\n\tvt6655_mac_reg_bits_on(iobase, MAC_REG_TFTCTL, TFTCTL_TSFCNTRRD);\n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tdata = ioread8(iobase + MAC_REG_TFTCTL);\n\t\tif (!(data & TFTCTL_TSFCNTRRD))\n\t\t\tbreak;\n\t}\n\tif (ww == W_MAX_TIMEOUT)\n\t\treturn 0;\n\tlow = ioread32(iobase + MAC_REG_TSFCNTR);\n\thigh = ioread32(iobase + MAC_REG_TSFCNTR + 4);\n\treturn le64_to_cpu(low + ((u64)high << 32));\n}\n\n \nu64 CARDqGetNextTBTT(u64 qwTSF, unsigned short wBeaconInterval)\n{\n\tu32 beacon_int;\n\n\tbeacon_int = wBeaconInterval * 1024;\n\tif (beacon_int) {\n\t\tdo_div(qwTSF, beacon_int);\n\t\tqwTSF += 1;\n\t\tqwTSF *= beacon_int;\n\t}\n\n\treturn qwTSF;\n}\n\n \nvoid CARDvSetFirstNextTBTT(struct vnt_private *priv,\n\t\t\t   unsigned short wBeaconInterval)\n{\n\tvoid __iomem *iobase = priv->port_offset;\n\tu64 qwNextTBTT;\n\n\tqwNextTBTT = vt6655_get_current_tsf(priv);  \n\n\tqwNextTBTT = CARDqGetNextTBTT(qwNextTBTT, wBeaconInterval);\n\t \n\tqwNextTBTT =  le64_to_cpu(qwNextTBTT);\n\tiowrite32((u32)qwNextTBTT, iobase + MAC_REG_NEXTTBTT);\n\tiowrite32((u32)(qwNextTBTT >> 32), iobase + MAC_REG_NEXTTBTT + 4);\n\tvt6655_mac_reg_bits_on(iobase, MAC_REG_TFTCTL, TFTCTL_TBTTSYNCEN);\n}\n\n \nvoid CARDvUpdateNextTBTT(struct vnt_private *priv, u64 qwTSF,\n\t\t\t unsigned short wBeaconInterval)\n{\n\tvoid __iomem *iobase = priv->port_offset;\n\n\tqwTSF = CARDqGetNextTBTT(qwTSF, wBeaconInterval);\n\t \n\tqwTSF =  le64_to_cpu(qwTSF);\n\tiowrite32((u32)qwTSF, iobase + MAC_REG_NEXTTBTT);\n\tiowrite32((u32)(qwTSF >> 32), iobase + MAC_REG_NEXTTBTT + 4);\n\tvt6655_mac_reg_bits_on(iobase, MAC_REG_TFTCTL, TFTCTL_TBTTSYNCEN);\n\tpr_debug(\"Card:Update Next TBTT[%8llx]\\n\", qwTSF);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}