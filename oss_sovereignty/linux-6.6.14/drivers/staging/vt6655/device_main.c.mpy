{
  "module_name": "device_main.c",
  "hash_id": "2e373f5d752aa02b3e1b1d6bda5a5acfce3c9f0edb0bf4de6c33ab9bcc3f67f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/staging/vt6655/device_main.c",
  "human_readable_source": "\n \n\n#include <linux/file.h>\n#include \"device.h\"\n#include \"card.h\"\n#include \"channel.h\"\n#include \"baseband.h\"\n#include \"mac.h\"\n#include \"power.h\"\n#include \"rxtx.h\"\n#include \"dpc.h\"\n#include \"rf.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n\n \n \nMODULE_AUTHOR(\"VIA Networking Technologies, Inc., <lyndonchen@vntek.com.tw>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"VIA Networking Solomon-A/B/G Wireless LAN Adapter Driver\");\n\n#define DEVICE_PARAM(N, D)\n\n#define RX_DESC_MIN0     16\n#define RX_DESC_MAX0     128\n#define RX_DESC_DEF0     32\nDEVICE_PARAM(RxDescriptors0, \"Number of receive descriptors0\");\n\n#define RX_DESC_MIN1     16\n#define RX_DESC_MAX1     128\n#define RX_DESC_DEF1     32\nDEVICE_PARAM(RxDescriptors1, \"Number of receive descriptors1\");\n\n#define TX_DESC_MIN0     16\n#define TX_DESC_MAX0     128\n#define TX_DESC_DEF0     32\nDEVICE_PARAM(TxDescriptors0, \"Number of transmit descriptors0\");\n\n#define TX_DESC_MIN1     16\n#define TX_DESC_MAX1     128\n#define TX_DESC_DEF1     64\nDEVICE_PARAM(TxDescriptors1, \"Number of transmit descriptors1\");\n\n#define INT_WORKS_DEF   20\n#define INT_WORKS_MIN   10\n#define INT_WORKS_MAX   64\n\nDEVICE_PARAM(int_works, \"Number of packets per interrupt services\");\n\n#define RTS_THRESH_DEF     2347\n\n#define FRAG_THRESH_DEF     2346\n\n#define SHORT_RETRY_MIN     0\n#define SHORT_RETRY_MAX     31\n#define SHORT_RETRY_DEF     8\n\nDEVICE_PARAM(ShortRetryLimit, \"Short frame retry limits\");\n\n#define LONG_RETRY_MIN     0\n#define LONG_RETRY_MAX     15\n#define LONG_RETRY_DEF     4\n\nDEVICE_PARAM(LongRetryLimit, \"long frame retry limits\");\n\n \n#define BBP_TYPE_MIN     0\n#define BBP_TYPE_MAX     2\n#define BBP_TYPE_DEF     2\n\nDEVICE_PARAM(BasebandType, \"baseband type\");\n\n \nstatic const struct pci_device_id vt6655_pci_id_table[] = {\n\t{ PCI_VDEVICE(VIA, 0x3253) },\n\t{ 0, }\n};\n\n \n\nstatic int  vt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent);\nstatic void device_free_info(struct vnt_private *priv);\nstatic void device_print_info(struct vnt_private *priv);\n\nstatic void vt6655_mac_write_bssid_addr(void __iomem *iobase, const u8 *mac_addr);\nstatic void vt6655_mac_read_ether_addr(void __iomem *iobase, u8 *mac_addr);\n\nstatic int device_init_rd0_ring(struct vnt_private *priv);\nstatic int device_init_rd1_ring(struct vnt_private *priv);\nstatic int device_init_td0_ring(struct vnt_private *priv);\nstatic int device_init_td1_ring(struct vnt_private *priv);\n\nstatic int  device_rx_srv(struct vnt_private *priv, unsigned int idx);\nstatic int  device_tx_srv(struct vnt_private *priv, unsigned int idx);\nstatic bool device_alloc_rx_buf(struct vnt_private *, struct vnt_rx_desc *);\nstatic void device_free_rx_buf(struct vnt_private *priv,\n\t\t\t       struct vnt_rx_desc *rd);\nstatic void device_init_registers(struct vnt_private *priv);\nstatic void device_free_tx_buf(struct vnt_private *, struct vnt_tx_desc *);\nstatic void device_free_td0_ring(struct vnt_private *priv);\nstatic void device_free_td1_ring(struct vnt_private *priv);\nstatic void device_free_rd0_ring(struct vnt_private *priv);\nstatic void device_free_rd1_ring(struct vnt_private *priv);\nstatic void device_free_rings(struct vnt_private *priv);\n\n \n\n \n\nstatic void vt6655_remove(struct pci_dev *pcid)\n{\n\tstruct vnt_private *priv = pci_get_drvdata(pcid);\n\n\tif (!priv)\n\t\treturn;\n\tdevice_free_info(priv);\n}\n\nstatic void device_get_options(struct vnt_private *priv)\n{\n\tstruct vnt_options *opts = &priv->opts;\n\n\topts->rx_descs0 = RX_DESC_DEF0;\n\topts->rx_descs1 = RX_DESC_DEF1;\n\topts->tx_descs[0] = TX_DESC_DEF0;\n\topts->tx_descs[1] = TX_DESC_DEF1;\n\topts->int_works = INT_WORKS_DEF;\n\n\topts->short_retry = SHORT_RETRY_DEF;\n\topts->long_retry = LONG_RETRY_DEF;\n\topts->bbp_type = BBP_TYPE_DEF;\n}\n\nstatic void\ndevice_set_options(struct vnt_private *priv)\n{\n\tpriv->byShortRetryLimit = priv->opts.short_retry;\n\tpriv->byLongRetryLimit = priv->opts.long_retry;\n\tpriv->byBBType = priv->opts.bbp_type;\n\tpriv->byPacketType = priv->byBBType;\n\tpriv->byAutoFBCtrl = AUTO_FB_0;\n\tpriv->bUpdateBBVGA = true;\n\tpriv->preamble_type = 0;\n\n\tpr_debug(\" byShortRetryLimit= %d\\n\", (int)priv->byShortRetryLimit);\n\tpr_debug(\" byLongRetryLimit= %d\\n\", (int)priv->byLongRetryLimit);\n\tpr_debug(\" preamble_type= %d\\n\", (int)priv->preamble_type);\n\tpr_debug(\" byShortPreamble= %d\\n\", (int)priv->byShortPreamble);\n\tpr_debug(\" byBBType= %d\\n\", (int)priv->byBBType);\n}\n\nstatic void vt6655_mac_write_bssid_addr(void __iomem *iobase, const u8 *mac_addr)\n{\n\tiowrite8(1, iobase + MAC_REG_PAGE1SEL);\n\tfor (int i = 0; i < 6; i++)\n\t\tiowrite8(mac_addr[i], iobase + MAC_REG_BSSID0 + i);\n\tiowrite8(0, iobase + MAC_REG_PAGE1SEL);\n}\n\nstatic void vt6655_mac_read_ether_addr(void __iomem *iobase, u8 *mac_addr)\n{\n\tiowrite8(1, iobase + MAC_REG_PAGE1SEL);\n\tfor (int i = 0; i < 6; i++)\n\t\tmac_addr[i] = ioread8(iobase + MAC_REG_PAR0 + i);\n\tiowrite8(0, iobase + MAC_REG_PAGE1SEL);\n}\n\nstatic void vt6655_mac_dma_ctl(void __iomem *iobase, u8 reg_index)\n{\n\tu32 reg_value;\n\n\treg_value = ioread32(iobase + reg_index);\n\tif (reg_value & DMACTL_RUN)\n\t\tiowrite32(DMACTL_WAKE, iobase + reg_index);\n\telse\n\t\tiowrite32(DMACTL_RUN, iobase + reg_index);\n}\n\nstatic void vt6655_mac_set_bits(void __iomem *iobase, u32 mask)\n{\n\tu32 reg_value;\n\n\treg_value = ioread32(iobase + MAC_REG_ENCFG);\n\treg_value = reg_value | mask;\n\tiowrite32(reg_value, iobase + MAC_REG_ENCFG);\n}\n\nstatic void vt6655_mac_clear_bits(void __iomem *iobase, u32 mask)\n{\n\tu32 reg_value;\n\n\treg_value = ioread32(iobase + MAC_REG_ENCFG);\n\treg_value = reg_value & ~mask;\n\tiowrite32(reg_value, iobase + MAC_REG_ENCFG);\n}\n\nstatic void vt6655_mac_en_protect_md(void __iomem *iobase)\n{\n\tvt6655_mac_set_bits(iobase, ENCFG_PROTECTMD);\n}\n\nstatic void vt6655_mac_dis_protect_md(void __iomem *iobase)\n{\n\tvt6655_mac_clear_bits(iobase, ENCFG_PROTECTMD);\n}\n\nstatic void vt6655_mac_en_barker_preamble_md(void __iomem *iobase)\n{\n\tvt6655_mac_set_bits(iobase, ENCFG_BARKERPREAM);\n}\n\nstatic void vt6655_mac_dis_barker_preamble_md(void __iomem *iobase)\n{\n\tvt6655_mac_clear_bits(iobase, ENCFG_BARKERPREAM);\n}\n\n \n\nstatic void device_init_registers(struct vnt_private *priv)\n{\n\tunsigned long flags;\n\tunsigned int ii;\n\tunsigned char byValue;\n\tunsigned char byCCKPwrdBm = 0;\n\tunsigned char byOFDMPwrdBm = 0;\n\n\tMACbShutdown(priv);\n\tbb_software_reset(priv);\n\n\t \n\tMACbSoftwareReset(priv);\n\n\tpriv->bAES = false;\n\n\t \n\tpriv->bProtectMode = false;\n\n\tpriv->bNonERPPresent = false;\n\tpriv->bBarkerPreambleMd = false;\n\tpriv->wCurrentRate = RATE_1M;\n\tpriv->byTopOFDMBasicRate = RATE_24M;\n\tpriv->byTopCCKBasicRate = RATE_1M;\n\n\t \n\tMACvInitialize(priv);\n\n\t \n\tpriv->local_id = ioread8(priv->port_offset + MAC_REG_LOCALID);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tSROMvReadAllContents(priv->port_offset, priv->abyEEPROM);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\tpriv->byMinChannel = 1;\n\tpriv->byMaxChannel = CB_MAX_CHANNEL;\n\n\t \n\tbyValue = SROMbyReadEmbedded(priv->port_offset, EEP_OFS_ANTENNA);\n\tif (byValue & EEP_ANTINV)\n\t\tpriv->bTxRxAntInv = true;\n\telse\n\t\tpriv->bTxRxAntInv = false;\n\n\tbyValue &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\n\t \n\tif (byValue == 0)\n\t\tbyValue = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\n\n\tif (byValue == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {\n\t\tpriv->byAntennaCount = 2;\n\t\tpriv->byTxAntennaMode = ANT_B;\n\t\tpriv->dwTxAntennaSel = 1;\n\t\tpriv->dwRxAntennaSel = 1;\n\n\t\tif (priv->bTxRxAntInv)\n\t\t\tpriv->byRxAntennaMode = ANT_A;\n\t\telse\n\t\t\tpriv->byRxAntennaMode = ANT_B;\n\t} else  {\n\t\tpriv->byAntennaCount = 1;\n\t\tpriv->dwTxAntennaSel = 0;\n\t\tpriv->dwRxAntennaSel = 0;\n\n\t\tif (byValue & EEP_ANTENNA_AUX) {\n\t\t\tpriv->byTxAntennaMode = ANT_A;\n\n\t\t\tif (priv->bTxRxAntInv)\n\t\t\t\tpriv->byRxAntennaMode = ANT_B;\n\t\t\telse\n\t\t\t\tpriv->byRxAntennaMode = ANT_A;\n\t\t} else {\n\t\t\tpriv->byTxAntennaMode = ANT_B;\n\n\t\t\tif (priv->bTxRxAntInv)\n\t\t\t\tpriv->byRxAntennaMode = ANT_A;\n\t\t\telse\n\t\t\t\tpriv->byRxAntennaMode = ANT_B;\n\t\t}\n\t}\n\n\t \n\tbb_set_tx_antenna_mode(priv, priv->byTxAntennaMode);\n\tbb_set_rx_antenna_mode(priv, priv->byRxAntennaMode);\n\n\t \n\tpriv->byOriginalZonetype = priv->abyEEPROM[EEP_OFS_ZONETYPE];\n\n\tif (!priv->bZoneRegExist)\n\t\tpriv->byZoneType = priv->abyEEPROM[EEP_OFS_ZONETYPE];\n\n\tpr_debug(\"priv->byZoneType = %x\\n\", priv->byZoneType);\n\n\t \n\tRFbInit(priv);\n\n\t \n\tpriv->byCurPwr = 0xFF;\n\tpriv->byCCKPwr = SROMbyReadEmbedded(priv->port_offset, EEP_OFS_PWR_CCK);\n\tpriv->byOFDMPwrG = SROMbyReadEmbedded(priv->port_offset,\n\t\t\t\t\t      EEP_OFS_PWR_OFDMG);\n\n\t \n\tfor (ii = 0; ii < CB_MAX_CHANNEL_24G; ii++) {\n\t\tpriv->abyCCKPwrTbl[ii + 1] =\n\t\t\tSROMbyReadEmbedded(priv->port_offset,\n\t\t\t\t\t   (unsigned char)(ii + EEP_OFS_CCK_PWR_TBL));\n\t\tif (priv->abyCCKPwrTbl[ii + 1] == 0)\n\t\t\tpriv->abyCCKPwrTbl[ii + 1] = priv->byCCKPwr;\n\n\t\tpriv->abyOFDMPwrTbl[ii + 1] =\n\t\t\tSROMbyReadEmbedded(priv->port_offset,\n\t\t\t\t\t   (unsigned char)(ii + EEP_OFS_OFDM_PWR_TBL));\n\t\tif (priv->abyOFDMPwrTbl[ii + 1] == 0)\n\t\t\tpriv->abyOFDMPwrTbl[ii + 1] = priv->byOFDMPwrG;\n\n\t\tpriv->abyCCKDefaultPwr[ii + 1] = byCCKPwrdBm;\n\t\tpriv->abyOFDMDefaultPwr[ii + 1] = byOFDMPwrdBm;\n\t}\n\n\t \n\tfor (ii = 11; ii < 14; ii++) {\n\t\tpriv->abyCCKPwrTbl[ii] = priv->abyCCKPwrTbl[10];\n\t\tpriv->abyOFDMPwrTbl[ii] = priv->abyOFDMPwrTbl[10];\n\t}\n\n\t \n\tfor (ii = 0; ii < CB_MAX_CHANNEL_5G; ii++) {\n\t\tpriv->abyOFDMPwrTbl[ii + CB_MAX_CHANNEL_24G + 1] =\n\t\t\tSROMbyReadEmbedded(priv->port_offset,\n\t\t\t\t\t   (unsigned char)(ii + EEP_OFS_OFDMA_PWR_TBL));\n\n\t\tpriv->abyOFDMDefaultPwr[ii + CB_MAX_CHANNEL_24G + 1] =\n\t\t\tSROMbyReadEmbedded(priv->port_offset,\n\t\t\t\t\t   (unsigned char)(ii + EEP_OFS_OFDMA_PWR_dBm));\n\t}\n\n\tif (priv->local_id > REV_ID_VT3253_B1) {\n\t\tVT6655_MAC_SELECT_PAGE1(priv->port_offset);\n\n\t\tiowrite8(MSRCTL1_TXPWR | MSRCTL1_CSAPAREN, priv->port_offset + MAC_REG_MSRCTL + 1);\n\n\t\tVT6655_MAC_SELECT_PAGE0(priv->port_offset);\n\t}\n\n\t \n\tvt6655_mac_word_reg_bits_on(priv->port_offset, MAC_REG_CFG,\n\t\t\t\t    (CFG_TKIPOPT | CFG_NOTXTIMEOUT));\n\n\t \n\tvt6655_mac_set_short_retry_limit(priv, priv->byShortRetryLimit);\n\tMACvSetLongRetryLimit(priv, priv->byLongRetryLimit);\n\n\t \n\tiowrite8(TFTCTL_TSFCNTRST, priv->port_offset + MAC_REG_TFTCTL);\n\t \n\tiowrite8(TFTCTL_TSFCNTREN, priv->port_offset + MAC_REG_TFTCTL);\n\n\t \n\tbb_vt3253_init(priv);\n\n\tif (priv->bUpdateBBVGA) {\n\t\tpriv->byBBVGACurrent = priv->abyBBVGA[0];\n\t\tpriv->byBBVGANew = priv->byBBVGACurrent;\n\t\tbb_set_vga_gain_offset(priv, priv->abyBBVGA[0]);\n\t}\n\n\tbb_set_rx_antenna_mode(priv, priv->byRxAntennaMode);\n\tbb_set_tx_antenna_mode(priv, priv->byTxAntennaMode);\n\n\t \n\t \n\tpriv->wCurrentRate = RATE_54M;\n\n\tpriv->radio_off = false;\n\n\tpriv->byRadioCtl = SROMbyReadEmbedded(priv->port_offset,\n\t\t\t\t\t      EEP_OFS_RADIOCTL);\n\tpriv->hw_radio_off = false;\n\n\tif (priv->byRadioCtl & EEP_RADIOCTL_ENABLE) {\n\t\t \n\t\tpriv->byGPIO = ioread8(priv->port_offset + MAC_REG_GPIOCTL1);\n\n\t\tif (((priv->byGPIO & GPIO0_DATA) &&\n\t\t     !(priv->byRadioCtl & EEP_RADIOCTL_INV)) ||\n\t\t     (!(priv->byGPIO & GPIO0_DATA) &&\n\t\t     (priv->byRadioCtl & EEP_RADIOCTL_INV)))\n\t\t\tpriv->hw_radio_off = true;\n\t}\n\n\tif (priv->hw_radio_off || priv->bRadioControlOff)\n\t\tCARDbRadioPowerOff(priv);\n\n\t \n\tSROMvReadEtherAddress(priv->port_offset, priv->abyCurrentNetAddr);\n\tpr_debug(\"Network address = %pM\\n\", priv->abyCurrentNetAddr);\n\n\t \n\tCARDvSafeResetRx(priv);\n\t \n\tCARDvSafeResetTx(priv);\n\n\tif (priv->local_id <= REV_ID_VT3253_A1)\n\t\tvt6655_mac_reg_bits_on(priv->port_offset, MAC_REG_RCR, RCR_WPAERR);\n\n\t \n\tvt6655_mac_dma_ctl(priv->port_offset, MAC_REG_RXDMACTL0);\n\tvt6655_mac_dma_ctl(priv->port_offset, MAC_REG_RXDMACTL1);\n\n\t \n\tiowrite8(HOSTCR_MACEN | HOSTCR_RXON | HOSTCR_TXON, priv->port_offset + MAC_REG_HOSTCR);\n}\n\nstatic void device_print_info(struct vnt_private *priv)\n{\n\tdev_info(&priv->pcid->dev, \"MAC=%pM IO=0x%lx Mem=0x%lx IRQ=%d\\n\",\n\t\t priv->abyCurrentNetAddr, (unsigned long)priv->ioaddr,\n\t\t (unsigned long)priv->port_offset, priv->pcid->irq);\n}\n\nstatic void device_free_info(struct vnt_private *priv)\n{\n\tif (!priv)\n\t\treturn;\n\n\tif (priv->mac_hw)\n\t\tieee80211_unregister_hw(priv->hw);\n\n\tif (priv->port_offset)\n\t\tiounmap(priv->port_offset);\n\n\tif (priv->pcid)\n\t\tpci_release_regions(priv->pcid);\n\n\tif (priv->hw)\n\t\tieee80211_free_hw(priv->hw);\n}\n\nstatic bool device_init_rings(struct vnt_private *priv)\n{\n\tvoid *vir_pool;\n\n\t \n\tvir_pool = dma_alloc_coherent(&priv->pcid->dev,\n\t\t\t\t      priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc) +\n\t\t\t\t      priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc) +\n\t\t\t\t      priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) +\n\t\t\t\t      priv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),\n\t\t\t\t      &priv->pool_dma, GFP_ATOMIC);\n\tif (!vir_pool) {\n\t\tdev_err(&priv->pcid->dev, \"allocate desc dma memory failed\\n\");\n\t\treturn false;\n\t}\n\n\tpriv->aRD0Ring = vir_pool;\n\tpriv->aRD1Ring = vir_pool +\n\t\tpriv->opts.rx_descs0 * sizeof(struct vnt_rx_desc);\n\n\tpriv->rd0_pool_dma = priv->pool_dma;\n\tpriv->rd1_pool_dma = priv->rd0_pool_dma +\n\t\tpriv->opts.rx_descs0 * sizeof(struct vnt_rx_desc);\n\n\tpriv->tx0_bufs = dma_alloc_coherent(&priv->pcid->dev,\n\t\t\t\t\t    priv->opts.tx_descs[0] * PKT_BUF_SZ +\n\t\t\t\t\t    priv->opts.tx_descs[1] * PKT_BUF_SZ +\n\t\t\t\t\t    CB_BEACON_BUF_SIZE +\n\t\t\t\t\t    CB_MAX_BUF_SIZE,\n\t\t\t\t\t    &priv->tx_bufs_dma0, GFP_ATOMIC);\n\tif (!priv->tx0_bufs) {\n\t\tdev_err(&priv->pcid->dev, \"allocate buf dma memory failed\\n\");\n\n\t\tdma_free_coherent(&priv->pcid->dev,\n\t\t\t\t  priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc) +\n\t\t\t\t  priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc) +\n\t\t\t\t  priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) +\n\t\t\t\t  priv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),\n\t\t\t\t  vir_pool, priv->pool_dma);\n\t\treturn false;\n\t}\n\n\tpriv->td0_pool_dma = priv->rd1_pool_dma +\n\t\tpriv->opts.rx_descs1 * sizeof(struct vnt_rx_desc);\n\n\tpriv->td1_pool_dma = priv->td0_pool_dma +\n\t\tpriv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc);\n\n\t \n\tpriv->apTD0Rings = vir_pool\n\t\t+ priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc)\n\t\t+ priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc);\n\n\tpriv->apTD1Rings = vir_pool\n\t\t+ priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc)\n\t\t+ priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc)\n\t\t+ priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc);\n\n\tpriv->tx1_bufs = priv->tx0_bufs +\n\t\tpriv->opts.tx_descs[0] * PKT_BUF_SZ;\n\n\tpriv->tx_beacon_bufs = priv->tx1_bufs +\n\t\tpriv->opts.tx_descs[1] * PKT_BUF_SZ;\n\n\tpriv->pbyTmpBuff = priv->tx_beacon_bufs +\n\t\tCB_BEACON_BUF_SIZE;\n\n\tpriv->tx_bufs_dma1 = priv->tx_bufs_dma0 +\n\t\tpriv->opts.tx_descs[0] * PKT_BUF_SZ;\n\n\tpriv->tx_beacon_dma = priv->tx_bufs_dma1 +\n\t\tpriv->opts.tx_descs[1] * PKT_BUF_SZ;\n\n\treturn true;\n}\n\nstatic void device_free_rings(struct vnt_private *priv)\n{\n\tdma_free_coherent(&priv->pcid->dev,\n\t\t\t  priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc) +\n\t\t\t  priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc) +\n\t\t\t  priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) +\n\t\t\t  priv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),\n\t\t\t  priv->aRD0Ring, priv->pool_dma);\n\n\tdma_free_coherent(&priv->pcid->dev,\n\t\t\t  priv->opts.tx_descs[0] * PKT_BUF_SZ +\n\t\t\t  priv->opts.tx_descs[1] * PKT_BUF_SZ +\n\t\t\t  CB_BEACON_BUF_SIZE +\n\t\t\t  CB_MAX_BUF_SIZE,\n\t\t\t  priv->tx0_bufs, priv->tx_bufs_dma0);\n}\n\nstatic int device_init_rd0_ring(struct vnt_private *priv)\n{\n\tint i;\n\tdma_addr_t      curr = priv->rd0_pool_dma;\n\tstruct vnt_rx_desc *desc;\n\tint ret;\n\n\t \n\tfor (i = 0; i < priv->opts.rx_descs0;\n\t     i ++, curr += sizeof(struct vnt_rx_desc)) {\n\t\tdesc = &priv->aRD0Ring[i];\n\t\tdesc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_KERNEL);\n\t\tif (!desc->rd_info) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_desc;\n\t\t}\n\n\t\tif (!device_alloc_rx_buf(priv, desc)) {\n\t\t\tdev_err(&priv->pcid->dev, \"can not alloc rx bufs\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_rd;\n\t\t}\n\n\t\tdesc->next = &priv->aRD0Ring[(i + 1) % priv->opts.rx_descs0];\n\t\tdesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));\n\t}\n\n\tif (i > 0)\n\t\tpriv->aRD0Ring[i - 1].next_desc = cpu_to_le32(priv->rd0_pool_dma);\n\tpriv->pCurrRD[0] = &priv->aRD0Ring[0];\n\n\treturn 0;\n\nerr_free_rd:\n\tkfree(desc->rd_info);\n\nerr_free_desc:\n\twhile (i--) {\n\t\tdesc = &priv->aRD0Ring[i];\n\t\tdevice_free_rx_buf(priv, desc);\n\t\tkfree(desc->rd_info);\n\t}\n\n\treturn ret;\n}\n\nstatic int device_init_rd1_ring(struct vnt_private *priv)\n{\n\tint i;\n\tdma_addr_t      curr = priv->rd1_pool_dma;\n\tstruct vnt_rx_desc *desc;\n\tint ret;\n\n\t \n\tfor (i = 0; i < priv->opts.rx_descs1;\n\t     i ++, curr += sizeof(struct vnt_rx_desc)) {\n\t\tdesc = &priv->aRD1Ring[i];\n\t\tdesc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_KERNEL);\n\t\tif (!desc->rd_info) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_desc;\n\t\t}\n\n\t\tif (!device_alloc_rx_buf(priv, desc)) {\n\t\t\tdev_err(&priv->pcid->dev, \"can not alloc rx bufs\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_rd;\n\t\t}\n\n\t\tdesc->next = &priv->aRD1Ring[(i + 1) % priv->opts.rx_descs1];\n\t\tdesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));\n\t}\n\n\tif (i > 0)\n\t\tpriv->aRD1Ring[i - 1].next_desc = cpu_to_le32(priv->rd1_pool_dma);\n\tpriv->pCurrRD[1] = &priv->aRD1Ring[0];\n\n\treturn 0;\n\nerr_free_rd:\n\tkfree(desc->rd_info);\n\nerr_free_desc:\n\twhile (i--) {\n\t\tdesc = &priv->aRD1Ring[i];\n\t\tdevice_free_rx_buf(priv, desc);\n\t\tkfree(desc->rd_info);\n\t}\n\n\treturn ret;\n}\n\nstatic void device_free_rd0_ring(struct vnt_private *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->opts.rx_descs0; i++) {\n\t\tstruct vnt_rx_desc *desc = &priv->aRD0Ring[i];\n\n\t\tdevice_free_rx_buf(priv, desc);\n\t\tkfree(desc->rd_info);\n\t}\n}\n\nstatic void device_free_rd1_ring(struct vnt_private *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->opts.rx_descs1; i++) {\n\t\tstruct vnt_rx_desc *desc = &priv->aRD1Ring[i];\n\n\t\tdevice_free_rx_buf(priv, desc);\n\t\tkfree(desc->rd_info);\n\t}\n}\n\nstatic int device_init_td0_ring(struct vnt_private *priv)\n{\n\tint i;\n\tdma_addr_t  curr;\n\tstruct vnt_tx_desc *desc;\n\tint ret;\n\n\tcurr = priv->td0_pool_dma;\n\tfor (i = 0; i < priv->opts.tx_descs[0];\n\t     i++, curr += sizeof(struct vnt_tx_desc)) {\n\t\tdesc = &priv->apTD0Rings[i];\n\t\tdesc->td_info = kzalloc(sizeof(*desc->td_info), GFP_KERNEL);\n\t\tif (!desc->td_info) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_desc;\n\t\t}\n\n\t\tdesc->td_info->buf = priv->tx0_bufs + i * PKT_BUF_SZ;\n\t\tdesc->td_info->buf_dma = priv->tx_bufs_dma0 + i * PKT_BUF_SZ;\n\n\t\tdesc->next = &(priv->apTD0Rings[(i + 1) % priv->opts.tx_descs[0]]);\n\t\tdesc->next_desc = cpu_to_le32(curr +\n\t\t\t\t\t      sizeof(struct vnt_tx_desc));\n\t}\n\n\tif (i > 0)\n\t\tpriv->apTD0Rings[i - 1].next_desc = cpu_to_le32(priv->td0_pool_dma);\n\tpriv->apTailTD[0] = priv->apCurrTD[0] = &priv->apTD0Rings[0];\n\n\treturn 0;\n\nerr_free_desc:\n\twhile (i--) {\n\t\tdesc = &priv->apTD0Rings[i];\n\t\tkfree(desc->td_info);\n\t}\n\n\treturn ret;\n}\n\nstatic int device_init_td1_ring(struct vnt_private *priv)\n{\n\tint i;\n\tdma_addr_t  curr;\n\tstruct vnt_tx_desc *desc;\n\tint ret;\n\n\t \n\tcurr = priv->td1_pool_dma;\n\tfor (i = 0; i < priv->opts.tx_descs[1];\n\t     i++, curr += sizeof(struct vnt_tx_desc)) {\n\t\tdesc = &priv->apTD1Rings[i];\n\t\tdesc->td_info = kzalloc(sizeof(*desc->td_info), GFP_KERNEL);\n\t\tif (!desc->td_info) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_desc;\n\t\t}\n\n\t\tdesc->td_info->buf = priv->tx1_bufs + i * PKT_BUF_SZ;\n\t\tdesc->td_info->buf_dma = priv->tx_bufs_dma1 + i * PKT_BUF_SZ;\n\n\t\tdesc->next = &(priv->apTD1Rings[(i + 1) % priv->opts.tx_descs[1]]);\n\t\tdesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));\n\t}\n\n\tif (i > 0)\n\t\tpriv->apTD1Rings[i - 1].next_desc = cpu_to_le32(priv->td1_pool_dma);\n\tpriv->apTailTD[1] = priv->apCurrTD[1] = &priv->apTD1Rings[0];\n\n\treturn 0;\n\nerr_free_desc:\n\twhile (i--) {\n\t\tdesc = &priv->apTD1Rings[i];\n\t\tkfree(desc->td_info);\n\t}\n\n\treturn ret;\n}\n\nstatic void device_free_td0_ring(struct vnt_private *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->opts.tx_descs[0]; i++) {\n\t\tstruct vnt_tx_desc *desc = &priv->apTD0Rings[i];\n\t\tstruct vnt_td_info *td_info = desc->td_info;\n\n\t\tdev_kfree_skb(td_info->skb);\n\t\tkfree(desc->td_info);\n\t}\n}\n\nstatic void device_free_td1_ring(struct vnt_private *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->opts.tx_descs[1]; i++) {\n\t\tstruct vnt_tx_desc *desc = &priv->apTD1Rings[i];\n\t\tstruct vnt_td_info *td_info = desc->td_info;\n\n\t\tdev_kfree_skb(td_info->skb);\n\t\tkfree(desc->td_info);\n\t}\n}\n\n \n\nstatic int device_rx_srv(struct vnt_private *priv, unsigned int idx)\n{\n\tstruct vnt_rx_desc *rd;\n\tint works = 0;\n\n\tfor (rd = priv->pCurrRD[idx];\n\t     rd->rd0.owner == OWNED_BY_HOST;\n\t     rd = rd->next) {\n\t\tif (works++ > 15)\n\t\t\tbreak;\n\n\t\tif (!rd->rd_info->skb)\n\t\t\tbreak;\n\n\t\tif (vnt_receive_frame(priv, rd)) {\n\t\t\tif (!device_alloc_rx_buf(priv, rd)) {\n\t\t\t\tdev_err(&priv->pcid->dev,\n\t\t\t\t\t\"can not allocate rx buf\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trd->rd0.owner = OWNED_BY_NIC;\n\t}\n\n\tpriv->pCurrRD[idx] = rd;\n\n\treturn works;\n}\n\nstatic bool device_alloc_rx_buf(struct vnt_private *priv,\n\t\t\t\tstruct vnt_rx_desc *rd)\n{\n\tstruct vnt_rd_info *rd_info = rd->rd_info;\n\n\trd_info->skb = dev_alloc_skb((int)priv->rx_buf_sz);\n\tif (!rd_info->skb)\n\t\treturn false;\n\n\trd_info->skb_dma =\n\t\tdma_map_single(&priv->pcid->dev,\n\t\t\t       skb_put(rd_info->skb, skb_tailroom(rd_info->skb)),\n\t\t\t       priv->rx_buf_sz, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&priv->pcid->dev, rd_info->skb_dma)) {\n\t\tdev_kfree_skb(rd_info->skb);\n\t\trd_info->skb = NULL;\n\t\treturn false;\n\t}\n\n\t*((unsigned int *)&rd->rd0) = 0;  \n\n\trd->rd0.res_count = cpu_to_le16(priv->rx_buf_sz);\n\trd->rd0.owner = OWNED_BY_NIC;\n\trd->rd1.req_count = cpu_to_le16(priv->rx_buf_sz);\n\trd->buff_addr = cpu_to_le32(rd_info->skb_dma);\n\n\treturn true;\n}\n\nstatic void device_free_rx_buf(struct vnt_private *priv,\n\t\t\t       struct vnt_rx_desc *rd)\n{\n\tstruct vnt_rd_info *rd_info = rd->rd_info;\n\n\tdma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,\n\t\t\t priv->rx_buf_sz, DMA_FROM_DEVICE);\n\tdev_kfree_skb(rd_info->skb);\n}\n\nstatic const u8 fallback_rate0[5][5] = {\n\t{RATE_18M, RATE_18M, RATE_12M, RATE_12M, RATE_12M},\n\t{RATE_24M, RATE_24M, RATE_18M, RATE_12M, RATE_12M},\n\t{RATE_36M, RATE_36M, RATE_24M, RATE_18M, RATE_18M},\n\t{RATE_48M, RATE_48M, RATE_36M, RATE_24M, RATE_24M},\n\t{RATE_54M, RATE_54M, RATE_48M, RATE_36M, RATE_36M}\n};\n\nstatic const u8 fallback_rate1[5][5] = {\n\t{RATE_18M, RATE_18M, RATE_12M, RATE_6M, RATE_6M},\n\t{RATE_24M, RATE_24M, RATE_18M, RATE_6M, RATE_6M},\n\t{RATE_36M, RATE_36M, RATE_24M, RATE_12M, RATE_12M},\n\t{RATE_48M, RATE_48M, RATE_24M, RATE_12M, RATE_12M},\n\t{RATE_54M, RATE_54M, RATE_36M, RATE_18M, RATE_18M}\n};\n\nstatic int vnt_int_report_rate(struct vnt_private *priv,\n\t\t\t       struct vnt_td_info *context, u8 tsr0, u8 tsr1)\n{\n\tstruct vnt_tx_fifo_head *fifo_head;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_rate *rate;\n\tu16 fb_option;\n\tu8 tx_retry = (tsr0 & TSR0_NCR);\n\ts8 idx;\n\n\tif (!context)\n\t\treturn -ENOMEM;\n\n\tif (!context->skb)\n\t\treturn -EINVAL;\n\n\tfifo_head = (struct vnt_tx_fifo_head *)context->buf;\n\tfb_option = (le16_to_cpu(fifo_head->fifo_ctl) &\n\t\t\t(FIFOCTL_AUTO_FB_0 | FIFOCTL_AUTO_FB_1));\n\n\tinfo = IEEE80211_SKB_CB(context->skb);\n\tidx = info->control.rates[0].idx;\n\n\tif (fb_option && !(tsr1 & TSR1_TERR)) {\n\t\tu8 tx_rate;\n\t\tu8 retry = tx_retry;\n\n\t\trate = ieee80211_get_tx_rate(priv->hw, info);\n\t\ttx_rate = rate->hw_value - RATE_18M;\n\n\t\tif (retry > 4)\n\t\t\tretry = 4;\n\n\t\tif (fb_option & FIFOCTL_AUTO_FB_0)\n\t\t\ttx_rate = fallback_rate0[tx_rate][retry];\n\t\telse if (fb_option & FIFOCTL_AUTO_FB_1)\n\t\t\ttx_rate = fallback_rate1[tx_rate][retry];\n\n\t\tif (info->band == NL80211_BAND_5GHZ)\n\t\t\tidx = tx_rate - RATE_6M;\n\t\telse\n\t\t\tidx = tx_rate;\n\t}\n\n\tieee80211_tx_info_clear_status(info);\n\n\tinfo->status.rates[0].count = tx_retry;\n\n\tif (!(tsr1 & TSR1_TERR)) {\n\t\tinfo->status.rates[0].idx = idx;\n\n\t\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\t\telse\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t}\n\n\treturn 0;\n}\n\nstatic int device_tx_srv(struct vnt_private *priv, unsigned int idx)\n{\n\tstruct vnt_tx_desc *desc;\n\tint                      works = 0;\n\tunsigned char byTsr0;\n\tunsigned char byTsr1;\n\n\tfor (desc = priv->apTailTD[idx]; priv->iTDUsed[idx] > 0; desc = desc->next) {\n\t\tif (desc->td0.owner == OWNED_BY_NIC)\n\t\t\tbreak;\n\t\tif (works++ > 15)\n\t\t\tbreak;\n\n\t\tbyTsr0 = desc->td0.tsr0;\n\t\tbyTsr1 = desc->td0.tsr1;\n\n\t\t \n\t\tif (desc->td1.tcr & TCR_STP) {\n\t\t\tif ((desc->td_info->flags & TD_FLAGS_NETIF_SKB) != 0) {\n\t\t\t\tif (!(byTsr1 & TSR1_TERR)) {\n\t\t\t\t\tif (byTsr0 != 0) {\n\t\t\t\t\t\tpr_debug(\" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X]\\n\",\n\t\t\t\t\t\t\t (int)idx, byTsr1,\n\t\t\t\t\t\t\t byTsr0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpr_debug(\" Tx[%d] dropped & tsr1[%02X] tsr0[%02X]\\n\",\n\t\t\t\t\t\t (int)idx, byTsr1, byTsr0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (byTsr1 & TSR1_TERR) {\n\t\t\t\tif ((desc->td_info->flags & TD_FLAGS_PRIV_SKB) != 0) {\n\t\t\t\t\tpr_debug(\" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X]\\n\",\n\t\t\t\t\t\t (int)idx, byTsr1, byTsr0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvnt_int_report_rate(priv, desc->td_info, byTsr0, byTsr1);\n\n\t\t\tdevice_free_tx_buf(priv, desc);\n\t\t\tpriv->iTDUsed[idx]--;\n\t\t}\n\t}\n\n\tpriv->apTailTD[idx] = desc;\n\n\treturn works;\n}\n\nstatic void device_error(struct vnt_private *priv, unsigned short status)\n{\n\tif (status & ISR_FETALERR) {\n\t\tdev_err(&priv->pcid->dev, \"Hardware fatal error\\n\");\n\n\t\tMACbShutdown(priv);\n\t\treturn;\n\t}\n}\n\nstatic void device_free_tx_buf(struct vnt_private *priv,\n\t\t\t       struct vnt_tx_desc *desc)\n{\n\tstruct vnt_td_info *td_info = desc->td_info;\n\tstruct sk_buff *skb = td_info->skb;\n\n\tif (skb)\n\t\tieee80211_tx_status_irqsafe(priv->hw, skb);\n\n\ttd_info->skb = NULL;\n\ttd_info->flags = 0;\n}\n\nstatic void vnt_check_bb_vga(struct vnt_private *priv)\n{\n\tlong dbm;\n\tint i;\n\n\tif (!priv->bUpdateBBVGA)\n\t\treturn;\n\n\tif (priv->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL)\n\t\treturn;\n\n\tif (!(priv->vif->cfg.assoc && priv->current_rssi))\n\t\treturn;\n\n\tRFvRSSITodBm(priv, (u8)priv->current_rssi, &dbm);\n\n\tfor (i = 0; i < BB_VGA_LEVEL; i++) {\n\t\tif (dbm < priv->dbm_threshold[i]) {\n\t\t\tpriv->byBBVGANew = priv->abyBBVGA[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (priv->byBBVGANew == priv->byBBVGACurrent) {\n\t\tpriv->uBBVGADiffCount = 1;\n\t\treturn;\n\t}\n\n\tpriv->uBBVGADiffCount++;\n\n\tif (priv->uBBVGADiffCount == 1) {\n\t\t \n\t\tbb_set_vga_gain_offset(priv, priv->byBBVGANew);\n\n\t\tdev_dbg(&priv->pcid->dev,\n\t\t\t\"First RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\\n\",\n\t\t\t(int)dbm, priv->byBBVGANew,\n\t\t\tpriv->byBBVGACurrent,\n\t\t\t(int)priv->uBBVGADiffCount);\n\t}\n\n\tif (priv->uBBVGADiffCount >= BB_VGA_CHANGE_THRESHOLD) {\n\t\tdev_dbg(&priv->pcid->dev,\n\t\t\t\"RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\\n\",\n\t\t\t(int)dbm, priv->byBBVGANew,\n\t\t\tpriv->byBBVGACurrent,\n\t\t\t(int)priv->uBBVGADiffCount);\n\n\t\tbb_set_vga_gain_offset(priv, priv->byBBVGANew);\n\t}\n}\n\nstatic void vnt_interrupt_process(struct vnt_private *priv)\n{\n\tstruct ieee80211_low_level_stats *low_stats = &priv->low_stats;\n\tint             max_count = 0;\n\tu32 mib_counter;\n\tu32 isr;\n\tunsigned long flags;\n\n\tisr = ioread32(priv->port_offset + MAC_REG_ISR);\n\n\tif (isr == 0)\n\t\treturn;\n\n\tif (isr == 0xffffffff) {\n\t\tpr_debug(\"isr = 0xffff\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t \n\tmib_counter = ioread32(priv->port_offset + MAC_REG_MIBCNTR);\n\n\tlow_stats->dot11RTSSuccessCount += mib_counter & 0xff;\n\tlow_stats->dot11RTSFailureCount += (mib_counter >> 8) & 0xff;\n\tlow_stats->dot11ACKFailureCount += (mib_counter >> 16) & 0xff;\n\tlow_stats->dot11FCSErrorCount += (mib_counter >> 24) & 0xff;\n\n\t \n\twhile (isr && priv->vif) {\n\t\tiowrite32(isr, priv->port_offset + MAC_REG_ISR);\n\n\t\tif (isr & ISR_FETALERR) {\n\t\t\tpr_debug(\" ISR_FETALERR\\n\");\n\t\t\tiowrite8(0, priv->port_offset + MAC_REG_SOFTPWRCTL);\n\t\t\tiowrite16(SOFTPWRCTL_SWPECTI, priv->port_offset + MAC_REG_SOFTPWRCTL);\n\t\t\tdevice_error(priv, isr);\n\t\t}\n\n\t\tif (isr & ISR_TBTT) {\n\t\t\tif (priv->op_mode != NL80211_IFTYPE_ADHOC)\n\t\t\t\tvnt_check_bb_vga(priv);\n\n\t\t\tpriv->bBeaconSent = false;\n\t\t\tif (priv->bEnablePSMode)\n\t\t\t\tPSbIsNextTBTTWakeUp((void *)priv);\n\n\t\t\tif ((priv->op_mode == NL80211_IFTYPE_AP ||\n\t\t\t    priv->op_mode == NL80211_IFTYPE_ADHOC) &&\n\t\t\t    priv->vif->bss_conf.enable_beacon)\n\t\t\t\tMACvOneShotTimer1MicroSec(priv,\n\t\t\t\t\t\t\t  (priv->vif->bss_conf.beacon_int -\n\t\t\t\t\t\t\t   MAKE_BEACON_RESERVED) << 10);\n\n\t\t\t \n\t\t}\n\n\t\tif (isr & ISR_BNTX) {\n\t\t\tif (priv->op_mode == NL80211_IFTYPE_ADHOC) {\n\t\t\t\tpriv->bIsBeaconBufReadySet = false;\n\t\t\t\tpriv->cbBeaconBufReadySetCnt = 0;\n\t\t\t}\n\n\t\t\tpriv->bBeaconSent = true;\n\t\t}\n\n\t\tif (isr & ISR_RXDMA0)\n\t\t\tmax_count += device_rx_srv(priv, TYPE_RXDMA0);\n\n\t\tif (isr & ISR_RXDMA1)\n\t\t\tmax_count += device_rx_srv(priv, TYPE_RXDMA1);\n\n\t\tif (isr & ISR_TXDMA0)\n\t\t\tmax_count += device_tx_srv(priv, TYPE_TXDMA0);\n\n\t\tif (isr & ISR_AC0DMA)\n\t\t\tmax_count += device_tx_srv(priv, TYPE_AC0DMA);\n\n\t\tif (isr & ISR_SOFTTIMER1) {\n\t\t\tif (priv->vif->bss_conf.enable_beacon)\n\t\t\t\tvnt_beacon_make(priv, priv->vif);\n\t\t}\n\n\t\t \n\t\tif (AVAIL_TD(priv, TYPE_TXDMA0) &&\n\t\t    AVAIL_TD(priv, TYPE_AC0DMA) &&\n\t\t    ieee80211_queue_stopped(priv->hw, 0))\n\t\t\tieee80211_wake_queues(priv->hw);\n\n\t\tisr = ioread32(priv->port_offset + MAC_REG_ISR);\n\n\t\tvt6655_mac_dma_ctl(priv->port_offset, MAC_REG_RXDMACTL0);\n\t\tvt6655_mac_dma_ctl(priv->port_offset, MAC_REG_RXDMACTL1);\n\n\t\tif (max_count > priv->opts.int_works)\n\t\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void vnt_interrupt_work(struct work_struct *work)\n{\n\tstruct vnt_private *priv =\n\t\tcontainer_of(work, struct vnt_private, interrupt_work);\n\n\tif (priv->vif)\n\t\tvnt_interrupt_process(priv);\n\n\tiowrite32(IMR_MASK_VALUE, priv->port_offset + MAC_REG_IMR);\n}\n\nstatic irqreturn_t vnt_interrupt(int irq,  void *arg)\n{\n\tstruct vnt_private *priv = arg;\n\n\tschedule_work(&priv->interrupt_work);\n\n\tiowrite32(0, priv->port_offset + MAC_REG_IMR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct vnt_tx_desc *head_td;\n\tu32 dma_idx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (ieee80211_is_data(hdr->frame_control))\n\t\tdma_idx = TYPE_AC0DMA;\n\telse\n\t\tdma_idx = TYPE_TXDMA0;\n\n\tif (AVAIL_TD(priv, dma_idx) < 1) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tieee80211_stop_queues(priv->hw);\n\t\treturn -ENOMEM;\n\t}\n\n\thead_td = priv->apCurrTD[dma_idx];\n\n\thead_td->td1.tcr = 0;\n\n\thead_td->td_info->skb = skb;\n\n\tif (dma_idx == TYPE_AC0DMA)\n\t\thead_td->td_info->flags = TD_FLAGS_NETIF_SKB;\n\n\tpriv->apCurrTD[dma_idx] = head_td->next;\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tvnt_generate_fifo_header(priv, dma_idx, head_td, skb);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tpriv->bPWBitOn = false;\n\n\t \n\thead_td->td1.tcr |= (TCR_STP | TCR_EDP | EDMSDU);\n\thead_td->td1.req_count = cpu_to_le16(head_td->td_info->req_count);\n\n\thead_td->buff_addr = cpu_to_le32(head_td->td_info->buf_dma);\n\n\t \n\twmb();\n\thead_td->td0.owner = OWNED_BY_NIC;\n\twmb();  \n\n\tif (head_td->td_info->flags & TD_FLAGS_NETIF_SKB)\n\t\tvt6655_mac_dma_ctl(priv->port_offset, MAC_REG_AC0DMACTL);\n\telse\n\t\tvt6655_mac_dma_ctl(priv->port_offset, MAC_REG_TXDMACTL0);\n\n\tpriv->iTDUsed[dma_idx]++;\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic void vnt_tx_80211(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_tx_control *control,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tif (vnt_tx_packet(priv, skb))\n\t\tieee80211_free_txskb(hw, skb);\n}\n\nstatic int vnt_start(struct ieee80211_hw *hw)\n{\n\tstruct vnt_private *priv = hw->priv;\n\tint ret;\n\n\tpriv->rx_buf_sz = PKT_BUF_SZ;\n\tif (!device_init_rings(priv))\n\t\treturn -ENOMEM;\n\n\tret = request_irq(priv->pcid->irq, vnt_interrupt,\n\t\t\t  IRQF_SHARED, \"vt6655\", priv);\n\tif (ret) {\n\t\tdev_dbg(&priv->pcid->dev, \"failed to start irq\\n\");\n\t\tgoto err_free_rings;\n\t}\n\n\tdev_dbg(&priv->pcid->dev, \"call device init rd0 ring\\n\");\n\tret = device_init_rd0_ring(priv);\n\tif (ret)\n\t\tgoto err_free_irq;\n\tret = device_init_rd1_ring(priv);\n\tif (ret)\n\t\tgoto err_free_rd0_ring;\n\tret = device_init_td0_ring(priv);\n\tif (ret)\n\t\tgoto err_free_rd1_ring;\n\tret = device_init_td1_ring(priv);\n\tif (ret)\n\t\tgoto err_free_td0_ring;\n\n\tdevice_init_registers(priv);\n\n\tdev_dbg(&priv->pcid->dev, \"enable MAC interrupt\\n\");\n\tiowrite32(IMR_MASK_VALUE, priv->port_offset + MAC_REG_IMR);\n\n\tieee80211_wake_queues(hw);\n\n\treturn 0;\n\nerr_free_td0_ring:\n\tdevice_free_td0_ring(priv);\nerr_free_rd1_ring:\n\tdevice_free_rd1_ring(priv);\nerr_free_rd0_ring:\n\tdevice_free_rd0_ring(priv);\nerr_free_irq:\n\tfree_irq(priv->pcid->irq, priv);\nerr_free_rings:\n\tdevice_free_rings(priv);\n\treturn ret;\n}\n\nstatic void vnt_stop(struct ieee80211_hw *hw)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tieee80211_stop_queues(hw);\n\n\tcancel_work_sync(&priv->interrupt_work);\n\n\tMACbShutdown(priv);\n\tMACbSoftwareReset(priv);\n\tCARDbRadioPowerOff(priv);\n\n\tdevice_free_td0_ring(priv);\n\tdevice_free_td1_ring(priv);\n\tdevice_free_rd0_ring(priv);\n\tdevice_free_rd1_ring(priv);\n\tdevice_free_rings(priv);\n\n\tfree_irq(priv->pcid->irq, priv);\n}\n\nstatic int vnt_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tpriv->vif = vif;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tvt6655_mac_reg_bits_off(priv->port_offset, MAC_REG_RCR, RCR_UNICAST);\n\n\t\tvt6655_mac_reg_bits_on(priv->port_offset, MAC_REG_HOSTCR, HOSTCR_ADHOC);\n\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tvt6655_mac_reg_bits_off(priv->port_offset, MAC_REG_RCR, RCR_UNICAST);\n\n\t\tvt6655_mac_reg_bits_on(priv->port_offset, MAC_REG_HOSTCR, HOSTCR_AP);\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->op_mode = vif->type;\n\n\treturn 0;\n}\n\nstatic void vnt_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tvt6655_mac_reg_bits_off(priv->port_offset, MAC_REG_TCR, TCR_AUTOBCNTX);\n\t\tvt6655_mac_reg_bits_off(priv->port_offset,\n\t\t\t\t\tMAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\n\t\tvt6655_mac_reg_bits_off(priv->port_offset, MAC_REG_HOSTCR, HOSTCR_ADHOC);\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tvt6655_mac_reg_bits_off(priv->port_offset, MAC_REG_TCR, TCR_AUTOBCNTX);\n\t\tvt6655_mac_reg_bits_off(priv->port_offset,\n\t\t\t\t\tMAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\n\t\tvt6655_mac_reg_bits_off(priv->port_offset, MAC_REG_HOSTCR, HOSTCR_AP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpriv->op_mode = NL80211_IFTYPE_UNSPECIFIED;\n}\n\nstatic int vnt_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct vnt_private *priv = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tu8 bb_type;\n\n\tif (changed & IEEE80211_CONF_CHANGE_PS) {\n\t\tif (conf->flags & IEEE80211_CONF_PS)\n\t\t\tPSvEnablePowerSaving(priv, conf->listen_interval);\n\t\telse\n\t\t\tPSvDisablePowerSaving(priv);\n\t}\n\n\tif ((changed & IEEE80211_CONF_CHANGE_CHANNEL) ||\n\t    (conf->flags & IEEE80211_CONF_OFFCHANNEL)) {\n\t\tset_channel(priv, conf->chandef.chan);\n\n\t\tif (conf->chandef.chan->band == NL80211_BAND_5GHZ)\n\t\t\tbb_type = BB_TYPE_11A;\n\t\telse\n\t\t\tbb_type = BB_TYPE_11G;\n\n\t\tif (priv->byBBType != bb_type) {\n\t\t\tpriv->byBBType = bb_type;\n\n\t\t\tCARDbSetPhyParameter(priv, priv->byBBType);\n\t\t}\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_POWER) {\n\t\tif (priv->byBBType == BB_TYPE_11B)\n\t\t\tpriv->wCurrentRate = RATE_1M;\n\t\telse\n\t\t\tpriv->wCurrentRate = RATE_54M;\n\n\t\tRFbSetPower(priv, priv->wCurrentRate,\n\t\t\t    conf->chandef.chan->hw_value);\n\t}\n\n\treturn 0;\n}\n\nstatic void vnt_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *conf, u64 changed)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tpriv->current_aid = vif->cfg.aid;\n\n\tif (changed & BSS_CHANGED_BSSID && conf->bssid) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\n\t\tvt6655_mac_write_bssid_addr(priv->port_offset, conf->bssid);\n\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\tpriv->basic_rates = conf->basic_rates;\n\n\t\tCARDvUpdateBasicTopRate(priv);\n\n\t\tdev_dbg(&priv->pcid->dev,\n\t\t\t\"basic rates %x\\n\", conf->basic_rates);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\tif (conf->use_short_preamble) {\n\t\t\tvt6655_mac_en_barker_preamble_md(priv->port_offset);\n\t\t\tpriv->preamble_type = true;\n\t\t} else {\n\t\t\tvt6655_mac_dis_barker_preamble_md(priv->port_offset);\n\t\t\tpriv->preamble_type = false;\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT) {\n\t\tif (conf->use_cts_prot)\n\t\t\tvt6655_mac_en_protect_md(priv->port_offset);\n\t\telse\n\t\t\tvt6655_mac_dis_protect_md(priv->port_offset);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tif (conf->use_short_slot)\n\t\t\tpriv->short_slot_time = true;\n\t\telse\n\t\t\tpriv->short_slot_time = false;\n\n\t\tCARDbSetPhyParameter(priv, priv->byBBType);\n\t\tbb_set_vga_gain_offset(priv, priv->abyBBVGA[0]);\n\t}\n\n\tif (changed & BSS_CHANGED_TXPOWER)\n\t\tRFbSetPower(priv, priv->wCurrentRate,\n\t\t\t    conf->chandef.chan->hw_value);\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED) {\n\t\tdev_dbg(&priv->pcid->dev,\n\t\t\t\"Beacon enable %d\\n\", conf->enable_beacon);\n\n\t\tif (conf->enable_beacon) {\n\t\t\tvnt_beacon_enable(priv, vif, conf);\n\n\t\t\tvt6655_mac_reg_bits_on(priv->port_offset, MAC_REG_TCR, TCR_AUTOBCNTX);\n\t\t} else {\n\t\t\tvt6655_mac_reg_bits_off(priv->port_offset, MAC_REG_TCR,\n\t\t\t\t\t\tTCR_AUTOBCNTX);\n\t\t}\n\t}\n\n\tif (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_BEACON_INFO) &&\n\t    priv->op_mode != NL80211_IFTYPE_AP) {\n\t\tif (vif->cfg.assoc && conf->beacon_rate) {\n\t\t\tCARDbUpdateTSF(priv, conf->beacon_rate->hw_value,\n\t\t\t\t       conf->sync_tsf);\n\n\t\t\tCARDbSetBeaconPeriod(priv, conf->beacon_int);\n\n\t\t\tCARDvSetFirstNextTBTT(priv, conf->beacon_int);\n\t\t} else {\n\t\t\tiowrite8(TFTCTL_TSFCNTRST, priv->port_offset + MAC_REG_TFTCTL);\n\t\t\tiowrite8(TFTCTL_TSFCNTREN, priv->port_offset + MAC_REG_TFTCTL);\n\t\t}\n\t}\n}\n\nstatic u64 vnt_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\t\t struct netdev_hw_addr_list *mc_list)\n{\n\tstruct vnt_private *priv = hw->priv;\n\tstruct netdev_hw_addr *ha;\n\tu64 mc_filter = 0;\n\tu32 bit_nr = 0;\n\n\tnetdev_hw_addr_list_for_each(ha, mc_list) {\n\t\tbit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\n\t\tmc_filter |= 1ULL << (bit_nr & 0x3f);\n\t}\n\n\tpriv->mc_list_count = mc_list->count;\n\n\treturn mc_filter;\n}\n\nstatic void vnt_configure(struct ieee80211_hw *hw,\n\t\t\t  unsigned int changed_flags,\n\t\t\t  unsigned int *total_flags, u64 multicast)\n{\n\tstruct vnt_private *priv = hw->priv;\n\tu8 rx_mode = 0;\n\n\t*total_flags &= FIF_ALLMULTI | FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC;\n\n\trx_mode = ioread8(priv->port_offset + MAC_REG_RCR);\n\n\tdev_dbg(&priv->pcid->dev, \"rx mode in = %x\\n\", rx_mode);\n\n\tif (changed_flags & FIF_ALLMULTI) {\n\t\tif (*total_flags & FIF_ALLMULTI) {\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&priv->lock, flags);\n\n\t\t\tif (priv->mc_list_count > 2) {\n\t\t\t\tVT6655_MAC_SELECT_PAGE1(priv->port_offset);\n\n\t\t\t\tiowrite32(0xffffffff, priv->port_offset + MAC_REG_MAR0);\n\t\t\t\tiowrite32(0xffffffff, priv->port_offset + MAC_REG_MAR0 + 4);\n\n\t\t\t\tVT6655_MAC_SELECT_PAGE0(priv->port_offset);\n\t\t\t} else {\n\t\t\t\tVT6655_MAC_SELECT_PAGE1(priv->port_offset);\n\n\t\t\t\tmulticast =  le64_to_cpu(multicast);\n\t\t\t\tiowrite32((u32)multicast, priv->port_offset +  MAC_REG_MAR0);\n\t\t\t\tiowrite32((u32)(multicast >> 32),\n\t\t\t\t\t  priv->port_offset + MAC_REG_MAR0 + 4);\n\n\t\t\t\tVT6655_MAC_SELECT_PAGE0(priv->port_offset);\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t\t\trx_mode |= RCR_MULTICAST | RCR_BROADCAST;\n\t\t} else {\n\t\t\trx_mode &= ~(RCR_MULTICAST | RCR_BROADCAST);\n\t\t}\n\t}\n\n\tif (changed_flags & (FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC)) {\n\t\trx_mode |= RCR_MULTICAST | RCR_BROADCAST;\n\n\t\tif (*total_flags & (FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC))\n\t\t\trx_mode &= ~RCR_BSSID;\n\t\telse\n\t\t\trx_mode |= RCR_BSSID;\n\t}\n\n\tiowrite8(rx_mode, priv->port_offset + MAC_REG_RCR);\n\n\tdev_dbg(&priv->pcid->dev, \"rx mode out= %x\\n\", rx_mode);\n}\n\nstatic int vnt_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t       struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t       struct ieee80211_key_conf *key)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tif (vnt_set_keys(hw, sta, vif, key))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\tif (test_bit(key->hw_key_idx, &priv->key_entry_inuse))\n\t\t\tclear_bit(key->hw_key_idx, &priv->key_entry_inuse);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int vnt_get_stats(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_low_level_stats *stats)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tmemcpy(stats, &priv->low_stats, sizeof(*stats));\n\n\treturn 0;\n}\n\nstatic u64 vnt_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct vnt_private *priv = hw->priv;\n\tu64 tsf;\n\n\ttsf = vt6655_get_current_tsf(priv);\n\n\treturn tsf;\n}\n\nstatic void vnt_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tu64 tsf)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\tCARDvUpdateNextTBTT(priv, tsf, vif->bss_conf.beacon_int);\n}\n\nstatic void vnt_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct vnt_private *priv = hw->priv;\n\n\t \n\tiowrite8(TFTCTL_TSFCNTRST, priv->port_offset + MAC_REG_TFTCTL);\n}\n\nstatic const struct ieee80211_ops vnt_mac_ops = {\n\t.tx\t\t\t= vnt_tx_80211,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= vnt_start,\n\t.stop\t\t\t= vnt_stop,\n\t.add_interface\t\t= vnt_add_interface,\n\t.remove_interface\t= vnt_remove_interface,\n\t.config\t\t\t= vnt_config,\n\t.bss_info_changed\t= vnt_bss_info_changed,\n\t.prepare_multicast\t= vnt_prepare_multicast,\n\t.configure_filter\t= vnt_configure,\n\t.set_key\t\t= vnt_set_key,\n\t.get_stats\t\t= vnt_get_stats,\n\t.get_tsf\t\t= vnt_get_tsf,\n\t.set_tsf\t\t= vnt_set_tsf,\n\t.reset_tsf\t\t= vnt_reset_tsf,\n};\n\nstatic int vnt_init(struct vnt_private *priv)\n{\n\tSET_IEEE80211_PERM_ADDR(priv->hw, priv->abyCurrentNetAddr);\n\n\tvnt_init_bands(priv);\n\n\tif (ieee80211_register_hw(priv->hw))\n\t\treturn -ENODEV;\n\n\tpriv->mac_hw = true;\n\n\tCARDbRadioPowerOff(priv);\n\n\treturn 0;\n}\n\nstatic int\nvt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)\n{\n\tstruct vnt_private *priv;\n\tstruct ieee80211_hw *hw;\n\tstruct wiphy *wiphy;\n\tint         rc;\n\n\tdev_notice(&pcid->dev,\n\t\t   \"%s Ver. %s\\n\", DEVICE_FULL_DRV_NAM, DEVICE_VERSION);\n\n\tdev_notice(&pcid->dev,\n\t\t   \"Copyright (c) 2003 VIA Networking Technologies, Inc.\\n\");\n\n\thw = ieee80211_alloc_hw(sizeof(*priv), &vnt_mac_ops);\n\tif (!hw) {\n\t\tdev_err(&pcid->dev, \"could not register ieee80211_hw\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = hw->priv;\n\tpriv->pcid = pcid;\n\n\tspin_lock_init(&priv->lock);\n\n\tpriv->hw = hw;\n\n\tSET_IEEE80211_DEV(priv->hw, &pcid->dev);\n\n\tif (pci_enable_device(pcid)) {\n\t\tdevice_free_info(priv);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&pcid->dev,\n\t\t\"Before get pci_info memaddr is %x\\n\", priv->memaddr);\n\n\tpci_set_master(pcid);\n\n\tpriv->memaddr = pci_resource_start(pcid, 0);\n\tpriv->ioaddr = pci_resource_start(pcid, 1);\n\tpriv->port_offset = ioremap(priv->memaddr & PCI_BASE_ADDRESS_MEM_MASK,\n\t\t\t\t   256);\n\tif (!priv->port_offset) {\n\t\tdev_err(&pcid->dev, \": Failed to IO remapping ..\\n\");\n\t\tdevice_free_info(priv);\n\t\treturn -ENODEV;\n\t}\n\n\trc = pci_request_regions(pcid, DEVICE_NAME);\n\tif (rc) {\n\t\tdev_err(&pcid->dev, \": Failed to find PCI device\\n\");\n\t\tdevice_free_info(priv);\n\t\treturn -ENODEV;\n\t}\n\n\tif (dma_set_mask(&pcid->dev, DMA_BIT_MASK(32))) {\n\t\tdev_err(&pcid->dev, \": Failed to set dma 32 bit mask\\n\");\n\t\tdevice_free_info(priv);\n\t\treturn -ENODEV;\n\t}\n\n\tINIT_WORK(&priv->interrupt_work, vnt_interrupt_work);\n\n\t \n\tif (!MACbSoftwareReset(priv)) {\n\t\tdev_err(&pcid->dev, \": Failed to access MAC hardware..\\n\");\n\t\tdevice_free_info(priv);\n\t\treturn -ENODEV;\n\t}\n\t \n\tMACvInitialize(priv);\n\tvt6655_mac_read_ether_addr(priv->port_offset, priv->abyCurrentNetAddr);\n\n\t \n\tpriv->byRFType = SROMbyReadEmbedded(priv->port_offset, EEP_OFS_RFTYPE);\n\tpriv->byRFType &= RF_MASK;\n\n\tdev_dbg(&pcid->dev, \"RF Type = %x\\n\", priv->byRFType);\n\n\tdevice_get_options(priv);\n\tdevice_set_options(priv);\n\n\twiphy = priv->hw->wiphy;\n\n\twiphy->frag_threshold = FRAG_THRESH_DEF;\n\twiphy->rts_threshold = RTS_THRESH_DEF;\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_ADHOC) | BIT(NL80211_IFTYPE_AP);\n\n\tieee80211_hw_set(priv->hw, TIMING_BEACON_ONLY);\n\tieee80211_hw_set(priv->hw, SIGNAL_DBM);\n\tieee80211_hw_set(priv->hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(priv->hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(priv->hw, SUPPORTS_PS);\n\n\tpriv->hw->max_signal = 100;\n\n\tif (vnt_init(priv)) {\n\t\tdevice_free_info(priv);\n\t\treturn -ENODEV;\n\t}\n\n\tdevice_print_info(priv);\n\tpci_set_drvdata(pcid, priv);\n\n\treturn 0;\n}\n\n \n\nstatic int __maybe_unused vt6655_suspend(struct device *dev_d)\n{\n\tstruct vnt_private *priv = dev_get_drvdata(dev_d);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tMACbShutdown(priv);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused vt6655_resume(struct device *dev_d)\n{\n\tdevice_wakeup_disable(dev_d);\n\n\treturn 0;\n}\n\nMODULE_DEVICE_TABLE(pci, vt6655_pci_id_table);\n\nstatic SIMPLE_DEV_PM_OPS(vt6655_pm_ops, vt6655_suspend, vt6655_resume);\n\nstatic struct pci_driver device_driver = {\n\t.name = DEVICE_NAME,\n\t.id_table = vt6655_pci_id_table,\n\t.probe = vt6655_probe,\n\t.remove = vt6655_remove,\n\t.driver.pm = &vt6655_pm_ops,\n};\n\nmodule_pci_driver(device_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}