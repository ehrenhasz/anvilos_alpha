{
  "module_name": "acpi_pcc.c",
  "hash_id": "48087538c6634cc78d8301dc124278c4b56c02a93bdf42d2cfd8338c622c7242",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_pcc.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/acpi.h>\n#include <linux/completion.h>\n#include <linux/idr.h>\n#include <linux/io.h>\n\n#include <acpi/pcc.h>\n\n \n#define PCC_CMD_WAIT_RETRIES_NUM\t500ULL\n\nstruct pcc_data {\n\tstruct pcc_mbox_chan *pcc_chan;\n\tvoid __iomem *pcc_comm_addr;\n\tstruct completion done;\n\tstruct mbox_client cl;\n\tstruct acpi_pcc_info ctx;\n};\n\nstatic struct acpi_pcc_info pcc_ctx;\n\nstatic void pcc_rx_callback(struct mbox_client *cl, void *m)\n{\n\tstruct pcc_data *data = container_of(cl, struct pcc_data, cl);\n\n\tcomplete(&data->done);\n}\n\nstatic acpi_status\nacpi_pcc_address_space_setup(acpi_handle region_handle, u32 function,\n\t\t\t     void *handler_context,  void **region_context)\n{\n\tstruct pcc_data *data;\n\tstruct acpi_pcc_info *ctx = handler_context;\n\tstruct pcc_mbox_chan *pcc_chan;\n\tstatic acpi_status ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn AE_NO_MEMORY;\n\n\tdata->cl.rx_callback = pcc_rx_callback;\n\tdata->cl.knows_txdone = true;\n\tdata->ctx.length = ctx->length;\n\tdata->ctx.subspace_id = ctx->subspace_id;\n\tdata->ctx.internal_buffer = ctx->internal_buffer;\n\n\tinit_completion(&data->done);\n\tdata->pcc_chan = pcc_mbox_request_channel(&data->cl, ctx->subspace_id);\n\tif (IS_ERR(data->pcc_chan)) {\n\t\tpr_err(\"Failed to find PCC channel for subspace %d\\n\",\n\t\t       ctx->subspace_id);\n\t\tret = AE_NOT_FOUND;\n\t\tgoto err_free_data;\n\t}\n\n\tpcc_chan = data->pcc_chan;\n\tif (!pcc_chan->mchan->mbox->txdone_irq) {\n\t\tpr_err(\"This channel-%d does not support interrupt.\\n\",\n\t\t       ctx->subspace_id);\n\t\tret = AE_SUPPORT;\n\t\tgoto err_free_channel;\n\t}\n\tdata->pcc_comm_addr = acpi_os_ioremap(pcc_chan->shmem_base_addr,\n\t\t\t\t\t      pcc_chan->shmem_size);\n\tif (!data->pcc_comm_addr) {\n\t\tpr_err(\"Failed to ioremap PCC comm region mem for %d\\n\",\n\t\t       ctx->subspace_id);\n\t\tret = AE_NO_MEMORY;\n\t\tgoto err_free_channel;\n\t}\n\n\t*region_context = data;\n\treturn AE_OK;\n\nerr_free_channel:\n\tpcc_mbox_free_channel(data->pcc_chan);\nerr_free_data:\n\tkfree(data);\n\n\treturn ret;\n}\n\nstatic acpi_status\nacpi_pcc_address_space_handler(u32 function, acpi_physical_address addr,\n\t\t\t       u32 bits, acpi_integer *value,\n\t\t\t       void *handler_context, void *region_context)\n{\n\tint ret;\n\tstruct pcc_data *data = region_context;\n\tu64 usecs_lat;\n\n\treinit_completion(&data->done);\n\n\t \n\tmemcpy_toio(data->pcc_comm_addr, (void *)value, data->ctx.length);\n\n\tret = mbox_send_message(data->pcc_chan->mchan, NULL);\n\tif (ret < 0)\n\t\treturn AE_ERROR;\n\n\t \n\tusecs_lat = PCC_CMD_WAIT_RETRIES_NUM * data->pcc_chan->latency;\n\tret = wait_for_completion_timeout(&data->done,\n\t\t\t\t\t\tusecs_to_jiffies(usecs_lat));\n\tif (ret == 0) {\n\t\tpr_err(\"PCC command executed timeout!\\n\");\n\t\treturn AE_TIME;\n\t}\n\n\tmbox_chan_txdone(data->pcc_chan->mchan, ret);\n\n\tmemcpy_fromio(value, data->pcc_comm_addr, data->ctx.length);\n\n\treturn AE_OK;\n}\n\nvoid __init acpi_init_pcc(void)\n{\n\tacpi_status status;\n\n\tstatus = acpi_install_address_space_handler(ACPI_ROOT_OBJECT,\n\t\t\t\t\t\t    ACPI_ADR_SPACE_PLATFORM_COMM,\n\t\t\t\t\t\t    &acpi_pcc_address_space_handler,\n\t\t\t\t\t\t    &acpi_pcc_address_space_setup,\n\t\t\t\t\t\t    &pcc_ctx);\n\tif (ACPI_FAILURE(status))\n\t\tpr_alert(\"OperationRegion handler could not be installed\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}