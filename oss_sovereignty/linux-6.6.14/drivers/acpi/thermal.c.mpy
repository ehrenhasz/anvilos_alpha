{
  "module_name": "thermal.c",
  "hash_id": "8582fd01f00ffdac7dee42fc0f73ddc047e4d242ddc616e489b6e5b9860242ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/thermal.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: thermal: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/dmi.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jiffies.h>\n#include <linux/kmod.h>\n#include <linux/reboot.h>\n#include <linux/device.h>\n#include <linux/thermal.h>\n#include <linux/acpi.h>\n#include <linux/workqueue.h>\n#include <linux/uaccess.h>\n#include <linux/units.h>\n\n#define ACPI_THERMAL_CLASS\t\t\"thermal_zone\"\n#define ACPI_THERMAL_DEVICE_NAME\t\"Thermal Zone\"\n#define ACPI_THERMAL_NOTIFY_TEMPERATURE\t0x80\n#define ACPI_THERMAL_NOTIFY_THRESHOLDS\t0x81\n#define ACPI_THERMAL_NOTIFY_DEVICES\t0x82\n#define ACPI_THERMAL_NOTIFY_CRITICAL\t0xF0\n#define ACPI_THERMAL_NOTIFY_HOT\t\t0xF1\n#define ACPI_THERMAL_MODE_ACTIVE\t0x00\n\n#define ACPI_THERMAL_MAX_ACTIVE\t\t10\n#define ACPI_THERMAL_MAX_LIMIT_STR_LEN\t65\n\n#define ACPI_TRIPS_CRITICAL\tBIT(0)\n#define ACPI_TRIPS_HOT\t\tBIT(1)\n#define ACPI_TRIPS_PASSIVE\tBIT(2)\n#define ACPI_TRIPS_ACTIVE\tBIT(3)\n#define ACPI_TRIPS_DEVICES\tBIT(4)\n\n#define ACPI_TRIPS_THRESHOLDS\t(ACPI_TRIPS_PASSIVE | ACPI_TRIPS_ACTIVE)\n\n#define ACPI_TRIPS_INIT\t\t(ACPI_TRIPS_CRITICAL | ACPI_TRIPS_HOT | \\\n\t\t\t\t ACPI_TRIPS_PASSIVE | ACPI_TRIPS_ACTIVE | \\\n\t\t\t\t ACPI_TRIPS_DEVICES)\n\n \n#define ACPI_THERMAL_TRIPS_EXCEPTION(flags, tz, str) \\\ndo { \\\n\tif (flags != ACPI_TRIPS_INIT) \\\n\t\tacpi_handle_info(tz->device->handle, \\\n\t\t\t\"ACPI thermal trip point %s changed\\n\" \\\n\t\t\t\"Please report to linux-acpi@vger.kernel.org\\n\", str); \\\n} while (0)\n\nstatic int act;\nmodule_param(act, int, 0644);\nMODULE_PARM_DESC(act, \"Disable or override all lowest active trip points.\");\n\nstatic int crt;\nmodule_param(crt, int, 0644);\nMODULE_PARM_DESC(crt, \"Disable or lower all critical trip points.\");\n\nstatic int tzp;\nmodule_param(tzp, int, 0444);\nMODULE_PARM_DESC(tzp, \"Thermal zone polling frequency, in 1/10 seconds.\");\n\nstatic int off;\nmodule_param(off, int, 0);\nMODULE_PARM_DESC(off, \"Set to disable ACPI thermal support.\");\n\nstatic int psv;\nmodule_param(psv, int, 0644);\nMODULE_PARM_DESC(psv, \"Disable or override all passive trip points.\");\n\nstatic struct workqueue_struct *acpi_thermal_pm_queue;\n\nstruct acpi_thermal_trip {\n\tunsigned long temperature;\n\tbool valid;\n};\n\nstruct acpi_thermal_passive {\n\tstruct acpi_thermal_trip trip;\n\tstruct acpi_handle_list devices;\n\tunsigned long tc1;\n\tunsigned long tc2;\n\tunsigned long tsp;\n};\n\nstruct acpi_thermal_active {\n\tstruct acpi_thermal_trip trip;\n\tstruct acpi_handle_list devices;\n};\n\nstruct acpi_thermal_trips {\n\tstruct acpi_thermal_trip critical;\n\tstruct acpi_thermal_trip hot;\n\tstruct acpi_thermal_passive passive;\n\tstruct acpi_thermal_active active[ACPI_THERMAL_MAX_ACTIVE];\n};\n\nstruct acpi_thermal {\n\tstruct acpi_device *device;\n\tacpi_bus_id name;\n\tunsigned long temperature;\n\tunsigned long last_temperature;\n\tunsigned long polling_frequency;\n\tvolatile u8 zombie;\n\tstruct acpi_thermal_trips trips;\n\tstruct thermal_trip *trip_table;\n\tstruct acpi_handle_list devices;\n\tstruct thermal_zone_device *thermal_zone;\n\tint kelvin_offset;\t \n\tstruct work_struct thermal_check_work;\n\tstruct mutex thermal_check_lock;\n\trefcount_t thermal_check_count;\n};\n\n \n\nstatic int acpi_thermal_get_temperature(struct acpi_thermal *tz)\n{\n\tacpi_status status = AE_OK;\n\tunsigned long long tmp;\n\n\tif (!tz)\n\t\treturn -EINVAL;\n\n\ttz->last_temperature = tz->temperature;\n\n\tstatus = acpi_evaluate_integer(tz->device->handle, \"_TMP\", NULL, &tmp);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\ttz->temperature = tmp;\n\n\tacpi_handle_debug(tz->device->handle, \"Temperature is %lu dK\\n\",\n\t\t\t  tz->temperature);\n\n\treturn 0;\n}\n\nstatic int acpi_thermal_get_polling_frequency(struct acpi_thermal *tz)\n{\n\tacpi_status status = AE_OK;\n\tunsigned long long tmp;\n\n\tif (!tz)\n\t\treturn -EINVAL;\n\n\tstatus = acpi_evaluate_integer(tz->device->handle, \"_TZP\", NULL, &tmp);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\ttz->polling_frequency = tmp;\n\tacpi_handle_debug(tz->device->handle, \"Polling frequency is %lu dS\\n\",\n\t\t\t  tz->polling_frequency);\n\n\treturn 0;\n}\n\nstatic int acpi_thermal_temp(struct acpi_thermal *tz, int temp_deci_k)\n{\n\tif (temp_deci_k == THERMAL_TEMP_INVALID)\n\t\treturn THERMAL_TEMP_INVALID;\n\n\treturn deci_kelvin_to_millicelsius_with_offset(temp_deci_k,\n\t\t\t\t\t\t       tz->kelvin_offset);\n}\n\nstatic void __acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)\n{\n\tacpi_status status;\n\tunsigned long long tmp;\n\tstruct acpi_handle_list devices;\n\tbool valid = false;\n\tint i;\n\n\t \n\tif (flag & ACPI_TRIPS_CRITICAL) {\n\t\tstatus = acpi_evaluate_integer(tz->device->handle, \"_CRT\", NULL, &tmp);\n\t\ttz->trips.critical.temperature = tmp;\n\t\t \n\t\tif (ACPI_FAILURE(status)) {\n\t\t\ttz->trips.critical.valid = false;\n\t\t\tacpi_handle_debug(tz->device->handle,\n\t\t\t\t\t  \"No critical threshold\\n\");\n\t\t} else if (tmp <= 2732) {\n\t\t\tpr_info(FW_BUG \"Invalid critical threshold (%llu)\\n\", tmp);\n\t\t\ttz->trips.critical.valid = false;\n\t\t} else {\n\t\t\ttz->trips.critical.valid = true;\n\t\t\tacpi_handle_debug(tz->device->handle,\n\t\t\t\t\t  \"Found critical threshold [%lu]\\n\",\n\t\t\t\t\t  tz->trips.critical.temperature);\n\t\t}\n\t\tif (tz->trips.critical.valid) {\n\t\t\tif (crt == -1) {\n\t\t\t\ttz->trips.critical.valid = false;\n\t\t\t} else if (crt > 0) {\n\t\t\t\tunsigned long crt_k = celsius_to_deci_kelvin(crt);\n\n\t\t\t\t \n\t\t\t\tif (crt_k > tz->trips.critical.temperature)\n\t\t\t\t\tpr_info(\"Critical threshold %d C\\n\", crt);\n\n\t\t\t\ttz->trips.critical.temperature = crt_k;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (flag & ACPI_TRIPS_HOT) {\n\t\tstatus = acpi_evaluate_integer(tz->device->handle, \"_HOT\", NULL, &tmp);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\ttz->trips.hot.valid = false;\n\t\t\tacpi_handle_debug(tz->device->handle,\n\t\t\t\t\t  \"No hot threshold\\n\");\n\t\t} else {\n\t\t\ttz->trips.hot.temperature = tmp;\n\t\t\ttz->trips.hot.valid = true;\n\t\t\tacpi_handle_debug(tz->device->handle,\n\t\t\t\t\t  \"Found hot threshold [%lu]\\n\",\n\t\t\t\t\t  tz->trips.hot.temperature);\n\t\t}\n\t}\n\n\t \n\tif (((flag & ACPI_TRIPS_PASSIVE) && tz->trips.passive.trip.valid) ||\n\t    flag == ACPI_TRIPS_INIT) {\n\t\tvalid = tz->trips.passive.trip.valid;\n\t\tif (psv == -1) {\n\t\t\tstatus = AE_SUPPORT;\n\t\t} else if (psv > 0) {\n\t\t\ttmp = celsius_to_deci_kelvin(psv);\n\t\t\tstatus = AE_OK;\n\t\t} else {\n\t\t\tstatus = acpi_evaluate_integer(tz->device->handle,\n\t\t\t\t\t\t       \"_PSV\", NULL, &tmp);\n\t\t}\n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\ttz->trips.passive.trip.valid = false;\n\t\t} else {\n\t\t\ttz->trips.passive.trip.temperature = tmp;\n\t\t\ttz->trips.passive.trip.valid = true;\n\t\t\tif (flag == ACPI_TRIPS_INIT) {\n\t\t\t\tstatus = acpi_evaluate_integer(tz->device->handle,\n\t\t\t\t\t\t\t       \"_TC1\", NULL, &tmp);\n\t\t\t\tif (ACPI_FAILURE(status))\n\t\t\t\t\ttz->trips.passive.trip.valid = false;\n\t\t\t\telse\n\t\t\t\t\ttz->trips.passive.tc1 = tmp;\n\n\t\t\t\tstatus = acpi_evaluate_integer(tz->device->handle,\n\t\t\t\t\t\t\t       \"_TC2\", NULL, &tmp);\n\t\t\t\tif (ACPI_FAILURE(status))\n\t\t\t\t\ttz->trips.passive.trip.valid = false;\n\t\t\t\telse\n\t\t\t\t\ttz->trips.passive.tc2 = tmp;\n\n\t\t\t\tstatus = acpi_evaluate_integer(tz->device->handle,\n\t\t\t\t\t\t\t       \"_TSP\", NULL, &tmp);\n\t\t\t\tif (ACPI_FAILURE(status))\n\t\t\t\t\ttz->trips.passive.trip.valid = false;\n\t\t\t\telse\n\t\t\t\t\ttz->trips.passive.tsp = tmp;\n\t\t\t}\n\t\t}\n\t}\n\tif ((flag & ACPI_TRIPS_DEVICES) && tz->trips.passive.trip.valid) {\n\t\tmemset(&devices, 0, sizeof(struct acpi_handle_list));\n\t\tstatus = acpi_evaluate_reference(tz->device->handle, \"_PSL\",\n\t\t\t\t\t\t NULL, &devices);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_handle_info(tz->device->handle,\n\t\t\t\t\t \"Invalid passive threshold\\n\");\n\t\t\ttz->trips.passive.trip.valid = false;\n\t\t} else {\n\t\t\ttz->trips.passive.trip.valid = true;\n\t\t}\n\n\t\tif (memcmp(&tz->trips.passive.devices, &devices,\n\t\t\t   sizeof(struct acpi_handle_list))) {\n\t\t\tmemcpy(&tz->trips.passive.devices, &devices,\n\t\t\t       sizeof(struct acpi_handle_list));\n\t\t\tACPI_THERMAL_TRIPS_EXCEPTION(flag, tz, \"device\");\n\t\t}\n\t}\n\tif ((flag & ACPI_TRIPS_PASSIVE) || (flag & ACPI_TRIPS_DEVICES)) {\n\t\tif (valid != tz->trips.passive.trip.valid)\n\t\t\tACPI_THERMAL_TRIPS_EXCEPTION(flag, tz, \"state\");\n\t}\n\n\t \n\tfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {\n\t\tchar name[5] = { '_', 'A', 'C', ('0' + i), '\\0' };\n\t\tvalid = tz->trips.active[i].trip.valid;\n\n\t\tif (act == -1)\n\t\t\tbreak;  \n\n\t\tif (flag == ACPI_TRIPS_INIT || ((flag & ACPI_TRIPS_ACTIVE) &&\n\t\t    tz->trips.active[i].trip.valid)) {\n\t\t\tstatus = acpi_evaluate_integer(tz->device->handle,\n\t\t\t\t\t\t       name, NULL, &tmp);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\ttz->trips.active[i].trip.valid = false;\n\t\t\t\tif (i == 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (act <= 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (i == 1)\n\t\t\t\t\ttz->trips.active[0].trip.temperature =\n\t\t\t\t\t\t\tcelsius_to_deci_kelvin(act);\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\ttz->trips.active[i-1].trip.temperature =\n\t\t\t\t\t\tmin_t(unsigned long,\n\t\t\t\t\t\t      tz->trips.active[i-2].trip.temperature,\n\t\t\t\t\t\t      celsius_to_deci_kelvin(act));\n\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ttz->trips.active[i].trip.temperature = tmp;\n\t\t\t\ttz->trips.active[i].trip.valid = true;\n\t\t\t}\n\t\t}\n\n\t\tname[2] = 'L';\n\t\tif ((flag & ACPI_TRIPS_DEVICES) && tz->trips.active[i].trip.valid) {\n\t\t\tmemset(&devices, 0, sizeof(struct acpi_handle_list));\n\t\t\tstatus = acpi_evaluate_reference(tz->device->handle,\n\t\t\t\t\t\t\t name, NULL, &devices);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tacpi_handle_info(tz->device->handle,\n\t\t\t\t\t\t \"Invalid active%d threshold\\n\", i);\n\t\t\t\ttz->trips.active[i].trip.valid = false;\n\t\t\t} else {\n\t\t\t\ttz->trips.active[i].trip.valid = true;\n\t\t\t}\n\n\t\t\tif (memcmp(&tz->trips.active[i].devices, &devices,\n\t\t\t\t   sizeof(struct acpi_handle_list))) {\n\t\t\t\tmemcpy(&tz->trips.active[i].devices, &devices,\n\t\t\t\t       sizeof(struct acpi_handle_list));\n\t\t\t\tACPI_THERMAL_TRIPS_EXCEPTION(flag, tz, \"device\");\n\t\t\t}\n\t\t}\n\t\tif ((flag & ACPI_TRIPS_ACTIVE) || (flag & ACPI_TRIPS_DEVICES))\n\t\t\tif (valid != tz->trips.active[i].trip.valid)\n\t\t\t\tACPI_THERMAL_TRIPS_EXCEPTION(flag, tz, \"state\");\n\n\t\tif (!tz->trips.active[i].trip.valid)\n\t\t\tbreak;\n\t}\n\n\tif (flag & ACPI_TRIPS_DEVICES) {\n\t\tmemset(&devices, 0, sizeof(devices));\n\t\tstatus = acpi_evaluate_reference(tz->device->handle, \"_TZD\",\n\t\t\t\t\t\t NULL, &devices);\n\t\tif (ACPI_SUCCESS(status) &&\n\t\t    memcmp(&tz->devices, &devices, sizeof(devices))) {\n\t\t\ttz->devices = devices;\n\t\t\tACPI_THERMAL_TRIPS_EXCEPTION(flag, tz, \"device\");\n\t\t}\n\t}\n}\n\nstatic int acpi_thermal_adjust_trip(struct thermal_trip *trip, void *data)\n{\n\tstruct acpi_thermal_trip *acpi_trip = trip->priv;\n\tstruct acpi_thermal *tz = data;\n\n\tif (!acpi_trip)\n\t\treturn 0;\n\n\tif (acpi_trip->valid)\n\t\ttrip->temperature = acpi_thermal_temp(tz, acpi_trip->temperature);\n\telse\n\t\ttrip->temperature = THERMAL_TEMP_INVALID;\n\n\treturn 0;\n}\n\nstatic void acpi_thermal_adjust_thermal_zone(struct thermal_zone_device *thermal,\n\t\t\t\t\t     unsigned long data)\n{\n\tstruct acpi_thermal *tz = thermal_zone_device_priv(thermal);\n\tint flag = data == ACPI_THERMAL_NOTIFY_THRESHOLDS ?\n\t\t\t\tACPI_TRIPS_THRESHOLDS : ACPI_TRIPS_DEVICES;\n\n\t__acpi_thermal_trips_update(tz, flag);\n\n\tfor_each_thermal_trip(tz->thermal_zone, acpi_thermal_adjust_trip, tz);\n}\n\nstatic void acpi_queue_thermal_check(struct acpi_thermal *tz)\n{\n\tif (!work_pending(&tz->thermal_check_work))\n\t\tqueue_work(acpi_thermal_pm_queue, &tz->thermal_check_work);\n}\n\nstatic void acpi_thermal_trips_update(struct acpi_thermal *tz, u32 event)\n{\n\tstruct acpi_device *adev = tz->device;\n\n\t \n\tthermal_zone_device_exec(tz->thermal_zone,\n\t\t\t\t acpi_thermal_adjust_thermal_zone, event);\n\tacpi_queue_thermal_check(tz);\n\tacpi_bus_generate_netlink_event(adev->pnp.device_class,\n\t\t\t\t\tdev_name(&adev->dev), event, 0);\n}\n\nstatic int acpi_thermal_get_trip_points(struct acpi_thermal *tz)\n{\n\tbool valid;\n\tint i;\n\n\t__acpi_thermal_trips_update(tz, ACPI_TRIPS_INIT);\n\n\tvalid = tz->trips.critical.valid |\n\t\ttz->trips.hot.valid |\n\t\ttz->trips.passive.trip.valid;\n\n\tfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++)\n\t\tvalid = valid || tz->trips.active[i].trip.valid;\n\n\tif (!valid) {\n\t\tpr_warn(FW_BUG \"No valid trip found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int thermal_get_temp(struct thermal_zone_device *thermal, int *temp)\n{\n\tstruct acpi_thermal *tz = thermal_zone_device_priv(thermal);\n\tint result;\n\n\tif (!tz)\n\t\treturn -EINVAL;\n\n\tresult = acpi_thermal_get_temperature(tz);\n\tif (result)\n\t\treturn result;\n\n\t*temp = deci_kelvin_to_millicelsius_with_offset(tz->temperature,\n\t\t\t\t\t\t\ttz->kelvin_offset);\n\treturn 0;\n}\n\nstatic int thermal_get_trend(struct thermal_zone_device *thermal,\n\t\t\t     const struct thermal_trip *trip,\n\t\t\t     enum thermal_trend *trend)\n{\n\tstruct acpi_thermal *tz = thermal_zone_device_priv(thermal);\n\tstruct acpi_thermal_trip *acpi_trip;\n\tint t;\n\n\tif (!tz || !trip)\n\t\treturn -EINVAL;\n\n\tacpi_trip = trip->priv;\n\tif (!acpi_trip || !acpi_trip->valid)\n\t\treturn -EINVAL;\n\n\tswitch (trip->type) {\n\tcase THERMAL_TRIP_PASSIVE:\n\t\tt = tz->trips.passive.tc1 * (tz->temperature -\n\t\t\t\t\t\ttz->last_temperature) +\n\t\t\ttz->trips.passive.tc2 * (tz->temperature -\n\t\t\t\t\t\tacpi_trip->temperature);\n\t\tif (t > 0)\n\t\t\t*trend = THERMAL_TREND_RAISING;\n\t\telse if (t < 0)\n\t\t\t*trend = THERMAL_TREND_DROPPING;\n\t\telse\n\t\t\t*trend = THERMAL_TREND_STABLE;\n\n\t\treturn 0;\n\n\tcase THERMAL_TRIP_ACTIVE:\n\t\tt = acpi_thermal_temp(tz, tz->temperature);\n\t\tif (t <= trip->temperature)\n\t\t\tbreak;\n\n\t\t*trend = THERMAL_TREND_RAISING;\n\n\t\treturn 0;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void acpi_thermal_zone_device_hot(struct thermal_zone_device *thermal)\n{\n\tstruct acpi_thermal *tz = thermal_zone_device_priv(thermal);\n\n\tacpi_bus_generate_netlink_event(tz->device->pnp.device_class,\n\t\t\t\t\tdev_name(&tz->device->dev),\n\t\t\t\t\tACPI_THERMAL_NOTIFY_HOT, 1);\n}\n\nstatic void acpi_thermal_zone_device_critical(struct thermal_zone_device *thermal)\n{\n\tstruct acpi_thermal *tz = thermal_zone_device_priv(thermal);\n\n\tacpi_bus_generate_netlink_event(tz->device->pnp.device_class,\n\t\t\t\t\tdev_name(&tz->device->dev),\n\t\t\t\t\tACPI_THERMAL_NOTIFY_CRITICAL, 1);\n\n\tthermal_zone_device_critical(thermal);\n}\n\nstatic int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,\n\t\t\t\t\t  struct thermal_cooling_device *cdev,\n\t\t\t\t\t  bool bind)\n{\n\tstruct acpi_device *device = cdev->devdata;\n\tstruct acpi_thermal *tz = thermal_zone_device_priv(thermal);\n\tstruct acpi_device *dev;\n\tacpi_handle handle;\n\tint i;\n\tint j;\n\tint trip = -1;\n\tint result = 0;\n\n\tif (tz->trips.critical.valid)\n\t\ttrip++;\n\n\tif (tz->trips.hot.valid)\n\t\ttrip++;\n\n\tif (tz->trips.passive.trip.valid) {\n\t\ttrip++;\n\t\tfor (i = 0; i < tz->trips.passive.devices.count; i++) {\n\t\t\thandle = tz->trips.passive.devices.handles[i];\n\t\t\tdev = acpi_fetch_acpi_dev(handle);\n\t\t\tif (dev != device)\n\t\t\t\tcontinue;\n\n\t\t\tif (bind)\n\t\t\t\tresult = thermal_zone_bind_cooling_device(\n\t\t\t\t\t\tthermal, trip, cdev,\n\t\t\t\t\t\tTHERMAL_NO_LIMIT,\n\t\t\t\t\t\tTHERMAL_NO_LIMIT,\n\t\t\t\t\t\tTHERMAL_WEIGHT_DEFAULT);\n\t\t\telse\n\t\t\t\tresult =\n\t\t\t\t\tthermal_zone_unbind_cooling_device(\n\t\t\t\t\t\tthermal, trip, cdev);\n\n\t\t\tif (result)\n\t\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {\n\t\tif (!tz->trips.active[i].trip.valid)\n\t\t\tbreak;\n\n\t\ttrip++;\n\t\tfor (j = 0; j < tz->trips.active[i].devices.count; j++) {\n\t\t\thandle = tz->trips.active[i].devices.handles[j];\n\t\t\tdev = acpi_fetch_acpi_dev(handle);\n\t\t\tif (dev != device)\n\t\t\t\tcontinue;\n\n\t\t\tif (bind)\n\t\t\t\tresult = thermal_zone_bind_cooling_device(\n\t\t\t\t\t\tthermal, trip, cdev,\n\t\t\t\t\t\tTHERMAL_NO_LIMIT,\n\t\t\t\t\t\tTHERMAL_NO_LIMIT,\n\t\t\t\t\t\tTHERMAL_WEIGHT_DEFAULT);\n\t\t\telse\n\t\t\t\tresult = thermal_zone_unbind_cooling_device(\n\t\t\t\t\t\tthermal, trip, cdev);\n\n\t\t\tif (result)\n\t\t\t\tgoto failed;\n\t\t}\n\t}\n\nfailed:\n\treturn result;\n}\n\nstatic int\nacpi_thermal_bind_cooling_device(struct thermal_zone_device *thermal,\n\t\t\t\t struct thermal_cooling_device *cdev)\n{\n\treturn acpi_thermal_cooling_device_cb(thermal, cdev, true);\n}\n\nstatic int\nacpi_thermal_unbind_cooling_device(struct thermal_zone_device *thermal,\n\t\t\t\t   struct thermal_cooling_device *cdev)\n{\n\treturn acpi_thermal_cooling_device_cb(thermal, cdev, false);\n}\n\nstatic struct thermal_zone_device_ops acpi_thermal_zone_ops = {\n\t.bind = acpi_thermal_bind_cooling_device,\n\t.unbind\t= acpi_thermal_unbind_cooling_device,\n\t.get_temp = thermal_get_temp,\n\t.get_trend = thermal_get_trend,\n\t.hot = acpi_thermal_zone_device_hot,\n\t.critical = acpi_thermal_zone_device_critical,\n};\n\nstatic int acpi_thermal_zone_sysfs_add(struct acpi_thermal *tz)\n{\n\tstruct device *tzdev = thermal_zone_device(tz->thermal_zone);\n\tint ret;\n\n\tret = sysfs_create_link(&tz->device->dev.kobj,\n\t\t\t\t&tzdev->kobj, \"thermal_zone\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_create_link(&tzdev->kobj,\n\t\t\t\t   &tz->device->dev.kobj, \"device\");\n\tif (ret)\n\t\tsysfs_remove_link(&tz->device->dev.kobj, \"thermal_zone\");\n\n\treturn ret;\n}\n\nstatic void acpi_thermal_zone_sysfs_remove(struct acpi_thermal *tz)\n{\n\tstruct device *tzdev = thermal_zone_device(tz->thermal_zone);\n\n\tsysfs_remove_link(&tz->device->dev.kobj, \"thermal_zone\");\n\tsysfs_remove_link(&tzdev->kobj, \"device\");\n}\n\nstatic int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)\n{\n\tstruct acpi_thermal_trip *acpi_trip;\n\tstruct thermal_trip *trip;\n\tint passive_delay = 0;\n\tint trip_count = 0;\n\tint result;\n\tint i;\n\n\tif (tz->trips.critical.valid)\n\t\ttrip_count++;\n\n\tif (tz->trips.hot.valid)\n\t\ttrip_count++;\n\n\tif (tz->trips.passive.trip.valid) {\n\t\ttrip_count++;\n\t\tpassive_delay = tz->trips.passive.tsp * 100;\n\t}\n\n\tfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE && tz->trips.active[i].trip.valid; i++)\n\t\ttrip_count++;\n\n\ttrip = kcalloc(trip_count, sizeof(*trip), GFP_KERNEL);\n\tif (!trip)\n\t\treturn -ENOMEM;\n\n\ttz->trip_table = trip;\n\n\tif (tz->trips.critical.valid) {\n\t\ttrip->type = THERMAL_TRIP_CRITICAL;\n\t\ttrip->temperature = acpi_thermal_temp(tz, tz->trips.critical.temperature);\n\t\ttrip++;\n\t}\n\n\tif (tz->trips.hot.valid) {\n\t\ttrip->type = THERMAL_TRIP_HOT;\n\t\ttrip->temperature = acpi_thermal_temp(tz, tz->trips.hot.temperature);\n\t\ttrip++;\n\t}\n\n\tacpi_trip = &tz->trips.passive.trip;\n\tif (acpi_trip->valid) {\n\t\ttrip->type = THERMAL_TRIP_PASSIVE;\n\t\ttrip->temperature = acpi_thermal_temp(tz, acpi_trip->temperature);\n\t\ttrip->priv = acpi_trip;\n\t\ttrip++;\n\t}\n\n\tfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {\n\t\tacpi_trip = &tz->trips.active[i].trip;\n\n\t\tif (!acpi_trip->valid)\n\t\t\tbreak;\n\n\t\ttrip->type = THERMAL_TRIP_ACTIVE;\n\t\ttrip->temperature = acpi_thermal_temp(tz, acpi_trip->temperature);\n\t\ttrip->priv = acpi_trip;\n\t\ttrip++;\n\t}\n\n\ttz->thermal_zone = thermal_zone_device_register_with_trips(\"acpitz\",\n\t\t\t\t\t\t\t\t   tz->trip_table,\n\t\t\t\t\t\t\t\t   trip_count,\n\t\t\t\t\t\t\t\t   0, tz,\n\t\t\t\t\t\t\t\t   &acpi_thermal_zone_ops,\n\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t   passive_delay,\n\t\t\t\t\t\t\t\t   tz->polling_frequency * 100);\n\tif (IS_ERR(tz->thermal_zone)) {\n\t\tresult = PTR_ERR(tz->thermal_zone);\n\t\tgoto free_trip_table;\n\t}\n\n\tresult = acpi_thermal_zone_sysfs_add(tz);\n\tif (result)\n\t\tgoto unregister_tzd;\n\n\tresult = thermal_zone_device_enable(tz->thermal_zone);\n\tif (result)\n\t\tgoto remove_links;\n\n\tdev_info(&tz->device->dev, \"registered as thermal_zone%d\\n\",\n\t\t thermal_zone_device_id(tz->thermal_zone));\n\n\treturn 0;\n\nremove_links:\n\tacpi_thermal_zone_sysfs_remove(tz);\nunregister_tzd:\n\tthermal_zone_device_unregister(tz->thermal_zone);\nfree_trip_table:\n\tkfree(tz->trip_table);\n\n\treturn result;\n}\n\nstatic void acpi_thermal_unregister_thermal_zone(struct acpi_thermal *tz)\n{\n\tthermal_zone_device_disable(tz->thermal_zone);\n\tacpi_thermal_zone_sysfs_remove(tz);\n\tthermal_zone_device_unregister(tz->thermal_zone);\n\ttz->thermal_zone = NULL;\n}\n\n\n \n\nstatic void acpi_thermal_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct acpi_device *device = data;\n\tstruct acpi_thermal *tz = acpi_driver_data(device);\n\n\tif (!tz)\n\t\treturn;\n\n\tswitch (event) {\n\tcase ACPI_THERMAL_NOTIFY_TEMPERATURE:\n\t\tacpi_queue_thermal_check(tz);\n\t\tbreak;\n\tcase ACPI_THERMAL_NOTIFY_THRESHOLDS:\n\tcase ACPI_THERMAL_NOTIFY_DEVICES:\n\t\tacpi_thermal_trips_update(tz, event);\n\t\tbreak;\n\tdefault:\n\t\tacpi_handle_debug(device->handle, \"Unsupported event [0x%x]\\n\",\n\t\t\t\t  event);\n\t\tbreak;\n\t}\n}\n\n \nstatic void acpi_thermal_aml_dependency_fix(struct acpi_thermal *tz)\n{\n\tacpi_handle handle = tz->device->handle;\n\tunsigned long long value;\n\tint i;\n\n\tacpi_evaluate_integer(handle, \"_CRT\", NULL, &value);\n\tacpi_evaluate_integer(handle, \"_HOT\", NULL, &value);\n\tacpi_evaluate_integer(handle, \"_PSV\", NULL, &value);\n\tfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {\n\t\tchar name[5] = { '_', 'A', 'C', ('0' + i), '\\0' };\n\t\tacpi_status status;\n\n\t\tstatus = acpi_evaluate_integer(handle, name, NULL, &value);\n\t\tif (status == AE_NOT_FOUND)\n\t\t\tbreak;\n\t}\n\tacpi_evaluate_integer(handle, \"_TMP\", NULL, &value);\n}\n\nstatic int acpi_thermal_get_info(struct acpi_thermal *tz)\n{\n\tint result;\n\n\tif (!tz)\n\t\treturn -EINVAL;\n\n\tacpi_thermal_aml_dependency_fix(tz);\n\n\t \n\tresult = acpi_thermal_get_trip_points(tz);\n\tif (result)\n\t\treturn result;\n\n\t \n\tresult = acpi_thermal_get_temperature(tz);\n\tif (result)\n\t\treturn result;\n\n\t \n\tacpi_execute_simple_method(tz->device->handle, \"_SCP\",\n\t\t\t\t   ACPI_THERMAL_MODE_ACTIVE);\n\n\t \n\tif (tzp)\n\t\ttz->polling_frequency = tzp;\n\telse\n\t\tacpi_thermal_get_polling_frequency(tz);\n\n\treturn 0;\n}\n\n \nstatic void acpi_thermal_guess_offset(struct acpi_thermal *tz)\n{\n\tif (tz->trips.critical.valid &&\n\t    (tz->trips.critical.temperature % 5) == 1)\n\t\ttz->kelvin_offset = 273100;\n\telse\n\t\ttz->kelvin_offset = 273200;\n}\n\nstatic void acpi_thermal_check_fn(struct work_struct *work)\n{\n\tstruct acpi_thermal *tz = container_of(work, struct acpi_thermal,\n\t\t\t\t\t       thermal_check_work);\n\n\t \n\tif (!refcount_dec_not_one(&tz->thermal_check_count))\n\t\treturn;\n\n\tmutex_lock(&tz->thermal_check_lock);\n\n\tthermal_zone_device_update(tz->thermal_zone, THERMAL_EVENT_UNSPECIFIED);\n\n\trefcount_inc(&tz->thermal_check_count);\n\n\tmutex_unlock(&tz->thermal_check_lock);\n}\n\nstatic int acpi_thermal_add(struct acpi_device *device)\n{\n\tstruct acpi_thermal *tz;\n\tint result;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\ttz = kzalloc(sizeof(struct acpi_thermal), GFP_KERNEL);\n\tif (!tz)\n\t\treturn -ENOMEM;\n\n\ttz->device = device;\n\tstrcpy(tz->name, device->pnp.bus_id);\n\tstrcpy(acpi_device_name(device), ACPI_THERMAL_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_THERMAL_CLASS);\n\tdevice->driver_data = tz;\n\n\tresult = acpi_thermal_get_info(tz);\n\tif (result)\n\t\tgoto free_memory;\n\n\tacpi_thermal_guess_offset(tz);\n\n\tresult = acpi_thermal_register_thermal_zone(tz);\n\tif (result)\n\t\tgoto free_memory;\n\n\trefcount_set(&tz->thermal_check_count, 3);\n\tmutex_init(&tz->thermal_check_lock);\n\tINIT_WORK(&tz->thermal_check_work, acpi_thermal_check_fn);\n\n\tpr_info(\"%s [%s] (%ld C)\\n\", acpi_device_name(device),\n\t\tacpi_device_bid(device), deci_kelvin_to_celsius(tz->temperature));\n\n\tresult = acpi_dev_install_notify_handler(device, ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t\t acpi_thermal_notify);\n\tif (result)\n\t\tgoto flush_wq;\n\n\treturn 0;\n\nflush_wq:\n\tflush_workqueue(acpi_thermal_pm_queue);\n\tacpi_thermal_unregister_thermal_zone(tz);\nfree_memory:\n\tkfree(tz);\n\n\treturn result;\n}\n\nstatic void acpi_thermal_remove(struct acpi_device *device)\n{\n\tstruct acpi_thermal *tz;\n\n\tif (!device || !acpi_driver_data(device))\n\t\treturn;\n\n\ttz = acpi_driver_data(device);\n\n\tacpi_dev_remove_notify_handler(device, ACPI_DEVICE_NOTIFY,\n\t\t\t\t       acpi_thermal_notify);\n\n\tflush_workqueue(acpi_thermal_pm_queue);\n\tacpi_thermal_unregister_thermal_zone(tz);\n\tkfree(tz->trip_table);\n\tkfree(tz);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acpi_thermal_suspend(struct device *dev)\n{\n\t \n\tflush_workqueue(acpi_thermal_pm_queue);\n\treturn 0;\n}\n\nstatic int acpi_thermal_resume(struct device *dev)\n{\n\tstruct acpi_thermal *tz;\n\tint i, j, power_state;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\ttz = acpi_driver_data(to_acpi_device(dev));\n\tif (!tz)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {\n\t\tif (!tz->trips.active[i].trip.valid)\n\t\t\tbreak;\n\n\t\tfor (j = 0; j < tz->trips.active[i].devices.count; j++) {\n\t\t\tacpi_bus_update_power(tz->trips.active[i].devices.handles[j],\n\t\t\t\t\t      &power_state);\n\t\t}\n\t}\n\n\tacpi_queue_thermal_check(tz);\n\n\treturn AE_OK;\n}\n#else\n#define acpi_thermal_suspend\tNULL\n#define acpi_thermal_resume\tNULL\n#endif\nstatic SIMPLE_DEV_PM_OPS(acpi_thermal_pm, acpi_thermal_suspend, acpi_thermal_resume);\n\nstatic const struct acpi_device_id  thermal_device_ids[] = {\n\t{ACPI_THERMAL_HID, 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, thermal_device_ids);\n\nstatic struct acpi_driver acpi_thermal_driver = {\n\t.name = \"thermal\",\n\t.class = ACPI_THERMAL_CLASS,\n\t.ids = thermal_device_ids,\n\t.ops = {\n\t\t.add = acpi_thermal_add,\n\t\t.remove = acpi_thermal_remove,\n\t\t},\n\t.drv.pm = &acpi_thermal_pm,\n};\n\nstatic int thermal_act(const struct dmi_system_id *d) {\n\tif (act == 0) {\n\t\tpr_notice(\"%s detected: disabling all active thermal trip points\\n\",\n\t\t\t  d->ident);\n\t\tact = -1;\n\t}\n\treturn 0;\n}\nstatic int thermal_nocrt(const struct dmi_system_id *d) {\n\tpr_notice(\"%s detected: disabling all critical thermal trip point actions.\\n\",\n\t\t  d->ident);\n\tcrt = -1;\n\treturn 0;\n}\nstatic int thermal_tzp(const struct dmi_system_id *d) {\n\tif (tzp == 0) {\n\t\tpr_notice(\"%s detected: enabling thermal zone polling\\n\",\n\t\t\t  d->ident);\n\t\ttzp = 300;\t \n\t}\n\treturn 0;\n}\nstatic int thermal_psv(const struct dmi_system_id *d) {\n\tif (psv == 0) {\n\t\tpr_notice(\"%s detected: disabling all passive thermal trip points\\n\",\n\t\t\t  d->ident);\n\t\tpsv = -1;\n\t}\n\treturn 0;\n}\n\nstatic const struct dmi_system_id thermal_dmi_table[] __initconst = {\n\t \n\t{\n\t .callback = thermal_act,\n\t .ident = \"AOpen i915GMm-HFS\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AOpen\"),\n\t\tDMI_MATCH(DMI_BOARD_NAME, \"i915GMm-HFS\"),\n\t\t},\n\t},\n\t{\n\t .callback = thermal_psv,\n\t .ident = \"AOpen i915GMm-HFS\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AOpen\"),\n\t\tDMI_MATCH(DMI_BOARD_NAME, \"i915GMm-HFS\"),\n\t\t},\n\t},\n\t{\n\t .callback = thermal_tzp,\n\t .ident = \"AOpen i915GMm-HFS\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AOpen\"),\n\t\tDMI_MATCH(DMI_BOARD_NAME, \"i915GMm-HFS\"),\n\t\t},\n\t},\n\t{\n\t .callback = thermal_nocrt,\n\t .ident = \"Gigabyte GA-7ZX\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Gigabyte Technology Co., Ltd.\"),\n\t\tDMI_MATCH(DMI_BOARD_NAME, \"7ZX\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic int __init acpi_thermal_init(void)\n{\n\tint result;\n\n\tdmi_check_system(thermal_dmi_table);\n\n\tif (off) {\n\t\tpr_notice(\"thermal control disabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tacpi_thermal_pm_queue = alloc_workqueue(\"acpi_thermal_pm\",\n\t\t\t\t\t\tWQ_HIGHPRI | WQ_MEM_RECLAIM, 0);\n\tif (!acpi_thermal_pm_queue)\n\t\treturn -ENODEV;\n\n\tresult = acpi_bus_register_driver(&acpi_thermal_driver);\n\tif (result < 0) {\n\t\tdestroy_workqueue(acpi_thermal_pm_queue);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit acpi_thermal_exit(void)\n{\n\tacpi_bus_unregister_driver(&acpi_thermal_driver);\n\tdestroy_workqueue(acpi_thermal_pm_queue);\n}\n\nmodule_init(acpi_thermal_init);\nmodule_exit(acpi_thermal_exit);\n\nMODULE_AUTHOR(\"Paul Diefenbaugh\");\nMODULE_DESCRIPTION(\"ACPI Thermal Zone Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}