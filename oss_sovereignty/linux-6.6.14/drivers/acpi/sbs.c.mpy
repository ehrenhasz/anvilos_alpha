{
  "module_name": "sbs.c",
  "hash_id": "fc980763f040726a1ee525a2d7ba12c45f905f03148fd585bd3833e4242b305d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/sbs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\n#include <linux/acpi.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/power_supply.h>\n#include <linux/platform_data/x86/apple.h>\n#include <acpi/battery.h>\n\n#include \"sbshc.h\"\n\n#define ACPI_SBS_CLASS\t\t\t\"sbs\"\n#define ACPI_AC_CLASS\t\t\t\"ac_adapter\"\n#define ACPI_SBS_DEVICE_NAME\t\t\"Smart Battery System\"\n#define ACPI_BATTERY_DIR_NAME\t\t\"BAT%i\"\n#define ACPI_AC_DIR_NAME\t\t\"AC0\"\n\n#define ACPI_SBS_NOTIFY_STATUS\t\t0x80\n#define ACPI_SBS_NOTIFY_INFO\t\t0x81\n\nMODULE_AUTHOR(\"Alexey Starikovskiy <astarikovskiy@suse.de>\");\nMODULE_DESCRIPTION(\"Smart Battery System ACPI interface driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int cache_time = 1000;\nmodule_param(cache_time, uint, 0644);\nMODULE_PARM_DESC(cache_time, \"cache time in milliseconds\");\n\n#define MAX_SBS_BAT\t\t\t4\n#define ACPI_SBS_BLOCK_MAX\t\t32\n\nstatic const struct acpi_device_id sbs_device_ids[] = {\n\t{\"ACPI0002\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, sbs_device_ids);\n\nstruct acpi_battery {\n\tstruct power_supply *bat;\n\tstruct power_supply_desc bat_desc;\n\tstruct acpi_sbs *sbs;\n\tunsigned long update_time;\n\tchar name[8];\n\tchar manufacturer_name[ACPI_SBS_BLOCK_MAX];\n\tchar device_name[ACPI_SBS_BLOCK_MAX];\n\tchar device_chemistry[ACPI_SBS_BLOCK_MAX];\n\tu16 alarm_capacity;\n\tu16 full_charge_capacity;\n\tu16 design_capacity;\n\tu16 design_voltage;\n\tu16 serial_number;\n\tu16 cycle_count;\n\tu16 temp_now;\n\tu16 voltage_now;\n\ts16 rate_now;\n\ts16 rate_avg;\n\tu16 capacity_now;\n\tu16 state_of_charge;\n\tu16 state;\n\tu16 mode;\n\tu16 spec;\n\tu8 id;\n\tu8 present:1;\n\tu8 have_sysfs_alarm:1;\n};\n\n#define to_acpi_battery(x) power_supply_get_drvdata(x)\n\nstruct acpi_sbs {\n\tstruct power_supply *charger;\n\tstruct acpi_device *device;\n\tstruct acpi_smb_hc *hc;\n\tstruct mutex lock;\n\tstruct acpi_battery battery[MAX_SBS_BAT];\n\tu8 batteries_supported:4;\n\tu8 manager_present:1;\n\tu8 charger_present:1;\n\tu8 charger_exists:1;\n};\n\n#define to_acpi_sbs(x) power_supply_get_drvdata(x)\n\nstatic void acpi_sbs_remove(struct acpi_device *device);\nstatic int acpi_battery_get_state(struct acpi_battery *battery);\n\nstatic inline int battery_scale(int log)\n{\n\tint scale = 1;\n\twhile (log--)\n\t\tscale *= 10;\n\treturn scale;\n}\n\nstatic inline int acpi_battery_vscale(struct acpi_battery *battery)\n{\n\treturn battery_scale((battery->spec & 0x0f00) >> 8);\n}\n\nstatic inline int acpi_battery_ipscale(struct acpi_battery *battery)\n{\n\treturn battery_scale((battery->spec & 0xf000) >> 12);\n}\n\nstatic inline int acpi_battery_mode(struct acpi_battery *battery)\n{\n\treturn (battery->mode & 0x8000);\n}\n\nstatic inline int acpi_battery_scale(struct acpi_battery *battery)\n{\n\treturn (acpi_battery_mode(battery) ? 10 : 1) *\n\t    acpi_battery_ipscale(battery);\n}\n\nstatic int sbs_get_ac_property(struct power_supply *psy,\n\t\t\t       enum power_supply_property psp,\n\t\t\t       union power_supply_propval *val)\n{\n\tstruct acpi_sbs *sbs = to_acpi_sbs(psy);\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = sbs->charger_present;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int acpi_battery_technology(struct acpi_battery *battery)\n{\n\tif (!strcasecmp(\"NiCd\", battery->device_chemistry))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_NiCd;\n\tif (!strcasecmp(\"NiMH\", battery->device_chemistry))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_NiMH;\n\tif (!strcasecmp(\"LION\", battery->device_chemistry))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_LION;\n\tif (!strcasecmp(\"LiP\", battery->device_chemistry))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_LIPO;\n\treturn POWER_SUPPLY_TECHNOLOGY_UNKNOWN;\n}\n\nstatic int acpi_sbs_battery_get_property(struct power_supply *psy,\n\t\t\t\t\t enum power_supply_property psp,\n\t\t\t\t\t union power_supply_propval *val)\n{\n\tstruct acpi_battery *battery = to_acpi_battery(psy);\n\n\tif ((!battery->present) && psp != POWER_SUPPLY_PROP_PRESENT)\n\t\treturn -ENODEV;\n\n\tacpi_battery_get_state(battery);\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (battery->rate_now < 0)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\telse if (battery->rate_now > 0)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = battery->present;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = acpi_battery_technology(battery);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CYCLE_COUNT:\n\t\tval->intval = battery->cycle_count;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\tval->intval = battery->design_voltage *\n\t\t\tacpi_battery_vscale(battery) * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = battery->voltage_now *\n\t\t\t\tacpi_battery_vscale(battery) * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\tcase POWER_SUPPLY_PROP_POWER_NOW:\n\t\tval->intval = abs(battery->rate_now) *\n\t\t\t\tacpi_battery_ipscale(battery) * 1000;\n\t\tval->intval *= (acpi_battery_mode(battery)) ?\n\t\t\t\t(battery->voltage_now *\n\t\t\t\tacpi_battery_vscale(battery) / 1000) : 1;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\tcase POWER_SUPPLY_PROP_POWER_AVG:\n\t\tval->intval = abs(battery->rate_avg) *\n\t\t\t\tacpi_battery_ipscale(battery) * 1000;\n\t\tval->intval *= (acpi_battery_mode(battery)) ?\n\t\t\t\t(battery->voltage_now *\n\t\t\t\tacpi_battery_vscale(battery) / 1000) : 1;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = battery->state_of_charge;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\n\t\tval->intval = battery->design_capacity *\n\t\t\tacpi_battery_scale(battery) * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL:\n\t\tval->intval = battery->full_charge_capacity *\n\t\t\tacpi_battery_scale(battery) * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\tcase POWER_SUPPLY_PROP_ENERGY_NOW:\n\t\tval->intval = battery->capacity_now *\n\t\t\t\tacpi_battery_scale(battery) * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tval->intval = battery->temp_now - 2730;\t\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = battery->device_name;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = battery->manufacturer_name;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic enum power_supply_property sbs_ac_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic enum power_supply_property sbs_charge_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_CYCLE_COUNT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n};\n\nstatic enum power_supply_property sbs_energy_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_POWER_NOW,\n\tPOWER_SUPPLY_PROP_POWER_AVG,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL,\n\tPOWER_SUPPLY_PROP_ENERGY_NOW,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n};\n\nstatic const struct power_supply_desc acpi_sbs_charger_desc = {\n\t.name\t\t= \"sbs-charger\",\n\t.type\t\t= POWER_SUPPLY_TYPE_MAINS,\n\t.properties\t= sbs_ac_props,\n\t.num_properties\t= ARRAY_SIZE(sbs_ac_props),\n\t.get_property\t= sbs_get_ac_property,\n};\n\n \n\nstruct acpi_battery_reader {\n\tu8 command;\t\t \n\tu8 mode;\t\t \n\tsize_t offset;\t\t \n};\n\nstatic struct acpi_battery_reader info_readers[] = {\n\t{0x01, SMBUS_READ_WORD, offsetof(struct acpi_battery, alarm_capacity)},\n\t{0x03, SMBUS_READ_WORD, offsetof(struct acpi_battery, mode)},\n\t{0x10, SMBUS_READ_WORD, offsetof(struct acpi_battery, full_charge_capacity)},\n\t{0x17, SMBUS_READ_WORD, offsetof(struct acpi_battery, cycle_count)},\n\t{0x18, SMBUS_READ_WORD, offsetof(struct acpi_battery, design_capacity)},\n\t{0x19, SMBUS_READ_WORD, offsetof(struct acpi_battery, design_voltage)},\n\t{0x1a, SMBUS_READ_WORD, offsetof(struct acpi_battery, spec)},\n\t{0x1c, SMBUS_READ_WORD, offsetof(struct acpi_battery, serial_number)},\n\t{0x20, SMBUS_READ_BLOCK, offsetof(struct acpi_battery, manufacturer_name)},\n\t{0x21, SMBUS_READ_BLOCK, offsetof(struct acpi_battery, device_name)},\n\t{0x22, SMBUS_READ_BLOCK, offsetof(struct acpi_battery, device_chemistry)},\n};\n\nstatic struct acpi_battery_reader state_readers[] = {\n\t{0x08, SMBUS_READ_WORD, offsetof(struct acpi_battery, temp_now)},\n\t{0x09, SMBUS_READ_WORD, offsetof(struct acpi_battery, voltage_now)},\n\t{0x0a, SMBUS_READ_WORD, offsetof(struct acpi_battery, rate_now)},\n\t{0x0b, SMBUS_READ_WORD, offsetof(struct acpi_battery, rate_avg)},\n\t{0x0f, SMBUS_READ_WORD, offsetof(struct acpi_battery, capacity_now)},\n\t{0x0e, SMBUS_READ_WORD, offsetof(struct acpi_battery, state_of_charge)},\n\t{0x16, SMBUS_READ_WORD, offsetof(struct acpi_battery, state)},\n};\n\nstatic int acpi_manager_get_info(struct acpi_sbs *sbs)\n{\n\tint result = 0;\n\tu16 battery_system_info;\n\n\tresult = acpi_smbus_read(sbs->hc, SMBUS_READ_WORD, ACPI_SBS_MANAGER,\n\t\t\t\t 0x04, (u8 *)&battery_system_info);\n\tif (!result)\n\t\tsbs->batteries_supported = battery_system_info & 0x000f;\n\treturn result;\n}\n\nstatic int acpi_battery_get_info(struct acpi_battery *battery)\n{\n\tint i, result = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(info_readers); ++i) {\n\t\tresult = acpi_smbus_read(battery->sbs->hc,\n\t\t\t\t\t info_readers[i].mode,\n\t\t\t\t\t ACPI_SBS_BATTERY,\n\t\t\t\t\t info_readers[i].command,\n\t\t\t\t\t (u8 *) battery +\n\t\t\t\t\t\tinfo_readers[i].offset);\n\t\tif (result)\n\t\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic int acpi_battery_get_state(struct acpi_battery *battery)\n{\n\tint i, result = 0;\n\n\tif (battery->update_time &&\n\t    time_before(jiffies, battery->update_time +\n\t\t\t\tmsecs_to_jiffies(cache_time)))\n\t\treturn 0;\n\tfor (i = 0; i < ARRAY_SIZE(state_readers); ++i) {\n\t\tresult = acpi_smbus_read(battery->sbs->hc,\n\t\t\t\t\t state_readers[i].mode,\n\t\t\t\t\t ACPI_SBS_BATTERY,\n\t\t\t\t\t state_readers[i].command,\n\t\t\t\t\t (u8 *)battery +\n\t\t\t\t\t\tstate_readers[i].offset);\n\t\tif (result)\n\t\t\tgoto end;\n\t}\n      end:\n\tbattery->update_time = jiffies;\n\treturn result;\n}\n\nstatic int acpi_battery_get_alarm(struct acpi_battery *battery)\n{\n\treturn acpi_smbus_read(battery->sbs->hc, SMBUS_READ_WORD,\n\t\t\t\t ACPI_SBS_BATTERY, 0x01,\n\t\t\t\t (u8 *)&battery->alarm_capacity);\n}\n\nstatic int acpi_battery_set_alarm(struct acpi_battery *battery)\n{\n\tstruct acpi_sbs *sbs = battery->sbs;\n\tu16 value, sel = 1 << (battery->id + 12);\n\n\tint ret;\n\n\n\tif (sbs->manager_present) {\n\t\tret = acpi_smbus_read(sbs->hc, SMBUS_READ_WORD, ACPI_SBS_MANAGER,\n\t\t\t\t0x01, (u8 *)&value);\n\t\tif (ret)\n\t\t\tgoto end;\n\t\tif ((value & 0xf000) != sel) {\n\t\t\tvalue &= 0x0fff;\n\t\t\tvalue |= sel;\n\t\t\tret = acpi_smbus_write(sbs->hc, SMBUS_WRITE_WORD,\n\t\t\t\t\t ACPI_SBS_MANAGER,\n\t\t\t\t\t 0x01, (u8 *)&value, 2);\n\t\t\tif (ret)\n\t\t\t\tgoto end;\n\t\t}\n\t}\n\tret = acpi_smbus_write(sbs->hc, SMBUS_WRITE_WORD, ACPI_SBS_BATTERY,\n\t\t\t\t0x01, (u8 *)&battery->alarm_capacity, 2);\n      end:\n\treturn ret;\n}\n\nstatic int acpi_ac_get_present(struct acpi_sbs *sbs)\n{\n\tint result;\n\tu16 status;\n\n\tresult = acpi_smbus_read(sbs->hc, SMBUS_READ_WORD, ACPI_SBS_CHARGER,\n\t\t\t\t 0x13, (u8 *) & status);\n\n\tif (result)\n\t\treturn result;\n\n\t \n\tif (!((status >> 4) & 0x1) || status == 0xffff)\n\t\treturn -ENODEV;\n\n\tsbs->charger_present = (status >> 15) & 0x1;\n\treturn 0;\n}\n\nstatic ssize_t acpi_battery_alarm_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct acpi_battery *battery = to_acpi_battery(dev_get_drvdata(dev));\n\tacpi_battery_get_alarm(battery);\n\treturn sprintf(buf, \"%d\\n\", battery->alarm_capacity *\n\t\t\t\tacpi_battery_scale(battery) * 1000);\n}\n\nstatic ssize_t acpi_battery_alarm_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tunsigned long x;\n\tstruct acpi_battery *battery = to_acpi_battery(dev_get_drvdata(dev));\n\tif (sscanf(buf, \"%lu\\n\", &x) == 1)\n\t\tbattery->alarm_capacity = x /\n\t\t\t(1000 * acpi_battery_scale(battery));\n\tif (battery->present)\n\t\tacpi_battery_set_alarm(battery);\n\treturn count;\n}\n\nstatic const struct device_attribute alarm_attr = {\n\t.attr = {.name = \"alarm\", .mode = 0644},\n\t.show = acpi_battery_alarm_show,\n\t.store = acpi_battery_alarm_store,\n};\n\n \nstatic int acpi_battery_read(struct acpi_battery *battery)\n{\n\tint result, saved_present = battery->present;\n\tu16 state;\n\n\tif (battery->sbs->manager_present) {\n\t\tresult = acpi_smbus_read(battery->sbs->hc, SMBUS_READ_WORD,\n\t\t\t\tACPI_SBS_MANAGER, 0x01, (u8 *)&state);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tbattery->present = state & (1 << battery->id);\n\t\tif (!battery->present)\n\t\t\treturn 0;\n\n\t\t \n\t\tstate = 0x0fff;\n\t\tstate |= 1 << (battery->id + 12);\n\t\tacpi_smbus_write(battery->sbs->hc, SMBUS_WRITE_WORD,\n\t\t\t\t  ACPI_SBS_MANAGER, 0x01, (u8 *)&state, 2);\n\t} else {\n\t\tif (battery->id == 0) {\n\t\t\tbattery->present = 1;\n\t\t} else {\n\t\t\tif (!battery->present)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (saved_present != battery->present) {\n\t\tbattery->update_time = 0;\n\t\tresult = acpi_battery_get_info(battery);\n\t\tif (result) {\n\t\t\tbattery->present = 0;\n\t\t\treturn result;\n\t\t}\n\t}\n\tresult = acpi_battery_get_state(battery);\n\tif (result)\n\t\tbattery->present = 0;\n\treturn result;\n}\n\n \nstatic int acpi_battery_add(struct acpi_sbs *sbs, int id)\n{\n\tstruct acpi_battery *battery = &sbs->battery[id];\n\tstruct power_supply_config psy_cfg = { .drv_data = battery, };\n\tint result;\n\n\tbattery->id = id;\n\tbattery->sbs = sbs;\n\tresult = acpi_battery_read(battery);\n\tif (result)\n\t\treturn result;\n\n\tsprintf(battery->name, ACPI_BATTERY_DIR_NAME, id);\n\tbattery->bat_desc.name = battery->name;\n\tbattery->bat_desc.type = POWER_SUPPLY_TYPE_BATTERY;\n\tif (!acpi_battery_mode(battery)) {\n\t\tbattery->bat_desc.properties = sbs_charge_battery_props;\n\t\tbattery->bat_desc.num_properties =\n\t\t    ARRAY_SIZE(sbs_charge_battery_props);\n\t} else {\n\t\tbattery->bat_desc.properties = sbs_energy_battery_props;\n\t\tbattery->bat_desc.num_properties =\n\t\t    ARRAY_SIZE(sbs_energy_battery_props);\n\t}\n\tbattery->bat_desc.get_property = acpi_sbs_battery_get_property;\n\tbattery->bat = power_supply_register(&sbs->device->dev,\n\t\t\t\t\t&battery->bat_desc, &psy_cfg);\n\tif (IS_ERR(battery->bat)) {\n\t\tresult = PTR_ERR(battery->bat);\n\t\tbattery->bat = NULL;\n\t\tgoto end;\n\t}\n\n\tresult = device_create_file(&battery->bat->dev, &alarm_attr);\n\tif (result)\n\t\tgoto end;\n\tbattery->have_sysfs_alarm = 1;\n      end:\n\tpr_info(\"%s [%s]: Battery Slot [%s] (battery %s)\\n\",\n\t       ACPI_SBS_DEVICE_NAME, acpi_device_bid(sbs->device),\n\t       battery->name, battery->present ? \"present\" : \"absent\");\n\treturn result;\n}\n\nstatic void acpi_battery_remove(struct acpi_sbs *sbs, int id)\n{\n\tstruct acpi_battery *battery = &sbs->battery[id];\n\n\tif (battery->bat) {\n\t\tif (battery->have_sysfs_alarm)\n\t\t\tdevice_remove_file(&battery->bat->dev, &alarm_attr);\n\t\tpower_supply_unregister(battery->bat);\n\t}\n}\n\nstatic int acpi_charger_add(struct acpi_sbs *sbs)\n{\n\tint result;\n\tstruct power_supply_config psy_cfg = { .drv_data = sbs, };\n\n\tresult = acpi_ac_get_present(sbs);\n\tif (result)\n\t\tgoto end;\n\n\tsbs->charger_exists = 1;\n\tsbs->charger = power_supply_register(&sbs->device->dev,\n\t\t\t\t\t&acpi_sbs_charger_desc, &psy_cfg);\n\tif (IS_ERR(sbs->charger)) {\n\t\tresult = PTR_ERR(sbs->charger);\n\t\tsbs->charger = NULL;\n\t}\n\tpr_info(\"%s [%s]: AC Adapter [%s] (%s)\\n\",\n\t       ACPI_SBS_DEVICE_NAME, acpi_device_bid(sbs->device),\n\t       ACPI_AC_DIR_NAME, sbs->charger_present ? \"on-line\" : \"off-line\");\nend:\n\treturn result;\n}\n\nstatic void acpi_charger_remove(struct acpi_sbs *sbs)\n{\n\tif (sbs->charger)\n\t\tpower_supply_unregister(sbs->charger);\n}\n\nstatic void acpi_sbs_callback(void *context)\n{\n\tint id;\n\tstruct acpi_sbs *sbs = context;\n\tstruct acpi_battery *bat;\n\tu8 saved_charger_state = sbs->charger_present;\n\tu8 saved_battery_state;\n\n\tif (sbs->charger_exists) {\n\t\tacpi_ac_get_present(sbs);\n\t\tif (sbs->charger_present != saved_charger_state)\n\t\t\tkobject_uevent(&sbs->charger->dev.kobj, KOBJ_CHANGE);\n\t}\n\n\tif (sbs->manager_present) {\n\t\tfor (id = 0; id < MAX_SBS_BAT; ++id) {\n\t\t\tif (!(sbs->batteries_supported & (1 << id)))\n\t\t\t\tcontinue;\n\t\t\tbat = &sbs->battery[id];\n\t\t\tsaved_battery_state = bat->present;\n\t\t\tacpi_battery_read(bat);\n\t\t\tif (saved_battery_state == bat->present)\n\t\t\t\tcontinue;\n\t\t\tkobject_uevent(&bat->bat->dev.kobj, KOBJ_CHANGE);\n\t\t}\n\t}\n}\n\nstatic int acpi_sbs_add(struct acpi_device *device)\n{\n\tstruct acpi_sbs *sbs;\n\tint result = 0;\n\tint id;\n\n\tsbs = kzalloc(sizeof(struct acpi_sbs), GFP_KERNEL);\n\tif (!sbs) {\n\t\tresult = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tmutex_init(&sbs->lock);\n\n\tsbs->hc = acpi_driver_data(acpi_dev_parent(device));\n\tsbs->device = device;\n\tstrcpy(acpi_device_name(device), ACPI_SBS_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_SBS_CLASS);\n\tdevice->driver_data = sbs;\n\n\tresult = acpi_charger_add(sbs);\n\tif (result && result != -ENODEV)\n\t\tgoto end;\n\n\tresult = 0;\n\n\tif (!x86_apple_machine) {\n\t\tresult = acpi_manager_get_info(sbs);\n\t\tif (!result) {\n\t\t\tsbs->manager_present = 1;\n\t\t\tfor (id = 0; id < MAX_SBS_BAT; ++id)\n\t\t\t\tif ((sbs->batteries_supported & (1 << id)))\n\t\t\t\t\tacpi_battery_add(sbs, id);\n\t\t}\n\t}\n\n\tif (!sbs->manager_present)\n\t\tacpi_battery_add(sbs, 0);\n\n\tacpi_smbus_register_callback(sbs->hc, acpi_sbs_callback, sbs);\nend:\n\tif (result)\n\t\tacpi_sbs_remove(device);\n\treturn result;\n}\n\nstatic void acpi_sbs_remove(struct acpi_device *device)\n{\n\tstruct acpi_sbs *sbs;\n\tint id;\n\n\tif (!device)\n\t\treturn;\n\tsbs = acpi_driver_data(device);\n\tif (!sbs)\n\t\treturn;\n\tmutex_lock(&sbs->lock);\n\tacpi_smbus_unregister_callback(sbs->hc);\n\tfor (id = 0; id < MAX_SBS_BAT; ++id)\n\t\tacpi_battery_remove(sbs, id);\n\tacpi_charger_remove(sbs);\n\tmutex_unlock(&sbs->lock);\n\tmutex_destroy(&sbs->lock);\n\tkfree(sbs);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acpi_sbs_resume(struct device *dev)\n{\n\tstruct acpi_sbs *sbs;\n\tif (!dev)\n\t\treturn -EINVAL;\n\tsbs = to_acpi_device(dev)->driver_data;\n\tacpi_sbs_callback(sbs);\n\treturn 0;\n}\n#else\n#define acpi_sbs_resume NULL\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(acpi_sbs_pm, NULL, acpi_sbs_resume);\n\nstatic struct acpi_driver acpi_sbs_driver = {\n\t.name = \"sbs\",\n\t.class = ACPI_SBS_CLASS,\n\t.ids = sbs_device_ids,\n\t.ops = {\n\t\t.add = acpi_sbs_add,\n\t\t.remove = acpi_sbs_remove,\n\t\t},\n\t.drv.pm = &acpi_sbs_pm,\n};\nmodule_acpi_driver(acpi_sbs_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}