{
  "module_name": "acpi_fpdt.c",
  "hash_id": "15adc769b14905f1cb4a65bd0ffbb68fbcea30e4498ab2af4554c3154bbd5590",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_fpdt.c",
  "human_readable_source": "\n\n \n\n#define pr_fmt(fmt) \"ACPI FPDT: \" fmt\n\n#include <linux/acpi.h>\n\n \nenum fpdt_subtable_type {\n\tSUBTABLE_FBPT,\n\tSUBTABLE_S3PT,\n};\n\nstruct fpdt_subtable_entry {\n\tu16 type;\t\t \n\tu8 length;\n\tu8 revision;\n\tu32 reserved;\n\tu64 address;\t\t \n};\n\nstruct fpdt_subtable_header {\n\tu32 signature;\n\tu32 length;\n};\n\nenum fpdt_record_type {\n\tRECORD_S3_RESUME,\n\tRECORD_S3_SUSPEND,\n\tRECORD_BOOT,\n};\n\nstruct fpdt_record_header {\n\tu16 type;\t\t \n\tu8 length;\n\tu8 revision;\n};\n\nstruct resume_performance_record {\n\tstruct fpdt_record_header header;\n\tu32 resume_count;\n\tu64 resume_prev;\n\tu64 resume_avg;\n} __attribute__((packed));\n\nstruct boot_performance_record {\n\tstruct fpdt_record_header header;\n\tu32 reserved;\n\tu64 firmware_start;\n\tu64 bootloader_load;\n\tu64 bootloader_launch;\n\tu64 exitbootservice_start;\n\tu64 exitbootservice_end;\n} __attribute__((packed));\n\nstruct suspend_performance_record {\n\tstruct fpdt_record_header header;\n\tu64 suspend_start;\n\tu64 suspend_end;\n} __attribute__((packed));\n\n\nstatic struct resume_performance_record *record_resume;\nstatic struct suspend_performance_record *record_suspend;\nstatic struct boot_performance_record *record_boot;\n\n#define FPDT_ATTR(phase, name)\t\\\nstatic ssize_t name##_show(struct kobject *kobj,\t\\\n\t\t struct kobj_attribute *attr, char *buf)\t\\\n{\t\\\n\treturn sprintf(buf, \"%llu\\n\", record_##phase->name);\t\\\n}\t\\\nstatic struct kobj_attribute name##_attr =\t\\\n__ATTR(name##_ns, 0444, name##_show, NULL)\n\nFPDT_ATTR(resume, resume_prev);\nFPDT_ATTR(resume, resume_avg);\nFPDT_ATTR(suspend, suspend_start);\nFPDT_ATTR(suspend, suspend_end);\nFPDT_ATTR(boot, firmware_start);\nFPDT_ATTR(boot, bootloader_load);\nFPDT_ATTR(boot, bootloader_launch);\nFPDT_ATTR(boot, exitbootservice_start);\nFPDT_ATTR(boot, exitbootservice_end);\n\nstatic ssize_t resume_count_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", record_resume->resume_count);\n}\n\nstatic struct kobj_attribute resume_count_attr =\n__ATTR_RO(resume_count);\n\nstatic struct attribute *resume_attrs[] = {\n\t&resume_count_attr.attr,\n\t&resume_prev_attr.attr,\n\t&resume_avg_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group resume_attr_group = {\n\t.attrs = resume_attrs,\n\t.name = \"resume\",\n};\n\nstatic struct attribute *suspend_attrs[] = {\n\t&suspend_start_attr.attr,\n\t&suspend_end_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group suspend_attr_group = {\n\t.attrs = suspend_attrs,\n\t.name = \"suspend\",\n};\n\nstatic struct attribute *boot_attrs[] = {\n\t&firmware_start_attr.attr,\n\t&bootloader_load_attr.attr,\n\t&bootloader_launch_attr.attr,\n\t&exitbootservice_start_attr.attr,\n\t&exitbootservice_end_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group boot_attr_group = {\n\t.attrs = boot_attrs,\n\t.name = \"boot\",\n};\n\nstatic struct kobject *fpdt_kobj;\n\n#if defined CONFIG_X86 && defined CONFIG_PHYS_ADDR_T_64BIT\n#include <linux/processor.h>\nstatic bool fpdt_address_valid(u64 address)\n{\n\t \n\treturn !(address >> boot_cpu_data.x86_phys_bits);\n}\n#else\nstatic bool fpdt_address_valid(u64 address)\n{\n\treturn true;\n}\n#endif\n\nstatic int fpdt_process_subtable(u64 address, u32 subtable_type)\n{\n\tstruct fpdt_subtable_header *subtable_header;\n\tstruct fpdt_record_header *record_header;\n\tchar *signature = (subtable_type == SUBTABLE_FBPT ? \"FBPT\" : \"S3PT\");\n\tu32 length, offset;\n\tint result;\n\n\tif (!fpdt_address_valid(address)) {\n\t\tpr_info(FW_BUG \"invalid physical address: 0x%llx!\\n\", address);\n\t\treturn -EINVAL;\n\t}\n\n\tsubtable_header = acpi_os_map_memory(address, sizeof(*subtable_header));\n\tif (!subtable_header)\n\t\treturn -ENOMEM;\n\n\tif (strncmp((char *)&subtable_header->signature, signature, 4)) {\n\t\tpr_info(FW_BUG \"subtable signature and type mismatch!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlength = subtable_header->length;\n\tacpi_os_unmap_memory(subtable_header, sizeof(*subtable_header));\n\n\tsubtable_header = acpi_os_map_memory(address, length);\n\tif (!subtable_header)\n\t\treturn -ENOMEM;\n\n\toffset = sizeof(*subtable_header);\n\twhile (offset < length) {\n\t\trecord_header = (void *)subtable_header + offset;\n\t\toffset += record_header->length;\n\n\t\tif (!record_header->length) {\n\t\t\tpr_err(FW_BUG \"Zero-length record found in FPTD.\\n\");\n\t\t\tresult = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tswitch (record_header->type) {\n\t\tcase RECORD_S3_RESUME:\n\t\t\tif (subtable_type != SUBTABLE_S3PT) {\n\t\t\t\tpr_err(FW_BUG \"Invalid record %d for subtable %s\\n\",\n\t\t\t\t     record_header->type, signature);\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (record_resume) {\n\t\t\t\tpr_err(\"Duplicate resume performance record found.\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trecord_resume = (struct resume_performance_record *)record_header;\n\t\t\tresult = sysfs_create_group(fpdt_kobj, &resume_attr_group);\n\t\t\tif (result)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tcase RECORD_S3_SUSPEND:\n\t\t\tif (subtable_type != SUBTABLE_S3PT) {\n\t\t\t\tpr_err(FW_BUG \"Invalid %d for subtable %s\\n\",\n\t\t\t\t     record_header->type, signature);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (record_suspend) {\n\t\t\t\tpr_err(\"Duplicate suspend performance record found.\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trecord_suspend = (struct suspend_performance_record *)record_header;\n\t\t\tresult = sysfs_create_group(fpdt_kobj, &suspend_attr_group);\n\t\t\tif (result)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tcase RECORD_BOOT:\n\t\t\tif (subtable_type != SUBTABLE_FBPT) {\n\t\t\t\tpr_err(FW_BUG \"Invalid %d for subtable %s\\n\",\n\t\t\t\t     record_header->type, signature);\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (record_boot) {\n\t\t\t\tpr_err(\"Duplicate boot performance record found.\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trecord_boot = (struct boot_performance_record *)record_header;\n\t\t\tresult = sysfs_create_group(fpdt_kobj, &boot_attr_group);\n\t\t\tif (result)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\nerr:\n\tif (record_boot)\n\t\tsysfs_remove_group(fpdt_kobj, &boot_attr_group);\n\n\tif (record_suspend)\n\t\tsysfs_remove_group(fpdt_kobj, &suspend_attr_group);\n\n\tif (record_resume)\n\t\tsysfs_remove_group(fpdt_kobj, &resume_attr_group);\n\n\treturn result;\n}\n\nstatic int __init acpi_init_fpdt(void)\n{\n\tacpi_status status;\n\tstruct acpi_table_header *header;\n\tstruct fpdt_subtable_entry *subtable;\n\tu32 offset = sizeof(*header);\n\tint result;\n\n\tstatus = acpi_get_table(ACPI_SIG_FPDT, 0, &header);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn 0;\n\n\tfpdt_kobj = kobject_create_and_add(\"fpdt\", acpi_kobj);\n\tif (!fpdt_kobj) {\n\t\tresult = -ENOMEM;\n\t\tgoto err_nomem;\n\t}\n\n\twhile (offset < header->length) {\n\t\tsubtable = (void *)header + offset;\n\t\tswitch (subtable->type) {\n\t\tcase SUBTABLE_FBPT:\n\t\tcase SUBTABLE_S3PT:\n\t\t\tresult = fpdt_process_subtable(subtable->address,\n\t\t\t\t\t      subtable->type);\n\t\t\tif (result)\n\t\t\t\tgoto err_subtable;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\toffset += sizeof(*subtable);\n\t}\n\treturn 0;\nerr_subtable:\n\tkobject_put(fpdt_kobj);\n\nerr_nomem:\n\tacpi_put_table(header);\n\treturn result;\n}\n\nfs_initcall(acpi_init_fpdt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}