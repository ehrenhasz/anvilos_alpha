{
  "module_name": "acpi_lpit.c",
  "hash_id": "06fbcf8222a2cbded5c5b0c2fd877dd8008ad3714967b3fd8a4023184a50a7c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_lpit.c",
  "human_readable_source": "\n\n \n\n#include <linux/cpu.h>\n#include <linux/acpi.h>\n#include <asm/msr.h>\n#include <asm/tsc.h>\n#include \"internal.h\"\n\nstruct lpit_residency_info {\n\tstruct acpi_generic_address gaddr;\n\tu64 frequency;\n\tvoid __iomem *iomem_addr;\n};\n\n \nstatic struct lpit_residency_info residency_info_mem;\nstatic struct lpit_residency_info residency_info_ffh;\n\nstatic int lpit_read_residency_counter_us(u64 *counter, bool io_mem)\n{\n\tint err;\n\n\tif (io_mem) {\n\t\tu64 count = 0;\n\t\tint error;\n\n\t\terror = acpi_os_read_iomem(residency_info_mem.iomem_addr, &count,\n\t\t\t\t\t   residency_info_mem.gaddr.bit_width);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t*counter = div64_u64(count * 1000000ULL, residency_info_mem.frequency);\n\t\treturn 0;\n\t}\n\n\terr = rdmsrl_safe(residency_info_ffh.gaddr.address, counter);\n\tif (!err) {\n\t\tu64 mask = GENMASK_ULL(residency_info_ffh.gaddr.bit_offset +\n\t\t\t\t       residency_info_ffh.gaddr. bit_width - 1,\n\t\t\t\t       residency_info_ffh.gaddr.bit_offset);\n\n\t\t*counter &= mask;\n\t\t*counter >>= residency_info_ffh.gaddr.bit_offset;\n\t\t*counter = div64_u64(*counter * 1000000ULL, residency_info_ffh.frequency);\n\t\treturn 0;\n\t}\n\n\treturn -ENODATA;\n}\n\nstatic ssize_t low_power_idle_system_residency_us_show(struct device *dev,\n\t\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t\t       char *buf)\n{\n\tu64 counter;\n\tint ret;\n\n\tret = lpit_read_residency_counter_us(&counter, true);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%llu\\n\", counter);\n}\nstatic DEVICE_ATTR_RO(low_power_idle_system_residency_us);\n\nstatic ssize_t low_power_idle_cpu_residency_us_show(struct device *dev,\n\t\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t\t    char *buf)\n{\n\tu64 counter;\n\tint ret;\n\n\tret = lpit_read_residency_counter_us(&counter, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%llu\\n\", counter);\n}\nstatic DEVICE_ATTR_RO(low_power_idle_cpu_residency_us);\n\nint lpit_read_residency_count_address(u64 *address)\n{\n\tif (!residency_info_mem.gaddr.address)\n\t\treturn -EINVAL;\n\n\t*address = residency_info_mem.gaddr.address;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lpit_read_residency_count_address);\n\nstatic void lpit_update_residency(struct lpit_residency_info *info,\n\t\t\t\t struct acpi_lpit_native *lpit_native)\n{\n\tstruct device *dev_root = bus_get_dev_root(&cpu_subsys);\n\n\t \n\tif (!dev_root)\n\t\treturn;\n\n\tinfo->frequency = lpit_native->counter_frequency ?\n\t\t\t\tlpit_native->counter_frequency : mul_u32_u32(tsc_khz, 1000U);\n\tif (!info->frequency)\n\t\tinfo->frequency = 1;\n\n\tinfo->gaddr = lpit_native->residency_counter;\n\tif (info->gaddr.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\n\t\tinfo->iomem_addr = ioremap(info->gaddr.address,\n\t\t\t\t\t\t   info->gaddr.bit_width / 8);\n\t\tif (!info->iomem_addr)\n\t\t\tgoto exit;\n\n\t\tsysfs_add_file_to_group(&dev_root->kobj,\n\t\t\t\t\t&dev_attr_low_power_idle_system_residency_us.attr,\n\t\t\t\t\t\"cpuidle\");\n\t} else if (info->gaddr.space_id == ACPI_ADR_SPACE_FIXED_HARDWARE) {\n\t\tsysfs_add_file_to_group(&dev_root->kobj,\n\t\t\t\t\t&dev_attr_low_power_idle_cpu_residency_us.attr,\n\t\t\t\t\t\"cpuidle\");\n\t}\nexit:\n\tput_device(dev_root);\n}\n\nstatic void lpit_process(u64 begin, u64 end)\n{\n\twhile (begin + sizeof(struct acpi_lpit_native) <= end) {\n\t\tstruct acpi_lpit_native *lpit_native = (struct acpi_lpit_native *)begin;\n\n\t\tif (!lpit_native->header.type && !lpit_native->header.flags) {\n\t\t\tif (lpit_native->residency_counter.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY &&\n\t\t\t    !residency_info_mem.gaddr.address) {\n\t\t\t\tlpit_update_residency(&residency_info_mem, lpit_native);\n\t\t\t} else if (lpit_native->residency_counter.space_id == ACPI_ADR_SPACE_FIXED_HARDWARE &&\n\t\t\t\t   !residency_info_ffh.gaddr.address) {\n\t\t\t\tlpit_update_residency(&residency_info_ffh, lpit_native);\n\t\t\t}\n\t\t}\n\t\tbegin += lpit_native->header.length;\n\t}\n}\n\nvoid acpi_init_lpit(void)\n{\n\tacpi_status status;\n\tstruct acpi_table_lpit *lpit;\n\n\tstatus = acpi_get_table(ACPI_SIG_LPIT, 0, (struct acpi_table_header **)&lpit);\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\n\tlpit_process((u64)lpit + sizeof(*lpit),\n\t\t     (u64)lpit + lpit->header.length);\n\n\tacpi_put_table((struct acpi_table_header *)lpit);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}