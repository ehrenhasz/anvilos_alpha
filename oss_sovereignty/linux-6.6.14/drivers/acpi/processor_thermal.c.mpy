{
  "module_name": "processor_thermal.c",
  "hash_id": "cae1623ec27603010670d5ef443607ac1ed858c326fec1855fbc61fe2fa63eb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/processor_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/acpi.h>\n#include <acpi/processor.h>\n#include <linux/uaccess.h>\n\n#ifdef CONFIG_CPU_FREQ\n\n \n\n#define CPUFREQ_THERMAL_MIN_STEP 0\n#define CPUFREQ_THERMAL_MAX_STEP 3\n\nstatic DEFINE_PER_CPU(unsigned int, cpufreq_thermal_reduction_pctg);\n\n#define reduction_pctg(cpu) \\\n\tper_cpu(cpufreq_thermal_reduction_pctg, phys_package_first_cpu(cpu))\n\n \nstatic int phys_package_first_cpu(int cpu)\n{\n\tint i;\n\tint id = topology_physical_package_id(cpu);\n\n\tfor_each_online_cpu(i)\n\t\tif (topology_physical_package_id(i) == id)\n\t\t\treturn i;\n\treturn 0;\n}\n\nstatic int cpu_has_cpufreq(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy;\n\n\tif (!acpi_processor_cpufreq_init)\n\t\treturn 0;\n\n\tpolicy = cpufreq_cpu_get(cpu);\n\tif (policy) {\n\t\tcpufreq_cpu_put(policy);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int cpufreq_get_max_state(unsigned int cpu)\n{\n\tif (!cpu_has_cpufreq(cpu))\n\t\treturn 0;\n\n\treturn CPUFREQ_THERMAL_MAX_STEP;\n}\n\nstatic int cpufreq_get_cur_state(unsigned int cpu)\n{\n\tif (!cpu_has_cpufreq(cpu))\n\t\treturn 0;\n\n\treturn reduction_pctg(cpu);\n}\n\nstatic int cpufreq_set_cur_state(unsigned int cpu, int state)\n{\n\tstruct cpufreq_policy *policy;\n\tstruct acpi_processor *pr;\n\tunsigned long max_freq;\n\tint i, ret;\n\n\tif (!cpu_has_cpufreq(cpu))\n\t\treturn 0;\n\n\treduction_pctg(cpu) = state;\n\n\t \n\tfor_each_online_cpu(i) {\n\t\tif (topology_physical_package_id(i) !=\n\t\t    topology_physical_package_id(cpu))\n\t\t\tcontinue;\n\n\t\tpr = per_cpu(processors, i);\n\n\t\tif (unlikely(!freq_qos_request_active(&pr->thermal_req)))\n\t\t\tcontinue;\n\n\t\tpolicy = cpufreq_cpu_get(i);\n\t\tif (!policy)\n\t\t\treturn -EINVAL;\n\n\t\tmax_freq = (policy->cpuinfo.max_freq * (100 - reduction_pctg(i) * 20)) / 100;\n\n\t\tcpufreq_cpu_put(policy);\n\n\t\tret = freq_qos_update_request(&pr->thermal_req, max_freq);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"Failed to update thermal freq constraint: CPU%d (%d)\\n\",\n\t\t\t\tpr->id, ret);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid acpi_thermal_cpufreq_init(struct cpufreq_policy *policy)\n{\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, policy->related_cpus) {\n\t\tstruct acpi_processor *pr = per_cpu(processors, cpu);\n\t\tint ret;\n\n\t\tif (!pr)\n\t\t\tcontinue;\n\n\t\tret = freq_qos_add_request(&policy->constraints,\n\t\t\t\t\t   &pr->thermal_req,\n\t\t\t\t\t   FREQ_QOS_MAX, INT_MAX);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Failed to add freq constraint for CPU%d (%d)\\n\",\n\t\t\t       cpu, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tthermal_cooling_device_update(pr->cdev);\n\t}\n}\n\nvoid acpi_thermal_cpufreq_exit(struct cpufreq_policy *policy)\n{\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, policy->related_cpus) {\n\t\tstruct acpi_processor *pr = per_cpu(processors, cpu);\n\n\t\tif (!pr)\n\t\t\tcontinue;\n\n\t\tfreq_qos_remove_request(&pr->thermal_req);\n\n\t\tthermal_cooling_device_update(pr->cdev);\n\t}\n}\n#else\t\t\t\t \nstatic int cpufreq_get_max_state(unsigned int cpu)\n{\n\treturn 0;\n}\n\nstatic int cpufreq_get_cur_state(unsigned int cpu)\n{\n\treturn 0;\n}\n\nstatic int cpufreq_set_cur_state(unsigned int cpu, int state)\n{\n\treturn 0;\n}\n\n#endif\n\n \nstatic int acpi_processor_max_state(struct acpi_processor *pr)\n{\n\tint max_state = 0;\n\n\t \n\tmax_state += cpufreq_get_max_state(pr->id);\n\tif (pr->flags.throttling)\n\t\tmax_state += (pr->throttling.state_count -1);\n\n\treturn max_state;\n}\nstatic int\nprocessor_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\tunsigned long *state)\n{\n\tstruct acpi_device *device = cdev->devdata;\n\tstruct acpi_processor *pr;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tpr = acpi_driver_data(device);\n\tif (!pr)\n\t\treturn -EINVAL;\n\n\t*state = acpi_processor_max_state(pr);\n\treturn 0;\n}\n\nstatic int\nprocessor_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\tunsigned long *cur_state)\n{\n\tstruct acpi_device *device = cdev->devdata;\n\tstruct acpi_processor *pr;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tpr = acpi_driver_data(device);\n\tif (!pr)\n\t\treturn -EINVAL;\n\n\t*cur_state = cpufreq_get_cur_state(pr->id);\n\tif (pr->flags.throttling)\n\t\t*cur_state += pr->throttling.state;\n\treturn 0;\n}\n\nstatic int\nprocessor_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\tunsigned long state)\n{\n\tstruct acpi_device *device = cdev->devdata;\n\tstruct acpi_processor *pr;\n\tint result = 0;\n\tint max_pstate;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tpr = acpi_driver_data(device);\n\tif (!pr)\n\t\treturn -EINVAL;\n\n\tmax_pstate = cpufreq_get_max_state(pr->id);\n\n\tif (state > acpi_processor_max_state(pr))\n\t\treturn -EINVAL;\n\n\tif (state <= max_pstate) {\n\t\tif (pr->flags.throttling && pr->throttling.state)\n\t\t\tresult = acpi_processor_set_throttling(pr, 0, false);\n\t\tcpufreq_set_cur_state(pr->id, state);\n\t} else {\n\t\tcpufreq_set_cur_state(pr->id, max_pstate);\n\t\tresult = acpi_processor_set_throttling(pr,\n\t\t\t\tstate - max_pstate, false);\n\t}\n\treturn result;\n}\n\nconst struct thermal_cooling_device_ops processor_cooling_ops = {\n\t.get_max_state = processor_get_max_state,\n\t.get_cur_state = processor_get_cur_state,\n\t.set_cur_state = processor_set_cur_state,\n};\n\nint acpi_processor_thermal_init(struct acpi_processor *pr,\n\t\t\t\tstruct acpi_device *device)\n{\n\tint result = 0;\n\n\tpr->cdev = thermal_cooling_device_register(\"Processor\", device,\n\t\t\t\t\t\t   &processor_cooling_ops);\n\tif (IS_ERR(pr->cdev)) {\n\t\tresult = PTR_ERR(pr->cdev);\n\t\treturn result;\n\t}\n\n\tdev_dbg(&device->dev, \"registered as cooling_device%d\\n\",\n\t\tpr->cdev->id);\n\n\tresult = sysfs_create_link(&device->dev.kobj,\n\t\t\t\t   &pr->cdev->device.kobj,\n\t\t\t\t   \"thermal_cooling\");\n\tif (result) {\n\t\tdev_err(&device->dev,\n\t\t\t\"Failed to create sysfs link 'thermal_cooling'\\n\");\n\t\tgoto err_thermal_unregister;\n\t}\n\n\tresult = sysfs_create_link(&pr->cdev->device.kobj,\n\t\t\t\t   &device->dev.kobj,\n\t\t\t\t   \"device\");\n\tif (result) {\n\t\tdev_err(&pr->cdev->device,\n\t\t\t\"Failed to create sysfs link 'device'\\n\");\n\t\tgoto err_remove_sysfs_thermal;\n\t}\n\n\treturn 0;\n\nerr_remove_sysfs_thermal:\n\tsysfs_remove_link(&device->dev.kobj, \"thermal_cooling\");\nerr_thermal_unregister:\n\tthermal_cooling_device_unregister(pr->cdev);\n\n\treturn result;\n}\n\nvoid acpi_processor_thermal_exit(struct acpi_processor *pr,\n\t\t\t\t struct acpi_device *device)\n{\n\tif (pr->cdev) {\n\t\tsysfs_remove_link(&device->dev.kobj, \"thermal_cooling\");\n\t\tsysfs_remove_link(&pr->cdev->device.kobj, \"device\");\n\t\tthermal_cooling_device_unregister(pr->cdev);\n\t\tpr->cdev = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}