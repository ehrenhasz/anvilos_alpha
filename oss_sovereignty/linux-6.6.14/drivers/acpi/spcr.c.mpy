{
  "module_name": "spcr.c",
  "hash_id": "6c40ed784dd4df45a4f1d4bae2ad22cded37b698956200147ba8c3fa3cbf8e20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/spcr.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: SPCR: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/console.h>\n#include <linux/kernel.h>\n#include <linux/serial_core.h>\n\n \nbool qdf2400_e44_present;\nEXPORT_SYMBOL(qdf2400_e44_present);\n\n \nstatic bool qdf2400_erratum_44_present(struct acpi_table_header *h)\n{\n\tif (memcmp(h->oem_id, \"QCOM  \", ACPI_OEM_ID_SIZE))\n\t\treturn false;\n\n\tif (!memcmp(h->oem_table_id, \"QDF2432 \", ACPI_OEM_TABLE_ID_SIZE))\n\t\treturn true;\n\n\tif (!memcmp(h->oem_table_id, \"QDF2400 \", ACPI_OEM_TABLE_ID_SIZE) &&\n\t\t\th->oem_revision == 1)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool xgene_8250_erratum_present(struct acpi_table_spcr *tb)\n{\n\tbool xgene_8250 = false;\n\n\tif (tb->interface_type != ACPI_DBG2_16550_COMPATIBLE)\n\t\treturn false;\n\n\tif (memcmp(tb->header.oem_id, \"APMC0D\", ACPI_OEM_ID_SIZE) &&\n\t    memcmp(tb->header.oem_id, \"HPE   \", ACPI_OEM_ID_SIZE))\n\t\treturn false;\n\n\tif (!memcmp(tb->header.oem_table_id, \"XGENESPC\",\n\t    ACPI_OEM_TABLE_ID_SIZE) && tb->header.oem_revision == 0)\n\t\txgene_8250 = true;\n\n\tif (!memcmp(tb->header.oem_table_id, \"ProLiant\",\n\t    ACPI_OEM_TABLE_ID_SIZE) && tb->header.oem_revision == 1)\n\t\txgene_8250 = true;\n\n\treturn xgene_8250;\n}\n\n \nint __init acpi_parse_spcr(bool enable_earlycon, bool enable_console)\n{\n\tstatic char opts[64];\n\tstruct acpi_table_spcr *table;\n\tacpi_status status;\n\tchar *uart;\n\tchar *iotype;\n\tint baud_rate;\n\tint err;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\tstatus = acpi_get_table(ACPI_SIG_SPCR, 0, (struct acpi_table_header **)&table);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENOENT;\n\n\tif (table->header.revision < 2)\n\t\tpr_info(\"SPCR table version %d\\n\", table->header.revision);\n\n\tif (table->serial_port.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\n\t\tu32 bit_width = table->serial_port.access_width;\n\n\t\tif (bit_width > ACPI_ACCESS_BIT_MAX) {\n\t\t\tpr_err(FW_BUG \"Unacceptable wide SPCR Access Width. Defaulting to byte size\\n\");\n\t\t\tbit_width = ACPI_ACCESS_BIT_DEFAULT;\n\t\t}\n\t\tswitch (ACPI_ACCESS_BIT_WIDTH((bit_width))) {\n\t\tdefault:\n\t\t\tpr_err(FW_BUG \"Unexpected SPCR Access Width. Defaulting to byte size\\n\");\n\t\t\tfallthrough;\n\t\tcase 8:\n\t\t\tiotype = \"mmio\";\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tiotype = \"mmio16\";\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tiotype = \"mmio32\";\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tiotype = \"io\";\n\n\tswitch (table->interface_type) {\n\tcase ACPI_DBG2_ARM_SBSA_32BIT:\n\t\tiotype = \"mmio32\";\n\t\tfallthrough;\n\tcase ACPI_DBG2_ARM_PL011:\n\tcase ACPI_DBG2_ARM_SBSA_GENERIC:\n\tcase ACPI_DBG2_BCM2835:\n\t\tuart = \"pl011\";\n\t\tbreak;\n\tcase ACPI_DBG2_16550_COMPATIBLE:\n\tcase ACPI_DBG2_16550_SUBSET:\n\tcase ACPI_DBG2_16550_WITH_GAS:\n\tcase ACPI_DBG2_16550_NVIDIA:\n\t\tuart = \"uart\";\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOENT;\n\t\tgoto done;\n\t}\n\n\tswitch (table->baud_rate) {\n\tcase 0:\n\t\t \n\t\tbaud_rate = 0;\n\t\tbreak;\n\tcase 3:\n\t\tbaud_rate = 9600;\n\t\tbreak;\n\tcase 4:\n\t\tbaud_rate = 19200;\n\t\tbreak;\n\tcase 6:\n\t\tbaud_rate = 57600;\n\t\tbreak;\n\tcase 7:\n\t\tbaud_rate = 115200;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOENT;\n\t\tgoto done;\n\t}\n\n\t \n\tif (qdf2400_erratum_44_present(&table->header)) {\n\t\tqdf2400_e44_present = true;\n\t\tif (enable_earlycon)\n\t\t\tuart = \"qdf2400_e44\";\n\t}\n\n\tif (xgene_8250_erratum_present(table)) {\n\t\tiotype = \"mmio32\";\n\n\t\t \n\t\tbaud_rate = 0;\n\t}\n\n\tif (!baud_rate) {\n\t\tsnprintf(opts, sizeof(opts), \"%s,%s,0x%llx\", uart, iotype,\n\t\t\t table->serial_port.address);\n\t} else {\n\t\tsnprintf(opts, sizeof(opts), \"%s,%s,0x%llx,%d\", uart, iotype,\n\t\t\t table->serial_port.address, baud_rate);\n\t}\n\n\tpr_info(\"console: %s\\n\", opts);\n\n\tif (enable_earlycon)\n\t\tsetup_earlycon(opts);\n\n\tif (enable_console)\n\t\terr = add_preferred_console(uart, 0, opts + strlen(uart) + 1);\n\telse\n\t\terr = 0;\ndone:\n\tacpi_put_table((struct acpi_table_header *)table);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}