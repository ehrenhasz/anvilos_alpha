{
  "module_name": "battery.c",
  "hash_id": "5c302795019ee3ef7b021281ef01f2112a539bbf5874cf0719403ad25c8bf291",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/battery.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: battery: \" fmt\n\n#include <linux/async.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/types.h>\n\n#include <asm/unaligned.h>\n\n#include <linux/acpi.h>\n#include <linux/power_supply.h>\n\n#include <acpi/battery.h>\n\n#define ACPI_BATTERY_VALUE_UNKNOWN 0xFFFFFFFF\n#define ACPI_BATTERY_CAPACITY_VALID(capacity) \\\n\t((capacity) != 0 && (capacity) != ACPI_BATTERY_VALUE_UNKNOWN)\n\n#define ACPI_BATTERY_DEVICE_NAME\t\"Battery\"\n\n \n#define ACPI_BATTERY_POWER_UNIT_MA\t1\n\n#define ACPI_BATTERY_STATE_DISCHARGING\t0x1\n#define ACPI_BATTERY_STATE_CHARGING\t0x2\n#define ACPI_BATTERY_STATE_CRITICAL\t0x4\n\n#define MAX_STRING_LENGTH\t64\n\nMODULE_AUTHOR(\"Paul Diefenbaugh\");\nMODULE_AUTHOR(\"Alexey Starikovskiy <astarikovskiy@suse.de>\");\nMODULE_DESCRIPTION(\"ACPI Battery Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic async_cookie_t async_cookie;\nstatic bool battery_driver_registered;\nstatic int battery_bix_broken_package;\nstatic int battery_notification_delay_ms;\nstatic int battery_ac_is_broken;\nstatic unsigned int cache_time = 1000;\nmodule_param(cache_time, uint, 0644);\nMODULE_PARM_DESC(cache_time, \"cache time in milliseconds\");\n\nstatic const struct acpi_device_id battery_device_ids[] = {\n\t{\"PNP0C0A\", 0},\n\n\t \n\t{\"MSHW0146\", 0},\n\n\t{\"\", 0},\n};\n\nMODULE_DEVICE_TABLE(acpi, battery_device_ids);\n\nenum {\n\tACPI_BATTERY_ALARM_PRESENT,\n\tACPI_BATTERY_XINFO_PRESENT,\n\tACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY,\n\t \n\tACPI_BATTERY_QUIRK_THINKPAD_MAH,\n\t \n\tACPI_BATTERY_QUIRK_DEGRADED_FULL_CHARGE,\n};\n\nstruct acpi_battery {\n\tstruct mutex lock;\n\tstruct mutex sysfs_lock;\n\tstruct power_supply *bat;\n\tstruct power_supply_desc bat_desc;\n\tstruct acpi_device *device;\n\tstruct notifier_block pm_nb;\n\tstruct list_head list;\n\tunsigned long update_time;\n\tint revision;\n\tint rate_now;\n\tint capacity_now;\n\tint voltage_now;\n\tint design_capacity;\n\tint full_charge_capacity;\n\tint technology;\n\tint design_voltage;\n\tint design_capacity_warning;\n\tint design_capacity_low;\n\tint cycle_count;\n\tint measurement_accuracy;\n\tint max_sampling_time;\n\tint min_sampling_time;\n\tint max_averaging_interval;\n\tint min_averaging_interval;\n\tint capacity_granularity_1;\n\tint capacity_granularity_2;\n\tint alarm;\n\tchar model_number[MAX_STRING_LENGTH];\n\tchar serial_number[MAX_STRING_LENGTH];\n\tchar type[MAX_STRING_LENGTH];\n\tchar oem_info[MAX_STRING_LENGTH];\n\tint state;\n\tint power_unit;\n\tunsigned long flags;\n};\n\n#define to_acpi_battery(x) power_supply_get_drvdata(x)\n\nstatic inline int acpi_battery_present(struct acpi_battery *battery)\n{\n\treturn battery->device->status.battery_present;\n}\n\nstatic int acpi_battery_technology(struct acpi_battery *battery)\n{\n\tif (!strcasecmp(\"NiCd\", battery->type))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_NiCd;\n\tif (!strcasecmp(\"NiMH\", battery->type))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_NiMH;\n\tif (!strcasecmp(\"LION\", battery->type))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_LION;\n\tif (!strncasecmp(\"LI-ION\", battery->type, 6))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_LION;\n\tif (!strcasecmp(\"LiP\", battery->type))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_LIPO;\n\treturn POWER_SUPPLY_TECHNOLOGY_UNKNOWN;\n}\n\nstatic int acpi_battery_get_state(struct acpi_battery *battery);\n\nstatic int acpi_battery_is_charged(struct acpi_battery *battery)\n{\n\t \n\tif (battery->state != 0)\n\t\treturn 0;\n\n\t \n\tif (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN ||\n\t    battery->capacity_now == 0)\n\t\treturn 0;\n\n\t \n\tif (battery->full_charge_capacity == battery->capacity_now)\n\t\treturn 1;\n\n\t \n\tif (battery->design_capacity <= battery->capacity_now)\n\t\treturn 1;\n\n\t \n\treturn 0;\n}\n\nstatic bool acpi_battery_is_degraded(struct acpi_battery *battery)\n{\n\treturn ACPI_BATTERY_CAPACITY_VALID(battery->full_charge_capacity) &&\n\t\tACPI_BATTERY_CAPACITY_VALID(battery->design_capacity) &&\n\t\tbattery->full_charge_capacity < battery->design_capacity;\n}\n\nstatic int acpi_battery_handle_discharging(struct acpi_battery *battery)\n{\n\t \n\tif ((battery_ac_is_broken || power_supply_is_system_supplied()) &&\n\t    battery->rate_now == 0)\n\t\treturn POWER_SUPPLY_STATUS_NOT_CHARGING;\n\n\treturn POWER_SUPPLY_STATUS_DISCHARGING;\n}\n\nstatic int acpi_battery_get_property(struct power_supply *psy,\n\t\t\t\t     enum power_supply_property psp,\n\t\t\t\t     union power_supply_propval *val)\n{\n\tint full_capacity = ACPI_BATTERY_VALUE_UNKNOWN, ret = 0;\n\tstruct acpi_battery *battery = to_acpi_battery(psy);\n\n\tif (acpi_battery_present(battery)) {\n\t\t \n\t\tacpi_battery_get_state(battery);\n\t} else if (psp != POWER_SUPPLY_PROP_PRESENT)\n\t\treturn -ENODEV;\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (battery->state & ACPI_BATTERY_STATE_DISCHARGING)\n\t\t\tval->intval = acpi_battery_handle_discharging(battery);\n\t\telse if (battery->state & ACPI_BATTERY_STATE_CHARGING)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse if (acpi_battery_is_charged(battery))\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = acpi_battery_present(battery);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = acpi_battery_technology(battery);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CYCLE_COUNT:\n\t\tval->intval = battery->cycle_count;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\tif (battery->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)\n\t\t\tret = -ENODEV;\n\t\telse\n\t\t\tval->intval = battery->design_voltage * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tif (battery->voltage_now == ACPI_BATTERY_VALUE_UNKNOWN)\n\t\t\tret = -ENODEV;\n\t\telse\n\t\t\tval->intval = battery->voltage_now * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\tcase POWER_SUPPLY_PROP_POWER_NOW:\n\t\tif (battery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN)\n\t\t\tret = -ENODEV;\n\t\telse\n\t\t\tval->intval = battery->rate_now * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\n\t\tif (!ACPI_BATTERY_CAPACITY_VALID(battery->design_capacity))\n\t\t\tret = -ENODEV;\n\t\telse\n\t\t\tval->intval = battery->design_capacity * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL:\n\t\tif (!ACPI_BATTERY_CAPACITY_VALID(battery->full_charge_capacity))\n\t\t\tret = -ENODEV;\n\t\telse\n\t\t\tval->intval = battery->full_charge_capacity * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\tcase POWER_SUPPLY_PROP_ENERGY_NOW:\n\t\tif (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN)\n\t\t\tret = -ENODEV;\n\t\telse\n\t\t\tval->intval = battery->capacity_now * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tif (ACPI_BATTERY_CAPACITY_VALID(battery->full_charge_capacity))\n\t\t\tfull_capacity = battery->full_charge_capacity;\n\t\telse if (ACPI_BATTERY_CAPACITY_VALID(battery->design_capacity))\n\t\t\tfull_capacity = battery->design_capacity;\n\n\t\tif (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN ||\n\t\t    full_capacity == ACPI_BATTERY_VALUE_UNKNOWN)\n\t\t\tret = -ENODEV;\n\t\telse\n\t\t\tval->intval = battery->capacity_now * 100/\n\t\t\t\t\tfull_capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\n\t\tif (battery->state & ACPI_BATTERY_STATE_CRITICAL)\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\n\t\telse if (test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags) &&\n\t\t\t(battery->capacity_now <= battery->alarm))\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\n\t\telse if (acpi_battery_is_charged(battery))\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_FULL;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = battery->model_number;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = battery->oem_info;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SERIAL_NUMBER:\n\t\tval->strval = battery->serial_number;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic enum power_supply_property charge_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_CYCLE_COUNT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CAPACITY_LEVEL,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_SERIAL_NUMBER,\n};\n\nstatic enum power_supply_property charge_battery_full_cap_broken_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_CYCLE_COUNT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_SERIAL_NUMBER,\n};\n\nstatic enum power_supply_property energy_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_CYCLE_COUNT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_POWER_NOW,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL,\n\tPOWER_SUPPLY_PROP_ENERGY_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CAPACITY_LEVEL,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_SERIAL_NUMBER,\n};\n\nstatic enum power_supply_property energy_battery_full_cap_broken_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_CYCLE_COUNT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_POWER_NOW,\n\tPOWER_SUPPLY_PROP_ENERGY_NOW,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_SERIAL_NUMBER,\n};\n\n \nstruct acpi_offsets {\n\tsize_t offset;\t\t \n\tu8 mode;\t\t \n};\n\nstatic const struct acpi_offsets state_offsets[] = {\n\t{offsetof(struct acpi_battery, state), 0},\n\t{offsetof(struct acpi_battery, rate_now), 0},\n\t{offsetof(struct acpi_battery, capacity_now), 0},\n\t{offsetof(struct acpi_battery, voltage_now), 0},\n};\n\nstatic const struct acpi_offsets info_offsets[] = {\n\t{offsetof(struct acpi_battery, power_unit), 0},\n\t{offsetof(struct acpi_battery, design_capacity), 0},\n\t{offsetof(struct acpi_battery, full_charge_capacity), 0},\n\t{offsetof(struct acpi_battery, technology), 0},\n\t{offsetof(struct acpi_battery, design_voltage), 0},\n\t{offsetof(struct acpi_battery, design_capacity_warning), 0},\n\t{offsetof(struct acpi_battery, design_capacity_low), 0},\n\t{offsetof(struct acpi_battery, capacity_granularity_1), 0},\n\t{offsetof(struct acpi_battery, capacity_granularity_2), 0},\n\t{offsetof(struct acpi_battery, model_number), 1},\n\t{offsetof(struct acpi_battery, serial_number), 1},\n\t{offsetof(struct acpi_battery, type), 1},\n\t{offsetof(struct acpi_battery, oem_info), 1},\n};\n\nstatic const struct acpi_offsets extended_info_offsets[] = {\n\t{offsetof(struct acpi_battery, revision), 0},\n\t{offsetof(struct acpi_battery, power_unit), 0},\n\t{offsetof(struct acpi_battery, design_capacity), 0},\n\t{offsetof(struct acpi_battery, full_charge_capacity), 0},\n\t{offsetof(struct acpi_battery, technology), 0},\n\t{offsetof(struct acpi_battery, design_voltage), 0},\n\t{offsetof(struct acpi_battery, design_capacity_warning), 0},\n\t{offsetof(struct acpi_battery, design_capacity_low), 0},\n\t{offsetof(struct acpi_battery, cycle_count), 0},\n\t{offsetof(struct acpi_battery, measurement_accuracy), 0},\n\t{offsetof(struct acpi_battery, max_sampling_time), 0},\n\t{offsetof(struct acpi_battery, min_sampling_time), 0},\n\t{offsetof(struct acpi_battery, max_averaging_interval), 0},\n\t{offsetof(struct acpi_battery, min_averaging_interval), 0},\n\t{offsetof(struct acpi_battery, capacity_granularity_1), 0},\n\t{offsetof(struct acpi_battery, capacity_granularity_2), 0},\n\t{offsetof(struct acpi_battery, model_number), 1},\n\t{offsetof(struct acpi_battery, serial_number), 1},\n\t{offsetof(struct acpi_battery, type), 1},\n\t{offsetof(struct acpi_battery, oem_info), 1},\n};\n\nstatic int extract_package(struct acpi_battery *battery,\n\t\t\t   union acpi_object *package,\n\t\t\t   const struct acpi_offsets *offsets, int num)\n{\n\tint i;\n\tunion acpi_object *element;\n\n\tif (package->type != ACPI_TYPE_PACKAGE)\n\t\treturn -EFAULT;\n\tfor (i = 0; i < num; ++i) {\n\t\tif (package->package.count <= i)\n\t\t\treturn -EFAULT;\n\t\telement = &package->package.elements[i];\n\t\tif (offsets[i].mode) {\n\t\t\tu8 *ptr = (u8 *)battery + offsets[i].offset;\n\t\t\tu32 len = MAX_STRING_LENGTH;\n\n\t\t\tswitch (element->type) {\n\t\t\tcase ACPI_TYPE_BUFFER:\n\t\t\t\tif (len > element->buffer.length + 1)\n\t\t\t\t\tlen = element->buffer.length + 1;\n\n\t\t\t\tfallthrough;\n\t\t\tcase ACPI_TYPE_STRING:\n\t\t\t\tstrscpy(ptr, element->string.pointer, len);\n\n\t\t\t\tbreak;\n\t\t\tcase ACPI_TYPE_INTEGER:\n\t\t\t\tstrscpy(ptr, (u8 *)&element->integer.value, sizeof(u64) + 1);\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*ptr = 0;  \n\t\t\t}\n\t\t} else {\n\t\t\tint *x = (int *)((u8 *)battery + offsets[i].offset);\n\t\t\t*x = (element->type == ACPI_TYPE_INTEGER) ?\n\t\t\t\telement->integer.value : -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int acpi_battery_get_status(struct acpi_battery *battery)\n{\n\tif (acpi_bus_get_status(battery->device)) {\n\t\tacpi_handle_info(battery->device->handle,\n\t\t\t\t \"_STA evaluation failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n\nstatic int extract_battery_info(const int use_bix,\n\t\t\t struct acpi_battery *battery,\n\t\t\t const struct acpi_buffer *buffer)\n{\n\tint result = -EFAULT;\n\n\tif (use_bix && battery_bix_broken_package)\n\t\tresult = extract_package(battery, buffer->pointer,\n\t\t\t\textended_info_offsets + 1,\n\t\t\t\tARRAY_SIZE(extended_info_offsets) - 1);\n\telse if (use_bix)\n\t\tresult = extract_package(battery, buffer->pointer,\n\t\t\t\textended_info_offsets,\n\t\t\t\tARRAY_SIZE(extended_info_offsets));\n\telse\n\t\tresult = extract_package(battery, buffer->pointer,\n\t\t\t\tinfo_offsets, ARRAY_SIZE(info_offsets));\n\tif (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags))\n\t\tbattery->full_charge_capacity = battery->design_capacity;\n\tif (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags) &&\n\t    battery->power_unit && battery->design_voltage) {\n\t\tbattery->design_capacity = battery->design_capacity *\n\t\t    10000 / battery->design_voltage;\n\t\tbattery->full_charge_capacity = battery->full_charge_capacity *\n\t\t    10000 / battery->design_voltage;\n\t\tbattery->design_capacity_warning =\n\t\t    battery->design_capacity_warning *\n\t\t    10000 / battery->design_voltage;\n\t\t \n\t\t \n\t}\n\tif (test_bit(ACPI_BATTERY_QUIRK_DEGRADED_FULL_CHARGE, &battery->flags) &&\n\t    battery->capacity_now > battery->full_charge_capacity)\n\t\tbattery->capacity_now = battery->full_charge_capacity;\n\n\treturn result;\n}\n\nstatic int acpi_battery_get_info(struct acpi_battery *battery)\n{\n\tconst int xinfo = test_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags);\n\tint use_bix;\n\tint result = -ENODEV;\n\n\tif (!acpi_battery_present(battery))\n\t\treturn 0;\n\n\n\tfor (use_bix = xinfo ? 1 : 0; use_bix >= 0; use_bix--) {\n\t\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\t\tacpi_status status = AE_ERROR;\n\n\t\tmutex_lock(&battery->lock);\n\t\tstatus = acpi_evaluate_object(battery->device->handle,\n\t\t\t\t\t      use_bix ? \"_BIX\":\"_BIF\",\n\t\t\t\t\t      NULL, &buffer);\n\t\tmutex_unlock(&battery->lock);\n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_handle_info(battery->device->handle,\n\t\t\t\t\t \"%s evaluation failed: %s\\n\",\n\t\t\t\t\t use_bix ? \"_BIX\":\"_BIF\",\n\t\t\t\t\t acpi_format_exception(status));\n\t\t} else {\n\t\t\tresult = extract_battery_info(use_bix,\n\t\t\t\t\t\t      battery,\n\t\t\t\t\t\t      &buffer);\n\n\t\t\tkfree(buffer.pointer);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!result && !use_bix && xinfo)\n\t\tpr_warn(FW_BUG \"The _BIX method is broken, using _BIF.\\n\");\n\n\treturn result;\n}\n\nstatic int acpi_battery_get_state(struct acpi_battery *battery)\n{\n\tint result = 0;\n\tacpi_status status = 0;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tif (!acpi_battery_present(battery))\n\t\treturn 0;\n\n\tif (battery->update_time &&\n\t    time_before(jiffies, battery->update_time +\n\t\t\tmsecs_to_jiffies(cache_time)))\n\t\treturn 0;\n\n\tmutex_lock(&battery->lock);\n\tstatus = acpi_evaluate_object(battery->device->handle, \"_BST\",\n\t\t\t\t      NULL, &buffer);\n\tmutex_unlock(&battery->lock);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_info(battery->device->handle,\n\t\t\t\t \"_BST evaluation failed: %s\",\n\t\t\t\t acpi_format_exception(status));\n\t\treturn -ENODEV;\n\t}\n\n\tresult = extract_package(battery, buffer.pointer,\n\t\t\t\t state_offsets, ARRAY_SIZE(state_offsets));\n\tbattery->update_time = jiffies;\n\tkfree(buffer.pointer);\n\n\t \n\tif (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA &&\n\t\tbattery->rate_now != ACPI_BATTERY_VALUE_UNKNOWN &&\n\t\t(s16)(battery->rate_now) < 0) {\n\t\tbattery->rate_now = abs((s16)battery->rate_now);\n\t\tpr_warn_once(FW_BUG \"(dis)charge rate invalid.\\n\");\n\t}\n\n\tif (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags)\n\t    && battery->capacity_now >= 0 && battery->capacity_now <= 100)\n\t\tbattery->capacity_now = (battery->capacity_now *\n\t\t\t\tbattery->full_charge_capacity) / 100;\n\tif (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags) &&\n\t    battery->power_unit && battery->design_voltage) {\n\t\tbattery->capacity_now = battery->capacity_now *\n\t\t    10000 / battery->design_voltage;\n\t}\n\tif (test_bit(ACPI_BATTERY_QUIRK_DEGRADED_FULL_CHARGE, &battery->flags) &&\n\t    battery->capacity_now > battery->full_charge_capacity)\n\t\tbattery->capacity_now = battery->full_charge_capacity;\n\n\treturn result;\n}\n\nstatic int acpi_battery_set_alarm(struct acpi_battery *battery)\n{\n\tacpi_status status = 0;\n\n\tif (!acpi_battery_present(battery) ||\n\t    !test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&battery->lock);\n\tstatus = acpi_execute_simple_method(battery->device->handle, \"_BTP\",\n\t\t\t\t\t    battery->alarm);\n\tmutex_unlock(&battery->lock);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tacpi_handle_debug(battery->device->handle, \"Alarm set to %d\\n\",\n\t\t\t  battery->alarm);\n\n\treturn 0;\n}\n\nstatic int acpi_battery_init_alarm(struct acpi_battery *battery)\n{\n\t \n\tif (!acpi_has_method(battery->device->handle, \"_BTP\")) {\n\t\tclear_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags);\n\t\treturn 0;\n\t}\n\tset_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags);\n\tif (!battery->alarm)\n\t\tbattery->alarm = battery->design_capacity_warning;\n\treturn acpi_battery_set_alarm(battery);\n}\n\nstatic ssize_t acpi_battery_alarm_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct acpi_battery *battery = to_acpi_battery(dev_get_drvdata(dev));\n\n\treturn sprintf(buf, \"%d\\n\", battery->alarm * 1000);\n}\n\nstatic ssize_t acpi_battery_alarm_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tunsigned long x;\n\tstruct acpi_battery *battery = to_acpi_battery(dev_get_drvdata(dev));\n\n\tif (sscanf(buf, \"%lu\\n\", &x) == 1)\n\t\tbattery->alarm = x/1000;\n\tif (acpi_battery_present(battery))\n\t\tacpi_battery_set_alarm(battery);\n\treturn count;\n}\n\nstatic const struct device_attribute alarm_attr = {\n\t.attr = {.name = \"alarm\", .mode = 0644},\n\t.show = acpi_battery_alarm_show,\n\t.store = acpi_battery_alarm_store,\n};\n\n \n\nstatic LIST_HEAD(acpi_battery_list);\nstatic LIST_HEAD(battery_hook_list);\nstatic DEFINE_MUTEX(hook_mutex);\n\nstatic void __battery_hook_unregister(struct acpi_battery_hook *hook, int lock)\n{\n\tstruct acpi_battery *battery;\n\t \n\tif (lock)\n\t\tmutex_lock(&hook_mutex);\n\tlist_for_each_entry(battery, &acpi_battery_list, list) {\n\t\tif (!hook->remove_battery(battery->bat, hook))\n\t\t\tpower_supply_changed(battery->bat);\n\t}\n\tlist_del(&hook->list);\n\tif (lock)\n\t\tmutex_unlock(&hook_mutex);\n\tpr_info(\"extension unregistered: %s\\n\", hook->name);\n}\n\nvoid battery_hook_unregister(struct acpi_battery_hook *hook)\n{\n\t__battery_hook_unregister(hook, 1);\n}\nEXPORT_SYMBOL_GPL(battery_hook_unregister);\n\nvoid battery_hook_register(struct acpi_battery_hook *hook)\n{\n\tstruct acpi_battery *battery;\n\n\tmutex_lock(&hook_mutex);\n\tINIT_LIST_HEAD(&hook->list);\n\tlist_add(&hook->list, &battery_hook_list);\n\t \n\tlist_for_each_entry(battery, &acpi_battery_list, list) {\n\t\tif (hook->add_battery(battery->bat, hook)) {\n\t\t\t \n\t\t\tpr_err(\"extension failed to load: %s\", hook->name);\n\t\t\t__battery_hook_unregister(hook, 0);\n\t\t\tgoto end;\n\t\t}\n\n\t\tpower_supply_changed(battery->bat);\n\t}\n\tpr_info(\"new extension: %s\\n\", hook->name);\nend:\n\tmutex_unlock(&hook_mutex);\n}\nEXPORT_SYMBOL_GPL(battery_hook_register);\n\n \nstatic void battery_hook_add_battery(struct acpi_battery *battery)\n{\n\tstruct acpi_battery_hook *hook_node, *tmp;\n\n\tmutex_lock(&hook_mutex);\n\tINIT_LIST_HEAD(&battery->list);\n\tlist_add(&battery->list, &acpi_battery_list);\n\t \n\tlist_for_each_entry_safe(hook_node, tmp, &battery_hook_list, list) {\n\t\tif (hook_node->add_battery(battery->bat, hook_node)) {\n\t\t\t \n\t\t\tpr_err(\"error in extension, unloading: %s\",\n\t\t\t\t\thook_node->name);\n\t\t\t__battery_hook_unregister(hook_node, 0);\n\t\t}\n\t}\n\tmutex_unlock(&hook_mutex);\n}\n\nstatic void battery_hook_remove_battery(struct acpi_battery *battery)\n{\n\tstruct acpi_battery_hook *hook;\n\n\tmutex_lock(&hook_mutex);\n\t \n\tlist_for_each_entry(hook, &battery_hook_list, list) {\n\t\thook->remove_battery(battery->bat, hook);\n\t}\n\t \n\tlist_del(&battery->list);\n\tmutex_unlock(&hook_mutex);\n}\n\nstatic void __exit battery_hook_exit(void)\n{\n\tstruct acpi_battery_hook *hook;\n\tstruct acpi_battery_hook *ptr;\n\t \n\tlist_for_each_entry_safe(hook, ptr, &battery_hook_list, list) {\n\t\t__battery_hook_unregister(hook, 1);\n\t}\n\tmutex_destroy(&hook_mutex);\n}\n\nstatic int sysfs_add_battery(struct acpi_battery *battery)\n{\n\tstruct power_supply_config psy_cfg = { .drv_data = battery, };\n\tbool full_cap_broken = false;\n\n\tif (!ACPI_BATTERY_CAPACITY_VALID(battery->full_charge_capacity) &&\n\t    !ACPI_BATTERY_CAPACITY_VALID(battery->design_capacity))\n\t\tfull_cap_broken = true;\n\n\tif (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) {\n\t\tif (full_cap_broken) {\n\t\t\tbattery->bat_desc.properties =\n\t\t\t    charge_battery_full_cap_broken_props;\n\t\t\tbattery->bat_desc.num_properties =\n\t\t\t    ARRAY_SIZE(charge_battery_full_cap_broken_props);\n\t\t} else {\n\t\t\tbattery->bat_desc.properties = charge_battery_props;\n\t\t\tbattery->bat_desc.num_properties =\n\t\t\t    ARRAY_SIZE(charge_battery_props);\n\t\t}\n\t} else {\n\t\tif (full_cap_broken) {\n\t\t\tbattery->bat_desc.properties =\n\t\t\t    energy_battery_full_cap_broken_props;\n\t\t\tbattery->bat_desc.num_properties =\n\t\t\t    ARRAY_SIZE(energy_battery_full_cap_broken_props);\n\t\t} else {\n\t\t\tbattery->bat_desc.properties = energy_battery_props;\n\t\t\tbattery->bat_desc.num_properties =\n\t\t\t    ARRAY_SIZE(energy_battery_props);\n\t\t}\n\t}\n\n\tbattery->bat_desc.name = acpi_device_bid(battery->device);\n\tbattery->bat_desc.type = POWER_SUPPLY_TYPE_BATTERY;\n\tbattery->bat_desc.get_property = acpi_battery_get_property;\n\n\tbattery->bat = power_supply_register_no_ws(&battery->device->dev,\n\t\t\t\t&battery->bat_desc, &psy_cfg);\n\n\tif (IS_ERR(battery->bat)) {\n\t\tint result = PTR_ERR(battery->bat);\n\n\t\tbattery->bat = NULL;\n\t\treturn result;\n\t}\n\tbattery_hook_add_battery(battery);\n\treturn device_create_file(&battery->bat->dev, &alarm_attr);\n}\n\nstatic void sysfs_remove_battery(struct acpi_battery *battery)\n{\n\tmutex_lock(&battery->sysfs_lock);\n\tif (!battery->bat) {\n\t\tmutex_unlock(&battery->sysfs_lock);\n\t\treturn;\n\t}\n\tbattery_hook_remove_battery(battery);\n\tdevice_remove_file(&battery->bat->dev, &alarm_attr);\n\tpower_supply_unregister(battery->bat);\n\tbattery->bat = NULL;\n\tmutex_unlock(&battery->sysfs_lock);\n}\n\nstatic void find_battery(const struct dmi_header *dm, void *private)\n{\n\tstruct acpi_battery *battery = (struct acpi_battery *)private;\n\t \n\tif (dm->type == DMI_ENTRY_PORTABLE_BATTERY && dm->length >= 8) {\n\t\tconst u8 *dmi_data = (const u8 *)(dm + 1);\n\t\tint dmi_capacity = get_unaligned((const u16 *)(dmi_data + 6));\n\n\t\tif (dm->length >= 18)\n\t\t\tdmi_capacity *= dmi_data[17];\n\t\tif (battery->design_capacity * battery->design_voltage / 1000\n\t\t    != dmi_capacity &&\n\t\t    battery->design_capacity * 10 == dmi_capacity)\n\t\t\tset_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH,\n\t\t\t\t&battery->flags);\n\t}\n}\n\n \nstatic void acpi_battery_quirks(struct acpi_battery *battery)\n{\n\tif (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags))\n\t\treturn;\n\n\tif (battery->full_charge_capacity == 100 &&\n\t\tbattery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN &&\n\t\tbattery->capacity_now >= 0 && battery->capacity_now <= 100) {\n\t\tset_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags);\n\t\tbattery->full_charge_capacity = battery->design_capacity;\n\t\tbattery->capacity_now = (battery->capacity_now *\n\t\t\t\tbattery->full_charge_capacity) / 100;\n\t}\n\n\tif (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags))\n\t\treturn;\n\n\tif (battery->power_unit && dmi_name_in_vendors(\"LENOVO\")) {\n\t\tconst char *s;\n\n\t\ts = dmi_get_system_info(DMI_PRODUCT_VERSION);\n\t\tif (s && !strncasecmp(s, \"ThinkPad\", 8)) {\n\t\t\tdmi_walk(find_battery, battery);\n\t\t\tif (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH,\n\t\t\t\t     &battery->flags) &&\n\t\t\t    battery->design_voltage) {\n\t\t\t\tbattery->design_capacity =\n\t\t\t\t    battery->design_capacity *\n\t\t\t\t    10000 / battery->design_voltage;\n\t\t\t\tbattery->full_charge_capacity =\n\t\t\t\t    battery->full_charge_capacity *\n\t\t\t\t    10000 / battery->design_voltage;\n\t\t\t\tbattery->design_capacity_warning =\n\t\t\t\t    battery->design_capacity_warning *\n\t\t\t\t    10000 / battery->design_voltage;\n\t\t\t\tbattery->capacity_now = battery->capacity_now *\n\t\t\t\t    10000 / battery->design_voltage;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (test_bit(ACPI_BATTERY_QUIRK_DEGRADED_FULL_CHARGE, &battery->flags))\n\t\treturn;\n\n\tif (acpi_battery_is_degraded(battery) &&\n\t    battery->capacity_now > battery->full_charge_capacity) {\n\t\tset_bit(ACPI_BATTERY_QUIRK_DEGRADED_FULL_CHARGE, &battery->flags);\n\t\tbattery->capacity_now = battery->full_charge_capacity;\n\t}\n}\n\nstatic int acpi_battery_update(struct acpi_battery *battery, bool resume)\n{\n\tint result = acpi_battery_get_status(battery);\n\n\tif (result)\n\t\treturn result;\n\n\tif (!acpi_battery_present(battery)) {\n\t\tsysfs_remove_battery(battery);\n\t\tbattery->update_time = 0;\n\t\treturn 0;\n\t}\n\n\tif (resume)\n\t\treturn 0;\n\n\tif (!battery->update_time) {\n\t\tresult = acpi_battery_get_info(battery);\n\t\tif (result)\n\t\t\treturn result;\n\t\tacpi_battery_init_alarm(battery);\n\t}\n\n\tresult = acpi_battery_get_state(battery);\n\tif (result)\n\t\treturn result;\n\tacpi_battery_quirks(battery);\n\n\tif (!battery->bat) {\n\t\tresult = sysfs_add_battery(battery);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\t \n\tif ((battery->state & ACPI_BATTERY_STATE_CRITICAL) ||\n\t    (test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags) &&\n\t     (battery->capacity_now <= battery->alarm)))\n\t\tacpi_pm_wakeup_event(&battery->device->dev);\n\n\treturn result;\n}\n\nstatic void acpi_battery_refresh(struct acpi_battery *battery)\n{\n\tint power_unit;\n\n\tif (!battery->bat)\n\t\treturn;\n\n\tpower_unit = battery->power_unit;\n\n\tacpi_battery_get_info(battery);\n\n\tif (power_unit == battery->power_unit)\n\t\treturn;\n\n\t \n\tsysfs_remove_battery(battery);\n\tsysfs_add_battery(battery);\n}\n\n \nstatic void acpi_battery_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct acpi_device *device = data;\n\tstruct acpi_battery *battery = acpi_driver_data(device);\n\tstruct power_supply *old;\n\n\tif (!battery)\n\t\treturn;\n\told = battery->bat;\n\t \n\tif (battery_notification_delay_ms > 0)\n\t\tmsleep(battery_notification_delay_ms);\n\tif (event == ACPI_BATTERY_NOTIFY_INFO)\n\t\tacpi_battery_refresh(battery);\n\tacpi_battery_update(battery, false);\n\tacpi_bus_generate_netlink_event(device->pnp.device_class,\n\t\t\t\t\tdev_name(&device->dev), event,\n\t\t\t\t\tacpi_battery_present(battery));\n\tacpi_notifier_call_chain(device, event, acpi_battery_present(battery));\n\t \n\tif (old && battery->bat)\n\t\tpower_supply_changed(battery->bat);\n}\n\nstatic int battery_notify(struct notifier_block *nb,\n\t\t\t       unsigned long mode, void *_unused)\n{\n\tstruct acpi_battery *battery = container_of(nb, struct acpi_battery,\n\t\t\t\t\t\t    pm_nb);\n\tint result;\n\n\tswitch (mode) {\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_SUSPEND:\n\t\tif (!acpi_battery_present(battery))\n\t\t\treturn 0;\n\n\t\tif (battery->bat) {\n\t\t\tacpi_battery_refresh(battery);\n\t\t} else {\n\t\t\tresult = acpi_battery_get_info(battery);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\n\t\t\tresult = sysfs_add_battery(battery);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t}\n\n\t\tacpi_battery_init_alarm(battery);\n\t\tacpi_battery_get_state(battery);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init\nbattery_bix_broken_package_quirk(const struct dmi_system_id *d)\n{\n\tbattery_bix_broken_package = 1;\n\treturn 0;\n}\n\nstatic int __init\nbattery_notification_delay_quirk(const struct dmi_system_id *d)\n{\n\tbattery_notification_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic int __init\nbattery_ac_is_broken_quirk(const struct dmi_system_id *d)\n{\n\tbattery_ac_is_broken = 1;\n\treturn 0;\n}\n\nstatic const struct dmi_system_id bat_dmi_table[] __initconst = {\n\t{\n\t\t \n\t\t.callback = battery_bix_broken_package_quirk,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"NEC\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PC-LZ750LS\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.callback = battery_notification_delay_quirk,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire V5-573G\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.callback = battery_ac_is_broken_quirk,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AMI Corporation\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Aptio CRB\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"3BAIR1013\"),\n\t\t\t \n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"08/22/2014\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.callback = battery_notification_delay_quirk,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Microsoft Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Surface Go 3\"),\n\t\t},\n\t},\n\t{},\n};\n\n \nstatic int acpi_battery_update_retry(struct acpi_battery *battery)\n{\n\tint retry, ret;\n\n\tfor (retry = 5; retry; retry--) {\n\t\tret = acpi_battery_update(battery, false);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t}\n\treturn ret;\n}\n\nstatic int acpi_battery_add(struct acpi_device *device)\n{\n\tint result = 0;\n\tstruct acpi_battery *battery = NULL;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tif (device->dep_unmet)\n\t\treturn -EPROBE_DEFER;\n\n\tbattery = kzalloc(sizeof(struct acpi_battery), GFP_KERNEL);\n\tif (!battery)\n\t\treturn -ENOMEM;\n\tbattery->device = device;\n\tstrcpy(acpi_device_name(device), ACPI_BATTERY_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);\n\tdevice->driver_data = battery;\n\tmutex_init(&battery->lock);\n\tmutex_init(&battery->sysfs_lock);\n\tif (acpi_has_method(battery->device->handle, \"_BIX\"))\n\t\tset_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags);\n\n\tresult = acpi_battery_update_retry(battery);\n\tif (result)\n\t\tgoto fail;\n\n\tpr_info(\"Slot [%s] (battery %s)\\n\", acpi_device_bid(device),\n\t\tdevice->status.battery_present ? \"present\" : \"absent\");\n\n\tbattery->pm_nb.notifier_call = battery_notify;\n\tregister_pm_notifier(&battery->pm_nb);\n\n\tdevice_init_wakeup(&device->dev, 1);\n\n\tresult = acpi_dev_install_notify_handler(device, ACPI_ALL_NOTIFY,\n\t\t\t\t\t\t acpi_battery_notify);\n\tif (result)\n\t\tgoto fail_pm;\n\n\treturn 0;\n\nfail_pm:\n\tdevice_init_wakeup(&device->dev, 0);\n\tunregister_pm_notifier(&battery->pm_nb);\nfail:\n\tsysfs_remove_battery(battery);\n\tmutex_destroy(&battery->lock);\n\tmutex_destroy(&battery->sysfs_lock);\n\tkfree(battery);\n\n\treturn result;\n}\n\nstatic void acpi_battery_remove(struct acpi_device *device)\n{\n\tstruct acpi_battery *battery = NULL;\n\n\tif (!device || !acpi_driver_data(device))\n\t\treturn;\n\n\tbattery = acpi_driver_data(device);\n\n\tacpi_dev_remove_notify_handler(device, ACPI_ALL_NOTIFY,\n\t\t\t\t       acpi_battery_notify);\n\n\tdevice_init_wakeup(&device->dev, 0);\n\tunregister_pm_notifier(&battery->pm_nb);\n\tsysfs_remove_battery(battery);\n\n\tmutex_destroy(&battery->lock);\n\tmutex_destroy(&battery->sysfs_lock);\n\tkfree(battery);\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int acpi_battery_resume(struct device *dev)\n{\n\tstruct acpi_battery *battery;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tbattery = acpi_driver_data(to_acpi_device(dev));\n\tif (!battery)\n\t\treturn -EINVAL;\n\n\tbattery->update_time = 0;\n\tacpi_battery_update(battery, true);\n\treturn 0;\n}\n#else\n#define acpi_battery_resume NULL\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(acpi_battery_pm, NULL, acpi_battery_resume);\n\nstatic struct acpi_driver acpi_battery_driver = {\n\t.name = \"battery\",\n\t.class = ACPI_BATTERY_CLASS,\n\t.ids = battery_device_ids,\n\t.ops = {\n\t\t.add = acpi_battery_add,\n\t\t.remove = acpi_battery_remove,\n\t\t},\n\t.drv.pm = &acpi_battery_pm,\n};\n\nstatic void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)\n{\n\tint result;\n\n\tif (acpi_quirk_skip_acpi_ac_and_battery())\n\t\treturn;\n\n\tdmi_check_system(bat_dmi_table);\n\n\tresult = acpi_bus_register_driver(&acpi_battery_driver);\n\tbattery_driver_registered = (result == 0);\n}\n\nstatic int __init acpi_battery_init(void)\n{\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\tasync_cookie = async_schedule(acpi_battery_init_async, NULL);\n\treturn 0;\n}\n\nstatic void __exit acpi_battery_exit(void)\n{\n\tasync_synchronize_cookie(async_cookie + 1);\n\tif (battery_driver_registered) {\n\t\tacpi_bus_unregister_driver(&acpi_battery_driver);\n\t\tbattery_hook_exit();\n\t}\n}\n\nmodule_init(acpi_battery_init);\nmodule_exit(acpi_battery_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}