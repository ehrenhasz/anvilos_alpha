{
  "module_name": "processor_throttling.c",
  "hash_id": "b49d9e521dbc6b5c0afd7f1cb017a50b9a3346f59ce0cca295a5e621eb0af83a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/processor_throttling.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/cpufreq.h>\n#include <linux/acpi.h>\n#include <acpi/processor.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n \nstatic int ignore_tpc;\nmodule_param(ignore_tpc, int, 0644);\nMODULE_PARM_DESC(ignore_tpc, \"Disable broken BIOS _TPC throttling support\");\n\nstruct throttling_tstate {\n\tunsigned int cpu;\t\t \n\tint target_state;\t\t \n};\n\nstruct acpi_processor_throttling_arg {\n\tstruct acpi_processor *pr;\n\tint target_state;\n\tbool force;\n};\n\n#define THROTTLING_PRECHANGE       (1)\n#define THROTTLING_POSTCHANGE      (2)\n\nstatic int acpi_processor_get_throttling(struct acpi_processor *pr);\nstatic int __acpi_processor_set_throttling(struct acpi_processor *pr,\n\t\t\t\t\t   int state, bool force, bool direct);\n\nstatic int acpi_processor_update_tsd_coord(void)\n{\n\tint count_target;\n\tint retval = 0;\n\tunsigned int i, j;\n\tcpumask_var_t covered_cpus;\n\tstruct acpi_processor *pr, *match_pr;\n\tstruct acpi_tsd_package *pdomain, *match_pdomain;\n\tstruct acpi_processor_throttling *pthrottling, *match_pthrottling;\n\n\tif (!zalloc_cpumask_var(&covered_cpus, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\t \n\tfor_each_possible_cpu(i) {\n\t\tpr = per_cpu(processors, i);\n\t\tif (!pr)\n\t\t\tcontinue;\n\n\t\t \n\t\tpthrottling = &(pr->throttling);\n\n\t\t \n\t\tif (!pthrottling->tsd_valid_flag) {\n\t\t\tretval = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (retval)\n\t\tgoto err_ret;\n\n\tfor_each_possible_cpu(i) {\n\t\tpr = per_cpu(processors, i);\n\t\tif (!pr)\n\t\t\tcontinue;\n\n\t\tif (cpumask_test_cpu(i, covered_cpus))\n\t\t\tcontinue;\n\t\tpthrottling = &pr->throttling;\n\n\t\tpdomain = &(pthrottling->domain_info);\n\t\tcpumask_set_cpu(i, pthrottling->shared_cpu_map);\n\t\tcpumask_set_cpu(i, covered_cpus);\n\t\t \n\t\tif (pdomain->num_processors <= 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tcount_target = pdomain->num_processors;\n\n\t\tfor_each_possible_cpu(j) {\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\n\t\t\tmatch_pr = per_cpu(processors, j);\n\t\t\tif (!match_pr)\n\t\t\t\tcontinue;\n\n\t\t\tmatch_pthrottling = &(match_pr->throttling);\n\t\t\tmatch_pdomain = &(match_pthrottling->domain_info);\n\t\t\tif (match_pdomain->domain != pdomain->domain)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (match_pdomain->num_processors != count_target) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto err_ret;\n\t\t\t}\n\n\t\t\tif (pdomain->coord_type != match_pdomain->coord_type) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto err_ret;\n\t\t\t}\n\n\t\t\tcpumask_set_cpu(j, covered_cpus);\n\t\t\tcpumask_set_cpu(j, pthrottling->shared_cpu_map);\n\t\t}\n\t\tfor_each_possible_cpu(j) {\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\n\t\t\tmatch_pr = per_cpu(processors, j);\n\t\t\tif (!match_pr)\n\t\t\t\tcontinue;\n\n\t\t\tmatch_pthrottling = &(match_pr->throttling);\n\t\t\tmatch_pdomain = &(match_pthrottling->domain_info);\n\t\t\tif (match_pdomain->domain != pdomain->domain)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tcpumask_copy(match_pthrottling->shared_cpu_map,\n\t\t\t\t     pthrottling->shared_cpu_map);\n\t\t}\n\t}\n\nerr_ret:\n\tfree_cpumask_var(covered_cpus);\n\n\tfor_each_possible_cpu(i) {\n\t\tpr = per_cpu(processors, i);\n\t\tif (!pr)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (retval) {\n\t\t\tpthrottling = &(pr->throttling);\n\t\t\tcpumask_clear(pthrottling->shared_cpu_map);\n\t\t\tcpumask_set_cpu(i, pthrottling->shared_cpu_map);\n\t\t\tpthrottling->shared_type = DOMAIN_COORD_TYPE_SW_ALL;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n \nvoid acpi_processor_throttling_init(void)\n{\n\tif (acpi_processor_update_tsd_coord())\n\t\tpr_debug(\"Assume no T-state coordination\\n\");\n}\n\nstatic int acpi_processor_throttling_notifier(unsigned long event, void *data)\n{\n\tstruct throttling_tstate *p_tstate = data;\n\tstruct acpi_processor *pr;\n\tunsigned int cpu;\n\tint target_state;\n\tstruct acpi_processor_limit *p_limit;\n\tstruct acpi_processor_throttling *p_throttling;\n\n\tcpu = p_tstate->cpu;\n\tpr = per_cpu(processors, cpu);\n\tif (!pr) {\n\t\tpr_debug(\"Invalid pr pointer\\n\");\n\t\treturn 0;\n\t}\n\tif (!pr->flags.throttling) {\n\t\tacpi_handle_debug(pr->handle,\n\t\t\t\t  \"Throttling control unsupported on CPU %d\\n\",\n\t\t\t\t  cpu);\n\t\treturn 0;\n\t}\n\ttarget_state = p_tstate->target_state;\n\tp_throttling = &(pr->throttling);\n\tswitch (event) {\n\tcase THROTTLING_PRECHANGE:\n\t\t \n\t\tp_limit = &pr->limit;\n\t\tif (p_limit->thermal.tx > target_state)\n\t\t\ttarget_state = p_limit->thermal.tx;\n\t\tif (p_limit->user.tx > target_state)\n\t\t\ttarget_state = p_limit->user.tx;\n\t\tif (pr->throttling_platform_limit > target_state)\n\t\t\ttarget_state = pr->throttling_platform_limit;\n\t\tif (target_state >= p_throttling->state_count) {\n\t\t\tpr_warn(\"Exceed the limit of T-state \\n\");\n\t\t\ttarget_state = p_throttling->state_count - 1;\n\t\t}\n\t\tp_tstate->target_state = target_state;\n\t\tacpi_handle_debug(pr->handle,\n\t\t\t\t  \"PreChange Event: target T-state of CPU %d is T%d\\n\",\n\t\t\t\t  cpu, target_state);\n\t\tbreak;\n\tcase THROTTLING_POSTCHANGE:\n\t\t \n\t\tp_throttling->state = target_state;\n\t\tacpi_handle_debug(pr->handle,\n\t\t\t\t  \"PostChange Event: CPU %d is switched to T%d\\n\",\n\t\t\t\t  cpu, target_state);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Unsupported Throttling notifier event\\n\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int acpi_processor_get_platform_limit(struct acpi_processor *pr)\n{\n\tacpi_status status = 0;\n\tunsigned long long tpc = 0;\n\n\tif (!pr)\n\t\treturn -EINVAL;\n\n\tif (ignore_tpc)\n\t\tgoto end;\n\n\tstatus = acpi_evaluate_integer(pr->handle, \"_TPC\", NULL, &tpc);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status != AE_NOT_FOUND)\n\t\t\tacpi_evaluation_failure_warn(pr->handle, \"_TPC\", status);\n\n\t\treturn -ENODEV;\n\t}\n\nend:\n\tpr->throttling_platform_limit = (int)tpc;\n\treturn 0;\n}\n\nint acpi_processor_tstate_has_changed(struct acpi_processor *pr)\n{\n\tint result = 0;\n\tint throttling_limit;\n\tint current_state;\n\tstruct acpi_processor_limit *limit;\n\tint target_state;\n\n\tif (ignore_tpc)\n\t\treturn 0;\n\n\tresult = acpi_processor_get_platform_limit(pr);\n\tif (result) {\n\t\t \n\t\treturn result;\n\t}\n\n\tthrottling_limit = pr->throttling_platform_limit;\n\tif (throttling_limit >= pr->throttling.state_count) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tcurrent_state = pr->throttling.state;\n\tif (current_state > throttling_limit) {\n\t\t \n\t\tlimit = &pr->limit;\n\t\ttarget_state = throttling_limit;\n\t\tif (limit->thermal.tx > target_state)\n\t\t\ttarget_state = limit->thermal.tx;\n\t\tif (limit->user.tx > target_state)\n\t\t\ttarget_state = limit->user.tx;\n\t} else if (current_state == throttling_limit) {\n\t\t \n\t\treturn 0;\n\t} else {\n\t\t \n\t\ttarget_state = throttling_limit;\n\t}\n\treturn acpi_processor_set_throttling(pr, target_state, false);\n}\n\n \nvoid acpi_processor_reevaluate_tstate(struct acpi_processor *pr,\n\t\t\t\t\tbool is_dead)\n{\n\tint result = 0;\n\n\tif (is_dead) {\n\t\t \n\t\tpr->flags.throttling = 0;\n\t\treturn;\n\t}\n\t \n\tif (!pr->throttling.state_count) {\n\t\t \n\t\tpr->flags.throttling = 0;\n\t\treturn;\n\t}\n\tpr->flags.throttling = 1;\n\n\t \n\n\tresult = acpi_processor_get_throttling(pr);\n\tif (result)\n\t\tgoto end;\n\n\tif (pr->throttling.state) {\n\t\tresult = acpi_processor_set_throttling(pr, 0, false);\n\t\tif (result)\n\t\t\tgoto end;\n\t}\n\nend:\n\tif (result)\n\t\tpr->flags.throttling = 0;\n}\n \nstatic int acpi_processor_get_throttling_control(struct acpi_processor *pr)\n{\n\tint result = 0;\n\tacpi_status status = 0;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *ptc = NULL;\n\tunion acpi_object obj;\n\tstruct acpi_processor_throttling *throttling;\n\n\tstatus = acpi_evaluate_object(pr->handle, \"_PTC\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status != AE_NOT_FOUND)\n\t\t\tacpi_evaluation_failure_warn(pr->handle, \"_PTC\", status);\n\n\t\treturn -ENODEV;\n\t}\n\n\tptc = (union acpi_object *)buffer.pointer;\n\tif (!ptc || (ptc->type != ACPI_TYPE_PACKAGE)\n\t    || (ptc->package.count != 2)) {\n\t\tpr_err(\"Invalid _PTC data\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\t \n\n\tobj = ptc->package.elements[0];\n\n\tif ((obj.type != ACPI_TYPE_BUFFER)\n\t    || (obj.buffer.length < sizeof(struct acpi_ptc_register))\n\t    || (obj.buffer.pointer == NULL)) {\n\t\tpr_err(\"Invalid _PTC data (control_register)\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\tmemcpy(&pr->throttling.control_register, obj.buffer.pointer,\n\t       sizeof(struct acpi_ptc_register));\n\n\t \n\n\tobj = ptc->package.elements[1];\n\n\tif ((obj.type != ACPI_TYPE_BUFFER)\n\t    || (obj.buffer.length < sizeof(struct acpi_ptc_register))\n\t    || (obj.buffer.pointer == NULL)) {\n\t\tpr_err(\"Invalid _PTC data (status_register)\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tmemcpy(&pr->throttling.status_register, obj.buffer.pointer,\n\t       sizeof(struct acpi_ptc_register));\n\n\tthrottling = &pr->throttling;\n\n\tif ((throttling->control_register.bit_width +\n\t\tthrottling->control_register.bit_offset) > 32) {\n\t\tpr_err(\"Invalid _PTC control register\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tif ((throttling->status_register.bit_width +\n\t\tthrottling->status_register.bit_offset) > 32) {\n\t\tpr_err(\"Invalid _PTC status register\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\nend:\n\tkfree(buffer.pointer);\n\n\treturn result;\n}\n\n \nstatic int acpi_processor_get_throttling_states(struct acpi_processor *pr)\n{\n\tint result = 0;\n\tacpi_status status = AE_OK;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_buffer format = { sizeof(\"NNNNN\"), \"NNNNN\" };\n\tstruct acpi_buffer state = { 0, NULL };\n\tunion acpi_object *tss = NULL;\n\tint i;\n\n\tstatus = acpi_evaluate_object(pr->handle, \"_TSS\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status != AE_NOT_FOUND)\n\t\t\tacpi_evaluation_failure_warn(pr->handle, \"_TSS\", status);\n\n\t\treturn -ENODEV;\n\t}\n\n\ttss = buffer.pointer;\n\tif (!tss || (tss->type != ACPI_TYPE_PACKAGE)) {\n\t\tpr_err(\"Invalid _TSS data\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tacpi_handle_debug(pr->handle, \"Found %d throttling states\\n\",\n\t\t\t  tss->package.count);\n\n\tpr->throttling.state_count = tss->package.count;\n\tpr->throttling.states_tss =\n\t    kmalloc_array(tss->package.count,\n\t\t\t  sizeof(struct acpi_processor_tx_tss),\n\t\t\t  GFP_KERNEL);\n\tif (!pr->throttling.states_tss) {\n\t\tresult = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tfor (i = 0; i < pr->throttling.state_count; i++) {\n\n\t\tstruct acpi_processor_tx_tss *tx =\n\t\t    (struct acpi_processor_tx_tss *)&(pr->throttling.\n\t\t\t\t\t\t      states_tss[i]);\n\n\t\tstate.length = sizeof(struct acpi_processor_tx_tss);\n\t\tstate.pointer = tx;\n\n\t\tacpi_handle_debug(pr->handle, \"Extracting state %d\\n\", i);\n\n\t\tstatus = acpi_extract_package(&(tss->package.elements[i]),\n\t\t\t\t\t      &format, &state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_handle_warn(pr->handle, \"Invalid _TSS data: %s\\n\",\n\t\t\t\t\t acpi_format_exception(status));\n\t\t\tresult = -EFAULT;\n\t\t\tkfree(pr->throttling.states_tss);\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (!tx->freqpercentage) {\n\t\t\tpr_err(\"Invalid _TSS data: freq is zero\\n\");\n\t\t\tresult = -EFAULT;\n\t\t\tkfree(pr->throttling.states_tss);\n\t\t\tgoto end;\n\t\t}\n\t}\n\nend:\n\tkfree(buffer.pointer);\n\n\treturn result;\n}\n\n \nstatic int acpi_processor_get_tsd(struct acpi_processor *pr)\n{\n\tint result = 0;\n\tacpi_status status = AE_OK;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_buffer format = { sizeof(\"NNNNN\"), \"NNNNN\" };\n\tstruct acpi_buffer state = { 0, NULL };\n\tunion acpi_object *tsd = NULL;\n\tstruct acpi_tsd_package *pdomain;\n\tstruct acpi_processor_throttling *pthrottling;\n\n\tpthrottling = &pr->throttling;\n\tpthrottling->tsd_valid_flag = 0;\n\n\tstatus = acpi_evaluate_object(pr->handle, \"_TSD\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status != AE_NOT_FOUND)\n\t\t\tacpi_evaluation_failure_warn(pr->handle, \"_TSD\", status);\n\n\t\treturn -ENODEV;\n\t}\n\n\ttsd = buffer.pointer;\n\tif (!tsd || (tsd->type != ACPI_TYPE_PACKAGE)) {\n\t\tpr_err(\"Invalid _TSD data\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tif (tsd->package.count != 1) {\n\t\tpr_err(\"Invalid _TSD data\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tpdomain = &(pr->throttling.domain_info);\n\n\tstate.length = sizeof(struct acpi_tsd_package);\n\tstate.pointer = pdomain;\n\n\tstatus = acpi_extract_package(&(tsd->package.elements[0]),\n\t\t\t\t      &format, &state);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Invalid _TSD data\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tif (pdomain->num_entries != ACPI_TSD_REV0_ENTRIES) {\n\t\tpr_err(\"Unknown _TSD:num_entries\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tif (pdomain->revision != ACPI_TSD_REV0_REVISION) {\n\t\tpr_err(\"Unknown _TSD:revision\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tpthrottling = &pr->throttling;\n\tpthrottling->tsd_valid_flag = 1;\n\tpthrottling->shared_type = pdomain->coord_type;\n\tcpumask_set_cpu(pr->id, pthrottling->shared_cpu_map);\n\t \n\tif (pdomain->coord_type != DOMAIN_COORD_TYPE_SW_ALL &&\n\t\tpdomain->coord_type != DOMAIN_COORD_TYPE_SW_ANY &&\n\t\tpdomain->coord_type != DOMAIN_COORD_TYPE_HW_ALL) {\n\t\tpthrottling->tsd_valid_flag = 0;\n\t\tpthrottling->shared_type = DOMAIN_COORD_TYPE_SW_ALL;\n\t}\n\nend:\n\tkfree(buffer.pointer);\n\treturn result;\n}\n\n \nstatic int acpi_processor_get_throttling_fadt(struct acpi_processor *pr)\n{\n\tint state = 0;\n\tu32 value = 0;\n\tu32 duty_mask = 0;\n\tu32 duty_value = 0;\n\n\tif (!pr)\n\t\treturn -EINVAL;\n\n\tif (!pr->flags.throttling)\n\t\treturn -ENODEV;\n\n\t \n\trequest_region(pr->throttling.address, 6, \"ACPI CPU throttle\");\n\n\tpr->throttling.state = 0;\n\n\tduty_mask = pr->throttling.state_count - 1;\n\n\tduty_mask <<= pr->throttling.duty_offset;\n\n\tlocal_irq_disable();\n\n\tvalue = inl(pr->throttling.address);\n\n\t \n\tif (value & 0x10) {\n\t\tduty_value = value & duty_mask;\n\t\tduty_value >>= pr->throttling.duty_offset;\n\n\t\tif (duty_value)\n\t\t\tstate = pr->throttling.state_count - duty_value;\n\t}\n\n\tpr->throttling.state = state;\n\n\tlocal_irq_enable();\n\n\tacpi_handle_debug(pr->handle,\n\t\t\t  \"Throttling state is T%d (%d%% throttling applied)\\n\",\n\t\t\t  state, pr->throttling.states[state].performance);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_X86\nstatic int acpi_throttling_rdmsr(u64 *value)\n{\n\tu64 msr_high, msr_low;\n\tu64 msr = 0;\n\tint ret = -1;\n\n\tif ((this_cpu_read(cpu_info.x86_vendor) != X86_VENDOR_INTEL) ||\n\t\t!this_cpu_has(X86_FEATURE_ACPI)) {\n\t\tpr_err(\"HARDWARE addr space,NOT supported yet\\n\");\n\t} else {\n\t\tmsr_low = 0;\n\t\tmsr_high = 0;\n\t\trdmsr_safe(MSR_IA32_THERM_CONTROL,\n\t\t\t(u32 *)&msr_low, (u32 *) &msr_high);\n\t\tmsr = (msr_high << 32) | msr_low;\n\t\t*value = (u64) msr;\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic int acpi_throttling_wrmsr(u64 value)\n{\n\tint ret = -1;\n\tu64 msr;\n\n\tif ((this_cpu_read(cpu_info.x86_vendor) != X86_VENDOR_INTEL) ||\n\t\t!this_cpu_has(X86_FEATURE_ACPI)) {\n\t\tpr_err(\"HARDWARE addr space,NOT supported yet\\n\");\n\t} else {\n\t\tmsr = value;\n\t\twrmsr_safe(MSR_IA32_THERM_CONTROL,\n\t\t\tmsr & 0xffffffff, msr >> 32);\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n#else\nstatic int acpi_throttling_rdmsr(u64 *value)\n{\n\tpr_err(\"HARDWARE addr space,NOT supported yet\\n\");\n\treturn -1;\n}\n\nstatic int acpi_throttling_wrmsr(u64 value)\n{\n\tpr_err(\"HARDWARE addr space,NOT supported yet\\n\");\n\treturn -1;\n}\n#endif\n\nstatic int acpi_read_throttling_status(struct acpi_processor *pr,\n\t\t\t\t\tu64 *value)\n{\n\tu32 bit_width, bit_offset;\n\tu32 ptc_value;\n\tu64 ptc_mask;\n\tstruct acpi_processor_throttling *throttling;\n\tint ret = -1;\n\n\tthrottling = &pr->throttling;\n\tswitch (throttling->status_register.space_id) {\n\tcase ACPI_ADR_SPACE_SYSTEM_IO:\n\t\tbit_width = throttling->status_register.bit_width;\n\t\tbit_offset = throttling->status_register.bit_offset;\n\n\t\tacpi_os_read_port((acpi_io_address) throttling->status_register.\n\t\t\t\t  address, &ptc_value,\n\t\t\t\t  (u32) (bit_width + bit_offset));\n\t\tptc_mask = (1 << bit_width) - 1;\n\t\t*value = (u64) ((ptc_value >> bit_offset) & ptc_mask);\n\t\tret = 0;\n\t\tbreak;\n\tcase ACPI_ADR_SPACE_FIXED_HARDWARE:\n\t\tret = acpi_throttling_rdmsr(value);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown addr space %d\\n\",\n\t\t       (u32) (throttling->status_register.space_id));\n\t}\n\treturn ret;\n}\n\nstatic int acpi_write_throttling_state(struct acpi_processor *pr,\n\t\t\t\tu64 value)\n{\n\tu32 bit_width, bit_offset;\n\tu64 ptc_value;\n\tu64 ptc_mask;\n\tstruct acpi_processor_throttling *throttling;\n\tint ret = -1;\n\n\tthrottling = &pr->throttling;\n\tswitch (throttling->control_register.space_id) {\n\tcase ACPI_ADR_SPACE_SYSTEM_IO:\n\t\tbit_width = throttling->control_register.bit_width;\n\t\tbit_offset = throttling->control_register.bit_offset;\n\t\tptc_mask = (1 << bit_width) - 1;\n\t\tptc_value = value & ptc_mask;\n\n\t\tacpi_os_write_port((acpi_io_address) throttling->\n\t\t\t\t\tcontrol_register.address,\n\t\t\t\t\t(u32) (ptc_value << bit_offset),\n\t\t\t\t\t(u32) (bit_width + bit_offset));\n\t\tret = 0;\n\t\tbreak;\n\tcase ACPI_ADR_SPACE_FIXED_HARDWARE:\n\t\tret = acpi_throttling_wrmsr(value);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown addr space %d\\n\",\n\t\t       (u32) (throttling->control_register.space_id));\n\t}\n\treturn ret;\n}\n\nstatic int acpi_get_throttling_state(struct acpi_processor *pr,\n\t\t\t\tu64 value)\n{\n\tint i;\n\n\tfor (i = 0; i < pr->throttling.state_count; i++) {\n\t\tstruct acpi_processor_tx_tss *tx =\n\t\t    (struct acpi_processor_tx_tss *)&(pr->throttling.\n\t\t\t\t\t\t      states_tss[i]);\n\t\tif (tx->control == value)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nstatic int acpi_get_throttling_value(struct acpi_processor *pr,\n\t\t\tint state, u64 *value)\n{\n\tint ret = -1;\n\n\tif (state >= 0 && state <= pr->throttling.state_count) {\n\t\tstruct acpi_processor_tx_tss *tx =\n\t\t    (struct acpi_processor_tx_tss *)&(pr->throttling.\n\t\t\t\t\t\t      states_tss[state]);\n\t\t*value = tx->control;\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic int acpi_processor_get_throttling_ptc(struct acpi_processor *pr)\n{\n\tint state = 0;\n\tint ret;\n\tu64 value;\n\n\tif (!pr)\n\t\treturn -EINVAL;\n\n\tif (!pr->flags.throttling)\n\t\treturn -ENODEV;\n\n\tpr->throttling.state = 0;\n\n\tvalue = 0;\n\tret = acpi_read_throttling_status(pr, &value);\n\tif (ret >= 0) {\n\t\tstate = acpi_get_throttling_state(pr, value);\n\t\tif (state == -1) {\n\t\t\tacpi_handle_debug(pr->handle,\n\t\t\t\t\t  \"Invalid throttling state, reset\\n\");\n\t\t\tstate = 0;\n\t\t\tret = __acpi_processor_set_throttling(pr, state, true,\n\t\t\t\t\t\t\t      true);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tpr->throttling.state = state;\n\t}\n\n\treturn 0;\n}\n\nstatic long __acpi_processor_get_throttling(void *data)\n{\n\tstruct acpi_processor *pr = data;\n\n\treturn pr->throttling.acpi_processor_get_throttling(pr);\n}\n\nstatic int acpi_processor_get_throttling(struct acpi_processor *pr)\n{\n\tif (!pr)\n\t\treturn -EINVAL;\n\n\tif (!pr->flags.throttling)\n\t\treturn -ENODEV;\n\n\t \n\tif (!cpu_online(pr->id))\n\t\treturn -ENODEV;\n\n\treturn call_on_cpu(pr->id, __acpi_processor_get_throttling, pr, false);\n}\n\nstatic int acpi_processor_get_fadt_info(struct acpi_processor *pr)\n{\n\tint i, step;\n\n\tif (!pr->throttling.address) {\n\t\tacpi_handle_debug(pr->handle, \"No throttling register\\n\");\n\t\treturn -EINVAL;\n\t} else if (!pr->throttling.duty_width) {\n\t\tacpi_handle_debug(pr->handle, \"No throttling states\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\telse if ((pr->throttling.duty_offset + pr->throttling.duty_width) > 4) {\n\t\tpr_warn(\"duty_cycle spans bit 4\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr->throttling.state_count = 1 << acpi_gbl_FADT.duty_width;\n\n\t \n\n\tstep = (1000 / pr->throttling.state_count);\n\n\tfor (i = 0; i < pr->throttling.state_count; i++) {\n\t\tpr->throttling.states[i].performance = 1000 - step * i;\n\t\tpr->throttling.states[i].power = 1000 - step * i;\n\t}\n\treturn 0;\n}\n\nstatic int acpi_processor_set_throttling_fadt(struct acpi_processor *pr,\n\t\t\t\t\t      int state, bool force)\n{\n\tu32 value = 0;\n\tu32 duty_mask = 0;\n\tu32 duty_value = 0;\n\n\tif (!pr)\n\t\treturn -EINVAL;\n\n\tif ((state < 0) || (state > (pr->throttling.state_count - 1)))\n\t\treturn -EINVAL;\n\n\tif (!pr->flags.throttling)\n\t\treturn -ENODEV;\n\n\tif (!force && (state == pr->throttling.state))\n\t\treturn 0;\n\n\tif (state < pr->throttling_platform_limit)\n\t\treturn -EPERM;\n\t \n\tif (state) {\n\t\tduty_value = pr->throttling.state_count - state;\n\n\t\tduty_value <<= pr->throttling.duty_offset;\n\n\t\t \n\t\tduty_mask = pr->throttling.state_count - 1;\n\n\t\tduty_mask <<= acpi_gbl_FADT.duty_offset;\n\t\tduty_mask = ~duty_mask;\n\t}\n\n\tlocal_irq_disable();\n\n\t \n\tvalue = inl(pr->throttling.address);\n\tif (value & 0x10) {\n\t\tvalue &= 0xFFFFFFEF;\n\t\toutl(value, pr->throttling.address);\n\t}\n\n\t \n\tif (state) {\n\t\tvalue &= duty_mask;\n\t\tvalue |= duty_value;\n\t\toutl(value, pr->throttling.address);\n\n\t\tvalue |= 0x00000010;\n\t\toutl(value, pr->throttling.address);\n\t}\n\n\tpr->throttling.state = state;\n\n\tlocal_irq_enable();\n\n\tacpi_handle_debug(pr->handle,\n\t\t\t  \"Throttling state set to T%d (%d%%)\\n\", state,\n\t\t\t  (pr->throttling.states[state].performance ? pr->\n\t\t\t   throttling.states[state].performance / 10 : 0));\n\n\treturn 0;\n}\n\nstatic int acpi_processor_set_throttling_ptc(struct acpi_processor *pr,\n\t\t\t\t\t     int state, bool force)\n{\n\tint ret;\n\tu64 value;\n\n\tif (!pr)\n\t\treturn -EINVAL;\n\n\tif ((state < 0) || (state > (pr->throttling.state_count - 1)))\n\t\treturn -EINVAL;\n\n\tif (!pr->flags.throttling)\n\t\treturn -ENODEV;\n\n\tif (!force && (state == pr->throttling.state))\n\t\treturn 0;\n\n\tif (state < pr->throttling_platform_limit)\n\t\treturn -EPERM;\n\n\tvalue = 0;\n\tret = acpi_get_throttling_value(pr, state, &value);\n\tif (ret >= 0) {\n\t\tacpi_write_throttling_state(pr, value);\n\t\tpr->throttling.state = state;\n\t}\n\n\treturn 0;\n}\n\nstatic long acpi_processor_throttling_fn(void *data)\n{\n\tstruct acpi_processor_throttling_arg *arg = data;\n\tstruct acpi_processor *pr = arg->pr;\n\n\treturn pr->throttling.acpi_processor_set_throttling(pr,\n\t\t\targ->target_state, arg->force);\n}\n\nstatic int __acpi_processor_set_throttling(struct acpi_processor *pr,\n\t\t\t\t\t   int state, bool force, bool direct)\n{\n\tint ret = 0;\n\tunsigned int i;\n\tstruct acpi_processor *match_pr;\n\tstruct acpi_processor_throttling *p_throttling;\n\tstruct acpi_processor_throttling_arg arg;\n\tstruct throttling_tstate t_state;\n\n\tif (!pr)\n\t\treturn -EINVAL;\n\n\tif (!pr->flags.throttling)\n\t\treturn -ENODEV;\n\n\tif ((state < 0) || (state > (pr->throttling.state_count - 1)))\n\t\treturn -EINVAL;\n\n\tif (cpu_is_offline(pr->id)) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tt_state.target_state = state;\n\tp_throttling = &(pr->throttling);\n\n\t \n\tfor_each_cpu_and(i, cpu_online_mask, p_throttling->shared_cpu_map) {\n\t\tt_state.cpu = i;\n\t\tacpi_processor_throttling_notifier(THROTTLING_PRECHANGE,\n\t\t\t\t\t\t\t&t_state);\n\t}\n\t \n\tif (p_throttling->shared_type == DOMAIN_COORD_TYPE_SW_ANY) {\n\t\targ.pr = pr;\n\t\targ.target_state = state;\n\t\targ.force = force;\n\t\tret = call_on_cpu(pr->id, acpi_processor_throttling_fn, &arg,\n\t\t\t\t  direct);\n\t} else {\n\t\t \n\t\tfor_each_cpu_and(i, cpu_online_mask,\n\t\t    p_throttling->shared_cpu_map) {\n\t\t\tmatch_pr = per_cpu(processors, i);\n\t\t\t \n\t\t\tif (!match_pr) {\n\t\t\t\tacpi_handle_debug(pr->handle,\n\t\t\t\t\t\"Invalid Pointer for CPU %d\\n\", i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (!match_pr->flags.throttling) {\n\t\t\t\tacpi_handle_debug(pr->handle,\n\t\t\t\t\t\"Throttling Control unsupported on CPU %d\\n\", i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\targ.pr = match_pr;\n\t\t\targ.target_state = state;\n\t\t\targ.force = force;\n\t\t\tret = call_on_cpu(pr->id, acpi_processor_throttling_fn,\n\t\t\t\t\t  &arg, direct);\n\t\t}\n\t}\n\t \n\tfor_each_cpu_and(i, cpu_online_mask, p_throttling->shared_cpu_map) {\n\t\tt_state.cpu = i;\n\t\tacpi_processor_throttling_notifier(THROTTLING_POSTCHANGE,\n\t\t\t\t\t\t\t&t_state);\n\t}\n\n\treturn ret;\n}\n\nint acpi_processor_set_throttling(struct acpi_processor *pr, int state,\n\t\t\t\t  bool force)\n{\n\treturn __acpi_processor_set_throttling(pr, state, force, false);\n}\n\nint acpi_processor_get_throttling_info(struct acpi_processor *pr)\n{\n\tint result = 0;\n\tstruct acpi_processor_throttling *pthrottling;\n\n\tacpi_handle_debug(pr->handle,\n\t\t\t  \"pblk_address[0x%08x] duty_offset[%d] duty_width[%d]\\n\",\n\t\t\t  pr->throttling.address,\n\t\t\t  pr->throttling.duty_offset,\n\t\t\t  pr->throttling.duty_width);\n\n\t \n\tif (acpi_processor_get_throttling_control(pr) ||\n\t\tacpi_processor_get_throttling_states(pr) ||\n\t\tacpi_processor_get_platform_limit(pr)) {\n\t\tpr->throttling.acpi_processor_get_throttling =\n\t\t    &acpi_processor_get_throttling_fadt;\n\t\tpr->throttling.acpi_processor_set_throttling =\n\t\t    &acpi_processor_set_throttling_fadt;\n\t\tif (acpi_processor_get_fadt_info(pr))\n\t\t\treturn 0;\n\t} else {\n\t\tpr->throttling.acpi_processor_get_throttling =\n\t\t    &acpi_processor_get_throttling_ptc;\n\t\tpr->throttling.acpi_processor_set_throttling =\n\t\t    &acpi_processor_set_throttling_ptc;\n\t}\n\n\t \n\tif (acpi_processor_get_tsd(pr)) {\n\t\tpthrottling = &pr->throttling;\n\t\tpthrottling->tsd_valid_flag = 0;\n\t\tcpumask_set_cpu(pr->id, pthrottling->shared_cpu_map);\n\t\tpthrottling->shared_type = DOMAIN_COORD_TYPE_SW_ALL;\n\t}\n\n\t \n\tif (errata.piix4.throttle) {\n\t\tacpi_handle_debug(pr->handle,\n\t\t\t\t  \"Throttling not supported on PIIX4 A- or B-step\\n\");\n\t\treturn 0;\n\t}\n\n\tacpi_handle_debug(pr->handle, \"Found %d throttling states\\n\",\n\t\t\t  pr->throttling.state_count);\n\n\tpr->flags.throttling = 1;\n\n\t \n\n\tresult = acpi_processor_get_throttling(pr);\n\tif (result)\n\t\tgoto end;\n\n\tif (pr->throttling.state) {\n\t\tacpi_handle_debug(pr->handle,\n\t\t\t\t  \"Disabling throttling (was T%d)\\n\",\n\t\t\t\t  pr->throttling.state);\n\t\tresult = acpi_processor_set_throttling(pr, 0, false);\n\t\tif (result)\n\t\t\tgoto end;\n\t}\n\nend:\n\tif (result)\n\t\tpr->flags.throttling = 0;\n\n\treturn result;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}