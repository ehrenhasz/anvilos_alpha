{
  "module_name": "acpi_memhotplug.c",
  "hash_id": "716d1f94cae6c45a38680f1567c7fe6ab266bd4368b960f3b1cc9d10e08b2878",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_memhotplug.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/memory.h>\n#include <linux/memory_hotplug.h>\n\n#include \"internal.h\"\n\n#define ACPI_MEMORY_DEVICE_CLASS\t\t\"memory\"\n#define ACPI_MEMORY_DEVICE_HID\t\t\t\"PNP0C80\"\n#define ACPI_MEMORY_DEVICE_NAME\t\t\t\"Hotplug Mem Device\"\n\nstatic const struct acpi_device_id memory_device_ids[] = {\n\t{ACPI_MEMORY_DEVICE_HID, 0},\n\t{\"\", 0},\n};\n\n#ifdef CONFIG_ACPI_HOTPLUG_MEMORY\n\nstatic int acpi_memory_device_add(struct acpi_device *device,\n\t\t\t\t  const struct acpi_device_id *not_used);\nstatic void acpi_memory_device_remove(struct acpi_device *device);\n\nstatic struct acpi_scan_handler memory_device_handler = {\n\t.ids = memory_device_ids,\n\t.attach = acpi_memory_device_add,\n\t.detach = acpi_memory_device_remove,\n\t.hotplug = {\n\t\t.enabled = true,\n\t},\n};\n\nstruct acpi_memory_info {\n\tstruct list_head list;\n\tu64 start_addr;\t\t \n\tu64 length;\t\t \n\tunsigned short caching;\t \n\tunsigned short write_protect;\t \n\tunsigned int enabled:1;\n};\n\nstruct acpi_memory_device {\n\tstruct acpi_device *device;\n\tstruct list_head res_list;\n\tint mgid;\n};\n\nstatic acpi_status\nacpi_memory_get_resource(struct acpi_resource *resource, void *context)\n{\n\tstruct acpi_memory_device *mem_device = context;\n\tstruct acpi_resource_address64 address64;\n\tstruct acpi_memory_info *info, *new;\n\tacpi_status status;\n\n\tstatus = acpi_resource_to_address64(resource, &address64);\n\tif (ACPI_FAILURE(status) ||\n\t    (address64.resource_type != ACPI_MEMORY_RANGE))\n\t\treturn AE_OK;\n\n\tlist_for_each_entry(info, &mem_device->res_list, list) {\n\t\t \n\t\tif ((info->caching == address64.info.mem.caching) &&\n\t\t    (info->write_protect == address64.info.mem.write_protect) &&\n\t\t    (info->start_addr + info->length == address64.address.minimum)) {\n\t\t\tinfo->length += address64.address.address_length;\n\t\t\treturn AE_OK;\n\t\t}\n\t}\n\n\tnew = kzalloc(sizeof(struct acpi_memory_info), GFP_KERNEL);\n\tif (!new)\n\t\treturn AE_ERROR;\n\n\tINIT_LIST_HEAD(&new->list);\n\tnew->caching = address64.info.mem.caching;\n\tnew->write_protect = address64.info.mem.write_protect;\n\tnew->start_addr = address64.address.minimum;\n\tnew->length = address64.address.address_length;\n\tlist_add_tail(&new->list, &mem_device->res_list);\n\n\treturn AE_OK;\n}\n\nstatic void\nacpi_memory_free_device_resources(struct acpi_memory_device *mem_device)\n{\n\tstruct acpi_memory_info *info, *n;\n\n\tlist_for_each_entry_safe(info, n, &mem_device->res_list, list)\n\t\tkfree(info);\n\tINIT_LIST_HEAD(&mem_device->res_list);\n}\n\nstatic int\nacpi_memory_get_device_resources(struct acpi_memory_device *mem_device)\n{\n\tacpi_status status;\n\n\tif (!list_empty(&mem_device->res_list))\n\t\treturn 0;\n\n\tstatus = acpi_walk_resources(mem_device->device->handle, METHOD_NAME__CRS,\n\t\t\t\t     acpi_memory_get_resource, mem_device);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_memory_free_device_resources(mem_device);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int acpi_memory_check_device(struct acpi_memory_device *mem_device)\n{\n\tunsigned long long current_status;\n\n\t \n\tif (ACPI_FAILURE(acpi_evaluate_integer(mem_device->device->handle,\n\t\t\t\t\t       METHOD_NAME__STA, NULL,\n\t\t\t\t\t       &current_status)))\n\t\treturn -ENODEV;\n\t \n\tif (!((current_status & ACPI_STA_DEVICE_PRESENT)\n\t      && (current_status & ACPI_STA_DEVICE_ENABLED)\n\t      && (current_status & ACPI_STA_DEVICE_FUNCTIONING)))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int acpi_bind_memblk(struct memory_block *mem, void *arg)\n{\n\treturn acpi_bind_one(&mem->dev, arg);\n}\n\nstatic int acpi_bind_memory_blocks(struct acpi_memory_info *info,\n\t\t\t\t   struct acpi_device *adev)\n{\n\treturn walk_memory_blocks(info->start_addr, info->length, adev,\n\t\t\t\t  acpi_bind_memblk);\n}\n\nstatic int acpi_unbind_memblk(struct memory_block *mem, void *arg)\n{\n\tacpi_unbind_one(&mem->dev);\n\treturn 0;\n}\n\nstatic void acpi_unbind_memory_blocks(struct acpi_memory_info *info)\n{\n\twalk_memory_blocks(info->start_addr, info->length, NULL,\n\t\t\t   acpi_unbind_memblk);\n}\n\nstatic int acpi_memory_enable_device(struct acpi_memory_device *mem_device)\n{\n\tacpi_handle handle = mem_device->device->handle;\n\tmhp_t mhp_flags = MHP_NID_IS_MGID;\n\tint result, num_enabled = 0;\n\tstruct acpi_memory_info *info;\n\tu64 total_length = 0;\n\tint node, mgid;\n\n\tnode = acpi_get_node(handle);\n\n\tlist_for_each_entry(info, &mem_device->res_list, list) {\n\t\tif (!info->length)\n\t\t\tcontinue;\n\t\t \n\t\tif (node < 0)\n\t\t\tnode = memory_add_physaddr_to_nid(info->start_addr);\n\t\ttotal_length += info->length;\n\t}\n\n\tif (!total_length) {\n\t\tdev_err(&mem_device->device->dev, \"device is empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmgid = memory_group_register_static(node, PFN_UP(total_length));\n\tif (mgid < 0)\n\t\treturn mgid;\n\tmem_device->mgid = mgid;\n\n\t \n\tlist_for_each_entry(info, &mem_device->res_list, list) {\n\t\t \n\t\tif (!info->length)\n\t\t\tcontinue;\n\n\t\tmhp_flags |= MHP_MEMMAP_ON_MEMORY;\n\t\tresult = __add_memory(mgid, info->start_addr, info->length,\n\t\t\t\t      mhp_flags);\n\n\t\t \n\t\tif (result && result != -EEXIST)\n\t\t\tcontinue;\n\n\t\tresult = acpi_bind_memory_blocks(info, mem_device->device);\n\t\tif (result) {\n\t\t\tacpi_unbind_memory_blocks(info);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tinfo->enabled = 1;\n\n\t\t \n\t\tnum_enabled++;\n\t}\n\tif (!num_enabled) {\n\t\tdev_err(&mem_device->device->dev, \"add_memory failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\treturn 0;\n}\n\nstatic void acpi_memory_remove_memory(struct acpi_memory_device *mem_device)\n{\n\tstruct acpi_memory_info *info, *n;\n\n\tlist_for_each_entry_safe(info, n, &mem_device->res_list, list) {\n\t\tif (!info->enabled)\n\t\t\tcontinue;\n\n\t\tacpi_unbind_memory_blocks(info);\n\t\t__remove_memory(info->start_addr, info->length);\n\t\tlist_del(&info->list);\n\t\tkfree(info);\n\t}\n}\n\nstatic void acpi_memory_device_free(struct acpi_memory_device *mem_device)\n{\n\tif (!mem_device)\n\t\treturn;\n\n\t \n\tif (mem_device->mgid >= 0)\n\t\tmemory_group_unregister(mem_device->mgid);\n\n\tacpi_memory_free_device_resources(mem_device);\n\tmem_device->device->driver_data = NULL;\n\tkfree(mem_device);\n}\n\nstatic int acpi_memory_device_add(struct acpi_device *device,\n\t\t\t\t  const struct acpi_device_id *not_used)\n{\n\tstruct acpi_memory_device *mem_device;\n\tint result;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tmem_device = kzalloc(sizeof(struct acpi_memory_device), GFP_KERNEL);\n\tif (!mem_device)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&mem_device->res_list);\n\tmem_device->device = device;\n\tmem_device->mgid = -1;\n\tsprintf(acpi_device_name(device), \"%s\", ACPI_MEMORY_DEVICE_NAME);\n\tsprintf(acpi_device_class(device), \"%s\", ACPI_MEMORY_DEVICE_CLASS);\n\tdevice->driver_data = mem_device;\n\n\t \n\tresult = acpi_memory_get_device_resources(mem_device);\n\tif (result) {\n\t\tdevice->driver_data = NULL;\n\t\tkfree(mem_device);\n\t\treturn result;\n\t}\n\n\tresult = acpi_memory_check_device(mem_device);\n\tif (result) {\n\t\tacpi_memory_device_free(mem_device);\n\t\treturn 0;\n\t}\n\n\tresult = acpi_memory_enable_device(mem_device);\n\tif (result) {\n\t\tdev_err(&device->dev, \"acpi_memory_enable_device() error\\n\");\n\t\tacpi_memory_device_free(mem_device);\n\t\treturn result;\n\t}\n\n\tdev_dbg(&device->dev, \"Memory device configured by ACPI\\n\");\n\treturn 1;\n}\n\nstatic void acpi_memory_device_remove(struct acpi_device *device)\n{\n\tstruct acpi_memory_device *mem_device;\n\n\tif (!device || !acpi_driver_data(device))\n\t\treturn;\n\n\tmem_device = acpi_driver_data(device);\n\tacpi_memory_remove_memory(mem_device);\n\tacpi_memory_device_free(mem_device);\n}\n\nstatic bool __initdata acpi_no_memhotplug;\n\nvoid __init acpi_memory_hotplug_init(void)\n{\n\tif (acpi_no_memhotplug) {\n\t\tmemory_device_handler.attach = NULL;\n\t\tacpi_scan_add_handler(&memory_device_handler);\n\t\treturn;\n\t}\n\tacpi_scan_add_handler_with_hotplug(&memory_device_handler, \"memory\");\n}\n\nstatic int __init disable_acpi_memory_hotplug(char *str)\n{\n\tacpi_no_memhotplug = true;\n\treturn 1;\n}\n__setup(\"acpi_no_memhotplug\", disable_acpi_memory_hotplug);\n\n#else\n\nstatic struct acpi_scan_handler memory_device_handler = {\n\t.ids = memory_device_ids,\n};\n\nvoid __init acpi_memory_hotplug_init(void)\n{\n\tacpi_scan_add_handler(&memory_device_handler);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}