{
  "module_name": "nsxfeval.c",
  "hash_id": "e22b2b9d3768c5601367848f25028dd902480a24587c047edbc23e2e39687f87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/nsxfeval.c",
  "human_readable_source": "\n \n\n#define EXPORT_ACPI_INTERFACES\n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"acinterp.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\nACPI_MODULE_NAME(\"nsxfeval\")\n\n \nstatic void acpi_ns_resolve_references(struct acpi_evaluate_info *info);\n\n \n\nacpi_status\nacpi_evaluate_object_typed(acpi_handle handle,\n\t\t\t   acpi_string pathname,\n\t\t\t   struct acpi_object_list *external_params,\n\t\t\t   struct acpi_buffer *return_buffer,\n\t\t\t   acpi_object_type return_type)\n{\n\tacpi_status status;\n\tu8 free_buffer_on_error = FALSE;\n\tacpi_handle target_handle;\n\tchar *full_pathname;\n\n\tACPI_FUNCTION_TRACE(acpi_evaluate_object_typed);\n\n\t \n\n\tif (!return_buffer) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tif (return_buffer->length == ACPI_ALLOCATE_BUFFER) {\n\t\tfree_buffer_on_error = TRUE;\n\t}\n\n\t \n\n\ttarget_handle = handle;\n\tif (pathname) {\n\t\tstatus = acpi_get_handle(handle, pathname, &target_handle);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t}\n\n\tfull_pathname = acpi_ns_get_external_pathname(target_handle);\n\tif (!full_pathname) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tstatus = acpi_evaluate_object(target_handle, NULL, external_params,\n\t\t\t\t      return_buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\t \n\n\tif (return_type == ACPI_TYPE_ANY) {\n\t\tgoto exit;\n\t}\n\n\tif (return_buffer->length == 0) {\n\n\t\t \n\n\t\tACPI_ERROR((AE_INFO, \"%s did not return any object\",\n\t\t\t    full_pathname));\n\t\tstatus = AE_NULL_OBJECT;\n\t\tgoto exit;\n\t}\n\n\t \n\n\tif (((union acpi_object *)return_buffer->pointer)->type == return_type) {\n\t\tgoto exit;\n\t}\n\n\t \n\n\tACPI_ERROR((AE_INFO,\n\t\t    \"Incorrect return type from %s - received [%s], requested [%s]\",\n\t\t    full_pathname,\n\t\t    acpi_ut_get_type_name(((union acpi_object *)return_buffer->\n\t\t\t\t\t   pointer)->type),\n\t\t    acpi_ut_get_type_name(return_type)));\n\n\tif (free_buffer_on_error) {\n\t\t \n\t\tacpi_os_free(return_buffer->pointer);\n\t\treturn_buffer->pointer = NULL;\n\t}\n\n\treturn_buffer->length = 0;\n\tstatus = AE_TYPE;\n\nexit:\n\tACPI_FREE(full_pathname);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_evaluate_object_typed)\n\n \nacpi_status\nacpi_evaluate_object(acpi_handle handle,\n\t\t     acpi_string pathname,\n\t\t     struct acpi_object_list *external_params,\n\t\t     struct acpi_buffer *return_buffer)\n{\n\tacpi_status status;\n\tstruct acpi_evaluate_info *info;\n\tacpi_size buffer_space_needed;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(acpi_evaluate_object);\n\n\t \n\n\tinfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\n\tif (!info) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tinfo->prefix_node = acpi_ns_validate_handle(handle);\n\tif (!info->prefix_node) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif ((pathname) && (ACPI_IS_ROOT_PREFIX(pathname[0]))) {\n\n\t\t \n\n\t\tinfo->prefix_node = NULL;\n\t} else if (!handle) {\n\t\t \n\t\tif (!pathname) {\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_INFO,\n\t\t\t\t\t  \"Both Handle and Pathname are NULL\"));\n\t\t} else {\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_INFO,\n\t\t\t\t\t  \"Null Handle with relative pathname [%s]\",\n\t\t\t\t\t  pathname));\n\t\t}\n\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto cleanup;\n\t}\n\n\tinfo->relative_pathname = pathname;\n\n\t \n\tif (external_params && external_params->count) {\n\t\tinfo->param_count = (u16)external_params->count;\n\n\t\t \n\n\t\tif (info->param_count > ACPI_METHOD_NUM_ARGS) {\n\t\t\tACPI_WARN_PREDEFINED((AE_INFO, pathname,\n\t\t\t\t\t      ACPI_WARN_ALWAYS,\n\t\t\t\t\t      \"Excess arguments (%u) - using only %u\",\n\t\t\t\t\t      info->param_count,\n\t\t\t\t\t      ACPI_METHOD_NUM_ARGS));\n\n\t\t\tinfo->param_count = ACPI_METHOD_NUM_ARGS;\n\t\t}\n\n\t\t \n\t\tinfo->parameters = ACPI_ALLOCATE_ZEROED(((acpi_size)info->\n\t\t\t\t\t\t\t param_count +\n\t\t\t\t\t\t\t 1) * sizeof(void *));\n\t\tif (!info->parameters) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\n\t\tfor (i = 0; i < info->param_count; i++) {\n\t\t\tstatus =\n\t\t\t    acpi_ut_copy_eobject_to_iobject(&external_params->\n\t\t\t\t\t\t\t    pointer[i],\n\t\t\t\t\t\t\t    &info->\n\t\t\t\t\t\t\t    parameters[i]);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tinfo->parameters[info->param_count] = NULL;\n\t}\n\n#ifdef _FUTURE_FEATURE\n\n\t \n\tswitch (acpi_ns_get_type(info->node)) {\n\tcase ACPI_TYPE_METHOD:\n\n\t\t \n\n\t\tif (info->obj_desc->method.param_count > info->param_count) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Insufficient arguments (%u) - %u are required\",\n\t\t\t\t    info->param_count,\n\t\t\t\t    info->obj_desc->method.param_count));\n\n\t\t\tstatus = AE_MISSING_ARGUMENTS;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\telse if (info->obj_desc->method.param_count < info->param_count) {\n\t\t\tACPI_WARNING((AE_INFO,\n\t\t\t\t      \"Excess arguments (%u) - only %u are required\",\n\t\t\t\t      info->param_count,\n\t\t\t\t      info->obj_desc->method.param_count));\n\n\t\t\t \n\n\t\t\tinfo->param_count = info->obj_desc->method.param_count;\n\t\t}\n\n\t\t \n\t\tif (info->param_count) {\n\t\t\t \n\t\t\tinfo->parameters = ACPI_ALLOCATE_ZEROED(((acpi_size)\n\t\t\t\t\t\t\t\t info->\n\t\t\t\t\t\t\t\t param_count +\n\t\t\t\t\t\t\t\t 1) *\n\t\t\t\t\t\t\t\tsizeof(void *));\n\t\t\tif (!info->parameters) {\n\t\t\t\tstatus = AE_NO_MEMORY;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tfor (i = 0; i < info->param_count; i++) {\n\t\t\t\tstatus =\n\t\t\t\t    acpi_ut_copy_eobject_to_iobject\n\t\t\t\t    (&external_params->pointer[i],\n\t\t\t\t     &info->parameters[i]);\n\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinfo->parameters[info->param_count] = NULL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\t \n\n\t\tif (info->param_count) {\n\t\t\tACPI_WARNING((AE_INFO,\n\t\t\t\t      \"%u arguments were passed to a non-method ACPI object\",\n\t\t\t\t      info->param_count));\n\t\t}\n\t\tbreak;\n\t}\n\n#endif\n\n\t \n\n\tstatus = acpi_ns_evaluate(info);\n\n\t \n\tif (!return_buffer) {\n\t\tgoto cleanup_return_object;\n\t}\n\n\tif (!info->return_object) {\n\t\treturn_buffer->length = 0;\n\t\tgoto cleanup;\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(info->return_object) ==\n\t    ACPI_DESC_TYPE_NAMED) {\n\t\t \n\t\tstatus = AE_TYPE;\n\t\tinfo->return_object = NULL;\t \n\t\treturn_buffer->length = 0;\n\t}\n\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto cleanup_return_object;\n\t}\n\n\t \n\n\tacpi_ns_resolve_references(info);\n\n\t \n\n\tstatus = acpi_ut_get_object_size(info->return_object,\n\t\t\t\t\t &buffer_space_needed);\n\tif (ACPI_SUCCESS(status)) {\n\n\t\t \n\n\t\tstatus = acpi_ut_initialize_buffer(return_buffer,\n\t\t\t\t\t\t   buffer_space_needed);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\t \n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_INFO,\n\t\t\t\t\t  \"Needed buffer size %X, %s\\n\",\n\t\t\t\t\t  (u32)buffer_space_needed,\n\t\t\t\t\t  acpi_format_exception(status)));\n\t\t} else {\n\t\t\t \n\n\t\t\tstatus =\n\t\t\t    acpi_ut_copy_iobject_to_eobject(info->return_object,\n\t\t\t\t\t\t\t    return_buffer);\n\t\t}\n\t}\n\ncleanup_return_object:\n\n\tif (info->return_object) {\n\t\t \n\t\tacpi_ex_enter_interpreter();\n\n\t\t \n\n\t\tacpi_ut_remove_reference(info->return_object);\n\t\tacpi_ex_exit_interpreter();\n\t}\n\ncleanup:\n\n\t \n\n\tif (info->parameters) {\n\n\t\t \n\n\t\tacpi_ut_delete_internal_object_list(info->parameters);\n\t}\n\n\tACPI_FREE(info);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_evaluate_object)\n\n \nstatic void acpi_ns_resolve_references(struct acpi_evaluate_info *info)\n{\n\tunion acpi_operand_object *obj_desc = NULL;\n\tstruct acpi_namespace_node *node;\n\n\t \n\n\tif ((info->return_object)->common.type != ACPI_TYPE_LOCAL_REFERENCE) {\n\t\treturn;\n\t}\n\n\t \n\tswitch (info->return_object->reference.class) {\n\tcase ACPI_REFCLASS_INDEX:\n\n\t\tobj_desc = *(info->return_object->reference.where);\n\t\tbreak;\n\n\tcase ACPI_REFCLASS_REFOF:\n\n\t\tnode = info->return_object->reference.object;\n\t\tif (node) {\n\t\t\tobj_desc = node->object;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\treturn;\n\t}\n\n\t \n\n\tif (obj_desc) {\n\t\tacpi_ut_add_reference(obj_desc);\n\t\tacpi_ut_remove_reference(info->return_object);\n\t\tinfo->return_object = obj_desc;\n\t}\n\n\treturn;\n}\n\n \n\nacpi_status\nacpi_walk_namespace(acpi_object_type type,\n\t\t    acpi_handle start_object,\n\t\t    u32 max_depth,\n\t\t    acpi_walk_callback descending_callback,\n\t\t    acpi_walk_callback ascending_callback,\n\t\t    void *context, void **return_value)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_walk_namespace);\n\n\t \n\n\tif ((type > ACPI_TYPE_LOCAL_MAX) ||\n\t    (!max_depth) || (!descending_callback && !ascending_callback)) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\tstatus = acpi_ut_acquire_read_lock(&acpi_gbl_namespace_rw_lock);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tif (!acpi_ns_validate_handle(start_object)) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit2;\n\t}\n\n\tstatus = acpi_ns_walk_namespace(type, start_object, max_depth,\n\t\t\t\t\tACPI_NS_WALK_UNLOCK,\n\t\t\t\t\tdescending_callback, ascending_callback,\n\t\t\t\t\tcontext, return_value);\n\nunlock_and_exit2:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\nunlock_and_exit:\n\t(void)acpi_ut_release_read_lock(&acpi_gbl_namespace_rw_lock);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_walk_namespace)\n\n \nstatic acpi_status\nacpi_ns_get_device_callback(acpi_handle obj_handle,\n\t\t\t    u32 nesting_level,\n\t\t\t    void *context, void **return_value)\n{\n\tstruct acpi_get_devices_info *info = context;\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\tu32 flags;\n\tstruct acpi_pnp_device_id *hid;\n\tstruct acpi_pnp_device_id_list *cid;\n\tu32 i;\n\tu8 found;\n\tint no_match;\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tnode = acpi_ns_validate_handle(obj_handle);\n\tstatus = acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tif (!node) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\tif (info->hid != NULL) {\n\t\tstatus = acpi_ut_execute_HID(node, &hid);\n\t\tif (status == AE_NOT_FOUND) {\n\t\t\treturn (AE_OK);\n\t\t} else if (ACPI_FAILURE(status)) {\n\t\t\treturn (AE_CTRL_DEPTH);\n\t\t}\n\n\t\tno_match = strcmp(hid->string, info->hid);\n\t\tACPI_FREE(hid);\n\n\t\tif (no_match) {\n\t\t\t \n\t\t\tstatus = acpi_ut_execute_CID(node, &cid);\n\t\t\tif (status == AE_NOT_FOUND) {\n\t\t\t\treturn (AE_OK);\n\t\t\t} else if (ACPI_FAILURE(status)) {\n\t\t\t\treturn (AE_CTRL_DEPTH);\n\t\t\t}\n\n\t\t\t \n\n\t\t\tfound = FALSE;\n\t\t\tfor (i = 0; i < cid->count; i++) {\n\t\t\t\tif (strcmp(cid->ids[i].string, info->hid) == 0) {\n\n\t\t\t\t\t \n\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tACPI_FREE(cid);\n\t\t\tif (!found) {\n\t\t\t\treturn (AE_OK);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tstatus = acpi_ut_execute_STA(node, &flags);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (AE_CTRL_DEPTH);\n\t}\n\n\tif (!(flags & ACPI_STA_DEVICE_PRESENT) &&\n\t    !(flags & ACPI_STA_DEVICE_FUNCTIONING)) {\n\t\t \n\t\treturn (AE_CTRL_DEPTH);\n\t}\n\n\t \n\n\tstatus = info->user_function(obj_handle, nesting_level,\n\t\t\t\t     info->context, return_value);\n\treturn (status);\n}\n\n \n\nacpi_status\nacpi_get_devices(const char *HID,\n\t\t acpi_walk_callback user_function,\n\t\t void *context, void **return_value)\n{\n\tacpi_status status;\n\tstruct acpi_get_devices_info info;\n\n\tACPI_FUNCTION_TRACE(acpi_get_devices);\n\n\t \n\n\tif (!user_function) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\tinfo.hid = HID;\n\tinfo.context = context;\n\tinfo.user_function = user_function;\n\n\t \n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\n\t\t\t\t\tACPI_UINT32_MAX, ACPI_NS_WALK_UNLOCK,\n\t\t\t\t\tacpi_ns_get_device_callback, NULL,\n\t\t\t\t\t&info, return_value);\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_devices)\n\n \nacpi_status\nacpi_attach_data(acpi_handle obj_handle,\n\t\t acpi_object_handler handler, void *data)\n{\n\tstruct acpi_namespace_node *node;\n\tacpi_status status;\n\n\t \n\n\tif (!obj_handle || !handler || !data) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\tnode = acpi_ns_validate_handle(obj_handle);\n\tif (!node) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\tstatus = acpi_ns_attach_data(node, handler, data);\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn (status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_attach_data)\n\n \nacpi_status\nacpi_detach_data(acpi_handle obj_handle, acpi_object_handler handler)\n{\n\tstruct acpi_namespace_node *node;\n\tacpi_status status;\n\n\t \n\n\tif (!obj_handle || !handler) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\tnode = acpi_ns_validate_handle(obj_handle);\n\tif (!node) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\tstatus = acpi_ns_detach_data(node, handler);\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn (status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_detach_data)\n\n \nacpi_status\nacpi_get_data_full(acpi_handle obj_handle, acpi_object_handler handler,\n\t\t   void **data, void (*callback)(void *))\n{\n\tstruct acpi_namespace_node *node;\n\tacpi_status status;\n\n\t \n\n\tif (!obj_handle || !handler || !data) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\tnode = acpi_ns_validate_handle(obj_handle);\n\tif (!node) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\tstatus = acpi_ns_get_attached_data(node, handler, data);\n\tif (ACPI_SUCCESS(status) && callback) {\n\t\tcallback(*data);\n\t}\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn (status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_data_full)\n\n \nacpi_status\nacpi_get_data(acpi_handle obj_handle, acpi_object_handler handler, void **data)\n{\n\treturn acpi_get_data_full(obj_handle, handler, data, NULL);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_data)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}