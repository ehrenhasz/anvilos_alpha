{
  "module_name": "dbinput.c",
  "hash_id": "ba5b6dcd7cb5b24ac740c8a56049348146a1da11eb45c3e5d4b871ac5feae33a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/dbinput.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acdebug.h\"\n\n#ifdef ACPI_APPLICATION\n#include \"acapps.h\"\n#endif\n\n#define _COMPONENT          ACPI_CA_DEBUGGER\nACPI_MODULE_NAME(\"dbinput\")\n\n \nstatic u32 acpi_db_get_line(char *input_buffer);\n\nstatic u32 acpi_db_match_command(char *user_command);\n\nstatic void acpi_db_display_command_info(const char *command, u8 display_all);\n\nstatic void acpi_db_display_help(char *command);\n\nstatic u8\nacpi_db_match_command_help(const char *command,\n\t\t\t   const struct acpi_db_command_help *help);\n\n \nenum acpi_ex_debugger_commands {\n\tCMD_NOT_FOUND = 0,\n\tCMD_NULL,\n\tCMD_ALL,\n\tCMD_ALLOCATIONS,\n\tCMD_ARGS,\n\tCMD_ARGUMENTS,\n\tCMD_BREAKPOINT,\n\tCMD_BUSINFO,\n\tCMD_CALL,\n\tCMD_DEBUG,\n\tCMD_DISASSEMBLE,\n\tCMD_DISASM,\n\tCMD_DUMP,\n\tCMD_EVALUATE,\n\tCMD_EXECUTE,\n\tCMD_EXIT,\n\tCMD_FIELDS,\n\tCMD_FIND,\n\tCMD_GO,\n\tCMD_HANDLERS,\n\tCMD_HELP,\n\tCMD_HELP2,\n\tCMD_HISTORY,\n\tCMD_HISTORY_EXE,\n\tCMD_HISTORY_LAST,\n\tCMD_INFORMATION,\n\tCMD_INTEGRITY,\n\tCMD_INTO,\n\tCMD_LEVEL,\n\tCMD_LIST,\n\tCMD_LOCALS,\n\tCMD_LOCKS,\n\tCMD_METHODS,\n\tCMD_NAMESPACE,\n\tCMD_NOTIFY,\n\tCMD_OBJECTS,\n\tCMD_OSI,\n\tCMD_OWNER,\n\tCMD_PATHS,\n\tCMD_PREDEFINED,\n\tCMD_PREFIX,\n\tCMD_QUIT,\n\tCMD_REFERENCES,\n\tCMD_RESOURCES,\n\tCMD_RESULTS,\n\tCMD_SET,\n\tCMD_STATS,\n\tCMD_STOP,\n\tCMD_TABLES,\n\tCMD_TEMPLATE,\n\tCMD_TRACE,\n\tCMD_TREE,\n\tCMD_TYPE,\n#ifdef ACPI_APPLICATION\n\tCMD_ENABLEACPI,\n\tCMD_EVENT,\n\tCMD_GPE,\n\tCMD_GPES,\n\tCMD_SCI,\n\tCMD_SLEEP,\n\n\tCMD_CLOSE,\n\tCMD_LOAD,\n\tCMD_OPEN,\n\tCMD_UNLOAD,\n\n\tCMD_TERMINATE,\n\tCMD_BACKGROUND,\n\tCMD_THREADS,\n\n\tCMD_TEST,\n\tCMD_INTERRUPT,\n#endif\n};\n\n#define CMD_FIRST_VALID     2\n\n \n\nstatic const struct acpi_db_command_info acpi_gbl_db_commands[] = {\n\t{\"<NOT FOUND>\", 0},\n\t{\"<NULL>\", 0},\n\t{\"ALL\", 1},\n\t{\"ALLOCATIONS\", 0},\n\t{\"ARGS\", 0},\n\t{\"ARGUMENTS\", 0},\n\t{\"BREAKPOINT\", 1},\n\t{\"BUSINFO\", 0},\n\t{\"CALL\", 0},\n\t{\"DEBUG\", 1},\n\t{\"DISASSEMBLE\", 1},\n\t{\"DISASM\", 1},\n\t{\"DUMP\", 1},\n\t{\"EVALUATE\", 1},\n\t{\"EXECUTE\", 1},\n\t{\"EXIT\", 0},\n\t{\"FIELDS\", 1},\n\t{\"FIND\", 1},\n\t{\"GO\", 0},\n\t{\"HANDLERS\", 0},\n\t{\"HELP\", 0},\n\t{\"?\", 0},\n\t{\"HISTORY\", 0},\n\t{\"!\", 1},\n\t{\"!!\", 0},\n\t{\"INFORMATION\", 0},\n\t{\"INTEGRITY\", 0},\n\t{\"INTO\", 0},\n\t{\"LEVEL\", 0},\n\t{\"LIST\", 0},\n\t{\"LOCALS\", 0},\n\t{\"LOCKS\", 0},\n\t{\"METHODS\", 0},\n\t{\"NAMESPACE\", 0},\n\t{\"NOTIFY\", 2},\n\t{\"OBJECTS\", 0},\n\t{\"OSI\", 0},\n\t{\"OWNER\", 1},\n\t{\"PATHS\", 0},\n\t{\"PREDEFINED\", 0},\n\t{\"PREFIX\", 0},\n\t{\"QUIT\", 0},\n\t{\"REFERENCES\", 1},\n\t{\"RESOURCES\", 0},\n\t{\"RESULTS\", 0},\n\t{\"SET\", 3},\n\t{\"STATS\", 1},\n\t{\"STOP\", 0},\n\t{\"TABLES\", 0},\n\t{\"TEMPLATE\", 1},\n\t{\"TRACE\", 1},\n\t{\"TREE\", 0},\n\t{\"TYPE\", 1},\n#ifdef ACPI_APPLICATION\n\t{\"ENABLEACPI\", 0},\n\t{\"EVENT\", 1},\n\t{\"GPE\", 1},\n\t{\"GPES\", 0},\n\t{\"SCI\", 0},\n\t{\"SLEEP\", 0},\n\n\t{\"CLOSE\", 0},\n\t{\"LOAD\", 1},\n\t{\"OPEN\", 1},\n\t{\"UNLOAD\", 1},\n\n\t{\"TERMINATE\", 0},\n\t{\"BACKGROUND\", 1},\n\t{\"THREADS\", 3},\n\n\t{\"TEST\", 1},\n\t{\"INTERRUPT\", 1},\n#endif\n\t{NULL, 0}\n};\n\n \nstatic const struct acpi_db_command_help acpi_gbl_db_command_help[] = {\n\t{0, \"\\nNamespace Access:\", \"\\n\"},\n\t{1, \"  Businfo\", \"Display system bus info\\n\"},\n\t{1, \"  Disassemble <Method>\", \"Disassemble a control method\\n\"},\n\t{1, \"  Find <AcpiName> (? is wildcard)\",\n\t \"Find ACPI name(s) with wildcards\\n\"},\n\t{1, \"  Integrity\", \"Validate namespace integrity\\n\"},\n\t{1, \"  Methods\", \"Display list of loaded control methods\\n\"},\n\t{1, \"  Fields <AddressSpaceId>\",\n\t \"Display list of loaded field units by space ID\\n\"},\n\t{1, \"  Namespace [Object] [Depth]\",\n\t \"Display loaded namespace tree/subtree\\n\"},\n\t{1, \"  Notify <Object> <Value>\", \"Send a notification on Object\\n\"},\n\t{1, \"  Objects [ObjectType]\",\n\t \"Display summary of all objects or just given type\\n\"},\n\t{1, \"  Owner <OwnerId> [Depth]\",\n\t \"Display loaded namespace by object owner\\n\"},\n\t{1, \"  Paths\", \"Display full pathnames of namespace objects\\n\"},\n\t{1, \"  Predefined\", \"Check all predefined names\\n\"},\n\t{1, \"  Prefix [<Namepath>]\", \"Set or Get current execution prefix\\n\"},\n\t{1, \"  References <Addr>\", \"Find all references to object at addr\\n\"},\n\t{1, \"  Resources [DeviceName]\",\n\t \"Display Device resources (no arg = all devices)\\n\"},\n\t{1, \"  Set N <NamedObject> <Value>\", \"Set value for named integer\\n\"},\n\t{1, \"  Template <Object>\", \"Format/dump a Buffer/ResourceTemplate\\n\"},\n\t{1, \"  Type <Object>\", \"Display object type\\n\"},\n\n\t{0, \"\\nControl Method Execution:\", \"\\n\"},\n\t{1, \"  All <NameSeg>\", \"Evaluate all objects named NameSeg\\n\"},\n\t{1, \"  Evaluate <Namepath> [Arguments]\",\n\t \"Evaluate object or control method\\n\"},\n\t{1, \"  Execute <Namepath> [Arguments]\", \"Synonym for Evaluate\\n\"},\n#ifdef ACPI_APPLICATION\n\t{1, \"  Background <Namepath> [Arguments]\",\n\t \"Evaluate object/method in a separate thread\\n\"},\n\t{1, \"  Thread <Threads><Loops><NamePath>\",\n\t \"Spawn threads to execute method(s)\\n\"},\n#endif\n\t{1, \"  Debug <Namepath> [Arguments]\", \"Single-Step a control method\\n\"},\n\t{7, \"  [Arguments] formats:\", \"Control method argument formats\\n\"},\n\t{1, \"     Hex Integer\", \"Integer\\n\"},\n\t{1, \"     \\\"Ascii String\\\"\", \"String\\n\"},\n\t{1, \"     (Hex Byte List)\", \"Buffer\\n\"},\n\t{1, \"         (01 42 7A BF)\", \"Buffer example (4 bytes)\\n\"},\n\t{1, \"     [Package Element List]\", \"Package\\n\"},\n\t{1, \"         [0x01 0x1234 \\\"string\\\"]\",\n\t \"Package example (3 elements)\\n\"},\n\n\t{0, \"\\nMiscellaneous:\", \"\\n\"},\n\t{1, \"  Allocations\", \"Display list of current memory allocations\\n\"},\n\t{2, \"  Dump <Address>|<Namepath>\", \"\\n\"},\n\t{0, \"       [Byte|Word|Dword|Qword]\",\n\t \"Display ACPI objects or memory\\n\"},\n\t{1, \"  Handlers\", \"Info about global handlers\\n\"},\n\t{1, \"  Help [Command]\", \"This help screen or individual command\\n\"},\n\t{1, \"  History\", \"Display command history buffer\\n\"},\n\t{1, \"  Level <DebugLevel>] [console]\",\n\t \"Get/Set debug level for file or console\\n\"},\n\t{1, \"  Locks\", \"Current status of internal mutexes\\n\"},\n\t{1, \"  Osi [Install|Remove <name>]\",\n\t \"Display or modify global _OSI list\\n\"},\n\t{1, \"  Quit or Exit\", \"Exit this command\\n\"},\n\t{8, \"  Stats <SubCommand>\",\n\t \"Display namespace and memory statistics\\n\"},\n\t{1, \"     Allocations\", \"Display list of current memory allocations\\n\"},\n\t{1, \"     Memory\", \"Dump internal memory lists\\n\"},\n\t{1, \"     Misc\", \"Namespace search and mutex stats\\n\"},\n\t{1, \"     Objects\", \"Summary of namespace objects\\n\"},\n\t{1, \"     Sizes\", \"Sizes for each of the internal objects\\n\"},\n\t{1, \"     Stack\", \"Display CPU stack usage\\n\"},\n\t{1, \"     Tables\", \"Info about current ACPI table(s)\\n\"},\n\t{1, \"  Tables\", \"Display info about loaded ACPI tables\\n\"},\n#ifdef ACPI_APPLICATION\n\t{1, \"  Terminate\", \"Delete namespace and all internal objects\\n\"},\n#endif\n\t{1, \"  ! <CommandNumber>\", \"Execute command from history buffer\\n\"},\n\t{1, \"  !!\", \"Execute last command again\\n\"},\n\n\t{0, \"\\nMethod and Namespace Debugging:\", \"\\n\"},\n\t{5, \"  Trace <State> [<Namepath>] [Once]\",\n\t \"Trace control method execution\\n\"},\n\t{1, \"     Enable\", \"Enable all messages\\n\"},\n\t{1, \"     Disable\", \"Disable tracing\\n\"},\n\t{1, \"     Method\", \"Enable method execution messages\\n\"},\n\t{1, \"     Opcode\", \"Enable opcode execution messages\\n\"},\n\t{3, \"  Test <TestName>\", \"Invoke a debug test\\n\"},\n\t{1, \"     Objects\", \"Read/write/compare all namespace data objects\\n\"},\n\t{1, \"     Predefined\",\n\t \"Validate all ACPI predefined names (_STA, etc.)\\n\"},\n\t{1, \"  Execute predefined\",\n\t \"Execute all predefined (public) methods\\n\"},\n\n\t{0, \"\\nControl Method Single-Step Execution:\", \"\\n\"},\n\t{1, \"  Arguments (or Args)\", \"Display method arguments\\n\"},\n\t{1, \"  Breakpoint <AmlOffset>\", \"Set an AML execution breakpoint\\n\"},\n\t{1, \"  Call\", \"Run to next control method invocation\\n\"},\n\t{1, \"  Go\", \"Allow method to run to completion\\n\"},\n\t{1, \"  Information\", \"Display info about the current method\\n\"},\n\t{1, \"  Into\", \"Step into (not over) a method call\\n\"},\n\t{1, \"  List [# of Aml Opcodes]\", \"Display method ASL statements\\n\"},\n\t{1, \"  Locals\", \"Display method local variables\\n\"},\n\t{1, \"  Results\", \"Display method result stack\\n\"},\n\t{1, \"  Set <A|L> <#> <Value>\", \"Set method data (Arguments/Locals)\\n\"},\n\t{1, \"  Stop\", \"Terminate control method\\n\"},\n\t{1, \"  Tree\", \"Display control method calling tree\\n\"},\n\t{1, \"  <Enter>\", \"Single step next AML opcode (over calls)\\n\"},\n\n#ifdef ACPI_APPLICATION\n\t{0, \"\\nFile Operations:\", \"\\n\"},\n\t{1, \"  Close\", \"Close debug output file\\n\"},\n\t{1, \"  Load <Input Filename>\", \"Load ACPI table from a file\\n\"},\n\t{1, \"  Open <Output Filename>\", \"Open a file for debug output\\n\"},\n\t{1, \"  Unload <Namepath>\",\n\t \"Unload an ACPI table via namespace object\\n\"},\n\n\t{0, \"\\nHardware Simulation:\", \"\\n\"},\n\t{1, \"  EnableAcpi\", \"Enable ACPI (hardware) mode\\n\"},\n\t{1, \"  Event <F|G> <Value>\", \"Generate AcpiEvent (Fixed/GPE)\\n\"},\n\t{1, \"  Gpe <GpeNum> [GpeBlockDevice]\", \"Simulate a GPE\\n\"},\n\t{1, \"  Gpes\", \"Display info on all GPE devices\\n\"},\n\t{1, \"  Sci\", \"Generate an SCI\\n\"},\n\t{1, \"  Sleep [SleepState]\", \"Simulate sleep/wake sequence(s) (0-5)\\n\"},\n\t{1, \"  Interrupt <GSIV>\", \"Simulate an interrupt\\n\"},\n#endif\n\t{0, NULL, NULL}\n};\n\n \n\nstatic u8\nacpi_db_match_command_help(const char *command,\n\t\t\t   const struct acpi_db_command_help *help)\n{\n\tchar *invocation = help->invocation;\n\tu32 line_count;\n\n\t \n\n\tif (*invocation != ' ') {\n\t\treturn (FALSE);\n\t}\n\n\twhile (*invocation == ' ') {\n\t\tinvocation++;\n\t}\n\n\t \n\n\twhile ((*command) && (*invocation) && (*invocation != ' ')) {\n\t\tif (tolower((int)*command) != tolower((int)*invocation)) {\n\t\t\treturn (FALSE);\n\t\t}\n\n\t\tinvocation++;\n\t\tcommand++;\n\t}\n\n\t \n\n\tline_count = help->line_count;\n\twhile (line_count) {\n\t\tacpi_os_printf(\"%-38s : %s\", help->invocation,\n\t\t\t       help->description);\n\t\thelp++;\n\t\tline_count--;\n\t}\n\n\treturn (TRUE);\n}\n\n \n\nstatic void acpi_db_display_command_info(const char *command, u8 display_all)\n{\n\tconst struct acpi_db_command_help *next;\n\tu8 matched;\n\n\tnext = acpi_gbl_db_command_help;\n\twhile (next->invocation) {\n\t\tmatched = acpi_db_match_command_help(command, next);\n\t\tif (!display_all && matched) {\n\t\t\treturn;\n\t\t}\n\n\t\tnext++;\n\t}\n}\n\n \n\nstatic void acpi_db_display_help(char *command)\n{\n\tconst struct acpi_db_command_help *next = acpi_gbl_db_command_help;\n\n\tif (!command) {\n\n\t\t \n\n\t\tacpi_os_printf(\"\\nSummary of AML Debugger Commands\\n\\n\");\n\n\t\twhile (next->invocation) {\n\t\t\tacpi_os_printf(\"%-38s%s\", next->invocation,\n\t\t\t\t       next->description);\n\t\t\tnext++;\n\t\t}\n\t\tacpi_os_printf(\"\\n\");\n\n\t} else {\n\t\t \n\n\t\tacpi_db_display_command_info(command, TRUE);\n\t}\n}\n\n \n\nchar *acpi_db_get_next_token(char *string,\n\t\t\t     char **next, acpi_object_type *return_type)\n{\n\tchar *start;\n\tu32 depth;\n\tacpi_object_type type = ACPI_TYPE_INTEGER;\n\n\t \n\n\tif (!string || !(*string)) {\n\t\treturn (NULL);\n\t}\n\n\t \n\n\twhile (*string && isspace((int)*string)) {\n\t\tstring++;\n\t}\n\n\tif (!(*string)) {\n\t\treturn (NULL);\n\t}\n\n\tswitch (*string) {\n\tcase '\"':\n\n\t\t \n\n\t\tstring++;\n\t\tstart = string;\n\t\ttype = ACPI_TYPE_STRING;\n\n\t\t \n\n\t\twhile (*string && (*string != '\"')) {\n\t\t\tstring++;\n\t\t}\n\t\tbreak;\n\n\tcase '(':\n\n\t\t \n\n\t\tstring++;\n\t\tstart = string;\n\t\ttype = ACPI_TYPE_BUFFER;\n\n\t\t \n\n\t\twhile (*string && (*string != ')')) {\n\t\t\tstring++;\n\t\t}\n\t\tbreak;\n\n\tcase '{':\n\n\t\t \n\n\t\tstring++;\n\t\tstart = string;\n\t\ttype = ACPI_TYPE_FIELD_UNIT;\n\n\t\t \n\n\t\twhile (*string && (*string != '}')) {\n\t\t\tstring++;\n\t\t}\n\t\tbreak;\n\n\tcase '[':\n\n\t\t \n\n\t\tstring++;\n\t\tdepth = 1;\n\t\tstart = string;\n\t\ttype = ACPI_TYPE_PACKAGE;\n\n\t\t \n\n\t\twhile (*string) {\n\n\t\t\t \n\n\t\t\tif (*string == '\"') {\n\t\t\t\t \n\n\t\t\t\tstring++;\n\t\t\t\twhile (*string && (*string != '\"')) {\n\t\t\t\t\tstring++;\n\t\t\t\t}\n\t\t\t\tif (!(*string)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (*string == '[') {\n\t\t\t\tdepth++;\t \n\t\t\t} else if (*string == ']') {\n\t\t\t\tdepth--;\n\t\t\t\tif (depth == 0) {\t \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring++;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\tstart = string;\n\n\t\t \n\n\t\twhile (*string && !isspace((int)*string)) {\n\t\t\tstring++;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!(*string)) {\n\t\t*next = NULL;\n\t} else {\n\t\t*string = 0;\n\t\t*next = string + 1;\n\t}\n\n\t*return_type = type;\n\treturn (start);\n}\n\n \n\nstatic u32 acpi_db_get_line(char *input_buffer)\n{\n\tu32 i;\n\tu32 count;\n\tchar *next;\n\tchar *this;\n\n\tif (acpi_ut_safe_strcpy\n\t    (acpi_gbl_db_parsed_buf, sizeof(acpi_gbl_db_parsed_buf),\n\t     input_buffer)) {\n\t\tacpi_os_printf\n\t\t    (\"Buffer overflow while parsing input line (max %u characters)\\n\",\n\t\t     (u32)sizeof(acpi_gbl_db_parsed_buf));\n\t\treturn (0);\n\t}\n\n\tthis = acpi_gbl_db_parsed_buf;\n\tfor (i = 0; i < ACPI_DEBUGGER_MAX_ARGS; i++) {\n\t\tacpi_gbl_db_args[i] = acpi_db_get_next_token(this, &next,\n\t\t\t\t\t\t\t     &acpi_gbl_db_arg_types\n\t\t\t\t\t\t\t     [i]);\n\t\tif (!acpi_gbl_db_args[i]) {\n\t\t\tbreak;\n\t\t}\n\n\t\tthis = next;\n\t}\n\n\t \n\n\tacpi_ut_strupr(acpi_gbl_db_args[0]);\n\n\tcount = i;\n\tif (count) {\n\t\tcount--;\t \n\t}\n\n\treturn (count);\n}\n\n \n\nstatic u32 acpi_db_match_command(char *user_command)\n{\n\tu32 i;\n\n\tif (!user_command || user_command[0] == 0) {\n\t\treturn (CMD_NULL);\n\t}\n\n\tfor (i = CMD_FIRST_VALID; acpi_gbl_db_commands[i].name; i++) {\n\t\tif (strstr\n\t\t    (ACPI_CAST_PTR(char, acpi_gbl_db_commands[i].name),\n\t\t     user_command) == acpi_gbl_db_commands[i].name) {\n\t\t\treturn (i);\n\t\t}\n\t}\n\n\t \n\n\treturn (CMD_NOT_FOUND);\n}\n\n \n\nacpi_status\nacpi_db_command_dispatch(char *input_buffer,\n\t\t\t struct acpi_walk_state *walk_state,\n\t\t\t union acpi_parse_object *op)\n{\n\tu32 temp;\n\tu64 temp64;\n\tu32 command_index;\n\tu32 param_count;\n\tchar *command_line;\n\tacpi_status status = AE_CTRL_TRUE;\n\n\t \n\n\tif (acpi_gbl_db_terminate_loop) {\n\t\treturn (AE_CTRL_TERMINATE);\n\t}\n\n\t \n\n\tparam_count = acpi_db_get_line(input_buffer);\n\tcommand_index = acpi_db_match_command(acpi_gbl_db_args[0]);\n\n\t \n\tif (command_index != CMD_HISTORY_LAST) {\n\t\tacpi_db_add_to_history(input_buffer);\n\t}\n\n\t \n\n\tif (param_count < acpi_gbl_db_commands[command_index].min_args) {\n\t\tacpi_os_printf\n\t\t    (\"%u parameters entered, [%s] requires %u parameters\\n\",\n\t\t     param_count, acpi_gbl_db_commands[command_index].name,\n\t\t     acpi_gbl_db_commands[command_index].min_args);\n\n\t\tacpi_db_display_command_info(acpi_gbl_db_commands\n\t\t\t\t\t     [command_index].name, FALSE);\n\t\treturn (AE_CTRL_TRUE);\n\t}\n\n\t \n\n\tswitch (command_index) {\n\tcase CMD_NULL:\n\n\t\tif (op) {\n\t\t\treturn (AE_OK);\n\t\t}\n\t\tbreak;\n\n\tcase CMD_ALL:\n\n\t\tacpi_os_printf(\"Executing all objects with NameSeg: %s\\n\",\n\t\t\t       acpi_gbl_db_args[1]);\n\t\tacpi_db_execute(acpi_gbl_db_args[1], &acpi_gbl_db_args[2],\n\t\t\t\t&acpi_gbl_db_arg_types[2],\n\t\t\t\tEX_NO_SINGLE_STEP | EX_ALL);\n\t\tbreak;\n\n\tcase CMD_ALLOCATIONS:\n\n#ifdef ACPI_DBG_TRACK_ALLOCATIONS\n\t\tacpi_ut_dump_allocations((u32)-1, NULL);\n#endif\n\t\tbreak;\n\n\tcase CMD_ARGS:\n\tcase CMD_ARGUMENTS:\n\n\t\tacpi_db_display_arguments();\n\t\tbreak;\n\n\tcase CMD_BREAKPOINT:\n\n\t\tacpi_db_set_method_breakpoint(acpi_gbl_db_args[1], walk_state,\n\t\t\t\t\t      op);\n\t\tbreak;\n\n\tcase CMD_BUSINFO:\n\n\t\tacpi_db_get_bus_info();\n\t\tbreak;\n\n\tcase CMD_CALL:\n\n\t\tacpi_db_set_method_call_breakpoint(op);\n\t\tstatus = AE_OK;\n\t\tbreak;\n\n\tcase CMD_DEBUG:\n\n\t\tacpi_db_execute(acpi_gbl_db_args[1],\n\t\t\t\t&acpi_gbl_db_args[2], &acpi_gbl_db_arg_types[2],\n\t\t\t\tEX_SINGLE_STEP);\n\t\tbreak;\n\n\tcase CMD_DISASSEMBLE:\n\tcase CMD_DISASM:\n\n#ifdef ACPI_DISASSEMBLER\n\t\t(void)acpi_db_disassemble_method(acpi_gbl_db_args[1]);\n#else\n\t\tacpi_os_printf\n\t\t    (\"The AML Disassembler is not configured/present\\n\");\n#endif\n\t\tbreak;\n\n\tcase CMD_DUMP:\n\n\t\tacpi_db_decode_and_display_object(acpi_gbl_db_args[1],\n\t\t\t\t\t\t  acpi_gbl_db_args[2]);\n\t\tbreak;\n\n\tcase CMD_EVALUATE:\n\tcase CMD_EXECUTE:\n\n\t\tacpi_db_execute(acpi_gbl_db_args[1],\n\t\t\t\t&acpi_gbl_db_args[2], &acpi_gbl_db_arg_types[2],\n\t\t\t\tEX_NO_SINGLE_STEP);\n\t\tbreak;\n\n\tcase CMD_FIND:\n\n\t\tstatus = acpi_db_find_name_in_namespace(acpi_gbl_db_args[1]);\n\t\tbreak;\n\n\tcase CMD_FIELDS:\n\n\t\tstatus = acpi_ut_strtoul64(acpi_gbl_db_args[1], &temp64);\n\n\t\tif (ACPI_FAILURE(status)\n\t\t    || temp64 >= ACPI_NUM_PREDEFINED_REGIONS) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Invalid address space ID: must be between 0 and %u inclusive\\n\",\n\t\t\t     ACPI_NUM_PREDEFINED_REGIONS - 1);\n\t\t\treturn (AE_OK);\n\t\t}\n\n\t\tstatus = acpi_db_display_fields((u32)temp64);\n\t\tbreak;\n\n\tcase CMD_GO:\n\n\t\tacpi_gbl_cm_single_step = FALSE;\n\t\treturn (AE_OK);\n\n\tcase CMD_HANDLERS:\n\n\t\tacpi_db_display_handlers();\n\t\tbreak;\n\n\tcase CMD_HELP:\n\tcase CMD_HELP2:\n\n\t\tacpi_db_display_help(acpi_gbl_db_args[1]);\n\t\tbreak;\n\n\tcase CMD_HISTORY:\n\n\t\tacpi_db_display_history();\n\t\tbreak;\n\n\tcase CMD_HISTORY_EXE:\t \n\n\t\tcommand_line = acpi_db_get_from_history(acpi_gbl_db_args[1]);\n\t\tif (!command_line) {\n\t\t\treturn (AE_CTRL_TRUE);\n\t\t}\n\n\t\tstatus = acpi_db_command_dispatch(command_line, walk_state, op);\n\t\treturn (status);\n\n\tcase CMD_HISTORY_LAST:\t \n\n\t\tcommand_line = acpi_db_get_from_history(NULL);\n\t\tif (!command_line) {\n\t\t\treturn (AE_CTRL_TRUE);\n\t\t}\n\n\t\tstatus = acpi_db_command_dispatch(command_line, walk_state, op);\n\t\treturn (status);\n\n\tcase CMD_INFORMATION:\n\n\t\tacpi_db_display_method_info(op);\n\t\tbreak;\n\n\tcase CMD_INTEGRITY:\n\n\t\tacpi_db_check_integrity();\n\t\tbreak;\n\n\tcase CMD_INTO:\n\n\t\tif (op) {\n\t\t\tacpi_gbl_cm_single_step = TRUE;\n\t\t\treturn (AE_OK);\n\t\t}\n\t\tbreak;\n\n\tcase CMD_LEVEL:\n\n\t\tif (param_count == 0) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Current debug level for file output is:    %8.8X\\n\",\n\t\t\t     acpi_gbl_db_debug_level);\n\t\t\tacpi_os_printf\n\t\t\t    (\"Current debug level for console output is: %8.8X\\n\",\n\t\t\t     acpi_gbl_db_console_debug_level);\n\t\t} else if (param_count == 2) {\n\t\t\ttemp = acpi_gbl_db_console_debug_level;\n\t\t\tacpi_gbl_db_console_debug_level =\n\t\t\t    strtoul(acpi_gbl_db_args[1], NULL, 16);\n\t\t\tacpi_os_printf\n\t\t\t    (\"Debug Level for console output was %8.8X, now %8.8X\\n\",\n\t\t\t     temp, acpi_gbl_db_console_debug_level);\n\t\t} else {\n\t\t\ttemp = acpi_gbl_db_debug_level;\n\t\t\tacpi_gbl_db_debug_level =\n\t\t\t    strtoul(acpi_gbl_db_args[1], NULL, 16);\n\t\t\tacpi_os_printf\n\t\t\t    (\"Debug Level for file output was %8.8X, now %8.8X\\n\",\n\t\t\t     temp, acpi_gbl_db_debug_level);\n\t\t}\n\t\tbreak;\n\n\tcase CMD_LIST:\n\n#ifdef ACPI_DISASSEMBLER\n\t\tacpi_db_disassemble_aml(acpi_gbl_db_args[1], op);\n#else\n\t\tacpi_os_printf\n\t\t    (\"The AML Disassembler is not configured/present\\n\");\n#endif\n\t\tbreak;\n\n\tcase CMD_LOCKS:\n\n\t\tacpi_db_display_locks();\n\t\tbreak;\n\n\tcase CMD_LOCALS:\n\n\t\tacpi_db_display_locals();\n\t\tbreak;\n\n\tcase CMD_METHODS:\n\n\t\tstatus = acpi_db_display_objects(\"METHOD\", acpi_gbl_db_args[1]);\n\t\tbreak;\n\n\tcase CMD_NAMESPACE:\n\n\t\tacpi_db_dump_namespace(acpi_gbl_db_args[1],\n\t\t\t\t       acpi_gbl_db_args[2]);\n\t\tbreak;\n\n\tcase CMD_NOTIFY:\n\n\t\ttemp = strtoul(acpi_gbl_db_args[2], NULL, 0);\n\t\tacpi_db_send_notify(acpi_gbl_db_args[1], temp);\n\t\tbreak;\n\n\tcase CMD_OBJECTS:\n\n\t\tacpi_ut_strupr(acpi_gbl_db_args[1]);\n\t\tstatus =\n\t\t    acpi_db_display_objects(acpi_gbl_db_args[1],\n\t\t\t\t\t    acpi_gbl_db_args[2]);\n\t\tbreak;\n\n\tcase CMD_OSI:\n\n\t\tacpi_db_display_interfaces(acpi_gbl_db_args[1],\n\t\t\t\t\t   acpi_gbl_db_args[2]);\n\t\tbreak;\n\n\tcase CMD_OWNER:\n\n\t\tacpi_db_dump_namespace_by_owner(acpi_gbl_db_args[1],\n\t\t\t\t\t\tacpi_gbl_db_args[2]);\n\t\tbreak;\n\n\tcase CMD_PATHS:\n\n\t\tacpi_db_dump_namespace_paths();\n\t\tbreak;\n\n\tcase CMD_PREFIX:\n\n\t\tacpi_db_set_scope(acpi_gbl_db_args[1]);\n\t\tbreak;\n\n\tcase CMD_REFERENCES:\n\n\t\tacpi_db_find_references(acpi_gbl_db_args[1]);\n\t\tbreak;\n\n\tcase CMD_RESOURCES:\n\n\t\tacpi_db_display_resources(acpi_gbl_db_args[1]);\n\t\tbreak;\n\n\tcase CMD_RESULTS:\n\n\t\tacpi_db_display_results();\n\t\tbreak;\n\n\tcase CMD_SET:\n\n\t\tacpi_db_set_method_data(acpi_gbl_db_args[1],\n\t\t\t\t\tacpi_gbl_db_args[2],\n\t\t\t\t\tacpi_gbl_db_args[3]);\n\t\tbreak;\n\n\tcase CMD_STATS:\n\n\t\tstatus = acpi_db_display_statistics(acpi_gbl_db_args[1]);\n\t\tbreak;\n\n\tcase CMD_STOP:\n\n\t\treturn (AE_NOT_IMPLEMENTED);\n\n\tcase CMD_TABLES:\n\n\t\tacpi_db_display_table_info(acpi_gbl_db_args[1]);\n\t\tbreak;\n\n\tcase CMD_TEMPLATE:\n\n\t\tacpi_db_display_template(acpi_gbl_db_args[1]);\n\t\tbreak;\n\n\tcase CMD_TRACE:\n\n\t\tacpi_db_trace(acpi_gbl_db_args[1], acpi_gbl_db_args[2],\n\t\t\t      acpi_gbl_db_args[3]);\n\t\tbreak;\n\n\tcase CMD_TREE:\n\n\t\tacpi_db_display_calling_tree();\n\t\tbreak;\n\n\tcase CMD_TYPE:\n\n\t\tacpi_db_display_object_type(acpi_gbl_db_args[1]);\n\t\tbreak;\n\n#ifdef ACPI_APPLICATION\n\n\t\t \n\n\tcase CMD_ENABLEACPI:\n#if (!ACPI_REDUCED_HARDWARE)\n\n\t\tstatus = acpi_enable();\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"AcpiEnable failed (Status=%X)\\n\",\n\t\t\t\t       status);\n\t\t\treturn (status);\n\t\t}\n#endif\t\t\t\t \n\t\tbreak;\n\n\tcase CMD_EVENT:\n\n\t\tacpi_os_printf(\"Event command not implemented\\n\");\n\t\tbreak;\n\n\tcase CMD_INTERRUPT:\n\n\t\tacpi_db_generate_interrupt(acpi_gbl_db_args[1]);\n\t\tbreak;\n\n\tcase CMD_GPE:\n\n\t\tacpi_db_generate_gpe(acpi_gbl_db_args[1], acpi_gbl_db_args[2]);\n\t\tbreak;\n\n\tcase CMD_GPES:\n\n\t\tacpi_db_display_gpes();\n\t\tbreak;\n\n\tcase CMD_SCI:\n\n\t\tacpi_db_generate_sci();\n\t\tbreak;\n\n\tcase CMD_SLEEP:\n\n\t\tstatus = acpi_db_sleep(acpi_gbl_db_args[1]);\n\t\tbreak;\n\n\t\t \n\n\tcase CMD_CLOSE:\n\n\t\tacpi_db_close_debug_file();\n\t\tbreak;\n\n\tcase CMD_LOAD:{\n\t\t\tstruct acpi_new_table_desc *list_head = NULL;\n\n\t\t\tstatus =\n\t\t\t    ac_get_all_tables_from_file(acpi_gbl_db_args[1],\n\t\t\t\t\t\t\tACPI_GET_ALL_TABLES,\n\t\t\t\t\t\t\t&list_head);\n\t\t\tif (ACPI_SUCCESS(status)) {\n\t\t\t\tacpi_db_load_tables(list_head);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase CMD_OPEN:\n\n\t\tacpi_db_open_debug_file(acpi_gbl_db_args[1]);\n\t\tbreak;\n\n\t\t \n\n\tcase CMD_TERMINATE:\n\n\t\tacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\n\t\tacpi_ut_subsystem_shutdown();\n\n\t\t \n\n\t\tacpi_gbl_db_terminate_loop = TRUE;\n\t\t \n\t\tbreak;\n\n\tcase CMD_BACKGROUND:\n\n\t\tacpi_db_create_execution_thread(acpi_gbl_db_args[1],\n\t\t\t\t\t\t&acpi_gbl_db_args[2],\n\t\t\t\t\t\t&acpi_gbl_db_arg_types[2]);\n\t\tbreak;\n\n\tcase CMD_THREADS:\n\n\t\tacpi_db_create_execution_threads(acpi_gbl_db_args[1],\n\t\t\t\t\t\t acpi_gbl_db_args[2],\n\t\t\t\t\t\t acpi_gbl_db_args[3]);\n\t\tbreak;\n\n\t\t \n\n\tcase CMD_PREDEFINED:\n\n\t\tacpi_db_check_predefined_names();\n\t\tbreak;\n\n\tcase CMD_TEST:\n\n\t\tacpi_db_execute_test(acpi_gbl_db_args[1]);\n\t\tbreak;\n\n\tcase CMD_UNLOAD:\n\n\t\tacpi_db_unload_acpi_table(acpi_gbl_db_args[1]);\n\t\tbreak;\n#endif\n\n\tcase CMD_EXIT:\n\tcase CMD_QUIT:\n\n\t\tif (op) {\n\t\t\tacpi_os_printf(\"Method execution terminated\\n\");\n\t\t\treturn (AE_CTRL_TERMINATE);\n\t\t}\n\n\t\tif (!acpi_gbl_db_output_to_file) {\n\t\t\tacpi_dbg_level = ACPI_DEBUG_DEFAULT;\n\t\t}\n#ifdef ACPI_APPLICATION\n\t\tacpi_db_close_debug_file();\n#endif\n\t\tacpi_gbl_db_terminate_loop = TRUE;\n\t\treturn (AE_CTRL_TERMINATE);\n\n\tcase CMD_NOT_FOUND:\n\tdefault:\n\n\t\tacpi_os_printf(\"%s: unknown command\\n\", acpi_gbl_db_args[0]);\n\t\treturn (AE_CTRL_TRUE);\n\t}\n\n\tif (ACPI_SUCCESS(status)) {\n\t\tstatus = AE_CTRL_TRUE;\n\t}\n\n\treturn (status);\n}\n\n \n\nvoid ACPI_SYSTEM_XFACE acpi_db_execute_thread(void *context)\n{\n\n\t(void)acpi_db_user_commands();\n\tacpi_gbl_db_threads_terminated = TRUE;\n}\n\n \n\nacpi_status acpi_db_user_commands(void)\n{\n\tacpi_status status = AE_OK;\n\n\tacpi_os_printf(\"\\n\");\n\n\t \n\n\twhile (!acpi_gbl_db_terminate_loop) {\n\n\t\t \n\n\t\tstatus = acpi_os_wait_command_ready();\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tacpi_gbl_method_executing = FALSE;\n\t\tacpi_gbl_step_to_next_call = FALSE;\n\n\t\t(void)acpi_db_command_dispatch(acpi_gbl_db_line_buf, NULL,\n\t\t\t\t\t       NULL);\n\n\t\t \n\n\t\tstatus = acpi_os_notify_command_complete();\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ACPI_FAILURE(status) && status != AE_CTRL_TERMINATE) {\n\t\tACPI_EXCEPTION((AE_INFO, status, \"While parsing command line\"));\n\t}\n\treturn (status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}