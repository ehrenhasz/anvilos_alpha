{
  "module_name": "utcopy.c",
  "hash_id": "2e92547c3d3be2038631d32d68cb1d608052894bc5dcc34248fbe676a694fafd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utcopy.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utcopy\")\n\n \nstatic acpi_status\nacpi_ut_copy_isimple_to_esimple(union acpi_operand_object *internal_object,\n\t\t\t\tunion acpi_object *external_object,\n\t\t\t\tu8 *data_space, acpi_size *buffer_space_used);\n\nstatic acpi_status\nacpi_ut_copy_ielement_to_ielement(u8 object_type,\n\t\t\t\t  union acpi_operand_object *source_object,\n\t\t\t\t  union acpi_generic_state *state,\n\t\t\t\t  void *context);\n\nstatic acpi_status\nacpi_ut_copy_ipackage_to_epackage(union acpi_operand_object *internal_object,\n\t\t\t\t  u8 *buffer, acpi_size *space_used);\n\nstatic acpi_status\nacpi_ut_copy_esimple_to_isimple(union acpi_object *user_obj,\n\t\t\t\tunion acpi_operand_object **return_obj);\n\nstatic acpi_status\nacpi_ut_copy_epackage_to_ipackage(union acpi_object *external_object,\n\t\t\t\t  union acpi_operand_object **internal_object);\n\nstatic acpi_status\nacpi_ut_copy_simple_object(union acpi_operand_object *source_desc,\n\t\t\t   union acpi_operand_object *dest_desc);\n\nstatic acpi_status\nacpi_ut_copy_ielement_to_eelement(u8 object_type,\n\t\t\t\t  union acpi_operand_object *source_object,\n\t\t\t\t  union acpi_generic_state *state,\n\t\t\t\t  void *context);\n\nstatic acpi_status\nacpi_ut_copy_ipackage_to_ipackage(union acpi_operand_object *source_obj,\n\t\t\t\t  union acpi_operand_object *dest_obj,\n\t\t\t\t  struct acpi_walk_state *walk_state);\n\n \n\nstatic acpi_status\nacpi_ut_copy_isimple_to_esimple(union acpi_operand_object *internal_object,\n\t\t\t\tunion acpi_object *external_object,\n\t\t\t\tu8 *data_space, acpi_size *buffer_space_used)\n{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(ut_copy_isimple_to_esimple);\n\n\t*buffer_space_used = 0;\n\n\t \n\tif (!internal_object) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tmemset(external_object, 0, sizeof(union acpi_object));\n\n\t \n\texternal_object->type = internal_object->common.type;\n\n\t \n\n\tswitch (internal_object->common.type) {\n\tcase ACPI_TYPE_STRING:\n\n\t\texternal_object->string.pointer = (char *)data_space;\n\t\texternal_object->string.length = internal_object->string.length;\n\t\t*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD((acpi_size)\n\t\t\t\t\t\t\t\t  internal_object->\n\t\t\t\t\t\t\t\t  string.\n\t\t\t\t\t\t\t\t  length + 1);\n\n\t\tmemcpy((void *)data_space,\n\t\t       (void *)internal_object->string.pointer,\n\t\t       (acpi_size)internal_object->string.length + 1);\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\texternal_object->buffer.pointer = data_space;\n\t\texternal_object->buffer.length = internal_object->buffer.length;\n\t\t*buffer_space_used =\n\t\t    ACPI_ROUND_UP_TO_NATIVE_WORD(internal_object->string.\n\t\t\t\t\t\t length);\n\n\t\tmemcpy((void *)data_space,\n\t\t       (void *)internal_object->buffer.pointer,\n\t\t       internal_object->buffer.length);\n\t\tbreak;\n\n\tcase ACPI_TYPE_INTEGER:\n\n\t\texternal_object->integer.value = internal_object->integer.value;\n\t\tbreak;\n\n\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\n\t\t \n\n\t\tswitch (internal_object->reference.class) {\n\t\tcase ACPI_REFCLASS_NAME:\n\t\t\t \n\t\t\texternal_object->reference.handle =\n\t\t\t    internal_object->reference.node;\n\t\t\texternal_object->reference.actual_type =\n\t\t\t    acpi_ns_get_type(internal_object->reference.node);\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\t \n\n\t\t\treturn_ACPI_STATUS(AE_TYPE);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_PROCESSOR:\n\n\t\texternal_object->processor.proc_id =\n\t\t    internal_object->processor.proc_id;\n\t\texternal_object->processor.pblk_address =\n\t\t    internal_object->processor.address;\n\t\texternal_object->processor.pblk_length =\n\t\t    internal_object->processor.length;\n\t\tbreak;\n\n\tcase ACPI_TYPE_POWER:\n\n\t\texternal_object->power_resource.system_level =\n\t\t    internal_object->power_resource.system_level;\n\n\t\texternal_object->power_resource.resource_order =\n\t\t    internal_object->power_resource.resource_order;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Unsupported object type, cannot convert to external object: %s\",\n\t\t\t    acpi_ut_get_type_name(internal_object->common.\n\t\t\t\t\t\t  type)));\n\n\t\treturn_ACPI_STATUS(AE_SUPPORT);\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic acpi_status\nacpi_ut_copy_ielement_to_eelement(u8 object_type,\n\t\t\t\t  union acpi_operand_object *source_object,\n\t\t\t\t  union acpi_generic_state *state,\n\t\t\t\t  void *context)\n{\n\tacpi_status status = AE_OK;\n\tstruct acpi_pkg_info *info = (struct acpi_pkg_info *)context;\n\tacpi_size object_space;\n\tu32 this_index;\n\tunion acpi_object *target_object;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tthis_index = state->pkg.index;\n\ttarget_object = (union acpi_object *)&((union acpi_object *)\n\t\t\t\t\t       (state->pkg.dest_object))->\n\t    package.elements[this_index];\n\n\tswitch (object_type) {\n\tcase ACPI_COPY_TYPE_SIMPLE:\n\t\t \n\t\tstatus = acpi_ut_copy_isimple_to_esimple(source_object,\n\t\t\t\t\t\t\t target_object,\n\t\t\t\t\t\t\t info->free_space,\n\t\t\t\t\t\t\t &object_space);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_COPY_TYPE_PACKAGE:\n\t\t \n\t\ttarget_object->type = ACPI_TYPE_PACKAGE;\n\t\ttarget_object->package.count = source_object->package.count;\n\t\ttarget_object->package.elements =\n\t\t    ACPI_CAST_PTR(union acpi_object, info->free_space);\n\n\t\t \n\t\tstate->pkg.this_target_obj = target_object;\n\n\t\t \n\t\tobject_space = ACPI_ROUND_UP_TO_NATIVE_WORD((acpi_size)\n\t\t\t\t\t\t\t    target_object->\n\t\t\t\t\t\t\t    package.count *\n\t\t\t\t\t\t\t    sizeof(union\n\t\t\t\t\t\t\t\t   acpi_object));\n\t\tbreak;\n\n\tdefault:\n\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tinfo->free_space += object_space;\n\tinfo->length += object_space;\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nacpi_ut_copy_ipackage_to_epackage(union acpi_operand_object *internal_object,\n\t\t\t\t  u8 *buffer, acpi_size *space_used)\n{\n\tunion acpi_object *external_object;\n\tacpi_status status;\n\tstruct acpi_pkg_info info;\n\n\tACPI_FUNCTION_TRACE(ut_copy_ipackage_to_epackage);\n\n\t \n\texternal_object = ACPI_CAST_PTR(union acpi_object, buffer);\n\n\t \n\tinfo.length = ACPI_ROUND_UP_TO_NATIVE_WORD(sizeof(union acpi_object));\n\tinfo.free_space = buffer +\n\t    ACPI_ROUND_UP_TO_NATIVE_WORD(sizeof(union acpi_object));\n\tinfo.object_space = 0;\n\tinfo.num_packages = 1;\n\n\texternal_object->type = internal_object->common.type;\n\texternal_object->package.count = internal_object->package.count;\n\texternal_object->package.elements =\n\t    ACPI_CAST_PTR(union acpi_object, info.free_space);\n\n\t \n\tinfo.length += (acpi_size)external_object->package.count *\n\t    ACPI_ROUND_UP_TO_NATIVE_WORD(sizeof(union acpi_object));\n\tinfo.free_space += external_object->package.count *\n\t    ACPI_ROUND_UP_TO_NATIVE_WORD(sizeof(union acpi_object));\n\n\tstatus = acpi_ut_walk_package_tree(internal_object, external_object,\n\t\t\t\t\t   acpi_ut_copy_ielement_to_eelement,\n\t\t\t\t\t   &info);\n\n\t*space_used = info.length;\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ut_copy_iobject_to_eobject(union acpi_operand_object *internal_object,\n\t\t\t\tstruct acpi_buffer *ret_buffer)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ut_copy_iobject_to_eobject);\n\n\tif (internal_object->common.type == ACPI_TYPE_PACKAGE) {\n\t\t \n\t\tstatus = acpi_ut_copy_ipackage_to_epackage(internal_object,\n\t\t\t\t\t\t\t   ret_buffer->pointer,\n\t\t\t\t\t\t\t   &ret_buffer->length);\n\t} else {\n\t\t \n\t\tstatus = acpi_ut_copy_isimple_to_esimple(internal_object,\n\t\t\t\t\t\t\t ACPI_CAST_PTR(union\n\t\t\t\t\t\t\t\t       acpi_object,\n\t\t\t\t\t\t\t\t       ret_buffer->\n\t\t\t\t\t\t\t\t       pointer),\n\t\t\t\t\t\t\t ACPI_ADD_PTR(u8,\n\t\t\t\t\t\t\t\t      ret_buffer->\n\t\t\t\t\t\t\t\t      pointer,\n\t\t\t\t\t\t\t\t      ACPI_ROUND_UP_TO_NATIVE_WORD\n\t\t\t\t\t\t\t\t      (sizeof\n\t\t\t\t\t\t\t\t       (union\n\t\t\t\t\t\t\t\t\tacpi_object))),\n\t\t\t\t\t\t\t &ret_buffer->length);\n\t\t \n\t\tret_buffer->length += sizeof(union acpi_object);\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic acpi_status\nacpi_ut_copy_esimple_to_isimple(union acpi_object *external_object,\n\t\t\t\tunion acpi_operand_object **ret_internal_object)\n{\n\tunion acpi_operand_object *internal_object;\n\n\tACPI_FUNCTION_TRACE(ut_copy_esimple_to_isimple);\n\n\t \n\tswitch (external_object->type) {\n\tcase ACPI_TYPE_STRING:\n\tcase ACPI_TYPE_BUFFER:\n\tcase ACPI_TYPE_INTEGER:\n\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\n\t\tinternal_object = acpi_ut_create_internal_object((u8)\n\t\t\t\t\t\t\t\t external_object->\n\t\t\t\t\t\t\t\t type);\n\t\tif (!internal_object) {\n\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_ANY:\t \n\n\t\t*ret_internal_object = NULL;\n\t\treturn_ACPI_STATUS(AE_OK);\n\n\tdefault:\n\n\t\t \n\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Unsupported object type, cannot convert to internal object: %s\",\n\t\t\t    acpi_ut_get_type_name(external_object->type)));\n\n\t\treturn_ACPI_STATUS(AE_SUPPORT);\n\t}\n\n\t \n\n\tswitch (external_object->type) {\n\tcase ACPI_TYPE_STRING:\n\n\t\tinternal_object->string.pointer =\n\t\t    ACPI_ALLOCATE_ZEROED((acpi_size)\n\t\t\t\t\t external_object->string.length + 1);\n\n\t\tif (!internal_object->string.pointer) {\n\t\t\tgoto error_exit;\n\t\t}\n\n\t\tmemcpy(internal_object->string.pointer,\n\t\t       external_object->string.pointer,\n\t\t       external_object->string.length);\n\n\t\tinternal_object->string.length = external_object->string.length;\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\tinternal_object->buffer.pointer =\n\t\t    ACPI_ALLOCATE_ZEROED(external_object->buffer.length);\n\t\tif (!internal_object->buffer.pointer) {\n\t\t\tgoto error_exit;\n\t\t}\n\n\t\tmemcpy(internal_object->buffer.pointer,\n\t\t       external_object->buffer.pointer,\n\t\t       external_object->buffer.length);\n\n\t\tinternal_object->buffer.length = external_object->buffer.length;\n\n\t\t \n\n\t\tinternal_object->buffer.flags |= AOPOBJ_DATA_VALID;\n\t\tbreak;\n\n\tcase ACPI_TYPE_INTEGER:\n\n\t\tinternal_object->integer.value = external_object->integer.value;\n\t\tbreak;\n\n\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\n\t\t \n\n\t\tinternal_object->reference.class = ACPI_REFCLASS_REFOF;\n\t\tinternal_object->reference.object =\n\t\t    external_object->reference.handle;\n\t\tbreak;\n\n\tdefault:\n\n\t\t \n\n\t\tbreak;\n\t}\n\n\t*ret_internal_object = internal_object;\n\treturn_ACPI_STATUS(AE_OK);\n\nerror_exit:\n\tacpi_ut_remove_reference(internal_object);\n\treturn_ACPI_STATUS(AE_NO_MEMORY);\n}\n\n \n\nstatic acpi_status\nacpi_ut_copy_epackage_to_ipackage(union acpi_object *external_object,\n\t\t\t\t  union acpi_operand_object **internal_object)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_operand_object *package_object;\n\tunion acpi_operand_object **package_elements;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ut_copy_epackage_to_ipackage);\n\n\t \n\n\tpackage_object =\n\t    acpi_ut_create_package_object(external_object->package.count);\n\tif (!package_object) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tpackage_elements = package_object->package.elements;\n\n\t \n\tfor (i = 0; i < external_object->package.count; i++) {\n\t\tstatus =\n\t\t    acpi_ut_copy_eobject_to_iobject(&external_object->package.\n\t\t\t\t\t\t    elements[i],\n\t\t\t\t\t\t    &package_elements[i]);\n\t\tif (ACPI_FAILURE(status)) {\n\n\t\t\t \n\n\t\t\tpackage_object->package.count = i;\n\t\t\tpackage_elements[i] = NULL;\n\t\t\tacpi_ut_remove_reference(package_object);\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t}\n\n\t \n\n\tpackage_object->package.flags |= AOPOBJ_DATA_VALID;\n\n\t*internal_object = package_object;\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ut_copy_eobject_to_iobject(union acpi_object *external_object,\n\t\t\t\tunion acpi_operand_object **internal_object)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ut_copy_eobject_to_iobject);\n\n\tif (external_object->type == ACPI_TYPE_PACKAGE) {\n\t\tstatus =\n\t\t    acpi_ut_copy_epackage_to_ipackage(external_object,\n\t\t\t\t\t\t      internal_object);\n\t} else {\n\t\t \n\t\tstatus = acpi_ut_copy_esimple_to_isimple(external_object,\n\t\t\t\t\t\t\t internal_object);\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic acpi_status\nacpi_ut_copy_simple_object(union acpi_operand_object *source_desc,\n\t\t\t   union acpi_operand_object *dest_desc)\n{\n\tu16 reference_count;\n\tunion acpi_operand_object *next_object;\n\tacpi_status status;\n\tacpi_size copy_size;\n\n\t \n\n\treference_count = dest_desc->common.reference_count;\n\tnext_object = dest_desc->common.next_object;\n\n\t \n\tcopy_size = sizeof(union acpi_operand_object);\n\tif (ACPI_GET_DESCRIPTOR_TYPE(source_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\tcopy_size = sizeof(struct acpi_namespace_node);\n\t}\n\n\tmemcpy(ACPI_CAST_PTR(char, dest_desc),\n\t       ACPI_CAST_PTR(char, source_desc), copy_size);\n\n\t \n\n\tdest_desc->common.reference_count = reference_count;\n\tdest_desc->common.next_object = next_object;\n\n\t \n\n\tdest_desc->common.flags &= ~AOPOBJ_STATIC_POINTER;\n\n\t \n\n\tswitch (dest_desc->common.type) {\n\tcase ACPI_TYPE_BUFFER:\n\t\t \n\t\tif ((source_desc->buffer.pointer) &&\n\t\t    (source_desc->buffer.length)) {\n\t\t\tdest_desc->buffer.pointer =\n\t\t\t    ACPI_ALLOCATE(source_desc->buffer.length);\n\t\t\tif (!dest_desc->buffer.pointer) {\n\t\t\t\treturn (AE_NO_MEMORY);\n\t\t\t}\n\n\t\t\t \n\n\t\t\tmemcpy(dest_desc->buffer.pointer,\n\t\t\t       source_desc->buffer.pointer,\n\t\t\t       source_desc->buffer.length);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_STRING:\n\t\t \n\t\tif (source_desc->string.pointer) {\n\t\t\tdest_desc->string.pointer =\n\t\t\t    ACPI_ALLOCATE((acpi_size)source_desc->string.\n\t\t\t\t\t  length + 1);\n\t\t\tif (!dest_desc->string.pointer) {\n\t\t\t\treturn (AE_NO_MEMORY);\n\t\t\t}\n\n\t\t\t \n\n\t\t\tmemcpy(dest_desc->string.pointer,\n\t\t\t       source_desc->string.pointer,\n\t\t\t       (acpi_size)source_desc->string.length + 1);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\t\t \n\t\tif (source_desc->reference.class == ACPI_REFCLASS_TABLE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tacpi_ut_add_reference(source_desc->reference.object);\n\t\tbreak;\n\n\tcase ACPI_TYPE_REGION:\n\t\t \n\t\tif (dest_desc->region.handler) {\n\t\t\tacpi_ut_add_reference(dest_desc->region.handler);\n\t\t}\n\t\tbreak;\n\n\t\t \n\tcase ACPI_TYPE_MUTEX:\n\n\t\tstatus = acpi_os_create_mutex(&dest_desc->mutex.os_mutex);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_EVENT:\n\n\t\tstatus = acpi_os_create_semaphore(ACPI_NO_UNIT_LIMIT, 0,\n\t\t\t\t\t\t  &dest_desc->event.\n\t\t\t\t\t\t  os_semaphore);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\t \n\n\t\tbreak;\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_ut_copy_ielement_to_ielement(u8 object_type,\n\t\t\t\t  union acpi_operand_object *source_object,\n\t\t\t\t  union acpi_generic_state *state,\n\t\t\t\t  void *context)\n{\n\tacpi_status status = AE_OK;\n\tu32 this_index;\n\tunion acpi_operand_object **this_target_ptr;\n\tunion acpi_operand_object *target_object;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tthis_index = state->pkg.index;\n\tthis_target_ptr = (union acpi_operand_object **)\n\t    &state->pkg.dest_object->package.elements[this_index];\n\n\tswitch (object_type) {\n\tcase ACPI_COPY_TYPE_SIMPLE:\n\n\t\t \n\n\t\tif (source_object) {\n\t\t\t \n\t\t\ttarget_object =\n\t\t\t    acpi_ut_create_internal_object(source_object->\n\t\t\t\t\t\t\t   common.type);\n\t\t\tif (!target_object) {\n\t\t\t\treturn (AE_NO_MEMORY);\n\t\t\t}\n\n\t\t\tstatus =\n\t\t\t    acpi_ut_copy_simple_object(source_object,\n\t\t\t\t\t\t       target_object);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tgoto error_exit;\n\t\t\t}\n\n\t\t\t*this_target_ptr = target_object;\n\t\t} else {\n\t\t\t \n\n\t\t\t*this_target_ptr = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_COPY_TYPE_PACKAGE:\n\t\t \n\t\ttarget_object =\n\t\t    acpi_ut_create_package_object(source_object->package.count);\n\t\tif (!target_object) {\n\t\t\treturn (AE_NO_MEMORY);\n\t\t}\n\n\t\ttarget_object->common.flags = source_object->common.flags;\n\n\t\t \n\n\t\tstate->pkg.this_target_obj = target_object;\n\n\t\t \n\n\t\t*this_target_ptr = target_object;\n\t\tbreak;\n\n\tdefault:\n\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\treturn (status);\n\nerror_exit:\n\tacpi_ut_remove_reference(target_object);\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nacpi_ut_copy_ipackage_to_ipackage(union acpi_operand_object *source_obj,\n\t\t\t\t  union acpi_operand_object *dest_obj,\n\t\t\t\t  struct acpi_walk_state *walk_state)\n{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(ut_copy_ipackage_to_ipackage);\n\n\tdest_obj->common.type = source_obj->common.type;\n\tdest_obj->common.flags = source_obj->common.flags;\n\tdest_obj->package.count = source_obj->package.count;\n\n\t \n\tdest_obj->package.elements = ACPI_ALLOCATE_ZEROED(((acpi_size)\n\t\t\t\t\t\t\t   source_obj->package.\n\t\t\t\t\t\t\t   count +\n\t\t\t\t\t\t\t   1) * sizeof(void *));\n\tif (!dest_obj->package.elements) {\n\t\tACPI_ERROR((AE_INFO, \"Package allocation failure\"));\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\tstatus = acpi_ut_walk_package_tree(source_obj, dest_obj,\n\t\t\t\t\t   acpi_ut_copy_ielement_to_ielement,\n\t\t\t\t\t   walk_state);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ut_copy_iobject_to_iobject(union acpi_operand_object *source_desc,\n\t\t\t\tunion acpi_operand_object **dest_desc,\n\t\t\t\tstruct acpi_walk_state *walk_state)\n{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(ut_copy_iobject_to_iobject);\n\n\t \n\n\t*dest_desc = acpi_ut_create_internal_object(source_desc->common.type);\n\tif (!*dest_desc) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tif (source_desc->common.type == ACPI_TYPE_PACKAGE) {\n\t\tstatus =\n\t\t    acpi_ut_copy_ipackage_to_ipackage(source_desc, *dest_desc,\n\t\t\t\t\t\t      walk_state);\n\t} else {\n\t\tstatus = acpi_ut_copy_simple_object(source_desc, *dest_desc);\n\t}\n\n\t \n\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ut_remove_reference(*dest_desc);\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}