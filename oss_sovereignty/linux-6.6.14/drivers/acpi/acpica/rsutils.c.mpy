{
  "module_name": "rsutils.c",
  "hash_id": "52f8c2f9fe26f17abd982188dc9bc3993f5f3d16be93dcce328e7c2a2de749e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/rsutils.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"acresrc.h\"\n\n#define _COMPONENT          ACPI_RESOURCES\nACPI_MODULE_NAME(\"rsutils\")\n\n \nu8 acpi_rs_decode_bitmask(u16 mask, u8 * list)\n{\n\tu8 i;\n\tu8 bit_count;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tfor (i = 0, bit_count = 0; mask; i++) {\n\t\tif (mask & 0x0001) {\n\t\t\tlist[bit_count] = i;\n\t\t\tbit_count++;\n\t\t}\n\n\t\tmask >>= 1;\n\t}\n\n\treturn (bit_count);\n}\n\n \n\nu16 acpi_rs_encode_bitmask(u8 * list, u8 count)\n{\n\tu32 i;\n\tu16 mask;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tfor (i = 0, mask = 0; i < count; i++) {\n\t\tmask |= (0x1 << list[i]);\n\t}\n\n\treturn (mask);\n}\n\n \n\nvoid\nacpi_rs_move_data(void *destination, void *source, u16 item_count, u8 move_type)\n{\n\tu32 i;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tfor (i = 0; i < item_count; i++) {\n\t\tswitch (move_type) {\n\t\t\t \n\t\tcase ACPI_RSC_MOVE8:\n\t\tcase ACPI_RSC_MOVE_GPIO_RES:\n\t\tcase ACPI_RSC_MOVE_SERIAL_VEN:\n\t\tcase ACPI_RSC_MOVE_SERIAL_RES:\n\n\t\t\tmemcpy(destination, source, item_count);\n\t\t\treturn;\n\n\t\t\t \n\t\tcase ACPI_RSC_MOVE16:\n\t\tcase ACPI_RSC_MOVE_GPIO_PIN:\n\n\t\t\tACPI_MOVE_16_TO_16(&ACPI_CAST_PTR(u16, destination)[i],\n\t\t\t\t\t   &ACPI_CAST_PTR(u16, source)[i]);\n\t\t\tbreak;\n\n\t\tcase ACPI_RSC_MOVE32:\n\n\t\t\tACPI_MOVE_32_TO_32(&ACPI_CAST_PTR(u32, destination)[i],\n\t\t\t\t\t   &ACPI_CAST_PTR(u32, source)[i]);\n\t\t\tbreak;\n\n\t\tcase ACPI_RSC_MOVE64:\n\n\t\t\tACPI_MOVE_64_TO_64(&ACPI_CAST_PTR(u64, destination)[i],\n\t\t\t\t\t   &ACPI_CAST_PTR(u64, source)[i]);\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \n\nvoid\nacpi_rs_set_resource_length(acpi_rsdesc_size total_length,\n\t\t\t    union aml_resource *aml)\n{\n\tacpi_rs_length resource_length;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tresource_length = (acpi_rs_length)\n\t    (total_length - acpi_ut_get_resource_header_length(aml));\n\n\t \n\n\tif (aml->small_header.descriptor_type & ACPI_RESOURCE_NAME_LARGE) {\n\n\t\t \n\n\t\tACPI_MOVE_16_TO_16(&aml->large_header.resource_length,\n\t\t\t\t   &resource_length);\n\t} else {\n\t\t \n\t\taml->small_header.descriptor_type = (u8)\n\t\t    ((aml->small_header.descriptor_type &\n\t\t      ~ACPI_RESOURCE_NAME_SMALL_LENGTH_MASK)\n\t\t     | resource_length);\n\t}\n}\n\n \n\nvoid\nacpi_rs_set_resource_header(u8 descriptor_type,\n\t\t\t    acpi_rsdesc_size total_length,\n\t\t\t    union aml_resource *aml)\n{\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\taml->small_header.descriptor_type = descriptor_type;\n\n\t \n\n\tacpi_rs_set_resource_length(total_length, aml);\n}\n\n \n\nstatic u16 acpi_rs_strcpy(char *destination, char *source)\n{\n\tu16 i;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tfor (i = 0; source[i]; i++) {\n\t\tdestination[i] = source[i];\n\t}\n\n\tdestination[i] = 0;\n\n\t \n\n\treturn ((u16) (i + 1));\n}\n\n \n\nacpi_rs_length\nacpi_rs_get_resource_source(acpi_rs_length resource_length,\n\t\t\t    acpi_rs_length minimum_length,\n\t\t\t    struct acpi_resource_source * resource_source,\n\t\t\t    union aml_resource * aml, char *string_ptr)\n{\n\tacpi_rsdesc_size total_length;\n\tu8 *aml_resource_source;\n\n\tACPI_FUNCTION_ENTRY();\n\n\ttotal_length =\n\t    resource_length + sizeof(struct aml_resource_large_header);\n\taml_resource_source = ACPI_ADD_PTR(u8, aml, minimum_length);\n\n\t \n\tif (total_length > (acpi_rsdesc_size)(minimum_length + 1)) {\n\n\t\t \n\n\t\tresource_source->index = aml_resource_source[0];\n\n\t\tresource_source->string_ptr = string_ptr;\n\t\tif (!string_ptr) {\n\t\t\t \n\t\t\tresource_source->string_ptr =\n\t\t\t    ACPI_ADD_PTR(char, resource_source,\n\t\t\t\t\t sizeof(struct acpi_resource_source));\n\t\t}\n\n\t\t \n\t\ttotal_length =\n\t\t    (u32)strlen(ACPI_CAST_PTR(char, &aml_resource_source[1])) +\n\t\t    1;\n\n\t\ttotal_length = (u32)ACPI_ROUND_UP_TO_NATIVE_WORD(total_length);\n\n\t\tmemset(resource_source->string_ptr, 0, total_length);\n\n\t\t \n\n\t\tresource_source->string_length =\n\t\t    acpi_rs_strcpy(resource_source->string_ptr,\n\t\t\t\t   ACPI_CAST_PTR(char,\n\t\t\t\t\t\t &aml_resource_source[1]));\n\n\t\treturn ((acpi_rs_length)total_length);\n\t}\n\n\t \n\n\tresource_source->index = 0;\n\tresource_source->string_length = 0;\n\tresource_source->string_ptr = NULL;\n\treturn (0);\n}\n\n \n\nacpi_rsdesc_size\nacpi_rs_set_resource_source(union aml_resource *aml,\n\t\t\t    acpi_rs_length minimum_length,\n\t\t\t    struct acpi_resource_source *resource_source)\n{\n\tu8 *aml_resource_source;\n\tacpi_rsdesc_size descriptor_length;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tdescriptor_length = minimum_length;\n\n\t \n\n\tif (resource_source->string_length) {\n\n\t\t \n\n\t\taml_resource_source = ACPI_ADD_PTR(u8, aml, minimum_length);\n\n\t\t \n\n\t\taml_resource_source[0] = (u8) resource_source->index;\n\n\t\t \n\n\t\tstrcpy(ACPI_CAST_PTR(char, &aml_resource_source[1]),\n\t\t       resource_source->string_ptr);\n\n\t\t \n\t\tdescriptor_length += ((acpi_rsdesc_size)\n\t\t\t\t      resource_source->string_length + 1);\n\t}\n\n\t \n\n\treturn (descriptor_length);\n}\n\n \n\nacpi_status\nacpi_rs_get_prt_method_data(struct acpi_namespace_node *node,\n\t\t\t    struct acpi_buffer *ret_buffer)\n{\n\tunion acpi_operand_object *obj_desc;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(rs_get_prt_method_data);\n\n\t \n\n\t \n\n\tstatus =\n\t    acpi_ut_evaluate_object(node, METHOD_NAME__PRT, ACPI_BTYPE_PACKAGE,\n\t\t\t\t    &obj_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tstatus = acpi_rs_create_pci_routing_table(obj_desc, ret_buffer);\n\n\t \n\n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_rs_get_crs_method_data(struct acpi_namespace_node *node,\n\t\t\t    struct acpi_buffer *ret_buffer)\n{\n\tunion acpi_operand_object *obj_desc;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(rs_get_crs_method_data);\n\n\t \n\n\t \n\n\tstatus =\n\t    acpi_ut_evaluate_object(node, METHOD_NAME__CRS, ACPI_BTYPE_BUFFER,\n\t\t\t\t    &obj_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tstatus = acpi_rs_create_resource_list(obj_desc, ret_buffer);\n\n\t \n\n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_rs_get_prs_method_data(struct acpi_namespace_node *node,\n\t\t\t    struct acpi_buffer *ret_buffer)\n{\n\tunion acpi_operand_object *obj_desc;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(rs_get_prs_method_data);\n\n\t \n\n\t \n\n\tstatus =\n\t    acpi_ut_evaluate_object(node, METHOD_NAME__PRS, ACPI_BTYPE_BUFFER,\n\t\t\t\t    &obj_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tstatus = acpi_rs_create_resource_list(obj_desc, ret_buffer);\n\n\t \n\n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_rs_get_aei_method_data(struct acpi_namespace_node *node,\n\t\t\t    struct acpi_buffer *ret_buffer)\n{\n\tunion acpi_operand_object *obj_desc;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(rs_get_aei_method_data);\n\n\t \n\n\t \n\n\tstatus =\n\t    acpi_ut_evaluate_object(node, METHOD_NAME__AEI, ACPI_BTYPE_BUFFER,\n\t\t\t\t    &obj_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tstatus = acpi_rs_create_resource_list(obj_desc, ret_buffer);\n\n\t \n\n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_rs_get_method_data(acpi_handle handle,\n\t\t\tconst char *path, struct acpi_buffer *ret_buffer)\n{\n\tunion acpi_operand_object *obj_desc;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(rs_get_method_data);\n\n\t \n\n\t \n\n\tstatus =\n\t    acpi_ut_evaluate_object(ACPI_CAST_PTR\n\t\t\t\t    (struct acpi_namespace_node, handle), path,\n\t\t\t\t    ACPI_BTYPE_BUFFER, &obj_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tstatus = acpi_rs_create_resource_list(obj_desc, ret_buffer);\n\n\t \n\n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_rs_set_srs_method_data(struct acpi_namespace_node *node,\n\t\t\t    struct acpi_buffer *in_buffer)\n{\n\tstruct acpi_evaluate_info *info;\n\tunion acpi_operand_object *args[2];\n\tacpi_status status;\n\tstruct acpi_buffer buffer;\n\n\tACPI_FUNCTION_TRACE(rs_set_srs_method_data);\n\n\t \n\n\tinfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\n\tif (!info) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tinfo->prefix_node = node;\n\tinfo->relative_pathname = METHOD_NAME__SRS;\n\tinfo->parameters = args;\n\tinfo->flags = ACPI_IGNORE_RETURN_VALUE;\n\n\t \n\tbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\tstatus = acpi_rs_create_aml_resources(in_buffer, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\targs[0] = acpi_ut_create_internal_object(ACPI_TYPE_BUFFER);\n\tif (!args[0]) {\n\t\t \n\t\tACPI_FREE(buffer.pointer);\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\targs[0]->buffer.length = (u32) buffer.length;\n\targs[0]->buffer.pointer = buffer.pointer;\n\targs[0]->common.flags = AOPOBJ_DATA_VALID;\n\targs[1] = NULL;\n\n\t \n\n\tstatus = acpi_ns_evaluate(info);\n\n\t \n\n\tacpi_ut_remove_reference(args[0]);\n\ncleanup:\n\tACPI_FREE(info);\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}