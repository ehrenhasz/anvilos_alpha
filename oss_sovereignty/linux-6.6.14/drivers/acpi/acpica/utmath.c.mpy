{
  "module_name": "utmath.c",
  "hash_id": "ab9c3c320db5b3c45af4a91d77265c408e419e372c34b9dcc90c12f8fb9703b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utmath.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utmath\")\n\n \ntypedef struct uint64_struct {\n\tu32 lo;\n\tu32 hi;\n\n} uint64_struct;\n\ntypedef union uint64_overlay {\n\tu64 full;\n\tstruct uint64_struct part;\n\n} uint64_overlay;\n\n \n#ifndef ACPI_USE_NATIVE_MATH64\n\n \n\nacpi_status\nacpi_ut_short_multiply(u64 multiplicand, u32 multiplier, u64 *out_product)\n{\n\tunion uint64_overlay multiplicand_ovl;\n\tunion uint64_overlay product;\n\tu32 carry32;\n\n\tACPI_FUNCTION_TRACE(ut_short_multiply);\n\n\tmultiplicand_ovl.full = multiplicand;\n\n\t \n\tACPI_MUL_64_BY_32(0, multiplicand_ovl.part.hi, multiplier,\n\t\t\t  product.part.hi, carry32);\n\n\tACPI_MUL_64_BY_32(0, multiplicand_ovl.part.lo, multiplier,\n\t\t\t  product.part.lo, carry32);\n\n\tproduct.part.hi += carry32;\n\n\t \n\n\tif (out_product) {\n\t\t*out_product = product.full;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status acpi_ut_short_shift_left(u64 operand, u32 count, u64 *out_result)\n{\n\tunion uint64_overlay operand_ovl;\n\n\tACPI_FUNCTION_TRACE(ut_short_shift_left);\n\n\toperand_ovl.full = operand;\n\n\tif ((count & 63) >= 32) {\n\t\toperand_ovl.part.hi = operand_ovl.part.lo;\n\t\toperand_ovl.part.lo = 0;\n\t\tcount = (count & 63) - 32;\n\t}\n\tACPI_SHIFT_LEFT_64_BY_32(operand_ovl.part.hi,\n\t\t\t\t operand_ovl.part.lo, count);\n\n\t \n\n\tif (out_result) {\n\t\t*out_result = operand_ovl.full;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status acpi_ut_short_shift_right(u64 operand, u32 count, u64 *out_result)\n{\n\tunion uint64_overlay operand_ovl;\n\n\tACPI_FUNCTION_TRACE(ut_short_shift_right);\n\n\toperand_ovl.full = operand;\n\n\tif ((count & 63) >= 32) {\n\t\toperand_ovl.part.lo = operand_ovl.part.hi;\n\t\toperand_ovl.part.hi = 0;\n\t\tcount = (count & 63) - 32;\n\t}\n\tACPI_SHIFT_RIGHT_64_BY_32(operand_ovl.part.hi,\n\t\t\t\t  operand_ovl.part.lo, count);\n\n\t \n\n\tif (out_result) {\n\t\t*out_result = operand_ovl.full;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n#else\n\n \n\nacpi_status\nacpi_ut_short_multiply(u64 multiplicand, u32 multiplier, u64 *out_product)\n{\n\n\tACPI_FUNCTION_TRACE(ut_short_multiply);\n\n\t \n\n\tif (out_product) {\n\t\t*out_product = multiplicand * multiplier;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status acpi_ut_short_shift_left(u64 operand, u32 count, u64 *out_result)\n{\n\n\tACPI_FUNCTION_TRACE(ut_short_shift_left);\n\n\t \n\n\tif (out_result) {\n\t\t*out_result = operand << count;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status acpi_ut_short_shift_right(u64 operand, u32 count, u64 *out_result)\n{\n\n\tACPI_FUNCTION_TRACE(ut_short_shift_right);\n\n\t \n\n\tif (out_result) {\n\t\t*out_result = operand >> count;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n#endif\n\n \n#ifndef ACPI_USE_NATIVE_DIVIDE\n\n \n\nacpi_status\nacpi_ut_short_divide(u64 dividend,\n\t\t     u32 divisor, u64 *out_quotient, u32 *out_remainder)\n{\n\tunion uint64_overlay dividend_ovl;\n\tunion uint64_overlay quotient;\n\tu32 remainder32;\n\n\tACPI_FUNCTION_TRACE(ut_short_divide);\n\n\t \n\n\tif (divisor == 0) {\n\t\tACPI_ERROR((AE_INFO, \"Divide by zero\"));\n\t\treturn_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);\n\t}\n\n\tdividend_ovl.full = dividend;\n\n\t \n\tACPI_DIV_64_BY_32(0, dividend_ovl.part.hi, divisor,\n\t\t\t  quotient.part.hi, remainder32);\n\n\tACPI_DIV_64_BY_32(remainder32, dividend_ovl.part.lo, divisor,\n\t\t\t  quotient.part.lo, remainder32);\n\n\t \n\n\tif (out_quotient) {\n\t\t*out_quotient = quotient.full;\n\t}\n\tif (out_remainder) {\n\t\t*out_remainder = remainder32;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ut_divide(u64 in_dividend,\n\t       u64 in_divisor, u64 *out_quotient, u64 *out_remainder)\n{\n\tunion uint64_overlay dividend;\n\tunion uint64_overlay divisor;\n\tunion uint64_overlay quotient;\n\tunion uint64_overlay remainder;\n\tunion uint64_overlay normalized_dividend;\n\tunion uint64_overlay normalized_divisor;\n\tu32 partial1;\n\tunion uint64_overlay partial2;\n\tunion uint64_overlay partial3;\n\n\tACPI_FUNCTION_TRACE(ut_divide);\n\n\t \n\n\tif (in_divisor == 0) {\n\t\tACPI_ERROR((AE_INFO, \"Divide by zero\"));\n\t\treturn_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);\n\t}\n\n\tdivisor.full = in_divisor;\n\tdividend.full = in_dividend;\n\tif (divisor.part.hi == 0) {\n\t\t \n\t\tremainder.part.hi = 0;\n\n\t\t \n\t\tACPI_DIV_64_BY_32(0, dividend.part.hi, divisor.part.lo,\n\t\t\t\t  quotient.part.hi, partial1);\n\n\t\tACPI_DIV_64_BY_32(partial1, dividend.part.lo, divisor.part.lo,\n\t\t\t\t  quotient.part.lo, remainder.part.lo);\n\t}\n\n\telse {\n\t\t \n\t\tquotient.part.hi = 0;\n\t\tnormalized_dividend = dividend;\n\t\tnormalized_divisor = divisor;\n\n\t\t \n\n\t\tdo {\n\t\t\tACPI_SHIFT_RIGHT_64(normalized_divisor.part.hi,\n\t\t\t\t\t    normalized_divisor.part.lo);\n\t\t\tACPI_SHIFT_RIGHT_64(normalized_dividend.part.hi,\n\t\t\t\t\t    normalized_dividend.part.lo);\n\n\t\t} while (normalized_divisor.part.hi != 0);\n\n\t\t \n\n\t\tACPI_DIV_64_BY_32(normalized_dividend.part.hi,\n\t\t\t\t  normalized_dividend.part.lo,\n\t\t\t\t  normalized_divisor.part.lo, quotient.part.lo,\n\t\t\t\t  partial1);\n\n\t\t \n\t\tpartial1 = quotient.part.lo * divisor.part.hi;\n\t\tpartial2.full = (u64) quotient.part.lo * divisor.part.lo;\n\t\tpartial3.full = (u64) partial2.part.hi + partial1;\n\n\t\tremainder.part.hi = partial3.part.lo;\n\t\tremainder.part.lo = partial2.part.lo;\n\n\t\tif (partial3.part.hi == 0) {\n\t\t\tif (partial3.part.lo >= dividend.part.hi) {\n\t\t\t\tif (partial3.part.lo == dividend.part.hi) {\n\t\t\t\t\tif (partial2.part.lo > dividend.part.lo) {\n\t\t\t\t\t\tquotient.part.lo--;\n\t\t\t\t\t\tremainder.full -= divisor.full;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tquotient.part.lo--;\n\t\t\t\t\tremainder.full -= divisor.full;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremainder.full = remainder.full - dividend.full;\n\t\t\tremainder.part.hi = (u32)-((s32)remainder.part.hi);\n\t\t\tremainder.part.lo = (u32)-((s32)remainder.part.lo);\n\n\t\t\tif (remainder.part.lo) {\n\t\t\t\tremainder.part.hi--;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tif (out_quotient) {\n\t\t*out_quotient = quotient.full;\n\t}\n\tif (out_remainder) {\n\t\t*out_remainder = remainder.full;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n#else\n\n \n\nacpi_status\nacpi_ut_short_divide(u64 in_dividend,\n\t\t     u32 divisor, u64 *out_quotient, u32 *out_remainder)\n{\n\n\tACPI_FUNCTION_TRACE(ut_short_divide);\n\n\t \n\n\tif (divisor == 0) {\n\t\tACPI_ERROR((AE_INFO, \"Divide by zero\"));\n\t\treturn_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);\n\t}\n\n\t \n\n\tif (out_quotient) {\n\t\t*out_quotient = in_dividend / divisor;\n\t}\n\tif (out_remainder) {\n\t\t*out_remainder = (u32) (in_dividend % divisor);\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\nacpi_status\nacpi_ut_divide(u64 in_dividend,\n\t       u64 in_divisor, u64 *out_quotient, u64 *out_remainder)\n{\n\tACPI_FUNCTION_TRACE(ut_divide);\n\n\t \n\n\tif (in_divisor == 0) {\n\t\tACPI_ERROR((AE_INFO, \"Divide by zero\"));\n\t\treturn_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);\n\t}\n\n\t \n\n\tif (out_quotient) {\n\t\t*out_quotient = in_dividend / in_divisor;\n\t}\n\tif (out_remainder) {\n\t\t*out_remainder = in_dividend % in_divisor;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}