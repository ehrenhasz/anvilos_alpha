{
  "module_name": "evxfregn.c",
  "hash_id": "d64c4f92f745842e9fce29a87ea115f85966e3b56935ef9026fd7a9874019d4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evxfregn.c",
  "human_readable_source": "\n \n\n#define EXPORT_ACPI_INTERFACES\n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"acevents.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evxfregn\")\n\n \nstatic acpi_status\nacpi_install_address_space_handler_internal(acpi_handle device,\n\t\t\t\t\t    acpi_adr_space_type space_id,\n\t\t\t\t\t    acpi_adr_space_handler handler,\n\t\t\t\t\t    acpi_adr_space_setup setup,\n\t\t\t\t\t    void *context, u8 run_reg)\n{\n\tstruct acpi_namespace_node *node;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_install_address_space_handler);\n\n\t \n\n\tif (!device) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tnode = acpi_ns_validate_handle(device);\n\tif (!node) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tstatus =\n\t    acpi_ev_install_space_handler(node, space_id, handler, setup,\n\t\t\t\t\t  context);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tif (run_reg) {\n\t\tacpi_ev_execute_reg_methods(node, space_id, ACPI_REG_CONNECT);\n\t}\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_ACPI_STATUS(status);\n}\n\nacpi_status\nacpi_install_address_space_handler(acpi_handle device,\n\t\t\t\t   acpi_adr_space_type space_id,\n\t\t\t\t   acpi_adr_space_handler handler,\n\t\t\t\t   acpi_adr_space_setup setup, void *context)\n{\n\treturn acpi_install_address_space_handler_internal(device, space_id,\n\t\t\t\t\t\t\t   handler, setup,\n\t\t\t\t\t\t\t   context, TRUE);\n}\n\nACPI_EXPORT_SYMBOL(acpi_install_address_space_handler)\nacpi_status\nacpi_install_address_space_handler_no_reg(acpi_handle device,\n\t\t\t\t\t  acpi_adr_space_type space_id,\n\t\t\t\t\t  acpi_adr_space_handler handler,\n\t\t\t\t\t  acpi_adr_space_setup setup,\n\t\t\t\t\t  void *context)\n{\n\treturn acpi_install_address_space_handler_internal(device, space_id,\n\t\t\t\t\t\t\t   handler, setup,\n\t\t\t\t\t\t\t   context, FALSE);\n}\n\nACPI_EXPORT_SYMBOL(acpi_install_address_space_handler_no_reg)\n\n \nacpi_status\nacpi_remove_address_space_handler(acpi_handle device,\n\t\t\t\t  acpi_adr_space_type space_id,\n\t\t\t\t  acpi_adr_space_handler handler)\n{\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_operand_object *handler_obj;\n\tunion acpi_operand_object *region_obj;\n\tunion acpi_operand_object **last_obj_ptr;\n\tstruct acpi_namespace_node *node;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_remove_address_space_handler);\n\n\t \n\n\tif (!device) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tnode = acpi_ns_validate_handle(device);\n\tif (!node ||\n\t    ((node->type != ACPI_TYPE_DEVICE) &&\n\t     (node->type != ACPI_TYPE_PROCESSOR) &&\n\t     (node->type != ACPI_TYPE_THERMAL) &&\n\t     (node != acpi_gbl_root_node))) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (!obj_desc) {\n\t\tstatus = AE_NOT_EXIST;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\thandler_obj = obj_desc->common_notify.handler;\n\tlast_obj_ptr = &obj_desc->common_notify.handler;\n\twhile (handler_obj) {\n\n\t\t \n\n\t\tif (handler_obj->address_space.space_id == space_id) {\n\n\t\t\t \n\n\t\t\tif (handler_obj->address_space.handler != handler) {\n\t\t\t\tstatus = AE_BAD_PARAMETER;\n\t\t\t\tgoto unlock_and_exit;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t\t\t  \"Removing address handler %p(%p) for region %s \"\n\t\t\t\t\t  \"on Device %p(%p)\\n\",\n\t\t\t\t\t  handler_obj, handler,\n\t\t\t\t\t  acpi_ut_get_region_name(space_id),\n\t\t\t\t\t  node, obj_desc));\n\n\t\t\tregion_obj = handler_obj->address_space.region_list;\n\n\t\t\t \n\n\t\t\twhile (region_obj) {\n\t\t\t\t \n\t\t\t\tacpi_ev_detach_region(region_obj, TRUE);\n\n\t\t\t\t \n\t\t\t\tregion_obj =\n\t\t\t\t    handler_obj->address_space.region_list;\n\t\t\t}\n\n\t\t\t \n\n\t\t\t*last_obj_ptr = handler_obj->address_space.next;\n\n\t\t\t \n\n\t\t\tacpi_os_release_mutex(handler_obj->address_space.\n\t\t\t\t\t      context_mutex);\n\t\t\tacpi_ut_remove_reference(handler_obj);\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\n\t\t \n\n\t\tlast_obj_ptr = &handler_obj->address_space.next;\n\t\thandler_obj = handler_obj->address_space.next;\n\t}\n\n\t \n\n\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t  \"Unable to remove address handler %p for %s(%X), DevNode %p, obj %p\\n\",\n\t\t\t  handler, acpi_ut_get_region_name(space_id), space_id,\n\t\t\t  node, obj_desc));\n\n\tstatus = AE_NOT_EXIST;\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_remove_address_space_handler)\n \nacpi_status\nacpi_execute_reg_methods(acpi_handle device, acpi_adr_space_type space_id)\n{\n\tstruct acpi_namespace_node *node;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_execute_reg_methods);\n\n\t \n\n\tif (!device) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tnode = acpi_ns_validate_handle(device);\n\tif (node) {\n\n\t\t \n\n\t\tacpi_ev_execute_reg_methods(node, space_id, ACPI_REG_CONNECT);\n\t} else {\n\t\tstatus = AE_BAD_PARAMETER;\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_execute_reg_methods)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}