{
  "module_name": "utinit.c",
  "hash_id": "f74d5d8c0e95efb68bbcc2d11bdc6420bccadfd8c06a6e399e40f38659160a92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utinit.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"acevents.h\"\n#include \"actables.h\"\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utinit\")\n\n \nstatic void acpi_ut_terminate(void);\n\n#if (!ACPI_REDUCED_HARDWARE)\n\nstatic void acpi_ut_free_gpe_lists(void);\n\n#else\n\n#define acpi_ut_free_gpe_lists()\n#endif\t\t\t\t \n\n#if (!ACPI_REDUCED_HARDWARE)\n \n\nstatic void acpi_ut_free_gpe_lists(void)\n{\n\tstruct acpi_gpe_block_info *gpe_block;\n\tstruct acpi_gpe_block_info *next_gpe_block;\n\tstruct acpi_gpe_xrupt_info *gpe_xrupt_info;\n\tstruct acpi_gpe_xrupt_info *next_gpe_xrupt_info;\n\n\t \n\n\tgpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;\n\twhile (gpe_xrupt_info) {\n\t\tgpe_block = gpe_xrupt_info->gpe_block_list_head;\n\t\twhile (gpe_block) {\n\t\t\tnext_gpe_block = gpe_block->next;\n\t\t\tACPI_FREE(gpe_block->event_info);\n\t\t\tACPI_FREE(gpe_block->register_info);\n\t\t\tACPI_FREE(gpe_block);\n\n\t\t\tgpe_block = next_gpe_block;\n\t\t}\n\t\tnext_gpe_xrupt_info = gpe_xrupt_info->next;\n\t\tACPI_FREE(gpe_xrupt_info);\n\t\tgpe_xrupt_info = next_gpe_xrupt_info;\n\t}\n}\n#endif\t\t\t\t \n\n \n\nacpi_status acpi_ut_init_globals(void)\n{\n\tacpi_status status;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ut_init_globals);\n\n\t \n\n\tstatus = acpi_ut_create_caches();\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tfor (i = 0; i < ACPI_ADDRESS_RANGE_MAX; i++) {\n\t\tacpi_gbl_address_range_list[i] = NULL;\n\t}\n\n\t \n\n\tfor (i = 0; i < ACPI_NUM_MUTEX; i++) {\n\t\tacpi_gbl_mutex_info[i].mutex = NULL;\n\t\tacpi_gbl_mutex_info[i].thread_id = ACPI_MUTEX_NOT_ACQUIRED;\n\t\tacpi_gbl_mutex_info[i].use_count = 0;\n\t}\n\n\tfor (i = 0; i < ACPI_NUM_OWNERID_MASKS; i++) {\n\t\tacpi_gbl_owner_id_mask[i] = 0;\n\t}\n\n\t \n\n\tacpi_gbl_owner_id_mask[ACPI_NUM_OWNERID_MASKS - 1] = 0x80000000;\n\n\t \n\n\tacpi_method_count = 0;\n\tacpi_sci_count = 0;\n\tacpi_gpe_count = 0;\n\n\tfor (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {\n\t\tacpi_fixed_event_count[i] = 0;\n\t}\n\n#if (!ACPI_REDUCED_HARDWARE)\n\n\t \n\n\tacpi_gbl_all_gpes_initialized = FALSE;\n\tacpi_gbl_gpe_xrupt_list_head = NULL;\n\tacpi_gbl_gpe_fadt_blocks[0] = NULL;\n\tacpi_gbl_gpe_fadt_blocks[1] = NULL;\n\tacpi_current_gpe_count = 0;\n\n\tacpi_gbl_global_event_handler = NULL;\n\tacpi_gbl_sci_handler_list = NULL;\n\n#endif\t\t\t\t \n\n\t \n\n\tacpi_gbl_global_notify[0].handler = NULL;\n\tacpi_gbl_global_notify[1].handler = NULL;\n\tacpi_gbl_exception_handler = NULL;\n\tacpi_gbl_init_handler = NULL;\n\tacpi_gbl_table_handler = NULL;\n\tacpi_gbl_interface_handler = NULL;\n\n\t \n\n\tacpi_gbl_global_lock_semaphore = NULL;\n\tacpi_gbl_global_lock_mutex = NULL;\n\tacpi_gbl_global_lock_acquired = FALSE;\n\tacpi_gbl_global_lock_handle = 0;\n\tacpi_gbl_global_lock_present = FALSE;\n\n\t \n\n\tacpi_gbl_DSDT = NULL;\n\tacpi_gbl_cm_single_step = FALSE;\n\tacpi_gbl_shutdown = FALSE;\n\tacpi_gbl_ns_lookup_count = 0;\n\tacpi_gbl_ps_find_count = 0;\n\tacpi_gbl_acpi_hardware_present = TRUE;\n\tacpi_gbl_last_owner_id_index = 0;\n\tacpi_gbl_next_owner_id_offset = 0;\n\tacpi_gbl_debugger_configuration = DEBUGGER_THREADING;\n\tacpi_gbl_osi_mutex = NULL;\n\n\t \n\n\tacpi_gbl_events_initialized = FALSE;\n\tacpi_gbl_system_awake_and_running = TRUE;\n\n\t \n\n\tacpi_gbl_root_node = NULL;\n\tacpi_gbl_root_node_struct.name.integer = ACPI_ROOT_NAME;\n\tacpi_gbl_root_node_struct.descriptor_type = ACPI_DESC_TYPE_NAMED;\n\tacpi_gbl_root_node_struct.type = ACPI_TYPE_DEVICE;\n\tacpi_gbl_root_node_struct.parent = NULL;\n\tacpi_gbl_root_node_struct.child = NULL;\n\tacpi_gbl_root_node_struct.peer = NULL;\n\tacpi_gbl_root_node_struct.object = NULL;\n\n#ifdef ACPI_DISASSEMBLER\n\tacpi_gbl_external_list = NULL;\n\tacpi_gbl_num_external_methods = 0;\n\tacpi_gbl_resolved_external_methods = 0;\n#endif\n\n#ifdef ACPI_DEBUG_OUTPUT\n\tacpi_gbl_lowest_stack_pointer = ACPI_CAST_PTR(acpi_size, ACPI_SIZE_MAX);\n#endif\n\n#ifdef ACPI_DBG_TRACK_ALLOCATIONS\n\tacpi_gbl_display_final_mem_stats = FALSE;\n\tacpi_gbl_disable_mem_tracking = FALSE;\n#endif\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nstatic void acpi_ut_terminate(void)\n{\n\tACPI_FUNCTION_TRACE(ut_terminate);\n\n\tacpi_ut_free_gpe_lists();\n\tacpi_ut_delete_address_lists();\n\treturn_VOID;\n}\n\n \n\nvoid acpi_ut_subsystem_shutdown(void)\n{\n\tACPI_FUNCTION_TRACE(ut_subsystem_shutdown);\n\n\t \n\n\tif (acpi_gbl_shutdown) {\n\t\tACPI_ERROR((AE_INFO, \"ACPI Subsystem is already terminated\"));\n\t\treturn_VOID;\n\t}\n\n\t \n\n\tacpi_gbl_shutdown = TRUE;\n\tacpi_gbl_startup_flags = 0;\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO, \"Shutting down ACPI Subsystem\\n\"));\n\n#ifndef ACPI_ASL_COMPILER\n\n\t \n\n\tacpi_ev_terminate();\n\n\t \n\n\tacpi_ut_interface_terminate();\n#endif\n\n\t \n\n\tacpi_ns_terminate();\n\n\t \n\n\tacpi_tb_terminate();\n\n\t \n\n\tacpi_ut_terminate();\n\n\t \n\n\t(void)acpi_ut_delete_caches();\n\treturn_VOID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}