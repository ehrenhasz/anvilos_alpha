{
  "module_name": "utaddress.c",
  "hash_id": "557cc67774f7bc46745c6dabe7dc4191268491be1cff52aa6aa0becf8f8f7065",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utaddress.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utaddress\")\n\n \nacpi_status\nacpi_ut_add_address_range(acpi_adr_space_type space_id,\n\t\t\t  acpi_physical_address address,\n\t\t\t  u32 length, struct acpi_namespace_node *region_node)\n{\n\tstruct acpi_address_range *range_info;\n\n\tACPI_FUNCTION_TRACE(ut_add_address_range);\n\n\tif ((space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) &&\n\t    (space_id != ACPI_ADR_SPACE_SYSTEM_IO)) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\trange_info = ACPI_ALLOCATE(sizeof(struct acpi_address_range));\n\tif (!range_info) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\trange_info->start_address = address;\n\trange_info->end_address = (address + length - 1);\n\trange_info->region_node = region_node;\n\n\trange_info->next = acpi_gbl_address_range_list[space_id];\n\tacpi_gbl_address_range_list[space_id] = range_info;\n\n\tACPI_DEBUG_PRINT((ACPI_DB_NAMES,\n\t\t\t  \"\\nAdded [%4.4s] address range: 0x%8.8X%8.8X-0x%8.8X%8.8X\\n\",\n\t\t\t  acpi_ut_get_node_name(range_info->region_node),\n\t\t\t  ACPI_FORMAT_UINT64(address),\n\t\t\t  ACPI_FORMAT_UINT64(range_info->end_address)));\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nvoid\nacpi_ut_remove_address_range(acpi_adr_space_type space_id,\n\t\t\t     struct acpi_namespace_node *region_node)\n{\n\tstruct acpi_address_range *range_info;\n\tstruct acpi_address_range *prev;\n\n\tACPI_FUNCTION_TRACE(ut_remove_address_range);\n\n\tif ((space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) &&\n\t    (space_id != ACPI_ADR_SPACE_SYSTEM_IO)) {\n\t\treturn_VOID;\n\t}\n\n\t \n\n\trange_info = prev = acpi_gbl_address_range_list[space_id];\n\twhile (range_info) {\n\t\tif (range_info->region_node == region_node) {\n\t\t\tif (range_info == prev) {\t \n\t\t\t\tacpi_gbl_address_range_list[space_id] =\n\t\t\t\t    range_info->next;\n\t\t\t} else {\n\t\t\t\tprev->next = range_info->next;\n\t\t\t}\n\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_NAMES,\n\t\t\t\t\t  \"\\nRemoved [%4.4s] address range: 0x%8.8X%8.8X-0x%8.8X%8.8X\\n\",\n\t\t\t\t\t  acpi_ut_get_node_name(range_info->\n\t\t\t\t\t\t\t\tregion_node),\n\t\t\t\t\t  ACPI_FORMAT_UINT64(range_info->\n\t\t\t\t\t\t\t     start_address),\n\t\t\t\t\t  ACPI_FORMAT_UINT64(range_info->\n\t\t\t\t\t\t\t     end_address)));\n\n\t\t\tACPI_FREE(range_info);\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tprev = range_info;\n\t\trange_info = range_info->next;\n\t}\n\n\treturn_VOID;\n}\n\n \n\nu32\nacpi_ut_check_address_range(acpi_adr_space_type space_id,\n\t\t\t    acpi_physical_address address, u32 length, u8 warn)\n{\n\tstruct acpi_address_range *range_info;\n\tacpi_physical_address end_address;\n\tchar *pathname;\n\tu32 overlap_count = 0;\n\n\tACPI_FUNCTION_TRACE(ut_check_address_range);\n\n\tif ((space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) &&\n\t    (space_id != ACPI_ADR_SPACE_SYSTEM_IO)) {\n\t\treturn_UINT32(0);\n\t}\n\n\trange_info = acpi_gbl_address_range_list[space_id];\n\tend_address = address + length - 1;\n\n\t \n\n\twhile (range_info) {\n\t\t \n\t\tif ((address <= range_info->end_address) &&\n\t\t    (end_address >= range_info->start_address)) {\n\n\t\t\t \n\n\t\t\toverlap_count++;\n\t\t\tif (warn) {\t \n\t\t\t\tpathname =\n\t\t\t\t    acpi_ns_get_normalized_pathname(range_info->\n\t\t\t\t\t\t\t\t    region_node,\n\t\t\t\t\t\t\t\t    TRUE);\n\n\t\t\t\tACPI_WARNING((AE_INFO,\n\t\t\t\t\t      \"%s range 0x%8.8X%8.8X-0x%8.8X%8.8X conflicts with OpRegion 0x%8.8X%8.8X-0x%8.8X%8.8X (%s)\",\n\t\t\t\t\t      acpi_ut_get_region_name(space_id),\n\t\t\t\t\t      ACPI_FORMAT_UINT64(address),\n\t\t\t\t\t      ACPI_FORMAT_UINT64(end_address),\n\t\t\t\t\t      ACPI_FORMAT_UINT64(range_info->\n\t\t\t\t\t\t\t\t start_address),\n\t\t\t\t\t      ACPI_FORMAT_UINT64(range_info->\n\t\t\t\t\t\t\t\t end_address),\n\t\t\t\t\t      pathname));\n\t\t\t\tACPI_FREE(pathname);\n\t\t\t}\n\t\t}\n\n\t\trange_info = range_info->next;\n\t}\n\n\treturn_UINT32(overlap_count);\n}\n\n \n\nvoid acpi_ut_delete_address_lists(void)\n{\n\tstruct acpi_address_range *next;\n\tstruct acpi_address_range *range_info;\n\tint i;\n\n\t \n\n\tfor (i = 0; i < ACPI_ADDRESS_RANGE_MAX; i++) {\n\t\tnext = acpi_gbl_address_range_list[i];\n\n\t\twhile (next) {\n\t\t\trange_info = next;\n\t\t\tnext = range_info->next;\n\t\t\tACPI_FREE(range_info);\n\t\t}\n\n\t\tacpi_gbl_address_range_list[i] = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}