{
  "module_name": "dspkginit.c",
  "hash_id": "f255592de6a1a6cc99773486f6b0e70ba2fbf99f342be1045418565395962510",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/dspkginit.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"amlcode.h\"\n#include \"acdispat.h\"\n#include \"acinterp.h\"\n#include \"acparser.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\nACPI_MODULE_NAME(\"dspkginit\")\n\n \nstatic void\nacpi_ds_resolve_package_element(union acpi_operand_object **element);\n\n \n\nacpi_status\nacpi_ds_build_internal_package_obj(struct acpi_walk_state *walk_state,\n\t\t\t\t   union acpi_parse_object *op,\n\t\t\t\t   u32 element_count,\n\t\t\t\t   union acpi_operand_object **obj_desc_ptr)\n{\n\tunion acpi_parse_object *arg;\n\tunion acpi_parse_object *parent;\n\tunion acpi_operand_object *obj_desc = NULL;\n\tacpi_status status = AE_OK;\n\tu8 module_level_code = FALSE;\n\tu16 reference_count;\n\tu32 index;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ds_build_internal_package_obj);\n\n\t \n\n\tif (walk_state->parse_flags & ACPI_PARSE_MODULE_LEVEL) {\n\t\tmodule_level_code = TRUE;\n\t}\n\n\t \n\n\tparent = op->common.parent;\n\twhile ((parent->common.aml_opcode == AML_PACKAGE_OP) ||\n\t       (parent->common.aml_opcode == AML_VARIABLE_PACKAGE_OP)) {\n\t\tparent = parent->common.parent;\n\t}\n\n\t \n\tobj_desc = *obj_desc_ptr;\n\tif (!obj_desc) {\n\t\tobj_desc = acpi_ut_create_internal_object(ACPI_TYPE_PACKAGE);\n\t\t*obj_desc_ptr = obj_desc;\n\t\tif (!obj_desc) {\n\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t}\n\n\t\tobj_desc->package.node = parent->common.node;\n\t}\n\n\tif (obj_desc->package.flags & AOPOBJ_DATA_VALID) {\t \n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\tif (!obj_desc->package.elements) {\n\t\tobj_desc->package.elements = ACPI_ALLOCATE_ZEROED(((acpi_size)\n\t\t\t\t\t\t\t\t   element_count\n\t\t\t\t\t\t\t\t   +\n\t\t\t\t\t\t\t\t   1) *\n\t\t\t\t\t\t\t\t  sizeof(void\n\t\t\t\t\t\t\t\t\t *));\n\n\t\tif (!obj_desc->package.elements) {\n\t\t\tacpi_ut_delete_object_desc(obj_desc);\n\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t}\n\n\t\tobj_desc->package.count = element_count;\n\t}\n\n\t \n\n\targ = op->common.value.arg;\n\targ = arg->common.next;\n\n\t \n\tif (module_level_code) {\n\t\tobj_desc->package.aml_start = walk_state->aml;\n\t\tobj_desc->package.aml_length = 0;\n\n\t\tACPI_DEBUG_PRINT_RAW((ACPI_DB_PARSE,\n\t\t\t\t      \"%s: Deferring resolution of Package elements\\n\",\n\t\t\t\t      ACPI_GET_FUNCTION_NAME));\n\t}\n\n\t \n\tfor (i = 0; arg && (i < element_count); i++) {\n\t\tif (arg->common.aml_opcode == AML_INT_RETURN_VALUE_OP) {\n\t\t\tif (!arg->common.node) {\n\t\t\t\t \n\t\t\t\tACPI_EXCEPTION((AE_INFO, AE_SUPPORT,\n\t\t\t\t\t\t\"Expressions within package elements are not supported\"));\n\n\t\t\t\t \n\n\t\t\t\tacpi_ut_remove_reference(walk_state->results->\n\t\t\t\t\t\t\t results.obj_desc[0]);\n\t\t\t\treturn_ACPI_STATUS(AE_SUPPORT);\n\t\t\t}\n\n\t\t\tif (arg->common.node->type == ACPI_TYPE_METHOD) {\n\t\t\t\t \n\t\t\t\targ->common.aml_opcode = AML_INT_NAMEPATH_OP;\n\t\t\t\tstatus =\n\t\t\t\t    acpi_ds_build_internal_object(walk_state,\n\t\t\t\t\t\t\t\t  arg,\n\t\t\t\t\t\t\t\t  &obj_desc->\n\t\t\t\t\t\t\t\t  package.\n\t\t\t\t\t\t\t\t  elements[i]);\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\tobj_desc->package.elements[i] =\n\t\t\t\t    ACPI_CAST_PTR(union acpi_operand_object,\n\t\t\t\t\t\t  arg->common.node);\n\t\t\t}\n\t\t} else {\n\t\t\tstatus =\n\t\t\t    acpi_ds_build_internal_object(walk_state, arg,\n\t\t\t\t\t\t\t  &obj_desc->package.\n\t\t\t\t\t\t\t  elements[i]);\n\t\t\tif (status == AE_NOT_FOUND) {\n\t\t\t\tACPI_ERROR((AE_INFO, \"%-48s\",\n\t\t\t\t\t    \"****DS namepath not found\"));\n\t\t\t}\n\n\t\t\tif (!module_level_code) {\n\t\t\t\t \n\t\t\t\tacpi_ds_init_package_element(0,\n\t\t\t\t\t\t\t     obj_desc->package.\n\t\t\t\t\t\t\t     elements[i], NULL,\n\t\t\t\t\t\t\t     &obj_desc->package.\n\t\t\t\t\t\t\t     elements[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (*obj_desc_ptr) {\n\n\t\t\t \n\n\t\t\treference_count =\n\t\t\t    (*obj_desc_ptr)->common.reference_count;\n\t\t\tif (reference_count > 1) {\n\n\t\t\t\t \n\t\t\t\t \n\n\t\t\t\tfor (index = 0;\n\t\t\t\t     index < ((u32)reference_count - 1);\n\t\t\t\t     index++) {\n\t\t\t\t\tacpi_ut_add_reference((obj_desc->\n\t\t\t\t\t\t\t       package.\n\t\t\t\t\t\t\t       elements[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\targ = arg->common.next;\n\t}\n\n\t \n\n\tif (arg) {\n\t\t \n\t\twhile (arg) {\n\t\t\t \n\t\t\tif (arg->common.node) {\n\t\t\t\tacpi_ut_remove_reference(ACPI_CAST_PTR\n\t\t\t\t\t\t\t (union\n\t\t\t\t\t\t\t  acpi_operand_object,\n\t\t\t\t\t\t\t  arg->common.node));\n\t\t\t\targ->common.node = NULL;\n\t\t\t}\n\n\t\t\t \n\n\t\t\ti++;\n\t\t\targ = arg->common.next;\n\t\t}\n\n\t\tACPI_INFO((\"Actual Package length (%u) is larger than \"\n\t\t\t   \"NumElements field (%u), truncated\",\n\t\t\t   i, element_count));\n\t} else if (i < element_count) {\n\t\t \n\t\tACPI_DEBUG_PRINT_RAW((ACPI_DB_INFO,\n\t\t\t\t      \"%s: Package List length (%u) smaller than NumElements \"\n\t\t\t\t      \"count (%u), padded with null elements\\n\",\n\t\t\t\t      ACPI_GET_FUNCTION_NAME, i,\n\t\t\t\t      element_count));\n\t}\n\n\t \n\n\tif (!module_level_code) {\n\t\tobj_desc->package.flags |= AOPOBJ_DATA_VALID;\n\t}\n\n\top->common.node = ACPI_CAST_PTR(struct acpi_namespace_node, obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ds_init_package_element(u8 object_type,\n\t\t\t     union acpi_operand_object *source_object,\n\t\t\t     union acpi_generic_state *state, void *context)\n{\n\tunion acpi_operand_object **element_ptr;\n\n\tACPI_FUNCTION_TRACE(ds_init_package_element);\n\n\tif (!source_object) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\tif (context) {\n\n\t\t \n\n\t\telement_ptr = (union acpi_operand_object **)context;\n\t} else {\n\t\t \n\n\t\telement_ptr = state->pkg.this_target_obj;\n\t}\n\n\t \n\n\tif (source_object->common.type == ACPI_TYPE_LOCAL_REFERENCE) {\n\n\t\t \n\n\t\tacpi_ds_resolve_package_element(element_ptr);\n\t} else if (source_object->common.type == ACPI_TYPE_PACKAGE) {\n\t\tsource_object->package.flags |= AOPOBJ_DATA_VALID;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nstatic void\nacpi_ds_resolve_package_element(union acpi_operand_object **element_ptr)\n{\n\tacpi_status status;\n\tacpi_status status2;\n\tunion acpi_generic_state scope_info;\n\tunion acpi_operand_object *element = *element_ptr;\n\tstruct acpi_namespace_node *resolved_node;\n\tstruct acpi_namespace_node *original_node;\n\tchar *external_path = \"\";\n\tacpi_object_type type;\n\n\tACPI_FUNCTION_TRACE(ds_resolve_package_element);\n\n\t \n\n\tif (element->reference.resolved) {\n\t\tACPI_DEBUG_PRINT_RAW((ACPI_DB_PARSE,\n\t\t\t\t      \"%s: Package element is already resolved\\n\",\n\t\t\t\t      ACPI_GET_FUNCTION_NAME));\n\n\t\treturn_VOID;\n\t}\n\n\t \n\n\tscope_info.scope.node = element->reference.node;\t \n\n\tstatus = acpi_ns_lookup(&scope_info, (char *)element->reference.aml,\n\t\t\t\tACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,\n\t\t\t\tACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,\n\t\t\t\tNULL, &resolved_node);\n\tif (ACPI_FAILURE(status)) {\n\t\tif ((status == AE_NOT_FOUND)\n\t\t    && acpi_gbl_ignore_package_resolution_errors) {\n\t\t\t \n\n\t\t\t \n\n\t\t\tacpi_ut_remove_reference(*element_ptr);\n\t\t\t*element_ptr = NULL;\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tstatus2 = acpi_ns_externalize_name(ACPI_UINT32_MAX,\n\t\t\t\t\t\t   (char *)element->reference.\n\t\t\t\t\t\t   aml, NULL, &external_path);\n\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"While resolving a named reference package element - %s\",\n\t\t\t\texternal_path));\n\t\tif (ACPI_SUCCESS(status2)) {\n\t\t\tACPI_FREE(external_path);\n\t\t}\n\n\t\t \n\n\t\tacpi_ut_remove_reference(*element_ptr);\n\t\t*element_ptr = NULL;\n\t\treturn_VOID;\n\t} else if (resolved_node->type == ACPI_TYPE_ANY) {\n\n\t\t \n\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Could not resolve named package element [%4.4s] in [%4.4s]\",\n\t\t\t    resolved_node->name.ascii,\n\t\t\t    scope_info.scope.node->name.ascii));\n\t\t*element_ptr = NULL;\n\t\treturn_VOID;\n\t}\n\n\t \n\tif (resolved_node->type == ACPI_TYPE_LOCAL_ALIAS) {\n\t\tresolved_node = ACPI_CAST_PTR(struct acpi_namespace_node,\n\t\t\t\t\t      resolved_node->object);\n\t}\n\n\t \n\n\telement->reference.resolved = TRUE;\n\telement->reference.node = resolved_node;\n\ttype = element->reference.node->type;\n\n\t \n\toriginal_node = resolved_node;\n\tstatus = acpi_ex_resolve_node_to_value(&resolved_node, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_VOID;\n\t}\n\n\tswitch (type) {\n\t\t \n\tcase ACPI_TYPE_DEVICE:\n\tcase ACPI_TYPE_THERMAL:\n\tcase ACPI_TYPE_METHOD:\n\t\tbreak;\n\n\tcase ACPI_TYPE_MUTEX:\n\tcase ACPI_TYPE_POWER:\n\tcase ACPI_TYPE_PROCESSOR:\n\tcase ACPI_TYPE_EVENT:\n\tcase ACPI_TYPE_REGION:\n\n\t\t \n\n\t\tacpi_ut_remove_reference(original_node->object);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tacpi_ut_remove_reference(element);\n\t\t*element_ptr = (union acpi_operand_object *)resolved_node;\n\t\tbreak;\n\t}\n\n\treturn_VOID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}