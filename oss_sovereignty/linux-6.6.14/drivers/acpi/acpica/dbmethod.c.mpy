{
  "module_name": "dbmethod.c",
  "hash_id": "bc47f23af5a6dc7c98c3c78eb08ffd3a4bd42b5b12418f6dbc4475a4b6db93b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/dbmethod.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acdispat.h\"\n#include \"acnamesp.h\"\n#include \"acdebug.h\"\n#include \"acparser.h\"\n#include \"acpredef.h\"\n\n#define _COMPONENT          ACPI_CA_DEBUGGER\nACPI_MODULE_NAME(\"dbmethod\")\n\n \nstatic acpi_status\nacpi_db_walk_for_execute(acpi_handle obj_handle,\n\t\t\t u32 nesting_level, void *context, void **return_value);\n\nstatic acpi_status acpi_db_evaluate_object(struct acpi_namespace_node *node);\n\n \n\nvoid\nacpi_db_set_method_breakpoint(char *location,\n\t\t\t      struct acpi_walk_state *walk_state,\n\t\t\t      union acpi_parse_object *op)\n{\n\tu32 address;\n\tu32 aml_offset;\n\n\tif (!op) {\n\t\tacpi_os_printf(\"There is no method currently executing\\n\");\n\t\treturn;\n\t}\n\n\t \n\n\taddress = strtoul(location, NULL, 16);\n\taml_offset = (u32)ACPI_PTR_DIFF(op->common.aml,\n\t\t\t\t\twalk_state->parser_state.aml_start);\n\tif (address <= aml_offset) {\n\t\tacpi_os_printf(\"Breakpoint %X is beyond current address %X\\n\",\n\t\t\t       address, aml_offset);\n\t}\n\n\t \n\n\twalk_state->user_breakpoint = address;\n\tacpi_os_printf(\"Breakpoint set at AML offset %X\\n\", address);\n}\n\n \n\nvoid acpi_db_set_method_call_breakpoint(union acpi_parse_object *op)\n{\n\n\tif (!op) {\n\t\tacpi_os_printf(\"There is no method currently executing\\n\");\n\t\treturn;\n\t}\n\n\tacpi_gbl_step_to_next_call = TRUE;\n}\n\n \n\nvoid acpi_db_set_method_data(char *type_arg, char *index_arg, char *value_arg)\n{\n\tchar type;\n\tu32 index;\n\tu32 value;\n\tstruct acpi_walk_state *walk_state;\n\tunion acpi_operand_object *obj_desc;\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\n\t \n\n\tacpi_ut_strupr(type_arg);\n\ttype = type_arg[0];\n\tif ((type != 'L') && (type != 'A') && (type != 'N')) {\n\t\tacpi_os_printf(\"Invalid SET operand: %s\\n\", type_arg);\n\t\treturn;\n\t}\n\n\tvalue = strtoul(value_arg, NULL, 16);\n\n\tif (type == 'N') {\n\t\tnode = acpi_db_convert_to_node(index_arg);\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (node->type != ACPI_TYPE_INTEGER) {\n\t\t\tacpi_os_printf(\"Can only set Integer nodes\\n\");\n\t\t\treturn;\n\t\t}\n\t\tobj_desc = node->object;\n\t\tobj_desc->integer.value = value;\n\t\treturn;\n\t}\n\n\t \n\n\tindex = strtoul(index_arg, NULL, 16);\n\n\twalk_state = acpi_ds_get_current_walk_state(acpi_gbl_current_walk_list);\n\tif (!walk_state) {\n\t\tacpi_os_printf(\"There is no method currently executing\\n\");\n\t\treturn;\n\t}\n\n\t \n\n\tobj_desc = acpi_ut_create_integer_object((u64)value);\n\tif (!obj_desc) {\n\t\tacpi_os_printf(\"Could not create an internal object\\n\");\n\t\treturn;\n\t}\n\n\t \n\n\tswitch (type) {\n\tcase 'A':\n\n\t\t \n\n\t\tif (index > ACPI_METHOD_MAX_ARG) {\n\t\t\tacpi_os_printf(\"Arg%u - Invalid argument name\\n\",\n\t\t\t\t       index);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tstatus = acpi_ds_store_object_to_local(ACPI_REFCLASS_ARG,\n\t\t\t\t\t\t       index, obj_desc,\n\t\t\t\t\t\t       walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tobj_desc = walk_state->arguments[index].object;\n\n\t\tacpi_os_printf(\"Arg%u: \", index);\n\t\tacpi_db_display_internal_object(obj_desc, walk_state);\n\t\tbreak;\n\n\tcase 'L':\n\n\t\t \n\n\t\tif (index > ACPI_METHOD_MAX_LOCAL) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Local%u - Invalid local variable name\\n\", index);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tstatus = acpi_ds_store_object_to_local(ACPI_REFCLASS_LOCAL,\n\t\t\t\t\t\t       index, obj_desc,\n\t\t\t\t\t\t       walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tobj_desc = walk_state->local_variables[index].object;\n\n\t\tacpi_os_printf(\"Local%u: \", index);\n\t\tacpi_db_display_internal_object(obj_desc, walk_state);\n\t\tbreak;\n\n\tdefault:\n\n\t\tbreak;\n\t}\n\ncleanup:\n\tacpi_ut_remove_reference(obj_desc);\n}\n\n#ifdef ACPI_DISASSEMBLER\n \n\nvoid acpi_db_disassemble_aml(char *statements, union acpi_parse_object *op)\n{\n\tu32 num_statements = 8;\n\n\tif (!op) {\n\t\tacpi_os_printf(\"There is no method currently executing\\n\");\n\t\treturn;\n\t}\n\n\tif (statements) {\n\t\tnum_statements = strtoul(statements, NULL, 0);\n\t}\n\n\tacpi_dm_disassemble(NULL, op, num_statements);\n}\n\n \n\nacpi_status acpi_db_disassemble_method(char *name)\n{\n\tacpi_status status;\n\tunion acpi_parse_object *op;\n\tstruct acpi_walk_state *walk_state;\n\tunion acpi_operand_object *obj_desc;\n\tstruct acpi_namespace_node *method;\n\n\tmethod = acpi_db_convert_to_node(name);\n\tif (!method) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tif (method->type != ACPI_TYPE_METHOD) {\n\t\tACPI_ERROR((AE_INFO, \"%s (%s): Object must be a control method\",\n\t\t\t    name, acpi_ut_get_type_name(method->type)));\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tobj_desc = method->object;\n\n\top = acpi_ps_create_scope_op(obj_desc->method.aml_start);\n\tif (!op) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\t \n\n\twalk_state = acpi_ds_create_walk_state(0, op, NULL, NULL);\n\tif (!walk_state) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\tstatus = acpi_ds_init_aml_walk(walk_state, op, NULL,\n\t\t\t\t       obj_desc->method.aml_start,\n\t\t\t\t       obj_desc->method.aml_length, NULL,\n\t\t\t\t       ACPI_IMODE_LOAD_PASS1);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tstatus = acpi_ut_allocate_owner_id(&obj_desc->method.owner_id);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\twalk_state->owner_id = obj_desc->method.owner_id;\n\n\t \n\n\tstatus = acpi_ds_scope_stack_push(method, method->type, walk_state);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\twalk_state->parse_flags &= ~ACPI_PARSE_DELETE_TREE;\n\twalk_state->parse_flags |= ACPI_PARSE_DISASSEMBLE;\n\n\tstatus = acpi_ps_parse_aml(walk_state);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t(void)acpi_dm_parse_deferred_ops(op);\n\n\t \n\n\tacpi_gbl_dm_opt_verbose = FALSE;\n\tacpi_dm_disassemble(NULL, op, 0);\n\tacpi_gbl_dm_opt_verbose = TRUE;\n\n\tacpi_ps_delete_parse_tree(op);\n\n\t \n\n\tacpi_ns_delete_namespace_subtree(method);\n\tacpi_ns_delete_namespace_by_owner(obj_desc->method.owner_id);\n\tacpi_ut_release_owner_id(&obj_desc->method.owner_id);\n\treturn (AE_OK);\n}\n#endif\n\n \n\nstatic acpi_status acpi_db_evaluate_object(struct acpi_namespace_node *node)\n{\n\tchar *pathname;\n\tu32 i;\n\tstruct acpi_device_info *obj_info;\n\tstruct acpi_object_list param_objects;\n\tunion acpi_object params[ACPI_METHOD_NUM_ARGS];\n\tstruct acpi_buffer return_obj;\n\tacpi_status status;\n\n\tpathname = acpi_ns_get_external_pathname(node);\n\tif (!pathname) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tstatus = acpi_get_object_info(node, &obj_info);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_FREE(pathname);\n\t\treturn (status);\n\t}\n\n\tparam_objects.pointer = NULL;\n\tparam_objects.count = 0;\n\n\tif (obj_info->type == ACPI_TYPE_METHOD) {\n\n\t\t \n\n\t\tfor (i = 0; i < obj_info->param_count; i++) {\n\t\t\tparams[i].type = ACPI_TYPE_INTEGER;\n\t\t\tparams[i].integer.value = 1;\n\t\t}\n\n\t\tparam_objects.pointer = params;\n\t\tparam_objects.count = obj_info->param_count;\n\t}\n\n\tACPI_FREE(obj_info);\n\treturn_obj.pointer = NULL;\n\treturn_obj.length = ACPI_ALLOCATE_BUFFER;\n\n\t \n\n\tacpi_gbl_method_executing = TRUE;\n\n\tstatus = acpi_evaluate_object(node, NULL, &param_objects, &return_obj);\n\tacpi_gbl_method_executing = FALSE;\n\n\tacpi_os_printf(\"%-32s returned %s\\n\", pathname,\n\t\t       acpi_format_exception(status));\n\tif (return_obj.length) {\n\t\tacpi_os_printf(\"Evaluation of %s returned object %p, \"\n\t\t\t       \"external buffer length %X\\n\",\n\t\t\t       pathname, return_obj.pointer,\n\t\t\t       (u32)return_obj.length);\n\n\t\tacpi_db_dump_external_object(return_obj.pointer, 1);\n\t\tacpi_os_printf(\"\\n\");\n\t}\n\n\tACPI_FREE(pathname);\n\n\t \n\n\treturn (AE_OK);\n\n\t \n\n}\n\n \n\nstatic acpi_status\nacpi_db_walk_for_execute(acpi_handle obj_handle,\n\t\t\t u32 nesting_level, void *context, void **return_value)\n{\n\tstruct acpi_namespace_node *node =\n\t    (struct acpi_namespace_node *)obj_handle;\n\tstruct acpi_db_execute_walk *info =\n\t    (struct acpi_db_execute_walk *)context;\n\tacpi_status status;\n\tconst union acpi_predefined_info *predefined;\n\n\tpredefined = acpi_ut_match_predefined_method(node->name.ascii);\n\tif (!predefined) {\n\t\treturn (AE_OK);\n\t}\n\n\tif (node->type == ACPI_TYPE_LOCAL_SCOPE) {\n\t\treturn (AE_OK);\n\t}\n\n\tacpi_db_evaluate_object(node);\n\n\t \n\n\tstatus = AE_OK;\n\n\t \n\n\tinfo->count++;\n\tif (info->count >= info->max_count) {\n\t\tstatus = AE_CTRL_TERMINATE;\n\t}\n\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nacpi_db_walk_for_execute_all(acpi_handle obj_handle,\n\t\t\t     u32 nesting_level,\n\t\t\t     void *context, void **return_value)\n{\n\tstruct acpi_namespace_node *node =\n\t    (struct acpi_namespace_node *)obj_handle;\n\tstruct acpi_db_execute_walk *info =\n\t    (struct acpi_db_execute_walk *)context;\n\tacpi_status status;\n\n\tif (!ACPI_COMPARE_NAMESEG(node->name.ascii, info->name_seg)) {\n\t\treturn (AE_OK);\n\t}\n\n\tif (node->type == ACPI_TYPE_LOCAL_SCOPE) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tacpi_db_evaluate_object(node);\n\n\t \n\n\tstatus = AE_OK;\n\n\t \n\n\tinfo->count++;\n\treturn (status);\n}\n\n \n\nvoid acpi_db_evaluate_predefined_names(void)\n{\n\tstruct acpi_db_execute_walk info;\n\n\tinfo.count = 0;\n\tinfo.max_count = ACPI_UINT32_MAX;\n\n\t \n\n\t(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\n\t\t\t\t  ACPI_UINT32_MAX, acpi_db_walk_for_execute,\n\t\t\t\t  NULL, (void *)&info, NULL);\n\n\tacpi_os_printf(\"Evaluated %u predefined names in the namespace\\n\",\n\t\t       info.count);\n}\n\n \n\nvoid acpi_db_evaluate_all(char *name_seg)\n{\n\tstruct acpi_db_execute_walk info;\n\n\tinfo.count = 0;\n\tinfo.max_count = ACPI_UINT32_MAX;\n\tACPI_COPY_NAMESEG(info.name_seg, name_seg);\n\tinfo.name_seg[ACPI_NAMESEG_SIZE] = 0;\n\n\t \n\n\t(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\n\t\t\t\t  ACPI_UINT32_MAX, acpi_db_walk_for_execute_all,\n\t\t\t\t  NULL, (void *)&info, NULL);\n\n\tacpi_os_printf(\"Evaluated %u names in the namespace\\n\", info.count);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}