{
  "module_name": "utownerid.c",
  "hash_id": "a97760666e73d23b3f4099348ba6dcd457b92b926c59dd18bf4beb0b1be92c8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utownerid.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utownerid\")\n\n \nacpi_status acpi_ut_allocate_owner_id(acpi_owner_id *owner_id)\n{\n\tu32 i;\n\tu32 j;\n\tu32 k;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ut_allocate_owner_id);\n\n\t \n\n\tif (*owner_id) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Owner ID [0x%3.3X] already exists\", *owner_id));\n\t\treturn_ACPI_STATUS(AE_ALREADY_EXISTS);\n\t}\n\n\t \n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tfor (i = 0, j = acpi_gbl_last_owner_id_index;\n\t     i < (ACPI_NUM_OWNERID_MASKS + 1); i++, j++) {\n\t\tif (j >= ACPI_NUM_OWNERID_MASKS) {\n\t\t\tj = 0;\t \n\t\t}\n\n\t\tfor (k = acpi_gbl_next_owner_id_offset; k < 32; k++) {\n\t\t\tif (acpi_gbl_owner_id_mask[j] == ACPI_UINT32_MAX) {\n\n\t\t\t\t \n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!(acpi_gbl_owner_id_mask[j] & ((u32)1 << k))) {\n\t\t\t\t \n\t\t\t\tacpi_gbl_owner_id_mask[j] |= ((u32)1 << k);\n\n\t\t\t\tacpi_gbl_last_owner_id_index = (u8)j;\n\t\t\t\tacpi_gbl_next_owner_id_offset = (u8)(k + 1);\n\n\t\t\t\t \n\t\t\t\t*owner_id =\n\t\t\t\t    (acpi_owner_id)((k + 1) + ACPI_MUL_32(j));\n\n\t\t\t\tACPI_DEBUG_PRINT((ACPI_DB_VALUES,\n\t\t\t\t\t\t  \"Allocated OwnerId: 0x%3.3X\\n\",\n\t\t\t\t\t\t  (unsigned int)*owner_id));\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tacpi_gbl_next_owner_id_offset = 0;\n\t}\n\n\t \n\tstatus = AE_OWNER_ID_LIMIT;\n\tACPI_ERROR((AE_INFO,\n\t\t    \"Could not allocate new OwnerId (4095 max), AE_OWNER_ID_LIMIT\"));\n\nexit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_CACHES);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nvoid acpi_ut_release_owner_id(acpi_owner_id *owner_id_ptr)\n{\n\tacpi_owner_id owner_id = *owner_id_ptr;\n\tacpi_status status;\n\tu32 index;\n\tu32 bit;\n\n\tACPI_FUNCTION_TRACE_U32(ut_release_owner_id, owner_id);\n\n\t \n\n\t*owner_id_ptr = 0;\n\n\t \n\n\tif (owner_id == 0) {\n\t\tACPI_ERROR((AE_INFO, \"Invalid OwnerId: 0x%3.3X\", owner_id));\n\t\treturn_VOID;\n\t}\n\n\t \n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_VOID;\n\t}\n\n\t \n\n\towner_id--;\n\n\t \n\n\tindex = ACPI_DIV_32(owner_id);\n\tbit = (u32)1 << ACPI_MOD_32(owner_id);\n\n\t \n\n\tif (acpi_gbl_owner_id_mask[index] & bit) {\n\t\tacpi_gbl_owner_id_mask[index] ^= bit;\n\t} else {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Attempted release of non-allocated OwnerId: 0x%3.3X\",\n\t\t\t    owner_id + 1));\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_CACHES);\n\treturn_VOID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}