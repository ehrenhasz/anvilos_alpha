{
  "module_name": "hwxfsleep.c",
  "hash_id": "c48c93746a7e4a1cb7caaedf635823e9860508c49237f16a718aae1ebe62f1bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/hwxfsleep.c",
  "human_readable_source": "\n \n\n#define EXPORT_ACPI_INTERFACES\n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n\n#define _COMPONENT          ACPI_HARDWARE\nACPI_MODULE_NAME(\"hwxfsleep\")\n\n \n#if (!ACPI_REDUCED_HARDWARE)\nstatic acpi_status\nacpi_hw_set_firmware_waking_vector(struct acpi_table_facs *facs,\n\t\t\t\t   acpi_physical_address physical_address,\n\t\t\t\t   acpi_physical_address physical_address64);\n#endif\n\n \n\n#if (!ACPI_REDUCED_HARDWARE)\n \n\nstatic acpi_status\nacpi_hw_set_firmware_waking_vector(struct acpi_table_facs *facs,\n\t\t\t\t   acpi_physical_address physical_address,\n\t\t\t\t   acpi_physical_address physical_address64)\n{\n\tACPI_FUNCTION_TRACE(acpi_hw_set_firmware_waking_vector);\n\n\n\t \n\n\t \n\n\tfacs->firmware_waking_vector = (u32)physical_address;\n\n\tif (facs->length > 32) {\n\t\tif (facs->version >= 1) {\n\n\t\t\t \n\n\t\t\tfacs->xfirmware_waking_vector = physical_address64;\n\t\t} else {\n\t\t\t \n\n\t\t\tfacs->xfirmware_waking_vector = 0;\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_set_firmware_waking_vector(acpi_physical_address physical_address,\n\t\t\t\tacpi_physical_address physical_address64)\n{\n\n\tACPI_FUNCTION_TRACE(acpi_set_firmware_waking_vector);\n\n\tif (acpi_gbl_FACS) {\n\t\t(void)acpi_hw_set_firmware_waking_vector(acpi_gbl_FACS,\n\t\t\t\t\t\t\t physical_address,\n\t\t\t\t\t\t\t physical_address64);\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\nACPI_EXPORT_SYMBOL(acpi_set_firmware_waking_vector)\n\n \nacpi_status acpi_enter_sleep_state_s4bios(void)\n{\n\tu32 in_value;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_enter_sleep_state_s4bios);\n\n\t \n\n\tstatus =\n\t    acpi_write_bit_register(ACPI_BITREG_WAKE_STATUS, ACPI_CLEAR_STATUS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_hw_clear_acpi_status();\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tstatus = acpi_hw_disable_all_gpes();\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\tacpi_gbl_system_awake_and_running = FALSE;\n\n\tstatus = acpi_hw_enable_all_wakeup_gpes();\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_hw_write_port(acpi_gbl_FADT.smi_command,\n\t\t\t\t    (u32)acpi_gbl_FADT.s4_bios_request, 8);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tdo {\n\t\tacpi_os_stall(ACPI_USEC_PER_MSEC);\n\t\tstatus =\n\t\t    acpi_read_bit_register(ACPI_BITREG_WAKE_STATUS, &in_value);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t} while (!in_value);\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\nACPI_EXPORT_SYMBOL(acpi_enter_sleep_state_s4bios)\n#endif\t\t\t\t \n\n \n\nacpi_status acpi_enter_sleep_state_prep(u8 sleep_state)\n{\n\tacpi_status status;\n\tstruct acpi_object_list arg_list;\n\tunion acpi_object arg;\n\tu32 sst_value;\n\n\tACPI_FUNCTION_TRACE(acpi_enter_sleep_state_prep);\n\n\tstatus = acpi_get_sleep_type_data(sleep_state,\n\t\t\t\t\t  &acpi_gbl_sleep_type_a,\n\t\t\t\t\t  &acpi_gbl_sleep_type_b);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_get_sleep_type_data(ACPI_STATE_S0,\n\t\t\t\t\t  &acpi_gbl_sleep_type_a_s0,\n\t\t\t\t\t  &acpi_gbl_sleep_type_b_s0);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_gbl_sleep_type_a_s0 = ACPI_SLEEP_TYPE_INVALID;\n\t}\n\n\t \n\n\targ_list.count = 1;\n\targ_list.pointer = &arg;\n\targ.type = ACPI_TYPE_INTEGER;\n\targ.integer.value = sleep_state;\n\n\tstatus =\n\t    acpi_evaluate_object(NULL, METHOD_PATHNAME__PTS, &arg_list, NULL);\n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tswitch (sleep_state) {\n\tcase ACPI_STATE_S0:\n\n\t\tsst_value = ACPI_SST_WORKING;\n\t\tbreak;\n\n\tcase ACPI_STATE_S1:\n\tcase ACPI_STATE_S2:\n\tcase ACPI_STATE_S3:\n\n\t\tsst_value = ACPI_SST_SLEEPING;\n\t\tbreak;\n\n\tcase ACPI_STATE_S4:\n\n\t\tsst_value = ACPI_SST_SLEEP_CONTEXT;\n\t\tbreak;\n\n\tdefault:\n\n\t\tsst_value = ACPI_SST_INDICATOR_OFF;\t \n\t\tbreak;\n\t}\n\n\t \n\tacpi_hw_execute_sleep_method(METHOD_PATHNAME__SST, sst_value);\n\treturn_ACPI_STATUS(AE_OK);\n}\n\nACPI_EXPORT_SYMBOL(acpi_enter_sleep_state_prep)\n\n \nacpi_status acpi_enter_sleep_state(u8 sleep_state)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_enter_sleep_state);\n\n\tif ((acpi_gbl_sleep_type_a > ACPI_SLEEP_TYPE_MAX) ||\n\t    (acpi_gbl_sleep_type_b > ACPI_SLEEP_TYPE_MAX)) {\n\t\tACPI_ERROR((AE_INFO, \"Sleep values out of range: A=0x%X B=0x%X\",\n\t\t\t    acpi_gbl_sleep_type_a, acpi_gbl_sleep_type_b));\n\t\treturn_ACPI_STATUS(AE_AML_OPERAND_VALUE);\n\t}\n\n#if !ACPI_REDUCED_HARDWARE\n\tif (!acpi_gbl_reduced_hardware)\n\t\tstatus = acpi_hw_legacy_sleep(sleep_state);\n\telse\n#endif\n\t\tstatus = acpi_hw_extended_sleep(sleep_state);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_enter_sleep_state)\n\n \nacpi_status acpi_leave_sleep_state_prep(u8 sleep_state)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_leave_sleep_state_prep);\n\n#if !ACPI_REDUCED_HARDWARE\n\tif (!acpi_gbl_reduced_hardware)\n\t\tstatus = acpi_hw_legacy_wake_prep(sleep_state);\n\telse\n#endif\n\t\tstatus = acpi_hw_extended_wake_prep(sleep_state);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_leave_sleep_state_prep)\n\n \nacpi_status acpi_leave_sleep_state(u8 sleep_state)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_leave_sleep_state);\n\n#if !ACPI_REDUCED_HARDWARE\n\tif (!acpi_gbl_reduced_hardware)\n\t\tstatus = acpi_hw_legacy_wake(sleep_state);\n\telse\n#endif\n\t\tstatus = acpi_hw_extended_wake(sleep_state);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_leave_sleep_state)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}