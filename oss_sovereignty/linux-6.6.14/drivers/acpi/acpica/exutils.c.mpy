{
  "module_name": "exutils.c",
  "hash_id": "ead394f39706e772aba508ba73a981007021db778bfb76d0514eb4186aec5b95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/exutils.c",
  "human_readable_source": "\n \n\n \n\n#define DEFINE_AML_GLOBALS\n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acinterp.h\"\n#include \"amlcode.h\"\n\n#define _COMPONENT          ACPI_EXECUTER\nACPI_MODULE_NAME(\"exutils\")\n\n \nstatic u32 acpi_ex_digits_needed(u64 value, u32 base);\n\n \n\nvoid acpi_ex_enter_interpreter(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ex_enter_interpreter);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Could not acquire AML Interpreter mutex\"));\n\t}\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_ERROR((AE_INFO, \"Could not acquire AML Namespace mutex\"));\n\t}\n\n\treturn_VOID;\n}\n\n \n\nvoid acpi_ex_exit_interpreter(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ex_exit_interpreter);\n\n\tstatus = acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_ERROR((AE_INFO, \"Could not release AML Namespace mutex\"));\n\t}\n\tstatus = acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Could not release AML Interpreter mutex\"));\n\t}\n\n\treturn_VOID;\n}\n\n \n\nu8 acpi_ex_truncate_for32bit_table(union acpi_operand_object *obj_desc)\n{\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\tif ((!obj_desc) ||\n\t    (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) != ACPI_DESC_TYPE_OPERAND) ||\n\t    (obj_desc->common.type != ACPI_TYPE_INTEGER)) {\n\t\treturn (FALSE);\n\t}\n\n\tif ((acpi_gbl_integer_byte_width == 4) &&\n\t    (obj_desc->integer.value > (u64)ACPI_UINT32_MAX)) {\n\t\t \n\t\tobj_desc->integer.value &= (u64)ACPI_UINT32_MAX;\n\t\treturn (TRUE);\n\t}\n\n\treturn (FALSE);\n}\n\n \n\nvoid acpi_ex_acquire_global_lock(u32 field_flags)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ex_acquire_global_lock);\n\n\t \n\n\tif (!(field_flags & AML_FIELD_LOCK_RULE_MASK)) {\n\t\treturn_VOID;\n\t}\n\n\t \n\n\tstatus = acpi_ex_acquire_mutex_object(ACPI_WAIT_FOREVER,\n\t\t\t\t\t      acpi_gbl_global_lock_mutex,\n\t\t\t\t\t      acpi_os_get_thread_id());\n\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"Could not acquire Global Lock\"));\n\t}\n\n\treturn_VOID;\n}\n\n \n\nvoid acpi_ex_release_global_lock(u32 field_flags)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ex_release_global_lock);\n\n\t \n\n\tif (!(field_flags & AML_FIELD_LOCK_RULE_MASK)) {\n\t\treturn_VOID;\n\t}\n\n\t \n\n\tstatus = acpi_ex_release_mutex_object(acpi_gbl_global_lock_mutex);\n\tif (ACPI_FAILURE(status)) {\n\n\t\t \n\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"Could not release Global Lock\"));\n\t}\n\n\treturn_VOID;\n}\n\n \n\nstatic u32 acpi_ex_digits_needed(u64 value, u32 base)\n{\n\tu32 num_digits;\n\tu64 current_value;\n\n\tACPI_FUNCTION_TRACE(ex_digits_needed);\n\n\t \n\n\tif (value == 0) {\n\t\treturn_UINT32(1);\n\t}\n\n\tcurrent_value = value;\n\tnum_digits = 0;\n\n\t \n\n\twhile (current_value) {\n\t\t(void)acpi_ut_short_divide(current_value, base, &current_value,\n\t\t\t\t\t   NULL);\n\t\tnum_digits++;\n\t}\n\n\treturn_UINT32(num_digits);\n}\n\n \n\nvoid acpi_ex_eisa_id_to_string(char *out_string, u64 compressed_id)\n{\n\tu32 swapped_id;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tif (compressed_id > ACPI_UINT32_MAX) {\n\t\tACPI_WARNING((AE_INFO,\n\t\t\t      \"Expected EISAID is larger than 32 bits: \"\n\t\t\t      \"0x%8.8X%8.8X, truncating\",\n\t\t\t      ACPI_FORMAT_UINT64(compressed_id)));\n\t}\n\n\t \n\n\tswapped_id = acpi_ut_dword_byte_swap((u32)compressed_id);\n\n\t \n\n\tout_string[0] =\n\t    (char)(0x40 + (((unsigned long)swapped_id >> 26) & 0x1F));\n\tout_string[1] = (char)(0x40 + ((swapped_id >> 21) & 0x1F));\n\tout_string[2] = (char)(0x40 + ((swapped_id >> 16) & 0x1F));\n\tout_string[3] = acpi_ut_hex_to_ascii_char((u64) swapped_id, 12);\n\tout_string[4] = acpi_ut_hex_to_ascii_char((u64) swapped_id, 8);\n\tout_string[5] = acpi_ut_hex_to_ascii_char((u64) swapped_id, 4);\n\tout_string[6] = acpi_ut_hex_to_ascii_char((u64) swapped_id, 0);\n\tout_string[7] = 0;\n}\n\n \n\nvoid acpi_ex_integer_to_string(char *out_string, u64 value)\n{\n\tu32 count;\n\tu32 digits_needed;\n\tu32 remainder;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tdigits_needed = acpi_ex_digits_needed(value, 10);\n\tout_string[digits_needed] = 0;\n\n\tfor (count = digits_needed; count > 0; count--) {\n\t\t(void)acpi_ut_short_divide(value, 10, &value, &remainder);\n\t\tout_string[count - 1] = (char)('0' + remainder);\n\t}\n}\n\n \n\nvoid acpi_ex_pci_cls_to_string(char *out_string, u8 class_code[3])\n{\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tout_string[0] = acpi_ut_hex_to_ascii_char((u64)class_code[0], 4);\n\tout_string[1] = acpi_ut_hex_to_ascii_char((u64)class_code[0], 0);\n\tout_string[2] = acpi_ut_hex_to_ascii_char((u64)class_code[1], 4);\n\tout_string[3] = acpi_ut_hex_to_ascii_char((u64)class_code[1], 0);\n\tout_string[4] = acpi_ut_hex_to_ascii_char((u64)class_code[2], 4);\n\tout_string[5] = acpi_ut_hex_to_ascii_char((u64)class_code[2], 0);\n\tout_string[6] = 0;\n}\n\n \n\nu8 acpi_is_valid_space_id(u8 space_id)\n{\n\n\tif ((space_id >= ACPI_NUM_PREDEFINED_REGIONS) &&\n\t    (space_id < ACPI_USER_REGION_BEGIN) &&\n\t    (space_id != ACPI_ADR_SPACE_DATA_TABLE) &&\n\t    (space_id != ACPI_ADR_SPACE_FIXED_HARDWARE)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}