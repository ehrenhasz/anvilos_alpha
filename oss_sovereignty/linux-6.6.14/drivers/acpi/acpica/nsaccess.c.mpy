{
  "module_name": "nsaccess.c",
  "hash_id": "589b7d03997b7fbb7d757f84ed69c93fb785964cc4c025e37d7dd7696558dcad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/nsaccess.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"amlcode.h\"\n#include \"acnamesp.h\"\n#include \"acdispat.h\"\n\n#ifdef ACPI_ASL_COMPILER\n#include \"acdisasm.h\"\n#endif\n\n#define _COMPONENT          ACPI_NAMESPACE\nACPI_MODULE_NAME(\"nsaccess\")\n\n \nacpi_status acpi_ns_root_initialize(void)\n{\n\tacpi_status status;\n\tconst struct acpi_predefined_names *init_val = NULL;\n\tstruct acpi_namespace_node *new_node;\n\tstruct acpi_namespace_node *prev_node = NULL;\n\tunion acpi_operand_object *obj_desc;\n\tacpi_string val = NULL;\n\n\tACPI_FUNCTION_TRACE(ns_root_initialize);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tif (acpi_gbl_root_node) {\n\t\tstatus = AE_OK;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\tacpi_gbl_root_node = &acpi_gbl_root_node_struct;\n\n\t \n\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO,\n\t\t\t  \"Entering predefined entries into namespace\\n\"));\n\n\t \n\tfor (init_val = acpi_gbl_pre_defined_names; init_val->name; init_val++) {\n\t\tstatus = AE_OK;\n\n\t\t \n\n\t\tif (!strcmp(init_val->name, \"_OSI\")\n\t\t    && !acpi_gbl_create_osi_method) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tnew_node =\n\t\t    acpi_ns_create_node(*ACPI_CAST_PTR(u32, init_val->name));\n\t\tif (!new_node) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\n\t\tnew_node->descriptor_type = ACPI_DESC_TYPE_NAMED;\n\t\tnew_node->type = init_val->type;\n\n\t\tif (!prev_node) {\n\t\t\tacpi_gbl_root_node_struct.child = new_node;\n\t\t} else {\n\t\t\tprev_node->peer = new_node;\n\t\t}\n\n\t\tnew_node->parent = &acpi_gbl_root_node_struct;\n\t\tprev_node = new_node;\n\n\t\t \n\t\tif (init_val->val) {\n\t\t\tstatus = acpi_os_predefined_override(init_val, &val);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t\t    \"Could not override predefined %s\",\n\t\t\t\t\t    init_val->name));\n\t\t\t}\n\n\t\t\tif (!val) {\n\t\t\t\tval = init_val->val;\n\t\t\t}\n\n\t\t\t \n\t\t\tobj_desc =\n\t\t\t    acpi_ut_create_internal_object(init_val->type);\n\t\t\tif (!obj_desc) {\n\t\t\t\tstatus = AE_NO_MEMORY;\n\t\t\t\tgoto unlock_and_exit;\n\t\t\t}\n\n\t\t\t \n\t\t\tswitch (init_val->type) {\n\t\t\tcase ACPI_TYPE_METHOD:\n\n\t\t\t\tobj_desc->method.param_count =\n\t\t\t\t    (u8) ACPI_TO_INTEGER(val);\n\t\t\t\tobj_desc->common.flags |= AOPOBJ_DATA_VALID;\n\n#if defined (ACPI_ASL_COMPILER)\n\n\t\t\t\t \n\n\t\t\t\tnew_node->value = obj_desc->method.param_count;\n#else\n\t\t\t\t \n\n\t\t\t\tobj_desc->method.info_flags =\n\t\t\t\t    ACPI_METHOD_INTERNAL_ONLY;\n\t\t\t\tobj_desc->method.dispatch.implementation =\n\t\t\t\t    acpi_ut_osi_implementation;\n#endif\n\t\t\t\tbreak;\n\n\t\t\tcase ACPI_TYPE_INTEGER:\n\n\t\t\t\tobj_desc->integer.value = ACPI_TO_INTEGER(val);\n\t\t\t\tbreak;\n\n\t\t\tcase ACPI_TYPE_STRING:\n\n\t\t\t\t \n\n\t\t\t\tobj_desc->string.length = (u32)strlen(val);\n\t\t\t\tobj_desc->string.pointer = val;\n\t\t\t\tobj_desc->common.flags |= AOPOBJ_STATIC_POINTER;\n\t\t\t\tbreak;\n\n\t\t\tcase ACPI_TYPE_MUTEX:\n\n\t\t\t\tobj_desc->mutex.node = new_node;\n\t\t\t\tobj_desc->mutex.sync_level =\n\t\t\t\t    (u8) (ACPI_TO_INTEGER(val) - 1);\n\n\t\t\t\t \n\n\t\t\t\tstatus =\n\t\t\t\t    acpi_os_create_mutex(&obj_desc->mutex.\n\t\t\t\t\t\t\t os_mutex);\n\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\tacpi_ut_remove_reference(obj_desc);\n\t\t\t\t\tgoto unlock_and_exit;\n\t\t\t\t}\n\n\t\t\t\t \n\n\t\t\t\tif (strcmp(init_val->name, \"_GL_\") == 0) {\n\t\t\t\t\tacpi_gbl_global_lock_mutex = obj_desc;\n\n\t\t\t\t\t \n\n\t\t\t\t\tstatus =\n\t\t\t\t\t    acpi_os_create_semaphore(1, 0,\n\t\t\t\t\t\t\t\t     &acpi_gbl_global_lock_semaphore);\n\t\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\t\tacpi_ut_remove_reference\n\t\t\t\t\t\t    (obj_desc);\n\t\t\t\t\t\tgoto unlock_and_exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t\t    \"Unsupported initial type value 0x%X\",\n\t\t\t\t\t    init_val->type));\n\t\t\t\tacpi_ut_remove_reference(obj_desc);\n\t\t\t\tobj_desc = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tstatus = acpi_ns_attach_object(new_node, obj_desc,\n\t\t\t\t\t\t       obj_desc->common.type);\n\n\t\t\t \n\n\t\t\tacpi_ut_remove_reference(obj_desc);\n\t\t}\n\t}\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\n\t \n\n\tif (ACPI_SUCCESS(status)) {\n\t\tstatus = acpi_ns_get_node(NULL, \"\\\\_GPE\", ACPI_NS_NO_UPSEARCH,\n\t\t\t\t\t  &acpi_gbl_fadt_gpe_device);\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ns_lookup(union acpi_generic_state *scope_info,\n\t       char *pathname,\n\t       acpi_object_type type,\n\t       acpi_interpreter_mode interpreter_mode,\n\t       u32 flags,\n\t       struct acpi_walk_state *walk_state,\n\t       struct acpi_namespace_node **return_node)\n{\n\tacpi_status status;\n\tchar *path = pathname;\n\tchar *external_path;\n\tstruct acpi_namespace_node *prefix_node;\n\tstruct acpi_namespace_node *current_node = NULL;\n\tstruct acpi_namespace_node *this_node = NULL;\n\tu32 num_segments;\n\tu32 num_carats;\n\tacpi_name simple_name;\n\tacpi_object_type type_to_check_for;\n\tacpi_object_type this_search_type;\n\tu32 search_parent_flag = ACPI_NS_SEARCH_PARENT;\n\tu32 local_flags;\n\tacpi_interpreter_mode local_interpreter_mode;\n\n\tACPI_FUNCTION_TRACE(ns_lookup);\n\n\tif (!return_node) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tlocal_flags = flags &\n\t    ~(ACPI_NS_ERROR_IF_FOUND | ACPI_NS_OVERRIDE_IF_FOUND |\n\t      ACPI_NS_SEARCH_PARENT);\n\t*return_node = ACPI_ENTRY_NOT_FOUND;\n\tacpi_gbl_ns_lookup_count++;\n\n\tif (!acpi_gbl_root_node) {\n\t\treturn_ACPI_STATUS(AE_NO_NAMESPACE);\n\t}\n\n\t \n\n\tif ((!scope_info) || (!scope_info->scope.node)) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_NAMES,\n\t\t\t\t  \"Null scope prefix, using root node (%p)\\n\",\n\t\t\t\t  acpi_gbl_root_node));\n\n\t\tprefix_node = acpi_gbl_root_node;\n\t} else {\n\t\tprefix_node = scope_info->scope.node;\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(prefix_node) !=\n\t\t    ACPI_DESC_TYPE_NAMED) {\n\t\t\tACPI_ERROR((AE_INFO, \"%p is not a namespace node [%s]\",\n\t\t\t\t    prefix_node,\n\t\t\t\t    acpi_ut_get_descriptor_name(prefix_node)));\n\t\t\treturn_ACPI_STATUS(AE_AML_INTERNAL);\n\t\t}\n\n\t\tif (!(flags & ACPI_NS_PREFIX_IS_SCOPE)) {\n\t\t\t \n\t\t\twhile (!acpi_ns_opens_scope(prefix_node->type) &&\n\t\t\t       prefix_node->type != ACPI_TYPE_ANY) {\n\t\t\t\tprefix_node = prefix_node->parent;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\ttype_to_check_for = type;\n\n\t \n\tif (!pathname) {\n\n\t\t \n\n\t\tnum_segments = 0;\n\t\tthis_node = acpi_gbl_root_node;\n\t\tpath = \"\";\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_NAMES,\n\t\t\t\t  \"Null Pathname (Zero segments), Flags=%X\\n\",\n\t\t\t\t  flags));\n\t} else {\n\t\t \n\t\tif (*path == (u8) AML_ROOT_PREFIX) {\n\n\t\t\t \n\n\t\t\tthis_node = acpi_gbl_root_node;\n\t\t\tsearch_parent_flag = ACPI_NS_NO_UPSEARCH;\n\n\t\t\t \n\n\t\t\tpath++;\n\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_NAMES,\n\t\t\t\t\t  \"Path is absolute from root [%p]\\n\",\n\t\t\t\t\t  this_node));\n\t\t} else {\n\t\t\t \n\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_NAMES,\n\t\t\t\t\t  \"Searching relative to prefix scope [%4.4s] (%p)\\n\",\n\t\t\t\t\t  acpi_ut_get_node_name(prefix_node),\n\t\t\t\t\t  prefix_node));\n\n\t\t\t \n\t\t\tthis_node = prefix_node;\n\t\t\tnum_carats = 0;\n\t\t\twhile (*path == (u8) AML_PARENT_PREFIX) {\n\n\t\t\t\t \n\n\t\t\t\tsearch_parent_flag = ACPI_NS_NO_UPSEARCH;\n\n\t\t\t\t \n\t\t\t\tpath++;\n\n\t\t\t\t \n\n\t\t\t\tnum_carats++;\n\t\t\t\tthis_node = this_node->parent;\n\t\t\t\tif (!this_node) {\n\t\t\t\t\t \n\t\t\t\t\tstatus =\n\t\t\t\t\t    acpi_ns_externalize_name\n\t\t\t\t\t    (ACPI_UINT32_MAX, pathname, NULL,\n\t\t\t\t\t     &external_path);\n\t\t\t\t\tif (ACPI_SUCCESS(status)) {\n\t\t\t\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t\t\t\t    \"%s: Path has too many parent prefixes (^)\",\n\t\t\t\t\t\t\t    external_path));\n\n\t\t\t\t\t\tACPI_FREE(external_path);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn_ACPI_STATUS(AE_NOT_FOUND);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (search_parent_flag == ACPI_NS_NO_UPSEARCH) {\n\t\t\t\tACPI_DEBUG_PRINT((ACPI_DB_NAMES,\n\t\t\t\t\t\t  \"Search scope is [%4.4s], path has %u carat(s)\\n\",\n\t\t\t\t\t\t  acpi_ut_get_node_name\n\t\t\t\t\t\t  (this_node), num_carats));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tswitch (*path) {\n\t\tcase 0:\n\t\t\t \n\t\t\tnum_segments = 0;\n\t\t\ttype = this_node->type;\n\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_NAMES,\n\t\t\t\t\t  \"Prefix-only Pathname (Zero name segments), Flags=%X\\n\",\n\t\t\t\t\t  flags));\n\t\t\tbreak;\n\n\t\tcase AML_DUAL_NAME_PREFIX:\n\n\t\t\t \n\n\t\t\tsearch_parent_flag = ACPI_NS_NO_UPSEARCH;\n\n\t\t\t \n\n\t\t\tnum_segments = 2;\n\t\t\tpath++;\n\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_NAMES,\n\t\t\t\t\t  \"Dual Pathname (2 segments, Flags=%X)\\n\",\n\t\t\t\t\t  flags));\n\t\t\tbreak;\n\n\t\tcase AML_MULTI_NAME_PREFIX:\n\n\t\t\t \n\n\t\t\tsearch_parent_flag = ACPI_NS_NO_UPSEARCH;\n\n\t\t\t \n\n\t\t\tpath++;\n\t\t\tnum_segments = (u32) (u8) * path;\n\t\t\tpath++;\n\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_NAMES,\n\t\t\t\t\t  \"Multi Pathname (%u Segments, Flags=%X)\\n\",\n\t\t\t\t\t  num_segments, flags));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tnum_segments = 1;\n\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_NAMES,\n\t\t\t\t\t  \"Simple Pathname (1 segment, Flags=%X)\\n\",\n\t\t\t\t\t  flags));\n\t\t\tbreak;\n\t\t}\n\n\t\tACPI_DEBUG_EXEC(acpi_ns_print_pathname(num_segments, path));\n\t}\n\n\t \n\tthis_search_type = ACPI_TYPE_ANY;\n\tcurrent_node = this_node;\n\n\twhile (num_segments && current_node) {\n\t\tnum_segments--;\n\t\tif (!num_segments) {\n\n\t\t\t \n\n\t\t\tthis_search_type = type;\n\n\t\t\t \n\t\t\tif ((search_parent_flag != ACPI_NS_NO_UPSEARCH) &&\n\t\t\t    (flags & ACPI_NS_SEARCH_PARENT)) {\n\t\t\t\tlocal_flags |= ACPI_NS_SEARCH_PARENT;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (flags & ACPI_NS_ERROR_IF_FOUND) {\n\t\t\t\tlocal_flags |= ACPI_NS_ERROR_IF_FOUND;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (flags & ACPI_NS_OVERRIDE_IF_FOUND) {\n\t\t\t\tlocal_flags |= ACPI_NS_OVERRIDE_IF_FOUND;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tlocal_interpreter_mode = interpreter_mode;\n\t\tif ((flags & ACPI_NS_PREFIX_MUST_EXIST) && (num_segments > 0)) {\n\n\t\t\t \n\n\t\t\tlocal_interpreter_mode = ACPI_IMODE_EXECUTE;\n\t\t}\n\n\t\t \n\n\t\tACPI_MOVE_32_TO_32(&simple_name, path);\n\n\t\t \n\n\t\tstatus =\n\t\t    acpi_ns_search_and_enter(simple_name, walk_state,\n\t\t\t\t\t     current_node,\n\t\t\t\t\t     local_interpreter_mode,\n\t\t\t\t\t     this_search_type, local_flags,\n\t\t\t\t\t     &this_node);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tif (status == AE_NOT_FOUND) {\n#if !defined ACPI_ASL_COMPILER\t \n\t\t\t\tif (flags & ACPI_NS_PREFIX_MUST_EXIST) {\n\t\t\t\t\tacpi_os_printf(ACPI_MSG_BIOS_ERROR\n\t\t\t\t\t\t       \"Object does not exist: %4.4s\\n\",\n\t\t\t\t\t\t       (char *)&simple_name);\n\t\t\t\t}\n#endif\n\t\t\t\t \n\n\t\t\t\tACPI_DEBUG_PRINT((ACPI_DB_NAMES,\n\t\t\t\t\t\t  \"Name [%4.4s] not found in scope [%4.4s] %p\\n\",\n\t\t\t\t\t\t  (char *)&simple_name,\n\t\t\t\t\t\t  (char *)&current_node->name,\n\t\t\t\t\t\t  current_node));\n\t\t\t}\n#ifdef ACPI_EXEC_APP\n\t\t\tif ((status == AE_ALREADY_EXISTS) &&\n\t\t\t    (this_node->flags & ANOBJ_NODE_EARLY_INIT)) {\n\t\t\t\tthis_node->flags &= ~ANOBJ_NODE_EARLY_INIT;\n\t\t\t\tstatus = AE_OK;\n\t\t\t}\n#endif\n\n#ifdef ACPI_ASL_COMPILER\n\t\t\t \n\t\t\tif (acpi_gbl_disasm_flag &&\n\t\t\t    (status == AE_ALREADY_EXISTS) &&\n\t\t\t    ((this_node->flags & ANOBJ_IS_EXTERNAL) ||\n\t\t\t     (walk_state\n\t\t\t      && walk_state->opcode == AML_EXTERNAL_OP))) {\n\t\t\t\tthis_node->flags &= ~ANOBJ_IS_EXTERNAL;\n\t\t\t\tthis_node->type = (u8)this_search_type;\n\t\t\t\tif (walk_state->opcode != AML_EXTERNAL_OP) {\n\t\t\t\t\tacpi_dm_mark_external_conflict\n\t\t\t\t\t    (this_node);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\n\t\t\t*return_node = this_node;\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\t \n\n\t\tif (num_segments > 0) {\n\t\t\t \n\t\t\tif (this_node->type == ACPI_TYPE_LOCAL_ALIAS) {\n\t\t\t\tif (!this_node->object) {\n\t\t\t\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t\t\t\t}\n\n\t\t\t\tif (acpi_ns_opens_scope\n\t\t\t\t    (((struct acpi_namespace_node *)\n\t\t\t\t      this_node->object)->type)) {\n\t\t\t\t\tthis_node =\n\t\t\t\t\t    (struct acpi_namespace_node *)\n\t\t\t\t\t    this_node->object;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\telse {\n\t\t\t \n\t\t\tif ((type_to_check_for != ACPI_TYPE_ANY) &&\n\t\t\t    (type_to_check_for != ACPI_TYPE_LOCAL_ALIAS) &&\n\t\t\t    (type_to_check_for != ACPI_TYPE_LOCAL_METHOD_ALIAS)\n\t\t\t    && (type_to_check_for != ACPI_TYPE_LOCAL_SCOPE)\n\t\t\t    && (this_node->type != ACPI_TYPE_ANY)\n\t\t\t    && (this_node->type != type_to_check_for)) {\n\n\t\t\t\t \n\n\t\t\t\tACPI_WARNING((AE_INFO,\n\t\t\t\t\t      \"NsLookup: Type mismatch on %4.4s (%s), searching for (%s)\",\n\t\t\t\t\t      ACPI_CAST_PTR(char, &simple_name),\n\t\t\t\t\t      acpi_ut_get_type_name(this_node->\n\t\t\t\t\t\t\t\t    type),\n\t\t\t\t\t      acpi_ut_get_type_name\n\t\t\t\t\t      (type_to_check_for)));\n\t\t\t}\n\n\t\t\t \n\t\t\tif (type == ACPI_TYPE_ANY) {\n\t\t\t\ttype = this_node->type;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tpath += ACPI_NAMESEG_SIZE;\n\t\tcurrent_node = this_node;\n\t}\n\n\t \n\n\tif (!(flags & ACPI_NS_DONT_OPEN_SCOPE) && (walk_state)) {\n\t\t \n\t\tif (acpi_ns_opens_scope(type)) {\n\t\t\tstatus =\n\t\t\t    acpi_ds_scope_stack_push(this_node, type,\n\t\t\t\t\t\t     walk_state);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t}\n\t\t}\n\t}\n#ifdef ACPI_EXEC_APP\n\tif (flags & ACPI_NS_EARLY_INIT) {\n\t\tthis_node->flags |= ANOBJ_NODE_EARLY_INIT;\n\t}\n#endif\n\n\t*return_node = this_node;\n\treturn_ACPI_STATUS(AE_OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}