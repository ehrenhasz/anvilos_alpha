{
  "module_name": "hwesleep.c",
  "hash_id": "46ed6fd4483503f4da9b94ab3db751298bc7aa2feb830d189bf60a5173035540",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/hwesleep.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n\n#define _COMPONENT          ACPI_HARDWARE\nACPI_MODULE_NAME(\"hwesleep\")\n\n \nvoid acpi_hw_execute_sleep_method(char *method_pathname, u32 integer_argument)\n{\n\tstruct acpi_object_list arg_list;\n\tunion acpi_object arg;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(hw_execute_sleep_method);\n\n\t \n\n\targ_list.count = 1;\n\targ_list.pointer = &arg;\n\targ.type = ACPI_TYPE_INTEGER;\n\targ.integer.value = (u64)integer_argument;\n\n\tstatus = acpi_evaluate_object(NULL, method_pathname, &arg_list, NULL);\n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\n\t\tACPI_EXCEPTION((AE_INFO, status, \"While executing method %s\",\n\t\t\t\tmethod_pathname));\n\t}\n\n\treturn_VOID;\n}\n\n \n\nacpi_status acpi_hw_extended_sleep(u8 sleep_state)\n{\n\tacpi_status status;\n\tu8 sleep_control;\n\tu64 sleep_status;\n\n\tACPI_FUNCTION_TRACE(hw_extended_sleep);\n\n\t \n\n\tif (!acpi_gbl_FADT.sleep_control.address ||\n\t    !acpi_gbl_FADT.sleep_status.address) {\n\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t}\n\n\t \n\n\tstatus = acpi_write((u64)ACPI_X_WAKE_STATUS,\n\t\t\t    &acpi_gbl_FADT.sleep_status);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tacpi_gbl_system_awake_and_running = FALSE;\n\n\t \n\tACPI_DEBUG_PRINT((ACPI_DB_INIT,\n\t\t\t  \"Entering sleep state [S%u]\\n\", sleep_state));\n\n\tsleep_control = ((acpi_gbl_sleep_type_a << ACPI_X_SLEEP_TYPE_POSITION) &\n\t\t\t ACPI_X_SLEEP_TYPE_MASK) | ACPI_X_SLEEP_ENABLE;\n\n\t \n\n\tif (sleep_state < ACPI_STATE_S4) {\n\t\tACPI_FLUSH_CPU_CACHE();\n\t}\n\n\tstatus = acpi_os_enter_sleep(sleep_state, sleep_control, 0);\n\tif (status == AE_CTRL_TERMINATE) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_write((u64)sleep_control, &acpi_gbl_FADT.sleep_control);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tdo {\n\t\tstatus = acpi_read(&sleep_status, &acpi_gbl_FADT.sleep_status);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t} while (!(((u8)sleep_status) & ACPI_X_WAKE_STATUS));\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status acpi_hw_extended_wake_prep(u8 sleep_state)\n{\n\tu8 sleep_type_value;\n\n\tACPI_FUNCTION_TRACE(hw_extended_wake_prep);\n\n\tif (acpi_gbl_sleep_type_a_s0 != ACPI_SLEEP_TYPE_INVALID) {\n\t\tsleep_type_value =\n\t\t    ((acpi_gbl_sleep_type_a_s0 << ACPI_X_SLEEP_TYPE_POSITION) &\n\t\t     ACPI_X_SLEEP_TYPE_MASK);\n\n\t\t(void)acpi_write((u64)(sleep_type_value | ACPI_X_SLEEP_ENABLE),\n\t\t\t\t &acpi_gbl_FADT.sleep_control);\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status acpi_hw_extended_wake(u8 sleep_state)\n{\n\tACPI_FUNCTION_TRACE(hw_extended_wake);\n\n\t \n\n\tacpi_gbl_sleep_type_a = ACPI_SLEEP_TYPE_INVALID;\n\n\t \n\n\tacpi_hw_execute_sleep_method(METHOD_PATHNAME__SST, ACPI_SST_WAKING);\n\tacpi_hw_execute_sleep_method(METHOD_PATHNAME__WAK, sleep_state);\n\n\t \n\t(void)acpi_write((u64)ACPI_X_WAKE_STATUS, &acpi_gbl_FADT.sleep_status);\n\tacpi_gbl_system_awake_and_running = TRUE;\n\n\tacpi_hw_execute_sleep_method(METHOD_PATHNAME__SST, ACPI_SST_WORKING);\n\treturn_ACPI_STATUS(AE_OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}