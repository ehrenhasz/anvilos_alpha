{
  "module_name": "utstrsuppt.c",
  "hash_id": "5a3d38403746a6edd14fb51bcb5f27e87e5ca9fe960b595ef99d6a993fbb224d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utstrsuppt.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utstrsuppt\")\n\n \nstatic acpi_status\nacpi_ut_insert_digit(u64 *accumulated_value, u32 base, int ascii_digit);\n\nstatic acpi_status\nacpi_ut_strtoul_multiply64(u64 multiplicand, u32 base, u64 *out_product);\n\nstatic acpi_status acpi_ut_strtoul_add64(u64 addend1, u32 digit, u64 *out_sum);\n\n \n\nacpi_status acpi_ut_convert_octal_string(char *string, u64 *return_value_ptr)\n{\n\tu64 accumulated_value = 0;\n\tacpi_status status = AE_OK;\n\n\t \n\n\twhile (*string) {\n\t\t \n\t\tif (!(ACPI_IS_OCTAL_DIGIT(*string))) {\n#ifdef ACPI_ASL_COMPILER\n\t\t\tstatus = AE_BAD_OCTAL_CONSTANT;\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ut_insert_digit(&accumulated_value, 8, *string);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tstatus = AE_OCTAL_OVERFLOW;\n\t\t\tbreak;\n\t\t}\n\n\t\tstring++;\n\t}\n\n\t \n\n\t*return_value_ptr = accumulated_value;\n\treturn (status);\n}\n\n \n\nacpi_status acpi_ut_convert_decimal_string(char *string, u64 *return_value_ptr)\n{\n\tu64 accumulated_value = 0;\n\tacpi_status status = AE_OK;\n\n\t \n\n\twhile (*string) {\n\t\t \n\t\tif (!isdigit((int)*string)) {\n#ifdef ACPI_ASL_COMPILER\n\t\t\tstatus = AE_BAD_DECIMAL_CONSTANT;\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ut_insert_digit(&accumulated_value, 10, *string);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tstatus = AE_DECIMAL_OVERFLOW;\n\t\t\tbreak;\n\t\t}\n\n\t\tstring++;\n\t}\n\n\t \n\n\t*return_value_ptr = accumulated_value;\n\treturn (status);\n}\n\n \n\nacpi_status acpi_ut_convert_hex_string(char *string, u64 *return_value_ptr)\n{\n\tu64 accumulated_value = 0;\n\tacpi_status status = AE_OK;\n\n\t \n\n\twhile (*string) {\n\t\t \n\t\tif (!isxdigit((int)*string)) {\n#ifdef ACPI_ASL_COMPILER\n\t\t\tstatus = AE_BAD_HEX_CONSTANT;\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ut_insert_digit(&accumulated_value, 16, *string);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tstatus = AE_HEX_OVERFLOW;\n\t\t\tbreak;\n\t\t}\n\n\t\tstring++;\n\t}\n\n\t \n\n\t*return_value_ptr = accumulated_value;\n\treturn (status);\n}\n\n \n\nchar acpi_ut_remove_leading_zeros(char **string)\n{\n\n\twhile (**string == ACPI_ASCII_ZERO) {\n\t\t*string += 1;\n\t}\n\n\treturn (**string);\n}\n\n \n\nchar acpi_ut_remove_whitespace(char **string)\n{\n\n\twhile (isspace((u8)**string)) {\n\t\t*string += 1;\n\t}\n\n\treturn (**string);\n}\n\n \n\nu8 acpi_ut_detect_hex_prefix(char **string)\n{\n\tchar *initial_position = *string;\n\n\tacpi_ut_remove_hex_prefix(string);\n\tif (*string != initial_position) {\n\t\treturn (TRUE);\t \n\t}\n\n\treturn (FALSE);\t\t \n}\n\n \n\nvoid acpi_ut_remove_hex_prefix(char **string)\n{\n\tif ((**string == ACPI_ASCII_ZERO) &&\n\t    (tolower((int)*(*string + 1)) == 'x')) {\n\t\t*string += 2;\t \n\t}\n}\n\n \n\nu8 acpi_ut_detect_octal_prefix(char **string)\n{\n\n\tif (**string == ACPI_ASCII_ZERO) {\n\t\t*string += 1;\t \n\t\treturn (TRUE);\n\t}\n\n\treturn (FALSE);\t\t \n}\n\n \n\nstatic acpi_status\nacpi_ut_insert_digit(u64 *accumulated_value, u32 base, int ascii_digit)\n{\n\tacpi_status status;\n\tu64 product;\n\n\t \n\n\tstatus = acpi_ut_strtoul_multiply64(*accumulated_value, base, &product);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\tstatus =\n\t    acpi_ut_strtoul_add64(product,\n\t\t\t\t  acpi_ut_ascii_char_to_hex(ascii_digit),\n\t\t\t\t  accumulated_value);\n\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nacpi_ut_strtoul_multiply64(u64 multiplicand, u32 base, u64 *out_product)\n{\n\tu64 product;\n\tu64 quotient;\n\n\t \n\n\t*out_product = 0;\n\tif (!multiplicand || !base) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\tacpi_ut_short_divide(ACPI_UINT64_MAX, base, &quotient, NULL);\n\tif (multiplicand > quotient) {\n\t\treturn (AE_NUMERIC_OVERFLOW);\n\t}\n\n\tproduct = multiplicand * base;\n\n\t \n\n\tif ((acpi_gbl_integer_bit_width == 32) && (product > ACPI_UINT32_MAX)) {\n\t\treturn (AE_NUMERIC_OVERFLOW);\n\t}\n\n\t*out_product = product;\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status acpi_ut_strtoul_add64(u64 addend1, u32 digit, u64 *out_sum)\n{\n\tu64 sum;\n\n\t \n\n\tif ((addend1 > 0) && (digit > (ACPI_UINT64_MAX - addend1))) {\n\t\treturn (AE_NUMERIC_OVERFLOW);\n\t}\n\n\tsum = addend1 + digit;\n\n\t \n\n\tif ((acpi_gbl_integer_bit_width == 32) && (sum > ACPI_UINT32_MAX)) {\n\t\treturn (AE_NUMERIC_OVERFLOW);\n\t}\n\n\t*out_sum = sum;\n\treturn (AE_OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}