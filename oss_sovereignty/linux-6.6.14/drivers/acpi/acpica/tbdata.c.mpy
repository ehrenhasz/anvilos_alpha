{
  "module_name": "tbdata.c",
  "hash_id": "a52f1d49dd4af4ccf3f2faf8291eddd1d190427291b16cb7979e150273463aa8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/tbdata.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"actables.h\"\n#include \"acevents.h\"\n\n#define _COMPONENT          ACPI_TABLES\nACPI_MODULE_NAME(\"tbdata\")\n\n \nstatic acpi_status\nacpi_tb_check_duplication(struct acpi_table_desc *table_desc, u32 *table_index);\n\nstatic u8\nacpi_tb_compare_tables(struct acpi_table_desc *table_desc, u32 table_index);\n\n \n\nstatic u8\nacpi_tb_compare_tables(struct acpi_table_desc *table_desc, u32 table_index)\n{\n\tacpi_status status = AE_OK;\n\tu8 is_identical;\n\tstruct acpi_table_header *table;\n\tu32 table_length;\n\tu8 table_flags;\n\n\tstatus =\n\t    acpi_tb_acquire_table(&acpi_gbl_root_table_list.tables[table_index],\n\t\t\t\t  &table, &table_length, &table_flags);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (FALSE);\n\t}\n\n\t \n\tis_identical = (u8)((table_desc->length != table_length ||\n\t\t\t     memcmp(table_desc->pointer, table, table_length)) ?\n\t\t\t    FALSE : TRUE);\n\n\t \n\n\tacpi_tb_release_table(table, table_length, table_flags);\n\treturn (is_identical);\n}\n\n \n\nvoid\nacpi_tb_init_table_descriptor(struct acpi_table_desc *table_desc,\n\t\t\t      acpi_physical_address address,\n\t\t\t      u8 flags, struct acpi_table_header *table)\n{\n\n\t \n\tmemset(table_desc, 0, sizeof(struct acpi_table_desc));\n\ttable_desc->address = address;\n\ttable_desc->length = table->length;\n\ttable_desc->flags = flags;\n\tACPI_MOVE_32_TO_32(table_desc->signature.ascii, table->signature);\n\n\tswitch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {\n\tcase ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:\n\tcase ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:\n\n\t\ttable_desc->pointer = table;\n\t\tbreak;\n\n\tcase ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:\n\tdefault:\n\n\t\tbreak;\n\t}\n}\n\n \n\nacpi_status\nacpi_tb_acquire_table(struct acpi_table_desc *table_desc,\n\t\t      struct acpi_table_header **table_ptr,\n\t\t      u32 *table_length, u8 *table_flags)\n{\n\tstruct acpi_table_header *table = NULL;\n\n\tswitch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {\n\tcase ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:\n\n\t\ttable =\n\t\t    acpi_os_map_memory(table_desc->address, table_desc->length);\n\t\tbreak;\n\n\tcase ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:\n\tcase ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:\n\n\t\ttable = table_desc->pointer;\n\t\tbreak;\n\n\tdefault:\n\n\t\tbreak;\n\t}\n\n\t \n\n\tif (!table) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\t \n\n\t*table_ptr = table;\n\t*table_length = table_desc->length;\n\t*table_flags = table_desc->flags;\n\treturn (AE_OK);\n}\n\n \n\nvoid\nacpi_tb_release_table(struct acpi_table_header *table,\n\t\t      u32 table_length, u8 table_flags)\n{\n\n\tswitch (table_flags & ACPI_TABLE_ORIGIN_MASK) {\n\tcase ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:\n\n\t\tacpi_os_unmap_memory(table, table_length);\n\t\tbreak;\n\n\tcase ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:\n\tcase ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:\n\tdefault:\n\n\t\tbreak;\n\t}\n}\n\n \n\nacpi_status\nacpi_tb_acquire_temp_table(struct acpi_table_desc *table_desc,\n\t\t\t   acpi_physical_address address,\n\t\t\t   u8 flags, struct acpi_table_header *table)\n{\n\tu8 mapped_table = FALSE;\n\n\tswitch (flags & ACPI_TABLE_ORIGIN_MASK) {\n\tcase ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:\n\n\t\t \n\n\t\tif (!table) {\n\t\t\ttable =\n\t\t\t    acpi_os_map_memory(address,\n\t\t\t\t\t       sizeof(struct\n\t\t\t\t\t\t      acpi_table_header));\n\t\t\tif (!table) {\n\t\t\t\treturn (AE_NO_MEMORY);\n\t\t\t}\n\n\t\t\tmapped_table = TRUE;\n\t\t}\n\n\t\tbreak;\n\n\tcase ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:\n\tcase ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:\n\n\t\tif (!table) {\n\t\t\treturn (AE_BAD_PARAMETER);\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\n\t\t \n\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\tacpi_tb_init_table_descriptor(table_desc, address, flags, table);\n\tif (mapped_table) {\n\t\tacpi_os_unmap_memory(table, sizeof(struct acpi_table_header));\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nvoid acpi_tb_release_temp_table(struct acpi_table_desc *table_desc)\n{\n\n\t \n\tacpi_tb_invalidate_table(table_desc);\n}\n\n \n\nacpi_status acpi_tb_validate_table(struct acpi_table_desc *table_desc)\n{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(tb_validate_table);\n\n\t \n\n\tif (!table_desc->pointer) {\n\t\tstatus = acpi_tb_acquire_table(table_desc, &table_desc->pointer,\n\t\t\t\t\t       &table_desc->length,\n\t\t\t\t\t       &table_desc->flags);\n\t\tif (!table_desc->pointer) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nvoid acpi_tb_invalidate_table(struct acpi_table_desc *table_desc)\n{\n\n\tACPI_FUNCTION_TRACE(tb_invalidate_table);\n\n\t \n\n\tif (!table_desc->pointer) {\n\t\treturn_VOID;\n\t}\n\n\tacpi_tb_release_table(table_desc->pointer, table_desc->length,\n\t\t\t      table_desc->flags);\n\n\tswitch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {\n\tcase ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:\n\n\t\ttable_desc->pointer = NULL;\n\t\tbreak;\n\n\tcase ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:\n\tcase ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:\n\tdefault:\n\n\t\tbreak;\n\t}\n\n\treturn_VOID;\n}\n\n \n\nacpi_status acpi_tb_validate_temp_table(struct acpi_table_desc *table_desc)\n{\n\n\tif (!table_desc->pointer && !acpi_gbl_enable_table_validation) {\n\t\t \n\t\ttable_desc->length = sizeof(struct acpi_table_header);\n\t}\n\n\treturn (acpi_tb_validate_table(table_desc));\n}\n\n \n\nstatic acpi_status\nacpi_tb_check_duplication(struct acpi_table_desc *table_desc, u32 *table_index)\n{\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(tb_check_duplication);\n\n\t \n\n\tfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {\n\n\t\t \n\n\t\tif (!\n\t\t    (acpi_gbl_root_table_list.tables[i].\n\t\t     flags & ACPI_TABLE_IS_VERIFIED)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!acpi_tb_compare_tables(table_desc, i)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (acpi_gbl_root_table_list.tables[i].flags &\n\t\t    ACPI_TABLE_IS_LOADED) {\n\n\t\t\t \n\n\t\t\treturn_ACPI_STATUS(AE_ALREADY_EXISTS);\n\t\t} else {\n\t\t\t*table_index = i;\n\t\t\treturn_ACPI_STATUS(AE_CTRL_TERMINATE);\n\t\t}\n\t}\n\n\t \n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_tb_verify_temp_table(struct acpi_table_desc *table_desc,\n\t\t\t  char *signature, u32 *table_index)\n{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(tb_verify_temp_table);\n\n\t \n\n\tstatus = acpi_tb_validate_temp_table(table_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tif (signature &&\n\t    !ACPI_COMPARE_NAMESEG(&table_desc->signature, signature)) {\n\t\tACPI_BIOS_ERROR((AE_INFO,\n\t\t\t\t \"Invalid signature 0x%X for ACPI table, expected [%s]\",\n\t\t\t\t table_desc->signature.integer, signature));\n\t\tstatus = AE_BAD_SIGNATURE;\n\t\tgoto invalidate_and_exit;\n\t}\n\n\tif (acpi_gbl_enable_table_validation) {\n\n\t\t \n\n\t\tstatus =\n\t\t    acpi_ut_verify_checksum(table_desc->pointer,\n\t\t\t\t\t    table_desc->length);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,\n\t\t\t\t\t\"%4.4s 0x%8.8X%8.8X\"\n\t\t\t\t\t\" Attempted table install failed\",\n\t\t\t\t\tacpi_ut_valid_nameseg(table_desc->\n\t\t\t\t\t\t\t      signature.\n\t\t\t\t\t\t\t      ascii) ?\n\t\t\t\t\ttable_desc->signature.ascii : \"????\",\n\t\t\t\t\tACPI_FORMAT_UINT64(table_desc->\n\t\t\t\t\t\t\t   address)));\n\n\t\t\tgoto invalidate_and_exit;\n\t\t}\n\n\t\t \n\n\t\tif (table_index) {\n\t\t\tstatus =\n\t\t\t    acpi_tb_check_duplication(table_desc, table_index);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tif (status != AE_CTRL_TERMINATE) {\n\t\t\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\t\t\"%4.4s 0x%8.8X%8.8X\"\n\t\t\t\t\t\t\t\" Table is already loaded\",\n\t\t\t\t\t\t\tacpi_ut_valid_nameseg\n\t\t\t\t\t\t\t(table_desc->signature.\n\t\t\t\t\t\t\t ascii) ? table_desc->\n\t\t\t\t\t\t\tsignature.\n\t\t\t\t\t\t\tascii : \"????\",\n\t\t\t\t\t\t\tACPI_FORMAT_UINT64\n\t\t\t\t\t\t\t(table_desc->address)));\n\t\t\t\t}\n\n\t\t\t\tgoto invalidate_and_exit;\n\t\t\t}\n\t\t}\n\n\t\ttable_desc->flags |= ACPI_TABLE_IS_VERIFIED;\n\t}\n\n\treturn_ACPI_STATUS(status);\n\ninvalidate_and_exit:\n\tacpi_tb_invalidate_table(table_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_tb_resize_root_table_list(void)\n{\n\tstruct acpi_table_desc *tables;\n\tu32 table_count;\n\tu32 current_table_count, max_table_count;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(tb_resize_root_table_list);\n\n\t \n\n\tif (!(acpi_gbl_root_table_list.flags & ACPI_ROOT_ALLOW_RESIZE)) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Resize of Root Table Array is not allowed\"));\n\t\treturn_ACPI_STATUS(AE_SUPPORT);\n\t}\n\n\t \n\n\tif (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {\n\t\ttable_count = acpi_gbl_root_table_list.max_table_count;\n\t} else {\n\t\ttable_count = acpi_gbl_root_table_list.current_table_count;\n\t}\n\n\tmax_table_count = table_count + ACPI_ROOT_TABLE_SIZE_INCREMENT;\n\ttables = ACPI_ALLOCATE_ZEROED(((acpi_size)max_table_count) *\n\t\t\t\t      sizeof(struct acpi_table_desc));\n\tif (!tables) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Could not allocate new root table array\"));\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tcurrent_table_count = 0;\n\tif (acpi_gbl_root_table_list.tables) {\n\t\tfor (i = 0; i < table_count; i++) {\n\t\t\tif (acpi_gbl_root_table_list.tables[i].address) {\n\t\t\t\tmemcpy(tables + current_table_count,\n\t\t\t\t       acpi_gbl_root_table_list.tables + i,\n\t\t\t\t       sizeof(struct acpi_table_desc));\n\t\t\t\tcurrent_table_count++;\n\t\t\t}\n\t\t}\n\n\t\tif (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {\n\t\t\tACPI_FREE(acpi_gbl_root_table_list.tables);\n\t\t}\n\t}\n\n\tacpi_gbl_root_table_list.tables = tables;\n\tacpi_gbl_root_table_list.max_table_count = max_table_count;\n\tacpi_gbl_root_table_list.current_table_count = current_table_count;\n\tacpi_gbl_root_table_list.flags |= ACPI_ROOT_ORIGIN_ALLOCATED;\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_tb_get_next_table_descriptor(u32 *table_index,\n\t\t\t\t  struct acpi_table_desc **table_desc)\n{\n\tacpi_status status;\n\tu32 i;\n\n\t \n\n\tif (acpi_gbl_root_table_list.current_table_count >=\n\t    acpi_gbl_root_table_list.max_table_count) {\n\t\tstatus = acpi_tb_resize_root_table_list();\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t}\n\n\ti = acpi_gbl_root_table_list.current_table_count;\n\tacpi_gbl_root_table_list.current_table_count++;\n\n\tif (table_index) {\n\t\t*table_index = i;\n\t}\n\tif (table_desc) {\n\t\t*table_desc = &acpi_gbl_root_table_list.tables[i];\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nvoid acpi_tb_terminate(void)\n{\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(tb_terminate);\n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\n\t \n\n\tfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {\n\t\tacpi_tb_uninstall_table(&acpi_gbl_root_table_list.tables[i]);\n\t}\n\n\t \n\tif (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {\n\t\tACPI_FREE(acpi_gbl_root_table_list.tables);\n\t}\n\n\tacpi_gbl_root_table_list.tables = NULL;\n\tacpi_gbl_root_table_list.flags = 0;\n\tacpi_gbl_root_table_list.current_table_count = 0;\n\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO, \"ACPI Tables freed\\n\"));\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\treturn_VOID;\n}\n\n \n\nacpi_status acpi_tb_delete_namespace_by_owner(u32 table_index)\n{\n\tacpi_owner_id owner_id;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(tb_delete_namespace_by_owner);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tif (table_index >= acpi_gbl_root_table_list.current_table_count) {\n\n\t\t \n\n\t\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t}\n\n\t \n\n\towner_id = acpi_gbl_root_table_list.tables[table_index].owner_id;\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\n\t \n\tstatus = acpi_ut_acquire_write_lock(&acpi_gbl_namespace_rw_lock);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tacpi_ns_delete_namespace_by_owner(owner_id);\n\tacpi_ut_release_write_lock(&acpi_gbl_namespace_rw_lock);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_tb_allocate_owner_id(u32 table_index)\n{\n\tacpi_status status = AE_BAD_PARAMETER;\n\n\tACPI_FUNCTION_TRACE(tb_allocate_owner_id);\n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\tif (table_index < acpi_gbl_root_table_list.current_table_count) {\n\t\tstatus =\n\t\t    acpi_ut_allocate_owner_id(&\n\t\t\t\t\t      (acpi_gbl_root_table_list.\n\t\t\t\t\t       tables[table_index].owner_id));\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_tb_release_owner_id(u32 table_index)\n{\n\tacpi_status status = AE_BAD_PARAMETER;\n\n\tACPI_FUNCTION_TRACE(tb_release_owner_id);\n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\tif (table_index < acpi_gbl_root_table_list.current_table_count) {\n\t\tacpi_ut_release_owner_id(&\n\t\t\t\t\t (acpi_gbl_root_table_list.\n\t\t\t\t\t  tables[table_index].owner_id));\n\t\tstatus = AE_OK;\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_tb_get_owner_id(u32 table_index, acpi_owner_id *owner_id)\n{\n\tacpi_status status = AE_BAD_PARAMETER;\n\n\tACPI_FUNCTION_TRACE(tb_get_owner_id);\n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\tif (table_index < acpi_gbl_root_table_list.current_table_count) {\n\t\t*owner_id =\n\t\t    acpi_gbl_root_table_list.tables[table_index].owner_id;\n\t\tstatus = AE_OK;\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nu8 acpi_tb_is_table_loaded(u32 table_index)\n{\n\tu8 is_loaded = FALSE;\n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\tif (table_index < acpi_gbl_root_table_list.current_table_count) {\n\t\tis_loaded = (u8)\n\t\t    (acpi_gbl_root_table_list.tables[table_index].flags &\n\t\t     ACPI_TABLE_IS_LOADED);\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\treturn (is_loaded);\n}\n\n \n\nvoid acpi_tb_set_table_loaded_flag(u32 table_index, u8 is_loaded)\n{\n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\tif (table_index < acpi_gbl_root_table_list.current_table_count) {\n\t\tif (is_loaded) {\n\t\t\tacpi_gbl_root_table_list.tables[table_index].flags |=\n\t\t\t    ACPI_TABLE_IS_LOADED;\n\t\t} else {\n\t\t\tacpi_gbl_root_table_list.tables[table_index].flags &=\n\t\t\t    ~ACPI_TABLE_IS_LOADED;\n\t\t}\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n}\n\n \n\nacpi_status\nacpi_tb_load_table(u32 table_index, struct acpi_namespace_node *parent_node)\n{\n\tstruct acpi_table_header *table;\n\tacpi_status status;\n\tacpi_owner_id owner_id;\n\n\tACPI_FUNCTION_TRACE(tb_load_table);\n\n\t \n\tstatus = acpi_get_table_by_index(table_index, &table);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_ns_load_table(table_index, parent_node);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tstatus = acpi_tb_get_owner_id(table_index, &owner_id);\n\tif (ACPI_SUCCESS(status)) {\n\t\tacpi_ev_update_gpes(owner_id);\n\t}\n\n\t \n\n\tacpi_tb_notify_table(ACPI_TABLE_EVENT_LOAD, table);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_tb_install_and_load_table(acpi_physical_address address,\n\t\t\t       u8 flags,\n\t\t\t       struct acpi_table_header *table,\n\t\t\t       u8 override, u32 *table_index)\n{\n\tacpi_status status;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(tb_install_and_load_table);\n\n\t \n\n\tstatus = acpi_tb_install_standard_table(address, flags, table, TRUE,\n\t\t\t\t\t\toverride, &i);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\tstatus = acpi_tb_load_table(i, acpi_gbl_root_node);\n\nexit:\n\t*table_index = i;\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_tb_install_and_load_table)\n\n \n\nacpi_status acpi_tb_unload_table(u32 table_index)\n{\n\tacpi_status status = AE_OK;\n\tstruct acpi_table_header *table;\n\n\tACPI_FUNCTION_TRACE(tb_unload_table);\n\n\t \n\n\tif (!acpi_tb_is_table_loaded(table_index)) {\n\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t}\n\n\t \n\n\tstatus = acpi_get_table_by_index(table_index, &table);\n\tif (ACPI_SUCCESS(status)) {\n\t\tacpi_tb_notify_table(ACPI_TABLE_EVENT_UNLOAD, table);\n\t}\n\n\t \n\n\tstatus = acpi_tb_delete_namespace_by_owner(table_index);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t(void)acpi_tb_release_owner_id(table_index);\n\tacpi_tb_set_table_loaded_flag(table_index, FALSE);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_tb_unload_table)\n\n \n\nvoid acpi_tb_notify_table(u32 event, void *table)\n{\n\t \n\n\tif (acpi_gbl_table_handler) {\n\t\t(void)acpi_gbl_table_handler(event, table,\n\t\t\t\t\t     acpi_gbl_table_handler_context);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}