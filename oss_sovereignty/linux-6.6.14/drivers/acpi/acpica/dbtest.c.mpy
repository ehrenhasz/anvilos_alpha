{
  "module_name": "dbtest.c",
  "hash_id": "9e655d548d4d8e3022ce10c9aa28b521ece0e543bc5a78010e59ef668cc48478",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/dbtest.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acdebug.h\"\n#include \"acnamesp.h\"\n#include \"acpredef.h\"\n#include \"acinterp.h\"\n\n#define _COMPONENT          ACPI_CA_DEBUGGER\nACPI_MODULE_NAME(\"dbtest\")\n\n \nstatic void acpi_db_test_all_objects(void);\n\nstatic acpi_status\nacpi_db_test_one_object(acpi_handle obj_handle,\n\t\t\tu32 nesting_level, void *context, void **return_value);\n\nstatic acpi_status\nacpi_db_test_integer_type(struct acpi_namespace_node *node, u32 bit_length);\n\nstatic acpi_status\nacpi_db_test_buffer_type(struct acpi_namespace_node *node, u32 bit_length);\n\nstatic acpi_status\nacpi_db_test_string_type(struct acpi_namespace_node *node, u32 byte_length);\n\nstatic acpi_status acpi_db_test_package_type(struct acpi_namespace_node *node);\n\nstatic acpi_status\nacpi_db_test_field_unit_type(union acpi_operand_object *obj_desc);\n\nstatic acpi_status\nacpi_db_read_from_object(struct acpi_namespace_node *node,\n\t\t\t acpi_object_type expected_type,\n\t\t\t union acpi_object **value);\n\nstatic acpi_status\nacpi_db_write_to_object(struct acpi_namespace_node *node,\n\t\t\tunion acpi_object *value);\n\nstatic void acpi_db_evaluate_all_predefined_names(char *count_arg);\n\nstatic acpi_status\nacpi_db_evaluate_one_predefined_name(acpi_handle obj_handle,\n\t\t\t\t     u32 nesting_level,\n\t\t\t\t     void *context, void **return_value);\n\n \nstatic struct acpi_db_argument_info acpi_db_test_types[] = {\n\t{\"OBJECTS\"},\n\t{\"PREDEFINED\"},\n\t{NULL}\t\t\t \n};\n\n#define CMD_TEST_OBJECTS        0\n#define CMD_TEST_PREDEFINED     1\n\n#define BUFFER_FILL_VALUE       0xFF\n\n \n#define ACPI_DB_READ_METHOD     \"\\\\_T98\"\n#define ACPI_DB_WRITE_METHOD    \"\\\\_T99\"\n\nstatic acpi_handle read_handle = NULL;\nstatic acpi_handle write_handle = NULL;\n\n \n\n#if 0\ndefinition_block(\"ssdt.aml\", \"SSDT\", 2, \"Intel\", \"DEBUG\", 0x00000001)\n{\n\tmethod(_T98, 1, not_serialized) {\t \n\t\treturn (de_ref_of(arg0))\n\t}\n}\n\ndefinition_block(\"ssdt2.aml\", \"SSDT\", 2, \"Intel\", \"DEBUG\", 0x00000001)\n{\n\tmethod(_T99, 2, not_serialized) {\t \n\t\tstore(arg1, arg0)\n\t}\n}\n#endif\n\nstatic unsigned char read_method_code[] = {\n\t0x53, 0x53, 0x44, 0x54, 0x2E, 0x00, 0x00, 0x00,\t \n\t0x02, 0xC9, 0x49, 0x6E, 0x74, 0x65, 0x6C, 0x00,\t \n\t0x44, 0x45, 0x42, 0x55, 0x47, 0x00, 0x00, 0x00,\t \n\t0x01, 0x00, 0x00, 0x00, 0x49, 0x4E, 0x54, 0x4C,\t \n\t0x18, 0x12, 0x13, 0x20, 0x14, 0x09, 0x5F, 0x54,\t \n\t0x39, 0x38, 0x01, 0xA4, 0x83, 0x68\t \n};\n\nstatic unsigned char write_method_code[] = {\n\t0x53, 0x53, 0x44, 0x54, 0x2E, 0x00, 0x00, 0x00,\t \n\t0x02, 0x15, 0x49, 0x6E, 0x74, 0x65, 0x6C, 0x00,\t \n\t0x44, 0x45, 0x42, 0x55, 0x47, 0x00, 0x00, 0x00,\t \n\t0x01, 0x00, 0x00, 0x00, 0x49, 0x4E, 0x54, 0x4C,\t \n\t0x18, 0x12, 0x13, 0x20, 0x14, 0x09, 0x5F, 0x54,\t \n\t0x39, 0x39, 0x02, 0x70, 0x69, 0x68\t \n};\n\n \n\nvoid acpi_db_execute_test(char *type_arg)\n{\n\tu32 temp;\n\n\tacpi_ut_strupr(type_arg);\n\ttemp = acpi_db_match_argument(type_arg, acpi_db_test_types);\n\tif (temp == ACPI_TYPE_NOT_FOUND) {\n\t\tacpi_os_printf(\"Invalid or unsupported argument\\n\");\n\t\treturn;\n\t}\n\n\tswitch (temp) {\n\tcase CMD_TEST_OBJECTS:\n\n\t\tacpi_db_test_all_objects();\n\t\tbreak;\n\n\tcase CMD_TEST_PREDEFINED:\n\n\t\tacpi_db_evaluate_all_predefined_names(NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \n\nstatic void acpi_db_test_all_objects(void)\n{\n\tacpi_status status;\n\n\t \n\n\tif (!read_handle) {\n\t\tstatus = acpi_install_method(read_method_code);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"%s, Could not install debugger read method\\n\",\n\t\t\t     acpi_format_exception(status));\n\t\t\treturn;\n\t\t}\n\n\t\tstatus =\n\t\t    acpi_get_handle(NULL, ACPI_DB_READ_METHOD, &read_handle);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Could not obtain handle for debug method %s\\n\",\n\t\t\t     ACPI_DB_READ_METHOD);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\n\tif (!write_handle) {\n\t\tstatus = acpi_install_method(write_method_code);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"%s, Could not install debugger write method\\n\",\n\t\t\t     acpi_format_exception(status));\n\t\t\treturn;\n\t\t}\n\n\t\tstatus =\n\t\t    acpi_get_handle(NULL, ACPI_DB_WRITE_METHOD, &write_handle);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Could not obtain handle for debug method %s\\n\",\n\t\t\t     ACPI_DB_WRITE_METHOD);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\n\t(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\n\t\t\t\t  ACPI_UINT32_MAX, acpi_db_test_one_object,\n\t\t\t\t  NULL, NULL, NULL);\n}\n\n \n\nstatic acpi_status\nacpi_db_test_one_object(acpi_handle obj_handle,\n\t\t\tu32 nesting_level, void *context, void **return_value)\n{\n\tstruct acpi_namespace_node *node;\n\tunion acpi_operand_object *obj_desc;\n\tacpi_object_type local_type;\n\tu32 bit_length = 0;\n\tu32 byte_length = 0;\n\tacpi_status status = AE_OK;\n\n\tnode = ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);\n\tobj_desc = node->object;\n\n\t \n\tswitch (node->type) {\n\tcase ACPI_TYPE_INTEGER:\n\n\t\t \n\n\t\tlocal_type = ACPI_TYPE_INTEGER;\n\t\tbit_length = acpi_gbl_integer_bit_width;\n\t\tbreak;\n\n\tcase ACPI_TYPE_STRING:\n\n\t\tlocal_type = ACPI_TYPE_STRING;\n\t\tbyte_length = obj_desc->string.length;\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\tlocal_type = ACPI_TYPE_BUFFER;\n\t\tbyte_length = obj_desc->buffer.length;\n\t\tbit_length = byte_length * 8;\n\t\tbreak;\n\n\tcase ACPI_TYPE_PACKAGE:\n\n\t\tlocal_type = ACPI_TYPE_PACKAGE;\n\t\tbreak;\n\n\tcase ACPI_TYPE_FIELD_UNIT:\n\tcase ACPI_TYPE_LOCAL_REGION_FIELD:\n\tcase ACPI_TYPE_LOCAL_INDEX_FIELD:\n\tcase ACPI_TYPE_LOCAL_BANK_FIELD:\n\n\t\tlocal_type = ACPI_TYPE_FIELD_UNIT;\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER_FIELD:\n\t\t \n\t\tlocal_type = ACPI_TYPE_INTEGER;\n\t\tif (obj_desc) {\n\t\t\tbit_length = obj_desc->common_field.bit_length;\n\t\t\tbyte_length = ACPI_ROUND_BITS_UP_TO_BYTES(bit_length);\n\t\t\tif (bit_length > acpi_gbl_integer_bit_width) {\n\t\t\t\tlocal_type = ACPI_TYPE_BUFFER;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\t \n\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tacpi_os_printf(\"%14s: %4.4s\",\n\t\t       acpi_ut_get_type_name(node->type), node->name.ascii);\n\n\tif (!obj_desc) {\n\t\tacpi_os_printf(\" No attached sub-object, ignoring\\n\");\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tswitch (local_type) {\n\tcase ACPI_TYPE_INTEGER:\n\n\t\tstatus = acpi_db_test_integer_type(node, bit_length);\n\t\tbreak;\n\n\tcase ACPI_TYPE_STRING:\n\n\t\tstatus = acpi_db_test_string_type(node, byte_length);\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\tstatus = acpi_db_test_buffer_type(node, bit_length);\n\t\tbreak;\n\n\tcase ACPI_TYPE_PACKAGE:\n\n\t\tstatus = acpi_db_test_package_type(node);\n\t\tbreak;\n\n\tcase ACPI_TYPE_FIELD_UNIT:\n\n\t\tstatus = acpi_db_test_field_unit_type(obj_desc);\n\t\tbreak;\n\n\tdefault:\n\n\t\tacpi_os_printf(\" Ignoring, type not implemented (%2.2X)\",\n\t\t\t       local_type);\n\t\tbreak;\n\t}\n\n\t \n\n\tif (ACPI_FAILURE(status)) {\n\t\tstatus = AE_OK;\n\t}\n\n\tacpi_os_printf(\"\\n\");\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nacpi_db_test_integer_type(struct acpi_namespace_node *node, u32 bit_length)\n{\n\tunion acpi_object *temp1 = NULL;\n\tunion acpi_object *temp2 = NULL;\n\tunion acpi_object *temp3 = NULL;\n\tunion acpi_object write_value;\n\tu64 value_to_write;\n\tacpi_status status;\n\n\tif (bit_length > 64) {\n\t\tacpi_os_printf(\" Invalid length for an Integer: %u\",\n\t\t\t       bit_length);\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tstatus = acpi_db_read_from_object(node, ACPI_TYPE_INTEGER, &temp1);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tacpi_os_printf(ACPI_DEBUG_LENGTH_FORMAT \" %8.8X%8.8X\",\n\t\t       bit_length, ACPI_ROUND_BITS_UP_TO_BYTES(bit_length),\n\t\t       ACPI_FORMAT_UINT64(temp1->integer.value));\n\n\tvalue_to_write = ACPI_UINT64_MAX >> (64 - bit_length);\n\tif (temp1->integer.value == value_to_write) {\n\t\tvalue_to_write = 0;\n\t}\n\t \n\n\twrite_value.type = ACPI_TYPE_INTEGER;\n\twrite_value.integer.value = value_to_write;\n\tstatus = acpi_db_write_to_object(node, &write_value);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\t \n\n\tstatus = acpi_db_read_from_object(node, ACPI_TYPE_INTEGER, &temp2);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\tif (temp2->integer.value != value_to_write) {\n\t\tacpi_os_printf(\" MISMATCH 2: %8.8X%8.8X, expecting %8.8X%8.8X\",\n\t\t\t       ACPI_FORMAT_UINT64(temp2->integer.value),\n\t\t\t       ACPI_FORMAT_UINT64(value_to_write));\n\t}\n\n\t \n\n\twrite_value.integer.value = temp1->integer.value;\n\tstatus = acpi_db_write_to_object(node, &write_value);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\t \n\n\tstatus = acpi_db_read_from_object(node, ACPI_TYPE_INTEGER, &temp3);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\tif (temp3->integer.value != temp1->integer.value) {\n\t\tacpi_os_printf(\" MISMATCH 3: %8.8X%8.8X, expecting %8.8X%8.8X\",\n\t\t\t       ACPI_FORMAT_UINT64(temp3->integer.value),\n\t\t\t       ACPI_FORMAT_UINT64(temp1->integer.value));\n\t}\n\nexit:\n\tif (temp1) {\n\t\tacpi_os_free(temp1);\n\t}\n\tif (temp2) {\n\t\tacpi_os_free(temp2);\n\t}\n\tif (temp3) {\n\t\tacpi_os_free(temp3);\n\t}\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_db_test_buffer_type(struct acpi_namespace_node *node, u32 bit_length)\n{\n\tunion acpi_object *temp1 = NULL;\n\tunion acpi_object *temp2 = NULL;\n\tunion acpi_object *temp3 = NULL;\n\tu8 *buffer;\n\tunion acpi_object write_value;\n\tacpi_status status;\n\tu32 byte_length;\n\tu32 i;\n\tu8 extra_bits;\n\n\tbyte_length = ACPI_ROUND_BITS_UP_TO_BYTES(bit_length);\n\tif (byte_length == 0) {\n\t\tacpi_os_printf(\" Ignoring zero length buffer\");\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tbuffer = ACPI_ALLOCATE_ZEROED(byte_length);\n\tif (!buffer) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\t \n\n\tstatus = acpi_db_read_from_object(node, ACPI_TYPE_BUFFER, &temp1);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\t \n\n\tacpi_os_printf(ACPI_DEBUG_LENGTH_FORMAT, bit_length,\n\t\t       temp1->buffer.length);\n\tfor (i = 0; ((i < 8) && (i < byte_length)); i++) {\n\t\tacpi_os_printf(\" %2.2X\", temp1->buffer.pointer[i]);\n\t}\n\tacpi_os_printf(\"... \");\n\n\t \n\tmemset(buffer, BUFFER_FILL_VALUE, byte_length);\n\textra_bits = bit_length % 8;\n\tif (extra_bits) {\n\t\tbuffer[byte_length - 1] = ACPI_MASK_BITS_ABOVE(extra_bits);\n\t}\n\n\twrite_value.type = ACPI_TYPE_BUFFER;\n\twrite_value.buffer.length = byte_length;\n\twrite_value.buffer.pointer = buffer;\n\n\tstatus = acpi_db_write_to_object(node, &write_value);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\t \n\n\tstatus = acpi_db_read_from_object(node, ACPI_TYPE_BUFFER, &temp2);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\tif (memcmp(temp2->buffer.pointer, buffer, byte_length)) {\n\t\tacpi_os_printf(\" MISMATCH 2: New buffer value\");\n\t}\n\n\t \n\n\twrite_value.buffer.length = byte_length;\n\twrite_value.buffer.pointer = temp1->buffer.pointer;\n\n\tstatus = acpi_db_write_to_object(node, &write_value);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\t \n\n\tstatus = acpi_db_read_from_object(node, ACPI_TYPE_BUFFER, &temp3);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\tif (memcmp(temp1->buffer.pointer, temp3->buffer.pointer, byte_length)) {\n\t\tacpi_os_printf(\" MISMATCH 3: While restoring original buffer\");\n\t}\n\nexit:\n\tACPI_FREE(buffer);\n\tif (temp1) {\n\t\tacpi_os_free(temp1);\n\t}\n\tif (temp2) {\n\t\tacpi_os_free(temp2);\n\t}\n\tif (temp3) {\n\t\tacpi_os_free(temp3);\n\t}\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nacpi_db_test_string_type(struct acpi_namespace_node *node, u32 byte_length)\n{\n\tunion acpi_object *temp1 = NULL;\n\tunion acpi_object *temp2 = NULL;\n\tunion acpi_object *temp3 = NULL;\n\tchar *value_to_write = \"Test String from AML Debugger\";\n\tunion acpi_object write_value;\n\tacpi_status status;\n\n\t \n\n\tstatus = acpi_db_read_from_object(node, ACPI_TYPE_STRING, &temp1);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tacpi_os_printf(ACPI_DEBUG_LENGTH_FORMAT \" \\\"%s\\\"\",\n\t\t       (temp1->string.length * 8), temp1->string.length,\n\t\t       temp1->string.pointer);\n\n\t \n\n\twrite_value.type = ACPI_TYPE_STRING;\n\twrite_value.string.length = strlen(value_to_write);\n\twrite_value.string.pointer = value_to_write;\n\n\tstatus = acpi_db_write_to_object(node, &write_value);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\t \n\n\tstatus = acpi_db_read_from_object(node, ACPI_TYPE_STRING, &temp2);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\tif (strcmp(temp2->string.pointer, value_to_write)) {\n\t\tacpi_os_printf(\" MISMATCH 2: %s, expecting %s\",\n\t\t\t       temp2->string.pointer, value_to_write);\n\t}\n\n\t \n\n\twrite_value.string.length = strlen(temp1->string.pointer);\n\twrite_value.string.pointer = temp1->string.pointer;\n\n\tstatus = acpi_db_write_to_object(node, &write_value);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\t \n\n\tstatus = acpi_db_read_from_object(node, ACPI_TYPE_STRING, &temp3);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\tif (strcmp(temp1->string.pointer, temp3->string.pointer)) {\n\t\tacpi_os_printf(\" MISMATCH 3: %s, expecting %s\",\n\t\t\t       temp3->string.pointer, temp1->string.pointer);\n\t}\n\nexit:\n\tif (temp1) {\n\t\tacpi_os_free(temp1);\n\t}\n\tif (temp2) {\n\t\tacpi_os_free(temp2);\n\t}\n\tif (temp3) {\n\t\tacpi_os_free(temp3);\n\t}\n\treturn (status);\n}\n\n \n\nstatic acpi_status acpi_db_test_package_type(struct acpi_namespace_node *node)\n{\n\tunion acpi_object *temp1 = NULL;\n\tacpi_status status;\n\n\t \n\n\tstatus = acpi_db_read_from_object(node, ACPI_TYPE_PACKAGE, &temp1);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tacpi_os_printf(\" %.2X Elements\", temp1->package.count);\n\tacpi_os_free(temp1);\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nacpi_db_test_field_unit_type(union acpi_operand_object *obj_desc)\n{\n\tunion acpi_operand_object *region_obj;\n\tu32 bit_length = 0;\n\tu32 byte_length = 0;\n\tacpi_status status = AE_OK;\n\tunion acpi_operand_object *ret_buffer_desc;\n\n\t \n\n\tregion_obj = obj_desc->field.region_obj;\n\tswitch (region_obj->region.space_id) {\n\tcase ACPI_ADR_SPACE_SYSTEM_MEMORY:\n\tcase ACPI_ADR_SPACE_SYSTEM_IO:\n\tcase ACPI_ADR_SPACE_PCI_CONFIG:\n\n\t\t \n\n\t\tacpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);\n\t\tacpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\n\t\t \n\n\t\tstatus =\n\t\t    acpi_ex_read_data_from_field(NULL, obj_desc,\n\t\t\t\t\t\t &ret_buffer_desc);\n\t\tif (status == AE_OK) {\n\t\t\tacpi_ex_write_data_to_field(ret_buffer_desc, obj_desc,\n\t\t\t\t\t\t    NULL);\n\t\t\tacpi_ut_remove_reference(ret_buffer_desc);\n\t\t}\n\n\t\tacpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\t\tacpi_ut_release_mutex(ACPI_MTX_INTERPRETER);\n\n\t\tbit_length = obj_desc->common_field.bit_length;\n\t\tbyte_length = ACPI_ROUND_BITS_UP_TO_BYTES(bit_length);\n\n\t\tacpi_os_printf(ACPI_DEBUG_LENGTH_FORMAT \" [%s]\", bit_length,\n\t\t\t       byte_length,\n\t\t\t       acpi_ut_get_region_name(region_obj->region.\n\t\t\t\t\t\t       space_id));\n\t\treturn (status);\n\n\tdefault:\n\n\t\tacpi_os_printf\n\t\t    (\"      %s address space is not supported in this command [%4.4s]\",\n\t\t     acpi_ut_get_region_name(region_obj->region.space_id),\n\t\t     region_obj->region.node->name.ascii);\n\t\treturn (AE_OK);\n\t}\n}\n\n \n\nstatic acpi_status\nacpi_db_read_from_object(struct acpi_namespace_node *node,\n\t\t\t acpi_object_type expected_type,\n\t\t\t union acpi_object **value)\n{\n\tunion acpi_object *ret_value;\n\tstruct acpi_object_list param_objects;\n\tunion acpi_object params[2];\n\tstruct acpi_buffer return_obj;\n\tacpi_status status;\n\n\tparams[0].type = ACPI_TYPE_LOCAL_REFERENCE;\n\tparams[0].reference.actual_type = node->type;\n\tparams[0].reference.handle = ACPI_CAST_PTR(acpi_handle, node);\n\n\tparam_objects.count = 1;\n\tparam_objects.pointer = params;\n\n\treturn_obj.length = ACPI_ALLOCATE_BUFFER;\n\n\tacpi_gbl_method_executing = TRUE;\n\tstatus = acpi_evaluate_object(read_handle, NULL,\n\t\t\t\t      &param_objects, &return_obj);\n\n\tacpi_gbl_method_executing = FALSE;\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could not read from object, %s\",\n\t\t\t       acpi_format_exception(status));\n\t\treturn (status);\n\t}\n\n\tret_value = (union acpi_object *)return_obj.pointer;\n\n\tswitch (ret_value->type) {\n\tcase ACPI_TYPE_INTEGER:\n\tcase ACPI_TYPE_BUFFER:\n\tcase ACPI_TYPE_STRING:\n\tcase ACPI_TYPE_PACKAGE:\n\t\t \n\t\tif (ret_value->type != expected_type) {\n\t\t\tacpi_os_printf\n\t\t\t    (\" Type mismatch: Expected %s, Received %s\",\n\t\t\t     acpi_ut_get_type_name(expected_type),\n\t\t\t     acpi_ut_get_type_name(ret_value->type));\n\n\t\t\tacpi_os_free(return_obj.pointer);\n\t\t\treturn (AE_TYPE);\n\t\t}\n\n\t\t*value = ret_value;\n\t\tbreak;\n\n\tdefault:\n\n\t\tacpi_os_printf(\" Unsupported return object type, %s\",\n\t\t\t       acpi_ut_get_type_name(ret_value->type));\n\n\t\tacpi_os_free(return_obj.pointer);\n\t\treturn (AE_TYPE);\n\t}\n\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nacpi_db_write_to_object(struct acpi_namespace_node *node,\n\t\t\tunion acpi_object *value)\n{\n\tstruct acpi_object_list param_objects;\n\tunion acpi_object params[2];\n\tacpi_status status;\n\n\tparams[0].type = ACPI_TYPE_LOCAL_REFERENCE;\n\tparams[0].reference.actual_type = node->type;\n\tparams[0].reference.handle = ACPI_CAST_PTR(acpi_handle, node);\n\n\t \n\n\tmemcpy(&params[1], value, sizeof(union acpi_object));\n\n\tparam_objects.count = 2;\n\tparam_objects.pointer = params;\n\n\tacpi_gbl_method_executing = TRUE;\n\tstatus = acpi_evaluate_object(write_handle, NULL, &param_objects, NULL);\n\tacpi_gbl_method_executing = FALSE;\n\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could not write to object, %s\",\n\t\t\t       acpi_format_exception(status));\n\t}\n\n\treturn (status);\n}\n\n \n\nstatic void acpi_db_evaluate_all_predefined_names(char *count_arg)\n{\n\tstruct acpi_db_execute_walk info;\n\n\tinfo.count = 0;\n\tinfo.max_count = ACPI_UINT32_MAX;\n\n\tif (count_arg) {\n\t\tinfo.max_count = strtoul(count_arg, NULL, 0);\n\t}\n\n\t \n\n\t(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\n\t\t\t\t  ACPI_UINT32_MAX,\n\t\t\t\t  acpi_db_evaluate_one_predefined_name, NULL,\n\t\t\t\t  (void *)&info, NULL);\n\n\tacpi_os_printf(\"Evaluated %u predefined names in the namespace\\n\",\n\t\t       info.count);\n}\n\n \n\nstatic acpi_status\nacpi_db_evaluate_one_predefined_name(acpi_handle obj_handle,\n\t\t\t\t     u32 nesting_level,\n\t\t\t\t     void *context, void **return_value)\n{\n\tstruct acpi_namespace_node *node =\n\t    (struct acpi_namespace_node *)obj_handle;\n\tstruct acpi_db_execute_walk *info =\n\t    (struct acpi_db_execute_walk *)context;\n\tchar *pathname;\n\tconst union acpi_predefined_info *predefined;\n\tstruct acpi_device_info *obj_info;\n\tstruct acpi_object_list param_objects;\n\tunion acpi_object params[ACPI_METHOD_NUM_ARGS];\n\tunion acpi_object *this_param;\n\tstruct acpi_buffer return_obj;\n\tacpi_status status;\n\tu16 arg_type_list;\n\tu8 arg_count;\n\tu8 arg_type;\n\tu32 i;\n\n\t \n\n\tpredefined = acpi_ut_match_predefined_method(node->name.ascii);\n\tif (!predefined) {\n\t\treturn (AE_OK);\n\t}\n\n\tif (node->type == ACPI_TYPE_LOCAL_SCOPE) {\n\t\treturn (AE_OK);\n\t}\n\n\tpathname = acpi_ns_get_normalized_pathname(node, TRUE);\n\tif (!pathname) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tstatus = acpi_get_object_info(obj_handle, &obj_info);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_FREE(pathname);\n\t\treturn (status);\n\t}\n\n\tparam_objects.count = 0;\n\tparam_objects.pointer = NULL;\n\n\tif (obj_info->type == ACPI_TYPE_METHOD) {\n\n\t\t \n\n\t\targ_type_list = predefined->info.argument_list;\n\t\targ_count = METHOD_GET_ARG_COUNT(arg_type_list);\n\n\t\t \n\t\tthis_param = params;\n\t\tfor (i = 0; i < arg_count; i++) {\n\t\t\targ_type = METHOD_GET_NEXT_TYPE(arg_type_list);\n\t\t\tthis_param->type = arg_type;\n\n\t\t\tswitch (arg_type) {\n\t\t\tcase ACPI_TYPE_INTEGER:\n\n\t\t\t\tthis_param->integer.value = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACPI_TYPE_STRING:\n\n\t\t\t\tthis_param->string.pointer =\n\t\t\t\t    \"This is the default argument string\";\n\t\t\t\tthis_param->string.length =\n\t\t\t\t    strlen(this_param->string.pointer);\n\t\t\t\tbreak;\n\n\t\t\tcase ACPI_TYPE_BUFFER:\n\n\t\t\t\tthis_param->buffer.pointer = (u8 *)params;\t \n\t\t\t\tthis_param->buffer.length = 48;\n\t\t\t\tbreak;\n\n\t\t\tcase ACPI_TYPE_PACKAGE:\n\n\t\t\t\tthis_param->package.elements = NULL;\n\t\t\t\tthis_param->package.count = 0;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tacpi_os_printf\n\t\t\t\t    (\"%s: Unsupported argument type: %u\\n\",\n\t\t\t\t     pathname, arg_type);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis_param++;\n\t\t}\n\n\t\tparam_objects.count = arg_count;\n\t\tparam_objects.pointer = params;\n\t}\n\n\tACPI_FREE(obj_info);\n\treturn_obj.pointer = NULL;\n\treturn_obj.length = ACPI_ALLOCATE_BUFFER;\n\n\t \n\n\tacpi_gbl_method_executing = TRUE;\n\n\tstatus = acpi_evaluate_object(node, NULL, &param_objects, &return_obj);\n\n\tacpi_os_printf(\"%-32s returned %s\\n\",\n\t\t       pathname, acpi_format_exception(status));\n\tacpi_gbl_method_executing = FALSE;\n\tACPI_FREE(pathname);\n\n\t \n\n\tstatus = AE_OK;\n\n\t \n\n\tinfo->count++;\n\tif (info->count >= info->max_count) {\n\t\tstatus = AE_CTRL_TERMINATE;\n\t}\n\n\treturn (status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}