{
  "module_name": "evxfgpe.c",
  "hash_id": "75a5eec1924e1225ec4f32c4796e9c2d2db8694f4a2730981c5609e29f587ebd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evxfgpe.c",
  "human_readable_source": "\n \n\n#define EXPORT_ACPI_INTERFACES\n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evxfgpe\")\n\n#if (!ACPI_REDUCED_HARDWARE)\t \n \n\nacpi_status acpi_update_all_gpes(void)\n{\n\tacpi_status status;\n\tu8 is_polling_needed = FALSE;\n\n\tACPI_FUNCTION_TRACE(acpi_update_all_gpes);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tif (acpi_gbl_all_gpes_initialized) {\n\t\tgoto unlock_and_exit;\n\t}\n\n\tstatus = acpi_ev_walk_gpe_list(acpi_ev_initialize_gpe_block,\n\t\t\t\t       &is_polling_needed);\n\tif (ACPI_SUCCESS(status)) {\n\t\tacpi_gbl_all_gpes_initialized = TRUE;\n\t}\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\n\tif (is_polling_needed && acpi_gbl_all_gpes_initialized) {\n\n\t\t \n\n\t\tacpi_ev_gpe_detect(acpi_gbl_gpe_xrupt_list_head);\n\t}\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_update_all_gpes)\n\n \nacpi_status acpi_enable_gpe(acpi_handle gpe_device, u32 gpe_number)\n{\n\tacpi_status status = AE_BAD_PARAMETER;\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(acpi_enable_gpe);\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\n\tif (gpe_event_info) {\n\t\tif (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) !=\n\t\t    ACPI_GPE_DISPATCH_NONE) {\n\t\t\tstatus = acpi_ev_add_gpe_reference(gpe_event_info, TRUE);\n\t\t\tif (ACPI_SUCCESS(status) &&\n\t\t\t    ACPI_GPE_IS_POLLING_NEEDED(gpe_event_info)) {\n\n\t\t\t\t \n\n\t\t\t\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\t\t\t\t(void)acpi_ev_detect_gpe(gpe_device,\n\t\t\t\t\t\t\t gpe_event_info,\n\t\t\t\t\t\t\t gpe_number);\n\t\t\t\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = AE_NO_HANDLER;\n\t\t}\n\t}\n\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn_ACPI_STATUS(status);\n}\nACPI_EXPORT_SYMBOL(acpi_enable_gpe)\n\n \n\nacpi_status acpi_disable_gpe(acpi_handle gpe_device, u32 gpe_number)\n{\n\tacpi_status status = AE_BAD_PARAMETER;\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(acpi_disable_gpe);\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\n\tif (gpe_event_info) {\n\t\tstatus = acpi_ev_remove_gpe_reference(gpe_event_info) ;\n\t}\n\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_disable_gpe)\n\n \nacpi_status acpi_set_gpe(acpi_handle gpe_device, u32 gpe_number, u8 action)\n{\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tacpi_status status;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(acpi_set_gpe);\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\n\tif (!gpe_event_info) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tswitch (action) {\n\tcase ACPI_GPE_ENABLE:\n\n\t\tstatus = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_ENABLE);\n\t\tgpe_event_info->disable_for_dispatch = FALSE;\n\t\tbreak;\n\n\tcase ACPI_GPE_DISABLE:\n\n\t\tstatus = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_DISABLE);\n\t\tgpe_event_info->disable_for_dispatch = TRUE;\n\t\tbreak;\n\n\tdefault:\n\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tbreak;\n\t}\n\nunlock_and_exit:\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_set_gpe)\n\n \nacpi_status acpi_mask_gpe(acpi_handle gpe_device, u32 gpe_number, u8 is_masked)\n{\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tacpi_status status;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(acpi_mask_gpe);\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\n\tif (!gpe_event_info) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\tstatus = acpi_ev_mask_gpe(gpe_event_info, is_masked);\n\nunlock_and_exit:\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_mask_gpe)\n\n \nacpi_status acpi_mark_gpe_for_wake(acpi_handle gpe_device, u32 gpe_number)\n{\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tacpi_status status = AE_BAD_PARAMETER;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(acpi_mark_gpe_for_wake);\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\n\tif (gpe_event_info) {\n\n\t\t \n\n\t\tgpe_event_info->flags |= ACPI_GPE_CAN_WAKE;\n\t\tstatus = AE_OK;\n\t}\n\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_mark_gpe_for_wake)\n\n \nacpi_status\nacpi_setup_gpe_for_wake(acpi_handle wake_device,\n\t\t\tacpi_handle gpe_device, u32 gpe_number)\n{\n\tacpi_status status;\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tstruct acpi_namespace_node *device_node;\n\tstruct acpi_gpe_notify_info *notify;\n\tstruct acpi_gpe_notify_info *new_notify;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(acpi_setup_gpe_for_wake);\n\n\t \n\n\tif (!wake_device) {\n\t\t \n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tif (wake_device == ACPI_ROOT_OBJECT) {\n\t\tdevice_node = acpi_gbl_root_node;\n\t} else {\n\t\tdevice_node =\n\t\t    ACPI_CAST_PTR(struct acpi_namespace_node, wake_device);\n\t}\n\n\t \n\n\tif (device_node->type != ACPI_TYPE_DEVICE) {\n\t\treturn_ACPI_STATUS (AE_BAD_PARAMETER);\n\t}\n\n\t \n\tnew_notify = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_notify_info));\n\tif (!new_notify) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\n\tif (!gpe_event_info) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\tif (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\n\t    ACPI_GPE_DISPATCH_NONE) {\n\t\t \n\t\tgpe_event_info->flags =\n\t\t    (ACPI_GPE_DISPATCH_NOTIFY | ACPI_GPE_LEVEL_TRIGGERED);\n\t} else if (gpe_event_info->flags & ACPI_GPE_AUTO_ENABLED) {\n\t\t \n\t\t(void)acpi_ev_remove_gpe_reference(gpe_event_info);\n\t\tgpe_event_info->flags &= ~ACPI_GPE_AUTO_ENABLED;\n\t}\n\n\t \n\tif (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\n\t    ACPI_GPE_DISPATCH_NOTIFY) {\n\n\t\t \n\n\t\tnotify = gpe_event_info->dispatch.notify_list;\n\t\twhile (notify) {\n\t\t\tif (notify->device_node == device_node) {\n\t\t\t\tstatus = AE_ALREADY_EXISTS;\n\t\t\t\tgoto unlock_and_exit;\n\t\t\t}\n\t\t\tnotify = notify->next;\n\t\t}\n\n\t\t \n\n\t\tnew_notify->device_node = device_node;\n\t\tnew_notify->next = gpe_event_info->dispatch.notify_list;\n\t\tgpe_event_info->dispatch.notify_list = new_notify;\n\t\tnew_notify = NULL;\n\t}\n\n\t \n\n\tgpe_event_info->flags |= ACPI_GPE_CAN_WAKE;\n\tstatus = AE_OK;\n\nunlock_and_exit:\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\n\t \n\n\tif (new_notify) {\n\t\tACPI_FREE(new_notify);\n\t}\n\treturn_ACPI_STATUS(status);\n}\nACPI_EXPORT_SYMBOL(acpi_setup_gpe_for_wake)\n\n \n\nacpi_status\nacpi_set_gpe_wake_mask(acpi_handle gpe_device, u32 gpe_number, u8 action)\n{\n\tacpi_status status = AE_OK;\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tstruct acpi_gpe_register_info *gpe_register_info;\n\tacpi_cpu_flags flags;\n\tu32 register_bit;\n\n\tACPI_FUNCTION_TRACE(acpi_set_gpe_wake_mask);\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\n\tif (!gpe_event_info) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\tif (!(gpe_event_info->flags & ACPI_GPE_CAN_WAKE)) {\n\t\tstatus = AE_TYPE;\n\t\tgoto unlock_and_exit;\n\t}\n\n\tgpe_register_info = gpe_event_info->register_info;\n\tif (!gpe_register_info) {\n\t\tstatus = AE_NOT_EXIST;\n\t\tgoto unlock_and_exit;\n\t}\n\n\tregister_bit = acpi_hw_get_gpe_register_bit(gpe_event_info);\n\n\t \n\n\tswitch (action) {\n\tcase ACPI_GPE_ENABLE:\n\n\t\tACPI_SET_BIT(gpe_register_info->enable_for_wake,\n\t\t\t     (u8)register_bit);\n\t\tbreak;\n\n\tcase ACPI_GPE_DISABLE:\n\n\t\tACPI_CLEAR_BIT(gpe_register_info->enable_for_wake,\n\t\t\t       (u8)register_bit);\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"%u, Invalid action\", action));\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tbreak;\n\t}\n\nunlock_and_exit:\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_set_gpe_wake_mask)\n\n \nacpi_status acpi_clear_gpe(acpi_handle gpe_device, u32 gpe_number)\n{\n\tacpi_status status = AE_OK;\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(acpi_clear_gpe);\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\n\tif (!gpe_event_info) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\tstatus = acpi_hw_clear_gpe(gpe_event_info);\n\n      unlock_and_exit:\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_clear_gpe)\n\n \nacpi_status\nacpi_get_gpe_status(acpi_handle gpe_device,\n\t\t    u32 gpe_number, acpi_event_status *event_status)\n{\n\tacpi_status status = AE_OK;\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(acpi_get_gpe_status);\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\n\tif (!gpe_event_info) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tstatus = acpi_hw_get_gpe_status(gpe_event_info, event_status);\n\nunlock_and_exit:\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_gpe_status)\n\n \nu32 acpi_dispatch_gpe(acpi_handle gpe_device, u32 gpe_number)\n{\n\tACPI_FUNCTION_TRACE(acpi_dispatch_gpe);\n\n\treturn acpi_ev_detect_gpe(gpe_device, NULL, gpe_number);\n}\n\nACPI_EXPORT_SYMBOL(acpi_dispatch_gpe)\n\n \nacpi_status acpi_finish_gpe(acpi_handle gpe_device, u32 gpe_number)\n{\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tacpi_status status;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(acpi_finish_gpe);\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\n\tif (!gpe_event_info) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\tstatus = acpi_ev_finish_gpe(gpe_event_info);\n\nunlock_and_exit:\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_finish_gpe)\n\n \n\nacpi_status acpi_disable_all_gpes(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_disable_all_gpes);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_hw_disable_all_gpes();\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_disable_all_gpes)\n\n \n\nacpi_status acpi_enable_all_runtime_gpes(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_enable_all_runtime_gpes);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_hw_enable_all_runtime_gpes();\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_enable_all_runtime_gpes)\n\n \nacpi_status acpi_enable_all_wakeup_gpes(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_enable_all_wakeup_gpes);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_hw_enable_all_wakeup_gpes();\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_enable_all_wakeup_gpes)\n\n \nu32 acpi_any_gpe_status_set(u32 gpe_skip_number)\n{\n\tacpi_status status;\n\tacpi_handle gpe_device;\n\tu8 ret;\n\n\tACPI_FUNCTION_TRACE(acpi_any_gpe_status_set);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (FALSE);\n\t}\n\n\tstatus = acpi_get_gpe_device(gpe_skip_number, &gpe_device);\n\tif (ACPI_FAILURE(status)) {\n\t\tgpe_device = NULL;\n\t}\n\n\tret = acpi_hw_check_all_gpes(gpe_device, gpe_skip_number);\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\n\treturn (ret);\n}\n\nACPI_EXPORT_SYMBOL(acpi_any_gpe_status_set)\n\n \nacpi_status\nacpi_install_gpe_block(acpi_handle gpe_device,\n\t\t       struct acpi_generic_address *gpe_block_address,\n\t\t       u32 register_count, u32 interrupt_number)\n{\n\tacpi_status status;\n\tunion acpi_operand_object *obj_desc;\n\tstruct acpi_namespace_node *node;\n\tstruct acpi_gpe_block_info *gpe_block;\n\n\tACPI_FUNCTION_TRACE(acpi_install_gpe_block);\n\n\tif ((!gpe_device) || (!gpe_block_address) || (!register_count)) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tnode = acpi_ns_validate_handle(gpe_device);\n\tif (!node) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tif (node->type != ACPI_TYPE_DEVICE) {\n\t\tstatus = AE_TYPE;\n\t\tgoto unlock_and_exit;\n\t}\n\n\tif (node->object) {\n\t\tstatus = AE_ALREADY_EXISTS;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\tstatus = acpi_ev_create_gpe_block(node, gpe_block_address->address,\n\t\t\t\t\t  gpe_block_address->space_id,\n\t\t\t\t\t  register_count, 0, interrupt_number,\n\t\t\t\t\t  &gpe_block);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (!obj_desc) {\n\n\t\t \n\t\tobj_desc = acpi_ut_create_internal_object(ACPI_TYPE_DEVICE);\n\t\tif (!obj_desc) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\n\t\tstatus =\n\t\t    acpi_ns_attach_object(node, obj_desc, ACPI_TYPE_DEVICE);\n\n\t\t \n\n\t\tacpi_ut_remove_reference(obj_desc);\n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\t}\n\n\t \n\n\tobj_desc->device.gpe_block = gpe_block;\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_install_gpe_block)\n\n \nacpi_status acpi_remove_gpe_block(acpi_handle gpe_device)\n{\n\tunion acpi_operand_object *obj_desc;\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\n\tACPI_FUNCTION_TRACE(acpi_remove_gpe_block);\n\n\tif (!gpe_device) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tnode = acpi_ns_validate_handle(gpe_device);\n\tif (!node) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tif (node->type != ACPI_TYPE_DEVICE) {\n\t\tstatus = AE_TYPE;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (!obj_desc || !obj_desc->device.gpe_block) {\n\t\treturn_ACPI_STATUS(AE_NULL_OBJECT);\n\t}\n\n\t \n\n\tstatus = acpi_ev_delete_gpe_block(obj_desc->device.gpe_block);\n\tif (ACPI_SUCCESS(status)) {\n\t\tobj_desc->device.gpe_block = NULL;\n\t}\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_remove_gpe_block)\n\n \nacpi_status acpi_get_gpe_device(u32 index, acpi_handle *gpe_device)\n{\n\tstruct acpi_gpe_device_info info;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_get_gpe_device);\n\n\tif (!gpe_device) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tif (index >= acpi_current_gpe_count) {\n\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t}\n\n\t \n\n\tinfo.index = index;\n\tinfo.status = AE_NOT_EXIST;\n\tinfo.gpe_device = NULL;\n\tinfo.next_block_base_index = 0;\n\n\tstatus = acpi_ev_walk_gpe_list(acpi_ev_get_gpe_device, &info);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t*gpe_device = ACPI_CAST_PTR(acpi_handle, info.gpe_device);\n\treturn_ACPI_STATUS(info.status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_gpe_device)\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}