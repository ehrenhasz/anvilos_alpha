{
  "module_name": "nswalk.c",
  "hash_id": "1190486477ca751ff151d1d90877605a81f1aca9b0f2681cb4127223c86e6bda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/nswalk.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\nACPI_MODULE_NAME(\"nswalk\")\n\n \nstruct acpi_namespace_node *acpi_ns_get_next_node(struct acpi_namespace_node\n\t\t\t\t\t\t  *parent_node,\n\t\t\t\t\t\t  struct acpi_namespace_node\n\t\t\t\t\t\t  *child_node)\n{\n\tACPI_FUNCTION_ENTRY();\n\n\tif (!child_node) {\n\n\t\t \n\n\t\treturn (parent_node->child);\n\t}\n\n\t \n\n\treturn (child_node->peer);\n}\n\n \n\nstruct acpi_namespace_node *acpi_ns_get_next_node_typed(acpi_object_type type,\n\t\t\t\t\t\t\tstruct\n\t\t\t\t\t\t\tacpi_namespace_node\n\t\t\t\t\t\t\t*parent_node,\n\t\t\t\t\t\t\tstruct\n\t\t\t\t\t\t\tacpi_namespace_node\n\t\t\t\t\t\t\t*child_node)\n{\n\tstruct acpi_namespace_node *next_node = NULL;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tnext_node = acpi_ns_get_next_node(parent_node, child_node);\n\n\n\t \n\n\tif (type == ACPI_TYPE_ANY) {\n\n\t\t \n\n\t\treturn (next_node);\n\t}\n\n\t \n\n\twhile (next_node) {\n\n\t\t \n\n\t\tif (next_node->type == type) {\n\t\t\treturn (next_node);\n\t\t}\n\n\t\t \n\n\t\tnext_node = next_node->peer;\n\t}\n\n\t \n\n\treturn (NULL);\n}\n\n \n\nacpi_status\nacpi_ns_walk_namespace(acpi_object_type type,\n\t\t       acpi_handle start_node,\n\t\t       u32 max_depth,\n\t\t       u32 flags,\n\t\t       acpi_walk_callback descending_callback,\n\t\t       acpi_walk_callback ascending_callback,\n\t\t       void *context, void **return_value)\n{\n\tacpi_status status;\n\tacpi_status mutex_status;\n\tstruct acpi_namespace_node *child_node;\n\tstruct acpi_namespace_node *parent_node;\n\tacpi_object_type child_type;\n\tu32 level;\n\tu8 node_previously_visited = FALSE;\n\n\tACPI_FUNCTION_TRACE(ns_walk_namespace);\n\n\t \n\n\tif (start_node == ACPI_ROOT_OBJECT) {\n\t\tstart_node = acpi_gbl_root_node;\n\t\tif (!start_node) {\n\t\t\treturn_ACPI_STATUS(AE_NO_NAMESPACE);\n\t\t}\n\t}\n\n\t \n\n\tparent_node = start_node;\n\tchild_node = acpi_ns_get_next_node(parent_node, NULL);\n\tchild_type = ACPI_TYPE_ANY;\n\tlevel = 1;\n\n\t \n\twhile (level > 0 && child_node) {\n\t\tstatus = AE_OK;\n\n\t\t \n\n\t\tif (type != ACPI_TYPE_ANY) {\n\t\t\tchild_type = child_node->type;\n\t\t}\n\n\t\t \n\t\tif ((child_node->flags & ANOBJ_TEMPORARY) &&\n\t\t    !(flags & ACPI_NS_WALK_TEMP_NODES)) {\n\t\t\tstatus = AE_CTRL_DEPTH;\n\t\t}\n\n\t\t \n\n\t\telse if (child_type == type) {\n\t\t\t \n\t\t\tif (flags & ACPI_NS_WALK_UNLOCK) {\n\t\t\t\tmutex_status =\n\t\t\t\t    acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\t\t\t\tif (ACPI_FAILURE(mutex_status)) {\n\t\t\t\t\treturn_ACPI_STATUS(mutex_status);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!node_previously_visited) {\n\t\t\t\tif (descending_callback) {\n\t\t\t\t\tstatus =\n\t\t\t\t\t    descending_callback(child_node,\n\t\t\t\t\t\t\t\tlevel, context,\n\t\t\t\t\t\t\t\treturn_value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ascending_callback) {\n\t\t\t\t\tstatus =\n\t\t\t\t\t    ascending_callback(child_node,\n\t\t\t\t\t\t\t       level, context,\n\t\t\t\t\t\t\t       return_value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (flags & ACPI_NS_WALK_UNLOCK) {\n\t\t\t\tmutex_status =\n\t\t\t\t    acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\t\t\t\tif (ACPI_FAILURE(mutex_status)) {\n\t\t\t\t\treturn_ACPI_STATUS(mutex_status);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (status) {\n\t\t\tcase AE_OK:\n\t\t\tcase AE_CTRL_DEPTH:\n\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\tcase AE_CTRL_TERMINATE:\n\n\t\t\t\t \n\n\t\t\t\treturn_ACPI_STATUS(AE_OK);\n\n\t\t\tdefault:\n\n\t\t\t\t \n\n\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!node_previously_visited &&\n\t\t    (level < max_depth) && (status != AE_CTRL_DEPTH)) {\n\t\t\tif (child_node->child) {\n\n\t\t\t\t \n\n\t\t\t\tlevel++;\n\t\t\t\tparent_node = child_node;\n\t\t\t\tchild_node =\n\t\t\t\t    acpi_ns_get_next_node(parent_node, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (!node_previously_visited) {\n\t\t\tnode_previously_visited = TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tchild_node = acpi_ns_get_next_node(parent_node, child_node);\n\t\tif (child_node) {\n\t\t\tnode_previously_visited = FALSE;\n\t\t}\n\n\t\t \n\n\t\telse {\n\t\t\t \n\t\t\tlevel--;\n\t\t\tchild_node = parent_node;\n\t\t\tparent_node = parent_node->parent;\n\n\t\t\tnode_previously_visited = TRUE;\n\t\t}\n\t}\n\n\t \n\n\treturn_ACPI_STATUS(AE_OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}