{
  "module_name": "dbexec.c",
  "hash_id": "63ee8522984376a01393c2194b0a350395cde6b2cecca2abe49e1e88240e86d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/dbexec.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acdebug.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_CA_DEBUGGER\nACPI_MODULE_NAME(\"dbexec\")\n\nstatic struct acpi_db_method_info acpi_gbl_db_method_info;\n\n \n\nstatic acpi_status\nacpi_db_execute_method(struct acpi_db_method_info *info,\n\t\t       struct acpi_buffer *return_obj);\n\nstatic acpi_status acpi_db_execute_setup(struct acpi_db_method_info *info);\n\nstatic u32 acpi_db_get_outstanding_allocations(void);\n\nstatic void ACPI_SYSTEM_XFACE acpi_db_method_thread(void *context);\n\nstatic acpi_status\nacpi_db_execution_walk(acpi_handle obj_handle,\n\t\t       u32 nesting_level, void *context, void **return_value);\n\nstatic void ACPI_SYSTEM_XFACE acpi_db_single_execution_thread(void *context);\n\n \n\nvoid acpi_db_delete_objects(u32 count, union acpi_object *objects)\n{\n\tu32 i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tswitch (objects[i].type) {\n\t\tcase ACPI_TYPE_BUFFER:\n\n\t\t\tACPI_FREE(objects[i].buffer.pointer);\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_PACKAGE:\n\n\t\t\t \n\n\t\t\tacpi_db_delete_objects(objects[i].package.count,\n\t\t\t\t\t       objects[i].package.elements);\n\n\t\t\t \n\n\t\t\tACPI_FREE(objects[i].package.elements);\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \n\nstatic acpi_status\nacpi_db_execute_method(struct acpi_db_method_info *info,\n\t\t       struct acpi_buffer *return_obj)\n{\n\tacpi_status status;\n\tstruct acpi_object_list param_objects;\n\tunion acpi_object params[ACPI_DEBUGGER_MAX_ARGS + 1];\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(db_execute_method);\n\n\tif (acpi_gbl_db_output_to_file && !acpi_dbg_level) {\n\t\tacpi_os_printf(\"Warning: debug output is not enabled!\\n\");\n\t}\n\n\tparam_objects.count = 0;\n\tparam_objects.pointer = NULL;\n\n\t \n\n\tif (info->args && info->args[0]) {\n\n\t\t \n\n\t\tfor (i = 0; (info->args[i] && *(info->args[i])); i++) {\n\n\t\t\t \n\n\t\t\tstatus = acpi_db_convert_to_object(info->types[i],\n\t\t\t\t\t\t\t   info->args[i],\n\t\t\t\t\t\t\t   &params[i]);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\t\"While parsing method arguments\"));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tparam_objects.count = i;\n\t\tparam_objects.pointer = params;\n\t}\n\n\t \n\n\treturn_obj->pointer = acpi_gbl_db_buffer;\n\treturn_obj->length = ACPI_DEBUG_BUFFER_SIZE;\n\n\t \n\n\tacpi_gbl_method_executing = TRUE;\n\tstatus = acpi_evaluate_object(NULL, info->pathname,\n\t\t\t\t      &param_objects, return_obj);\n\n\tacpi_gbl_cm_single_step = FALSE;\n\tacpi_gbl_method_executing = FALSE;\n\n\tif (ACPI_FAILURE(status)) {\n\t\tif ((status == AE_ABORT_METHOD) || acpi_gbl_abort_method) {\n\n\t\t\t \n\n\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\"Aborting top-level method\"));\n\n\t\t\tacpi_gbl_abort_method = FALSE;\n\t\t\tstatus = AE_OK;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"while executing %s from AML Debugger\",\n\t\t\t\tinfo->pathname));\n\n\t\tif (status == AE_BUFFER_OVERFLOW) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Possible buffer overflow within AML Debugger \"\n\t\t\t\t    \"buffer (size 0x%X needed 0x%X)\",\n\t\t\t\t    ACPI_DEBUG_BUFFER_SIZE,\n\t\t\t\t    (u32)return_obj->length));\n\t\t}\n\t}\n\ncleanup:\n\tacpi_db_delete_objects(param_objects.count, params);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic acpi_status acpi_db_execute_setup(struct acpi_db_method_info *info)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_NAME(db_execute_setup);\n\n\t \n\n\tinfo->pathname[0] = 0;\n\tif ((info->name[0] != '\\\\') && (info->name[0] != '/')) {\n\t\tif (acpi_ut_safe_strcat(info->pathname, sizeof(info->pathname),\n\t\t\t\t\tacpi_gbl_db_scope_buf)) {\n\t\t\tstatus = AE_BUFFER_OVERFLOW;\n\t\t\tgoto error_exit;\n\t\t}\n\t}\n\n\tif (acpi_ut_safe_strcat(info->pathname, sizeof(info->pathname),\n\t\t\t\tinfo->name)) {\n\t\tstatus = AE_BUFFER_OVERFLOW;\n\t\tgoto error_exit;\n\t}\n\n\tacpi_db_prep_namestring(info->pathname);\n\n\tacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\n\tacpi_os_printf(\"Evaluating %s\\n\", info->pathname);\n\n\tif (info->flags & EX_SINGLE_STEP) {\n\t\tacpi_gbl_cm_single_step = TRUE;\n\t\tacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\n\t}\n\n\telse {\n\t\t \n\n\t\tacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\n\t}\n\n\treturn (AE_OK);\n\nerror_exit:\n\n\tACPI_EXCEPTION((AE_INFO, status, \"During setup for method execution\"));\n\treturn (status);\n}\n\n#ifdef ACPI_DBG_TRACK_ALLOCATIONS\nu32 acpi_db_get_cache_info(struct acpi_memory_list *cache)\n{\n\n\treturn (cache->total_allocated - cache->total_freed -\n\t\tcache->current_depth);\n}\n#endif\n\n \n\nstatic u32 acpi_db_get_outstanding_allocations(void)\n{\n\tu32 outstanding = 0;\n\n#ifdef ACPI_DBG_TRACK_ALLOCATIONS\n\n\toutstanding += acpi_db_get_cache_info(acpi_gbl_state_cache);\n\toutstanding += acpi_db_get_cache_info(acpi_gbl_ps_node_cache);\n\toutstanding += acpi_db_get_cache_info(acpi_gbl_ps_node_ext_cache);\n\toutstanding += acpi_db_get_cache_info(acpi_gbl_operand_cache);\n#endif\n\n\treturn (outstanding);\n}\n\n \n\nstatic acpi_status\nacpi_db_execution_walk(acpi_handle obj_handle,\n\t\t       u32 nesting_level, void *context, void **return_value)\n{\n\tunion acpi_operand_object *obj_desc;\n\tstruct acpi_namespace_node *node =\n\t    (struct acpi_namespace_node *)obj_handle;\n\tstruct acpi_buffer return_obj;\n\tacpi_status status;\n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (obj_desc->method.param_count) {\n\t\treturn (AE_OK);\n\t}\n\n\treturn_obj.pointer = NULL;\n\treturn_obj.length = ACPI_ALLOCATE_BUFFER;\n\n\tacpi_ns_print_node_pathname(node, \"Evaluating\");\n\n\t \n\n\tacpi_os_printf(\"\\n\");\n\tacpi_gbl_method_executing = TRUE;\n\n\tstatus = acpi_evaluate_object(node, NULL, NULL, &return_obj);\n\n\tacpi_gbl_method_executing = FALSE;\n\n\tacpi_os_printf(\"Evaluation of [%4.4s] returned %s\\n\",\n\t\t       acpi_ut_get_node_name(node),\n\t\t       acpi_format_exception(status));\n\n\treturn (AE_OK);\n}\n\n \n\nvoid\nacpi_db_execute(char *name, char **args, acpi_object_type *types, u32 flags)\n{\n\tacpi_status status;\n\tstruct acpi_buffer return_obj;\n\tchar *name_string;\n\n#ifdef ACPI_DEBUG_OUTPUT\n\tu32 previous_allocations;\n\tu32 allocations;\n#endif\n\n\t \n\tif (acpi_gbl_method_executing) {\n\t\tacpi_os_printf(\"Only one debugger execution is allowed.\\n\");\n\t\treturn;\n\t}\n#ifdef ACPI_DEBUG_OUTPUT\n\t \n\n\tprevious_allocations = acpi_db_get_outstanding_allocations();\n#endif\n\n\tif (*name == '*') {\n\t\t(void)acpi_walk_namespace(ACPI_TYPE_METHOD, ACPI_ROOT_OBJECT,\n\t\t\t\t\t  ACPI_UINT32_MAX,\n\t\t\t\t\t  acpi_db_execution_walk, NULL, NULL,\n\t\t\t\t\t  NULL);\n\t\treturn;\n\t}\n\n\tif ((flags & EX_ALL) && (strlen(name) > 4)) {\n\t\tacpi_os_printf(\"Input name (%s) must be a 4-char NameSeg\\n\",\n\t\t\t       name);\n\t\treturn;\n\t}\n\n\tname_string = ACPI_ALLOCATE(strlen(name) + 1);\n\tif (!name_string) {\n\t\treturn;\n\t}\n\n\tmemset(&acpi_gbl_db_method_info, 0, sizeof(struct acpi_db_method_info));\n\tstrcpy(name_string, name);\n\tacpi_ut_strupr(name_string);\n\n\t \n\n\tif (!strncmp(name_string, \"PREDEF\", 6)) {\n\t\tacpi_db_evaluate_predefined_names();\n\t\tACPI_FREE(name_string);\n\t\treturn;\n\t}\n\n\t \n\n\telse if (flags & EX_ALL) {\n\t\tacpi_gbl_db_method_info.name = name_string;\n\t\treturn_obj.pointer = NULL;\n\t\treturn_obj.length = ACPI_ALLOCATE_BUFFER;\n\t\tacpi_db_evaluate_all(name_string);\n\t\tACPI_FREE(name_string);\n\t\treturn;\n\t} else {\n\t\tacpi_gbl_db_method_info.name = name_string;\n\t\tacpi_gbl_db_method_info.args = args;\n\t\tacpi_gbl_db_method_info.types = types;\n\t\tacpi_gbl_db_method_info.flags = flags;\n\n\t\treturn_obj.pointer = NULL;\n\t\treturn_obj.length = ACPI_ALLOCATE_BUFFER;\n\t}\n\n\tstatus = acpi_db_execute_setup(&acpi_gbl_db_method_info);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_FREE(name_string);\n\t\treturn;\n\t}\n\n\t \n\n\tstatus = acpi_get_handle(NULL, acpi_gbl_db_method_info.pathname,\n\t\t\t\t &acpi_gbl_db_method_info.method);\n\tif (ACPI_SUCCESS(status)) {\n\t\tstatus = acpi_db_execute_method(&acpi_gbl_db_method_info,\n\t\t\t\t\t\t&return_obj);\n\t}\n\tACPI_FREE(name_string);\n\n\t \n\tacpi_os_sleep((u64)10);\n\n#ifdef ACPI_DEBUG_OUTPUT\n\n\t \n\n\tallocations =\n\t    acpi_db_get_outstanding_allocations() - previous_allocations;\n\n\tacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\n\n\tif (allocations > 0) {\n\t\tacpi_os_printf\n\t\t    (\"0x%X Outstanding allocations after evaluation of %s\\n\",\n\t\t     allocations, acpi_gbl_db_method_info.pathname);\n\t}\n#endif\n\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Evaluation of %s failed with status %s\\n\",\n\t\t\t       acpi_gbl_db_method_info.pathname,\n\t\t\t       acpi_format_exception(status));\n\t} else {\n\t\t \n\n\t\tif (return_obj.length) {\n\t\t\tacpi_os_printf(\"Evaluation of %s returned object %p, \"\n\t\t\t\t       \"external buffer length %X\\n\",\n\t\t\t\t       acpi_gbl_db_method_info.pathname,\n\t\t\t\t       return_obj.pointer,\n\t\t\t\t       (u32)return_obj.length);\n\n\t\t\tacpi_db_dump_external_object(return_obj.pointer, 1);\n\t\t\tacpi_os_printf(\"\\n\");\n\n\t\t\t \n\n\t\t\tif (ACPI_COMPARE_NAMESEG\n\t\t\t    ((ACPI_CAST_PTR\n\t\t\t      (struct acpi_namespace_node,\n\t\t\t       acpi_gbl_db_method_info.method)->name.ascii),\n\t\t\t     METHOD_NAME__PLD)) {\n\t\t\t\tacpi_db_dump_pld_buffer(return_obj.pointer);\n\t\t\t}\n\t\t} else {\n\t\t\tacpi_os_printf\n\t\t\t    (\"No object was returned from evaluation of %s\\n\",\n\t\t\t     acpi_gbl_db_method_info.pathname);\n\t\t}\n\t}\n\n\tacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\n}\n\n \n\nstatic void ACPI_SYSTEM_XFACE acpi_db_method_thread(void *context)\n{\n\tacpi_status status;\n\tstruct acpi_db_method_info *info = context;\n\tstruct acpi_db_method_info local_info;\n\tu32 i;\n\tu8 allow;\n\tstruct acpi_buffer return_obj;\n\n\t \n\t(void)acpi_os_wait_semaphore(info->info_gate, 1, ACPI_WAIT_FOREVER);\n\n\tif (info->init_args) {\n\t\tacpi_db_uint32_to_hex_string(info->num_created,\n\t\t\t\t\t     info->index_of_thread_str);\n\t\tacpi_db_uint32_to_hex_string((u32)acpi_os_get_thread_id(),\n\t\t\t\t\t     info->id_of_thread_str);\n\t}\n\n\tif (info->threads && (info->num_created < info->num_threads)) {\n\t\tinfo->threads[info->num_created++] = acpi_os_get_thread_id();\n\t}\n\n\tlocal_info = *info;\n\tlocal_info.args = local_info.arguments;\n\tlocal_info.arguments[0] = local_info.num_threads_str;\n\tlocal_info.arguments[1] = local_info.id_of_thread_str;\n\tlocal_info.arguments[2] = local_info.index_of_thread_str;\n\tlocal_info.arguments[3] = NULL;\n\n\tlocal_info.types = local_info.arg_types;\n\n\t(void)acpi_os_signal_semaphore(info->info_gate, 1);\n\n\tfor (i = 0; i < info->num_loops; i++) {\n\t\tstatus = acpi_db_execute_method(&local_info, &return_obj);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"%s During evaluation of %s at iteration %X\\n\",\n\t\t\t     acpi_format_exception(status), info->pathname, i);\n\t\t\tif (status == AE_ABORT_METHOD) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#if 0\n\t\tif ((i % 100) == 0) {\n\t\t\tacpi_os_printf(\"%u loops, Thread 0x%x\\n\",\n\t\t\t\t       i, acpi_os_get_thread_id());\n\t\t}\n\n\t\tif (return_obj.length) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Evaluation of %s returned object %p Buflen %X\\n\",\n\t\t\t     info->pathname, return_obj.pointer,\n\t\t\t     (u32)return_obj.length);\n\t\t\tacpi_db_dump_external_object(return_obj.pointer, 1);\n\t\t}\n#endif\n\t}\n\n\t \n\n\tallow = 0;\n\t(void)acpi_os_wait_semaphore(info->thread_complete_gate,\n\t\t\t\t     1, ACPI_WAIT_FOREVER);\n\tinfo->num_completed++;\n\n\tif (info->num_completed == info->num_threads) {\n\n\t\t \n\t\tallow = 1;\n\t}\n\n\t(void)acpi_os_signal_semaphore(info->thread_complete_gate, 1);\n\n\tif (allow) {\n\t\tstatus = acpi_os_signal_semaphore(info->main_thread_gate, 1);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Could not signal debugger thread sync semaphore, %s\\n\",\n\t\t\t     acpi_format_exception(status));\n\t\t}\n\t}\n}\n\n \n\nstatic void ACPI_SYSTEM_XFACE acpi_db_single_execution_thread(void *context)\n{\n\tstruct acpi_db_method_info *info = context;\n\tacpi_status status;\n\tstruct acpi_buffer return_obj;\n\n\tacpi_os_printf(\"\\n\");\n\n\tstatus = acpi_db_execute_method(info, &return_obj);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"%s During evaluation of %s\\n\",\n\t\t\t       acpi_format_exception(status), info->pathname);\n\t\treturn;\n\t}\n\n\t \n\n\tif (return_obj.length) {\n\t\tacpi_os_printf(\"Evaluation of %s returned object %p, \"\n\t\t\t       \"external buffer length %X\\n\",\n\t\t\t       acpi_gbl_db_method_info.pathname,\n\t\t\t       return_obj.pointer, (u32)return_obj.length);\n\n\t\tacpi_db_dump_external_object(return_obj.pointer, 1);\n\t}\n\n\tacpi_os_printf(\"\\nBackground thread completed\\n%c \",\n\t\t       ACPI_DEBUGGER_COMMAND_PROMPT);\n}\n\n \n\nvoid\nacpi_db_create_execution_thread(char *method_name_arg,\n\t\t\t\tchar **arguments, acpi_object_type *types)\n{\n\tacpi_status status;\n\tu32 i;\n\n\tmemset(&acpi_gbl_db_method_info, 0, sizeof(struct acpi_db_method_info));\n\tacpi_gbl_db_method_info.name = method_name_arg;\n\tacpi_gbl_db_method_info.init_args = 1;\n\tacpi_gbl_db_method_info.args = acpi_gbl_db_method_info.arguments;\n\tacpi_gbl_db_method_info.types = acpi_gbl_db_method_info.arg_types;\n\n\t \n\n\tfor (i = 0; (i < ACPI_METHOD_NUM_ARGS) && *arguments; i++) {\n\t\tacpi_gbl_db_method_info.arguments[i] = *arguments;\n\t\targuments++;\n\n\t\tacpi_gbl_db_method_info.arg_types[i] = *types;\n\t\ttypes++;\n\t}\n\n\tstatus = acpi_db_execute_setup(&acpi_gbl_db_method_info);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn;\n\t}\n\n\t \n\n\tstatus = acpi_get_handle(NULL, acpi_gbl_db_method_info.pathname,\n\t\t\t\t &acpi_gbl_db_method_info.method);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"%s Could not get handle for %s\\n\",\n\t\t\t       acpi_format_exception(status),\n\t\t\t       acpi_gbl_db_method_info.pathname);\n\t\treturn;\n\t}\n\n\tstatus = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,\n\t\t\t\t acpi_db_single_execution_thread,\n\t\t\t\t &acpi_gbl_db_method_info);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn;\n\t}\n\n\tacpi_os_printf(\"\\nBackground thread started\\n\");\n}\n\n \n\nvoid\nacpi_db_create_execution_threads(char *num_threads_arg,\n\t\t\t\t char *num_loops_arg, char *method_name_arg)\n{\n\tacpi_status status;\n\tu32 num_threads;\n\tu32 num_loops;\n\tu32 i;\n\tu32 size;\n\tacpi_mutex main_thread_gate;\n\tacpi_mutex thread_complete_gate;\n\tacpi_mutex info_gate;\n\n\t \n\n\tnum_threads = strtoul(num_threads_arg, NULL, 0);\n\tnum_loops = strtoul(num_loops_arg, NULL, 0);\n\n\tif (!num_threads || !num_loops) {\n\t\tacpi_os_printf(\"Bad argument: Threads %X, Loops %X\\n\",\n\t\t\t       num_threads, num_loops);\n\t\treturn;\n\t}\n\n\t \n\tstatus = acpi_os_create_semaphore(1, 0, &main_thread_gate);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could not create semaphore for \"\n\t\t\t       \"synchronization with the main thread, %s\\n\",\n\t\t\t       acpi_format_exception(status));\n\t\treturn;\n\t}\n\n\t \n\tstatus = acpi_os_create_semaphore(1, 1, &thread_complete_gate);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could not create semaphore for \"\n\t\t\t       \"synchronization between the created threads, %s\\n\",\n\t\t\t       acpi_format_exception(status));\n\n\t\t(void)acpi_os_delete_semaphore(main_thread_gate);\n\t\treturn;\n\t}\n\n\tstatus = acpi_os_create_semaphore(1, 1, &info_gate);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could not create semaphore for \"\n\t\t\t       \"synchronization of AcpiGbl_DbMethodInfo, %s\\n\",\n\t\t\t       acpi_format_exception(status));\n\n\t\t(void)acpi_os_delete_semaphore(thread_complete_gate);\n\t\t(void)acpi_os_delete_semaphore(main_thread_gate);\n\t\treturn;\n\t}\n\n\tmemset(&acpi_gbl_db_method_info, 0, sizeof(struct acpi_db_method_info));\n\n\t \n\n\tacpi_gbl_db_method_info.num_threads = num_threads;\n\tsize = sizeof(acpi_thread_id) * acpi_gbl_db_method_info.num_threads;\n\n\tacpi_gbl_db_method_info.threads = acpi_os_allocate(size);\n\tif (acpi_gbl_db_method_info.threads == NULL) {\n\t\tacpi_os_printf(\"No memory for thread IDs array\\n\");\n\t\t(void)acpi_os_delete_semaphore(main_thread_gate);\n\t\t(void)acpi_os_delete_semaphore(thread_complete_gate);\n\t\t(void)acpi_os_delete_semaphore(info_gate);\n\t\treturn;\n\t}\n\tmemset(acpi_gbl_db_method_info.threads, 0, size);\n\n\t \n\n\tacpi_gbl_db_method_info.name = method_name_arg;\n\tacpi_gbl_db_method_info.flags = 0;\n\tacpi_gbl_db_method_info.num_loops = num_loops;\n\tacpi_gbl_db_method_info.main_thread_gate = main_thread_gate;\n\tacpi_gbl_db_method_info.thread_complete_gate = thread_complete_gate;\n\tacpi_gbl_db_method_info.info_gate = info_gate;\n\n\t \n\n\tacpi_gbl_db_method_info.init_args = 1;\n\tacpi_gbl_db_method_info.args = acpi_gbl_db_method_info.arguments;\n\tacpi_gbl_db_method_info.arguments[0] =\n\t    acpi_gbl_db_method_info.num_threads_str;\n\tacpi_gbl_db_method_info.arguments[1] =\n\t    acpi_gbl_db_method_info.id_of_thread_str;\n\tacpi_gbl_db_method_info.arguments[2] =\n\t    acpi_gbl_db_method_info.index_of_thread_str;\n\tacpi_gbl_db_method_info.arguments[3] = NULL;\n\n\tacpi_gbl_db_method_info.types = acpi_gbl_db_method_info.arg_types;\n\tacpi_gbl_db_method_info.arg_types[0] = ACPI_TYPE_INTEGER;\n\tacpi_gbl_db_method_info.arg_types[1] = ACPI_TYPE_INTEGER;\n\tacpi_gbl_db_method_info.arg_types[2] = ACPI_TYPE_INTEGER;\n\n\tacpi_db_uint32_to_hex_string(num_threads,\n\t\t\t\t     acpi_gbl_db_method_info.num_threads_str);\n\n\tstatus = acpi_db_execute_setup(&acpi_gbl_db_method_info);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto cleanup_and_exit;\n\t}\n\n\t \n\n\tstatus = acpi_get_handle(NULL, acpi_gbl_db_method_info.pathname,\n\t\t\t\t &acpi_gbl_db_method_info.method);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"%s Could not get handle for %s\\n\",\n\t\t\t       acpi_format_exception(status),\n\t\t\t       acpi_gbl_db_method_info.pathname);\n\t\tgoto cleanup_and_exit;\n\t}\n\n\t \n\n\tacpi_os_printf(\"Creating %X threads to execute %X times each\\n\",\n\t\t       num_threads, num_loops);\n\n\tfor (i = 0; i < (num_threads); i++) {\n\t\tstatus =\n\t\t    acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,\n\t\t\t\t    acpi_db_method_thread,\n\t\t\t\t    &acpi_gbl_db_method_info);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\n\t(void)acpi_os_wait_semaphore(main_thread_gate, 1, ACPI_WAIT_FOREVER);\n\n\tacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\n\tacpi_os_printf(\"All threads (%X) have completed\\n\", num_threads);\n\tacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\n\ncleanup_and_exit:\n\n\t \n\n\t(void)acpi_os_delete_semaphore(main_thread_gate);\n\t(void)acpi_os_delete_semaphore(thread_complete_gate);\n\t(void)acpi_os_delete_semaphore(info_gate);\n\n\tacpi_os_free(acpi_gbl_db_method_info.threads);\n\tacpi_gbl_db_method_info.threads = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}