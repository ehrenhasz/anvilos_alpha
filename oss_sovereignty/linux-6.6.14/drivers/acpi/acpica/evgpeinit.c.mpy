{
  "module_name": "evgpeinit.c",
  "hash_id": "ec466ff02c53b55d18fc8818f43a47eb44855a4983741679953638d9680eb617",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evgpeinit.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evgpeinit\")\n#if (!ACPI_REDUCED_HARDWARE)\t \n \n\n#ifdef ACPI_GPE_USE_LOGICAL_ADDRESSES\n#define ACPI_FADT_GPE_BLOCK_ADDRESS(N)\t\\\n\tacpi_gbl_FADT.xgpe##N##_block.space_id == \\\n\t\t\t\t\tACPI_ADR_SPACE_SYSTEM_MEMORY ? \\\n\t\t(u64)acpi_gbl_xgpe##N##_block_logical_address : \\\n\t\tacpi_gbl_FADT.xgpe##N##_block.address\n#else\n#define ACPI_FADT_GPE_BLOCK_ADDRESS(N)\tacpi_gbl_FADT.xgpe##N##_block.address\n#endif\t\t \n\n \nacpi_status acpi_ev_gpe_initialize(void)\n{\n\tu32 register_count0 = 0;\n\tu32 register_count1 = 0;\n\tu32 gpe_number_max = 0;\n\tacpi_status status;\n\tu64 address;\n\n\tACPI_FUNCTION_TRACE(ev_gpe_initialize);\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,\n\t\t\t      \"Initializing General Purpose Events (GPEs):\\n\"));\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\t \n\taddress = ACPI_FADT_GPE_BLOCK_ADDRESS(0);\n\n\tif (acpi_gbl_FADT.gpe0_block_length && address) {\n\n\t\t \n\n\t\tregister_count0 = (u16)(acpi_gbl_FADT.gpe0_block_length / 2);\n\t\tgpe_number_max =\n\t\t    (register_count0 * ACPI_GPE_REGISTER_WIDTH) - 1;\n\n\t\t \n\n\t\tstatus = acpi_ev_create_gpe_block(acpi_gbl_fadt_gpe_device,\n\t\t\t\t\t\t  address,\n\t\t\t\t\t\t  acpi_gbl_FADT.xgpe0_block.\n\t\t\t\t\t\t  space_id, register_count0, 0,\n\t\t\t\t\t\t  acpi_gbl_FADT.sci_interrupt,\n\t\t\t\t\t\t  &acpi_gbl_gpe_fadt_blocks[0]);\n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\"Could not create GPE Block 0\"));\n\t\t}\n\t}\n\n\taddress = ACPI_FADT_GPE_BLOCK_ADDRESS(1);\n\n\tif (acpi_gbl_FADT.gpe1_block_length && address) {\n\n\t\t \n\n\t\tregister_count1 = (u16)(acpi_gbl_FADT.gpe1_block_length / 2);\n\n\t\t \n\n\t\tif ((register_count0) &&\n\t\t    (gpe_number_max >= acpi_gbl_FADT.gpe1_base)) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"GPE0 block (GPE 0 to %u) overlaps the GPE1 block \"\n\t\t\t\t    \"(GPE %u to %u) - Ignoring GPE1\",\n\t\t\t\t    gpe_number_max, acpi_gbl_FADT.gpe1_base,\n\t\t\t\t    acpi_gbl_FADT.gpe1_base +\n\t\t\t\t    ((register_count1 *\n\t\t\t\t      ACPI_GPE_REGISTER_WIDTH) - 1)));\n\n\t\t\t \n\n\t\t\tregister_count1 = 0;\n\t\t} else {\n\t\t\t \n\n\t\t\tstatus =\n\t\t\t    acpi_ev_create_gpe_block(acpi_gbl_fadt_gpe_device,\n\t\t\t\t\t\t     address,\n\t\t\t\t\t\t     acpi_gbl_FADT.xgpe1_block.\n\t\t\t\t\t\t     space_id, register_count1,\n\t\t\t\t\t\t     acpi_gbl_FADT.gpe1_base,\n\t\t\t\t\t\t     acpi_gbl_FADT.\n\t\t\t\t\t\t     sci_interrupt,\n\t\t\t\t\t\t     &acpi_gbl_gpe_fadt_blocks\n\t\t\t\t\t\t     [1]);\n\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\t\"Could not create GPE Block 1\"));\n\t\t\t}\n\n\t\t\t \n\t\t}\n\t}\n\n\t \n\n\tif ((register_count0 + register_count1) == 0) {\n\n\t\t \n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_INIT,\n\t\t\t\t  \"There are no GPE blocks defined in the FADT\\n\"));\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nvoid acpi_ev_update_gpes(acpi_owner_id table_owner_id)\n{\n\tstruct acpi_gpe_xrupt_info *gpe_xrupt_info;\n\tstruct acpi_gpe_block_info *gpe_block;\n\tstruct acpi_gpe_walk_info walk_info;\n\tacpi_status status = AE_OK;\n\n\t \n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn;\n\t}\n\n\twalk_info.count = 0;\n\twalk_info.owner_id = table_owner_id;\n\twalk_info.execute_by_owner_id = TRUE;\n\n\t \n\n\tgpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;\n\twhile (gpe_xrupt_info) {\n\n\t\t \n\n\t\tgpe_block = gpe_xrupt_info->gpe_block_list_head;\n\t\twhile (gpe_block) {\n\t\t\twalk_info.gpe_block = gpe_block;\n\t\t\twalk_info.gpe_device = gpe_block->node;\n\n\t\t\tstatus = acpi_ns_walk_namespace(ACPI_TYPE_METHOD,\n\t\t\t\t\t\t\twalk_info.gpe_device,\n\t\t\t\t\t\t\tACPI_UINT32_MAX,\n\t\t\t\t\t\t\tACPI_NS_WALK_NO_UNLOCK,\n\t\t\t\t\t\t\tacpi_ev_match_gpe_method,\n\t\t\t\t\t\t\tNULL, &walk_info, NULL);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\t\"While decoding _Lxx/_Exx methods\"));\n\t\t\t}\n\n\t\t\tgpe_block = gpe_block->next;\n\t\t}\n\n\t\tgpe_xrupt_info = gpe_xrupt_info->next;\n\t}\n\n\tif (walk_info.count) {\n\t\tACPI_INFO((\"Enabled %u new GPEs\", walk_info.count));\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn;\n}\n\n \n\nacpi_status\nacpi_ev_match_gpe_method(acpi_handle obj_handle,\n\t\t\t u32 level, void *context, void **return_value)\n{\n\tstruct acpi_namespace_node *method_node =\n\t    ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);\n\tstruct acpi_gpe_walk_info *walk_info =\n\t    ACPI_CAST_PTR(struct acpi_gpe_walk_info, context);\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tacpi_status status;\n\tu32 gpe_number;\n\tu8 temp_gpe_number;\n\tchar name[ACPI_NAMESEG_SIZE + 1];\n\tu8 type;\n\n\tACPI_FUNCTION_TRACE(ev_match_gpe_method);\n\n\t \n\n\tif ((walk_info->execute_by_owner_id) &&\n\t    (method_node->owner_id != walk_info->owner_id)) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\tACPI_MOVE_32_TO_32(name, &method_node->name.integer);\n\tname[ACPI_NAMESEG_SIZE] = 0;\n\n\t \n\n\tif (name[0] != '_') {\n\t\treturn_ACPI_STATUS(AE_OK);\t \n\t}\n\n\t \n\tswitch (name[1]) {\n\tcase 'L':\n\n\t\ttype = ACPI_GPE_LEVEL_TRIGGERED;\n\t\tbreak;\n\n\tcase 'E':\n\n\t\ttype = ACPI_GPE_EDGE_TRIGGERED;\n\t\tbreak;\n\n\tdefault:\n\n\t\t \n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_LOAD,\n\t\t\t\t  \"Ignoring unknown GPE method type: %s \"\n\t\t\t\t  \"(name not of form _Lxx or _Exx)\", name));\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tstatus = acpi_ut_ascii_to_hex_byte(&name[2], &temp_gpe_number);\n\tif (ACPI_FAILURE(status)) {\n\n\t\t \n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_LOAD,\n\t\t\t\t  \"Could not extract GPE number from name: %s \"\n\t\t\t\t  \"(name is not of form _Lxx or _Exx)\", name));\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tgpe_number = (u32)temp_gpe_number;\n\tgpe_event_info =\n\t    acpi_ev_low_get_gpe_info(gpe_number, walk_info->gpe_block);\n\tif (!gpe_event_info) {\n\t\t \n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\tif ((ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\n\t     ACPI_GPE_DISPATCH_HANDLER) ||\n\t    (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\n\t     ACPI_GPE_DISPATCH_RAW_HANDLER)) {\n\n\t\t \n\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\tif (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\n\t    ACPI_GPE_DISPATCH_METHOD) {\n\t\t \n\t\tif (type != (gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK)) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"For GPE 0x%.2X, found both _L%2.2X and _E%2.2X methods\",\n\t\t\t\t    gpe_number, gpe_number, gpe_number));\n\t\t}\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\t(void)acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_DISABLE);\n\n\t \n\tgpe_event_info->flags &= ~(ACPI_GPE_DISPATCH_MASK);\n\tgpe_event_info->flags |= (u8)(type | ACPI_GPE_DISPATCH_METHOD);\n\tgpe_event_info->dispatch.method_node = method_node;\n\n\tACPI_DEBUG_PRINT((ACPI_DB_LOAD,\n\t\t\t  \"Registered GPE method %s as GPE number 0x%.2X\\n\",\n\t\t\t  name, gpe_number));\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}