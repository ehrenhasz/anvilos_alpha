{
  "module_name": "utresrc.c",
  "hash_id": "fdeff16a84b0df9decc7234376af3c516b29f712588e6efe52508504a72e1377",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utresrc.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acresrc.h\"\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utresrc\")\n\n \nconst u8 acpi_gbl_resource_aml_sizes[] = {\n\t \n\n\t0,\n\t0,\n\t0,\n\t0,\n\tACPI_AML_SIZE_SMALL(struct aml_resource_irq),\n\tACPI_AML_SIZE_SMALL(struct aml_resource_dma),\n\tACPI_AML_SIZE_SMALL(struct aml_resource_start_dependent),\n\tACPI_AML_SIZE_SMALL(struct aml_resource_end_dependent),\n\tACPI_AML_SIZE_SMALL(struct aml_resource_io),\n\tACPI_AML_SIZE_SMALL(struct aml_resource_fixed_io),\n\tACPI_AML_SIZE_SMALL(struct aml_resource_fixed_dma),\n\t0,\n\t0,\n\t0,\n\tACPI_AML_SIZE_SMALL(struct aml_resource_vendor_small),\n\tACPI_AML_SIZE_SMALL(struct aml_resource_end_tag),\n\n\t \n\n\t0,\n\tACPI_AML_SIZE_LARGE(struct aml_resource_memory24),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_generic_register),\n\t0,\n\tACPI_AML_SIZE_LARGE(struct aml_resource_vendor_large),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_memory32),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_fixed_memory32),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_address32),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_address16),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_extended_irq),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_address64),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_extended_address64),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_gpio),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_pin_function),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_common_serialbus),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_pin_config),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_pin_group),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_pin_group_function),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_pin_group_config),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_clock_input),\n\n};\n\nconst u8 acpi_gbl_resource_aml_serial_bus_sizes[] = {\n\t0,\n\tACPI_AML_SIZE_LARGE(struct aml_resource_i2c_serialbus),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_spi_serialbus),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_uart_serialbus),\n\tACPI_AML_SIZE_LARGE(struct aml_resource_csi2_serialbus),\n};\n\n \nstatic const u8 acpi_gbl_resource_types[] = {\n\t \n\n\t0,\n\t0,\n\t0,\n\t0,\n\tACPI_SMALL_VARIABLE_LENGTH,\t \n\tACPI_FIXED_LENGTH,\t \n\tACPI_SMALL_VARIABLE_LENGTH,\t \n\tACPI_FIXED_LENGTH,\t \n\tACPI_FIXED_LENGTH,\t \n\tACPI_FIXED_LENGTH,\t \n\tACPI_FIXED_LENGTH,\t \n\t0,\n\t0,\n\t0,\n\tACPI_VARIABLE_LENGTH,\t \n\tACPI_FIXED_LENGTH,\t \n\n\t \n\n\t0,\n\tACPI_FIXED_LENGTH,\t \n\tACPI_FIXED_LENGTH,\t \n\t0,\n\tACPI_VARIABLE_LENGTH,\t \n\tACPI_FIXED_LENGTH,\t \n\tACPI_FIXED_LENGTH,\t \n\tACPI_VARIABLE_LENGTH,\t \n\tACPI_VARIABLE_LENGTH,\t \n\tACPI_VARIABLE_LENGTH,\t \n\tACPI_VARIABLE_LENGTH,\t \n\tACPI_FIXED_LENGTH,\t \n\tACPI_VARIABLE_LENGTH,\t \n\tACPI_VARIABLE_LENGTH,\t \n\tACPI_VARIABLE_LENGTH,\t \n\tACPI_VARIABLE_LENGTH,\t \n\tACPI_VARIABLE_LENGTH,\t \n\tACPI_VARIABLE_LENGTH,\t \n\tACPI_VARIABLE_LENGTH,\t \n\tACPI_VARIABLE_LENGTH,\t \n};\n\n \n\nacpi_status\nacpi_ut_walk_aml_resources(struct acpi_walk_state *walk_state,\n\t\t\t   u8 *aml,\n\t\t\t   acpi_size aml_length,\n\t\t\t   acpi_walk_aml_callback user_function, void **context)\n{\n\tacpi_status status;\n\tu8 *end_aml;\n\tu8 resource_index;\n\tu32 length;\n\tu32 offset = 0;\n\tu8 end_tag[2] = { 0x79, 0x00 };\n\n\tACPI_FUNCTION_TRACE(ut_walk_aml_resources);\n\n\t \n\n\tif (aml_length < sizeof(struct aml_resource_end_tag)) {\n\t\treturn_ACPI_STATUS(AE_AML_NO_RESOURCE_END_TAG);\n\t}\n\n\t \n\n\tend_aml = aml + aml_length;\n\n\t \n\n\twhile (aml < end_aml) {\n\n\t\t \n\n\t\tstatus =\n\t\t    acpi_ut_validate_resource(walk_state, aml, &resource_index);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\t \n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\t \n\n\t\tlength = acpi_ut_get_descriptor_length(aml);\n\n\t\t \n\n\t\tif (user_function) {\n\t\t\tstatus =\n\t\t\t    user_function(aml, length, offset, resource_index,\n\t\t\t\t\t  context);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (acpi_ut_get_resource_type(aml) ==\n\t\t    ACPI_RESOURCE_NAME_END_TAG) {\n\t\t\t \n\t\t\tif ((aml + 1) >= end_aml) {\n\t\t\t\treturn_ACPI_STATUS(AE_AML_NO_RESOURCE_END_TAG);\n\t\t\t}\n\n\t\t\t \n\n\t\t\t \n\n\t\t\tif (!user_function) {\n\t\t\t\t*context = aml;\n\t\t\t}\n\n\t\t\t \n\n\t\t\treturn_ACPI_STATUS(AE_OK);\n\t\t}\n\n\t\taml += length;\n\t\toffset += length;\n\t}\n\n\t \n\n\tif (user_function) {\n\n\t\t \n\n\t\t(void)acpi_ut_validate_resource(walk_state, end_tag,\n\t\t\t\t\t\t&resource_index);\n\t\tstatus =\n\t\t    user_function(end_tag, 2, offset, resource_index, context);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(AE_AML_NO_RESOURCE_END_TAG);\n}\n\n \n\nacpi_status\nacpi_ut_validate_resource(struct acpi_walk_state *walk_state,\n\t\t\t  void *aml, u8 *return_index)\n{\n\tunion aml_resource *aml_resource;\n\tu8 resource_type;\n\tu8 resource_index;\n\tacpi_rs_length resource_length;\n\tacpi_rs_length minimum_resource_length;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\tresource_type = ACPI_GET8(aml);\n\n\t \n\tif (resource_type & ACPI_RESOURCE_NAME_LARGE) {\n\n\t\t \n\n\t\tif (resource_type > ACPI_RESOURCE_NAME_LARGE_MAX) {\n\t\t\tgoto invalid_resource;\n\t\t}\n\n\t\t \n\t\tresource_index = (u8) (resource_type - 0x70);\n\t} else {\n\t\t \n\t\tresource_index = (u8)\n\t\t    ((resource_type & ACPI_RESOURCE_NAME_SMALL_MASK) >> 3);\n\t}\n\n\t \n\tif (!acpi_gbl_resource_types[resource_index]) {\n\t\tgoto invalid_resource;\n\t}\n\n\t \n\tresource_length = acpi_ut_get_resource_length(aml);\n\tminimum_resource_length = acpi_gbl_resource_aml_sizes[resource_index];\n\n\t \n\n\tswitch (acpi_gbl_resource_types[resource_index]) {\n\tcase ACPI_FIXED_LENGTH:\n\n\t\t \n\n\t\tif (resource_length != minimum_resource_length) {\n\t\t\tgoto bad_resource_length;\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_VARIABLE_LENGTH:\n\n\t\t \n\n\t\tif (resource_length < minimum_resource_length) {\n\t\t\tgoto bad_resource_length;\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_SMALL_VARIABLE_LENGTH:\n\n\t\t \n\n\t\tif ((resource_length > minimum_resource_length) ||\n\t\t    (resource_length < (minimum_resource_length - 1))) {\n\t\t\tgoto bad_resource_length;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\t \n\n\t\tgoto invalid_resource;\n\t}\n\n\taml_resource = ACPI_CAST_PTR(union aml_resource, aml);\n\tif (resource_type == ACPI_RESOURCE_NAME_SERIAL_BUS) {\n\n\t\t \n\n\t\tstruct aml_resource_common_serialbus common_serial_bus;\n\t\tmemcpy(&common_serial_bus, aml_resource,\n\t\t       sizeof(common_serial_bus));\n\n\t\t \n\n\t\tif ((common_serial_bus.type == 0) ||\n\t\t    (common_serial_bus.type > AML_RESOURCE_MAX_SERIALBUSTYPE)) {\n\t\t\tif (walk_state) {\n\t\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t\t    \"Invalid/unsupported SerialBus resource descriptor: BusType 0x%2.2X\",\n\t\t\t\t\t    common_serial_bus.type));\n\t\t\t}\n\t\t\treturn (AE_AML_INVALID_RESOURCE_TYPE);\n\t\t}\n\t}\n\n\t \n\n\tif (return_index) {\n\t\t*return_index = resource_index;\n\t}\n\n\treturn (AE_OK);\n\ninvalid_resource:\n\n\tif (walk_state) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Invalid/unsupported resource descriptor: Type 0x%2.2X\",\n\t\t\t    resource_type));\n\t}\n\treturn (AE_AML_INVALID_RESOURCE_TYPE);\n\nbad_resource_length:\n\n\tif (walk_state) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Invalid resource descriptor length: Type \"\n\t\t\t    \"0x%2.2X, Length 0x%4.4X, MinLength 0x%4.4X\",\n\t\t\t    resource_type, resource_length,\n\t\t\t    minimum_resource_length));\n\t}\n\treturn (AE_AML_BAD_RESOURCE_LENGTH);\n}\n\n \n\nu8 acpi_ut_get_resource_type(void *aml)\n{\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\tif (ACPI_GET8(aml) & ACPI_RESOURCE_NAME_LARGE) {\n\n\t\t \n\n\t\treturn (ACPI_GET8(aml));\n\t} else {\n\t\t \n\n\t\treturn ((u8) (ACPI_GET8(aml) & ACPI_RESOURCE_NAME_SMALL_MASK));\n\t}\n}\n\n \n\nu16 acpi_ut_get_resource_length(void *aml)\n{\n\tacpi_rs_length resource_length;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\tif (ACPI_GET8(aml) & ACPI_RESOURCE_NAME_LARGE) {\n\n\t\t \n\n\t\tACPI_MOVE_16_TO_16(&resource_length, ACPI_ADD_PTR(u8, aml, 1));\n\n\t} else {\n\t\t \n\n\t\tresource_length = (u16) (ACPI_GET8(aml) &\n\t\t\t\t\t ACPI_RESOURCE_NAME_SMALL_LENGTH_MASK);\n\t}\n\n\treturn (resource_length);\n}\n\n \n\nu8 acpi_ut_get_resource_header_length(void *aml)\n{\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tif (ACPI_GET8(aml) & ACPI_RESOURCE_NAME_LARGE) {\n\t\treturn (sizeof(struct aml_resource_large_header));\n\t} else {\n\t\treturn (sizeof(struct aml_resource_small_header));\n\t}\n}\n\n \n\nu32 acpi_ut_get_descriptor_length(void *aml)\n{\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\treturn (acpi_ut_get_resource_length(aml) +\n\t\tacpi_ut_get_resource_header_length(aml));\n}\n\n \n\nacpi_status\nacpi_ut_get_resource_end_tag(union acpi_operand_object *obj_desc, u8 **end_tag)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ut_get_resource_end_tag);\n\n\t \n\n\tif (!obj_desc->buffer.length) {\n\t\t*end_tag = obj_desc->buffer.pointer;\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tstatus = acpi_ut_walk_aml_resources(NULL, obj_desc->buffer.pointer,\n\t\t\t\t\t    obj_desc->buffer.length, NULL,\n\t\t\t\t\t    (void **)end_tag);\n\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}