{
  "module_name": "utcache.c",
  "hash_id": "118dde7056580912ce8bf9f50e1cfb7528fa817777ef25e396c1e2d198e9cbc0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utcache.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utcache\")\n\n#ifdef ACPI_USE_LOCAL_CACHE\n \nacpi_status\nacpi_os_create_cache(char *cache_name,\n\t\t     u16 object_size,\n\t\t     u16 max_depth, struct acpi_memory_list **return_cache)\n{\n\tstruct acpi_memory_list *cache;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tif (!cache_name || !return_cache || !object_size) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tcache = acpi_os_allocate(sizeof(struct acpi_memory_list));\n\tif (!cache) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\t \n\n\tmemset(cache, 0, sizeof(struct acpi_memory_list));\n\tcache->list_name = cache_name;\n\tcache->object_size = object_size;\n\tcache->max_depth = max_depth;\n\n\t*return_cache = cache;\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_os_purge_cache(struct acpi_memory_list *cache)\n{\n\tvoid *next;\n\tacpi_status status;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tif (!cache) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\twhile (cache->list_head) {\n\n\t\t \n\n\t\tnext = ACPI_GET_DESCRIPTOR_PTR(cache->list_head);\n\t\tACPI_FREE(cache->list_head);\n\n\t\tcache->list_head = next;\n\t\tcache->current_depth--;\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_CACHES);\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_os_delete_cache(struct acpi_memory_list *cache)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tstatus = acpi_os_purge_cache(cache);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\tacpi_os_free(cache);\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_os_release_object(struct acpi_memory_list *cache, void *object)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tif (!cache || !object) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tif (cache->current_depth >= cache->max_depth) {\n\t\tACPI_FREE(object);\n\t\tACPI_MEM_TRACKING(cache->total_freed++);\n\t}\n\n\t \n\n\telse {\n\t\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\n\t\t \n\n\t\tmemset(object, 0xCA, cache->object_size);\n\t\tACPI_SET_DESCRIPTOR_TYPE(object, ACPI_DESC_TYPE_CACHED);\n\n\t\t \n\n\t\tACPI_SET_DESCRIPTOR_PTR(object, cache->list_head);\n\t\tcache->list_head = object;\n\t\tcache->current_depth++;\n\n\t\t(void)acpi_ut_release_mutex(ACPI_MTX_CACHES);\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nvoid *acpi_os_acquire_object(struct acpi_memory_list *cache)\n{\n\tacpi_status status;\n\tvoid *object;\n\n\tACPI_FUNCTION_TRACE(os_acquire_object);\n\n\tif (!cache) {\n\t\treturn_PTR(NULL);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_PTR(NULL);\n\t}\n\n\tACPI_MEM_TRACKING(cache->requests++);\n\n\t \n\n\tif (cache->list_head) {\n\n\t\t \n\n\t\tobject = cache->list_head;\n\t\tcache->list_head = ACPI_GET_DESCRIPTOR_PTR(object);\n\n\t\tcache->current_depth--;\n\n\t\tACPI_MEM_TRACKING(cache->hits++);\n\t\tACPI_DEBUG_PRINT_RAW((ACPI_DB_EXEC,\n\t\t\t\t      \"%s: Object %p from %s cache\\n\",\n\t\t\t\t      ACPI_GET_FUNCTION_NAME, object,\n\t\t\t\t      cache->list_name));\n\n\t\tstatus = acpi_ut_release_mutex(ACPI_MTX_CACHES);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_PTR(NULL);\n\t\t}\n\n\t\t \n\n\t\tmemset(object, 0, cache->object_size);\n\t} else {\n\t\t \n\n\t\tACPI_MEM_TRACKING(cache->total_allocated++);\n\n#ifdef ACPI_DBG_TRACK_ALLOCATIONS\n\t\tif ((cache->total_allocated - cache->total_freed) >\n\t\t    cache->max_occupied) {\n\t\t\tcache->max_occupied =\n\t\t\t    cache->total_allocated - cache->total_freed;\n\t\t}\n#endif\n\n\t\t \n\n\t\tstatus = acpi_ut_release_mutex(ACPI_MTX_CACHES);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_PTR(NULL);\n\t\t}\n\n\t\tobject = ACPI_ALLOCATE_ZEROED(cache->object_size);\n\t\tif (!object) {\n\t\t\treturn_PTR(NULL);\n\t\t}\n\t}\n\n\treturn_PTR(object);\n}\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}