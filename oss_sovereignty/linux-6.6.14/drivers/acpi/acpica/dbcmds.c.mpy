{
  "module_name": "dbcmds.c",
  "hash_id": "cc480fa999f8f1a34ad13957c6b870916f2d06a14c37ac88cce3e5992bd51aeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/dbcmds.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n#include \"acdebug.h\"\n#include \"acnamesp.h\"\n#include \"acresrc.h\"\n#include \"actables.h\"\n\n#define _COMPONENT          ACPI_CA_DEBUGGER\nACPI_MODULE_NAME(\"dbcmds\")\n\n \nstatic void\nacpi_dm_compare_aml_resources(u8 *aml1_buffer,\n\t\t\t      acpi_rsdesc_size aml1_buffer_length,\n\t\t\t      u8 *aml2_buffer,\n\t\t\t      acpi_rsdesc_size aml2_buffer_length);\n\nstatic acpi_status\nacpi_dm_test_resource_conversion(struct acpi_namespace_node *node, char *name);\n\nstatic acpi_status\nacpi_db_resource_callback(struct acpi_resource *resource, void *context);\n\nstatic acpi_status\nacpi_db_device_resources(acpi_handle obj_handle,\n\t\t\t u32 nesting_level, void *context, void **return_value);\n\nstatic void acpi_db_do_one_sleep_state(u8 sleep_state);\n\nstatic char *acpi_db_trace_method_name = NULL;\n\n \n\nstruct acpi_namespace_node *acpi_db_convert_to_node(char *in_string)\n{\n\tstruct acpi_namespace_node *node;\n\tacpi_size address;\n\n\tif ((*in_string >= 0x30) && (*in_string <= 0x39)) {\n\n\t\t \n\n\t\taddress = strtoul(in_string, NULL, 16);\n\t\tnode = ACPI_TO_POINTER(address);\n\t\tif (!acpi_os_readable(node, sizeof(struct acpi_namespace_node))) {\n\t\t\tacpi_os_printf(\"Address %p is invalid\", node);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\t \n\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(node) != ACPI_DESC_TYPE_NAMED) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Address %p is not a valid namespace node [%s]\\n\",\n\t\t\t     node, acpi_ut_get_descriptor_name(node));\n\t\t\treturn (NULL);\n\t\t}\n\t} else {\n\t\t \n\t\tnode = acpi_db_local_ns_lookup(in_string);\n\t\tif (!node) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Could not find [%s] in namespace, defaulting to root node\\n\",\n\t\t\t     in_string);\n\t\t\tnode = acpi_gbl_root_node;\n\t\t}\n\t}\n\n\treturn (node);\n}\n\n \n\nacpi_status acpi_db_sleep(char *object_arg)\n{\n\tu8 sleep_state;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(acpi_db_sleep);\n\n\t \n\n\tif (!object_arg) {\n\t\tacpi_os_printf(\"Invoking all possible sleep states, 0-%d\\n\",\n\t\t\t       ACPI_S_STATES_MAX);\n\n\t\tfor (i = 0; i <= ACPI_S_STATES_MAX; i++) {\n\t\t\tacpi_db_do_one_sleep_state((u8)i);\n\t\t}\n\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tsleep_state = (u8)strtoul(object_arg, NULL, 0);\n\tacpi_db_do_one_sleep_state(sleep_state);\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nstatic void acpi_db_do_one_sleep_state(u8 sleep_state)\n{\n\tacpi_status status;\n\tu8 sleep_type_a;\n\tu8 sleep_type_b;\n\n\t \n\n\tif (sleep_state > ACPI_S_STATES_MAX) {\n\t\tacpi_os_printf(\"Sleep state %d out of range (%d max)\\n\",\n\t\t\t       sleep_state, ACPI_S_STATES_MAX);\n\t\treturn;\n\t}\n\n\tacpi_os_printf(\"\\n---- Invoking sleep state S%d (%s):\\n\",\n\t\t       sleep_state, acpi_gbl_sleep_state_names[sleep_state]);\n\n\t \n\n\tstatus =\n\t    acpi_get_sleep_type_data(sleep_state, &sleep_type_a, &sleep_type_b);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could not evaluate [%s] method, %s\\n\",\n\t\t\t       acpi_gbl_sleep_state_names[sleep_state],\n\t\t\t       acpi_format_exception(status));\n\t\treturn;\n\t}\n\n\tacpi_os_printf\n\t    (\"Register values for sleep state S%d: Sleep-A: %.2X, Sleep-B: %.2X\\n\",\n\t     sleep_state, sleep_type_a, sleep_type_b);\n\n\t \n\n\tacpi_os_printf(\"**** Sleep: Prepare to sleep (S%d) ****\\n\",\n\t\t       sleep_state);\n\tstatus = acpi_enter_sleep_state_prep(sleep_state);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto error_exit;\n\t}\n\n\tacpi_os_printf(\"**** Sleep: Going to sleep (S%d) ****\\n\", sleep_state);\n\tstatus = acpi_enter_sleep_state(sleep_state);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto error_exit;\n\t}\n\n\tacpi_os_printf(\"**** Wake: Prepare to return from sleep (S%d) ****\\n\",\n\t\t       sleep_state);\n\tstatus = acpi_leave_sleep_state_prep(sleep_state);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto error_exit;\n\t}\n\n\tacpi_os_printf(\"**** Wake: Return from sleep (S%d) ****\\n\",\n\t\t       sleep_state);\n\tstatus = acpi_leave_sleep_state(sleep_state);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto error_exit;\n\t}\n\n\treturn;\n\nerror_exit:\n\tACPI_EXCEPTION((AE_INFO, status, \"During invocation of sleep state S%d\",\n\t\t\tsleep_state));\n}\n\n \n\nvoid acpi_db_display_locks(void)\n{\n\tu32 i;\n\n\tfor (i = 0; i < ACPI_MAX_MUTEX; i++) {\n\t\tacpi_os_printf(\"%26s : %s\\n\", acpi_ut_get_mutex_name(i),\n\t\t\t       acpi_gbl_mutex_info[i].thread_id ==\n\t\t\t       ACPI_MUTEX_NOT_ACQUIRED ? \"Locked\" : \"Unlocked\");\n\t}\n}\n\n \n\nvoid acpi_db_display_table_info(char *table_arg)\n{\n\tu32 i;\n\tstruct acpi_table_desc *table_desc;\n\tacpi_status status;\n\n\t \n\n\tacpi_os_printf(\"Idx ID  Status Type                    \"\n\t\t       \"TableHeader (Sig, Address, Length, Misc)\\n\");\n\n\t \n\n\tfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {\n\t\ttable_desc = &acpi_gbl_root_table_list.tables[i];\n\n\t\t \n\n\t\tacpi_os_printf(\"%3u %.2u \", i, table_desc->owner_id);\n\n\t\t \n\n\t\tif (!(table_desc->flags & ACPI_TABLE_IS_LOADED)) {\n\t\t\tacpi_os_printf(\"NotLoaded \");\n\t\t} else {\n\t\t\tacpi_os_printf(\" Loaded \");\n\t\t}\n\n\t\tswitch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {\n\t\tcase ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:\n\n\t\t\tacpi_os_printf(\"External/virtual \");\n\t\t\tbreak;\n\n\t\tcase ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:\n\n\t\t\tacpi_os_printf(\"Internal/physical \");\n\t\t\tbreak;\n\n\t\tcase ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:\n\n\t\t\tacpi_os_printf(\"Internal/virtual \");\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tacpi_os_printf(\"INVALID TYPE    \");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_tb_validate_table(table_desc);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn;\n\t\t}\n\n\t\t \n\n\t\tif (table_desc->pointer) {\n\t\t\tacpi_tb_print_table_header(table_desc->address,\n\t\t\t\t\t\t   table_desc->pointer);\n\t\t} else {\n\t\t\t \n\n\t\t\tACPI_INFO((\"%4.4s - Table has been unloaded\",\n\t\t\t\t   table_desc->signature.ascii));\n\t\t}\n\t}\n}\n\n \n\nvoid acpi_db_unload_acpi_table(char *object_name)\n{\n\tstruct acpi_namespace_node *node;\n\tacpi_status status;\n\n\t \n\n\tnode = acpi_db_convert_to_node(object_name);\n\tif (!node) {\n\t\treturn;\n\t}\n\n\tstatus = acpi_unload_parent_table(ACPI_CAST_PTR(acpi_handle, node));\n\tif (ACPI_SUCCESS(status)) {\n\t\tacpi_os_printf(\"Parent of [%s] (%p) unloaded and uninstalled\\n\",\n\t\t\t       object_name, node);\n\t} else {\n\t\tacpi_os_printf(\"%s, while unloading parent table of [%s]\\n\",\n\t\t\t       acpi_format_exception(status), object_name);\n\t}\n}\n\n \n\nvoid acpi_db_send_notify(char *name, u32 value)\n{\n\tstruct acpi_namespace_node *node;\n\tacpi_status status;\n\n\t \n\n\tnode = acpi_db_convert_to_node(name);\n\tif (!node) {\n\t\treturn;\n\t}\n\n\t \n\n\tif (acpi_ev_is_notify_object(node)) {\n\t\tstatus = acpi_ev_queue_notify_request(node, value);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"Could not queue notify\\n\");\n\t\t}\n\t} else {\n\t\tacpi_os_printf(\"Named object [%4.4s] Type %s, \"\n\t\t\t       \"must be Device/Thermal/Processor type\\n\",\n\t\t\t       acpi_ut_get_node_name(node),\n\t\t\t       acpi_ut_get_type_name(node->type));\n\t}\n}\n\n \n\nvoid acpi_db_display_interfaces(char *action_arg, char *interface_name_arg)\n{\n\tstruct acpi_interface_info *next_interface;\n\tchar *sub_string;\n\tacpi_status status;\n\n\t \n\n\tif (!action_arg) {\n\t\t(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex,\n\t\t\t\t\t    ACPI_WAIT_FOREVER);\n\n\t\tnext_interface = acpi_gbl_supported_interfaces;\n\t\twhile (next_interface) {\n\t\t\tif (!(next_interface->flags & ACPI_OSI_INVALID)) {\n\t\t\t\tacpi_os_printf(\"%s\\n\", next_interface->name);\n\t\t\t}\n\n\t\t\tnext_interface = next_interface->next;\n\t\t}\n\n\t\tacpi_os_release_mutex(acpi_gbl_osi_mutex);\n\t\treturn;\n\t}\n\n\t \n\n\tif (!interface_name_arg) {\n\t\tacpi_os_printf(\"Missing Interface Name argument\\n\");\n\t\treturn;\n\t}\n\n\t \n\n\tacpi_ut_strupr(action_arg);\n\n\t \n\n\tsub_string = strstr(\"INSTALL\", action_arg);\n\tif (sub_string) {\n\t\tstatus = acpi_install_interface(interface_name_arg);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"%s, while installing \\\"%s\\\"\\n\",\n\t\t\t\t       acpi_format_exception(status),\n\t\t\t\t       interface_name_arg);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\n\tsub_string = strstr(\"REMOVE\", action_arg);\n\tif (sub_string) {\n\t\tstatus = acpi_remove_interface(interface_name_arg);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"%s, while removing \\\"%s\\\"\\n\",\n\t\t\t\t       acpi_format_exception(status),\n\t\t\t\t       interface_name_arg);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\n\tacpi_os_printf(\"Invalid action argument: %s\\n\", action_arg);\n\treturn;\n}\n\n \n\nvoid acpi_db_display_template(char *buffer_arg)\n{\n\tstruct acpi_namespace_node *node;\n\tacpi_status status;\n\tstruct acpi_buffer return_buffer;\n\n\t \n\n\tnode = acpi_db_convert_to_node(buffer_arg);\n\tif (!node || (node == acpi_gbl_root_node)) {\n\t\tacpi_os_printf(\"Invalid argument: %s\\n\", buffer_arg);\n\t\treturn;\n\t}\n\n\t \n\n\tif (node->type != ACPI_TYPE_BUFFER) {\n\t\tacpi_os_printf\n\t\t    (\"Not a Buffer object, cannot be a template: %s\\n\",\n\t\t     buffer_arg);\n\t\treturn;\n\t}\n\n\treturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\n\treturn_buffer.pointer = acpi_gbl_db_buffer;\n\n\t \n\n\tstatus = acpi_rs_create_resource_list(node->object, &return_buffer);\n\n\tacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\n\tacpi_dbg_level |= ACPI_LV_RESOURCES;\n\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf\n\t\t    (\"Could not convert Buffer to a resource list: %s, %s\\n\",\n\t\t     buffer_arg, acpi_format_exception(status));\n\t\tgoto dump_buffer;\n\t}\n\n\t \n\n\tacpi_rs_dump_resource_list(ACPI_CAST_PTR(struct acpi_resource,\n\t\t\t\t\t\t return_buffer.pointer));\n\ndump_buffer:\n\tacpi_os_printf(\"\\nRaw data buffer:\\n\");\n\tacpi_ut_debug_dump_buffer((u8 *)node->object->buffer.pointer,\n\t\t\t\t  node->object->buffer.length,\n\t\t\t\t  DB_BYTE_DISPLAY, ACPI_UINT32_MAX);\n\n\tacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\n\treturn;\n}\n\n \n\nstatic void\nacpi_dm_compare_aml_resources(u8 *aml1_buffer,\n\t\t\t      acpi_rsdesc_size aml1_buffer_length,\n\t\t\t      u8 *aml2_buffer,\n\t\t\t      acpi_rsdesc_size aml2_buffer_length)\n{\n\tu8 *aml1;\n\tu8 *aml2;\n\tu8 *aml1_end;\n\tu8 *aml2_end;\n\tacpi_rsdesc_size aml1_length;\n\tacpi_rsdesc_size aml2_length;\n\tacpi_rsdesc_size offset = 0;\n\tu8 resource_type;\n\tu32 count = 0;\n\tu32 i;\n\n\t \n\n\tif (aml1_buffer_length != aml2_buffer_length) {\n\t\tacpi_os_printf(\"**** Buffer length mismatch in converted \"\n\t\t\t       \"AML: Original %X, New %X ****\\n\",\n\t\t\t       aml1_buffer_length, aml2_buffer_length);\n\t}\n\n\taml1 = aml1_buffer;\n\taml2 = aml2_buffer;\n\taml1_end = aml1_buffer + aml1_buffer_length;\n\taml2_end = aml2_buffer + aml2_buffer_length;\n\n\t \n\n\twhile ((aml1 < aml1_end) && (aml2 < aml2_end)) {\n\n\t\t \n\n\t\taml1_length = acpi_ut_get_descriptor_length(aml1);\n\t\taml2_length = acpi_ut_get_descriptor_length(aml2);\n\t\tresource_type = acpi_ut_get_resource_type(aml1);\n\n\t\t \n\n\t\tif (aml1_length != aml2_length) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"**** Length mismatch in descriptor [%.2X] type %2.2X, \"\n\t\t\t     \"Offset %8.8X Len1 %X, Len2 %X ****\\n\", count,\n\t\t\t     resource_type, offset, aml1_length, aml2_length);\n\t\t}\n\n\t\t \n\n\t\telse if (memcmp(aml1, aml2, aml1_length)) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"**** Data mismatch in descriptor [%.2X] type %2.2X, \"\n\t\t\t     \"Offset %8.8X ****\\n\", count, resource_type,\n\t\t\t     offset);\n\n\t\t\tfor (i = 0; i < aml1_length; i++) {\n\t\t\t\tif (aml1[i] != aml2[i]) {\n\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t    (\"Mismatch at byte offset %.2X: is %2.2X, \"\n\t\t\t\t\t     \"should be %2.2X\\n\", i, aml2[i],\n\t\t\t\t\t     aml1[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (resource_type == ACPI_RESOURCE_NAME_END_TAG) {\n\t\t\treturn;\n\t\t}\n\n\t\t \n\n\t\tcount++;\n\t\toffset += aml1_length;\n\t\taml1 += aml1_length;\n\t\taml2 += aml2_length;\n\t}\n}\n\n \n\nstatic acpi_status\nacpi_dm_test_resource_conversion(struct acpi_namespace_node *node, char *name)\n{\n\tacpi_status status;\n\tstruct acpi_buffer return_buffer;\n\tstruct acpi_buffer resource_buffer;\n\tstruct acpi_buffer new_aml;\n\tunion acpi_object *original_aml;\n\n\tacpi_os_printf(\"Resource Conversion Comparison:\\n\");\n\n\tnew_aml.length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\treturn_buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\tresource_buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\n\t \n\n\tstatus = acpi_evaluate_object(node, name, NULL, &return_buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could not obtain %s: %s\\n\",\n\t\t\t       name, acpi_format_exception(status));\n\t\treturn (status);\n\t}\n\n\t \n\n\tstatus = acpi_get_current_resources(node, &resource_buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"AcpiGetCurrentResources failed: %s\\n\",\n\t\t\t       acpi_format_exception(status));\n\t\tgoto exit1;\n\t}\n\n\t \n\n\tstatus = acpi_rs_create_aml_resources(&resource_buffer, &new_aml);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"AcpiRsCreateAmlResources failed: %s\\n\",\n\t\t\t       acpi_format_exception(status));\n\t\tgoto exit2;\n\t}\n\n\t \n\n\toriginal_aml = return_buffer.pointer;\n\n\tacpi_dm_compare_aml_resources(original_aml->buffer.pointer,\n\t\t\t\t      (acpi_rsdesc_size)original_aml->buffer.\n\t\t\t\t      length, new_aml.pointer,\n\t\t\t\t      (acpi_rsdesc_size)new_aml.length);\n\n\t \n\n\tACPI_FREE(new_aml.pointer);\nexit2:\n\tACPI_FREE(resource_buffer.pointer);\nexit1:\n\tACPI_FREE(return_buffer.pointer);\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nacpi_db_resource_callback(struct acpi_resource *resource, void *context)\n{\n\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_db_device_resources(acpi_handle obj_handle,\n\t\t\t u32 nesting_level, void *context, void **return_value)\n{\n\tstruct acpi_namespace_node *node;\n\tstruct acpi_namespace_node *prt_node = NULL;\n\tstruct acpi_namespace_node *crs_node = NULL;\n\tstruct acpi_namespace_node *prs_node = NULL;\n\tstruct acpi_namespace_node *aei_node = NULL;\n\tchar *parent_path;\n\tstruct acpi_buffer return_buffer;\n\tacpi_status status;\n\n\tnode = ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);\n\tparent_path = acpi_ns_get_normalized_pathname(node, TRUE);\n\tif (!parent_path) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\t \n\n\t(void)acpi_get_handle(node, METHOD_NAME__PRT,\n\t\t\t      ACPI_CAST_PTR(acpi_handle, &prt_node));\n\t(void)acpi_get_handle(node, METHOD_NAME__CRS,\n\t\t\t      ACPI_CAST_PTR(acpi_handle, &crs_node));\n\t(void)acpi_get_handle(node, METHOD_NAME__PRS,\n\t\t\t      ACPI_CAST_PTR(acpi_handle, &prs_node));\n\t(void)acpi_get_handle(node, METHOD_NAME__AEI,\n\t\t\t      ACPI_CAST_PTR(acpi_handle, &aei_node));\n\n\tif (!prt_node && !crs_node && !prs_node && !aei_node) {\n\t\tgoto cleanup;\t \n\t}\n\n\tacpi_os_printf(\"\\nDevice: %s\\n\", parent_path);\n\n\t \n\n\treturn_buffer.pointer = acpi_gbl_db_buffer;\n\treturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\n\n\t \n\n\tif (prt_node) {\n\t\tacpi_os_printf(\"Evaluating _PRT\\n\");\n\n\t\tstatus =\n\t\t    acpi_evaluate_object(prt_node, NULL, NULL, &return_buffer);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"Could not evaluate _PRT: %s\\n\",\n\t\t\t\t       acpi_format_exception(status));\n\t\t\tgoto get_crs;\n\t\t}\n\n\t\treturn_buffer.pointer = acpi_gbl_db_buffer;\n\t\treturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\n\n\t\tstatus = acpi_get_irq_routing_table(node, &return_buffer);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"GetIrqRoutingTable failed: %s\\n\",\n\t\t\t\t       acpi_format_exception(status));\n\t\t\tgoto get_crs;\n\t\t}\n\n\t\tacpi_rs_dump_irq_list(ACPI_CAST_PTR(u8, acpi_gbl_db_buffer));\n\t}\n\n\t \n\nget_crs:\n\tif (crs_node) {\n\t\tacpi_os_printf(\"Evaluating _CRS\\n\");\n\n\t\treturn_buffer.pointer = acpi_gbl_db_buffer;\n\t\treturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\n\n\t\tstatus =\n\t\t    acpi_evaluate_object(crs_node, NULL, NULL, &return_buffer);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"Could not evaluate _CRS: %s\\n\",\n\t\t\t\t       acpi_format_exception(status));\n\t\t\tgoto get_prs;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_walk_resources(node, METHOD_NAME__CRS,\n\t\t\t\t\t     acpi_db_resource_callback, NULL);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"AcpiWalkResources failed: %s\\n\",\n\t\t\t\t       acpi_format_exception(status));\n\t\t\tgoto get_prs;\n\t\t}\n\n\t\t \n\n\t\treturn_buffer.pointer = NULL;\n\t\treturn_buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\n\t\tstatus = acpi_get_current_resources(node, &return_buffer);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"AcpiGetCurrentResources failed: %s\\n\",\n\t\t\t\t       acpi_format_exception(status));\n\t\t\tgoto get_prs;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_walk_resource_buffer(&return_buffer,\n\t\t\t\t\t\t   acpi_db_resource_callback,\n\t\t\t\t\t\t   NULL);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"AcpiWalkResourceBuffer failed: %s\\n\",\n\t\t\t\t       acpi_format_exception(status));\n\t\t\tgoto end_crs;\n\t\t}\n\n\t\t \n\n\t\tacpi_rs_dump_resource_list(ACPI_CAST_PTR(struct acpi_resource,\n\t\t\t\t\t\t\t return_buffer.\n\t\t\t\t\t\t\t pointer));\n\n\t\t \n\t\t(void)acpi_dm_test_resource_conversion(node, METHOD_NAME__CRS);\n\n\t\t \n\n\t\tacpi_os_printf(\"Evaluating _SRS\\n\");\n\n\t\tstatus = acpi_set_current_resources(node, &return_buffer);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"AcpiSetCurrentResources failed: %s\\n\",\n\t\t\t\t       acpi_format_exception(status));\n\t\t\tgoto end_crs;\n\t\t}\n\nend_crs:\n\t\tACPI_FREE(return_buffer.pointer);\n\t}\n\n\t \n\nget_prs:\n\tif (prs_node) {\n\t\tacpi_os_printf(\"Evaluating _PRS\\n\");\n\n\t\treturn_buffer.pointer = acpi_gbl_db_buffer;\n\t\treturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\n\n\t\tstatus =\n\t\t    acpi_evaluate_object(prs_node, NULL, NULL, &return_buffer);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"Could not evaluate _PRS: %s\\n\",\n\t\t\t\t       acpi_format_exception(status));\n\t\t\tgoto get_aei;\n\t\t}\n\n\t\treturn_buffer.pointer = acpi_gbl_db_buffer;\n\t\treturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\n\n\t\tstatus = acpi_get_possible_resources(node, &return_buffer);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"AcpiGetPossibleResources failed: %s\\n\",\n\t\t\t\t       acpi_format_exception(status));\n\t\t\tgoto get_aei;\n\t\t}\n\n\t\tacpi_rs_dump_resource_list(ACPI_CAST_PTR\n\t\t\t\t\t   (struct acpi_resource,\n\t\t\t\t\t    acpi_gbl_db_buffer));\n\t}\n\n\t \n\nget_aei:\n\tif (aei_node) {\n\t\tacpi_os_printf(\"Evaluating _AEI\\n\");\n\n\t\treturn_buffer.pointer = acpi_gbl_db_buffer;\n\t\treturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\n\n\t\tstatus =\n\t\t    acpi_evaluate_object(aei_node, NULL, NULL, &return_buffer);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"Could not evaluate _AEI: %s\\n\",\n\t\t\t\t       acpi_format_exception(status));\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\treturn_buffer.pointer = acpi_gbl_db_buffer;\n\t\treturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\n\n\t\tstatus = acpi_get_event_resources(node, &return_buffer);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_os_printf(\"AcpiGetEventResources failed: %s\\n\",\n\t\t\t\t       acpi_format_exception(status));\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tacpi_rs_dump_resource_list(ACPI_CAST_PTR\n\t\t\t\t\t   (struct acpi_resource,\n\t\t\t\t\t    acpi_gbl_db_buffer));\n\t}\n\ncleanup:\n\tACPI_FREE(parent_path);\n\treturn (AE_OK);\n}\n\n \n\nvoid acpi_db_display_resources(char *object_arg)\n{\n\tstruct acpi_namespace_node *node;\n\n\tacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\n\tacpi_dbg_level |= ACPI_LV_RESOURCES;\n\n\t \n\n\tif (!object_arg || (!strcmp(object_arg, \"*\"))) {\n\t\t(void)acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\n\t\t\t\t\t  ACPI_UINT32_MAX,\n\t\t\t\t\t  acpi_db_device_resources, NULL, NULL,\n\t\t\t\t\t  NULL);\n\t} else {\n\t\t \n\n\t\tnode = acpi_db_convert_to_node(object_arg);\n\t\tif (node) {\n\t\t\tif (node->type != ACPI_TYPE_DEVICE) {\n\t\t\t\tacpi_os_printf\n\t\t\t\t    (\"%4.4s: Name is not a device object (%s)\\n\",\n\t\t\t\t     node->name.ascii,\n\t\t\t\t     acpi_ut_get_type_name(node->type));\n\t\t\t} else {\n\t\t\t\t(void)acpi_db_device_resources(node, 0, NULL,\n\t\t\t\t\t\t\t       NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\tacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\n}\n\n \n\nvoid acpi_db_generate_interrupt(char *gsiv_arg)\n{\n\tu32 gsiv_number;\n\tstruct acpi_ged_handler_info *ged_info = acpi_gbl_ged_handler_list;\n\n\tif (!ged_info) {\n\t\tacpi_os_printf(\"No GED handling present\\n\");\n\t}\n\n\tgsiv_number = strtoul(gsiv_arg, NULL, 0);\n\n\twhile (ged_info) {\n\n\t\tif (ged_info->int_id == gsiv_number) {\n\t\t\tstruct acpi_object_list arg_list;\n\t\t\tunion acpi_object arg0;\n\t\t\tacpi_handle evt_handle = ged_info->evt_method;\n\t\t\tacpi_status status;\n\n\t\t\tacpi_os_printf(\"Evaluate GED _EVT (GSIV=%d)\\n\",\n\t\t\t\t       gsiv_number);\n\n\t\t\tif (!evt_handle) {\n\t\t\t\tacpi_os_printf(\"Undefined _EVT method\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\targ0.integer.type = ACPI_TYPE_INTEGER;\n\t\t\targ0.integer.value = gsiv_number;\n\n\t\t\targ_list.count = 1;\n\t\t\targ_list.pointer = &arg0;\n\n\t\t\tstatus =\n\t\t\t    acpi_evaluate_object(evt_handle, NULL, &arg_list,\n\t\t\t\t\t\t NULL);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tacpi_os_printf(\"Could not evaluate _EVT\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t}\n\t\tged_info = ged_info->next;\n\t}\n}\n\n#if (!ACPI_REDUCED_HARDWARE)\n \n\nvoid acpi_db_generate_gpe(char *gpe_arg, char *block_arg)\n{\n\tu32 block_number = 0;\n\tu32 gpe_number;\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\n\tgpe_number = strtoul(gpe_arg, NULL, 0);\n\n\t \n\tif (block_arg) {\n\t\tblock_number = strtoul(block_arg, NULL, 0);\n\t\tif (block_number == 1) {\n\t\t\tblock_number = 0;\n\t\t}\n\t}\n\n\tgpe_event_info =\n\t    acpi_ev_get_gpe_event_info(ACPI_TO_POINTER(block_number),\n\t\t\t\t       gpe_number);\n\tif (!gpe_event_info) {\n\t\tacpi_os_printf(\"Invalid GPE\\n\");\n\t\treturn;\n\t}\n\n\t(void)acpi_ev_gpe_dispatch(NULL, gpe_event_info, gpe_number);\n}\n\n \n\nvoid acpi_db_generate_sci(void)\n{\n\tacpi_ev_sci_dispatch();\n}\n\n#endif\t\t\t\t \n\n \n\nvoid acpi_db_trace(char *enable_arg, char *method_arg, char *once_arg)\n{\n\tu32 debug_level = 0;\n\tu32 debug_layer = 0;\n\tu32 flags = 0;\n\n\tacpi_ut_strupr(enable_arg);\n\tacpi_ut_strupr(once_arg);\n\n\tif (method_arg) {\n\t\tif (acpi_db_trace_method_name) {\n\t\t\tACPI_FREE(acpi_db_trace_method_name);\n\t\t\tacpi_db_trace_method_name = NULL;\n\t\t}\n\n\t\tacpi_db_trace_method_name =\n\t\t    ACPI_ALLOCATE(strlen(method_arg) + 1);\n\t\tif (!acpi_db_trace_method_name) {\n\t\t\tacpi_os_printf(\"Failed to allocate method name (%s)\\n\",\n\t\t\t\t       method_arg);\n\t\t\treturn;\n\t\t}\n\n\t\tstrcpy(acpi_db_trace_method_name, method_arg);\n\t}\n\n\tif (!strcmp(enable_arg, \"ENABLE\") ||\n\t    !strcmp(enable_arg, \"METHOD\") || !strcmp(enable_arg, \"OPCODE\")) {\n\t\tif (!strcmp(enable_arg, \"ENABLE\")) {\n\n\t\t\t \n\n\t\t\tdebug_level = acpi_gbl_db_console_debug_level;\n\t\t\tdebug_layer = acpi_dbg_layer;\n\t\t} else {\n\t\t\t \n\n\t\t\tdebug_level = ACPI_LV_TRACE_POINT;\n\t\t\tdebug_layer = ACPI_EXECUTER;\n\t\t}\n\n\t\tflags = ACPI_TRACE_ENABLED;\n\n\t\tif (!strcmp(enable_arg, \"OPCODE\")) {\n\t\t\tflags |= ACPI_TRACE_OPCODE;\n\t\t}\n\n\t\tif (once_arg && !strcmp(once_arg, \"ONCE\")) {\n\t\t\tflags |= ACPI_TRACE_ONESHOT;\n\t\t}\n\t}\n\n\t(void)acpi_debug_trace(acpi_db_trace_method_name,\n\t\t\t       debug_level, debug_layer, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}