{
  "module_name": "hwregs.c",
  "hash_id": "aa1c1864279df612a4665f2b535bf08e7a7b75199d8a7a5809e17df78e6b27ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/hwregs.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n\n#define _COMPONENT          ACPI_HARDWARE\nACPI_MODULE_NAME(\"hwregs\")\n\n#if (!ACPI_REDUCED_HARDWARE)\n \nstatic u8\nacpi_hw_get_access_bit_width(u64 address,\n\t\t\t     struct acpi_generic_address *reg,\n\t\t\t     u8 max_bit_width);\n\nstatic acpi_status\nacpi_hw_read_multiple(u32 *value,\n\t\t      struct acpi_generic_address *register_a,\n\t\t      struct acpi_generic_address *register_b);\n\nstatic acpi_status\nacpi_hw_write_multiple(u32 value,\n\t\t       struct acpi_generic_address *register_a,\n\t\t       struct acpi_generic_address *register_b);\n\n#endif\t\t\t\t \n\n \n\nstatic u8\nacpi_hw_get_access_bit_width(u64 address,\n\t\t\t     struct acpi_generic_address *reg, u8 max_bit_width)\n{\n\tu8 access_bit_width;\n\n\t \n\tif (!reg->bit_offset && reg->bit_width &&\n\t    ACPI_IS_POWER_OF_TWO(reg->bit_width) &&\n\t    ACPI_IS_ALIGNED(reg->bit_width, 8)) {\n\t\taccess_bit_width = reg->bit_width;\n\t} else if (reg->access_width) {\n\t\taccess_bit_width = ACPI_ACCESS_BIT_WIDTH(reg->access_width);\n\t} else {\n\t\taccess_bit_width =\n\t\t    ACPI_ROUND_UP_POWER_OF_TWO_8(reg->bit_offset +\n\t\t\t\t\t\t reg->bit_width);\n\t\tif (access_bit_width <= 8) {\n\t\t\taccess_bit_width = 8;\n\t\t} else {\n\t\t\twhile (!ACPI_IS_ALIGNED(address, access_bit_width >> 3)) {\n\t\t\t\taccess_bit_width >>= 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_IO) {\n\t\tmax_bit_width = 32;\n\t}\n\n\t \n\tif (access_bit_width < max_bit_width) {\n\t\treturn (access_bit_width);\n\t}\n\treturn (max_bit_width);\n}\n\n \n\nacpi_status\nacpi_hw_validate_register(struct acpi_generic_address *reg,\n\t\t\t  u8 max_bit_width, u64 *address)\n{\n\tu8 bit_width;\n\tu8 access_width;\n\n\t \n\n\tif (!reg) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\tACPI_MOVE_64_TO_64(address, &reg->address);\n\tif (!(*address)) {\n\t\treturn (AE_BAD_ADDRESS);\n\t}\n\n\t \n\n\tif ((reg->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) &&\n\t    (reg->space_id != ACPI_ADR_SPACE_SYSTEM_IO)) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Unsupported address space: 0x%X\", reg->space_id));\n\t\treturn (AE_SUPPORT);\n\t}\n\n\t \n\n\tif (reg->access_width > 4) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Unsupported register access width: 0x%X\",\n\t\t\t    reg->access_width));\n\t\treturn (AE_SUPPORT);\n\t}\n\n\t \n\n\taccess_width =\n\t    acpi_hw_get_access_bit_width(*address, reg, max_bit_width);\n\tbit_width =\n\t    ACPI_ROUND_UP(reg->bit_offset + reg->bit_width, access_width);\n\tif (max_bit_width < bit_width) {\n\t\tACPI_WARNING((AE_INFO,\n\t\t\t      \"Requested bit width 0x%X is smaller than register bit width 0x%X\",\n\t\t\t      max_bit_width, bit_width));\n\t\treturn (AE_SUPPORT);\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_hw_read(u64 *value, struct acpi_generic_address *reg)\n{\n\tu64 address;\n\tu8 access_width;\n\tu32 bit_width;\n\tu8 bit_offset;\n\tu64 value64;\n\tu32 value32;\n\tu8 index;\n\tacpi_status status;\n\n\tACPI_FUNCTION_NAME(hw_read);\n\n\t \n\n\tstatus = acpi_hw_validate_register(reg, 64, &address);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\t*value = 0;\n\taccess_width = acpi_hw_get_access_bit_width(address, reg, 64);\n\tbit_width = reg->bit_offset + reg->bit_width;\n\tbit_offset = reg->bit_offset;\n\n\t \n\tindex = 0;\n\twhile (bit_width) {\n\t\tif (bit_offset >= access_width) {\n\t\t\tvalue64 = 0;\n\t\t\tbit_offset -= access_width;\n\t\t} else {\n\t\t\tif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\n\t\t\t\tstatus =\n\t\t\t\t    acpi_os_read_memory((acpi_physical_address)\n\t\t\t\t\t\t\taddress +\n\t\t\t\t\t\t\tindex *\n\t\t\t\t\t\t\tACPI_DIV_8\n\t\t\t\t\t\t\t(access_width),\n\t\t\t\t\t\t\t&value64, access_width);\n\t\t\t} else {\t \n\n\t\t\t\tstatus = acpi_hw_read_port((acpi_io_address)\n\t\t\t\t\t\t\t   address +\n\t\t\t\t\t\t\t   index *\n\t\t\t\t\t\t\t   ACPI_DIV_8\n\t\t\t\t\t\t\t   (access_width),\n\t\t\t\t\t\t\t   &value32,\n\t\t\t\t\t\t\t   access_width);\n\t\t\t\tvalue64 = (u64)value32;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tACPI_SET_BITS(value, index * access_width,\n\t\t\t      ACPI_MASK_BITS_ABOVE_64(access_width), value64);\n\n\t\tbit_width -=\n\t\t    bit_width > access_width ? access_width : bit_width;\n\t\tindex++;\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_IO,\n\t\t\t  \"Read:  %8.8X%8.8X width %2d from %8.8X%8.8X (%s)\\n\",\n\t\t\t  ACPI_FORMAT_UINT64(*value), access_width,\n\t\t\t  ACPI_FORMAT_UINT64(address),\n\t\t\t  acpi_ut_get_region_name(reg->space_id)));\n\n\treturn (status);\n}\n\n \n\nacpi_status acpi_hw_write(u64 value, struct acpi_generic_address *reg)\n{\n\tu64 address;\n\tu8 access_width;\n\tu32 bit_width;\n\tu8 bit_offset;\n\tu64 value64;\n\tu8 index;\n\tacpi_status status;\n\n\tACPI_FUNCTION_NAME(hw_write);\n\n\t \n\n\tstatus = acpi_hw_validate_register(reg, 64, &address);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\taccess_width = acpi_hw_get_access_bit_width(address, reg, 64);\n\tbit_width = reg->bit_offset + reg->bit_width;\n\tbit_offset = reg->bit_offset;\n\n\t \n\tindex = 0;\n\twhile (bit_width) {\n\t\t \n\t\tvalue64 = ACPI_GET_BITS(&value, index * access_width,\n\t\t\t\t\tACPI_MASK_BITS_ABOVE_64(access_width));\n\n\t\tif (bit_offset >= access_width) {\n\t\t\tbit_offset -= access_width;\n\t\t} else {\n\t\t\tif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\n\t\t\t\tstatus =\n\t\t\t\t    acpi_os_write_memory((acpi_physical_address)\n\t\t\t\t\t\t\t address +\n\t\t\t\t\t\t\t index *\n\t\t\t\t\t\t\t ACPI_DIV_8\n\t\t\t\t\t\t\t (access_width),\n\t\t\t\t\t\t\t value64, access_width);\n\t\t\t} else {\t \n\n\t\t\t\tstatus = acpi_hw_write_port((acpi_io_address)\n\t\t\t\t\t\t\t    address +\n\t\t\t\t\t\t\t    index *\n\t\t\t\t\t\t\t    ACPI_DIV_8\n\t\t\t\t\t\t\t    (access_width),\n\t\t\t\t\t\t\t    (u32)value64,\n\t\t\t\t\t\t\t    access_width);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tbit_width -=\n\t\t    bit_width > access_width ? access_width : bit_width;\n\t\tindex++;\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_IO,\n\t\t\t  \"Wrote: %8.8X%8.8X width %2d   to %8.8X%8.8X (%s)\\n\",\n\t\t\t  ACPI_FORMAT_UINT64(value), access_width,\n\t\t\t  ACPI_FORMAT_UINT64(address),\n\t\t\t  acpi_ut_get_region_name(reg->space_id)));\n\n\treturn (status);\n}\n\n#if (!ACPI_REDUCED_HARDWARE)\n \n\nacpi_status acpi_hw_clear_acpi_status(void)\n{\n\tacpi_status status;\n\tacpi_cpu_flags lock_flags = 0;\n\n\tACPI_FUNCTION_TRACE(hw_clear_acpi_status);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_IO, \"About to write %04X to %8.8X%8.8X\\n\",\n\t\t\t  ACPI_BITMASK_ALL_FIXED_STATUS,\n\t\t\t  ACPI_FORMAT_UINT64(acpi_gbl_xpm1a_status.address)));\n\n\tlock_flags = acpi_os_acquire_raw_lock(acpi_gbl_hardware_lock);\n\n\t \n\n\tstatus = acpi_hw_register_write(ACPI_REGISTER_PM1_STATUS,\n\t\t\t\t\tACPI_BITMASK_ALL_FIXED_STATUS);\n\n\tacpi_os_release_raw_lock(acpi_gbl_hardware_lock, lock_flags);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\t \n\n\tstatus = acpi_ev_walk_gpe_list(acpi_hw_clear_gpe_block, NULL);\n\nexit:\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstruct acpi_bit_register_info *acpi_hw_get_bit_register_info(u32 register_id)\n{\n\tACPI_FUNCTION_ENTRY();\n\n\tif (register_id > ACPI_BITREG_MAX) {\n\t\tACPI_ERROR((AE_INFO, \"Invalid BitRegister ID: 0x%X\",\n\t\t\t    register_id));\n\t\treturn (NULL);\n\t}\n\n\treturn (&acpi_gbl_bit_register_info[register_id]);\n}\n\n \n\nacpi_status acpi_hw_write_pm1_control(u32 pm1a_control, u32 pm1b_control)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(hw_write_pm1_control);\n\n\tstatus =\n\t    acpi_hw_write(pm1a_control, &acpi_gbl_FADT.xpm1a_control_block);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tif (acpi_gbl_FADT.xpm1b_control_block.address) {\n\t\tstatus =\n\t\t    acpi_hw_write(pm1b_control,\n\t\t\t\t  &acpi_gbl_FADT.xpm1b_control_block);\n\t}\n\treturn_ACPI_STATUS(status);\n}\n\n \nacpi_status acpi_hw_register_read(u32 register_id, u32 *return_value)\n{\n\tu32 value = 0;\n\tu64 value64;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(hw_register_read);\n\n\tswitch (register_id) {\n\tcase ACPI_REGISTER_PM1_STATUS:\t \n\n\t\tstatus = acpi_hw_read_multiple(&value,\n\t\t\t\t\t       &acpi_gbl_xpm1a_status,\n\t\t\t\t\t       &acpi_gbl_xpm1b_status);\n\t\tbreak;\n\n\tcase ACPI_REGISTER_PM1_ENABLE:\t \n\n\t\tstatus = acpi_hw_read_multiple(&value,\n\t\t\t\t\t       &acpi_gbl_xpm1a_enable,\n\t\t\t\t\t       &acpi_gbl_xpm1b_enable);\n\t\tbreak;\n\n\tcase ACPI_REGISTER_PM1_CONTROL:\t \n\n\t\tstatus = acpi_hw_read_multiple(&value,\n\t\t\t\t\t       &acpi_gbl_FADT.\n\t\t\t\t\t       xpm1a_control_block,\n\t\t\t\t\t       &acpi_gbl_FADT.\n\t\t\t\t\t       xpm1b_control_block);\n\n\t\t \n\t\tvalue &= ~ACPI_PM1_CONTROL_WRITEONLY_BITS;\n\t\tbreak;\n\n\tcase ACPI_REGISTER_PM2_CONTROL:\t \n\n\t\tstatus =\n\t\t    acpi_hw_read(&value64, &acpi_gbl_FADT.xpm2_control_block);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tvalue = (u32)value64;\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_REGISTER_PM_TIMER:\t \n\n\t\tstatus = acpi_hw_read(&value64, &acpi_gbl_FADT.xpm_timer_block);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tvalue = (u32)value64;\n\t\t}\n\n\t\tbreak;\n\n\tcase ACPI_REGISTER_SMI_COMMAND_BLOCK:\t \n\n\t\tstatus =\n\t\t    acpi_hw_read_port(acpi_gbl_FADT.smi_command, &value, 8);\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"Unknown Register ID: 0x%X\", register_id));\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tbreak;\n\t}\n\n\tif (ACPI_SUCCESS(status)) {\n\t\t*return_value = (u32)value;\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_hw_register_write(u32 register_id, u32 value)\n{\n\tacpi_status status;\n\tu32 read_value;\n\tu64 read_value64;\n\n\tACPI_FUNCTION_TRACE(hw_register_write);\n\n\tswitch (register_id) {\n\tcase ACPI_REGISTER_PM1_STATUS:\t \n\t\t \n\t\tvalue &= ~ACPI_PM1_STATUS_PRESERVED_BITS;\n\n\t\tstatus = acpi_hw_write_multiple(value,\n\t\t\t\t\t\t&acpi_gbl_xpm1a_status,\n\t\t\t\t\t\t&acpi_gbl_xpm1b_status);\n\t\tbreak;\n\n\tcase ACPI_REGISTER_PM1_ENABLE:\t \n\n\t\tstatus = acpi_hw_write_multiple(value,\n\t\t\t\t\t\t&acpi_gbl_xpm1a_enable,\n\t\t\t\t\t\t&acpi_gbl_xpm1b_enable);\n\t\tbreak;\n\n\tcase ACPI_REGISTER_PM1_CONTROL:\t \n\t\t \n\t\tstatus = acpi_hw_read_multiple(&read_value,\n\t\t\t\t\t       &acpi_gbl_FADT.\n\t\t\t\t\t       xpm1a_control_block,\n\t\t\t\t\t       &acpi_gbl_FADT.\n\t\t\t\t\t       xpm1b_control_block);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\n\t\tACPI_INSERT_BITS(value, ACPI_PM1_CONTROL_PRESERVED_BITS,\n\t\t\t\t read_value);\n\n\t\t \n\n\t\tstatus = acpi_hw_write_multiple(value,\n\t\t\t\t\t\t&acpi_gbl_FADT.\n\t\t\t\t\t\txpm1a_control_block,\n\t\t\t\t\t\t&acpi_gbl_FADT.\n\t\t\t\t\t\txpm1b_control_block);\n\t\tbreak;\n\n\tcase ACPI_REGISTER_PM2_CONTROL:\t \n\t\t \n\t\tstatus =\n\t\t    acpi_hw_read(&read_value64,\n\t\t\t\t &acpi_gbl_FADT.xpm2_control_block);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto exit;\n\t\t}\n\t\tread_value = (u32)read_value64;\n\n\t\t \n\n\t\tACPI_INSERT_BITS(value, ACPI_PM2_CONTROL_PRESERVED_BITS,\n\t\t\t\t read_value);\n\n\t\tstatus =\n\t\t    acpi_hw_write(value, &acpi_gbl_FADT.xpm2_control_block);\n\t\tbreak;\n\n\tcase ACPI_REGISTER_PM_TIMER:\t \n\n\t\tstatus = acpi_hw_write(value, &acpi_gbl_FADT.xpm_timer_block);\n\t\tbreak;\n\n\tcase ACPI_REGISTER_SMI_COMMAND_BLOCK:\t \n\n\t\t \n\n\t\tstatus =\n\t\t    acpi_hw_write_port(acpi_gbl_FADT.smi_command, value, 8);\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"Unknown Register ID: 0x%X\", register_id));\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tbreak;\n\t}\n\nexit:\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic acpi_status\nacpi_hw_read_multiple(u32 *value,\n\t\t      struct acpi_generic_address *register_a,\n\t\t      struct acpi_generic_address *register_b)\n{\n\tu32 value_a = 0;\n\tu32 value_b = 0;\n\tu64 value64;\n\tacpi_status status;\n\n\t \n\n\tstatus = acpi_hw_read(&value64, register_a);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\tvalue_a = (u32)value64;\n\n\t \n\n\tif (register_b->address) {\n\t\tstatus = acpi_hw_read(&value64, register_b);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t\tvalue_b = (u32)value64;\n\t}\n\n\t \n\t*value = (value_a | value_b);\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_hw_write_multiple(u32 value,\n\t\t       struct acpi_generic_address *register_a,\n\t\t       struct acpi_generic_address *register_b)\n{\n\tacpi_status status;\n\n\t \n\n\tstatus = acpi_hw_write(value, register_a);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\tif (register_b->address) {\n\t\tstatus = acpi_hw_write(value, register_b);\n\t}\n\n\treturn (status);\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}