{
  "module_name": "hwvalid.c",
  "hash_id": "ae632bce6e581909d23e896fb8808e8e0c53351a012841b286d1ab65010c335c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/hwvalid.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n\n#define _COMPONENT          ACPI_HARDWARE\nACPI_MODULE_NAME(\"hwvalid\")\n\n \nstatic acpi_status\nacpi_hw_validate_io_request(acpi_io_address address, u32 bit_width);\n\n \nstatic const struct acpi_port_info acpi_protected_ports[] = {\n\t{\"DMA\", 0x0000, 0x000F, ACPI_OSI_WIN_XP},\n\t{\"PIC0\", 0x0020, 0x0021, ACPI_ALWAYS_ILLEGAL},\n\t{\"PIT1\", 0x0040, 0x0043, ACPI_OSI_WIN_XP},\n\t{\"PIT2\", 0x0048, 0x004B, ACPI_OSI_WIN_XP},\n\t{\"RTC\", 0x0070, 0x0071, ACPI_OSI_WIN_XP},\n\t{\"CMOS\", 0x0074, 0x0076, ACPI_OSI_WIN_XP},\n\t{\"DMA1\", 0x0081, 0x0083, ACPI_OSI_WIN_XP},\n\t{\"DMA1L\", 0x0087, 0x0087, ACPI_OSI_WIN_XP},\n\t{\"DMA2\", 0x0089, 0x008B, ACPI_OSI_WIN_XP},\n\t{\"DMA2L\", 0x008F, 0x008F, ACPI_OSI_WIN_XP},\n\t{\"ARBC\", 0x0090, 0x0091, ACPI_OSI_WIN_XP},\n\t{\"SETUP\", 0x0093, 0x0094, ACPI_OSI_WIN_XP},\n\t{\"POS\", 0x0096, 0x0097, ACPI_OSI_WIN_XP},\n\t{\"PIC1\", 0x00A0, 0x00A1, ACPI_ALWAYS_ILLEGAL},\n\t{\"IDMA\", 0x00C0, 0x00DF, ACPI_OSI_WIN_XP},\n\t{\"ELCR\", 0x04D0, 0x04D1, ACPI_ALWAYS_ILLEGAL},\n\t{\"PCI\", 0x0CF8, 0x0CFF, ACPI_OSI_WIN_XP}\n};\n\n#define ACPI_PORT_INFO_ENTRIES      ACPI_ARRAY_LENGTH (acpi_protected_ports)\n\n \n\nstatic acpi_status\nacpi_hw_validate_io_request(acpi_io_address address, u32 bit_width)\n{\n\tu32 i;\n\tu32 byte_width;\n\tacpi_io_address last_address;\n\tconst struct acpi_port_info *port_info;\n\n\tACPI_FUNCTION_TRACE(hw_validate_io_request);\n\n\t \n\n\tif ((bit_width != 8) && (bit_width != 16) && (bit_width != 32)) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Bad BitWidth parameter: %8.8X\", bit_width));\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tport_info = acpi_protected_ports;\n\tbyte_width = ACPI_DIV_8(bit_width);\n\tlast_address = address + byte_width - 1;\n\n\tACPI_DEBUG_PRINT((ACPI_DB_IO,\n\t\t\t  \"Address %8.8X%8.8X LastAddress %8.8X%8.8X Length %X\",\n\t\t\t  ACPI_FORMAT_UINT64(address),\n\t\t\t  ACPI_FORMAT_UINT64(last_address), byte_width));\n\n\t \n\n\tif (last_address > ACPI_UINT16_MAX) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Illegal I/O port address/length above 64K: %8.8X%8.8X/0x%X\",\n\t\t\t    ACPI_FORMAT_UINT64(address), byte_width));\n\t\treturn_ACPI_STATUS(AE_LIMIT);\n\t}\n\n\t \n\n\tif (address > acpi_protected_ports[ACPI_PORT_INFO_ENTRIES - 1].end) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tfor (i = 0; i < ACPI_PORT_INFO_ENTRIES; i++, port_info++) {\n\t\t \n\t\tif ((address <= port_info->end)\n\t\t    && (last_address >= port_info->start)) {\n\n\t\t\t \n\n\t\t\tif (port_info->osi_dependency == ACPI_ALWAYS_ILLEGAL ||\n\t\t\t    acpi_gbl_osi_data == port_info->osi_dependency) {\n\t\t\t\tACPI_DEBUG_PRINT((ACPI_DB_VALUES,\n\t\t\t\t\t\t  \"Denied AML access to port 0x%8.8X%8.8X/%X (%s 0x%.4X-0x%.4X)\\n\",\n\t\t\t\t\t\t  ACPI_FORMAT_UINT64(address),\n\t\t\t\t\t\t  byte_width, port_info->name,\n\t\t\t\t\t\t  port_info->start,\n\t\t\t\t\t\t  port_info->end));\n\n\t\t\t\treturn_ACPI_STATUS(AE_AML_ILLEGAL_ADDRESS);\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (last_address <= port_info->end) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status acpi_hw_read_port(acpi_io_address address, u32 *value, u32 width)\n{\n\tacpi_status status;\n\tu32 one_byte;\n\tu32 i;\n\n\t \n\n\tif (acpi_gbl_truncate_io_addresses) {\n\t\taddress &= ACPI_UINT16_MAX;\n\t}\n\n\t \n\n\tstatus = acpi_hw_validate_io_request(address, width);\n\tif (ACPI_SUCCESS(status)) {\n\t\tstatus = acpi_os_read_port(address, value, width);\n\t\treturn (status);\n\t}\n\n\tif (status != AE_AML_ILLEGAL_ADDRESS) {\n\t\treturn (status);\n\t}\n\n\t \n\tfor (i = 0, *value = 0; i < width; i += 8) {\n\n\t\t \n\n\t\tif (acpi_hw_validate_io_request(address, 8) == AE_OK) {\n\t\t\tstatus = acpi_os_read_port(address, &one_byte, 8);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn (status);\n\t\t\t}\n\n\t\t\t*value |= (one_byte << i);\n\t\t}\n\n\t\taddress++;\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_hw_write_port(acpi_io_address address, u32 value, u32 width)\n{\n\tacpi_status status;\n\tu32 i;\n\n\t \n\n\tif (acpi_gbl_truncate_io_addresses) {\n\t\taddress &= ACPI_UINT16_MAX;\n\t}\n\n\t \n\n\tstatus = acpi_hw_validate_io_request(address, width);\n\tif (ACPI_SUCCESS(status)) {\n\t\tstatus = acpi_os_write_port(address, value, width);\n\t\treturn (status);\n\t}\n\n\tif (status != AE_AML_ILLEGAL_ADDRESS) {\n\t\treturn (status);\n\t}\n\n\t \n\tfor (i = 0; i < width; i += 8) {\n\n\t\t \n\n\t\tif (acpi_hw_validate_io_request(address, 8) == AE_OK) {\n\t\t\tstatus =\n\t\t\t    acpi_os_write_port(address, (value >> i) & 0xFF, 8);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn (status);\n\t\t\t}\n\t\t}\n\n\t\taddress++;\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_hw_validate_io_block(u64 address, u32 bit_width, u32 count)\n{\n\tacpi_status status;\n\n\twhile (count--) {\n\t\tstatus = acpi_hw_validate_io_request((acpi_io_address)address,\n\t\t\t\t\t\t     bit_width);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn_ACPI_STATUS(status);\n\n\t\taddress += ACPI_DIV_8(bit_width);\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}