{
  "module_name": "exoparg1.c",
  "hash_id": "6937d79e29af023ef1e49ee72ff8fb0bb7e743d28d753729e55707f27069891a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/exoparg1.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acparser.h\"\n#include \"acdispat.h\"\n#include \"acinterp.h\"\n#include \"amlcode.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_EXECUTER\nACPI_MODULE_NAME(\"exoparg1\")\n\n \n \nacpi_status acpi_ex_opcode_0A_0T_1R(struct acpi_walk_state *walk_state)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_operand_object *return_desc = NULL;\n\n\tACPI_FUNCTION_TRACE_STR(ex_opcode_0A_0T_1R,\n\t\t\t\tacpi_ps_get_opcode_name(walk_state->opcode));\n\n\t \n\n\tswitch (walk_state->opcode) {\n\tcase AML_TIMER_OP:\t \n\n\t\t \n\n\t\treturn_desc =\n\t\t    acpi_ut_create_integer_object(acpi_os_get_timer());\n\t\tif (!return_desc) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\n\tdefault:\t\t \n\n\t\tACPI_ERROR((AE_INFO, \"Unknown AML opcode 0x%X\",\n\t\t\t    walk_state->opcode));\n\t\tstatus = AE_AML_BAD_OPCODE;\n\t\tbreak;\n\t}\n\ncleanup:\n\n\t \n\n\tif ((ACPI_FAILURE(status)) || walk_state->result_obj) {\n\t\tacpi_ut_remove_reference(return_desc);\n\t\twalk_state->result_obj = NULL;\n\t} else {\n\t\t \n\n\t\twalk_state->result_obj = return_desc;\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ex_opcode_1A_0T_0R(struct acpi_walk_state *walk_state)\n{\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE_STR(ex_opcode_1A_0T_0R,\n\t\t\t\tacpi_ps_get_opcode_name(walk_state->opcode));\n\n\t \n\n\tswitch (walk_state->opcode) {\n\tcase AML_RELEASE_OP:\t \n\n\t\tstatus = acpi_ex_release_mutex(operand[0], walk_state);\n\t\tbreak;\n\n\tcase AML_RESET_OP:\t \n\n\t\tstatus = acpi_ex_system_reset_event(operand[0]);\n\t\tbreak;\n\n\tcase AML_SIGNAL_OP:\t \n\n\t\tstatus = acpi_ex_system_signal_event(operand[0]);\n\t\tbreak;\n\n\tcase AML_SLEEP_OP:\t \n\n\t\tstatus = acpi_ex_system_do_sleep(operand[0]->integer.value);\n\t\tbreak;\n\n\tcase AML_STALL_OP:\t \n\n\t\tstatus =\n\t\t    acpi_ex_system_do_stall((u32) operand[0]->integer.value);\n\t\tbreak;\n\n\tcase AML_UNLOAD_OP:\t \n\n\t\tstatus = acpi_ex_unload_table(operand[0]);\n\t\tbreak;\n\n\tdefault:\t\t \n\n\t\tACPI_ERROR((AE_INFO, \"Unknown AML opcode 0x%X\",\n\t\t\t    walk_state->opcode));\n\t\tstatus = AE_AML_BAD_OPCODE;\n\t\tbreak;\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n#ifdef _OBSOLETE_CODE\t\t \n \n\nacpi_status acpi_ex_opcode_1A_1T_0R(struct acpi_walk_state *walk_state)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\n\tACPI_FUNCTION_TRACE_STR(ex_opcode_1A_1T_0R,\n\t\t\t\tacpi_ps_get_opcode_name(walk_state->opcode));\n\n\t \n\n\tswitch (walk_state->opcode) {\n#ifdef _OBSOLETE_CODE\n\tcase AML_LOAD_OP:\n\n\t\tstatus = acpi_ex_load_op(operand[0], operand[1], walk_state);\n\t\tbreak;\n#endif\n\n\tdefault:\t\t \n\n\t\tACPI_ERROR((AE_INFO, \"Unknown AML opcode 0x%X\",\n\t\t\t    walk_state->opcode));\n\t\tstatus = AE_AML_BAD_OPCODE;\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\n\treturn_ACPI_STATUS(status);\n}\n#endif\n\n \n\nacpi_status acpi_ex_opcode_1A_1T_1R(struct acpi_walk_state *walk_state)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\tunion acpi_operand_object *return_desc = NULL;\n\tunion acpi_operand_object *return_desc2 = NULL;\n\tu32 temp32;\n\tu32 i;\n\tu64 power_of_ten;\n\tu64 digit;\n\n\tACPI_FUNCTION_TRACE_STR(ex_opcode_1A_1T_1R,\n\t\t\t\tacpi_ps_get_opcode_name(walk_state->opcode));\n\n\t \n\n\tswitch (walk_state->opcode) {\n\tcase AML_BIT_NOT_OP:\n\tcase AML_FIND_SET_LEFT_BIT_OP:\n\tcase AML_FIND_SET_RIGHT_BIT_OP:\n\tcase AML_FROM_BCD_OP:\n\tcase AML_LOAD_OP:\n\tcase AML_TO_BCD_OP:\n\tcase AML_CONDITIONAL_REF_OF_OP:\n\n\t\t \n\n\t\treturn_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);\n\t\tif (!return_desc) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tswitch (walk_state->opcode) {\n\t\tcase AML_BIT_NOT_OP:\t \n\n\t\t\treturn_desc->integer.value = ~operand[0]->integer.value;\n\t\t\tbreak;\n\n\t\tcase AML_FIND_SET_LEFT_BIT_OP:\t \n\n\t\t\treturn_desc->integer.value = operand[0]->integer.value;\n\n\t\t\t \n\t\t\tfor (temp32 = 0; return_desc->integer.value &&\n\t\t\t     temp32 < ACPI_INTEGER_BIT_SIZE; ++temp32) {\n\t\t\t\treturn_desc->integer.value >>= 1;\n\t\t\t}\n\n\t\t\treturn_desc->integer.value = temp32;\n\t\t\tbreak;\n\n\t\tcase AML_FIND_SET_RIGHT_BIT_OP:\t \n\n\t\t\treturn_desc->integer.value = operand[0]->integer.value;\n\n\t\t\t \n\t\t\tfor (temp32 = 0; return_desc->integer.value &&\n\t\t\t     temp32 < ACPI_INTEGER_BIT_SIZE; ++temp32) {\n\t\t\t\treturn_desc->integer.value <<= 1;\n\t\t\t}\n\n\t\t\t \n\n\t\t\treturn_desc->integer.value =\n\t\t\t    temp32 ==\n\t\t\t    0 ? 0 : (ACPI_INTEGER_BIT_SIZE + 1) - temp32;\n\t\t\tbreak;\n\n\t\tcase AML_FROM_BCD_OP:\t \n\t\t\t \n\t\t\tpower_of_ten = 1;\n\t\t\treturn_desc->integer.value = 0;\n\t\t\tdigit = operand[0]->integer.value;\n\n\t\t\t \n\n\t\t\tfor (i = 0;\n\t\t\t     (i < acpi_gbl_integer_nybble_width) && (digit > 0);\n\t\t\t     i++) {\n\n\t\t\t\t \n\n\t\t\t\ttemp32 = ((u32) digit) & 0xF;\n\n\t\t\t\t \n\n\t\t\t\tif (temp32 > 9) {\n\t\t\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t\t\t    \"BCD digit too large (not decimal): 0x%X\",\n\t\t\t\t\t\t    temp32));\n\n\t\t\t\t\tstatus = AE_AML_NUMERIC_OVERFLOW;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\t \n\n\t\t\t\treturn_desc->integer.value +=\n\t\t\t\t    (((u64) temp32) * power_of_ten);\n\n\t\t\t\t \n\n\t\t\t\tdigit >>= 4;\n\n\t\t\t\t \n\n\t\t\t\tpower_of_ten *= 10;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AML_LOAD_OP:\t \n\n\t\t\treturn_desc->integer.value = 0;\n\t\t\tstatus =\n\t\t\t    acpi_ex_load_op(operand[0], return_desc,\n\t\t\t\t\t    walk_state);\n\t\t\tif (ACPI_SUCCESS(status)) {\n\n\t\t\t\t \n\n\t\t\t\treturn_desc->integer.value = 0xFFFFFFFFFFFFFFFF;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AML_TO_BCD_OP:\t \n\n\t\t\treturn_desc->integer.value = 0;\n\t\t\tdigit = operand[0]->integer.value;\n\n\t\t\t \n\n\t\t\tfor (i = 0;\n\t\t\t     (i < acpi_gbl_integer_nybble_width) && (digit > 0);\n\t\t\t     i++) {\n\t\t\t\t(void)acpi_ut_short_divide(digit, 10, &digit,\n\t\t\t\t\t\t\t   &temp32);\n\n\t\t\t\t \n\t\t\t\treturn_desc->integer.value |=\n\t\t\t\t    (((u64) temp32) << ACPI_MUL_4(i));\n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (digit > 0) {\n\t\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t\t    \"Integer too large to convert to BCD: 0x%8.8X%8.8X\",\n\t\t\t\t\t    ACPI_FORMAT_UINT64(operand[0]->\n\t\t\t\t\t\t\t       integer.value)));\n\t\t\t\tstatus = AE_AML_NUMERIC_OVERFLOW;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AML_CONDITIONAL_REF_OF_OP:\t \n\t\t\t \n\t\t\tif ((struct acpi_namespace_node *)operand[0] ==\n\t\t\t    acpi_gbl_root_node) {\n\t\t\t\t \n\t\t\t\treturn_desc->integer.value = 0;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tstatus = acpi_ex_get_object_reference(operand[0],\n\t\t\t\t\t\t\t      &return_desc2,\n\t\t\t\t\t\t\t      walk_state);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tstatus =\n\t\t\t    acpi_ex_store(return_desc2, operand[1], walk_state);\n\t\t\tacpi_ut_remove_reference(return_desc2);\n\n\t\t\t \n\n\t\t\treturn_desc->integer.value = ACPI_UINT64_MAX;\n\t\t\tgoto cleanup;\n\n\t\tdefault:\n\n\t\t\t \n\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase AML_STORE_OP:\t \n\t\t \n\t\tstatus = acpi_ex_store(operand[0], operand[1], walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\t \n\n\t\tif (!walk_state->result_obj) {\n\t\t\t \n\t\t\twalk_state->result_obj = operand[0];\n\t\t\twalk_state->operands[0] = NULL;\t \n\t\t}\n\t\treturn_ACPI_STATUS(status);\n\n\t\t \n\tcase AML_COPY_OBJECT_OP:\t \n\n\t\tstatus =\n\t\t    acpi_ut_copy_iobject_to_iobject(operand[0], &return_desc,\n\t\t\t\t\t\t    walk_state);\n\t\tbreak;\n\n\tcase AML_TO_DECIMAL_STRING_OP:\t \n\n\t\tstatus =\n\t\t    acpi_ex_convert_to_string(operand[0], &return_desc,\n\t\t\t\t\t      ACPI_EXPLICIT_CONVERT_DECIMAL);\n\t\tif (return_desc == operand[0]) {\n\n\t\t\t \n\n\t\t\tacpi_ut_add_reference(return_desc);\n\t\t}\n\t\tbreak;\n\n\tcase AML_TO_HEX_STRING_OP:\t \n\n\t\tstatus =\n\t\t    acpi_ex_convert_to_string(operand[0], &return_desc,\n\t\t\t\t\t      ACPI_EXPLICIT_CONVERT_HEX);\n\t\tif (return_desc == operand[0]) {\n\n\t\t\t \n\n\t\t\tacpi_ut_add_reference(return_desc);\n\t\t}\n\t\tbreak;\n\n\tcase AML_TO_BUFFER_OP:\t \n\n\t\tstatus = acpi_ex_convert_to_buffer(operand[0], &return_desc);\n\t\tif (return_desc == operand[0]) {\n\n\t\t\t \n\n\t\t\tacpi_ut_add_reference(return_desc);\n\t\t}\n\t\tbreak;\n\n\tcase AML_TO_INTEGER_OP:\t \n\n\t\t \n\n\t\tstatus =\n\t\t    acpi_ex_convert_to_integer(operand[0], &return_desc, 0);\n\t\tif (return_desc == operand[0]) {\n\n\t\t\t \n\n\t\t\tacpi_ut_add_reference(return_desc);\n\t\t}\n\t\tbreak;\n\n\tcase AML_SHIFT_LEFT_BIT_OP:\t \n\tcase AML_SHIFT_RIGHT_BIT_OP:\t \n\n\t\t \n\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"%s is obsolete and not implemented\",\n\t\t\t    acpi_ps_get_opcode_name(walk_state->opcode)));\n\t\tstatus = AE_SUPPORT;\n\t\tgoto cleanup;\n\n\tdefault:\t\t \n\n\t\tACPI_ERROR((AE_INFO, \"Unknown AML opcode 0x%X\",\n\t\t\t    walk_state->opcode));\n\t\tstatus = AE_AML_BAD_OPCODE;\n\t\tgoto cleanup;\n\t}\n\n\tif (ACPI_SUCCESS(status)) {\n\n\t\t \n\n\t\tstatus = acpi_ex_store(return_desc, operand[1], walk_state);\n\t}\n\ncleanup:\n\n\t \n\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ut_remove_reference(return_desc);\n\t}\n\n\t \n\n\telse if (!walk_state->result_obj) {\n\t\twalk_state->result_obj = return_desc;\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ex_opcode_1A_0T_1R(struct acpi_walk_state *walk_state)\n{\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\tunion acpi_operand_object *temp_desc;\n\tunion acpi_operand_object *return_desc = NULL;\n\tacpi_status status = AE_OK;\n\tu32 type;\n\tu64 value;\n\n\tACPI_FUNCTION_TRACE_STR(ex_opcode_1A_0T_1R,\n\t\t\t\tacpi_ps_get_opcode_name(walk_state->opcode));\n\n\t \n\n\tswitch (walk_state->opcode) {\n\tcase AML_LOGICAL_NOT_OP:\t \n\n\t\treturn_desc = acpi_ut_create_integer_object((u64) 0);\n\t\tif (!return_desc) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\tif (!operand[0]->integer.value) {\n\t\t\treturn_desc->integer.value = ACPI_UINT64_MAX;\n\t\t}\n\t\tbreak;\n\n\tcase AML_DECREMENT_OP:\t \n\tcase AML_INCREMENT_OP:\t \n\t\t \n\t\treturn_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);\n\t\tif (!return_desc) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\ttemp_desc = operand[0];\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(temp_desc) ==\n\t\t    ACPI_DESC_TYPE_OPERAND) {\n\n\t\t\t \n\n\t\t\tacpi_ut_add_reference(temp_desc);\n\t\t}\n\n\t\t \n\t\tstatus = acpi_ex_resolve_operands(AML_LOGICAL_NOT_OP,\n\t\t\t\t\t\t  &temp_desc, walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\"While resolving operands for [%s]\",\n\t\t\t\t\tacpi_ps_get_opcode_name(walk_state->\n\t\t\t\t\t\t\t\topcode)));\n\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\tif (walk_state->opcode == AML_INCREMENT_OP) {\n\t\t\treturn_desc->integer.value =\n\t\t\t    temp_desc->integer.value + 1;\n\t\t} else {\n\t\t\treturn_desc->integer.value =\n\t\t\t    temp_desc->integer.value - 1;\n\t\t}\n\n\t\t \n\n\t\tacpi_ut_remove_reference(temp_desc);\n\n\t\t \n\t\tstatus = acpi_ex_store(return_desc, operand[0], walk_state);\n\t\tbreak;\n\n\tcase AML_OBJECT_TYPE_OP:\t \n\t\t \n\n\t\t \n\n\t\tstatus =\n\t\t    acpi_ex_resolve_multiple(walk_state, operand[0], &type,\n\t\t\t\t\t     NULL);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\n\t\treturn_desc = acpi_ut_create_integer_object((u64) type);\n\t\tif (!return_desc) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\n\tcase AML_SIZE_OF_OP:\t \n\t\t \n\n\t\t \n\n\t\tstatus =\n\t\t    acpi_ex_resolve_multiple(walk_state, operand[0], &type,\n\t\t\t\t\t     &temp_desc);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\tswitch (type) {\n\t\tcase ACPI_TYPE_INTEGER:\n\n\t\t\tvalue = acpi_gbl_integer_byte_width;\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_STRING:\n\n\t\t\tvalue = temp_desc->string.length;\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_BUFFER:\n\n\t\t\t \n\n\t\t\tstatus = acpi_ds_get_buffer_arguments(temp_desc);\n\t\t\tvalue = temp_desc->buffer.length;\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_PACKAGE:\n\n\t\t\t \n\n\t\t\tstatus = acpi_ds_get_package_arguments(temp_desc);\n\t\t\tvalue = temp_desc->package.count;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Operand must be Buffer/Integer/String/Package\"\n\t\t\t\t    \" - found type %s\",\n\t\t\t\t    acpi_ut_get_type_name(type)));\n\n\t\t\tstatus = AE_AML_OPERAND_TYPE;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\treturn_desc = acpi_ut_create_integer_object(value);\n\t\tif (!return_desc) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\n\tcase AML_REF_OF_OP:\t \n\n\t\tstatus =\n\t\t    acpi_ex_get_object_reference(operand[0], &return_desc,\n\t\t\t\t\t\t walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\n\tcase AML_DEREF_OF_OP:\t \n\n\t\t \n\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(operand[0]) ==\n\t\t    ACPI_DESC_TYPE_NAMED) {\n\t\t\ttemp_desc =\n\t\t\t    acpi_ns_get_attached_object((struct\n\t\t\t\t\t\t\t acpi_namespace_node *)\n\t\t\t\t\t\t\toperand[0]);\n\t\t\tif (temp_desc\n\t\t\t    && ((temp_desc->common.type == ACPI_TYPE_STRING)\n\t\t\t\t|| (temp_desc->common.type ==\n\t\t\t\t    ACPI_TYPE_LOCAL_REFERENCE))) {\n\t\t\t\toperand[0] = temp_desc;\n\t\t\t\tacpi_ut_add_reference(temp_desc);\n\t\t\t} else {\n\t\t\t\tstatus = AE_AML_OPERAND_TYPE;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch ((operand[0])->common.type) {\n\t\t\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\t\t\t\t \n\t\t\t\tswitch (operand[0]->reference.class) {\n\t\t\t\tcase ACPI_REFCLASS_LOCAL:\n\t\t\t\tcase ACPI_REFCLASS_ARG:\n\n\t\t\t\t\t \n\n\t\t\t\t\tstatus =\n\t\t\t\t\t    acpi_ds_method_data_get_value\n\t\t\t\t\t    (operand[0]->reference.class,\n\t\t\t\t\t     operand[0]->reference.value,\n\t\t\t\t\t     walk_state, &temp_desc);\n\t\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tacpi_ut_remove_reference(operand[0]);\n\t\t\t\t\toperand[0] = temp_desc;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACPI_REFCLASS_REFOF:\n\n\t\t\t\t\t \n\n\t\t\t\t\ttemp_desc =\n\t\t\t\t\t    operand[0]->reference.object;\n\t\t\t\t\tacpi_ut_remove_reference(operand[0]);\n\t\t\t\t\toperand[0] = temp_desc;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ACPI_TYPE_STRING:\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstatus = AE_AML_OPERAND_TYPE;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(operand[0]) !=\n\t\t    ACPI_DESC_TYPE_NAMED) {\n\t\t\tif ((operand[0])->common.type == ACPI_TYPE_STRING) {\n\t\t\t\t \n\t\t\t\tstatus =\n\t\t\t\t    acpi_ns_get_node_unlocked(walk_state->\n\t\t\t\t\t\t\t      scope_info->scope.\n\t\t\t\t\t\t\t      node,\n\t\t\t\t\t\t\t      operand[0]->\n\t\t\t\t\t\t\t      string.pointer,\n\t\t\t\t\t\t\t      ACPI_NS_SEARCH_PARENT,\n\t\t\t\t\t\t\t      ACPI_CAST_INDIRECT_PTR\n\t\t\t\t\t\t\t      (struct\n\t\t\t\t\t\t\t       acpi_namespace_node,\n\t\t\t\t\t\t\t       &return_desc));\n\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\tstatus =\n\t\t\t\t    acpi_ex_resolve_node_to_value\n\t\t\t\t    (ACPI_CAST_INDIRECT_PTR\n\t\t\t\t     (struct acpi_namespace_node, &return_desc),\n\t\t\t\t     walk_state);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(operand[0]) ==\n\t\t    ACPI_DESC_TYPE_NAMED) {\n\t\t\t \n\t\t\tswitch (((struct acpi_namespace_node *)operand[0])->\n\t\t\t\ttype) {\n\t\t\tcase ACPI_TYPE_DEVICE:\n\t\t\tcase ACPI_TYPE_THERMAL:\n\n\t\t\t\t \n\n\t\t\t\treturn_desc = operand[0];\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t \n\n\t\t\t\treturn_desc = acpi_ns_get_attached_object((struct acpi_namespace_node *)operand[0]);\n\t\t\t\tacpi_ut_add_reference(return_desc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tswitch (operand[0]->reference.class) {\n\t\t\tcase ACPI_REFCLASS_INDEX:\n\t\t\t\t \n\t\t\t\tswitch (operand[0]->reference.target_type) {\n\t\t\t\tcase ACPI_TYPE_BUFFER_FIELD:\n\n\t\t\t\t\ttemp_desc =\n\t\t\t\t\t    operand[0]->reference.object;\n\n\t\t\t\t\t \n\t\t\t\t\treturn_desc =\n\t\t\t\t\t    acpi_ut_create_integer_object((u64)\n\t\t\t\t\t\t\t\t\t  temp_desc->buffer.pointer[operand[0]->reference.value]);\n\t\t\t\t\tif (!return_desc) {\n\t\t\t\t\t\tstatus = AE_NO_MEMORY;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACPI_TYPE_PACKAGE:\n\t\t\t\t\t \n\t\t\t\t\treturn_desc =\n\t\t\t\t\t    *(operand[0]->reference.where);\n\t\t\t\t\tif (!return_desc) {\n\t\t\t\t\t\t \n\t\t\t\t\t\treturn_ACPI_STATUS\n\t\t\t\t\t\t    (AE_AML_UNINITIALIZED_ELEMENT);\n\t\t\t\t\t}\n\n\t\t\t\t\tacpi_ut_add_reference(return_desc);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t\t\t    \"Unknown Index TargetType 0x%X in reference object %p\",\n\t\t\t\t\t\t    operand[0]->reference.\n\t\t\t\t\t\t    target_type, operand[0]));\n\n\t\t\t\t\tstatus = AE_AML_OPERAND_TYPE;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ACPI_REFCLASS_REFOF:\n\n\t\t\t\treturn_desc = operand[0]->reference.object;\n\n\t\t\t\tif (ACPI_GET_DESCRIPTOR_TYPE(return_desc) ==\n\t\t\t\t    ACPI_DESC_TYPE_NAMED) {\n\t\t\t\t\treturn_desc =\n\t\t\t\t\t    acpi_ns_get_attached_object((struct\n\t\t\t\t\t\t\t\t\t acpi_namespace_node\n\t\t\t\t\t\t\t\t\t *)\n\t\t\t\t\t\t\t\t\treturn_desc);\n\t\t\t\t\tif (!return_desc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tswitch (return_desc->common.type) {\n\t\t\t\t\tcase ACPI_TYPE_BUFFER_FIELD:\n\t\t\t\t\tcase ACPI_TYPE_LOCAL_REGION_FIELD:\n\t\t\t\t\tcase ACPI_TYPE_LOCAL_BANK_FIELD:\n\t\t\t\t\tcase ACPI_TYPE_LOCAL_INDEX_FIELD:\n\n\t\t\t\t\t\tstatus =\n\t\t\t\t\t\t    acpi_ex_read_data_from_field\n\t\t\t\t\t\t    (walk_state, return_desc,\n\t\t\t\t\t\t     &temp_desc);\n\t\t\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\t\t\treturn_ACPI_STATUS\n\t\t\t\t\t\t\t    (status);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn_desc = temp_desc;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t \n\n\t\t\t\t\t\tacpi_ut_add_reference\n\t\t\t\t\t\t    (return_desc);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t\t    \"Unknown class in reference(%p) - 0x%2.2X\",\n\t\t\t\t\t    operand[0],\n\t\t\t\t\t    operand[0]->reference.class));\n\n\t\t\t\tstatus = AE_TYPE;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"Unknown AML opcode 0x%X\",\n\t\t\t    walk_state->opcode));\n\n\t\tstatus = AE_AML_BAD_OPCODE;\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\n\t \n\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ut_remove_reference(return_desc);\n\t}\n\n\t \n\n\telse {\n\t\twalk_state->result_obj = return_desc;\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}