{
  "module_name": "nsalloc.c",
  "hash_id": "3ec19bba462881e88cf8587303c530169ce5de915750b093a31478771cfd5d74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/nsalloc.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\nACPI_MODULE_NAME(\"nsalloc\")\n\n \nstruct acpi_namespace_node *acpi_ns_create_node(u32 name)\n{\n\tstruct acpi_namespace_node *node;\n#ifdef ACPI_DBG_TRACK_ALLOCATIONS\n\tu32 temp;\n#endif\n\n\tACPI_FUNCTION_TRACE(ns_create_node);\n\n\tnode = acpi_os_acquire_object(acpi_gbl_namespace_cache);\n\tif (!node) {\n\t\treturn_PTR(NULL);\n\t}\n\n\tACPI_MEM_TRACKING(acpi_gbl_ns_node_list->total_allocated++);\n\n#ifdef ACPI_DBG_TRACK_ALLOCATIONS\n\ttemp = acpi_gbl_ns_node_list->total_allocated -\n\t    acpi_gbl_ns_node_list->total_freed;\n\tif (temp > acpi_gbl_ns_node_list->max_occupied) {\n\t\tacpi_gbl_ns_node_list->max_occupied = temp;\n\t}\n#endif\n\n\tnode->name.integer = name;\n\tACPI_SET_DESCRIPTOR_TYPE(node, ACPI_DESC_TYPE_NAMED);\n\treturn_PTR(node);\n}\n\n \n\nvoid acpi_ns_delete_node(struct acpi_namespace_node *node)\n{\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_operand_object *next_desc;\n\n\tACPI_FUNCTION_NAME(ns_delete_node);\n\n\tif (!node) {\n\t\treturn_VOID;\n\t}\n\n\t \n\n\tacpi_ns_detach_object(node);\n\n\t \n\tobj_desc = node->object;\n\twhile (obj_desc && (obj_desc->common.type == ACPI_TYPE_LOCAL_DATA)) {\n\n\t\t \n\n\t\tif (obj_desc->data.handler) {\n\t\t\tobj_desc->data.handler(node, obj_desc->data.pointer);\n\t\t}\n\n\t\tnext_desc = obj_desc->common.next_object;\n\t\tacpi_ut_remove_reference(obj_desc);\n\t\tobj_desc = next_desc;\n\t}\n\n\t \n\n\tif (node == acpi_gbl_root_node) {\n\t\treturn;\n\t}\n\n\t \n\n\t(void)acpi_os_release_object(acpi_gbl_namespace_cache, node);\n\n\tACPI_MEM_TRACKING(acpi_gbl_ns_node_list->total_freed++);\n\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, \"Node %p, Remaining %X\\n\",\n\t\t\t  node, acpi_gbl_current_node_count));\n}\n\n \n\nvoid acpi_ns_remove_node(struct acpi_namespace_node *node)\n{\n\tstruct acpi_namespace_node *parent_node;\n\tstruct acpi_namespace_node *prev_node;\n\tstruct acpi_namespace_node *next_node;\n\n\tACPI_FUNCTION_TRACE_PTR(ns_remove_node, node);\n\n\tparent_node = node->parent;\n\n\tprev_node = NULL;\n\tnext_node = parent_node->child;\n\n\t \n\n\twhile (next_node != node) {\n\t\tprev_node = next_node;\n\t\tnext_node = next_node->peer;\n\t}\n\n\tif (prev_node) {\n\n\t\t \n\n\t\tprev_node->peer = node->peer;\n\t} else {\n\t\t \n\t\tparent_node->child = node->peer;\n\t}\n\n\t \n\n\tacpi_ns_delete_node(node);\n\treturn_VOID;\n}\n\n \n\nvoid acpi_ns_install_node(struct acpi_walk_state *walk_state, struct acpi_namespace_node *parent_node,\t \n\t\t\t  struct acpi_namespace_node *node,\t \n\t\t\t  acpi_object_type type)\n{\n\tacpi_owner_id owner_id = 0;\n\tstruct acpi_namespace_node *child_node;\n\n\tACPI_FUNCTION_TRACE(ns_install_node);\n\n\tif (walk_state) {\n\t\t \n\t\towner_id = walk_state->owner_id;\n\n\t\tif ((walk_state->method_desc) &&\n\t\t    (parent_node != walk_state->method_node)) {\n\t\t\t \n\t\t\twalk_state->method_desc->method.info_flags |=\n\t\t\t    ACPI_METHOD_MODIFIED_NAMESPACE;\n\t\t}\n\t}\n\n\t \n\n\tnode->peer = NULL;\n\tnode->parent = parent_node;\n\tchild_node = parent_node->child;\n\n\tif (!child_node) {\n\t\tparent_node->child = node;\n\t} else {\n\t\t \n\n\t\twhile (child_node->peer) {\n\t\t\tchild_node = child_node->peer;\n\t\t}\n\n\t\tchild_node->peer = node;\n\t}\n\n\t \n\n\tnode->owner_id = owner_id;\n\tnode->type = (u8) type;\n\n\tACPI_DEBUG_PRINT((ACPI_DB_NAMES,\n\t\t\t  \"%4.4s (%s) [Node %p Owner %3.3X] added to %4.4s (%s) [Node %p]\\n\",\n\t\t\t  acpi_ut_get_node_name(node),\n\t\t\t  acpi_ut_get_type_name(node->type), node, owner_id,\n\t\t\t  acpi_ut_get_node_name(parent_node),\n\t\t\t  acpi_ut_get_type_name(parent_node->type),\n\t\t\t  parent_node));\n\n\treturn_VOID;\n}\n\n \n\nvoid acpi_ns_delete_children(struct acpi_namespace_node *parent_node)\n{\n\tstruct acpi_namespace_node *next_node;\n\tstruct acpi_namespace_node *node_to_delete;\n\n\tACPI_FUNCTION_TRACE_PTR(ns_delete_children, parent_node);\n\n\tif (!parent_node) {\n\t\treturn_VOID;\n\t}\n\n\t \n\n\tnext_node = parent_node->child;\n\twhile (next_node) {\n\n\t\t \n\n\t\tif (next_node->child) {\n\t\t\tACPI_ERROR((AE_INFO, \"Found a grandchild! P=%p C=%p\",\n\t\t\t\t    parent_node, next_node));\n\t\t}\n\n\t\t \n\t\tnode_to_delete = next_node;\n\t\tnext_node = next_node->peer;\n\t\tacpi_ns_delete_node(node_to_delete);\n\t}\n\n\t \n\n\tparent_node->child = NULL;\n\treturn_VOID;\n}\n\n \n\nvoid acpi_ns_delete_namespace_subtree(struct acpi_namespace_node *parent_node)\n{\n\tstruct acpi_namespace_node *child_node = NULL;\n\tu32 level = 1;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ns_delete_namespace_subtree);\n\n\tif (!parent_node) {\n\t\treturn_VOID;\n\t}\n\n\t \n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_VOID;\n\t}\n\n\t \n\twhile (level > 0) {\n\n\t\t \n\n\t\tchild_node = acpi_ns_get_next_node(parent_node, child_node);\n\t\tif (child_node) {\n\n\t\t\t \n\n\t\t\tacpi_ns_detach_object(child_node);\n\n\t\t\t \n\n\t\t\tif (child_node->child) {\n\t\t\t\t \n\t\t\t\tlevel++;\n\t\t\t\tparent_node = child_node;\n\t\t\t\tchild_node = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tlevel--;\n\n\t\t\t \n\t\t\tacpi_ns_delete_children(parent_node);\n\n\t\t\t \n\n\t\t\tchild_node = parent_node;\n\n\t\t\t \n\n\t\t\tparent_node = parent_node->parent;\n\t\t}\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_VOID;\n}\n\n \n\nvoid acpi_ns_delete_namespace_by_owner(acpi_owner_id owner_id)\n{\n\tstruct acpi_namespace_node *child_node;\n\tstruct acpi_namespace_node *deletion_node;\n\tstruct acpi_namespace_node *parent_node;\n\tu32 level;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE_U32(ns_delete_namespace_by_owner, owner_id);\n\n\tif (owner_id == 0) {\n\t\treturn_VOID;\n\t}\n\n\t \n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_VOID;\n\t}\n\n\tdeletion_node = NULL;\n\tparent_node = acpi_gbl_root_node;\n\tchild_node = NULL;\n\tlevel = 1;\n\n\t \n\twhile (level > 0) {\n\t\t \n\t\tchild_node = acpi_ns_get_next_node(parent_node, child_node);\n\n\t\tif (deletion_node) {\n\t\t\tacpi_ns_delete_children(deletion_node);\n\t\t\tacpi_ns_remove_node(deletion_node);\n\t\t\tdeletion_node = NULL;\n\t\t}\n\n\t\tif (child_node) {\n\t\t\tif (child_node->owner_id == owner_id) {\n\n\t\t\t\t \n\n\t\t\t\tacpi_ns_detach_object(child_node);\n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (child_node->child) {\n\t\t\t\t \n\t\t\t\tlevel++;\n\t\t\t\tparent_node = child_node;\n\t\t\t\tchild_node = NULL;\n\t\t\t} else if (child_node->owner_id == owner_id) {\n\t\t\t\tdeletion_node = child_node;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tlevel--;\n\t\t\tif (level != 0) {\n\t\t\t\tif (parent_node->owner_id == owner_id) {\n\t\t\t\t\tdeletion_node = parent_node;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\n\t\t\tchild_node = parent_node;\n\n\t\t\t \n\n\t\t\tparent_node = parent_node->parent;\n\t\t}\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_VOID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}