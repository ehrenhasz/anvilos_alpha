{
  "module_name": "evgpeblk.c",
  "hash_id": "dff99f4536560c69a998a3002327c476e504da879058c17ae747a06d34ffa072",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evgpeblk.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evgpeblk\")\n#if (!ACPI_REDUCED_HARDWARE)\t \n \nstatic acpi_status\nacpi_ev_install_gpe_block(struct acpi_gpe_block_info *gpe_block,\n\t\t\t  u32 interrupt_number);\n\nstatic acpi_status\nacpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block);\n\n \n\nstatic acpi_status\nacpi_ev_install_gpe_block(struct acpi_gpe_block_info *gpe_block,\n\t\t\t  u32 interrupt_number)\n{\n\tstruct acpi_gpe_block_info *next_gpe_block;\n\tstruct acpi_gpe_xrupt_info *gpe_xrupt_block;\n\tacpi_status status;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(ev_install_gpe_block);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus =\n\t    acpi_ev_get_gpe_xrupt_block(interrupt_number, &gpe_xrupt_block);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\tif (gpe_xrupt_block->gpe_block_list_head) {\n\t\tnext_gpe_block = gpe_xrupt_block->gpe_block_list_head;\n\t\twhile (next_gpe_block->next) {\n\t\t\tnext_gpe_block = next_gpe_block->next;\n\t\t}\n\n\t\tnext_gpe_block->next = gpe_block;\n\t\tgpe_block->previous = next_gpe_block;\n\t} else {\n\t\tgpe_xrupt_block->gpe_block_list_head = gpe_block;\n\t}\n\n\tgpe_block->xrupt_block = gpe_xrupt_block;\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ev_delete_gpe_block(struct acpi_gpe_block_info *gpe_block)\n{\n\tacpi_status status;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(ev_install_gpe_block);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tstatus =\n\t    acpi_hw_disable_gpe_block(gpe_block->xrupt_block, gpe_block, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tif (!gpe_block->previous && !gpe_block->next) {\n\n\t\t \n\n\t\tstatus = acpi_ev_delete_gpe_xrupt(gpe_block->xrupt_block);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\t} else {\n\t\t \n\n\t\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\t\tif (gpe_block->previous) {\n\t\t\tgpe_block->previous->next = gpe_block->next;\n\t\t} else {\n\t\t\tgpe_block->xrupt_block->gpe_block_list_head =\n\t\t\t    gpe_block->next;\n\t\t}\n\n\t\tif (gpe_block->next) {\n\t\t\tgpe_block->next->previous = gpe_block->previous;\n\t\t}\n\n\t\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\t}\n\n\tacpi_current_gpe_count -= gpe_block->gpe_count;\n\n\t \n\n\tACPI_FREE(gpe_block->register_info);\n\tACPI_FREE(gpe_block->event_info);\n\tACPI_FREE(gpe_block);\n\nunlock_and_exit:\n\tstatus = acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic acpi_status\nacpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block)\n{\n\tstruct acpi_gpe_register_info *gpe_register_info = NULL;\n\tstruct acpi_gpe_event_info *gpe_event_info = NULL;\n\tstruct acpi_gpe_event_info *this_event;\n\tstruct acpi_gpe_register_info *this_register;\n\tu32 i;\n\tu32 j;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ev_create_gpe_info_blocks);\n\n\t \n\n\tgpe_register_info = ACPI_ALLOCATE_ZEROED((acpi_size)gpe_block->\n\t\t\t\t\t\t register_count *\n\t\t\t\t\t\t sizeof(struct\n\t\t\t\t\t\t\tacpi_gpe_register_info));\n\tif (!gpe_register_info) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Could not allocate the GpeRegisterInfo table\"));\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\tgpe_event_info = ACPI_ALLOCATE_ZEROED((acpi_size)gpe_block->gpe_count *\n\t\t\t\t\t      sizeof(struct\n\t\t\t\t\t\t     acpi_gpe_event_info));\n\tif (!gpe_event_info) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Could not allocate the GpeEventInfo table\"));\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto error_exit;\n\t}\n\n\t \n\n\tgpe_block->register_info = gpe_register_info;\n\tgpe_block->event_info = gpe_event_info;\n\n\t \n\tthis_register = gpe_register_info;\n\tthis_event = gpe_event_info;\n\n\tfor (i = 0; i < gpe_block->register_count; i++) {\n\n\t\t \n\n\t\tthis_register->base_gpe_number = (u16)\n\t\t    (gpe_block->block_base_number +\n\t\t     (i * ACPI_GPE_REGISTER_WIDTH));\n\n\t\tthis_register->status_address.address = gpe_block->address + i;\n\n\t\tthis_register->enable_address.address =\n\t\t    gpe_block->address + i + gpe_block->register_count;\n\n\t\tthis_register->status_address.space_id = gpe_block->space_id;\n\t\tthis_register->enable_address.space_id = gpe_block->space_id;\n\n\t\t \n\n\t\tfor (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {\n\t\t\tthis_event->gpe_number =\n\t\t\t    (u8) (this_register->base_gpe_number + j);\n\t\t\tthis_event->register_info = this_register;\n\t\t\tthis_event++;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_hw_gpe_write(0x00, &this_register->enable_address);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto error_exit;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_hw_gpe_write(0xFF, &this_register->status_address);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto error_exit;\n\t\t}\n\n\t\tthis_register++;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n\nerror_exit:\n\tif (gpe_register_info) {\n\t\tACPI_FREE(gpe_register_info);\n\t}\n\tif (gpe_event_info) {\n\t\tACPI_FREE(gpe_event_info);\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,\n\t\t\t u64 address,\n\t\t\t u8 space_id,\n\t\t\t u32 register_count,\n\t\t\t u16 gpe_block_base_number,\n\t\t\t u32 interrupt_number,\n\t\t\t struct acpi_gpe_block_info **return_gpe_block)\n{\n\tacpi_status status;\n\tstruct acpi_gpe_block_info *gpe_block;\n\tstruct acpi_gpe_walk_info walk_info;\n\n\tACPI_FUNCTION_TRACE(ev_create_gpe_block);\n\n\tif (!register_count) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tif ((space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) &&\n\t    (space_id != ACPI_ADR_SPACE_SYSTEM_IO)) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Unsupported address space: 0x%X\", space_id));\n\t\treturn_ACPI_STATUS(AE_SUPPORT);\n\t}\n\n\tif (space_id == ACPI_ADR_SPACE_SYSTEM_IO) {\n\t\tstatus = acpi_hw_validate_io_block(address,\n\t\t\t\t\t\t   ACPI_GPE_REGISTER_WIDTH,\n\t\t\t\t\t\t   register_count);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tgpe_block = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_block_info));\n\tif (!gpe_block) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tgpe_block->address = address;\n\tgpe_block->space_id = space_id;\n\tgpe_block->node = gpe_device;\n\tgpe_block->gpe_count = (u16)(register_count * ACPI_GPE_REGISTER_WIDTH);\n\tgpe_block->initialized = FALSE;\n\tgpe_block->register_count = register_count;\n\tgpe_block->block_base_number = gpe_block_base_number;\n\n\t \n\tstatus = acpi_ev_create_gpe_info_blocks(gpe_block);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_FREE(gpe_block);\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tstatus = acpi_ev_install_gpe_block(gpe_block, interrupt_number);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_FREE(gpe_block->register_info);\n\t\tACPI_FREE(gpe_block->event_info);\n\t\tACPI_FREE(gpe_block);\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tacpi_gbl_all_gpes_initialized = FALSE;\n\n\t \n\n\twalk_info.gpe_block = gpe_block;\n\twalk_info.gpe_device = gpe_device;\n\twalk_info.execute_by_owner_id = FALSE;\n\n\t(void)acpi_ns_walk_namespace(ACPI_TYPE_METHOD, gpe_device,\n\t\t\t\t     ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,\n\t\t\t\t     acpi_ev_match_gpe_method, NULL, &walk_info,\n\t\t\t\t     NULL);\n\n\t \n\n\tif (return_gpe_block) {\n\t\t(*return_gpe_block) = gpe_block;\n\t}\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,\n\t\t\t      \"    Initialized GPE %02X to %02X [%4.4s] %u regs on interrupt 0x%X%s\\n\",\n\t\t\t      (u32)gpe_block->block_base_number,\n\t\t\t      (u32)(gpe_block->block_base_number +\n\t\t\t\t    (gpe_block->gpe_count - 1)),\n\t\t\t      gpe_device->name.ascii, gpe_block->register_count,\n\t\t\t      interrupt_number,\n\t\t\t      interrupt_number ==\n\t\t\t      acpi_gbl_FADT.sci_interrupt ? \" (SCI)\" : \"\"));\n\n\t \n\n\tacpi_current_gpe_count += gpe_block->gpe_count;\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\n\t\t\t     struct acpi_gpe_block_info *gpe_block,\n\t\t\t     void *context)\n{\n\tacpi_status status;\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tu32 gpe_enabled_count;\n\tu32 gpe_index;\n\tu32 i;\n\tu32 j;\n\tu8 *is_polling_needed = context;\n\tACPI_ERROR_ONLY(u32 gpe_number);\n\n\tACPI_FUNCTION_TRACE(ev_initialize_gpe_block);\n\n\t \n\tif (!gpe_block || gpe_block->initialized) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\tgpe_enabled_count = 0;\n\n\tfor (i = 0; i < gpe_block->register_count; i++) {\n\t\tfor (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {\n\n\t\t\t \n\n\t\t\tgpe_index = (i * ACPI_GPE_REGISTER_WIDTH) + j;\n\t\t\tgpe_event_info = &gpe_block->event_info[gpe_index];\n\t\t\tACPI_ERROR_ONLY(gpe_number =\n\t\t\t\t\tgpe_block->block_base_number +\n\t\t\t\t\tgpe_index);\n\t\t\tgpe_event_info->flags |= ACPI_GPE_INITIALIZED;\n\n\t\t\t \n\t\t\tif ((ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) !=\n\t\t\t     ACPI_GPE_DISPATCH_METHOD)\n\t\t\t    || (gpe_event_info->flags & ACPI_GPE_CAN_WAKE)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstatus = acpi_ev_add_gpe_reference(gpe_event_info, FALSE);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\"Could not enable GPE 0x%02X\",\n\t\t\t\t\tgpe_number));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgpe_event_info->flags |= ACPI_GPE_AUTO_ENABLED;\n\n\t\t\tif (is_polling_needed &&\n\t\t\t    ACPI_GPE_IS_POLLING_NEEDED(gpe_event_info)) {\n\t\t\t\t*is_polling_needed = TRUE;\n\t\t\t}\n\n\t\t\tgpe_enabled_count++;\n\t\t}\n\t}\n\n\tif (gpe_enabled_count) {\n\t\tACPI_INFO((\"Enabled %u GPEs in block %02X to %02X\",\n\t\t\t   gpe_enabled_count, (u32)gpe_block->block_base_number,\n\t\t\t   (u32)(gpe_block->block_base_number +\n\t\t\t\t (gpe_block->gpe_count - 1))));\n\t}\n\n\tgpe_block->initialized = TRUE;\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}