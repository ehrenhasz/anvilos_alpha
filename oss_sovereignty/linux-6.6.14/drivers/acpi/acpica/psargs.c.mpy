{
  "module_name": "psargs.c",
  "hash_id": "6b9e8732ba453360bff936354b0387c9853fa4beeb95fe8d2813ec3811e00bc9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/psargs.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acparser.h\"\n#include \"amlcode.h\"\n#include \"acnamesp.h\"\n#include \"acdispat.h\"\n#include \"acconvert.h\"\n\n#define _COMPONENT          ACPI_PARSER\nACPI_MODULE_NAME(\"psargs\")\n\n \nstatic u32\nacpi_ps_get_next_package_length(struct acpi_parse_state *parser_state);\n\nstatic union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state\n\t\t\t\t\t\t       *parser_state);\n\n \n\nstatic u32\nacpi_ps_get_next_package_length(struct acpi_parse_state *parser_state)\n{\n\tu8 *aml = parser_state->aml;\n\tu32 package_length = 0;\n\tu32 byte_count;\n\tu8 byte_zero_mask = 0x3F;\t \n\n\tACPI_FUNCTION_TRACE(ps_get_next_package_length);\n\n\t \n\tbyte_count = (aml[0] >> 6);\n\tparser_state->aml += ((acpi_size)byte_count + 1);\n\n\t \n\n\twhile (byte_count) {\n\t\t \n\t\tpackage_length |= (aml[byte_count] << ((byte_count << 3) - 4));\n\n\t\tbyte_zero_mask = 0x0F;\t \n\t\tbyte_count--;\n\t}\n\n\t \n\n\tpackage_length |= (aml[0] & byte_zero_mask);\n\treturn_UINT32(package_length);\n}\n\n \n\nu8 *acpi_ps_get_next_package_end(struct acpi_parse_state *parser_state)\n{\n\tu8 *start = parser_state->aml;\n\tu32 package_length;\n\n\tACPI_FUNCTION_TRACE(ps_get_next_package_end);\n\n\t \n\n\tpackage_length = acpi_ps_get_next_package_length(parser_state);\n\n\treturn_PTR(start + package_length);\t \n}\n\n \n\nchar *acpi_ps_get_next_namestring(struct acpi_parse_state *parser_state)\n{\n\tu8 *start = parser_state->aml;\n\tu8 *end = parser_state->aml;\n\n\tACPI_FUNCTION_TRACE(ps_get_next_namestring);\n\n\t \n\n\twhile (ACPI_IS_ROOT_PREFIX(*end) || ACPI_IS_PARENT_PREFIX(*end)) {\n\t\tend++;\n\t}\n\n\t \n\n\tswitch (*end) {\n\tcase 0:\n\n\t\t \n\n\t\tif (end == start) {\n\t\t\tstart = NULL;\n\t\t}\n\t\tend++;\n\t\tbreak;\n\n\tcase AML_DUAL_NAME_PREFIX:\n\n\t\t \n\n\t\tend += 1 + (2 * ACPI_NAMESEG_SIZE);\n\t\tbreak;\n\n\tcase AML_MULTI_NAME_PREFIX:\n\n\t\t \n\n\t\tend += 2 + (*(end + 1) * ACPI_NAMESEG_SIZE);\n\t\tbreak;\n\n\tdefault:\n\n\t\t \n\n\t\tend += ACPI_NAMESEG_SIZE;\n\t\tbreak;\n\t}\n\n\tparser_state->aml = end;\n\treturn_PTR((char *)start);\n}\n\n \n\nacpi_status\nacpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,\n\t\t\t  struct acpi_parse_state *parser_state,\n\t\t\t  union acpi_parse_object *arg, u8 possible_method_call)\n{\n\tacpi_status status;\n\tchar *path;\n\tunion acpi_parse_object *name_op;\n\tunion acpi_operand_object *method_desc;\n\tstruct acpi_namespace_node *node;\n\tu8 *start = parser_state->aml;\n\n\tACPI_FUNCTION_TRACE(ps_get_next_namepath);\n\n\tpath = acpi_ps_get_next_namestring(parser_state);\n\tacpi_ps_init_op(arg, AML_INT_NAMEPATH_OP);\n\n\t \n\n\tif (!path) {\n\t\targ->common.value.name = path;\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\tstatus = acpi_ns_lookup(walk_state->scope_info, path,\n\t\t\t\tACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,\n\t\t\t\tACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,\n\t\t\t\tNULL, &node);\n\n\t \n\tif (ACPI_SUCCESS(status) &&\n\t    possible_method_call && (node->type == ACPI_TYPE_METHOD)) {\n\t\tif ((GET_CURRENT_ARG_TYPE(walk_state->arg_types) ==\n\t\t     ARGP_SUPERNAME)\n\t\t    || (GET_CURRENT_ARG_TYPE(walk_state->arg_types) ==\n\t\t\tARGP_TARGET)) {\n\t\t\t \n\t\t\twalk_state->parser_state.aml = start;\n\t\t\twalk_state->arg_count = 1;\n\t\t\tacpi_ps_init_op(arg, AML_INT_METHODCALL_OP);\n\t\t}\n\n\t\t \n\n\t\tmethod_desc = acpi_ns_get_attached_object(node);\n\t\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t\t  \"Control Method invocation %4.4s - %p Desc %p Path=%p\\n\",\n\t\t\t\t  node->name.ascii, node, method_desc, path));\n\n\t\tname_op = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP, start);\n\t\tif (!name_op) {\n\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t}\n\n\t\t \n\n\t\tacpi_ps_init_op(arg, AML_INT_METHODCALL_OP);\n\t\tname_op->common.value.name = path;\n\n\t\t \n\n\t\tname_op->common.node = node;\n\t\tacpi_ps_append_arg(arg, name_op);\n\n\t\tif (!method_desc) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Control Method %p has no attached object\",\n\t\t\t\t    node));\n\t\t\treturn_ACPI_STATUS(AE_AML_INTERNAL);\n\t\t}\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t\t  \"Control Method - %p Args %X\\n\",\n\t\t\t\t  node, method_desc->method.param_count));\n\n\t\t \n\n\t\twalk_state->arg_count = method_desc->method.param_count;\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\tif (status == AE_NOT_FOUND) {\n\n\t\t \n\n\t\tif ((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) !=\n\t\t    ACPI_PARSE_EXECUTE) {\n\t\t\tstatus = AE_OK;\n\t\t}\n\n\t\t \n\n\t\telse if (walk_state->op->common.aml_opcode ==\n\t\t\t AML_CONDITIONAL_REF_OF_OP) {\n\t\t\tstatus = AE_OK;\n\t\t}\n\n\t\t \n\t\telse if ((arg->common.parent) &&\n\t\t\t ((arg->common.parent->common.aml_opcode ==\n\t\t\t   AML_PACKAGE_OP)\n\t\t\t  || (arg->common.parent->common.aml_opcode ==\n\t\t\t      AML_VARIABLE_PACKAGE_OP))) {\n\t\t\tstatus = AE_OK;\n\t\t}\n\t}\n\n\t \n\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_ERROR_NAMESPACE(walk_state->scope_info, path, status);\n\n\t\tif ((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) ==\n\t\t    ACPI_PARSE_EXECUTE) {\n\n\t\t\t \n\n\t\t\tstatus = acpi_ds_method_error(status, walk_state);\n\t\t}\n\t}\n\n\t \n\n\targ->common.value.name = path;\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nvoid\nacpi_ps_get_next_simple_arg(struct acpi_parse_state *parser_state,\n\t\t\t    u32 arg_type, union acpi_parse_object *arg)\n{\n\tu32 length;\n\tu16 opcode;\n\tu8 *aml = parser_state->aml;\n\n\tACPI_FUNCTION_TRACE_U32(ps_get_next_simple_arg, arg_type);\n\n\tswitch (arg_type) {\n\tcase ARGP_BYTEDATA:\n\n\t\t \n\n\t\topcode = AML_BYTE_OP;\n\t\targ->common.value.integer = (u64) *aml;\n\t\tlength = 1;\n\t\tbreak;\n\n\tcase ARGP_WORDDATA:\n\n\t\t \n\n\t\topcode = AML_WORD_OP;\n\t\tACPI_MOVE_16_TO_64(&arg->common.value.integer, aml);\n\t\tlength = 2;\n\t\tbreak;\n\n\tcase ARGP_DWORDDATA:\n\n\t\t \n\n\t\topcode = AML_DWORD_OP;\n\t\tACPI_MOVE_32_TO_64(&arg->common.value.integer, aml);\n\t\tlength = 4;\n\t\tbreak;\n\n\tcase ARGP_QWORDDATA:\n\n\t\t \n\n\t\topcode = AML_QWORD_OP;\n\t\tACPI_MOVE_64_TO_64(&arg->common.value.integer, aml);\n\t\tlength = 8;\n\t\tbreak;\n\n\tcase ARGP_CHARLIST:\n\n\t\t \n\n\t\topcode = AML_STRING_OP;\n\t\targ->common.value.string = ACPI_CAST_PTR(char, aml);\n\n\t\t \n\n\t\tlength = 0;\n\t\twhile (aml[length]) {\n\t\t\tlength++;\n\t\t}\n\t\tlength++;\n\t\tbreak;\n\n\tcase ARGP_NAME:\n\tcase ARGP_NAMESTRING:\n\n\t\tacpi_ps_init_op(arg, AML_INT_NAMEPATH_OP);\n\t\targ->common.value.name =\n\t\t    acpi_ps_get_next_namestring(parser_state);\n\t\treturn_VOID;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"Invalid ArgType 0x%X\", arg_type));\n\t\treturn_VOID;\n\t}\n\n\tacpi_ps_init_op(arg, opcode);\n\tparser_state->aml += length;\n\treturn_VOID;\n}\n\n \n\nstatic union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state\n\t\t\t\t\t\t       *parser_state)\n{\n\tu8 *aml;\n\tunion acpi_parse_object *field;\n\tunion acpi_parse_object *arg = NULL;\n\tu16 opcode;\n\tu32 name;\n\tu8 access_type;\n\tu8 access_attribute;\n\tu8 access_length;\n\tu32 pkg_length;\n\tu8 *pkg_end;\n\tu32 buffer_length;\n\n\tACPI_FUNCTION_TRACE(ps_get_next_field);\n\n\tASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);\n\taml = parser_state->aml;\n\n\t \n\n\tswitch (ACPI_GET8(parser_state->aml)) {\n\tcase AML_FIELD_OFFSET_OP:\n\n\t\topcode = AML_INT_RESERVEDFIELD_OP;\n\t\tparser_state->aml++;\n\t\tbreak;\n\n\tcase AML_FIELD_ACCESS_OP:\n\n\t\topcode = AML_INT_ACCESSFIELD_OP;\n\t\tparser_state->aml++;\n\t\tbreak;\n\n\tcase AML_FIELD_CONNECTION_OP:\n\n\t\topcode = AML_INT_CONNECTION_OP;\n\t\tparser_state->aml++;\n\t\tbreak;\n\n\tcase AML_FIELD_EXT_ACCESS_OP:\n\n\t\topcode = AML_INT_EXTACCESSFIELD_OP;\n\t\tparser_state->aml++;\n\t\tbreak;\n\n\tdefault:\n\n\t\topcode = AML_INT_NAMEDFIELD_OP;\n\t\tbreak;\n\t}\n\n\t \n\n\tfield = acpi_ps_alloc_op(opcode, aml);\n\tif (!field) {\n\t\treturn_PTR(NULL);\n\t}\n\n\t \n\n\tASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);\n\tswitch (opcode) {\n\tcase AML_INT_NAMEDFIELD_OP:\n\n\t\t \n\n\t\tACPI_MOVE_32_TO_32(&name, parser_state->aml);\n\t\tacpi_ps_set_name(field, name);\n\t\tparser_state->aml += ACPI_NAMESEG_SIZE;\n\n\t\tASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);\n\n#ifdef ACPI_ASL_COMPILER\n\t\t \n\t\tif (field->common.inline_comment) {\n\t\t\tfield->common.name_comment =\n\t\t\t    field->common.inline_comment;\n\t\t}\n\t\tfield->common.inline_comment = acpi_gbl_current_inline_comment;\n\t\tacpi_gbl_current_inline_comment = NULL;\n#endif\n\n\t\t \n\n\t\tfield->common.value.size =\n\t\t    acpi_ps_get_next_package_length(parser_state);\n\t\tbreak;\n\n\tcase AML_INT_RESERVEDFIELD_OP:\n\n\t\t \n\n\t\tfield->common.value.size =\n\t\t    acpi_ps_get_next_package_length(parser_state);\n\t\tbreak;\n\n\tcase AML_INT_ACCESSFIELD_OP:\n\tcase AML_INT_EXTACCESSFIELD_OP:\n\n\t\t \n\n\t\t \n\n\t\taccess_type = ACPI_GET8(parser_state->aml);\n\t\tparser_state->aml++;\n\t\taccess_attribute = ACPI_GET8(parser_state->aml);\n\t\tparser_state->aml++;\n\n\t\tfield->common.value.integer = (u8)access_type;\n\t\tfield->common.value.integer |= (u16)(access_attribute << 8);\n\n\t\t \n\n\t\tif (opcode == AML_INT_EXTACCESSFIELD_OP) {\n\t\t\taccess_length = ACPI_GET8(parser_state->aml);\n\t\t\tparser_state->aml++;\n\n\t\t\tfield->common.value.integer |=\n\t\t\t    (u32)(access_length << 16);\n\t\t}\n\t\tbreak;\n\n\tcase AML_INT_CONNECTION_OP:\n\n\t\t \n\t\taml = parser_state->aml;\n\t\tif (ACPI_GET8(parser_state->aml) == AML_BUFFER_OP) {\n\t\t\tparser_state->aml++;\n\n\t\t\tASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);\n\t\t\tpkg_end = parser_state->aml;\n\t\t\tpkg_length =\n\t\t\t    acpi_ps_get_next_package_length(parser_state);\n\t\t\tpkg_end += pkg_length;\n\n\t\t\tASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);\n\t\t\tif (parser_state->aml < pkg_end) {\n\n\t\t\t\t \n\n\t\t\t\targ =\n\t\t\t\t    acpi_ps_alloc_op(AML_INT_BYTELIST_OP, aml);\n\t\t\t\tif (!arg) {\n\t\t\t\t\tacpi_ps_free_op(field);\n\t\t\t\t\treturn_PTR(NULL);\n\t\t\t\t}\n\n\t\t\t\t \n\n\t\t\t\topcode = ACPI_GET8(parser_state->aml);\n\t\t\t\tparser_state->aml++;\n\n\t\t\t\tASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);\n\t\t\t\tswitch (opcode) {\n\t\t\t\tcase AML_BYTE_OP:\t \n\n\t\t\t\t\tbuffer_length =\n\t\t\t\t\t    ACPI_GET8(parser_state->aml);\n\t\t\t\t\tparser_state->aml += 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AML_WORD_OP:\t \n\n\t\t\t\t\tbuffer_length =\n\t\t\t\t\t    ACPI_GET16(parser_state->aml);\n\t\t\t\t\tparser_state->aml += 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AML_DWORD_OP:\t \n\n\t\t\t\t\tbuffer_length =\n\t\t\t\t\t    ACPI_GET32(parser_state->aml);\n\t\t\t\t\tparser_state->aml += 4;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tbuffer_length = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\n\t\t\t\tASL_CV_CAPTURE_COMMENTS_ONLY(parser_state);\n\t\t\t\targ->named.value.size = buffer_length;\n\t\t\t\targ->named.data = parser_state->aml;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tparser_state->aml = pkg_end;\n\t\t} else {\n\t\t\targ = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP, aml);\n\t\t\tif (!arg) {\n\t\t\t\tacpi_ps_free_op(field);\n\t\t\t\treturn_PTR(NULL);\n\t\t\t}\n\n\t\t\t \n\n\t\t\targ->common.value.name =\n\t\t\t    acpi_ps_get_next_namestring(parser_state);\n\t\t}\n\n\t\t \n\n\t\tacpi_ps_append_arg(field, arg);\n\t\tbreak;\n\n\tdefault:\n\n\t\t \n\t\tbreak;\n\t}\n\n\treturn_PTR(field);\n}\n\n \n\nacpi_status\nacpi_ps_get_next_arg(struct acpi_walk_state *walk_state,\n\t\t     struct acpi_parse_state *parser_state,\n\t\t     u32 arg_type, union acpi_parse_object **return_arg)\n{\n\tunion acpi_parse_object *arg = NULL;\n\tunion acpi_parse_object *prev = NULL;\n\tunion acpi_parse_object *field;\n\tu32 subop;\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE_PTR(ps_get_next_arg, parser_state);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t  \"Expected argument type ARGP: %s (%2.2X)\\n\",\n\t\t\t  acpi_ut_get_argument_type_name(arg_type), arg_type));\n\n\tswitch (arg_type) {\n\tcase ARGP_BYTEDATA:\n\tcase ARGP_WORDDATA:\n\tcase ARGP_DWORDDATA:\n\tcase ARGP_CHARLIST:\n\tcase ARGP_NAME:\n\tcase ARGP_NAMESTRING:\n\n\t\t \n\n\t\targ = acpi_ps_alloc_op(AML_BYTE_OP, parser_state->aml);\n\t\tif (!arg) {\n\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t}\n\n\t\tacpi_ps_get_next_simple_arg(parser_state, arg_type, arg);\n\t\tbreak;\n\n\tcase ARGP_PKGLENGTH:\n\n\t\t \n\n\t\tparser_state->pkg_end =\n\t\t    acpi_ps_get_next_package_end(parser_state);\n\t\tbreak;\n\n\tcase ARGP_FIELDLIST:\n\n\t\tif (parser_state->aml < parser_state->pkg_end) {\n\n\t\t\t \n\n\t\t\twhile (parser_state->aml < parser_state->pkg_end) {\n\t\t\t\tfield = acpi_ps_get_next_field(parser_state);\n\t\t\t\tif (!field) {\n\t\t\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t\t\t}\n\n\t\t\t\tif (prev) {\n\t\t\t\t\tprev->common.next = field;\n\t\t\t\t} else {\n\t\t\t\t\targ = field;\n\t\t\t\t}\n\t\t\t\tprev = field;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tparser_state->aml = parser_state->pkg_end;\n\t\t}\n\t\tbreak;\n\n\tcase ARGP_BYTELIST:\n\n\t\tif (parser_state->aml < parser_state->pkg_end) {\n\n\t\t\t \n\n\t\t\targ = acpi_ps_alloc_op(AML_INT_BYTELIST_OP,\n\t\t\t\t\t       parser_state->aml);\n\t\t\tif (!arg) {\n\t\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t\t}\n\n\t\t\t \n\n\t\t\targ->common.value.size = (u32)\n\t\t\t    ACPI_PTR_DIFF(parser_state->pkg_end,\n\t\t\t\t\t  parser_state->aml);\n\t\t\targ->named.data = parser_state->aml;\n\n\t\t\t \n\n\t\t\tparser_state->aml = parser_state->pkg_end;\n\t\t}\n\t\tbreak;\n\n\tcase ARGP_SIMPLENAME:\n\tcase ARGP_NAME_OR_REF:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t\t  \"**** SimpleName/NameOrRef: %s (%2.2X)\\n\",\n\t\t\t\t  acpi_ut_get_argument_type_name(arg_type),\n\t\t\t\t  arg_type));\n\n\t\tsubop = acpi_ps_peek_opcode(parser_state);\n\t\tif (subop == 0 ||\n\t\t    acpi_ps_is_leading_char(subop) ||\n\t\t    ACPI_IS_ROOT_PREFIX(subop) ||\n\t\t    ACPI_IS_PARENT_PREFIX(subop)) {\n\n\t\t\t \n\n\t\t\targ =\n\t\t\t    acpi_ps_alloc_op(AML_INT_NAMEPATH_OP,\n\t\t\t\t\t     parser_state->aml);\n\t\t\tif (!arg) {\n\t\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t\t}\n\n\t\t\tstatus =\n\t\t\t    acpi_ps_get_next_namepath(walk_state, parser_state,\n\t\t\t\t\t\t      arg,\n\t\t\t\t\t\t      ACPI_NOT_METHOD_CALL);\n\t\t} else {\n\t\t\t \n\n\t\t\twalk_state->arg_count = 1;\n\t\t}\n\t\tbreak;\n\n\tcase ARGP_TARGET:\n\tcase ARGP_SUPERNAME:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t\t  \"**** Target/Supername: %s (%2.2X)\\n\",\n\t\t\t\t  acpi_ut_get_argument_type_name(arg_type),\n\t\t\t\t  arg_type));\n\n\t\tsubop = acpi_ps_peek_opcode(parser_state);\n\t\tif (subop == 0 ||\n\t\t    acpi_ps_is_leading_char(subop) ||\n\t\t    ACPI_IS_ROOT_PREFIX(subop) ||\n\t\t    ACPI_IS_PARENT_PREFIX(subop)) {\n\n\t\t\t \n\n\t\t\targ =\n\t\t\t    acpi_ps_alloc_op(AML_INT_NAMEPATH_OP,\n\t\t\t\t\t     parser_state->aml);\n\t\t\tif (!arg) {\n\t\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t\t}\n\n\t\t\tstatus =\n\t\t\t    acpi_ps_get_next_namepath(walk_state, parser_state,\n\t\t\t\t\t\t      arg,\n\t\t\t\t\t\t      ACPI_POSSIBLE_METHOD_CALL);\n\n\t\t\tif (arg->common.aml_opcode == AML_INT_METHODCALL_OP) {\n\n\t\t\t\t \n\n\t\t\t\tacpi_ps_free_op(arg->common.value.arg);\n\t\t\t\tacpi_ps_free_op(arg);\n\t\t\t\targ = NULL;\n\t\t\t\twalk_state->arg_count = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\n\t\t\twalk_state->arg_count = 1;\n\t\t}\n\t\tbreak;\n\n\tcase ARGP_DATAOBJ:\n\tcase ARGP_TERMARG:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t\t  \"**** TermArg/DataObj: %s (%2.2X)\\n\",\n\t\t\t\t  acpi_ut_get_argument_type_name(arg_type),\n\t\t\t\t  arg_type));\n\n\t\t \n\n\t\twalk_state->arg_count = 1;\n\t\tbreak;\n\n\tcase ARGP_DATAOBJLIST:\n\tcase ARGP_TERMLIST:\n\tcase ARGP_OBJLIST:\n\n\t\tif (parser_state->aml < parser_state->pkg_end) {\n\n\t\t\t \n\n\t\t\twalk_state->arg_count = ACPI_VAR_ARGS;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"Invalid ArgType: 0x%X\", arg_type));\n\t\tstatus = AE_AML_OPERAND_TYPE;\n\t\tbreak;\n\t}\n\n\t*return_arg = arg;\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}