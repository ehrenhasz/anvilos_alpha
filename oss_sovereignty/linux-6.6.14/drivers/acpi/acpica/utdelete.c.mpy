{
  "module_name": "utdelete.c",
  "hash_id": "dd83c318f3d3622bc1eb016a47a3b819b83ce5b411aed3d18a91314e8614ff35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utdelete.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acinterp.h\"\n#include \"acnamesp.h\"\n#include \"acevents.h\"\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utdelete\")\n\n \nstatic void acpi_ut_delete_internal_obj(union acpi_operand_object *object);\n\nstatic void\nacpi_ut_update_ref_count(union acpi_operand_object *object, u32 action);\n\n \n\nstatic void acpi_ut_delete_internal_obj(union acpi_operand_object *object)\n{\n\tvoid *obj_pointer = NULL;\n\tunion acpi_operand_object *handler_desc;\n\tunion acpi_operand_object *second_desc;\n\tunion acpi_operand_object *next_desc;\n\tunion acpi_operand_object *start_desc;\n\tunion acpi_operand_object **last_obj_ptr;\n\n\tACPI_FUNCTION_TRACE_PTR(ut_delete_internal_obj, object);\n\n\tif (!object) {\n\t\treturn_VOID;\n\t}\n\n\t \n\tswitch (object->common.type) {\n\tcase ACPI_TYPE_STRING:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t\t  \"**** String %p, ptr %p\\n\", object,\n\t\t\t\t  object->string.pointer));\n\n\t\t \n\n\t\tif (!(object->common.flags & AOPOBJ_STATIC_POINTER)) {\n\n\t\t\t \n\n\t\t\tobj_pointer = object->string.pointer;\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t\t  \"**** Buffer %p, ptr %p\\n\", object,\n\t\t\t\t  object->buffer.pointer));\n\n\t\t \n\n\t\tif (!(object->common.flags & AOPOBJ_STATIC_POINTER)) {\n\n\t\t\t \n\n\t\t\tobj_pointer = object->buffer.pointer;\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_PACKAGE:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t\t  \" **** Package of count %X\\n\",\n\t\t\t\t  object->package.count));\n\n\t\t \n\n\t\t \n\n\t\tobj_pointer = object->package.elements;\n\t\tbreak;\n\n\t\t \n\tcase ACPI_TYPE_DEVICE:\n\n\t\tif (object->device.gpe_block) {\n\t\t\t(void)acpi_ev_delete_gpe_block(object->device.\n\t\t\t\t\t\t       gpe_block);\n\t\t}\n\n\t\tACPI_FALLTHROUGH;\n\n\tcase ACPI_TYPE_PROCESSOR:\n\tcase ACPI_TYPE_THERMAL:\n\n\t\t \n\n\t\thandler_desc = object->common_notify.handler;\n\t\twhile (handler_desc) {\n\t\t\tnext_desc = handler_desc->address_space.next;\n\t\t\tacpi_ut_remove_reference(handler_desc);\n\t\t\thandler_desc = next_desc;\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_MUTEX:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t\t  \"***** Mutex %p, OS Mutex %p\\n\",\n\t\t\t\t  object, object->mutex.os_mutex));\n\n\t\tif (object == acpi_gbl_global_lock_mutex) {\n\n\t\t\t \n\n\t\t\t(void)\n\t\t\t    acpi_os_delete_semaphore\n\t\t\t    (acpi_gbl_global_lock_semaphore);\n\t\t\tacpi_gbl_global_lock_semaphore = NULL;\n\n\t\t\tacpi_os_delete_mutex(object->mutex.os_mutex);\n\t\t\tacpi_gbl_global_lock_mutex = NULL;\n\t\t} else {\n\t\t\tacpi_ex_unlink_mutex(object);\n\t\t\tacpi_os_delete_mutex(object->mutex.os_mutex);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_EVENT:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t\t  \"***** Event %p, OS Semaphore %p\\n\",\n\t\t\t\t  object, object->event.os_semaphore));\n\n\t\t(void)acpi_os_delete_semaphore(object->event.os_semaphore);\n\t\tobject->event.os_semaphore = NULL;\n\t\tbreak;\n\n\tcase ACPI_TYPE_METHOD:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t\t  \"***** Method %p\\n\", object));\n\n\t\t \n\n\t\tif (object->method.mutex) {\n\t\t\tacpi_os_delete_mutex(object->method.mutex->mutex.\n\t\t\t\t\t     os_mutex);\n\t\t\tacpi_ut_delete_object_desc(object->method.mutex);\n\t\t\tobject->method.mutex = NULL;\n\t\t}\n\n\t\tif (object->method.node) {\n\t\t\tobject->method.node = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_REGION:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t\t  \"***** Region %p\\n\", object));\n\n\t\t \n\t\tif (!(object->region.node->flags & ANOBJ_TEMPORARY)) {\n\t\t\tacpi_ut_remove_address_range(object->region.space_id,\n\t\t\t\t\t\t     object->region.node);\n\t\t}\n\n\t\tsecond_desc = acpi_ns_get_secondary_object(object);\n\t\tif (second_desc) {\n\t\t\t \n\t\t\thandler_desc = object->region.handler;\n\t\t\tif (handler_desc) {\n\t\t\t\tnext_desc =\n\t\t\t\t    handler_desc->address_space.region_list;\n\t\t\t\tstart_desc = next_desc;\n\t\t\t\tlast_obj_ptr =\n\t\t\t\t    &handler_desc->address_space.region_list;\n\n\t\t\t\t \n\n\t\t\t\twhile (next_desc) {\n\t\t\t\t\tif (next_desc == object) {\n\t\t\t\t\t\t*last_obj_ptr =\n\t\t\t\t\t\t    next_desc->region.next;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\n\t\t\t\t\tlast_obj_ptr = &next_desc->region.next;\n\t\t\t\t\tnext_desc = next_desc->region.next;\n\n\t\t\t\t\t \n\n\t\t\t\t\tif (next_desc == start_desc) {\n\t\t\t\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t\t\t\t    \"Circular region list in address handler object %p\",\n\t\t\t\t\t\t\t    handler_desc));\n\t\t\t\t\t\treturn_VOID;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (handler_desc->address_space.handler_flags &\n\t\t\t\t    ACPI_ADDR_HANDLER_DEFAULT_INSTALLED) {\n\n\t\t\t\t\t \n\n\t\t\t\t\tif (handler_desc->address_space.setup) {\n\t\t\t\t\t\t(void)handler_desc->\n\t\t\t\t\t\t    address_space.setup(object,\n\t\t\t\t\t\t\t\t\tACPI_REGION_DEACTIVATE,\n\t\t\t\t\t\t\t\t\thandler_desc->\n\t\t\t\t\t\t\t\t\taddress_space.\n\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t&second_desc->\n\t\t\t\t\t\t\t\t\textra.\n\t\t\t\t\t\t\t\t\tregion_context);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tacpi_ut_remove_reference(handler_desc);\n\t\t\t}\n\n\t\t\t \n\n\t\t\tacpi_ut_delete_object_desc(second_desc);\n\t\t}\n\t\tif (object->field.internal_pcc_buffer) {\n\t\t\tACPI_FREE(object->field.internal_pcc_buffer);\n\t\t}\n\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER_FIELD:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t\t  \"***** Buffer Field %p\\n\", object));\n\n\t\tsecond_desc = acpi_ns_get_secondary_object(object);\n\t\tif (second_desc) {\n\t\t\tacpi_ut_delete_object_desc(second_desc);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_LOCAL_BANK_FIELD:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t\t  \"***** Bank Field %p\\n\", object));\n\n\t\tsecond_desc = acpi_ns_get_secondary_object(object);\n\t\tif (second_desc) {\n\t\t\tacpi_ut_delete_object_desc(second_desc);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_LOCAL_ADDRESS_HANDLER:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t\t  \"***** Address handler %p\\n\", object));\n\n\t\tacpi_os_delete_mutex(object->address_space.context_mutex);\n\t\tbreak;\n\n\tdefault:\n\n\t\tbreak;\n\t}\n\n\t \n\n\tif (obj_pointer) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t\t  \"Deleting Object Subptr %p\\n\", obj_pointer));\n\t\tACPI_FREE(obj_pointer);\n\t}\n\n\t \n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_ALLOCATIONS,\n\t\t\t      \"%s: Deleting Object %p [%s]\\n\",\n\t\t\t      ACPI_GET_FUNCTION_NAME, object,\n\t\t\t      acpi_ut_get_object_type_name(object)));\n\n\tacpi_ut_delete_object_desc(object);\n\treturn_VOID;\n}\n\n \n\nvoid acpi_ut_delete_internal_object_list(union acpi_operand_object **obj_list)\n{\n\tunion acpi_operand_object **internal_obj;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tfor (internal_obj = obj_list; *internal_obj; internal_obj++) {\n\t\tacpi_ut_remove_reference(*internal_obj);\n\t}\n\n\t \n\n\tACPI_FREE(obj_list);\n\treturn;\n}\n\n \n\nstatic void\nacpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)\n{\n\tu16 original_count;\n\tu16 new_count = 0;\n\tacpi_cpu_flags lock_flags;\n\tchar *message;\n\n\tACPI_FUNCTION_NAME(ut_update_ref_count);\n\n\tif (!object) {\n\t\treturn;\n\t}\n\n\t \n\tlock_flags = acpi_os_acquire_lock(acpi_gbl_reference_count_lock);\n\toriginal_count = object->common.reference_count;\n\n\t \n\n\tswitch (action) {\n\tcase REF_INCREMENT:\n\n\t\tnew_count = original_count + 1;\n\t\tobject->common.reference_count = new_count;\n\t\tacpi_os_release_lock(acpi_gbl_reference_count_lock, lock_flags);\n\n\t\t \n\n\t\tif (!original_count) {\n\t\t\tACPI_WARNING((AE_INFO,\n\t\t\t\t      \"Obj %p, Reference Count was zero before increment\\n\",\n\t\t\t\t      object));\n\t\t}\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t\t  \"Obj %p Type %.2X [%s] Refs %.2X [Incremented]\\n\",\n\t\t\t\t  object, object->common.type,\n\t\t\t\t  acpi_ut_get_object_type_name(object),\n\t\t\t\t  new_count));\n\t\tmessage = \"Incremement\";\n\t\tbreak;\n\n\tcase REF_DECREMENT:\n\n\t\t \n\n\t\tif (original_count) {\n\t\t\tnew_count = original_count - 1;\n\t\t\tobject->common.reference_count = new_count;\n\t\t}\n\n\t\tacpi_os_release_lock(acpi_gbl_reference_count_lock, lock_flags);\n\n\t\tif (!original_count) {\n\t\t\tACPI_WARNING((AE_INFO,\n\t\t\t\t      \"Obj %p, Reference Count is already zero, cannot decrement\\n\",\n\t\t\t\t      object));\n\t\t\treturn;\n\t\t}\n\n\t\tACPI_DEBUG_PRINT_RAW((ACPI_DB_ALLOCATIONS,\n\t\t\t\t      \"%s: Obj %p Type %.2X Refs %.2X [Decremented]\\n\",\n\t\t\t\t      ACPI_GET_FUNCTION_NAME, object,\n\t\t\t\t      object->common.type, new_count));\n\n\t\t \n\n\t\tif (new_count == 0) {\n\t\t\tacpi_ut_delete_internal_obj(object);\n\t\t}\n\t\tmessage = \"Decrement\";\n\t\tbreak;\n\n\tdefault:\n\n\t\tacpi_os_release_lock(acpi_gbl_reference_count_lock, lock_flags);\n\t\tACPI_ERROR((AE_INFO, \"Unknown Reference Count action (0x%X)\",\n\t\t\t    action));\n\t\treturn;\n\t}\n\n\t \n\tif (new_count > ACPI_MAX_REFERENCE_COUNT) {\n\t\tACPI_WARNING((AE_INFO,\n\t\t\t      \"Large Reference Count (0x%X) in object %p, Type=0x%.2X Operation=%s\",\n\t\t\t      new_count, object, object->common.type, message));\n\t}\n}\n\n \n\nacpi_status\nacpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_generic_state *state_list = NULL;\n\tunion acpi_operand_object *next_object = NULL;\n\tunion acpi_operand_object *prev_object;\n\tunion acpi_generic_state *state;\n\tu32 i;\n\n\tACPI_FUNCTION_NAME(ut_update_object_reference);\n\n\twhile (object) {\n\n\t\t \n\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(object) == ACPI_DESC_TYPE_NAMED) {\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t\t\t  \"Object %p is NS handle\\n\", object));\n\t\t\treturn (AE_OK);\n\t\t}\n\n\t\t \n\t\tswitch (object->common.type) {\n\t\tcase ACPI_TYPE_DEVICE:\n\t\tcase ACPI_TYPE_PROCESSOR:\n\t\tcase ACPI_TYPE_POWER:\n\t\tcase ACPI_TYPE_THERMAL:\n\t\t\t \n\t\t\tfor (i = 0; i < ACPI_NUM_NOTIFY_TYPES; i++) {\n\t\t\t\tprev_object =\n\t\t\t\t    object->common_notify.notify_list[i];\n\t\t\t\twhile (prev_object) {\n\t\t\t\t\tnext_object =\n\t\t\t\t\t    prev_object->notify.next[i];\n\t\t\t\t\tacpi_ut_update_ref_count(prev_object,\n\t\t\t\t\t\t\t\t action);\n\t\t\t\t\tprev_object = next_object;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_PACKAGE:\n\t\t\t \n\t\t\tfor (i = 0; i < object->package.count; i++) {\n\t\t\t\t \n\t\t\t\tnext_object = object->package.elements[i];\n\t\t\t\tif (!next_object) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (next_object->common.type) {\n\t\t\t\tcase ACPI_TYPE_INTEGER:\n\t\t\t\tcase ACPI_TYPE_STRING:\n\t\t\t\tcase ACPI_TYPE_BUFFER:\n\t\t\t\t\t \n\t\t\t\t\tacpi_ut_update_ref_count(next_object,\n\t\t\t\t\t\t\t\t action);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t \n\t\t\t\t\tstatus =\n\t\t\t\t\t    acpi_ut_create_update_state_and_push\n\t\t\t\t\t    (next_object, action, &state_list);\n\t\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\t\tgoto error_exit;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext_object = NULL;\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_BUFFER_FIELD:\n\n\t\t\tnext_object = object->buffer_field.buffer_obj;\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_LOCAL_BANK_FIELD:\n\n\t\t\tnext_object = object->bank_field.bank_obj;\n\t\t\tstatus =\n\t\t\t    acpi_ut_create_update_state_and_push(object->\n\t\t\t\t\t\t\t\t bank_field.\n\t\t\t\t\t\t\t\t region_obj,\n\t\t\t\t\t\t\t\t action,\n\t\t\t\t\t\t\t\t &state_list);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tgoto error_exit;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_LOCAL_INDEX_FIELD:\n\n\t\t\tnext_object = object->index_field.index_obj;\n\t\t\tstatus =\n\t\t\t    acpi_ut_create_update_state_and_push(object->\n\t\t\t\t\t\t\t\t index_field.\n\t\t\t\t\t\t\t\t data_obj,\n\t\t\t\t\t\t\t\t action,\n\t\t\t\t\t\t\t\t &state_list);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tgoto error_exit;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\t\t\t \n\t\t\tif ((object->reference.class == ACPI_REFCLASS_INDEX) ||\n\t\t\t    (object->reference.class == ACPI_REFCLASS_NAME)) {\n\t\t\t\tnext_object = object->reference.object;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_LOCAL_REGION_FIELD:\n\t\tcase ACPI_TYPE_REGION:\n\t\tdefault:\n\n\t\t\tbreak;\t \n\t\t}\n\n\t\t \n\t\tacpi_ut_update_ref_count(object, action);\n\t\tobject = NULL;\n\n\t\t \n\n\t\tif (next_object) {\n\t\t\tobject = next_object;\n\t\t\tnext_object = NULL;\n\t\t} else if (state_list) {\n\t\t\tstate = acpi_ut_pop_generic_state(&state_list);\n\t\t\tobject = state->update.object;\n\t\t\tacpi_ut_delete_generic_state(state);\n\t\t}\n\t}\n\n\treturn (AE_OK);\n\nerror_exit:\n\n\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\"Could not update object reference count\"));\n\n\t \n\n\twhile (state_list) {\n\t\tstate = acpi_ut_pop_generic_state(&state_list);\n\t\tacpi_ut_delete_generic_state(state);\n\t}\n\n\treturn (status);\n}\n\n \n\nvoid acpi_ut_add_reference(union acpi_operand_object *object)\n{\n\n\tACPI_FUNCTION_NAME(ut_add_reference);\n\n\t \n\n\tif (!acpi_ut_valid_internal_object(object)) {\n\t\treturn;\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\n\t\t\t  \"Obj %p Current Refs=%X [To Be Incremented]\\n\",\n\t\t\t  object, object->common.reference_count));\n\n\t \n\n\t(void)acpi_ut_update_object_reference(object, REF_INCREMENT);\n\treturn;\n}\n\n \n\nvoid acpi_ut_remove_reference(union acpi_operand_object *object)\n{\n\n\tACPI_FUNCTION_NAME(ut_remove_reference);\n\n\t \n\tif (!object ||\n\t    (ACPI_GET_DESCRIPTOR_TYPE(object) == ACPI_DESC_TYPE_NAMED)) {\n\t\treturn;\n\t}\n\n\t \n\n\tif (!acpi_ut_valid_internal_object(object)) {\n\t\treturn;\n\t}\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_ALLOCATIONS,\n\t\t\t      \"%s: Obj %p Current Refs=%X [To Be Decremented]\\n\",\n\t\t\t      ACPI_GET_FUNCTION_NAME, object,\n\t\t\t      object->common.reference_count));\n\n\t \n\t(void)acpi_ut_update_object_reference(object, REF_DECREMENT);\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}