{
  "module_name": "evrgnini.c",
  "hash_id": "ad408f0b6f51a9ea97987b76fc87aba02aaba357c9418d8639a3fb2042a7cddb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evrgnini.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n#include \"acnamesp.h\"\n#include \"acinterp.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evrgnini\")\n\n \nacpi_status\nacpi_ev_system_memory_region_setup(acpi_handle handle,\n\t\t\t\t   u32 function,\n\t\t\t\t   void *handler_context, void **region_context)\n{\n\tunion acpi_operand_object *region_desc =\n\t    (union acpi_operand_object *)handle;\n\tstruct acpi_mem_space_context *local_region_context;\n\tstruct acpi_mem_mapping *mm;\n\n\tACPI_FUNCTION_TRACE(ev_system_memory_region_setup);\n\n\tif (function == ACPI_REGION_DEACTIVATE) {\n\t\tif (*region_context) {\n\t\t\tlocal_region_context =\n\t\t\t    (struct acpi_mem_space_context *)*region_context;\n\n\t\t\t \n\n\t\t\twhile (local_region_context->first_mm) {\n\t\t\t\tmm = local_region_context->first_mm;\n\t\t\t\tlocal_region_context->first_mm = mm->next_mm;\n\t\t\t\tacpi_os_unmap_memory(mm->logical_address,\n\t\t\t\t\t\t     mm->length);\n\t\t\t\tACPI_FREE(mm);\n\t\t\t}\n\t\t\tACPI_FREE(local_region_context);\n\t\t\t*region_context = NULL;\n\t\t}\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tlocal_region_context =\n\t    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_mem_space_context));\n\tif (!(local_region_context)) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tlocal_region_context->length = region_desc->region.length;\n\tlocal_region_context->address = region_desc->region.address;\n\n\t*region_context = local_region_context;\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ev_io_space_region_setup(acpi_handle handle,\n\t\t\t      u32 function,\n\t\t\t      void *handler_context, void **region_context)\n{\n\tACPI_FUNCTION_TRACE(ev_io_space_region_setup);\n\n\tif (function == ACPI_REGION_DEACTIVATE) {\n\t\t*region_context = NULL;\n\t} else {\n\t\t*region_context = handler_context;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ev_pci_config_region_setup(acpi_handle handle,\n\t\t\t\tu32 function,\n\t\t\t\tvoid *handler_context, void **region_context)\n{\n\tacpi_status status = AE_OK;\n\tu64 pci_value;\n\tstruct acpi_pci_id *pci_id = *region_context;\n\tunion acpi_operand_object *handler_obj;\n\tstruct acpi_namespace_node *parent_node;\n\tstruct acpi_namespace_node *pci_root_node;\n\tstruct acpi_namespace_node *pci_device_node;\n\tunion acpi_operand_object *region_obj =\n\t    (union acpi_operand_object *)handle;\n\n\tACPI_FUNCTION_TRACE(ev_pci_config_region_setup);\n\n\thandler_obj = region_obj->region.handler;\n\tif (!handler_obj) {\n\t\t \n\t\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t\t  \"Attempting to init a region %p, with no handler\\n\",\n\t\t\t\t  region_obj));\n\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t}\n\n\t*region_context = NULL;\n\tif (function == ACPI_REGION_DEACTIVATE) {\n\t\tif (pci_id) {\n\t\t\tACPI_FREE(pci_id);\n\t\t}\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tparent_node = region_obj->region.node->parent;\n\n\t \n\n\t \n\tif (handler_obj->address_space.node == acpi_gbl_root_node) {\n\n\t\t \n\n\t\tpci_root_node = parent_node;\n\t\twhile (pci_root_node != acpi_gbl_root_node) {\n\n\t\t\t \n\n\t\t\tif (acpi_ev_is_pci_root_bridge(pci_root_node)) {\n\n\t\t\t\t \n\n\t\t\t\tstatus = acpi_install_address_space_handler((acpi_handle)pci_root_node, ACPI_ADR_SPACE_PCI_CONFIG, ACPI_DEFAULT_HANDLER, NULL, NULL);\n\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\tif (status == AE_SAME_HANDLER) {\n\t\t\t\t\t\t \n\t\t\t\t\t} else {\n\t\t\t\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\t\t\t\"Could not install PciConfig handler \"\n\t\t\t\t\t\t\t\t\"for Root Bridge %4.4s\",\n\t\t\t\t\t\t\t\tacpi_ut_get_node_name\n\t\t\t\t\t\t\t\t(pci_root_node)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpci_root_node = pci_root_node->parent;\n\t\t}\n\n\t\t \n\t} else {\n\t\tpci_root_node = handler_obj->address_space.node;\n\t}\n\n\t \n\tif (region_obj->region.flags & AOPOBJ_SETUP_COMPLETE) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tpci_id = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_pci_id));\n\tif (!pci_id) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\tpci_device_node = region_obj->region.node;\n\twhile (pci_device_node && (pci_device_node->type != ACPI_TYPE_DEVICE)) {\n\t\tpci_device_node = pci_device_node->parent;\n\t}\n\n\tif (!pci_device_node) {\n\t\tACPI_FREE(pci_id);\n\t\treturn_ACPI_STATUS(AE_AML_OPERAND_TYPE);\n\t}\n\n\t \n\tstatus = acpi_ut_evaluate_numeric_object(METHOD_NAME__ADR,\n\t\t\t\t\t\t pci_device_node, &pci_value);\n\n\t \n\tif (ACPI_SUCCESS(status)) {\n\t\tpci_id->device = ACPI_HIWORD(ACPI_LODWORD(pci_value));\n\t\tpci_id->function = ACPI_LOWORD(ACPI_LODWORD(pci_value));\n\t}\n\n\t \n\n\tstatus = acpi_ut_evaluate_numeric_object(METHOD_NAME__SEG,\n\t\t\t\t\t\t pci_root_node, &pci_value);\n\tif (ACPI_SUCCESS(status)) {\n\t\tpci_id->segment = ACPI_LOWORD(pci_value);\n\t}\n\n\t \n\n\tstatus = acpi_ut_evaluate_numeric_object(METHOD_NAME__BBN,\n\t\t\t\t\t\t pci_root_node, &pci_value);\n\tif (ACPI_SUCCESS(status)) {\n\t\tpci_id->bus = ACPI_LOWORD(pci_value);\n\t}\n\n\t \n\n\tstatus =\n\t    acpi_hw_derive_pci_id(pci_id, pci_root_node,\n\t\t\t\t  region_obj->region.node);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_FREE(pci_id);\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t*region_context = pci_id;\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nu8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node)\n{\n\tacpi_status status;\n\tstruct acpi_pnp_device_id *hid;\n\tstruct acpi_pnp_device_id_list *cid;\n\tu32 i;\n\tu8 match;\n\n\t \n\n\tstatus = acpi_ut_execute_HID(node, &hid);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (FALSE);\n\t}\n\n\tmatch = acpi_ut_is_pci_root_bridge(hid->string);\n\tACPI_FREE(hid);\n\n\tif (match) {\n\t\treturn (TRUE);\n\t}\n\n\t \n\n\tstatus = acpi_ut_execute_CID(node, &cid);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (FALSE);\n\t}\n\n\t \n\n\tfor (i = 0; i < cid->count; i++) {\n\t\tif (acpi_ut_is_pci_root_bridge(cid->ids[i].string)) {\n\t\t\tACPI_FREE(cid);\n\t\t\treturn (TRUE);\n\t\t}\n\t}\n\n\tACPI_FREE(cid);\n\treturn (FALSE);\n}\n\n \n\nacpi_status\nacpi_ev_pci_bar_region_setup(acpi_handle handle,\n\t\t\t     u32 function,\n\t\t\t     void *handler_context, void **region_context)\n{\n\tACPI_FUNCTION_TRACE(ev_pci_bar_region_setup);\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ev_cmos_region_setup(acpi_handle handle,\n\t\t\t  u32 function,\n\t\t\t  void *handler_context, void **region_context)\n{\n\tACPI_FUNCTION_TRACE(ev_cmos_region_setup);\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ev_data_table_region_setup(acpi_handle handle,\n\t\t\t\tu32 function,\n\t\t\t\tvoid *handler_context, void **region_context)\n{\n\tunion acpi_operand_object *region_desc =\n\t    (union acpi_operand_object *)handle;\n\tstruct acpi_data_table_mapping *local_region_context;\n\n\tACPI_FUNCTION_TRACE(ev_data_table_region_setup);\n\n\tif (function == ACPI_REGION_DEACTIVATE) {\n\t\tif (*region_context) {\n\t\t\tACPI_FREE(*region_context);\n\t\t\t*region_context = NULL;\n\t\t}\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tlocal_region_context =\n\t    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_data_table_mapping));\n\tif (!(local_region_context)) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tlocal_region_context->pointer = region_desc->region.pointer;\n\n\t*region_context = local_region_context;\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ev_default_region_setup(acpi_handle handle,\n\t\t\t     u32 function,\n\t\t\t     void *handler_context, void **region_context)\n{\n\tACPI_FUNCTION_TRACE(ev_default_region_setup);\n\n\tif (function == ACPI_REGION_DEACTIVATE) {\n\t\t*region_context = NULL;\n\t} else {\n\t\t*region_context = handler_context;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status acpi_ev_initialize_region(union acpi_operand_object *region_obj)\n{\n\tunion acpi_operand_object *handler_obj;\n\tunion acpi_operand_object *obj_desc;\n\tacpi_adr_space_type space_id;\n\tstruct acpi_namespace_node *node;\n\n\tACPI_FUNCTION_TRACE(ev_initialize_region);\n\n\tif (!region_obj) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tif (region_obj->common.flags & AOPOBJ_OBJECT_INITIALIZED) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\tregion_obj->common.flags |= AOPOBJ_OBJECT_INITIALIZED;\n\n\tnode = region_obj->region.node->parent;\n\tspace_id = region_obj->region.space_id;\n\n\t \n\twhile (node) {\n\n\t\t \n\n\t\thandler_obj = NULL;\n\t\tobj_desc = acpi_ns_get_attached_object(node);\n\t\tif (obj_desc) {\n\n\t\t\t \n\n\t\t\tswitch (node->type) {\n\t\t\tcase ACPI_TYPE_DEVICE:\n\t\t\tcase ACPI_TYPE_PROCESSOR:\n\t\t\tcase ACPI_TYPE_THERMAL:\n\n\t\t\t\thandler_obj = obj_desc->common_notify.handler;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\t \n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\thandler_obj =\n\t\t\t    acpi_ev_find_region_handler(space_id, handler_obj);\n\t\t\tif (handler_obj) {\n\n\t\t\t\t \n\n\t\t\t\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t\t\t\t  \"Found handler %p for region %p in obj %p\\n\",\n\t\t\t\t\t\t  handler_obj, region_obj,\n\t\t\t\t\t\t  obj_desc));\n\n\t\t\t\t(void)acpi_ev_attach_region(handler_obj,\n\t\t\t\t\t\t\t    region_obj, FALSE);\n\n\t\t\t\t \n\t\t\t\tacpi_ex_exit_interpreter();\n\t\t\t\t(void)acpi_ev_execute_reg_method(region_obj,\n\t\t\t\t\t\t\t\t ACPI_REG_CONNECT);\n\t\t\t\tacpi_ex_enter_interpreter();\n\t\t\t\treturn_ACPI_STATUS(AE_OK);\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tnode = node->parent;\n\t}\n\n\t \n\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t  \"No handler for RegionType %s(%X) (RegionObj %p)\\n\",\n\t\t\t  acpi_ut_get_region_name(space_id), space_id,\n\t\t\t  region_obj));\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}