{
  "module_name": "nsparse.c",
  "hash_id": "87562a64308ccdbd51db639830a51837cac575e3585792912a2fc477398a4370",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/nsparse.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"acparser.h\"\n#include \"acdispat.h\"\n#include \"actables.h\"\n#include \"acinterp.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\nACPI_MODULE_NAME(\"nsparse\")\n\n \nacpi_status\nacpi_ns_execute_table(u32 table_index, struct acpi_namespace_node *start_node)\n{\n\tacpi_status status;\n\tstruct acpi_table_header *table;\n\tacpi_owner_id owner_id;\n\tstruct acpi_evaluate_info *info = NULL;\n\tu32 aml_length;\n\tu8 *aml_start;\n\tunion acpi_operand_object *method_obj = NULL;\n\n\tACPI_FUNCTION_TRACE(ns_execute_table);\n\n\tstatus = acpi_get_table_by_index(table_index, &table);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tif (table->length < sizeof(struct acpi_table_header)) {\n\t\treturn_ACPI_STATUS(AE_BAD_HEADER);\n\t}\n\n\taml_start = (u8 *)table + sizeof(struct acpi_table_header);\n\taml_length = table->length - sizeof(struct acpi_table_header);\n\n\tstatus = acpi_tb_get_owner_id(table_index, &owner_id);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tmethod_obj = acpi_ut_create_internal_object(ACPI_TYPE_METHOD);\n\tif (!method_obj) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tinfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\n\tif (!info) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_PARSE,\n\t\t\t      \"%s: Create table pseudo-method for [%4.4s] @%p, method %p\\n\",\n\t\t\t      ACPI_GET_FUNCTION_NAME, table->signature, table,\n\t\t\t      method_obj));\n\n\tmethod_obj->method.aml_start = aml_start;\n\tmethod_obj->method.aml_length = aml_length;\n\tmethod_obj->method.owner_id = owner_id;\n\tmethod_obj->method.info_flags |= ACPI_METHOD_MODULE_LEVEL;\n\n\tinfo->pass_number = ACPI_IMODE_EXECUTE;\n\tinfo->node = start_node;\n\tinfo->obj_desc = method_obj;\n\tinfo->node_flags = info->node->flags;\n\tinfo->full_pathname = acpi_ns_get_normalized_pathname(info->node, TRUE);\n\tif (!info->full_pathname) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_EVALUATION,\n\t\t\t      \"%-26s:  (Definition Block level)\\n\",\n\t\t\t      \"Module-level evaluation\"));\n\n\tstatus = acpi_ps_execute_table(info);\n\n\t \n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_EVALUATION,\n\t\t\t      \"%-26s:  (Definition Block level)\\n\",\n\t\t\t      \"Module-level complete\"));\n\ncleanup:\n\tif (info) {\n\t\tACPI_FREE(info->full_pathname);\n\t\tinfo->full_pathname = NULL;\n\t}\n\tACPI_FREE(info);\n\tacpi_ut_remove_reference(method_obj);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ns_one_complete_parse(u32 pass_number,\n\t\t\t   u32 table_index,\n\t\t\t   struct acpi_namespace_node *start_node)\n{\n\tunion acpi_parse_object *parse_root;\n\tacpi_status status;\n\tu32 aml_length;\n\tu8 *aml_start;\n\tstruct acpi_walk_state *walk_state;\n\tstruct acpi_table_header *table;\n\tacpi_owner_id owner_id;\n\n\tACPI_FUNCTION_TRACE(ns_one_complete_parse);\n\n\tstatus = acpi_get_table_by_index(table_index, &table);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tif (table->length < sizeof(struct acpi_table_header)) {\n\t\treturn_ACPI_STATUS(AE_BAD_HEADER);\n\t}\n\n\taml_start = (u8 *)table + sizeof(struct acpi_table_header);\n\taml_length = table->length - sizeof(struct acpi_table_header);\n\n\tstatus = acpi_tb_get_owner_id(table_index, &owner_id);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tparse_root = acpi_ps_create_scope_op(aml_start);\n\tif (!parse_root) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\twalk_state = acpi_ds_create_walk_state(owner_id, NULL, NULL, NULL);\n\tif (!walk_state) {\n\t\tacpi_ps_free_op(parse_root);\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tstatus = acpi_ds_init_aml_walk(walk_state, parse_root, NULL,\n\t\t\t\t       aml_start, aml_length, NULL,\n\t\t\t\t       (u8)pass_number);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ds_delete_walk_state(walk_state);\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tif (ACPI_COMPARE_NAMESEG(table->signature, ACPI_SIG_OSDT) &&\n\t    pass_number == ACPI_IMODE_LOAD_PASS1) {\n\t\twalk_state->namespace_override = TRUE;\n\t}\n\n\t \n\n\tif (start_node && start_node != acpi_gbl_root_node) {\n\t\tstatus =\n\t\t    acpi_ds_scope_stack_push(start_node, ACPI_TYPE_METHOD,\n\t\t\t\t\t     walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_ds_delete_walk_state(walk_state);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\n\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t  \"*PARSE* pass %u parse\\n\", pass_number));\n\tacpi_ex_enter_interpreter();\n\tstatus = acpi_ps_parse_aml(walk_state);\n\tacpi_ex_exit_interpreter();\n\ncleanup:\n\tacpi_ps_delete_parse_tree(parse_root);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ns_parse_table);\n\n\t \n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_PARSE,\n\t\t\t      \"%s: **** Start table execution pass\\n\",\n\t\t\t      ACPI_GET_FUNCTION_NAME));\n\n\tstatus = acpi_ns_execute_table(table_index, start_node);\n\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}