{
  "module_name": "evhandler.c",
  "hash_id": "09882563c1c73bd9f4f4126d40081f26cd5f0bd5762681675fd92a32873576df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evhandler.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n#include \"acnamesp.h\"\n#include \"acinterp.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evhandler\")\n\n \nstatic acpi_status\nacpi_ev_install_handler(acpi_handle obj_handle,\n\t\t\tu32 level, void *context, void **return_value);\n\n \n\nu8 acpi_gbl_default_address_spaces[ACPI_NUM_DEFAULT_SPACES] = {\n\tACPI_ADR_SPACE_SYSTEM_MEMORY,\n\tACPI_ADR_SPACE_SYSTEM_IO,\n\tACPI_ADR_SPACE_PCI_CONFIG,\n\tACPI_ADR_SPACE_DATA_TABLE\n};\n\n \n\nacpi_status acpi_ev_install_region_handlers(void)\n{\n\tacpi_status status;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ev_install_region_handlers);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tfor (i = 0; i < ACPI_NUM_DEFAULT_SPACES; i++) {\n\t\tstatus = acpi_ev_install_space_handler(acpi_gbl_root_node,\n\t\t\t\t\t\t       acpi_gbl_default_address_spaces\n\t\t\t\t\t\t       [i],\n\t\t\t\t\t\t       ACPI_DEFAULT_HANDLER,\n\t\t\t\t\t\t       NULL, NULL);\n\t\tswitch (status) {\n\t\tcase AE_OK:\n\t\tcase AE_SAME_HANDLER:\n\t\tcase AE_ALREADY_EXISTS:\n\n\t\t\t \n\n\t\t\tstatus = AE_OK;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\t}\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nu8\nacpi_ev_has_default_handler(struct acpi_namespace_node *node,\n\t\t\t    acpi_adr_space_type space_id)\n{\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_operand_object *handler_obj;\n\n\t \n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (obj_desc) {\n\t\thandler_obj = obj_desc->common_notify.handler;\n\n\t\t \n\n\t\twhile (handler_obj) {\n\t\t\tif (handler_obj->address_space.space_id == space_id) {\n\t\t\t\tif (handler_obj->address_space.handler_flags &\n\t\t\t\t    ACPI_ADDR_HANDLER_DEFAULT_INSTALLED) {\n\t\t\t\t\treturn (TRUE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thandler_obj = handler_obj->address_space.next;\n\t\t}\n\t}\n\n\treturn (FALSE);\n}\n\n \n\nstatic acpi_status\nacpi_ev_install_handler(acpi_handle obj_handle,\n\t\t\tu32 level, void *context, void **return_value)\n{\n\tunion acpi_operand_object *handler_obj;\n\tunion acpi_operand_object *next_handler_obj;\n\tunion acpi_operand_object *obj_desc;\n\tstruct acpi_namespace_node *node;\n\tacpi_status status;\n\n\tACPI_FUNCTION_NAME(ev_install_handler);\n\n\thandler_obj = (union acpi_operand_object *)context;\n\n\t \n\n\tif (!handler_obj) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tnode = acpi_ns_validate_handle(obj_handle);\n\tif (!node) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\tif ((node->type != ACPI_TYPE_DEVICE) &&\n\t    (node->type != ACPI_TYPE_REGION) && (node != acpi_gbl_root_node)) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (!obj_desc) {\n\n\t\t \n\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tif (obj_desc->common.type == ACPI_TYPE_DEVICE) {\n\n\t\t \n\n\t\tnext_handler_obj =\n\t\t    acpi_ev_find_region_handler(handler_obj->address_space.\n\t\t\t\t\t\tspace_id,\n\t\t\t\t\t\tobj_desc->common_notify.\n\t\t\t\t\t\thandler);\n\t\tif (next_handler_obj) {\n\n\t\t\t \n\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t\t\t  \"Found handler for region [%s] in device %p(%p) handler %p\\n\",\n\t\t\t\t\t  acpi_ut_get_region_name(handler_obj->\n\t\t\t\t\t\t\t\t  address_space.\n\t\t\t\t\t\t\t\t  space_id),\n\t\t\t\t\t  obj_desc, next_handler_obj,\n\t\t\t\t\t  handler_obj));\n\n\t\t\t \n\t\t\treturn (AE_CTRL_DEPTH);\n\t\t}\n\n\t\t \n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tif (obj_desc->region.space_id != handler_obj->address_space.space_id) {\n\n\t\t \n\n\t\treturn (AE_OK);\n\t}\n\n\t \n\tacpi_ev_detach_region(obj_desc, FALSE);\n\n\t \n\n\tstatus = acpi_ev_attach_region(handler_obj, obj_desc, FALSE);\n\treturn (status);\n}\n\n \n\nunion acpi_operand_object *acpi_ev_find_region_handler(acpi_adr_space_type\n\t\t\t\t\t\t       space_id,\n\t\t\t\t\t\t       union acpi_operand_object\n\t\t\t\t\t\t       *handler_obj)\n{\n\n\t \n\n\twhile (handler_obj) {\n\n\t\t \n\n\t\tif (handler_obj->address_space.space_id == space_id) {\n\t\t\treturn (handler_obj);\n\t\t}\n\n\t\t \n\n\t\thandler_obj = handler_obj->address_space.next;\n\t}\n\n\treturn (NULL);\n}\n\n \n\nacpi_status\nacpi_ev_install_space_handler(struct acpi_namespace_node *node,\n\t\t\t      acpi_adr_space_type space_id,\n\t\t\t      acpi_adr_space_handler handler,\n\t\t\t      acpi_adr_space_setup setup, void *context)\n{\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_operand_object *handler_obj;\n\tacpi_status status = AE_OK;\n\tacpi_object_type type;\n\tu8 flags = 0;\n\n\tACPI_FUNCTION_TRACE(ev_install_space_handler);\n\n\t \n\tif ((node->type != ACPI_TYPE_DEVICE) &&\n\t    (node->type != ACPI_TYPE_PROCESSOR) &&\n\t    (node->type != ACPI_TYPE_THERMAL) && (node != acpi_gbl_root_node)) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\tif (handler == ACPI_DEFAULT_HANDLER) {\n\t\tflags = ACPI_ADDR_HANDLER_DEFAULT_INSTALLED;\n\n\t\tswitch (space_id) {\n\t\tcase ACPI_ADR_SPACE_SYSTEM_MEMORY:\n\n\t\t\thandler = acpi_ex_system_memory_space_handler;\n\t\t\tsetup = acpi_ev_system_memory_region_setup;\n\t\t\tbreak;\n\n\t\tcase ACPI_ADR_SPACE_SYSTEM_IO:\n\n\t\t\thandler = acpi_ex_system_io_space_handler;\n\t\t\tsetup = acpi_ev_io_space_region_setup;\n\t\t\tbreak;\n#ifdef ACPI_PCI_CONFIGURED\n\t\tcase ACPI_ADR_SPACE_PCI_CONFIG:\n\n\t\t\thandler = acpi_ex_pci_config_space_handler;\n\t\t\tsetup = acpi_ev_pci_config_region_setup;\n\t\t\tbreak;\n#endif\n\t\tcase ACPI_ADR_SPACE_CMOS:\n\n\t\t\thandler = acpi_ex_cmos_space_handler;\n\t\t\tsetup = acpi_ev_cmos_region_setup;\n\t\t\tbreak;\n#ifdef ACPI_PCI_CONFIGURED\n\t\tcase ACPI_ADR_SPACE_PCI_BAR_TARGET:\n\n\t\t\thandler = acpi_ex_pci_bar_space_handler;\n\t\t\tsetup = acpi_ev_pci_bar_region_setup;\n\t\t\tbreak;\n#endif\n\t\tcase ACPI_ADR_SPACE_DATA_TABLE:\n\n\t\t\thandler = acpi_ex_data_table_space_handler;\n\t\t\tsetup = acpi_ev_data_table_region_setup;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tstatus = AE_BAD_PARAMETER;\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\t}\n\n\t \n\n\tif (!setup) {\n\t\tsetup = acpi_ev_default_region_setup;\n\t}\n\n\t \n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (obj_desc) {\n\t\t \n\t\thandler_obj = acpi_ev_find_region_handler(space_id,\n\t\t\t\t\t\t\t  obj_desc->\n\t\t\t\t\t\t\t  common_notify.\n\t\t\t\t\t\t\t  handler);\n\n\t\tif (handler_obj) {\n\t\t\tif (handler_obj->address_space.handler == handler) {\n\t\t\t\t \n\t\t\t\tstatus = AE_SAME_HANDLER;\n\t\t\t\tgoto unlock_and_exit;\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\tstatus = AE_ALREADY_EXISTS;\n\t\t\t}\n\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\t} else {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t\t  \"Creating object on Device %p while installing handler\\n\",\n\t\t\t\t  node));\n\n\t\t \n\n\t\tif (node->type == ACPI_TYPE_ANY) {\n\t\t\ttype = ACPI_TYPE_DEVICE;\n\t\t} else {\n\t\t\ttype = node->type;\n\t\t}\n\n\t\tobj_desc = acpi_ut_create_internal_object(type);\n\t\tif (!obj_desc) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\n\t\t \n\n\t\tobj_desc->common.type = (u8)type;\n\n\t\t \n\n\t\tstatus = acpi_ns_attach_object(node, obj_desc, type);\n\n\t\t \n\n\t\tacpi_ut_remove_reference(obj_desc);\n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t  \"Installing address handler for region %s(%X) \"\n\t\t\t  \"on Device %4.4s %p(%p)\\n\",\n\t\t\t  acpi_ut_get_region_name(space_id), space_id,\n\t\t\t  acpi_ut_get_node_name(node), node, obj_desc));\n\n\t \n\thandler_obj =\n\t    acpi_ut_create_internal_object(ACPI_TYPE_LOCAL_ADDRESS_HANDLER);\n\tif (!handler_obj) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tstatus =\n\t    acpi_os_create_mutex(&handler_obj->address_space.context_mutex);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ut_remove_reference(handler_obj);\n\t\tgoto unlock_and_exit;\n\t}\n\n\thandler_obj->address_space.space_id = (u8)space_id;\n\thandler_obj->address_space.handler_flags = flags;\n\thandler_obj->address_space.region_list = NULL;\n\thandler_obj->address_space.node = node;\n\thandler_obj->address_space.handler = handler;\n\thandler_obj->address_space.context = context;\n\thandler_obj->address_space.setup = setup;\n\n\t \n\n\thandler_obj->address_space.next = obj_desc->common_notify.handler;\n\n\t \n\tobj_desc->common_notify.handler = handler_obj;\n\n\t \n\tstatus = acpi_ns_walk_namespace(ACPI_TYPE_ANY, node,\n\t\t\t\t\tACPI_UINT32_MAX, ACPI_NS_WALK_UNLOCK,\n\t\t\t\t\tacpi_ev_install_handler, NULL,\n\t\t\t\t\thandler_obj, NULL);\n\nunlock_and_exit:\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}