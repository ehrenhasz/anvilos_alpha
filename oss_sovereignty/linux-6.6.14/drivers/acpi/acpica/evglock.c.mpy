{
  "module_name": "evglock.c",
  "hash_id": "5a8601dc5a87e6380fbdbf4eeb24e7fcbee137316851be375e260f80989972b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evglock.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n#include \"acinterp.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evglock\")\n#if (!ACPI_REDUCED_HARDWARE)\t \n \nstatic u32 acpi_ev_global_lock_handler(void *context);\n\n \n\nacpi_status acpi_ev_init_global_lock_handler(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ev_init_global_lock_handler);\n\n\t \n\n\tif (acpi_gbl_reduced_hardware) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tstatus = acpi_install_fixed_event_handler(ACPI_EVENT_GLOBAL,\n\t\t\t\t\t\t  acpi_ev_global_lock_handler,\n\t\t\t\t\t\t  NULL);\n\n\t \n\tacpi_gbl_global_lock_present = FALSE;\n\tif (status == AE_NO_HARDWARE_RESPONSE) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"No response from Global Lock hardware, disabling lock\"));\n\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\tstatus = acpi_os_create_lock(&acpi_gbl_global_lock_pending_lock);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tacpi_gbl_global_lock_pending = FALSE;\n\tacpi_gbl_global_lock_present = TRUE;\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ev_remove_global_lock_handler(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ev_remove_global_lock_handler);\n\n\tacpi_gbl_global_lock_present = FALSE;\n\tstatus = acpi_remove_fixed_event_handler(ACPI_EVENT_GLOBAL,\n\t\t\t\t\t\t acpi_ev_global_lock_handler);\n\n\tacpi_os_delete_lock(acpi_gbl_global_lock_pending_lock);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic u32 acpi_ev_global_lock_handler(void *context)\n{\n\tacpi_status status;\n\tacpi_cpu_flags flags;\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_global_lock_pending_lock);\n\n\t \n\tif (!acpi_gbl_global_lock_pending) {\n\t\tgoto cleanup_and_exit;\n\t}\n\n\t \n\tstatus = acpi_os_signal_semaphore(acpi_gbl_global_lock_semaphore, 1);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_ERROR((AE_INFO, \"Could not signal Global Lock semaphore\"));\n\t}\n\n\tacpi_gbl_global_lock_pending = FALSE;\n\ncleanup_and_exit:\n\n\tacpi_os_release_lock(acpi_gbl_global_lock_pending_lock, flags);\n\treturn (ACPI_INTERRUPT_HANDLED);\n}\n\n \n\nacpi_status acpi_ev_acquire_global_lock(u16 timeout)\n{\n\tacpi_cpu_flags flags;\n\tacpi_status status;\n\tu8 acquired = FALSE;\n\n\tACPI_FUNCTION_TRACE(ev_acquire_global_lock);\n\n\t \n\tstatus =\n\t    acpi_ex_system_wait_mutex(acpi_gbl_global_lock_mutex->mutex.\n\t\t\t\t      os_mutex, timeout);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tacpi_gbl_global_lock_handle++;\n\tif (acpi_gbl_global_lock_handle == 0) {\n\t\tacpi_gbl_global_lock_handle = 1;\n\t}\n\n\t \n\tif (!acpi_gbl_global_lock_present) {\n\t\tacpi_gbl_global_lock_acquired = TRUE;\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_global_lock_pending_lock);\n\n\tdo {\n\n\t\t \n\n\t\tACPI_ACQUIRE_GLOBAL_LOCK(acpi_gbl_FACS, acquired);\n\t\tif (acquired) {\n\t\t\tacpi_gbl_global_lock_acquired = TRUE;\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t\t\t  \"Acquired hardware Global Lock\\n\"));\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tacpi_gbl_global_lock_pending = TRUE;\n\t\tacpi_os_release_lock(acpi_gbl_global_lock_pending_lock, flags);\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t\t  \"Waiting for hardware Global Lock\\n\"));\n\n\t\t \n\t\tstatus =\n\t\t    acpi_ex_system_wait_semaphore\n\t\t    (acpi_gbl_global_lock_semaphore, ACPI_WAIT_FOREVER);\n\n\t\tflags = acpi_os_acquire_lock(acpi_gbl_global_lock_pending_lock);\n\n\t} while (ACPI_SUCCESS(status));\n\n\tacpi_gbl_global_lock_pending = FALSE;\n\tacpi_os_release_lock(acpi_gbl_global_lock_pending_lock, flags);\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ev_release_global_lock(void)\n{\n\tu8 pending = FALSE;\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(ev_release_global_lock);\n\n\t \n\n\tif (!acpi_gbl_global_lock_acquired) {\n\t\tACPI_WARNING((AE_INFO,\n\t\t\t      \"Cannot release the ACPI Global Lock, it has not been acquired\"));\n\t\treturn_ACPI_STATUS(AE_NOT_ACQUIRED);\n\t}\n\n\tif (acpi_gbl_global_lock_present) {\n\n\t\t \n\n\t\tACPI_RELEASE_GLOBAL_LOCK(acpi_gbl_FACS, pending);\n\n\t\t \n\t\tif (pending) {\n\t\t\tstatus =\n\t\t\t    acpi_write_bit_register\n\t\t\t    (ACPI_BITREG_GLOBAL_LOCK_RELEASE,\n\t\t\t     ACPI_ENABLE_EVENT);\n\t\t}\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t\t  \"Released hardware Global Lock\\n\"));\n\t}\n\n\tacpi_gbl_global_lock_acquired = FALSE;\n\n\t \n\n\tacpi_os_release_mutex(acpi_gbl_global_lock_mutex->mutex.os_mutex);\n\treturn_ACPI_STATUS(status);\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}