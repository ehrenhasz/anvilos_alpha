{
  "module_name": "dsutils.c",
  "hash_id": "11ee5d164d013f6314bae7c36aa60b0c77299ba4fd071d34ee1d9d0e6f6f9d74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/dsutils.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acparser.h\"\n#include \"amlcode.h\"\n#include \"acdispat.h\"\n#include \"acinterp.h\"\n#include \"acnamesp.h\"\n#include \"acdebug.h\"\n\n#define _COMPONENT          ACPI_DISPATCHER\nACPI_MODULE_NAME(\"dsutils\")\n\n \nvoid acpi_ds_clear_implicit_return(struct acpi_walk_state *walk_state)\n{\n\tACPI_FUNCTION_NAME(ds_clear_implicit_return);\n\n\t \n\tif (!acpi_gbl_enable_interpreter_slack) {\n\t\treturn;\n\t}\n\n\tif (walk_state->implicit_return_obj) {\n\t\t \n\t\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t\t  \"Removing reference on stale implicit return obj %p\\n\",\n\t\t\t\t  walk_state->implicit_return_obj));\n\n\t\tacpi_ut_remove_reference(walk_state->implicit_return_obj);\n\t\twalk_state->implicit_return_obj = NULL;\n\t}\n}\n\n \n\nu8\nacpi_ds_do_implicit_return(union acpi_operand_object *return_desc,\n\t\t\t   struct acpi_walk_state *walk_state, u8 add_reference)\n{\n\tACPI_FUNCTION_NAME(ds_do_implicit_return);\n\n\t \n\tif ((!acpi_gbl_enable_interpreter_slack) || (!return_desc)) {\n\t\treturn (FALSE);\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  \"Result %p will be implicitly returned; Prev=%p\\n\",\n\t\t\t  return_desc, walk_state->implicit_return_obj));\n\n\t \n\tif (walk_state->implicit_return_obj) {\n\t\tif (walk_state->implicit_return_obj == return_desc) {\n\t\t\treturn (TRUE);\n\t\t}\n\t\tacpi_ds_clear_implicit_return(walk_state);\n\t}\n\n\t \n\n\twalk_state->implicit_return_obj = return_desc;\n\tif (add_reference) {\n\t\tacpi_ut_add_reference(return_desc);\n\t}\n\n\treturn (TRUE);\n}\n\n \n\nu8\nacpi_ds_is_result_used(union acpi_parse_object * op,\n\t\t       struct acpi_walk_state * walk_state)\n{\n\tconst struct acpi_opcode_info *parent_info;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_is_result_used, op);\n\n\t \n\n\tif (!op) {\n\t\tACPI_ERROR((AE_INFO, \"Null Op\"));\n\t\treturn_UINT8(TRUE);\n\t}\n\n\t \n\t(void)acpi_ds_do_implicit_return(walk_state->result_obj, walk_state,\n\t\t\t\t\t TRUE);\n\n\t \n\tif ((!op->common.parent) ||\n\t    (op->common.parent->common.aml_opcode == AML_SCOPE_OP)) {\n\n\t\t \n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t\t  \"At Method level, result of [%s] not used\\n\",\n\t\t\t\t  acpi_ps_get_opcode_name(op->common.\n\t\t\t\t\t\t\t  aml_opcode)));\n\t\treturn_UINT8(FALSE);\n\t}\n\n\t \n\n\tparent_info =\n\t    acpi_ps_get_opcode_info(op->common.parent->common.aml_opcode);\n\tif (parent_info->class == AML_CLASS_UNKNOWN) {\n\t\tACPI_ERROR((AE_INFO, \"Unknown parent opcode Op=%p\", op));\n\t\treturn_UINT8(FALSE);\n\t}\n\n\t \n\tswitch (parent_info->class) {\n\tcase AML_CLASS_CONTROL:\n\n\t\tswitch (op->common.parent->common.aml_opcode) {\n\t\tcase AML_RETURN_OP:\n\n\t\t\t \n\n\t\t\tgoto result_used;\n\n\t\tcase AML_IF_OP:\n\t\tcase AML_WHILE_OP:\n\t\t\t \n\t\t\tif ((walk_state->control_state->common.state ==\n\t\t\t     ACPI_CONTROL_PREDICATE_EXECUTING) &&\n\t\t\t    (walk_state->control_state->control.predicate_op ==\n\t\t\t     op)) {\n\t\t\t\tgoto result_used;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\t \n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tgoto result_not_used;\n\n\tcase AML_CLASS_CREATE:\n\t\t \n\t\tgoto result_used;\n\n\tcase AML_CLASS_NAMED_OBJECT:\n\n\t\tif ((op->common.parent->common.aml_opcode == AML_REGION_OP) ||\n\t\t    (op->common.parent->common.aml_opcode == AML_DATA_REGION_OP)\n\t\t    || (op->common.parent->common.aml_opcode == AML_PACKAGE_OP)\n\t\t    || (op->common.parent->common.aml_opcode == AML_BUFFER_OP)\n\t\t    || (op->common.parent->common.aml_opcode ==\n\t\t\tAML_VARIABLE_PACKAGE_OP)\n\t\t    || (op->common.parent->common.aml_opcode ==\n\t\t\tAML_INT_EVAL_SUBTREE_OP)\n\t\t    || (op->common.parent->common.aml_opcode ==\n\t\t\tAML_BANK_FIELD_OP)) {\n\t\t\t \n\t\t\tgoto result_used;\n\t\t}\n\n\t\tgoto result_not_used;\n\n\tdefault:\n\t\t \n\t\tgoto result_used;\n\t}\n\nresult_used:\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  \"Result of [%s] used by Parent [%s] Op=%p\\n\",\n\t\t\t  acpi_ps_get_opcode_name(op->common.aml_opcode),\n\t\t\t  acpi_ps_get_opcode_name(op->common.parent->common.\n\t\t\t\t\t\t  aml_opcode), op));\n\n\treturn_UINT8(TRUE);\n\nresult_not_used:\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  \"Result of [%s] not used by Parent [%s] Op=%p\\n\",\n\t\t\t  acpi_ps_get_opcode_name(op->common.aml_opcode),\n\t\t\t  acpi_ps_get_opcode_name(op->common.parent->common.\n\t\t\t\t\t\t  aml_opcode), op));\n\n\treturn_UINT8(FALSE);\n}\n\n \n\nvoid\nacpi_ds_delete_result_if_not_used(union acpi_parse_object *op,\n\t\t\t\t  union acpi_operand_object *result_obj,\n\t\t\t\t  struct acpi_walk_state *walk_state)\n{\n\tunion acpi_operand_object *obj_desc;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_delete_result_if_not_used, result_obj);\n\n\tif (!op) {\n\t\tACPI_ERROR((AE_INFO, \"Null Op\"));\n\t\treturn_VOID;\n\t}\n\n\tif (!result_obj) {\n\t\treturn_VOID;\n\t}\n\n\tif (!acpi_ds_is_result_used(op, walk_state)) {\n\n\t\t \n\n\t\tstatus = acpi_ds_result_pop(&obj_desc, walk_state);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tacpi_ut_remove_reference(result_obj);\n\t\t}\n\t}\n\n\treturn_VOID;\n}\n\n \n\nacpi_status acpi_ds_resolve_operands(struct acpi_walk_state *walk_state)\n{\n\tu32 i;\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_resolve_operands, walk_state);\n\n\t \n\tfor (i = 0; i < walk_state->num_operands; i++) {\n\t\tstatus =\n\t\t    acpi_ex_resolve_to_value(&walk_state->operands[i],\n\t\t\t\t\t     walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nvoid acpi_ds_clear_operands(struct acpi_walk_state *walk_state)\n{\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_clear_operands, walk_state);\n\n\t \n\n\tfor (i = 0; i < walk_state->num_operands; i++) {\n\t\t \n\t\tacpi_ut_remove_reference(walk_state->operands[i]);\n\t\twalk_state->operands[i] = NULL;\n\t}\n\n\twalk_state->num_operands = 0;\n\treturn_VOID;\n}\n\n \n\nacpi_status\nacpi_ds_create_operand(struct acpi_walk_state *walk_state,\n\t\t       union acpi_parse_object *arg, u32 arg_index)\n{\n\tacpi_status status = AE_OK;\n\tchar *name_string;\n\tu32 name_length;\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_parse_object *parent_op;\n\tu16 opcode;\n\tacpi_interpreter_mode interpreter_mode;\n\tconst struct acpi_opcode_info *op_info;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_create_operand, arg);\n\n\t \n\n\tif ((arg->common.aml_opcode == AML_INT_NAMEPATH_OP) &&\n\t    (arg->common.value.string) &&\n\t    !(arg->common.flags & ACPI_PARSEOP_IN_STACK)) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH, \"Getting a name: Arg=%p\\n\",\n\t\t\t\t  arg));\n\n\t\t \n\n\t\tstatus = acpi_ex_get_name_string(ACPI_TYPE_ANY,\n\t\t\t\t\t\t arg->common.value.buffer,\n\t\t\t\t\t\t &name_string, &name_length);\n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif ((walk_state->deferred_node) &&\n\t\t    (walk_state->deferred_node->type == ACPI_TYPE_BUFFER_FIELD)\n\t\t    && (arg_index == (u32)\n\t\t\t((walk_state->opcode == AML_CREATE_FIELD_OP) ? 3 : 2))) {\n\t\t\tobj_desc =\n\t\t\t    ACPI_CAST_PTR(union acpi_operand_object,\n\t\t\t\t\t  walk_state->deferred_node);\n\t\t\tstatus = AE_OK;\n\t\t} else {\t \n\n\t\t\t \n\t\t\tparent_op = arg->common.parent;\n\t\t\top_info =\n\t\t\t    acpi_ps_get_opcode_info(parent_op->common.\n\t\t\t\t\t\t    aml_opcode);\n\n\t\t\tif ((op_info->flags & AML_NSNODE) &&\n\t\t\t    (parent_op->common.aml_opcode !=\n\t\t\t     AML_INT_METHODCALL_OP)\n\t\t\t    && (parent_op->common.aml_opcode != AML_REGION_OP)\n\t\t\t    && (parent_op->common.aml_opcode !=\n\t\t\t\tAML_INT_NAMEPATH_OP)) {\n\n\t\t\t\t \n\n\t\t\t\tinterpreter_mode = ACPI_IMODE_LOAD_PASS2;\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\tinterpreter_mode = ACPI_IMODE_EXECUTE;\n\t\t\t}\n\n\t\t\tstatus =\n\t\t\t    acpi_ns_lookup(walk_state->scope_info, name_string,\n\t\t\t\t\t   ACPI_TYPE_ANY, interpreter_mode,\n\t\t\t\t\t   ACPI_NS_SEARCH_PARENT |\n\t\t\t\t\t   ACPI_NS_DONT_OPEN_SCOPE, walk_state,\n\t\t\t\t\t   ACPI_CAST_INDIRECT_PTR(struct\n\t\t\t\t\t\t\t\t  acpi_namespace_node,\n\t\t\t\t\t\t\t\t  &obj_desc));\n\t\t\t \n\t\t\tif (status == AE_NOT_FOUND) {\n\t\t\t\tif (parent_op->common.aml_opcode ==\n\t\t\t\t    AML_CONDITIONAL_REF_OF_OP) {\n\t\t\t\t\t \n\t\t\t\t\tobj_desc =\n\t\t\t\t\t    ACPI_CAST_PTR(union\n\t\t\t\t\t\t\t\t acpi_operand_object,\n\t\t\t\t\t\t\t\t acpi_gbl_root_node);\n\t\t\t\t\tstatus = AE_OK;\n\t\t\t\t} else if (parent_op->common.aml_opcode ==\n\t\t\t\t\t   AML_EXTERNAL_OP) {\n\t\t\t\t\t \n\t\t\t\t\tstatus = AE_AML_BAD_OPCODE;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tstatus = AE_AML_NAME_NOT_FOUND;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tACPI_ERROR_NAMESPACE(walk_state->scope_info,\n\t\t\t\t\t\t     name_string, status);\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tACPI_FREE(name_string);\n\n\t\t \n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ds_obj_stack_push(obj_desc, walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\tacpi_db_display_argument_object(obj_desc, walk_state);\n\t} else {\n\t\t \n\n\t\tif ((arg->common.aml_opcode == AML_INT_NAMEPATH_OP) &&\n\t\t    !(arg->common.flags & ACPI_PARSEOP_IN_STACK)) {\n\t\t\t \n\t\t\topcode = AML_ZERO_OP;\t \n\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t\t\t  \"Null namepath: Arg=%p\\n\", arg));\n\t\t} else {\n\t\t\topcode = arg->common.aml_opcode;\n\t\t}\n\n\t\t \n\n\t\top_info = acpi_ps_get_opcode_info(opcode);\n\t\tif (op_info->object_type == ACPI_TYPE_INVALID) {\n\t\t\treturn_ACPI_STATUS(AE_NOT_IMPLEMENTED);\n\t\t}\n\n\t\tif ((op_info->flags & AML_HAS_RETVAL) ||\n\t\t    (arg->common.flags & ACPI_PARSEOP_IN_STACK)) {\n\t\t\t \n\t\t\tstatus = acpi_ds_result_pop(&obj_desc, walk_state);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t \n\t\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\t\"Missing or null operand\"));\n\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\n\t\t\tobj_desc =\n\t\t\t    acpi_ut_create_internal_object(op_info->\n\t\t\t\t\t\t\t   object_type);\n\t\t\tif (!obj_desc) {\n\t\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t\t}\n\n\t\t\t \n\n\t\t\tstatus =\n\t\t\t    acpi_ds_init_object_from_op(walk_state, arg, opcode,\n\t\t\t\t\t\t\t&obj_desc);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tacpi_ut_delete_object_desc(obj_desc);\n\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ds_obj_stack_push(obj_desc, walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\tacpi_db_display_argument_object(obj_desc, walk_state);\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ds_create_operands(struct acpi_walk_state *walk_state,\n\t\t\tunion acpi_parse_object *first_arg)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_parse_object *arg;\n\tunion acpi_parse_object *arguments[ACPI_OBJ_NUM_OPERANDS];\n\tu32 arg_count = 0;\n\tu32 index = walk_state->num_operands;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_create_operands, first_arg);\n\n\t \n\n\targ = first_arg;\n\twhile (arg) {\n\t\tif (index >= ACPI_OBJ_NUM_OPERANDS) {\n\t\t\treturn_ACPI_STATUS(AE_BAD_DATA);\n\t\t}\n\n\t\targuments[index] = arg;\n\t\twalk_state->operands[index] = NULL;\n\n\t\t \n\n\t\targ = arg->common.next;\n\t\targ_count++;\n\t\tindex++;\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  \"NumOperands %d, ArgCount %d, Index %d\\n\",\n\t\t\t  walk_state->num_operands, arg_count, index));\n\n\t \n\n\tindex--;\n\tfor (i = 0; i < arg_count; i++) {\n\t\targ = arguments[index];\n\t\twalk_state->operand_index = (u8)index;\n\n\t\tstatus = acpi_ds_create_operand(walk_state, arg, index);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t\t  \"Created Arg #%u (%p) %u args total\\n\",\n\t\t\t\t  index, arg, arg_count));\n\t\tindex--;\n\t}\n\n\treturn_ACPI_STATUS(status);\n\ncleanup:\n\t \n\tacpi_ds_obj_stack_pop_and_delete(arg_count, walk_state);\n\n\tACPI_EXCEPTION((AE_INFO, status, \"While creating Arg %u\", index));\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ds_evaluate_name_path(struct acpi_walk_state *walk_state)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_parse_object *op = walk_state->op;\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\tunion acpi_operand_object *new_obj_desc;\n\tu8 type;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_evaluate_name_path, walk_state);\n\n\tif (!op->common.parent) {\n\n\t\t \n\n\t\tgoto exit;\n\t}\n\n\tif ((op->common.parent->common.aml_opcode == AML_PACKAGE_OP) ||\n\t    (op->common.parent->common.aml_opcode == AML_VARIABLE_PACKAGE_OP) ||\n\t    (op->common.parent->common.aml_opcode == AML_REF_OF_OP)) {\n\n\t\t \n\n\t\tgoto exit;\n\t}\n\n\tstatus = acpi_ds_create_operand(walk_state, op, 0);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\tif (op->common.flags & ACPI_PARSEOP_TARGET) {\n\t\tnew_obj_desc = *operand;\n\t\tgoto push_result;\n\t}\n\n\ttype = (*operand)->common.type;\n\n\tstatus = acpi_ex_resolve_to_value(operand, walk_state);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\tif (type == ACPI_TYPE_INTEGER) {\n\n\t\t \n\n\t\tacpi_ut_remove_reference(*operand);\n\n\t\tstatus =\n\t\t    acpi_ut_copy_iobject_to_iobject(*operand, &new_obj_desc,\n\t\t\t\t\t\t    walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\t \n\t\tnew_obj_desc = *operand;\n\t}\n\n\t \n\n\tstatus = acpi_ds_obj_stack_pop(1, walk_state);\n\tif (ACPI_FAILURE(status)) {\n\t\twalk_state->result_obj = new_obj_desc;\n\t\tgoto exit;\n\t}\n\npush_result:\n\n\twalk_state->result_obj = new_obj_desc;\n\n\tstatus = acpi_ds_result_push(walk_state->result_obj, walk_state);\n\tif (ACPI_SUCCESS(status)) {\n\n\t\t \n\n\t\top->common.flags |= ACPI_PARSEOP_IN_STACK;\n\t}\n\nexit:\n\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}