{
  "module_name": "evxface.c",
  "hash_id": "a7604a6479d49a0f3508a59ab3ad175a7219e7eeeb9f85d652e2091f08e5a8da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evxface.c",
  "human_readable_source": "\n \n\n#define EXPORT_ACPI_INTERFACES\n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"acevents.h\"\n#include \"acinterp.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evxface\")\n#if (!ACPI_REDUCED_HARDWARE)\n \nstatic acpi_status\nacpi_ev_install_gpe_handler(acpi_handle gpe_device,\n\t\t\t    u32 gpe_number,\n\t\t\t    u32 type,\n\t\t\t    u8 is_raw_handler,\n\t\t\t    acpi_gpe_handler address, void *context);\n\n#endif\n\n\n \n\nacpi_status\nacpi_install_notify_handler(acpi_handle device,\n\t\t\t    u32 handler_type,\n\t\t\t    acpi_notify_handler handler, void *context)\n{\n\tstruct acpi_namespace_node *node =\n\t    ACPI_CAST_PTR(struct acpi_namespace_node, device);\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_operand_object *handler_obj;\n\tacpi_status status;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(acpi_install_notify_handler);\n\n\t \n\n\tif ((!device) || (!handler) || (!handler_type) ||\n\t    (handler_type > ACPI_MAX_NOTIFY_HANDLER_TYPE)) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tif (device == ACPI_ROOT_OBJECT) {\n\t\tfor (i = 0; i < ACPI_NUM_NOTIFY_TYPES; i++) {\n\t\t\tif (handler_type & (i + 1)) {\n\t\t\t\tif (acpi_gbl_global_notify[i].handler) {\n\t\t\t\t\tstatus = AE_ALREADY_EXISTS;\n\t\t\t\t\tgoto unlock_and_exit;\n\t\t\t\t}\n\n\t\t\t\tacpi_gbl_global_notify[i].handler = handler;\n\t\t\t\tacpi_gbl_global_notify[i].context = context;\n\t\t\t}\n\t\t}\n\n\t\tgoto unlock_and_exit;\t \n\t}\n\n\t \n\n\t \n\n\tif (!acpi_ev_is_notify_object(node)) {\n\t\tstatus = AE_TYPE;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (!obj_desc) {\n\n\t\t \n\n\t\tobj_desc = acpi_ut_create_internal_object(node->type);\n\t\tif (!obj_desc) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ns_attach_object(device, obj_desc, node->type);\n\t\tacpi_ut_remove_reference(obj_desc);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\t}\n\n\t \n\n\tfor (i = 0; i < ACPI_NUM_NOTIFY_TYPES; i++) {\n\t\tif (handler_type & (i + 1)) {\n\t\t\thandler_obj = obj_desc->common_notify.notify_list[i];\n\t\t\twhile (handler_obj) {\n\t\t\t\tif (handler_obj->notify.handler == handler) {\n\t\t\t\t\tstatus = AE_ALREADY_EXISTS;\n\t\t\t\t\tgoto unlock_and_exit;\n\t\t\t\t}\n\n\t\t\t\thandler_obj = handler_obj->notify.next[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\thandler_obj = acpi_ut_create_internal_object(ACPI_TYPE_LOCAL_NOTIFY);\n\tif (!handler_obj) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto unlock_and_exit;\n\t}\n\n\thandler_obj->notify.node = node;\n\thandler_obj->notify.handler_type = handler_type;\n\thandler_obj->notify.handler = handler;\n\thandler_obj->notify.context = context;\n\n\t \n\n\tfor (i = 0; i < ACPI_NUM_NOTIFY_TYPES; i++) {\n\t\tif (handler_type & (i + 1)) {\n\t\t\thandler_obj->notify.next[i] =\n\t\t\t    obj_desc->common_notify.notify_list[i];\n\n\t\t\tobj_desc->common_notify.notify_list[i] = handler_obj;\n\t\t}\n\t}\n\n\t \n\n\tif (handler_type == ACPI_ALL_NOTIFY) {\n\t\tacpi_ut_add_reference(handler_obj);\n\t}\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_install_notify_handler)\n\n \nacpi_status\nacpi_remove_notify_handler(acpi_handle device,\n\t\t\t   u32 handler_type, acpi_notify_handler handler)\n{\n\tstruct acpi_namespace_node *node =\n\t    ACPI_CAST_PTR(struct acpi_namespace_node, device);\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_operand_object *handler_obj;\n\tunion acpi_operand_object *previous_handler_obj;\n\tacpi_status status = AE_OK;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(acpi_remove_notify_handler);\n\n\t \n\n\tif ((!device) || (!handler) || (!handler_type) ||\n\t    (handler_type > ACPI_MAX_NOTIFY_HANDLER_TYPE)) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tif (device == ACPI_ROOT_OBJECT) {\n\t\tfor (i = 0; i < ACPI_NUM_NOTIFY_TYPES; i++) {\n\t\t\tif (handler_type & (i + 1)) {\n\t\t\t\tstatus =\n\t\t\t\t    acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t\t}\n\n\t\t\t\tif (!acpi_gbl_global_notify[i].handler ||\n\t\t\t\t    (acpi_gbl_global_notify[i].handler !=\n\t\t\t\t     handler)) {\n\t\t\t\t\tstatus = AE_NOT_EXIST;\n\t\t\t\t\tgoto unlock_and_exit;\n\t\t\t\t}\n\n\t\t\t\tACPI_DEBUG_PRINT((ACPI_DB_INFO,\n\t\t\t\t\t\t  \"Removing global notify handler\\n\"));\n\n\t\t\t\tacpi_gbl_global_notify[i].handler = NULL;\n\t\t\t\tacpi_gbl_global_notify[i].context = NULL;\n\n\t\t\t\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\n\t\t\t\t \n\n\t\t\t\tacpi_os_wait_events_complete();\n\t\t\t}\n\t\t}\n\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tif (!acpi_ev_is_notify_object(node)) {\n\t\treturn_ACPI_STATUS(AE_TYPE);\n\t}\n\n\t \n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (!obj_desc) {\n\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t}\n\n\t \n\n\tfor (i = 0; i < ACPI_NUM_NOTIFY_TYPES; i++) {\n\t\tif (handler_type & (i + 1)) {\n\t\t\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t}\n\n\t\t\thandler_obj = obj_desc->common_notify.notify_list[i];\n\t\t\tprevious_handler_obj = NULL;\n\n\t\t\t \n\n\t\t\twhile (handler_obj &&\n\t\t\t       (handler_obj->notify.handler != handler)) {\n\t\t\t\tprevious_handler_obj = handler_obj;\n\t\t\t\thandler_obj = handler_obj->notify.next[i];\n\t\t\t}\n\n\t\t\tif (!handler_obj) {\n\t\t\t\tstatus = AE_NOT_EXIST;\n\t\t\t\tgoto unlock_and_exit;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (previous_handler_obj) {\t \n\t\t\t\tprevious_handler_obj->notify.next[i] =\n\t\t\t\t    handler_obj->notify.next[i];\n\t\t\t} else {\t \n\n\t\t\t\tobj_desc->common_notify.notify_list[i] =\n\t\t\t\t    handler_obj->notify.next[i];\n\t\t\t}\n\n\t\t\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\n\t\t\t \n\n\t\t\tacpi_os_wait_events_complete();\n\t\t\tacpi_ut_remove_reference(handler_obj);\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(status);\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_remove_notify_handler)\n\n \n#ifdef ACPI_FUTURE_USAGE\nacpi_status acpi_install_exception_handler(acpi_exception_handler handler)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_install_exception_handler);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tif (acpi_gbl_exception_handler) {\n\t\tstatus = AE_ALREADY_EXISTS;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tacpi_gbl_exception_handler = handler;\n\ncleanup:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_install_exception_handler)\n#endif\n\n#if (!ACPI_REDUCED_HARDWARE)\n \nacpi_status acpi_install_sci_handler(acpi_sci_handler address, void *context)\n{\n\tstruct acpi_sci_handler_info *new_sci_handler;\n\tstruct acpi_sci_handler_info *sci_handler;\n\tacpi_cpu_flags flags;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_install_sci_handler);\n\n\tif (!address) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tnew_sci_handler = ACPI_ALLOCATE(sizeof(struct acpi_sci_handler_info));\n\tif (!new_sci_handler) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tnew_sci_handler->address = address;\n\tnew_sci_handler->context = context;\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\n\t}\n\n\t \n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\tsci_handler = acpi_gbl_sci_handler_list;\n\n\t \n\n\twhile (sci_handler) {\n\t\tif (address == sci_handler->address) {\n\t\t\tstatus = AE_ALREADY_EXISTS;\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\n\t\tsci_handler = sci_handler->next;\n\t}\n\n\t \n\n\tnew_sci_handler->next = acpi_gbl_sci_handler_list;\n\tacpi_gbl_sci_handler_list = new_sci_handler;\n\nunlock_and_exit:\n\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\nexit:\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_FREE(new_sci_handler);\n\t}\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_install_sci_handler)\n\n \nacpi_status acpi_remove_sci_handler(acpi_sci_handler address)\n{\n\tstruct acpi_sci_handler_info *prev_sci_handler;\n\tstruct acpi_sci_handler_info *next_sci_handler;\n\tacpi_cpu_flags flags;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_remove_sci_handler);\n\n\tif (!address) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\tprev_sci_handler = NULL;\n\tnext_sci_handler = acpi_gbl_sci_handler_list;\n\twhile (next_sci_handler) {\n\t\tif (next_sci_handler->address == address) {\n\n\t\t\t \n\n\t\t\tif (prev_sci_handler) {\n\t\t\t\tprev_sci_handler->next = next_sci_handler->next;\n\t\t\t} else {\n\t\t\t\tacpi_gbl_sci_handler_list =\n\t\t\t\t    next_sci_handler->next;\n\t\t\t}\n\n\t\t\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\t\t\tACPI_FREE(next_sci_handler);\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\n\t\tprev_sci_handler = next_sci_handler;\n\t\tnext_sci_handler = next_sci_handler->next;\n\t}\n\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\tstatus = AE_NOT_EXIST;\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_remove_sci_handler)\n\n \nacpi_status\nacpi_install_global_event_handler(acpi_gbl_event_handler handler, void *context)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_install_global_event_handler);\n\n\t \n\n\tif (!handler) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tif (acpi_gbl_global_event_handler) {\n\t\tstatus = AE_ALREADY_EXISTS;\n\t\tgoto cleanup;\n\t}\n\n\tacpi_gbl_global_event_handler = handler;\n\tacpi_gbl_global_event_handler_context = context;\n\ncleanup:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_install_global_event_handler)\n\n \nacpi_status\nacpi_install_fixed_event_handler(u32 event,\n\t\t\t\t acpi_event_handler handler, void *context)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_install_fixed_event_handler);\n\n\t \n\n\tif (event > ACPI_EVENT_MAX) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tif (acpi_gbl_fixed_event_handlers[event].handler) {\n\t\tstatus = AE_ALREADY_EXISTS;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tacpi_gbl_fixed_event_handlers[event].handler = handler;\n\tacpi_gbl_fixed_event_handlers[event].context = context;\n\n\tstatus = acpi_clear_event(event);\n\tif (ACPI_SUCCESS(status))\n\t\tstatus = acpi_enable_event(event, 0);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_WARNING((AE_INFO,\n\t\t\t      \"Could not enable fixed event - %s (%u)\",\n\t\t\t      acpi_ut_get_event_name(event), event));\n\n\t\t \n\n\t\tacpi_gbl_fixed_event_handlers[event].handler = NULL;\n\t\tacpi_gbl_fixed_event_handlers[event].context = NULL;\n\t} else {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_INFO,\n\t\t\t\t  \"Enabled fixed event %s (%X), Handler=%p\\n\",\n\t\t\t\t  acpi_ut_get_event_name(event), event,\n\t\t\t\t  handler));\n\t}\n\ncleanup:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_install_fixed_event_handler)\n\n \nacpi_status\nacpi_remove_fixed_event_handler(u32 event, acpi_event_handler handler)\n{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(acpi_remove_fixed_event_handler);\n\n\t \n\n\tif (event > ACPI_EVENT_MAX) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tstatus = acpi_disable_event(event, 0);\n\n\t \n\n\tacpi_gbl_fixed_event_handlers[event].handler = NULL;\n\tacpi_gbl_fixed_event_handlers[event].context = NULL;\n\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_WARNING((AE_INFO,\n\t\t\t      \"Could not disable fixed event - %s (%u)\",\n\t\t\t      acpi_ut_get_event_name(event), event));\n\t} else {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_INFO,\n\t\t\t\t  \"Disabled fixed event - %s (%X)\\n\",\n\t\t\t\t  acpi_ut_get_event_name(event), event));\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_remove_fixed_event_handler)\n\n \nstatic acpi_status\nacpi_ev_install_gpe_handler(acpi_handle gpe_device,\n\t\t\t    u32 gpe_number,\n\t\t\t    u32 type,\n\t\t\t    u8 is_raw_handler,\n\t\t\t    acpi_gpe_handler address, void *context)\n{\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tstruct acpi_gpe_handler_info *handler;\n\tacpi_status status;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(ev_install_gpe_handler);\n\n\t \n\n\tif ((!address) || (type & ~ACPI_GPE_XRUPT_TYPE_MASK)) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\thandler = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_handler_info));\n\tif (!handler) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto unlock_and_exit;\n\t}\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\n\tif (!gpe_event_info) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto free_and_exit;\n\t}\n\n\t \n\n\tif ((ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\n\t     ACPI_GPE_DISPATCH_HANDLER) ||\n\t    (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\n\t     ACPI_GPE_DISPATCH_RAW_HANDLER)) {\n\t\tstatus = AE_ALREADY_EXISTS;\n\t\tgoto free_and_exit;\n\t}\n\n\thandler->address = address;\n\thandler->context = context;\n\thandler->method_node = gpe_event_info->dispatch.method_node;\n\thandler->original_flags = (u8)(gpe_event_info->flags &\n\t\t\t\t       (ACPI_GPE_XRUPT_TYPE_MASK |\n\t\t\t\t\tACPI_GPE_DISPATCH_MASK));\n\n\t \n\tif (((ACPI_GPE_DISPATCH_TYPE(handler->original_flags) ==\n\t      ACPI_GPE_DISPATCH_METHOD) ||\n\t     (ACPI_GPE_DISPATCH_TYPE(handler->original_flags) ==\n\t      ACPI_GPE_DISPATCH_NOTIFY)) && gpe_event_info->runtime_count) {\n\t\thandler->originally_enabled = TRUE;\n\t\t(void)acpi_ev_remove_gpe_reference(gpe_event_info);\n\n\t\t \n\n\t\tif (type !=\n\t\t    (u32)(gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK)) {\n\t\t\tACPI_WARNING((AE_INFO,\n\t\t\t\t      \"GPE type mismatch (level/edge)\"));\n\t\t}\n\t}\n\n\t \n\n\tgpe_event_info->dispatch.handler = handler;\n\n\t \n\n\tgpe_event_info->flags &=\n\t    ~(ACPI_GPE_XRUPT_TYPE_MASK | ACPI_GPE_DISPATCH_MASK);\n\tgpe_event_info->flags |=\n\t    (u8)(type |\n\t\t (is_raw_handler ? ACPI_GPE_DISPATCH_RAW_HANDLER :\n\t\t  ACPI_GPE_DISPATCH_HANDLER));\n\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn_ACPI_STATUS(status);\n\nfree_and_exit:\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\tACPI_FREE(handler);\n\tgoto unlock_and_exit;\n}\n\n \n\nacpi_status\nacpi_install_gpe_handler(acpi_handle gpe_device,\n\t\t\t u32 gpe_number,\n\t\t\t u32 type, acpi_gpe_handler address, void *context)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_install_gpe_handler);\n\n\tstatus = acpi_ev_install_gpe_handler(gpe_device, gpe_number, type,\n\t\t\t\t\t     FALSE, address, context);\n\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_install_gpe_handler)\n\n \nacpi_status\nacpi_install_gpe_raw_handler(acpi_handle gpe_device,\n\t\t\t     u32 gpe_number,\n\t\t\t     u32 type, acpi_gpe_handler address, void *context)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_install_gpe_raw_handler);\n\n\tstatus = acpi_ev_install_gpe_handler(gpe_device, gpe_number, type,\n\t\t\t\t\t     TRUE, address, context);\n\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_install_gpe_raw_handler)\n\n \nacpi_status\nacpi_remove_gpe_handler(acpi_handle gpe_device,\n\t\t\tu32 gpe_number, acpi_gpe_handler address)\n{\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tstruct acpi_gpe_handler_info *handler;\n\tacpi_status status;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(acpi_remove_gpe_handler);\n\n\t \n\n\tif (!address) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\n\tif (!gpe_event_info) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tif ((ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) !=\n\t     ACPI_GPE_DISPATCH_HANDLER) &&\n\t    (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) !=\n\t     ACPI_GPE_DISPATCH_RAW_HANDLER)) {\n\t\tstatus = AE_NOT_EXIST;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tif (gpe_event_info->dispatch.handler->address != address) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\thandler = gpe_event_info->dispatch.handler;\n\tgpe_event_info->dispatch.handler = NULL;\n\n\t \n\n\tgpe_event_info->dispatch.method_node = handler->method_node;\n\tgpe_event_info->flags &=\n\t    ~(ACPI_GPE_XRUPT_TYPE_MASK | ACPI_GPE_DISPATCH_MASK);\n\tgpe_event_info->flags |= handler->original_flags;\n\n\t \n\tif (((ACPI_GPE_DISPATCH_TYPE(handler->original_flags) ==\n\t      ACPI_GPE_DISPATCH_METHOD) ||\n\t     (ACPI_GPE_DISPATCH_TYPE(handler->original_flags) ==\n\t      ACPI_GPE_DISPATCH_NOTIFY)) && handler->originally_enabled) {\n\t\t(void)acpi_ev_add_gpe_reference(gpe_event_info, FALSE);\n\t\tif (ACPI_GPE_IS_POLLING_NEEDED(gpe_event_info)) {\n\n\t\t\t \n\n\t\t\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\t\t\t(void)acpi_ev_detect_gpe(gpe_device, gpe_event_info,\n\t\t\t\t\t\t gpe_number);\n\t\t\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\t\t}\n\t}\n\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\n\t \n\n\tacpi_os_wait_events_complete();\n\n\t \n\n\tACPI_FREE(handler);\n\treturn_ACPI_STATUS(status);\n\nunlock_and_exit:\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_remove_gpe_handler)\n\n \nacpi_status acpi_acquire_global_lock(u16 timeout, u32 *handle)\n{\n\tacpi_status status;\n\n\tif (!handle) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tacpi_ex_enter_interpreter();\n\n\tstatus = acpi_ex_acquire_mutex_object(timeout,\n\t\t\t\t\t      acpi_gbl_global_lock_mutex,\n\t\t\t\t\t      acpi_os_get_thread_id());\n\n\tif (ACPI_SUCCESS(status)) {\n\n\t\t \n\n\t\t*handle = acpi_gbl_global_lock_handle;\n\t}\n\n\tacpi_ex_exit_interpreter();\n\treturn (status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_acquire_global_lock)\n\n \nacpi_status acpi_release_global_lock(u32 handle)\n{\n\tacpi_status status;\n\n\tif (!handle || (handle != acpi_gbl_global_lock_handle)) {\n\t\treturn (AE_NOT_ACQUIRED);\n\t}\n\n\tstatus = acpi_ex_release_mutex_object(acpi_gbl_global_lock_mutex);\n\treturn (status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_release_global_lock)\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}