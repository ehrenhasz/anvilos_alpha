{
  "module_name": "dbdisply.c",
  "hash_id": "bb90212b6cbaf004f7e16990377bc9988d21c2643da2b89b141de305100218f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/dbdisply.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"amlcode.h\"\n#include \"acdispat.h\"\n#include \"acnamesp.h\"\n#include \"acparser.h\"\n#include \"acinterp.h\"\n#include \"acevents.h\"\n#include \"acdebug.h\"\n\n#define _COMPONENT          ACPI_CA_DEBUGGER\nACPI_MODULE_NAME(\"dbdisply\")\n\n \nstatic void acpi_db_dump_parser_descriptor(union acpi_parse_object *op);\n\nstatic void *acpi_db_get_pointer(void *target);\n\nstatic acpi_status\nacpi_db_display_non_root_handlers(acpi_handle obj_handle,\n\t\t\t\t  u32 nesting_level,\n\t\t\t\t  void *context, void **return_value);\n\n \n#define ACPI_PREDEFINED_PREFIX          \"%25s (%.2X) : \"\n#define ACPI_HANDLER_NAME_STRING               \"%30s : \"\n#define ACPI_HANDLER_PRESENT_STRING                    \"%-9s (%p)\\n\"\n#define ACPI_HANDLER_PRESENT_STRING2                   \"%-9s (%p)\"\n#define ACPI_HANDLER_NOT_PRESENT_STRING                \"%-9s\\n\"\n\n \n\nstatic acpi_adr_space_type acpi_gbl_space_id_list[] = {\n\tACPI_ADR_SPACE_SYSTEM_MEMORY,\n\tACPI_ADR_SPACE_SYSTEM_IO,\n\tACPI_ADR_SPACE_PCI_CONFIG,\n\tACPI_ADR_SPACE_EC,\n\tACPI_ADR_SPACE_SMBUS,\n\tACPI_ADR_SPACE_CMOS,\n\tACPI_ADR_SPACE_PCI_BAR_TARGET,\n\tACPI_ADR_SPACE_IPMI,\n\tACPI_ADR_SPACE_GPIO,\n\tACPI_ADR_SPACE_GSBUS,\n\tACPI_ADR_SPACE_PLATFORM_COMM,\n\tACPI_ADR_SPACE_PLATFORM_RT,\n\tACPI_ADR_SPACE_DATA_TABLE,\n\tACPI_ADR_SPACE_FIXED_HARDWARE\n};\n\n \n\ntypedef struct acpi_handler_info {\n\tvoid *handler;\n\tchar *name;\n\n} acpi_handler_info;\n\nstatic struct acpi_handler_info acpi_gbl_handler_list[] = {\n\t{&acpi_gbl_global_notify[0].handler, \"System Notifications\"},\n\t{&acpi_gbl_global_notify[1].handler, \"Device Notifications\"},\n\t{&acpi_gbl_table_handler, \"ACPI Table Events\"},\n\t{&acpi_gbl_exception_handler, \"Control Method Exceptions\"},\n\t{&acpi_gbl_interface_handler, \"OSI Invocations\"}\n};\n\n \n\nstatic void *acpi_db_get_pointer(void *target)\n{\n\tvoid *obj_ptr;\n\tacpi_size address;\n\n\taddress = strtoul(target, NULL, 16);\n\tobj_ptr = ACPI_TO_POINTER(address);\n\treturn (obj_ptr);\n}\n\n \n\nstatic void acpi_db_dump_parser_descriptor(union acpi_parse_object *op)\n{\n\tconst struct acpi_opcode_info *info;\n\n\tinfo = acpi_ps_get_opcode_info(op->common.aml_opcode);\n\n\tacpi_os_printf(\"Parser Op Descriptor:\\n\");\n\tacpi_os_printf(\"%20.20s : %4.4X\\n\", \"Opcode\", op->common.aml_opcode);\n\n\tACPI_DEBUG_ONLY_MEMBERS(acpi_os_printf(\"%20.20s : %s\\n\", \"Opcode Name\",\n\t\t\t\t\t       info->name));\n\n\tacpi_os_printf(\"%20.20s : %p\\n\", \"Value/ArgList\", op->common.value.arg);\n\tacpi_os_printf(\"%20.20s : %p\\n\", \"Parent\", op->common.parent);\n\tacpi_os_printf(\"%20.20s : %p\\n\", \"NextOp\", op->common.next);\n}\n\n \n\nvoid acpi_db_decode_and_display_object(char *target, char *output_type)\n{\n\tvoid *obj_ptr;\n\tstruct acpi_namespace_node *node;\n\tunion acpi_operand_object *obj_desc;\n\tu32 display = DB_BYTE_DISPLAY;\n\tchar buffer[80];\n\tstruct acpi_buffer ret_buf;\n\tacpi_status status;\n\tu32 size;\n\n\tif (!target) {\n\t\treturn;\n\t}\n\n\t \n\n\tif (output_type) {\n\t\tacpi_ut_strupr(output_type);\n\t\tif (output_type[0] == 'W') {\n\t\t\tdisplay = DB_WORD_DISPLAY;\n\t\t} else if (output_type[0] == 'D') {\n\t\t\tdisplay = DB_DWORD_DISPLAY;\n\t\t} else if (output_type[0] == 'Q') {\n\t\t\tdisplay = DB_QWORD_DISPLAY;\n\t\t}\n\t}\n\n\tret_buf.length = sizeof(buffer);\n\tret_buf.pointer = buffer;\n\n\t \n\n\tif ((target[0] >= 0x30) && (target[0] <= 0x39)) {\n\t\tobj_ptr = acpi_db_get_pointer(target);\n\t\tif (!acpi_os_readable(obj_ptr, 16)) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Address %p is invalid in this address space\\n\",\n\t\t\t     obj_ptr);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\n\t\tswitch (ACPI_GET_DESCRIPTOR_TYPE(obj_ptr)) {\n\t\tcase ACPI_DESC_TYPE_NAMED:\n\n\t\t\t \n\n\t\t\tif (!acpi_os_readable\n\t\t\t    (obj_ptr, sizeof(struct acpi_namespace_node))) {\n\t\t\t\tacpi_os_printf\n\t\t\t\t    (\"Cannot read entire Named object at address %p\\n\",\n\t\t\t\t     obj_ptr);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnode = obj_ptr;\n\t\t\tgoto dump_node;\n\n\t\tcase ACPI_DESC_TYPE_OPERAND:\n\n\t\t\t \n\n\t\t\tif (!acpi_os_readable\n\t\t\t    (obj_ptr, sizeof(union acpi_operand_object))) {\n\t\t\t\tacpi_os_printf\n\t\t\t\t    (\"Cannot read entire ACPI object at address %p\\n\",\n\t\t\t\t     obj_ptr);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tacpi_ut_debug_dump_buffer(obj_ptr,\n\t\t\t\t\t\t  sizeof(union\n\t\t\t\t\t\t\t acpi_operand_object),\n\t\t\t\t\t\t  display, ACPI_UINT32_MAX);\n\t\t\tacpi_ex_dump_object_descriptor(obj_ptr, 1);\n\t\t\tbreak;\n\n\t\tcase ACPI_DESC_TYPE_PARSER:\n\n\t\t\t \n\n\t\t\tif (!acpi_os_readable\n\t\t\t    (obj_ptr, sizeof(union acpi_parse_object))) {\n\t\t\t\tacpi_os_printf\n\t\t\t\t    (\"Cannot read entire Parser object at address %p\\n\",\n\t\t\t\t     obj_ptr);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tacpi_ut_debug_dump_buffer(obj_ptr,\n\t\t\t\t\t\t  sizeof(union\n\t\t\t\t\t\t\t acpi_parse_object),\n\t\t\t\t\t\t  display, ACPI_UINT32_MAX);\n\t\t\tacpi_db_dump_parser_descriptor((union acpi_parse_object\n\t\t\t\t\t\t\t*)obj_ptr);\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\t \n\n\t\t\tacpi_os_printf\n\t\t\t    (\"Not a known ACPI internal object, descriptor type %2.2X\\n\",\n\t\t\t     ACPI_GET_DESCRIPTOR_TYPE(obj_ptr));\n\n\t\t\tsize = 16;\n\t\t\tif (acpi_os_readable(obj_ptr, 64)) {\n\t\t\t\tsize = 64;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tacpi_ut_debug_dump_buffer(obj_ptr, size, display,\n\t\t\t\t\t\t  ACPI_UINT32_MAX);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn;\n\t}\n\n\t \n\n\tnode = acpi_db_local_ns_lookup(target);\n\tif (!node) {\n\t\treturn;\n\t}\n\ndump_node:\n\t \n\n\tstatus = acpi_get_name(node, ACPI_FULL_PATHNAME_NO_TRAILING, &ret_buf);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could not convert name to pathname\\n\");\n\t}\n\n\telse {\n\t\tacpi_os_printf(\"Object %p: Namespace Node - Pathname: %s\\n\",\n\t\t\t       node, (char *)ret_buf.pointer);\n\t}\n\n\tif (!acpi_os_readable(node, sizeof(struct acpi_namespace_node))) {\n\t\tacpi_os_printf(\"Invalid Named object at address %p\\n\", node);\n\t\treturn;\n\t}\n\n\tacpi_ut_debug_dump_buffer((void *)node,\n\t\t\t\t  sizeof(struct acpi_namespace_node), display,\n\t\t\t\t  ACPI_UINT32_MAX);\n\tacpi_ex_dump_namespace_node(node, 1);\n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (obj_desc) {\n\t\tacpi_os_printf(\"\\nAttached Object %p:\", obj_desc);\n\t\tif (!acpi_os_readable\n\t\t    (obj_desc, sizeof(union acpi_operand_object))) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Invalid internal ACPI Object at address %p\\n\",\n\t\t\t     obj_desc);\n\t\t\treturn;\n\t\t}\n\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(((struct acpi_namespace_node *)\n\t\t\t\t\t      obj_desc)) ==\n\t\t    ACPI_DESC_TYPE_NAMED) {\n\t\t\tacpi_os_printf(\" Namespace Node - \");\n\t\t\tstatus =\n\t\t\t    acpi_get_name((struct acpi_namespace_node *)\n\t\t\t\t\t  obj_desc,\n\t\t\t\t\t  ACPI_FULL_PATHNAME_NO_TRAILING,\n\t\t\t\t\t  &ret_buf);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tacpi_os_printf\n\t\t\t\t    (\"Could not convert name to pathname\\n\");\n\t\t\t} else {\n\t\t\t\tacpi_os_printf(\"Pathname: %s\",\n\t\t\t\t\t       (char *)ret_buf.pointer);\n\t\t\t}\n\n\t\t\tacpi_os_printf(\"\\n\");\n\t\t\tacpi_ut_debug_dump_buffer((void *)obj_desc,\n\t\t\t\t\t\t  sizeof(struct\n\t\t\t\t\t\t\t acpi_namespace_node),\n\t\t\t\t\t\t  display, ACPI_UINT32_MAX);\n\t\t} else {\n\t\t\tacpi_os_printf(\"\\n\");\n\t\t\tacpi_ut_debug_dump_buffer((void *)obj_desc,\n\t\t\t\t\t\t  sizeof(union\n\t\t\t\t\t\t\t acpi_operand_object),\n\t\t\t\t\t\t  display, ACPI_UINT32_MAX);\n\t\t}\n\n\t\tacpi_ex_dump_object_descriptor(obj_desc, 1);\n\t}\n}\n\n \n\nvoid acpi_db_display_method_info(union acpi_parse_object *start_op)\n{\n\tstruct acpi_walk_state *walk_state;\n\tunion acpi_operand_object *obj_desc;\n\tstruct acpi_namespace_node *node;\n\tunion acpi_parse_object *root_op;\n\tunion acpi_parse_object *op;\n\tconst struct acpi_opcode_info *op_info;\n\tu32 num_ops = 0;\n\tu32 num_operands = 0;\n\tu32 num_operators = 0;\n\tu32 num_remaining_ops = 0;\n\tu32 num_remaining_operands = 0;\n\tu32 num_remaining_operators = 0;\n\tu8 count_remaining = FALSE;\n\n\twalk_state = acpi_ds_get_current_walk_state(acpi_gbl_current_walk_list);\n\tif (!walk_state) {\n\t\tacpi_os_printf(\"There is no method currently executing\\n\");\n\t\treturn;\n\t}\n\n\tobj_desc = walk_state->method_desc;\n\tnode = walk_state->method_node;\n\n\tacpi_os_printf(\"Currently executing control method is [%4.4s]\\n\",\n\t\t       acpi_ut_get_node_name(node));\n\tacpi_os_printf(\"%X Arguments, SyncLevel = %X\\n\",\n\t\t       (u32)obj_desc->method.param_count,\n\t\t       (u32)obj_desc->method.sync_level);\n\n\troot_op = start_op;\n\twhile (root_op->common.parent) {\n\t\troot_op = root_op->common.parent;\n\t}\n\n\top = root_op;\n\n\twhile (op) {\n\t\tif (op == start_op) {\n\t\t\tcount_remaining = TRUE;\n\t\t}\n\n\t\tnum_ops++;\n\t\tif (count_remaining) {\n\t\t\tnum_remaining_ops++;\n\t\t}\n\n\t\t \n\n\t\top_info = acpi_ps_get_opcode_info(op->common.aml_opcode);\n\t\tswitch (op_info->class) {\n\t\tcase AML_CLASS_ARGUMENT:\n\n\t\t\tif (count_remaining) {\n\t\t\t\tnum_remaining_operands++;\n\t\t\t}\n\n\t\t\tnum_operands++;\n\t\t\tbreak;\n\n\t\tcase AML_CLASS_UNKNOWN:\n\n\t\t\t \n\n\t\t\tcontinue;\n\n\t\tdefault:\n\n\t\t\tif (count_remaining) {\n\t\t\t\tnum_remaining_operators++;\n\t\t\t}\n\n\t\t\tnum_operators++;\n\t\t\tbreak;\n\t\t}\n\n\t\top = acpi_ps_get_depth_next(start_op, op);\n\t}\n\n\tacpi_os_printf\n\t    (\"Method contains:       %X AML Opcodes - %X Operators, %X Operands\\n\",\n\t     num_ops, num_operators, num_operands);\n\n\tacpi_os_printf\n\t    (\"Remaining to execute:  %X AML Opcodes - %X Operators, %X Operands\\n\",\n\t     num_remaining_ops, num_remaining_operators,\n\t     num_remaining_operands);\n}\n\n \n\nvoid acpi_db_display_locals(void)\n{\n\tstruct acpi_walk_state *walk_state;\n\n\twalk_state = acpi_ds_get_current_walk_state(acpi_gbl_current_walk_list);\n\tif (!walk_state) {\n\t\tacpi_os_printf(\"There is no method currently executing\\n\");\n\t\treturn;\n\t}\n\n\tacpi_db_decode_locals(walk_state);\n}\n\n \n\nvoid acpi_db_display_arguments(void)\n{\n\tstruct acpi_walk_state *walk_state;\n\n\twalk_state = acpi_ds_get_current_walk_state(acpi_gbl_current_walk_list);\n\tif (!walk_state) {\n\t\tacpi_os_printf(\"There is no method currently executing\\n\");\n\t\treturn;\n\t}\n\n\tacpi_db_decode_arguments(walk_state);\n}\n\n \n\nvoid acpi_db_display_results(void)\n{\n\tu32 i;\n\tstruct acpi_walk_state *walk_state;\n\tunion acpi_operand_object *obj_desc;\n\tu32 result_count = 0;\n\tstruct acpi_namespace_node *node;\n\tunion acpi_generic_state *frame;\n\tu32 index;\t\t \n\n\twalk_state = acpi_ds_get_current_walk_state(acpi_gbl_current_walk_list);\n\tif (!walk_state) {\n\t\tacpi_os_printf(\"There is no method currently executing\\n\");\n\t\treturn;\n\t}\n\n\tnode = walk_state->method_node;\n\n\tif (walk_state->results) {\n\t\tresult_count = walk_state->result_count;\n\t}\n\n\tacpi_os_printf(\"Method [%4.4s] has %X stacked result objects\\n\",\n\t\t       acpi_ut_get_node_name(node), result_count);\n\n\t \n\n\tframe = walk_state->results;\n\tindex = (result_count - 1) % ACPI_RESULTS_FRAME_OBJ_NUM;\n\n\tfor (i = 0; i < result_count; i++) {\n\t\tobj_desc = frame->results.obj_desc[index];\n\t\tacpi_os_printf(\"Result%u: \", i);\n\t\tacpi_db_display_internal_object(obj_desc, walk_state);\n\n\t\tif (index == 0) {\n\t\t\tframe = frame->results.next;\n\t\t\tindex = ACPI_RESULTS_FRAME_OBJ_NUM;\n\t\t}\n\n\t\tindex--;\n\t}\n}\n\n \n\nvoid acpi_db_display_calling_tree(void)\n{\n\tstruct acpi_walk_state *walk_state;\n\tstruct acpi_namespace_node *node;\n\n\twalk_state = acpi_ds_get_current_walk_state(acpi_gbl_current_walk_list);\n\tif (!walk_state) {\n\t\tacpi_os_printf(\"There is no method currently executing\\n\");\n\t\treturn;\n\t}\n\n\tacpi_os_printf(\"Current Control Method Call Tree\\n\");\n\n\twhile (walk_state) {\n\t\tnode = walk_state->method_node;\n\t\tacpi_os_printf(\"  [%4.4s]\\n\", acpi_ut_get_node_name(node));\n\n\t\twalk_state = walk_state->next;\n\t}\n}\n\n \n\nvoid acpi_db_display_object_type(char *object_arg)\n{\n\tacpi_size arg;\n\tacpi_handle handle;\n\tstruct acpi_device_info *info;\n\tacpi_status status;\n\tu32 i;\n\n\targ = strtoul(object_arg, NULL, 16);\n\thandle = ACPI_TO_POINTER(arg);\n\n\tstatus = acpi_get_object_info(handle, &info);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could not get object info, %s\\n\",\n\t\t\t       acpi_format_exception(status));\n\t\treturn;\n\t}\n\n\tacpi_os_printf(\"ADR: %8.8X%8.8X, Flags: %X\\n\",\n\t\t       ACPI_FORMAT_UINT64(info->address), info->flags);\n\n\tacpi_os_printf(\"S1D-%2.2X S2D-%2.2X S3D-%2.2X S4D-%2.2X\\n\",\n\t\t       info->highest_dstates[0], info->highest_dstates[1],\n\t\t       info->highest_dstates[2], info->highest_dstates[3]);\n\n\tacpi_os_printf(\"S0W-%2.2X S1W-%2.2X S2W-%2.2X S3W-%2.2X S4W-%2.2X\\n\",\n\t\t       info->lowest_dstates[0], info->lowest_dstates[1],\n\t\t       info->lowest_dstates[2], info->lowest_dstates[3],\n\t\t       info->lowest_dstates[4]);\n\n\tif (info->valid & ACPI_VALID_HID) {\n\t\tacpi_os_printf(\"HID: %s\\n\", info->hardware_id.string);\n\t}\n\n\tif (info->valid & ACPI_VALID_UID) {\n\t\tacpi_os_printf(\"UID: %s\\n\", info->unique_id.string);\n\t}\n\n\tif (info->valid & ACPI_VALID_CID) {\n\t\tfor (i = 0; i < info->compatible_id_list.count; i++) {\n\t\t\tacpi_os_printf(\"CID %u: %s\\n\", i,\n\t\t\t\t       info->compatible_id_list.ids[i].string);\n\t\t}\n\t}\n\n\tACPI_FREE(info);\n}\n\n \n\nvoid\nacpi_db_display_result_object(union acpi_operand_object *obj_desc,\n\t\t\t      struct acpi_walk_state *walk_state)\n{\n\n#ifndef ACPI_APPLICATION\n\tif (acpi_gbl_db_thread_id != acpi_os_get_thread_id()) {\n\t\treturn;\n\t}\n#endif\n\n\t \n\n\tif (!acpi_gbl_cm_single_step) {\n\t\treturn;\n\t}\n\n\tacpi_os_printf(\"ResultObj: \");\n\tacpi_db_display_internal_object(obj_desc, walk_state);\n\tacpi_os_printf(\"\\n\");\n}\n\n \n\nvoid\nacpi_db_display_argument_object(union acpi_operand_object *obj_desc,\n\t\t\t\tstruct acpi_walk_state *walk_state)\n{\n\n#ifndef ACPI_APPLICATION\n\tif (acpi_gbl_db_thread_id != acpi_os_get_thread_id()) {\n\t\treturn;\n\t}\n#endif\n\n\tif (!acpi_gbl_cm_single_step) {\n\t\treturn;\n\t}\n\n\tacpi_os_printf(\"ArgObj:  \");\n\tacpi_db_display_internal_object(obj_desc, walk_state);\n}\n\n#if (!ACPI_REDUCED_HARDWARE)\n \n\nvoid acpi_db_display_gpes(void)\n{\n\tstruct acpi_gpe_block_info *gpe_block;\n\tstruct acpi_gpe_xrupt_info *gpe_xrupt_info;\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tstruct acpi_gpe_register_info *gpe_register_info;\n\tchar *gpe_type;\n\tstruct acpi_gpe_notify_info *notify;\n\tu32 gpe_index;\n\tu32 block = 0;\n\tu32 i;\n\tu32 j;\n\tu32 count;\n\tchar buffer[80];\n\tstruct acpi_buffer ret_buf;\n\tacpi_status status;\n\n\tret_buf.length = sizeof(buffer);\n\tret_buf.pointer = buffer;\n\n\tblock = 0;\n\n\t \n\n\tgpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;\n\twhile (gpe_xrupt_info) {\n\t\tgpe_block = gpe_xrupt_info->gpe_block_list_head;\n\t\twhile (gpe_block) {\n\t\t\tstatus = acpi_get_name(gpe_block->node,\n\t\t\t\t\t       ACPI_FULL_PATHNAME_NO_TRAILING,\n\t\t\t\t\t       &ret_buf);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tacpi_os_printf\n\t\t\t\t    (\"Could not convert name to pathname\\n\");\n\t\t\t}\n\n\t\t\tif (gpe_block->node == acpi_gbl_fadt_gpe_device) {\n\t\t\t\tgpe_type = \"FADT-defined GPE block\";\n\t\t\t} else {\n\t\t\t\tgpe_type = \"GPE Block Device\";\n\t\t\t}\n\n\t\t\tacpi_os_printf\n\t\t\t    (\"\\nBlock %u - Info %p  DeviceNode %p [%s] - %s\\n\",\n\t\t\t     block, gpe_block, gpe_block->node, buffer,\n\t\t\t     gpe_type);\n\n\t\t\tacpi_os_printf(\"    Registers:    %u (%u GPEs)\\n\",\n\t\t\t\t       gpe_block->register_count,\n\t\t\t\t       gpe_block->gpe_count);\n\n\t\t\tacpi_os_printf\n\t\t\t    (\"    GPE range:    0x%X to 0x%X on interrupt %u\\n\",\n\t\t\t     gpe_block->block_base_number,\n\t\t\t     gpe_block->block_base_number +\n\t\t\t     (gpe_block->gpe_count - 1),\n\t\t\t     gpe_xrupt_info->interrupt_number);\n\n\t\t\tacpi_os_printf\n\t\t\t    (\"    RegisterInfo: %p  Status %8.8X%8.8X Enable %8.8X%8.8X\\n\",\n\t\t\t     gpe_block->register_info,\n\t\t\t     ACPI_FORMAT_UINT64(gpe_block->register_info->\n\t\t\t\t\t\tstatus_address.address),\n\t\t\t     ACPI_FORMAT_UINT64(gpe_block->register_info->\n\t\t\t\t\t\tenable_address.address));\n\n\t\t\tacpi_os_printf(\"  EventInfo:    %p\\n\",\n\t\t\t\t       gpe_block->event_info);\n\n\t\t\t \n\n\t\t\tfor (i = 0; i < gpe_block->register_count; i++) {\n\t\t\t\tgpe_register_info =\n\t\t\t\t    &gpe_block->register_info[i];\n\n\t\t\t\tacpi_os_printf(\"    Reg %u: (GPE %.2X-%.2X)  \"\n\t\t\t\t\t       \"RunEnable %2.2X WakeEnable %2.2X\"\n\t\t\t\t\t       \" Status %8.8X%8.8X Enable %8.8X%8.8X\\n\",\n\t\t\t\t\t       i,\n\t\t\t\t\t       gpe_register_info->\n\t\t\t\t\t       base_gpe_number,\n\t\t\t\t\t       gpe_register_info->\n\t\t\t\t\t       base_gpe_number +\n\t\t\t\t\t       (ACPI_GPE_REGISTER_WIDTH - 1),\n\t\t\t\t\t       gpe_register_info->\n\t\t\t\t\t       enable_for_run,\n\t\t\t\t\t       gpe_register_info->\n\t\t\t\t\t       enable_for_wake,\n\t\t\t\t\t       ACPI_FORMAT_UINT64\n\t\t\t\t\t       (gpe_register_info->\n\t\t\t\t\t\tstatus_address.address),\n\t\t\t\t\t       ACPI_FORMAT_UINT64\n\t\t\t\t\t       (gpe_register_info->\n\t\t\t\t\t\tenable_address.address));\n\n\t\t\t\t \n\n\t\t\t\tfor (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {\n\t\t\t\t\tgpe_index =\n\t\t\t\t\t    (i * ACPI_GPE_REGISTER_WIDTH) + j;\n\t\t\t\t\tgpe_event_info =\n\t\t\t\t\t    &gpe_block->event_info[gpe_index];\n\n\t\t\t\t\tif (ACPI_GPE_DISPATCH_TYPE\n\t\t\t\t\t    (gpe_event_info->flags) ==\n\t\t\t\t\t    ACPI_GPE_DISPATCH_NONE) {\n\n\t\t\t\t\t\t \n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t    (\"        GPE %.2X: %p  RunRefs %2.2X Flags %2.2X (\",\n\t\t\t\t\t     gpe_block->block_base_number +\n\t\t\t\t\t     gpe_index, gpe_event_info,\n\t\t\t\t\t     gpe_event_info->runtime_count,\n\t\t\t\t\t     gpe_event_info->flags);\n\n\t\t\t\t\t \n\n\t\t\t\t\tif (gpe_event_info->\n\t\t\t\t\t    flags & ACPI_GPE_LEVEL_TRIGGERED) {\n\t\t\t\t\t\tacpi_os_printf(\"Level, \");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tacpi_os_printf(\"Edge, \");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gpe_event_info->\n\t\t\t\t\t    flags & ACPI_GPE_CAN_WAKE) {\n\t\t\t\t\t\tacpi_os_printf(\"CanWake, \");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tacpi_os_printf(\"RunOnly, \");\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (ACPI_GPE_DISPATCH_TYPE\n\t\t\t\t\t\t(gpe_event_info->flags)) {\n\t\t\t\t\tcase ACPI_GPE_DISPATCH_NONE:\n\n\t\t\t\t\t\tacpi_os_printf(\"NotUsed\");\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ACPI_GPE_DISPATCH_METHOD:\n\n\t\t\t\t\t\tacpi_os_printf(\"Method\");\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ACPI_GPE_DISPATCH_HANDLER:\n\n\t\t\t\t\t\tacpi_os_printf(\"Handler\");\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ACPI_GPE_DISPATCH_NOTIFY:\n\n\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\tnotify =\n\t\t\t\t\t\t    gpe_event_info->dispatch.\n\t\t\t\t\t\t    notify_list;\n\t\t\t\t\t\twhile (notify) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tnotify = notify->next;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t\t    (\"Implicit Notify on %u devices\",\n\t\t\t\t\t\t     count);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ACPI_GPE_DISPATCH_RAW_HANDLER:\n\n\t\t\t\t\t\tacpi_os_printf(\"RawHandler\");\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tacpi_os_printf(\"UNKNOWN: %X\",\n\t\t\t\t\t\t\t       ACPI_GPE_DISPATCH_TYPE\n\t\t\t\t\t\t\t       (gpe_event_info->\n\t\t\t\t\t\t\t\tflags));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tacpi_os_printf(\")\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tblock++;\n\t\t\tgpe_block = gpe_block->next;\n\t\t}\n\n\t\tgpe_xrupt_info = gpe_xrupt_info->next;\n\t}\n}\n#endif\t\t\t\t \n\n \n\nvoid acpi_db_display_handlers(void)\n{\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_operand_object *handler_obj;\n\tacpi_adr_space_type space_id;\n\tu32 i;\n\n\t \n\n\tacpi_os_printf(\"\\nOperation Region Handlers at the namespace root:\\n\");\n\n\tobj_desc = acpi_ns_get_attached_object(acpi_gbl_root_node);\n\tif (obj_desc) {\n\t\tfor (i = 0; i < ACPI_ARRAY_LENGTH(acpi_gbl_space_id_list); i++) {\n\t\t\tspace_id = acpi_gbl_space_id_list[i];\n\n\t\t\tacpi_os_printf(ACPI_PREDEFINED_PREFIX,\n\t\t\t\t       acpi_ut_get_region_name((u8)space_id),\n\t\t\t\t       space_id);\n\n\t\t\thandler_obj =\n\t\t\t    acpi_ev_find_region_handler(space_id,\n\t\t\t\t\t\t\tobj_desc->common_notify.\n\t\t\t\t\t\t\thandler);\n\t\t\tif (handler_obj) {\n\t\t\t\tacpi_os_printf(ACPI_HANDLER_PRESENT_STRING,\n\t\t\t\t\t       (handler_obj->address_space.\n\t\t\t\t\t\thandler_flags &\n\t\t\t\t\t\tACPI_ADDR_HANDLER_DEFAULT_INSTALLED)\n\t\t\t\t\t       ? \"Default\" : \"User\",\n\t\t\t\t\t       handler_obj->address_space.\n\t\t\t\t\t       handler);\n\n\t\t\t\tgoto found_handler;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tacpi_os_printf(\"None\\n\");\n\nfound_handler:\t\t;\n\t\t}\n\n\t\t \n\n\t\thandler_obj = obj_desc->common_notify.handler;\n\t\twhile (handler_obj) {\n\t\t\tif (handler_obj->address_space.space_id >=\n\t\t\t    ACPI_USER_REGION_BEGIN) {\n\t\t\t\tacpi_os_printf(ACPI_PREDEFINED_PREFIX,\n\t\t\t\t\t       \"User-defined ID\",\n\t\t\t\t\t       handler_obj->address_space.\n\t\t\t\t\t       space_id);\n\t\t\t\tacpi_os_printf(ACPI_HANDLER_PRESENT_STRING,\n\t\t\t\t\t       (handler_obj->address_space.\n\t\t\t\t\t\thandler_flags &\n\t\t\t\t\t\tACPI_ADDR_HANDLER_DEFAULT_INSTALLED)\n\t\t\t\t\t       ? \"Default\" : \"User\",\n\t\t\t\t\t       handler_obj->address_space.\n\t\t\t\t\t       handler);\n\t\t\t}\n\n\t\t\thandler_obj = handler_obj->address_space.next;\n\t\t}\n\t}\n#if (!ACPI_REDUCED_HARDWARE)\n\n\t \n\n\tacpi_os_printf(\"\\nFixed Event Handlers:\\n\");\n\n\tfor (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {\n\t\tacpi_os_printf(ACPI_PREDEFINED_PREFIX,\n\t\t\t       acpi_ut_get_event_name(i), i);\n\t\tif (acpi_gbl_fixed_event_handlers[i].handler) {\n\t\t\tacpi_os_printf(ACPI_HANDLER_PRESENT_STRING, \"User\",\n\t\t\t\t       acpi_gbl_fixed_event_handlers[i].\n\t\t\t\t       handler);\n\t\t} else {\n\t\t\tacpi_os_printf(ACPI_HANDLER_NOT_PRESENT_STRING, \"None\");\n\t\t}\n\t}\n\n#endif\t\t\t\t \n\n\t \n\n\tacpi_os_printf(\"\\nMiscellaneous Global Handlers:\\n\");\n\n\tfor (i = 0; i < ACPI_ARRAY_LENGTH(acpi_gbl_handler_list); i++) {\n\t\tacpi_os_printf(ACPI_HANDLER_NAME_STRING,\n\t\t\t       acpi_gbl_handler_list[i].name);\n\n\t\tif (acpi_gbl_handler_list[i].handler) {\n\t\t\tacpi_os_printf(ACPI_HANDLER_PRESENT_STRING, \"User\",\n\t\t\t\t       acpi_gbl_handler_list[i].handler);\n\t\t} else {\n\t\t\tacpi_os_printf(ACPI_HANDLER_NOT_PRESENT_STRING, \"None\");\n\t\t}\n\t}\n\n\t \n\n\tacpi_os_printf(\"\\nOperation Region Handlers for specific devices:\\n\");\n\n\t(void)acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\n\t\t\t\t  ACPI_UINT32_MAX,\n\t\t\t\t  acpi_db_display_non_root_handlers, NULL, NULL,\n\t\t\t\t  NULL);\n}\n\n \n\nstatic acpi_status\nacpi_db_display_non_root_handlers(acpi_handle obj_handle,\n\t\t\t\t  u32 nesting_level,\n\t\t\t\t  void *context, void **return_value)\n{\n\tstruct acpi_namespace_node *node =\n\t    ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_operand_object *handler_obj;\n\tchar *pathname;\n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (!obj_desc) {\n\t\treturn (AE_OK);\n\t}\n\n\tpathname = acpi_ns_get_normalized_pathname(node, TRUE);\n\tif (!pathname) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\thandler_obj = obj_desc->common_notify.handler;\n\twhile (handler_obj) {\n\t\tacpi_os_printf(ACPI_PREDEFINED_PREFIX,\n\t\t\t       acpi_ut_get_region_name((u8)handler_obj->\n\t\t\t\t\t\t       address_space.space_id),\n\t\t\t       handler_obj->address_space.space_id);\n\n\t\tacpi_os_printf(ACPI_HANDLER_PRESENT_STRING2,\n\t\t\t       (handler_obj->address_space.handler_flags &\n\t\t\t\tACPI_ADDR_HANDLER_DEFAULT_INSTALLED) ? \"Default\"\n\t\t\t       : \"User\", handler_obj->address_space.handler);\n\n\t\tacpi_os_printf(\" Device Name: %s (%p)\\n\", pathname, node);\n\n\t\thandler_obj = handler_obj->address_space.next;\n\t}\n\n\tACPI_FREE(pathname);\n\treturn (AE_OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}