{
  "module_name": "dbutils.c",
  "hash_id": "997dfe8fbd4d0cae389919dcbfa9caf2d292b210f6f9cf783b4a5b796c2d174d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/dbutils.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"acdebug.h\"\n\n#define _COMPONENT          ACPI_CA_DEBUGGER\nACPI_MODULE_NAME(\"dbutils\")\n\n \n#ifdef ACPI_OBSOLETE_FUNCTIONS\nacpi_status acpi_db_second_pass_parse(union acpi_parse_object *root);\n\nvoid acpi_db_dump_buffer(u32 address);\n#endif\n\n \n\nacpi_object_type\nacpi_db_match_argument(char *user_argument,\n\t\t       struct acpi_db_argument_info *arguments)\n{\n\tu32 i;\n\n\tif (!user_argument || user_argument[0] == 0) {\n\t\treturn (ACPI_TYPE_NOT_FOUND);\n\t}\n\n\tfor (i = 0; arguments[i].name; i++) {\n\t\tif (strstr(ACPI_CAST_PTR(char, arguments[i].name),\n\t\t\t   ACPI_CAST_PTR(char,\n\t\t\t\t\t user_argument)) == arguments[i].name) {\n\t\t\treturn (i);\n\t\t}\n\t}\n\n\t \n\n\treturn (ACPI_TYPE_NOT_FOUND);\n}\n\n \n\nvoid acpi_db_set_output_destination(u32 output_flags)\n{\n\n\tacpi_gbl_db_output_flags = (u8)output_flags;\n\n\tif ((output_flags & ACPI_DB_REDIRECTABLE_OUTPUT) &&\n\t    acpi_gbl_db_output_to_file) {\n\t\tacpi_dbg_level = acpi_gbl_db_debug_level;\n\t} else {\n\t\tacpi_dbg_level = acpi_gbl_db_console_debug_level;\n\t}\n}\n\n \n\nvoid acpi_db_dump_external_object(union acpi_object *obj_desc, u32 level)\n{\n\tu32 i;\n\n\tif (!obj_desc) {\n\t\tacpi_os_printf(\"[Null Object]\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < level; i++) {\n\t\tacpi_os_printf(\" \");\n\t}\n\n\tswitch (obj_desc->type) {\n\tcase ACPI_TYPE_ANY:\n\n\t\tacpi_os_printf(\"[Null Object] (Type=0)\\n\");\n\t\tbreak;\n\n\tcase ACPI_TYPE_INTEGER:\n\n\t\tacpi_os_printf(\"[Integer] = %8.8X%8.8X\\n\",\n\t\t\t       ACPI_FORMAT_UINT64(obj_desc->integer.value));\n\t\tbreak;\n\n\tcase ACPI_TYPE_STRING:\n\n\t\tacpi_os_printf(\"[String] Length %.2X = \",\n\t\t\t       obj_desc->string.length);\n\t\tacpi_ut_print_string(obj_desc->string.pointer, ACPI_UINT8_MAX);\n\t\tacpi_os_printf(\"\\n\");\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\tacpi_os_printf(\"[Buffer] Length %.2X = \",\n\t\t\t       obj_desc->buffer.length);\n\t\tif (obj_desc->buffer.length) {\n\t\t\tif (obj_desc->buffer.length > 16) {\n\t\t\t\tacpi_os_printf(\"\\n\");\n\t\t\t}\n\n\t\t\tacpi_ut_debug_dump_buffer(ACPI_CAST_PTR\n\t\t\t\t\t\t  (u8,\n\t\t\t\t\t\t   obj_desc->buffer.pointer),\n\t\t\t\t\t\t  obj_desc->buffer.length,\n\t\t\t\t\t\t  DB_BYTE_DISPLAY, _COMPONENT);\n\t\t} else {\n\t\t\tacpi_os_printf(\"\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_PACKAGE:\n\n\t\tacpi_os_printf(\"[Package] Contains %u Elements:\\n\",\n\t\t\t       obj_desc->package.count);\n\n\t\tfor (i = 0; i < obj_desc->package.count; i++) {\n\t\t\tacpi_db_dump_external_object(&obj_desc->package.\n\t\t\t\t\t\t     elements[i], level + 1);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\n\t\tacpi_os_printf(\"[Object Reference] = \");\n\t\tacpi_db_display_internal_object(obj_desc->reference.handle,\n\t\t\t\t\t\tNULL);\n\t\tbreak;\n\n\tcase ACPI_TYPE_PROCESSOR:\n\n\t\tacpi_os_printf(\"[Processor]\\n\");\n\t\tbreak;\n\n\tcase ACPI_TYPE_POWER:\n\n\t\tacpi_os_printf(\"[Power Resource]\\n\");\n\t\tbreak;\n\n\tdefault:\n\n\t\tacpi_os_printf(\"[Unknown Type] %X\\n\", obj_desc->type);\n\t\tbreak;\n\t}\n}\n\n \n\nvoid acpi_db_prep_namestring(char *name)\n{\n\n\tif (!name) {\n\t\treturn;\n\t}\n\n\tacpi_ut_strupr(name);\n\n\t \n\n\tif (*name == '/') {\n\t\t*name = '\\\\';\n\t}\n\n\t \n\n\tif (ACPI_IS_ROOT_PREFIX(*name)) {\n\t\tname++;\n\t}\n\n\t \n\n\twhile (*name) {\n\t\tif ((*name == '/') || (*name == '\\\\')) {\n\t\t\t*name = '.';\n\t\t}\n\n\t\tname++;\n\t}\n}\n\n \n\nstruct acpi_namespace_node *acpi_db_local_ns_lookup(char *name)\n{\n\tchar *internal_path;\n\tacpi_status status;\n\tstruct acpi_namespace_node *node = NULL;\n\n\tacpi_db_prep_namestring(name);\n\n\t \n\n\tstatus = acpi_ns_internalize_name(name, &internal_path);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Invalid namestring: %s\\n\", name);\n\t\treturn (NULL);\n\t}\n\n\t \n\tstatus = acpi_ns_lookup(NULL, internal_path, ACPI_TYPE_ANY,\n\t\t\t\tACPI_IMODE_EXECUTE,\n\t\t\t\tACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE,\n\t\t\t\tNULL, &node);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could not locate name: %s, %s\\n\",\n\t\t\t       name, acpi_format_exception(status));\n\t}\n\n\tACPI_FREE(internal_path);\n\treturn (node);\n}\n\n \n\nvoid acpi_db_uint32_to_hex_string(u32 value, char *buffer)\n{\n\tint i;\n\n\tif (value == 0) {\n\t\tstrcpy(buffer, \"0\");\n\t\treturn;\n\t}\n\n\tbuffer[8] = '\\0';\n\n\tfor (i = 7; i >= 0; i--) {\n\t\tbuffer[i] = acpi_gbl_upper_hex_digits[value & 0x0F];\n\t\tvalue = value >> 4;\n\t}\n}\n\n#ifdef ACPI_OBSOLETE_FUNCTIONS\n \n\nacpi_status acpi_db_second_pass_parse(union acpi_parse_object *root)\n{\n\tunion acpi_parse_object *op = root;\n\tunion acpi_parse_object *method;\n\tunion acpi_parse_object *search_op;\n\tunion acpi_parse_object *start_op;\n\tacpi_status status = AE_OK;\n\tu32 base_aml_offset;\n\tstruct acpi_walk_state *walk_state;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tacpi_os_printf(\"Pass two parse ....\\n\");\n\n\twhile (op) {\n\t\tif (op->common.aml_opcode == AML_METHOD_OP) {\n\t\t\tmethod = op;\n\n\t\t\t \n\n\t\t\twalk_state =\n\t\t\t    acpi_ds_create_walk_state(0, NULL, NULL, NULL);\n\t\t\tif (!walk_state) {\n\t\t\t\treturn (AE_NO_MEMORY);\n\t\t\t}\n\n\t\t\t \n\n\t\t\twalk_state->parser_state.aml =\n\t\t\t    walk_state->parser_state.aml_start =\n\t\t\t    method->named.data;\n\t\t\twalk_state->parser_state.aml_end =\n\t\t\t    walk_state->parser_state.pkg_end =\n\t\t\t    method->named.data + method->named.length;\n\t\t\twalk_state->parser_state.start_scope = op;\n\n\t\t\twalk_state->descending_callback =\n\t\t\t    acpi_ds_load1_begin_op;\n\t\t\twalk_state->ascending_callback = acpi_ds_load1_end_op;\n\n\t\t\t \n\n\t\t\tstatus = acpi_ps_parse_aml(walk_state);\n\n\t\t\tbase_aml_offset =\n\t\t\t    (method->common.value.arg)->common.aml_offset + 1;\n\t\t\tstart_op = (method->common.value.arg)->common.next;\n\t\t\tsearch_op = start_op;\n\n\t\t\twhile (search_op) {\n\t\t\t\tsearch_op->common.aml_offset += base_aml_offset;\n\t\t\t\tsearch_op =\n\t\t\t\t    acpi_ps_get_depth_next(start_op, search_op);\n\t\t\t}\n\t\t}\n\n\t\tif (op->common.aml_opcode == AML_REGION_OP) {\n\n\t\t\t \n\t\t\t \n\t\t}\n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tbreak;\n\t\t}\n\n\t\top = acpi_ps_get_depth_next(root, op);\n\t}\n\n\treturn (status);\n}\n\n \n\nvoid acpi_db_dump_buffer(u32 address)\n{\n\n\tacpi_os_printf(\"\\nLocation %X:\\n\", address);\n\n\tacpi_dbg_level |= ACPI_LV_TABLES;\n\tacpi_ut_debug_dump_buffer(ACPI_TO_POINTER(address), 64, DB_BYTE_DISPLAY,\n\t\t\t\t  ACPI_UINT32_MAX);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}