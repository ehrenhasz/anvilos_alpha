{
  "module_name": "psobject.c",
  "hash_id": "821b46fb479bfb672e08b7ccfaa4018339a1f2310f9993b3583dc0b8596a176c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/psobject.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acparser.h\"\n#include \"amlcode.h\"\n#include \"acconvert.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_PARSER\nACPI_MODULE_NAME(\"psobject\")\n\n \nstatic acpi_status acpi_ps_get_aml_opcode(struct acpi_walk_state *walk_state);\n\n \n\nstatic acpi_status acpi_ps_get_aml_opcode(struct acpi_walk_state *walk_state)\n{\n\tACPI_ERROR_ONLY(u32 aml_offset);\n\n\tACPI_FUNCTION_TRACE_PTR(ps_get_aml_opcode, walk_state);\n\n\twalk_state->aml = walk_state->parser_state.aml;\n\twalk_state->opcode = acpi_ps_peek_opcode(&(walk_state->parser_state));\n\n\t \n\twalk_state->op_info = acpi_ps_get_opcode_info(walk_state->opcode);\n\n\tswitch (walk_state->op_info->class) {\n\tcase AML_CLASS_ASCII:\n\tcase AML_CLASS_PREFIX:\n\t\t \n\t\twalk_state->opcode = AML_INT_NAMEPATH_OP;\n\t\twalk_state->arg_types = ARGP_NAMESTRING;\n\t\tbreak;\n\n\tcase AML_CLASS_UNKNOWN:\n\n\t\t \n\n\t\tif (walk_state->pass_number == 2) {\n\t\t\tACPI_ERROR_ONLY(aml_offset =\n\t\t\t\t\t(u32)ACPI_PTR_DIFF(walk_state->aml,\n\t\t\t\t\t\t\t   walk_state->\n\t\t\t\t\t\t\t   parser_state.\n\t\t\t\t\t\t\t   aml_start));\n\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Unknown opcode 0x%.2X at table offset 0x%.4X, ignoring\",\n\t\t\t\t    walk_state->opcode,\n\t\t\t\t    (u32)(aml_offset +\n\t\t\t\t\t  sizeof(struct acpi_table_header))));\n\n\t\t\tACPI_DUMP_BUFFER((walk_state->parser_state.aml - 16),\n\t\t\t\t\t 48);\n\n#ifdef ACPI_ASL_COMPILER\n\t\t\t \n\t\t\tacpi_os_printf\n\t\t\t    (\"/*\\nError: Unknown opcode 0x%.2X at table offset 0x%.4X, context:\\n\",\n\t\t\t     walk_state->opcode,\n\t\t\t     (u32)(aml_offset +\n\t\t\t\t   sizeof(struct acpi_table_header)));\n\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Aborting disassembly, AML byte code is corrupt\"));\n\n\t\t\t \n\n\t\t\tacpi_ut_dump_buffer(((u8 *)walk_state->parser_state.\n\t\t\t\t\t     aml - 16), 48, DB_BYTE_DISPLAY,\n\t\t\t\t\t    (aml_offset +\n\t\t\t\t\t     sizeof(struct acpi_table_header) -\n\t\t\t\t\t     16));\n\t\t\tacpi_os_printf(\" */\\n\");\n\n\t\t\t \n\t\t\treturn_ACPI_STATUS(AE_AML_BAD_OPCODE);\n#endif\n\t\t}\n\n\t\t \n\n\t\twalk_state->parser_state.aml++;\n\t\tif (walk_state->opcode > 0xFF) {\t \n\t\t\twalk_state->parser_state.aml++;\n\t\t}\n\n\t\treturn_ACPI_STATUS(AE_CTRL_PARSE_CONTINUE);\n\n\tdefault:\n\n\t\t \n\n\t\twalk_state->parser_state.aml +=\n\t\t    acpi_ps_get_opcode_size(walk_state->opcode);\n\t\twalk_state->arg_types = walk_state->op_info->parse_args;\n\t\tbreak;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ps_build_named_op(struct acpi_walk_state *walk_state,\n\t\t       u8 *aml_op_start,\n\t\t       union acpi_parse_object *unnamed_op,\n\t\t       union acpi_parse_object **op)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_parse_object *arg = NULL;\n\n\tACPI_FUNCTION_TRACE_PTR(ps_build_named_op, walk_state);\n\n\tunnamed_op->common.value.arg = NULL;\n\tunnamed_op->common.arg_list_length = 0;\n\tunnamed_op->common.aml_opcode = walk_state->opcode;\n\n\t \n\twhile (GET_CURRENT_ARG_TYPE(walk_state->arg_types) &&\n\t       (GET_CURRENT_ARG_TYPE(walk_state->arg_types) != ARGP_NAME)) {\n\t\tASL_CV_CAPTURE_COMMENTS(walk_state);\n\t\tstatus =\n\t\t    acpi_ps_get_next_arg(walk_state,\n\t\t\t\t\t &(walk_state->parser_state),\n\t\t\t\t\t GET_CURRENT_ARG_TYPE(walk_state->\n\t\t\t\t\t\t\t      arg_types), &arg);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\tacpi_ps_append_arg(unnamed_op, arg);\n\t\tINCREMENT_ARG_LIST(walk_state->arg_types);\n\t}\n\n\t \n\n\tASL_CV_CAPTURE_COMMENTS(walk_state);\n\n#ifdef ACPI_ASL_COMPILER\n\tif (acpi_gbl_current_inline_comment != NULL) {\n\t\tunnamed_op->common.name_comment =\n\t\t    acpi_gbl_current_inline_comment;\n\t\tacpi_gbl_current_inline_comment = NULL;\n\t}\n#endif\n\n\t \n\tif (!GET_CURRENT_ARG_TYPE(walk_state->arg_types)) {\n\t\treturn_ACPI_STATUS(AE_AML_NO_OPERAND);\n\t}\n\n\t \n\n\tINCREMENT_ARG_LIST(walk_state->arg_types);\n\n\t \n\twalk_state->op = NULL;\n\n\tstatus = walk_state->descending_callback(walk_state, op);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status != AE_CTRL_TERMINATE) {\n\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\"During name lookup/catalog\"));\n\t\t}\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tif (!*op) {\n\t\treturn_ACPI_STATUS(AE_CTRL_PARSE_CONTINUE);\n\t}\n\n\tstatus = acpi_ps_next_parse_state(walk_state, *op, status);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status == AE_CTRL_PENDING) {\n\t\t\tstatus = AE_CTRL_PARSE_PENDING;\n\t\t}\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tacpi_ps_append_arg(*op, unnamed_op->common.value.arg);\n\n#ifdef ACPI_ASL_COMPILER\n\n\t \n\n\t(*op)->common.inline_comment = unnamed_op->common.inline_comment;\n\t(*op)->common.end_node_comment = unnamed_op->common.end_node_comment;\n\t(*op)->common.close_brace_comment =\n\t    unnamed_op->common.close_brace_comment;\n\t(*op)->common.name_comment = unnamed_op->common.name_comment;\n\t(*op)->common.comment_list = unnamed_op->common.comment_list;\n\t(*op)->common.end_blk_comment = unnamed_op->common.end_blk_comment;\n\t(*op)->common.cv_filename = unnamed_op->common.cv_filename;\n\t(*op)->common.cv_parent_filename =\n\t    unnamed_op->common.cv_parent_filename;\n\t(*op)->named.aml = unnamed_op->common.aml;\n\n\tunnamed_op->common.inline_comment = NULL;\n\tunnamed_op->common.end_node_comment = NULL;\n\tunnamed_op->common.close_brace_comment = NULL;\n\tunnamed_op->common.name_comment = NULL;\n\tunnamed_op->common.comment_list = NULL;\n\tunnamed_op->common.end_blk_comment = NULL;\n#endif\n\n\tif ((*op)->common.aml_opcode == AML_REGION_OP ||\n\t    (*op)->common.aml_opcode == AML_DATA_REGION_OP) {\n\t\t \n\t\t(*op)->named.data = aml_op_start;\n\t\t(*op)->named.length = 0;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ps_create_op(struct acpi_walk_state *walk_state,\n\t\t  u8 *aml_op_start, union acpi_parse_object **new_op)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_parse_object *op;\n\tunion acpi_parse_object *named_op = NULL;\n\tunion acpi_parse_object *parent_scope;\n\tu8 argument_count;\n\tconst struct acpi_opcode_info *op_info;\n\n\tACPI_FUNCTION_TRACE_PTR(ps_create_op, walk_state);\n\n\tstatus = acpi_ps_get_aml_opcode(walk_state);\n\tif (status == AE_CTRL_PARSE_CONTINUE) {\n\t\treturn_ACPI_STATUS(AE_CTRL_PARSE_CONTINUE);\n\t}\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\twalk_state->op_info = acpi_ps_get_opcode_info(walk_state->opcode);\n\top = acpi_ps_alloc_op(walk_state->opcode, aml_op_start);\n\tif (!op) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tif (walk_state->op_info->flags & AML_NAMED) {\n\t\tstatus =\n\t\t    acpi_ps_build_named_op(walk_state, aml_op_start, op,\n\t\t\t\t\t   &named_op);\n\t\tacpi_ps_free_op(op);\n\n#ifdef ACPI_ASL_COMPILER\n\t\tif (acpi_gbl_disasm_flag\n\t\t    && walk_state->opcode == AML_EXTERNAL_OP\n\t\t    && status == AE_NOT_FOUND) {\n\t\t\t \n\t\t\twalk_state->aml = walk_state->parser_state.aml + 2;\n\t\t\twalk_state->parser_state.aml = walk_state->aml;\n\t\t\treturn_ACPI_STATUS(AE_CTRL_PARSE_CONTINUE);\n\t\t}\n#endif\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\t*new_op = named_op;\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tif (walk_state->op_info->flags & AML_CREATE) {\n\t\t \n\t\top->named.data = aml_op_start;\n\t\top->named.length = 0;\n\t}\n\n\tif (walk_state->opcode == AML_BANK_FIELD_OP) {\n\t\t \n\t\top->named.data = aml_op_start;\n\t\top->named.length = 0;\n\t}\n\n\tparent_scope = acpi_ps_get_parent_scope(&(walk_state->parser_state));\n\tacpi_ps_append_arg(parent_scope, op);\n\n\tif (parent_scope) {\n\t\top_info =\n\t\t    acpi_ps_get_opcode_info(parent_scope->common.aml_opcode);\n\t\tif (op_info->flags & AML_HAS_TARGET) {\n\t\t\targument_count =\n\t\t\t    acpi_ps_get_argument_count(op_info->type);\n\t\t\tif (parent_scope->common.arg_list_length >\n\t\t\t    argument_count) {\n\t\t\t\top->common.flags |= ACPI_PARSEOP_TARGET;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\telse if ((parent_scope->common.aml_opcode == AML_INCREMENT_OP)\n\t\t\t || (parent_scope->common.aml_opcode ==\n\t\t\t     AML_DECREMENT_OP)) {\n\t\t\top->common.flags |= ACPI_PARSEOP_TARGET;\n\t\t}\n\t}\n\n\tif (walk_state->descending_callback != NULL) {\n\t\t \n\t\twalk_state->op = *new_op = op;\n\n\t\tstatus = walk_state->descending_callback(walk_state, &op);\n\t\tstatus = acpi_ps_next_parse_state(walk_state, op, status);\n\t\tif (status == AE_CTRL_PENDING) {\n\t\t\tstatus = AE_CTRL_PARSE_PENDING;\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ps_complete_op(struct acpi_walk_state *walk_state,\n\t\t    union acpi_parse_object **op, acpi_status status)\n{\n\tacpi_status status2;\n\n\tACPI_FUNCTION_TRACE_PTR(ps_complete_op, walk_state);\n\n\t \n\twalk_state->parser_state.scope->parse_scope.arg_count--;\n\n\t \n\n\tstatus2 = acpi_ps_complete_this_op(walk_state, *op);\n\tif (ACPI_FAILURE(status2)) {\n\t\treturn_ACPI_STATUS(status2);\n\t}\n\n\t*op = NULL;\n\n\tswitch (status) {\n\tcase AE_OK:\n\n\t\tbreak;\n\n\tcase AE_CTRL_TRANSFER:\n\n\t\t \n\n\t\twalk_state->prev_op = NULL;\n\t\twalk_state->prev_arg_types = walk_state->arg_types;\n\t\treturn_ACPI_STATUS(status);\n\n\tcase AE_CTRL_END:\n\n\t\tacpi_ps_pop_scope(&(walk_state->parser_state), op,\n\t\t\t\t  &walk_state->arg_types,\n\t\t\t\t  &walk_state->arg_count);\n\n\t\tif (*op) {\n\t\t\twalk_state->op = *op;\n\t\t\twalk_state->op_info =\n\t\t\t    acpi_ps_get_opcode_info((*op)->common.aml_opcode);\n\t\t\twalk_state->opcode = (*op)->common.aml_opcode;\n\n\t\t\tstatus = walk_state->ascending_callback(walk_state);\n\t\t\t(void)acpi_ps_next_parse_state(walk_state, *op, status);\n\n\t\t\tstatus2 = acpi_ps_complete_this_op(walk_state, *op);\n\t\t\tif (ACPI_FAILURE(status2)) {\n\t\t\t\treturn_ACPI_STATUS(status2);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase AE_CTRL_BREAK:\n\tcase AE_CTRL_CONTINUE:\n\n\t\t \n\n\t\twhile (!(*op) || ((*op)->common.aml_opcode != AML_WHILE_OP)) {\n\t\t\tacpi_ps_pop_scope(&(walk_state->parser_state), op,\n\t\t\t\t\t  &walk_state->arg_types,\n\t\t\t\t\t  &walk_state->arg_count);\n\t\t}\n\n\t\t \n\n\t\twalk_state->op = *op;\n\t\twalk_state->op_info =\n\t\t    acpi_ps_get_opcode_info((*op)->common.aml_opcode);\n\t\twalk_state->opcode = (*op)->common.aml_opcode;\n\n\t\tstatus = walk_state->ascending_callback(walk_state);\n\t\t(void)acpi_ps_next_parse_state(walk_state, *op, status);\n\n\t\tstatus2 = acpi_ps_complete_this_op(walk_state, *op);\n\t\tif (ACPI_FAILURE(status2)) {\n\t\t\treturn_ACPI_STATUS(status2);\n\t\t}\n\n\t\tbreak;\n\n\tcase AE_CTRL_TERMINATE:\n\n\t\t \n\t\tdo {\n\t\t\tif (*op) {\n\t\t\t\tstatus2 =\n\t\t\t\t    acpi_ps_complete_this_op(walk_state, *op);\n\t\t\t\tif (ACPI_FAILURE(status2)) {\n\t\t\t\t\treturn_ACPI_STATUS(status2);\n\t\t\t\t}\n\n\t\t\t\tacpi_ut_delete_generic_state\n\t\t\t\t    (acpi_ut_pop_generic_state\n\t\t\t\t     (&walk_state->control_state));\n\t\t\t}\n\n\t\t\tacpi_ps_pop_scope(&(walk_state->parser_state), op,\n\t\t\t\t\t  &walk_state->arg_types,\n\t\t\t\t\t  &walk_state->arg_count);\n\n\t\t} while (*op);\n\n\t\treturn_ACPI_STATUS(AE_OK);\n\n\tdefault:\t\t \n\n\t\tdo {\n\t\t\tif (*op) {\n\t\t\t\t \n\t\t\t\tif (((*op)->common.aml_opcode == AML_REGION_OP)\n\t\t\t\t    || ((*op)->common.aml_opcode ==\n\t\t\t\t\tAML_DATA_REGION_OP)) {\n\t\t\t\t\tacpi_ns_delete_children((*op)->common.\n\t\t\t\t\t\t\t\tnode);\n\t\t\t\t\tacpi_ns_remove_node((*op)->common.node);\n\t\t\t\t\t(*op)->common.node = NULL;\n\t\t\t\t\tacpi_ps_delete_parse_tree(*op);\n\t\t\t\t}\n\n\t\t\t\tstatus2 =\n\t\t\t\t    acpi_ps_complete_this_op(walk_state, *op);\n\t\t\t\tif (ACPI_FAILURE(status2)) {\n\t\t\t\t\treturn_ACPI_STATUS(status2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tacpi_ps_pop_scope(&(walk_state->parser_state), op,\n\t\t\t\t\t  &walk_state->arg_types,\n\t\t\t\t\t  &walk_state->arg_count);\n\n\t\t} while (*op);\n\n#if 0\n\t\t \n\t\tif (*op == NULL) {\n\t\t\tacpi_ps_pop_scope(parser_state, op,\n\t\t\t\t\t  &walk_state->arg_types,\n\t\t\t\t\t  &walk_state->arg_count);\n\t\t}\n#endif\n\t\twalk_state->prev_op = NULL;\n\t\twalk_state->prev_arg_types = walk_state->arg_types;\n\n\t\tif (walk_state->parse_flags & ACPI_PARSE_MODULE_LEVEL) {\n\t\t\t \n\t\t\tACPI_INFO((\"Ignoring error and continuing table load\"));\n\t\t\treturn_ACPI_STATUS(AE_OK);\n\t\t}\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tif (acpi_ps_has_completed_scope(&(walk_state->parser_state))) {\n\t\tacpi_ps_pop_scope(&(walk_state->parser_state), op,\n\t\t\t\t  &walk_state->arg_types,\n\t\t\t\t  &walk_state->arg_count);\n\t\tACPI_DEBUG_PRINT((ACPI_DB_PARSE, \"Popped scope, Op=%p\\n\", *op));\n\t} else {\n\t\t*op = NULL;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ps_complete_final_op(struct acpi_walk_state *walk_state,\n\t\t\t  union acpi_parse_object *op, acpi_status status)\n{\n\tacpi_status status2;\n\n\tACPI_FUNCTION_TRACE_PTR(ps_complete_final_op, walk_state);\n\n\t \n\tACPI_DEBUG_PRINT((ACPI_DB_PARSE, \"AML package complete at Op %p\\n\",\n\t\t\t  op));\n\tdo {\n\t\tif (op) {\n\t\t\tif (walk_state->ascending_callback != NULL) {\n\t\t\t\twalk_state->op = op;\n\t\t\t\twalk_state->op_info =\n\t\t\t\t    acpi_ps_get_opcode_info(op->common.\n\t\t\t\t\t\t\t    aml_opcode);\n\t\t\t\twalk_state->opcode = op->common.aml_opcode;\n\n\t\t\t\tstatus =\n\t\t\t\t    walk_state->ascending_callback(walk_state);\n\t\t\t\tstatus =\n\t\t\t\t    acpi_ps_next_parse_state(walk_state, op,\n\t\t\t\t\t\t\t     status);\n\t\t\t\tif (status == AE_CTRL_PENDING) {\n\t\t\t\t\tstatus =\n\t\t\t\t\t    acpi_ps_complete_op(walk_state, &op,\n\t\t\t\t\t\t\t\tAE_OK);\n\t\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (status == AE_CTRL_TERMINATE) {\n\t\t\t\t\tstatus = AE_OK;\n\n\t\t\t\t\t \n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (op) {\n\t\t\t\t\t\t\tstatus2 =\n\t\t\t\t\t\t\t    acpi_ps_complete_this_op\n\t\t\t\t\t\t\t    (walk_state, op);\n\t\t\t\t\t\t\tif (ACPI_FAILURE\n\t\t\t\t\t\t\t    (status2)) {\n\t\t\t\t\t\t\t\treturn_ACPI_STATUS\n\t\t\t\t\t\t\t\t    (status2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tacpi_ps_pop_scope(&\n\t\t\t\t\t\t\t\t  (walk_state->\n\t\t\t\t\t\t\t\t   parser_state),\n\t\t\t\t\t\t\t\t  &op,\n\t\t\t\t\t\t\t\t  &walk_state->\n\t\t\t\t\t\t\t\t  arg_types,\n\t\t\t\t\t\t\t\t  &walk_state->\n\t\t\t\t\t\t\t\t  arg_count);\n\n\t\t\t\t\t} while (op);\n\n\t\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t\t}\n\n\t\t\t\telse if (ACPI_FAILURE(status)) {\n\n\t\t\t\t\t \n\n\t\t\t\t\t(void)\n\t\t\t\t\t    acpi_ps_complete_this_op(walk_state,\n\t\t\t\t\t\t\t\t     op);\n\t\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatus2 = acpi_ps_complete_this_op(walk_state, op);\n\t\t\tif (ACPI_FAILURE(status2)) {\n\t\t\t\treturn_ACPI_STATUS(status2);\n\t\t\t}\n\t\t}\n\n\t\tacpi_ps_pop_scope(&(walk_state->parser_state), &op,\n\t\t\t\t  &walk_state->arg_types,\n\t\t\t\t  &walk_state->arg_count);\n\n\t} while (op);\n\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}