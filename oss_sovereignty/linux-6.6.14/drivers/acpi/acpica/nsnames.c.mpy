{
  "module_name": "nsnames.c",
  "hash_id": "92200e787e3060ed6bb0cff5b822d81428100a2f5e8ce6ed3643c14c5e134a29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/nsnames.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"amlcode.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\nACPI_MODULE_NAME(\"nsnames\")\n\n \nchar *acpi_ns_get_external_pathname(struct acpi_namespace_node *node)\n{\n\tchar *name_buffer;\n\n\tACPI_FUNCTION_TRACE_PTR(ns_get_external_pathname, node);\n\n\tname_buffer = acpi_ns_get_normalized_pathname(node, FALSE);\n\treturn_PTR(name_buffer);\n}\n\n \n\nacpi_size acpi_ns_get_pathname_length(struct acpi_namespace_node *node)\n{\n\tacpi_size size;\n\n\t \n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(node) != ACPI_DESC_TYPE_NAMED) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Invalid/cached reference target node: %p, descriptor type %d\",\n\t\t\t    node, ACPI_GET_DESCRIPTOR_TYPE(node)));\n\t\treturn (0);\n\t}\n\n\tsize = acpi_ns_build_normalized_path(node, NULL, 0, FALSE);\n\treturn (size);\n}\n\n \n\nacpi_status\nacpi_ns_handle_to_name(acpi_handle target_handle, struct acpi_buffer *buffer)\n{\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\tconst char *node_name;\n\n\tACPI_FUNCTION_TRACE_PTR(ns_handle_to_name, target_handle);\n\n\tnode = acpi_ns_validate_handle(target_handle);\n\tif (!node) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tstatus = acpi_ut_initialize_buffer(buffer, ACPI_PATH_SEGMENT_LENGTH);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tnode_name = acpi_ut_get_node_name(node);\n\tACPI_COPY_NAMESEG(buffer->pointer, node_name);\n\t((char *)buffer->pointer)[ACPI_NAMESEG_SIZE] = 0;\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC, \"%4.4s\\n\", (char *)buffer->pointer));\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ns_handle_to_pathname(acpi_handle target_handle,\n\t\t\t   struct acpi_buffer *buffer, u8 no_trailing)\n{\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\tacpi_size required_size;\n\n\tACPI_FUNCTION_TRACE_PTR(ns_handle_to_pathname, target_handle);\n\n\tnode = acpi_ns_validate_handle(target_handle);\n\tif (!node) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\trequired_size =\n\t    acpi_ns_build_normalized_path(node, NULL, 0, no_trailing);\n\tif (!required_size) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tstatus = acpi_ut_initialize_buffer(buffer, required_size);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\t(void)acpi_ns_build_normalized_path(node, buffer->pointer,\n\t\t\t\t\t    (u32)required_size, no_trailing);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC, \"%s [%X]\\n\",\n\t\t\t  (char *)buffer->pointer, (u32) required_size));\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nu32\nacpi_ns_build_normalized_path(struct acpi_namespace_node *node,\n\t\t\t      char *full_path, u32 path_size, u8 no_trailing)\n{\n\tu32 length = 0, i;\n\tchar name[ACPI_NAMESEG_SIZE];\n\tu8 do_no_trailing;\n\tchar c, *left, *right;\n\tstruct acpi_namespace_node *next_node;\n\n\tACPI_FUNCTION_TRACE_PTR(ns_build_normalized_path, node);\n\n#define ACPI_PATH_PUT8(path, size, byte, length)    \\\n\tdo {                                            \\\n\t\tif ((length) < (size))                      \\\n\t\t{                                           \\\n\t\t\t(path)[(length)] = (byte);              \\\n\t\t}                                           \\\n\t\t(length)++;                                 \\\n\t} while (0)\n\n\t \n\tif (!full_path) {\n\t\tpath_size = 0;\n\t}\n\n\tif (!node) {\n\t\tgoto build_trailing_null;\n\t}\n\n\tnext_node = node;\n\twhile (next_node && next_node != acpi_gbl_root_node) {\n\t\tif (next_node != node) {\n\t\t\tACPI_PATH_PUT8(full_path, path_size,\n\t\t\t\t       AML_DUAL_NAME_PREFIX, length);\n\t\t}\n\n\t\tACPI_MOVE_32_TO_32(name, &next_node->name);\n\t\tdo_no_trailing = no_trailing;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tc = name[4 - i - 1];\n\t\t\tif (do_no_trailing && c != '_') {\n\t\t\t\tdo_no_trailing = FALSE;\n\t\t\t}\n\t\t\tif (!do_no_trailing) {\n\t\t\t\tACPI_PATH_PUT8(full_path, path_size, c, length);\n\t\t\t}\n\t\t}\n\n\t\tnext_node = next_node->parent;\n\t}\n\n\tACPI_PATH_PUT8(full_path, path_size, AML_ROOT_PREFIX, length);\n\n\t \n\n\tif (length <= path_size) {\n\t\tleft = full_path;\n\t\tright = full_path + length - 1;\n\n\t\twhile (left < right) {\n\t\t\tc = *left;\n\t\t\t*left++ = *right;\n\t\t\t*right-- = c;\n\t\t}\n\t}\n\n\t \n\nbuild_trailing_null:\n\tACPI_PATH_PUT8(full_path, path_size, '\\0', length);\n\n#undef ACPI_PATH_PUT8\n\n\treturn_UINT32(length);\n}\n\n \n\nchar *acpi_ns_get_normalized_pathname(struct acpi_namespace_node *node,\n\t\t\t\t      u8 no_trailing)\n{\n\tchar *name_buffer;\n\tacpi_size size;\n\n\tACPI_FUNCTION_TRACE_PTR(ns_get_normalized_pathname, node);\n\n\t \n\n\tsize = acpi_ns_build_normalized_path(node, NULL, 0, no_trailing);\n\tif (!size) {\n\t\treturn_PTR(NULL);\n\t}\n\n\t \n\n\tname_buffer = ACPI_ALLOCATE_ZEROED(size);\n\tif (!name_buffer) {\n\t\tACPI_ERROR((AE_INFO, \"Could not allocate %u bytes\", (u32)size));\n\t\treturn_PTR(NULL);\n\t}\n\n\t \n\n\t(void)acpi_ns_build_normalized_path(node, name_buffer, (u32)size,\n\t\t\t\t\t    no_trailing);\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_NAMES, \"%s: Path \\\"%s\\\"\\n\",\n\t\t\t      ACPI_GET_FUNCTION_NAME, name_buffer));\n\n\treturn_PTR(name_buffer);\n}\n\n \n\nchar *acpi_ns_build_prefixed_pathname(union acpi_generic_state *prefix_scope,\n\t\t\t\t      const char *internal_path)\n{\n\tacpi_status status;\n\tchar *full_path = NULL;\n\tchar *external_path = NULL;\n\tchar *prefix_path = NULL;\n\tacpi_size prefix_path_length = 0;\n\n\t \n\n\tif (prefix_scope && prefix_scope->scope.node) {\n\t\tprefix_path =\n\t\t    acpi_ns_get_normalized_pathname(prefix_scope->scope.node,\n\t\t\t\t\t\t    TRUE);\n\t\tif (prefix_path) {\n\t\t\tprefix_path_length = strlen(prefix_path);\n\t\t}\n\t}\n\n\tstatus = acpi_ns_externalize_name(ACPI_UINT32_MAX, internal_path,\n\t\t\t\t\t  NULL, &external_path);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tfull_path =\n\t    ACPI_ALLOCATE_ZEROED(prefix_path_length + strlen(external_path) +\n\t\t\t\t 2);\n\tif (!full_path) {\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tif (prefix_path && (*external_path != '\\\\') && (*external_path != '^')) {\n\t\tstrcat(full_path, prefix_path);\n\t\tif (prefix_path[1]) {\n\t\t\tstrcat(full_path, \".\");\n\t\t}\n\t}\n\n\tacpi_ns_normalize_pathname(external_path);\n\tstrcat(full_path, external_path);\n\ncleanup:\n\tif (prefix_path) {\n\t\tACPI_FREE(prefix_path);\n\t}\n\tif (external_path) {\n\t\tACPI_FREE(external_path);\n\t}\n\n\treturn (full_path);\n}\n\n \n\nvoid acpi_ns_normalize_pathname(char *original_path)\n{\n\tchar *input_path = original_path;\n\tchar *new_path_buffer;\n\tchar *new_path;\n\tu32 i;\n\n\t \n\n\tnew_path_buffer = ACPI_ALLOCATE_ZEROED(strlen(input_path) + 1);\n\tnew_path = new_path_buffer;\n\tif (!new_path_buffer) {\n\t\treturn;\n\t}\n\n\t \n\n\tif (*input_path == '\\\\') {\n\t\t*new_path = *input_path;\n\t\tnew_path++;\n\t\tinput_path++;\n\t}\n\n\twhile (*input_path == '^') {\n\t\t*new_path = *input_path;\n\t\tnew_path++;\n\t\tinput_path++;\n\t}\n\n\t \n\n\twhile (*input_path) {\n\n\t\t \n\n\t\tfor (i = 0; (i < ACPI_NAMESEG_SIZE) && *input_path; i++) {\n\t\t\tif ((i == 0) || (*input_path != '_')) {\t \n\t\t\t\t*new_path = *input_path;\n\t\t\t\tnew_path++;\n\t\t\t}\n\n\t\t\tinput_path++;\n\t\t}\n\n\t\t \n\n\t\tif (*input_path == '.') {\n\t\t\t*new_path = *input_path;\n\t\t\tnew_path++;\n\t\t\tinput_path++;\n\t\t}\n\t}\n\n\t*new_path = 0;\n\tstrcpy(original_path, new_path_buffer);\n\tACPI_FREE(new_path_buffer);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}