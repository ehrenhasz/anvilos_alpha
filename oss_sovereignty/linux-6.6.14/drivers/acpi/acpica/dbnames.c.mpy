{
  "module_name": "dbnames.c",
  "hash_id": "a4a0bfa2b8645a8666c8346e4bc41bfb80518a1cab3aaa95bb043f9bedef0712",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/dbnames.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"acdebug.h\"\n#include \"acpredef.h\"\n#include \"acinterp.h\"\n\n#define _COMPONENT          ACPI_CA_DEBUGGER\nACPI_MODULE_NAME(\"dbnames\")\n\n \nstatic acpi_status\nacpi_db_walk_and_match_name(acpi_handle obj_handle,\n\t\t\t    u32 nesting_level,\n\t\t\t    void *context, void **return_value);\n\nstatic acpi_status\nacpi_db_walk_for_predefined_names(acpi_handle obj_handle,\n\t\t\t\t  u32 nesting_level,\n\t\t\t\t  void *context, void **return_value);\n\nstatic acpi_status\nacpi_db_walk_for_specific_objects(acpi_handle obj_handle,\n\t\t\t\t  u32 nesting_level,\n\t\t\t\t  void *context, void **return_value);\n\nstatic acpi_status\nacpi_db_walk_for_object_counts(acpi_handle obj_handle,\n\t\t\t       u32 nesting_level,\n\t\t\t       void *context, void **return_value);\n\nstatic acpi_status\nacpi_db_integrity_walk(acpi_handle obj_handle,\n\t\t       u32 nesting_level, void *context, void **return_value);\n\nstatic acpi_status\nacpi_db_walk_for_references(acpi_handle obj_handle,\n\t\t\t    u32 nesting_level,\n\t\t\t    void *context, void **return_value);\n\nstatic acpi_status\nacpi_db_bus_walk(acpi_handle obj_handle,\n\t\t u32 nesting_level, void *context, void **return_value);\n\n \nstatic struct acpi_db_argument_info acpi_db_object_types[] = {\n\t{\"ANY\"},\n\t{\"INTEGERS\"},\n\t{\"STRINGS\"},\n\t{\"BUFFERS\"},\n\t{\"PACKAGES\"},\n\t{\"FIELDS\"},\n\t{\"DEVICES\"},\n\t{\"EVENTS\"},\n\t{\"METHODS\"},\n\t{\"MUTEXES\"},\n\t{\"REGIONS\"},\n\t{\"POWERRESOURCES\"},\n\t{\"PROCESSORS\"},\n\t{\"THERMALZONES\"},\n\t{\"BUFFERFIELDS\"},\n\t{\"DDBHANDLES\"},\n\t{\"DEBUG\"},\n\t{\"REGIONFIELDS\"},\n\t{\"BANKFIELDS\"},\n\t{\"INDEXFIELDS\"},\n\t{\"REFERENCES\"},\n\t{\"ALIASES\"},\n\t{\"METHODALIASES\"},\n\t{\"NOTIFY\"},\n\t{\"ADDRESSHANDLER\"},\n\t{\"RESOURCE\"},\n\t{\"RESOURCEFIELD\"},\n\t{\"SCOPES\"},\n\t{NULL}\t\t\t \n};\n\n \n\nvoid acpi_db_set_scope(char *name)\n{\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\n\tif (!name || name[0] == 0) {\n\t\tacpi_os_printf(\"Current scope: %s\\n\", acpi_gbl_db_scope_buf);\n\t\treturn;\n\t}\n\n\tacpi_db_prep_namestring(name);\n\n\tif (ACPI_IS_ROOT_PREFIX(name[0])) {\n\n\t\t \n\n\t\tstatus = acpi_ns_get_node(acpi_gbl_root_node, name,\n\t\t\t\t\t  ACPI_NS_NO_UPSEARCH, &node);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto error_exit;\n\t\t}\n\n\t\tacpi_gbl_db_scope_buf[0] = 0;\n\t} else {\n\t\t \n\n\t\tstatus = acpi_ns_get_node(acpi_gbl_db_scope_node, name,\n\t\t\t\t\t  ACPI_NS_NO_UPSEARCH, &node);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto error_exit;\n\t\t}\n\t}\n\n\t \n\n\tif (acpi_ut_safe_strcat\n\t    (acpi_gbl_db_scope_buf, sizeof(acpi_gbl_db_scope_buf), name)) {\n\t\tstatus = AE_BUFFER_OVERFLOW;\n\t\tgoto error_exit;\n\t}\n\n\tif (acpi_ut_safe_strcat\n\t    (acpi_gbl_db_scope_buf, sizeof(acpi_gbl_db_scope_buf), \"\\\\\")) {\n\t\tstatus = AE_BUFFER_OVERFLOW;\n\t\tgoto error_exit;\n\t}\n\n\tacpi_gbl_db_scope_node = node;\n\tacpi_os_printf(\"New scope: %s\\n\", acpi_gbl_db_scope_buf);\n\treturn;\n\nerror_exit:\n\n\tacpi_os_printf(\"Could not attach scope: %s, %s\\n\",\n\t\t       name, acpi_format_exception(status));\n}\n\n \n\nvoid acpi_db_dump_namespace(char *start_arg, char *depth_arg)\n{\n\tacpi_handle subtree_entry = acpi_gbl_root_node;\n\tu32 max_depth = ACPI_UINT32_MAX;\n\n\t \n\n\tif (start_arg) {\n\t\tsubtree_entry = acpi_db_convert_to_node(start_arg);\n\t\tif (!subtree_entry) {\n\t\t\treturn;\n\t\t}\n\n\t\t \n\n\t\tif (depth_arg) {\n\t\t\tmax_depth = strtoul(depth_arg, NULL, 0);\n\t\t}\n\t}\n\n\tacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\n\n\tif (((struct acpi_namespace_node *)subtree_entry)->parent) {\n\t\tacpi_os_printf(\"ACPI Namespace (from %4.4s (%p) subtree):\\n\",\n\t\t\t       ((struct acpi_namespace_node *)subtree_entry)->\n\t\t\t       name.ascii, subtree_entry);\n\t} else {\n\t\tacpi_os_printf(\"ACPI Namespace (from %s):\\n\",\n\t\t\t       ACPI_NAMESPACE_ROOT);\n\t}\n\n\t \n\n\tacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\n\tacpi_ns_dump_objects(ACPI_TYPE_ANY, ACPI_DISPLAY_SUMMARY, max_depth,\n\t\t\t     ACPI_OWNER_ID_MAX, subtree_entry);\n\tacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\n}\n\n \n\nvoid acpi_db_dump_namespace_paths(void)\n{\n\n\tacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\n\tacpi_os_printf(\"ACPI Namespace (from root):\\n\");\n\n\t \n\n\tacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\n\tacpi_ns_dump_object_paths(ACPI_TYPE_ANY, ACPI_DISPLAY_SUMMARY,\n\t\t\t\t  ACPI_UINT32_MAX, ACPI_OWNER_ID_MAX,\n\t\t\t\t  acpi_gbl_root_node);\n\n\tacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\n}\n\n \n\nvoid acpi_db_dump_namespace_by_owner(char *owner_arg, char *depth_arg)\n{\n\tacpi_handle subtree_entry = acpi_gbl_root_node;\n\tu32 max_depth = ACPI_UINT32_MAX;\n\tacpi_owner_id owner_id;\n\n\towner_id = (acpi_owner_id)strtoul(owner_arg, NULL, 0);\n\n\t \n\n\tif (depth_arg) {\n\t\tmax_depth = strtoul(depth_arg, NULL, 0);\n\t}\n\n\tacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\n\tacpi_os_printf(\"ACPI Namespace by owner %X:\\n\", owner_id);\n\n\t \n\n\tacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\n\tacpi_ns_dump_objects(ACPI_TYPE_ANY, ACPI_DISPLAY_SUMMARY, max_depth,\n\t\t\t     owner_id, subtree_entry);\n\tacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\n}\n\n \n\nstatic acpi_status\nacpi_db_walk_and_match_name(acpi_handle obj_handle,\n\t\t\t    u32 nesting_level,\n\t\t\t    void *context, void **return_value)\n{\n\tacpi_status status;\n\tchar *requested_name = (char *)context;\n\tu32 i;\n\tstruct acpi_buffer buffer;\n\tstruct acpi_walk_info info;\n\n\t \n\n\tfor (i = 0; i < 4; i++) {\n\n\t\t \n\n\t\tif ((requested_name[i] != '?') &&\n\t\t    (requested_name[i] != ((struct acpi_namespace_node *)\n\t\t\t\t\t   obj_handle)->name.ascii[i])) {\n\n\t\t\t \n\n\t\t\treturn (AE_OK);\n\t\t}\n\t}\n\n\t \n\n\tbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\tstatus = acpi_ns_handle_to_pathname(obj_handle, &buffer, TRUE);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could Not get pathname for object %p\\n\",\n\t\t\t       obj_handle);\n\t} else {\n\t\tinfo.count = 0;\n\t\tinfo.owner_id = ACPI_OWNER_ID_MAX;\n\t\tinfo.debug_level = ACPI_UINT32_MAX;\n\t\tinfo.display_type = ACPI_DISPLAY_SUMMARY | ACPI_DISPLAY_SHORT;\n\n\t\tacpi_os_printf(\"%32s\", (char *)buffer.pointer);\n\t\t(void)acpi_ns_dump_one_object(obj_handle, nesting_level, &info,\n\t\t\t\t\t      NULL);\n\t\tACPI_FREE(buffer.pointer);\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_db_find_name_in_namespace(char *name_arg)\n{\n\tchar acpi_name[5] = \"____\";\n\tchar *acpi_name_ptr = acpi_name;\n\n\tif (strlen(name_arg) > ACPI_NAMESEG_SIZE) {\n\t\tacpi_os_printf(\"Name must be no longer than 4 characters\\n\");\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tacpi_ut_strupr(name_arg);\n\twhile (*name_arg) {\n\t\t*acpi_name_ptr = *name_arg;\n\t\tacpi_name_ptr++;\n\t\tname_arg++;\n\t}\n\n\t \n\n\t(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\n\t\t\t\t  ACPI_UINT32_MAX, acpi_db_walk_and_match_name,\n\t\t\t\t  NULL, acpi_name, NULL);\n\n\tacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_db_walk_for_predefined_names(acpi_handle obj_handle,\n\t\t\t\t  u32 nesting_level,\n\t\t\t\t  void *context, void **return_value)\n{\n\tstruct acpi_namespace_node *node =\n\t    (struct acpi_namespace_node *)obj_handle;\n\tu32 *count = (u32 *)context;\n\tconst union acpi_predefined_info *predefined;\n\tconst union acpi_predefined_info *package = NULL;\n\tchar *pathname;\n\tchar string_buffer[48];\n\n\tpredefined = acpi_ut_match_predefined_method(node->name.ascii);\n\tif (!predefined) {\n\t\treturn (AE_OK);\n\t}\n\n\tpathname = acpi_ns_get_normalized_pathname(node, TRUE);\n\tif (!pathname) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tif (predefined->info.expected_btypes & ACPI_RTYPE_PACKAGE) {\n\t\tpackage = predefined + 1;\n\t}\n\n\tacpi_ut_get_expected_return_types(string_buffer,\n\t\t\t\t\t  predefined->info.expected_btypes);\n\n\tacpi_os_printf(\"%-32s Arguments %X, Return Types: %s\", pathname,\n\t\t       METHOD_GET_ARG_COUNT(predefined->info.argument_list),\n\t\t       string_buffer);\n\n\tif (package) {\n\t\tacpi_os_printf(\" (PkgType %2.2X, ObjType %2.2X, Count %2.2X)\",\n\t\t\t       package->ret_info.type,\n\t\t\t       package->ret_info.object_type1,\n\t\t\t       package->ret_info.count1);\n\t}\n\n\tacpi_os_printf(\"\\n\");\n\n\t \n\n\tacpi_ns_check_acpi_compliance(pathname, node, predefined);\n\n\tACPI_FREE(pathname);\n\t(*count)++;\n\treturn (AE_OK);\n}\n\n \n\nvoid acpi_db_check_predefined_names(void)\n{\n\tu32 count = 0;\n\n\t \n\n\t(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\n\t\t\t\t  ACPI_UINT32_MAX,\n\t\t\t\t  acpi_db_walk_for_predefined_names, NULL,\n\t\t\t\t  (void *)&count, NULL);\n\n\tacpi_os_printf(\"Found %u predefined names in the namespace\\n\", count);\n}\n\n \n\nstatic acpi_status\nacpi_db_walk_for_object_counts(acpi_handle obj_handle,\n\t\t\t       u32 nesting_level,\n\t\t\t       void *context, void **return_value)\n{\n\tstruct acpi_object_info *info = (struct acpi_object_info *)context;\n\tstruct acpi_namespace_node *node =\n\t    (struct acpi_namespace_node *)obj_handle;\n\n\tif (node->type > ACPI_TYPE_NS_NODE_MAX) {\n\t\tacpi_os_printf(\"[%4.4s]: Unknown object type %X\\n\",\n\t\t\t       node->name.ascii, node->type);\n\t} else {\n\t\tinfo->types[node->type]++;\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_db_walk_for_fields(acpi_handle obj_handle,\n\t\t\tu32 nesting_level, void *context, void **return_value)\n{\n\tunion acpi_object *ret_value;\n\tstruct acpi_region_walk_info *info =\n\t    (struct acpi_region_walk_info *)context;\n\tstruct acpi_buffer buffer;\n\tacpi_status status;\n\tstruct acpi_namespace_node *node = acpi_ns_validate_handle(obj_handle);\n\n\tif (!node) {\n\t\treturn (AE_OK);\n\t}\n\tif (node->object->field.region_obj->region.space_id !=\n\t    info->address_space_id) {\n\t\treturn (AE_OK);\n\t}\n\n\tinfo->count++;\n\n\t \n\n\tbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\tstatus = acpi_ns_handle_to_pathname(obj_handle, &buffer, TRUE);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could Not get pathname for object %p\\n\",\n\t\t\t       obj_handle);\n\t\treturn (AE_OK);\n\t}\n\n\tacpi_os_printf(\"%s \", (char *)buffer.pointer);\n\tACPI_FREE(buffer.pointer);\n\n\tbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\tacpi_evaluate_object(obj_handle, NULL, NULL, &buffer);\n\n\t \n\tacpi_os_printf(\"{\");\n\n\tret_value = (union acpi_object *)buffer.pointer;\n\tswitch (ret_value->type) {\n\tcase ACPI_TYPE_INTEGER:\n\n\t\tacpi_os_printf(\"%8.8X%8.8X\",\n\t\t\t       ACPI_FORMAT_UINT64(ret_value->integer.value));\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\tacpi_ut_dump_buffer(ret_value->buffer.pointer,\n\t\t\t\t    ret_value->buffer.length,\n\t\t\t\t    DB_DISPLAY_DATA_ONLY | DB_BYTE_DISPLAY, 0);\n\t\tbreak;\n\n\tdefault:\n\n\t\tbreak;\n\t}\n\tacpi_os_printf(\"}\\n\");\n\n\tACPI_FREE(buffer.pointer);\n\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_db_walk_for_specific_objects(acpi_handle obj_handle,\n\t\t\t\t  u32 nesting_level,\n\t\t\t\t  void *context, void **return_value)\n{\n\tstruct acpi_walk_info *info = (struct acpi_walk_info *)context;\n\tstruct acpi_buffer buffer;\n\tacpi_status status;\n\n\tinfo->count++;\n\n\t \n\n\tbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\tstatus = acpi_ns_handle_to_pathname(obj_handle, &buffer, TRUE);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could Not get pathname for object %p\\n\",\n\t\t\t       obj_handle);\n\t\treturn (AE_OK);\n\t}\n\n\tacpi_os_printf(\"%32s\", (char *)buffer.pointer);\n\tACPI_FREE(buffer.pointer);\n\n\t \n\n\t(void)acpi_ns_dump_one_object(obj_handle, nesting_level, info, NULL);\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_db_display_objects(char *obj_type_arg, char *display_count_arg)\n{\n\tstruct acpi_walk_info info;\n\tacpi_object_type type;\n\tstruct acpi_object_info *object_info;\n\tu32 i;\n\tu32 total_objects = 0;\n\n\t \n\n\tif (!obj_type_arg) {\n\t\tobject_info =\n\t\t    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_object_info));\n\n\t\tif (!object_info)\n\t\t\treturn (AE_NO_MEMORY);\n\n\t\t \n\n\t\t(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\n\t\t\t\t\t  ACPI_UINT32_MAX,\n\t\t\t\t\t  acpi_db_walk_for_object_counts, NULL,\n\t\t\t\t\t  (void *)object_info, NULL);\n\n\t\tacpi_os_printf(\"\\nSummary of namespace objects:\\n\\n\");\n\n\t\tfor (i = 0; i < ACPI_TOTAL_TYPES; i++) {\n\t\t\tacpi_os_printf(\"%8u %s\\n\", object_info->types[i],\n\t\t\t\t       acpi_ut_get_type_name(i));\n\n\t\t\ttotal_objects += object_info->types[i];\n\t\t}\n\n\t\tacpi_os_printf(\"\\n%8u Total namespace objects\\n\\n\",\n\t\t\t       total_objects);\n\n\t\tACPI_FREE(object_info);\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\ttype = acpi_db_match_argument(obj_type_arg, acpi_db_object_types);\n\tif (type == ACPI_TYPE_NOT_FOUND) {\n\t\tacpi_os_printf(\"Invalid or unsupported argument\\n\");\n\t\treturn (AE_OK);\n\t}\n\n\tacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\n\tacpi_os_printf\n\t    (\"Objects of type [%s] defined in the current ACPI Namespace:\\n\",\n\t     acpi_ut_get_type_name(type));\n\n\tacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\n\n\tinfo.count = 0;\n\tinfo.owner_id = ACPI_OWNER_ID_MAX;\n\tinfo.debug_level = ACPI_UINT32_MAX;\n\tinfo.display_type = ACPI_DISPLAY_SUMMARY | ACPI_DISPLAY_SHORT;\n\n\t \n\n\t(void)acpi_walk_namespace(type, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,\n\t\t\t\t  acpi_db_walk_for_specific_objects, NULL,\n\t\t\t\t  (void *)&info, NULL);\n\n\tacpi_os_printf\n\t    (\"\\nFound %u objects of type [%s] in the current ACPI Namespace\\n\",\n\t     info.count, acpi_ut_get_type_name(type));\n\n\tacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_db_display_fields(u32 address_space_id)\n{\n\tstruct acpi_region_walk_info info;\n\n\tinfo.count = 0;\n\tinfo.owner_id = ACPI_OWNER_ID_MAX;\n\tinfo.debug_level = ACPI_UINT32_MAX;\n\tinfo.display_type = ACPI_DISPLAY_SUMMARY | ACPI_DISPLAY_SHORT;\n\tinfo.address_space_id = address_space_id;\n\n\t \n\n\t(void)acpi_walk_namespace(ACPI_TYPE_LOCAL_REGION_FIELD,\n\t\t\t\t  ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,\n\t\t\t\t  acpi_db_walk_for_fields, NULL, (void *)&info,\n\t\t\t\t  NULL);\n\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_db_integrity_walk(acpi_handle obj_handle,\n\t\t       u32 nesting_level, void *context, void **return_value)\n{\n\tstruct acpi_integrity_info *info =\n\t    (struct acpi_integrity_info *)context;\n\tstruct acpi_namespace_node *node =\n\t    (struct acpi_namespace_node *)obj_handle;\n\tunion acpi_operand_object *object;\n\tu8 alias = TRUE;\n\n\tinfo->nodes++;\n\n\t \n\n\twhile (alias) {\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(node) != ACPI_DESC_TYPE_NAMED) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Invalid Descriptor Type for Node %p [%s] - \"\n\t\t\t     \"is %2.2X should be %2.2X\\n\", node,\n\t\t\t     acpi_ut_get_descriptor_name(node),\n\t\t\t     ACPI_GET_DESCRIPTOR_TYPE(node),\n\t\t\t     ACPI_DESC_TYPE_NAMED);\n\t\t\treturn (AE_OK);\n\t\t}\n\n\t\tif ((node->type == ACPI_TYPE_LOCAL_ALIAS) ||\n\t\t    (node->type == ACPI_TYPE_LOCAL_METHOD_ALIAS)) {\n\t\t\tnode = (struct acpi_namespace_node *)node->object;\n\t\t} else {\n\t\t\talias = FALSE;\n\t\t}\n\t}\n\n\tif (node->type > ACPI_TYPE_LOCAL_MAX) {\n\t\tacpi_os_printf(\"Invalid Object Type for Node %p, Type = %X\\n\",\n\t\t\t       node, node->type);\n\t\treturn (AE_OK);\n\t}\n\n\tif (!acpi_ut_valid_nameseg(node->name.ascii)) {\n\t\tacpi_os_printf(\"Invalid AcpiName for Node %p\\n\", node);\n\t\treturn (AE_OK);\n\t}\n\n\tobject = acpi_ns_get_attached_object(node);\n\tif (object) {\n\t\tinfo->objects++;\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(object) != ACPI_DESC_TYPE_OPERAND) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Invalid Descriptor Type for Object %p [%s]\\n\",\n\t\t\t     object, acpi_ut_get_descriptor_name(object));\n\t\t}\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nvoid acpi_db_check_integrity(void)\n{\n\tstruct acpi_integrity_info info = { 0, 0 };\n\n\t \n\n\t(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\n\t\t\t\t  ACPI_UINT32_MAX, acpi_db_integrity_walk, NULL,\n\t\t\t\t  (void *)&info, NULL);\n\n\tacpi_os_printf(\"Verified %u namespace nodes with %u Objects\\n\",\n\t\t       info.nodes, info.objects);\n}\n\n \n\nstatic acpi_status\nacpi_db_walk_for_references(acpi_handle obj_handle,\n\t\t\t    u32 nesting_level,\n\t\t\t    void *context, void **return_value)\n{\n\tunion acpi_operand_object *obj_desc =\n\t    (union acpi_operand_object *)context;\n\tstruct acpi_namespace_node *node =\n\t    (struct acpi_namespace_node *)obj_handle;\n\n\t \n\n\tif (node == (void *)obj_desc) {\n\t\tacpi_os_printf(\"Object is a Node [%4.4s]\\n\",\n\t\t\t       acpi_ut_get_node_name(node));\n\t}\n\n\t \n\n\tif (acpi_ns_get_attached_object(node) == obj_desc) {\n\t\tacpi_os_printf(\"Reference at Node->Object %p [%4.4s]\\n\",\n\t\t\t       node, acpi_ut_get_node_name(node));\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nvoid acpi_db_find_references(char *object_arg)\n{\n\tunion acpi_operand_object *obj_desc;\n\tacpi_size address;\n\n\t \n\n\taddress = strtoul(object_arg, NULL, 16);\n\tobj_desc = ACPI_TO_POINTER(address);\n\n\t \n\n\t(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\n\t\t\t\t  ACPI_UINT32_MAX, acpi_db_walk_for_references,\n\t\t\t\t  NULL, (void *)obj_desc, NULL);\n}\n\n \n\nstatic acpi_status\nacpi_db_bus_walk(acpi_handle obj_handle,\n\t\t u32 nesting_level, void *context, void **return_value)\n{\n\tstruct acpi_namespace_node *node =\n\t    (struct acpi_namespace_node *)obj_handle;\n\tacpi_status status;\n\tstruct acpi_buffer buffer;\n\tstruct acpi_namespace_node *temp_node;\n\tstruct acpi_device_info *info;\n\tu32 i;\n\n\tif ((node->type != ACPI_TYPE_DEVICE) &&\n\t    (node->type != ACPI_TYPE_PROCESSOR)) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tstatus = acpi_get_handle(node, METHOD_NAME__PRT,\n\t\t\t\t ACPI_CAST_PTR(acpi_handle, &temp_node));\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\tstatus = acpi_ns_handle_to_pathname(obj_handle, &buffer, TRUE);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_printf(\"Could Not get pathname for object %p\\n\",\n\t\t\t       obj_handle);\n\t\treturn (AE_OK);\n\t}\n\n\tstatus = acpi_get_object_info(obj_handle, &info);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tacpi_os_printf(\"%-32s Type %X\", (char *)buffer.pointer, node->type);\n\tACPI_FREE(buffer.pointer);\n\n\tif (info->flags & ACPI_PCI_ROOT_BRIDGE) {\n\t\tacpi_os_printf(\" - Is PCI Root Bridge\");\n\t}\n\tacpi_os_printf(\"\\n\");\n\n\t \n\n\tacpi_os_printf(\"_PRT: %p\\n\", temp_node);\n\n\t \n\n\tif (info->valid & ACPI_VALID_ADR) {\n\t\tacpi_os_printf(\"_ADR: %8.8X%8.8X\\n\",\n\t\t\t       ACPI_FORMAT_UINT64(info->address));\n\t} else {\n\t\tacpi_os_printf(\"_ADR: <Not Present>\\n\");\n\t}\n\n\tif (info->valid & ACPI_VALID_HID) {\n\t\tacpi_os_printf(\"_HID: %s\\n\", info->hardware_id.string);\n\t} else {\n\t\tacpi_os_printf(\"_HID: <Not Present>\\n\");\n\t}\n\n\tif (info->valid & ACPI_VALID_UID) {\n\t\tacpi_os_printf(\"_UID: %s\\n\", info->unique_id.string);\n\t} else {\n\t\tacpi_os_printf(\"_UID: <Not Present>\\n\");\n\t}\n\n\tif (info->valid & ACPI_VALID_CID) {\n\t\tfor (i = 0; i < info->compatible_id_list.count; i++) {\n\t\t\tacpi_os_printf(\"_CID: %s\\n\",\n\t\t\t\t       info->compatible_id_list.ids[i].string);\n\t\t}\n\t} else {\n\t\tacpi_os_printf(\"_CID: <Not Present>\\n\");\n\t}\n\n\tACPI_FREE(info);\n\treturn (AE_OK);\n}\n\n \n\nvoid acpi_db_get_bus_info(void)\n{\n\t \n\n\t(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\n\t\t\t\t  ACPI_UINT32_MAX, acpi_db_bus_walk, NULL, NULL,\n\t\t\t\t  NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}