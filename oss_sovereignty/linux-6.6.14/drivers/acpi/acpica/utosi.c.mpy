{
  "module_name": "utosi.c",
  "hash_id": "dd87a24070fda045b090347a7ab5df73f178cb86fc179430a58a406f91748106",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utosi.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utosi\")\n\n \n \nstatic struct acpi_interface_info acpi_default_supported_interfaces[] = {\n\t \n\n\t{\"Windows 2000\", NULL, 0, ACPI_OSI_WIN_2000},\t \n\t{\"Windows 2001\", NULL, 0, ACPI_OSI_WIN_XP},\t \n\t{\"Windows 2001 SP1\", NULL, 0, ACPI_OSI_WIN_XP_SP1},\t \n\t{\"Windows 2001.1\", NULL, 0, ACPI_OSI_WINSRV_2003},\t \n\t{\"Windows 2001 SP2\", NULL, 0, ACPI_OSI_WIN_XP_SP2},\t \n\t{\"Windows 2001.1 SP1\", NULL, 0, ACPI_OSI_WINSRV_2003_SP1},\t \n\t{\"Windows 2006\", NULL, 0, ACPI_OSI_WIN_VISTA},\t \n\t{\"Windows 2006.1\", NULL, 0, ACPI_OSI_WINSRV_2008},\t \n\t{\"Windows 2006 SP1\", NULL, 0, ACPI_OSI_WIN_VISTA_SP1},\t \n\t{\"Windows 2006 SP2\", NULL, 0, ACPI_OSI_WIN_VISTA_SP2},\t \n\t{\"Windows 2009\", NULL, 0, ACPI_OSI_WIN_7},\t \n\t{\"Windows 2012\", NULL, 0, ACPI_OSI_WIN_8},\t \n\t{\"Windows 2013\", NULL, 0, ACPI_OSI_WIN_8_1},\t \n\t{\"Windows 2015\", NULL, 0, ACPI_OSI_WIN_10},\t \n\t{\"Windows 2016\", NULL, 0, ACPI_OSI_WIN_10_RS1},\t \n\t{\"Windows 2017\", NULL, 0, ACPI_OSI_WIN_10_RS2},\t \n\t{\"Windows 2017.2\", NULL, 0, ACPI_OSI_WIN_10_RS3},\t \n\t{\"Windows 2018\", NULL, 0, ACPI_OSI_WIN_10_RS4},\t \n\t{\"Windows 2018.2\", NULL, 0, ACPI_OSI_WIN_10_RS5},\t \n\t{\"Windows 2019\", NULL, 0, ACPI_OSI_WIN_10_19H1},\t \n\t{\"Windows 2020\", NULL, 0, ACPI_OSI_WIN_10_20H1},\t \n\t{\"Windows 2021\", NULL, 0, ACPI_OSI_WIN_11},\t \n\n\t \n\n\t{\"Extended Address Space Descriptor\", NULL, ACPI_OSI_FEATURE, 0},\n\n\t \n\n\t{\"Module Device\", NULL, ACPI_OSI_OPTIONAL_FEATURE, 0},\n\t{\"Processor Device\", NULL, ACPI_OSI_OPTIONAL_FEATURE, 0},\n\t{\"3.0 Thermal Model\", NULL, ACPI_OSI_OPTIONAL_FEATURE, 0},\n\t{\"3.0 _SCP Extensions\", NULL, ACPI_OSI_OPTIONAL_FEATURE, 0},\n\t{\"Processor Aggregator Device\", NULL, ACPI_OSI_OPTIONAL_FEATURE, 0}\n};\n\n \n\nacpi_status acpi_ut_initialize_interfaces(void)\n{\n\tacpi_status status;\n\tu32 i;\n\n\tstatus = acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tacpi_gbl_supported_interfaces = acpi_default_supported_interfaces;\n\n\t \n\n\tfor (i = 0;\n\t     i < (ACPI_ARRAY_LENGTH(acpi_default_supported_interfaces) - 1);\n\t     i++) {\n\t\tacpi_default_supported_interfaces[i].next =\n\t\t    &acpi_default_supported_interfaces[(acpi_size)i + 1];\n\t}\n\n\tacpi_os_release_mutex(acpi_gbl_osi_mutex);\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_ut_interface_terminate(void)\n{\n\tacpi_status status;\n\tstruct acpi_interface_info *next_interface;\n\n\tstatus = acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tnext_interface = acpi_gbl_supported_interfaces;\n\twhile (next_interface) {\n\t\tacpi_gbl_supported_interfaces = next_interface->next;\n\n\t\tif (next_interface->flags & ACPI_OSI_DYNAMIC) {\n\n\t\t\t \n\n\t\t\tACPI_FREE(next_interface->name);\n\t\t\tACPI_FREE(next_interface);\n\t\t} else {\n\t\t\t \n\n\t\t\tif (next_interface->flags & ACPI_OSI_DEFAULT_INVALID) {\n\t\t\t\tnext_interface->flags |= ACPI_OSI_INVALID;\n\t\t\t} else {\n\t\t\t\tnext_interface->flags &= ~ACPI_OSI_INVALID;\n\t\t\t}\n\t\t}\n\n\t\tnext_interface = acpi_gbl_supported_interfaces;\n\t}\n\n\tacpi_os_release_mutex(acpi_gbl_osi_mutex);\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_ut_install_interface(acpi_string interface_name)\n{\n\tstruct acpi_interface_info *interface_info;\n\n\t \n\n\tinterface_info =\n\t    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_interface_info));\n\tif (!interface_info) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\tinterface_info->name = ACPI_ALLOCATE_ZEROED(strlen(interface_name) + 1);\n\tif (!interface_info->name) {\n\t\tACPI_FREE(interface_info);\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\t \n\n\tstrcpy(interface_info->name, interface_name);\n\tinterface_info->flags = ACPI_OSI_DYNAMIC;\n\tinterface_info->next = acpi_gbl_supported_interfaces;\n\n\tacpi_gbl_supported_interfaces = interface_info;\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_ut_remove_interface(acpi_string interface_name)\n{\n\tstruct acpi_interface_info *previous_interface;\n\tstruct acpi_interface_info *next_interface;\n\n\tprevious_interface = next_interface = acpi_gbl_supported_interfaces;\n\twhile (next_interface) {\n\t\tif (!strcmp(interface_name, next_interface->name)) {\n\t\t\t \n\t\t\tif (next_interface->flags & ACPI_OSI_DYNAMIC) {\n\n\t\t\t\t \n\n\t\t\t\tif (previous_interface == next_interface) {\n\t\t\t\t\tacpi_gbl_supported_interfaces =\n\t\t\t\t\t    next_interface->next;\n\t\t\t\t} else {\n\t\t\t\t\tprevious_interface->next =\n\t\t\t\t\t    next_interface->next;\n\t\t\t\t}\n\n\t\t\t\tACPI_FREE(next_interface->name);\n\t\t\t\tACPI_FREE(next_interface);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (next_interface->flags & ACPI_OSI_INVALID) {\n\t\t\t\t\treturn (AE_NOT_EXIST);\n\t\t\t\t}\n\n\t\t\t\tnext_interface->flags |= ACPI_OSI_INVALID;\n\t\t\t}\n\n\t\t\treturn (AE_OK);\n\t\t}\n\n\t\tprevious_interface = next_interface;\n\t\tnext_interface = next_interface->next;\n\t}\n\n\t \n\n\treturn (AE_NOT_EXIST);\n}\n\n \n\nacpi_status acpi_ut_update_interfaces(u8 action)\n{\n\tstruct acpi_interface_info *next_interface;\n\n\tnext_interface = acpi_gbl_supported_interfaces;\n\twhile (next_interface) {\n\t\tif (((next_interface->flags & ACPI_OSI_FEATURE) &&\n\t\t     (action & ACPI_FEATURE_STRINGS)) ||\n\t\t    (!(next_interface->flags & ACPI_OSI_FEATURE) &&\n\t\t     (action & ACPI_VENDOR_STRINGS))) {\n\t\t\tif (action & ACPI_DISABLE_INTERFACES) {\n\n\t\t\t\t \n\n\t\t\t\tnext_interface->flags |= ACPI_OSI_INVALID;\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\tnext_interface->flags &= ~ACPI_OSI_INVALID;\n\t\t\t}\n\t\t}\n\n\t\tnext_interface = next_interface->next;\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nstruct acpi_interface_info *acpi_ut_get_interface(acpi_string interface_name)\n{\n\tstruct acpi_interface_info *next_interface;\n\n\tnext_interface = acpi_gbl_supported_interfaces;\n\twhile (next_interface) {\n\t\tif (!strcmp(interface_name, next_interface->name)) {\n\t\t\treturn (next_interface);\n\t\t}\n\n\t\tnext_interface = next_interface->next;\n\t}\n\n\treturn (NULL);\n}\n\n \n\nacpi_status acpi_ut_osi_implementation(struct acpi_walk_state *walk_state)\n{\n\tunion acpi_operand_object *string_desc;\n\tunion acpi_operand_object *return_desc;\n\tstruct acpi_interface_info *interface_info;\n\tacpi_interface_handler interface_handler;\n\tacpi_status status;\n\tu64 return_value;\n\n\tACPI_FUNCTION_TRACE(ut_osi_implementation);\n\n\t \n\n\tstring_desc = walk_state->arguments[0].object;\n\tif (!string_desc || (string_desc->common.type != ACPI_TYPE_STRING)) {\n\t\treturn_ACPI_STATUS(AE_TYPE);\n\t}\n\n\t \n\n\treturn_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);\n\tif (!return_desc) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\treturn_value = 0;\n\tstatus = acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ut_remove_reference(return_desc);\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tinterface_info = acpi_ut_get_interface(string_desc->string.pointer);\n\tif (interface_info && !(interface_info->flags & ACPI_OSI_INVALID)) {\n\t\t \n\t\tif (interface_info->value > acpi_gbl_osi_data) {\n\t\t\tacpi_gbl_osi_data = interface_info->value;\n\t\t}\n\n\t\treturn_value = ACPI_UINT64_MAX;\n\t}\n\n\tacpi_os_release_mutex(acpi_gbl_osi_mutex);\n\n\t \n\tinterface_handler = acpi_gbl_interface_handler;\n\tif (interface_handler) {\n\t\tif (interface_handler\n\t\t    (string_desc->string.pointer, (u32)return_value)) {\n\t\t\treturn_value = ACPI_UINT64_MAX;\n\t\t}\n\t}\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_INFO,\n\t\t\t      \"ACPI: BIOS _OSI(\\\"%s\\\") is %ssupported\\n\",\n\t\t\t      string_desc->string.pointer,\n\t\t\t      return_value == 0 ? \"not \" : \"\"));\n\n\t \n\n\treturn_desc->integer.value = return_value;\n\twalk_state->return_desc = return_desc;\n\treturn_ACPI_STATUS(AE_OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}