{
  "module_name": "utmisc.c",
  "hash_id": "79c2fde1a38a69b7f7afdebb570f7a7bfa430190065f027bb4f99c0b24bb6ed4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utmisc.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utmisc\")\n\n \nu8 acpi_ut_is_pci_root_bridge(char *id)\n{\n\n\t \n\tif (!(strcmp(id,\n\t\t     PCI_ROOT_HID_STRING)) ||\n\t    !(strcmp(id, PCI_EXPRESS_ROOT_HID_STRING))) {\n\t\treturn (TRUE);\n\t}\n\n\treturn (FALSE);\n}\n\n#if (defined ACPI_ASL_COMPILER || defined ACPI_EXEC_APP || defined ACPI_NAMES_APP)\n \n\nu8 acpi_ut_is_aml_table(struct acpi_table_header *table)\n{\n\n\t \n\n\tif (ACPI_COMPARE_NAMESEG(table->signature, ACPI_SIG_DSDT) ||\n\t    ACPI_COMPARE_NAMESEG(table->signature, ACPI_SIG_PSDT) ||\n\t    ACPI_COMPARE_NAMESEG(table->signature, ACPI_SIG_SSDT) ||\n\t    ACPI_COMPARE_NAMESEG(table->signature, ACPI_SIG_OSDT) ||\n\t    ACPI_IS_OEM_SIG(table->signature)) {\n\t\treturn (TRUE);\n\t}\n\n\treturn (FALSE);\n}\n#endif\n\n \n\nu32 acpi_ut_dword_byte_swap(u32 value)\n{\n\tunion {\n\t\tu32 value;\n\t\tu8 bytes[4];\n\t} out;\n\tunion {\n\t\tu32 value;\n\t\tu8 bytes[4];\n\t} in;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tin.value = value;\n\n\tout.bytes[0] = in.bytes[3];\n\tout.bytes[1] = in.bytes[2];\n\tout.bytes[2] = in.bytes[1];\n\tout.bytes[3] = in.bytes[0];\n\n\treturn (out.value);\n}\n\n \n\nvoid acpi_ut_set_integer_width(u8 revision)\n{\n\n\tif (revision < 2) {\n\n\t\t \n\n\t\tacpi_gbl_integer_bit_width = 32;\n\t\tacpi_gbl_integer_nybble_width = 8;\n\t\tacpi_gbl_integer_byte_width = 4;\n\t} else {\n\t\t \n\n\t\tacpi_gbl_integer_bit_width = 64;\n\t\tacpi_gbl_integer_nybble_width = 16;\n\t\tacpi_gbl_integer_byte_width = 8;\n\t}\n}\n\n \n\nacpi_status\nacpi_ut_create_update_state_and_push(union acpi_operand_object *object,\n\t\t\t\t     u16 action,\n\t\t\t\t     union acpi_generic_state **state_list)\n{\n\tunion acpi_generic_state *state;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tif (!object) {\n\t\treturn (AE_OK);\n\t}\n\n\tstate = acpi_ut_create_update_state(object, action);\n\tif (!state) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\tacpi_ut_push_generic_state(state_list, state);\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_ut_walk_package_tree(union acpi_operand_object *source_object,\n\t\t\t  void *target_object,\n\t\t\t  acpi_pkg_callback walk_callback, void *context)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_generic_state *state_list = NULL;\n\tunion acpi_generic_state *state;\n\tunion acpi_operand_object *this_source_obj;\n\tu32 this_index;\n\n\tACPI_FUNCTION_TRACE(ut_walk_package_tree);\n\n\tstate = acpi_ut_create_pkg_state(source_object, target_object, 0);\n\tif (!state) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\twhile (state) {\n\n\t\t \n\n\t\tthis_index = state->pkg.index;\n\t\tthis_source_obj =\n\t\t    state->pkg.source_object->package.elements[this_index];\n\t\tstate->pkg.this_target_obj =\n\t\t    &state->pkg.source_object->package.elements[this_index];\n\n\t\t \n\t\tif ((!this_source_obj) ||\n\t\t    (ACPI_GET_DESCRIPTOR_TYPE(this_source_obj) !=\n\t\t     ACPI_DESC_TYPE_OPERAND) ||\n\t\t    (this_source_obj->common.type != ACPI_TYPE_PACKAGE)) {\n\t\t\tstatus =\n\t\t\t    walk_callback(ACPI_COPY_TYPE_SIMPLE,\n\t\t\t\t\t  this_source_obj, state, context);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t}\n\n\t\t\tstate->pkg.index++;\n\t\t\twhile (state->pkg.index >=\n\t\t\t       state->pkg.source_object->package.count) {\n\t\t\t\t \n\t\t\t\tacpi_ut_delete_generic_state(state);\n\t\t\t\tstate = acpi_ut_pop_generic_state(&state_list);\n\n\t\t\t\t \n\n\t\t\t\tif (!state) {\n\t\t\t\t\t \n\t\t\t\t\treturn_ACPI_STATUS(AE_OK);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tstate->pkg.index++;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\n\t\t\tstatus =\n\t\t\t    walk_callback(ACPI_COPY_TYPE_PACKAGE,\n\t\t\t\t\t  this_source_obj, state, context);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t}\n\n\t\t\t \n\t\t\tacpi_ut_push_generic_state(&state_list, state);\n\t\t\tstate =\n\t\t\t    acpi_ut_create_pkg_state(this_source_obj,\n\t\t\t\t\t\t     state->pkg.this_target_obj,\n\t\t\t\t\t\t     0);\n\t\t\tif (!state) {\n\n\t\t\t\t \n\n\t\t\t\twhile (state_list) {\n\t\t\t\t\tstate =\n\t\t\t\t\t    acpi_ut_pop_generic_state\n\t\t\t\t\t    (&state_list);\n\t\t\t\t\tacpi_ut_delete_generic_state(state);\n\t\t\t\t}\n\t\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tACPI_ERROR((AE_INFO, \"State list did not terminate correctly\"));\n\n\treturn_ACPI_STATUS(AE_AML_INTERNAL);\n}\n\n#ifdef ACPI_DEBUG_OUTPUT\n \n\nvoid\nacpi_ut_display_init_pathname(u8 type,\n\t\t\t      struct acpi_namespace_node *obj_handle,\n\t\t\t      const char *path)\n{\n\tacpi_status status;\n\tstruct acpi_buffer buffer;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tif (!(acpi_dbg_level & ACPI_LV_INIT_NAMES)) {\n\t\treturn;\n\t}\n\n\t \n\n\tbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\tstatus = acpi_ns_handle_to_pathname(obj_handle, &buffer, TRUE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn;\n\t}\n\n\t \n\n\tswitch (type) {\n\tcase ACPI_TYPE_METHOD:\n\n\t\tacpi_os_printf(\"Executing  \");\n\t\tbreak;\n\n\tdefault:\n\n\t\tacpi_os_printf(\"Initializing \");\n\t\tbreak;\n\t}\n\n\t \n\n\tacpi_os_printf(\"%-12s %s\",\n\t\t       acpi_ut_get_type_name(type), (char *)buffer.pointer);\n\n\t \n\n\tif (path) {\n\t\tacpi_os_printf(\".%s\", path);\n\t}\n\tacpi_os_printf(\"\\n\");\n\n\tACPI_FREE(buffer.pointer);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}