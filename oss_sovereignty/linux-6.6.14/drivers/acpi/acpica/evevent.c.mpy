{
  "module_name": "evevent.c",
  "hash_id": "20220552cc50aa1239406c72625f83af79d774db7c1ba5a61408b60dee995332",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evevent.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evevent\")\n#if (!ACPI_REDUCED_HARDWARE)\t \n \nstatic acpi_status acpi_ev_fixed_event_initialize(void);\n\nstatic u32 acpi_ev_fixed_event_dispatch(u32 event);\n\n \n\nacpi_status acpi_ev_initialize_events(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ev_initialize_events);\n\n\t \n\n\tif (acpi_gbl_reduced_hardware) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\tstatus = acpi_ev_fixed_event_initialize();\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"Unable to initialize fixed events\"));\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_ev_gpe_initialize();\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"Unable to initialize general purpose events\"));\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ev_install_xrupt_handlers(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ev_install_xrupt_handlers);\n\n\t \n\n\tif (acpi_gbl_reduced_hardware) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tstatus = acpi_ev_install_sci_handler();\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"Unable to install System Control Interrupt handler\"));\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tstatus = acpi_ev_init_global_lock_handler();\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"Unable to initialize Global Lock handler\"));\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tacpi_gbl_events_initialized = TRUE;\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic acpi_status acpi_ev_fixed_event_initialize(void)\n{\n\tu32 i;\n\tacpi_status status;\n\n\t \n\tfor (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {\n\t\tacpi_gbl_fixed_event_handlers[i].handler = NULL;\n\t\tacpi_gbl_fixed_event_handlers[i].context = NULL;\n\n\t\t \n\n\t\tif (acpi_gbl_fixed_event_info[i].enable_register_id != 0xFF) {\n\t\t\tstatus =\n\t\t\t    acpi_write_bit_register(acpi_gbl_fixed_event_info\n\t\t\t\t\t\t    [i].enable_register_id,\n\t\t\t\t\t\t    ACPI_DISABLE_EVENT);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn (status);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nu32 acpi_ev_fixed_event_detect(void)\n{\n\tu32 int_status = ACPI_INTERRUPT_NOT_HANDLED;\n\tu32 fixed_status;\n\tu32 fixed_enable;\n\tu32 i;\n\tacpi_status status;\n\n\tACPI_FUNCTION_NAME(ev_fixed_event_detect);\n\n\t \n\tstatus = acpi_hw_register_read(ACPI_REGISTER_PM1_STATUS, &fixed_status);\n\tstatus |=\n\t    acpi_hw_register_read(ACPI_REGISTER_PM1_ENABLE, &fixed_enable);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (int_status);\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_INTERRUPTS,\n\t\t\t  \"Fixed Event Block: Enable %08X Status %08X\\n\",\n\t\t\t  fixed_enable, fixed_status));\n\n\t \n\tfor (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {\n\n\t\t \n\n\t\tif ((fixed_status & acpi_gbl_fixed_event_info[i].\n\t\t     status_bit_mask)\n\t\t    && (fixed_enable & acpi_gbl_fixed_event_info[i].\n\t\t\tenable_bit_mask)) {\n\t\t\t \n\t\t\tacpi_fixed_event_count[i]++;\n\t\t\tif (acpi_gbl_global_event_handler) {\n\t\t\t\tacpi_gbl_global_event_handler\n\t\t\t\t    (ACPI_EVENT_TYPE_FIXED, NULL, i,\n\t\t\t\t     acpi_gbl_global_event_handler_context);\n\t\t\t}\n\n\t\t\tint_status |= acpi_ev_fixed_event_dispatch(i);\n\t\t}\n\t}\n\n\treturn (int_status);\n}\n\n \n\nstatic u32 acpi_ev_fixed_event_dispatch(u32 event)\n{\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\t(void)acpi_write_bit_register(acpi_gbl_fixed_event_info[event].\n\t\t\t\t      status_register_id, ACPI_CLEAR_STATUS);\n\n\t \n\tif (!acpi_gbl_fixed_event_handlers[event].handler) {\n\t\t(void)acpi_write_bit_register(acpi_gbl_fixed_event_info[event].\n\t\t\t\t\t      enable_register_id,\n\t\t\t\t\t      ACPI_DISABLE_EVENT);\n\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"No installed handler for fixed event - %s (%u), disabling\",\n\t\t\t    acpi_ut_get_event_name(event), event));\n\n\t\treturn (ACPI_INTERRUPT_NOT_HANDLED);\n\t}\n\n\t \n\n\treturn ((acpi_gbl_fixed_event_handlers[event].\n\t\t handler) (acpi_gbl_fixed_event_handlers[event].context));\n}\n\n \n\nu32 acpi_any_fixed_event_status_set(void)\n{\n\tacpi_status status;\n\tu32 in_status;\n\tu32 in_enable;\n\tu32 i;\n\n\tstatus = acpi_hw_register_read(ACPI_REGISTER_PM1_ENABLE, &in_enable);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (FALSE);\n\t}\n\n\tstatus = acpi_hw_register_read(ACPI_REGISTER_PM1_STATUS, &in_status);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (FALSE);\n\t}\n\n\t \n\tfor (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {\n\n\t\t \n\n\t\tif ((in_status & acpi_gbl_fixed_event_info[i].status_bit_mask) &&\n\t\t    (in_enable & acpi_gbl_fixed_event_info[i].enable_bit_mask)) {\n\t\t\treturn (TRUE);\n\t\t}\n\t}\n\n\treturn (FALSE);\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}