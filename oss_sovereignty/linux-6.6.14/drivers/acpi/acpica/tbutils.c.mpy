{
  "module_name": "tbutils.c",
  "hash_id": "e40f97efc6fafc573a3ffdc536bf8bb115ea202be07e7a7fa465fb28700edad4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/tbutils.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"actables.h\"\n\n#define _COMPONENT          ACPI_TABLES\nACPI_MODULE_NAME(\"tbutils\")\n\n \nstatic acpi_physical_address\nacpi_tb_get_root_table_entry(u8 *table_entry, u32 table_entry_size);\n\n#if (!ACPI_REDUCED_HARDWARE)\n \n\nacpi_status acpi_tb_initialize_facs(void)\n{\n\tstruct acpi_table_facs *facs;\n\n\t \n\n\tif (acpi_gbl_reduced_hardware) {\n\t\tacpi_gbl_FACS = NULL;\n\t\treturn (AE_OK);\n\t} else if (acpi_gbl_FADT.Xfacs &&\n\t\t   (!acpi_gbl_FADT.facs\n\t\t    || !acpi_gbl_use32_bit_facs_addresses)) {\n\t\t(void)acpi_get_table_by_index(acpi_gbl_xfacs_index,\n\t\t\t\t\t      ACPI_CAST_INDIRECT_PTR(struct\n\t\t\t\t\t\t\t\t     acpi_table_header,\n\t\t\t\t\t\t\t\t     &facs));\n\t\tacpi_gbl_FACS = facs;\n\t} else if (acpi_gbl_FADT.facs) {\n\t\t(void)acpi_get_table_by_index(acpi_gbl_facs_index,\n\t\t\t\t\t      ACPI_CAST_INDIRECT_PTR(struct\n\t\t\t\t\t\t\t\t     acpi_table_header,\n\t\t\t\t\t\t\t\t     &facs));\n\t\tacpi_gbl_FACS = facs;\n\t}\n\n\t \n\n\treturn (AE_OK);\n}\n#endif\t\t\t\t \n\n \n\nvoid acpi_tb_check_dsdt_header(void)\n{\n\n\t \n\n\tif (acpi_gbl_original_dsdt_header.length != acpi_gbl_DSDT->length ||\n\t    acpi_gbl_original_dsdt_header.checksum != acpi_gbl_DSDT->checksum) {\n\t\tACPI_BIOS_ERROR((AE_INFO,\n\t\t\t\t \"The DSDT has been corrupted or replaced - \"\n\t\t\t\t \"old, new headers below\"));\n\n\t\tacpi_tb_print_table_header(0, &acpi_gbl_original_dsdt_header);\n\t\tacpi_tb_print_table_header(0, acpi_gbl_DSDT);\n\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Please send DMI info to linux-acpi@vger.kernel.org\\n\"\n\t\t\t    \"If system does not work as expected, please boot with acpi=copy_dsdt\"));\n\n\t\t \n\n\t\tacpi_gbl_original_dsdt_header.length = acpi_gbl_DSDT->length;\n\t\tacpi_gbl_original_dsdt_header.checksum =\n\t\t    acpi_gbl_DSDT->checksum;\n\t}\n}\n\n \n\nstruct acpi_table_header *acpi_tb_copy_dsdt(u32 table_index)\n{\n\tstruct acpi_table_header *new_table;\n\tstruct acpi_table_desc *table_desc;\n\n\ttable_desc = &acpi_gbl_root_table_list.tables[table_index];\n\n\tnew_table = ACPI_ALLOCATE(table_desc->length);\n\tif (!new_table) {\n\t\tACPI_ERROR((AE_INFO, \"Could not copy DSDT of length 0x%X\",\n\t\t\t    table_desc->length));\n\t\treturn (NULL);\n\t}\n\n\tmemcpy(new_table, table_desc->pointer, table_desc->length);\n\tacpi_tb_uninstall_table(table_desc);\n\n\tacpi_tb_init_table_descriptor(&acpi_gbl_root_table_list.\n\t\t\t\t      tables[acpi_gbl_dsdt_index],\n\t\t\t\t      ACPI_PTR_TO_PHYSADDR(new_table),\n\t\t\t\t      ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL,\n\t\t\t\t      new_table);\n\n\tACPI_INFO((\"Forced DSDT copy: length 0x%05X copied locally, original unmapped\", new_table->length));\n\n\treturn (new_table);\n}\n\n \n\nstatic acpi_physical_address\nacpi_tb_get_root_table_entry(u8 *table_entry, u32 table_entry_size)\n{\n\tu32 address32;\n\tu64 address64;\n\n\t \n\tif (table_entry_size == ACPI_RSDT_ENTRY_SIZE) {\n\t\t \n\t\tACPI_MOVE_32_TO_32(&address32, table_entry);\n\t\treturn address32;\n\t} else {\n\t\t \n\t\tACPI_MOVE_64_TO_64(&address64, table_entry);\n\n#if ACPI_MACHINE_WIDTH == 32\n\t\tif (address64 > ACPI_UINT32_MAX) {\n\n\t\t\t \n\n\t\t\tACPI_BIOS_WARNING((AE_INFO,\n\t\t\t\t\t   \"64-bit Physical Address in XSDT is too large (0x%8.8X%8.8X),\"\n\t\t\t\t\t   \" truncating\",\n\t\t\t\t\t   ACPI_FORMAT_UINT64(address64)));\n\t\t}\n#endif\n\t\treturn ((acpi_physical_address)(address64));\n\t}\n}\n\n \n\nacpi_status ACPI_INIT_FUNCTION\nacpi_tb_parse_root_table(acpi_physical_address rsdp_address)\n{\n\tstruct acpi_table_rsdp *rsdp;\n\tu32 table_entry_size;\n\tu32 i;\n\tu32 table_count;\n\tstruct acpi_table_header *table;\n\tacpi_physical_address address;\n\tu32 length;\n\tu8 *table_entry;\n\tacpi_status status;\n\tu32 table_index;\n\n\tACPI_FUNCTION_TRACE(tb_parse_root_table);\n\n\t \n\n\trsdp = acpi_os_map_memory(rsdp_address, sizeof(struct acpi_table_rsdp));\n\tif (!rsdp) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tacpi_tb_print_table_header(rsdp_address,\n\t\t\t\t   ACPI_CAST_PTR(struct acpi_table_header,\n\t\t\t\t\t\t rsdp));\n\n\t \n\n\tif ((rsdp->revision > 1) &&\n\t    rsdp->xsdt_physical_address && !acpi_gbl_do_not_use_xsdt) {\n\t\t \n\t\taddress = (acpi_physical_address)rsdp->xsdt_physical_address;\n\t\ttable_entry_size = ACPI_XSDT_ENTRY_SIZE;\n\t} else {\n\t\t \n\n\t\taddress = (acpi_physical_address)rsdp->rsdt_physical_address;\n\t\ttable_entry_size = ACPI_RSDT_ENTRY_SIZE;\n\t}\n\n\t \n\tacpi_os_unmap_memory(rsdp, sizeof(struct acpi_table_rsdp));\n\n\t \n\n\ttable = acpi_os_map_memory(address, sizeof(struct acpi_table_header));\n\tif (!table) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tacpi_tb_print_table_header(address, table);\n\n\t \n\tlength = table->length;\n\tacpi_os_unmap_memory(table, sizeof(struct acpi_table_header));\n\n\tif (length < (sizeof(struct acpi_table_header) + table_entry_size)) {\n\t\tACPI_BIOS_ERROR((AE_INFO,\n\t\t\t\t \"Invalid table length 0x%X in RSDT/XSDT\",\n\t\t\t\t length));\n\t\treturn_ACPI_STATUS(AE_INVALID_TABLE_LENGTH);\n\t}\n\n\ttable = acpi_os_map_memory(address, length);\n\tif (!table) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tstatus = acpi_ut_verify_checksum(table, length);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_unmap_memory(table, length);\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\ttable_count = (u32)((table->length - sizeof(struct acpi_table_header)) /\n\t\t\t    table_entry_size);\n\ttable_entry = ACPI_ADD_PTR(u8, table, sizeof(struct acpi_table_header));\n\n\t \n\n\tfor (i = 0; i < table_count; i++) {\n\n\t\t \n\n\t\taddress =\n\t\t    acpi_tb_get_root_table_entry(table_entry, table_entry_size);\n\n\t\t \n\n\t\tif (!address) {\n\t\t\tgoto next_table;\n\t\t}\n\n\t\tstatus = acpi_tb_install_standard_table(address,\n\t\t\t\t\t\t\tACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL,\n\t\t\t\t\t\t\tNULL, FALSE, TRUE,\n\t\t\t\t\t\t\t&table_index);\n\n\t\tif (ACPI_SUCCESS(status) &&\n\t\t    ACPI_COMPARE_NAMESEG(&acpi_gbl_root_table_list.\n\t\t\t\t\t tables[table_index].signature,\n\t\t\t\t\t ACPI_SIG_FADT)) {\n\t\t\tacpi_gbl_fadt_index = table_index;\n\t\t\tacpi_tb_parse_fadt();\n\t\t}\n\nnext_table:\n\n\t\ttable_entry += table_entry_size;\n\t}\n\n\tacpi_os_unmap_memory(table, length);\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_tb_get_table(struct acpi_table_desc *table_desc,\n\t\t  struct acpi_table_header **out_table)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_tb_get_table);\n\n\tif (table_desc->validation_count == 0) {\n\n\t\t \n\n\t\tstatus = acpi_tb_validate_table(table_desc);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t}\n\n\tif (table_desc->validation_count < ACPI_MAX_TABLE_VALIDATIONS) {\n\t\ttable_desc->validation_count++;\n\n\t\t \n\t\tif (table_desc->validation_count >= ACPI_MAX_TABLE_VALIDATIONS) {\n\t\t\tACPI_WARNING((AE_INFO,\n\t\t\t\t      \"Table %p, Validation count overflows\\n\",\n\t\t\t\t      table_desc));\n\t\t}\n\t}\n\n\t*out_table = table_desc->pointer;\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nvoid acpi_tb_put_table(struct acpi_table_desc *table_desc)\n{\n\n\tACPI_FUNCTION_TRACE(acpi_tb_put_table);\n\n\tif (table_desc->validation_count < ACPI_MAX_TABLE_VALIDATIONS) {\n\t\ttable_desc->validation_count--;\n\n\t\t \n\t\tif (table_desc->validation_count >= ACPI_MAX_TABLE_VALIDATIONS) {\n\t\t\tACPI_WARNING((AE_INFO,\n\t\t\t\t      \"Table %p, Validation count underflows\\n\",\n\t\t\t\t      table_desc));\n\t\t\treturn_VOID;\n\t\t}\n\t}\n\n\tif (table_desc->validation_count == 0) {\n\n\t\t \n\n\t\tacpi_tb_invalidate_table(table_desc);\n\t}\n\n\treturn_VOID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}