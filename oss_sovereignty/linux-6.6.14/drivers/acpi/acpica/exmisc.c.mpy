{
  "module_name": "exmisc.c",
  "hash_id": "03d3503aa0f8784a6ab12df109f6b136e474a39d87bab2d7d5656d9511120145",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/exmisc.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acinterp.h\"\n#include \"amlcode.h\"\n\n#define _COMPONENT          ACPI_EXECUTER\nACPI_MODULE_NAME(\"exmisc\")\n\n \nacpi_status\nacpi_ex_get_object_reference(union acpi_operand_object *obj_desc,\n\t\t\t     union acpi_operand_object **return_desc,\n\t\t\t     struct acpi_walk_state *walk_state)\n{\n\tunion acpi_operand_object *reference_obj;\n\tunion acpi_operand_object *referenced_obj;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_get_object_reference, obj_desc);\n\n\t*return_desc = NULL;\n\n\tswitch (ACPI_GET_DESCRIPTOR_TYPE(obj_desc)) {\n\tcase ACPI_DESC_TYPE_OPERAND:\n\n\t\tif (obj_desc->common.type != ACPI_TYPE_LOCAL_REFERENCE) {\n\t\t\treturn_ACPI_STATUS(AE_AML_OPERAND_TYPE);\n\t\t}\n\n\t\t \n\t\tswitch (obj_desc->reference.class) {\n\t\tcase ACPI_REFCLASS_LOCAL:\n\t\tcase ACPI_REFCLASS_ARG:\n\t\tcase ACPI_REFCLASS_DEBUG:\n\n\t\t\t \n\n\t\t\treferenced_obj = obj_desc->reference.object;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tACPI_ERROR((AE_INFO, \"Invalid Reference Class 0x%2.2X\",\n\t\t\t\t    obj_desc->reference.class));\n\t\t\treturn_ACPI_STATUS(AE_AML_OPERAND_TYPE);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_DESC_TYPE_NAMED:\n\t\t \n\t\treferenced_obj = obj_desc;\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"Invalid descriptor type 0x%X\",\n\t\t\t    ACPI_GET_DESCRIPTOR_TYPE(obj_desc)));\n\t\treturn_ACPI_STATUS(AE_TYPE);\n\t}\n\n\t \n\n\treference_obj =\n\t    acpi_ut_create_internal_object(ACPI_TYPE_LOCAL_REFERENCE);\n\tif (!reference_obj) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\treference_obj->reference.class = ACPI_REFCLASS_REFOF;\n\treference_obj->reference.object = referenced_obj;\n\t*return_desc = reference_obj;\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t  \"Object %p Type [%s], returning Reference %p\\n\",\n\t\t\t  obj_desc, acpi_ut_get_object_type_name(obj_desc),\n\t\t\t  *return_desc));\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nu64 acpi_ex_do_math_op(u16 opcode, u64 integer0, u64 integer1)\n{\n\n\tACPI_FUNCTION_ENTRY();\n\n\tswitch (opcode) {\n\tcase AML_ADD_OP:\t \n\n\t\treturn (integer0 + integer1);\n\n\tcase AML_BIT_AND_OP:\t \n\n\t\treturn (integer0 & integer1);\n\n\tcase AML_BIT_NAND_OP:\t \n\n\t\treturn (~(integer0 & integer1));\n\n\tcase AML_BIT_OR_OP:\t \n\n\t\treturn (integer0 | integer1);\n\n\tcase AML_BIT_NOR_OP:\t \n\n\t\treturn (~(integer0 | integer1));\n\n\tcase AML_BIT_XOR_OP:\t \n\n\t\treturn (integer0 ^ integer1);\n\n\tcase AML_MULTIPLY_OP:\t \n\n\t\treturn (integer0 * integer1);\n\n\tcase AML_SHIFT_LEFT_OP:\t \n\n\t\t \n\t\tif (integer1 >= acpi_gbl_integer_bit_width) {\n\t\t\treturn (0);\n\t\t}\n\t\treturn (integer0 << integer1);\n\n\tcase AML_SHIFT_RIGHT_OP:\t \n\n\t\t \n\t\tif (integer1 >= acpi_gbl_integer_bit_width) {\n\t\t\treturn (0);\n\t\t}\n\t\treturn (integer0 >> integer1);\n\n\tcase AML_SUBTRACT_OP:\t \n\n\t\treturn (integer0 - integer1);\n\n\tdefault:\n\n\t\treturn (0);\n\t}\n}\n\n \n\nacpi_status\nacpi_ex_do_logical_numeric_op(u16 opcode,\n\t\t\t      u64 integer0, u64 integer1, u8 *logical_result)\n{\n\tacpi_status status = AE_OK;\n\tu8 local_result = FALSE;\n\n\tACPI_FUNCTION_TRACE(ex_do_logical_numeric_op);\n\n\tswitch (opcode) {\n\tcase AML_LOGICAL_AND_OP:\t \n\n\t\tif (integer0 && integer1) {\n\t\t\tlocal_result = TRUE;\n\t\t}\n\t\tbreak;\n\n\tcase AML_LOGICAL_OR_OP:\t \n\n\t\tif (integer0 || integer1) {\n\t\t\tlocal_result = TRUE;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Invalid numeric logical opcode: %X\", opcode));\n\t\tstatus = AE_AML_INTERNAL;\n\t\tbreak;\n\t}\n\n\t \n\n\t*logical_result = local_result;\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ex_do_logical_op(u16 opcode,\n\t\t      union acpi_operand_object *operand0,\n\t\t      union acpi_operand_object *operand1, u8 * logical_result)\n{\n\tunion acpi_operand_object *local_operand1 = operand1;\n\tu64 integer0;\n\tu64 integer1;\n\tu32 length0;\n\tu32 length1;\n\tacpi_status status = AE_OK;\n\tu8 local_result = FALSE;\n\tint compare;\n\n\tACPI_FUNCTION_TRACE(ex_do_logical_op);\n\n\t \n\tswitch (operand0->common.type) {\n\tcase ACPI_TYPE_INTEGER:\n\n\t\tstatus = acpi_ex_convert_to_integer(operand1, &local_operand1,\n\t\t\t\t\t\t    ACPI_IMPLICIT_CONVERSION);\n\t\tbreak;\n\n\tcase ACPI_TYPE_STRING:\n\n\t\tstatus =\n\t\t    acpi_ex_convert_to_string(operand1, &local_operand1,\n\t\t\t\t\t      ACPI_IMPLICIT_CONVERT_HEX);\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\tstatus = acpi_ex_convert_to_buffer(operand1, &local_operand1);\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Invalid object type for logical operator: %X\",\n\t\t\t    operand0->common.type));\n\t\tstatus = AE_AML_INTERNAL;\n\t\tbreak;\n\t}\n\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (operand0->common.type == ACPI_TYPE_INTEGER) {\n\t\t \n\t\tinteger0 = operand0->integer.value;\n\t\tinteger1 = local_operand1->integer.value;\n\n\t\tswitch (opcode) {\n\t\tcase AML_LOGICAL_EQUAL_OP:\t \n\n\t\t\tif (integer0 == integer1) {\n\t\t\t\tlocal_result = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AML_LOGICAL_GREATER_OP:\t \n\n\t\t\tif (integer0 > integer1) {\n\t\t\t\tlocal_result = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AML_LOGICAL_LESS_OP:\t \n\n\t\t\tif (integer0 < integer1) {\n\t\t\t\tlocal_result = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Invalid comparison opcode: %X\", opcode));\n\t\t\tstatus = AE_AML_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tlength0 = operand0->buffer.length;\n\t\tlength1 = local_operand1->buffer.length;\n\n\t\t \n\n\t\tcompare = memcmp(operand0->buffer.pointer,\n\t\t\t\t local_operand1->buffer.pointer,\n\t\t\t\t (length0 > length1) ? length1 : length0);\n\n\t\tswitch (opcode) {\n\t\tcase AML_LOGICAL_EQUAL_OP:\t \n\n\t\t\t \n\n\t\t\tif ((length0 == length1) && (compare == 0)) {\n\n\t\t\t\t \n\n\t\t\t\tlocal_result = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AML_LOGICAL_GREATER_OP:\t \n\n\t\t\tif (compare > 0) {\n\t\t\t\tlocal_result = TRUE;\n\t\t\t\tgoto cleanup;\t \n\t\t\t}\n\t\t\tif (compare < 0) {\n\t\t\t\tgoto cleanup;\t \n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (length0 > length1) {\n\t\t\t\tlocal_result = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AML_LOGICAL_LESS_OP:\t \n\n\t\t\tif (compare > 0) {\n\t\t\t\tgoto cleanup;\t \n\t\t\t}\n\t\t\tif (compare < 0) {\n\t\t\t\tlocal_result = TRUE;\n\t\t\t\tgoto cleanup;\t \n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (length0 < length1) {\n\t\t\t\tlocal_result = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Invalid comparison opcode: %X\", opcode));\n\t\t\tstatus = AE_AML_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\ncleanup:\n\n\t \n\n\tif (local_operand1 != operand1) {\n\t\tacpi_ut_remove_reference(local_operand1);\n\t}\n\n\t \n\n\t*logical_result = local_result;\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}