{
  "module_name": "psscope.c",
  "hash_id": "a42ed680e6647fe4468f57d38eb3026779521648b08cd2f832ef6009084f1c0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/psscope.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acparser.h\"\n\n#define _COMPONENT          ACPI_PARSER\nACPI_MODULE_NAME(\"psscope\")\n\n \nunion acpi_parse_object *acpi_ps_get_parent_scope(struct acpi_parse_state\n\t\t\t\t\t\t  *parser_state)\n{\n\n\treturn (parser_state->scope->parse_scope.op);\n}\n\n \n\nu8 acpi_ps_has_completed_scope(struct acpi_parse_state * parser_state)\n{\n\n\treturn ((u8)\n\t\t((parser_state->aml >= parser_state->scope->parse_scope.arg_end\n\t\t  || !parser_state->scope->parse_scope.arg_count)));\n}\n\n \n\nacpi_status\nacpi_ps_init_scope(struct acpi_parse_state * parser_state,\n\t\t   union acpi_parse_object * root_op)\n{\n\tunion acpi_generic_state *scope;\n\n\tACPI_FUNCTION_TRACE_PTR(ps_init_scope, root_op);\n\n\tscope = acpi_ut_create_generic_state();\n\tif (!scope) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tscope->common.descriptor_type = ACPI_DESC_TYPE_STATE_RPSCOPE;\n\tscope->parse_scope.op = root_op;\n\tscope->parse_scope.arg_count = ACPI_VAR_ARGS;\n\tscope->parse_scope.arg_end = parser_state->aml_end;\n\tscope->parse_scope.pkg_end = parser_state->aml_end;\n\n\tparser_state->scope = scope;\n\tparser_state->start_op = root_op;\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ps_push_scope(struct acpi_parse_state *parser_state,\n\t\t   union acpi_parse_object *op,\n\t\t   u32 remaining_args, u32 arg_count)\n{\n\tunion acpi_generic_state *scope;\n\n\tACPI_FUNCTION_TRACE_PTR(ps_push_scope, op);\n\n\tscope = acpi_ut_create_generic_state();\n\tif (!scope) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tscope->common.descriptor_type = ACPI_DESC_TYPE_STATE_PSCOPE;\n\tscope->parse_scope.op = op;\n\tscope->parse_scope.arg_list = remaining_args;\n\tscope->parse_scope.arg_count = arg_count;\n\tscope->parse_scope.pkg_end = parser_state->pkg_end;\n\n\t \n\n\tacpi_ut_push_generic_state(&parser_state->scope, scope);\n\n\tif (arg_count == ACPI_VAR_ARGS) {\n\n\t\t \n\n\t\tscope->parse_scope.arg_end = parser_state->pkg_end;\n\t} else {\n\t\t \n\n\t\tscope->parse_scope.arg_end = ACPI_TO_POINTER(ACPI_MAX_PTR);\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nvoid\nacpi_ps_pop_scope(struct acpi_parse_state *parser_state,\n\t\t  union acpi_parse_object **op, u32 * arg_list, u32 * arg_count)\n{\n\tunion acpi_generic_state *scope = parser_state->scope;\n\n\tACPI_FUNCTION_TRACE(ps_pop_scope);\n\n\t \n\n\tif (scope->common.next) {\n\t\tscope = acpi_ut_pop_generic_state(&parser_state->scope);\n\n\t\t \n\n\t\t*op = scope->parse_scope.op;\n\t\t*arg_list = scope->parse_scope.arg_list;\n\t\t*arg_count = scope->parse_scope.arg_count;\n\t\tparser_state->pkg_end = scope->parse_scope.pkg_end;\n\n\t\t \n\n\t\tacpi_ut_delete_generic_state(scope);\n\t} else {\n\t\t \n\n\t\t*op = NULL;\n\t\t*arg_list = 0;\n\t\t*arg_count = 0;\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t  \"Popped Op %p Args %X\\n\", *op, *arg_count));\n\treturn_VOID;\n}\n\n \n\nvoid acpi_ps_cleanup_scope(struct acpi_parse_state *parser_state)\n{\n\tunion acpi_generic_state *scope;\n\n\tACPI_FUNCTION_TRACE_PTR(ps_cleanup_scope, parser_state);\n\n\tif (!parser_state) {\n\t\treturn_VOID;\n\t}\n\n\t \n\n\twhile (parser_state->scope) {\n\t\tscope = acpi_ut_pop_generic_state(&parser_state->scope);\n\t\tacpi_ut_delete_generic_state(scope);\n\t}\n\n\treturn_VOID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}