{
  "module_name": "hwxface.c",
  "hash_id": "944284687f9f799d00571519d8f5ec7b59681e2eef4ac1f22765cade2eace9d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/hwxface.c",
  "human_readable_source": "\n \n\n#define EXPORT_ACPI_INTERFACES\n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_HARDWARE\nACPI_MODULE_NAME(\"hwxface\")\n\n \nacpi_status acpi_reset(void)\n{\n\tstruct acpi_generic_address *reset_reg;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_reset);\n\n\treset_reg = &acpi_gbl_FADT.reset_register;\n\n\t \n\n\tif (!(acpi_gbl_FADT.flags & ACPI_FADT_RESET_REGISTER) ||\n\t    !reset_reg->address) {\n\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t}\n\n\tif (reset_reg->space_id == ACPI_ADR_SPACE_SYSTEM_IO) {\n\t\t \n\t\tstatus = acpi_os_write_port((acpi_io_address)reset_reg->address,\n\t\t\t\t\t    acpi_gbl_FADT.reset_value,\n\t\t\t\t\t    ACPI_RESET_REGISTER_WIDTH);\n\t} else {\n\t\t \n\n\t\tstatus = acpi_hw_write(acpi_gbl_FADT.reset_value, reset_reg);\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_reset)\n\n \nacpi_status acpi_read(u64 *return_value, struct acpi_generic_address *reg)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_NAME(acpi_read);\n\n\tstatus = acpi_hw_read(return_value, reg);\n\treturn (status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_read)\n\n \nacpi_status acpi_write(u64 value, struct acpi_generic_address *reg)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_NAME(acpi_write);\n\n\tstatus = acpi_hw_write(value, reg);\n\treturn (status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_write)\n\n#if (!ACPI_REDUCED_HARDWARE)\n \nacpi_status acpi_read_bit_register(u32 register_id, u32 *return_value)\n{\n\tstruct acpi_bit_register_info *bit_reg_info;\n\tu32 register_value;\n\tu32 value;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE_U32(acpi_read_bit_register, register_id);\n\n\t \n\n\tbit_reg_info = acpi_hw_get_bit_register_info(register_id);\n\tif (!bit_reg_info) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tstatus = acpi_hw_register_read(bit_reg_info->parent_register,\n\t\t\t\t       &register_value);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tvalue = ((register_value & bit_reg_info->access_bit_mask)\n\t\t >> bit_reg_info->bit_position);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_IO,\n\t\t\t  \"BitReg %X, ParentReg %X, Actual %8.8X, ReturnValue %8.8X\\n\",\n\t\t\t  register_id, bit_reg_info->parent_register,\n\t\t\t  register_value, value));\n\n\t*return_value = value;\n\treturn_ACPI_STATUS(AE_OK);\n}\n\nACPI_EXPORT_SYMBOL(acpi_read_bit_register)\n\n \nacpi_status acpi_write_bit_register(u32 register_id, u32 value)\n{\n\tstruct acpi_bit_register_info *bit_reg_info;\n\tacpi_cpu_flags lock_flags;\n\tu32 register_value;\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE_U32(acpi_write_bit_register, register_id);\n\n\t \n\n\tbit_reg_info = acpi_hw_get_bit_register_info(register_id);\n\tif (!bit_reg_info) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tlock_flags = acpi_os_acquire_raw_lock(acpi_gbl_hardware_lock);\n\n\t \n\tif (bit_reg_info->parent_register != ACPI_REGISTER_PM1_STATUS) {\n\t\t \n\t\tstatus = acpi_hw_register_read(bit_reg_info->parent_register,\n\t\t\t\t\t       &register_value);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto unlock_and_exit;\n\t\t}\n\n\t\t \n\t\tACPI_REGISTER_INSERT_VALUE(register_value,\n\t\t\t\t\t   bit_reg_info->bit_position,\n\t\t\t\t\t   bit_reg_info->access_bit_mask,\n\t\t\t\t\t   value);\n\n\t\tstatus = acpi_hw_register_write(bit_reg_info->parent_register,\n\t\t\t\t\t\tregister_value);\n\t} else {\n\t\t \n\t\tregister_value = ACPI_REGISTER_PREPARE_BITS(value,\n\t\t\t\t\t\t\t    bit_reg_info->\n\t\t\t\t\t\t\t    bit_position,\n\t\t\t\t\t\t\t    bit_reg_info->\n\t\t\t\t\t\t\t    access_bit_mask);\n\n\t\t \n\n\t\tif (register_value) {\n\t\t\tstatus =\n\t\t\t    acpi_hw_register_write(ACPI_REGISTER_PM1_STATUS,\n\t\t\t\t\t\t   register_value);\n\t\t}\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_IO,\n\t\t\t  \"BitReg %X, ParentReg %X, Value %8.8X, Actual %8.8X\\n\",\n\t\t\t  register_id, bit_reg_info->parent_register, value,\n\t\t\t  register_value));\n\nunlock_and_exit:\n\n\tacpi_os_release_raw_lock(acpi_gbl_hardware_lock, lock_flags);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_write_bit_register)\n#endif\t\t\t\t \n \nacpi_status\nacpi_get_sleep_type_data(u8 sleep_state, u8 *sleep_type_a, u8 *sleep_type_b)\n{\n\tacpi_status status;\n\tstruct acpi_evaluate_info *info;\n\tunion acpi_operand_object **elements;\n\n\tACPI_FUNCTION_TRACE(acpi_get_sleep_type_data);\n\n\t \n\n\tif ((sleep_state > ACPI_S_STATES_MAX) || !sleep_type_a || !sleep_type_b) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tinfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\n\tif (!info) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\tinfo->relative_pathname = acpi_gbl_sleep_state_names[sleep_state];\n\n\tstatus = acpi_ns_evaluate(info);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status == AE_NOT_FOUND) {\n\n\t\t\t \n\n\t\t\tgoto final_cleanup;\n\t\t}\n\n\t\tgoto warning_cleanup;\n\t}\n\n\t \n\n\tif (!info->return_object) {\n\t\tACPI_ERROR((AE_INFO, \"No Sleep State object returned from [%s]\",\n\t\t\t    info->relative_pathname));\n\t\tstatus = AE_AML_NO_RETURN_VALUE;\n\t\tgoto warning_cleanup;\n\t}\n\n\t \n\n\tif (info->return_object->common.type != ACPI_TYPE_PACKAGE) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Sleep State return object is not a Package\"));\n\t\tstatus = AE_AML_OPERAND_TYPE;\n\t\tgoto return_value_cleanup;\n\t}\n\n\t \n\telements = info->return_object->package.elements;\n\tswitch (info->return_object->package.count) {\n\tcase 0:\n\n\t\tstatus = AE_AML_PACKAGE_LIMIT;\n\t\tbreak;\n\n\tcase 1:\n\n\t\tif (elements[0]->common.type != ACPI_TYPE_INTEGER) {\n\t\t\tstatus = AE_AML_OPERAND_TYPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\t*sleep_type_a = (u8)elements[0]->integer.value;\n\t\t*sleep_type_b = (u8)(elements[0]->integer.value >> 8);\n\t\tbreak;\n\n\tcase 2:\n\tdefault:\n\n\t\tif ((elements[0]->common.type != ACPI_TYPE_INTEGER) ||\n\t\t    (elements[1]->common.type != ACPI_TYPE_INTEGER)) {\n\t\t\tstatus = AE_AML_OPERAND_TYPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\t*sleep_type_a = (u8)elements[0]->integer.value;\n\t\t*sleep_type_b = (u8)elements[1]->integer.value;\n\t\tbreak;\n\t}\n\nreturn_value_cleanup:\n\tacpi_ut_remove_reference(info->return_object);\n\nwarning_cleanup:\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"While evaluating Sleep State [%s]\",\n\t\t\t\tinfo->relative_pathname));\n\t}\n\nfinal_cleanup:\n\tACPI_FREE(info);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_sleep_type_data)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}