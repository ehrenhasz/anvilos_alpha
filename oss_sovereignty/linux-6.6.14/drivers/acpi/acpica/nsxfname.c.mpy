{
  "module_name": "nsxfname.c",
  "hash_id": "6a0f5e4d2c8b877546203f05bcc56b60d46d71836a3dc2a6dac625f344d8a0fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/nsxfname.c",
  "human_readable_source": "\n \n\n#define EXPORT_ACPI_INTERFACES\n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"acparser.h\"\n#include \"amlcode.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\nACPI_MODULE_NAME(\"nsxfname\")\n\n \nstatic char *acpi_ns_copy_device_id(struct acpi_pnp_device_id *dest,\n\t\t\t\t    struct acpi_pnp_device_id *source,\n\t\t\t\t    char *string_area);\n\n \n\nacpi_status\nacpi_get_handle(acpi_handle parent,\n\t\tconst char *pathname, acpi_handle *ret_handle)\n{\n\tacpi_status status;\n\tstruct acpi_namespace_node *node = NULL;\n\tstruct acpi_namespace_node *prefix_node = NULL;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tif (!ret_handle || !pathname) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tif (parent) {\n\t\tprefix_node = acpi_ns_validate_handle(parent);\n\t\tif (!prefix_node) {\n\t\t\treturn (AE_BAD_PARAMETER);\n\t\t}\n\t}\n\n\t \n\tif (ACPI_IS_ROOT_PREFIX(pathname[0])) {\n\n\t\t \n\n\t\t \n\n\t\tif (!strcmp(pathname, ACPI_NS_ROOT_PATH)) {\n\t\t\t*ret_handle =\n\t\t\t    ACPI_CAST_PTR(acpi_handle, acpi_gbl_root_node);\n\t\t\treturn (AE_OK);\n\t\t}\n\t} else if (!prefix_node) {\n\n\t\t \n\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tstatus =\n\t    acpi_ns_get_node(prefix_node, pathname, ACPI_NS_NO_UPSEARCH, &node);\n\tif (ACPI_SUCCESS(status)) {\n\t\t*ret_handle = ACPI_CAST_PTR(acpi_handle, node);\n\t}\n\n\treturn (status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_handle)\n\n \nacpi_status\nacpi_get_name(acpi_handle handle, u32 name_type, struct acpi_buffer *buffer)\n{\n\tacpi_status status;\n\n\t \n\n\tif (name_type > ACPI_NAME_TYPE_MAX) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_validate_buffer(buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tif (name_type == ACPI_FULL_PATHNAME ||\n\t    name_type == ACPI_FULL_PATHNAME_NO_TRAILING) {\n\n\t\t \n\n\t\tstatus = acpi_ns_handle_to_pathname(handle, buffer,\n\t\t\t\t\t\t    name_type ==\n\t\t\t\t\t\t    ACPI_FULL_PATHNAME ? FALSE :\n\t\t\t\t\t\t    TRUE);\n\t} else {\n\t\t \n\n\t\tstatus = acpi_ns_handle_to_name(handle, buffer);\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn (status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_name)\n\n \nstatic char *acpi_ns_copy_device_id(struct acpi_pnp_device_id *dest,\n\t\t\t\t    struct acpi_pnp_device_id *source,\n\t\t\t\t    char *string_area)\n{\n\t \n\n\tdest->string = string_area;\n\tdest->length = source->length;\n\n\t \n\n\tmemcpy(string_area, source->string, source->length);\n\treturn (string_area + source->length);\n}\n\n \n\nacpi_status\nacpi_get_object_info(acpi_handle handle,\n\t\t     struct acpi_device_info **return_buffer)\n{\n\tstruct acpi_namespace_node *node;\n\tstruct acpi_device_info *info;\n\tstruct acpi_pnp_device_id_list *cid_list = NULL;\n\tstruct acpi_pnp_device_id *hid = NULL;\n\tstruct acpi_pnp_device_id *uid = NULL;\n\tstruct acpi_pnp_device_id *cls = NULL;\n\tchar *next_id_string;\n\tacpi_object_type type;\n\tacpi_name name;\n\tu8 param_count = 0;\n\tu16 valid = 0;\n\tu32 info_size;\n\tu32 i;\n\tacpi_status status;\n\n\t \n\n\tif (!handle || !return_buffer) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tnode = acpi_ns_validate_handle(handle);\n\tif (!node) {\n\t\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tinfo_size = sizeof(struct acpi_device_info);\n\ttype = node->type;\n\tname = node->name.integer;\n\n\tif (node->type == ACPI_TYPE_METHOD) {\n\t\tparam_count = node->object->method.param_count;\n\t}\n\n\tstatus = acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tif ((type == ACPI_TYPE_DEVICE) || (type == ACPI_TYPE_PROCESSOR)) {\n\t\t \n\n\t\t \n\n\t\tstatus = acpi_ut_execute_HID(node, &hid);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tinfo_size += hid->length;\n\t\t\tvalid |= ACPI_VALID_HID;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ut_execute_UID(node, &uid);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tinfo_size += uid->length;\n\t\t\tvalid |= ACPI_VALID_UID;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ut_execute_CID(node, &cid_list);\n\t\tif (ACPI_SUCCESS(status)) {\n\n\t\t\t \n\n\t\t\tinfo_size +=\n\t\t\t    (cid_list->list_size -\n\t\t\t     sizeof(struct acpi_pnp_device_id_list));\n\t\t\tvalid |= ACPI_VALID_CID;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ut_execute_CLS(node, &cls);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tinfo_size += cls->length;\n\t\t\tvalid |= ACPI_VALID_CLS;\n\t\t}\n\t}\n\n\t \n\tinfo = ACPI_ALLOCATE_ZEROED(info_size);\n\tif (!info) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tif ((type == ACPI_TYPE_DEVICE) || (type == ACPI_TYPE_PROCESSOR)) {\n\t\t \n\n\t\t \n\n\t\tstatus = acpi_ut_evaluate_numeric_object(METHOD_NAME__ADR, node,\n\t\t\t\t\t\t\t &info->address);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tvalid |= ACPI_VALID_ADR;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ut_execute_power_methods(node,\n\t\t\t\t\t\t       acpi_gbl_lowest_dstate_names,\n\t\t\t\t\t\t       ACPI_NUM_sx_w_METHODS,\n\t\t\t\t\t\t       info->lowest_dstates);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tvalid |= ACPI_VALID_SXWS;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ut_execute_power_methods(node,\n\t\t\t\t\t\t       acpi_gbl_highest_dstate_names,\n\t\t\t\t\t\t       ACPI_NUM_sx_d_METHODS,\n\t\t\t\t\t\t       info->highest_dstates);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tvalid |= ACPI_VALID_SXDS;\n\t\t}\n\t}\n\n\t \n\tnext_id_string = ACPI_CAST_PTR(char, info->compatible_id_list.ids);\n\tif (cid_list) {\n\n\t\t \n\n\t\tnext_id_string +=\n\t\t    ((acpi_size)cid_list->count *\n\t\t     sizeof(struct acpi_pnp_device_id));\n\t}\n\n\t \n\tif (hid) {\n\t\tnext_id_string = acpi_ns_copy_device_id(&info->hardware_id,\n\t\t\t\t\t\t\thid, next_id_string);\n\n\t\tif (acpi_ut_is_pci_root_bridge(hid->string)) {\n\t\t\tinfo->flags |= ACPI_PCI_ROOT_BRIDGE;\n\t\t}\n\t}\n\n\tif (uid) {\n\t\tnext_id_string = acpi_ns_copy_device_id(&info->unique_id,\n\t\t\t\t\t\t\tuid, next_id_string);\n\t}\n\n\tif (cid_list) {\n\t\tinfo->compatible_id_list.count = cid_list->count;\n\t\tinfo->compatible_id_list.list_size = cid_list->list_size;\n\n\t\t \n\n\t\tfor (i = 0; i < cid_list->count; i++) {\n\t\t\tnext_id_string =\n\t\t\t    acpi_ns_copy_device_id(&info->compatible_id_list.\n\t\t\t\t\t\t   ids[i], &cid_list->ids[i],\n\t\t\t\t\t\t   next_id_string);\n\n\t\t\tif (acpi_ut_is_pci_root_bridge(cid_list->ids[i].string)) {\n\t\t\t\tinfo->flags |= ACPI_PCI_ROOT_BRIDGE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cls) {\n\t\t(void)acpi_ns_copy_device_id(&info->class_code,\n\t\t\t\t\t     cls, next_id_string);\n\t}\n\n\t \n\n\tinfo->info_size = info_size;\n\tinfo->type = type;\n\tinfo->name = name;\n\tinfo->param_count = param_count;\n\tinfo->valid = valid;\n\n\t*return_buffer = info;\n\tstatus = AE_OK;\n\ncleanup:\n\tif (hid) {\n\t\tACPI_FREE(hid);\n\t}\n\tif (uid) {\n\t\tACPI_FREE(uid);\n\t}\n\tif (cid_list) {\n\t\tACPI_FREE(cid_list);\n\t}\n\tif (cls) {\n\t\tACPI_FREE(cls);\n\t}\n\treturn (status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_object_info)\n\n \nacpi_status acpi_install_method(u8 *buffer)\n{\n\tstruct acpi_table_header *table =\n\t    ACPI_CAST_PTR(struct acpi_table_header, buffer);\n\tu8 *aml_buffer;\n\tu8 *aml_start;\n\tchar *path;\n\tstruct acpi_namespace_node *node;\n\tunion acpi_operand_object *method_obj;\n\tstruct acpi_parse_state parser_state;\n\tu32 aml_length;\n\tu16 opcode;\n\tu8 method_flags;\n\tacpi_status status;\n\n\t \n\n\tif (!buffer) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tif (!ACPI_COMPARE_NAMESEG(table->signature, ACPI_SIG_DSDT) &&\n\t    !ACPI_COMPARE_NAMESEG(table->signature, ACPI_SIG_SSDT)) {\n\t\treturn (AE_BAD_HEADER);\n\t}\n\n\t \n\n\tparser_state.aml = buffer + sizeof(struct acpi_table_header);\n\topcode = acpi_ps_peek_opcode(&parser_state);\n\tif (opcode != AML_METHOD_OP) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tparser_state.aml += acpi_ps_get_opcode_size(opcode);\n\tparser_state.pkg_end = acpi_ps_get_next_package_end(&parser_state);\n\tpath = acpi_ps_get_next_namestring(&parser_state);\n\n\tmethod_flags = *parser_state.aml++;\n\taml_start = parser_state.aml;\n\taml_length = (u32)ACPI_PTR_DIFF(parser_state.pkg_end, aml_start);\n\n\t \n\taml_buffer = ACPI_ALLOCATE(aml_length);\n\tif (!aml_buffer) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\tmethod_obj = acpi_ut_create_internal_object(ACPI_TYPE_METHOD);\n\tif (!method_obj) {\n\t\tACPI_FREE(aml_buffer);\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\t \n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto error_exit;\n\t}\n\n\t \n\n\tstatus =\n\t    acpi_ns_lookup(NULL, path, ACPI_TYPE_METHOD, ACPI_IMODE_LOAD_PASS1,\n\t\t\t   ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND,\n\t\t\t   NULL, &node);\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\n\tif (ACPI_FAILURE(status)) {\t \n\t\tif (status != AE_ALREADY_EXISTS) {\n\t\t\tgoto error_exit;\n\t\t}\n\n\t\t \n\n\t\tif (node->type != ACPI_TYPE_METHOD) {\n\t\t\tstatus = AE_TYPE;\n\t\t\tgoto error_exit;\n\t\t}\n\t}\n\n\t \n\n\tmemcpy(aml_buffer, aml_start, aml_length);\n\n\t \n\n\tmethod_obj->method.aml_start = aml_buffer;\n\tmethod_obj->method.aml_length = aml_length;\n\n\tmethod_obj->method.param_count = (u8)\n\t    (method_flags & AML_METHOD_ARG_COUNT);\n\n\tif (method_flags & AML_METHOD_SERIALIZED) {\n\t\tmethod_obj->method.info_flags = ACPI_METHOD_SERIALIZED;\n\n\t\tmethod_obj->method.sync_level = (u8)\n\t\t    ((method_flags & AML_METHOD_SYNC_LEVEL) >> 4);\n\t}\n\n\t \n\tstatus = acpi_ns_attach_object(node, method_obj, ACPI_TYPE_METHOD);\n\n\t \n\tnode->flags |= ANOBJ_ALLOCATED_BUFFER;\n\n\t \n\n\tacpi_ut_remove_reference(method_obj);\n\treturn (status);\n\nerror_exit:\n\n\tACPI_FREE(aml_buffer);\n\tACPI_FREE(method_obj);\n\treturn (status);\n}\nACPI_EXPORT_SYMBOL(acpi_install_method)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}