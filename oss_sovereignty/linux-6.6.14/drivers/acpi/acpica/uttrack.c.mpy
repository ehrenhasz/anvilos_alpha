{
  "module_name": "uttrack.c",
  "hash_id": "c91908d068365eaaaff909de068c041c56efe7a17e27aad511a55bfed4b45b12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/uttrack.c",
  "human_readable_source": "\n \n\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n\n#ifdef ACPI_DBG_TRACK_ALLOCATIONS\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"uttrack\")\n\n \nstatic struct acpi_debug_mem_block *acpi_ut_find_allocation(struct\n\t\t\t\t\t\t\t    acpi_debug_mem_block\n\t\t\t\t\t\t\t    *allocation);\n\nstatic acpi_status\nacpi_ut_track_allocation(struct acpi_debug_mem_block *address,\n\t\t\t acpi_size size,\n\t\t\t u8 alloc_type,\n\t\t\t u32 component, const char *module, u32 line);\n\nstatic acpi_status\nacpi_ut_remove_allocation(struct acpi_debug_mem_block *address,\n\t\t\t  u32 component, const char *module, u32 line);\n\n \n\nacpi_status\nacpi_ut_create_list(const char *list_name,\n\t\t    u16 object_size, struct acpi_memory_list **return_cache)\n{\n\tstruct acpi_memory_list *cache;\n\n\tcache = acpi_os_allocate_zeroed(sizeof(struct acpi_memory_list));\n\tif (!cache) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\tcache->list_name = list_name;\n\tcache->object_size = object_size;\n\n\t*return_cache = cache;\n\treturn (AE_OK);\n}\n\n \n\nvoid *acpi_ut_allocate_and_track(acpi_size size,\n\t\t\t\t u32 component, const char *module, u32 line)\n{\n\tstruct acpi_debug_mem_block *allocation;\n\tacpi_status status;\n\n\t \n\n\tif (!size) {\n\t\tACPI_WARNING((module, line,\n\t\t\t      \"Attempt to allocate zero bytes, allocating 1 byte\"));\n\t\tsize = 1;\n\t}\n\n\tallocation =\n\t    acpi_os_allocate(size + sizeof(struct acpi_debug_mem_header));\n\tif (!allocation) {\n\n\t\t \n\n\t\tACPI_WARNING((module, line,\n\t\t\t      \"Could not allocate size %u\", (u32)size));\n\n\t\treturn (NULL);\n\t}\n\n\tstatus =\n\t    acpi_ut_track_allocation(allocation, size, ACPI_MEM_MALLOC,\n\t\t\t\t     component, module, line);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_free(allocation);\n\t\treturn (NULL);\n\t}\n\n\tacpi_gbl_global_list->total_allocated++;\n\tacpi_gbl_global_list->total_size += (u32)size;\n\tacpi_gbl_global_list->current_total_size += (u32)size;\n\n\tif (acpi_gbl_global_list->current_total_size >\n\t    acpi_gbl_global_list->max_occupied) {\n\t\tacpi_gbl_global_list->max_occupied =\n\t\t    acpi_gbl_global_list->current_total_size;\n\t}\n\n\treturn ((void *)&allocation->user_space);\n}\n\n \n\nvoid *acpi_ut_allocate_zeroed_and_track(acpi_size size,\n\t\t\t\t\tu32 component,\n\t\t\t\t\tconst char *module, u32 line)\n{\n\tstruct acpi_debug_mem_block *allocation;\n\tacpi_status status;\n\n\t \n\n\tif (!size) {\n\t\tACPI_WARNING((module, line,\n\t\t\t      \"Attempt to allocate zero bytes, allocating 1 byte\"));\n\t\tsize = 1;\n\t}\n\n\tallocation =\n\t    acpi_os_allocate_zeroed(size +\n\t\t\t\t    sizeof(struct acpi_debug_mem_header));\n\tif (!allocation) {\n\n\t\t \n\n\t\tACPI_ERROR((module, line,\n\t\t\t    \"Could not allocate size %u\", (u32)size));\n\t\treturn (NULL);\n\t}\n\n\tstatus = acpi_ut_track_allocation(allocation, size,\n\t\t\t\t\t  ACPI_MEM_CALLOC, component, module,\n\t\t\t\t\t  line);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_os_free(allocation);\n\t\treturn (NULL);\n\t}\n\n\tacpi_gbl_global_list->total_allocated++;\n\tacpi_gbl_global_list->total_size += (u32)size;\n\tacpi_gbl_global_list->current_total_size += (u32)size;\n\n\tif (acpi_gbl_global_list->current_total_size >\n\t    acpi_gbl_global_list->max_occupied) {\n\t\tacpi_gbl_global_list->max_occupied =\n\t\t    acpi_gbl_global_list->current_total_size;\n\t}\n\n\treturn ((void *)&allocation->user_space);\n}\n\n \n\nvoid\nacpi_ut_free_and_track(void *allocation,\n\t\t       u32 component, const char *module, u32 line)\n{\n\tstruct acpi_debug_mem_block *debug_block;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE_PTR(ut_free, allocation);\n\n\tif (NULL == allocation) {\n\t\tACPI_ERROR((module, line, \"Attempt to delete a NULL address\"));\n\n\t\treturn_VOID;\n\t}\n\n\tdebug_block = ACPI_CAST_PTR(struct acpi_debug_mem_block,\n\t\t\t\t    (((char *)allocation) -\n\t\t\t\t     sizeof(struct acpi_debug_mem_header)));\n\n\tacpi_gbl_global_list->total_freed++;\n\tacpi_gbl_global_list->current_total_size -= debug_block->size;\n\n\tstatus =\n\t    acpi_ut_remove_allocation(debug_block, component, module, line);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status, \"Could not free memory\"));\n\t}\n\n\tacpi_os_free(debug_block);\n\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, \"%p freed (block %p)\\n\",\n\t\t\t  allocation, debug_block));\n\treturn_VOID;\n}\n\n \n\nstatic struct acpi_debug_mem_block *acpi_ut_find_allocation(struct\n\t\t\t\t\t\t\t    acpi_debug_mem_block\n\t\t\t\t\t\t\t    *allocation)\n{\n\tstruct acpi_debug_mem_block *element;\n\n\telement = acpi_gbl_global_list->list_head;\n\tif (!element) {\n\t\treturn (NULL);\n\t}\n\n\t \n\twhile (element > allocation) {\n\n\t\t \n\n\t\tif (!element->next) {\n\t\t\treturn (element);\n\t\t}\n\n\t\telement = element->next;\n\t}\n\n\tif (element == allocation) {\n\t\treturn (element);\n\t}\n\n\treturn (element->previous);\n}\n\n \n\nstatic acpi_status\nacpi_ut_track_allocation(struct acpi_debug_mem_block *allocation,\n\t\t\t acpi_size size,\n\t\t\t u8 alloc_type,\n\t\t\t u32 component, const char *module, u32 line)\n{\n\tstruct acpi_memory_list *mem_list;\n\tstruct acpi_debug_mem_block *element;\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE_PTR(ut_track_allocation, allocation);\n\n\tif (acpi_gbl_disable_mem_tracking) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\tmem_list = acpi_gbl_global_list;\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_MEMORY);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\telement = acpi_ut_find_allocation(allocation);\n\tif (element == allocation) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"UtTrackAllocation: Allocation (%p) already present in global list!\",\n\t\t\t    allocation));\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tallocation->size = (u32)size;\n\tallocation->alloc_type = alloc_type;\n\tallocation->component = component;\n\tallocation->line = line;\n\n\tacpi_ut_safe_strncpy(allocation->module, (char *)module,\n\t\t\t     ACPI_MAX_MODULE_NAME);\n\n\tif (!element) {\n\n\t\t \n\n\t\tif (mem_list->list_head) {\n\t\t\t((struct acpi_debug_mem_block *)(mem_list->list_head))->\n\t\t\t    previous = allocation;\n\t\t}\n\n\t\tallocation->next = mem_list->list_head;\n\t\tallocation->previous = NULL;\n\n\t\tmem_list->list_head = allocation;\n\t} else {\n\t\t \n\n\t\tallocation->next = element->next;\n\t\tallocation->previous = element;\n\n\t\tif (element->next) {\n\t\t\t(element->next)->previous = allocation;\n\t\t}\n\n\t\telement->next = allocation;\n\t}\n\nunlock_and_exit:\n\tstatus = acpi_ut_release_mutex(ACPI_MTX_MEMORY);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic acpi_status\nacpi_ut_remove_allocation(struct acpi_debug_mem_block *allocation,\n\t\t\t  u32 component, const char *module, u32 line)\n{\n\tstruct acpi_memory_list *mem_list;\n\tacpi_status status;\n\n\tACPI_FUNCTION_NAME(ut_remove_allocation);\n\n\tif (acpi_gbl_disable_mem_tracking) {\n\t\treturn (AE_OK);\n\t}\n\n\tmem_list = acpi_gbl_global_list;\n\tif (NULL == mem_list->list_head) {\n\n\t\t \n\n\t\tACPI_ERROR((module, line,\n\t\t\t    \"Empty allocation list, nothing to free!\"));\n\n\t\treturn (AE_OK);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_MEMORY);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\tif (allocation->previous) {\n\t\t(allocation->previous)->next = allocation->next;\n\t} else {\n\t\tmem_list->list_head = allocation->next;\n\t}\n\n\tif (allocation->next) {\n\t\t(allocation->next)->previous = allocation->previous;\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, \"Freeing %p, size 0%X\\n\",\n\t\t\t  &allocation->user_space, allocation->size));\n\n\t \n\n\tmemset(&allocation->user_space, 0xEA, allocation->size);\n\n\tstatus = acpi_ut_release_mutex(ACPI_MTX_MEMORY);\n\treturn (status);\n}\n\n \n\nvoid acpi_ut_dump_allocation_info(void)\n{\n \n\n\tACPI_FUNCTION_TRACE(ut_dump_allocation_info);\n\n \n\treturn_VOID;\n}\n\n \n\nvoid acpi_ut_dump_allocations(u32 component, const char *module)\n{\n\tstruct acpi_debug_mem_block *element;\n\tunion acpi_descriptor *descriptor;\n\tu32 num_outstanding = 0;\n\tu8 descriptor_type;\n\n\tACPI_FUNCTION_TRACE(ut_dump_allocations);\n\n\tif (acpi_gbl_disable_mem_tracking) {\n\t\treturn_VOID;\n\t}\n\n\t \n\tif (ACPI_FAILURE(acpi_ut_acquire_mutex(ACPI_MTX_MEMORY))) {\n\t\treturn_VOID;\n\t}\n\n\tif (!acpi_gbl_global_list) {\n\t\tgoto exit;\n\t}\n\n\telement = acpi_gbl_global_list->list_head;\n\twhile (element) {\n\t\tif ((element->component & component) &&\n\t\t    ((module == NULL)\n\t\t     || (0 == strcmp(module, element->module)))) {\n\t\t\tdescriptor =\n\t\t\t    ACPI_CAST_PTR(union acpi_descriptor,\n\t\t\t\t\t  &element->user_space);\n\n\t\t\tif (element->size <\n\t\t\t    sizeof(struct acpi_common_descriptor)) {\n\t\t\t\tacpi_os_printf(\"%p Length 0x%04X %9.9s-%4.4u \"\n\t\t\t\t\t       \"[Not a Descriptor - too small]\\n\",\n\t\t\t\t\t       descriptor, element->size,\n\t\t\t\t\t       element->module, element->line);\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\tif (ACPI_GET_DESCRIPTOR_TYPE(descriptor) !=\n\t\t\t\t    ACPI_DESC_TYPE_CACHED) {\n\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t    (\"%p Length 0x%04X %9.9s-%4.4u [%s] \",\n\t\t\t\t\t     descriptor, element->size,\n\t\t\t\t\t     element->module, element->line,\n\t\t\t\t\t     acpi_ut_get_descriptor_name\n\t\t\t\t\t     (descriptor));\n\n\t\t\t\t\t \n\n\t\t\t\t\tif (acpi_gbl_verbose_leak_dump) {\n\t\t\t\t\t\tacpi_os_printf(\"\\n\");\n\t\t\t\t\t\tacpi_ut_dump_buffer((u8 *)\n\t\t\t\t\t\t\t\t    descriptor,\n\t\t\t\t\t\t\t\t    element->\n\t\t\t\t\t\t\t\t    size,\n\t\t\t\t\t\t\t\t    DB_BYTE_DISPLAY,\n\t\t\t\t\t\t\t\t    0);\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\n\t\t\t\t\tdescriptor_type = 0;\t \n\n\t\t\t\t\tswitch (ACPI_GET_DESCRIPTOR_TYPE\n\t\t\t\t\t\t(descriptor)) {\n\t\t\t\t\tcase ACPI_DESC_TYPE_OPERAND:\n\n\t\t\t\t\t\tif (element->size ==\n\t\t\t\t\t\t    sizeof(union\n\t\t\t\t\t\t\t   acpi_operand_object))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdescriptor_type =\n\t\t\t\t\t\t\t    ACPI_DESC_TYPE_OPERAND;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ACPI_DESC_TYPE_PARSER:\n\n\t\t\t\t\t\tif (element->size ==\n\t\t\t\t\t\t    sizeof(union\n\t\t\t\t\t\t\t   acpi_parse_object)) {\n\t\t\t\t\t\t\tdescriptor_type =\n\t\t\t\t\t\t\t    ACPI_DESC_TYPE_PARSER;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ACPI_DESC_TYPE_NAMED:\n\n\t\t\t\t\t\tif (element->size ==\n\t\t\t\t\t\t    sizeof(struct\n\t\t\t\t\t\t\t   acpi_namespace_node))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdescriptor_type =\n\t\t\t\t\t\t\t    ACPI_DESC_TYPE_NAMED;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\n\t\t\t\t\tswitch (descriptor_type) {\n\t\t\t\t\tcase ACPI_DESC_TYPE_OPERAND:\n\n\t\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t\t    (\"%12.12s RefCount 0x%04X\\n\",\n\t\t\t\t\t\t     acpi_ut_get_type_name\n\t\t\t\t\t\t     (descriptor->object.common.\n\t\t\t\t\t\t      type),\n\t\t\t\t\t\t     descriptor->object.common.\n\t\t\t\t\t\t     reference_count);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ACPI_DESC_TYPE_PARSER:\n\n\t\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t\t    (\"AmlOpcode 0x%04X\\n\",\n\t\t\t\t\t\t     descriptor->op.asl.\n\t\t\t\t\t\t     aml_opcode);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ACPI_DESC_TYPE_NAMED:\n\n\t\t\t\t\t\tacpi_os_printf(\"%4.4s\\n\",\n\t\t\t\t\t\t\t       acpi_ut_get_node_name\n\t\t\t\t\t\t\t       (&descriptor->\n\t\t\t\t\t\t\t\tnode));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tacpi_os_printf(\"\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnum_outstanding++;\n\t\t}\n\n\t\telement = element->next;\n\t}\n\nexit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_MEMORY);\n\n\t \n\n\tif (!num_outstanding) {\n\t\tACPI_INFO((\"No outstanding allocations\"));\n\t} else {\n\t\tACPI_ERROR((AE_INFO, \"%u (0x%X) Outstanding cache allocations\",\n\t\t\t    num_outstanding, num_outstanding));\n\t}\n\n\treturn_VOID;\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}