{
  "module_name": "nsrepair2.c",
  "hash_id": "fb0ed3e682e66629112e1d0bef31b95f88eb34869cfbb1456f81c9272d410f71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/nsrepair2.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\nACPI_MODULE_NAME(\"nsrepair2\")\n\n \ntypedef\nacpi_status (*acpi_repair_function) (struct acpi_evaluate_info * info,\n\t\t\t\t     union acpi_operand_object **\n\t\t\t\t     return_object_ptr);\n\ntypedef struct acpi_repair_info {\n\tchar name[ACPI_NAMESEG_SIZE];\n\tacpi_repair_function repair_function;\n\n} acpi_repair_info;\n\n \n\nstatic const struct acpi_repair_info *acpi_ns_match_complex_repair(struct\n\t\t\t\t\t\t\t\t   acpi_namespace_node\n\t\t\t\t\t\t\t\t   *node);\n\nstatic acpi_status\nacpi_ns_repair_ALR(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr);\n\nstatic acpi_status\nacpi_ns_repair_CID(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr);\n\nstatic acpi_status\nacpi_ns_repair_CST(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr);\n\nstatic acpi_status\nacpi_ns_repair_FDE(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr);\n\nstatic acpi_status\nacpi_ns_repair_HID(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr);\n\nstatic acpi_status\nacpi_ns_repair_PRT(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr);\n\nstatic acpi_status\nacpi_ns_repair_PSS(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr);\n\nstatic acpi_status\nacpi_ns_repair_TSS(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr);\n\nstatic acpi_status\nacpi_ns_check_sorted_list(struct acpi_evaluate_info *info,\n\t\t\t  union acpi_operand_object *return_object,\n\t\t\t  u32 start_index,\n\t\t\t  u32 expected_count,\n\t\t\t  u32 sort_index,\n\t\t\t  u8 sort_direction, char *sort_key_name);\n\n \n\n#define ACPI_SORT_ASCENDING     0\n#define ACPI_SORT_DESCENDING    1\n\nstatic void\nacpi_ns_remove_element(union acpi_operand_object *obj_desc, u32 index);\n\nstatic void\nacpi_ns_sort_list(union acpi_operand_object **elements,\n\t\t  u32 count, u32 index, u8 sort_direction);\n\n \nstatic const struct acpi_repair_info acpi_ns_repairable_names[] = {\n\t{\"_ALR\", acpi_ns_repair_ALR},\n\t{\"_CID\", acpi_ns_repair_CID},\n\t{\"_CST\", acpi_ns_repair_CST},\n\t{\"_FDE\", acpi_ns_repair_FDE},\n\t{\"_GTM\", acpi_ns_repair_FDE},\t \n\t{\"_HID\", acpi_ns_repair_HID},\n\t{\"_PRT\", acpi_ns_repair_PRT},\n\t{\"_PSS\", acpi_ns_repair_PSS},\n\t{\"_TSS\", acpi_ns_repair_TSS},\n\t{{0, 0, 0, 0}, NULL}\t \n};\n\n#define ACPI_FDE_FIELD_COUNT        5\n#define ACPI_FDE_BYTE_BUFFER_SIZE   5\n#define ACPI_FDE_DWORD_BUFFER_SIZE  (ACPI_FDE_FIELD_COUNT * (u32) sizeof (u32))\n\n \n\nacpi_status\nacpi_ns_complex_repairs(struct acpi_evaluate_info *info,\n\t\t\tstruct acpi_namespace_node *node,\n\t\t\tacpi_status validate_status,\n\t\t\tunion acpi_operand_object **return_object_ptr)\n{\n\tconst struct acpi_repair_info *predefined;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ns_complex_repairs);\n\n\t \n\n\tpredefined = acpi_ns_match_complex_repair(node);\n\tif (!predefined) {\n\t\treturn_ACPI_STATUS(validate_status);\n\t}\n\n\tstatus = predefined->repair_function(info, return_object_ptr);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic const struct acpi_repair_info *acpi_ns_match_complex_repair(struct\n\t\t\t\t\t\t\t\t   acpi_namespace_node\n\t\t\t\t\t\t\t\t   *node)\n{\n\tconst struct acpi_repair_info *this_name;\n\n\t \n\n\tthis_name = acpi_ns_repairable_names;\n\twhile (this_name->repair_function) {\n\t\tif (ACPI_COMPARE_NAMESEG(node->name.ascii, this_name->name)) {\n\t\t\treturn (this_name);\n\t\t}\n\n\t\tthis_name++;\n\t}\n\n\treturn (NULL);\t\t \n}\n\n \n\nstatic acpi_status\nacpi_ns_repair_ALR(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr)\n{\n\tunion acpi_operand_object *return_object = *return_object_ptr;\n\tacpi_status status;\n\n\tstatus = acpi_ns_check_sorted_list(info, return_object, 0, 2, 1,\n\t\t\t\t\t   ACPI_SORT_ASCENDING,\n\t\t\t\t\t   \"AmbientIlluminance\");\n\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nacpi_ns_repair_FDE(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr)\n{\n\tunion acpi_operand_object *return_object = *return_object_ptr;\n\tunion acpi_operand_object *buffer_object;\n\tu8 *byte_buffer;\n\tu32 *dword_buffer;\n\tu32 i;\n\n\tACPI_FUNCTION_NAME(ns_repair_FDE);\n\n\tswitch (return_object->common.type) {\n\tcase ACPI_TYPE_BUFFER:\n\n\t\t \n\n\t\tif (return_object->buffer.length >= ACPI_FDE_DWORD_BUFFER_SIZE) {\n\t\t\treturn (AE_OK);\n\t\t}\n\n\t\t \n\n\t\tif (return_object->buffer.length != ACPI_FDE_BYTE_BUFFER_SIZE) {\n\t\t\tACPI_WARN_PREDEFINED((AE_INFO,\n\t\t\t\t\t      info->full_pathname,\n\t\t\t\t\t      info->node_flags,\n\t\t\t\t\t      \"Incorrect return buffer length %u, expected %u\",\n\t\t\t\t\t      return_object->buffer.length,\n\t\t\t\t\t      ACPI_FDE_DWORD_BUFFER_SIZE));\n\n\t\t\treturn (AE_AML_OPERAND_TYPE);\n\t\t}\n\n\t\t \n\n\t\tbuffer_object =\n\t\t    acpi_ut_create_buffer_object(ACPI_FDE_DWORD_BUFFER_SIZE);\n\t\tif (!buffer_object) {\n\t\t\treturn (AE_NO_MEMORY);\n\t\t}\n\n\t\t \n\n\t\tbyte_buffer = return_object->buffer.pointer;\n\t\tdword_buffer = ACPI_CAST_PTR(u32,\n\t\t\t\t\t     buffer_object->buffer.pointer);\n\n\t\tfor (i = 0; i < ACPI_FDE_FIELD_COUNT; i++) {\n\t\t\t*dword_buffer = (u32) *byte_buffer;\n\t\t\tdword_buffer++;\n\t\t\tbyte_buffer++;\n\t\t}\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_REPAIR,\n\t\t\t\t  \"%s Expanded Byte Buffer to expected DWord Buffer\\n\",\n\t\t\t\t  info->full_pathname));\n\t\tbreak;\n\n\tdefault:\n\n\t\treturn (AE_AML_OPERAND_TYPE);\n\t}\n\n\t \n\n\tacpi_ut_remove_reference(return_object);\n\t*return_object_ptr = buffer_object;\n\n\tinfo->return_flags |= ACPI_OBJECT_REPAIRED;\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_ns_repair_CID(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr)\n{\n\tacpi_status status;\n\tunion acpi_operand_object *return_object = *return_object_ptr;\n\tunion acpi_operand_object **element_ptr;\n\tunion acpi_operand_object *original_element;\n\tu16 original_ref_count;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ns_repair_CID);\n\n\t \n\n\tif (return_object->common.type == ACPI_TYPE_STRING) {\n\t\tstatus = acpi_ns_repair_HID(info, return_object_ptr);\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tif (return_object->common.type != ACPI_TYPE_PACKAGE) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\telement_ptr = return_object->package.elements;\n\tfor (i = 0; i < return_object->package.count; i++) {\n\t\toriginal_element = *element_ptr;\n\t\toriginal_ref_count = original_element->common.reference_count;\n\n\t\tstatus = acpi_ns_repair_HID(info, element_ptr);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\tif (original_element != *element_ptr) {\n\n\t\t\t \n\n\t\t\t(*element_ptr)->common.reference_count =\n\t\t\t    original_ref_count;\n\t\t}\n\n\t\telement_ptr++;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_ns_repair_CST(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr)\n{\n\tunion acpi_operand_object *return_object = *return_object_ptr;\n\tunion acpi_operand_object **outer_elements;\n\tu32 outer_element_count;\n\tunion acpi_operand_object *obj_desc;\n\tacpi_status status;\n\tu8 removing;\n\tu32 i;\n\n\tACPI_FUNCTION_NAME(ns_repair_CST);\n\n\t \n\touter_element_count = return_object->package.count - 1;\n\ti = 0;\n\twhile (i < outer_element_count) {\n\t\touter_elements = &return_object->package.elements[i + 1];\n\t\tremoving = FALSE;\n\n\t\tif ((*outer_elements)->package.count == 0) {\n\t\t\tACPI_WARN_PREDEFINED((AE_INFO,\n\t\t\t\t\t      info->full_pathname,\n\t\t\t\t\t      info->node_flags,\n\t\t\t\t\t      \"SubPackage[%u] - removing entry due to zero count\",\n\t\t\t\t\t      i));\n\t\t\tremoving = TRUE;\n\t\t\tgoto remove_element;\n\t\t}\n\n\t\tobj_desc = (*outer_elements)->package.elements[1];\t \n\t\tif ((u32)obj_desc->integer.value == 0) {\n\t\t\tACPI_WARN_PREDEFINED((AE_INFO,\n\t\t\t\t\t      info->full_pathname,\n\t\t\t\t\t      info->node_flags,\n\t\t\t\t\t      \"SubPackage[%u] - removing entry due to invalid Type(0)\",\n\t\t\t\t\t      i));\n\t\t\tremoving = TRUE;\n\t\t}\n\nremove_element:\n\t\tif (removing) {\n\t\t\tacpi_ns_remove_element(return_object, i + 1);\n\t\t\touter_element_count--;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\n\t \n\n\tobj_desc = return_object->package.elements[0];\n\tobj_desc->integer.value = outer_element_count;\n\n\t \n\tstatus = acpi_ns_check_sorted_list(info, return_object, 1, 4, 1,\n\t\t\t\t\t   ACPI_SORT_ASCENDING, \"C-State Type\");\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_ns_repair_HID(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr)\n{\n\tunion acpi_operand_object *return_object = *return_object_ptr;\n\tunion acpi_operand_object *new_string;\n\tchar *source;\n\tchar *dest;\n\n\tACPI_FUNCTION_TRACE(ns_repair_HID);\n\n\t \n\n\tif (return_object->common.type != ACPI_TYPE_STRING) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\tif (return_object->string.length == 0) {\n\t\tACPI_WARN_PREDEFINED((AE_INFO,\n\t\t\t\t      info->full_pathname, info->node_flags,\n\t\t\t\t      \"Invalid zero-length _HID or _CID string\"));\n\n\t\t \n\n\t\tinfo->return_flags |= ACPI_OBJECT_REPAIRED;\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tnew_string = acpi_ut_create_string_object(return_object->string.length);\n\tif (!new_string) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\tsource = return_object->string.pointer;\n\tif (*source == '*') {\n\t\tsource++;\n\t\tnew_string->string.length--;\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_REPAIR,\n\t\t\t\t  \"%s: Removed invalid leading asterisk\\n\",\n\t\t\t\t  info->full_pathname));\n\t}\n\n\t \n\tfor (dest = new_string->string.pointer; *source; dest++, source++) {\n\t\t*dest = (char)toupper((int)*source);\n\t}\n\n\tacpi_ut_remove_reference(return_object);\n\t*return_object_ptr = new_string;\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_ns_repair_PRT(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr)\n{\n\tunion acpi_operand_object *package_object = *return_object_ptr;\n\tunion acpi_operand_object **top_object_list;\n\tunion acpi_operand_object **sub_object_list;\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_operand_object *sub_package;\n\tu32 element_count;\n\tu32 index;\n\n\t \n\n\ttop_object_list = package_object->package.elements;\n\telement_count = package_object->package.count;\n\n\t \n\n\tfor (index = 0; index < element_count; index++, top_object_list++) {\n\t\tsub_package = *top_object_list;\n\t\tsub_object_list = sub_package->package.elements;\n\n\t\t \n\n\t\tif (sub_package->package.count < 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tobj_desc = sub_object_list[3];\n\t\tif (!obj_desc || (obj_desc->common.type != ACPI_TYPE_INTEGER)) {\n\t\t\tsub_object_list[3] = sub_object_list[2];\n\t\t\tsub_object_list[2] = obj_desc;\n\t\t\tinfo->return_flags |= ACPI_OBJECT_REPAIRED;\n\n\t\t\tACPI_WARN_PREDEFINED((AE_INFO,\n\t\t\t\t\t      info->full_pathname,\n\t\t\t\t\t      info->node_flags,\n\t\t\t\t\t      \"PRT[%X]: Fixed reversed SourceName and SourceIndex\",\n\t\t\t\t\t      index));\n\t\t}\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_ns_repair_PSS(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr)\n{\n\tunion acpi_operand_object *return_object = *return_object_ptr;\n\tunion acpi_operand_object **outer_elements;\n\tu32 outer_element_count;\n\tunion acpi_operand_object **elements;\n\tunion acpi_operand_object *obj_desc;\n\tu32 previous_value;\n\tacpi_status status;\n\tu32 i;\n\n\t \n\tstatus = acpi_ns_check_sorted_list(info, return_object, 0, 6, 0,\n\t\t\t\t\t   ACPI_SORT_DESCENDING,\n\t\t\t\t\t   \"CpuFrequency\");\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\tprevious_value = ACPI_UINT32_MAX;\n\touter_elements = return_object->package.elements;\n\touter_element_count = return_object->package.count;\n\n\tfor (i = 0; i < outer_element_count; i++) {\n\t\telements = (*outer_elements)->package.elements;\n\t\tobj_desc = elements[1];\t \n\n\t\tif ((u32)obj_desc->integer.value > previous_value) {\n\t\t\tACPI_WARN_PREDEFINED((AE_INFO,\n\t\t\t\t\t      info->full_pathname,\n\t\t\t\t\t      info->node_flags,\n\t\t\t\t\t      \"SubPackage[%u,%u] - suspicious power dissipation values\",\n\t\t\t\t\t      i - 1, i));\n\t\t}\n\n\t\tprevious_value = (u32) obj_desc->integer.value;\n\t\touter_elements++;\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_ns_repair_TSS(struct acpi_evaluate_info *info,\n\t\t   union acpi_operand_object **return_object_ptr)\n{\n\tunion acpi_operand_object *return_object = *return_object_ptr;\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\n\t \n\tstatus = acpi_ns_get_node(info->node, \"^_PSS\",\n\t\t\t\t  ACPI_NS_NO_UPSEARCH, &node);\n\tif (ACPI_SUCCESS(status)) {\n\t\treturn (AE_OK);\n\t}\n\n\tstatus = acpi_ns_check_sorted_list(info, return_object, 0, 5, 1,\n\t\t\t\t\t   ACPI_SORT_DESCENDING,\n\t\t\t\t\t   \"PowerDissipation\");\n\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nacpi_ns_check_sorted_list(struct acpi_evaluate_info *info,\n\t\t\t  union acpi_operand_object *return_object,\n\t\t\t  u32 start_index,\n\t\t\t  u32 expected_count,\n\t\t\t  u32 sort_index,\n\t\t\t  u8 sort_direction, char *sort_key_name)\n{\n\tu32 outer_element_count;\n\tunion acpi_operand_object **outer_elements;\n\tunion acpi_operand_object **elements;\n\tunion acpi_operand_object *obj_desc;\n\tu32 i;\n\tu32 previous_value;\n\n\tACPI_FUNCTION_NAME(ns_check_sorted_list);\n\n\t \n\n\tif (return_object->common.type != ACPI_TYPE_PACKAGE) {\n\t\treturn (AE_AML_OPERAND_TYPE);\n\t}\n\n\t \n\touter_element_count = return_object->package.count;\n\tif (!outer_element_count || start_index >= outer_element_count) {\n\t\treturn (AE_AML_PACKAGE_LIMIT);\n\t}\n\n\touter_elements = &return_object->package.elements[start_index];\n\touter_element_count -= start_index;\n\n\tprevious_value = 0;\n\tif (sort_direction == ACPI_SORT_DESCENDING) {\n\t\tprevious_value = ACPI_UINT32_MAX;\n\t}\n\n\t \n\n\tfor (i = 0; i < outer_element_count; i++) {\n\n\t\t \n\n\t\tif ((*outer_elements)->common.type != ACPI_TYPE_PACKAGE) {\n\t\t\treturn (AE_AML_OPERAND_TYPE);\n\t\t}\n\n\t\t \n\n\t\tif ((*outer_elements)->package.count < expected_count) {\n\t\t\treturn (AE_AML_PACKAGE_LIMIT);\n\t\t}\n\n\t\telements = (*outer_elements)->package.elements;\n\t\tobj_desc = elements[sort_index];\n\n\t\tif (obj_desc->common.type != ACPI_TYPE_INTEGER) {\n\t\t\treturn (AE_AML_OPERAND_TYPE);\n\t\t}\n\n\t\t \n\t\tif (((sort_direction == ACPI_SORT_ASCENDING) &&\n\t\t     (obj_desc->integer.value < previous_value)) ||\n\t\t    ((sort_direction == ACPI_SORT_DESCENDING) &&\n\t\t     (obj_desc->integer.value > previous_value))) {\n\t\t\tacpi_ns_sort_list(&return_object->package.\n\t\t\t\t\t  elements[start_index],\n\t\t\t\t\t  outer_element_count, sort_index,\n\t\t\t\t\t  sort_direction);\n\n\t\t\tinfo->return_flags |= ACPI_OBJECT_REPAIRED;\n\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_REPAIR,\n\t\t\t\t\t  \"%s: Repaired unsorted list - now sorted by %s\\n\",\n\t\t\t\t\t  info->full_pathname, sort_key_name));\n\t\t\treturn (AE_OK);\n\t\t}\n\n\t\tprevious_value = (u32) obj_desc->integer.value;\n\t\touter_elements++;\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nstatic void\nacpi_ns_sort_list(union acpi_operand_object **elements,\n\t\t  u32 count, u32 index, u8 sort_direction)\n{\n\tunion acpi_operand_object *obj_desc1;\n\tunion acpi_operand_object *obj_desc2;\n\tunion acpi_operand_object *temp_obj;\n\tu32 i;\n\tu32 j;\n\n\t \n\n\tfor (i = 1; i < count; i++) {\n\t\tfor (j = (count - 1); j >= i; j--) {\n\t\t\tobj_desc1 = elements[j - 1]->package.elements[index];\n\t\t\tobj_desc2 = elements[j]->package.elements[index];\n\n\t\t\tif (((sort_direction == ACPI_SORT_ASCENDING) &&\n\t\t\t     (obj_desc1->integer.value >\n\t\t\t      obj_desc2->integer.value))\n\t\t\t    || ((sort_direction == ACPI_SORT_DESCENDING)\n\t\t\t\t&& (obj_desc1->integer.value <\n\t\t\t\t    obj_desc2->integer.value))) {\n\t\t\t\ttemp_obj = elements[j - 1];\n\t\t\t\telements[j - 1] = elements[j];\n\t\t\t\telements[j] = temp_obj;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \n\nstatic void\nacpi_ns_remove_element(union acpi_operand_object *obj_desc, u32 index)\n{\n\tunion acpi_operand_object **source;\n\tunion acpi_operand_object **dest;\n\tu32 count;\n\tu32 new_count;\n\tu32 i;\n\n\tACPI_FUNCTION_NAME(ns_remove_element);\n\n\tcount = obj_desc->package.count;\n\tnew_count = count - 1;\n\n\tsource = obj_desc->package.elements;\n\tdest = source;\n\n\t \n\n\tfor (i = 0; i < count; i++) {\n\t\tif (i == index) {\n\t\t\tacpi_ut_remove_reference(*source);\t \n\t\t\tacpi_ut_remove_reference(*source);\n\t\t} else {\n\t\t\t*dest = *source;\n\t\t\tdest++;\n\t\t}\n\n\t\tsource++;\n\t}\n\n\t \n\n\t*dest = NULL;\n\tobj_desc->package.count = new_count;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}