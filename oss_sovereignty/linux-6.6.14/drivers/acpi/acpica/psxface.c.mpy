{
  "module_name": "psxface.c",
  "hash_id": "fdced2b05aa9d4f8b3caea0d6ca3c6b68a55697cadc3ee72a8ee801dc03ef4b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/psxface.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acparser.h\"\n#include \"acdispat.h\"\n#include \"acinterp.h\"\n#include \"actables.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_PARSER\nACPI_MODULE_NAME(\"psxface\")\n\n \nstatic void\nacpi_ps_update_parameter_list(struct acpi_evaluate_info *info, u16 action);\n\n \n\nacpi_status\nacpi_debug_trace(const char *name, u32 debug_level, u32 debug_layer, u32 flags)\n{\n\tacpi_status status;\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tacpi_gbl_trace_method_name = name;\n\tacpi_gbl_trace_flags = flags;\n\tacpi_gbl_trace_dbg_level = debug_level;\n\tacpi_gbl_trace_dbg_layer = debug_layer;\n\tstatus = AE_OK;\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn (status);\n}\n\n \n\nacpi_status acpi_ps_execute_method(struct acpi_evaluate_info *info)\n{\n\tacpi_status status;\n\tunion acpi_parse_object *op;\n\tstruct acpi_walk_state *walk_state;\n\n\tACPI_FUNCTION_TRACE(ps_execute_method);\n\n\t \n\n\tacpi_tb_check_dsdt_header();\n\n\t \n\n\tif (!info || !info->node) {\n\t\treturn_ACPI_STATUS(AE_NULL_ENTRY);\n\t}\n\n\t \n\n\tstatus =\n\t    acpi_ds_begin_method_execution(info->node, info->obj_desc, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tacpi_ps_update_parameter_list(info, REF_INCREMENT);\n\n\t \n\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t  \"**** Begin Method Parse/Execute [%4.4s] **** Node=%p Obj=%p\\n\",\n\t\t\t  info->node->name.ascii, info->node, info->obj_desc));\n\n\t \n\n\top = acpi_ps_create_scope_op(info->obj_desc->method.aml_start);\n\tif (!op) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tinfo->pass_number = ACPI_IMODE_EXECUTE;\n\twalk_state =\n\t    acpi_ds_create_walk_state(info->obj_desc->method.owner_id, NULL,\n\t\t\t\t      NULL, NULL);\n\tif (!walk_state) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\tstatus = acpi_ds_init_aml_walk(walk_state, op, info->node,\n\t\t\t\t       info->obj_desc->method.aml_start,\n\t\t\t\t       info->obj_desc->method.aml_length, info,\n\t\t\t\t       info->pass_number);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ds_delete_walk_state(walk_state);\n\t\tgoto cleanup;\n\t}\n\n\twalk_state->method_pathname = info->full_pathname;\n\twalk_state->method_is_nested = FALSE;\n\n\tif (info->obj_desc->method.info_flags & ACPI_METHOD_MODULE_LEVEL) {\n\t\twalk_state->parse_flags |= ACPI_PARSE_MODULE_LEVEL;\n\t}\n\n\t \n\n\tif (info->obj_desc->method.info_flags & ACPI_METHOD_INTERNAL_ONLY) {\n\t\tstatus =\n\t\t    info->obj_desc->method.dispatch.implementation(walk_state);\n\t\tinfo->return_object = walk_state->return_desc;\n\n\t\t \n\n\t\tacpi_ds_scope_stack_clear(walk_state);\n\t\tacpi_ps_cleanup_scope(&walk_state->parser_state);\n\t\tacpi_ds_terminate_control_method(walk_state->method_desc,\n\t\t\t\t\t\t walk_state);\n\t\tacpi_ds_delete_walk_state(walk_state);\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (acpi_gbl_enable_interpreter_slack) {\n\t\twalk_state->implicit_return_obj =\n\t\t    acpi_ut_create_integer_object((u64) 0);\n\t\tif (!walk_state->implicit_return_obj) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tacpi_ds_delete_walk_state(walk_state);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\n\tstatus = acpi_ps_parse_aml(walk_state);\n\n\t \n\ncleanup:\n\tacpi_ps_delete_parse_tree(op);\n\n\t \n\n\tacpi_ps_update_parameter_list(info, REF_DECREMENT);\n\n\t \n\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tif (info->return_object) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_PARSE, \"Method returned ObjDesc=%p\\n\",\n\t\t\t\t  info->return_object));\n\t\tACPI_DUMP_STACK_ENTRY(info->return_object);\n\n\t\tstatus = AE_CTRL_RETURN_VALUE;\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ps_execute_table(struct acpi_evaluate_info *info)\n{\n\tacpi_status status;\n\tunion acpi_parse_object *op = NULL;\n\tstruct acpi_walk_state *walk_state = NULL;\n\n\tACPI_FUNCTION_TRACE(ps_execute_table);\n\n\t \n\n\top = acpi_ps_create_scope_op(info->obj_desc->method.aml_start);\n\tif (!op) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\twalk_state =\n\t    acpi_ds_create_walk_state(info->obj_desc->method.owner_id, NULL,\n\t\t\t\t      NULL, NULL);\n\tif (!walk_state) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\tstatus = acpi_ds_init_aml_walk(walk_state, op, info->node,\n\t\t\t\t       info->obj_desc->method.aml_start,\n\t\t\t\t       info->obj_desc->method.aml_length, info,\n\t\t\t\t       info->pass_number);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto cleanup;\n\t}\n\n\twalk_state->method_pathname = info->full_pathname;\n\twalk_state->method_is_nested = FALSE;\n\n\tif (info->obj_desc->method.info_flags & ACPI_METHOD_MODULE_LEVEL) {\n\t\twalk_state->parse_flags |= ACPI_PARSE_MODULE_LEVEL;\n\t}\n\n\t \n\n\tif (info->node && info->node != acpi_gbl_root_node) {\n\t\tstatus =\n\t\t    acpi_ds_scope_stack_push(info->node, ACPI_TYPE_METHOD,\n\t\t\t\t\t     walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\tacpi_ex_enter_interpreter();\n\tstatus = acpi_ps_parse_aml(walk_state);\n\tacpi_ex_exit_interpreter();\n\twalk_state = NULL;\n\ncleanup:\n\tif (walk_state) {\n\t\tacpi_ds_delete_walk_state(walk_state);\n\t}\n\tif (op) {\n\t\tacpi_ps_delete_parse_tree(op);\n\t}\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic void\nacpi_ps_update_parameter_list(struct acpi_evaluate_info *info, u16 action)\n{\n\tu32 i;\n\n\tif (info->parameters) {\n\n\t\t \n\n\t\tfor (i = 0; info->parameters[i]; i++) {\n\n\t\t\t \n\n\t\t\t(void)acpi_ut_update_object_reference(info->\n\t\t\t\t\t\t\t      parameters[i],\n\t\t\t\t\t\t\t      action);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}