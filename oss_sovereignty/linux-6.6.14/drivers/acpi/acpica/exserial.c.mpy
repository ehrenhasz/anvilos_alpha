{
  "module_name": "exserial.c",
  "hash_id": "beded36e701423abab480a4b3c0009a00b311d5c88e528455d7dd9379d80feb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/exserial.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acdispat.h\"\n#include \"acinterp.h\"\n#include \"amlcode.h\"\n\n#define _COMPONENT          ACPI_EXECUTER\nACPI_MODULE_NAME(\"exserial\")\n\n \nacpi_status acpi_ex_read_gpio(union acpi_operand_object *obj_desc, void *buffer)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_read_gpio, obj_desc);\n\n\t \n\tACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\n\t\t\t  \"GPIO FieldRead [FROM]:  Pin %u Bits %u\\n\",\n\t\t\t  obj_desc->field.pin_number_index,\n\t\t\t  obj_desc->field.bit_length));\n\n\t \n\n\tacpi_ex_acquire_global_lock(obj_desc->common_field.field_flags);\n\n\t \n\n\tstatus = acpi_ex_access_region(obj_desc, 0, (u64 *)buffer, ACPI_READ);\n\n\tacpi_ex_release_global_lock(obj_desc->common_field.field_flags);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ex_write_gpio(union acpi_operand_object *source_desc,\n\t\t   union acpi_operand_object *obj_desc,\n\t\t   union acpi_operand_object **return_buffer)\n{\n\tacpi_status status;\n\tvoid *buffer;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_write_gpio, obj_desc);\n\n\t \n\tif (source_desc->common.type != ACPI_TYPE_INTEGER) {\n\t\treturn_ACPI_STATUS(AE_AML_OPERAND_TYPE);\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\n\t\t\t  \"GPIO FieldWrite [FROM]: (%s:%X), Value %.8X  [TO]: Pin %u Bits %u\\n\",\n\t\t\t  acpi_ut_get_type_name(source_desc->common.type),\n\t\t\t  source_desc->common.type,\n\t\t\t  (u32)source_desc->integer.value,\n\t\t\t  obj_desc->field.pin_number_index,\n\t\t\t  obj_desc->field.bit_length));\n\n\tbuffer = &source_desc->integer.value;\n\n\t \n\n\tacpi_ex_acquire_global_lock(obj_desc->common_field.field_flags);\n\n\t \n\n\tstatus = acpi_ex_access_region(obj_desc, 0, (u64 *)buffer, ACPI_WRITE);\n\tacpi_ex_release_global_lock(obj_desc->common_field.field_flags);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ex_read_serial_bus(union acpi_operand_object *obj_desc,\n\t\t\tunion acpi_operand_object **return_buffer)\n{\n\tacpi_status status;\n\tu32 buffer_length;\n\tunion acpi_operand_object *buffer_desc;\n\tu32 function;\n\tu16 accessor_type;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_read_serial_bus, obj_desc);\n\n\t \n\tswitch (obj_desc->field.region_obj->region.space_id) {\n\tcase ACPI_ADR_SPACE_SMBUS:\n\n\t\tbuffer_length = ACPI_SMBUS_BUFFER_SIZE;\n\t\tfunction = ACPI_READ | (obj_desc->field.attribute << 16);\n\t\tbreak;\n\n\tcase ACPI_ADR_SPACE_IPMI:\n\n\t\tbuffer_length = ACPI_IPMI_BUFFER_SIZE;\n\t\tfunction = ACPI_READ;\n\t\tbreak;\n\n\tcase ACPI_ADR_SPACE_GSBUS:\n\n\t\taccessor_type = obj_desc->field.attribute;\n\t\tif (accessor_type == AML_FIELD_ATTRIB_RAW_PROCESS_BYTES) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Invalid direct read using bidirectional write-then-read protocol\"));\n\n\t\t\treturn_ACPI_STATUS(AE_AML_PROTOCOL);\n\t\t}\n\n\t\tstatus =\n\t\t    acpi_ex_get_protocol_buffer_length(accessor_type,\n\t\t\t\t\t\t       &buffer_length);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Invalid protocol ID for GSBus: 0x%4.4X\",\n\t\t\t\t    accessor_type));\n\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\t \n\n\t\tbuffer_length += ACPI_SERIAL_HEADER_SIZE;\n\t\tfunction = ACPI_READ | (accessor_type << 16);\n\t\tbreak;\n\n\tcase ACPI_ADR_SPACE_PLATFORM_RT:\n\n\t\tbuffer_length = ACPI_PRM_INPUT_BUFFER_SIZE;\n\t\tfunction = ACPI_READ;\n\t\tbreak;\n\n\tdefault:\n\t\treturn_ACPI_STATUS(AE_AML_INVALID_SPACE_ID);\n\t}\n\n\t \n\n\tbuffer_desc = acpi_ut_create_buffer_object(buffer_length);\n\tif (!buffer_desc) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tacpi_ex_acquire_global_lock(obj_desc->common_field.field_flags);\n\n\t \n\n\tstatus = acpi_ex_access_region(obj_desc, 0,\n\t\t\t\t       ACPI_CAST_PTR(u64,\n\t\t\t\t\t\t     buffer_desc->buffer.\n\t\t\t\t\t\t     pointer), function);\n\tacpi_ex_release_global_lock(obj_desc->common_field.field_flags);\n\n\t*return_buffer = buffer_desc;\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ex_write_serial_bus(union acpi_operand_object *source_desc,\n\t\t\t union acpi_operand_object *obj_desc,\n\t\t\t union acpi_operand_object **return_buffer)\n{\n\tacpi_status status;\n\tu32 buffer_length;\n\tu32 data_length;\n\tvoid *buffer;\n\tunion acpi_operand_object *buffer_desc;\n\tu32 function;\n\tu16 accessor_type;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_write_serial_bus, obj_desc);\n\n\t \n\tif (source_desc->common.type != ACPI_TYPE_BUFFER) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"SMBus/IPMI/GenericSerialBus write requires \"\n\t\t\t    \"Buffer, found type %s\",\n\t\t\t    acpi_ut_get_object_type_name(source_desc)));\n\n\t\treturn_ACPI_STATUS(AE_AML_OPERAND_TYPE);\n\t}\n\n\tswitch (obj_desc->field.region_obj->region.space_id) {\n\tcase ACPI_ADR_SPACE_SMBUS:\n\n\t\tbuffer_length = ACPI_SMBUS_BUFFER_SIZE;\n\t\tfunction = ACPI_WRITE | (obj_desc->field.attribute << 16);\n\t\tbreak;\n\n\tcase ACPI_ADR_SPACE_IPMI:\n\n\t\tbuffer_length = ACPI_IPMI_BUFFER_SIZE;\n\t\tfunction = ACPI_WRITE;\n\t\tbreak;\n\n\tcase ACPI_ADR_SPACE_GSBUS:\n\n\t\taccessor_type = obj_desc->field.attribute;\n\t\tstatus =\n\t\t    acpi_ex_get_protocol_buffer_length(accessor_type,\n\t\t\t\t\t\t       &buffer_length);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Invalid protocol ID for GSBus: 0x%4.4X\",\n\t\t\t\t    accessor_type));\n\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\t \n\n\t\tbuffer_length += ACPI_SERIAL_HEADER_SIZE;\n\t\tfunction = ACPI_WRITE | (accessor_type << 16);\n\t\tbreak;\n\n\tcase ACPI_ADR_SPACE_PLATFORM_RT:\n\n\t\tbuffer_length = ACPI_PRM_INPUT_BUFFER_SIZE;\n\t\tfunction = ACPI_WRITE;\n\t\tbreak;\n\n\tcase ACPI_ADR_SPACE_FIXED_HARDWARE:\n\n\t\tbuffer_length = ACPI_FFH_INPUT_BUFFER_SIZE;\n\t\tfunction = ACPI_WRITE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn_ACPI_STATUS(AE_AML_INVALID_SPACE_ID);\n\t}\n\n\t \n\n\tbuffer_desc = acpi_ut_create_buffer_object(buffer_length);\n\tif (!buffer_desc) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tbuffer = buffer_desc->buffer.pointer;\n\tdata_length = ACPI_MIN(buffer_length, source_desc->buffer.length);\n\tmemcpy(buffer, source_desc->buffer.pointer, data_length);\n\n\t \n\n\tacpi_ex_acquire_global_lock(obj_desc->common_field.field_flags);\n\n\t \n\tstatus = acpi_ex_access_region(obj_desc, 0, (u64 *)buffer, function);\n\tacpi_ex_release_global_lock(obj_desc->common_field.field_flags);\n\n\t*return_buffer = buffer_desc;\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}