{
  "module_name": "tbxface.c",
  "hash_id": "684a4f0ae80de1e019f57cdbe18bfba68a9e10309b3d7a1e4565c4622bd4def2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/tbxface.c",
  "human_readable_source": "\n \n\n#define EXPORT_ACPI_INTERFACES\n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"actables.h\"\n\n#define _COMPONENT          ACPI_TABLES\nACPI_MODULE_NAME(\"tbxface\")\n\n \nacpi_status acpi_allocate_root_table(u32 initial_table_count)\n{\n\n\tacpi_gbl_root_table_list.max_table_count = initial_table_count;\n\tacpi_gbl_root_table_list.flags = ACPI_ROOT_ALLOW_RESIZE;\n\n\treturn (acpi_tb_resize_root_table_list());\n}\n\n \n\nacpi_status ACPI_INIT_FUNCTION\nacpi_initialize_tables(struct acpi_table_desc *initial_table_array,\n\t\t       u32 initial_table_count, u8 allow_resize)\n{\n\tacpi_physical_address rsdp_address;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_initialize_tables);\n\n\t \n\tif (!initial_table_array) {\n\t\tstatus = acpi_allocate_root_table(initial_table_count);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t} else {\n\t\t \n\n\t\tmemset(initial_table_array, 0,\n\t\t       (acpi_size)initial_table_count *\n\t\t       sizeof(struct acpi_table_desc));\n\n\t\tacpi_gbl_root_table_list.tables = initial_table_array;\n\t\tacpi_gbl_root_table_list.max_table_count = initial_table_count;\n\t\tacpi_gbl_root_table_list.flags = ACPI_ROOT_ORIGIN_UNKNOWN;\n\t\tif (allow_resize) {\n\t\t\tacpi_gbl_root_table_list.flags |=\n\t\t\t    ACPI_ROOT_ALLOW_RESIZE;\n\t\t}\n\t}\n\n\t \n\n\trsdp_address = acpi_os_get_root_pointer();\n\tif (!rsdp_address) {\n\t\treturn_ACPI_STATUS(AE_NOT_FOUND);\n\t}\n\n\t \n\tstatus = acpi_tb_parse_root_table(rsdp_address);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL_INIT(acpi_initialize_tables)\n\n \nacpi_status ACPI_INIT_FUNCTION acpi_reallocate_root_table(void)\n{\n\tacpi_status status;\n\tstruct acpi_table_desc *table_desc;\n\tu32 i, j;\n\n\tACPI_FUNCTION_TRACE(acpi_reallocate_root_table);\n\n\t \n\tif ((acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) &&\n\t    acpi_gbl_enable_table_validation) {\n\t\treturn_ACPI_STATUS(AE_SUPPORT);\n\t}\n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\n\t \n\tfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {\n\t\ttable_desc = &acpi_gbl_root_table_list.tables[i];\n\t\tif (table_desc->pointer) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Table [%4.4s] is not invalidated during early boot stage\",\n\t\t\t\t    table_desc->signature.ascii));\n\t\t}\n\t}\n\n\tif (!acpi_gbl_enable_table_validation) {\n\t\t \n\t\tacpi_gbl_enable_table_validation = TRUE;\n\t\tfor (i = 0; i < acpi_gbl_root_table_list.current_table_count;\n\t\t     ++i) {\n\t\t\ttable_desc = &acpi_gbl_root_table_list.tables[i];\n\t\t\tif (!(table_desc->flags & ACPI_TABLE_IS_VERIFIED)) {\n\t\t\t\tstatus =\n\t\t\t\t    acpi_tb_verify_temp_table(table_desc, NULL,\n\t\t\t\t\t\t\t      &j);\n\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\tacpi_tb_uninstall_table(table_desc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tacpi_gbl_root_table_list.flags |= ACPI_ROOT_ALLOW_RESIZE;\n\tstatus = acpi_tb_resize_root_table_list();\n\tacpi_gbl_root_table_list.flags |= ACPI_ROOT_ORIGIN_ALLOCATED;\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL_INIT(acpi_reallocate_root_table)\n\n \nacpi_status\nacpi_get_table_header(char *signature,\n\t\t      u32 instance, struct acpi_table_header *out_table_header)\n{\n\tu32 i;\n\tu32 j;\n\tstruct acpi_table_header *header;\n\n\t \n\n\tif (!signature || !out_table_header) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tfor (i = 0, j = 0; i < acpi_gbl_root_table_list.current_table_count;\n\t     i++) {\n\t\tif (!ACPI_COMPARE_NAMESEG\n\t\t    (&(acpi_gbl_root_table_list.tables[i].signature),\n\t\t     signature)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (++j < instance) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!acpi_gbl_root_table_list.tables[i].pointer) {\n\t\t\tif ((acpi_gbl_root_table_list.tables[i].flags &\n\t\t\t     ACPI_TABLE_ORIGIN_MASK) ==\n\t\t\t    ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL) {\n\t\t\t\theader =\n\t\t\t\t    acpi_os_map_memory(acpi_gbl_root_table_list.\n\t\t\t\t\t\t       tables[i].address,\n\t\t\t\t\t\t       sizeof(struct\n\t\t\t\t\t\t\t      acpi_table_header));\n\t\t\t\tif (!header) {\n\t\t\t\t\treturn (AE_NO_MEMORY);\n\t\t\t\t}\n\n\t\t\t\tmemcpy(out_table_header, header,\n\t\t\t\t       sizeof(struct acpi_table_header));\n\t\t\t\tacpi_os_unmap_memory(header,\n\t\t\t\t\t\t     sizeof(struct\n\t\t\t\t\t\t\t    acpi_table_header));\n\t\t\t} else {\n\t\t\t\treturn (AE_NOT_FOUND);\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy(out_table_header,\n\t\t\t       acpi_gbl_root_table_list.tables[i].pointer,\n\t\t\t       sizeof(struct acpi_table_header));\n\t\t}\n\t\treturn (AE_OK);\n\t}\n\n\treturn (AE_NOT_FOUND);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_table_header)\n\n \nacpi_status\nacpi_get_table(char *signature,\n\t       u32 instance, struct acpi_table_header ** out_table)\n{\n\tu32 i;\n\tu32 j;\n\tacpi_status status = AE_NOT_FOUND;\n\tstruct acpi_table_desc *table_desc;\n\n\t \n\n\tif (!signature || !out_table) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\t*out_table = NULL;\n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\n\t \n\n\tfor (i = 0, j = 0; i < acpi_gbl_root_table_list.current_table_count;\n\t     i++) {\n\t\ttable_desc = &acpi_gbl_root_table_list.tables[i];\n\n\t\tif (!ACPI_COMPARE_NAMESEG(&table_desc->signature, signature)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (++j < instance) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = acpi_tb_get_table(table_desc, out_table);\n\t\tbreak;\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\treturn (status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_table)\n\n \nvoid acpi_put_table(struct acpi_table_header *table)\n{\n\tu32 i;\n\tstruct acpi_table_desc *table_desc;\n\n\tACPI_FUNCTION_TRACE(acpi_put_table);\n\n\tif (!table) {\n\t\treturn_VOID;\n\t}\n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\n\t \n\n\tfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {\n\t\ttable_desc = &acpi_gbl_root_table_list.tables[i];\n\n\t\tif (table_desc->pointer != table) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpi_tb_put_table(table_desc);\n\t\tbreak;\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\treturn_VOID;\n}\n\nACPI_EXPORT_SYMBOL(acpi_put_table)\n\n \nacpi_status\nacpi_get_table_by_index(u32 table_index, struct acpi_table_header **out_table)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_get_table_by_index);\n\n\t \n\n\tif (!out_table) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\t*out_table = NULL;\n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\n\t \n\n\tif (table_index >= acpi_gbl_root_table_list.current_table_count) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto unlock_and_exit;\n\t}\n\n\tstatus =\n\t    acpi_tb_get_table(&acpi_gbl_root_table_list.tables[table_index],\n\t\t\t      out_table);\n\nunlock_and_exit:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_table_by_index)\n\n \nacpi_status\nacpi_install_table_handler(acpi_table_handler handler, void *context)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_install_table_handler);\n\n\tif (!handler) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tif (acpi_gbl_table_handler) {\n\t\tstatus = AE_ALREADY_EXISTS;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tacpi_gbl_table_handler = handler;\n\tacpi_gbl_table_handler_context = context;\n\ncleanup:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_install_table_handler)\n\n \nacpi_status acpi_remove_table_handler(acpi_table_handler handler)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(acpi_remove_table_handler);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tif (!handler || handler != acpi_gbl_table_handler) {\n\t\tstatus = AE_BAD_PARAMETER;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tacpi_gbl_table_handler = NULL;\n\ncleanup:\n\t(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_remove_table_handler)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}