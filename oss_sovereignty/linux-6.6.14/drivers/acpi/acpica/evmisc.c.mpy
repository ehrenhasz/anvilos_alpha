{
  "module_name": "evmisc.c",
  "hash_id": "1ac91cce005092a27aab69a5159ef6da00098230fe5c59455ea7e19133ac6bb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evmisc.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evmisc\")\n\n \nstatic void ACPI_SYSTEM_XFACE acpi_ev_notify_dispatch(void *context);\n\n \n\nu8 acpi_ev_is_notify_object(struct acpi_namespace_node *node)\n{\n\n\tswitch (node->type) {\n\tcase ACPI_TYPE_DEVICE:\n\tcase ACPI_TYPE_PROCESSOR:\n\tcase ACPI_TYPE_THERMAL:\n\t\t \n\t\treturn (TRUE);\n\n\tdefault:\n\n\t\treturn (FALSE);\n\t}\n}\n\n \n\nacpi_status\nacpi_ev_queue_notify_request(struct acpi_namespace_node *node, u32 notify_value)\n{\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_operand_object *handler_list_head = NULL;\n\tunion acpi_generic_state *info;\n\tu8 handler_list_id = 0;\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_NAME(ev_queue_notify_request);\n\n\t \n\n\tif (!acpi_ev_is_notify_object(node)) {\n\t\treturn (AE_TYPE);\n\t}\n\n\t \n\n\tif (notify_value <= ACPI_MAX_SYS_NOTIFY) {\n\t\thandler_list_id = ACPI_SYSTEM_HANDLER_LIST;\n\t} else {\n\t\thandler_list_id = ACPI_DEVICE_HANDLER_LIST;\n\t}\n\n\t \n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (obj_desc) {\n\n\t\t \n\n\t\thandler_list_head =\n\t\t    obj_desc->common_notify.notify_list[handler_list_id];\n\t}\n\n\t \n\tif (!acpi_gbl_global_notify[handler_list_id].handler\n\t    && !handler_list_head) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_INFO,\n\t\t\t\t  \"No notify handler for Notify, ignoring (%4.4s, %X) node %p\\n\",\n\t\t\t\t  acpi_ut_get_node_name(node), notify_value,\n\t\t\t\t  node));\n\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tinfo = acpi_ut_create_generic_state();\n\tif (!info) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\tinfo->common.descriptor_type = ACPI_DESC_TYPE_STATE_NOTIFY;\n\n\tinfo->notify.node = node;\n\tinfo->notify.value = (u16)notify_value;\n\tinfo->notify.handler_list_id = handler_list_id;\n\tinfo->notify.handler_list_head = handler_list_head;\n\tinfo->notify.global = &acpi_gbl_global_notify[handler_list_id];\n\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO,\n\t\t\t  \"Dispatching Notify on [%4.4s] (%s) Value 0x%2.2X (%s) Node %p\\n\",\n\t\t\t  acpi_ut_get_node_name(node),\n\t\t\t  acpi_ut_get_type_name(node->type), notify_value,\n\t\t\t  acpi_ut_get_notify_name(notify_value, ACPI_TYPE_ANY),\n\t\t\t  node));\n\n\tstatus = acpi_os_execute(OSL_NOTIFY_HANDLER,\n\t\t\t\t acpi_ev_notify_dispatch, info);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ut_delete_generic_state(info);\n\t}\n\n\treturn (status);\n}\n\n \n\nstatic void ACPI_SYSTEM_XFACE acpi_ev_notify_dispatch(void *context)\n{\n\tunion acpi_generic_state *info = (union acpi_generic_state *)context;\n\tunion acpi_operand_object *handler_obj;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tif (info->notify.global->handler) {\n\t\tinfo->notify.global->handler(info->notify.node,\n\t\t\t\t\t     info->notify.value,\n\t\t\t\t\t     info->notify.global->context);\n\t}\n\n\t \n\n\thandler_obj = info->notify.handler_list_head;\n\twhile (handler_obj) {\n\t\thandler_obj->notify.handler(info->notify.node,\n\t\t\t\t\t    info->notify.value,\n\t\t\t\t\t    handler_obj->notify.context);\n\n\t\thandler_obj =\n\t\t    handler_obj->notify.next[info->notify.handler_list_id];\n\t}\n\n\t \n\n\tacpi_ut_delete_generic_state(info);\n}\n\n#if (!ACPI_REDUCED_HARDWARE)\n \n\nvoid acpi_ev_terminate(void)\n{\n\tu32 i;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ev_terminate);\n\n\tif (acpi_gbl_events_initialized) {\n\t\t \n\n\t\t \n\n\t\tfor (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {\n\t\t\tstatus = acpi_disable_event(i, 0);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t\t    \"Could not disable fixed event %u\",\n\t\t\t\t\t    (u32) i));\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ev_walk_gpe_list(acpi_hw_disable_gpe_block, NULL);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\"Could not disable GPEs in GPE block\"));\n\t\t}\n\n\t\tstatus = acpi_ev_remove_global_lock_handler();\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\"Could not remove Global Lock handler\"));\n\t\t}\n\n\t\tacpi_gbl_events_initialized = FALSE;\n\t}\n\n\t \n\n\tstatus = acpi_ev_remove_all_sci_handlers();\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_ERROR((AE_INFO, \"Could not remove SCI handler\"));\n\t}\n\n\t \n\n\tstatus = acpi_ev_walk_gpe_list(acpi_ev_delete_gpe_handlers, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"Could not delete GPE handlers\"));\n\t}\n\n\t \n\n\tif (acpi_gbl_original_mode == ACPI_SYS_MODE_LEGACY) {\n\t\tstatus = acpi_disable();\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_WARNING((AE_INFO, \"AcpiDisable failed\"));\n\t\t}\n\t}\n\treturn_VOID;\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}