{
  "module_name": "evgpeutil.c",
  "hash_id": "a8cad5b4a671b9bf8ef4bf106201a1ede96730af95de9411accbfa109fadc220",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evgpeutil.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evgpeutil\")\n\n#if (!ACPI_REDUCED_HARDWARE)\t \n \nacpi_status\nacpi_ev_walk_gpe_list(acpi_gpe_callback gpe_walk_callback, void *context)\n{\n\tstruct acpi_gpe_block_info *gpe_block;\n\tstruct acpi_gpe_xrupt_info *gpe_xrupt_info;\n\tacpi_status status = AE_OK;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(ev_walk_gpe_list);\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\tgpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;\n\twhile (gpe_xrupt_info) {\n\n\t\t \n\n\t\tgpe_block = gpe_xrupt_info->gpe_block_list_head;\n\t\twhile (gpe_block) {\n\n\t\t\t \n\n\t\t\tstatus =\n\t\t\t    gpe_walk_callback(gpe_xrupt_info, gpe_block,\n\t\t\t\t\t      context);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tif (status == AE_CTRL_END) {\t \n\t\t\t\t\tstatus = AE_OK;\n\t\t\t\t}\n\t\t\t\tgoto unlock_and_exit;\n\t\t\t}\n\n\t\t\tgpe_block = gpe_block->next;\n\t\t}\n\n\t\tgpe_xrupt_info = gpe_xrupt_info->next;\n\t}\n\nunlock_and_exit:\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ev_get_gpe_device(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\n\t\t       struct acpi_gpe_block_info *gpe_block, void *context)\n{\n\tstruct acpi_gpe_device_info *info = context;\n\n\t \n\n\tinfo->next_block_base_index += gpe_block->gpe_count;\n\n\tif (info->index < info->next_block_base_index) {\n\t\t \n\t\tif ((gpe_block->node)->type == ACPI_TYPE_DEVICE) {\n\t\t\tinfo->gpe_device = gpe_block->node;\n\t\t}\n\n\t\tinfo->status = AE_OK;\n\t\treturn (AE_CTRL_END);\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_ev_get_gpe_xrupt_block(u32 interrupt_number,\n\t\t\t    struct acpi_gpe_xrupt_info **gpe_xrupt_block)\n{\n\tstruct acpi_gpe_xrupt_info *next_gpe_xrupt;\n\tstruct acpi_gpe_xrupt_info *gpe_xrupt;\n\tacpi_status status;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(ev_get_gpe_xrupt_block);\n\n\t \n\n\tnext_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;\n\twhile (next_gpe_xrupt) {\n\t\tif (next_gpe_xrupt->interrupt_number == interrupt_number) {\n\t\t\t*gpe_xrupt_block = next_gpe_xrupt;\n\t\t\treturn_ACPI_STATUS(AE_OK);\n\t\t}\n\n\t\tnext_gpe_xrupt = next_gpe_xrupt->next;\n\t}\n\n\t \n\n\tgpe_xrupt = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_xrupt_info));\n\tif (!gpe_xrupt) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tgpe_xrupt->interrupt_number = interrupt_number;\n\n\t \n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\tif (acpi_gbl_gpe_xrupt_list_head) {\n\t\tnext_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;\n\t\twhile (next_gpe_xrupt->next) {\n\t\t\tnext_gpe_xrupt = next_gpe_xrupt->next;\n\t\t}\n\n\t\tnext_gpe_xrupt->next = gpe_xrupt;\n\t\tgpe_xrupt->previous = next_gpe_xrupt;\n\t} else {\n\t\tacpi_gbl_gpe_xrupt_list_head = gpe_xrupt;\n\t}\n\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\n\t \n\n\tif (interrupt_number != acpi_gbl_FADT.sci_interrupt) {\n\t\tstatus = acpi_os_install_interrupt_handler(interrupt_number,\n\t\t\t\t\t\t\t   acpi_ev_gpe_xrupt_handler,\n\t\t\t\t\t\t\t   gpe_xrupt);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\"Could not install GPE interrupt handler at level 0x%X\",\n\t\t\t\t\tinterrupt_number));\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t}\n\n\t*gpe_xrupt_block = gpe_xrupt;\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status acpi_ev_delete_gpe_xrupt(struct acpi_gpe_xrupt_info *gpe_xrupt)\n{\n\tacpi_status status;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(ev_delete_gpe_xrupt);\n\n\t \n\n\tif (gpe_xrupt->interrupt_number == acpi_gbl_FADT.sci_interrupt) {\n\t\tgpe_xrupt->gpe_block_list_head = NULL;\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tstatus =\n\t    acpi_os_remove_interrupt_handler(gpe_xrupt->interrupt_number,\n\t\t\t\t\t     acpi_ev_gpe_xrupt_handler);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\tif (gpe_xrupt->previous) {\n\t\tgpe_xrupt->previous->next = gpe_xrupt->next;\n\t} else {\n\t\t \n\n\t\tacpi_gbl_gpe_xrupt_list_head = gpe_xrupt->next;\n\t}\n\n\tif (gpe_xrupt->next) {\n\t\tgpe_xrupt->next->previous = gpe_xrupt->previous;\n\t}\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\n\t \n\n\tACPI_FREE(gpe_xrupt);\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\n\t\t\t    struct acpi_gpe_block_info *gpe_block,\n\t\t\t    void *context)\n{\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tstruct acpi_gpe_notify_info *notify;\n\tstruct acpi_gpe_notify_info *next;\n\tu32 i;\n\tu32 j;\n\n\tACPI_FUNCTION_TRACE(ev_delete_gpe_handlers);\n\n\t \n\n\tfor (i = 0; i < gpe_block->register_count; i++) {\n\n\t\t \n\n\t\tfor (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {\n\t\t\tgpe_event_info = &gpe_block->event_info[((acpi_size)i *\n\t\t\t\t\t\t\t\t ACPI_GPE_REGISTER_WIDTH)\n\t\t\t\t\t\t\t\t+ j];\n\n\t\t\tif ((ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\n\t\t\t     ACPI_GPE_DISPATCH_HANDLER) ||\n\t\t\t    (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\n\t\t\t     ACPI_GPE_DISPATCH_RAW_HANDLER)) {\n\n\t\t\t\t \n\n\t\t\t\tACPI_FREE(gpe_event_info->dispatch.handler);\n\t\t\t\tgpe_event_info->dispatch.handler = NULL;\n\t\t\t\tgpe_event_info->flags &=\n\t\t\t\t    ~ACPI_GPE_DISPATCH_MASK;\n\t\t\t} else if (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags)\n\t\t\t\t   == ACPI_GPE_DISPATCH_NOTIFY) {\n\n\t\t\t\t \n\n\t\t\t\tnotify = gpe_event_info->dispatch.notify_list;\n\t\t\t\twhile (notify) {\n\t\t\t\t\tnext = notify->next;\n\t\t\t\t\tACPI_FREE(notify);\n\t\t\t\t\tnotify = next;\n\t\t\t\t}\n\n\t\t\t\tgpe_event_info->dispatch.notify_list = NULL;\n\t\t\t\tgpe_event_info->flags &=\n\t\t\t\t    ~ACPI_GPE_DISPATCH_MASK;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}