{
  "module_name": "tbinstal.c",
  "hash_id": "be68ec065674d8e14f87d3b270d4bbaff47ebbc7d6338dd1bea239780478acf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/tbinstal.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"actables.h\"\n\n#define _COMPONENT          ACPI_TABLES\nACPI_MODULE_NAME(\"tbinstal\")\n\n \nvoid\nacpi_tb_install_table_with_override(struct acpi_table_desc *new_table_desc,\n\t\t\t\t    u8 override, u32 *table_index)\n{\n\tu32 i;\n\tacpi_status status;\n\n\tstatus = acpi_tb_get_next_table_descriptor(&i, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn;\n\t}\n\n\t \n\tif (override) {\n\t\tacpi_tb_override_table(new_table_desc);\n\t}\n\n\tacpi_tb_init_table_descriptor(&acpi_gbl_root_table_list.tables[i],\n\t\t\t\t      new_table_desc->address,\n\t\t\t\t      new_table_desc->flags,\n\t\t\t\t      new_table_desc->pointer);\n\n\tacpi_tb_print_table_header(new_table_desc->address,\n\t\t\t\t   new_table_desc->pointer);\n\n\t \n\n\t*table_index = i;\n\n\t \n\n\tif (i == acpi_gbl_dsdt_index) {\n\t\tacpi_ut_set_integer_width(new_table_desc->pointer->revision);\n\t}\n}\n\n \n\nacpi_status\nacpi_tb_install_standard_table(acpi_physical_address address,\n\t\t\t       u8 flags,\n\t\t\t       struct acpi_table_header *table,\n\t\t\t       u8 reload, u8 override, u32 *table_index)\n{\n\tu32 i;\n\tacpi_status status = AE_OK;\n\tstruct acpi_table_desc new_table_desc;\n\n\tACPI_FUNCTION_TRACE(tb_install_standard_table);\n\n\t \n\n\tstatus =\n\t    acpi_tb_acquire_temp_table(&new_table_desc, address, flags, table);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Could not acquire table length at %8.8X%8.8X\",\n\t\t\t    ACPI_FORMAT_UINT64(address)));\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tif (!reload &&\n\t    acpi_gbl_disable_ssdt_table_install &&\n\t    ACPI_COMPARE_NAMESEG(&new_table_desc.signature, ACPI_SIG_SSDT)) {\n\t\tACPI_INFO((\"Ignoring installation of %4.4s at %8.8X%8.8X\",\n\t\t\t   new_table_desc.signature.ascii,\n\t\t\t   ACPI_FORMAT_UINT64(address)));\n\t\tgoto release_and_exit;\n\t}\n\n\t \n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\n\t \n\n\tstatus = acpi_tb_verify_temp_table(&new_table_desc, NULL, &i);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status == AE_CTRL_TERMINATE) {\n\t\t\t \n\t\t\tacpi_tb_uninstall_table(&new_table_desc);\n\t\t\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\t\t\t*table_index = i;\n\t\t\treturn_ACPI_STATUS(AE_OK);\n\t\t}\n\t\tgoto unlock_and_exit;\n\t}\n\n\t \n\n\tacpi_tb_install_table_with_override(&new_table_desc, override,\n\t\t\t\t\t    table_index);\n\n\t \n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\tacpi_tb_notify_table(ACPI_TABLE_EVENT_INSTALL, new_table_desc.pointer);\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\n\nunlock_and_exit:\n\n\t \n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\n\nrelease_and_exit:\n\n\t \n\n\tacpi_tb_release_temp_table(&new_table_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nvoid acpi_tb_override_table(struct acpi_table_desc *old_table_desc)\n{\n\tacpi_status status;\n\tstruct acpi_table_desc new_table_desc;\n\tstruct acpi_table_header *table;\n\tacpi_physical_address address;\n\tu32 length;\n\tACPI_ERROR_ONLY(char *override_type);\n\n\t \n\n\tstatus = acpi_os_table_override(old_table_desc->pointer, &table);\n\tif (ACPI_SUCCESS(status) && table) {\n\t\tacpi_tb_acquire_temp_table(&new_table_desc,\n\t\t\t\t\t   ACPI_PTR_TO_PHYSADDR(table),\n\t\t\t\t\t   ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL,\n\t\t\t\t\t   table);\n\t\tACPI_ERROR_ONLY(override_type = \"Logical\");\n\t\tgoto finish_override;\n\t}\n\n\t \n\n\tstatus = acpi_os_physical_table_override(old_table_desc->pointer,\n\t\t\t\t\t\t &address, &length);\n\tif (ACPI_SUCCESS(status) && address && length) {\n\t\tacpi_tb_acquire_temp_table(&new_table_desc, address,\n\t\t\t\t\t   ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL,\n\t\t\t\t\t   NULL);\n\t\tACPI_ERROR_ONLY(override_type = \"Physical\");\n\t\tgoto finish_override;\n\t}\n\n\treturn;\t\t\t \n\nfinish_override:\n\n\t \n\tstatus = acpi_tb_verify_temp_table(&new_table_desc, NULL, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn;\n\t}\n\n\tACPI_INFO((\"%4.4s 0x%8.8X%8.8X\"\n\t\t   \" %s table override, new table: 0x%8.8X%8.8X\",\n\t\t   old_table_desc->signature.ascii,\n\t\t   ACPI_FORMAT_UINT64(old_table_desc->address),\n\t\t   override_type, ACPI_FORMAT_UINT64(new_table_desc.address)));\n\n\t \n\n\tacpi_tb_uninstall_table(old_table_desc);\n\n\t \n\tacpi_tb_init_table_descriptor(old_table_desc, new_table_desc.address,\n\t\t\t\t      new_table_desc.flags,\n\t\t\t\t      new_table_desc.pointer);\n\tacpi_tb_validate_temp_table(old_table_desc);\n\n\t \n\n\tacpi_tb_release_temp_table(&new_table_desc);\n}\n\n \n\nvoid acpi_tb_uninstall_table(struct acpi_table_desc *table_desc)\n{\n\n\tACPI_FUNCTION_TRACE(tb_uninstall_table);\n\n\t \n\n\tif (!table_desc->address) {\n\t\treturn_VOID;\n\t}\n\n\tacpi_tb_invalidate_table(table_desc);\n\n\tif ((table_desc->flags & ACPI_TABLE_ORIGIN_MASK) ==\n\t    ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL) {\n\t\tACPI_FREE(table_desc->pointer);\n\t\ttable_desc->pointer = NULL;\n\t}\n\n\ttable_desc->address = ACPI_PTR_TO_PHYSADDR(NULL);\n\treturn_VOID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}