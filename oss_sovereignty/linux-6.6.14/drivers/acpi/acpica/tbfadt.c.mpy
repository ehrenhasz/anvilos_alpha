{
  "module_name": "tbfadt.c",
  "hash_id": "d60b90d4e1d6548213d3982280b6ed7c7a9f49c040f1a242ad475817446f8a1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/tbfadt.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"actables.h\"\n\n#define _COMPONENT          ACPI_TABLES\nACPI_MODULE_NAME(\"tbfadt\")\n\n \nstatic void\nacpi_tb_init_generic_address(struct acpi_generic_address *generic_address,\n\t\t\t     u8 space_id,\n\t\t\t     u8 byte_width,\n\t\t\t     u64 address, const char *register_name, u8 flags);\n\nstatic void acpi_tb_convert_fadt(void);\n\nstatic void acpi_tb_setup_fadt_registers(void);\n\nstatic u64\nacpi_tb_select_address(char *register_name, u32 address32, u64 address64);\n\n \n\ntypedef struct acpi_fadt_info {\n\tconst char *name;\n\tu16 address64;\n\tu16 address32;\n\tu16 length;\n\tu8 default_length;\n\tu8 flags;\n\n} acpi_fadt_info;\n\n#define ACPI_FADT_OPTIONAL          0\n#define ACPI_FADT_REQUIRED          1\n#define ACPI_FADT_SEPARATE_LENGTH   2\n#define ACPI_FADT_GPE_REGISTER      4\n\nstatic struct acpi_fadt_info fadt_info_table[] = {\n\t{\"Pm1aEventBlock\",\n\t ACPI_FADT_OFFSET(xpm1a_event_block),\n\t ACPI_FADT_OFFSET(pm1a_event_block),\n\t ACPI_FADT_OFFSET(pm1_event_length),\n\t ACPI_PM1_REGISTER_WIDTH * 2,\t \n\t ACPI_FADT_REQUIRED},\n\n\t{\"Pm1bEventBlock\",\n\t ACPI_FADT_OFFSET(xpm1b_event_block),\n\t ACPI_FADT_OFFSET(pm1b_event_block),\n\t ACPI_FADT_OFFSET(pm1_event_length),\n\t ACPI_PM1_REGISTER_WIDTH * 2,\t \n\t ACPI_FADT_OPTIONAL},\n\n\t{\"Pm1aControlBlock\",\n\t ACPI_FADT_OFFSET(xpm1a_control_block),\n\t ACPI_FADT_OFFSET(pm1a_control_block),\n\t ACPI_FADT_OFFSET(pm1_control_length),\n\t ACPI_PM1_REGISTER_WIDTH,\n\t ACPI_FADT_REQUIRED},\n\n\t{\"Pm1bControlBlock\",\n\t ACPI_FADT_OFFSET(xpm1b_control_block),\n\t ACPI_FADT_OFFSET(pm1b_control_block),\n\t ACPI_FADT_OFFSET(pm1_control_length),\n\t ACPI_PM1_REGISTER_WIDTH,\n\t ACPI_FADT_OPTIONAL},\n\n\t{\"Pm2ControlBlock\",\n\t ACPI_FADT_OFFSET(xpm2_control_block),\n\t ACPI_FADT_OFFSET(pm2_control_block),\n\t ACPI_FADT_OFFSET(pm2_control_length),\n\t ACPI_PM2_REGISTER_WIDTH,\n\t ACPI_FADT_SEPARATE_LENGTH},\n\n\t{\"PmTimerBlock\",\n\t ACPI_FADT_OFFSET(xpm_timer_block),\n\t ACPI_FADT_OFFSET(pm_timer_block),\n\t ACPI_FADT_OFFSET(pm_timer_length),\n\t ACPI_PM_TIMER_WIDTH,\n\t ACPI_FADT_SEPARATE_LENGTH},\t \n\n\t{\"Gpe0Block\",\n\t ACPI_FADT_OFFSET(xgpe0_block),\n\t ACPI_FADT_OFFSET(gpe0_block),\n\t ACPI_FADT_OFFSET(gpe0_block_length),\n\t 0,\n\t ACPI_FADT_SEPARATE_LENGTH | ACPI_FADT_GPE_REGISTER},\n\n\t{\"Gpe1Block\",\n\t ACPI_FADT_OFFSET(xgpe1_block),\n\t ACPI_FADT_OFFSET(gpe1_block),\n\t ACPI_FADT_OFFSET(gpe1_block_length),\n\t 0,\n\t ACPI_FADT_SEPARATE_LENGTH | ACPI_FADT_GPE_REGISTER}\n};\n\n#define ACPI_FADT_INFO_ENTRIES \\\n\t\t\t(sizeof (fadt_info_table) / sizeof (struct acpi_fadt_info))\n\n \n\ntypedef struct acpi_fadt_pm_info {\n\tstruct acpi_generic_address *target;\n\tu16 source;\n\tu8 register_num;\n\n} acpi_fadt_pm_info;\n\nstatic struct acpi_fadt_pm_info fadt_pm_info_table[] = {\n\t{&acpi_gbl_xpm1a_status,\n\t ACPI_FADT_OFFSET(xpm1a_event_block),\n\t 0},\n\n\t{&acpi_gbl_xpm1a_enable,\n\t ACPI_FADT_OFFSET(xpm1a_event_block),\n\t 1},\n\n\t{&acpi_gbl_xpm1b_status,\n\t ACPI_FADT_OFFSET(xpm1b_event_block),\n\t 0},\n\n\t{&acpi_gbl_xpm1b_enable,\n\t ACPI_FADT_OFFSET(xpm1b_event_block),\n\t 1}\n};\n\n#define ACPI_FADT_PM_INFO_ENTRIES \\\n\t\t\t(sizeof (fadt_pm_info_table) / sizeof (struct acpi_fadt_pm_info))\n\n \n\nstatic void\nacpi_tb_init_generic_address(struct acpi_generic_address *generic_address,\n\t\t\t     u8 space_id,\n\t\t\t     u8 byte_width,\n\t\t\t     u64 address, const char *register_name, u8 flags)\n{\n\tu8 bit_width;\n\n\t \n\tbit_width = (u8)(byte_width * 8);\n\tif (byte_width > 31) {\t \n\t\t \n\t\tif (!(flags & ACPI_FADT_GPE_REGISTER)) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"%s - 32-bit FADT register is too long (%u bytes, %u bits) \"\n\t\t\t\t    \"to convert to GAS struct - 255 bits max, truncating\",\n\t\t\t\t    register_name, byte_width,\n\t\t\t\t    (byte_width * 8)));\n\t\t}\n\n\t\tbit_width = 255;\n\t}\n\n\t \n\tACPI_MOVE_64_TO_64(&generic_address->address, &address);\n\n\t \n\n\tgeneric_address->space_id = space_id;\n\tgeneric_address->bit_width = bit_width;\n\tgeneric_address->bit_offset = 0;\n\tgeneric_address->access_width = 0;\t \n}\n\n \n\nstatic u64\nacpi_tb_select_address(char *register_name, u32 address32, u64 address64)\n{\n\n\tif (!address64) {\n\n\t\t \n\n\t\treturn ((u64)address32);\n\t}\n\n\tif (address32 && (address64 != (u64)address32)) {\n\n\t\t \n\n\t\tACPI_BIOS_WARNING((AE_INFO,\n\t\t\t\t   \"32/64X %s address mismatch in FADT: \"\n\t\t\t\t   \"0x%8.8X/0x%8.8X%8.8X, using %u-bit address\",\n\t\t\t\t   register_name, address32,\n\t\t\t\t   ACPI_FORMAT_UINT64(address64),\n\t\t\t\t   acpi_gbl_use32_bit_fadt_addresses ? 32 :\n\t\t\t\t   64));\n\n\t\t \n\n\t\tif (acpi_gbl_use32_bit_fadt_addresses) {\n\t\t\treturn ((u64)address32);\n\t\t}\n\t}\n\n\t \n\n\treturn (address64);\n}\n\n \n\nvoid acpi_tb_parse_fadt(void)\n{\n\tu32 length;\n\tstruct acpi_table_header *table;\n\tstruct acpi_table_desc *fadt_desc;\n\tacpi_status status;\n\n\t \n\tfadt_desc = &acpi_gbl_root_table_list.tables[acpi_gbl_fadt_index];\n\tstatus = acpi_tb_get_table(fadt_desc, &table);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn;\n\t}\n\tlength = fadt_desc->length;\n\n\t \n\t(void)acpi_ut_verify_checksum(table, length);\n\n\t \n\n\tacpi_tb_create_local_fadt(table, length);\n\n\t \n\n\tacpi_tb_put_table(fadt_desc);\n\n\t \n\n\tacpi_tb_install_standard_table((acpi_physical_address)acpi_gbl_FADT.\n\t\t\t\t       Xdsdt,\n\t\t\t\t       ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL,\n\t\t\t\t       NULL, FALSE, TRUE, &acpi_gbl_dsdt_index);\n\n\t \n\n\tif (!acpi_gbl_reduced_hardware) {\n\t\tif (acpi_gbl_FADT.facs) {\n\t\t\tacpi_tb_install_standard_table((acpi_physical_address)\n\t\t\t\t\t\t       acpi_gbl_FADT.facs,\n\t\t\t\t\t\t       ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL,\n\t\t\t\t\t\t       NULL, FALSE, TRUE,\n\t\t\t\t\t\t       &acpi_gbl_facs_index);\n\t\t}\n\t\tif (acpi_gbl_FADT.Xfacs) {\n\t\t\tacpi_tb_install_standard_table((acpi_physical_address)\n\t\t\t\t\t\t       acpi_gbl_FADT.Xfacs,\n\t\t\t\t\t\t       ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL,\n\t\t\t\t\t\t       NULL, FALSE, TRUE,\n\t\t\t\t\t\t       &acpi_gbl_xfacs_index);\n\t\t}\n\t}\n}\n\n \n\nvoid acpi_tb_create_local_fadt(struct acpi_table_header *table, u32 length)\n{\n\t \n\tif (length > sizeof(struct acpi_table_fadt)) {\n\t\tACPI_BIOS_WARNING((AE_INFO,\n\t\t\t\t   \"FADT (revision %u) is longer than %s length, \"\n\t\t\t\t   \"truncating length %u to %u\",\n\t\t\t\t   table->revision, ACPI_FADT_CONFORMANCE,\n\t\t\t\t   length,\n\t\t\t\t   (u32)sizeof(struct acpi_table_fadt)));\n\t}\n\n\t \n\n\tmemset(&acpi_gbl_FADT, 0, sizeof(struct acpi_table_fadt));\n\n\t \n\n\tmemcpy(&acpi_gbl_FADT, table,\n\t       ACPI_MIN(length, sizeof(struct acpi_table_fadt)));\n\n\t \n\n\tacpi_gbl_reduced_hardware = FALSE;\n\tif (acpi_gbl_FADT.flags & ACPI_FADT_HW_REDUCED) {\n\t\tacpi_gbl_reduced_hardware = TRUE;\n\t}\n\n\t \n\n\tacpi_tb_convert_fadt();\n\n\t \n\n\tacpi_tb_setup_fadt_registers();\n}\n\n \n\nstatic void acpi_tb_convert_fadt(void)\n{\n\tconst char *name;\n\tstruct acpi_generic_address *address64;\n\tu32 address32;\n\tu8 length;\n\tu8 flags;\n\tu32 i;\n\n\t \n\tif (acpi_gbl_FADT.header.length <= ACPI_FADT_V2_SIZE) {\n\t\tacpi_gbl_FADT.preferred_profile = 0;\n\t\tacpi_gbl_FADT.pstate_control = 0;\n\t\tacpi_gbl_FADT.cst_control = 0;\n\t\tacpi_gbl_FADT.boot_flags = 0;\n\t}\n\n\t \n\tacpi_gbl_FADT.header.length = sizeof(struct acpi_table_fadt);\n\n\t \n\tacpi_gbl_FADT.Xdsdt = acpi_tb_select_address(\"DSDT\",\n\t\t\t\t\t\t     acpi_gbl_FADT.dsdt,\n\t\t\t\t\t\t     acpi_gbl_FADT.Xdsdt);\n\n\t \n\n\tif (acpi_gbl_reduced_hardware) {\n\t\treturn;\n\t}\n\n\t \n\n\tfor (i = 0; i < ACPI_FADT_INFO_ENTRIES; i++) {\n\t\t \n\t\taddress32 = *ACPI_ADD_PTR(u32,\n\t\t\t\t\t  &acpi_gbl_FADT,\n\t\t\t\t\t  fadt_info_table[i].address32);\n\n\t\taddress64 = ACPI_ADD_PTR(struct acpi_generic_address,\n\t\t\t\t\t &acpi_gbl_FADT,\n\t\t\t\t\t fadt_info_table[i].address64);\n\n\t\tlength = *ACPI_ADD_PTR(u8,\n\t\t\t\t       &acpi_gbl_FADT,\n\t\t\t\t       fadt_info_table[i].length);\n\n\t\tname = fadt_info_table[i].name;\n\t\tflags = fadt_info_table[i].flags;\n\n\t\t \n\t\tif (address32) {\n\t\t\tif (address64->address) {\n\t\t\t\tif (address64->address != (u64)address32) {\n\n\t\t\t\t\t \n\n\t\t\t\t\tACPI_BIOS_WARNING((AE_INFO,\n\t\t\t\t\t\t\t   \"32/64X address mismatch in FADT/%s: \"\n\t\t\t\t\t\t\t   \"0x%8.8X/0x%8.8X%8.8X, using %u-bit address\",\n\t\t\t\t\t\t\t   name, address32,\n\t\t\t\t\t\t\t   ACPI_FORMAT_UINT64\n\t\t\t\t\t\t\t   (address64->address),\n\t\t\t\t\t\t\t   acpi_gbl_use32_bit_fadt_addresses\n\t\t\t\t\t\t\t   ? 32 : 64));\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif ((ACPI_MUL_8(length) <= ACPI_UINT8_MAX) &&\n\t\t\t\t    (address64->bit_width !=\n\t\t\t\t     ACPI_MUL_8(length))) {\n\t\t\t\t\tACPI_BIOS_WARNING((AE_INFO,\n\t\t\t\t\t\t\t   \"32/64X length mismatch in FADT/%s: %u/%u\",\n\t\t\t\t\t\t\t   name,\n\t\t\t\t\t\t\t   ACPI_MUL_8(length),\n\t\t\t\t\t\t\t   address64->\n\t\t\t\t\t\t\t   bit_width));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!address64->address\n\t\t\t    || acpi_gbl_use32_bit_fadt_addresses) {\n\t\t\t\tacpi_tb_init_generic_address(address64,\n\t\t\t\t\t\t\t     ACPI_ADR_SPACE_SYSTEM_IO,\n\t\t\t\t\t\t\t     length,\n\t\t\t\t\t\t\t     (u64)address32,\n\t\t\t\t\t\t\t     name, flags);\n\t\t\t}\n\t\t}\n\n\t\tif (fadt_info_table[i].flags & ACPI_FADT_REQUIRED) {\n\t\t\t \n\t\t\tif (!address64->address || !length) {\n\t\t\t\tACPI_BIOS_ERROR((AE_INFO,\n\t\t\t\t\t\t \"Required FADT field %s has zero address and/or length: \"\n\t\t\t\t\t\t \"0x%8.8X%8.8X/0x%X\",\n\t\t\t\t\t\t name,\n\t\t\t\t\t\t ACPI_FORMAT_UINT64(address64->\n\t\t\t\t\t\t\t\t    address),\n\t\t\t\t\t\t length));\n\t\t\t}\n\t\t} else if (fadt_info_table[i].flags & ACPI_FADT_SEPARATE_LENGTH) {\n\t\t\t \n\t\t\tif ((address64->address && !length) ||\n\t\t\t    (!address64->address && length)) {\n\t\t\t\tACPI_BIOS_WARNING((AE_INFO,\n\t\t\t\t\t\t   \"Optional FADT field %s has valid %s but zero %s: \"\n\t\t\t\t\t\t   \"0x%8.8X%8.8X/0x%X\", name,\n\t\t\t\t\t\t   (length ? \"Length\" :\n\t\t\t\t\t\t    \"Address\"),\n\t\t\t\t\t\t   (length ? \"Address\" :\n\t\t\t\t\t\t    \"Length\"),\n\t\t\t\t\t\t   ACPI_FORMAT_UINT64\n\t\t\t\t\t\t   (address64->address),\n\t\t\t\t\t\t   length));\n\t\t\t}\n\t\t}\n\t}\n}\n\n \n\nstatic void acpi_tb_setup_fadt_registers(void)\n{\n\tstruct acpi_generic_address *target64;\n\tstruct acpi_generic_address *source64;\n\tu8 pm1_register_byte_width;\n\tu32 i;\n\n\t \n\tif (acpi_gbl_use_default_register_widths) {\n\t\tfor (i = 0; i < ACPI_FADT_INFO_ENTRIES; i++) {\n\t\t\ttarget64 =\n\t\t\t    ACPI_ADD_PTR(struct acpi_generic_address,\n\t\t\t\t\t &acpi_gbl_FADT,\n\t\t\t\t\t fadt_info_table[i].address64);\n\n\t\t\t \n\t\t\tif ((target64->address) &&\n\t\t\t    (fadt_info_table[i].default_length > 0) &&\n\t\t\t    (fadt_info_table[i].default_length !=\n\t\t\t     target64->bit_width)) {\n\t\t\t\tACPI_BIOS_WARNING((AE_INFO,\n\t\t\t\t\t\t   \"Invalid length for FADT/%s: %u, using default %u\",\n\t\t\t\t\t\t   fadt_info_table[i].name,\n\t\t\t\t\t\t   target64->bit_width,\n\t\t\t\t\t\t   fadt_info_table[i].\n\t\t\t\t\t\t   default_length));\n\n\t\t\t\t \n\n\t\t\t\ttarget64->bit_width =\n\t\t\t\t    fadt_info_table[i].default_length;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tpm1_register_byte_width = (u8)\n\t    ACPI_DIV_16(acpi_gbl_FADT.xpm1a_event_block.bit_width);\n\n\t \n\n\tfor (i = 0; i < ACPI_FADT_PM_INFO_ENTRIES; i++) {\n\t\tsource64 =\n\t\t    ACPI_ADD_PTR(struct acpi_generic_address, &acpi_gbl_FADT,\n\t\t\t\t fadt_pm_info_table[i].source);\n\n\t\tif (source64->address) {\n\t\t\tacpi_tb_init_generic_address(fadt_pm_info_table[i].\n\t\t\t\t\t\t     target, source64->space_id,\n\t\t\t\t\t\t     pm1_register_byte_width,\n\t\t\t\t\t\t     source64->address +\n\t\t\t\t\t\t     (fadt_pm_info_table[i].\n\t\t\t\t\t\t      register_num *\n\t\t\t\t\t\t      pm1_register_byte_width),\n\t\t\t\t\t\t     \"PmRegisters\", 0);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}