{
  "module_name": "rsxface.c",
  "hash_id": "d830db25f9826bcabc9913aa54b7d5fa2c53106e03193167b5148be5164f27b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/rsxface.c",
  "human_readable_source": "\n \n\n#define EXPORT_ACPI_INTERFACES\n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acresrc.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_RESOURCES\nACPI_MODULE_NAME(\"rsxface\")\n\n \n#define ACPI_COPY_FIELD(out, in, field)  ((out)->field = (in)->field)\n#define ACPI_COPY_ADDRESS(out, in)                       \\\n\tACPI_COPY_FIELD(out, in, resource_type);             \\\n\tACPI_COPY_FIELD(out, in, producer_consumer);         \\\n\tACPI_COPY_FIELD(out, in, decode);                    \\\n\tACPI_COPY_FIELD(out, in, min_address_fixed);         \\\n\tACPI_COPY_FIELD(out, in, max_address_fixed);         \\\n\tACPI_COPY_FIELD(out, in, info);                      \\\n\tACPI_COPY_FIELD(out, in, address.granularity);       \\\n\tACPI_COPY_FIELD(out, in, address.minimum);           \\\n\tACPI_COPY_FIELD(out, in, address.maximum);           \\\n\tACPI_COPY_FIELD(out, in, address.translation_offset); \\\n\tACPI_COPY_FIELD(out, in, address.address_length);    \\\n\tACPI_COPY_FIELD(out, in, resource_source);\n \nstatic acpi_status\nacpi_rs_match_vendor_resource(struct acpi_resource *resource, void *context);\n\nstatic acpi_status\nacpi_rs_validate_parameters(acpi_handle device_handle,\n\t\t\t    struct acpi_buffer *buffer,\n\t\t\t    struct acpi_namespace_node **return_node);\n\n \n\nstatic acpi_status\nacpi_rs_validate_parameters(acpi_handle device_handle,\n\t\t\t    struct acpi_buffer *buffer,\n\t\t\t    struct acpi_namespace_node **return_node)\n{\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\n\tACPI_FUNCTION_TRACE(rs_validate_parameters);\n\n\t \n\tif (!device_handle) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tnode = acpi_ns_validate_handle(device_handle);\n\tif (!node) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\tif (node->type != ACPI_TYPE_DEVICE) {\n\t\treturn_ACPI_STATUS(AE_TYPE);\n\t}\n\n\t \n\tstatus = acpi_ut_validate_buffer(buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t*return_node = node;\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_get_irq_routing_table(acpi_handle device_handle,\n\t\t\t   struct acpi_buffer *ret_buffer)\n{\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\n\tACPI_FUNCTION_TRACE(acpi_get_irq_routing_table);\n\n\t \n\n\tstatus = acpi_rs_validate_parameters(device_handle, ret_buffer, &node);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_rs_get_prt_method_data(node, ret_buffer);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_irq_routing_table)\n\n \nacpi_status\nacpi_get_current_resources(acpi_handle device_handle,\n\t\t\t   struct acpi_buffer *ret_buffer)\n{\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\n\tACPI_FUNCTION_TRACE(acpi_get_current_resources);\n\n\t \n\n\tstatus = acpi_rs_validate_parameters(device_handle, ret_buffer, &node);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_rs_get_crs_method_data(node, ret_buffer);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_current_resources)\n\n \nacpi_status\nacpi_get_possible_resources(acpi_handle device_handle,\n\t\t\t    struct acpi_buffer *ret_buffer)\n{\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\n\tACPI_FUNCTION_TRACE(acpi_get_possible_resources);\n\n\t \n\n\tstatus = acpi_rs_validate_parameters(device_handle, ret_buffer, &node);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_rs_get_prs_method_data(node, ret_buffer);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_possible_resources)\n\n \nacpi_status\nacpi_set_current_resources(acpi_handle device_handle,\n\t\t\t   struct acpi_buffer *in_buffer)\n{\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\n\tACPI_FUNCTION_TRACE(acpi_set_current_resources);\n\n\t \n\n\tif ((!in_buffer) || (!in_buffer->pointer) || (!in_buffer->length)) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tstatus = acpi_rs_validate_parameters(device_handle, in_buffer, &node);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_rs_set_srs_method_data(node, in_buffer);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_set_current_resources)\n\n \nacpi_status\nacpi_get_event_resources(acpi_handle device_handle,\n\t\t\t struct acpi_buffer *ret_buffer)\n{\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\n\tACPI_FUNCTION_TRACE(acpi_get_event_resources);\n\n\t \n\n\tstatus = acpi_rs_validate_parameters(device_handle, ret_buffer, &node);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_rs_get_aei_method_data(node, ret_buffer);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_event_resources)\n\n \nacpi_status\nacpi_resource_to_address64(struct acpi_resource *resource,\n\t\t\t   struct acpi_resource_address64 *out)\n{\n\tstruct acpi_resource_address16 *address16;\n\tstruct acpi_resource_address32 *address32;\n\n\tif (!resource || !out) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tswitch (resource->type) {\n\tcase ACPI_RESOURCE_TYPE_ADDRESS16:\n\n\t\taddress16 =\n\t\t    ACPI_CAST_PTR(struct acpi_resource_address16,\n\t\t\t\t  &resource->data);\n\t\tACPI_COPY_ADDRESS(out, address16);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_ADDRESS32:\n\n\t\taddress32 =\n\t\t    ACPI_CAST_PTR(struct acpi_resource_address32,\n\t\t\t\t  &resource->data);\n\t\tACPI_COPY_ADDRESS(out, address32);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_ADDRESS64:\n\n\t\t \n\n\t\tmemcpy(out, &resource->data,\n\t\t       sizeof(struct acpi_resource_address64));\n\t\tbreak;\n\n\tdefault:\n\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\treturn (AE_OK);\n}\n\nACPI_EXPORT_SYMBOL(acpi_resource_to_address64)\n\n \nacpi_status\nacpi_get_vendor_resource(acpi_handle device_handle,\n\t\t\t char *name,\n\t\t\t struct acpi_vendor_uuid *uuid,\n\t\t\t struct acpi_buffer *ret_buffer)\n{\n\tstruct acpi_vendor_walk_info info;\n\tacpi_status status;\n\n\t \n\n\tif (!uuid || !ret_buffer) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tinfo.uuid = uuid;\n\tinfo.buffer = ret_buffer;\n\tinfo.status = AE_NOT_EXIST;\n\n\t \n\n\tstatus =\n\t    acpi_walk_resources(device_handle, name,\n\t\t\t\tacpi_rs_match_vendor_resource, &info);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\treturn (info.status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_get_vendor_resource)\n\n \nstatic acpi_status\nacpi_rs_match_vendor_resource(struct acpi_resource *resource, void *context)\n{\n\tstruct acpi_vendor_walk_info *info = context;\n\tstruct acpi_resource_vendor_typed *vendor;\n\tstruct acpi_buffer *buffer;\n\tacpi_status status;\n\n\t \n\n\tif (resource->type != ACPI_RESOURCE_TYPE_VENDOR) {\n\t\treturn (AE_OK);\n\t}\n\n\tvendor = &resource->data.vendor_typed;\n\n\t \n\tif ((vendor->byte_length < (ACPI_UUID_LENGTH + 1)) ||\n\t    (vendor->uuid_subtype != info->uuid->subtype) ||\n\t    (memcmp(vendor->uuid, info->uuid->data, ACPI_UUID_LENGTH))) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tbuffer = info->buffer;\n\tstatus = acpi_ut_initialize_buffer(buffer, resource->length);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\tmemcpy(buffer->pointer, resource, resource->length);\n\tbuffer->length = resource->length;\n\n\t \n\n\tinfo->status = AE_OK;\n\treturn (AE_CTRL_TERMINATE);\n}\n\n \n\nacpi_status\nacpi_walk_resource_buffer(struct acpi_buffer *buffer,\n\t\t\t  acpi_walk_resource_callback user_function,\n\t\t\t  void *context)\n{\n\tacpi_status status = AE_OK;\n\tstruct acpi_resource *resource;\n\tstruct acpi_resource *resource_end;\n\n\tACPI_FUNCTION_TRACE(acpi_walk_resource_buffer);\n\n\t \n\n\tif (!buffer || !buffer->pointer || !user_function) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tresource = ACPI_CAST_PTR(struct acpi_resource, buffer->pointer);\n\tresource_end =\n\t    ACPI_ADD_PTR(struct acpi_resource, buffer->pointer, buffer->length);\n\n\t \n\n\twhile (resource < resource_end) {\n\n\t\t \n\n\t\tif (resource->type > ACPI_RESOURCE_TYPE_MAX) {\n\t\t\tstatus = AE_AML_INVALID_RESOURCE_TYPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tif (!resource->length) {\n\t\t\treturn_ACPI_STATUS(AE_AML_BAD_RESOURCE_LENGTH);\n\t\t}\n\n\t\t \n\n\t\tstatus = user_function(resource, context);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tif (status == AE_CTRL_TERMINATE) {\n\n\t\t\t\t \n\n\t\t\t\tstatus = AE_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tif (resource->type == ACPI_RESOURCE_TYPE_END_TAG) {\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tresource = ACPI_NEXT_RESOURCE(resource);\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_walk_resource_buffer)\n\n \nacpi_status\nacpi_walk_resources(acpi_handle device_handle,\n\t\t    char *name,\n\t\t    acpi_walk_resource_callback user_function, void *context)\n{\n\tacpi_status status;\n\tstruct acpi_buffer buffer;\n\n\tACPI_FUNCTION_TRACE(acpi_walk_resources);\n\n\t \n\n\tif (!device_handle || !user_function || !name ||\n\t    (!ACPI_COMPARE_NAMESEG(name, METHOD_NAME__CRS) &&\n\t     !ACPI_COMPARE_NAMESEG(name, METHOD_NAME__PRS) &&\n\t     !ACPI_COMPARE_NAMESEG(name, METHOD_NAME__AEI) &&\n\t     !ACPI_COMPARE_NAMESEG(name, METHOD_NAME__DMA))) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\tstatus = acpi_rs_get_method_data(device_handle, name, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tstatus = acpi_walk_resource_buffer(&buffer, user_function, context);\n\tACPI_FREE(buffer.pointer);\n\treturn_ACPI_STATUS(status);\n}\n\nACPI_EXPORT_SYMBOL(acpi_walk_resources)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}