{
  "module_name": "acevents.h",
  "hash_id": "1ca17fda27de107a5423af0f70991f108c85c681be0083f70d5eac02e202754a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/acevents.h",
  "human_readable_source": " \n \n\n#ifndef __ACEVENTS_H__\n#define __ACEVENTS_H__\n\n \n#ifdef ACPI_USE_GPE_POLLING\n#define ACPI_GPE_IS_POLLING_NEEDED(__gpe__)             \\\n\t((__gpe__)->runtime_count == 1 &&                   \\\n\t (__gpe__)->flags & ACPI_GPE_INITIALIZED &&         \\\n\t ((__gpe__)->flags & ACPI_GPE_XRUPT_TYPE_MASK) == ACPI_GPE_EDGE_TRIGGERED)\n#else\n#define ACPI_GPE_IS_POLLING_NEEDED(__gpe__)             FALSE\n#endif\n\n \nacpi_status acpi_ev_initialize_events(void);\n\nacpi_status acpi_ev_install_xrupt_handlers(void);\n\nu32 acpi_ev_fixed_event_detect(void);\n\n \nu8 acpi_ev_is_notify_object(struct acpi_namespace_node *node);\n\nu32 acpi_ev_get_gpe_number_index(u32 gpe_number);\n\nacpi_status\nacpi_ev_queue_notify_request(struct acpi_namespace_node *node,\n\t\t\t     u32 notify_value);\n\n \nacpi_status acpi_ev_init_global_lock_handler(void);\n\nACPI_HW_DEPENDENT_RETURN_OK(acpi_status\n\t\t\t    acpi_ev_acquire_global_lock(u16 timeout))\nACPI_HW_DEPENDENT_RETURN_OK(acpi_status acpi_ev_release_global_lock(void))\n\nacpi_status acpi_ev_remove_global_lock_handler(void);\n\n \nu32 acpi_ev_gpe_detect(struct acpi_gpe_xrupt_info *gpe_xrupt_list);\n\nacpi_status\nacpi_ev_update_gpe_enable_mask(struct acpi_gpe_event_info *gpe_event_info);\n\nacpi_status acpi_ev_enable_gpe(struct acpi_gpe_event_info *gpe_event_info);\n\nacpi_status\nacpi_ev_mask_gpe(struct acpi_gpe_event_info *gpe_event_info, u8 is_masked);\n\nacpi_status\nacpi_ev_add_gpe_reference(struct acpi_gpe_event_info *gpe_event_info,\n\t\t\t  u8 clear_on_enable);\n\nacpi_status\nacpi_ev_remove_gpe_reference(struct acpi_gpe_event_info *gpe_event_info);\n\nstruct acpi_gpe_event_info *acpi_ev_get_gpe_event_info(acpi_handle gpe_device,\n\t\t\t\t\t\t       u32 gpe_number);\n\nstruct acpi_gpe_event_info *acpi_ev_low_get_gpe_info(u32 gpe_number,\n\t\t\t\t\t\t     struct acpi_gpe_block_info\n\t\t\t\t\t\t     *gpe_block);\n\nacpi_status acpi_ev_finish_gpe(struct acpi_gpe_event_info *gpe_event_info);\n\nu32\nacpi_ev_detect_gpe(struct acpi_namespace_node *gpe_device,\n\t\t   struct acpi_gpe_event_info *gpe_event_info, u32 gpe_number);\n\n \nacpi_status\nacpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,\n\t\t\t u64 address,\n\t\t\t u8 space_id,\n\t\t\t u32 register_count,\n\t\t\t u16 gpe_block_base_number,\n\t\t\t u32 interrupt_number,\n\t\t\t struct acpi_gpe_block_info **return_gpe_block);\n\nacpi_status\nacpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\n\t\t\t     struct acpi_gpe_block_info *gpe_block,\n\t\t\t     void *context);\n\nACPI_HW_DEPENDENT_RETURN_OK(acpi_status\n\t\t\t    acpi_ev_delete_gpe_block(struct acpi_gpe_block_info\n\t\t\t\t\t\t     *gpe_block))\n\nu32\nacpi_ev_gpe_dispatch(struct acpi_namespace_node *gpe_device,\n\t\t     struct acpi_gpe_event_info *gpe_event_info,\n\t\t     u32 gpe_number);\n\n \nacpi_status acpi_ev_gpe_initialize(void);\n\nACPI_HW_DEPENDENT_RETURN_VOID(void\n\t\t\t      acpi_ev_update_gpes(acpi_owner_id table_owner_id))\n\nacpi_status\nacpi_ev_match_gpe_method(acpi_handle obj_handle,\n\t\t\t u32 level, void *context, void **return_value);\n\n \nacpi_status\nacpi_ev_walk_gpe_list(acpi_gpe_callback gpe_walk_callback, void *context);\n\nacpi_status\nacpi_ev_get_gpe_device(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\n\t\t       struct acpi_gpe_block_info *gpe_block, void *context);\n\nacpi_status\nacpi_ev_get_gpe_xrupt_block(u32 interrupt_number,\n\t\t\t    struct acpi_gpe_xrupt_info **gpe_xrupt_block);\n\nacpi_status acpi_ev_delete_gpe_xrupt(struct acpi_gpe_xrupt_info *gpe_xrupt);\n\nacpi_status\nacpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\n\t\t\t    struct acpi_gpe_block_info *gpe_block,\n\t\t\t    void *context);\n\n \nunion acpi_operand_object *acpi_ev_find_region_handler(acpi_adr_space_type\n\t\t\t\t\t\t       space_id,\n\t\t\t\t\t\t       union acpi_operand_object\n\t\t\t\t\t\t       *handler_obj);\n\nu8\nacpi_ev_has_default_handler(struct acpi_namespace_node *node,\n\t\t\t    acpi_adr_space_type space_id);\n\nacpi_status acpi_ev_install_region_handlers(void);\n\nacpi_status\nacpi_ev_install_space_handler(struct acpi_namespace_node *node,\n\t\t\t      acpi_adr_space_type space_id,\n\t\t\t      acpi_adr_space_handler handler,\n\t\t\t      acpi_adr_space_setup setup, void *context);\n\n \nacpi_status acpi_ev_initialize_op_regions(void);\n\nacpi_status\nacpi_ev_address_space_dispatch(union acpi_operand_object *region_obj,\n\t\t\t       union acpi_operand_object *field_obj,\n\t\t\t       u32 function,\n\t\t\t       u32 region_offset, u32 bit_width, u64 *value);\n\nacpi_status\nacpi_ev_attach_region(union acpi_operand_object *handler_obj,\n\t\t      union acpi_operand_object *region_obj,\n\t\t      u8 acpi_ns_is_locked);\n\nvoid\nacpi_ev_detach_region(union acpi_operand_object *region_obj,\n\t\t      u8 acpi_ns_is_locked);\n\nvoid\nacpi_ev_execute_reg_methods(struct acpi_namespace_node *node,\n\t\t\t    acpi_adr_space_type space_id, u32 function);\n\nacpi_status\nacpi_ev_execute_reg_method(union acpi_operand_object *region_obj, u32 function);\n\n \nacpi_status\nacpi_ev_system_memory_region_setup(acpi_handle handle,\n\t\t\t\t   u32 function,\n\t\t\t\t   void *handler_context,\n\t\t\t\t   void **region_context);\n\nacpi_status\nacpi_ev_io_space_region_setup(acpi_handle handle,\n\t\t\t      u32 function,\n\t\t\t      void *handler_context, void **region_context);\n\nacpi_status\nacpi_ev_pci_config_region_setup(acpi_handle handle,\n\t\t\t\tu32 function,\n\t\t\t\tvoid *handler_context, void **region_context);\n\nacpi_status\nacpi_ev_cmos_region_setup(acpi_handle handle,\n\t\t\t  u32 function,\n\t\t\t  void *handler_context, void **region_context);\n\nacpi_status\nacpi_ev_pci_bar_region_setup(acpi_handle handle,\n\t\t\t     u32 function,\n\t\t\t     void *handler_context, void **region_context);\n\nacpi_status\nacpi_ev_data_table_region_setup(acpi_handle handle,\n\t\t\t\tu32 function,\n\t\t\t\tvoid *handler_context, void **region_context);\n\nacpi_status\nacpi_ev_default_region_setup(acpi_handle handle,\n\t\t\t     u32 function,\n\t\t\t     void *handler_context, void **region_context);\n\nacpi_status acpi_ev_initialize_region(union acpi_operand_object *region_obj);\n\nu8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node);\n\n \nu32 ACPI_SYSTEM_XFACE acpi_ev_gpe_xrupt_handler(void *context);\n\nu32 acpi_ev_sci_dispatch(void);\n\nu32 acpi_ev_install_sci_handler(void);\n\nacpi_status acpi_ev_remove_all_sci_handlers(void);\n\nACPI_HW_DEPENDENT_RETURN_VOID(void acpi_ev_terminate(void))\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}