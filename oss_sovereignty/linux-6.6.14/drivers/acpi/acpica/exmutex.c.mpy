{
  "module_name": "exmutex.c",
  "hash_id": "3b7c7db62eb0ab057478a7680786f3677809d10947dbc84928e7dfdf982f9dd3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/exmutex.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acinterp.h\"\n#include \"acevents.h\"\n\n#define _COMPONENT          ACPI_EXECUTER\nACPI_MODULE_NAME(\"exmutex\")\n\n \nstatic void\nacpi_ex_link_mutex(union acpi_operand_object *obj_desc,\n\t\t   struct acpi_thread_state *thread);\n\n \n\nvoid acpi_ex_unlink_mutex(union acpi_operand_object *obj_desc)\n{\n\tstruct acpi_thread_state *thread = obj_desc->mutex.owner_thread;\n\n\tif (!thread) {\n\t\treturn;\n\t}\n\n\t \n\n\tif (obj_desc->mutex.next) {\n\t\t(obj_desc->mutex.next)->mutex.prev = obj_desc->mutex.prev;\n\t}\n\n\tif (obj_desc->mutex.prev) {\n\t\t(obj_desc->mutex.prev)->mutex.next = obj_desc->mutex.next;\n\n\t\t \n\t\t(obj_desc->mutex.prev)->mutex.original_sync_level =\n\t\t    obj_desc->mutex.original_sync_level;\n\t} else {\n\t\tthread->acquired_mutex_list = obj_desc->mutex.next;\n\t}\n}\n\n \n\nstatic void\nacpi_ex_link_mutex(union acpi_operand_object *obj_desc,\n\t\t   struct acpi_thread_state *thread)\n{\n\tunion acpi_operand_object *list_head;\n\n\tlist_head = thread->acquired_mutex_list;\n\n\t \n\n\tobj_desc->mutex.prev = NULL;\n\tobj_desc->mutex.next = list_head;\n\n\t \n\n\tif (list_head) {\n\t\tlist_head->mutex.prev = obj_desc;\n\t}\n\n\t \n\n\tthread->acquired_mutex_list = obj_desc;\n}\n\n \n\nacpi_status\nacpi_ex_acquire_mutex_object(u16 timeout,\n\t\t\t     union acpi_operand_object *obj_desc,\n\t\t\t     acpi_thread_id thread_id)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_acquire_mutex_object, obj_desc);\n\n\tif (!obj_desc) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tif (obj_desc->mutex.thread_id == thread_id) {\n\t\t \n\t\tobj_desc->mutex.acquisition_depth++;\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tif (obj_desc == acpi_gbl_global_lock_mutex) {\n\t\tstatus = acpi_ev_acquire_global_lock(timeout);\n\t} else {\n\t\tstatus =\n\t\t    acpi_ex_system_wait_mutex(obj_desc->mutex.os_mutex,\n\t\t\t\t\t      timeout);\n\t}\n\n\tif (ACPI_FAILURE(status)) {\n\n\t\t \n\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tobj_desc->mutex.thread_id = thread_id;\n\tobj_desc->mutex.acquisition_depth = 1;\n\tobj_desc->mutex.original_sync_level = 0;\n\tobj_desc->mutex.owner_thread = NULL;\t \n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ex_acquire_mutex(union acpi_operand_object *time_desc,\n\t\t      union acpi_operand_object *obj_desc,\n\t\t      struct acpi_walk_state *walk_state)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_acquire_mutex, obj_desc);\n\n\tif (!obj_desc) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tif (!walk_state->thread) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Cannot acquire Mutex [%4.4s], null thread info\",\n\t\t\t    acpi_ut_get_node_name(obj_desc->mutex.node)));\n\t\treturn_ACPI_STATUS(AE_AML_INTERNAL);\n\t}\n\n\t \n\tif (walk_state->thread->current_sync_level > obj_desc->mutex.sync_level) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Cannot acquire Mutex [%4.4s], \"\n\t\t\t    \"current SyncLevel is too large (%u)\",\n\t\t\t    acpi_ut_get_node_name(obj_desc->mutex.node),\n\t\t\t    walk_state->thread->current_sync_level));\n\t\treturn_ACPI_STATUS(AE_AML_MUTEX_ORDER);\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t  \"Acquiring: Mutex SyncLevel %u, Thread SyncLevel %u, \"\n\t\t\t  \"Depth %u TID %p\\n\",\n\t\t\t  obj_desc->mutex.sync_level,\n\t\t\t  walk_state->thread->current_sync_level,\n\t\t\t  obj_desc->mutex.acquisition_depth,\n\t\t\t  walk_state->thread));\n\n\tstatus = acpi_ex_acquire_mutex_object((u16)time_desc->integer.value,\n\t\t\t\t\t      obj_desc,\n\t\t\t\t\t      walk_state->thread->thread_id);\n\n\tif (ACPI_SUCCESS(status) && obj_desc->mutex.acquisition_depth == 1) {\n\n\t\t \n\n\t\tobj_desc->mutex.owner_thread = walk_state->thread;\n\t\tobj_desc->mutex.original_sync_level =\n\t\t    walk_state->thread->current_sync_level;\n\t\twalk_state->thread->current_sync_level =\n\t\t    obj_desc->mutex.sync_level;\n\n\t\t \n\n\t\tacpi_ex_link_mutex(obj_desc, walk_state->thread);\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t  \"Acquired: Mutex SyncLevel %u, Thread SyncLevel %u, Depth %u\\n\",\n\t\t\t  obj_desc->mutex.sync_level,\n\t\t\t  walk_state->thread->current_sync_level,\n\t\t\t  obj_desc->mutex.acquisition_depth));\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ex_release_mutex_object(union acpi_operand_object *obj_desc)\n{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(ex_release_mutex_object);\n\n\tif (obj_desc->mutex.acquisition_depth == 0) {\n\t\treturn_ACPI_STATUS(AE_NOT_ACQUIRED);\n\t}\n\n\t \n\n\tobj_desc->mutex.acquisition_depth--;\n\tif (obj_desc->mutex.acquisition_depth != 0) {\n\n\t\t \n\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\tif (obj_desc->mutex.owner_thread) {\n\n\t\t \n\n\t\tacpi_ex_unlink_mutex(obj_desc);\n\t\tobj_desc->mutex.owner_thread = NULL;\n\t}\n\n\t \n\n\tif (obj_desc == acpi_gbl_global_lock_mutex) {\n\t\tstatus = acpi_ev_release_global_lock();\n\t} else {\n\t\tacpi_os_release_mutex(obj_desc->mutex.os_mutex);\n\t}\n\n\t \n\n\tobj_desc->mutex.thread_id = 0;\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ex_release_mutex(union acpi_operand_object *obj_desc,\n\t\t      struct acpi_walk_state *walk_state)\n{\n\tu8 previous_sync_level;\n\tstruct acpi_thread_state *owner_thread;\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(ex_release_mutex);\n\n\tif (!obj_desc) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\towner_thread = obj_desc->mutex.owner_thread;\n\n\t \n\n\tif (!owner_thread) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Cannot release Mutex [%4.4s], not acquired\",\n\t\t\t    acpi_ut_get_node_name(obj_desc->mutex.node)));\n\t\treturn_ACPI_STATUS(AE_AML_MUTEX_NOT_ACQUIRED);\n\t}\n\n\t \n\n\tif (!walk_state->thread) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Cannot release Mutex [%4.4s], null thread info\",\n\t\t\t    acpi_ut_get_node_name(obj_desc->mutex.node)));\n\t\treturn_ACPI_STATUS(AE_AML_INTERNAL);\n\t}\n\n\t \n\tif ((owner_thread->thread_id != walk_state->thread->thread_id) &&\n\t    (obj_desc != acpi_gbl_global_lock_mutex)) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Thread %u cannot release Mutex [%4.4s] acquired by thread %u\",\n\t\t\t    (u32)walk_state->thread->thread_id,\n\t\t\t    acpi_ut_get_node_name(obj_desc->mutex.node),\n\t\t\t    (u32)owner_thread->thread_id));\n\t\treturn_ACPI_STATUS(AE_AML_NOT_OWNER);\n\t}\n\n\t \n\tif (obj_desc->mutex.sync_level != owner_thread->current_sync_level) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Cannot release Mutex [%4.4s], SyncLevel mismatch: \"\n\t\t\t    \"mutex %u current %u\",\n\t\t\t    acpi_ut_get_node_name(obj_desc->mutex.node),\n\t\t\t    obj_desc->mutex.sync_level,\n\t\t\t    walk_state->thread->current_sync_level));\n\t\treturn_ACPI_STATUS(AE_AML_MUTEX_ORDER);\n\t}\n\n\t \n\tprevious_sync_level =\n\t    owner_thread->acquired_mutex_list->mutex.original_sync_level;\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t  \"Releasing: Object SyncLevel %u, Thread SyncLevel %u, \"\n\t\t\t  \"Prev SyncLevel %u, Depth %u TID %p\\n\",\n\t\t\t  obj_desc->mutex.sync_level,\n\t\t\t  walk_state->thread->current_sync_level,\n\t\t\t  previous_sync_level,\n\t\t\t  obj_desc->mutex.acquisition_depth,\n\t\t\t  walk_state->thread));\n\n\tstatus = acpi_ex_release_mutex_object(obj_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tif (obj_desc->mutex.acquisition_depth == 0) {\n\n\t\t \n\n\t\towner_thread->current_sync_level = previous_sync_level;\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t  \"Released: Object SyncLevel %u, Thread SyncLevel, %u, \"\n\t\t\t  \"Prev SyncLevel %u, Depth %u\\n\",\n\t\t\t  obj_desc->mutex.sync_level,\n\t\t\t  walk_state->thread->current_sync_level,\n\t\t\t  previous_sync_level,\n\t\t\t  obj_desc->mutex.acquisition_depth));\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nvoid acpi_ex_release_all_mutexes(struct acpi_thread_state *thread)\n{\n\tunion acpi_operand_object *next = thread->acquired_mutex_list;\n\tunion acpi_operand_object *obj_desc;\n\n\tACPI_FUNCTION_TRACE(ex_release_all_mutexes);\n\n\t \n\n\twhile (next) {\n\t\tobj_desc = next;\n\t\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t\t  \"Mutex [%4.4s] force-release, SyncLevel %u Depth %u\\n\",\n\t\t\t\t  obj_desc->mutex.node->name.ascii,\n\t\t\t\t  obj_desc->mutex.sync_level,\n\t\t\t\t  obj_desc->mutex.acquisition_depth));\n\n\t\t \n\n\t\tif (obj_desc == acpi_gbl_global_lock_mutex) {\n\n\t\t\t \n\n\t\t\t(void)acpi_ev_release_global_lock();\n\t\t} else {\n\t\t\tacpi_os_release_mutex(obj_desc->mutex.os_mutex);\n\t\t}\n\n\t\t \n\n\t\tthread->current_sync_level =\n\t\t    obj_desc->mutex.original_sync_level;\n\n\t\t \n\n\t\tnext = obj_desc->mutex.next;\n\n\t\tobj_desc->mutex.prev = NULL;\n\t\tobj_desc->mutex.next = NULL;\n\t\tobj_desc->mutex.acquisition_depth = 0;\n\t\tobj_desc->mutex.owner_thread = NULL;\n\t\tobj_desc->mutex.thread_id = 0;\n\t}\n\n\treturn_VOID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}