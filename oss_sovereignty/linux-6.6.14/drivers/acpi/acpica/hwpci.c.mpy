{
  "module_name": "hwpci.c",
  "hash_id": "2adfda73c758817d50b1caabbedaa444b090dffcdcc1d47dba3aeaf04ab4b5b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/hwpci.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\nACPI_MODULE_NAME(\"hwpci\")\n\n \n#define PCI_CFG_HEADER_TYPE_REG             0x0E\n#define PCI_CFG_PRIMARY_BUS_NUMBER_REG      0x18\n#define PCI_CFG_SECONDARY_BUS_NUMBER_REG    0x19\n \n#define PCI_HEADER_TYPE_MASK                0x7F\n#define PCI_TYPE_BRIDGE                     0x01\n#define PCI_TYPE_CARDBUS_BRIDGE             0x02\ntypedef struct acpi_pci_device {\n\tacpi_handle device;\n\tstruct acpi_pci_device *next;\n\n} acpi_pci_device;\n\n \n\nstatic acpi_status\nacpi_hw_build_pci_list(acpi_handle root_pci_device,\n\t\t       acpi_handle pci_region,\n\t\t       struct acpi_pci_device **return_list_head);\n\nstatic acpi_status\nacpi_hw_process_pci_list(struct acpi_pci_id *pci_id,\n\t\t\t struct acpi_pci_device *list_head);\n\nstatic void acpi_hw_delete_pci_list(struct acpi_pci_device *list_head);\n\nstatic acpi_status\nacpi_hw_get_pci_device_info(struct acpi_pci_id *pci_id,\n\t\t\t    acpi_handle pci_device,\n\t\t\t    u16 *bus_number, u8 *is_bridge);\n\n \n\nacpi_status\nacpi_hw_derive_pci_id(struct acpi_pci_id *pci_id,\n\t\t      acpi_handle root_pci_device, acpi_handle pci_region)\n{\n\tacpi_status status;\n\tstruct acpi_pci_device *list_head;\n\n\tACPI_FUNCTION_TRACE(hw_derive_pci_id);\n\n\tif (!pci_id) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tstatus =\n\t    acpi_hw_build_pci_list(root_pci_device, pci_region, &list_head);\n\tif (ACPI_SUCCESS(status)) {\n\n\t\t \n\n\t\tstatus = acpi_hw_process_pci_list(pci_id, list_head);\n\n\t\t \n\n\t\tacpi_hw_delete_pci_list(list_head);\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic acpi_status\nacpi_hw_build_pci_list(acpi_handle root_pci_device,\n\t\t       acpi_handle pci_region,\n\t\t       struct acpi_pci_device **return_list_head)\n{\n\tacpi_handle current_device;\n\tacpi_handle parent_device;\n\tacpi_status status;\n\tstruct acpi_pci_device *list_element;\n\n\t \n\t*return_list_head = NULL;\n\tcurrent_device = pci_region;\n\twhile (1) {\n\t\tstatus = acpi_get_parent(current_device, &parent_device);\n\t\tif (ACPI_FAILURE(status)) {\n\n\t\t\t \n\n\t\t\tacpi_hw_delete_pci_list(*return_list_head);\n\t\t\treturn (status);\n\t\t}\n\n\t\t \n\n\t\tif (parent_device == root_pci_device) {\n\t\t\treturn (AE_OK);\n\t\t}\n\n\t\tlist_element = ACPI_ALLOCATE(sizeof(struct acpi_pci_device));\n\t\tif (!list_element) {\n\n\t\t\t \n\n\t\t\tacpi_hw_delete_pci_list(*return_list_head);\n\t\t\treturn (AE_NO_MEMORY);\n\t\t}\n\n\t\t \n\n\t\tlist_element->next = *return_list_head;\n\t\tlist_element->device = parent_device;\n\t\t*return_list_head = list_element;\n\n\t\tcurrent_device = parent_device;\n\t}\n}\n\n \n\nstatic acpi_status\nacpi_hw_process_pci_list(struct acpi_pci_id *pci_id,\n\t\t\t struct acpi_pci_device *list_head)\n{\n\tacpi_status status = AE_OK;\n\tstruct acpi_pci_device *info;\n\tu16 bus_number;\n\tu8 is_bridge = TRUE;\n\n\tACPI_FUNCTION_NAME(hw_process_pci_list);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t  \"Input PciId:  Seg %4.4X Bus %4.4X Dev %4.4X Func %4.4X\\n\",\n\t\t\t  pci_id->segment, pci_id->bus, pci_id->device,\n\t\t\t  pci_id->function));\n\n\tbus_number = pci_id->bus;\n\n\t \n\tinfo = list_head;\n\twhile (info) {\n\t\tstatus = acpi_hw_get_pci_device_info(pci_id, info->device,\n\t\t\t\t\t\t     &bus_number, &is_bridge);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\n\t\tinfo = info->next;\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t  \"Output PciId: Seg %4.4X Bus %4.4X Dev %4.4X Func %4.4X \"\n\t\t\t  \"Status %X BusNumber %X IsBridge %X\\n\",\n\t\t\t  pci_id->segment, pci_id->bus, pci_id->device,\n\t\t\t  pci_id->function, status, bus_number, is_bridge));\n\n\treturn (AE_OK);\n}\n\n \n\nstatic void acpi_hw_delete_pci_list(struct acpi_pci_device *list_head)\n{\n\tstruct acpi_pci_device *next;\n\tstruct acpi_pci_device *previous;\n\n\tnext = list_head;\n\twhile (next) {\n\t\tprevious = next;\n\t\tnext = previous->next;\n\t\tACPI_FREE(previous);\n\t}\n}\n\n \n\nstatic acpi_status\nacpi_hw_get_pci_device_info(struct acpi_pci_id *pci_id,\n\t\t\t    acpi_handle pci_device,\n\t\t\t    u16 *bus_number, u8 *is_bridge)\n{\n\tacpi_status status;\n\tacpi_object_type object_type;\n\tu64 return_value;\n\tu64 pci_value;\n\n\t \n\n\tstatus = acpi_get_type(pci_device, &object_type);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tif (object_type != ACPI_TYPE_DEVICE) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tstatus = acpi_ut_evaluate_numeric_object(METHOD_NAME__ADR,\n\t\t\t\t\t\t pci_device, &return_value);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\tpci_id->device = ACPI_HIWORD(ACPI_LODWORD(return_value));\n\tpci_id->function = ACPI_LOWORD(ACPI_LODWORD(return_value));\n\n\t \n\tif (*is_bridge) {\n\t\tpci_id->bus = *bus_number;\n\t}\n\n\t \n\t*is_bridge = FALSE;\n\tstatus = acpi_os_read_pci_configuration(pci_id,\n\t\t\t\t\t\tPCI_CFG_HEADER_TYPE_REG,\n\t\t\t\t\t\t&pci_value, 8);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\tpci_value &= PCI_HEADER_TYPE_MASK;\n\n\tif ((pci_value != PCI_TYPE_BRIDGE) &&\n\t    (pci_value != PCI_TYPE_CARDBUS_BRIDGE)) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tstatus = acpi_os_read_pci_configuration(pci_id,\n\t\t\t\t\t\tPCI_CFG_PRIMARY_BUS_NUMBER_REG,\n\t\t\t\t\t\t&pci_value, 8);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t*is_bridge = TRUE;\n\tpci_id->bus = (u16)pci_value;\n\n\t \n\n\tstatus = acpi_os_read_pci_configuration(pci_id,\n\t\t\t\t\t\tPCI_CFG_SECONDARY_BUS_NUMBER_REG,\n\t\t\t\t\t\t&pci_value, 8);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t*bus_number = (u16)pci_value;\n\treturn (AE_OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}