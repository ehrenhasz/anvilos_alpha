{
  "module_name": "evsci.c",
  "hash_id": "b4ec4ee949090b7bbc300f8b3817fd2af90a5b6b1e291ddb260984848e617a2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evsci.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evsci\")\n#if (!ACPI_REDUCED_HARDWARE)\t \n \nstatic u32 ACPI_SYSTEM_XFACE acpi_ev_sci_xrupt_handler(void *context);\n\n \n\nu32 acpi_ev_sci_dispatch(void)\n{\n\tstruct acpi_sci_handler_info *sci_handler;\n\tacpi_cpu_flags flags;\n\tu32 int_status = ACPI_INTERRUPT_NOT_HANDLED;\n\n\tACPI_FUNCTION_NAME(ev_sci_dispatch);\n\n\t \n\n\tif (!acpi_gbl_sci_handler_list) {\n\t\treturn (int_status);\n\t}\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\tsci_handler = acpi_gbl_sci_handler_list;\n\twhile (sci_handler) {\n\n\t\t \n\n\t\tint_status |= sci_handler->address(sci_handler->context);\n\n\t\tsci_handler = sci_handler->next;\n\t}\n\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn (int_status);\n}\n\n \n\nstatic u32 ACPI_SYSTEM_XFACE acpi_ev_sci_xrupt_handler(void *context)\n{\n\tstruct acpi_gpe_xrupt_info *gpe_xrupt_list = context;\n\tu32 interrupt_handled = ACPI_INTERRUPT_NOT_HANDLED;\n\n\tACPI_FUNCTION_TRACE(ev_sci_xrupt_handler);\n\n\t \n\n\t \n\tinterrupt_handled |= acpi_ev_fixed_event_detect();\n\n\t \n\tinterrupt_handled |= acpi_ev_gpe_detect(gpe_xrupt_list);\n\n\t \n\n\tinterrupt_handled |= acpi_ev_sci_dispatch();\n\n\tacpi_sci_count++;\n\treturn_UINT32(interrupt_handled);\n}\n\n \n\nu32 ACPI_SYSTEM_XFACE acpi_ev_gpe_xrupt_handler(void *context)\n{\n\tstruct acpi_gpe_xrupt_info *gpe_xrupt_list = context;\n\tu32 interrupt_handled = ACPI_INTERRUPT_NOT_HANDLED;\n\n\tACPI_FUNCTION_TRACE(ev_gpe_xrupt_handler);\n\n\t \n\n\t \n\n\tinterrupt_handled |= acpi_ev_gpe_detect(gpe_xrupt_list);\n\treturn_UINT32(interrupt_handled);\n}\n\n \n\nu32 acpi_ev_install_sci_handler(void)\n{\n\tu32 status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(ev_install_sci_handler);\n\n\tstatus =\n\t    acpi_os_install_interrupt_handler((u32) acpi_gbl_FADT.sci_interrupt,\n\t\t\t\t\t      acpi_ev_sci_xrupt_handler,\n\t\t\t\t\t      acpi_gbl_gpe_xrupt_list_head);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ev_remove_all_sci_handlers(void)\n{\n\tstruct acpi_sci_handler_info *sci_handler;\n\tacpi_cpu_flags flags;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ev_remove_all_sci_handlers);\n\n\t \n\n\tstatus =\n\t    acpi_os_remove_interrupt_handler((u32) acpi_gbl_FADT.sci_interrupt,\n\t\t\t\t\t     acpi_ev_sci_xrupt_handler);\n\n\tif (!acpi_gbl_sci_handler_list) {\n\t\treturn (status);\n\t}\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\twhile (acpi_gbl_sci_handler_list) {\n\t\tsci_handler = acpi_gbl_sci_handler_list;\n\t\tacpi_gbl_sci_handler_list = sci_handler->next;\n\t\tACPI_FREE(sci_handler);\n\t}\n\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn_ACPI_STATUS(status);\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}