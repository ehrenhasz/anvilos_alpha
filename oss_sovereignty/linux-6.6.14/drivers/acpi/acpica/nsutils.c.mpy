{
  "module_name": "nsutils.c",
  "hash_id": "f6655cbb67d5437f2b6a53b41f29dfa79c00a3f993e4850cddd6c61e271fb1ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/nsutils.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"amlcode.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\nACPI_MODULE_NAME(\"nsutils\")\n\n \n#ifdef ACPI_OBSOLETE_FUNCTIONS\nacpi_name acpi_ns_find_parent_name(struct acpi_namespace_node *node_to_search);\n#endif\n\n \n\nvoid\nacpi_ns_print_node_pathname(struct acpi_namespace_node *node,\n\t\t\t    const char *message)\n{\n\tstruct acpi_buffer buffer;\n\tacpi_status status;\n\n\tif (!node) {\n\t\tacpi_os_printf(\"[NULL NAME]\");\n\t\treturn;\n\t}\n\n\t \n\n\tbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\n\tstatus = acpi_ns_handle_to_pathname(node, &buffer, TRUE);\n\tif (ACPI_SUCCESS(status)) {\n\t\tif (message) {\n\t\t\tacpi_os_printf(\"%s \", message);\n\t\t}\n\n\t\tacpi_os_printf(\"%s\", (char *)buffer.pointer);\n\t\tACPI_FREE(buffer.pointer);\n\t}\n}\n\n \n\nacpi_object_type acpi_ns_get_type(struct acpi_namespace_node * node)\n{\n\tACPI_FUNCTION_TRACE(ns_get_type);\n\n\tif (!node) {\n\t\tACPI_WARNING((AE_INFO, \"Null Node parameter\"));\n\t\treturn_UINT8(ACPI_TYPE_ANY);\n\t}\n\n\treturn_UINT8(node->type);\n}\n\n \n\nu32 acpi_ns_local(acpi_object_type type)\n{\n\tACPI_FUNCTION_TRACE(ns_local);\n\n\tif (!acpi_ut_valid_object_type(type)) {\n\n\t\t \n\n\t\tACPI_WARNING((AE_INFO, \"Invalid Object Type 0x%X\", type));\n\t\treturn_UINT32(ACPI_NS_NORMAL);\n\t}\n\n\treturn_UINT32(acpi_gbl_ns_properties[type] & ACPI_NS_LOCAL);\n}\n\n \n\nvoid acpi_ns_get_internal_name_length(struct acpi_namestring_info *info)\n{\n\tconst char *next_external_char;\n\tu32 i;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tnext_external_char = info->external_name;\n\tinfo->num_carats = 0;\n\tinfo->num_segments = 0;\n\tinfo->fully_qualified = FALSE;\n\n\t \n\tif (ACPI_IS_ROOT_PREFIX(*next_external_char)) {\n\t\tinfo->fully_qualified = TRUE;\n\t\tnext_external_char++;\n\n\t\t \n\n\t\twhile (ACPI_IS_ROOT_PREFIX(*next_external_char)) {\n\t\t\tnext_external_char++;\n\t\t}\n\t} else {\n\t\t \n\n\t\twhile (ACPI_IS_PARENT_PREFIX(*next_external_char)) {\n\t\t\tinfo->num_carats++;\n\t\t\tnext_external_char++;\n\t\t}\n\t}\n\n\t \n\tif (*next_external_char) {\n\t\tinfo->num_segments = 1;\n\t\tfor (i = 0; next_external_char[i]; i++) {\n\t\t\tif (ACPI_IS_PATH_SEPARATOR(next_external_char[i])) {\n\t\t\t\tinfo->num_segments++;\n\t\t\t}\n\t\t}\n\t}\n\n\tinfo->length = (ACPI_NAMESEG_SIZE * info->num_segments) +\n\t    4 + info->num_carats;\n\n\tinfo->next_external_char = next_external_char;\n}\n\n \n\nacpi_status acpi_ns_build_internal_name(struct acpi_namestring_info *info)\n{\n\tu32 num_segments = info->num_segments;\n\tchar *internal_name = info->internal_name;\n\tconst char *external_name = info->next_external_char;\n\tchar *result = NULL;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ns_build_internal_name);\n\n\t \n\n\tif (info->fully_qualified) {\n\t\tinternal_name[0] = AML_ROOT_PREFIX;\n\n\t\tif (num_segments <= 1) {\n\t\t\tresult = &internal_name[1];\n\t\t} else if (num_segments == 2) {\n\t\t\tinternal_name[1] = AML_DUAL_NAME_PREFIX;\n\t\t\tresult = &internal_name[2];\n\t\t} else {\n\t\t\tinternal_name[1] = AML_MULTI_NAME_PREFIX;\n\t\t\tinternal_name[2] = (char)num_segments;\n\t\t\tresult = &internal_name[3];\n\t\t}\n\t} else {\n\t\t \n\t\ti = 0;\n\t\tif (info->num_carats) {\n\t\t\tfor (i = 0; i < info->num_carats; i++) {\n\t\t\t\tinternal_name[i] = AML_PARENT_PREFIX;\n\t\t\t}\n\t\t}\n\n\t\tif (num_segments <= 1) {\n\t\t\tresult = &internal_name[i];\n\t\t} else if (num_segments == 2) {\n\t\t\tinternal_name[i] = AML_DUAL_NAME_PREFIX;\n\t\t\tresult = &internal_name[(acpi_size)i + 1];\n\t\t} else {\n\t\t\tinternal_name[i] = AML_MULTI_NAME_PREFIX;\n\t\t\tinternal_name[(acpi_size)i + 1] = (char)num_segments;\n\t\t\tresult = &internal_name[(acpi_size)i + 2];\n\t\t}\n\t}\n\n\t \n\n\tfor (; num_segments; num_segments--) {\n\t\tfor (i = 0; i < ACPI_NAMESEG_SIZE; i++) {\n\t\t\tif (ACPI_IS_PATH_SEPARATOR(*external_name) ||\n\t\t\t    (*external_name == 0)) {\n\n\t\t\t\t \n\n\t\t\t\tresult[i] = '_';\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\tresult[i] = (char)toupper((int)*external_name);\n\t\t\t\texternal_name++;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (!ACPI_IS_PATH_SEPARATOR(*external_name) &&\n\t\t    (*external_name != 0)) {\n\t\t\treturn_ACPI_STATUS(AE_BAD_PATHNAME);\n\t\t}\n\n\t\t \n\n\t\texternal_name++;\n\t\tresult += ACPI_NAMESEG_SIZE;\n\t}\n\n\t \n\n\t*result = 0;\n\n\tif (info->fully_qualified) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t\t  \"Returning [%p] (abs) \\\"\\\\%s\\\"\\n\",\n\t\t\t\t  internal_name, internal_name));\n\t} else {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_EXEC, \"Returning [%p] (rel) \\\"%s\\\"\\n\",\n\t\t\t\t  internal_name, internal_name));\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ns_internalize_name(const char *external_name, char **converted_name)\n{\n\tchar *internal_name;\n\tstruct acpi_namestring_info info;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ns_internalize_name);\n\n\tif ((!external_name) || (*external_name == 0) || (!converted_name)) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tinfo.external_name = external_name;\n\tacpi_ns_get_internal_name_length(&info);\n\n\t \n\n\tinternal_name = ACPI_ALLOCATE_ZEROED(info.length);\n\tif (!internal_name) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tinfo.internal_name = internal_name;\n\tstatus = acpi_ns_build_internal_name(&info);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_FREE(internal_name);\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t*converted_name = internal_name;\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ns_externalize_name(u32 internal_name_length,\n\t\t\t const char *internal_name,\n\t\t\t u32 * converted_name_length, char **converted_name)\n{\n\tu32 names_index = 0;\n\tu32 num_segments = 0;\n\tu32 required_length;\n\tu32 prefix_length = 0;\n\tu32 i = 0;\n\tu32 j = 0;\n\n\tACPI_FUNCTION_TRACE(ns_externalize_name);\n\n\tif (!internal_name_length || !internal_name || !converted_name) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tswitch (internal_name[0]) {\n\tcase AML_ROOT_PREFIX:\n\n\t\tprefix_length = 1;\n\t\tbreak;\n\n\tcase AML_PARENT_PREFIX:\n\n\t\tfor (i = 0; i < internal_name_length; i++) {\n\t\t\tif (ACPI_IS_PARENT_PREFIX(internal_name[i])) {\n\t\t\t\tprefix_length = i + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == internal_name_length) {\n\t\t\tprefix_length = i;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\n\t\tbreak;\n\t}\n\n\t \n\tif (prefix_length < internal_name_length) {\n\t\tswitch (internal_name[prefix_length]) {\n\t\tcase AML_MULTI_NAME_PREFIX:\n\n\t\t\t \n\n\t\t\tnames_index = prefix_length + 2;\n\t\t\tnum_segments = (u8)\n\t\t\t    internal_name[(acpi_size)prefix_length + 1];\n\t\t\tbreak;\n\n\t\tcase AML_DUAL_NAME_PREFIX:\n\n\t\t\t \n\n\t\t\tnames_index = prefix_length + 1;\n\t\t\tnum_segments = 2;\n\t\t\tbreak;\n\n\t\tcase 0:\n\n\t\t\t \n\n\t\t\tnames_index = 0;\n\t\t\tnum_segments = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\t \n\n\t\t\tnames_index = prefix_length;\n\t\t\tnum_segments = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\trequired_length = prefix_length + (4 * num_segments) +\n\t    ((num_segments > 0) ? (num_segments - 1) : 0) + 1;\n\n\t \n\tif (required_length > internal_name_length) {\n\t\tACPI_ERROR((AE_INFO, \"Invalid internal name\"));\n\t\treturn_ACPI_STATUS(AE_BAD_PATHNAME);\n\t}\n\n\t \n\n\t*converted_name = ACPI_ALLOCATE_ZEROED(required_length);\n\tif (!(*converted_name)) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tj = 0;\n\n\tfor (i = 0; i < prefix_length; i++) {\n\t\t(*converted_name)[j++] = internal_name[i];\n\t}\n\n\tif (num_segments > 0) {\n\t\tfor (i = 0; i < num_segments; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\t(*converted_name)[j++] = '.';\n\t\t\t}\n\n\t\t\t \n\n\t\t\tACPI_COPY_NAMESEG(&(*converted_name)[j],\n\t\t\t\t\t  &internal_name[names_index]);\n\t\t\tacpi_ut_repair_name(&(*converted_name)[j]);\n\n\t\t\tj += ACPI_NAMESEG_SIZE;\n\t\t\tnames_index += ACPI_NAMESEG_SIZE;\n\t\t}\n\t}\n\n\tif (converted_name_length) {\n\t\t*converted_name_length = (u32) required_length;\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nstruct acpi_namespace_node *acpi_ns_validate_handle(acpi_handle handle)\n{\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tif ((!handle) || (handle == ACPI_ROOT_OBJECT)) {\n\t\treturn (acpi_gbl_root_node);\n\t}\n\n\t \n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(handle) != ACPI_DESC_TYPE_NAMED) {\n\t\treturn (NULL);\n\t}\n\n\treturn (ACPI_CAST_PTR(struct acpi_namespace_node, handle));\n}\n\n \n\nvoid acpi_ns_terminate(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ns_terminate);\n\n\t \n\tacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\n\n\t \n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_VOID;\n\t}\n\n\tacpi_ns_delete_node(acpi_gbl_root_node);\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO, \"Namespace freed\\n\"));\n\treturn_VOID;\n}\n\n \n\nu32 acpi_ns_opens_scope(acpi_object_type type)\n{\n\tACPI_FUNCTION_ENTRY();\n\n\tif (type > ACPI_TYPE_LOCAL_MAX) {\n\n\t\t \n\n\t\tACPI_WARNING((AE_INFO, \"Invalid Object Type 0x%X\", type));\n\t\treturn (ACPI_NS_NORMAL);\n\t}\n\n\treturn (((u32)acpi_gbl_ns_properties[type]) & ACPI_NS_NEWSCOPE);\n}\n\n \n\nacpi_status\nacpi_ns_get_node_unlocked(struct acpi_namespace_node *prefix_node,\n\t\t\t  const char *pathname,\n\t\t\t  u32 flags, struct acpi_namespace_node **return_node)\n{\n\tunion acpi_generic_state scope_info;\n\tacpi_status status;\n\tchar *internal_path;\n\n\tACPI_FUNCTION_TRACE_PTR(ns_get_node_unlocked,\n\t\t\t\tACPI_CAST_PTR(char, pathname));\n\n\t \n\n\tif (!pathname) {\n\t\t*return_node = prefix_node;\n\t\tif (!prefix_node) {\n\t\t\t*return_node = acpi_gbl_root_node;\n\t\t}\n\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tif (ACPI_IS_ROOT_PREFIX(pathname[0]) && (!pathname[1])) {\n\t\t*return_node = acpi_gbl_root_node;\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tstatus = acpi_ns_internalize_name(pathname, &internal_path);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tscope_info.scope.node = prefix_node;\n\n\t \n\n\tstatus = acpi_ns_lookup(&scope_info, internal_path, ACPI_TYPE_ANY,\n\t\t\t\tACPI_IMODE_EXECUTE,\n\t\t\t\t(flags | ACPI_NS_DONT_OPEN_SCOPE), NULL,\n\t\t\t\treturn_node);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_EXEC, \"%s, %s\\n\",\n\t\t\t\t  pathname, acpi_format_exception(status)));\n\t}\n\n\tACPI_FREE(internal_path);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ns_get_node(struct acpi_namespace_node *prefix_node,\n\t\t const char *pathname,\n\t\t u32 flags, struct acpi_namespace_node **return_node)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE_PTR(ns_get_node, ACPI_CAST_PTR(char, pathname));\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tstatus = acpi_ns_get_node_unlocked(prefix_node, pathname,\n\t\t\t\t\t   flags, return_node);\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}