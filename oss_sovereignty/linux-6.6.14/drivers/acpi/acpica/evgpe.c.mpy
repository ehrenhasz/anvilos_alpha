{
  "module_name": "evgpe.c",
  "hash_id": "d69b474ed15904116d052607810f46086e4c02d8e92b42ad7baad4e68027307c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evgpe.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evgpe\")\n#if (!ACPI_REDUCED_HARDWARE)\t \n \nstatic void ACPI_SYSTEM_XFACE acpi_ev_asynch_execute_gpe_method(void *context);\n\nstatic void ACPI_SYSTEM_XFACE acpi_ev_asynch_enable_gpe(void *context);\n\n \n\nacpi_status\nacpi_ev_update_gpe_enable_mask(struct acpi_gpe_event_info *gpe_event_info)\n{\n\tstruct acpi_gpe_register_info *gpe_register_info;\n\tu32 register_bit;\n\n\tACPI_FUNCTION_TRACE(ev_update_gpe_enable_mask);\n\n\tgpe_register_info = gpe_event_info->register_info;\n\tif (!gpe_register_info) {\n\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t}\n\n\tregister_bit = acpi_hw_get_gpe_register_bit(gpe_event_info);\n\n\t \n\n\tACPI_CLEAR_BIT(gpe_register_info->enable_for_run, register_bit);\n\n\t \n\n\tif (gpe_event_info->runtime_count) {\n\t\tACPI_SET_BIT(gpe_register_info->enable_for_run,\n\t\t\t     (u8)register_bit);\n\t}\n\n\tgpe_register_info->enable_mask = gpe_register_info->enable_for_run;\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status acpi_ev_enable_gpe(struct acpi_gpe_event_info *gpe_event_info)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ev_enable_gpe);\n\n\t \n\n\tstatus = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_ENABLE);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ev_mask_gpe(struct acpi_gpe_event_info *gpe_event_info, u8 is_masked)\n{\n\tstruct acpi_gpe_register_info *gpe_register_info;\n\tu32 register_bit;\n\n\tACPI_FUNCTION_TRACE(ev_mask_gpe);\n\n\tgpe_register_info = gpe_event_info->register_info;\n\tif (!gpe_register_info) {\n\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t}\n\n\tregister_bit = acpi_hw_get_gpe_register_bit(gpe_event_info);\n\n\t \n\n\tif (is_masked) {\n\t\tif (register_bit & gpe_register_info->mask_for_run) {\n\t\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t\t}\n\n\t\t(void)acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_DISABLE);\n\t\tACPI_SET_BIT(gpe_register_info->mask_for_run, (u8)register_bit);\n\t} else {\n\t\tif (!(register_bit & gpe_register_info->mask_for_run)) {\n\t\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t\t}\n\n\t\tACPI_CLEAR_BIT(gpe_register_info->mask_for_run,\n\t\t\t       (u8)register_bit);\n\t\tif (gpe_event_info->runtime_count\n\t\t    && !gpe_event_info->disable_for_dispatch) {\n\t\t\t(void)acpi_hw_low_set_gpe(gpe_event_info,\n\t\t\t\t\t\t  ACPI_GPE_ENABLE);\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ev_add_gpe_reference(struct acpi_gpe_event_info *gpe_event_info,\n\t\t\t  u8 clear_on_enable)\n{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(ev_add_gpe_reference);\n\n\tif (gpe_event_info->runtime_count == ACPI_UINT8_MAX) {\n\t\treturn_ACPI_STATUS(AE_LIMIT);\n\t}\n\n\tgpe_event_info->runtime_count++;\n\tif (gpe_event_info->runtime_count == 1) {\n\n\t\t \n\n\t\tif (clear_on_enable) {\n\t\t\t(void)acpi_hw_clear_gpe(gpe_event_info);\n\t\t}\n\n\t\tstatus = acpi_ev_update_gpe_enable_mask(gpe_event_info);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tstatus = acpi_ev_enable_gpe(gpe_event_info);\n\t\t}\n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgpe_event_info->runtime_count--;\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ev_remove_gpe_reference(struct acpi_gpe_event_info *gpe_event_info)\n{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(ev_remove_gpe_reference);\n\n\tif (!gpe_event_info->runtime_count) {\n\t\treturn_ACPI_STATUS(AE_LIMIT);\n\t}\n\n\tgpe_event_info->runtime_count--;\n\tif (!gpe_event_info->runtime_count) {\n\n\t\t \n\n\t\tstatus = acpi_ev_update_gpe_enable_mask(gpe_event_info);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tstatus =\n\t\t\t    acpi_hw_low_set_gpe(gpe_event_info,\n\t\t\t\t\t\tACPI_GPE_DISABLE);\n\t\t}\n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgpe_event_info->runtime_count++;\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstruct acpi_gpe_event_info *acpi_ev_low_get_gpe_info(u32 gpe_number,\n\t\t\t\t\t\t     struct acpi_gpe_block_info\n\t\t\t\t\t\t     *gpe_block)\n{\n\tu32 gpe_index;\n\n\t \n\tif (!gpe_block || (gpe_number < gpe_block->block_base_number)) {\n\t\treturn (NULL);\n\t}\n\n\tgpe_index = gpe_number - gpe_block->block_base_number;\n\tif (gpe_index >= gpe_block->gpe_count) {\n\t\treturn (NULL);\n\t}\n\n\treturn (&gpe_block->event_info[gpe_index]);\n}\n\n\n \n\nstruct acpi_gpe_event_info *acpi_ev_get_gpe_event_info(acpi_handle gpe_device,\n\t\t\t\t\t\t       u32 gpe_number)\n{\n\tunion acpi_operand_object *obj_desc;\n\tstruct acpi_gpe_event_info *gpe_info;\n\tu32 i;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tif (!gpe_device) {\n\n\t\t \n\n\t\tfor (i = 0; i < ACPI_MAX_GPE_BLOCKS; i++) {\n\t\t\tgpe_info = acpi_ev_low_get_gpe_info(gpe_number,\n\t\t\t\t\t\t\t    acpi_gbl_gpe_fadt_blocks\n\t\t\t\t\t\t\t    [i]);\n\t\t\tif (gpe_info) {\n\t\t\t\treturn (gpe_info);\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\treturn (NULL);\n\t}\n\n\t \n\n\tobj_desc =\n\t    acpi_ns_get_attached_object((struct acpi_namespace_node *)\n\t\t\t\t\t       gpe_device);\n\tif (!obj_desc || !obj_desc->device.gpe_block) {\n\t\treturn (NULL);\n\t}\n\n\treturn (acpi_ev_low_get_gpe_info\n\t\t(gpe_number, obj_desc->device.gpe_block));\n}\n\n \n\nu32 acpi_ev_gpe_detect(struct acpi_gpe_xrupt_info *gpe_xrupt_list)\n{\n\tstruct acpi_gpe_block_info *gpe_block;\n\tstruct acpi_namespace_node *gpe_device;\n\tstruct acpi_gpe_register_info *gpe_register_info;\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tu32 gpe_number;\n\tu32 int_status = ACPI_INTERRUPT_NOT_HANDLED;\n\tacpi_cpu_flags flags;\n\tu32 i;\n\tu32 j;\n\n\tACPI_FUNCTION_NAME(ev_gpe_detect);\n\n\t \n\n\tif (!gpe_xrupt_list) {\n\t\treturn (int_status);\n\t}\n\n\t \n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\t \n\n\tgpe_block = gpe_xrupt_list->gpe_block_list_head;\n\twhile (gpe_block) {\n\t\tgpe_device = gpe_block->node;\n\n\t\t \n\t\tfor (i = 0; i < gpe_block->register_count; i++) {\n\n\t\t\t \n\n\t\t\tgpe_register_info = &gpe_block->register_info[i];\n\n\t\t\t \n\t\t\tif (!(gpe_register_info->enable_for_run |\n\t\t\t      gpe_register_info->enable_for_wake)) {\n\t\t\t\tACPI_DEBUG_PRINT((ACPI_DB_INTERRUPTS,\n\t\t\t\t\t\t  \"Ignore disabled registers for GPE %02X-%02X: \"\n\t\t\t\t\t\t  \"RunEnable=%02X, WakeEnable=%02X\\n\",\n\t\t\t\t\t\t  gpe_register_info->\n\t\t\t\t\t\t  base_gpe_number,\n\t\t\t\t\t\t  gpe_register_info->\n\t\t\t\t\t\t  base_gpe_number +\n\t\t\t\t\t\t  (ACPI_GPE_REGISTER_WIDTH - 1),\n\t\t\t\t\t\t  gpe_register_info->\n\t\t\t\t\t\t  enable_for_run,\n\t\t\t\t\t\t  gpe_register_info->\n\t\t\t\t\t\t  enable_for_wake));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tfor (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {\n\n\t\t\t\t \n\n\t\t\t\tgpe_event_info =\n\t\t\t\t    &gpe_block->\n\t\t\t\t    event_info[((acpi_size)i *\n\t\t\t\t\t\tACPI_GPE_REGISTER_WIDTH) + j];\n\t\t\t\tgpe_number =\n\t\t\t\t    j + gpe_register_info->base_gpe_number;\n\t\t\t\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\t\t\t\tint_status |=\n\t\t\t\t    acpi_ev_detect_gpe(gpe_device,\n\t\t\t\t\t\t       gpe_event_info,\n\t\t\t\t\t\t       gpe_number);\n\t\t\t\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\t\t\t}\n\t\t}\n\n\t\tgpe_block = gpe_block->next;\n\t}\n\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn (int_status);\n}\n\n \n\nstatic void ACPI_SYSTEM_XFACE acpi_ev_asynch_execute_gpe_method(void *context)\n{\n\tstruct acpi_gpe_event_info *gpe_event_info = context;\n\tacpi_status status = AE_OK;\n\tstruct acpi_evaluate_info *info;\n\tstruct acpi_gpe_notify_info *notify;\n\n\tACPI_FUNCTION_TRACE(ev_asynch_execute_gpe_method);\n\n\t \n\n\tswitch (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags)) {\n\tcase ACPI_GPE_DISPATCH_NOTIFY:\n\t\t \n\t\tnotify = gpe_event_info->dispatch.notify_list;\n\t\twhile (ACPI_SUCCESS(status) && notify) {\n\t\t\tstatus =\n\t\t\t    acpi_ev_queue_notify_request(notify->device_node,\n\t\t\t\t\t\t\t ACPI_NOTIFY_DEVICE_WAKE);\n\n\t\t\tnotify = notify->next;\n\t\t}\n\n\t\tbreak;\n\n\tcase ACPI_GPE_DISPATCH_METHOD:\n\n\t\t \n\n\t\tinfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\n\t\tif (!info) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t} else {\n\t\t\t \n\t\t\tinfo->prefix_node =\n\t\t\t    gpe_event_info->dispatch.method_node;\n\t\t\tinfo->flags = ACPI_IGNORE_RETURN_VALUE;\n\n\t\t\tstatus = acpi_ns_evaluate(info);\n\t\t\tACPI_FREE(info);\n\t\t}\n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\"while evaluating GPE method [%4.4s]\",\n\t\t\t\t\tacpi_ut_get_node_name(gpe_event_info->\n\t\t\t\t\t\t\t      dispatch.\n\t\t\t\t\t\t\t      method_node)));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\tgoto error_exit;\t \n\t}\n\n\t \n\n\tstatus = acpi_os_execute(OSL_NOTIFY_HANDLER,\n\t\t\t\t acpi_ev_asynch_enable_gpe, gpe_event_info);\n\tif (ACPI_SUCCESS(status)) {\n\t\treturn_VOID;\n\t}\n\nerror_exit:\n\tacpi_ev_asynch_enable_gpe(gpe_event_info);\n\treturn_VOID;\n}\n\n\n \n\nstatic void ACPI_SYSTEM_XFACE acpi_ev_asynch_enable_gpe(void *context)\n{\n\tstruct acpi_gpe_event_info *gpe_event_info = context;\n\tacpi_cpu_flags flags;\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\t(void)acpi_ev_finish_gpe(gpe_event_info);\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\n\treturn;\n}\n\n\n \n\nacpi_status acpi_ev_finish_gpe(struct acpi_gpe_event_info *gpe_event_info)\n{\n\tacpi_status status;\n\n\tif ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) ==\n\t    ACPI_GPE_LEVEL_TRIGGERED) {\n\t\t \n\t\tstatus = acpi_hw_clear_gpe(gpe_event_info);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t}\n\n\t \n\t(void)acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_CONDITIONAL_ENABLE);\n\tgpe_event_info->disable_for_dispatch = FALSE;\n\treturn (AE_OK);\n}\n\n\n \n\nu32\nacpi_ev_detect_gpe(struct acpi_namespace_node *gpe_device,\n\t\t   struct acpi_gpe_event_info *gpe_event_info, u32 gpe_number)\n{\n\tu32 int_status = ACPI_INTERRUPT_NOT_HANDLED;\n\tu8 enabled_status_byte;\n\tu64 status_reg;\n\tu64 enable_reg;\n\tu32 register_bit;\n\tstruct acpi_gpe_register_info *gpe_register_info;\n\tstruct acpi_gpe_handler_info *gpe_handler_info;\n\tacpi_cpu_flags flags;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ev_gpe_detect);\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\tif (!gpe_event_info) {\n\t\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\n\t\tif (!gpe_event_info)\n\t\t\tgoto error_exit;\n\t}\n\n\t \n\n\tgpe_register_info = gpe_event_info->register_info;\n\n\t \n\n\tregister_bit = acpi_hw_get_gpe_register_bit(gpe_event_info);\n\n\t \n\n\tstatus = acpi_hw_gpe_read(&enable_reg, &gpe_register_info->enable_address);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto error_exit;\n\t}\n\n\t \n\n\tstatus = acpi_hw_gpe_read(&status_reg, &gpe_register_info->status_address);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto error_exit;\n\t}\n\n\t \n\n\tACPI_DEBUG_PRINT((ACPI_DB_INTERRUPTS,\n\t\t\t  \"Read registers for GPE %02X: Status=%02X, Enable=%02X, \"\n\t\t\t  \"RunEnable=%02X, WakeEnable=%02X\\n\",\n\t\t\t  gpe_number,\n\t\t\t  (u32)(status_reg & register_bit),\n\t\t\t  (u32)(enable_reg & register_bit),\n\t\t\t  gpe_register_info->enable_for_run,\n\t\t\t  gpe_register_info->enable_for_wake));\n\n\tenabled_status_byte = (u8)(status_reg & enable_reg);\n\tif (!(enabled_status_byte & register_bit)) {\n\t\tgoto error_exit;\n\t}\n\n\t \n\n\tacpi_gpe_count++;\n\tif (acpi_gbl_global_event_handler) {\n\t\tacpi_gbl_global_event_handler(ACPI_EVENT_TYPE_GPE,\n\t\t\t\t\t      gpe_device, gpe_number,\n\t\t\t\t\t      acpi_gbl_global_event_handler_context);\n\t}\n\n\t \n\n\tif (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\n\t    ACPI_GPE_DISPATCH_RAW_HANDLER) {\n\n\t\t \n\n\t\tgpe_handler_info = gpe_event_info->dispatch.handler;\n\n\t\t \n\t\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\t\tint_status |=\n\t\t    gpe_handler_info->address(gpe_device, gpe_number,\n\t\t\t\t\t      gpe_handler_info->context);\n\t\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\t} else {\n\t\t \n\n\t\tint_status |= acpi_ev_gpe_dispatch(gpe_device,\n\t\t\t\t\t\t   gpe_event_info, gpe_number);\n\t}\n\nerror_exit:\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\treturn (int_status);\n}\n\n \n\nu32\nacpi_ev_gpe_dispatch(struct acpi_namespace_node *gpe_device,\n\t\t     struct acpi_gpe_event_info *gpe_event_info, u32 gpe_number)\n{\n\tacpi_status status;\n\tu32 return_value;\n\n\tACPI_FUNCTION_TRACE(ev_gpe_dispatch);\n\n\t \n\tstatus = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_DISABLE);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"Unable to disable GPE %02X\", gpe_number));\n\t\treturn_UINT32(ACPI_INTERRUPT_NOT_HANDLED);\n\t}\n\n\t \n\tif ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) ==\n\t    ACPI_GPE_EDGE_TRIGGERED) {\n\t\tstatus = acpi_hw_clear_gpe(gpe_event_info);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\"Unable to clear GPE %02X\",\n\t\t\t\t\tgpe_number));\n\t\t\t(void)acpi_hw_low_set_gpe(gpe_event_info,\n\t\t\t\t\t\t  ACPI_GPE_CONDITIONAL_ENABLE);\n\t\t\treturn_UINT32(ACPI_INTERRUPT_NOT_HANDLED);\n\t\t}\n\t}\n\n\tgpe_event_info->disable_for_dispatch = TRUE;\n\n\t \n\tswitch (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags)) {\n\tcase ACPI_GPE_DISPATCH_HANDLER:\n\n\t\t \n\n\t\treturn_value =\n\t\t    gpe_event_info->dispatch.handler->address(gpe_device,\n\t\t\t\t\t\t\t      gpe_number,\n\t\t\t\t\t\t\t      gpe_event_info->\n\t\t\t\t\t\t\t      dispatch.handler->\n\t\t\t\t\t\t\t      context);\n\n\t\t \n\n\t\tif (return_value & ACPI_REENABLE_GPE) {\n\t\t\t(void)acpi_ev_finish_gpe(gpe_event_info);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_GPE_DISPATCH_METHOD:\n\tcase ACPI_GPE_DISPATCH_NOTIFY:\n\t\t \n\t\tstatus = acpi_os_execute(OSL_GPE_HANDLER,\n\t\t\t\t\t acpi_ev_asynch_execute_gpe_method,\n\t\t\t\t\t gpe_event_info);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\"Unable to queue handler for GPE %02X - event disabled\",\n\t\t\t\t\tgpe_number));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"No handler or method for GPE %02X, disabling event\",\n\t\t\t    gpe_number));\n\n\t\tbreak;\n\t}\n\n\treturn_UINT32(ACPI_INTERRUPT_HANDLED);\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}