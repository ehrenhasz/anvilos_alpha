{
  "module_name": "excreate.c",
  "hash_id": "d07dd466900ebd6966dfd626bacccc201806f34d7a780970b0a5e20be2b6dc48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/excreate.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acinterp.h\"\n#include \"amlcode.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_EXECUTER\nACPI_MODULE_NAME(\"excreate\")\n \nacpi_status acpi_ex_create_alias(struct acpi_walk_state *walk_state)\n{\n\tstruct acpi_namespace_node *target_node;\n\tstruct acpi_namespace_node *alias_node;\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(ex_create_alias);\n\n\t \n\n\talias_node = (struct acpi_namespace_node *)walk_state->operands[0];\n\ttarget_node = (struct acpi_namespace_node *)walk_state->operands[1];\n\n\tif ((target_node->type == ACPI_TYPE_LOCAL_ALIAS) ||\n\t    (target_node->type == ACPI_TYPE_LOCAL_METHOD_ALIAS)) {\n\t\t \n\t\ttarget_node =\n\t\t    ACPI_CAST_PTR(struct acpi_namespace_node,\n\t\t\t\t  target_node->object);\n\t}\n\n\t \n\n\tif (!target_node) {\n\t\treturn_ACPI_STATUS(AE_NULL_OBJECT);\n\t}\n\n\t \n\n\tswitch (target_node->type) {\n\tcase ACPI_TYPE_METHOD:\n\t\t \n\t\talias_node->type = ACPI_TYPE_LOCAL_METHOD_ALIAS;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\talias_node->type = ACPI_TYPE_LOCAL_ALIAS;\n\t\talias_node->object =\n\t\t    ACPI_CAST_PTR(union acpi_operand_object, target_node);\n\t\tbreak;\n\t}\n\n\t \n\n\talias_node->object =\n\t    ACPI_CAST_PTR(union acpi_operand_object, target_node);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ex_create_event(struct acpi_walk_state *walk_state)\n{\n\tacpi_status status;\n\tunion acpi_operand_object *obj_desc;\n\n\tACPI_FUNCTION_TRACE(ex_create_event);\n\n\tobj_desc = acpi_ut_create_internal_object(ACPI_TYPE_EVENT);\n\tif (!obj_desc) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tstatus = acpi_os_create_semaphore(ACPI_NO_UNIT_LIMIT, 0,\n\t\t\t\t\t  &obj_desc->event.os_semaphore);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tstatus = acpi_ns_attach_object((struct acpi_namespace_node *)\n\t\t\t\t       walk_state->operands[0], obj_desc,\n\t\t\t\t       ACPI_TYPE_EVENT);\n\ncleanup:\n\t \n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ex_create_mutex(struct acpi_walk_state *walk_state)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_operand_object *obj_desc;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_create_mutex, ACPI_WALK_OPERANDS);\n\n\t \n\n\tobj_desc = acpi_ut_create_internal_object(ACPI_TYPE_MUTEX);\n\tif (!obj_desc) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tstatus = acpi_os_create_mutex(&obj_desc->mutex.os_mutex);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tobj_desc->mutex.sync_level = (u8)walk_state->operands[1]->integer.value;\n\tobj_desc->mutex.node =\n\t    (struct acpi_namespace_node *)walk_state->operands[0];\n\n\tstatus =\n\t    acpi_ns_attach_object(obj_desc->mutex.node, obj_desc,\n\t\t\t\t  ACPI_TYPE_MUTEX);\n\ncleanup:\n\t \n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ex_create_region(u8 * aml_start,\n\t\t      u32 aml_length,\n\t\t      u8 space_id, struct acpi_walk_state *walk_state)\n{\n\tacpi_status status;\n\tunion acpi_operand_object *obj_desc;\n\tstruct acpi_namespace_node *node;\n\tunion acpi_operand_object *region_obj2;\n\n\tACPI_FUNCTION_TRACE(ex_create_region);\n\n\t \n\n\tnode = walk_state->op->common.node;\n\n\t \n\tif (acpi_ns_get_attached_object(node)) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\tif (!acpi_is_valid_space_id(space_id)) {\n\t\t \n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Invalid/unknown Address Space ID: 0x%2.2X\",\n\t\t\t    space_id));\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_LOAD, \"Region Type - %s (0x%X)\\n\",\n\t\t\t  acpi_ut_get_region_name(space_id), space_id));\n\n\t \n\n\tobj_desc = acpi_ut_create_internal_object(ACPI_TYPE_REGION);\n\tif (!obj_desc) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tregion_obj2 = acpi_ns_get_secondary_object(obj_desc);\n\tregion_obj2->extra.aml_start = aml_start;\n\tregion_obj2->extra.aml_length = aml_length;\n\tregion_obj2->extra.method_REG = NULL;\n\tif (walk_state->scope_info) {\n\t\tregion_obj2->extra.scope_node =\n\t\t    walk_state->scope_info->scope.node;\n\t} else {\n\t\tregion_obj2->extra.scope_node = node;\n\t}\n\n\t \n\n\tobj_desc->region.space_id = space_id;\n\tobj_desc->region.address = 0;\n\tobj_desc->region.length = 0;\n\tobj_desc->region.pointer = NULL;\n\tobj_desc->region.node = node;\n\tobj_desc->region.handler = NULL;\n\tobj_desc->common.flags &=\n\t    ~(AOPOBJ_SETUP_COMPLETE | AOPOBJ_REG_CONNECTED |\n\t      AOPOBJ_OBJECT_INITIALIZED);\n\n\t \n\n\tstatus = acpi_ns_attach_object(node, obj_desc, ACPI_TYPE_REGION);\n\ncleanup:\n\n\t \n\n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ex_create_processor(struct acpi_walk_state *walk_state)\n{\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\tunion acpi_operand_object *obj_desc;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_create_processor, walk_state);\n\n\t \n\n\tobj_desc = acpi_ut_create_internal_object(ACPI_TYPE_PROCESSOR);\n\tif (!obj_desc) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tobj_desc->processor.proc_id = (u8) operand[1]->integer.value;\n\tobj_desc->processor.length = (u8) operand[3]->integer.value;\n\tobj_desc->processor.address =\n\t    (acpi_io_address)operand[2]->integer.value;\n\n\t \n\n\tstatus = acpi_ns_attach_object((struct acpi_namespace_node *)operand[0],\n\t\t\t\t       obj_desc, ACPI_TYPE_PROCESSOR);\n\n\t \n\n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ex_create_power_resource(struct acpi_walk_state *walk_state)\n{\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\tacpi_status status;\n\tunion acpi_operand_object *obj_desc;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_create_power_resource, walk_state);\n\n\t \n\n\tobj_desc = acpi_ut_create_internal_object(ACPI_TYPE_POWER);\n\tif (!obj_desc) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tobj_desc->power_resource.system_level = (u8) operand[1]->integer.value;\n\tobj_desc->power_resource.resource_order =\n\t    (u16) operand[2]->integer.value;\n\n\t \n\n\tstatus = acpi_ns_attach_object((struct acpi_namespace_node *)operand[0],\n\t\t\t\t       obj_desc, ACPI_TYPE_POWER);\n\n\t \n\n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ex_create_method(u8 * aml_start,\n\t\t      u32 aml_length, struct acpi_walk_state *walk_state)\n{\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\tunion acpi_operand_object *obj_desc;\n\tacpi_status status;\n\tu8 method_flags;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_create_method, walk_state);\n\n\t \n\n\tobj_desc = acpi_ut_create_internal_object(ACPI_TYPE_METHOD);\n\tif (!obj_desc) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto exit;\n\t}\n\n\t \n\n\tobj_desc->method.aml_start = aml_start;\n\tobj_desc->method.aml_length = aml_length;\n\tobj_desc->method.node = operand[0];\n\n\t \n\tmethod_flags = (u8)operand[1]->integer.value;\n\tobj_desc->method.param_count = (u8)\n\t    (method_flags & AML_METHOD_ARG_COUNT);\n\n\t \n\tif (method_flags & AML_METHOD_SERIALIZED) {\n\t\tobj_desc->method.info_flags = ACPI_METHOD_SERIALIZED;\n\n\t\t \n\t\tobj_desc->method.sync_level = (u8)\n\t\t    ((method_flags & AML_METHOD_SYNC_LEVEL) >> 4);\n\t}\n\n\t \n\n\tstatus = acpi_ns_attach_object((struct acpi_namespace_node *)operand[0],\n\t\t\t\t       obj_desc, ACPI_TYPE_METHOD);\n\n\t \n\n\tacpi_ut_remove_reference(obj_desc);\n\nexit:\n\t \n\n\tacpi_ut_remove_reference(operand[1]);\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}