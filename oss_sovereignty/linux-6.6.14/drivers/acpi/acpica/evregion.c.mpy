{
  "module_name": "evregion.c",
  "hash_id": "883b63cd9dacfb74fe297bd499ab7154532e6a10913d30fd3be759e402c837dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/evregion.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n#include \"acnamesp.h\"\n#include \"acinterp.h\"\n\n#define _COMPONENT          ACPI_EVENTS\nACPI_MODULE_NAME(\"evregion\")\n\nextern u8 acpi_gbl_default_address_spaces[];\n\n \n\nstatic void\nacpi_ev_execute_orphan_reg_method(struct acpi_namespace_node *device_node,\n\t\t\t\t  acpi_adr_space_type space_id);\n\nstatic acpi_status\nacpi_ev_reg_run(acpi_handle obj_handle,\n\t\tu32 level, void *context, void **return_value);\n\n \n\nacpi_status acpi_ev_initialize_op_regions(void)\n{\n\tacpi_status status;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ev_initialize_op_regions);\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tfor (i = 0; i < ACPI_NUM_DEFAULT_SPACES; i++) {\n\t\t \n\t\tif (acpi_ev_has_default_handler(acpi_gbl_root_node,\n\t\t\t\t\t\tacpi_gbl_default_address_spaces\n\t\t\t\t\t\t[i])) {\n\t\t\tacpi_ev_execute_reg_methods(acpi_gbl_root_node,\n\t\t\t\t\t\t    acpi_gbl_default_address_spaces\n\t\t\t\t\t\t    [i], ACPI_REG_CONNECT);\n\t\t}\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ev_address_space_dispatch(union acpi_operand_object *region_obj,\n\t\t\t       union acpi_operand_object *field_obj,\n\t\t\t       u32 function,\n\t\t\t       u32 region_offset, u32 bit_width, u64 *value)\n{\n\tacpi_status status;\n\tacpi_adr_space_handler handler;\n\tacpi_adr_space_setup region_setup;\n\tunion acpi_operand_object *handler_desc;\n\tunion acpi_operand_object *region_obj2;\n\tvoid *region_context = NULL;\n\tstruct acpi_connection_info *context;\n\tacpi_mutex context_mutex;\n\tu8 context_locked;\n\tacpi_physical_address address;\n\n\tACPI_FUNCTION_TRACE(ev_address_space_dispatch);\n\n\tregion_obj2 = acpi_ns_get_secondary_object(region_obj);\n\tif (!region_obj2) {\n\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t}\n\n\t \n\n\thandler_desc = region_obj->region.handler;\n\tif (!handler_desc) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"No handler for Region [%4.4s] (%p) [%s]\",\n\t\t\t    acpi_ut_get_node_name(region_obj->region.node),\n\t\t\t    region_obj,\n\t\t\t    acpi_ut_get_region_name(region_obj->region.\n\t\t\t\t\t\t    space_id)));\n\n\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t}\n\n\tcontext = handler_desc->address_space.context;\n\tcontext_mutex = handler_desc->address_space.context_mutex;\n\tcontext_locked = FALSE;\n\n\t \n\tif (!(region_obj->region.flags & AOPOBJ_SETUP_COMPLETE)) {\n\n\t\t \n\n\t\tregion_setup = handler_desc->address_space.setup;\n\t\tif (!region_setup) {\n\n\t\t\t \n\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"No init routine for region(%p) [%s]\",\n\t\t\t\t    region_obj,\n\t\t\t\t    acpi_ut_get_region_name(region_obj->region.\n\t\t\t\t\t\t\t    space_id)));\n\t\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t\t}\n\n\t\tif (region_obj->region.space_id == ACPI_ADR_SPACE_PLATFORM_COMM) {\n\t\t\tstruct acpi_pcc_info *ctx =\n\t\t\t    handler_desc->address_space.context;\n\n\t\t\tctx->internal_buffer =\n\t\t\t    field_obj->field.internal_pcc_buffer;\n\t\t\tctx->length = (u16)region_obj->region.length;\n\t\t\tctx->subspace_id = (u8)region_obj->region.address;\n\t\t}\n\n\t\tif (region_obj->region.space_id ==\n\t\t    ACPI_ADR_SPACE_FIXED_HARDWARE) {\n\t\t\tstruct acpi_ffh_info *ctx =\n\t\t\t    handler_desc->address_space.context;\n\n\t\t\tctx->length = region_obj->region.length;\n\t\t\tctx->offset = region_obj->region.address;\n\t\t}\n\n\t\t \n\t\tacpi_ex_exit_interpreter();\n\n\t\tstatus = region_setup(region_obj, ACPI_REGION_ACTIVATE,\n\t\t\t\t      context, &region_context);\n\n\t\t \n\n\t\tacpi_ex_enter_interpreter();\n\n\t\t \n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\"During region initialization: [%s]\",\n\t\t\t\t\tacpi_ut_get_region_name(region_obj->\n\t\t\t\t\t\t\t\tregion.\n\t\t\t\t\t\t\t\tspace_id)));\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\t \n\n\t\tif (!(region_obj->region.flags & AOPOBJ_SETUP_COMPLETE)) {\n\t\t\tregion_obj->region.flags |= AOPOBJ_SETUP_COMPLETE;\n\n\t\t\t \n\t\t\tif (!(region_obj2->extra.region_context)) {\n\t\t\t\tregion_obj2->extra.region_context =\n\t\t\t\t    region_context;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\thandler = handler_desc->address_space.handler;\n\taddress = (region_obj->region.address + region_offset);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t  \"Handler %p (@%p) Address %8.8X%8.8X [%s]\\n\",\n\t\t\t  &region_obj->region.handler->address_space, handler,\n\t\t\t  ACPI_FORMAT_UINT64(address),\n\t\t\t  acpi_ut_get_region_name(region_obj->region.\n\t\t\t\t\t\t  space_id)));\n\n\tif (!(handler_desc->address_space.handler_flags &\n\t      ACPI_ADDR_HANDLER_DEFAULT_INSTALLED)) {\n\t\t \n\t\tacpi_ex_exit_interpreter();\n\t}\n\n\t \n\tif ((region_obj->region.space_id == ACPI_ADR_SPACE_GSBUS ||\n\t     region_obj->region.space_id == ACPI_ADR_SPACE_GPIO) &&\n\t    context && field_obj) {\n\n\t\tstatus =\n\t\t    acpi_os_acquire_mutex(context_mutex, ACPI_WAIT_FOREVER);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto re_enter_interpreter;\n\t\t}\n\n\t\tcontext_locked = TRUE;\n\n\t\t \n\n\t\tcontext->connection = field_obj->field.resource_buffer;\n\t\tcontext->length = field_obj->field.resource_length;\n\t\tcontext->access_length = field_obj->field.access_length;\n\n\t\tif (region_obj->region.space_id == ACPI_ADR_SPACE_GPIO) {\n\t\t\taddress = field_obj->field.pin_number_index;\n\t\t\tbit_width = field_obj->field.bit_length;\n\t\t}\n\t}\n\n\t \n\n\tstatus = handler(function, address, bit_width, value, context,\n\t\t\t region_obj2->extra.region_context);\n\n\tif (context_locked) {\n\t\tacpi_os_release_mutex(context_mutex);\n\t}\n\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status, \"Returned by Handler for [%s]\",\n\t\t\t\tacpi_ut_get_region_name(region_obj->region.\n\t\t\t\t\t\t\tspace_id)));\n\n\t\t \n\t\tif ((region_obj->region.space_id == ACPI_ADR_SPACE_EC) &&\n\t\t    (status == AE_TIME)) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Timeout from EC hardware or EC device driver\"));\n\t\t}\n\t}\n\nre_enter_interpreter:\n\tif (!(handler_desc->address_space.handler_flags &\n\t      ACPI_ADDR_HANDLER_DEFAULT_INSTALLED)) {\n\t\t \n\t\tacpi_ex_enter_interpreter();\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nvoid\nacpi_ev_detach_region(union acpi_operand_object *region_obj,\n\t\t      u8 acpi_ns_is_locked)\n{\n\tunion acpi_operand_object *handler_obj;\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_operand_object *start_desc;\n\tunion acpi_operand_object **last_obj_ptr;\n\tacpi_adr_space_setup region_setup;\n\tvoid **region_context;\n\tunion acpi_operand_object *region_obj2;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ev_detach_region);\n\n\tregion_obj2 = acpi_ns_get_secondary_object(region_obj);\n\tif (!region_obj2) {\n\t\treturn_VOID;\n\t}\n\tregion_context = &region_obj2->extra.region_context;\n\n\t \n\n\thandler_obj = region_obj->region.handler;\n\tif (!handler_obj) {\n\n\t\t \n\n\t\treturn_VOID;\n\t}\n\n\t \n\n\tobj_desc = handler_obj->address_space.region_list;\n\tstart_desc = obj_desc;\n\tlast_obj_ptr = &handler_obj->address_space.region_list;\n\n\twhile (obj_desc) {\n\n\t\t \n\n\t\tif (obj_desc == region_obj) {\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t\t\t  \"Removing Region %p from address handler %p\\n\",\n\t\t\t\t\t  region_obj, handler_obj));\n\n\t\t\t \n\n\t\t\t*last_obj_ptr = obj_desc->region.next;\n\t\t\tobj_desc->region.next = NULL;\t \n\n\t\t\tif (acpi_ns_is_locked) {\n\t\t\t\tstatus =\n\t\t\t\t    acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\treturn_VOID;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\n\t\t\tstatus =\n\t\t\t    acpi_ev_execute_reg_method(region_obj,\n\t\t\t\t\t\t       ACPI_REG_DISCONNECT);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\t\"from region _REG, [%s]\",\n\t\t\t\t\t\tacpi_ut_get_region_name\n\t\t\t\t\t\t(region_obj->region.space_id)));\n\t\t\t}\n\n\t\t\tif (acpi_ns_is_locked) {\n\t\t\t\tstatus =\n\t\t\t\t    acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\treturn_VOID;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (region_obj->region.flags & AOPOBJ_SETUP_COMPLETE) {\n\t\t\t\tregion_setup = handler_obj->address_space.setup;\n\t\t\t\tstatus =\n\t\t\t\t    region_setup(region_obj,\n\t\t\t\t\t\t ACPI_REGION_DEACTIVATE,\n\t\t\t\t\t\t handler_obj->address_space.\n\t\t\t\t\t\t context, region_context);\n\n\t\t\t\t \n\t\t\t\tif (region_context) {\n\t\t\t\t\t*region_context = NULL;\n\t\t\t\t}\n\n\t\t\t\t \n\n\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\t\t\"from region handler - deactivate, [%s]\",\n\t\t\t\t\t\t\tacpi_ut_get_region_name\n\t\t\t\t\t\t\t(region_obj->region.\n\t\t\t\t\t\t\t space_id)));\n\t\t\t\t}\n\n\t\t\t\tregion_obj->region.flags &=\n\t\t\t\t    ~(AOPOBJ_SETUP_COMPLETE);\n\t\t\t}\n\n\t\t\t \n\t\t\tregion_obj->region.handler = NULL;\n\t\t\tacpi_ut_remove_reference(handler_obj);\n\n\t\t\treturn_VOID;\n\t\t}\n\n\t\t \n\n\t\tlast_obj_ptr = &obj_desc->region.next;\n\t\tobj_desc = obj_desc->region.next;\n\n\t\t \n\n\t\tif (obj_desc == start_desc) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Circular handler list in region object %p\",\n\t\t\t\t    region_obj));\n\t\t\treturn_VOID;\n\t\t}\n\t}\n\n\t \n\n\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t  \"Cannot remove region %p from address handler %p\\n\",\n\t\t\t  region_obj, handler_obj));\n\n\treturn_VOID;\n}\n\n \n\nacpi_status\nacpi_ev_attach_region(union acpi_operand_object *handler_obj,\n\t\t      union acpi_operand_object *region_obj,\n\t\t      u8 acpi_ns_is_locked)\n{\n\n\tACPI_FUNCTION_TRACE(ev_attach_region);\n\n\t \n\n\tif (region_obj->region.handler) {\n\t\treturn_ACPI_STATUS(AE_ALREADY_EXISTS);\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\n\t\t\t  \"Adding Region [%4.4s] %p to address handler %p [%s]\\n\",\n\t\t\t  acpi_ut_get_node_name(region_obj->region.node),\n\t\t\t  region_obj, handler_obj,\n\t\t\t  acpi_ut_get_region_name(region_obj->region.\n\t\t\t\t\t\t  space_id)));\n\n\t \n\n\tregion_obj->region.next = handler_obj->address_space.region_list;\n\thandler_obj->address_space.region_list = region_obj;\n\tregion_obj->region.handler = handler_obj;\n\tacpi_ut_add_reference(handler_obj);\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ev_execute_reg_method(union acpi_operand_object *region_obj, u32 function)\n{\n\tstruct acpi_evaluate_info *info;\n\tunion acpi_operand_object *args[3];\n\tunion acpi_operand_object *region_obj2;\n\tconst acpi_name *reg_name_ptr =\n\t    ACPI_CAST_PTR(acpi_name, METHOD_NAME__REG);\n\tstruct acpi_namespace_node *method_node;\n\tstruct acpi_namespace_node *node;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ev_execute_reg_method);\n\n\tif (!acpi_gbl_namespace_initialized ||\n\t    region_obj->region.handler == NULL) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\tregion_obj2 = acpi_ns_get_secondary_object(region_obj);\n\tif (!region_obj2) {\n\t\treturn_ACPI_STATUS(AE_NOT_EXIST);\n\t}\n\n\t \n\tnode = region_obj->region.node->parent;\n\tstatus =\n\t    acpi_ns_search_one_scope(*reg_name_ptr, node, ACPI_TYPE_METHOD,\n\t\t\t\t     &method_node);\n\tif (ACPI_SUCCESS(status)) {\n\t\t \n\t\tregion_obj2->extra.method_REG = method_node;\n\t}\n\tif (region_obj2->extra.method_REG == NULL) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tif ((function == ACPI_REG_CONNECT &&\n\t     region_obj->common.flags & AOPOBJ_REG_CONNECTED) ||\n\t    (function == ACPI_REG_DISCONNECT &&\n\t     !(region_obj->common.flags & AOPOBJ_REG_CONNECTED))) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tinfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\n\tif (!info) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tinfo->prefix_node = region_obj2->extra.method_REG;\n\tinfo->relative_pathname = NULL;\n\tinfo->parameters = args;\n\tinfo->flags = ACPI_IGNORE_RETURN_VALUE;\n\n\t \n\targs[0] =\n\t    acpi_ut_create_integer_object((u64)region_obj->region.space_id);\n\tif (!args[0]) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup1;\n\t}\n\n\targs[1] = acpi_ut_create_integer_object((u64)function);\n\tif (!args[1]) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup2;\n\t}\n\n\targs[2] = NULL;\t\t \n\n\t \n\n\tACPI_DEBUG_EXEC(acpi_ut_display_init_pathname\n\t\t\t(ACPI_TYPE_METHOD, info->prefix_node, NULL));\n\n\tstatus = acpi_ns_evaluate(info);\n\tacpi_ut_remove_reference(args[1]);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto cleanup2;\n\t}\n\n\tif (function == ACPI_REG_CONNECT) {\n\t\tregion_obj->common.flags |= AOPOBJ_REG_CONNECTED;\n\t} else {\n\t\tregion_obj->common.flags &= ~AOPOBJ_REG_CONNECTED;\n\t}\n\ncleanup2:\n\tacpi_ut_remove_reference(args[0]);\n\ncleanup1:\n\tACPI_FREE(info);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nvoid\nacpi_ev_execute_reg_methods(struct acpi_namespace_node *node,\n\t\t\t    acpi_adr_space_type space_id, u32 function)\n{\n\tstruct acpi_reg_walk_info info;\n\n\tACPI_FUNCTION_TRACE(ev_execute_reg_methods);\n\n\t \n\tif ((space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) ||\n\t    (space_id == ACPI_ADR_SPACE_SYSTEM_IO) ||\n\t    (space_id == ACPI_ADR_SPACE_DATA_TABLE)) {\n\t\treturn_VOID;\n\t}\n\n\tinfo.space_id = space_id;\n\tinfo.function = function;\n\tinfo.reg_run_count = 0;\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_NAMES,\n\t\t\t      \"    Running _REG methods for SpaceId %s\\n\",\n\t\t\t      acpi_ut_get_region_name(info.space_id)));\n\n\t \n\t(void)acpi_ns_walk_namespace(ACPI_TYPE_ANY, node, ACPI_UINT32_MAX,\n\t\t\t\t     ACPI_NS_WALK_UNLOCK, acpi_ev_reg_run, NULL,\n\t\t\t\t     &info, NULL);\n\n\t \n\tif (space_id == ACPI_ADR_SPACE_EC || space_id == ACPI_ADR_SPACE_GPIO) {\n\t\tacpi_ev_execute_orphan_reg_method(node, space_id);\n\t}\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_NAMES,\n\t\t\t      \"    Executed %u _REG methods for SpaceId %s\\n\",\n\t\t\t      info.reg_run_count,\n\t\t\t      acpi_ut_get_region_name(info.space_id)));\n\n\treturn_VOID;\n}\n\n \n\nstatic acpi_status\nacpi_ev_reg_run(acpi_handle obj_handle,\n\t\tu32 level, void *context, void **return_value)\n{\n\tunion acpi_operand_object *obj_desc;\n\tstruct acpi_namespace_node *node;\n\tacpi_status status;\n\tstruct acpi_reg_walk_info *info;\n\n\tinfo = ACPI_CAST_PTR(struct acpi_reg_walk_info, context);\n\n\t \n\n\tnode = acpi_ns_validate_handle(obj_handle);\n\tif (!node) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\tif ((node->type != ACPI_TYPE_REGION) && (node != acpi_gbl_root_node)) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (!obj_desc) {\n\n\t\t \n\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tif (obj_desc->region.space_id != info->space_id) {\n\n\t\t \n\n\t\treturn (AE_OK);\n\t}\n\n\tinfo->reg_run_count++;\n\tstatus = acpi_ev_execute_reg_method(obj_desc, info->function);\n\treturn (status);\n}\n\n \n\nstatic void\nacpi_ev_execute_orphan_reg_method(struct acpi_namespace_node *device_node,\n\t\t\t\t  acpi_adr_space_type space_id)\n{\n\tacpi_handle reg_method;\n\tstruct acpi_namespace_node *next_node;\n\tacpi_status status;\n\tstruct acpi_object_list args;\n\tunion acpi_object objects[2];\n\n\tACPI_FUNCTION_TRACE(ev_execute_orphan_reg_method);\n\n\tif (!device_node) {\n\t\treturn_VOID;\n\t}\n\n\t \n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\n\t \n\n\tstatus = acpi_get_handle(device_node, METHOD_NAME__REG, &reg_method);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto exit;\t \n\t}\n\n\t \n\tnext_node = acpi_ns_get_next_node(device_node, NULL);\n\twhile (next_node) {\n\t\tif ((next_node->type == ACPI_TYPE_REGION) &&\n\t\t    (next_node->object) &&\n\t\t    (next_node->object->region.space_id == space_id)) {\n\t\t\tgoto exit;\t \n\t\t}\n\n\t\tnext_node = acpi_ns_get_next_node(device_node, next_node);\n\t}\n\n\t \n\n\targs.count = 2;\n\targs.pointer = objects;\n\tobjects[0].type = ACPI_TYPE_INTEGER;\n\tobjects[0].integer.value = space_id;\n\tobjects[1].type = ACPI_TYPE_INTEGER;\n\tobjects[1].integer.value = ACPI_REG_CONNECT;\n\n\t(void)acpi_evaluate_object(reg_method, NULL, &args, NULL);\n\nexit:\n\t \n\n\t(void)acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\treturn_VOID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}