{
  "module_name": "utids.c",
  "hash_id": "65dfc506cf09798d5023e7e947a6f93ba22103dd8fefadebc8106cfc8bc58254",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utids.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acinterp.h\"\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utids\")\n\n \nacpi_status\nacpi_ut_execute_HID(struct acpi_namespace_node *device_node,\n\t\t    struct acpi_pnp_device_id **return_id)\n{\n\tunion acpi_operand_object *obj_desc;\n\tstruct acpi_pnp_device_id *hid;\n\tu32 length;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ut_execute_HID);\n\n\tstatus = acpi_ut_evaluate_object(device_node, METHOD_NAME__HID,\n\t\t\t\t\t ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING,\n\t\t\t\t\t &obj_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tif (obj_desc->common.type == ACPI_TYPE_INTEGER) {\n\t\tlength = ACPI_EISAID_STRING_SIZE;\n\t} else {\n\t\tlength = obj_desc->string.length + 1;\n\t}\n\n\t \n\n\thid =\n\t    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_pnp_device_id) +\n\t\t\t\t (acpi_size)length);\n\tif (!hid) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\thid->string =\n\t    ACPI_ADD_PTR(char, hid, sizeof(struct acpi_pnp_device_id));\n\n\t \n\n\tif (obj_desc->common.type == ACPI_TYPE_INTEGER) {\n\t\tacpi_ex_eisa_id_to_string(hid->string, obj_desc->integer.value);\n\t} else {\n\t\tstrcpy(hid->string, obj_desc->string.pointer);\n\t}\n\n\thid->length = length;\n\t*return_id = hid;\n\ncleanup:\n\n\t \n\n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ut_execute_UID(struct acpi_namespace_node *device_node,\n\t\t    struct acpi_pnp_device_id **return_id)\n{\n\tunion acpi_operand_object *obj_desc;\n\tstruct acpi_pnp_device_id *uid;\n\tu32 length;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ut_execute_UID);\n\n\tstatus = acpi_ut_evaluate_object(device_node, METHOD_NAME__UID,\n\t\t\t\t\t ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING,\n\t\t\t\t\t &obj_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tif (obj_desc->common.type == ACPI_TYPE_INTEGER) {\n\t\tlength = ACPI_MAX64_DECIMAL_DIGITS + 1;\n\t} else {\n\t\tlength = obj_desc->string.length + 1;\n\t}\n\n\t \n\n\tuid =\n\t    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_pnp_device_id) +\n\t\t\t\t (acpi_size)length);\n\tif (!uid) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tuid->string =\n\t    ACPI_ADD_PTR(char, uid, sizeof(struct acpi_pnp_device_id));\n\n\t \n\n\tif (obj_desc->common.type == ACPI_TYPE_INTEGER) {\n\t\tacpi_ex_integer_to_string(uid->string, obj_desc->integer.value);\n\t} else {\n\t\tstrcpy(uid->string, obj_desc->string.pointer);\n\t}\n\n\tuid->length = length;\n\t*return_id = uid;\n\ncleanup:\n\n\t \n\n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ut_execute_CID(struct acpi_namespace_node *device_node,\n\t\t    struct acpi_pnp_device_id_list **return_cid_list)\n{\n\tunion acpi_operand_object **cid_objects;\n\tunion acpi_operand_object *obj_desc;\n\tstruct acpi_pnp_device_id_list *cid_list;\n\tchar *next_id_string;\n\tu32 string_area_size;\n\tu32 length;\n\tu32 cid_list_size;\n\tacpi_status status;\n\tu32 count;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ut_execute_CID);\n\n\t \n\n\tstatus = acpi_ut_evaluate_object(device_node, METHOD_NAME__CID,\n\t\t\t\t\t ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING\n\t\t\t\t\t | ACPI_BTYPE_PACKAGE, &obj_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tif (obj_desc->common.type == ACPI_TYPE_PACKAGE) {\n\t\tcount = obj_desc->package.count;\n\t\tcid_objects = obj_desc->package.elements;\n\t} else {\t\t \n\n\t\tcount = 1;\n\t\tcid_objects = &obj_desc;\n\t}\n\n\tstring_area_size = 0;\n\tfor (i = 0; i < count; i++) {\n\n\t\t \n\n\t\tswitch (cid_objects[i]->common.type) {\n\t\tcase ACPI_TYPE_INTEGER:\n\n\t\t\tstring_area_size += ACPI_EISAID_STRING_SIZE;\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_STRING:\n\n\t\t\tstring_area_size += cid_objects[i]->string.length + 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tstatus = AE_TYPE;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\tcid_list_size = sizeof(struct acpi_pnp_device_id_list) +\n\t    (count * sizeof(struct acpi_pnp_device_id)) + string_area_size;\n\n\tcid_list = ACPI_ALLOCATE_ZEROED(cid_list_size);\n\tif (!cid_list) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tnext_id_string = ACPI_CAST_PTR(char, cid_list->ids) +\n\t    ((acpi_size)count * sizeof(struct acpi_pnp_device_id));\n\n\t \n\n\tfor (i = 0; i < count; i++) {\n\t\tif (cid_objects[i]->common.type == ACPI_TYPE_INTEGER) {\n\n\t\t\t \n\n\t\t\tacpi_ex_eisa_id_to_string(next_id_string,\n\t\t\t\t\t\t  cid_objects[i]->integer.\n\t\t\t\t\t\t  value);\n\t\t\tlength = ACPI_EISAID_STRING_SIZE;\n\t\t} else {\t \n\t\t\t \n\t\t\tstrcpy(next_id_string, cid_objects[i]->string.pointer);\n\t\t\tlength = cid_objects[i]->string.length + 1;\n\t\t}\n\n\t\tcid_list->ids[i].string = next_id_string;\n\t\tcid_list->ids[i].length = length;\n\t\tnext_id_string += length;\n\t}\n\n\t \n\n\tcid_list->count = count;\n\tcid_list->list_size = cid_list_size;\n\t*return_cid_list = cid_list;\n\ncleanup:\n\n\t \n\n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ut_execute_CLS(struct acpi_namespace_node *device_node,\n\t\t    struct acpi_pnp_device_id **return_id)\n{\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_operand_object **cls_objects;\n\tu32 count;\n\tstruct acpi_pnp_device_id *cls;\n\tu32 length;\n\tacpi_status status;\n\tu8 class_code[3] = { 0, 0, 0 };\n\n\tACPI_FUNCTION_TRACE(ut_execute_CLS);\n\n\tstatus = acpi_ut_evaluate_object(device_node, METHOD_NAME__CLS,\n\t\t\t\t\t ACPI_BTYPE_PACKAGE, &obj_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tlength = ACPI_PCICLS_STRING_SIZE;\n\tcls_objects = obj_desc->package.elements;\n\tcount = obj_desc->package.count;\n\n\tif (obj_desc->common.type == ACPI_TYPE_PACKAGE) {\n\t\tif (count > 0\n\t\t    && cls_objects[0]->common.type == ACPI_TYPE_INTEGER) {\n\t\t\tclass_code[0] = (u8)cls_objects[0]->integer.value;\n\t\t}\n\t\tif (count > 1\n\t\t    && cls_objects[1]->common.type == ACPI_TYPE_INTEGER) {\n\t\t\tclass_code[1] = (u8)cls_objects[1]->integer.value;\n\t\t}\n\t\tif (count > 2\n\t\t    && cls_objects[2]->common.type == ACPI_TYPE_INTEGER) {\n\t\t\tclass_code[2] = (u8)cls_objects[2]->integer.value;\n\t\t}\n\t}\n\n\t \n\n\tcls =\n\t    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_pnp_device_id) +\n\t\t\t\t (acpi_size)length);\n\tif (!cls) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tcls->string =\n\t    ACPI_ADD_PTR(char, cls, sizeof(struct acpi_pnp_device_id));\n\n\t \n\n\tacpi_ex_pci_cls_to_string(cls->string, class_code);\n\tcls->length = length;\n\t*return_id = cls;\n\ncleanup:\n\n\t \n\n\tacpi_ut_remove_reference(obj_desc);\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}