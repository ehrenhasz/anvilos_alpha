{
  "module_name": "nsconvert.c",
  "hash_id": "9a13a059c16e0a9e2726d99962512a3ec9c89d6868d19e9c065d4dee275a03c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/nsconvert.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"acinterp.h\"\n#include \"acpredef.h\"\n#include \"amlresrc.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\nACPI_MODULE_NAME(\"nsconvert\")\n\n \nacpi_status\nacpi_ns_convert_to_integer(union acpi_operand_object *original_object,\n\t\t\t   union acpi_operand_object **return_object)\n{\n\tunion acpi_operand_object *new_object;\n\tacpi_status status;\n\tu64 value = 0;\n\tu32 i;\n\n\tswitch (original_object->common.type) {\n\tcase ACPI_TYPE_STRING:\n\n\t\t \n\n\t\tstatus =\n\t\t    acpi_ut_strtoul64(original_object->string.pointer, &value);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\t \n\n\t\tif (original_object->buffer.length > 8) {\n\t\t\treturn (AE_AML_OPERAND_TYPE);\n\t\t}\n\n\t\t \n\n\t\tfor (i = 0; i < original_object->buffer.length; i++) {\n\t\t\tvalue |= ((u64)\n\t\t\t\t  original_object->buffer.pointer[i] << (i *\n\t\t\t\t\t\t\t\t\t 8));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\treturn (AE_AML_OPERAND_TYPE);\n\t}\n\n\tnew_object = acpi_ut_create_integer_object(value);\n\tif (!new_object) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\t*return_object = new_object;\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_ns_convert_to_string(union acpi_operand_object *original_object,\n\t\t\t  union acpi_operand_object **return_object)\n{\n\tunion acpi_operand_object *new_object;\n\tacpi_size length;\n\tacpi_status status;\n\n\tswitch (original_object->common.type) {\n\tcase ACPI_TYPE_INTEGER:\n\t\t \n\t\tif (original_object->integer.value == 0) {\n\n\t\t\t \n\n\t\t\tnew_object = acpi_ut_create_string_object(0);\n\t\t\tif (!new_object) {\n\t\t\t\treturn (AE_NO_MEMORY);\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = acpi_ex_convert_to_string(original_object,\n\t\t\t\t\t\t\t   &new_object,\n\t\t\t\t\t\t\t   ACPI_IMPLICIT_CONVERT_HEX);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn (status);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\t\t \n\t\tlength = 0;\n\t\twhile ((length < original_object->buffer.length) &&\n\t\t       (original_object->buffer.pointer[length])) {\n\t\t\tlength++;\n\t\t}\n\n\t\t \n\n\t\tnew_object = acpi_ut_create_string_object(length);\n\t\tif (!new_object) {\n\t\t\treturn (AE_NO_MEMORY);\n\t\t}\n\n\t\t \n\t\tmemcpy(new_object->string.pointer,\n\t\t       original_object->buffer.pointer, length);\n\t\tbreak;\n\n\tdefault:\n\n\t\treturn (AE_AML_OPERAND_TYPE);\n\t}\n\n\t*return_object = new_object;\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_ns_convert_to_buffer(union acpi_operand_object *original_object,\n\t\t\t  union acpi_operand_object **return_object)\n{\n\tunion acpi_operand_object *new_object;\n\tacpi_status status;\n\tunion acpi_operand_object **elements;\n\tu32 *dword_buffer;\n\tu32 count;\n\tu32 i;\n\n\tswitch (original_object->common.type) {\n\tcase ACPI_TYPE_INTEGER:\n\t\t \n\t\tstatus =\n\t\t    acpi_ex_convert_to_buffer(original_object, &new_object);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_STRING:\n\n\t\t \n\n\t\tnew_object = acpi_ut_create_buffer_object\n\t\t    (original_object->string.length);\n\t\tif (!new_object) {\n\t\t\treturn (AE_NO_MEMORY);\n\t\t}\n\n\t\tmemcpy(new_object->buffer.pointer,\n\t\t       original_object->string.pointer,\n\t\t       original_object->string.length);\n\t\tbreak;\n\n\tcase ACPI_TYPE_PACKAGE:\n\t\t \n\n\t\t \n\n\t\telements = original_object->package.elements;\n\t\tcount = original_object->package.count;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif ((!*elements) ||\n\t\t\t    ((*elements)->common.type != ACPI_TYPE_INTEGER)) {\n\t\t\t\treturn (AE_AML_OPERAND_TYPE);\n\t\t\t}\n\t\t\telements++;\n\t\t}\n\n\t\t \n\n\t\tnew_object = acpi_ut_create_buffer_object(ACPI_MUL_4(count));\n\t\tif (!new_object) {\n\t\t\treturn (AE_NO_MEMORY);\n\t\t}\n\n\t\t \n\n\t\telements = original_object->package.elements;\n\t\tdword_buffer = ACPI_CAST_PTR(u32, new_object->buffer.pointer);\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\t*dword_buffer = (u32)(*elements)->integer.value;\n\t\t\tdword_buffer++;\n\t\t\telements++;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\treturn (AE_AML_OPERAND_TYPE);\n\t}\n\n\t*return_object = new_object;\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_ns_convert_to_unicode(struct acpi_namespace_node *scope,\n\t\t\t   union acpi_operand_object *original_object,\n\t\t\t   union acpi_operand_object **return_object)\n{\n\tunion acpi_operand_object *new_object;\n\tchar *ascii_string;\n\tu16 *unicode_buffer;\n\tu32 unicode_length;\n\tu32 i;\n\n\tif (!original_object) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tif (original_object->common.type == ACPI_TYPE_BUFFER) {\n\t\tif (original_object->buffer.length < 2) {\n\t\t\treturn (AE_AML_OPERAND_VALUE);\n\t\t}\n\n\t\t*return_object = NULL;\n\t\treturn (AE_OK);\n\t}\n\n\t \n\tascii_string = original_object->string.pointer;\n\tunicode_length = (original_object->string.length * 2) + 2;\n\n\t \n\n\tnew_object = acpi_ut_create_buffer_object(unicode_length);\n\tif (!new_object) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\tunicode_buffer = ACPI_CAST_PTR(u16, new_object->buffer.pointer);\n\n\t \n\n\tfor (i = 0; i < original_object->string.length; i++) {\n\t\tunicode_buffer[i] = (u16)ascii_string[i];\n\t}\n\n\t*return_object = new_object;\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_ns_convert_to_resource(struct acpi_namespace_node *scope,\n\t\t\t    union acpi_operand_object *original_object,\n\t\t\t    union acpi_operand_object **return_object)\n{\n\tunion acpi_operand_object *new_object;\n\tu8 *buffer;\n\n\t \n\tif (original_object) {\n\t\tswitch (original_object->common.type) {\n\t\tcase ACPI_TYPE_INTEGER:\n\n\t\t\t \n\n\t\t\tif (original_object->integer.value) {\n\t\t\t\treturn (AE_AML_OPERAND_TYPE);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_BUFFER:\n\n\t\t\tif (original_object->buffer.length) {\n\n\t\t\t\t \n\n\t\t\t\t*return_object = NULL;\n\t\t\t\treturn (AE_OK);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_STRING:\n\t\tdefault:\n\n\t\t\treturn (AE_AML_OPERAND_TYPE);\n\t\t}\n\t}\n\n\t \n\n\tnew_object = acpi_ut_create_buffer_object(2);\n\tif (!new_object) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\tbuffer = ACPI_CAST_PTR(u8, new_object->buffer.pointer);\n\n\t \n\n\tbuffer[0] = (ACPI_RESOURCE_NAME_END_TAG | ASL_RDESC_END_TAG_SIZE);\n\tbuffer[1] = 0x00;\n\n\t*return_object = new_object;\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_ns_convert_to_reference(struct acpi_namespace_node *scope,\n\t\t\t     union acpi_operand_object *original_object,\n\t\t\t     union acpi_operand_object **return_object)\n{\n\tunion acpi_operand_object *new_object = NULL;\n\tacpi_status status;\n\tstruct acpi_namespace_node *node;\n\tunion acpi_generic_state scope_info;\n\tchar *name;\n\n\tACPI_FUNCTION_NAME(ns_convert_to_reference);\n\n\t \n\n\tstatus =\n\t    acpi_ns_internalize_name(original_object->string.pointer, &name);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tscope_info.scope.node =\n\t    ACPI_CAST_PTR(struct acpi_namespace_node, scope);\n\tstatus =\n\t    acpi_ns_lookup(&scope_info, name, ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,\n\t\t\t   ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,\n\t\t\t   NULL, &node);\n\tif (ACPI_FAILURE(status)) {\n\n\t\t \n\n\t\tACPI_ERROR_NAMESPACE(&scope_info,\n\t\t\t\t     original_object->string.pointer, status);\n\t\tgoto error_exit;\n\t}\n\n\t \n\n\tnew_object = acpi_ut_create_internal_object(ACPI_TYPE_LOCAL_REFERENCE);\n\tif (!new_object) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto error_exit;\n\t}\n\tnew_object->reference.node = node;\n\tnew_object->reference.object = node->object;\n\tnew_object->reference.class = ACPI_REFCLASS_NAME;\n\n\t \n\tacpi_ut_add_reference(node->object);\n\nerror_exit:\n\tACPI_FREE(name);\n\t*return_object = new_object;\n\treturn (status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}