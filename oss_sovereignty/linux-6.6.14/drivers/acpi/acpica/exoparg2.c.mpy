{
  "module_name": "exoparg2.c",
  "hash_id": "10b3a76bb186d66721605f5b9574b1a76f138c1f721d4b197bd52ba30237ba3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/exoparg2.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acparser.h\"\n#include \"acinterp.h\"\n#include \"acevents.h\"\n#include \"amlcode.h\"\n\n#define _COMPONENT          ACPI_EXECUTER\nACPI_MODULE_NAME(\"exoparg2\")\n\n \n \nacpi_status acpi_ex_opcode_2A_0T_0R(struct acpi_walk_state *walk_state)\n{\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\tstruct acpi_namespace_node *node;\n\tu32 value;\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE_STR(ex_opcode_2A_0T_0R,\n\t\t\t\tacpi_ps_get_opcode_name(walk_state->opcode));\n\n\t \n\n\tswitch (walk_state->opcode) {\n\tcase AML_NOTIFY_OP:\t \n\n\t\t \n\n\t\tnode = (struct acpi_namespace_node *)operand[0];\n\n\t\t \n\n\t\tvalue = (u32) operand[1]->integer.value;\n\n\t\t \n\n\t\tif (!acpi_ev_is_notify_object(node)) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Unexpected notify object type [%s]\",\n\t\t\t\t    acpi_ut_get_type_name(node->type)));\n\n\t\t\tstatus = AE_AML_OPERAND_TYPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tstatus = acpi_ev_queue_notify_request(node, value);\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"Unknown AML opcode 0x%X\",\n\t\t\t    walk_state->opcode));\n\t\tstatus = AE_AML_BAD_OPCODE;\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ex_opcode_2A_2T_1R(struct acpi_walk_state *walk_state)\n{\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\tunion acpi_operand_object *return_desc1 = NULL;\n\tunion acpi_operand_object *return_desc2 = NULL;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE_STR(ex_opcode_2A_2T_1R,\n\t\t\t\tacpi_ps_get_opcode_name(walk_state->opcode));\n\n\t \n\n\tswitch (walk_state->opcode) {\n\tcase AML_DIVIDE_OP:\n\n\t\t \n\n\t\treturn_desc1 =\n\t\t    acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);\n\t\tif (!return_desc1) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\treturn_desc2 =\n\t\t    acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);\n\t\tif (!return_desc2) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ut_divide(operand[0]->integer.value,\n\t\t\t\t\toperand[1]->integer.value,\n\t\t\t\t\t&return_desc1->integer.value,\n\t\t\t\t\t&return_desc2->integer.value);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"Unknown AML opcode 0x%X\",\n\t\t\t    walk_state->opcode));\n\n\t\tstatus = AE_AML_BAD_OPCODE;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tstatus = acpi_ex_store(return_desc2, operand[2], walk_state);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto cleanup;\n\t}\n\n\tstatus = acpi_ex_store(return_desc1, operand[3], walk_state);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\t \n\tacpi_ut_remove_reference(return_desc2);\n\n\tif (ACPI_FAILURE(status)) {\n\n\t\t \n\n\t\tacpi_ut_remove_reference(return_desc1);\n\t}\n\n\t \n\n\telse {\n\t\twalk_state->result_obj = return_desc1;\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ex_opcode_2A_1T_1R(struct acpi_walk_state *walk_state)\n{\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\tunion acpi_operand_object *return_desc = NULL;\n\tu64 index;\n\tacpi_status status = AE_OK;\n\tacpi_size length = 0;\n\n\tACPI_FUNCTION_TRACE_STR(ex_opcode_2A_1T_1R,\n\t\t\t\tacpi_ps_get_opcode_name(walk_state->opcode));\n\n\t \n\n\tif (walk_state->op_info->flags & AML_MATH) {\n\n\t\t \n\n\t\treturn_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);\n\t\tif (!return_desc) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\treturn_desc->integer.value =\n\t\t    acpi_ex_do_math_op(walk_state->opcode,\n\t\t\t\t       operand[0]->integer.value,\n\t\t\t\t       operand[1]->integer.value);\n\t\tgoto store_result_to_target;\n\t}\n\n\tswitch (walk_state->opcode) {\n\tcase AML_MOD_OP:\t \n\n\t\treturn_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);\n\t\tif (!return_desc) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ut_divide(operand[0]->integer.value,\n\t\t\t\t\toperand[1]->integer.value,\n\t\t\t\t\tNULL, &return_desc->integer.value);\n\t\tbreak;\n\n\tcase AML_CONCATENATE_OP:\t \n\n\t\tstatus =\n\t\t    acpi_ex_do_concatenate(operand[0], operand[1], &return_desc,\n\t\t\t\t\t   walk_state);\n\t\tbreak;\n\n\tcase AML_TO_STRING_OP:\t \n\t\t \n\n\t\t \n\t\twhile ((length < operand[0]->buffer.length) &&\t \n\t\t       (length < operand[1]->integer.value) &&\t \n\t\t       (operand[0]->buffer.pointer[length])) {\t \n\t\t\tlength++;\n\t\t}\n\n\t\t \n\n\t\treturn_desc = acpi_ut_create_string_object(length);\n\t\tif (!return_desc) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\tmemcpy(return_desc->string.pointer,\n\t\t       operand[0]->buffer.pointer, length);\n\t\tbreak;\n\n\tcase AML_CONCATENATE_TEMPLATE_OP:\n\n\t\t \n\n\t\tstatus =\n\t\t    acpi_ex_concat_template(operand[0], operand[1],\n\t\t\t\t\t    &return_desc, walk_state);\n\t\tbreak;\n\n\tcase AML_INDEX_OP:\t \n\n\t\t \n\n\t\treturn_desc =\n\t\t    acpi_ut_create_internal_object(ACPI_TYPE_LOCAL_REFERENCE);\n\t\tif (!return_desc) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\n\t\tindex = operand[1]->integer.value;\n\t\treturn_desc->reference.value = (u32) index;\n\t\treturn_desc->reference.class = ACPI_REFCLASS_INDEX;\n\n\t\t \n\t\tswitch ((operand[0])->common.type) {\n\t\tcase ACPI_TYPE_STRING:\n\n\t\t\tif (index >= operand[0]->string.length) {\n\t\t\t\tlength = operand[0]->string.length;\n\t\t\t\tstatus = AE_AML_STRING_LIMIT;\n\t\t\t}\n\n\t\t\treturn_desc->reference.target_type =\n\t\t\t    ACPI_TYPE_BUFFER_FIELD;\n\t\t\treturn_desc->reference.index_pointer =\n\t\t\t    &(operand[0]->buffer.pointer[index]);\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_BUFFER:\n\n\t\t\tif (index >= operand[0]->buffer.length) {\n\t\t\t\tlength = operand[0]->buffer.length;\n\t\t\t\tstatus = AE_AML_BUFFER_LIMIT;\n\t\t\t}\n\n\t\t\treturn_desc->reference.target_type =\n\t\t\t    ACPI_TYPE_BUFFER_FIELD;\n\t\t\treturn_desc->reference.index_pointer =\n\t\t\t    &(operand[0]->buffer.pointer[index]);\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_PACKAGE:\n\n\t\t\tif (index >= operand[0]->package.count) {\n\t\t\t\tlength = operand[0]->package.count;\n\t\t\t\tstatus = AE_AML_PACKAGE_LIMIT;\n\t\t\t}\n\n\t\t\treturn_desc->reference.target_type = ACPI_TYPE_PACKAGE;\n\t\t\treturn_desc->reference.where =\n\t\t\t    &operand[0]->package.elements[index];\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Invalid object type: %X\",\n\t\t\t\t    (operand[0])->common.type));\n\t\t\tstatus = AE_AML_INTERNAL;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_BIOS_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t     \"Index (0x%X%8.8X) is beyond end of object (length 0x%X)\",\n\t\t\t\t\t     ACPI_FORMAT_UINT64(index),\n\t\t\t\t\t     (u32)length));\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\treturn_desc->reference.object = operand[0];\n\t\tacpi_ut_add_reference(operand[0]);\n\n\t\t \n\n\t\tstatus = acpi_ex_store(return_desc, operand[2], walk_state);\n\n\t\t \n\n\t\twalk_state->result_obj = return_desc;\n\t\tgoto cleanup;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"Unknown AML opcode 0x%X\",\n\t\t\t    walk_state->opcode));\n\t\tstatus = AE_AML_BAD_OPCODE;\n\t\tbreak;\n\t}\n\nstore_result_to_target:\n\n\tif (ACPI_SUCCESS(status)) {\n\t\t \n\t\tstatus = acpi_ex_store(return_desc, operand[2], walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (!walk_state->result_obj) {\n\t\t\twalk_state->result_obj = return_desc;\n\t\t}\n\t}\n\ncleanup:\n\n\t \n\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ut_remove_reference(return_desc);\n\t\twalk_state->result_obj = NULL;\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ex_opcode_2A_0T_1R(struct acpi_walk_state *walk_state)\n{\n\tunion acpi_operand_object **operand = &walk_state->operands[0];\n\tunion acpi_operand_object *return_desc = NULL;\n\tacpi_status status = AE_OK;\n\tu8 logical_result = FALSE;\n\n\tACPI_FUNCTION_TRACE_STR(ex_opcode_2A_0T_1R,\n\t\t\t\tacpi_ps_get_opcode_name(walk_state->opcode));\n\n\t \n\n\treturn_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);\n\tif (!return_desc) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tif (walk_state->op_info->flags & AML_LOGICAL_NUMERIC) {\n\n\t\t \n\n\t\tstatus = acpi_ex_do_logical_numeric_op(walk_state->opcode,\n\t\t\t\t\t\t       operand[0]->integer.\n\t\t\t\t\t\t       value,\n\t\t\t\t\t\t       operand[1]->integer.\n\t\t\t\t\t\t       value, &logical_result);\n\t\tgoto store_logical_result;\n\t} else if (walk_state->op_info->flags & AML_LOGICAL) {\n\n\t\t \n\n\t\tstatus = acpi_ex_do_logical_op(walk_state->opcode, operand[0],\n\t\t\t\t\t       operand[1], &logical_result);\n\t\tgoto store_logical_result;\n\t}\n\n\tswitch (walk_state->opcode) {\n\tcase AML_ACQUIRE_OP:\t \n\n\t\tstatus =\n\t\t    acpi_ex_acquire_mutex(operand[1], operand[0], walk_state);\n\t\tif (status == AE_TIME) {\n\t\t\tlogical_result = TRUE;\t \n\t\t\tstatus = AE_OK;\n\t\t}\n\t\tbreak;\n\n\tcase AML_WAIT_OP:\t \n\n\t\tstatus = acpi_ex_system_wait_event(operand[1], operand[0]);\n\t\tif (status == AE_TIME) {\n\t\t\tlogical_result = TRUE;\t \n\t\t\tstatus = AE_OK;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"Unknown AML opcode 0x%X\",\n\t\t\t    walk_state->opcode));\n\n\t\tstatus = AE_AML_BAD_OPCODE;\n\t\tgoto cleanup;\n\t}\n\nstore_logical_result:\n\t \n\tif (logical_result) {\n\t\treturn_desc->integer.value = ACPI_UINT64_MAX;\n\t}\n\ncleanup:\n\n\t \n\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ut_remove_reference(return_desc);\n\t}\n\n\t \n\n\telse {\n\t\twalk_state->result_obj = return_desc;\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}