{
  "module_name": "utmutex.c",
  "hash_id": "4aff3e122fee4073b79a9509202ed53e92ac8feaf7d8f7eb2a7c661adee3dbc3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utmutex.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utmutex\")\n\n \nstatic acpi_status acpi_ut_create_mutex(acpi_mutex_handle mutex_id);\n\nstatic void acpi_ut_delete_mutex(acpi_mutex_handle mutex_id);\n\n \n\nacpi_status acpi_ut_mutex_initialize(void)\n{\n\tu32 i;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ut_mutex_initialize);\n\n\t \n\n\tfor (i = 0; i < ACPI_NUM_MUTEX; i++) {\n\t\tstatus = acpi_ut_create_mutex(i);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t}\n\n\t \n\n\tstatus = acpi_os_create_lock (&acpi_gbl_gpe_lock);\n\tif (ACPI_FAILURE (status)) {\n\t\treturn_ACPI_STATUS (status);\n\t}\n\n\tstatus = acpi_os_create_raw_lock(&acpi_gbl_hardware_lock);\n\tif (ACPI_FAILURE (status)) {\n\t\treturn_ACPI_STATUS (status);\n\t}\n\n\tstatus = acpi_os_create_lock(&acpi_gbl_reference_count_lock);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tstatus = acpi_os_create_mutex(&acpi_gbl_osi_mutex);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tstatus = acpi_ut_create_rw_lock(&acpi_gbl_namespace_rw_lock);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nvoid acpi_ut_mutex_terminate(void)\n{\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ut_mutex_terminate);\n\n\t \n\n\tfor (i = 0; i < ACPI_NUM_MUTEX; i++) {\n\t\tacpi_ut_delete_mutex(i);\n\t}\n\n\tacpi_os_delete_mutex(acpi_gbl_osi_mutex);\n\n\t \n\n\tacpi_os_delete_lock(acpi_gbl_gpe_lock);\n\tacpi_os_delete_raw_lock(acpi_gbl_hardware_lock);\n\tacpi_os_delete_lock(acpi_gbl_reference_count_lock);\n\n\t \n\n\tacpi_ut_delete_rw_lock(&acpi_gbl_namespace_rw_lock);\n\treturn_VOID;\n}\n\n \n\nstatic acpi_status acpi_ut_create_mutex(acpi_mutex_handle mutex_id)\n{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE_U32(ut_create_mutex, mutex_id);\n\n\tif (!acpi_gbl_mutex_info[mutex_id].mutex) {\n\t\tstatus =\n\t\t    acpi_os_create_mutex(&acpi_gbl_mutex_info[mutex_id].mutex);\n\t\tacpi_gbl_mutex_info[mutex_id].thread_id =\n\t\t    ACPI_MUTEX_NOT_ACQUIRED;\n\t\tacpi_gbl_mutex_info[mutex_id].use_count = 0;\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic void acpi_ut_delete_mutex(acpi_mutex_handle mutex_id)\n{\n\n\tACPI_FUNCTION_TRACE_U32(ut_delete_mutex, mutex_id);\n\n\tacpi_os_delete_mutex(acpi_gbl_mutex_info[mutex_id].mutex);\n\n\tacpi_gbl_mutex_info[mutex_id].mutex = NULL;\n\tacpi_gbl_mutex_info[mutex_id].thread_id = ACPI_MUTEX_NOT_ACQUIRED;\n\n\treturn_VOID;\n}\n\n \n\nacpi_status acpi_ut_acquire_mutex(acpi_mutex_handle mutex_id)\n{\n\tacpi_status status;\n\tacpi_thread_id this_thread_id;\n\n\tACPI_FUNCTION_NAME(ut_acquire_mutex);\n\n\tif (mutex_id > ACPI_MAX_MUTEX) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tthis_thread_id = acpi_os_get_thread_id();\n\n#ifdef ACPI_MUTEX_DEBUG\n\t{\n\t\tu32 i;\n\t\t \n\t\tfor (i = mutex_id; i < ACPI_NUM_MUTEX; i++) {\n\t\t\tif (acpi_gbl_mutex_info[i].thread_id == this_thread_id) {\n\t\t\t\tif (i == mutex_id) {\n\t\t\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t\t\t    \"Mutex [%s] already acquired by this thread [%u]\",\n\t\t\t\t\t\t    acpi_ut_get_mutex_name\n\t\t\t\t\t\t    (mutex_id),\n\t\t\t\t\t\t    (u32)this_thread_id));\n\n\t\t\t\t\treturn (AE_ALREADY_ACQUIRED);\n\t\t\t\t}\n\n\t\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t\t    \"Invalid acquire order: Thread %u owns [%s], wants [%s]\",\n\t\t\t\t\t    (u32)this_thread_id,\n\t\t\t\t\t    acpi_ut_get_mutex_name(i),\n\t\t\t\t\t    acpi_ut_get_mutex_name(mutex_id)));\n\n\t\t\t\treturn (AE_ACQUIRE_DEADLOCK);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tACPI_DEBUG_PRINT((ACPI_DB_MUTEX,\n\t\t\t  \"Thread %u attempting to acquire Mutex [%s]\\n\",\n\t\t\t  (u32)this_thread_id,\n\t\t\t  acpi_ut_get_mutex_name(mutex_id)));\n\n\tstatus =\n\t    acpi_os_acquire_mutex(acpi_gbl_mutex_info[mutex_id].mutex,\n\t\t\t\t  ACPI_WAIT_FOREVER);\n\tif (ACPI_SUCCESS(status)) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_MUTEX,\n\t\t\t\t  \"Thread %u acquired Mutex [%s]\\n\",\n\t\t\t\t  (u32)this_thread_id,\n\t\t\t\t  acpi_ut_get_mutex_name(mutex_id)));\n\n\t\tacpi_gbl_mutex_info[mutex_id].use_count++;\n\t\tacpi_gbl_mutex_info[mutex_id].thread_id = this_thread_id;\n\t} else {\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"Thread %u could not acquire Mutex [%s] (0x%X)\",\n\t\t\t\t(u32)this_thread_id,\n\t\t\t\tacpi_ut_get_mutex_name(mutex_id), mutex_id));\n\t}\n\n\treturn (status);\n}\n\n \n\nacpi_status acpi_ut_release_mutex(acpi_mutex_handle mutex_id)\n{\n\tACPI_FUNCTION_NAME(ut_release_mutex);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_MUTEX, \"Thread %u releasing Mutex [%s]\\n\",\n\t\t\t  (u32)acpi_os_get_thread_id(),\n\t\t\t  acpi_ut_get_mutex_name(mutex_id)));\n\n\tif (mutex_id > ACPI_MAX_MUTEX) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\tif (acpi_gbl_mutex_info[mutex_id].thread_id == ACPI_MUTEX_NOT_ACQUIRED) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Mutex [%s] (0x%X) is not acquired, cannot release\",\n\t\t\t    acpi_ut_get_mutex_name(mutex_id), mutex_id));\n\n\t\treturn (AE_NOT_ACQUIRED);\n\t}\n#ifdef ACPI_MUTEX_DEBUG\n\t{\n\t\tu32 i;\n\t\t \n\t\tfor (i = mutex_id; i < ACPI_NUM_MUTEX; i++) {\n\t\t\tif (acpi_gbl_mutex_info[i].thread_id ==\n\t\t\t    acpi_os_get_thread_id()) {\n\t\t\t\tif (i == mutex_id) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t\t    \"Invalid release order: owns [%s], releasing [%s]\",\n\t\t\t\t\t    acpi_ut_get_mutex_name(i),\n\t\t\t\t\t    acpi_ut_get_mutex_name(mutex_id)));\n\n\t\t\t\treturn (AE_RELEASE_DEADLOCK);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\t \n\n\tacpi_gbl_mutex_info[mutex_id].thread_id = ACPI_MUTEX_NOT_ACQUIRED;\n\n\tacpi_os_release_mutex(acpi_gbl_mutex_info[mutex_id].mutex);\n\treturn (AE_OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}