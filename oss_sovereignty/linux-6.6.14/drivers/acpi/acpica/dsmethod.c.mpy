{
  "module_name": "dsmethod.c",
  "hash_id": "ab187ba66d0c41e81b2a0f068f283b17c0fa36f305f293c1e6bd51c6d59579e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/dsmethod.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acdispat.h\"\n#include \"acinterp.h\"\n#include \"acnamesp.h\"\n#include \"acparser.h\"\n#include \"amlcode.h\"\n#include \"acdebug.h\"\n\n#define _COMPONENT          ACPI_DISPATCHER\nACPI_MODULE_NAME(\"dsmethod\")\n\n \nstatic acpi_status\nacpi_ds_detect_named_opcodes(struct acpi_walk_state *walk_state,\n\t\t\t     union acpi_parse_object **out_op);\n\nstatic acpi_status\nacpi_ds_create_method_mutex(union acpi_operand_object *method_desc);\n\n \n\nacpi_status\nacpi_ds_auto_serialize_method(struct acpi_namespace_node *node,\n\t\t\t      union acpi_operand_object *obj_desc)\n{\n\tacpi_status status;\n\tunion acpi_parse_object *op = NULL;\n\tstruct acpi_walk_state *walk_state;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_auto_serialize_method, node);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t  \"Method auto-serialization parse [%4.4s] %p\\n\",\n\t\t\t  acpi_ut_get_node_name(node), node));\n\n\t \n\n\top = acpi_ps_alloc_op(AML_METHOD_OP, obj_desc->method.aml_start);\n\tif (!op) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tacpi_ps_set_name(op, node->name.integer);\n\top->common.node = node;\n\n\t \n\n\twalk_state =\n\t    acpi_ds_create_walk_state(node->owner_id, NULL, NULL, NULL);\n\tif (!walk_state) {\n\t\tacpi_ps_free_op(op);\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tstatus = acpi_ds_init_aml_walk(walk_state, op, node,\n\t\t\t\t       obj_desc->method.aml_start,\n\t\t\t\t       obj_desc->method.aml_length, NULL, 0);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ds_delete_walk_state(walk_state);\n\t\tacpi_ps_free_op(op);\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\twalk_state->descending_callback = acpi_ds_detect_named_opcodes;\n\n\t \n\n\tstatus = acpi_ps_parse_aml(walk_state);\n\n\tacpi_ps_delete_parse_tree(op);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic acpi_status\nacpi_ds_detect_named_opcodes(struct acpi_walk_state *walk_state,\n\t\t\t     union acpi_parse_object **out_op)\n{\n\n\tACPI_FUNCTION_NAME(acpi_ds_detect_named_opcodes);\n\n\t \n\n\tif (!\n\t    (walk_state->op_info->\n\t     flags & (AML_NAMED | AML_CREATE | AML_FIELD))) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\twalk_state->method_desc->method.sync_level = 0;\n\twalk_state->method_desc->method.info_flags |=\n\t    (ACPI_METHOD_SERIALIZED | ACPI_METHOD_IGNORE_SYNC_LEVEL);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO,\n\t\t\t  \"Method serialized [%4.4s] %p - [%s] (%4.4X)\\n\",\n\t\t\t  walk_state->method_node->name.ascii,\n\t\t\t  walk_state->method_node, walk_state->op_info->name,\n\t\t\t  walk_state->opcode));\n\n\t \n\n\treturn (AE_CTRL_TERMINATE);\n}\n\n \n\nacpi_status\nacpi_ds_method_error(acpi_status status, struct acpi_walk_state *walk_state)\n{\n\tu32 aml_offset;\n\tacpi_name name = 0;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tif (ACPI_SUCCESS(status) || (status & AE_CODE_CONTROL)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\tif (acpi_gbl_exception_handler) {\n\n\t\t \n\n\t\tacpi_ex_exit_interpreter();\n\n\t\t \n\t\taml_offset = (u32)ACPI_PTR_DIFF(walk_state->aml,\n\t\t\t\t\t\twalk_state->parser_state.\n\t\t\t\t\t\taml_start);\n\n\t\tif (walk_state->method_node) {\n\t\t\tname = walk_state->method_node->name.integer;\n\t\t} else if (walk_state->deferred_node) {\n\t\t\tname = walk_state->deferred_node->name.integer;\n\t\t}\n\n\t\tstatus = acpi_gbl_exception_handler(status, name,\n\t\t\t\t\t\t    walk_state->opcode,\n\t\t\t\t\t\t    aml_offset, NULL);\n\t\tacpi_ex_enter_interpreter();\n\t}\n\n\tacpi_ds_clear_implicit_return(walk_state);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ds_dump_method_stack(status, walk_state, walk_state->op);\n\n\t\t \n\n#ifdef ACPI_DEBUGGER\n\t\tacpi_db_dump_method_info(status, walk_state);\n#endif\n\t}\n\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nacpi_ds_create_method_mutex(union acpi_operand_object *method_desc)\n{\n\tunion acpi_operand_object *mutex_desc;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ds_create_method_mutex);\n\n\t \n\n\tmutex_desc = acpi_ut_create_internal_object(ACPI_TYPE_MUTEX);\n\tif (!mutex_desc) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\t \n\n\tstatus = acpi_os_create_mutex(&mutex_desc->mutex.os_mutex);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_ut_delete_object_desc(mutex_desc);\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tmutex_desc->mutex.sync_level = method_desc->method.sync_level;\n\tmethod_desc->method.mutex = mutex_desc;\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,\n\t\t\t       union acpi_operand_object *obj_desc,\n\t\t\t       struct acpi_walk_state *walk_state)\n{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_begin_method_execution, method_node);\n\n\tif (!method_node) {\n\t\treturn_ACPI_STATUS(AE_NULL_ENTRY);\n\t}\n\n\tacpi_ex_start_trace_method(method_node, obj_desc, walk_state);\n\n\t \n\n\tif (obj_desc->method.thread_count == ACPI_UINT8_MAX) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Method reached maximum reentrancy limit (255)\"));\n\t\treturn_ACPI_STATUS(AE_AML_METHOD_LIMIT);\n\t}\n\n\t \n\tif (obj_desc->method.info_flags & ACPI_METHOD_SERIALIZED) {\n\t\t \n\t\tif (!obj_desc->method.mutex) {\n\t\t\tstatus = acpi_ds_create_method_mutex(obj_desc);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (walk_state &&\n\t\t    (!(obj_desc->method.\n\t\t       info_flags & ACPI_METHOD_IGNORE_SYNC_LEVEL))\n\t\t    && (walk_state->thread->current_sync_level >\n\t\t\tobj_desc->method.mutex->mutex.sync_level)) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Cannot acquire Mutex for method [%4.4s]\"\n\t\t\t\t    \", current SyncLevel is too large (%u)\",\n\t\t\t\t    acpi_ut_get_node_name(method_node),\n\t\t\t\t    walk_state->thread->current_sync_level));\n\n\t\t\treturn_ACPI_STATUS(AE_AML_MUTEX_ORDER);\n\t\t}\n\n\t\t \n\t\tif (!walk_state ||\n\t\t    !obj_desc->method.mutex->mutex.thread_id ||\n\t\t    (walk_state->thread->thread_id !=\n\t\t     obj_desc->method.mutex->mutex.thread_id)) {\n\t\t\t \n\t\t\tstatus =\n\t\t\t    acpi_ex_system_wait_mutex(obj_desc->method.mutex->\n\t\t\t\t\t\t      mutex.os_mutex,\n\t\t\t\t\t\t      ACPI_WAIT_FOREVER);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (walk_state) {\n\t\t\t\tobj_desc->method.mutex->mutex.\n\t\t\t\t    original_sync_level =\n\t\t\t\t    walk_state->thread->current_sync_level;\n\n\t\t\t\tobj_desc->method.mutex->mutex.thread_id =\n\t\t\t\t    walk_state->thread->thread_id;\n\n\t\t\t\t \n\t\t\t\tif (!(obj_desc->method.info_flags &\n\t\t\t\t      ACPI_METHOD_IGNORE_SYNC_LEVEL)) {\n\t\t\t\t\twalk_state->thread->current_sync_level =\n\t\t\t\t\t    obj_desc->method.sync_level;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tobj_desc->method.mutex->mutex.\n\t\t\t\t    original_sync_level =\n\t\t\t\t    obj_desc->method.mutex->mutex.sync_level;\n\n\t\t\t\tobj_desc->method.mutex->mutex.thread_id =\n\t\t\t\t    acpi_os_get_thread_id();\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tobj_desc->method.mutex->mutex.acquisition_depth++;\n\t}\n\n\t \n\tif (!obj_desc->method.owner_id) {\n\t\tstatus = acpi_ut_allocate_owner_id(&obj_desc->method.owner_id);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\tobj_desc->method.thread_count++;\n\tacpi_method_count++;\n\treturn_ACPI_STATUS(status);\n\ncleanup:\n\t \n\n\tif (obj_desc->method.mutex) {\n\t\tacpi_os_release_mutex(obj_desc->method.mutex->mutex.os_mutex);\n\t}\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ds_call_control_method(struct acpi_thread_state *thread,\n\t\t\t    struct acpi_walk_state *this_walk_state,\n\t\t\t    union acpi_parse_object *op)\n{\n\tacpi_status status;\n\tstruct acpi_namespace_node *method_node;\n\tstruct acpi_walk_state *next_walk_state = NULL;\n\tunion acpi_operand_object *obj_desc;\n\tstruct acpi_evaluate_info *info;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_call_control_method, this_walk_state);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  \"Calling method %p, currentstate=%p\\n\",\n\t\t\t  this_walk_state->prev_op, this_walk_state));\n\n\t \n\tmethod_node = this_walk_state->method_call_node;\n\tif (!method_node) {\n\t\treturn_ACPI_STATUS(AE_NULL_ENTRY);\n\t}\n\n\tobj_desc = acpi_ns_get_attached_object(method_node);\n\tif (!obj_desc) {\n\t\treturn_ACPI_STATUS(AE_NULL_OBJECT);\n\t}\n\n\t \n\n\tstatus =\n\t    acpi_ds_begin_method_execution(method_node, obj_desc,\n\t\t\t\t\t   this_walk_state);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\n\tnext_walk_state =\n\t    acpi_ds_create_walk_state(obj_desc->method.owner_id, NULL, obj_desc,\n\t\t\t\t      thread);\n\tif (!next_walk_state) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tthis_walk_state->operands[this_walk_state->num_operands] = NULL;\n\n\t \n\tinfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\n\tif (!info) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto pop_walk_state;\n\t}\n\n\tinfo->parameters = &this_walk_state->operands[0];\n\n\tstatus = acpi_ds_init_aml_walk(next_walk_state, NULL, method_node,\n\t\t\t\t       obj_desc->method.aml_start,\n\t\t\t\t       obj_desc->method.aml_length, info,\n\t\t\t\t       ACPI_IMODE_EXECUTE);\n\n\tACPI_FREE(info);\n\tif (ACPI_FAILURE(status)) {\n\t\tgoto pop_walk_state;\n\t}\n\n\tnext_walk_state->method_nesting_depth =\n\t    this_walk_state->method_nesting_depth + 1;\n\n\t \n\tfor (i = 0; i < obj_desc->method.param_count; i++) {\n\t\tacpi_ut_remove_reference(this_walk_state->operands[i]);\n\t\tthis_walk_state->operands[i] = NULL;\n\t}\n\n\t \n\n\tthis_walk_state->num_operands = 0;\n\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  \"**** Begin nested execution of [%4.4s] **** WalkState=%p\\n\",\n\t\t\t  method_node->name.ascii, next_walk_state));\n\n\tthis_walk_state->method_pathname =\n\t    acpi_ns_get_normalized_pathname(method_node, TRUE);\n\tthis_walk_state->method_is_nested = TRUE;\n\n\t \n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_EVALUATION,\n\t\t\t      \"%-26s:  %*s%s\\n\", \"   Nested method call\",\n\t\t\t      next_walk_state->method_nesting_depth * 3, \" \",\n\t\t\t      &this_walk_state->method_pathname[1]));\n\n\t \n\n\tif (obj_desc->method.info_flags & ACPI_METHOD_INTERNAL_ONLY) {\n\t\tstatus =\n\t\t    obj_desc->method.dispatch.implementation(next_walk_state);\n\t\tif (status == AE_OK) {\n\t\t\tstatus = AE_CTRL_TERMINATE;\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(status);\n\npop_walk_state:\n\n\t \n\n\tacpi_ds_pop_walk_state(thread);\n\ncleanup:\n\n\t \n\n\tacpi_ds_terminate_control_method(obj_desc, next_walk_state);\n\tacpi_ds_delete_walk_state(next_walk_state);\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ds_restart_control_method(struct acpi_walk_state *walk_state,\n\t\t\t       union acpi_operand_object *return_desc)\n{\n\tacpi_status status;\n\tint same_as_implicit_return;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_restart_control_method, walk_state);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  \"****Restart [%4.4s] Op %p ReturnValueFromCallee %p\\n\",\n\t\t\t  acpi_ut_get_node_name(walk_state->method_node),\n\t\t\t  walk_state->method_call_op, return_desc));\n\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  \"    ReturnFromThisMethodUsed?=%X ResStack %p Walk %p\\n\",\n\t\t\t  walk_state->return_used,\n\t\t\t  walk_state->results, walk_state));\n\n\t \n\n\tif (return_desc) {\n\n\t\t \n\n\t\tsame_as_implicit_return =\n\t\t    (walk_state->implicit_return_obj == return_desc);\n\n\t\t \n\n\t\tif (walk_state->return_used) {\n\n\t\t\t \n\n\t\t\tstatus = acpi_ds_result_push(return_desc, walk_state);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tacpi_ut_remove_reference(return_desc);\n\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t}\n\n\t\t\t \n\t\t\twalk_state->return_desc = return_desc;\n\t\t}\n\n\t\t \n\t\telse if (!acpi_ds_do_implicit_return\n\t\t\t (return_desc, walk_state, FALSE)\n\t\t\t || same_as_implicit_return) {\n\t\t\t \n\t\t\tacpi_ut_remove_reference(return_desc);\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nvoid\nacpi_ds_terminate_control_method(union acpi_operand_object *method_desc,\n\t\t\t\t struct acpi_walk_state *walk_state)\n{\n\n\tACPI_FUNCTION_TRACE_PTR(ds_terminate_control_method, walk_state);\n\n\t \n\n\tif (!method_desc) {\n\t\treturn_VOID;\n\t}\n\n\tif (walk_state) {\n\n\t\t \n\n\t\tacpi_ds_method_data_delete_all(walk_state);\n\n\t\t \n\t\tif (!(method_desc->method.info_flags & ACPI_METHOD_MODULE_LEVEL)\n\t\t    && (method_desc->method.thread_count == 1)) {\n\n\t\t\t \n\n\t\t\t(void)acpi_ex_exit_interpreter();\n\t\t\tacpi_ns_delete_namespace_subtree(walk_state->\n\t\t\t\t\t\t\t method_node);\n\t\t\t(void)acpi_ex_enter_interpreter();\n\n\t\t\t \n\t\t\tif (method_desc->method.\n\t\t\t    info_flags & ACPI_METHOD_MODIFIED_NAMESPACE) {\n\t\t\t\t(void)acpi_ex_exit_interpreter();\n\t\t\t\tacpi_ns_delete_namespace_by_owner(method_desc->\n\t\t\t\t\t\t\t\t  method.\n\t\t\t\t\t\t\t\t  owner_id);\n\t\t\t\t(void)acpi_ex_enter_interpreter();\n\t\t\t\tmethod_desc->method.info_flags &=\n\t\t\t\t    ~ACPI_METHOD_MODIFIED_NAMESPACE;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (method_desc->method.mutex) {\n\n\t\t\t \n\n\t\t\tmethod_desc->method.mutex->mutex.acquisition_depth--;\n\t\t\tif (!method_desc->method.mutex->mutex.acquisition_depth) {\n\t\t\t\twalk_state->thread->current_sync_level =\n\t\t\t\t    method_desc->method.mutex->mutex.\n\t\t\t\t    original_sync_level;\n\n\t\t\t\tacpi_os_release_mutex(method_desc->method.\n\t\t\t\t\t\t      mutex->mutex.os_mutex);\n\t\t\t\tmethod_desc->method.mutex->mutex.thread_id = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tif (method_desc->method.thread_count) {\n\t\tmethod_desc->method.thread_count--;\n\t} else {\n\t\tACPI_ERROR((AE_INFO, \"Invalid zero thread count in method\"));\n\t}\n\n\t \n\n\tif (method_desc->method.thread_count) {\n\t\t \n\t\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t\t  \"*** Completed execution of one thread, %u threads remaining\\n\",\n\t\t\t\t  method_desc->method.thread_count));\n\t} else {\n\t\t \n\n\t\t \n\t\tif (method_desc->method.\n\t\t    info_flags & ACPI_METHOD_SERIALIZED_PENDING) {\n\t\t\tif (walk_state) {\n\t\t\t\tACPI_INFO((\"Marking method %4.4s as Serialized \"\n\t\t\t\t\t   \"because of AE_ALREADY_EXISTS error\",\n\t\t\t\t\t   walk_state->method_node->name.\n\t\t\t\t\t   ascii));\n\t\t\t}\n\n\t\t\t \n\t\t\tmethod_desc->method.info_flags &=\n\t\t\t    ~ACPI_METHOD_SERIALIZED_PENDING;\n\n\t\t\tmethod_desc->method.info_flags |=\n\t\t\t    (ACPI_METHOD_SERIALIZED |\n\t\t\t     ACPI_METHOD_IGNORE_SYNC_LEVEL);\n\t\t\tmethod_desc->method.sync_level = 0;\n\t\t}\n\n\t\t \n\n\t\tif (!\n\t\t    (method_desc->method.\n\t\t     info_flags & ACPI_METHOD_MODULE_LEVEL)) {\n\t\t\tacpi_ut_release_owner_id(&method_desc->method.owner_id);\n\t\t}\n\t}\n\n\tacpi_ex_stop_trace_method((struct acpi_namespace_node *)method_desc->\n\t\t\t\t  method.node, method_desc, walk_state);\n\n\treturn_VOID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}