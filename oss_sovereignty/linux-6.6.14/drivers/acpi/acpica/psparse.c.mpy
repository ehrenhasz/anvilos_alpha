{
  "module_name": "psparse.c",
  "hash_id": "bf316aa140d4bcdc4b721b28979915e7bdc902c26964400a7bf629f787eb1987",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/psparse.c",
  "human_readable_source": "\n \n\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acparser.h\"\n#include \"acdispat.h\"\n#include \"amlcode.h\"\n#include \"acinterp.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_PARSER\nACPI_MODULE_NAME(\"psparse\")\n\n \nu32 acpi_ps_get_opcode_size(u32 opcode)\n{\n\n\t \n\n\tif (opcode > 0x00FF) {\n\t\treturn (2);\n\t}\n\n\t \n\n\treturn (1);\n}\n\n \n\nu16 acpi_ps_peek_opcode(struct acpi_parse_state * parser_state)\n{\n\tu8 *aml;\n\tu16 opcode;\n\n\taml = parser_state->aml;\n\topcode = (u16) ACPI_GET8(aml);\n\n\tif (opcode == AML_EXTENDED_PREFIX) {\n\n\t\t \n\n\t\taml++;\n\t\topcode = (u16) ((opcode << 8) | ACPI_GET8(aml));\n\t}\n\n\treturn (opcode);\n}\n\n \n\nacpi_status\nacpi_ps_complete_this_op(struct acpi_walk_state *walk_state,\n\t\t\t union acpi_parse_object *op)\n{\n\tunion acpi_parse_object *prev;\n\tunion acpi_parse_object *next;\n\tconst struct acpi_opcode_info *parent_info;\n\tunion acpi_parse_object *replacement_op = NULL;\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE_PTR(ps_complete_this_op, op);\n\n\t \n\n\tif (!op) {\n\t\treturn_ACPI_STATUS(AE_OK);\t \n\t}\n\n\tacpi_ex_stop_trace_opcode(op, walk_state);\n\n\t \n\n\tif (((walk_state->parse_flags & ACPI_PARSE_TREE_MASK) !=\n\t     ACPI_PARSE_DELETE_TREE)\n\t    || (walk_state->op_info->class == AML_CLASS_ARGUMENT)) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tif (op->common.parent) {\n\t\tprev = op->common.parent->common.value.arg;\n\t\tif (!prev) {\n\n\t\t\t \n\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\tparent_info =\n\t\t    acpi_ps_get_opcode_info(op->common.parent->common.\n\t\t\t\t\t    aml_opcode);\n\n\t\tswitch (parent_info->class) {\n\t\tcase AML_CLASS_CONTROL:\n\n\t\t\tbreak;\n\n\t\tcase AML_CLASS_CREATE:\n\t\t\t \n\t\t\treplacement_op =\n\t\t\t    acpi_ps_alloc_op(AML_INT_RETURN_VALUE_OP,\n\t\t\t\t\t     op->common.aml);\n\t\t\tif (!replacement_op) {\n\t\t\t\tstatus = AE_NO_MEMORY;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AML_CLASS_NAMED_OBJECT:\n\t\t\t \n\t\t\tif ((op->common.parent->common.aml_opcode ==\n\t\t\t     AML_REGION_OP)\n\t\t\t    || (op->common.parent->common.aml_opcode ==\n\t\t\t\tAML_DATA_REGION_OP)\n\t\t\t    || (op->common.parent->common.aml_opcode ==\n\t\t\t\tAML_BUFFER_OP)\n\t\t\t    || (op->common.parent->common.aml_opcode ==\n\t\t\t\tAML_PACKAGE_OP)\n\t\t\t    || (op->common.parent->common.aml_opcode ==\n\t\t\t\tAML_BANK_FIELD_OP)\n\t\t\t    || (op->common.parent->common.aml_opcode ==\n\t\t\t\tAML_VARIABLE_PACKAGE_OP)) {\n\t\t\t\treplacement_op =\n\t\t\t\t    acpi_ps_alloc_op(AML_INT_RETURN_VALUE_OP,\n\t\t\t\t\t\t     op->common.aml);\n\t\t\t\tif (!replacement_op) {\n\t\t\t\t\tstatus = AE_NO_MEMORY;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t    if ((op->common.parent->common.aml_opcode ==\n\t\t\t\t AML_NAME_OP)\n\t\t\t\t&& (walk_state->pass_number <=\n\t\t\t\t    ACPI_IMODE_LOAD_PASS2)) {\n\t\t\t\tif ((op->common.aml_opcode == AML_BUFFER_OP)\n\t\t\t\t    || (op->common.aml_opcode == AML_PACKAGE_OP)\n\t\t\t\t    || (op->common.aml_opcode ==\n\t\t\t\t\tAML_VARIABLE_PACKAGE_OP)) {\n\t\t\t\t\treplacement_op =\n\t\t\t\t\t    acpi_ps_alloc_op(op->common.\n\t\t\t\t\t\t\t     aml_opcode,\n\t\t\t\t\t\t\t     op->common.aml);\n\t\t\t\t\tif (!replacement_op) {\n\t\t\t\t\t\tstatus = AE_NO_MEMORY;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplacement_op->named.data =\n\t\t\t\t\t\t    op->named.data;\n\t\t\t\t\t\treplacement_op->named.length =\n\t\t\t\t\t\t    op->named.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treplacement_op =\n\t\t\t    acpi_ps_alloc_op(AML_INT_RETURN_VALUE_OP,\n\t\t\t\t\t     op->common.aml);\n\t\t\tif (!replacement_op) {\n\t\t\t\tstatus = AE_NO_MEMORY;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (prev == op) {\n\n\t\t\t \n\n\t\t\tif (replacement_op) {\n\t\t\t\treplacement_op->common.parent =\n\t\t\t\t    op->common.parent;\n\t\t\t\treplacement_op->common.value.arg = NULL;\n\t\t\t\treplacement_op->common.node = op->common.node;\n\t\t\t\top->common.parent->common.value.arg =\n\t\t\t\t    replacement_op;\n\t\t\t\treplacement_op->common.next = op->common.next;\n\t\t\t} else {\n\t\t\t\top->common.parent->common.value.arg =\n\t\t\t\t    op->common.next;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\telse\n\t\t\twhile (prev) {\n\n\t\t\t\t \n\n\t\t\t\tnext = prev->common.next;\n\t\t\t\tif (next == op) {\n\t\t\t\t\tif (replacement_op) {\n\t\t\t\t\t\treplacement_op->common.parent =\n\t\t\t\t\t\t    op->common.parent;\n\t\t\t\t\t\treplacement_op->common.value.\n\t\t\t\t\t\t    arg = NULL;\n\t\t\t\t\t\treplacement_op->common.node =\n\t\t\t\t\t\t    op->common.node;\n\t\t\t\t\t\tprev->common.next =\n\t\t\t\t\t\t    replacement_op;\n\t\t\t\t\t\treplacement_op->common.next =\n\t\t\t\t\t\t    op->common.next;\n\t\t\t\t\t\tnext = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprev->common.next =\n\t\t\t\t\t\t    op->common.next;\n\t\t\t\t\t\tnext = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprev = next;\n\t\t\t}\n\t}\n\ncleanup:\n\n\t \n\n\tacpi_ps_delete_parse_tree(op);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ps_next_parse_state(struct acpi_walk_state *walk_state,\n\t\t\t union acpi_parse_object *op,\n\t\t\t acpi_status callback_status)\n{\n\tstruct acpi_parse_state *parser_state = &walk_state->parser_state;\n\tacpi_status status = AE_CTRL_PENDING;\n\n\tACPI_FUNCTION_TRACE_PTR(ps_next_parse_state, op);\n\n\tswitch (callback_status) {\n\tcase AE_CTRL_TERMINATE:\n\t\t \n\t\tparser_state->aml = parser_state->aml_end;\n\t\tstatus = AE_CTRL_TERMINATE;\n\t\tbreak;\n\n\tcase AE_CTRL_BREAK:\n\n\t\tparser_state->aml = walk_state->aml_last_while;\n\t\twalk_state->control_state->common.value = FALSE;\n\t\tstatus = AE_CTRL_BREAK;\n\t\tbreak;\n\n\tcase AE_CTRL_CONTINUE:\n\n\t\tparser_state->aml = walk_state->aml_last_while;\n\t\tstatus = AE_CTRL_CONTINUE;\n\t\tbreak;\n\n\tcase AE_CTRL_PENDING:\n\n\t\tparser_state->aml = walk_state->aml_last_while;\n\t\tbreak;\n\n#if 0\n\tcase AE_CTRL_SKIP:\n\n\t\tparser_state->aml = parser_state->scope->parse_scope.pkg_end;\n\t\tstatus = AE_OK;\n\t\tbreak;\n#endif\n\n\tcase AE_CTRL_TRUE:\n\t\t \n\t\tparser_state->aml = acpi_ps_get_next_package_end(parser_state);\n\t\tstatus = AE_CTRL_PENDING;\n\t\tbreak;\n\n\tcase AE_CTRL_FALSE:\n\t\t \n\t\tparser_state->aml = parser_state->scope->parse_scope.pkg_end;\n\n\t\t \n\n\t\twalk_state->control_state->common.value = FALSE;\n\t\tstatus = AE_CTRL_END;\n\t\tbreak;\n\n\tcase AE_CTRL_TRANSFER:\n\n\t\t \n\n\t\tstatus = AE_CTRL_TRANSFER;\n\t\twalk_state->prev_op = op;\n\t\twalk_state->method_call_op = op;\n\t\twalk_state->method_call_node =\n\t\t    (op->common.value.arg)->common.node;\n\n\t\t \n\n\t\twalk_state->return_used =\n\t\t    acpi_ds_is_result_used(op, walk_state);\n\t\tbreak;\n\n\tdefault:\n\n\t\tstatus = callback_status;\n\t\tif (ACPI_CNTL_EXCEPTION(callback_status)) {\n\t\t\tstatus = AE_OK;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_ps_parse_aml(struct acpi_walk_state *walk_state)\n{\n\tacpi_status status;\n\tstruct acpi_thread_state *thread;\n\tstruct acpi_thread_state *prev_walk_list = acpi_gbl_current_walk_list;\n\tstruct acpi_walk_state *previous_walk_state;\n\n\tACPI_FUNCTION_TRACE(ps_parse_aml);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t  \"Entered with WalkState=%p Aml=%p size=%X\\n\",\n\t\t\t  walk_state, walk_state->parser_state.aml,\n\t\t\t  walk_state->parser_state.aml_size));\n\n\tif (!walk_state->parser_state.aml) {\n\t\treturn_ACPI_STATUS(AE_BAD_ADDRESS);\n\t}\n\n\t \n\n\tthread = acpi_ut_create_thread_state();\n\tif (!thread) {\n\t\tif (walk_state->method_desc) {\n\n\t\t\t \n\n\t\t\tacpi_ds_terminate_control_method(walk_state->\n\t\t\t\t\t\t\t method_desc,\n\t\t\t\t\t\t\t walk_state);\n\t\t}\n\n\t\tacpi_ds_delete_walk_state(walk_state);\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\twalk_state->thread = thread;\n\n\t \n\tif (walk_state->method_desc) {\n\t\twalk_state->thread->current_sync_level =\n\t\t    walk_state->method_desc->method.sync_level;\n\t}\n\n\tacpi_ds_push_walk_state(walk_state, thread);\n\n\t \n\tacpi_gbl_current_walk_list = thread;\n\n\t \n\tACPI_DEBUG_PRINT((ACPI_DB_PARSE, \"State=%p\\n\", walk_state));\n\n\tstatus = AE_OK;\n\twhile (walk_state) {\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\t \n\t\t\tstatus = acpi_ps_parse_loop(walk_state);\n\t\t}\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t\t  \"Completed one call to walk loop, %s State=%p\\n\",\n\t\t\t\t  acpi_format_exception(status), walk_state));\n\n\t\tif (walk_state->method_pathname && walk_state->method_is_nested) {\n\n\t\t\t \n\n\t\t\tACPI_DEBUG_PRINT_RAW((ACPI_DB_EVALUATION,\n\t\t\t\t\t      \"%-26s:  %*s%s\\n\",\n\t\t\t\t\t      \"   Exit nested method\",\n\t\t\t\t\t      (walk_state->\n\t\t\t\t\t       method_nesting_depth + 1) * 3,\n\t\t\t\t\t      \" \",\n\t\t\t\t\t      &walk_state->method_pathname[1]));\n\n\t\t\tACPI_FREE(walk_state->method_pathname);\n\t\t\twalk_state->method_is_nested = FALSE;\n\t\t}\n\t\tif (status == AE_CTRL_TRANSFER) {\n\t\t\t \n\t\t\tstatus =\n\t\t\t    acpi_ds_call_control_method(thread, walk_state,\n\t\t\t\t\t\t\tNULL);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tstatus =\n\t\t\t\t    acpi_ds_method_error(status, walk_state);\n\t\t\t}\n\n\t\t\t \n\t\t\twalk_state = acpi_ds_get_current_walk_state(thread);\n\t\t\tcontinue;\n\t\t} else if (status == AE_CTRL_TERMINATE) {\n\t\t\tstatus = AE_OK;\n\t\t} else if ((status != AE_OK) && (walk_state->method_desc)) {\n\n\t\t\t \n\n\t\t\tacpi_ex_exit_interpreter();\n\t\t\tif (status == AE_ABORT_METHOD) {\n\t\t\t\tacpi_ns_print_node_pathname(walk_state->\n\t\t\t\t\t\t\t    method_node,\n\t\t\t\t\t\t\t    \"Aborting method\");\n\t\t\t\tacpi_os_printf(\"\\n\");\n\t\t\t} else {\n\t\t\t\tACPI_ERROR_METHOD(\"Aborting method\",\n\t\t\t\t\t\t  walk_state->method_node, NULL,\n\t\t\t\t\t\t  status);\n\t\t\t}\n\t\t\tacpi_ex_enter_interpreter();\n\n\t\t\t \n\n\t\t\tif ((status == AE_ALREADY_EXISTS) &&\n\t\t\t    (!(walk_state->method_desc->method.info_flags &\n\t\t\t       ACPI_METHOD_SERIALIZED))) {\n\t\t\t\t \n\t\t\t\twalk_state->method_desc->method.info_flags |=\n\t\t\t\t    ACPI_METHOD_SERIALIZED_PENDING;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\twalk_state = acpi_ds_pop_walk_state(thread);\n\n\t\t \n\n\t\tacpi_ds_scope_stack_clear(walk_state);\n\n\t\t \n\t\tif (((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) ==\n\t\t     ACPI_PARSE_EXECUTE &&\n\t\t     !(walk_state->parse_flags & ACPI_PARSE_MODULE_LEVEL)) ||\n\t\t    (ACPI_FAILURE(status))) {\n\t\t\tacpi_ds_terminate_control_method(walk_state->\n\t\t\t\t\t\t\t method_desc,\n\t\t\t\t\t\t\t walk_state);\n\t\t}\n\n\t\t \n\n\t\tacpi_ps_cleanup_scope(&walk_state->parser_state);\n\t\tprevious_walk_state = walk_state;\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_PARSE,\n\t\t\t\t  \"ReturnValue=%p, ImplicitValue=%p State=%p\\n\",\n\t\t\t\t  walk_state->return_desc,\n\t\t\t\t  walk_state->implicit_return_obj, walk_state));\n\n\t\t \n\n\t\twalk_state = acpi_ds_get_current_walk_state(thread);\n\t\tif (walk_state) {\n\t\t\tif (ACPI_SUCCESS(status)) {\n\t\t\t\t \n\t\t\t\tif (!previous_walk_state->return_desc) {\n\t\t\t\t\t \n\t\t\t\t\tif (acpi_gbl_enable_interpreter_slack &&\n\t\t\t\t\t    !previous_walk_state->\n\t\t\t\t\t    implicit_return_obj) {\n\t\t\t\t\t\tprevious_walk_state->\n\t\t\t\t\t\t    implicit_return_obj =\n\t\t\t\t\t\t    acpi_ut_create_integer_object\n\t\t\t\t\t\t    ((u64) 0);\n\t\t\t\t\t\tif (!previous_walk_state->\n\t\t\t\t\t\t    implicit_return_obj) {\n\t\t\t\t\t\t\treturn_ACPI_STATUS\n\t\t\t\t\t\t\t    (AE_NO_MEMORY);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\n\t\t\t\t\tstatus =\n\t\t\t\t\t    acpi_ds_restart_control_method\n\t\t\t\t\t    (walk_state,\n\t\t\t\t\t     previous_walk_state->\n\t\t\t\t\t     implicit_return_obj);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tacpi_ds_clear_implicit_return\n\t\t\t\t\t    (previous_walk_state);\n\n\t\t\t\t\tstatus =\n\t\t\t\t\t    acpi_ds_restart_control_method\n\t\t\t\t\t    (walk_state,\n\t\t\t\t\t     previous_walk_state->return_desc);\n\t\t\t\t}\n\t\t\t\tif (ACPI_SUCCESS(status)) {\n\t\t\t\t\twalk_state->walk_type |=\n\t\t\t\t\t    ACPI_WALK_METHOD_RESTART;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\tacpi_ut_remove_reference(previous_walk_state->\n\t\t\t\t\t\t\t return_desc);\n\t\t\t\tacpi_ds_clear_implicit_return\n\t\t\t\t    (previous_walk_state);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\telse if (previous_walk_state->caller_return_desc) {\n\t\t\tif (previous_walk_state->implicit_return_obj) {\n\t\t\t\t*(previous_walk_state->caller_return_desc) =\n\t\t\t\t    previous_walk_state->implicit_return_obj;\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\t*(previous_walk_state->caller_return_desc) =\n\t\t\t\t    previous_walk_state->return_desc;\n\t\t\t}\n\t\t} else {\n\t\t\tif (previous_walk_state->return_desc) {\n\n\t\t\t\t \n\n\t\t\t\tacpi_ut_remove_reference(previous_walk_state->\n\t\t\t\t\t\t\t return_desc);\n\t\t\t}\n\t\t\tif (previous_walk_state->implicit_return_obj) {\n\n\t\t\t\t \n\n\t\t\t\tacpi_ut_remove_reference(previous_walk_state->\n\t\t\t\t\t\t\t implicit_return_obj);\n\t\t\t}\n\t\t}\n\n\t\tacpi_ds_delete_walk_state(previous_walk_state);\n\t}\n\n\t \n\n\tacpi_ex_release_all_mutexes(thread);\n\tacpi_ut_delete_generic_state(ACPI_CAST_PTR\n\t\t\t\t     (union acpi_generic_state, thread));\n\tacpi_gbl_current_walk_list = prev_walk_list;\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}