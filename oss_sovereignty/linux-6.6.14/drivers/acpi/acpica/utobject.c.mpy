{
  "module_name": "utobject.c",
  "hash_id": "34f9ac4541cf8d07a04c45be0272dfb863465d6012916fd4dd835761c390430e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/utobject.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include <linux/kmemleak.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_UTILITIES\nACPI_MODULE_NAME(\"utobject\")\n\n \nstatic acpi_status\nacpi_ut_get_simple_object_size(union acpi_operand_object *obj,\n\t\t\t       acpi_size *obj_length);\n\nstatic acpi_status\nacpi_ut_get_package_object_size(union acpi_operand_object *obj,\n\t\t\t\tacpi_size *obj_length);\n\nstatic acpi_status\nacpi_ut_get_element_length(u8 object_type,\n\t\t\t   union acpi_operand_object *source_object,\n\t\t\t   union acpi_generic_state *state, void *context);\n\n \n\nunion acpi_operand_object *acpi_ut_create_internal_object_dbg(const char\n\t\t\t\t\t\t\t      *module_name,\n\t\t\t\t\t\t\t      u32 line_number,\n\t\t\t\t\t\t\t      u32 component_id,\n\t\t\t\t\t\t\t      acpi_object_type\n\t\t\t\t\t\t\t      type)\n{\n\tunion acpi_operand_object *object;\n\tunion acpi_operand_object *second_object;\n\n\tACPI_FUNCTION_TRACE_STR(ut_create_internal_object_dbg,\n\t\t\t\tacpi_ut_get_type_name(type));\n\n\t \n\n\tobject =\n\t    acpi_ut_allocate_object_desc_dbg(module_name, line_number,\n\t\t\t\t\t     component_id);\n\tif (!object) {\n\t\treturn_PTR(NULL);\n\t}\n\tkmemleak_not_leak(object);\n\n\tswitch (type) {\n\tcase ACPI_TYPE_REGION:\n\tcase ACPI_TYPE_BUFFER_FIELD:\n\tcase ACPI_TYPE_LOCAL_BANK_FIELD:\n\n\t\t \n\n\t\tsecond_object =\n\t\t    acpi_ut_allocate_object_desc_dbg(module_name, line_number,\n\t\t\t\t\t\t     component_id);\n\t\tif (!second_object) {\n\t\t\tacpi_ut_delete_object_desc(object);\n\t\t\treturn_PTR(NULL);\n\t\t}\n\n\t\tsecond_object->common.type = ACPI_TYPE_LOCAL_EXTRA;\n\t\tsecond_object->common.reference_count = 1;\n\n\t\t \n\n\t\tobject->common.next_object = second_object;\n\t\tbreak;\n\n\tdefault:\n\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\n\tobject->common.type = (u8) type;\n\n\t \n\n\tobject->common.reference_count = 1;\n\n\t \n\n\treturn_PTR(object);\n}\n\n \n\nunion acpi_operand_object *acpi_ut_create_package_object(u32 count)\n{\n\tunion acpi_operand_object *package_desc;\n\tunion acpi_operand_object **package_elements;\n\n\tACPI_FUNCTION_TRACE_U32(ut_create_package_object, count);\n\n\t \n\n\tpackage_desc = acpi_ut_create_internal_object(ACPI_TYPE_PACKAGE);\n\tif (!package_desc) {\n\t\treturn_PTR(NULL);\n\t}\n\n\t \n\tpackage_elements = ACPI_ALLOCATE_ZEROED(((acpi_size)count +\n\t\t\t\t\t\t 1) * sizeof(void *));\n\tif (!package_elements) {\n\t\tACPI_FREE(package_desc);\n\t\treturn_PTR(NULL);\n\t}\n\n\tpackage_desc->package.count = count;\n\tpackage_desc->package.elements = package_elements;\n\treturn_PTR(package_desc);\n}\n\n \n\nunion acpi_operand_object *acpi_ut_create_integer_object(u64 initial_value)\n{\n\tunion acpi_operand_object *integer_desc;\n\n\tACPI_FUNCTION_TRACE(ut_create_integer_object);\n\n\t \n\n\tinteger_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);\n\tif (!integer_desc) {\n\t\treturn_PTR(NULL);\n\t}\n\n\tinteger_desc->integer.value = initial_value;\n\treturn_PTR(integer_desc);\n}\n\n \n\nunion acpi_operand_object *acpi_ut_create_buffer_object(acpi_size buffer_size)\n{\n\tunion acpi_operand_object *buffer_desc;\n\tu8 *buffer = NULL;\n\n\tACPI_FUNCTION_TRACE_U32(ut_create_buffer_object, buffer_size);\n\n\t \n\n\tbuffer_desc = acpi_ut_create_internal_object(ACPI_TYPE_BUFFER);\n\tif (!buffer_desc) {\n\t\treturn_PTR(NULL);\n\t}\n\n\t \n\n\tif (buffer_size > 0) {\n\n\t\t \n\n\t\tbuffer = ACPI_ALLOCATE_ZEROED(buffer_size);\n\t\tif (!buffer) {\n\t\t\tACPI_ERROR((AE_INFO, \"Could not allocate size %u\",\n\t\t\t\t    (u32)buffer_size));\n\n\t\t\tacpi_ut_remove_reference(buffer_desc);\n\t\t\treturn_PTR(NULL);\n\t\t}\n\t}\n\n\t \n\n\tbuffer_desc->buffer.flags |= AOPOBJ_DATA_VALID;\n\tbuffer_desc->buffer.pointer = buffer;\n\tbuffer_desc->buffer.length = (u32) buffer_size;\n\n\t \n\n\treturn_PTR(buffer_desc);\n}\n\n \n\nunion acpi_operand_object *acpi_ut_create_string_object(acpi_size string_size)\n{\n\tunion acpi_operand_object *string_desc;\n\tchar *string;\n\n\tACPI_FUNCTION_TRACE_U32(ut_create_string_object, string_size);\n\n\t \n\n\tstring_desc = acpi_ut_create_internal_object(ACPI_TYPE_STRING);\n\tif (!string_desc) {\n\t\treturn_PTR(NULL);\n\t}\n\n\t \n\tstring = ACPI_ALLOCATE_ZEROED(string_size + 1);\n\tif (!string) {\n\t\tACPI_ERROR((AE_INFO, \"Could not allocate size %u\",\n\t\t\t    (u32)string_size));\n\n\t\tacpi_ut_remove_reference(string_desc);\n\t\treturn_PTR(NULL);\n\t}\n\n\t \n\n\tstring_desc->string.pointer = string;\n\tstring_desc->string.length = (u32) string_size;\n\n\t \n\n\treturn_PTR(string_desc);\n}\n\n \n\nu8 acpi_ut_valid_internal_object(void *object)\n{\n\n\tACPI_FUNCTION_NAME(ut_valid_internal_object);\n\n\t \n\n\tif (!object) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_EXEC, \"**** Null Object Ptr\\n\"));\n\t\treturn (FALSE);\n\t}\n\n\t \n\n\tswitch (ACPI_GET_DESCRIPTOR_TYPE(object)) {\n\tcase ACPI_DESC_TYPE_OPERAND:\n\n\t\t \n\n\t\treturn (TRUE);\n\n\tdefault:\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t\t  \"%p is not an ACPI operand obj [%s]\\n\",\n\t\t\t\t  object, acpi_ut_get_descriptor_name(object)));\n\t\tbreak;\n\t}\n\n\treturn (FALSE);\n}\n\n \n\nvoid *acpi_ut_allocate_object_desc_dbg(const char *module_name,\n\t\t\t\t       u32 line_number, u32 component_id)\n{\n\tunion acpi_operand_object *object;\n\n\tACPI_FUNCTION_TRACE(ut_allocate_object_desc_dbg);\n\n\tobject = acpi_os_acquire_object(acpi_gbl_operand_cache);\n\tif (!object) {\n\t\tACPI_ERROR((module_name, line_number,\n\t\t\t    \"Could not allocate an object descriptor\"));\n\n\t\treturn_PTR(NULL);\n\t}\n\n\t \n\n\tACPI_SET_DESCRIPTOR_TYPE(object, ACPI_DESC_TYPE_OPERAND);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, \"%p Size %X\\n\",\n\t\t\t  object, (u32) sizeof(union acpi_operand_object)));\n\n\treturn_PTR(object);\n}\n\n \n\nvoid acpi_ut_delete_object_desc(union acpi_operand_object *object)\n{\n\tACPI_FUNCTION_TRACE_PTR(ut_delete_object_desc, object);\n\n\t \n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(object) != ACPI_DESC_TYPE_OPERAND) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"%p is not an ACPI Operand object [%s]\", object,\n\t\t\t    acpi_ut_get_descriptor_name(object)));\n\t\treturn_VOID;\n\t}\n\n\t(void)acpi_os_release_object(acpi_gbl_operand_cache, object);\n\treturn_VOID;\n}\n\n \n\nstatic acpi_status\nacpi_ut_get_simple_object_size(union acpi_operand_object *internal_object,\n\t\t\t       acpi_size *obj_length)\n{\n\tacpi_size length;\n\tacpi_size size;\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE_PTR(ut_get_simple_object_size, internal_object);\n\n\t \n\n\tlength = sizeof(union acpi_object);\n\n\t \n\n\tif (!internal_object) {\n\t \n\t\t*obj_length = ACPI_ROUND_UP_TO_NATIVE_WORD(length);\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(internal_object) == ACPI_DESC_TYPE_NAMED) {\n\n\t\t \n\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Received a namespace node [%4.4s] \"\n\t\t\t    \"where an operand object is required\",\n\t\t\t    ACPI_CAST_PTR(struct acpi_namespace_node,\n\t\t\t\t\t  internal_object)->name.ascii));\n\t\treturn_ACPI_STATUS(AE_AML_INTERNAL);\n\t}\n\n\t \n\tswitch (internal_object->common.type) {\n\tcase ACPI_TYPE_STRING:\n\n\t\tlength += (acpi_size)internal_object->string.length + 1;\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\tlength += (acpi_size)internal_object->buffer.length;\n\t\tbreak;\n\n\tcase ACPI_TYPE_INTEGER:\n\tcase ACPI_TYPE_PROCESSOR:\n\tcase ACPI_TYPE_POWER:\n\n\t\t \n\n\t\tbreak;\n\n\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\n\t\tswitch (internal_object->reference.class) {\n\t\tcase ACPI_REFCLASS_NAME:\n\t\t\t \n\t\t\tsize =\n\t\t\t    acpi_ns_get_pathname_length(internal_object->\n\t\t\t\t\t\t\treference.node);\n\t\t\tif (!size) {\n\t\t\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t\t\t}\n\n\t\t\tlength += ACPI_ROUND_UP_TO_NATIVE_WORD(size);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Cannot convert to external object - \"\n\t\t\t\t    \"unsupported Reference Class [%s] 0x%X in object %p\",\n\t\t\t\t    acpi_ut_get_reference_name(internal_object),\n\t\t\t\t    internal_object->reference.class,\n\t\t\t\t    internal_object));\n\t\t\tstatus = AE_TYPE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"Cannot convert to external object - \"\n\t\t\t    \"unsupported type [%s] 0x%X in object %p\",\n\t\t\t    acpi_ut_get_object_type_name(internal_object),\n\t\t\t    internal_object->common.type, internal_object));\n\t\tstatus = AE_TYPE;\n\t\tbreak;\n\t}\n\n\t \n\t*obj_length = ACPI_ROUND_UP_TO_NATIVE_WORD(length);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic acpi_status\nacpi_ut_get_element_length(u8 object_type,\n\t\t\t   union acpi_operand_object *source_object,\n\t\t\t   union acpi_generic_state *state, void *context)\n{\n\tacpi_status status = AE_OK;\n\tstruct acpi_pkg_info *info = (struct acpi_pkg_info *)context;\n\tacpi_size object_space;\n\n\tswitch (object_type) {\n\tcase ACPI_COPY_TYPE_SIMPLE:\n\t\t \n\t\tstatus =\n\t\t    acpi_ut_get_simple_object_size(source_object,\n\t\t\t\t\t\t   &object_space);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\n\t\tinfo->length += object_space;\n\t\tbreak;\n\n\tcase ACPI_COPY_TYPE_PACKAGE:\n\n\t\t \n\n\t\tinfo->num_packages++;\n\t\tstate->pkg.this_target_obj = NULL;\n\t\tbreak;\n\n\tdefault:\n\n\t\t \n\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nacpi_ut_get_package_object_size(union acpi_operand_object *internal_object,\n\t\t\t\tacpi_size *obj_length)\n{\n\tacpi_status status;\n\tstruct acpi_pkg_info info;\n\n\tACPI_FUNCTION_TRACE_PTR(ut_get_package_object_size, internal_object);\n\n\tinfo.length = 0;\n\tinfo.object_space = 0;\n\tinfo.num_packages = 1;\n\n\tstatus =\n\t    acpi_ut_walk_package_tree(internal_object, NULL,\n\t\t\t\t      acpi_ut_get_element_length, &info);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\tinfo.length +=\n\t    ACPI_ROUND_UP_TO_NATIVE_WORD(sizeof(union acpi_object)) *\n\t    (acpi_size)info.num_packages;\n\n\t \n\n\t*obj_length = info.length;\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ut_get_object_size(union acpi_operand_object *internal_object,\n\t\t\tacpi_size *obj_length)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tif ((ACPI_GET_DESCRIPTOR_TYPE(internal_object) ==\n\t     ACPI_DESC_TYPE_OPERAND) &&\n\t    (internal_object->common.type == ACPI_TYPE_PACKAGE)) {\n\t\tstatus =\n\t\t    acpi_ut_get_package_object_size(internal_object,\n\t\t\t\t\t\t    obj_length);\n\t} else {\n\t\tstatus =\n\t\t    acpi_ut_get_simple_object_size(internal_object, obj_length);\n\t}\n\n\treturn (status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}