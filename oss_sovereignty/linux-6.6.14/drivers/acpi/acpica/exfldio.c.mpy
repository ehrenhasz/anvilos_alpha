{
  "module_name": "exfldio.c",
  "hash_id": "ab3cbb262969e9f48a95f20e7de965acdd2d715dc923f02c77dd577da5ad0b7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/exfldio.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acinterp.h\"\n#include \"amlcode.h\"\n#include \"acevents.h\"\n#include \"acdispat.h\"\n\n#define _COMPONENT          ACPI_EXECUTER\nACPI_MODULE_NAME(\"exfldio\")\n\n \nstatic acpi_status\nacpi_ex_field_datum_io(union acpi_operand_object *obj_desc,\n\t\t       u32 field_datum_byte_offset, u64 *value, u32 read_write);\n\nstatic u8\nacpi_ex_register_overflow(union acpi_operand_object *obj_desc, u64 value);\n\nstatic acpi_status\nacpi_ex_setup_region(union acpi_operand_object *obj_desc,\n\t\t     u32 field_datum_byte_offset);\n\n \n\nstatic acpi_status\nacpi_ex_setup_region(union acpi_operand_object *obj_desc,\n\t\t     u32 field_datum_byte_offset)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_operand_object *rgn_desc;\n\tu8 space_id;\n\n\tACPI_FUNCTION_TRACE_U32(ex_setup_region, field_datum_byte_offset);\n\n\trgn_desc = obj_desc->common_field.region_obj;\n\n\t \n\n\tif (rgn_desc->common.type != ACPI_TYPE_REGION) {\n\t\tACPI_ERROR((AE_INFO, \"Needed Region, found type 0x%X (%s)\",\n\t\t\t    rgn_desc->common.type,\n\t\t\t    acpi_ut_get_object_type_name(rgn_desc)));\n\n\t\treturn_ACPI_STATUS(AE_AML_OPERAND_TYPE);\n\t}\n\n\tspace_id = rgn_desc->region.space_id;\n\n\t \n\n\tif (!acpi_is_valid_space_id(space_id)) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Invalid/unknown Address Space ID: 0x%2.2X\",\n\t\t\t    space_id));\n\t\treturn_ACPI_STATUS(AE_AML_INVALID_SPACE_ID);\n\t}\n\n\t \n\tif (!(rgn_desc->common.flags & AOPOBJ_DATA_VALID)) {\n\t\tstatus = acpi_ds_get_region_arguments(rgn_desc);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t}\n\n\t \n\tif (space_id == ACPI_ADR_SPACE_SMBUS ||\n\t    space_id == ACPI_ADR_SPACE_GSBUS ||\n\t    space_id == ACPI_ADR_SPACE_IPMI) {\n\n\t\t \n\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n#ifdef ACPI_UNDER_DEVELOPMENT\n\t \n\tif (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t}\n#endif\n\n\t \n\tif (rgn_desc->region.length <\n\t    (obj_desc->common_field.base_byte_offset + field_datum_byte_offset +\n\t     obj_desc->common_field.access_byte_width)) {\n\t\tif (acpi_gbl_enable_interpreter_slack) {\n\t\t\t \n\t\t\tif (ACPI_ROUND_UP(rgn_desc->region.length,\n\t\t\t\t\t  obj_desc->common_field.\n\t\t\t\t\t  access_byte_width) >=\n\t\t\t    ((acpi_size)obj_desc->common_field.\n\t\t\t     base_byte_offset +\n\t\t\t     obj_desc->common_field.access_byte_width +\n\t\t\t     field_datum_byte_offset)) {\n\t\t\t\treturn_ACPI_STATUS(AE_OK);\n\t\t\t}\n\t\t}\n\n\t\tif (rgn_desc->region.length <\n\t\t    obj_desc->common_field.access_byte_width) {\n\t\t\t \n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Field [%4.4s] access width (%u bytes) \"\n\t\t\t\t    \"too large for region [%4.4s] (length %u)\",\n\t\t\t\t    acpi_ut_get_node_name(obj_desc->\n\t\t\t\t\t\t\t  common_field.node),\n\t\t\t\t    obj_desc->common_field.access_byte_width,\n\t\t\t\t    acpi_ut_get_node_name(rgn_desc->region.\n\t\t\t\t\t\t\t  node),\n\t\t\t\t    rgn_desc->region.length));\n\t\t}\n\n\t\t \n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Field [%4.4s] Base+Offset+Width %u+%u+%u \"\n\t\t\t    \"is beyond end of region [%4.4s] (length %u)\",\n\t\t\t    acpi_ut_get_node_name(obj_desc->common_field.node),\n\t\t\t    obj_desc->common_field.base_byte_offset,\n\t\t\t    field_datum_byte_offset,\n\t\t\t    obj_desc->common_field.access_byte_width,\n\t\t\t    acpi_ut_get_node_name(rgn_desc->region.node),\n\t\t\t    rgn_desc->region.length));\n\n\t\treturn_ACPI_STATUS(AE_AML_REGION_LIMIT);\n\t}\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ex_access_region(union acpi_operand_object *obj_desc,\n\t\t      u32 field_datum_byte_offset, u64 *value, u32 function)\n{\n\tacpi_status status;\n\tunion acpi_operand_object *rgn_desc;\n\tu32 region_offset;\n\n\tACPI_FUNCTION_TRACE(ex_access_region);\n\n\t \n\tstatus = acpi_ex_setup_region(obj_desc, field_datum_byte_offset);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t \n\trgn_desc = obj_desc->common_field.region_obj;\n\tregion_offset =\n\t    obj_desc->common_field.base_byte_offset + field_datum_byte_offset;\n\n\tif ((function & ACPI_IO_MASK) == ACPI_READ) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_BFIELD, \"[READ]\"));\n\t} else {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_BFIELD, \"[WRITE]\"));\n\t}\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_BFIELD,\n\t\t\t      \" Region [%s:%X], Width %X, ByteBase %X, Offset %X at %8.8X%8.8X\\n\",\n\t\t\t      acpi_ut_get_region_name(rgn_desc->region.\n\t\t\t\t\t\t      space_id),\n\t\t\t      rgn_desc->region.space_id,\n\t\t\t      obj_desc->common_field.access_byte_width,\n\t\t\t      obj_desc->common_field.base_byte_offset,\n\t\t\t      field_datum_byte_offset,\n\t\t\t      ACPI_FORMAT_UINT64(rgn_desc->region.address +\n\t\t\t\t\t\t region_offset)));\n\n\t \n\n\tstatus = acpi_ev_address_space_dispatch(rgn_desc, obj_desc,\n\t\t\t\t\t\tfunction, region_offset,\n\t\t\t\t\t\tACPI_MUL_8(obj_desc->\n\t\t\t\t\t\t\t   common_field.\n\t\t\t\t\t\t\t   access_byte_width),\n\t\t\t\t\t\tvalue);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status == AE_NOT_IMPLEMENTED) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Region %s (ID=%u) not implemented\",\n\t\t\t\t    acpi_ut_get_region_name(rgn_desc->region.\n\t\t\t\t\t\t\t    space_id),\n\t\t\t\t    rgn_desc->region.space_id));\n\t\t} else if (status == AE_NOT_EXIST) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Region %s (ID=%u) has no handler\",\n\t\t\t\t    acpi_ut_get_region_name(rgn_desc->region.\n\t\t\t\t\t\t\t    space_id),\n\t\t\t\t    rgn_desc->region.space_id));\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nstatic u8\nacpi_ex_register_overflow(union acpi_operand_object *obj_desc, u64 value)\n{\n\n\tif (obj_desc->common_field.bit_length >= ACPI_INTEGER_BIT_SIZE) {\n\t\t \n\t\treturn (FALSE);\n\t}\n\n\tif (value >= ((u64) 1 << obj_desc->common_field.bit_length)) {\n\t\t \n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Index value 0x%8.8X%8.8X overflows field width 0x%X\",\n\t\t\t    ACPI_FORMAT_UINT64(value),\n\t\t\t    obj_desc->common_field.bit_length));\n\n\t\treturn (TRUE);\n\t}\n\n\t \n\n\treturn (FALSE);\n}\n\n \n\nstatic acpi_status\nacpi_ex_field_datum_io(union acpi_operand_object *obj_desc,\n\t\t       u32 field_datum_byte_offset, u64 *value, u32 read_write)\n{\n\tacpi_status status;\n\tu64 local_value;\n\n\tACPI_FUNCTION_TRACE_U32(ex_field_datum_io, field_datum_byte_offset);\n\n\tif (read_write == ACPI_READ) {\n\t\tif (!value) {\n\t\t\tlocal_value = 0;\n\n\t\t\t \n\t\t\tvalue = &local_value;\n\t\t}\n\n\t\t \n\n\t\t*value = 0;\n\t}\n\n\t \n\tswitch (obj_desc->common.type) {\n\tcase ACPI_TYPE_BUFFER_FIELD:\n\t\t \n\t\tif (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {\n\t\t\tstatus = acpi_ds_get_buffer_field_arguments(obj_desc);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t}\n\t\t}\n\n\t\tif (read_write == ACPI_READ) {\n\t\t\t \n\t\t\tmemcpy(value,\n\t\t\t       (obj_desc->buffer_field.buffer_obj)->buffer.\n\t\t\t       pointer +\n\t\t\t       obj_desc->buffer_field.base_byte_offset +\n\t\t\t       field_datum_byte_offset,\n\t\t\t       obj_desc->common_field.access_byte_width);\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy((obj_desc->buffer_field.buffer_obj)->buffer.\n\t\t\t       pointer +\n\t\t\t       obj_desc->buffer_field.base_byte_offset +\n\t\t\t       field_datum_byte_offset, value,\n\t\t\t       obj_desc->common_field.access_byte_width);\n\t\t}\n\n\t\tstatus = AE_OK;\n\t\tbreak;\n\n\tcase ACPI_TYPE_LOCAL_BANK_FIELD:\n\t\t \n\t\tif (acpi_ex_register_overflow(obj_desc->bank_field.bank_obj,\n\t\t\t\t\t      (u64) obj_desc->bank_field.\n\t\t\t\t\t      value)) {\n\t\t\treturn_ACPI_STATUS(AE_AML_REGISTER_LIMIT);\n\t\t}\n\n\t\t \n\t\tstatus =\n\t\t    acpi_ex_insert_into_field(obj_desc->bank_field.bank_obj,\n\t\t\t\t\t      &obj_desc->bank_field.value,\n\t\t\t\t\t      sizeof(obj_desc->bank_field.\n\t\t\t\t\t\t     value));\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\t \n\n\t\tACPI_FALLTHROUGH;\n\n\tcase ACPI_TYPE_LOCAL_REGION_FIELD:\n\t\t \n\t\tstatus =\n\t\t    acpi_ex_access_region(obj_desc, field_datum_byte_offset,\n\t\t\t\t\t  value, read_write);\n\t\tbreak;\n\n\tcase ACPI_TYPE_LOCAL_INDEX_FIELD:\n\t\t \n\t\tif (acpi_ex_register_overflow(obj_desc->index_field.index_obj,\n\t\t\t\t\t      (u64) obj_desc->index_field.\n\t\t\t\t\t      value)) {\n\t\t\treturn_ACPI_STATUS(AE_AML_REGISTER_LIMIT);\n\t\t}\n\n\t\t \n\n\t\tfield_datum_byte_offset += obj_desc->index_field.value;\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\n\t\t\t\t  \"Write to Index Register: Value %8.8X\\n\",\n\t\t\t\t  field_datum_byte_offset));\n\n\t\tstatus =\n\t\t    acpi_ex_insert_into_field(obj_desc->index_field.index_obj,\n\t\t\t\t\t      &field_datum_byte_offset,\n\t\t\t\t\t      sizeof(field_datum_byte_offset));\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\tif (read_write == ACPI_READ) {\n\n\t\t\t \n\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\n\t\t\t\t\t  \"Read from Data Register\\n\"));\n\n\t\t\tstatus =\n\t\t\t    acpi_ex_extract_from_field(obj_desc->index_field.\n\t\t\t\t\t\t       data_obj, value,\n\t\t\t\t\t\t       sizeof(u64));\n\t\t} else {\n\t\t\t \n\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\n\t\t\t\t\t  \"Write to Data Register: Value %8.8X%8.8X\\n\",\n\t\t\t\t\t  ACPI_FORMAT_UINT64(*value)));\n\n\t\t\tstatus =\n\t\t\t    acpi_ex_insert_into_field(obj_desc->index_field.\n\t\t\t\t\t\t      data_obj, value,\n\t\t\t\t\t\t      sizeof(u64));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"Wrong object type in field I/O %u\",\n\t\t\t    obj_desc->common.type));\n\t\tstatus = AE_AML_INTERNAL;\n\t\tbreak;\n\t}\n\n\tif (ACPI_SUCCESS(status)) {\n\t\tif (read_write == ACPI_READ) {\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\n\t\t\t\t\t  \"Value Read %8.8X%8.8X, Width %u\\n\",\n\t\t\t\t\t  ACPI_FORMAT_UINT64(*value),\n\t\t\t\t\t  obj_desc->common_field.\n\t\t\t\t\t  access_byte_width));\n\t\t} else {\n\t\t\tACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\n\t\t\t\t\t  \"Value Written %8.8X%8.8X, Width %u\\n\",\n\t\t\t\t\t  ACPI_FORMAT_UINT64(*value),\n\t\t\t\t\t  obj_desc->common_field.\n\t\t\t\t\t  access_byte_width));\n\t\t}\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ex_write_with_update_rule(union acpi_operand_object *obj_desc,\n\t\t\t       u64 mask,\n\t\t\t       u64 field_value, u32 field_datum_byte_offset)\n{\n\tacpi_status status = AE_OK;\n\tu64 merged_value;\n\tu64 current_value;\n\n\tACPI_FUNCTION_TRACE_U32(ex_write_with_update_rule, mask);\n\n\t \n\n\tmerged_value = field_value;\n\n\t \n\n\tif (mask != ACPI_UINT64_MAX) {\n\n\t\t \n\n\t\tswitch (obj_desc->common_field.\n\t\t\tfield_flags & AML_FIELD_UPDATE_RULE_MASK) {\n\t\tcase AML_FIELD_UPDATE_PRESERVE:\n\t\t\t \n\t\t\tif ((~mask << (ACPI_MUL_8(sizeof(mask)) -\n\t\t\t\t       ACPI_MUL_8(obj_desc->common_field.\n\t\t\t\t\t\t  access_byte_width))) != 0) {\n\t\t\t\t \n\t\t\t\tstatus =\n\t\t\t\t    acpi_ex_field_datum_io(obj_desc,\n\t\t\t\t\t\t\t   field_datum_byte_offset,\n\t\t\t\t\t\t\t   &current_value,\n\t\t\t\t\t\t\t   ACPI_READ);\n\t\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t\t}\n\n\t\t\t\tmerged_value |= (current_value & ~mask);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AML_FIELD_UPDATE_WRITE_AS_ONES:\n\n\t\t\t \n\n\t\t\tmerged_value |= ~mask;\n\t\t\tbreak;\n\n\t\tcase AML_FIELD_UPDATE_WRITE_AS_ZEROS:\n\n\t\t\t \n\n\t\t\tmerged_value &= mask;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Unknown UpdateRule value: 0x%X\",\n\t\t\t\t    (obj_desc->common_field.field_flags &\n\t\t\t\t     AML_FIELD_UPDATE_RULE_MASK)));\n\t\t\treturn_ACPI_STATUS(AE_AML_OPERAND_VALUE);\n\t\t}\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_BFIELD,\n\t\t\t  \"Mask %8.8X%8.8X, DatumOffset %X, Width %X, \"\n\t\t\t  \"Value %8.8X%8.8X, MergedValue %8.8X%8.8X\\n\",\n\t\t\t  ACPI_FORMAT_UINT64(mask),\n\t\t\t  field_datum_byte_offset,\n\t\t\t  obj_desc->common_field.access_byte_width,\n\t\t\t  ACPI_FORMAT_UINT64(field_value),\n\t\t\t  ACPI_FORMAT_UINT64(merged_value)));\n\n\t \n\n\tstatus =\n\t    acpi_ex_field_datum_io(obj_desc, field_datum_byte_offset,\n\t\t\t\t   &merged_value, ACPI_WRITE);\n\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ex_extract_from_field(union acpi_operand_object *obj_desc,\n\t\t\t   void *buffer, u32 buffer_length)\n{\n\tacpi_status status;\n\tu64 raw_datum;\n\tu64 merged_datum;\n\tu32 field_offset = 0;\n\tu32 buffer_offset = 0;\n\tu32 buffer_tail_bits;\n\tu32 datum_count;\n\tu32 field_datum_count;\n\tu32 access_bit_width;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ex_extract_from_field);\n\n\t \n\n\tif (buffer_length <\n\t    ACPI_ROUND_BITS_UP_TO_BYTES(obj_desc->common_field.bit_length)) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Field size %u (bits) is too large for buffer (%u)\",\n\t\t\t    obj_desc->common_field.bit_length, buffer_length));\n\n\t\treturn_ACPI_STATUS(AE_BUFFER_OVERFLOW);\n\t}\n\n\tmemset(buffer, 0, buffer_length);\n\taccess_bit_width = ACPI_MUL_8(obj_desc->common_field.access_byte_width);\n\n\t \n\n\tif ((obj_desc->common_field.start_field_bit_offset == 0) &&\n\t    (obj_desc->common_field.bit_length == access_bit_width)) {\n\t\tif (buffer_length >= sizeof(u64)) {\n\t\t\tstatus =\n\t\t\t    acpi_ex_field_datum_io(obj_desc, 0, buffer,\n\t\t\t\t\t\t   ACPI_READ);\n\t\t} else {\n\t\t\t \n\n\t\t\tstatus =\n\t\t\t    acpi_ex_field_datum_io(obj_desc, 0, &raw_datum,\n\t\t\t\t\t\t   ACPI_READ);\n\t\t\tmemcpy(buffer, &raw_datum, buffer_length);\n\t\t}\n\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n \n\n\t \n\n\tif (obj_desc->common_field.access_byte_width > sizeof(u64)) {\n\t\tobj_desc->common_field.access_byte_width = sizeof(u64);\n\t\taccess_bit_width = sizeof(u64) * 8;\n\t}\n\n\t \n\n\tdatum_count =\n\t    ACPI_ROUND_UP_TO(obj_desc->common_field.bit_length,\n\t\t\t     access_bit_width);\n\n\tfield_datum_count = ACPI_ROUND_UP_TO(obj_desc->common_field.bit_length +\n\t\t\t\t\t     obj_desc->common_field.\n\t\t\t\t\t     start_field_bit_offset,\n\t\t\t\t\t     access_bit_width);\n\n\t \n\n\tstatus =\n\t    acpi_ex_field_datum_io(obj_desc, field_offset, &raw_datum,\n\t\t\t\t   ACPI_READ);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\tmerged_datum =\n\t    raw_datum >> obj_desc->common_field.start_field_bit_offset;\n\n\t \n\n\tfor (i = 1; i < field_datum_count; i++) {\n\n\t\t \n\n\t\tfield_offset += obj_desc->common_field.access_byte_width;\n\t\tstatus =\n\t\t    acpi_ex_field_datum_io(obj_desc, field_offset, &raw_datum,\n\t\t\t\t\t   ACPI_READ);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\t \n\t\tif (access_bit_width -\n\t\t    obj_desc->common_field.start_field_bit_offset <\n\t\t    ACPI_INTEGER_BIT_SIZE) {\n\t\t\tmerged_datum |=\n\t\t\t    raw_datum << (access_bit_width -\n\t\t\t\t\t  obj_desc->common_field.\n\t\t\t\t\t  start_field_bit_offset);\n\t\t}\n\n\t\tif (i == datum_count) {\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tmemcpy(((char *)buffer) + buffer_offset, &merged_datum,\n\t\t       ACPI_MIN(obj_desc->common_field.access_byte_width,\n\t\t\t\tbuffer_length - buffer_offset));\n\n\t\tbuffer_offset += obj_desc->common_field.access_byte_width;\n\t\tmerged_datum =\n\t\t    raw_datum >> obj_desc->common_field.start_field_bit_offset;\n\t}\n\n\t \n\n\tbuffer_tail_bits = obj_desc->common_field.bit_length % access_bit_width;\n\tif (buffer_tail_bits) {\n\t\tmerged_datum &= ACPI_MASK_BITS_ABOVE(buffer_tail_bits);\n\t}\n\n\t \n\n\tmemcpy(((char *)buffer) + buffer_offset, &merged_datum,\n\t       ACPI_MIN(obj_desc->common_field.access_byte_width,\n\t\t\tbuffer_length - buffer_offset));\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status\nacpi_ex_insert_into_field(union acpi_operand_object *obj_desc,\n\t\t\t  void *buffer, u32 buffer_length)\n{\n\tvoid *new_buffer;\n\tacpi_status status;\n\tu64 mask;\n\tu64 width_mask;\n\tu64 merged_datum;\n\tu64 raw_datum = 0;\n\tu32 field_offset = 0;\n\tu32 buffer_offset = 0;\n\tu32 buffer_tail_bits;\n\tu32 datum_count;\n\tu32 field_datum_count;\n\tu32 access_bit_width;\n\tu32 required_length;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ex_insert_into_field);\n\n\t \n\n\tnew_buffer = NULL;\n\trequired_length =\n\t    ACPI_ROUND_BITS_UP_TO_BYTES(obj_desc->common_field.bit_length);\n\n\t \n\tif (buffer_length < required_length) {\n\n\t\t \n\n\t\tnew_buffer = ACPI_ALLOCATE_ZEROED(required_length);\n\t\tif (!new_buffer) {\n\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t}\n\n\t\t \n\t\tmemcpy((char *)new_buffer, (char *)buffer, buffer_length);\n\t\tbuffer = new_buffer;\n\t\tbuffer_length = required_length;\n\t}\n\n \n\n\t \n\tif (obj_desc->common_field.access_byte_width > sizeof(u64)) {\n\t\tobj_desc->common_field.access_byte_width = sizeof(u64);\n\t}\n\n\taccess_bit_width = ACPI_MUL_8(obj_desc->common_field.access_byte_width);\n\n\t \n\n\twidth_mask = ACPI_MASK_BITS_ABOVE_64(access_bit_width);\n\tmask = width_mask &\n\t    ACPI_MASK_BITS_BELOW(obj_desc->common_field.start_field_bit_offset);\n\n\t \n\n\tdatum_count = ACPI_ROUND_UP_TO(obj_desc->common_field.bit_length,\n\t\t\t\t       access_bit_width);\n\n\tfield_datum_count = ACPI_ROUND_UP_TO(obj_desc->common_field.bit_length +\n\t\t\t\t\t     obj_desc->common_field.\n\t\t\t\t\t     start_field_bit_offset,\n\t\t\t\t\t     access_bit_width);\n\n\t \n\n\tmemcpy(&raw_datum, buffer,\n\t       ACPI_MIN(obj_desc->common_field.access_byte_width,\n\t\t\tbuffer_length - buffer_offset));\n\n\tmerged_datum =\n\t    raw_datum << obj_desc->common_field.start_field_bit_offset;\n\n\t \n\n\tfor (i = 1; i < field_datum_count; i++) {\n\n\t\t \n\n\t\tmerged_datum &= mask;\n\t\tstatus =\n\t\t    acpi_ex_write_with_update_rule(obj_desc, mask, merged_datum,\n\t\t\t\t\t\t   field_offset);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\tfield_offset += obj_desc->common_field.access_byte_width;\n\n\t\t \n\t\tif ((access_bit_width -\n\t\t     obj_desc->common_field.start_field_bit_offset) <\n\t\t    ACPI_INTEGER_BIT_SIZE) {\n\t\t\tmerged_datum =\n\t\t\t    raw_datum >> (access_bit_width -\n\t\t\t\t\t  obj_desc->common_field.\n\t\t\t\t\t  start_field_bit_offset);\n\t\t} else {\n\t\t\tmerged_datum = 0;\n\t\t}\n\n\t\tmask = width_mask;\n\n\t\tif (i == datum_count) {\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tbuffer_offset += obj_desc->common_field.access_byte_width;\n\t\tmemcpy(&raw_datum, ((char *)buffer) + buffer_offset,\n\t\t       ACPI_MIN(obj_desc->common_field.access_byte_width,\n\t\t\t\tbuffer_length - buffer_offset));\n\n\t\tmerged_datum |=\n\t\t    raw_datum << obj_desc->common_field.start_field_bit_offset;\n\t}\n\n\t \n\n\tbuffer_tail_bits = (obj_desc->common_field.bit_length +\n\t\t\t    obj_desc->common_field.start_field_bit_offset) %\n\t    access_bit_width;\n\tif (buffer_tail_bits) {\n\t\tmask &= ACPI_MASK_BITS_ABOVE(buffer_tail_bits);\n\t}\n\n\t \n\n\tmerged_datum &= mask;\n\tstatus =\n\t    acpi_ex_write_with_update_rule(obj_desc, mask, merged_datum,\n\t\t\t\t\t   field_offset);\n\nexit:\n\t \n\n\tif (new_buffer) {\n\t\tACPI_FREE(new_buffer);\n\t}\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}