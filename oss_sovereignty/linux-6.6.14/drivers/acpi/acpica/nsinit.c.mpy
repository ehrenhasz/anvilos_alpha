{
  "module_name": "nsinit.c",
  "hash_id": "dfb6e5762e47c6032e6e029311ac6e4cf75470fd7ae038090f2afb9e64a65dd5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/nsinit.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"acdispat.h\"\n#include \"acinterp.h\"\n#include \"acevents.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\nACPI_MODULE_NAME(\"nsinit\")\n\n \nstatic acpi_status\nacpi_ns_init_one_object(acpi_handle obj_handle,\n\t\t\tu32 level, void *context, void **return_value);\n\nstatic acpi_status\nacpi_ns_init_one_device(acpi_handle obj_handle,\n\t\t\tu32 nesting_level, void *context, void **return_value);\n\nstatic acpi_status\nacpi_ns_find_ini_methods(acpi_handle obj_handle,\n\t\t\t u32 nesting_level, void *context, void **return_value);\n\n \n\nacpi_status acpi_ns_initialize_objects(void)\n{\n\tacpi_status status;\n\tstruct acpi_init_walk_info info;\n\n\tACPI_FUNCTION_TRACE(ns_initialize_objects);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t  \"[Init] Completing Initialization of ACPI Objects\\n\"));\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  \"**** Starting initialization of namespace objects ****\\n\"));\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,\n\t\t\t      \"Final data object initialization: \"));\n\n\t \n\n\tmemset(&info, 0, sizeof(struct acpi_init_walk_info));\n\n\t \n\n\t \n\tstatus = acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\n\t\t\t\t     ACPI_UINT32_MAX, acpi_ns_init_one_object,\n\t\t\t\t     NULL, &info, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status, \"During WalkNamespace\"));\n\t}\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,\n\t\t\t      \"Namespace contains %u (0x%X) objects\\n\",\n\t\t\t      info.object_count, info.object_count));\n\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  \"%u Control Methods found\\n%u Op Regions found\\n\",\n\t\t\t  info.method_count, info.op_region_count));\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status acpi_ns_initialize_devices(u32 flags)\n{\n\tacpi_status status = AE_OK;\n\tstruct acpi_device_walk_info info;\n\tacpi_handle handle;\n\n\tACPI_FUNCTION_TRACE(ns_initialize_devices);\n\n\tif (!(flags & ACPI_NO_DEVICE_INIT)) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t\t  \"[Init] Initializing ACPI Devices\\n\"));\n\n\t\t \n\n\t\tinfo.device_count = 0;\n\t\tinfo.num_STA = 0;\n\t\tinfo.num_INI = 0;\n\n\t\tACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,\n\t\t\t\t      \"Initializing Device/Processor/Thermal objects \"\n\t\t\t\t      \"and executing _INI/_STA methods:\\n\"));\n\n\t\t \n\n\t\tstatus = acpi_ns_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\n\t\t\t\t\t\tACPI_UINT32_MAX, FALSE,\n\t\t\t\t\t\tacpi_ns_find_ini_methods, NULL,\n\t\t\t\t\t\t&info, NULL);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto error_exit;\n\t\t}\n\n\t\t \n\n\t\tinfo.evaluate_info =\n\t\t    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\n\t\tif (!info.evaluate_info) {\n\t\t\tstatus = AE_NO_MEMORY;\n\t\t\tgoto error_exit;\n\t\t}\n\n\t\t \n\t\tinfo.evaluate_info->prefix_node = acpi_gbl_root_node;\n\t\tinfo.evaluate_info->relative_pathname = METHOD_NAME__INI;\n\t\tinfo.evaluate_info->parameters = NULL;\n\t\tinfo.evaluate_info->flags = ACPI_IGNORE_RETURN_VALUE;\n\n\t\tstatus = acpi_ns_evaluate(info.evaluate_info);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tinfo.num_INI++;\n\t\t}\n\n\t\t \n\t\tstatus = acpi_get_handle(NULL, \"\\\\_SB\", &handle);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tmemset(info.evaluate_info, 0,\n\t\t\t       sizeof(struct acpi_evaluate_info));\n\t\t\tinfo.evaluate_info->prefix_node = handle;\n\t\t\tinfo.evaluate_info->relative_pathname =\n\t\t\t    METHOD_NAME__INI;\n\t\t\tinfo.evaluate_info->parameters = NULL;\n\t\t\tinfo.evaluate_info->flags = ACPI_IGNORE_RETURN_VALUE;\n\n\t\t\tstatus = acpi_ns_evaluate(info.evaluate_info);\n\t\t\tif (ACPI_SUCCESS(status)) {\n\t\t\t\tinfo.num_INI++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!(flags & ACPI_NO_ADDRESS_SPACE_INIT)) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t\t  \"[Init] Executing _REG OpRegion methods\\n\"));\n\n\t\tstatus = acpi_ev_initialize_op_regions();\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto error_exit;\n\t\t}\n\t}\n\n\tif (!(flags & ACPI_NO_DEVICE_INIT)) {\n\n\t\t \n\n\t\tstatus = acpi_ns_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\n\t\t\t\t\t\tACPI_UINT32_MAX, FALSE,\n\t\t\t\t\t\tacpi_ns_init_one_device, NULL,\n\t\t\t\t\t\t&info, NULL);\n\n\t\t \n\t\tif (acpi_gbl_osi_data >= ACPI_OSI_WIN_2000) {\n\t\t\tacpi_gbl_truncate_io_addresses = TRUE;\n\t\t}\n\n\t\tACPI_FREE(info.evaluate_info);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tgoto error_exit;\n\t\t}\n\n\t\tACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,\n\t\t\t\t      \"    Executed %u _INI methods requiring %u _STA executions \"\n\t\t\t\t      \"(examined %u objects)\\n\",\n\t\t\t\t      info.num_INI, info.num_STA,\n\t\t\t\t      info.device_count));\n\t}\n\n\treturn_ACPI_STATUS(status);\n\nerror_exit:\n\tACPI_EXCEPTION((AE_INFO, status, \"During device initialization\"));\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status\nacpi_ns_init_one_package(acpi_handle obj_handle,\n\t\t\t u32 level, void *context, void **return_value)\n{\n\tacpi_status status;\n\tunion acpi_operand_object *obj_desc;\n\tstruct acpi_namespace_node *node =\n\t    (struct acpi_namespace_node *)obj_handle;\n\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (!obj_desc) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tif (obj_desc->package.flags & AOPOBJ_DATA_VALID) {\n\t\treturn (AE_OK);\n\t}\n\n\tstatus = acpi_ds_get_package_arguments(obj_desc);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (AE_OK);\n\t}\n\n\tstatus =\n\t    acpi_ut_walk_package_tree(obj_desc, NULL,\n\t\t\t\t      acpi_ds_init_package_element, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (AE_OK);\n\t}\n\n\tobj_desc->package.flags |= AOPOBJ_DATA_VALID;\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_ns_init_one_object(acpi_handle obj_handle,\n\t\t\tu32 level, void *context, void **return_value)\n{\n\tacpi_object_type type;\n\tacpi_status status = AE_OK;\n\tstruct acpi_init_walk_info *info =\n\t    (struct acpi_init_walk_info *)context;\n\tstruct acpi_namespace_node *node =\n\t    (struct acpi_namespace_node *)obj_handle;\n\tunion acpi_operand_object *obj_desc;\n\n\tACPI_FUNCTION_NAME(ns_init_one_object);\n\n\tinfo->object_count++;\n\n\t \n\n\ttype = acpi_ns_get_type(obj_handle);\n\tobj_desc = acpi_ns_get_attached_object(node);\n\tif (!obj_desc) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tswitch (type) {\n\tcase ACPI_TYPE_REGION:\n\n\t\tinfo->op_region_count++;\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER_FIELD:\n\n\t\tinfo->field_count++;\n\t\tbreak;\n\n\tcase ACPI_TYPE_LOCAL_BANK_FIELD:\n\n\t\tinfo->field_count++;\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\tinfo->buffer_count++;\n\t\tbreak;\n\n\tcase ACPI_TYPE_PACKAGE:\n\n\t\tinfo->package_count++;\n\t\tbreak;\n\n\tdefault:\n\n\t\t \n\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tif (obj_desc->common.flags & AOPOBJ_DATA_VALID) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tacpi_ex_enter_interpreter();\n\n\t \n\tswitch (type) {\n\tcase ACPI_TYPE_LOCAL_BANK_FIELD:\n\n\t\t \n\n\t\tinfo->field_init++;\n\t\tstatus = acpi_ds_get_bank_field_arguments(obj_desc);\n\t\tbreak;\n\n\tcase ACPI_TYPE_PACKAGE:\n\n\t\t \n\n\t\tinfo->package_init++;\n\t\tstatus =\n\t\t    acpi_ns_init_one_package(obj_handle, level, NULL, NULL);\n\t\tbreak;\n\n\tdefault:\n\n\t\t \n\n\t\tstatus = AE_TYPE;\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"Opcode is not deferred [%4.4s] (%s)\",\n\t\t\t\tacpi_ut_get_node_name(node),\n\t\t\t\tacpi_ut_get_type_name(type)));\n\t\tbreak;\n\t}\n\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\"Could not execute arguments for [%4.4s] (%s)\",\n\t\t\t\tacpi_ut_get_node_name(node),\n\t\t\t\tacpi_ut_get_type_name(type)));\n\t}\n\n\t \n\tacpi_ex_exit_interpreter();\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_ns_find_ini_methods(acpi_handle obj_handle,\n\t\t\t u32 nesting_level, void *context, void **return_value)\n{\n\tstruct acpi_device_walk_info *info =\n\t    ACPI_CAST_PTR(struct acpi_device_walk_info, context);\n\tstruct acpi_namespace_node *node;\n\tstruct acpi_namespace_node *parent_node;\n\n\t \n\n\tnode = ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);\n\tif ((node->type == ACPI_TYPE_DEVICE) ||\n\t    (node->type == ACPI_TYPE_PROCESSOR) ||\n\t    (node->type == ACPI_TYPE_THERMAL)) {\n\t\tinfo->device_count++;\n\t\treturn (AE_OK);\n\t}\n\n\t \n\n\tif (!ACPI_COMPARE_NAMESEG(node->name.ascii, METHOD_NAME__INI)) {\n\t\treturn (AE_OK);\n\t}\n\n\t \n\tparent_node = node->parent;\n\tswitch (parent_node->type) {\n\tcase ACPI_TYPE_DEVICE:\n\tcase ACPI_TYPE_PROCESSOR:\n\tcase ACPI_TYPE_THERMAL:\n\n\t\t \n\n\t\twhile (parent_node) {\n\t\t\tparent_node->flags |= ANOBJ_SUBTREE_HAS_INI;\n\t\t\tparent_node = parent_node->parent;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\tbreak;\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_ns_init_one_device(acpi_handle obj_handle,\n\t\t\tu32 nesting_level, void *context, void **return_value)\n{\n\tstruct acpi_device_walk_info *walk_info =\n\t    ACPI_CAST_PTR(struct acpi_device_walk_info, context);\n\tstruct acpi_evaluate_info *info = walk_info->evaluate_info;\n\tu32 flags;\n\tacpi_status status;\n\tstruct acpi_namespace_node *device_node;\n\n\tACPI_FUNCTION_TRACE(ns_init_one_device);\n\n\t \n\n\tdevice_node = ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);\n\tif ((device_node->type != ACPI_TYPE_DEVICE) &&\n\t    (device_node->type != ACPI_TYPE_PROCESSOR) &&\n\t    (device_node->type != ACPI_TYPE_THERMAL)) {\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\tif (!(device_node->flags & ANOBJ_SUBTREE_HAS_INI)) {\n\t\treturn_ACPI_STATUS(AE_CTRL_DEPTH);\n\t}\n\n\t \n\tACPI_DEBUG_EXEC(acpi_ut_display_init_pathname\n\t\t\t(ACPI_TYPE_METHOD, device_node, METHOD_NAME__STA));\n\n\tstatus = acpi_ut_execute_STA(device_node, &flags);\n\tif (ACPI_FAILURE(status)) {\n\n\t\t \n\n\t\treturn_ACPI_STATUS(AE_OK);\n\t}\n\n\t \n\tif (flags != ACPI_UINT32_MAX) {\n\t\twalk_info->num_STA++;\n\t}\n\n\t \n\tif (!(flags & ACPI_STA_DEVICE_PRESENT)) {\n\n\t\t \n\n\t\tif (flags & ACPI_STA_DEVICE_FUNCTIONING) {\n\t\t\t \n\t\t\treturn_ACPI_STATUS(AE_OK);\n\t\t} else {\n\t\t\t \n\t\t\treturn_ACPI_STATUS(AE_CTRL_DEPTH);\n\t\t}\n\t}\n\n\t \n\tif (!ACPI_COMPARE_NAMESEG(device_node->name.ascii, \"_SB_\") ||\n\t    device_node->parent != acpi_gbl_root_node) {\n\t\tACPI_DEBUG_EXEC(acpi_ut_display_init_pathname\n\t\t\t\t(ACPI_TYPE_METHOD, device_node,\n\t\t\t\t METHOD_NAME__INI));\n\n\t\tmemset(info, 0, sizeof(struct acpi_evaluate_info));\n\t\tinfo->prefix_node = device_node;\n\t\tinfo->relative_pathname = METHOD_NAME__INI;\n\t\tinfo->parameters = NULL;\n\t\tinfo->flags = ACPI_IGNORE_RETURN_VALUE;\n\n\t\tstatus = acpi_ns_evaluate(info);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\twalk_info->num_INI++;\n\t\t}\n#ifdef ACPI_DEBUG_OUTPUT\n\t\telse if (status != AE_NOT_FOUND) {\n\n\t\t\t \n\n\t\t\tchar *scope_name =\n\t\t\t    acpi_ns_get_normalized_pathname(device_node, TRUE);\n\n\t\t\tACPI_EXCEPTION((AE_INFO, status,\n\t\t\t\t\t\"during %s._INI execution\",\n\t\t\t\t\tscope_name));\n\t\t\tACPI_FREE(scope_name);\n\t\t}\n#endif\n\t}\n\n\t \n\n\tstatus = AE_OK;\n\n\t \n\tif (acpi_gbl_init_handler) {\n\t\tstatus =\n\t\t    acpi_gbl_init_handler(device_node, ACPI_INIT_DEVICE_INI);\n\t}\n\n\treturn_ACPI_STATUS(status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}