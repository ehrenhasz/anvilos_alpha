{
  "module_name": "dswstate.c",
  "hash_id": "00ce20143fb1c5ffb4e4eac97257b1cc8d437a93a917ad42be59c56bd912d5d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/dswstate.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acparser.h\"\n#include \"acdispat.h\"\n#include \"acnamesp.h\"\n\n#define _COMPONENT          ACPI_DISPATCHER\nACPI_MODULE_NAME(\"dswstate\")\n\n   \nstatic acpi_status\nacpi_ds_result_stack_push(struct acpi_walk_state *walk_state);\nstatic acpi_status acpi_ds_result_stack_pop(struct acpi_walk_state *walk_state);\n\n \n\nacpi_status\nacpi_ds_result_pop(union acpi_operand_object **object,\n\t\t   struct acpi_walk_state *walk_state)\n{\n\tu32 index;\n\tunion acpi_generic_state *state;\n\tacpi_status status;\n\n\tACPI_FUNCTION_NAME(ds_result_pop);\n\n\tstate = walk_state->results;\n\n\t \n\n\tif (state && !walk_state->result_count) {\n\t\tACPI_ERROR((AE_INFO, \"No results on result stack\"));\n\t\treturn (AE_AML_INTERNAL);\n\t}\n\n\tif (!state && walk_state->result_count) {\n\t\tACPI_ERROR((AE_INFO, \"No result state for result stack\"));\n\t\treturn (AE_AML_INTERNAL);\n\t}\n\n\t \n\n\tif (!state) {\n\t\tACPI_ERROR((AE_INFO, \"Result stack is empty! State=%p\",\n\t\t\t    walk_state));\n\t\treturn (AE_AML_NO_RETURN_VALUE);\n\t}\n\n\t \n\n\twalk_state->result_count--;\n\tindex = (u32)walk_state->result_count % ACPI_RESULTS_FRAME_OBJ_NUM;\n\n\t*object = state->results.obj_desc[index];\n\tif (!*object) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"No result objects on result stack, State=%p\",\n\t\t\t    walk_state));\n\t\treturn (AE_AML_NO_RETURN_VALUE);\n\t}\n\n\tstate->results.obj_desc[index] = NULL;\n\tif (index == 0) {\n\t\tstatus = acpi_ds_result_stack_pop(walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t  \"Obj=%p [%s] Index=%X State=%p Num=%X\\n\", *object,\n\t\t\t  acpi_ut_get_object_type_name(*object),\n\t\t\t  index, walk_state, walk_state->result_count));\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_ds_result_push(union acpi_operand_object *object,\n\t\t    struct acpi_walk_state *walk_state)\n{\n\tunion acpi_generic_state *state;\n\tacpi_status status;\n\tu32 index;\n\n\tACPI_FUNCTION_NAME(ds_result_push);\n\n\tif (walk_state->result_count > walk_state->result_size) {\n\t\tACPI_ERROR((AE_INFO, \"Result stack is full\"));\n\t\treturn (AE_AML_INTERNAL);\n\t} else if (walk_state->result_count == walk_state->result_size) {\n\n\t\t \n\n\t\tstatus = acpi_ds_result_stack_push(walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Failed to extend the result stack\"));\n\t\t\treturn (status);\n\t\t}\n\t}\n\n\tif (!(walk_state->result_count < walk_state->result_size)) {\n\t\tACPI_ERROR((AE_INFO, \"No free elements in result stack\"));\n\t\treturn (AE_AML_INTERNAL);\n\t}\n\n\tstate = walk_state->results;\n\tif (!state) {\n\t\tACPI_ERROR((AE_INFO, \"No result stack frame during push\"));\n\t\treturn (AE_AML_INTERNAL);\n\t}\n\n\tif (!object) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Null Object! State=%p Num=%u\",\n\t\t\t    walk_state, walk_state->result_count));\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tindex = (u32)walk_state->result_count % ACPI_RESULTS_FRAME_OBJ_NUM;\n\tstate->results.obj_desc[index] = object;\n\twalk_state->result_count++;\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC, \"Obj=%p [%s] State=%p Num=%X Cur=%X\\n\",\n\t\t\t  object,\n\t\t\t  acpi_ut_get_object_type_name((union\n\t\t\t\t\t\t\tacpi_operand_object *)\n\t\t\t\t\t\t       object), walk_state,\n\t\t\t  walk_state->result_count,\n\t\t\t  walk_state->current_result));\n\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status acpi_ds_result_stack_push(struct acpi_walk_state *walk_state)\n{\n\tunion acpi_generic_state *state;\n\n\tACPI_FUNCTION_NAME(ds_result_stack_push);\n\n\t \n\n\tif (((u32) walk_state->result_size + ACPI_RESULTS_FRAME_OBJ_NUM) >\n\t    ACPI_RESULTS_OBJ_NUM_MAX) {\n\t\tACPI_ERROR((AE_INFO, \"Result stack overflow: State=%p Num=%u\",\n\t\t\t    walk_state, walk_state->result_size));\n\t\treturn (AE_STACK_OVERFLOW);\n\t}\n\n\tstate = acpi_ut_create_generic_state();\n\tif (!state) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\tstate->common.descriptor_type = ACPI_DESC_TYPE_STATE_RESULT;\n\tacpi_ut_push_generic_state(&walk_state->results, state);\n\n\t \n\n\twalk_state->result_size += ACPI_RESULTS_FRAME_OBJ_NUM;\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC, \"Results=%p State=%p\\n\",\n\t\t\t  state, walk_state));\n\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status acpi_ds_result_stack_pop(struct acpi_walk_state *walk_state)\n{\n\tunion acpi_generic_state *state;\n\n\tACPI_FUNCTION_NAME(ds_result_stack_pop);\n\n\t \n\n\tif (walk_state->results == NULL) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t\t  \"Result stack underflow - State=%p\\n\",\n\t\t\t\t  walk_state));\n\t\treturn (AE_AML_NO_OPERAND);\n\t}\n\n\tif (walk_state->result_size < ACPI_RESULTS_FRAME_OBJ_NUM) {\n\t\tACPI_ERROR((AE_INFO, \"Insufficient result stack size\"));\n\t\treturn (AE_AML_INTERNAL);\n\t}\n\n\tstate = acpi_ut_pop_generic_state(&walk_state->results);\n\tacpi_ut_delete_generic_state(state);\n\n\t \n\n\twalk_state->result_size -= ACPI_RESULTS_FRAME_OBJ_NUM;\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t  \"Result=%p RemainingResults=%X State=%p\\n\",\n\t\t\t  state, walk_state->result_count, walk_state));\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_ds_obj_stack_push(void *object, struct acpi_walk_state *walk_state)\n{\n\tACPI_FUNCTION_NAME(ds_obj_stack_push);\n\n\t \n\n\tif (walk_state->num_operands >= ACPI_OBJ_NUM_OPERANDS) {\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Object stack overflow! Obj=%p State=%p #Ops=%u\",\n\t\t\t    object, walk_state, walk_state->num_operands));\n\t\treturn (AE_STACK_OVERFLOW);\n\t}\n\n\t \n\n\twalk_state->operands[walk_state->operand_index] = object;\n\twalk_state->num_operands++;\n\n\t \n\n\twalk_state->operand_index++;\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC, \"Obj=%p [%s] State=%p #Ops=%X\\n\",\n\t\t\t  object,\n\t\t\t  acpi_ut_get_object_type_name((union\n\t\t\t\t\t\t\tacpi_operand_object *)\n\t\t\t\t\t\t       object), walk_state,\n\t\t\t  walk_state->num_operands));\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_ds_obj_stack_pop(u32 pop_count, struct acpi_walk_state *walk_state)\n{\n\tu32 i;\n\n\tACPI_FUNCTION_NAME(ds_obj_stack_pop);\n\n\tfor (i = 0; i < pop_count; i++) {\n\n\t\t \n\n\t\tif (walk_state->num_operands == 0) {\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Object stack underflow! Count=%X State=%p #Ops=%u\",\n\t\t\t\t    pop_count, walk_state,\n\t\t\t\t    walk_state->num_operands));\n\t\t\treturn (AE_STACK_UNDERFLOW);\n\t\t}\n\n\t\t \n\n\t\twalk_state->num_operands--;\n\t\twalk_state->operands[walk_state->num_operands] = NULL;\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC, \"Count=%X State=%p #Ops=%u\\n\",\n\t\t\t  pop_count, walk_state, walk_state->num_operands));\n\n\treturn (AE_OK);\n}\n\n \n\nvoid\nacpi_ds_obj_stack_pop_and_delete(u32 pop_count,\n\t\t\t\t struct acpi_walk_state *walk_state)\n{\n\ts32 i;\n\tunion acpi_operand_object *obj_desc;\n\n\tACPI_FUNCTION_NAME(ds_obj_stack_pop_and_delete);\n\n\tif (pop_count == 0) {\n\t\treturn;\n\t}\n\n\tfor (i = (s32)pop_count - 1; i >= 0; i--) {\n\t\tif (walk_state->num_operands == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t \n\n\t\twalk_state->num_operands--;\n\t\tobj_desc = walk_state->operands[i];\n\t\tif (obj_desc) {\n\t\t\tacpi_ut_remove_reference(walk_state->operands[i]);\n\t\t\twalk_state->operands[i] = NULL;\n\t\t}\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC, \"Count=%X State=%p #Ops=%X\\n\",\n\t\t\t  pop_count, walk_state, walk_state->num_operands));\n}\n\n \n\nstruct acpi_walk_state *acpi_ds_get_current_walk_state(struct acpi_thread_state\n\t\t\t\t\t\t       *thread)\n{\n\tACPI_FUNCTION_NAME(ds_get_current_walk_state);\n\n\tif (!thread) {\n\t\treturn (NULL);\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_PARSE, \"Current WalkState %p\\n\",\n\t\t\t  thread->walk_state_list));\n\n\treturn (thread->walk_state_list);\n}\n\n \n\nvoid\nacpi_ds_push_walk_state(struct acpi_walk_state *walk_state,\n\t\t\tstruct acpi_thread_state *thread)\n{\n\tACPI_FUNCTION_TRACE(ds_push_walk_state);\n\n\twalk_state->next = thread->walk_state_list;\n\tthread->walk_state_list = walk_state;\n\n\treturn_VOID;\n}\n\n \n\nstruct acpi_walk_state *acpi_ds_pop_walk_state(struct acpi_thread_state *thread)\n{\n\tstruct acpi_walk_state *walk_state;\n\n\tACPI_FUNCTION_TRACE(ds_pop_walk_state);\n\n\twalk_state = thread->walk_state_list;\n\n\tif (walk_state) {\n\n\t\t \n\n\t\tthread->walk_state_list = walk_state->next;\n\n\t\t \n\t}\n\n\treturn_PTR(walk_state);\n}\n\n \n\nstruct acpi_walk_state *acpi_ds_create_walk_state(acpi_owner_id owner_id,\n\t\t\t\t\t\t  union acpi_parse_object\n\t\t\t\t\t\t  *origin,\n\t\t\t\t\t\t  union acpi_operand_object\n\t\t\t\t\t\t  *method_desc,\n\t\t\t\t\t\t  struct acpi_thread_state\n\t\t\t\t\t\t  *thread)\n{\n\tstruct acpi_walk_state *walk_state;\n\n\tACPI_FUNCTION_TRACE(ds_create_walk_state);\n\n\twalk_state = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_walk_state));\n\tif (!walk_state) {\n\t\treturn_PTR(NULL);\n\t}\n\n\twalk_state->descriptor_type = ACPI_DESC_TYPE_WALK;\n\twalk_state->method_desc = method_desc;\n\twalk_state->owner_id = owner_id;\n\twalk_state->origin = origin;\n\twalk_state->thread = thread;\n\n\twalk_state->parser_state.start_op = origin;\n\n\t \n\n#ifndef ACPI_CONSTANT_EVAL_ONLY\n\tacpi_ds_method_data_init(walk_state);\n#endif\n\n\t \n\n\tif (thread) {\n\t\tacpi_ds_push_walk_state(walk_state, thread);\n\t}\n\n\treturn_PTR(walk_state);\n}\n\n \n\nacpi_status\nacpi_ds_init_aml_walk(struct acpi_walk_state *walk_state,\n\t\t      union acpi_parse_object *op,\n\t\t      struct acpi_namespace_node *method_node,\n\t\t      u8 * aml_start,\n\t\t      u32 aml_length,\n\t\t      struct acpi_evaluate_info *info, u8 pass_number)\n{\n\tacpi_status status;\n\tstruct acpi_parse_state *parser_state = &walk_state->parser_state;\n\tunion acpi_parse_object *extra_op;\n\n\tACPI_FUNCTION_TRACE(ds_init_aml_walk);\n\n\twalk_state->parser_state.aml =\n\t    walk_state->parser_state.aml_start =\n\t    walk_state->parser_state.aml_end =\n\t    walk_state->parser_state.pkg_end = aml_start;\n\t \n\tif (aml_length != 0) {\n\t\twalk_state->parser_state.aml_end += aml_length;\n\t\twalk_state->parser_state.pkg_end += aml_length;\n\t}\n\n\t \n\n\twalk_state->next_op = NULL;\n\twalk_state->pass_number = pass_number;\n\n\tif (info) {\n\t\twalk_state->params = info->parameters;\n\t\twalk_state->caller_return_desc = &info->return_object;\n\t}\n\n\tstatus = acpi_ps_init_scope(&walk_state->parser_state, op);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tif (method_node) {\n\t\twalk_state->parser_state.start_node = method_node;\n\t\twalk_state->walk_type = ACPI_WALK_METHOD;\n\t\twalk_state->method_node = method_node;\n\t\twalk_state->method_desc =\n\t\t    acpi_ns_get_attached_object(method_node);\n\n\t\t \n\n\t\tstatus =\n\t\t    acpi_ds_scope_stack_push(method_node, ACPI_TYPE_METHOD,\n\t\t\t\t\t     walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\n\t\t \n\n\t\tstatus = acpi_ds_method_data_init_args(walk_state->params,\n\t\t\t\t\t\t       ACPI_METHOD_NUM_ARGS,\n\t\t\t\t\t\t       walk_state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t} else {\n\t\t \n\t\textra_op = parser_state->start_op;\n\t\twhile (extra_op && !extra_op->common.node) {\n\t\t\textra_op = extra_op->common.parent;\n\t\t}\n\n\t\tif (!extra_op) {\n\t\t\tparser_state->start_node = NULL;\n\t\t} else {\n\t\t\tparser_state->start_node = extra_op->common.node;\n\t\t}\n\n\t\tif (parser_state->start_node) {\n\n\t\t\t \n\n\t\t\tstatus =\n\t\t\t    acpi_ds_scope_stack_push(parser_state->start_node,\n\t\t\t\t\t\t     parser_state->start_node->\n\t\t\t\t\t\t     type, walk_state);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn_ACPI_STATUS(status);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatus = acpi_ds_init_callbacks(walk_state, pass_number);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nvoid acpi_ds_delete_walk_state(struct acpi_walk_state *walk_state)\n{\n\tunion acpi_generic_state *state;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_delete_walk_state, walk_state);\n\n\tif (!walk_state) {\n\t\treturn_VOID;\n\t}\n\n\tif (walk_state->descriptor_type != ACPI_DESC_TYPE_WALK) {\n\t\tACPI_ERROR((AE_INFO, \"%p is not a valid walk state\",\n\t\t\t    walk_state));\n\t\treturn_VOID;\n\t}\n\n\t \n\n\tif (walk_state->parser_state.scope) {\n\t\tACPI_ERROR((AE_INFO, \"%p walk still has a scope list\",\n\t\t\t    walk_state));\n\t\tacpi_ps_cleanup_scope(&walk_state->parser_state);\n\t}\n\n\t \n\n\twhile (walk_state->control_state) {\n\t\tstate = walk_state->control_state;\n\t\twalk_state->control_state = state->common.next;\n\n\t\tacpi_ut_delete_generic_state(state);\n\t}\n\n\t \n\n\twhile (walk_state->scope_info) {\n\t\tstate = walk_state->scope_info;\n\t\twalk_state->scope_info = state->common.next;\n\n\t\tacpi_ut_delete_generic_state(state);\n\t}\n\n\t \n\n\twhile (walk_state->results) {\n\t\tstate = walk_state->results;\n\t\twalk_state->results = state->common.next;\n\n\t\tacpi_ut_delete_generic_state(state);\n\t}\n\n\tACPI_FREE(walk_state);\n\treturn_VOID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}