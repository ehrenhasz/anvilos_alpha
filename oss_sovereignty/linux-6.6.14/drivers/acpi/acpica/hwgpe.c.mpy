{
  "module_name": "hwgpe.c",
  "hash_id": "c573adb6b1138f7ab0d0ab006f6f32dea95715b043af6cc2739f3c69cb8210e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpica/hwgpe.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"acevents.h\"\n\n#define _COMPONENT          ACPI_HARDWARE\nACPI_MODULE_NAME(\"hwgpe\")\n#if (!ACPI_REDUCED_HARDWARE)\t \n \nstatic acpi_status\nacpi_hw_enable_wakeup_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\n\t\t\t\tstruct acpi_gpe_block_info *gpe_block,\n\t\t\t\tvoid *context);\n\nstatic acpi_status\nacpi_hw_gpe_enable_write(u8 enable_mask,\n\t\t\t struct acpi_gpe_register_info *gpe_register_info);\n\n \n\nacpi_status acpi_hw_gpe_read(u64 *value, struct acpi_gpe_address *reg)\n{\n\tacpi_status status;\n\tu32 value32;\n\n\tif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\n#ifdef ACPI_GPE_USE_LOGICAL_ADDRESSES\n\t\t*value = (u64)ACPI_GET8((unsigned long)reg->address);\n\t\treturn_ACPI_STATUS(AE_OK);\n#else\n\t\treturn acpi_os_read_memory((acpi_physical_address)reg->address,\n\t\t\t\t\t    value, ACPI_GPE_REGISTER_WIDTH);\n#endif\n\t}\n\n\tstatus = acpi_os_read_port((acpi_io_address)reg->address,\n\t\t\t\t   &value32, ACPI_GPE_REGISTER_WIDTH);\n\tif (ACPI_FAILURE(status))\n\t\treturn_ACPI_STATUS(status);\n\n\t*value = (u64)value32;\n\n\treturn_ACPI_STATUS(AE_OK);\n}\n\n \n\nacpi_status acpi_hw_gpe_write(u64 value, struct acpi_gpe_address *reg)\n{\n\tif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\n#ifdef ACPI_GPE_USE_LOGICAL_ADDRESSES\n\t\tACPI_SET8((unsigned long)reg->address, value);\n\t\treturn_ACPI_STATUS(AE_OK);\n#else\n\t\treturn acpi_os_write_memory((acpi_physical_address)reg->address,\n\t\t\t\t\t    value, ACPI_GPE_REGISTER_WIDTH);\n#endif\n\t}\n\n\treturn acpi_os_write_port((acpi_io_address)reg->address, (u32)value,\n\t\t\t\t  ACPI_GPE_REGISTER_WIDTH);\n}\n\n \n\nu32 acpi_hw_get_gpe_register_bit(struct acpi_gpe_event_info *gpe_event_info)\n{\n\n\treturn ((u32)1 <<\n\t\t(gpe_event_info->gpe_number -\n\t\t gpe_event_info->register_info->base_gpe_number));\n}\n\n \n\nacpi_status\nacpi_hw_low_set_gpe(struct acpi_gpe_event_info *gpe_event_info, u32 action)\n{\n\tstruct acpi_gpe_register_info *gpe_register_info;\n\tacpi_status status = AE_OK;\n\tu64 enable_mask;\n\tu32 register_bit;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tgpe_register_info = gpe_event_info->register_info;\n\tif (!gpe_register_info) {\n\t\treturn (AE_NOT_EXIST);\n\t}\n\n\t \n\n\tstatus = acpi_hw_gpe_read(&enable_mask,\n\t\t\t\t  &gpe_register_info->enable_address);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\tregister_bit = acpi_hw_get_gpe_register_bit(gpe_event_info);\n\tswitch (action) {\n\tcase ACPI_GPE_CONDITIONAL_ENABLE:\n\n\t\t \n\n\t\tif (!(register_bit & gpe_register_info->enable_mask)) {\n\t\t\treturn (AE_BAD_PARAMETER);\n\t\t}\n\n\t\tACPI_FALLTHROUGH;\n\n\tcase ACPI_GPE_ENABLE:\n\n\t\tACPI_SET_BIT(enable_mask, register_bit);\n\t\tbreak;\n\n\tcase ACPI_GPE_DISABLE:\n\n\t\tACPI_CLEAR_BIT(enable_mask, register_bit);\n\t\tbreak;\n\n\tdefault:\n\n\t\tACPI_ERROR((AE_INFO, \"Invalid GPE Action, %u\", action));\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tif (!(register_bit & gpe_register_info->mask_for_run)) {\n\n\t\t \n\n\t\tstatus = acpi_hw_gpe_write(enable_mask,\n\t\t\t\t\t   &gpe_register_info->enable_address);\n\t}\n\treturn (status);\n}\n\n \n\nacpi_status acpi_hw_clear_gpe(struct acpi_gpe_event_info *gpe_event_info)\n{\n\tstruct acpi_gpe_register_info *gpe_register_info;\n\tacpi_status status;\n\tu32 register_bit;\n\n\tACPI_FUNCTION_ENTRY();\n\n\t \n\n\tgpe_register_info = gpe_event_info->register_info;\n\tif (!gpe_register_info) {\n\t\treturn (AE_NOT_EXIST);\n\t}\n\n\t \n\tregister_bit = acpi_hw_get_gpe_register_bit(gpe_event_info);\n\n\tstatus = acpi_hw_gpe_write(register_bit,\n\t\t\t\t   &gpe_register_info->status_address);\n\treturn (status);\n}\n\n \n\nacpi_status\nacpi_hw_get_gpe_status(struct acpi_gpe_event_info *gpe_event_info,\n\t\t       acpi_event_status *event_status)\n{\n\tu64 in_byte;\n\tu32 register_bit;\n\tstruct acpi_gpe_register_info *gpe_register_info;\n\tacpi_event_status local_event_status = 0;\n\tacpi_status status;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tif (!event_status) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t \n\n\tif (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) !=\n\t    ACPI_GPE_DISPATCH_NONE) {\n\t\tlocal_event_status |= ACPI_EVENT_FLAG_HAS_HANDLER;\n\t}\n\n\t \n\n\tgpe_register_info = gpe_event_info->register_info;\n\n\t \n\n\tregister_bit = acpi_hw_get_gpe_register_bit(gpe_event_info);\n\n\t \n\n\tif (register_bit & gpe_register_info->enable_for_run) {\n\t\tlocal_event_status |= ACPI_EVENT_FLAG_ENABLED;\n\t}\n\n\t \n\n\tif (register_bit & gpe_register_info->mask_for_run) {\n\t\tlocal_event_status |= ACPI_EVENT_FLAG_MASKED;\n\t}\n\n\t \n\n\tif (register_bit & gpe_register_info->enable_for_wake) {\n\t\tlocal_event_status |= ACPI_EVENT_FLAG_WAKE_ENABLED;\n\t}\n\n\t \n\n\tstatus = acpi_hw_gpe_read(&in_byte, &gpe_register_info->enable_address);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tif (register_bit & in_byte) {\n\t\tlocal_event_status |= ACPI_EVENT_FLAG_ENABLE_SET;\n\t}\n\n\t \n\n\tstatus = acpi_hw_gpe_read(&in_byte, &gpe_register_info->status_address);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\tif (register_bit & in_byte) {\n\t\tlocal_event_status |= ACPI_EVENT_FLAG_STATUS_SET;\n\t}\n\n\t \n\n\t(*event_status) = local_event_status;\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_hw_gpe_enable_write(u8 enable_mask,\n\t\t\t struct acpi_gpe_register_info *gpe_register_info)\n{\n\tacpi_status status;\n\n\tgpe_register_info->enable_mask = enable_mask;\n\n\tstatus = acpi_hw_gpe_write(enable_mask,\n\t\t\t\t   &gpe_register_info->enable_address);\n\treturn (status);\n}\n\n \n\nacpi_status\nacpi_hw_disable_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\n\t\t\t  struct acpi_gpe_block_info *gpe_block, void *context)\n{\n\tu32 i;\n\tacpi_status status;\n\n\t \n\n\tfor (i = 0; i < gpe_block->register_count; i++) {\n\n\t\t \n\n\t\tstatus =\n\t\t    acpi_hw_gpe_enable_write(0x00,\n\t\t\t\t\t     &gpe_block->register_info[i]);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_hw_clear_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\n\t\t\tstruct acpi_gpe_block_info *gpe_block, void *context)\n{\n\tu32 i;\n\tacpi_status status;\n\n\t \n\n\tfor (i = 0; i < gpe_block->register_count; i++) {\n\n\t\t \n\n\t\tstatus = acpi_hw_gpe_write(0xFF,\n\t\t\t\t\t   &gpe_block->register_info[i].status_address);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_hw_enable_runtime_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\n\t\t\t\t struct acpi_gpe_block_info *gpe_block,\n\t\t\t\t void *context)\n{\n\tu32 i;\n\tacpi_status status;\n\tstruct acpi_gpe_register_info *gpe_register_info;\n\tu8 enable_mask;\n\n\t \n\n\t \n\n\tfor (i = 0; i < gpe_block->register_count; i++) {\n\t\tgpe_register_info = &gpe_block->register_info[i];\n\t\tif (!gpe_register_info->enable_for_run) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tenable_mask = gpe_register_info->enable_for_run &\n\t\t    ~gpe_register_info->mask_for_run;\n\t\tstatus =\n\t\t    acpi_hw_gpe_enable_write(enable_mask, gpe_register_info);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nacpi_hw_enable_wakeup_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\n\t\t\t\tstruct acpi_gpe_block_info *gpe_block,\n\t\t\t\tvoid *context)\n{\n\tu32 i;\n\tacpi_status status;\n\tstruct acpi_gpe_register_info *gpe_register_info;\n\n\t \n\n\tfor (i = 0; i < gpe_block->register_count; i++) {\n\t\tgpe_register_info = &gpe_block->register_info[i];\n\n\t\t \n\n\t\tstatus =\n\t\t    acpi_hw_gpe_enable_write(gpe_register_info->enable_for_wake,\n\t\t\t\t\t     gpe_register_info);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t}\n\n\treturn (AE_OK);\n}\n\nstruct acpi_gpe_block_status_context {\n\tstruct acpi_gpe_register_info *gpe_skip_register_info;\n\tu8 gpe_skip_mask;\n\tu8 retval;\n};\n\n \n\nstatic acpi_status\nacpi_hw_get_gpe_block_status(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\n\t\t\t     struct acpi_gpe_block_info *gpe_block,\n\t\t\t     void *context)\n{\n\tstruct acpi_gpe_block_status_context *c = context;\n\tstruct acpi_gpe_register_info *gpe_register_info;\n\tu64 in_enable, in_status;\n\tacpi_status status;\n\tu8 ret_mask;\n\tu32 i;\n\n\t \n\n\tfor (i = 0; i < gpe_block->register_count; i++) {\n\t\tgpe_register_info = &gpe_block->register_info[i];\n\n\t\tstatus = acpi_hw_gpe_read(&in_enable,\n\t\t\t\t\t  &gpe_register_info->enable_address);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = acpi_hw_gpe_read(&in_status,\n\t\t\t\t\t  &gpe_register_info->status_address);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tret_mask = in_enable & in_status;\n\t\tif (ret_mask && c->gpe_skip_register_info == gpe_register_info) {\n\t\t\tret_mask &= ~c->gpe_skip_mask;\n\t\t}\n\t\tc->retval |= ret_mask;\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_hw_disable_all_gpes(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(hw_disable_all_gpes);\n\n\tstatus = acpi_ev_walk_gpe_list(acpi_hw_disable_gpe_block, NULL);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_hw_enable_all_runtime_gpes(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(hw_enable_all_runtime_gpes);\n\n\tstatus = acpi_ev_walk_gpe_list(acpi_hw_enable_runtime_gpe_block, NULL);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nacpi_status acpi_hw_enable_all_wakeup_gpes(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(hw_enable_all_wakeup_gpes);\n\n\tstatus = acpi_ev_walk_gpe_list(acpi_hw_enable_wakeup_gpe_block, NULL);\n\treturn_ACPI_STATUS(status);\n}\n\n \n\nu8 acpi_hw_check_all_gpes(acpi_handle gpe_skip_device, u32 gpe_skip_number)\n{\n\tstruct acpi_gpe_block_status_context context = {\n\t\t.gpe_skip_register_info = NULL,\n\t\t.retval = 0,\n\t};\n\tstruct acpi_gpe_event_info *gpe_event_info;\n\tacpi_cpu_flags flags;\n\n\tACPI_FUNCTION_TRACE(acpi_hw_check_all_gpes);\n\n\tflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\n\n\tgpe_event_info = acpi_ev_get_gpe_event_info(gpe_skip_device,\n\t\t\t\t\t\t    gpe_skip_number);\n\tif (gpe_event_info) {\n\t\tcontext.gpe_skip_register_info = gpe_event_info->register_info;\n\t\tcontext.gpe_skip_mask = acpi_hw_get_gpe_register_bit(gpe_event_info);\n\t}\n\n\tacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\n\n\t(void)acpi_ev_walk_gpe_list(acpi_hw_get_gpe_block_status, &context);\n\treturn (context.retval != 0);\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}