{
  "module_name": "device_sysfs.c",
  "hash_id": "79d4d58d5c86f88bbdcc8a2536cb65c67ca4408bebf77a822d0eb453f9e63c3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/device_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/nls.h>\n\n#include \"internal.h\"\n\nstatic ssize_t acpi_object_path(acpi_handle handle, char *buf)\n{\n\tstruct acpi_buffer path = {ACPI_ALLOCATE_BUFFER, NULL};\n\tint result;\n\n\tresult = acpi_get_name(handle, ACPI_FULL_PATHNAME, &path);\n\tif (result)\n\t\treturn result;\n\n\tresult = sprintf(buf, \"%s\\n\", (char *)path.pointer);\n\tkfree(path.pointer);\n\treturn result;\n}\n\nstruct acpi_data_node_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct acpi_data_node *, char *);\n\tssize_t (*store)(struct acpi_data_node *, const char *, size_t count);\n};\n\n#define DATA_NODE_ATTR(_name)\t\t\t\\\n\tstatic struct acpi_data_node_attr data_node_##_name =\t\\\n\t\t__ATTR(_name, 0444, data_node_show_##_name, NULL)\n\nstatic ssize_t data_node_show_path(struct acpi_data_node *dn, char *buf)\n{\n\treturn dn->handle ? acpi_object_path(dn->handle, buf) : 0;\n}\n\nDATA_NODE_ATTR(path);\n\nstatic struct attribute *acpi_data_node_default_attrs[] = {\n\t&data_node_path.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(acpi_data_node_default);\n\n#define to_data_node(k) container_of(k, struct acpi_data_node, kobj)\n#define to_attr(a) container_of(a, struct acpi_data_node_attr, attr)\n\nstatic ssize_t acpi_data_node_attr_show(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr, char *buf)\n{\n\tstruct acpi_data_node *dn = to_data_node(kobj);\n\tstruct acpi_data_node_attr *dn_attr = to_attr(attr);\n\n\treturn dn_attr->show ? dn_attr->show(dn, buf) : -ENXIO;\n}\n\nstatic const struct sysfs_ops acpi_data_node_sysfs_ops = {\n\t.show\t= acpi_data_node_attr_show,\n};\n\nstatic void acpi_data_node_release(struct kobject *kobj)\n{\n\tstruct acpi_data_node *dn = to_data_node(kobj);\n\n\tcomplete(&dn->kobj_done);\n}\n\nstatic const struct kobj_type acpi_data_node_ktype = {\n\t.sysfs_ops = &acpi_data_node_sysfs_ops,\n\t.default_groups = acpi_data_node_default_groups,\n\t.release = acpi_data_node_release,\n};\n\nstatic void acpi_expose_nondev_subnodes(struct kobject *kobj,\n\t\t\t\t\tstruct acpi_device_data *data)\n{\n\tstruct list_head *list = &data->subnodes;\n\tstruct acpi_data_node *dn;\n\n\tif (list_empty(list))\n\t\treturn;\n\n\tlist_for_each_entry(dn, list, sibling) {\n\t\tint ret;\n\n\t\tinit_completion(&dn->kobj_done);\n\t\tret = kobject_init_and_add(&dn->kobj, &acpi_data_node_ktype,\n\t\t\t\t\t   kobj, \"%s\", dn->name);\n\t\tif (!ret)\n\t\t\tacpi_expose_nondev_subnodes(&dn->kobj, &dn->data);\n\t\telse if (dn->handle)\n\t\t\tacpi_handle_err(dn->handle, \"Failed to expose (%d)\\n\", ret);\n\t}\n}\n\nstatic void acpi_hide_nondev_subnodes(struct acpi_device_data *data)\n{\n\tstruct list_head *list = &data->subnodes;\n\tstruct acpi_data_node *dn;\n\n\tif (list_empty(list))\n\t\treturn;\n\n\tlist_for_each_entry_reverse(dn, list, sibling) {\n\t\tacpi_hide_nondev_subnodes(&dn->data);\n\t\tkobject_put(&dn->kobj);\n\t}\n}\n\n \nstatic int create_pnp_modalias(const struct acpi_device *acpi_dev, char *modalias,\n\t\t\t       int size)\n{\n\tint len;\n\tint count;\n\tstruct acpi_hardware_id *id;\n\n\t \n\tif (!acpi_device_is_present(acpi_dev))\n\t\treturn 0;\n\n\t \n\tcount = 0;\n\tlist_for_each_entry(id, &acpi_dev->pnp.ids, list)\n\t\tif (strcmp(id->id, ACPI_DT_NAMESPACE_HID))\n\t\t\tcount++;\n\n\tif (!count)\n\t\treturn 0;\n\n\tlen = snprintf(modalias, size, \"acpi:\");\n\tif (len >= size)\n\t\treturn -ENOMEM;\n\n\tsize -= len;\n\n\tlist_for_each_entry(id, &acpi_dev->pnp.ids, list) {\n\t\tif (!strcmp(id->id, ACPI_DT_NAMESPACE_HID))\n\t\t\tcontinue;\n\n\t\tcount = snprintf(&modalias[len], size, \"%s:\", id->id);\n\t\tif (count < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (count >= size)\n\t\t\treturn -ENOMEM;\n\n\t\tlen += count;\n\t\tsize -= count;\n\t}\n\tmodalias[len] = '\\0';\n\treturn len;\n}\n\n \nstatic int create_of_modalias(const struct acpi_device *acpi_dev, char *modalias,\n\t\t\t      int size)\n{\n\tstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };\n\tconst union acpi_object *of_compatible, *obj;\n\tacpi_status status;\n\tint len, count;\n\tint i, nval;\n\tchar *c;\n\n\tstatus = acpi_get_name(acpi_dev->handle, ACPI_SINGLE_NAME, &buf);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\t \n\tfor (c = buf.pointer; *c != '\\0'; c++)\n\t\t*c = tolower(*c);\n\n\tlen = snprintf(modalias, size, \"of:N%sT\", (char *)buf.pointer);\n\tACPI_FREE(buf.pointer);\n\n\tif (len >= size)\n\t\treturn -ENOMEM;\n\n\tsize -= len;\n\n\tof_compatible = acpi_dev->data.of_compatible;\n\tif (of_compatible->type == ACPI_TYPE_PACKAGE) {\n\t\tnval = of_compatible->package.count;\n\t\tobj = of_compatible->package.elements;\n\t} else {  \n\t\tnval = 1;\n\t\tobj = of_compatible;\n\t}\n\tfor (i = 0; i < nval; i++, obj++) {\n\t\tcount = snprintf(&modalias[len], size, \"C%s\",\n\t\t\t\t obj->string.pointer);\n\t\tif (count < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (count >= size)\n\t\t\treturn -ENOMEM;\n\n\t\tlen += count;\n\t\tsize -= count;\n\t}\n\tmodalias[len] = '\\0';\n\treturn len;\n}\n\nint __acpi_device_uevent_modalias(const struct acpi_device *adev,\n\t\t\t\t  struct kobj_uevent_env *env)\n{\n\tint len;\n\n\tif (!adev)\n\t\treturn -ENODEV;\n\n\tif (list_empty(&adev->pnp.ids))\n\t\treturn 0;\n\n\tif (add_uevent_var(env, \"MODALIAS=\"))\n\t\treturn -ENOMEM;\n\n\tif (adev->data.of_compatible)\n\t\tlen = create_of_modalias(adev, &env->buf[env->buflen - 1],\n\t\t\t\t\t sizeof(env->buf) - env->buflen);\n\telse\n\t\tlen = create_pnp_modalias(adev, &env->buf[env->buflen - 1],\n\t\t\t\t\t  sizeof(env->buf) - env->buflen);\n\tif (len < 0)\n\t\treturn len;\n\n\tenv->buflen += len;\n\n\treturn 0;\n}\n\n \nint acpi_device_uevent_modalias(const struct device *dev, struct kobj_uevent_env *env)\n{\n\treturn __acpi_device_uevent_modalias(acpi_companion_match(dev), env);\n}\nEXPORT_SYMBOL_GPL(acpi_device_uevent_modalias);\n\nstatic int __acpi_device_modalias(const struct acpi_device *adev, char *buf, int size)\n{\n\tint len, count;\n\n\tif (!adev)\n\t\treturn -ENODEV;\n\n\tif (list_empty(&adev->pnp.ids))\n\t\treturn 0;\n\n\tlen = create_pnp_modalias(adev, buf, size - 1);\n\tif (len < 0) {\n\t\treturn len;\n\t} else if (len > 0) {\n\t\tbuf[len++] = '\\n';\n\t\tsize -= len;\n\t}\n\tif (!adev->data.of_compatible)\n\t\treturn len;\n\n\tcount = create_of_modalias(adev, buf + len, size - 1);\n\tif (count < 0) {\n\t\treturn count;\n\t} else if (count > 0) {\n\t\tlen += count;\n\t\tbuf[len++] = '\\n';\n\t}\n\n\treturn len;\n}\n\n \nint acpi_device_modalias(struct device *dev, char *buf, int size)\n{\n\treturn __acpi_device_modalias(acpi_companion_match(dev), buf, size);\n}\nEXPORT_SYMBOL_GPL(acpi_device_modalias);\n\nstatic ssize_t\nmodalias_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn __acpi_device_modalias(to_acpi_device(dev), buf, 1024);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t real_power_state_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct acpi_device *adev = to_acpi_device(dev);\n\tint state;\n\tint ret;\n\n\tret = acpi_device_get_power(adev, &state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%s\\n\", acpi_power_state_string(state));\n}\n\nstatic DEVICE_ATTR_RO(real_power_state);\n\nstatic ssize_t power_state_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct acpi_device *adev = to_acpi_device(dev);\n\n\treturn sprintf(buf, \"%s\\n\", acpi_power_state_string(adev->power.state));\n}\n\nstatic DEVICE_ATTR_RO(power_state);\n\nstatic ssize_t\neject_store(struct device *d, struct device_attribute *attr,\n\t    const char *buf, size_t count)\n{\n\tstruct acpi_device *acpi_device = to_acpi_device(d);\n\tacpi_object_type not_used;\n\tacpi_status status;\n\n\tif (!count || buf[0] != '1')\n\t\treturn -EINVAL;\n\n\tif ((!acpi_device->handler || !acpi_device->handler->hotplug.enabled)\n\t    && !d->driver)\n\t\treturn -ENODEV;\n\n\tstatus = acpi_get_type(acpi_device->handle, &not_used);\n\tif (ACPI_FAILURE(status) || !acpi_device->flags.ejectable)\n\t\treturn -ENODEV;\n\n\tacpi_dev_get(acpi_device);\n\tstatus = acpi_hotplug_schedule(acpi_device, ACPI_OST_EC_OSPM_EJECT);\n\tif (ACPI_SUCCESS(status))\n\t\treturn count;\n\n\tacpi_dev_put(acpi_device);\n\tacpi_evaluate_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,\n\t\t\t  ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);\n\treturn status == AE_NO_MEMORY ? -ENOMEM : -EAGAIN;\n}\n\nstatic DEVICE_ATTR_WO(eject);\n\nstatic ssize_t\nhid_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\n\treturn sprintf(buf, \"%s\\n\", acpi_device_hid(acpi_dev));\n}\nstatic DEVICE_ATTR_RO(hid);\n\nstatic ssize_t uid_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\n\treturn sprintf(buf, \"%s\\n\", acpi_dev->pnp.unique_id);\n}\nstatic DEVICE_ATTR_RO(uid);\n\nstatic ssize_t adr_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\n\tif (acpi_dev->pnp.bus_address > U32_MAX)\n\t\treturn sprintf(buf, \"0x%016llx\\n\", acpi_dev->pnp.bus_address);\n\telse\n\t\treturn sprintf(buf, \"0x%08llx\\n\", acpi_dev->pnp.bus_address);\n}\nstatic DEVICE_ATTR_RO(adr);\n\nstatic ssize_t path_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\n\treturn acpi_object_path(acpi_dev->handle, buf);\n}\nstatic DEVICE_ATTR_RO(path);\n\n \nstatic ssize_t description_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tint result;\n\n\tif (acpi_dev->pnp.str_obj == NULL)\n\t\treturn 0;\n\n\t \n\tresult = utf16s_to_utf8s(\n\t\t(wchar_t *)acpi_dev->pnp.str_obj->buffer.pointer,\n\t\tacpi_dev->pnp.str_obj->buffer.length,\n\t\tUTF16_LITTLE_ENDIAN, buf,\n\t\tPAGE_SIZE - 1);\n\n\tbuf[result++] = '\\n';\n\n\treturn result;\n}\nstatic DEVICE_ATTR_RO(description);\n\nstatic ssize_t\nsun_show(struct device *dev, struct device_attribute *attr,\n\t char *buf)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tacpi_status status;\n\tunsigned long long sun;\n\n\tstatus = acpi_evaluate_integer(acpi_dev->handle, \"_SUN\", NULL, &sun);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\treturn sprintf(buf, \"%llu\\n\", sun);\n}\nstatic DEVICE_ATTR_RO(sun);\n\nstatic ssize_t\nhrv_show(struct device *dev, struct device_attribute *attr,\n\t char *buf)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tacpi_status status;\n\tunsigned long long hrv;\n\n\tstatus = acpi_evaluate_integer(acpi_dev->handle, \"_HRV\", NULL, &hrv);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\treturn sprintf(buf, \"%llu\\n\", hrv);\n}\nstatic DEVICE_ATTR_RO(hrv);\n\nstatic ssize_t status_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tacpi_status status;\n\tunsigned long long sta;\n\n\tstatus = acpi_evaluate_integer(acpi_dev->handle, \"_STA\", NULL, &sta);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\treturn sprintf(buf, \"%llu\\n\", sta);\n}\nstatic DEVICE_ATTR_RO(status);\n\n \nint acpi_device_setup_files(struct acpi_device *dev)\n{\n\tstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\n\tacpi_status status;\n\tint result = 0;\n\n\t \n\tif (dev->handle) {\n\t\tresult = device_create_file(&dev->dev, &dev_attr_path);\n\t\tif (result)\n\t\t\tgoto end;\n\t}\n\n\tif (!list_empty(&dev->pnp.ids)) {\n\t\tresult = device_create_file(&dev->dev, &dev_attr_hid);\n\t\tif (result)\n\t\t\tgoto end;\n\n\t\tresult = device_create_file(&dev->dev, &dev_attr_modalias);\n\t\tif (result)\n\t\t\tgoto end;\n\t}\n\n\t \n\tif (acpi_has_method(dev->handle, \"_STR\")) {\n\t\tstatus = acpi_evaluate_object(dev->handle, \"_STR\",\n\t\t\t\t\tNULL, &buffer);\n\t\tif (ACPI_FAILURE(status))\n\t\t\tbuffer.pointer = NULL;\n\t\tdev->pnp.str_obj = buffer.pointer;\n\t\tresult = device_create_file(&dev->dev, &dev_attr_description);\n\t\tif (result)\n\t\t\tgoto end;\n\t}\n\n\tif (dev->pnp.type.bus_address)\n\t\tresult = device_create_file(&dev->dev, &dev_attr_adr);\n\tif (dev->pnp.unique_id)\n\t\tresult = device_create_file(&dev->dev, &dev_attr_uid);\n\n\tif (acpi_has_method(dev->handle, \"_SUN\")) {\n\t\tresult = device_create_file(&dev->dev, &dev_attr_sun);\n\t\tif (result)\n\t\t\tgoto end;\n\t}\n\n\tif (acpi_has_method(dev->handle, \"_HRV\")) {\n\t\tresult = device_create_file(&dev->dev, &dev_attr_hrv);\n\t\tif (result)\n\t\t\tgoto end;\n\t}\n\n\tif (acpi_has_method(dev->handle, \"_STA\")) {\n\t\tresult = device_create_file(&dev->dev, &dev_attr_status);\n\t\tif (result)\n\t\t\tgoto end;\n\t}\n\n\t \n\tif (acpi_has_method(dev->handle, \"_EJ0\")) {\n\t\tresult = device_create_file(&dev->dev, &dev_attr_eject);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tif (dev->flags.power_manageable) {\n\t\tresult = device_create_file(&dev->dev, &dev_attr_power_state);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tif (dev->power.flags.power_resources)\n\t\t\tresult = device_create_file(&dev->dev,\n\t\t\t\t\t\t    &dev_attr_real_power_state);\n\t}\n\n\tacpi_expose_nondev_subnodes(&dev->dev.kobj, &dev->data);\n\nend:\n\treturn result;\n}\n\n \nvoid acpi_device_remove_files(struct acpi_device *dev)\n{\n\tacpi_hide_nondev_subnodes(&dev->data);\n\n\tif (dev->flags.power_manageable) {\n\t\tdevice_remove_file(&dev->dev, &dev_attr_power_state);\n\t\tif (dev->power.flags.power_resources)\n\t\t\tdevice_remove_file(&dev->dev,\n\t\t\t\t\t   &dev_attr_real_power_state);\n\t}\n\n\t \n\tif (acpi_has_method(dev->handle, \"_STR\")) {\n\t\tkfree(dev->pnp.str_obj);\n\t\tdevice_remove_file(&dev->dev, &dev_attr_description);\n\t}\n\t \n\tif (acpi_has_method(dev->handle, \"_EJ0\"))\n\t\tdevice_remove_file(&dev->dev, &dev_attr_eject);\n\n\tif (acpi_has_method(dev->handle, \"_SUN\"))\n\t\tdevice_remove_file(&dev->dev, &dev_attr_sun);\n\n\tif (acpi_has_method(dev->handle, \"_HRV\"))\n\t\tdevice_remove_file(&dev->dev, &dev_attr_hrv);\n\n\tif (dev->pnp.unique_id)\n\t\tdevice_remove_file(&dev->dev, &dev_attr_uid);\n\tif (dev->pnp.type.bus_address)\n\t\tdevice_remove_file(&dev->dev, &dev_attr_adr);\n\tdevice_remove_file(&dev->dev, &dev_attr_modalias);\n\tdevice_remove_file(&dev->dev, &dev_attr_hid);\n\tif (acpi_has_method(dev->handle, \"_STA\"))\n\t\tdevice_remove_file(&dev->dev, &dev_attr_status);\n\tif (dev->handle)\n\t\tdevice_remove_file(&dev->dev, &dev_attr_path);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}