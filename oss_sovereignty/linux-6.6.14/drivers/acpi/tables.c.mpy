{
  "module_name": "tables.c",
  "hash_id": "3cb526cd1cfdf5b3d215c79820ec95ab75d1f8aa236a773444efee82c491e241",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/tables.c",
  "human_readable_source": "\n \n\n \n \n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/errno.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h>\n#include <linux/earlycpio.h>\n#include <linux/initrd.h>\n#include <linux/security.h>\n#include <linux/kmemleak.h>\n#include \"internal.h\"\n\n#ifdef CONFIG_ACPI_CUSTOM_DSDT\n#include CONFIG_ACPI_CUSTOM_DSDT_FILE\n#endif\n\n#define ACPI_MAX_TABLES\t\t128\n\nstatic char *mps_inti_flags_polarity[] = { \"dfl\", \"high\", \"res\", \"low\" };\nstatic char *mps_inti_flags_trigger[] = { \"dfl\", \"edge\", \"res\", \"level\" };\n\nstatic struct acpi_table_desc initial_tables[ACPI_MAX_TABLES] __initdata;\n\nstatic int acpi_apic_instance __initdata_or_acpilib;\n\nenum acpi_subtable_type {\n\tACPI_SUBTABLE_COMMON,\n\tACPI_SUBTABLE_HMAT,\n\tACPI_SUBTABLE_PRMT,\n\tACPI_SUBTABLE_CEDT,\n};\n\nstruct acpi_subtable_entry {\n\tunion acpi_subtable_headers *hdr;\n\tenum acpi_subtable_type type;\n};\n\n \nstatic bool acpi_verify_table_checksum __initdata_or_acpilib = false;\n\nvoid acpi_table_print_madt_entry(struct acpi_subtable_header *header)\n{\n\tif (!header)\n\t\treturn;\n\n\tswitch (header->type) {\n\n\tcase ACPI_MADT_TYPE_LOCAL_APIC:\n\t\t{\n\t\t\tstruct acpi_madt_local_apic *p =\n\t\t\t    (struct acpi_madt_local_apic *)header;\n\t\t\tpr_debug(\"LAPIC (acpi_id[0x%02x] lapic_id[0x%02x] %s)\\n\",\n\t\t\t\t p->processor_id, p->id,\n\t\t\t\t (p->lapic_flags & ACPI_MADT_ENABLED) ? \"enabled\" : \"disabled\");\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_LOCAL_X2APIC:\n\t\t{\n\t\t\tstruct acpi_madt_local_x2apic *p =\n\t\t\t    (struct acpi_madt_local_x2apic *)header;\n\t\t\tpr_debug(\"X2APIC (apic_id[0x%02x] uid[0x%02x] %s)\\n\",\n\t\t\t\t p->local_apic_id, p->uid,\n\t\t\t\t (p->lapic_flags & ACPI_MADT_ENABLED) ? \"enabled\" : \"disabled\");\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_IO_APIC:\n\t\t{\n\t\t\tstruct acpi_madt_io_apic *p =\n\t\t\t    (struct acpi_madt_io_apic *)header;\n\t\t\tpr_debug(\"IOAPIC (id[0x%02x] address[0x%08x] gsi_base[%d])\\n\",\n\t\t\t\t p->id, p->address, p->global_irq_base);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_INTERRUPT_OVERRIDE:\n\t\t{\n\t\t\tstruct acpi_madt_interrupt_override *p =\n\t\t\t    (struct acpi_madt_interrupt_override *)header;\n\t\t\tpr_info(\"INT_SRC_OVR (bus %d bus_irq %d global_irq %d %s %s)\\n\",\n\t\t\t\tp->bus, p->source_irq, p->global_irq,\n\t\t\t\tmps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],\n\t\t\t\tmps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2]);\n\t\t\tif (p->inti_flags  &\n\t\t\t    ~(ACPI_MADT_POLARITY_MASK | ACPI_MADT_TRIGGER_MASK))\n\t\t\t\tpr_info(\"INT_SRC_OVR unexpected reserved flags: 0x%x\\n\",\n\t\t\t\t\tp->inti_flags  &\n\t\t\t\t\t~(ACPI_MADT_POLARITY_MASK | ACPI_MADT_TRIGGER_MASK));\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_NMI_SOURCE:\n\t\t{\n\t\t\tstruct acpi_madt_nmi_source *p =\n\t\t\t    (struct acpi_madt_nmi_source *)header;\n\t\t\tpr_info(\"NMI_SRC (%s %s global_irq %d)\\n\",\n\t\t\t\tmps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],\n\t\t\t\tmps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],\n\t\t\t\tp->global_irq);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_LOCAL_APIC_NMI:\n\t\t{\n\t\t\tstruct acpi_madt_local_apic_nmi *p =\n\t\t\t    (struct acpi_madt_local_apic_nmi *)header;\n\t\t\tpr_info(\"LAPIC_NMI (acpi_id[0x%02x] %s %s lint[0x%x])\\n\",\n\t\t\t\tp->processor_id,\n\t\t\t\tmps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK\t],\n\t\t\t\tmps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],\n\t\t\t\tp->lint);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_LOCAL_X2APIC_NMI:\n\t\t{\n\t\t\tu16 polarity, trigger;\n\t\t\tstruct acpi_madt_local_x2apic_nmi *p =\n\t\t\t    (struct acpi_madt_local_x2apic_nmi *)header;\n\n\t\t\tpolarity = p->inti_flags & ACPI_MADT_POLARITY_MASK;\n\t\t\ttrigger = (p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2;\n\n\t\t\tpr_info(\"X2APIC_NMI (uid[0x%02x] %s %s lint[0x%x])\\n\",\n\t\t\t\tp->uid,\n\t\t\t\tmps_inti_flags_polarity[polarity],\n\t\t\t\tmps_inti_flags_trigger[trigger],\n\t\t\t\tp->lint);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE:\n\t\t{\n\t\t\tstruct acpi_madt_local_apic_override *p =\n\t\t\t    (struct acpi_madt_local_apic_override *)header;\n\t\t\tpr_info(\"LAPIC_ADDR_OVR (address[0x%llx])\\n\",\n\t\t\t\tp->address);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_IO_SAPIC:\n\t\t{\n\t\t\tstruct acpi_madt_io_sapic *p =\n\t\t\t    (struct acpi_madt_io_sapic *)header;\n\t\t\tpr_debug(\"IOSAPIC (id[0x%x] address[%p] gsi_base[%d])\\n\",\n\t\t\t\t p->id, (void *)(unsigned long)p->address,\n\t\t\t\t p->global_irq_base);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_LOCAL_SAPIC:\n\t\t{\n\t\t\tstruct acpi_madt_local_sapic *p =\n\t\t\t    (struct acpi_madt_local_sapic *)header;\n\t\t\tpr_debug(\"LSAPIC (acpi_id[0x%02x] lsapic_id[0x%02x] lsapic_eid[0x%02x] %s)\\n\",\n\t\t\t\t p->processor_id, p->id, p->eid,\n\t\t\t\t (p->lapic_flags & ACPI_MADT_ENABLED) ? \"enabled\" : \"disabled\");\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_INTERRUPT_SOURCE:\n\t\t{\n\t\t\tstruct acpi_madt_interrupt_source *p =\n\t\t\t    (struct acpi_madt_interrupt_source *)header;\n\t\t\tpr_info(\"PLAT_INT_SRC (%s %s type[0x%x] id[0x%04x] eid[0x%x] iosapic_vector[0x%x] global_irq[0x%x]\\n\",\n\t\t\t\tmps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],\n\t\t\t\tmps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],\n\t\t\t\tp->type, p->id, p->eid, p->io_sapic_vector,\n\t\t\t\tp->global_irq);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_GENERIC_INTERRUPT:\n\t\t{\n\t\t\tstruct acpi_madt_generic_interrupt *p =\n\t\t\t\t(struct acpi_madt_generic_interrupt *)header;\n\t\t\tpr_debug(\"GICC (acpi_id[0x%04x] address[%llx] MPIDR[0x%llx] %s)\\n\",\n\t\t\t\t p->uid, p->base_address,\n\t\t\t\t p->arm_mpidr,\n\t\t\t\t (p->flags & ACPI_MADT_ENABLED) ? \"enabled\" : \"disabled\");\n\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR:\n\t\t{\n\t\t\tstruct acpi_madt_generic_distributor *p =\n\t\t\t\t(struct acpi_madt_generic_distributor *)header;\n\t\t\tpr_debug(\"GIC Distributor (gic_id[0x%04x] address[%llx] gsi_base[%d])\\n\",\n\t\t\t\t p->gic_id, p->base_address,\n\t\t\t\t p->global_irq_base);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_CORE_PIC:\n\t\t{\n\t\t\tstruct acpi_madt_core_pic *p = (struct acpi_madt_core_pic *)header;\n\n\t\t\tpr_debug(\"CORE PIC (processor_id[0x%02x] core_id[0x%02x] %s)\\n\",\n\t\t\t\t p->processor_id, p->core_id,\n\t\t\t\t (p->flags & ACPI_MADT_ENABLED) ? \"enabled\" : \"disabled\");\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_MADT_TYPE_RINTC:\n\t\t{\n\t\t\tstruct acpi_madt_rintc *p = (struct acpi_madt_rintc *)header;\n\n\t\t\tpr_debug(\"RISC-V INTC (acpi_uid[0x%04x] hart_id[0x%llx] %s)\\n\",\n\t\t\t\t p->uid, p->hart_id,\n\t\t\t\t (p->flags & ACPI_MADT_ENABLED) ? \"enabled\" : \"disabled\");\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"Found unsupported MADT entry (type = 0x%x)\\n\",\n\t\t\theader->type);\n\t\tbreak;\n\t}\n}\n\nstatic unsigned long __init_or_acpilib\nacpi_get_entry_type(struct acpi_subtable_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase ACPI_SUBTABLE_COMMON:\n\t\treturn entry->hdr->common.type;\n\tcase ACPI_SUBTABLE_HMAT:\n\t\treturn entry->hdr->hmat.type;\n\tcase ACPI_SUBTABLE_PRMT:\n\t\treturn 0;\n\tcase ACPI_SUBTABLE_CEDT:\n\t\treturn entry->hdr->cedt.type;\n\t}\n\treturn 0;\n}\n\nstatic unsigned long __init_or_acpilib\nacpi_get_entry_length(struct acpi_subtable_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase ACPI_SUBTABLE_COMMON:\n\t\treturn entry->hdr->common.length;\n\tcase ACPI_SUBTABLE_HMAT:\n\t\treturn entry->hdr->hmat.length;\n\tcase ACPI_SUBTABLE_PRMT:\n\t\treturn entry->hdr->prmt.length;\n\tcase ACPI_SUBTABLE_CEDT:\n\t\treturn entry->hdr->cedt.length;\n\t}\n\treturn 0;\n}\n\nstatic unsigned long __init_or_acpilib\nacpi_get_subtable_header_length(struct acpi_subtable_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase ACPI_SUBTABLE_COMMON:\n\t\treturn sizeof(entry->hdr->common);\n\tcase ACPI_SUBTABLE_HMAT:\n\t\treturn sizeof(entry->hdr->hmat);\n\tcase ACPI_SUBTABLE_PRMT:\n\t\treturn sizeof(entry->hdr->prmt);\n\tcase ACPI_SUBTABLE_CEDT:\n\t\treturn sizeof(entry->hdr->cedt);\n\t}\n\treturn 0;\n}\n\nstatic enum acpi_subtable_type __init_or_acpilib\nacpi_get_subtable_type(char *id)\n{\n\tif (strncmp(id, ACPI_SIG_HMAT, 4) == 0)\n\t\treturn ACPI_SUBTABLE_HMAT;\n\tif (strncmp(id, ACPI_SIG_PRMT, 4) == 0)\n\t\treturn ACPI_SUBTABLE_PRMT;\n\tif (strncmp(id, ACPI_SIG_CEDT, 4) == 0)\n\t\treturn ACPI_SUBTABLE_CEDT;\n\treturn ACPI_SUBTABLE_COMMON;\n}\n\nstatic __init_or_acpilib bool has_handler(struct acpi_subtable_proc *proc)\n{\n\treturn proc->handler || proc->handler_arg;\n}\n\nstatic __init_or_acpilib int call_handler(struct acpi_subtable_proc *proc,\n\t\t\t\t\t  union acpi_subtable_headers *hdr,\n\t\t\t\t\t  unsigned long end)\n{\n\tif (proc->handler)\n\t\treturn proc->handler(hdr, end);\n\tif (proc->handler_arg)\n\t\treturn proc->handler_arg(hdr, proc->arg, end);\n\treturn -EINVAL;\n}\n\n \nstatic int __init_or_acpilib acpi_parse_entries_array(\n\tchar *id, unsigned long table_size,\n\tstruct acpi_table_header *table_header, struct acpi_subtable_proc *proc,\n\tint proc_num, unsigned int max_entries)\n{\n\tstruct acpi_subtable_entry entry;\n\tunsigned long table_end, subtable_len, entry_len;\n\tint count = 0;\n\tint errs = 0;\n\tint i;\n\n\ttable_end = (unsigned long)table_header + table_header->length;\n\n\t \n\n\tentry.type = acpi_get_subtable_type(id);\n\tentry.hdr = (union acpi_subtable_headers *)\n\t    ((unsigned long)table_header + table_size);\n\tsubtable_len = acpi_get_subtable_header_length(&entry);\n\n\twhile (((unsigned long)entry.hdr) + subtable_len  < table_end) {\n\t\tif (max_entries && count >= max_entries)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < proc_num; i++) {\n\t\t\tif (acpi_get_entry_type(&entry) != proc[i].id)\n\t\t\t\tcontinue;\n\t\t\tif (!has_handler(&proc[i]) ||\n\t\t\t    (!errs &&\n\t\t\t     call_handler(&proc[i], entry.hdr, table_end))) {\n\t\t\t\terrs++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tproc[i].count++;\n\t\t\tbreak;\n\t\t}\n\t\tif (i != proc_num)\n\t\t\tcount++;\n\n\t\t \n\t\tentry_len = acpi_get_entry_length(&entry);\n\t\tif (entry_len == 0) {\n\t\t\tpr_err(\"[%4.4s:0x%02x] Invalid zero length\\n\", id, proc->id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tentry.hdr = (union acpi_subtable_headers *)\n\t\t    ((unsigned long)entry.hdr + entry_len);\n\t}\n\n\tif (max_entries && count > max_entries) {\n\t\tpr_warn(\"[%4.4s:0x%02x] found the maximum %i entries\\n\",\n\t\t\tid, proc->id, count);\n\t}\n\n\treturn errs ? -EINVAL : count;\n}\n\nint __init_or_acpilib acpi_table_parse_entries_array(\n\tchar *id, unsigned long table_size, struct acpi_subtable_proc *proc,\n\tint proc_num, unsigned int max_entries)\n{\n\tstruct acpi_table_header *table_header = NULL;\n\tint count;\n\tu32 instance = 0;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\tif (!id)\n\t\treturn -EINVAL;\n\n\tif (!table_size)\n\t\treturn -EINVAL;\n\n\tif (!strncmp(id, ACPI_SIG_MADT, 4))\n\t\tinstance = acpi_apic_instance;\n\n\tacpi_get_table(id, instance, &table_header);\n\tif (!table_header) {\n\t\tpr_debug(\"%4.4s not present\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\tcount = acpi_parse_entries_array(id, table_size, table_header,\n\t\t\tproc, proc_num, max_entries);\n\n\tacpi_put_table(table_header);\n\treturn count;\n}\n\nstatic int __init_or_acpilib __acpi_table_parse_entries(\n\tchar *id, unsigned long table_size, int entry_id,\n\tacpi_tbl_entry_handler handler, acpi_tbl_entry_handler_arg handler_arg,\n\tvoid *arg, unsigned int max_entries)\n{\n\tstruct acpi_subtable_proc proc = {\n\t\t.id\t\t= entry_id,\n\t\t.handler\t= handler,\n\t\t.handler_arg\t= handler_arg,\n\t\t.arg\t\t= arg,\n\t};\n\n\treturn acpi_table_parse_entries_array(id, table_size, &proc, 1,\n\t\t\t\t\t\tmax_entries);\n}\n\nint __init_or_acpilib\nacpi_table_parse_cedt(enum acpi_cedt_type id,\n\t\t      acpi_tbl_entry_handler_arg handler_arg, void *arg)\n{\n\treturn __acpi_table_parse_entries(ACPI_SIG_CEDT,\n\t\t\t\t\t  sizeof(struct acpi_table_cedt), id,\n\t\t\t\t\t  NULL, handler_arg, arg, 0);\n}\nEXPORT_SYMBOL_ACPI_LIB(acpi_table_parse_cedt);\n\nint __init acpi_table_parse_entries(char *id, unsigned long table_size,\n\t\t\t\t    int entry_id,\n\t\t\t\t    acpi_tbl_entry_handler handler,\n\t\t\t\t    unsigned int max_entries)\n{\n\treturn __acpi_table_parse_entries(id, table_size, entry_id, handler,\n\t\t\t\t\t  NULL, NULL, max_entries);\n}\n\nint __init acpi_table_parse_madt(enum acpi_madt_type id,\n\t\t      acpi_tbl_entry_handler handler, unsigned int max_entries)\n{\n\treturn acpi_table_parse_entries(ACPI_SIG_MADT,\n\t\t\t\t\t    sizeof(struct acpi_table_madt), id,\n\t\t\t\t\t    handler, max_entries);\n}\n\n \nint __init acpi_table_parse(char *id, acpi_tbl_table_handler handler)\n{\n\tstruct acpi_table_header *table = NULL;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\tif (!id || !handler)\n\t\treturn -EINVAL;\n\n\tif (strncmp(id, ACPI_SIG_MADT, 4) == 0)\n\t\tacpi_get_table(id, acpi_apic_instance, &table);\n\telse\n\t\tacpi_get_table(id, 0, &table);\n\n\tif (table) {\n\t\thandler(table);\n\t\tacpi_put_table(table);\n\t\treturn 0;\n\t} else\n\t\treturn -ENODEV;\n}\n\n \nstatic void __init check_multiple_madt(void)\n{\n\tstruct acpi_table_header *table = NULL;\n\n\tacpi_get_table(ACPI_SIG_MADT, 2, &table);\n\tif (table) {\n\t\tpr_warn(\"BIOS bug: multiple APIC/MADT found, using %d\\n\",\n\t\t\tacpi_apic_instance);\n\t\tpr_warn(\"If \\\"acpi_apic_instance=%d\\\" works better, \"\n\t\t\t\"notify linux-acpi@vger.kernel.org\\n\",\n\t\t\tacpi_apic_instance ? 0 : 2);\n\t\tacpi_put_table(table);\n\n\t} else\n\t\tacpi_apic_instance = 0;\n\n\treturn;\n}\n\nstatic void acpi_table_taint(struct acpi_table_header *table)\n{\n\tpr_warn(\"Override [%4.4s-%8.8s], this is unsafe: tainting kernel\\n\",\n\t\ttable->signature, table->oem_table_id);\n\tadd_taint(TAINT_OVERRIDDEN_ACPI_TABLE, LOCKDEP_NOW_UNRELIABLE);\n}\n\n#ifdef CONFIG_ACPI_TABLE_UPGRADE\nstatic u64 acpi_tables_addr;\nstatic int all_tables_size;\n\n \nstatic u8 __init acpi_table_checksum(u8 *buffer, u32 length)\n{\n\tu8 sum = 0;\n\tu8 *end = buffer + length;\n\n\twhile (buffer < end)\n\t\tsum = (u8) (sum + *(buffer++));\n\treturn sum;\n}\n\n \nstatic const char table_sigs[][ACPI_NAMESEG_SIZE] __initconst = {\n\tACPI_SIG_BERT, ACPI_SIG_BGRT, ACPI_SIG_CPEP, ACPI_SIG_ECDT,\n\tACPI_SIG_EINJ, ACPI_SIG_ERST, ACPI_SIG_HEST, ACPI_SIG_MADT,\n\tACPI_SIG_MSCT, ACPI_SIG_SBST, ACPI_SIG_SLIT, ACPI_SIG_SRAT,\n\tACPI_SIG_ASF,  ACPI_SIG_BOOT, ACPI_SIG_DBGP, ACPI_SIG_DMAR,\n\tACPI_SIG_HPET, ACPI_SIG_IBFT, ACPI_SIG_IVRS, ACPI_SIG_MCFG,\n\tACPI_SIG_MCHI, ACPI_SIG_SLIC, ACPI_SIG_SPCR, ACPI_SIG_SPMI,\n\tACPI_SIG_TCPA, ACPI_SIG_UEFI, ACPI_SIG_WAET, ACPI_SIG_WDAT,\n\tACPI_SIG_WDDT, ACPI_SIG_WDRT, ACPI_SIG_DSDT, ACPI_SIG_FADT,\n\tACPI_SIG_PSDT, ACPI_SIG_RSDT, ACPI_SIG_XSDT, ACPI_SIG_SSDT,\n\tACPI_SIG_IORT, ACPI_SIG_NFIT, ACPI_SIG_HMAT, ACPI_SIG_PPTT,\n\tACPI_SIG_NHLT, ACPI_SIG_AEST, ACPI_SIG_CEDT, ACPI_SIG_AGDI,\n\tACPI_SIG_NBFT };\n\n#define ACPI_HEADER_SIZE sizeof(struct acpi_table_header)\n\n#define NR_ACPI_INITRD_TABLES 64\nstatic struct cpio_data __initdata acpi_initrd_files[NR_ACPI_INITRD_TABLES];\nstatic DECLARE_BITMAP(acpi_initrd_installed, NR_ACPI_INITRD_TABLES);\n\n#define MAP_CHUNK_SIZE   (NR_FIX_BTMAPS << PAGE_SHIFT)\n\nvoid __init acpi_table_upgrade(void)\n{\n\tvoid *data;\n\tsize_t size;\n\tint sig, no, table_nr = 0, total_offset = 0;\n\tlong offset = 0;\n\tstruct acpi_table_header *table;\n\tchar cpio_path[32] = \"kernel/firmware/acpi/\";\n\tstruct cpio_data file;\n\n\tif (IS_ENABLED(CONFIG_ACPI_TABLE_OVERRIDE_VIA_BUILTIN_INITRD)) {\n\t\tdata = __initramfs_start;\n\t\tsize = __initramfs_size;\n\t} else {\n\t\tdata = (void *)initrd_start;\n\t\tsize = initrd_end - initrd_start;\n\t}\n\n\tif (data == NULL || size == 0)\n\t\treturn;\n\n\tfor (no = 0; no < NR_ACPI_INITRD_TABLES; no++) {\n\t\tfile = find_cpio_data(cpio_path, data, size, &offset);\n\t\tif (!file.data)\n\t\t\tbreak;\n\n\t\tdata += offset;\n\t\tsize -= offset;\n\n\t\tif (file.size < sizeof(struct acpi_table_header)) {\n\t\t\tpr_err(\"ACPI OVERRIDE: Table smaller than ACPI header [%s%s]\\n\",\n\t\t\t\tcpio_path, file.name);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttable = file.data;\n\n\t\tfor (sig = 0; sig < ARRAY_SIZE(table_sigs); sig++)\n\t\t\tif (!memcmp(table->signature, table_sigs[sig], 4))\n\t\t\t\tbreak;\n\n\t\tif (sig >= ARRAY_SIZE(table_sigs)) {\n\t\t\tpr_err(\"ACPI OVERRIDE: Unknown signature [%s%s]\\n\",\n\t\t\t\tcpio_path, file.name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (file.size != table->length) {\n\t\t\tpr_err(\"ACPI OVERRIDE: File length does not match table length [%s%s]\\n\",\n\t\t\t\tcpio_path, file.name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (acpi_table_checksum(file.data, table->length)) {\n\t\t\tpr_err(\"ACPI OVERRIDE: Bad table checksum [%s%s]\\n\",\n\t\t\t\tcpio_path, file.name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_info(\"%4.4s ACPI table found in initrd [%s%s][0x%x]\\n\",\n\t\t\ttable->signature, cpio_path, file.name, table->length);\n\n\t\tall_tables_size += table->length;\n\t\tacpi_initrd_files[table_nr].data = file.data;\n\t\tacpi_initrd_files[table_nr].size = file.size;\n\t\ttable_nr++;\n\t}\n\tif (table_nr == 0)\n\t\treturn;\n\n\tif (security_locked_down(LOCKDOWN_ACPI_TABLES)) {\n\t\tpr_notice(\"kernel is locked down, ignoring table override\\n\");\n\t\treturn;\n\t}\n\n\tacpi_tables_addr =\n\t\tmemblock_phys_alloc_range(all_tables_size, PAGE_SIZE,\n\t\t\t\t\t  0, ACPI_TABLE_UPGRADE_MAX_PHYS);\n\tif (!acpi_tables_addr) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\t \n\tarch_reserve_mem_area(acpi_tables_addr, all_tables_size);\n\n\tkmemleak_ignore_phys(acpi_tables_addr);\n\n\t \n\tfor (no = 0; no < table_nr; no++) {\n\t\tunsigned char *src_p = acpi_initrd_files[no].data;\n\t\tphys_addr_t size = acpi_initrd_files[no].size;\n\t\tphys_addr_t dest_addr = acpi_tables_addr + total_offset;\n\t\tphys_addr_t slop, clen;\n\t\tchar *dest_p;\n\n\t\ttotal_offset += size;\n\n\t\twhile (size) {\n\t\t\tslop = dest_addr & ~PAGE_MASK;\n\t\t\tclen = size;\n\t\t\tif (clen > MAP_CHUNK_SIZE - slop)\n\t\t\t\tclen = MAP_CHUNK_SIZE - slop;\n\t\t\tdest_p = early_memremap(dest_addr & PAGE_MASK,\n\t\t\t\t\t\tclen + slop);\n\t\t\tmemcpy(dest_p + slop, src_p, clen);\n\t\t\tearly_memunmap(dest_p, clen + slop);\n\t\t\tsrc_p += clen;\n\t\t\tdest_addr += clen;\n\t\t\tsize -= clen;\n\t\t}\n\t}\n}\n\nstatic acpi_status\nacpi_table_initrd_override(struct acpi_table_header *existing_table,\n\t\t\t   acpi_physical_address *address, u32 *length)\n{\n\tint table_offset = 0;\n\tint table_index = 0;\n\tstruct acpi_table_header *table;\n\tu32 table_length;\n\n\t*length = 0;\n\t*address = 0;\n\tif (!acpi_tables_addr)\n\t\treturn AE_OK;\n\n\twhile (table_offset + ACPI_HEADER_SIZE <= all_tables_size) {\n\t\ttable = acpi_os_map_memory(acpi_tables_addr + table_offset,\n\t\t\t\t\t   ACPI_HEADER_SIZE);\n\t\tif (table_offset + table->length > all_tables_size) {\n\t\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\t\tWARN_ON(1);\n\t\t\treturn AE_OK;\n\t\t}\n\n\t\ttable_length = table->length;\n\n\t\t \n\t\tif (memcmp(existing_table->signature, table->signature, 4) ||\n\t\t    memcmp(table->oem_id, existing_table->oem_id,\n\t\t\t   ACPI_OEM_ID_SIZE) ||\n\t\t    memcmp(table->oem_table_id, existing_table->oem_table_id,\n\t\t\t   ACPI_OEM_TABLE_ID_SIZE)) {\n\t\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\t\tgoto next_table;\n\t\t}\n\t\t \n\t\tif (test_and_set_bit(table_index, acpi_initrd_installed) ||\n\t\t    existing_table->oem_revision >= table->oem_revision) {\n\t\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\t\tgoto next_table;\n\t\t}\n\n\t\t*length = table_length;\n\t\t*address = acpi_tables_addr + table_offset;\n\t\tpr_info(\"Table Upgrade: override [%4.4s-%6.6s-%8.8s]\\n\",\n\t\t\ttable->signature, table->oem_id,\n\t\t\ttable->oem_table_id);\n\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\tbreak;\n\nnext_table:\n\t\ttable_offset += table_length;\n\t\ttable_index++;\n\t}\n\treturn AE_OK;\n}\n\nstatic void __init acpi_table_initrd_scan(void)\n{\n\tint table_offset = 0;\n\tint table_index = 0;\n\tu32 table_length;\n\tstruct acpi_table_header *table;\n\n\tif (!acpi_tables_addr)\n\t\treturn;\n\n\twhile (table_offset + ACPI_HEADER_SIZE <= all_tables_size) {\n\t\ttable = acpi_os_map_memory(acpi_tables_addr + table_offset,\n\t\t\t\t\t   ACPI_HEADER_SIZE);\n\t\tif (table_offset + table->length > all_tables_size) {\n\t\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\n\t\ttable_length = table->length;\n\n\t\t \n\t\tif (ACPI_COMPARE_NAMESEG(table->signature, ACPI_SIG_RSDT) ||\n\t\t    ACPI_COMPARE_NAMESEG(table->signature, ACPI_SIG_XSDT)) {\n\t\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\t\tgoto next_table;\n\t\t}\n\t\t \n\t\tif (test_and_set_bit(table_index, acpi_initrd_installed)) {\n\t\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\t\tgoto next_table;\n\t\t}\n\n\t\tpr_info(\"Table Upgrade: install [%4.4s-%6.6s-%8.8s]\\n\",\n\t\t\ttable->signature, table->oem_id,\n\t\t\ttable->oem_table_id);\n\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\tacpi_install_physical_table(acpi_tables_addr + table_offset);\nnext_table:\n\t\ttable_offset += table_length;\n\t\ttable_index++;\n\t}\n}\n#else\nstatic acpi_status\nacpi_table_initrd_override(struct acpi_table_header *existing_table,\n\t\t\t   acpi_physical_address *address,\n\t\t\t   u32 *table_length)\n{\n\t*table_length = 0;\n\t*address = 0;\n\treturn AE_OK;\n}\n\nstatic void __init acpi_table_initrd_scan(void)\n{\n}\n#endif  \n\nacpi_status\nacpi_os_physical_table_override(struct acpi_table_header *existing_table,\n\t\t\t\tacpi_physical_address *address,\n\t\t\t\tu32 *table_length)\n{\n\treturn acpi_table_initrd_override(existing_table, address,\n\t\t\t\t\t  table_length);\n}\n\n#ifdef CONFIG_ACPI_CUSTOM_DSDT\nstatic void *amlcode __attribute__ ((weakref(\"AmlCode\")));\nstatic void *dsdt_amlcode __attribute__ ((weakref(\"dsdt_aml_code\")));\n#endif\n\nacpi_status acpi_os_table_override(struct acpi_table_header *existing_table,\n\t\t       struct acpi_table_header **new_table)\n{\n\tif (!existing_table || !new_table)\n\t\treturn AE_BAD_PARAMETER;\n\n\t*new_table = NULL;\n\n#ifdef CONFIG_ACPI_CUSTOM_DSDT\n\tif (!strncmp(existing_table->signature, \"DSDT\", 4)) {\n\t\t*new_table = (struct acpi_table_header *)&amlcode;\n\t\tif (!(*new_table))\n\t\t\t*new_table = (struct acpi_table_header *)&dsdt_amlcode;\n\t}\n#endif\n\tif (*new_table != NULL)\n\t\tacpi_table_taint(existing_table);\n\treturn AE_OK;\n}\n\n \nint __init acpi_locate_initial_tables(void)\n{\n\tacpi_status status;\n\n\tif (acpi_verify_table_checksum) {\n\t\tpr_info(\"Early table checksum verification enabled\\n\");\n\t\tacpi_gbl_enable_table_validation = TRUE;\n\t} else {\n\t\tpr_info(\"Early table checksum verification disabled\\n\");\n\t\tacpi_gbl_enable_table_validation = FALSE;\n\t}\n\n\tstatus = acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nvoid __init acpi_reserve_initial_tables(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ACPI_MAX_TABLES; i++) {\n\t\tstruct acpi_table_desc *table_desc = &initial_tables[i];\n\t\tu64 start = table_desc->address;\n\t\tu64 size = table_desc->length;\n\n\t\tif (!start || !size)\n\t\t\tbreak;\n\n\t\tpr_info(\"Reserving %4s table memory at [mem 0x%llx-0x%llx]\\n\",\n\t\t\ttable_desc->signature.ascii, start, start + size - 1);\n\n\t\tmemblock_reserve(start, size);\n\t}\n}\n\nvoid __init acpi_table_init_complete(void)\n{\n\tacpi_table_initrd_scan();\n\tcheck_multiple_madt();\n}\n\nint __init acpi_table_init(void)\n{\n\tint ret;\n\n\tret = acpi_locate_initial_tables();\n\tif (ret)\n\t\treturn ret;\n\n\tacpi_table_init_complete();\n\n\treturn 0;\n}\n\nstatic int __init acpi_parse_apic_instance(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (kstrtoint(str, 0, &acpi_apic_instance))\n\t\treturn -EINVAL;\n\n\tpr_notice(\"Shall use APIC/MADT table %d\\n\", acpi_apic_instance);\n\n\treturn 0;\n}\nearly_param(\"acpi_apic_instance\", acpi_parse_apic_instance);\n\nstatic int __init acpi_force_table_verification_setup(char *s)\n{\n\tacpi_verify_table_checksum = true;\n\n\treturn 0;\n}\nearly_param(\"acpi_force_table_verification\", acpi_force_table_verification_setup);\n\nstatic int __init acpi_force_32bit_fadt_addr(char *s)\n{\n\tpr_info(\"Forcing 32 Bit FADT addresses\\n\");\n\tacpi_gbl_use32_bit_fadt_addresses = TRUE;\n\n\treturn 0;\n}\nearly_param(\"acpi_force_32bit_fadt_addr\", acpi_force_32bit_fadt_addr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}