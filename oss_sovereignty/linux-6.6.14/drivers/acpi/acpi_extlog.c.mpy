{
  "module_name": "acpi_extlog.c",
  "hash_id": "c294979d4bd1f0bb4aa60678712c0c35ffa4b967d6af1806d1661652350e209c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_extlog.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/cper.h>\n#include <linux/ratelimit.h>\n#include <linux/edac.h>\n#include <linux/ras.h>\n#include <acpi/ghes.h>\n#include <asm/cpu.h>\n#include <asm/mce.h>\n\n#include \"apei/apei-internal.h\"\n#include <ras/ras_event.h>\n\n#define EXT_ELOG_ENTRY_MASK\tGENMASK_ULL(51, 0)  \n\n#define EXTLOG_DSM_REV\t\t0x0\n#define\tEXTLOG_FN_ADDR\t\t0x1\n\n#define FLAG_OS_OPTIN\t\tBIT(0)\n#define ELOG_ENTRY_VALID\t(1ULL<<63)\n#define ELOG_ENTRY_LEN\t\t0x1000\n\n#define EMCA_BUG \\\n\t\"Can not request iomem region <0x%016llx-0x%016llx> - eMCA disabled\\n\"\n\nstruct extlog_l1_head {\n\tu32 ver;\t \n\tu32 hdr_len;\t \n\tu64 total_len;\t \n\tu64 elog_base;\t \n\tu64 elog_len;\t \n\tu32 flags;\t \n\tu8  rev0[12];\n\tu32 entries;\t \n\tu8  rev1[12];\n};\n\nstatic u8 extlog_dsm_uuid[] __initdata = \"663E35AF-CC10-41A4-88EA-5470AF055295\";\n\n \nstatic u64 elog_base;\nstatic size_t elog_size;\nstatic u64 l1_dirbase;\nstatic size_t l1_size;\n\n \nstatic void __iomem *extlog_l1_addr;\nstatic void __iomem *elog_addr;\n\nstatic void *elog_buf;\n\nstatic u64 *l1_entry_base;\nstatic u32 l1_percpu_entry;\n\n#define ELOG_IDX(cpu, bank) \\\n\t(cpu_physical_id(cpu) * l1_percpu_entry + (bank))\n\n#define ELOG_ENTRY_DATA(idx) \\\n\t(*(l1_entry_base + (idx)))\n\n#define ELOG_ENTRY_ADDR(phyaddr) \\\n\t(phyaddr - elog_base + (u8 *)elog_addr)\n\nstatic struct acpi_hest_generic_status *extlog_elog_entry_check(int cpu, int bank)\n{\n\tint idx;\n\tu64 data;\n\tstruct acpi_hest_generic_status *estatus;\n\n\tWARN_ON(cpu < 0);\n\tidx = ELOG_IDX(cpu, bank);\n\tdata = ELOG_ENTRY_DATA(idx);\n\tif ((data & ELOG_ENTRY_VALID) == 0)\n\t\treturn NULL;\n\n\tdata &= EXT_ELOG_ENTRY_MASK;\n\testatus = (struct acpi_hest_generic_status *)ELOG_ENTRY_ADDR(data);\n\n\t \n\tif (estatus->block_status == 0)\n\t\treturn NULL;\n\n\treturn estatus;\n}\n\nstatic void __print_extlog_rcd(const char *pfx,\n\t\t\t       struct acpi_hest_generic_status *estatus, int cpu)\n{\n\tstatic atomic_t seqno;\n\tunsigned int curr_seqno;\n\tchar pfx_seq[64];\n\n\tif (!pfx) {\n\t\tif (estatus->error_severity <= CPER_SEV_CORRECTED)\n\t\t\tpfx = KERN_INFO;\n\t\telse\n\t\t\tpfx = KERN_ERR;\n\t}\n\tcurr_seqno = atomic_inc_return(&seqno);\n\tsnprintf(pfx_seq, sizeof(pfx_seq), \"%s{%u}\", pfx, curr_seqno);\n\tprintk(\"%s\"\"Hardware error detected on CPU%d\\n\", pfx_seq, cpu);\n\tcper_estatus_print(pfx_seq, estatus);\n}\n\nstatic int print_extlog_rcd(const char *pfx,\n\t\t\t    struct acpi_hest_generic_status *estatus, int cpu)\n{\n\t \n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_corrected, 5*HZ, 2);\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_uncorrected, 5*HZ, 2);\n\tstruct ratelimit_state *ratelimit;\n\n\tif (estatus->error_severity == CPER_SEV_CORRECTED ||\n\t    (estatus->error_severity == CPER_SEV_INFORMATIONAL))\n\t\tratelimit = &ratelimit_corrected;\n\telse\n\t\tratelimit = &ratelimit_uncorrected;\n\tif (__ratelimit(ratelimit)) {\n\t\t__print_extlog_rcd(pfx, estatus, cpu);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int extlog_print(struct notifier_block *nb, unsigned long val,\n\t\t\tvoid *data)\n{\n\tstruct mce *mce = (struct mce *)data;\n\tint\tbank = mce->bank;\n\tint\tcpu = mce->extcpu;\n\tstruct acpi_hest_generic_status *estatus, *tmp;\n\tstruct acpi_hest_generic_data *gdata;\n\tconst guid_t *fru_id;\n\tchar *fru_text;\n\tguid_t *sec_type;\n\tstatic u32 err_seq;\n\n\testatus = extlog_elog_entry_check(cpu, bank);\n\tif (!estatus)\n\t\treturn NOTIFY_DONE;\n\n\tif (mce->kflags & MCE_HANDLED_CEC) {\n\t\testatus->block_status = 0;\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tmemcpy(elog_buf, (void *)estatus, ELOG_ENTRY_LEN);\n\t \n\testatus->block_status = 0;\n\n\ttmp = (struct acpi_hest_generic_status *)elog_buf;\n\n\tif (!ras_userspace_consumers()) {\n\t\tprint_extlog_rcd(NULL, tmp, cpu);\n\t\tgoto out;\n\t}\n\n\t \n\terr_seq++;\n\tapei_estatus_for_each_section(tmp, gdata) {\n\t\tif (gdata->validation_bits & CPER_SEC_VALID_FRU_ID)\n\t\t\tfru_id = (guid_t *)gdata->fru_id;\n\t\telse\n\t\t\tfru_id = &guid_null;\n\t\tif (gdata->validation_bits & CPER_SEC_VALID_FRU_TEXT)\n\t\t\tfru_text = gdata->fru_text;\n\t\telse\n\t\t\tfru_text = \"\";\n\t\tsec_type = (guid_t *)gdata->section_type;\n\t\tif (guid_equal(sec_type, &CPER_SEC_PLATFORM_MEM)) {\n\t\t\tstruct cper_sec_mem_err *mem = acpi_hest_get_payload(gdata);\n\n\t\t\tif (gdata->error_data_length >= sizeof(*mem))\n\t\t\t\ttrace_extlog_mem_event(mem, err_seq, fru_id, fru_text,\n\t\t\t\t\t\t       (u8)gdata->error_severity);\n\t\t}\n\t}\n\nout:\n\tmce->kflags |= MCE_HANDLED_EXTLOG;\n\treturn NOTIFY_OK;\n}\n\nstatic bool __init extlog_get_l1addr(void)\n{\n\tguid_t guid;\n\tacpi_handle handle;\n\tunion acpi_object *obj;\n\n\tif (guid_parse(extlog_dsm_uuid, &guid))\n\t\treturn false;\n\tif (ACPI_FAILURE(acpi_get_handle(NULL, \"\\\\_SB\", &handle)))\n\t\treturn false;\n\tif (!acpi_check_dsm(handle, &guid, EXTLOG_DSM_REV, 1 << EXTLOG_FN_ADDR))\n\t\treturn false;\n\tobj = acpi_evaluate_dsm_typed(handle, &guid, EXTLOG_DSM_REV,\n\t\t\t\t      EXTLOG_FN_ADDR, NULL, ACPI_TYPE_INTEGER);\n\tif (!obj) {\n\t\treturn false;\n\t} else {\n\t\tl1_dirbase = obj->integer.value;\n\t\tACPI_FREE(obj);\n\t}\n\n\t \n\tif (l1_dirbase & ((1 << 12) - 1)) {\n\t\tpr_warn(FW_BUG \"L1 Directory is invalid at physical %llx\\n\",\n\t\t\tl1_dirbase);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nstatic struct notifier_block extlog_mce_dec = {\n\t.notifier_call\t= extlog_print,\n\t.priority\t= MCE_PRIO_EXTLOG,\n};\n\nstatic int __init extlog_init(void)\n{\n\tstruct extlog_l1_head *l1_head;\n\tvoid __iomem *extlog_l1_hdr;\n\tsize_t l1_hdr_size;\n\tstruct resource *r;\n\tu64 cap;\n\tint rc;\n\n\tif (rdmsrl_safe(MSR_IA32_MCG_CAP, &cap) ||\n\t    !(cap & MCG_ELOG_P) ||\n\t    !extlog_get_l1addr())\n\t\treturn -ENODEV;\n\n\trc = -EINVAL;\n\t \n\tl1_hdr_size = sizeof(struct extlog_l1_head);\n\tr = request_mem_region(l1_dirbase, l1_hdr_size, \"L1 DIR HDR\");\n\tif (!r) {\n\t\tpr_warn(FW_BUG EMCA_BUG,\n\t\t\t(unsigned long long)l1_dirbase,\n\t\t\t(unsigned long long)l1_dirbase + l1_hdr_size);\n\t\tgoto err;\n\t}\n\n\textlog_l1_hdr = acpi_os_map_iomem(l1_dirbase, l1_hdr_size);\n\tl1_head = (struct extlog_l1_head *)extlog_l1_hdr;\n\tl1_size = l1_head->total_len;\n\tl1_percpu_entry = l1_head->entries;\n\telog_base = l1_head->elog_base;\n\telog_size = l1_head->elog_len;\n\tacpi_os_unmap_iomem(extlog_l1_hdr, l1_hdr_size);\n\trelease_mem_region(l1_dirbase, l1_hdr_size);\n\n\t \n\tr = request_mem_region(l1_dirbase, l1_size, \"L1 Table\");\n\tif (!r) {\n\t\tpr_warn(FW_BUG EMCA_BUG,\n\t\t\t(unsigned long long)l1_dirbase,\n\t\t\t(unsigned long long)l1_dirbase + l1_size);\n\t\tgoto err;\n\t}\n\textlog_l1_addr = acpi_os_map_iomem(l1_dirbase, l1_size);\n\tl1_entry_base = (u64 *)((u8 *)extlog_l1_addr + l1_hdr_size);\n\n\t \n\tr = request_mem_region(elog_base, elog_size, \"Elog Table\");\n\tif (!r) {\n\t\tpr_warn(FW_BUG EMCA_BUG,\n\t\t\t(unsigned long long)elog_base,\n\t\t\t(unsigned long long)elog_base + elog_size);\n\t\tgoto err_release_l1_dir;\n\t}\n\telog_addr = acpi_os_map_iomem(elog_base, elog_size);\n\n\trc = -ENOMEM;\n\t \n\telog_buf = kmalloc(ELOG_ENTRY_LEN, GFP_KERNEL);\n\tif (elog_buf == NULL)\n\t\tgoto err_release_elog;\n\n\tmce_register_decode_chain(&extlog_mce_dec);\n\t \n\t((struct extlog_l1_head *)extlog_l1_addr)->flags |= FLAG_OS_OPTIN;\n\n\treturn 0;\n\nerr_release_elog:\n\tif (elog_addr)\n\t\tacpi_os_unmap_iomem(elog_addr, elog_size);\n\trelease_mem_region(elog_base, elog_size);\nerr_release_l1_dir:\n\tif (extlog_l1_addr)\n\t\tacpi_os_unmap_iomem(extlog_l1_addr, l1_size);\n\trelease_mem_region(l1_dirbase, l1_size);\nerr:\n\tpr_warn(FW_BUG \"Extended error log disabled because of problems parsing f/w tables\\n\");\n\treturn rc;\n}\n\nstatic void __exit extlog_exit(void)\n{\n\tmce_unregister_decode_chain(&extlog_mce_dec);\n\t((struct extlog_l1_head *)extlog_l1_addr)->flags &= ~FLAG_OS_OPTIN;\n\tif (extlog_l1_addr)\n\t\tacpi_os_unmap_iomem(extlog_l1_addr, l1_size);\n\tif (elog_addr)\n\t\tacpi_os_unmap_iomem(elog_addr, elog_size);\n\trelease_mem_region(elog_base, elog_size);\n\trelease_mem_region(l1_dirbase, l1_size);\n\tkfree(elog_buf);\n}\n\nmodule_init(extlog_init);\nmodule_exit(extlog_exit);\n\nMODULE_AUTHOR(\"Chen, Gong <gong.chen@intel.com>\");\nMODULE_DESCRIPTION(\"Extended MCA Error Log Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}