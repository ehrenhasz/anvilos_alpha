{
  "module_name": "acpi_ipmi.c",
  "hash_id": "29770742e5f6822589c0d039c435cd14b75298ef7f474c59dabcb0a67dee6cae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_ipmi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/ipmi.h>\n#include <linux/spinlock.h>\n\nMODULE_AUTHOR(\"Zhao Yakui\");\nMODULE_DESCRIPTION(\"ACPI IPMI Opregion driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define ACPI_IPMI_OK\t\t\t0\n#define ACPI_IPMI_TIMEOUT\t\t0x10\n#define ACPI_IPMI_UNKNOWN\t\t0x07\n \n#define IPMI_TIMEOUT\t\t\t(5000)\n#define ACPI_IPMI_MAX_MSG_LENGTH\t64\n\nstruct acpi_ipmi_device {\n\t \n\tstruct list_head head;\n\n\t \n\tstruct list_head tx_msg_list;\n\n\tspinlock_t tx_msg_lock;\n\tacpi_handle handle;\n\tstruct device *dev;\n\tstruct ipmi_user *user_interface;\n\tint ipmi_ifnum;  \n\tlong curr_msgid;\n\tbool dead;\n\tstruct kref kref;\n};\n\nstruct ipmi_driver_data {\n\tstruct list_head ipmi_devices;\n\tstruct ipmi_smi_watcher bmc_events;\n\tconst struct ipmi_user_hndl ipmi_hndlrs;\n\tstruct mutex ipmi_lock;\n\n\t \n\tstruct acpi_ipmi_device *selected_smi;\n};\n\nstruct acpi_ipmi_msg {\n\tstruct list_head head;\n\n\t \n\tstruct ipmi_addr addr;\n\tlong tx_msgid;\n\n\t \n\tstruct completion tx_complete;\n\n\tstruct kernel_ipmi_msg tx_message;\n\tint msg_done;\n\n\t \n\tu8 data[ACPI_IPMI_MAX_MSG_LENGTH];\n\tu8 rx_len;\n\n\tstruct acpi_ipmi_device *device;\n\tstruct kref kref;\n};\n\n \nstruct acpi_ipmi_buffer {\n\tu8 status;\n\tu8 length;\n\tu8 data[ACPI_IPMI_MAX_MSG_LENGTH];\n};\n\nstatic void ipmi_register_bmc(int iface, struct device *dev);\nstatic void ipmi_bmc_gone(int iface);\nstatic void ipmi_msg_handler(struct ipmi_recv_msg *msg, void *user_msg_data);\n\nstatic struct ipmi_driver_data driver_data = {\n\t.ipmi_devices = LIST_HEAD_INIT(driver_data.ipmi_devices),\n\t.bmc_events = {\n\t\t.owner = THIS_MODULE,\n\t\t.new_smi = ipmi_register_bmc,\n\t\t.smi_gone = ipmi_bmc_gone,\n\t},\n\t.ipmi_hndlrs = {\n\t\t.ipmi_recv_hndl = ipmi_msg_handler,\n\t},\n\t.ipmi_lock = __MUTEX_INITIALIZER(driver_data.ipmi_lock)\n};\n\nstatic struct acpi_ipmi_device *\nipmi_dev_alloc(int iface, struct device *dev, acpi_handle handle)\n{\n\tstruct acpi_ipmi_device *ipmi_device;\n\tint err;\n\tstruct ipmi_user *user;\n\n\tipmi_device = kzalloc(sizeof(*ipmi_device), GFP_KERNEL);\n\tif (!ipmi_device)\n\t\treturn NULL;\n\n\tkref_init(&ipmi_device->kref);\n\tINIT_LIST_HEAD(&ipmi_device->head);\n\tINIT_LIST_HEAD(&ipmi_device->tx_msg_list);\n\tspin_lock_init(&ipmi_device->tx_msg_lock);\n\tipmi_device->handle = handle;\n\tipmi_device->dev = get_device(dev);\n\tipmi_device->ipmi_ifnum = iface;\n\n\terr = ipmi_create_user(iface, &driver_data.ipmi_hndlrs,\n\t\t\t       ipmi_device, &user);\n\tif (err) {\n\t\tput_device(dev);\n\t\tkfree(ipmi_device);\n\t\treturn NULL;\n\t}\n\tipmi_device->user_interface = user;\n\n\treturn ipmi_device;\n}\n\nstatic void ipmi_dev_release(struct acpi_ipmi_device *ipmi_device)\n{\n\tipmi_destroy_user(ipmi_device->user_interface);\n\tput_device(ipmi_device->dev);\n\tkfree(ipmi_device);\n}\n\nstatic void ipmi_dev_release_kref(struct kref *kref)\n{\n\tstruct acpi_ipmi_device *ipmi =\n\t\tcontainer_of(kref, struct acpi_ipmi_device, kref);\n\n\tipmi_dev_release(ipmi);\n}\n\nstatic void __ipmi_dev_kill(struct acpi_ipmi_device *ipmi_device)\n{\n\tlist_del(&ipmi_device->head);\n\tif (driver_data.selected_smi == ipmi_device)\n\t\tdriver_data.selected_smi = NULL;\n\n\t \n\tipmi_device->dead = true;\n}\n\nstatic struct acpi_ipmi_device *acpi_ipmi_dev_get(void)\n{\n\tstruct acpi_ipmi_device *ipmi_device = NULL;\n\n\tmutex_lock(&driver_data.ipmi_lock);\n\tif (driver_data.selected_smi) {\n\t\tipmi_device = driver_data.selected_smi;\n\t\tkref_get(&ipmi_device->kref);\n\t}\n\tmutex_unlock(&driver_data.ipmi_lock);\n\n\treturn ipmi_device;\n}\n\nstatic void acpi_ipmi_dev_put(struct acpi_ipmi_device *ipmi_device)\n{\n\tkref_put(&ipmi_device->kref, ipmi_dev_release_kref);\n}\n\nstatic struct acpi_ipmi_msg *ipmi_msg_alloc(void)\n{\n\tstruct acpi_ipmi_device *ipmi;\n\tstruct acpi_ipmi_msg *ipmi_msg;\n\n\tipmi = acpi_ipmi_dev_get();\n\tif (!ipmi)\n\t\treturn NULL;\n\n\tipmi_msg = kzalloc(sizeof(struct acpi_ipmi_msg), GFP_KERNEL);\n\tif (!ipmi_msg) {\n\t\tacpi_ipmi_dev_put(ipmi);\n\t\treturn NULL;\n\t}\n\n\tkref_init(&ipmi_msg->kref);\n\tinit_completion(&ipmi_msg->tx_complete);\n\tINIT_LIST_HEAD(&ipmi_msg->head);\n\tipmi_msg->device = ipmi;\n\tipmi_msg->msg_done = ACPI_IPMI_UNKNOWN;\n\n\treturn ipmi_msg;\n}\n\nstatic void ipmi_msg_release(struct acpi_ipmi_msg *tx_msg)\n{\n\tacpi_ipmi_dev_put(tx_msg->device);\n\tkfree(tx_msg);\n}\n\nstatic void ipmi_msg_release_kref(struct kref *kref)\n{\n\tstruct acpi_ipmi_msg *tx_msg =\n\t\tcontainer_of(kref, struct acpi_ipmi_msg, kref);\n\n\tipmi_msg_release(tx_msg);\n}\n\nstatic struct acpi_ipmi_msg *acpi_ipmi_msg_get(struct acpi_ipmi_msg *tx_msg)\n{\n\tkref_get(&tx_msg->kref);\n\n\treturn tx_msg;\n}\n\nstatic void acpi_ipmi_msg_put(struct acpi_ipmi_msg *tx_msg)\n{\n\tkref_put(&tx_msg->kref, ipmi_msg_release_kref);\n}\n\n#define IPMI_OP_RGN_NETFN(offset)\t((offset >> 8) & 0xff)\n#define IPMI_OP_RGN_CMD(offset)\t\t(offset & 0xff)\nstatic int acpi_format_ipmi_request(struct acpi_ipmi_msg *tx_msg,\n\t\t\t\t    acpi_physical_address address,\n\t\t\t\t    acpi_integer *value)\n{\n\tstruct kernel_ipmi_msg *msg;\n\tstruct acpi_ipmi_buffer *buffer;\n\tstruct acpi_ipmi_device *device;\n\tunsigned long flags;\n\n\tmsg = &tx_msg->tx_message;\n\n\t \n\tmsg->netfn = IPMI_OP_RGN_NETFN(address);\n\tmsg->cmd = IPMI_OP_RGN_CMD(address);\n\tmsg->data = tx_msg->data;\n\n\t \n\tbuffer = (struct acpi_ipmi_buffer *)value;\n\n\t \n\tif (buffer->length > ACPI_IPMI_MAX_MSG_LENGTH) {\n\t\tdev_WARN_ONCE(tx_msg->device->dev, true,\n\t\t\t      \"Unexpected request (msg len %d).\\n\",\n\t\t\t      buffer->length);\n\t\treturn -EINVAL;\n\t}\n\tmsg->data_len = buffer->length;\n\tmemcpy(tx_msg->data, buffer->data, msg->data_len);\n\n\t \n\ttx_msg->addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\ttx_msg->addr.channel = IPMI_BMC_CHANNEL;\n\ttx_msg->addr.data[0] = 0;\n\n\t \n\tdevice = tx_msg->device;\n\n\tspin_lock_irqsave(&device->tx_msg_lock, flags);\n\tdevice->curr_msgid++;\n\ttx_msg->tx_msgid = device->curr_msgid;\n\tspin_unlock_irqrestore(&device->tx_msg_lock, flags);\n\n\treturn 0;\n}\n\nstatic void acpi_format_ipmi_response(struct acpi_ipmi_msg *msg,\n\t\t\t\t      acpi_integer *value)\n{\n\tstruct acpi_ipmi_buffer *buffer;\n\n\t \n\tbuffer = (struct acpi_ipmi_buffer *)value;\n\n\t \n\tbuffer->status = msg->msg_done;\n\tif (msg->msg_done != ACPI_IPMI_OK)\n\t\treturn;\n\n\t \n\tbuffer->length = msg->rx_len;\n\tmemcpy(buffer->data, msg->data, msg->rx_len);\n}\n\nstatic void ipmi_flush_tx_msg(struct acpi_ipmi_device *ipmi)\n{\n\tstruct acpi_ipmi_msg *tx_msg;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&ipmi->tx_msg_lock, flags);\n\twhile (!list_empty(&ipmi->tx_msg_list)) {\n\t\ttx_msg = list_first_entry(&ipmi->tx_msg_list,\n\t\t\t\t\t  struct acpi_ipmi_msg,\n\t\t\t\t\t  head);\n\t\tlist_del(&tx_msg->head);\n\t\tspin_unlock_irqrestore(&ipmi->tx_msg_lock, flags);\n\n\t\t \n\t\tcomplete(&tx_msg->tx_complete);\n\t\tacpi_ipmi_msg_put(tx_msg);\n\t\tspin_lock_irqsave(&ipmi->tx_msg_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&ipmi->tx_msg_lock, flags);\n}\n\nstatic void ipmi_cancel_tx_msg(struct acpi_ipmi_device *ipmi,\n\t\t\t       struct acpi_ipmi_msg *msg)\n{\n\tstruct acpi_ipmi_msg *tx_msg = NULL, *iter, *temp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ipmi->tx_msg_lock, flags);\n\tlist_for_each_entry_safe(iter, temp, &ipmi->tx_msg_list, head) {\n\t\tif (msg == iter) {\n\t\t\ttx_msg = iter;\n\t\t\tlist_del(&iter->head);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ipmi->tx_msg_lock, flags);\n\n\tif (tx_msg)\n\t\tacpi_ipmi_msg_put(tx_msg);\n}\n\nstatic void ipmi_msg_handler(struct ipmi_recv_msg *msg, void *user_msg_data)\n{\n\tstruct acpi_ipmi_device *ipmi_device = user_msg_data;\n\tstruct acpi_ipmi_msg *tx_msg = NULL, *iter, *temp;\n\tstruct device *dev = ipmi_device->dev;\n\tunsigned long flags;\n\n\tif (msg->user != ipmi_device->user_interface) {\n\t\tdev_warn(dev,\n\t\t\t \"Unexpected response is returned. returned user %p, expected user %p\\n\",\n\t\t\t msg->user, ipmi_device->user_interface);\n\t\tgoto out_msg;\n\t}\n\n\tspin_lock_irqsave(&ipmi_device->tx_msg_lock, flags);\n\tlist_for_each_entry_safe(iter, temp, &ipmi_device->tx_msg_list, head) {\n\t\tif (msg->msgid == iter->tx_msgid) {\n\t\t\ttx_msg = iter;\n\t\t\tlist_del(&iter->head);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ipmi_device->tx_msg_lock, flags);\n\n\tif (!tx_msg) {\n\t\tdev_warn(dev,\n\t\t\t \"Unexpected response (msg id %ld) is returned.\\n\",\n\t\t\t msg->msgid);\n\t\tgoto out_msg;\n\t}\n\n\t \n\tif (msg->msg.data_len > ACPI_IPMI_MAX_MSG_LENGTH) {\n\t\tdev_WARN_ONCE(dev, true,\n\t\t\t      \"Unexpected response (msg len %d).\\n\",\n\t\t\t      msg->msg.data_len);\n\t\tgoto out_comp;\n\t}\n\n\t \n\tmsg->recv_type = IPMI_RESPONSE_RECV_TYPE;\n\tif (msg->recv_type == IPMI_RESPONSE_RECV_TYPE &&\n\t    msg->msg.data_len == 1) {\n\t\tif (msg->msg.data[0] == IPMI_TIMEOUT_COMPLETION_CODE) {\n\t\t\tdev_dbg_once(dev, \"Unexpected response (timeout).\\n\");\n\t\t\ttx_msg->msg_done = ACPI_IPMI_TIMEOUT;\n\t\t}\n\t\tgoto out_comp;\n\t}\n\n\ttx_msg->rx_len = msg->msg.data_len;\n\tmemcpy(tx_msg->data, msg->msg.data, tx_msg->rx_len);\n\ttx_msg->msg_done = ACPI_IPMI_OK;\n\nout_comp:\n\tcomplete(&tx_msg->tx_complete);\n\tacpi_ipmi_msg_put(tx_msg);\nout_msg:\n\tipmi_free_recv_msg(msg);\n}\n\nstatic void ipmi_register_bmc(int iface, struct device *dev)\n{\n\tstruct acpi_ipmi_device *ipmi_device, *temp;\n\tint err;\n\tstruct ipmi_smi_info smi_data;\n\tacpi_handle handle;\n\n\terr = ipmi_get_smi_info(iface, &smi_data);\n\tif (err)\n\t\treturn;\n\n\tif (smi_data.addr_src != SI_ACPI)\n\t\tgoto err_ref;\n\thandle = smi_data.addr_info.acpi_info.acpi_handle;\n\tif (!handle)\n\t\tgoto err_ref;\n\n\tipmi_device = ipmi_dev_alloc(iface, smi_data.dev, handle);\n\tif (!ipmi_device) {\n\t\tdev_warn(smi_data.dev, \"Can't create IPMI user interface\\n\");\n\t\tgoto err_ref;\n\t}\n\n\tmutex_lock(&driver_data.ipmi_lock);\n\tlist_for_each_entry(temp, &driver_data.ipmi_devices, head) {\n\t\t \n\t\tif (temp->handle == handle)\n\t\t\tgoto err_lock;\n\t}\n\tif (!driver_data.selected_smi)\n\t\tdriver_data.selected_smi = ipmi_device;\n\tlist_add_tail(&ipmi_device->head, &driver_data.ipmi_devices);\n\tmutex_unlock(&driver_data.ipmi_lock);\n\n\tput_device(smi_data.dev);\n\treturn;\n\nerr_lock:\n\tmutex_unlock(&driver_data.ipmi_lock);\n\tipmi_dev_release(ipmi_device);\nerr_ref:\n\tput_device(smi_data.dev);\n}\n\nstatic void ipmi_bmc_gone(int iface)\n{\n\tstruct acpi_ipmi_device *ipmi_device = NULL, *iter, *temp;\n\n\tmutex_lock(&driver_data.ipmi_lock);\n\tlist_for_each_entry_safe(iter, temp,\n\t\t\t\t &driver_data.ipmi_devices, head) {\n\t\tif (iter->ipmi_ifnum != iface) {\n\t\t\tipmi_device = iter;\n\t\t\t__ipmi_dev_kill(iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!driver_data.selected_smi)\n\t\tdriver_data.selected_smi = list_first_entry_or_null(\n\t\t\t\t\t&driver_data.ipmi_devices,\n\t\t\t\t\tstruct acpi_ipmi_device, head);\n\tmutex_unlock(&driver_data.ipmi_lock);\n\n\tif (ipmi_device) {\n\t\tipmi_flush_tx_msg(ipmi_device);\n\t\tacpi_ipmi_dev_put(ipmi_device);\n\t}\n}\n\n \nstatic acpi_status\nacpi_ipmi_space_handler(u32 function, acpi_physical_address address,\n\t\t\tu32 bits, acpi_integer *value,\n\t\t\tvoid *handler_context, void *region_context)\n{\n\tstruct acpi_ipmi_msg *tx_msg;\n\tstruct acpi_ipmi_device *ipmi_device;\n\tint err;\n\tacpi_status status;\n\tunsigned long flags;\n\n\t \n\tif ((function & ACPI_IO_MASK) == ACPI_READ)\n\t\treturn AE_TYPE;\n\n\ttx_msg = ipmi_msg_alloc();\n\tif (!tx_msg)\n\t\treturn AE_NOT_EXIST;\n\tipmi_device = tx_msg->device;\n\n\tif (acpi_format_ipmi_request(tx_msg, address, value) != 0) {\n\t\tipmi_msg_release(tx_msg);\n\t\treturn AE_TYPE;\n\t}\n\n\tacpi_ipmi_msg_get(tx_msg);\n\tmutex_lock(&driver_data.ipmi_lock);\n\t \n\tif (ipmi_device->dead) {\n\t\tmutex_unlock(&driver_data.ipmi_lock);\n\t\tipmi_msg_release(tx_msg);\n\t\treturn AE_NOT_EXIST;\n\t}\n\tspin_lock_irqsave(&ipmi_device->tx_msg_lock, flags);\n\tlist_add_tail(&tx_msg->head, &ipmi_device->tx_msg_list);\n\tspin_unlock_irqrestore(&ipmi_device->tx_msg_lock, flags);\n\tmutex_unlock(&driver_data.ipmi_lock);\n\n\terr = ipmi_request_settime(ipmi_device->user_interface,\n\t\t\t\t   &tx_msg->addr,\n\t\t\t\t   tx_msg->tx_msgid,\n\t\t\t\t   &tx_msg->tx_message,\n\t\t\t\t   NULL, 0, 0, IPMI_TIMEOUT);\n\tif (err) {\n\t\tstatus = AE_ERROR;\n\t\tgoto out_msg;\n\t}\n\twait_for_completion(&tx_msg->tx_complete);\n\n\tacpi_format_ipmi_response(tx_msg, value);\n\tstatus = AE_OK;\n\nout_msg:\n\tipmi_cancel_tx_msg(ipmi_device, tx_msg);\n\tacpi_ipmi_msg_put(tx_msg);\n\treturn status;\n}\n\nstatic int __init acpi_ipmi_init(void)\n{\n\tint result;\n\tacpi_status status;\n\n\tif (acpi_disabled)\n\t\treturn 0;\n\n\tstatus = acpi_install_address_space_handler(ACPI_ROOT_OBJECT,\n\t\t\t\t\t\t    ACPI_ADR_SPACE_IPMI,\n\t\t\t\t\t\t    &acpi_ipmi_space_handler,\n\t\t\t\t\t\t    NULL, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_warn(\"Can't register IPMI opregion space handle\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tresult = ipmi_smi_watcher_register(&driver_data.bmc_events);\n\tif (result) {\n\t\tacpi_remove_address_space_handler(ACPI_ROOT_OBJECT,\n\t\t\t\t\t\t\t\t\t\t  ACPI_ADR_SPACE_IPMI,\n\t\t\t\t\t\t\t\t\t\t  &acpi_ipmi_space_handler);\n\t\tpr_err(\"Can't register IPMI system interface watcher\\n\");\n\t}\n\n\treturn result;\n}\n\nstatic void __exit acpi_ipmi_exit(void)\n{\n\tstruct acpi_ipmi_device *ipmi_device;\n\n\tif (acpi_disabled)\n\t\treturn;\n\n\tipmi_smi_watcher_unregister(&driver_data.bmc_events);\n\n\t \n\tmutex_lock(&driver_data.ipmi_lock);\n\twhile (!list_empty(&driver_data.ipmi_devices)) {\n\t\tipmi_device = list_first_entry(&driver_data.ipmi_devices,\n\t\t\t\t\t       struct acpi_ipmi_device,\n\t\t\t\t\t       head);\n\t\t__ipmi_dev_kill(ipmi_device);\n\t\tmutex_unlock(&driver_data.ipmi_lock);\n\n\t\tipmi_flush_tx_msg(ipmi_device);\n\t\tacpi_ipmi_dev_put(ipmi_device);\n\n\t\tmutex_lock(&driver_data.ipmi_lock);\n\t}\n\tmutex_unlock(&driver_data.ipmi_lock);\n\tacpi_remove_address_space_handler(ACPI_ROOT_OBJECT,\n\t\t\t\t\t  ACPI_ADR_SPACE_IPMI,\n\t\t\t\t\t  &acpi_ipmi_space_handler);\n}\n\nmodule_init(acpi_ipmi_init);\nmodule_exit(acpi_ipmi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}