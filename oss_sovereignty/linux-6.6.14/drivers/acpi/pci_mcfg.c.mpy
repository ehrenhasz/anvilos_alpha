{
  "module_name": "pci_mcfg.c",
  "hash_id": "510f4d93183c0463a1396d1e6c5dabacdda67c53d7bd2bb1e7d69d1e2b0484ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pci_mcfg.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/pci-acpi.h>\n#include <linux/pci-ecam.h>\n\n \nstruct mcfg_entry {\n\tstruct list_head\tlist;\n\tphys_addr_t\t\taddr;\n\tu16\t\t\tsegment;\n\tu8\t\t\tbus_start;\n\tu8\t\t\tbus_end;\n};\n\n#ifdef CONFIG_PCI_QUIRKS\nstruct mcfg_fixup {\n\tchar oem_id[ACPI_OEM_ID_SIZE + 1];\n\tchar oem_table_id[ACPI_OEM_TABLE_ID_SIZE + 1];\n\tu32 oem_revision;\n\tu16 segment;\n\tstruct resource bus_range;\n\tconst struct pci_ecam_ops *ops;\n\tstruct resource cfgres;\n};\n\n#define MCFG_BUS_RANGE(start, end)\tDEFINE_RES_NAMED((start),\t\\\n\t\t\t\t\t\t((end) - (start) + 1),\t\\\n\t\t\t\t\t\tNULL, IORESOURCE_BUS)\n#define MCFG_BUS_ANY\t\t\tMCFG_BUS_RANGE(0x0, 0xff)\n\nstatic struct mcfg_fixup mcfg_quirks[] = {\n \n\n#ifdef CONFIG_ARM64\n\n#define AL_ECAM(table_id, rev, seg, ops) \\\n\t{ \"AMAZON\", table_id, rev, seg, MCFG_BUS_ANY, ops }\n\n\tAL_ECAM(\"GRAVITON\", 0, 0, &al_pcie_ops),\n\tAL_ECAM(\"GRAVITON\", 0, 1, &al_pcie_ops),\n\tAL_ECAM(\"GRAVITON\", 0, 2, &al_pcie_ops),\n\tAL_ECAM(\"GRAVITON\", 0, 3, &al_pcie_ops),\n\tAL_ECAM(\"GRAVITON\", 0, 4, &al_pcie_ops),\n\tAL_ECAM(\"GRAVITON\", 0, 5, &al_pcie_ops),\n\tAL_ECAM(\"GRAVITON\", 0, 6, &al_pcie_ops),\n\tAL_ECAM(\"GRAVITON\", 0, 7, &al_pcie_ops),\n\n#define QCOM_ECAM32(seg) \\\n\t{ \"QCOM  \", \"QDF2432 \", 1, seg, MCFG_BUS_ANY, &pci_32b_ops }\n\n\tQCOM_ECAM32(0),\n\tQCOM_ECAM32(1),\n\tQCOM_ECAM32(2),\n\tQCOM_ECAM32(3),\n\tQCOM_ECAM32(4),\n\tQCOM_ECAM32(5),\n\tQCOM_ECAM32(6),\n\tQCOM_ECAM32(7),\n\n#define HISI_QUAD_DOM(table_id, seg, ops) \\\n\t{ \"HISI  \", table_id, 0, (seg) + 0, MCFG_BUS_ANY, ops }, \\\n\t{ \"HISI  \", table_id, 0, (seg) + 1, MCFG_BUS_ANY, ops }, \\\n\t{ \"HISI  \", table_id, 0, (seg) + 2, MCFG_BUS_ANY, ops }, \\\n\t{ \"HISI  \", table_id, 0, (seg) + 3, MCFG_BUS_ANY, ops }\n\n\tHISI_QUAD_DOM(\"HIP05   \",  0, &hisi_pcie_ops),\n\tHISI_QUAD_DOM(\"HIP06   \",  0, &hisi_pcie_ops),\n\tHISI_QUAD_DOM(\"HIP07   \",  0, &hisi_pcie_ops),\n\tHISI_QUAD_DOM(\"HIP07   \",  4, &hisi_pcie_ops),\n\tHISI_QUAD_DOM(\"HIP07   \",  8, &hisi_pcie_ops),\n\tHISI_QUAD_DOM(\"HIP07   \", 12, &hisi_pcie_ops),\n\n#define THUNDER_PEM_RES(addr, node) \\\n\tDEFINE_RES_MEM((addr) + ((u64) (node) << 44), 0x39 * SZ_16M)\n\n#define THUNDER_PEM_QUIRK(rev, node) \\\n\t{ \"CAVIUM\", \"THUNDERX\", rev, 4 + (10 * (node)), MCFG_BUS_ANY,\t    \\\n\t  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x88001f000000UL, node) },  \\\n\t{ \"CAVIUM\", \"THUNDERX\", rev, 5 + (10 * (node)), MCFG_BUS_ANY,\t    \\\n\t  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x884057000000UL, node) },  \\\n\t{ \"CAVIUM\", \"THUNDERX\", rev, 6 + (10 * (node)), MCFG_BUS_ANY,\t    \\\n\t  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x88808f000000UL, node) },  \\\n\t{ \"CAVIUM\", \"THUNDERX\", rev, 7 + (10 * (node)), MCFG_BUS_ANY,\t    \\\n\t  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x89001f000000UL, node) },  \\\n\t{ \"CAVIUM\", \"THUNDERX\", rev, 8 + (10 * (node)), MCFG_BUS_ANY,\t    \\\n\t  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x894057000000UL, node) },  \\\n\t{ \"CAVIUM\", \"THUNDERX\", rev, 9 + (10 * (node)), MCFG_BUS_ANY,\t    \\\n\t  &thunder_pem_ecam_ops, THUNDER_PEM_RES(0x89808f000000UL, node) }\n\n#define THUNDER_ECAM_QUIRK(rev, seg)\t\t\t\t\t\\\n\t{ \"CAVIUM\", \"THUNDERX\", rev, seg, MCFG_BUS_ANY,\t\t\t\\\n\t&pci_thunder_ecam_ops }\n\n\t \n\tTHUNDER_PEM_QUIRK(1, 0),\n\tTHUNDER_PEM_QUIRK(1, 1),\n\tTHUNDER_ECAM_QUIRK(1, 10),\n\n\t \n\tTHUNDER_PEM_QUIRK(2, 0),\t \n\tTHUNDER_PEM_QUIRK(2, 1),\t \n\tTHUNDER_ECAM_QUIRK(2,  0),\n\tTHUNDER_ECAM_QUIRK(2,  1),\n\tTHUNDER_ECAM_QUIRK(2,  2),\n\tTHUNDER_ECAM_QUIRK(2,  3),\n\tTHUNDER_ECAM_QUIRK(2, 10),\n\tTHUNDER_ECAM_QUIRK(2, 11),\n\tTHUNDER_ECAM_QUIRK(2, 12),\n\tTHUNDER_ECAM_QUIRK(2, 13),\n\n\t{ \"NVIDIA\", \"TEGRA194\", 1, 0, MCFG_BUS_ANY, &tegra194_pcie_ops},\n\t{ \"NVIDIA\", \"TEGRA194\", 1, 1, MCFG_BUS_ANY, &tegra194_pcie_ops},\n\t{ \"NVIDIA\", \"TEGRA194\", 1, 2, MCFG_BUS_ANY, &tegra194_pcie_ops},\n\t{ \"NVIDIA\", \"TEGRA194\", 1, 3, MCFG_BUS_ANY, &tegra194_pcie_ops},\n\t{ \"NVIDIA\", \"TEGRA194\", 1, 4, MCFG_BUS_ANY, &tegra194_pcie_ops},\n\t{ \"NVIDIA\", \"TEGRA194\", 1, 5, MCFG_BUS_ANY, &tegra194_pcie_ops},\n\n#define XGENE_V1_ECAM_MCFG(rev, seg) \\\n\t{\"APM   \", \"XGENE   \", rev, seg, MCFG_BUS_ANY, \\\n\t\t&xgene_v1_pcie_ecam_ops }\n\n#define XGENE_V2_ECAM_MCFG(rev, seg) \\\n\t{\"APM   \", \"XGENE   \", rev, seg, MCFG_BUS_ANY, \\\n\t\t&xgene_v2_pcie_ecam_ops }\n\n\t \n\tXGENE_V1_ECAM_MCFG(1, 0),\n\tXGENE_V1_ECAM_MCFG(1, 1),\n\tXGENE_V1_ECAM_MCFG(1, 2),\n\tXGENE_V1_ECAM_MCFG(1, 3),\n\tXGENE_V1_ECAM_MCFG(1, 4),\n\tXGENE_V1_ECAM_MCFG(2, 0),\n\tXGENE_V1_ECAM_MCFG(2, 1),\n\tXGENE_V1_ECAM_MCFG(2, 2),\n\tXGENE_V1_ECAM_MCFG(2, 3),\n\tXGENE_V1_ECAM_MCFG(2, 4),\n\t \n\tXGENE_V2_ECAM_MCFG(3, 0),\n\tXGENE_V2_ECAM_MCFG(3, 1),\n\t \n\tXGENE_V2_ECAM_MCFG(4, 0),\n\tXGENE_V2_ECAM_MCFG(4, 1),\n\tXGENE_V2_ECAM_MCFG(4, 2),\n\n#define ALTRA_ECAM_QUIRK(rev, seg) \\\n\t{ \"Ampere\", \"Altra   \", rev, seg, MCFG_BUS_ANY, &pci_32b_read_ops }\n\n\tALTRA_ECAM_QUIRK(1, 0),\n\tALTRA_ECAM_QUIRK(1, 1),\n\tALTRA_ECAM_QUIRK(1, 2),\n\tALTRA_ECAM_QUIRK(1, 3),\n\tALTRA_ECAM_QUIRK(1, 4),\n\tALTRA_ECAM_QUIRK(1, 5),\n\tALTRA_ECAM_QUIRK(1, 6),\n\tALTRA_ECAM_QUIRK(1, 7),\n\tALTRA_ECAM_QUIRK(1, 8),\n\tALTRA_ECAM_QUIRK(1, 9),\n\tALTRA_ECAM_QUIRK(1, 10),\n\tALTRA_ECAM_QUIRK(1, 11),\n\tALTRA_ECAM_QUIRK(1, 12),\n\tALTRA_ECAM_QUIRK(1, 13),\n\tALTRA_ECAM_QUIRK(1, 14),\n\tALTRA_ECAM_QUIRK(1, 15),\n#endif  \n\n#ifdef CONFIG_LOONGARCH\n#define LOONGSON_ECAM_MCFG(table_id, seg) \\\n\t{ \"LOONGS\", table_id, 1, seg, MCFG_BUS_ANY, &loongson_pci_ecam_ops }\n\n\tLOONGSON_ECAM_MCFG(\"\\0\", 0),\n\tLOONGSON_ECAM_MCFG(\"LOONGSON\", 0),\n\tLOONGSON_ECAM_MCFG(\"\\0\", 1),\n\tLOONGSON_ECAM_MCFG(\"LOONGSON\", 1),\n#endif  \n};\n\nstatic char mcfg_oem_id[ACPI_OEM_ID_SIZE];\nstatic char mcfg_oem_table_id[ACPI_OEM_TABLE_ID_SIZE];\nstatic u32 mcfg_oem_revision;\n\nstatic int pci_mcfg_quirk_matches(struct mcfg_fixup *f, u16 segment,\n\t\t\t\t  struct resource *bus_range)\n{\n\tif (!memcmp(f->oem_id, mcfg_oem_id, ACPI_OEM_ID_SIZE) &&\n\t    !memcmp(f->oem_table_id, mcfg_oem_table_id,\n\t\t    ACPI_OEM_TABLE_ID_SIZE) &&\n\t    f->oem_revision == mcfg_oem_revision &&\n\t    f->segment == segment &&\n\t    resource_contains(&f->bus_range, bus_range))\n\t\treturn 1;\n\n\treturn 0;\n}\n#endif\n\nstatic void pci_mcfg_apply_quirks(struct acpi_pci_root *root,\n\t\t\t\t  struct resource *cfgres,\n\t\t\t\t  const struct pci_ecam_ops **ecam_ops)\n{\n#ifdef CONFIG_PCI_QUIRKS\n\tu16 segment = root->segment;\n\tstruct resource *bus_range = &root->secondary;\n\tstruct mcfg_fixup *f;\n\tint i;\n\n\tfor (i = 0, f = mcfg_quirks; i < ARRAY_SIZE(mcfg_quirks); i++, f++) {\n\t\tif (pci_mcfg_quirk_matches(f, segment, bus_range)) {\n\t\t\tif (f->cfgres.start)\n\t\t\t\t*cfgres = f->cfgres;\n\t\t\tif (f->ops)\n\t\t\t\t*ecam_ops =  f->ops;\n\t\t\tdev_info(&root->device->dev, \"MCFG quirk: ECAM at %pR for %pR with %ps\\n\",\n\t\t\t\t cfgres, bus_range, *ecam_ops);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n}\n\n \nstatic LIST_HEAD(pci_mcfg_list);\n\nint pci_mcfg_lookup(struct acpi_pci_root *root, struct resource *cfgres,\n\t\t    const struct pci_ecam_ops **ecam_ops)\n{\n\tconst struct pci_ecam_ops *ops = &pci_generic_ecam_ops;\n\tstruct resource *bus_res = &root->secondary;\n\tu16 seg = root->segment;\n\tstruct mcfg_entry *e;\n\tstruct resource res;\n\n\t \n\tif (root->mcfg_addr)\n\t\tgoto skip_lookup;\n\n\t \n\tlist_for_each_entry(e, &pci_mcfg_list, list) {\n\t\tif (e->segment == seg && e->bus_start <= bus_res->start &&\n\t\t    e->bus_end >= bus_res->end) {\n\t\t\troot->mcfg_addr = e->addr;\n\t\t}\n\n\t}\n\nskip_lookup:\n\tmemset(&res, 0, sizeof(res));\n\tif (root->mcfg_addr) {\n\t\tres.start = root->mcfg_addr + (bus_res->start << 20);\n\t\tres.end = res.start + (resource_size(bus_res) << 20) - 1;\n\t\tres.flags = IORESOURCE_MEM;\n\t}\n\n\t \n\tpci_mcfg_apply_quirks(root, &res, &ops);\n\tif (!res.start)\n\t\treturn -ENXIO;\n\n\t*cfgres = res;\n\t*ecam_ops = ops;\n\treturn 0;\n}\n\nstatic __init int pci_mcfg_parse(struct acpi_table_header *header)\n{\n\tstruct acpi_table_mcfg *mcfg;\n\tstruct acpi_mcfg_allocation *mptr;\n\tstruct mcfg_entry *e, *arr;\n\tint i, n;\n\n\tif (header->length < sizeof(struct acpi_table_mcfg))\n\t\treturn -EINVAL;\n\n\tn = (header->length - sizeof(struct acpi_table_mcfg)) /\n\t\t\t\t\tsizeof(struct acpi_mcfg_allocation);\n\tmcfg = (struct acpi_table_mcfg *)header;\n\tmptr = (struct acpi_mcfg_allocation *) &mcfg[1];\n\n\tarr = kcalloc(n, sizeof(*arr), GFP_KERNEL);\n\tif (!arr)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, e = arr; i < n; i++, mptr++, e++) {\n\t\te->segment = mptr->pci_segment;\n\t\te->addr =  mptr->address;\n\t\te->bus_start = mptr->start_bus_number;\n\t\te->bus_end = mptr->end_bus_number;\n\t\tlist_add(&e->list, &pci_mcfg_list);\n\t}\n\n#ifdef CONFIG_PCI_QUIRKS\n\t \n\tmemcpy(mcfg_oem_id, header->oem_id, ACPI_OEM_ID_SIZE);\n\tmemcpy(mcfg_oem_table_id, header->oem_table_id, ACPI_OEM_TABLE_ID_SIZE);\n\tmcfg_oem_revision = header->oem_revision;\n#endif\n\n\tpr_info(\"MCFG table detected, %d entries\\n\", n);\n\treturn 0;\n}\n\n \nvoid __init pci_mmcfg_late_init(void)\n{\n\tint err = acpi_table_parse(ACPI_SIG_MCFG, pci_mcfg_parse);\n\tif (err)\n\t\tpr_debug(\"Failed to parse MCFG (%d)\\n\", err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}