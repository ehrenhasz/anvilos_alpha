{
  "module_name": "fan_core.c",
  "hash_id": "a0c3705b7753cd6d1990c9993cfe907f75a6942b37f764ce092d258af325a49a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/fan_core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <linux/thermal.h>\n#include <linux/acpi.h>\n#include <linux/platform_device.h>\n#include <linux/sort.h>\n\n#include \"fan.h\"\n\nstatic const struct acpi_device_id fan_device_ids[] = {\n\tACPI_FAN_DEVICE_IDS,\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, fan_device_ids);\n\n \nstatic int fan_get_max_state(struct thermal_cooling_device *cdev, unsigned long\n\t\t\t     *state)\n{\n\tstruct acpi_device *device = cdev->devdata;\n\tstruct acpi_fan *fan = acpi_driver_data(device);\n\n\tif (fan->acpi4) {\n\t\tif (fan->fif.fine_grain_ctrl)\n\t\t\t*state = 100 / fan->fif.step_size;\n\t\telse\n\t\t\t*state = fan->fps_count - 1;\n\t} else {\n\t\t*state = 1;\n\t}\n\n\treturn 0;\n}\n\nint acpi_fan_get_fst(struct acpi_device *device, struct acpi_fan_fst *fst)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tint ret = 0;\n\n\tstatus = acpi_evaluate_object(device->handle, \"_FST\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(&device->dev, \"Get fan state failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tobj = buffer.pointer;\n\tif (!obj || obj->type != ACPI_TYPE_PACKAGE ||\n\t    obj->package.count != 3 ||\n\t    obj->package.elements[1].type != ACPI_TYPE_INTEGER) {\n\t\tdev_err(&device->dev, \"Invalid _FST data\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tfst->revision = obj->package.elements[0].integer.value;\n\tfst->control = obj->package.elements[1].integer.value;\n\tfst->speed = obj->package.elements[2].integer.value;\n\nerr:\n\tkfree(obj);\n\treturn ret;\n}\n\nstatic int fan_get_state_acpi4(struct acpi_device *device, unsigned long *state)\n{\n\tstruct acpi_fan *fan = acpi_driver_data(device);\n\tstruct acpi_fan_fst fst;\n\tint status, i;\n\n\tstatus = acpi_fan_get_fst(device, &fst);\n\tif (status)\n\t\treturn status;\n\n\tif (fan->fif.fine_grain_ctrl) {\n\t\t \n\t\tif (fst.control > 100) {\n\t\t\tdev_dbg(&device->dev, \"Invalid control value returned\\n\");\n\t\t\tgoto match_fps;\n\t\t}\n\n\t\t*state = (int) fst.control / fan->fif.step_size;\n\t\treturn 0;\n\t}\n\nmatch_fps:\n\tfor (i = 0; i < fan->fps_count; i++) {\n\t\tif (fst.control == fan->fps[i].control)\n\t\t\tbreak;\n\t}\n\tif (i == fan->fps_count) {\n\t\tdev_dbg(&device->dev, \"Invalid control value returned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*state = i;\n\n\treturn status;\n}\n\nstatic int fan_get_state(struct acpi_device *device, unsigned long *state)\n{\n\tint result;\n\tint acpi_state = ACPI_STATE_D0;\n\n\tresult = acpi_device_update_power(device, &acpi_state);\n\tif (result)\n\t\treturn result;\n\n\t*state = acpi_state == ACPI_STATE_D3_COLD\n\t\t\t|| acpi_state == ACPI_STATE_D3_HOT ?\n\t\t0 : (acpi_state == ACPI_STATE_D0 ? 1 : -1);\n\treturn 0;\n}\n\nstatic int fan_get_cur_state(struct thermal_cooling_device *cdev, unsigned long\n\t\t\t     *state)\n{\n\tstruct acpi_device *device = cdev->devdata;\n\tstruct acpi_fan *fan = acpi_driver_data(device);\n\n\tif (fan->acpi4)\n\t\treturn fan_get_state_acpi4(device, state);\n\telse\n\t\treturn fan_get_state(device, state);\n}\n\nstatic int fan_set_state(struct acpi_device *device, unsigned long state)\n{\n\tif (state != 0 && state != 1)\n\t\treturn -EINVAL;\n\n\treturn acpi_device_set_power(device,\n\t\t\t\t     state ? ACPI_STATE_D0 : ACPI_STATE_D3_COLD);\n}\n\nstatic int fan_set_state_acpi4(struct acpi_device *device, unsigned long state)\n{\n\tstruct acpi_fan *fan = acpi_driver_data(device);\n\tacpi_status status;\n\tu64 value = state;\n\tint max_state;\n\n\tif (fan->fif.fine_grain_ctrl)\n\t\tmax_state = 100 / fan->fif.step_size;\n\telse\n\t\tmax_state = fan->fps_count - 1;\n\n\tif (state > max_state)\n\t\treturn -EINVAL;\n\n\tif (fan->fif.fine_grain_ctrl) {\n\t\tvalue *= fan->fif.step_size;\n\t\t \n\t\tif (value + fan->fif.step_size > 100)\n\t\t\tvalue = 100;\n\t} else {\n\t\tvalue = fan->fps[state].control;\n\t}\n\n\tstatus = acpi_execute_simple_method(device->handle, \"_FSL\", value);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_dbg(&device->dev, \"Failed to set state by _FSL\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nfan_set_cur_state(struct thermal_cooling_device *cdev, unsigned long state)\n{\n\tstruct acpi_device *device = cdev->devdata;\n\tstruct acpi_fan *fan = acpi_driver_data(device);\n\n\tif (fan->acpi4)\n\t\treturn fan_set_state_acpi4(device, state);\n\telse\n\t\treturn fan_set_state(device, state);\n}\n\nstatic const struct thermal_cooling_device_ops fan_cooling_ops = {\n\t.get_max_state = fan_get_max_state,\n\t.get_cur_state = fan_get_cur_state,\n\t.set_cur_state = fan_set_cur_state,\n};\n\n \n\nstatic bool acpi_fan_is_acpi4(struct acpi_device *device)\n{\n\treturn acpi_has_method(device->handle, \"_FIF\") &&\n\t       acpi_has_method(device->handle, \"_FPS\") &&\n\t       acpi_has_method(device->handle, \"_FSL\") &&\n\t       acpi_has_method(device->handle, \"_FST\");\n}\n\nstatic int acpi_fan_get_fif(struct acpi_device *device)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_fan *fan = acpi_driver_data(device);\n\tstruct acpi_buffer format = { sizeof(\"NNNN\"), \"NNNN\" };\n\tu64 fields[4];\n\tstruct acpi_buffer fif = { sizeof(fields), fields };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_object(device->handle, \"_FIF\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tobj = buffer.pointer;\n\tif (!obj || obj->type != ACPI_TYPE_PACKAGE) {\n\t\tdev_err(&device->dev, \"Invalid _FIF data\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tstatus = acpi_extract_package(obj, &format, &fif);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(&device->dev, \"Invalid _FIF element\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tfan->fif.revision = fields[0];\n\tfan->fif.fine_grain_ctrl = fields[1];\n\tfan->fif.step_size = fields[2];\n\tfan->fif.low_speed_notification = fields[3];\n\n\t \n\tif (!fan->fif.step_size)\n\t\tfan->fif.step_size = 1;\n\t \n\telse if (fan->fif.step_size > 9)\n\t\tfan->fif.step_size = 9;\nerr:\n\tkfree(obj);\n\treturn status;\n}\n\nstatic int acpi_fan_speed_cmp(const void *a, const void *b)\n{\n\tconst struct acpi_fan_fps *fps1 = a;\n\tconst struct acpi_fan_fps *fps2 = b;\n\treturn fps1->speed - fps2->speed;\n}\n\nstatic int acpi_fan_get_fps(struct acpi_device *device)\n{\n\tstruct acpi_fan *fan = acpi_driver_data(device);\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tint i;\n\n\tstatus = acpi_evaluate_object(device->handle, \"_FPS\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tobj = buffer.pointer;\n\tif (!obj || obj->type != ACPI_TYPE_PACKAGE || obj->package.count < 2) {\n\t\tdev_err(&device->dev, \"Invalid _FPS data\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tfan->fps_count = obj->package.count - 1;  \n\tfan->fps = devm_kcalloc(&device->dev,\n\t\t\t\tfan->fps_count, sizeof(struct acpi_fan_fps),\n\t\t\t\tGFP_KERNEL);\n\tif (!fan->fps) {\n\t\tdev_err(&device->dev, \"Not enough memory\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err;\n\t}\n\tfor (i = 0; i < fan->fps_count; i++) {\n\t\tstruct acpi_buffer format = { sizeof(\"NNNNN\"), \"NNNNN\" };\n\t\tstruct acpi_buffer fps = { offsetof(struct acpi_fan_fps, name),\n\t\t\t\t\t\t&fan->fps[i] };\n\t\tstatus = acpi_extract_package(&obj->package.elements[i + 1],\n\t\t\t\t\t      &format, &fps);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tdev_err(&device->dev, \"Invalid _FPS element\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tsort(fan->fps, fan->fps_count, sizeof(*fan->fps),\n\t     acpi_fan_speed_cmp, NULL);\n\nerr:\n\tkfree(obj);\n\treturn status;\n}\n\nstatic int acpi_fan_probe(struct platform_device *pdev)\n{\n\tint result = 0;\n\tstruct thermal_cooling_device *cdev;\n\tstruct acpi_fan *fan;\n\tstruct acpi_device *device = ACPI_COMPANION(&pdev->dev);\n\tchar *name;\n\n\tfan = devm_kzalloc(&pdev->dev, sizeof(*fan), GFP_KERNEL);\n\tif (!fan) {\n\t\tdev_err(&device->dev, \"No memory for fan\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdevice->driver_data = fan;\n\tplatform_set_drvdata(pdev, fan);\n\n\tif (acpi_fan_is_acpi4(device)) {\n\t\tresult = acpi_fan_get_fif(device);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tresult = acpi_fan_get_fps(device);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tresult = acpi_fan_create_attributes(device);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tfan->acpi4 = true;\n\t} else {\n\t\tresult = acpi_device_update_power(device, NULL);\n\t\tif (result) {\n\t\t\tdev_err(&device->dev, \"Failed to set initial power state\\n\");\n\t\t\tgoto err_end;\n\t\t}\n\t}\n\n\tif (!strncmp(pdev->name, \"PNP0C0B\", strlen(\"PNP0C0B\")))\n\t\tname = \"Fan\";\n\telse\n\t\tname = acpi_device_bid(device);\n\n\tcdev = thermal_cooling_device_register(name, device,\n\t\t\t\t\t\t&fan_cooling_ops);\n\tif (IS_ERR(cdev)) {\n\t\tresult = PTR_ERR(cdev);\n\t\tgoto err_end;\n\t}\n\n\tdev_dbg(&pdev->dev, \"registered as cooling_device%d\\n\", cdev->id);\n\n\tfan->cdev = cdev;\n\tresult = sysfs_create_link(&pdev->dev.kobj,\n\t\t\t\t   &cdev->device.kobj,\n\t\t\t\t   \"thermal_cooling\");\n\tif (result)\n\t\tdev_err(&pdev->dev, \"Failed to create sysfs link 'thermal_cooling'\\n\");\n\n\tresult = sysfs_create_link(&cdev->device.kobj,\n\t\t\t\t   &pdev->dev.kobj,\n\t\t\t\t   \"device\");\n\tif (result) {\n\t\tdev_err(&pdev->dev, \"Failed to create sysfs link 'device'\\n\");\n\t\tgoto err_end;\n\t}\n\n\treturn 0;\n\nerr_end:\n\tif (fan->acpi4)\n\t\tacpi_fan_delete_attributes(device);\n\n\treturn result;\n}\n\nstatic int acpi_fan_remove(struct platform_device *pdev)\n{\n\tstruct acpi_fan *fan = platform_get_drvdata(pdev);\n\n\tif (fan->acpi4) {\n\t\tstruct acpi_device *device = ACPI_COMPANION(&pdev->dev);\n\n\t\tacpi_fan_delete_attributes(device);\n\t}\n\tsysfs_remove_link(&pdev->dev.kobj, \"thermal_cooling\");\n\tsysfs_remove_link(&fan->cdev->device.kobj, \"device\");\n\tthermal_cooling_device_unregister(fan->cdev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acpi_fan_suspend(struct device *dev)\n{\n\tstruct acpi_fan *fan = dev_get_drvdata(dev);\n\tif (fan->acpi4)\n\t\treturn 0;\n\n\tacpi_device_set_power(ACPI_COMPANION(dev), ACPI_STATE_D0);\n\n\treturn AE_OK;\n}\n\nstatic int acpi_fan_resume(struct device *dev)\n{\n\tint result;\n\tstruct acpi_fan *fan = dev_get_drvdata(dev);\n\n\tif (fan->acpi4)\n\t\treturn 0;\n\n\tresult = acpi_device_update_power(ACPI_COMPANION(dev), NULL);\n\tif (result)\n\t\tdev_err(dev, \"Error updating fan power state\\n\");\n\n\treturn result;\n}\n\nstatic const struct dev_pm_ops acpi_fan_pm = {\n\t.resume = acpi_fan_resume,\n\t.freeze = acpi_fan_suspend,\n\t.thaw = acpi_fan_resume,\n\t.restore = acpi_fan_resume,\n};\n#define FAN_PM_OPS_PTR (&acpi_fan_pm)\n\n#else\n\n#define FAN_PM_OPS_PTR NULL\n\n#endif\n\nstatic struct platform_driver acpi_fan_driver = {\n\t.probe = acpi_fan_probe,\n\t.remove = acpi_fan_remove,\n\t.driver = {\n\t\t.name = \"acpi-fan\",\n\t\t.acpi_match_table = fan_device_ids,\n\t\t.pm = FAN_PM_OPS_PTR,\n\t},\n};\n\nmodule_platform_driver(acpi_fan_driver);\n\nMODULE_AUTHOR(\"Paul Diefenbaugh\");\nMODULE_DESCRIPTION(\"ACPI Fan Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}