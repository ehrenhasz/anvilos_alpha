{
  "module_name": "pci_slot.c",
  "hash_id": "9487ff3dba2d4679b769358ca3c1d02d5266da022844275d850b6965df7ff1a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pci_slot.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/pci-acpi.h>\n\nstatic int check_sta_before_sun;\n\n#define SLOT_NAME_SIZE 21\t\t \n\nstruct acpi_pci_slot {\n\tstruct pci_slot *pci_slot;\t \n\tstruct list_head list;\t\t \n};\n\nstatic LIST_HEAD(slot_list);\nstatic DEFINE_MUTEX(slot_list_lock);\n\nstatic int\ncheck_slot(acpi_handle handle, unsigned long long *sun)\n{\n\tint device = -1;\n\tunsigned long long adr, sta;\n\tacpi_status status;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tacpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);\n\tpr_debug(\"Checking slot on path: %s\\n\", (char *)buffer.pointer);\n\n\tif (check_sta_before_sun) {\n\t\t \n\t\tstatus = acpi_evaluate_integer(handle, \"_STA\", NULL, &sta);\n\t\tif (ACPI_SUCCESS(status) && !(sta & ACPI_STA_DEVICE_PRESENT))\n\t\t\tgoto out;\n\t}\n\n\tstatus = acpi_evaluate_integer(handle, \"_ADR\", NULL, &adr);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_debug(\"_ADR returned %d on %s\\n\",\n\t\t\t status, (char *)buffer.pointer);\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = acpi_evaluate_integer(handle, \"_SUN\", NULL, sun);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_debug(\"_SUN returned %d on %s\\n\",\n\t\t\t status, (char *)buffer.pointer);\n\t\tgoto out;\n\t}\n\n\tdevice = (adr >> 16) & 0xffff;\nout:\n\tkfree(buffer.pointer);\n\treturn device;\n}\n\n \nstatic acpi_status\nregister_slot(acpi_handle handle, u32 lvl, void *context, void **rv)\n{\n\tint device;\n\tunsigned long long sun;\n\tchar name[SLOT_NAME_SIZE];\n\tstruct acpi_pci_slot *slot;\n\tstruct pci_slot *pci_slot;\n\tstruct pci_bus *pci_bus = context;\n\n\tdevice = check_slot(handle, &sun);\n\tif (device < 0)\n\t\treturn AE_OK;\n\n\t \n\tlist_for_each_entry(slot, &slot_list, list) {\n\t\tpci_slot = slot->pci_slot;\n\t\tif (pci_slot->bus == pci_bus && pci_slot->number == device)\n\t\t\treturn AE_OK;\n\t}\n\n\tslot = kmalloc(sizeof(*slot), GFP_KERNEL);\n\tif (!slot)\n\t\treturn AE_OK;\n\n\tsnprintf(name, sizeof(name), \"%llu\", sun);\n\tpci_slot = pci_create_slot(pci_bus, device, name, NULL);\n\tif (IS_ERR(pci_slot)) {\n\t\tpr_err(\"pci_create_slot returned %ld\\n\", PTR_ERR(pci_slot));\n\t\tkfree(slot);\n\t\treturn AE_OK;\n\t}\n\n\tslot->pci_slot = pci_slot;\n\tlist_add(&slot->list, &slot_list);\n\n\tget_device(&pci_bus->dev);\n\n\tpr_debug(\"%p, pci_bus: %x, device: %d, name: %s\\n\",\n\t\t pci_slot, pci_bus->number, device, name);\n\n\treturn AE_OK;\n}\n\nvoid acpi_pci_slot_enumerate(struct pci_bus *bus)\n{\n\tacpi_handle handle = ACPI_HANDLE(bus->bridge);\n\n\tif (handle) {\n\t\tmutex_lock(&slot_list_lock);\n\t\tacpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,\n\t\t\t\t    register_slot, NULL, bus, NULL);\n\t\tmutex_unlock(&slot_list_lock);\n\t}\n}\n\nvoid acpi_pci_slot_remove(struct pci_bus *bus)\n{\n\tstruct acpi_pci_slot *slot, *tmp;\n\n\tmutex_lock(&slot_list_lock);\n\tlist_for_each_entry_safe(slot, tmp, &slot_list, list) {\n\t\tif (slot->pci_slot->bus == bus) {\n\t\t\tlist_del(&slot->list);\n\t\t\tpci_destroy_slot(slot->pci_slot);\n\t\t\tput_device(&bus->dev);\n\t\t\tkfree(slot);\n\t\t}\n\t}\n\tmutex_unlock(&slot_list_lock);\n}\n\nstatic int do_sta_before_sun(const struct dmi_system_id *d)\n{\n\tpr_info(\"%s detected: will evaluate _STA before calling _SUN\\n\",\n\t\td->ident);\n\tcheck_sta_before_sun = 1;\n\treturn 0;\n}\n\nstatic const struct dmi_system_id acpi_pci_slot_dmi_table[] __initconst = {\n\t \n\t{\n\t .callback = do_sta_before_sun,\n\t .ident = \"Fujitsu PRIMEQUEST\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"FUJITSU LIMITED\"),\n\t\tDMI_MATCH(DMI_BIOS_VERSION, \"PRIMEQUEST\"),\n\t\t},\n\t},\n\t{}\n};\n\nvoid __init acpi_pci_slot_init(void)\n{\n\tdmi_check_system(acpi_pci_slot_dmi_table);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}