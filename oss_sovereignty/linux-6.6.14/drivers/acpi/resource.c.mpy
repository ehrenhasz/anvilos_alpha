{
  "module_name": "resource.c",
  "hash_id": "a8eee54d6e5e2e2be83f1efed7711ec1e9dd7e0a70fde9d49167bfe62c2269c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/resource.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/dmi.h>\n\n#ifdef CONFIG_X86\n#define valid_IRQ(i) (((i) != 0) && ((i) != 2))\nstatic inline bool acpi_iospace_resource_valid(struct resource *res)\n{\n\t \n\treturn res->end < 0x10003;\n}\n#else\n#define valid_IRQ(i) (true)\n \nstatic inline bool\nacpi_iospace_resource_valid(struct resource *res) { return true; }\n#endif\n\n#if IS_ENABLED(CONFIG_ACPI_GENERIC_GSI)\nstatic inline bool is_gsi(struct acpi_resource_extended_irq *ext_irq)\n{\n\treturn ext_irq->resource_source.string_length == 0 &&\n\t       ext_irq->producer_consumer == ACPI_CONSUMER;\n}\n#else\nstatic inline bool is_gsi(struct acpi_resource_extended_irq *ext_irq)\n{\n\treturn true;\n}\n#endif\n\nstatic bool acpi_dev_resource_len_valid(u64 start, u64 end, u64 len, bool io)\n{\n\tu64 reslen = end - start + 1;\n\n\t \n\tif (len && reslen && start <= end)\n\t\treturn true;\n\n\tpr_debug(\"ACPI: invalid or unassigned resource %s [%016llx - %016llx] length [%016llx]\\n\",\n\t\tio ? \"io\" : \"mem\", start, end, len);\n\n\treturn false;\n}\n\nstatic void acpi_dev_memresource_flags(struct resource *res, u64 len,\n\t\t\t\t       u8 write_protect)\n{\n\tres->flags = IORESOURCE_MEM;\n\n\tif (!acpi_dev_resource_len_valid(res->start, res->end, len, false))\n\t\tres->flags |= IORESOURCE_DISABLED | IORESOURCE_UNSET;\n\n\tif (write_protect == ACPI_READ_WRITE_MEMORY)\n\t\tres->flags |= IORESOURCE_MEM_WRITEABLE;\n}\n\nstatic void acpi_dev_get_memresource(struct resource *res, u64 start, u64 len,\n\t\t\t\t     u8 write_protect)\n{\n\tres->start = start;\n\tres->end = start + len - 1;\n\tacpi_dev_memresource_flags(res, len, write_protect);\n}\n\n \nbool acpi_dev_resource_memory(struct acpi_resource *ares, struct resource *res)\n{\n\tstruct acpi_resource_memory24 *memory24;\n\tstruct acpi_resource_memory32 *memory32;\n\tstruct acpi_resource_fixed_memory32 *fixed_memory32;\n\n\tswitch (ares->type) {\n\tcase ACPI_RESOURCE_TYPE_MEMORY24:\n\t\tmemory24 = &ares->data.memory24;\n\t\tacpi_dev_get_memresource(res, memory24->minimum << 8,\n\t\t\t\t\t memory24->address_length << 8,\n\t\t\t\t\t memory24->write_protect);\n\t\tbreak;\n\tcase ACPI_RESOURCE_TYPE_MEMORY32:\n\t\tmemory32 = &ares->data.memory32;\n\t\tacpi_dev_get_memresource(res, memory32->minimum,\n\t\t\t\t\t memory32->address_length,\n\t\t\t\t\t memory32->write_protect);\n\t\tbreak;\n\tcase ACPI_RESOURCE_TYPE_FIXED_MEMORY32:\n\t\tfixed_memory32 = &ares->data.fixed_memory32;\n\t\tacpi_dev_get_memresource(res, fixed_memory32->address,\n\t\t\t\t\t fixed_memory32->address_length,\n\t\t\t\t\t fixed_memory32->write_protect);\n\t\tbreak;\n\tdefault:\n\t\tres->flags = 0;\n\t\treturn false;\n\t}\n\n\treturn !(res->flags & IORESOURCE_DISABLED);\n}\nEXPORT_SYMBOL_GPL(acpi_dev_resource_memory);\n\nstatic void acpi_dev_ioresource_flags(struct resource *res, u64 len,\n\t\t\t\t      u8 io_decode, u8 translation_type)\n{\n\tres->flags = IORESOURCE_IO;\n\n\tif (!acpi_dev_resource_len_valid(res->start, res->end, len, true))\n\t\tres->flags |= IORESOURCE_DISABLED | IORESOURCE_UNSET;\n\n\tif (!acpi_iospace_resource_valid(res))\n\t\tres->flags |= IORESOURCE_DISABLED | IORESOURCE_UNSET;\n\n\tif (io_decode == ACPI_DECODE_16)\n\t\tres->flags |= IORESOURCE_IO_16BIT_ADDR;\n\tif (translation_type == ACPI_SPARSE_TRANSLATION)\n\t\tres->flags |= IORESOURCE_IO_SPARSE;\n}\n\nstatic void acpi_dev_get_ioresource(struct resource *res, u64 start, u64 len,\n\t\t\t\t    u8 io_decode)\n{\n\tres->start = start;\n\tres->end = start + len - 1;\n\tacpi_dev_ioresource_flags(res, len, io_decode, 0);\n}\n\n \nbool acpi_dev_resource_io(struct acpi_resource *ares, struct resource *res)\n{\n\tstruct acpi_resource_io *io;\n\tstruct acpi_resource_fixed_io *fixed_io;\n\n\tswitch (ares->type) {\n\tcase ACPI_RESOURCE_TYPE_IO:\n\t\tio = &ares->data.io;\n\t\tacpi_dev_get_ioresource(res, io->minimum,\n\t\t\t\t\tio->address_length,\n\t\t\t\t\tio->io_decode);\n\t\tbreak;\n\tcase ACPI_RESOURCE_TYPE_FIXED_IO:\n\t\tfixed_io = &ares->data.fixed_io;\n\t\tacpi_dev_get_ioresource(res, fixed_io->address,\n\t\t\t\t\tfixed_io->address_length,\n\t\t\t\t\tACPI_DECODE_10);\n\t\tbreak;\n\tdefault:\n\t\tres->flags = 0;\n\t\treturn false;\n\t}\n\n\treturn !(res->flags & IORESOURCE_DISABLED);\n}\nEXPORT_SYMBOL_GPL(acpi_dev_resource_io);\n\nstatic bool acpi_decode_space(struct resource_win *win,\n\t\t\t      struct acpi_resource_address *addr,\n\t\t\t      struct acpi_address64_attribute *attr)\n{\n\tu8 iodec = attr->granularity == 0xfff ? ACPI_DECODE_10 : ACPI_DECODE_16;\n\tbool wp = addr->info.mem.write_protect;\n\tu64 len = attr->address_length;\n\tu64 start, end, offset = 0;\n\tstruct resource *res = &win->res;\n\n\t \n\tif ((addr->min_address_fixed != addr->max_address_fixed && len) ||\n\t    (addr->min_address_fixed && addr->max_address_fixed && !len))\n\t\tpr_debug(\"ACPI: Invalid address space min_addr_fix %d, max_addr_fix %d, len %llx\\n\",\n\t\t\t addr->min_address_fixed, addr->max_address_fixed, len);\n\n\t \n\tif (addr->producer_consumer == ACPI_PRODUCER)\n\t\toffset = attr->translation_offset;\n\telse if (attr->translation_offset)\n\t\tpr_debug(\"ACPI: translation_offset(%lld) is invalid for non-bridge device.\\n\",\n\t\t\t attr->translation_offset);\n\tstart = attr->minimum + offset;\n\tend = attr->maximum + offset;\n\n\twin->offset = offset;\n\tres->start = start;\n\tres->end = end;\n\tif (sizeof(resource_size_t) < sizeof(u64) &&\n\t    (offset != win->offset || start != res->start || end != res->end)) {\n\t\tpr_warn(\"acpi resource window ([%#llx-%#llx] ignored, not CPU addressable)\\n\",\n\t\t\tattr->minimum, attr->maximum);\n\t\treturn false;\n\t}\n\n\tswitch (addr->resource_type) {\n\tcase ACPI_MEMORY_RANGE:\n\t\tacpi_dev_memresource_flags(res, len, wp);\n\t\tbreak;\n\tcase ACPI_IO_RANGE:\n\t\tacpi_dev_ioresource_flags(res, len, iodec,\n\t\t\t\t\t  addr->info.io.translation_type);\n\t\tbreak;\n\tcase ACPI_BUS_NUMBER_RANGE:\n\t\tres->flags = IORESOURCE_BUS;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (addr->producer_consumer == ACPI_PRODUCER)\n\t\tres->flags |= IORESOURCE_WINDOW;\n\n\tif (addr->info.mem.caching == ACPI_PREFETCHABLE_MEMORY)\n\t\tres->flags |= IORESOURCE_PREFETCH;\n\n\treturn !(res->flags & IORESOURCE_DISABLED);\n}\n\n \nbool acpi_dev_resource_address_space(struct acpi_resource *ares,\n\t\t\t\t     struct resource_win *win)\n{\n\tstruct acpi_resource_address64 addr;\n\n\twin->res.flags = 0;\n\tif (ACPI_FAILURE(acpi_resource_to_address64(ares, &addr)))\n\t\treturn false;\n\n\treturn acpi_decode_space(win, (struct acpi_resource_address *)&addr,\n\t\t\t\t &addr.address);\n}\nEXPORT_SYMBOL_GPL(acpi_dev_resource_address_space);\n\n \nbool acpi_dev_resource_ext_address_space(struct acpi_resource *ares,\n\t\t\t\t\t struct resource_win *win)\n{\n\tstruct acpi_resource_extended_address64 *ext_addr;\n\n\twin->res.flags = 0;\n\tif (ares->type != ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64)\n\t\treturn false;\n\n\text_addr = &ares->data.ext_address64;\n\n\treturn acpi_decode_space(win, (struct acpi_resource_address *)ext_addr,\n\t\t\t\t &ext_addr->address);\n}\nEXPORT_SYMBOL_GPL(acpi_dev_resource_ext_address_space);\n\n \nunsigned long acpi_dev_irq_flags(u8 triggering, u8 polarity, u8 shareable, u8 wake_capable)\n{\n\tunsigned long flags;\n\n\tif (triggering == ACPI_LEVEL_SENSITIVE)\n\t\tflags = polarity == ACPI_ACTIVE_LOW ?\n\t\t\tIORESOURCE_IRQ_LOWLEVEL : IORESOURCE_IRQ_HIGHLEVEL;\n\telse\n\t\tflags = polarity == ACPI_ACTIVE_LOW ?\n\t\t\tIORESOURCE_IRQ_LOWEDGE : IORESOURCE_IRQ_HIGHEDGE;\n\n\tif (shareable == ACPI_SHARED)\n\t\tflags |= IORESOURCE_IRQ_SHAREABLE;\n\n\tif (wake_capable == ACPI_WAKE_CAPABLE)\n\t\tflags |= IORESOURCE_IRQ_WAKECAPABLE;\n\n\treturn flags | IORESOURCE_IRQ;\n}\nEXPORT_SYMBOL_GPL(acpi_dev_irq_flags);\n\n \nunsigned int acpi_dev_get_irq_type(int triggering, int polarity)\n{\n\tswitch (polarity) {\n\tcase ACPI_ACTIVE_LOW:\n\t\treturn triggering == ACPI_EDGE_SENSITIVE ?\n\t\t       IRQ_TYPE_EDGE_FALLING :\n\t\t       IRQ_TYPE_LEVEL_LOW;\n\tcase ACPI_ACTIVE_HIGH:\n\t\treturn triggering == ACPI_EDGE_SENSITIVE ?\n\t\t       IRQ_TYPE_EDGE_RISING :\n\t\t       IRQ_TYPE_LEVEL_HIGH;\n\tcase ACPI_ACTIVE_BOTH:\n\t\tif (triggering == ACPI_EDGE_SENSITIVE)\n\t\t\treturn IRQ_TYPE_EDGE_BOTH;\n\t\tfallthrough;\n\tdefault:\n\t\treturn IRQ_TYPE_NONE;\n\t}\n}\nEXPORT_SYMBOL_GPL(acpi_dev_get_irq_type);\n\nstatic const struct dmi_system_id medion_laptop[] = {\n\t{\n\t\t.ident = \"MEDION P15651\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MEDION\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"M15T\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"MEDION S17405\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MEDION\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"M17T\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"MEDION S17413\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MEDION\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"M1xA\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic const struct dmi_system_id asus_laptop[] = {\n\t{\n\t\t.ident = \"Asus Vivobook K3402ZA\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"K3402ZA\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Asus Vivobook K3502ZA\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"K3502ZA\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Asus Vivobook S5402ZA\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"S5402ZA\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Asus Vivobook S5602ZA\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"S5602ZA\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Asus ExpertBook B1402CBA\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"B1402CBA\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"B1402CVA\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Asus ExpertBook B1502CBA\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"B1502CBA\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Asus ExpertBook B2402CBA\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"B2402CBA\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Asus ExpertBook B2402FBA\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"B2402FBA\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Asus ExpertBook B2502\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"B2502CBA\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic const struct dmi_system_id tongfang_gm_rg[] = {\n\t{\n\t\t.ident = \"TongFang GMxRGxx/XMG CORE 15 (M22)/TUXEDO Stellaris 15 Gen4 AMD\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"GMxRGxx\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic const struct dmi_system_id maingear_laptop[] = {\n\t{\n\t\t.ident = \"MAINGEAR Vector Pro 2 15\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Micro Electronics Inc\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MG-VCP2-15A3070T\"),\n\t\t}\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"GMxXGxx\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Eluktronics Inc.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"RP-15\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"GM6XGxX\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"MAINGEAR Vector Pro 2 17\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Micro Electronics Inc\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MG-VCP2-17A3070T\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic const struct dmi_system_id pcspecialist_laptop[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"GM6BGEQ\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"GM6BG5Q\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"GM6BG0Q\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic const struct dmi_system_id lg_laptop[] = {\n\t{\n\t\t.ident = \"LG Electronics 17U70P\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LG Electronics\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"17U70P\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstruct irq_override_cmp {\n\tconst struct dmi_system_id *system;\n\tunsigned char irq;\n\tunsigned char triggering;\n\tunsigned char polarity;\n\tunsigned char shareable;\n\tbool override;\n};\n\nstatic const struct irq_override_cmp override_table[] = {\n\t{ medion_laptop, 1, ACPI_LEVEL_SENSITIVE, ACPI_ACTIVE_LOW, 0, false },\n\t{ asus_laptop, 1, ACPI_LEVEL_SENSITIVE, ACPI_ACTIVE_LOW, 0, false },\n\t{ tongfang_gm_rg, 1, ACPI_EDGE_SENSITIVE, ACPI_ACTIVE_LOW, 1, true },\n\t{ maingear_laptop, 1, ACPI_EDGE_SENSITIVE, ACPI_ACTIVE_LOW, 1, true },\n\t{ pcspecialist_laptop, 1, ACPI_EDGE_SENSITIVE, ACPI_ACTIVE_LOW, 1, true },\n\t{ lg_laptop, 1, ACPI_LEVEL_SENSITIVE, ACPI_ACTIVE_LOW, 0, false },\n};\n\nstatic bool acpi_dev_irq_override(u32 gsi, u8 triggering, u8 polarity,\n\t\t\t\t  u8 shareable)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(override_table); i++) {\n\t\tconst struct irq_override_cmp *entry = &override_table[i];\n\n\t\tif (dmi_check_system(entry->system) &&\n\t\t    entry->irq == gsi &&\n\t\t    entry->triggering == triggering &&\n\t\t    entry->polarity == polarity &&\n\t\t    entry->shareable == shareable)\n\t\t\treturn entry->override;\n\t}\n\n#ifdef CONFIG_X86\n\t \n\tif (gsi != 1 && gsi != 12)\n\t\treturn true;\n\n\t \n\tif (acpi_int_src_ovr[gsi])\n\t\treturn true;\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_ZEN))\n\t\treturn false;\n#endif\n\n\treturn true;\n}\n\nstatic void acpi_dev_get_irqresource(struct resource *res, u32 gsi,\n\t\t\t\t     u8 triggering, u8 polarity, u8 shareable,\n\t\t\t\t     u8 wake_capable, bool check_override)\n{\n\tint irq, p, t;\n\n\tif (!valid_IRQ(gsi)) {\n\t\tirqresource_disabled(res, gsi);\n\t\treturn;\n\t}\n\n\t \n\tif (check_override &&\n\t    acpi_dev_irq_override(gsi, triggering, polarity, shareable) &&\n\t    !acpi_get_override_irq(gsi, &t, &p)) {\n\t\tu8 trig = t ? ACPI_LEVEL_SENSITIVE : ACPI_EDGE_SENSITIVE;\n\t\tu8 pol = p ? ACPI_ACTIVE_LOW : ACPI_ACTIVE_HIGH;\n\n\t\tif (triggering != trig || polarity != pol) {\n\t\t\tpr_warn(\"ACPI: IRQ %d override to %s%s, %s%s\\n\", gsi,\n\t\t\t\tt ? \"level\" : \"edge\",\n\t\t\t\ttrig == triggering ? \"\" : \"(!)\",\n\t\t\t\tp ? \"low\" : \"high\",\n\t\t\t\tpol == polarity ? \"\" : \"(!)\");\n\t\t\ttriggering = trig;\n\t\t\tpolarity = pol;\n\t\t}\n\t}\n\n\tres->flags = acpi_dev_irq_flags(triggering, polarity, shareable, wake_capable);\n\tirq = acpi_register_gsi(NULL, gsi, triggering, polarity);\n\tif (irq >= 0) {\n\t\tres->start = irq;\n\t\tres->end = irq;\n\t} else {\n\t\tirqresource_disabled(res, gsi);\n\t}\n}\n\n \nbool acpi_dev_resource_interrupt(struct acpi_resource *ares, int index,\n\t\t\t\t struct resource *res)\n{\n\tstruct acpi_resource_irq *irq;\n\tstruct acpi_resource_extended_irq *ext_irq;\n\n\tswitch (ares->type) {\n\tcase ACPI_RESOURCE_TYPE_IRQ:\n\t\t \n\t\tirq = &ares->data.irq;\n\t\tif (index >= irq->interrupt_count) {\n\t\t\tirqresource_disabled(res, 0);\n\t\t\treturn false;\n\t\t}\n\t\tacpi_dev_get_irqresource(res, irq->interrupts[index],\n\t\t\t\t\t irq->triggering, irq->polarity,\n\t\t\t\t\t irq->shareable, irq->wake_capable,\n\t\t\t\t\t true);\n\t\tbreak;\n\tcase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\n\t\text_irq = &ares->data.extended_irq;\n\t\tif (index >= ext_irq->interrupt_count) {\n\t\t\tirqresource_disabled(res, 0);\n\t\t\treturn false;\n\t\t}\n\t\tif (is_gsi(ext_irq))\n\t\t\tacpi_dev_get_irqresource(res, ext_irq->interrupts[index],\n\t\t\t\t\t ext_irq->triggering, ext_irq->polarity,\n\t\t\t\t\t ext_irq->shareable, ext_irq->wake_capable,\n\t\t\t\t\t false);\n\t\telse\n\t\t\tirqresource_disabled(res, 0);\n\t\tbreak;\n\tdefault:\n\t\tres->flags = 0;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(acpi_dev_resource_interrupt);\n\n \nvoid acpi_dev_free_resource_list(struct list_head *list)\n{\n\tresource_list_free(list);\n}\nEXPORT_SYMBOL_GPL(acpi_dev_free_resource_list);\n\nstruct res_proc_context {\n\tstruct list_head *list;\n\tint (*preproc)(struct acpi_resource *, void *);\n\tvoid *preproc_data;\n\tint count;\n\tint error;\n};\n\nstatic acpi_status acpi_dev_new_resource_entry(struct resource_win *win,\n\t\t\t\t\t       struct res_proc_context *c)\n{\n\tstruct resource_entry *rentry;\n\n\trentry = resource_list_create_entry(NULL, 0);\n\tif (!rentry) {\n\t\tc->error = -ENOMEM;\n\t\treturn AE_NO_MEMORY;\n\t}\n\t*rentry->res = win->res;\n\trentry->offset = win->offset;\n\tresource_list_add_tail(rentry, c->list);\n\tc->count++;\n\treturn AE_OK;\n}\n\nstatic acpi_status acpi_dev_process_resource(struct acpi_resource *ares,\n\t\t\t\t\t     void *context)\n{\n\tstruct res_proc_context *c = context;\n\tstruct resource_win win;\n\tstruct resource *res = &win.res;\n\tint i;\n\n\tif (c->preproc) {\n\t\tint ret;\n\n\t\tret = c->preproc(ares, c->preproc_data);\n\t\tif (ret < 0) {\n\t\t\tc->error = ret;\n\t\t\treturn AE_ABORT_METHOD;\n\t\t} else if (ret > 0) {\n\t\t\treturn AE_OK;\n\t\t}\n\t}\n\n\tmemset(&win, 0, sizeof(win));\n\n\tif (acpi_dev_resource_memory(ares, res)\n\t    || acpi_dev_resource_io(ares, res)\n\t    || acpi_dev_resource_address_space(ares, &win)\n\t    || acpi_dev_resource_ext_address_space(ares, &win))\n\t\treturn acpi_dev_new_resource_entry(&win, c);\n\n\tfor (i = 0; acpi_dev_resource_interrupt(ares, i, res); i++) {\n\t\tacpi_status status;\n\n\t\tstatus = acpi_dev_new_resource_entry(&win, c);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn status;\n\t}\n\n\treturn AE_OK;\n}\n\nstatic int __acpi_dev_get_resources(struct acpi_device *adev,\n\t\t\t\t    struct list_head *list,\n\t\t\t\t    int (*preproc)(struct acpi_resource *, void *),\n\t\t\t\t    void *preproc_data, char *method)\n{\n\tstruct res_proc_context c;\n\tacpi_status status;\n\n\tif (!adev || !adev->handle || !list_empty(list))\n\t\treturn -EINVAL;\n\n\tif (!acpi_has_method(adev->handle, method))\n\t\treturn 0;\n\n\tc.list = list;\n\tc.preproc = preproc;\n\tc.preproc_data = preproc_data;\n\tc.count = 0;\n\tc.error = 0;\n\tstatus = acpi_walk_resources(adev->handle, method,\n\t\t\t\t     acpi_dev_process_resource, &c);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_dev_free_resource_list(list);\n\t\treturn c.error ? c.error : -EIO;\n\t}\n\n\treturn c.count;\n}\n\n \nint acpi_dev_get_resources(struct acpi_device *adev, struct list_head *list,\n\t\t\t   int (*preproc)(struct acpi_resource *, void *),\n\t\t\t   void *preproc_data)\n{\n\treturn __acpi_dev_get_resources(adev, list, preproc, preproc_data,\n\t\t\t\t\tMETHOD_NAME__CRS);\n}\nEXPORT_SYMBOL_GPL(acpi_dev_get_resources);\n\nstatic int is_memory(struct acpi_resource *ares, void *not_used)\n{\n\tstruct resource_win win;\n\tstruct resource *res = &win.res;\n\n\tmemset(&win, 0, sizeof(win));\n\n\tif (acpi_dev_filter_resource_type(ares, IORESOURCE_MEM))\n\t\treturn 1;\n\n\treturn !(acpi_dev_resource_memory(ares, res)\n\t       || acpi_dev_resource_address_space(ares, &win)\n\t       || acpi_dev_resource_ext_address_space(ares, &win));\n}\n\n \nint acpi_dev_get_dma_resources(struct acpi_device *adev, struct list_head *list)\n{\n\treturn __acpi_dev_get_resources(adev, list, is_memory, NULL,\n\t\t\t\t\tMETHOD_NAME__DMA);\n}\nEXPORT_SYMBOL_GPL(acpi_dev_get_dma_resources);\n\n \nint acpi_dev_get_memory_resources(struct acpi_device *adev, struct list_head *list)\n{\n\treturn acpi_dev_get_resources(adev, list, is_memory, NULL);\n}\nEXPORT_SYMBOL_GPL(acpi_dev_get_memory_resources);\n\n \nint acpi_dev_filter_resource_type(struct acpi_resource *ares,\n\t\t\t\t  unsigned long types)\n{\n\tunsigned long type = 0;\n\n\tswitch (ares->type) {\n\tcase ACPI_RESOURCE_TYPE_MEMORY24:\n\tcase ACPI_RESOURCE_TYPE_MEMORY32:\n\tcase ACPI_RESOURCE_TYPE_FIXED_MEMORY32:\n\t\ttype = IORESOURCE_MEM;\n\t\tbreak;\n\tcase ACPI_RESOURCE_TYPE_IO:\n\tcase ACPI_RESOURCE_TYPE_FIXED_IO:\n\t\ttype = IORESOURCE_IO;\n\t\tbreak;\n\tcase ACPI_RESOURCE_TYPE_IRQ:\n\tcase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\n\t\ttype = IORESOURCE_IRQ;\n\t\tbreak;\n\tcase ACPI_RESOURCE_TYPE_DMA:\n\tcase ACPI_RESOURCE_TYPE_FIXED_DMA:\n\t\ttype = IORESOURCE_DMA;\n\t\tbreak;\n\tcase ACPI_RESOURCE_TYPE_GENERIC_REGISTER:\n\t\ttype = IORESOURCE_REG;\n\t\tbreak;\n\tcase ACPI_RESOURCE_TYPE_ADDRESS16:\n\tcase ACPI_RESOURCE_TYPE_ADDRESS32:\n\tcase ACPI_RESOURCE_TYPE_ADDRESS64:\n\tcase ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64:\n\t\tif (ares->data.address.resource_type == ACPI_MEMORY_RANGE)\n\t\t\ttype = IORESOURCE_MEM;\n\t\telse if (ares->data.address.resource_type == ACPI_IO_RANGE)\n\t\t\ttype = IORESOURCE_IO;\n\t\telse if (ares->data.address.resource_type ==\n\t\t\t ACPI_BUS_NUMBER_RANGE)\n\t\t\ttype = IORESOURCE_BUS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (type & types) ? 0 : 1;\n}\nEXPORT_SYMBOL_GPL(acpi_dev_filter_resource_type);\n\nstatic int acpi_dev_consumes_res(struct acpi_device *adev, struct resource *res)\n{\n\tstruct list_head resource_list;\n\tstruct resource_entry *rentry;\n\tint ret, found = 0;\n\n\tINIT_LIST_HEAD(&resource_list);\n\tret = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tlist_for_each_entry(rentry, &resource_list, node) {\n\t\tif (resource_contains(rentry->res, res)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tacpi_dev_free_resource_list(&resource_list);\n\treturn found;\n}\n\nstatic acpi_status acpi_res_consumer_cb(acpi_handle handle, u32 depth,\n\t\t\t\t\t void *context, void **ret)\n{\n\tstruct resource *res = context;\n\tstruct acpi_device **consumer = (struct acpi_device **) ret;\n\tstruct acpi_device *adev = acpi_fetch_acpi_dev(handle);\n\n\tif (!adev)\n\t\treturn AE_OK;\n\n\tif (acpi_dev_consumes_res(adev, res)) {\n\t\t*consumer = adev;\n\t\treturn AE_CTRL_TERMINATE;\n\t}\n\n\treturn AE_OK;\n}\n\n \nstruct acpi_device *acpi_resource_consumer(struct resource *res)\n{\n\tstruct acpi_device *consumer = NULL;\n\n\tacpi_get_devices(NULL, acpi_res_consumer_cb, res, (void **) &consumer);\n\treturn consumer;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}