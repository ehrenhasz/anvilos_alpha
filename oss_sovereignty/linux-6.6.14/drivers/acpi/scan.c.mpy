{
  "module_name": "scan.c",
  "hash_id": "221a5a238cb9067886c3eb40404e9d196f2fef1b2ceacc83c61e19f0a6c3fd93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/scan.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/acpi.h>\n#include <linux/acpi_iort.h>\n#include <linux/acpi_viot.h>\n#include <linux/iommu.h>\n#include <linux/signal.h>\n#include <linux/kthread.h>\n#include <linux/dmi.h>\n#include <linux/dma-map-ops.h>\n#include <linux/platform_data/x86/apple.h>\n#include <linux/pgtable.h>\n#include <linux/crc32.h>\n#include <linux/dma-direct.h>\n\n#include \"internal.h\"\n#include \"sleep.h\"\n\n#define ACPI_BUS_CLASS\t\t\t\"system_bus\"\n#define ACPI_BUS_HID\t\t\t\"LNXSYBUS\"\n#define ACPI_BUS_DEVICE_NAME\t\t\"System Bus\"\n\n#define INVALID_ACPI_HANDLE\t((acpi_handle)ZERO_PAGE(0))\n\nstatic const char *dummy_hid = \"device\";\n\nstatic LIST_HEAD(acpi_dep_list);\nstatic DEFINE_MUTEX(acpi_dep_list_lock);\nLIST_HEAD(acpi_bus_id_list);\nstatic DEFINE_MUTEX(acpi_scan_lock);\nstatic LIST_HEAD(acpi_scan_handlers_list);\nDEFINE_MUTEX(acpi_device_lock);\nLIST_HEAD(acpi_wakeup_device_list);\nstatic DEFINE_MUTEX(acpi_hp_context_lock);\n\n \nstatic u64 spcr_uart_addr;\n\nvoid acpi_scan_lock_acquire(void)\n{\n\tmutex_lock(&acpi_scan_lock);\n}\nEXPORT_SYMBOL_GPL(acpi_scan_lock_acquire);\n\nvoid acpi_scan_lock_release(void)\n{\n\tmutex_unlock(&acpi_scan_lock);\n}\nEXPORT_SYMBOL_GPL(acpi_scan_lock_release);\n\nvoid acpi_lock_hp_context(void)\n{\n\tmutex_lock(&acpi_hp_context_lock);\n}\n\nvoid acpi_unlock_hp_context(void)\n{\n\tmutex_unlock(&acpi_hp_context_lock);\n}\n\nvoid acpi_initialize_hp_context(struct acpi_device *adev,\n\t\t\t\tstruct acpi_hotplug_context *hp,\n\t\t\t\tint (*notify)(struct acpi_device *, u32),\n\t\t\t\tvoid (*uevent)(struct acpi_device *, u32))\n{\n\tacpi_lock_hp_context();\n\thp->notify = notify;\n\thp->uevent = uevent;\n\tacpi_set_hp_context(adev, hp);\n\tacpi_unlock_hp_context();\n}\nEXPORT_SYMBOL_GPL(acpi_initialize_hp_context);\n\nint acpi_scan_add_handler(struct acpi_scan_handler *handler)\n{\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tlist_add_tail(&handler->list_node, &acpi_scan_handlers_list);\n\treturn 0;\n}\n\nint acpi_scan_add_handler_with_hotplug(struct acpi_scan_handler *handler,\n\t\t\t\t       const char *hotplug_profile_name)\n{\n\tint error;\n\n\terror = acpi_scan_add_handler(handler);\n\tif (error)\n\t\treturn error;\n\n\tacpi_sysfs_add_hotplug_profile(&handler->hotplug, hotplug_profile_name);\n\treturn 0;\n}\n\nbool acpi_scan_is_offline(struct acpi_device *adev, bool uevent)\n{\n\tstruct acpi_device_physical_node *pn;\n\tbool offline = true;\n\tchar *envp[] = { \"EVENT=offline\", NULL };\n\n\t \n\tmutex_lock_nested(&adev->physical_node_lock, SINGLE_DEPTH_NESTING);\n\n\tlist_for_each_entry(pn, &adev->physical_node_list, node)\n\t\tif (device_supports_offline(pn->dev) && !pn->dev->offline) {\n\t\t\tif (uevent)\n\t\t\t\tkobject_uevent_env(&pn->dev->kobj, KOBJ_CHANGE, envp);\n\n\t\t\toffline = false;\n\t\t\tbreak;\n\t\t}\n\n\tmutex_unlock(&adev->physical_node_lock);\n\treturn offline;\n}\n\nstatic acpi_status acpi_bus_offline(acpi_handle handle, u32 lvl, void *data,\n\t\t\t\t    void **ret_p)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\tstruct acpi_device_physical_node *pn;\n\tbool second_pass = (bool)data;\n\tacpi_status status = AE_OK;\n\n\tif (!device)\n\t\treturn AE_OK;\n\n\tif (device->handler && !device->handler->hotplug.enabled) {\n\t\t*ret_p = &device->dev;\n\t\treturn AE_SUPPORT;\n\t}\n\n\tmutex_lock(&device->physical_node_lock);\n\n\tlist_for_each_entry(pn, &device->physical_node_list, node) {\n\t\tint ret;\n\n\t\tif (second_pass) {\n\t\t\t \n\t\t\tif (pn->put_online)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tpn->put_online = false;\n\t\t}\n\t\tret = device_offline(pn->dev);\n\t\tif (ret >= 0) {\n\t\t\tpn->put_online = !ret;\n\t\t} else {\n\t\t\t*ret_p = pn->dev;\n\t\t\tif (second_pass) {\n\t\t\t\tstatus = AE_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&device->physical_node_lock);\n\n\treturn status;\n}\n\nstatic acpi_status acpi_bus_online(acpi_handle handle, u32 lvl, void *data,\n\t\t\t\t   void **ret_p)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\tstruct acpi_device_physical_node *pn;\n\n\tif (!device)\n\t\treturn AE_OK;\n\n\tmutex_lock(&device->physical_node_lock);\n\n\tlist_for_each_entry(pn, &device->physical_node_list, node)\n\t\tif (pn->put_online) {\n\t\t\tdevice_online(pn->dev);\n\t\t\tpn->put_online = false;\n\t\t}\n\n\tmutex_unlock(&device->physical_node_lock);\n\n\treturn AE_OK;\n}\n\nstatic int acpi_scan_try_to_offline(struct acpi_device *device)\n{\n\tacpi_handle handle = device->handle;\n\tstruct device *errdev = NULL;\n\tacpi_status status;\n\n\t \n\tstatus = acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,\n\t\t\t\t     NULL, acpi_bus_offline, (void *)false,\n\t\t\t\t     (void **)&errdev);\n\tif (status == AE_SUPPORT) {\n\t\tdev_warn(errdev, \"Offline disabled.\\n\");\n\t\tacpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,\n\t\t\t\t    acpi_bus_online, NULL, NULL, NULL);\n\t\treturn -EPERM;\n\t}\n\tacpi_bus_offline(handle, 0, (void *)false, (void **)&errdev);\n\tif (errdev) {\n\t\terrdev = NULL;\n\t\tacpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,\n\t\t\t\t    NULL, acpi_bus_offline, (void *)true,\n\t\t\t\t    (void **)&errdev);\n\t\tif (!errdev)\n\t\t\tacpi_bus_offline(handle, 0, (void *)true,\n\t\t\t\t\t (void **)&errdev);\n\n\t\tif (errdev) {\n\t\t\tdev_warn(errdev, \"Offline failed.\\n\");\n\t\t\tacpi_bus_online(handle, 0, NULL, NULL);\n\t\t\tacpi_walk_namespace(ACPI_TYPE_ANY, handle,\n\t\t\t\t\t    ACPI_UINT32_MAX, acpi_bus_online,\n\t\t\t\t\t    NULL, NULL, NULL);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int acpi_scan_hot_remove(struct acpi_device *device)\n{\n\tacpi_handle handle = device->handle;\n\tunsigned long long sta;\n\tacpi_status status;\n\n\tif (device->handler && device->handler->hotplug.demand_offline) {\n\t\tif (!acpi_scan_is_offline(device, true))\n\t\t\treturn -EBUSY;\n\t} else {\n\t\tint error = acpi_scan_try_to_offline(device);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tacpi_handle_debug(handle, \"Ejecting\\n\");\n\n\tacpi_bus_trim(device);\n\n\tacpi_evaluate_lck(handle, 0);\n\t \n\tstatus = acpi_evaluate_ej0(handle);\n\tif (status == AE_NOT_FOUND)\n\t\treturn -ENODEV;\n\telse if (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\t \n\tstatus = acpi_evaluate_integer(handle, \"_STA\", NULL, &sta);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_warn(handle,\n\t\t\t\"Status check after eject failed (0x%x)\\n\", status);\n\t} else if (sta & ACPI_STA_DEVICE_ENABLED) {\n\t\tacpi_handle_warn(handle,\n\t\t\t\"Eject incomplete - status 0x%llx\\n\", sta);\n\t}\n\n\treturn 0;\n}\n\nstatic int acpi_scan_device_not_present(struct acpi_device *adev)\n{\n\tif (!acpi_device_enumerated(adev)) {\n\t\tdev_warn(&adev->dev, \"Still not present\\n\");\n\t\treturn -EALREADY;\n\t}\n\tacpi_bus_trim(adev);\n\treturn 0;\n}\n\nstatic int acpi_scan_device_check(struct acpi_device *adev)\n{\n\tint error;\n\n\tacpi_bus_get_status(adev);\n\tif (adev->status.present || adev->status.functional) {\n\t\t \n\t\tif (adev->handler) {\n\t\t\tdev_warn(&adev->dev, \"Already enumerated\\n\");\n\t\t\treturn -EALREADY;\n\t\t}\n\t\terror = acpi_bus_scan(adev->handle);\n\t\tif (error) {\n\t\t\tdev_warn(&adev->dev, \"Namespace scan failure\\n\");\n\t\t\treturn error;\n\t\t}\n\t\tif (!adev->handler) {\n\t\t\tdev_warn(&adev->dev, \"Enumeration failure\\n\");\n\t\t\terror = -ENODEV;\n\t\t}\n\t} else {\n\t\terror = acpi_scan_device_not_present(adev);\n\t}\n\treturn error;\n}\n\nstatic int acpi_scan_bus_check(struct acpi_device *adev, void *not_used)\n{\n\tstruct acpi_scan_handler *handler = adev->handler;\n\tint error;\n\n\tacpi_bus_get_status(adev);\n\tif (!(adev->status.present || adev->status.functional)) {\n\t\tacpi_scan_device_not_present(adev);\n\t\treturn 0;\n\t}\n\tif (handler && handler->hotplug.scan_dependent)\n\t\treturn handler->hotplug.scan_dependent(adev);\n\n\terror = acpi_bus_scan(adev->handle);\n\tif (error) {\n\t\tdev_warn(&adev->dev, \"Namespace scan failure\\n\");\n\t\treturn error;\n\t}\n\treturn acpi_dev_for_each_child(adev, acpi_scan_bus_check, NULL);\n}\n\nstatic int acpi_generic_hotplug_event(struct acpi_device *adev, u32 type)\n{\n\tswitch (type) {\n\tcase ACPI_NOTIFY_BUS_CHECK:\n\t\treturn acpi_scan_bus_check(adev, NULL);\n\tcase ACPI_NOTIFY_DEVICE_CHECK:\n\t\treturn acpi_scan_device_check(adev);\n\tcase ACPI_NOTIFY_EJECT_REQUEST:\n\tcase ACPI_OST_EC_OSPM_EJECT:\n\t\tif (adev->handler && !adev->handler->hotplug.enabled) {\n\t\t\tdev_info(&adev->dev, \"Eject disabled\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tacpi_evaluate_ost(adev->handle, ACPI_NOTIFY_EJECT_REQUEST,\n\t\t\t\t  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);\n\t\treturn acpi_scan_hot_remove(adev);\n\t}\n\treturn -EINVAL;\n}\n\nvoid acpi_device_hotplug(struct acpi_device *adev, u32 src)\n{\n\tu32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;\n\tint error = -ENODEV;\n\n\tlock_device_hotplug();\n\tmutex_lock(&acpi_scan_lock);\n\n\t \n\tif (adev->handle == INVALID_ACPI_HANDLE)\n\t\tgoto err_out;\n\n\tif (adev->flags.is_dock_station) {\n\t\terror = dock_notify(adev, src);\n\t} else if (adev->flags.hotplug_notify) {\n\t\terror = acpi_generic_hotplug_event(adev, src);\n\t} else {\n\t\tint (*notify)(struct acpi_device *, u32);\n\n\t\tacpi_lock_hp_context();\n\t\tnotify = adev->hp ? adev->hp->notify : NULL;\n\t\tacpi_unlock_hp_context();\n\t\t \n\t\tif (notify)\n\t\t\terror = notify(adev, src);\n\t\telse\n\t\t\tgoto out;\n\t}\n\tswitch (error) {\n\tcase 0:\n\t\tost_code = ACPI_OST_SC_SUCCESS;\n\t\tbreak;\n\tcase -EPERM:\n\t\tost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;\n\t\tbreak;\n\tcase -EBUSY:\n\t\tost_code = ACPI_OST_SC_DEVICE_BUSY;\n\t\tbreak;\n\tdefault:\n\t\tost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;\n\t\tbreak;\n\t}\n\n err_out:\n\tacpi_evaluate_ost(adev->handle, src, ost_code, NULL);\n\n out:\n\tacpi_put_acpi_dev(adev);\n\tmutex_unlock(&acpi_scan_lock);\n\tunlock_device_hotplug();\n}\n\nstatic void acpi_free_power_resources_lists(struct acpi_device *device)\n{\n\tint i;\n\n\tif (device->wakeup.flags.valid)\n\t\tacpi_power_resources_list_free(&device->wakeup.resources);\n\n\tif (!device->power.flags.power_resources)\n\t\treturn;\n\n\tfor (i = ACPI_STATE_D0; i <= ACPI_STATE_D3_HOT; i++) {\n\t\tstruct acpi_device_power_state *ps = &device->power.states[i];\n\t\tacpi_power_resources_list_free(&ps->resources);\n\t}\n}\n\nstatic void acpi_device_release(struct device *dev)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\n\tacpi_free_properties(acpi_dev);\n\tacpi_free_pnp_ids(&acpi_dev->pnp);\n\tacpi_free_power_resources_lists(acpi_dev);\n\tkfree(acpi_dev);\n}\n\nstatic void acpi_device_del(struct acpi_device *device)\n{\n\tstruct acpi_device_bus_id *acpi_device_bus_id;\n\n\tmutex_lock(&acpi_device_lock);\n\n\tlist_for_each_entry(acpi_device_bus_id, &acpi_bus_id_list, node)\n\t\tif (!strcmp(acpi_device_bus_id->bus_id,\n\t\t\t    acpi_device_hid(device))) {\n\t\t\tida_free(&acpi_device_bus_id->instance_ida,\n\t\t\t\t device->pnp.instance_no);\n\t\t\tif (ida_is_empty(&acpi_device_bus_id->instance_ida)) {\n\t\t\t\tlist_del(&acpi_device_bus_id->node);\n\t\t\t\tkfree_const(acpi_device_bus_id->bus_id);\n\t\t\t\tkfree(acpi_device_bus_id);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\tlist_del(&device->wakeup_list);\n\n\tmutex_unlock(&acpi_device_lock);\n\n\tacpi_power_add_remove_device(device, false);\n\tacpi_device_remove_files(device);\n\tif (device->remove)\n\t\tdevice->remove(device);\n\n\tdevice_del(&device->dev);\n}\n\nstatic BLOCKING_NOTIFIER_HEAD(acpi_reconfig_chain);\n\nstatic LIST_HEAD(acpi_device_del_list);\nstatic DEFINE_MUTEX(acpi_device_del_lock);\n\nstatic void acpi_device_del_work_fn(struct work_struct *work_not_used)\n{\n\tfor (;;) {\n\t\tstruct acpi_device *adev;\n\n\t\tmutex_lock(&acpi_device_del_lock);\n\n\t\tif (list_empty(&acpi_device_del_list)) {\n\t\t\tmutex_unlock(&acpi_device_del_lock);\n\t\t\tbreak;\n\t\t}\n\t\tadev = list_first_entry(&acpi_device_del_list,\n\t\t\t\t\tstruct acpi_device, del_list);\n\t\tlist_del(&adev->del_list);\n\n\t\tmutex_unlock(&acpi_device_del_lock);\n\n\t\tblocking_notifier_call_chain(&acpi_reconfig_chain,\n\t\t\t\t\t     ACPI_RECONFIG_DEVICE_REMOVE, adev);\n\n\t\tacpi_device_del(adev);\n\t\t \n\t\tacpi_power_transition(adev, ACPI_STATE_D3_COLD);\n\t\tacpi_dev_put(adev);\n\t}\n}\n\n \nstatic void acpi_scan_drop_device(acpi_handle handle, void *context)\n{\n\tstatic DECLARE_WORK(work, acpi_device_del_work_fn);\n\tstruct acpi_device *adev = context;\n\n\tmutex_lock(&acpi_device_del_lock);\n\n\t \n\tif (list_empty(&acpi_device_del_list))\n\t\tacpi_queue_hotplug_work(&work);\n\n\tlist_add_tail(&adev->del_list, &acpi_device_del_list);\n\t \n\tadev->handle = INVALID_ACPI_HANDLE;\n\n\tmutex_unlock(&acpi_device_del_lock);\n}\n\nstatic struct acpi_device *handle_to_device(acpi_handle handle,\n\t\t\t\t\t    void (*callback)(void *))\n{\n\tstruct acpi_device *adev = NULL;\n\tacpi_status status;\n\n\tstatus = acpi_get_data_full(handle, acpi_scan_drop_device,\n\t\t\t\t    (void **)&adev, callback);\n\tif (ACPI_FAILURE(status) || !adev) {\n\t\tacpi_handle_debug(handle, \"No context!\\n\");\n\t\treturn NULL;\n\t}\n\treturn adev;\n}\n\n \nstruct acpi_device *acpi_fetch_acpi_dev(acpi_handle handle)\n{\n\treturn handle_to_device(handle, NULL);\n}\nEXPORT_SYMBOL_GPL(acpi_fetch_acpi_dev);\n\nstatic void get_acpi_device(void *dev)\n{\n\tacpi_dev_get(dev);\n}\n\n \nstruct acpi_device *acpi_get_acpi_dev(acpi_handle handle)\n{\n\treturn handle_to_device(handle, get_acpi_device);\n}\nEXPORT_SYMBOL_GPL(acpi_get_acpi_dev);\n\nstatic struct acpi_device_bus_id *acpi_device_bus_id_match(const char *dev_id)\n{\n\tstruct acpi_device_bus_id *acpi_device_bus_id;\n\n\t \n\tlist_for_each_entry(acpi_device_bus_id, &acpi_bus_id_list, node) {\n\t\tif (!strcmp(acpi_device_bus_id->bus_id, dev_id))\n\t\t\treturn acpi_device_bus_id;\n\t}\n\treturn NULL;\n}\n\nstatic int acpi_device_set_name(struct acpi_device *device,\n\t\t\t\tstruct acpi_device_bus_id *acpi_device_bus_id)\n{\n\tstruct ida *instance_ida = &acpi_device_bus_id->instance_ida;\n\tint result;\n\n\tresult = ida_alloc(instance_ida, GFP_KERNEL);\n\tif (result < 0)\n\t\treturn result;\n\n\tdevice->pnp.instance_no = result;\n\tdev_set_name(&device->dev, \"%s:%02x\", acpi_device_bus_id->bus_id, result);\n\treturn 0;\n}\n\nint acpi_tie_acpi_dev(struct acpi_device *adev)\n{\n\tacpi_handle handle = adev->handle;\n\tacpi_status status;\n\n\tif (!handle)\n\t\treturn 0;\n\n\tstatus = acpi_attach_data(handle, acpi_scan_drop_device, adev);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_err(handle, \"Unable to attach device data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void acpi_store_pld_crc(struct acpi_device *adev)\n{\n\tstruct acpi_pld_info *pld;\n\tacpi_status status;\n\n\tstatus = acpi_get_physical_device_location(adev->handle, &pld);\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\n\tadev->pld_crc = crc32(~0, pld, sizeof(*pld));\n\tACPI_FREE(pld);\n}\n\nint acpi_device_add(struct acpi_device *device)\n{\n\tstruct acpi_device_bus_id *acpi_device_bus_id;\n\tint result;\n\n\t \n\tINIT_LIST_HEAD(&device->wakeup_list);\n\tINIT_LIST_HEAD(&device->physical_node_list);\n\tINIT_LIST_HEAD(&device->del_list);\n\tmutex_init(&device->physical_node_lock);\n\n\tmutex_lock(&acpi_device_lock);\n\n\tacpi_device_bus_id = acpi_device_bus_id_match(acpi_device_hid(device));\n\tif (acpi_device_bus_id) {\n\t\tresult = acpi_device_set_name(device, acpi_device_bus_id);\n\t\tif (result)\n\t\t\tgoto err_unlock;\n\t} else {\n\t\tacpi_device_bus_id = kzalloc(sizeof(*acpi_device_bus_id),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!acpi_device_bus_id) {\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tacpi_device_bus_id->bus_id =\n\t\t\tkstrdup_const(acpi_device_hid(device), GFP_KERNEL);\n\t\tif (!acpi_device_bus_id->bus_id) {\n\t\t\tkfree(acpi_device_bus_id);\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\tida_init(&acpi_device_bus_id->instance_ida);\n\n\t\tresult = acpi_device_set_name(device, acpi_device_bus_id);\n\t\tif (result) {\n\t\t\tkfree_const(acpi_device_bus_id->bus_id);\n\t\t\tkfree(acpi_device_bus_id);\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\tlist_add_tail(&acpi_device_bus_id->node, &acpi_bus_id_list);\n\t}\n\n\tif (device->wakeup.flags.valid)\n\t\tlist_add_tail(&device->wakeup_list, &acpi_wakeup_device_list);\n\n\tacpi_store_pld_crc(device);\n\n\tmutex_unlock(&acpi_device_lock);\n\n\tresult = device_add(&device->dev);\n\tif (result) {\n\t\tdev_err(&device->dev, \"Error registering device\\n\");\n\t\tgoto err;\n\t}\n\n\tresult = acpi_device_setup_files(device);\n\tif (result)\n\t\tpr_err(\"Error creating sysfs interface for device %s\\n\",\n\t\t       dev_name(&device->dev));\n\n\treturn 0;\n\nerr:\n\tmutex_lock(&acpi_device_lock);\n\n\tlist_del(&device->wakeup_list);\n\nerr_unlock:\n\tmutex_unlock(&acpi_device_lock);\n\n\tacpi_detach_data(device->handle, acpi_scan_drop_device);\n\n\treturn result;\n}\n\n \nstatic bool acpi_info_matches_ids(struct acpi_device_info *info,\n\t\t\t\t  const char * const ids[])\n{\n\tstruct acpi_pnp_device_id_list *cid_list = NULL;\n\tint i, index;\n\n\tif (!(info->valid & ACPI_VALID_HID))\n\t\treturn false;\n\n\tindex = match_string(ids, -1, info->hardware_id.string);\n\tif (index >= 0)\n\t\treturn true;\n\n\tif (info->valid & ACPI_VALID_CID)\n\t\tcid_list = &info->compatible_id_list;\n\n\tif (!cid_list)\n\t\treturn false;\n\n\tfor (i = 0; i < cid_list->count; i++) {\n\t\tindex = match_string(ids, -1, cid_list->ids[i].string);\n\t\tif (index >= 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic const char * const acpi_ignore_dep_ids[] = {\n\t\"PNP0D80\",  \n\t\"INT33BD\",  \n\t\"LATT2021\",  \n\tNULL\n};\n\n \nstatic const char * const acpi_honor_dep_ids[] = {\n\t\"INT3472\",  \n\t\"INTC1059\",  \n\t\"INTC1095\",  \n\t\"INTC100A\",  \n\tNULL\n};\n\nstatic struct acpi_device *acpi_find_parent_acpi_dev(acpi_handle handle)\n{\n\tstruct acpi_device *adev;\n\n\t \n\tif (!handle)\n\t\treturn acpi_root;\n\n\tdo {\n\t\tacpi_status status;\n\n\t\tstatus = acpi_get_parent(handle, &handle);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tif (status != AE_NULL_ENTRY)\n\t\t\t\treturn acpi_root;\n\n\t\t\treturn NULL;\n\t\t}\n\t\tadev = acpi_fetch_acpi_dev(handle);\n\t} while (!adev);\n\treturn adev;\n}\n\nacpi_status\nacpi_bus_get_ejd(acpi_handle handle, acpi_handle *ejd)\n{\n\tacpi_status status;\n\tacpi_handle tmp;\n\tstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\n\tunion acpi_object *obj;\n\n\tstatus = acpi_get_handle(handle, \"_EJD\", &tmp);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tstatus = acpi_evaluate_object(handle, \"_EJD\", NULL, &buffer);\n\tif (ACPI_SUCCESS(status)) {\n\t\tobj = buffer.pointer;\n\t\tstatus = acpi_get_handle(ACPI_ROOT_OBJECT, obj->string.pointer,\n\t\t\t\t\t ejd);\n\t\tkfree(buffer.pointer);\n\t}\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(acpi_bus_get_ejd);\n\nstatic int acpi_bus_extract_wakeup_device_power_package(struct acpi_device *dev)\n{\n\tacpi_handle handle = dev->handle;\n\tstruct acpi_device_wakeup *wakeup = &dev->wakeup;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *package = NULL;\n\tunion acpi_object *element = NULL;\n\tacpi_status status;\n\tint err = -ENODATA;\n\n\tINIT_LIST_HEAD(&wakeup->resources);\n\n\t \n\tstatus = acpi_evaluate_object(handle, \"_PRW\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_info(handle, \"_PRW evaluation failed: %s\\n\",\n\t\t\t\t acpi_format_exception(status));\n\t\treturn err;\n\t}\n\n\tpackage = (union acpi_object *)buffer.pointer;\n\n\tif (!package || package->package.count < 2)\n\t\tgoto out;\n\n\telement = &(package->package.elements[0]);\n\tif (!element)\n\t\tgoto out;\n\n\tif (element->type == ACPI_TYPE_PACKAGE) {\n\t\tif ((element->package.count < 2) ||\n\t\t    (element->package.elements[0].type !=\n\t\t     ACPI_TYPE_LOCAL_REFERENCE)\n\t\t    || (element->package.elements[1].type != ACPI_TYPE_INTEGER))\n\t\t\tgoto out;\n\n\t\twakeup->gpe_device =\n\t\t    element->package.elements[0].reference.handle;\n\t\twakeup->gpe_number =\n\t\t    (u32) element->package.elements[1].integer.value;\n\t} else if (element->type == ACPI_TYPE_INTEGER) {\n\t\twakeup->gpe_device = NULL;\n\t\twakeup->gpe_number = element->integer.value;\n\t} else {\n\t\tgoto out;\n\t}\n\n\telement = &(package->package.elements[1]);\n\tif (element->type != ACPI_TYPE_INTEGER)\n\t\tgoto out;\n\n\twakeup->sleep_state = element->integer.value;\n\n\terr = acpi_extract_power_resources(package, 2, &wakeup->resources);\n\tif (err)\n\t\tgoto out;\n\n\tif (!list_empty(&wakeup->resources)) {\n\t\tint sleep_state;\n\n\t\terr = acpi_power_wakeup_list_init(&wakeup->resources,\n\t\t\t\t\t\t  &sleep_state);\n\t\tif (err) {\n\t\t\tacpi_handle_warn(handle, \"Retrieving current states \"\n\t\t\t\t\t \"of wakeup power resources failed\\n\");\n\t\t\tacpi_power_resources_list_free(&wakeup->resources);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sleep_state < wakeup->sleep_state) {\n\t\t\tacpi_handle_warn(handle, \"Overriding _PRW sleep state \"\n\t\t\t\t\t \"(S%d) by S%d from power resources\\n\",\n\t\t\t\t\t (int)wakeup->sleep_state, sleep_state);\n\t\t\twakeup->sleep_state = sleep_state;\n\t\t}\n\t}\n\n out:\n\tkfree(buffer.pointer);\n\treturn err;\n}\n\n \n#define ACPI_AVOID_WAKE_FROM_S5\t\tBIT(0)\n\nstatic bool acpi_wakeup_gpe_init(struct acpi_device *device)\n{\n\tstatic const struct acpi_device_id button_device_ids[] = {\n\t\t{\"PNP0C0C\", 0},\t\t\t\t \n\t\t{\"PNP0C0D\", ACPI_AVOID_WAKE_FROM_S5},\t \n\t\t{\"PNP0C0E\", ACPI_AVOID_WAKE_FROM_S5},\t \n\t\t{\"\", 0},\n\t};\n\tstruct acpi_device_wakeup *wakeup = &device->wakeup;\n\tconst struct acpi_device_id *match;\n\tacpi_status status;\n\n\twakeup->flags.notifier_present = 0;\n\n\t \n\tmatch = acpi_match_acpi_device(button_device_ids, device);\n\tif (match) {\n\t\tif ((match->driver_data & ACPI_AVOID_WAKE_FROM_S5) &&\n\t\t    wakeup->sleep_state == ACPI_STATE_S5)\n\t\t\twakeup->sleep_state = ACPI_STATE_S4;\n\t\tacpi_mark_gpe_for_wake(wakeup->gpe_device, wakeup->gpe_number);\n\t\tdevice_set_wakeup_capable(&device->dev, true);\n\t\treturn true;\n\t}\n\n\tstatus = acpi_setup_gpe_for_wake(device->handle, wakeup->gpe_device,\n\t\t\t\t\t wakeup->gpe_number);\n\treturn ACPI_SUCCESS(status);\n}\n\nstatic void acpi_bus_get_wakeup_device_flags(struct acpi_device *device)\n{\n\tint err;\n\n\t \n\tif (!acpi_has_method(device->handle, \"_PRW\"))\n\t\treturn;\n\n\terr = acpi_bus_extract_wakeup_device_power_package(device);\n\tif (err) {\n\t\tdev_err(&device->dev, \"Unable to extract wakeup power resources\");\n\t\treturn;\n\t}\n\n\tdevice->wakeup.flags.valid = acpi_wakeup_gpe_init(device);\n\tdevice->wakeup.prepare_count = 0;\n\t \n\terr = acpi_device_sleep_wake(device, 0, 0, 0);\n\tif (err)\n\t\tpr_debug(\"error in _DSW or _PSW evaluation\\n\");\n}\n\nstatic void acpi_bus_init_power_state(struct acpi_device *device, int state)\n{\n\tstruct acpi_device_power_state *ps = &device->power.states[state];\n\tchar pathname[5] = { '_', 'P', 'R', '0' + state, '\\0' };\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_status status;\n\n\tINIT_LIST_HEAD(&ps->resources);\n\n\t \n\tstatus = acpi_evaluate_object(device->handle, pathname, NULL, &buffer);\n\tif (ACPI_SUCCESS(status)) {\n\t\tunion acpi_object *package = buffer.pointer;\n\n\t\tif (buffer.length && package\n\t\t    && package->type == ACPI_TYPE_PACKAGE\n\t\t    && package->package.count)\n\t\t\tacpi_extract_power_resources(package, 0, &ps->resources);\n\n\t\tACPI_FREE(buffer.pointer);\n\t}\n\n\t \n\tpathname[2] = 'S';\n\tif (acpi_has_method(device->handle, pathname))\n\t\tps->flags.explicit_set = 1;\n\n\t \n\tif (!list_empty(&ps->resources) || ps->flags.explicit_set)\n\t\tps->flags.valid = 1;\n\n\tps->power = -1;\t\t \n\tps->latency = -1;\t \n}\n\nstatic void acpi_bus_get_power_flags(struct acpi_device *device)\n{\n\tunsigned long long dsc = ACPI_STATE_D0;\n\tu32 i;\n\n\t \n\tif (!acpi_has_method(device->handle, \"_PS0\") &&\n\t    !acpi_has_method(device->handle, \"_PR0\"))\n\t\treturn;\n\n\tdevice->flags.power_manageable = 1;\n\n\t \n\tif (acpi_has_method(device->handle, \"_PSC\"))\n\t\tdevice->power.flags.explicit_get = 1;\n\n\tif (acpi_has_method(device->handle, \"_IRC\"))\n\t\tdevice->power.flags.inrush_current = 1;\n\n\tif (acpi_has_method(device->handle, \"_DSW\"))\n\t\tdevice->power.flags.dsw_present = 1;\n\n\tacpi_evaluate_integer(device->handle, \"_DSC\", NULL, &dsc);\n\tdevice->power.state_for_enumeration = dsc;\n\n\t \n\tfor (i = ACPI_STATE_D0; i <= ACPI_STATE_D3_HOT; i++)\n\t\tacpi_bus_init_power_state(device, i);\n\n\tINIT_LIST_HEAD(&device->power.states[ACPI_STATE_D3_COLD].resources);\n\n\t \n\tdevice->power.states[ACPI_STATE_D0].flags.valid = 1;\n\tdevice->power.states[ACPI_STATE_D0].power = 100;\n\tdevice->power.states[ACPI_STATE_D3_HOT].flags.valid = 1;\n\n\t \n\tif (!list_empty(&device->power.states[ACPI_STATE_D0].resources)) {\n\t\tdevice->power.flags.power_resources = 1;\n\t\t \n\t\tif (!list_empty(&device->power.states[ACPI_STATE_D3_HOT].resources))\n\t\t\tdevice->power.states[ACPI_STATE_D3_COLD].flags.valid = 1;\n\t}\n\n\tif (acpi_bus_init_power(device))\n\t\tdevice->flags.power_manageable = 0;\n}\n\nstatic void acpi_bus_get_flags(struct acpi_device *device)\n{\n\t \n\tif (acpi_has_method(device->handle, \"_STA\"))\n\t\tdevice->flags.dynamic_status = 1;\n\n\t \n\tif (acpi_has_method(device->handle, \"_RMV\"))\n\t\tdevice->flags.removable = 1;\n\n\t \n\tif (acpi_has_method(device->handle, \"_EJD\") ||\n\t    acpi_has_method(device->handle, \"_EJ0\"))\n\t\tdevice->flags.ejectable = 1;\n}\n\nstatic void acpi_device_get_busid(struct acpi_device *device)\n{\n\tchar bus_id[5] = { '?', 0 };\n\tstruct acpi_buffer buffer = { sizeof(bus_id), bus_id };\n\tint i = 0;\n\n\t \n\tif (!acpi_dev_parent(device)) {\n\t\tstrcpy(device->pnp.bus_id, \"ACPI\");\n\t\treturn;\n\t}\n\n\tswitch (device->device_type) {\n\tcase ACPI_BUS_TYPE_POWER_BUTTON:\n\t\tstrcpy(device->pnp.bus_id, \"PWRF\");\n\t\tbreak;\n\tcase ACPI_BUS_TYPE_SLEEP_BUTTON:\n\t\tstrcpy(device->pnp.bus_id, \"SLPF\");\n\t\tbreak;\n\tcase ACPI_BUS_TYPE_ECDT_EC:\n\t\tstrcpy(device->pnp.bus_id, \"ECDT\");\n\t\tbreak;\n\tdefault:\n\t\tacpi_get_name(device->handle, ACPI_SINGLE_NAME, &buffer);\n\t\t \n\t\tfor (i = 3; i > 1; i--) {\n\t\t\tif (bus_id[i] == '_')\n\t\t\t\tbus_id[i] = '\\0';\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tstrcpy(device->pnp.bus_id, bus_id);\n\t\tbreak;\n\t}\n}\n\n \nbool acpi_ata_match(acpi_handle handle)\n{\n\treturn acpi_has_method(handle, \"_GTF\") ||\n\t       acpi_has_method(handle, \"_GTM\") ||\n\t       acpi_has_method(handle, \"_STM\") ||\n\t       acpi_has_method(handle, \"_SDD\");\n}\n\n \nbool acpi_bay_match(acpi_handle handle)\n{\n\tacpi_handle phandle;\n\n\tif (!acpi_has_method(handle, \"_EJ0\"))\n\t\treturn false;\n\tif (acpi_ata_match(handle))\n\t\treturn true;\n\tif (ACPI_FAILURE(acpi_get_parent(handle, &phandle)))\n\t\treturn false;\n\n\treturn acpi_ata_match(phandle);\n}\n\nbool acpi_device_is_battery(struct acpi_device *adev)\n{\n\tstruct acpi_hardware_id *hwid;\n\n\tlist_for_each_entry(hwid, &adev->pnp.ids, list)\n\t\tif (!strcmp(\"PNP0C0A\", hwid->id))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool is_ejectable_bay(struct acpi_device *adev)\n{\n\tacpi_handle handle = adev->handle;\n\n\tif (acpi_has_method(handle, \"_EJ0\") && acpi_device_is_battery(adev))\n\t\treturn true;\n\n\treturn acpi_bay_match(handle);\n}\n\n \nbool acpi_dock_match(acpi_handle handle)\n{\n\treturn acpi_has_method(handle, \"_DCK\");\n}\n\nstatic acpi_status\nacpi_backlight_cap_match(acpi_handle handle, u32 level, void *context,\n\t\t\t  void **return_value)\n{\n\tlong *cap = context;\n\n\tif (acpi_has_method(handle, \"_BCM\") &&\n\t    acpi_has_method(handle, \"_BCL\")) {\n\t\tacpi_handle_debug(handle, \"Found generic backlight support\\n\");\n\t\t*cap |= ACPI_VIDEO_BACKLIGHT;\n\t\t \n\t\treturn AE_CTRL_TERMINATE;\n\t}\n\treturn 0;\n}\n\n \nlong acpi_is_video_device(acpi_handle handle)\n{\n\tlong video_caps = 0;\n\n\t \n\tif (acpi_has_method(handle, \"_DOD\") || acpi_has_method(handle, \"_DOS\"))\n\t\tvideo_caps |= ACPI_VIDEO_OUTPUT_SWITCHING;\n\n\t \n\tif (acpi_has_method(handle, \"_ROM\"))\n\t\tvideo_caps |= ACPI_VIDEO_ROM_AVAILABLE;\n\n\t \n\tif (acpi_has_method(handle, \"_VPO\") &&\n\t    acpi_has_method(handle, \"_GPD\") &&\n\t    acpi_has_method(handle, \"_SPD\"))\n\t\tvideo_caps |= ACPI_VIDEO_DEVICE_POSTING;\n\n\t \n\tif (video_caps)\n\t\tacpi_walk_namespace(ACPI_TYPE_DEVICE, handle,\n\t\t\t\t    ACPI_UINT32_MAX, acpi_backlight_cap_match, NULL,\n\t\t\t\t    &video_caps, NULL);\n\n\treturn video_caps;\n}\nEXPORT_SYMBOL(acpi_is_video_device);\n\nconst char *acpi_device_hid(struct acpi_device *device)\n{\n\tstruct acpi_hardware_id *hid;\n\n\tif (list_empty(&device->pnp.ids))\n\t\treturn dummy_hid;\n\n\thid = list_first_entry(&device->pnp.ids, struct acpi_hardware_id, list);\n\treturn hid->id;\n}\nEXPORT_SYMBOL(acpi_device_hid);\n\nstatic void acpi_add_id(struct acpi_device_pnp *pnp, const char *dev_id)\n{\n\tstruct acpi_hardware_id *id;\n\n\tid = kmalloc(sizeof(*id), GFP_KERNEL);\n\tif (!id)\n\t\treturn;\n\n\tid->id = kstrdup_const(dev_id, GFP_KERNEL);\n\tif (!id->id) {\n\t\tkfree(id);\n\t\treturn;\n\t}\n\n\tlist_add_tail(&id->list, &pnp->ids);\n\tpnp->type.hardware_id = 1;\n}\n\n \nstatic bool acpi_ibm_smbus_match(acpi_handle handle)\n{\n\tchar node_name[ACPI_PATH_SEGMENT_LENGTH];\n\tstruct acpi_buffer path = { sizeof(node_name), node_name };\n\n\tif (!dmi_name_in_vendors(\"IBM\"))\n\t\treturn false;\n\n\t \n\tif (ACPI_FAILURE(acpi_get_name(handle, ACPI_SINGLE_NAME, &path)) ||\n\t    strcmp(\"SMBS\", path.pointer))\n\t\treturn false;\n\n\t \n\tif (acpi_has_method(handle, \"SBI\") &&\n\t    acpi_has_method(handle, \"SBR\") &&\n\t    acpi_has_method(handle, \"SBW\"))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool acpi_object_is_system_bus(acpi_handle handle)\n{\n\tacpi_handle tmp;\n\n\tif (ACPI_SUCCESS(acpi_get_handle(NULL, \"\\\\_SB\", &tmp)) &&\n\t    tmp == handle)\n\t\treturn true;\n\tif (ACPI_SUCCESS(acpi_get_handle(NULL, \"\\\\_TZ\", &tmp)) &&\n\t    tmp == handle)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void acpi_set_pnp_ids(acpi_handle handle, struct acpi_device_pnp *pnp,\n\t\t\t     int device_type)\n{\n\tstruct acpi_device_info *info = NULL;\n\tstruct acpi_pnp_device_id_list *cid_list;\n\tint i;\n\n\tswitch (device_type) {\n\tcase ACPI_BUS_TYPE_DEVICE:\n\t\tif (handle == ACPI_ROOT_OBJECT) {\n\t\t\tacpi_add_id(pnp, ACPI_SYSTEM_HID);\n\t\t\tbreak;\n\t\t}\n\n\t\tacpi_get_object_info(handle, &info);\n\t\tif (!info) {\n\t\t\tpr_err(\"%s: Error reading device info\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tif (info->valid & ACPI_VALID_HID) {\n\t\t\tacpi_add_id(pnp, info->hardware_id.string);\n\t\t\tpnp->type.platform_id = 1;\n\t\t}\n\t\tif (info->valid & ACPI_VALID_CID) {\n\t\t\tcid_list = &info->compatible_id_list;\n\t\t\tfor (i = 0; i < cid_list->count; i++)\n\t\t\t\tacpi_add_id(pnp, cid_list->ids[i].string);\n\t\t}\n\t\tif (info->valid & ACPI_VALID_ADR) {\n\t\t\tpnp->bus_address = info->address;\n\t\t\tpnp->type.bus_address = 1;\n\t\t}\n\t\tif (info->valid & ACPI_VALID_UID)\n\t\t\tpnp->unique_id = kstrdup(info->unique_id.string,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (info->valid & ACPI_VALID_CLS)\n\t\t\tacpi_add_id(pnp, info->class_code.string);\n\n\t\tkfree(info);\n\n\t\t \n\t\tif (acpi_is_video_device(handle)) {\n\t\t\tacpi_add_id(pnp, ACPI_VIDEO_HID);\n\t\t\tpnp->type.backlight = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (acpi_bay_match(handle))\n\t\t\tacpi_add_id(pnp, ACPI_BAY_HID);\n\t\telse if (acpi_dock_match(handle))\n\t\t\tacpi_add_id(pnp, ACPI_DOCK_HID);\n\t\telse if (acpi_ibm_smbus_match(handle))\n\t\t\tacpi_add_id(pnp, ACPI_SMBUS_IBM_HID);\n\t\telse if (list_empty(&pnp->ids) &&\n\t\t\t acpi_object_is_system_bus(handle)) {\n\t\t\t \n\t\t\tacpi_add_id(pnp, ACPI_BUS_HID);\n\t\t\tstrcpy(pnp->device_name, ACPI_BUS_DEVICE_NAME);\n\t\t\tstrcpy(pnp->device_class, ACPI_BUS_CLASS);\n\t\t}\n\n\t\tbreak;\n\tcase ACPI_BUS_TYPE_POWER:\n\t\tacpi_add_id(pnp, ACPI_POWER_HID);\n\t\tbreak;\n\tcase ACPI_BUS_TYPE_PROCESSOR:\n\t\tacpi_add_id(pnp, ACPI_PROCESSOR_OBJECT_HID);\n\t\tbreak;\n\tcase ACPI_BUS_TYPE_THERMAL:\n\t\tacpi_add_id(pnp, ACPI_THERMAL_HID);\n\t\tbreak;\n\tcase ACPI_BUS_TYPE_POWER_BUTTON:\n\t\tacpi_add_id(pnp, ACPI_BUTTON_HID_POWERF);\n\t\tbreak;\n\tcase ACPI_BUS_TYPE_SLEEP_BUTTON:\n\t\tacpi_add_id(pnp, ACPI_BUTTON_HID_SLEEPF);\n\t\tbreak;\n\tcase ACPI_BUS_TYPE_ECDT_EC:\n\t\tacpi_add_id(pnp, ACPI_ECDT_HID);\n\t\tbreak;\n\t}\n}\n\nvoid acpi_free_pnp_ids(struct acpi_device_pnp *pnp)\n{\n\tstruct acpi_hardware_id *id, *tmp;\n\n\tlist_for_each_entry_safe(id, tmp, &pnp->ids, list) {\n\t\tkfree_const(id->id);\n\t\tkfree(id);\n\t}\n\tkfree(pnp->unique_id);\n}\n\n \nbool acpi_dma_supported(const struct acpi_device *adev)\n{\n\tif (!adev)\n\t\treturn false;\n\n\tif (adev->flags.cca_seen)\n\t\treturn true;\n\n\t \n\tif (!IS_ENABLED(CONFIG_ACPI_CCA_REQUIRED))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nenum dev_dma_attr acpi_get_dma_attr(struct acpi_device *adev)\n{\n\tif (!acpi_dma_supported(adev))\n\t\treturn DEV_DMA_NOT_SUPPORTED;\n\n\tif (adev->flags.coherent_dma)\n\t\treturn DEV_DMA_COHERENT;\n\telse\n\t\treturn DEV_DMA_NON_COHERENT;\n}\n\n \nint acpi_dma_get_range(struct device *dev, const struct bus_dma_region **map)\n{\n\tstruct acpi_device *adev;\n\tLIST_HEAD(list);\n\tstruct resource_entry *rentry;\n\tint ret;\n\tstruct device *dma_dev = dev;\n\tstruct bus_dma_region *r;\n\n\t \n\tdo {\n\t\tadev = ACPI_COMPANION(dma_dev);\n\t\tif (adev && acpi_has_method(adev->handle, METHOD_NAME__DMA))\n\t\t\tbreak;\n\n\t\tdma_dev = dma_dev->parent;\n\t} while (dma_dev);\n\n\tif (!dma_dev)\n\t\treturn -ENODEV;\n\n\tif (!acpi_has_method(adev->handle, METHOD_NAME__CRS)) {\n\t\tacpi_handle_warn(adev->handle, \"_DMA is valid only if _CRS is present\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = acpi_dev_get_dma_resources(adev, &list);\n\tif (ret > 0) {\n\t\tr = kcalloc(ret + 1, sizeof(*r), GFP_KERNEL);\n\t\tif (!r) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*map = r;\n\n\t\tlist_for_each_entry(rentry, &list, node) {\n\t\t\tif (rentry->res->start >= rentry->res->end) {\n\t\t\t\tkfree(*map);\n\t\t\t\t*map = NULL;\n\t\t\t\tret = -EINVAL;\n\t\t\t\tdev_dbg(dma_dev, \"Invalid DMA regions configuration\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tr->cpu_start = rentry->res->start;\n\t\t\tr->dma_start = rentry->res->start - rentry->offset;\n\t\t\tr->size = resource_size(rentry->res);\n\t\t\tr->offset = rentry->offset;\n\t\t\tr++;\n\t\t}\n\t}\n out:\n\tacpi_dev_free_resource_list(&list);\n\n\treturn ret >= 0 ? 0 : ret;\n}\n\n#ifdef CONFIG_IOMMU_API\nint acpi_iommu_fwspec_init(struct device *dev, u32 id,\n\t\t\t   struct fwnode_handle *fwnode,\n\t\t\t   const struct iommu_ops *ops)\n{\n\tint ret = iommu_fwspec_init(dev, fwnode, ops);\n\n\tif (!ret)\n\t\tret = iommu_fwspec_add_ids(dev, &id, 1);\n\n\treturn ret;\n}\n\nstatic inline const struct iommu_ops *acpi_iommu_fwspec_ops(struct device *dev)\n{\n\tstruct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);\n\n\treturn fwspec ? fwspec->ops : NULL;\n}\n\nstatic const struct iommu_ops *acpi_iommu_configure_id(struct device *dev,\n\t\t\t\t\t\t       const u32 *id_in)\n{\n\tint err;\n\tconst struct iommu_ops *ops;\n\n\t \n\tmutex_lock(&iommu_probe_device_lock);\n\t \n\tops = acpi_iommu_fwspec_ops(dev);\n\tif (ops) {\n\t\tmutex_unlock(&iommu_probe_device_lock);\n\t\treturn ops;\n\t}\n\n\terr = iort_iommu_configure_id(dev, id_in);\n\tif (err && err != -EPROBE_DEFER)\n\t\terr = viot_iommu_configure(dev);\n\tmutex_unlock(&iommu_probe_device_lock);\n\n\t \n\tif (!err && dev->bus)\n\t\terr = iommu_probe_device(dev);\n\n\t \n\tif (err == -EPROBE_DEFER) {\n\t\treturn ERR_PTR(err);\n\t} else if (err) {\n\t\tdev_dbg(dev, \"Adding to IOMMU failed: %d\\n\", err);\n\t\treturn NULL;\n\t}\n\treturn acpi_iommu_fwspec_ops(dev);\n}\n\n#else  \n\nint acpi_iommu_fwspec_init(struct device *dev, u32 id,\n\t\t\t   struct fwnode_handle *fwnode,\n\t\t\t   const struct iommu_ops *ops)\n{\n\treturn -ENODEV;\n}\n\nstatic const struct iommu_ops *acpi_iommu_configure_id(struct device *dev,\n\t\t\t\t\t\t       const u32 *id_in)\n{\n\treturn NULL;\n}\n\n#endif  \n\n \nint acpi_dma_configure_id(struct device *dev, enum dev_dma_attr attr,\n\t\t\t  const u32 *input_id)\n{\n\tconst struct iommu_ops *iommu;\n\n\tif (attr == DEV_DMA_NOT_SUPPORTED) {\n\t\tset_dma_ops(dev, &dma_dummy_ops);\n\t\treturn 0;\n\t}\n\n\tacpi_arch_dma_setup(dev);\n\n\tiommu = acpi_iommu_configure_id(dev, input_id);\n\tif (PTR_ERR(iommu) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tarch_setup_dma_ops(dev, 0, U64_MAX,\n\t\t\t\tiommu, attr == DEV_DMA_COHERENT);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_dma_configure_id);\n\nstatic void acpi_init_coherency(struct acpi_device *adev)\n{\n\tunsigned long long cca = 0;\n\tacpi_status status;\n\tstruct acpi_device *parent = acpi_dev_parent(adev);\n\n\tif (parent && parent->flags.cca_seen) {\n\t\t \n\t\tadev->flags.cca_seen = 1;\n\t\tcca = parent->flags.coherent_dma;\n\t} else {\n\t\tstatus = acpi_evaluate_integer(adev->handle, \"_CCA\",\n\t\t\t\t\t       NULL, &cca);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\tadev->flags.cca_seen = 1;\n\t\telse if (!IS_ENABLED(CONFIG_ACPI_CCA_REQUIRED))\n\t\t\t \n\t\t\tcca = 1;\n\t\telse\n\t\t\tacpi_handle_debug(adev->handle,\n\t\t\t\t\t  \"ACPI device is missing _CCA.\\n\");\n\t}\n\n\tadev->flags.coherent_dma = cca;\n}\n\nstatic int acpi_check_serial_bus_slave(struct acpi_resource *ares, void *data)\n{\n\tbool *is_serial_bus_slave_p = data;\n\n\tif (ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS)\n\t\treturn 1;\n\n\t*is_serial_bus_slave_p = true;\n\n\t  \n\treturn -1;\n}\n\nstatic bool acpi_is_indirect_io_slave(struct acpi_device *device)\n{\n\tstruct acpi_device *parent = acpi_dev_parent(device);\n\tstatic const struct acpi_device_id indirect_io_hosts[] = {\n\t\t{\"HISI0191\", 0},\n\t\t{}\n\t};\n\n\treturn parent && !acpi_match_device_ids(parent, indirect_io_hosts);\n}\n\nstatic bool acpi_device_enumeration_by_parent(struct acpi_device *device)\n{\n\tstruct list_head resource_list;\n\tbool is_serial_bus_slave = false;\n\tstatic const struct acpi_device_id ignore_serial_bus_ids[] = {\n\t \n\t\t{\"BSG1160\", },\n\t\t{\"BSG2150\", },\n\t\t{\"CSC3551\", },\n\t\t{\"CSC3556\", },\n\t\t{\"INT33FE\", },\n\t\t{\"INT3515\", },\n\t\t \n\t\t{\"CLSA0100\", },\n\t\t{\"CLSA0101\", },\n\t \n\t\t{\"MSHW0028\", },\n\t \n\t\t{\"BCM4752\", },\n\t\t{\"LNV4752\", },\n\t\t{}\n\t};\n\n\tif (acpi_is_indirect_io_slave(device))\n\t\treturn true;\n\n\t \n\tif (x86_apple_machine &&\n\t    (fwnode_property_present(&device->fwnode, \"spiSclkPeriod\") ||\n\t     fwnode_property_present(&device->fwnode, \"i2cAddress\") ||\n\t     fwnode_property_present(&device->fwnode, \"baud\")))\n\t\treturn true;\n\n\tif (!acpi_match_device_ids(device, ignore_serial_bus_ids))\n\t\treturn false;\n\n\tINIT_LIST_HEAD(&resource_list);\n\tacpi_dev_get_resources(device, &resource_list,\n\t\t\t       acpi_check_serial_bus_slave,\n\t\t\t       &is_serial_bus_slave);\n\tacpi_dev_free_resource_list(&resource_list);\n\n\treturn is_serial_bus_slave;\n}\n\nvoid acpi_init_device_object(struct acpi_device *device, acpi_handle handle,\n\t\t\t     int type, void (*release)(struct device *))\n{\n\tstruct acpi_device *parent = acpi_find_parent_acpi_dev(handle);\n\n\tINIT_LIST_HEAD(&device->pnp.ids);\n\tdevice->device_type = type;\n\tdevice->handle = handle;\n\tdevice->dev.parent = parent ? &parent->dev : NULL;\n\tdevice->dev.release = release;\n\tdevice->dev.bus = &acpi_bus_type;\n\tfwnode_init(&device->fwnode, &acpi_device_fwnode_ops);\n\tacpi_set_device_status(device, ACPI_STA_DEFAULT);\n\tacpi_device_get_busid(device);\n\tacpi_set_pnp_ids(handle, &device->pnp, type);\n\tacpi_init_properties(device);\n\tacpi_bus_get_flags(device);\n\tdevice->flags.match_driver = false;\n\tdevice->flags.initialized = true;\n\tdevice->flags.enumeration_by_parent =\n\t\tacpi_device_enumeration_by_parent(device);\n\tacpi_device_clear_enumerated(device);\n\tdevice_initialize(&device->dev);\n\tdev_set_uevent_suppress(&device->dev, true);\n\tacpi_init_coherency(device);\n}\n\nstatic void acpi_scan_dep_init(struct acpi_device *adev)\n{\n\tstruct acpi_dep_data *dep;\n\n\tlist_for_each_entry(dep, &acpi_dep_list, node) {\n\t\tif (dep->consumer == adev->handle) {\n\t\t\tif (dep->honor_dep)\n\t\t\t\tadev->flags.honor_deps = 1;\n\n\t\t\tadev->dep_unmet++;\n\t\t}\n\t}\n}\n\nvoid acpi_device_add_finalize(struct acpi_device *device)\n{\n\tdev_set_uevent_suppress(&device->dev, false);\n\tkobject_uevent(&device->dev.kobj, KOBJ_ADD);\n}\n\nstatic void acpi_scan_init_status(struct acpi_device *adev)\n{\n\tif (acpi_bus_get_status(adev))\n\t\tacpi_set_device_status(adev, 0);\n}\n\nstatic int acpi_add_single_object(struct acpi_device **child,\n\t\t\t\t  acpi_handle handle, int type, bool dep_init)\n{\n\tstruct acpi_device *device;\n\tbool release_dep_lock = false;\n\tint result;\n\n\tdevice = kzalloc(sizeof(struct acpi_device), GFP_KERNEL);\n\tif (!device)\n\t\treturn -ENOMEM;\n\n\tacpi_init_device_object(device, handle, type, acpi_device_release);\n\t \n\tif (type == ACPI_BUS_TYPE_DEVICE || type == ACPI_BUS_TYPE_PROCESSOR) {\n\t\tif (dep_init) {\n\t\t\tmutex_lock(&acpi_dep_list_lock);\n\t\t\t \n\t\t\trelease_dep_lock = true;\n\t\t\tacpi_scan_dep_init(device);\n\t\t}\n\t\tacpi_scan_init_status(device);\n\t}\n\n\tacpi_bus_get_power_flags(device);\n\tacpi_bus_get_wakeup_device_flags(device);\n\n\tresult = acpi_tie_acpi_dev(device);\n\n\tif (release_dep_lock)\n\t\tmutex_unlock(&acpi_dep_list_lock);\n\n\tif (!result)\n\t\tresult = acpi_device_add(device);\n\n\tif (result) {\n\t\tacpi_device_release(&device->dev);\n\t\treturn result;\n\t}\n\n\tacpi_power_add_remove_device(device, true);\n\tacpi_device_add_finalize(device);\n\n\tacpi_handle_debug(handle, \"Added as %s, parent %s\\n\",\n\t\t\t  dev_name(&device->dev), device->dev.parent ?\n\t\t\t\tdev_name(device->dev.parent) : \"(null)\");\n\n\t*child = device;\n\treturn 0;\n}\n\nstatic acpi_status acpi_get_resource_memory(struct acpi_resource *ares,\n\t\t\t\t\t    void *context)\n{\n\tstruct resource *res = context;\n\n\tif (acpi_dev_resource_memory(ares, res))\n\t\treturn AE_CTRL_TERMINATE;\n\n\treturn AE_OK;\n}\n\nstatic bool acpi_device_should_be_hidden(acpi_handle handle)\n{\n\tacpi_status status;\n\tstruct resource res;\n\n\t \n\tif (!(spcr_uart_addr && acpi_has_method(handle, METHOD_NAME__CRS)))\n\t\treturn false;\n\n\t \n\tstatus = acpi_walk_resources(handle, METHOD_NAME__CRS,\n\t\t\t\t     acpi_get_resource_memory, &res);\n\tif (ACPI_FAILURE(status) || res.start != spcr_uart_addr)\n\t\treturn false;\n\n\tacpi_handle_info(handle, \"The UART device @%pa in SPCR table will be hidden\\n\",\n\t\t\t &res.start);\n\n\treturn true;\n}\n\nbool acpi_device_is_present(const struct acpi_device *adev)\n{\n\treturn adev->status.present || adev->status.functional;\n}\n\nstatic bool acpi_scan_handler_matching(struct acpi_scan_handler *handler,\n\t\t\t\t       const char *idstr,\n\t\t\t\t       const struct acpi_device_id **matchid)\n{\n\tconst struct acpi_device_id *devid;\n\n\tif (handler->match)\n\t\treturn handler->match(idstr, matchid);\n\n\tfor (devid = handler->ids; devid->id[0]; devid++)\n\t\tif (!strcmp((char *)devid->id, idstr)) {\n\t\t\tif (matchid)\n\t\t\t\t*matchid = devid;\n\n\t\t\treturn true;\n\t\t}\n\n\treturn false;\n}\n\nstatic struct acpi_scan_handler *acpi_scan_match_handler(const char *idstr,\n\t\t\t\t\tconst struct acpi_device_id **matchid)\n{\n\tstruct acpi_scan_handler *handler;\n\n\tlist_for_each_entry(handler, &acpi_scan_handlers_list, list_node)\n\t\tif (acpi_scan_handler_matching(handler, idstr, matchid))\n\t\t\treturn handler;\n\n\treturn NULL;\n}\n\nvoid acpi_scan_hotplug_enabled(struct acpi_hotplug_profile *hotplug, bool val)\n{\n\tif (!!hotplug->enabled == !!val)\n\t\treturn;\n\n\tmutex_lock(&acpi_scan_lock);\n\n\thotplug->enabled = val;\n\n\tmutex_unlock(&acpi_scan_lock);\n}\n\nstatic void acpi_scan_init_hotplug(struct acpi_device *adev)\n{\n\tstruct acpi_hardware_id *hwid;\n\n\tif (acpi_dock_match(adev->handle) || is_ejectable_bay(adev)) {\n\t\tacpi_dock_add(adev);\n\t\treturn;\n\t}\n\tlist_for_each_entry(hwid, &adev->pnp.ids, list) {\n\t\tstruct acpi_scan_handler *handler;\n\n\t\thandler = acpi_scan_match_handler(hwid->id, NULL);\n\t\tif (handler) {\n\t\t\tadev->flags.hotplug_notify = true;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic u32 acpi_scan_check_dep(acpi_handle handle, bool check_dep)\n{\n\tstruct acpi_handle_list dep_devices;\n\tacpi_status status;\n\tu32 count;\n\tint i;\n\n\t \n\tif (!check_dep || !acpi_has_method(handle, \"_DEP\") ||\n\t    !acpi_has_method(handle, \"_HID\"))\n\t\treturn 0;\n\n\tstatus = acpi_evaluate_reference(handle, \"_DEP\", NULL, &dep_devices);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_debug(handle, \"Failed to evaluate _DEP.\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (count = 0, i = 0; i < dep_devices.count; i++) {\n\t\tstruct acpi_device_info *info;\n\t\tstruct acpi_dep_data *dep;\n\t\tbool skip, honor_dep;\n\n\t\tstatus = acpi_get_object_info(dep_devices.handles[i], &info);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_handle_debug(handle, \"Error reading _DEP device info\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tskip = acpi_info_matches_ids(info, acpi_ignore_dep_ids);\n\t\thonor_dep = acpi_info_matches_ids(info, acpi_honor_dep_ids);\n\t\tkfree(info);\n\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\tdep = kzalloc(sizeof(*dep), GFP_KERNEL);\n\t\tif (!dep)\n\t\t\tcontinue;\n\n\t\tcount++;\n\n\t\tdep->supplier = dep_devices.handles[i];\n\t\tdep->consumer = handle;\n\t\tdep->honor_dep = honor_dep;\n\n\t\tmutex_lock(&acpi_dep_list_lock);\n\t\tlist_add_tail(&dep->node , &acpi_dep_list);\n\t\tmutex_unlock(&acpi_dep_list_lock);\n\t}\n\n\treturn count;\n}\n\nstatic acpi_status acpi_bus_check_add(acpi_handle handle, bool check_dep,\n\t\t\t\t      struct acpi_device **adev_p)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\tacpi_object_type acpi_type;\n\tint type;\n\n\tif (device)\n\t\tgoto out;\n\n\tif (ACPI_FAILURE(acpi_get_type(handle, &acpi_type)))\n\t\treturn AE_OK;\n\n\tswitch (acpi_type) {\n\tcase ACPI_TYPE_DEVICE:\n\t\tif (acpi_device_should_be_hidden(handle))\n\t\t\treturn AE_OK;\n\n\t\t \n\t\tif (acpi_scan_check_dep(handle, check_dep) > 0)\n\t\t\treturn AE_CTRL_DEPTH;\n\n\t\tfallthrough;\n\tcase ACPI_TYPE_ANY:\t \n\t\ttype = ACPI_BUS_TYPE_DEVICE;\n\t\tbreak;\n\n\tcase ACPI_TYPE_PROCESSOR:\n\t\ttype = ACPI_BUS_TYPE_PROCESSOR;\n\t\tbreak;\n\n\tcase ACPI_TYPE_THERMAL:\n\t\ttype = ACPI_BUS_TYPE_THERMAL;\n\t\tbreak;\n\n\tcase ACPI_TYPE_POWER:\n\t\tacpi_add_power_resource(handle);\n\t\tfallthrough;\n\tdefault:\n\t\treturn AE_OK;\n\t}\n\n\t \n\tacpi_add_single_object(&device, handle, type, !check_dep);\n\tif (!device)\n\t\treturn AE_CTRL_DEPTH;\n\n\tacpi_scan_init_hotplug(device);\n\nout:\n\tif (!*adev_p)\n\t\t*adev_p = device;\n\n\treturn AE_OK;\n}\n\nstatic acpi_status acpi_bus_check_add_1(acpi_handle handle, u32 lvl_not_used,\n\t\t\t\t\tvoid *not_used, void **ret_p)\n{\n\treturn acpi_bus_check_add(handle, true, (struct acpi_device **)ret_p);\n}\n\nstatic acpi_status acpi_bus_check_add_2(acpi_handle handle, u32 lvl_not_used,\n\t\t\t\t\tvoid *not_used, void **ret_p)\n{\n\treturn acpi_bus_check_add(handle, false, (struct acpi_device **)ret_p);\n}\n\nstatic void acpi_default_enumeration(struct acpi_device *device)\n{\n\t \n\tif (!device->flags.enumeration_by_parent) {\n\t\tacpi_create_platform_device(device, NULL);\n\t\tacpi_device_set_enumerated(device);\n\t} else {\n\t\tblocking_notifier_call_chain(&acpi_reconfig_chain,\n\t\t\t\t\t     ACPI_RECONFIG_DEVICE_ADD, device);\n\t}\n}\n\nstatic const struct acpi_device_id generic_device_ids[] = {\n\t{ACPI_DT_NAMESPACE_HID, },\n\t{\"\", },\n};\n\nstatic int acpi_generic_device_attach(struct acpi_device *adev,\n\t\t\t\t      const struct acpi_device_id *not_used)\n{\n\t \n\tif (adev->data.of_compatible)\n\t\tacpi_default_enumeration(adev);\n\n\treturn 1;\n}\n\nstatic struct acpi_scan_handler generic_device_handler = {\n\t.ids = generic_device_ids,\n\t.attach = acpi_generic_device_attach,\n};\n\nstatic int acpi_scan_attach_handler(struct acpi_device *device)\n{\n\tstruct acpi_hardware_id *hwid;\n\tint ret = 0;\n\n\tlist_for_each_entry(hwid, &device->pnp.ids, list) {\n\t\tconst struct acpi_device_id *devid;\n\t\tstruct acpi_scan_handler *handler;\n\n\t\thandler = acpi_scan_match_handler(hwid->id, &devid);\n\t\tif (handler) {\n\t\t\tif (!handler->attach) {\n\t\t\t\tdevice->pnp.type.platform_id = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdevice->handler = handler;\n\t\t\tret = handler->attach(device, devid);\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\n\t\t\tdevice->handler = NULL;\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int acpi_bus_attach(struct acpi_device *device, void *first_pass)\n{\n\tbool skip = !first_pass && device->flags.visited;\n\tacpi_handle ejd;\n\tint ret;\n\n\tif (skip)\n\t\tgoto ok;\n\n\tif (ACPI_SUCCESS(acpi_bus_get_ejd(device->handle, &ejd)))\n\t\tregister_dock_dependent_device(device, ejd);\n\n\tacpi_bus_get_status(device);\n\t \n\tif (!acpi_dev_ready_for_enumeration(device)) {\n\t\tdevice->flags.initialized = false;\n\t\tacpi_device_clear_enumerated(device);\n\t\tdevice->flags.power_manageable = 0;\n\t\treturn 0;\n\t}\n\tif (device->handler)\n\t\tgoto ok;\n\n\tif (!device->flags.initialized) {\n\t\tdevice->flags.power_manageable =\n\t\t\tdevice->power.states[ACPI_STATE_D0].flags.valid;\n\t\tif (acpi_bus_init_power(device))\n\t\t\tdevice->flags.power_manageable = 0;\n\n\t\tdevice->flags.initialized = true;\n\t} else if (device->flags.visited) {\n\t\tgoto ok;\n\t}\n\n\tret = acpi_scan_attach_handler(device);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tdevice->flags.match_driver = true;\n\tif (ret > 0 && !device->flags.enumeration_by_parent) {\n\t\tacpi_device_set_enumerated(device);\n\t\tgoto ok;\n\t}\n\n\tret = device_attach(&device->dev);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (device->pnp.type.platform_id || device->flags.enumeration_by_parent)\n\t\tacpi_default_enumeration(device);\n\telse\n\t\tacpi_device_set_enumerated(device);\n\nok:\n\tacpi_dev_for_each_child(device, acpi_bus_attach, first_pass);\n\n\tif (!skip && device->handler && device->handler->hotplug.notify_online)\n\t\tdevice->handler->hotplug.notify_online(device);\n\n\treturn 0;\n}\n\nstatic int acpi_dev_get_next_consumer_dev_cb(struct acpi_dep_data *dep, void *data)\n{\n\tstruct acpi_device **adev_p = data;\n\tstruct acpi_device *adev = *adev_p;\n\n\t \n\tif (adev) {\n\t\tif (dep->consumer == adev->handle)\n\t\t\t*adev_p = NULL;\n\n\t\treturn 0;\n\t}\n\n\tadev = acpi_get_acpi_dev(dep->consumer);\n\tif (adev) {\n\t\t*(struct acpi_device **)data = adev;\n\t\treturn 1;\n\t}\n\t \n\treturn 0;\n}\n\nstruct acpi_scan_clear_dep_work {\n\tstruct work_struct work;\n\tstruct acpi_device *adev;\n};\n\nstatic void acpi_scan_clear_dep_fn(struct work_struct *work)\n{\n\tstruct acpi_scan_clear_dep_work *cdw;\n\n\tcdw = container_of(work, struct acpi_scan_clear_dep_work, work);\n\n\tacpi_scan_lock_acquire();\n\tacpi_bus_attach(cdw->adev, (void *)true);\n\tacpi_scan_lock_release();\n\n\tacpi_dev_put(cdw->adev);\n\tkfree(cdw);\n}\n\nstatic bool acpi_scan_clear_dep_queue(struct acpi_device *adev)\n{\n\tstruct acpi_scan_clear_dep_work *cdw;\n\n\tif (adev->dep_unmet)\n\t\treturn false;\n\n\tcdw = kmalloc(sizeof(*cdw), GFP_KERNEL);\n\tif (!cdw)\n\t\treturn false;\n\n\tcdw->adev = adev;\n\tINIT_WORK(&cdw->work, acpi_scan_clear_dep_fn);\n\t \n\tqueue_work(system_unbound_wq, &cdw->work);\n\n\treturn true;\n}\n\nstatic void acpi_scan_delete_dep_data(struct acpi_dep_data *dep)\n{\n\tlist_del(&dep->node);\n\tkfree(dep);\n}\n\nstatic int acpi_scan_clear_dep(struct acpi_dep_data *dep, void *data)\n{\n\tstruct acpi_device *adev = acpi_get_acpi_dev(dep->consumer);\n\n\tif (adev) {\n\t\tadev->dep_unmet--;\n\t\tif (!acpi_scan_clear_dep_queue(adev))\n\t\t\tacpi_dev_put(adev);\n\t}\n\n\tif (dep->free_when_met)\n\t\tacpi_scan_delete_dep_data(dep);\n\telse\n\t\tdep->met = true;\n\n\treturn 0;\n}\n\n \nstatic int acpi_walk_dep_device_list(acpi_handle handle,\n\t\t\t\tint (*callback)(struct acpi_dep_data *, void *),\n\t\t\t\tvoid *data)\n{\n\tstruct acpi_dep_data *dep, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&acpi_dep_list_lock);\n\tlist_for_each_entry_safe(dep, tmp, &acpi_dep_list, node) {\n\t\tif (dep->supplier == handle) {\n\t\t\tret = callback(dep, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&acpi_dep_list_lock);\n\n\treturn ret > 0 ? 0 : ret;\n}\n\n \nvoid acpi_dev_clear_dependencies(struct acpi_device *supplier)\n{\n\tacpi_walk_dep_device_list(supplier->handle, acpi_scan_clear_dep, NULL);\n}\nEXPORT_SYMBOL_GPL(acpi_dev_clear_dependencies);\n\n \nbool acpi_dev_ready_for_enumeration(const struct acpi_device *device)\n{\n\tif (device->flags.honor_deps && device->dep_unmet)\n\t\treturn false;\n\n\treturn acpi_device_is_present(device);\n}\nEXPORT_SYMBOL_GPL(acpi_dev_ready_for_enumeration);\n\n \nstruct acpi_device *acpi_dev_get_next_consumer_dev(struct acpi_device *supplier,\n\t\t\t\t\t\t   struct acpi_device *start)\n{\n\tstruct acpi_device *adev = start;\n\n\tacpi_walk_dep_device_list(supplier->handle,\n\t\t\t\t  acpi_dev_get_next_consumer_dev_cb, &adev);\n\n\tacpi_dev_put(start);\n\n\tif (adev == start)\n\t\treturn NULL;\n\n\treturn adev;\n}\nEXPORT_SYMBOL_GPL(acpi_dev_get_next_consumer_dev);\n\nstatic void acpi_scan_postponed_branch(acpi_handle handle)\n{\n\tstruct acpi_device *adev = NULL;\n\n\tif (ACPI_FAILURE(acpi_bus_check_add(handle, false, &adev)))\n\t\treturn;\n\n\tacpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,\n\t\t\t    acpi_bus_check_add_2, NULL, NULL, (void **)&adev);\n\tacpi_bus_attach(adev, NULL);\n}\n\nstatic void acpi_scan_postponed(void)\n{\n\tstruct acpi_dep_data *dep, *tmp;\n\n\tmutex_lock(&acpi_dep_list_lock);\n\n\tlist_for_each_entry_safe(dep, tmp, &acpi_dep_list, node) {\n\t\tacpi_handle handle = dep->consumer;\n\n\t\t \n\t\tif (!acpi_fetch_acpi_dev(handle)) {\n\t\t\t \n\t\t\tmutex_unlock(&acpi_dep_list_lock);\n\n\t\t\tacpi_scan_postponed_branch(handle);\n\n\t\t\tmutex_lock(&acpi_dep_list_lock);\n\t\t}\n\n\t\tif (dep->met)\n\t\t\tacpi_scan_delete_dep_data(dep);\n\t\telse\n\t\t\tdep->free_when_met = true;\n\t}\n\n\tmutex_unlock(&acpi_dep_list_lock);\n}\n\n \nint acpi_bus_scan(acpi_handle handle)\n{\n\tstruct acpi_device *device = NULL;\n\n\t \n\n\tif (ACPI_SUCCESS(acpi_bus_check_add(handle, true, &device)))\n\t\tacpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,\n\t\t\t\t    acpi_bus_check_add_1, NULL, NULL,\n\t\t\t\t    (void **)&device);\n\n\tif (!device)\n\t\treturn -ENODEV;\n\n\tacpi_bus_attach(device, (void *)true);\n\n\t \n\n\tacpi_scan_postponed();\n\n\treturn 0;\n}\nEXPORT_SYMBOL(acpi_bus_scan);\n\nstatic int acpi_bus_trim_one(struct acpi_device *adev, void *not_used)\n{\n\tstruct acpi_scan_handler *handler = adev->handler;\n\n\tacpi_dev_for_each_child_reverse(adev, acpi_bus_trim_one, NULL);\n\n\tadev->flags.match_driver = false;\n\tif (handler) {\n\t\tif (handler->detach)\n\t\t\thandler->detach(adev);\n\n\t\tadev->handler = NULL;\n\t} else {\n\t\tdevice_release_driver(&adev->dev);\n\t}\n\t \n\tacpi_device_set_power(adev, ACPI_STATE_D3_COLD);\n\tadev->flags.initialized = false;\n\tacpi_device_clear_enumerated(adev);\n\n\treturn 0;\n}\n\n \nvoid acpi_bus_trim(struct acpi_device *adev)\n{\n\tacpi_bus_trim_one(adev, NULL);\n}\nEXPORT_SYMBOL_GPL(acpi_bus_trim);\n\nint acpi_bus_register_early_device(int type)\n{\n\tstruct acpi_device *device = NULL;\n\tint result;\n\n\tresult = acpi_add_single_object(&device, NULL, type, false);\n\tif (result)\n\t\treturn result;\n\n\tdevice->flags.match_driver = true;\n\treturn device_attach(&device->dev);\n}\nEXPORT_SYMBOL_GPL(acpi_bus_register_early_device);\n\nstatic void acpi_bus_scan_fixed(void)\n{\n\tif (!(acpi_gbl_FADT.flags & ACPI_FADT_POWER_BUTTON)) {\n\t\tstruct acpi_device *adev = NULL;\n\n\t\tacpi_add_single_object(&adev, NULL, ACPI_BUS_TYPE_POWER_BUTTON,\n\t\t\t\t       false);\n\t\tif (adev) {\n\t\t\tadev->flags.match_driver = true;\n\t\t\tif (device_attach(&adev->dev) >= 0)\n\t\t\t\tdevice_init_wakeup(&adev->dev, true);\n\t\t\telse\n\t\t\t\tdev_dbg(&adev->dev, \"No driver\\n\");\n\t\t}\n\t}\n\n\tif (!(acpi_gbl_FADT.flags & ACPI_FADT_SLEEP_BUTTON)) {\n\t\tstruct acpi_device *adev = NULL;\n\n\t\tacpi_add_single_object(&adev, NULL, ACPI_BUS_TYPE_SLEEP_BUTTON,\n\t\t\t\t       false);\n\t\tif (adev) {\n\t\t\tadev->flags.match_driver = true;\n\t\t\tif (device_attach(&adev->dev) < 0)\n\t\t\t\tdev_dbg(&adev->dev, \"No driver\\n\");\n\t\t}\n\t}\n}\n\nstatic void __init acpi_get_spcr_uart_addr(void)\n{\n\tacpi_status status;\n\tstruct acpi_table_spcr *spcr_ptr;\n\n\tstatus = acpi_get_table(ACPI_SIG_SPCR, 0,\n\t\t\t\t(struct acpi_table_header **)&spcr_ptr);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_warn(\"STAO table present, but SPCR is missing\\n\");\n\t\treturn;\n\t}\n\n\tspcr_uart_addr = spcr_ptr->serial_port.address;\n\tacpi_put_table((struct acpi_table_header *)spcr_ptr);\n}\n\nstatic bool acpi_scan_initialized;\n\nvoid __init acpi_scan_init(void)\n{\n\tacpi_status status;\n\tstruct acpi_table_stao *stao_ptr;\n\n\tacpi_pci_root_init();\n\tacpi_pci_link_init();\n\tacpi_processor_init();\n\tacpi_platform_init();\n\tacpi_lpss_init();\n\tacpi_apd_init();\n\tacpi_cmos_rtc_init();\n\tacpi_container_init();\n\tacpi_memory_hotplug_init();\n\tacpi_watchdog_init();\n\tacpi_pnp_init();\n\tacpi_int340x_thermal_init();\n\tacpi_init_lpit();\n\n\tacpi_scan_add_handler(&generic_device_handler);\n\n\t \n\tstatus = acpi_get_table(ACPI_SIG_STAO, 0,\n\t\t\t\t(struct acpi_table_header **)&stao_ptr);\n\tif (ACPI_SUCCESS(status)) {\n\t\tif (stao_ptr->header.length > sizeof(struct acpi_table_stao))\n\t\t\tpr_info(\"STAO Name List not yet supported.\\n\");\n\n\t\tif (stao_ptr->ignore_uart)\n\t\t\tacpi_get_spcr_uart_addr();\n\n\t\tacpi_put_table((struct acpi_table_header *)stao_ptr);\n\t}\n\n\tacpi_gpe_apply_masked_gpes();\n\tacpi_update_all_gpes();\n\n\t \n\tmutex_lock(&acpi_scan_lock);\n\t \n\tif (acpi_bus_scan(ACPI_ROOT_OBJECT))\n\t\tgoto unlock;\n\n\tacpi_root = acpi_fetch_acpi_dev(ACPI_ROOT_OBJECT);\n\tif (!acpi_root)\n\t\tgoto unlock;\n\n\t \n\tif (!acpi_gbl_reduced_hardware)\n\t\tacpi_bus_scan_fixed();\n\n\tacpi_turn_off_unused_power_resources();\n\n\tacpi_scan_initialized = true;\n\nunlock:\n\tmutex_unlock(&acpi_scan_lock);\n}\n\nstatic struct acpi_probe_entry *ape;\nstatic int acpi_probe_count;\nstatic DEFINE_MUTEX(acpi_probe_mutex);\n\nstatic int __init acpi_match_madt(union acpi_subtable_headers *header,\n\t\t\t\t  const unsigned long end)\n{\n\tif (!ape->subtable_valid || ape->subtable_valid(&header->common, ape))\n\t\tif (!ape->probe_subtbl(header, end))\n\t\t\tacpi_probe_count++;\n\n\treturn 0;\n}\n\nint __init __acpi_probe_device_table(struct acpi_probe_entry *ap_head, int nr)\n{\n\tint count = 0;\n\n\tif (acpi_disabled)\n\t\treturn 0;\n\n\tmutex_lock(&acpi_probe_mutex);\n\tfor (ape = ap_head; nr; ape++, nr--) {\n\t\tif (ACPI_COMPARE_NAMESEG(ACPI_SIG_MADT, ape->id)) {\n\t\t\tacpi_probe_count = 0;\n\t\t\tacpi_table_parse_madt(ape->type, acpi_match_madt, 0);\n\t\t\tcount += acpi_probe_count;\n\t\t} else {\n\t\t\tint res;\n\t\t\tres = acpi_table_parse(ape->id, ape->probe_table);\n\t\t\tif (!res)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tmutex_unlock(&acpi_probe_mutex);\n\n\treturn count;\n}\n\nstatic void acpi_table_events_fn(struct work_struct *work)\n{\n\tacpi_scan_lock_acquire();\n\tacpi_bus_scan(ACPI_ROOT_OBJECT);\n\tacpi_scan_lock_release();\n\n\tkfree(work);\n}\n\nvoid acpi_scan_table_notify(void)\n{\n\tstruct work_struct *work;\n\n\tif (!acpi_scan_initialized)\n\t\treturn;\n\n\twork = kmalloc(sizeof(*work), GFP_KERNEL);\n\tif (!work)\n\t\treturn;\n\n\tINIT_WORK(work, acpi_table_events_fn);\n\tschedule_work(work);\n}\n\nint acpi_reconfig_notifier_register(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&acpi_reconfig_chain, nb);\n}\nEXPORT_SYMBOL(acpi_reconfig_notifier_register);\n\nint acpi_reconfig_notifier_unregister(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&acpi_reconfig_chain, nb);\n}\nEXPORT_SYMBOL(acpi_reconfig_notifier_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}