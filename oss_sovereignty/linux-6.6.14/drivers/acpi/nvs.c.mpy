{
  "module_name": "nvs.c",
  "hash_id": "5e95a83d0a4475d5bd79487f326c4116afb94ed274e0553cf8288cb19c6c0654",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/nvs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: PM: \" fmt\n\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n\n#include \"internal.h\"\n\n \n\nstruct nvs_region {\n\t__u64 phys_start;\n\t__u64 size;\n\tstruct list_head node;\n};\n\nstatic LIST_HEAD(nvs_region_list);\n\n#ifdef CONFIG_ACPI_SLEEP\nstatic int suspend_nvs_register(unsigned long start, unsigned long size);\n#else\nstatic inline int suspend_nvs_register(unsigned long a, unsigned long b)\n{\n\treturn 0;\n}\n#endif\n\nint acpi_nvs_register(__u64 start, __u64 size)\n{\n\tstruct nvs_region *region;\n\n\tregion = kmalloc(sizeof(*region), GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\tregion->phys_start = start;\n\tregion->size = size;\n\tlist_add_tail(&region->node, &nvs_region_list);\n\n\treturn suspend_nvs_register(start, size);\n}\n\nint acpi_nvs_for_each_region(int (*func)(__u64 start, __u64 size, void *data),\n\t\t\t     void *data)\n{\n\tint rc;\n\tstruct nvs_region *region;\n\n\tlist_for_each_entry(region, &nvs_region_list, node) {\n\t\trc = func(region->phys_start, region->size, data);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n\n#ifdef CONFIG_ACPI_SLEEP\n \n\nstruct nvs_page {\n\tunsigned long phys_start;\n\tunsigned int size;\n\tvoid *kaddr;\n\tvoid *data;\n\tbool unmap;\n\tstruct list_head node;\n};\n\nstatic LIST_HEAD(nvs_list);\n\n \nstatic int suspend_nvs_register(unsigned long start, unsigned long size)\n{\n\tstruct nvs_page *entry, *next;\n\n\tpr_info(\"Registering ACPI NVS region [mem %#010lx-%#010lx] (%ld bytes)\\n\",\n\t\tstart, start + size - 1, size);\n\n\twhile (size > 0) {\n\t\tunsigned int nr_bytes;\n\n\t\tentry = kzalloc(sizeof(struct nvs_page), GFP_KERNEL);\n\t\tif (!entry)\n\t\t\tgoto Error;\n\n\t\tlist_add_tail(&entry->node, &nvs_list);\n\t\tentry->phys_start = start;\n\t\tnr_bytes = PAGE_SIZE - (start & ~PAGE_MASK);\n\t\tentry->size = (size < nr_bytes) ? size : nr_bytes;\n\n\t\tstart += entry->size;\n\t\tsize -= entry->size;\n\t}\n\treturn 0;\n\n Error:\n\tlist_for_each_entry_safe(entry, next, &nvs_list, node) {\n\t\tlist_del(&entry->node);\n\t\tkfree(entry);\n\t}\n\treturn -ENOMEM;\n}\n\n \nvoid suspend_nvs_free(void)\n{\n\tstruct nvs_page *entry;\n\n\tlist_for_each_entry(entry, &nvs_list, node)\n\t\tif (entry->data) {\n\t\t\tfree_page((unsigned long)entry->data);\n\t\t\tentry->data = NULL;\n\t\t\tif (entry->kaddr) {\n\t\t\t\tif (entry->unmap) {\n\t\t\t\t\tiounmap(entry->kaddr);\n\t\t\t\t\tentry->unmap = false;\n\t\t\t\t} else {\n\t\t\t\t\tacpi_os_unmap_iomem(entry->kaddr,\n\t\t\t\t\t\t\t    entry->size);\n\t\t\t\t}\n\t\t\t\tentry->kaddr = NULL;\n\t\t\t}\n\t\t}\n}\n\n \nint suspend_nvs_alloc(void)\n{\n\tstruct nvs_page *entry;\n\n\tlist_for_each_entry(entry, &nvs_list, node) {\n\t\tentry->data = (void *)__get_free_page(GFP_KERNEL);\n\t\tif (!entry->data) {\n\t\t\tsuspend_nvs_free();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint suspend_nvs_save(void)\n{\n\tstruct nvs_page *entry;\n\n\tpr_info(\"Saving platform NVS memory\\n\");\n\n\tlist_for_each_entry(entry, &nvs_list, node)\n\t\tif (entry->data) {\n\t\t\tunsigned long phys = entry->phys_start;\n\t\t\tunsigned int size = entry->size;\n\n\t\t\tentry->kaddr = acpi_os_get_iomem(phys, size);\n\t\t\tif (!entry->kaddr) {\n\t\t\t\tentry->kaddr = acpi_os_ioremap(phys, size);\n\t\t\t\tentry->unmap = !!entry->kaddr;\n\t\t\t}\n\t\t\tif (!entry->kaddr) {\n\t\t\t\tsuspend_nvs_free();\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmemcpy(entry->data, entry->kaddr, entry->size);\n\t\t}\n\n\treturn 0;\n}\n\n \nvoid suspend_nvs_restore(void)\n{\n\tstruct nvs_page *entry;\n\n\tpr_info(\"Restoring platform NVS memory\\n\");\n\n\tlist_for_each_entry(entry, &nvs_list, node)\n\t\tif (entry->data)\n\t\t\tmemcpy(entry->kaddr, entry->data, entry->size);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}