{
  "module_name": "pci_irq.c",
  "hash_id": "b0f563ba70799a3b61ab6f43d2a90147cb8f052605025de56c087d5a1557da8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pci_irq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: PCI: \" fmt\n\n#include <linux/dmi.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/pm.h>\n#include <linux/pci.h>\n#include <linux/acpi.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n\nstruct acpi_prt_entry {\n\tstruct acpi_pci_id\tid;\n\tu8\t\t\tpin;\n\tacpi_handle\t\tlink;\n\tu32\t\t\tindex;\t\t \n};\n\nstatic inline char pin_name(int pin)\n{\n\treturn 'A' + pin - 1;\n}\n\n \n\n \n\tconst char\t\t*actual_source;\n};\n\n#define PCI_INTX_PIN(c)\t\t(c - 'A' + 1)\n\n \nstatic const struct prt_quirk prt_quirks[] = {\n\t{ medion_md9580, 0, 0, 9, PCI_INTX_PIN('A'),\n\t\t\"\\\\_SB_.PCI0.ISA_.LNKA\",\n\t\t\"\\\\_SB_.PCI0.ISA_.LNKB\"},\n\t{ dell_optiplex, 0, 0, 0xd, PCI_INTX_PIN('A'),\n\t\t\"\\\\_SB_.LNKB\",\n\t\t\"\\\\_SB_.LNKA\"},\n\t{ hp_t5710, 0, 0, 1, PCI_INTX_PIN('A'),\n\t\t\"\\\\_SB_.PCI0.LNK1\",\n\t\t\"\\\\_SB_.PCI0.LNK3\"},\n};\n\nstatic void do_prt_fixups(struct acpi_prt_entry *entry,\n\t\t\t  struct acpi_pci_routing_table *prt)\n{\n\tint i;\n\tconst struct prt_quirk *quirk;\n\n\tfor (i = 0; i < ARRAY_SIZE(prt_quirks); i++) {\n\t\tquirk = &prt_quirks[i];\n\n\t\t \n\t\tif (dmi_check_system(quirk->system) &&\n\t\t    entry->id.segment == quirk->segment &&\n\t\t    entry->id.bus == quirk->bus &&\n\t\t    entry->id.device == quirk->device &&\n\t\t    entry->pin == quirk->pin &&\n\t\t    !strcmp(prt->source, quirk->source) &&\n\t\t    strlen(prt->source) >= strlen(quirk->actual_source)) {\n\t\t\tpr_warn(\"Firmware reports \"\n\t\t\t\t\"%04x:%02x:%02x PCI INT %c connected to %s; \"\n\t\t\t\t\"changing to %s\\n\",\n\t\t\t\tentry->id.segment, entry->id.bus,\n\t\t\t\tentry->id.device, pin_name(entry->pin),\n\t\t\t\tprt->source, quirk->actual_source);\n\t\t\tstrcpy(prt->source, quirk->actual_source);\n\t\t}\n\t}\n}\n\nstatic int acpi_pci_irq_check_entry(acpi_handle handle, struct pci_dev *dev,\n\t\t\t\t  int pin, struct acpi_pci_routing_table *prt,\n\t\t\t\t  struct acpi_prt_entry **entry_ptr)\n{\n\tint segment = pci_domain_nr(dev->bus);\n\tint bus = dev->bus->number;\n\tint device = pci_ari_enabled(dev->bus) ? 0 : PCI_SLOT(dev->devfn);\n\tstruct acpi_prt_entry *entry;\n\n\tif (((prt->address >> 16) & 0xffff) != device ||\n\t    prt->pin + 1 != pin)\n\t\treturn -ENODEV;\n\n\tentry = kzalloc(sizeof(struct acpi_prt_entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\t \n\tentry->id.segment = segment;\n\tentry->id.bus = bus;\n\tentry->id.device = (prt->address >> 16) & 0xFFFF;\n\tentry->pin = prt->pin + 1;\n\n\tdo_prt_fixups(entry, prt);\n\n\tentry->index = prt->source_index;\n\n\t \n\tif (prt->source[0])\n\t\tacpi_get_handle(handle, prt->source, &entry->link);\n\n\t \n\tpr_debug(\"%04x:%02x:%02x[%c] -> %s[%d]\\n\",\n\t\t entry->id.segment, entry->id.bus, entry->id.device,\n\t\t pin_name(entry->pin), prt->source, entry->index);\n\n\t*entry_ptr = entry;\n\n\treturn 0;\n}\n\nstatic int acpi_pci_irq_find_prt_entry(struct pci_dev *dev,\n\t\t\t  int pin, struct acpi_prt_entry **entry_ptr)\n{\n\tacpi_status status;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_pci_routing_table *entry;\n\tacpi_handle handle = NULL;\n\n\tif (dev->bus->bridge)\n\t\thandle = ACPI_HANDLE(dev->bus->bridge);\n\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\t \n\tstatus = acpi_get_irq_routing_table(handle, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tkfree(buffer.pointer);\n\t\treturn -ENODEV;\n\t}\n\n\tentry = buffer.pointer;\n\twhile (entry && (entry->length > 0)) {\n\t\tif (!acpi_pci_irq_check_entry(handle, dev, pin,\n\t\t\t\t\t\t entry, entry_ptr))\n\t\t\tbreak;\n\t\tentry = (struct acpi_pci_routing_table *)\n\t\t    ((unsigned long)entry + entry->length);\n\t}\n\n\tkfree(buffer.pointer);\n\treturn 0;\n}\n\n \n#ifdef CONFIG_X86_IO_APIC\nextern int noioapicquirk;\nextern int noioapicreroute;\n\nstatic int bridge_has_boot_interrupt_variant(struct pci_bus *bus)\n{\n\tstruct pci_bus *bus_it;\n\n\tfor (bus_it = bus ; bus_it ; bus_it = bus_it->parent) {\n\t\tif (!bus_it->self)\n\t\t\treturn 0;\n\t\tif (bus_it->self->irq_reroute_variant)\n\t\t\treturn bus_it->self->irq_reroute_variant;\n\t}\n\treturn 0;\n}\n\n \nstatic int acpi_reroute_boot_interrupt(struct pci_dev *dev,\n\t\t\t\t       struct acpi_prt_entry *entry)\n{\n\tif (noioapicquirk || noioapicreroute) {\n\t\treturn 0;\n\t} else {\n\t\tswitch (bridge_has_boot_interrupt_variant(dev->bus)) {\n\t\tcase 0:\n\t\t\t \n\t\t\treturn 0;\n\t\tcase INTEL_IRQ_REROUTE_VARIANT:\n\t\t\t \n\t\t\tdev_info(&dev->dev, \"PCI IRQ %d -> rerouted to legacy \"\n\t\t\t\t \"IRQ %d\\n\", entry->index,\n\t\t\t\t (entry->index % 4) + 16);\n\t\t\tentry->index = (entry->index % 4) + 16;\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tdev_warn(&dev->dev, \"Cannot reroute IRQ %d to legacy \"\n\t\t\t\t \"IRQ: unknown mapping\\n\", entry->index);\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n#endif  \n\nstatic struct acpi_prt_entry *acpi_pci_irq_lookup(struct pci_dev *dev, int pin)\n{\n\tstruct acpi_prt_entry *entry = NULL;\n\tstruct pci_dev *bridge;\n\tu8 bridge_pin, orig_pin = pin;\n\tint ret;\n\n\tret = acpi_pci_irq_find_prt_entry(dev, pin, &entry);\n\tif (!ret && entry) {\n#ifdef CONFIG_X86_IO_APIC\n\t\tacpi_reroute_boot_interrupt(dev, entry);\n#endif  \n\t\tdev_dbg(&dev->dev, \"Found [%c] _PRT entry\\n\", pin_name(pin));\n\t\treturn entry;\n\t}\n\n\t \n\tbridge = dev->bus->self;\n\twhile (bridge) {\n\t\tpin = pci_swizzle_interrupt_pin(dev, pin);\n\n\t\tif ((bridge->class >> 8) == PCI_CLASS_BRIDGE_CARDBUS) {\n\t\t\t \n\t\t\tbridge_pin = bridge->pin;\n\t\t\tif (!bridge_pin) {\n\t\t\t\tdev_dbg(&bridge->dev, \"No interrupt pin configured\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tpin = bridge_pin;\n\t\t}\n\n\t\tret = acpi_pci_irq_find_prt_entry(bridge, pin, &entry);\n\t\tif (!ret && entry) {\n\t\t\tdev_dbg(&dev->dev, \"Derived GSI INT %c from %s\\n\",\n\t\t\t\tpin_name(orig_pin), pci_name(bridge));\n\t\t\treturn entry;\n\t\t}\n\n\t\tdev = bridge;\n\t\tbridge = dev->bus->self;\n\t}\n\n\tdev_warn(&dev->dev, \"can't derive routing for PCI INT %c\\n\",\n\t\t pin_name(orig_pin));\n\treturn NULL;\n}\n\n#if IS_ENABLED(CONFIG_ISA) || IS_ENABLED(CONFIG_EISA)\nstatic int acpi_isa_register_gsi(struct pci_dev *dev)\n{\n\tu32 dev_gsi;\n\n\t \n\tif (dev->irq > 0 && (dev->irq <= 0xF) &&\n\t    acpi_isa_irq_available(dev->irq) &&\n\t    (acpi_isa_irq_to_gsi(dev->irq, &dev_gsi) == 0)) {\n\t\tdev_warn(&dev->dev, \"PCI INT %c: no GSI - using ISA IRQ %d\\n\",\n\t\t\t pin_name(dev->pin), dev->irq);\n\t\tacpi_register_gsi(&dev->dev, dev_gsi,\n\t\t\t\t  ACPI_LEVEL_SENSITIVE,\n\t\t\t\t  ACPI_ACTIVE_LOW);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n#else\nstatic inline int acpi_isa_register_gsi(struct pci_dev *dev)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic inline bool acpi_pci_irq_valid(struct pci_dev *dev, u8 pin)\n{\n#ifdef CONFIG_X86\n\t \n\tif (dev->irq == 0xff) {\n\t\tdev->irq = IRQ_NOTCONNECTED;\n\t\tdev_warn(&dev->dev, \"PCI INT %c: not connected\\n\",\n\t\t\t pin_name(pin));\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}\n\nint acpi_pci_irq_enable(struct pci_dev *dev)\n{\n\tstruct acpi_prt_entry *entry;\n\tint gsi;\n\tu8 pin;\n\tint triggering = ACPI_LEVEL_SENSITIVE;\n\t \n\tint polarity = acpi_irq_model == ACPI_IRQ_MODEL_GIC ||\n\t\t       acpi_irq_model == ACPI_IRQ_MODEL_LPIC ?\n\t\t\t\t      ACPI_ACTIVE_HIGH : ACPI_ACTIVE_LOW;\n\tchar *link = NULL;\n\tchar link_desc[16];\n\tint rc;\n\n\tpin = dev->pin;\n\tif (!pin) {\n\t\tdev_dbg(&dev->dev, \"No interrupt pin configured\\n\");\n\t\treturn 0;\n\t}\n\n\tif (dev->irq_managed && dev->irq > 0)\n\t\treturn 0;\n\n\tentry = acpi_pci_irq_lookup(dev, pin);\n\tif (!entry) {\n\t\t \n\t\tif (dev->class >> 8 == PCI_CLASS_STORAGE_IDE &&\n\t\t\t\t(dev->class & 0x05) == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (entry) {\n\t\tif (entry->link)\n\t\t\tgsi = acpi_pci_link_allocate_irq(entry->link,\n\t\t\t\t\t\t\t entry->index,\n\t\t\t\t\t\t\t &triggering, &polarity,\n\t\t\t\t\t\t\t &link);\n\t\telse\n\t\t\tgsi = entry->index;\n\t} else\n\t\tgsi = -1;\n\n\tif (gsi < 0) {\n\t\t \n\t\tif (!acpi_pci_irq_valid(dev, pin)) {\n\t\t\tkfree(entry);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (acpi_isa_register_gsi(dev))\n\t\t\tdev_warn(&dev->dev, \"PCI INT %c: no GSI\\n\",\n\t\t\t\t pin_name(pin));\n\n\t\tkfree(entry);\n\t\treturn 0;\n\t}\n\n\trc = acpi_register_gsi(&dev->dev, gsi, triggering, polarity);\n\tif (rc < 0) {\n\t\tdev_warn(&dev->dev, \"PCI INT %c: failed to register GSI\\n\",\n\t\t\t pin_name(pin));\n\t\tkfree(entry);\n\t\treturn rc;\n\t}\n\tdev->irq = rc;\n\tdev->irq_managed = 1;\n\n\tif (link)\n\t\tsnprintf(link_desc, sizeof(link_desc), \" -> Link[%s]\", link);\n\telse\n\t\tlink_desc[0] = '\\0';\n\n\tdev_dbg(&dev->dev, \"PCI INT %c%s -> GSI %u (%s, %s) -> IRQ %d\\n\",\n\t\tpin_name(pin), link_desc, gsi,\n\t\t(triggering == ACPI_LEVEL_SENSITIVE) ? \"level\" : \"edge\",\n\t\t(polarity == ACPI_ACTIVE_LOW) ? \"low\" : \"high\", dev->irq);\n\n\tkfree(entry);\n\treturn 0;\n}\n\nvoid acpi_pci_irq_disable(struct pci_dev *dev)\n{\n\tstruct acpi_prt_entry *entry;\n\tint gsi;\n\tu8 pin;\n\n\tpin = dev->pin;\n\tif (!pin || !dev->irq_managed || dev->irq <= 0)\n\t\treturn;\n\n\t \n\tif (dev->dev.power.is_prepared)\n\t\treturn;\n#ifdef\tCONFIG_PM\n\tif (dev->dev.power.runtime_status == RPM_SUSPENDING)\n\t\treturn;\n#endif\n\n\tentry = acpi_pci_irq_lookup(dev, pin);\n\tif (!entry)\n\t\treturn;\n\n\tif (entry->link)\n\t\tgsi = acpi_pci_link_free_irq(entry->link);\n\telse\n\t\tgsi = entry->index;\n\n\tkfree(entry);\n\n\t \n\n\tdev_dbg(&dev->dev, \"PCI INT %c disabled\\n\", pin_name(pin));\n\tif (gsi >= 0) {\n\t\tacpi_unregister_gsi(gsi);\n\t\tdev->irq_managed = 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}