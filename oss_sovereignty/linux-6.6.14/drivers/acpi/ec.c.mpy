{
  "module_name": "ec.c",
  "hash_id": "ad4fa82f685e9116c0cf6acc8dc513ae7fd6534c77634a4dfc3e53bbda68611a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/ec.c",
  "human_readable_source": "\n \n\n \n \n#define pr_fmt(fmt) \"ACPI: EC: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <asm/io.h>\n\n#include \"internal.h\"\n\n#define ACPI_EC_CLASS\t\t\t\"embedded_controller\"\n#define ACPI_EC_DEVICE_NAME\t\t\"Embedded Controller\"\n\n \n#define ACPI_EC_FLAG_OBF\t0x01\t \n#define ACPI_EC_FLAG_IBF\t0x02\t \n#define ACPI_EC_FLAG_CMD\t0x08\t \n#define ACPI_EC_FLAG_BURST\t0x10\t \n#define ACPI_EC_FLAG_SCI\t0x20\t \n\n \n#define ACPI_EC_EVT_TIMING_STATUS\t0x00\n#define ACPI_EC_EVT_TIMING_QUERY\t0x01\n#define ACPI_EC_EVT_TIMING_EVENT\t0x02\n\n \nenum ec_command {\n\tACPI_EC_COMMAND_READ = 0x80,\n\tACPI_EC_COMMAND_WRITE = 0x81,\n\tACPI_EC_BURST_ENABLE = 0x82,\n\tACPI_EC_BURST_DISABLE = 0x83,\n\tACPI_EC_COMMAND_QUERY = 0x84,\n};\n\n#define ACPI_EC_DELAY\t\t500\t \n#define ACPI_EC_UDELAY_GLK\t1000\t \n#define ACPI_EC_UDELAY_POLL\t550\t \n#define ACPI_EC_CLEAR_MAX\t100\t \n#define ACPI_EC_MAX_QUERIES\t16\t \n\nenum {\n\tEC_FLAGS_QUERY_ENABLED,\t\t \n\tEC_FLAGS_EVENT_HANDLER_INSTALLED,\t \n\tEC_FLAGS_EC_HANDLER_INSTALLED,\t \n\tEC_FLAGS_EC_REG_CALLED,\t\t \n\tEC_FLAGS_QUERY_METHODS_INSTALLED,  \n\tEC_FLAGS_STARTED,\t\t \n\tEC_FLAGS_STOPPED,\t\t \n\tEC_FLAGS_EVENTS_MASKED,\t\t \n};\n\n#define ACPI_EC_COMMAND_POLL\t\t0x01  \n#define ACPI_EC_COMMAND_COMPLETE\t0x02  \n\n \nstatic unsigned int ec_delay __read_mostly = ACPI_EC_DELAY;\nmodule_param(ec_delay, uint, 0644);\nMODULE_PARM_DESC(ec_delay, \"Timeout(ms) waited until an EC command completes\");\n\nstatic unsigned int ec_max_queries __read_mostly = ACPI_EC_MAX_QUERIES;\nmodule_param(ec_max_queries, uint, 0644);\nMODULE_PARM_DESC(ec_max_queries, \"Maximum parallel _Qxx evaluations\");\n\nstatic bool ec_busy_polling __read_mostly;\nmodule_param(ec_busy_polling, bool, 0644);\nMODULE_PARM_DESC(ec_busy_polling, \"Use busy polling to advance EC transaction\");\n\nstatic unsigned int ec_polling_guard __read_mostly = ACPI_EC_UDELAY_POLL;\nmodule_param(ec_polling_guard, uint, 0644);\nMODULE_PARM_DESC(ec_polling_guard, \"Guard time(us) between EC accesses in polling modes\");\n\nstatic unsigned int ec_event_clearing __read_mostly = ACPI_EC_EVT_TIMING_QUERY;\n\n \nstatic unsigned int ec_storm_threshold  __read_mostly = 8;\nmodule_param(ec_storm_threshold, uint, 0644);\nMODULE_PARM_DESC(ec_storm_threshold, \"Maxim false GPE numbers not considered as GPE storm\");\n\nstatic bool ec_freeze_events __read_mostly;\nmodule_param(ec_freeze_events, bool, 0644);\nMODULE_PARM_DESC(ec_freeze_events, \"Disabling event handling during suspend/resume\");\n\nstatic bool ec_no_wakeup __read_mostly;\nmodule_param(ec_no_wakeup, bool, 0644);\nMODULE_PARM_DESC(ec_no_wakeup, \"Do not wake up from suspend-to-idle\");\n\nstruct acpi_ec_query_handler {\n\tstruct list_head node;\n\tacpi_ec_query_func func;\n\tacpi_handle handle;\n\tvoid *data;\n\tu8 query_bit;\n\tstruct kref kref;\n};\n\nstruct transaction {\n\tconst u8 *wdata;\n\tu8 *rdata;\n\tunsigned short irq_count;\n\tu8 command;\n\tu8 wi;\n\tu8 ri;\n\tu8 wlen;\n\tu8 rlen;\n\tu8 flags;\n};\n\nstruct acpi_ec_query {\n\tstruct transaction transaction;\n\tstruct work_struct work;\n\tstruct acpi_ec_query_handler *handler;\n\tstruct acpi_ec *ec;\n};\n\nstatic int acpi_ec_submit_query(struct acpi_ec *ec);\nstatic void advance_transaction(struct acpi_ec *ec, bool interrupt);\nstatic void acpi_ec_event_handler(struct work_struct *work);\n\nstruct acpi_ec *first_ec;\nEXPORT_SYMBOL(first_ec);\n\nstatic struct acpi_ec *boot_ec;\nstatic bool boot_ec_is_ecdt;\nstatic struct workqueue_struct *ec_wq;\nstatic struct workqueue_struct *ec_query_wq;\n\nstatic int EC_FLAGS_CORRECT_ECDT;  \nstatic int EC_FLAGS_TRUST_DSDT_GPE;  \nstatic int EC_FLAGS_CLEAR_ON_RESUME;  \n\n \n\n \n#ifdef DEBUG\n#define EC_DBG_SEP\t\" \"\n#define EC_DBG_DRV\t\"+++++\"\n#define EC_DBG_STM\t\"=====\"\n#define EC_DBG_REQ\t\"*****\"\n#define EC_DBG_EVT\t\"#####\"\n#else\n#define EC_DBG_SEP\t\"\"\n#define EC_DBG_DRV\n#define EC_DBG_STM\n#define EC_DBG_REQ\n#define EC_DBG_EVT\n#endif\n\n#define ec_log_raw(fmt, ...) \\\n\tpr_info(fmt \"\\n\", ##__VA_ARGS__)\n#define ec_dbg_raw(fmt, ...) \\\n\tpr_debug(fmt \"\\n\", ##__VA_ARGS__)\n#define ec_log(filter, fmt, ...) \\\n\tec_log_raw(filter EC_DBG_SEP fmt EC_DBG_SEP filter, ##__VA_ARGS__)\n#define ec_dbg(filter, fmt, ...) \\\n\tec_dbg_raw(filter EC_DBG_SEP fmt EC_DBG_SEP filter, ##__VA_ARGS__)\n\n#define ec_log_drv(fmt, ...) \\\n\tec_log(EC_DBG_DRV, fmt, ##__VA_ARGS__)\n#define ec_dbg_drv(fmt, ...) \\\n\tec_dbg(EC_DBG_DRV, fmt, ##__VA_ARGS__)\n#define ec_dbg_stm(fmt, ...) \\\n\tec_dbg(EC_DBG_STM, fmt, ##__VA_ARGS__)\n#define ec_dbg_req(fmt, ...) \\\n\tec_dbg(EC_DBG_REQ, fmt, ##__VA_ARGS__)\n#define ec_dbg_evt(fmt, ...) \\\n\tec_dbg(EC_DBG_EVT, fmt, ##__VA_ARGS__)\n#define ec_dbg_ref(ec, fmt, ...) \\\n\tec_dbg_raw(\"%lu: \" fmt, ec->reference_count, ## __VA_ARGS__)\n\n \n\nstatic bool acpi_ec_started(struct acpi_ec *ec)\n{\n\treturn test_bit(EC_FLAGS_STARTED, &ec->flags) &&\n\t       !test_bit(EC_FLAGS_STOPPED, &ec->flags);\n}\n\nstatic bool acpi_ec_event_enabled(struct acpi_ec *ec)\n{\n\t \n\tif (!test_bit(EC_FLAGS_QUERY_ENABLED, &ec->flags))\n\t\treturn false;\n\t \n\tif (ec_freeze_events)\n\t\treturn acpi_ec_started(ec);\n\telse\n\t\treturn test_bit(EC_FLAGS_STARTED, &ec->flags);\n}\n\nstatic bool acpi_ec_flushed(struct acpi_ec *ec)\n{\n\treturn ec->reference_count == 1;\n}\n\n \n\nstatic inline u8 acpi_ec_read_status(struct acpi_ec *ec)\n{\n\tu8 x = inb(ec->command_addr);\n\n\tec_dbg_raw(\"EC_SC(R) = 0x%2.2x \"\n\t\t   \"SCI_EVT=%d BURST=%d CMD=%d IBF=%d OBF=%d\",\n\t\t   x,\n\t\t   !!(x & ACPI_EC_FLAG_SCI),\n\t\t   !!(x & ACPI_EC_FLAG_BURST),\n\t\t   !!(x & ACPI_EC_FLAG_CMD),\n\t\t   !!(x & ACPI_EC_FLAG_IBF),\n\t\t   !!(x & ACPI_EC_FLAG_OBF));\n\treturn x;\n}\n\nstatic inline u8 acpi_ec_read_data(struct acpi_ec *ec)\n{\n\tu8 x = inb(ec->data_addr);\n\n\tec->timestamp = jiffies;\n\tec_dbg_raw(\"EC_DATA(R) = 0x%2.2x\", x);\n\treturn x;\n}\n\nstatic inline void acpi_ec_write_cmd(struct acpi_ec *ec, u8 command)\n{\n\tec_dbg_raw(\"EC_SC(W) = 0x%2.2x\", command);\n\toutb(command, ec->command_addr);\n\tec->timestamp = jiffies;\n}\n\nstatic inline void acpi_ec_write_data(struct acpi_ec *ec, u8 data)\n{\n\tec_dbg_raw(\"EC_DATA(W) = 0x%2.2x\", data);\n\toutb(data, ec->data_addr);\n\tec->timestamp = jiffies;\n}\n\n#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)\nstatic const char *acpi_ec_cmd_string(u8 cmd)\n{\n\tswitch (cmd) {\n\tcase 0x80:\n\t\treturn \"RD_EC\";\n\tcase 0x81:\n\t\treturn \"WR_EC\";\n\tcase 0x82:\n\t\treturn \"BE_EC\";\n\tcase 0x83:\n\t\treturn \"BD_EC\";\n\tcase 0x84:\n\t\treturn \"QR_EC\";\n\t}\n\treturn \"UNKNOWN\";\n}\n#else\n#define acpi_ec_cmd_string(cmd)\t\t\"UNDEF\"\n#endif\n\n \n\nstatic inline bool acpi_ec_gpe_status_set(struct acpi_ec *ec)\n{\n\tacpi_event_status gpe_status = 0;\n\n\t(void)acpi_get_gpe_status(NULL, ec->gpe, &gpe_status);\n\treturn !!(gpe_status & ACPI_EVENT_FLAG_STATUS_SET);\n}\n\nstatic inline void acpi_ec_enable_gpe(struct acpi_ec *ec, bool open)\n{\n\tif (open)\n\t\tacpi_enable_gpe(NULL, ec->gpe);\n\telse {\n\t\tBUG_ON(ec->reference_count < 1);\n\t\tacpi_set_gpe(NULL, ec->gpe, ACPI_GPE_ENABLE);\n\t}\n\tif (acpi_ec_gpe_status_set(ec)) {\n\t\t \n\t\tec_dbg_raw(\"Polling quirk\");\n\t\tadvance_transaction(ec, false);\n\t}\n}\n\nstatic inline void acpi_ec_disable_gpe(struct acpi_ec *ec, bool close)\n{\n\tif (close)\n\t\tacpi_disable_gpe(NULL, ec->gpe);\n\telse {\n\t\tBUG_ON(ec->reference_count < 1);\n\t\tacpi_set_gpe(NULL, ec->gpe, ACPI_GPE_DISABLE);\n\t}\n}\n\n \n\nstatic void acpi_ec_submit_request(struct acpi_ec *ec)\n{\n\tec->reference_count++;\n\tif (test_bit(EC_FLAGS_EVENT_HANDLER_INSTALLED, &ec->flags) &&\n\t    ec->gpe >= 0 && ec->reference_count == 1)\n\t\tacpi_ec_enable_gpe(ec, true);\n}\n\nstatic void acpi_ec_complete_request(struct acpi_ec *ec)\n{\n\tbool flushed = false;\n\n\tec->reference_count--;\n\tif (test_bit(EC_FLAGS_EVENT_HANDLER_INSTALLED, &ec->flags) &&\n\t    ec->gpe >= 0 && ec->reference_count == 0)\n\t\tacpi_ec_disable_gpe(ec, true);\n\tflushed = acpi_ec_flushed(ec);\n\tif (flushed)\n\t\twake_up(&ec->wait);\n}\n\nstatic void acpi_ec_mask_events(struct acpi_ec *ec)\n{\n\tif (!test_bit(EC_FLAGS_EVENTS_MASKED, &ec->flags)) {\n\t\tif (ec->gpe >= 0)\n\t\t\tacpi_ec_disable_gpe(ec, false);\n\t\telse\n\t\t\tdisable_irq_nosync(ec->irq);\n\n\t\tec_dbg_drv(\"Polling enabled\");\n\t\tset_bit(EC_FLAGS_EVENTS_MASKED, &ec->flags);\n\t}\n}\n\nstatic void acpi_ec_unmask_events(struct acpi_ec *ec)\n{\n\tif (test_bit(EC_FLAGS_EVENTS_MASKED, &ec->flags)) {\n\t\tclear_bit(EC_FLAGS_EVENTS_MASKED, &ec->flags);\n\t\tif (ec->gpe >= 0)\n\t\t\tacpi_ec_enable_gpe(ec, false);\n\t\telse\n\t\t\tenable_irq(ec->irq);\n\n\t\tec_dbg_drv(\"Polling disabled\");\n\t}\n}\n\n \nstatic bool acpi_ec_submit_flushable_request(struct acpi_ec *ec)\n{\n\tif (!acpi_ec_started(ec))\n\t\treturn false;\n\tacpi_ec_submit_request(ec);\n\treturn true;\n}\n\nstatic void acpi_ec_submit_event(struct acpi_ec *ec)\n{\n\t \n\tacpi_ec_mask_events(ec);\n\tif (!acpi_ec_event_enabled(ec))\n\t\treturn;\n\n\tif (ec->event_state != EC_EVENT_READY)\n\t\treturn;\n\n\tec_dbg_evt(\"Command(%s) submitted/blocked\",\n\t\t   acpi_ec_cmd_string(ACPI_EC_COMMAND_QUERY));\n\n\tec->event_state = EC_EVENT_IN_PROGRESS;\n\t \n\tif (ec->events_to_process++ > 0)\n\t\treturn;\n\n\tec->events_in_progress++;\n\tqueue_work(ec_wq, &ec->work);\n}\n\nstatic void acpi_ec_complete_event(struct acpi_ec *ec)\n{\n\tif (ec->event_state == EC_EVENT_IN_PROGRESS)\n\t\tec->event_state = EC_EVENT_COMPLETE;\n}\n\nstatic void acpi_ec_close_event(struct acpi_ec *ec)\n{\n\tif (ec->event_state != EC_EVENT_READY)\n\t\tec_dbg_evt(\"Command(%s) unblocked\",\n\t\t\t   acpi_ec_cmd_string(ACPI_EC_COMMAND_QUERY));\n\n\tec->event_state = EC_EVENT_READY;\n\tacpi_ec_unmask_events(ec);\n}\n\nstatic inline void __acpi_ec_enable_event(struct acpi_ec *ec)\n{\n\tif (!test_and_set_bit(EC_FLAGS_QUERY_ENABLED, &ec->flags))\n\t\tec_log_drv(\"event unblocked\");\n\t \n\tadvance_transaction(ec, false);\n}\n\nstatic inline void __acpi_ec_disable_event(struct acpi_ec *ec)\n{\n\tif (test_and_clear_bit(EC_FLAGS_QUERY_ENABLED, &ec->flags))\n\t\tec_log_drv(\"event blocked\");\n}\n\n \nstatic void acpi_ec_clear(struct acpi_ec *ec)\n{\n\tint i;\n\n\tfor (i = 0; i < ACPI_EC_CLEAR_MAX; i++) {\n\t\tif (acpi_ec_submit_query(ec))\n\t\t\tbreak;\n\t}\n\tif (unlikely(i == ACPI_EC_CLEAR_MAX))\n\t\tpr_warn(\"Warning: Maximum of %d stale EC events cleared\\n\", i);\n\telse\n\t\tpr_info(\"%d stale EC events cleared\\n\", i);\n}\n\nstatic void acpi_ec_enable_event(struct acpi_ec *ec)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ec->lock, flags);\n\tif (acpi_ec_started(ec))\n\t\t__acpi_ec_enable_event(ec);\n\tspin_unlock_irqrestore(&ec->lock, flags);\n\n\t \n\tif (EC_FLAGS_CLEAR_ON_RESUME)\n\t\tacpi_ec_clear(ec);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void __acpi_ec_flush_work(void)\n{\n\tflush_workqueue(ec_wq);  \n\tflush_workqueue(ec_query_wq);  \n}\n\nstatic void acpi_ec_disable_event(struct acpi_ec *ec)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ec->lock, flags);\n\t__acpi_ec_disable_event(ec);\n\tspin_unlock_irqrestore(&ec->lock, flags);\n\n\t \n\t__acpi_ec_flush_work();\n}\n\nvoid acpi_ec_flush_work(void)\n{\n\t \n\tif (!ec_wq)\n\t\treturn;\n\n\t__acpi_ec_flush_work();\n}\n#endif  \n\nstatic bool acpi_ec_guard_event(struct acpi_ec *ec)\n{\n\tunsigned long flags;\n\tbool guarded;\n\n\tspin_lock_irqsave(&ec->lock, flags);\n\t \n\tguarded = ec_event_clearing == ACPI_EC_EVT_TIMING_EVENT &&\n\t\tec->event_state != EC_EVENT_READY &&\n\t\t(!ec->curr || ec->curr->command != ACPI_EC_COMMAND_QUERY);\n\tspin_unlock_irqrestore(&ec->lock, flags);\n\treturn guarded;\n}\n\nstatic int ec_transaction_polled(struct acpi_ec *ec)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&ec->lock, flags);\n\tif (ec->curr && (ec->curr->flags & ACPI_EC_COMMAND_POLL))\n\t\tret = 1;\n\tspin_unlock_irqrestore(&ec->lock, flags);\n\treturn ret;\n}\n\nstatic int ec_transaction_completed(struct acpi_ec *ec)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&ec->lock, flags);\n\tif (ec->curr && (ec->curr->flags & ACPI_EC_COMMAND_COMPLETE))\n\t\tret = 1;\n\tspin_unlock_irqrestore(&ec->lock, flags);\n\treturn ret;\n}\n\nstatic inline void ec_transaction_transition(struct acpi_ec *ec, unsigned long flag)\n{\n\tec->curr->flags |= flag;\n\n\tif (ec->curr->command != ACPI_EC_COMMAND_QUERY)\n\t\treturn;\n\n\tswitch (ec_event_clearing) {\n\tcase ACPI_EC_EVT_TIMING_STATUS:\n\t\tif (flag == ACPI_EC_COMMAND_POLL)\n\t\t\tacpi_ec_close_event(ec);\n\n\t\treturn;\n\n\tcase ACPI_EC_EVT_TIMING_QUERY:\n\t\tif (flag == ACPI_EC_COMMAND_COMPLETE)\n\t\t\tacpi_ec_close_event(ec);\n\n\t\treturn;\n\n\tcase ACPI_EC_EVT_TIMING_EVENT:\n\t\tif (flag == ACPI_EC_COMMAND_COMPLETE)\n\t\t\tacpi_ec_complete_event(ec);\n\t}\n}\n\nstatic void acpi_ec_spurious_interrupt(struct acpi_ec *ec, struct transaction *t)\n{\n\tif (t->irq_count < ec_storm_threshold)\n\t\t++t->irq_count;\n\n\t \n\tif (t->irq_count == ec_storm_threshold)\n\t\tacpi_ec_mask_events(ec);\n}\n\nstatic void advance_transaction(struct acpi_ec *ec, bool interrupt)\n{\n\tstruct transaction *t = ec->curr;\n\tbool wakeup = false;\n\tu8 status;\n\n\tec_dbg_stm(\"%s (%d)\", interrupt ? \"IRQ\" : \"TASK\", smp_processor_id());\n\n\tstatus = acpi_ec_read_status(ec);\n\n\t \n\tif (!t || !(t->flags & ACPI_EC_COMMAND_POLL)) {\n\t\tif (ec_event_clearing == ACPI_EC_EVT_TIMING_EVENT &&\n\t\t    ec->event_state == EC_EVENT_COMPLETE)\n\t\t\tacpi_ec_close_event(ec);\n\n\t\tif (!t)\n\t\t\tgoto out;\n\t}\n\n\tif (t->flags & ACPI_EC_COMMAND_POLL) {\n\t\tif (t->wlen > t->wi) {\n\t\t\tif (!(status & ACPI_EC_FLAG_IBF))\n\t\t\t\tacpi_ec_write_data(ec, t->wdata[t->wi++]);\n\t\t\telse if (interrupt && !(status & ACPI_EC_FLAG_SCI))\n\t\t\t\tacpi_ec_spurious_interrupt(ec, t);\n\t\t} else if (t->rlen > t->ri) {\n\t\t\tif (status & ACPI_EC_FLAG_OBF) {\n\t\t\t\tt->rdata[t->ri++] = acpi_ec_read_data(ec);\n\t\t\t\tif (t->rlen == t->ri) {\n\t\t\t\t\tec_transaction_transition(ec, ACPI_EC_COMMAND_COMPLETE);\n\t\t\t\t\twakeup = true;\n\t\t\t\t\tif (t->command == ACPI_EC_COMMAND_QUERY)\n\t\t\t\t\t\tec_dbg_evt(\"Command(%s) completed by hardware\",\n\t\t\t\t\t\t\t   acpi_ec_cmd_string(ACPI_EC_COMMAND_QUERY));\n\t\t\t\t}\n\t\t\t} else if (interrupt && !(status & ACPI_EC_FLAG_SCI)) {\n\t\t\t\tacpi_ec_spurious_interrupt(ec, t);\n\t\t\t}\n\t\t} else if (t->wlen == t->wi && !(status & ACPI_EC_FLAG_IBF)) {\n\t\t\tec_transaction_transition(ec, ACPI_EC_COMMAND_COMPLETE);\n\t\t\twakeup = true;\n\t\t}\n\t} else if (!(status & ACPI_EC_FLAG_IBF)) {\n\t\tacpi_ec_write_cmd(ec, t->command);\n\t\tec_transaction_transition(ec, ACPI_EC_COMMAND_POLL);\n\t}\n\nout:\n\tif (status & ACPI_EC_FLAG_SCI)\n\t\tacpi_ec_submit_event(ec);\n\n\tif (wakeup && interrupt)\n\t\twake_up(&ec->wait);\n}\n\nstatic void start_transaction(struct acpi_ec *ec)\n{\n\tec->curr->irq_count = ec->curr->wi = ec->curr->ri = 0;\n\tec->curr->flags = 0;\n}\n\nstatic int ec_guard(struct acpi_ec *ec)\n{\n\tunsigned long guard = usecs_to_jiffies(ec->polling_guard);\n\tunsigned long timeout = ec->timestamp + guard;\n\n\t \n\tdo {\n\t\tif (ec->busy_polling) {\n\t\t\t \n\t\t\tif (ec_transaction_completed(ec))\n\t\t\t\treturn 0;\n\t\t\tudelay(jiffies_to_usecs(guard));\n\t\t} else {\n\t\t\t \n\t\t\tif (!ec_transaction_polled(ec) &&\n\t\t\t    !acpi_ec_guard_event(ec))\n\t\t\t\tbreak;\n\t\t\tif (wait_event_timeout(ec->wait,\n\t\t\t\t\t       ec_transaction_completed(ec),\n\t\t\t\t\t       guard))\n\t\t\t\treturn 0;\n\t\t}\n\t} while (time_before(jiffies, timeout));\n\treturn -ETIME;\n}\n\nstatic int ec_poll(struct acpi_ec *ec)\n{\n\tunsigned long flags;\n\tint repeat = 5;  \n\n\twhile (repeat--) {\n\t\tunsigned long delay = jiffies +\n\t\t\tmsecs_to_jiffies(ec_delay);\n\t\tdo {\n\t\t\tif (!ec_guard(ec))\n\t\t\t\treturn 0;\n\t\t\tspin_lock_irqsave(&ec->lock, flags);\n\t\t\tadvance_transaction(ec, false);\n\t\t\tspin_unlock_irqrestore(&ec->lock, flags);\n\t\t} while (time_before(jiffies, delay));\n\t\tpr_debug(\"controller reset, restart transaction\\n\");\n\t\tspin_lock_irqsave(&ec->lock, flags);\n\t\tstart_transaction(ec);\n\t\tspin_unlock_irqrestore(&ec->lock, flags);\n\t}\n\treturn -ETIME;\n}\n\nstatic int acpi_ec_transaction_unlocked(struct acpi_ec *ec,\n\t\t\t\t\tstruct transaction *t)\n{\n\tunsigned long tmp;\n\tint ret = 0;\n\n\t \n\tspin_lock_irqsave(&ec->lock, tmp);\n\t \n\tif (!acpi_ec_submit_flushable_request(ec)) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\tec_dbg_ref(ec, \"Increase command\");\n\t \n\tec->curr = t;\n\tec_dbg_req(\"Command(%s) started\", acpi_ec_cmd_string(t->command));\n\tstart_transaction(ec);\n\tspin_unlock_irqrestore(&ec->lock, tmp);\n\n\tret = ec_poll(ec);\n\n\tspin_lock_irqsave(&ec->lock, tmp);\n\tif (t->irq_count == ec_storm_threshold)\n\t\tacpi_ec_unmask_events(ec);\n\tec_dbg_req(\"Command(%s) stopped\", acpi_ec_cmd_string(t->command));\n\tec->curr = NULL;\n\t \n\tacpi_ec_complete_request(ec);\n\tec_dbg_ref(ec, \"Decrease command\");\nunlock:\n\tspin_unlock_irqrestore(&ec->lock, tmp);\n\treturn ret;\n}\n\nstatic int acpi_ec_transaction(struct acpi_ec *ec, struct transaction *t)\n{\n\tint status;\n\tu32 glk;\n\n\tif (!ec || (!t) || (t->wlen && !t->wdata) || (t->rlen && !t->rdata))\n\t\treturn -EINVAL;\n\tif (t->rdata)\n\t\tmemset(t->rdata, 0, t->rlen);\n\n\tmutex_lock(&ec->mutex);\n\tif (ec->global_lock) {\n\t\tstatus = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tstatus = acpi_ec_transaction_unlocked(ec, t);\n\n\tif (ec->global_lock)\n\t\tacpi_release_global_lock(glk);\nunlock:\n\tmutex_unlock(&ec->mutex);\n\treturn status;\n}\n\nstatic int acpi_ec_burst_enable(struct acpi_ec *ec)\n{\n\tu8 d;\n\tstruct transaction t = {.command = ACPI_EC_BURST_ENABLE,\n\t\t\t\t.wdata = NULL, .rdata = &d,\n\t\t\t\t.wlen = 0, .rlen = 1};\n\n\treturn acpi_ec_transaction(ec, &t);\n}\n\nstatic int acpi_ec_burst_disable(struct acpi_ec *ec)\n{\n\tstruct transaction t = {.command = ACPI_EC_BURST_DISABLE,\n\t\t\t\t.wdata = NULL, .rdata = NULL,\n\t\t\t\t.wlen = 0, .rlen = 0};\n\n\treturn (acpi_ec_read_status(ec) & ACPI_EC_FLAG_BURST) ?\n\t\t\t\tacpi_ec_transaction(ec, &t) : 0;\n}\n\nstatic int acpi_ec_read(struct acpi_ec *ec, u8 address, u8 *data)\n{\n\tint result;\n\tu8 d;\n\tstruct transaction t = {.command = ACPI_EC_COMMAND_READ,\n\t\t\t\t.wdata = &address, .rdata = &d,\n\t\t\t\t.wlen = 1, .rlen = 1};\n\n\tresult = acpi_ec_transaction(ec, &t);\n\t*data = d;\n\treturn result;\n}\n\nstatic int acpi_ec_write(struct acpi_ec *ec, u8 address, u8 data)\n{\n\tu8 wdata[2] = { address, data };\n\tstruct transaction t = {.command = ACPI_EC_COMMAND_WRITE,\n\t\t\t\t.wdata = wdata, .rdata = NULL,\n\t\t\t\t.wlen = 2, .rlen = 0};\n\n\treturn acpi_ec_transaction(ec, &t);\n}\n\nint ec_read(u8 addr, u8 *val)\n{\n\tint err;\n\tu8 temp_data;\n\n\tif (!first_ec)\n\t\treturn -ENODEV;\n\n\terr = acpi_ec_read(first_ec, addr, &temp_data);\n\n\tif (!err) {\n\t\t*val = temp_data;\n\t\treturn 0;\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL(ec_read);\n\nint ec_write(u8 addr, u8 val)\n{\n\tif (!first_ec)\n\t\treturn -ENODEV;\n\n\treturn acpi_ec_write(first_ec, addr, val);\n}\nEXPORT_SYMBOL(ec_write);\n\nint ec_transaction(u8 command,\n\t\t   const u8 *wdata, unsigned wdata_len,\n\t\t   u8 *rdata, unsigned rdata_len)\n{\n\tstruct transaction t = {.command = command,\n\t\t\t\t.wdata = wdata, .rdata = rdata,\n\t\t\t\t.wlen = wdata_len, .rlen = rdata_len};\n\n\tif (!first_ec)\n\t\treturn -ENODEV;\n\n\treturn acpi_ec_transaction(first_ec, &t);\n}\nEXPORT_SYMBOL(ec_transaction);\n\n \nacpi_handle ec_get_handle(void)\n{\n\tif (!first_ec)\n\t\treturn NULL;\n\treturn first_ec->handle;\n}\nEXPORT_SYMBOL(ec_get_handle);\n\nstatic void acpi_ec_start(struct acpi_ec *ec, bool resuming)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ec->lock, flags);\n\tif (!test_and_set_bit(EC_FLAGS_STARTED, &ec->flags)) {\n\t\tec_dbg_drv(\"Starting EC\");\n\t\t \n\t\tif (!resuming) {\n\t\t\tacpi_ec_submit_request(ec);\n\t\t\tec_dbg_ref(ec, \"Increase driver\");\n\t\t}\n\t\tec_log_drv(\"EC started\");\n\t}\n\tspin_unlock_irqrestore(&ec->lock, flags);\n}\n\nstatic bool acpi_ec_stopped(struct acpi_ec *ec)\n{\n\tunsigned long flags;\n\tbool flushed;\n\n\tspin_lock_irqsave(&ec->lock, flags);\n\tflushed = acpi_ec_flushed(ec);\n\tspin_unlock_irqrestore(&ec->lock, flags);\n\treturn flushed;\n}\n\nstatic void acpi_ec_stop(struct acpi_ec *ec, bool suspending)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ec->lock, flags);\n\tif (acpi_ec_started(ec)) {\n\t\tec_dbg_drv(\"Stopping EC\");\n\t\tset_bit(EC_FLAGS_STOPPED, &ec->flags);\n\t\tspin_unlock_irqrestore(&ec->lock, flags);\n\t\twait_event(ec->wait, acpi_ec_stopped(ec));\n\t\tspin_lock_irqsave(&ec->lock, flags);\n\t\t \n\t\tif (!suspending) {\n\t\t\tacpi_ec_complete_request(ec);\n\t\t\tec_dbg_ref(ec, \"Decrease driver\");\n\t\t} else if (!ec_freeze_events)\n\t\t\t__acpi_ec_disable_event(ec);\n\t\tclear_bit(EC_FLAGS_STARTED, &ec->flags);\n\t\tclear_bit(EC_FLAGS_STOPPED, &ec->flags);\n\t\tec_log_drv(\"EC stopped\");\n\t}\n\tspin_unlock_irqrestore(&ec->lock, flags);\n}\n\nstatic void acpi_ec_enter_noirq(struct acpi_ec *ec)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ec->lock, flags);\n\tec->busy_polling = true;\n\tec->polling_guard = 0;\n\tec_log_drv(\"interrupt blocked\");\n\tspin_unlock_irqrestore(&ec->lock, flags);\n}\n\nstatic void acpi_ec_leave_noirq(struct acpi_ec *ec)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ec->lock, flags);\n\tec->busy_polling = ec_busy_polling;\n\tec->polling_guard = ec_polling_guard;\n\tec_log_drv(\"interrupt unblocked\");\n\tspin_unlock_irqrestore(&ec->lock, flags);\n}\n\nvoid acpi_ec_block_transactions(void)\n{\n\tstruct acpi_ec *ec = first_ec;\n\n\tif (!ec)\n\t\treturn;\n\n\tmutex_lock(&ec->mutex);\n\t \n\tacpi_ec_stop(ec, true);\n\tmutex_unlock(&ec->mutex);\n}\n\nvoid acpi_ec_unblock_transactions(void)\n{\n\t \n\tif (first_ec)\n\t\tacpi_ec_start(first_ec, true);\n}\n\n \nstatic struct acpi_ec_query_handler *\nacpi_ec_get_query_handler_by_value(struct acpi_ec *ec, u8 value)\n{\n\tstruct acpi_ec_query_handler *handler;\n\n\tmutex_lock(&ec->mutex);\n\tlist_for_each_entry(handler, &ec->list, node) {\n\t\tif (value == handler->query_bit) {\n\t\t\tkref_get(&handler->kref);\n\t\t\tmutex_unlock(&ec->mutex);\n\t\t\treturn handler;\n\t\t}\n\t}\n\tmutex_unlock(&ec->mutex);\n\treturn NULL;\n}\n\nstatic void acpi_ec_query_handler_release(struct kref *kref)\n{\n\tstruct acpi_ec_query_handler *handler =\n\t\tcontainer_of(kref, struct acpi_ec_query_handler, kref);\n\n\tkfree(handler);\n}\n\nstatic void acpi_ec_put_query_handler(struct acpi_ec_query_handler *handler)\n{\n\tkref_put(&handler->kref, acpi_ec_query_handler_release);\n}\n\nint acpi_ec_add_query_handler(struct acpi_ec *ec, u8 query_bit,\n\t\t\t      acpi_handle handle, acpi_ec_query_func func,\n\t\t\t      void *data)\n{\n\tstruct acpi_ec_query_handler *handler;\n\n\tif (!handle && !func)\n\t\treturn -EINVAL;\n\n\thandler = kzalloc(sizeof(*handler), GFP_KERNEL);\n\tif (!handler)\n\t\treturn -ENOMEM;\n\n\thandler->query_bit = query_bit;\n\thandler->handle = handle;\n\thandler->func = func;\n\thandler->data = data;\n\tmutex_lock(&ec->mutex);\n\tkref_init(&handler->kref);\n\tlist_add(&handler->node, &ec->list);\n\tmutex_unlock(&ec->mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_ec_add_query_handler);\n\nstatic void acpi_ec_remove_query_handlers(struct acpi_ec *ec,\n\t\t\t\t\t  bool remove_all, u8 query_bit)\n{\n\tstruct acpi_ec_query_handler *handler, *tmp;\n\tLIST_HEAD(free_list);\n\n\tmutex_lock(&ec->mutex);\n\tlist_for_each_entry_safe(handler, tmp, &ec->list, node) {\n\t\t \n\t\tif (remove_all || (handler->func && handler->query_bit == query_bit)) {\n\t\t\tlist_del_init(&handler->node);\n\t\t\tlist_add(&handler->node, &free_list);\n\n\t\t}\n\t}\n\tmutex_unlock(&ec->mutex);\n\tlist_for_each_entry_safe(handler, tmp, &free_list, node)\n\t\tacpi_ec_put_query_handler(handler);\n}\n\nvoid acpi_ec_remove_query_handler(struct acpi_ec *ec, u8 query_bit)\n{\n\tacpi_ec_remove_query_handlers(ec, false, query_bit);\n\tflush_workqueue(ec_query_wq);\n}\nEXPORT_SYMBOL_GPL(acpi_ec_remove_query_handler);\n\nstatic void acpi_ec_event_processor(struct work_struct *work)\n{\n\tstruct acpi_ec_query *q = container_of(work, struct acpi_ec_query, work);\n\tstruct acpi_ec_query_handler *handler = q->handler;\n\tstruct acpi_ec *ec = q->ec;\n\n\tec_dbg_evt(\"Query(0x%02x) started\", handler->query_bit);\n\n\tif (handler->func)\n\t\thandler->func(handler->data);\n\telse if (handler->handle)\n\t\tacpi_evaluate_object(handler->handle, NULL, NULL, NULL);\n\n\tec_dbg_evt(\"Query(0x%02x) stopped\", handler->query_bit);\n\n\tspin_lock_irq(&ec->lock);\n\tec->queries_in_progress--;\n\tspin_unlock_irq(&ec->lock);\n\n\tacpi_ec_put_query_handler(handler);\n\tkfree(q);\n}\n\nstatic struct acpi_ec_query *acpi_ec_create_query(struct acpi_ec *ec, u8 *pval)\n{\n\tstruct acpi_ec_query *q;\n\tstruct transaction *t;\n\n\tq = kzalloc(sizeof (struct acpi_ec_query), GFP_KERNEL);\n\tif (!q)\n\t\treturn NULL;\n\n\tINIT_WORK(&q->work, acpi_ec_event_processor);\n\tt = &q->transaction;\n\tt->command = ACPI_EC_COMMAND_QUERY;\n\tt->rdata = pval;\n\tt->rlen = 1;\n\tq->ec = ec;\n\treturn q;\n}\n\nstatic int acpi_ec_submit_query(struct acpi_ec *ec)\n{\n\tstruct acpi_ec_query *q;\n\tu8 value = 0;\n\tint result;\n\n\tq = acpi_ec_create_query(ec, &value);\n\tif (!q)\n\t\treturn -ENOMEM;\n\n\t \n\tresult = acpi_ec_transaction(ec, &q->transaction);\n\tif (result)\n\t\tgoto err_exit;\n\n\tif (!value) {\n\t\tresult = -ENODATA;\n\t\tgoto err_exit;\n\t}\n\n\tq->handler = acpi_ec_get_query_handler_by_value(ec, value);\n\tif (!q->handler) {\n\t\tresult = -ENODATA;\n\t\tgoto err_exit;\n\t}\n\n\t \n\tec_dbg_evt(\"Query(0x%02x) scheduled\", value);\n\n\tspin_lock_irq(&ec->lock);\n\n\tec->queries_in_progress++;\n\tqueue_work(ec_query_wq, &q->work);\n\n\tspin_unlock_irq(&ec->lock);\n\n\treturn 0;\n\nerr_exit:\n\tkfree(q);\n\n\treturn result;\n}\n\nstatic void acpi_ec_event_handler(struct work_struct *work)\n{\n\tstruct acpi_ec *ec = container_of(work, struct acpi_ec, work);\n\n\tec_dbg_evt(\"Event started\");\n\n\tspin_lock_irq(&ec->lock);\n\n\twhile (ec->events_to_process) {\n\t\tspin_unlock_irq(&ec->lock);\n\n\t\tacpi_ec_submit_query(ec);\n\n\t\tspin_lock_irq(&ec->lock);\n\n\t\tec->events_to_process--;\n\t}\n\n\t \n\tif (ec_event_clearing == ACPI_EC_EVT_TIMING_EVENT) {\n\t\tbool guard_timeout;\n\n\t\tacpi_ec_complete_event(ec);\n\n\t\tec_dbg_evt(\"Event stopped\");\n\n\t\tspin_unlock_irq(&ec->lock);\n\n\t\tguard_timeout = !!ec_guard(ec);\n\n\t\tspin_lock_irq(&ec->lock);\n\n\t\t \n\t\tif (guard_timeout && !ec->curr)\n\t\t\tadvance_transaction(ec, false);\n\t} else {\n\t\tacpi_ec_close_event(ec);\n\n\t\tec_dbg_evt(\"Event stopped\");\n\t}\n\n\tec->events_in_progress--;\n\n\tspin_unlock_irq(&ec->lock);\n}\n\nstatic void clear_gpe_and_advance_transaction(struct acpi_ec *ec, bool interrupt)\n{\n\t \n\tif (ec->gpe >= 0 && acpi_ec_gpe_status_set(ec))\n\t\tacpi_clear_gpe(NULL, ec->gpe);\n\n\tadvance_transaction(ec, true);\n}\n\nstatic void acpi_ec_handle_interrupt(struct acpi_ec *ec)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ec->lock, flags);\n\n\tclear_gpe_and_advance_transaction(ec, true);\n\n\tspin_unlock_irqrestore(&ec->lock, flags);\n}\n\nstatic u32 acpi_ec_gpe_handler(acpi_handle gpe_device,\n\t\t\t       u32 gpe_number, void *data)\n{\n\tacpi_ec_handle_interrupt(data);\n\treturn ACPI_INTERRUPT_HANDLED;\n}\n\nstatic irqreturn_t acpi_ec_irq_handler(int irq, void *data)\n{\n\tacpi_ec_handle_interrupt(data);\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic acpi_status\nacpi_ec_space_handler(u32 function, acpi_physical_address address,\n\t\t      u32 bits, u64 *value64,\n\t\t      void *handler_context, void *region_context)\n{\n\tstruct acpi_ec *ec = handler_context;\n\tint result = 0, i, bytes = bits / 8;\n\tu8 *value = (u8 *)value64;\n\n\tif ((address > 0xFF) || !value || !handler_context)\n\t\treturn AE_BAD_PARAMETER;\n\n\tif (function != ACPI_READ && function != ACPI_WRITE)\n\t\treturn AE_BAD_PARAMETER;\n\n\tif (ec->busy_polling || bits > 8)\n\t\tacpi_ec_burst_enable(ec);\n\n\tfor (i = 0; i < bytes; ++i, ++address, ++value)\n\t\tresult = (function == ACPI_READ) ?\n\t\t\tacpi_ec_read(ec, address, value) :\n\t\t\tacpi_ec_write(ec, address, *value);\n\n\tif (ec->busy_polling || bits > 8)\n\t\tacpi_ec_burst_disable(ec);\n\n\tswitch (result) {\n\tcase -EINVAL:\n\t\treturn AE_BAD_PARAMETER;\n\tcase -ENODEV:\n\t\treturn AE_NOT_FOUND;\n\tcase -ETIME:\n\t\treturn AE_TIME;\n\tdefault:\n\t\treturn AE_OK;\n\t}\n}\n\n \n\nstatic acpi_status\nec_parse_io_ports(struct acpi_resource *resource, void *context);\n\nstatic void acpi_ec_free(struct acpi_ec *ec)\n{\n\tif (first_ec == ec)\n\t\tfirst_ec = NULL;\n\tif (boot_ec == ec)\n\t\tboot_ec = NULL;\n\tkfree(ec);\n}\n\nstatic struct acpi_ec *acpi_ec_alloc(void)\n{\n\tstruct acpi_ec *ec = kzalloc(sizeof(struct acpi_ec), GFP_KERNEL);\n\n\tif (!ec)\n\t\treturn NULL;\n\tmutex_init(&ec->mutex);\n\tinit_waitqueue_head(&ec->wait);\n\tINIT_LIST_HEAD(&ec->list);\n\tspin_lock_init(&ec->lock);\n\tINIT_WORK(&ec->work, acpi_ec_event_handler);\n\tec->timestamp = jiffies;\n\tec->busy_polling = true;\n\tec->polling_guard = 0;\n\tec->gpe = -1;\n\tec->irq = -1;\n\treturn ec;\n}\n\nstatic acpi_status\nacpi_ec_register_query_methods(acpi_handle handle, u32 level,\n\t\t\t       void *context, void **return_value)\n{\n\tchar node_name[5];\n\tstruct acpi_buffer buffer = { sizeof(node_name), node_name };\n\tstruct acpi_ec *ec = context;\n\tint value = 0;\n\tacpi_status status;\n\n\tstatus = acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer);\n\n\tif (ACPI_SUCCESS(status) && sscanf(node_name, \"_Q%x\", &value) == 1)\n\t\tacpi_ec_add_query_handler(ec, value, handle, NULL, NULL);\n\treturn AE_OK;\n}\n\nstatic acpi_status\nec_parse_device(acpi_handle handle, u32 Level, void *context, void **retval)\n{\n\tacpi_status status;\n\tunsigned long long tmp = 0;\n\tstruct acpi_ec *ec = context;\n\n\t \n\tec->command_addr = ec->data_addr = 0;\n\n\tstatus = acpi_walk_resources(handle, METHOD_NAME__CRS,\n\t\t\t\t     ec_parse_io_ports, ec);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\tif (ec->data_addr == 0 || ec->command_addr == 0)\n\t\treturn AE_OK;\n\n\t \n\t \n\tstatus = acpi_evaluate_integer(handle, \"_GPE\", NULL, &tmp);\n\tif (ACPI_SUCCESS(status))\n\t\tec->gpe = tmp;\n\t \n\n\t \n\ttmp = 0;\n\tacpi_evaluate_integer(handle, \"_GLK\", NULL, &tmp);\n\tec->global_lock = tmp;\n\tec->handle = handle;\n\treturn AE_CTRL_TERMINATE;\n}\n\nstatic bool install_gpe_event_handler(struct acpi_ec *ec)\n{\n\tacpi_status status;\n\n\tstatus = acpi_install_gpe_raw_handler(NULL, ec->gpe,\n\t\t\t\t\t      ACPI_GPE_EDGE_TRIGGERED,\n\t\t\t\t\t      &acpi_ec_gpe_handler, ec);\n\tif (ACPI_FAILURE(status))\n\t\treturn false;\n\n\tif (test_bit(EC_FLAGS_STARTED, &ec->flags) && ec->reference_count >= 1)\n\t\tacpi_ec_enable_gpe(ec, true);\n\n\treturn true;\n}\n\nstatic bool install_gpio_irq_event_handler(struct acpi_ec *ec)\n{\n\treturn request_irq(ec->irq, acpi_ec_irq_handler, IRQF_SHARED,\n\t\t\t   \"ACPI EC\", ec) >= 0;\n}\n\n \nstatic int ec_install_handlers(struct acpi_ec *ec, struct acpi_device *device,\n\t\t\t       bool call_reg)\n{\n\tacpi_status status;\n\n\tacpi_ec_start(ec, false);\n\n\tif (!test_bit(EC_FLAGS_EC_HANDLER_INSTALLED, &ec->flags)) {\n\t\tacpi_ec_enter_noirq(ec);\n\t\tstatus = acpi_install_address_space_handler_no_reg(ec->handle,\n\t\t\t\t\t\t\t\t   ACPI_ADR_SPACE_EC,\n\t\t\t\t\t\t\t\t   &acpi_ec_space_handler,\n\t\t\t\t\t\t\t\t   NULL, ec);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_ec_stop(ec, false);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tset_bit(EC_FLAGS_EC_HANDLER_INSTALLED, &ec->flags);\n\t\tec->address_space_handler_holder = ec->handle;\n\t}\n\n\tif (call_reg && !test_bit(EC_FLAGS_EC_REG_CALLED, &ec->flags)) {\n\t\tacpi_execute_reg_methods(ec->handle, ACPI_ADR_SPACE_EC);\n\t\tset_bit(EC_FLAGS_EC_REG_CALLED, &ec->flags);\n\t}\n\n\tif (!device)\n\t\treturn 0;\n\n\tif (ec->gpe < 0) {\n\t\t \n\t\tint irq = acpi_dev_gpio_irq_get(device, 0);\n\t\t \n\t\tif (irq == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\telse if (irq >= 0)\n\t\t\tec->irq = irq;\n\t}\n\n\tif (!test_bit(EC_FLAGS_QUERY_METHODS_INSTALLED, &ec->flags)) {\n\t\t \n\t\tacpi_walk_namespace(ACPI_TYPE_METHOD, ec->handle, 1,\n\t\t\t\t    acpi_ec_register_query_methods,\n\t\t\t\t    NULL, ec, NULL);\n\t\tset_bit(EC_FLAGS_QUERY_METHODS_INSTALLED, &ec->flags);\n\t}\n\tif (!test_bit(EC_FLAGS_EVENT_HANDLER_INSTALLED, &ec->flags)) {\n\t\tbool ready = false;\n\n\t\tif (ec->gpe >= 0)\n\t\t\tready = install_gpe_event_handler(ec);\n\t\telse if (ec->irq >= 0)\n\t\t\tready = install_gpio_irq_event_handler(ec);\n\n\t\tif (ready) {\n\t\t\tset_bit(EC_FLAGS_EVENT_HANDLER_INSTALLED, &ec->flags);\n\t\t\tacpi_ec_leave_noirq(ec);\n\t\t}\n\t\t \n\t}\n\t \n\tacpi_ec_enable_event(ec);\n\n\treturn 0;\n}\n\nstatic void ec_remove_handlers(struct acpi_ec *ec)\n{\n\tif (test_bit(EC_FLAGS_EC_HANDLER_INSTALLED, &ec->flags)) {\n\t\tif (ACPI_FAILURE(acpi_remove_address_space_handler(\n\t\t\t\t\tec->address_space_handler_holder,\n\t\t\t\t\tACPI_ADR_SPACE_EC, &acpi_ec_space_handler)))\n\t\t\tpr_err(\"failed to remove space handler\\n\");\n\t\tclear_bit(EC_FLAGS_EC_HANDLER_INSTALLED, &ec->flags);\n\t}\n\n\t \n\tacpi_ec_stop(ec, false);\n\n\tif (test_bit(EC_FLAGS_EVENT_HANDLER_INSTALLED, &ec->flags)) {\n\t\tif (ec->gpe >= 0 &&\n\t\t    ACPI_FAILURE(acpi_remove_gpe_handler(NULL, ec->gpe,\n\t\t\t\t &acpi_ec_gpe_handler)))\n\t\t\tpr_err(\"failed to remove gpe handler\\n\");\n\n\t\tif (ec->irq >= 0)\n\t\t\tfree_irq(ec->irq, ec);\n\n\t\tclear_bit(EC_FLAGS_EVENT_HANDLER_INSTALLED, &ec->flags);\n\t}\n\tif (test_bit(EC_FLAGS_QUERY_METHODS_INSTALLED, &ec->flags)) {\n\t\tacpi_ec_remove_query_handlers(ec, true, 0);\n\t\tclear_bit(EC_FLAGS_QUERY_METHODS_INSTALLED, &ec->flags);\n\t}\n}\n\nstatic int acpi_ec_setup(struct acpi_ec *ec, struct acpi_device *device, bool call_reg)\n{\n\tint ret;\n\n\tret = ec_install_handlers(ec, device, call_reg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!first_ec)\n\t\tfirst_ec = ec;\n\n\tpr_info(\"EC_CMD/EC_SC=0x%lx, EC_DATA=0x%lx\\n\", ec->command_addr,\n\t\tec->data_addr);\n\n\tif (test_bit(EC_FLAGS_EVENT_HANDLER_INSTALLED, &ec->flags)) {\n\t\tif (ec->gpe >= 0)\n\t\t\tpr_info(\"GPE=0x%x\\n\", ec->gpe);\n\t\telse\n\t\t\tpr_info(\"IRQ=%d\\n\", ec->irq);\n\t}\n\n\treturn ret;\n}\n\nstatic int acpi_ec_add(struct acpi_device *device)\n{\n\tstruct acpi_ec *ec;\n\tint ret;\n\n\tstrcpy(acpi_device_name(device), ACPI_EC_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_EC_CLASS);\n\n\tif (boot_ec && (boot_ec->handle == device->handle ||\n\t    !strcmp(acpi_device_hid(device), ACPI_ECDT_HID))) {\n\t\t \n\t\tec = boot_ec;\n\t} else {\n\t\tacpi_status status;\n\n\t\tec = acpi_ec_alloc();\n\t\tif (!ec)\n\t\t\treturn -ENOMEM;\n\n\t\tstatus = ec_parse_device(device->handle, 0, ec, NULL);\n\t\tif (status != AE_CTRL_TERMINATE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (boot_ec && ec->command_addr == boot_ec->command_addr &&\n\t\t    ec->data_addr == boot_ec->data_addr) {\n\t\t\t \n\t\t\tboot_ec->handle = ec->handle;\n\n\t\t\tif (EC_FLAGS_TRUST_DSDT_GPE)\n\t\t\t\tboot_ec->gpe = ec->gpe;\n\n\t\t\tacpi_handle_debug(ec->handle, \"duplicated.\\n\");\n\t\t\tacpi_ec_free(ec);\n\t\t\tec = boot_ec;\n\t\t}\n\t}\n\n\tret = acpi_ec_setup(ec, device, true);\n\tif (ret)\n\t\tgoto err;\n\n\tif (ec == boot_ec)\n\t\tacpi_handle_info(boot_ec->handle,\n\t\t\t\t \"Boot %s EC initialization complete\\n\",\n\t\t\t\t boot_ec_is_ecdt ? \"ECDT\" : \"DSDT\");\n\n\tacpi_handle_info(ec->handle,\n\t\t\t \"EC: Used to handle transactions and events\\n\");\n\n\tdevice->driver_data = ec;\n\n\tret = !!request_region(ec->data_addr, 1, \"EC data\");\n\tWARN(!ret, \"Could not request EC data io port 0x%lx\", ec->data_addr);\n\tret = !!request_region(ec->command_addr, 1, \"EC cmd\");\n\tWARN(!ret, \"Could not request EC cmd io port 0x%lx\", ec->command_addr);\n\n\t \n\tacpi_dev_clear_dependencies(device);\n\n\tacpi_handle_debug(ec->handle, \"enumerated.\\n\");\n\treturn 0;\n\nerr:\n\tif (ec != boot_ec)\n\t\tacpi_ec_free(ec);\n\n\treturn ret;\n}\n\nstatic void acpi_ec_remove(struct acpi_device *device)\n{\n\tstruct acpi_ec *ec;\n\n\tif (!device)\n\t\treturn;\n\n\tec = acpi_driver_data(device);\n\trelease_region(ec->data_addr, 1);\n\trelease_region(ec->command_addr, 1);\n\tdevice->driver_data = NULL;\n\tif (ec != boot_ec) {\n\t\tec_remove_handlers(ec);\n\t\tacpi_ec_free(ec);\n\t}\n}\n\nstatic acpi_status\nec_parse_io_ports(struct acpi_resource *resource, void *context)\n{\n\tstruct acpi_ec *ec = context;\n\n\tif (resource->type != ACPI_RESOURCE_TYPE_IO)\n\t\treturn AE_OK;\n\n\t \n\tif (ec->data_addr == 0)\n\t\tec->data_addr = resource->data.io.minimum;\n\telse if (ec->command_addr == 0)\n\t\tec->command_addr = resource->data.io.minimum;\n\telse\n\t\treturn AE_CTRL_TERMINATE;\n\n\treturn AE_OK;\n}\n\nstatic const struct acpi_device_id ec_device_ids[] = {\n\t{\"PNP0C09\", 0},\n\t{ACPI_ECDT_HID, 0},\n\t{\"\", 0},\n};\n\n \nvoid __init acpi_ec_dsdt_probe(void)\n{\n\tstruct acpi_ec *ec;\n\tacpi_status status;\n\tint ret;\n\n\t \n\tif (boot_ec)\n\t\treturn;\n\n\tec = acpi_ec_alloc();\n\tif (!ec)\n\t\treturn;\n\n\t \n\tstatus = acpi_get_devices(ec_device_ids[0].id, ec_parse_device, ec, NULL);\n\tif (ACPI_FAILURE(status) || !ec->handle) {\n\t\tacpi_ec_free(ec);\n\t\treturn;\n\t}\n\n\t \n\tret = acpi_ec_setup(ec, NULL, true);\n\tif (ret) {\n\t\tacpi_ec_free(ec);\n\t\treturn;\n\t}\n\n\tboot_ec = ec;\n\n\tacpi_handle_info(ec->handle,\n\t\t\t \"Boot DSDT EC used to handle transactions\\n\");\n}\n\n \nstatic void __init acpi_ec_ecdt_start(void)\n{\n\tstruct acpi_table_ecdt *ecdt_ptr;\n\tacpi_handle handle;\n\tacpi_status status;\n\n\t \n\tif (!boot_ec || boot_ec->handle != ACPI_ROOT_OBJECT)\n\t\treturn;\n\n\t \n\tstatus = acpi_get_table(ACPI_SIG_ECDT, 1,\n\t\t\t\t(struct acpi_table_header **)&ecdt_ptr);\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\n\tstatus = acpi_get_handle(NULL, ecdt_ptr->id, &handle);\n\tif (ACPI_SUCCESS(status)) {\n\t\tboot_ec->handle = handle;\n\n\t\t \n\t\tacpi_bus_register_early_device(ACPI_BUS_TYPE_ECDT_EC);\n\t}\n\n\tacpi_put_table((struct acpi_table_header *)ecdt_ptr);\n}\n\n \nstatic int ec_clear_on_resume(const struct dmi_system_id *id)\n{\n\tpr_debug(\"Detected system needing EC poll on resume.\\n\");\n\tEC_FLAGS_CLEAR_ON_RESUME = 1;\n\tec_event_clearing = ACPI_EC_EVT_TIMING_STATUS;\n\treturn 0;\n}\n\n \nstatic int ec_correct_ecdt(const struct dmi_system_id *id)\n{\n\tpr_debug(\"Detected system needing ECDT address correction.\\n\");\n\tEC_FLAGS_CORRECT_ECDT = 1;\n\treturn 0;\n}\n\n \nstatic int ec_honor_dsdt_gpe(const struct dmi_system_id *id)\n{\n\tpr_debug(\"Detected system needing DSDT GPE setting.\\n\");\n\tEC_FLAGS_TRUST_DSDT_GPE = 1;\n\treturn 0;\n}\n\nstatic const struct dmi_system_id ec_dmi_table[] __initconst = {\n\t{\n\t\t \n\t\t.callback = ec_correct_ecdt,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Micro-Star\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MS-171F\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.callback = ec_honor_dsdt_gpe,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Pavilion Gaming Laptop 15-cx0xxx\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.callback = ec_honor_dsdt_gpe,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP 15-cx0041ur\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.callback = ec_honor_dsdt_gpe,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Pavilion Gaming Laptop 15-dk1xxx\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.callback = ec_honor_dsdt_gpe,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP 250 G7 Notebook PC\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.callback = ec_clear_on_resume,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"SAMSUNG ELECTRONICS CO., LTD.\"),\n\t\t},\n\t},\n\t{}\n};\n\nvoid __init acpi_ec_ecdt_probe(void)\n{\n\tstruct acpi_table_ecdt *ecdt_ptr;\n\tstruct acpi_ec *ec;\n\tacpi_status status;\n\tint ret;\n\n\t \n\tdmi_check_system(ec_dmi_table);\n\tstatus = acpi_get_table(ACPI_SIG_ECDT, 1,\n\t\t\t\t(struct acpi_table_header **)&ecdt_ptr);\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\n\tif (!ecdt_ptr->control.address || !ecdt_ptr->data.address) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tec = acpi_ec_alloc();\n\tif (!ec)\n\t\tgoto out;\n\n\tif (EC_FLAGS_CORRECT_ECDT) {\n\t\tec->command_addr = ecdt_ptr->data.address;\n\t\tec->data_addr = ecdt_ptr->control.address;\n\t} else {\n\t\tec->command_addr = ecdt_ptr->control.address;\n\t\tec->data_addr = ecdt_ptr->data.address;\n\t}\n\n\t \n\tif (!acpi_gbl_reduced_hardware)\n\t\tec->gpe = ecdt_ptr->gpe;\n\n\tec->handle = ACPI_ROOT_OBJECT;\n\n\t \n\tret = acpi_ec_setup(ec, NULL, false);\n\tif (ret) {\n\t\tacpi_ec_free(ec);\n\t\tgoto out;\n\t}\n\n\tboot_ec = ec;\n\tboot_ec_is_ecdt = true;\n\n\tpr_info(\"Boot ECDT EC used to handle transactions\\n\");\n\nout:\n\tacpi_put_table((struct acpi_table_header *)ecdt_ptr);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acpi_ec_suspend(struct device *dev)\n{\n\tstruct acpi_ec *ec =\n\t\tacpi_driver_data(to_acpi_device(dev));\n\n\tif (!pm_suspend_no_platform() && ec_freeze_events)\n\t\tacpi_ec_disable_event(ec);\n\treturn 0;\n}\n\nstatic int acpi_ec_suspend_noirq(struct device *dev)\n{\n\tstruct acpi_ec *ec = acpi_driver_data(to_acpi_device(dev));\n\n\t \n\tif (ec_no_wakeup && test_bit(EC_FLAGS_STARTED, &ec->flags) &&\n\t    ec->gpe >= 0 && ec->reference_count >= 1)\n\t\tacpi_set_gpe(NULL, ec->gpe, ACPI_GPE_DISABLE);\n\n\tacpi_ec_enter_noirq(ec);\n\n\treturn 0;\n}\n\nstatic int acpi_ec_resume_noirq(struct device *dev)\n{\n\tstruct acpi_ec *ec = acpi_driver_data(to_acpi_device(dev));\n\n\tacpi_ec_leave_noirq(ec);\n\n\tif (ec_no_wakeup && test_bit(EC_FLAGS_STARTED, &ec->flags) &&\n\t    ec->gpe >= 0 && ec->reference_count >= 1)\n\t\tacpi_set_gpe(NULL, ec->gpe, ACPI_GPE_ENABLE);\n\n\treturn 0;\n}\n\nstatic int acpi_ec_resume(struct device *dev)\n{\n\tstruct acpi_ec *ec =\n\t\tacpi_driver_data(to_acpi_device(dev));\n\n\tacpi_ec_enable_event(ec);\n\treturn 0;\n}\n\nvoid acpi_ec_mark_gpe_for_wake(void)\n{\n\tif (first_ec && !ec_no_wakeup)\n\t\tacpi_mark_gpe_for_wake(NULL, first_ec->gpe);\n}\nEXPORT_SYMBOL_GPL(acpi_ec_mark_gpe_for_wake);\n\nvoid acpi_ec_set_gpe_wake_mask(u8 action)\n{\n\tif (pm_suspend_no_platform() && first_ec && !ec_no_wakeup)\n\t\tacpi_set_gpe_wake_mask(NULL, first_ec->gpe, action);\n}\n\nstatic bool acpi_ec_work_in_progress(struct acpi_ec *ec)\n{\n\treturn ec->events_in_progress + ec->queries_in_progress > 0;\n}\n\nbool acpi_ec_dispatch_gpe(void)\n{\n\tbool work_in_progress = false;\n\n\tif (!first_ec)\n\t\treturn acpi_any_gpe_status_set(U32_MAX);\n\n\t \n\tif (acpi_any_gpe_status_set(first_ec->gpe))\n\t\treturn true;\n\n\t \n\tpm_system_cancel_wakeup();\n\n\t \n\tspin_lock_irq(&first_ec->lock);\n\n\tif (acpi_ec_gpe_status_set(first_ec)) {\n\t\tpm_pr_dbg(\"ACPI EC GPE status set\\n\");\n\n\t\tclear_gpe_and_advance_transaction(first_ec, false);\n\t\twork_in_progress = acpi_ec_work_in_progress(first_ec);\n\t}\n\n\tspin_unlock_irq(&first_ec->lock);\n\n\tif (!work_in_progress)\n\t\treturn false;\n\n\tpm_pr_dbg(\"ACPI EC GPE dispatched\\n\");\n\n\t \n\tdo {\n\t\tacpi_ec_flush_work();\n\n\t\tpm_pr_dbg(\"ACPI EC work flushed\\n\");\n\n\t\tspin_lock_irq(&first_ec->lock);\n\n\t\twork_in_progress = acpi_ec_work_in_progress(first_ec);\n\n\t\tspin_unlock_irq(&first_ec->lock);\n\t} while (work_in_progress && !pm_wakeup_pending());\n\n\treturn false;\n}\n#endif  \n\nstatic const struct dev_pm_ops acpi_ec_pm = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(acpi_ec_suspend_noirq, acpi_ec_resume_noirq)\n\tSET_SYSTEM_SLEEP_PM_OPS(acpi_ec_suspend, acpi_ec_resume)\n};\n\nstatic int param_set_event_clearing(const char *val,\n\t\t\t\t    const struct kernel_param *kp)\n{\n\tint result = 0;\n\n\tif (!strncmp(val, \"status\", sizeof(\"status\") - 1)) {\n\t\tec_event_clearing = ACPI_EC_EVT_TIMING_STATUS;\n\t\tpr_info(\"Assuming SCI_EVT clearing on EC_SC accesses\\n\");\n\t} else if (!strncmp(val, \"query\", sizeof(\"query\") - 1)) {\n\t\tec_event_clearing = ACPI_EC_EVT_TIMING_QUERY;\n\t\tpr_info(\"Assuming SCI_EVT clearing on QR_EC writes\\n\");\n\t} else if (!strncmp(val, \"event\", sizeof(\"event\") - 1)) {\n\t\tec_event_clearing = ACPI_EC_EVT_TIMING_EVENT;\n\t\tpr_info(\"Assuming SCI_EVT clearing on event reads\\n\");\n\t} else\n\t\tresult = -EINVAL;\n\treturn result;\n}\n\nstatic int param_get_event_clearing(char *buffer,\n\t\t\t\t    const struct kernel_param *kp)\n{\n\tswitch (ec_event_clearing) {\n\tcase ACPI_EC_EVT_TIMING_STATUS:\n\t\treturn sprintf(buffer, \"status\\n\");\n\tcase ACPI_EC_EVT_TIMING_QUERY:\n\t\treturn sprintf(buffer, \"query\\n\");\n\tcase ACPI_EC_EVT_TIMING_EVENT:\n\t\treturn sprintf(buffer, \"event\\n\");\n\tdefault:\n\t\treturn sprintf(buffer, \"invalid\\n\");\n\t}\n\treturn 0;\n}\n\nmodule_param_call(ec_event_clearing, param_set_event_clearing, param_get_event_clearing,\n\t\t  NULL, 0644);\nMODULE_PARM_DESC(ec_event_clearing, \"Assumed SCI_EVT clearing timing\");\n\nstatic struct acpi_driver acpi_ec_driver = {\n\t.name = \"ec\",\n\t.class = ACPI_EC_CLASS,\n\t.ids = ec_device_ids,\n\t.ops = {\n\t\t.add = acpi_ec_add,\n\t\t.remove = acpi_ec_remove,\n\t\t},\n\t.drv.pm = &acpi_ec_pm,\n};\n\nstatic void acpi_ec_destroy_workqueues(void)\n{\n\tif (ec_wq) {\n\t\tdestroy_workqueue(ec_wq);\n\t\tec_wq = NULL;\n\t}\n\tif (ec_query_wq) {\n\t\tdestroy_workqueue(ec_query_wq);\n\t\tec_query_wq = NULL;\n\t}\n}\n\nstatic int acpi_ec_init_workqueues(void)\n{\n\tif (!ec_wq)\n\t\tec_wq = alloc_ordered_workqueue(\"kec\", 0);\n\n\tif (!ec_query_wq)\n\t\tec_query_wq = alloc_workqueue(\"kec_query\", 0, ec_max_queries);\n\n\tif (!ec_wq || !ec_query_wq) {\n\t\tacpi_ec_destroy_workqueues();\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic const struct dmi_system_id acpi_ec_no_wakeup[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"Thinkpad X1 Carbon 6th\"),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"ThinkPad X1 Yoga 3rd\"),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"103C_5336AN HP ZHAN 66 Pro\"),\n\t\t},\n\t},\n\t{ },\n};\n\nvoid __init acpi_ec_init(void)\n{\n\tint result;\n\n\tresult = acpi_ec_init_workqueues();\n\tif (result)\n\t\treturn;\n\n\t \n\tif (dmi_check_system(acpi_ec_no_wakeup)) {\n\t\tec_no_wakeup = true;\n\t\tpr_debug(\"Disabling EC wakeup on suspend-to-idle\\n\");\n\t}\n\n\t \n\tacpi_bus_register_driver(&acpi_ec_driver);\n\n\tacpi_ec_ecdt_start();\n}\n\n \n#if 0\nstatic void __exit acpi_ec_exit(void)\n{\n\n\tacpi_bus_unregister_driver(&acpi_ec_driver);\n\tacpi_ec_destroy_workqueues();\n}\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}