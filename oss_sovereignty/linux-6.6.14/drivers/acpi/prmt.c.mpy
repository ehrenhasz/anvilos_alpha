{
  "module_name": "prmt.c",
  "hash_id": "d5cdb3028a144ba76de4c2c7214120261ae3b3b60068cc3b0eac3cad2b2af4c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/prmt.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/efi.h>\n#include <linux/acpi.h>\n#include <linux/prmt.h>\n#include <asm/efi.h>\n\n#pragma pack(1)\nstruct prm_mmio_addr_range {\n\tu64 phys_addr;\n\tu64 virt_addr;\n\tu32 length;\n};\n\nstruct prm_mmio_info {\n\tu64 mmio_count;\n\tstruct prm_mmio_addr_range addr_ranges[];\n};\n\nstruct prm_buffer {\n\tu8 prm_status;\n\tu64 efi_status;\n\tu8 prm_cmd;\n\tguid_t handler_guid;\n};\n\nstruct prm_context_buffer {\n\tchar signature[ACPI_NAMESEG_SIZE];\n\tu16 revision;\n\tu16 reserved;\n\tguid_t identifier;\n\tu64 static_data_buffer;\n\tstruct prm_mmio_info *mmio_ranges;\n};\n#pragma pack()\n\nstatic LIST_HEAD(prm_module_list);\n\nstruct prm_handler_info {\n\tguid_t guid;\n\tefi_status_t (__efiapi *handler_addr)(u64, void *);\n\tu64 static_data_buffer_addr;\n\tu64 acpi_param_buffer_addr;\n\n\tstruct list_head handler_list;\n};\n\nstruct prm_module_info {\n\tguid_t guid;\n\tu16 major_rev;\n\tu16 minor_rev;\n\tu16 handler_count;\n\tstruct prm_mmio_info *mmio_info;\n\tbool updatable;\n\n\tstruct list_head module_list;\n\tstruct prm_handler_info handlers[];\n};\n\nstatic u64 efi_pa_va_lookup(u64 pa)\n{\n\tefi_memory_desc_t *md;\n\tu64 pa_offset = pa & ~PAGE_MASK;\n\tu64 page = pa & PAGE_MASK;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tif (md->phys_addr < pa && pa < md->phys_addr + PAGE_SIZE * md->num_pages)\n\t\t\treturn pa_offset + md->virt_addr + page - md->phys_addr;\n\t}\n\n\treturn 0;\n}\n\n#define get_first_handler(a) ((struct acpi_prmt_handler_info *) ((char *) (a) + a->handler_info_offset))\n#define get_next_handler(a) ((struct acpi_prmt_handler_info *) (sizeof(struct acpi_prmt_handler_info) + (char *) a))\n\nstatic int __init\nacpi_parse_prmt(union acpi_subtable_headers *header, const unsigned long end)\n{\n\tstruct acpi_prmt_module_info *module_info;\n\tstruct acpi_prmt_handler_info *handler_info;\n\tstruct prm_handler_info *th;\n\tstruct prm_module_info *tm;\n\tu64 *mmio_count;\n\tu64 cur_handler = 0;\n\tu32 module_info_size = 0;\n\tu64 mmio_range_size = 0;\n\tvoid *temp_mmio;\n\n\tmodule_info = (struct acpi_prmt_module_info *) header;\n\tmodule_info_size = struct_size(tm, handlers, module_info->handler_info_count);\n\ttm = kmalloc(module_info_size, GFP_KERNEL);\n\tif (!tm)\n\t\tgoto parse_prmt_out1;\n\n\tguid_copy(&tm->guid, (guid_t *) module_info->module_guid);\n\ttm->major_rev = module_info->major_rev;\n\ttm->minor_rev = module_info->minor_rev;\n\ttm->handler_count = module_info->handler_info_count;\n\ttm->updatable = true;\n\n\tif (module_info->mmio_list_pointer) {\n\t\t \n\t\tmmio_count = (u64 *) memremap(module_info->mmio_list_pointer, 8, MEMREMAP_WB);\n\t\tif (!mmio_count)\n\t\t\tgoto parse_prmt_out2;\n\n\t\tmmio_range_size = struct_size(tm->mmio_info, addr_ranges, *mmio_count);\n\t\ttm->mmio_info = kmalloc(mmio_range_size, GFP_KERNEL);\n\t\tif (!tm->mmio_info)\n\t\t\tgoto parse_prmt_out3;\n\n\t\ttemp_mmio = memremap(module_info->mmio_list_pointer, mmio_range_size, MEMREMAP_WB);\n\t\tif (!temp_mmio)\n\t\t\tgoto parse_prmt_out4;\n\t\tmemmove(tm->mmio_info, temp_mmio, mmio_range_size);\n\t} else {\n\t\ttm->mmio_info = kmalloc(sizeof(*tm->mmio_info), GFP_KERNEL);\n\t\tif (!tm->mmio_info)\n\t\t\tgoto parse_prmt_out2;\n\n\t\ttm->mmio_info->mmio_count = 0;\n\t}\n\n\tINIT_LIST_HEAD(&tm->module_list);\n\tlist_add(&tm->module_list, &prm_module_list);\n\n\thandler_info = get_first_handler(module_info);\n\tdo {\n\t\tth = &tm->handlers[cur_handler];\n\n\t\tguid_copy(&th->guid, (guid_t *)handler_info->handler_guid);\n\t\tth->handler_addr = (void *)efi_pa_va_lookup(handler_info->handler_address);\n\t\tth->static_data_buffer_addr = efi_pa_va_lookup(handler_info->static_data_buffer_address);\n\t\tth->acpi_param_buffer_addr = efi_pa_va_lookup(handler_info->acpi_param_buffer_address);\n\t} while (++cur_handler < tm->handler_count && (handler_info = get_next_handler(handler_info)));\n\n\treturn 0;\n\nparse_prmt_out4:\n\tkfree(tm->mmio_info);\nparse_prmt_out3:\n\tmemunmap(mmio_count);\nparse_prmt_out2:\n\tkfree(tm);\nparse_prmt_out1:\n\treturn -ENOMEM;\n}\n\n#define GET_MODULE\t0\n#define GET_HANDLER\t1\n\nstatic void *find_guid_info(const guid_t *guid, u8 mode)\n{\n\tstruct prm_handler_info *cur_handler;\n\tstruct prm_module_info *cur_module;\n\tint i = 0;\n\n\tlist_for_each_entry(cur_module, &prm_module_list, module_list) {\n\t\tfor (i = 0; i < cur_module->handler_count; ++i) {\n\t\t\tcur_handler = &cur_module->handlers[i];\n\t\t\tif (guid_equal(guid, &cur_handler->guid)) {\n\t\t\t\tif (mode == GET_MODULE)\n\t\t\t\t\treturn (void *)cur_module;\n\t\t\t\telse\n\t\t\t\t\treturn (void *)cur_handler;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct prm_module_info *find_prm_module(const guid_t *guid)\n{\n\treturn (struct prm_module_info *)find_guid_info(guid, GET_MODULE);\n}\n\nstatic struct prm_handler_info *find_prm_handler(const guid_t *guid)\n{\n\treturn (struct prm_handler_info *) find_guid_info(guid, GET_HANDLER);\n}\n\n \n\n#define PRM_CMD_RUN_SERVICE\t\t0\n#define PRM_CMD_START_TRANSACTION\t1\n#define PRM_CMD_END_TRANSACTION\t\t2\n\n \n\n#define PRM_HANDLER_SUCCESS \t\t0\n#define PRM_HANDLER_ERROR \t\t1\n#define INVALID_PRM_COMMAND \t\t2\n#define PRM_HANDLER_GUID_NOT_FOUND \t3\n#define UPDATE_LOCK_ALREADY_HELD \t4\n#define UPDATE_UNLOCK_WITHOUT_LOCK \t5\n\n \nstatic acpi_status acpi_platformrt_space_handler(u32 function,\n\t\t\t\t\t\t acpi_physical_address addr,\n\t\t\t\t\t\t u32 bits, acpi_integer *value,\n\t\t\t\t\t\t void *handler_context,\n\t\t\t\t\t\t void *region_context)\n{\n\tstruct prm_buffer *buffer = ACPI_CAST_PTR(struct prm_buffer, value);\n\tstruct prm_handler_info *handler;\n\tstruct prm_module_info *module;\n\tefi_status_t status;\n\tstruct prm_context_buffer context;\n\n\tif (!efi_enabled(EFI_RUNTIME_SERVICES)) {\n\t\tpr_err_ratelimited(\"PRM: EFI runtime services no longer available\\n\");\n\t\treturn AE_NO_HANDLER;\n\t}\n\n\t \n\tswitch (buffer->prm_cmd) {\n\tcase PRM_CMD_RUN_SERVICE:\n\n\t\thandler = find_prm_handler(&buffer->handler_guid);\n\t\tmodule = find_prm_module(&buffer->handler_guid);\n\t\tif (!handler || !module)\n\t\t\tgoto invalid_guid;\n\n\t\tACPI_COPY_NAMESEG(context.signature, \"PRMC\");\n\t\tcontext.revision = 0x0;\n\t\tcontext.reserved = 0x0;\n\t\tcontext.identifier = handler->guid;\n\t\tcontext.static_data_buffer = handler->static_data_buffer_addr;\n\t\tcontext.mmio_ranges = module->mmio_info;\n\n\t\tstatus = efi_call_acpi_prm_handler(handler->handler_addr,\n\t\t\t\t\t\t   handler->acpi_param_buffer_addr,\n\t\t\t\t\t\t   &context);\n\t\tif (status == EFI_SUCCESS) {\n\t\t\tbuffer->prm_status = PRM_HANDLER_SUCCESS;\n\t\t} else {\n\t\t\tbuffer->prm_status = PRM_HANDLER_ERROR;\n\t\t\tbuffer->efi_status = status;\n\t\t}\n\t\tbreak;\n\n\tcase PRM_CMD_START_TRANSACTION:\n\n\t\tmodule = find_prm_module(&buffer->handler_guid);\n\t\tif (!module)\n\t\t\tgoto invalid_guid;\n\n\t\tif (module->updatable)\n\t\t\tmodule->updatable = false;\n\t\telse\n\t\t\tbuffer->prm_status = UPDATE_LOCK_ALREADY_HELD;\n\t\tbreak;\n\n\tcase PRM_CMD_END_TRANSACTION:\n\n\t\tmodule = find_prm_module(&buffer->handler_guid);\n\t\tif (!module)\n\t\t\tgoto invalid_guid;\n\n\t\tif (module->updatable)\n\t\t\tbuffer->prm_status = UPDATE_UNLOCK_WITHOUT_LOCK;\n\t\telse\n\t\t\tmodule->updatable = true;\n\t\tbreak;\n\n\tdefault:\n\n\t\tbuffer->prm_status = INVALID_PRM_COMMAND;\n\t\tbreak;\n\t}\n\n\treturn AE_OK;\n\ninvalid_guid:\n\tbuffer->prm_status = PRM_HANDLER_GUID_NOT_FOUND;\n\treturn AE_OK;\n}\n\nvoid __init init_prmt(void)\n{\n\tstruct acpi_table_header *tbl;\n\tacpi_status status;\n\tint mc;\n\n\tstatus = acpi_get_table(ACPI_SIG_PRMT, 0, &tbl);\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\n\tmc = acpi_table_parse_entries(ACPI_SIG_PRMT, sizeof(struct acpi_table_prmt) +\n\t\t\t\t\t  sizeof (struct acpi_table_prmt_header),\n\t\t\t\t\t  0, acpi_parse_prmt, 0);\n\tacpi_put_table(tbl);\n\t \n\tif (mc <= 0)\n\t\treturn;\n\n\tpr_info(\"PRM: found %u modules\\n\", mc);\n\n\tif (!efi_enabled(EFI_RUNTIME_SERVICES)) {\n\t\tpr_err(\"PRM: EFI runtime services unavailable\\n\");\n\t\treturn;\n\t}\n\n\tstatus = acpi_install_address_space_handler(ACPI_ROOT_OBJECT,\n\t\t\t\t\t\t    ACPI_ADR_SPACE_PLATFORM_RT,\n\t\t\t\t\t\t    &acpi_platformrt_space_handler,\n\t\t\t\t\t\t    NULL, NULL);\n\tif (ACPI_FAILURE(status))\n\t\tpr_alert(\"PRM: OperationRegion handler could not be installed\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}