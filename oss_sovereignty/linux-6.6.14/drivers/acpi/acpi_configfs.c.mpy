{
  "module_name": "acpi_configfs.c",
  "hash_id": "da4d4e1cc4b0264bf73a7f19c41342d20feeaa75bd904e060bab7511d056118b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_configfs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI configfs: \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/configfs.h>\n#include <linux/acpi.h>\n#include <linux/security.h>\n\nstatic struct config_group *acpi_table_group;\n\nstruct acpi_table {\n\tstruct config_item cfg;\n\tstruct acpi_table_header *header;\n\tu32 index;\n};\n\nstatic ssize_t acpi_table_aml_write(struct config_item *cfg,\n\t\t\t\t    const void *data, size_t size)\n{\n\tconst struct acpi_table_header *header = data;\n\tstruct acpi_table *table;\n\tint ret = security_locked_down(LOCKDOWN_ACPI_TABLES);\n\n\tif (ret)\n\t\treturn ret;\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\tif (table->header) {\n\t\tpr_err(\"table already loaded\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (header->length != size) {\n\t\tpr_err(\"invalid table length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(header->signature, ACPI_SIG_SSDT, 4)) {\n\t\tpr_err(\"invalid table signature\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\ttable->header = kmemdup(header, header->length, GFP_KERNEL);\n\tif (!table->header)\n\t\treturn -ENOMEM;\n\n\tret = acpi_load_table(table->header, &table->index);\n\tif (ret) {\n\t\tkfree(table->header);\n\t\ttable->header = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic inline struct acpi_table_header *get_header(struct config_item *cfg)\n{\n\tstruct acpi_table *table = container_of(cfg, struct acpi_table, cfg);\n\n\tif (!table->header)\n\t\tpr_err(\"table not loaded\\n\");\n\n\treturn table->header ?: ERR_PTR(-EINVAL);\n}\n\nstatic ssize_t acpi_table_aml_read(struct config_item *cfg,\n\t\t\t\t   void *data, size_t size)\n{\n\tstruct acpi_table_header *h = get_header(cfg);\n\n\tif (IS_ERR(h))\n\t\treturn PTR_ERR(h);\n\n\tif (data)\n\t\tmemcpy(data, h, h->length);\n\n\treturn h->length;\n}\n\n#define MAX_ACPI_TABLE_SIZE (128 * 1024)\n\nCONFIGFS_BIN_ATTR(acpi_table_, aml, NULL, MAX_ACPI_TABLE_SIZE);\n\nstatic struct configfs_bin_attribute *acpi_table_bin_attrs[] = {\n\t&acpi_table_attr_aml,\n\tNULL,\n};\n\nstatic ssize_t acpi_table_signature_show(struct config_item *cfg, char *str)\n{\n\tstruct acpi_table_header *h = get_header(cfg);\n\n\tif (IS_ERR(h))\n\t\treturn PTR_ERR(h);\n\n\treturn sysfs_emit(str, \"%.*s\\n\", ACPI_NAMESEG_SIZE, h->signature);\n}\n\nstatic ssize_t acpi_table_length_show(struct config_item *cfg, char *str)\n{\n\tstruct acpi_table_header *h = get_header(cfg);\n\n\tif (IS_ERR(h))\n\t\treturn PTR_ERR(h);\n\n\treturn sysfs_emit(str, \"%d\\n\", h->length);\n}\n\nstatic ssize_t acpi_table_revision_show(struct config_item *cfg, char *str)\n{\n\tstruct acpi_table_header *h = get_header(cfg);\n\n\tif (IS_ERR(h))\n\t\treturn PTR_ERR(h);\n\n\treturn sysfs_emit(str, \"%d\\n\", h->revision);\n}\n\nstatic ssize_t acpi_table_oem_id_show(struct config_item *cfg, char *str)\n{\n\tstruct acpi_table_header *h = get_header(cfg);\n\n\tif (IS_ERR(h))\n\t\treturn PTR_ERR(h);\n\n\treturn sysfs_emit(str, \"%.*s\\n\", ACPI_OEM_ID_SIZE, h->oem_id);\n}\n\nstatic ssize_t acpi_table_oem_table_id_show(struct config_item *cfg, char *str)\n{\n\tstruct acpi_table_header *h = get_header(cfg);\n\n\tif (IS_ERR(h))\n\t\treturn PTR_ERR(h);\n\n\treturn sysfs_emit(str, \"%.*s\\n\", ACPI_OEM_TABLE_ID_SIZE, h->oem_table_id);\n}\n\nstatic ssize_t acpi_table_oem_revision_show(struct config_item *cfg, char *str)\n{\n\tstruct acpi_table_header *h = get_header(cfg);\n\n\tif (IS_ERR(h))\n\t\treturn PTR_ERR(h);\n\n\treturn sysfs_emit(str, \"%d\\n\", h->oem_revision);\n}\n\nstatic ssize_t acpi_table_asl_compiler_id_show(struct config_item *cfg,\n\t\t\t\t\t       char *str)\n{\n\tstruct acpi_table_header *h = get_header(cfg);\n\n\tif (IS_ERR(h))\n\t\treturn PTR_ERR(h);\n\n\treturn sysfs_emit(str, \"%.*s\\n\", ACPI_NAMESEG_SIZE, h->asl_compiler_id);\n}\n\nstatic ssize_t acpi_table_asl_compiler_revision_show(struct config_item *cfg,\n\t\t\t\t\t\t     char *str)\n{\n\tstruct acpi_table_header *h = get_header(cfg);\n\n\tif (IS_ERR(h))\n\t\treturn PTR_ERR(h);\n\n\treturn sysfs_emit(str, \"%d\\n\", h->asl_compiler_revision);\n}\n\nCONFIGFS_ATTR_RO(acpi_table_, signature);\nCONFIGFS_ATTR_RO(acpi_table_, length);\nCONFIGFS_ATTR_RO(acpi_table_, revision);\nCONFIGFS_ATTR_RO(acpi_table_, oem_id);\nCONFIGFS_ATTR_RO(acpi_table_, oem_table_id);\nCONFIGFS_ATTR_RO(acpi_table_, oem_revision);\nCONFIGFS_ATTR_RO(acpi_table_, asl_compiler_id);\nCONFIGFS_ATTR_RO(acpi_table_, asl_compiler_revision);\n\nstatic struct configfs_attribute *acpi_table_attrs[] = {\n\t&acpi_table_attr_signature,\n\t&acpi_table_attr_length,\n\t&acpi_table_attr_revision,\n\t&acpi_table_attr_oem_id,\n\t&acpi_table_attr_oem_table_id,\n\t&acpi_table_attr_oem_revision,\n\t&acpi_table_attr_asl_compiler_id,\n\t&acpi_table_attr_asl_compiler_revision,\n\tNULL,\n};\n\nstatic const struct config_item_type acpi_table_type = {\n\t.ct_owner = THIS_MODULE,\n\t.ct_bin_attrs = acpi_table_bin_attrs,\n\t.ct_attrs = acpi_table_attrs,\n};\n\nstatic struct config_item *acpi_table_make_item(struct config_group *group,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct acpi_table *table;\n\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconfig_item_init_type_name(&table->cfg, name, &acpi_table_type);\n\treturn &table->cfg;\n}\n\nstatic void acpi_table_drop_item(struct config_group *group,\n\t\t\t\t struct config_item *cfg)\n{\n\tstruct acpi_table *table = container_of(cfg, struct acpi_table, cfg);\n\n\tpr_debug(\"Host-directed Dynamic ACPI Table Unload\\n\");\n\tacpi_unload_table(table->index);\n\tconfig_item_put(cfg);\n}\n\nstatic struct configfs_group_operations acpi_table_group_ops = {\n\t.make_item = acpi_table_make_item,\n\t.drop_item = acpi_table_drop_item,\n};\n\nstatic const struct config_item_type acpi_tables_type = {\n\t.ct_owner = THIS_MODULE,\n\t.ct_group_ops = &acpi_table_group_ops,\n};\n\nstatic const struct config_item_type acpi_root_group_type = {\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic struct configfs_subsystem acpi_configfs = {\n\t.su_group = {\n\t\t.cg_item = {\n\t\t\t.ci_namebuf = \"acpi\",\n\t\t\t.ci_type = &acpi_root_group_type,\n\t\t},\n\t},\n\t.su_mutex = __MUTEX_INITIALIZER(acpi_configfs.su_mutex),\n};\n\nstatic int __init acpi_configfs_init(void)\n{\n\tint ret;\n\tstruct config_group *root = &acpi_configfs.su_group;\n\n\tconfig_group_init(root);\n\n\tret = configfs_register_subsystem(&acpi_configfs);\n\tif (ret)\n\t\treturn ret;\n\n\tacpi_table_group = configfs_register_default_group(root, \"table\",\n\t\t\t\t\t\t\t   &acpi_tables_type);\n\tif (IS_ERR(acpi_table_group)) {\n\t\tconfigfs_unregister_subsystem(&acpi_configfs);\n\t\treturn PTR_ERR(acpi_table_group);\n\t}\n\n\treturn 0;\n}\nmodule_init(acpi_configfs_init);\n\nstatic void __exit acpi_configfs_exit(void)\n{\n\tconfigfs_unregister_default_group(acpi_table_group);\n\tconfigfs_unregister_subsystem(&acpi_configfs);\n}\nmodule_exit(acpi_configfs_exit);\n\nMODULE_AUTHOR(\"Octavian Purdila <octavian.purdila@intel.com>\");\nMODULE_DESCRIPTION(\"ACPI configfs support\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}