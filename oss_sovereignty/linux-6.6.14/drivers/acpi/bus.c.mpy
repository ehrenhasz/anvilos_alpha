{
  "module_name": "bus.c",
  "hash_id": "7529be5239ec0d111b1f0fdf463913c666de7172575d2a88912e5a41ae4a20ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/bus.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/pm.h>\n#include <linux/device.h>\n#include <linux/proc_fs.h>\n#include <linux/acpi.h>\n#include <linux/slab.h>\n#include <linux/regulator/machine.h>\n#include <linux/workqueue.h>\n#include <linux/reboot.h>\n#include <linux/delay.h>\n#ifdef CONFIG_X86\n#include <asm/mpspec.h>\n#include <linux/dmi.h>\n#endif\n#include <linux/acpi_viot.h>\n#include <linux/pci.h>\n#include <acpi/apei.h>\n#include <linux/suspend.h>\n#include <linux/prmt.h>\n\n#include \"internal.h\"\n\nstruct acpi_device *acpi_root;\nstruct proc_dir_entry *acpi_root_dir;\nEXPORT_SYMBOL(acpi_root_dir);\n\n#ifdef CONFIG_X86\n#ifdef CONFIG_ACPI_CUSTOM_DSDT\nstatic inline int set_copy_dsdt(const struct dmi_system_id *id)\n{\n\treturn 0;\n}\n#else\nstatic int set_copy_dsdt(const struct dmi_system_id *id)\n{\n\tpr_notice(\"%s detected - force copy of DSDT to local memory\\n\", id->ident);\n\tacpi_gbl_copy_dsdt_locally = 1;\n\treturn 0;\n}\n#endif\n\nstatic const struct dmi_system_id dsdt_dmi_table[] __initconst = {\n\t \n\t{\n\t .callback = set_copy_dsdt,\n\t .ident = \"TOSHIBA Satellite\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Satellite\"),\n\t\t},\n\t},\n\t{}\n};\n#endif\n\n \n\nacpi_status acpi_bus_get_status_handle(acpi_handle handle,\n\t\t\t\t       unsigned long long *sta)\n{\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(handle, \"_STA\", NULL, sta);\n\tif (ACPI_SUCCESS(status))\n\t\treturn AE_OK;\n\n\tif (status == AE_NOT_FOUND) {\n\t\t*sta = ACPI_STA_DEVICE_PRESENT | ACPI_STA_DEVICE_ENABLED |\n\t\t       ACPI_STA_DEVICE_UI      | ACPI_STA_DEVICE_FUNCTIONING;\n\t\treturn AE_OK;\n\t}\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(acpi_bus_get_status_handle);\n\nint acpi_bus_get_status(struct acpi_device *device)\n{\n\tacpi_status status;\n\tunsigned long long sta;\n\n\tif (acpi_device_override_status(device, &sta)) {\n\t\tacpi_set_device_status(device, sta);\n\t\treturn 0;\n\t}\n\n\t \n\tif (acpi_device_is_battery(device) && device->dep_unmet) {\n\t\tacpi_set_device_status(device, 0);\n\t\treturn 0;\n\t}\n\n\tstatus = acpi_bus_get_status_handle(device->handle, &sta);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tacpi_set_device_status(device, sta);\n\n\tif (device->status.functional && !device->status.present) {\n\t\tpr_debug(\"Device [%s] status [%08x]: functional but not present\\n\",\n\t\t\t device->pnp.bus_id, (u32)sta);\n\t}\n\n\tpr_debug(\"Device [%s] status [%08x]\\n\", device->pnp.bus_id, (u32)sta);\n\treturn 0;\n}\nEXPORT_SYMBOL(acpi_bus_get_status);\n\nvoid acpi_bus_private_data_handler(acpi_handle handle,\n\t\t\t\t   void *context)\n{\n\treturn;\n}\nEXPORT_SYMBOL(acpi_bus_private_data_handler);\n\nint acpi_bus_attach_private_data(acpi_handle handle, void *data)\n{\n\tacpi_status status;\n\n\tstatus = acpi_attach_data(handle,\n\t\t\tacpi_bus_private_data_handler, data);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_debug(handle, \"Error attaching device data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_bus_attach_private_data);\n\nint acpi_bus_get_private_data(acpi_handle handle, void **data)\n{\n\tacpi_status status;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tstatus = acpi_get_data(handle, acpi_bus_private_data_handler, data);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_debug(handle, \"No context for object\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_bus_get_private_data);\n\nvoid acpi_bus_detach_private_data(acpi_handle handle)\n{\n\tacpi_detach_data(handle, acpi_bus_private_data_handler);\n}\nEXPORT_SYMBOL_GPL(acpi_bus_detach_private_data);\n\nstatic void acpi_print_osc_error(acpi_handle handle,\n\t\t\t\t struct acpi_osc_context *context, char *error)\n{\n\tint i;\n\n\tacpi_handle_debug(handle, \"(%s): %s\\n\", context->uuid_str, error);\n\n\tpr_debug(\"_OSC request data:\");\n\tfor (i = 0; i < context->cap.length; i += sizeof(u32))\n\t\tpr_debug(\" %x\", *((u32 *)(context->cap.pointer + i)));\n\n\tpr_debug(\"\\n\");\n}\n\nacpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)\n{\n\tacpi_status status;\n\tstruct acpi_object_list input;\n\tunion acpi_object in_params[4];\n\tunion acpi_object *out_obj;\n\tguid_t guid;\n\tu32 errors;\n\tstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\n\n\tif (!context)\n\t\treturn AE_ERROR;\n\tif (guid_parse(context->uuid_str, &guid))\n\t\treturn AE_ERROR;\n\tcontext->ret.length = ACPI_ALLOCATE_BUFFER;\n\tcontext->ret.pointer = NULL;\n\n\t \n\tinput.count = 4;\n\tinput.pointer = in_params;\n\tin_params[0].type \t\t= ACPI_TYPE_BUFFER;\n\tin_params[0].buffer.length \t= 16;\n\tin_params[0].buffer.pointer\t= (u8 *)&guid;\n\tin_params[1].type \t\t= ACPI_TYPE_INTEGER;\n\tin_params[1].integer.value \t= context->rev;\n\tin_params[2].type \t\t= ACPI_TYPE_INTEGER;\n\tin_params[2].integer.value\t= context->cap.length/sizeof(u32);\n\tin_params[3].type\t\t= ACPI_TYPE_BUFFER;\n\tin_params[3].buffer.length \t= context->cap.length;\n\tin_params[3].buffer.pointer \t= context->cap.pointer;\n\n\tstatus = acpi_evaluate_object(handle, \"_OSC\", &input, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tif (!output.length)\n\t\treturn AE_NULL_OBJECT;\n\n\tout_obj = output.pointer;\n\tif (out_obj->type != ACPI_TYPE_BUFFER\n\t\t|| out_obj->buffer.length != context->cap.length) {\n\t\tacpi_print_osc_error(handle, context,\n\t\t\t\"_OSC evaluation returned wrong type\");\n\t\tstatus = AE_TYPE;\n\t\tgoto out_kfree;\n\t}\n\t \n\terrors = *((u32 *)out_obj->buffer.pointer) & ~(1 << 0);\n\tif (errors) {\n\t\tif (errors & OSC_REQUEST_ERROR)\n\t\t\tacpi_print_osc_error(handle, context,\n\t\t\t\t\"_OSC request failed\");\n\t\tif (errors & OSC_INVALID_UUID_ERROR)\n\t\t\tacpi_print_osc_error(handle, context,\n\t\t\t\t\"_OSC invalid UUID\");\n\t\tif (errors & OSC_INVALID_REVISION_ERROR)\n\t\t\tacpi_print_osc_error(handle, context,\n\t\t\t\t\"_OSC invalid revision\");\n\t\tif (errors & OSC_CAPABILITIES_MASK_ERROR) {\n\t\t\tif (((u32 *)context->cap.pointer)[OSC_QUERY_DWORD]\n\t\t\t    & OSC_QUERY_ENABLE)\n\t\t\t\tgoto out_success;\n\t\t\tstatus = AE_SUPPORT;\n\t\t\tgoto out_kfree;\n\t\t}\n\t\tstatus = AE_ERROR;\n\t\tgoto out_kfree;\n\t}\nout_success:\n\tcontext->ret.length = out_obj->buffer.length;\n\tcontext->ret.pointer = kmemdup(out_obj->buffer.pointer,\n\t\t\t\t       context->ret.length, GFP_KERNEL);\n\tif (!context->ret.pointer) {\n\t\tstatus =  AE_NO_MEMORY;\n\t\tgoto out_kfree;\n\t}\n\tstatus =  AE_OK;\n\nout_kfree:\n\tkfree(output.pointer);\n\treturn status;\n}\nEXPORT_SYMBOL(acpi_run_osc);\n\nbool osc_sb_apei_support_acked;\n\n \nbool osc_pc_lpi_support_confirmed;\nEXPORT_SYMBOL_GPL(osc_pc_lpi_support_confirmed);\n\n \nbool osc_cpc_flexible_adr_space_confirmed;\nEXPORT_SYMBOL_GPL(osc_cpc_flexible_adr_space_confirmed);\n\n \nbool osc_sb_native_usb4_support_confirmed;\nEXPORT_SYMBOL_GPL(osc_sb_native_usb4_support_confirmed);\n\nbool osc_sb_cppc2_support_acked;\n\nstatic u8 sb_uuid_str[] = \"0811B06E-4A27-44F9-8D60-3CBBC22E7B48\";\nstatic void acpi_bus_osc_negotiate_platform_control(void)\n{\n\tu32 capbuf[2], *capbuf_ret;\n\tstruct acpi_osc_context context = {\n\t\t.uuid_str = sb_uuid_str,\n\t\t.rev = 1,\n\t\t.cap.length = 8,\n\t\t.cap.pointer = capbuf,\n\t};\n\tacpi_handle handle;\n\n\tcapbuf[OSC_QUERY_DWORD] = OSC_QUERY_ENABLE;\n\tcapbuf[OSC_SUPPORT_DWORD] = OSC_SB_PR3_SUPPORT;  \n\tif (IS_ENABLED(CONFIG_ACPI_PROCESSOR_AGGREGATOR))\n\t\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PAD_SUPPORT;\n\tif (IS_ENABLED(CONFIG_ACPI_PROCESSOR))\n\t\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PPC_OST_SUPPORT;\n\n\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_HOTPLUG_OST_SUPPORT;\n\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PCLPI_SUPPORT;\n\tif (IS_ENABLED(CONFIG_ACPI_PRMT))\n\t\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_PRM_SUPPORT;\n\tif (IS_ENABLED(CONFIG_ACPI_FFH))\n\t\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_FFH_OPR_SUPPORT;\n\n#ifdef CONFIG_ARM64\n\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_GENERIC_INITIATOR_SUPPORT;\n#endif\n#ifdef CONFIG_X86\n\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_GENERIC_INITIATOR_SUPPORT;\n#endif\n\n#ifdef CONFIG_ACPI_CPPC_LIB\n\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_CPC_SUPPORT;\n\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_CPCV2_SUPPORT;\n#endif\n\n\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_CPC_FLEXIBLE_ADR_SPACE;\n\n\tif (IS_ENABLED(CONFIG_SCHED_MC_PRIO))\n\t\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_CPC_DIVERSE_HIGH_SUPPORT;\n\n\tif (IS_ENABLED(CONFIG_USB4))\n\t\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_NATIVE_USB4_SUPPORT;\n\n\tif (!ghes_disable)\n\t\tcapbuf[OSC_SUPPORT_DWORD] |= OSC_SB_APEI_SUPPORT;\n\tif (ACPI_FAILURE(acpi_get_handle(NULL, \"\\\\_SB\", &handle)))\n\t\treturn;\n\n\tif (ACPI_FAILURE(acpi_run_osc(handle, &context)))\n\t\treturn;\n\n\tcapbuf_ret = context.ret.pointer;\n\tif (context.ret.length <= OSC_SUPPORT_DWORD) {\n\t\tkfree(context.ret.pointer);\n\t\treturn;\n\t}\n\n\t \n\tcapbuf[OSC_QUERY_DWORD] = 0;\n\tcapbuf[OSC_SUPPORT_DWORD] = capbuf_ret[OSC_SUPPORT_DWORD];\n\tkfree(context.ret.pointer);\n\n\tif (ACPI_FAILURE(acpi_run_osc(handle, &context)))\n\t\treturn;\n\n\tcapbuf_ret = context.ret.pointer;\n\tif (context.ret.length > OSC_SUPPORT_DWORD) {\n#ifdef CONFIG_ACPI_CPPC_LIB\n\t\tosc_sb_cppc2_support_acked = capbuf_ret[OSC_SUPPORT_DWORD] & OSC_SB_CPCV2_SUPPORT;\n#endif\n\n\t\tosc_sb_apei_support_acked =\n\t\t\tcapbuf_ret[OSC_SUPPORT_DWORD] & OSC_SB_APEI_SUPPORT;\n\t\tosc_pc_lpi_support_confirmed =\n\t\t\tcapbuf_ret[OSC_SUPPORT_DWORD] & OSC_SB_PCLPI_SUPPORT;\n\t\tosc_sb_native_usb4_support_confirmed =\n\t\t\tcapbuf_ret[OSC_SUPPORT_DWORD] & OSC_SB_NATIVE_USB4_SUPPORT;\n\t\tosc_cpc_flexible_adr_space_confirmed =\n\t\t\tcapbuf_ret[OSC_SUPPORT_DWORD] & OSC_SB_CPC_FLEXIBLE_ADR_SPACE;\n\t}\n\n\tkfree(context.ret.pointer);\n}\n\n \nu32 osc_sb_native_usb4_control;\nEXPORT_SYMBOL_GPL(osc_sb_native_usb4_control);\n\nstatic void acpi_bus_decode_usb_osc(const char *msg, u32 bits)\n{\n\tpr_info(\"%s USB3%c DisplayPort%c PCIe%c XDomain%c\\n\", msg,\n\t       (bits & OSC_USB_USB3_TUNNELING) ? '+' : '-',\n\t       (bits & OSC_USB_DP_TUNNELING) ? '+' : '-',\n\t       (bits & OSC_USB_PCIE_TUNNELING) ? '+' : '-',\n\t       (bits & OSC_USB_XDOMAIN) ? '+' : '-');\n}\n\nstatic u8 sb_usb_uuid_str[] = \"23A0D13A-26AB-486C-9C5F-0FFA525A575A\";\nstatic void acpi_bus_osc_negotiate_usb_control(void)\n{\n\tu32 capbuf[3];\n\tstruct acpi_osc_context context = {\n\t\t.uuid_str = sb_usb_uuid_str,\n\t\t.rev = 1,\n\t\t.cap.length = sizeof(capbuf),\n\t\t.cap.pointer = capbuf,\n\t};\n\tacpi_handle handle;\n\tacpi_status status;\n\tu32 control;\n\n\tif (!osc_sb_native_usb4_support_confirmed)\n\t\treturn;\n\n\tif (ACPI_FAILURE(acpi_get_handle(NULL, \"\\\\_SB\", &handle)))\n\t\treturn;\n\n\tcontrol = OSC_USB_USB3_TUNNELING | OSC_USB_DP_TUNNELING |\n\t\t  OSC_USB_PCIE_TUNNELING | OSC_USB_XDOMAIN;\n\n\tcapbuf[OSC_QUERY_DWORD] = 0;\n\tcapbuf[OSC_SUPPORT_DWORD] = 0;\n\tcapbuf[OSC_CONTROL_DWORD] = control;\n\n\tstatus = acpi_run_osc(handle, &context);\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\n\tif (context.ret.length != sizeof(capbuf)) {\n\t\tpr_info(\"USB4 _OSC: returned invalid length buffer\\n\");\n\t\tgoto out_free;\n\t}\n\n\tosc_sb_native_usb4_control =\n\t\tcontrol &  acpi_osc_ctx_get_pci_control(&context);\n\n\tacpi_bus_decode_usb_osc(\"USB4 _OSC: OS supports\", control);\n\tacpi_bus_decode_usb_osc(\"USB4 _OSC: OS controls\",\n\t\t\t\tosc_sb_native_usb4_control);\n\nout_free:\n\tkfree(context.ret.pointer);\n}\n\n \n\n \nstatic void acpi_bus_notify(acpi_handle handle, u32 type, void *data)\n{\n\tstruct acpi_device *adev;\n\n\tswitch (type) {\n\tcase ACPI_NOTIFY_BUS_CHECK:\n\t\tacpi_handle_debug(handle, \"ACPI_NOTIFY_BUS_CHECK event\\n\");\n\t\tbreak;\n\n\tcase ACPI_NOTIFY_DEVICE_CHECK:\n\t\tacpi_handle_debug(handle, \"ACPI_NOTIFY_DEVICE_CHECK event\\n\");\n\t\tbreak;\n\n\tcase ACPI_NOTIFY_DEVICE_WAKE:\n\t\tacpi_handle_debug(handle, \"ACPI_NOTIFY_DEVICE_WAKE event\\n\");\n\t\treturn;\n\n\tcase ACPI_NOTIFY_EJECT_REQUEST:\n\t\tacpi_handle_debug(handle, \"ACPI_NOTIFY_EJECT_REQUEST event\\n\");\n\t\tbreak;\n\n\tcase ACPI_NOTIFY_DEVICE_CHECK_LIGHT:\n\t\tacpi_handle_debug(handle, \"ACPI_NOTIFY_DEVICE_CHECK_LIGHT event\\n\");\n\t\t \n\t\treturn;\n\n\tcase ACPI_NOTIFY_FREQUENCY_MISMATCH:\n\t\tacpi_handle_err(handle, \"Device cannot be configured due \"\n\t\t\t\t\"to a frequency mismatch\\n\");\n\t\treturn;\n\n\tcase ACPI_NOTIFY_BUS_MODE_MISMATCH:\n\t\tacpi_handle_err(handle, \"Device cannot be configured due \"\n\t\t\t\t\"to a bus mode mismatch\\n\");\n\t\treturn;\n\n\tcase ACPI_NOTIFY_POWER_FAULT:\n\t\tacpi_handle_err(handle, \"Device has suffered a power fault\\n\");\n\t\treturn;\n\n\tdefault:\n\t\tacpi_handle_debug(handle, \"Unknown event type 0x%x\\n\", type);\n\t\treturn;\n\t}\n\n\tadev = acpi_get_acpi_dev(handle);\n\n\tif (adev && ACPI_SUCCESS(acpi_hotplug_schedule(adev, type)))\n\t\treturn;\n\n\tacpi_put_acpi_dev(adev);\n\n\tacpi_evaluate_ost(handle, type, ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);\n}\n\nstatic void acpi_notify_device(acpi_handle handle, u32 event, void *data)\n{\n\tstruct acpi_device *device = data;\n\tstruct acpi_driver *acpi_drv = to_acpi_driver(device->dev.driver);\n\n\tacpi_drv->ops.notify(device, event);\n}\n\nstatic int acpi_device_install_notify_handler(struct acpi_device *device,\n\t\t\t\t\t      struct acpi_driver *acpi_drv)\n{\n\tu32 type = acpi_drv->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS ?\n\t\t\t\tACPI_ALL_NOTIFY : ACPI_DEVICE_NOTIFY;\n\tacpi_status status;\n\n\tstatus = acpi_install_notify_handler(device->handle, type,\n\t\t\t\t\t     acpi_notify_device, device);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void acpi_device_remove_notify_handler(struct acpi_device *device,\n\t\t\t\t\t      struct acpi_driver *acpi_drv)\n{\n\tu32 type = acpi_drv->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS ?\n\t\t\t\tACPI_ALL_NOTIFY : ACPI_DEVICE_NOTIFY;\n\n\tacpi_remove_notify_handler(device->handle, type,\n\t\t\t\t   acpi_notify_device);\n\n\tacpi_os_wait_events_complete();\n}\n\nint acpi_dev_install_notify_handler(struct acpi_device *adev,\n\t\t\t\t    u32 handler_type,\n\t\t\t\t    acpi_notify_handler handler)\n{\n\tacpi_status status;\n\n\tstatus = acpi_install_notify_handler(adev->handle, handler_type,\n\t\t\t\t\t     handler, adev);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_dev_install_notify_handler);\n\nvoid acpi_dev_remove_notify_handler(struct acpi_device *adev,\n\t\t\t\t    u32 handler_type,\n\t\t\t\t    acpi_notify_handler handler)\n{\n\tacpi_remove_notify_handler(adev->handle, handler_type, handler);\n\tacpi_os_wait_events_complete();\n}\nEXPORT_SYMBOL_GPL(acpi_dev_remove_notify_handler);\n\n \n\n#define ACPI_SB_NOTIFY_SHUTDOWN_REQUEST 0x81\n#define ACPI_SB_INDICATE_INTERVAL\t10000\n\nstatic void sb_notify_work(struct work_struct *dummy)\n{\n\tacpi_handle sb_handle;\n\n\torderly_poweroff(true);\n\n\t \n\tacpi_get_handle(NULL, \"\\\\_SB\", &sb_handle);\n\twhile (1) {\n\t\tpr_info(\"Graceful shutdown in progress.\\n\");\n\t\tacpi_evaluate_ost(sb_handle, ACPI_OST_EC_OSPM_SHUTDOWN,\n\t\t\t\tACPI_OST_SC_OS_SHUTDOWN_IN_PROGRESS, NULL);\n\t\tmsleep(ACPI_SB_INDICATE_INTERVAL);\n\t}\n}\n\nstatic void acpi_sb_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstatic DECLARE_WORK(acpi_sb_work, sb_notify_work);\n\n\tif (event == ACPI_SB_NOTIFY_SHUTDOWN_REQUEST) {\n\t\tif (!work_busy(&acpi_sb_work))\n\t\t\tschedule_work(&acpi_sb_work);\n\t} else {\n\t\tpr_warn(\"event %x is not supported by \\\\_SB device\\n\", event);\n\t}\n}\n\nstatic int __init acpi_setup_sb_notify_handler(void)\n{\n\tacpi_handle sb_handle;\n\n\tif (ACPI_FAILURE(acpi_get_handle(NULL, \"\\\\_SB\", &sb_handle)))\n\t\treturn -ENXIO;\n\n\tif (ACPI_FAILURE(acpi_install_notify_handler(sb_handle, ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t\tacpi_sb_notify, NULL)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \n\n \nstruct device *acpi_get_first_physical_node(struct acpi_device *adev)\n{\n\tstruct mutex *physical_node_lock = &adev->physical_node_lock;\n\tstruct device *phys_dev;\n\n\tmutex_lock(physical_node_lock);\n\tif (list_empty(&adev->physical_node_list)) {\n\t\tphys_dev = NULL;\n\t} else {\n\t\tconst struct acpi_device_physical_node *node;\n\n\t\tnode = list_first_entry(&adev->physical_node_list,\n\t\t\t\t\tstruct acpi_device_physical_node, node);\n\n\t\tphys_dev = node->dev;\n\t}\n\tmutex_unlock(physical_node_lock);\n\treturn phys_dev;\n}\nEXPORT_SYMBOL_GPL(acpi_get_first_physical_node);\n\nstatic struct acpi_device *acpi_primary_dev_companion(struct acpi_device *adev,\n\t\t\t\t\t\t      const struct device *dev)\n{\n\tconst struct device *phys_dev = acpi_get_first_physical_node(adev);\n\n\treturn phys_dev && phys_dev == dev ? adev : NULL;\n}\n\n \nbool acpi_device_is_first_physical_node(struct acpi_device *adev,\n\t\t\t\t\tconst struct device *dev)\n{\n\treturn !!acpi_primary_dev_companion(adev, dev);\n}\n\n \nconst struct acpi_device *acpi_companion_match(const struct device *dev)\n{\n\tstruct acpi_device *adev;\n\n\tadev = ACPI_COMPANION(dev);\n\tif (!adev)\n\t\treturn NULL;\n\n\tif (list_empty(&adev->pnp.ids))\n\t\treturn NULL;\n\n\treturn acpi_primary_dev_companion(adev, dev);\n}\n\n \nstatic bool acpi_of_match_device(const struct acpi_device *adev,\n\t\t\t\t const struct of_device_id *of_match_table,\n\t\t\t\t const struct of_device_id **of_id)\n{\n\tconst union acpi_object *of_compatible, *obj;\n\tint i, nval;\n\n\tif (!adev)\n\t\treturn false;\n\n\tof_compatible = adev->data.of_compatible;\n\tif (!of_match_table || !of_compatible)\n\t\treturn false;\n\n\tif (of_compatible->type == ACPI_TYPE_PACKAGE) {\n\t\tnval = of_compatible->package.count;\n\t\tobj = of_compatible->package.elements;\n\t} else {  \n\t\tnval = 1;\n\t\tobj = of_compatible;\n\t}\n\t \n\tfor (i = 0; i < nval; i++, obj++) {\n\t\tconst struct of_device_id *id;\n\n\t\tfor (id = of_match_table; id->compatible[0]; id++)\n\t\t\tif (!strcasecmp(obj->string.pointer, id->compatible)) {\n\t\t\t\tif (of_id)\n\t\t\t\t\t*of_id = id;\n\t\t\t\treturn true;\n\t\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool acpi_of_modalias(struct acpi_device *adev,\n\t\t\t     char *modalias, size_t len)\n{\n\tconst union acpi_object *of_compatible;\n\tconst union acpi_object *obj;\n\tconst char *str, *chr;\n\n\tof_compatible = adev->data.of_compatible;\n\tif (!of_compatible)\n\t\treturn false;\n\n\tif (of_compatible->type == ACPI_TYPE_PACKAGE)\n\t\tobj = of_compatible->package.elements;\n\telse  \n\t\tobj = of_compatible;\n\n\tstr = obj->string.pointer;\n\tchr = strchr(str, ',');\n\tstrscpy(modalias, chr ? chr + 1 : str, len);\n\n\treturn true;\n}\n\n \nvoid acpi_set_modalias(struct acpi_device *adev, const char *default_id,\n\t\t       char *modalias, size_t len)\n{\n\tif (!acpi_of_modalias(adev, modalias, len))\n\t\tstrscpy(modalias, default_id, len);\n}\nEXPORT_SYMBOL_GPL(acpi_set_modalias);\n\nstatic bool __acpi_match_device_cls(const struct acpi_device_id *id,\n\t\t\t\t    struct acpi_hardware_id *hwid)\n{\n\tint i, msk, byte_shift;\n\tchar buf[3];\n\n\tif (!id->cls)\n\t\treturn false;\n\n\t \n\tfor (i = 1; i <= 3; i++) {\n\t\tbyte_shift = 8 * (3 - i);\n\t\tmsk = (id->cls_msk >> byte_shift) & 0xFF;\n\t\tif (!msk)\n\t\t\tcontinue;\n\n\t\tsprintf(buf, \"%02x\", (id->cls >> byte_shift) & msk);\n\t\tif (strncmp(buf, &hwid->id[(i - 1) * 2], 2))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool __acpi_match_device(const struct acpi_device *device,\n\t\t\t\tconst struct acpi_device_id *acpi_ids,\n\t\t\t\tconst struct of_device_id *of_ids,\n\t\t\t\tconst struct acpi_device_id **acpi_id,\n\t\t\t\tconst struct of_device_id **of_id)\n{\n\tconst struct acpi_device_id *id;\n\tstruct acpi_hardware_id *hwid;\n\n\t \n\tif (!device || !device->status.present)\n\t\treturn false;\n\n\tlist_for_each_entry(hwid, &device->pnp.ids, list) {\n\t\t \n\t\tif (acpi_ids) {\n\t\t\tfor (id = acpi_ids; id->id[0] || id->cls; id++) {\n\t\t\t\tif (id->id[0] && !strcmp((char *)id->id, hwid->id))\n\t\t\t\t\tgoto out_acpi_match;\n\t\t\t\tif (id->cls && __acpi_match_device_cls(id, hwid))\n\t\t\t\t\tgoto out_acpi_match;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!strcmp(ACPI_DT_NAMESPACE_HID, hwid->id))\n\t\t\treturn acpi_of_match_device(device, of_ids, of_id);\n\t}\n\treturn false;\n\nout_acpi_match:\n\tif (acpi_id)\n\t\t*acpi_id = id;\n\treturn true;\n}\n\n \nconst struct acpi_device_id *acpi_match_acpi_device(const struct acpi_device_id *ids,\n\t\t\t\t\t\t    const struct acpi_device *adev)\n{\n\tconst struct acpi_device_id *id = NULL;\n\n\t__acpi_match_device(adev, ids, NULL, &id, NULL);\n\treturn id;\n}\nEXPORT_SYMBOL_GPL(acpi_match_acpi_device);\n\n \nconst struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,\n\t\t\t\t\t       const struct device *dev)\n{\n\treturn acpi_match_acpi_device(ids, acpi_companion_match(dev));\n}\nEXPORT_SYMBOL_GPL(acpi_match_device);\n\nstatic const void *acpi_of_device_get_match_data(const struct device *dev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tconst struct of_device_id *match = NULL;\n\n\tif (!acpi_of_match_device(adev, dev->driver->of_match_table, &match))\n\t\treturn NULL;\n\n\treturn match->data;\n}\n\nconst void *acpi_device_get_match_data(const struct device *dev)\n{\n\tconst struct acpi_device_id *acpi_ids = dev->driver->acpi_match_table;\n\tconst struct acpi_device_id *match;\n\n\tif (!acpi_ids)\n\t\treturn acpi_of_device_get_match_data(dev);\n\n\tmatch = acpi_match_device(acpi_ids, dev);\n\tif (!match)\n\t\treturn NULL;\n\n\treturn (const void *)match->driver_data;\n}\nEXPORT_SYMBOL_GPL(acpi_device_get_match_data);\n\nint acpi_match_device_ids(struct acpi_device *device,\n\t\t\t  const struct acpi_device_id *ids)\n{\n\treturn __acpi_match_device(device, ids, NULL, NULL, NULL) ? 0 : -ENOENT;\n}\nEXPORT_SYMBOL(acpi_match_device_ids);\n\nbool acpi_driver_match_device(struct device *dev,\n\t\t\t      const struct device_driver *drv)\n{\n\tconst struct acpi_device_id *acpi_ids = drv->acpi_match_table;\n\tconst struct of_device_id *of_ids = drv->of_match_table;\n\n\tif (!acpi_ids)\n\t\treturn acpi_of_match_device(ACPI_COMPANION(dev), of_ids, NULL);\n\n\treturn __acpi_match_device(acpi_companion_match(dev), acpi_ids, of_ids, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(acpi_driver_match_device);\n\n \n\n \nint acpi_bus_register_driver(struct acpi_driver *driver)\n{\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\tdriver->drv.name = driver->name;\n\tdriver->drv.bus = &acpi_bus_type;\n\tdriver->drv.owner = driver->owner;\n\n\treturn driver_register(&driver->drv);\n}\n\nEXPORT_SYMBOL(acpi_bus_register_driver);\n\n \nvoid acpi_bus_unregister_driver(struct acpi_driver *driver)\n{\n\tdriver_unregister(&driver->drv);\n}\n\nEXPORT_SYMBOL(acpi_bus_unregister_driver);\n\n \n\nstatic int acpi_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tstruct acpi_driver *acpi_drv = to_acpi_driver(drv);\n\n\treturn acpi_dev->flags.match_driver\n\t\t&& !acpi_match_device_ids(acpi_dev, acpi_drv->ids);\n}\n\nstatic int acpi_device_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\treturn __acpi_device_uevent_modalias(to_acpi_device(dev), env);\n}\n\nstatic int acpi_device_probe(struct device *dev)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tstruct acpi_driver *acpi_drv = to_acpi_driver(dev->driver);\n\tint ret;\n\n\tif (acpi_dev->handler && !acpi_is_pnp_device(acpi_dev))\n\t\treturn -EINVAL;\n\n\tif (!acpi_drv->ops.add)\n\t\treturn -ENOSYS;\n\n\tret = acpi_drv->ops.add(acpi_dev);\n\tif (ret) {\n\t\tacpi_dev->driver_data = NULL;\n\t\treturn ret;\n\t}\n\n\tpr_debug(\"Driver [%s] successfully bound to device [%s]\\n\",\n\t\t acpi_drv->name, acpi_dev->pnp.bus_id);\n\n\tif (acpi_drv->ops.notify) {\n\t\tret = acpi_device_install_notify_handler(acpi_dev, acpi_drv);\n\t\tif (ret) {\n\t\t\tif (acpi_drv->ops.remove)\n\t\t\t\tacpi_drv->ops.remove(acpi_dev);\n\n\t\t\tacpi_dev->driver_data = NULL;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpr_debug(\"Found driver [%s] for device [%s]\\n\", acpi_drv->name,\n\t\t acpi_dev->pnp.bus_id);\n\n\tget_device(dev);\n\treturn 0;\n}\n\nstatic void acpi_device_remove(struct device *dev)\n{\n\tstruct acpi_device *acpi_dev = to_acpi_device(dev);\n\tstruct acpi_driver *acpi_drv = to_acpi_driver(dev->driver);\n\n\tif (acpi_drv->ops.notify)\n\t\tacpi_device_remove_notify_handler(acpi_dev, acpi_drv);\n\n\tif (acpi_drv->ops.remove)\n\t\tacpi_drv->ops.remove(acpi_dev);\n\n\tacpi_dev->driver_data = NULL;\n\n\tput_device(dev);\n}\n\nstruct bus_type acpi_bus_type = {\n\t.name\t\t= \"acpi\",\n\t.match\t\t= acpi_bus_match,\n\t.probe\t\t= acpi_device_probe,\n\t.remove\t\t= acpi_device_remove,\n\t.uevent\t\t= acpi_device_uevent,\n};\n\nint acpi_bus_for_each_dev(int (*fn)(struct device *, void *), void *data)\n{\n\treturn bus_for_each_dev(&acpi_bus_type, NULL, data, fn);\n}\nEXPORT_SYMBOL_GPL(acpi_bus_for_each_dev);\n\nstruct acpi_dev_walk_context {\n\tint (*fn)(struct acpi_device *, void *);\n\tvoid *data;\n};\n\nstatic int acpi_dev_for_one_check(struct device *dev, void *context)\n{\n\tstruct acpi_dev_walk_context *adwc = context;\n\n\tif (dev->bus != &acpi_bus_type)\n\t\treturn 0;\n\n\treturn adwc->fn(to_acpi_device(dev), adwc->data);\n}\nEXPORT_SYMBOL_GPL(acpi_dev_for_each_child);\n\nint acpi_dev_for_each_child(struct acpi_device *adev,\n\t\t\t    int (*fn)(struct acpi_device *, void *), void *data)\n{\n\tstruct acpi_dev_walk_context adwc = {\n\t\t.fn = fn,\n\t\t.data = data,\n\t};\n\n\treturn device_for_each_child(&adev->dev, &adwc, acpi_dev_for_one_check);\n}\n\nint acpi_dev_for_each_child_reverse(struct acpi_device *adev,\n\t\t\t\t    int (*fn)(struct acpi_device *, void *),\n\t\t\t\t    void *data)\n{\n\tstruct acpi_dev_walk_context adwc = {\n\t\t.fn = fn,\n\t\t.data = data,\n\t};\n\n\treturn device_for_each_child_reverse(&adev->dev, &adwc, acpi_dev_for_one_check);\n}\n\n \n\nstatic int __init acpi_bus_init_irq(void)\n{\n\tacpi_status status;\n\tchar *message = NULL;\n\n\n\t \n\n\tswitch (acpi_irq_model) {\n\tcase ACPI_IRQ_MODEL_PIC:\n\t\tmessage = \"PIC\";\n\t\tbreak;\n\tcase ACPI_IRQ_MODEL_IOAPIC:\n\t\tmessage = \"IOAPIC\";\n\t\tbreak;\n\tcase ACPI_IRQ_MODEL_IOSAPIC:\n\t\tmessage = \"IOSAPIC\";\n\t\tbreak;\n\tcase ACPI_IRQ_MODEL_GIC:\n\t\tmessage = \"GIC\";\n\t\tbreak;\n\tcase ACPI_IRQ_MODEL_PLATFORM:\n\t\tmessage = \"platform specific model\";\n\t\tbreak;\n\tcase ACPI_IRQ_MODEL_LPIC:\n\t\tmessage = \"LPIC\";\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"Unknown interrupt routing model\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpr_info(\"Using %s for interrupt routing\\n\", message);\n\n\tstatus = acpi_execute_simple_method(NULL, \"\\\\_PIC\", acpi_irq_model);\n\tif (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {\n\t\tpr_info(\"_PIC evaluation failed: %s\\n\", acpi_format_exception(status));\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nvoid __init acpi_early_init(void)\n{\n\tacpi_status status;\n\n\tif (acpi_disabled)\n\t\treturn;\n\n\tpr_info(\"Core revision %08x\\n\", ACPI_CA_VERSION);\n\n\t \n\tif (!acpi_strict)\n\t\tacpi_gbl_enable_interpreter_slack = TRUE;\n\n\tacpi_permanent_mmap = true;\n\n#ifdef CONFIG_X86\n\t \n\tdmi_check_system(dsdt_dmi_table);\n#endif\n\n\tstatus = acpi_reallocate_root_table();\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Unable to reallocate ACPI tables\\n\");\n\t\tgoto error0;\n\t}\n\n\tstatus = acpi_initialize_subsystem();\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Unable to initialize the ACPI Interpreter\\n\");\n\t\tgoto error0;\n\t}\n\n#ifdef CONFIG_X86\n\tif (!acpi_ioapic) {\n\t\t \n\t\tif (!(acpi_sci_flags & ACPI_MADT_TRIGGER_MASK)) {\n\t\t\tacpi_sci_flags &= ~ACPI_MADT_TRIGGER_MASK;\n\t\t\tacpi_sci_flags |= ACPI_MADT_TRIGGER_LEVEL;\n\t\t}\n\t\t \n\t\tacpi_pic_sci_set_trigger(acpi_gbl_FADT.sci_interrupt,\n\t\t\t\t\t (acpi_sci_flags & ACPI_MADT_TRIGGER_MASK) >> 2);\n\t} else {\n\t\t \n\t\tacpi_gbl_FADT.sci_interrupt = acpi_sci_override_gsi;\n\t}\n#endif\n\treturn;\n\n error0:\n\tdisable_acpi();\n}\n\n \nvoid __init acpi_subsystem_init(void)\n{\n\tacpi_status status;\n\n\tif (acpi_disabled)\n\t\treturn;\n\n\tstatus = acpi_enable_subsystem(~ACPI_NO_ACPI_ENABLE);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Unable to enable ACPI\\n\");\n\t\tdisable_acpi();\n\t} else {\n\t\t \n\t\tregulator_has_full_constraints();\n\t}\n}\n\nstatic acpi_status acpi_bus_table_handler(u32 event, void *table, void *context)\n{\n\tif (event == ACPI_TABLE_EVENT_LOAD)\n\t\tacpi_scan_table_notify();\n\n\treturn acpi_sysfs_table_handler(event, table, context);\n}\n\nstatic int __init acpi_bus_init(void)\n{\n\tint result;\n\tacpi_status status;\n\n\tacpi_os_initialize1();\n\n\tstatus = acpi_load_tables();\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Unable to load the System Description Tables\\n\");\n\t\tgoto error1;\n\t}\n\n\t \n\tacpi_ec_ecdt_probe();\n\n\tstatus = acpi_enable_subsystem(ACPI_NO_ACPI_ENABLE);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Unable to start the ACPI Interpreter\\n\");\n\t\tgoto error1;\n\t}\n\n\tstatus = acpi_initialize_objects(ACPI_FULL_INITIALIZATION);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Unable to initialize ACPI objects\\n\");\n\t\tgoto error1;\n\t}\n\n\t \n\tacpi_bus_osc_negotiate_platform_control();\n\tacpi_bus_osc_negotiate_usb_control();\n\n\t \n\tstatus = acpi_install_table_handler(acpi_bus_table_handler, NULL);\n\n\tacpi_sysfs_init();\n\n\tacpi_early_processor_control_setup();\n\n\t \n\tacpi_ec_dsdt_probe();\n\n\tpr_info(\"Interpreter enabled\\n\");\n\n\t \n\tacpi_sleep_init();\n\n\t \n\tresult = acpi_bus_init_irq();\n\tif (result)\n\t\tgoto error1;\n\n\t \n\tstatus =\n\t    acpi_install_notify_handler(ACPI_ROOT_OBJECT, ACPI_SYSTEM_NOTIFY,\n\t\t\t\t\t&acpi_bus_notify, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Unable to register for system notifications\\n\");\n\t\tgoto error1;\n\t}\n\n\t \n\tacpi_root_dir = proc_mkdir(ACPI_BUS_FILE_ROOT, NULL);\n\n\tresult = bus_register(&acpi_bus_type);\n\tif (!result)\n\t\treturn 0;\n\n\t \n      error1:\n\tacpi_terminate();\n\treturn -ENODEV;\n}\n\nstruct kobject *acpi_kobj;\nEXPORT_SYMBOL_GPL(acpi_kobj);\n\nstatic int __init acpi_init(void)\n{\n\tint result;\n\n\tif (acpi_disabled) {\n\t\tpr_info(\"Interpreter disabled.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tacpi_kobj = kobject_create_and_add(\"acpi\", firmware_kobj);\n\tif (!acpi_kobj)\n\t\tpr_debug(\"%s: kset create error\\n\", __func__);\n\n\tinit_prmt();\n\tacpi_init_pcc();\n\tresult = acpi_bus_init();\n\tif (result) {\n\t\tkobject_put(acpi_kobj);\n\t\tdisable_acpi();\n\t\treturn result;\n\t}\n\tacpi_init_ffh();\n\n\tpci_mmcfg_late_init();\n\tacpi_viot_early_init();\n\tacpi_hest_init();\n\tacpi_ghes_init();\n\tacpi_arm_init();\n\tacpi_scan_init();\n\tacpi_ec_init();\n\tacpi_debugfs_init();\n\tacpi_sleep_proc_init();\n\tacpi_wakeup_device_init();\n\tacpi_debugger_init();\n\tacpi_setup_sb_notify_handler();\n\tacpi_viot_init();\n\treturn 0;\n}\n\nsubsys_initcall(acpi_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}