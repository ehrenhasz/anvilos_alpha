{
  "module_name": "acpi_tad.c",
  "hash_id": "d0fc50395c3c60389db21f06a91b57f554e36df5e954399587aac1b5dea64e33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_tad.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/suspend.h>\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Rafael J. Wysocki\");\n\n \n#define ACPI_TAD_AC_WAKE\tBIT(0)\n#define ACPI_TAD_DC_WAKE\tBIT(1)\n#define ACPI_TAD_RT\t\tBIT(2)\n#define ACPI_TAD_RT_IN_MS\tBIT(3)\n#define ACPI_TAD_S4_S5__GWS\tBIT(4)\n#define ACPI_TAD_AC_S4_WAKE\tBIT(5)\n#define ACPI_TAD_AC_S5_WAKE\tBIT(6)\n#define ACPI_TAD_DC_S4_WAKE\tBIT(7)\n#define ACPI_TAD_DC_S5_WAKE\tBIT(8)\n\n \n#define ACPI_TAD_AC_TIMER\t(u32)0\n#define ACPI_TAD_DC_TIMER\t(u32)1\n\n \n#define ACPI_TAD_WAKE_DISABLED\t(~(u32)0)\n\nstruct acpi_tad_driver_data {\n\tu32 capabilities;\n};\n\nstruct acpi_tad_rt {\n\tu16 year;   \n\tu8 month;   \n\tu8 day;     \n\tu8 hour;    \n\tu8 minute;  \n\tu8 second;  \n\tu8 valid;   \n\tu16 msec;   \n\ts16 tz;     \n\tu8 daylight;\n\tu8 padding[3];  \n} __packed;\n\nstatic int acpi_tad_set_real_time(struct device *dev, struct acpi_tad_rt *rt)\n{\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tunion acpi_object args[] = {\n\t\t{ .type = ACPI_TYPE_BUFFER, },\n\t};\n\tstruct acpi_object_list arg_list = {\n\t\t.pointer = args,\n\t\t.count = ARRAY_SIZE(args),\n\t};\n\tunsigned long long retval;\n\tacpi_status status;\n\n\tif (rt->year < 1900 || rt->year > 9999 ||\n\t    rt->month < 1 || rt->month > 12 ||\n\t    rt->hour > 23 || rt->minute > 59 || rt->second > 59 ||\n\t    rt->tz < -1440 || (rt->tz > 1440 && rt->tz != 2047) ||\n\t    rt->daylight > 3)\n\t\treturn -ERANGE;\n\n\targs[0].buffer.pointer = (u8 *)rt;\n\targs[0].buffer.length = sizeof(*rt);\n\n\tpm_runtime_get_sync(dev);\n\n\tstatus = acpi_evaluate_integer(handle, \"_SRT\", &arg_list, &retval);\n\n\tpm_runtime_put_sync(dev);\n\n\tif (ACPI_FAILURE(status) || retval)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int acpi_tad_get_real_time(struct device *dev, struct acpi_tad_rt *rt)\n{\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER };\n\tunion acpi_object *out_obj;\n\tstruct acpi_tad_rt *data;\n\tacpi_status status;\n\tint ret = -EIO;\n\n\tpm_runtime_get_sync(dev);\n\n\tstatus = acpi_evaluate_object(handle, \"_GRT\", NULL, &output);\n\n\tpm_runtime_put_sync(dev);\n\n\tif (ACPI_FAILURE(status))\n\t\tgoto out_free;\n\n\tout_obj = output.pointer;\n\tif (out_obj->type != ACPI_TYPE_BUFFER)\n\t\tgoto out_free;\n\n\tif (out_obj->buffer.length != sizeof(*rt))\n\t\tgoto out_free;\n\n\tdata = (struct acpi_tad_rt *)(out_obj->buffer.pointer);\n\tif (!data->valid)\n\t\tgoto out_free;\n\n\tmemcpy(rt, data, sizeof(*rt));\n\tret = 0;\n\nout_free:\n\tACPI_FREE(output.pointer);\n\treturn ret;\n}\n\nstatic char *acpi_tad_rt_next_field(char *s, int *val)\n{\n\tchar *p;\n\n\tp = strchr(s, ':');\n\tif (!p)\n\t\treturn NULL;\n\n\t*p = '\\0';\n\tif (kstrtoint(s, 10, val))\n\t\treturn NULL;\n\n\treturn p + 1;\n}\n\nstatic ssize_t time_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct acpi_tad_rt rt;\n\tchar *str, *s;\n\tint val, ret = -ENODATA;\n\n\tstr = kmemdup_nul(buf, count, GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\ts = acpi_tad_rt_next_field(str, &val);\n\tif (!s)\n\t\tgoto out_free;\n\n\trt.year = val;\n\n\ts = acpi_tad_rt_next_field(s, &val);\n\tif (!s)\n\t\tgoto out_free;\n\n\trt.month = val;\n\n\ts = acpi_tad_rt_next_field(s, &val);\n\tif (!s)\n\t\tgoto out_free;\n\n\trt.day = val;\n\n\ts = acpi_tad_rt_next_field(s, &val);\n\tif (!s)\n\t\tgoto out_free;\n\n\trt.hour = val;\n\n\ts = acpi_tad_rt_next_field(s, &val);\n\tif (!s)\n\t\tgoto out_free;\n\n\trt.minute = val;\n\n\ts = acpi_tad_rt_next_field(s, &val);\n\tif (!s)\n\t\tgoto out_free;\n\n\trt.second = val;\n\n\ts = acpi_tad_rt_next_field(s, &val);\n\tif (!s)\n\t\tgoto out_free;\n\n\trt.tz = val;\n\n\tif (kstrtoint(s, 10, &val))\n\t\tgoto out_free;\n\n\trt.daylight = val;\n\n\trt.valid = 0;\n\trt.msec = 0;\n\tmemset(rt.padding, 0, 3);\n\n\tret = acpi_tad_set_real_time(dev, &rt);\n\nout_free:\n\tkfree(str);\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t time_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct acpi_tad_rt rt;\n\tint ret;\n\n\tret = acpi_tad_get_real_time(dev, &rt);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%u:%u:%u:%u:%u:%u:%d:%u\\n\",\n\t\t       rt.year, rt.month, rt.day, rt.hour, rt.minute, rt.second,\n\t\t       rt.tz, rt.daylight);\n}\n\nstatic DEVICE_ATTR_RW(time);\n\nstatic struct attribute *acpi_tad_time_attrs[] = {\n\t&dev_attr_time.attr,\n\tNULL,\n};\nstatic const struct attribute_group acpi_tad_time_attr_group = {\n\t.attrs\t= acpi_tad_time_attrs,\n};\n\nstatic int acpi_tad_wake_set(struct device *dev, char *method, u32 timer_id,\n\t\t\t     u32 value)\n{\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tunion acpi_object args[] = {\n\t\t{ .type = ACPI_TYPE_INTEGER, },\n\t\t{ .type = ACPI_TYPE_INTEGER, },\n\t};\n\tstruct acpi_object_list arg_list = {\n\t\t.pointer = args,\n\t\t.count = ARRAY_SIZE(args),\n\t};\n\tunsigned long long retval;\n\tacpi_status status;\n\n\targs[0].integer.value = timer_id;\n\targs[1].integer.value = value;\n\n\tpm_runtime_get_sync(dev);\n\n\tstatus = acpi_evaluate_integer(handle, method, &arg_list, &retval);\n\n\tpm_runtime_put_sync(dev);\n\n\tif (ACPI_FAILURE(status) || retval)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int acpi_tad_wake_write(struct device *dev, const char *buf, char *method,\n\t\t\t       u32 timer_id, const char *specval)\n{\n\tu32 value;\n\n\tif (sysfs_streq(buf, specval)) {\n\t\tvalue = ACPI_TAD_WAKE_DISABLED;\n\t} else {\n\t\tint ret = kstrtou32(buf, 0, &value);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (value == ACPI_TAD_WAKE_DISABLED)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn acpi_tad_wake_set(dev, method, timer_id, value);\n}\n\nstatic ssize_t acpi_tad_wake_read(struct device *dev, char *buf, char *method,\n\t\t\t\t  u32 timer_id, const char *specval)\n{\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tunion acpi_object args[] = {\n\t\t{ .type = ACPI_TYPE_INTEGER, },\n\t};\n\tstruct acpi_object_list arg_list = {\n\t\t.pointer = args,\n\t\t.count = ARRAY_SIZE(args),\n\t};\n\tunsigned long long retval;\n\tacpi_status status;\n\n\targs[0].integer.value = timer_id;\n\n\tpm_runtime_get_sync(dev);\n\n\tstatus = acpi_evaluate_integer(handle, method, &arg_list, &retval);\n\n\tpm_runtime_put_sync(dev);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tif ((u32)retval == ACPI_TAD_WAKE_DISABLED)\n\t\treturn sprintf(buf, \"%s\\n\", specval);\n\n\treturn sprintf(buf, \"%u\\n\", (u32)retval);\n}\n\nstatic const char *alarm_specval = \"disabled\";\n\nstatic int acpi_tad_alarm_write(struct device *dev, const char *buf,\n\t\t\t\tu32 timer_id)\n{\n\treturn acpi_tad_wake_write(dev, buf, \"_STV\", timer_id, alarm_specval);\n}\n\nstatic ssize_t acpi_tad_alarm_read(struct device *dev, char *buf, u32 timer_id)\n{\n\treturn acpi_tad_wake_read(dev, buf, \"_TIV\", timer_id, alarm_specval);\n}\n\nstatic const char *policy_specval = \"never\";\n\nstatic int acpi_tad_policy_write(struct device *dev, const char *buf,\n\t\t\t\t u32 timer_id)\n{\n\treturn acpi_tad_wake_write(dev, buf, \"_STP\", timer_id, policy_specval);\n}\n\nstatic ssize_t acpi_tad_policy_read(struct device *dev, char *buf, u32 timer_id)\n{\n\treturn acpi_tad_wake_read(dev, buf, \"_TIP\", timer_id, policy_specval);\n}\n\nstatic int acpi_tad_clear_status(struct device *dev, u32 timer_id)\n{\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tunion acpi_object args[] = {\n\t\t{ .type = ACPI_TYPE_INTEGER, },\n\t};\n\tstruct acpi_object_list arg_list = {\n\t\t.pointer = args,\n\t\t.count = ARRAY_SIZE(args),\n\t};\n\tunsigned long long retval;\n\tacpi_status status;\n\n\targs[0].integer.value = timer_id;\n\n\tpm_runtime_get_sync(dev);\n\n\tstatus = acpi_evaluate_integer(handle, \"_CWS\", &arg_list, &retval);\n\n\tpm_runtime_put_sync(dev);\n\n\tif (ACPI_FAILURE(status) || retval)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int acpi_tad_status_write(struct device *dev, const char *buf, u32 timer_id)\n{\n\tint ret, value;\n\n\tret = kstrtoint(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value)\n\t\treturn -EINVAL;\n\n\treturn acpi_tad_clear_status(dev, timer_id);\n}\n\nstatic ssize_t acpi_tad_status_read(struct device *dev, char *buf, u32 timer_id)\n{\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tunion acpi_object args[] = {\n\t\t{ .type = ACPI_TYPE_INTEGER, },\n\t};\n\tstruct acpi_object_list arg_list = {\n\t\t.pointer = args,\n\t\t.count = ARRAY_SIZE(args),\n\t};\n\tunsigned long long retval;\n\tacpi_status status;\n\n\targs[0].integer.value = timer_id;\n\n\tpm_runtime_get_sync(dev);\n\n\tstatus = acpi_evaluate_integer(handle, \"_GWS\", &arg_list, &retval);\n\n\tpm_runtime_put_sync(dev);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\treturn sprintf(buf, \"0x%02X\\n\", (u32)retval);\n}\n\nstatic ssize_t caps_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct acpi_tad_driver_data *dd = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"0x%02X\\n\", dd->capabilities);\n}\n\nstatic DEVICE_ATTR_RO(caps);\n\nstatic ssize_t ac_alarm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tint ret = acpi_tad_alarm_write(dev, buf, ACPI_TAD_AC_TIMER);\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t ac_alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn acpi_tad_alarm_read(dev, buf, ACPI_TAD_AC_TIMER);\n}\n\nstatic DEVICE_ATTR_RW(ac_alarm);\n\nstatic ssize_t ac_policy_store(struct device *dev, struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tint ret = acpi_tad_policy_write(dev, buf, ACPI_TAD_AC_TIMER);\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t ac_policy_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn acpi_tad_policy_read(dev, buf, ACPI_TAD_AC_TIMER);\n}\n\nstatic DEVICE_ATTR_RW(ac_policy);\n\nstatic ssize_t ac_status_store(struct device *dev, struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tint ret = acpi_tad_status_write(dev, buf, ACPI_TAD_AC_TIMER);\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t ac_status_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn acpi_tad_status_read(dev, buf, ACPI_TAD_AC_TIMER);\n}\n\nstatic DEVICE_ATTR_RW(ac_status);\n\nstatic struct attribute *acpi_tad_attrs[] = {\n\t&dev_attr_caps.attr,\n\t&dev_attr_ac_alarm.attr,\n\t&dev_attr_ac_policy.attr,\n\t&dev_attr_ac_status.attr,\n\tNULL,\n};\nstatic const struct attribute_group acpi_tad_attr_group = {\n\t.attrs\t= acpi_tad_attrs,\n};\n\nstatic ssize_t dc_alarm_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tint ret = acpi_tad_alarm_write(dev, buf, ACPI_TAD_DC_TIMER);\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t dc_alarm_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn acpi_tad_alarm_read(dev, buf, ACPI_TAD_DC_TIMER);\n}\n\nstatic DEVICE_ATTR_RW(dc_alarm);\n\nstatic ssize_t dc_policy_store(struct device *dev, struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tint ret = acpi_tad_policy_write(dev, buf, ACPI_TAD_DC_TIMER);\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t dc_policy_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn acpi_tad_policy_read(dev, buf, ACPI_TAD_DC_TIMER);\n}\n\nstatic DEVICE_ATTR_RW(dc_policy);\n\nstatic ssize_t dc_status_store(struct device *dev, struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tint ret = acpi_tad_status_write(dev, buf, ACPI_TAD_DC_TIMER);\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t dc_status_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn acpi_tad_status_read(dev, buf, ACPI_TAD_DC_TIMER);\n}\n\nstatic DEVICE_ATTR_RW(dc_status);\n\nstatic struct attribute *acpi_tad_dc_attrs[] = {\n\t&dev_attr_dc_alarm.attr,\n\t&dev_attr_dc_policy.attr,\n\t&dev_attr_dc_status.attr,\n\tNULL,\n};\nstatic const struct attribute_group acpi_tad_dc_attr_group = {\n\t.attrs\t= acpi_tad_dc_attrs,\n};\n\nstatic int acpi_tad_disable_timer(struct device *dev, u32 timer_id)\n{\n\treturn acpi_tad_wake_set(dev, \"_STV\", timer_id, ACPI_TAD_WAKE_DISABLED);\n}\n\nstatic int acpi_tad_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tstruct acpi_tad_driver_data *dd = dev_get_drvdata(dev);\n\n\tdevice_init_wakeup(dev, false);\n\n\tpm_runtime_get_sync(dev);\n\n\tif (dd->capabilities & ACPI_TAD_DC_WAKE)\n\t\tsysfs_remove_group(&dev->kobj, &acpi_tad_dc_attr_group);\n\n\tsysfs_remove_group(&dev->kobj, &acpi_tad_attr_group);\n\n\tacpi_tad_disable_timer(dev, ACPI_TAD_AC_TIMER);\n\tacpi_tad_clear_status(dev, ACPI_TAD_AC_TIMER);\n\tif (dd->capabilities & ACPI_TAD_DC_WAKE) {\n\t\tacpi_tad_disable_timer(dev, ACPI_TAD_DC_TIMER);\n\t\tacpi_tad_clear_status(dev, ACPI_TAD_DC_TIMER);\n\t}\n\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\tacpi_remove_cmos_rtc_space_handler(handle);\n\treturn 0;\n}\n\nstatic int acpi_tad_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tstruct acpi_tad_driver_data *dd;\n\tacpi_status status;\n\tunsigned long long caps;\n\tint ret;\n\n\tret = acpi_install_cmos_rtc_space_handler(handle);\n\tif (ret < 0) {\n\t\tdev_info(dev, \"Unable to install space handler\\n\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tstatus = acpi_evaluate_integer(handle, \"_GCP\", NULL, &caps);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_info(dev, \"Unable to get capabilities\\n\");\n\t\tret = -ENODEV;\n\t\tgoto remove_handler;\n\t}\n\n\tif (!(caps & ACPI_TAD_AC_WAKE)) {\n\t\tdev_info(dev, \"Unsupported capabilities\\n\");\n\t\tret = -ENODEV;\n\t\tgoto remove_handler;\n\t}\n\n\tif (!acpi_has_method(handle, \"_PRW\")) {\n\t\tdev_info(dev, \"Missing _PRW\\n\");\n\t\tret = -ENODEV;\n\t\tgoto remove_handler;\n\t}\n\n\tdd = devm_kzalloc(dev, sizeof(*dd), GFP_KERNEL);\n\tif (!dd) {\n\t\tret = -ENOMEM;\n\t\tgoto remove_handler;\n\t}\n\n\tdd->capabilities = caps;\n\tdev_set_drvdata(dev, dd);\n\n\t \n\tdevice_init_wakeup(dev, true);\n\tdev_pm_set_driver_flags(dev, DPM_FLAG_SMART_SUSPEND |\n\t\t\t\t     DPM_FLAG_MAY_SKIP_RESUME);\n\t \n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_suspend(dev);\n\n\tret = sysfs_create_group(&dev->kobj, &acpi_tad_attr_group);\n\tif (ret)\n\t\tgoto fail;\n\n\tif (caps & ACPI_TAD_DC_WAKE) {\n\t\tret = sysfs_create_group(&dev->kobj, &acpi_tad_dc_attr_group);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tif (caps & ACPI_TAD_RT) {\n\t\tret = sysfs_create_group(&dev->kobj, &acpi_tad_time_attr_group);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tacpi_tad_remove(pdev);\n\t \n\treturn ret;\n\nremove_handler:\n\tacpi_remove_cmos_rtc_space_handler(handle);\n\treturn ret;\n}\n\nstatic const struct acpi_device_id acpi_tad_ids[] = {\n\t{\"ACPI000E\", 0},\n\t{}\n};\n\nstatic struct platform_driver acpi_tad_driver = {\n\t.driver = {\n\t\t.name = \"acpi-tad\",\n\t\t.acpi_match_table = acpi_tad_ids,\n\t},\n\t.probe = acpi_tad_probe,\n\t.remove = acpi_tad_remove,\n};\nMODULE_DEVICE_TABLE(acpi, acpi_tad_ids);\n\nmodule_platform_driver(acpi_tad_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}