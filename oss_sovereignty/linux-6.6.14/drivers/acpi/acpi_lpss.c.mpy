{
  "module_name": "acpi_lpss.c",
  "hash_id": "b9d8f372d71c178ec1d98e77c92f20195191cb12c3be3914b93c17623ea25665",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_lpss.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/dmi.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/x86/clk-lpss.h>\n#include <linux/platform_data/x86/pmc_atom.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/pwm.h>\n#include <linux/pxa2xx_ssp.h>\n#include <linux/suspend.h>\n#include <linux/delay.h>\n\n#include \"internal.h\"\n\n#ifdef CONFIG_X86_INTEL_LPSS\n\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n#include <asm/iosf_mbi.h>\n\n#define LPSS_ADDR(desc) ((unsigned long)&desc)\n\n#define LPSS_CLK_SIZE\t0x04\n#define LPSS_LTR_SIZE\t0x18\n\n \n#define LPSS_CLK_DIVIDER_DEF_MASK\t(BIT(1) | BIT(16))\n#define LPSS_RESETS\t\t\t0x04\n#define LPSS_RESETS_RESET_FUNC\t\tBIT(0)\n#define LPSS_RESETS_RESET_APB\t\tBIT(1)\n#define LPSS_GENERAL\t\t\t0x08\n#define LPSS_GENERAL_LTR_MODE_SW\tBIT(2)\n#define LPSS_GENERAL_UART_RTS_OVRD\tBIT(3)\n#define LPSS_SW_LTR\t\t\t0x10\n#define LPSS_AUTO_LTR\t\t\t0x14\n#define LPSS_LTR_SNOOP_REQ\t\tBIT(15)\n#define LPSS_LTR_SNOOP_MASK\t\t0x0000FFFF\n#define LPSS_LTR_SNOOP_LAT_1US\t\t0x800\n#define LPSS_LTR_SNOOP_LAT_32US\t\t0xC00\n#define LPSS_LTR_SNOOP_LAT_SHIFT\t5\n#define LPSS_LTR_SNOOP_LAT_CUTOFF\t3000\n#define LPSS_LTR_MAX_VAL\t\t0x3FF\n#define LPSS_TX_INT\t\t\t0x20\n#define LPSS_TX_INT_MASK\t\tBIT(1)\n\n#define LPSS_PRV_REG_COUNT\t\t9\n\n \n#define LPSS_CLK\t\t\tBIT(0)\n#define LPSS_CLK_GATE\t\t\tBIT(1)\n#define LPSS_CLK_DIVIDER\t\tBIT(2)\n#define LPSS_LTR\t\t\tBIT(3)\n#define LPSS_SAVE_CTX\t\t\tBIT(4)\n \n#define LPSS_SAVE_CTX_ONCE\t\tBIT(5)\n#define LPSS_NO_D3_DELAY\t\tBIT(6)\n\nstruct lpss_private_data;\n\nstruct lpss_device_desc {\n\tunsigned int flags;\n\tconst char *clk_con_id;\n\tunsigned int prv_offset;\n\tsize_t prv_size_override;\n\tconst struct property_entry *properties;\n\tvoid (*setup)(struct lpss_private_data *pdata);\n\tbool resume_from_noirq;\n};\n\nstatic const struct lpss_device_desc lpss_dma_desc = {\n\t.flags = LPSS_CLK,\n};\n\nstruct lpss_private_data {\n\tstruct acpi_device *adev;\n\tvoid __iomem *mmio_base;\n\tresource_size_t mmio_size;\n\tunsigned int fixed_clk_rate;\n\tstruct clk *clk;\n\tconst struct lpss_device_desc *dev_desc;\n\tu32 prv_reg_ctx[LPSS_PRV_REG_COUNT];\n};\n\n \nstatic u32 pmc_atom_d3_mask = 0xfe000ffe;\n\n \nstatic unsigned int lpss_quirks;\n\n \n#define LPSS_QUIRK_ALWAYS_POWER_ON\tBIT(0)\n\n \n#define LPSS_UART_CPR\t\t\t0xF4\n#define LPSS_UART_CPR_AFCE\t\tBIT(4)\n\nstatic void lpss_uart_setup(struct lpss_private_data *pdata)\n{\n\tunsigned int offset;\n\tu32 val;\n\n\toffset = pdata->dev_desc->prv_offset + LPSS_TX_INT;\n\tval = readl(pdata->mmio_base + offset);\n\twritel(val | LPSS_TX_INT_MASK, pdata->mmio_base + offset);\n\n\tval = readl(pdata->mmio_base + LPSS_UART_CPR);\n\tif (!(val & LPSS_UART_CPR_AFCE)) {\n\t\toffset = pdata->dev_desc->prv_offset + LPSS_GENERAL;\n\t\tval = readl(pdata->mmio_base + offset);\n\t\tval |= LPSS_GENERAL_UART_RTS_OVRD;\n\t\twritel(val, pdata->mmio_base + offset);\n\t}\n}\n\nstatic void lpss_deassert_reset(struct lpss_private_data *pdata)\n{\n\tunsigned int offset;\n\tu32 val;\n\n\toffset = pdata->dev_desc->prv_offset + LPSS_RESETS;\n\tval = readl(pdata->mmio_base + offset);\n\tval |= LPSS_RESETS_RESET_APB | LPSS_RESETS_RESET_FUNC;\n\twritel(val, pdata->mmio_base + offset);\n}\n\n \nstatic struct pwm_lookup byt_pwm_lookup[] = {\n\tPWM_LOOKUP_WITH_MODULE(\"80860F09:00\", 0, \"0000:00:02.0\",\n\t\t\t       \"pwm_soc_backlight\", 0, PWM_POLARITY_NORMAL,\n\t\t\t       \"pwm-lpss-platform\"),\n};\n\nstatic void byt_pwm_setup(struct lpss_private_data *pdata)\n{\n\tu64 uid;\n\n\t \n\tif (acpi_dev_uid_to_integer(pdata->adev, &uid) || uid != 1)\n\t\treturn;\n\n\tpwm_add_table(byt_pwm_lookup, ARRAY_SIZE(byt_pwm_lookup));\n}\n\n#define LPSS_I2C_ENABLE\t\t\t0x6c\n\nstatic void byt_i2c_setup(struct lpss_private_data *pdata)\n{\n\tacpi_handle handle = pdata->adev->handle;\n\tunsigned long long shared_host = 0;\n\tacpi_status status;\n\tu64 uid;\n\n\t \n\tif (!acpi_dev_uid_to_integer(pdata->adev, &uid) && uid) {\n\t\t \n\t\tstatus = acpi_evaluate_integer(handle, \"_SEM\", NULL, &shared_host);\n\t\tif (ACPI_SUCCESS(status) && shared_host)\n\t\t\tpmc_atom_d3_mask &= ~(BIT_LPSS2_F1_I2C1 << (uid - 1));\n\t}\n\n\tlpss_deassert_reset(pdata);\n\n\tif (readl(pdata->mmio_base + pdata->dev_desc->prv_offset))\n\t\tpdata->fixed_clk_rate = 133000000;\n\n\twritel(0, pdata->mmio_base + LPSS_I2C_ENABLE);\n}\n\n \nstatic struct pwm_lookup bsw_pwm_lookup[] = {\n\tPWM_LOOKUP_WITH_MODULE(\"80862288:00\", 0, \"0000:00:02.0\",\n\t\t\t       \"pwm_soc_backlight\", 0, PWM_POLARITY_NORMAL,\n\t\t\t       \"pwm-lpss-platform\"),\n\tPWM_LOOKUP_WITH_MODULE(\"80862289:00\", 0, NULL,\n\t\t\t       \"pwm_soc_lpss_2\", 0, PWM_POLARITY_NORMAL,\n\t\t\t       \"pwm-lpss-platform\"),\n};\n\nstatic void bsw_pwm_setup(struct lpss_private_data *pdata)\n{\n\tu64 uid;\n\n\t \n\tif (acpi_dev_uid_to_integer(pdata->adev, &uid) || uid != 1)\n\t\treturn;\n\n\tpwm_add_table(bsw_pwm_lookup, ARRAY_SIZE(bsw_pwm_lookup));\n}\n\nstatic const struct property_entry lpt_spi_properties[] = {\n\tPROPERTY_ENTRY_U32(\"intel,spi-pxa2xx-type\", LPSS_LPT_SSP),\n\t{ }\n};\n\nstatic const struct lpss_device_desc lpt_spi_dev_desc = {\n\t.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR\n\t\t\t| LPSS_SAVE_CTX,\n\t.prv_offset = 0x800,\n\t.properties = lpt_spi_properties,\n};\n\nstatic const struct lpss_device_desc lpt_i2c_dev_desc = {\n\t.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_LTR | LPSS_SAVE_CTX,\n\t.prv_offset = 0x800,\n};\n\nstatic struct property_entry uart_properties[] = {\n\tPROPERTY_ENTRY_U32(\"reg-io-width\", 4),\n\tPROPERTY_ENTRY_U32(\"reg-shift\", 2),\n\tPROPERTY_ENTRY_BOOL(\"snps,uart-16550-compatible\"),\n\t{ },\n};\n\nstatic const struct lpss_device_desc lpt_uart_dev_desc = {\n\t.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR\n\t\t\t| LPSS_SAVE_CTX,\n\t.clk_con_id = \"baudclk\",\n\t.prv_offset = 0x800,\n\t.setup = lpss_uart_setup,\n\t.properties = uart_properties,\n};\n\nstatic const struct lpss_device_desc lpt_sdio_dev_desc = {\n\t.flags = LPSS_LTR,\n\t.prv_offset = 0x1000,\n\t.prv_size_override = 0x1018,\n};\n\nstatic const struct lpss_device_desc byt_pwm_dev_desc = {\n\t.flags = LPSS_SAVE_CTX,\n\t.prv_offset = 0x800,\n\t.setup = byt_pwm_setup,\n};\n\nstatic const struct lpss_device_desc bsw_pwm_dev_desc = {\n\t.flags = LPSS_SAVE_CTX_ONCE | LPSS_NO_D3_DELAY,\n\t.prv_offset = 0x800,\n\t.setup = bsw_pwm_setup,\n\t.resume_from_noirq = true,\n};\n\nstatic const struct lpss_device_desc bsw_pwm2_dev_desc = {\n\t.flags = LPSS_SAVE_CTX_ONCE | LPSS_NO_D3_DELAY,\n\t.prv_offset = 0x800,\n\t.resume_from_noirq = true,\n};\n\nstatic const struct lpss_device_desc byt_uart_dev_desc = {\n\t.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,\n\t.clk_con_id = \"baudclk\",\n\t.prv_offset = 0x800,\n\t.setup = lpss_uart_setup,\n\t.properties = uart_properties,\n};\n\nstatic const struct lpss_device_desc bsw_uart_dev_desc = {\n\t.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX\n\t\t\t| LPSS_NO_D3_DELAY,\n\t.clk_con_id = \"baudclk\",\n\t.prv_offset = 0x800,\n\t.setup = lpss_uart_setup,\n\t.properties = uart_properties,\n};\n\nstatic const struct property_entry byt_spi_properties[] = {\n\tPROPERTY_ENTRY_U32(\"intel,spi-pxa2xx-type\", LPSS_BYT_SSP),\n\t{ }\n};\n\nstatic const struct lpss_device_desc byt_spi_dev_desc = {\n\t.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,\n\t.prv_offset = 0x400,\n\t.properties = byt_spi_properties,\n};\n\nstatic const struct lpss_device_desc byt_sdio_dev_desc = {\n\t.flags = LPSS_CLK,\n};\n\nstatic const struct lpss_device_desc byt_i2c_dev_desc = {\n\t.flags = LPSS_CLK | LPSS_SAVE_CTX,\n\t.prv_offset = 0x800,\n\t.setup = byt_i2c_setup,\n\t.resume_from_noirq = true,\n};\n\nstatic const struct lpss_device_desc bsw_i2c_dev_desc = {\n\t.flags = LPSS_CLK | LPSS_SAVE_CTX | LPSS_NO_D3_DELAY,\n\t.prv_offset = 0x800,\n\t.setup = byt_i2c_setup,\n\t.resume_from_noirq = true,\n};\n\nstatic const struct property_entry bsw_spi_properties[] = {\n\tPROPERTY_ENTRY_U32(\"intel,spi-pxa2xx-type\", LPSS_BSW_SSP),\n\t{ }\n};\n\nstatic const struct lpss_device_desc bsw_spi_dev_desc = {\n\t.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX\n\t\t\t| LPSS_NO_D3_DELAY,\n\t.prv_offset = 0x400,\n\t.setup = lpss_deassert_reset,\n\t.properties = bsw_spi_properties,\n};\n\nstatic const struct x86_cpu_id lpss_cpu_ids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT,\tNULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT,\tNULL),\n\t{}\n};\n\n#else\n\n#define LPSS_ADDR(desc) (0UL)\n\n#endif  \n\nstatic const struct acpi_device_id acpi_lpss_device_ids[] = {\n\t \n\t{ \"INTL9C60\", LPSS_ADDR(lpss_dma_desc) },\n\n\t \n\t{ \"INT33C0\", LPSS_ADDR(lpt_spi_dev_desc) },\n\t{ \"INT33C1\", LPSS_ADDR(lpt_spi_dev_desc) },\n\t{ \"INT33C2\", LPSS_ADDR(lpt_i2c_dev_desc) },\n\t{ \"INT33C3\", LPSS_ADDR(lpt_i2c_dev_desc) },\n\t{ \"INT33C4\", LPSS_ADDR(lpt_uart_dev_desc) },\n\t{ \"INT33C5\", LPSS_ADDR(lpt_uart_dev_desc) },\n\t{ \"INT33C6\", LPSS_ADDR(lpt_sdio_dev_desc) },\n\t{ \"INT33C7\", },\n\n\t \n\t{ \"80860F09\", LPSS_ADDR(byt_pwm_dev_desc) },\n\t{ \"80860F0A\", LPSS_ADDR(byt_uart_dev_desc) },\n\t{ \"80860F0E\", LPSS_ADDR(byt_spi_dev_desc) },\n\t{ \"80860F14\", LPSS_ADDR(byt_sdio_dev_desc) },\n\t{ \"80860F41\", LPSS_ADDR(byt_i2c_dev_desc) },\n\t{ \"INT33B2\", },\n\t{ \"INT33FC\", },\n\n\t \n\t{ \"80862286\", LPSS_ADDR(lpss_dma_desc) },\n\t{ \"80862288\", LPSS_ADDR(bsw_pwm_dev_desc) },\n\t{ \"80862289\", LPSS_ADDR(bsw_pwm2_dev_desc) },\n\t{ \"8086228A\", LPSS_ADDR(bsw_uart_dev_desc) },\n\t{ \"8086228E\", LPSS_ADDR(bsw_spi_dev_desc) },\n\t{ \"808622C0\", LPSS_ADDR(lpss_dma_desc) },\n\t{ \"808622C1\", LPSS_ADDR(bsw_i2c_dev_desc) },\n\n\t \n\t{ \"INT3430\", LPSS_ADDR(lpt_spi_dev_desc) },\n\t{ \"INT3431\", LPSS_ADDR(lpt_spi_dev_desc) },\n\t{ \"INT3432\", LPSS_ADDR(lpt_i2c_dev_desc) },\n\t{ \"INT3433\", LPSS_ADDR(lpt_i2c_dev_desc) },\n\t{ \"INT3434\", LPSS_ADDR(lpt_uart_dev_desc) },\n\t{ \"INT3435\", LPSS_ADDR(lpt_uart_dev_desc) },\n\t{ \"INT3436\", LPSS_ADDR(lpt_sdio_dev_desc) },\n\t{ \"INT3437\", },\n\n\t \n\t{ \"INT3438\", LPSS_ADDR(lpt_spi_dev_desc) },\n\n\t{ }\n};\n\n#ifdef CONFIG_X86_INTEL_LPSS\n\n \nstatic struct platform_device *lpss_clk_dev;\n\nstatic inline void lpt_register_clock_device(void)\n{\n\tlpss_clk_dev = platform_device_register_simple(\"clk-lpss-atom\",\n\t\t\t\t\t\t       PLATFORM_DEVID_NONE,\n\t\t\t\t\t\t       NULL, 0);\n}\n\nstatic int register_device_clock(struct acpi_device *adev,\n\t\t\t\t struct lpss_private_data *pdata)\n{\n\tconst struct lpss_device_desc *dev_desc = pdata->dev_desc;\n\tconst char *devname = dev_name(&adev->dev);\n\tstruct clk *clk;\n\tstruct lpss_clk_data *clk_data;\n\tconst char *parent, *clk_name;\n\tvoid __iomem *prv_base;\n\n\tif (!lpss_clk_dev)\n\t\tlpt_register_clock_device();\n\n\tif (IS_ERR(lpss_clk_dev))\n\t\treturn PTR_ERR(lpss_clk_dev);\n\n\tclk_data = platform_get_drvdata(lpss_clk_dev);\n\tif (!clk_data)\n\t\treturn -ENODEV;\n\tclk = clk_data->clk;\n\n\tif (!pdata->mmio_base\n\t    || pdata->mmio_size < dev_desc->prv_offset + LPSS_CLK_SIZE)\n\t\treturn -ENODATA;\n\n\tparent = clk_data->name;\n\tprv_base = pdata->mmio_base + dev_desc->prv_offset;\n\n\tif (pdata->fixed_clk_rate) {\n\t\tclk = clk_register_fixed_rate(NULL, devname, parent, 0,\n\t\t\t\t\t      pdata->fixed_clk_rate);\n\t\tgoto out;\n\t}\n\n\tif (dev_desc->flags & LPSS_CLK_GATE) {\n\t\tclk = clk_register_gate(NULL, devname, parent, 0,\n\t\t\t\t\tprv_base, 0, 0, NULL);\n\t\tparent = devname;\n\t}\n\n\tif (dev_desc->flags & LPSS_CLK_DIVIDER) {\n\t\t \n\t\tif (!readl(prv_base))\n\t\t\twritel(LPSS_CLK_DIVIDER_DEF_MASK, prv_base);\n\n\t\tclk_name = kasprintf(GFP_KERNEL, \"%s-div\", devname);\n\t\tif (!clk_name)\n\t\t\treturn -ENOMEM;\n\t\tclk = clk_register_fractional_divider(NULL, clk_name, parent,\n\t\t\t\t\t\t      0, prv_base, 1, 15, 16, 15,\n\t\t\t\t\t\t      CLK_FRAC_DIVIDER_POWER_OF_TWO_PS,\n\t\t\t\t\t\t      NULL);\n\t\tparent = clk_name;\n\n\t\tclk_name = kasprintf(GFP_KERNEL, \"%s-update\", devname);\n\t\tif (!clk_name) {\n\t\t\tkfree(parent);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tclk = clk_register_gate(NULL, clk_name, parent,\n\t\t\t\t\tCLK_SET_RATE_PARENT | CLK_SET_RATE_GATE,\n\t\t\t\t\tprv_base, 31, 0, NULL);\n\t\tkfree(parent);\n\t\tkfree(clk_name);\n\t}\nout:\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tpdata->clk = clk;\n\tclk_register_clkdev(clk, dev_desc->clk_con_id, devname);\n\treturn 0;\n}\n\nstruct lpss_device_links {\n\tconst char *supplier_hid;\n\tconst char *supplier_uid;\n\tconst char *consumer_hid;\n\tconst char *consumer_uid;\n\tu32 flags;\n\tconst struct dmi_system_id *dep_missing_ids;\n};\n\n \nstatic const struct dmi_system_id i2c1_dep_missing_dmi_ids[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"T200TA\"),\n\t\t},\n\t},\n\t{}\n};\n\n \nstatic const struct lpss_device_links lpss_device_links[] = {\n\t \n\t{\"808622C1\", \"7\", \"80860F14\", \"3\", DL_FLAG_PM_RUNTIME},\n\t \n\t{\"808622C1\", \"7\", \"LNXVIDEO\", NULL, DL_FLAG_PM_RUNTIME},\n\t \n\t{\"80860F41\", \"1\", \"LNXVIDEO\", NULL, DL_FLAG_PM_RUNTIME,\n\t i2c1_dep_missing_dmi_ids},\n\t \n\t{\"80860F41\", \"5\", \"LNXVIDEO\", NULL, DL_FLAG_PM_RUNTIME},\n\t \n\t{\"80860F41\", \"7\", \"LNXVIDEO\", NULL, DL_FLAG_PM_RUNTIME},\n};\n\nstatic bool acpi_lpss_is_supplier(struct acpi_device *adev,\n\t\t\t\t  const struct lpss_device_links *link)\n{\n\treturn acpi_dev_hid_uid_match(adev, link->supplier_hid, link->supplier_uid);\n}\n\nstatic bool acpi_lpss_is_consumer(struct acpi_device *adev,\n\t\t\t\t  const struct lpss_device_links *link)\n{\n\treturn acpi_dev_hid_uid_match(adev, link->consumer_hid, link->consumer_uid);\n}\n\nstruct hid_uid {\n\tconst char *hid;\n\tconst char *uid;\n};\n\nstatic int match_hid_uid(struct device *dev, const void *data)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tconst struct hid_uid *id = data;\n\n\tif (!adev)\n\t\treturn 0;\n\n\treturn acpi_dev_hid_uid_match(adev, id->hid, id->uid);\n}\n\nstatic struct device *acpi_lpss_find_device(const char *hid, const char *uid)\n{\n\tstruct device *dev;\n\n\tstruct hid_uid data = {\n\t\t.hid = hid,\n\t\t.uid = uid,\n\t};\n\n\tdev = bus_find_device(&platform_bus_type, NULL, &data, match_hid_uid);\n\tif (dev)\n\t\treturn dev;\n\n\treturn bus_find_device(&pci_bus_type, NULL, &data, match_hid_uid);\n}\n\nstatic bool acpi_lpss_dep(struct acpi_device *adev, acpi_handle handle)\n{\n\tstruct acpi_handle_list dep_devices;\n\tacpi_status status;\n\tint i;\n\n\tif (!acpi_has_method(adev->handle, \"_DEP\"))\n\t\treturn false;\n\n\tstatus = acpi_evaluate_reference(adev->handle, \"_DEP\", NULL,\n\t\t\t\t\t &dep_devices);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_dbg(&adev->dev, \"Failed to evaluate _DEP.\\n\");\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < dep_devices.count; i++) {\n\t\tif (dep_devices.handles[i] == handle)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void acpi_lpss_link_consumer(struct device *dev1,\n\t\t\t\t    const struct lpss_device_links *link)\n{\n\tstruct device *dev2;\n\n\tdev2 = acpi_lpss_find_device(link->consumer_hid, link->consumer_uid);\n\tif (!dev2)\n\t\treturn;\n\n\tif ((link->dep_missing_ids && dmi_check_system(link->dep_missing_ids))\n\t    || acpi_lpss_dep(ACPI_COMPANION(dev2), ACPI_HANDLE(dev1)))\n\t\tdevice_link_add(dev2, dev1, link->flags);\n\n\tput_device(dev2);\n}\n\nstatic void acpi_lpss_link_supplier(struct device *dev1,\n\t\t\t\t    const struct lpss_device_links *link)\n{\n\tstruct device *dev2;\n\n\tdev2 = acpi_lpss_find_device(link->supplier_hid, link->supplier_uid);\n\tif (!dev2)\n\t\treturn;\n\n\tif ((link->dep_missing_ids && dmi_check_system(link->dep_missing_ids))\n\t    || acpi_lpss_dep(ACPI_COMPANION(dev1), ACPI_HANDLE(dev2)))\n\t\tdevice_link_add(dev1, dev2, link->flags);\n\n\tput_device(dev2);\n}\n\nstatic void acpi_lpss_create_device_links(struct acpi_device *adev,\n\t\t\t\t\t  struct platform_device *pdev)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lpss_device_links); i++) {\n\t\tconst struct lpss_device_links *link = &lpss_device_links[i];\n\n\t\tif (acpi_lpss_is_supplier(adev, link))\n\t\t\tacpi_lpss_link_consumer(&pdev->dev, link);\n\n\t\tif (acpi_lpss_is_consumer(adev, link))\n\t\t\tacpi_lpss_link_supplier(&pdev->dev, link);\n\t}\n}\n\nstatic int acpi_lpss_create_device(struct acpi_device *adev,\n\t\t\t\t   const struct acpi_device_id *id)\n{\n\tconst struct lpss_device_desc *dev_desc;\n\tstruct lpss_private_data *pdata;\n\tstruct resource_entry *rentry;\n\tstruct list_head resource_list;\n\tstruct platform_device *pdev;\n\tint ret;\n\n\tdev_desc = (const struct lpss_device_desc *)id->driver_data;\n\tif (!dev_desc) {\n\t\tpdev = acpi_create_platform_device(adev, NULL);\n\t\treturn IS_ERR_OR_NULL(pdev) ? PTR_ERR(pdev) : 1;\n\t}\n\tpdata = kzalloc(sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&resource_list);\n\tret = acpi_dev_get_memory_resources(adev, &resource_list);\n\tif (ret < 0)\n\t\tgoto err_out;\n\n\trentry = list_first_entry_or_null(&resource_list, struct resource_entry, node);\n\tif (rentry) {\n\t\tif (dev_desc->prv_size_override)\n\t\t\tpdata->mmio_size = dev_desc->prv_size_override;\n\t\telse\n\t\t\tpdata->mmio_size = resource_size(rentry->res);\n\t\tpdata->mmio_base = ioremap(rentry->res->start, pdata->mmio_size);\n\t}\n\n\tacpi_dev_free_resource_list(&resource_list);\n\n\tif (!pdata->mmio_base) {\n\t\t \n\t\tadev->pnp.type.platform_id = 0;\n\t\tgoto out_free;\n\t}\n\n\tpdata->adev = adev;\n\tpdata->dev_desc = dev_desc;\n\n\tif (dev_desc->setup)\n\t\tdev_desc->setup(pdata);\n\n\tif (dev_desc->flags & LPSS_CLK) {\n\t\tret = register_device_clock(adev, pdata);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\t \n\tacpi_device_fix_up_power(adev);\n\n\tadev->driver_data = pdata;\n\tpdev = acpi_create_platform_device(adev, dev_desc->properties);\n\tif (IS_ERR_OR_NULL(pdev)) {\n\t\tadev->driver_data = NULL;\n\t\tret = PTR_ERR(pdev);\n\t\tgoto err_out;\n\t}\n\n\tacpi_lpss_create_device_links(adev, pdev);\n\treturn 1;\n\nout_free:\n\t \n\tret = 0;\nerr_out:\n\tkfree(pdata);\n\treturn ret;\n}\n\nstatic u32 __lpss_reg_read(struct lpss_private_data *pdata, unsigned int reg)\n{\n\treturn readl(pdata->mmio_base + pdata->dev_desc->prv_offset + reg);\n}\n\nstatic void __lpss_reg_write(u32 val, struct lpss_private_data *pdata,\n\t\t\t     unsigned int reg)\n{\n\twritel(val, pdata->mmio_base + pdata->dev_desc->prv_offset + reg);\n}\n\nstatic int lpss_reg_read(struct device *dev, unsigned int reg, u32 *val)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tstruct lpss_private_data *pdata;\n\tunsigned long flags;\n\tint ret;\n\n\tif (WARN_ON(!adev))\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&dev->power.lock, flags);\n\tif (pm_runtime_suspended(dev)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\tpdata = acpi_driver_data(adev);\n\tif (WARN_ON(!pdata || !pdata->mmio_base)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\t*val = __lpss_reg_read(pdata, reg);\n\tret = 0;\n\n out:\n\tspin_unlock_irqrestore(&dev->power.lock, flags);\n\treturn ret;\n}\n\nstatic ssize_t lpss_ltr_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tu32 ltr_value = 0;\n\tunsigned int reg;\n\tint ret;\n\n\treg = strcmp(attr->attr.name, \"auto_ltr\") ? LPSS_SW_LTR : LPSS_AUTO_LTR;\n\tret = lpss_reg_read(dev, reg, &ltr_value);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%08x\\n\", ltr_value);\n}\n\nstatic ssize_t lpss_ltr_mode_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tu32 ltr_mode = 0;\n\tchar *outstr;\n\tint ret;\n\n\tret = lpss_reg_read(dev, LPSS_GENERAL, &ltr_mode);\n\tif (ret)\n\t\treturn ret;\n\n\toutstr = (ltr_mode & LPSS_GENERAL_LTR_MODE_SW) ? \"sw\" : \"auto\";\n\treturn sprintf(buf, \"%s\\n\", outstr);\n}\n\nstatic DEVICE_ATTR(auto_ltr, S_IRUSR, lpss_ltr_show, NULL);\nstatic DEVICE_ATTR(sw_ltr, S_IRUSR, lpss_ltr_show, NULL);\nstatic DEVICE_ATTR(ltr_mode, S_IRUSR, lpss_ltr_mode_show, NULL);\n\nstatic struct attribute *lpss_attrs[] = {\n\t&dev_attr_auto_ltr.attr,\n\t&dev_attr_sw_ltr.attr,\n\t&dev_attr_ltr_mode.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group lpss_attr_group = {\n\t.attrs = lpss_attrs,\n\t.name = \"lpss_ltr\",\n};\n\nstatic void acpi_lpss_set_ltr(struct device *dev, s32 val)\n{\n\tstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\n\tu32 ltr_mode, ltr_val;\n\n\tltr_mode = __lpss_reg_read(pdata, LPSS_GENERAL);\n\tif (val < 0) {\n\t\tif (ltr_mode & LPSS_GENERAL_LTR_MODE_SW) {\n\t\t\tltr_mode &= ~LPSS_GENERAL_LTR_MODE_SW;\n\t\t\t__lpss_reg_write(ltr_mode, pdata, LPSS_GENERAL);\n\t\t}\n\t\treturn;\n\t}\n\tltr_val = __lpss_reg_read(pdata, LPSS_SW_LTR) & ~LPSS_LTR_SNOOP_MASK;\n\tif (val >= LPSS_LTR_SNOOP_LAT_CUTOFF) {\n\t\tltr_val |= LPSS_LTR_SNOOP_LAT_32US;\n\t\tval = LPSS_LTR_MAX_VAL;\n\t} else if (val > LPSS_LTR_MAX_VAL) {\n\t\tltr_val |= LPSS_LTR_SNOOP_LAT_32US | LPSS_LTR_SNOOP_REQ;\n\t\tval >>= LPSS_LTR_SNOOP_LAT_SHIFT;\n\t} else {\n\t\tltr_val |= LPSS_LTR_SNOOP_LAT_1US | LPSS_LTR_SNOOP_REQ;\n\t}\n\tltr_val |= val;\n\t__lpss_reg_write(ltr_val, pdata, LPSS_SW_LTR);\n\tif (!(ltr_mode & LPSS_GENERAL_LTR_MODE_SW)) {\n\t\tltr_mode |= LPSS_GENERAL_LTR_MODE_SW;\n\t\t__lpss_reg_write(ltr_mode, pdata, LPSS_GENERAL);\n\t}\n}\n\n#ifdef CONFIG_PM\n \nstatic void acpi_lpss_save_ctx(struct device *dev,\n\t\t\t       struct lpss_private_data *pdata)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < LPSS_PRV_REG_COUNT; i++) {\n\t\tunsigned long offset = i * sizeof(u32);\n\n\t\tpdata->prv_reg_ctx[i] = __lpss_reg_read(pdata, offset);\n\t\tdev_dbg(dev, \"saving 0x%08x from LPSS reg at offset 0x%02lx\\n\",\n\t\t\tpdata->prv_reg_ctx[i], offset);\n\t}\n}\n\n \nstatic void acpi_lpss_restore_ctx(struct device *dev,\n\t\t\t\t  struct lpss_private_data *pdata)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < LPSS_PRV_REG_COUNT; i++) {\n\t\tunsigned long offset = i * sizeof(u32);\n\n\t\t__lpss_reg_write(pdata->prv_reg_ctx[i], pdata, offset);\n\t\tdev_dbg(dev, \"restoring 0x%08x to LPSS reg at offset 0x%02lx\\n\",\n\t\t\tpdata->prv_reg_ctx[i], offset);\n\t}\n}\n\nstatic void acpi_lpss_d3_to_d0_delay(struct lpss_private_data *pdata)\n{\n\t \n\tunsigned int delay = 10;\t \n\n\tif (pdata->dev_desc->flags & LPSS_NO_D3_DELAY)\n\t\tdelay = 0;\n\n\tmsleep(delay);\n}\n\nstatic int acpi_lpss_activate(struct device *dev)\n{\n\tstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\n\tint ret;\n\n\tret = acpi_dev_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tacpi_lpss_d3_to_d0_delay(pdata);\n\n\t \n\tif (pdata->dev_desc->flags & (LPSS_SAVE_CTX | LPSS_SAVE_CTX_ONCE))\n\t\tlpss_deassert_reset(pdata);\n\n#ifdef CONFIG_PM\n\tif (pdata->dev_desc->flags & LPSS_SAVE_CTX_ONCE)\n\t\tacpi_lpss_save_ctx(dev, pdata);\n#endif\n\n\treturn 0;\n}\n\nstatic void acpi_lpss_dismiss(struct device *dev)\n{\n\tacpi_dev_suspend(dev, false);\n}\n\n \n#define LPSS_IOSF_UNIT_LPIOEP\t\t0xA0\n#define LPSS_IOSF_UNIT_LPIO1\t\t0xAB\n#define LPSS_IOSF_UNIT_LPIO2\t\t0xAC\n\n#define LPSS_IOSF_PMCSR\t\t\t0x84\n#define LPSS_PMCSR_D0\t\t\t0\n#define LPSS_PMCSR_D3hot\t\t3\n#define LPSS_PMCSR_Dx_MASK\t\tGENMASK(1, 0)\n\n#define LPSS_IOSF_GPIODEF0\t\t0x154\n#define LPSS_GPIODEF0_DMA1_D3\t\tBIT(2)\n#define LPSS_GPIODEF0_DMA2_D3\t\tBIT(3)\n#define LPSS_GPIODEF0_DMA_D3_MASK\tGENMASK(3, 2)\n#define LPSS_GPIODEF0_DMA_LLP\t\tBIT(13)\n\nstatic DEFINE_MUTEX(lpss_iosf_mutex);\nstatic bool lpss_iosf_d3_entered = true;\n\nstatic void lpss_iosf_enter_d3_state(void)\n{\n\tu32 value1 = 0;\n\tu32 mask1 = LPSS_GPIODEF0_DMA_D3_MASK | LPSS_GPIODEF0_DMA_LLP;\n\tu32 value2 = LPSS_PMCSR_D3hot;\n\tu32 mask2 = LPSS_PMCSR_Dx_MASK;\n\t \n\tu32 func_dis, d3_sts_0, pmc_status;\n\tint ret;\n\n\tret = pmc_atom_read(PMC_FUNC_DIS, &func_dis);\n\tif (ret)\n\t\treturn;\n\n\tmutex_lock(&lpss_iosf_mutex);\n\n\tret = pmc_atom_read(PMC_D3_STS_0, &d3_sts_0);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tpmc_status = (~(d3_sts_0 | func_dis)) & pmc_atom_d3_mask;\n\tif (pmc_status)\n\t\tgoto exit;\n\n\tiosf_mbi_modify(LPSS_IOSF_UNIT_LPIO1, MBI_CFG_WRITE,\n\t\t\tLPSS_IOSF_PMCSR, value2, mask2);\n\n\tiosf_mbi_modify(LPSS_IOSF_UNIT_LPIO2, MBI_CFG_WRITE,\n\t\t\tLPSS_IOSF_PMCSR, value2, mask2);\n\n\tiosf_mbi_modify(LPSS_IOSF_UNIT_LPIOEP, MBI_CR_WRITE,\n\t\t\tLPSS_IOSF_GPIODEF0, value1, mask1);\n\n\tlpss_iosf_d3_entered = true;\n\nexit:\n\tmutex_unlock(&lpss_iosf_mutex);\n}\n\nstatic void lpss_iosf_exit_d3_state(void)\n{\n\tu32 value1 = LPSS_GPIODEF0_DMA1_D3 | LPSS_GPIODEF0_DMA2_D3 |\n\t\t     LPSS_GPIODEF0_DMA_LLP;\n\tu32 mask1 = LPSS_GPIODEF0_DMA_D3_MASK | LPSS_GPIODEF0_DMA_LLP;\n\tu32 value2 = LPSS_PMCSR_D0;\n\tu32 mask2 = LPSS_PMCSR_Dx_MASK;\n\n\tmutex_lock(&lpss_iosf_mutex);\n\n\tif (!lpss_iosf_d3_entered)\n\t\tgoto exit;\n\n\tlpss_iosf_d3_entered = false;\n\n\tiosf_mbi_modify(LPSS_IOSF_UNIT_LPIOEP, MBI_CR_WRITE,\n\t\t\tLPSS_IOSF_GPIODEF0, value1, mask1);\n\n\tiosf_mbi_modify(LPSS_IOSF_UNIT_LPIO2, MBI_CFG_WRITE,\n\t\t\tLPSS_IOSF_PMCSR, value2, mask2);\n\n\tiosf_mbi_modify(LPSS_IOSF_UNIT_LPIO1, MBI_CFG_WRITE,\n\t\t\tLPSS_IOSF_PMCSR, value2, mask2);\n\nexit:\n\tmutex_unlock(&lpss_iosf_mutex);\n}\n\nstatic int acpi_lpss_suspend(struct device *dev, bool wakeup)\n{\n\tstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\n\tint ret;\n\n\tif (pdata->dev_desc->flags & LPSS_SAVE_CTX)\n\t\tacpi_lpss_save_ctx(dev, pdata);\n\n\tret = acpi_dev_suspend(dev, wakeup);\n\n\t \n\tif (acpi_target_system_state() == ACPI_STATE_S0 &&\n\t    lpss_quirks & LPSS_QUIRK_ALWAYS_POWER_ON && iosf_mbi_available())\n\t\tlpss_iosf_enter_d3_state();\n\n\treturn ret;\n}\n\nstatic int acpi_lpss_resume(struct device *dev)\n{\n\tstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\n\tint ret;\n\n\t \n\tif (lpss_quirks & LPSS_QUIRK_ALWAYS_POWER_ON && iosf_mbi_available())\n\t\tlpss_iosf_exit_d3_state();\n\n\tret = acpi_dev_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tacpi_lpss_d3_to_d0_delay(pdata);\n\n\tif (pdata->dev_desc->flags & (LPSS_SAVE_CTX | LPSS_SAVE_CTX_ONCE))\n\t\tacpi_lpss_restore_ctx(dev, pdata);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acpi_lpss_do_suspend_late(struct device *dev)\n{\n\tint ret;\n\n\tif (dev_pm_skip_suspend(dev))\n\t\treturn 0;\n\n\tret = pm_generic_suspend_late(dev);\n\treturn ret ? ret : acpi_lpss_suspend(dev, device_may_wakeup(dev));\n}\n\nstatic int acpi_lpss_suspend_late(struct device *dev)\n{\n\tstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\n\n\tif (pdata->dev_desc->resume_from_noirq)\n\t\treturn 0;\n\n\treturn acpi_lpss_do_suspend_late(dev);\n}\n\nstatic int acpi_lpss_suspend_noirq(struct device *dev)\n{\n\tstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\n\tint ret;\n\n\tif (pdata->dev_desc->resume_from_noirq) {\n\t\t \n\t\tret = acpi_lpss_do_suspend_late(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn acpi_subsys_suspend_noirq(dev);\n}\n\nstatic int acpi_lpss_do_resume_early(struct device *dev)\n{\n\tint ret = acpi_lpss_resume(dev);\n\n\treturn ret ? ret : pm_generic_resume_early(dev);\n}\n\nstatic int acpi_lpss_resume_early(struct device *dev)\n{\n\tstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\n\n\tif (pdata->dev_desc->resume_from_noirq)\n\t\treturn 0;\n\n\tif (dev_pm_skip_resume(dev))\n\t\treturn 0;\n\n\treturn acpi_lpss_do_resume_early(dev);\n}\n\nstatic int acpi_lpss_resume_noirq(struct device *dev)\n{\n\tstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\n\tint ret;\n\n\t \n\tif (dev_pm_skip_resume(dev))\n\t\treturn 0;\n\n\tret = pm_generic_resume_noirq(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!pdata->dev_desc->resume_from_noirq)\n\t\treturn 0;\n\n\t \n\treturn acpi_lpss_do_resume_early(dev);\n}\n\nstatic int acpi_lpss_do_restore_early(struct device *dev)\n{\n\tint ret = acpi_lpss_resume(dev);\n\n\treturn ret ? ret : pm_generic_restore_early(dev);\n}\n\nstatic int acpi_lpss_restore_early(struct device *dev)\n{\n\tstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\n\n\tif (pdata->dev_desc->resume_from_noirq)\n\t\treturn 0;\n\n\treturn acpi_lpss_do_restore_early(dev);\n}\n\nstatic int acpi_lpss_restore_noirq(struct device *dev)\n{\n\tstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\n\tint ret;\n\n\tret = pm_generic_restore_noirq(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!pdata->dev_desc->resume_from_noirq)\n\t\treturn 0;\n\n\t \n\treturn acpi_lpss_do_restore_early(dev);\n}\n\nstatic int acpi_lpss_do_poweroff_late(struct device *dev)\n{\n\tint ret = pm_generic_poweroff_late(dev);\n\n\treturn ret ? ret : acpi_lpss_suspend(dev, device_may_wakeup(dev));\n}\n\nstatic int acpi_lpss_poweroff_late(struct device *dev)\n{\n\tstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\n\n\tif (dev_pm_skip_suspend(dev))\n\t\treturn 0;\n\n\tif (pdata->dev_desc->resume_from_noirq)\n\t\treturn 0;\n\n\treturn acpi_lpss_do_poweroff_late(dev);\n}\n\nstatic int acpi_lpss_poweroff_noirq(struct device *dev)\n{\n\tstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\n\n\tif (dev_pm_skip_suspend(dev))\n\t\treturn 0;\n\n\tif (pdata->dev_desc->resume_from_noirq) {\n\t\t \n\t\tint ret = acpi_lpss_do_poweroff_late(dev);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn pm_generic_poweroff_noirq(dev);\n}\n#endif  \n\nstatic int acpi_lpss_runtime_suspend(struct device *dev)\n{\n\tint ret = pm_generic_runtime_suspend(dev);\n\n\treturn ret ? ret : acpi_lpss_suspend(dev, true);\n}\n\nstatic int acpi_lpss_runtime_resume(struct device *dev)\n{\n\tint ret = acpi_lpss_resume(dev);\n\n\treturn ret ? ret : pm_generic_runtime_resume(dev);\n}\n#endif  \n\nstatic struct dev_pm_domain acpi_lpss_pm_domain = {\n#ifdef CONFIG_PM\n\t.activate = acpi_lpss_activate,\n\t.dismiss = acpi_lpss_dismiss,\n#endif\n\t.ops = {\n#ifdef CONFIG_PM\n#ifdef CONFIG_PM_SLEEP\n\t\t.prepare = acpi_subsys_prepare,\n\t\t.complete = acpi_subsys_complete,\n\t\t.suspend = acpi_subsys_suspend,\n\t\t.suspend_late = acpi_lpss_suspend_late,\n\t\t.suspend_noirq = acpi_lpss_suspend_noirq,\n\t\t.resume_noirq = acpi_lpss_resume_noirq,\n\t\t.resume_early = acpi_lpss_resume_early,\n\t\t.freeze = acpi_subsys_freeze,\n\t\t.poweroff = acpi_subsys_poweroff,\n\t\t.poweroff_late = acpi_lpss_poweroff_late,\n\t\t.poweroff_noirq = acpi_lpss_poweroff_noirq,\n\t\t.restore_noirq = acpi_lpss_restore_noirq,\n\t\t.restore_early = acpi_lpss_restore_early,\n#endif\n\t\t.runtime_suspend = acpi_lpss_runtime_suspend,\n\t\t.runtime_resume = acpi_lpss_runtime_resume,\n#endif\n\t},\n};\n\nstatic int acpi_lpss_platform_notify(struct notifier_block *nb,\n\t\t\t\t     unsigned long action, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(data);\n\tstruct lpss_private_data *pdata;\n\tstruct acpi_device *adev;\n\tconst struct acpi_device_id *id;\n\n\tid = acpi_match_device(acpi_lpss_device_ids, &pdev->dev);\n\tif (!id || !id->driver_data)\n\t\treturn 0;\n\n\tadev = ACPI_COMPANION(&pdev->dev);\n\tif (!adev)\n\t\treturn 0;\n\n\tpdata = acpi_driver_data(adev);\n\tif (!pdata)\n\t\treturn 0;\n\n\tif (pdata->mmio_base &&\n\t    pdata->mmio_size < pdata->dev_desc->prv_offset + LPSS_LTR_SIZE) {\n\t\tdev_err(&pdev->dev, \"MMIO size insufficient to access LTR\\n\");\n\t\treturn 0;\n\t}\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_BIND_DRIVER:\n\t\tdev_pm_domain_set(&pdev->dev, &acpi_lpss_pm_domain);\n\t\tbreak;\n\tcase BUS_NOTIFY_DRIVER_NOT_BOUND:\n\tcase BUS_NOTIFY_UNBOUND_DRIVER:\n\t\tdev_pm_domain_set(&pdev->dev, NULL);\n\t\tbreak;\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\tdev_pm_domain_set(&pdev->dev, &acpi_lpss_pm_domain);\n\t\tif (pdata->dev_desc->flags & LPSS_LTR)\n\t\t\treturn sysfs_create_group(&pdev->dev.kobj,\n\t\t\t\t\t\t  &lpss_attr_group);\n\t\tbreak;\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\tif (pdata->dev_desc->flags & LPSS_LTR)\n\t\t\tsysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);\n\t\tdev_pm_domain_set(&pdev->dev, NULL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct notifier_block acpi_lpss_nb = {\n\t.notifier_call = acpi_lpss_platform_notify,\n};\n\nstatic void acpi_lpss_bind(struct device *dev)\n{\n\tstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\n\n\tif (!pdata || !pdata->mmio_base || !(pdata->dev_desc->flags & LPSS_LTR))\n\t\treturn;\n\n\tif (pdata->mmio_size >= pdata->dev_desc->prv_offset + LPSS_LTR_SIZE)\n\t\tdev->power.set_latency_tolerance = acpi_lpss_set_ltr;\n\telse\n\t\tdev_err(dev, \"MMIO size insufficient to access LTR\\n\");\n}\n\nstatic void acpi_lpss_unbind(struct device *dev)\n{\n\tdev->power.set_latency_tolerance = NULL;\n}\n\nstatic struct acpi_scan_handler lpss_handler = {\n\t.ids = acpi_lpss_device_ids,\n\t.attach = acpi_lpss_create_device,\n\t.bind = acpi_lpss_bind,\n\t.unbind = acpi_lpss_unbind,\n};\n\nvoid __init acpi_lpss_init(void)\n{\n\tconst struct x86_cpu_id *id;\n\tint ret;\n\n\tret = lpss_atom_clk_init();\n\tif (ret)\n\t\treturn;\n\n\tid = x86_match_cpu(lpss_cpu_ids);\n\tif (id)\n\t\tlpss_quirks |= LPSS_QUIRK_ALWAYS_POWER_ON;\n\n\tbus_register_notifier(&platform_bus_type, &acpi_lpss_nb);\n\tacpi_scan_add_handler(&lpss_handler);\n}\n\n#else\n\nstatic struct acpi_scan_handler lpss_handler = {\n\t.ids = acpi_lpss_device_ids,\n};\n\nvoid __init acpi_lpss_init(void)\n{\n\tacpi_scan_add_handler(&lpss_handler);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}