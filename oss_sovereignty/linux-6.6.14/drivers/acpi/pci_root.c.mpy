{
  "module_name": "pci_root.c",
  "hash_id": "05a8d7a268ff5c2d85c7aecb2bdbc478dfc95fc6c3872abc4be8f6001905d0b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pci_root.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/pci.h>\n#include <linux/pci-acpi.h>\n#include <linux/dmar.h>\n#include <linux/acpi.h>\n#include <linux/slab.h>\n#include <linux/dmi.h>\n#include <linux/platform_data/x86/apple.h>\n#include \"internal.h\"\n\n#define ACPI_PCI_ROOT_CLASS\t\t\"pci_bridge\"\n#define ACPI_PCI_ROOT_DEVICE_NAME\t\"PCI Root Bridge\"\nstatic int acpi_pci_root_add(struct acpi_device *device,\n\t\t\t     const struct acpi_device_id *not_used);\nstatic void acpi_pci_root_remove(struct acpi_device *device);\n\nstatic int acpi_pci_root_scan_dependent(struct acpi_device *adev)\n{\n\tacpiphp_check_host_bridge(adev);\n\treturn 0;\n}\n\n#define ACPI_PCIE_REQ_SUPPORT (OSC_PCI_EXT_CONFIG_SUPPORT \\\n\t\t\t\t| OSC_PCI_ASPM_SUPPORT \\\n\t\t\t\t| OSC_PCI_CLOCK_PM_SUPPORT \\\n\t\t\t\t| OSC_PCI_MSI_SUPPORT)\n\nstatic const struct acpi_device_id root_device_ids[] = {\n\t{\"PNP0A03\", 0},\n\t{\"\", 0},\n};\n\nstatic struct acpi_scan_handler pci_root_handler = {\n\t.ids = root_device_ids,\n\t.attach = acpi_pci_root_add,\n\t.detach = acpi_pci_root_remove,\n\t.hotplug = {\n\t\t.enabled = true,\n\t\t.scan_dependent = acpi_pci_root_scan_dependent,\n\t},\n};\n\n \nint acpi_is_root_bridge(acpi_handle handle)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\tint ret;\n\n\tif (!device)\n\t\treturn 0;\n\n\tret = acpi_match_device_ids(device, root_device_ids);\n\tif (ret)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\nEXPORT_SYMBOL_GPL(acpi_is_root_bridge);\n\nstatic acpi_status\nget_root_bridge_busnr_callback(struct acpi_resource *resource, void *data)\n{\n\tstruct resource *res = data;\n\tstruct acpi_resource_address64 address;\n\tacpi_status status;\n\n\tstatus = acpi_resource_to_address64(resource, &address);\n\tif (ACPI_FAILURE(status))\n\t\treturn AE_OK;\n\n\tif ((address.address.address_length > 0) &&\n\t    (address.resource_type == ACPI_BUS_NUMBER_RANGE)) {\n\t\tres->start = address.address.minimum;\n\t\tres->end = address.address.minimum + address.address.address_length - 1;\n\t}\n\n\treturn AE_OK;\n}\n\nstatic acpi_status try_get_root_bridge_busnr(acpi_handle handle,\n\t\t\t\t\t     struct resource *res)\n{\n\tacpi_status status;\n\n\tres->start = -1;\n\tstatus =\n\t    acpi_walk_resources(handle, METHOD_NAME__CRS,\n\t\t\t\tget_root_bridge_busnr_callback, res);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\tif (res->start == -1)\n\t\treturn AE_ERROR;\n\treturn AE_OK;\n}\n\nstruct pci_osc_bit_struct {\n\tu32 bit;\n\tchar *desc;\n};\n\nstatic struct pci_osc_bit_struct pci_osc_support_bit[] = {\n\t{ OSC_PCI_EXT_CONFIG_SUPPORT, \"ExtendedConfig\" },\n\t{ OSC_PCI_ASPM_SUPPORT, \"ASPM\" },\n\t{ OSC_PCI_CLOCK_PM_SUPPORT, \"ClockPM\" },\n\t{ OSC_PCI_SEGMENT_GROUPS_SUPPORT, \"Segments\" },\n\t{ OSC_PCI_MSI_SUPPORT, \"MSI\" },\n\t{ OSC_PCI_EDR_SUPPORT, \"EDR\" },\n\t{ OSC_PCI_HPX_TYPE_3_SUPPORT, \"HPX-Type3\" },\n};\n\nstatic struct pci_osc_bit_struct pci_osc_control_bit[] = {\n\t{ OSC_PCI_EXPRESS_NATIVE_HP_CONTROL, \"PCIeHotplug\" },\n\t{ OSC_PCI_SHPC_NATIVE_HP_CONTROL, \"SHPCHotplug\" },\n\t{ OSC_PCI_EXPRESS_PME_CONTROL, \"PME\" },\n\t{ OSC_PCI_EXPRESS_AER_CONTROL, \"AER\" },\n\t{ OSC_PCI_EXPRESS_CAPABILITY_CONTROL, \"PCIeCapability\" },\n\t{ OSC_PCI_EXPRESS_LTR_CONTROL, \"LTR\" },\n\t{ OSC_PCI_EXPRESS_DPC_CONTROL, \"DPC\" },\n};\n\nstatic struct pci_osc_bit_struct cxl_osc_support_bit[] = {\n\t{ OSC_CXL_1_1_PORT_REG_ACCESS_SUPPORT, \"CXL11PortRegAccess\" },\n\t{ OSC_CXL_2_0_PORT_DEV_REG_ACCESS_SUPPORT, \"CXL20PortDevRegAccess\" },\n\t{ OSC_CXL_PROTOCOL_ERR_REPORTING_SUPPORT, \"CXLProtocolErrorReporting\" },\n\t{ OSC_CXL_NATIVE_HP_SUPPORT, \"CXLNativeHotPlug\" },\n};\n\nstatic struct pci_osc_bit_struct cxl_osc_control_bit[] = {\n\t{ OSC_CXL_ERROR_REPORTING_CONTROL, \"CXLMemErrorReporting\" },\n};\n\nstatic void decode_osc_bits(struct acpi_pci_root *root, char *msg, u32 word,\n\t\t\t    struct pci_osc_bit_struct *table, int size)\n{\n\tchar buf[80];\n\tint i, len = 0;\n\tstruct pci_osc_bit_struct *entry;\n\n\tbuf[0] = '\\0';\n\tfor (i = 0, entry = table; i < size; i++, entry++)\n\t\tif (word & entry->bit)\n\t\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \"%s%s\",\n\t\t\t\t\tlen ? \" \" : \"\", entry->desc);\n\n\tdev_info(&root->device->dev, \"_OSC: %s [%s]\\n\", msg, buf);\n}\n\nstatic void decode_osc_support(struct acpi_pci_root *root, char *msg, u32 word)\n{\n\tdecode_osc_bits(root, msg, word, pci_osc_support_bit,\n\t\t\tARRAY_SIZE(pci_osc_support_bit));\n}\n\nstatic void decode_osc_control(struct acpi_pci_root *root, char *msg, u32 word)\n{\n\tdecode_osc_bits(root, msg, word, pci_osc_control_bit,\n\t\t\tARRAY_SIZE(pci_osc_control_bit));\n}\n\nstatic void decode_cxl_osc_support(struct acpi_pci_root *root, char *msg, u32 word)\n{\n\tdecode_osc_bits(root, msg, word, cxl_osc_support_bit,\n\t\t\tARRAY_SIZE(cxl_osc_support_bit));\n}\n\nstatic void decode_cxl_osc_control(struct acpi_pci_root *root, char *msg, u32 word)\n{\n\tdecode_osc_bits(root, msg, word, cxl_osc_control_bit,\n\t\t\tARRAY_SIZE(cxl_osc_control_bit));\n}\n\nstatic inline bool is_pcie(struct acpi_pci_root *root)\n{\n\treturn root->bridge_type == ACPI_BRIDGE_TYPE_PCIE;\n}\n\nstatic inline bool is_cxl(struct acpi_pci_root *root)\n{\n\treturn root->bridge_type == ACPI_BRIDGE_TYPE_CXL;\n}\n\nstatic u8 pci_osc_uuid_str[] = \"33DB4D5B-1FF7-401C-9657-7441C03DD766\";\nstatic u8 cxl_osc_uuid_str[] = \"68F2D50B-C469-4d8A-BD3D-941A103FD3FC\";\n\nstatic char *to_uuid(struct acpi_pci_root *root)\n{\n\tif (is_cxl(root))\n\t\treturn cxl_osc_uuid_str;\n\treturn pci_osc_uuid_str;\n}\n\nstatic int cap_length(struct acpi_pci_root *root)\n{\n\tif (is_cxl(root))\n\t\treturn sizeof(u32) * OSC_CXL_CAPABILITY_DWORDS;\n\treturn sizeof(u32) * OSC_PCI_CAPABILITY_DWORDS;\n}\n\nstatic acpi_status acpi_pci_run_osc(struct acpi_pci_root *root,\n\t\t\t\t    const u32 *capbuf, u32 *pci_control,\n\t\t\t\t    u32 *cxl_control)\n{\n\tstruct acpi_osc_context context = {\n\t\t.uuid_str = to_uuid(root),\n\t\t.rev = 1,\n\t\t.cap.length = cap_length(root),\n\t\t.cap.pointer = (void *)capbuf,\n\t};\n\tacpi_status status;\n\n\tstatus = acpi_run_osc(root->device->handle, &context);\n\tif (ACPI_SUCCESS(status)) {\n\t\t*pci_control = acpi_osc_ctx_get_pci_control(&context);\n\t\tif (is_cxl(root))\n\t\t\t*cxl_control = acpi_osc_ctx_get_cxl_control(&context);\n\t\tkfree(context.ret.pointer);\n\t}\n\treturn status;\n}\n\nstatic acpi_status acpi_pci_query_osc(struct acpi_pci_root *root, u32 support,\n\t\t\t\t      u32 *control, u32 cxl_support,\n\t\t\t\t      u32 *cxl_control)\n{\n\tacpi_status status;\n\tu32 pci_result, cxl_result, capbuf[OSC_CXL_CAPABILITY_DWORDS];\n\n\tsupport |= root->osc_support_set;\n\n\tcapbuf[OSC_QUERY_DWORD] = OSC_QUERY_ENABLE;\n\tcapbuf[OSC_SUPPORT_DWORD] = support;\n\tcapbuf[OSC_CONTROL_DWORD] = *control | root->osc_control_set;\n\n\tif (is_cxl(root)) {\n\t\tcxl_support |= root->osc_ext_support_set;\n\t\tcapbuf[OSC_EXT_SUPPORT_DWORD] = cxl_support;\n\t\tcapbuf[OSC_EXT_CONTROL_DWORD] = *cxl_control | root->osc_ext_control_set;\n\t}\n\nretry:\n\tstatus = acpi_pci_run_osc(root, capbuf, &pci_result, &cxl_result);\n\tif (ACPI_SUCCESS(status)) {\n\t\troot->osc_support_set = support;\n\t\t*control = pci_result;\n\t\tif (is_cxl(root)) {\n\t\t\troot->osc_ext_support_set = cxl_support;\n\t\t\t*cxl_control = cxl_result;\n\t\t}\n\t} else if (is_cxl(root)) {\n\t\t \n\t\troot->bridge_type = ACPI_BRIDGE_TYPE_PCIE;\n\t\tgoto retry;\n\t}\n\treturn status;\n}\n\nstruct acpi_pci_root *acpi_pci_find_root(acpi_handle handle)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\tstruct acpi_pci_root *root;\n\n\tif (!device || acpi_match_device_ids(device, root_device_ids))\n\t\treturn NULL;\n\n\troot = acpi_driver_data(device);\n\n\treturn root;\n}\nEXPORT_SYMBOL_GPL(acpi_pci_find_root);\n\nstruct acpi_handle_node {\n\tstruct list_head node;\n\tacpi_handle handle;\n};\n\n \nstruct pci_dev *acpi_get_pci_dev(acpi_handle handle)\n{\n\tstruct acpi_device *adev = acpi_fetch_acpi_dev(handle);\n\tstruct acpi_device_physical_node *pn;\n\tstruct pci_dev *pci_dev = NULL;\n\n\tif (!adev)\n\t\treturn NULL;\n\n\tmutex_lock(&adev->physical_node_lock);\n\n\tlist_for_each_entry(pn, &adev->physical_node_list, node) {\n\t\tif (dev_is_pci(pn->dev)) {\n\t\t\tget_device(pn->dev);\n\t\t\tpci_dev = to_pci_dev(pn->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&adev->physical_node_lock);\n\n\treturn pci_dev;\n}\nEXPORT_SYMBOL_GPL(acpi_get_pci_dev);\n\n \nstatic acpi_status acpi_pci_osc_control_set(acpi_handle handle, u32 *mask,\n\t\t\t\t\t    u32 support, u32 *cxl_mask,\n\t\t\t\t\t    u32 cxl_support)\n{\n\tu32 req = OSC_PCI_EXPRESS_CAPABILITY_CONTROL;\n\tstruct acpi_pci_root *root;\n\tacpi_status status;\n\tu32 ctrl, cxl_ctrl = 0, capbuf[OSC_CXL_CAPABILITY_DWORDS];\n\n\tif (!mask)\n\t\treturn AE_BAD_PARAMETER;\n\n\troot = acpi_pci_find_root(handle);\n\tif (!root)\n\t\treturn AE_NOT_EXIST;\n\n\tctrl   = *mask;\n\t*mask |= root->osc_control_set;\n\n\tif (is_cxl(root)) {\n\t\tcxl_ctrl = *cxl_mask;\n\t\t*cxl_mask |= root->osc_ext_control_set;\n\t}\n\n\t \n\tdo {\n\t\tu32 pci_missing = 0, cxl_missing = 0;\n\n\t\tstatus = acpi_pci_query_osc(root, support, mask, cxl_support,\n\t\t\t\t\t    cxl_mask);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn status;\n\t\tif (is_cxl(root)) {\n\t\t\tif (ctrl == *mask && cxl_ctrl == *cxl_mask)\n\t\t\t\tbreak;\n\t\t\tpci_missing = ctrl & ~(*mask);\n\t\t\tcxl_missing = cxl_ctrl & ~(*cxl_mask);\n\t\t} else {\n\t\t\tif (ctrl == *mask)\n\t\t\t\tbreak;\n\t\t\tpci_missing = ctrl & ~(*mask);\n\t\t}\n\t\tif (pci_missing)\n\t\t\tdecode_osc_control(root, \"platform does not support\",\n\t\t\t\t\t   pci_missing);\n\t\tif (cxl_missing)\n\t\t\tdecode_cxl_osc_control(root, \"CXL platform does not support\",\n\t\t\t\t\t   cxl_missing);\n\t\tctrl = *mask;\n\t\tcxl_ctrl = *cxl_mask;\n\t} while (*mask || *cxl_mask);\n\n\t \n\tif ((root->osc_control_set & ctrl) == ctrl &&\n\t    (root->osc_ext_control_set & cxl_ctrl) == cxl_ctrl)\n\t\treturn AE_OK;\n\n\tif ((ctrl & req) != req) {\n\t\tdecode_osc_control(root, \"not requesting control; platform does not support\",\n\t\t\t\t   req & ~(ctrl));\n\t\treturn AE_SUPPORT;\n\t}\n\n\tcapbuf[OSC_QUERY_DWORD] = 0;\n\tcapbuf[OSC_SUPPORT_DWORD] = root->osc_support_set;\n\tcapbuf[OSC_CONTROL_DWORD] = ctrl;\n\tif (is_cxl(root)) {\n\t\tcapbuf[OSC_EXT_SUPPORT_DWORD] = root->osc_ext_support_set;\n\t\tcapbuf[OSC_EXT_CONTROL_DWORD] = cxl_ctrl;\n\t}\n\n\tstatus = acpi_pci_run_osc(root, capbuf, mask, cxl_mask);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\troot->osc_control_set = *mask;\n\troot->osc_ext_control_set = *cxl_mask;\n\treturn AE_OK;\n}\n\nstatic u32 calculate_support(void)\n{\n\tu32 support;\n\n\t \n\tsupport = OSC_PCI_SEGMENT_GROUPS_SUPPORT;\n\tsupport |= OSC_PCI_HPX_TYPE_3_SUPPORT;\n\tif (pci_ext_cfg_avail())\n\t\tsupport |= OSC_PCI_EXT_CONFIG_SUPPORT;\n\tif (pcie_aspm_support_enabled())\n\t\tsupport |= OSC_PCI_ASPM_SUPPORT | OSC_PCI_CLOCK_PM_SUPPORT;\n\tif (pci_msi_enabled())\n\t\tsupport |= OSC_PCI_MSI_SUPPORT;\n\tif (IS_ENABLED(CONFIG_PCIE_EDR))\n\t\tsupport |= OSC_PCI_EDR_SUPPORT;\n\n\treturn support;\n}\n\n \nstatic u32 calculate_cxl_support(void)\n{\n\tu32 support;\n\n\tsupport = OSC_CXL_2_0_PORT_DEV_REG_ACCESS_SUPPORT;\n\tsupport |= OSC_CXL_1_1_PORT_REG_ACCESS_SUPPORT;\n\tif (pci_aer_available())\n\t\tsupport |= OSC_CXL_PROTOCOL_ERR_REPORTING_SUPPORT;\n\tif (IS_ENABLED(CONFIG_HOTPLUG_PCI_PCIE))\n\t\tsupport |= OSC_CXL_NATIVE_HP_SUPPORT;\n\n\treturn support;\n}\n\nstatic u32 calculate_control(void)\n{\n\tu32 control;\n\n\tcontrol = OSC_PCI_EXPRESS_CAPABILITY_CONTROL\n\t\t| OSC_PCI_EXPRESS_PME_CONTROL;\n\n\tif (IS_ENABLED(CONFIG_PCIEASPM))\n\t\tcontrol |= OSC_PCI_EXPRESS_LTR_CONTROL;\n\n\tif (IS_ENABLED(CONFIG_HOTPLUG_PCI_PCIE))\n\t\tcontrol |= OSC_PCI_EXPRESS_NATIVE_HP_CONTROL;\n\n\tif (IS_ENABLED(CONFIG_HOTPLUG_PCI_SHPC))\n\t\tcontrol |= OSC_PCI_SHPC_NATIVE_HP_CONTROL;\n\n\tif (pci_aer_available())\n\t\tcontrol |= OSC_PCI_EXPRESS_AER_CONTROL;\n\n\t \n\tif (IS_ENABLED(CONFIG_PCIE_DPC) && IS_ENABLED(CONFIG_PCIE_EDR))\n\t\tcontrol |= OSC_PCI_EXPRESS_DPC_CONTROL;\n\n\treturn control;\n}\n\nstatic u32 calculate_cxl_control(void)\n{\n\tu32 control = 0;\n\n\tif (IS_ENABLED(CONFIG_MEMORY_FAILURE))\n\t\tcontrol |= OSC_CXL_ERROR_REPORTING_CONTROL;\n\n\treturn control;\n}\n\nstatic bool os_control_query_checks(struct acpi_pci_root *root, u32 support)\n{\n\tstruct acpi_device *device = root->device;\n\n\tif (pcie_ports_disabled) {\n\t\tdev_info(&device->dev, \"PCIe port services disabled; not requesting _OSC control\\n\");\n\t\treturn false;\n\t}\n\n\tif ((support & ACPI_PCIE_REQ_SUPPORT) != ACPI_PCIE_REQ_SUPPORT) {\n\t\tdecode_osc_support(root, \"not requesting OS control; OS requires\",\n\t\t\t\t   ACPI_PCIE_REQ_SUPPORT);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void negotiate_os_control(struct acpi_pci_root *root, int *no_aspm)\n{\n\tu32 support, control = 0, requested = 0;\n\tu32 cxl_support = 0, cxl_control = 0, cxl_requested = 0;\n\tacpi_status status;\n\tstruct acpi_device *device = root->device;\n\tacpi_handle handle = device->handle;\n\n\t \n\tif (x86_apple_machine) {\n\t\troot->osc_control_set = ~OSC_PCI_EXPRESS_PME_CONTROL;\n\t\tdecode_osc_control(root, \"OS assumes control of\",\n\t\t\t\t   root->osc_control_set);\n\t\treturn;\n\t}\n\n\tsupport = calculate_support();\n\n\tdecode_osc_support(root, \"OS supports\", support);\n\n\tif (os_control_query_checks(root, support))\n\t\trequested = control = calculate_control();\n\n\tif (is_cxl(root)) {\n\t\tcxl_support = calculate_cxl_support();\n\t\tdecode_cxl_osc_support(root, \"OS supports\", cxl_support);\n\t\tcxl_requested = cxl_control = calculate_cxl_control();\n\t}\n\n\tstatus = acpi_pci_osc_control_set(handle, &control, support,\n\t\t\t\t\t  &cxl_control, cxl_support);\n\tif (ACPI_SUCCESS(status)) {\n\t\tif (control)\n\t\t\tdecode_osc_control(root, \"OS now controls\", control);\n\t\tif (cxl_control)\n\t\t\tdecode_cxl_osc_control(root, \"OS now controls\",\n\t\t\t\t\t   cxl_control);\n\n\t\tif (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_ASPM) {\n\t\t\t \n\t\t\tdev_info(&device->dev, \"FADT indicates ASPM is unsupported, using BIOS configuration\\n\");\n\t\t\t*no_aspm = 1;\n\t\t}\n\t} else {\n\t\t \n\t\t*no_aspm = 1;\n\n\t\t \n\t\tif (status == AE_NOT_FOUND && !is_pcie(root))\n\t\t\treturn;\n\n\t\tif (control) {\n\t\t\tdecode_osc_control(root, \"OS requested\", requested);\n\t\t\tdecode_osc_control(root, \"platform willing to grant\", control);\n\t\t}\n\t\tif (cxl_control) {\n\t\t\tdecode_cxl_osc_control(root, \"OS requested\", cxl_requested);\n\t\t\tdecode_cxl_osc_control(root, \"platform willing to grant\",\n\t\t\t\t\t   cxl_control);\n\t\t}\n\n\t\tdev_info(&device->dev, \"_OSC: platform retains control of PCIe features (%s)\\n\",\n\t\t\t acpi_format_exception(status));\n\t}\n}\n\nstatic int acpi_pci_root_add(struct acpi_device *device,\n\t\t\t     const struct acpi_device_id *not_used)\n{\n\tunsigned long long segment, bus;\n\tacpi_status status;\n\tint result;\n\tstruct acpi_pci_root *root;\n\tacpi_handle handle = device->handle;\n\tint no_aspm = 0;\n\tbool hotadd = system_state == SYSTEM_RUNNING;\n\tconst char *acpi_hid;\n\n\troot = kzalloc(sizeof(struct acpi_pci_root), GFP_KERNEL);\n\tif (!root)\n\t\treturn -ENOMEM;\n\n\tsegment = 0;\n\tstatus = acpi_evaluate_integer(handle, METHOD_NAME__SEG, NULL,\n\t\t\t\t       &segment);\n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\n\t\tdev_err(&device->dev,  \"can't evaluate _SEG\\n\");\n\t\tresult = -ENODEV;\n\t\tgoto end;\n\t}\n\n\t \n\troot->secondary.flags = IORESOURCE_BUS;\n\tstatus = try_get_root_bridge_busnr(handle, &root->secondary);\n\tif (ACPI_FAILURE(status)) {\n\t\t \n\t\troot->secondary.end = 0xFF;\n\t\tdev_warn(&device->dev,\n\t\t\t FW_BUG \"no secondary bus range in _CRS\\n\");\n\t\tstatus = acpi_evaluate_integer(handle, METHOD_NAME__BBN,\n\t\t\t\t\t       NULL, &bus);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\troot->secondary.start = bus;\n\t\telse if (status == AE_NOT_FOUND)\n\t\t\troot->secondary.start = 0;\n\t\telse {\n\t\t\tdev_err(&device->dev, \"can't evaluate _BBN\\n\");\n\t\t\tresult = -ENODEV;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\troot->device = device;\n\troot->segment = segment & 0xFFFF;\n\tstrcpy(acpi_device_name(device), ACPI_PCI_ROOT_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_PCI_ROOT_CLASS);\n\tdevice->driver_data = root;\n\n\tif (hotadd && dmar_device_add(handle)) {\n\t\tresult = -ENXIO;\n\t\tgoto end;\n\t}\n\n\tpr_info(\"%s [%s] (domain %04x %pR)\\n\",\n\t       acpi_device_name(device), acpi_device_bid(device),\n\t       root->segment, &root->secondary);\n\n\troot->mcfg_addr = acpi_pci_root_get_mcfg_addr(handle);\n\n\tacpi_hid = acpi_device_hid(root->device);\n\tif (strcmp(acpi_hid, \"PNP0A08\") == 0)\n\t\troot->bridge_type = ACPI_BRIDGE_TYPE_PCIE;\n\telse if (strcmp(acpi_hid, \"ACPI0016\") == 0)\n\t\troot->bridge_type = ACPI_BRIDGE_TYPE_CXL;\n\telse\n\t\tdev_dbg(&device->dev, \"Assuming non-PCIe host bridge\\n\");\n\n\tnegotiate_os_control(root, &no_aspm);\n\n\t \n\n\t \n\troot->bus = pci_acpi_scan_root(root);\n\tif (!root->bus) {\n\t\tdev_err(&device->dev,\n\t\t\t\"Bus %04x:%02x not present in PCI namespace\\n\",\n\t\t\troot->segment, (unsigned int)root->secondary.start);\n\t\tdevice->driver_data = NULL;\n\t\tresult = -ENODEV;\n\t\tgoto remove_dmar;\n\t}\n\n\tif (no_aspm)\n\t\tpcie_no_aspm();\n\n\tpci_acpi_add_bus_pm_notifier(device);\n\tdevice_set_wakeup_capable(root->bus->bridge, device->wakeup.flags.valid);\n\n\tif (hotadd) {\n\t\tpcibios_resource_survey_bus(root->bus);\n\t\tpci_assign_unassigned_root_bus_resources(root->bus);\n\t\t \n\t\tacpi_ioapic_add(root->device->handle);\n\t}\n\n\tpci_lock_rescan_remove();\n\tpci_bus_add_devices(root->bus);\n\tpci_unlock_rescan_remove();\n\treturn 1;\n\nremove_dmar:\n\tif (hotadd)\n\t\tdmar_device_remove(handle);\nend:\n\tkfree(root);\n\treturn result;\n}\n\nstatic void acpi_pci_root_remove(struct acpi_device *device)\n{\n\tstruct acpi_pci_root *root = acpi_driver_data(device);\n\n\tpci_lock_rescan_remove();\n\n\tpci_stop_root_bus(root->bus);\n\n\tpci_ioapic_remove(root);\n\tdevice_set_wakeup_capable(root->bus->bridge, false);\n\tpci_acpi_remove_bus_pm_notifier(device);\n\n\tpci_remove_root_bus(root->bus);\n\tWARN_ON(acpi_ioapic_remove(root));\n\n\tdmar_device_remove(device->handle);\n\n\tpci_unlock_rescan_remove();\n\n\tkfree(root);\n}\n\n \nstatic void acpi_pci_root_validate_resources(struct device *dev,\n\t\t\t\t\t     struct list_head *resources,\n\t\t\t\t\t     unsigned long type)\n{\n\tLIST_HEAD(list);\n\tstruct resource *res1, *res2, *root = NULL;\n\tstruct resource_entry *tmp, *entry, *entry2;\n\n\tBUG_ON((type & (IORESOURCE_MEM | IORESOURCE_IO)) == 0);\n\troot = (type & IORESOURCE_MEM) ? &iomem_resource : &ioport_resource;\n\n\tlist_splice_init(resources, &list);\n\tresource_list_for_each_entry_safe(entry, tmp, &list) {\n\t\tbool free = false;\n\t\tresource_size_t end;\n\n\t\tres1 = entry->res;\n\t\tif (!(res1->flags & type))\n\t\t\tgoto next;\n\n\t\t \n\t\tend = min(res1->end, root->end);\n\t\tif (end <= res1->start) {\n\t\t\tdev_info(dev, \"host bridge window %pR (ignored, not CPU addressable)\\n\",\n\t\t\t\t res1);\n\t\t\tfree = true;\n\t\t\tgoto next;\n\t\t} else if (res1->end != end) {\n\t\t\tdev_info(dev, \"host bridge window %pR ([%#llx-%#llx] ignored, not CPU addressable)\\n\",\n\t\t\t\t res1, (unsigned long long)end + 1,\n\t\t\t\t (unsigned long long)res1->end);\n\t\t\tres1->end = end;\n\t\t}\n\n\t\tresource_list_for_each_entry(entry2, resources) {\n\t\t\tres2 = entry2->res;\n\t\t\tif (!(res2->flags & type))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (resource_union(res1, res2, res2)) {\n\t\t\t\tdev_info(dev, \"host bridge window expanded to %pR; %pR ignored\\n\",\n\t\t\t\t\t res2, res1);\n\t\t\t\tfree = true;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\nnext:\n\t\tresource_list_del(entry);\n\t\tif (free)\n\t\t\tresource_list_free_entry(entry);\n\t\telse\n\t\t\tresource_list_add_tail(entry, resources);\n\t}\n}\n\nstatic void acpi_pci_root_remap_iospace(struct fwnode_handle *fwnode,\n\t\t\tstruct resource_entry *entry)\n{\n#ifdef PCI_IOBASE\n\tstruct resource *res = entry->res;\n\tresource_size_t cpu_addr = res->start;\n\tresource_size_t pci_addr = cpu_addr - entry->offset;\n\tresource_size_t length = resource_size(res);\n\tunsigned long port;\n\n\tif (pci_register_io_range(fwnode, cpu_addr, length))\n\t\tgoto err;\n\n\tport = pci_address_to_pio(cpu_addr);\n\tif (port == (unsigned long)-1)\n\t\tgoto err;\n\n\tres->start = port;\n\tres->end = port + length - 1;\n\tentry->offset = port - pci_addr;\n\n\tif (pci_remap_iospace(res, cpu_addr) < 0)\n\t\tgoto err;\n\n\tpr_info(\"Remapped I/O %pa to %pR\\n\", &cpu_addr, res);\n\treturn;\nerr:\n\tres->flags |= IORESOURCE_DISABLED;\n#endif\n}\n\nint acpi_pci_probe_root_resources(struct acpi_pci_root_info *info)\n{\n\tint ret;\n\tstruct list_head *list = &info->resources;\n\tstruct acpi_device *device = info->bridge;\n\tstruct resource_entry *entry, *tmp;\n\tunsigned long flags;\n\n\tflags = IORESOURCE_IO | IORESOURCE_MEM | IORESOURCE_MEM_8AND16BIT;\n\tret = acpi_dev_get_resources(device, list,\n\t\t\t\t     acpi_dev_filter_resource_type_cb,\n\t\t\t\t     (void *)flags);\n\tif (ret < 0)\n\t\tdev_warn(&device->dev,\n\t\t\t \"failed to parse _CRS method, error code %d\\n\", ret);\n\telse if (ret == 0)\n\t\tdev_dbg(&device->dev,\n\t\t\t\"no IO and memory resources present in _CRS\\n\");\n\telse {\n\t\tresource_list_for_each_entry_safe(entry, tmp, list) {\n\t\t\tif (entry->res->flags & IORESOURCE_IO)\n\t\t\t\tacpi_pci_root_remap_iospace(&device->fwnode,\n\t\t\t\t\t\tentry);\n\n\t\t\tif (entry->res->flags & IORESOURCE_DISABLED)\n\t\t\t\tresource_list_destroy_entry(entry);\n\t\t\telse\n\t\t\t\tentry->res->name = info->name;\n\t\t}\n\t\tacpi_pci_root_validate_resources(&device->dev, list,\n\t\t\t\t\t\t IORESOURCE_MEM);\n\t\tacpi_pci_root_validate_resources(&device->dev, list,\n\t\t\t\t\t\t IORESOURCE_IO);\n\t}\n\n\treturn ret;\n}\n\nstatic void pci_acpi_root_add_resources(struct acpi_pci_root_info *info)\n{\n\tstruct resource_entry *entry, *tmp;\n\tstruct resource *res, *conflict, *root = NULL;\n\n\tresource_list_for_each_entry_safe(entry, tmp, &info->resources) {\n\t\tres = entry->res;\n\t\tif (res->flags & IORESOURCE_MEM)\n\t\t\troot = &iomem_resource;\n\t\telse if (res->flags & IORESOURCE_IO)\n\t\t\troot = &ioport_resource;\n\t\telse\n\t\t\tcontinue;\n\n\t\t \n\t\tif (res == root)\n\t\t\tcontinue;\n\n\t\tconflict = insert_resource_conflict(root, res);\n\t\tif (conflict) {\n\t\t\tdev_info(&info->bridge->dev,\n\t\t\t\t \"ignoring host bridge window %pR (conflicts with %s %pR)\\n\",\n\t\t\t\t res, conflict->name, conflict);\n\t\t\tresource_list_destroy_entry(entry);\n\t\t}\n\t}\n}\n\nstatic void __acpi_pci_root_release_info(struct acpi_pci_root_info *info)\n{\n\tstruct resource *res;\n\tstruct resource_entry *entry, *tmp;\n\n\tif (!info)\n\t\treturn;\n\n\tresource_list_for_each_entry_safe(entry, tmp, &info->resources) {\n\t\tres = entry->res;\n\t\tif (res->parent &&\n\t\t    (res->flags & (IORESOURCE_MEM | IORESOURCE_IO)))\n\t\t\trelease_resource(res);\n\t\tresource_list_destroy_entry(entry);\n\t}\n\n\tinfo->ops->release_info(info);\n}\n\nstatic void acpi_pci_root_release_info(struct pci_host_bridge *bridge)\n{\n\tstruct resource *res;\n\tstruct resource_entry *entry;\n\n\tresource_list_for_each_entry(entry, &bridge->windows) {\n\t\tres = entry->res;\n\t\tif (res->flags & IORESOURCE_IO)\n\t\t\tpci_unmap_iospace(res);\n\t\tif (res->parent &&\n\t\t    (res->flags & (IORESOURCE_MEM | IORESOURCE_IO)))\n\t\t\trelease_resource(res);\n\t}\n\t__acpi_pci_root_release_info(bridge->release_data);\n}\n\nstruct pci_bus *acpi_pci_root_create(struct acpi_pci_root *root,\n\t\t\t\t     struct acpi_pci_root_ops *ops,\n\t\t\t\t     struct acpi_pci_root_info *info,\n\t\t\t\t     void *sysdata)\n{\n\tint ret, busnum = root->secondary.start;\n\tstruct acpi_device *device = root->device;\n\tint node = acpi_get_node(device->handle);\n\tstruct pci_bus *bus;\n\tstruct pci_host_bridge *host_bridge;\n\tunion acpi_object *obj;\n\n\tinfo->root = root;\n\tinfo->bridge = device;\n\tinfo->ops = ops;\n\tINIT_LIST_HEAD(&info->resources);\n\tsnprintf(info->name, sizeof(info->name), \"PCI Bus %04x:%02x\",\n\t\t root->segment, busnum);\n\n\tif (ops->init_info && ops->init_info(info))\n\t\tgoto out_release_info;\n\tif (ops->prepare_resources)\n\t\tret = ops->prepare_resources(info);\n\telse\n\t\tret = acpi_pci_probe_root_resources(info);\n\tif (ret < 0)\n\t\tgoto out_release_info;\n\n\tpci_acpi_root_add_resources(info);\n\tpci_add_resource(&info->resources, &root->secondary);\n\tbus = pci_create_root_bus(NULL, busnum, ops->pci_ops,\n\t\t\t\t  sysdata, &info->resources);\n\tif (!bus)\n\t\tgoto out_release_info;\n\n\thost_bridge = to_pci_host_bridge(bus->bridge);\n\tif (!(root->osc_control_set & OSC_PCI_EXPRESS_NATIVE_HP_CONTROL))\n\t\thost_bridge->native_pcie_hotplug = 0;\n\tif (!(root->osc_control_set & OSC_PCI_SHPC_NATIVE_HP_CONTROL))\n\t\thost_bridge->native_shpc_hotplug = 0;\n\tif (!(root->osc_control_set & OSC_PCI_EXPRESS_AER_CONTROL))\n\t\thost_bridge->native_aer = 0;\n\tif (!(root->osc_control_set & OSC_PCI_EXPRESS_PME_CONTROL))\n\t\thost_bridge->native_pme = 0;\n\tif (!(root->osc_control_set & OSC_PCI_EXPRESS_LTR_CONTROL))\n\t\thost_bridge->native_ltr = 0;\n\tif (!(root->osc_control_set & OSC_PCI_EXPRESS_DPC_CONTROL))\n\t\thost_bridge->native_dpc = 0;\n\n\tif (!(root->osc_ext_control_set & OSC_CXL_ERROR_REPORTING_CONTROL))\n\t\thost_bridge->native_cxl_error = 0;\n\n\t \n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(bus->bridge), &pci_acpi_dsm_guid, 1,\n\t\t\t\tDSM_PCI_PRESERVE_BOOT_CONFIG, NULL);\n\tif (obj && obj->type == ACPI_TYPE_INTEGER && obj->integer.value == 0)\n\t\thost_bridge->preserve_config = 1;\n\tACPI_FREE(obj);\n\n\tacpi_dev_power_up_children_with_adr(device);\n\n\tpci_scan_child_bus(bus);\n\tpci_set_host_bridge_release(host_bridge, acpi_pci_root_release_info,\n\t\t\t\t    info);\n\tif (node != NUMA_NO_NODE)\n\t\tdev_printk(KERN_DEBUG, &bus->dev, \"on NUMA node %d\\n\", node);\n\treturn bus;\n\nout_release_info:\n\t__acpi_pci_root_release_info(info);\n\treturn NULL;\n}\n\nvoid __init acpi_pci_root_init(void)\n{\n\tif (acpi_pci_disabled)\n\t\treturn;\n\n\tpci_acpi_crs_quirks();\n\tacpi_scan_add_handler_with_hotplug(&pci_root_handler, \"pci_root\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}