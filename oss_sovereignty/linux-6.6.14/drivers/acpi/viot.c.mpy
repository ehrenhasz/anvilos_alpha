{
  "module_name": "viot.c",
  "hash_id": "79bbb82a0219e031421d5b368934fc773ee4dd5c9fda7381413243b02449cf6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/viot.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"ACPI: VIOT: \" fmt\n\n#include <linux/acpi_viot.h>\n#include <linux/fwnode.h>\n#include <linux/iommu.h>\n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n\nstruct viot_iommu {\n\t \n\tunsigned int\t\t\toffset;\n\tstruct fwnode_handle\t\t*fwnode;\n\tstruct list_head\t\tlist;\n};\n\nstruct viot_endpoint {\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\tu16\t\tsegment_start;\n\t\t\tu16\t\tsegment_end;\n\t\t\tu16\t\tbdf_start;\n\t\t\tu16\t\tbdf_end;\n\t\t};\n\t\t \n\t\tu64\t\t\taddress;\n\t};\n\tu32\t\t\t\tendpoint_id;\n\tstruct viot_iommu\t\t*viommu;\n\tstruct list_head\t\tlist;\n};\n\nstatic struct acpi_table_viot *viot;\nstatic LIST_HEAD(viot_iommus);\nstatic LIST_HEAD(viot_pci_ranges);\nstatic LIST_HEAD(viot_mmio_endpoints);\n\nstatic int __init viot_check_bounds(const struct acpi_viot_header *hdr)\n{\n\tstruct acpi_viot_header *start, *end, *hdr_end;\n\n\tstart = ACPI_ADD_PTR(struct acpi_viot_header, viot,\n\t\t\t     max_t(size_t, sizeof(*viot), viot->node_offset));\n\tend = ACPI_ADD_PTR(struct acpi_viot_header, viot, viot->header.length);\n\thdr_end = ACPI_ADD_PTR(struct acpi_viot_header, hdr, sizeof(*hdr));\n\n\tif (hdr < start || hdr_end > end) {\n\t\tpr_err(FW_BUG \"Node pointer overflows\\n\");\n\t\treturn -EOVERFLOW;\n\t}\n\tif (hdr->length < sizeof(*hdr)) {\n\t\tpr_err(FW_BUG \"Empty node\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int __init viot_get_pci_iommu_fwnode(struct viot_iommu *viommu,\n\t\t\t\t\t    u16 segment, u16 bdf)\n{\n\tstruct pci_dev *pdev;\n\tstruct fwnode_handle *fwnode;\n\n\tpdev = pci_get_domain_bus_and_slot(segment, PCI_BUS_NUM(bdf),\n\t\t\t\t\t   bdf & 0xff);\n\tif (!pdev) {\n\t\tpr_err(\"Could not find PCI IOMMU\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfwnode = dev_fwnode(&pdev->dev);\n\tif (!fwnode) {\n\t\t \n\t\tfwnode = acpi_alloc_fwnode_static();\n\t\tif (!fwnode) {\n\t\t\tpci_dev_put(pdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tset_primary_fwnode(&pdev->dev, fwnode);\n\t}\n\tviommu->fwnode = dev_fwnode(&pdev->dev);\n\tpci_dev_put(pdev);\n\treturn 0;\n}\n\nstatic int __init viot_get_mmio_iommu_fwnode(struct viot_iommu *viommu,\n\t\t\t\t\t     u64 address)\n{\n\tstruct acpi_device *adev;\n\tstruct resource res = {\n\t\t.start\t= address,\n\t\t.end\t= address,\n\t\t.flags\t= IORESOURCE_MEM,\n\t};\n\n\tadev = acpi_resource_consumer(&res);\n\tif (!adev) {\n\t\tpr_err(\"Could not find MMIO IOMMU\\n\");\n\t\treturn -EINVAL;\n\t}\n\tviommu->fwnode = &adev->fwnode;\n\treturn 0;\n}\n\nstatic struct viot_iommu * __init viot_get_iommu(unsigned int offset)\n{\n\tint ret;\n\tstruct viot_iommu *viommu;\n\tstruct acpi_viot_header *hdr = ACPI_ADD_PTR(struct acpi_viot_header,\n\t\t\t\t\t\t    viot, offset);\n\tunion {\n\t\tstruct acpi_viot_virtio_iommu_pci pci;\n\t\tstruct acpi_viot_virtio_iommu_mmio mmio;\n\t} *node = (void *)hdr;\n\n\tlist_for_each_entry(viommu, &viot_iommus, list)\n\t\tif (viommu->offset == offset)\n\t\t\treturn viommu;\n\n\tif (viot_check_bounds(hdr))\n\t\treturn NULL;\n\n\tviommu = kzalloc(sizeof(*viommu), GFP_KERNEL);\n\tif (!viommu)\n\t\treturn NULL;\n\n\tviommu->offset = offset;\n\tswitch (hdr->type) {\n\tcase ACPI_VIOT_NODE_VIRTIO_IOMMU_PCI:\n\t\tif (hdr->length < sizeof(node->pci))\n\t\t\tgoto err_free;\n\n\t\tret = viot_get_pci_iommu_fwnode(viommu, node->pci.segment,\n\t\t\t\t\t\tnode->pci.bdf);\n\t\tbreak;\n\tcase ACPI_VIOT_NODE_VIRTIO_IOMMU_MMIO:\n\t\tif (hdr->length < sizeof(node->mmio))\n\t\t\tgoto err_free;\n\n\t\tret = viot_get_mmio_iommu_fwnode(viommu,\n\t\t\t\t\t\t node->mmio.base_address);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif (ret)\n\t\tgoto err_free;\n\n\tlist_add(&viommu->list, &viot_iommus);\n\treturn viommu;\n\nerr_free:\n\tkfree(viommu);\n\treturn NULL;\n}\n\nstatic int __init viot_parse_node(const struct acpi_viot_header *hdr)\n{\n\tint ret = -EINVAL;\n\tstruct list_head *list;\n\tstruct viot_endpoint *ep;\n\tunion {\n\t\tstruct acpi_viot_mmio mmio;\n\t\tstruct acpi_viot_pci_range pci;\n\t} *node = (void *)hdr;\n\n\tif (viot_check_bounds(hdr))\n\t\treturn -EINVAL;\n\n\tif (hdr->type == ACPI_VIOT_NODE_VIRTIO_IOMMU_PCI ||\n\t    hdr->type == ACPI_VIOT_NODE_VIRTIO_IOMMU_MMIO)\n\t\treturn 0;\n\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tswitch (hdr->type) {\n\tcase ACPI_VIOT_NODE_PCI_RANGE:\n\t\tif (hdr->length < sizeof(node->pci)) {\n\t\t\tpr_err(FW_BUG \"Invalid PCI node size\\n\");\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tep->segment_start = node->pci.segment_start;\n\t\tep->segment_end = node->pci.segment_end;\n\t\tep->bdf_start = node->pci.bdf_start;\n\t\tep->bdf_end = node->pci.bdf_end;\n\t\tep->endpoint_id = node->pci.endpoint_start;\n\t\tep->viommu = viot_get_iommu(node->pci.output_node);\n\t\tlist = &viot_pci_ranges;\n\t\tbreak;\n\tcase ACPI_VIOT_NODE_MMIO:\n\t\tif (hdr->length < sizeof(node->mmio)) {\n\t\t\tpr_err(FW_BUG \"Invalid MMIO node size\\n\");\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tep->address = node->mmio.base_address;\n\t\tep->endpoint_id = node->mmio.endpoint;\n\t\tep->viommu = viot_get_iommu(node->mmio.output_node);\n\t\tlist = &viot_mmio_endpoints;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Unsupported node %x\\n\", hdr->type);\n\t\tret = 0;\n\t\tgoto err_free;\n\t}\n\n\tif (!ep->viommu) {\n\t\tpr_warn(\"No IOMMU node found\\n\");\n\t\t \n\t\tret = 0;\n\t\tgoto err_free;\n\t}\n\n\tlist_add(&ep->list, list);\n\treturn 0;\n\nerr_free:\n\tkfree(ep);\n\treturn ret;\n}\n\n \nvoid __init acpi_viot_early_init(void)\n{\n#ifdef CONFIG_PCI\n\tacpi_status status;\n\tstruct acpi_table_header *hdr;\n\n\tstatus = acpi_get_table(ACPI_SIG_VIOT, 0, &hdr);\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\tpci_request_acs();\n\tacpi_put_table(hdr);\n#endif\n}\n\n \nvoid __init acpi_viot_init(void)\n{\n\tint i;\n\tacpi_status status;\n\tstruct acpi_table_header *hdr;\n\tstruct acpi_viot_header *node;\n\n\tstatus = acpi_get_table(ACPI_SIG_VIOT, 0, &hdr);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status != AE_NOT_FOUND) {\n\t\t\tconst char *msg = acpi_format_exception(status);\n\n\t\t\tpr_err(\"Failed to get table, %s\\n\", msg);\n\t\t}\n\t\treturn;\n\t}\n\n\tviot = (void *)hdr;\n\n\tnode = ACPI_ADD_PTR(struct acpi_viot_header, viot, viot->node_offset);\n\tfor (i = 0; i < viot->node_count; i++) {\n\t\tif (viot_parse_node(node))\n\t\t\treturn;\n\n\t\tnode = ACPI_ADD_PTR(struct acpi_viot_header, node,\n\t\t\t\t    node->length);\n\t}\n\n\tacpi_put_table(hdr);\n}\n\nstatic int viot_dev_iommu_init(struct device *dev, struct viot_iommu *viommu,\n\t\t\t       u32 epid)\n{\n\tconst struct iommu_ops *ops;\n\n\tif (!viommu)\n\t\treturn -ENODEV;\n\n\t \n\tif (device_match_fwnode(dev, viommu->fwnode))\n\t\treturn -EINVAL;\n\n\tops = iommu_ops_from_fwnode(viommu->fwnode);\n\tif (!ops)\n\t\treturn IS_ENABLED(CONFIG_VIRTIO_IOMMU) ?\n\t\t\t-EPROBE_DEFER : -ENODEV;\n\n\treturn acpi_iommu_fwspec_init(dev, epid, viommu->fwnode, ops);\n}\n\nstatic int viot_pci_dev_iommu_init(struct pci_dev *pdev, u16 dev_id, void *data)\n{\n\tu32 epid;\n\tstruct viot_endpoint *ep;\n\tstruct device *aliased_dev = data;\n\tu32 domain_nr = pci_domain_nr(pdev->bus);\n\n\tlist_for_each_entry(ep, &viot_pci_ranges, list) {\n\t\tif (domain_nr >= ep->segment_start &&\n\t\t    domain_nr <= ep->segment_end &&\n\t\t    dev_id >= ep->bdf_start &&\n\t\t    dev_id <= ep->bdf_end) {\n\t\t\tepid = ((domain_nr - ep->segment_start) << 16) +\n\t\t\t\tdev_id - ep->bdf_start + ep->endpoint_id;\n\n\t\t\treturn viot_dev_iommu_init(aliased_dev, ep->viommu,\n\t\t\t\t\t\t   epid);\n\t\t}\n\t}\n\treturn -ENODEV;\n}\n\nstatic int viot_mmio_dev_iommu_init(struct platform_device *pdev)\n{\n\tstruct resource *mem;\n\tstruct viot_endpoint *ep;\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!mem)\n\t\treturn -ENODEV;\n\n\tlist_for_each_entry(ep, &viot_mmio_endpoints, list) {\n\t\tif (ep->address == mem->start)\n\t\t\treturn viot_dev_iommu_init(&pdev->dev, ep->viommu,\n\t\t\t\t\t\t   ep->endpoint_id);\n\t}\n\treturn -ENODEV;\n}\n\n \nint viot_iommu_configure(struct device *dev)\n{\n\tif (dev_is_pci(dev))\n\t\treturn pci_for_each_dma_alias(to_pci_dev(dev),\n\t\t\t\t\t      viot_pci_dev_iommu_init, dev);\n\telse if (dev_is_platform(dev))\n\t\treturn viot_mmio_dev_iommu_init(to_platform_device(dev));\n\treturn -ENODEV;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}