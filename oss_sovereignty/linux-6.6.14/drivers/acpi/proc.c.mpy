{
  "module_name": "proc.c",
  "hash_id": "2df144c2cb6870447f2737b217dec562261ace00d34c4d27698fe1fd5b3c7e7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/proc.c",
  "human_readable_source": "\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/bcd.h>\n#include <linux/acpi.h>\n#include <linux/uaccess.h>\n\n#include \"sleep.h\"\n#include \"internal.h\"\n\n \n\nstatic int\nacpi_system_wakeup_device_seq_show(struct seq_file *seq, void *offset)\n{\n\tstruct acpi_device *dev, *tmp;\n\n\tseq_printf(seq, \"Device\\tS-state\\t  Status   Sysfs node\\n\");\n\n\tmutex_lock(&acpi_device_lock);\n\tlist_for_each_entry_safe(dev, tmp, &acpi_wakeup_device_list,\n\t\t\t\t wakeup_list) {\n\t\tstruct acpi_device_physical_node *entry;\n\n\t\tif (!dev->wakeup.flags.valid)\n\t\t\tcontinue;\n\n\t\tseq_printf(seq, \"%s\\t  S%d\\t\",\n\t\t\t   dev->pnp.bus_id,\n\t\t\t   (u32) dev->wakeup.sleep_state);\n\n\t\tmutex_lock(&dev->physical_node_lock);\n\n\t\tif (!dev->physical_node_count) {\n\t\t\tseq_printf(seq, \"%c%-8s\\n\",\n\t\t\t\tdev->wakeup.flags.valid ? '*' : ' ',\n\t\t\t\tdevice_may_wakeup(&dev->dev) ?\n\t\t\t\t\t\"enabled\" : \"disabled\");\n\t\t} else {\n\t\t\tstruct device *ldev;\n\t\t\tlist_for_each_entry(entry, &dev->physical_node_list,\n\t\t\t\t\tnode) {\n\t\t\t\tldev = get_device(entry->dev);\n\t\t\t\tif (!ldev)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (&entry->node !=\n\t\t\t\t\t\tdev->physical_node_list.next)\n\t\t\t\t\tseq_printf(seq, \"\\t\\t\");\n\n\t\t\t\tseq_printf(seq, \"%c%-8s  %s:%s\\n\",\n\t\t\t\t\tdev->wakeup.flags.valid ? '*' : ' ',\n\t\t\t\t\t(device_may_wakeup(&dev->dev) ||\n\t\t\t\t\tdevice_may_wakeup(ldev)) ?\n\t\t\t\t\t\"enabled\" : \"disabled\",\n\t\t\t\t\tldev->bus ? ldev->bus->name :\n\t\t\t\t\t\"no-bus\", dev_name(ldev));\n\t\t\t\tput_device(ldev);\n\t\t\t}\n\t\t}\n\n\t\tmutex_unlock(&dev->physical_node_lock);\n\t}\n\tmutex_unlock(&acpi_device_lock);\n\treturn 0;\n}\n\nstatic void physical_device_enable_wakeup(struct acpi_device *adev)\n{\n\tstruct acpi_device_physical_node *entry;\n\n\tmutex_lock(&adev->physical_node_lock);\n\n\tlist_for_each_entry(entry,\n\t\t&adev->physical_node_list, node)\n\t\tif (entry->dev && device_can_wakeup(entry->dev)) {\n\t\t\tbool enable = !device_may_wakeup(entry->dev);\n\t\t\tdevice_set_wakeup_enable(entry->dev, enable);\n\t\t}\n\n\tmutex_unlock(&adev->physical_node_lock);\n}\n\nstatic ssize_t\nacpi_system_write_wakeup_device(struct file *file,\n\t\t\t\tconst char __user * buffer,\n\t\t\t\tsize_t count, loff_t * ppos)\n{\n\tstruct acpi_device *dev, *tmp;\n\tchar strbuf[5];\n\tchar str[5] = \"\";\n\n\tif (count > 4)\n\t\tcount = 4;\n\n\tif (copy_from_user(strbuf, buffer, count))\n\t\treturn -EFAULT;\n\tstrbuf[count] = '\\0';\n\tsscanf(strbuf, \"%s\", str);\n\n\tmutex_lock(&acpi_device_lock);\n\tlist_for_each_entry_safe(dev, tmp, &acpi_wakeup_device_list,\n\t\t\t\t wakeup_list) {\n\t\tif (!dev->wakeup.flags.valid)\n\t\t\tcontinue;\n\n\t\tif (!strncmp(dev->pnp.bus_id, str, 4)) {\n\t\t\tif (device_can_wakeup(&dev->dev)) {\n\t\t\t\tbool enable = !device_may_wakeup(&dev->dev);\n\t\t\t\tdevice_set_wakeup_enable(&dev->dev, enable);\n\t\t\t} else {\n\t\t\t\tphysical_device_enable_wakeup(dev);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&acpi_device_lock);\n\treturn count;\n}\n\nstatic int\nacpi_system_wakeup_device_open_fs(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, acpi_system_wakeup_device_seq_show,\n\t\t\t   pde_data(inode));\n}\n\nstatic const struct proc_ops acpi_system_wakeup_device_proc_ops = {\n\t.proc_open\t= acpi_system_wakeup_device_open_fs,\n\t.proc_read\t= seq_read,\n\t.proc_write\t= acpi_system_write_wakeup_device,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n};\n\nvoid __init acpi_sleep_proc_init(void)\n{\n\t \n\tproc_create(\"wakeup\", S_IFREG | S_IRUGO | S_IWUSR,\n\t\t    acpi_root_dir, &acpi_system_wakeup_device_proc_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}