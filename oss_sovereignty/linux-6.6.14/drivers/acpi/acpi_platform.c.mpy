{
  "module_name": "acpi_platform.c",
  "hash_id": "b96bbe9c3a309127e4e0127a52410890cb38eb735577809b1cf69c9af37cf7a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_platform.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n\n#include \"internal.h\"\n\n \n#define ACPI_ALLOW_WO_RESOURCES\t\tBIT(0)\n\nstatic const struct acpi_device_id forbidden_id_list[] = {\n\t{\"ACPI0009\", 0},\t \n\t{\"ACPI000A\", 0},\t \n\t{\"PNP0000\",  0},\t \n\t{\"PNP0100\",  0},\t \n\t{\"PNP0200\",  0},\t \n\t{ACPI_SMBUS_MS_HID,  ACPI_ALLOW_WO_RESOURCES},\t \n\t{ }\n};\n\nstatic struct platform_device *acpi_platform_device_find_by_companion(struct acpi_device *adev)\n{\n\tstruct device *dev;\n\n\tdev = bus_find_device_by_acpi_dev(&platform_bus_type, adev);\n\treturn dev ? to_platform_device(dev) : NULL;\n}\n\nstatic int acpi_platform_device_remove_notify(struct notifier_block *nb,\n\t\t\t\t\t      unsigned long value, void *arg)\n{\n\tstruct acpi_device *adev = arg;\n\tstruct platform_device *pdev;\n\n\tswitch (value) {\n\tcase ACPI_RECONFIG_DEVICE_ADD:\n\t\t \n\t\tbreak;\n\tcase ACPI_RECONFIG_DEVICE_REMOVE:\n\t\tif (!acpi_device_enumerated(adev))\n\t\t\tbreak;\n\n\t\tpdev = acpi_platform_device_find_by_companion(adev);\n\t\tif (!pdev)\n\t\t\tbreak;\n\n\t\tplatform_device_unregister(pdev);\n\t\tput_device(&pdev->dev);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block acpi_platform_notifier = {\n\t.notifier_call = acpi_platform_device_remove_notify,\n};\n\nstatic void acpi_platform_fill_resource(struct acpi_device *adev,\n\tconst struct resource *src, struct resource *dest)\n{\n\tstruct device *parent;\n\n\t*dest = *src;\n\n\t \n\tparent = acpi_get_first_physical_node(acpi_dev_parent(adev));\n\tif (parent && dev_is_pci(parent))\n\t\tdest->parent = pci_find_resource(to_pci_dev(parent), dest);\n}\n\nstatic unsigned int acpi_platform_resource_count(struct acpi_resource *ares, void *data)\n{\n\tbool *has_resources = data;\n\n\t*has_resources = true;\n\n\treturn AE_CTRL_TERMINATE;\n}\n\n \nstruct platform_device *acpi_create_platform_device(struct acpi_device *adev,\n\t\t\t\t\t\t    const struct property_entry *properties)\n{\n\tstruct acpi_device *parent = acpi_dev_parent(adev);\n\tstruct platform_device *pdev = NULL;\n\tstruct platform_device_info pdevinfo;\n\tconst struct acpi_device_id *match;\n\tstruct resource_entry *rentry;\n\tstruct list_head resource_list;\n\tstruct resource *resources = NULL;\n\tint count;\n\n\t \n\tif (adev->physical_node_count)\n\t\treturn NULL;\n\n\tmatch = acpi_match_acpi_device(forbidden_id_list, adev);\n\tif (match) {\n\t\tif (match->driver_data & ACPI_ALLOW_WO_RESOURCES) {\n\t\t\tbool has_resources = false;\n\n\t\t\tacpi_walk_resources(adev->handle, METHOD_NAME__CRS,\n\t\t\t\t\t    acpi_platform_resource_count, &has_resources);\n\t\t\tif (has_resources)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t} else {\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\tINIT_LIST_HEAD(&resource_list);\n\tcount = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);\n\tif (count < 0)\n\t\treturn NULL;\n\tif (count > 0) {\n\t\tresources = kcalloc(count, sizeof(*resources), GFP_KERNEL);\n\t\tif (!resources) {\n\t\t\tacpi_dev_free_resource_list(&resource_list);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tcount = 0;\n\t\tlist_for_each_entry(rentry, &resource_list, node)\n\t\t\tacpi_platform_fill_resource(adev, rentry->res,\n\t\t\t\t\t\t    &resources[count++]);\n\n\t\tacpi_dev_free_resource_list(&resource_list);\n\t}\n\n\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\t \n\tpdevinfo.parent = parent ? acpi_get_first_physical_node(parent) : NULL;\n\tpdevinfo.name = dev_name(&adev->dev);\n\tpdevinfo.id = PLATFORM_DEVID_NONE;\n\tpdevinfo.res = resources;\n\tpdevinfo.num_res = count;\n\tpdevinfo.fwnode = acpi_fwnode_handle(adev);\n\tpdevinfo.properties = properties;\n\n\tif (acpi_dma_supported(adev))\n\t\tpdevinfo.dma_mask = DMA_BIT_MASK(32);\n\telse\n\t\tpdevinfo.dma_mask = 0;\n\n\tpdev = platform_device_register_full(&pdevinfo);\n\tif (IS_ERR(pdev))\n\t\tdev_err(&adev->dev, \"platform device creation failed: %ld\\n\",\n\t\t\tPTR_ERR(pdev));\n\telse {\n\t\tset_dev_node(&pdev->dev, acpi_get_node(adev->handle));\n\t\tdev_dbg(&adev->dev, \"created platform device %s\\n\",\n\t\t\tdev_name(&pdev->dev));\n\t}\n\n\tkfree(resources);\n\n\treturn pdev;\n}\nEXPORT_SYMBOL_GPL(acpi_create_platform_device);\n\nvoid __init acpi_platform_init(void)\n{\n\tacpi_reconfig_notifier_register(&acpi_platform_notifier);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}