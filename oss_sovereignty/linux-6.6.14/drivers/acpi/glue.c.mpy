{
  "module_name": "glue.c",
  "hash_id": "c7ff00fd460b50e16e406e2d6a11a86be32d2cc7b86bafe503fe291b4d5d922c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/glue.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/acpi_iort.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/acpi.h>\n#include <linux/dma-mapping.h>\n#include <linux/pci.h>\n#include <linux/pci-acpi.h>\n#include <linux/platform_device.h>\n\n#include \"internal.h\"\n\nstatic LIST_HEAD(bus_type_list);\nstatic DECLARE_RWSEM(bus_type_sem);\n\n#define PHYSICAL_NODE_STRING \"physical_node\"\n#define PHYSICAL_NODE_NAME_SIZE (sizeof(PHYSICAL_NODE_STRING) + 10)\n\nint register_acpi_bus_type(struct acpi_bus_type *type)\n{\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\tif (type && type->match && type->find_companion) {\n\t\tdown_write(&bus_type_sem);\n\t\tlist_add_tail(&type->list, &bus_type_list);\n\t\tup_write(&bus_type_sem);\n\t\tpr_info(\"bus type %s registered\\n\", type->name);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(register_acpi_bus_type);\n\nint unregister_acpi_bus_type(struct acpi_bus_type *type)\n{\n\tif (acpi_disabled)\n\t\treturn 0;\n\tif (type) {\n\t\tdown_write(&bus_type_sem);\n\t\tlist_del_init(&type->list);\n\t\tup_write(&bus_type_sem);\n\t\tpr_info(\"bus type %s unregistered\\n\", type->name);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(unregister_acpi_bus_type);\n\nstatic struct acpi_bus_type *acpi_get_bus_type(struct device *dev)\n{\n\tstruct acpi_bus_type *tmp, *ret = NULL;\n\n\tdown_read(&bus_type_sem);\n\tlist_for_each_entry(tmp, &bus_type_list, list) {\n\t\tif (tmp->match(dev)) {\n\t\t\tret = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&bus_type_sem);\n\treturn ret;\n}\n\n#define FIND_CHILD_MIN_SCORE\t1\n#define FIND_CHILD_MID_SCORE\t2\n#define FIND_CHILD_MAX_SCORE\t3\n\nstatic int match_any(struct acpi_device *adev, void *not_used)\n{\n\treturn 1;\n}\n\nstatic bool acpi_dev_has_children(struct acpi_device *adev)\n{\n\treturn acpi_dev_for_each_child(adev, match_any, NULL) > 0;\n}\n\nstatic int find_child_checks(struct acpi_device *adev, bool check_children)\n{\n\tunsigned long long sta;\n\tacpi_status status;\n\n\tif (check_children && !acpi_dev_has_children(adev))\n\t\treturn -ENODEV;\n\n\tstatus = acpi_evaluate_integer(adev->handle, \"_STA\", NULL, &sta);\n\tif (status == AE_NOT_FOUND) {\n\t\t \n\t\tif (adev->pnp.type.backlight)\n\t\t\treturn FIND_CHILD_MID_SCORE;\n\n\t\treturn FIND_CHILD_MIN_SCORE;\n\t}\n\n\tif (ACPI_FAILURE(status) || !(sta & ACPI_STA_DEVICE_ENABLED))\n\t\treturn -ENODEV;\n\n\t \n\tif (adev->pnp.type.platform_id)\n\t\treturn FIND_CHILD_MIN_SCORE;\n\n\treturn FIND_CHILD_MAX_SCORE;\n}\n\nstruct find_child_walk_data {\n\tstruct acpi_device *adev;\n\tu64 address;\n\tint score;\n\tbool check_sta;\n\tbool check_children;\n};\n\nstatic int check_one_child(struct acpi_device *adev, void *data)\n{\n\tstruct find_child_walk_data *wd = data;\n\tint score;\n\n\tif (!adev->pnp.type.bus_address || acpi_device_adr(adev) != wd->address)\n\t\treturn 0;\n\n\tif (!wd->adev) {\n\t\t \n\t\twd->adev = adev;\n\t\treturn !(wd->check_sta || wd->check_children);\n\t}\n\n\t \n\tif (!wd->score) {\n\t\tscore = find_child_checks(wd->adev, wd->check_children);\n\t\tif (score == FIND_CHILD_MAX_SCORE)\n\t\t\treturn 1;\n\n\t\twd->score = score;\n\t}\n\t \n\tscore = find_child_checks(adev, wd->check_children);\n\tif (score > wd->score) {\n\t\twd->adev = adev;\n\t\tif (score == FIND_CHILD_MAX_SCORE)\n\t\t\treturn 1;\n\n\t\twd->score = score;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic struct acpi_device *acpi_find_child(struct acpi_device *parent,\n\t\t\t\t\t   u64 address, bool check_children,\n\t\t\t\t\t   bool check_sta)\n{\n\tstruct find_child_walk_data wd = {\n\t\t.address = address,\n\t\t.check_children = check_children,\n\t\t.check_sta = check_sta,\n\t\t.adev = NULL,\n\t\t.score = 0,\n\t};\n\n\tif (parent)\n\t\tacpi_dev_for_each_child(parent, check_one_child, &wd);\n\n\treturn wd.adev;\n}\n\nstruct acpi_device *acpi_find_child_device(struct acpi_device *parent,\n\t\t\t\t\t   u64 address, bool check_children)\n{\n\treturn acpi_find_child(parent, address, check_children, true);\n}\nEXPORT_SYMBOL_GPL(acpi_find_child_device);\n\nstruct acpi_device *acpi_find_child_by_adr(struct acpi_device *adev,\n\t\t\t\t\t   acpi_bus_address adr)\n{\n\treturn acpi_find_child(adev, adr, false, false);\n}\nEXPORT_SYMBOL_GPL(acpi_find_child_by_adr);\n\nstatic void acpi_physnode_link_name(char *buf, unsigned int node_id)\n{\n\tif (node_id > 0)\n\t\tsnprintf(buf, PHYSICAL_NODE_NAME_SIZE,\n\t\t\t PHYSICAL_NODE_STRING \"%u\", node_id);\n\telse\n\t\tstrcpy(buf, PHYSICAL_NODE_STRING);\n}\n\nint acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)\n{\n\tstruct acpi_device_physical_node *physical_node, *pn;\n\tchar physical_node_name[PHYSICAL_NODE_NAME_SIZE];\n\tstruct list_head *physnode_list;\n\tunsigned int node_id;\n\tint retval = -EINVAL;\n\n\tif (has_acpi_companion(dev)) {\n\t\tif (acpi_dev) {\n\t\t\tdev_warn(dev, \"ACPI companion already set\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tacpi_dev = ACPI_COMPANION(dev);\n\t\t}\n\t}\n\tif (!acpi_dev)\n\t\treturn -EINVAL;\n\n\tacpi_dev_get(acpi_dev);\n\tget_device(dev);\n\tphysical_node = kzalloc(sizeof(*physical_node), GFP_KERNEL);\n\tif (!physical_node) {\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&acpi_dev->physical_node_lock);\n\n\t \n\tphysnode_list = &acpi_dev->physical_node_list;\n\tnode_id = 0;\n\tlist_for_each_entry(pn, &acpi_dev->physical_node_list, node) {\n\t\t \n\t\tif (pn->dev == dev) {\n\t\t\tmutex_unlock(&acpi_dev->physical_node_lock);\n\n\t\t\tdev_warn(dev, \"Already associated with ACPI node\\n\");\n\t\t\tkfree(physical_node);\n\t\t\tif (ACPI_COMPANION(dev) != acpi_dev)\n\t\t\t\tgoto err;\n\n\t\t\tput_device(dev);\n\t\t\tacpi_dev_put(acpi_dev);\n\t\t\treturn 0;\n\t\t}\n\t\tif (pn->node_id == node_id) {\n\t\t\tphysnode_list = &pn->node;\n\t\t\tnode_id++;\n\t\t}\n\t}\n\n\tphysical_node->node_id = node_id;\n\tphysical_node->dev = dev;\n\tlist_add(&physical_node->node, physnode_list);\n\tacpi_dev->physical_node_count++;\n\n\tif (!has_acpi_companion(dev))\n\t\tACPI_COMPANION_SET(dev, acpi_dev);\n\n\tacpi_physnode_link_name(physical_node_name, node_id);\n\tretval = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,\n\t\t\t\t   physical_node_name);\n\tif (retval)\n\t\tdev_err(&acpi_dev->dev, \"Failed to create link %s (%d)\\n\",\n\t\t\tphysical_node_name, retval);\n\n\tretval = sysfs_create_link(&dev->kobj, &acpi_dev->dev.kobj,\n\t\t\t\t   \"firmware_node\");\n\tif (retval)\n\t\tdev_err(dev, \"Failed to create link firmware_node (%d)\\n\",\n\t\t\tretval);\n\n\tmutex_unlock(&acpi_dev->physical_node_lock);\n\n\tif (acpi_dev->wakeup.flags.valid)\n\t\tdevice_set_wakeup_capable(dev, true);\n\n\treturn 0;\n\n err:\n\tACPI_COMPANION_SET(dev, NULL);\n\tput_device(dev);\n\tacpi_dev_put(acpi_dev);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(acpi_bind_one);\n\nint acpi_unbind_one(struct device *dev)\n{\n\tstruct acpi_device *acpi_dev = ACPI_COMPANION(dev);\n\tstruct acpi_device_physical_node *entry;\n\n\tif (!acpi_dev)\n\t\treturn 0;\n\n\tmutex_lock(&acpi_dev->physical_node_lock);\n\n\tlist_for_each_entry(entry, &acpi_dev->physical_node_list, node)\n\t\tif (entry->dev == dev) {\n\t\t\tchar physnode_name[PHYSICAL_NODE_NAME_SIZE];\n\n\t\t\tlist_del(&entry->node);\n\t\t\tacpi_dev->physical_node_count--;\n\n\t\t\tacpi_physnode_link_name(physnode_name, entry->node_id);\n\t\t\tsysfs_remove_link(&acpi_dev->dev.kobj, physnode_name);\n\t\t\tsysfs_remove_link(&dev->kobj, \"firmware_node\");\n\t\t\tACPI_COMPANION_SET(dev, NULL);\n\t\t\t \n\t\t\tput_device(dev);\n\t\t\tacpi_dev_put(acpi_dev);\n\t\t\tkfree(entry);\n\t\t\tbreak;\n\t\t}\n\n\tmutex_unlock(&acpi_dev->physical_node_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_unbind_one);\n\nvoid acpi_device_notify(struct device *dev)\n{\n\tstruct acpi_device *adev;\n\tint ret;\n\n\tret = acpi_bind_one(dev, NULL);\n\tif (ret) {\n\t\tstruct acpi_bus_type *type = acpi_get_bus_type(dev);\n\n\t\tif (!type)\n\t\t\tgoto err;\n\n\t\tadev = type->find_companion(dev);\n\t\tif (!adev) {\n\t\t\tdev_dbg(dev, \"ACPI companion not found\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tret = acpi_bind_one(dev, adev);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (type->setup) {\n\t\t\ttype->setup(dev);\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tadev = ACPI_COMPANION(dev);\n\n\t\tif (dev_is_pci(dev)) {\n\t\t\tpci_acpi_setup(dev, adev);\n\t\t\tgoto done;\n\t\t} else if (dev_is_platform(dev)) {\n\t\t\tacpi_configure_pmsi_domain(dev);\n\t\t}\n\t}\n\n\tif (adev->handler && adev->handler->bind)\n\t\tadev->handler->bind(dev);\n\ndone:\n\tacpi_handle_debug(ACPI_HANDLE(dev), \"Bound to device %s\\n\",\n\t\t\t  dev_name(dev));\n\n\treturn;\n\nerr:\n\tdev_dbg(dev, \"No ACPI support\\n\");\n}\n\nvoid acpi_device_notify_remove(struct device *dev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\n\tif (!adev)\n\t\treturn;\n\n\tif (dev_is_pci(dev))\n\t\tpci_acpi_cleanup(dev, adev);\n\telse if (adev->handler && adev->handler->unbind)\n\t\tadev->handler->unbind(dev);\n\n\tacpi_unbind_one(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}