{
  "module_name": "dock.c",
  "hash_id": "4ac40da92289c9d2257954e7fefab6a99a1db0795482a6552b6fc5ae11729e9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/dock.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/notifier.h>\n#include <linux/platform_device.h>\n#include <linux/jiffies.h>\n#include <linux/stddef.h>\n#include <linux/acpi.h>\n\n#include \"internal.h\"\n\nstatic bool immediate_undock = 1;\nmodule_param(immediate_undock, bool, 0644);\nMODULE_PARM_DESC(immediate_undock, \"1 (default) will cause the driver to \"\n\t\"undock immediately when the undock button is pressed, 0 will cause\"\n\t\" the driver to wait for userspace to write the undock sysfs file \"\n\t\" before undocking\");\n\nstruct dock_station {\n\tacpi_handle handle;\n\tunsigned long last_dock_time;\n\tu32 flags;\n\tstruct list_head dependent_devices;\n\n\tstruct list_head sibling;\n\tstruct platform_device *dock_device;\n};\nstatic LIST_HEAD(dock_stations);\nstatic int dock_station_count;\n\nstruct dock_dependent_device {\n\tstruct list_head list;\n\tstruct acpi_device *adev;\n};\n\n#define DOCK_DOCKING\t0x00000001\n#define DOCK_UNDOCKING  0x00000002\n#define DOCK_IS_DOCK\t0x00000010\n#define DOCK_IS_ATA\t0x00000020\n#define DOCK_IS_BAT\t0x00000040\n#define DOCK_EVENT\t3\n#define UNDOCK_EVENT\t2\n\nenum dock_callback_type {\n\tDOCK_CALL_HANDLER,\n\tDOCK_CALL_FIXUP,\n\tDOCK_CALL_UEVENT,\n};\n\n \n \nstatic int add_dock_dependent_device(struct dock_station *ds,\n\t\t\t\t     struct acpi_device *adev)\n{\n\tstruct dock_dependent_device *dd;\n\n\tdd = kzalloc(sizeof(*dd), GFP_KERNEL);\n\tif (!dd)\n\t\treturn -ENOMEM;\n\n\tdd->adev = adev;\n\tINIT_LIST_HEAD(&dd->list);\n\tlist_add_tail(&dd->list, &ds->dependent_devices);\n\n\treturn 0;\n}\n\nstatic void dock_hotplug_event(struct dock_dependent_device *dd, u32 event,\n\t\t\t       enum dock_callback_type cb_type)\n{\n\tstruct acpi_device *adev = dd->adev;\n\n\tacpi_lock_hp_context();\n\n\tif (!adev->hp)\n\t\tgoto out;\n\n\tif (cb_type == DOCK_CALL_FIXUP) {\n\t\tvoid (*fixup)(struct acpi_device *);\n\n\t\tfixup = adev->hp->fixup;\n\t\tif (fixup) {\n\t\t\tacpi_unlock_hp_context();\n\t\t\tfixup(adev);\n\t\t\treturn;\n\t\t}\n\t} else if (cb_type == DOCK_CALL_UEVENT) {\n\t\tvoid (*uevent)(struct acpi_device *, u32);\n\n\t\tuevent = adev->hp->uevent;\n\t\tif (uevent) {\n\t\t\tacpi_unlock_hp_context();\n\t\t\tuevent(adev, event);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tint (*notify)(struct acpi_device *, u32);\n\n\t\tnotify = adev->hp->notify;\n\t\tif (notify) {\n\t\t\tacpi_unlock_hp_context();\n\t\t\tnotify(adev, event);\n\t\t\treturn;\n\t\t}\n\t}\n\n out:\n\tacpi_unlock_hp_context();\n}\n\nstatic struct dock_station *find_dock_station(acpi_handle handle)\n{\n\tstruct dock_station *ds;\n\n\tlist_for_each_entry(ds, &dock_stations, sibling)\n\t\tif (ds->handle == handle)\n\t\t\treturn ds;\n\n\treturn NULL;\n}\n\n \nstatic struct dock_dependent_device *\nfind_dock_dependent_device(struct dock_station *ds, struct acpi_device *adev)\n{\n\tstruct dock_dependent_device *dd;\n\n\tlist_for_each_entry(dd, &ds->dependent_devices, list)\n\t\tif (adev == dd->adev)\n\t\t\treturn dd;\n\n\treturn NULL;\n}\n\nvoid register_dock_dependent_device(struct acpi_device *adev,\n\t\t\t\t    acpi_handle dshandle)\n{\n\tstruct dock_station *ds = find_dock_station(dshandle);\n\n\tif (ds && !find_dock_dependent_device(ds, adev))\n\t\tadd_dock_dependent_device(ds, adev);\n}\n\n \n\n \nint is_dock_device(struct acpi_device *adev)\n{\n\tstruct dock_station *dock_station;\n\n\tif (!dock_station_count)\n\t\treturn 0;\n\n\tif (acpi_dock_match(adev->handle))\n\t\treturn 1;\n\n\tlist_for_each_entry(dock_station, &dock_stations, sibling)\n\t\tif (find_dock_dependent_device(dock_station, adev))\n\t\t\treturn 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(is_dock_device);\n\n \nstatic int dock_present(struct dock_station *ds)\n{\n\tunsigned long long sta;\n\tacpi_status status;\n\n\tif (ds) {\n\t\tstatus = acpi_evaluate_integer(ds->handle, \"_STA\", NULL, &sta);\n\t\tif (ACPI_SUCCESS(status) && sta)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void hot_remove_dock_devices(struct dock_station *ds)\n{\n\tstruct dock_dependent_device *dd;\n\n\t \n\tlist_for_each_entry_reverse(dd, &ds->dependent_devices, list)\n\t\tdock_hotplug_event(dd, ACPI_NOTIFY_EJECT_REQUEST,\n\t\t\t\t   DOCK_CALL_HANDLER);\n\n\tlist_for_each_entry_reverse(dd, &ds->dependent_devices, list)\n\t\tacpi_bus_trim(dd->adev);\n}\n\n \nstatic void hotplug_dock_devices(struct dock_station *ds, u32 event)\n{\n\tstruct dock_dependent_device *dd;\n\n\t \n\tlist_for_each_entry(dd, &ds->dependent_devices, list)\n\t\tdock_hotplug_event(dd, event, DOCK_CALL_FIXUP);\n\n\t \n\tlist_for_each_entry(dd, &ds->dependent_devices, list)\n\t\tdock_hotplug_event(dd, event, DOCK_CALL_HANDLER);\n\n\t \n\tlist_for_each_entry(dd, &ds->dependent_devices, list) {\n\t\tstruct acpi_device *adev = dd->adev;\n\n\t\tif (!acpi_device_enumerated(adev)) {\n\t\t\tint ret = acpi_bus_scan(adev->handle);\n\n\t\t\tif (ret)\n\t\t\t\tdev_dbg(&adev->dev, \"scan error %d\\n\", -ret);\n\t\t}\n\t}\n}\n\nstatic void dock_event(struct dock_station *ds, u32 event, int num)\n{\n\tstruct device *dev = &ds->dock_device->dev;\n\tchar event_string[13];\n\tchar *envp[] = { event_string, NULL };\n\tstruct dock_dependent_device *dd;\n\n\tif (num == UNDOCK_EVENT)\n\t\tsprintf(event_string, \"EVENT=undock\");\n\telse\n\t\tsprintf(event_string, \"EVENT=dock\");\n\n\t \n\tif (num == DOCK_EVENT)\n\t\tkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);\n\n\tlist_for_each_entry(dd, &ds->dependent_devices, list)\n\t\tdock_hotplug_event(dd, event, DOCK_CALL_UEVENT);\n\n\tif (num != DOCK_EVENT)\n\t\tkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);\n}\n\n \nstatic void handle_dock(struct dock_station *ds, int dock)\n{\n\tacpi_status status;\n\tstruct acpi_object_list arg_list;\n\tunion acpi_object arg;\n\tunsigned long long value;\n\n\tacpi_handle_info(ds->handle, \"%s\\n\", dock ? \"docking\" : \"undocking\");\n\n\t \n\targ_list.count = 1;\n\targ_list.pointer = &arg;\n\targ.type = ACPI_TYPE_INTEGER;\n\targ.integer.value = dock;\n\tstatus = acpi_evaluate_integer(ds->handle, \"_DCK\", &arg_list, &value);\n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND)\n\t\tacpi_handle_err(ds->handle, \"Failed to execute _DCK (0x%x)\\n\",\n\t\t\t\tstatus);\n}\n\nstatic inline void dock(struct dock_station *ds)\n{\n\thandle_dock(ds, 1);\n}\n\nstatic inline void undock(struct dock_station *ds)\n{\n\thandle_dock(ds, 0);\n}\n\nstatic inline void begin_dock(struct dock_station *ds)\n{\n\tds->flags |= DOCK_DOCKING;\n}\n\nstatic inline void complete_dock(struct dock_station *ds)\n{\n\tds->flags &= ~(DOCK_DOCKING);\n\tds->last_dock_time = jiffies;\n}\n\nstatic inline void begin_undock(struct dock_station *ds)\n{\n\tds->flags |= DOCK_UNDOCKING;\n}\n\nstatic inline void complete_undock(struct dock_station *ds)\n{\n\tds->flags &= ~(DOCK_UNDOCKING);\n}\n\n \nstatic int dock_in_progress(struct dock_station *ds)\n{\n\tif ((ds->flags & DOCK_DOCKING) ||\n\t    time_before(jiffies, (ds->last_dock_time + HZ)))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int handle_eject_request(struct dock_station *ds, u32 event)\n{\n\tif (dock_in_progress(ds))\n\t\treturn -EBUSY;\n\n\t \n\tdock_event(ds, event, UNDOCK_EVENT);\n\n\thot_remove_dock_devices(ds);\n\tundock(ds);\n\tacpi_evaluate_lck(ds->handle, 0);\n\tacpi_evaluate_ej0(ds->handle);\n\tif (dock_present(ds)) {\n\t\tacpi_handle_err(ds->handle, \"Unable to undock!\\n\");\n\t\treturn -EBUSY;\n\t}\n\tcomplete_undock(ds);\n\treturn 0;\n}\n\n \nint dock_notify(struct acpi_device *adev, u32 event)\n{\n\tacpi_handle handle = adev->handle;\n\tstruct dock_station *ds = find_dock_station(handle);\n\tint surprise_removal = 0;\n\n\tif (!ds)\n\t\treturn -ENODEV;\n\n\t \n\tif ((ds->flags & DOCK_IS_DOCK) && event == ACPI_NOTIFY_DEVICE_CHECK)\n\t\tevent = ACPI_NOTIFY_EJECT_REQUEST;\n\n\t \n\tswitch (event) {\n\tcase ACPI_NOTIFY_BUS_CHECK:\n\tcase ACPI_NOTIFY_DEVICE_CHECK:\n\t\tif (!dock_in_progress(ds) && !acpi_device_enumerated(adev)) {\n\t\t\tbegin_dock(ds);\n\t\t\tdock(ds);\n\t\t\tif (!dock_present(ds)) {\n\t\t\t\tacpi_handle_err(handle, \"Unable to dock!\\n\");\n\t\t\t\tcomplete_dock(ds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thotplug_dock_devices(ds, event);\n\t\t\tcomplete_dock(ds);\n\t\t\tdock_event(ds, event, DOCK_EVENT);\n\t\t\tacpi_evaluate_lck(ds->handle, 1);\n\t\t\tacpi_update_all_gpes();\n\t\t\tbreak;\n\t\t}\n\t\tif (dock_present(ds) || dock_in_progress(ds))\n\t\t\tbreak;\n\t\t \n\t\tsurprise_removal = 1;\n\t\tevent = ACPI_NOTIFY_EJECT_REQUEST;\n\t\t \n\t\tfallthrough;\n\tcase ACPI_NOTIFY_EJECT_REQUEST:\n\t\tbegin_undock(ds);\n\t\tif ((immediate_undock && !(ds->flags & DOCK_IS_ATA))\n\t\t   || surprise_removal)\n\t\t\thandle_eject_request(ds, event);\n\t\telse\n\t\t\tdock_event(ds, event, UNDOCK_EVENT);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic ssize_t docked_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct dock_station *dock_station = dev->platform_data;\n\tstruct acpi_device *adev = acpi_fetch_acpi_dev(dock_station->handle);\n\n\treturn sysfs_emit(buf, \"%u\\n\", acpi_device_enumerated(adev));\n}\nstatic DEVICE_ATTR_RO(docked);\n\n \nstatic ssize_t flags_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct dock_station *dock_station = dev->platform_data;\n\n\treturn sysfs_emit(buf, \"%d\\n\", dock_station->flags);\n\n}\nstatic DEVICE_ATTR_RO(flags);\n\n \nstatic ssize_t undock_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint ret;\n\tstruct dock_station *dock_station = dev->platform_data;\n\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tacpi_scan_lock_acquire();\n\tbegin_undock(dock_station);\n\tret = handle_eject_request(dock_station, ACPI_NOTIFY_EJECT_REQUEST);\n\tacpi_scan_lock_release();\n\treturn ret ? ret : count;\n}\nstatic DEVICE_ATTR_WO(undock);\n\n \nstatic ssize_t uid_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tunsigned long long lbuf;\n\tstruct dock_station *dock_station = dev->platform_data;\n\n\tacpi_status status = acpi_evaluate_integer(dock_station->handle,\n\t\t\t\t\t\"_UID\", NULL, &lbuf);\n\tif (ACPI_FAILURE(status))\n\t\treturn 0;\n\n\treturn sysfs_emit(buf, \"%llx\\n\", lbuf);\n}\nstatic DEVICE_ATTR_RO(uid);\n\nstatic ssize_t type_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct dock_station *dock_station = dev->platform_data;\n\tchar *type;\n\n\tif (dock_station->flags & DOCK_IS_DOCK)\n\t\ttype = \"dock_station\";\n\telse if (dock_station->flags & DOCK_IS_ATA)\n\t\ttype = \"ata_bay\";\n\telse if (dock_station->flags & DOCK_IS_BAT)\n\t\ttype = \"battery_bay\";\n\telse\n\t\ttype = \"unknown\";\n\n\treturn sysfs_emit(buf, \"%s\\n\", type);\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic struct attribute *dock_attributes[] = {\n\t&dev_attr_docked.attr,\n\t&dev_attr_flags.attr,\n\t&dev_attr_undock.attr,\n\t&dev_attr_uid.attr,\n\t&dev_attr_type.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dock_attribute_group = {\n\t.attrs = dock_attributes\n};\n\n \nvoid acpi_dock_add(struct acpi_device *adev)\n{\n\tstruct dock_station *dock_station, ds = { NULL, };\n\tstruct platform_device_info pdevinfo;\n\tacpi_handle handle = adev->handle;\n\tstruct platform_device *dd;\n\tint ret;\n\n\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\tpdevinfo.name = \"dock\";\n\tpdevinfo.id = dock_station_count;\n\tpdevinfo.fwnode = acpi_fwnode_handle(adev);\n\tpdevinfo.data = &ds;\n\tpdevinfo.size_data = sizeof(ds);\n\tdd = platform_device_register_full(&pdevinfo);\n\tif (IS_ERR(dd))\n\t\treturn;\n\n\tdock_station = dd->dev.platform_data;\n\n\tdock_station->handle = handle;\n\tdock_station->dock_device = dd;\n\tdock_station->last_dock_time = jiffies - HZ;\n\n\tINIT_LIST_HEAD(&dock_station->sibling);\n\tINIT_LIST_HEAD(&dock_station->dependent_devices);\n\n\t \n\tdev_set_uevent_suppress(&dd->dev, 0);\n\n\tif (acpi_dock_match(handle))\n\t\tdock_station->flags |= DOCK_IS_DOCK;\n\tif (acpi_ata_match(handle))\n\t\tdock_station->flags |= DOCK_IS_ATA;\n\tif (acpi_device_is_battery(adev))\n\t\tdock_station->flags |= DOCK_IS_BAT;\n\n\tret = sysfs_create_group(&dd->dev.kobj, &dock_attribute_group);\n\tif (ret)\n\t\tgoto err_unregister;\n\n\t \n\tret = add_dock_dependent_device(dock_station, adev);\n\tif (ret)\n\t\tgoto err_rmgroup;\n\n\tdock_station_count++;\n\tlist_add(&dock_station->sibling, &dock_stations);\n\tadev->flags.is_dock_station = true;\n\tdev_info(&adev->dev, \"ACPI dock station (docks/bays count: %d)\\n\",\n\t\t dock_station_count);\n\treturn;\n\nerr_rmgroup:\n\tsysfs_remove_group(&dd->dev.kobj, &dock_attribute_group);\n\nerr_unregister:\n\tplatform_device_unregister(dd);\n\tacpi_handle_err(handle, \"%s encountered error %d\\n\", __func__, ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}