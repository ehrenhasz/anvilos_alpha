{
  "module_name": "button.c",
  "hash_id": "c7cdea93a41c14797e153d6e34b5ee44d3b29246d1edeb49d1acd7629c0f9492",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/button.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: button: \" fmt\n\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <acpi/button.h>\n\n#define ACPI_BUTTON_CLASS\t\t\"button\"\n#define ACPI_BUTTON_FILE_STATE\t\t\"state\"\n#define ACPI_BUTTON_TYPE_UNKNOWN\t0x00\n#define ACPI_BUTTON_NOTIFY_STATUS\t0x80\n\n#define ACPI_BUTTON_SUBCLASS_POWER\t\"power\"\n#define ACPI_BUTTON_DEVICE_NAME_POWER\t\"Power Button\"\n#define ACPI_BUTTON_TYPE_POWER\t\t0x01\n\n#define ACPI_BUTTON_SUBCLASS_SLEEP\t\"sleep\"\n#define ACPI_BUTTON_DEVICE_NAME_SLEEP\t\"Sleep Button\"\n#define ACPI_BUTTON_TYPE_SLEEP\t\t0x03\n\n#define ACPI_BUTTON_SUBCLASS_LID\t\"lid\"\n#define ACPI_BUTTON_DEVICE_NAME_LID\t\"Lid Switch\"\n#define ACPI_BUTTON_TYPE_LID\t\t0x05\n\nenum {\n\tACPI_BUTTON_LID_INIT_IGNORE,\n\tACPI_BUTTON_LID_INIT_OPEN,\n\tACPI_BUTTON_LID_INIT_METHOD,\n\tACPI_BUTTON_LID_INIT_DISABLED,\n};\n\nstatic const char * const lid_init_state_str[] = {\n\t[ACPI_BUTTON_LID_INIT_IGNORE]\t\t= \"ignore\",\n\t[ACPI_BUTTON_LID_INIT_OPEN]\t\t= \"open\",\n\t[ACPI_BUTTON_LID_INIT_METHOD]\t\t= \"method\",\n\t[ACPI_BUTTON_LID_INIT_DISABLED]\t\t= \"disabled\",\n};\n\nMODULE_AUTHOR(\"Paul Diefenbaugh\");\nMODULE_DESCRIPTION(\"ACPI Button Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct acpi_device_id button_device_ids[] = {\n\t{ACPI_BUTTON_HID_LID,    0},\n\t{ACPI_BUTTON_HID_SLEEP,  0},\n\t{ACPI_BUTTON_HID_SLEEPF, 0},\n\t{ACPI_BUTTON_HID_POWER,  0},\n\t{ACPI_BUTTON_HID_POWERF, 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, button_device_ids);\n\n \nstatic const struct dmi_system_id dmi_lid_quirks[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Insyde\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"T701\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"BYT70A.YNCHENG.WIN.007\"),\n\t\t},\n\t\t.driver_data = (void *)(long)ACPI_BUTTON_LID_INIT_DISABLED,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Insyde\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CherryTrail\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"M882\"),\n\t\t},\n\t\t.driver_data = (void *)(long)ACPI_BUTTON_LID_INIT_DISABLED,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"82BG\"),\n\t\t},\n\t\t.driver_data = (void *)(long)ACPI_BUTTON_LID_INIT_OPEN,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MEDION\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"E2215T\"),\n\t\t},\n\t\t.driver_data = (void *)(long)ACPI_BUTTON_LID_INIT_OPEN,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MEDION\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"E2228T\"),\n\t\t},\n\t\t.driver_data = (void *)(long)ACPI_BUTTON_LID_INIT_OPEN,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Razer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Razer Blade Stealth 13 Late 2019\"),\n\t\t},\n\t\t.driver_data = (void *)(long)ACPI_BUTTON_LID_INIT_OPEN,\n\t},\n\t{}\n};\n\nstatic int acpi_button_add(struct acpi_device *device);\nstatic void acpi_button_remove(struct acpi_device *device);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acpi_button_suspend(struct device *dev);\nstatic int acpi_button_resume(struct device *dev);\n#else\n#define acpi_button_suspend NULL\n#define acpi_button_resume NULL\n#endif\nstatic SIMPLE_DEV_PM_OPS(acpi_button_pm, acpi_button_suspend, acpi_button_resume);\n\nstatic struct acpi_driver acpi_button_driver = {\n\t.name = \"button\",\n\t.class = ACPI_BUTTON_CLASS,\n\t.ids = button_device_ids,\n\t.ops = {\n\t\t.add = acpi_button_add,\n\t\t.remove = acpi_button_remove,\n\t},\n\t.drv.pm = &acpi_button_pm,\n};\n\nstruct acpi_button {\n\tunsigned int type;\n\tstruct input_dev *input;\n\tchar phys[32];\t\t\t \n\tunsigned long pushed;\n\tint last_state;\n\tktime_t last_time;\n\tbool suspended;\n\tbool lid_state_initialized;\n};\n\nstatic struct acpi_device *lid_device;\nstatic long lid_init_state = -1;\n\nstatic unsigned long lid_report_interval __read_mostly = 500;\nmodule_param(lid_report_interval, ulong, 0644);\nMODULE_PARM_DESC(lid_report_interval, \"Interval (ms) between lid key events\");\n\n \nstatic struct proc_dir_entry *acpi_button_dir;\nstatic struct proc_dir_entry *acpi_lid_dir;\n\nstatic int acpi_lid_evaluate_state(struct acpi_device *device)\n{\n\tunsigned long long lid_state;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(device->handle, \"_LID\", NULL, &lid_state);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\treturn lid_state ? 1 : 0;\n}\n\nstatic int acpi_lid_notify_state(struct acpi_device *device, int state)\n{\n\tstruct acpi_button *button = acpi_driver_data(device);\n\tktime_t next_report;\n\tbool do_update;\n\n\t \n\tif (lid_init_state != ACPI_BUTTON_LID_INIT_IGNORE ||\n\t    button->last_state != !!state)\n\t\tdo_update = true;\n\telse\n\t\tdo_update = false;\n\n\tnext_report = ktime_add(button->last_time,\n\t\t\t\tms_to_ktime(lid_report_interval));\n\tif (button->last_state == !!state &&\n\t    ktime_after(ktime_get(), next_report)) {\n\t\t \n\t\tpr_warn_once(\"The lid device is not compliant to SW_LID.\\n\");\n\n\t\t \n\t\tif (lid_init_state == ACPI_BUTTON_LID_INIT_IGNORE) {\n\t\t\tdo_update = true;\n\t\t\t \n\t\t\tif (!state) {\n\t\t\t\tinput_report_switch(button->input,\n\t\t\t\t\t\t    SW_LID, state);\n\t\t\t\tinput_sync(button->input);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (do_update) {\n\t\tacpi_handle_debug(device->handle, \"ACPI LID %s\\n\",\n\t\t\t\t  state ? \"open\" : \"closed\");\n\t\tinput_report_switch(button->input, SW_LID, !state);\n\t\tinput_sync(button->input);\n\t\tbutton->last_state = !!state;\n\t\tbutton->last_time = ktime_get();\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused acpi_button_state_seq_show(struct seq_file *seq,\n\t\t\t\t\t\t     void *offset)\n{\n\tstruct acpi_device *device = seq->private;\n\tint state;\n\n\tstate = acpi_lid_evaluate_state(device);\n\tseq_printf(seq, \"state:      %s\\n\",\n\t\t   state < 0 ? \"unsupported\" : (state ? \"open\" : \"closed\"));\n\treturn 0;\n}\n\nstatic int acpi_button_add_fs(struct acpi_device *device)\n{\n\tstruct acpi_button *button = acpi_driver_data(device);\n\tstruct proc_dir_entry *entry = NULL;\n\tint ret = 0;\n\n\t \n\tif (button->type != ACPI_BUTTON_TYPE_LID)\n\t\treturn 0;\n\n\tif (acpi_button_dir || acpi_lid_dir) {\n\t\tpr_info(\"More than one Lid device found!\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tacpi_button_dir = proc_mkdir(ACPI_BUTTON_CLASS, acpi_root_dir);\n\tif (!acpi_button_dir)\n\t\treturn -ENODEV;\n\n\t \n\tacpi_lid_dir = proc_mkdir(ACPI_BUTTON_SUBCLASS_LID, acpi_button_dir);\n\tif (!acpi_lid_dir) {\n\t\tret = -ENODEV;\n\t\tgoto remove_button_dir;\n\t}\n\n\t \n\tacpi_device_dir(device) = proc_mkdir(acpi_device_bid(device), acpi_lid_dir);\n\tif (!acpi_device_dir(device)) {\n\t\tret = -ENODEV;\n\t\tgoto remove_lid_dir;\n\t}\n\n\t \n\tentry = proc_create_single_data(ACPI_BUTTON_FILE_STATE, S_IRUGO,\n\t\t\tacpi_device_dir(device), acpi_button_state_seq_show,\n\t\t\tdevice);\n\tif (!entry) {\n\t\tret = -ENODEV;\n\t\tgoto remove_dev_dir;\n\t}\n\ndone:\n\treturn ret;\n\nremove_dev_dir:\n\tremove_proc_entry(acpi_device_bid(device),\n\t\t\t  acpi_lid_dir);\n\tacpi_device_dir(device) = NULL;\nremove_lid_dir:\n\tremove_proc_entry(ACPI_BUTTON_SUBCLASS_LID, acpi_button_dir);\n\tacpi_lid_dir = NULL;\nremove_button_dir:\n\tremove_proc_entry(ACPI_BUTTON_CLASS, acpi_root_dir);\n\tacpi_button_dir = NULL;\n\tgoto done;\n}\n\nstatic int acpi_button_remove_fs(struct acpi_device *device)\n{\n\tstruct acpi_button *button = acpi_driver_data(device);\n\n\tif (button->type != ACPI_BUTTON_TYPE_LID)\n\t\treturn 0;\n\n\tremove_proc_entry(ACPI_BUTTON_FILE_STATE,\n\t\t\t  acpi_device_dir(device));\n\tremove_proc_entry(acpi_device_bid(device),\n\t\t\t  acpi_lid_dir);\n\tacpi_device_dir(device) = NULL;\n\tremove_proc_entry(ACPI_BUTTON_SUBCLASS_LID, acpi_button_dir);\n\tacpi_lid_dir = NULL;\n\tremove_proc_entry(ACPI_BUTTON_CLASS, acpi_root_dir);\n\tacpi_button_dir = NULL;\n\n\treturn 0;\n}\n\n \nint acpi_lid_open(void)\n{\n\tif (!lid_device)\n\t\treturn -ENODEV;\n\n\treturn acpi_lid_evaluate_state(lid_device);\n}\nEXPORT_SYMBOL(acpi_lid_open);\n\nstatic int acpi_lid_update_state(struct acpi_device *device,\n\t\t\t\t bool signal_wakeup)\n{\n\tint state;\n\n\tstate = acpi_lid_evaluate_state(device);\n\tif (state < 0)\n\t\treturn state;\n\n\tif (state && signal_wakeup)\n\t\tacpi_pm_wakeup_event(&device->dev);\n\n\treturn acpi_lid_notify_state(device, state);\n}\n\nstatic void acpi_lid_initialize_state(struct acpi_device *device)\n{\n\tstruct acpi_button *button = acpi_driver_data(device);\n\n\tswitch (lid_init_state) {\n\tcase ACPI_BUTTON_LID_INIT_OPEN:\n\t\t(void)acpi_lid_notify_state(device, 1);\n\t\tbreak;\n\tcase ACPI_BUTTON_LID_INIT_METHOD:\n\t\t(void)acpi_lid_update_state(device, false);\n\t\tbreak;\n\tcase ACPI_BUTTON_LID_INIT_IGNORE:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tbutton->lid_state_initialized = true;\n}\n\nstatic void acpi_lid_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct acpi_device *device = data;\n\tstruct acpi_button *button;\n\n\tif (event != ACPI_BUTTON_NOTIFY_STATUS) {\n\t\tacpi_handle_debug(device->handle, \"Unsupported event [0x%x]\\n\",\n\t\t\t\t  event);\n\t\treturn;\n\t}\n\n\tbutton = acpi_driver_data(device);\n\tif (!button->lid_state_initialized)\n\t\treturn;\n\n\tacpi_lid_update_state(device, true);\n}\n\nstatic void acpi_button_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct acpi_device *device = data;\n\tstruct acpi_button *button;\n\tstruct input_dev *input;\n\tint keycode;\n\n\tif (event != ACPI_BUTTON_NOTIFY_STATUS) {\n\t\tacpi_handle_debug(device->handle, \"Unsupported event [0x%x]\\n\",\n\t\t\t\t  event);\n\t\treturn;\n\t}\n\n\tacpi_pm_wakeup_event(&device->dev);\n\n\tbutton = acpi_driver_data(device);\n\tif (button->suspended)\n\t\treturn;\n\n\tinput = button->input;\n\tkeycode = test_bit(KEY_SLEEP, input->keybit) ? KEY_SLEEP : KEY_POWER;\n\n\tinput_report_key(input, keycode, 1);\n\tinput_sync(input);\n\tinput_report_key(input, keycode, 0);\n\tinput_sync(input);\n\n\tacpi_bus_generate_netlink_event(device->pnp.device_class,\n\t\t\t\t\tdev_name(&device->dev),\n\t\t\t\t\tevent, ++button->pushed);\n}\n\nstatic void acpi_button_notify_run(void *data)\n{\n\tacpi_button_notify(NULL, ACPI_BUTTON_NOTIFY_STATUS, data);\n}\n\nstatic u32 acpi_button_event(void *data)\n{\n\tacpi_os_execute(OSL_NOTIFY_HANDLER, acpi_button_notify_run, data);\n\treturn ACPI_INTERRUPT_HANDLED;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acpi_button_suspend(struct device *dev)\n{\n\tstruct acpi_device *device = to_acpi_device(dev);\n\tstruct acpi_button *button = acpi_driver_data(device);\n\n\tbutton->suspended = true;\n\treturn 0;\n}\n\nstatic int acpi_button_resume(struct device *dev)\n{\n\tstruct acpi_device *device = to_acpi_device(dev);\n\tstruct acpi_button *button = acpi_driver_data(device);\n\n\tbutton->suspended = false;\n\tif (button->type == ACPI_BUTTON_TYPE_LID) {\n\t\tbutton->last_state = !!acpi_lid_evaluate_state(device);\n\t\tbutton->last_time = ktime_get();\n\t\tacpi_lid_initialize_state(device);\n\t}\n\treturn 0;\n}\n#endif\n\nstatic int acpi_lid_input_open(struct input_dev *input)\n{\n\tstruct acpi_device *device = input_get_drvdata(input);\n\tstruct acpi_button *button = acpi_driver_data(device);\n\n\tbutton->last_state = !!acpi_lid_evaluate_state(device);\n\tbutton->last_time = ktime_get();\n\tacpi_lid_initialize_state(device);\n\n\treturn 0;\n}\n\nstatic int acpi_button_add(struct acpi_device *device)\n{\n\tacpi_notify_handler handler;\n\tstruct acpi_button *button;\n\tstruct input_dev *input;\n\tconst char *hid = acpi_device_hid(device);\n\tacpi_status status;\n\tchar *name, *class;\n\tint error = 0;\n\n\tif (!strcmp(hid, ACPI_BUTTON_HID_LID) &&\n\t     lid_init_state == ACPI_BUTTON_LID_INIT_DISABLED)\n\t\treturn -ENODEV;\n\n\tbutton = kzalloc(sizeof(struct acpi_button), GFP_KERNEL);\n\tif (!button)\n\t\treturn -ENOMEM;\n\n\tdevice->driver_data = button;\n\n\tbutton->input = input = input_allocate_device();\n\tif (!input) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_button;\n\t}\n\n\tname = acpi_device_name(device);\n\tclass = acpi_device_class(device);\n\n\tif (!strcmp(hid, ACPI_BUTTON_HID_POWER) ||\n\t    !strcmp(hid, ACPI_BUTTON_HID_POWERF)) {\n\t\tbutton->type = ACPI_BUTTON_TYPE_POWER;\n\t\thandler = acpi_button_notify;\n\t\tstrcpy(name, ACPI_BUTTON_DEVICE_NAME_POWER);\n\t\tsprintf(class, \"%s/%s\",\n\t\t\tACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_POWER);\n\t} else if (!strcmp(hid, ACPI_BUTTON_HID_SLEEP) ||\n\t\t   !strcmp(hid, ACPI_BUTTON_HID_SLEEPF)) {\n\t\tbutton->type = ACPI_BUTTON_TYPE_SLEEP;\n\t\thandler = acpi_button_notify;\n\t\tstrcpy(name, ACPI_BUTTON_DEVICE_NAME_SLEEP);\n\t\tsprintf(class, \"%s/%s\",\n\t\t\tACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_SLEEP);\n\t} else if (!strcmp(hid, ACPI_BUTTON_HID_LID)) {\n\t\tbutton->type = ACPI_BUTTON_TYPE_LID;\n\t\thandler = acpi_lid_notify;\n\t\tstrcpy(name, ACPI_BUTTON_DEVICE_NAME_LID);\n\t\tsprintf(class, \"%s/%s\",\n\t\t\tACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_LID);\n\t\tinput->open = acpi_lid_input_open;\n\t} else {\n\t\tpr_info(\"Unsupported hid [%s]\\n\", hid);\n\t\terror = -ENODEV;\n\t}\n\n\tif (!error)\n\t\terror = acpi_button_add_fs(device);\n\n\tif (error) {\n\t\tinput_free_device(input);\n\t\tgoto err_free_button;\n\t}\n\n\tsnprintf(button->phys, sizeof(button->phys), \"%s/button/input0\", hid);\n\n\tinput->name = name;\n\tinput->phys = button->phys;\n\tinput->id.bustype = BUS_HOST;\n\tinput->id.product = button->type;\n\tinput->dev.parent = &device->dev;\n\n\tswitch (button->type) {\n\tcase ACPI_BUTTON_TYPE_POWER:\n\t\tinput_set_capability(input, EV_KEY, KEY_POWER);\n\t\tbreak;\n\n\tcase ACPI_BUTTON_TYPE_SLEEP:\n\t\tinput_set_capability(input, EV_KEY, KEY_SLEEP);\n\t\tbreak;\n\n\tcase ACPI_BUTTON_TYPE_LID:\n\t\tinput_set_capability(input, EV_SW, SW_LID);\n\t\tbreak;\n\t}\n\n\tinput_set_drvdata(input, device);\n\terror = input_register_device(input);\n\tif (error)\n\t\tgoto err_remove_fs;\n\n\tswitch (device->device_type) {\n\tcase ACPI_BUS_TYPE_POWER_BUTTON:\n\t\tstatus = acpi_install_fixed_event_handler(ACPI_EVENT_POWER_BUTTON,\n\t\t\t\t\t\t\t  acpi_button_event,\n\t\t\t\t\t\t\t  device);\n\t\tbreak;\n\tcase ACPI_BUS_TYPE_SLEEP_BUTTON:\n\t\tstatus = acpi_install_fixed_event_handler(ACPI_EVENT_SLEEP_BUTTON,\n\t\t\t\t\t\t\t  acpi_button_event,\n\t\t\t\t\t\t\t  device);\n\t\tbreak;\n\tdefault:\n\t\tstatus = acpi_install_notify_handler(device->handle,\n\t\t\t\t\t\t     ACPI_DEVICE_NOTIFY, handler,\n\t\t\t\t\t\t     device);\n\t\tbreak;\n\t}\n\tif (ACPI_FAILURE(status)) {\n\t\terror = -ENODEV;\n\t\tgoto err_input_unregister;\n\t}\n\n\tif (button->type == ACPI_BUTTON_TYPE_LID) {\n\t\t \n\t\tlid_device = device;\n\t}\n\n\tdevice_init_wakeup(&device->dev, true);\n\tpr_info(\"%s [%s]\\n\", name, acpi_device_bid(device));\n\treturn 0;\n\nerr_input_unregister:\n\tinput_unregister_device(input);\nerr_remove_fs:\n\tacpi_button_remove_fs(device);\nerr_free_button:\n\tkfree(button);\n\treturn error;\n}\n\nstatic void acpi_button_remove(struct acpi_device *device)\n{\n\tstruct acpi_button *button = acpi_driver_data(device);\n\n\tswitch (device->device_type) {\n\tcase ACPI_BUS_TYPE_POWER_BUTTON:\n\t\tacpi_remove_fixed_event_handler(ACPI_EVENT_POWER_BUTTON,\n\t\t\t\t\t\tacpi_button_event);\n\t\tbreak;\n\tcase ACPI_BUS_TYPE_SLEEP_BUTTON:\n\t\tacpi_remove_fixed_event_handler(ACPI_EVENT_SLEEP_BUTTON,\n\t\t\t\t\t\tacpi_button_event);\n\t\tbreak;\n\tdefault:\n\t\tacpi_remove_notify_handler(device->handle, ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t   button->type == ACPI_BUTTON_TYPE_LID ?\n\t\t\t\t\t\tacpi_lid_notify :\n\t\t\t\t\t\tacpi_button_notify);\n\t\tbreak;\n\t}\n\tacpi_os_wait_events_complete();\n\n\tacpi_button_remove_fs(device);\n\tinput_unregister_device(button->input);\n\tkfree(button);\n}\n\nstatic int param_set_lid_init_state(const char *val,\n\t\t\t\t    const struct kernel_param *kp)\n{\n\tint i;\n\n\ti = sysfs_match_string(lid_init_state_str, val);\n\tif (i < 0)\n\t\treturn i;\n\n\tlid_init_state = i;\n\tpr_info(\"Initial lid state set to '%s'\\n\", lid_init_state_str[i]);\n\treturn 0;\n}\n\nstatic int param_get_lid_init_state(char *buf, const struct kernel_param *kp)\n{\n\tint i, c = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(lid_init_state_str); i++)\n\t\tif (i == lid_init_state)\n\t\t\tc += sprintf(buf + c, \"[%s] \", lid_init_state_str[i]);\n\t\telse\n\t\t\tc += sprintf(buf + c, \"%s \", lid_init_state_str[i]);\n\n\tbuf[c - 1] = '\\n';  \n\n\treturn c;\n}\n\nmodule_param_call(lid_init_state,\n\t\t  param_set_lid_init_state, param_get_lid_init_state,\n\t\t  NULL, 0644);\nMODULE_PARM_DESC(lid_init_state, \"Behavior for reporting LID initial state\");\n\nstatic int acpi_button_register_driver(struct acpi_driver *driver)\n{\n\tconst struct dmi_system_id *dmi_id;\n\n\tif (lid_init_state == -1) {\n\t\tdmi_id = dmi_first_match(dmi_lid_quirks);\n\t\tif (dmi_id)\n\t\t\tlid_init_state = (long)dmi_id->driver_data;\n\t\telse\n\t\t\tlid_init_state = ACPI_BUTTON_LID_INIT_METHOD;\n\t}\n\n\t \n\tif (acpi_disabled)\n\t\treturn 0;\n\n\treturn acpi_bus_register_driver(driver);\n}\n\nstatic void acpi_button_unregister_driver(struct acpi_driver *driver)\n{\n\tif (!acpi_disabled)\n\t\tacpi_bus_unregister_driver(driver);\n}\n\nmodule_driver(acpi_button_driver, acpi_button_register_driver,\n\t       acpi_button_unregister_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}