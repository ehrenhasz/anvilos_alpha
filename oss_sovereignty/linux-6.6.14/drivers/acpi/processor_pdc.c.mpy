{
  "module_name": "processor_pdc.c",
  "hash_id": "bcfe15fe70ec31784eab52f20dd5c25cf5ddac503a935255f6e5491c9544739e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/processor_pdc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <acpi/processor.h>\n\n#include \"internal.h\"\n\nstatic void acpi_set_pdc_bits(u32 *buf)\n{\n\tbuf[0] = ACPI_PDC_REVISION_ID;\n\tbuf[1] = 1;\n\tbuf[2] = 0;\n\n\t \n\tarch_acpi_set_proc_cap_bits(&buf[2]);\n}\n\nstatic struct acpi_object_list *acpi_processor_alloc_pdc(void)\n{\n\tstruct acpi_object_list *obj_list;\n\tunion acpi_object *obj;\n\tu32 *buf;\n\n\t \n\tobj_list = kmalloc(sizeof(struct acpi_object_list), GFP_KERNEL);\n\tif (!obj_list)\n\t\tgoto out;\n\n\tobj = kmalloc(sizeof(union acpi_object), GFP_KERNEL);\n\tif (!obj) {\n\t\tkfree(obj_list);\n\t\tgoto out;\n\t}\n\n\tbuf = kmalloc(12, GFP_KERNEL);\n\tif (!buf) {\n\t\tkfree(obj);\n\t\tkfree(obj_list);\n\t\tgoto out;\n\t}\n\n\tacpi_set_pdc_bits(buf);\n\n\tobj->type = ACPI_TYPE_BUFFER;\n\tobj->buffer.length = 12;\n\tobj->buffer.pointer = (u8 *) buf;\n\tobj_list->count = 1;\n\tobj_list->pointer = obj;\n\n\treturn obj_list;\nout:\n\tpr_err(\"Memory allocation error\\n\");\n\treturn NULL;\n}\n\n \nstatic acpi_status\nacpi_processor_eval_pdc(acpi_handle handle, struct acpi_object_list *pdc_in)\n{\n\tacpi_status status = AE_OK;\n\n\tstatus = acpi_evaluate_object(handle, \"_PDC\", pdc_in, NULL);\n\n\tif (ACPI_FAILURE(status))\n\t\tacpi_handle_debug(handle,\n\t\t    \"Could not evaluate _PDC, using legacy perf control\\n\");\n\n\treturn status;\n}\n\nvoid acpi_processor_set_pdc(acpi_handle handle)\n{\n\tstruct acpi_object_list *obj_list;\n\n\tif (arch_has_acpi_pdc() == false)\n\t\treturn;\n\n\tobj_list = acpi_processor_alloc_pdc();\n\tif (!obj_list)\n\t\treturn;\n\n\tacpi_processor_eval_pdc(handle, obj_list);\n\n\tkfree(obj_list->pointer->buffer.pointer);\n\tkfree(obj_list->pointer);\n\tkfree(obj_list);\n}\n\nstatic acpi_status __init\nearly_init_pdc(acpi_handle handle, u32 lvl, void *context, void **rv)\n{\n\tif (processor_physically_present(handle) == false)\n\t\treturn AE_OK;\n\n\tacpi_processor_set_pdc(handle);\n\treturn AE_OK;\n}\n\nvoid __init acpi_early_processor_set_pdc(void)\n{\n\tacpi_proc_quirk_mwait_check();\n\n\tacpi_walk_namespace(ACPI_TYPE_PROCESSOR, ACPI_ROOT_OBJECT,\n\t\t\t    ACPI_UINT32_MAX,\n\t\t\t    early_init_pdc, NULL, NULL, NULL);\n\tacpi_get_devices(ACPI_PROCESSOR_DEVICE_HID, early_init_pdc, NULL, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}