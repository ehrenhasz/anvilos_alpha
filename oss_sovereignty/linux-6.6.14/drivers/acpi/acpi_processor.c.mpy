{
  "module_name": "acpi_processor.c",
  "hash_id": "81415bbe49d99aa3c7fb93e3cffc1d881638f9345af80a81f179278810dd09fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_processor.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/cpu.h>\n#include <linux/device.h>\n#include <linux/dmi.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n\n#include <acpi/processor.h>\n\n#include <asm/cpu.h>\n\n#include <xen/xen.h>\n\n#include \"internal.h\"\n\nDEFINE_PER_CPU(struct acpi_processor *, processors);\nEXPORT_PER_CPU_SYMBOL(processors);\n\n \nstruct acpi_processor_errata errata __read_mostly;\nEXPORT_SYMBOL_GPL(errata);\n\nstatic int acpi_processor_errata_piix4(struct pci_dev *dev)\n{\n\tu8 value1 = 0;\n\tu8 value2 = 0;\n\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\t \n\n\tswitch (dev->revision) {\n\tcase 0:\n\t\tdev_dbg(&dev->dev, \"Found PIIX4 A-step\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tdev_dbg(&dev->dev, \"Found PIIX4 B-step\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tdev_dbg(&dev->dev, \"Found PIIX4E\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tdev_dbg(&dev->dev, \"Found PIIX4M\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&dev->dev, \"Found unknown PIIX4\\n\");\n\t\tbreak;\n\t}\n\n\tswitch (dev->revision) {\n\n\tcase 0:\t\t \n\tcase 1:\t\t \n\t\t \n\t\terrata.piix4.throttle = 1;\n\t\tfallthrough;\n\n\tcase 2:\t\t \n\tcase 3:\t\t \n\t\t \n\n\t\t \n\t\tdev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\n\t\t\t\t     PCI_DEVICE_ID_INTEL_82371AB,\n\t\t\t\t     PCI_ANY_ID, PCI_ANY_ID, NULL);\n\t\tif (dev) {\n\t\t\terrata.piix4.bmisx = pci_resource_start(dev, 4);\n\t\t\tpci_dev_put(dev);\n\t\t}\n\n\t\t \n\t\tdev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\n\t\t\t\t     PCI_DEVICE_ID_INTEL_82371AB_0,\n\t\t\t\t     PCI_ANY_ID, PCI_ANY_ID, NULL);\n\t\tif (dev) {\n\t\t\tpci_read_config_byte(dev, 0x76, &value1);\n\t\t\tpci_read_config_byte(dev, 0x77, &value2);\n\t\t\tif ((value1 & 0x80) || (value2 & 0x80))\n\t\t\t\terrata.piix4.fdma = 1;\n\t\t\tpci_dev_put(dev);\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (errata.piix4.bmisx)\n\t\tdev_dbg(&dev->dev, \"Bus master activity detection (BM-IDE) erratum enabled\\n\");\n\tif (errata.piix4.fdma)\n\t\tdev_dbg(&dev->dev, \"Type-F DMA livelock erratum (C3 disabled)\\n\");\n\n\treturn 0;\n}\n\nstatic int acpi_processor_errata(void)\n{\n\tint result = 0;\n\tstruct pci_dev *dev = NULL;\n\n\t \n\tdev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\n\t\t\t     PCI_DEVICE_ID_INTEL_82371AB_3, PCI_ANY_ID,\n\t\t\t     PCI_ANY_ID, NULL);\n\tif (dev) {\n\t\tresult = acpi_processor_errata_piix4(dev);\n\t\tpci_dev_put(dev);\n\t}\n\n\treturn result;\n}\n\n \nstatic void cpufreq_add_device(const char *name)\n{\n\tstruct platform_device *pdev;\n\n\tpdev = platform_device_register_simple(name, PLATFORM_DEVID_NONE, NULL, 0);\n\tif (IS_ERR(pdev))\n\t\tpr_info(\"%s device creation failed: %ld\\n\", name, PTR_ERR(pdev));\n}\n\n#ifdef CONFIG_X86\n \nstatic void __init acpi_pcc_cpufreq_init(void)\n{\n\tacpi_status status;\n\tacpi_handle handle;\n\n\tstatus = acpi_get_handle(NULL, \"\\\\_SB\", &handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\n\tif (acpi_has_method(handle, \"PCCH\"))\n\t\tcpufreq_add_device(\"pcc-cpufreq\");\n}\n#else\nstatic void __init acpi_pcc_cpufreq_init(void) {}\n#endif  \n\n \n#ifdef CONFIG_ACPI_HOTPLUG_CPU\nint __weak acpi_map_cpu(acpi_handle handle,\n\t\tphys_cpuid_t physid, u32 acpi_id, int *pcpu)\n{\n\treturn -ENODEV;\n}\n\nint __weak acpi_unmap_cpu(int cpu)\n{\n\treturn -ENODEV;\n}\n\nint __weak arch_register_cpu(int cpu)\n{\n\treturn -ENODEV;\n}\n\nvoid __weak arch_unregister_cpu(int cpu) {}\n\nstatic int acpi_processor_hotadd_init(struct acpi_processor *pr)\n{\n\tunsigned long long sta;\n\tacpi_status status;\n\tint ret;\n\n\tif (invalid_phys_cpuid(pr->phys_id))\n\t\treturn -ENODEV;\n\n\tstatus = acpi_evaluate_integer(pr->handle, \"_STA\", NULL, &sta);\n\tif (ACPI_FAILURE(status) || !(sta & ACPI_STA_DEVICE_PRESENT))\n\t\treturn -ENODEV;\n\n\tcpu_maps_update_begin();\n\tcpus_write_lock();\n\n\tret = acpi_map_cpu(pr->handle, pr->phys_id, pr->acpi_id, &pr->id);\n\tif (ret)\n\t\tgoto out;\n\n\tret = arch_register_cpu(pr->id);\n\tif (ret) {\n\t\tacpi_unmap_cpu(pr->id);\n\t\tgoto out;\n\t}\n\n\t \n\tpr_info(\"CPU%d has been hot-added\\n\", pr->id);\n\tpr->flags.need_hotplug_init = 1;\n\nout:\n\tcpus_write_unlock();\n\tcpu_maps_update_done();\n\treturn ret;\n}\n#else\nstatic inline int acpi_processor_hotadd_init(struct acpi_processor *pr)\n{\n\treturn -ENODEV;\n}\n#endif  \n\nstatic int acpi_processor_get_info(struct acpi_device *device)\n{\n\tunion acpi_object object = { 0 };\n\tstruct acpi_buffer buffer = { sizeof(union acpi_object), &object };\n\tstruct acpi_processor *pr = acpi_driver_data(device);\n\tint device_declaration = 0;\n\tacpi_status status = AE_OK;\n\tstatic int cpu0_initialized;\n\tunsigned long long value;\n\n\tacpi_processor_errata();\n\n\t \n\tif (acpi_gbl_FADT.pm2_control_block && acpi_gbl_FADT.pm2_control_length) {\n\t\tpr->flags.bm_control = 1;\n\t\tdev_dbg(&device->dev, \"Bus mastering arbitration control present\\n\");\n\t} else\n\t\tdev_dbg(&device->dev, \"No bus mastering arbitration control\\n\");\n\n\tif (!strcmp(acpi_device_hid(device), ACPI_PROCESSOR_OBJECT_HID)) {\n\t\t \n\t\tstatus = acpi_evaluate_object(pr->handle, NULL, NULL, &buffer);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tdev_err(&device->dev,\n\t\t\t\t\"Failed to evaluate processor object (0x%x)\\n\",\n\t\t\t\tstatus);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tpr->acpi_id = object.processor.proc_id;\n\t} else {\n\t\t \n\t\tstatus = acpi_evaluate_integer(pr->handle, METHOD_NAME__UID,\n\t\t\t\t\t\tNULL, &value);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tdev_err(&device->dev,\n\t\t\t\t\"Failed to evaluate processor _UID (0x%x)\\n\",\n\t\t\t\tstatus);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tdevice_declaration = 1;\n\t\tpr->acpi_id = value;\n\t}\n\n\tif (acpi_duplicate_processor_id(pr->acpi_id)) {\n\t\tif (pr->acpi_id == 0xff)\n\t\t\tdev_info_once(&device->dev,\n\t\t\t\t\"Entry not well-defined, consider updating BIOS\\n\");\n\t\telse\n\t\t\tdev_err(&device->dev,\n\t\t\t\t\"Failed to get unique processor _UID (0x%x)\\n\",\n\t\t\t\tpr->acpi_id);\n\t\treturn -ENODEV;\n\t}\n\n\tpr->phys_id = acpi_get_phys_id(pr->handle, device_declaration,\n\t\t\t\t\tpr->acpi_id);\n\tif (invalid_phys_cpuid(pr->phys_id))\n\t\tdev_dbg(&device->dev, \"Failed to get CPU physical ID.\\n\");\n\n\tpr->id = acpi_map_cpuid(pr->phys_id, pr->acpi_id);\n\tif (!cpu0_initialized) {\n\t\tcpu0_initialized = 1;\n\t\t \n\t\tif (!acpi_has_cpu_in_madt() && invalid_logical_cpuid(pr->id) &&\n\t\t    (num_online_cpus() == 1))\n\t\t\tpr->id = 0;\n\t\t \n\t\tif (acpi_has_method(pr->handle, \"_PCT\"))\n\t\t\tcpufreq_add_device(\"acpi-cpufreq\");\n\t}\n\n\t \n\tif (invalid_logical_cpuid(pr->id) || !cpu_present(pr->id)) {\n\t\tint ret = acpi_processor_hotadd_init(pr);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tsprintf(acpi_device_bid(device), \"CPU%X\", pr->id);\n\tdev_dbg(&device->dev, \"Processor [%d:%d]\\n\", pr->id, pr->acpi_id);\n\n\tif (!object.processor.pblk_address)\n\t\tdev_dbg(&device->dev, \"No PBLK (NULL address)\\n\");\n\telse if (object.processor.pblk_length != 6)\n\t\tdev_err(&device->dev, \"Invalid PBLK length [%d]\\n\",\n\t\t\t    object.processor.pblk_length);\n\telse {\n\t\tpr->throttling.address = object.processor.pblk_address;\n\t\tpr->throttling.duty_offset = acpi_gbl_FADT.duty_offset;\n\t\tpr->throttling.duty_width = acpi_gbl_FADT.duty_width;\n\n\t\tpr->pblk = object.processor.pblk_address;\n\t}\n\n\t \n\tstatus = acpi_evaluate_integer(pr->handle, \"_SUN\", NULL, &value);\n\tif (ACPI_SUCCESS(status))\n\t\tarch_fix_phys_package_id(pr->id, value);\n\n\treturn 0;\n}\n\n \nstatic DEFINE_PER_CPU(void *, processor_device_array);\n\nstatic int acpi_processor_add(struct acpi_device *device,\n\t\t\t\t\tconst struct acpi_device_id *id)\n{\n\tstruct acpi_processor *pr;\n\tstruct device *dev;\n\tint result = 0;\n\n\tpr = kzalloc(sizeof(struct acpi_processor), GFP_KERNEL);\n\tif (!pr)\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(&pr->throttling.shared_cpu_map, GFP_KERNEL)) {\n\t\tresult = -ENOMEM;\n\t\tgoto err_free_pr;\n\t}\n\n\tpr->handle = device->handle;\n\tstrcpy(acpi_device_name(device), ACPI_PROCESSOR_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_PROCESSOR_CLASS);\n\tdevice->driver_data = pr;\n\n\tresult = acpi_processor_get_info(device);\n\tif (result)  \n\t\treturn 0;\n\n\tBUG_ON(pr->id >= nr_cpu_ids);\n\n\t \n\tif (per_cpu(processor_device_array, pr->id) != NULL &&\n\t    per_cpu(processor_device_array, pr->id) != device) {\n\t\tdev_warn(&device->dev,\n\t\t\t\"BIOS reported wrong ACPI id %d for the processor\\n\",\n\t\t\tpr->id);\n\t\t \n\t\tgoto err;\n\t}\n\t \n\tper_cpu(processor_device_array, pr->id) = device;\n\tper_cpu(processors, pr->id) = pr;\n\n\tdev = get_cpu_device(pr->id);\n\tif (!dev) {\n\t\tresult = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tresult = acpi_bind_one(dev, device);\n\tif (result)\n\t\tgoto err;\n\n\tpr->dev = dev;\n\n\t \n\tif (device_attach(dev) >= 0)\n\t\treturn 1;\n\n\tdev_err(dev, \"Processor driver could not be attached\\n\");\n\tacpi_unbind_one(dev);\n\n err:\n\tfree_cpumask_var(pr->throttling.shared_cpu_map);\n\tdevice->driver_data = NULL;\n\tper_cpu(processors, pr->id) = NULL;\n err_free_pr:\n\tkfree(pr);\n\treturn result;\n}\n\n#ifdef CONFIG_ACPI_HOTPLUG_CPU\n \nstatic void acpi_processor_remove(struct acpi_device *device)\n{\n\tstruct acpi_processor *pr;\n\n\tif (!device || !acpi_driver_data(device))\n\t\treturn;\n\n\tpr = acpi_driver_data(device);\n\tif (pr->id >= nr_cpu_ids)\n\t\tgoto out;\n\n\t \n\tdevice_release_driver(pr->dev);\n\tacpi_unbind_one(pr->dev);\n\n\t \n\tper_cpu(processor_device_array, pr->id) = NULL;\n\tper_cpu(processors, pr->id) = NULL;\n\n\tcpu_maps_update_begin();\n\tcpus_write_lock();\n\n\t \n\tarch_unregister_cpu(pr->id);\n\tacpi_unmap_cpu(pr->id);\n\n\tcpus_write_unlock();\n\tcpu_maps_update_done();\n\n\ttry_offline_node(cpu_to_node(pr->id));\n\n out:\n\tfree_cpumask_var(pr->throttling.shared_cpu_map);\n\tkfree(pr);\n}\n#endif  \n\n#ifdef CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC\nbool __init processor_physically_present(acpi_handle handle)\n{\n\tint cpuid, type;\n\tu32 acpi_id;\n\tacpi_status status;\n\tacpi_object_type acpi_type;\n\tunsigned long long tmp;\n\tunion acpi_object object = {};\n\tstruct acpi_buffer buffer = { sizeof(union acpi_object), &object };\n\n\tstatus = acpi_get_type(handle, &acpi_type);\n\tif (ACPI_FAILURE(status))\n\t\treturn false;\n\n\tswitch (acpi_type) {\n\tcase ACPI_TYPE_PROCESSOR:\n\t\tstatus = acpi_evaluate_object(handle, NULL, NULL, &buffer);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn false;\n\t\tacpi_id = object.processor.proc_id;\n\t\tbreak;\n\tcase ACPI_TYPE_DEVICE:\n\t\tstatus = acpi_evaluate_integer(handle, METHOD_NAME__UID,\n\t\t\t\t\t       NULL, &tmp);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn false;\n\t\tacpi_id = tmp;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (xen_initial_domain())\n\t\t \n\t\treturn xen_processor_present(acpi_id);\n\n\ttype = (acpi_type == ACPI_TYPE_DEVICE) ? 1 : 0;\n\tcpuid = acpi_get_cpuid(handle, type, acpi_id);\n\n\treturn !invalid_logical_cpuid(cpuid);\n}\n\n \nstatic u8 sb_uuid_str[] = \"4077A616-290C-47BE-9EBD-D87058713953\";\n\nstatic acpi_status __init acpi_processor_osc(acpi_handle handle, u32 lvl,\n\t\t\t\t\t     void *context, void **rv)\n{\n\tu32 capbuf[2] = {};\n\tstruct acpi_osc_context osc_context = {\n\t\t.uuid_str = sb_uuid_str,\n\t\t.rev = 1,\n\t\t.cap.length = 8,\n\t\t.cap.pointer = capbuf,\n\t};\n\tacpi_status status;\n\n\tif (!processor_physically_present(handle))\n\t\treturn AE_OK;\n\n\tarch_acpi_set_proc_cap_bits(&capbuf[OSC_SUPPORT_DWORD]);\n\n\tstatus = acpi_run_osc(handle, &osc_context);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tkfree(osc_context.ret.pointer);\n\n\treturn AE_OK;\n}\n\nstatic bool __init acpi_early_processor_osc(void)\n{\n\tacpi_status status;\n\n\tacpi_proc_quirk_mwait_check();\n\n\tstatus = acpi_walk_namespace(ACPI_TYPE_PROCESSOR, ACPI_ROOT_OBJECT,\n\t\t\t\t     ACPI_UINT32_MAX, acpi_processor_osc, NULL,\n\t\t\t\t     NULL, NULL);\n\tif (ACPI_FAILURE(status))\n\t\treturn false;\n\n\tstatus = acpi_get_devices(ACPI_PROCESSOR_DEVICE_HID, acpi_processor_osc,\n\t\t\t\t  NULL, NULL);\n\tif (ACPI_FAILURE(status))\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid __init acpi_early_processor_control_setup(void)\n{\n\tif (acpi_early_processor_osc()) {\n\t\tpr_info(\"_OSC evaluated successfully for all CPUs\\n\");\n\t} else {\n\t\tpr_info(\"_OSC evaluation for CPUs failed, trying _PDC\\n\");\n\t\tacpi_early_processor_set_pdc();\n\t}\n}\n#endif\n\n \nstatic const struct acpi_device_id processor_device_ids[] = {\n\n\t{ ACPI_PROCESSOR_OBJECT_HID, },\n\t{ ACPI_PROCESSOR_DEVICE_HID, },\n\n\t{ }\n};\n\nstatic struct acpi_scan_handler processor_handler = {\n\t.ids = processor_device_ids,\n\t.attach = acpi_processor_add,\n#ifdef CONFIG_ACPI_HOTPLUG_CPU\n\t.detach = acpi_processor_remove,\n#endif\n\t.hotplug = {\n\t\t.enabled = true,\n\t},\n};\n\nstatic int acpi_processor_container_attach(struct acpi_device *dev,\n\t\t\t\t\t   const struct acpi_device_id *id)\n{\n\treturn 1;\n}\n\nstatic const struct acpi_device_id processor_container_ids[] = {\n\t{ ACPI_PROCESSOR_CONTAINER_HID, },\n\t{ }\n};\n\nstatic struct acpi_scan_handler processor_container_handler = {\n\t.ids = processor_container_ids,\n\t.attach = acpi_processor_container_attach,\n};\n\n \nstatic int nr_unique_ids __initdata;\n\n \nstatic int nr_duplicate_ids;\n\n \nstatic int unique_processor_ids[] __initdata = {\n\t[0 ... NR_CPUS - 1] = -1,\n};\n\n \nstatic int duplicate_processor_ids[] = {\n\t[0 ... NR_CPUS - 1] = -1,\n};\n\nstatic void __init processor_validated_ids_update(int proc_id)\n{\n\tint i;\n\n\tif (nr_unique_ids == NR_CPUS||nr_duplicate_ids == NR_CPUS)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < nr_duplicate_ids; i++) {\n\t\tif (duplicate_processor_ids[i] == proc_id)\n\t\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < nr_unique_ids; i++) {\n\t\tif (unique_processor_ids[i] == proc_id) {\n\t\t\tduplicate_processor_ids[nr_duplicate_ids] = proc_id;\n\t\t\tnr_duplicate_ids++;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tunique_processor_ids[nr_unique_ids] = proc_id;\n\tnr_unique_ids++;\n}\n\nstatic acpi_status __init acpi_processor_ids_walk(acpi_handle handle,\n\t\t\t\t\t\t  u32 lvl,\n\t\t\t\t\t\t  void *context,\n\t\t\t\t\t\t  void **rv)\n{\n\tacpi_status status;\n\tacpi_object_type acpi_type;\n\tunsigned long long uid;\n\tunion acpi_object object = { 0 };\n\tstruct acpi_buffer buffer = { sizeof(union acpi_object), &object };\n\n\tstatus = acpi_get_type(handle, &acpi_type);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tswitch (acpi_type) {\n\tcase ACPI_TYPE_PROCESSOR:\n\t\tstatus = acpi_evaluate_object(handle, NULL, NULL, &buffer);\n\t\tif (ACPI_FAILURE(status))\n\t\t\tgoto err;\n\t\tuid = object.processor.proc_id;\n\t\tbreak;\n\n\tcase ACPI_TYPE_DEVICE:\n\t\tstatus = acpi_evaluate_integer(handle, \"_UID\", NULL, &uid);\n\t\tif (ACPI_FAILURE(status))\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\tprocessor_validated_ids_update(uid);\n\treturn AE_OK;\n\nerr:\n\t \n\tacpi_handle_info(handle, \"Invalid processor object\\n\");\n\treturn AE_OK;\n\n}\n\nstatic void __init acpi_processor_check_duplicates(void)\n{\n\t \n\tacpi_walk_namespace(ACPI_TYPE_PROCESSOR, ACPI_ROOT_OBJECT,\n\t\t\t\t\t\tACPI_UINT32_MAX,\n\t\t\t\t\t\tacpi_processor_ids_walk,\n\t\t\t\t\t\tNULL, NULL, NULL);\n\tacpi_get_devices(ACPI_PROCESSOR_DEVICE_HID, acpi_processor_ids_walk,\n\t\t\t\t\t\tNULL, NULL);\n}\n\nbool acpi_duplicate_processor_id(int proc_id)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < nr_duplicate_ids; i++) {\n\t\tif (duplicate_processor_ids[i] == proc_id)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid __init acpi_processor_init(void)\n{\n\tacpi_processor_check_duplicates();\n\tacpi_scan_add_handler_with_hotplug(&processor_handler, \"processor\");\n\tacpi_scan_add_handler(&processor_container_handler);\n\tacpi_pcc_cpufreq_init();\n}\n\n#ifdef CONFIG_ACPI_PROCESSOR_CSTATE\n \nbool acpi_processor_claim_cst_control(void)\n{\n\tstatic bool cst_control_claimed;\n\tacpi_status status;\n\n\tif (!acpi_gbl_FADT.cst_control || cst_control_claimed)\n\t\treturn true;\n\n\tstatus = acpi_os_write_port(acpi_gbl_FADT.smi_command,\n\t\t\t\t    acpi_gbl_FADT.cst_control, 8);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_warn(\"ACPI: Failed to claim processor _CST control\\n\");\n\t\treturn false;\n\t}\n\n\tcst_control_claimed = true;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(acpi_processor_claim_cst_control);\n\n \nint acpi_processor_evaluate_cst(acpi_handle handle, u32 cpu,\n\t\t\t\tstruct acpi_processor_power *info)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *cst;\n\tacpi_status status;\n\tu64 count;\n\tint last_index = 0;\n\tint i, ret = 0;\n\n\tstatus = acpi_evaluate_object(handle, \"_CST\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_debug(handle, \"No _CST\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcst = buffer.pointer;\n\n\t \n\tif (!cst || cst->type != ACPI_TYPE_PACKAGE || cst->package.count < 2) {\n\t\tacpi_handle_warn(handle, \"Invalid _CST output\\n\");\n\t\tret = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tcount = cst->package.elements[0].integer.value;\n\n\t \n\tif (count < 1 || count != cst->package.count - 1) {\n\t\tacpi_handle_warn(handle, \"Inconsistent _CST data\\n\");\n\t\tret = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tfor (i = 1; i <= count; i++) {\n\t\tunion acpi_object *element;\n\t\tunion acpi_object *obj;\n\t\tstruct acpi_power_register *reg;\n\t\tstruct acpi_processor_cx cx;\n\n\t\t \n\t\tif (last_index >= ACPI_PROCESSOR_MAX_POWER - 1) {\n\t\t\tacpi_handle_warn(handle,\n\t\t\t\t\t \"No room for more idle states (limit: %d)\\n\",\n\t\t\t\t\t ACPI_PROCESSOR_MAX_POWER - 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&cx, 0, sizeof(cx));\n\n\t\telement = &cst->package.elements[i];\n\t\tif (element->type != ACPI_TYPE_PACKAGE) {\n\t\t\tacpi_handle_info(handle, \"_CST C%d type(%x) is not package, skip...\\n\",\n\t\t\t\t\t i, element->type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (element->package.count != 4) {\n\t\t\tacpi_handle_info(handle, \"_CST C%d package count(%d) is not 4, skip...\\n\",\n\t\t\t\t\t i, element->package.count);\n\t\t\tcontinue;\n\t\t}\n\n\t\tobj = &element->package.elements[0];\n\n\t\tif (obj->type != ACPI_TYPE_BUFFER) {\n\t\t\tacpi_handle_info(handle, \"_CST C%d package element[0] type(%x) is not buffer, skip...\\n\",\n\t\t\t\t\t i, obj->type);\n\t\t\tcontinue;\n\t\t}\n\n\t\treg = (struct acpi_power_register *)obj->buffer.pointer;\n\n\t\tobj = &element->package.elements[1];\n\t\tif (obj->type != ACPI_TYPE_INTEGER) {\n\t\t\tacpi_handle_info(handle, \"_CST C[%d] package element[1] type(%x) is not integer, skip...\\n\",\n\t\t\t\t\t i, obj->type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcx.type = obj->integer.value;\n\t\t \n\t\tif (i == 1 && cx.type != ACPI_STATE_C1)\n\t\t\tlast_index = 1;\n\n\t\tcx.address = reg->address;\n\t\tcx.index = last_index + 1;\n\n\t\tif (reg->space_id == ACPI_ADR_SPACE_FIXED_HARDWARE) {\n\t\t\tif (!acpi_processor_ffh_cstate_probe(cpu, &cx, reg)) {\n\t\t\t\t \n\t\t\t\tif (cx.type == ACPI_STATE_C1 &&\n\t\t\t\t    boot_option_idle_override == IDLE_NOMWAIT) {\n\t\t\t\t\tcx.entry_method = ACPI_CSTATE_HALT;\n\t\t\t\t\tsnprintf(cx.desc, ACPI_CX_DESC_LEN, \"ACPI HLT\");\n\t\t\t\t} else {\n\t\t\t\t\tcx.entry_method = ACPI_CSTATE_FFH;\n\t\t\t\t}\n\t\t\t} else if (cx.type == ACPI_STATE_C1) {\n\t\t\t\t \n\t\t\t\tcx.entry_method = ACPI_CSTATE_HALT;\n\t\t\t\tsnprintf(cx.desc, ACPI_CX_DESC_LEN, \"ACPI HLT\");\n\t\t\t} else {\n\t\t\t\tacpi_handle_info(handle, \"_CST C%d declares FIXED_HARDWARE C-state but not supported in hardware, skip...\\n\",\n\t\t\t\t\t\t i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (reg->space_id == ACPI_ADR_SPACE_SYSTEM_IO) {\n\t\t\tcx.entry_method = ACPI_CSTATE_SYSTEMIO;\n\t\t\tsnprintf(cx.desc, ACPI_CX_DESC_LEN, \"ACPI IOPORT 0x%x\",\n\t\t\t\t cx.address);\n\t\t} else {\n\t\t\tacpi_handle_info(handle, \"_CST C%d space_id(%x) neither FIXED_HARDWARE nor SYSTEM_IO, skip...\\n\",\n\t\t\t\t\t i, reg->space_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cx.type == ACPI_STATE_C1)\n\t\t\tcx.valid = 1;\n\n\t\tobj = &element->package.elements[2];\n\t\tif (obj->type != ACPI_TYPE_INTEGER) {\n\t\t\tacpi_handle_info(handle, \"_CST C%d package element[2] type(%x) not integer, skip...\\n\",\n\t\t\t\t\t i, obj->type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcx.latency = obj->integer.value;\n\n\t\tobj = &element->package.elements[3];\n\t\tif (obj->type != ACPI_TYPE_INTEGER) {\n\t\t\tacpi_handle_info(handle, \"_CST C%d package element[3] type(%x) not integer, skip...\\n\",\n\t\t\t\t\t i, obj->type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemcpy(&info->states[++last_index], &cx, sizeof(cx));\n\t}\n\n\tacpi_handle_info(handle, \"Found %d idle states\\n\", last_index);\n\n\tinfo->count = last_index;\n\nend:\n\tkfree(buffer.pointer);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(acpi_processor_evaluate_cst);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}