{
  "module_name": "processor_perflib.c",
  "hash_id": "7c99cca78ff1a2181a6372787585e1b1847814ff263e39389992b674383ee63c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/processor_perflib.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <acpi/processor.h>\n#ifdef CONFIG_X86\n#include <asm/cpufeature.h>\n#endif\n\n#define ACPI_PROCESSOR_FILE_PERFORMANCE\t\"performance\"\n\nstatic DEFINE_MUTEX(performance_mutex);\n\n \n\n \nstatic int ignore_ppc = -1;\nmodule_param(ignore_ppc, int, 0644);\nMODULE_PARM_DESC(ignore_ppc, \"If the frequency of your machine gets wrongly\" \\\n\t\t \"limited by BIOS, this should help\");\n\nstatic bool acpi_processor_ppc_in_use;\n\nstatic int acpi_processor_get_platform_limit(struct acpi_processor *pr)\n{\n\tacpi_status status = 0;\n\tunsigned long long ppc = 0;\n\ts32 qos_value;\n\tint index;\n\tint ret;\n\n\tif (!pr)\n\t\treturn -EINVAL;\n\n\t \n\tstatus = acpi_evaluate_integer(pr->handle, \"_PPC\", NULL, &ppc);\n\tif (status != AE_NOT_FOUND) {\n\t\tacpi_processor_ppc_in_use = true;\n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_evaluation_failure_warn(pr->handle, \"_PPC\", status);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tindex = ppc;\n\n\tif (pr->performance_platform_limit == index ||\n\t    ppc >= pr->performance->state_count)\n\t\treturn 0;\n\n\tpr_debug(\"CPU %d: _PPC is %d - frequency %s limited\\n\", pr->id,\n\t\t index, index ? \"is\" : \"is not\");\n\n\tpr->performance_platform_limit = index;\n\n\tif (unlikely(!freq_qos_request_active(&pr->perflib_req)))\n\t\treturn 0;\n\n\t \n\tif (index == 0)\n\t\tqos_value = FREQ_QOS_MAX_DEFAULT_VALUE;\n\telse\n\t\tqos_value = pr->performance->states[index].core_frequency * 1000;\n\n\tret = freq_qos_update_request(&pr->perflib_req, qos_value);\n\tif (ret < 0) {\n\t\tpr_warn(\"Failed to update perflib freq constraint: CPU%d (%d)\\n\",\n\t\t\tpr->id, ret);\n\t}\n\n\treturn 0;\n}\n\n#define ACPI_PROCESSOR_NOTIFY_PERFORMANCE\t0x80\n \nstatic void acpi_processor_ppc_ost(acpi_handle handle, int status)\n{\n\tif (acpi_has_method(handle, \"_OST\"))\n\t\tacpi_evaluate_ost(handle, ACPI_PROCESSOR_NOTIFY_PERFORMANCE,\n\t\t\t\t  status, NULL);\n}\n\nvoid acpi_processor_ppc_has_changed(struct acpi_processor *pr, int event_flag)\n{\n\tint ret;\n\n\tif (ignore_ppc || !pr->performance) {\n\t\t \n\t\tif (event_flag)\n\t\t\tacpi_processor_ppc_ost(pr->handle, 1);\n\t\treturn;\n\t}\n\n\tret = acpi_processor_get_platform_limit(pr);\n\t \n\tif (event_flag) {\n\t\tif (ret < 0)\n\t\t\tacpi_processor_ppc_ost(pr->handle, 1);\n\t\telse\n\t\t\tacpi_processor_ppc_ost(pr->handle, 0);\n\t}\n\tif (ret >= 0)\n\t\tcpufreq_update_limits(pr->id);\n}\n\nint acpi_processor_get_bios_limit(int cpu, unsigned int *limit)\n{\n\tstruct acpi_processor *pr;\n\n\tpr = per_cpu(processors, cpu);\n\tif (!pr || !pr->performance || !pr->performance->state_count)\n\t\treturn -ENODEV;\n\n\t*limit = pr->performance->states[pr->performance_platform_limit].\n\t\tcore_frequency * 1000;\n\treturn 0;\n}\nEXPORT_SYMBOL(acpi_processor_get_bios_limit);\n\nvoid acpi_processor_ignore_ppc_init(void)\n{\n\tif (ignore_ppc < 0)\n\t\tignore_ppc = 0;\n}\n\nvoid acpi_processor_ppc_init(struct cpufreq_policy *policy)\n{\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, policy->related_cpus) {\n\t\tstruct acpi_processor *pr = per_cpu(processors, cpu);\n\t\tint ret;\n\n\t\tif (!pr)\n\t\t\tcontinue;\n\n\t\t \n\t\tpr->performance_platform_limit = 0;\n\n\t\tret = freq_qos_add_request(&policy->constraints,\n\t\t\t\t\t   &pr->perflib_req, FREQ_QOS_MAX,\n\t\t\t\t\t   FREQ_QOS_MAX_DEFAULT_VALUE);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"Failed to add freq constraint for CPU%d (%d)\\n\",\n\t\t\t       cpu, ret);\n\t}\n}\n\nvoid acpi_processor_ppc_exit(struct cpufreq_policy *policy)\n{\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, policy->related_cpus) {\n\t\tstruct acpi_processor *pr = per_cpu(processors, cpu);\n\n\t\tif (pr)\n\t\t\tfreq_qos_remove_request(&pr->perflib_req);\n\t}\n}\n\nstatic int acpi_processor_get_performance_control(struct acpi_processor *pr)\n{\n\tint result = 0;\n\tacpi_status status = 0;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *pct = NULL;\n\tunion acpi_object obj = { 0 };\n\n\tstatus = acpi_evaluate_object(pr->handle, \"_PCT\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_evaluation_failure_warn(pr->handle, \"_PCT\", status);\n\t\treturn -ENODEV;\n\t}\n\n\tpct = (union acpi_object *)buffer.pointer;\n\tif (!pct || pct->type != ACPI_TYPE_PACKAGE || pct->package.count != 2) {\n\t\tpr_err(\"Invalid _PCT data\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\t \n\n\tobj = pct->package.elements[0];\n\n\tif (!obj.buffer.pointer || obj.type != ACPI_TYPE_BUFFER ||\n\t    obj.buffer.length < sizeof(struct acpi_pct_register)) {\n\t\tpr_err(\"Invalid _PCT data (control_register)\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\tmemcpy(&pr->performance->control_register, obj.buffer.pointer,\n\t       sizeof(struct acpi_pct_register));\n\n\t \n\n\tobj = pct->package.elements[1];\n\n\tif (!obj.buffer.pointer || obj.type != ACPI_TYPE_BUFFER ||\n\t    obj.buffer.length < sizeof(struct acpi_pct_register)) {\n\t\tpr_err(\"Invalid _PCT data (status_register)\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tmemcpy(&pr->performance->status_register, obj.buffer.pointer,\n\t       sizeof(struct acpi_pct_register));\n\nend:\n\tkfree(buffer.pointer);\n\n\treturn result;\n}\n\n#ifdef CONFIG_X86\n \nstatic void amd_fixup_frequency(struct acpi_processor_px *px, int i)\n{\n\tu32 hi, lo, fid, did;\n\tint index = px->control & 0x00000007;\n\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD)\n\t\treturn;\n\n\tif ((boot_cpu_data.x86 == 0x10 && boot_cpu_data.x86_model < 10) ||\n\t    boot_cpu_data.x86 == 0x11) {\n\t\trdmsr(MSR_AMD_PSTATE_DEF_BASE + index, lo, hi);\n\t\t \n\t\tif (!(hi & BIT(31)))\n\t\t\treturn;\n\n\t\tfid = lo & 0x3f;\n\t\tdid = (lo >> 6) & 7;\n\t\tif (boot_cpu_data.x86 == 0x10)\n\t\t\tpx->core_frequency = (100 * (fid + 0x10)) >> did;\n\t\telse\n\t\t\tpx->core_frequency = (100 * (fid + 8)) >> did;\n\t}\n}\n#else\nstatic void amd_fixup_frequency(struct acpi_processor_px *px, int i) {};\n#endif\n\nstatic int acpi_processor_get_performance_states(struct acpi_processor *pr)\n{\n\tint result = 0;\n\tacpi_status status = AE_OK;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_buffer format = { sizeof(\"NNNNNN\"), \"NNNNNN\" };\n\tstruct acpi_buffer state = { 0, NULL };\n\tunion acpi_object *pss = NULL;\n\tint i;\n\tint last_invalid = -1;\n\n\tstatus = acpi_evaluate_object(pr->handle, \"_PSS\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_evaluation_failure_warn(pr->handle, \"_PSS\", status);\n\t\treturn -ENODEV;\n\t}\n\n\tpss = buffer.pointer;\n\tif (!pss || pss->type != ACPI_TYPE_PACKAGE) {\n\t\tpr_err(\"Invalid _PSS data\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tacpi_handle_debug(pr->handle, \"Found %d performance states\\n\",\n\t\t\t  pss->package.count);\n\n\tpr->performance->state_count = pss->package.count;\n\tpr->performance->states =\n\t    kmalloc_array(pss->package.count,\n\t\t\t  sizeof(struct acpi_processor_px),\n\t\t\t  GFP_KERNEL);\n\tif (!pr->performance->states) {\n\t\tresult = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tfor (i = 0; i < pr->performance->state_count; i++) {\n\n\t\tstruct acpi_processor_px *px = &(pr->performance->states[i]);\n\n\t\tstate.length = sizeof(struct acpi_processor_px);\n\t\tstate.pointer = px;\n\n\t\tacpi_handle_debug(pr->handle, \"Extracting state %d\\n\", i);\n\n\t\tstatus = acpi_extract_package(&(pss->package.elements[i]),\n\t\t\t\t\t      &format, &state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_handle_warn(pr->handle, \"Invalid _PSS data: %s\\n\",\n\t\t\t\t\t acpi_format_exception(status));\n\t\t\tresult = -EFAULT;\n\t\t\tkfree(pr->performance->states);\n\t\t\tgoto end;\n\t\t}\n\n\t\tamd_fixup_frequency(px, i);\n\n\t\tacpi_handle_debug(pr->handle,\n\t\t\t\t  \"State [%d]: core_frequency[%d] power[%d] transition_latency[%d] bus_master_latency[%d] control[0x%x] status[0x%x]\\n\",\n\t\t\t\t  i,\n\t\t\t\t  (u32) px->core_frequency,\n\t\t\t\t  (u32) px->power,\n\t\t\t\t  (u32) px->transition_latency,\n\t\t\t\t  (u32) px->bus_master_latency,\n\t\t\t\t  (u32) px->control, (u32) px->status);\n\n\t\t \n\t\tif (!px->core_frequency ||\n\t\t    (u32)(px->core_frequency * 1000) != px->core_frequency * 1000) {\n\t\t\tpr_err(FW_BUG\n\t\t\t       \"Invalid BIOS _PSS frequency found for processor %d: 0x%llx MHz\\n\",\n\t\t\t       pr->id, px->core_frequency);\n\t\t\tif (last_invalid == -1)\n\t\t\t\tlast_invalid = i;\n\t\t} else {\n\t\t\tif (last_invalid != -1) {\n\t\t\t\t \n\t\t\t\tmemcpy(&(pr->performance->states[last_invalid]),\n\t\t\t\t       px, sizeof(struct acpi_processor_px));\n\t\t\t\t++last_invalid;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (last_invalid == 0) {\n\t\tpr_err(FW_BUG\n\t\t\t   \"No valid BIOS _PSS frequency found for processor %d\\n\", pr->id);\n\t\tresult = -EFAULT;\n\t\tkfree(pr->performance->states);\n\t\tpr->performance->states = NULL;\n\t}\n\n\tif (last_invalid > 0)\n\t\tpr->performance->state_count = last_invalid;\n\nend:\n\tkfree(buffer.pointer);\n\n\treturn result;\n}\n\nint acpi_processor_get_performance_info(struct acpi_processor *pr)\n{\n\tint result = 0;\n\n\tif (!pr || !pr->performance || !pr->handle)\n\t\treturn -EINVAL;\n\n\tif (!acpi_has_method(pr->handle, \"_PCT\")) {\n\t\tacpi_handle_debug(pr->handle,\n\t\t\t\t  \"ACPI-based processor performance control unavailable\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tresult = acpi_processor_get_performance_control(pr);\n\tif (result)\n\t\tgoto update_bios;\n\n\tresult = acpi_processor_get_performance_states(pr);\n\tif (result)\n\t\tgoto update_bios;\n\n\t \n\tif (ignore_ppc != 1)\n\t\tresult = acpi_processor_get_platform_limit(pr);\n\n\treturn result;\n\n\t \n update_bios:\n#ifdef CONFIG_X86\n\tif (acpi_has_method(pr->handle, \"_PPC\")) {\n\t\tif(boot_cpu_has(X86_FEATURE_EST))\n\t\t\tpr_warn(FW_BUG \"BIOS needs update for CPU \"\n\t\t\t       \"frequency support\\n\");\n\t}\n#endif\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(acpi_processor_get_performance_info);\n\nint acpi_processor_pstate_control(void)\n{\n\tacpi_status status;\n\n\tif (!acpi_gbl_FADT.smi_command || !acpi_gbl_FADT.pstate_control)\n\t\treturn 0;\n\n\tpr_debug(\"Writing pstate_control [0x%x] to smi_command [0x%x]\\n\",\n\t\t acpi_gbl_FADT.pstate_control, acpi_gbl_FADT.smi_command);\n\n\tstatus = acpi_os_write_port(acpi_gbl_FADT.smi_command,\n\t\t\t\t    (u32)acpi_gbl_FADT.pstate_control, 8);\n\tif (ACPI_SUCCESS(status))\n\t\treturn 1;\n\n\tpr_warn(\"Failed to write pstate_control [0x%x] to smi_command [0x%x]: %s\\n\",\n\t\tacpi_gbl_FADT.pstate_control, acpi_gbl_FADT.smi_command,\n\t\tacpi_format_exception(status));\n\treturn -EIO;\n}\n\nint acpi_processor_notify_smm(struct module *calling_module)\n{\n\tstatic int is_done;\n\tint result = 0;\n\n\tif (!acpi_processor_cpufreq_init)\n\t\treturn -EBUSY;\n\n\tif (!try_module_get(calling_module))\n\t\treturn -EINVAL;\n\n\t \n\tif (is_done != 0) {\n\t\tif (is_done < 0)\n\t\t\tresult = is_done;\n\n\t\tgoto out_put;\n\t}\n\n\tresult = acpi_processor_pstate_control();\n\tif (result <= 0) {\n\t\tif (result) {\n\t\t\tis_done = result;\n\t\t} else {\n\t\t\tpr_debug(\"No SMI port or pstate_control\\n\");\n\t\t\tis_done = 1;\n\t\t}\n\t\tgoto out_put;\n\t}\n\n\tis_done = 1;\n\t \n\tif (acpi_processor_ppc_in_use)\n\t\treturn 0;\n\nout_put:\n\tmodule_put(calling_module);\n\treturn result;\n}\nEXPORT_SYMBOL(acpi_processor_notify_smm);\n\nint acpi_processor_get_psd(acpi_handle handle, struct acpi_psd_package *pdomain)\n{\n\tint result = 0;\n\tacpi_status status = AE_OK;\n\tstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\n\tstruct acpi_buffer format = {sizeof(\"NNNNN\"), \"NNNNN\"};\n\tstruct acpi_buffer state = {0, NULL};\n\tunion acpi_object  *psd = NULL;\n\n\tstatus = acpi_evaluate_object(handle, \"_PSD\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn -ENODEV;\n\t}\n\n\tpsd = buffer.pointer;\n\tif (!psd || psd->type != ACPI_TYPE_PACKAGE) {\n\t\tpr_err(\"Invalid _PSD data\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tif (psd->package.count != 1) {\n\t\tpr_err(\"Invalid _PSD data\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tstate.length = sizeof(struct acpi_psd_package);\n\tstate.pointer = pdomain;\n\n\tstatus = acpi_extract_package(&(psd->package.elements[0]), &format, &state);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Invalid _PSD data\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tif (pdomain->num_entries != ACPI_PSD_REV0_ENTRIES) {\n\t\tpr_err(\"Unknown _PSD:num_entries\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tif (pdomain->revision != ACPI_PSD_REV0_REVISION) {\n\t\tpr_err(\"Unknown _PSD:revision\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tif (pdomain->coord_type != DOMAIN_COORD_TYPE_SW_ALL &&\n\t    pdomain->coord_type != DOMAIN_COORD_TYPE_SW_ANY &&\n\t    pdomain->coord_type != DOMAIN_COORD_TYPE_HW_ALL) {\n\t\tpr_err(\"Invalid _PSD:coord_type\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\nend:\n\tkfree(buffer.pointer);\n\treturn result;\n}\nEXPORT_SYMBOL(acpi_processor_get_psd);\n\nint acpi_processor_preregister_performance(\n\t\tstruct acpi_processor_performance __percpu *performance)\n{\n\tint count_target;\n\tint retval = 0;\n\tunsigned int i, j;\n\tcpumask_var_t covered_cpus;\n\tstruct acpi_processor *pr;\n\tstruct acpi_psd_package *pdomain;\n\tstruct acpi_processor *match_pr;\n\tstruct acpi_psd_package *match_pdomain;\n\n\tif (!zalloc_cpumask_var(&covered_cpus, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&performance_mutex);\n\n\t \n\tfor_each_possible_cpu(i) {\n\t\tpr = per_cpu(processors, i);\n\t\tif (!pr) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pr->performance) {\n\t\t\tretval = -EBUSY;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (!performance || !per_cpu_ptr(performance, i)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\t \n\tfor_each_possible_cpu(i) {\n\t\tpr = per_cpu(processors, i);\n\t\tif (!pr)\n\t\t\tcontinue;\n\n\t\tpr->performance = per_cpu_ptr(performance, i);\n\t\tpdomain = &(pr->performance->domain_info);\n\t\tif (acpi_processor_get_psd(pr->handle, pdomain)) {\n\t\t\tretval = -EINVAL;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif (retval)\n\t\tgoto err_ret;\n\n\t \n\tfor_each_possible_cpu(i) {\n\t\tpr = per_cpu(processors, i);\n\t\tif (!pr)\n\t\t\tcontinue;\n\n\t\tif (cpumask_test_cpu(i, covered_cpus))\n\t\t\tcontinue;\n\n\t\tpdomain = &(pr->performance->domain_info);\n\t\tcpumask_set_cpu(i, pr->performance->shared_cpu_map);\n\t\tcpumask_set_cpu(i, covered_cpus);\n\t\tif (pdomain->num_processors <= 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tcount_target = pdomain->num_processors;\n\t\tif (pdomain->coord_type == DOMAIN_COORD_TYPE_SW_ALL)\n\t\t\tpr->performance->shared_type = CPUFREQ_SHARED_TYPE_ALL;\n\t\telse if (pdomain->coord_type == DOMAIN_COORD_TYPE_HW_ALL)\n\t\t\tpr->performance->shared_type = CPUFREQ_SHARED_TYPE_HW;\n\t\telse if (pdomain->coord_type == DOMAIN_COORD_TYPE_SW_ANY)\n\t\t\tpr->performance->shared_type = CPUFREQ_SHARED_TYPE_ANY;\n\n\t\tfor_each_possible_cpu(j) {\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\n\t\t\tmatch_pr = per_cpu(processors, j);\n\t\t\tif (!match_pr)\n\t\t\t\tcontinue;\n\n\t\t\tmatch_pdomain = &(match_pr->performance->domain_info);\n\t\t\tif (match_pdomain->domain != pdomain->domain)\n\t\t\t\tcontinue;\n\n\t\t\t \n\n\t\t\tif (match_pdomain->num_processors != count_target) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto err_ret;\n\t\t\t}\n\n\t\t\tif (pdomain->coord_type != match_pdomain->coord_type) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto err_ret;\n\t\t\t}\n\n\t\t\tcpumask_set_cpu(j, covered_cpus);\n\t\t\tcpumask_set_cpu(j, pr->performance->shared_cpu_map);\n\t\t}\n\n\t\tfor_each_possible_cpu(j) {\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\n\t\t\tmatch_pr = per_cpu(processors, j);\n\t\t\tif (!match_pr)\n\t\t\t\tcontinue;\n\n\t\t\tmatch_pdomain = &(match_pr->performance->domain_info);\n\t\t\tif (match_pdomain->domain != pdomain->domain)\n\t\t\t\tcontinue;\n\n\t\t\tmatch_pr->performance->shared_type =\n\t\t\t\t\tpr->performance->shared_type;\n\t\t\tcpumask_copy(match_pr->performance->shared_cpu_map,\n\t\t\t\t     pr->performance->shared_cpu_map);\n\t\t}\n\t}\n\nerr_ret:\n\tfor_each_possible_cpu(i) {\n\t\tpr = per_cpu(processors, i);\n\t\tif (!pr || !pr->performance)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (retval) {\n\t\t\tcpumask_clear(pr->performance->shared_cpu_map);\n\t\t\tcpumask_set_cpu(i, pr->performance->shared_cpu_map);\n\t\t\tpr->performance->shared_type = CPUFREQ_SHARED_TYPE_NONE;\n\t\t}\n\t\tpr->performance = NULL;  \n\t}\n\nerr_out:\n\tmutex_unlock(&performance_mutex);\n\tfree_cpumask_var(covered_cpus);\n\treturn retval;\n}\nEXPORT_SYMBOL(acpi_processor_preregister_performance);\n\nint acpi_processor_register_performance(struct acpi_processor_performance\n\t\t\t\t\t*performance, unsigned int cpu)\n{\n\tstruct acpi_processor *pr;\n\n\tif (!acpi_processor_cpufreq_init)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&performance_mutex);\n\n\tpr = per_cpu(processors, cpu);\n\tif (!pr) {\n\t\tmutex_unlock(&performance_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif (pr->performance) {\n\t\tmutex_unlock(&performance_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tWARN_ON(!performance);\n\n\tpr->performance = performance;\n\n\tif (acpi_processor_get_performance_info(pr)) {\n\t\tpr->performance = NULL;\n\t\tmutex_unlock(&performance_mutex);\n\t\treturn -EIO;\n\t}\n\n\tmutex_unlock(&performance_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(acpi_processor_register_performance);\n\nvoid acpi_processor_unregister_performance(unsigned int cpu)\n{\n\tstruct acpi_processor *pr;\n\n\tmutex_lock(&performance_mutex);\n\n\tpr = per_cpu(processors, cpu);\n\tif (!pr)\n\t\tgoto unlock;\n\n\tif (pr->performance)\n\t\tkfree(pr->performance->states);\n\n\tpr->performance = NULL;\n\nunlock:\n\tmutex_unlock(&performance_mutex);\n}\nEXPORT_SYMBOL(acpi_processor_unregister_performance);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}