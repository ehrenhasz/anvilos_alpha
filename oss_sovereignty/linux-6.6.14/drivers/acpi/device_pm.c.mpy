{
  "module_name": "device_pm.c",
  "hash_id": "94c14e7ebc010e05fd47eecb6852632ca14f3f3a2fafea8f5bf71002e5785b4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/device_pm.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"PM: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/pm_qos.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/suspend.h>\n\n#include \"fan.h\"\n#include \"internal.h\"\n\n \nconst char *acpi_power_state_string(int state)\n{\n\tswitch (state) {\n\tcase ACPI_STATE_D0:\n\t\treturn \"D0\";\n\tcase ACPI_STATE_D1:\n\t\treturn \"D1\";\n\tcase ACPI_STATE_D2:\n\t\treturn \"D2\";\n\tcase ACPI_STATE_D3_HOT:\n\t\treturn \"D3hot\";\n\tcase ACPI_STATE_D3_COLD:\n\t\treturn \"D3cold\";\n\tdefault:\n\t\treturn \"(unknown)\";\n\t}\n}\n\nstatic int acpi_dev_pm_explicit_get(struct acpi_device *device, int *state)\n{\n\tunsigned long long psc;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(device->handle, \"_PSC\", NULL, &psc);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\t*state = psc;\n\treturn 0;\n}\n\n \nint acpi_device_get_power(struct acpi_device *device, int *state)\n{\n\tint result = ACPI_STATE_UNKNOWN;\n\tstruct acpi_device *parent;\n\tint error;\n\n\tif (!device || !state)\n\t\treturn -EINVAL;\n\n\tparent = acpi_dev_parent(device);\n\n\tif (!device->flags.power_manageable) {\n\t\t \n\t\t*state = parent ? parent->power.state : ACPI_STATE_D0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (device->power.flags.power_resources) {\n\t\terror = acpi_power_get_inferred_state(device, &result);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (device->power.flags.explicit_get) {\n\t\tint psc;\n\n\t\terror = acpi_dev_pm_explicit_get(device, &psc);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tif (psc > result && psc < ACPI_STATE_D3_COLD)\n\t\t\tresult = psc;\n\t\telse if (result == ACPI_STATE_UNKNOWN)\n\t\t\tresult = psc > ACPI_STATE_D2 ? ACPI_STATE_D3_HOT : psc;\n\t}\n\n\t \n\tif (!device->power.flags.ignore_parent && parent &&\n\t    parent->power.state == ACPI_STATE_UNKNOWN &&\n\t    result == ACPI_STATE_D0)\n\t\tparent->power.state = ACPI_STATE_D0;\n\n\t*state = result;\n\n out:\n\tacpi_handle_debug(device->handle, \"Power state: %s\\n\",\n\t\t\t  acpi_power_state_string(*state));\n\n\treturn 0;\n}\n\nstatic int acpi_dev_pm_explicit_set(struct acpi_device *adev, int state)\n{\n\tif (adev->power.states[state].flags.explicit_set) {\n\t\tchar method[5] = { '_', 'P', 'S', '0' + state, '\\0' };\n\t\tacpi_status status;\n\n\t\tstatus = acpi_evaluate_object(adev->handle, method, NULL, NULL);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n \nint acpi_device_set_power(struct acpi_device *device, int state)\n{\n\tint target_state = state;\n\tint result = 0;\n\n\tif (!device || !device->flags.power_manageable\n\t    || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))\n\t\treturn -EINVAL;\n\n\tacpi_handle_debug(device->handle, \"Power state change: %s -> %s\\n\",\n\t\t\t  acpi_power_state_string(device->power.state),\n\t\t\t  acpi_power_state_string(state));\n\n\t \n\n\t \n\tif (state > ACPI_STATE_D0 && state == device->power.state)\n\t\tgoto no_change;\n\n\tif (state == ACPI_STATE_D3_COLD) {\n\t\t \n\t\tstate = ACPI_STATE_D3_HOT;\n\t\t \n\t\tif (!device->power.states[ACPI_STATE_D3_COLD].flags.valid)\n\t\t\ttarget_state = state;\n\t} else if (!device->power.states[state].flags.valid) {\n\t\tacpi_handle_debug(device->handle, \"Power state %s not supported\\n\",\n\t\t\t\t  acpi_power_state_string(state));\n\t\treturn -ENODEV;\n\t}\n\n\tif (!device->power.flags.ignore_parent) {\n\t\tstruct acpi_device *parent;\n\n\t\tparent = acpi_dev_parent(device);\n\t\tif (parent && state < parent->power.state) {\n\t\t\tacpi_handle_debug(device->handle,\n\t\t\t\t\t  \"Cannot transition to %s for parent in %s\\n\",\n\t\t\t\t\t  acpi_power_state_string(state),\n\t\t\t\t\t  acpi_power_state_string(parent->power.state));\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tif (state > ACPI_STATE_D0) {\n\t\t \n\t\tif (state < device->power.state) {\n\t\t\tacpi_handle_debug(device->handle,\n\t\t\t\t\t  \"Cannot transition from %s to %s\\n\",\n\t\t\t\t\t  acpi_power_state_string(device->power.state),\n\t\t\t\t\t  acpi_power_state_string(state));\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tif (device->power.state < ACPI_STATE_D3_HOT) {\n\t\t\tresult = acpi_dev_pm_explicit_set(device, state);\n\t\t\tif (result)\n\t\t\t\tgoto end;\n\t\t}\n\n\t\tif (device->power.flags.power_resources)\n\t\t\tresult = acpi_power_transition(device, target_state);\n\t} else {\n\t\tint cur_state = device->power.state;\n\n\t\tif (device->power.flags.power_resources) {\n\t\t\tresult = acpi_power_transition(device, ACPI_STATE_D0);\n\t\t\tif (result)\n\t\t\t\tgoto end;\n\t\t}\n\n\t\tif (cur_state == ACPI_STATE_D0) {\n\t\t\tint psc;\n\n\t\t\t \n\t\t\tif (!device->power.flags.explicit_get)\n\t\t\t\tgoto no_change;\n\n\t\t\t \n\t\t\tresult = acpi_dev_pm_explicit_get(device, &psc);\n\t\t\tif (result || psc == ACPI_STATE_D0)\n\t\t\t\tgoto no_change;\n\t\t}\n\n\t\tresult = acpi_dev_pm_explicit_set(device, ACPI_STATE_D0);\n\t}\n\nend:\n\tif (result) {\n\t\tacpi_handle_debug(device->handle,\n\t\t\t\t  \"Failed to change power state to %s\\n\",\n\t\t\t\t  acpi_power_state_string(target_state));\n\t} else {\n\t\tdevice->power.state = target_state;\n\t\tacpi_handle_debug(device->handle, \"Power state changed to %s\\n\",\n\t\t\t\t  acpi_power_state_string(target_state));\n\t}\n\n\treturn result;\n\nno_change:\n\tacpi_handle_debug(device->handle, \"Already in %s\\n\",\n\t\t\t  acpi_power_state_string(state));\n\treturn 0;\n}\nEXPORT_SYMBOL(acpi_device_set_power);\n\nint acpi_bus_set_power(acpi_handle handle, int state)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\n\tif (device)\n\t\treturn acpi_device_set_power(device, state);\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL(acpi_bus_set_power);\n\nint acpi_bus_init_power(struct acpi_device *device)\n{\n\tint state;\n\tint result;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tdevice->power.state = ACPI_STATE_UNKNOWN;\n\tif (!acpi_device_is_present(device)) {\n\t\tdevice->flags.initialized = false;\n\t\treturn -ENXIO;\n\t}\n\n\tresult = acpi_device_get_power(device, &state);\n\tif (result)\n\t\treturn result;\n\n\tif (state < ACPI_STATE_D3_COLD && device->power.flags.power_resources) {\n\t\t \n\t\tresult = acpi_power_on_resources(device, state);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tif (state == ACPI_STATE_D0) {\n\t\t\t \n\t\t\tresult = acpi_dev_pm_explicit_set(device, state);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t}\n\t} else if (state == ACPI_STATE_UNKNOWN) {\n\t\t \n\t\tstate = ACPI_STATE_D0;\n\t}\n\tdevice->power.state = state;\n\treturn 0;\n}\n\n \nint acpi_device_fix_up_power(struct acpi_device *device)\n{\n\tint ret = 0;\n\n\tif (!device->power.flags.power_resources\n\t    && !device->power.flags.explicit_get\n\t    && device->power.state == ACPI_STATE_D0)\n\t\tret = acpi_dev_pm_explicit_set(device, ACPI_STATE_D0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(acpi_device_fix_up_power);\n\nstatic int fix_up_power_if_applicable(struct acpi_device *adev, void *not_used)\n{\n\tif (adev->status.present && adev->status.enabled)\n\t\tacpi_device_fix_up_power(adev);\n\n\treturn 0;\n}\n\n \nvoid acpi_device_fix_up_power_extended(struct acpi_device *adev)\n{\n\tacpi_device_fix_up_power(adev);\n\tacpi_dev_for_each_child(adev, fix_up_power_if_applicable, NULL);\n}\nEXPORT_SYMBOL_GPL(acpi_device_fix_up_power_extended);\n\n \nvoid acpi_device_fix_up_power_children(struct acpi_device *adev)\n{\n\tacpi_dev_for_each_child(adev, fix_up_power_if_applicable, NULL);\n}\nEXPORT_SYMBOL_GPL(acpi_device_fix_up_power_children);\n\nint acpi_device_update_power(struct acpi_device *device, int *state_p)\n{\n\tint state;\n\tint result;\n\n\tif (device->power.state == ACPI_STATE_UNKNOWN) {\n\t\tresult = acpi_bus_init_power(device);\n\t\tif (!result && state_p)\n\t\t\t*state_p = device->power.state;\n\n\t\treturn result;\n\t}\n\n\tresult = acpi_device_get_power(device, &state);\n\tif (result)\n\t\treturn result;\n\n\tif (state == ACPI_STATE_UNKNOWN) {\n\t\tstate = ACPI_STATE_D0;\n\t\tresult = acpi_device_set_power(device, state);\n\t\tif (result)\n\t\t\treturn result;\n\t} else {\n\t\tif (device->power.flags.power_resources) {\n\t\t\t \n\t\t\tresult = acpi_power_transition(device, state);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t}\n\t\tdevice->power.state = state;\n\t}\n\tif (state_p)\n\t\t*state_p = state;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_device_update_power);\n\nint acpi_bus_update_power(acpi_handle handle, int *state_p)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\n\tif (device)\n\t\treturn acpi_device_update_power(device, state_p);\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(acpi_bus_update_power);\n\nbool acpi_bus_power_manageable(acpi_handle handle)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\n\treturn device && device->flags.power_manageable;\n}\nEXPORT_SYMBOL(acpi_bus_power_manageable);\n\nstatic int acpi_power_up_if_adr_present(struct acpi_device *adev, void *not_used)\n{\n\tif (!(adev->flags.power_manageable && adev->pnp.type.bus_address))\n\t\treturn 0;\n\n\tacpi_handle_debug(adev->handle, \"Power state: %s\\n\",\n\t\t\t  acpi_power_state_string(adev->power.state));\n\n\tif (adev->power.state == ACPI_STATE_D3_COLD)\n\t\treturn acpi_device_set_power(adev, ACPI_STATE_D0);\n\n\treturn 0;\n}\n\n \nvoid acpi_dev_power_up_children_with_adr(struct acpi_device *adev)\n{\n\tacpi_dev_for_each_child(adev, acpi_power_up_if_adr_present, NULL);\n}\n\n \nu8 acpi_dev_power_state_for_wake(struct acpi_device *adev)\n{\n\tunsigned long long state;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(adev->handle, \"_S0W\", NULL, &state);\n\tif (ACPI_FAILURE(status))\n\t\treturn ACPI_STATE_UNKNOWN;\n\n\treturn state;\n}\n\n#ifdef CONFIG_PM\nstatic DEFINE_MUTEX(acpi_pm_notifier_lock);\nstatic DEFINE_MUTEX(acpi_pm_notifier_install_lock);\n\nvoid acpi_pm_wakeup_event(struct device *dev)\n{\n\tpm_wakeup_dev_event(dev, 0, acpi_s2idle_wakeup());\n}\nEXPORT_SYMBOL_GPL(acpi_pm_wakeup_event);\n\nstatic void acpi_pm_notify_handler(acpi_handle handle, u32 val, void *not_used)\n{\n\tstruct acpi_device *adev;\n\n\tif (val != ACPI_NOTIFY_DEVICE_WAKE)\n\t\treturn;\n\n\tacpi_handle_debug(handle, \"Wake notify\\n\");\n\n\tadev = acpi_get_acpi_dev(handle);\n\tif (!adev)\n\t\treturn;\n\n\tmutex_lock(&acpi_pm_notifier_lock);\n\n\tif (adev->wakeup.flags.notifier_present) {\n\t\tpm_wakeup_ws_event(adev->wakeup.ws, 0, acpi_s2idle_wakeup());\n\t\tif (adev->wakeup.context.func) {\n\t\t\tacpi_handle_debug(handle, \"Running %pS for %s\\n\",\n\t\t\t\t\t  adev->wakeup.context.func,\n\t\t\t\t\t  dev_name(adev->wakeup.context.dev));\n\t\t\tadev->wakeup.context.func(&adev->wakeup.context);\n\t\t}\n\t}\n\n\tmutex_unlock(&acpi_pm_notifier_lock);\n\n\tacpi_put_acpi_dev(adev);\n}\n\n \nacpi_status acpi_add_pm_notifier(struct acpi_device *adev, struct device *dev,\n\t\t\tvoid (*func)(struct acpi_device_wakeup_context *context))\n{\n\tacpi_status status = AE_ALREADY_EXISTS;\n\n\tif (!dev && !func)\n\t\treturn AE_BAD_PARAMETER;\n\n\tmutex_lock(&acpi_pm_notifier_install_lock);\n\n\tif (adev->wakeup.flags.notifier_present)\n\t\tgoto out;\n\n\tstatus = acpi_install_notify_handler(adev->handle, ACPI_SYSTEM_NOTIFY,\n\t\t\t\t\t     acpi_pm_notify_handler, NULL);\n\tif (ACPI_FAILURE(status))\n\t\tgoto out;\n\n\tmutex_lock(&acpi_pm_notifier_lock);\n\tadev->wakeup.ws = wakeup_source_register(&adev->dev,\n\t\t\t\t\t\t dev_name(&adev->dev));\n\tadev->wakeup.context.dev = dev;\n\tadev->wakeup.context.func = func;\n\tadev->wakeup.flags.notifier_present = true;\n\tmutex_unlock(&acpi_pm_notifier_lock);\n\n out:\n\tmutex_unlock(&acpi_pm_notifier_install_lock);\n\treturn status;\n}\n\n \nacpi_status acpi_remove_pm_notifier(struct acpi_device *adev)\n{\n\tacpi_status status = AE_BAD_PARAMETER;\n\n\tmutex_lock(&acpi_pm_notifier_install_lock);\n\n\tif (!adev->wakeup.flags.notifier_present)\n\t\tgoto out;\n\n\tstatus = acpi_remove_notify_handler(adev->handle,\n\t\t\t\t\t    ACPI_SYSTEM_NOTIFY,\n\t\t\t\t\t    acpi_pm_notify_handler);\n\tif (ACPI_FAILURE(status))\n\t\tgoto out;\n\n\tmutex_lock(&acpi_pm_notifier_lock);\n\tadev->wakeup.context.func = NULL;\n\tadev->wakeup.context.dev = NULL;\n\twakeup_source_unregister(adev->wakeup.ws);\n\tadev->wakeup.flags.notifier_present = false;\n\tmutex_unlock(&acpi_pm_notifier_lock);\n\n out:\n\tmutex_unlock(&acpi_pm_notifier_install_lock);\n\treturn status;\n}\n\nbool acpi_bus_can_wakeup(acpi_handle handle)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\n\treturn device && device->wakeup.flags.valid;\n}\nEXPORT_SYMBOL(acpi_bus_can_wakeup);\n\nbool acpi_pm_device_can_wakeup(struct device *dev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\n\treturn adev ? acpi_device_can_wakeup(adev) : false;\n}\n\n \nstatic int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,\n\t\t\t\t u32 target_state, int *d_min_p, int *d_max_p)\n{\n\tchar method[] = { '_', 'S', '0' + target_state, 'D', '\\0' };\n\tacpi_handle handle = adev->handle;\n\tunsigned long long ret;\n\tint d_min, d_max;\n\tbool wakeup = false;\n\tbool has_sxd = false;\n\tacpi_status status;\n\n\t \n\td_min = ACPI_STATE_D0;\n\td_max = ACPI_STATE_D3_COLD;\n\n\t \n\tif (target_state > ACPI_STATE_S0) {\n\t\t \n\t\tret = d_min;\n\t\tstatus = acpi_evaluate_integer(handle, method, NULL, &ret);\n\t\tif ((ACPI_FAILURE(status) && status != AE_NOT_FOUND)\n\t\t    || ret > ACPI_STATE_D3_COLD)\n\t\t\treturn -ENODATA;\n\n\t\t \n\t\tif (!adev->power.states[ret].flags.valid) {\n\t\t\tif (ret == ACPI_STATE_D3_HOT)\n\t\t\t\tret = ACPI_STATE_D3_COLD;\n\t\t\telse\n\t\t\t\treturn -ENODATA;\n\t\t}\n\n\t\tif (status == AE_OK)\n\t\t\thas_sxd = true;\n\n\t\td_min = ret;\n\t\twakeup = device_may_wakeup(dev) && adev->wakeup.flags.valid\n\t\t\t&& adev->wakeup.sleep_state >= target_state;\n\t} else if (device_may_wakeup(dev) && dev->power.wakeirq) {\n\t\t \n\t\twakeup = true;\n\t} else {\n\t\t \n\t\twakeup = adev->wakeup.flags.valid;\n\t}\n\n\t \n\tif (wakeup) {\n\t\tmethod[3] = 'W';\n\t\tstatus = acpi_evaluate_integer(handle, method, NULL, &ret);\n\t\tif (status == AE_NOT_FOUND) {\n\t\t\t \n\t\t\tif (has_sxd && target_state > ACPI_STATE_S0)\n\t\t\t\td_max = d_min;\n\t\t} else if (ACPI_SUCCESS(status) && ret <= ACPI_STATE_D3_COLD) {\n\t\t\t \n\t\t\tif (!adev->power.states[ret].flags.valid)\n\t\t\t\tret = ACPI_STATE_D3_COLD;\n\n\t\t\td_max = ret > d_min ? ret : d_min;\n\t\t} else {\n\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\n\tif (d_min_p)\n\t\t*d_min_p = d_min;\n\n\tif (d_max_p)\n\t\t*d_max_p = d_max;\n\n\treturn 0;\n}\n\n \nint acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)\n{\n\tstruct acpi_device *adev;\n\tint ret, d_min, d_max;\n\n\tif (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3_COLD)\n\t\treturn -EINVAL;\n\n\tif (d_max_in > ACPI_STATE_D2) {\n\t\tenum pm_qos_flags_status stat;\n\n\t\tstat = dev_pm_qos_flags(dev, PM_QOS_FLAG_NO_POWER_OFF);\n\t\tif (stat == PM_QOS_FLAGS_ALL)\n\t\t\td_max_in = ACPI_STATE_D2;\n\t}\n\n\tadev = ACPI_COMPANION(dev);\n\tif (!adev) {\n\t\tdev_dbg(dev, \"ACPI companion missing in %s!\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tret = acpi_dev_pm_get_state(dev, adev, acpi_target_system_state(),\n\t\t\t\t    &d_min, &d_max);\n\tif (ret)\n\t\treturn ret;\n\n\tif (d_max_in < d_min)\n\t\treturn -EINVAL;\n\n\tif (d_max > d_max_in) {\n\t\tfor (d_max = d_max_in; d_max > d_min; d_max--) {\n\t\t\tif (adev->power.states[d_max].flags.valid)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (d_min_p)\n\t\t*d_min_p = d_min;\n\n\treturn d_max;\n}\nEXPORT_SYMBOL(acpi_pm_device_sleep_state);\n\n \nstatic void acpi_pm_notify_work_func(struct acpi_device_wakeup_context *context)\n{\n\tstruct device *dev = context->dev;\n\n\tif (dev) {\n\t\tpm_wakeup_event(dev, 0);\n\t\tpm_request_resume(dev);\n\t}\n}\n\nstatic DEFINE_MUTEX(acpi_wakeup_lock);\n\nstatic int __acpi_device_wakeup_enable(struct acpi_device *adev,\n\t\t\t\t       u32 target_state)\n{\n\tstruct acpi_device_wakeup *wakeup = &adev->wakeup;\n\tacpi_status status;\n\tint error = 0;\n\n\tmutex_lock(&acpi_wakeup_lock);\n\n\t \n\tif (wakeup->enable_count > 0)\n\t\tacpi_disable_wakeup_device_power(adev);\n\n\terror = acpi_enable_wakeup_device_power(adev, target_state);\n\tif (error) {\n\t\tif (wakeup->enable_count > 0) {\n\t\t\tacpi_disable_gpe(wakeup->gpe_device, wakeup->gpe_number);\n\t\t\twakeup->enable_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (wakeup->enable_count > 0)\n\t\tgoto inc;\n\n\tstatus = acpi_enable_gpe(wakeup->gpe_device, wakeup->gpe_number);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_disable_wakeup_device_power(adev);\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\tacpi_handle_debug(adev->handle, \"GPE%2X enabled for wakeup\\n\",\n\t\t\t  (unsigned int)wakeup->gpe_number);\n\ninc:\n\tif (wakeup->enable_count < INT_MAX)\n\t\twakeup->enable_count++;\n\telse\n\t\tacpi_handle_info(adev->handle, \"Wakeup enable count out of bounds!\\n\");\n\nout:\n\tmutex_unlock(&acpi_wakeup_lock);\n\treturn error;\n}\n\n \nstatic int acpi_device_wakeup_enable(struct acpi_device *adev, u32 target_state)\n{\n\treturn __acpi_device_wakeup_enable(adev, target_state);\n}\n\n \nstatic void acpi_device_wakeup_disable(struct acpi_device *adev)\n{\n\tstruct acpi_device_wakeup *wakeup = &adev->wakeup;\n\n\tmutex_lock(&acpi_wakeup_lock);\n\n\tif (!wakeup->enable_count)\n\t\tgoto out;\n\n\tacpi_disable_gpe(wakeup->gpe_device, wakeup->gpe_number);\n\tacpi_disable_wakeup_device_power(adev);\n\n\twakeup->enable_count--;\n\nout:\n\tmutex_unlock(&acpi_wakeup_lock);\n}\n\n \nint acpi_pm_set_device_wakeup(struct device *dev, bool enable)\n{\n\tstruct acpi_device *adev;\n\tint error;\n\n\tadev = ACPI_COMPANION(dev);\n\tif (!adev) {\n\t\tdev_dbg(dev, \"ACPI companion missing in %s!\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!acpi_device_can_wakeup(adev))\n\t\treturn -EINVAL;\n\n\tif (!enable) {\n\t\tacpi_device_wakeup_disable(adev);\n\t\tdev_dbg(dev, \"Wakeup disabled by ACPI\\n\");\n\t\treturn 0;\n\t}\n\n\terror = __acpi_device_wakeup_enable(adev, acpi_target_system_state());\n\tif (!error)\n\t\tdev_dbg(dev, \"Wakeup enabled by ACPI\\n\");\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(acpi_pm_set_device_wakeup);\n\n \nstatic int acpi_dev_pm_low_power(struct device *dev, struct acpi_device *adev,\n\t\t\t\t u32 system_state)\n{\n\tint ret, state;\n\n\tif (!acpi_device_power_manageable(adev))\n\t\treturn 0;\n\n\tret = acpi_dev_pm_get_state(dev, adev, system_state, NULL, &state);\n\treturn ret ? ret : acpi_device_set_power(adev, state);\n}\n\n \nstatic int acpi_dev_pm_full_power(struct acpi_device *adev)\n{\n\treturn acpi_device_power_manageable(adev) ?\n\t\tacpi_device_set_power(adev, ACPI_STATE_D0) : 0;\n}\n\n \nint acpi_dev_suspend(struct device *dev, bool wakeup)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tu32 target_state = acpi_target_system_state();\n\tint error;\n\n\tif (!adev)\n\t\treturn 0;\n\n\tif (wakeup && acpi_device_can_wakeup(adev)) {\n\t\terror = acpi_device_wakeup_enable(adev, target_state);\n\t\tif (error)\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\twakeup = false;\n\t}\n\n\terror = acpi_dev_pm_low_power(dev, adev, target_state);\n\tif (error && wakeup)\n\t\tacpi_device_wakeup_disable(adev);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(acpi_dev_suspend);\n\n \nint acpi_dev_resume(struct device *dev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tint error;\n\n\tif (!adev)\n\t\treturn 0;\n\n\terror = acpi_dev_pm_full_power(adev);\n\tacpi_device_wakeup_disable(adev);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(acpi_dev_resume);\n\n \nint acpi_subsys_runtime_suspend(struct device *dev)\n{\n\tint ret = pm_generic_runtime_suspend(dev);\n\n\treturn ret ? ret : acpi_dev_suspend(dev, true);\n}\nEXPORT_SYMBOL_GPL(acpi_subsys_runtime_suspend);\n\n \nint acpi_subsys_runtime_resume(struct device *dev)\n{\n\tint ret = acpi_dev_resume(dev);\n\n\treturn ret ? ret : pm_generic_runtime_resume(dev);\n}\nEXPORT_SYMBOL_GPL(acpi_subsys_runtime_resume);\n\n#ifdef CONFIG_PM_SLEEP\nstatic bool acpi_dev_needs_resume(struct device *dev, struct acpi_device *adev)\n{\n\tu32 sys_target = acpi_target_system_state();\n\tint ret, state;\n\n\tif (!pm_runtime_suspended(dev) || !adev || (adev->wakeup.flags.valid &&\n\t    device_may_wakeup(dev) != !!adev->wakeup.prepare_count))\n\t\treturn true;\n\n\tif (sys_target == ACPI_STATE_S0)\n\t\treturn false;\n\n\tif (adev->power.flags.dsw_present)\n\t\treturn true;\n\n\tret = acpi_dev_pm_get_state(dev, adev, sys_target, NULL, &state);\n\tif (ret)\n\t\treturn true;\n\n\treturn state != adev->power.state;\n}\n\n \nint acpi_subsys_prepare(struct device *dev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\n\tif (dev->driver && dev->driver->pm && dev->driver->pm->prepare) {\n\t\tint ret = dev->driver->pm->prepare(dev);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!ret && dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_PREPARE))\n\t\t\treturn 0;\n\t}\n\n\treturn !acpi_dev_needs_resume(dev, adev);\n}\nEXPORT_SYMBOL_GPL(acpi_subsys_prepare);\n\n \nvoid acpi_subsys_complete(struct device *dev)\n{\n\tpm_generic_complete(dev);\n\t \n\tif (pm_runtime_suspended(dev) && pm_resume_via_firmware())\n\t\tpm_request_resume(dev);\n}\nEXPORT_SYMBOL_GPL(acpi_subsys_complete);\n\n \nint acpi_subsys_suspend(struct device *dev)\n{\n\tif (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND) ||\n\t    acpi_dev_needs_resume(dev, ACPI_COMPANION(dev)))\n\t\tpm_runtime_resume(dev);\n\n\treturn pm_generic_suspend(dev);\n}\nEXPORT_SYMBOL_GPL(acpi_subsys_suspend);\n\n \nint acpi_subsys_suspend_late(struct device *dev)\n{\n\tint ret;\n\n\tif (dev_pm_skip_suspend(dev))\n\t\treturn 0;\n\n\tret = pm_generic_suspend_late(dev);\n\treturn ret ? ret : acpi_dev_suspend(dev, device_may_wakeup(dev));\n}\nEXPORT_SYMBOL_GPL(acpi_subsys_suspend_late);\n\n \nint acpi_subsys_suspend_noirq(struct device *dev)\n{\n\tint ret;\n\n\tif (dev_pm_skip_suspend(dev))\n\t\treturn 0;\n\n\tret = pm_generic_suspend_noirq(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (device_can_wakeup(dev) && !device_may_wakeup(dev))\n\t\tdev->power.may_skip_resume = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_subsys_suspend_noirq);\n\n \nstatic int acpi_subsys_resume_noirq(struct device *dev)\n{\n\tif (dev_pm_skip_resume(dev))\n\t\treturn 0;\n\n\treturn pm_generic_resume_noirq(dev);\n}\n\n \nstatic int acpi_subsys_resume_early(struct device *dev)\n{\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\tint ret;\n\n\tif (dev_pm_skip_resume(dev))\n\t\treturn 0;\n\n\tif (pm && !pm->resume_early) {\n\t\tdev_dbg(dev, \"postponing D0 transition to normal resume stage\\n\");\n\t\treturn 0;\n\t}\n\n\tret = acpi_dev_resume(dev);\n\treturn ret ? ret : pm_generic_resume_early(dev);\n}\n\n \nstatic int acpi_subsys_resume(struct device *dev)\n{\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\tint ret = 0;\n\n\tif (!dev_pm_skip_resume(dev) && pm && !pm->resume_early) {\n\t\tdev_dbg(dev, \"executing postponed D0 transition\\n\");\n\t\tret = acpi_dev_resume(dev);\n\t}\n\n\treturn ret ? ret : pm_generic_resume(dev);\n}\n\n \nint acpi_subsys_freeze(struct device *dev)\n{\n\t \n\tpm_runtime_resume(dev);\n\n\treturn pm_generic_freeze(dev);\n}\nEXPORT_SYMBOL_GPL(acpi_subsys_freeze);\n\n \nint acpi_subsys_restore_early(struct device *dev)\n{\n\tint ret = acpi_dev_resume(dev);\n\n\treturn ret ? ret : pm_generic_restore_early(dev);\n}\nEXPORT_SYMBOL_GPL(acpi_subsys_restore_early);\n\n \nint acpi_subsys_poweroff(struct device *dev)\n{\n\tif (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND) ||\n\t    acpi_dev_needs_resume(dev, ACPI_COMPANION(dev)))\n\t\tpm_runtime_resume(dev);\n\n\treturn pm_generic_poweroff(dev);\n}\nEXPORT_SYMBOL_GPL(acpi_subsys_poweroff);\n\n \nstatic int acpi_subsys_poweroff_late(struct device *dev)\n{\n\tint ret;\n\n\tif (dev_pm_skip_suspend(dev))\n\t\treturn 0;\n\n\tret = pm_generic_poweroff_late(dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn acpi_dev_suspend(dev, device_may_wakeup(dev));\n}\n\n \nstatic int acpi_subsys_poweroff_noirq(struct device *dev)\n{\n\tif (dev_pm_skip_suspend(dev))\n\t\treturn 0;\n\n\treturn pm_generic_poweroff_noirq(dev);\n}\n#endif  \n\nstatic struct dev_pm_domain acpi_general_pm_domain = {\n\t.ops = {\n\t\t.runtime_suspend = acpi_subsys_runtime_suspend,\n\t\t.runtime_resume = acpi_subsys_runtime_resume,\n#ifdef CONFIG_PM_SLEEP\n\t\t.prepare = acpi_subsys_prepare,\n\t\t.complete = acpi_subsys_complete,\n\t\t.suspend = acpi_subsys_suspend,\n\t\t.resume = acpi_subsys_resume,\n\t\t.suspend_late = acpi_subsys_suspend_late,\n\t\t.suspend_noirq = acpi_subsys_suspend_noirq,\n\t\t.resume_noirq = acpi_subsys_resume_noirq,\n\t\t.resume_early = acpi_subsys_resume_early,\n\t\t.freeze = acpi_subsys_freeze,\n\t\t.poweroff = acpi_subsys_poweroff,\n\t\t.poweroff_late = acpi_subsys_poweroff_late,\n\t\t.poweroff_noirq = acpi_subsys_poweroff_noirq,\n\t\t.restore_early = acpi_subsys_restore_early,\n#endif\n\t},\n};\n\n \nstatic void acpi_dev_pm_detach(struct device *dev, bool power_off)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\n\tif (adev && dev->pm_domain == &acpi_general_pm_domain) {\n\t\tdev_pm_domain_set(dev, NULL);\n\t\tacpi_remove_pm_notifier(adev);\n\t\tif (power_off) {\n\t\t\t \n\t\t\tdev_pm_qos_hide_latency_limit(dev);\n\t\t\tdev_pm_qos_hide_flags(dev);\n\t\t\tacpi_device_wakeup_disable(adev);\n\t\t\tacpi_dev_pm_low_power(dev, adev, ACPI_STATE_S0);\n\t\t}\n\t}\n}\n\n \nint acpi_dev_pm_attach(struct device *dev, bool power_on)\n{\n\t \n\tstatic const struct acpi_device_id special_pm_ids[] = {\n\t\tACPI_FAN_DEVICE_IDS,\n\t\t{}\n\t};\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\n\tif (!adev || !acpi_match_device_ids(adev, special_pm_ids))\n\t\treturn 0;\n\n\t \n\tif (!acpi_device_is_first_physical_node(adev, dev))\n\t\treturn 0;\n\n\tacpi_add_pm_notifier(adev, dev, acpi_pm_notify_work_func);\n\tdev_pm_domain_set(dev, &acpi_general_pm_domain);\n\tif (power_on) {\n\t\tacpi_dev_pm_full_power(adev);\n\t\tacpi_device_wakeup_disable(adev);\n\t}\n\n\tdev->pm_domain->detach = acpi_dev_pm_detach;\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(acpi_dev_pm_attach);\n\n \nbool acpi_storage_d3(struct device *dev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tu8 val;\n\n\tif (force_storage_d3())\n\t\treturn true;\n\n\tif (!adev)\n\t\treturn false;\n\tif (fwnode_property_read_u8(acpi_fwnode_handle(adev), \"StorageD3Enable\",\n\t\t\t&val))\n\t\treturn false;\n\treturn val == 1;\n}\nEXPORT_SYMBOL_GPL(acpi_storage_d3);\n\n \nbool acpi_dev_state_d0(struct device *dev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\n\tif (!adev)\n\t\treturn true;\n\n\treturn adev->power.state == ACPI_STATE_D0;\n}\nEXPORT_SYMBOL_GPL(acpi_dev_state_d0);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}