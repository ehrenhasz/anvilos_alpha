{
  "module_name": "pptt.c",
  "hash_id": "13240fd6dd5f20b3cfadf7b970d7e27d33b2f30c237010088fc69ca7e7fa4e2d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pptt.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"ACPI PPTT: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/cacheinfo.h>\n#include <acpi/processor.h>\n\nstatic struct acpi_subtable_header *fetch_pptt_subtable(struct acpi_table_header *table_hdr,\n\t\t\t\t\t\t\tu32 pptt_ref)\n{\n\tstruct acpi_subtable_header *entry;\n\n\t \n\tif (pptt_ref < sizeof(struct acpi_subtable_header))\n\t\treturn NULL;\n\n\tif (pptt_ref + sizeof(struct acpi_subtable_header) > table_hdr->length)\n\t\treturn NULL;\n\n\tentry = ACPI_ADD_PTR(struct acpi_subtable_header, table_hdr, pptt_ref);\n\n\tif (entry->length == 0)\n\t\treturn NULL;\n\n\tif (pptt_ref + entry->length > table_hdr->length)\n\t\treturn NULL;\n\n\treturn entry;\n}\n\nstatic struct acpi_pptt_processor *fetch_pptt_node(struct acpi_table_header *table_hdr,\n\t\t\t\t\t\t   u32 pptt_ref)\n{\n\treturn (struct acpi_pptt_processor *)fetch_pptt_subtable(table_hdr, pptt_ref);\n}\n\nstatic struct acpi_pptt_cache *fetch_pptt_cache(struct acpi_table_header *table_hdr,\n\t\t\t\t\t\tu32 pptt_ref)\n{\n\treturn (struct acpi_pptt_cache *)fetch_pptt_subtable(table_hdr, pptt_ref);\n}\n\nstatic struct acpi_subtable_header *acpi_get_pptt_resource(struct acpi_table_header *table_hdr,\n\t\t\t\t\t\t\t   struct acpi_pptt_processor *node,\n\t\t\t\t\t\t\t   int resource)\n{\n\tu32 *ref;\n\n\tif (resource >= node->number_of_priv_resources)\n\t\treturn NULL;\n\n\tref = ACPI_ADD_PTR(u32, node, sizeof(struct acpi_pptt_processor));\n\tref += resource;\n\n\treturn fetch_pptt_subtable(table_hdr, *ref);\n}\n\nstatic inline bool acpi_pptt_match_type(int table_type, int type)\n{\n\treturn ((table_type & ACPI_PPTT_MASK_CACHE_TYPE) == type ||\n\t\ttable_type & ACPI_PPTT_CACHE_TYPE_UNIFIED & type);\n}\n\n \nstatic unsigned int acpi_pptt_walk_cache(struct acpi_table_header *table_hdr,\n\t\t\t\t\t unsigned int local_level,\n\t\t\t\t\t unsigned int *split_levels,\n\t\t\t\t\t struct acpi_subtable_header *res,\n\t\t\t\t\t struct acpi_pptt_cache **found,\n\t\t\t\t\t unsigned int level, int type)\n{\n\tstruct acpi_pptt_cache *cache;\n\n\tif (res->type != ACPI_PPTT_TYPE_CACHE)\n\t\treturn 0;\n\n\tcache = (struct acpi_pptt_cache *) res;\n\twhile (cache) {\n\t\tlocal_level++;\n\n\t\tif (!(cache->flags & ACPI_PPTT_CACHE_TYPE_VALID)) {\n\t\t\tcache = fetch_pptt_cache(table_hdr, cache->next_level_of_cache);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (split_levels &&\n\t\t    (acpi_pptt_match_type(cache->attributes, ACPI_PPTT_CACHE_TYPE_DATA) ||\n\t\t     acpi_pptt_match_type(cache->attributes, ACPI_PPTT_CACHE_TYPE_INSTR)))\n\t\t\t*split_levels = local_level;\n\n\t\tif (local_level == level &&\n\t\t    acpi_pptt_match_type(cache->attributes, type)) {\n\t\t\tif (*found != NULL && cache != *found)\n\t\t\t\tpr_warn(\"Found duplicate cache level/type unable to determine uniqueness\\n\");\n\n\t\t\tpr_debug(\"Found cache @ level %u\\n\", level);\n\t\t\t*found = cache;\n\t\t\t \n\t\t}\n\t\tcache = fetch_pptt_cache(table_hdr, cache->next_level_of_cache);\n\t}\n\treturn local_level;\n}\n\nstatic struct acpi_pptt_cache *\nacpi_find_cache_level(struct acpi_table_header *table_hdr,\n\t\t      struct acpi_pptt_processor *cpu_node,\n\t\t      unsigned int *starting_level, unsigned int *split_levels,\n\t\t      unsigned int level, int type)\n{\n\tstruct acpi_subtable_header *res;\n\tunsigned int number_of_levels = *starting_level;\n\tint resource = 0;\n\tstruct acpi_pptt_cache *ret = NULL;\n\tunsigned int local_level;\n\n\t \n\twhile ((res = acpi_get_pptt_resource(table_hdr, cpu_node, resource))) {\n\t\tresource++;\n\n\t\tlocal_level = acpi_pptt_walk_cache(table_hdr, *starting_level,\n\t\t\t\t\t\t   split_levels, res, &ret,\n\t\t\t\t\t\t   level, type);\n\t\t \n\t\tif (number_of_levels < local_level)\n\t\t\tnumber_of_levels = local_level;\n\t}\n\tif (number_of_levels > *starting_level)\n\t\t*starting_level = number_of_levels;\n\n\treturn ret;\n}\n\n \nstatic void acpi_count_levels(struct acpi_table_header *table_hdr,\n\t\t\t      struct acpi_pptt_processor *cpu_node,\n\t\t\t      unsigned int *levels, unsigned int *split_levels)\n{\n\tdo {\n\t\tacpi_find_cache_level(table_hdr, cpu_node, levels, split_levels, 0, 0);\n\t\tcpu_node = fetch_pptt_node(table_hdr, cpu_node->parent);\n\t} while (cpu_node);\n}\n\n \nstatic int acpi_pptt_leaf_node(struct acpi_table_header *table_hdr,\n\t\t\t       struct acpi_pptt_processor *node)\n{\n\tstruct acpi_subtable_header *entry;\n\tunsigned long table_end;\n\tu32 node_entry;\n\tstruct acpi_pptt_processor *cpu_node;\n\tu32 proc_sz;\n\n\tif (table_hdr->revision > 1)\n\t\treturn (node->flags & ACPI_PPTT_ACPI_LEAF_NODE);\n\n\ttable_end = (unsigned long)table_hdr + table_hdr->length;\n\tnode_entry = ACPI_PTR_DIFF(node, table_hdr);\n\tentry = ACPI_ADD_PTR(struct acpi_subtable_header, table_hdr,\n\t\t\t     sizeof(struct acpi_table_pptt));\n\tproc_sz = sizeof(struct acpi_pptt_processor *);\n\n\twhile ((unsigned long)entry + proc_sz < table_end) {\n\t\tcpu_node = (struct acpi_pptt_processor *)entry;\n\t\tif (entry->type == ACPI_PPTT_TYPE_PROCESSOR &&\n\t\t    cpu_node->parent == node_entry)\n\t\t\treturn 0;\n\t\tif (entry->length == 0)\n\t\t\treturn 0;\n\t\tentry = ACPI_ADD_PTR(struct acpi_subtable_header, entry,\n\t\t\t\t     entry->length);\n\n\t}\n\treturn 1;\n}\n\n \nstatic struct acpi_pptt_processor *acpi_find_processor_node(struct acpi_table_header *table_hdr,\n\t\t\t\t\t\t\t    u32 acpi_cpu_id)\n{\n\tstruct acpi_subtable_header *entry;\n\tunsigned long table_end;\n\tstruct acpi_pptt_processor *cpu_node;\n\tu32 proc_sz;\n\n\ttable_end = (unsigned long)table_hdr + table_hdr->length;\n\tentry = ACPI_ADD_PTR(struct acpi_subtable_header, table_hdr,\n\t\t\t     sizeof(struct acpi_table_pptt));\n\tproc_sz = sizeof(struct acpi_pptt_processor *);\n\n\t \n\twhile ((unsigned long)entry + proc_sz < table_end) {\n\t\tcpu_node = (struct acpi_pptt_processor *)entry;\n\n\t\tif (entry->length == 0) {\n\t\t\tpr_warn(\"Invalid zero length subtable\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (entry->type == ACPI_PPTT_TYPE_PROCESSOR &&\n\t\t    acpi_cpu_id == cpu_node->acpi_processor_id &&\n\t\t     acpi_pptt_leaf_node(table_hdr, cpu_node)) {\n\t\t\treturn (struct acpi_pptt_processor *)entry;\n\t\t}\n\n\t\tentry = ACPI_ADD_PTR(struct acpi_subtable_header, entry,\n\t\t\t\t     entry->length);\n\t}\n\n\treturn NULL;\n}\n\nstatic u8 acpi_cache_type(enum cache_type type)\n{\n\tswitch (type) {\n\tcase CACHE_TYPE_DATA:\n\t\tpr_debug(\"Looking for data cache\\n\");\n\t\treturn ACPI_PPTT_CACHE_TYPE_DATA;\n\tcase CACHE_TYPE_INST:\n\t\tpr_debug(\"Looking for instruction cache\\n\");\n\t\treturn ACPI_PPTT_CACHE_TYPE_INSTR;\n\tdefault:\n\tcase CACHE_TYPE_UNIFIED:\n\t\tpr_debug(\"Looking for unified cache\\n\");\n\t\t \n\t\treturn ACPI_PPTT_CACHE_TYPE_UNIFIED;\n\t}\n}\n\nstatic struct acpi_pptt_cache *acpi_find_cache_node(struct acpi_table_header *table_hdr,\n\t\t\t\t\t\t    u32 acpi_cpu_id,\n\t\t\t\t\t\t    enum cache_type type,\n\t\t\t\t\t\t    unsigned int level,\n\t\t\t\t\t\t    struct acpi_pptt_processor **node)\n{\n\tunsigned int total_levels = 0;\n\tstruct acpi_pptt_cache *found = NULL;\n\tstruct acpi_pptt_processor *cpu_node;\n\tu8 acpi_type = acpi_cache_type(type);\n\n\tpr_debug(\"Looking for CPU %d's level %u cache type %d\\n\",\n\t\t acpi_cpu_id, level, acpi_type);\n\n\tcpu_node = acpi_find_processor_node(table_hdr, acpi_cpu_id);\n\n\twhile (cpu_node && !found) {\n\t\tfound = acpi_find_cache_level(table_hdr, cpu_node,\n\t\t\t\t\t      &total_levels, NULL, level, acpi_type);\n\t\t*node = cpu_node;\n\t\tcpu_node = fetch_pptt_node(table_hdr, cpu_node->parent);\n\t}\n\n\treturn found;\n}\n\n \nstatic void update_cache_properties(struct cacheinfo *this_leaf,\n\t\t\t\t    struct acpi_pptt_cache *found_cache,\n\t\t\t\t    struct acpi_pptt_processor *cpu_node,\n\t\t\t\t    u8 revision)\n{\n\tstruct acpi_pptt_cache_v1* found_cache_v1;\n\n\tthis_leaf->fw_token = cpu_node;\n\tif (found_cache->flags & ACPI_PPTT_SIZE_PROPERTY_VALID)\n\t\tthis_leaf->size = found_cache->size;\n\tif (found_cache->flags & ACPI_PPTT_LINE_SIZE_VALID)\n\t\tthis_leaf->coherency_line_size = found_cache->line_size;\n\tif (found_cache->flags & ACPI_PPTT_NUMBER_OF_SETS_VALID)\n\t\tthis_leaf->number_of_sets = found_cache->number_of_sets;\n\tif (found_cache->flags & ACPI_PPTT_ASSOCIATIVITY_VALID)\n\t\tthis_leaf->ways_of_associativity = found_cache->associativity;\n\tif (found_cache->flags & ACPI_PPTT_WRITE_POLICY_VALID) {\n\t\tswitch (found_cache->attributes & ACPI_PPTT_MASK_WRITE_POLICY) {\n\t\tcase ACPI_PPTT_CACHE_POLICY_WT:\n\t\t\tthis_leaf->attributes = CACHE_WRITE_THROUGH;\n\t\t\tbreak;\n\t\tcase ACPI_PPTT_CACHE_POLICY_WB:\n\t\t\tthis_leaf->attributes = CACHE_WRITE_BACK;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found_cache->flags & ACPI_PPTT_ALLOCATION_TYPE_VALID) {\n\t\tswitch (found_cache->attributes & ACPI_PPTT_MASK_ALLOCATION_TYPE) {\n\t\tcase ACPI_PPTT_CACHE_READ_ALLOCATE:\n\t\t\tthis_leaf->attributes |= CACHE_READ_ALLOCATE;\n\t\t\tbreak;\n\t\tcase ACPI_PPTT_CACHE_WRITE_ALLOCATE:\n\t\t\tthis_leaf->attributes |= CACHE_WRITE_ALLOCATE;\n\t\t\tbreak;\n\t\tcase ACPI_PPTT_CACHE_RW_ALLOCATE:\n\t\tcase ACPI_PPTT_CACHE_RW_ALLOCATE_ALT:\n\t\t\tthis_leaf->attributes |=\n\t\t\t\tCACHE_READ_ALLOCATE | CACHE_WRITE_ALLOCATE;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (this_leaf->type == CACHE_TYPE_NOCACHE &&\n\t    found_cache->flags & ACPI_PPTT_CACHE_TYPE_VALID)\n\t\tthis_leaf->type = CACHE_TYPE_UNIFIED;\n\n\tif (revision >= 3 && (found_cache->flags & ACPI_PPTT_CACHE_ID_VALID)) {\n\t\tfound_cache_v1 = ACPI_ADD_PTR(struct acpi_pptt_cache_v1,\n\t                                      found_cache, sizeof(struct acpi_pptt_cache));\n\t\tthis_leaf->id = found_cache_v1->cache_id;\n\t\tthis_leaf->attributes |= CACHE_ID;\n\t}\n}\n\nstatic void cache_setup_acpi_cpu(struct acpi_table_header *table,\n\t\t\t\t unsigned int cpu)\n{\n\tstruct acpi_pptt_cache *found_cache;\n\tstruct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);\n\tu32 acpi_cpu_id = get_acpi_id_for_cpu(cpu);\n\tstruct cacheinfo *this_leaf;\n\tunsigned int index = 0;\n\tstruct acpi_pptt_processor *cpu_node = NULL;\n\n\twhile (index < get_cpu_cacheinfo(cpu)->num_leaves) {\n\t\tthis_leaf = this_cpu_ci->info_list + index;\n\t\tfound_cache = acpi_find_cache_node(table, acpi_cpu_id,\n\t\t\t\t\t\t   this_leaf->type,\n\t\t\t\t\t\t   this_leaf->level,\n\t\t\t\t\t\t   &cpu_node);\n\t\tpr_debug(\"found = %p %p\\n\", found_cache, cpu_node);\n\t\tif (found_cache)\n\t\t\tupdate_cache_properties(this_leaf, found_cache,\n\t\t\t\t\t\tACPI_TO_POINTER(ACPI_PTR_DIFF(cpu_node, table)),\n\t\t\t\t\t\ttable->revision);\n\n\t\tindex++;\n\t}\n}\n\nstatic bool flag_identical(struct acpi_table_header *table_hdr,\n\t\t\t   struct acpi_pptt_processor *cpu)\n{\n\tstruct acpi_pptt_processor *next;\n\n\t \n\tif (table_hdr->revision < 2)\n\t\treturn false;\n\n\t \n\tif (cpu->flags & ACPI_PPTT_ACPI_IDENTICAL) {\n\t\tnext = fetch_pptt_node(table_hdr, cpu->parent);\n\t\tif (!(next && next->flags & ACPI_PPTT_ACPI_IDENTICAL))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \n#define PPTT_ABORT_PACKAGE 0xFF\n\nstatic struct acpi_pptt_processor *acpi_find_processor_tag(struct acpi_table_header *table_hdr,\n\t\t\t\t\t\t\t   struct acpi_pptt_processor *cpu,\n\t\t\t\t\t\t\t   int level, int flag)\n{\n\tstruct acpi_pptt_processor *prev_node;\n\n\twhile (cpu && level) {\n\t\t \n\t\tif (flag == ACPI_PPTT_ACPI_IDENTICAL) {\n\t\t\tif (flag_identical(table_hdr, cpu))\n\t\t\t\tbreak;\n\t\t} else if (cpu->flags & flag)\n\t\t\tbreak;\n\t\tpr_debug(\"level %d\\n\", level);\n\t\tprev_node = fetch_pptt_node(table_hdr, cpu->parent);\n\t\tif (prev_node == NULL)\n\t\t\tbreak;\n\t\tcpu = prev_node;\n\t\tlevel--;\n\t}\n\treturn cpu;\n}\n\nstatic void acpi_pptt_warn_missing(void)\n{\n\tpr_warn_once(\"No PPTT table found, CPU and cache topology may be inaccurate\\n\");\n}\n\n \nstatic int topology_get_acpi_cpu_tag(struct acpi_table_header *table,\n\t\t\t\t     unsigned int cpu, int level, int flag)\n{\n\tstruct acpi_pptt_processor *cpu_node;\n\tu32 acpi_cpu_id = get_acpi_id_for_cpu(cpu);\n\n\tcpu_node = acpi_find_processor_node(table, acpi_cpu_id);\n\tif (cpu_node) {\n\t\tcpu_node = acpi_find_processor_tag(table, cpu_node,\n\t\t\t\t\t\t   level, flag);\n\t\t \n\t\tif (level == 0 ||\n\t\t    cpu_node->flags & ACPI_PPTT_ACPI_PROCESSOR_ID_VALID)\n\t\t\treturn cpu_node->acpi_processor_id;\n\t\treturn ACPI_PTR_DIFF(cpu_node, table);\n\t}\n\tpr_warn_once(\"PPTT table found, but unable to locate core %d (%d)\\n\",\n\t\t    cpu, acpi_cpu_id);\n\treturn -ENOENT;\n}\n\n\nstatic struct acpi_table_header *acpi_get_pptt(void)\n{\n\tstatic struct acpi_table_header *pptt;\n\tstatic bool is_pptt_checked;\n\tacpi_status status;\n\n\t \n\tif (!pptt && !is_pptt_checked) {\n\t\tstatus = acpi_get_table(ACPI_SIG_PPTT, 0, &pptt);\n\t\tif (ACPI_FAILURE(status))\n\t\t\tacpi_pptt_warn_missing();\n\n\t\tis_pptt_checked = true;\n\t}\n\n\treturn pptt;\n}\n\nstatic int find_acpi_cpu_topology_tag(unsigned int cpu, int level, int flag)\n{\n\tstruct acpi_table_header *table;\n\tint retval;\n\n\ttable = acpi_get_pptt();\n\tif (!table)\n\t\treturn -ENOENT;\n\n\tretval = topology_get_acpi_cpu_tag(table, cpu, level, flag);\n\tpr_debug(\"Topology Setup ACPI CPU %d, level %d ret = %d\\n\",\n\t\t cpu, level, retval);\n\n\treturn retval;\n}\n\n \nstatic int check_acpi_cpu_flag(unsigned int cpu, int rev, u32 flag)\n{\n\tstruct acpi_table_header *table;\n\tu32 acpi_cpu_id = get_acpi_id_for_cpu(cpu);\n\tstruct acpi_pptt_processor *cpu_node = NULL;\n\tint ret = -ENOENT;\n\n\ttable = acpi_get_pptt();\n\tif (!table)\n\t\treturn -ENOENT;\n\n\tif (table->revision >= rev)\n\t\tcpu_node = acpi_find_processor_node(table, acpi_cpu_id);\n\n\tif (cpu_node)\n\t\tret = (cpu_node->flags & flag) != 0;\n\n\treturn ret;\n}\n\n \nint acpi_get_cache_info(unsigned int cpu, unsigned int *levels,\n\t\t\tunsigned int *split_levels)\n{\n\tstruct acpi_pptt_processor *cpu_node;\n\tstruct acpi_table_header *table;\n\tu32 acpi_cpu_id;\n\n\t*levels = 0;\n\tif (split_levels)\n\t\t*split_levels = 0;\n\n\ttable = acpi_get_pptt();\n\tif (!table)\n\t\treturn -ENOENT;\n\n\tpr_debug(\"Cache Setup: find cache levels for CPU=%d\\n\", cpu);\n\n\tacpi_cpu_id = get_acpi_id_for_cpu(cpu);\n\tcpu_node = acpi_find_processor_node(table, acpi_cpu_id);\n\tif (!cpu_node)\n\t\treturn -ENOENT;\n\n\tacpi_count_levels(table, cpu_node, levels, split_levels);\n\n\tpr_debug(\"Cache Setup: last_level=%d split_levels=%d\\n\",\n\t\t *levels, split_levels ? *split_levels : -1);\n\n\treturn 0;\n}\n\n \nint cache_setup_acpi(unsigned int cpu)\n{\n\tstruct acpi_table_header *table;\n\n\ttable = acpi_get_pptt();\n\tif (!table)\n\t\treturn -ENOENT;\n\n\tpr_debug(\"Cache Setup ACPI CPU %d\\n\", cpu);\n\n\tcache_setup_acpi_cpu(table, cpu);\n\n\treturn 0;\n}\n\n \nint acpi_pptt_cpu_is_thread(unsigned int cpu)\n{\n\treturn check_acpi_cpu_flag(cpu, 2, ACPI_PPTT_ACPI_PROCESSOR_IS_THREAD);\n}\n\n \nint find_acpi_cpu_topology(unsigned int cpu, int level)\n{\n\treturn find_acpi_cpu_topology_tag(cpu, level, 0);\n}\n\n \nint find_acpi_cpu_topology_package(unsigned int cpu)\n{\n\treturn find_acpi_cpu_topology_tag(cpu, PPTT_ABORT_PACKAGE,\n\t\t\t\t\t  ACPI_PPTT_PHYSICAL_PACKAGE);\n}\n\n \n\nint find_acpi_cpu_topology_cluster(unsigned int cpu)\n{\n\tstruct acpi_table_header *table;\n\tstruct acpi_pptt_processor *cpu_node, *cluster_node;\n\tu32 acpi_cpu_id;\n\tint retval;\n\tint is_thread;\n\n\ttable = acpi_get_pptt();\n\tif (!table)\n\t\treturn -ENOENT;\n\n\tacpi_cpu_id = get_acpi_id_for_cpu(cpu);\n\tcpu_node = acpi_find_processor_node(table, acpi_cpu_id);\n\tif (!cpu_node || !cpu_node->parent)\n\t\treturn -ENOENT;\n\n\tis_thread = cpu_node->flags & ACPI_PPTT_ACPI_PROCESSOR_IS_THREAD;\n\tcluster_node = fetch_pptt_node(table, cpu_node->parent);\n\tif (!cluster_node)\n\t\treturn -ENOENT;\n\n\tif (is_thread) {\n\t\tif (!cluster_node->parent)\n\t\t\treturn -ENOENT;\n\n\t\tcluster_node = fetch_pptt_node(table, cluster_node->parent);\n\t\tif (!cluster_node)\n\t\t\treturn -ENOENT;\n\t}\n\tif (cluster_node->flags & ACPI_PPTT_ACPI_PROCESSOR_ID_VALID)\n\t\tretval = cluster_node->acpi_processor_id;\n\telse\n\t\tretval = ACPI_PTR_DIFF(cluster_node, table);\n\n\treturn retval;\n}\n\n \nint find_acpi_cpu_topology_hetero_id(unsigned int cpu)\n{\n\treturn find_acpi_cpu_topology_tag(cpu, PPTT_ABORT_PACKAGE,\n\t\t\t\t\t  ACPI_PPTT_ACPI_IDENTICAL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}