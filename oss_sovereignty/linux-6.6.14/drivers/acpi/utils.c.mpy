{
  "module_name": "utils.c",
  "hash_id": "e915a0d59a1631efcfa6bc477c3ab54bbd407511981b2a704428c0691b41df09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/utils.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: utils: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n#include <linux/acpi.h>\n#include <linux/dynamic_debug.h>\n\n#include \"internal.h\"\n#include \"sleep.h\"\n\n \nstatic void acpi_util_eval_error(acpi_handle h, acpi_string p, acpi_status s)\n{\n\tacpi_handle_debug(h, \"Evaluate [%s]: %s\\n\", p, acpi_format_exception(s));\n}\n\nacpi_status\nacpi_extract_package(union acpi_object *package,\n\t\t     struct acpi_buffer *format, struct acpi_buffer *buffer)\n{\n\tu32 size_required = 0;\n\tu32 tail_offset = 0;\n\tchar *format_string = NULL;\n\tu32 format_count = 0;\n\tu32 i = 0;\n\tu8 *head = NULL;\n\tu8 *tail = NULL;\n\n\n\tif (!package || (package->type != ACPI_TYPE_PACKAGE)\n\t    || (package->package.count < 1)) {\n\t\tpr_debug(\"Invalid package argument\\n\");\n\t\treturn AE_BAD_PARAMETER;\n\t}\n\n\tif (!format || !format->pointer || (format->length < 1)) {\n\t\tpr_debug(\"Invalid format argument\\n\");\n\t\treturn AE_BAD_PARAMETER;\n\t}\n\n\tif (!buffer) {\n\t\tpr_debug(\"Invalid buffer argument\\n\");\n\t\treturn AE_BAD_PARAMETER;\n\t}\n\n\tformat_count = (format->length / sizeof(char)) - 1;\n\tif (format_count > package->package.count) {\n\t\tpr_debug(\"Format specifies more objects [%d] than present [%d]\\n\",\n\t\t\t format_count, package->package.count);\n\t\treturn AE_BAD_DATA;\n\t}\n\n\tformat_string = format->pointer;\n\n\t \n\tfor (i = 0; i < format_count; i++) {\n\n\t\tunion acpi_object *element = &(package->package.elements[i]);\n\n\t\tswitch (element->type) {\n\n\t\tcase ACPI_TYPE_INTEGER:\n\t\t\tswitch (format_string[i]) {\n\t\t\tcase 'N':\n\t\t\t\tsize_required += sizeof(u64);\n\t\t\t\ttail_offset += sizeof(u64);\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tsize_required +=\n\t\t\t\t    sizeof(char *) + sizeof(u64) +\n\t\t\t\t    sizeof(char);\n\t\t\t\ttail_offset += sizeof(char *);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_debug(\"Invalid package element [%d]: got number, expected [%c]\\n\",\n\t\t\t\t\t i, format_string[i]);\n\t\t\t\treturn AE_BAD_DATA;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_STRING:\n\t\tcase ACPI_TYPE_BUFFER:\n\t\t\tswitch (format_string[i]) {\n\t\t\tcase 'S':\n\t\t\t\tsize_required +=\n\t\t\t\t    sizeof(char *) +\n\t\t\t\t    (element->string.length * sizeof(char)) +\n\t\t\t\t    sizeof(char);\n\t\t\t\ttail_offset += sizeof(char *);\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\tsize_required +=\n\t\t\t\t    sizeof(u8 *) + element->buffer.length;\n\t\t\t\ttail_offset += sizeof(u8 *);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_debug(\"Invalid package element [%d] got string/buffer, expected [%c]\\n\",\n\t\t\t\t\t i, format_string[i]);\n\t\t\t\treturn AE_BAD_DATA;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\t\t\tswitch (format_string[i]) {\n\t\t\tcase 'R':\n\t\t\t\tsize_required += sizeof(void *);\n\t\t\t\ttail_offset += sizeof(void *);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_debug(\"Invalid package element [%d] got reference, expected [%c]\\n\",\n\t\t\t\t\t i, format_string[i]);\n\t\t\t\treturn AE_BAD_DATA;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_PACKAGE:\n\t\tdefault:\n\t\t\tpr_debug(\"Unsupported element at index=%d\\n\", i);\n\t\t\t \n\t\t\treturn AE_SUPPORT;\n\t\t}\n\t}\n\n\t \n\tif (buffer->length == ACPI_ALLOCATE_BUFFER) {\n\t\tbuffer->pointer = ACPI_ALLOCATE_ZEROED(size_required);\n\t\tif (!buffer->pointer)\n\t\t\treturn AE_NO_MEMORY;\n\t\tbuffer->length = size_required;\n\t} else {\n\t\tif (buffer->length < size_required) {\n\t\t\tbuffer->length = size_required;\n\t\t\treturn AE_BUFFER_OVERFLOW;\n\t\t} else if (buffer->length != size_required ||\n\t\t\t   !buffer->pointer) {\n\t\t\treturn AE_BAD_PARAMETER;\n\t\t}\n\t}\n\n\thead = buffer->pointer;\n\ttail = buffer->pointer + tail_offset;\n\n\t \n\tfor (i = 0; i < format_count; i++) {\n\n\t\tu8 **pointer = NULL;\n\t\tunion acpi_object *element = &(package->package.elements[i]);\n\n\t\tswitch (element->type) {\n\n\t\tcase ACPI_TYPE_INTEGER:\n\t\t\tswitch (format_string[i]) {\n\t\t\tcase 'N':\n\t\t\t\t*((u64 *) head) =\n\t\t\t\t    element->integer.value;\n\t\t\t\thead += sizeof(u64);\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tpointer = (u8 **) head;\n\t\t\t\t*pointer = tail;\n\t\t\t\t*((u64 *) tail) =\n\t\t\t\t    element->integer.value;\n\t\t\t\thead += sizeof(u64 *);\n\t\t\t\ttail += sizeof(u64);\n\t\t\t\t \n\t\t\t\t*tail = (char)0;\n\t\t\t\ttail += sizeof(char);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_STRING:\n\t\tcase ACPI_TYPE_BUFFER:\n\t\t\tswitch (format_string[i]) {\n\t\t\tcase 'S':\n\t\t\t\tpointer = (u8 **) head;\n\t\t\t\t*pointer = tail;\n\t\t\t\tmemcpy(tail, element->string.pointer,\n\t\t\t\t       element->string.length);\n\t\t\t\thead += sizeof(char *);\n\t\t\t\ttail += element->string.length * sizeof(char);\n\t\t\t\t \n\t\t\t\t*tail = (char)0;\n\t\t\t\ttail += sizeof(char);\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\tpointer = (u8 **) head;\n\t\t\t\t*pointer = tail;\n\t\t\t\tmemcpy(tail, element->buffer.pointer,\n\t\t\t\t       element->buffer.length);\n\t\t\t\thead += sizeof(u8 *);\n\t\t\t\ttail += element->buffer.length;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\t\t\tswitch (format_string[i]) {\n\t\t\tcase 'R':\n\t\t\t\t*(void **)head =\n\t\t\t\t    (void *)element->reference.handle;\n\t\t\t\thead += sizeof(void *);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACPI_TYPE_PACKAGE:\n\t\t\t \n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn AE_OK;\n}\n\nEXPORT_SYMBOL(acpi_extract_package);\n\nacpi_status\nacpi_evaluate_integer(acpi_handle handle,\n\t\t      acpi_string pathname,\n\t\t      struct acpi_object_list *arguments, unsigned long long *data)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_object element;\n\tstruct acpi_buffer buffer = { 0, NULL };\n\n\tif (!data)\n\t\treturn AE_BAD_PARAMETER;\n\n\tbuffer.length = sizeof(union acpi_object);\n\tbuffer.pointer = &element;\n\tstatus = acpi_evaluate_object(handle, pathname, arguments, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_util_eval_error(handle, pathname, status);\n\t\treturn status;\n\t}\n\n\tif (element.type != ACPI_TYPE_INTEGER) {\n\t\tacpi_util_eval_error(handle, pathname, AE_BAD_DATA);\n\t\treturn AE_BAD_DATA;\n\t}\n\n\t*data = element.integer.value;\n\n\tacpi_handle_debug(handle, \"Return value [%llu]\\n\", *data);\n\n\treturn AE_OK;\n}\n\nEXPORT_SYMBOL(acpi_evaluate_integer);\n\nint acpi_get_local_address(acpi_handle handle, u32 *addr)\n{\n\tunsigned long long adr;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL, &adr);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODATA;\n\n\t*addr = (u32)adr;\n\treturn 0;\n}\nEXPORT_SYMBOL(acpi_get_local_address);\n\n#define ACPI_MAX_SUB_BUF_SIZE\t9\n\nconst char *acpi_get_subsystem_id(acpi_handle handle)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tconst char *sub;\n\tsize_t len;\n\n\tstatus = acpi_evaluate_object(handle, METHOD_NAME__SUB, NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_debug(handle, \"Reading ACPI _SUB failed: %#x\\n\", status);\n\t\treturn ERR_PTR(-ENODATA);\n\t}\n\n\tobj = buffer.pointer;\n\tif (obj->type == ACPI_TYPE_STRING) {\n\t\tlen = strlen(obj->string.pointer);\n\t\tif (len < ACPI_MAX_SUB_BUF_SIZE && len > 0) {\n\t\t\tsub = kstrdup(obj->string.pointer, GFP_KERNEL);\n\t\t\tif (!sub)\n\t\t\t\tsub = ERR_PTR(-ENOMEM);\n\t\t} else {\n\t\t\tacpi_handle_err(handle, \"ACPI _SUB Length %zu is Invalid\\n\", len);\n\t\t\tsub = ERR_PTR(-ENODATA);\n\t\t}\n\t} else {\n\t\tacpi_handle_warn(handle, \"Warning ACPI _SUB did not return a string\\n\");\n\t\tsub = ERR_PTR(-ENODATA);\n\t}\n\n\tacpi_os_free(buffer.pointer);\n\n\treturn sub;\n}\nEXPORT_SYMBOL_GPL(acpi_get_subsystem_id);\n\nacpi_status\nacpi_evaluate_reference(acpi_handle handle,\n\t\t\tacpi_string pathname,\n\t\t\tstruct acpi_object_list *arguments,\n\t\t\tstruct acpi_handle_list *list)\n{\n\tacpi_status status = AE_OK;\n\tunion acpi_object *package = NULL;\n\tunion acpi_object *element = NULL;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tu32 i = 0;\n\n\n\tif (!list) {\n\t\treturn AE_BAD_PARAMETER;\n\t}\n\n\t \n\n\tstatus = acpi_evaluate_object(handle, pathname, arguments, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\tgoto end;\n\n\tpackage = buffer.pointer;\n\n\tif ((buffer.length == 0) || !package) {\n\t\tstatus = AE_BAD_DATA;\n\t\tacpi_util_eval_error(handle, pathname, status);\n\t\tgoto end;\n\t}\n\tif (package->type != ACPI_TYPE_PACKAGE) {\n\t\tstatus = AE_BAD_DATA;\n\t\tacpi_util_eval_error(handle, pathname, status);\n\t\tgoto end;\n\t}\n\tif (!package->package.count) {\n\t\tstatus = AE_BAD_DATA;\n\t\tacpi_util_eval_error(handle, pathname, status);\n\t\tgoto end;\n\t}\n\n\tif (package->package.count > ACPI_MAX_HANDLES) {\n\t\tkfree(package);\n\t\treturn AE_NO_MEMORY;\n\t}\n\tlist->count = package->package.count;\n\n\t \n\n\tfor (i = 0; i < list->count; i++) {\n\n\t\telement = &(package->package.elements[i]);\n\n\t\tif (element->type != ACPI_TYPE_LOCAL_REFERENCE) {\n\t\t\tstatus = AE_BAD_DATA;\n\t\t\tacpi_util_eval_error(handle, pathname, status);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!element->reference.handle) {\n\t\t\tstatus = AE_NULL_ENTRY;\n\t\t\tacpi_util_eval_error(handle, pathname, status);\n\t\t\tbreak;\n\t\t}\n\t\t \n\n\t\tlist->handles[i] = element->reference.handle;\n\t\tacpi_handle_debug(list->handles[i], \"Found in reference list\\n\");\n\t}\n\n      end:\n\tif (ACPI_FAILURE(status)) {\n\t\tlist->count = 0;\n\t\t\n\t}\n\n\tkfree(buffer.pointer);\n\n\treturn status;\n}\n\nEXPORT_SYMBOL(acpi_evaluate_reference);\n\nacpi_status\nacpi_get_physical_device_location(acpi_handle handle, struct acpi_pld_info **pld)\n{\n\tacpi_status status;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *output;\n\n\tstatus = acpi_evaluate_object(handle, \"_PLD\", NULL, &buffer);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\toutput = buffer.pointer;\n\n\tif (!output || output->type != ACPI_TYPE_PACKAGE\n\t    || !output->package.count\n\t    || output->package.elements[0].type != ACPI_TYPE_BUFFER\n\t    || output->package.elements[0].buffer.length < ACPI_PLD_REV1_BUFFER_SIZE) {\n\t\tstatus = AE_TYPE;\n\t\tgoto out;\n\t}\n\n\tstatus = acpi_decode_pld_buffer(\n\t\t\toutput->package.elements[0].buffer.pointer,\n\t\t\toutput->package.elements[0].buffer.length,\n\t\t\tpld);\n\nout:\n\tkfree(buffer.pointer);\n\treturn status;\n}\nEXPORT_SYMBOL(acpi_get_physical_device_location);\n\n \nacpi_status\nacpi_evaluate_ost(acpi_handle handle, u32 source_event, u32 status_code,\n\t\t  struct acpi_buffer *status_buf)\n{\n\tunion acpi_object params[3] = {\n\t\t{.type = ACPI_TYPE_INTEGER,},\n\t\t{.type = ACPI_TYPE_INTEGER,},\n\t\t{.type = ACPI_TYPE_BUFFER,}\n\t};\n\tstruct acpi_object_list arg_list = {3, params};\n\n\tparams[0].integer.value = source_event;\n\tparams[1].integer.value = status_code;\n\tif (status_buf != NULL) {\n\t\tparams[2].buffer.pointer = status_buf->pointer;\n\t\tparams[2].buffer.length = status_buf->length;\n\t} else {\n\t\tparams[2].buffer.pointer = NULL;\n\t\tparams[2].buffer.length = 0;\n\t}\n\n\treturn acpi_evaluate_object(handle, \"_OST\", &arg_list, NULL);\n}\nEXPORT_SYMBOL(acpi_evaluate_ost);\n\n \nstatic char *acpi_handle_path(acpi_handle handle)\n{\n\tstruct acpi_buffer buffer = {\n\t\t.length = ACPI_ALLOCATE_BUFFER,\n\t\t.pointer = NULL\n\t};\n\n\tif (in_interrupt() ||\n\t    acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer) != AE_OK)\n\t\treturn NULL;\n\treturn buffer.pointer;\n}\n\n \nvoid\nacpi_handle_printk(const char *level, acpi_handle handle, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *path;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpath = acpi_handle_path(handle);\n\tprintk(\"%sACPI: %s: %pV\", level, path ? path : \"<n/a>\" , &vaf);\n\n\tva_end(args);\n\tkfree(path);\n}\nEXPORT_SYMBOL(acpi_handle_printk);\n\n#if defined(CONFIG_DYNAMIC_DEBUG)\n \nvoid\n__acpi_handle_debug(struct _ddebug *descriptor, acpi_handle handle,\n\t\t    const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *path;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpath = acpi_handle_path(handle);\n\t__dynamic_pr_debug(descriptor, \"ACPI: %s: %pV\", path ? path : \"<n/a>\", &vaf);\n\n\tva_end(args);\n\tkfree(path);\n}\nEXPORT_SYMBOL(__acpi_handle_debug);\n#endif\n\n \nvoid acpi_evaluation_failure_warn(acpi_handle handle, const char *name,\n\t\t\t\t  acpi_status status)\n{\n\tacpi_handle_warn(handle, \"%s evaluation failed: %s\\n\", name,\n\t\t\t acpi_format_exception(status));\n}\nEXPORT_SYMBOL_GPL(acpi_evaluation_failure_warn);\n\n \nbool acpi_has_method(acpi_handle handle, char *name)\n{\n\tacpi_handle tmp;\n\n\treturn ACPI_SUCCESS(acpi_get_handle(handle, name, &tmp));\n}\nEXPORT_SYMBOL(acpi_has_method);\n\nacpi_status acpi_execute_simple_method(acpi_handle handle, char *method,\n\t\t\t\t       u64 arg)\n{\n\tunion acpi_object obj = { .type = ACPI_TYPE_INTEGER };\n\tstruct acpi_object_list arg_list = { .count = 1, .pointer = &obj, };\n\n\tobj.integer.value = arg;\n\n\treturn acpi_evaluate_object(handle, method, &arg_list, NULL);\n}\nEXPORT_SYMBOL(acpi_execute_simple_method);\n\n \nacpi_status acpi_evaluate_ej0(acpi_handle handle)\n{\n\tacpi_status status;\n\n\tstatus = acpi_execute_simple_method(handle, \"_EJ0\", 1);\n\tif (status == AE_NOT_FOUND)\n\t\tacpi_handle_warn(handle, \"No _EJ0 support for device\\n\");\n\telse if (ACPI_FAILURE(status))\n\t\tacpi_handle_warn(handle, \"Eject failed (0x%x)\\n\", status);\n\n\treturn status;\n}\n\n \nacpi_status acpi_evaluate_lck(acpi_handle handle, int lock)\n{\n\tacpi_status status;\n\n\tstatus = acpi_execute_simple_method(handle, \"_LCK\", !!lock);\n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\n\t\tif (lock)\n\t\t\tacpi_handle_warn(handle,\n\t\t\t\t\"Locking device failed (0x%x)\\n\", status);\n\t\telse\n\t\t\tacpi_handle_warn(handle,\n\t\t\t\t\"Unlocking device failed (0x%x)\\n\", status);\n\t}\n\n\treturn status;\n}\n\n \nacpi_status acpi_evaluate_reg(acpi_handle handle, u8 space_id, u32 function)\n{\n\tstruct acpi_object_list arg_list;\n\tunion acpi_object params[2];\n\n\tparams[0].type = ACPI_TYPE_INTEGER;\n\tparams[0].integer.value = space_id;\n\tparams[1].type = ACPI_TYPE_INTEGER;\n\tparams[1].integer.value = function;\n\targ_list.count = 2;\n\targ_list.pointer = params;\n\n\treturn acpi_evaluate_object(handle, \"_REG\", &arg_list, NULL);\n}\nEXPORT_SYMBOL(acpi_evaluate_reg);\n\n \nunion acpi_object *\nacpi_evaluate_dsm(acpi_handle handle, const guid_t *guid, u64 rev, u64 func,\n\t\t  union acpi_object *argv4)\n{\n\tacpi_status ret;\n\tstruct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};\n\tunion acpi_object params[4];\n\tstruct acpi_object_list input = {\n\t\t.count = 4,\n\t\t.pointer = params,\n\t};\n\n\tparams[0].type = ACPI_TYPE_BUFFER;\n\tparams[0].buffer.length = 16;\n\tparams[0].buffer.pointer = (u8 *)guid;\n\tparams[1].type = ACPI_TYPE_INTEGER;\n\tparams[1].integer.value = rev;\n\tparams[2].type = ACPI_TYPE_INTEGER;\n\tparams[2].integer.value = func;\n\tif (argv4) {\n\t\tparams[3] = *argv4;\n\t} else {\n\t\tparams[3].type = ACPI_TYPE_PACKAGE;\n\t\tparams[3].package.count = 0;\n\t\tparams[3].package.elements = NULL;\n\t}\n\n\tret = acpi_evaluate_object(handle, \"_DSM\", &input, &buf);\n\tif (ACPI_SUCCESS(ret))\n\t\treturn (union acpi_object *)buf.pointer;\n\n\tif (ret != AE_NOT_FOUND)\n\t\tacpi_handle_warn(handle,\n\t\t\t\t \"failed to evaluate _DSM %pUb (0x%x)\\n\", guid, ret);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(acpi_evaluate_dsm);\n\n \nbool acpi_check_dsm(acpi_handle handle, const guid_t *guid, u64 rev, u64 funcs)\n{\n\tint i;\n\tu64 mask = 0;\n\tunion acpi_object *obj;\n\n\tif (funcs == 0)\n\t\treturn false;\n\n\tobj = acpi_evaluate_dsm(handle, guid, rev, 0, NULL);\n\tif (!obj)\n\t\treturn false;\n\n\t \n\tif (obj->type == ACPI_TYPE_INTEGER)\n\t\tmask = obj->integer.value;\n\telse if (obj->type == ACPI_TYPE_BUFFER)\n\t\tfor (i = 0; i < obj->buffer.length && i < 8; i++)\n\t\t\tmask |= (((u64)obj->buffer.pointer[i]) << (i * 8));\n\tACPI_FREE(obj);\n\n\t \n\tif ((mask & 0x1) && (mask & funcs) == funcs)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(acpi_check_dsm);\n\n \nbool acpi_dev_hid_uid_match(struct acpi_device *adev,\n\t\t\t    const char *hid2, const char *uid2)\n{\n\tconst char *hid1 = acpi_device_hid(adev);\n\tconst char *uid1 = acpi_device_uid(adev);\n\n\tif (strcmp(hid1, hid2))\n\t\treturn false;\n\n\tif (!uid2)\n\t\treturn true;\n\n\treturn uid1 && !strcmp(uid1, uid2);\n}\nEXPORT_SYMBOL(acpi_dev_hid_uid_match);\n\n \nint acpi_dev_uid_to_integer(struct acpi_device *adev, u64 *integer)\n{\n\tconst char *uid;\n\n\tif (!adev)\n\t\treturn -ENODEV;\n\n\tuid = acpi_device_uid(adev);\n\tif (!uid)\n\t\treturn -ENODATA;\n\n\treturn kstrtou64(uid, 0, integer);\n}\nEXPORT_SYMBOL(acpi_dev_uid_to_integer);\n\n \nbool acpi_dev_found(const char *hid)\n{\n\tstruct acpi_device_bus_id *acpi_device_bus_id;\n\tbool found = false;\n\n\tmutex_lock(&acpi_device_lock);\n\tlist_for_each_entry(acpi_device_bus_id, &acpi_bus_id_list, node)\n\t\tif (!strcmp(acpi_device_bus_id->bus_id, hid)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&acpi_device_lock);\n\n\treturn found;\n}\nEXPORT_SYMBOL(acpi_dev_found);\n\nstruct acpi_dev_match_info {\n\tstruct acpi_device_id hid[2];\n\tconst char *uid;\n\ts64 hrv;\n};\n\nstatic int acpi_dev_match_cb(struct device *dev, const void *data)\n{\n\tstruct acpi_device *adev = to_acpi_device(dev);\n\tconst struct acpi_dev_match_info *match = data;\n\tunsigned long long hrv;\n\tacpi_status status;\n\n\tif (acpi_match_device_ids(adev, match->hid))\n\t\treturn 0;\n\n\tif (match->uid && (!adev->pnp.unique_id ||\n\t    strcmp(adev->pnp.unique_id, match->uid)))\n\t\treturn 0;\n\n\tif (match->hrv == -1)\n\t\treturn 1;\n\n\tstatus = acpi_evaluate_integer(adev->handle, \"_HRV\", NULL, &hrv);\n\tif (ACPI_FAILURE(status))\n\t\treturn 0;\n\n\treturn hrv == match->hrv;\n}\n\n \nbool acpi_dev_present(const char *hid, const char *uid, s64 hrv)\n{\n\tstruct acpi_dev_match_info match = {};\n\tstruct device *dev;\n\n\tstrscpy(match.hid[0].id, hid, sizeof(match.hid[0].id));\n\tmatch.uid = uid;\n\tmatch.hrv = hrv;\n\n\tdev = bus_find_device(&acpi_bus_type, NULL, &match, acpi_dev_match_cb);\n\tput_device(dev);\n\treturn !!dev;\n}\nEXPORT_SYMBOL(acpi_dev_present);\n\n \nstruct acpi_device *\nacpi_dev_get_next_match_dev(struct acpi_device *adev, const char *hid, const char *uid, s64 hrv)\n{\n\tstruct device *start = adev ? &adev->dev : NULL;\n\tstruct acpi_dev_match_info match = {};\n\tstruct device *dev;\n\n\tstrscpy(match.hid[0].id, hid, sizeof(match.hid[0].id));\n\tmatch.uid = uid;\n\tmatch.hrv = hrv;\n\n\tdev = bus_find_device(&acpi_bus_type, start, &match, acpi_dev_match_cb);\n\tacpi_dev_put(adev);\n\treturn dev ? to_acpi_device(dev) : NULL;\n}\nEXPORT_SYMBOL(acpi_dev_get_next_match_dev);\n\n \nstruct acpi_device *\nacpi_dev_get_first_match_dev(const char *hid, const char *uid, s64 hrv)\n{\n\treturn acpi_dev_get_next_match_dev(NULL, hid, uid, hrv);\n}\nEXPORT_SYMBOL(acpi_dev_get_first_match_dev);\n\n \nbool acpi_reduced_hardware(void)\n{\n\treturn acpi_gbl_reduced_hardware;\n}\nEXPORT_SYMBOL_GPL(acpi_reduced_hardware);\n\n \nchar acpi_video_backlight_string[16];\nEXPORT_SYMBOL(acpi_video_backlight_string);\n\nstatic int __init acpi_backlight(char *str)\n{\n\tstrscpy(acpi_video_backlight_string, str,\n\t\tsizeof(acpi_video_backlight_string));\n\treturn 1;\n}\n__setup(\"acpi_backlight=\", acpi_backlight);\n\n \nint acpi_match_platform_list(const struct acpi_platform_list *plat)\n{\n\tstruct acpi_table_header hdr;\n\tint idx = 0;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\tfor (; plat->oem_id[0]; plat++, idx++) {\n\t\tif (ACPI_FAILURE(acpi_get_table_header(plat->table, 0, &hdr)))\n\t\t\tcontinue;\n\n\t\tif (strncmp(plat->oem_id, hdr.oem_id, ACPI_OEM_ID_SIZE))\n\t\t\tcontinue;\n\n\t\tif (strncmp(plat->oem_table_id, hdr.oem_table_id, ACPI_OEM_TABLE_ID_SIZE))\n\t\t\tcontinue;\n\n\t\tif ((plat->pred == all_versions) ||\n\t\t    (plat->pred == less_than_or_equal && hdr.oem_revision <= plat->oem_revision) ||\n\t\t    (plat->pred == greater_than_or_equal && hdr.oem_revision >= plat->oem_revision) ||\n\t\t    (plat->pred == equal && hdr.oem_revision == plat->oem_revision))\n\t\t\treturn idx;\n\t}\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL(acpi_match_platform_list);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}