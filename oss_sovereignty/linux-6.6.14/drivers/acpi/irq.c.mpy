{
  "module_name": "irq.c",
  "hash_id": "250d782b224468f343ab305c66947eff6142bdc8422afcbec9283e587e8414b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/irq.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n\nenum acpi_irq_model_id acpi_irq_model;\n\nstatic struct fwnode_handle *(*acpi_get_gsi_domain_id)(u32 gsi);\nstatic u32 (*acpi_gsi_to_irq_fallback)(u32 gsi);\n\n \nint acpi_gsi_to_irq(u32 gsi, unsigned int *irq)\n{\n\tstruct irq_domain *d;\n\n\td = irq_find_matching_fwnode(acpi_get_gsi_domain_id(gsi),\n\t\t\t\t\tDOMAIN_BUS_ANY);\n\t*irq = irq_find_mapping(d, gsi);\n\t \n\tif (!*irq && acpi_gsi_to_irq_fallback)\n\t\t*irq = acpi_gsi_to_irq_fallback(gsi);\n\n\treturn (*irq > 0) ? 0 : -EINVAL;\n}\nEXPORT_SYMBOL_GPL(acpi_gsi_to_irq);\n\n \nint acpi_register_gsi(struct device *dev, u32 gsi, int trigger,\n\t\t      int polarity)\n{\n\tstruct irq_fwspec fwspec;\n\tunsigned int irq;\n\n\tfwspec.fwnode = acpi_get_gsi_domain_id(gsi);\n\tif (WARN_ON(!fwspec.fwnode)) {\n\t\tpr_warn(\"GSI: No registered irqchip, giving up\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfwspec.param[0] = gsi;\n\tfwspec.param[1] = acpi_dev_get_irq_type(trigger, polarity);\n\tfwspec.param_count = 2;\n\n\tirq = irq_create_fwspec_mapping(&fwspec);\n\tif (!irq)\n\t\treturn -EINVAL;\n\n\treturn irq;\n}\nEXPORT_SYMBOL_GPL(acpi_register_gsi);\n\n \nvoid acpi_unregister_gsi(u32 gsi)\n{\n\tstruct irq_domain *d;\n\tint irq;\n\n\tif (WARN_ON(acpi_irq_model == ACPI_IRQ_MODEL_GIC && gsi < 16))\n\t\treturn;\n\n\td = irq_find_matching_fwnode(acpi_get_gsi_domain_id(gsi),\n\t\t\t\t     DOMAIN_BUS_ANY);\n\tirq = irq_find_mapping(d, gsi);\n\tirq_dispose_mapping(irq);\n}\nEXPORT_SYMBOL_GPL(acpi_unregister_gsi);\n\n \nstatic struct fwnode_handle *\nacpi_get_irq_source_fwhandle(const struct acpi_resource_source *source,\n\t\t\t     u32 gsi)\n{\n\tstruct fwnode_handle *result;\n\tstruct acpi_device *device;\n\tacpi_handle handle;\n\tacpi_status status;\n\n\tif (!source->string_length)\n\t\treturn acpi_get_gsi_domain_id(gsi);\n\n\tstatus = acpi_get_handle(NULL, source->string_ptr, &handle);\n\tif (WARN_ON(ACPI_FAILURE(status)))\n\t\treturn NULL;\n\n\tdevice = acpi_get_acpi_dev(handle);\n\tif (WARN_ON(!device))\n\t\treturn NULL;\n\n\tresult = &device->fwnode;\n\tacpi_put_acpi_dev(device);\n\treturn result;\n}\n\n \nstruct acpi_irq_parse_one_ctx {\n\tint rc;\n\tunsigned int index;\n\tunsigned long *res_flags;\n\tstruct irq_fwspec *fwspec;\n};\n\n \nstatic inline void acpi_irq_parse_one_match(struct fwnode_handle *fwnode,\n\t\t\t\t\t    u32 hwirq, u8 triggering,\n\t\t\t\t\t    u8 polarity, u8 shareable,\n\t\t\t\t\t    u8 wake_capable,\n\t\t\t\t\t    struct acpi_irq_parse_one_ctx *ctx)\n{\n\tif (!fwnode)\n\t\treturn;\n\tctx->rc = 0;\n\t*ctx->res_flags = acpi_dev_irq_flags(triggering, polarity, shareable, wake_capable);\n\tctx->fwspec->fwnode = fwnode;\n\tctx->fwspec->param[0] = hwirq;\n\tctx->fwspec->param[1] = acpi_dev_get_irq_type(triggering, polarity);\n\tctx->fwspec->param_count = 2;\n}\n\n \nstatic acpi_status acpi_irq_parse_one_cb(struct acpi_resource *ares,\n\t\t\t\t\t void *context)\n{\n\tstruct acpi_irq_parse_one_ctx *ctx = context;\n\tstruct acpi_resource_irq *irq;\n\tstruct acpi_resource_extended_irq *eirq;\n\tstruct fwnode_handle *fwnode;\n\n\tswitch (ares->type) {\n\tcase ACPI_RESOURCE_TYPE_IRQ:\n\t\tirq = &ares->data.irq;\n\t\tif (ctx->index >= irq->interrupt_count) {\n\t\t\tctx->index -= irq->interrupt_count;\n\t\t\treturn AE_OK;\n\t\t}\n\t\tfwnode = acpi_get_gsi_domain_id(irq->interrupts[ctx->index]);\n\t\tacpi_irq_parse_one_match(fwnode, irq->interrupts[ctx->index],\n\t\t\t\t\t irq->triggering, irq->polarity,\n\t\t\t\t\t irq->shareable, irq->wake_capable, ctx);\n\t\treturn AE_CTRL_TERMINATE;\n\tcase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\n\t\teirq = &ares->data.extended_irq;\n\t\tif (eirq->producer_consumer == ACPI_PRODUCER)\n\t\t\treturn AE_OK;\n\t\tif (ctx->index >= eirq->interrupt_count) {\n\t\t\tctx->index -= eirq->interrupt_count;\n\t\t\treturn AE_OK;\n\t\t}\n\t\tfwnode = acpi_get_irq_source_fwhandle(&eirq->resource_source,\n\t\t\t\t\t\t      eirq->interrupts[ctx->index]);\n\t\tacpi_irq_parse_one_match(fwnode, eirq->interrupts[ctx->index],\n\t\t\t\t\t eirq->triggering, eirq->polarity,\n\t\t\t\t\t eirq->shareable, eirq->wake_capable, ctx);\n\t\treturn AE_CTRL_TERMINATE;\n\t}\n\n\treturn AE_OK;\n}\n\n \nstatic int acpi_irq_parse_one(acpi_handle handle, unsigned int index,\n\t\t\t      struct irq_fwspec *fwspec, unsigned long *flags)\n{\n\tstruct acpi_irq_parse_one_ctx ctx = { -EINVAL, index, flags, fwspec };\n\n\tacpi_walk_resources(handle, METHOD_NAME__CRS, acpi_irq_parse_one_cb, &ctx);\n\treturn ctx.rc;\n}\n\n \nint acpi_irq_get(acpi_handle handle, unsigned int index, struct resource *res)\n{\n\tstruct irq_fwspec fwspec;\n\tstruct irq_domain *domain;\n\tunsigned long flags;\n\tint rc;\n\n\trc = acpi_irq_parse_one(handle, index, &fwspec, &flags);\n\tif (rc)\n\t\treturn rc;\n\n\tdomain = irq_find_matching_fwnode(fwspec.fwnode, DOMAIN_BUS_ANY);\n\tif (!domain)\n\t\treturn -EPROBE_DEFER;\n\n\trc = irq_create_fwspec_mapping(&fwspec);\n\tif (rc <= 0)\n\t\treturn -EINVAL;\n\n\tres->start = rc;\n\tres->end = rc;\n\tres->flags = flags;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_irq_get);\n\n \nvoid __init acpi_set_irq_model(enum acpi_irq_model_id model,\n\t\t\t       struct fwnode_handle *(*fn)(u32))\n{\n\tacpi_irq_model = model;\n\tacpi_get_gsi_domain_id = fn;\n}\n\n \nvoid __init acpi_set_gsi_to_irq_fallback(u32 (*fn)(u32))\n{\n\tacpi_gsi_to_irq_fallback = fn;\n}\n\n \nstruct irq_domain *acpi_irq_create_hierarchy(unsigned int flags,\n\t\t\t\t\t     unsigned int size,\n\t\t\t\t\t     struct fwnode_handle *fwnode,\n\t\t\t\t\t     const struct irq_domain_ops *ops,\n\t\t\t\t\t     void *host_data)\n{\n\tstruct irq_domain *d;\n\n\t \n\tif (acpi_irq_model != ACPI_IRQ_MODEL_GIC)\n\t\treturn NULL;\n\n\td = irq_find_matching_fwnode(acpi_get_gsi_domain_id(0),\n\t\t\t\t     DOMAIN_BUS_ANY);\n\n\tif (!d)\n\t\treturn NULL;\n\n\treturn irq_domain_create_hierarchy(d, flags, size, fwnode, ops,\n\t\t\t\t\t   host_data);\n}\nEXPORT_SYMBOL_GPL(acpi_irq_create_hierarchy);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}